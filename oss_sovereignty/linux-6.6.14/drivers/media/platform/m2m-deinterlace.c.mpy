{
  "module_name": "m2m-deinterlace.c",
  "hash_id": "9b9ed60114ebf1f1b623deded4f8ae024ec1329efca44e6e26b52c8660673e16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/m2m-deinterlace.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/dmaengine.h>\n#include <linux/platform_device.h>\n\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-dma-contig.h>\n\n#define MEM2MEM_TEST_MODULE_NAME \"mem2mem-deinterlace\"\n\nMODULE_DESCRIPTION(\"mem2mem device which supports deinterlacing using dmaengine\");\nMODULE_AUTHOR(\"Javier Martin <javier.martin@vista-silicon.com\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.0.1\");\n\nstatic bool debug;\nmodule_param(debug, bool, 0644);\n\n \n#define MEM2MEM_CAPTURE\t(1 << 0)\n#define MEM2MEM_OUTPUT\t(1 << 1)\n\n#define MEM2MEM_NAME\t\t\"m2m-deinterlace\"\n\n#define dprintk(dev, fmt, arg...) \\\n\tv4l2_dbg(1, debug, &dev->v4l2_dev, \"%s: \" fmt, __func__, ## arg)\n\nstruct deinterlace_fmt {\n\tu32\tfourcc;\n\t \n\tu32\ttypes;\n};\n\nstatic struct deinterlace_fmt formats[] = {\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_YUV420,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_YUYV,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t},\n};\n\n#define NUM_FORMATS ARRAY_SIZE(formats)\n\n \nstruct deinterlace_q_data {\n\tunsigned int\t\twidth;\n\tunsigned int\t\theight;\n\tunsigned int\t\tsizeimage;\n\tstruct deinterlace_fmt\t*fmt;\n\tenum v4l2_field\t\tfield;\n};\n\nenum {\n\tV4L2_M2M_SRC = 0,\n\tV4L2_M2M_DST = 1,\n};\n\nenum {\n\tYUV420_DMA_Y_ODD,\n\tYUV420_DMA_Y_EVEN,\n\tYUV420_DMA_U_ODD,\n\tYUV420_DMA_U_EVEN,\n\tYUV420_DMA_V_ODD,\n\tYUV420_DMA_V_EVEN,\n\tYUV420_DMA_Y_ODD_DOUBLING,\n\tYUV420_DMA_U_ODD_DOUBLING,\n\tYUV420_DMA_V_ODD_DOUBLING,\n\tYUYV_DMA_ODD,\n\tYUYV_DMA_EVEN,\n\tYUYV_DMA_EVEN_DOUBLING,\n};\n\n \nstatic struct deinterlace_q_data q_data[2];\n\nstatic struct deinterlace_q_data *get_q_data(enum v4l2_buf_type type)\n{\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\treturn &q_data[V4L2_M2M_SRC];\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn &q_data[V4L2_M2M_DST];\n\tdefault:\n\t\tBUG();\n\t}\n\treturn NULL;\n}\n\nstatic struct deinterlace_fmt *find_format(struct v4l2_format *f)\n{\n\tstruct deinterlace_fmt *fmt;\n\tunsigned int k;\n\n\tfor (k = 0; k < NUM_FORMATS; k++) {\n\t\tfmt = &formats[k];\n\t\tif ((fmt->types & f->type) &&\n\t\t\t(fmt->fourcc == f->fmt.pix.pixelformat))\n\t\t\tbreak;\n\t}\n\n\tif (k == NUM_FORMATS)\n\t\treturn NULL;\n\n\treturn &formats[k];\n}\n\nstruct deinterlace_dev {\n\tstruct v4l2_device\tv4l2_dev;\n\tstruct video_device\tvfd;\n\n\tatomic_t\t\tbusy;\n\tstruct mutex\t\tdev_mutex;\n\tspinlock_t\t\tirqlock;\n\n\tstruct dma_chan\t\t*dma_chan;\n\n\tstruct v4l2_m2m_dev\t*m2m_dev;\n};\n\nstruct deinterlace_ctx {\n\tstruct v4l2_fh\t\tfh;\n\tstruct deinterlace_dev\t*dev;\n\n\t \n\tint\t\t\taborting;\n\tenum v4l2_colorspace\tcolorspace;\n\tdma_cookie_t\t\tcookie;\n\tstruct dma_interleaved_template *xt;\n};\n\n \nstatic int deinterlace_job_ready(void *priv)\n{\n\tstruct deinterlace_ctx *ctx = priv;\n\tstruct deinterlace_dev *pcdev = ctx->dev;\n\n\tif (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) > 0 &&\n\t    v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) > 0 &&\n\t    !atomic_read(&ctx->dev->busy)) {\n\t\tdprintk(pcdev, \"Task ready\\n\");\n\t\treturn 1;\n\t}\n\n\tdprintk(pcdev, \"Task not ready to run\\n\");\n\n\treturn 0;\n}\n\nstatic void deinterlace_job_abort(void *priv)\n{\n\tstruct deinterlace_ctx *ctx = priv;\n\tstruct deinterlace_dev *pcdev = ctx->dev;\n\n\tctx->aborting = 1;\n\n\tdprintk(pcdev, \"Aborting task\\n\");\n\n\tv4l2_m2m_job_finish(pcdev->m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic void dma_callback(void *data)\n{\n\tstruct deinterlace_ctx *curr_ctx = data;\n\tstruct deinterlace_dev *pcdev = curr_ctx->dev;\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\n\tatomic_set(&pcdev->busy, 0);\n\n\tsrc_vb = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\n\tdst_vb = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\n\n\tdst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;\n\tdst_vb->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst_vb->flags |=\n\t\tsrc_vb->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst_vb->timecode = src_vb->timecode;\n\n\tv4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_DONE);\n\n\tv4l2_m2m_job_finish(pcdev->m2m_dev, curr_ctx->fh.m2m_ctx);\n\n\tdprintk(pcdev, \"dma transfers completed.\\n\");\n}\n\nstatic void deinterlace_issue_dma(struct deinterlace_ctx *ctx, int op,\n\t\t\t\t  int do_callback)\n{\n\tstruct deinterlace_q_data *s_q_data;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct deinterlace_dev *pcdev = ctx->dev;\n\tstruct dma_chan *chan = pcdev->dma_chan;\n\tstruct dma_device *dmadev = chan->device;\n\tstruct dma_async_tx_descriptor *tx;\n\tunsigned int s_width, s_height;\n\tunsigned int s_size;\n\tdma_addr_t p_in, p_out;\n\tenum dma_ctrl_flags flags;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\ts_q_data = get_q_data(V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\ts_width\t= s_q_data->width;\n\ts_height = s_q_data->height;\n\ts_size = s_width * s_height;\n\n\tp_in = (dma_addr_t)vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\n\tp_out = (dma_addr_t)vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf,\n\t\t\t\t\t\t\t  0);\n\tif (!p_in || !p_out) {\n\t\tv4l2_err(&pcdev->v4l2_dev,\n\t\t\t \"Acquiring kernel pointers to buffers failed\\n\");\n\t\treturn;\n\t}\n\n\tswitch (op) {\n\tcase YUV420_DMA_Y_ODD:\n\t\tctx->xt->numf = s_height / 2;\n\t\tctx->xt->sgl[0].size = s_width;\n\t\tctx->xt->sgl[0].icg = s_width;\n\t\tctx->xt->src_start = p_in;\n\t\tctx->xt->dst_start = p_out;\n\t\tbreak;\n\tcase YUV420_DMA_Y_EVEN:\n\t\tctx->xt->numf = s_height / 2;\n\t\tctx->xt->sgl[0].size = s_width;\n\t\tctx->xt->sgl[0].icg = s_width;\n\t\tctx->xt->src_start = p_in + s_size / 2;\n\t\tctx->xt->dst_start = p_out + s_width;\n\t\tbreak;\n\tcase YUV420_DMA_U_ODD:\n\t\tctx->xt->numf = s_height / 4;\n\t\tctx->xt->sgl[0].size = s_width / 2;\n\t\tctx->xt->sgl[0].icg = s_width / 2;\n\t\tctx->xt->src_start = p_in + s_size;\n\t\tctx->xt->dst_start = p_out + s_size;\n\t\tbreak;\n\tcase YUV420_DMA_U_EVEN:\n\t\tctx->xt->numf = s_height / 4;\n\t\tctx->xt->sgl[0].size = s_width / 2;\n\t\tctx->xt->sgl[0].icg = s_width / 2;\n\t\tctx->xt->src_start = p_in + (9 * s_size) / 8;\n\t\tctx->xt->dst_start = p_out + s_size + s_width / 2;\n\t\tbreak;\n\tcase YUV420_DMA_V_ODD:\n\t\tctx->xt->numf = s_height / 4;\n\t\tctx->xt->sgl[0].size = s_width / 2;\n\t\tctx->xt->sgl[0].icg = s_width / 2;\n\t\tctx->xt->src_start = p_in + (5 * s_size) / 4;\n\t\tctx->xt->dst_start = p_out + (5 * s_size) / 4;\n\t\tbreak;\n\tcase YUV420_DMA_V_EVEN:\n\t\tctx->xt->numf = s_height / 4;\n\t\tctx->xt->sgl[0].size = s_width / 2;\n\t\tctx->xt->sgl[0].icg = s_width / 2;\n\t\tctx->xt->src_start = p_in + (11 * s_size) / 8;\n\t\tctx->xt->dst_start = p_out + (5 * s_size) / 4 + s_width / 2;\n\t\tbreak;\n\tcase YUV420_DMA_Y_ODD_DOUBLING:\n\t\tctx->xt->numf = s_height / 2;\n\t\tctx->xt->sgl[0].size = s_width;\n\t\tctx->xt->sgl[0].icg = s_width;\n\t\tctx->xt->src_start = p_in;\n\t\tctx->xt->dst_start = p_out + s_width;\n\t\tbreak;\n\tcase YUV420_DMA_U_ODD_DOUBLING:\n\t\tctx->xt->numf = s_height / 4;\n\t\tctx->xt->sgl[0].size = s_width / 2;\n\t\tctx->xt->sgl[0].icg = s_width / 2;\n\t\tctx->xt->src_start = p_in + s_size;\n\t\tctx->xt->dst_start = p_out + s_size + s_width / 2;\n\t\tbreak;\n\tcase YUV420_DMA_V_ODD_DOUBLING:\n\t\tctx->xt->numf = s_height / 4;\n\t\tctx->xt->sgl[0].size = s_width / 2;\n\t\tctx->xt->sgl[0].icg = s_width / 2;\n\t\tctx->xt->src_start = p_in + (5 * s_size) / 4;\n\t\tctx->xt->dst_start = p_out + (5 * s_size) / 4 + s_width / 2;\n\t\tbreak;\n\tcase YUYV_DMA_ODD:\n\t\tctx->xt->numf = s_height / 2;\n\t\tctx->xt->sgl[0].size = s_width * 2;\n\t\tctx->xt->sgl[0].icg = s_width * 2;\n\t\tctx->xt->src_start = p_in;\n\t\tctx->xt->dst_start = p_out;\n\t\tbreak;\n\tcase YUYV_DMA_EVEN:\n\t\tctx->xt->numf = s_height / 2;\n\t\tctx->xt->sgl[0].size = s_width * 2;\n\t\tctx->xt->sgl[0].icg = s_width * 2;\n\t\tctx->xt->src_start = p_in + s_size;\n\t\tctx->xt->dst_start = p_out + s_width * 2;\n\t\tbreak;\n\tcase YUYV_DMA_EVEN_DOUBLING:\n\tdefault:\n\t\tctx->xt->numf = s_height / 2;\n\t\tctx->xt->sgl[0].size = s_width * 2;\n\t\tctx->xt->sgl[0].icg = s_width * 2;\n\t\tctx->xt->src_start = p_in;\n\t\tctx->xt->dst_start = p_out + s_width * 2;\n\t\tbreak;\n\t}\n\n\t \n\tctx->xt->frame_size = 1;\n\tctx->xt->dir = DMA_MEM_TO_MEM;\n\tctx->xt->src_sgl = false;\n\tctx->xt->dst_sgl = true;\n\tflags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\n\n\ttx = dmadev->device_prep_interleaved_dma(chan, ctx->xt, flags);\n\tif (tx == NULL) {\n\t\tv4l2_warn(&pcdev->v4l2_dev, \"DMA interleaved prep error\\n\");\n\t\treturn;\n\t}\n\n\tif (do_callback) {\n\t\ttx->callback = dma_callback;\n\t\ttx->callback_param = ctx;\n\t}\n\n\tctx->cookie = dmaengine_submit(tx);\n\tif (dma_submit_error(ctx->cookie)) {\n\t\tv4l2_warn(&pcdev->v4l2_dev,\n\t\t\t  \"DMA submit error %d with src=0x%x dst=0x%x len=0x%x\\n\",\n\t\t\t  ctx->cookie, (unsigned)p_in, (unsigned)p_out,\n\t\t\t  s_size * 3/2);\n\t\treturn;\n\t}\n\n\tdma_async_issue_pending(chan);\n}\n\nstatic void deinterlace_device_run(void *priv)\n{\n\tstruct deinterlace_ctx *ctx = priv;\n\tstruct deinterlace_q_data *dst_q_data;\n\n\tatomic_set(&ctx->dev->busy, 1);\n\n\tdprintk(ctx->dev, \"%s: DMA try issue.\\n\", __func__);\n\n\tdst_q_data = get_q_data(V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\t \n\tswitch (dst_q_data->fmt->fourcc) {\n\tcase V4L2_PIX_FMT_YUV420:\n\t\tswitch (dst_q_data->field) {\n\t\tcase V4L2_FIELD_INTERLACED_TB:\n\t\tcase V4L2_FIELD_INTERLACED_BT:\n\t\t\tdprintk(ctx->dev, \"%s: yuv420 interlaced tb.\\n\",\n\t\t\t\t__func__);\n\t\t\tdeinterlace_issue_dma(ctx, YUV420_DMA_Y_ODD, 0);\n\t\t\tdeinterlace_issue_dma(ctx, YUV420_DMA_Y_EVEN, 0);\n\t\t\tdeinterlace_issue_dma(ctx, YUV420_DMA_U_ODD, 0);\n\t\t\tdeinterlace_issue_dma(ctx, YUV420_DMA_U_EVEN, 0);\n\t\t\tdeinterlace_issue_dma(ctx, YUV420_DMA_V_ODD, 0);\n\t\t\tdeinterlace_issue_dma(ctx, YUV420_DMA_V_EVEN, 1);\n\t\t\tbreak;\n\t\tcase V4L2_FIELD_NONE:\n\t\tdefault:\n\t\t\tdprintk(ctx->dev, \"%s: yuv420 interlaced line doubling.\\n\",\n\t\t\t\t__func__);\n\t\t\tdeinterlace_issue_dma(ctx, YUV420_DMA_Y_ODD, 0);\n\t\t\tdeinterlace_issue_dma(ctx, YUV420_DMA_Y_ODD_DOUBLING, 0);\n\t\t\tdeinterlace_issue_dma(ctx, YUV420_DMA_U_ODD, 0);\n\t\t\tdeinterlace_issue_dma(ctx, YUV420_DMA_U_ODD_DOUBLING, 0);\n\t\t\tdeinterlace_issue_dma(ctx, YUV420_DMA_V_ODD, 0);\n\t\t\tdeinterlace_issue_dma(ctx, YUV420_DMA_V_ODD_DOUBLING, 1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\tdefault:\n\t\tswitch (dst_q_data->field) {\n\t\tcase V4L2_FIELD_INTERLACED_TB:\n\t\tcase V4L2_FIELD_INTERLACED_BT:\n\t\t\tdprintk(ctx->dev, \"%s: yuyv interlaced_tb.\\n\",\n\t\t\t\t__func__);\n\t\t\tdeinterlace_issue_dma(ctx, YUYV_DMA_ODD, 0);\n\t\t\tdeinterlace_issue_dma(ctx, YUYV_DMA_EVEN, 1);\n\t\t\tbreak;\n\t\tcase V4L2_FIELD_NONE:\n\t\tdefault:\n\t\t\tdprintk(ctx->dev, \"%s: yuyv interlaced line doubling.\\n\",\n\t\t\t\t__func__);\n\t\t\tdeinterlace_issue_dma(ctx, YUYV_DMA_ODD, 0);\n\t\t\tdeinterlace_issue_dma(ctx, YUYV_DMA_EVEN_DOUBLING, 1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdprintk(ctx->dev, \"%s: DMA issue done.\\n\", __func__);\n}\n\n \nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, MEM2MEM_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, MEM2MEM_NAME, sizeof(cap->card));\n\tstrscpy(cap->bus_info, MEM2MEM_NAME, sizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic int enum_fmt(struct v4l2_fmtdesc *f, u32 type)\n{\n\tint i, num;\n\tstruct deinterlace_fmt *fmt;\n\n\tnum = 0;\n\n\tfor (i = 0; i < NUM_FORMATS; ++i) {\n\t\tif (formats[i].types & type) {\n\t\t\t \n\t\t\tif (num == f->index)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\t++num;\n\t\t}\n\t}\n\n\tif (i < NUM_FORMATS) {\n\t\t \n\t\tfmt = &formats[i];\n\t\tf->pixelformat = fmt->fourcc;\n\t\treturn 0;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn enum_fmt(f, MEM2MEM_CAPTURE);\n}\n\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn enum_fmt(f, MEM2MEM_OUTPUT);\n}\n\nstatic int vidioc_g_fmt(struct deinterlace_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct deinterlace_q_data *q_data;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(f->type);\n\n\tf->fmt.pix.width\t= q_data->width;\n\tf->fmt.pix.height\t= q_data->height;\n\tf->fmt.pix.field\t= q_data->field;\n\tf->fmt.pix.pixelformat\t= q_data->fmt->fourcc;\n\n\tswitch (q_data->fmt->fourcc) {\n\tcase V4L2_PIX_FMT_YUV420:\n\t\tf->fmt.pix.bytesperline = q_data->width * 3 / 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\tdefault:\n\t\tf->fmt.pix.bytesperline = q_data->width * 2;\n\t}\n\n\tf->fmt.pix.sizeimage\t= q_data->sizeimage;\n\tf->fmt.pix.colorspace\t= ctx->colorspace;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\treturn vidioc_g_fmt(priv, f);\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\treturn vidioc_g_fmt(priv, f);\n}\n\nstatic int vidioc_try_fmt(struct v4l2_format *f, struct deinterlace_fmt *fmt)\n{\n\tswitch (f->fmt.pix.pixelformat) {\n\tcase V4L2_PIX_FMT_YUV420:\n\t\tf->fmt.pix.bytesperline = f->fmt.pix.width * 3 / 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\tdefault:\n\t\tf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\n\t}\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct deinterlace_fmt *fmt;\n\tstruct deinterlace_ctx *ctx = priv;\n\n\tfmt = find_format(f);\n\tif (!fmt || !(fmt->types & MEM2MEM_CAPTURE))\n\t\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;\n\n\tf->fmt.pix.colorspace = ctx->colorspace;\n\n\tif (f->fmt.pix.field != V4L2_FIELD_INTERLACED_TB &&\n\t    f->fmt.pix.field != V4L2_FIELD_INTERLACED_BT &&\n\t    f->fmt.pix.field != V4L2_FIELD_NONE)\n\t\tf->fmt.pix.field = V4L2_FIELD_INTERLACED_TB;\n\n\treturn vidioc_try_fmt(f, fmt);\n}\n\nstatic int vidioc_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct deinterlace_fmt *fmt;\n\n\tfmt = find_format(f);\n\tif (!fmt || !(fmt->types & MEM2MEM_OUTPUT))\n\t\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;\n\n\tif (!f->fmt.pix.colorspace)\n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\n\n\tif (f->fmt.pix.field != V4L2_FIELD_SEQ_TB &&\n\t    f->fmt.pix.field != V4L2_FIELD_SEQ_BT)\n\t\tf->fmt.pix.field = V4L2_FIELD_SEQ_TB;\n\n\treturn vidioc_try_fmt(f, fmt);\n}\n\nstatic int vidioc_s_fmt(struct deinterlace_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct deinterlace_q_data *q_data;\n\tstruct vb2_queue *vq;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(f->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"%s queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tq_data->fmt = find_format(f);\n\tif (!q_data->fmt) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"Couldn't set format type %d, wxh: %dx%d. fmt: %d, field: %d\\n\",\n\t\t\tf->type, f->fmt.pix.width, f->fmt.pix.height,\n\t\t\tf->fmt.pix.pixelformat, f->fmt.pix.field);\n\t\treturn -EINVAL;\n\t}\n\n\tq_data->width\t\t= f->fmt.pix.width;\n\tq_data->height\t\t= f->fmt.pix.height;\n\tq_data->field\t\t= f->fmt.pix.field;\n\n\tswitch (f->fmt.pix.pixelformat) {\n\tcase V4L2_PIX_FMT_YUV420:\n\t\tf->fmt.pix.bytesperline = f->fmt.pix.width * 3 / 2;\n\t\tq_data->sizeimage = (q_data->width * q_data->height * 3) / 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\tdefault:\n\t\tf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\n\t\tq_data->sizeimage = q_data->width * q_data->height * 2;\n\t}\n\n\tdprintk(ctx->dev,\n\t\t\"Setting format for type %d, wxh: %dx%d, fmt: %d, field: %d\\n\",\n\t\tf->type, q_data->width, q_data->height, q_data->fmt->fourcc,\n\t\tq_data->field);\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tint ret;\n\n\tret = vidioc_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\treturn vidioc_s_fmt(priv, f);\n}\n\nstatic int vidioc_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct deinterlace_ctx *ctx = priv;\n\tint ret;\n\n\tret = vidioc_try_fmt_vid_out(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vidioc_s_fmt(priv, f);\n\tif (!ret)\n\t\tctx->colorspace = f->fmt.pix.colorspace;\n\n\treturn ret;\n}\n\nstatic int vidioc_streamon(struct file *file, void *priv,\n\t\t\t   enum v4l2_buf_type type)\n{\n\tstruct deinterlace_q_data *s_q_data, *d_q_data;\n\tstruct deinterlace_ctx *ctx = priv;\n\n\ts_q_data = get_q_data(V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\td_q_data = get_q_data(V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\t \n\tif (s_q_data->fmt->fourcc != d_q_data->fmt->fourcc) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"src and dst formats don't match.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (s_q_data->field) {\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tif (d_q_data->field != V4L2_FIELD_NONE &&\n\t\t\td_q_data->field != V4L2_FIELD_INTERLACED_BT) {\n\t\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"src and dst field conversion [(%d)->(%d)] not supported.\\n\",\n\t\t\t\ts_q_data->field, d_q_data->field);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase V4L2_FIELD_SEQ_TB:\n\t\tif (d_q_data->field != V4L2_FIELD_NONE &&\n\t\t\td_q_data->field != V4L2_FIELD_INTERLACED_TB) {\n\t\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"src and dst field conversion [(%d)->(%d)] not supported.\\n\",\n\t\t\t\ts_q_data->field, d_q_data->field);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn v4l2_m2m_streamon(file, ctx->fh.m2m_ctx, type);\n}\n\nstatic const struct v4l2_ioctl_ops deinterlace_ioctl_ops = {\n\t.vidioc_querycap\t= vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t= vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t= vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t= vidioc_s_fmt_vid_cap,\n\n\t.vidioc_enum_fmt_vid_out = vidioc_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out\t= vidioc_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t= vidioc_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t= vidioc_s_fmt_vid_out,\n\n\t.vidioc_reqbufs\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_expbuf\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon\t= vidioc_streamon,\n\t.vidioc_streamoff\t= v4l2_m2m_ioctl_streamoff,\n};\n\n\n \nstruct vb2_dc_conf {\n\tstruct device           *dev;\n};\n\nstatic int deinterlace_queue_setup(struct vb2_queue *vq,\n\t\t\t\tunsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct deinterlace_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct deinterlace_q_data *q_data;\n\tunsigned int size, count = *nbuffers;\n\n\tq_data = get_q_data(vq->type);\n\n\tswitch (q_data->fmt->fourcc) {\n\tcase V4L2_PIX_FMT_YUV420:\n\t\tsize = q_data->width * q_data->height * 3 / 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\tdefault:\n\t\tsize = q_data->width * q_data->height * 2;\n\t}\n\n\t*nplanes = 1;\n\t*nbuffers = count;\n\tsizes[0] = size;\n\n\tdprintk(ctx->dev, \"get %d buffer(s) of size %d each.\\n\", count, size);\n\n\treturn 0;\n}\n\nstatic int deinterlace_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct deinterlace_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct deinterlace_q_data *q_data;\n\n\tdprintk(ctx->dev, \"type: %d\\n\", vb->vb2_queue->type);\n\n\tq_data = get_q_data(vb->vb2_queue->type);\n\n\tif (vb2_plane_size(vb, 0) < q_data->sizeimage) {\n\t\tdprintk(ctx->dev, \"%s data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t__func__, vb2_plane_size(vb, 0), (long)q_data->sizeimage);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, q_data->sizeimage);\n\n\treturn 0;\n}\n\nstatic void deinterlace_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct deinterlace_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic const struct vb2_ops deinterlace_qops = {\n\t.queue_setup\t = deinterlace_queue_setup,\n\t.buf_prepare\t = deinterlace_buf_prepare,\n\t.buf_queue\t = deinterlace_buf_queue,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n};\n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct deinterlace_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->ops = &deinterlace_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->dev = ctx->dev->v4l2_dev.dev;\n\tsrc_vq->lock = &ctx->dev->dev_mutex;\n\tq_data[V4L2_M2M_SRC].fmt = &formats[0];\n\tq_data[V4L2_M2M_SRC].width = 640;\n\tq_data[V4L2_M2M_SRC].height = 480;\n\tq_data[V4L2_M2M_SRC].sizeimage = (640 * 480 * 3) / 2;\n\tq_data[V4L2_M2M_SRC].field = V4L2_FIELD_SEQ_TB;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops = &deinterlace_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->dev = ctx->dev->v4l2_dev.dev;\n\tdst_vq->lock = &ctx->dev->dev_mutex;\n\tq_data[V4L2_M2M_DST].fmt = &formats[0];\n\tq_data[V4L2_M2M_DST].width = 640;\n\tq_data[V4L2_M2M_DST].height = 480;\n\tq_data[V4L2_M2M_DST].sizeimage = (640 * 480 * 3) / 2;\n\tq_data[V4L2_M2M_SRC].field = V4L2_FIELD_INTERLACED_TB;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\n \nstatic int deinterlace_open(struct file *file)\n{\n\tstruct deinterlace_dev *pcdev = video_drvdata(file);\n\tstruct deinterlace_ctx *ctx = NULL;\n\n\tctx = kzalloc(sizeof *ctx, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tctx->dev = pcdev;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(pcdev->m2m_dev, ctx, &queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tint ret = PTR_ERR(ctx->fh.m2m_ctx);\n\n\t\tkfree(ctx);\n\t\treturn ret;\n\t}\n\n\tctx->xt = kzalloc(sizeof(struct dma_interleaved_template) +\n\t\t\t\tsizeof(struct data_chunk), GFP_KERNEL);\n\tif (!ctx->xt) {\n\t\tkfree(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->colorspace = V4L2_COLORSPACE_REC709;\n\tv4l2_fh_add(&ctx->fh);\n\n\tdprintk(pcdev, \"Created instance %p, m2m_ctx: %p\\n\",\n\t\tctx, ctx->fh.m2m_ctx);\n\n\treturn 0;\n}\n\nstatic int deinterlace_release(struct file *file)\n{\n\tstruct deinterlace_dev *pcdev = video_drvdata(file);\n\tstruct deinterlace_ctx *ctx = file->private_data;\n\n\tdprintk(pcdev, \"Releasing instance %p\\n\", ctx);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tkfree(ctx->xt);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations deinterlace_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= deinterlace_open,\n\t.release\t= deinterlace_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct video_device deinterlace_videodev = {\n\t.name\t\t= MEM2MEM_NAME,\n\t.fops\t\t= &deinterlace_fops,\n\t.ioctl_ops\t= &deinterlace_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= video_device_release_empty,\n\t.vfl_dir\t= VFL_DIR_M2M,\n\t.device_caps\t= V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING,\n};\n\nstatic const struct v4l2_m2m_ops m2m_ops = {\n\t.device_run\t= deinterlace_device_run,\n\t.job_ready\t= deinterlace_job_ready,\n\t.job_abort\t= deinterlace_job_abort,\n};\n\nstatic int deinterlace_probe(struct platform_device *pdev)\n{\n\tstruct deinterlace_dev *pcdev;\n\tstruct video_device *vfd;\n\tdma_cap_mask_t mask;\n\tint ret = 0;\n\n\tpcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);\n\tif (!pcdev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&pcdev->irqlock);\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_INTERLEAVE, mask);\n\tpcdev->dma_chan = dma_request_channel(mask, NULL, pcdev);\n\tif (!pcdev->dma_chan)\n\t\treturn -ENODEV;\n\n\tif (!dma_has_cap(DMA_INTERLEAVE, pcdev->dma_chan->device->cap_mask)) {\n\t\tdev_err(&pdev->dev, \"DMA does not support INTERLEAVE\\n\");\n\t\tret = -ENODEV;\n\t\tgoto rel_dma;\n\t}\n\n\tret = v4l2_device_register(&pdev->dev, &pcdev->v4l2_dev);\n\tif (ret)\n\t\tgoto rel_dma;\n\n\tatomic_set(&pcdev->busy, 0);\n\tmutex_init(&pcdev->dev_mutex);\n\n\tvfd = &pcdev->vfd;\n\t*vfd = deinterlace_videodev;\n\tvfd->lock = &pcdev->dev_mutex;\n\tvfd->v4l2_dev = &pcdev->v4l2_dev;\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&pcdev->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto unreg_dev;\n\t}\n\n\tvideo_set_drvdata(vfd, pcdev);\n\tv4l2_info(&pcdev->v4l2_dev, MEM2MEM_TEST_MODULE_NAME\n\t\t\t\" Device registered as /dev/video%d\\n\", vfd->num);\n\n\tplatform_set_drvdata(pdev, pcdev);\n\n\tpcdev->m2m_dev = v4l2_m2m_init(&m2m_ops);\n\tif (IS_ERR(pcdev->m2m_dev)) {\n\t\tv4l2_err(&pcdev->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(pcdev->m2m_dev);\n\t\tgoto err_m2m;\n\t}\n\n\treturn 0;\n\nerr_m2m:\n\tvideo_unregister_device(&pcdev->vfd);\nunreg_dev:\n\tv4l2_device_unregister(&pcdev->v4l2_dev);\nrel_dma:\n\tdma_release_channel(pcdev->dma_chan);\n\n\treturn ret;\n}\n\nstatic void deinterlace_remove(struct platform_device *pdev)\n{\n\tstruct deinterlace_dev *pcdev = platform_get_drvdata(pdev);\n\n\tv4l2_info(&pcdev->v4l2_dev, \"Removing \" MEM2MEM_TEST_MODULE_NAME);\n\tv4l2_m2m_release(pcdev->m2m_dev);\n\tvideo_unregister_device(&pcdev->vfd);\n\tv4l2_device_unregister(&pcdev->v4l2_dev);\n\tdma_release_channel(pcdev->dma_chan);\n}\n\nstatic struct platform_driver deinterlace_pdrv = {\n\t.probe\t\t= deinterlace_probe,\n\t.remove_new\t= deinterlace_remove,\n\t.driver\t\t= {\n\t\t.name\t= MEM2MEM_NAME,\n\t},\n};\nmodule_platform_driver(deinterlace_pdrv);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}