{
  "module_name": "rcar-csi2.c",
  "hash_id": "b5bf80fc195097b83e84eff936f34169104f2cdb08cee9de26a9c471a0466a82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/rcar-vin/rcar-csi2.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/sys_soc.h>\n\n#include <media/mipi-csi2.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n\nstruct rcar_csi2;\n\n \n\n \n#define TREF_REG\t\t\t0x00\n#define TREF_TREF\t\t\tBIT(0)\n\n \n#define SRST_REG\t\t\t0x04\n#define SRST_SRST\t\t\tBIT(0)\n\n \n#define PHYCNT_REG\t\t\t0x08\n#define PHYCNT_SHUTDOWNZ\t\tBIT(17)\n#define PHYCNT_RSTZ\t\t\tBIT(16)\n#define PHYCNT_ENABLECLK\t\tBIT(4)\n#define PHYCNT_ENABLE_3\t\t\tBIT(3)\n#define PHYCNT_ENABLE_2\t\t\tBIT(2)\n#define PHYCNT_ENABLE_1\t\t\tBIT(1)\n#define PHYCNT_ENABLE_0\t\t\tBIT(0)\n\n \n#define CHKSUM_REG\t\t\t0x0c\n#define CHKSUM_ECC_EN\t\t\tBIT(1)\n#define CHKSUM_CRC_EN\t\t\tBIT(0)\n\n \n#define VCDT_REG\t\t\t0x10\n#define VCDT2_REG\t\t\t0x14\n#define VCDT_VCDTN_EN\t\t\tBIT(15)\n#define VCDT_SEL_VC(n)\t\t\t(((n) & 0x3) << 8)\n#define VCDT_SEL_DTN_ON\t\t\tBIT(6)\n#define VCDT_SEL_DT(n)\t\t\t(((n) & 0x3f) << 0)\n\n \n#define FRDT_REG\t\t\t0x18\n\n \n#define FLD_REG\t\t\t\t0x1c\n#define FLD_FLD_NUM(n)\t\t\t(((n) & 0xff) << 16)\n#define FLD_DET_SEL(n)\t\t\t(((n) & 0x3) << 4)\n#define FLD_FLD_EN4\t\t\tBIT(3)\n#define FLD_FLD_EN3\t\t\tBIT(2)\n#define FLD_FLD_EN2\t\t\tBIT(1)\n#define FLD_FLD_EN\t\t\tBIT(0)\n\n \n#define ASTBY_REG\t\t\t0x20\n\n \n#define LNGDT0_REG\t\t\t0x28\n\n \n#define LNGDT1_REG\t\t\t0x2c\n\n \n#define INTEN_REG\t\t\t0x30\n#define INTEN_INT_AFIFO_OF\t\tBIT(27)\n#define INTEN_INT_ERRSOTHS\t\tBIT(4)\n#define INTEN_INT_ERRSOTSYNCHS\t\tBIT(3)\n\n \n#define INTCLOSE_REG\t\t\t0x34\n\n \n#define INTSTATE_REG\t\t\t0x38\n#define INTSTATE_INT_ULPS_START\t\tBIT(7)\n#define INTSTATE_INT_ULPS_END\t\tBIT(6)\n\n \n#define INTERRSTATE_REG\t\t\t0x3c\n\n \n#define SHPDAT_REG\t\t\t0x40\n\n \n#define SHPCNT_REG\t\t\t0x44\n\n \n#define LINKCNT_REG\t\t\t0x48\n#define LINKCNT_MONITOR_EN\t\tBIT(31)\n#define LINKCNT_REG_MONI_PACT_EN\tBIT(25)\n#define LINKCNT_ICLK_NONSTOP\t\tBIT(24)\n\n \n#define LSWAP_REG\t\t\t0x4c\n#define LSWAP_L3SEL(n)\t\t\t(((n) & 0x3) << 6)\n#define LSWAP_L2SEL(n)\t\t\t(((n) & 0x3) << 4)\n#define LSWAP_L1SEL(n)\t\t\t(((n) & 0x3) << 2)\n#define LSWAP_L0SEL(n)\t\t\t(((n) & 0x3) << 0)\n\n \n#define PHTW_REG\t\t\t0x50\n#define PHTW_DWEN\t\t\tBIT(24)\n#define PHTW_TESTDIN_DATA(n)\t\t(((n & 0xff)) << 16)\n#define PHTW_CWEN\t\t\tBIT(8)\n#define PHTW_TESTDIN_CODE(n)\t\t((n & 0xff))\n\n#define PHYFRX_REG\t\t\t0x64\n#define PHYFRX_FORCERX_MODE_3\t\tBIT(3)\n#define PHYFRX_FORCERX_MODE_2\t\tBIT(2)\n#define PHYFRX_FORCERX_MODE_1\t\tBIT(1)\n#define PHYFRX_FORCERX_MODE_0\t\tBIT(0)\n\n \n#define V4H_N_LANES_REG\t\t\t\t\t0x0004\n#define V4H_CSI2_RESETN_REG\t\t\t\t0x0008\n#define V4H_PHY_MODE_REG\t\t\t\t0x001c\n#define V4H_PHY_SHUTDOWNZ_REG\t\t\t\t0x0040\n#define V4H_DPHY_RSTZ_REG\t\t\t\t0x0044\n#define V4H_FLDC_REG\t\t\t\t\t0x0804\n#define V4H_FLDD_REG\t\t\t\t\t0x0808\n#define V4H_IDIC_REG\t\t\t\t\t0x0810\n#define V4H_PHY_EN_REG\t\t\t\t\t0x2000\n\n#define V4H_ST_PHYST_REG\t\t\t\t0x2814\n#define V4H_ST_PHYST_ST_PHY_READY\t\t\tBIT(31)\n#define V4H_ST_PHYST_ST_STOPSTATE_3\t\t\tBIT(3)\n#define V4H_ST_PHYST_ST_STOPSTATE_2\t\t\tBIT(2)\n#define V4H_ST_PHYST_ST_STOPSTATE_1\t\t\tBIT(1)\n#define V4H_ST_PHYST_ST_STOPSTATE_0\t\t\tBIT(0)\n\n \n#define V4H_PPI_STARTUP_RW_COMMON_DPHY_REG(n)\t\t(0x21800 + ((n) * 2))  \n#define V4H_PPI_STARTUP_RW_COMMON_STARTUP_1_1_REG\t0x21822\n#define V4H_PPI_CALIBCTRL_RW_COMMON_BG_0_REG\t\t0x2184c\n#define V4H_PPI_RW_LPDCOCAL_TIMEBASE_REG\t\t0x21c02\n#define V4H_PPI_RW_LPDCOCAL_NREF_REG\t\t\t0x21c04\n#define V4H_PPI_RW_LPDCOCAL_NREF_RANGE_REG\t\t0x21c06\n#define V4H_PPI_RW_LPDCOCAL_TWAIT_CONFIG_REG\t\t0x21c0a\n#define V4H_PPI_RW_LPDCOCAL_VT_CONFIG_REG\t\t0x21c0c\n#define V4H_PPI_RW_LPDCOCAL_COARSE_CFG_REG\t\t0x21c10\n#define V4H_PPI_RW_COMMON_CFG_REG\t\t\t0x21c6c\n#define V4H_PPI_RW_TERMCAL_CFG_0_REG\t\t\t0x21c80\n#define V4H_PPI_RW_OFFSETCAL_CFG_0_REG\t\t\t0x21ca0\n\n \n#define V4H_CORE_DIG_IOCTRL_RW_AFE_LANE0_CTRL_2_REG(n)\t(0x22040 + ((n) * 2))  \n#define V4H_CORE_DIG_IOCTRL_RW_AFE_LANE1_CTRL_2_REG(n)\t(0x22440 + ((n) * 2))  \n#define V4H_CORE_DIG_IOCTRL_RW_AFE_LANE2_CTRL_2_REG(n)\t(0x22840 + ((n) * 2))  \n#define V4H_CORE_DIG_IOCTRL_RW_AFE_LANE3_CTRL_2_REG(n)\t(0x22c40 + ((n) * 2))  \n#define V4H_CORE_DIG_IOCTRL_RW_AFE_LANE4_CTRL_2_REG(n)\t(0x23040 + ((n) * 2))  \n#define V4H_CORE_DIG_IOCTRL_RW_AFE_CB_CTRL_2_REG(n)\t(0x23840 + ((n) * 2))  \n#define V4H_CORE_DIG_RW_COMMON_REG(n)\t\t\t(0x23880 + ((n) * 2))  \n#define V4H_CORE_DIG_ANACTRL_RW_COMMON_ANACTRL_REG(n)\t(0x239e0 + ((n) * 2))  \n#define V4H_CORE_DIG_CLANE_1_RW_CFG_0_REG\t\t0x2a400\n#define V4H_CORE_DIG_CLANE_1_RW_HS_TX_6_REG\t\t0x2a60c\n\n \n#define V4H_CORE_DIG_RW_TRIO0_REG(n)\t\t\t(0x22100 + ((n) * 2))  \n#define V4H_CORE_DIG_RW_TRIO1_REG(n)\t\t\t(0x22500 + ((n) * 2))  \n#define V4H_CORE_DIG_RW_TRIO2_REG(n)\t\t\t(0x22900 + ((n) * 2))  \n#define V4H_CORE_DIG_CLANE_0_RW_LP_0_REG\t\t0x2a080\n#define V4H_CORE_DIG_CLANE_0_RW_HS_RX_REG(n)\t\t(0x2a100 + ((n) * 2))  \n#define V4H_CORE_DIG_CLANE_1_RW_LP_0_REG\t\t0x2a480\n#define V4H_CORE_DIG_CLANE_1_RW_HS_RX_REG(n)\t\t(0x2a500 + ((n) * 2))  \n#define V4H_CORE_DIG_CLANE_2_RW_LP_0_REG\t\t0x2a880\n#define V4H_CORE_DIG_CLANE_2_RW_HS_RX_REG(n)\t\t(0x2a900 + ((n) * 2))  \n\nstruct rcsi2_cphy_setting {\n\tu16 msps;\n\tu16 rx2;\n\tu16 trio0;\n\tu16 trio1;\n\tu16 trio2;\n\tu16 lane27;\n\tu16 lane29;\n};\n\nstatic const struct rcsi2_cphy_setting cphy_setting_table_r8a779g0[] = {\n\t{ .msps =   80, .rx2 = 0x38, .trio0 = 0x024a, .trio1 = 0x0134, .trio2 = 0x6a, .lane27 = 0x0000, .lane29 = 0x0a24 },\n\t{ .msps =  100, .rx2 = 0x38, .trio0 = 0x024a, .trio1 = 0x00f5, .trio2 = 0x55, .lane27 = 0x0000, .lane29 = 0x0a24 },\n\t{ .msps =  200, .rx2 = 0x38, .trio0 = 0x024a, .trio1 = 0x0077, .trio2 = 0x2b, .lane27 = 0x0000, .lane29 = 0x0a44 },\n\t{ .msps =  300, .rx2 = 0x38, .trio0 = 0x024a, .trio1 = 0x004d, .trio2 = 0x1d, .lane27 = 0x0000, .lane29 = 0x0a44 },\n\t{ .msps =  400, .rx2 = 0x38, .trio0 = 0x024a, .trio1 = 0x0038, .trio2 = 0x16, .lane27 = 0x0000, .lane29 = 0x0a64 },\n\t{ .msps =  500, .rx2 = 0x38, .trio0 = 0x024a, .trio1 = 0x002b, .trio2 = 0x12, .lane27 = 0x0000, .lane29 = 0x0a64 },\n\t{ .msps =  600, .rx2 = 0x38, .trio0 = 0x024a, .trio1 = 0x0023, .trio2 = 0x0f, .lane27 = 0x0000, .lane29 = 0x0a64 },\n\t{ .msps =  700, .rx2 = 0x38, .trio0 = 0x024a, .trio1 = 0x001d, .trio2 = 0x0d, .lane27 = 0x0000, .lane29 = 0x0a84 },\n\t{ .msps =  800, .rx2 = 0x38, .trio0 = 0x024a, .trio1 = 0x0018, .trio2 = 0x0c, .lane27 = 0x0000, .lane29 = 0x0a84 },\n\t{ .msps =  900, .rx2 = 0x38, .trio0 = 0x024a, .trio1 = 0x0015, .trio2 = 0x0b, .lane27 = 0x0000, .lane29 = 0x0a84 },\n\t{ .msps = 1000, .rx2 = 0x3e, .trio0 = 0x024a, .trio1 = 0x0012, .trio2 = 0x0a, .lane27 = 0x0400, .lane29 = 0x0a84 },\n\t{ .msps = 1100, .rx2 = 0x44, .trio0 = 0x024a, .trio1 = 0x000f, .trio2 = 0x09, .lane27 = 0x0800, .lane29 = 0x0a84 },\n\t{ .msps = 1200, .rx2 = 0x4a, .trio0 = 0x024a, .trio1 = 0x000e, .trio2 = 0x08, .lane27 = 0x0c00, .lane29 = 0x0a84 },\n\t{ .msps = 1300, .rx2 = 0x51, .trio0 = 0x024a, .trio1 = 0x000c, .trio2 = 0x08, .lane27 = 0x0c00, .lane29 = 0x0aa4 },\n\t{ .msps = 1400, .rx2 = 0x57, .trio0 = 0x024a, .trio1 = 0x000b, .trio2 = 0x07, .lane27 = 0x1000, .lane29 = 0x0aa4 },\n\t{ .msps = 1500, .rx2 = 0x5d, .trio0 = 0x044a, .trio1 = 0x0009, .trio2 = 0x07, .lane27 = 0x1000, .lane29 = 0x0aa4 },\n\t{ .msps = 1600, .rx2 = 0x63, .trio0 = 0x044a, .trio1 = 0x0008, .trio2 = 0x07, .lane27 = 0x1400, .lane29 = 0x0aa4 },\n\t{ .msps = 1700, .rx2 = 0x6a, .trio0 = 0x044a, .trio1 = 0x0007, .trio2 = 0x06, .lane27 = 0x1400, .lane29 = 0x0aa4 },\n\t{ .msps = 1800, .rx2 = 0x70, .trio0 = 0x044a, .trio1 = 0x0007, .trio2 = 0x06, .lane27 = 0x1400, .lane29 = 0x0aa4 },\n\t{ .msps = 1900, .rx2 = 0x76, .trio0 = 0x044a, .trio1 = 0x0006, .trio2 = 0x06, .lane27 = 0x1400, .lane29 = 0x0aa4 },\n\t{ .msps = 2000, .rx2 = 0x7c, .trio0 = 0x044a, .trio1 = 0x0005, .trio2 = 0x06, .lane27 = 0x1800, .lane29 = 0x0aa4 },\n\t{ .msps = 2100, .rx2 = 0x83, .trio0 = 0x044a, .trio1 = 0x0005, .trio2 = 0x05, .lane27 = 0x1800, .lane29 = 0x0aa4 },\n\t{ .msps = 2200, .rx2 = 0x89, .trio0 = 0x064a, .trio1 = 0x0004, .trio2 = 0x05, .lane27 = 0x1800, .lane29 = 0x0aa4 },\n\t{ .msps = 2300, .rx2 = 0x8f, .trio0 = 0x064a, .trio1 = 0x0003, .trio2 = 0x05, .lane27 = 0x1800, .lane29 = 0x0aa4 },\n\t{ .msps = 2400, .rx2 = 0x95, .trio0 = 0x064a, .trio1 = 0x0003, .trio2 = 0x05, .lane27 = 0x1800, .lane29 = 0x0aa4 },\n\t{ .msps = 2500, .rx2 = 0x9c, .trio0 = 0x064a, .trio1 = 0x0003, .trio2 = 0x05, .lane27 = 0x1c00, .lane29 = 0x0aa4 },\n\t{ .msps = 2600, .rx2 = 0xa2, .trio0 = 0x064a, .trio1 = 0x0002, .trio2 = 0x05, .lane27 = 0x1c00, .lane29 = 0x0ad4 },\n\t{ .msps = 2700, .rx2 = 0xa8, .trio0 = 0x064a, .trio1 = 0x0002, .trio2 = 0x05, .lane27 = 0x1c00, .lane29 = 0x0ad4 },\n\t{ .msps = 2800, .rx2 = 0xae, .trio0 = 0x064a, .trio1 = 0x0002, .trio2 = 0x04, .lane27 = 0x1c00, .lane29 = 0x0ad4 },\n\t{ .msps = 2900, .rx2 = 0xb5, .trio0 = 0x084a, .trio1 = 0x0001, .trio2 = 0x04, .lane27 = 0x1c00, .lane29 = 0x0ad4 },\n\t{ .msps = 3000, .rx2 = 0xbb, .trio0 = 0x084a, .trio1 = 0x0001, .trio2 = 0x04, .lane27 = 0x1c00, .lane29 = 0x0ad4 },\n\t{ .msps = 3100, .rx2 = 0xc1, .trio0 = 0x084a, .trio1 = 0x0001, .trio2 = 0x04, .lane27 = 0x1c00, .lane29 = 0x0ad4 },\n\t{ .msps = 3200, .rx2 = 0xc7, .trio0 = 0x084a, .trio1 = 0x0001, .trio2 = 0x04, .lane27 = 0x1c00, .lane29 = 0x0ad4 },\n\t{ .msps = 3300, .rx2 = 0xce, .trio0 = 0x084a, .trio1 = 0x0001, .trio2 = 0x04, .lane27 = 0x1c00, .lane29 = 0x0ad4 },\n\t{ .msps = 3400, .rx2 = 0xd4, .trio0 = 0x084a, .trio1 = 0x0001, .trio2 = 0x04, .lane27 = 0x1c00, .lane29 = 0x0ad4 },\n\t{ .msps = 3500, .rx2 = 0xda, .trio0 = 0x084a, .trio1 = 0x0001, .trio2 = 0x04, .lane27 = 0x1c00, .lane29 = 0x0ad4 },\n\t{   },\n};\n\nstruct phtw_value {\n\tu16 data;\n\tu16 code;\n};\n\nstruct rcsi2_mbps_reg {\n\tu16 mbps;\n\tu16 reg;\n};\n\nstatic const struct rcsi2_mbps_reg phtw_mbps_v3u[] = {\n\t{ .mbps = 1500, .reg = 0xcc },\n\t{ .mbps = 1550, .reg = 0x1d },\n\t{ .mbps = 1600, .reg = 0x27 },\n\t{ .mbps = 1650, .reg = 0x30 },\n\t{ .mbps = 1700, .reg = 0x39 },\n\t{ .mbps = 1750, .reg = 0x42 },\n\t{ .mbps = 1800, .reg = 0x4b },\n\t{ .mbps = 1850, .reg = 0x55 },\n\t{ .mbps = 1900, .reg = 0x5e },\n\t{ .mbps = 1950, .reg = 0x67 },\n\t{ .mbps = 2000, .reg = 0x71 },\n\t{ .mbps = 2050, .reg = 0x79 },\n\t{ .mbps = 2100, .reg = 0x83 },\n\t{ .mbps = 2150, .reg = 0x8c },\n\t{ .mbps = 2200, .reg = 0x95 },\n\t{ .mbps = 2250, .reg = 0x9e },\n\t{ .mbps = 2300, .reg = 0xa7 },\n\t{ .mbps = 2350, .reg = 0xb0 },\n\t{ .mbps = 2400, .reg = 0xba },\n\t{ .mbps = 2450, .reg = 0xc3 },\n\t{ .mbps = 2500, .reg = 0xcc },\n\t{   },\n};\n\nstatic const struct rcsi2_mbps_reg phtw_mbps_h3_v3h_m3n[] = {\n\t{ .mbps =   80, .reg = 0x86 },\n\t{ .mbps =   90, .reg = 0x86 },\n\t{ .mbps =  100, .reg = 0x87 },\n\t{ .mbps =  110, .reg = 0x87 },\n\t{ .mbps =  120, .reg = 0x88 },\n\t{ .mbps =  130, .reg = 0x88 },\n\t{ .mbps =  140, .reg = 0x89 },\n\t{ .mbps =  150, .reg = 0x89 },\n\t{ .mbps =  160, .reg = 0x8a },\n\t{ .mbps =  170, .reg = 0x8a },\n\t{ .mbps =  180, .reg = 0x8b },\n\t{ .mbps =  190, .reg = 0x8b },\n\t{ .mbps =  205, .reg = 0x8c },\n\t{ .mbps =  220, .reg = 0x8d },\n\t{ .mbps =  235, .reg = 0x8e },\n\t{ .mbps =  250, .reg = 0x8e },\n\t{   },\n};\n\nstatic const struct rcsi2_mbps_reg phtw_mbps_v3m_e3[] = {\n\t{ .mbps =   80, .reg = 0x00 },\n\t{ .mbps =   90, .reg = 0x20 },\n\t{ .mbps =  100, .reg = 0x40 },\n\t{ .mbps =  110, .reg = 0x02 },\n\t{ .mbps =  130, .reg = 0x22 },\n\t{ .mbps =  140, .reg = 0x42 },\n\t{ .mbps =  150, .reg = 0x04 },\n\t{ .mbps =  170, .reg = 0x24 },\n\t{ .mbps =  180, .reg = 0x44 },\n\t{ .mbps =  200, .reg = 0x06 },\n\t{ .mbps =  220, .reg = 0x26 },\n\t{ .mbps =  240, .reg = 0x46 },\n\t{ .mbps =  250, .reg = 0x08 },\n\t{ .mbps =  270, .reg = 0x28 },\n\t{ .mbps =  300, .reg = 0x0a },\n\t{ .mbps =  330, .reg = 0x2a },\n\t{ .mbps =  360, .reg = 0x4a },\n\t{ .mbps =  400, .reg = 0x0c },\n\t{ .mbps =  450, .reg = 0x2c },\n\t{ .mbps =  500, .reg = 0x0e },\n\t{ .mbps =  550, .reg = 0x2e },\n\t{ .mbps =  600, .reg = 0x10 },\n\t{ .mbps =  650, .reg = 0x30 },\n\t{ .mbps =  700, .reg = 0x12 },\n\t{ .mbps =  750, .reg = 0x32 },\n\t{ .mbps =  800, .reg = 0x52 },\n\t{ .mbps =  850, .reg = 0x72 },\n\t{ .mbps =  900, .reg = 0x14 },\n\t{ .mbps =  950, .reg = 0x34 },\n\t{ .mbps = 1000, .reg = 0x54 },\n\t{ .mbps = 1050, .reg = 0x74 },\n\t{ .mbps = 1125, .reg = 0x16 },\n\t{   },\n};\n\n \n#define PHTC_REG\t\t\t0x58\n#define PHTC_TESTCLR\t\t\tBIT(0)\n\n \n#define PHYPLL_REG\t\t\t0x68\n#define PHYPLL_HSFREQRANGE(n)\t\t((n) << 16)\n\nstatic const struct rcsi2_mbps_reg hsfreqrange_v3u[] = {\n\t{ .mbps =   80, .reg = 0x00 },\n\t{ .mbps =   90, .reg = 0x10 },\n\t{ .mbps =  100, .reg = 0x20 },\n\t{ .mbps =  110, .reg = 0x30 },\n\t{ .mbps =  120, .reg = 0x01 },\n\t{ .mbps =  130, .reg = 0x11 },\n\t{ .mbps =  140, .reg = 0x21 },\n\t{ .mbps =  150, .reg = 0x31 },\n\t{ .mbps =  160, .reg = 0x02 },\n\t{ .mbps =  170, .reg = 0x12 },\n\t{ .mbps =  180, .reg = 0x22 },\n\t{ .mbps =  190, .reg = 0x32 },\n\t{ .mbps =  205, .reg = 0x03 },\n\t{ .mbps =  220, .reg = 0x13 },\n\t{ .mbps =  235, .reg = 0x23 },\n\t{ .mbps =  250, .reg = 0x33 },\n\t{ .mbps =  275, .reg = 0x04 },\n\t{ .mbps =  300, .reg = 0x14 },\n\t{ .mbps =  325, .reg = 0x25 },\n\t{ .mbps =  350, .reg = 0x35 },\n\t{ .mbps =  400, .reg = 0x05 },\n\t{ .mbps =  450, .reg = 0x16 },\n\t{ .mbps =  500, .reg = 0x26 },\n\t{ .mbps =  550, .reg = 0x37 },\n\t{ .mbps =  600, .reg = 0x07 },\n\t{ .mbps =  650, .reg = 0x18 },\n\t{ .mbps =  700, .reg = 0x28 },\n\t{ .mbps =  750, .reg = 0x39 },\n\t{ .mbps =  800, .reg = 0x09 },\n\t{ .mbps =  850, .reg = 0x19 },\n\t{ .mbps =  900, .reg = 0x29 },\n\t{ .mbps =  950, .reg = 0x3a },\n\t{ .mbps = 1000, .reg = 0x0a },\n\t{ .mbps = 1050, .reg = 0x1a },\n\t{ .mbps = 1100, .reg = 0x2a },\n\t{ .mbps = 1150, .reg = 0x3b },\n\t{ .mbps = 1200, .reg = 0x0b },\n\t{ .mbps = 1250, .reg = 0x1b },\n\t{ .mbps = 1300, .reg = 0x2b },\n\t{ .mbps = 1350, .reg = 0x3c },\n\t{ .mbps = 1400, .reg = 0x0c },\n\t{ .mbps = 1450, .reg = 0x1c },\n\t{ .mbps = 1500, .reg = 0x2c },\n\t{ .mbps = 1550, .reg = 0x3d },\n\t{ .mbps = 1600, .reg = 0x0d },\n\t{ .mbps = 1650, .reg = 0x1d },\n\t{ .mbps = 1700, .reg = 0x2e },\n\t{ .mbps = 1750, .reg = 0x3e },\n\t{ .mbps = 1800, .reg = 0x0e },\n\t{ .mbps = 1850, .reg = 0x1e },\n\t{ .mbps = 1900, .reg = 0x2f },\n\t{ .mbps = 1950, .reg = 0x3f },\n\t{ .mbps = 2000, .reg = 0x0f },\n\t{ .mbps = 2050, .reg = 0x40 },\n\t{ .mbps = 2100, .reg = 0x41 },\n\t{ .mbps = 2150, .reg = 0x42 },\n\t{ .mbps = 2200, .reg = 0x43 },\n\t{ .mbps = 2300, .reg = 0x45 },\n\t{ .mbps = 2350, .reg = 0x46 },\n\t{ .mbps = 2400, .reg = 0x47 },\n\t{ .mbps = 2450, .reg = 0x48 },\n\t{ .mbps = 2500, .reg = 0x49 },\n\t{   },\n};\n\nstatic const struct rcsi2_mbps_reg hsfreqrange_h3_v3h_m3n[] = {\n\t{ .mbps =   80, .reg = 0x00 },\n\t{ .mbps =   90, .reg = 0x10 },\n\t{ .mbps =  100, .reg = 0x20 },\n\t{ .mbps =  110, .reg = 0x30 },\n\t{ .mbps =  120, .reg = 0x01 },\n\t{ .mbps =  130, .reg = 0x11 },\n\t{ .mbps =  140, .reg = 0x21 },\n\t{ .mbps =  150, .reg = 0x31 },\n\t{ .mbps =  160, .reg = 0x02 },\n\t{ .mbps =  170, .reg = 0x12 },\n\t{ .mbps =  180, .reg = 0x22 },\n\t{ .mbps =  190, .reg = 0x32 },\n\t{ .mbps =  205, .reg = 0x03 },\n\t{ .mbps =  220, .reg = 0x13 },\n\t{ .mbps =  235, .reg = 0x23 },\n\t{ .mbps =  250, .reg = 0x33 },\n\t{ .mbps =  275, .reg = 0x04 },\n\t{ .mbps =  300, .reg = 0x14 },\n\t{ .mbps =  325, .reg = 0x25 },\n\t{ .mbps =  350, .reg = 0x35 },\n\t{ .mbps =  400, .reg = 0x05 },\n\t{ .mbps =  450, .reg = 0x16 },\n\t{ .mbps =  500, .reg = 0x26 },\n\t{ .mbps =  550, .reg = 0x37 },\n\t{ .mbps =  600, .reg = 0x07 },\n\t{ .mbps =  650, .reg = 0x18 },\n\t{ .mbps =  700, .reg = 0x28 },\n\t{ .mbps =  750, .reg = 0x39 },\n\t{ .mbps =  800, .reg = 0x09 },\n\t{ .mbps =  850, .reg = 0x19 },\n\t{ .mbps =  900, .reg = 0x29 },\n\t{ .mbps =  950, .reg = 0x3a },\n\t{ .mbps = 1000, .reg = 0x0a },\n\t{ .mbps = 1050, .reg = 0x1a },\n\t{ .mbps = 1100, .reg = 0x2a },\n\t{ .mbps = 1150, .reg = 0x3b },\n\t{ .mbps = 1200, .reg = 0x0b },\n\t{ .mbps = 1250, .reg = 0x1b },\n\t{ .mbps = 1300, .reg = 0x2b },\n\t{ .mbps = 1350, .reg = 0x3c },\n\t{ .mbps = 1400, .reg = 0x0c },\n\t{ .mbps = 1450, .reg = 0x1c },\n\t{ .mbps = 1500, .reg = 0x2c },\n\t{   },\n};\n\nstatic const struct rcsi2_mbps_reg hsfreqrange_m3w[] = {\n\t{ .mbps =   80,\t.reg = 0x00 },\n\t{ .mbps =   90,\t.reg = 0x10 },\n\t{ .mbps =  100,\t.reg = 0x20 },\n\t{ .mbps =  110,\t.reg = 0x30 },\n\t{ .mbps =  120,\t.reg = 0x01 },\n\t{ .mbps =  130,\t.reg = 0x11 },\n\t{ .mbps =  140,\t.reg = 0x21 },\n\t{ .mbps =  150,\t.reg = 0x31 },\n\t{ .mbps =  160,\t.reg = 0x02 },\n\t{ .mbps =  170,\t.reg = 0x12 },\n\t{ .mbps =  180,\t.reg = 0x22 },\n\t{ .mbps =  190,\t.reg = 0x32 },\n\t{ .mbps =  205,\t.reg = 0x03 },\n\t{ .mbps =  220,\t.reg = 0x13 },\n\t{ .mbps =  235,\t.reg = 0x23 },\n\t{ .mbps =  250,\t.reg = 0x33 },\n\t{ .mbps =  275,\t.reg = 0x04 },\n\t{ .mbps =  300,\t.reg = 0x14 },\n\t{ .mbps =  325,\t.reg = 0x05 },\n\t{ .mbps =  350,\t.reg = 0x15 },\n\t{ .mbps =  400,\t.reg = 0x25 },\n\t{ .mbps =  450,\t.reg = 0x06 },\n\t{ .mbps =  500,\t.reg = 0x16 },\n\t{ .mbps =  550,\t.reg = 0x07 },\n\t{ .mbps =  600,\t.reg = 0x17 },\n\t{ .mbps =  650,\t.reg = 0x08 },\n\t{ .mbps =  700,\t.reg = 0x18 },\n\t{ .mbps =  750,\t.reg = 0x09 },\n\t{ .mbps =  800,\t.reg = 0x19 },\n\t{ .mbps =  850,\t.reg = 0x29 },\n\t{ .mbps =  900,\t.reg = 0x39 },\n\t{ .mbps =  950,\t.reg = 0x0a },\n\t{ .mbps = 1000,\t.reg = 0x1a },\n\t{ .mbps = 1050,\t.reg = 0x2a },\n\t{ .mbps = 1100,\t.reg = 0x3a },\n\t{ .mbps = 1150,\t.reg = 0x0b },\n\t{ .mbps = 1200,\t.reg = 0x1b },\n\t{ .mbps = 1250,\t.reg = 0x2b },\n\t{ .mbps = 1300,\t.reg = 0x3b },\n\t{ .mbps = 1350,\t.reg = 0x0c },\n\t{ .mbps = 1400,\t.reg = 0x1c },\n\t{ .mbps = 1450,\t.reg = 0x2c },\n\t{ .mbps = 1500,\t.reg = 0x3c },\n\t{   },\n};\n\n \n#define PHEERM_REG\t\t\t0x74\n\n \n#define PHCLM_REG\t\t\t0x78\n#define PHCLM_STOPSTATECKL\t\tBIT(0)\n\n \n#define PHDLM_REG\t\t\t0x7c\n\n \n#define CSI0CLKFCPR_REG\t\t\t0x260\n#define CSI0CLKFREQRANGE(n)\t\t((n & 0x3f) << 16)\n\nstruct rcar_csi2_format {\n\tu32 code;\n\tunsigned int datatype;\n\tunsigned int bpp;\n};\n\nstatic const struct rcar_csi2_format rcar_csi2_formats[] = {\n\t{\n\t\t.code = MEDIA_BUS_FMT_RGB888_1X24,\n\t\t.datatype = MIPI_CSI2_DT_RGB888,\n\t\t.bpp = 24,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.datatype = MIPI_CSI2_DT_YUV422_8B,\n\t\t.bpp = 16,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_YUYV8_1X16,\n\t\t.datatype = MIPI_CSI2_DT_YUV422_8B,\n\t\t.bpp = 16,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.datatype = MIPI_CSI2_DT_YUV422_8B,\n\t\t.bpp = 16,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_YUYV10_2X10,\n\t\t.datatype = MIPI_CSI2_DT_YUV422_8B,\n\t\t.bpp = 20,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_Y10_1X10,\n\t\t.datatype = MIPI_CSI2_DT_RAW10,\n\t\t.bpp = 10,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.datatype = MIPI_CSI2_DT_RAW8,\n\t\t.bpp = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.datatype = MIPI_CSI2_DT_RAW8,\n\t\t.bpp = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.datatype = MIPI_CSI2_DT_RAW8,\n\t\t.bpp = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.datatype = MIPI_CSI2_DT_RAW8,\n\t\t.bpp = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_Y8_1X8,\n\t\t.datatype = MIPI_CSI2_DT_RAW8,\n\t\t.bpp = 8,\n\t},\n};\n\nstatic const struct rcar_csi2_format *rcsi2_code_to_fmt(unsigned int code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rcar_csi2_formats); i++)\n\t\tif (rcar_csi2_formats[i].code == code)\n\t\t\treturn &rcar_csi2_formats[i];\n\n\treturn NULL;\n}\n\nenum rcar_csi2_pads {\n\tRCAR_CSI2_SINK,\n\tRCAR_CSI2_SOURCE_VC0,\n\tRCAR_CSI2_SOURCE_VC1,\n\tRCAR_CSI2_SOURCE_VC2,\n\tRCAR_CSI2_SOURCE_VC3,\n\tNR_OF_RCAR_CSI2_PAD,\n};\n\nstruct rcar_csi2_info {\n\tint (*init_phtw)(struct rcar_csi2 *priv, unsigned int mbps);\n\tint (*phy_post_init)(struct rcar_csi2 *priv);\n\tint (*start_receiver)(struct rcar_csi2 *priv);\n\tvoid (*enter_standby)(struct rcar_csi2 *priv);\n\tconst struct rcsi2_mbps_reg *hsfreqrange;\n\tunsigned int csi0clkfreqrange;\n\tunsigned int num_channels;\n\tbool clear_ulps;\n\tbool use_isp;\n\tbool support_dphy;\n\tbool support_cphy;\n};\n\nstruct rcar_csi2 {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tconst struct rcar_csi2_info *info;\n\tstruct reset_control *rstc;\n\n\tstruct v4l2_subdev subdev;\n\tstruct media_pad pads[NR_OF_RCAR_CSI2_PAD];\n\n\tstruct v4l2_async_notifier notifier;\n\tstruct v4l2_subdev *remote;\n\tunsigned int remote_pad;\n\n\tint channel_vc[4];\n\n\tstruct mutex lock;  \n\tstruct v4l2_mbus_framefmt mf;\n\tint stream_count;\n\n\tbool cphy;\n\tunsigned short lanes;\n\tunsigned char lane_swap[4];\n};\n\nstatic inline struct rcar_csi2 *sd_to_csi2(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct rcar_csi2, subdev);\n}\n\nstatic inline struct rcar_csi2 *notifier_to_csi2(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct rcar_csi2, notifier);\n}\n\nstatic u32 rcsi2_read(struct rcar_csi2 *priv, unsigned int reg)\n{\n\treturn ioread32(priv->base + reg);\n}\n\nstatic void rcsi2_write(struct rcar_csi2 *priv, unsigned int reg, u32 data)\n{\n\tiowrite32(data, priv->base + reg);\n}\n\nstatic void rcsi2_write16(struct rcar_csi2 *priv, unsigned int reg, u16 data)\n{\n\tiowrite16(data, priv->base + reg);\n}\n\nstatic void rcsi2_enter_standby_gen3(struct rcar_csi2 *priv)\n{\n\trcsi2_write(priv, PHYCNT_REG, 0);\n\trcsi2_write(priv, PHTC_REG, PHTC_TESTCLR);\n}\n\nstatic void rcsi2_enter_standby(struct rcar_csi2 *priv)\n{\n\tif (priv->info->enter_standby)\n\t\tpriv->info->enter_standby(priv);\n\n\treset_control_assert(priv->rstc);\n\tusleep_range(100, 150);\n\tpm_runtime_put(priv->dev);\n}\n\nstatic int rcsi2_exit_standby(struct rcar_csi2 *priv)\n{\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treset_control_deassert(priv->rstc);\n\n\treturn 0;\n}\n\nstatic int rcsi2_wait_phy_start(struct rcar_csi2 *priv,\n\t\t\t\tunsigned int lanes)\n{\n\tunsigned int timeout;\n\n\t \n\tfor (timeout = 0; timeout <= 20; timeout++) {\n\t\tconst u32 lane_mask = (1 << lanes) - 1;\n\n\t\tif ((rcsi2_read(priv, PHCLM_REG) & PHCLM_STOPSTATECKL)  &&\n\t\t    (rcsi2_read(priv, PHDLM_REG) & lane_mask) == lane_mask)\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tdev_err(priv->dev, \"Timeout waiting for LP-11 state\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int rcsi2_set_phypll(struct rcar_csi2 *priv, unsigned int mbps)\n{\n\tconst struct rcsi2_mbps_reg *hsfreq;\n\tconst struct rcsi2_mbps_reg *hsfreq_prev = NULL;\n\n\tif (mbps < priv->info->hsfreqrange->mbps)\n\t\tdev_warn(priv->dev, \"%u Mbps less than min PHY speed %u Mbps\",\n\t\t\t mbps, priv->info->hsfreqrange->mbps);\n\n\tfor (hsfreq = priv->info->hsfreqrange; hsfreq->mbps != 0; hsfreq++) {\n\t\tif (hsfreq->mbps >= mbps)\n\t\t\tbreak;\n\t\thsfreq_prev = hsfreq;\n\t}\n\n\tif (!hsfreq->mbps) {\n\t\tdev_err(priv->dev, \"Unsupported PHY speed (%u Mbps)\", mbps);\n\t\treturn -ERANGE;\n\t}\n\n\tif (hsfreq_prev &&\n\t    ((mbps - hsfreq_prev->mbps) <= (hsfreq->mbps - mbps)))\n\t\thsfreq = hsfreq_prev;\n\n\trcsi2_write(priv, PHYPLL_REG, PHYPLL_HSFREQRANGE(hsfreq->reg));\n\n\treturn 0;\n}\n\nstatic int rcsi2_calc_mbps(struct rcar_csi2 *priv, unsigned int bpp,\n\t\t\t   unsigned int lanes)\n{\n\tstruct v4l2_subdev *source;\n\tstruct v4l2_ctrl *ctrl;\n\tu64 mbps;\n\n\tif (!priv->remote)\n\t\treturn -ENODEV;\n\n\tsource = priv->remote;\n\n\t \n\tctrl = v4l2_ctrl_find(source->ctrl_handler, V4L2_CID_PIXEL_RATE);\n\tif (!ctrl) {\n\t\tdev_err(priv->dev, \"no pixel rate control in subdev %s\\n\",\n\t\t\tsource->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmbps = v4l2_ctrl_g_ctrl_int64(ctrl) * bpp;\n\tdo_div(mbps, lanes * 1000000);\n\n\t \n\tif (priv->cphy)\n\t\tmbps = div_u64(mbps * 5, 14);\n\n\treturn mbps;\n}\n\nstatic int rcsi2_get_active_lanes(struct rcar_csi2 *priv,\n\t\t\t\t  unsigned int *lanes)\n{\n\tstruct v4l2_mbus_config mbus_config = { 0 };\n\tint ret;\n\n\t*lanes = priv->lanes;\n\n\tret = v4l2_subdev_call(priv->remote, pad, get_mbus_config,\n\t\t\t       priv->remote_pad, &mbus_config);\n\tif (ret == -ENOIOCTLCMD) {\n\t\tdev_dbg(priv->dev, \"No remote mbus configuration available\\n\");\n\t\treturn 0;\n\t}\n\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to get remote mbus configuration\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (mbus_config.type) {\n\tcase V4L2_MBUS_CSI2_CPHY:\n\t\tif (!priv->cphy)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_MBUS_CSI2_DPHY:\n\t\tif (priv->cphy)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"Unsupported media bus type %u\\n\",\n\t\t\tmbus_config.type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mbus_config.bus.mipi_csi2.num_data_lanes > priv->lanes) {\n\t\tdev_err(priv->dev,\n\t\t\t\"Unsupported mbus config: too many data lanes %u\\n\",\n\t\t\tmbus_config.bus.mipi_csi2.num_data_lanes);\n\t\treturn -EINVAL;\n\t}\n\n\t*lanes = mbus_config.bus.mipi_csi2.num_data_lanes;\n\n\treturn 0;\n}\n\nstatic int rcsi2_start_receiver_gen3(struct rcar_csi2 *priv)\n{\n\tconst struct rcar_csi2_format *format;\n\tu32 phycnt, vcdt = 0, vcdt2 = 0, fld = 0;\n\tunsigned int lanes;\n\tunsigned int i;\n\tint mbps, ret;\n\n\tdev_dbg(priv->dev, \"Input size (%ux%u%c)\\n\",\n\t\tpriv->mf.width, priv->mf.height,\n\t\tpriv->mf.field == V4L2_FIELD_NONE ? 'p' : 'i');\n\n\t \n\tformat = rcsi2_code_to_fmt(priv->mf.code);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < priv->info->num_channels; i++) {\n\t\tu32 vcdt_part;\n\n\t\tif (priv->channel_vc[i] < 0)\n\t\t\tcontinue;\n\n\t\tvcdt_part = VCDT_SEL_VC(priv->channel_vc[i]) | VCDT_VCDTN_EN |\n\t\t\tVCDT_SEL_DTN_ON | VCDT_SEL_DT(format->datatype);\n\n\t\t \n\t\tif (i < 2)\n\t\t\tvcdt |= vcdt_part << ((i % 2) * 16);\n\t\telse\n\t\t\tvcdt2 |= vcdt_part << ((i % 2) * 16);\n\t}\n\n\tif (priv->mf.field == V4L2_FIELD_ALTERNATE) {\n\t\tfld = FLD_DET_SEL(1) | FLD_FLD_EN4 | FLD_FLD_EN3 | FLD_FLD_EN2\n\t\t\t| FLD_FLD_EN;\n\n\t\tif (priv->mf.height == 240)\n\t\t\tfld |= FLD_FLD_NUM(0);\n\t\telse\n\t\t\tfld |= FLD_FLD_NUM(1);\n\t}\n\n\t \n\tret = rcsi2_get_active_lanes(priv, &lanes);\n\tif (ret)\n\t\treturn ret;\n\n\tphycnt = PHYCNT_ENABLECLK;\n\tphycnt |= (1 << lanes) - 1;\n\n\tmbps = rcsi2_calc_mbps(priv, format->bpp, lanes);\n\tif (mbps < 0)\n\t\treturn mbps;\n\n\t \n\trcsi2_write(priv, INTEN_REG, INTEN_INT_AFIFO_OF | INTEN_INT_ERRSOTHS\n\t\t    | INTEN_INT_ERRSOTSYNCHS);\n\n\t \n\trcsi2_write(priv, TREF_REG, TREF_TREF);\n\trcsi2_write(priv, PHTC_REG, 0);\n\n\t \n\tif (!priv->info->use_isp) {\n\t\trcsi2_write(priv, VCDT_REG, vcdt);\n\t\tif (vcdt2)\n\t\t\trcsi2_write(priv, VCDT2_REG, vcdt2);\n\t}\n\n\t \n\trcsi2_write(priv, LSWAP_REG,\n\t\t    LSWAP_L0SEL(priv->lane_swap[0] - 1) |\n\t\t    LSWAP_L1SEL(priv->lane_swap[1] - 1) |\n\t\t    LSWAP_L2SEL(priv->lane_swap[2] - 1) |\n\t\t    LSWAP_L3SEL(priv->lane_swap[3] - 1));\n\n\t \n\tif (priv->info->init_phtw) {\n\t\tret = priv->info->init_phtw(priv, mbps);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (priv->info->hsfreqrange) {\n\t\tret = rcsi2_set_phypll(priv, mbps);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (priv->info->csi0clkfreqrange)\n\t\trcsi2_write(priv, CSI0CLKFCPR_REG,\n\t\t\t    CSI0CLKFREQRANGE(priv->info->csi0clkfreqrange));\n\n\tif (priv->info->use_isp)\n\t\trcsi2_write(priv, PHYFRX_REG,\n\t\t\t    PHYFRX_FORCERX_MODE_3 | PHYFRX_FORCERX_MODE_2 |\n\t\t\t    PHYFRX_FORCERX_MODE_1 | PHYFRX_FORCERX_MODE_0);\n\n\trcsi2_write(priv, PHYCNT_REG, phycnt);\n\trcsi2_write(priv, LINKCNT_REG, LINKCNT_MONITOR_EN |\n\t\t    LINKCNT_REG_MONI_PACT_EN | LINKCNT_ICLK_NONSTOP);\n\trcsi2_write(priv, FLD_REG, fld);\n\trcsi2_write(priv, PHYCNT_REG, phycnt | PHYCNT_SHUTDOWNZ);\n\trcsi2_write(priv, PHYCNT_REG, phycnt | PHYCNT_SHUTDOWNZ | PHYCNT_RSTZ);\n\n\tret = rcsi2_wait_phy_start(priv, lanes);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->info->use_isp)\n\t\trcsi2_write(priv, PHYFRX_REG, 0);\n\n\t \n\tif (priv->info->phy_post_init) {\n\t\tret = priv->info->phy_post_init(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (priv->info->clear_ulps)\n\t\trcsi2_write(priv, INTSTATE_REG,\n\t\t\t    INTSTATE_INT_ULPS_START |\n\t\t\t    INTSTATE_INT_ULPS_END);\n\treturn 0;\n}\n\nstatic int rcsi2_wait_phy_start_v4h(struct rcar_csi2 *priv, u32 match)\n{\n\tunsigned int timeout;\n\tu32 status;\n\n\tfor (timeout = 0; timeout <= 10; timeout++) {\n\t\tstatus = rcsi2_read(priv, V4H_ST_PHYST_REG);\n\t\tif ((status & match) == match)\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int rcsi2_c_phy_setting_v4h(struct rcar_csi2 *priv, int msps)\n{\n\tconst struct rcsi2_cphy_setting *conf;\n\n\tfor (conf = cphy_setting_table_r8a779g0; conf->msps != 0; conf++) {\n\t\tif (conf->msps > msps)\n\t\t\tbreak;\n\t}\n\n\tif (!conf->msps) {\n\t\tdev_err(priv->dev, \"Unsupported PHY speed for msps setting (%u Msps)\", msps);\n\t\treturn -ERANGE;\n\t}\n\n\t \n\trcsi2_write16(priv, V4H_CORE_DIG_RW_COMMON_REG(7), 0x0155);\n\trcsi2_write16(priv, V4H_PPI_STARTUP_RW_COMMON_DPHY_REG(7), 0x0068);\n\trcsi2_write16(priv, V4H_PPI_STARTUP_RW_COMMON_DPHY_REG(8), 0x0010);\n\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_0_RW_LP_0_REG, 0x463c);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_1_RW_LP_0_REG, 0x463c);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_2_RW_LP_0_REG, 0x463c);\n\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_0_RW_HS_RX_REG(0), 0x00d5);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_1_RW_HS_RX_REG(0), 0x00d5);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_2_RW_HS_RX_REG(0), 0x00d5);\n\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_0_RW_HS_RX_REG(1), 0x0013);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_1_RW_HS_RX_REG(1), 0x0013);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_2_RW_HS_RX_REG(1), 0x0013);\n\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_0_RW_HS_RX_REG(5), 0x0013);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_1_RW_HS_RX_REG(5), 0x0013);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_2_RW_HS_RX_REG(5), 0x0013);\n\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_0_RW_HS_RX_REG(6), 0x000a);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_1_RW_HS_RX_REG(6), 0x000a);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_2_RW_HS_RX_REG(6), 0x000a);\n\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_0_RW_HS_RX_REG(2), conf->rx2);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_1_RW_HS_RX_REG(2), conf->rx2);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_2_RW_HS_RX_REG(2), conf->rx2);\n\n\trcsi2_write16(priv, V4H_CORE_DIG_IOCTRL_RW_AFE_LANE0_CTRL_2_REG(2), 0x0001);\n\trcsi2_write16(priv, V4H_CORE_DIG_IOCTRL_RW_AFE_LANE1_CTRL_2_REG(2), 0);\n\trcsi2_write16(priv, V4H_CORE_DIG_IOCTRL_RW_AFE_LANE2_CTRL_2_REG(2), 0x0001);\n\trcsi2_write16(priv, V4H_CORE_DIG_IOCTRL_RW_AFE_LANE3_CTRL_2_REG(2), 0x0001);\n\trcsi2_write16(priv, V4H_CORE_DIG_IOCTRL_RW_AFE_LANE4_CTRL_2_REG(2), 0);\n\n\trcsi2_write16(priv, V4H_CORE_DIG_RW_TRIO0_REG(0), conf->trio0);\n\trcsi2_write16(priv, V4H_CORE_DIG_RW_TRIO1_REG(0), conf->trio0);\n\trcsi2_write16(priv, V4H_CORE_DIG_RW_TRIO2_REG(0), conf->trio0);\n\n\trcsi2_write16(priv, V4H_CORE_DIG_RW_TRIO0_REG(2), conf->trio2);\n\trcsi2_write16(priv, V4H_CORE_DIG_RW_TRIO1_REG(2), conf->trio2);\n\trcsi2_write16(priv, V4H_CORE_DIG_RW_TRIO2_REG(2), conf->trio2);\n\n\trcsi2_write16(priv, V4H_CORE_DIG_RW_TRIO0_REG(1), conf->trio1);\n\trcsi2_write16(priv, V4H_CORE_DIG_RW_TRIO1_REG(1), conf->trio1);\n\trcsi2_write16(priv, V4H_CORE_DIG_RW_TRIO2_REG(1), conf->trio1);\n\n\t \n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_1_RW_CFG_0_REG, 0xf5);\n\trcsi2_write16(priv, V4H_CORE_DIG_CLANE_1_RW_HS_TX_6_REG, 0x5000);\n\n\t \n\trcsi2_write(priv, V4H_DPHY_RSTZ_REG, BIT(0));\n\trcsi2_write(priv, V4H_PHY_SHUTDOWNZ_REG, BIT(0));\n\n\t \n\tif (rcsi2_wait_phy_start_v4h(priv, V4H_ST_PHYST_ST_PHY_READY)) {\n\t\tdev_err(priv->dev, \"PHY calibration failed\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\trcsi2_write16(priv, V4H_CORE_DIG_IOCTRL_RW_AFE_LANE0_CTRL_2_REG(9), conf->lane29);\n\trcsi2_write16(priv, V4H_CORE_DIG_IOCTRL_RW_AFE_LANE0_CTRL_2_REG(7), conf->lane27);\n\n\treturn 0;\n}\n\nstatic int rcsi2_start_receiver_v4h(struct rcar_csi2 *priv)\n{\n\tconst struct rcar_csi2_format *format;\n\tunsigned int lanes;\n\tint msps;\n\tint ret;\n\n\t \n\tformat = rcsi2_code_to_fmt(priv->mf.code);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tret = rcsi2_get_active_lanes(priv, &lanes);\n\tif (ret)\n\t\treturn ret;\n\n\tmsps = rcsi2_calc_mbps(priv, format->bpp, lanes);\n\tif (msps < 0)\n\t\treturn msps;\n\n\t \n\trcsi2_write(priv, V4H_CSI2_RESETN_REG, 0);\n\trcsi2_write(priv, V4H_DPHY_RSTZ_REG, 0);\n\trcsi2_write(priv, V4H_PHY_SHUTDOWNZ_REG, 0);\n\n\t \n\trcsi2_write(priv, V4H_PHY_EN_REG, BIT(0));\n\trcsi2_write(priv, V4H_FLDC_REG, 0);\n\trcsi2_write(priv, V4H_FLDD_REG, 0);\n\trcsi2_write(priv, V4H_IDIC_REG, 0);\n\trcsi2_write(priv, V4H_PHY_MODE_REG, BIT(0));\n\trcsi2_write(priv, V4H_N_LANES_REG, lanes - 1);\n\n\t \n\trcsi2_write(priv, V4H_CSI2_RESETN_REG, BIT(0));\n\n\t \n\t \n\trcsi2_write16(priv, V4H_CORE_DIG_ANACTRL_RW_COMMON_ANACTRL_REG(0), 0x1bfd);\n\trcsi2_write16(priv, V4H_PPI_STARTUP_RW_COMMON_STARTUP_1_1_REG, 0x0233);\n\trcsi2_write16(priv, V4H_PPI_STARTUP_RW_COMMON_DPHY_REG(6), 0x0027);\n\trcsi2_write16(priv, V4H_PPI_CALIBCTRL_RW_COMMON_BG_0_REG, 0x01f4);\n\trcsi2_write16(priv, V4H_PPI_RW_TERMCAL_CFG_0_REG, 0x0013);\n\trcsi2_write16(priv, V4H_PPI_RW_OFFSETCAL_CFG_0_REG, 0x0003);\n\trcsi2_write16(priv, V4H_PPI_RW_LPDCOCAL_TIMEBASE_REG, 0x004f);\n\trcsi2_write16(priv, V4H_PPI_RW_LPDCOCAL_NREF_REG, 0x0320);\n\trcsi2_write16(priv, V4H_PPI_RW_LPDCOCAL_NREF_RANGE_REG, 0x000f);\n\trcsi2_write16(priv, V4H_PPI_RW_LPDCOCAL_TWAIT_CONFIG_REG, 0xfe18);\n\trcsi2_write16(priv, V4H_PPI_RW_LPDCOCAL_VT_CONFIG_REG, 0x0c3c);\n\trcsi2_write16(priv, V4H_PPI_RW_LPDCOCAL_COARSE_CFG_REG, 0x0105);\n\trcsi2_write16(priv, V4H_CORE_DIG_IOCTRL_RW_AFE_CB_CTRL_2_REG(6), 0x1000);\n\trcsi2_write16(priv, V4H_PPI_RW_COMMON_CFG_REG, 0x0003);\n\n\t \n\tret = rcsi2_c_phy_setting_v4h(priv, msps);\n\tif (ret)\n\t\treturn ret;\n\n\trcsi2_wait_phy_start_v4h(priv, V4H_ST_PHYST_ST_STOPSTATE_0 |\n\t\t\t\t V4H_ST_PHYST_ST_STOPSTATE_1 |\n\t\t\t\t V4H_ST_PHYST_ST_STOPSTATE_2);\n\n\treturn 0;\n}\n\nstatic int rcsi2_start(struct rcar_csi2 *priv)\n{\n\tint ret;\n\n\tret = rcsi2_exit_standby(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = priv->info->start_receiver(priv);\n\tif (ret) {\n\t\trcsi2_enter_standby(priv);\n\t\treturn ret;\n\t}\n\n\tret = v4l2_subdev_call(priv->remote, video, s_stream, 1);\n\tif (ret) {\n\t\trcsi2_enter_standby(priv);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rcsi2_stop(struct rcar_csi2 *priv)\n{\n\trcsi2_enter_standby(priv);\n\tv4l2_subdev_call(priv->remote, video, s_stream, 0);\n}\n\nstatic int rcsi2_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct rcar_csi2 *priv = sd_to_csi2(sd);\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tif (!priv->remote) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (enable && priv->stream_count == 0) {\n\t\tret = rcsi2_start(priv);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else if (!enable && priv->stream_count == 1) {\n\t\trcsi2_stop(priv);\n\t}\n\n\tpriv->stream_count += enable ? 1 : -1;\nout:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int rcsi2_set_pad_format(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct rcar_csi2 *priv = sd_to_csi2(sd);\n\tstruct v4l2_mbus_framefmt *framefmt;\n\n\tmutex_lock(&priv->lock);\n\n\tif (!rcsi2_code_to_fmt(format->format.code))\n\t\tformat->format.code = rcar_csi2_formats[0].code;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tpriv->mf = format->format;\n\t} else {\n\t\tframefmt = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t\t*framefmt = format->format;\n\t}\n\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int rcsi2_get_pad_format(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct rcar_csi2 *priv = sd_to_csi2(sd);\n\n\tmutex_lock(&priv->lock);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tformat->format = priv->mf;\n\telse\n\t\tformat->format = *v4l2_subdev_get_try_format(sd, sd_state, 0);\n\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops rcar_csi2_video_ops = {\n\t.s_stream = rcsi2_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops rcar_csi2_pad_ops = {\n\t.set_fmt = rcsi2_set_pad_format,\n\t.get_fmt = rcsi2_get_pad_format,\n};\n\nstatic const struct v4l2_subdev_ops rcar_csi2_subdev_ops = {\n\t.video\t= &rcar_csi2_video_ops,\n\t.pad\t= &rcar_csi2_pad_ops,\n};\n\nstatic irqreturn_t rcsi2_irq(int irq, void *data)\n{\n\tstruct rcar_csi2 *priv = data;\n\tu32 status, err_status;\n\n\tstatus = rcsi2_read(priv, INTSTATE_REG);\n\terr_status = rcsi2_read(priv, INTERRSTATE_REG);\n\n\tif (!status)\n\t\treturn IRQ_HANDLED;\n\n\trcsi2_write(priv, INTSTATE_REG, status);\n\n\tif (!err_status)\n\t\treturn IRQ_HANDLED;\n\n\trcsi2_write(priv, INTERRSTATE_REG, err_status);\n\n\tdev_info(priv->dev, \"Transfer error, restarting CSI-2 receiver\\n\");\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t rcsi2_irq_thread(int irq, void *data)\n{\n\tstruct rcar_csi2 *priv = data;\n\n\tmutex_lock(&priv->lock);\n\trcsi2_stop(priv);\n\tusleep_range(1000, 2000);\n\tif (rcsi2_start(priv))\n\t\tdev_warn(priv->dev, \"Failed to restart CSI-2 receiver\\n\");\n\tmutex_unlock(&priv->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int rcsi2_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t      struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_async_connection *asc)\n{\n\tstruct rcar_csi2 *priv = notifier_to_csi2(notifier);\n\tint pad;\n\n\tpad = media_entity_get_fwnode_pad(&subdev->entity, asc->match.fwnode,\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (pad < 0) {\n\t\tdev_err(priv->dev, \"Failed to find pad for %s\\n\", subdev->name);\n\t\treturn pad;\n\t}\n\n\tpriv->remote = subdev;\n\tpriv->remote_pad = pad;\n\n\tdev_dbg(priv->dev, \"Bound %s pad: %d\\n\", subdev->name, pad);\n\n\treturn media_create_pad_link(&subdev->entity, pad,\n\t\t\t\t     &priv->subdev.entity, 0,\n\t\t\t\t     MEDIA_LNK_FL_ENABLED |\n\t\t\t\t     MEDIA_LNK_FL_IMMUTABLE);\n}\n\nstatic void rcsi2_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\tstruct v4l2_subdev *subdev,\n\t\t\t\tstruct v4l2_async_connection *asc)\n{\n\tstruct rcar_csi2 *priv = notifier_to_csi2(notifier);\n\n\tpriv->remote = NULL;\n\n\tdev_dbg(priv->dev, \"Unbind %s\\n\", subdev->name);\n}\n\nstatic const struct v4l2_async_notifier_operations rcar_csi2_notify_ops = {\n\t.bound = rcsi2_notify_bound,\n\t.unbind = rcsi2_notify_unbind,\n};\n\nstatic int rcsi2_parse_v4l2(struct rcar_csi2 *priv,\n\t\t\t    struct v4l2_fwnode_endpoint *vep)\n{\n\tunsigned int i;\n\n\t \n\tif (vep->base.port || vep->base.id)\n\t\treturn -ENOTCONN;\n\n\tpriv->lanes = vep->bus.mipi_csi2.num_data_lanes;\n\n\tswitch (vep->bus_type) {\n\tcase V4L2_MBUS_CSI2_DPHY:\n\t\tif (!priv->info->support_dphy) {\n\t\t\tdev_err(priv->dev, \"D-PHY not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (priv->lanes != 1 && priv->lanes != 2 && priv->lanes != 4) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"Unsupported number of data-lanes for D-PHY: %u\\n\",\n\t\t\t\tpriv->lanes);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpriv->cphy = false;\n\t\tbreak;\n\tcase V4L2_MBUS_CSI2_CPHY:\n\t\tif (!priv->info->support_cphy) {\n\t\t\tdev_err(priv->dev, \"C-PHY not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (priv->lanes != 3) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"Unsupported number of data-lanes for C-PHY: %u\\n\",\n\t\t\t\tpriv->lanes);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpriv->cphy = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"Unsupported bus: %u\\n\", vep->bus_type);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->lane_swap); i++) {\n\t\tpriv->lane_swap[i] = i < priv->lanes ?\n\t\t\tvep->bus.mipi_csi2.data_lanes[i] : i;\n\n\t\t \n\t\tif (priv->lane_swap[i] < 1 || priv->lane_swap[i] > 4) {\n\t\t\tdev_err(priv->dev, \"data-lanes must be in 1-4 range\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rcsi2_parse_dt(struct rcar_csi2 *priv)\n{\n\tstruct v4l2_async_connection *asc;\n\tstruct fwnode_handle *fwnode;\n\tstruct fwnode_handle *ep;\n\tstruct v4l2_fwnode_endpoint v4l2_ep = {\n\t\t.bus_type = V4L2_MBUS_UNKNOWN,\n\t};\n\tint ret;\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(priv->dev), 0, 0, 0);\n\tif (!ep) {\n\t\tdev_err(priv->dev, \"Not connected to subdevice\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(ep, &v4l2_ep);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Could not parse v4l2 endpoint\\n\");\n\t\tfwnode_handle_put(ep);\n\t\treturn -EINVAL;\n\t}\n\n\tret = rcsi2_parse_v4l2(priv, &v4l2_ep);\n\tif (ret) {\n\t\tfwnode_handle_put(ep);\n\t\treturn ret;\n\t}\n\n\tfwnode = fwnode_graph_get_remote_endpoint(ep);\n\tfwnode_handle_put(ep);\n\n\tdev_dbg(priv->dev, \"Found '%pOF'\\n\", to_of_node(fwnode));\n\n\tv4l2_async_subdev_nf_init(&priv->notifier, &priv->subdev);\n\tpriv->notifier.ops = &rcar_csi2_notify_ops;\n\n\tasc = v4l2_async_nf_add_fwnode(&priv->notifier, fwnode,\n\t\t\t\t       struct v4l2_async_connection);\n\tfwnode_handle_put(fwnode);\n\tif (IS_ERR(asc))\n\t\treturn PTR_ERR(asc);\n\n\tret = v4l2_async_nf_register(&priv->notifier);\n\tif (ret)\n\t\tv4l2_async_nf_cleanup(&priv->notifier);\n\n\treturn ret;\n}\n\n \n\nstatic int rcsi2_phtw_write(struct rcar_csi2 *priv, u16 data, u16 code)\n{\n\tunsigned int timeout;\n\n\trcsi2_write(priv, PHTW_REG,\n\t\t    PHTW_DWEN | PHTW_TESTDIN_DATA(data) |\n\t\t    PHTW_CWEN | PHTW_TESTDIN_CODE(code));\n\n\t \n\tfor (timeout = 0; timeout <= 20; timeout++) {\n\t\tif (!(rcsi2_read(priv, PHTW_REG) & (PHTW_DWEN | PHTW_CWEN)))\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tdev_err(priv->dev, \"Timeout waiting for PHTW_DWEN and/or PHTW_CWEN\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int rcsi2_phtw_write_array(struct rcar_csi2 *priv,\n\t\t\t\t  const struct phtw_value *values)\n{\n\tconst struct phtw_value *value;\n\tint ret;\n\n\tfor (value = values; value->data || value->code; value++) {\n\t\tret = rcsi2_phtw_write(priv, value->data, value->code);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rcsi2_phtw_write_mbps(struct rcar_csi2 *priv, unsigned int mbps,\n\t\t\t\t const struct rcsi2_mbps_reg *values, u16 code)\n{\n\tconst struct rcsi2_mbps_reg *value;\n\tconst struct rcsi2_mbps_reg *prev_value = NULL;\n\n\tfor (value = values; value->mbps; value++) {\n\t\tif (value->mbps >= mbps)\n\t\t\tbreak;\n\t\tprev_value = value;\n\t}\n\n\tif (prev_value &&\n\t    ((mbps - prev_value->mbps) <= (value->mbps - mbps)))\n\t\tvalue = prev_value;\n\n\tif (!value->mbps) {\n\t\tdev_err(priv->dev, \"Unsupported PHY speed (%u Mbps)\", mbps);\n\t\treturn -ERANGE;\n\t}\n\n\treturn rcsi2_phtw_write(priv, value->reg, code);\n}\n\nstatic int __rcsi2_init_phtw_h3_v3h_m3n(struct rcar_csi2 *priv,\n\t\t\t\t\tunsigned int mbps)\n{\n\tstatic const struct phtw_value step1[] = {\n\t\t{ .data = 0xcc, .code = 0xe2 },\n\t\t{ .data = 0x01, .code = 0xe3 },\n\t\t{ .data = 0x11, .code = 0xe4 },\n\t\t{ .data = 0x01, .code = 0xe5 },\n\t\t{ .data = 0x10, .code = 0x04 },\n\t\t{   },\n\t};\n\n\tstatic const struct phtw_value step2[] = {\n\t\t{ .data = 0x38, .code = 0x08 },\n\t\t{ .data = 0x01, .code = 0x00 },\n\t\t{ .data = 0x4b, .code = 0xac },\n\t\t{ .data = 0x03, .code = 0x00 },\n\t\t{ .data = 0x80, .code = 0x07 },\n\t\t{   },\n\t};\n\n\tint ret;\n\n\tret = rcsi2_phtw_write_array(priv, step1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mbps != 0 && mbps <= 250) {\n\t\tret = rcsi2_phtw_write(priv, 0x39, 0x05);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = rcsi2_phtw_write_mbps(priv, mbps, phtw_mbps_h3_v3h_m3n,\n\t\t\t\t\t    0xf1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn rcsi2_phtw_write_array(priv, step2);\n}\n\nstatic int rcsi2_init_phtw_h3_v3h_m3n(struct rcar_csi2 *priv, unsigned int mbps)\n{\n\treturn __rcsi2_init_phtw_h3_v3h_m3n(priv, mbps);\n}\n\nstatic int rcsi2_init_phtw_h3es2(struct rcar_csi2 *priv, unsigned int mbps)\n{\n\treturn __rcsi2_init_phtw_h3_v3h_m3n(priv, 0);\n}\n\nstatic int rcsi2_init_phtw_v3m_e3(struct rcar_csi2 *priv, unsigned int mbps)\n{\n\treturn rcsi2_phtw_write_mbps(priv, mbps, phtw_mbps_v3m_e3, 0x44);\n}\n\nstatic int rcsi2_phy_post_init_v3m_e3(struct rcar_csi2 *priv)\n{\n\tstatic const struct phtw_value step1[] = {\n\t\t{ .data = 0xee, .code = 0x34 },\n\t\t{ .data = 0xee, .code = 0x44 },\n\t\t{ .data = 0xee, .code = 0x54 },\n\t\t{ .data = 0xee, .code = 0x84 },\n\t\t{ .data = 0xee, .code = 0x94 },\n\t\t{   },\n\t};\n\n\treturn rcsi2_phtw_write_array(priv, step1);\n}\n\nstatic int rcsi2_init_phtw_v3u(struct rcar_csi2 *priv,\n\t\t\t       unsigned int mbps)\n{\n\t \n\tstatic const struct phtw_value step1[] = {\n\t\t{ .data = 0xcc, .code = 0xe2 },\n\t\t{   },\n\t};\n\n\tstatic const struct phtw_value step2[] = {\n\t\t{ .data = 0x01, .code = 0xe3 },\n\t\t{ .data = 0x11, .code = 0xe4 },\n\t\t{ .data = 0x01, .code = 0xe5 },\n\t\t{   },\n\t};\n\n\t \n\tstatic const struct phtw_value step3[] = {\n\t\t{ .data = 0x38, .code = 0x08 },\n\t\t{   },\n\t};\n\n\tstatic const struct phtw_value step4[] = {\n\t\t{ .data = 0x01, .code = 0x00 },\n\t\t{ .data = 0x4b, .code = 0xac },\n\t\t{ .data = 0x03, .code = 0x00 },\n\t\t{ .data = 0x80, .code = 0x07 },\n\t\t{   },\n\t};\n\n\tint ret;\n\n\tif (mbps != 0 && mbps <= 1500)\n\t\tret = rcsi2_phtw_write_array(priv, step1);\n\telse\n\t\tret = rcsi2_phtw_write_mbps(priv, mbps, phtw_mbps_v3u, 0xe2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rcsi2_phtw_write_array(priv, step2);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mbps != 0 && mbps <= 1500) {\n\t\tret = rcsi2_phtw_write_array(priv, step3);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = rcsi2_phtw_write_array(priv, step4);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\n \n\nstatic int rcsi2_link_setup(struct media_entity *entity,\n\t\t\t    const struct media_pad *local,\n\t\t\t    const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct rcar_csi2 *priv = sd_to_csi2(sd);\n\tstruct video_device *vdev;\n\tint channel, vc;\n\tu32 id;\n\n\tif (!is_media_entity_v4l2_video_device(remote->entity)) {\n\t\tdev_err(priv->dev, \"Remote is not a video device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvdev = media_entity_to_video_device(remote->entity);\n\n\tif (of_property_read_u32(vdev->dev_parent->of_node, \"renesas,id\", &id)) {\n\t\tdev_err(priv->dev, \"No renesas,id, can't configure routing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannel = id % 4;\n\n\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\tif (media_pad_remote_pad_first(local)) {\n\t\t\tdev_dbg(priv->dev,\n\t\t\t\t\"Each VC can only be routed to one output channel\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvc = local->index - 1;\n\n\t\tdev_dbg(priv->dev, \"Route VC%d to VIN%u on output channel %d\\n\",\n\t\t\tvc, id, channel);\n\t} else {\n\t\tvc = -1;\n\t}\n\n\tpriv->channel_vc[channel] = vc;\n\n\treturn 0;\n}\n\nstatic const struct media_entity_operations rcar_csi2_entity_ops = {\n\t.link_setup = rcsi2_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic int rcsi2_probe_resources(struct rcar_csi2 *priv,\n\t\t\t\t struct platform_device *pdev)\n{\n\tint irq, ret;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq, rcsi2_irq,\n\t\t\t\t\trcsi2_irq_thread, IRQF_SHARED,\n\t\t\t\t\tKBUILD_MODNAME, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->rstc = devm_reset_control_get(&pdev->dev, NULL);\n\n\treturn PTR_ERR_OR_ZERO(priv->rstc);\n}\n\nstatic const struct rcar_csi2_info rcar_csi2_info_r8a7795 = {\n\t.init_phtw = rcsi2_init_phtw_h3_v3h_m3n,\n\t.start_receiver = rcsi2_start_receiver_gen3,\n\t.enter_standby = rcsi2_enter_standby_gen3,\n\t.hsfreqrange = hsfreqrange_h3_v3h_m3n,\n\t.csi0clkfreqrange = 0x20,\n\t.num_channels = 4,\n\t.clear_ulps = true,\n\t.support_dphy = true,\n};\n\nstatic const struct rcar_csi2_info rcar_csi2_info_r8a7795es2 = {\n\t.init_phtw = rcsi2_init_phtw_h3es2,\n\t.start_receiver = rcsi2_start_receiver_gen3,\n\t.enter_standby = rcsi2_enter_standby_gen3,\n\t.hsfreqrange = hsfreqrange_h3_v3h_m3n,\n\t.csi0clkfreqrange = 0x20,\n\t.num_channels = 4,\n\t.clear_ulps = true,\n\t.support_dphy = true,\n};\n\nstatic const struct rcar_csi2_info rcar_csi2_info_r8a7796 = {\n\t.start_receiver = rcsi2_start_receiver_gen3,\n\t.enter_standby = rcsi2_enter_standby_gen3,\n\t.hsfreqrange = hsfreqrange_m3w,\n\t.num_channels = 4,\n\t.support_dphy = true,\n};\n\nstatic const struct rcar_csi2_info rcar_csi2_info_r8a77961 = {\n\t.start_receiver = rcsi2_start_receiver_gen3,\n\t.enter_standby = rcsi2_enter_standby_gen3,\n\t.hsfreqrange = hsfreqrange_m3w,\n\t.num_channels = 4,\n\t.support_dphy = true,\n};\n\nstatic const struct rcar_csi2_info rcar_csi2_info_r8a77965 = {\n\t.init_phtw = rcsi2_init_phtw_h3_v3h_m3n,\n\t.start_receiver = rcsi2_start_receiver_gen3,\n\t.enter_standby = rcsi2_enter_standby_gen3,\n\t.hsfreqrange = hsfreqrange_h3_v3h_m3n,\n\t.csi0clkfreqrange = 0x20,\n\t.num_channels = 4,\n\t.clear_ulps = true,\n\t.support_dphy = true,\n};\n\nstatic const struct rcar_csi2_info rcar_csi2_info_r8a77970 = {\n\t.init_phtw = rcsi2_init_phtw_v3m_e3,\n\t.phy_post_init = rcsi2_phy_post_init_v3m_e3,\n\t.start_receiver = rcsi2_start_receiver_gen3,\n\t.enter_standby = rcsi2_enter_standby_gen3,\n\t.num_channels = 4,\n\t.support_dphy = true,\n};\n\nstatic const struct rcar_csi2_info rcar_csi2_info_r8a77980 = {\n\t.init_phtw = rcsi2_init_phtw_h3_v3h_m3n,\n\t.start_receiver = rcsi2_start_receiver_gen3,\n\t.enter_standby = rcsi2_enter_standby_gen3,\n\t.hsfreqrange = hsfreqrange_h3_v3h_m3n,\n\t.csi0clkfreqrange = 0x20,\n\t.clear_ulps = true,\n\t.support_dphy = true,\n};\n\nstatic const struct rcar_csi2_info rcar_csi2_info_r8a77990 = {\n\t.init_phtw = rcsi2_init_phtw_v3m_e3,\n\t.phy_post_init = rcsi2_phy_post_init_v3m_e3,\n\t.start_receiver = rcsi2_start_receiver_gen3,\n\t.enter_standby = rcsi2_enter_standby_gen3,\n\t.num_channels = 2,\n\t.support_dphy = true,\n};\n\nstatic const struct rcar_csi2_info rcar_csi2_info_r8a779a0 = {\n\t.init_phtw = rcsi2_init_phtw_v3u,\n\t.start_receiver = rcsi2_start_receiver_gen3,\n\t.enter_standby = rcsi2_enter_standby_gen3,\n\t.hsfreqrange = hsfreqrange_v3u,\n\t.csi0clkfreqrange = 0x20,\n\t.clear_ulps = true,\n\t.use_isp = true,\n\t.support_dphy = true,\n};\n\nstatic const struct rcar_csi2_info rcar_csi2_info_r8a779g0 = {\n\t.start_receiver = rcsi2_start_receiver_v4h,\n\t.use_isp = true,\n\t.support_cphy = true,\n};\n\nstatic const struct of_device_id rcar_csi2_of_table[] = {\n\t{\n\t\t.compatible = \"renesas,r8a774a1-csi2\",\n\t\t.data = &rcar_csi2_info_r8a7796,\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a774b1-csi2\",\n\t\t.data = &rcar_csi2_info_r8a77965,\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a774c0-csi2\",\n\t\t.data = &rcar_csi2_info_r8a77990,\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a774e1-csi2\",\n\t\t.data = &rcar_csi2_info_r8a7795,\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a7795-csi2\",\n\t\t.data = &rcar_csi2_info_r8a7795,\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a7796-csi2\",\n\t\t.data = &rcar_csi2_info_r8a7796,\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a77961-csi2\",\n\t\t.data = &rcar_csi2_info_r8a77961,\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a77965-csi2\",\n\t\t.data = &rcar_csi2_info_r8a77965,\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a77970-csi2\",\n\t\t.data = &rcar_csi2_info_r8a77970,\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a77980-csi2\",\n\t\t.data = &rcar_csi2_info_r8a77980,\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a77990-csi2\",\n\t\t.data = &rcar_csi2_info_r8a77990,\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a779a0-csi2\",\n\t\t.data = &rcar_csi2_info_r8a779a0,\n\t},\n\t{\n\t\t.compatible = \"renesas,r8a779g0-csi2\",\n\t\t.data = &rcar_csi2_info_r8a779g0,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, rcar_csi2_of_table);\n\nstatic const struct soc_device_attribute r8a7795[] = {\n\t{\n\t\t.soc_id = \"r8a7795\", .revision = \"ES2.*\",\n\t\t.data = &rcar_csi2_info_r8a7795es2,\n\t},\n\t{   }\n};\n\nstatic int rcsi2_probe(struct platform_device *pdev)\n{\n\tconst struct soc_device_attribute *attr;\n\tstruct rcar_csi2 *priv;\n\tunsigned int i, num_pads;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->info = of_device_get_match_data(&pdev->dev);\n\n\t \n\tattr = soc_device_match(r8a7795);\n\tif (attr)\n\t\tpriv->info = attr->data;\n\n\tpriv->dev = &pdev->dev;\n\n\tmutex_init(&priv->lock);\n\tpriv->stream_count = 0;\n\n\tret = rcsi2_probe_resources(priv, pdev);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to get resources\\n\");\n\t\tgoto error_mutex;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = rcsi2_parse_dt(priv);\n\tif (ret)\n\t\tgoto error_mutex;\n\n\tpriv->subdev.owner = THIS_MODULE;\n\tpriv->subdev.dev = &pdev->dev;\n\tv4l2_subdev_init(&priv->subdev, &rcar_csi2_subdev_ops);\n\tv4l2_set_subdevdata(&priv->subdev, &pdev->dev);\n\tsnprintf(priv->subdev.name, V4L2_SUBDEV_NAME_SIZE, \"%s %s\",\n\t\t KBUILD_MODNAME, dev_name(&pdev->dev));\n\tpriv->subdev.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tpriv->subdev.entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;\n\tpriv->subdev.entity.ops = &rcar_csi2_entity_ops;\n\n\tnum_pads = priv->info->use_isp ? 2 : NR_OF_RCAR_CSI2_PAD;\n\n\tpriv->pads[RCAR_CSI2_SINK].flags = MEDIA_PAD_FL_SINK;\n\tfor (i = RCAR_CSI2_SOURCE_VC0; i < num_pads; i++)\n\t\tpriv->pads[i].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&priv->subdev.entity, num_pads,\n\t\t\t\t     priv->pads);\n\tif (ret)\n\t\tgoto error_async;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->channel_vc); i++)\n\t\tpriv->channel_vc[i] = -1;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = v4l2_async_register_subdev(&priv->subdev);\n\tif (ret < 0)\n\t\tgoto error_async;\n\n\tdev_info(priv->dev, \"%d lanes found\\n\", priv->lanes);\n\n\treturn 0;\n\nerror_async:\n\tv4l2_async_nf_unregister(&priv->notifier);\n\tv4l2_async_nf_cleanup(&priv->notifier);\nerror_mutex:\n\tmutex_destroy(&priv->lock);\n\n\treturn ret;\n}\n\nstatic void rcsi2_remove(struct platform_device *pdev)\n{\n\tstruct rcar_csi2 *priv = platform_get_drvdata(pdev);\n\n\tv4l2_async_nf_unregister(&priv->notifier);\n\tv4l2_async_nf_cleanup(&priv->notifier);\n\tv4l2_async_unregister_subdev(&priv->subdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tmutex_destroy(&priv->lock);\n}\n\nstatic struct platform_driver rcar_csi2_pdrv = {\n\t.remove_new = rcsi2_remove,\n\t.probe\t= rcsi2_probe,\n\t.driver\t= {\n\t\t.name\t= \"rcar-csi2\",\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table\t= rcar_csi2_of_table,\n\t},\n};\n\nmodule_platform_driver(rcar_csi2_pdrv);\n\nMODULE_AUTHOR(\"Niklas S\u00f6derlund <niklas.soderlund@ragnatech.se>\");\nMODULE_DESCRIPTION(\"Renesas R-Car MIPI CSI-2 receiver driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}