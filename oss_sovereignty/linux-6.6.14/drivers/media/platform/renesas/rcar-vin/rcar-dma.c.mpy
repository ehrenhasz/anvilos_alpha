{
  "module_name": "rcar-dma.c",
  "hash_id": "105d19e6c3dc85ea40935611075b92043f616eddce55c1aa3ea048dbb26b598c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/rcar-vin/rcar-dma.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n\n#include <media/videobuf2-dma-contig.h>\n\n#include \"rcar-vin.h\"\n\n \n\n \n#define VNMC_REG\t0x00\t \n#define VNMS_REG\t0x04\t \n#define VNFC_REG\t0x08\t \n#define VNSLPRC_REG\t0x0C\t \n#define VNELPRC_REG\t0x10\t \n#define VNSPPRC_REG\t0x14\t \n#define VNEPPRC_REG\t0x18\t \n#define VNIS_REG\t0x2C\t \n#define VNMB_REG(m)\t(0x30 + ((m) << 2))  \n#define VNIE_REG\t0x40\t \n#define VNINTS_REG\t0x44\t \n#define VNSI_REG\t0x48\t \n#define VNMTC_REG\t0x4C\t \n#define VNDMR_REG\t0x58\t \n#define VNDMR2_REG\t0x5C\t \n#define VNUVAOF_REG\t0x60\t \n\n \n#define VNSLPOC_REG\t0x1C\t \n#define VNELPOC_REG\t0x20\t \n#define VNSPPOC_REG\t0x24\t \n#define VNEPPOC_REG\t0x28\t \n#define VNYS_REG\t0x50\t \n#define VNXS_REG\t0x54\t \n#define VNC1A_REG\t0x80\t \n#define VNC1B_REG\t0x84\t \n#define VNC1C_REG\t0x88\t \n#define VNC2A_REG\t0x90\t \n#define VNC2B_REG\t0x94\t \n#define VNC2C_REG\t0x98\t \n#define VNC3A_REG\t0xA0\t \n#define VNC3B_REG\t0xA4\t \n#define VNC3C_REG\t0xA8\t \n#define VNC4A_REG\t0xB0\t \n#define VNC4B_REG\t0xB4\t \n#define VNC4C_REG\t0xB8\t \n#define VNC5A_REG\t0xC0\t \n#define VNC5B_REG\t0xC4\t \n#define VNC5C_REG\t0xC8\t \n#define VNC6A_REG\t0xD0\t \n#define VNC6B_REG\t0xD4\t \n#define VNC6C_REG\t0xD8\t \n#define VNC7A_REG\t0xE0\t \n#define VNC7B_REG\t0xE4\t \n#define VNC7C_REG\t0xE8\t \n#define VNC8A_REG\t0xF0\t \n#define VNC8B_REG\t0xF4\t \n#define VNC8C_REG\t0xF8\t \n\n \n#define VNCSI_IFMD_REG\t\t0x20  \n#define VNUDS_CTRL_REG\t\t0x80  \n#define VNUDS_SCALE_REG\t\t0x84  \n#define VNUDS_PASS_BWIDTH_REG\t0x90  \n#define VNUDS_CLIP_SIZE_REG\t0xa4  \n\n \n \n#define VNMC_INF_MASK\t\t(7 << 16)\n#define VNMC_DPINE\t\t(1 << 27)  \n#define VNMC_SCLE\t\t(1 << 26)  \n#define VNMC_FOC\t\t(1 << 21)\n#define VNMC_YCAL\t\t(1 << 19)\n#define VNMC_INF_YUV8_BT656\t(0 << 16)\n#define VNMC_INF_YUV8_BT601\t(1 << 16)\n#define VNMC_INF_YUV10_BT656\t(2 << 16)\n#define VNMC_INF_YUV10_BT601\t(3 << 16)\n#define VNMC_INF_RAW8\t\t(4 << 16)\n#define VNMC_INF_YUV16\t\t(5 << 16)\n#define VNMC_INF_RGB888\t\t(6 << 16)\n#define VNMC_INF_RGB666\t\t(7 << 16)\n#define VNMC_VUP\t\t(1 << 10)\n#define VNMC_IM_ODD\t\t(0 << 3)\n#define VNMC_IM_ODD_EVEN\t(1 << 3)\n#define VNMC_IM_EVEN\t\t(2 << 3)\n#define VNMC_IM_FULL\t\t(3 << 3)\n#define VNMC_BPS\t\t(1 << 1)\n#define VNMC_ME\t\t\t(1 << 0)\n\n \n#define VNMS_FBS_MASK\t\t(3 << 3)\n#define VNMS_FBS_SHIFT\t\t3\n#define VNMS_FS\t\t\t(1 << 2)\n#define VNMS_AV\t\t\t(1 << 1)\n#define VNMS_CA\t\t\t(1 << 0)\n\n \n#define VNFC_C_FRAME\t\t(1 << 1)\n#define VNFC_S_FRAME\t\t(1 << 0)\n\n \n#define VNIE_FIE\t\t(1 << 4)\n#define VNIE_EFE\t\t(1 << 1)\n\n \n#define VNINTS_FIS\t\t(1 << 4)\n\n \n#define VNDMR_A8BIT(n)\t\t(((n) & 0xff) << 24)\n#define VNDMR_A8BIT_MASK\t(0xff << 24)\n#define VNDMR_YMODE_Y8\t\t(1 << 12)\n#define VNDMR_EXRGB\t\t(1 << 8)\n#define VNDMR_BPSM\t\t(1 << 4)\n#define VNDMR_ABIT\t\t(1 << 2)\n#define VNDMR_DTMD_YCSEP\t(1 << 1)\n#define VNDMR_DTMD_ARGB\t\t(1 << 0)\n#define VNDMR_DTMD_YCSEP_420\t(3 << 0)\n\n \n#define VNDMR2_VPS\t\t(1 << 30)\n#define VNDMR2_HPS\t\t(1 << 29)\n#define VNDMR2_CES\t\t(1 << 28)\n#define VNDMR2_YDS\t\t(1 << 22)\n#define VNDMR2_FTEV\t\t(1 << 17)\n#define VNDMR2_VLV(n)\t\t((n & 0xf) << 12)\n\n \n#define VNCSI_IFMD_DES1\t\t(1 << 26)\n#define VNCSI_IFMD_DES0\t\t(1 << 25)\n#define VNCSI_IFMD_CSI_CHSEL(n) (((n) & 0xf) << 0)\n\n \n#define VNUDS_CTRL_AMD\t\t(1 << 30)\n\nstruct rvin_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\n#define to_buf_list(vb2_buffer) (&container_of(vb2_buffer, \\\n\t\t\t\t\t       struct rvin_buffer, \\\n\t\t\t\t\t       vb)->list)\n\nstatic void rvin_write(struct rvin_dev *vin, u32 value, u32 offset)\n{\n\tiowrite32(value, vin->base + offset);\n}\n\nstatic u32 rvin_read(struct rvin_dev *vin, u32 offset)\n{\n\treturn ioread32(vin->base + offset);\n}\n\n \n\nstatic bool rvin_scaler_needed(const struct rvin_dev *vin)\n{\n\treturn !(vin->crop.width == vin->format.width &&\n\t\t vin->compose.width == vin->format.width &&\n\t\t vin->crop.height == vin->format.height &&\n\t\t vin->compose.height == vin->format.height);\n}\n\nstruct vin_coeff {\n\tunsigned short xs_value;\n\tu32 coeff_set[24];\n};\n\nstatic const struct vin_coeff vin_coeff_set[] = {\n\t{ 0x0000, {\n\t\t\t  0x00000000, 0x00000000, 0x00000000,\n\t\t\t  0x00000000, 0x00000000, 0x00000000,\n\t\t\t  0x00000000, 0x00000000, 0x00000000,\n\t\t\t  0x00000000, 0x00000000, 0x00000000,\n\t\t\t  0x00000000, 0x00000000, 0x00000000,\n\t\t\t  0x00000000, 0x00000000, 0x00000000,\n\t\t\t  0x00000000, 0x00000000, 0x00000000,\n\t\t\t  0x00000000, 0x00000000, 0x00000000 },\n\t},\n\t{ 0x1000, {\n\t\t\t  0x000fa400, 0x000fa400, 0x09625902,\n\t\t\t  0x000003f8, 0x00000403, 0x3de0d9f0,\n\t\t\t  0x001fffed, 0x00000804, 0x3cc1f9c3,\n\t\t\t  0x001003de, 0x00000c01, 0x3cb34d7f,\n\t\t\t  0x002003d2, 0x00000c00, 0x3d24a92d,\n\t\t\t  0x00200bca, 0x00000bff, 0x3df600d2,\n\t\t\t  0x002013cc, 0x000007ff, 0x3ed70c7e,\n\t\t\t  0x00100fde, 0x00000000, 0x3f87c036 },\n\t},\n\t{ 0x1200, {\n\t\t\t  0x002ffff1, 0x002ffff1, 0x02a0a9c8,\n\t\t\t  0x002003e7, 0x001ffffa, 0x000185bc,\n\t\t\t  0x002007dc, 0x000003ff, 0x3e52859c,\n\t\t\t  0x00200bd4, 0x00000002, 0x3d53996b,\n\t\t\t  0x00100fd0, 0x00000403, 0x3d04ad2d,\n\t\t\t  0x00000bd5, 0x00000403, 0x3d35ace7,\n\t\t\t  0x3ff003e4, 0x00000801, 0x3dc674a1,\n\t\t\t  0x3fffe800, 0x00000800, 0x3e76f461 },\n\t},\n\t{ 0x1400, {\n\t\t\t  0x00100be3, 0x00100be3, 0x04d1359a,\n\t\t\t  0x00000fdb, 0x002003ed, 0x0211fd93,\n\t\t\t  0x00000fd6, 0x002003f4, 0x0002d97b,\n\t\t\t  0x000007d6, 0x002ffffb, 0x3e93b956,\n\t\t\t  0x3ff003da, 0x001003ff, 0x3db49926,\n\t\t\t  0x3fffefe9, 0x00100001, 0x3d655cee,\n\t\t\t  0x3fffd400, 0x00000003, 0x3d65f4b6,\n\t\t\t  0x000fb421, 0x00000402, 0x3dc6547e },\n\t},\n\t{ 0x1600, {\n\t\t\t  0x00000bdd, 0x00000bdd, 0x06519578,\n\t\t\t  0x3ff007da, 0x00000be3, 0x03c24973,\n\t\t\t  0x3ff003d9, 0x00000be9, 0x01b30d5f,\n\t\t\t  0x3ffff7df, 0x001003f1, 0x0003c542,\n\t\t\t  0x000fdfec, 0x001003f7, 0x3ec4711d,\n\t\t\t  0x000fc400, 0x002ffffd, 0x3df504f1,\n\t\t\t  0x001fa81a, 0x002ffc00, 0x3d957cc2,\n\t\t\t  0x002f8c3c, 0x00100000, 0x3db5c891 },\n\t},\n\t{ 0x1800, {\n\t\t\t  0x3ff003dc, 0x3ff003dc, 0x0791e558,\n\t\t\t  0x000ff7dd, 0x3ff007de, 0x05328554,\n\t\t\t  0x000fe7e3, 0x3ff00be2, 0x03232546,\n\t\t\t  0x000fd7ee, 0x000007e9, 0x0143bd30,\n\t\t\t  0x001fb800, 0x000007ee, 0x00044511,\n\t\t\t  0x002fa015, 0x000007f4, 0x3ef4bcee,\n\t\t\t  0x002f8832, 0x001003f9, 0x3e4514c7,\n\t\t\t  0x001f7853, 0x001003fd, 0x3de54c9f },\n\t},\n\t{ 0x1a00, {\n\t\t\t  0x000fefe0, 0x000fefe0, 0x08721d3c,\n\t\t\t  0x001fdbe7, 0x000ffbde, 0x0652a139,\n\t\t\t  0x001fcbf0, 0x000003df, 0x0463292e,\n\t\t\t  0x002fb3ff, 0x3ff007e3, 0x0293a91d,\n\t\t\t  0x002f9c12, 0x3ff00be7, 0x01241905,\n\t\t\t  0x001f8c29, 0x000007ed, 0x3fe470eb,\n\t\t\t  0x000f7c46, 0x000007f2, 0x3f04b8ca,\n\t\t\t  0x3fef7865, 0x000007f6, 0x3e74e4a8 },\n\t},\n\t{ 0x1c00, {\n\t\t\t  0x001fd3e9, 0x001fd3e9, 0x08f23d26,\n\t\t\t  0x002fbff3, 0x001fe3e4, 0x0712ad23,\n\t\t\t  0x002fa800, 0x000ff3e0, 0x05631d1b,\n\t\t\t  0x001f9810, 0x000ffbe1, 0x03b3890d,\n\t\t\t  0x000f8c23, 0x000003e3, 0x0233e8fa,\n\t\t\t  0x3fef843b, 0x000003e7, 0x00f430e4,\n\t\t\t  0x3fbf8456, 0x3ff00bea, 0x00046cc8,\n\t\t\t  0x3f8f8c72, 0x3ff00bef, 0x3f3490ac },\n\t},\n\t{ 0x1e00, {\n\t\t\t  0x001fbbf4, 0x001fbbf4, 0x09425112,\n\t\t\t  0x001fa800, 0x002fc7ed, 0x0792b110,\n\t\t\t  0x000f980e, 0x001fdbe6, 0x0613110a,\n\t\t\t  0x3fff8c20, 0x001fe7e3, 0x04a368fd,\n\t\t\t  0x3fcf8c33, 0x000ff7e2, 0x0343b8ed,\n\t\t\t  0x3f9f8c4a, 0x000fffe3, 0x0203f8da,\n\t\t\t  0x3f5f9c61, 0x000003e6, 0x00e428c5,\n\t\t\t  0x3f1fb07b, 0x000003eb, 0x3fe440af },\n\t},\n\t{ 0x2000, {\n\t\t\t  0x000fa400, 0x000fa400, 0x09625902,\n\t\t\t  0x3fff980c, 0x001fb7f5, 0x0812b0ff,\n\t\t\t  0x3fdf901c, 0x001fc7ed, 0x06b2fcfa,\n\t\t\t  0x3faf902d, 0x001fd3e8, 0x055348f1,\n\t\t\t  0x3f7f983f, 0x001fe3e5, 0x04038ce3,\n\t\t\t  0x3f3fa454, 0x001fefe3, 0x02e3c8d1,\n\t\t\t  0x3f0fb86a, 0x001ff7e4, 0x01c3e8c0,\n\t\t\t  0x3ecfd880, 0x000fffe6, 0x00c404ac },\n\t},\n\t{ 0x2200, {\n\t\t\t  0x3fdf9c0b, 0x3fdf9c0b, 0x09725cf4,\n\t\t\t  0x3fbf9818, 0x3fffa400, 0x0842a8f1,\n\t\t\t  0x3f8f9827, 0x000fb3f7, 0x0702f0ec,\n\t\t\t  0x3f5fa037, 0x000fc3ef, 0x05d330e4,\n\t\t\t  0x3f2fac49, 0x001fcfea, 0x04a364d9,\n\t\t\t  0x3effc05c, 0x001fdbe7, 0x038394ca,\n\t\t\t  0x3ecfdc6f, 0x001fe7e6, 0x0273b0bb,\n\t\t\t  0x3ea00083, 0x001fefe6, 0x0183c0a9 },\n\t},\n\t{ 0x2400, {\n\t\t\t  0x3f9fa014, 0x3f9fa014, 0x098260e6,\n\t\t\t  0x3f7f9c23, 0x3fcf9c0a, 0x08629ce5,\n\t\t\t  0x3f4fa431, 0x3fefa400, 0x0742d8e1,\n\t\t\t  0x3f1fb440, 0x3fffb3f8, 0x062310d9,\n\t\t\t  0x3eefc850, 0x000fbbf2, 0x050340d0,\n\t\t\t  0x3ecfe062, 0x000fcbec, 0x041364c2,\n\t\t\t  0x3ea00073, 0x001fd3ea, 0x03037cb5,\n\t\t\t  0x3e902086, 0x001fdfe8, 0x022388a5 },\n\t},\n\t{ 0x2600, {\n\t\t\t  0x3f5fa81e, 0x3f5fa81e, 0x096258da,\n\t\t\t  0x3f3fac2b, 0x3f8fa412, 0x088290d8,\n\t\t\t  0x3f0fbc38, 0x3fafa408, 0x0772c8d5,\n\t\t\t  0x3eefcc47, 0x3fcfa800, 0x0672f4ce,\n\t\t\t  0x3ecfe456, 0x3fefaffa, 0x05531cc6,\n\t\t\t  0x3eb00066, 0x3fffbbf3, 0x047334bb,\n\t\t\t  0x3ea01c77, 0x000fc7ee, 0x039348ae,\n\t\t\t  0x3ea04486, 0x000fd3eb, 0x02b350a1 },\n\t},\n\t{ 0x2800, {\n\t\t\t  0x3f2fb426, 0x3f2fb426, 0x094250ce,\n\t\t\t  0x3f0fc032, 0x3f4fac1b, 0x086284cd,\n\t\t\t  0x3eefd040, 0x3f7fa811, 0x0782acc9,\n\t\t\t  0x3ecfe84c, 0x3f9fa807, 0x06a2d8c4,\n\t\t\t  0x3eb0005b, 0x3fbfac00, 0x05b2f4bc,\n\t\t\t  0x3eb0186a, 0x3fdfb3fa, 0x04c308b4,\n\t\t\t  0x3eb04077, 0x3fefbbf4, 0x03f31ca8,\n\t\t\t  0x3ec06884, 0x000fbff2, 0x03031c9e },\n\t},\n\t{ 0x2a00, {\n\t\t\t  0x3f0fc42d, 0x3f0fc42d, 0x090240c4,\n\t\t\t  0x3eefd439, 0x3f2fb822, 0x08526cc2,\n\t\t\t  0x3edfe845, 0x3f4fb018, 0x078294bf,\n\t\t\t  0x3ec00051, 0x3f6fac0f, 0x06b2b4bb,\n\t\t\t  0x3ec0185f, 0x3f8fac07, 0x05e2ccb4,\n\t\t\t  0x3ec0386b, 0x3fafac00, 0x0502e8ac,\n\t\t\t  0x3ed05c77, 0x3fcfb3fb, 0x0432f0a3,\n\t\t\t  0x3ef08482, 0x3fdfbbf6, 0x0372f898 },\n\t},\n\t{ 0x2c00, {\n\t\t\t  0x3eefdc31, 0x3eefdc31, 0x08e238b8,\n\t\t\t  0x3edfec3d, 0x3f0fc828, 0x082258b9,\n\t\t\t  0x3ed00049, 0x3f1fc01e, 0x077278b6,\n\t\t\t  0x3ed01455, 0x3f3fb815, 0x06c294b2,\n\t\t\t  0x3ed03460, 0x3f5fb40d, 0x0602acac,\n\t\t\t  0x3ef0506c, 0x3f7fb006, 0x0542c0a4,\n\t\t\t  0x3f107476, 0x3f9fb400, 0x0472c89d,\n\t\t\t  0x3f309c80, 0x3fbfb7fc, 0x03b2cc94 },\n\t},\n\t{ 0x2e00, {\n\t\t\t  0x3eefec37, 0x3eefec37, 0x088220b0,\n\t\t\t  0x3ee00041, 0x3effdc2d, 0x07f244ae,\n\t\t\t  0x3ee0144c, 0x3f0fd023, 0x07625cad,\n\t\t\t  0x3ef02c57, 0x3f1fc81a, 0x06c274a9,\n\t\t\t  0x3f004861, 0x3f3fbc13, 0x060288a6,\n\t\t\t  0x3f20686b, 0x3f5fb80c, 0x05529c9e,\n\t\t\t  0x3f408c74, 0x3f6fb805, 0x04b2ac96,\n\t\t\t  0x3f80ac7e, 0x3f8fb800, 0x0402ac8e },\n\t},\n\t{ 0x3000, {\n\t\t\t  0x3ef0003a, 0x3ef0003a, 0x084210a6,\n\t\t\t  0x3ef01045, 0x3effec32, 0x07b228a7,\n\t\t\t  0x3f00284e, 0x3f0fdc29, 0x073244a4,\n\t\t\t  0x3f104058, 0x3f0fd420, 0x06a258a2,\n\t\t\t  0x3f305c62, 0x3f2fc818, 0x0612689d,\n\t\t\t  0x3f508069, 0x3f3fc011, 0x05728496,\n\t\t\t  0x3f80a072, 0x3f4fc00a, 0x04d28c90,\n\t\t\t  0x3fc0c07b, 0x3f6fbc04, 0x04429088 },\n\t},\n\t{ 0x3200, {\n\t\t\t  0x3f00103e, 0x3f00103e, 0x07f1fc9e,\n\t\t\t  0x3f102447, 0x3f000035, 0x0782149d,\n\t\t\t  0x3f203c4f, 0x3f0ff02c, 0x07122c9c,\n\t\t\t  0x3f405458, 0x3f0fe424, 0x06924099,\n\t\t\t  0x3f607061, 0x3f1fd41d, 0x06024c97,\n\t\t\t  0x3f909068, 0x3f2fcc16, 0x05726490,\n\t\t\t  0x3fc0b070, 0x3f3fc80f, 0x04f26c8a,\n\t\t\t  0x0000d077, 0x3f4fc409, 0x04627484 },\n\t},\n\t{ 0x3400, {\n\t\t\t  0x3f202040, 0x3f202040, 0x07a1e898,\n\t\t\t  0x3f303449, 0x3f100c38, 0x0741fc98,\n\t\t\t  0x3f504c50, 0x3f10002f, 0x06e21495,\n\t\t\t  0x3f706459, 0x3f1ff028, 0x06722492,\n\t\t\t  0x3fa08060, 0x3f1fe421, 0x05f2348f,\n\t\t\t  0x3fd09c67, 0x3f1fdc19, 0x05824c89,\n\t\t\t  0x0000bc6e, 0x3f2fd014, 0x04f25086,\n\t\t\t  0x0040dc74, 0x3f3fcc0d, 0x04825c7f },\n\t},\n\t{ 0x3600, {\n\t\t\t  0x3f403042, 0x3f403042, 0x0761d890,\n\t\t\t  0x3f504848, 0x3f301c3b, 0x0701f090,\n\t\t\t  0x3f805c50, 0x3f200c33, 0x06a2008f,\n\t\t\t  0x3fa07458, 0x3f10002b, 0x06520c8d,\n\t\t\t  0x3fd0905e, 0x3f1ff424, 0x05e22089,\n\t\t\t  0x0000ac65, 0x3f1fe81d, 0x05823483,\n\t\t\t  0x0030cc6a, 0x3f2fdc18, 0x04f23c81,\n\t\t\t  0x0080e871, 0x3f2fd412, 0x0482407c },\n\t},\n\t{ 0x3800, {\n\t\t\t  0x3f604043, 0x3f604043, 0x0721c88a,\n\t\t\t  0x3f80544a, 0x3f502c3c, 0x06d1d88a,\n\t\t\t  0x3fb06851, 0x3f301c35, 0x0681e889,\n\t\t\t  0x3fd08456, 0x3f30082f, 0x0611fc88,\n\t\t\t  0x00009c5d, 0x3f200027, 0x05d20884,\n\t\t\t  0x0030b863, 0x3f2ff421, 0x05621880,\n\t\t\t  0x0070d468, 0x3f2fe81b, 0x0502247c,\n\t\t\t  0x00c0ec6f, 0x3f2fe015, 0x04a22877 },\n\t},\n\t{ 0x3a00, {\n\t\t\t  0x3f904c44, 0x3f904c44, 0x06e1b884,\n\t\t\t  0x3fb0604a, 0x3f70383e, 0x0691c885,\n\t\t\t  0x3fe07451, 0x3f502c36, 0x0661d483,\n\t\t\t  0x00009055, 0x3f401831, 0x0601ec81,\n\t\t\t  0x0030a85b, 0x3f300c2a, 0x05b1f480,\n\t\t\t  0x0070c061, 0x3f300024, 0x0562047a,\n\t\t\t  0x00b0d867, 0x3f3ff41e, 0x05020c77,\n\t\t\t  0x00f0f46b, 0x3f2fec19, 0x04a21474 },\n\t},\n\t{ 0x3c00, {\n\t\t\t  0x3fb05c43, 0x3fb05c43, 0x06c1b07e,\n\t\t\t  0x3fe06c4b, 0x3f902c3f, 0x0681c081,\n\t\t\t  0x0000844f, 0x3f703838, 0x0631cc7d,\n\t\t\t  0x00309855, 0x3f602433, 0x05d1d47e,\n\t\t\t  0x0060b459, 0x3f50142e, 0x0581e47b,\n\t\t\t  0x00a0c85f, 0x3f400828, 0x0531f078,\n\t\t\t  0x00e0e064, 0x3f300021, 0x0501fc73,\n\t\t\t  0x00b0fc6a, 0x3f3ff41d, 0x04a20873 },\n\t},\n\t{ 0x3e00, {\n\t\t\t  0x3fe06444, 0x3fe06444, 0x0681a07a,\n\t\t\t  0x00007849, 0x3fc0503f, 0x0641b07a,\n\t\t\t  0x0020904d, 0x3fa0403a, 0x05f1c07a,\n\t\t\t  0x0060a453, 0x3f803034, 0x05c1c878,\n\t\t\t  0x0090b858, 0x3f70202f, 0x0571d477,\n\t\t\t  0x00d0d05d, 0x3f501829, 0x0531e073,\n\t\t\t  0x0110e462, 0x3f500825, 0x04e1e471,\n\t\t\t  0x01510065, 0x3f40001f, 0x04a1f06d },\n\t},\n\t{ 0x4000, {\n\t\t\t  0x00007044, 0x00007044, 0x06519476,\n\t\t\t  0x00208448, 0x3fe05c3f, 0x0621a476,\n\t\t\t  0x0050984d, 0x3fc04c3a, 0x05e1b075,\n\t\t\t  0x0080ac52, 0x3fa03c35, 0x05a1b875,\n\t\t\t  0x00c0c056, 0x3f803030, 0x0561c473,\n\t\t\t  0x0100d45b, 0x3f70202b, 0x0521d46f,\n\t\t\t  0x0140e860, 0x3f601427, 0x04d1d46e,\n\t\t\t  0x01810064, 0x3f500822, 0x0491dc6b },\n\t},\n\t{ 0x5000, {\n\t\t\t  0x0110a442, 0x0110a442, 0x0551545e,\n\t\t\t  0x0140b045, 0x00e0983f, 0x0531585f,\n\t\t\t  0x0160c047, 0x00c08c3c, 0x0511645e,\n\t\t\t  0x0190cc4a, 0x00908039, 0x04f1685f,\n\t\t\t  0x01c0dc4c, 0x00707436, 0x04d1705e,\n\t\t\t  0x0200e850, 0x00506833, 0x04b1785b,\n\t\t\t  0x0230f453, 0x00305c30, 0x0491805a,\n\t\t\t  0x02710056, 0x0010542d, 0x04718059 },\n\t},\n\t{ 0x6000, {\n\t\t\t  0x01c0bc40, 0x01c0bc40, 0x04c13052,\n\t\t\t  0x01e0c841, 0x01a0b43d, 0x04c13851,\n\t\t\t  0x0210cc44, 0x0180a83c, 0x04a13453,\n\t\t\t  0x0230d845, 0x0160a03a, 0x04913c52,\n\t\t\t  0x0260e047, 0x01409838, 0x04714052,\n\t\t\t  0x0280ec49, 0x01208c37, 0x04514c50,\n\t\t\t  0x02b0f44b, 0x01008435, 0x04414c50,\n\t\t\t  0x02d1004c, 0x00e07c33, 0x0431544f },\n\t},\n\t{ 0x7000, {\n\t\t\t  0x0230c83e, 0x0230c83e, 0x04711c4c,\n\t\t\t  0x0250d03f, 0x0210c43c, 0x0471204b,\n\t\t\t  0x0270d840, 0x0200b83c, 0x0451244b,\n\t\t\t  0x0290dc42, 0x01e0b43a, 0x0441244c,\n\t\t\t  0x02b0e443, 0x01c0b038, 0x0441284b,\n\t\t\t  0x02d0ec44, 0x01b0a438, 0x0421304a,\n\t\t\t  0x02f0f445, 0x0190a036, 0x04213449,\n\t\t\t  0x0310f847, 0x01709c34, 0x04213848 },\n\t},\n\t{ 0x8000, {\n\t\t\t  0x0280d03d, 0x0280d03d, 0x04310c48,\n\t\t\t  0x02a0d43e, 0x0270c83c, 0x04311047,\n\t\t\t  0x02b0dc3e, 0x0250c83a, 0x04311447,\n\t\t\t  0x02d0e040, 0x0240c03a, 0x04211446,\n\t\t\t  0x02e0e840, 0x0220bc39, 0x04111847,\n\t\t\t  0x0300e842, 0x0210b438, 0x04012445,\n\t\t\t  0x0310f043, 0x0200b037, 0x04012045,\n\t\t\t  0x0330f444, 0x01e0ac36, 0x03f12445 },\n\t},\n\t{ 0xefff, {\n\t\t\t  0x0340dc3a, 0x0340dc3a, 0x03b0ec40,\n\t\t\t  0x0340e03a, 0x0330e039, 0x03c0f03e,\n\t\t\t  0x0350e03b, 0x0330dc39, 0x03c0ec3e,\n\t\t\t  0x0350e43a, 0x0320dc38, 0x03c0f43e,\n\t\t\t  0x0360e43b, 0x0320d839, 0x03b0f03e,\n\t\t\t  0x0360e83b, 0x0310d838, 0x03c0fc3b,\n\t\t\t  0x0370e83b, 0x0310d439, 0x03a0f83d,\n\t\t\t  0x0370e83c, 0x0300d438, 0x03b0fc3c },\n\t}\n};\n\nstatic void rvin_set_coeff(struct rvin_dev *vin, unsigned short xs)\n{\n\tint i;\n\tconst struct vin_coeff *p_prev_set = NULL;\n\tconst struct vin_coeff *p_set = NULL;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vin_coeff_set); i++) {\n\t\tp_prev_set = p_set;\n\t\tp_set = &vin_coeff_set[i];\n\n\t\tif (xs < p_set->xs_value)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (p_prev_set &&\n\t    xs - p_prev_set->xs_value < p_set->xs_value - xs)\n\t\tp_set = p_prev_set;\n\n\t \n\trvin_write(vin, p_set->coeff_set[0], VNC1A_REG);\n\trvin_write(vin, p_set->coeff_set[1], VNC1B_REG);\n\trvin_write(vin, p_set->coeff_set[2], VNC1C_REG);\n\n\trvin_write(vin, p_set->coeff_set[3], VNC2A_REG);\n\trvin_write(vin, p_set->coeff_set[4], VNC2B_REG);\n\trvin_write(vin, p_set->coeff_set[5], VNC2C_REG);\n\n\trvin_write(vin, p_set->coeff_set[6], VNC3A_REG);\n\trvin_write(vin, p_set->coeff_set[7], VNC3B_REG);\n\trvin_write(vin, p_set->coeff_set[8], VNC3C_REG);\n\n\trvin_write(vin, p_set->coeff_set[9], VNC4A_REG);\n\trvin_write(vin, p_set->coeff_set[10], VNC4B_REG);\n\trvin_write(vin, p_set->coeff_set[11], VNC4C_REG);\n\n\trvin_write(vin, p_set->coeff_set[12], VNC5A_REG);\n\trvin_write(vin, p_set->coeff_set[13], VNC5B_REG);\n\trvin_write(vin, p_set->coeff_set[14], VNC5C_REG);\n\n\trvin_write(vin, p_set->coeff_set[15], VNC6A_REG);\n\trvin_write(vin, p_set->coeff_set[16], VNC6B_REG);\n\trvin_write(vin, p_set->coeff_set[17], VNC6C_REG);\n\n\trvin_write(vin, p_set->coeff_set[18], VNC7A_REG);\n\trvin_write(vin, p_set->coeff_set[19], VNC7B_REG);\n\trvin_write(vin, p_set->coeff_set[20], VNC7C_REG);\n\n\trvin_write(vin, p_set->coeff_set[21], VNC8A_REG);\n\trvin_write(vin, p_set->coeff_set[22], VNC8B_REG);\n\trvin_write(vin, p_set->coeff_set[23], VNC8C_REG);\n}\n\nvoid rvin_scaler_gen2(struct rvin_dev *vin)\n{\n\tunsigned int crop_height;\n\tu32 xs, ys;\n\n\t \n\tcrop_height = vin->crop.height;\n\tif (V4L2_FIELD_HAS_BOTH(vin->format.field))\n\t\tcrop_height *= 2;\n\n\tys = 0;\n\tif (crop_height != vin->compose.height)\n\t\tys = (4096 * crop_height) / vin->compose.height;\n\trvin_write(vin, ys, VNYS_REG);\n\n\txs = 0;\n\tif (vin->crop.width != vin->compose.width)\n\t\txs = (4096 * vin->crop.width) / vin->compose.width;\n\n\t \n\tif (xs > 0 && xs < 2048)\n\t\txs = 2048;\n\n\trvin_write(vin, xs, VNXS_REG);\n\n\t \n\tif (xs < 4096)\n\t\txs *= 2;\n\n\trvin_set_coeff(vin, xs);\n\n\t \n\trvin_write(vin, 0, VNSPPOC_REG);\n\trvin_write(vin, 0, VNSLPOC_REG);\n\trvin_write(vin, vin->format.width - 1, VNEPPOC_REG);\n\n\tif (V4L2_FIELD_HAS_BOTH(vin->format.field))\n\t\trvin_write(vin, vin->format.height / 2 - 1, VNELPOC_REG);\n\telse\n\t\trvin_write(vin, vin->format.height - 1, VNELPOC_REG);\n\n\tvin_dbg(vin,\n\t\t\"Pre-Clip: %ux%u@%u:%u YS: %d XS: %d Post-Clip: %ux%u@%u:%u\\n\",\n\t\tvin->crop.width, vin->crop.height, vin->crop.left,\n\t\tvin->crop.top, ys, xs, vin->format.width, vin->format.height,\n\t\t0, 0);\n}\n\nstatic unsigned int rvin_uds_scale_ratio(unsigned int in, unsigned int out)\n{\n\tunsigned int ratio;\n\n\tratio = in * 4096 / out;\n\treturn ratio >= 0x10000 ? 0xffff : ratio;\n}\n\nstatic unsigned int rvin_uds_filter_width(unsigned int ratio)\n{\n\tif (ratio >= 0x1000)\n\t\treturn 64 * (ratio & 0xf000) / ratio;\n\n\treturn 64;\n}\n\nvoid rvin_scaler_gen3(struct rvin_dev *vin)\n{\n\tunsigned int ratio_h, ratio_v;\n\tunsigned int bwidth_h, bwidth_v;\n\tu32 vnmc, clip_size;\n\n\tvnmc = rvin_read(vin, VNMC_REG);\n\n\t \n\tif (!rvin_scaler_needed(vin)) {\n\t\trvin_write(vin, vnmc & ~VNMC_SCLE, VNMC_REG);\n\t\treturn;\n\t}\n\n\tratio_h = rvin_uds_scale_ratio(vin->crop.width, vin->compose.width);\n\tbwidth_h = rvin_uds_filter_width(ratio_h);\n\n\tratio_v = rvin_uds_scale_ratio(vin->crop.height, vin->compose.height);\n\tbwidth_v = rvin_uds_filter_width(ratio_v);\n\n\tclip_size = vin->compose.width << 16;\n\n\tswitch (vin->format.field) {\n\tcase V4L2_FIELD_INTERLACED_TB:\n\tcase V4L2_FIELD_INTERLACED_BT:\n\tcase V4L2_FIELD_INTERLACED:\n\tcase V4L2_FIELD_SEQ_TB:\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tclip_size |= vin->compose.height / 2;\n\t\tbreak;\n\tdefault:\n\t\tclip_size |= vin->compose.height;\n\t\tbreak;\n\t}\n\n\trvin_write(vin, vnmc | VNMC_SCLE, VNMC_REG);\n\trvin_write(vin, VNUDS_CTRL_AMD, VNUDS_CTRL_REG);\n\trvin_write(vin, (ratio_h << 16) | ratio_v, VNUDS_SCALE_REG);\n\trvin_write(vin, (bwidth_h << 16) | bwidth_v, VNUDS_PASS_BWIDTH_REG);\n\trvin_write(vin, clip_size, VNUDS_CLIP_SIZE_REG);\n\n\tvin_dbg(vin, \"Pre-Clip: %ux%u@%u:%u Post-Clip: %ux%u@%u:%u\\n\",\n\t\tvin->crop.width, vin->crop.height, vin->crop.left,\n\t\tvin->crop.top, vin->compose.width, vin->compose.height,\n\t\tvin->compose.left, vin->compose.top);\n}\n\nvoid rvin_crop_scale_comp(struct rvin_dev *vin)\n{\n\tconst struct rvin_video_format *fmt;\n\tu32 stride;\n\n\t \n\trvin_write(vin, vin->crop.left, VNSPPRC_REG);\n\trvin_write(vin, vin->crop.left + vin->crop.width - 1, VNEPPRC_REG);\n\trvin_write(vin, vin->crop.top, VNSLPRC_REG);\n\trvin_write(vin, vin->crop.top + vin->crop.height - 1, VNELPRC_REG);\n\n\tif (vin->scaler)\n\t\tvin->scaler(vin);\n\n\tfmt = rvin_format_from_pixel(vin, vin->format.pixelformat);\n\tstride = vin->format.bytesperline / fmt->bpp;\n\n\t \n\tswitch (vin->format.pixelformat) {\n\tcase V4L2_PIX_FMT_SBGGR8:\n\tcase V4L2_PIX_FMT_SGBRG8:\n\tcase V4L2_PIX_FMT_SGRBG8:\n\tcase V4L2_PIX_FMT_SRGGB8:\n\tcase V4L2_PIX_FMT_GREY:\n\t\tstride /= 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trvin_write(vin, stride, VNIS_REG);\n}\n\n \n\nstatic int rvin_setup(struct rvin_dev *vin)\n{\n\tu32 vnmc, dmr, dmr2, interrupts;\n\tbool progressive = false, output_is_yuv = false, input_is_yuv = false;\n\n\tswitch (vin->format.field) {\n\tcase V4L2_FIELD_TOP:\n\t\tvnmc = VNMC_IM_ODD;\n\t\tbreak;\n\tcase V4L2_FIELD_BOTTOM:\n\t\tvnmc = VNMC_IM_EVEN;\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED:\n\t\t \n\t\tvnmc = VNMC_IM_FULL;\n\t\t \n\t\tif (!vin->info->use_mc && vin->std & V4L2_STD_525_60)\n\t\t\tvnmc = VNMC_IM_FULL | VNMC_FOC;\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED_TB:\n\t\tvnmc = VNMC_IM_FULL;\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED_BT:\n\t\tvnmc = VNMC_IM_FULL | VNMC_FOC;\n\t\tbreak;\n\tcase V4L2_FIELD_SEQ_TB:\n\tcase V4L2_FIELD_SEQ_BT:\n\tcase V4L2_FIELD_NONE:\n\tcase V4L2_FIELD_ALTERNATE:\n\t\tvnmc = VNMC_IM_ODD_EVEN;\n\t\tprogressive = true;\n\t\tbreak;\n\tdefault:\n\t\tvnmc = VNMC_IM_ODD;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (vin->mbus_code) {\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\t\t \n\t\tvnmc |= VNMC_INF_YUV16;\n\t\tinput_is_yuv = true;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tvnmc |= VNMC_INF_YUV16 | VNMC_YCAL;\n\t\tinput_is_yuv = true;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\t \n\t\tif (!vin->is_csi &&\n\t\t    vin->parallel.mbus_type == V4L2_MBUS_BT656)\n\t\t\tvnmc |= VNMC_INF_YUV8_BT656;\n\t\telse\n\t\t\tvnmc |= VNMC_INF_YUV8_BT601;\n\n\t\tinput_is_yuv = true;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\tvnmc |= VNMC_INF_RGB888;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY10_2X10:\n\t\t \n\t\tif (!vin->is_csi &&\n\t\t    vin->parallel.mbus_type == V4L2_MBUS_BT656)\n\t\t\tvnmc |= VNMC_INF_YUV10_BT656;\n\t\telse\n\t\t\tvnmc |= VNMC_INF_YUV10_BT601;\n\n\t\tinput_is_yuv = true;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\tcase MEDIA_BUS_FMT_Y8_1X8:\n\t\tvnmc |= VNMC_INF_RAW8;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (vin->info->model == RCAR_GEN3) {\n\t\tswitch (vnmc & VNMC_INF_MASK) {\n\t\tcase VNMC_INF_YUV8_BT656:\n\t\tcase VNMC_INF_YUV10_BT656:\n\t\tcase VNMC_INF_YUV16:\n\t\tcase VNMC_INF_RGB666:\n\t\t\tif (vin->is_csi) {\n\t\t\t\tvin_err(vin, \"Invalid setting in MIPI CSI2\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VNMC_INF_RAW8:\n\t\t\tif (!vin->is_csi) {\n\t\t\t\tvin_err(vin, \"Invalid setting in Digital Pins\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (vin->info->model == RCAR_GEN3)\n\t\tdmr2 = VNDMR2_FTEV;\n\telse\n\t\tdmr2 = VNDMR2_FTEV | VNDMR2_VLV(1);\n\n\tif (!vin->is_csi) {\n\t\t \n\t\tif (!(vin->parallel.bus.flags & V4L2_MBUS_HSYNC_ACTIVE_LOW))\n\t\t\tdmr2 |= VNDMR2_HPS;\n\n\t\t \n\t\tif (!(vin->parallel.bus.flags & V4L2_MBUS_VSYNC_ACTIVE_LOW))\n\t\t\tdmr2 |= VNDMR2_VPS;\n\n\t\t \n\t\tif (vin->parallel.bus.flags & V4L2_MBUS_DATA_ENABLE_LOW)\n\t\t\tdmr2 |= VNDMR2_CES;\n\n\t\tswitch (vin->mbus_code) {\n\t\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\t\tif (vin->parallel.bus.bus_width == 8 &&\n\t\t\t    vin->parallel.bus.data_shift == 8)\n\t\t\t\tdmr2 |= VNDMR2_YDS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tswitch (vin->format.pixelformat) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV16:\n\t\trvin_write(vin,\n\t\t\t   ALIGN(vin->format.bytesperline * vin->format.height,\n\t\t\t\t 0x80), VNUVAOF_REG);\n\t\tdmr = vin->format.pixelformat == V4L2_PIX_FMT_NV12 ?\n\t\t\tVNDMR_DTMD_YCSEP_420 : VNDMR_DTMD_YCSEP;\n\t\toutput_is_yuv = true;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\t\tdmr = VNDMR_BPSM;\n\t\toutput_is_yuv = true;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_UYVY:\n\t\tdmr = 0;\n\t\toutput_is_yuv = true;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_XRGB555:\n\t\tdmr = VNDMR_DTMD_ARGB;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565:\n\t\tdmr = 0;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_XBGR32:\n\t\t \n\t\tdmr = VNDMR_EXRGB;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_ARGB555:\n\t\tdmr = (vin->alpha ? VNDMR_ABIT : 0) | VNDMR_DTMD_ARGB;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_ABGR32:\n\t\tdmr = VNDMR_A8BIT(vin->alpha) | VNDMR_EXRGB | VNDMR_DTMD_ARGB;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SBGGR8:\n\tcase V4L2_PIX_FMT_SGBRG8:\n\tcase V4L2_PIX_FMT_SGRBG8:\n\tcase V4L2_PIX_FMT_SRGGB8:\n\t\tdmr = 0;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_GREY:\n\t\tif (input_is_yuv) {\n\t\t\tdmr = VNDMR_DTMD_YCSEP | VNDMR_YMODE_Y8;\n\t\t\toutput_is_yuv = true;\n\t\t} else {\n\t\t\tdmr = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tvin_err(vin, \"Invalid pixelformat (0x%x)\\n\",\n\t\t\tvin->format.pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvnmc |= VNMC_VUP;\n\n\tif (!vin->info->use_isp) {\n\t\t \n\t\tif (input_is_yuv == output_is_yuv)\n\t\t\tvnmc |= VNMC_BPS;\n\n\t\tif (vin->info->model == RCAR_GEN3) {\n\t\t\t \n\t\t\tif (vin->is_csi)\n\t\t\t\tvnmc &= ~VNMC_DPINE;\n\t\t\telse\n\t\t\t\tvnmc |= VNMC_DPINE;\n\t\t}\n\t}\n\n\t \n\tinterrupts = progressive ? VNIE_FIE : VNIE_EFE;\n\n\t \n\trvin_write(vin, interrupts, VNINTS_REG);\n\t \n\trvin_write(vin, interrupts, VNIE_REG);\n\t \n\trvin_write(vin, dmr, VNDMR_REG);\n\trvin_write(vin, dmr2, VNDMR2_REG);\n\n\t \n\trvin_write(vin, vnmc | VNMC_ME, VNMC_REG);\n\n\treturn 0;\n}\n\nstatic void rvin_disable_interrupts(struct rvin_dev *vin)\n{\n\trvin_write(vin, 0, VNIE_REG);\n}\n\nstatic u32 rvin_get_interrupt_status(struct rvin_dev *vin)\n{\n\treturn rvin_read(vin, VNINTS_REG);\n}\n\nstatic void rvin_ack_interrupt(struct rvin_dev *vin)\n{\n\trvin_write(vin, rvin_read(vin, VNINTS_REG), VNINTS_REG);\n}\n\nstatic bool rvin_capture_active(struct rvin_dev *vin)\n{\n\treturn rvin_read(vin, VNMS_REG) & VNMS_CA;\n}\n\nstatic enum v4l2_field rvin_get_active_field(struct rvin_dev *vin, u32 vnms)\n{\n\tif (vin->format.field == V4L2_FIELD_ALTERNATE) {\n\t\t \n\t\tif (vnms & VNMS_FS)\n\t\t\treturn V4L2_FIELD_BOTTOM;\n\t\treturn V4L2_FIELD_TOP;\n\t}\n\n\treturn vin->format.field;\n}\n\nstatic void rvin_set_slot_addr(struct rvin_dev *vin, int slot, dma_addr_t addr)\n{\n\tconst struct rvin_video_format *fmt;\n\tint offsetx, offsety;\n\tdma_addr_t offset;\n\n\tfmt = rvin_format_from_pixel(vin, vin->format.pixelformat);\n\n\t \n\toffsetx = vin->compose.left * fmt->bpp;\n\toffsety = vin->compose.top * vin->format.bytesperline;\n\toffset = addr + offsetx + offsety;\n\n\t \n\tif (WARN_ON((offsetx | offsety | offset) & HW_BUFFER_MASK))\n\t\treturn;\n\n\trvin_write(vin, offset, VNMB_REG(slot));\n}\n\n \nstatic void rvin_fill_hw_slot(struct rvin_dev *vin, int slot)\n{\n\tstruct rvin_buffer *buf;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tdma_addr_t phys_addr;\n\tint prev;\n\n\t \n\tif (WARN_ON(vin->buf_hw[slot].buffer))\n\t\treturn;\n\n\tprev = (slot == 0 ? HW_BUFFER_NUM : slot) - 1;\n\n\tif (vin->buf_hw[prev].type == HALF_TOP) {\n\t\tvbuf = vin->buf_hw[prev].buffer;\n\t\tvin->buf_hw[slot].buffer = vbuf;\n\t\tvin->buf_hw[slot].type = HALF_BOTTOM;\n\t\tswitch (vin->format.pixelformat) {\n\t\tcase V4L2_PIX_FMT_NV12:\n\t\tcase V4L2_PIX_FMT_NV16:\n\t\t\tphys_addr = vin->buf_hw[prev].phys +\n\t\t\t\tvin->format.sizeimage / 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphys_addr = vin->buf_hw[prev].phys +\n\t\t\t\tvin->format.sizeimage / 2;\n\t\t\tbreak;\n\t\t}\n\t} else if ((vin->state != STOPPED && vin->state != RUNNING) ||\n\t\t   list_empty(&vin->buf_list)) {\n\t\tvin->buf_hw[slot].buffer = NULL;\n\t\tvin->buf_hw[slot].type = FULL;\n\t\tphys_addr = vin->scratch_phys;\n\t} else {\n\t\t \n\t\tbuf = list_entry(vin->buf_list.next, struct rvin_buffer, list);\n\t\tvbuf = &buf->vb;\n\t\tlist_del_init(to_buf_list(vbuf));\n\t\tvin->buf_hw[slot].buffer = vbuf;\n\n\t\tvin->buf_hw[slot].type =\n\t\t\tV4L2_FIELD_IS_SEQUENTIAL(vin->format.field) ?\n\t\t\tHALF_TOP : FULL;\n\n\t\t \n\t\tphys_addr = vb2_dma_contig_plane_dma_addr(&vbuf->vb2_buf, 0);\n\t}\n\n\tvin_dbg(vin, \"Filling HW slot: %d type: %d buffer: %p\\n\",\n\t\tslot, vin->buf_hw[slot].type, vin->buf_hw[slot].buffer);\n\n\tvin->buf_hw[slot].phys = phys_addr;\n\trvin_set_slot_addr(vin, slot, phys_addr);\n}\n\nstatic int rvin_capture_start(struct rvin_dev *vin)\n{\n\tint slot, ret;\n\n\tfor (slot = 0; slot < HW_BUFFER_NUM; slot++) {\n\t\tvin->buf_hw[slot].buffer = NULL;\n\t\tvin->buf_hw[slot].type = FULL;\n\t}\n\n\tfor (slot = 0; slot < HW_BUFFER_NUM; slot++)\n\t\trvin_fill_hw_slot(vin, slot);\n\n\tret = rvin_setup(vin);\n\tif (ret)\n\t\treturn ret;\n\n\trvin_crop_scale_comp(vin);\n\n\tvin_dbg(vin, \"Starting to capture\\n\");\n\n\t \n\trvin_write(vin, VNFC_C_FRAME, VNFC_REG);\n\n\tvin->state = STARTING;\n\n\treturn 0;\n}\n\nstatic void rvin_capture_stop(struct rvin_dev *vin)\n{\n\t \n\trvin_write(vin, 0, VNFC_REG);\n\n\t \n\trvin_write(vin, rvin_read(vin, VNMC_REG) & ~VNMC_ME, VNMC_REG);\n}\n\n \n\n#define RVIN_TIMEOUT_MS 100\n#define RVIN_RETRIES 10\n\nstatic irqreturn_t rvin_irq(int irq, void *data)\n{\n\tstruct rvin_dev *vin = data;\n\tu32 int_status, vnms;\n\tint slot;\n\tunsigned int handled = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vin->qlock, flags);\n\n\tint_status = rvin_get_interrupt_status(vin);\n\tif (!int_status)\n\t\tgoto done;\n\n\trvin_ack_interrupt(vin);\n\thandled = 1;\n\n\t \n\tif (!(int_status & VNINTS_FIS))\n\t\tgoto done;\n\n\t \n\tif (vin->state == STOPPED) {\n\t\tvin_dbg(vin, \"IRQ while state stopped\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tvnms = rvin_read(vin, VNMS_REG);\n\tslot = (vnms & VNMS_FBS_MASK) >> VNMS_FBS_SHIFT;\n\n\t \n\tif (vin->state == STARTING) {\n\t\tif (slot != 0) {\n\t\t\tvin_dbg(vin, \"Starting sync slot: %d\\n\", slot);\n\t\t\tgoto done;\n\t\t}\n\n\t\tvin_dbg(vin, \"Capture start synced!\\n\");\n\t\tvin->state = RUNNING;\n\t}\n\n\t \n\tif (vin->buf_hw[slot].buffer) {\n\t\t \n\t\tif (vin->buf_hw[slot].type == HALF_TOP) {\n\t\t\tvin->buf_hw[slot].buffer = NULL;\n\t\t\trvin_fill_hw_slot(vin, slot);\n\t\t\tgoto done;\n\t\t}\n\n\t\tvin->buf_hw[slot].buffer->field =\n\t\t\trvin_get_active_field(vin, vnms);\n\t\tvin->buf_hw[slot].buffer->sequence = vin->sequence;\n\t\tvin->buf_hw[slot].buffer->vb2_buf.timestamp = ktime_get_ns();\n\t\tvb2_buffer_done(&vin->buf_hw[slot].buffer->vb2_buf,\n\t\t\t\tVB2_BUF_STATE_DONE);\n\t\tvin->buf_hw[slot].buffer = NULL;\n\t} else {\n\t\t \n\t\tvin_dbg(vin, \"Dropping frame %u\\n\", vin->sequence);\n\t}\n\n\tvin->sequence++;\n\n\t \n\trvin_fill_hw_slot(vin, slot);\ndone:\n\tspin_unlock_irqrestore(&vin->qlock, flags);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void return_unused_buffers(struct rvin_dev *vin,\n\t\t\t\t  enum vb2_buffer_state state)\n{\n\tstruct rvin_buffer *buf, *node;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vin->qlock, flags);\n\n\tlist_for_each_entry_safe(buf, node, &vin->buf_list, list) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t\tlist_del(&buf->list);\n\t}\n\n\tspin_unlock_irqrestore(&vin->qlock, flags);\n}\n\nstatic int rvin_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\n\t\t\t    unsigned int *nplanes, unsigned int sizes[],\n\t\t\t    struct device *alloc_devs[])\n\n{\n\tstruct rvin_dev *vin = vb2_get_drv_priv(vq);\n\n\t \n\tif (*nplanes)\n\t\treturn sizes[0] < vin->format.sizeimage ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = vin->format.sizeimage;\n\n\treturn 0;\n};\n\nstatic int rvin_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct rvin_dev *vin = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long size = vin->format.sizeimage;\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tvin_err(vin, \"buffer too small (%lu < %lu)\\n\",\n\t\t\tvb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, size);\n\n\treturn 0;\n}\n\nstatic void rvin_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct rvin_dev *vin = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vin->qlock, flags);\n\n\tlist_add_tail(to_buf_list(vbuf), &vin->buf_list);\n\n\tspin_unlock_irqrestore(&vin->qlock, flags);\n}\n\nstatic int rvin_mc_validate_format(struct rvin_dev *vin, struct v4l2_subdev *sd,\n\t\t\t\t   struct media_pad *pad)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\tfmt.pad = pad->index;\n\tif (v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt))\n\t\treturn -EPIPE;\n\n\tswitch (fmt.format.code) {\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\tcase MEDIA_BUS_FMT_UYVY10_2X10:\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\tif (vin->format.pixelformat != V4L2_PIX_FMT_SBGGR8)\n\t\t\treturn -EPIPE;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\t\tif (vin->format.pixelformat != V4L2_PIX_FMT_SGBRG8)\n\t\t\treturn -EPIPE;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\t\tif (vin->format.pixelformat != V4L2_PIX_FMT_SGRBG8)\n\t\t\treturn -EPIPE;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\t\tif (vin->format.pixelformat != V4L2_PIX_FMT_SRGGB8)\n\t\t\treturn -EPIPE;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_Y8_1X8:\n\t\tif (vin->format.pixelformat != V4L2_PIX_FMT_GREY)\n\t\t\treturn -EPIPE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EPIPE;\n\t}\n\tvin->mbus_code = fmt.format.code;\n\n\tswitch (fmt.format.field) {\n\tcase V4L2_FIELD_TOP:\n\tcase V4L2_FIELD_BOTTOM:\n\tcase V4L2_FIELD_NONE:\n\tcase V4L2_FIELD_INTERLACED_TB:\n\tcase V4L2_FIELD_INTERLACED_BT:\n\tcase V4L2_FIELD_INTERLACED:\n\tcase V4L2_FIELD_SEQ_TB:\n\tcase V4L2_FIELD_SEQ_BT:\n\t\t \n\t\tbreak;\n\tcase V4L2_FIELD_ALTERNATE:\n\t\tswitch (vin->format.field) {\n\t\tcase V4L2_FIELD_TOP:\n\t\tcase V4L2_FIELD_BOTTOM:\n\t\tcase V4L2_FIELD_NONE:\n\t\tcase V4L2_FIELD_ALTERNATE:\n\t\t\tbreak;\n\t\tcase V4L2_FIELD_INTERLACED_TB:\n\t\tcase V4L2_FIELD_INTERLACED_BT:\n\t\tcase V4L2_FIELD_INTERLACED:\n\t\tcase V4L2_FIELD_SEQ_TB:\n\t\tcase V4L2_FIELD_SEQ_BT:\n\t\t\t \n\t\t\tfmt.format.height *= 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EPIPE;\n\t}\n\n\tif (rvin_scaler_needed(vin)) {\n\t\t \n\t\tif (vin->info->model == RCAR_GEN3 &&\n\t\t    vin->format.pixelformat == V4L2_PIX_FMT_NV12)\n\t\t\treturn -EPIPE;\n\n\t\tif (!vin->scaler)\n\t\t\treturn -EPIPE;\n\t} else {\n\t\tif (vin->format.pixelformat == V4L2_PIX_FMT_NV12) {\n\t\t\tif (ALIGN(fmt.format.width, 32) != vin->format.width ||\n\t\t\t    ALIGN(fmt.format.height, 32) != vin->format.height)\n\t\t\t\treturn -EPIPE;\n\t\t} else {\n\t\t\tif (fmt.format.width != vin->format.width ||\n\t\t\t    fmt.format.height != vin->format.height)\n\t\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\n\tif (fmt.format.code != vin->mbus_code)\n\t\treturn -EPIPE;\n\n\treturn 0;\n}\n\nstatic int rvin_set_stream(struct rvin_dev *vin, int on)\n{\n\tstruct v4l2_subdev *sd;\n\tstruct media_pad *pad;\n\tint ret;\n\n\t \n\tif (!vin->info->use_mc) {\n\t\tret = v4l2_subdev_call(vin->parallel.subdev, video, s_stream,\n\t\t\t\t       on);\n\n\t\treturn ret == -ENOIOCTLCMD ? 0 : ret;\n\t}\n\n\tpad = media_pad_remote_pad_first(&vin->pad);\n\tif (!pad)\n\t\treturn -EPIPE;\n\n\tsd = media_entity_to_v4l2_subdev(pad->entity);\n\n\tif (!on) {\n\t\tvideo_device_pipeline_stop(&vin->vdev);\n\t\treturn v4l2_subdev_call(sd, video, s_stream, 0);\n\t}\n\n\tret = rvin_mc_validate_format(vin, sd, pad);\n\tif (ret)\n\t\treturn ret;\n\n\tret = video_device_pipeline_alloc_start(&vin->vdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_subdev_call(sd, video, s_stream, 1);\n\tif (ret == -ENOIOCTLCMD)\n\t\tret = 0;\n\tif (ret)\n\t\tvideo_device_pipeline_stop(&vin->vdev);\n\n\treturn ret;\n}\n\nint rvin_start_streaming(struct rvin_dev *vin)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tret = rvin_set_stream(vin, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&vin->qlock, flags);\n\n\tvin->sequence = 0;\n\n\tret = rvin_capture_start(vin);\n\tif (ret)\n\t\trvin_set_stream(vin, 0);\n\n\tspin_unlock_irqrestore(&vin->qlock, flags);\n\n\treturn ret;\n}\n\nstatic int rvin_start_streaming_vq(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct rvin_dev *vin = vb2_get_drv_priv(vq);\n\tint ret = -ENOMEM;\n\n\t \n\tvin->scratch = dma_alloc_coherent(vin->dev, vin->format.sizeimage,\n\t\t\t\t\t  &vin->scratch_phys, GFP_KERNEL);\n\tif (!vin->scratch)\n\t\tgoto err_scratch;\n\n\tret = rvin_start_streaming(vin);\n\tif (ret)\n\t\tgoto err_start;\n\n\treturn 0;\nerr_start:\n\tdma_free_coherent(vin->dev, vin->format.sizeimage, vin->scratch,\n\t\t\t  vin->scratch_phys);\nerr_scratch:\n\treturn_unused_buffers(vin, VB2_BUF_STATE_QUEUED);\n\n\treturn ret;\n}\n\nvoid rvin_stop_streaming(struct rvin_dev *vin)\n{\n\tunsigned int i, retries;\n\tunsigned long flags;\n\tbool buffersFreed;\n\n\tspin_lock_irqsave(&vin->qlock, flags);\n\n\tif (vin->state == STOPPED) {\n\t\tspin_unlock_irqrestore(&vin->qlock, flags);\n\t\treturn;\n\t}\n\n\tvin->state = STOPPING;\n\n\t \n\tretries = 0;\n\twhile (retries++ < RVIN_RETRIES) {\n\t\tbuffersFreed = true;\n\t\tfor (i = 0; i < HW_BUFFER_NUM; i++)\n\t\t\tif (vin->buf_hw[i].buffer)\n\t\t\t\tbuffersFreed = false;\n\n\t\tif (buffersFreed)\n\t\t\tbreak;\n\n\t\tspin_unlock_irqrestore(&vin->qlock, flags);\n\t\tmsleep(RVIN_TIMEOUT_MS);\n\t\tspin_lock_irqsave(&vin->qlock, flags);\n\t}\n\n\t \n\tretries = 0;\n\twhile (retries++ < RVIN_RETRIES) {\n\n\t\trvin_capture_stop(vin);\n\n\t\t \n\t\tif (!rvin_capture_active(vin)) {\n\t\t\tvin->state = STOPPED;\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&vin->qlock, flags);\n\t\tmsleep(RVIN_TIMEOUT_MS);\n\t\tspin_lock_irqsave(&vin->qlock, flags);\n\t}\n\n\tif (!buffersFreed || vin->state != STOPPED) {\n\t\t \n\t\tvin_err(vin, \"Failed stop HW, something is seriously broken\\n\");\n\t\tvin->state = STOPPED;\n\t}\n\n\tspin_unlock_irqrestore(&vin->qlock, flags);\n\n\t \n\tif (!buffersFreed) {\n\t\treturn_unused_buffers(vin, VB2_BUF_STATE_ERROR);\n\t\tfor (i = 0; i < HW_BUFFER_NUM; i++) {\n\t\t\tif (vin->buf_hw[i].buffer)\n\t\t\t\tvb2_buffer_done(&vin->buf_hw[i].buffer->vb2_buf,\n\t\t\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\t}\n\t}\n\n\trvin_set_stream(vin, 0);\n\n\t \n\trvin_disable_interrupts(vin);\n}\n\nstatic void rvin_stop_streaming_vq(struct vb2_queue *vq)\n{\n\tstruct rvin_dev *vin = vb2_get_drv_priv(vq);\n\n\trvin_stop_streaming(vin);\n\n\t \n\tdma_free_coherent(vin->dev, vin->format.sizeimage, vin->scratch,\n\t\t\t  vin->scratch_phys);\n\n\treturn_unused_buffers(vin, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct vb2_ops rvin_qops = {\n\t.queue_setup\t\t= rvin_queue_setup,\n\t.buf_prepare\t\t= rvin_buffer_prepare,\n\t.buf_queue\t\t= rvin_buffer_queue,\n\t.start_streaming\t= rvin_start_streaming_vq,\n\t.stop_streaming\t\t= rvin_stop_streaming_vq,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nvoid rvin_dma_unregister(struct rvin_dev *vin)\n{\n\tmutex_destroy(&vin->lock);\n\n\tv4l2_device_unregister(&vin->v4l2_dev);\n}\n\nint rvin_dma_register(struct rvin_dev *vin, int irq)\n{\n\tstruct vb2_queue *q = &vin->queue;\n\tint i, ret;\n\n\t \n\tret = v4l2_device_register(vin->dev, &vin->v4l2_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&vin->lock);\n\tINIT_LIST_HEAD(&vin->buf_list);\n\n\tspin_lock_init(&vin->qlock);\n\n\tvin->state = STOPPED;\n\n\tfor (i = 0; i < HW_BUFFER_NUM; i++)\n\t\tvin->buf_hw[i].buffer = NULL;\n\n\t \n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;\n\tq->lock = &vin->lock;\n\tq->drv_priv = vin;\n\tq->buf_struct_size = sizeof(struct rvin_buffer);\n\tq->ops = &rvin_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = 4;\n\tq->dev = vin->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret < 0) {\n\t\tvin_err(vin, \"failed to initialize VB2 queue\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tret = devm_request_irq(vin->dev, irq, rvin_irq, IRQF_SHARED,\n\t\t\t       KBUILD_MODNAME, vin);\n\tif (ret) {\n\t\tvin_err(vin, \"failed to request irq\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\trvin_dma_unregister(vin);\n\n\treturn ret;\n}\n\n \n\n \nint rvin_set_channel_routing(struct rvin_dev *vin, u8 chsel)\n{\n\tconst struct rvin_group_route *route;\n\tu32 ifmd = 0;\n\tu32 vnmc;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(vin->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tvnmc = rvin_read(vin, VNMC_REG);\n\trvin_write(vin, vnmc & ~VNMC_VUP, VNMC_REG);\n\n\t \n\tfor (route = vin->info->routes; route->chsel; route++) {\n\t\tif (route->csi == RVIN_CSI20 || route->csi == RVIN_CSI21)\n\t\t\tifmd |= VNCSI_IFMD_DES1;\n\t\telse\n\t\t\tifmd |= VNCSI_IFMD_DES0;\n\n\t\tif (ifmd == (VNCSI_IFMD_DES0 | VNCSI_IFMD_DES1))\n\t\t\tbreak;\n\t}\n\n\tif (ifmd) {\n\t\tifmd |= VNCSI_IFMD_CSI_CHSEL(chsel);\n\t\trvin_write(vin, ifmd, VNCSI_IFMD_REG);\n\t}\n\n\tvin_dbg(vin, \"Set IFMD 0x%x\\n\", ifmd);\n\n\tvin->chsel = chsel;\n\n\t \n\trvin_write(vin, vnmc, VNMC_REG);\n\n\tpm_runtime_put(vin->dev);\n\n\treturn 0;\n}\n\nvoid rvin_set_alpha(struct rvin_dev *vin, unsigned int alpha)\n{\n\tunsigned long flags;\n\tu32 dmr;\n\n\tspin_lock_irqsave(&vin->qlock, flags);\n\n\tvin->alpha = alpha;\n\n\tif (vin->state == STOPPED)\n\t\tgoto out;\n\n\tswitch (vin->format.pixelformat) {\n\tcase V4L2_PIX_FMT_ARGB555:\n\t\tdmr = rvin_read(vin, VNDMR_REG) & ~VNDMR_ABIT;\n\t\tif (vin->alpha)\n\t\t\tdmr |= VNDMR_ABIT;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_ABGR32:\n\t\tdmr = rvin_read(vin, VNDMR_REG) & ~VNDMR_A8BIT_MASK;\n\t\tdmr |= VNDMR_A8BIT(vin->alpha);\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\trvin_write(vin, dmr,  VNDMR_REG);\nout:\n\tspin_unlock_irqrestore(&vin->qlock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}