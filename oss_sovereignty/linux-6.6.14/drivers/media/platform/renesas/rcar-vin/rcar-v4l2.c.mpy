{
  "module_name": "rcar-v4l2.c",
  "hash_id": "5a14ac08e80d08cf3ef4228049aa9f1472bd947fe1b274e504cd60354d338db2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/rcar-vin/rcar-v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/pm_runtime.h>\n\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-rect.h>\n\n#include \"rcar-vin.h\"\n\n#define RVIN_DEFAULT_FORMAT\tV4L2_PIX_FMT_YUYV\n#define RVIN_DEFAULT_WIDTH\t800\n#define RVIN_DEFAULT_HEIGHT\t600\n#define RVIN_DEFAULT_FIELD\tV4L2_FIELD_NONE\n#define RVIN_DEFAULT_COLORSPACE\tV4L2_COLORSPACE_SRGB\n\n \n\nstatic const struct rvin_video_format rvin_formats[] = {\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_NV12,\n\t\t.bpp\t\t\t= 1,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_NV16,\n\t\t.bpp\t\t\t= 1,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.bpp\t\t\t= 2,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_UYVY,\n\t\t.bpp\t\t\t= 2,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.bpp\t\t\t= 2,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_XRGB555,\n\t\t.bpp\t\t\t= 2,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_XBGR32,\n\t\t.bpp\t\t\t= 4,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_ARGB555,\n\t\t.bpp\t\t\t= 2,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_ABGR32,\n\t\t.bpp\t\t\t= 4,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.bpp\t\t\t= 1,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SGBRG8,\n\t\t.bpp\t\t\t= 1,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.bpp\t\t\t= 1,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SRGGB8,\n\t\t.bpp\t\t\t= 1,\n\t},\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_GREY,\n\t\t.bpp\t\t\t= 1,\n\t},\n};\n\nconst struct rvin_video_format *rvin_format_from_pixel(struct rvin_dev *vin,\n\t\t\t\t\t\t       u32 pixelformat)\n{\n\tint i;\n\n\tswitch (pixelformat) {\n\tcase V4L2_PIX_FMT_XBGR32:\n\t\tif (vin->info->model == RCAR_M1)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12:\n\t\t \n\t\tif (!vin->info->nv12 || !(BIT(vin->id) & 0x3333))\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rvin_formats); i++)\n\t\tif (rvin_formats[i].fourcc == pixelformat)\n\t\t\treturn rvin_formats + i;\n\n\treturn NULL;\n}\n\nstatic u32 rvin_format_bytesperline(struct rvin_dev *vin,\n\t\t\t\t    struct v4l2_pix_format *pix)\n{\n\tconst struct rvin_video_format *fmt;\n\tu32 align;\n\n\tfmt = rvin_format_from_pixel(vin, pix->pixelformat);\n\n\tif (WARN_ON(!fmt))\n\t\treturn -EINVAL;\n\n\tswitch (pix->pixelformat) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV16:\n\t\talign = 0x20;\n\t\tbreak;\n\tdefault:\n\t\talign = 0x10;\n\t\tbreak;\n\t}\n\n\tif (V4L2_FIELD_IS_SEQUENTIAL(pix->field))\n\t\talign = 0x80;\n\n\treturn ALIGN(pix->width, align) * fmt->bpp;\n}\n\nstatic u32 rvin_format_sizeimage(struct v4l2_pix_format *pix)\n{\n\tswitch (pix->pixelformat) {\n\tcase V4L2_PIX_FMT_NV12:\n\t\treturn pix->bytesperline * pix->height * 3 / 2;\n\tcase V4L2_PIX_FMT_NV16:\n\t\treturn pix->bytesperline * pix->height * 2;\n\tdefault:\n\t\treturn pix->bytesperline * pix->height;\n\t}\n}\n\nstatic void rvin_format_align(struct rvin_dev *vin, struct v4l2_pix_format *pix)\n{\n\tu32 walign;\n\n\tif (!rvin_format_from_pixel(vin, pix->pixelformat))\n\t\tpix->pixelformat = RVIN_DEFAULT_FORMAT;\n\n\tswitch (pix->field) {\n\tcase V4L2_FIELD_TOP:\n\tcase V4L2_FIELD_BOTTOM:\n\tcase V4L2_FIELD_NONE:\n\tcase V4L2_FIELD_INTERLACED_TB:\n\tcase V4L2_FIELD_INTERLACED_BT:\n\tcase V4L2_FIELD_INTERLACED:\n\tcase V4L2_FIELD_ALTERNATE:\n\tcase V4L2_FIELD_SEQ_TB:\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tbreak;\n\tdefault:\n\t\tpix->field = RVIN_DEFAULT_FIELD;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (pix->pixelformat) {\n\t \n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV16:\n\t\twalign = 5;\n\t\tbreak;\n\t \n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_UYVY:\n\t\twalign = 1;\n\t\tbreak;\n\t \n\tdefault:\n\t\twalign = 0;\n\t\tbreak;\n\t}\n\n\t \n\tv4l_bound_align_image(&pix->width, 5, vin->info->max_width, walign,\n\t\t\t      &pix->height, 2, vin->info->max_height, 0, 0);\n\n\tpix->bytesperline = rvin_format_bytesperline(vin, pix);\n\tpix->sizeimage = rvin_format_sizeimage(pix);\n\n\tvin_dbg(vin, \"Format %ux%u bpl: %u size: %u\\n\",\n\t\tpix->width, pix->height, pix->bytesperline, pix->sizeimage);\n}\n\n \n\nstatic int rvin_reset_format(struct rvin_dev *vin)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.pad = vin->parallel.source_pad,\n\t};\n\tint ret;\n\n\tret = v4l2_subdev_call(vin_to_source(vin), pad, get_fmt, NULL, &fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tv4l2_fill_pix_format(&vin->format, &fmt.format);\n\n\tvin->crop.top = 0;\n\tvin->crop.left = 0;\n\tvin->crop.width = vin->format.width;\n\tvin->crop.height = vin->format.height;\n\n\t \n\tif (vin->format.field == V4L2_FIELD_ALTERNATE) {\n\t\tvin->format.field = V4L2_FIELD_INTERLACED;\n\t\tvin->format.height *= 2;\n\t}\n\n\trvin_format_align(vin, &vin->format);\n\n\tvin->compose.top = 0;\n\tvin->compose.left = 0;\n\tvin->compose.width = vin->format.width;\n\tvin->compose.height = vin->format.height;\n\n\treturn 0;\n}\n\nstatic int rvin_try_format(struct rvin_dev *vin, u32 which,\n\t\t\t   struct v4l2_pix_format *pix,\n\t\t\t   struct v4l2_rect *src_rect)\n{\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\tstruct v4l2_subdev_state *sd_state;\n\tstatic struct lock_class_key key;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = which,\n\t\t.pad = vin->parallel.source_pad,\n\t};\n\tenum v4l2_field field;\n\tu32 width, height;\n\tint ret;\n\n\t \n\tsd_state = __v4l2_subdev_state_alloc(sd, \"rvin:state->lock\", &key);\n\tif (IS_ERR(sd_state))\n\t\treturn PTR_ERR(sd_state);\n\n\tif (!rvin_format_from_pixel(vin, pix->pixelformat))\n\t\tpix->pixelformat = RVIN_DEFAULT_FORMAT;\n\n\tv4l2_fill_mbus_format(&format.format, pix, vin->mbus_code);\n\n\t \n\tfield = pix->field;\n\twidth = pix->width;\n\theight = pix->height;\n\n\tret = v4l2_subdev_call(sd, pad, set_fmt, sd_state, &format);\n\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\tgoto done;\n\tret = 0;\n\n\tv4l2_fill_pix_format(pix, &format.format);\n\n\tif (src_rect) {\n\t\tsrc_rect->top = 0;\n\t\tsrc_rect->left = 0;\n\t\tsrc_rect->width = pix->width;\n\t\tsrc_rect->height = pix->height;\n\t}\n\n\tif (field != V4L2_FIELD_ANY)\n\t\tpix->field = field;\n\n\tpix->width = width;\n\tpix->height = height;\n\n\trvin_format_align(vin, pix);\ndone:\n\t__v4l2_subdev_state_free(sd_state);\n\n\treturn ret;\n}\n\nstatic int rvin_querycap(struct file *file, void *priv,\n\t\t\t struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrscpy(cap->card, \"R_Car_VIN\", sizeof(cap->card));\n\treturn 0;\n}\n\nstatic int rvin_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\n\treturn rvin_try_format(vin, V4L2_SUBDEV_FORMAT_TRY, &f->fmt.pix, NULL);\n}\n\nstatic int rvin_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_rect fmt_rect, src_rect;\n\tint ret;\n\n\tif (vb2_is_busy(&vin->queue))\n\t\treturn -EBUSY;\n\n\tret = rvin_try_format(vin, V4L2_SUBDEV_FORMAT_ACTIVE, &f->fmt.pix,\n\t\t\t      &src_rect);\n\tif (ret)\n\t\treturn ret;\n\n\tvin->format = f->fmt.pix;\n\n\tfmt_rect.top = 0;\n\tfmt_rect.left = 0;\n\tfmt_rect.width = vin->format.width;\n\tfmt_rect.height = vin->format.height;\n\n\tv4l2_rect_map_inside(&vin->crop, &src_rect);\n\tv4l2_rect_map_inside(&vin->compose, &fmt_rect);\n\n\treturn 0;\n}\n\nstatic int rvin_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\n\tf->fmt.pix = vin->format;\n\n\treturn 0;\n}\n\nstatic int rvin_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_fmtdesc *f)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tunsigned int i;\n\tint matched;\n\n\t \n\tswitch (f->mbus_code) {\n\tcase 0:\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\tcase MEDIA_BUS_FMT_UYVY10_2X10:\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\tif (f->index)\n\t\t\treturn -EINVAL;\n\t\tf->pixelformat = V4L2_PIX_FMT_SBGGR8;\n\t\treturn 0;\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\t\tif (f->index)\n\t\t\treturn -EINVAL;\n\t\tf->pixelformat = V4L2_PIX_FMT_SGBRG8;\n\t\treturn 0;\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\t\tif (f->index)\n\t\t\treturn -EINVAL;\n\t\tf->pixelformat = V4L2_PIX_FMT_SGRBG8;\n\t\treturn 0;\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\t\tif (f->index)\n\t\t\treturn -EINVAL;\n\t\tf->pixelformat = V4L2_PIX_FMT_SRGGB8;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmatched = -1;\n\tfor (i = 0; i < ARRAY_SIZE(rvin_formats); i++) {\n\t\tif (rvin_format_from_pixel(vin, rvin_formats[i].fourcc))\n\t\t\tmatched++;\n\n\t\tif (matched == f->index) {\n\t\t\tf->pixelformat = rvin_formats[i].fourcc;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int rvin_remote_rectangle(struct rvin_dev *vin, struct v4l2_rect *rect)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev *sd;\n\tunsigned int index;\n\tint ret;\n\n\tif (vin->info->use_mc) {\n\t\tstruct media_pad *pad = media_pad_remote_pad_first(&vin->pad);\n\n\t\tif (!pad)\n\t\t\treturn -EINVAL;\n\n\t\tsd = media_entity_to_v4l2_subdev(pad->entity);\n\t\tindex = pad->index;\n\t} else {\n\t\tsd = vin_to_source(vin);\n\t\tindex = vin->parallel.source_pad;\n\t}\n\n\tfmt.pad = index;\n\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);\n\tif (ret)\n\t\treturn ret;\n\n\trect->left = rect->top = 0;\n\trect->width = fmt.format.width;\n\trect->height = fmt.format.height;\n\n\tif (fmt.format.field == V4L2_FIELD_ALTERNATE) {\n\t\tswitch (vin->format.field) {\n\t\tcase V4L2_FIELD_INTERLACED_TB:\n\t\tcase V4L2_FIELD_INTERLACED_BT:\n\t\tcase V4L2_FIELD_INTERLACED:\n\t\tcase V4L2_FIELD_SEQ_TB:\n\t\tcase V4L2_FIELD_SEQ_BT:\n\t\t\trect->height *= 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rvin_g_selection(struct file *file, void *fh,\n\t\t\t    struct v4l2_selection *s)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tint ret;\n\n\tif (!vin->scaler)\n\t\treturn -ENOIOCTLCMD;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tret = rvin_remote_rectangle(vin, &s->r);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\ts->r = vin->crop;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\ts->r.left = s->r.top = 0;\n\t\ts->r.width = vin->format.width;\n\t\ts->r.height = vin->format.height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\ts->r = vin->compose;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rvin_s_selection(struct file *file, void *fh,\n\t\t\t    struct v4l2_selection *s)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tconst struct rvin_video_format *fmt;\n\tstruct v4l2_rect r = s->r;\n\tstruct v4l2_rect max_rect;\n\tstruct v4l2_rect min_rect = {\n\t\t.width = 6,\n\t\t.height = 2,\n\t};\n\tint ret;\n\n\tif (!vin->scaler)\n\t\treturn -ENOIOCTLCMD;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tv4l2_rect_set_min_size(&r, &min_rect);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\t \n\t\tret = rvin_remote_rectangle(vin, &max_rect);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tv4l2_rect_map_inside(&r, &max_rect);\n\n\t\tv4l_bound_align_image(&r.width, 6, max_rect.width, 0,\n\t\t\t\t      &r.height, 2, max_rect.height, 0, 0);\n\n\t\tr.top  = clamp_t(s32, r.top, 0, max_rect.height - r.height);\n\t\tr.left = clamp_t(s32, r.left, 0, max_rect.width - r.width);\n\n\t\tvin->crop = s->r = r;\n\n\t\tvin_dbg(vin, \"Cropped %dx%d@%d:%d of %dx%d\\n\",\n\t\t\tr.width, r.height, r.left, r.top,\n\t\t\tmax_rect.width, max_rect.height);\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\t \n\t\tmax_rect.top = max_rect.left = 0;\n\t\tmax_rect.width = vin->format.width;\n\t\tmax_rect.height = vin->format.height;\n\t\tv4l2_rect_map_inside(&r, &max_rect);\n\n\t\t \n\t\twhile ((r.top * vin->format.bytesperline) & HW_BUFFER_MASK)\n\t\t\tr.top--;\n\n\t\tfmt = rvin_format_from_pixel(vin, vin->format.pixelformat);\n\t\twhile ((r.left * fmt->bpp) & HW_BUFFER_MASK)\n\t\t\tr.left--;\n\n\t\tvin->compose = s->r = r;\n\n\t\tvin_dbg(vin, \"Compose %dx%d@%d:%d in %dx%d\\n\",\n\t\t\tr.width, r.height, r.left, r.top,\n\t\t\tvin->format.width, vin->format.height);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trvin_crop_scale_comp(vin);\n\n\treturn 0;\n}\n\nstatic int rvin_g_parm(struct file *file, void *priv,\n\t\t       struct v4l2_streamparm *parm)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\n\treturn v4l2_g_parm_cap(&vin->vdev, sd, parm);\n}\n\nstatic int rvin_s_parm(struct file *file, void *priv,\n\t\t       struct v4l2_streamparm *parm)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\n\treturn v4l2_s_parm_cap(&vin->vdev, sd, parm);\n}\n\nstatic int rvin_g_pixelaspect(struct file *file, void *priv,\n\t\t\t      int type, struct v4l2_fract *f)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\treturn v4l2_subdev_call(sd, video, g_pixelaspect, f);\n}\n\nstatic int rvin_enum_input(struct file *file, void *priv,\n\t\t\t   struct v4l2_input *i)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\tint ret;\n\n\tif (i->index != 0)\n\t\treturn -EINVAL;\n\n\tret = v4l2_subdev_call(sd, video, g_input_status, &i->status);\n\tif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)\n\t\treturn ret;\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\n\tif (v4l2_subdev_has_op(sd, pad, dv_timings_cap)) {\n\t\ti->capabilities = V4L2_IN_CAP_DV_TIMINGS;\n\t\ti->std = 0;\n\t} else {\n\t\ti->capabilities = V4L2_IN_CAP_STD;\n\t\ti->std = vin->vdev.tvnorms;\n\t}\n\n\tstrscpy(i->name, \"Camera\", sizeof(i->name));\n\n\treturn 0;\n}\n\nstatic int rvin_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int rvin_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tif (i > 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int rvin_querystd(struct file *file, void *priv, v4l2_std_id *a)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\n\treturn v4l2_subdev_call(sd, video, querystd, a);\n}\n\nstatic int rvin_s_std(struct file *file, void *priv, v4l2_std_id a)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tint ret;\n\n\tret = v4l2_subdev_call(vin_to_source(vin), video, s_std, a);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvin->std = a;\n\n\t \n\treturn rvin_reset_format(vin);\n}\n\nstatic int rvin_g_std(struct file *file, void *priv, v4l2_std_id *a)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\n\tif (v4l2_subdev_has_op(vin_to_source(vin), pad, dv_timings_cap))\n\t\treturn -ENOIOCTLCMD;\n\n\t*a = vin->std;\n\n\treturn 0;\n}\n\nstatic int rvin_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\tconst struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_event_subscribe(fh, sub, 4, NULL);\n\t}\n\treturn v4l2_ctrl_subscribe_event(fh, sub);\n}\n\nstatic int rvin_enum_dv_timings(struct file *file, void *priv_fh,\n\t\t\t\tstruct v4l2_enum_dv_timings *timings)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\tint ret;\n\n\tif (timings->pad)\n\t\treturn -EINVAL;\n\n\ttimings->pad = vin->parallel.sink_pad;\n\n\tret = v4l2_subdev_call(sd, pad, enum_dv_timings, timings);\n\n\ttimings->pad = 0;\n\n\treturn ret;\n}\n\nstatic int rvin_s_dv_timings(struct file *file, void *priv_fh,\n\t\t\t     struct v4l2_dv_timings *timings)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\tint ret;\n\n\tret = v4l2_subdev_call(sd, video, s_dv_timings, timings);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn rvin_reset_format(vin);\n}\n\nstatic int rvin_g_dv_timings(struct file *file, void *priv_fh,\n\t\t\t     struct v4l2_dv_timings *timings)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\n\treturn v4l2_subdev_call(sd, video, g_dv_timings, timings);\n}\n\nstatic int rvin_query_dv_timings(struct file *file, void *priv_fh,\n\t\t\t\t struct v4l2_dv_timings *timings)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\n\treturn v4l2_subdev_call(sd, video, query_dv_timings, timings);\n}\n\nstatic int rvin_dv_timings_cap(struct file *file, void *priv_fh,\n\t\t\t       struct v4l2_dv_timings_cap *cap)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\tint ret;\n\n\tif (cap->pad)\n\t\treturn -EINVAL;\n\n\tcap->pad = vin->parallel.sink_pad;\n\n\tret = v4l2_subdev_call(sd, pad, dv_timings_cap, cap);\n\n\tcap->pad = 0;\n\n\treturn ret;\n}\n\nstatic int rvin_g_edid(struct file *file, void *fh, struct v4l2_edid *edid)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\tint ret;\n\n\tif (edid->pad)\n\t\treturn -EINVAL;\n\n\tedid->pad = vin->parallel.sink_pad;\n\n\tret = v4l2_subdev_call(sd, pad, get_edid, edid);\n\n\tedid->pad = 0;\n\n\treturn ret;\n}\n\nstatic int rvin_s_edid(struct file *file, void *fh, struct v4l2_edid *edid)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\tint ret;\n\n\tif (edid->pad)\n\t\treturn -EINVAL;\n\n\tedid->pad = vin->parallel.sink_pad;\n\n\tret = v4l2_subdev_call(sd, pad, set_edid, edid);\n\n\tedid->pad = 0;\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ioctl_ops rvin_ioctl_ops = {\n\t.vidioc_querycap\t\t= rvin_querycap,\n\t.vidioc_try_fmt_vid_cap\t\t= rvin_try_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= rvin_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= rvin_s_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_cap\t= rvin_enum_fmt_vid_cap,\n\n\t.vidioc_g_selection\t\t= rvin_g_selection,\n\t.vidioc_s_selection\t\t= rvin_s_selection,\n\n\t.vidioc_g_parm\t\t\t= rvin_g_parm,\n\t.vidioc_s_parm\t\t\t= rvin_s_parm,\n\n\t.vidioc_g_pixelaspect\t\t= rvin_g_pixelaspect,\n\n\t.vidioc_enum_input\t\t= rvin_enum_input,\n\t.vidioc_g_input\t\t\t= rvin_g_input,\n\t.vidioc_s_input\t\t\t= rvin_s_input,\n\n\t.vidioc_dv_timings_cap\t\t= rvin_dv_timings_cap,\n\t.vidioc_enum_dv_timings\t\t= rvin_enum_dv_timings,\n\t.vidioc_g_dv_timings\t\t= rvin_g_dv_timings,\n\t.vidioc_s_dv_timings\t\t= rvin_s_dv_timings,\n\t.vidioc_query_dv_timings\t= rvin_query_dv_timings,\n\n\t.vidioc_g_edid\t\t\t= rvin_g_edid,\n\t.vidioc_s_edid\t\t\t= rvin_s_edid,\n\n\t.vidioc_querystd\t\t= rvin_querystd,\n\t.vidioc_g_std\t\t\t= rvin_g_std,\n\t.vidioc_s_std\t\t\t= rvin_s_std,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\n\t.vidioc_log_status\t\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event\t\t= rvin_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\n \n\nstatic void rvin_mc_try_format(struct rvin_dev *vin,\n\t\t\t       struct v4l2_pix_format *pix)\n{\n\t \n\tpix->colorspace = RVIN_DEFAULT_COLORSPACE;\n\tpix->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(pix->colorspace);\n\tpix->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(pix->colorspace);\n\tpix->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true, pix->colorspace,\n\t\t\t\t\t\t\t  pix->ycbcr_enc);\n\n\trvin_format_align(vin, pix);\n}\n\nstatic int rvin_mc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\n\trvin_mc_try_format(vin, &f->fmt.pix);\n\n\treturn 0;\n}\n\nstatic int rvin_mc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\n\tif (vb2_is_busy(&vin->queue))\n\t\treturn -EBUSY;\n\n\trvin_mc_try_format(vin, &f->fmt.pix);\n\n\tvin->format = f->fmt.pix;\n\n\tvin->crop.top = 0;\n\tvin->crop.left = 0;\n\tvin->crop.width = vin->format.width;\n\tvin->crop.height = vin->format.height;\n\tvin->compose = vin->crop;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops rvin_mc_ioctl_ops = {\n\t.vidioc_querycap\t\t= rvin_querycap,\n\t.vidioc_try_fmt_vid_cap\t\t= rvin_mc_try_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= rvin_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= rvin_mc_s_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_cap\t= rvin_enum_fmt_vid_cap,\n\n\t.vidioc_g_selection\t\t= rvin_g_selection,\n\t.vidioc_s_selection\t\t= rvin_s_selection,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\n\t.vidioc_log_status\t\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event\t\t= rvin_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\n \n\nstatic int rvin_power_parallel(struct rvin_dev *vin, bool on)\n{\n\tstruct v4l2_subdev *sd = vin_to_source(vin);\n\tint power = on ? 1 : 0;\n\tint ret;\n\n\tret = v4l2_subdev_call(sd, core, s_power, power);\n\tif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rvin_open(struct file *file)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(vin->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mutex_lock_interruptible(&vin->lock);\n\tif (ret)\n\t\tgoto err_pm;\n\n\tfile->private_data = vin;\n\n\tret = v4l2_fh_open(file);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tif (vin->info->use_mc)\n\t\tret = v4l2_pipeline_pm_get(&vin->vdev.entity);\n\telse if (v4l2_fh_is_singular_file(file))\n\t\tret = rvin_power_parallel(vin, true);\n\n\tif (ret < 0)\n\t\tgoto err_open;\n\n\tret = v4l2_ctrl_handler_setup(&vin->ctrl_handler);\n\tif (ret)\n\t\tgoto err_power;\n\n\tmutex_unlock(&vin->lock);\n\n\treturn 0;\nerr_power:\n\tif (vin->info->use_mc)\n\t\tv4l2_pipeline_pm_put(&vin->vdev.entity);\n\telse if (v4l2_fh_is_singular_file(file))\n\t\trvin_power_parallel(vin, false);\nerr_open:\n\tv4l2_fh_release(file);\nerr_unlock:\n\tmutex_unlock(&vin->lock);\nerr_pm:\n\tpm_runtime_put(vin->dev);\n\n\treturn ret;\n}\n\nstatic int rvin_release(struct file *file)\n{\n\tstruct rvin_dev *vin = video_drvdata(file);\n\tbool fh_singular;\n\tint ret;\n\n\tmutex_lock(&vin->lock);\n\n\t \n\tfh_singular = v4l2_fh_is_singular_file(file);\n\n\t \n\tret = _vb2_fop_release(file, NULL);\n\n\tif (vin->info->use_mc) {\n\t\tv4l2_pipeline_pm_put(&vin->vdev.entity);\n\t} else {\n\t\tif (fh_singular)\n\t\t\trvin_power_parallel(vin, false);\n\t}\n\n\tmutex_unlock(&vin->lock);\n\n\tpm_runtime_put(vin->dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_file_operations rvin_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.open\t\t= rvin_open,\n\t.release\t= rvin_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.read\t\t= vb2_fop_read,\n};\n\nvoid rvin_v4l2_unregister(struct rvin_dev *vin)\n{\n\tif (!video_is_registered(&vin->vdev))\n\t\treturn;\n\n\tv4l2_info(&vin->v4l2_dev, \"Removing %s\\n\",\n\t\t  video_device_node_name(&vin->vdev));\n\n\t \n\tvideo_unregister_device(&vin->vdev);\n}\n\nstatic void rvin_notify_video_device(struct rvin_dev *vin,\n\t\t\t\t     unsigned int notification, void *arg)\n{\n\tswitch (notification) {\n\tcase V4L2_DEVICE_NOTIFY_EVENT:\n\t\tv4l2_event_queue(&vin->vdev, arg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rvin_notify(struct v4l2_subdev *sd,\n\t\t\tunsigned int notification, void *arg)\n{\n\tstruct v4l2_subdev *remote;\n\tstruct rvin_group *group;\n\tstruct media_pad *pad;\n\tstruct rvin_dev *vin =\n\t\tcontainer_of(sd->v4l2_dev, struct rvin_dev, v4l2_dev);\n\tunsigned int i;\n\n\t \n\tif (!vin->info->use_mc) {\n\t\trvin_notify_video_device(vin, notification, arg);\n\t\treturn;\n\t}\n\n\tgroup = vin->group;\n\n\tfor (i = 0; i < RCAR_VIN_NUM; i++) {\n\t\tvin = group->vin[i];\n\t\tif (!vin)\n\t\t\tcontinue;\n\n\t\tpad = media_pad_remote_pad_first(&vin->pad);\n\t\tif (!pad)\n\t\t\tcontinue;\n\n\t\tremote = media_entity_to_v4l2_subdev(pad->entity);\n\t\tif (remote != sd)\n\t\t\tcontinue;\n\n\t\trvin_notify_video_device(vin, notification, arg);\n\t}\n}\n\nint rvin_v4l2_register(struct rvin_dev *vin)\n{\n\tstruct video_device *vdev = &vin->vdev;\n\tint ret;\n\n\tvin->v4l2_dev.notify = rvin_notify;\n\n\t \n\tvdev->v4l2_dev = &vin->v4l2_dev;\n\tvdev->queue = &vin->queue;\n\tsnprintf(vdev->name, sizeof(vdev->name), \"VIN%u output\", vin->id);\n\tvdev->release = video_device_release_empty;\n\tvdev->lock = &vin->lock;\n\tvdev->fops = &rvin_fops;\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\n\t\tV4L2_CAP_READWRITE;\n\n\t \n\tvin->format.pixelformat\t= RVIN_DEFAULT_FORMAT;\n\tvin->format.width = RVIN_DEFAULT_WIDTH;\n\tvin->format.height = RVIN_DEFAULT_HEIGHT;\n\tvin->format.field = RVIN_DEFAULT_FIELD;\n\tvin->format.colorspace = RVIN_DEFAULT_COLORSPACE;\n\n\tif (vin->info->use_mc) {\n\t\tvdev->device_caps |= V4L2_CAP_IO_MC;\n\t\tvdev->ioctl_ops = &rvin_mc_ioctl_ops;\n\t} else {\n\t\tvdev->ioctl_ops = &rvin_ioctl_ops;\n\t\trvin_reset_format(vin);\n\t}\n\n\trvin_format_align(vin, &vin->format);\n\n\tret = video_register_device(&vin->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tvin_err(vin, \"Failed to register video device\\n\");\n\t\treturn ret;\n\t}\n\n\tvideo_set_drvdata(&vin->vdev, vin);\n\n\tv4l2_info(&vin->v4l2_dev, \"Device registered as %s\\n\",\n\t\t  video_device_node_name(&vin->vdev));\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}