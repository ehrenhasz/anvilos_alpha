{
  "module_name": "rcar-core.c",
  "hash_id": "d130f0f9d27da0a69dd287fd9dd8c5217a1226fb0e33f726931c613a297d2f01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/rcar-vin/rcar-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mc.h>\n\n#include \"rcar-vin.h\"\n\n \n#define rvin_group_csi_pad_to_channel(pad) ((pad) - 1)\n#define rvin_group_csi_channel_to_pad(channel) ((channel) + 1)\n\n \n#define rvin_group_id_to_master(vin) ((vin) < 4 ? 0 : 4)\n\n#define v4l2_dev_to_vin(d)\tcontainer_of(d, struct rvin_dev, v4l2_dev)\n\n \n\n \n\nstatic DEFINE_MUTEX(rvin_group_lock);\nstatic struct rvin_group *rvin_group_data;\n\nstatic void rvin_group_cleanup(struct rvin_group *group)\n{\n\tmedia_device_cleanup(&group->mdev);\n\tmutex_destroy(&group->lock);\n}\n\nstatic int rvin_group_init(struct rvin_group *group, struct rvin_dev *vin,\n\t\t\t   int (*link_setup)(struct rvin_dev *),\n\t\t\t   const struct media_device_ops *ops)\n{\n\tstruct media_device *mdev = &group->mdev;\n\tconst struct of_device_id *match;\n\tstruct device_node *np;\n\n\tmutex_init(&group->lock);\n\n\t \n\tgroup->count = 0;\n\tfor_each_matching_node(np, vin->dev->driver->of_match_table)\n\t\tif (of_device_is_available(np))\n\t\t\tgroup->count++;\n\n\tvin_dbg(vin, \"found %u enabled VIN's in DT\", group->count);\n\n\tgroup->link_setup = link_setup;\n\n\tmdev->dev = vin->dev;\n\tmdev->ops = ops;\n\n\tmatch = of_match_node(vin->dev->driver->of_match_table,\n\t\t\t      vin->dev->of_node);\n\n\tstrscpy(mdev->driver_name, KBUILD_MODNAME, sizeof(mdev->driver_name));\n\tstrscpy(mdev->model, match->compatible, sizeof(mdev->model));\n\n\tmedia_device_init(mdev);\n\n\treturn 0;\n}\n\nstatic void rvin_group_release(struct kref *kref)\n{\n\tstruct rvin_group *group =\n\t\tcontainer_of(kref, struct rvin_group, refcount);\n\n\tmutex_lock(&rvin_group_lock);\n\n\trvin_group_data = NULL;\n\n\trvin_group_cleanup(group);\n\n\tkfree(group);\n\n\tmutex_unlock(&rvin_group_lock);\n}\n\nstatic int rvin_group_get(struct rvin_dev *vin,\n\t\t\t  int (*link_setup)(struct rvin_dev *),\n\t\t\t  const struct media_device_ops *ops)\n{\n\tstruct rvin_group *group;\n\tu32 id;\n\tint ret;\n\n\t \n\tret = of_property_read_u32(vin->dev->of_node, \"renesas,id\", &id);\n\tif (ret) {\n\t\tvin_err(vin, \"%pOF: No renesas,id property found\\n\",\n\t\t\tvin->dev->of_node);\n\t\treturn -EINVAL;\n\t}\n\n\tif (id >= RCAR_VIN_NUM) {\n\t\tvin_err(vin, \"%pOF: Invalid renesas,id '%u'\\n\",\n\t\t\tvin->dev->of_node, id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmutex_lock(&rvin_group_lock);\n\tif (rvin_group_data) {\n\t\tgroup = rvin_group_data;\n\t\tkref_get(&group->refcount);\n\t} else {\n\t\tgroup = kzalloc(sizeof(*group), GFP_KERNEL);\n\t\tif (!group) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_group;\n\t\t}\n\n\t\tret = rvin_group_init(group, vin, link_setup, ops);\n\t\tif (ret) {\n\t\t\tkfree(group);\n\t\t\tvin_err(vin, \"Failed to initialize group\\n\");\n\t\t\tgoto err_group;\n\t\t}\n\n\t\tkref_init(&group->refcount);\n\n\t\trvin_group_data = group;\n\t}\n\tmutex_unlock(&rvin_group_lock);\n\n\t \n\tmutex_lock(&group->lock);\n\n\tif (group->vin[id]) {\n\t\tvin_err(vin, \"Duplicate renesas,id property value %u\\n\", id);\n\t\tmutex_unlock(&group->lock);\n\t\tkref_put(&group->refcount, rvin_group_release);\n\t\treturn -EINVAL;\n\t}\n\n\tgroup->vin[id] = vin;\n\n\tvin->id = id;\n\tvin->group = group;\n\tvin->v4l2_dev.mdev = &group->mdev;\n\n\tmutex_unlock(&group->lock);\n\n\treturn 0;\nerr_group:\n\tmutex_unlock(&rvin_group_lock);\n\treturn ret;\n}\n\nstatic void rvin_group_put(struct rvin_dev *vin)\n{\n\tstruct rvin_group *group = vin->group;\n\n\tmutex_lock(&group->lock);\n\n\tvin->group = NULL;\n\tvin->v4l2_dev.mdev = NULL;\n\n\tif (WARN_ON(group->vin[vin->id] != vin))\n\t\tgoto out;\n\n\tgroup->vin[vin->id] = NULL;\nout:\n\tmutex_unlock(&group->lock);\n\n\tkref_put(&group->refcount, rvin_group_release);\n}\n\n \nstatic int rvin_group_entity_to_remote_id(struct rvin_group *group,\n\t\t\t\t\t  struct media_entity *entity)\n{\n\tstruct v4l2_subdev *sd;\n\tunsigned int i;\n\n\tsd = media_entity_to_v4l2_subdev(entity);\n\n\tfor (i = 0; i < RVIN_REMOTES_MAX; i++)\n\t\tif (group->remotes[i].subdev == sd)\n\t\t\treturn i;\n\n\treturn -ENODEV;\n}\n\nstatic int rvin_group_notify_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct rvin_dev *vin = v4l2_dev_to_vin(notifier->v4l2_dev);\n\tunsigned int i;\n\tint ret;\n\n\tret = media_device_register(&vin->group->mdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_device_register_subdev_nodes(&vin->v4l2_dev);\n\tif (ret) {\n\t\tvin_err(vin, \"Failed to register subdev nodes\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < RCAR_VIN_NUM; i++) {\n\t\tif (vin->group->vin[i] &&\n\t\t    !video_is_registered(&vin->group->vin[i]->vdev)) {\n\t\t\tret = rvin_v4l2_register(vin->group->vin[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn vin->group->link_setup(vin);\n}\n\nstatic void rvin_group_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\t     struct v4l2_subdev *subdev,\n\t\t\t\t     struct v4l2_async_connection *asc)\n{\n\tstruct rvin_dev *vin = v4l2_dev_to_vin(notifier->v4l2_dev);\n\tunsigned int i;\n\n\tfor (i = 0; i < RCAR_VIN_NUM; i++)\n\t\tif (vin->group->vin[i])\n\t\t\trvin_v4l2_unregister(vin->group->vin[i]);\n\n\tmutex_lock(&vin->group->lock);\n\n\tfor (i = 0; i < RVIN_CSI_MAX; i++) {\n\t\tif (vin->group->remotes[i].asc != asc)\n\t\t\tcontinue;\n\t\tvin->group->remotes[i].subdev = NULL;\n\t\tvin_dbg(vin, \"Unbind %s from slot %u\\n\", subdev->name, i);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&vin->group->lock);\n\n\tmedia_device_unregister(&vin->group->mdev);\n}\n\nstatic int rvin_group_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t   struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_async_connection *asc)\n{\n\tstruct rvin_dev *vin = v4l2_dev_to_vin(notifier->v4l2_dev);\n\tunsigned int i;\n\n\tmutex_lock(&vin->group->lock);\n\n\tfor (i = 0; i < RVIN_CSI_MAX; i++) {\n\t\tif (vin->group->remotes[i].asc != asc)\n\t\t\tcontinue;\n\t\tvin->group->remotes[i].subdev = subdev;\n\t\tvin_dbg(vin, \"Bound %s to slot %u\\n\", subdev->name, i);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&vin->group->lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_async_notifier_operations rvin_group_notify_ops = {\n\t.bound = rvin_group_notify_bound,\n\t.unbind = rvin_group_notify_unbind,\n\t.complete = rvin_group_notify_complete,\n};\n\nstatic int rvin_group_parse_of(struct rvin_dev *vin, unsigned int port,\n\t\t\t       unsigned int id)\n{\n\tstruct fwnode_handle *ep, *fwnode;\n\tstruct v4l2_fwnode_endpoint vep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tstruct v4l2_async_connection *asc;\n\tint ret;\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(vin->dev), port, id, 0);\n\tif (!ep)\n\t\treturn 0;\n\n\tfwnode = fwnode_graph_get_remote_endpoint(ep);\n\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\tfwnode_handle_put(ep);\n\tif (ret) {\n\t\tvin_err(vin, \"Failed to parse %pOF\\n\", to_of_node(fwnode));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tasc = v4l2_async_nf_add_fwnode(&vin->group->notifier, fwnode,\n\t\t\t\t       struct v4l2_async_connection);\n\tif (IS_ERR(asc)) {\n\t\tret = PTR_ERR(asc);\n\t\tgoto out;\n\t}\n\n\tvin->group->remotes[vep.base.id].asc = asc;\n\n\tvin_dbg(vin, \"Add group OF device %pOF to slot %u\\n\",\n\t\tto_of_node(fwnode), vep.base.id);\nout:\n\tfwnode_handle_put(fwnode);\n\n\treturn ret;\n}\n\nstatic void rvin_group_notifier_cleanup(struct rvin_dev *vin)\n{\n\tif (&vin->v4l2_dev == vin->group->notifier.v4l2_dev) {\n\t\tv4l2_async_nf_unregister(&vin->group->notifier);\n\t\tv4l2_async_nf_cleanup(&vin->group->notifier);\n\t}\n}\n\nstatic int rvin_group_notifier_init(struct rvin_dev *vin, unsigned int port,\n\t\t\t\t    unsigned int max_id)\n{\n\tunsigned int count = 0, vin_mask = 0;\n\tunsigned int i, id;\n\tint ret;\n\n\tmutex_lock(&vin->group->lock);\n\n\t \n\tfor (i = 0; i < RCAR_VIN_NUM; i++) {\n\t\tif (vin->group->vin[i]) {\n\t\t\tcount++;\n\t\t\tvin_mask |= BIT(i);\n\t\t}\n\t}\n\n\tif (vin->group->count != count) {\n\t\tmutex_unlock(&vin->group->lock);\n\t\treturn 0;\n\t}\n\n\tmutex_unlock(&vin->group->lock);\n\n\tv4l2_async_nf_init(&vin->group->notifier, &vin->v4l2_dev);\n\n\t \n\tfor (i = 0; i < RCAR_VIN_NUM; i++) {\n\t\tif (!(vin_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tfor (id = 0; id < max_id; id++) {\n\t\t\tif (vin->group->remotes[id].asc)\n\t\t\t\tcontinue;\n\n\t\t\tret = rvin_group_parse_of(vin->group->vin[i], port, id);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (list_empty(&vin->group->notifier.waiting_list))\n\t\treturn 0;\n\n\tvin->group->notifier.ops = &rvin_group_notify_ops;\n\tret = v4l2_async_nf_register(&vin->group->notifier);\n\tif (ret < 0) {\n\t\tvin_err(vin, \"Notifier registration failed\\n\");\n\t\tv4l2_async_nf_cleanup(&vin->group->notifier);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int rvin_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct rvin_dev *vin =\n\t\tcontainer_of(ctrl->handler, struct rvin_dev, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_ALPHA_COMPONENT:\n\t\trvin_set_alpha(vin, ctrl->val);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops rvin_ctrl_ops = {\n\t.s_ctrl = rvin_s_ctrl,\n};\n\nstatic void rvin_free_controls(struct rvin_dev *vin)\n{\n\tv4l2_ctrl_handler_free(&vin->ctrl_handler);\n\tvin->vdev.ctrl_handler = NULL;\n}\n\nstatic int rvin_create_controls(struct rvin_dev *vin, struct v4l2_subdev *subdev)\n{\n\tint ret;\n\n\tret = v4l2_ctrl_handler_init(&vin->ctrl_handler, 16);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tv4l2_ctrl_new_std(&vin->ctrl_handler, &rvin_ctrl_ops,\n\t\t\t  V4L2_CID_ALPHA_COMPONENT, 0, 255, 1, 255);\n\n\tif (vin->ctrl_handler.error) {\n\t\tret = vin->ctrl_handler.error;\n\t\trvin_free_controls(vin);\n\t\treturn ret;\n\t}\n\n\t \n\tif (subdev) {\n\t\tret = v4l2_ctrl_add_handler(&vin->ctrl_handler,\n\t\t\t\t\t    subdev->ctrl_handler, NULL, true);\n\t\tif (ret < 0) {\n\t\t\trvin_free_controls(vin);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tvin->vdev.ctrl_handler = &vin->ctrl_handler;\n\n\treturn 0;\n}\n\n \n\nstatic int rvin_find_pad(struct v4l2_subdev *sd, int direction)\n{\n\tunsigned int pad;\n\n\tif (sd->entity.num_pads <= 1)\n\t\treturn 0;\n\n\tfor (pad = 0; pad < sd->entity.num_pads; pad++)\n\t\tif (sd->entity.pads[pad].flags & direction)\n\t\t\treturn pad;\n\n\treturn -EINVAL;\n}\n\n \n\n \nstatic int rvin_parallel_subdevice_attach(struct rvin_dev *vin,\n\t\t\t\t\t  struct v4l2_subdev *subdev)\n{\n\tstruct v4l2_subdev_mbus_code_enum code = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\t \n\tret = rvin_find_pad(subdev, MEDIA_PAD_FL_SOURCE);\n\tif (ret < 0)\n\t\treturn ret;\n\tvin->parallel.source_pad = ret;\n\n\tret = rvin_find_pad(subdev, MEDIA_PAD_FL_SINK);\n\tvin->parallel.sink_pad = ret < 0 ? 0 : ret;\n\n\tif (vin->info->use_mc) {\n\t\tvin->parallel.subdev = subdev;\n\t\treturn 0;\n\t}\n\n\t \n\tvin->mbus_code = 0;\n\tcode.index = 0;\n\tcode.pad = vin->parallel.source_pad;\n\twhile (!vin->mbus_code &&\n\t       !v4l2_subdev_call(subdev, pad, enum_mbus_code, NULL, &code)) {\n\t\tcode.index++;\n\t\tswitch (code.code) {\n\t\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\t\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tcase MEDIA_BUS_FMT_UYVY10_2X10:\n\t\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\t\tvin->mbus_code = code.code;\n\t\t\tvin_dbg(vin, \"Found media bus format for %s: %d\\n\",\n\t\t\t\tsubdev->name, vin->mbus_code);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!vin->mbus_code) {\n\t\tvin_err(vin, \"Unsupported media bus format for %s\\n\",\n\t\t\tsubdev->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = v4l2_subdev_call(subdev, video, g_tvnorms, &vin->vdev.tvnorms);\n\tif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)\n\t\treturn ret;\n\n\t \n\tvin->std = V4L2_STD_UNKNOWN;\n\tret = v4l2_subdev_call(subdev, video, g_std, &vin->std);\n\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\t \n\tret = rvin_create_controls(vin, subdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvin->parallel.subdev = subdev;\n\n\treturn 0;\n}\n\nstatic void rvin_parallel_subdevice_detach(struct rvin_dev *vin)\n{\n\trvin_v4l2_unregister(vin);\n\tvin->parallel.subdev = NULL;\n\n\tif (!vin->info->use_mc)\n\t\trvin_free_controls(vin);\n}\n\nstatic int rvin_parallel_notify_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct rvin_dev *vin = v4l2_dev_to_vin(notifier->v4l2_dev);\n\tstruct media_entity *source;\n\tstruct media_entity *sink;\n\tint ret;\n\n\tret = v4l2_device_register_subdev_nodes(&vin->v4l2_dev);\n\tif (ret < 0) {\n\t\tvin_err(vin, \"Failed to register subdev nodes\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!video_is_registered(&vin->vdev)) {\n\t\tret = rvin_v4l2_register(vin);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (!vin->info->use_mc)\n\t\treturn 0;\n\n\t \n\tsource = &vin->parallel.subdev->entity;\n\tsink = &vin->vdev.entity;\n\n\tret = media_create_pad_link(source, vin->parallel.source_pad,\n\t\t\t\t    sink, vin->parallel.sink_pad, 0);\n\tif (ret)\n\t\tvin_err(vin, \"Error adding link from %s to %s: %d\\n\",\n\t\t\tsource->name, sink->name, ret);\n\n\treturn ret;\n}\n\nstatic void rvin_parallel_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\t\tstruct v4l2_subdev *subdev,\n\t\t\t\t\tstruct v4l2_async_connection *asc)\n{\n\tstruct rvin_dev *vin = v4l2_dev_to_vin(notifier->v4l2_dev);\n\n\tvin_dbg(vin, \"unbind parallel subdev %s\\n\", subdev->name);\n\n\tmutex_lock(&vin->lock);\n\trvin_parallel_subdevice_detach(vin);\n\tmutex_unlock(&vin->lock);\n}\n\nstatic int rvin_parallel_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t      struct v4l2_subdev *subdev,\n\t\t\t\t      struct v4l2_async_connection *asc)\n{\n\tstruct rvin_dev *vin = v4l2_dev_to_vin(notifier->v4l2_dev);\n\tint ret;\n\n\tmutex_lock(&vin->lock);\n\tret = rvin_parallel_subdevice_attach(vin, subdev);\n\tmutex_unlock(&vin->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tv4l2_set_subdev_hostdata(subdev, vin);\n\n\tvin_dbg(vin, \"bound subdev %s source pad: %u sink pad: %u\\n\",\n\t\tsubdev->name, vin->parallel.source_pad,\n\t\tvin->parallel.sink_pad);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_async_notifier_operations rvin_parallel_notify_ops = {\n\t.bound = rvin_parallel_notify_bound,\n\t.unbind = rvin_parallel_notify_unbind,\n\t.complete = rvin_parallel_notify_complete,\n};\n\nstatic int rvin_parallel_parse_of(struct rvin_dev *vin)\n{\n\tstruct fwnode_handle *ep, *fwnode;\n\tstruct v4l2_fwnode_endpoint vep = {\n\t\t.bus_type = V4L2_MBUS_UNKNOWN,\n\t};\n\tstruct v4l2_async_connection *asc;\n\tint ret;\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(vin->dev), 0, 0, 0);\n\tif (!ep)\n\t\treturn 0;\n\n\tfwnode = fwnode_graph_get_remote_endpoint(ep);\n\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\tfwnode_handle_put(ep);\n\tif (ret) {\n\t\tvin_err(vin, \"Failed to parse %pOF\\n\", to_of_node(fwnode));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (vep.bus_type) {\n\tcase V4L2_MBUS_PARALLEL:\n\tcase V4L2_MBUS_BT656:\n\t\tvin_dbg(vin, \"Found %s media bus\\n\",\n\t\t\tvep.bus_type == V4L2_MBUS_PARALLEL ?\n\t\t\t\"PARALLEL\" : \"BT656\");\n\t\tvin->parallel.mbus_type = vep.bus_type;\n\t\tvin->parallel.bus = vep.bus.parallel;\n\t\tbreak;\n\tdefault:\n\t\tvin_err(vin, \"Unknown media bus type\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tasc = v4l2_async_nf_add_fwnode(&vin->notifier, fwnode,\n\t\t\t\t       struct v4l2_async_connection);\n\tif (IS_ERR(asc)) {\n\t\tret = PTR_ERR(asc);\n\t\tgoto out;\n\t}\n\n\tvin->parallel.asc = asc;\n\n\tvin_dbg(vin, \"Add parallel OF device %pOF\\n\", to_of_node(fwnode));\nout:\n\tfwnode_handle_put(fwnode);\n\n\treturn ret;\n}\n\nstatic void rvin_parallel_cleanup(struct rvin_dev *vin)\n{\n\tv4l2_async_nf_unregister(&vin->notifier);\n\tv4l2_async_nf_cleanup(&vin->notifier);\n}\n\nstatic int rvin_parallel_init(struct rvin_dev *vin)\n{\n\tint ret;\n\n\tv4l2_async_nf_init(&vin->notifier, &vin->v4l2_dev);\n\n\tret = rvin_parallel_parse_of(vin);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!vin->parallel.asc)\n\t\treturn -ENODEV;\n\n\tvin_dbg(vin, \"Found parallel subdevice %pOF\\n\",\n\t\tto_of_node(vin->parallel.asc->match.fwnode));\n\n\tvin->notifier.ops = &rvin_parallel_notify_ops;\n\tret = v4l2_async_nf_register(&vin->notifier);\n\tif (ret < 0) {\n\t\tvin_err(vin, \"Notifier registration failed\\n\");\n\t\tv4l2_async_nf_cleanup(&vin->notifier);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic int rvin_csi2_link_notify(struct media_link *link, u32 flags,\n\t\t\t\t unsigned int notification)\n{\n\tstruct rvin_group *group = container_of(link->graph_obj.mdev,\n\t\t\t\t\t\tstruct rvin_group, mdev);\n\tstruct media_entity *entity;\n\tstruct video_device *vdev;\n\tstruct rvin_dev *vin;\n\tunsigned int i;\n\tint csi_id, ret;\n\n\tret = v4l2_pipeline_link_notify(link, flags, notification);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!(flags & MEDIA_LNK_FL_ENABLED) ||\n\t    !is_media_entity_v4l2_video_device(link->sink->entity))\n\t\treturn 0;\n\n\t \n\tmedia_device_for_each_entity(entity, &group->mdev)\n\t\tif (media_entity_is_streaming(entity))\n\t\t\treturn -EBUSY;\n\n\t \n\tvdev = media_entity_to_video_device(link->sink->entity);\n\tvin = container_of(vdev, struct rvin_dev, vdev);\n\n\tmutex_lock(&group->lock);\n\n\tcsi_id = rvin_group_entity_to_remote_id(group, link->source->entity);\n\tif (csi_id == -ENODEV) {\n\t\tstruct v4l2_subdev *sd;\n\n\t\t \n\t\tsd = media_entity_to_v4l2_subdev(link->source->entity);\n\t\tfor (i = 0; i < RCAR_VIN_NUM; i++) {\n\t\t\tif (group->vin[i] &&\n\t\t\t    group->vin[i]->parallel.subdev == sd) {\n\t\t\t\tgroup->vin[i]->is_csi = false;\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tvin_err(vin, \"Subdevice %s not registered to any VIN\\n\",\n\t\t\tlink->source->entity->name);\n\t\tret = -ENODEV;\n\t} else {\n\t\tconst struct rvin_group_route *route;\n\t\tunsigned int chsel = UINT_MAX;\n\t\tunsigned int master_id;\n\n\t\tmaster_id = rvin_group_id_to_master(vin->id);\n\n\t\tif (WARN_ON(!group->vin[master_id])) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tfor (i = master_id; i < master_id + 4; i++) {\n\t\t\tstruct media_pad *csi_pad;\n\n\t\t\tif (!group->vin[i])\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tcsi_pad = media_pad_remote_pad_first(\n\t\t\t\t\t&group->vin[i]->vdev.entity.pads[0]);\n\t\t\tif (!csi_pad)\n\t\t\t\tcontinue;\n\n\t\t\tif (csi_pad->entity != link->source->entity) {\n\t\t\t\tvin_dbg(vin, \"Already attached to %s\\n\",\n\t\t\t\t\tcsi_pad->entity->name);\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tfor (route = vin->info->routes; route->chsel; route++) {\n\t\t\tif (route->master == master_id && route->csi == csi_id) {\n\t\t\t\tchsel = route->chsel;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (chsel == UINT_MAX) {\n\t\t\tvin_err(vin, \"No CHSEL value found\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = rvin_set_channel_routing(group->vin[master_id], chsel);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tvin->is_csi = true;\n\t}\nout:\n\tmutex_unlock(&group->lock);\n\n\treturn ret;\n}\n\nstatic const struct media_device_ops rvin_csi2_media_ops = {\n\t.link_notify = rvin_csi2_link_notify,\n};\n\nstatic int rvin_csi2_create_link(struct rvin_group *group, unsigned int id,\n\t\t\t\t const struct rvin_group_route *route)\n{\n\tstruct media_entity *source = &group->remotes[route->csi].subdev->entity;\n\tstruct media_entity *sink = &group->vin[id]->vdev.entity;\n\tstruct media_pad *sink_pad = &sink->pads[0];\n\tunsigned int channel;\n\tint ret;\n\n\tfor (channel = 0; channel < 4; channel++) {\n\t\tunsigned int source_idx = rvin_group_csi_channel_to_pad(channel);\n\t\tstruct media_pad *source_pad = &source->pads[source_idx];\n\n\t\t \n\t\tif (media_entity_find_link(source_pad, sink_pad))\n\t\t\tcontinue;\n\n\t\tret = media_create_pad_link(source, source_idx, sink, 0, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rvin_csi2_setup_links(struct rvin_dev *vin)\n{\n\tconst struct rvin_group_route *route;\n\tunsigned int id;\n\tint ret = -EINVAL;\n\n\t \n\tmutex_lock(&vin->group->lock);\n\tfor (route = vin->info->routes; route->chsel; route++) {\n\t\t \n\t\tif (!vin->group->vin[route->master])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!vin->group->remotes[route->csi].subdev)\n\t\t\tcontinue;\n\n\t\tfor (id = route->master; id < route->master + 4; id++) {\n\t\t\t \n\t\t\tif (!vin->group->vin[id])\n\t\t\t\tcontinue;\n\n\t\t\tret = rvin_csi2_create_link(vin->group, id, route);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&vin->group->lock);\n\n\treturn ret;\n}\n\nstatic void rvin_csi2_cleanup(struct rvin_dev *vin)\n{\n\trvin_parallel_cleanup(vin);\n\trvin_group_notifier_cleanup(vin);\n\trvin_group_put(vin);\n\trvin_free_controls(vin);\n}\n\nstatic int rvin_csi2_init(struct rvin_dev *vin)\n{\n\tint ret;\n\n\tvin->pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&vin->vdev.entity, 1, &vin->pad);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rvin_create_controls(vin, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rvin_group_get(vin, rvin_csi2_setup_links, &rvin_csi2_media_ops);\n\tif (ret)\n\t\tgoto err_controls;\n\n\t \n\tret = rvin_parallel_init(vin);\n\tif (ret && ret != -ENODEV)\n\t\tgoto err_group;\n\n\tret = rvin_group_notifier_init(vin, 1, RVIN_CSI_MAX);\n\tif (ret)\n\t\tgoto err_parallel;\n\n\treturn 0;\nerr_parallel:\n\trvin_parallel_cleanup(vin);\nerr_group:\n\trvin_group_put(vin);\nerr_controls:\n\trvin_free_controls(vin);\n\n\treturn ret;\n}\n\n \n\nstatic int rvin_isp_setup_links(struct rvin_dev *vin)\n{\n\tunsigned int i;\n\tint ret = -EINVAL;\n\n\t \n\tmutex_lock(&vin->group->lock);\n\tfor (i = 0; i < RCAR_VIN_NUM; i++) {\n\t\tstruct media_pad *source_pad, *sink_pad;\n\t\tstruct media_entity *source, *sink;\n\t\tunsigned int source_slot = i / 8;\n\t\tunsigned int source_idx = i % 8 + 1;\n\n\t\tif (!vin->group->vin[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!vin->group->remotes[source_slot].subdev)\n\t\t\tcontinue;\n\n\t\tsource = &vin->group->remotes[source_slot].subdev->entity;\n\t\tsource_pad = &source->pads[source_idx];\n\n\t\tsink = &vin->group->vin[i]->vdev.entity;\n\t\tsink_pad = &sink->pads[0];\n\n\t\t \n\t\tif (media_entity_find_link(source_pad, sink_pad))\n\t\t\tcontinue;\n\n\t\tret = media_create_pad_link(source, source_idx, sink, 0,\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\t\tif (ret) {\n\t\t\tvin_err(vin, \"Error adding link from %s to %s\\n\",\n\t\t\t\tsource->name, sink->name);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vin->group->lock);\n\n\treturn ret;\n}\n\nstatic void rvin_isp_cleanup(struct rvin_dev *vin)\n{\n\trvin_group_notifier_cleanup(vin);\n\trvin_group_put(vin);\n\trvin_free_controls(vin);\n}\n\nstatic int rvin_isp_init(struct rvin_dev *vin)\n{\n\tint ret;\n\n\tvin->pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&vin->vdev.entity, 1, &vin->pad);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rvin_create_controls(vin, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rvin_group_get(vin, rvin_isp_setup_links, NULL);\n\tif (ret)\n\t\tgoto err_controls;\n\n\tret = rvin_group_notifier_init(vin, 2, RVIN_ISP_MAX);\n\tif (ret)\n\t\tgoto err_group;\n\n\treturn 0;\nerr_group:\n\trvin_group_put(vin);\nerr_controls:\n\trvin_free_controls(vin);\n\n\treturn ret;\n}\n\n \n\nstatic int __maybe_unused rvin_suspend(struct device *dev)\n{\n\tstruct rvin_dev *vin = dev_get_drvdata(dev);\n\n\tif (vin->state != RUNNING)\n\t\treturn 0;\n\n\trvin_stop_streaming(vin);\n\n\tvin->state = SUSPENDED;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rvin_resume(struct device *dev)\n{\n\tstruct rvin_dev *vin = dev_get_drvdata(dev);\n\n\tif (vin->state != SUSPENDED)\n\t\treturn 0;\n\n\t \n\tif (vin->info->use_mc) {\n\t\tunsigned int master_id = rvin_group_id_to_master(vin->id);\n\t\tstruct rvin_dev *master = vin->group->vin[master_id];\n\t\tint ret;\n\n\t\tif (WARN_ON(!master))\n\t\t\treturn -ENODEV;\n\n\t\tret = rvin_set_channel_routing(master, master->chsel);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn rvin_start_streaming(vin);\n}\n\n \n\nstatic const struct rvin_info rcar_info_h1 = {\n\t.model = RCAR_H1,\n\t.use_mc = false,\n\t.max_width = 2048,\n\t.max_height = 2048,\n\t.scaler = rvin_scaler_gen2,\n};\n\nstatic const struct rvin_info rcar_info_m1 = {\n\t.model = RCAR_M1,\n\t.use_mc = false,\n\t.max_width = 2048,\n\t.max_height = 2048,\n\t.scaler = rvin_scaler_gen2,\n};\n\nstatic const struct rvin_info rcar_info_gen2 = {\n\t.model = RCAR_GEN2,\n\t.use_mc = false,\n\t.max_width = 2048,\n\t.max_height = 2048,\n\t.scaler = rvin_scaler_gen2,\n};\n\nstatic const struct rvin_group_route rcar_info_r8a774e1_routes[] = {\n\t{ .master = 0, .csi = RVIN_CSI20, .chsel = 0x04 },\n\t{ .master = 0, .csi = RVIN_CSI40, .chsel = 0x03 },\n\t{ .master = 4, .csi = RVIN_CSI20, .chsel = 0x04 },\n\t{   }\n};\n\nstatic const struct rvin_info rcar_info_r8a774e1 = {\n\t.model = RCAR_GEN3,\n\t.use_mc = true,\n\t.max_width = 4096,\n\t.max_height = 4096,\n\t.routes = rcar_info_r8a774e1_routes,\n};\n\nstatic const struct rvin_group_route rcar_info_r8a7795_routes[] = {\n\t{ .master = 0, .csi = RVIN_CSI20, .chsel = 0x04 },\n\t{ .master = 0, .csi = RVIN_CSI40, .chsel = 0x03 },\n\t{ .master = 4, .csi = RVIN_CSI20, .chsel = 0x04 },\n\t{ .master = 4, .csi = RVIN_CSI41, .chsel = 0x03 },\n\t{   }\n};\n\nstatic const struct rvin_info rcar_info_r8a7795 = {\n\t.model = RCAR_GEN3,\n\t.use_mc = true,\n\t.nv12 = true,\n\t.max_width = 4096,\n\t.max_height = 4096,\n\t.routes = rcar_info_r8a7795_routes,\n\t.scaler = rvin_scaler_gen3,\n};\n\nstatic const struct rvin_group_route rcar_info_r8a7796_routes[] = {\n\t{ .master = 0, .csi = RVIN_CSI20, .chsel = 0x04 },\n\t{ .master = 0, .csi = RVIN_CSI40, .chsel = 0x03 },\n\t{ .master = 4, .csi = RVIN_CSI20, .chsel = 0x04 },\n\t{ .master = 4, .csi = RVIN_CSI40, .chsel = 0x03 },\n\t{   }\n};\n\nstatic const struct rvin_info rcar_info_r8a7796 = {\n\t.model = RCAR_GEN3,\n\t.use_mc = true,\n\t.nv12 = true,\n\t.max_width = 4096,\n\t.max_height = 4096,\n\t.routes = rcar_info_r8a7796_routes,\n\t.scaler = rvin_scaler_gen3,\n};\n\nstatic const struct rvin_group_route rcar_info_r8a77965_routes[] = {\n\t{ .master = 0, .csi = RVIN_CSI20, .chsel = 0x04 },\n\t{ .master = 0, .csi = RVIN_CSI40, .chsel = 0x03 },\n\t{ .master = 4, .csi = RVIN_CSI20, .chsel = 0x04 },\n\t{ .master = 4, .csi = RVIN_CSI40, .chsel = 0x03 },\n\t{   }\n};\n\nstatic const struct rvin_info rcar_info_r8a77965 = {\n\t.model = RCAR_GEN3,\n\t.use_mc = true,\n\t.nv12 = true,\n\t.max_width = 4096,\n\t.max_height = 4096,\n\t.routes = rcar_info_r8a77965_routes,\n\t.scaler = rvin_scaler_gen3,\n};\n\nstatic const struct rvin_group_route rcar_info_r8a77970_routes[] = {\n\t{ .master = 0, .csi = RVIN_CSI40, .chsel = 0x03 },\n\t{   }\n};\n\nstatic const struct rvin_info rcar_info_r8a77970 = {\n\t.model = RCAR_GEN3,\n\t.use_mc = true,\n\t.max_width = 4096,\n\t.max_height = 4096,\n\t.routes = rcar_info_r8a77970_routes,\n};\n\nstatic const struct rvin_group_route rcar_info_r8a77980_routes[] = {\n\t{ .master = 0, .csi = RVIN_CSI40, .chsel = 0x03 },\n\t{ .master = 4, .csi = RVIN_CSI41, .chsel = 0x03 },\n\t{   }\n};\n\nstatic const struct rvin_info rcar_info_r8a77980 = {\n\t.model = RCAR_GEN3,\n\t.use_mc = true,\n\t.nv12 = true,\n\t.max_width = 4096,\n\t.max_height = 4096,\n\t.routes = rcar_info_r8a77980_routes,\n};\n\nstatic const struct rvin_group_route rcar_info_r8a77990_routes[] = {\n\t{ .master = 4, .csi = RVIN_CSI40, .chsel = 0x03 },\n\t{   }\n};\n\nstatic const struct rvin_info rcar_info_r8a77990 = {\n\t.model = RCAR_GEN3,\n\t.use_mc = true,\n\t.nv12 = true,\n\t.max_width = 4096,\n\t.max_height = 4096,\n\t.routes = rcar_info_r8a77990_routes,\n\t.scaler = rvin_scaler_gen3,\n};\n\nstatic const struct rvin_group_route rcar_info_r8a77995_routes[] = {\n\t{   }\n};\n\nstatic const struct rvin_info rcar_info_r8a77995 = {\n\t.model = RCAR_GEN3,\n\t.use_mc = true,\n\t.nv12 = true,\n\t.max_width = 4096,\n\t.max_height = 4096,\n\t.routes = rcar_info_r8a77995_routes,\n\t.scaler = rvin_scaler_gen3,\n};\n\nstatic const struct rvin_info rcar_info_r8a779a0 = {\n\t.model = RCAR_GEN3,\n\t.use_mc = true,\n\t.use_isp = true,\n\t.nv12 = true,\n\t.max_width = 4096,\n\t.max_height = 4096,\n};\n\nstatic const struct rvin_info rcar_info_r8a779g0 = {\n\t.model = RCAR_GEN3,\n\t.use_mc = true,\n\t.use_isp = true,\n\t.nv12 = true,\n\t.max_width = 4096,\n\t.max_height = 4096,\n};\n\nstatic const struct of_device_id rvin_of_id_table[] = {\n\t{\n\t\t.compatible = \"renesas,vin-r8a774a1\",\n\t\t.data = &rcar_info_r8a7796,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a774b1\",\n\t\t.data = &rcar_info_r8a77965,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a774c0\",\n\t\t.data = &rcar_info_r8a77990,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a774e1\",\n\t\t.data = &rcar_info_r8a774e1,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a7778\",\n\t\t.data = &rcar_info_m1,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a7779\",\n\t\t.data = &rcar_info_h1,\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen2-vin\",\n\t\t.data = &rcar_info_gen2,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a7795\",\n\t\t.data = &rcar_info_r8a7795,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a7796\",\n\t\t.data = &rcar_info_r8a7796,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a77961\",\n\t\t.data = &rcar_info_r8a7796,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a77965\",\n\t\t.data = &rcar_info_r8a77965,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a77970\",\n\t\t.data = &rcar_info_r8a77970,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a77980\",\n\t\t.data = &rcar_info_r8a77980,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a77990\",\n\t\t.data = &rcar_info_r8a77990,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a77995\",\n\t\t.data = &rcar_info_r8a77995,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a779a0\",\n\t\t.data = &rcar_info_r8a779a0,\n\t},\n\t{\n\t\t.compatible = \"renesas,vin-r8a779g0\",\n\t\t.data = &rcar_info_r8a779g0,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, rvin_of_id_table);\n\nstatic int rcar_vin_probe(struct platform_device *pdev)\n{\n\tstruct rvin_dev *vin;\n\tint irq, ret;\n\n\tvin = devm_kzalloc(&pdev->dev, sizeof(*vin), GFP_KERNEL);\n\tif (!vin)\n\t\treturn -ENOMEM;\n\n\tvin->dev = &pdev->dev;\n\tvin->info = of_device_get_match_data(&pdev->dev);\n\tvin->alpha = 0xff;\n\n\tvin->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(vin->base))\n\t\treturn PTR_ERR(vin->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = rvin_dma_register(vin, irq);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, vin);\n\n\tif (vin->info->use_isp) {\n\t\tret = rvin_isp_init(vin);\n\t} else if (vin->info->use_mc) {\n\t\tret = rvin_csi2_init(vin);\n\n\t\tif (vin->info->scaler &&\n\t\t    rvin_group_id_to_master(vin->id) == vin->id)\n\t\t\tvin->scaler = vin->info->scaler;\n\t} else {\n\t\tret = rvin_parallel_init(vin);\n\n\t\tif (vin->info->scaler)\n\t\t\tvin->scaler = vin->info->scaler;\n\t}\n\n\tif (ret) {\n\t\trvin_dma_unregister(vin);\n\t\treturn ret;\n\t}\n\n\tpm_suspend_ignore_children(&pdev->dev, true);\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic void rcar_vin_remove(struct platform_device *pdev)\n{\n\tstruct rvin_dev *vin = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\trvin_v4l2_unregister(vin);\n\n\tif (vin->info->use_isp)\n\t\trvin_isp_cleanup(vin);\n\telse if (vin->info->use_mc)\n\t\trvin_csi2_cleanup(vin);\n\telse\n\t\trvin_parallel_cleanup(vin);\n\n\trvin_dma_unregister(vin);\n}\n\nstatic SIMPLE_DEV_PM_OPS(rvin_pm_ops, rvin_suspend, rvin_resume);\n\nstatic struct platform_driver rcar_vin_driver = {\n\t.driver = {\n\t\t.name = \"rcar-vin\",\n\t\t.suppress_bind_attrs = true,\n\t\t.pm = &rvin_pm_ops,\n\t\t.of_match_table = rvin_of_id_table,\n\t},\n\t.probe = rcar_vin_probe,\n\t.remove_new = rcar_vin_remove,\n};\n\nmodule_platform_driver(rcar_vin_driver);\n\nMODULE_AUTHOR(\"Niklas S\u00f6derlund <niklas.soderlund@ragnatech.se>\");\nMODULE_DESCRIPTION(\"Renesas R-Car VIN camera host driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}