{
  "module_name": "rcar_drif.c",
  "hash_id": "9c8ba6d77973e9c4d611e877ba7d48d294072a16260dc041b7bf93928998db01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/rcar_drif.c",
  "human_readable_source": "\n \n\n \n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/ioctl.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n\n \n#define RCAR_DRIF_SITMDR1\t\t\t0x00\n#define RCAR_DRIF_SITMDR2\t\t\t0x04\n#define RCAR_DRIF_SITMDR3\t\t\t0x08\n#define RCAR_DRIF_SIRMDR1\t\t\t0x10\n#define RCAR_DRIF_SIRMDR2\t\t\t0x14\n#define RCAR_DRIF_SIRMDR3\t\t\t0x18\n#define RCAR_DRIF_SICTR\t\t\t\t0x28\n#define RCAR_DRIF_SIFCTR\t\t\t0x30\n#define RCAR_DRIF_SISTR\t\t\t\t0x40\n#define RCAR_DRIF_SIIER\t\t\t\t0x44\n#define RCAR_DRIF_SIRFDR\t\t\t0x60\n\n#define RCAR_DRIF_RFOVF\t\t\tBIT(3)\t \n#define RCAR_DRIF_RFUDF\t\t\tBIT(4)\t \n#define RCAR_DRIF_RFSERR\t\tBIT(5)\t \n#define RCAR_DRIF_REOF\t\t\tBIT(7)\t \n#define RCAR_DRIF_RDREQ\t\t\tBIT(12)  \n#define RCAR_DRIF_RFFUL\t\t\tBIT(13)\t \n\n \n#define RCAR_DRIF_SIRMDR1_SYNCMD_FRAME\t\t(0 << 28)\n#define RCAR_DRIF_SIRMDR1_SYNCMD_LR\t\t(3 << 28)\n\n#define RCAR_DRIF_SIRMDR1_SYNCAC_POL_HIGH\t(0 << 25)\n#define RCAR_DRIF_SIRMDR1_SYNCAC_POL_LOW\t(1 << 25)\n\n#define RCAR_DRIF_SIRMDR1_MSB_FIRST\t\t(0 << 24)\n#define RCAR_DRIF_SIRMDR1_LSB_FIRST\t\t(1 << 24)\n\n#define RCAR_DRIF_SIRMDR1_DTDL_0\t\t(0 << 20)\n#define RCAR_DRIF_SIRMDR1_DTDL_1\t\t(1 << 20)\n#define RCAR_DRIF_SIRMDR1_DTDL_2\t\t(2 << 20)\n#define RCAR_DRIF_SIRMDR1_DTDL_0PT5\t\t(5 << 20)\n#define RCAR_DRIF_SIRMDR1_DTDL_1PT5\t\t(6 << 20)\n\n#define RCAR_DRIF_SIRMDR1_SYNCDL_0\t\t(0 << 20)\n#define RCAR_DRIF_SIRMDR1_SYNCDL_1\t\t(1 << 20)\n#define RCAR_DRIF_SIRMDR1_SYNCDL_2\t\t(2 << 20)\n#define RCAR_DRIF_SIRMDR1_SYNCDL_3\t\t(3 << 20)\n#define RCAR_DRIF_SIRMDR1_SYNCDL_0PT5\t\t(5 << 20)\n#define RCAR_DRIF_SIRMDR1_SYNCDL_1PT5\t\t(6 << 20)\n\n#define RCAR_DRIF_MDR_GRPCNT(n)\t\t\t(((n) - 1) << 30)\n#define RCAR_DRIF_MDR_BITLEN(n)\t\t\t(((n) - 1) << 24)\n#define RCAR_DRIF_MDR_WDCNT(n)\t\t\t(((n) - 1) << 16)\n\n \n#define RCAR_DRIF_SITMDR1_PCON\t\t\tBIT(30)\n\n#define RCAR_DRIF_SICTR_RX_RISING_EDGE\t\tBIT(26)\n#define RCAR_DRIF_SICTR_RX_EN\t\t\tBIT(8)\n#define RCAR_DRIF_SICTR_RESET\t\t\tBIT(0)\n\n \n#define RCAR_DRIF_NUM_HWBUFS\t\t\t32\n#define RCAR_DRIF_MAX_DEVS\t\t\t4\n#define RCAR_DRIF_DEFAULT_NUM_HWBUFS\t\t16\n#define RCAR_DRIF_DEFAULT_HWBUF_SIZE\t\t(4 * PAGE_SIZE)\n#define RCAR_DRIF_MAX_CHANNEL\t\t\t2\n#define RCAR_SDR_BUFFER_SIZE\t\t\tSZ_64K\n\n \n#define RCAR_DRIF_BUF_DONE\t\t\tBIT(0)\t \n#define RCAR_DRIF_BUF_OVERFLOW\t\t\tBIT(1)\t \n\n#define to_rcar_drif_buf_pair(sdr, ch_num, idx)\t\t\t\\\n\t(&((sdr)->ch[!(ch_num)]->buf[(idx)]))\n\n#define for_each_rcar_drif_channel(ch, ch_mask)\t\t\t\\\n\tfor_each_set_bit(ch, ch_mask, RCAR_DRIF_MAX_CHANNEL)\n\n \n#define rdrif_dbg(sdr, fmt, arg...)\t\t\t\t\\\n\tdev_dbg(sdr->v4l2_dev.dev, fmt, ## arg)\n\n#define rdrif_err(sdr, fmt, arg...)\t\t\t\t\\\n\tdev_err(sdr->v4l2_dev.dev, fmt, ## arg)\n\n \nstruct rcar_drif_format {\n\tu32\tpixelformat;\n\tu32\tbuffersize;\n\tu32\tbitlen;\n\tu32\twdcnt;\n\tu32\tnum_ch;\n};\n\n \nstatic const struct rcar_drif_format formats[] = {\n\t{\n\t\t.pixelformat\t= V4L2_SDR_FMT_PCU16BE,\n\t\t.buffersize\t= RCAR_SDR_BUFFER_SIZE,\n\t\t.bitlen\t\t= 16,\n\t\t.wdcnt\t\t= 1,\n\t\t.num_ch\t\t= 2,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_SDR_FMT_PCU18BE,\n\t\t.buffersize\t= RCAR_SDR_BUFFER_SIZE,\n\t\t.bitlen\t\t= 18,\n\t\t.wdcnt\t\t= 1,\n\t\t.num_ch\t\t= 2,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_SDR_FMT_PCU20BE,\n\t\t.buffersize\t= RCAR_SDR_BUFFER_SIZE,\n\t\t.bitlen\t\t= 20,\n\t\t.wdcnt\t\t= 1,\n\t\t.num_ch\t\t= 2,\n\t},\n};\n\n \nstruct rcar_drif_frame_buf {\n\t \n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\n \nstruct rcar_drif_graph_ep {\n\tstruct v4l2_subdev *subdev;\t \n};\n\n \nstruct rcar_drif_hwbuf {\n\tvoid *addr;\t\t\t \n\tunsigned int status;\t\t \n};\n\n \nstruct rcar_drif {\n\tstruct rcar_drif_sdr *sdr;\t \n\tstruct platform_device *pdev;\t \n\tvoid __iomem *base;\t\t \n\tresource_size_t start;\t\t \n\tstruct dma_chan *dmach;\t\t \n\tstruct clk *clk;\t\t \n\tstruct rcar_drif_hwbuf buf[RCAR_DRIF_NUM_HWBUFS];  \n\tdma_addr_t dma_handle;\t\t \n\tunsigned int num;\t\t \n\tbool acting_sdr;\t\t \n};\n\n \nstruct rcar_drif_sdr {\n\tstruct device *dev;\t\t \n\tstruct video_device *vdev;\t \n\tstruct v4l2_device v4l2_dev;\t \n\n\t \n\tstruct vb2_queue vb_queue;\n\tstruct list_head queued_bufs;\n\tspinlock_t queued_bufs_lock;\t \n\tspinlock_t dma_lock;\t\t \n\n\tstruct mutex v4l2_mutex;\t \n\tstruct mutex vb_queue_mutex;\t \n\tstruct v4l2_ctrl_handler ctrl_hdl;\t \n\tstruct v4l2_async_notifier notifier;\t \n\tstruct rcar_drif_graph_ep ep;\t \n\n\t \n\tconst struct rcar_drif_format *fmt;\n\n\t \n\tu32 mdr1;\n\n\t \n\tstruct rcar_drif *ch[RCAR_DRIF_MAX_CHANNEL];  \n\tunsigned long hw_ch_mask;\t \n\tunsigned long cur_ch_mask;\t \n\tu32 num_hw_ch;\t\t\t \n\tu32 num_cur_ch;\t\t\t \n\tu32 hwbuf_size;\t\t\t \n\tu32 produced;\t\t\t \n};\n\n \nstatic void rcar_drif_write(struct rcar_drif *ch, u32 offset, u32 data)\n{\n\twritel(data, ch->base + offset);\n}\n\nstatic u32 rcar_drif_read(struct rcar_drif *ch, u32 offset)\n{\n\treturn readl(ch->base + offset);\n}\n\n \nstatic void rcar_drif_release_dmachannels(struct rcar_drif_sdr *sdr)\n{\n\tunsigned int i;\n\n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask)\n\t\tif (sdr->ch[i]->dmach) {\n\t\t\tdma_release_channel(sdr->ch[i]->dmach);\n\t\t\tsdr->ch[i]->dmach = NULL;\n\t\t}\n}\n\n \nstatic int rcar_drif_alloc_dmachannels(struct rcar_drif_sdr *sdr)\n{\n\tstruct dma_slave_config dma_cfg;\n\tunsigned int i;\n\tint ret;\n\n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\n\t\tstruct rcar_drif *ch = sdr->ch[i];\n\n\t\tch->dmach = dma_request_chan(&ch->pdev->dev, \"rx\");\n\t\tif (IS_ERR(ch->dmach)) {\n\t\t\tret = PTR_ERR(ch->dmach);\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\trdrif_err(sdr,\n\t\t\t\t\t  \"ch%u: dma channel req failed: %pe\\n\",\n\t\t\t\t\t  i, ch->dmach);\n\t\t\tch->dmach = NULL;\n\t\t\tgoto dmach_error;\n\t\t}\n\n\t\t \n\t\tmemset(&dma_cfg, 0, sizeof(dma_cfg));\n\t\tdma_cfg.src_addr = (phys_addr_t)(ch->start + RCAR_DRIF_SIRFDR);\n\t\tdma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tret = dmaengine_slave_config(ch->dmach, &dma_cfg);\n\t\tif (ret) {\n\t\t\trdrif_err(sdr, \"ch%u: dma slave config failed\\n\", i);\n\t\t\tgoto dmach_error;\n\t\t}\n\t}\n\treturn 0;\n\ndmach_error:\n\trcar_drif_release_dmachannels(sdr);\n\treturn ret;\n}\n\n \nstatic void rcar_drif_release_queued_bufs(struct rcar_drif_sdr *sdr,\n\t\t\t\t\t  enum vb2_buffer_state state)\n{\n\tstruct rcar_drif_frame_buf *fbuf, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sdr->queued_bufs_lock, flags);\n\tlist_for_each_entry_safe(fbuf, tmp, &sdr->queued_bufs, list) {\n\t\tlist_del(&fbuf->list);\n\t\tvb2_buffer_done(&fbuf->vb.vb2_buf, state);\n\t}\n\tspin_unlock_irqrestore(&sdr->queued_bufs_lock, flags);\n}\n\n \nstatic inline void rcar_drif_set_mdr1(struct rcar_drif_sdr *sdr)\n{\n\tunsigned int i;\n\n\t \n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\n\t\t \n\t\trcar_drif_write(sdr->ch[i], RCAR_DRIF_SITMDR1,\n\t\t\t\tRCAR_DRIF_SITMDR1_PCON);\n\n\t\t \n\t\trcar_drif_write(sdr->ch[i], RCAR_DRIF_SIRMDR1, sdr->mdr1);\n\n\t\trdrif_dbg(sdr, \"ch%u: mdr1 = 0x%08x\",\n\t\t\t  i, rcar_drif_read(sdr->ch[i], RCAR_DRIF_SIRMDR1));\n\t}\n}\n\n \nstatic int rcar_drif_set_format(struct rcar_drif_sdr *sdr)\n{\n\tunsigned int i;\n\n\trdrif_dbg(sdr, \"setfmt: bitlen %u wdcnt %u num_ch %u\\n\",\n\t\t  sdr->fmt->bitlen, sdr->fmt->wdcnt, sdr->fmt->num_ch);\n\n\t \n\tif (sdr->fmt->num_ch > sdr->num_cur_ch) {\n\t\trdrif_err(sdr, \"fmt num_ch %u cur_ch %u mismatch\\n\",\n\t\t\t  sdr->fmt->num_ch, sdr->num_cur_ch);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\n\t\tu32 mdr;\n\n\t\t \n\t\tmdr = RCAR_DRIF_MDR_GRPCNT(2) |\n\t\t\tRCAR_DRIF_MDR_BITLEN(sdr->fmt->bitlen) |\n\t\t\tRCAR_DRIF_MDR_WDCNT(sdr->fmt->wdcnt);\n\t\trcar_drif_write(sdr->ch[i], RCAR_DRIF_SIRMDR2, mdr);\n\n\t\tmdr = RCAR_DRIF_MDR_BITLEN(sdr->fmt->bitlen) |\n\t\t\tRCAR_DRIF_MDR_WDCNT(sdr->fmt->wdcnt);\n\t\trcar_drif_write(sdr->ch[i], RCAR_DRIF_SIRMDR3, mdr);\n\n\t\trdrif_dbg(sdr, \"ch%u: new mdr[2,3] = 0x%08x, 0x%08x\\n\",\n\t\t\t  i, rcar_drif_read(sdr->ch[i], RCAR_DRIF_SIRMDR2),\n\t\t\t  rcar_drif_read(sdr->ch[i], RCAR_DRIF_SIRMDR3));\n\t}\n\treturn 0;\n}\n\n \nstatic void rcar_drif_release_buf(struct rcar_drif_sdr *sdr)\n{\n\tunsigned int i;\n\n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\n\t\tstruct rcar_drif *ch = sdr->ch[i];\n\n\t\t \n\t\tif (ch->buf[0].addr) {\n\t\t\tdma_free_coherent(&ch->pdev->dev,\n\t\t\t\tsdr->hwbuf_size * RCAR_DRIF_NUM_HWBUFS,\n\t\t\t\tch->buf[0].addr, ch->dma_handle);\n\t\t\tch->buf[0].addr = NULL;\n\t\t}\n\t}\n}\n\n \nstatic int rcar_drif_request_buf(struct rcar_drif_sdr *sdr)\n{\n\tint ret = -ENOMEM;\n\tunsigned int i, j;\n\tvoid *addr;\n\n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\n\t\tstruct rcar_drif *ch = sdr->ch[i];\n\n\t\t \n\t\taddr = dma_alloc_coherent(&ch->pdev->dev,\n\t\t\t\tsdr->hwbuf_size * RCAR_DRIF_NUM_HWBUFS,\n\t\t\t\t&ch->dma_handle, GFP_KERNEL);\n\t\tif (!addr) {\n\t\t\trdrif_err(sdr,\n\t\t\t\"ch%u: dma alloc failed. num hwbufs %u size %u\\n\",\n\t\t\ti, RCAR_DRIF_NUM_HWBUFS, sdr->hwbuf_size);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < RCAR_DRIF_NUM_HWBUFS; j++) {\n\t\t\tch->buf[j].addr = addr + (j * sdr->hwbuf_size);\n\t\t\tch->buf[j].status = 0;\n\t\t}\n\t}\n\treturn 0;\nerror:\n\treturn ret;\n}\n\n \nstatic int rcar_drif_queue_setup(struct vb2_queue *vq,\n\t\t\tunsigned int *num_buffers, unsigned int *num_planes,\n\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct rcar_drif_sdr *sdr = vb2_get_drv_priv(vq);\n\n\t \n\tif (vq->num_buffers + *num_buffers < 16)\n\t\t*num_buffers = 16 - vq->num_buffers;\n\n\t*num_planes = 1;\n\tsizes[0] = PAGE_ALIGN(sdr->fmt->buffersize);\n\trdrif_dbg(sdr, \"num_bufs %d sizes[0] %d\\n\", *num_buffers, sizes[0]);\n\n\treturn 0;\n}\n\n \nstatic void rcar_drif_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct rcar_drif_sdr *sdr = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct rcar_drif_frame_buf *fbuf =\n\t\t\tcontainer_of(vbuf, struct rcar_drif_frame_buf, vb);\n\tunsigned long flags;\n\n\trdrif_dbg(sdr, \"buf_queue idx %u\\n\", vb->index);\n\tspin_lock_irqsave(&sdr->queued_bufs_lock, flags);\n\tlist_add_tail(&fbuf->list, &sdr->queued_bufs);\n\tspin_unlock_irqrestore(&sdr->queued_bufs_lock, flags);\n}\n\n \nstatic struct rcar_drif_frame_buf *\nrcar_drif_get_fbuf(struct rcar_drif_sdr *sdr)\n{\n\tstruct rcar_drif_frame_buf *fbuf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sdr->queued_bufs_lock, flags);\n\tfbuf = list_first_entry_or_null(&sdr->queued_bufs, struct\n\t\t\t\t\trcar_drif_frame_buf, list);\n\tif (!fbuf) {\n\t\t \n\t\trdrif_dbg(sdr, \"\\napp late: prod %u\\n\", sdr->produced);\n\t\tspin_unlock_irqrestore(&sdr->queued_bufs_lock, flags);\n\t\treturn NULL;\n\t}\n\tlist_del(&fbuf->list);\n\tspin_unlock_irqrestore(&sdr->queued_bufs_lock, flags);\n\n\treturn fbuf;\n}\n\n \nstatic inline bool rcar_drif_bufs_done(struct rcar_drif_hwbuf **buf)\n{\n\treturn (buf[0]->status & buf[1]->status & RCAR_DRIF_BUF_DONE);\n}\n\nstatic inline bool rcar_drif_bufs_overflow(struct rcar_drif_hwbuf **buf)\n{\n\treturn ((buf[0]->status | buf[1]->status) & RCAR_DRIF_BUF_OVERFLOW);\n}\n\nstatic inline void rcar_drif_bufs_clear(struct rcar_drif_hwbuf **buf,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < RCAR_DRIF_MAX_CHANNEL; i++)\n\t\tbuf[i]->status &= ~bit;\n}\n\n \nstatic void rcar_drif_channel_complete(struct rcar_drif *ch, u32 idx)\n{\n\tu32 str;\n\n\tch->buf[idx].status |= RCAR_DRIF_BUF_DONE;\n\n\t \n\tstr = rcar_drif_read(ch, RCAR_DRIF_SISTR);\n\tif (unlikely(str & RCAR_DRIF_RFOVF)) {\n\t\t \n\t\trcar_drif_write(ch, RCAR_DRIF_SISTR, str);\n\n\t\t \n\t\tch->buf[idx].status |= RCAR_DRIF_BUF_OVERFLOW;\n\t}\n}\n\n \nstatic void rcar_drif_dma_complete(void *dma_async_param)\n{\n\tstruct rcar_drif *ch = dma_async_param;\n\tstruct rcar_drif_sdr *sdr = ch->sdr;\n\tstruct rcar_drif_hwbuf *buf[RCAR_DRIF_MAX_CHANNEL];\n\tstruct rcar_drif_frame_buf *fbuf;\n\tbool overflow = false;\n\tu32 idx, produced;\n\tunsigned int i;\n\n\tspin_lock(&sdr->dma_lock);\n\n\t \n\tif (!vb2_is_streaming(&sdr->vb_queue)) {\n\t\tspin_unlock(&sdr->dma_lock);\n\t\treturn;\n\t}\n\n\tidx = sdr->produced % RCAR_DRIF_NUM_HWBUFS;\n\trcar_drif_channel_complete(ch, idx);\n\n\tif (sdr->num_cur_ch == RCAR_DRIF_MAX_CHANNEL) {\n\t\tbuf[0] = ch->num ? to_rcar_drif_buf_pair(sdr, ch->num, idx) :\n\t\t\t\t&ch->buf[idx];\n\t\tbuf[1] = ch->num ? &ch->buf[idx] :\n\t\t\t\tto_rcar_drif_buf_pair(sdr, ch->num, idx);\n\n\t\t \n\t\tif (!rcar_drif_bufs_done(buf)) {\n\t\t\tspin_unlock(&sdr->dma_lock);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\trcar_drif_bufs_clear(buf, RCAR_DRIF_BUF_DONE);\n\n\t\tif (rcar_drif_bufs_overflow(buf)) {\n\t\t\toverflow = true;\n\t\t\t \n\t\t\trcar_drif_bufs_clear(buf, RCAR_DRIF_BUF_OVERFLOW);\n\t\t}\n\t} else {\n\t\tbuf[0] = &ch->buf[idx];\n\t\tif (buf[0]->status & RCAR_DRIF_BUF_OVERFLOW) {\n\t\t\toverflow = true;\n\t\t\t \n\t\t\tbuf[0]->status &= ~RCAR_DRIF_BUF_OVERFLOW;\n\t\t}\n\t}\n\n\t \n\tproduced = sdr->produced++;\n\tspin_unlock(&sdr->dma_lock);\n\n\trdrif_dbg(sdr, \"ch%u: prod %u\\n\", ch->num, produced);\n\n\t \n\tfbuf = rcar_drif_get_fbuf(sdr);\n\tif (!fbuf)\n\t\treturn;\n\n\tfor (i = 0; i < RCAR_DRIF_MAX_CHANNEL; i++)\n\t\tmemcpy(vb2_plane_vaddr(&fbuf->vb.vb2_buf, 0) +\n\t\t       i * sdr->hwbuf_size, buf[i]->addr, sdr->hwbuf_size);\n\n\tfbuf->vb.field = V4L2_FIELD_NONE;\n\tfbuf->vb.sequence = produced;\n\tfbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\tvb2_set_plane_payload(&fbuf->vb.vb2_buf, 0, sdr->fmt->buffersize);\n\n\t \n\tvb2_buffer_done(&fbuf->vb.vb2_buf,\n\t\t\toverflow ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n}\n\nstatic int rcar_drif_qbuf(struct rcar_drif *ch)\n{\n\tstruct rcar_drif_sdr *sdr = ch->sdr;\n\tdma_addr_t addr = ch->dma_handle;\n\tstruct dma_async_tx_descriptor *rxd;\n\tdma_cookie_t cookie;\n\tint ret = -EIO;\n\n\t \n\trxd = dmaengine_prep_dma_cyclic(ch->dmach, addr,\n\t\t\t\t\tsdr->hwbuf_size * RCAR_DRIF_NUM_HWBUFS,\n\t\t\t\t\tsdr->hwbuf_size, DMA_DEV_TO_MEM,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!rxd) {\n\t\trdrif_err(sdr, \"ch%u: prep dma cyclic failed\\n\", ch->num);\n\t\treturn ret;\n\t}\n\n\t \n\trxd->callback = rcar_drif_dma_complete;\n\trxd->callback_param = ch;\n\tcookie = dmaengine_submit(rxd);\n\tif (dma_submit_error(cookie)) {\n\t\trdrif_err(sdr, \"ch%u: dma submit failed\\n\", ch->num);\n\t\treturn ret;\n\t}\n\n\tdma_async_issue_pending(ch->dmach);\n\treturn 0;\n}\n\n \nstatic int rcar_drif_enable_rx(struct rcar_drif_sdr *sdr)\n{\n\tunsigned int i;\n\tu32 ctr;\n\tint ret = -EINVAL;\n\n\t \n\n\t \n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\n\t\tctr = rcar_drif_read(sdr->ch[i], RCAR_DRIF_SICTR);\n\t\tctr |= (RCAR_DRIF_SICTR_RX_RISING_EDGE |\n\t\t\t RCAR_DRIF_SICTR_RX_EN);\n\t\trcar_drif_write(sdr->ch[i], RCAR_DRIF_SICTR, ctr);\n\t}\n\n\t \n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\n\t\tret = readl_poll_timeout(sdr->ch[i]->base + RCAR_DRIF_SICTR,\n\t\t\t\tctr, ctr & RCAR_DRIF_SICTR_RX_EN, 7, 100000);\n\t\tif (ret) {\n\t\t\trdrif_err(sdr, \"ch%u: rx en failed. ctr 0x%08x\\n\", i,\n\t\t\t\t  rcar_drif_read(sdr->ch[i], RCAR_DRIF_SICTR));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic void rcar_drif_disable_rx(struct rcar_drif_sdr *sdr)\n{\n\tunsigned int i;\n\tu32 ctr;\n\tint ret;\n\n\t \n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\n\t\tctr = rcar_drif_read(sdr->ch[i], RCAR_DRIF_SICTR);\n\t\tctr &= ~RCAR_DRIF_SICTR_RX_EN;\n\t\trcar_drif_write(sdr->ch[i], RCAR_DRIF_SICTR, ctr);\n\t}\n\n\t \n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\n\t\tret = readl_poll_timeout(sdr->ch[i]->base + RCAR_DRIF_SICTR,\n\t\t\t\tctr, !(ctr & RCAR_DRIF_SICTR_RX_EN), 7, 100000);\n\t\tif (ret)\n\t\t\tdev_warn(&sdr->vdev->dev,\n\t\t\t\"ch%u: failed to disable rx. ctr 0x%08x\\n\",\n\t\t\ti, rcar_drif_read(sdr->ch[i], RCAR_DRIF_SICTR));\n\t}\n}\n\n \nstatic void rcar_drif_stop_channel(struct rcar_drif *ch)\n{\n\t \n\trcar_drif_write(ch, RCAR_DRIF_SIIER, 0x00000000);\n\n\t \n\tdmaengine_terminate_sync(ch->dmach);\n}\n\n \nstatic void rcar_drif_stop(struct rcar_drif_sdr *sdr)\n{\n\tunsigned int i;\n\n\t \n\trcar_drif_disable_rx(sdr);\n\n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask)\n\t\trcar_drif_stop_channel(sdr->ch[i]);\n}\n\n \nstatic int rcar_drif_start_channel(struct rcar_drif *ch)\n{\n\tstruct rcar_drif_sdr *sdr = ch->sdr;\n\tu32 ctr, str;\n\tint ret;\n\n\t \n\trcar_drif_write(ch, RCAR_DRIF_SICTR, RCAR_DRIF_SICTR_RESET);\n\tret = readl_poll_timeout(ch->base + RCAR_DRIF_SICTR, ctr,\n\t\t\t\t !(ctr & RCAR_DRIF_SICTR_RESET), 7, 100000);\n\tif (ret) {\n\t\trdrif_err(sdr, \"ch%u: failed to reset rx. ctr 0x%08x\\n\",\n\t\t\t  ch->num, rcar_drif_read(ch, RCAR_DRIF_SICTR));\n\t\treturn ret;\n\t}\n\n\t \n\tret = rcar_drif_qbuf(ch);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstr = RCAR_DRIF_RFFUL | RCAR_DRIF_REOF | RCAR_DRIF_RFSERR |\n\t\tRCAR_DRIF_RFUDF | RCAR_DRIF_RFOVF;\n\trcar_drif_write(ch, RCAR_DRIF_SISTR, str);\n\n\t \n\trcar_drif_write(ch, RCAR_DRIF_SIIER, 0x00009000);\n\n\treturn ret;\n}\n\n \nstatic int rcar_drif_start(struct rcar_drif_sdr *sdr)\n{\n\tunsigned long enabled = 0;\n\tunsigned int i;\n\tint ret;\n\n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\n\t\tret = rcar_drif_start_channel(sdr->ch[i]);\n\t\tif (ret)\n\t\t\tgoto start_error;\n\t\tenabled |= BIT(i);\n\t}\n\n\tret = rcar_drif_enable_rx(sdr);\n\tif (ret)\n\t\tgoto enable_error;\n\n\tsdr->produced = 0;\n\treturn ret;\n\nenable_error:\n\trcar_drif_disable_rx(sdr);\nstart_error:\n\tfor_each_rcar_drif_channel(i, &enabled)\n\t\trcar_drif_stop_channel(sdr->ch[i]);\n\n\treturn ret;\n}\n\n \nstatic int rcar_drif_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct rcar_drif_sdr *sdr = vb2_get_drv_priv(vq);\n\tunsigned long enabled = 0;\n\tunsigned int i;\n\tint ret;\n\n\tmutex_lock(&sdr->v4l2_mutex);\n\n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask) {\n\t\tret = clk_prepare_enable(sdr->ch[i]->clk);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tenabled |= BIT(i);\n\t}\n\n\t \n\trcar_drif_set_mdr1(sdr);\n\n\t \n\tret = rcar_drif_set_format(sdr);\n\tif (ret)\n\t\tgoto error;\n\n\tif (sdr->num_cur_ch == RCAR_DRIF_MAX_CHANNEL)\n\t\tsdr->hwbuf_size = sdr->fmt->buffersize / RCAR_DRIF_MAX_CHANNEL;\n\telse\n\t\tsdr->hwbuf_size = sdr->fmt->buffersize;\n\n\trdrif_dbg(sdr, \"num hwbufs %u, hwbuf_size %u\\n\",\n\t\tRCAR_DRIF_NUM_HWBUFS, sdr->hwbuf_size);\n\n\t \n\tret = rcar_drif_alloc_dmachannels(sdr);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = rcar_drif_request_buf(sdr);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = rcar_drif_start(sdr);\n\tif (ret)\n\t\tgoto error;\n\n\tmutex_unlock(&sdr->v4l2_mutex);\n\n\treturn ret;\n\nerror:\n\trcar_drif_release_queued_bufs(sdr, VB2_BUF_STATE_QUEUED);\n\trcar_drif_release_buf(sdr);\n\trcar_drif_release_dmachannels(sdr);\n\tfor_each_rcar_drif_channel(i, &enabled)\n\t\tclk_disable_unprepare(sdr->ch[i]->clk);\n\n\tmutex_unlock(&sdr->v4l2_mutex);\n\n\treturn ret;\n}\n\n \nstatic void rcar_drif_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct rcar_drif_sdr *sdr = vb2_get_drv_priv(vq);\n\tunsigned int i;\n\n\tmutex_lock(&sdr->v4l2_mutex);\n\n\t \n\trcar_drif_stop(sdr);\n\n\t \n\trcar_drif_release_queued_bufs(sdr, VB2_BUF_STATE_ERROR);\n\n\t \n\trcar_drif_release_buf(sdr);\n\n\t \n\trcar_drif_release_dmachannels(sdr);\n\n\tfor_each_rcar_drif_channel(i, &sdr->cur_ch_mask)\n\t\tclk_disable_unprepare(sdr->ch[i]->clk);\n\n\tmutex_unlock(&sdr->v4l2_mutex);\n}\n\n \nstatic const struct vb2_ops rcar_drif_vb2_ops = {\n\t.queue_setup            = rcar_drif_queue_setup,\n\t.buf_queue              = rcar_drif_buf_queue,\n\t.start_streaming        = rcar_drif_start_streaming,\n\t.stop_streaming         = rcar_drif_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic int rcar_drif_querycap(struct file *file, void *fh,\n\t\t\t      struct v4l2_capability *cap)\n{\n\tstruct rcar_drif_sdr *sdr = video_drvdata(file);\n\n\tstrscpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrscpy(cap->card, sdr->vdev->name, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"platform:%s\",\n\t\t sdr->vdev->name);\n\n\treturn 0;\n}\n\nstatic int rcar_drif_set_default_format(struct rcar_drif_sdr *sdr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\t \n\t\tif (sdr->num_hw_ch == formats[i].num_ch) {\n\t\t\tsdr->fmt = &formats[i];\n\t\t\tsdr->cur_ch_mask = sdr->hw_ch_mask;\n\t\t\tsdr->num_cur_ch = sdr->num_hw_ch;\n\t\t\tdev_dbg(sdr->dev, \"default fmt[%u]: mask %lu num %u\\n\",\n\t\t\t\ti, sdr->cur_ch_mask, sdr->num_cur_ch);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int rcar_drif_enum_fmt_sdr_cap(struct file *file, void *priv,\n\t\t\t\t      struct v4l2_fmtdesc *f)\n{\n\tif (f->index >= ARRAY_SIZE(formats))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[f->index].pixelformat;\n\n\treturn 0;\n}\n\nstatic int rcar_drif_g_fmt_sdr_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct rcar_drif_sdr *sdr = video_drvdata(file);\n\n\tf->fmt.sdr.pixelformat = sdr->fmt->pixelformat;\n\tf->fmt.sdr.buffersize = sdr->fmt->buffersize;\n\n\treturn 0;\n}\n\nstatic int rcar_drif_s_fmt_sdr_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct rcar_drif_sdr *sdr = video_drvdata(file);\n\tstruct vb2_queue *q = &sdr->vb_queue;\n\tunsigned int i;\n\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(formats))\n\t\ti = 0;\t\t \n\n\tsdr->fmt = &formats[i];\n\tf->fmt.sdr.pixelformat = sdr->fmt->pixelformat;\n\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\tmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\n\n\t \n\tif (formats[i].num_ch < sdr->num_hw_ch) {\n\t\tsdr->cur_ch_mask = BIT(0);\n\t\tsdr->num_cur_ch = formats[i].num_ch;\n\t} else {\n\t\tsdr->cur_ch_mask = sdr->hw_ch_mask;\n\t\tsdr->num_cur_ch = sdr->num_hw_ch;\n\t}\n\n\trdrif_dbg(sdr, \"cur: idx %u mask %lu num %u\\n\",\n\t\t  i, sdr->cur_ch_mask, sdr->num_cur_ch);\n\n\treturn 0;\n}\n\nstatic int rcar_drif_try_fmt_sdr_cap(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_format *f)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\tmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\n\n\treturn 0;\n}\n\n \nstatic int rcar_drif_enum_freq_bands(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_frequency_band *band)\n{\n\tstruct rcar_drif_sdr *sdr = video_drvdata(file);\n\n\treturn v4l2_subdev_call(sdr->ep.subdev, tuner, enum_freq_bands, band);\n}\n\nstatic int rcar_drif_g_frequency(struct file *file, void *priv,\n\t\t\t\t struct v4l2_frequency *f)\n{\n\tstruct rcar_drif_sdr *sdr = video_drvdata(file);\n\n\treturn v4l2_subdev_call(sdr->ep.subdev, tuner, g_frequency, f);\n}\n\nstatic int rcar_drif_s_frequency(struct file *file, void *priv,\n\t\t\t\t const struct v4l2_frequency *f)\n{\n\tstruct rcar_drif_sdr *sdr = video_drvdata(file);\n\n\treturn v4l2_subdev_call(sdr->ep.subdev, tuner, s_frequency, f);\n}\n\nstatic int rcar_drif_g_tuner(struct file *file, void *priv,\n\t\t\t     struct v4l2_tuner *vt)\n{\n\tstruct rcar_drif_sdr *sdr = video_drvdata(file);\n\n\treturn v4l2_subdev_call(sdr->ep.subdev, tuner, g_tuner, vt);\n}\n\nstatic int rcar_drif_s_tuner(struct file *file, void *priv,\n\t\t\t     const struct v4l2_tuner *vt)\n{\n\tstruct rcar_drif_sdr *sdr = video_drvdata(file);\n\n\treturn v4l2_subdev_call(sdr->ep.subdev, tuner, s_tuner, vt);\n}\n\nstatic const struct v4l2_ioctl_ops rcar_drif_ioctl_ops = {\n\t.vidioc_querycap          = rcar_drif_querycap,\n\n\t.vidioc_enum_fmt_sdr_cap  = rcar_drif_enum_fmt_sdr_cap,\n\t.vidioc_g_fmt_sdr_cap     = rcar_drif_g_fmt_sdr_cap,\n\t.vidioc_s_fmt_sdr_cap     = rcar_drif_s_fmt_sdr_cap,\n\t.vidioc_try_fmt_sdr_cap   = rcar_drif_try_fmt_sdr_cap,\n\n\t.vidioc_reqbufs           = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs       = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf       = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf          = vb2_ioctl_querybuf,\n\t.vidioc_qbuf              = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf             = vb2_ioctl_dqbuf,\n\n\t.vidioc_streamon          = vb2_ioctl_streamon,\n\t.vidioc_streamoff         = vb2_ioctl_streamoff,\n\n\t.vidioc_s_frequency       = rcar_drif_s_frequency,\n\t.vidioc_g_frequency       = rcar_drif_g_frequency,\n\t.vidioc_s_tuner\t\t  = rcar_drif_s_tuner,\n\t.vidioc_g_tuner\t\t  = rcar_drif_g_tuner,\n\t.vidioc_enum_freq_bands   = rcar_drif_enum_freq_bands,\n\t.vidioc_subscribe_event   = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_log_status        = v4l2_ctrl_log_status,\n};\n\nstatic const struct v4l2_file_operations rcar_drif_fops = {\n\t.owner                    = THIS_MODULE,\n\t.open                     = v4l2_fh_open,\n\t.release                  = vb2_fop_release,\n\t.read                     = vb2_fop_read,\n\t.poll                     = vb2_fop_poll,\n\t.mmap                     = vb2_fop_mmap,\n\t.unlocked_ioctl           = video_ioctl2,\n};\n\nstatic int rcar_drif_sdr_register(struct rcar_drif_sdr *sdr)\n{\n\tint ret;\n\n\t \n\tsdr->vdev = video_device_alloc();\n\tif (!sdr->vdev)\n\t\treturn -ENOMEM;\n\n\tsnprintf(sdr->vdev->name, sizeof(sdr->vdev->name), \"R-Car DRIF\");\n\tsdr->vdev->fops = &rcar_drif_fops;\n\tsdr->vdev->ioctl_ops = &rcar_drif_ioctl_ops;\n\tsdr->vdev->release = video_device_release;\n\tsdr->vdev->lock = &sdr->v4l2_mutex;\n\tsdr->vdev->queue = &sdr->vb_queue;\n\tsdr->vdev->queue->lock = &sdr->vb_queue_mutex;\n\tsdr->vdev->ctrl_handler = &sdr->ctrl_hdl;\n\tsdr->vdev->v4l2_dev = &sdr->v4l2_dev;\n\tsdr->vdev->device_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_TUNER |\n\t\tV4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\tvideo_set_drvdata(sdr->vdev, sdr);\n\n\t \n\tret = video_register_device(sdr->vdev, VFL_TYPE_SDR, -1);\n\tif (ret) {\n\t\tvideo_device_release(sdr->vdev);\n\t\tsdr->vdev = NULL;\n\t\tdev_err(sdr->dev, \"failed video_register_device (%d)\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic void rcar_drif_sdr_unregister(struct rcar_drif_sdr *sdr)\n{\n\tvideo_unregister_device(sdr->vdev);\n\tsdr->vdev = NULL;\n}\n\n \nstatic int rcar_drif_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t   struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_async_connection *asd)\n{\n\tstruct rcar_drif_sdr *sdr =\n\t\tcontainer_of(notifier, struct rcar_drif_sdr, notifier);\n\n\tv4l2_set_subdev_hostdata(subdev, sdr);\n\tsdr->ep.subdev = subdev;\n\trdrif_dbg(sdr, \"bound asd %s\\n\", subdev->name);\n\n\treturn 0;\n}\n\n \nstatic void rcar_drif_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\t   struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_async_connection *asd)\n{\n\tstruct rcar_drif_sdr *sdr =\n\t\tcontainer_of(notifier, struct rcar_drif_sdr, notifier);\n\n\tif (sdr->ep.subdev != subdev) {\n\t\trdrif_err(sdr, \"subdev %s is not bound\\n\", subdev->name);\n\t\treturn;\n\t}\n\n\t \n\tv4l2_ctrl_handler_free(&sdr->ctrl_hdl);\n\tsdr->v4l2_dev.ctrl_handler = NULL;\n\tsdr->ep.subdev = NULL;\n\n\trcar_drif_sdr_unregister(sdr);\n\trdrif_dbg(sdr, \"unbind asd %s\\n\", subdev->name);\n}\n\n \nstatic int rcar_drif_notify_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct rcar_drif_sdr *sdr =\n\t\tcontainer_of(notifier, struct rcar_drif_sdr, notifier);\n\tint ret;\n\n\t \n\tret = v4l2_ctrl_handler_init(&sdr->ctrl_hdl, 10);\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\tsdr->v4l2_dev.ctrl_handler = &sdr->ctrl_hdl;\n\tret = v4l2_device_register_subdev_nodes(&sdr->v4l2_dev);\n\tif (ret) {\n\t\trdrif_err(sdr, \"failed: register subdev nodes ret %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = v4l2_ctrl_add_handler(&sdr->ctrl_hdl,\n\t\t\t\t    sdr->ep.subdev->ctrl_handler, NULL, true);\n\tif (ret) {\n\t\trdrif_err(sdr, \"failed: ctrl add hdlr ret %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = rcar_drif_sdr_register(sdr);\n\tif (ret)\n\t\tgoto error;\n\n\treturn ret;\n\nerror:\n\tv4l2_ctrl_handler_free(&sdr->ctrl_hdl);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_async_notifier_operations rcar_drif_notify_ops = {\n\t.bound = rcar_drif_notify_bound,\n\t.unbind = rcar_drif_notify_unbind,\n\t.complete = rcar_drif_notify_complete,\n};\n\n \nstatic void rcar_drif_get_ep_properties(struct rcar_drif_sdr *sdr,\n\t\t\t\t\tstruct fwnode_handle *fwnode)\n{\n\tu32 val;\n\n\t \n\tsdr->mdr1 = RCAR_DRIF_SIRMDR1_SYNCMD_LR | RCAR_DRIF_SIRMDR1_MSB_FIRST |\n\t\tRCAR_DRIF_SIRMDR1_DTDL_1 | RCAR_DRIF_SIRMDR1_SYNCDL_0;\n\n\t \n\tif (!fwnode_property_read_u32(fwnode, \"sync-active\", &val))\n\t\tsdr->mdr1 |= val ? RCAR_DRIF_SIRMDR1_SYNCAC_POL_HIGH :\n\t\t\tRCAR_DRIF_SIRMDR1_SYNCAC_POL_LOW;\n\telse\n\t\tsdr->mdr1 |= RCAR_DRIF_SIRMDR1_SYNCAC_POL_HIGH;  \n\n\tdev_dbg(sdr->dev, \"mdr1 0x%08x\\n\", sdr->mdr1);\n}\n\n \nstatic int rcar_drif_parse_subdevs(struct rcar_drif_sdr *sdr)\n{\n\tstruct v4l2_async_notifier *notifier = &sdr->notifier;\n\tstruct fwnode_handle *fwnode, *ep;\n\tstruct v4l2_async_connection *asd;\n\n\tv4l2_async_nf_init(&sdr->notifier, &sdr->v4l2_dev);\n\n\tep = fwnode_graph_get_next_endpoint(of_fwnode_handle(sdr->dev->of_node),\n\t\t\t\t\t    NULL);\n\tif (!ep)\n\t\treturn 0;\n\n\t \n\trcar_drif_get_ep_properties(sdr, ep);\n\n\tfwnode = fwnode_graph_get_remote_port_parent(ep);\n\tfwnode_handle_put(ep);\n\tif (!fwnode) {\n\t\tdev_warn(sdr->dev, \"bad remote port parent\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tasd = v4l2_async_nf_add_fwnode(notifier, fwnode,\n\t\t\t\t       struct v4l2_async_connection);\n\tfwnode_handle_put(fwnode);\n\tif (IS_ERR(asd))\n\t\treturn PTR_ERR(asd);\n\n\treturn 0;\n}\n\n \nstatic bool rcar_drif_primary_bond(struct platform_device *pdev)\n{\n\treturn of_property_read_bool(pdev->dev.of_node, \"renesas,primary-bond\");\n}\n\n \nstatic struct device_node *rcar_drif_bond_enabled(struct platform_device *p)\n{\n\tstruct device_node *np;\n\n\tnp = of_parse_phandle(p->dev.of_node, \"renesas,bonding\", 0);\n\tif (np && of_device_is_available(np))\n\t\treturn np;\n\n\treturn NULL;\n}\n\n \nstatic int rcar_drif_bond_available(struct rcar_drif_sdr *sdr,\n\t\t\t\t    struct device_node *np)\n{\n\tstruct platform_device *pdev;\n\tstruct rcar_drif *ch;\n\tint ret = 0;\n\n\tpdev = of_find_device_by_node(np);\n\tif (!pdev) {\n\t\tdev_err(sdr->dev, \"failed to get bonded device from node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdevice_lock(&pdev->dev);\n\tch = platform_get_drvdata(pdev);\n\tif (ch) {\n\t\t \n\t\tch->sdr = sdr;\n\n\t\t \n\t\tsdr->ch[ch->num] = ch;\n\t\tsdr->hw_ch_mask |= BIT(ch->num);\n\t} else {\n\t\t \n\t\tdev_info(sdr->dev, \"defer probe\\n\");\n\t\tret = -EPROBE_DEFER;\n\t}\n\tdevice_unlock(&pdev->dev);\n\n\tput_device(&pdev->dev);\n\n\treturn ret;\n}\n\n \nstatic int rcar_drif_sdr_probe(struct rcar_drif_sdr *sdr)\n{\n\tint ret;\n\n\t \n\tret = rcar_drif_set_default_format(sdr);\n\tif (ret) {\n\t\tdev_err(sdr->dev, \"failed to set default format\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tsdr->hwbuf_size = RCAR_DRIF_DEFAULT_HWBUF_SIZE;\n\n\tmutex_init(&sdr->v4l2_mutex);\n\tmutex_init(&sdr->vb_queue_mutex);\n\tspin_lock_init(&sdr->queued_bufs_lock);\n\tspin_lock_init(&sdr->dma_lock);\n\tINIT_LIST_HEAD(&sdr->queued_bufs);\n\n\t \n\tsdr->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\n\tsdr->vb_queue.io_modes = VB2_READ | VB2_MMAP | VB2_DMABUF;\n\tsdr->vb_queue.drv_priv = sdr;\n\tsdr->vb_queue.buf_struct_size = sizeof(struct rcar_drif_frame_buf);\n\tsdr->vb_queue.ops = &rcar_drif_vb2_ops;\n\tsdr->vb_queue.mem_ops = &vb2_vmalloc_memops;\n\tsdr->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\n\t \n\tret = vb2_queue_init(&sdr->vb_queue);\n\tif (ret) {\n\t\tdev_err(sdr->dev, \"failed: vb2_queue_init ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = v4l2_device_register(sdr->dev, &sdr->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(sdr->dev, \"failed: v4l2_device_register ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = rcar_drif_parse_subdevs(sdr);\n\tif (ret)\n\t\tgoto error;\n\n\tsdr->notifier.ops = &rcar_drif_notify_ops;\n\n\t \n\tret = v4l2_async_nf_register(&sdr->notifier);\n\tif (ret < 0) {\n\t\tdev_err(sdr->dev, \"failed: notifier register ret %d\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\n\treturn ret;\n\ncleanup:\n\tv4l2_async_nf_cleanup(&sdr->notifier);\nerror:\n\tv4l2_device_unregister(&sdr->v4l2_dev);\n\n\treturn ret;\n}\n\n \nstatic void rcar_drif_sdr_remove(struct rcar_drif_sdr *sdr)\n{\n\tv4l2_async_nf_unregister(&sdr->notifier);\n\tv4l2_async_nf_cleanup(&sdr->notifier);\n\tv4l2_device_unregister(&sdr->v4l2_dev);\n}\n\n \nstatic int rcar_drif_probe(struct platform_device *pdev)\n{\n\tstruct rcar_drif_sdr *sdr;\n\tstruct device_node *np;\n\tstruct rcar_drif *ch;\n\tstruct resource\t*res;\n\tint ret;\n\n\t \n\tch = devm_kzalloc(&pdev->dev, sizeof(*ch), GFP_KERNEL);\n\tif (!ch)\n\t\treturn -ENOMEM;\n\n\tch->pdev = pdev;\n\n\t \n\tch->clk = devm_clk_get(&pdev->dev, \"fck\");\n\tif (IS_ERR(ch->clk)) {\n\t\tret = PTR_ERR(ch->clk);\n\t\tdev_err(&pdev->dev, \"clk get failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tch->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(ch->base))\n\t\treturn PTR_ERR(ch->base);\n\n\tch->start = res->start;\n\tplatform_set_drvdata(pdev, ch);\n\n\t \n\tnp = rcar_drif_bond_enabled(pdev);\n\tif (np) {\n\t\t \n\t\tif (!rcar_drif_primary_bond(pdev)) {\n\t\t\tch->num = 1;\t \n\t\t\tof_node_put(np);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tsdr = devm_kzalloc(&pdev->dev, sizeof(*sdr), GFP_KERNEL);\n\tif (!sdr) {\n\t\tof_node_put(np);\n\t\treturn -ENOMEM;\n\t}\n\tch->sdr = sdr;\n\tsdr->dev = &pdev->dev;\n\n\t \n\tsdr->ch[ch->num] = ch;\n\tsdr->hw_ch_mask = BIT(ch->num);\n\tif (np) {\n\t\t \n\t\tret = rcar_drif_bond_available(sdr, np);\n\t\tof_node_put(np);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tsdr->num_hw_ch = hweight_long(sdr->hw_ch_mask);\n\n\treturn rcar_drif_sdr_probe(sdr);\n}\n\n \nstatic void rcar_drif_remove(struct platform_device *pdev)\n{\n\tstruct rcar_drif *ch = platform_get_drvdata(pdev);\n\tstruct rcar_drif_sdr *sdr = ch->sdr;\n\n\t \n\tif (ch->num)\n\t\treturn;\n\n\t \n\trcar_drif_sdr_remove(sdr);\n}\n\n \nstatic int __maybe_unused rcar_drif_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int __maybe_unused rcar_drif_resume(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(rcar_drif_pm_ops, rcar_drif_suspend,\n\t\t\t rcar_drif_resume);\n\nstatic const struct of_device_id rcar_drif_of_table[] = {\n\t{ .compatible = \"renesas,rcar-gen3-drif\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rcar_drif_of_table);\n\n#define RCAR_DRIF_DRV_NAME \"rcar_drif\"\nstatic struct platform_driver rcar_drif_driver = {\n\t.driver = {\n\t\t.name = RCAR_DRIF_DRV_NAME,\n\t\t.of_match_table = rcar_drif_of_table,\n\t\t.pm = &rcar_drif_pm_ops,\n\t\t},\n\t.probe = rcar_drif_probe,\n\t.remove_new = rcar_drif_remove,\n};\n\nmodule_platform_driver(rcar_drif_driver);\n\nMODULE_DESCRIPTION(\"Renesas R-Car Gen3 DRIF driver\");\nMODULE_ALIAS(\"platform:\" RCAR_DRIF_DRV_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ramesh Shanmugasundaram <ramesh.shanmugasundaram@bp.renesas.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}