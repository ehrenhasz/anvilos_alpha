{
  "module_name": "rcar-isp.c",
  "hash_id": "fdf3fc5e47306666c096fa4ab975a27f5cb04e2a55d8b16ab8a9a2555a66aa54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/rcar-isp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <media/mipi-csi2.h>\n#include <media/v4l2-subdev.h>\n\n#define ISPINPUTSEL0_REG\t\t\t\t0x0008\n#define ISPINPUTSEL0_SEL_CSI0\t\t\t\tBIT(31)\n\n#define ISPSTART_REG\t\t\t\t\t0x0014\n#define ISPSTART_START\t\t\t\t\t0xffff\n#define ISPSTART_STOP\t\t\t\t\t0x0000\n\n#define ISPPROCMODE_DT_REG(n)\t\t\t\t(0x1100 + (0x4 * (n)))\n#define ISPPROCMODE_DT_PROC_MODE_VC3(pm)\t\t(((pm) & 0x3f) << 24)\n#define ISPPROCMODE_DT_PROC_MODE_VC2(pm)\t\t(((pm) & 0x3f) << 16)\n#define ISPPROCMODE_DT_PROC_MODE_VC1(pm)\t\t(((pm) & 0x3f) << 8)\n#define ISPPROCMODE_DT_PROC_MODE_VC0(pm)\t\t((pm) & 0x3f)\n\n#define ISPCS_FILTER_ID_CH_REG(n)\t\t\t(0x3000 + (0x0100 * (n)))\n\n#define ISPCS_DT_CODE03_CH_REG(n)\t\t\t(0x3008 + (0x100 * (n)))\n#define ISPCS_DT_CODE03_EN3\t\t\t\tBIT(31)\n#define ISPCS_DT_CODE03_DT3(dt)\t\t\t\t(((dt) & 0x3f) << 24)\n#define ISPCS_DT_CODE03_EN2\t\t\t\tBIT(23)\n#define ISPCS_DT_CODE03_DT2(dt)\t\t\t\t(((dt) & 0x3f) << 16)\n#define ISPCS_DT_CODE03_EN1\t\t\t\tBIT(15)\n#define ISPCS_DT_CODE03_DT1(dt)\t\t\t\t(((dt) & 0x3f) << 8)\n#define ISPCS_DT_CODE03_EN0\t\t\t\tBIT(7)\n#define ISPCS_DT_CODE03_DT0(dt)\t\t\t\t((dt) & 0x3f)\n\nstruct rcar_isp_format {\n\tu32 code;\n\tunsigned int datatype;\n\tunsigned int procmode;\n};\n\nstatic const struct rcar_isp_format rcar_isp_formats[] = {\n\t{\n\t\t.code = MEDIA_BUS_FMT_RGB888_1X24,\n\t\t.datatype = MIPI_CSI2_DT_RGB888,\n\t\t.procmode = 0x15\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_Y10_1X10,\n\t\t.datatype = MIPI_CSI2_DT_RAW10,\n\t\t.procmode = 0x10,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.datatype = MIPI_CSI2_DT_YUV422_8B,\n\t\t.procmode = 0x0c,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_YUYV8_1X16,\n\t\t.datatype = MIPI_CSI2_DT_YUV422_8B,\n\t\t.procmode = 0x0c,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.datatype = MIPI_CSI2_DT_YUV422_8B,\n\t\t.procmode = 0x0c,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_YUYV10_2X10,\n\t\t.datatype = MIPI_CSI2_DT_YUV422_8B,\n\t\t.procmode = 0x0c,\n\t},\n};\n\nstatic const struct rcar_isp_format *risp_code_to_fmt(unsigned int code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rcar_isp_formats); i++) {\n\t\tif (rcar_isp_formats[i].code == code)\n\t\t\treturn &rcar_isp_formats[i];\n\t}\n\n\treturn NULL;\n}\n\nenum rcar_isp_input {\n\tRISP_CSI_INPUT0,\n\tRISP_CSI_INPUT1,\n};\n\nenum rcar_isp_pads {\n\tRCAR_ISP_SINK,\n\tRCAR_ISP_PORT0,\n\tRCAR_ISP_PORT1,\n\tRCAR_ISP_PORT2,\n\tRCAR_ISP_PORT3,\n\tRCAR_ISP_PORT4,\n\tRCAR_ISP_PORT5,\n\tRCAR_ISP_PORT6,\n\tRCAR_ISP_PORT7,\n\tRCAR_ISP_NUM_PADS,\n};\n\nstruct rcar_isp {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct reset_control *rstc;\n\n\tenum rcar_isp_input csi_input;\n\n\tstruct v4l2_subdev subdev;\n\tstruct media_pad pads[RCAR_ISP_NUM_PADS];\n\n\tstruct v4l2_async_notifier notifier;\n\tstruct v4l2_subdev *remote;\n\n\tstruct mutex lock;  \n\tstruct v4l2_mbus_framefmt mf;\n\tint stream_count;\n};\n\nstatic inline struct rcar_isp *sd_to_isp(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct rcar_isp, subdev);\n}\n\nstatic inline struct rcar_isp *notifier_to_isp(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct rcar_isp, notifier);\n}\n\nstatic void risp_write(struct rcar_isp *isp, u32 offset, u32 value)\n{\n\tiowrite32(value, isp->base + offset);\n}\n\nstatic u32 risp_read(struct rcar_isp *isp, u32 offset)\n{\n\treturn ioread32(isp->base + offset);\n}\n\nstatic int risp_power_on(struct rcar_isp *isp)\n{\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(isp->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = reset_control_deassert(isp->rstc);\n\tif (ret < 0) {\n\t\tpm_runtime_put(isp->dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void risp_power_off(struct rcar_isp *isp)\n{\n\treset_control_assert(isp->rstc);\n\tpm_runtime_put(isp->dev);\n}\n\nstatic int risp_start(struct rcar_isp *isp)\n{\n\tconst struct rcar_isp_format *format;\n\tunsigned int vc;\n\tu32 sel_csi = 0;\n\tint ret;\n\n\tformat = risp_code_to_fmt(isp->mf.code);\n\tif (!format) {\n\t\tdev_err(isp->dev, \"Unsupported bus format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = risp_power_on(isp);\n\tif (ret) {\n\t\tdev_err(isp->dev, \"Failed to power on ISP\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (isp->csi_input == RISP_CSI_INPUT1)\n\t\tsel_csi = ISPINPUTSEL0_SEL_CSI0;\n\n\trisp_write(isp, ISPINPUTSEL0_REG,\n\t\t   risp_read(isp, ISPINPUTSEL0_REG) | sel_csi);\n\n\t \n\tfor (vc = 0; vc < 4; vc++) {\n\t\tu8 ch = vc + 4;\n\t\tu8 dt = format->datatype;\n\n\t\trisp_write(isp, ISPCS_FILTER_ID_CH_REG(ch), BIT(vc));\n\t\trisp_write(isp, ISPCS_DT_CODE03_CH_REG(ch),\n\t\t\t   ISPCS_DT_CODE03_EN3 | ISPCS_DT_CODE03_DT3(dt) |\n\t\t\t   ISPCS_DT_CODE03_EN2 | ISPCS_DT_CODE03_DT2(dt) |\n\t\t\t   ISPCS_DT_CODE03_EN1 | ISPCS_DT_CODE03_DT1(dt) |\n\t\t\t   ISPCS_DT_CODE03_EN0 | ISPCS_DT_CODE03_DT0(dt));\n\t}\n\n\t \n\trisp_write(isp, ISPPROCMODE_DT_REG(format->datatype),\n\t\t   ISPPROCMODE_DT_PROC_MODE_VC3(format->procmode) |\n\t\t   ISPPROCMODE_DT_PROC_MODE_VC2(format->procmode) |\n\t\t   ISPPROCMODE_DT_PROC_MODE_VC1(format->procmode) |\n\t\t   ISPPROCMODE_DT_PROC_MODE_VC0(format->procmode));\n\n\t \n\trisp_write(isp, ISPSTART_REG, ISPSTART_START);\n\n\tret = v4l2_subdev_call(isp->remote, video, s_stream, 1);\n\tif (ret)\n\t\trisp_power_off(isp);\n\n\treturn ret;\n}\n\nstatic void risp_stop(struct rcar_isp *isp)\n{\n\tv4l2_subdev_call(isp->remote, video, s_stream, 0);\n\n\t \n\trisp_write(isp, ISPSTART_REG, ISPSTART_STOP);\n\n\trisp_power_off(isp);\n}\n\nstatic int risp_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct rcar_isp *isp = sd_to_isp(sd);\n\tint ret = 0;\n\n\tmutex_lock(&isp->lock);\n\n\tif (!isp->remote) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (enable && isp->stream_count == 0) {\n\t\tret = risp_start(isp);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else if (!enable && isp->stream_count == 1) {\n\t\trisp_stop(isp);\n\t}\n\n\tisp->stream_count += enable ? 1 : -1;\nout:\n\tmutex_unlock(&isp->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops risp_video_ops = {\n\t.s_stream = risp_s_stream,\n};\n\nstatic int risp_set_pad_format(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_format *format)\n{\n\tstruct rcar_isp *isp = sd_to_isp(sd);\n\tstruct v4l2_mbus_framefmt *framefmt;\n\n\tmutex_lock(&isp->lock);\n\n\tif (!risp_code_to_fmt(format->format.code))\n\t\tformat->format.code = rcar_isp_formats[0].code;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\tisp->mf = format->format;\n\t} else {\n\t\tframefmt = v4l2_subdev_get_try_format(sd, sd_state, 0);\n\t\t*framefmt = format->format;\n\t}\n\n\tmutex_unlock(&isp->lock);\n\n\treturn 0;\n}\n\nstatic int risp_get_pad_format(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_format *format)\n{\n\tstruct rcar_isp *isp = sd_to_isp(sd);\n\n\tmutex_lock(&isp->lock);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tformat->format = isp->mf;\n\telse\n\t\tformat->format = *v4l2_subdev_get_try_format(sd, sd_state, 0);\n\n\tmutex_unlock(&isp->lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops risp_pad_ops = {\n\t.set_fmt = risp_set_pad_format,\n\t.get_fmt = risp_get_pad_format,\n\t.link_validate = v4l2_subdev_link_validate_default,\n};\n\nstatic const struct v4l2_subdev_ops rcar_isp_subdev_ops = {\n\t.video\t= &risp_video_ops,\n\t.pad\t= &risp_pad_ops,\n};\n\n \n\nstatic int risp_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t     struct v4l2_subdev *subdev,\n\t\t\t     struct v4l2_async_connection *asd)\n{\n\tstruct rcar_isp *isp = notifier_to_isp(notifier);\n\tint pad;\n\n\tpad = media_entity_get_fwnode_pad(&subdev->entity, asd->match.fwnode,\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (pad < 0) {\n\t\tdev_err(isp->dev, \"Failed to find pad for %s\\n\", subdev->name);\n\t\treturn pad;\n\t}\n\n\tisp->remote = subdev;\n\n\tdev_dbg(isp->dev, \"Bound %s pad: %d\\n\", subdev->name, pad);\n\n\treturn media_create_pad_link(&subdev->entity, pad,\n\t\t\t\t     &isp->subdev.entity, 0,\n\t\t\t\t     MEDIA_LNK_FL_ENABLED |\n\t\t\t\t     MEDIA_LNK_FL_IMMUTABLE);\n}\n\nstatic void risp_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t       struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_async_connection *asd)\n{\n\tstruct rcar_isp *isp = notifier_to_isp(notifier);\n\n\tisp->remote = NULL;\n\n\tdev_dbg(isp->dev, \"Unbind %s\\n\", subdev->name);\n}\n\nstatic const struct v4l2_async_notifier_operations risp_notify_ops = {\n\t.bound = risp_notify_bound,\n\t.unbind = risp_notify_unbind,\n};\n\nstatic int risp_parse_dt(struct rcar_isp *isp)\n{\n\tstruct v4l2_async_connection *asd;\n\tstruct fwnode_handle *fwnode;\n\tstruct fwnode_handle *ep;\n\tunsigned int id;\n\tint ret;\n\n\tfor (id = 0; id < 2; id++) {\n\t\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(isp->dev),\n\t\t\t\t\t\t     0, id, 0);\n\t\tif (ep)\n\t\t\tbreak;\n\t}\n\n\tif (!ep) {\n\t\tdev_err(isp->dev, \"Not connected to subdevice\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (id == 1)\n\t\tisp->csi_input = RISP_CSI_INPUT1;\n\n\tfwnode = fwnode_graph_get_remote_endpoint(ep);\n\tfwnode_handle_put(ep);\n\n\tdev_dbg(isp->dev, \"Found '%pOF'\\n\", to_of_node(fwnode));\n\n\tv4l2_async_subdev_nf_init(&isp->notifier, &isp->subdev);\n\tisp->notifier.ops = &risp_notify_ops;\n\n\tasd = v4l2_async_nf_add_fwnode(&isp->notifier, fwnode,\n\t\t\t\t       struct v4l2_async_connection);\n\tfwnode_handle_put(fwnode);\n\tif (IS_ERR(asd))\n\t\treturn PTR_ERR(asd);\n\n\tret = v4l2_async_nf_register(&isp->notifier);\n\tif (ret)\n\t\tv4l2_async_nf_cleanup(&isp->notifier);\n\n\treturn ret;\n}\n\n \n\nstatic const struct media_entity_operations risp_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic int risp_probe_resources(struct rcar_isp *isp,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tisp->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(isp->base))\n\t\treturn PTR_ERR(isp->base);\n\n\tisp->rstc = devm_reset_control_get(&pdev->dev, NULL);\n\n\treturn PTR_ERR_OR_ZERO(isp->rstc);\n}\n\nstatic const struct of_device_id risp_of_id_table[] = {\n\t{ .compatible = \"renesas,r8a779a0-isp\" },\n\t{ .compatible = \"renesas,r8a779g0-isp\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, risp_of_id_table);\n\nstatic int risp_probe(struct platform_device *pdev)\n{\n\tstruct rcar_isp *isp;\n\tunsigned int i;\n\tint ret;\n\n\tisp = devm_kzalloc(&pdev->dev, sizeof(*isp), GFP_KERNEL);\n\tif (!isp)\n\t\treturn -ENOMEM;\n\n\tisp->dev = &pdev->dev;\n\n\tmutex_init(&isp->lock);\n\n\tret = risp_probe_resources(isp, pdev);\n\tif (ret) {\n\t\tdev_err(isp->dev, \"Failed to get resources\\n\");\n\t\tgoto error_mutex;\n\t}\n\n\tplatform_set_drvdata(pdev, isp);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = risp_parse_dt(isp);\n\tif (ret)\n\t\tgoto error_pm;\n\n\tisp->subdev.owner = THIS_MODULE;\n\tisp->subdev.dev = &pdev->dev;\n\tv4l2_subdev_init(&isp->subdev, &rcar_isp_subdev_ops);\n\tv4l2_set_subdevdata(&isp->subdev, &pdev->dev);\n\tsnprintf(isp->subdev.name, V4L2_SUBDEV_NAME_SIZE, \"%s %s\",\n\t\t KBUILD_MODNAME, dev_name(&pdev->dev));\n\tisp->subdev.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tisp->subdev.entity.function = MEDIA_ENT_F_VID_MUX;\n\tisp->subdev.entity.ops = &risp_entity_ops;\n\n\tisp->pads[RCAR_ISP_SINK].flags = MEDIA_PAD_FL_SINK;\n\tfor (i = RCAR_ISP_PORT0; i < RCAR_ISP_NUM_PADS; i++)\n\t\tisp->pads[i].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&isp->subdev.entity, RCAR_ISP_NUM_PADS,\n\t\t\t\t     isp->pads);\n\tif (ret)\n\t\tgoto error_notifier;\n\n\tret = v4l2_async_register_subdev(&isp->subdev);\n\tif (ret < 0)\n\t\tgoto error_notifier;\n\n\tdev_info(isp->dev, \"Using CSI-2 input: %u\\n\", isp->csi_input);\n\n\treturn 0;\nerror_notifier:\n\tv4l2_async_nf_unregister(&isp->notifier);\n\tv4l2_async_nf_cleanup(&isp->notifier);\nerror_pm:\n\tpm_runtime_disable(&pdev->dev);\nerror_mutex:\n\tmutex_destroy(&isp->lock);\n\n\treturn ret;\n}\n\nstatic void risp_remove(struct platform_device *pdev)\n{\n\tstruct rcar_isp *isp = platform_get_drvdata(pdev);\n\n\tv4l2_async_nf_unregister(&isp->notifier);\n\tv4l2_async_nf_cleanup(&isp->notifier);\n\n\tv4l2_async_unregister_subdev(&isp->subdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tmutex_destroy(&isp->lock);\n}\n\nstatic struct platform_driver rcar_isp_driver = {\n\t.driver = {\n\t\t.name = \"rcar-isp\",\n\t\t.of_match_table = risp_of_id_table,\n\t},\n\t.probe = risp_probe,\n\t.remove_new = risp_remove,\n};\n\nmodule_platform_driver(rcar_isp_driver);\n\nMODULE_AUTHOR(\"Niklas S\u00f6derlund <niklas.soderlund@ragnatech.se>\");\nMODULE_DESCRIPTION(\"Renesas R-Car ISP Channel Selector driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}