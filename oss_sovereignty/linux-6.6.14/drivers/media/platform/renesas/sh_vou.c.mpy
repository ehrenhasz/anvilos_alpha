{
  "module_name": "sh_vou.c",
  "hash_id": "93f666507024a2e7c83c8e356a9584fab3244f7f5563693a810ac02f4a3ce2b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/sh_vou.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/module.h>\n\n#include <media/drv-intf/sh_vou.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mediabus.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n \n#define VOUER\t0\n#define VOUCR\t4\n#define VOUSTR\t8\n#define VOUVCR\t0xc\n#define VOUISR\t0x10\n#define VOUBCR\t0x14\n#define VOUDPR\t0x18\n#define VOUDSR\t0x1c\n#define VOUVPR\t0x20\n#define VOUIR\t0x24\n#define VOUSRR\t0x28\n#define VOUMSR\t0x2c\n#define VOUHIR\t0x30\n#define VOUDFR\t0x34\n#define VOUAD1R\t0x38\n#define VOUAD2R\t0x3c\n#define VOUAIR\t0x40\n#define VOUSWR\t0x44\n#define VOURCR\t0x48\n#define VOURPR\t0x50\n\nenum sh_vou_status {\n\tSH_VOU_IDLE,\n\tSH_VOU_INITIALISING,\n\tSH_VOU_RUNNING,\n};\n\n#define VOU_MIN_IMAGE_WIDTH\t16\n#define VOU_MAX_IMAGE_WIDTH\t720\n#define VOU_MIN_IMAGE_HEIGHT\t16\n\nstruct sh_vou_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\nstatic inline struct\nsh_vou_buffer *to_sh_vou_buffer(struct vb2_v4l2_buffer *vb2)\n{\n\treturn container_of(vb2, struct sh_vou_buffer, vb);\n}\n\nstruct sh_vou_device {\n\tstruct v4l2_device v4l2_dev;\n\tstruct video_device vdev;\n\tstruct sh_vou_pdata *pdata;\n\tspinlock_t lock;\n\tvoid __iomem *base;\n\t \n\tstruct v4l2_pix_format pix;\n\tstruct v4l2_rect rect;\n\tstruct list_head buf_list;\n\tv4l2_std_id std;\n\tint pix_idx;\n\tstruct vb2_queue queue;\n\tstruct sh_vou_buffer *active;\n\tenum sh_vou_status status;\n\tunsigned sequence;\n\tstruct mutex fop_lock;\n};\n\n \nstatic void sh_vou_reg_a_write(struct sh_vou_device *vou_dev, unsigned int reg,\n\t\t\t       u32 value)\n{\n\t__raw_writel(value, vou_dev->base + reg);\n}\n\nstatic void sh_vou_reg_ab_write(struct sh_vou_device *vou_dev, unsigned int reg,\n\t\t\t\tu32 value)\n{\n\t__raw_writel(value, vou_dev->base + reg);\n\t__raw_writel(value, vou_dev->base + reg + 0x1000);\n}\n\nstatic void sh_vou_reg_m_write(struct sh_vou_device *vou_dev, unsigned int reg,\n\t\t\t       u32 value)\n{\n\t__raw_writel(value, vou_dev->base + reg + 0x2000);\n}\n\nstatic u32 sh_vou_reg_a_read(struct sh_vou_device *vou_dev, unsigned int reg)\n{\n\treturn __raw_readl(vou_dev->base + reg);\n}\n\nstatic void sh_vou_reg_a_set(struct sh_vou_device *vou_dev, unsigned int reg,\n\t\t\t     u32 value, u32 mask)\n{\n\tu32 old = __raw_readl(vou_dev->base + reg);\n\n\tvalue = (value & mask) | (old & ~mask);\n\t__raw_writel(value, vou_dev->base + reg);\n}\n\nstatic void sh_vou_reg_b_set(struct sh_vou_device *vou_dev, unsigned int reg,\n\t\t\t     u32 value, u32 mask)\n{\n\tsh_vou_reg_a_set(vou_dev, reg + 0x1000, value, mask);\n}\n\nstatic void sh_vou_reg_ab_set(struct sh_vou_device *vou_dev, unsigned int reg,\n\t\t\t      u32 value, u32 mask)\n{\n\tsh_vou_reg_a_set(vou_dev, reg, value, mask);\n\tsh_vou_reg_b_set(vou_dev, reg, value, mask);\n}\n\nstruct sh_vou_fmt {\n\tu32\t\tpfmt;\n\tunsigned char\tbpp;\n\tunsigned char\tbpl;\n\tunsigned char\trgb;\n\tunsigned char\tyf;\n\tunsigned char\tpkf;\n};\n\n \nstatic struct sh_vou_fmt vou_fmt[] = {\n\t{\n\t\t.pfmt\t= V4L2_PIX_FMT_NV12,\n\t\t.bpp\t= 12,\n\t\t.bpl\t= 1,\n\t\t.yf\t= 0,\n\t\t.rgb\t= 0,\n\t},\n\t{\n\t\t.pfmt\t= V4L2_PIX_FMT_NV16,\n\t\t.bpp\t= 16,\n\t\t.bpl\t= 1,\n\t\t.yf\t= 1,\n\t\t.rgb\t= 0,\n\t},\n\t{\n\t\t.pfmt\t= V4L2_PIX_FMT_RGB24,\n\t\t.bpp\t= 24,\n\t\t.bpl\t= 3,\n\t\t.pkf\t= 2,\n\t\t.rgb\t= 1,\n\t},\n\t{\n\t\t.pfmt\t= V4L2_PIX_FMT_RGB565,\n\t\t.bpp\t= 16,\n\t\t.bpl\t= 2,\n\t\t.pkf\t= 3,\n\t\t.rgb\t= 1,\n\t},\n\t{\n\t\t.pfmt\t= V4L2_PIX_FMT_RGB565X,\n\t\t.bpp\t= 16,\n\t\t.bpl\t= 2,\n\t\t.pkf\t= 3,\n\t\t.rgb\t= 1,\n\t},\n};\n\nstatic void sh_vou_schedule_next(struct sh_vou_device *vou_dev,\n\t\t\t\t struct vb2_v4l2_buffer *vbuf)\n{\n\tdma_addr_t addr1, addr2;\n\n\taddr1 = vb2_dma_contig_plane_dma_addr(&vbuf->vb2_buf, 0);\n\tswitch (vou_dev->pix.pixelformat) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV16:\n\t\taddr2 = addr1 + vou_dev->pix.width * vou_dev->pix.height;\n\t\tbreak;\n\tdefault:\n\t\taddr2 = 0;\n\t}\n\n\tsh_vou_reg_m_write(vou_dev, VOUAD1R, addr1);\n\tsh_vou_reg_m_write(vou_dev, VOUAD2R, addr2);\n}\n\nstatic void sh_vou_stream_config(struct sh_vou_device *vou_dev)\n{\n\tunsigned int row_coeff;\n#ifdef __LITTLE_ENDIAN\n\tu32 dataswap = 7;\n#else\n\tu32 dataswap = 0;\n#endif\n\n\tswitch (vou_dev->pix.pixelformat) {\n\tdefault:\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV16:\n\t\trow_coeff = 1;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565:\n\t\tdataswap ^= 1;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_RGB565X:\n\t\trow_coeff = 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB24:\n\t\trow_coeff = 3;\n\t\tbreak;\n\t}\n\n\tsh_vou_reg_a_write(vou_dev, VOUSWR, dataswap);\n\tsh_vou_reg_ab_write(vou_dev, VOUAIR, vou_dev->pix.width * row_coeff);\n}\n\n \nstatic int sh_vou_queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct sh_vou_device *vou_dev = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format *pix = &vou_dev->pix;\n\tint bytes_per_line = vou_fmt[vou_dev->pix_idx].bpp * pix->width / 8;\n\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"%s()\\n\", __func__);\n\n\tif (*nplanes)\n\t\treturn sizes[0] < pix->height * bytes_per_line ? -EINVAL : 0;\n\t*nplanes = 1;\n\tsizes[0] = pix->height * bytes_per_line;\n\treturn 0;\n}\n\nstatic int sh_vou_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct sh_vou_device *vou_dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct v4l2_pix_format *pix = &vou_dev->pix;\n\tunsigned bytes_per_line = vou_fmt[vou_dev->pix_idx].bpp * pix->width / 8;\n\tunsigned size = pix->height * bytes_per_line;\n\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"%s()\\n\", __func__);\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\t \n\t\tdev_warn(vou_dev->v4l2_dev.dev, \"buffer too small (%lu < %u)\\n\",\n\t\t\t vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, size);\n\treturn 0;\n}\n\n \nstatic void sh_vou_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct sh_vou_device *vou_dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct sh_vou_buffer *shbuf = to_sh_vou_buffer(vbuf);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vou_dev->lock, flags);\n\tlist_add_tail(&shbuf->list, &vou_dev->buf_list);\n\tspin_unlock_irqrestore(&vou_dev->lock, flags);\n}\n\nstatic int sh_vou_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct sh_vou_device *vou_dev = vb2_get_drv_priv(vq);\n\tstruct sh_vou_buffer *buf, *node;\n\tint ret;\n\n\tvou_dev->sequence = 0;\n\tret = v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0,\n\t\t\t\t\t video, s_stream, 1);\n\tif (ret < 0 && ret != -ENOIOCTLCMD) {\n\t\tlist_for_each_entry_safe(buf, node, &vou_dev->buf_list, list) {\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t\tlist_del(&buf->list);\n\t\t}\n\t\tvou_dev->active = NULL;\n\t\treturn ret;\n\t}\n\n\tbuf = list_entry(vou_dev->buf_list.next, struct sh_vou_buffer, list);\n\n\tvou_dev->active = buf;\n\n\t \n\tsh_vou_reg_a_write(vou_dev, VOURPR, 1);\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"%s: first buffer status 0x%x\\n\",\n\t\t__func__, sh_vou_reg_a_read(vou_dev, VOUSTR));\n\tsh_vou_schedule_next(vou_dev, &buf->vb);\n\n\tbuf = list_entry(buf->list.next, struct sh_vou_buffer, list);\n\n\t \n\tsh_vou_reg_a_write(vou_dev, VOURPR, 0);\n\tsh_vou_schedule_next(vou_dev, &buf->vb);\n\n\t \n\tsh_vou_reg_a_write(vou_dev, VOURCR, 5);\n\n\tsh_vou_stream_config(vou_dev);\n\t \n\tsh_vou_reg_a_write(vou_dev, VOUIR, 0x10004);\n\n\t \n\tvou_dev->status = SH_VOU_RUNNING;\n\tsh_vou_reg_a_write(vou_dev, VOUER, 0x107);\n\treturn 0;\n}\n\nstatic void sh_vou_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct sh_vou_device *vou_dev = vb2_get_drv_priv(vq);\n\tstruct sh_vou_buffer *buf, *node;\n\tunsigned long flags;\n\n\tv4l2_device_call_until_err(&vou_dev->v4l2_dev, 0,\n\t\t\t\t\t video, s_stream, 0);\n\t \n\tsh_vou_reg_a_set(vou_dev, VOUER, 0, 1);\n\t \n\tsh_vou_reg_a_set(vou_dev, VOUIR, 0, 0x30000);\n\tmsleep(50);\n\tspin_lock_irqsave(&vou_dev->lock, flags);\n\tlist_for_each_entry_safe(buf, node, &vou_dev->buf_list, list) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tlist_del(&buf->list);\n\t}\n\tvou_dev->active = NULL;\n\tspin_unlock_irqrestore(&vou_dev->lock, flags);\n}\n\nstatic const struct vb2_ops sh_vou_qops = {\n\t.queue_setup\t\t= sh_vou_queue_setup,\n\t.buf_prepare\t\t= sh_vou_buf_prepare,\n\t.buf_queue\t\t= sh_vou_buf_queue,\n\t.start_streaming\t= sh_vou_start_streaming,\n\t.stop_streaming\t\t= sh_vou_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \nstatic int sh_vou_querycap(struct file *file, void  *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"%s()\\n\", __func__);\n\n\tstrscpy(cap->card, \"SuperH VOU\", sizeof(cap->card));\n\tstrscpy(cap->driver, \"sh-vou\", sizeof(cap->driver));\n\tstrscpy(cap->bus_info, \"platform:sh-vou\", sizeof(cap->bus_info));\n\treturn 0;\n}\n\n \nstatic int sh_vou_enum_fmt_vid_out(struct file *file, void  *priv,\n\t\t\t\t   struct v4l2_fmtdesc *fmt)\n{\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\n\tif (fmt->index >= ARRAY_SIZE(vou_fmt))\n\t\treturn -EINVAL;\n\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"%s()\\n\", __func__);\n\n\tfmt->pixelformat = vou_fmt[fmt->index].pfmt;\n\n\treturn 0;\n}\n\nstatic int sh_vou_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"%s()\\n\", __func__);\n\n\tfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tfmt->fmt.pix = vou_dev->pix;\n\n\treturn 0;\n}\n\nstatic const unsigned char vou_scale_h_num[] = {1, 9, 2, 9, 4};\nstatic const unsigned char vou_scale_h_den[] = {1, 8, 1, 4, 1};\nstatic const unsigned char vou_scale_h_fld[] = {0, 2, 1, 3};\nstatic const unsigned char vou_scale_v_num[] = {1, 2, 4};\nstatic const unsigned char vou_scale_v_den[] = {1, 1, 1};\nstatic const unsigned char vou_scale_v_fld[] = {0, 1};\n\nstatic void sh_vou_configure_geometry(struct sh_vou_device *vou_dev,\n\t\t\t\t      int pix_idx, int w_idx, int h_idx)\n{\n\tstruct sh_vou_fmt *fmt = vou_fmt + pix_idx;\n\tunsigned int black_left, black_top, width_max,\n\t\tframe_in_height, frame_out_height, frame_out_top;\n\tstruct v4l2_rect *rect = &vou_dev->rect;\n\tstruct v4l2_pix_format *pix = &vou_dev->pix;\n\tu32 vouvcr = 0, dsr_h, dsr_v;\n\n\tif (vou_dev->std & V4L2_STD_525_60) {\n\t\twidth_max = 858;\n\t\t \n\t} else {\n\t\twidth_max = 864;\n\t\t \n\t}\n\n\tframe_in_height = pix->height / 2;\n\tframe_out_height = rect->height / 2;\n\tframe_out_top = rect->top / 2;\n\n\t \n\tblack_left = width_max - VOU_MAX_IMAGE_WIDTH;\n\tblack_top = 20;\n\n\tdsr_h = rect->width + rect->left;\n\tdsr_v = frame_out_height + frame_out_top;\n\n\tdev_dbg(vou_dev->v4l2_dev.dev,\n\t\t\"image %ux%u, black %u:%u, offset %u:%u, display %ux%u\\n\",\n\t\tpix->width, frame_in_height, black_left, black_top,\n\t\trect->left, frame_out_top, dsr_h, dsr_v);\n\n\t \n\tsh_vou_reg_ab_write(vou_dev, VOUISR, (pix->width << 16) | frame_in_height);\n\tsh_vou_reg_ab_write(vou_dev, VOUVPR, (black_left << 16) | black_top);\n\tsh_vou_reg_ab_write(vou_dev, VOUDPR, (rect->left << 16) | frame_out_top);\n\tsh_vou_reg_ab_write(vou_dev, VOUDSR, (dsr_h << 16) | dsr_v);\n\n\t \n\n\tif (w_idx)\n\t\tvouvcr |= (1 << 15) | (vou_scale_h_fld[w_idx - 1] << 4);\n\tif (h_idx)\n\t\tvouvcr |= (1 << 14) | vou_scale_v_fld[h_idx - 1];\n\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"0x%08x: scaling 0x%x\\n\",\n\t\tfmt->pfmt, vouvcr);\n\n\t \n\tsh_vou_reg_ab_write(vou_dev, VOUVCR, vouvcr);\n\tsh_vou_reg_ab_write(vou_dev, VOUDFR,\n\t\t\t    fmt->pkf | (fmt->yf << 8) | (fmt->rgb << 16));\n}\n\nstruct sh_vou_geometry {\n\tstruct v4l2_rect output;\n\tunsigned int in_width;\n\tunsigned int in_height;\n\tint scale_idx_h;\n\tint scale_idx_v;\n};\n\n \nstatic void vou_adjust_input(struct sh_vou_geometry *geo, v4l2_std_id std)\n{\n\t \n\tunsigned int best_err = UINT_MAX, best = 0, img_height_max;\n\tint i, idx = 0;\n\n\tif (std & V4L2_STD_525_60)\n\t\timg_height_max = 480;\n\telse\n\t\timg_height_max = 576;\n\n\t \n\tv4l_bound_align_image(&geo->in_width,\n\t\t\t      VOU_MIN_IMAGE_WIDTH, VOU_MAX_IMAGE_WIDTH, 2,\n\t\t\t      &geo->in_height,\n\t\t\t      VOU_MIN_IMAGE_HEIGHT, img_height_max, 1, 0);\n\n\t \n\tfor (i = ARRAY_SIZE(vou_scale_h_num) - 1; i >= 0; i--) {\n\t\tunsigned int err;\n\t\tunsigned int found = geo->output.width * vou_scale_h_den[i] /\n\t\t\tvou_scale_h_num[i];\n\n\t\tif (found > VOU_MAX_IMAGE_WIDTH)\n\t\t\t \n\t\t\tbreak;\n\n\t\terr = abs(found - geo->in_width);\n\t\tif (err < best_err) {\n\t\t\tbest_err = err;\n\t\t\tidx = i;\n\t\t\tbest = found;\n\t\t}\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\tgeo->in_width = best;\n\tgeo->scale_idx_h = idx;\n\n\tbest_err = UINT_MAX;\n\n\t \n\tfor (i = ARRAY_SIZE(vou_scale_v_num) - 1; i >= 0; i--) {\n\t\tunsigned int err;\n\t\tunsigned int found = geo->output.height * vou_scale_v_den[i] /\n\t\t\tvou_scale_v_num[i];\n\n\t\tif (found > img_height_max)\n\t\t\t \n\t\t\tbreak;\n\n\t\terr = abs(found - geo->in_height);\n\t\tif (err < best_err) {\n\t\t\tbest_err = err;\n\t\t\tidx = i;\n\t\t\tbest = found;\n\t\t}\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\tgeo->in_height = best;\n\tgeo->scale_idx_v = idx;\n}\n\n \nstatic void vou_adjust_output(struct sh_vou_geometry *geo, v4l2_std_id std)\n{\n\tunsigned int best_err = UINT_MAX, best = geo->in_width,\n\t\twidth_max, height_max, img_height_max;\n\tint i, idx_h = 0, idx_v = 0;\n\n\tif (std & V4L2_STD_525_60) {\n\t\twidth_max = 858;\n\t\theight_max = 262 * 2;\n\t\timg_height_max = 480;\n\t} else {\n\t\twidth_max = 864;\n\t\theight_max = 312 * 2;\n\t\timg_height_max = 576;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vou_scale_h_num); i++) {\n\t\tunsigned int err;\n\t\tunsigned int found = geo->in_width * vou_scale_h_num[i] /\n\t\t\tvou_scale_h_den[i];\n\n\t\tif (found > VOU_MAX_IMAGE_WIDTH)\n\t\t\t \n\t\t\tbreak;\n\n\t\terr = abs(found - geo->output.width);\n\t\tif (err < best_err) {\n\t\t\tbest_err = err;\n\t\t\tidx_h = i;\n\t\t\tbest = found;\n\t\t}\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\tgeo->output.width = best;\n\tgeo->scale_idx_h = idx_h;\n\tif (geo->output.left + best > width_max)\n\t\tgeo->output.left = width_max - best;\n\n\tpr_debug(\"%s(): W %u * %u/%u = %u\\n\", __func__, geo->in_width,\n\t\t vou_scale_h_num[idx_h], vou_scale_h_den[idx_h], best);\n\n\tbest_err = UINT_MAX;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vou_scale_v_num); i++) {\n\t\tunsigned int err;\n\t\tunsigned int found = geo->in_height * vou_scale_v_num[i] /\n\t\t\tvou_scale_v_den[i];\n\n\t\tif (found > img_height_max)\n\t\t\t \n\t\t\tbreak;\n\n\t\terr = abs(found - geo->output.height);\n\t\tif (err < best_err) {\n\t\t\tbest_err = err;\n\t\t\tidx_v = i;\n\t\t\tbest = found;\n\t\t}\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\tgeo->output.height = best;\n\tgeo->scale_idx_v = idx_v;\n\tif (geo->output.top + best > height_max)\n\t\tgeo->output.top = height_max - best;\n\n\tpr_debug(\"%s(): H %u * %u/%u = %u\\n\", __func__, geo->in_height,\n\t\t vou_scale_v_num[idx_v], vou_scale_v_den[idx_v], best);\n}\n\nstatic int sh_vou_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *fmt)\n{\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\tstruct v4l2_pix_format *pix = &fmt->fmt.pix;\n\tunsigned int img_height_max;\n\tint pix_idx;\n\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"%s()\\n\", __func__);\n\n\tpix->field = V4L2_FIELD_INTERLACED;\n\tpix->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tpix->ycbcr_enc = pix->quantization = 0;\n\n\tfor (pix_idx = 0; pix_idx < ARRAY_SIZE(vou_fmt); pix_idx++)\n\t\tif (vou_fmt[pix_idx].pfmt == pix->pixelformat)\n\t\t\tbreak;\n\n\tif (pix_idx == ARRAY_SIZE(vou_fmt))\n\t\treturn -EINVAL;\n\n\tif (vou_dev->std & V4L2_STD_525_60)\n\t\timg_height_max = 480;\n\telse\n\t\timg_height_max = 576;\n\n\tv4l_bound_align_image(&pix->width,\n\t\t\t      VOU_MIN_IMAGE_WIDTH, VOU_MAX_IMAGE_WIDTH, 2,\n\t\t\t      &pix->height,\n\t\t\t      VOU_MIN_IMAGE_HEIGHT, img_height_max, 1, 0);\n\tpix->bytesperline = pix->width * vou_fmt[pix_idx].bpl;\n\tpix->sizeimage = pix->height * ((pix->width * vou_fmt[pix_idx].bpp) >> 3);\n\n\treturn 0;\n}\n\nstatic int sh_vou_set_fmt_vid_out(struct sh_vou_device *vou_dev,\n\t\t\t\tstruct v4l2_pix_format *pix)\n{\n\tunsigned int img_height_max;\n\tstruct sh_vou_geometry geo;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t \n\t\t.format.code = MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.format.field = V4L2_FIELD_INTERLACED,\n\t\t.format.colorspace = V4L2_COLORSPACE_SMPTE170M,\n\t};\n\tstruct v4l2_mbus_framefmt *mbfmt = &format.format;\n\tint pix_idx;\n\tint ret;\n\n\tif (vb2_is_busy(&vou_dev->queue))\n\t\treturn -EBUSY;\n\n\tfor (pix_idx = 0; pix_idx < ARRAY_SIZE(vou_fmt); pix_idx++)\n\t\tif (vou_fmt[pix_idx].pfmt == pix->pixelformat)\n\t\t\tbreak;\n\n\tgeo.in_width = pix->width;\n\tgeo.in_height = pix->height;\n\tgeo.output = vou_dev->rect;\n\n\tvou_adjust_output(&geo, vou_dev->std);\n\n\tmbfmt->width = geo.output.width;\n\tmbfmt->height = geo.output.height;\n\tret = v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, pad,\n\t\t\t\t\t set_fmt, NULL, &format);\n\t \n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"%s(): %ux%u -> %ux%u\\n\", __func__,\n\t\tgeo.output.width, geo.output.height, mbfmt->width, mbfmt->height);\n\n\tif (vou_dev->std & V4L2_STD_525_60)\n\t\timg_height_max = 480;\n\telse\n\t\timg_height_max = 576;\n\n\t \n\tif ((unsigned)mbfmt->width > VOU_MAX_IMAGE_WIDTH ||\n\t    (unsigned)mbfmt->height > img_height_max ||\n\t    mbfmt->code != MEDIA_BUS_FMT_YUYV8_2X8)\n\t\treturn -EIO;\n\n\tif (mbfmt->width != geo.output.width ||\n\t    mbfmt->height != geo.output.height) {\n\t\tgeo.output.width = mbfmt->width;\n\t\tgeo.output.height = mbfmt->height;\n\n\t\tvou_adjust_input(&geo, vou_dev->std);\n\t}\n\n\t \n\tvou_dev->rect = geo.output;\n\tpix->width = geo.in_width;\n\tpix->height = geo.in_height;\n\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"%s(): %ux%u\\n\", __func__,\n\t\tpix->width, pix->height);\n\n\tvou_dev->pix_idx = pix_idx;\n\n\tvou_dev->pix = *pix;\n\n\tsh_vou_configure_geometry(vou_dev, pix_idx,\n\t\t\t\t  geo.scale_idx_h, geo.scale_idx_v);\n\n\treturn 0;\n}\n\nstatic int sh_vou_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\tint ret = sh_vou_try_fmt_vid_out(file, priv, fmt);\n\n\tif (ret)\n\t\treturn ret;\n\treturn sh_vou_set_fmt_vid_out(vou_dev, &fmt->fmt.pix);\n}\n\nstatic int sh_vou_enum_output(struct file *file, void *fh,\n\t\t\t      struct v4l2_output *a)\n{\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\n\tif (a->index)\n\t\treturn -EINVAL;\n\tstrscpy(a->name, \"Video Out\", sizeof(a->name));\n\ta->type = V4L2_OUTPUT_TYPE_ANALOG;\n\ta->std = vou_dev->vdev.tvnorms;\n\treturn 0;\n}\n\nstatic int sh_vou_g_output(struct file *file, void *fh, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int sh_vou_s_output(struct file *file, void *fh, unsigned int i)\n{\n\treturn i ? -EINVAL : 0;\n}\n\nstatic u32 sh_vou_ntsc_mode(enum sh_vou_bus_fmt bus_fmt)\n{\n\tswitch (bus_fmt) {\n\tdefault:\n\t\tpr_warn(\"%s(): Invalid bus-format code %d, using default 8-bit\\n\",\n\t\t\t__func__, bus_fmt);\n\t\tfallthrough;\n\tcase SH_VOU_BUS_8BIT:\n\t\treturn 1;\n\tcase SH_VOU_BUS_16BIT:\n\t\treturn 0;\n\tcase SH_VOU_BUS_BT656:\n\t\treturn 3;\n\t}\n}\n\nstatic int sh_vou_s_std(struct file *file, void *priv, v4l2_std_id std_id)\n{\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\tint ret;\n\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"%s(): 0x%llx\\n\", __func__, std_id);\n\n\tif (std_id == vou_dev->std)\n\t\treturn 0;\n\n\tif (vb2_is_busy(&vou_dev->queue))\n\t\treturn -EBUSY;\n\n\tret = v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, video,\n\t\t\t\t\t s_std_output, std_id);\n\t \n\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\tvou_dev->rect.top = vou_dev->rect.left = 0;\n\tvou_dev->rect.width = VOU_MAX_IMAGE_WIDTH;\n\tif (std_id & V4L2_STD_525_60) {\n\t\tsh_vou_reg_ab_set(vou_dev, VOUCR,\n\t\t\tsh_vou_ntsc_mode(vou_dev->pdata->bus_fmt) << 29, 7 << 29);\n\t\tvou_dev->rect.height = 480;\n\t} else {\n\t\tsh_vou_reg_ab_set(vou_dev, VOUCR, 5 << 29, 7 << 29);\n\t\tvou_dev->rect.height = 576;\n\t}\n\n\tvou_dev->pix.width = vou_dev->rect.width;\n\tvou_dev->pix.height = vou_dev->rect.height;\n\tvou_dev->pix.bytesperline =\n\t\tvou_dev->pix.width * vou_fmt[vou_dev->pix_idx].bpl;\n\tvou_dev->pix.sizeimage = vou_dev->pix.height *\n\t\t((vou_dev->pix.width * vou_fmt[vou_dev->pix_idx].bpp) >> 3);\n\tvou_dev->std = std_id;\n\tsh_vou_set_fmt_vid_out(vou_dev, &vou_dev->pix);\n\n\treturn 0;\n}\n\nstatic int sh_vou_g_std(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"%s()\\n\", __func__);\n\n\t*std = vou_dev->std;\n\n\treturn 0;\n}\n\nstatic int sh_vou_log_status(struct file *file, void *priv)\n{\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\n\tpr_info(\"VOUER:   0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUER));\n\tpr_info(\"VOUCR:   0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUCR));\n\tpr_info(\"VOUSTR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUSTR));\n\tpr_info(\"VOUVCR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUVCR));\n\tpr_info(\"VOUISR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUISR));\n\tpr_info(\"VOUBCR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUBCR));\n\tpr_info(\"VOUDPR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUDPR));\n\tpr_info(\"VOUDSR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUDSR));\n\tpr_info(\"VOUVPR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUVPR));\n\tpr_info(\"VOUIR:   0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUIR));\n\tpr_info(\"VOUSRR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUSRR));\n\tpr_info(\"VOUMSR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUMSR));\n\tpr_info(\"VOUHIR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUHIR));\n\tpr_info(\"VOUDFR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUDFR));\n\tpr_info(\"VOUAD1R: 0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUAD1R));\n\tpr_info(\"VOUAD2R: 0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUAD2R));\n\tpr_info(\"VOUAIR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUAIR));\n\tpr_info(\"VOUSWR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOUSWR));\n\tpr_info(\"VOURCR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOURCR));\n\tpr_info(\"VOURPR:  0x%08x\\n\", sh_vou_reg_a_read(vou_dev, VOURPR));\n\treturn 0;\n}\n\nstatic int sh_vou_g_selection(struct file *file, void *fh,\n\t\t\t      struct v4l2_selection *sel)\n{\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tsel->r = vou_dev->rect;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = VOU_MAX_IMAGE_WIDTH;\n\t\tif (vou_dev->std & V4L2_STD_525_60)\n\t\t\tsel->r.height = 480;\n\t\telse\n\t\t\tsel->r.height = 576;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int sh_vou_s_selection(struct file *file, void *fh,\n\t\t\t      struct v4l2_selection *sel)\n{\n\tstruct v4l2_rect *rect = &sel->r;\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\tstruct v4l2_subdev_selection sd_sel = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.target = V4L2_SEL_TGT_COMPOSE,\n\t};\n\tstruct v4l2_pix_format *pix = &vou_dev->pix;\n\tstruct sh_vou_geometry geo;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t \n\t\t.format.code = MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.format.field = V4L2_FIELD_INTERLACED,\n\t\t.format.colorspace = V4L2_COLORSPACE_SMPTE170M,\n\t};\n\tunsigned int img_height_max;\n\tint ret;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\n\t    sel->target != V4L2_SEL_TGT_COMPOSE)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(&vou_dev->queue))\n\t\treturn -EBUSY;\n\n\tif (vou_dev->std & V4L2_STD_525_60)\n\t\timg_height_max = 480;\n\telse\n\t\timg_height_max = 576;\n\n\tv4l_bound_align_image(&rect->width,\n\t\t\t      VOU_MIN_IMAGE_WIDTH, VOU_MAX_IMAGE_WIDTH, 1,\n\t\t\t      &rect->height,\n\t\t\t      VOU_MIN_IMAGE_HEIGHT, img_height_max, 1, 0);\n\n\tif (rect->width + rect->left > VOU_MAX_IMAGE_WIDTH)\n\t\trect->left = VOU_MAX_IMAGE_WIDTH - rect->width;\n\n\tif (rect->height + rect->top > img_height_max)\n\t\trect->top = img_height_max - rect->height;\n\n\tgeo.output = *rect;\n\tgeo.in_width = pix->width;\n\tgeo.in_height = pix->height;\n\n\t \n\tsd_sel.r.width = geo.output.width;\n\tsd_sel.r.height = geo.output.height;\n\t \n\tv4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, pad,\n\t\t\t\t   set_selection, NULL, &sd_sel);\n\tformat.format.width = geo.output.width;\n\tformat.format.height = geo.output.height;\n\tret = v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, pad,\n\t\t\t\t\t set_fmt, NULL, &format);\n\t \n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif ((unsigned)format.format.width > VOU_MAX_IMAGE_WIDTH ||\n\t    (unsigned)format.format.height > img_height_max ||\n\t    format.format.code != MEDIA_BUS_FMT_YUYV8_2X8)\n\t\treturn -EIO;\n\n\tgeo.output.width = format.format.width;\n\tgeo.output.height = format.format.height;\n\n\t \n\tvou_adjust_input(&geo, vou_dev->std);\n\n\t \n\tvou_dev->rect = geo.output;\n\tpix->width = geo.in_width;\n\tpix->height = geo.in_height;\n\n\tsh_vou_configure_geometry(vou_dev, vou_dev->pix_idx,\n\t\t\t\t  geo.scale_idx_h, geo.scale_idx_v);\n\n\treturn 0;\n}\n\nstatic irqreturn_t sh_vou_isr(int irq, void *dev_id)\n{\n\tstruct sh_vou_device *vou_dev = dev_id;\n\tstatic unsigned long j;\n\tstruct sh_vou_buffer *vb;\n\tstatic int cnt;\n\tu32 irq_status = sh_vou_reg_a_read(vou_dev, VOUIR), masked;\n\tu32 vou_status = sh_vou_reg_a_read(vou_dev, VOUSTR);\n\n\tif (!(irq_status & 0x300)) {\n\t\tif (printk_timed_ratelimit(&j, 500))\n\t\t\tdev_warn(vou_dev->v4l2_dev.dev, \"IRQ status 0x%x!\\n\",\n\t\t\t\t irq_status);\n\t\treturn IRQ_NONE;\n\t}\n\n\tspin_lock(&vou_dev->lock);\n\tif (!vou_dev->active || list_empty(&vou_dev->buf_list)) {\n\t\tif (printk_timed_ratelimit(&j, 500))\n\t\t\tdev_warn(vou_dev->v4l2_dev.dev,\n\t\t\t\t \"IRQ without active buffer: %x!\\n\", irq_status);\n\t\t \n\t\tsh_vou_reg_a_set(vou_dev, VOUIR, 0, 0x300);\n\t\tspin_unlock(&vou_dev->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tmasked = ~(0x300 & irq_status) & irq_status & 0x30304;\n\tdev_dbg(vou_dev->v4l2_dev.dev,\n\t\t\"IRQ status 0x%x -> 0x%x, VOU status 0x%x, cnt %d\\n\",\n\t\tirq_status, masked, vou_status, cnt);\n\n\tcnt++;\n\t \n\n\t \n\tsh_vou_reg_a_write(vou_dev, VOUIR, masked);\n\n\tvb = vou_dev->active;\n\tif (list_is_singular(&vb->list)) {\n\t\t \n\t\tsh_vou_schedule_next(vou_dev, &vb->vb);\n\t\tspin_unlock(&vou_dev->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tlist_del(&vb->list);\n\n\tvb->vb.vb2_buf.timestamp = ktime_get_ns();\n\tvb->vb.sequence = vou_dev->sequence++;\n\tvb->vb.field = V4L2_FIELD_INTERLACED;\n\tvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\n\tvou_dev->active = list_entry(vou_dev->buf_list.next,\n\t\t\t\t     struct sh_vou_buffer, list);\n\n\tif (list_is_singular(&vou_dev->buf_list)) {\n\t\t \n\t\tsh_vou_schedule_next(vou_dev, &vou_dev->active->vb);\n\t} else {\n\t\tstruct sh_vou_buffer *new = list_entry(vou_dev->active->list.next,\n\t\t\t\t\t\tstruct sh_vou_buffer, list);\n\t\tsh_vou_schedule_next(vou_dev, &new->vb);\n\t}\n\n\tspin_unlock(&vou_dev->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sh_vou_hw_init(struct sh_vou_device *vou_dev)\n{\n\tstruct sh_vou_pdata *pdata = vou_dev->pdata;\n\tu32 voucr = sh_vou_ntsc_mode(pdata->bus_fmt) << 29;\n\tint i = 100;\n\n\t \n\tsh_vou_reg_a_write(vou_dev, VOUIR, 0);\n\n\t \n\tsh_vou_reg_a_write(vou_dev, VOUSRR, 0x101);\n\twhile (--i && (sh_vou_reg_a_read(vou_dev, VOUSRR) & 0x101))\n\t\tudelay(1);\n\n\tif (!i)\n\t\treturn -ETIMEDOUT;\n\n\tdev_dbg(vou_dev->v4l2_dev.dev, \"Reset took %dus\\n\", 100 - i);\n\n\tif (pdata->flags & SH_VOU_PCLK_FALLING)\n\t\tvoucr |= 1 << 28;\n\tif (pdata->flags & SH_VOU_HSYNC_LOW)\n\t\tvoucr |= 1 << 27;\n\tif (pdata->flags & SH_VOU_VSYNC_LOW)\n\t\tvoucr |= 1 << 26;\n\tsh_vou_reg_ab_set(vou_dev, VOUCR, voucr, 0xfc000000);\n\n\t \n\tsh_vou_reg_a_write(vou_dev, VOURCR, 4);\n\t \n\tsh_vou_reg_ab_write(vou_dev, VOUMSR, 0x800000);\n\n\tsh_vou_set_fmt_vid_out(vou_dev, &vou_dev->pix);\n\n\treturn 0;\n}\n\n \nstatic int sh_vou_open(struct file *file)\n{\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\tint err;\n\n\tif (mutex_lock_interruptible(&vou_dev->fop_lock))\n\t\treturn -ERESTARTSYS;\n\n\terr = v4l2_fh_open(file);\n\tif (err)\n\t\tgoto done_open;\n\tif (v4l2_fh_is_singular_file(file) &&\n\t    vou_dev->status == SH_VOU_INITIALISING) {\n\t\t \n\t\terr = pm_runtime_resume_and_get(vou_dev->v4l2_dev.dev);\n\t\tif (err < 0) {\n\t\t\tv4l2_fh_release(file);\n\t\t\tgoto done_open;\n\t\t}\n\t\terr = sh_vou_hw_init(vou_dev);\n\t\tif (err < 0) {\n\t\t\tpm_runtime_put(vou_dev->v4l2_dev.dev);\n\t\t\tv4l2_fh_release(file);\n\t\t} else {\n\t\t\tvou_dev->status = SH_VOU_IDLE;\n\t\t}\n\t}\ndone_open:\n\tmutex_unlock(&vou_dev->fop_lock);\n\treturn err;\n}\n\nstatic int sh_vou_release(struct file *file)\n{\n\tstruct sh_vou_device *vou_dev = video_drvdata(file);\n\tbool is_last;\n\n\tmutex_lock(&vou_dev->fop_lock);\n\tis_last = v4l2_fh_is_singular_file(file);\n\t_vb2_fop_release(file, NULL);\n\tif (is_last) {\n\t\t \n\t\tvou_dev->status = SH_VOU_INITIALISING;\n\t\tsh_vou_reg_a_set(vou_dev, VOUER, 0, 0x101);\n\t\tpm_runtime_put(vou_dev->v4l2_dev.dev);\n\t}\n\tmutex_unlock(&vou_dev->fop_lock);\n\treturn 0;\n}\n\n \nstatic const struct v4l2_ioctl_ops sh_vou_ioctl_ops = {\n\t.vidioc_querycap\t\t= sh_vou_querycap,\n\t.vidioc_enum_fmt_vid_out\t= sh_vou_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out\t\t= sh_vou_g_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t\t= sh_vou_s_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t\t= sh_vou_try_fmt_vid_out,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_g_output\t\t= sh_vou_g_output,\n\t.vidioc_s_output\t\t= sh_vou_s_output,\n\t.vidioc_enum_output\t\t= sh_vou_enum_output,\n\t.vidioc_s_std\t\t\t= sh_vou_s_std,\n\t.vidioc_g_std\t\t\t= sh_vou_g_std,\n\t.vidioc_g_selection\t\t= sh_vou_g_selection,\n\t.vidioc_s_selection\t\t= sh_vou_s_selection,\n\t.vidioc_log_status\t\t= sh_vou_log_status,\n};\n\nstatic const struct v4l2_file_operations sh_vou_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= sh_vou_open,\n\t.release\t= sh_vou_release,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.poll\t\t= vb2_fop_poll,\n\t.write\t\t= vb2_fop_write,\n};\n\nstatic const struct video_device sh_vou_video_template = {\n\t.name\t\t= \"sh_vou\",\n\t.fops\t\t= &sh_vou_fops,\n\t.ioctl_ops\t= &sh_vou_ioctl_ops,\n\t.tvnorms\t= V4L2_STD_525_60,  \n\t.vfl_dir\t= VFL_DIR_TX,\n\t.device_caps\t= V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_READWRITE |\n\t\t\t  V4L2_CAP_STREAMING,\n};\n\nstatic int sh_vou_probe(struct platform_device *pdev)\n{\n\tstruct sh_vou_pdata *vou_pdata = pdev->dev.platform_data;\n\tstruct v4l2_rect *rect;\n\tstruct v4l2_pix_format *pix;\n\tstruct i2c_adapter *i2c_adap;\n\tstruct video_device *vdev;\n\tstruct sh_vou_device *vou_dev;\n\tstruct v4l2_subdev *subdev;\n\tstruct vb2_queue *q;\n\tint irq, ret;\n\n\tif (!vou_pdata) {\n\t\tdev_err(&pdev->dev, \"Insufficient VOU platform information.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tvou_dev = devm_kzalloc(&pdev->dev, sizeof(*vou_dev), GFP_KERNEL);\n\tif (!vou_dev)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&vou_dev->buf_list);\n\tspin_lock_init(&vou_dev->lock);\n\tmutex_init(&vou_dev->fop_lock);\n\tvou_dev->pdata = vou_pdata;\n\tvou_dev->status = SH_VOU_INITIALISING;\n\tvou_dev->pix_idx = 1;\n\n\trect = &vou_dev->rect;\n\tpix = &vou_dev->pix;\n\n\t \n\tvou_dev->std\t\t= V4L2_STD_NTSC_M;\n\trect->left\t\t= 0;\n\trect->top\t\t= 0;\n\trect->width\t\t= VOU_MAX_IMAGE_WIDTH;\n\trect->height\t\t= 480;\n\tpix->width\t\t= VOU_MAX_IMAGE_WIDTH;\n\tpix->height\t\t= 480;\n\tpix->pixelformat\t= V4L2_PIX_FMT_NV16;\n\tpix->field\t\t= V4L2_FIELD_INTERLACED;\n\tpix->bytesperline\t= VOU_MAX_IMAGE_WIDTH;\n\tpix->sizeimage\t\t= VOU_MAX_IMAGE_WIDTH * 2 * 480;\n\tpix->colorspace\t\t= V4L2_COLORSPACE_SMPTE170M;\n\n\tvou_dev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(vou_dev->base))\n\t\treturn PTR_ERR(vou_dev->base);\n\n\tret = devm_request_irq(&pdev->dev, irq, sh_vou_isr, 0, \"vou\", vou_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = v4l2_device_register(&pdev->dev, &vou_dev->v4l2_dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Error registering v4l2 device\\n\");\n\t\treturn ret;\n\t}\n\n\tvdev = &vou_dev->vdev;\n\t*vdev = sh_vou_video_template;\n\tif (vou_pdata->bus_fmt == SH_VOU_BUS_8BIT)\n\t\tvdev->tvnorms |= V4L2_STD_PAL;\n\tvdev->v4l2_dev = &vou_dev->v4l2_dev;\n\tvdev->release = video_device_release_empty;\n\tvdev->lock = &vou_dev->fop_lock;\n\n\tvideo_set_drvdata(vdev, vou_dev);\n\n\t \n\tq = &vou_dev->queue;\n\tq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF | VB2_WRITE;\n\tq->drv_priv = vou_dev;\n\tq->buf_struct_size = sizeof(struct sh_vou_buffer);\n\tq->ops = &sh_vou_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = 2;\n\tq->lock = &vou_dev->fop_lock;\n\tq->dev = &pdev->dev;\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\tgoto ei2cgadap;\n\n\tvdev->queue = q;\n\tINIT_LIST_HEAD(&vou_dev->buf_list);\n\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_resume(&pdev->dev);\n\n\ti2c_adap = i2c_get_adapter(vou_pdata->i2c_adap);\n\tif (!i2c_adap) {\n\t\tret = -ENODEV;\n\t\tgoto ei2cgadap;\n\t}\n\n\tret = sh_vou_hw_init(vou_dev);\n\tif (ret < 0)\n\t\tgoto ereset;\n\n\tsubdev = v4l2_i2c_new_subdev_board(&vou_dev->v4l2_dev, i2c_adap,\n\t\t\tvou_pdata->board_info, NULL);\n\tif (!subdev) {\n\t\tret = -ENOMEM;\n\t\tgoto ei2cnd;\n\t}\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0)\n\t\tgoto evregdev;\n\n\treturn 0;\n\nevregdev:\nei2cnd:\nereset:\n\ti2c_put_adapter(i2c_adap);\nei2cgadap:\n\tpm_runtime_disable(&pdev->dev);\n\tv4l2_device_unregister(&vou_dev->v4l2_dev);\n\treturn ret;\n}\n\nstatic void sh_vou_remove(struct platform_device *pdev)\n{\n\tstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\n\tstruct sh_vou_device *vou_dev = container_of(v4l2_dev,\n\t\t\t\t\t\tstruct sh_vou_device, v4l2_dev);\n\tstruct v4l2_subdev *sd = list_entry(v4l2_dev->subdevs.next,\n\t\t\t\t\t    struct v4l2_subdev, list);\n\tstruct i2c_client *client = v4l2_get_subdevdata(sd);\n\n\tpm_runtime_disable(&pdev->dev);\n\tvideo_unregister_device(&vou_dev->vdev);\n\ti2c_put_adapter(client->adapter);\n\tv4l2_device_unregister(&vou_dev->v4l2_dev);\n}\n\nstatic struct platform_driver sh_vou = {\n\t.remove_new = sh_vou_remove,\n\t.driver  = {\n\t\t.name\t= \"sh-vou\",\n\t},\n};\n\nmodule_platform_driver_probe(sh_vou, sh_vou_probe);\n\nMODULE_DESCRIPTION(\"SuperH VOU driver\");\nMODULE_AUTHOR(\"Guennadi Liakhovetski <g.liakhovetski@gmx.de>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(\"0.1.0\");\nMODULE_ALIAS(\"platform:sh-vou\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}