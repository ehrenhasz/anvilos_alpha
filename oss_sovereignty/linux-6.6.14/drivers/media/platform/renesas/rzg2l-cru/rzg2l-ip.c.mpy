{
  "module_name": "rzg2l-ip.c",
  "hash_id": "3bd468670a48fed4f5c108d8d8eb1dcab1d4a5c38a1caa3f9df61dd2942a2247",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/rzg2l-cru/rzg2l-ip.c",
  "human_readable_source": "\n \n\n#include \"rzg2l-cru.h\"\n\nstruct rzg2l_cru_ip_format {\n\tu32 code;\n\tunsigned int datatype;\n\tunsigned int bpp;\n};\n\nstatic const struct rzg2l_cru_ip_format rzg2l_cru_ip_formats[] = {\n\t{ .code = MEDIA_BUS_FMT_UYVY8_1X16,\t.datatype = 0x1e, .bpp = 16 },\n};\n\nenum rzg2l_csi2_pads {\n\tRZG2L_CRU_IP_SINK = 0,\n\tRZG2L_CRU_IP_SOURCE,\n};\n\nstatic const struct rzg2l_cru_ip_format *rzg2l_cru_ip_code_to_fmt(unsigned int code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rzg2l_cru_ip_formats); i++)\n\t\tif (rzg2l_cru_ip_formats[i].code == code)\n\t\t\treturn &rzg2l_cru_ip_formats[i];\n\n\treturn NULL;\n}\n\nstruct v4l2_mbus_framefmt *rzg2l_cru_ip_get_src_fmt(struct rzg2l_cru_dev *cru)\n{\n\tstruct v4l2_subdev_state *state;\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(&cru->ip.subdev);\n\tfmt = v4l2_subdev_get_pad_format(&cru->ip.subdev, state, 1);\n\tv4l2_subdev_unlock_state(state);\n\n\treturn fmt;\n}\n\nstatic int rzg2l_cru_ip_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct rzg2l_cru_dev *cru;\n\tint s_stream_ret = 0;\n\tint ret;\n\n\tcru = v4l2_get_subdevdata(sd);\n\n\tif (!enable) {\n\t\tret = v4l2_subdev_call(cru->ip.remote, video, s_stream, enable);\n\t\tif (ret)\n\t\t\ts_stream_ret = ret;\n\n\t\tret = v4l2_subdev_call(cru->ip.remote, video, post_streamoff);\n\t\tif (ret == -ENOIOCTLCMD)\n\t\t\tret = 0;\n\t\tif (ret && !s_stream_ret)\n\t\t\ts_stream_ret = ret;\n\t\trzg2l_cru_stop_image_processing(cru);\n\t} else {\n\t\tret = v4l2_subdev_call(cru->ip.remote, video, pre_streamon, 0);\n\t\tif (ret == -ENOIOCTLCMD)\n\t\t\tret = 0;\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = rzg2l_cru_start_image_processing(cru);\n\t\tif (ret) {\n\t\t\tv4l2_subdev_call(cru->ip.remote, video, post_streamoff);\n\t\t\treturn ret;\n\t\t}\n\n\t\trzg2l_cru_vclk_unprepare(cru);\n\n\t\tret = v4l2_subdev_call(cru->ip.remote, video, s_stream, enable);\n\t\tif (ret == -ENOIOCTLCMD)\n\t\t\tret = 0;\n\t\tif (!ret) {\n\t\t\tret = rzg2l_cru_vclk_prepare(cru);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\t \n\t\t\tif (rzg2l_cru_vclk_prepare(cru))\n\t\t\t\tdev_err(cru->dev, \"Failed to enable vclk\\n\");\n\t\t}\n\n\t\ts_stream_ret = ret;\n\n\t\tv4l2_subdev_call(cru->ip.remote, video, post_streamoff);\n\t\trzg2l_cru_stop_image_processing(cru);\n\t}\n\n\treturn s_stream_ret;\n}\n\nstatic int rzg2l_cru_ip_set_format(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *state,\n\t\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct v4l2_mbus_framefmt *src_format;\n\tstruct v4l2_mbus_framefmt *sink_format;\n\n\tsrc_format = v4l2_subdev_get_pad_format(sd, state, RZG2L_CRU_IP_SOURCE);\n\tif (fmt->pad == RZG2L_CRU_IP_SOURCE) {\n\t\tfmt->format = *src_format;\n\t\treturn 0;\n\t}\n\n\tsink_format = v4l2_subdev_get_pad_format(sd, state, fmt->pad);\n\n\tif (!rzg2l_cru_ip_code_to_fmt(fmt->format.code))\n\t\tsink_format->code = rzg2l_cru_ip_formats[0].code;\n\telse\n\t\tsink_format->code = fmt->format.code;\n\n\tsink_format->field = V4L2_FIELD_NONE;\n\tsink_format->colorspace = fmt->format.colorspace;\n\tsink_format->xfer_func = fmt->format.xfer_func;\n\tsink_format->ycbcr_enc = fmt->format.ycbcr_enc;\n\tsink_format->quantization = fmt->format.quantization;\n\tsink_format->width = clamp_t(u32, fmt->format.width,\n\t\t\t\t     RZG2L_CRU_MIN_INPUT_WIDTH, RZG2L_CRU_MAX_INPUT_WIDTH);\n\tsink_format->height = clamp_t(u32, fmt->format.height,\n\t\t\t\t      RZG2L_CRU_MIN_INPUT_HEIGHT, RZG2L_CRU_MAX_INPUT_HEIGHT);\n\n\tfmt->format = *sink_format;\n\n\t \n\t*src_format = *sink_format;\n\n\treturn 0;\n}\n\nstatic int rzg2l_cru_ip_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t       struct v4l2_subdev_state *state,\n\t\t\t\t       struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= ARRAY_SIZE(rzg2l_cru_ip_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = rzg2l_cru_ip_formats[code->index].code;\n\treturn 0;\n}\n\nstatic int rzg2l_cru_ip_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t\tstruct v4l2_subdev_state *state,\n\t\t\t\t\tstruct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tif (fse->code != MEDIA_BUS_FMT_UYVY8_1X16)\n\t\treturn -EINVAL;\n\n\tfse->min_width = RZG2L_CRU_MIN_INPUT_WIDTH;\n\tfse->min_height = RZG2L_CRU_MIN_INPUT_HEIGHT;\n\tfse->max_width = RZG2L_CRU_MAX_INPUT_WIDTH;\n\tfse->max_height = RZG2L_CRU_MAX_INPUT_HEIGHT;\n\n\treturn 0;\n}\n\nstatic int rzg2l_cru_ip_init_config(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_subdev_format fmt = { .pad = RZG2L_CRU_IP_SINK, };\n\n\tfmt.format.width = RZG2L_CRU_MIN_INPUT_WIDTH;\n\tfmt.format.height = RZG2L_CRU_MIN_INPUT_HEIGHT;\n\tfmt.format.field = V4L2_FIELD_NONE;\n\tfmt.format.code = MEDIA_BUS_FMT_UYVY8_1X16;\n\tfmt.format.colorspace = V4L2_COLORSPACE_SRGB;\n\tfmt.format.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tfmt.format.quantization = V4L2_QUANTIZATION_DEFAULT;\n\tfmt.format.xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\n\treturn rzg2l_cru_ip_set_format(sd, sd_state, &fmt);\n}\n\nstatic const struct v4l2_subdev_video_ops rzg2l_cru_ip_video_ops = {\n\t.s_stream = rzg2l_cru_ip_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops rzg2l_cru_ip_pad_ops = {\n\t.enum_mbus_code = rzg2l_cru_ip_enum_mbus_code,\n\t.enum_frame_size = rzg2l_cru_ip_enum_frame_size,\n\t.init_cfg = rzg2l_cru_ip_init_config,\n\t.get_fmt = v4l2_subdev_get_fmt,\n\t.set_fmt = rzg2l_cru_ip_set_format,\n};\n\nstatic const struct v4l2_subdev_ops rzg2l_cru_ip_subdev_ops = {\n\t.video = &rzg2l_cru_ip_video_ops,\n\t.pad = &rzg2l_cru_ip_pad_ops,\n};\n\nstatic const struct media_entity_operations rzg2l_cru_ip_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nint rzg2l_cru_ip_subdev_register(struct rzg2l_cru_dev *cru)\n{\n\tstruct rzg2l_cru_ip *ip = &cru->ip;\n\tint ret;\n\n\tip->subdev.dev = cru->dev;\n\tv4l2_subdev_init(&ip->subdev, &rzg2l_cru_ip_subdev_ops);\n\tv4l2_set_subdevdata(&ip->subdev, cru);\n\tsnprintf(ip->subdev.name, sizeof(ip->subdev.name),\n\t\t \"cru-ip-%s\", dev_name(cru->dev));\n\tip->subdev.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tip->subdev.entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;\n\tip->subdev.entity.ops = &rzg2l_cru_ip_entity_ops;\n\n\tip->pads[0].flags = MEDIA_PAD_FL_SINK;\n\tip->pads[1].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&ip->subdev.entity, 2, ip->pads);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_subdev_init_finalize(&ip->subdev);\n\tif (ret < 0)\n\t\tgoto entity_cleanup;\n\n\tret = v4l2_device_register_subdev(&cru->v4l2_dev, &ip->subdev);\n\tif (ret < 0)\n\t\tgoto error_subdev;\n\n\treturn 0;\nerror_subdev:\n\tv4l2_subdev_cleanup(&ip->subdev);\nentity_cleanup:\n\tmedia_entity_cleanup(&ip->subdev.entity);\n\n\treturn ret;\n}\n\nvoid rzg2l_cru_ip_subdev_unregister(struct rzg2l_cru_dev *cru)\n{\n\tstruct rzg2l_cru_ip *ip = &cru->ip;\n\n\tmedia_entity_cleanup(&ip->subdev.entity);\n\tv4l2_subdev_cleanup(&ip->subdev);\n\tv4l2_device_unregister_subdev(&ip->subdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}