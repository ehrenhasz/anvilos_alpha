{
  "module_name": "rzg2l-core.c",
  "hash_id": "623b83206a7b52b64a0da50c0b4bd613eb1b2edfd84b56f6ae06a1d2585dcd70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/rzg2l-cru/rzg2l-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mc.h>\n\n#include \"rzg2l-cru.h\"\n\nstatic inline struct rzg2l_cru_dev *notifier_to_cru(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct rzg2l_cru_dev, notifier);\n}\n\nstatic const struct media_device_ops rzg2l_cru_media_ops = {\n\t.link_notify = v4l2_pipeline_link_notify,\n};\n\n \n\nstatic int rzg2l_cru_group_notify_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct rzg2l_cru_dev *cru = notifier_to_cru(notifier);\n\tstruct media_entity *source, *sink;\n\tint ret;\n\n\tret = rzg2l_cru_ip_subdev_register(cru);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_device_register_subdev_nodes(&cru->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(cru->dev, \"Failed to register subdev nodes\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rzg2l_cru_video_register(cru);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsource = &cru->csi.subdev->entity;\n\tsink = &cru->ip.subdev.entity;\n\tret = media_create_pad_link(source, 1, sink, 0,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret) {\n\t\tdev_err(cru->dev, \"Error creating link from %s to %s\\n\",\n\t\t\tsource->name, sink->name);\n\t\treturn ret;\n\t}\n\tcru->csi.channel = 0;\n\tcru->ip.remote = cru->csi.subdev;\n\n\t \n\tsource = &cru->ip.subdev.entity;\n\tsink = &cru->vdev.entity;\n\tret = media_create_pad_link(source, 1, sink, 0,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret) {\n\t\tdev_err(cru->dev, \"Error creating link from %s to %s\\n\",\n\t\t\tsource->name, sink->name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rzg2l_cru_group_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\t\t  struct v4l2_subdev *subdev,\n\t\t\t\t\t  struct v4l2_async_connection *asd)\n{\n\tstruct rzg2l_cru_dev *cru = notifier_to_cru(notifier);\n\n\trzg2l_cru_ip_subdev_unregister(cru);\n\n\tmutex_lock(&cru->mdev_lock);\n\n\tif (cru->csi.asd == asd) {\n\t\tcru->csi.subdev = NULL;\n\t\tdev_dbg(cru->dev, \"Unbind CSI-2 %s\\n\", subdev->name);\n\t}\n\n\tmutex_unlock(&cru->mdev_lock);\n}\n\nstatic int rzg2l_cru_group_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t\tstruct v4l2_subdev *subdev,\n\t\t\t\t\tstruct v4l2_async_connection *asd)\n{\n\tstruct rzg2l_cru_dev *cru = notifier_to_cru(notifier);\n\n\tmutex_lock(&cru->mdev_lock);\n\n\tif (cru->csi.asd == asd) {\n\t\tcru->csi.subdev = subdev;\n\t\tdev_dbg(cru->dev, \"Bound CSI-2 %s\\n\", subdev->name);\n\t}\n\n\tmutex_unlock(&cru->mdev_lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_async_notifier_operations rzg2l_cru_async_ops = {\n\t.bound = rzg2l_cru_group_notify_bound,\n\t.unbind = rzg2l_cru_group_notify_unbind,\n\t.complete = rzg2l_cru_group_notify_complete,\n};\n\nstatic int rzg2l_cru_mc_parse_of(struct rzg2l_cru_dev *cru)\n{\n\tstruct v4l2_fwnode_endpoint vep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tstruct fwnode_handle *ep, *fwnode;\n\tstruct v4l2_async_connection *asd;\n\tint ret;\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(cru->dev), 1, 0, 0);\n\tif (!ep)\n\t\treturn 0;\n\n\tfwnode = fwnode_graph_get_remote_endpoint(ep);\n\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\tfwnode_handle_put(ep);\n\tif (ret) {\n\t\tdev_err(cru->dev, \"Failed to parse %pOF\\n\", to_of_node(fwnode));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!of_device_is_available(to_of_node(fwnode))) {\n\t\tdev_dbg(cru->dev, \"OF device %pOF disabled, ignoring\\n\",\n\t\t\tto_of_node(fwnode));\n\t\tret = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tasd = v4l2_async_nf_add_fwnode(&cru->notifier, fwnode,\n\t\t\t\t       struct v4l2_async_connection);\n\tif (IS_ERR(asd)) {\n\t\tret = PTR_ERR(asd);\n\t\tgoto out;\n\t}\n\n\tcru->csi.asd = asd;\n\n\tdev_dbg(cru->dev, \"Added OF device %pOF to slot %u\\n\",\n\t\tto_of_node(fwnode), vep.base.id);\nout:\n\tfwnode_handle_put(fwnode);\n\n\treturn ret;\n}\n\nstatic int rzg2l_cru_mc_parse_of_graph(struct rzg2l_cru_dev *cru)\n{\n\tint ret;\n\n\tv4l2_async_nf_init(&cru->notifier, &cru->v4l2_dev);\n\n\tret = rzg2l_cru_mc_parse_of(cru);\n\tif (ret)\n\t\treturn ret;\n\n\tcru->notifier.ops = &rzg2l_cru_async_ops;\n\n\tif (list_empty(&cru->notifier.waiting_list))\n\t\treturn 0;\n\n\tret = v4l2_async_nf_register(&cru->notifier);\n\tif (ret < 0) {\n\t\tdev_err(cru->dev, \"Notifier registration failed\\n\");\n\t\tv4l2_async_nf_cleanup(&cru->notifier);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rzg2l_cru_media_init(struct rzg2l_cru_dev *cru)\n{\n\tstruct media_device *mdev = NULL;\n\tconst struct of_device_id *match;\n\tint ret;\n\n\tcru->pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&cru->vdev.entity, 1, &cru->pad);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&cru->mdev_lock);\n\tmdev = &cru->mdev;\n\tmdev->dev = cru->dev;\n\tmdev->ops = &rzg2l_cru_media_ops;\n\n\tmatch = of_match_node(cru->dev->driver->of_match_table,\n\t\t\t      cru->dev->of_node);\n\n\tstrscpy(mdev->driver_name, KBUILD_MODNAME, sizeof(mdev->driver_name));\n\tstrscpy(mdev->model, match->compatible, sizeof(mdev->model));\n\n\tcru->v4l2_dev.mdev = &cru->mdev;\n\n\tmedia_device_init(mdev);\n\n\tret = rzg2l_cru_mc_parse_of_graph(cru);\n\tif (ret) {\n\t\tmutex_lock(&cru->mdev_lock);\n\t\tcru->v4l2_dev.mdev = NULL;\n\t\tmutex_unlock(&cru->mdev_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int rzg2l_cru_probe(struct platform_device *pdev)\n{\n\tstruct rzg2l_cru_dev *cru;\n\tint ret;\n\n\tcru = devm_kzalloc(&pdev->dev, sizeof(*cru), GFP_KERNEL);\n\tif (!cru)\n\t\treturn -ENOMEM;\n\n\tcru->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cru->base))\n\t\treturn PTR_ERR(cru->base);\n\n\tcru->presetn = devm_reset_control_get_shared(&pdev->dev, \"presetn\");\n\tif (IS_ERR(cru->presetn))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(cru->presetn),\n\t\t\t\t     \"Failed to get cpg presetn\\n\");\n\n\tcru->aresetn = devm_reset_control_get_exclusive(&pdev->dev, \"aresetn\");\n\tif (IS_ERR(cru->aresetn))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(cru->aresetn),\n\t\t\t\t     \"Failed to get cpg aresetn\\n\");\n\n\tcru->vclk = devm_clk_get(&pdev->dev, \"video\");\n\tif (IS_ERR(cru->vclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(cru->vclk),\n\t\t\t\t     \"Failed to get video clock\\n\");\n\n\tcru->dev = &pdev->dev;\n\tcru->info = of_device_get_match_data(&pdev->dev);\n\n\tcru->image_conv_irq = platform_get_irq(pdev, 0);\n\tif (cru->image_conv_irq < 0)\n\t\treturn cru->image_conv_irq;\n\n\tplatform_set_drvdata(pdev, cru);\n\n\tret = rzg2l_cru_dma_register(cru);\n\tif (ret)\n\t\treturn ret;\n\n\tcru->num_buf = RZG2L_CRU_HW_BUFFER_DEFAULT;\n\tpm_suspend_ignore_children(&pdev->dev, true);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = rzg2l_cru_media_init(cru);\n\tif (ret)\n\t\tgoto error_dma_unregister;\n\n\treturn 0;\n\nerror_dma_unregister:\n\trzg2l_cru_dma_unregister(cru);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void rzg2l_cru_remove(struct platform_device *pdev)\n{\n\tstruct rzg2l_cru_dev *cru = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tv4l2_async_nf_unregister(&cru->notifier);\n\tv4l2_async_nf_cleanup(&cru->notifier);\n\n\trzg2l_cru_video_unregister(cru);\n\tmedia_device_cleanup(&cru->mdev);\n\tmutex_destroy(&cru->mdev_lock);\n\n\trzg2l_cru_dma_unregister(cru);\n}\n\nstatic const struct of_device_id rzg2l_cru_of_id_table[] = {\n\t{ .compatible = \"renesas,rzg2l-cru\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rzg2l_cru_of_id_table);\n\nstatic struct platform_driver rzg2l_cru_driver = {\n\t.driver = {\n\t\t.name = \"rzg2l-cru\",\n\t\t.of_match_table = rzg2l_cru_of_id_table,\n\t},\n\t.probe = rzg2l_cru_probe,\n\t.remove_new = rzg2l_cru_remove,\n};\n\nmodule_platform_driver(rzg2l_cru_driver);\n\nMODULE_AUTHOR(\"Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>\");\nMODULE_DESCRIPTION(\"Renesas RZ/G2L CRU driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}