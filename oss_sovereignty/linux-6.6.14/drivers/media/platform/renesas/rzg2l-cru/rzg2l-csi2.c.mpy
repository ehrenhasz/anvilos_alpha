{
  "module_name": "rzg2l-csi2.c",
  "hash_id": "1408d98ce61ce0223a2b7ac31a4a32fd9d8a17e63713a53f9eec9ed04724c3fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/rzg2l-cru/rzg2l-csi2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/sys_soc.h>\n#include <linux/units.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n\n \n \n#define CSI2nMCG\t\t\t0x0\n#define CSI2nMCG_SDLN\t\t\tGENMASK(11, 8)\n\n \n#define CSI2nMCT0\t\t\t0x10\n#define CSI2nMCT0_VDLN(x)\t\t((x) << 0)\n\n \n#define CSI2nMCT2\t\t\t0x18\n#define CSI2nMCT2_FRRSKW(x)\t\t((x) << 16)\n#define CSI2nMCT2_FRRCLK(x)\t\t((x) << 0)\n\n \n#define CSI2nMCT3\t\t\t0x1c\n#define CSI2nMCT3_RXEN\t\t\tBIT(0)\n\n \n#define CSI2nRTCT\t\t\t0x28\n#define CSI2nRTCT_VSRST\t\t\tBIT(0)\n\n \n#define CSI2nRTST\t\t\t0x2c\n#define CSI2nRTST_VSRSTS\t\tBIT(0)\n\n \n#define CSI2nDTEL\t\t\t0x60\n\n \n#define CSI2nDTEH\t\t\t0x64\n\n \n \n#define CSIDPHYCTRL0\t\t\t0x400\n#define CSIDPHYCTRL0_EN_LDO1200\t\tBIT(1)\n#define CSIDPHYCTRL0_EN_BGR\t\tBIT(0)\n\n \n#define CSIDPHYTIM0\t\t\t0x404\n#define CSIDPHYTIM0_TCLK_MISS(x)\t((x) << 24)\n#define CSIDPHYTIM0_T_INIT(x)\t\t((x) << 0)\n\n \n#define CSIDPHYTIM1\t\t\t0x408\n#define CSIDPHYTIM1_THS_PREPARE(x)\t((x) << 24)\n#define CSIDPHYTIM1_TCLK_PREPARE(x)\t((x) << 16)\n#define CSIDPHYTIM1_THS_SETTLE(x)\t((x) << 8)\n#define CSIDPHYTIM1_TCLK_SETTLE(x)\t((x) << 0)\n\n \n#define CSIDPHYSKW0\t\t\t0x460\n#define CSIDPHYSKW0_UTIL_DL0_SKW_ADJ(x)\t((x) & 0x3)\n#define CSIDPHYSKW0_UTIL_DL1_SKW_ADJ(x)\t(((x) & 0x3) << 4)\n#define CSIDPHYSKW0_UTIL_DL2_SKW_ADJ(x)\t(((x) & 0x3) << 8)\n#define CSIDPHYSKW0_UTIL_DL3_SKW_ADJ(x)\t(((x) & 0x3) << 12)\n#define CSIDPHYSKW0_DEFAULT_SKW\t\t(CSIDPHYSKW0_UTIL_DL0_SKW_ADJ(1) | \\\n\t\t\t\t\t CSIDPHYSKW0_UTIL_DL1_SKW_ADJ(1) | \\\n\t\t\t\t\t CSIDPHYSKW0_UTIL_DL2_SKW_ADJ(1) | \\\n\t\t\t\t\t CSIDPHYSKW0_UTIL_DL3_SKW_ADJ(1))\n\n#define VSRSTS_RETRIES\t\t\t20\n\n#define RZG2L_CSI2_MIN_WIDTH\t\t320\n#define RZG2L_CSI2_MIN_HEIGHT\t\t240\n#define RZG2L_CSI2_MAX_WIDTH\t\t2800\n#define RZG2L_CSI2_MAX_HEIGHT\t\t4095\n\n#define RZG2L_CSI2_DEFAULT_WIDTH\tRZG2L_CSI2_MIN_WIDTH\n#define RZG2L_CSI2_DEFAULT_HEIGHT\tRZG2L_CSI2_MIN_HEIGHT\n#define RZG2L_CSI2_DEFAULT_FMT\t\tMEDIA_BUS_FMT_UYVY8_1X16\n\nenum rzg2l_csi2_pads {\n\tRZG2L_CSI2_SINK = 0,\n\tRZG2L_CSI2_SOURCE,\n\tNR_OF_RZG2L_CSI2_PAD,\n};\n\nstruct rzg2l_csi2 {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct reset_control *presetn;\n\tstruct reset_control *cmn_rstb;\n\tstruct clk *sysclk;\n\tunsigned long vclk_rate;\n\n\tstruct v4l2_subdev subdev;\n\tstruct media_pad pads[NR_OF_RZG2L_CSI2_PAD];\n\n\tstruct v4l2_async_notifier notifier;\n\tstruct v4l2_subdev *remote_source;\n\n\tunsigned short lanes;\n\tunsigned long hsfreq;\n\n\tbool dphy_enabled;\n};\n\nstruct rzg2l_csi2_timings {\n\tu32 t_init;\n\tu32 tclk_miss;\n\tu32 tclk_settle;\n\tu32 ths_settle;\n\tu32 tclk_prepare;\n\tu32 ths_prepare;\n\tu32 max_hsfreq;\n};\n\nstatic const struct rzg2l_csi2_timings rzg2l_csi2_global_timings[] = {\n\t{\n\t\t.max_hsfreq = 80,\n\t\t.t_init = 79801,\n\t\t.tclk_miss = 4,\n\t\t.tclk_settle = 23,\n\t\t.ths_settle = 31,\n\t\t.tclk_prepare = 10,\n\t\t.ths_prepare = 19,\n\t},\n\t{\n\t\t.max_hsfreq = 125,\n\t\t.t_init = 79801,\n\t\t.tclk_miss = 4,\n\t\t.tclk_settle = 23,\n\t\t.ths_settle = 28,\n\t\t.tclk_prepare = 10,\n\t\t.ths_prepare = 19,\n\t},\n\t{\n\t\t.max_hsfreq = 250,\n\t\t.t_init = 79801,\n\t\t.tclk_miss = 4,\n\t\t.tclk_settle = 23,\n\t\t.ths_settle = 22,\n\t\t.tclk_prepare = 10,\n\t\t.ths_prepare = 16,\n\t},\n\t{\n\t\t.max_hsfreq = 360,\n\t\t.t_init = 79801,\n\t\t.tclk_miss = 4,\n\t\t.tclk_settle = 18,\n\t\t.ths_settle = 19,\n\t\t.tclk_prepare = 10,\n\t\t.ths_prepare = 10,\n\t},\n\t{\n\t\t.max_hsfreq = 1500,\n\t\t.t_init = 79801,\n\t\t.tclk_miss = 4,\n\t\t.tclk_settle = 18,\n\t\t.ths_settle = 18,\n\t\t.tclk_prepare = 10,\n\t\t.ths_prepare = 10,\n\t},\n};\n\nstruct rzg2l_csi2_format {\n\tu32 code;\n\tunsigned int datatype;\n\tunsigned int bpp;\n};\n\nstatic const struct rzg2l_csi2_format rzg2l_csi2_formats[] = {\n\t{ .code = MEDIA_BUS_FMT_UYVY8_1X16,\t.datatype = 0x1e, .bpp = 16 },\n};\n\nstatic inline struct rzg2l_csi2 *sd_to_csi2(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct rzg2l_csi2, subdev);\n}\n\nstatic const struct rzg2l_csi2_format *rzg2l_csi2_code_to_fmt(unsigned int code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rzg2l_csi2_formats); i++)\n\t\tif (rzg2l_csi2_formats[i].code == code)\n\t\t\treturn &rzg2l_csi2_formats[i];\n\n\treturn NULL;\n}\n\nstatic inline struct rzg2l_csi2 *notifier_to_csi2(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct rzg2l_csi2, notifier);\n}\n\nstatic u32 rzg2l_csi2_read(struct rzg2l_csi2 *csi2, unsigned int reg)\n{\n\treturn ioread32(csi2->base + reg);\n}\n\nstatic void rzg2l_csi2_write(struct rzg2l_csi2 *csi2, unsigned int reg,\n\t\t\t     u32 data)\n{\n\tiowrite32(data, csi2->base + reg);\n}\n\nstatic void rzg2l_csi2_set(struct rzg2l_csi2 *csi2, unsigned int reg, u32 set)\n{\n\trzg2l_csi2_write(csi2, reg, rzg2l_csi2_read(csi2, reg) | set);\n}\n\nstatic void rzg2l_csi2_clr(struct rzg2l_csi2 *csi2, unsigned int reg, u32 clr)\n{\n\trzg2l_csi2_write(csi2, reg, rzg2l_csi2_read(csi2, reg) & ~clr);\n}\n\nstatic int rzg2l_csi2_calc_mbps(struct rzg2l_csi2 *csi2)\n{\n\tstruct v4l2_subdev *source = csi2->remote_source;\n\tconst struct rzg2l_csi2_format *format;\n\tconst struct v4l2_mbus_framefmt *fmt;\n\tstruct v4l2_subdev_state *state;\n\tstruct v4l2_ctrl *ctrl;\n\tu64 mbps;\n\n\t \n\tctrl = v4l2_ctrl_find(source->ctrl_handler, V4L2_CID_PIXEL_RATE);\n\tif (!ctrl) {\n\t\tdev_err(csi2->dev, \"no pixel rate control in subdev %s\\n\",\n\t\t\tsource->name);\n\t\treturn -EINVAL;\n\t}\n\n\tstate = v4l2_subdev_lock_and_get_active_state(&csi2->subdev);\n\tfmt = v4l2_subdev_get_pad_format(&csi2->subdev, state, RZG2L_CSI2_SINK);\n\tformat = rzg2l_csi2_code_to_fmt(fmt->code);\n\tv4l2_subdev_unlock_state(state);\n\n\t \n\tmbps = v4l2_ctrl_g_ctrl_int64(ctrl) * format->bpp;\n\tdo_div(mbps, csi2->lanes * 1000000);\n\n\treturn mbps;\n}\n\n \n\nstatic int rzg2l_csi2_dphy_disable(struct rzg2l_csi2 *csi2)\n{\n\tint ret;\n\n\t \n\tret = reset_control_assert(csi2->cmn_rstb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tclk_disable_unprepare(csi2->sysclk);\n\n\t \n\trzg2l_csi2_clr(csi2, CSIDPHYCTRL0, CSIDPHYCTRL0_EN_LDO1200);\n\n\t \n\trzg2l_csi2_clr(csi2, CSIDPHYCTRL0, CSIDPHYCTRL0_EN_BGR);\n\n\tcsi2->dphy_enabled = false;\n\n\treturn 0;\n}\n\nstatic int rzg2l_csi2_dphy_enable(struct rzg2l_csi2 *csi2)\n{\n\tconst struct rzg2l_csi2_timings *dphy_timing;\n\tu32 dphytim0, dphytim1;\n\tunsigned int i;\n\tint mbps;\n\tint ret;\n\n\tmbps = rzg2l_csi2_calc_mbps(csi2);\n\tif (mbps < 0)\n\t\treturn mbps;\n\n\tcsi2->hsfreq = mbps;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rzg2l_csi2_global_timings); ++i) {\n\t\tdphy_timing = &rzg2l_csi2_global_timings[i];\n\n\t\tif (csi2->hsfreq <= dphy_timing->max_hsfreq)\n\t\t\tbreak;\n\t}\n\n\tif (i >= ARRAY_SIZE(rzg2l_csi2_global_timings))\n\t\treturn -EINVAL;\n\n\t \n\tdphytim0 = CSIDPHYTIM0_TCLK_MISS(dphy_timing->tclk_miss) |\n\t\t\tCSIDPHYTIM0_T_INIT(dphy_timing->t_init);\n\tdphytim1 = CSIDPHYTIM1_THS_PREPARE(dphy_timing->ths_prepare) |\n\t\t\tCSIDPHYTIM1_TCLK_PREPARE(dphy_timing->tclk_prepare) |\n\t\t\tCSIDPHYTIM1_THS_SETTLE(dphy_timing->ths_settle) |\n\t\t\tCSIDPHYTIM1_TCLK_SETTLE(dphy_timing->tclk_settle);\n\trzg2l_csi2_write(csi2, CSIDPHYTIM0, dphytim0);\n\trzg2l_csi2_write(csi2, CSIDPHYTIM1, dphytim1);\n\n\t \n\trzg2l_csi2_write(csi2, CSIDPHYSKW0, CSIDPHYSKW0_DEFAULT_SKW);\n\n\t \n\trzg2l_csi2_set(csi2, CSIDPHYCTRL0, CSIDPHYCTRL0_EN_BGR);\n\n\t \n\tusleep_range(20, 40);\n\n\t \n\trzg2l_csi2_set(csi2, CSIDPHYCTRL0, CSIDPHYCTRL0_EN_LDO1200);\n\n\t \n\tusleep_range(10, 20);\n\n\t \n\tret = clk_prepare_enable(csi2->sysclk);\n\tif (ret)\n\t\trzg2l_csi2_dphy_disable(csi2);\n\n\tcsi2->dphy_enabled = true;\n\n\treturn ret;\n}\n\nstatic int rzg2l_csi2_dphy_setting(struct v4l2_subdev *sd, bool on)\n{\n\tstruct rzg2l_csi2 *csi2 = sd_to_csi2(sd);\n\n\tif (on)\n\t\treturn rzg2l_csi2_dphy_enable(csi2);\n\n\treturn rzg2l_csi2_dphy_disable(csi2);\n}\n\nstatic void rzg2l_csi2_mipi_link_enable(struct rzg2l_csi2 *csi2)\n{\n\tunsigned long vclk_rate = csi2->vclk_rate / HZ_PER_MHZ;\n\tu32 frrskw, frrclk, frrskw_coeff, frrclk_coeff;\n\n\t \n\trzg2l_csi2_write(csi2, CSI2nMCT0, CSI2nMCT0_VDLN(csi2->lanes));\n\n\tfrrskw_coeff = 3 * vclk_rate * 8;\n\tfrrclk_coeff = frrskw_coeff / 2;\n\tfrrskw = DIV_ROUND_UP(frrskw_coeff, csi2->hsfreq);\n\tfrrclk = DIV_ROUND_UP(frrclk_coeff, csi2->hsfreq);\n\trzg2l_csi2_write(csi2, CSI2nMCT2, CSI2nMCT2_FRRSKW(frrskw) |\n\t\t\t CSI2nMCT2_FRRCLK(frrclk));\n\n\t \n\trzg2l_csi2_write(csi2, CSI2nDTEL, 0xf778ff0f);\n\trzg2l_csi2_write(csi2, CSI2nDTEH, 0x00ffff1f);\n\n\t \n\trzg2l_csi2_write(csi2, CSI2nMCT3, CSI2nMCT3_RXEN);\n}\n\nstatic void rzg2l_csi2_mipi_link_disable(struct rzg2l_csi2 *csi2)\n{\n\tunsigned int timeout = VSRSTS_RETRIES;\n\n\t \n\trzg2l_csi2_clr(csi2, CSI2nMCT3, CSI2nMCT3_RXEN);\n\n\t \n\trzg2l_csi2_write(csi2, CSI2nRTCT, CSI2nRTCT_VSRST);\n\n\t \n\twhile (--timeout) {\n\t\tif (!(rzg2l_csi2_read(csi2, CSI2nRTST) & CSI2nRTST_VSRSTS))\n\t\t\tbreak;\n\t\tusleep_range(100, 200);\n\t}\n\n\tif (!timeout)\n\t\tdev_err(csi2->dev, \"Clearing CSI2nRTST.VSRSTS timed out\\n\");\n}\n\nstatic int rzg2l_csi2_mipi_link_setting(struct v4l2_subdev *sd, bool on)\n{\n\tstruct rzg2l_csi2 *csi2 = sd_to_csi2(sd);\n\n\tif (on)\n\t\trzg2l_csi2_mipi_link_enable(csi2);\n\telse\n\t\trzg2l_csi2_mipi_link_disable(csi2);\n\n\treturn 0;\n}\n\nstatic int rzg2l_csi2_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct rzg2l_csi2 *csi2 = sd_to_csi2(sd);\n\tint s_stream_ret = 0;\n\tint ret;\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(csi2->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = rzg2l_csi2_mipi_link_setting(sd, 1);\n\t\tif (ret)\n\t\t\tgoto err_pm_put;\n\n\t\tret = reset_control_deassert(csi2->cmn_rstb);\n\t\tif (ret)\n\t\t\tgoto err_mipi_link_disable;\n\t}\n\n\tret = v4l2_subdev_call(csi2->remote_source, video, s_stream, enable);\n\tif (ret)\n\t\ts_stream_ret = ret;\n\n\tif (enable && ret)\n\t\tgoto err_assert_rstb;\n\n\tif (!enable) {\n\t\tret = rzg2l_csi2_dphy_setting(sd, 0);\n\t\tif (ret && !s_stream_ret)\n\t\t\ts_stream_ret = ret;\n\t\tret = rzg2l_csi2_mipi_link_setting(sd, 0);\n\t\tif (ret && !s_stream_ret)\n\t\t\ts_stream_ret = ret;\n\n\t\tpm_runtime_put_sync(csi2->dev);\n\t}\n\n\treturn s_stream_ret;\n\nerr_assert_rstb:\n\treset_control_assert(csi2->cmn_rstb);\nerr_mipi_link_disable:\n\trzg2l_csi2_mipi_link_setting(sd, 0);\nerr_pm_put:\n\tpm_runtime_put_sync(csi2->dev);\n\treturn ret;\n}\n\nstatic int rzg2l_csi2_pre_streamon(struct v4l2_subdev *sd, u32 flags)\n{\n\treturn rzg2l_csi2_dphy_setting(sd, 1);\n}\n\nstatic int rzg2l_csi2_post_streamoff(struct v4l2_subdev *sd)\n{\n\tstruct rzg2l_csi2 *csi2 = sd_to_csi2(sd);\n\n\t \n\tif (csi2->dphy_enabled)\n\t\treturn rzg2l_csi2_dphy_setting(sd, 0);\n\n\treturn 0;\n}\n\nstatic int rzg2l_csi2_set_format(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *state,\n\t\t\t\t struct v4l2_subdev_format *fmt)\n{\n\tstruct v4l2_mbus_framefmt *src_format;\n\tstruct v4l2_mbus_framefmt *sink_format;\n\n\tsrc_format = v4l2_subdev_get_pad_format(sd, state, RZG2L_CSI2_SOURCE);\n\tif (fmt->pad == RZG2L_CSI2_SOURCE) {\n\t\tfmt->format = *src_format;\n\t\treturn 0;\n\t}\n\n\tsink_format = v4l2_subdev_get_pad_format(sd, state, RZG2L_CSI2_SINK);\n\n\tif (!rzg2l_csi2_code_to_fmt(fmt->format.code))\n\t\tsink_format->code = rzg2l_csi2_formats[0].code;\n\telse\n\t\tsink_format->code = fmt->format.code;\n\n\tsink_format->field = V4L2_FIELD_NONE;\n\tsink_format->colorspace = fmt->format.colorspace;\n\tsink_format->xfer_func = fmt->format.xfer_func;\n\tsink_format->ycbcr_enc = fmt->format.ycbcr_enc;\n\tsink_format->quantization = fmt->format.quantization;\n\tsink_format->width = clamp_t(u32, fmt->format.width,\n\t\t\t\t     RZG2L_CSI2_MIN_WIDTH, RZG2L_CSI2_MAX_WIDTH);\n\tsink_format->height = clamp_t(u32, fmt->format.height,\n\t\t\t\t      RZG2L_CSI2_MIN_HEIGHT, RZG2L_CSI2_MAX_HEIGHT);\n\tfmt->format = *sink_format;\n\n\t \n\t*src_format = *sink_format;\n\n\treturn 0;\n}\n\nstatic int rzg2l_csi2_init_config(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_subdev_format fmt = { .pad = RZG2L_CSI2_SINK, };\n\n\tfmt.format.width = RZG2L_CSI2_DEFAULT_WIDTH;\n\tfmt.format.height = RZG2L_CSI2_DEFAULT_HEIGHT;\n\tfmt.format.field = V4L2_FIELD_NONE;\n\tfmt.format.code = RZG2L_CSI2_DEFAULT_FMT;\n\tfmt.format.colorspace = V4L2_COLORSPACE_SRGB;\n\tfmt.format.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tfmt.format.quantization = V4L2_QUANTIZATION_DEFAULT;\n\tfmt.format.xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\n\treturn rzg2l_csi2_set_format(sd, sd_state, &fmt);\n}\n\nstatic int rzg2l_csi2_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= ARRAY_SIZE(rzg2l_csi2_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = rzg2l_csi2_formats[code->index].code;\n\n\treturn 0;\n}\n\nstatic int rzg2l_csi2_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t\t      struct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tfse->min_width = RZG2L_CSI2_MIN_WIDTH;\n\tfse->min_height = RZG2L_CSI2_MIN_HEIGHT;\n\tfse->max_width = RZG2L_CSI2_MAX_WIDTH;\n\tfse->max_height = RZG2L_CSI2_MAX_HEIGHT;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops rzg2l_csi2_video_ops = {\n\t.s_stream = rzg2l_csi2_s_stream,\n\t.pre_streamon = rzg2l_csi2_pre_streamon,\n\t.post_streamoff = rzg2l_csi2_post_streamoff,\n};\n\nstatic const struct v4l2_subdev_pad_ops rzg2l_csi2_pad_ops = {\n\t.enum_mbus_code = rzg2l_csi2_enum_mbus_code,\n\t.init_cfg = rzg2l_csi2_init_config,\n\t.enum_frame_size = rzg2l_csi2_enum_frame_size,\n\t.set_fmt = rzg2l_csi2_set_format,\n\t.get_fmt = v4l2_subdev_get_fmt,\n};\n\nstatic const struct v4l2_subdev_ops rzg2l_csi2_subdev_ops = {\n\t.video\t= &rzg2l_csi2_video_ops,\n\t.pad\t= &rzg2l_csi2_pad_ops,\n};\n\n \n\nstatic int rzg2l_csi2_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t   struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_async_connection *asd)\n{\n\tstruct rzg2l_csi2 *csi2 = notifier_to_csi2(notifier);\n\n\tcsi2->remote_source = subdev;\n\n\tdev_dbg(csi2->dev, \"Bound subdev: %s pad\\n\", subdev->name);\n\n\treturn media_create_pad_link(&subdev->entity, RZG2L_CSI2_SINK,\n\t\t\t\t     &csi2->subdev.entity, 0,\n\t\t\t\t     MEDIA_LNK_FL_ENABLED |\n\t\t\t\t     MEDIA_LNK_FL_IMMUTABLE);\n}\n\nstatic void rzg2l_csi2_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\t     struct v4l2_subdev *subdev,\n\t\t\t\t     struct v4l2_async_connection *asd)\n{\n\tstruct rzg2l_csi2 *csi2 = notifier_to_csi2(notifier);\n\n\tcsi2->remote_source = NULL;\n\n\tdev_dbg(csi2->dev, \"Unbind subdev %s\\n\", subdev->name);\n}\n\nstatic const struct v4l2_async_notifier_operations rzg2l_csi2_notify_ops = {\n\t.bound = rzg2l_csi2_notify_bound,\n\t.unbind = rzg2l_csi2_notify_unbind,\n};\n\nstatic int rzg2l_csi2_parse_v4l2(struct rzg2l_csi2 *csi2,\n\t\t\t\t struct v4l2_fwnode_endpoint *vep)\n{\n\t \n\tif (vep->base.port || vep->base.id)\n\t\treturn -ENOTCONN;\n\n\tcsi2->lanes = vep->bus.mipi_csi2.num_data_lanes;\n\n\treturn 0;\n}\n\nstatic int rzg2l_csi2_parse_dt(struct rzg2l_csi2 *csi2)\n{\n\tstruct v4l2_fwnode_endpoint v4l2_ep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY\n\t};\n\tstruct v4l2_async_connection *asd;\n\tstruct fwnode_handle *fwnode;\n\tstruct fwnode_handle *ep;\n\tint ret;\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(csi2->dev), 0, 0, 0);\n\tif (!ep) {\n\t\tdev_err(csi2->dev, \"Not connected to subdevice\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(ep, &v4l2_ep);\n\tif (ret) {\n\t\tdev_err(csi2->dev, \"Could not parse v4l2 endpoint\\n\");\n\t\tfwnode_handle_put(ep);\n\t\treturn -EINVAL;\n\t}\n\n\tret = rzg2l_csi2_parse_v4l2(csi2, &v4l2_ep);\n\tif (ret) {\n\t\tfwnode_handle_put(ep);\n\t\treturn ret;\n\t}\n\n\tfwnode = fwnode_graph_get_remote_endpoint(ep);\n\tfwnode_handle_put(ep);\n\n\tv4l2_async_subdev_nf_init(&csi2->notifier, &csi2->subdev);\n\tcsi2->notifier.ops = &rzg2l_csi2_notify_ops;\n\n\tasd = v4l2_async_nf_add_fwnode(&csi2->notifier, fwnode,\n\t\t\t\t       struct v4l2_async_connection);\n\tfwnode_handle_put(fwnode);\n\tif (IS_ERR(asd))\n\t\treturn PTR_ERR(asd);\n\n\tret = v4l2_async_nf_register(&csi2->notifier);\n\tif (ret)\n\t\tv4l2_async_nf_cleanup(&csi2->notifier);\n\n\treturn ret;\n}\n\nstatic int rzg2l_validate_csi2_lanes(struct rzg2l_csi2 *csi2)\n{\n\tint lanes;\n\tint ret;\n\n\tif (csi2->lanes != 1 && csi2->lanes != 2 && csi2->lanes != 4) {\n\t\tdev_err(csi2->dev, \"Unsupported number of data-lanes: %u\\n\",\n\t\t\tcsi2->lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tret = pm_runtime_resume_and_get(csi2->dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlanes = (rzg2l_csi2_read(csi2, CSI2nMCG) & CSI2nMCG_SDLN) >> 8;\n\tif (lanes < csi2->lanes) {\n\t\tdev_err(csi2->dev,\n\t\t\t\"Failed to support %d data lanes\\n\", csi2->lanes);\n\t\tret = -EINVAL;\n\t}\n\n\tpm_runtime_put_sync(csi2->dev);\n\n\treturn ret;\n}\n\n \n\nstatic const struct media_entity_operations rzg2l_csi2_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic int rzg2l_csi2_probe(struct platform_device *pdev)\n{\n\tstruct rzg2l_csi2 *csi2;\n\tstruct clk *vclk;\n\tint ret;\n\n\tcsi2 = devm_kzalloc(&pdev->dev, sizeof(*csi2), GFP_KERNEL);\n\tif (!csi2)\n\t\treturn -ENOMEM;\n\n\tcsi2->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(csi2->base))\n\t\treturn PTR_ERR(csi2->base);\n\n\tcsi2->cmn_rstb = devm_reset_control_get_exclusive(&pdev->dev, \"cmn-rstb\");\n\tif (IS_ERR(csi2->cmn_rstb))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(csi2->cmn_rstb),\n\t\t\t\t     \"Failed to get cpg cmn-rstb\\n\");\n\n\tcsi2->presetn = devm_reset_control_get_shared(&pdev->dev, \"presetn\");\n\tif (IS_ERR(csi2->presetn))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(csi2->presetn),\n\t\t\t\t     \"Failed to get cpg presetn\\n\");\n\n\tcsi2->sysclk = devm_clk_get(&pdev->dev, \"system\");\n\tif (IS_ERR(csi2->sysclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(csi2->sysclk),\n\t\t\t\t     \"Failed to get system clk\\n\");\n\n\tvclk = clk_get(&pdev->dev, \"video\");\n\tif (IS_ERR(vclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(vclk),\n\t\t\t\t     \"Failed to get video clock\\n\");\n\tcsi2->vclk_rate = clk_get_rate(vclk);\n\tclk_put(vclk);\n\n\tcsi2->dev = &pdev->dev;\n\n\tplatform_set_drvdata(pdev, csi2);\n\n\tret = rzg2l_csi2_parse_dt(csi2);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = rzg2l_validate_csi2_lanes(csi2);\n\tif (ret)\n\t\tgoto error_pm;\n\n\tcsi2->subdev.dev = &pdev->dev;\n\tv4l2_subdev_init(&csi2->subdev, &rzg2l_csi2_subdev_ops);\n\tv4l2_set_subdevdata(&csi2->subdev, &pdev->dev);\n\tsnprintf(csi2->subdev.name, sizeof(csi2->subdev.name),\n\t\t \"csi-%s\", dev_name(&pdev->dev));\n\tcsi2->subdev.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tcsi2->subdev.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tcsi2->subdev.entity.ops = &rzg2l_csi2_entity_ops;\n\n\tcsi2->pads[RZG2L_CSI2_SINK].flags = MEDIA_PAD_FL_SINK;\n\t \n\tcsi2->pads[RZG2L_CSI2_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&csi2->subdev.entity, 2, csi2->pads);\n\tif (ret)\n\t\tgoto error_pm;\n\n\tret = v4l2_subdev_init_finalize(&csi2->subdev);\n\tif (ret < 0)\n\t\tgoto error_async;\n\n\tret = v4l2_async_register_subdev(&csi2->subdev);\n\tif (ret < 0)\n\t\tgoto error_subdev;\n\n\treturn 0;\n\nerror_subdev:\n\tv4l2_subdev_cleanup(&csi2->subdev);\nerror_async:\n\tv4l2_async_nf_unregister(&csi2->notifier);\n\tv4l2_async_nf_cleanup(&csi2->notifier);\n\tmedia_entity_cleanup(&csi2->subdev.entity);\nerror_pm:\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void rzg2l_csi2_remove(struct platform_device *pdev)\n{\n\tstruct rzg2l_csi2 *csi2 = platform_get_drvdata(pdev);\n\n\tv4l2_async_nf_unregister(&csi2->notifier);\n\tv4l2_async_nf_cleanup(&csi2->notifier);\n\tv4l2_async_unregister_subdev(&csi2->subdev);\n\tv4l2_subdev_cleanup(&csi2->subdev);\n\tmedia_entity_cleanup(&csi2->subdev.entity);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused rzg2l_csi2_pm_runtime_suspend(struct device *dev)\n{\n\tstruct rzg2l_csi2 *csi2 = dev_get_drvdata(dev);\n\n\treset_control_assert(csi2->presetn);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rzg2l_csi2_pm_runtime_resume(struct device *dev)\n{\n\tstruct rzg2l_csi2 *csi2 = dev_get_drvdata(dev);\n\n\treturn reset_control_deassert(csi2->presetn);\n}\n\nstatic const struct dev_pm_ops rzg2l_csi2_pm_ops = {\n\tSET_RUNTIME_PM_OPS(rzg2l_csi2_pm_runtime_suspend, rzg2l_csi2_pm_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id rzg2l_csi2_of_table[] = {\n\t{ .compatible = \"renesas,rzg2l-csi2\", },\n\t{   }\n};\n\nstatic struct platform_driver rzg2l_csi2_pdrv = {\n\t.remove_new = rzg2l_csi2_remove,\n\t.probe\t= rzg2l_csi2_probe,\n\t.driver\t= {\n\t\t.name = \"rzg2l-csi2\",\n\t\t.of_match_table = rzg2l_csi2_of_table,\n\t\t.pm = &rzg2l_csi2_pm_ops,\n\t},\n};\n\nmodule_platform_driver(rzg2l_csi2_pdrv);\n\nMODULE_AUTHOR(\"Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>\");\nMODULE_DESCRIPTION(\"Renesas RZ/G2L MIPI CSI2 receiver driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}