{
  "module_name": "rzg2l-video.c",
  "hash_id": "6e8370ef97a5d35b790f7a3c312c3b9e43796088a0c83b0a8f0bb149ba202c40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/rzg2l-cru/rzg2l-video.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"rzg2l-cru.h\"\n\n \n\n \n#define CRUnCTRL\t\t\t0x0\n#define CRUnCTRL_VINSEL(x)\t\t((x) << 0)\n\n \n#define CRUnIE\t\t\t\t0x4\n#define CRUnIE_EFE\t\t\tBIT(17)\n\n \n#define CRUnINTS\t\t\t0x8\n#define CRUnINTS_SFS\t\t\tBIT(16)\n\n \n#define CRUnRST\t\t\t\t0xc\n#define CRUnRST_VRESETN\t\t\tBIT(0)\n\n \n#define AMnMBxADDRL(x)\t\t\t(0x100 + ((x) * 8))\n\n \n#define AMnMBxADDRH(x)\t\t\t(0x104 + ((x) * 8))\n\n \n#define AMnMBVALID\t\t\t0x148\n#define AMnMBVALID_MBVALID(x)\t\tGENMASK(x, 0)\n\n \n#define AMnMBS\t\t\t\t0x14c\n#define AMnMBS_MBSTS\t\t\t0x7\n\n \n#define AMnFIFOPNTR\t\t\t0x168\n#define AMnFIFOPNTR_FIFOWPNTR\t\tGENMASK(7, 0)\n#define AMnFIFOPNTR_FIFORPNTR_Y\t\tGENMASK(23, 16)\n\n \n#define AMnAXISTP\t\t\t0x174\n#define AMnAXISTP_AXI_STOP\t\tBIT(0)\n\n \n#define AMnAXISTPACK\t\t\t0x178\n#define AMnAXISTPACK_AXI_STOP_ACK\tBIT(0)\n\n \n#define ICnEN\t\t\t\t0x200\n#define ICnEN_ICEN\t\t\tBIT(0)\n\n \n#define ICnMC\t\t\t\t0x208\n#define ICnMC_CSCTHR\t\t\tBIT(5)\n#define ICnMC_INF_YUV8_422\t\t(0x1e << 16)\n#define ICnMC_INF_USER\t\t\t(0x30 << 16)\n#define ICnMC_VCSEL(x)\t\t\t((x) << 22)\n#define ICnMC_INF_MASK\t\t\tGENMASK(21, 16)\n\n \n#define ICnMS\t\t\t\t0x254\n#define ICnMS_IA\t\t\tBIT(2)\n\n \n#define ICnDMR\t\t\t\t0x26c\n#define ICnDMR_YCMODE_UYVY\t\t(1 << 4)\n\n#define RZG2L_TIMEOUT_MS\t\t100\n#define RZG2L_RETRIES\t\t\t10\n\n#define RZG2L_CRU_DEFAULT_FORMAT\tV4L2_PIX_FMT_UYVY\n#define RZG2L_CRU_DEFAULT_WIDTH\t\tRZG2L_CRU_MIN_INPUT_WIDTH\n#define RZG2L_CRU_DEFAULT_HEIGHT\tRZG2L_CRU_MIN_INPUT_HEIGHT\n#define RZG2L_CRU_DEFAULT_FIELD\t\tV4L2_FIELD_NONE\n#define RZG2L_CRU_DEFAULT_COLORSPACE\tV4L2_COLORSPACE_SRGB\n\nstruct rzg2l_cru_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\n#define to_buf_list(vb2_buffer) \\\n\t(&container_of(vb2_buffer, struct rzg2l_cru_buffer, vb)->list)\n\n \nstatic void rzg2l_cru_write(struct rzg2l_cru_dev *cru, u32 offset, u32 value)\n{\n\tiowrite32(value, cru->base + offset);\n}\n\nstatic u32 rzg2l_cru_read(struct rzg2l_cru_dev *cru, u32 offset)\n{\n\treturn ioread32(cru->base + offset);\n}\n\n \nstatic void return_unused_buffers(struct rzg2l_cru_dev *cru,\n\t\t\t\t  enum vb2_buffer_state state)\n{\n\tstruct rzg2l_cru_buffer *buf, *node;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&cru->qlock, flags);\n\tfor (i = 0; i < cru->num_buf; i++) {\n\t\tif (cru->queue_buf[i]) {\n\t\t\tvb2_buffer_done(&cru->queue_buf[i]->vb2_buf,\n\t\t\t\t\tstate);\n\t\t\tcru->queue_buf[i] = NULL;\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(buf, node, &cru->buf_list, list) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t\tlist_del(&buf->list);\n\t}\n\tspin_unlock_irqrestore(&cru->qlock, flags);\n}\n\nstatic int rzg2l_cru_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\n\t\t\t\t unsigned int *nplanes, unsigned int sizes[],\n\t\t\t\t struct device *alloc_devs[])\n{\n\tstruct rzg2l_cru_dev *cru = vb2_get_drv_priv(vq);\n\n\t \n\tif (*nplanes)\n\t\treturn sizes[0] < cru->format.sizeimage ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = cru->format.sizeimage;\n\n\treturn 0;\n};\n\nstatic int rzg2l_cru_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct rzg2l_cru_dev *cru = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long size = cru->format.sizeimage;\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdev_err(cru->dev, \"buffer too small (%lu < %lu)\\n\",\n\t\t\tvb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, size);\n\n\treturn 0;\n}\n\nstatic void rzg2l_cru_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct rzg2l_cru_dev *cru = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cru->qlock, flags);\n\n\tlist_add_tail(to_buf_list(vbuf), &cru->buf_list);\n\n\tspin_unlock_irqrestore(&cru->qlock, flags);\n}\n\nstatic int rzg2l_cru_mc_validate_format(struct rzg2l_cru_dev *cru,\n\t\t\t\t\tstruct v4l2_subdev *sd,\n\t\t\t\t\tstruct media_pad *pad)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\tfmt.pad = pad->index;\n\tif (v4l2_subdev_call_state_active(sd, pad, get_fmt, &fmt))\n\t\treturn -EPIPE;\n\n\tswitch (fmt.format.code) {\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EPIPE;\n\t}\n\n\tswitch (fmt.format.field) {\n\tcase V4L2_FIELD_TOP:\n\tcase V4L2_FIELD_BOTTOM:\n\tcase V4L2_FIELD_NONE:\n\tcase V4L2_FIELD_INTERLACED_TB:\n\tcase V4L2_FIELD_INTERLACED_BT:\n\tcase V4L2_FIELD_INTERLACED:\n\tcase V4L2_FIELD_SEQ_TB:\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EPIPE;\n\t}\n\n\tif (fmt.format.width != cru->format.width ||\n\t    fmt.format.height != cru->format.height)\n\t\treturn -EPIPE;\n\n\treturn 0;\n}\n\nstatic void rzg2l_cru_set_slot_addr(struct rzg2l_cru_dev *cru,\n\t\t\t\t    int slot, dma_addr_t addr)\n{\n\t \n\tif (WARN_ON((addr) & RZG2L_CRU_HW_BUFFER_MASK))\n\t\treturn;\n\n\t \n\trzg2l_cru_write(cru, AMnMBxADDRL(slot), addr);\n\trzg2l_cru_write(cru, AMnMBxADDRH(slot), 0);\n}\n\n \nstatic void rzg2l_cru_fill_hw_slot(struct rzg2l_cru_dev *cru, int slot)\n{\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct rzg2l_cru_buffer *buf;\n\tdma_addr_t phys_addr;\n\n\t \n\tif (WARN_ON(cru->queue_buf[slot]))\n\t\treturn;\n\n\tdev_dbg(cru->dev, \"Filling HW slot: %d\\n\", slot);\n\n\tif (list_empty(&cru->buf_list)) {\n\t\tcru->queue_buf[slot] = NULL;\n\t\tphys_addr = cru->scratch_phys;\n\t} else {\n\t\t \n\t\tbuf = list_entry(cru->buf_list.next,\n\t\t\t\t struct rzg2l_cru_buffer, list);\n\t\tvbuf = &buf->vb;\n\t\tlist_del_init(to_buf_list(vbuf));\n\t\tcru->queue_buf[slot] = vbuf;\n\n\t\t \n\t\tphys_addr = vb2_dma_contig_plane_dma_addr(&vbuf->vb2_buf, 0);\n\t}\n\n\trzg2l_cru_set_slot_addr(cru, slot, phys_addr);\n}\n\nstatic void rzg2l_cru_initialize_axi(struct rzg2l_cru_dev *cru)\n{\n\tunsigned int slot;\n\n\t \n\trzg2l_cru_write(cru, AMnMBVALID, AMnMBVALID_MBVALID(cru->num_buf - 1));\n\n\tfor (slot = 0; slot < cru->num_buf; slot++)\n\t\trzg2l_cru_fill_hw_slot(cru, slot);\n}\n\nstatic void rzg2l_cru_csi2_setup(struct rzg2l_cru_dev *cru, bool *input_is_yuv,\n\t\t\t\t struct v4l2_mbus_framefmt *ip_sd_fmt)\n{\n\tu32 icnmc;\n\n\tswitch (ip_sd_fmt->code) {\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\ticnmc = ICnMC_INF_YUV8_422;\n\t\t*input_is_yuv = true;\n\t\tbreak;\n\tdefault:\n\t\t*input_is_yuv = false;\n\t\ticnmc = ICnMC_INF_USER;\n\t\tbreak;\n\t}\n\n\ticnmc |= (rzg2l_cru_read(cru, ICnMC) & ~ICnMC_INF_MASK);\n\n\t \n\ticnmc |= ICnMC_VCSEL(cru->csi.channel);\n\n\trzg2l_cru_write(cru, ICnMC, icnmc);\n}\n\nstatic int rzg2l_cru_initialize_image_conv(struct rzg2l_cru_dev *cru,\n\t\t\t\t\t   struct v4l2_mbus_framefmt *ip_sd_fmt)\n{\n\tbool output_is_yuv = false;\n\tbool input_is_yuv = false;\n\tu32 icndmr;\n\n\trzg2l_cru_csi2_setup(cru, &input_is_yuv, ip_sd_fmt);\n\n\t \n\tswitch (cru->format.pixelformat) {\n\tcase V4L2_PIX_FMT_UYVY:\n\t\ticndmr = ICnDMR_YCMODE_UYVY;\n\t\toutput_is_yuv = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cru->dev, \"Invalid pixelformat (0x%x)\\n\",\n\t\t\tcru->format.pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (output_is_yuv == input_is_yuv)\n\t\trzg2l_cru_write(cru, ICnMC,\n\t\t\t\trzg2l_cru_read(cru, ICnMC) | ICnMC_CSCTHR);\n\telse\n\t\trzg2l_cru_write(cru, ICnMC,\n\t\t\t\trzg2l_cru_read(cru, ICnMC) & (~ICnMC_CSCTHR));\n\n\t \n\trzg2l_cru_write(cru, ICnDMR, icndmr);\n\n\treturn 0;\n}\n\nvoid rzg2l_cru_stop_image_processing(struct rzg2l_cru_dev *cru)\n{\n\tu32 amnfifopntr, amnfifopntr_w, amnfifopntr_r_y;\n\tunsigned int retries = 0;\n\tunsigned long flags;\n\tu32 icnms;\n\n\tspin_lock_irqsave(&cru->qlock, flags);\n\n\t \n\trzg2l_cru_write(cru, CRUnIE, 0);\n\trzg2l_cru_write(cru, CRUnINTS, 0x001F0F0F);\n\n\t \n\trzg2l_cru_write(cru, ICnEN, 0);\n\n\t \n\twhile ((rzg2l_cru_read(cru, ICnMS) & ICnMS_IA) && retries++ < RZG2L_RETRIES) {\n\t\tspin_unlock_irqrestore(&cru->qlock, flags);\n\t\tmsleep(RZG2L_TIMEOUT_MS);\n\t\tspin_lock_irqsave(&cru->qlock, flags);\n\t}\n\n\ticnms = rzg2l_cru_read(cru, ICnMS) & ICnMS_IA;\n\tif (icnms)\n\t\tdev_err(cru->dev, \"Failed stop HW, something is seriously broken\\n\");\n\n\tcru->state = RZG2L_CRU_DMA_STOPPED;\n\n\t \n\tfor (retries = 5; retries > 0; retries--) {\n\t\tamnfifopntr = rzg2l_cru_read(cru, AMnFIFOPNTR);\n\n\t\tamnfifopntr_w = amnfifopntr & AMnFIFOPNTR_FIFOWPNTR;\n\t\tamnfifopntr_r_y =\n\t\t\t(amnfifopntr & AMnFIFOPNTR_FIFORPNTR_Y) >> 16;\n\t\tif (amnfifopntr_w == amnfifopntr_r_y)\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\t \n\tif (!retries)\n\t\tdev_err(cru->dev, \"Failed to empty FIFO\\n\");\n\n\t \n\trzg2l_cru_write(cru, AMnAXISTP, AMnAXISTP_AXI_STOP);\n\n\t \n\tfor (retries = 5; retries > 0; retries--) {\n\t\tif (rzg2l_cru_read(cru, AMnAXISTPACK) &\n\t\t\tAMnAXISTPACK_AXI_STOP_ACK)\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\t \n\tif (!retries)\n\t\tdev_err(cru->dev, \"Failed to stop AXI bus\\n\");\n\n\t \n\trzg2l_cru_write(cru, AMnAXISTP, 0);\n\n\t \n\treset_control_assert(cru->aresetn);\n\n\t \n\trzg2l_cru_write(cru, CRUnRST, 0);\n\n\tspin_unlock_irqrestore(&cru->qlock, flags);\n}\n\nint rzg2l_cru_start_image_processing(struct rzg2l_cru_dev *cru)\n{\n\tstruct v4l2_mbus_framefmt *fmt = rzg2l_cru_ip_get_src_fmt(cru);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cru->qlock, flags);\n\n\t \n\tret = rzg2l_cru_initialize_image_conv(cru, fmt);\n\tif (ret) {\n\t\tspin_unlock_irqrestore(&cru->qlock, flags);\n\t\treturn ret;\n\t}\n\n\t \n\trzg2l_cru_write(cru, CRUnCTRL, CRUnCTRL_VINSEL(0));\n\n\t \n\trzg2l_cru_write(cru, CRUnRST, CRUnRST_VRESETN);\n\n\t \n\trzg2l_cru_write(cru, CRUnIE, 0);\n\trzg2l_cru_write(cru, CRUnINTS, 0x001f000f);\n\n\t \n\trzg2l_cru_initialize_axi(cru);\n\n\t \n\trzg2l_cru_write(cru, CRUnIE, CRUnIE_EFE);\n\n\t \n\trzg2l_cru_write(cru, ICnEN, ICnEN_ICEN);\n\n\tspin_unlock_irqrestore(&cru->qlock, flags);\n\n\treturn 0;\n}\n\nvoid rzg2l_cru_vclk_unprepare(struct rzg2l_cru_dev *cru)\n{\n\tclk_disable_unprepare(cru->vclk);\n}\n\nint rzg2l_cru_vclk_prepare(struct rzg2l_cru_dev *cru)\n{\n\treturn clk_prepare_enable(cru->vclk);\n}\n\nstatic int rzg2l_cru_set_stream(struct rzg2l_cru_dev *cru, int on)\n{\n\tstruct media_pipeline *pipe;\n\tstruct v4l2_subdev *sd;\n\tstruct media_pad *pad;\n\tint ret;\n\n\tpad = media_pad_remote_pad_first(&cru->pad);\n\tif (!pad)\n\t\treturn -EPIPE;\n\n\tsd = media_entity_to_v4l2_subdev(pad->entity);\n\n\tif (!on) {\n\t\tint stream_off_ret = 0;\n\n\t\tret = v4l2_subdev_call(sd, video, s_stream, 0);\n\t\tif (ret)\n\t\t\tstream_off_ret = ret;\n\n\t\tret = v4l2_subdev_call(sd, video, post_streamoff);\n\t\tif (ret == -ENOIOCTLCMD)\n\t\t\tret = 0;\n\t\tif (ret && !stream_off_ret)\n\t\t\tstream_off_ret = ret;\n\n\t\tvideo_device_pipeline_stop(&cru->vdev);\n\n\t\tpm_runtime_put_sync(cru->dev);\n\t\tclk_disable_unprepare(cru->vclk);\n\n\t\treturn stream_off_ret;\n\t}\n\n\tret = pm_runtime_resume_and_get(cru->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(cru->vclk);\n\tif (ret)\n\t\tgoto err_pm_put;\n\n\tret = rzg2l_cru_mc_validate_format(cru, sd, pad);\n\tif (ret)\n\t\tgoto err_vclk_disable;\n\n\tpipe = media_entity_pipeline(&sd->entity) ? : &cru->vdev.pipe;\n\tret = video_device_pipeline_start(&cru->vdev, pipe);\n\tif (ret)\n\t\tgoto err_vclk_disable;\n\n\tret = v4l2_subdev_call(sd, video, pre_streamon, 0);\n\tif (ret == -ENOIOCTLCMD)\n\t\tret = 0;\n\tif (ret)\n\t\tgoto pipe_line_stop;\n\n\tret = v4l2_subdev_call(sd, video, s_stream, 1);\n\tif (ret == -ENOIOCTLCMD)\n\t\tret = 0;\n\tif (ret)\n\t\tgoto err_s_stream;\n\n\treturn 0;\n\nerr_s_stream:\n\tv4l2_subdev_call(sd, video, post_streamoff);\n\npipe_line_stop:\n\tvideo_device_pipeline_stop(&cru->vdev);\n\nerr_vclk_disable:\n\tclk_disable_unprepare(cru->vclk);\n\nerr_pm_put:\n\tpm_runtime_put_sync(cru->dev);\n\n\treturn ret;\n}\n\nstatic void rzg2l_cru_stop_streaming(struct rzg2l_cru_dev *cru)\n{\n\tcru->state = RZG2L_CRU_DMA_STOPPING;\n\n\trzg2l_cru_set_stream(cru, 0);\n}\n\nstatic irqreturn_t rzg2l_cru_irq(int irq, void *data)\n{\n\tstruct rzg2l_cru_dev *cru = data;\n\tunsigned int handled = 0;\n\tunsigned long flags;\n\tu32 irq_status;\n\tu32 amnmbs;\n\tint slot;\n\n\tspin_lock_irqsave(&cru->qlock, flags);\n\n\tirq_status = rzg2l_cru_read(cru, CRUnINTS);\n\tif (!irq_status)\n\t\tgoto done;\n\n\thandled = 1;\n\n\trzg2l_cru_write(cru, CRUnINTS, rzg2l_cru_read(cru, CRUnINTS));\n\n\t \n\tif (cru->state == RZG2L_CRU_DMA_STOPPED) {\n\t\tdev_dbg(cru->dev, \"IRQ while state stopped\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tif (cru->state == RZG2L_CRU_DMA_STOPPING) {\n\t\tif (irq_status & CRUnINTS_SFS)\n\t\t\tdev_dbg(cru->dev, \"IRQ while state stopping\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tamnmbs = rzg2l_cru_read(cru, AMnMBS);\n\tslot = amnmbs & AMnMBS_MBSTS;\n\n\t \n\tif (slot == 0)\n\t\tslot = cru->num_buf - 1;\n\telse\n\t\tslot--;\n\n\t \n\tif (cru->state == RZG2L_CRU_DMA_STARTING) {\n\t\tif (slot != 0) {\n\t\t\tdev_dbg(cru->dev, \"Starting sync slot: %d\\n\", slot);\n\t\t\tgoto done;\n\t\t}\n\n\t\tdev_dbg(cru->dev, \"Capture start synced!\\n\");\n\t\tcru->state = RZG2L_CRU_DMA_RUNNING;\n\t}\n\n\t \n\tif (cru->queue_buf[slot]) {\n\t\tcru->queue_buf[slot]->field = cru->format.field;\n\t\tcru->queue_buf[slot]->sequence = cru->sequence;\n\t\tcru->queue_buf[slot]->vb2_buf.timestamp = ktime_get_ns();\n\t\tvb2_buffer_done(&cru->queue_buf[slot]->vb2_buf,\n\t\t\t\tVB2_BUF_STATE_DONE);\n\t\tcru->queue_buf[slot] = NULL;\n\t} else {\n\t\t \n\t\tdev_dbg(cru->dev, \"Dropping frame %u\\n\", cru->sequence);\n\t}\n\n\tcru->sequence++;\n\n\t \n\trzg2l_cru_fill_hw_slot(cru, slot);\n\ndone:\n\tspin_unlock_irqrestore(&cru->qlock, flags);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic int rzg2l_cru_start_streaming_vq(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct rzg2l_cru_dev *cru = vb2_get_drv_priv(vq);\n\tint ret;\n\n\t \n\tret = reset_control_deassert(cru->aresetn);\n\tif (ret) {\n\t\tdev_err(cru->dev, \"failed to deassert aresetn\\n\");\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(cru->presetn);\n\tif (ret) {\n\t\treset_control_assert(cru->aresetn);\n\t\tdev_err(cru->dev, \"failed to deassert presetn\\n\");\n\t\treturn ret;\n\t}\n\n\tret = request_irq(cru->image_conv_irq, rzg2l_cru_irq,\n\t\t\t  IRQF_SHARED, KBUILD_MODNAME, cru);\n\tif (ret) {\n\t\tdev_err(cru->dev, \"failed to request irq\\n\");\n\t\tgoto assert_resets;\n\t}\n\n\t \n\tcru->scratch = dma_alloc_coherent(cru->dev, cru->format.sizeimage,\n\t\t\t\t\t  &cru->scratch_phys, GFP_KERNEL);\n\tif (!cru->scratch) {\n\t\treturn_unused_buffers(cru, VB2_BUF_STATE_QUEUED);\n\t\tdev_err(cru->dev, \"Failed to allocate scratch buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_image_conv_irq;\n\t}\n\n\tcru->sequence = 0;\n\n\tret = rzg2l_cru_set_stream(cru, 1);\n\tif (ret) {\n\t\treturn_unused_buffers(cru, VB2_BUF_STATE_QUEUED);\n\t\tgoto out;\n\t}\n\n\tcru->state = RZG2L_CRU_DMA_STARTING;\n\tdev_dbg(cru->dev, \"Starting to capture\\n\");\n\treturn 0;\n\nout:\n\tif (ret)\n\t\tdma_free_coherent(cru->dev, cru->format.sizeimage, cru->scratch,\n\t\t\t\t  cru->scratch_phys);\nfree_image_conv_irq:\n\tfree_irq(cru->image_conv_irq, cru);\n\nassert_resets:\n\treset_control_assert(cru->presetn);\n\treset_control_assert(cru->aresetn);\n\n\treturn ret;\n}\n\nstatic void rzg2l_cru_stop_streaming_vq(struct vb2_queue *vq)\n{\n\tstruct rzg2l_cru_dev *cru = vb2_get_drv_priv(vq);\n\n\trzg2l_cru_stop_streaming(cru);\n\n\t \n\tdma_free_coherent(cru->dev, cru->format.sizeimage,\n\t\t\t  cru->scratch, cru->scratch_phys);\n\n\tfree_irq(cru->image_conv_irq, cru);\n\treset_control_assert(cru->presetn);\n\n\treturn_unused_buffers(cru, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct vb2_ops rzg2l_cru_qops = {\n\t.queue_setup\t\t= rzg2l_cru_queue_setup,\n\t.buf_prepare\t\t= rzg2l_cru_buffer_prepare,\n\t.buf_queue\t\t= rzg2l_cru_buffer_queue,\n\t.start_streaming\t= rzg2l_cru_start_streaming_vq,\n\t.stop_streaming\t\t= rzg2l_cru_stop_streaming_vq,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nvoid rzg2l_cru_dma_unregister(struct rzg2l_cru_dev *cru)\n{\n\tmutex_destroy(&cru->lock);\n\n\tv4l2_device_unregister(&cru->v4l2_dev);\n\tvb2_queue_release(&cru->queue);\n}\n\nint rzg2l_cru_dma_register(struct rzg2l_cru_dev *cru)\n{\n\tstruct vb2_queue *q = &cru->queue;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tret = v4l2_device_register(cru->dev, &cru->v4l2_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&cru->lock);\n\tINIT_LIST_HEAD(&cru->buf_list);\n\n\tspin_lock_init(&cru->qlock);\n\n\tcru->state = RZG2L_CRU_DMA_STOPPED;\n\n\tfor (i = 0; i < RZG2L_CRU_HW_BUFFER_MAX; i++)\n\t\tcru->queue_buf[i] = NULL;\n\n\t \n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tq->lock = &cru->lock;\n\tq->drv_priv = cru;\n\tq->buf_struct_size = sizeof(struct rzg2l_cru_buffer);\n\tq->ops = &rzg2l_cru_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = 4;\n\tq->dev = cru->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret < 0) {\n\t\tdev_err(cru->dev, \"failed to initialize VB2 queue\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tmutex_destroy(&cru->lock);\n\tv4l2_device_unregister(&cru->v4l2_dev);\n\treturn ret;\n}\n\n \n\nstatic const struct v4l2_format_info rzg2l_cru_formats[] = {\n\t{\n\t\t.format = V4L2_PIX_FMT_UYVY,\n\t\t.bpp[0] = 2,\n\t},\n};\n\nconst struct v4l2_format_info *rzg2l_cru_format_from_pixel(u32 format)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rzg2l_cru_formats); i++)\n\t\tif (rzg2l_cru_formats[i].format == format)\n\t\t\treturn rzg2l_cru_formats + i;\n\n\treturn NULL;\n}\n\nstatic u32 rzg2l_cru_format_bytesperline(struct v4l2_pix_format *pix)\n{\n\tconst struct v4l2_format_info *fmt;\n\n\tfmt = rzg2l_cru_format_from_pixel(pix->pixelformat);\n\n\tif (WARN_ON(!fmt))\n\t\treturn -EINVAL;\n\n\treturn pix->width * fmt->bpp[0];\n}\n\nstatic u32 rzg2l_cru_format_sizeimage(struct v4l2_pix_format *pix)\n{\n\treturn pix->bytesperline * pix->height;\n}\n\nstatic void rzg2l_cru_format_align(struct rzg2l_cru_dev *cru,\n\t\t\t\t   struct v4l2_pix_format *pix)\n{\n\tif (!rzg2l_cru_format_from_pixel(pix->pixelformat))\n\t\tpix->pixelformat = RZG2L_CRU_DEFAULT_FORMAT;\n\n\tswitch (pix->field) {\n\tcase V4L2_FIELD_TOP:\n\tcase V4L2_FIELD_BOTTOM:\n\tcase V4L2_FIELD_NONE:\n\tcase V4L2_FIELD_INTERLACED_TB:\n\tcase V4L2_FIELD_INTERLACED_BT:\n\tcase V4L2_FIELD_INTERLACED:\n\t\tbreak;\n\tdefault:\n\t\tpix->field = RZG2L_CRU_DEFAULT_FIELD;\n\t\tbreak;\n\t}\n\n\t \n\tv4l_bound_align_image(&pix->width, 320, RZG2L_CRU_MAX_INPUT_WIDTH, 1,\n\t\t\t      &pix->height, 240, RZG2L_CRU_MAX_INPUT_HEIGHT, 2, 0);\n\n\tpix->bytesperline = rzg2l_cru_format_bytesperline(pix);\n\tpix->sizeimage = rzg2l_cru_format_sizeimage(pix);\n\n\tdev_dbg(cru->dev, \"Format %ux%u bpl: %u size: %u\\n\",\n\t\tpix->width, pix->height, pix->bytesperline, pix->sizeimage);\n}\n\nstatic void rzg2l_cru_try_format(struct rzg2l_cru_dev *cru,\n\t\t\t\t struct v4l2_pix_format *pix)\n{\n\t \n\tpix->colorspace = RZG2L_CRU_DEFAULT_COLORSPACE;\n\tpix->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(pix->colorspace);\n\tpix->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(pix->colorspace);\n\tpix->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true, pix->colorspace,\n\t\t\t\t\t\t\t  pix->ycbcr_enc);\n\n\trzg2l_cru_format_align(cru, pix);\n}\n\nstatic int rzg2l_cru_querycap(struct file *file, void *priv,\n\t\t\t      struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrscpy(cap->card, \"RZG2L_CRU\", sizeof(cap->card));\n\n\treturn 0;\n}\n\nstatic int rzg2l_cru_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_format *f)\n{\n\tstruct rzg2l_cru_dev *cru = video_drvdata(file);\n\n\trzg2l_cru_try_format(cru, &f->fmt.pix);\n\n\treturn 0;\n}\n\nstatic int rzg2l_cru_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct rzg2l_cru_dev *cru = video_drvdata(file);\n\n\tif (vb2_is_busy(&cru->queue))\n\t\treturn -EBUSY;\n\n\trzg2l_cru_try_format(cru, &f->fmt.pix);\n\n\tcru->format = f->fmt.pix;\n\n\treturn 0;\n}\n\nstatic int rzg2l_cru_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct rzg2l_cru_dev *cru = video_drvdata(file);\n\n\tf->fmt.pix = cru->format;\n\n\treturn 0;\n}\n\nstatic int rzg2l_cru_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t      struct v4l2_fmtdesc *f)\n{\n\tif (f->index >= ARRAY_SIZE(rzg2l_cru_formats))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = rzg2l_cru_formats[f->index].format;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops rzg2l_cru_ioctl_ops = {\n\t.vidioc_querycap\t\t= rzg2l_cru_querycap,\n\t.vidioc_try_fmt_vid_cap\t\t= rzg2l_cru_try_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= rzg2l_cru_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= rzg2l_cru_s_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_cap\t= rzg2l_cru_enum_fmt_vid_cap,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n};\n\n \n\nstatic int rzg2l_cru_open(struct file *file)\n{\n\tstruct rzg2l_cru_dev *cru = video_drvdata(file);\n\tint ret;\n\n\tret = mutex_lock_interruptible(&cru->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tfile->private_data = cru;\n\tret = v4l2_fh_open(file);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tmutex_unlock(&cru->lock);\n\n\treturn 0;\n\nerr_unlock:\n\tmutex_unlock(&cru->lock);\n\n\treturn ret;\n}\n\nstatic int rzg2l_cru_release(struct file *file)\n{\n\tstruct rzg2l_cru_dev *cru = video_drvdata(file);\n\tint ret;\n\n\tmutex_lock(&cru->lock);\n\n\t \n\tret = _vb2_fop_release(file, NULL);\n\n\tmutex_unlock(&cru->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_file_operations rzg2l_cru_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.open\t\t= rzg2l_cru_open,\n\t.release\t= rzg2l_cru_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.read\t\t= vb2_fop_read,\n};\n\nstatic void rzg2l_cru_v4l2_init(struct rzg2l_cru_dev *cru)\n{\n\tstruct video_device *vdev = &cru->vdev;\n\n\tvdev->v4l2_dev = &cru->v4l2_dev;\n\tvdev->queue = &cru->queue;\n\tsnprintf(vdev->name, sizeof(vdev->name), \"CRU output\");\n\tvdev->release = video_device_release_empty;\n\tvdev->lock = &cru->lock;\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\n\tvdev->device_caps |= V4L2_CAP_IO_MC;\n\tvdev->fops = &rzg2l_cru_fops;\n\tvdev->ioctl_ops = &rzg2l_cru_ioctl_ops;\n\n\t \n\tcru->format.pixelformat\t= RZG2L_CRU_DEFAULT_FORMAT;\n\tcru->format.width = RZG2L_CRU_DEFAULT_WIDTH;\n\tcru->format.height = RZG2L_CRU_DEFAULT_HEIGHT;\n\tcru->format.field = RZG2L_CRU_DEFAULT_FIELD;\n\tcru->format.colorspace = RZG2L_CRU_DEFAULT_COLORSPACE;\n\trzg2l_cru_format_align(cru, &cru->format);\n}\n\nvoid rzg2l_cru_video_unregister(struct rzg2l_cru_dev *cru)\n{\n\tmedia_device_unregister(&cru->mdev);\n\tvideo_unregister_device(&cru->vdev);\n}\n\nint rzg2l_cru_video_register(struct rzg2l_cru_dev *cru)\n{\n\tstruct video_device *vdev = &cru->vdev;\n\tint ret;\n\n\tif (video_is_registered(&cru->vdev)) {\n\t\tstruct media_entity *entity;\n\n\t\tentity = &cru->vdev.entity;\n\t\tif (!entity->graph_obj.mdev)\n\t\t\tentity->graph_obj.mdev = &cru->mdev;\n\t\treturn 0;\n\t}\n\n\trzg2l_cru_v4l2_init(cru);\n\tvideo_set_drvdata(vdev, cru);\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(cru->dev, \"Failed to register video device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = media_device_register(&cru->mdev);\n\tif (ret) {\n\t\tvideo_unregister_device(&cru->vdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}