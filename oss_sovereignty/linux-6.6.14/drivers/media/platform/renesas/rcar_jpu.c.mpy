{
  "module_name": "rcar_jpu.c",
  "hash_id": "bb306dbf168eac65465d89a924c6288b0507baa2c05a326a66e0741ab9d8d2a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/rcar_jpu.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/videodev2.h>\n#include <media/jpeg.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n\n#define DRV_NAME \"rcar_jpu\"\n\n \n#define JPU_JPEG_HDR_SIZE\t\t(ALIGN(0x258, L1_CACHE_BYTES))\n#define JPU_JPEG_MAX_BYTES_PER_PIXEL\t2\t \n#define JPU_JPEG_MIN_SIZE\t\t25\t \n#define JPU_JPEG_QTBL_SIZE\t\t0x40\n#define JPU_JPEG_HDCTBL_SIZE\t\t0x1c\n#define JPU_JPEG_HACTBL_SIZE\t\t0xb2\n#define JPU_JPEG_HEIGHT_OFFSET\t\t0x91\n#define JPU_JPEG_WIDTH_OFFSET\t\t0x93\n#define JPU_JPEG_SUBS_OFFSET\t\t0x97\n#define JPU_JPEG_QTBL_LUM_OFFSET\t0x07\n#define JPU_JPEG_QTBL_CHR_OFFSET\t0x4c\n#define JPU_JPEG_HDCTBL_LUM_OFFSET\t0xa4\n#define JPU_JPEG_HACTBL_LUM_OFFSET\t0xc5\n#define JPU_JPEG_HDCTBL_CHR_OFFSET\t0x17c\n#define JPU_JPEG_HACTBL_CHR_OFFSET\t0x19d\n#define JPU_JPEG_PADDING_OFFSET\t\t0x24f\n#define JPU_JPEG_LUM 0x00\n#define JPU_JPEG_CHR 0x01\n#define JPU_JPEG_DC  0x00\n#define JPU_JPEG_AC  0x10\n\n#define JPU_JPEG_422 0x21\n#define JPU_JPEG_420 0x22\n\n#define JPU_JPEG_DEFAULT_422_PIX_FMT V4L2_PIX_FMT_NV16M\n#define JPU_JPEG_DEFAULT_420_PIX_FMT V4L2_PIX_FMT_NV12M\n\n#define JPU_RESET_TIMEOUT\t100  \n#define JPU_JOB_TIMEOUT\t\t300  \n#define JPU_MAX_QUALITY\t\t4\n#define JPU_WIDTH_MIN\t\t16\n#define JPU_HEIGHT_MIN\t\t16\n#define JPU_WIDTH_MAX\t\t4096\n#define JPU_HEIGHT_MAX\t\t4096\n#define JPU_MEMALIGN\t\t8\n\n \n#define JPU_FMT_TYPE_OUTPUT\t0\n#define JPU_FMT_TYPE_CAPTURE\t1\n#define JPU_ENC_CAPTURE\t\t(1 << 0)\n#define JPU_ENC_OUTPUT\t\t(1 << 1)\n#define JPU_DEC_CAPTURE\t\t(1 << 2)\n#define JPU_DEC_OUTPUT\t\t(1 << 3)\n\n \n\n \n#define JCMOD\t0x00\n#define JCMOD_PCTR\t\t(1 << 7)\n#define JCMOD_MSKIP_ENABLE\t(1 << 5)\n#define JCMOD_DSP_ENC\t\t(0 << 3)\n#define JCMOD_DSP_DEC\t\t(1 << 3)\n#define JCMOD_REDU\t\t(7 << 0)\n#define JCMOD_REDU_422\t\t(1 << 0)\n#define JCMOD_REDU_420\t\t(2 << 0)\n\n \n#define JCCMD\t0x04\n#define JCCMD_SRST\t(1 << 12)\n#define JCCMD_JEND\t(1 << 2)\n#define JCCMD_JSRT\t(1 << 0)\n\n \n#define JCQTN\t0x0c\n#define JCQTN_SHIFT(t)\t\t(((t) - 1) << 1)\n\n \n#define JCHTN\t0x10\n#define JCHTN_AC_SHIFT(t)\t(((t) << 1) - 1)\n#define JCHTN_DC_SHIFT(t)\t(((t) - 1) << 1)\n\n#define JCVSZU\t0x1c  \n#define JCVSZD\t0x20  \n#define JCHSZU\t0x24  \n#define JCHSZD\t0x28  \n#define JCSZ_MASK 0xff  \n\n#define JCDTCU\t0x2c  \n#define JCDTCM\t0x30  \n#define JCDTCD\t0x34  \n\n \n#define JINTE\t0x38\n#define JINTE_ERR\t\t(7 << 5)  \n#define JINTE_TRANSF_COMPL\t(1 << 10)\n\n \n#define JINTS\t0x3c\n#define JINTS_MASK\t0x7c68\n#define JINTS_ERR\t\t(1 << 5)\n#define JINTS_PROCESS_COMPL\t(1 << 6)\n#define JINTS_TRANSF_COMPL\t(1 << 10)\n\n#define JCDERR\t0x40  \n#define JCDERR_MASK\t0xf  \n\n \n#define JIFECNT\t0x70\n#define JIFECNT_INFT_422\t0\n#define JIFECNT_INFT_420\t1\n#define JIFECNT_SWAP_WB\t\t(3 << 4)  \n\n#define JIFESYA1\t0x74\t \n#define JIFESCA1\t0x78\t \n#define JIFESYA2\t0x7c\t \n#define JIFESCA2\t0x80\t \n#define JIFESMW\t\t0x84\t \n#define JIFESVSZ\t0x88\t \n#define JIFESHSZ\t0x8c\t \n#define JIFEDA1\t\t0x90\t \n#define JIFEDA2\t\t0x94\t \n\n \n#define JIFDCNT\t0xa0\n#define JIFDCNT_SWAP_WB\t\t(3 << 1)  \n\n#define JIFDSA1\t\t0xa4\t \n#define JIFDDMW\t\t0xb0\t \n#define JIFDDVSZ\t0xb4\t \n#define JIFDDHSZ\t0xb8\t \n#define JIFDDYA1\t0xbc\t \n#define JIFDDCA1\t0xc0\t \n\n#define JCQTBL(n)\t(0x10000 + (n) * 0x40)\t \n#define JCHTBD(n)\t(0x10100 + (n) * 0x100)\t \n#define JCHTBA(n)\t(0x10120 + (n) * 0x100)\t \n\n \nstruct jpu {\n\tstruct mutex\tmutex;\n\tspinlock_t\tlock;\n\tstruct v4l2_device\tv4l2_dev;\n\tstruct video_device\tvfd_encoder;\n\tstruct video_device\tvfd_decoder;\n\tstruct v4l2_m2m_dev\t*m2m_dev;\n\tstruct jpu_ctx\t\t*curr;\n\n\tvoid __iomem\t\t*regs;\n\tunsigned int\t\tirq;\n\tstruct clk\t\t*clk;\n\tstruct device\t\t*dev;\n\tint\t\t\tref_count;\n};\n\n \nstruct jpu_buffer {\n\tstruct v4l2_m2m_buffer buf;\n\tunsigned short\tcompr_quality;\n\tunsigned char\tsubsampling;\n};\n\n \nstruct jpu_fmt {\n\tu32 fourcc;\n\tu32 colorspace;\n\tu8 bpp[2];\n\tu8 h_align;\n\tu8 v_align;\n\tu8 subsampling;\n\tu8 num_planes;\n\tu16 types;\n};\n\n \nstruct jpu_q_data {\n\tstruct jpu_fmt *fmtinfo;\n\tstruct v4l2_pix_format_mplane format;\n\tunsigned int sequence;\n};\n\n \nstruct jpu_ctx {\n\tstruct jpu\t\t*jpu;\n\tbool\t\t\tencoder;\n\tunsigned short\t\tcompr_quality;\n\tstruct jpu_q_data\tout_q;\n\tstruct jpu_q_data\tcap_q;\n\tstruct v4l2_fh\t\tfh;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n};\n\n  \nstruct jpeg_buffer {\n\tvoid *end;\n\tvoid *curr;\n};\n\nstatic struct jpu_fmt jpu_formats[] = {\n\t{ V4L2_PIX_FMT_JPEG, V4L2_COLORSPACE_JPEG,\n\t  {0, 0}, 0, 0, 0, 1, JPU_ENC_CAPTURE | JPU_DEC_OUTPUT },\n\t{ V4L2_PIX_FMT_NV16M, V4L2_COLORSPACE_SRGB,\n\t  {8, 8}, 2, 2, JPU_JPEG_422, 2, JPU_ENC_OUTPUT | JPU_DEC_CAPTURE },\n\t{ V4L2_PIX_FMT_NV12M, V4L2_COLORSPACE_SRGB,\n\t  {8, 4}, 2, 2, JPU_JPEG_420, 2, JPU_ENC_OUTPUT | JPU_DEC_CAPTURE },\n\t{ V4L2_PIX_FMT_NV16, V4L2_COLORSPACE_SRGB,\n\t  {16, 0}, 2, 2, JPU_JPEG_422, 1, JPU_ENC_OUTPUT | JPU_DEC_CAPTURE },\n\t{ V4L2_PIX_FMT_NV12, V4L2_COLORSPACE_SRGB,\n\t  {12, 0}, 2, 2, JPU_JPEG_420, 1, JPU_ENC_OUTPUT | JPU_DEC_CAPTURE },\n};\n\nstatic const u8 zigzag[] = {\n\t0x03, 0x02, 0x0b, 0x13, 0x0a, 0x01, 0x00, 0x09,\n\t0x12, 0x1b, 0x23, 0x1a, 0x11, 0x08, 0x07, 0x06,\n\t0x0f, 0x10, 0x19, 0x22, 0x2b, 0x33, 0x2a, 0x21,\n\t0x18, 0x17, 0x0e, 0x05, 0x04, 0x0d, 0x16, 0x1f,\n\t0x20, 0x29, 0x32, 0x3b, 0x3a, 0x31, 0x28, 0x27,\n\t0x1e, 0x15, 0x0e, 0x14, 0x10, 0x26, 0x2f, 0x30,\n\t0x39, 0x38, 0x37, 0x2e, 0x25, 0x1c, 0x24, 0x2b,\n\t0x36, 0x3f, 0x3e, 0x35, 0x2c, 0x34, 0x3d, 0x3c\n};\n\n#define QTBL_SIZE (ALIGN(JPU_JPEG_QTBL_SIZE, \\\n\t\t\t  sizeof(unsigned int)) / sizeof(unsigned int))\n#define HDCTBL_SIZE (ALIGN(JPU_JPEG_HDCTBL_SIZE, \\\n\t\t\t  sizeof(unsigned int)) / sizeof(unsigned int))\n#define HACTBL_SIZE (ALIGN(JPU_JPEG_HACTBL_SIZE, \\\n\t\t\t  sizeof(unsigned int)) / sizeof(unsigned int))\n \n#define JPU_JPEG_HDR_BLOB {                                                    \\\n\t0xff, JPEG_MARKER_SOI, 0xff, JPEG_MARKER_DQT, 0x00,\t\t       \\\n\tJPU_JPEG_QTBL_SIZE + 0x3, JPU_JPEG_LUM,\t\t\t\t       \\\n\t[JPU_JPEG_QTBL_LUM_OFFSET ...\t\t\t\t\t       \\\n\t\tJPU_JPEG_QTBL_LUM_OFFSET + JPU_JPEG_QTBL_SIZE - 1] = 0x00,     \\\n\t0xff, JPEG_MARKER_DQT, 0x00, JPU_JPEG_QTBL_SIZE + 0x3, JPU_JPEG_CHR,   \\\n\t[JPU_JPEG_QTBL_CHR_OFFSET ... JPU_JPEG_QTBL_CHR_OFFSET +               \\\n\t\tJPU_JPEG_QTBL_SIZE - 1] = 0x00,\t\t\t\t       \\\n\t0xff, JPEG_MARKER_SOF0, 0x00, 0x11, 0x08,\t\t\t       \\\n\t[JPU_JPEG_HEIGHT_OFFSET ... JPU_JPEG_HEIGHT_OFFSET + 1] = 0x00,        \\\n\t[JPU_JPEG_WIDTH_OFFSET ... JPU_JPEG_WIDTH_OFFSET + 1] = 0x00,          \\\n\t0x03, 0x01, [JPU_JPEG_SUBS_OFFSET] = 0x00, JPU_JPEG_LUM,               \\\n\t0x02, 0x11, JPU_JPEG_CHR, 0x03, 0x11, JPU_JPEG_CHR,                    \\\n\t0xff, JPEG_MARKER_DHT, 0x00, JPU_JPEG_HDCTBL_SIZE + 0x3,\t       \\\n\tJPU_JPEG_LUM | JPU_JPEG_DC,\t\t\t\t\t       \\\n\t[JPU_JPEG_HDCTBL_LUM_OFFSET ...                                        \\\n\t\tJPU_JPEG_HDCTBL_LUM_OFFSET + JPU_JPEG_HDCTBL_SIZE - 1] = 0x00, \\\n\t0xff, JPEG_MARKER_DHT, 0x00, JPU_JPEG_HACTBL_SIZE + 0x3,\t       \\\n\tJPU_JPEG_LUM | JPU_JPEG_AC,\t\t\t\t\t       \\\n\t[JPU_JPEG_HACTBL_LUM_OFFSET ...                                        \\\n\t\tJPU_JPEG_HACTBL_LUM_OFFSET + JPU_JPEG_HACTBL_SIZE - 1] = 0x00, \\\n\t0xff, JPEG_MARKER_DHT, 0x00, JPU_JPEG_HDCTBL_SIZE + 0x3,\t       \\\n\tJPU_JPEG_CHR | JPU_JPEG_DC,\t\t\t\t\t       \\\n\t[JPU_JPEG_HDCTBL_CHR_OFFSET ...                                        \\\n\t\tJPU_JPEG_HDCTBL_CHR_OFFSET + JPU_JPEG_HDCTBL_SIZE - 1] = 0x00, \\\n\t0xff, JPEG_MARKER_DHT, 0x00, JPU_JPEG_HACTBL_SIZE + 0x3,\t       \\\n\tJPU_JPEG_CHR | JPU_JPEG_AC,\t\t\t\t\t       \\\n\t[JPU_JPEG_HACTBL_CHR_OFFSET ...                                        \\\n\t\tJPU_JPEG_HACTBL_CHR_OFFSET + JPU_JPEG_HACTBL_SIZE - 1] = 0x00, \\\n\t[JPU_JPEG_PADDING_OFFSET ... JPU_JPEG_HDR_SIZE - 1] = 0xff             \\\n}\n\nstatic unsigned char jpeg_hdrs[JPU_MAX_QUALITY][JPU_JPEG_HDR_SIZE] = {\n\t[0 ... JPU_MAX_QUALITY - 1] = JPU_JPEG_HDR_BLOB\n};\n\nstatic const unsigned int qtbl_lum[JPU_MAX_QUALITY][QTBL_SIZE] = {\n\t{\n\t\t0x14101927, 0x322e3e44, 0x10121726, 0x26354144,\n\t\t0x19171f26, 0x35414444, 0x27262635, 0x41444444,\n\t\t0x32263541, 0x44444444, 0x2e354144, 0x44444444,\n\t\t0x3e414444, 0x44444444, 0x44444444, 0x44444444\n\t},\n\t{\n\t\t0x100b0b10, 0x171b1f1e, 0x0b0c0c0f, 0x1417171e,\n\t\t0x0b0c0d10, 0x171a232f, 0x100f1017, 0x1a252f40,\n\t\t0x1714171a, 0x27334040, 0x1b171a25, 0x33404040,\n\t\t0x1f17232f, 0x40404040, 0x1e1e2f40, 0x40404040\n\t},\n\t{\n\t\t0x0c08080c, 0x11151817, 0x0809090b, 0x0f131217,\n\t\t0x08090a0c, 0x13141b24, 0x0c0b0c15, 0x141c2435,\n\t\t0x110f1314, 0x1e27333b, 0x1513141c, 0x27333b3b,\n\t\t0x18121b24, 0x333b3b3b, 0x17172435, 0x3b3b3b3b\n\t},\n\t{\n\t\t0x08060608, 0x0c0e1011, 0x06060608, 0x0a0d0c0f,\n\t\t0x06060708, 0x0d0e1218, 0x0808080e, 0x0d131823,\n\t\t0x0c0a0d0d, 0x141a2227, 0x0e0d0e13, 0x1a222727,\n\t\t0x100c1318, 0x22272727, 0x110f1823, 0x27272727\n\t}\n};\n\nstatic const unsigned int qtbl_chr[JPU_MAX_QUALITY][QTBL_SIZE] = {\n\t{\n\t\t0x15192026, 0x36444444, 0x191c1826, 0x36444444,\n\t\t0x2018202b, 0x42444444, 0x26262b35, 0x44444444,\n\t\t0x36424444, 0x44444444, 0x44444444, 0x44444444,\n\t\t0x44444444, 0x44444444, 0x44444444, 0x44444444\n\t},\n\t{\n\t\t0x110f1115, 0x141a2630, 0x0f131211, 0x141a232b,\n\t\t0x11121416, 0x1a1e2e35, 0x1511161c, 0x1e273540,\n\t\t0x14141a1e, 0x27304040, 0x1a1a1e27, 0x303f4040,\n\t\t0x26232e35, 0x40404040, 0x302b3540, 0x40404040\n\t},\n\t{\n\t\t0x0d0b0d10, 0x14141d25, 0x0b0e0e0e, 0x10141a20,\n\t\t0x0d0e0f11, 0x14172328, 0x100e1115, 0x171e2832,\n\t\t0x14101417, 0x1e25323b, 0x1414171e, 0x25303b3b,\n\t\t0x1d1a2328, 0x323b3b3b, 0x25202832, 0x3b3b3b3b\n\t},\n\t{\n\t\t0x0908090b, 0x0e111318, 0x080a090b, 0x0e0d1116,\n\t\t0x09090d0e, 0x0d0f171a, 0x0b0b0e0e, 0x0f141a21,\n\t\t0x0e0e0d0f, 0x14182127, 0x110d0f14, 0x18202727,\n\t\t0x1311171a, 0x21272727, 0x18161a21, 0x27272727\n\t}\n};\n\nstatic const unsigned int hdctbl_lum[HDCTBL_SIZE] = {\n\t0x00010501, 0x01010101, 0x01000000, 0x00000000,\n\t0x00010203, 0x04050607, 0x08090a0b\n};\n\nstatic const unsigned int hdctbl_chr[HDCTBL_SIZE] = {\n\t0x00010501, 0x01010101, 0x01000000, 0x00000000,\n\t0x00010203, 0x04050607, 0x08090a0b\n};\n\nstatic const unsigned int hactbl_lum[HACTBL_SIZE] = {\n\t0x00020103, 0x03020403, 0x05050404, 0x0000017d, 0x01020300, 0x04110512,\n\t0x21314106, 0x13516107,\t0x22711432, 0x8191a108, 0x2342b1c1, 0x1552d1f0,\n\t0x24336272, 0x82090a16, 0x1718191a, 0x25262728, 0x292a3435, 0x36373839,\n\t0x3a434445, 0x46474849, 0x4a535455, 0x56575859, 0x5a636465, 0x66676869,\n\t0x6a737475, 0x76777879, 0x7a838485, 0x86878889, 0x8a929394, 0x95969798,\n\t0x999aa2a3, 0xa4a5a6a7, 0xa8a9aab2, 0xb3b4b5b6, 0xb7b8b9ba, 0xc2c3c4c5,\n\t0xc6c7c8c9, 0xcad2d3d4, 0xd5d6d7d8, 0xd9dae1e2, 0xe3e4e5e6, 0xe7e8e9ea,\n\t0xf1f2f3f4, 0xf5f6f7f8, 0xf9fa0000\n};\n\nstatic const unsigned int hactbl_chr[HACTBL_SIZE] = {\n\t0x00020103, 0x03020403, 0x05050404, 0x0000017d, 0x01020300, 0x04110512,\n\t0x21314106, 0x13516107,\t0x22711432, 0x8191a108, 0x2342b1c1, 0x1552d1f0,\n\t0x24336272, 0x82090a16, 0x1718191a, 0x25262728, 0x292a3435, 0x36373839,\n\t0x3a434445, 0x46474849, 0x4a535455, 0x56575859, 0x5a636465, 0x66676869,\n\t0x6a737475, 0x76777879, 0x7a838485, 0x86878889, 0x8a929394, 0x95969798,\n\t0x999aa2a3, 0xa4a5a6a7, 0xa8a9aab2, 0xb3b4b5b6, 0xb7b8b9ba, 0xc2c3c4c5,\n\t0xc6c7c8c9, 0xcad2d3d4, 0xd5d6d7d8, 0xd9dae1e2, 0xe3e4e5e6, 0xe7e8e9ea,\n\t0xf1f2f3f4, 0xf5f6f7f8, 0xf9fa0000\n};\n\nstatic const char *error_to_text[16] = {\n\t\"Normal\",\n\t\"SOI not detected\",\n\t\"SOF1 to SOFF detected\",\n\t\"Subsampling not detected\",\n\t\"SOF accuracy error\",\n\t\"DQT accuracy error\",\n\t\"Component error 1\",\n\t\"Component error 2\",\n\t\"SOF0, DQT, and DHT not detected when SOS detected\",\n\t\"SOS not detected\",\n\t\"EOI not detected\",\n\t\"Restart interval data number error detected\",\n\t\"Image size error\",\n\t\"Last MCU data number error\",\n\t\"Block data number error\",\n\t\"Unknown\"\n};\n\nstatic struct jpu_buffer *vb2_to_jpu_buffer(struct vb2_v4l2_buffer *vb)\n{\n\tstruct v4l2_m2m_buffer *b =\n\t\tcontainer_of(vb, struct v4l2_m2m_buffer, vb);\n\n\treturn container_of(b, struct jpu_buffer, buf);\n}\n\nstatic u32 jpu_read(struct jpu *jpu, unsigned int reg)\n{\n\treturn ioread32(jpu->regs + reg);\n}\n\nstatic void jpu_write(struct jpu *jpu, u32 val, unsigned int reg)\n{\n\tiowrite32(val, jpu->regs + reg);\n}\n\nstatic struct jpu_ctx *ctrl_to_ctx(struct v4l2_ctrl *c)\n{\n\treturn container_of(c->handler, struct jpu_ctx, ctrl_handler);\n}\n\nstatic struct jpu_ctx *fh_to_ctx(struct v4l2_fh *fh)\n{\n\treturn container_of(fh, struct jpu_ctx, fh);\n}\n\nstatic void jpu_set_tbl(struct jpu *jpu, u32 reg, const unsigned int *tbl,\n\t\t\tunsigned int len) {\n\tunsigned int i;\n\n\tfor (i = 0; i < len; i++)\n\t\tjpu_write(jpu, tbl[i], reg + (i << 2));\n}\n\nstatic void jpu_set_qtbl(struct jpu *jpu, unsigned short quality)\n{\n\tjpu_set_tbl(jpu, JCQTBL(0), qtbl_lum[quality], QTBL_SIZE);\n\tjpu_set_tbl(jpu, JCQTBL(1), qtbl_chr[quality], QTBL_SIZE);\n}\n\nstatic void jpu_set_htbl(struct jpu *jpu)\n{\n\tjpu_set_tbl(jpu, JCHTBD(0), hdctbl_lum, HDCTBL_SIZE);\n\tjpu_set_tbl(jpu, JCHTBA(0), hactbl_lum, HACTBL_SIZE);\n\tjpu_set_tbl(jpu, JCHTBD(1), hdctbl_chr, HDCTBL_SIZE);\n\tjpu_set_tbl(jpu, JCHTBA(1), hactbl_chr, HACTBL_SIZE);\n}\n\nstatic int jpu_wait_reset(struct jpu *jpu)\n{\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(JPU_RESET_TIMEOUT);\n\n\twhile (jpu_read(jpu, JCCMD) & JCCMD_SRST) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(jpu->dev, \"timed out in reset\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tschedule();\n\t}\n\n\treturn 0;\n}\n\nstatic int jpu_reset(struct jpu *jpu)\n{\n\tjpu_write(jpu, JCCMD_SRST, JCCMD);\n\treturn jpu_wait_reset(jpu);\n}\n\n \nstatic void put_qtbl(u8 *p, const u8 *qtbl)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(zigzag); i++)\n\t\tp[i] = *(qtbl + zigzag[i]);\n}\n\nstatic void put_htbl(u8 *p, const u8 *htbl, unsigned int len)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; i < len; i += 4)\n\t\tfor (j = 0; j < 4 && (i + j) < len; ++j)\n\t\t\tp[i + j] = htbl[i + 3 - j];\n}\n\nstatic void jpu_generate_hdr(unsigned short quality, unsigned char *p)\n{\n\tput_qtbl(p + JPU_JPEG_QTBL_LUM_OFFSET, (const u8 *)qtbl_lum[quality]);\n\tput_qtbl(p + JPU_JPEG_QTBL_CHR_OFFSET, (const u8 *)qtbl_chr[quality]);\n\n\tput_htbl(p + JPU_JPEG_HDCTBL_LUM_OFFSET, (const u8 *)hdctbl_lum,\n\t\t JPU_JPEG_HDCTBL_SIZE);\n\tput_htbl(p + JPU_JPEG_HACTBL_LUM_OFFSET, (const u8 *)hactbl_lum,\n\t\t JPU_JPEG_HACTBL_SIZE);\n\n\tput_htbl(p + JPU_JPEG_HDCTBL_CHR_OFFSET, (const u8 *)hdctbl_chr,\n\t\t JPU_JPEG_HDCTBL_SIZE);\n\tput_htbl(p + JPU_JPEG_HACTBL_CHR_OFFSET, (const u8 *)hactbl_chr,\n\t\t JPU_JPEG_HACTBL_SIZE);\n}\n\nstatic int get_byte(struct jpeg_buffer *buf)\n{\n\tif (buf->curr >= buf->end)\n\t\treturn -1;\n\n\treturn *(u8 *)buf->curr++;\n}\n\nstatic int get_word_be(struct jpeg_buffer *buf, unsigned int *word)\n{\n\tif (buf->end - buf->curr < 2)\n\t\treturn -1;\n\n\t*word = get_unaligned_be16(buf->curr);\n\tbuf->curr += 2;\n\n\treturn 0;\n}\n\nstatic void skip(struct jpeg_buffer *buf, unsigned long len)\n{\n\tbuf->curr += min((unsigned long)(buf->end - buf->curr), len);\n}\n\nstatic u8 jpu_parse_hdr(void *buffer, unsigned long size, unsigned int *width,\n\t\t\t  unsigned int *height)\n{\n\tstruct jpeg_buffer jpeg_buffer;\n\tunsigned int word;\n\tbool soi = false;\n\n\tjpeg_buffer.end = buffer + size;\n\tjpeg_buffer.curr = buffer;\n\n\t \n\tif (size < JPU_JPEG_MIN_SIZE ||\n\t    *(u8 *)(buffer + size - 1) != JPEG_MARKER_EOI)\n\t\treturn 0;\n\n\tfor (;;) {\n\t\tint c;\n\n\t\t \n\t\tdo\n\t\t\tc = get_byte(&jpeg_buffer);\n\t\twhile (c == 0xff || c == 0);\n\n\t\tif (!soi && c == JPEG_MARKER_SOI) {\n\t\t\tsoi = true;\n\t\t\tcontinue;\n\t\t} else if (soi != (c != JPEG_MARKER_SOI))\n\t\t\treturn 0;\n\n\t\tswitch (c) {\n\t\tcase JPEG_MARKER_SOF0:  \n\t\t\tskip(&jpeg_buffer, 3);  \n\t\t\tif (get_word_be(&jpeg_buffer, height) ||\n\t\t\t    get_word_be(&jpeg_buffer, width) ||\n\t\t\t    get_byte(&jpeg_buffer) != 3)  \n\t\t\t\treturn 0;\n\n\t\t\tskip(&jpeg_buffer, 1);\n\t\t\treturn get_byte(&jpeg_buffer);\n\t\tcase JPEG_MARKER_DHT:\n\t\tcase JPEG_MARKER_DQT:\n\t\tcase JPEG_MARKER_COM:\n\t\tcase JPEG_MARKER_DRI:\n\t\tcase JPEG_MARKER_APP0 ... JPEG_MARKER_APP0 + 0x0f:\n\t\t\tif (get_word_be(&jpeg_buffer, &word))\n\t\t\t\treturn 0;\n\t\t\tskip(&jpeg_buffer, (long)word - 2);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int jpu_querycap(struct file *file, void *priv,\n\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct jpu_ctx *ctx = fh_to_ctx(priv);\n\n\tif (ctx->encoder)\n\t\tstrscpy(cap->card, DRV_NAME \" encoder\", sizeof(cap->card));\n\telse\n\t\tstrscpy(cap->card, DRV_NAME \" decoder\", sizeof(cap->card));\n\n\tstrscpy(cap->driver, DRV_NAME, sizeof(cap->driver));\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\n\treturn 0;\n}\n\nstatic struct jpu_fmt *jpu_find_format(bool encoder, u32 pixelformat,\n\t\t\t\t       unsigned int fmt_type)\n{\n\tunsigned int i, fmt_flag;\n\n\tif (encoder)\n\t\tfmt_flag = fmt_type == JPU_FMT_TYPE_OUTPUT ? JPU_ENC_OUTPUT :\n\t\t\t\t\t\t\t     JPU_ENC_CAPTURE;\n\telse\n\t\tfmt_flag = fmt_type == JPU_FMT_TYPE_OUTPUT ? JPU_DEC_OUTPUT :\n\t\t\t\t\t\t\t     JPU_DEC_CAPTURE;\n\n\tfor (i = 0; i < ARRAY_SIZE(jpu_formats); i++) {\n\t\tstruct jpu_fmt *fmt = &jpu_formats[i];\n\n\t\tif (fmt->fourcc == pixelformat && fmt->types & fmt_flag)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nstatic int jpu_enum_fmt(struct v4l2_fmtdesc *f, u32 type)\n{\n\tunsigned int i, num = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(jpu_formats); ++i) {\n\t\tif (jpu_formats[i].types & type) {\n\t\t\tif (num == f->index)\n\t\t\t\tbreak;\n\t\t\t++num;\n\t\t}\n\t}\n\n\tif (i >= ARRAY_SIZE(jpu_formats))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = jpu_formats[i].fourcc;\n\n\treturn 0;\n}\n\nstatic int jpu_enum_fmt_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_fmtdesc *f)\n{\n\tstruct jpu_ctx *ctx = fh_to_ctx(priv);\n\n\treturn jpu_enum_fmt(f, ctx->encoder ? JPU_ENC_CAPTURE :\n\t\t\t    JPU_DEC_CAPTURE);\n}\n\nstatic int jpu_enum_fmt_out(struct file *file, void *priv,\n\t\t\t    struct v4l2_fmtdesc *f)\n{\n\tstruct jpu_ctx *ctx = fh_to_ctx(priv);\n\n\treturn jpu_enum_fmt(f, ctx->encoder ? JPU_ENC_OUTPUT : JPU_DEC_OUTPUT);\n}\n\nstatic struct jpu_q_data *jpu_get_q_data(struct jpu_ctx *ctx,\n\t\t\t\t\t enum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn &ctx->out_q;\n\telse\n\t\treturn &ctx->cap_q;\n}\n\nstatic void jpu_bound_align_image(u32 *w, unsigned int w_min,\n\t\t\t\t  unsigned int w_max, unsigned int w_align,\n\t\t\t\t  u32 *h, unsigned int h_min,\n\t\t\t\t  unsigned int h_max, unsigned int h_align)\n{\n\tunsigned int width, height, w_step, h_step;\n\n\twidth = *w;\n\theight = *h;\n\n\tw_step = 1U << w_align;\n\th_step = 1U << h_align;\n\tv4l_bound_align_image(w, w_min, w_max, w_align, h, h_min, h_max,\n\t\t\t      h_align, 3);\n\n\tif (*w < width && *w + w_step < w_max)\n\t\t*w += w_step;\n\tif (*h < height && *h + h_step < h_max)\n\t\t*h += h_step;\n}\n\nstatic int __jpu_try_fmt(struct jpu_ctx *ctx, struct jpu_fmt **fmtinfo,\n\t\t\t struct v4l2_pix_format_mplane *pix,\n\t\t\t enum v4l2_buf_type type)\n{\n\tstruct jpu_fmt *fmt;\n\tunsigned int f_type, w, h;\n\n\tf_type = V4L2_TYPE_IS_OUTPUT(type) ? JPU_FMT_TYPE_OUTPUT :\n\t\t\t\t\t\tJPU_FMT_TYPE_CAPTURE;\n\n\tfmt = jpu_find_format(ctx->encoder, pix->pixelformat, f_type);\n\tif (!fmt) {\n\t\tunsigned int pixelformat;\n\n\t\tdev_dbg(ctx->jpu->dev, \"unknown format; set default format\\n\");\n\t\tif (ctx->encoder)\n\t\t\tpixelformat = f_type == JPU_FMT_TYPE_OUTPUT ?\n\t\t\t\tV4L2_PIX_FMT_NV16M : V4L2_PIX_FMT_JPEG;\n\t\telse\n\t\t\tpixelformat = f_type == JPU_FMT_TYPE_CAPTURE ?\n\t\t\t\tV4L2_PIX_FMT_NV16M : V4L2_PIX_FMT_JPEG;\n\t\tfmt = jpu_find_format(ctx->encoder, pixelformat, f_type);\n\t}\n\n\tpix->pixelformat = fmt->fourcc;\n\tpix->colorspace = fmt->colorspace;\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->num_planes = fmt->num_planes;\n\n\tjpu_bound_align_image(&pix->width, JPU_WIDTH_MIN, JPU_WIDTH_MAX,\n\t\t\t      fmt->h_align, &pix->height, JPU_HEIGHT_MIN,\n\t\t\t      JPU_HEIGHT_MAX, fmt->v_align);\n\n\tw = pix->width;\n\th = pix->height;\n\n\tif (fmt->fourcc == V4L2_PIX_FMT_JPEG) {\n\t\t \n\t\tif (pix->plane_fmt[0].sizeimage <= 0 || ctx->encoder)\n\t\t\tpix->plane_fmt[0].sizeimage = JPU_JPEG_HDR_SIZE +\n\t\t\t\t(JPU_JPEG_MAX_BYTES_PER_PIXEL * w * h);\n\t\tpix->plane_fmt[0].bytesperline = 0;\n\t} else {\n\t\tunsigned int i, bpl = 0;\n\n\t\tfor (i = 0; i < pix->num_planes; ++i)\n\t\t\tbpl = max(bpl, pix->plane_fmt[i].bytesperline);\n\n\t\tbpl = clamp_t(unsigned int, bpl, w, JPU_WIDTH_MAX);\n\t\tbpl = round_up(bpl, JPU_MEMALIGN);\n\n\t\tfor (i = 0; i < pix->num_planes; ++i) {\n\t\t\tpix->plane_fmt[i].bytesperline = bpl;\n\t\t\tpix->plane_fmt[i].sizeimage = bpl * h * fmt->bpp[i] / 8;\n\t\t}\n\t}\n\n\tif (fmtinfo)\n\t\t*fmtinfo = fmt;\n\n\treturn 0;\n}\n\nstatic int jpu_try_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct jpu_ctx *ctx = fh_to_ctx(priv);\n\n\tif (!v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type))\n\t\treturn -EINVAL;\n\n\treturn __jpu_try_fmt(ctx, NULL, &f->fmt.pix_mp, f->type);\n}\n\nstatic int jpu_s_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct jpu_ctx *ctx = fh_to_ctx(priv);\n\tstruct v4l2_m2m_ctx *m2m_ctx = ctx->fh.m2m_ctx;\n\tstruct jpu_fmt *fmtinfo;\n\tstruct jpu_q_data *q_data;\n\tint ret;\n\n\tvq = v4l2_m2m_get_vq(m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&ctx->jpu->v4l2_dev, \"%s queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tret = __jpu_try_fmt(ctx, &fmtinfo, &f->fmt.pix_mp, f->type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tq_data = jpu_get_q_data(ctx, f->type);\n\n\tq_data->format = f->fmt.pix_mp;\n\tq_data->fmtinfo = fmtinfo;\n\n\treturn 0;\n}\n\nstatic int jpu_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct jpu_q_data *q_data;\n\tstruct jpu_ctx *ctx = fh_to_ctx(priv);\n\n\tif (!v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type))\n\t\treturn -EINVAL;\n\n\tq_data = jpu_get_q_data(ctx, f->type);\n\tf->fmt.pix_mp = q_data->format;\n\n\treturn 0;\n}\n\n \nstatic int jpu_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct jpu_ctx *ctx = ctrl_to_ctx(ctrl);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->jpu->lock, flags);\n\tif (ctrl->id == V4L2_CID_JPEG_COMPRESSION_QUALITY)\n\t\tctx->compr_quality = ctrl->val;\n\tspin_unlock_irqrestore(&ctx->jpu->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops jpu_ctrl_ops = {\n\t.s_ctrl\t\t= jpu_s_ctrl,\n};\n\nstatic int jpu_streamon(struct file *file, void *priv, enum v4l2_buf_type type)\n{\n\tstruct jpu_ctx *ctx = fh_to_ctx(priv);\n\tstruct jpu_q_data *src_q_data, *dst_q_data, *orig, adj, *ref;\n\tenum v4l2_buf_type adj_type;\n\n\tsrc_q_data = jpu_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\tdst_q_data = jpu_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\n\tif (ctx->encoder) {\n\t\tadj = *src_q_data;\n\t\torig = src_q_data;\n\t\tref = dst_q_data;\n\t\tadj_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\t} else {\n\t\tadj = *dst_q_data;\n\t\torig = dst_q_data;\n\t\tref = src_q_data;\n\t\tadj_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\t}\n\n\tadj.format.width = ref->format.width;\n\tadj.format.height = ref->format.height;\n\n\t__jpu_try_fmt(ctx, NULL, &adj.format, adj_type);\n\n\tif (adj.format.width != orig->format.width ||\n\t    adj.format.height != orig->format.height) {\n\t\tdev_err(ctx->jpu->dev, \"src and dst formats do not match.\\n\");\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn v4l2_m2m_streamon(file, ctx->fh.m2m_ctx, type);\n}\n\nstatic const struct v4l2_ioctl_ops jpu_ioctl_ops = {\n\t.vidioc_querycap\t\t= jpu_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= jpu_enum_fmt_cap,\n\t.vidioc_enum_fmt_vid_out\t= jpu_enum_fmt_out,\n\t.vidioc_g_fmt_vid_cap_mplane\t= jpu_g_fmt,\n\t.vidioc_g_fmt_vid_out_mplane\t= jpu_g_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane\t= jpu_try_fmt,\n\t.vidioc_try_fmt_vid_out_mplane\t= jpu_try_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane\t= jpu_s_fmt,\n\t.vidioc_s_fmt_vid_out_mplane\t= jpu_s_fmt,\n\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_create_bufs             = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon\t\t= jpu_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe\n};\n\nstatic int jpu_controls_create(struct jpu_ctx *ctx)\n{\n\tstruct v4l2_ctrl *ctrl;\n\tint ret;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, 1);\n\n\tctrl = v4l2_ctrl_new_std(&ctx->ctrl_handler, &jpu_ctrl_ops,\n\t\t\t\t V4L2_CID_JPEG_COMPRESSION_QUALITY,\n\t\t\t\t 0, JPU_MAX_QUALITY - 1, 1, 0);\n\n\tif (ctx->ctrl_handler.error) {\n\t\tret = ctx->ctrl_handler.error;\n\t\tgoto error_free;\n\t}\n\n\tif (!ctx->encoder)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |\n\t\t\t\tV4L2_CTRL_FLAG_READ_ONLY;\n\n\tret = v4l2_ctrl_handler_setup(&ctx->ctrl_handler);\n\tif (ret < 0)\n\t\tgoto error_free;\n\n\treturn 0;\n\nerror_free:\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\treturn ret;\n}\n\n \nstatic int jpu_queue_setup(struct vb2_queue *vq,\n\t\t\t   unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct jpu_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct jpu_q_data *q_data;\n\tunsigned int i;\n\n\tq_data = jpu_get_q_data(ctx, vq->type);\n\n\tif (*nplanes) {\n\t\tif (*nplanes != q_data->format.num_planes)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < *nplanes; i++) {\n\t\t\tunsigned int q_size = q_data->format.plane_fmt[i].sizeimage;\n\n\t\t\tif (sizes[i] < q_size)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t*nplanes = q_data->format.num_planes;\n\n\tfor (i = 0; i < *nplanes; i++)\n\t\tsizes[i] = q_data->format.plane_fmt[i].sizeimage;\n\n\treturn 0;\n}\n\nstatic int jpu_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct jpu_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct jpu_q_data *q_data;\n\tunsigned int i;\n\n\tq_data = jpu_get_q_data(ctx, vb->vb2_queue->type);\n\n\tif (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\n\t\tif (vbuf->field == V4L2_FIELD_ANY)\n\t\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tif (vbuf->field != V4L2_FIELD_NONE) {\n\t\t\tdev_err(ctx->jpu->dev, \"%s field isn't supported\\n\",\n\t\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < q_data->format.num_planes; i++) {\n\t\tunsigned long size = q_data->format.plane_fmt[i].sizeimage;\n\n\t\tif (vb2_plane_size(vb, i) < size) {\n\t\t\tdev_err(ctx->jpu->dev,\n\t\t\t\t\"%s: data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t       __func__, vb2_plane_size(vb, i), size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (!ctx->encoder && V4L2_TYPE_IS_CAPTURE(vb->vb2_queue->type))\n\t\t\tvb2_set_plane_payload(vb, i, size);\n\t}\n\n\treturn 0;\n}\n\nstatic void jpu_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct jpu_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tif (!ctx->encoder && V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\n\t\tstruct jpu_buffer *jpu_buf = vb2_to_jpu_buffer(vbuf);\n\t\tstruct jpu_q_data *q_data, adjust;\n\t\tvoid *buffer = vb2_plane_vaddr(vb, 0);\n\t\tunsigned long buf_size = vb2_get_plane_payload(vb, 0);\n\t\tunsigned int width, height;\n\n\t\tu8 subsampling = jpu_parse_hdr(buffer, buf_size, &width,\n\t\t\t\t\t\t &height);\n\n\t\t \n\t\tif (subsampling != JPU_JPEG_422 && subsampling != JPU_JPEG_420)\n\t\t\tgoto format_error;\n\n\t\tq_data = &ctx->out_q;\n\n\t\tadjust = *q_data;\n\t\tadjust.format.width = width;\n\t\tadjust.format.height = height;\n\n\t\t__jpu_try_fmt(ctx, &adjust.fmtinfo, &adjust.format,\n\t\t\t      V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\n\t\tif (adjust.format.width != q_data->format.width ||\n\t\t    adjust.format.height != q_data->format.height)\n\t\t\tgoto format_error;\n\n\t\t \n\t\tjpu_buf->subsampling = subsampling;\n\t}\n\n\tif (ctx->fh.m2m_ctx)\n\t\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n\n\treturn;\n\nformat_error:\n\tdev_err(ctx->jpu->dev, \"incompatible or corrupted JPEG data\\n\");\n\tvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\n}\n\nstatic void jpu_buf_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct jpu_buffer *jpu_buf = vb2_to_jpu_buffer(vbuf);\n\tstruct jpu_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct jpu_q_data *q_data = &ctx->out_q;\n\tenum v4l2_buf_type type = vb->vb2_queue->type;\n\tu8 *buffer;\n\n\tif (vb->state == VB2_BUF_STATE_DONE)\n\t\tvbuf->sequence = jpu_get_q_data(ctx, type)->sequence++;\n\n\tif (!ctx->encoder || vb->state != VB2_BUF_STATE_DONE ||\n\t    V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn;\n\n\tbuffer = vb2_plane_vaddr(vb, 0);\n\n\tmemcpy(buffer, jpeg_hdrs[jpu_buf->compr_quality], JPU_JPEG_HDR_SIZE);\n\t*(__be16 *)(buffer + JPU_JPEG_HEIGHT_OFFSET) =\n\t\t\t\t\tcpu_to_be16(q_data->format.height);\n\t*(__be16 *)(buffer + JPU_JPEG_WIDTH_OFFSET) =\n\t\t\t\t\tcpu_to_be16(q_data->format.width);\n\t*(buffer + JPU_JPEG_SUBS_OFFSET) = q_data->fmtinfo->subsampling;\n}\n\nstatic int jpu_start_streaming(struct vb2_queue *vq, unsigned count)\n{\n\tstruct jpu_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct jpu_q_data *q_data = jpu_get_q_data(ctx, vq->type);\n\n\tq_data->sequence = 0;\n\treturn 0;\n}\n\nstatic void jpu_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct jpu_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct vb2_v4l2_buffer *vb;\n\tunsigned long flags;\n\n\tfor (;;) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\t\tvb = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (vb == NULL)\n\t\t\treturn;\n\t\tspin_lock_irqsave(&ctx->jpu->lock, flags);\n\t\tv4l2_m2m_buf_done(vb, VB2_BUF_STATE_ERROR);\n\t\tspin_unlock_irqrestore(&ctx->jpu->lock, flags);\n\t}\n}\n\nstatic const struct vb2_ops jpu_qops = {\n\t.queue_setup\t\t= jpu_queue_setup,\n\t.buf_prepare\t\t= jpu_buf_prepare,\n\t.buf_queue\t\t= jpu_buf_queue,\n\t.buf_finish\t\t= jpu_buf_finish,\n\t.start_streaming\t= jpu_start_streaming,\n\t.stop_streaming\t\t= jpu_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic int jpu_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t  struct vb2_queue *dst_vq)\n{\n\tstruct jpu_ctx *ctx = priv;\n\tint ret;\n\n\tmemset(src_vq, 0, sizeof(*src_vq));\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct jpu_buffer);\n\tsrc_vq->ops = &jpu_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->jpu->mutex;\n\tsrc_vq->dev = ctx->jpu->v4l2_dev.dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(dst_vq, 0, sizeof(*dst_vq));\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct jpu_buffer);\n\tdst_vq->ops = &jpu_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->jpu->mutex;\n\tdst_vq->dev = ctx->jpu->v4l2_dev.dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\n \nstatic int jpu_open(struct file *file)\n{\n\tstruct jpu *jpu = video_drvdata(file);\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct jpu_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tv4l2_fh_init(&ctx->fh, vfd);\n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\tctx->jpu = jpu;\n\tctx->encoder = vfd == &jpu->vfd_encoder;\n\n\t__jpu_try_fmt(ctx, &ctx->out_q.fmtinfo, &ctx->out_q.format,\n\t\t      V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\t__jpu_try_fmt(ctx, &ctx->cap_q.fmtinfo, &ctx->cap_q.format,\n\t\t      V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(jpu->m2m_dev, ctx, jpu_queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto v4l_prepare_rollback;\n\t}\n\n\tret = jpu_controls_create(ctx);\n\tif (ret < 0)\n\t\tgoto v4l_prepare_rollback;\n\n\tif (mutex_lock_interruptible(&jpu->mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto v4l_prepare_rollback;\n\t}\n\n\tif (jpu->ref_count == 0) {\n\t\tret = clk_prepare_enable(jpu->clk);\n\t\tif (ret < 0)\n\t\t\tgoto device_prepare_rollback;\n\t\t \n\t\tret = jpu_reset(jpu);\n\t\tif (ret)\n\t\t\tgoto jpu_reset_rollback;\n\t}\n\n\tjpu->ref_count++;\n\n\tmutex_unlock(&jpu->mutex);\n\treturn 0;\n\njpu_reset_rollback:\n\tclk_disable_unprepare(jpu->clk);\ndevice_prepare_rollback:\n\tmutex_unlock(&jpu->mutex);\nv4l_prepare_rollback:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic int jpu_release(struct file *file)\n{\n\tstruct jpu *jpu = video_drvdata(file);\n\tstruct jpu_ctx *ctx = fh_to_ctx(file->private_data);\n\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\n\tmutex_lock(&jpu->mutex);\n\tif (--jpu->ref_count == 0)\n\t\tclk_disable_unprepare(jpu->clk);\n\tmutex_unlock(&jpu->mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations jpu_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= jpu_open,\n\t.release\t= jpu_release,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\n \nstatic void jpu_cleanup(struct jpu_ctx *ctx, bool reset)\n{\n\t \n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->jpu->lock, flags);\n\n\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\n\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\n\n\t \n\tif (reset)\n\t\tjpu_write(ctx->jpu, JCCMD_SRST, JCCMD);\n\n\tspin_unlock_irqrestore(&ctx->jpu->lock, flags);\n\n\tv4l2_m2m_job_finish(ctx->jpu->m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic void jpu_device_run(void *priv)\n{\n\tstruct jpu_ctx *ctx = priv;\n\tstruct jpu *jpu = ctx->jpu;\n\tstruct jpu_buffer *jpu_buf;\n\tstruct jpu_q_data *q_data;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tunsigned int w, h, bpl;\n\tunsigned char num_planes, subsampling;\n\tunsigned long flags;\n\n\t \n\tif (jpu_wait_reset(jpu)) {\n\t\tjpu_cleanup(ctx, true);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&ctx->jpu->lock, flags);\n\n\tjpu->curr = ctx;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\tif (ctx->encoder) {\n\t\tjpu_buf = vb2_to_jpu_buffer(dst_buf);\n\t\tq_data = &ctx->out_q;\n\t} else {\n\t\tjpu_buf = vb2_to_jpu_buffer(src_buf);\n\t\tq_data = &ctx->cap_q;\n\t}\n\n\tw = q_data->format.width;\n\th = q_data->format.height;\n\tbpl = q_data->format.plane_fmt[0].bytesperline;\n\tnum_planes = q_data->fmtinfo->num_planes;\n\tsubsampling = q_data->fmtinfo->subsampling;\n\n\tif (ctx->encoder) {\n\t\tunsigned long src_1_addr, src_2_addr, dst_addr;\n\t\tunsigned int redu, inft;\n\n\t\tdst_addr = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\t\tsrc_1_addr =\n\t\t\tvb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\n\t\tif (num_planes > 1)\n\t\t\tsrc_2_addr = vb2_dma_contig_plane_dma_addr(\n\t\t\t\t\t&src_buf->vb2_buf, 1);\n\t\telse\n\t\t\tsrc_2_addr = src_1_addr + w * h;\n\n\t\tjpu_buf->compr_quality = ctx->compr_quality;\n\n\t\tif (subsampling == JPU_JPEG_420) {\n\t\t\tredu = JCMOD_REDU_420;\n\t\t\tinft = JIFECNT_INFT_420;\n\t\t} else {\n\t\t\tredu = JCMOD_REDU_422;\n\t\t\tinft = JIFECNT_INFT_422;\n\t\t}\n\n\t\t \n\t\tjpu_write(jpu, JCMOD_DSP_ENC | JCMOD_PCTR | redu |\n\t\t\t  JCMOD_MSKIP_ENABLE, JCMOD);\n\n\t\tjpu_write(jpu, JIFECNT_SWAP_WB | inft, JIFECNT);\n\t\tjpu_write(jpu, JIFDCNT_SWAP_WB, JIFDCNT);\n\t\tjpu_write(jpu, JINTE_TRANSF_COMPL, JINTE);\n\n\t\t \n\t\tjpu_write(jpu, src_1_addr, JIFESYA1);\n\t\tjpu_write(jpu, src_2_addr, JIFESCA1);\n\n\t\t \n\t\tjpu_write(jpu, bpl, JIFESMW);\n\n\t\tjpu_write(jpu, (w >> 8) & JCSZ_MASK, JCHSZU);\n\t\tjpu_write(jpu, w & JCSZ_MASK, JCHSZD);\n\n\t\tjpu_write(jpu, (h >> 8) & JCSZ_MASK, JCVSZU);\n\t\tjpu_write(jpu, h & JCSZ_MASK, JCVSZD);\n\n\t\tjpu_write(jpu, w, JIFESHSZ);\n\t\tjpu_write(jpu, h, JIFESVSZ);\n\n\t\tjpu_write(jpu, dst_addr + JPU_JPEG_HDR_SIZE, JIFEDA1);\n\n\t\tjpu_write(jpu, 0 << JCQTN_SHIFT(1) | 1 << JCQTN_SHIFT(2) |\n\t\t\t  1 << JCQTN_SHIFT(3), JCQTN);\n\n\t\tjpu_write(jpu, 0 << JCHTN_AC_SHIFT(1) | 0 << JCHTN_DC_SHIFT(1) |\n\t\t\t  1 << JCHTN_AC_SHIFT(2) | 1 << JCHTN_DC_SHIFT(2) |\n\t\t\t  1 << JCHTN_AC_SHIFT(3) | 1 << JCHTN_DC_SHIFT(3),\n\t\t\t  JCHTN);\n\n\t\tjpu_set_qtbl(jpu, ctx->compr_quality);\n\t\tjpu_set_htbl(jpu);\n\t} else {\n\t\tunsigned long src_addr, dst_1_addr, dst_2_addr;\n\n\t\tif (jpu_buf->subsampling != subsampling) {\n\t\t\tdev_err(ctx->jpu->dev,\n\t\t\t\t\"src and dst formats do not match.\\n\");\n\t\t\tspin_unlock_irqrestore(&ctx->jpu->lock, flags);\n\t\t\tjpu_cleanup(ctx, false);\n\t\t\treturn;\n\t\t}\n\n\t\tsrc_addr = vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\n\t\tdst_1_addr =\n\t\t\tvb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\t\tif (q_data->fmtinfo->num_planes > 1)\n\t\t\tdst_2_addr = vb2_dma_contig_plane_dma_addr(\n\t\t\t\t\t&dst_buf->vb2_buf, 1);\n\t\telse\n\t\t\tdst_2_addr = dst_1_addr + w * h;\n\n\t\t \n\t\tjpu_write(jpu, JCMOD_DSP_DEC | JCMOD_PCTR, JCMOD);\n\t\tjpu_write(jpu, JIFECNT_SWAP_WB, JIFECNT);\n\t\tjpu_write(jpu, JIFDCNT_SWAP_WB, JIFDCNT);\n\n\t\t \n\t\tjpu_write(jpu, JINTE_TRANSF_COMPL | JINTE_ERR, JINTE);\n\n\t\t \n\t\tjpu_write(jpu, src_addr, JIFDSA1);\n\t\tjpu_write(jpu, dst_1_addr, JIFDDYA1);\n\t\tjpu_write(jpu, dst_2_addr, JIFDDCA1);\n\n\t\tjpu_write(jpu, bpl, JIFDDMW);\n\t}\n\n\t \n\tjpu_write(jpu, JCCMD_JSRT, JCCMD);\n\n\tspin_unlock_irqrestore(&ctx->jpu->lock, flags);\n}\n\nstatic const struct v4l2_m2m_ops jpu_m2m_ops = {\n\t.device_run\t= jpu_device_run,\n};\n\n \nstatic irqreturn_t jpu_irq_handler(int irq, void *dev_id)\n{\n\tstruct jpu *jpu = dev_id;\n\tstruct jpu_ctx *curr_ctx;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tunsigned int int_status;\n\n\tint_status = jpu_read(jpu, JINTS);\n\n\t \n\tif (!((JINTS_TRANSF_COMPL | JINTS_PROCESS_COMPL | JINTS_ERR) &\n\t    int_status))\n\t\treturn IRQ_NONE;\n\n\t \n\tjpu_write(jpu, ~(int_status & JINTS_MASK), JINTS);\n\tif (int_status & (JINTS_ERR | JINTS_PROCESS_COMPL))\n\t\tjpu_write(jpu, JCCMD_JEND, JCCMD);\n\n\tspin_lock(&jpu->lock);\n\n\tif ((int_status & JINTS_PROCESS_COMPL) &&\n\t   !(int_status & JINTS_TRANSF_COMPL))\n\t\tgoto handled;\n\n\tcurr_ctx = v4l2_m2m_get_curr_priv(jpu->m2m_dev);\n\tif (!curr_ctx) {\n\t\t \n\t\tdev_err(jpu->dev, \"no active context for m2m\\n\");\n\t\tgoto handled;\n\t}\n\n\tsrc_buf = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\n\n\tif (int_status & JINTS_TRANSF_COMPL) {\n\t\tif (curr_ctx->encoder) {\n\t\t\tunsigned long payload_size = jpu_read(jpu, JCDTCU) << 16\n\t\t\t\t\t\t   | jpu_read(jpu, JCDTCM) << 8\n\t\t\t\t\t\t   | jpu_read(jpu, JCDTCD);\n\t\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0,\n\t\t\t\tpayload_size + JPU_JPEG_HDR_SIZE);\n\t\t}\n\n\t\tdst_buf->field = src_buf->field;\n\t\tdst_buf->vb2_buf.timestamp = src_buf->vb2_buf.timestamp;\n\t\tif (src_buf->flags & V4L2_BUF_FLAG_TIMECODE)\n\t\t\tdst_buf->timecode = src_buf->timecode;\n\t\tdst_buf->flags = src_buf->flags &\n\t\t\t(V4L2_BUF_FLAG_TIMECODE | V4L2_BUF_FLAG_KEYFRAME |\n\t\t\t V4L2_BUF_FLAG_PFRAME | V4L2_BUF_FLAG_BFRAME |\n\t\t\t V4L2_BUF_FLAG_TSTAMP_SRC_MASK);\n\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);\n\t} else if (int_status & JINTS_ERR) {\n\t\tunsigned char error = jpu_read(jpu, JCDERR) & JCDERR_MASK;\n\n\t\tdev_dbg(jpu->dev, \"processing error: %#X: %s\\n\", error,\n\t\t\terror_to_text[error]);\n\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\n\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\n\t}\n\n\tjpu->curr = NULL;\n\n\t \n\tjpu_write(jpu, JCCMD_SRST, JCCMD);\n\tspin_unlock(&jpu->lock);\n\n\tv4l2_m2m_job_finish(jpu->m2m_dev, curr_ctx->fh.m2m_ctx);\n\n\treturn IRQ_HANDLED;\n\nhandled:\n\tspin_unlock(&jpu->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic const struct of_device_id jpu_dt_ids[] = {\n\t{ .compatible = \"renesas,jpu-r8a7790\" },  \n\t{ .compatible = \"renesas,jpu-r8a7791\" },  \n\t{ .compatible = \"renesas,jpu-r8a7792\" },  \n\t{ .compatible = \"renesas,jpu-r8a7793\" },  \n\t{ .compatible = \"renesas,rcar-gen2-jpu\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, jpu_dt_ids);\n\nstatic int jpu_probe(struct platform_device *pdev)\n{\n\tstruct jpu *jpu;\n\tint ret;\n\tunsigned int i;\n\n\tjpu = devm_kzalloc(&pdev->dev, sizeof(*jpu), GFP_KERNEL);\n\tif (!jpu)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&jpu->mutex);\n\tspin_lock_init(&jpu->lock);\n\tjpu->dev = &pdev->dev;\n\n\t \n\tjpu->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(jpu->regs))\n\t\treturn PTR_ERR(jpu->regs);\n\n\t \n\tjpu->irq = ret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_request_irq(&pdev->dev, jpu->irq, jpu_irq_handler, 0,\n\t\t\t       dev_name(&pdev->dev), jpu);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot claim IRQ %d\\n\", jpu->irq);\n\t\treturn ret;\n\t}\n\n\t \n\tjpu->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(jpu->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot get clock\\n\");\n\t\treturn PTR_ERR(jpu->clk);\n\t}\n\n\t \n\tret = v4l2_device_register(&pdev->dev, &jpu->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register v4l2 device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tjpu->m2m_dev = v4l2_m2m_init(&jpu_m2m_ops);\n\tif (IS_ERR(jpu->m2m_dev)) {\n\t\tv4l2_err(&jpu->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(jpu->m2m_dev);\n\t\tgoto device_register_rollback;\n\t}\n\n\t \n\tfor (i = 0; i < JPU_MAX_QUALITY; i++)\n\t\tjpu_generate_hdr(i, (unsigned char *)jpeg_hdrs[i]);\n\n\tstrscpy(jpu->vfd_encoder.name, DRV_NAME, sizeof(jpu->vfd_encoder.name));\n\tjpu->vfd_encoder.fops\t\t= &jpu_fops;\n\tjpu->vfd_encoder.ioctl_ops\t= &jpu_ioctl_ops;\n\tjpu->vfd_encoder.minor\t\t= -1;\n\tjpu->vfd_encoder.release\t= video_device_release_empty;\n\tjpu->vfd_encoder.lock\t\t= &jpu->mutex;\n\tjpu->vfd_encoder.v4l2_dev\t= &jpu->v4l2_dev;\n\tjpu->vfd_encoder.vfl_dir\t= VFL_DIR_M2M;\n\tjpu->vfd_encoder.device_caps\t= V4L2_CAP_STREAMING |\n\t\t\t\t\t  V4L2_CAP_VIDEO_M2M_MPLANE;\n\n\tret = video_register_device(&jpu->vfd_encoder, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(&jpu->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto m2m_init_rollback;\n\t}\n\n\tvideo_set_drvdata(&jpu->vfd_encoder, jpu);\n\n\tstrscpy(jpu->vfd_decoder.name, DRV_NAME, sizeof(jpu->vfd_decoder.name));\n\tjpu->vfd_decoder.fops\t\t= &jpu_fops;\n\tjpu->vfd_decoder.ioctl_ops\t= &jpu_ioctl_ops;\n\tjpu->vfd_decoder.minor\t\t= -1;\n\tjpu->vfd_decoder.release\t= video_device_release_empty;\n\tjpu->vfd_decoder.lock\t\t= &jpu->mutex;\n\tjpu->vfd_decoder.v4l2_dev\t= &jpu->v4l2_dev;\n\tjpu->vfd_decoder.vfl_dir\t= VFL_DIR_M2M;\n\tjpu->vfd_decoder.device_caps\t= V4L2_CAP_STREAMING |\n\t\t\t\t\t  V4L2_CAP_VIDEO_M2M_MPLANE;\n\n\tret = video_register_device(&jpu->vfd_decoder, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(&jpu->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto enc_vdev_register_rollback;\n\t}\n\n\tvideo_set_drvdata(&jpu->vfd_decoder, jpu);\n\tplatform_set_drvdata(pdev, jpu);\n\n\tv4l2_info(&jpu->v4l2_dev, \"encoder device registered as /dev/video%d\\n\",\n\t\t  jpu->vfd_encoder.num);\n\tv4l2_info(&jpu->v4l2_dev, \"decoder device registered as /dev/video%d\\n\",\n\t\t  jpu->vfd_decoder.num);\n\n\treturn 0;\n\nenc_vdev_register_rollback:\n\tvideo_unregister_device(&jpu->vfd_encoder);\n\nm2m_init_rollback:\n\tv4l2_m2m_release(jpu->m2m_dev);\n\ndevice_register_rollback:\n\tv4l2_device_unregister(&jpu->v4l2_dev);\n\n\treturn ret;\n}\n\nstatic void jpu_remove(struct platform_device *pdev)\n{\n\tstruct jpu *jpu = platform_get_drvdata(pdev);\n\n\tvideo_unregister_device(&jpu->vfd_decoder);\n\tvideo_unregister_device(&jpu->vfd_encoder);\n\tv4l2_m2m_release(jpu->m2m_dev);\n\tv4l2_device_unregister(&jpu->v4l2_dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int jpu_suspend(struct device *dev)\n{\n\tstruct jpu *jpu = dev_get_drvdata(dev);\n\n\tif (jpu->ref_count == 0)\n\t\treturn 0;\n\n\tclk_disable_unprepare(jpu->clk);\n\n\treturn 0;\n}\n\nstatic int jpu_resume(struct device *dev)\n{\n\tstruct jpu *jpu = dev_get_drvdata(dev);\n\n\tif (jpu->ref_count == 0)\n\t\treturn 0;\n\n\tclk_prepare_enable(jpu->clk);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops jpu_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(jpu_suspend, jpu_resume)\n};\n\nstatic struct platform_driver jpu_driver = {\n\t.probe = jpu_probe,\n\t.remove_new = jpu_remove,\n\t.driver = {\n\t\t.of_match_table = jpu_dt_ids,\n\t\t.name = DRV_NAME,\n\t\t.pm = &jpu_pm_ops,\n\t},\n};\n\nmodule_platform_driver(jpu_driver);\n\nMODULE_ALIAS(\"platform:\" DRV_NAME);\nMODULE_AUTHOR(\"Mikhail Ulianov <mikhail.ulyanov@cogentembedded.com>\");\nMODULE_DESCRIPTION(\"Renesas R-Car JPEG processing unit driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}