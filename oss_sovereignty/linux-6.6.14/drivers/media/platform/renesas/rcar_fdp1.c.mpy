{
  "module_name": "rcar_fdp1.c",
  "hash_id": "a37218859b1a710c1a96e3d0e11f5904a1a40fdac544298d9567e75cfa46d764",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/rcar_fdp1.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <media/rcar-fcp.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n\nstatic unsigned int debug;\nmodule_param(debug, uint, 0644);\nMODULE_PARM_DESC(debug, \"activate debug info\");\n\n \n#define FDP1_MIN_W\t\t80U\n#define FDP1_MIN_H\t\t80U\n\n#define FDP1_MAX_W\t\t3840U\n#define FDP1_MAX_H\t\t2160U\n\n#define FDP1_MAX_PLANES\t\t3U\n#define FDP1_MAX_STRIDE\t\t8190U\n\n \n#define FDP1_CAPTURE\t\tBIT(0)\n#define FDP1_OUTPUT\t\tBIT(1)\n\n#define DRIVER_NAME\t\t\"rcar_fdp1\"\n\n \n#define FDP1_NUMBER_JOBS 8\n\n#define dprintk(fdp1, fmt, arg...) \\\n\tv4l2_dbg(1, debug, &fdp1->v4l2_dev, \"%s: \" fmt, __func__, ## arg)\n\n \n\n \n#define FD1_CTL_CMD\t\t\t0x0000\n#define FD1_CTL_CMD_STRCMD\t\tBIT(0)\n\n \n#define FD1_CTL_SGCMD\t\t\t0x0004\n#define FD1_CTL_SGCMD_SGEN\t\tBIT(0)\n\n \n#define FD1_CTL_REGEND\t\t\t0x0008\n#define FD1_CTL_REGEND_REGEND\t\tBIT(0)\n\n \n#define FD1_CTL_CHACT\t\t\t0x000c\n#define FD1_CTL_CHACT_SMW\t\tBIT(9)\n#define FD1_CTL_CHACT_WR\t\tBIT(8)\n#define FD1_CTL_CHACT_SMR\t\tBIT(3)\n#define FD1_CTL_CHACT_RD2\t\tBIT(2)\n#define FD1_CTL_CHACT_RD1\t\tBIT(1)\n#define FD1_CTL_CHACT_RD0\t\tBIT(0)\n\n \n#define FD1_CTL_OPMODE\t\t\t0x0010\n#define FD1_CTL_OPMODE_PRG\t\tBIT(4)\n#define FD1_CTL_OPMODE_VIMD_INTERRUPT\t(0 << 0)\n#define FD1_CTL_OPMODE_VIMD_BESTEFFORT\t(1 << 0)\n#define FD1_CTL_OPMODE_VIMD_NOINTERRUPT\t(2 << 0)\n\n#define FD1_CTL_VPERIOD\t\t\t0x0014\n#define FD1_CTL_CLKCTRL\t\t\t0x0018\n#define FD1_CTL_CLKCTRL_CSTP_N\t\tBIT(0)\n\n \n#define FD1_CTL_SRESET\t\t\t0x001c\n#define FD1_CTL_SRESET_SRST\t\tBIT(0)\n\n \n#define FD1_CTL_STATUS\t\t\t0x0024\n#define FD1_CTL_STATUS_VINT_CNT_MASK\tGENMASK(31, 16)\n#define FD1_CTL_STATUS_VINT_CNT_SHIFT\t16\n#define FD1_CTL_STATUS_SGREGSET\t\tBIT(10)\n#define FD1_CTL_STATUS_SGVERR\t\tBIT(9)\n#define FD1_CTL_STATUS_SGFREND\t\tBIT(8)\n#define FD1_CTL_STATUS_BSY\t\tBIT(0)\n\n#define FD1_CTL_VCYCLE_STAT\t\t0x0028\n\n \n#define FD1_CTL_IRQENB\t\t\t0x0038\n \n#define FD1_CTL_IRQSTA\t\t\t0x003c\n \n#define FD1_CTL_IRQFSET\t\t\t0x0040\n\n \n#define FD1_CTL_IRQ_VERE\t\tBIT(16)\n#define FD1_CTL_IRQ_VINTE\t\tBIT(4)\n#define FD1_CTL_IRQ_FREE\t\tBIT(0)\n#define FD1_CTL_IRQ_MASK\t\t(FD1_CTL_IRQ_VERE | \\\n\t\t\t\t\t FD1_CTL_IRQ_VINTE | \\\n\t\t\t\t\t FD1_CTL_IRQ_FREE)\n\n \n#define FD1_RPF_SIZE\t\t\t0x0060\n#define FD1_RPF_SIZE_MASK\t\tGENMASK(12, 0)\n#define FD1_RPF_SIZE_H_SHIFT\t\t16\n#define FD1_RPF_SIZE_V_SHIFT\t\t0\n\n#define FD1_RPF_FORMAT\t\t\t0x0064\n#define FD1_RPF_FORMAT_CIPM\t\tBIT(16)\n#define FD1_RPF_FORMAT_RSPYCS\t\tBIT(13)\n#define FD1_RPF_FORMAT_RSPUVS\t\tBIT(12)\n#define FD1_RPF_FORMAT_CF\t\tBIT(8)\n\n#define FD1_RPF_PSTRIDE\t\t\t0x0068\n#define FD1_RPF_PSTRIDE_Y_SHIFT\t\t16\n#define FD1_RPF_PSTRIDE_C_SHIFT\t\t0\n\n \n#define FD1_RPF0_ADDR_Y\t\t\t0x006c\n\n \n#define FD1_RPF1_ADDR_Y\t\t\t0x0078\n#define FD1_RPF1_ADDR_C0\t\t0x007c\n#define FD1_RPF1_ADDR_C1\t\t0x0080\n\n \n#define FD1_RPF2_ADDR_Y\t\t\t0x0084\n\n#define FD1_RPF_SMSK_ADDR\t\t0x0090\n#define FD1_RPF_SWAP\t\t\t0x0094\n\n \n#define FD1_WPF_FORMAT\t\t\t0x00c0\n#define FD1_WPF_FORMAT_PDV_SHIFT\t24\n#define FD1_WPF_FORMAT_FCNL\t\tBIT(20)\n#define FD1_WPF_FORMAT_WSPYCS\t\tBIT(15)\n#define FD1_WPF_FORMAT_WSPUVS\t\tBIT(14)\n#define FD1_WPF_FORMAT_WRTM_601_16\t(0 << 9)\n#define FD1_WPF_FORMAT_WRTM_601_0\t(1 << 9)\n#define FD1_WPF_FORMAT_WRTM_709_16\t(2 << 9)\n#define FD1_WPF_FORMAT_CSC\t\tBIT(8)\n\n#define FD1_WPF_RNDCTL\t\t\t0x00c4\n#define FD1_WPF_RNDCTL_CBRM\t\tBIT(28)\n#define FD1_WPF_RNDCTL_CLMD_NOCLIP\t(0 << 12)\n#define FD1_WPF_RNDCTL_CLMD_CLIP_16_235\t(1 << 12)\n#define FD1_WPF_RNDCTL_CLMD_CLIP_1_254\t(2 << 12)\n\n#define FD1_WPF_PSTRIDE\t\t\t0x00c8\n#define FD1_WPF_PSTRIDE_Y_SHIFT\t\t16\n#define FD1_WPF_PSTRIDE_C_SHIFT\t\t0\n\n \n#define FD1_WPF_ADDR_Y\t\t\t0x00cc\n#define FD1_WPF_ADDR_C0\t\t\t0x00d0\n#define FD1_WPF_ADDR_C1\t\t\t0x00d4\n#define FD1_WPF_SWAP\t\t\t0x00d8\n#define FD1_WPF_SWAP_OSWAP_SHIFT\t0\n#define FD1_WPF_SWAP_SSWAP_SHIFT\t4\n\n \n#define FD1_RWPF_SWAP_BYTE\t\tBIT(0)\n#define FD1_RWPF_SWAP_WORD\t\tBIT(1)\n#define FD1_RWPF_SWAP_LWRD\t\tBIT(2)\n#define FD1_RWPF_SWAP_LLWD\t\tBIT(3)\n\n \n#define FD1_IPC_MODE\t\t\t0x0100\n#define FD1_IPC_MODE_DLI\t\tBIT(8)\n#define FD1_IPC_MODE_DIM_ADAPT2D3D\t(0 << 0)\n#define FD1_IPC_MODE_DIM_FIXED2D\t(1 << 0)\n#define FD1_IPC_MODE_DIM_FIXED3D\t(2 << 0)\n#define FD1_IPC_MODE_DIM_PREVFIELD\t(3 << 0)\n#define FD1_IPC_MODE_DIM_NEXTFIELD\t(4 << 0)\n\n#define FD1_IPC_SMSK_THRESH\t\t0x0104\n#define FD1_IPC_SMSK_THRESH_CONST\t0x00010002\n\n#define FD1_IPC_COMB_DET\t\t0x0108\n#define FD1_IPC_COMB_DET_CONST\t\t0x00200040\n\n#define FD1_IPC_MOTDEC\t\t\t0x010c\n#define FD1_IPC_MOTDEC_CONST\t\t0x00008020\n\n \n#define FD1_IPC_DLI_BLEND\t\t0x0120\n#define FD1_IPC_DLI_BLEND_CONST\t\t0x0080ff02\n\n#define FD1_IPC_DLI_HGAIN\t\t0x0124\n#define FD1_IPC_DLI_HGAIN_CONST\t\t0x001000ff\n\n#define FD1_IPC_DLI_SPRS\t\t0x0128\n#define FD1_IPC_DLI_SPRS_CONST\t\t0x009004ff\n\n#define FD1_IPC_DLI_ANGLE\t\t0x012c\n#define FD1_IPC_DLI_ANGLE_CONST\t\t0x0004080c\n\n#define FD1_IPC_DLI_ISOPIX0\t\t0x0130\n#define FD1_IPC_DLI_ISOPIX0_CONST\t0xff10ff10\n\n#define FD1_IPC_DLI_ISOPIX1\t\t0x0134\n#define FD1_IPC_DLI_ISOPIX1_CONST\t0x0000ff10\n\n \n#define FD1_IPC_SENSOR_TH0\t\t0x0140\n#define FD1_IPC_SENSOR_TH0_CONST\t0x20208080\n\n#define FD1_IPC_SENSOR_TH1\t\t0x0144\n#define FD1_IPC_SENSOR_TH1_CONST\t0\n\n#define FD1_IPC_SENSOR_CTL0\t\t0x0170\n#define FD1_IPC_SENSOR_CTL0_CONST\t0x00002201\n\n#define FD1_IPC_SENSOR_CTL1\t\t0x0174\n#define FD1_IPC_SENSOR_CTL1_CONST\t0\n\n#define FD1_IPC_SENSOR_CTL2\t\t0x0178\n#define FD1_IPC_SENSOR_CTL2_X_SHIFT\t16\n#define FD1_IPC_SENSOR_CTL2_Y_SHIFT\t0\n\n#define FD1_IPC_SENSOR_CTL3\t\t0x017c\n#define FD1_IPC_SENSOR_CTL3_0_SHIFT\t16\n#define FD1_IPC_SENSOR_CTL3_1_SHIFT\t0\n\n \n#define FD1_IPC_LMEM\t\t\t0x01e0\n#define FD1_IPC_LMEM_LINEAR\t\t1024\n#define FD1_IPC_LMEM_TILE\t\t960\n\n \n#define FD1_IP_INTDATA\t\t\t0x0800\n \n#define FD1_IP_GEN2\t\t\t0x02010101\n#define FD1_IP_M3W\t\t\t0x02010202\n#define FD1_IP_H3\t\t\t0x02010203\n#define FD1_IP_M3N\t\t\t0x02010204\n#define FD1_IP_E3\t\t\t0x02010205\n\n \n#define FD1_LUT_DIF_ADJ\t\t\t0x1000\n#define FD1_LUT_SAD_ADJ\t\t\t0x1400\n#define FD1_LUT_BLD_GAIN\t\t0x1800\n#define FD1_LUT_DIF_GAIN\t\t0x1c00\n#define FD1_LUT_MDET\t\t\t0x2000\n\n \nstruct fdp1_fmt {\n\tu32\tfourcc;\n\tu8\tbpp[3];\n\tu8\tnum_planes;\n\tu8\thsub;\n\tu8\tvsub;\n\tu8\tfmt;\n\tbool\tswap_yc;\n\tbool\tswap_uv;\n\tu8\tswap;\n\tu8\ttypes;\n};\n\nstatic const struct fdp1_fmt fdp1_formats[] = {\n\t \n\n\t{ V4L2_PIX_FMT_RGB332, { 8, 0, 0 }, 1, 1, 1, 0x00, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE },\n\t{ V4L2_PIX_FMT_XRGB444, { 16, 0, 0 }, 1, 1, 1, 0x01, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD,\n\t  FDP1_CAPTURE },\n\t{ V4L2_PIX_FMT_XRGB555, { 16, 0, 0 }, 1, 1, 1, 0x04, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD,\n\t  FDP1_CAPTURE },\n\t{ V4L2_PIX_FMT_RGB565, { 16, 0, 0 }, 1, 1, 1, 0x06, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD,\n\t  FDP1_CAPTURE },\n\t{ V4L2_PIX_FMT_ABGR32, { 32, 0, 0 }, 1, 1, 1, 0x13, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD,\n\t  FDP1_CAPTURE },\n\t{ V4L2_PIX_FMT_XBGR32, { 32, 0, 0 }, 1, 1, 1, 0x13, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD,\n\t  FDP1_CAPTURE },\n\t{ V4L2_PIX_FMT_ARGB32, { 32, 0, 0 }, 1, 1, 1, 0x13, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE },\n\t{ V4L2_PIX_FMT_XRGB32, { 32, 0, 0 }, 1, 1, 1, 0x13, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE },\n\t{ V4L2_PIX_FMT_RGB24, { 24, 0, 0 }, 1, 1, 1, 0x15, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE },\n\t{ V4L2_PIX_FMT_BGR24, { 24, 0, 0 }, 1, 1, 1, 0x18, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE },\n\t{ V4L2_PIX_FMT_ARGB444, { 16, 0, 0 }, 1, 1, 1, 0x19, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD,\n\t  FDP1_CAPTURE },\n\t{ V4L2_PIX_FMT_ARGB555, { 16, 0, 0 }, 1, 1, 1, 0x1b, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD,\n\t  FDP1_CAPTURE },\n\n\t \n\n\t{ V4L2_PIX_FMT_NV16M, { 8, 16, 0 }, 2, 2, 1, 0x41, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_NV61M, { 8, 16, 0 }, 2, 2, 1, 0x41, false, true,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_NV12M, { 8, 16, 0 }, 2, 2, 2, 0x42, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_NV21M, { 8, 16, 0 }, 2, 2, 2, 0x42, false, true,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_UYVY, { 16, 0, 0 }, 1, 2, 1, 0x47, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_VYUY, { 16, 0, 0 }, 1, 2, 1, 0x47, false, true,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_YUYV, { 16, 0, 0 }, 1, 2, 1, 0x47, true, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_YVYU, { 16, 0, 0 }, 1, 2, 1, 0x47, true, true,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_YUV444M, { 8, 8, 8 }, 3, 1, 1, 0x4a, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_YVU444M, { 8, 8, 8 }, 3, 1, 1, 0x4a, false, true,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_YUV422M, { 8, 8, 8 }, 3, 2, 1, 0x4b, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_YVU422M, { 8, 8, 8 }, 3, 2, 1, 0x4b, false, true,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_YUV420M, { 8, 8, 8 }, 3, 2, 2, 0x4c, false, false,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n\t{ V4L2_PIX_FMT_YVU420M, { 8, 8, 8 }, 3, 2, 2, 0x4c, false, true,\n\t  FD1_RWPF_SWAP_LLWD | FD1_RWPF_SWAP_LWRD |\n\t  FD1_RWPF_SWAP_WORD | FD1_RWPF_SWAP_BYTE,\n\t  FDP1_CAPTURE | FDP1_OUTPUT },\n};\n\nstatic int fdp1_fmt_is_rgb(const struct fdp1_fmt *fmt)\n{\n\treturn fmt->fmt <= 0x1b;  \n}\n\n \nstatic const u8 fdp1_diff_adj[] = {\n\t0x00, 0x24, 0x43, 0x5e, 0x76, 0x8c, 0x9e, 0xaf,\n\t0xbd, 0xc9, 0xd4, 0xdd, 0xe4, 0xea, 0xef, 0xf3,\n\t0xf6, 0xf9, 0xfb, 0xfc, 0xfd, 0xfe, 0xfe, 0xff,\n};\n\nstatic const u8 fdp1_sad_adj[] = {\n\t0x00, 0x24, 0x43, 0x5e, 0x76, 0x8c, 0x9e, 0xaf,\n\t0xbd, 0xc9, 0xd4, 0xdd, 0xe4, 0xea, 0xef, 0xf3,\n\t0xf6, 0xf9, 0xfb, 0xfc, 0xfd, 0xfe, 0xfe, 0xff,\n};\n\nstatic const u8 fdp1_bld_gain[] = {\n\t0x80,\n};\n\nstatic const u8 fdp1_dif_gain[] = {\n\t0x80,\n};\n\nstatic const u8 fdp1_mdet[] = {\n\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n\t0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n\t0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n\t0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n\t0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n\t0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n\t0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n\t0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n\t0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n\t0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n\t0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n\t0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n\t0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n\t0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n\t0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n\t0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n\t0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n\t0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n\t0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n\t0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n\t0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n\t0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n\t0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff\n};\n\n \nstruct fdp1_q_data {\n\tconst struct fdp1_fmt\t\t*fmt;\n\tstruct v4l2_pix_format_mplane\tformat;\n\n\tunsigned int\t\t\tvsize;\n\tunsigned int\t\t\tstride_y;\n\tunsigned int\t\t\tstride_c;\n};\n\nstatic const struct fdp1_fmt *fdp1_find_format(u32 pixelformat)\n{\n\tconst struct fdp1_fmt *fmt;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fdp1_formats); i++) {\n\t\tfmt = &fdp1_formats[i];\n\t\tif (fmt->fourcc == pixelformat)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nenum fdp1_deint_mode {\n\tFDP1_PROGRESSIVE = 0,  \n\tFDP1_ADAPT2D3D,\n\tFDP1_FIXED2D,\n\tFDP1_FIXED3D,\n\tFDP1_PREVFIELD,\n\tFDP1_NEXTFIELD,\n};\n\n#define FDP1_DEINT_MODE_USES_NEXT(mode) \\\n\t(mode == FDP1_ADAPT2D3D || \\\n\t mode == FDP1_FIXED3D   || \\\n\t mode == FDP1_NEXTFIELD)\n\n#define FDP1_DEINT_MODE_USES_PREV(mode) \\\n\t(mode == FDP1_ADAPT2D3D || \\\n\t mode == FDP1_FIXED3D   || \\\n\t mode == FDP1_PREVFIELD)\n\n \nstruct fdp1_field_buffer {\n\tstruct vb2_v4l2_buffer\t\t*vb;\n\tdma_addr_t\t\t\taddrs[3];\n\n\t \n\tenum v4l2_field\t\t\tfield;\n\n\t \n\tbool\t\t\t\tlast_field;\n\n\t \n\tstruct list_head\t\tlist;\n};\n\nstruct fdp1_buffer {\n\tstruct v4l2_m2m_buffer\t\tm2m_buf;\n\tstruct fdp1_field_buffer\tfields[2];\n\tunsigned int\t\t\tnum_fields;\n};\n\nstatic inline struct fdp1_buffer *to_fdp1_buffer(struct vb2_v4l2_buffer *vb)\n{\n\treturn container_of(vb, struct fdp1_buffer, m2m_buf.vb);\n}\n\nstruct fdp1_job {\n\tstruct fdp1_field_buffer\t*previous;\n\tstruct fdp1_field_buffer\t*active;\n\tstruct fdp1_field_buffer\t*next;\n\tstruct fdp1_field_buffer\t*dst;\n\n\t \n\tstruct list_head\t\tlist;\n};\n\nstruct fdp1_dev {\n\tstruct v4l2_device\t\tv4l2_dev;\n\tstruct video_device\t\tvfd;\n\n\tstruct mutex\t\t\tdev_mutex;\n\tspinlock_t\t\t\tirqlock;\n\tspinlock_t\t\t\tdevice_process_lock;\n\n\tvoid __iomem\t\t\t*regs;\n\tunsigned int\t\t\tirq;\n\tstruct device\t\t\t*dev;\n\n\t \n\tstruct fdp1_job\t\t\tjobs[FDP1_NUMBER_JOBS];\n\tstruct list_head\t\tfree_job_list;\n\tstruct list_head\t\tqueued_job_list;\n\tstruct list_head\t\thw_job_list;\n\n\tunsigned int\t\t\tclk_rate;\n\n\tstruct rcar_fcp_device\t\t*fcp;\n\tstruct v4l2_m2m_dev\t\t*m2m_dev;\n};\n\nstruct fdp1_ctx {\n\tstruct v4l2_fh\t\t\tfh;\n\tstruct fdp1_dev\t\t\t*fdp1;\n\n\tstruct v4l2_ctrl_handler\thdl;\n\tunsigned int\t\t\tsequence;\n\n\t \n\tu8\t\t\t\tnum_processed;\n\n\t \n\tu32\t\t\t\ttranslen;\n\n\t \n\tint\t\t\t\taborting;\n\n\t \n\tenum fdp1_deint_mode\t\tdeint_mode;\n\n\t \n\tunsigned int\t\t\tsmsk_size;\n\tdma_addr_t\t\t\tsmsk_addr[2];\n\tvoid\t\t\t\t*smsk_cpu;\n\n\t \n\tunsigned char\t\t\talpha;\n\n\t \n\tstruct fdp1_q_data\t\tout_q;  \n\tstruct fdp1_q_data\t\tcap_q;  \n\n\t \n\tstruct list_head\t\tfields_queue;\n\tunsigned int\t\t\tbuffers_queued;\n\n\t \n\tstruct fdp1_field_buffer\t*previous;\n};\n\nstatic inline struct fdp1_ctx *fh_to_ctx(struct v4l2_fh *fh)\n{\n\treturn container_of(fh, struct fdp1_ctx, fh);\n}\n\nstatic struct fdp1_q_data *get_q_data(struct fdp1_ctx *ctx,\n\t\t\t\t\t enum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn &ctx->out_q;\n\telse\n\t\treturn &ctx->cap_q;\n}\n\n \nstatic struct fdp1_job *list_remove_job(struct fdp1_dev *fdp1,\n\t\t\t\t\t struct list_head *list)\n{\n\tstruct fdp1_job *job;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fdp1->irqlock, flags);\n\tjob = list_first_entry_or_null(list, struct fdp1_job, list);\n\tif (job)\n\t\tlist_del(&job->list);\n\tspin_unlock_irqrestore(&fdp1->irqlock, flags);\n\n\treturn job;\n}\n\n \nstatic void list_add_job(struct fdp1_dev *fdp1,\n\t\t\t struct list_head *list,\n\t\t\t struct fdp1_job *job)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fdp1->irqlock, flags);\n\tlist_add_tail(&job->list, list);\n\tspin_unlock_irqrestore(&fdp1->irqlock, flags);\n}\n\nstatic struct fdp1_job *fdp1_job_alloc(struct fdp1_dev *fdp1)\n{\n\treturn list_remove_job(fdp1, &fdp1->free_job_list);\n}\n\nstatic void fdp1_job_free(struct fdp1_dev *fdp1, struct fdp1_job *job)\n{\n\t \n\tmemset(job, 0, sizeof(struct fdp1_job));\n\n\tlist_add_job(fdp1, &fdp1->free_job_list, job);\n}\n\nstatic void queue_job(struct fdp1_dev *fdp1, struct fdp1_job *job)\n{\n\tlist_add_job(fdp1, &fdp1->queued_job_list, job);\n}\n\nstatic struct fdp1_job *get_queued_job(struct fdp1_dev *fdp1)\n{\n\treturn list_remove_job(fdp1, &fdp1->queued_job_list);\n}\n\nstatic void queue_hw_job(struct fdp1_dev *fdp1, struct fdp1_job *job)\n{\n\tlist_add_job(fdp1, &fdp1->hw_job_list, job);\n}\n\nstatic struct fdp1_job *get_hw_queued_job(struct fdp1_dev *fdp1)\n{\n\treturn list_remove_job(fdp1, &fdp1->hw_job_list);\n}\n\n \nstatic void fdp1_field_complete(struct fdp1_ctx *ctx,\n\t\t\t\tstruct fdp1_field_buffer *fbuf)\n{\n\t \n\tif (!fbuf)\n\t\treturn;\n\n\tif (fbuf->last_field)\n\t\tv4l2_m2m_buf_done(fbuf->vb, VB2_BUF_STATE_DONE);\n}\n\nstatic void fdp1_queue_field(struct fdp1_ctx *ctx,\n\t\t\t     struct fdp1_field_buffer *fbuf)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->fdp1->irqlock, flags);\n\tlist_add_tail(&fbuf->list, &ctx->fields_queue);\n\tspin_unlock_irqrestore(&ctx->fdp1->irqlock, flags);\n\n\tctx->buffers_queued++;\n}\n\nstatic struct fdp1_field_buffer *fdp1_dequeue_field(struct fdp1_ctx *ctx)\n{\n\tstruct fdp1_field_buffer *fbuf;\n\tunsigned long flags;\n\n\tctx->buffers_queued--;\n\n\tspin_lock_irqsave(&ctx->fdp1->irqlock, flags);\n\tfbuf = list_first_entry_or_null(&ctx->fields_queue,\n\t\t\t\t\tstruct fdp1_field_buffer, list);\n\tif (fbuf)\n\t\tlist_del(&fbuf->list);\n\tspin_unlock_irqrestore(&ctx->fdp1->irqlock, flags);\n\n\treturn fbuf;\n}\n\n \nstatic struct fdp1_field_buffer *fdp1_peek_queued_field(struct fdp1_ctx *ctx)\n{\n\tstruct fdp1_field_buffer *fbuf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->fdp1->irqlock, flags);\n\tfbuf = list_first_entry_or_null(&ctx->fields_queue,\n\t\t\t\t\tstruct fdp1_field_buffer, list);\n\tspin_unlock_irqrestore(&ctx->fdp1->irqlock, flags);\n\n\treturn fbuf;\n}\n\nstatic u32 fdp1_read(struct fdp1_dev *fdp1, unsigned int reg)\n{\n\tu32 value = ioread32(fdp1->regs + reg);\n\n\tif (debug >= 2)\n\t\tdprintk(fdp1, \"Read 0x%08x from 0x%04x\\n\", value, reg);\n\n\treturn value;\n}\n\nstatic void fdp1_write(struct fdp1_dev *fdp1, u32 val, unsigned int reg)\n{\n\tif (debug >= 2)\n\t\tdprintk(fdp1, \"Write 0x%08x to 0x%04x\\n\", val, reg);\n\n\tiowrite32(val, fdp1->regs + reg);\n}\n\n \nstatic void fdp1_set_ipc_dli(struct fdp1_ctx *ctx)\n{\n\tstruct fdp1_dev *fdp1 = ctx->fdp1;\n\n\tfdp1_write(fdp1, FD1_IPC_SMSK_THRESH_CONST,\tFD1_IPC_SMSK_THRESH);\n\tfdp1_write(fdp1, FD1_IPC_COMB_DET_CONST,\tFD1_IPC_COMB_DET);\n\tfdp1_write(fdp1, FD1_IPC_MOTDEC_CONST,\tFD1_IPC_MOTDEC);\n\n\tfdp1_write(fdp1, FD1_IPC_DLI_BLEND_CONST,\tFD1_IPC_DLI_BLEND);\n\tfdp1_write(fdp1, FD1_IPC_DLI_HGAIN_CONST,\tFD1_IPC_DLI_HGAIN);\n\tfdp1_write(fdp1, FD1_IPC_DLI_SPRS_CONST,\tFD1_IPC_DLI_SPRS);\n\tfdp1_write(fdp1, FD1_IPC_DLI_ANGLE_CONST,\tFD1_IPC_DLI_ANGLE);\n\tfdp1_write(fdp1, FD1_IPC_DLI_ISOPIX0_CONST,\tFD1_IPC_DLI_ISOPIX0);\n\tfdp1_write(fdp1, FD1_IPC_DLI_ISOPIX1_CONST,\tFD1_IPC_DLI_ISOPIX1);\n}\n\n\nstatic void fdp1_set_ipc_sensor(struct fdp1_ctx *ctx)\n{\n\tstruct fdp1_dev *fdp1 = ctx->fdp1;\n\tstruct fdp1_q_data *src_q_data = &ctx->out_q;\n\tunsigned int x0, x1;\n\tunsigned int hsize = src_q_data->format.width;\n\tunsigned int vsize = src_q_data->format.height;\n\n\tx0 = hsize / 3;\n\tx1 = 2 * hsize / 3;\n\n\tfdp1_write(fdp1, FD1_IPC_SENSOR_TH0_CONST, FD1_IPC_SENSOR_TH0);\n\tfdp1_write(fdp1, FD1_IPC_SENSOR_TH1_CONST, FD1_IPC_SENSOR_TH1);\n\tfdp1_write(fdp1, FD1_IPC_SENSOR_CTL0_CONST, FD1_IPC_SENSOR_CTL0);\n\tfdp1_write(fdp1, FD1_IPC_SENSOR_CTL1_CONST, FD1_IPC_SENSOR_CTL1);\n\n\tfdp1_write(fdp1, ((hsize - 1) << FD1_IPC_SENSOR_CTL2_X_SHIFT) |\n\t\t\t ((vsize - 1) << FD1_IPC_SENSOR_CTL2_Y_SHIFT),\n\t\t\t FD1_IPC_SENSOR_CTL2);\n\n\tfdp1_write(fdp1, (x0 << FD1_IPC_SENSOR_CTL3_0_SHIFT) |\n\t\t\t (x1 << FD1_IPC_SENSOR_CTL3_1_SHIFT),\n\t\t\t FD1_IPC_SENSOR_CTL3);\n}\n\n \nstatic void fdp1_write_lut(struct fdp1_dev *fdp1, const u8 *lut,\n\t\t\t   unsigned int len, unsigned int base)\n{\n\tunsigned int i;\n\tu8 pad;\n\n\t \n\tlen = min(len, 256u);\n\n\tfor (i = 0; i < len; i++)\n\t\tfdp1_write(fdp1, lut[i], base + (i*4));\n\n\t \n\tpad = lut[i-1];\n\n\tfor (; i < 256; i++)\n\t\tfdp1_write(fdp1, pad, base + (i*4));\n}\n\nstatic void fdp1_set_lut(struct fdp1_dev *fdp1)\n{\n\tfdp1_write_lut(fdp1, fdp1_diff_adj, ARRAY_SIZE(fdp1_diff_adj),\n\t\t\tFD1_LUT_DIF_ADJ);\n\tfdp1_write_lut(fdp1, fdp1_sad_adj,  ARRAY_SIZE(fdp1_sad_adj),\n\t\t\tFD1_LUT_SAD_ADJ);\n\tfdp1_write_lut(fdp1, fdp1_bld_gain, ARRAY_SIZE(fdp1_bld_gain),\n\t\t\tFD1_LUT_BLD_GAIN);\n\tfdp1_write_lut(fdp1, fdp1_dif_gain, ARRAY_SIZE(fdp1_dif_gain),\n\t\t\tFD1_LUT_DIF_GAIN);\n\tfdp1_write_lut(fdp1, fdp1_mdet, ARRAY_SIZE(fdp1_mdet),\n\t\t\tFD1_LUT_MDET);\n}\n\nstatic void fdp1_configure_rpf(struct fdp1_ctx *ctx,\n\t\t\t       struct fdp1_job *job)\n{\n\tstruct fdp1_dev *fdp1 = ctx->fdp1;\n\tu32 picture_size;\n\tu32 pstride;\n\tu32 format;\n\tu32 smsk_addr;\n\n\tstruct fdp1_q_data *q_data = &ctx->out_q;\n\n\t \n\tpicture_size = (q_data->format.width << FD1_RPF_SIZE_H_SHIFT)\n\t\t     | (q_data->vsize << FD1_RPF_SIZE_V_SHIFT);\n\n\t \n\tpstride = q_data->stride_y << FD1_RPF_PSTRIDE_Y_SHIFT;\n\tif (q_data->format.num_planes > 1)\n\t\tpstride |= q_data->stride_c << FD1_RPF_PSTRIDE_C_SHIFT;\n\n\t \n\tformat = q_data->fmt->fmt;\n\tif (q_data->fmt->swap_yc)\n\t\tformat |= FD1_RPF_FORMAT_RSPYCS;\n\n\tif (q_data->fmt->swap_uv)\n\t\tformat |= FD1_RPF_FORMAT_RSPUVS;\n\n\tif (job->active->field == V4L2_FIELD_BOTTOM) {\n\t\tformat |= FD1_RPF_FORMAT_CF;  \n\t\tsmsk_addr = ctx->smsk_addr[0];\n\t} else {\n\t\tsmsk_addr = ctx->smsk_addr[1];\n\t}\n\n\t \n\tif (ctx->deint_mode)\n\t\tformat |= FD1_RPF_FORMAT_CIPM;\n\n\tfdp1_write(fdp1, format, FD1_RPF_FORMAT);\n\tfdp1_write(fdp1, q_data->fmt->swap, FD1_RPF_SWAP);\n\tfdp1_write(fdp1, picture_size, FD1_RPF_SIZE);\n\tfdp1_write(fdp1, pstride, FD1_RPF_PSTRIDE);\n\tfdp1_write(fdp1, smsk_addr, FD1_RPF_SMSK_ADDR);\n\n\t \n\tif (job->previous)\n\t\tfdp1_write(fdp1, job->previous->addrs[0], FD1_RPF0_ADDR_Y);\n\n\t \n\tfdp1_write(fdp1, job->active->addrs[0], FD1_RPF1_ADDR_Y);\n\tfdp1_write(fdp1, job->active->addrs[1], FD1_RPF1_ADDR_C0);\n\tfdp1_write(fdp1, job->active->addrs[2], FD1_RPF1_ADDR_C1);\n\n\t \n\tif (job->next)\n\t\tfdp1_write(fdp1, job->next->addrs[0], FD1_RPF2_ADDR_Y);\n}\n\nstatic void fdp1_configure_wpf(struct fdp1_ctx *ctx,\n\t\t\t       struct fdp1_job *job)\n{\n\tstruct fdp1_dev *fdp1 = ctx->fdp1;\n\tstruct fdp1_q_data *src_q_data = &ctx->out_q;\n\tstruct fdp1_q_data *q_data = &ctx->cap_q;\n\tu32 pstride;\n\tu32 format;\n\tu32 swap;\n\tu32 rndctl;\n\n\tpstride = q_data->format.plane_fmt[0].bytesperline\n\t\t<< FD1_WPF_PSTRIDE_Y_SHIFT;\n\n\tif (q_data->format.num_planes > 1)\n\t\tpstride |= q_data->format.plane_fmt[1].bytesperline\n\t\t\t<< FD1_WPF_PSTRIDE_C_SHIFT;\n\n\tformat = q_data->fmt->fmt;  \n\n\tif (q_data->fmt->swap_yc)\n\t\tformat |= FD1_WPF_FORMAT_WSPYCS;\n\n\tif (q_data->fmt->swap_uv)\n\t\tformat |= FD1_WPF_FORMAT_WSPUVS;\n\n\tif (fdp1_fmt_is_rgb(q_data->fmt)) {\n\t\t \n\t\tformat |= FD1_WPF_FORMAT_CSC;\n\n\t\t \n\t\tif (src_q_data->format.ycbcr_enc == V4L2_YCBCR_ENC_709)\n\t\t\tformat |= FD1_WPF_FORMAT_WRTM_709_16;\n\t\telse if (src_q_data->format.quantization ==\n\t\t\t\tV4L2_QUANTIZATION_FULL_RANGE)\n\t\t\tformat |= FD1_WPF_FORMAT_WRTM_601_0;\n\t\telse\n\t\t\tformat |= FD1_WPF_FORMAT_WRTM_601_16;\n\t}\n\n\t \n\tformat |= ctx->alpha << FD1_WPF_FORMAT_PDV_SHIFT;\n\n\t \n\trndctl = FD1_WPF_RNDCTL_CBRM;  \n\trndctl |= FD1_WPF_RNDCTL_CLMD_NOCLIP;\n\n\t \n\tswap = q_data->fmt->swap << FD1_WPF_SWAP_OSWAP_SHIFT;\n\tswap |= src_q_data->fmt->swap << FD1_WPF_SWAP_SSWAP_SHIFT;\n\n\tfdp1_write(fdp1, format, FD1_WPF_FORMAT);\n\tfdp1_write(fdp1, rndctl, FD1_WPF_RNDCTL);\n\tfdp1_write(fdp1, swap, FD1_WPF_SWAP);\n\tfdp1_write(fdp1, pstride, FD1_WPF_PSTRIDE);\n\n\tfdp1_write(fdp1, job->dst->addrs[0], FD1_WPF_ADDR_Y);\n\tfdp1_write(fdp1, job->dst->addrs[1], FD1_WPF_ADDR_C0);\n\tfdp1_write(fdp1, job->dst->addrs[2], FD1_WPF_ADDR_C1);\n}\n\nstatic void fdp1_configure_deint_mode(struct fdp1_ctx *ctx,\n\t\t\t\t      struct fdp1_job *job)\n{\n\tstruct fdp1_dev *fdp1 = ctx->fdp1;\n\tu32 opmode = FD1_CTL_OPMODE_VIMD_NOINTERRUPT;\n\tu32 ipcmode = FD1_IPC_MODE_DLI;  \n\tu32 channels = FD1_CTL_CHACT_WR | FD1_CTL_CHACT_RD1;  \n\n\t \n\tswitch (ctx->deint_mode) {\n\tdefault:\n\tcase FDP1_PROGRESSIVE:\n\t\tdprintk(fdp1, \"Progressive Mode\\n\");\n\t\topmode |= FD1_CTL_OPMODE_PRG;\n\t\tipcmode |= FD1_IPC_MODE_DIM_FIXED2D;\n\t\tbreak;\n\tcase FDP1_ADAPT2D3D:\n\t\tdprintk(fdp1, \"Adapt2D3D Mode\\n\");\n\t\tif (ctx->sequence == 0 || ctx->aborting)\n\t\t\tipcmode |= FD1_IPC_MODE_DIM_FIXED2D;\n\t\telse\n\t\t\tipcmode |= FD1_IPC_MODE_DIM_ADAPT2D3D;\n\n\t\tif (ctx->sequence > 1) {\n\t\t\tchannels |= FD1_CTL_CHACT_SMW;\n\t\t\tchannels |= FD1_CTL_CHACT_RD0 | FD1_CTL_CHACT_RD2;\n\t\t}\n\n\t\tif (ctx->sequence > 2)\n\t\t\tchannels |= FD1_CTL_CHACT_SMR;\n\n\t\tbreak;\n\tcase FDP1_FIXED3D:\n\t\tdprintk(fdp1, \"Fixed 3D Mode\\n\");\n\t\tipcmode |= FD1_IPC_MODE_DIM_FIXED3D;\n\t\t \n\t\tif (!(ctx->sequence == 0 || ctx->aborting))\n\t\t\tchannels |= FD1_CTL_CHACT_RD0 | FD1_CTL_CHACT_RD2;\n\t\tbreak;\n\tcase FDP1_FIXED2D:\n\t\tdprintk(fdp1, \"Fixed 2D Mode\\n\");\n\t\tipcmode |= FD1_IPC_MODE_DIM_FIXED2D;\n\t\t \n\t\tbreak;\n\tcase FDP1_PREVFIELD:\n\t\tdprintk(fdp1, \"Previous Field Mode\\n\");\n\t\tipcmode |= FD1_IPC_MODE_DIM_PREVFIELD;\n\t\tchannels |= FD1_CTL_CHACT_RD0;  \n\t\tbreak;\n\tcase FDP1_NEXTFIELD:\n\t\tdprintk(fdp1, \"Next Field Mode\\n\");\n\t\tipcmode |= FD1_IPC_MODE_DIM_NEXTFIELD;\n\t\tchannels |= FD1_CTL_CHACT_RD2;  \n\t\tbreak;\n\t}\n\n\tfdp1_write(fdp1, channels,\tFD1_CTL_CHACT);\n\tfdp1_write(fdp1, opmode,\tFD1_CTL_OPMODE);\n\tfdp1_write(fdp1, ipcmode,\tFD1_IPC_MODE);\n}\n\n \nstatic int fdp1_device_process(struct fdp1_ctx *ctx)\n\n{\n\tstruct fdp1_dev *fdp1 = ctx->fdp1;\n\tstruct fdp1_job *job;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fdp1->device_process_lock, flags);\n\n\t \n\tjob = get_queued_job(fdp1);\n\tif (!job) {\n\t\t \n\t\tspin_unlock_irqrestore(&fdp1->device_process_lock, flags);\n\t\treturn 0;\n\t}\n\n\t \n\tfdp1_write(fdp1, FD1_CTL_CLKCTRL_CSTP_N, FD1_CTL_CLKCTRL);\n\n\t \n\tfdp1_configure_deint_mode(ctx, job);\n\n\t \n\tfdp1_set_ipc_dli(ctx);\n\n\t \n\tfdp1_set_ipc_sensor(ctx);\n\n\t \n\tfdp1_configure_rpf(ctx, job);\n\n\t \n\tfdp1_configure_wpf(ctx, job);\n\n\t \n\tfdp1_write(fdp1, FD1_IPC_LMEM_LINEAR, FD1_IPC_LMEM);\n\n\t \n\tfdp1_write(fdp1, FD1_CTL_IRQ_MASK, FD1_CTL_IRQENB);\n\n\t \n\n\t \n\tqueue_hw_job(fdp1, job);\n\n\t \n\tfdp1_write(fdp1, FD1_CTL_CMD_STRCMD, FD1_CTL_CMD);\n\n\t \n\tfdp1_write(fdp1, FD1_CTL_REGEND_REGEND, FD1_CTL_REGEND);\n\n\t \n\tfdp1_write(fdp1, FD1_CTL_SGCMD_SGEN, FD1_CTL_SGCMD);\n\n\tspin_unlock_irqrestore(&fdp1->device_process_lock, flags);\n\n\treturn 0;\n}\n\n \n\n \nstatic int fdp1_m2m_job_ready(void *priv)\n{\n\tstruct fdp1_ctx *ctx = priv;\n\tstruct fdp1_q_data *src_q_data = &ctx->out_q;\n\tint srcbufs = 1;\n\tint dstbufs = 1;\n\n\tdprintk(ctx->fdp1, \"+ Src: %d : Dst: %d\\n\",\n\t\tv4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx),\n\t\tv4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx));\n\n\t \n\tif (V4L2_FIELD_HAS_BOTH(src_q_data->format.field))\n\t\tdstbufs = 2;\n\n\tif (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) < srcbufs\n\t    || v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) < dstbufs) {\n\t\tdprintk(ctx->fdp1, \"Not enough buffers available\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void fdp1_m2m_job_abort(void *priv)\n{\n\tstruct fdp1_ctx *ctx = priv;\n\n\tdprintk(ctx->fdp1, \"+\\n\");\n\n\t \n\tctx->aborting = 1;\n\n\t \n\tfdp1_write(ctx->fdp1, 0, FD1_CTL_SGCMD);\n\tfdp1_write(ctx->fdp1, FD1_CTL_SRESET_SRST, FD1_CTL_SRESET);\n}\n\n \nstatic struct fdp1_job *fdp1_prepare_job(struct fdp1_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct fdp1_buffer *fbuf;\n\tstruct fdp1_dev *fdp1 = ctx->fdp1;\n\tstruct fdp1_job *job;\n\tunsigned int buffers_required = 1;\n\n\tdprintk(fdp1, \"+\\n\");\n\n\tif (FDP1_DEINT_MODE_USES_NEXT(ctx->deint_mode))\n\t\tbuffers_required = 2;\n\n\tif (ctx->buffers_queued < buffers_required)\n\t\treturn NULL;\n\n\tjob = fdp1_job_alloc(fdp1);\n\tif (!job) {\n\t\tdprintk(fdp1, \"No free jobs currently available\\n\");\n\t\treturn NULL;\n\t}\n\n\tjob->active = fdp1_dequeue_field(ctx);\n\tif (!job->active) {\n\t\t \n\t\tdprintk(fdp1, \"No input buffers currently available\\n\");\n\n\t\tfdp1_job_free(fdp1, job);\n\t\treturn NULL;\n\t}\n\n\tdprintk(fdp1, \"+ Buffer en-route...\\n\");\n\n\t \n\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tfbuf = to_fdp1_buffer(vbuf);\n\tjob->dst = &fbuf->fields[0];\n\n\tjob->active->vb->sequence = ctx->sequence;\n\tjob->dst->vb->sequence = ctx->sequence;\n\tctx->sequence++;\n\n\tif (FDP1_DEINT_MODE_USES_PREV(ctx->deint_mode)) {\n\t\tjob->previous = ctx->previous;\n\n\t\t \n\t\tctx->previous = job->active;\n\t}\n\n\tif (FDP1_DEINT_MODE_USES_NEXT(ctx->deint_mode)) {\n\t\t \n\t\tjob->next = fdp1_peek_queued_field(ctx);\n\t}\n\n\t \n\n\tjob->dst->vb->vb2_buf.timestamp = job->active->vb->vb2_buf.timestamp;\n\n\tjob->dst->vb->flags = job->active->vb->flags &\n\t\t\t\tV4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\t \n\tctx->translen++;\n\n\t \n\tqueue_job(fdp1, job);\n\n\tdprintk(fdp1, \"Job Queued translen = %d\\n\", ctx->translen);\n\n\treturn job;\n}\n\n \nstatic void fdp1_m2m_device_run(void *priv)\n{\n\tstruct fdp1_ctx *ctx = priv;\n\tstruct fdp1_dev *fdp1 = ctx->fdp1;\n\tstruct vb2_v4l2_buffer *src_vb;\n\tstruct fdp1_buffer *buf;\n\tunsigned int i;\n\n\tdprintk(fdp1, \"+\\n\");\n\n\tctx->translen = 0;\n\n\t \n\tsrc_vb = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tbuf = to_fdp1_buffer(src_vb);\n\n\tfor (i = 0; i < buf->num_fields; i++) {\n\t\tstruct fdp1_field_buffer *fbuf = &buf->fields[i];\n\n\t\tfdp1_queue_field(ctx, fbuf);\n\t\tdprintk(fdp1, \"Queued Buffer [%d] last_field:%d\\n\",\n\t\t\ti, fbuf->last_field);\n\t}\n\n\t \n\twhile (fdp1_prepare_job(ctx))\n\t\t;\n\n\tif (ctx->translen == 0) {\n\t\tdprintk(fdp1, \"No jobs were processed. M2M action complete\\n\");\n\t\tv4l2_m2m_job_finish(fdp1->m2m_dev, ctx->fh.m2m_ctx);\n\t\treturn;\n\t}\n\n\t \n\tfdp1_device_process(ctx);\n}\n\n \nstatic void device_frame_end(struct fdp1_dev *fdp1,\n\t\t\t     enum vb2_buffer_state state)\n{\n\tstruct fdp1_ctx *ctx;\n\tunsigned long flags;\n\tstruct fdp1_job *job = get_hw_queued_job(fdp1);\n\n\tdprintk(fdp1, \"+\\n\");\n\n\tctx = v4l2_m2m_get_curr_priv(fdp1->m2m_dev);\n\n\tif (ctx == NULL) {\n\t\tv4l2_err(&fdp1->v4l2_dev,\n\t\t\t\"Instance released before the end of transaction\\n\");\n\t\treturn;\n\t}\n\n\tctx->num_processed++;\n\n\t \n\tif (FDP1_DEINT_MODE_USES_PREV(ctx->deint_mode))\n\t\tfdp1_field_complete(ctx, job->previous);\n\telse\n\t\tfdp1_field_complete(ctx, job->active);\n\n\tspin_lock_irqsave(&fdp1->irqlock, flags);\n\tv4l2_m2m_buf_done(job->dst->vb, state);\n\tjob->dst = NULL;\n\tspin_unlock_irqrestore(&fdp1->irqlock, flags);\n\n\t \n\tfdp1_job_free(fdp1, job);\n\n\tdprintk(fdp1, \"curr_ctx->num_processed %d curr_ctx->translen %d\\n\",\n\t\tctx->num_processed, ctx->translen);\n\n\tif (ctx->num_processed == ctx->translen ||\n\t\t\tctx->aborting) {\n\t\tdprintk(ctx->fdp1, \"Finishing transaction\\n\");\n\t\tctx->num_processed = 0;\n\t\tv4l2_m2m_job_finish(fdp1->m2m_dev, ctx->fh.m2m_ctx);\n\t} else {\n\t\t \n\t\tfdp1_device_process(ctx);\n\t}\n}\n\n \nstatic int fdp1_vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, DRIVER_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, DRIVER_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:%s\", DRIVER_NAME);\n\treturn 0;\n}\n\nstatic int fdp1_enum_fmt(struct v4l2_fmtdesc *f, u32 type)\n{\n\tunsigned int i, num;\n\n\tnum = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(fdp1_formats); ++i) {\n\t\tif (fdp1_formats[i].types & type) {\n\t\t\tif (num == f->index)\n\t\t\t\tbreak;\n\t\t\t++num;\n\t\t}\n\t}\n\n\t \n\tif (i >= ARRAY_SIZE(fdp1_formats))\n\t\treturn -EINVAL;\n\n\t \n\tf->pixelformat = fdp1_formats[i].fourcc;\n\n\treturn 0;\n}\n\nstatic int fdp1_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_fmtdesc *f)\n{\n\treturn fdp1_enum_fmt(f, FDP1_CAPTURE);\n}\n\nstatic int fdp1_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn fdp1_enum_fmt(f, FDP1_OUTPUT);\n}\n\nstatic int fdp1_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct fdp1_q_data *q_data;\n\tstruct fdp1_ctx *ctx = fh_to_ctx(priv);\n\n\tif (!v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type))\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, f->type);\n\tf->fmt.pix_mp = q_data->format;\n\n\treturn 0;\n}\n\nstatic void fdp1_compute_stride(struct v4l2_pix_format_mplane *pix,\n\t\t\t\tconst struct fdp1_fmt *fmt)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < min_t(unsigned int, fmt->num_planes, 2U); ++i) {\n\t\tunsigned int hsub = i > 0 ? fmt->hsub : 1;\n\t\tunsigned int vsub = i > 0 ? fmt->vsub : 1;\n\t\t  \n\t\tunsigned int align = 128;\n\t\tunsigned int bpl;\n\n\t\tbpl = clamp_t(unsigned int, pix->plane_fmt[i].bytesperline,\n\t\t\t      pix->width / hsub * fmt->bpp[i] / 8,\n\t\t\t      round_down(FDP1_MAX_STRIDE, align));\n\n\t\tpix->plane_fmt[i].bytesperline = round_up(bpl, align);\n\t\tpix->plane_fmt[i].sizeimage = pix->plane_fmt[i].bytesperline\n\t\t\t\t\t    * pix->height / vsub;\n\n\t}\n\n\tif (fmt->num_planes == 3) {\n\t\t \n\t\tpix->plane_fmt[2].bytesperline = pix->plane_fmt[1].bytesperline;\n\t\tpix->plane_fmt[2].sizeimage = pix->plane_fmt[1].sizeimage;\n\n\t}\n}\n\nstatic void fdp1_try_fmt_output(struct fdp1_ctx *ctx,\n\t\t\t\tconst struct fdp1_fmt **fmtinfo,\n\t\t\t\tstruct v4l2_pix_format_mplane *pix)\n{\n\tconst struct fdp1_fmt *fmt;\n\tunsigned int width;\n\tunsigned int height;\n\n\t \n\tfmt = fdp1_find_format(pix->pixelformat);\n\tif (!fmt || !(fmt->types & FDP1_OUTPUT))\n\t\tfmt = fdp1_find_format(V4L2_PIX_FMT_YUYV);\n\n\tif (fmtinfo)\n\t\t*fmtinfo = fmt;\n\n\tpix->pixelformat = fmt->fourcc;\n\tpix->num_planes = fmt->num_planes;\n\n\t \n\tif (pix->field != V4L2_FIELD_NONE &&\n\t    pix->field != V4L2_FIELD_ALTERNATE &&\n\t    !V4L2_FIELD_HAS_BOTH(pix->field))\n\t\tpix->field = V4L2_FIELD_INTERLACED;\n\n\t \n\tif (pix->colorspace == V4L2_COLORSPACE_DEFAULT)\n\t\tpix->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\t \n\twidth = round_down(pix->width, fmt->hsub);\n\tpix->width = clamp(width, FDP1_MIN_W, FDP1_MAX_W);\n\n\theight = round_down(pix->height, fmt->vsub);\n\tif (pix->field == V4L2_FIELD_ALTERNATE)\n\t\tpix->height = clamp(height, FDP1_MIN_H / 2, FDP1_MAX_H / 2);\n\telse\n\t\tpix->height = clamp(height, FDP1_MIN_H, FDP1_MAX_H);\n\n\tfdp1_compute_stride(pix, fmt);\n}\n\nstatic void fdp1_try_fmt_capture(struct fdp1_ctx *ctx,\n\t\t\t\t const struct fdp1_fmt **fmtinfo,\n\t\t\t\t struct v4l2_pix_format_mplane *pix)\n{\n\tstruct fdp1_q_data *src_data = &ctx->out_q;\n\tenum v4l2_colorspace colorspace;\n\tenum v4l2_ycbcr_encoding ycbcr_enc;\n\tenum v4l2_quantization quantization;\n\tconst struct fdp1_fmt *fmt;\n\tbool allow_rgb;\n\n\t \n\tcolorspace = src_data->format.colorspace;\n\n\tycbcr_enc = src_data->format.ycbcr_enc;\n\tif (ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT)\n\t\tycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(colorspace);\n\n\tquantization = src_data->format.quantization;\n\tif (quantization == V4L2_QUANTIZATION_DEFAULT)\n\t\tquantization = V4L2_MAP_QUANTIZATION_DEFAULT(false, colorspace,\n\t\t\t\t\t\t\t     ycbcr_enc);\n\n\tallow_rgb = ycbcr_enc == V4L2_YCBCR_ENC_601 ||\n\t\t    (ycbcr_enc == V4L2_YCBCR_ENC_709 &&\n\t\t     quantization == V4L2_QUANTIZATION_LIM_RANGE);\n\n\tfmt = fdp1_find_format(pix->pixelformat);\n\tif (!fmt || (!allow_rgb && fdp1_fmt_is_rgb(fmt)))\n\t\tfmt = fdp1_find_format(V4L2_PIX_FMT_YUYV);\n\n\tif (fmtinfo)\n\t\t*fmtinfo = fmt;\n\n\tpix->pixelformat = fmt->fourcc;\n\tpix->num_planes = fmt->num_planes;\n\tpix->field = V4L2_FIELD_NONE;\n\n\t \n\tpix->colorspace = src_data->format.colorspace;\n\tpix->xfer_func = src_data->format.xfer_func;\n\n\tif (fdp1_fmt_is_rgb(fmt)) {\n\t\tpix->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\t\tpix->quantization = V4L2_QUANTIZATION_DEFAULT;\n\t} else {\n\t\tpix->ycbcr_enc = src_data->format.ycbcr_enc;\n\t\tpix->quantization = src_data->format.quantization;\n\t}\n\n\t \n\tpix->width = src_data->format.width;\n\tif (src_data->format.field == V4L2_FIELD_ALTERNATE)\n\t\tpix->height = 2 * src_data->format.height;\n\telse\n\t\tpix->height = src_data->format.height;\n\n\tfdp1_compute_stride(pix, fmt);\n}\n\nstatic int fdp1_try_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct fdp1_ctx *ctx = fh_to_ctx(priv);\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tfdp1_try_fmt_output(ctx, NULL, &f->fmt.pix_mp);\n\telse\n\t\tfdp1_try_fmt_capture(ctx, NULL, &f->fmt.pix_mp);\n\n\tdprintk(ctx->fdp1, \"Try %s format: %4.4s (0x%08x) %ux%u field %u\\n\",\n\t\tV4L2_TYPE_IS_OUTPUT(f->type) ? \"output\" : \"capture\",\n\t\t(char *)&f->fmt.pix_mp.pixelformat, f->fmt.pix_mp.pixelformat,\n\t\tf->fmt.pix_mp.width, f->fmt.pix_mp.height, f->fmt.pix_mp.field);\n\n\treturn 0;\n}\n\nstatic void fdp1_set_format(struct fdp1_ctx *ctx,\n\t\t\t    struct v4l2_pix_format_mplane *pix,\n\t\t\t    enum v4l2_buf_type type)\n{\n\tstruct fdp1_q_data *q_data = get_q_data(ctx, type);\n\tconst struct fdp1_fmt *fmtinfo;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tfdp1_try_fmt_output(ctx, &fmtinfo, pix);\n\telse\n\t\tfdp1_try_fmt_capture(ctx, &fmtinfo, pix);\n\n\tq_data->fmt = fmtinfo;\n\tq_data->format = *pix;\n\n\tq_data->vsize = pix->height;\n\tif (pix->field != V4L2_FIELD_NONE)\n\t\tq_data->vsize /= 2;\n\n\tq_data->stride_y = pix->plane_fmt[0].bytesperline;\n\tq_data->stride_c = pix->plane_fmt[1].bytesperline;\n\n\t \n\tif (pix->field == V4L2_FIELD_INTERLACED ||\n\t    pix->field == V4L2_FIELD_INTERLACED_TB ||\n\t    pix->field == V4L2_FIELD_INTERLACED_BT) {\n\t\tq_data->stride_y *= 2;\n\t\tq_data->stride_c *= 2;\n\t}\n\n\t \n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tstruct fdp1_q_data *dst_data = &ctx->cap_q;\n\n\t\t \n\t\tdst_data->format = q_data->format;\n\t\tmemset(dst_data->format.plane_fmt, 0,\n\t\t       sizeof(dst_data->format.plane_fmt));\n\n\t\tdst_data->format.field = V4L2_FIELD_NONE;\n\t\tif (pix->field == V4L2_FIELD_ALTERNATE)\n\t\t\tdst_data->format.height *= 2;\n\n\t\tfdp1_try_fmt_capture(ctx, &dst_data->fmt, &dst_data->format);\n\n\t\tdst_data->vsize = dst_data->format.height;\n\t\tdst_data->stride_y = dst_data->format.plane_fmt[0].bytesperline;\n\t\tdst_data->stride_c = dst_data->format.plane_fmt[1].bytesperline;\n\t}\n}\n\nstatic int fdp1_s_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct fdp1_ctx *ctx = fh_to_ctx(priv);\n\tstruct v4l2_m2m_ctx *m2m_ctx = ctx->fh.m2m_ctx;\n\tstruct vb2_queue *vq = v4l2_m2m_get_vq(m2m_ctx, f->type);\n\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&ctx->fdp1->v4l2_dev, \"%s queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tfdp1_set_format(ctx, &f->fmt.pix_mp, f->type);\n\n\tdprintk(ctx->fdp1, \"Set %s format: %4.4s (0x%08x) %ux%u field %u\\n\",\n\t\tV4L2_TYPE_IS_OUTPUT(f->type) ? \"output\" : \"capture\",\n\t\t(char *)&f->fmt.pix_mp.pixelformat, f->fmt.pix_mp.pixelformat,\n\t\tf->fmt.pix_mp.width, f->fmt.pix_mp.height, f->fmt.pix_mp.field);\n\n\treturn 0;\n}\n\nstatic int fdp1_g_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct fdp1_ctx *ctx =\n\t\tcontainer_of(ctrl->handler, struct fdp1_ctx, hdl);\n\tstruct fdp1_q_data *src_q_data = &ctx->out_q;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:\n\t\tif (V4L2_FIELD_HAS_BOTH(src_q_data->format.field))\n\t\t\tctrl->val = 2;\n\t\telse\n\t\t\tctrl->val = 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int fdp1_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct fdp1_ctx *ctx =\n\t\tcontainer_of(ctrl->handler, struct fdp1_ctx, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_ALPHA_COMPONENT:\n\t\tctx->alpha = ctrl->val;\n\t\tbreak;\n\n\tcase V4L2_CID_DEINTERLACING_MODE:\n\t\tctx->deint_mode = ctrl->val;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops fdp1_ctrl_ops = {\n\t.s_ctrl = fdp1_s_ctrl,\n\t.g_volatile_ctrl = fdp1_g_ctrl,\n};\n\nstatic const char * const fdp1_ctrl_deint_menu[] = {\n\t\"Progressive\",\n\t\"Adaptive 2D/3D\",\n\t\"Fixed 2D\",\n\t\"Fixed 3D\",\n\t\"Previous field\",\n\t\"Next field\",\n\tNULL\n};\n\nstatic const struct v4l2_ioctl_ops fdp1_ioctl_ops = {\n\t.vidioc_querycap\t= fdp1_vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= fdp1_enum_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_out\t= fdp1_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_cap_mplane\t= fdp1_g_fmt,\n\t.vidioc_g_fmt_vid_out_mplane\t= fdp1_g_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane\t= fdp1_try_fmt,\n\t.vidioc_try_fmt_vid_out_mplane\t= fdp1_try_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane\t= fdp1_s_fmt,\n\t.vidioc_s_fmt_vid_out_mplane\t= fdp1_s_fmt,\n\n\t.vidioc_reqbufs\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n \n\nstatic int fdp1_queue_setup(struct vb2_queue *vq,\n\t\t\t\tunsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t\tunsigned int sizes[],\n\t\t\t\tstruct device *alloc_ctxs[])\n{\n\tstruct fdp1_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct fdp1_q_data *q_data;\n\tunsigned int i;\n\n\tq_data = get_q_data(ctx, vq->type);\n\n\tif (*nplanes) {\n\t\tif (*nplanes > FDP1_MAX_PLANES)\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\t*nplanes = q_data->format.num_planes;\n\n\tfor (i = 0; i < *nplanes; i++)\n\t\tsizes[i] = q_data->format.plane_fmt[i].sizeimage;\n\n\treturn 0;\n}\n\nstatic void fdp1_buf_prepare_field(struct fdp1_q_data *q_data,\n\t\t\t\t   struct vb2_v4l2_buffer *vbuf,\n\t\t\t\t   unsigned int field_num)\n{\n\tstruct fdp1_buffer *buf = to_fdp1_buffer(vbuf);\n\tstruct fdp1_field_buffer *fbuf = &buf->fields[field_num];\n\tunsigned int num_fields;\n\tunsigned int i;\n\n\tnum_fields = V4L2_FIELD_HAS_BOTH(vbuf->field) ? 2 : 1;\n\n\tfbuf->vb = vbuf;\n\tfbuf->last_field = (field_num + 1) == num_fields;\n\n\tfor (i = 0; i < vbuf->vb2_buf.num_planes; ++i)\n\t\tfbuf->addrs[i] = vb2_dma_contig_plane_dma_addr(&vbuf->vb2_buf, i);\n\n\tswitch (vbuf->field) {\n\tcase V4L2_FIELD_INTERLACED:\n\t\t \n\t\tfbuf->field = (q_data->format.height < 576) == field_num\n\t\t\t    ? V4L2_FIELD_TOP : V4L2_FIELD_BOTTOM;\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED_TB:\n\tcase V4L2_FIELD_SEQ_TB:\n\t\tfbuf->field = field_num ? V4L2_FIELD_BOTTOM : V4L2_FIELD_TOP;\n\t\tbreak;\n\tcase V4L2_FIELD_INTERLACED_BT:\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tfbuf->field = field_num ? V4L2_FIELD_TOP : V4L2_FIELD_BOTTOM;\n\t\tbreak;\n\tdefault:\n\t\tfbuf->field = vbuf->field;\n\t\tbreak;\n\t}\n\n\t \n\tif (!field_num)\n\t\treturn;\n\n\t \n\tswitch (vbuf->field) {\n\tcase V4L2_FIELD_INTERLACED:\n\tcase V4L2_FIELD_INTERLACED_TB:\n\tcase V4L2_FIELD_INTERLACED_BT:\n\t\tfor (i = 0; i < vbuf->vb2_buf.num_planes; i++)\n\t\t\tfbuf->addrs[i] +=\n\t\t\t\t(i == 0 ? q_data->stride_y : q_data->stride_c);\n\t\tbreak;\n\tcase V4L2_FIELD_SEQ_TB:\n\tcase V4L2_FIELD_SEQ_BT:\n\t\tfor (i = 0; i < vbuf->vb2_buf.num_planes; i++)\n\t\t\tfbuf->addrs[i] += q_data->vsize *\n\t\t\t\t(i == 0 ? q_data->stride_y : q_data->stride_c);\n\t\tbreak;\n\t}\n}\n\nstatic int fdp1_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct fdp1_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct fdp1_q_data *q_data = get_q_data(ctx, vb->vb2_queue->type);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct fdp1_buffer *buf = to_fdp1_buffer(vbuf);\n\tunsigned int i;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\n\t\tbool field_valid = true;\n\n\t\t \n\t\tswitch (q_data->format.field) {\n\t\tcase V4L2_FIELD_NONE:\n\t\t\tif (vbuf->field != V4L2_FIELD_NONE)\n\t\t\t\tfield_valid = false;\n\t\t\tbreak;\n\n\t\tcase V4L2_FIELD_ALTERNATE:\n\t\t\tif (vbuf->field != V4L2_FIELD_TOP &&\n\t\t\t    vbuf->field != V4L2_FIELD_BOTTOM)\n\t\t\t\tfield_valid = false;\n\t\t\tbreak;\n\n\t\tcase V4L2_FIELD_INTERLACED:\n\t\tcase V4L2_FIELD_SEQ_TB:\n\t\tcase V4L2_FIELD_SEQ_BT:\n\t\tcase V4L2_FIELD_INTERLACED_TB:\n\t\tcase V4L2_FIELD_INTERLACED_BT:\n\t\t\tif (vbuf->field != q_data->format.field)\n\t\t\t\tfield_valid = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!field_valid) {\n\t\t\tdprintk(ctx->fdp1,\n\t\t\t\t\"buffer field %u invalid for format field %u\\n\",\n\t\t\t\tvbuf->field, q_data->format.field);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tvbuf->field = V4L2_FIELD_NONE;\n\t}\n\n\t \n\tfor (i = 0; i < q_data->format.num_planes; i++) {\n\t\tunsigned long size = q_data->format.plane_fmt[i].sizeimage;\n\n\t\tif (vb2_plane_size(vb, i) < size) {\n\t\t\tdprintk(ctx->fdp1,\n\t\t\t\t\"data will not fit into plane [%u/%u] (%lu < %lu)\\n\",\n\t\t\t\ti, q_data->format.num_planes,\n\t\t\t\tvb2_plane_size(vb, i), size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tvb2_set_plane_payload(vb, i, size);\n\t}\n\n\tbuf->num_fields = V4L2_FIELD_HAS_BOTH(vbuf->field) ? 2 : 1;\n\tfor (i = 0; i < buf->num_fields; ++i)\n\t\tfdp1_buf_prepare_field(q_data, vbuf, i);\n\n\treturn 0;\n}\n\nstatic void fdp1_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct fdp1_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int fdp1_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct fdp1_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct fdp1_q_data *q_data = get_q_data(ctx, q->type);\n\n\tif (V4L2_TYPE_IS_OUTPUT(q->type)) {\n\t\t \n\t\tif (q_data->format.field == V4L2_FIELD_NONE)\n\t\t\tctx->deint_mode = FDP1_PROGRESSIVE;\n\n\t\tif (ctx->deint_mode == FDP1_ADAPT2D3D) {\n\t\t\tu32 stride;\n\t\t\tdma_addr_t smsk_base;\n\t\t\tconst u32 bpp = 2;  \n\n\t\t\tstride = round_up(q_data->format.width, 8);\n\n\t\t\tctx->smsk_size = bpp * stride * q_data->vsize;\n\n\t\t\tctx->smsk_cpu = dma_alloc_coherent(ctx->fdp1->dev,\n\t\t\t\tctx->smsk_size, &smsk_base, GFP_KERNEL);\n\n\t\t\tif (ctx->smsk_cpu == NULL) {\n\t\t\t\tdprintk(ctx->fdp1, \"Failed to alloc smsk\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tctx->smsk_addr[0] = smsk_base;\n\t\t\tctx->smsk_addr[1] = smsk_base + (ctx->smsk_size/2);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void fdp1_stop_streaming(struct vb2_queue *q)\n{\n\tstruct fdp1_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf;\n\tunsigned long flags;\n\n\twhile (1) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (vbuf == NULL)\n\t\t\tbreak;\n\t\tspin_lock_irqsave(&ctx->fdp1->irqlock, flags);\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t\tspin_unlock_irqrestore(&ctx->fdp1->irqlock, flags);\n\t}\n\n\t \n\tif (V4L2_TYPE_IS_OUTPUT(q->type)) {\n\t\t \n\t\tstruct fdp1_field_buffer *fbuf;\n\n\t\t \n\t\tfbuf = fdp1_dequeue_field(ctx);\n\t\twhile (fbuf != NULL) {\n\t\t\tfdp1_field_complete(ctx, fbuf);\n\t\t\tfbuf = fdp1_dequeue_field(ctx);\n\t\t}\n\n\t\t \n\t\tif (ctx->smsk_cpu) {\n\t\t\tdma_free_coherent(ctx->fdp1->dev, ctx->smsk_size,\n\t\t\t\t\t  ctx->smsk_cpu, ctx->smsk_addr[0]);\n\t\t\tctx->smsk_addr[0] = ctx->smsk_addr[1] = 0;\n\t\t\tctx->smsk_cpu = NULL;\n\t\t}\n\n\t\tWARN(!list_empty(&ctx->fields_queue),\n\t\t     \"Buffer queue not empty\");\n\t} else {\n\t\t \n\t\tstruct fdp1_job *job;\n\n\t\tjob = get_queued_job(ctx->fdp1);\n\t\twhile (job) {\n\t\t\tif (FDP1_DEINT_MODE_USES_PREV(ctx->deint_mode))\n\t\t\t\tfdp1_field_complete(ctx, job->previous);\n\t\t\telse\n\t\t\t\tfdp1_field_complete(ctx, job->active);\n\n\t\t\tv4l2_m2m_buf_done(job->dst->vb, VB2_BUF_STATE_ERROR);\n\t\t\tjob->dst = NULL;\n\n\t\t\tjob = get_queued_job(ctx->fdp1);\n\t\t}\n\n\t\t \n\t\tfdp1_field_complete(ctx, ctx->previous);\n\n\t\tWARN(!list_empty(&ctx->fdp1->queued_job_list),\n\t\t     \"Queued Job List not empty\");\n\n\t\tWARN(!list_empty(&ctx->fdp1->hw_job_list),\n\t\t     \"HW Job list not empty\");\n\t}\n}\n\nstatic const struct vb2_ops fdp1_qops = {\n\t.queue_setup\t = fdp1_queue_setup,\n\t.buf_prepare\t = fdp1_buf_prepare,\n\t.buf_queue\t = fdp1_buf_queue,\n\t.start_streaming = fdp1_start_streaming,\n\t.stop_streaming  = fdp1_stop_streaming,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n};\n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct fdp1_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct fdp1_buffer);\n\tsrc_vq->ops = &fdp1_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->fdp1->dev_mutex;\n\tsrc_vq->dev = ctx->fdp1->dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct fdp1_buffer);\n\tdst_vq->ops = &fdp1_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->fdp1->dev_mutex;\n\tdst_vq->dev = ctx->fdp1->dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\n \nstatic int fdp1_open(struct file *file)\n{\n\tstruct fdp1_dev *fdp1 = video_drvdata(file);\n\tstruct v4l2_pix_format_mplane format;\n\tstruct fdp1_ctx *ctx = NULL;\n\tstruct v4l2_ctrl *ctrl;\n\tint ret = 0;\n\n\tif (mutex_lock_interruptible(&fdp1->dev_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tctx->fdp1 = fdp1;\n\n\t \n\tINIT_LIST_HEAD(&ctx->fields_queue);\n\n\tctx->translen = 1;\n\tctx->sequence = 0;\n\n\t \n\n\tv4l2_ctrl_handler_init(&ctx->hdl, 3);\n\tv4l2_ctrl_new_std_menu_items(&ctx->hdl, &fdp1_ctrl_ops,\n\t\t\t\t     V4L2_CID_DEINTERLACING_MODE,\n\t\t\t\t     FDP1_NEXTFIELD, BIT(0), FDP1_FIXED3D,\n\t\t\t\t     fdp1_ctrl_deint_menu);\n\n\tctrl = v4l2_ctrl_new_std(&ctx->hdl, &fdp1_ctrl_ops,\n\t\t\t\t V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 2, 1, 1);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\tv4l2_ctrl_new_std(&ctx->hdl, &fdp1_ctrl_ops,\n\t\t\t  V4L2_CID_ALPHA_COMPONENT, 0, 255, 1, 255);\n\n\tif (ctx->hdl.error) {\n\t\tret = ctx->hdl.error;\n\t\tgoto error_ctx;\n\t}\n\n\tctx->fh.ctrl_handler = &ctx->hdl;\n\tv4l2_ctrl_handler_setup(&ctx->hdl);\n\n\t \n\tmemset(&format, 0, sizeof(format));\n\tfdp1_set_format(ctx, &format, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(fdp1->m2m_dev, ctx, &queue_init);\n\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto error_ctx;\n\t}\n\n\t \n\tret = pm_runtime_resume_and_get(fdp1->dev);\n\tif (ret < 0)\n\t\tgoto error_pm;\n\n\tv4l2_fh_add(&ctx->fh);\n\n\tdprintk(fdp1, \"Created instance: %p, m2m_ctx: %p\\n\",\n\t\tctx, ctx->fh.m2m_ctx);\n\n\tmutex_unlock(&fdp1->dev_mutex);\n\treturn 0;\n\nerror_pm:\n       v4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\nerror_ctx:\n\tv4l2_ctrl_handler_free(&ctx->hdl);\n\tkfree(ctx);\ndone:\n\tmutex_unlock(&fdp1->dev_mutex);\n\treturn ret;\n}\n\nstatic int fdp1_release(struct file *file)\n{\n\tstruct fdp1_dev *fdp1 = video_drvdata(file);\n\tstruct fdp1_ctx *ctx = fh_to_ctx(file->private_data);\n\n\tdprintk(fdp1, \"Releasing instance %p\\n\", ctx);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_ctrl_handler_free(&ctx->hdl);\n\tmutex_lock(&fdp1->dev_mutex);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tmutex_unlock(&fdp1->dev_mutex);\n\tkfree(ctx);\n\n\tpm_runtime_put(fdp1->dev);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations fdp1_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= fdp1_open,\n\t.release\t= fdp1_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct video_device fdp1_videodev = {\n\t.name\t\t= DRIVER_NAME,\n\t.vfl_dir\t= VFL_DIR_M2M,\n\t.fops\t\t= &fdp1_fops,\n\t.device_caps\t= V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING,\n\t.ioctl_ops\t= &fdp1_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= video_device_release_empty,\n};\n\nstatic const struct v4l2_m2m_ops m2m_ops = {\n\t.device_run\t= fdp1_m2m_device_run,\n\t.job_ready\t= fdp1_m2m_job_ready,\n\t.job_abort\t= fdp1_m2m_job_abort,\n};\n\nstatic irqreturn_t fdp1_irq_handler(int irq, void *dev_id)\n{\n\tstruct fdp1_dev *fdp1 = dev_id;\n\tu32 int_status;\n\tu32 ctl_status;\n\tu32 vint_cnt;\n\tu32 cycles;\n\n\tint_status = fdp1_read(fdp1, FD1_CTL_IRQSTA);\n\tcycles = fdp1_read(fdp1, FD1_CTL_VCYCLE_STAT);\n\tctl_status = fdp1_read(fdp1, FD1_CTL_STATUS);\n\tvint_cnt = (ctl_status & FD1_CTL_STATUS_VINT_CNT_MASK) >>\n\t\t\tFD1_CTL_STATUS_VINT_CNT_SHIFT;\n\n\t \n\tfdp1_write(fdp1, ~(int_status) & FD1_CTL_IRQ_MASK, FD1_CTL_IRQSTA);\n\n\tif (debug >= 2) {\n\t\tdprintk(fdp1, \"IRQ: 0x%x %s%s%s\\n\", int_status,\n\t\t\tint_status & FD1_CTL_IRQ_VERE ? \"[Error]\" : \"[!E]\",\n\t\t\tint_status & FD1_CTL_IRQ_VINTE ? \"[VSync]\" : \"[!V]\",\n\t\t\tint_status & FD1_CTL_IRQ_FREE ? \"[FrameEnd]\" : \"[!F]\");\n\n\t\tdprintk(fdp1, \"CycleStatus = %d (%dms)\\n\",\n\t\t\tcycles, cycles/(fdp1->clk_rate/1000));\n\n\t\tdprintk(fdp1,\n\t\t\t\"Control Status = 0x%08x : VINT_CNT = %d %s:%s:%s:%s\\n\",\n\t\t\tctl_status, vint_cnt,\n\t\t\tctl_status & FD1_CTL_STATUS_SGREGSET ? \"RegSet\" : \"\",\n\t\t\tctl_status & FD1_CTL_STATUS_SGVERR ? \"Vsync Error\" : \"\",\n\t\t\tctl_status & FD1_CTL_STATUS_SGFREND ? \"FrameEnd\" : \"\",\n\t\t\tctl_status & FD1_CTL_STATUS_BSY ? \"Busy\" : \"\");\n\t\tdprintk(fdp1, \"***********************************\\n\");\n\t}\n\n\t \n\tif (!(FD1_CTL_IRQ_MASK & int_status))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (FD1_CTL_IRQ_VERE & int_status)\n\t\tdevice_frame_end(fdp1, VB2_BUF_STATE_ERROR);\n\telse if (FD1_CTL_IRQ_FREE & int_status)\n\t\tdevice_frame_end(fdp1, VB2_BUF_STATE_DONE);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fdp1_probe(struct platform_device *pdev)\n{\n\tstruct fdp1_dev *fdp1;\n\tstruct video_device *vfd;\n\tstruct device_node *fcp_node;\n\tstruct clk *clk;\n\tunsigned int i;\n\n\tint ret;\n\tint hw_version;\n\n\tfdp1 = devm_kzalloc(&pdev->dev, sizeof(*fdp1), GFP_KERNEL);\n\tif (!fdp1)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&fdp1->free_job_list);\n\tINIT_LIST_HEAD(&fdp1->queued_job_list);\n\tINIT_LIST_HEAD(&fdp1->hw_job_list);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fdp1->jobs); i++)\n\t\tlist_add(&fdp1->jobs[i].list, &fdp1->free_job_list);\n\n\tmutex_init(&fdp1->dev_mutex);\n\n\tspin_lock_init(&fdp1->irqlock);\n\tspin_lock_init(&fdp1->device_process_lock);\n\tfdp1->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, fdp1);\n\n\t \n\tfdp1->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(fdp1->regs))\n\t\treturn PTR_ERR(fdp1->regs);\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tfdp1->irq = ret;\n\n\tret = devm_request_irq(&pdev->dev, fdp1->irq, fdp1_irq_handler, 0,\n\t\t\t       dev_name(&pdev->dev), fdp1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot claim IRQ %d\\n\", fdp1->irq);\n\t\treturn ret;\n\t}\n\n\t \n\tfcp_node = of_parse_phandle(pdev->dev.of_node, \"renesas,fcp\", 0);\n\tif (fcp_node) {\n\t\tfdp1->fcp = rcar_fcp_get(fcp_node);\n\t\tof_node_put(fcp_node);\n\t\tif (IS_ERR(fdp1->fcp)) {\n\t\t\tdev_dbg(&pdev->dev, \"FCP not found (%ld)\\n\",\n\t\t\t\tPTR_ERR(fdp1->fcp));\n\t\t\treturn PTR_ERR(fdp1->fcp);\n\t\t}\n\t}\n\n\t \n\tclk = clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto put_dev;\n\t}\n\n\tfdp1->clk_rate = clk_get_rate(clk);\n\tclk_put(clk);\n\n\t \n\tret = v4l2_device_register(&pdev->dev, &fdp1->v4l2_dev);\n\tif (ret) {\n\t\tv4l2_err(&fdp1->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto put_dev;\n\t}\n\n\t \n\tfdp1->m2m_dev = v4l2_m2m_init(&m2m_ops);\n\tif (IS_ERR(fdp1->m2m_dev)) {\n\t\tv4l2_err(&fdp1->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(fdp1->m2m_dev);\n\t\tgoto unreg_dev;\n\t}\n\n\t \n\tfdp1->vfd = fdp1_videodev;\n\tvfd = &fdp1->vfd;\n\tvfd->lock = &fdp1->dev_mutex;\n\tvfd->v4l2_dev = &fdp1->v4l2_dev;\n\tvideo_set_drvdata(vfd, fdp1);\n\tstrscpy(vfd->name, fdp1_videodev.name, sizeof(vfd->name));\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&fdp1->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto release_m2m;\n\t}\n\n\tv4l2_info(&fdp1->v4l2_dev, \"Device registered as /dev/video%d\\n\",\n\t\t  vfd->num);\n\n\t \n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(fdp1->dev);\n\tif (ret < 0)\n\t\tgoto disable_pm;\n\n\thw_version = fdp1_read(fdp1, FD1_IP_INTDATA);\n\tswitch (hw_version) {\n\tcase FD1_IP_GEN2:\n\t\tdprintk(fdp1, \"FDP1 Version R-Car Gen2\\n\");\n\t\tbreak;\n\tcase FD1_IP_M3W:\n\t\tdprintk(fdp1, \"FDP1 Version R-Car M3-W\\n\");\n\t\tbreak;\n\tcase FD1_IP_H3:\n\t\tdprintk(fdp1, \"FDP1 Version R-Car H3\\n\");\n\t\tbreak;\n\tcase FD1_IP_M3N:\n\t\tdprintk(fdp1, \"FDP1 Version R-Car M3-N\\n\");\n\t\tbreak;\n\tcase FD1_IP_E3:\n\t\tdprintk(fdp1, \"FDP1 Version R-Car E3\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(fdp1->dev, \"FDP1 Unidentifiable (0x%08x)\\n\",\n\t\t\thw_version);\n\t}\n\n\t \n\tpm_runtime_put(fdp1->dev);\n\n\treturn 0;\n\ndisable_pm:\n\tpm_runtime_disable(fdp1->dev);\n\nrelease_m2m:\n\tv4l2_m2m_release(fdp1->m2m_dev);\n\nunreg_dev:\n\tv4l2_device_unregister(&fdp1->v4l2_dev);\n\nput_dev:\n\trcar_fcp_put(fdp1->fcp);\n\treturn ret;\n}\n\nstatic void fdp1_remove(struct platform_device *pdev)\n{\n\tstruct fdp1_dev *fdp1 = platform_get_drvdata(pdev);\n\n\tv4l2_m2m_release(fdp1->m2m_dev);\n\tvideo_unregister_device(&fdp1->vfd);\n\tv4l2_device_unregister(&fdp1->v4l2_dev);\n\tpm_runtime_disable(&pdev->dev);\n\trcar_fcp_put(fdp1->fcp);\n}\n\nstatic int __maybe_unused fdp1_pm_runtime_suspend(struct device *dev)\n{\n\tstruct fdp1_dev *fdp1 = dev_get_drvdata(dev);\n\n\trcar_fcp_disable(fdp1->fcp);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused fdp1_pm_runtime_resume(struct device *dev)\n{\n\tstruct fdp1_dev *fdp1 = dev_get_drvdata(dev);\n\n\t \n\tfdp1_set_lut(fdp1);\n\n\treturn rcar_fcp_enable(fdp1->fcp);\n}\n\nstatic const struct dev_pm_ops fdp1_pm_ops = {\n\tSET_RUNTIME_PM_OPS(fdp1_pm_runtime_suspend,\n\t\t\t   fdp1_pm_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id fdp1_dt_ids[] = {\n\t{ .compatible = \"renesas,fdp1\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, fdp1_dt_ids);\n\nstatic struct platform_driver fdp1_pdrv = {\n\t.probe\t\t= fdp1_probe,\n\t.remove_new\t= fdp1_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = fdp1_dt_ids,\n\t\t.pm\t= &fdp1_pm_ops,\n\t},\n};\n\nmodule_platform_driver(fdp1_pdrv);\n\nMODULE_DESCRIPTION(\"Renesas R-Car Fine Display Processor Driver\");\nMODULE_AUTHOR(\"Kieran Bingham <kieran@bingham.xyz>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}