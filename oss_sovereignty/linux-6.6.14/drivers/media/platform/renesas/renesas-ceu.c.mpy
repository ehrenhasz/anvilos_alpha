{
  "module_name": "renesas-ceu.c",
  "hash_id": "c1a897ab7356d5c98127bf369b00400a857d2bf94e8c8d898ae28f6b0ab69be9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/renesas-ceu.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mediabus.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include <media/drv-intf/renesas-ceu.h>\n\n#define DRIVER_NAME\t\"renesas-ceu\"\n\n \n#define CEU_CAPSR\t0x00  \n#define CEU_CAPCR\t0x04  \n#define CEU_CAMCR\t0x08  \n#define CEU_CAMOR\t0x10  \n#define CEU_CAPWR\t0x14  \n#define CEU_CAIFR\t0x18  \n#define CEU_CRCNTR\t0x28  \n#define CEU_CRCMPR\t0x2c  \n#define CEU_CFLCR\t0x30  \n#define CEU_CFSZR\t0x34  \n#define CEU_CDWDR\t0x38  \n#define CEU_CDAYR\t0x3c  \n#define CEU_CDACR\t0x40  \n#define CEU_CFWCR\t0x5c  \n#define CEU_CDOCR\t0x64  \n#define CEU_CEIER\t0x70  \n#define CEU_CETCR\t0x74  \n#define CEU_CSTSR\t0x7c  \n#define CEU_CSRTR\t0x80  \n\n \n#define CEU_CAMCR_JPEG\t\t\tBIT(4)\n\n \n#define CEU_CAMCR_DTARY_8_UYVY\t\t(0x00 << 8)\n#define CEU_CAMCR_DTARY_8_VYUY\t\t(0x01 << 8)\n#define CEU_CAMCR_DTARY_8_YUYV\t\t(0x02 << 8)\n#define CEU_CAMCR_DTARY_8_YVYU\t\t(0x03 << 8)\n \n\n \n#define CEU_CAPCR_BUS_WIDTH256\t\t(0x3 << 20)\n\n \n#define CEU_CAMCR_DTIF_16BITS\t\tBIT(12)\n\n \n#define CEU_CDOCR_NO_DOWSAMPLE\t\tBIT(4)\n\n \n#define CEU_CDOCR_SWAP_ENDIANNESS\t(7)\n\n \n#define CEU_CAPSR_CPKIL\t\t\tBIT(16)\n#define CEU_CAPSR_CE\t\t\tBIT(0)\n\n \n#define CEU_CAPCR_CTNCP\t\t\tBIT(16)\n#define CEU_CSTRST_CPTON\t\tBIT(0)\n\n \n#define CEU_CETCR_ALL_IRQS_RZ\t\t0x397f313\n#define CEU_CETCR_ALL_IRQS_SH4\t\t0x3d7f313\n\n \n#define CEU_CETCR_IGRW\t\t\tBIT(4)\n \n#define CEU_CEIER_CPE\t\t\tBIT(0)\n \n#define CEU_CEIER_VBP\t\t\tBIT(20)\n#define CEU_CEIER_MASK\t\t\t(CEU_CEIER_CPE | CEU_CEIER_VBP)\n\n#define CEU_MAX_WIDTH\t2560\n#define CEU_MAX_HEIGHT\t1920\n#define CEU_MAX_BPL\t8188\n#define CEU_W_MAX(w)\t((w) < CEU_MAX_WIDTH ? (w) : CEU_MAX_WIDTH)\n#define CEU_H_MAX(h)\t((h) < CEU_MAX_HEIGHT ? (h) : CEU_MAX_HEIGHT)\n\n \nstruct ceu_mbus_fmt {\n\tu32\tmbus_code;\n\tu32\tfmt_order;\n\tu32\tfmt_order_swap;\n\tbool\tswapped;\n\tu8\tbps;\n\tu8\tbpp;\n};\n\n \nstruct ceu_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head queue;\n};\n\nstatic inline struct ceu_buffer *vb2_to_ceu(struct vb2_v4l2_buffer *vbuf)\n{\n\treturn container_of(vbuf, struct ceu_buffer, vb);\n}\n\n \nstruct ceu_subdev {\n\tstruct v4l2_async_connection asd;\n\tstruct v4l2_subdev *v4l2_sd;\n\n\t \n\tunsigned int mbus_flags;\n\tstruct ceu_mbus_fmt mbus_fmt;\n};\n\nstatic struct ceu_subdev *to_ceu_subdev(struct v4l2_async_connection *asd)\n{\n\treturn container_of(asd, struct ceu_subdev, asd);\n}\n\n \nstruct ceu_device {\n\tstruct device\t\t*dev;\n\tstruct video_device\tvdev;\n\tstruct v4l2_device\tv4l2_dev;\n\n\t \n\tstruct ceu_subdev\t**subdevs;\n\t \n\tstruct ceu_subdev\t*sd;\n\tunsigned int\t\tsd_index;\n\tunsigned int\t\tnum_sd;\n\n\t \n\tu32\t\t\tirq_mask;\n\n\t \n\tenum v4l2_field\tfield;\n\tstruct v4l2_pix_format_mplane v4l2_pix;\n\n\t \n\tstruct v4l2_async_notifier notifier;\n\n\t \n\tstruct vb2_queue\tvb2_vq;\n\tstruct list_head\tcapture;\n\tstruct vb2_v4l2_buffer\t*active;\n\tunsigned int\t\tsequence;\n\n\t \n\tstruct mutex\tmlock;\n\n\t \n\tspinlock_t\tlock;\n\n\t \n\tvoid __iomem\t*base;\n};\n\nstatic inline struct ceu_device *v4l2_to_ceu(struct v4l2_device *v4l2_dev)\n{\n\treturn container_of(v4l2_dev, struct ceu_device, v4l2_dev);\n}\n\n \n\n \nstruct ceu_fmt {\n\tu32\tfourcc;\n\tu32\tbpp;\n};\n\n \nstatic const struct ceu_fmt ceu_fmt_list[] = {\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_NV16,\n\t\t.bpp\t= 16,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV61,\n\t\t.bpp\t= 16,\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_NV12,\n\t\t.bpp\t= 12,\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_NV21,\n\t\t.bpp\t= 12,\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_YUYV,\n\t\t.bpp\t= 16,\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_UYVY,\n\t\t.bpp\t= 16,\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_YVYU,\n\t\t.bpp\t= 16,\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_VYUY,\n\t\t.bpp\t= 16,\n\t},\n};\n\nstatic const struct ceu_fmt *get_ceu_fmt_from_fourcc(unsigned int fourcc)\n{\n\tconst struct ceu_fmt *fmt = &ceu_fmt_list[0];\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ceu_fmt_list); i++, fmt++)\n\t\tif (fmt->fourcc == fourcc)\n\t\t\treturn fmt;\n\n\treturn NULL;\n}\n\nstatic bool ceu_fmt_mplane(struct v4l2_pix_format_mplane *pix)\n{\n\tswitch (pix->pixelformat) {\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_YVYU:\n\tcase V4L2_PIX_FMT_VYUY:\n\t\treturn false;\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \n\nstatic void ceu_write(struct ceu_device *priv, unsigned int reg_offs, u32 data)\n{\n\tiowrite32(data, priv->base + reg_offs);\n}\n\nstatic u32 ceu_read(struct ceu_device *priv, unsigned int reg_offs)\n{\n\treturn ioread32(priv->base + reg_offs);\n}\n\n \nstatic int ceu_soft_reset(struct ceu_device *ceudev)\n{\n\tunsigned int i;\n\n\tceu_write(ceudev, CEU_CAPSR, CEU_CAPSR_CPKIL);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (!(ceu_read(ceudev, CEU_CSTSR) & CEU_CSTRST_CPTON))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i == 100) {\n\t\tdev_err(ceudev->dev, \"soft reset time out\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (!(ceu_read(ceudev, CEU_CAPSR) & CEU_CAPSR_CPKIL))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\t \n\treturn -EIO;\n}\n\n \n\n \nstatic int ceu_hw_config(struct ceu_device *ceudev)\n{\n\tu32 camcr, cdocr, cfzsr, cdwdr, capwr;\n\tstruct v4l2_pix_format_mplane *pix = &ceudev->v4l2_pix;\n\tstruct ceu_subdev *ceu_sd = ceudev->sd;\n\tstruct ceu_mbus_fmt *mbus_fmt = &ceu_sd->mbus_fmt;\n\tunsigned int mbus_flags = ceu_sd->mbus_flags;\n\n\t \n\tceu_write(ceudev, CEU_CAIFR, 0);\n\tceu_write(ceudev, CEU_CFWCR, 0);\n\tceu_write(ceudev, CEU_CRCNTR, 0);\n\tceu_write(ceudev, CEU_CRCMPR, 0);\n\n\t \n\tcapwr = (pix->height << 16) | pix->width * mbus_fmt->bpp / 8;\n\n\t \n\tcdocr = CEU_CDOCR_SWAP_ENDIANNESS;\n\n\t \n\tswitch (pix->pixelformat) {\n\t \n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_YVYU:\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_VYUY:\n\t\tcamcr\t= CEU_CAMCR_JPEG;\n\t\tcdocr\t|= CEU_CDOCR_NO_DOWSAMPLE;\n\t\tcfzsr\t= (pix->height << 16) | pix->width;\n\t\tcdwdr\t= pix->plane_fmt[0].bytesperline;\n\t\tbreak;\n\n\t \n\tcase V4L2_PIX_FMT_NV16:\n\t\tcdocr\t|= CEU_CDOCR_NO_DOWSAMPLE;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_NV12:\n\t\tif (mbus_fmt->swapped)\n\t\t\tcamcr = mbus_fmt->fmt_order_swap;\n\t\telse\n\t\t\tcamcr = mbus_fmt->fmt_order;\n\n\t\tcfzsr\t= (pix->height << 16) | pix->width;\n\t\tcdwdr\t= pix->width;\n\t\tbreak;\n\n\t \n\tcase V4L2_PIX_FMT_NV61:\n\t\tcdocr\t|= CEU_CDOCR_NO_DOWSAMPLE;\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_NV21:\n\t\tif (mbus_fmt->swapped)\n\t\t\tcamcr = mbus_fmt->fmt_order;\n\t\telse\n\t\t\tcamcr = mbus_fmt->fmt_order_swap;\n\n\t\tcfzsr\t= (pix->height << 16) | pix->width;\n\t\tcdwdr\t= pix->width;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcamcr |= mbus_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW ? 1 << 1 : 0;\n\tcamcr |= mbus_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW ? 1 << 0 : 0;\n\n\t \n\tceu_write(ceudev, CEU_CAMCR, camcr);\n\tceu_write(ceudev, CEU_CDOCR, cdocr);\n\tceu_write(ceudev, CEU_CAPCR, CEU_CAPCR_BUS_WIDTH256);\n\n\t \n\tceu_write(ceudev, CEU_CAMOR, 0);\n\n\t \n\tceu_write(ceudev, CEU_CAPWR, capwr);\n\tceu_write(ceudev, CEU_CFSZR, cfzsr);\n\tceu_write(ceudev, CEU_CDWDR, cdwdr);\n\n\treturn 0;\n}\n\n \nstatic int ceu_capture(struct ceu_device *ceudev)\n{\n\tstruct v4l2_pix_format_mplane *pix = &ceudev->v4l2_pix;\n\tdma_addr_t phys_addr_top;\n\n\tphys_addr_top =\n\t\tvb2_dma_contig_plane_dma_addr(&ceudev->active->vb2_buf, 0);\n\tceu_write(ceudev, CEU_CDAYR, phys_addr_top);\n\n\t \n\tif (ceu_fmt_mplane(pix)) {\n\t\tphys_addr_top =\n\t\t\tvb2_dma_contig_plane_dma_addr(&ceudev->active->vb2_buf,\n\t\t\t\t\t\t      1);\n\t\tceu_write(ceudev, CEU_CDACR, phys_addr_top);\n\t}\n\n\t \n\tceu_write(ceudev, CEU_CAPSR, CEU_CAPSR_CE);\n\n\treturn 0;\n}\n\nstatic irqreturn_t ceu_irq(int irq, void *data)\n{\n\tstruct ceu_device *ceudev = data;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct ceu_buffer *buf;\n\tu32 status;\n\n\t \n\tstatus = ceu_read(ceudev, CEU_CETCR);\n\tceu_write(ceudev, CEU_CETCR, ~ceudev->irq_mask);\n\n\t \n\tif (!(status & CEU_CEIER_MASK))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&ceudev->lock);\n\n\t \n\tvbuf = ceudev->active;\n\tif (!vbuf) {\n\t\tspin_unlock(&ceudev->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (status & CEU_CEIER_VBP) {\n\t\tdev_err(ceudev->dev, \"VBP interrupt: abort capture\\n\");\n\t\tgoto error_irq_out;\n\t}\n\n\t \n\tvbuf->vb2_buf.timestamp = ktime_get_ns();\n\tvbuf->sequence = ceudev->sequence++;\n\tvbuf->field = ceudev->field;\n\n\t \n\tif (!list_empty(&ceudev->capture)) {\n\t\tbuf = list_first_entry(&ceudev->capture, struct ceu_buffer,\n\t\t\t\t       queue);\n\t\tlist_del(&buf->queue);\n\t\tceudev->active = &buf->vb;\n\n\t\tceu_capture(ceudev);\n\t}\n\n\t \n\tvb2_buffer_done(&vbuf->vb2_buf, VB2_BUF_STATE_DONE);\n\n\tspin_unlock(&ceudev->lock);\n\n\treturn IRQ_HANDLED;\n\nerror_irq_out:\n\t \n\tvb2_buffer_done(&vbuf->vb2_buf, VB2_BUF_STATE_ERROR);\n\n\tlist_for_each_entry(buf, &ceudev->capture, queue)\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\n\tspin_unlock(&ceudev->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void ceu_update_plane_sizes(struct v4l2_plane_pix_format *plane,\n\t\t\t\t   unsigned int bpl, unsigned int szimage)\n{\n\tmemset(plane, 0, sizeof(*plane));\n\n\tplane->sizeimage = szimage;\n\tif (plane->bytesperline < bpl || plane->bytesperline > CEU_MAX_BPL)\n\t\tplane->bytesperline = bpl;\n}\n\n \nstatic void ceu_calc_plane_sizes(struct ceu_device *ceudev,\n\t\t\t\t const struct ceu_fmt *ceu_fmt,\n\t\t\t\t struct v4l2_pix_format_mplane *pix)\n{\n\tunsigned int bpl, szimage;\n\n\tswitch (pix->pixelformat) {\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_YVYU:\n\tcase V4L2_PIX_FMT_VYUY:\n\t\tpix->num_planes\t= 1;\n\t\tbpl\t\t= pix->width * ceu_fmt->bpp / 8;\n\t\tszimage\t\t= pix->height * bpl;\n\t\tceu_update_plane_sizes(&pix->plane_fmt[0], bpl, szimage);\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\tpix->num_planes\t= 2;\n\t\tbpl\t\t= pix->width;\n\t\tszimage\t\t= pix->height * pix->width;\n\t\tceu_update_plane_sizes(&pix->plane_fmt[0], bpl, szimage);\n\t\tceu_update_plane_sizes(&pix->plane_fmt[1], bpl, szimage / 2);\n\t\tbreak;\n\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\tdefault:\n\t\tpix->num_planes\t= 2;\n\t\tbpl\t\t= pix->width;\n\t\tszimage\t\t= pix->height * pix->width;\n\t\tceu_update_plane_sizes(&pix->plane_fmt[0], bpl, szimage);\n\t\tceu_update_plane_sizes(&pix->plane_fmt[1], bpl, szimage);\n\t\tbreak;\n\t}\n}\n\n \nstatic int ceu_vb2_setup(struct vb2_queue *vq, unsigned int *count,\n\t\t\t unsigned int *num_planes, unsigned int sizes[],\n\t\t\t struct device *alloc_devs[])\n{\n\tstruct ceu_device *ceudev = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format_mplane *pix = &ceudev->v4l2_pix;\n\tunsigned int i;\n\n\t \n\tif (*num_planes) {\n\t\tfor (i = 0; i < pix->num_planes; i++)\n\t\t\tif (sizes[i] < pix->plane_fmt[i].sizeimage)\n\t\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\t \n\t*num_planes = pix->num_planes;\n\tfor (i = 0; i < pix->num_planes; i++)\n\t\tsizes[i] = pix->plane_fmt[i].sizeimage;\n\n\treturn 0;\n}\n\nstatic void ceu_vb2_queue(struct vb2_buffer *vb)\n{\n\tstruct ceu_device *ceudev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct ceu_buffer *buf = vb2_to_ceu(vbuf);\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&ceudev->lock, irqflags);\n\tlist_add_tail(&buf->queue, &ceudev->capture);\n\tspin_unlock_irqrestore(&ceudev->lock, irqflags);\n}\n\nstatic int ceu_vb2_prepare(struct vb2_buffer *vb)\n{\n\tstruct ceu_device *ceudev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct v4l2_pix_format_mplane *pix = &ceudev->v4l2_pix;\n\tunsigned int i;\n\n\tfor (i = 0; i < pix->num_planes; i++) {\n\t\tif (vb2_plane_size(vb, i) < pix->plane_fmt[i].sizeimage) {\n\t\t\tdev_err(ceudev->dev,\n\t\t\t\t\"Plane size too small (%lu < %u)\\n\",\n\t\t\t\tvb2_plane_size(vb, i),\n\t\t\t\tpix->plane_fmt[i].sizeimage);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvb2_set_plane_payload(vb, i, pix->plane_fmt[i].sizeimage);\n\t}\n\n\treturn 0;\n}\n\nstatic int ceu_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct ceu_device *ceudev = vb2_get_drv_priv(vq);\n\tstruct v4l2_subdev *v4l2_sd = ceudev->sd->v4l2_sd;\n\tstruct ceu_buffer *buf;\n\tunsigned long irqflags;\n\tint ret;\n\n\t \n\tret = ceu_hw_config(ceudev);\n\tif (ret)\n\t\tgoto error_return_bufs;\n\n\tret = v4l2_subdev_call(v4l2_sd, video, s_stream, 1);\n\tif (ret && ret != -ENOIOCTLCMD) {\n\t\tdev_dbg(ceudev->dev,\n\t\t\t\"Subdevice failed to start streaming: %d\\n\", ret);\n\t\tgoto error_return_bufs;\n\t}\n\n\tspin_lock_irqsave(&ceudev->lock, irqflags);\n\tceudev->sequence = 0;\n\n\t \n\tbuf = list_first_entry(&ceudev->capture, struct ceu_buffer,\n\t\t\t       queue);\n\n\tlist_del(&buf->queue);\n\tceudev->active = &buf->vb;\n\n\t \n\tceu_write(ceudev, CEU_CETCR, ~ceudev->irq_mask);\n\tceu_write(ceudev, CEU_CEIER, CEU_CEIER_MASK);\n\n\tceu_capture(ceudev);\n\n\tspin_unlock_irqrestore(&ceudev->lock, irqflags);\n\n\treturn 0;\n\nerror_return_bufs:\n\tspin_lock_irqsave(&ceudev->lock, irqflags);\n\tlist_for_each_entry(buf, &ceudev->capture, queue)\n\t\tvb2_buffer_done(&ceudev->active->vb2_buf,\n\t\t\t\tVB2_BUF_STATE_QUEUED);\n\tceudev->active = NULL;\n\tspin_unlock_irqrestore(&ceudev->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic void ceu_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct ceu_device *ceudev = vb2_get_drv_priv(vq);\n\tstruct v4l2_subdev *v4l2_sd = ceudev->sd->v4l2_sd;\n\tstruct ceu_buffer *buf;\n\tunsigned long irqflags;\n\n\t \n\tceu_write(ceudev, CEU_CETCR,\n\t\t  ceu_read(ceudev, CEU_CETCR) & ceudev->irq_mask);\n\tceu_write(ceudev, CEU_CEIER, CEU_CEIER_MASK);\n\n\tv4l2_subdev_call(v4l2_sd, video, s_stream, 0);\n\n\tspin_lock_irqsave(&ceudev->lock, irqflags);\n\tif (ceudev->active) {\n\t\tvb2_buffer_done(&ceudev->active->vb2_buf,\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\tceudev->active = NULL;\n\t}\n\n\t \n\tlist_for_each_entry(buf, &ceudev->capture, queue)\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\tINIT_LIST_HEAD(&ceudev->capture);\n\n\tspin_unlock_irqrestore(&ceudev->lock, irqflags);\n\n\tceu_soft_reset(ceudev);\n}\n\nstatic const struct vb2_ops ceu_vb2_ops = {\n\t.queue_setup\t\t= ceu_vb2_setup,\n\t.buf_queue\t\t= ceu_vb2_queue,\n\t.buf_prepare\t\t= ceu_vb2_prepare,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.start_streaming\t= ceu_start_streaming,\n\t.stop_streaming\t\t= ceu_stop_streaming,\n};\n\n \n\n \nstatic int __ceu_try_fmt(struct ceu_device *ceudev, struct v4l2_format *v4l2_fmt,\n\t\t\t u32 *sd_mbus_code)\n{\n\tstruct ceu_subdev *ceu_sd = ceudev->sd;\n\tstruct v4l2_pix_format_mplane *pix = &v4l2_fmt->fmt.pix_mp;\n\tstruct v4l2_subdev *v4l2_sd = ceu_sd->v4l2_sd;\n\tstruct v4l2_subdev_pad_config pad_cfg;\n\tstruct v4l2_subdev_state pad_state = {\n\t\t.pads = &pad_cfg,\n\t};\n\tconst struct ceu_fmt *ceu_fmt;\n\tu32 mbus_code_old;\n\tu32 mbus_code;\n\tint ret;\n\n\t \n\tstruct v4l2_subdev_format sd_format = {\n\t\t.which\t= V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\n\tmbus_code_old = ceu_sd->mbus_fmt.mbus_code;\n\n\tswitch (pix->pixelformat) {\n\tcase V4L2_PIX_FMT_YUYV:\n\t\tmbus_code = MEDIA_BUS_FMT_YUYV8_2X8;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_UYVY:\n\t\tmbus_code = MEDIA_BUS_FMT_UYVY8_2X8;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YVYU:\n\t\tmbus_code = MEDIA_BUS_FMT_YVYU8_2X8;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VYUY:\n\t\tmbus_code = MEDIA_BUS_FMT_VYUY8_2X8;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\tmbus_code = ceu_sd->mbus_fmt.mbus_code;\n\t\tbreak;\n\n\tdefault:\n\t\tpix->pixelformat = V4L2_PIX_FMT_NV16;\n\t\tmbus_code = ceu_sd->mbus_fmt.mbus_code;\n\t\tbreak;\n\t}\n\n\tceu_fmt = get_ceu_fmt_from_fourcc(pix->pixelformat);\n\n\t \n\tv4l_bound_align_image(&pix->width, 2, CEU_MAX_WIDTH, 4,\n\t\t\t      &pix->height, 4, CEU_MAX_HEIGHT, 4, 0);\n\n\tv4l2_fill_mbus_format_mplane(&sd_format.format, pix);\n\n\t \n\tsd_format.format.code = mbus_code;\n\tret = v4l2_subdev_call(v4l2_sd, pad, set_fmt, &pad_state, &sd_format);\n\tif (ret) {\n\t\tif (ret == -EINVAL) {\n\t\t\t \n\t\t\tsd_format.format.code = mbus_code_old;\n\t\t\tret = v4l2_subdev_call(v4l2_sd, pad, set_fmt,\n\t\t\t\t\t       &pad_state, &sd_format);\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tv4l2_fill_pix_format_mplane(pix, &sd_format.format);\n\n\t \n\tceu_calc_plane_sizes(ceudev, ceu_fmt, pix);\n\n\t \n\t*sd_mbus_code = sd_format.format.code;\n\n\treturn 0;\n}\n\n \nstatic int ceu_try_fmt(struct ceu_device *ceudev, struct v4l2_format *v4l2_fmt)\n{\n\tu32 mbus_code;\n\n\treturn __ceu_try_fmt(ceudev, v4l2_fmt, &mbus_code);\n}\n\n \nstatic int ceu_set_fmt(struct ceu_device *ceudev, struct v4l2_format *v4l2_fmt)\n{\n\tstruct ceu_subdev *ceu_sd = ceudev->sd;\n\tstruct v4l2_subdev *v4l2_sd = ceu_sd->v4l2_sd;\n\tu32 mbus_code;\n\tint ret;\n\n\t \n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\tret = __ceu_try_fmt(ceudev, v4l2_fmt, &mbus_code);\n\tif (ret)\n\t\treturn ret;\n\n\tformat.format.code = mbus_code;\n\tv4l2_fill_mbus_format_mplane(&format.format, &v4l2_fmt->fmt.pix_mp);\n\tret = v4l2_subdev_call(v4l2_sd, pad, set_fmt, NULL, &format);\n\tif (ret)\n\t\treturn ret;\n\n\tceudev->v4l2_pix = v4l2_fmt->fmt.pix_mp;\n\tceudev->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\n \nstatic int ceu_set_default_fmt(struct ceu_device *ceudev)\n{\n\tint ret;\n\n\tstruct v4l2_format v4l2_fmt = {\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t\t.fmt.pix_mp = {\n\t\t\t.width\t\t= VGA_WIDTH,\n\t\t\t.height\t\t= VGA_HEIGHT,\n\t\t\t.field\t\t= V4L2_FIELD_NONE,\n\t\t\t.pixelformat\t= V4L2_PIX_FMT_NV16,\n\t\t\t.num_planes\t= 2,\n\t\t\t.plane_fmt\t= {\n\t\t\t\t[0]\t= {\n\t\t\t\t\t.sizeimage = VGA_WIDTH * VGA_HEIGHT * 2,\n\t\t\t\t\t.bytesperline = VGA_WIDTH * 2,\n\t\t\t\t},\n\t\t\t\t[1]\t= {\n\t\t\t\t\t.sizeimage = VGA_WIDTH * VGA_HEIGHT * 2,\n\t\t\t\t\t.bytesperline = VGA_WIDTH * 2,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t};\n\n\tret = ceu_try_fmt(ceudev, &v4l2_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tceudev->v4l2_pix = v4l2_fmt.fmt.pix_mp;\n\tceudev->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\n \nstatic int ceu_init_mbus_fmt(struct ceu_device *ceudev)\n{\n\tstruct ceu_subdev *ceu_sd = ceudev->sd;\n\tstruct ceu_mbus_fmt *mbus_fmt = &ceu_sd->mbus_fmt;\n\tstruct v4l2_subdev *v4l2_sd = ceu_sd->v4l2_sd;\n\tbool yuyv_bus_fmt = false;\n\n\tstruct v4l2_subdev_mbus_code_enum sd_mbus_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.index = 0,\n\t};\n\n\t \n\twhile (!yuyv_bus_fmt &&\n\t       !v4l2_subdev_call(v4l2_sd, pad, enum_mbus_code,\n\t\t\t\t NULL, &sd_mbus_fmt)) {\n\t\tswitch (sd_mbus_fmt.code) {\n\t\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\t\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\t\t\tyuyv_bus_fmt = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tsd_mbus_fmt.index++;\n\t}\n\n\tif (!yuyv_bus_fmt)\n\t\treturn -ENXIO;\n\n\t \n\tmbus_fmt->mbus_code\t= sd_mbus_fmt.code;\n\tmbus_fmt->bps\t\t= 8;\n\n\t \n\tswitch (sd_mbus_fmt.code) {\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\tmbus_fmt->fmt_order\t\t= CEU_CAMCR_DTARY_8_YUYV;\n\t\tmbus_fmt->fmt_order_swap\t= CEU_CAMCR_DTARY_8_YVYU;\n\t\tmbus_fmt->swapped\t\t= false;\n\t\tmbus_fmt->bpp\t\t\t= 16;\n\t\tbreak;\n\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\t\tmbus_fmt->fmt_order\t\t= CEU_CAMCR_DTARY_8_YVYU;\n\t\tmbus_fmt->fmt_order_swap\t= CEU_CAMCR_DTARY_8_YUYV;\n\t\tmbus_fmt->swapped\t\t= true;\n\t\tmbus_fmt->bpp\t\t\t= 16;\n\t\tbreak;\n\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tmbus_fmt->fmt_order\t\t= CEU_CAMCR_DTARY_8_UYVY;\n\t\tmbus_fmt->fmt_order_swap\t= CEU_CAMCR_DTARY_8_VYUY;\n\t\tmbus_fmt->swapped\t\t= false;\n\t\tmbus_fmt->bpp\t\t\t= 16;\n\t\tbreak;\n\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\t\tmbus_fmt->fmt_order\t\t= CEU_CAMCR_DTARY_8_VYUY;\n\t\tmbus_fmt->fmt_order_swap\t= CEU_CAMCR_DTARY_8_UYVY;\n\t\tmbus_fmt->swapped\t\t= true;\n\t\tmbus_fmt->bpp\t\t\t= 16;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic int __maybe_unused ceu_runtime_resume(struct device *dev)\n{\n\tstruct ceu_device *ceudev = dev_get_drvdata(dev);\n\tstruct v4l2_subdev *v4l2_sd = ceudev->sd->v4l2_sd;\n\n\tv4l2_subdev_call(v4l2_sd, core, s_power, 1);\n\n\tceu_soft_reset(ceudev);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused ceu_runtime_suspend(struct device *dev)\n{\n\tstruct ceu_device *ceudev = dev_get_drvdata(dev);\n\tstruct v4l2_subdev *v4l2_sd = ceudev->sd->v4l2_sd;\n\n\tv4l2_subdev_call(v4l2_sd, core, s_power, 0);\n\n\tceu_write(ceudev, CEU_CEIER, 0);\n\tceu_soft_reset(ceudev);\n\n\treturn 0;\n}\n\n \n\nstatic int ceu_open(struct file *file)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\tint ret;\n\n\tret = v4l2_fh_open(file);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&ceudev->mlock);\n\t \n\tret = pm_runtime_resume_and_get(ceudev->dev);\n\tmutex_unlock(&ceudev->mlock);\n\n\treturn ret;\n}\n\nstatic int ceu_release(struct file *file)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\n\tvb2_fop_release(file);\n\n\tmutex_lock(&ceudev->mlock);\n\t \n\tpm_runtime_put(ceudev->dev);\n\tmutex_unlock(&ceudev->mlock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations ceu_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= ceu_open,\n\t.release\t\t= ceu_release,\n\t.unlocked_ioctl\t\t= video_ioctl2,\n\t.mmap\t\t\t= vb2_fop_mmap,\n\t.poll\t\t\t= vb2_fop_poll,\n};\n\n \n\nstatic int ceu_querycap(struct file *file, void *priv,\n\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\n\tstrscpy(cap->card, \"Renesas CEU\", sizeof(cap->card));\n\tstrscpy(cap->driver, DRIVER_NAME, sizeof(cap->driver));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:renesas-ceu-%s\", dev_name(ceudev->dev));\n\n\treturn 0;\n}\n\nstatic int ceu_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tconst struct ceu_fmt *fmt;\n\n\tif (f->index >= ARRAY_SIZE(ceu_fmt_list))\n\t\treturn -EINVAL;\n\n\tfmt = &ceu_fmt_list[f->index];\n\tf->pixelformat = fmt->fourcc;\n\n\treturn 0;\n}\n\nstatic int ceu_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\n\treturn ceu_try_fmt(ceudev, f);\n}\n\nstatic int ceu_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\n\tif (vb2_is_streaming(&ceudev->vb2_vq))\n\t\treturn -EBUSY;\n\n\treturn ceu_set_fmt(ceudev, f);\n}\n\nstatic int ceu_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\n\tf->fmt.pix_mp = ceudev->v4l2_pix;\n\n\treturn 0;\n}\n\nstatic int ceu_enum_input(struct file *file, void *priv,\n\t\t\t  struct v4l2_input *inp)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\tstruct ceu_subdev *ceusd;\n\n\tif (inp->index >= ceudev->num_sd)\n\t\treturn -EINVAL;\n\n\tceusd = ceudev->subdevs[inp->index];\n\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tinp->std = 0;\n\tsnprintf(inp->name, sizeof(inp->name), \"Camera%u: %s\",\n\t\t inp->index, ceusd->v4l2_sd->name);\n\n\treturn 0;\n}\n\nstatic int ceu_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\n\t*i = ceudev->sd_index;\n\n\treturn 0;\n}\n\nstatic int ceu_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\tstruct ceu_subdev *ceu_sd_old;\n\tint ret;\n\n\tif (i >= ceudev->num_sd)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_streaming(&ceudev->vb2_vq))\n\t\treturn -EBUSY;\n\n\tif (i == ceudev->sd_index)\n\t\treturn 0;\n\n\tceu_sd_old = ceudev->sd;\n\tceudev->sd = ceudev->subdevs[i];\n\n\t \n\tret = ceu_init_mbus_fmt(ceudev);\n\tif (ret) {\n\t\tceudev->sd = ceu_sd_old;\n\t\treturn -EINVAL;\n\t}\n\n\tret = ceu_set_default_fmt(ceudev);\n\tif (ret) {\n\t\tceudev->sd = ceu_sd_old;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tv4l2_subdev_call(ceu_sd_old->v4l2_sd, core, s_power, 0);\n\tv4l2_subdev_call(ceudev->sd->v4l2_sd, core, s_power, 1);\n\n\tceudev->sd_index = i;\n\n\treturn 0;\n}\n\nstatic int ceu_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\n\treturn v4l2_g_parm_cap(video_devdata(file), ceudev->sd->v4l2_sd, a);\n}\n\nstatic int ceu_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\n\treturn v4l2_s_parm_cap(video_devdata(file), ceudev->sd->v4l2_sd, a);\n}\n\nstatic int ceu_enum_framesizes(struct file *file, void *fh,\n\t\t\t       struct v4l2_frmsizeenum *fsize)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\tstruct ceu_subdev *ceu_sd = ceudev->sd;\n\tconst struct ceu_fmt *ceu_fmt;\n\tstruct v4l2_subdev *v4l2_sd = ceu_sd->v4l2_sd;\n\tint ret;\n\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.code\t= ceu_sd->mbus_fmt.mbus_code,\n\t\t.index\t= fsize->index,\n\t\t.which\t= V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\t \n\tceu_fmt = get_ceu_fmt_from_fourcc(fsize->pixel_format);\n\tif (!ceu_fmt)\n\t\treturn -EINVAL;\n\n\tret = v4l2_subdev_call(v4l2_sd, pad, enum_frame_size,\n\t\t\t       NULL, &fse);\n\tif (ret)\n\t\treturn ret;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = CEU_W_MAX(fse.max_width);\n\tfsize->discrete.height = CEU_H_MAX(fse.max_height);\n\n\treturn 0;\n}\n\nstatic int ceu_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_frmivalenum *fival)\n{\n\tstruct ceu_device *ceudev = video_drvdata(file);\n\tstruct ceu_subdev *ceu_sd = ceudev->sd;\n\tconst struct ceu_fmt *ceu_fmt;\n\tstruct v4l2_subdev *v4l2_sd = ceu_sd->v4l2_sd;\n\tint ret;\n\n\tstruct v4l2_subdev_frame_interval_enum fie = {\n\t\t.code\t= ceu_sd->mbus_fmt.mbus_code,\n\t\t.index = fival->index,\n\t\t.width = fival->width,\n\t\t.height = fival->height,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\t \n\tceu_fmt = get_ceu_fmt_from_fourcc(fival->pixel_format);\n\tif (!ceu_fmt)\n\t\treturn -EINVAL;\n\n\tret = v4l2_subdev_call(v4l2_sd, pad, enum_frame_interval, NULL,\n\t\t\t       &fie);\n\tif (ret)\n\t\treturn ret;\n\n\tfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tfival->discrete = fie.interval;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops ceu_ioctl_ops = {\n\t.vidioc_querycap\t\t= ceu_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= ceu_enum_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap_mplane\t= ceu_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap_mplane\t= ceu_s_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap_mplane\t= ceu_g_fmt_vid_cap,\n\n\t.vidioc_enum_input\t\t= ceu_enum_input,\n\t.vidioc_g_input\t\t\t= ceu_g_input,\n\t.vidioc_s_input\t\t\t= ceu_s_input,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\n\t.vidioc_g_parm\t\t\t= ceu_g_parm,\n\t.vidioc_s_parm\t\t\t= ceu_s_parm,\n\t.vidioc_enum_framesizes\t\t= ceu_enum_framesizes,\n\t.vidioc_enum_frameintervals\t= ceu_enum_frameintervals,\n\n\t.vidioc_log_status              = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event         = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event       = v4l2_event_unsubscribe,\n};\n\n \nstatic void ceu_vdev_release(struct video_device *vdev)\n{\n\tstruct ceu_device *ceudev = video_get_drvdata(vdev);\n\n\tkfree(ceudev);\n}\n\nstatic int ceu_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t    struct v4l2_subdev *v4l2_sd,\n\t\t\t    struct v4l2_async_connection *asd)\n{\n\tstruct v4l2_device *v4l2_dev = notifier->v4l2_dev;\n\tstruct ceu_device *ceudev = v4l2_to_ceu(v4l2_dev);\n\tstruct ceu_subdev *ceu_sd = to_ceu_subdev(asd);\n\n\tceu_sd->v4l2_sd = v4l2_sd;\n\tceudev->num_sd++;\n\n\treturn 0;\n}\n\nstatic int ceu_notify_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct v4l2_device *v4l2_dev = notifier->v4l2_dev;\n\tstruct ceu_device *ceudev = v4l2_to_ceu(v4l2_dev);\n\tstruct video_device *vdev = &ceudev->vdev;\n\tstruct vb2_queue *q = &ceudev->vb2_vq;\n\tstruct v4l2_subdev *v4l2_sd;\n\tint ret;\n\n\t \n\tq->type\t\t\t= V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tq->io_modes\t\t= VB2_MMAP | VB2_DMABUF;\n\tq->drv_priv\t\t= ceudev;\n\tq->ops\t\t\t= &ceu_vb2_ops;\n\tq->mem_ops\t\t= &vb2_dma_contig_memops;\n\tq->buf_struct_size\t= sizeof(struct ceu_buffer);\n\tq->timestamp_flags\t= V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed\t= 2;\n\tq->lock\t\t\t= &ceudev->mlock;\n\tq->dev\t\t\t= ceudev->v4l2_dev.dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!ceudev->sd) {\n\t\tceudev->sd = ceudev->subdevs[0];\n\t\tceudev->sd_index = 0;\n\t}\n\n\tv4l2_sd = ceudev->sd->v4l2_sd;\n\n\tret = ceu_init_mbus_fmt(ceudev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ceu_set_default_fmt(ceudev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstrscpy(vdev->name, DRIVER_NAME, sizeof(vdev->name));\n\tvdev->v4l2_dev\t\t= v4l2_dev;\n\tvdev->lock\t\t= &ceudev->mlock;\n\tvdev->queue\t\t= &ceudev->vb2_vq;\n\tvdev->ctrl_handler\t= v4l2_sd->ctrl_handler;\n\tvdev->fops\t\t= &ceu_fops;\n\tvdev->ioctl_ops\t\t= &ceu_ioctl_ops;\n\tvdev->release\t\t= ceu_vdev_release;\n\tvdev->device_caps\t= V4L2_CAP_VIDEO_CAPTURE_MPLANE |\n\t\t\t\t  V4L2_CAP_STREAMING;\n\tvideo_set_drvdata(vdev, ceudev);\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0) {\n\t\tv4l2_err(vdev->v4l2_dev,\n\t\t\t \"video_register_device failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_async_notifier_operations ceu_notify_ops = {\n\t.bound\t\t= ceu_notify_bound,\n\t.complete\t= ceu_notify_complete,\n};\n\n \nstatic int ceu_init_async_subdevs(struct ceu_device *ceudev, unsigned int n_sd)\n{\n\t \n\tceudev->subdevs = devm_kcalloc(ceudev->dev, n_sd,\n\t\t\t\t       sizeof(*ceudev->subdevs), GFP_KERNEL);\n\tif (!ceudev->subdevs)\n\t\treturn -ENOMEM;\n\n\tceudev->sd = NULL;\n\tceudev->sd_index = 0;\n\tceudev->num_sd = 0;\n\n\treturn 0;\n}\n\n \nstatic int ceu_parse_platform_data(struct ceu_device *ceudev,\n\t\t\t\t   const struct ceu_platform_data *pdata)\n{\n\tconst struct ceu_async_subdev *async_sd;\n\tstruct ceu_subdev *ceu_sd;\n\tunsigned int i;\n\tint ret;\n\n\tif (pdata->num_subdevs == 0)\n\t\treturn -ENODEV;\n\n\tret = ceu_init_async_subdevs(ceudev, pdata->num_subdevs);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < pdata->num_subdevs; i++) {\n\n\t\t \n\t\tasync_sd = &pdata->subdevs[i];\n\t\tceu_sd = v4l2_async_nf_add_i2c(&ceudev->notifier,\n\t\t\t\t\t       async_sd->i2c_adapter_id,\n\t\t\t\t\t       async_sd->i2c_address,\n\t\t\t\t\t       struct ceu_subdev);\n\t\tif (IS_ERR(ceu_sd)) {\n\t\t\tv4l2_async_nf_cleanup(&ceudev->notifier);\n\t\t\treturn PTR_ERR(ceu_sd);\n\t\t}\n\t\tceu_sd->mbus_flags = async_sd->flags;\n\t\tceudev->subdevs[i] = ceu_sd;\n\t}\n\n\treturn pdata->num_subdevs;\n}\n\n \nstatic int ceu_parse_dt(struct ceu_device *ceudev)\n{\n\tstruct device_node *of = ceudev->dev->of_node;\n\tstruct device_node *ep;\n\tstruct ceu_subdev *ceu_sd;\n\tunsigned int i;\n\tint num_ep;\n\tint ret;\n\n\tnum_ep = of_graph_get_endpoint_count(of);\n\tif (!num_ep)\n\t\treturn -ENODEV;\n\n\tret = ceu_init_async_subdevs(ceudev, num_ep);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < num_ep; i++) {\n\t\tstruct v4l2_fwnode_endpoint fw_ep = {\n\t\t\t.bus_type = V4L2_MBUS_PARALLEL,\n\t\t\t.bus = {\n\t\t\t\t.parallel = {\n\t\t\t\t\t.flags = V4L2_MBUS_HSYNC_ACTIVE_HIGH |\n\t\t\t\t\t\t V4L2_MBUS_VSYNC_ACTIVE_HIGH,\n\t\t\t\t\t.bus_width = 8,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tep = of_graph_get_endpoint_by_regs(of, 0, i);\n\t\tif (!ep) {\n\t\t\tdev_err(ceudev->dev,\n\t\t\t\t\"No subdevice connected on endpoint %u.\\n\", i);\n\t\t\tret = -ENODEV;\n\t\t\tgoto error_cleanup;\n\t\t}\n\n\t\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep), &fw_ep);\n\t\tif (ret) {\n\t\t\tdev_err(ceudev->dev,\n\t\t\t\t\"Unable to parse endpoint #%u: %d.\\n\", i, ret);\n\t\t\tgoto error_cleanup;\n\t\t}\n\n\t\t \n\t\tceu_sd = v4l2_async_nf_add_fwnode_remote(&ceudev->notifier,\n\t\t\t\t\t\t\t of_fwnode_handle(ep),\n\t\t\t\t\t\t\t struct ceu_subdev);\n\t\tif (IS_ERR(ceu_sd)) {\n\t\t\tret = PTR_ERR(ceu_sd);\n\t\t\tgoto error_cleanup;\n\t\t}\n\t\tceu_sd->mbus_flags = fw_ep.bus.parallel.flags;\n\t\tceudev->subdevs[i] = ceu_sd;\n\n\t\tof_node_put(ep);\n\t}\n\n\treturn num_ep;\n\nerror_cleanup:\n\tv4l2_async_nf_cleanup(&ceudev->notifier);\n\tof_node_put(ep);\n\treturn ret;\n}\n\n \nstruct ceu_data {\n\tu32 irq_mask;\n};\n\nstatic const struct ceu_data ceu_data_sh4 = {\n\t.irq_mask = CEU_CETCR_ALL_IRQS_SH4,\n};\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct ceu_data ceu_data_rz = {\n\t.irq_mask = CEU_CETCR_ALL_IRQS_RZ,\n};\n\nstatic const struct of_device_id ceu_of_match[] = {\n\t{ .compatible = \"renesas,r7s72100-ceu\", .data = &ceu_data_rz },\n\t{ .compatible = \"renesas,r8a7740-ceu\", .data = &ceu_data_rz },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ceu_of_match);\n#endif\n\nstatic int ceu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct ceu_data *ceu_data;\n\tstruct ceu_device *ceudev;\n\tunsigned int irq;\n\tint num_subdevs;\n\tint ret;\n\n\tceudev = kzalloc(sizeof(*ceudev), GFP_KERNEL);\n\tif (!ceudev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ceudev);\n\tceudev->dev = dev;\n\n\tINIT_LIST_HEAD(&ceudev->capture);\n\tspin_lock_init(&ceudev->lock);\n\tmutex_init(&ceudev->mlock);\n\n\tceudev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ceudev->base)) {\n\t\tret = PTR_ERR(ceudev->base);\n\t\tgoto error_free_ceudev;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto error_free_ceudev;\n\tirq = ret;\n\n\tret = devm_request_irq(dev, irq, ceu_irq,\n\t\t\t       0, dev_name(dev), ceudev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to request CEU interrupt.\\n\");\n\t\tgoto error_free_ceudev;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\tret = v4l2_device_register(dev, &ceudev->v4l2_dev);\n\tif (ret)\n\t\tgoto error_pm_disable;\n\n\tv4l2_async_nf_init(&ceudev->notifier, &ceudev->v4l2_dev);\n\n\tif (IS_ENABLED(CONFIG_OF) && dev->of_node) {\n\t\tceu_data = of_device_get_match_data(dev);\n\t\tnum_subdevs = ceu_parse_dt(ceudev);\n\t} else if (dev->platform_data) {\n\t\t \n\t\tceu_data = &ceu_data_sh4;\n\t\tnum_subdevs = ceu_parse_platform_data(ceudev,\n\t\t\t\t\t\t      dev->platform_data);\n\t} else {\n\t\tnum_subdevs = -EINVAL;\n\t}\n\n\tif (num_subdevs < 0) {\n\t\tret = num_subdevs;\n\t\tgoto error_v4l2_unregister;\n\t}\n\tceudev->irq_mask = ceu_data->irq_mask;\n\n\tceudev->notifier.v4l2_dev\t= &ceudev->v4l2_dev;\n\tceudev->notifier.ops\t\t= &ceu_notify_ops;\n\tret = v4l2_async_nf_register(&ceudev->notifier);\n\tif (ret)\n\t\tgoto error_cleanup;\n\n\tdev_info(dev, \"Renesas Capture Engine Unit %s\\n\", dev_name(dev));\n\n\treturn 0;\n\nerror_cleanup:\n\tv4l2_async_nf_cleanup(&ceudev->notifier);\nerror_v4l2_unregister:\n\tv4l2_device_unregister(&ceudev->v4l2_dev);\nerror_pm_disable:\n\tpm_runtime_disable(dev);\nerror_free_ceudev:\n\tkfree(ceudev);\n\n\treturn ret;\n}\n\nstatic void ceu_remove(struct platform_device *pdev)\n{\n\tstruct ceu_device *ceudev = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(ceudev->dev);\n\n\tv4l2_async_nf_unregister(&ceudev->notifier);\n\n\tv4l2_async_nf_cleanup(&ceudev->notifier);\n\n\tv4l2_device_unregister(&ceudev->v4l2_dev);\n\n\tvideo_unregister_device(&ceudev->vdev);\n}\n\nstatic const struct dev_pm_ops ceu_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ceu_runtime_suspend,\n\t\t\t   ceu_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver ceu_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= &ceu_pm_ops,\n\t\t.of_match_table = of_match_ptr(ceu_of_match),\n\t},\n\t.probe\t\t= ceu_probe,\n\t.remove_new\t= ceu_remove,\n};\n\nmodule_platform_driver(ceu_driver);\n\nMODULE_DESCRIPTION(\"Renesas CEU camera driver\");\nMODULE_AUTHOR(\"Jacopo Mondi <jacopo+renesas@jmondi.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}