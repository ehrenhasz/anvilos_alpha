{
  "module_name": "vsp1_sru.c",
  "hash_id": "17df51fb813ff75be1c31cc9699f58c07ba9eed145342e1a9f2b5eab3b80dbd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_sru.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gfp.h>\n\n#include <media/v4l2-subdev.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_dl.h\"\n#include \"vsp1_pipe.h\"\n#include \"vsp1_sru.h\"\n\n#define SRU_MIN_SIZE\t\t\t\t4U\n#define SRU_MAX_SIZE\t\t\t\t8190U\n\n \n\nstatic inline void vsp1_sru_write(struct vsp1_sru *sru,\n\t\t\t\t  struct vsp1_dl_body *dlb, u32 reg, u32 data)\n{\n\tvsp1_dl_body_write(dlb, reg, data);\n}\n\n \n\n#define V4L2_CID_VSP1_SRU_INTENSITY\t\t(V4L2_CID_USER_BASE | 0x1001)\n\nstruct vsp1_sru_param {\n\tu32 ctrl0;\n\tu32 ctrl2;\n};\n\n#define VI6_SRU_CTRL0_PARAMS(p0, p1)\t\t\t\\\n\t(((p0) << VI6_SRU_CTRL0_PARAM0_SHIFT) |\t\t\\\n\t ((p1) << VI6_SRU_CTRL0_PARAM1_SHIFT))\n\n#define VI6_SRU_CTRL2_PARAMS(p6, p7, p8)\t\t\\\n\t(((p6) << VI6_SRU_CTRL2_PARAM6_SHIFT) |\t\t\\\n\t ((p7) << VI6_SRU_CTRL2_PARAM7_SHIFT) |\t\t\\\n\t ((p8) << VI6_SRU_CTRL2_PARAM8_SHIFT))\n\nstatic const struct vsp1_sru_param vsp1_sru_params[] = {\n\t{\n\t\t.ctrl0 = VI6_SRU_CTRL0_PARAMS(256, 4) | VI6_SRU_CTRL0_EN,\n\t\t.ctrl2 = VI6_SRU_CTRL2_PARAMS(24, 40, 255),\n\t}, {\n\t\t.ctrl0 = VI6_SRU_CTRL0_PARAMS(256, 4) | VI6_SRU_CTRL0_EN,\n\t\t.ctrl2 = VI6_SRU_CTRL2_PARAMS(8, 16, 255),\n\t}, {\n\t\t.ctrl0 = VI6_SRU_CTRL0_PARAMS(384, 5) | VI6_SRU_CTRL0_EN,\n\t\t.ctrl2 = VI6_SRU_CTRL2_PARAMS(36, 60, 255),\n\t}, {\n\t\t.ctrl0 = VI6_SRU_CTRL0_PARAMS(384, 5) | VI6_SRU_CTRL0_EN,\n\t\t.ctrl2 = VI6_SRU_CTRL2_PARAMS(12, 27, 255),\n\t}, {\n\t\t.ctrl0 = VI6_SRU_CTRL0_PARAMS(511, 6) | VI6_SRU_CTRL0_EN,\n\t\t.ctrl2 = VI6_SRU_CTRL2_PARAMS(48, 80, 255),\n\t}, {\n\t\t.ctrl0 = VI6_SRU_CTRL0_PARAMS(511, 6) | VI6_SRU_CTRL0_EN,\n\t\t.ctrl2 = VI6_SRU_CTRL2_PARAMS(16, 36, 255),\n\t},\n};\n\nstatic int sru_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vsp1_sru *sru =\n\t\tcontainer_of(ctrl->handler, struct vsp1_sru, ctrls);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VSP1_SRU_INTENSITY:\n\t\tsru->intensity = ctrl->val;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops sru_ctrl_ops = {\n\t.s_ctrl = sru_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config sru_intensity_control = {\n\t.ops = &sru_ctrl_ops,\n\t.id = V4L2_CID_VSP1_SRU_INTENSITY,\n\t.name = \"Intensity\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.min = 1,\n\t.max = 6,\n\t.def = 1,\n\t.step = 1,\n};\n\n \n\nstatic int sru_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstatic const unsigned int codes[] = {\n\t\tMEDIA_BUS_FMT_ARGB8888_1X32,\n\t\tMEDIA_BUS_FMT_AYUV8_1X32,\n\t};\n\n\treturn vsp1_subdev_enum_mbus_code(subdev, sd_state, code, codes,\n\t\t\t\t\t  ARRAY_SIZE(codes));\n}\n\nstatic int sru_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct vsp1_sru *sru = to_sru(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tint ret = 0;\n\n\tconfig = vsp1_entity_get_pad_config(&sru->entity, sd_state,\n\t\t\t\t\t    fse->which);\n\tif (!config)\n\t\treturn -EINVAL;\n\n\tformat = vsp1_entity_get_pad_format(&sru->entity, config, SRU_PAD_SINK);\n\n\tmutex_lock(&sru->entity.lock);\n\n\tif (fse->index || fse->code != format->code) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (fse->pad == SRU_PAD_SINK) {\n\t\tfse->min_width = SRU_MIN_SIZE;\n\t\tfse->max_width = SRU_MAX_SIZE;\n\t\tfse->min_height = SRU_MIN_SIZE;\n\t\tfse->max_height = SRU_MAX_SIZE;\n\t} else {\n\t\tfse->min_width = format->width;\n\t\tfse->min_height = format->height;\n\t\tif (format->width <= SRU_MAX_SIZE / 2 &&\n\t\t    format->height <= SRU_MAX_SIZE / 2) {\n\t\t\tfse->max_width = format->width * 2;\n\t\t\tfse->max_height = format->height * 2;\n\t\t} else {\n\t\t\tfse->max_width = format->width;\n\t\t\tfse->max_height = format->height;\n\t\t}\n\t}\n\ndone:\n\tmutex_unlock(&sru->entity.lock);\n\treturn ret;\n}\n\nstatic void sru_try_format(struct vsp1_sru *sru,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   unsigned int pad, struct v4l2_mbus_framefmt *fmt)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\tunsigned int input_area;\n\tunsigned int output_area;\n\n\tswitch (pad) {\n\tcase SRU_PAD_SINK:\n\t\t \n\t\tif (fmt->code != MEDIA_BUS_FMT_ARGB8888_1X32 &&\n\t\t    fmt->code != MEDIA_BUS_FMT_AYUV8_1X32)\n\t\t\tfmt->code = MEDIA_BUS_FMT_AYUV8_1X32;\n\n\t\tfmt->width = clamp(fmt->width, SRU_MIN_SIZE, SRU_MAX_SIZE);\n\t\tfmt->height = clamp(fmt->height, SRU_MIN_SIZE, SRU_MAX_SIZE);\n\t\tbreak;\n\n\tcase SRU_PAD_SOURCE:\n\t\t \n\t\tformat = vsp1_entity_get_pad_format(&sru->entity, sd_state,\n\t\t\t\t\t\t    SRU_PAD_SINK);\n\t\tfmt->code = format->code;\n\n\t\t \n\t\tinput_area = format->width * format->height;\n\t\toutput_area = min(fmt->width, SRU_MAX_SIZE)\n\t\t\t    * min(fmt->height, SRU_MAX_SIZE);\n\n\t\tif (fmt->width <= SRU_MAX_SIZE / 2 &&\n\t\t    fmt->height <= SRU_MAX_SIZE / 2 &&\n\t\t    output_area > input_area * 9 / 4) {\n\t\t\tfmt->width = format->width * 2;\n\t\t\tfmt->height = format->height * 2;\n\t\t} else {\n\t\t\tfmt->width = format->width;\n\t\t\tfmt->height = format->height;\n\t\t}\n\t\tbreak;\n\t}\n\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n}\n\nstatic int sru_set_format(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct vsp1_sru *sru = to_sru(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tint ret = 0;\n\n\tmutex_lock(&sru->entity.lock);\n\n\tconfig = vsp1_entity_get_pad_config(&sru->entity, sd_state,\n\t\t\t\t\t    fmt->which);\n\tif (!config) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tsru_try_format(sru, config, fmt->pad, &fmt->format);\n\n\tformat = vsp1_entity_get_pad_format(&sru->entity, config, fmt->pad);\n\t*format = fmt->format;\n\n\tif (fmt->pad == SRU_PAD_SINK) {\n\t\t \n\t\tformat = vsp1_entity_get_pad_format(&sru->entity, config,\n\t\t\t\t\t\t    SRU_PAD_SOURCE);\n\t\t*format = fmt->format;\n\n\t\tsru_try_format(sru, config, SRU_PAD_SOURCE, format);\n\t}\n\ndone:\n\tmutex_unlock(&sru->entity.lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_pad_ops sru_pad_ops = {\n\t.init_cfg = vsp1_entity_init_cfg,\n\t.enum_mbus_code = sru_enum_mbus_code,\n\t.enum_frame_size = sru_enum_frame_size,\n\t.get_fmt = vsp1_subdev_get_pad_format,\n\t.set_fmt = sru_set_format,\n};\n\nstatic const struct v4l2_subdev_ops sru_ops = {\n\t.pad    = &sru_pad_ops,\n};\n\n \n\nstatic void sru_configure_stream(struct vsp1_entity *entity,\n\t\t\t\t struct vsp1_pipeline *pipe,\n\t\t\t\t struct vsp1_dl_list *dl,\n\t\t\t\t struct vsp1_dl_body *dlb)\n{\n\tconst struct vsp1_sru_param *param;\n\tstruct vsp1_sru *sru = to_sru(&entity->subdev);\n\tstruct v4l2_mbus_framefmt *input;\n\tstruct v4l2_mbus_framefmt *output;\n\tu32 ctrl0;\n\n\tinput = vsp1_entity_get_pad_format(&sru->entity, sru->entity.config,\n\t\t\t\t\t   SRU_PAD_SINK);\n\toutput = vsp1_entity_get_pad_format(&sru->entity, sru->entity.config,\n\t\t\t\t\t    SRU_PAD_SOURCE);\n\n\tif (input->code == MEDIA_BUS_FMT_ARGB8888_1X32)\n\t\tctrl0 = VI6_SRU_CTRL0_PARAM2 | VI6_SRU_CTRL0_PARAM3\n\t\t      | VI6_SRU_CTRL0_PARAM4;\n\telse\n\t\tctrl0 = VI6_SRU_CTRL0_PARAM3;\n\n\tif (input->width != output->width)\n\t\tctrl0 |= VI6_SRU_CTRL0_MODE_UPSCALE;\n\n\tparam = &vsp1_sru_params[sru->intensity - 1];\n\n\tctrl0 |= param->ctrl0;\n\n\tvsp1_sru_write(sru, dlb, VI6_SRU_CTRL0, ctrl0);\n\tvsp1_sru_write(sru, dlb, VI6_SRU_CTRL1, VI6_SRU_CTRL1_PARAM5);\n\tvsp1_sru_write(sru, dlb, VI6_SRU_CTRL2, param->ctrl2);\n}\n\nstatic unsigned int sru_max_width(struct vsp1_entity *entity,\n\t\t\t\t  struct vsp1_pipeline *pipe)\n{\n\tstruct vsp1_sru *sru = to_sru(&entity->subdev);\n\tstruct v4l2_mbus_framefmt *input;\n\tstruct v4l2_mbus_framefmt *output;\n\n\tinput = vsp1_entity_get_pad_format(&sru->entity, sru->entity.config,\n\t\t\t\t\t   SRU_PAD_SINK);\n\toutput = vsp1_entity_get_pad_format(&sru->entity, sru->entity.config,\n\t\t\t\t\t    SRU_PAD_SOURCE);\n\n\t \n\tif (input->width != output->width)\n\t\treturn 512;\n\telse\n\t\treturn 256;\n}\n\nstatic void sru_partition(struct vsp1_entity *entity,\n\t\t\t  struct vsp1_pipeline *pipe,\n\t\t\t  struct vsp1_partition *partition,\n\t\t\t  unsigned int partition_idx,\n\t\t\t  struct vsp1_partition_window *window)\n{\n\tstruct vsp1_sru *sru = to_sru(&entity->subdev);\n\tstruct v4l2_mbus_framefmt *input;\n\tstruct v4l2_mbus_framefmt *output;\n\n\tinput = vsp1_entity_get_pad_format(&sru->entity, sru->entity.config,\n\t\t\t\t\t   SRU_PAD_SINK);\n\toutput = vsp1_entity_get_pad_format(&sru->entity, sru->entity.config,\n\t\t\t\t\t    SRU_PAD_SOURCE);\n\n\t \n\tif (input->width != output->width) {\n\t\twindow->width /= 2;\n\t\twindow->left /= 2;\n\t}\n\n\tpartition->sru = *window;\n}\n\nstatic const struct vsp1_entity_operations sru_entity_ops = {\n\t.configure_stream = sru_configure_stream,\n\t.max_width = sru_max_width,\n\t.partition = sru_partition,\n};\n\n \n\nstruct vsp1_sru *vsp1_sru_create(struct vsp1_device *vsp1)\n{\n\tstruct vsp1_sru *sru;\n\tint ret;\n\n\tsru = devm_kzalloc(vsp1->dev, sizeof(*sru), GFP_KERNEL);\n\tif (sru == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsru->entity.ops = &sru_entity_ops;\n\tsru->entity.type = VSP1_ENTITY_SRU;\n\n\tret = vsp1_entity_init(vsp1, &sru->entity, \"sru\", 2, &sru_ops,\n\t\t\t       MEDIA_ENT_F_PROC_VIDEO_SCALER);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tv4l2_ctrl_handler_init(&sru->ctrls, 1);\n\tv4l2_ctrl_new_custom(&sru->ctrls, &sru_intensity_control, NULL);\n\n\tsru->intensity = 1;\n\n\tsru->entity.subdev.ctrl_handler = &sru->ctrls;\n\n\tif (sru->ctrls.error) {\n\t\tdev_err(vsp1->dev, \"sru: failed to initialize controls\\n\");\n\t\tret = sru->ctrls.error;\n\t\tvsp1_entity_destroy(&sru->entity);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn sru;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}