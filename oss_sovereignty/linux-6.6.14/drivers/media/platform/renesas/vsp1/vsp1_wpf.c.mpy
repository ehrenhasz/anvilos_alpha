{
  "module_name": "vsp1_wpf.c",
  "hash_id": "a1ef62a18177e641b352713259f9a6c593544aedc67b8e6fef16948d3eaf2db5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_wpf.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n\n#include <media/v4l2-subdev.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_dl.h\"\n#include \"vsp1_pipe.h\"\n#include \"vsp1_rwpf.h\"\n#include \"vsp1_video.h\"\n\n#define WPF_GEN2_MAX_WIDTH\t\t\t2048U\n#define WPF_GEN2_MAX_HEIGHT\t\t\t2048U\n#define WPF_GEN3_MAX_WIDTH\t\t\t8190U\n#define WPF_GEN3_MAX_HEIGHT\t\t\t8190U\n\n \n\nstatic inline void vsp1_wpf_write(struct vsp1_rwpf *wpf,\n\t\t\t\t  struct vsp1_dl_body *dlb, u32 reg, u32 data)\n{\n\tvsp1_dl_body_write(dlb, reg + wpf->entity.index * VI6_WPF_OFFSET, data);\n}\n\n \n\nenum wpf_flip_ctrl {\n\tWPF_CTRL_VFLIP = 0,\n\tWPF_CTRL_HFLIP = 1,\n};\n\nstatic int vsp1_wpf_set_rotation(struct vsp1_rwpf *wpf, unsigned int rotation)\n{\n\tstruct vsp1_video *video = wpf->video;\n\tstruct v4l2_mbus_framefmt *sink_format;\n\tstruct v4l2_mbus_framefmt *source_format;\n\tbool rotate;\n\tint ret = 0;\n\n\t \n\trotate = rotation == 90 || rotation == 270;\n\tif (rotate == wpf->flip.rotate)\n\t\treturn 0;\n\n\t \n\tmutex_lock(&video->lock);\n\n\tif (vb2_is_busy(&video->queue)) {\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\tsink_format = vsp1_entity_get_pad_format(&wpf->entity,\n\t\t\t\t\t\t wpf->entity.config,\n\t\t\t\t\t\t RWPF_PAD_SINK);\n\tsource_format = vsp1_entity_get_pad_format(&wpf->entity,\n\t\t\t\t\t\t   wpf->entity.config,\n\t\t\t\t\t\t   RWPF_PAD_SOURCE);\n\n\tmutex_lock(&wpf->entity.lock);\n\n\tif (rotate) {\n\t\tsource_format->width = sink_format->height;\n\t\tsource_format->height = sink_format->width;\n\t} else {\n\t\tsource_format->width = sink_format->width;\n\t\tsource_format->height = sink_format->height;\n\t}\n\n\twpf->flip.rotate = rotate;\n\n\tmutex_unlock(&wpf->entity.lock);\n\ndone:\n\tmutex_unlock(&video->lock);\n\treturn ret;\n}\n\nstatic int vsp1_wpf_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vsp1_rwpf *wpf =\n\t\tcontainer_of(ctrl->handler, struct vsp1_rwpf, ctrls);\n\tunsigned int rotation;\n\tu32 flip = 0;\n\tint ret;\n\n\t \n\trotation = wpf->flip.ctrls.rotate ? wpf->flip.ctrls.rotate->val : 0;\n\tret = vsp1_wpf_set_rotation(wpf, rotation);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (wpf->flip.ctrls.vflip->val)\n\t\tflip |= BIT(WPF_CTRL_VFLIP);\n\n\tif (wpf->flip.ctrls.hflip && wpf->flip.ctrls.hflip->val)\n\t\tflip |= BIT(WPF_CTRL_HFLIP);\n\n\tif (rotation == 180 || rotation == 270)\n\t\tflip ^= BIT(WPF_CTRL_VFLIP) | BIT(WPF_CTRL_HFLIP);\n\n\tspin_lock_irq(&wpf->flip.lock);\n\twpf->flip.pending = flip;\n\tspin_unlock_irq(&wpf->flip.lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vsp1_wpf_ctrl_ops = {\n\t.s_ctrl = vsp1_wpf_s_ctrl,\n};\n\nstatic int wpf_init_controls(struct vsp1_rwpf *wpf)\n{\n\tstruct vsp1_device *vsp1 = wpf->entity.vsp1;\n\tunsigned int num_flip_ctrls;\n\n\tspin_lock_init(&wpf->flip.lock);\n\n\tif (wpf->entity.index != 0) {\n\t\t \n\t\tnum_flip_ctrls = 0;\n\t} else if (vsp1_feature(vsp1, VSP1_HAS_WPF_HFLIP)) {\n\t\t \n\t\tnum_flip_ctrls = 3;\n\t} else if (vsp1_feature(vsp1, VSP1_HAS_WPF_VFLIP)) {\n\t\t \n\t\tnum_flip_ctrls = 1;\n\t} else {\n\t\t \n\t\tnum_flip_ctrls = 0;\n\t}\n\n\tvsp1_rwpf_init_ctrls(wpf, num_flip_ctrls);\n\n\tif (num_flip_ctrls >= 1) {\n\t\twpf->flip.ctrls.vflip =\n\t\t\tv4l2_ctrl_new_std(&wpf->ctrls, &vsp1_wpf_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\t}\n\n\tif (num_flip_ctrls == 3) {\n\t\twpf->flip.ctrls.hflip =\n\t\t\tv4l2_ctrl_new_std(&wpf->ctrls, &vsp1_wpf_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\t\twpf->flip.ctrls.rotate =\n\t\t\tv4l2_ctrl_new_std(&wpf->ctrls, &vsp1_wpf_ctrl_ops,\n\t\t\t\t\t  V4L2_CID_ROTATE, 0, 270, 90, 0);\n\t\tv4l2_ctrl_cluster(3, &wpf->flip.ctrls.vflip);\n\t}\n\n\tif (wpf->ctrls.error) {\n\t\tdev_err(vsp1->dev, \"wpf%u: failed to initialize controls\\n\",\n\t\t\twpf->entity.index);\n\t\treturn wpf->ctrls.error;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int wpf_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tstruct vsp1_rwpf *wpf = to_rwpf(subdev);\n\tstruct vsp1_device *vsp1 = wpf->entity.vsp1;\n\n\tif (enable)\n\t\treturn 0;\n\n\t \n\tvsp1_write(vsp1, VI6_WPF_IRQ_ENB(wpf->entity.index), 0);\n\tvsp1_write(vsp1, wpf->entity.index * VI6_WPF_OFFSET +\n\t\t   VI6_WPF_SRCRPF, 0);\n\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_subdev_video_ops wpf_video_ops = {\n\t.s_stream = wpf_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops wpf_ops = {\n\t.video\t= &wpf_video_ops,\n\t.pad    = &vsp1_rwpf_pad_ops,\n};\n\n \n\nstatic void vsp1_wpf_destroy(struct vsp1_entity *entity)\n{\n\tstruct vsp1_rwpf *wpf = entity_to_rwpf(entity);\n\n\tvsp1_dlm_destroy(wpf->dlm);\n}\n\nstatic int wpf_configure_writeback_chain(struct vsp1_rwpf *wpf,\n\t\t\t\t\t struct vsp1_dl_list *dl)\n{\n\tunsigned int index = wpf->entity.index;\n\tstruct vsp1_dl_list *dl_next;\n\tstruct vsp1_dl_body *dlb;\n\n\tdl_next = vsp1_dl_list_get(wpf->dlm);\n\tif (!dl_next) {\n\t\tdev_err(wpf->entity.vsp1->dev,\n\t\t\t\"Failed to obtain a dl list, disabling writeback\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdlb = vsp1_dl_list_get_body0(dl_next);\n\tvsp1_dl_body_write(dlb, VI6_WPF_WRBCK_CTRL(index), 0);\n\tvsp1_dl_list_add_chain(dl, dl_next);\n\n\treturn 0;\n}\n\nstatic void wpf_configure_stream(struct vsp1_entity *entity,\n\t\t\t\t struct vsp1_pipeline *pipe,\n\t\t\t\t struct vsp1_dl_list *dl,\n\t\t\t\t struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_rwpf *wpf = to_rwpf(&entity->subdev);\n\tstruct vsp1_device *vsp1 = wpf->entity.vsp1;\n\tconst struct v4l2_mbus_framefmt *source_format;\n\tconst struct v4l2_mbus_framefmt *sink_format;\n\tunsigned int index = wpf->entity.index;\n\tunsigned int i;\n\tu32 outfmt = 0;\n\tu32 srcrpf = 0;\n\tint ret;\n\n\tsink_format = vsp1_entity_get_pad_format(&wpf->entity,\n\t\t\t\t\t\t wpf->entity.config,\n\t\t\t\t\t\t RWPF_PAD_SINK);\n\tsource_format = vsp1_entity_get_pad_format(&wpf->entity,\n\t\t\t\t\t\t   wpf->entity.config,\n\t\t\t\t\t\t   RWPF_PAD_SOURCE);\n\n\t \n\tif (!pipe->lif || wpf->writeback) {\n\t\tconst struct v4l2_pix_format_mplane *format = &wpf->format;\n\t\tconst struct vsp1_format_info *fmtinfo = wpf->fmtinfo;\n\n\t\toutfmt = fmtinfo->hwfmt << VI6_WPF_OUTFMT_WRFMT_SHIFT;\n\n\t\tif (wpf->flip.rotate)\n\t\t\toutfmt |= VI6_WPF_OUTFMT_ROT;\n\n\t\tif (fmtinfo->alpha)\n\t\t\toutfmt |= VI6_WPF_OUTFMT_PXA;\n\t\tif (fmtinfo->swap_yc)\n\t\t\toutfmt |= VI6_WPF_OUTFMT_SPYCS;\n\t\tif (fmtinfo->swap_uv)\n\t\t\toutfmt |= VI6_WPF_OUTFMT_SPUVS;\n\n\t\t \n\t\tvsp1_wpf_write(wpf, dlb, VI6_WPF_DSTM_STRIDE_Y,\n\t\t\t       format->plane_fmt[0].bytesperline);\n\t\tif (format->num_planes > 1)\n\t\t\tvsp1_wpf_write(wpf, dlb, VI6_WPF_DSTM_STRIDE_C,\n\t\t\t\t       format->plane_fmt[1].bytesperline);\n\n\t\tvsp1_wpf_write(wpf, dlb, VI6_WPF_DSWAP, fmtinfo->swap);\n\n\t\tif (vsp1_feature(vsp1, VSP1_HAS_WPF_HFLIP) && index == 0)\n\t\t\tvsp1_wpf_write(wpf, dlb, VI6_WPF_ROT_CTRL,\n\t\t\t\t       VI6_WPF_ROT_CTRL_LN16 |\n\t\t\t\t       (256 << VI6_WPF_ROT_CTRL_LMEM_WD_SHIFT));\n\t}\n\n\tif (sink_format->code != source_format->code)\n\t\toutfmt |= VI6_WPF_OUTFMT_CSC;\n\n\twpf->outfmt = outfmt;\n\n\tvsp1_dl_body_write(dlb, VI6_DPR_WPF_FPORCH(index),\n\t\t\t   VI6_DPR_WPF_FPORCH_FP_WPFN);\n\n\t \n\tfor (i = 0; i < vsp1->info->rpf_count; ++i) {\n\t\tstruct vsp1_rwpf *input = pipe->inputs[i];\n\n\t\tif (!input)\n\t\t\tcontinue;\n\n\t\tsrcrpf |= (!pipe->brx && pipe->num_inputs == 1)\n\t\t\t? VI6_WPF_SRCRPF_RPF_ACT_MST(input->entity.index)\n\t\t\t: VI6_WPF_SRCRPF_RPF_ACT_SUB(input->entity.index);\n\t}\n\n\tif (pipe->brx)\n\t\tsrcrpf |= pipe->brx->type == VSP1_ENTITY_BRU\n\t\t\t? VI6_WPF_SRCRPF_VIRACT_MST\n\t\t\t: VI6_WPF_SRCRPF_VIRACT2_MST;\n\n\tvsp1_wpf_write(wpf, dlb, VI6_WPF_SRCRPF, srcrpf);\n\n\t \n\tvsp1_dl_body_write(dlb, VI6_WPF_IRQ_STA(index), 0);\n\tvsp1_dl_body_write(dlb, VI6_WPF_IRQ_ENB(index),\n\t\t\t   VI6_WPF_IRQ_ENB_DFEE);\n\n\t \n\tif (wpf->writeback) {\n\t\tret = wpf_configure_writeback_chain(wpf, dl);\n\t\tif (ret < 0)\n\t\t\twpf->writeback = false;\n\t}\n\n\tvsp1_dl_body_write(dlb, VI6_WPF_WRBCK_CTRL(index),\n\t\t\t   wpf->writeback ? VI6_WPF_WRBCK_CTRL_WBMD : 0);\n}\n\nstatic void wpf_configure_frame(struct vsp1_entity *entity,\n\t\t\t\tstruct vsp1_pipeline *pipe,\n\t\t\t\tstruct vsp1_dl_list *dl,\n\t\t\t\tstruct vsp1_dl_body *dlb)\n{\n\tconst unsigned int mask = BIT(WPF_CTRL_VFLIP)\n\t\t\t\t| BIT(WPF_CTRL_HFLIP);\n\tstruct vsp1_rwpf *wpf = to_rwpf(&entity->subdev);\n\tunsigned long flags;\n\tu32 outfmt;\n\n\tspin_lock_irqsave(&wpf->flip.lock, flags);\n\twpf->flip.active = (wpf->flip.active & ~mask)\n\t\t\t | (wpf->flip.pending & mask);\n\tspin_unlock_irqrestore(&wpf->flip.lock, flags);\n\n\toutfmt = (wpf->alpha << VI6_WPF_OUTFMT_PDV_SHIFT) | wpf->outfmt;\n\n\tif (wpf->flip.active & BIT(WPF_CTRL_VFLIP))\n\t\toutfmt |= VI6_WPF_OUTFMT_FLP;\n\tif (wpf->flip.active & BIT(WPF_CTRL_HFLIP))\n\t\toutfmt |= VI6_WPF_OUTFMT_HFLP;\n\n\tvsp1_wpf_write(wpf, dlb, VI6_WPF_OUTFMT, outfmt);\n}\n\nstatic void wpf_configure_partition(struct vsp1_entity *entity,\n\t\t\t\t    struct vsp1_pipeline *pipe,\n\t\t\t\t    struct vsp1_dl_list *dl,\n\t\t\t\t    struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_rwpf *wpf = to_rwpf(&entity->subdev);\n\tstruct vsp1_device *vsp1 = wpf->entity.vsp1;\n\tstruct vsp1_rwpf_memory mem = wpf->mem;\n\tconst struct v4l2_mbus_framefmt *sink_format;\n\tconst struct v4l2_pix_format_mplane *format = &wpf->format;\n\tconst struct vsp1_format_info *fmtinfo = wpf->fmtinfo;\n\tunsigned int width;\n\tunsigned int height;\n\tunsigned int left;\n\tunsigned int offset;\n\tunsigned int flip;\n\tunsigned int i;\n\n\tsink_format = vsp1_entity_get_pad_format(&wpf->entity,\n\t\t\t\t\t\t wpf->entity.config,\n\t\t\t\t\t\t RWPF_PAD_SINK);\n\twidth = sink_format->width;\n\theight = sink_format->height;\n\tleft = 0;\n\n\t \n\tif (pipe->partitions > 1) {\n\t\twidth = pipe->partition->wpf.width;\n\t\tleft = pipe->partition->wpf.left;\n\t}\n\n\tvsp1_wpf_write(wpf, dlb, VI6_WPF_HSZCLIP, VI6_WPF_SZCLIP_EN |\n\t\t       (0 << VI6_WPF_SZCLIP_OFST_SHIFT) |\n\t\t       (width << VI6_WPF_SZCLIP_SIZE_SHIFT));\n\tvsp1_wpf_write(wpf, dlb, VI6_WPF_VSZCLIP, VI6_WPF_SZCLIP_EN |\n\t\t       (0 << VI6_WPF_SZCLIP_OFST_SHIFT) |\n\t\t       (height << VI6_WPF_SZCLIP_SIZE_SHIFT));\n\n\t \n\tif (pipe->lif && !wpf->writeback)\n\t\treturn;\n\n\t \n\n\t \n\tflip = wpf->flip.active;\n\n\tif (flip & BIT(WPF_CTRL_HFLIP) && !wpf->flip.rotate)\n\t\toffset = format->width - left - width;\n\telse if (flip & BIT(WPF_CTRL_VFLIP) && wpf->flip.rotate)\n\t\toffset = format->height - left - width;\n\telse\n\t\toffset = left;\n\n\tfor (i = 0; i < format->num_planes; ++i) {\n\t\tunsigned int hsub = i > 0 ? fmtinfo->hsub : 1;\n\t\tunsigned int vsub = i > 0 ? fmtinfo->vsub : 1;\n\n\t\tif (wpf->flip.rotate)\n\t\t\tmem.addr[i] += offset / vsub\n\t\t\t\t     * format->plane_fmt[i].bytesperline;\n\t\telse\n\t\t\tmem.addr[i] += offset / hsub\n\t\t\t\t     * fmtinfo->bpp[i] / 8;\n\t}\n\n\tif (flip & BIT(WPF_CTRL_VFLIP)) {\n\t\t \n\t\tif (wpf->flip.rotate)\n\t\t\theight = width;\n\t\telse\n\t\t\theight = format->height;\n\n\t\tmem.addr[0] += (height - 1)\n\t\t\t     * format->plane_fmt[0].bytesperline;\n\n\t\tif (format->num_planes > 1) {\n\t\t\toffset = (height / fmtinfo->vsub - 1)\n\t\t\t       * format->plane_fmt[1].bytesperline;\n\t\t\tmem.addr[1] += offset;\n\t\t\tmem.addr[2] += offset;\n\t\t}\n\t}\n\n\tif (wpf->flip.rotate && !(flip & BIT(WPF_CTRL_HFLIP))) {\n\t\tunsigned int hoffset = max(0, (int)format->width - 16);\n\n\t\t \n\t\tfor (i = 0; i < format->num_planes; ++i) {\n\t\t\tunsigned int hsub = i > 0 ? fmtinfo->hsub : 1;\n\n\t\t\tmem.addr[i] += hoffset / hsub\n\t\t\t\t     * fmtinfo->bpp[i] / 8;\n\t\t}\n\t}\n\n\t \n\tif (vsp1->info->gen >= 3 && format->num_planes == 3 &&\n\t    fmtinfo->swap_uv)\n\t\tswap(mem.addr[1], mem.addr[2]);\n\n\tvsp1_wpf_write(wpf, dlb, VI6_WPF_DSTM_ADDR_Y, mem.addr[0]);\n\tvsp1_wpf_write(wpf, dlb, VI6_WPF_DSTM_ADDR_C0, mem.addr[1]);\n\tvsp1_wpf_write(wpf, dlb, VI6_WPF_DSTM_ADDR_C1, mem.addr[2]);\n\n\t \n\twpf->writeback = false;\n}\n\nstatic unsigned int wpf_max_width(struct vsp1_entity *entity,\n\t\t\t\t  struct vsp1_pipeline *pipe)\n{\n\tstruct vsp1_rwpf *wpf = to_rwpf(&entity->subdev);\n\n\treturn wpf->flip.rotate ? 256 : wpf->max_width;\n}\n\nstatic void wpf_partition(struct vsp1_entity *entity,\n\t\t\t  struct vsp1_pipeline *pipe,\n\t\t\t  struct vsp1_partition *partition,\n\t\t\t  unsigned int partition_idx,\n\t\t\t  struct vsp1_partition_window *window)\n{\n\tpartition->wpf = *window;\n}\n\nstatic const struct vsp1_entity_operations wpf_entity_ops = {\n\t.destroy = vsp1_wpf_destroy,\n\t.configure_stream = wpf_configure_stream,\n\t.configure_frame = wpf_configure_frame,\n\t.configure_partition = wpf_configure_partition,\n\t.max_width = wpf_max_width,\n\t.partition = wpf_partition,\n};\n\n \n\nstruct vsp1_rwpf *vsp1_wpf_create(struct vsp1_device *vsp1, unsigned int index)\n{\n\tstruct vsp1_rwpf *wpf;\n\tchar name[6];\n\tint ret;\n\n\twpf = devm_kzalloc(vsp1->dev, sizeof(*wpf), GFP_KERNEL);\n\tif (wpf == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (vsp1->info->gen == 2) {\n\t\twpf->max_width = WPF_GEN2_MAX_WIDTH;\n\t\twpf->max_height = WPF_GEN2_MAX_HEIGHT;\n\t} else {\n\t\twpf->max_width = WPF_GEN3_MAX_WIDTH;\n\t\twpf->max_height = WPF_GEN3_MAX_HEIGHT;\n\t}\n\n\twpf->entity.ops = &wpf_entity_ops;\n\twpf->entity.type = VSP1_ENTITY_WPF;\n\twpf->entity.index = index;\n\n\tsprintf(name, \"wpf.%u\", index);\n\tret = vsp1_entity_init(vsp1, &wpf->entity, name, 2, &wpf_ops,\n\t\t\t       MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\t \n\twpf->dlm = vsp1_dlm_create(vsp1, index, 64);\n\tif (!wpf->dlm) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tret = wpf_init_controls(wpf);\n\tif (ret < 0) {\n\t\tdev_err(vsp1->dev, \"wpf%u: failed to initialize controls\\n\",\n\t\t\tindex);\n\t\tgoto error;\n\t}\n\n\tv4l2_ctrl_handler_setup(&wpf->ctrls);\n\n\treturn wpf;\n\nerror:\n\tvsp1_entity_destroy(&wpf->entity);\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}