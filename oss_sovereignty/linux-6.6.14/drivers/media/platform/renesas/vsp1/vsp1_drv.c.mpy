{
  "module_name": "vsp1_drv.c",
  "hash_id": "a57ffe19ded1fa86b3371556495ae679b6829bb3dac37502f2ab47c9e5161cc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_drv.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/videodev2.h>\n\n#include <media/rcar-fcp.h>\n#include <media/v4l2-subdev.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_brx.h\"\n#include \"vsp1_clu.h\"\n#include \"vsp1_dl.h\"\n#include \"vsp1_drm.h\"\n#include \"vsp1_hgo.h\"\n#include \"vsp1_hgt.h\"\n#include \"vsp1_hsit.h\"\n#include \"vsp1_lif.h\"\n#include \"vsp1_lut.h\"\n#include \"vsp1_pipe.h\"\n#include \"vsp1_rwpf.h\"\n#include \"vsp1_sru.h\"\n#include \"vsp1_uds.h\"\n#include \"vsp1_uif.h\"\n#include \"vsp1_video.h\"\n\n \n\nstatic irqreturn_t vsp1_irq_handler(int irq, void *data)\n{\n\tu32 mask = VI6_WPF_IRQ_STA_DFE | VI6_WPF_IRQ_STA_FRE |\n\t\t   VI6_WPF_IRQ_STA_UND;\n\tstruct vsp1_device *vsp1 = data;\n\tirqreturn_t ret = IRQ_NONE;\n\tunsigned int i;\n\tu32 status;\n\n\tfor (i = 0; i < vsp1->info->wpf_count; ++i) {\n\t\tstruct vsp1_rwpf *wpf = vsp1->wpf[i];\n\n\t\tif (wpf == NULL)\n\t\t\tcontinue;\n\n\t\tstatus = vsp1_read(vsp1, VI6_WPF_IRQ_STA(i));\n\t\tvsp1_write(vsp1, VI6_WPF_IRQ_STA(i), ~status & mask);\n\n\t\tif ((status & VI6_WPF_IRQ_STA_UND) && wpf->entity.pipe) {\n\t\t\twpf->entity.pipe->underrun_count++;\n\n\t\t\tdev_warn_ratelimited(vsp1->dev,\n\t\t\t\t\"Underrun occurred at WPF%u (total underruns %u)\\n\",\n\t\t\t\ti, wpf->entity.pipe->underrun_count);\n\t\t}\n\n\t\tif (status & VI6_WPF_IRQ_STA_DFE) {\n\t\t\tvsp1_pipeline_frame_end(wpf->entity.pipe);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \n\n \nstatic int vsp1_create_sink_links(struct vsp1_device *vsp1,\n\t\t\t\t  struct vsp1_entity *sink)\n{\n\tstruct media_entity *entity = &sink->subdev.entity;\n\tstruct vsp1_entity *source;\n\tunsigned int pad;\n\tint ret;\n\n\tlist_for_each_entry(source, &vsp1->entities, list_dev) {\n\t\tu32 flags;\n\n\t\tif (source->type == sink->type)\n\t\t\tcontinue;\n\n\t\tif (source->type == VSP1_ENTITY_HGO ||\n\t\t    source->type == VSP1_ENTITY_HGT ||\n\t\t    source->type == VSP1_ENTITY_LIF ||\n\t\t    source->type == VSP1_ENTITY_WPF)\n\t\t\tcontinue;\n\n\t\tflags = source->type == VSP1_ENTITY_RPF &&\n\t\t\tsink->type == VSP1_ENTITY_WPF &&\n\t\t\tsource->index == sink->index\n\t\t      ? MEDIA_LNK_FL_ENABLED : 0;\n\n\t\tfor (pad = 0; pad < entity->num_pads; ++pad) {\n\t\t\tif (!(entity->pads[pad].flags & MEDIA_PAD_FL_SINK))\n\t\t\t\tcontinue;\n\n\t\t\tret = media_create_pad_link(&source->subdev.entity,\n\t\t\t\t\t\t       source->source_pad,\n\t\t\t\t\t\t       entity, pad, flags);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (flags & MEDIA_LNK_FL_ENABLED)\n\t\t\t\tsource->sink = sink;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vsp1_uapi_create_links(struct vsp1_device *vsp1)\n{\n\tstruct vsp1_entity *entity;\n\tunsigned int i;\n\tint ret;\n\n\tlist_for_each_entry(entity, &vsp1->entities, list_dev) {\n\t\tif (entity->type == VSP1_ENTITY_LIF ||\n\t\t    entity->type == VSP1_ENTITY_RPF)\n\t\t\tcontinue;\n\n\t\tret = vsp1_create_sink_links(vsp1, entity);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (vsp1->hgo) {\n\t\tret = media_create_pad_link(&vsp1->hgo->histo.entity.subdev.entity,\n\t\t\t\t\t    HISTO_PAD_SOURCE,\n\t\t\t\t\t    &vsp1->hgo->histo.video.entity, 0,\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (vsp1->hgt) {\n\t\tret = media_create_pad_link(&vsp1->hgt->histo.entity.subdev.entity,\n\t\t\t\t\t    HISTO_PAD_SOURCE,\n\t\t\t\t\t    &vsp1->hgt->histo.video.entity, 0,\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < vsp1->info->lif_count; ++i) {\n\t\tif (!vsp1->lif[i])\n\t\t\tcontinue;\n\n\t\tret = media_create_pad_link(&vsp1->wpf[i]->entity.subdev.entity,\n\t\t\t\t\t    RWPF_PAD_SOURCE,\n\t\t\t\t\t    &vsp1->lif[i]->entity.subdev.entity,\n\t\t\t\t\t    LIF_PAD_SINK, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < vsp1->info->rpf_count; ++i) {\n\t\tstruct vsp1_rwpf *rpf = vsp1->rpf[i];\n\n\t\tret = media_create_pad_link(&rpf->video->video.entity, 0,\n\t\t\t\t\t    &rpf->entity.subdev.entity,\n\t\t\t\t\t    RWPF_PAD_SINK,\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < vsp1->info->wpf_count; ++i) {\n\t\t \n\t\tstruct vsp1_rwpf *wpf = vsp1->wpf[i];\n\n\t\tret = media_create_pad_link(&wpf->entity.subdev.entity,\n\t\t\t\t\t    RWPF_PAD_SOURCE,\n\t\t\t\t\t    &wpf->video->video.entity, 0,\n\t\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void vsp1_destroy_entities(struct vsp1_device *vsp1)\n{\n\tstruct vsp1_entity *entity, *_entity;\n\tstruct vsp1_video *video, *_video;\n\n\tlist_for_each_entry_safe(entity, _entity, &vsp1->entities, list_dev) {\n\t\tlist_del(&entity->list_dev);\n\t\tvsp1_entity_destroy(entity);\n\t}\n\n\tlist_for_each_entry_safe(video, _video, &vsp1->videos, list) {\n\t\tlist_del(&video->list);\n\t\tvsp1_video_cleanup(video);\n\t}\n\n\tv4l2_device_unregister(&vsp1->v4l2_dev);\n\tif (vsp1->info->uapi)\n\t\tmedia_device_unregister(&vsp1->media_dev);\n\tmedia_device_cleanup(&vsp1->media_dev);\n\n\tif (!vsp1->info->uapi)\n\t\tvsp1_drm_cleanup(vsp1);\n}\n\nstatic int vsp1_create_entities(struct vsp1_device *vsp1)\n{\n\tstruct media_device *mdev = &vsp1->media_dev;\n\tstruct v4l2_device *vdev = &vsp1->v4l2_dev;\n\tstruct vsp1_entity *entity;\n\tunsigned int i;\n\tint ret;\n\n\tmdev->dev = vsp1->dev;\n\tmdev->hw_revision = vsp1->version;\n\tstrscpy(mdev->model, vsp1->info->model, sizeof(mdev->model));\n\tmedia_device_init(mdev);\n\n\tvsp1->media_ops.link_setup = vsp1_entity_link_setup;\n\t \n\tif (vsp1->info->uapi)\n\t\tvsp1->media_ops.link_validate = v4l2_subdev_link_validate;\n\n\tvdev->mdev = mdev;\n\tret = v4l2_device_register(vsp1->dev, vdev);\n\tif (ret < 0) {\n\t\tdev_err(vsp1->dev, \"V4L2 device registration failed (%d)\\n\",\n\t\t\tret);\n\t\tgoto done;\n\t}\n\n\t \n\tif (vsp1_feature(vsp1, VSP1_HAS_BRS)) {\n\t\tvsp1->brs = vsp1_brx_create(vsp1, VSP1_ENTITY_BRS);\n\t\tif (IS_ERR(vsp1->brs)) {\n\t\t\tret = PTR_ERR(vsp1->brs);\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_add_tail(&vsp1->brs->entity.list_dev, &vsp1->entities);\n\t}\n\n\tif (vsp1_feature(vsp1, VSP1_HAS_BRU)) {\n\t\tvsp1->bru = vsp1_brx_create(vsp1, VSP1_ENTITY_BRU);\n\t\tif (IS_ERR(vsp1->bru)) {\n\t\t\tret = PTR_ERR(vsp1->bru);\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_add_tail(&vsp1->bru->entity.list_dev, &vsp1->entities);\n\t}\n\n\tif (vsp1_feature(vsp1, VSP1_HAS_CLU)) {\n\t\tvsp1->clu = vsp1_clu_create(vsp1);\n\t\tif (IS_ERR(vsp1->clu)) {\n\t\t\tret = PTR_ERR(vsp1->clu);\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_add_tail(&vsp1->clu->entity.list_dev, &vsp1->entities);\n\t}\n\n\tvsp1->hsi = vsp1_hsit_create(vsp1, true);\n\tif (IS_ERR(vsp1->hsi)) {\n\t\tret = PTR_ERR(vsp1->hsi);\n\t\tgoto done;\n\t}\n\n\tlist_add_tail(&vsp1->hsi->entity.list_dev, &vsp1->entities);\n\n\tvsp1->hst = vsp1_hsit_create(vsp1, false);\n\tif (IS_ERR(vsp1->hst)) {\n\t\tret = PTR_ERR(vsp1->hst);\n\t\tgoto done;\n\t}\n\n\tlist_add_tail(&vsp1->hst->entity.list_dev, &vsp1->entities);\n\n\tif (vsp1_feature(vsp1, VSP1_HAS_HGO) && vsp1->info->uapi) {\n\t\tvsp1->hgo = vsp1_hgo_create(vsp1);\n\t\tif (IS_ERR(vsp1->hgo)) {\n\t\t\tret = PTR_ERR(vsp1->hgo);\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_add_tail(&vsp1->hgo->histo.entity.list_dev,\n\t\t\t      &vsp1->entities);\n\t}\n\n\tif (vsp1_feature(vsp1, VSP1_HAS_HGT) && vsp1->info->uapi) {\n\t\tvsp1->hgt = vsp1_hgt_create(vsp1);\n\t\tif (IS_ERR(vsp1->hgt)) {\n\t\t\tret = PTR_ERR(vsp1->hgt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_add_tail(&vsp1->hgt->histo.entity.list_dev,\n\t\t\t      &vsp1->entities);\n\t}\n\n\t \n\tif (!vsp1->info->uapi) {\n\t\tfor (i = 0; i < vsp1->info->lif_count; ++i) {\n\t\t\tstruct vsp1_lif *lif;\n\n\t\t\tlif = vsp1_lif_create(vsp1, i);\n\t\t\tif (IS_ERR(lif)) {\n\t\t\t\tret = PTR_ERR(lif);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tvsp1->lif[i] = lif;\n\t\t\tlist_add_tail(&lif->entity.list_dev, &vsp1->entities);\n\t\t}\n\t}\n\n\tif (vsp1_feature(vsp1, VSP1_HAS_LUT)) {\n\t\tvsp1->lut = vsp1_lut_create(vsp1);\n\t\tif (IS_ERR(vsp1->lut)) {\n\t\t\tret = PTR_ERR(vsp1->lut);\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_add_tail(&vsp1->lut->entity.list_dev, &vsp1->entities);\n\t}\n\n\tfor (i = 0; i < vsp1->info->rpf_count; ++i) {\n\t\tstruct vsp1_rwpf *rpf;\n\n\t\trpf = vsp1_rpf_create(vsp1, i);\n\t\tif (IS_ERR(rpf)) {\n\t\t\tret = PTR_ERR(rpf);\n\t\t\tgoto done;\n\t\t}\n\n\t\tvsp1->rpf[i] = rpf;\n\t\tlist_add_tail(&rpf->entity.list_dev, &vsp1->entities);\n\n\t\tif (vsp1->info->uapi) {\n\t\t\tstruct vsp1_video *video = vsp1_video_create(vsp1, rpf);\n\n\t\t\tif (IS_ERR(video)) {\n\t\t\t\tret = PTR_ERR(video);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tlist_add_tail(&video->list, &vsp1->videos);\n\t\t}\n\t}\n\n\tif (vsp1_feature(vsp1, VSP1_HAS_SRU)) {\n\t\tvsp1->sru = vsp1_sru_create(vsp1);\n\t\tif (IS_ERR(vsp1->sru)) {\n\t\t\tret = PTR_ERR(vsp1->sru);\n\t\t\tgoto done;\n\t\t}\n\n\t\tlist_add_tail(&vsp1->sru->entity.list_dev, &vsp1->entities);\n\t}\n\n\tfor (i = 0; i < vsp1->info->uds_count; ++i) {\n\t\tstruct vsp1_uds *uds;\n\n\t\tuds = vsp1_uds_create(vsp1, i);\n\t\tif (IS_ERR(uds)) {\n\t\t\tret = PTR_ERR(uds);\n\t\t\tgoto done;\n\t\t}\n\n\t\tvsp1->uds[i] = uds;\n\t\tlist_add_tail(&uds->entity.list_dev, &vsp1->entities);\n\t}\n\n\tfor (i = 0; i < vsp1->info->uif_count; ++i) {\n\t\tstruct vsp1_uif *uif;\n\n\t\tuif = vsp1_uif_create(vsp1, i);\n\t\tif (IS_ERR(uif)) {\n\t\t\tret = PTR_ERR(uif);\n\t\t\tgoto done;\n\t\t}\n\n\t\tvsp1->uif[i] = uif;\n\t\tlist_add_tail(&uif->entity.list_dev, &vsp1->entities);\n\t}\n\n\tfor (i = 0; i < vsp1->info->wpf_count; ++i) {\n\t\tstruct vsp1_rwpf *wpf;\n\n\t\twpf = vsp1_wpf_create(vsp1, i);\n\t\tif (IS_ERR(wpf)) {\n\t\t\tret = PTR_ERR(wpf);\n\t\t\tgoto done;\n\t\t}\n\n\t\tvsp1->wpf[i] = wpf;\n\t\tlist_add_tail(&wpf->entity.list_dev, &vsp1->entities);\n\n\t\tif (vsp1->info->uapi) {\n\t\t\tstruct vsp1_video *video = vsp1_video_create(vsp1, wpf);\n\n\t\t\tif (IS_ERR(video)) {\n\t\t\t\tret = PTR_ERR(video);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tlist_add_tail(&video->list, &vsp1->videos);\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(entity, &vsp1->entities, list_dev) {\n\t\tret = v4l2_device_register_subdev(&vsp1->v4l2_dev,\n\t\t\t\t\t\t  &entity->subdev);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\t \n\tif (vsp1->info->uapi) {\n\t\tret = vsp1_uapi_create_links(vsp1);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tret = v4l2_device_register_subdev_nodes(&vsp1->v4l2_dev);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tret = media_device_register(mdev);\n\t} else {\n\t\tret = vsp1_drm_init(vsp1);\n\t}\n\ndone:\n\tif (ret < 0)\n\t\tvsp1_destroy_entities(vsp1);\n\n\treturn ret;\n}\n\nint vsp1_reset_wpf(struct vsp1_device *vsp1, unsigned int index)\n{\n\tunsigned int timeout;\n\tu32 status;\n\n\tstatus = vsp1_read(vsp1, VI6_STATUS);\n\tif (!(status & VI6_STATUS_SYS_ACT(index)))\n\t\treturn 0;\n\n\tvsp1_write(vsp1, VI6_SRESET, VI6_SRESET_SRTS(index));\n\tfor (timeout = 10; timeout > 0; --timeout) {\n\t\tstatus = vsp1_read(vsp1, VI6_STATUS);\n\t\tif (!(status & VI6_STATUS_SYS_ACT(index)))\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (!timeout) {\n\t\tdev_err(vsp1->dev, \"failed to reset wpf.%u\\n\", index);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int vsp1_device_init(struct vsp1_device *vsp1)\n{\n\tunsigned int i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < vsp1->info->wpf_count; ++i) {\n\t\tret = vsp1_reset_wpf(vsp1, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tvsp1_write(vsp1, VI6_CLK_DCSWT, (8 << VI6_CLK_DCSWT_CSTPW_SHIFT) |\n\t\t   (8 << VI6_CLK_DCSWT_CSTRW_SHIFT));\n\n\tfor (i = 0; i < vsp1->info->rpf_count; ++i)\n\t\tvsp1_write(vsp1, VI6_DPR_RPF_ROUTE(i), VI6_DPR_NODE_UNUSED);\n\n\tfor (i = 0; i < vsp1->info->uds_count; ++i)\n\t\tvsp1_write(vsp1, VI6_DPR_UDS_ROUTE(i), VI6_DPR_NODE_UNUSED);\n\n\tfor (i = 0; i < vsp1->info->uif_count; ++i)\n\t\tvsp1_write(vsp1, VI6_DPR_UIF_ROUTE(i), VI6_DPR_NODE_UNUSED);\n\n\tvsp1_write(vsp1, VI6_DPR_SRU_ROUTE, VI6_DPR_NODE_UNUSED);\n\tvsp1_write(vsp1, VI6_DPR_LUT_ROUTE, VI6_DPR_NODE_UNUSED);\n\tvsp1_write(vsp1, VI6_DPR_CLU_ROUTE, VI6_DPR_NODE_UNUSED);\n\tvsp1_write(vsp1, VI6_DPR_HST_ROUTE, VI6_DPR_NODE_UNUSED);\n\tvsp1_write(vsp1, VI6_DPR_HSI_ROUTE, VI6_DPR_NODE_UNUSED);\n\tvsp1_write(vsp1, VI6_DPR_BRU_ROUTE, VI6_DPR_NODE_UNUSED);\n\n\tif (vsp1_feature(vsp1, VSP1_HAS_BRS))\n\t\tvsp1_write(vsp1, VI6_DPR_ILV_BRS_ROUTE, VI6_DPR_NODE_UNUSED);\n\n\tvsp1_write(vsp1, VI6_DPR_HGO_SMPPT, (7 << VI6_DPR_SMPPT_TGW_SHIFT) |\n\t\t   (VI6_DPR_NODE_UNUSED << VI6_DPR_SMPPT_PT_SHIFT));\n\tvsp1_write(vsp1, VI6_DPR_HGT_SMPPT, (7 << VI6_DPR_SMPPT_TGW_SHIFT) |\n\t\t   (VI6_DPR_NODE_UNUSED << VI6_DPR_SMPPT_PT_SHIFT));\n\n\tvsp1_dlm_setup(vsp1);\n\n\treturn 0;\n}\n\nstatic void vsp1_mask_all_interrupts(struct vsp1_device *vsp1)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < vsp1->info->lif_count; ++i)\n\t\tvsp1_write(vsp1, VI6_DISP_IRQ_ENB(i), 0);\n\tfor (i = 0; i < vsp1->info->wpf_count; ++i)\n\t\tvsp1_write(vsp1, VI6_WPF_IRQ_ENB(i), 0);\n}\n\n \nint vsp1_device_get(struct vsp1_device *vsp1)\n{\n\treturn pm_runtime_resume_and_get(vsp1->dev);\n}\n\n \nvoid vsp1_device_put(struct vsp1_device *vsp1)\n{\n\tpm_runtime_put_sync(vsp1->dev);\n}\n\n \n\nstatic int __maybe_unused vsp1_pm_suspend(struct device *dev)\n{\n\tstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\n\n\t \n\tif (!vsp1->drm)\n\t\tvsp1_video_suspend(vsp1);\n\n\tpm_runtime_force_suspend(vsp1->dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused vsp1_pm_resume(struct device *dev)\n{\n\tstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\n\n\tpm_runtime_force_resume(vsp1->dev);\n\n\t \n\tif (!vsp1->drm)\n\t\tvsp1_video_resume(vsp1);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused vsp1_pm_runtime_suspend(struct device *dev)\n{\n\tstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\n\n\trcar_fcp_disable(vsp1->fcp);\n\treset_control_assert(vsp1->rstc);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused vsp1_pm_runtime_resume(struct device *dev)\n{\n\tstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = reset_control_deassert(vsp1->rstc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (vsp1->info) {\n\t\t \n\t\tif (vsp1->info->gen == 2)\n\t\t\tudelay(1);\n\n\t\tret = vsp1_device_init(vsp1);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tret = rcar_fcp_enable(vsp1->fcp);\n\ndone:\n\tif (ret < 0)\n\t\treset_control_assert(vsp1->rstc);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops vsp1_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(vsp1_pm_suspend, vsp1_pm_resume)\n\tSET_RUNTIME_PM_OPS(vsp1_pm_runtime_suspend, vsp1_pm_runtime_resume, NULL)\n};\n\n \n\nstatic const struct vsp1_device_info vsp1_device_infos[] = {\n\t{\n\t\t.version = VI6_IP_VERSION_MODEL_VSPS_H2,\n\t\t.model = \"VSP1-S\",\n\t\t.gen = 2,\n\t\t.features = VSP1_HAS_BRU | VSP1_HAS_CLU | VSP1_HAS_HGO\n\t\t\t  | VSP1_HAS_HGT | VSP1_HAS_LUT | VSP1_HAS_SRU\n\t\t\t  | VSP1_HAS_WPF_VFLIP,\n\t\t.rpf_count = 5,\n\t\t.uds_count = 3,\n\t\t.wpf_count = 4,\n\t\t.num_bru_inputs = 4,\n\t\t.uapi = true,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPR_H2,\n\t\t.model = \"VSP1-R\",\n\t\t.gen = 2,\n\t\t.features = VSP1_HAS_BRU | VSP1_HAS_SRU | VSP1_HAS_WPF_VFLIP,\n\t\t.rpf_count = 5,\n\t\t.uds_count = 3,\n\t\t.wpf_count = 4,\n\t\t.num_bru_inputs = 4,\n\t\t.uapi = true,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPD_GEN2,\n\t\t.model = \"VSP1-D\",\n\t\t.gen = 2,\n\t\t.features = VSP1_HAS_BRU | VSP1_HAS_HGO | VSP1_HAS_LUT,\n\t\t.lif_count = 1,\n\t\t.rpf_count = 4,\n\t\t.uds_count = 1,\n\t\t.wpf_count = 1,\n\t\t.num_bru_inputs = 4,\n\t\t.uapi = true,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPS_M2,\n\t\t.model = \"VSP1-S\",\n\t\t.gen = 2,\n\t\t.features = VSP1_HAS_BRU | VSP1_HAS_CLU | VSP1_HAS_HGO\n\t\t\t  | VSP1_HAS_HGT | VSP1_HAS_LUT | VSP1_HAS_SRU\n\t\t\t  | VSP1_HAS_WPF_VFLIP,\n\t\t.rpf_count = 5,\n\t\t.uds_count = 1,\n\t\t.wpf_count = 4,\n\t\t.num_bru_inputs = 4,\n\t\t.uapi = true,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPS_V2H,\n\t\t.model = \"VSP1V-S\",\n\t\t.gen = 2,\n\t\t.features = VSP1_HAS_BRU | VSP1_HAS_CLU | VSP1_HAS_LUT\n\t\t\t  | VSP1_HAS_SRU | VSP1_HAS_WPF_VFLIP,\n\t\t.rpf_count = 4,\n\t\t.uds_count = 1,\n\t\t.wpf_count = 4,\n\t\t.num_bru_inputs = 4,\n\t\t.uapi = true,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPD_V2H,\n\t\t.model = \"VSP1V-D\",\n\t\t.gen = 2,\n\t\t.features = VSP1_HAS_BRU | VSP1_HAS_CLU | VSP1_HAS_LUT,\n\t\t.lif_count = 1,\n\t\t.rpf_count = 4,\n\t\t.uds_count = 1,\n\t\t.wpf_count = 1,\n\t\t.num_bru_inputs = 4,\n\t\t.uapi = true,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPI_GEN3,\n\t\t.model = \"VSP2-I\",\n\t\t.gen = 3,\n\t\t.features = VSP1_HAS_CLU | VSP1_HAS_HGO | VSP1_HAS_HGT\n\t\t\t  | VSP1_HAS_LUT | VSP1_HAS_SRU | VSP1_HAS_WPF_HFLIP\n\t\t\t  | VSP1_HAS_WPF_VFLIP,\n\t\t.rpf_count = 1,\n\t\t.uds_count = 1,\n\t\t.wpf_count = 1,\n\t\t.uapi = true,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPBD_GEN3,\n\t\t.model = \"VSP2-BD\",\n\t\t.gen = 3,\n\t\t.features = VSP1_HAS_BRU | VSP1_HAS_WPF_VFLIP,\n\t\t.rpf_count = 5,\n\t\t.wpf_count = 1,\n\t\t.num_bru_inputs = 5,\n\t\t.uapi = true,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPBC_GEN3,\n\t\t.model = \"VSP2-BC\",\n\t\t.gen = 3,\n\t\t.features = VSP1_HAS_BRU | VSP1_HAS_CLU | VSP1_HAS_HGO\n\t\t\t  | VSP1_HAS_LUT | VSP1_HAS_WPF_VFLIP,\n\t\t.rpf_count = 5,\n\t\t.wpf_count = 1,\n\t\t.num_bru_inputs = 5,\n\t\t.uapi = true,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPBS_GEN3,\n\t\t.model = \"VSP2-BS\",\n\t\t.gen = 3,\n\t\t.features = VSP1_HAS_BRS | VSP1_HAS_WPF_VFLIP,\n\t\t.rpf_count = 2,\n\t\t.wpf_count = 1,\n\t\t.uapi = true,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPD_GEN3,\n\t\t.model = \"VSP2-D\",\n\t\t.gen = 3,\n\t\t.features = VSP1_HAS_BRU | VSP1_HAS_WPF_VFLIP | VSP1_HAS_EXT_DL,\n\t\t.lif_count = 1,\n\t\t.rpf_count = 5,\n\t\t.uif_count = 1,\n\t\t.wpf_count = 2,\n\t\t.num_bru_inputs = 5,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPD_V3,\n\t\t.model = \"VSP2-D\",\n\t\t.soc = VI6_IP_VERSION_SOC_V3H,\n\t\t.gen = 3,\n\t\t.features = VSP1_HAS_BRS | VSP1_HAS_BRU,\n\t\t.lif_count = 1,\n\t\t.rpf_count = 5,\n\t\t.uif_count = 1,\n\t\t.wpf_count = 1,\n\t\t.num_bru_inputs = 5,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPD_V3,\n\t\t.model = \"VSP2-D\",\n\t\t.soc = VI6_IP_VERSION_SOC_V3M,\n\t\t.gen = 3,\n\t\t.features = VSP1_HAS_BRS | VSP1_HAS_BRU | VSP1_HAS_NON_ZERO_LBA,\n\t\t.lif_count = 1,\n\t\t.rpf_count = 5,\n\t\t.uif_count = 1,\n\t\t.wpf_count = 1,\n\t\t.num_bru_inputs = 5,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPDL_GEN3,\n\t\t.model = \"VSP2-DL\",\n\t\t.gen = 3,\n\t\t.features = VSP1_HAS_BRS | VSP1_HAS_BRU | VSP1_HAS_EXT_DL,\n\t\t.lif_count = 2,\n\t\t.rpf_count = 5,\n\t\t.uif_count = 2,\n\t\t.wpf_count = 2,\n\t\t.num_bru_inputs = 5,\n\t}, {\n\t\t.version = VI6_IP_VERSION_MODEL_VSPD_GEN4,\n\t\t.model = \"VSP2-D\",\n\t\t.gen = 4,\n\t\t.features = VSP1_HAS_BRU | VSP1_HAS_EXT_DL,\n\t\t.lif_count = 1,\n\t\t.rpf_count = 5,\n\t\t.uif_count = 2,\n\t\t.wpf_count = 1,\n\t\t.num_bru_inputs = 5,\n\t},\n};\n\nstatic const struct vsp1_device_info rzg2l_vsp2_device_info = {\n\t.version = VI6_IP_VERSION_MODEL_VSPD_RZG2L,\n\t.model = \"VSP2-D\",\n\t.soc = VI6_IP_VERSION_SOC_RZG2L,\n\t.gen = 3,\n\t.features = VSP1_HAS_BRS | VSP1_HAS_WPF_VFLIP | VSP1_HAS_EXT_DL\n\t\t  | VSP1_HAS_NON_ZERO_LBA,\n\t.lif_count = 1,\n\t.rpf_count = 2,\n\t.wpf_count = 1,\n};\n\nstatic const struct vsp1_device_info *vsp1_lookup_info(struct vsp1_device *vsp1)\n{\n\tconst struct vsp1_device_info *info;\n\tunsigned int i;\n\tu32 model;\n\tu32 soc;\n\n\t \n\tinfo = of_device_get_match_data(vsp1->dev);\n\tif (info) {\n\t\tvsp1->version = VI6_IP_VERSION_VSP_SW | info->version | info->soc;\n\t\treturn info;\n\t}\n\n\tvsp1->version = vsp1_read(vsp1, VI6_IP_VERSION);\n\tmodel = vsp1->version & VI6_IP_VERSION_MODEL_MASK;\n\tsoc = vsp1->version & VI6_IP_VERSION_SOC_MASK;\n\n\tfor (i = 0; i < ARRAY_SIZE(vsp1_device_infos); ++i) {\n\t\tinfo = &vsp1_device_infos[i];\n\n\t\tif (model == info->version && (!info->soc || soc == info->soc))\n\t\t\treturn info;\n\t}\n\n\tdev_err(vsp1->dev, \"unsupported IP version 0x%08x\\n\", vsp1->version);\n\n\treturn NULL;\n}\n\nstatic int vsp1_probe(struct platform_device *pdev)\n{\n\tstruct vsp1_device *vsp1;\n\tstruct device_node *fcp_node;\n\tint ret;\n\tint irq;\n\n\tvsp1 = devm_kzalloc(&pdev->dev, sizeof(*vsp1), GFP_KERNEL);\n\tif (vsp1 == NULL)\n\t\treturn -ENOMEM;\n\n\tvsp1->dev = &pdev->dev;\n\tINIT_LIST_HEAD(&vsp1->entities);\n\tINIT_LIST_HEAD(&vsp1->videos);\n\n\tplatform_set_drvdata(pdev, vsp1);\n\n\t \n\tvsp1->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(vsp1->mmio))\n\t\treturn PTR_ERR(vsp1->mmio);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tvsp1->rstc = devm_reset_control_get_shared(&pdev->dev, NULL);\n\tif (IS_ERR(vsp1->rstc))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(vsp1->rstc),\n\t\t\t\t     \"failed to get reset control\\n\");\n\n\t \n\tfcp_node = of_parse_phandle(pdev->dev.of_node, \"renesas,fcp\", 0);\n\tif (fcp_node) {\n\t\tvsp1->fcp = rcar_fcp_get(fcp_node);\n\t\tof_node_put(fcp_node);\n\t\tif (IS_ERR(vsp1->fcp)) {\n\t\t\tdev_dbg(&pdev->dev, \"FCP not found (%ld)\\n\",\n\t\t\t\tPTR_ERR(vsp1->fcp));\n\t\t\treturn PTR_ERR(vsp1->fcp);\n\t\t}\n\n\t\t \n\t\tvsp1->bus_master = rcar_fcp_get_device(vsp1->fcp);\n\t} else {\n\t\tvsp1->bus_master = vsp1->dev;\n\t}\n\n\t \n\tpm_runtime_enable(&pdev->dev);\n\n\tret = vsp1_device_get(vsp1);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tvsp1->info = vsp1_lookup_info(vsp1);\n\tif (!vsp1->info) {\n\t\tvsp1_device_put(vsp1);\n\t\tret = -ENXIO;\n\t\tgoto done;\n\t}\n\n\tdev_dbg(&pdev->dev, \"IP version 0x%08x\\n\", vsp1->version);\n\n\t \n\tvsp1_mask_all_interrupts(vsp1);\n\n\tvsp1_device_put(vsp1);\n\n\tret = devm_request_irq(&pdev->dev, irq, vsp1_irq_handler,\n\t\t\t       IRQF_SHARED, dev_name(&pdev->dev), vsp1);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tret = vsp1_create_entities(vsp1);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to create entities\\n\");\n\t\tgoto done;\n\t}\n\ndone:\n\tif (ret) {\n\t\tpm_runtime_disable(&pdev->dev);\n\t\trcar_fcp_put(vsp1->fcp);\n\t}\n\n\treturn ret;\n}\n\nstatic void vsp1_remove(struct platform_device *pdev)\n{\n\tstruct vsp1_device *vsp1 = platform_get_drvdata(pdev);\n\n\tvsp1_destroy_entities(vsp1);\n\trcar_fcp_put(vsp1->fcp);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id vsp1_of_match[] = {\n\t{ .compatible = \"renesas,vsp1\" },\n\t{ .compatible = \"renesas,vsp2\" },\n\t{ .compatible = \"renesas,r9a07g044-vsp2\", .data = &rzg2l_vsp2_device_info },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, vsp1_of_match);\n\nstatic struct platform_driver vsp1_platform_driver = {\n\t.probe\t\t= vsp1_probe,\n\t.remove_new\t= vsp1_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"vsp1\",\n\t\t.pm\t= &vsp1_pm_ops,\n\t\t.of_match_table = vsp1_of_match,\n\t},\n};\n\nmodule_platform_driver(vsp1_platform_driver);\n\nMODULE_ALIAS(\"vsp1\");\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_DESCRIPTION(\"Renesas VSP1 Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}