{
  "module_name": "vsp1_uds.c",
  "hash_id": "4ec571e3a4c7d03a00b0148b725637f2710dcfce6fb6c9cbe77a39d47a7ccbd4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_uds.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gfp.h>\n\n#include <media/v4l2-subdev.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_dl.h\"\n#include \"vsp1_pipe.h\"\n#include \"vsp1_uds.h\"\n\n#define UDS_MIN_SIZE\t\t\t\t4U\n#define UDS_MAX_SIZE\t\t\t\t8190U\n\n#define UDS_MIN_FACTOR\t\t\t\t0x0100\n#define UDS_MAX_FACTOR\t\t\t\t0xffff\n\n \n\nstatic inline void vsp1_uds_write(struct vsp1_uds *uds,\n\t\t\t\t  struct vsp1_dl_body *dlb, u32 reg, u32 data)\n{\n\tvsp1_dl_body_write(dlb, reg + uds->entity.index * VI6_UDS_OFFSET, data);\n}\n\n \n\nvoid vsp1_uds_set_alpha(struct vsp1_entity *entity, struct vsp1_dl_body *dlb,\n\t\t\tunsigned int alpha)\n{\n\tstruct vsp1_uds *uds = to_uds(&entity->subdev);\n\n\tvsp1_uds_write(uds, dlb, VI6_UDS_ALPVAL,\n\t\t       alpha << VI6_UDS_ALPVAL_VAL0_SHIFT);\n}\n\n \nstatic unsigned int uds_output_size(unsigned int input, unsigned int ratio)\n{\n\tif (ratio > 4096) {\n\t\t \n\t\tunsigned int mp;\n\n\t\tmp = ratio / 4096;\n\t\tmp = mp < 4 ? 1 : (mp < 8 ? 2 : 4);\n\n\t\treturn (input - 1) / mp * mp * 4096 / ratio + 1;\n\t} else {\n\t\t \n\t\treturn (input - 1) * 4096 / ratio + 1;\n\t}\n}\n\n \nstatic void uds_output_limits(unsigned int input,\n\t\t\t      unsigned int *minimum, unsigned int *maximum)\n{\n\t*minimum = max(uds_output_size(input, UDS_MAX_FACTOR), UDS_MIN_SIZE);\n\t*maximum = min(uds_output_size(input, UDS_MIN_FACTOR), UDS_MAX_SIZE);\n}\n\n \nstatic unsigned int uds_passband_width(unsigned int ratio)\n{\n\tif (ratio >= 4096) {\n\t\t \n\t\tunsigned int mp;\n\n\t\tmp = ratio / 4096;\n\t\tmp = mp < 4 ? 1 : (mp < 8 ? 2 : 4);\n\n\t\treturn 64 * 4096 * mp / ratio;\n\t} else {\n\t\t \n\t\treturn 64;\n\t}\n}\n\nstatic unsigned int uds_compute_ratio(unsigned int input, unsigned int output)\n{\n\t \n\treturn (input - 1) * 4096 / (output - 1);\n}\n\n \n\nstatic int uds_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstatic const unsigned int codes[] = {\n\t\tMEDIA_BUS_FMT_ARGB8888_1X32,\n\t\tMEDIA_BUS_FMT_AYUV8_1X32,\n\t};\n\n\treturn vsp1_subdev_enum_mbus_code(subdev, sd_state, code, codes,\n\t\t\t\t\t  ARRAY_SIZE(codes));\n}\n\nstatic int uds_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct vsp1_uds *uds = to_uds(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tint ret = 0;\n\n\tconfig = vsp1_entity_get_pad_config(&uds->entity, sd_state,\n\t\t\t\t\t    fse->which);\n\tif (!config)\n\t\treturn -EINVAL;\n\n\tformat = vsp1_entity_get_pad_format(&uds->entity, config,\n\t\t\t\t\t    UDS_PAD_SINK);\n\n\tmutex_lock(&uds->entity.lock);\n\n\tif (fse->index || fse->code != format->code) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (fse->pad == UDS_PAD_SINK) {\n\t\tfse->min_width = UDS_MIN_SIZE;\n\t\tfse->max_width = UDS_MAX_SIZE;\n\t\tfse->min_height = UDS_MIN_SIZE;\n\t\tfse->max_height = UDS_MAX_SIZE;\n\t} else {\n\t\tuds_output_limits(format->width, &fse->min_width,\n\t\t\t\t  &fse->max_width);\n\t\tuds_output_limits(format->height, &fse->min_height,\n\t\t\t\t  &fse->max_height);\n\t}\n\ndone:\n\tmutex_unlock(&uds->entity.lock);\n\treturn ret;\n}\n\nstatic void uds_try_format(struct vsp1_uds *uds,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   unsigned int pad, struct v4l2_mbus_framefmt *fmt)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\tunsigned int minimum;\n\tunsigned int maximum;\n\n\tswitch (pad) {\n\tcase UDS_PAD_SINK:\n\t\t \n\t\tif (fmt->code != MEDIA_BUS_FMT_ARGB8888_1X32 &&\n\t\t    fmt->code != MEDIA_BUS_FMT_AYUV8_1X32)\n\t\t\tfmt->code = MEDIA_BUS_FMT_AYUV8_1X32;\n\n\t\tfmt->width = clamp(fmt->width, UDS_MIN_SIZE, UDS_MAX_SIZE);\n\t\tfmt->height = clamp(fmt->height, UDS_MIN_SIZE, UDS_MAX_SIZE);\n\t\tbreak;\n\n\tcase UDS_PAD_SOURCE:\n\t\t \n\t\tformat = vsp1_entity_get_pad_format(&uds->entity, sd_state,\n\t\t\t\t\t\t    UDS_PAD_SINK);\n\t\tfmt->code = format->code;\n\n\t\tuds_output_limits(format->width, &minimum, &maximum);\n\t\tfmt->width = clamp(fmt->width, minimum, maximum);\n\t\tuds_output_limits(format->height, &minimum, &maximum);\n\t\tfmt->height = clamp(fmt->height, minimum, maximum);\n\t\tbreak;\n\t}\n\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n}\n\nstatic int uds_set_format(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct vsp1_uds *uds = to_uds(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tint ret = 0;\n\n\tmutex_lock(&uds->entity.lock);\n\n\tconfig = vsp1_entity_get_pad_config(&uds->entity, sd_state,\n\t\t\t\t\t    fmt->which);\n\tif (!config) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tuds_try_format(uds, config, fmt->pad, &fmt->format);\n\n\tformat = vsp1_entity_get_pad_format(&uds->entity, config, fmt->pad);\n\t*format = fmt->format;\n\n\tif (fmt->pad == UDS_PAD_SINK) {\n\t\t \n\t\tformat = vsp1_entity_get_pad_format(&uds->entity, config,\n\t\t\t\t\t\t    UDS_PAD_SOURCE);\n\t\t*format = fmt->format;\n\n\t\tuds_try_format(uds, config, UDS_PAD_SOURCE, format);\n\t}\n\ndone:\n\tmutex_unlock(&uds->entity.lock);\n\treturn ret;\n}\n\n \n\nstatic const struct v4l2_subdev_pad_ops uds_pad_ops = {\n\t.init_cfg = vsp1_entity_init_cfg,\n\t.enum_mbus_code = uds_enum_mbus_code,\n\t.enum_frame_size = uds_enum_frame_size,\n\t.get_fmt = vsp1_subdev_get_pad_format,\n\t.set_fmt = uds_set_format,\n};\n\nstatic const struct v4l2_subdev_ops uds_ops = {\n\t.pad    = &uds_pad_ops,\n};\n\n \n\nstatic void uds_configure_stream(struct vsp1_entity *entity,\n\t\t\t\t struct vsp1_pipeline *pipe,\n\t\t\t\t struct vsp1_dl_list *dl,\n\t\t\t\t struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_uds *uds = to_uds(&entity->subdev);\n\tconst struct v4l2_mbus_framefmt *output;\n\tconst struct v4l2_mbus_framefmt *input;\n\tunsigned int hscale;\n\tunsigned int vscale;\n\tbool multitap;\n\n\tinput = vsp1_entity_get_pad_format(&uds->entity, uds->entity.config,\n\t\t\t\t\t   UDS_PAD_SINK);\n\toutput = vsp1_entity_get_pad_format(&uds->entity, uds->entity.config,\n\t\t\t\t\t    UDS_PAD_SOURCE);\n\n\thscale = uds_compute_ratio(input->width, output->width);\n\tvscale = uds_compute_ratio(input->height, output->height);\n\n\tdev_dbg(uds->entity.vsp1->dev, \"hscale %u vscale %u\\n\", hscale, vscale);\n\n\t \n\tif (uds->scale_alpha && (hscale >= 8192 || vscale >= 8192))\n\t\tmultitap = false;\n\telse\n\t\tmultitap = true;\n\n\tvsp1_uds_write(uds, dlb, VI6_UDS_CTRL,\n\t\t       (uds->scale_alpha ? VI6_UDS_CTRL_AON : 0) |\n\t\t       (multitap ? VI6_UDS_CTRL_BC : 0));\n\n\tvsp1_uds_write(uds, dlb, VI6_UDS_PASS_BWIDTH,\n\t\t       (uds_passband_width(hscale)\n\t\t\t\t<< VI6_UDS_PASS_BWIDTH_H_SHIFT) |\n\t\t       (uds_passband_width(vscale)\n\t\t\t\t<< VI6_UDS_PASS_BWIDTH_V_SHIFT));\n\n\t \n\tvsp1_uds_write(uds, dlb, VI6_UDS_SCALE,\n\t\t       (hscale << VI6_UDS_SCALE_HFRAC_SHIFT) |\n\t\t       (vscale << VI6_UDS_SCALE_VFRAC_SHIFT));\n}\n\nstatic void uds_configure_partition(struct vsp1_entity *entity,\n\t\t\t\t    struct vsp1_pipeline *pipe,\n\t\t\t\t    struct vsp1_dl_list *dl,\n\t\t\t\t    struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_uds *uds = to_uds(&entity->subdev);\n\tstruct vsp1_partition *partition = pipe->partition;\n\tconst struct v4l2_mbus_framefmt *output;\n\n\toutput = vsp1_entity_get_pad_format(&uds->entity, uds->entity.config,\n\t\t\t\t\t    UDS_PAD_SOURCE);\n\n\t \n\tvsp1_uds_write(uds, dlb, VI6_UDS_HSZCLIP, VI6_UDS_HSZCLIP_HCEN |\n\t\t       (0 << VI6_UDS_HSZCLIP_HCL_OFST_SHIFT) |\n\t\t       (partition->uds_sink.width\n\t\t\t\t<< VI6_UDS_HSZCLIP_HCL_SIZE_SHIFT));\n\n\t \n\tvsp1_uds_write(uds, dlb, VI6_UDS_CLIP_SIZE,\n\t\t       (partition->uds_source.width\n\t\t\t\t<< VI6_UDS_CLIP_SIZE_HSIZE_SHIFT) |\n\t\t       (output->height\n\t\t\t\t<< VI6_UDS_CLIP_SIZE_VSIZE_SHIFT));\n}\n\nstatic unsigned int uds_max_width(struct vsp1_entity *entity,\n\t\t\t\t  struct vsp1_pipeline *pipe)\n{\n\tstruct vsp1_uds *uds = to_uds(&entity->subdev);\n\tconst struct v4l2_mbus_framefmt *output;\n\tconst struct v4l2_mbus_framefmt *input;\n\tunsigned int hscale;\n\n\tinput = vsp1_entity_get_pad_format(&uds->entity, uds->entity.config,\n\t\t\t\t\t   UDS_PAD_SINK);\n\toutput = vsp1_entity_get_pad_format(&uds->entity, uds->entity.config,\n\t\t\t\t\t    UDS_PAD_SOURCE);\n\thscale = output->width / input->width;\n\n\t \n\tif (hscale <= 2)\n\t\treturn 256;\n\telse if (hscale <= 4)\n\t\treturn 512;\n\telse if (hscale <= 8)\n\t\treturn 1024;\n\telse\n\t\treturn 2048;\n}\n\n \n\nstatic void uds_partition(struct vsp1_entity *entity,\n\t\t\t  struct vsp1_pipeline *pipe,\n\t\t\t  struct vsp1_partition *partition,\n\t\t\t  unsigned int partition_idx,\n\t\t\t  struct vsp1_partition_window *window)\n{\n\tstruct vsp1_uds *uds = to_uds(&entity->subdev);\n\tconst struct v4l2_mbus_framefmt *output;\n\tconst struct v4l2_mbus_framefmt *input;\n\n\t \n\tpartition->uds_sink = *window;\n\tpartition->uds_source = *window;\n\n\tinput = vsp1_entity_get_pad_format(&uds->entity, uds->entity.config,\n\t\t\t\t\t   UDS_PAD_SINK);\n\toutput = vsp1_entity_get_pad_format(&uds->entity, uds->entity.config,\n\t\t\t\t\t    UDS_PAD_SOURCE);\n\n\tpartition->uds_sink.width = window->width * input->width\n\t\t\t\t  / output->width;\n\tpartition->uds_sink.left = window->left * input->width\n\t\t\t\t / output->width;\n\n\t*window = partition->uds_sink;\n}\n\nstatic const struct vsp1_entity_operations uds_entity_ops = {\n\t.configure_stream = uds_configure_stream,\n\t.configure_partition = uds_configure_partition,\n\t.max_width = uds_max_width,\n\t.partition = uds_partition,\n};\n\n \n\nstruct vsp1_uds *vsp1_uds_create(struct vsp1_device *vsp1, unsigned int index)\n{\n\tstruct vsp1_uds *uds;\n\tchar name[6];\n\tint ret;\n\n\tuds = devm_kzalloc(vsp1->dev, sizeof(*uds), GFP_KERNEL);\n\tif (uds == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tuds->entity.ops = &uds_entity_ops;\n\tuds->entity.type = VSP1_ENTITY_UDS;\n\tuds->entity.index = index;\n\n\tsprintf(name, \"uds.%u\", index);\n\tret = vsp1_entity_init(vsp1, &uds->entity, name, 2, &uds_ops,\n\t\t\t       MEDIA_ENT_F_PROC_VIDEO_SCALER);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\treturn uds;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}