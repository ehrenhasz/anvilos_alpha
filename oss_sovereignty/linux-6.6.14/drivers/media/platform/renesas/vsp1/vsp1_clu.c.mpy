{
  "module_name": "vsp1_clu.c",
  "hash_id": "589b821276a5bf1102661212d47010dee8e54d1545b48ccb04f6555491309163",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_clu.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-subdev.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_clu.h\"\n#include \"vsp1_dl.h\"\n\n#define CLU_MIN_SIZE\t\t\t\t4U\n#define CLU_MAX_SIZE\t\t\t\t8190U\n\n#define CLU_SIZE\t\t\t\t(17 * 17 * 17)\n\n \n\nstatic inline void vsp1_clu_write(struct vsp1_clu *clu,\n\t\t\t\t  struct vsp1_dl_body *dlb, u32 reg, u32 data)\n{\n\tvsp1_dl_body_write(dlb, reg, data);\n}\n\n \n\n#define V4L2_CID_VSP1_CLU_TABLE\t\t\t(V4L2_CID_USER_BASE | 0x1001)\n#define V4L2_CID_VSP1_CLU_MODE\t\t\t(V4L2_CID_USER_BASE | 0x1002)\n#define V4L2_CID_VSP1_CLU_MODE_2D\t\t0\n#define V4L2_CID_VSP1_CLU_MODE_3D\t\t1\n\nstatic int clu_set_table(struct vsp1_clu *clu, struct v4l2_ctrl *ctrl)\n{\n\tstruct vsp1_dl_body *dlb;\n\tunsigned int i;\n\n\tdlb = vsp1_dl_body_get(clu->pool);\n\tif (!dlb)\n\t\treturn -ENOMEM;\n\n\tvsp1_dl_body_write(dlb, VI6_CLU_ADDR, 0);\n\tfor (i = 0; i < CLU_SIZE; ++i)\n\t\tvsp1_dl_body_write(dlb, VI6_CLU_DATA, ctrl->p_new.p_u32[i]);\n\n\tspin_lock_irq(&clu->lock);\n\tswap(clu->clu, dlb);\n\tspin_unlock_irq(&clu->lock);\n\n\tvsp1_dl_body_put(dlb);\n\treturn 0;\n}\n\nstatic int clu_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vsp1_clu *clu =\n\t\tcontainer_of(ctrl->handler, struct vsp1_clu, ctrls);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VSP1_CLU_TABLE:\n\t\tclu_set_table(clu, ctrl);\n\t\tbreak;\n\n\tcase V4L2_CID_VSP1_CLU_MODE:\n\t\tclu->mode = ctrl->val;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops clu_ctrl_ops = {\n\t.s_ctrl = clu_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config clu_table_control = {\n\t.ops = &clu_ctrl_ops,\n\t.id = V4L2_CID_VSP1_CLU_TABLE,\n\t.name = \"Look-Up Table\",\n\t.type = V4L2_CTRL_TYPE_U32,\n\t.min = 0x00000000,\n\t.max = 0x00ffffff,\n\t.step = 1,\n\t.def = 0,\n\t.dims = { 17, 17, 17 },\n};\n\nstatic const char * const clu_mode_menu[] = {\n\t\"2D\",\n\t\"3D\",\n\tNULL,\n};\n\nstatic const struct v4l2_ctrl_config clu_mode_control = {\n\t.ops = &clu_ctrl_ops,\n\t.id = V4L2_CID_VSP1_CLU_MODE,\n\t.name = \"Mode\",\n\t.type = V4L2_CTRL_TYPE_MENU,\n\t.min = 0,\n\t.max = 1,\n\t.def = 1,\n\t.qmenu = clu_mode_menu,\n};\n\n \n\nstatic const unsigned int clu_codes[] = {\n\tMEDIA_BUS_FMT_ARGB8888_1X32,\n\tMEDIA_BUS_FMT_AHSV8888_1X32,\n\tMEDIA_BUS_FMT_AYUV8_1X32,\n};\n\nstatic int clu_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\treturn vsp1_subdev_enum_mbus_code(subdev, sd_state, code, clu_codes,\n\t\t\t\t\t  ARRAY_SIZE(clu_codes));\n}\n\nstatic int clu_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_frame_size_enum *fse)\n{\n\treturn vsp1_subdev_enum_frame_size(subdev, sd_state, fse,\n\t\t\t\t\t   CLU_MIN_SIZE,\n\t\t\t\t\t   CLU_MIN_SIZE, CLU_MAX_SIZE,\n\t\t\t\t\t   CLU_MAX_SIZE);\n}\n\nstatic int clu_set_format(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\treturn vsp1_subdev_set_pad_format(subdev, sd_state, fmt, clu_codes,\n\t\t\t\t\t  ARRAY_SIZE(clu_codes),\n\t\t\t\t\t  CLU_MIN_SIZE, CLU_MIN_SIZE,\n\t\t\t\t\t  CLU_MAX_SIZE, CLU_MAX_SIZE);\n}\n\n \n\nstatic const struct v4l2_subdev_pad_ops clu_pad_ops = {\n\t.init_cfg = vsp1_entity_init_cfg,\n\t.enum_mbus_code = clu_enum_mbus_code,\n\t.enum_frame_size = clu_enum_frame_size,\n\t.get_fmt = vsp1_subdev_get_pad_format,\n\t.set_fmt = clu_set_format,\n};\n\nstatic const struct v4l2_subdev_ops clu_ops = {\n\t.pad    = &clu_pad_ops,\n};\n\n \n\nstatic void clu_configure_stream(struct vsp1_entity *entity,\n\t\t\t\t struct vsp1_pipeline *pipe,\n\t\t\t\t struct vsp1_dl_list *dl,\n\t\t\t\t struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_clu *clu = to_clu(&entity->subdev);\n\tstruct v4l2_mbus_framefmt *format;\n\n\t \n\tformat = vsp1_entity_get_pad_format(&clu->entity,\n\t\t\t\t\t    clu->entity.config,\n\t\t\t\t\t    CLU_PAD_SINK);\n\tclu->yuv_mode = format->code == MEDIA_BUS_FMT_AYUV8_1X32;\n}\n\nstatic void clu_configure_frame(struct vsp1_entity *entity,\n\t\t\t\tstruct vsp1_pipeline *pipe,\n\t\t\t\tstruct vsp1_dl_list *dl,\n\t\t\t\tstruct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_clu *clu = to_clu(&entity->subdev);\n\tstruct vsp1_dl_body *clu_dlb;\n\tunsigned long flags;\n\tu32 ctrl = VI6_CLU_CTRL_AAI | VI6_CLU_CTRL_MVS | VI6_CLU_CTRL_EN;\n\n\t \n\tif (clu->mode == V4L2_CID_VSP1_CLU_MODE_2D && clu->yuv_mode)\n\t\tctrl |= VI6_CLU_CTRL_AX1I_2D | VI6_CLU_CTRL_AX2I_2D\n\t\t     |  VI6_CLU_CTRL_OS0_2D | VI6_CLU_CTRL_OS1_2D\n\t\t     |  VI6_CLU_CTRL_OS2_2D | VI6_CLU_CTRL_M2D;\n\n\tvsp1_clu_write(clu, dlb, VI6_CLU_CTRL, ctrl);\n\n\tspin_lock_irqsave(&clu->lock, flags);\n\tclu_dlb = clu->clu;\n\tclu->clu = NULL;\n\tspin_unlock_irqrestore(&clu->lock, flags);\n\n\tif (clu_dlb) {\n\t\tvsp1_dl_list_add_body(dl, clu_dlb);\n\n\t\t \n\t\tvsp1_dl_body_put(clu_dlb);\n\t}\n}\n\nstatic void clu_destroy(struct vsp1_entity *entity)\n{\n\tstruct vsp1_clu *clu = to_clu(&entity->subdev);\n\n\tvsp1_dl_body_pool_destroy(clu->pool);\n}\n\nstatic const struct vsp1_entity_operations clu_entity_ops = {\n\t.configure_stream = clu_configure_stream,\n\t.configure_frame = clu_configure_frame,\n\t.destroy = clu_destroy,\n};\n\n \n\nstruct vsp1_clu *vsp1_clu_create(struct vsp1_device *vsp1)\n{\n\tstruct vsp1_clu *clu;\n\tint ret;\n\n\tclu = devm_kzalloc(vsp1->dev, sizeof(*clu), GFP_KERNEL);\n\tif (clu == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&clu->lock);\n\n\tclu->entity.ops = &clu_entity_ops;\n\tclu->entity.type = VSP1_ENTITY_CLU;\n\n\tret = vsp1_entity_init(vsp1, &clu->entity, \"clu\", 2, &clu_ops,\n\t\t\t       MEDIA_ENT_F_PROC_VIDEO_LUT);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tclu->pool = vsp1_dl_body_pool_create(clu->entity.vsp1, 3, CLU_SIZE + 1,\n\t\t\t\t\t     0);\n\tif (!clu->pool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tv4l2_ctrl_handler_init(&clu->ctrls, 2);\n\tv4l2_ctrl_new_custom(&clu->ctrls, &clu_table_control, NULL);\n\tv4l2_ctrl_new_custom(&clu->ctrls, &clu_mode_control, NULL);\n\n\tclu->entity.subdev.ctrl_handler = &clu->ctrls;\n\n\tif (clu->ctrls.error) {\n\t\tdev_err(vsp1->dev, \"clu: failed to initialize controls\\n\");\n\t\tret = clu->ctrls.error;\n\t\tvsp1_entity_destroy(&clu->entity);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tv4l2_ctrl_handler_setup(&clu->ctrls);\n\n\treturn clu;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}