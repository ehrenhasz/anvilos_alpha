{
  "module_name": "vsp1_drm.c",
  "hash_id": "9a8893fa8d9fd914a12907a8642497dea73cd597d6b5096cb9f9f70e913e622d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_drm.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n\n#include <media/media-entity.h>\n#include <media/v4l2-subdev.h>\n#include <media/vsp1.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_brx.h\"\n#include \"vsp1_dl.h\"\n#include \"vsp1_drm.h\"\n#include \"vsp1_lif.h\"\n#include \"vsp1_pipe.h\"\n#include \"vsp1_rwpf.h\"\n#include \"vsp1_uif.h\"\n\n#define BRX_NAME(e)\t(e)->type == VSP1_ENTITY_BRU ? \"BRU\" : \"BRS\"\n\n \n\nstatic void vsp1_du_pipeline_frame_end(struct vsp1_pipeline *pipe,\n\t\t\t\t       unsigned int completion)\n{\n\tstruct vsp1_drm_pipeline *drm_pipe = to_vsp1_drm_pipeline(pipe);\n\n\tif (drm_pipe->du_complete) {\n\t\tstruct vsp1_entity *uif = drm_pipe->uif;\n\t\tunsigned int status = completion\n\t\t\t\t    & (VSP1_DU_STATUS_COMPLETE |\n\t\t\t\t       VSP1_DU_STATUS_WRITEBACK);\n\t\tu32 crc;\n\n\t\tcrc = uif ? vsp1_uif_get_crc(to_uif(&uif->subdev)) : 0;\n\t\tdrm_pipe->du_complete(drm_pipe->du_private, status, crc);\n\t}\n\n\tif (completion & VSP1_DL_FRAME_END_INTERNAL) {\n\t\tdrm_pipe->force_brx_release = false;\n\t\twake_up(&drm_pipe->wait_queue);\n\t}\n}\n\n \n\n \nstatic int vsp1_du_insert_uif(struct vsp1_device *vsp1,\n\t\t\t      struct vsp1_pipeline *pipe,\n\t\t\t      struct vsp1_entity *uif,\n\t\t\t      struct vsp1_entity *prev, unsigned int prev_pad,\n\t\t\t      struct vsp1_entity *next, unsigned int next_pad)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tif (!uif) {\n\t\t \n\t\tprev->sink = next;\n\t\tprev->sink_pad = next_pad;\n\t\treturn 0;\n\t}\n\n\tprev->sink = uif;\n\tprev->sink_pad = UIF_PAD_SINK;\n\n\tformat.pad = prev_pad;\n\n\tret = v4l2_subdev_call(&prev->subdev, pad, get_fmt, NULL, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tformat.pad = UIF_PAD_SINK;\n\n\tret = v4l2_subdev_call(&uif->subdev, pad, set_fmt, NULL, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(vsp1->dev, \"%s: set format %ux%u (%x) on UIF sink\\n\",\n\t\t__func__, format.format.width, format.format.height,\n\t\tformat.format.code);\n\n\t \n\n\tuif->sink = next;\n\tuif->sink_pad = next_pad;\n\n\treturn 0;\n}\n\n \nstatic int vsp1_du_pipeline_setup_rpf(struct vsp1_device *vsp1,\n\t\t\t\t      struct vsp1_pipeline *pipe,\n\t\t\t\t      struct vsp1_rwpf *rpf,\n\t\t\t\t      struct vsp1_entity *uif,\n\t\t\t\t      unsigned int brx_input)\n{\n\tstruct v4l2_subdev_selection sel = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tconst struct v4l2_rect *crop;\n\tint ret;\n\n\t \n\tcrop = &vsp1->drm->inputs[rpf->entity.index].crop;\n\n\tformat.pad = RWPF_PAD_SINK;\n\tformat.format.width = crop->width + crop->left;\n\tformat.format.height = crop->height + crop->top;\n\tformat.format.code = rpf->fmtinfo->mbus;\n\tformat.format.field = V4L2_FIELD_NONE;\n\n\tret = v4l2_subdev_call(&rpf->entity.subdev, pad, set_fmt, NULL,\n\t\t\t       &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(vsp1->dev,\n\t\t\"%s: set format %ux%u (%x) on RPF%u sink\\n\",\n\t\t__func__, format.format.width, format.format.height,\n\t\tformat.format.code, rpf->entity.index);\n\n\tsel.pad = RWPF_PAD_SINK;\n\tsel.target = V4L2_SEL_TGT_CROP;\n\tsel.r = *crop;\n\n\tret = v4l2_subdev_call(&rpf->entity.subdev, pad, set_selection, NULL,\n\t\t\t       &sel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(vsp1->dev,\n\t\t\"%s: set selection (%u,%u)/%ux%u on RPF%u sink\\n\",\n\t\t__func__, sel.r.left, sel.r.top, sel.r.width, sel.r.height,\n\t\trpf->entity.index);\n\n\t \n\tformat.pad = RWPF_PAD_SOURCE;\n\n\tret = v4l2_subdev_call(&rpf->entity.subdev, pad, get_fmt, NULL,\n\t\t\t       &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(vsp1->dev,\n\t\t\"%s: got format %ux%u (%x) on RPF%u source\\n\",\n\t\t__func__, format.format.width, format.format.height,\n\t\tformat.format.code, rpf->entity.index);\n\n\tformat.format.code = MEDIA_BUS_FMT_ARGB8888_1X32;\n\n\tret = v4l2_subdev_call(&rpf->entity.subdev, pad, set_fmt, NULL,\n\t\t\t       &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = vsp1_du_insert_uif(vsp1, pipe, uif, &rpf->entity, RWPF_PAD_SOURCE,\n\t\t\t\t pipe->brx, brx_input);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tformat.pad = brx_input;\n\n\tret = v4l2_subdev_call(&pipe->brx->subdev, pad, set_fmt, NULL,\n\t\t\t       &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(vsp1->dev, \"%s: set format %ux%u (%x) on %s pad %u\\n\",\n\t\t__func__, format.format.width, format.format.height,\n\t\tformat.format.code, BRX_NAME(pipe->brx), format.pad);\n\n\tsel.pad = brx_input;\n\tsel.target = V4L2_SEL_TGT_COMPOSE;\n\tsel.r = vsp1->drm->inputs[rpf->entity.index].compose;\n\n\tret = v4l2_subdev_call(&pipe->brx->subdev, pad, set_selection, NULL,\n\t\t\t       &sel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(vsp1->dev, \"%s: set selection (%u,%u)/%ux%u on %s pad %u\\n\",\n\t\t__func__, sel.r.left, sel.r.top, sel.r.width, sel.r.height,\n\t\tBRX_NAME(pipe->brx), sel.pad);\n\n\treturn 0;\n}\n\n \nstatic int vsp1_du_pipeline_setup_inputs(struct vsp1_device *vsp1,\n\t\t\t\t\t struct vsp1_pipeline *pipe);\nstatic void vsp1_du_pipeline_configure(struct vsp1_pipeline *pipe);\n\nstatic int vsp1_du_pipeline_setup_brx(struct vsp1_device *vsp1,\n\t\t\t\t      struct vsp1_pipeline *pipe)\n{\n\tstruct vsp1_drm_pipeline *drm_pipe = to_vsp1_drm_pipeline(pipe);\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct vsp1_entity *brx;\n\tint ret;\n\n\t \n\tif (pipe->num_inputs > 2)\n\t\tbrx = &vsp1->bru->entity;\n\telse if (pipe->brx && !drm_pipe->force_brx_release)\n\t\tbrx = pipe->brx;\n\telse if (vsp1_feature(vsp1, VSP1_HAS_BRU) && !vsp1->bru->entity.pipe)\n\t\tbrx = &vsp1->bru->entity;\n\telse\n\t\tbrx = &vsp1->brs->entity;\n\n\t \n\tif (brx != pipe->brx) {\n\t\tstruct vsp1_entity *released_brx = NULL;\n\n\t\t \n\t\tif (pipe->brx) {\n\t\t\tdev_dbg(vsp1->dev, \"%s: pipe %u: releasing %s\\n\",\n\t\t\t\t__func__, pipe->lif->index,\n\t\t\t\tBRX_NAME(pipe->brx));\n\n\t\t\t \n\t\t\treleased_brx = pipe->brx;\n\n\t\t\tlist_del(&pipe->brx->list_pipe);\n\t\t\tpipe->brx->sink = NULL;\n\t\t\tpipe->brx->pipe = NULL;\n\t\t\tpipe->brx = NULL;\n\t\t}\n\n\t\t \n\t\tif (brx->pipe) {\n\t\t\tstruct vsp1_drm_pipeline *owner_pipe;\n\n\t\t\tdev_dbg(vsp1->dev, \"%s: pipe %u: waiting for %s\\n\",\n\t\t\t\t__func__, pipe->lif->index, BRX_NAME(brx));\n\n\t\t\towner_pipe = to_vsp1_drm_pipeline(brx->pipe);\n\t\t\towner_pipe->force_brx_release = true;\n\n\t\t\tvsp1_du_pipeline_setup_inputs(vsp1, &owner_pipe->pipe);\n\t\t\tvsp1_du_pipeline_configure(&owner_pipe->pipe);\n\n\t\t\tret = wait_event_timeout(owner_pipe->wait_queue,\n\t\t\t\t\t\t !owner_pipe->force_brx_release,\n\t\t\t\t\t\t msecs_to_jiffies(500));\n\t\t\tif (ret == 0)\n\t\t\t\tdev_warn(vsp1->dev,\n\t\t\t\t\t \"DRM pipeline %u reconfiguration timeout\\n\",\n\t\t\t\t\t owner_pipe->pipe.lif->index);\n\t\t}\n\n\t\t \n\t\tif (released_brx && !released_brx->pipe)\n\t\t\tlist_add_tail(&released_brx->list_pipe,\n\t\t\t\t      &pipe->entities);\n\n\t\t \n\t\tdev_dbg(vsp1->dev, \"%s: pipe %u: acquired %s\\n\",\n\t\t\t__func__, pipe->lif->index, BRX_NAME(brx));\n\n\t\tpipe->brx = brx;\n\t\tpipe->brx->pipe = pipe;\n\t\tpipe->brx->sink = &pipe->output->entity;\n\t\tpipe->brx->sink_pad = 0;\n\n\t\tlist_add_tail(&pipe->brx->list_pipe, &pipe->entities);\n\t}\n\n\t \n\tformat.pad = brx->source_pad;\n\tformat.format.width = drm_pipe->width;\n\tformat.format.height = drm_pipe->height;\n\tformat.format.field = V4L2_FIELD_NONE;\n\n\tret = v4l2_subdev_call(&brx->subdev, pad, set_fmt, NULL,\n\t\t\t       &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(vsp1->dev, \"%s: set format %ux%u (%x) on %s pad %u\\n\",\n\t\t__func__, format.format.width, format.format.height,\n\t\tformat.format.code, BRX_NAME(brx), brx->source_pad);\n\n\tif (format.format.width != drm_pipe->width ||\n\t    format.format.height != drm_pipe->height) {\n\t\tdev_dbg(vsp1->dev, \"%s: format mismatch\\n\", __func__);\n\t\treturn -EPIPE;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int rpf_zpos(struct vsp1_device *vsp1, struct vsp1_rwpf *rpf)\n{\n\treturn vsp1->drm->inputs[rpf->entity.index].zpos;\n}\n\n \nstatic int vsp1_du_pipeline_setup_inputs(struct vsp1_device *vsp1,\n\t\t\t\t\tstruct vsp1_pipeline *pipe)\n{\n\tstruct vsp1_drm_pipeline *drm_pipe = to_vsp1_drm_pipeline(pipe);\n\tstruct vsp1_rwpf *inputs[VSP1_MAX_RPF] = { NULL, };\n\tstruct vsp1_entity *uif;\n\tbool use_uif = false;\n\tstruct vsp1_brx *brx;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tpipe->num_inputs = 0;\n\n\tfor (i = 0; i < vsp1->info->rpf_count; ++i) {\n\t\tstruct vsp1_rwpf *rpf = vsp1->rpf[i];\n\t\tunsigned int j;\n\n\t\tif (!pipe->inputs[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (j = pipe->num_inputs++; j > 0; --j) {\n\t\t\tif (rpf_zpos(vsp1, inputs[j-1]) <= rpf_zpos(vsp1, rpf))\n\t\t\t\tbreak;\n\t\t\tinputs[j] = inputs[j-1];\n\t\t}\n\n\t\tinputs[j] = rpf;\n\t}\n\n\t \n\tret = vsp1_du_pipeline_setup_brx(vsp1, pipe);\n\tif (ret < 0) {\n\t\tdev_err(vsp1->dev, \"%s: failed to setup %s source\\n\", __func__,\n\t\t\tBRX_NAME(pipe->brx));\n\t\treturn ret;\n\t}\n\n\tbrx = to_brx(&pipe->brx->subdev);\n\n\t \n\tfor (i = 0; i < pipe->brx->source_pad; ++i) {\n\t\tstruct vsp1_rwpf *rpf = inputs[i];\n\n\t\tif (!rpf) {\n\t\t\tbrx->inputs[i].rpf = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rpf->entity.pipe) {\n\t\t\trpf->entity.pipe = pipe;\n\t\t\tlist_add_tail(&rpf->entity.list_pipe, &pipe->entities);\n\t\t}\n\n\t\tbrx->inputs[i].rpf = rpf;\n\t\trpf->brx_input = i;\n\t\trpf->entity.sink = pipe->brx;\n\t\trpf->entity.sink_pad = i;\n\n\t\tdev_dbg(vsp1->dev, \"%s: connecting RPF.%u to %s:%u\\n\",\n\t\t\t__func__, rpf->entity.index, BRX_NAME(pipe->brx), i);\n\n\t\tuif = drm_pipe->crc.source == VSP1_DU_CRC_PLANE &&\n\t\t      drm_pipe->crc.index == i ? drm_pipe->uif : NULL;\n\t\tif (uif)\n\t\t\tuse_uif = true;\n\t\tret = vsp1_du_pipeline_setup_rpf(vsp1, pipe, rpf, uif, i);\n\t\tif (ret < 0) {\n\t\t\tdev_err(vsp1->dev,\n\t\t\t\t\"%s: failed to setup RPF.%u\\n\",\n\t\t\t\t__func__, rpf->entity.index);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tuif = drm_pipe->crc.source == VSP1_DU_CRC_OUTPUT ? drm_pipe->uif : NULL;\n\tif (uif)\n\t\tuse_uif = true;\n\tret = vsp1_du_insert_uif(vsp1, pipe, uif,\n\t\t\t\t pipe->brx, pipe->brx->source_pad,\n\t\t\t\t &pipe->output->entity, 0);\n\tif (ret < 0)\n\t\tdev_err(vsp1->dev, \"%s: failed to setup UIF after %s\\n\",\n\t\t\t__func__, BRX_NAME(pipe->brx));\n\n\t \n\tif (!drm_pipe->uif)\n\t\treturn 0;\n\n\t \n\tif (!use_uif) {\n\t\tdrm_pipe->uif->pipe = NULL;\n\t} else if (!drm_pipe->uif->pipe) {\n\t\tdrm_pipe->uif->pipe = pipe;\n\t\tlist_add_tail(&drm_pipe->uif->list_pipe, &pipe->entities);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vsp1_du_pipeline_setup_output(struct vsp1_device *vsp1,\n\t\t\t\t\t struct vsp1_pipeline *pipe)\n{\n\tstruct vsp1_drm_pipeline *drm_pipe = to_vsp1_drm_pipeline(pipe);\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tformat.pad = RWPF_PAD_SINK;\n\tformat.format.width = drm_pipe->width;\n\tformat.format.height = drm_pipe->height;\n\tformat.format.code = MEDIA_BUS_FMT_ARGB8888_1X32;\n\tformat.format.field = V4L2_FIELD_NONE;\n\n\tret = v4l2_subdev_call(&pipe->output->entity.subdev, pad, set_fmt, NULL,\n\t\t\t       &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(vsp1->dev, \"%s: set format %ux%u (%x) on WPF%u sink\\n\",\n\t\t__func__, format.format.width, format.format.height,\n\t\tformat.format.code, pipe->output->entity.index);\n\n\tformat.pad = RWPF_PAD_SOURCE;\n\tret = v4l2_subdev_call(&pipe->output->entity.subdev, pad, get_fmt, NULL,\n\t\t\t       &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(vsp1->dev, \"%s: got format %ux%u (%x) on WPF%u source\\n\",\n\t\t__func__, format.format.width, format.format.height,\n\t\tformat.format.code, pipe->output->entity.index);\n\n\tformat.pad = LIF_PAD_SINK;\n\tret = v4l2_subdev_call(&pipe->lif->subdev, pad, set_fmt, NULL,\n\t\t\t       &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(vsp1->dev, \"%s: set format %ux%u (%x) on LIF%u sink\\n\",\n\t\t__func__, format.format.width, format.format.height,\n\t\tformat.format.code, pipe->lif->index);\n\n\t \n\tif (format.format.width != drm_pipe->width ||\n\t    format.format.height != drm_pipe->height ||\n\t    format.format.code != MEDIA_BUS_FMT_ARGB8888_1X32) {\n\t\tdev_dbg(vsp1->dev, \"%s: format mismatch on LIF%u\\n\", __func__,\n\t\t\tpipe->lif->index);\n\t\treturn -EPIPE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void vsp1_du_pipeline_configure(struct vsp1_pipeline *pipe)\n{\n\tstruct vsp1_drm_pipeline *drm_pipe = to_vsp1_drm_pipeline(pipe);\n\tstruct vsp1_entity *entity;\n\tstruct vsp1_entity *next;\n\tstruct vsp1_dl_list *dl;\n\tstruct vsp1_dl_body *dlb;\n\tunsigned int dl_flags = 0;\n\n\tif (drm_pipe->force_brx_release)\n\t\tdl_flags |= VSP1_DL_FRAME_END_INTERNAL;\n\tif (pipe->output->writeback)\n\t\tdl_flags |= VSP1_DL_FRAME_END_WRITEBACK;\n\n\tdl = vsp1_dl_list_get(pipe->output->dlm);\n\tdlb = vsp1_dl_list_get_body0(dl);\n\n\tlist_for_each_entry_safe(entity, next, &pipe->entities, list_pipe) {\n\t\t \n\t\tif (!entity->pipe) {\n\t\t\tvsp1_dl_body_write(dlb, entity->route->reg,\n\t\t\t\t\t   VI6_DPR_NODE_UNUSED);\n\n\t\t\tentity->sink = NULL;\n\t\t\tlist_del(&entity->list_pipe);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tvsp1_entity_route_setup(entity, pipe, dlb);\n\t\tvsp1_entity_configure_stream(entity, pipe, dl, dlb);\n\t\tvsp1_entity_configure_frame(entity, pipe, dl, dlb);\n\t\tvsp1_entity_configure_partition(entity, pipe, dl, dlb);\n\t}\n\n\tvsp1_dl_list_commit(dl, dl_flags);\n}\n\nstatic int vsp1_du_pipeline_set_rwpf_format(struct vsp1_device *vsp1,\n\t\t\t\t\t    struct vsp1_rwpf *rwpf,\n\t\t\t\t\t    u32 pixelformat, unsigned int pitch)\n{\n\tconst struct vsp1_format_info *fmtinfo;\n\tunsigned int chroma_hsub;\n\n\tfmtinfo = vsp1_get_format_info(vsp1, pixelformat);\n\tif (!fmtinfo) {\n\t\tdev_dbg(vsp1->dev, \"Unsupported pixel format %08x\\n\",\n\t\t\tpixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tchroma_hsub = (fmtinfo->planes == 3) ? fmtinfo->hsub : 1;\n\n\trwpf->fmtinfo = fmtinfo;\n\trwpf->format.num_planes = fmtinfo->planes;\n\trwpf->format.plane_fmt[0].bytesperline = pitch;\n\trwpf->format.plane_fmt[1].bytesperline = pitch / chroma_hsub;\n\n\treturn 0;\n}\n\n \n\nint vsp1_du_init(struct device *dev)\n{\n\tstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\n\n\tif (!vsp1)\n\t\treturn -EPROBE_DEFER;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vsp1_du_init);\n\n \nint vsp1_du_setup_lif(struct device *dev, unsigned int pipe_index,\n\t\t      const struct vsp1_du_lif_config *cfg)\n{\n\tstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\n\tstruct vsp1_drm_pipeline *drm_pipe;\n\tstruct vsp1_pipeline *pipe;\n\tunsigned long flags;\n\tunsigned int i;\n\tint ret;\n\n\tif (pipe_index >= vsp1->info->lif_count)\n\t\treturn -EINVAL;\n\n\tdrm_pipe = &vsp1->drm->pipe[pipe_index];\n\tpipe = &drm_pipe->pipe;\n\n\tif (!cfg) {\n\t\tstruct vsp1_brx *brx;\n\n\t\tmutex_lock(&vsp1->drm->lock);\n\n\t\tbrx = to_brx(&pipe->brx->subdev);\n\n\t\t \n\t\tret = vsp1_pipeline_stop(pipe);\n\t\tif (ret == -ETIMEDOUT)\n\t\t\tdev_err(vsp1->dev, \"DRM pipeline stop timeout\\n\");\n\n\t\tfor (i = 0; i < ARRAY_SIZE(pipe->inputs); ++i) {\n\t\t\tstruct vsp1_rwpf *rpf = pipe->inputs[i];\n\n\t\t\tif (!rpf)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tWARN_ON(!rpf->entity.pipe);\n\t\t\trpf->entity.pipe = NULL;\n\t\t\tlist_del(&rpf->entity.list_pipe);\n\t\t\tpipe->inputs[i] = NULL;\n\n\t\t\tbrx->inputs[rpf->brx_input].rpf = NULL;\n\t\t}\n\n\t\tdrm_pipe->du_complete = NULL;\n\t\tpipe->num_inputs = 0;\n\n\t\tdev_dbg(vsp1->dev, \"%s: pipe %u: releasing %s\\n\",\n\t\t\t__func__, pipe->lif->index,\n\t\t\tBRX_NAME(pipe->brx));\n\n\t\tlist_del(&pipe->brx->list_pipe);\n\t\tpipe->brx->pipe = NULL;\n\t\tpipe->brx = NULL;\n\n\t\tmutex_unlock(&vsp1->drm->lock);\n\n\t\tvsp1_dlm_reset(pipe->output->dlm);\n\t\tvsp1_device_put(vsp1);\n\n\t\tdev_dbg(vsp1->dev, \"%s: pipeline disabled\\n\", __func__);\n\n\t\treturn 0;\n\t}\n\n\t \n\tpipe->underrun_count = 0;\n\n\tdrm_pipe->width = cfg->width;\n\tdrm_pipe->height = cfg->height;\n\tpipe->interlaced = cfg->interlaced;\n\n\tdev_dbg(vsp1->dev, \"%s: configuring LIF%u with format %ux%u%s\\n\",\n\t\t__func__, pipe_index, cfg->width, cfg->height,\n\t\tpipe->interlaced ? \"i\" : \"\");\n\n\tmutex_lock(&vsp1->drm->lock);\n\n\t \n\tret = vsp1_du_pipeline_setup_inputs(vsp1, pipe);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = vsp1_du_pipeline_setup_output(vsp1, pipe);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t \n\tret = vsp1_device_get(vsp1);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\t \n\tdrm_pipe->du_complete = cfg->callback;\n\tdrm_pipe->du_private = cfg->callback_data;\n\n\t \n\tvsp1_write(vsp1, VI6_DISP_IRQ_STA(pipe_index), 0);\n\tvsp1_write(vsp1, VI6_DISP_IRQ_ENB(pipe_index), 0);\n\n\t \n\tvsp1_du_pipeline_configure(pipe);\n\nunlock:\n\tmutex_unlock(&vsp1->drm->lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tspin_lock_irqsave(&pipe->irqlock, flags);\n\tvsp1_pipeline_run(pipe);\n\tspin_unlock_irqrestore(&pipe->irqlock, flags);\n\n\tdev_dbg(vsp1->dev, \"%s: pipeline enabled\\n\", __func__);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vsp1_du_setup_lif);\n\n \nvoid vsp1_du_atomic_begin(struct device *dev, unsigned int pipe_index)\n{\n}\nEXPORT_SYMBOL_GPL(vsp1_du_atomic_begin);\n\n \nint vsp1_du_atomic_update(struct device *dev, unsigned int pipe_index,\n\t\t\t  unsigned int rpf_index,\n\t\t\t  const struct vsp1_du_atomic_config *cfg)\n{\n\tstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\n\tstruct vsp1_drm_pipeline *drm_pipe = &vsp1->drm->pipe[pipe_index];\n\tstruct vsp1_rwpf *rpf;\n\tint ret;\n\n\tif (rpf_index >= vsp1->info->rpf_count)\n\t\treturn -EINVAL;\n\n\trpf = vsp1->rpf[rpf_index];\n\n\tif (!cfg) {\n\t\tdev_dbg(vsp1->dev, \"%s: RPF%u: disable requested\\n\", __func__,\n\t\t\trpf_index);\n\n\t\t \n\t\trpf->entity.pipe = NULL;\n\t\tdrm_pipe->pipe.inputs[rpf_index] = NULL;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(vsp1->dev,\n\t\t\"%s: RPF%u: (%u,%u)/%ux%u -> (%u,%u)/%ux%u (%08x), pitch %u dma { %pad, %pad, %pad } zpos %u\\n\",\n\t\t__func__, rpf_index,\n\t\tcfg->src.left, cfg->src.top, cfg->src.width, cfg->src.height,\n\t\tcfg->dst.left, cfg->dst.top, cfg->dst.width, cfg->dst.height,\n\t\tcfg->pixelformat, cfg->pitch, &cfg->mem[0], &cfg->mem[1],\n\t\t&cfg->mem[2], cfg->zpos);\n\n\t \n\tret = vsp1_du_pipeline_set_rwpf_format(vsp1, rpf, cfg->pixelformat,\n\t\t\t\t\t       cfg->pitch);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trpf->alpha = cfg->alpha;\n\n\trpf->mem.addr[0] = cfg->mem[0];\n\trpf->mem.addr[1] = cfg->mem[1];\n\trpf->mem.addr[2] = cfg->mem[2];\n\n\trpf->format.flags = cfg->premult ? V4L2_PIX_FMT_FLAG_PREMUL_ALPHA : 0;\n\n\tvsp1->drm->inputs[rpf_index].crop = cfg->src;\n\tvsp1->drm->inputs[rpf_index].compose = cfg->dst;\n\tvsp1->drm->inputs[rpf_index].zpos = cfg->zpos;\n\n\tdrm_pipe->pipe.inputs[rpf_index] = rpf;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vsp1_du_atomic_update);\n\n \nvoid vsp1_du_atomic_flush(struct device *dev, unsigned int pipe_index,\n\t\t\t  const struct vsp1_du_atomic_pipe_config *cfg)\n{\n\tstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\n\tstruct vsp1_drm_pipeline *drm_pipe = &vsp1->drm->pipe[pipe_index];\n\tstruct vsp1_pipeline *pipe = &drm_pipe->pipe;\n\tint ret;\n\n\tdrm_pipe->crc = cfg->crc;\n\n\tmutex_lock(&vsp1->drm->lock);\n\n\tif (cfg->writeback.pixelformat) {\n\t\tconst struct vsp1_du_writeback_config *wb_cfg = &cfg->writeback;\n\n\t\tret = vsp1_du_pipeline_set_rwpf_format(vsp1, pipe->output,\n\t\t\t\t\t\t       wb_cfg->pixelformat,\n\t\t\t\t\t\t       wb_cfg->pitch);\n\t\tif (WARN_ON(ret < 0))\n\t\t\tgoto done;\n\n\t\tpipe->output->mem.addr[0] = wb_cfg->mem[0];\n\t\tpipe->output->mem.addr[1] = wb_cfg->mem[1];\n\t\tpipe->output->mem.addr[2] = wb_cfg->mem[2];\n\t\tpipe->output->writeback = true;\n\t}\n\n\tvsp1_du_pipeline_setup_inputs(vsp1, pipe);\n\tvsp1_du_pipeline_configure(pipe);\n\ndone:\n\tmutex_unlock(&vsp1->drm->lock);\n}\nEXPORT_SYMBOL_GPL(vsp1_du_atomic_flush);\n\nint vsp1_du_map_sg(struct device *dev, struct sg_table *sgt)\n{\n\tstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\n\n\t \n\treturn dma_map_sgtable(vsp1->bus_master, sgt, DMA_TO_DEVICE,\n\t\t\t       DMA_ATTR_SKIP_CPU_SYNC);\n}\nEXPORT_SYMBOL_GPL(vsp1_du_map_sg);\n\nvoid vsp1_du_unmap_sg(struct device *dev, struct sg_table *sgt)\n{\n\tstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\n\n\tdma_unmap_sgtable(vsp1->bus_master, sgt, DMA_TO_DEVICE,\n\t\t\t  DMA_ATTR_SKIP_CPU_SYNC);\n}\nEXPORT_SYMBOL_GPL(vsp1_du_unmap_sg);\n\n \n\nint vsp1_drm_init(struct vsp1_device *vsp1)\n{\n\tunsigned int i;\n\n\tvsp1->drm = devm_kzalloc(vsp1->dev, sizeof(*vsp1->drm), GFP_KERNEL);\n\tif (!vsp1->drm)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&vsp1->drm->lock);\n\n\t \n\tfor (i = 0; i < vsp1->info->lif_count; ++i) {\n\t\tstruct vsp1_drm_pipeline *drm_pipe = &vsp1->drm->pipe[i];\n\t\tstruct vsp1_pipeline *pipe = &drm_pipe->pipe;\n\n\t\tinit_waitqueue_head(&drm_pipe->wait_queue);\n\n\t\tvsp1_pipeline_init(pipe);\n\n\t\tpipe->frame_end = vsp1_du_pipeline_frame_end;\n\n\t\t \n\t\tpipe->output = vsp1->wpf[i];\n\t\tpipe->lif = &vsp1->lif[i]->entity;\n\n\t\tpipe->output->entity.pipe = pipe;\n\t\tpipe->output->entity.sink = pipe->lif;\n\t\tpipe->output->entity.sink_pad = 0;\n\t\tlist_add_tail(&pipe->output->entity.list_pipe, &pipe->entities);\n\n\t\tpipe->lif->pipe = pipe;\n\t\tlist_add_tail(&pipe->lif->list_pipe, &pipe->entities);\n\n\t\t \n\t\tif (i < vsp1->info->uif_count)\n\t\t\tdrm_pipe->uif = &vsp1->uif[i]->entity;\n\t}\n\n\t \n\tfor (i = 0; i < vsp1->info->rpf_count; ++i) {\n\t\tstruct vsp1_rwpf *input = vsp1->rpf[i];\n\n\t\tINIT_LIST_HEAD(&input->entity.list_pipe);\n\t}\n\n\treturn 0;\n}\n\nvoid vsp1_drm_cleanup(struct vsp1_device *vsp1)\n{\n\tmutex_destroy(&vsp1->drm->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}