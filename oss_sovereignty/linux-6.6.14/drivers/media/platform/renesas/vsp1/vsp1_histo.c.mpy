{
  "module_name": "vsp1_histo.c",
  "hash_id": "c46f9ed3edb41a52223488dc55e27e5f854aa54d2e91ad9fc005206de2296d56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_histo.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gfp.h>\n\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_histo.h\"\n#include \"vsp1_pipe.h\"\n\n#define HISTO_MIN_SIZE\t\t\t\t4U\n#define HISTO_MAX_SIZE\t\t\t\t8192U\n\n \n\nstatic inline struct vsp1_histogram_buffer *\nto_vsp1_histogram_buffer(struct vb2_v4l2_buffer *vbuf)\n{\n\treturn container_of(vbuf, struct vsp1_histogram_buffer, buf);\n}\n\nstruct vsp1_histogram_buffer *\nvsp1_histogram_buffer_get(struct vsp1_histogram *histo)\n{\n\tstruct vsp1_histogram_buffer *buf = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&histo->irqlock, flags);\n\n\tif (list_empty(&histo->irqqueue))\n\t\tgoto done;\n\n\tbuf = list_first_entry(&histo->irqqueue, struct vsp1_histogram_buffer,\n\t\t\t       queue);\n\tlist_del(&buf->queue);\n\thisto->readout = true;\n\ndone:\n\tspin_unlock_irqrestore(&histo->irqlock, flags);\n\treturn buf;\n}\n\nvoid vsp1_histogram_buffer_complete(struct vsp1_histogram *histo,\n\t\t\t\t    struct vsp1_histogram_buffer *buf,\n\t\t\t\t    size_t size)\n{\n\tstruct vsp1_pipeline *pipe = histo->entity.pipe;\n\tunsigned long flags;\n\n\t \n\tbuf->buf.sequence = pipe->sequence;\n\tbuf->buf.vb2_buf.timestamp = ktime_get_ns();\n\tvb2_set_plane_payload(&buf->buf.vb2_buf, 0, size);\n\tvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_DONE);\n\n\tspin_lock_irqsave(&histo->irqlock, flags);\n\thisto->readout = false;\n\twake_up(&histo->wait_queue);\n\tspin_unlock_irqrestore(&histo->irqlock, flags);\n}\n\n \n\nstatic int histo_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\n\t\t\t     unsigned int *nplanes, unsigned int sizes[],\n\t\t\t     struct device *alloc_devs[])\n{\n\tstruct vsp1_histogram *histo = vb2_get_drv_priv(vq);\n\n\tif (*nplanes) {\n\t\tif (*nplanes != 1)\n\t\t\treturn -EINVAL;\n\n\t\tif (sizes[0] < histo->data_size)\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\t*nplanes = 1;\n\tsizes[0] = histo->data_size;\n\n\treturn 0;\n}\n\nstatic int histo_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vsp1_histogram *histo = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vsp1_histogram_buffer *buf = to_vsp1_histogram_buffer(vbuf);\n\n\tif (vb->num_planes != 1)\n\t\treturn -EINVAL;\n\n\tif (vb2_plane_size(vb, 0) < histo->data_size)\n\t\treturn -EINVAL;\n\n\tbuf->addr = vb2_plane_vaddr(vb, 0);\n\n\treturn 0;\n}\n\nstatic void histo_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vsp1_histogram *histo = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vsp1_histogram_buffer *buf = to_vsp1_histogram_buffer(vbuf);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&histo->irqlock, flags);\n\tlist_add_tail(&buf->queue, &histo->irqqueue);\n\tspin_unlock_irqrestore(&histo->irqlock, flags);\n}\n\nstatic int histo_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\treturn 0;\n}\n\nstatic void histo_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct vsp1_histogram *histo = vb2_get_drv_priv(vq);\n\tstruct vsp1_histogram_buffer *buffer;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&histo->irqlock, flags);\n\n\t \n\tlist_for_each_entry(buffer, &histo->irqqueue, queue)\n\t\tvb2_buffer_done(&buffer->buf.vb2_buf, VB2_BUF_STATE_ERROR);\n\tINIT_LIST_HEAD(&histo->irqqueue);\n\n\t \n\twait_event_lock_irq(histo->wait_queue, !histo->readout, histo->irqlock);\n\n\tspin_unlock_irqrestore(&histo->irqlock, flags);\n}\n\nstatic const struct vb2_ops histo_video_queue_qops = {\n\t.queue_setup = histo_queue_setup,\n\t.buf_prepare = histo_buffer_prepare,\n\t.buf_queue = histo_buffer_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = histo_start_streaming,\n\t.stop_streaming = histo_stop_streaming,\n};\n\n \n\nstatic int histo_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct vsp1_histogram *histo = subdev_to_histo(subdev);\n\n\tif (code->pad == HISTO_PAD_SOURCE) {\n\t\tcode->code = MEDIA_BUS_FMT_FIXED;\n\t\treturn 0;\n\t}\n\n\treturn vsp1_subdev_enum_mbus_code(subdev, sd_state, code,\n\t\t\t\t\t  histo->formats,\n\t\t\t\t\t  histo->num_formats);\n}\n\nstatic int histo_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->pad != HISTO_PAD_SINK)\n\t\treturn -EINVAL;\n\n\treturn vsp1_subdev_enum_frame_size(subdev, sd_state, fse,\n\t\t\t\t\t   HISTO_MIN_SIZE,\n\t\t\t\t\t   HISTO_MIN_SIZE, HISTO_MAX_SIZE,\n\t\t\t\t\t   HISTO_MAX_SIZE);\n}\n\nstatic int histo_get_selection(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_selection *sel)\n{\n\tstruct vsp1_histogram *histo = subdev_to_histo(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *crop;\n\tint ret = 0;\n\n\tif (sel->pad != HISTO_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&histo->entity.lock);\n\n\tconfig = vsp1_entity_get_pad_config(&histo->entity, sd_state,\n\t\t\t\t\t    sel->which);\n\tif (!config) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\tcrop = vsp1_entity_get_pad_selection(&histo->entity, config,\n\t\t\t\t\t\t     HISTO_PAD_SINK,\n\t\t\t\t\t\t     V4L2_SEL_TGT_CROP);\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = crop->width;\n\t\tsel->r.height = crop->height;\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tformat = vsp1_entity_get_pad_format(&histo->entity, config,\n\t\t\t\t\t\t    HISTO_PAD_SINK);\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = format->width;\n\t\tsel->r.height = format->height;\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *vsp1_entity_get_pad_selection(&histo->entity, config,\n\t\t\t\t\t\t\tsel->pad, sel->target);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\ndone:\n\tmutex_unlock(&histo->entity.lock);\n\treturn ret;\n}\n\nstatic int histo_set_crop(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_selection *sel)\n{\n\tstruct vsp1_histogram *histo = subdev_to_histo(subdev);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *selection;\n\n\t \n\tformat = vsp1_entity_get_pad_format(&histo->entity, sd_state,\n\t\t\t\t\t    HISTO_PAD_SINK);\n\tsel->r.left = clamp_t(unsigned int, sel->r.left, 0, format->width - 1);\n\tsel->r.top = clamp_t(unsigned int, sel->r.top, 0, format->height - 1);\n\tsel->r.width = clamp_t(unsigned int, sel->r.width, HISTO_MIN_SIZE,\n\t\t\t       format->width - sel->r.left);\n\tsel->r.height = clamp_t(unsigned int, sel->r.height, HISTO_MIN_SIZE,\n\t\t\t\tformat->height - sel->r.top);\n\n\t \n\tselection = vsp1_entity_get_pad_selection(&histo->entity, sd_state,\n\t\t\t\t\t\t  sel->pad, V4L2_SEL_TGT_CROP);\n\t*selection = sel->r;\n\n\tselection = vsp1_entity_get_pad_selection(&histo->entity, sd_state,\n\t\t\t\t\t\t  sel->pad,\n\t\t\t\t\t\t  V4L2_SEL_TGT_COMPOSE);\n\t*selection = sel->r;\n\n\treturn 0;\n}\n\nstatic int histo_set_compose(struct v4l2_subdev *subdev,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct vsp1_histogram *histo = subdev_to_histo(subdev);\n\tstruct v4l2_rect *compose;\n\tstruct v4l2_rect *crop;\n\tunsigned int ratio;\n\n\t \n\tsel->r.left = 0;\n\tsel->r.top = 0;\n\n\tcrop = vsp1_entity_get_pad_selection(&histo->entity, sd_state,\n\t\t\t\t\t     sel->pad,\n\t\t\t\t\t     V4L2_SEL_TGT_CROP);\n\n\t \n\tsel->r.width = clamp(sel->r.width, crop->width / 4, crop->width);\n\tratio = 1 << (crop->width * 2 / sel->r.width / 3);\n\tsel->r.width = crop->width / ratio;\n\n\n\tsel->r.height = clamp(sel->r.height, crop->height / 4, crop->height);\n\tratio = 1 << (crop->height * 2 / sel->r.height / 3);\n\tsel->r.height = crop->height / ratio;\n\n\tcompose = vsp1_entity_get_pad_selection(&histo->entity, sd_state,\n\t\t\t\t\t\tsel->pad,\n\t\t\t\t\t\tV4L2_SEL_TGT_COMPOSE);\n\t*compose = sel->r;\n\n\treturn 0;\n}\n\nstatic int histo_set_selection(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_selection *sel)\n{\n\tstruct vsp1_histogram *histo = subdev_to_histo(subdev);\n\tstruct v4l2_subdev_state *config;\n\tint ret;\n\n\tif (sel->pad != HISTO_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&histo->entity.lock);\n\n\tconfig = vsp1_entity_get_pad_config(&histo->entity, sd_state,\n\t\t\t\t\t    sel->which);\n\tif (!config) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (sel->target == V4L2_SEL_TGT_CROP)\n\t\tret = histo_set_crop(subdev, config, sel);\n\telse if (sel->target == V4L2_SEL_TGT_COMPOSE)\n\t\tret = histo_set_compose(subdev, config, sel);\n\telse\n\t\tret = -EINVAL;\n\ndone:\n\tmutex_unlock(&histo->entity.lock);\n\treturn ret;\n}\n\nstatic int histo_get_format(struct v4l2_subdev *subdev,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tif (fmt->pad == HISTO_PAD_SOURCE) {\n\t\tfmt->format.code = MEDIA_BUS_FMT_FIXED;\n\t\tfmt->format.width = 0;\n\t\tfmt->format.height = 0;\n\t\tfmt->format.field = V4L2_FIELD_NONE;\n\t\tfmt->format.colorspace = V4L2_COLORSPACE_RAW;\n\t\treturn 0;\n\t}\n\n\treturn vsp1_subdev_get_pad_format(subdev, sd_state, fmt);\n}\n\nstatic int histo_set_format(struct v4l2_subdev *subdev,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct vsp1_histogram *histo = subdev_to_histo(subdev);\n\n\tif (fmt->pad != HISTO_PAD_SINK)\n\t\treturn histo_get_format(subdev, sd_state, fmt);\n\n\treturn vsp1_subdev_set_pad_format(subdev, sd_state, fmt,\n\t\t\t\t\t  histo->formats, histo->num_formats,\n\t\t\t\t\t  HISTO_MIN_SIZE, HISTO_MIN_SIZE,\n\t\t\t\t\t  HISTO_MAX_SIZE, HISTO_MAX_SIZE);\n}\n\nstatic const struct v4l2_subdev_pad_ops histo_pad_ops = {\n\t.enum_mbus_code = histo_enum_mbus_code,\n\t.enum_frame_size = histo_enum_frame_size,\n\t.get_fmt = histo_get_format,\n\t.set_fmt = histo_set_format,\n\t.get_selection = histo_get_selection,\n\t.set_selection = histo_set_selection,\n};\n\nstatic const struct v4l2_subdev_ops histo_ops = {\n\t.pad    = &histo_pad_ops,\n};\n\n \n\nstatic int histo_v4l2_querycap(struct file *file, void *fh,\n\t\t\t       struct v4l2_capability *cap)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct vsp1_histogram *histo = vdev_to_histo(vfh->vdev);\n\n\tcap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_STREAMING\n\t\t\t  | V4L2_CAP_VIDEO_CAPTURE_MPLANE\n\t\t\t  | V4L2_CAP_VIDEO_OUTPUT_MPLANE\n\t\t\t  | V4L2_CAP_META_CAPTURE;\n\n\tstrscpy(cap->driver, \"vsp1\", sizeof(cap->driver));\n\tstrscpy(cap->card, histo->video.name, sizeof(cap->card));\n\n\treturn 0;\n}\n\nstatic int histo_v4l2_enum_format(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_fmtdesc *f)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct vsp1_histogram *histo = vdev_to_histo(vfh->vdev);\n\n\tif (f->index > 0 || f->type != histo->queue.type)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = histo->meta_format;\n\n\treturn 0;\n}\n\nstatic int histo_v4l2_get_format(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *format)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct vsp1_histogram *histo = vdev_to_histo(vfh->vdev);\n\tstruct v4l2_meta_format *meta = &format->fmt.meta;\n\n\tif (format->type != histo->queue.type)\n\t\treturn -EINVAL;\n\n\tmemset(meta, 0, sizeof(*meta));\n\n\tmeta->dataformat = histo->meta_format;\n\tmeta->buffersize = histo->data_size;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops histo_v4l2_ioctl_ops = {\n\t.vidioc_querycap\t\t= histo_v4l2_querycap,\n\t.vidioc_enum_fmt_meta_cap\t= histo_v4l2_enum_format,\n\t.vidioc_g_fmt_meta_cap\t\t= histo_v4l2_get_format,\n\t.vidioc_s_fmt_meta_cap\t\t= histo_v4l2_get_format,\n\t.vidioc_try_fmt_meta_cap\t= histo_v4l2_get_format,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n};\n\n \n\nstatic const struct v4l2_file_operations histo_v4l2_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = video_ioctl2,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.poll = vb2_fop_poll,\n\t.mmap = vb2_fop_mmap,\n};\n\nstatic void vsp1_histogram_cleanup(struct vsp1_histogram *histo)\n{\n\tif (video_is_registered(&histo->video))\n\t\tvideo_unregister_device(&histo->video);\n\n\tmedia_entity_cleanup(&histo->video.entity);\n}\n\nvoid vsp1_histogram_destroy(struct vsp1_entity *entity)\n{\n\tstruct vsp1_histogram *histo = subdev_to_histo(&entity->subdev);\n\n\tvsp1_histogram_cleanup(histo);\n}\n\nint vsp1_histogram_init(struct vsp1_device *vsp1, struct vsp1_histogram *histo,\n\t\t\tenum vsp1_entity_type type, const char *name,\n\t\t\tconst struct vsp1_entity_operations *ops,\n\t\t\tconst unsigned int *formats, unsigned int num_formats,\n\t\t\tsize_t data_size, u32 meta_format)\n{\n\tint ret;\n\n\thisto->formats = formats;\n\thisto->num_formats = num_formats;\n\thisto->data_size = data_size;\n\thisto->meta_format = meta_format;\n\n\thisto->pad.flags = MEDIA_PAD_FL_SINK;\n\thisto->video.vfl_dir = VFL_DIR_RX;\n\n\tmutex_init(&histo->lock);\n\tspin_lock_init(&histo->irqlock);\n\tINIT_LIST_HEAD(&histo->irqqueue);\n\tinit_waitqueue_head(&histo->wait_queue);\n\n\t \n\thisto->entity.ops = ops;\n\thisto->entity.type = type;\n\n\tret = vsp1_entity_init(vsp1, &histo->entity, name, 2, &histo_ops,\n\t\t\t       MEDIA_ENT_F_PROC_VIDEO_STATISTICS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = media_entity_pads_init(&histo->video.entity, 1, &histo->pad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\thisto->video.v4l2_dev = &vsp1->v4l2_dev;\n\thisto->video.fops = &histo_v4l2_fops;\n\tsnprintf(histo->video.name, sizeof(histo->video.name),\n\t\t \"%s histo\", histo->entity.subdev.name);\n\thisto->video.vfl_type = VFL_TYPE_VIDEO;\n\thisto->video.release = video_device_release_empty;\n\thisto->video.ioctl_ops = &histo_v4l2_ioctl_ops;\n\thisto->video.device_caps = V4L2_CAP_META_CAPTURE | V4L2_CAP_STREAMING;\n\n\tvideo_set_drvdata(&histo->video, histo);\n\n\t \n\thisto->queue.type = V4L2_BUF_TYPE_META_CAPTURE;\n\thisto->queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\thisto->queue.lock = &histo->lock;\n\thisto->queue.drv_priv = histo;\n\thisto->queue.buf_struct_size = sizeof(struct vsp1_histogram_buffer);\n\thisto->queue.ops = &histo_video_queue_qops;\n\thisto->queue.mem_ops = &vb2_vmalloc_memops;\n\thisto->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\thisto->queue.dev = vsp1->dev;\n\tret = vb2_queue_init(&histo->queue);\n\tif (ret < 0) {\n\t\tdev_err(vsp1->dev, \"failed to initialize vb2 queue\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\thisto->video.queue = &histo->queue;\n\tret = video_register_device(&histo->video, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0) {\n\t\tdev_err(vsp1->dev, \"failed to register video device\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tvsp1_histogram_cleanup(histo);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}