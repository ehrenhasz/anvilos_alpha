{
  "module_name": "vsp1_entity.c",
  "hash_id": "c69968155ace5043f5a83a52277268a69fb4d1df20a3e10de4cff61850a0c696",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_entity.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gfp.h>\n\n#include <media/media-entity.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-subdev.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_dl.h\"\n#include \"vsp1_entity.h\"\n#include \"vsp1_pipe.h\"\n#include \"vsp1_rwpf.h\"\n\nvoid vsp1_entity_route_setup(struct vsp1_entity *entity,\n\t\t\t     struct vsp1_pipeline *pipe,\n\t\t\t     struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_entity *source;\n\tu32 route;\n\n\tif (entity->type == VSP1_ENTITY_HGO) {\n\t\tu32 smppt;\n\n\t\t \n\t\tsource = entity->sources[0];\n\t\tsmppt = (pipe->output->entity.index << VI6_DPR_SMPPT_TGW_SHIFT)\n\t\t      | (source->route->output << VI6_DPR_SMPPT_PT_SHIFT);\n\n\t\tvsp1_dl_body_write(dlb, VI6_DPR_HGO_SMPPT, smppt);\n\t\treturn;\n\t} else if (entity->type == VSP1_ENTITY_HGT) {\n\t\tu32 smppt;\n\n\t\t \n\t\tsource = entity->sources[0];\n\t\tsmppt = (pipe->output->entity.index << VI6_DPR_SMPPT_TGW_SHIFT)\n\t\t      | (source->route->output << VI6_DPR_SMPPT_PT_SHIFT);\n\n\t\tvsp1_dl_body_write(dlb, VI6_DPR_HGT_SMPPT, smppt);\n\t\treturn;\n\t}\n\n\tsource = entity;\n\tif (source->route->reg == 0)\n\t\treturn;\n\n\troute = source->sink->route->inputs[source->sink_pad];\n\t \n\tif (source->type == VSP1_ENTITY_BRS)\n\t\troute |= VI6_DPR_ROUTE_BRSSEL;\n\tvsp1_dl_body_write(dlb, source->route->reg, route);\n}\n\nvoid vsp1_entity_configure_stream(struct vsp1_entity *entity,\n\t\t\t\t  struct vsp1_pipeline *pipe,\n\t\t\t\t  struct vsp1_dl_list *dl,\n\t\t\t\t  struct vsp1_dl_body *dlb)\n{\n\tif (entity->ops->configure_stream)\n\t\tentity->ops->configure_stream(entity, pipe, dl, dlb);\n}\n\nvoid vsp1_entity_configure_frame(struct vsp1_entity *entity,\n\t\t\t\t struct vsp1_pipeline *pipe,\n\t\t\t\t struct vsp1_dl_list *dl,\n\t\t\t\t struct vsp1_dl_body *dlb)\n{\n\tif (entity->ops->configure_frame)\n\t\tentity->ops->configure_frame(entity, pipe, dl, dlb);\n}\n\nvoid vsp1_entity_configure_partition(struct vsp1_entity *entity,\n\t\t\t\t     struct vsp1_pipeline *pipe,\n\t\t\t\t     struct vsp1_dl_list *dl,\n\t\t\t\t     struct vsp1_dl_body *dlb)\n{\n\tif (entity->ops->configure_partition)\n\t\tentity->ops->configure_partition(entity, pipe, dl, dlb);\n}\n\n \n\n \nstruct v4l2_subdev_state *\nvsp1_entity_get_pad_config(struct vsp1_entity *entity,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   enum v4l2_subdev_format_whence which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn entity->config;\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\tdefault:\n\t\treturn sd_state;\n\t}\n}\n\n \nstruct v4l2_mbus_framefmt *\nvsp1_entity_get_pad_format(struct vsp1_entity *entity,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   unsigned int pad)\n{\n\treturn v4l2_subdev_get_try_format(&entity->subdev, sd_state, pad);\n}\n\n \nstruct v4l2_rect *\nvsp1_entity_get_pad_selection(struct vsp1_entity *entity,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      unsigned int pad, unsigned int target)\n{\n\tswitch (target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\treturn v4l2_subdev_get_try_compose(&entity->subdev, sd_state,\n\t\t\t\t\t\t   pad);\n\tcase V4L2_SEL_TGT_CROP:\n\t\treturn v4l2_subdev_get_try_crop(&entity->subdev, sd_state,\n\t\t\t\t\t\tpad);\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \nint vsp1_entity_init_cfg(struct v4l2_subdev *subdev,\n\t\t\t struct v4l2_subdev_state *sd_state)\n{\n\tunsigned int pad;\n\n\tfor (pad = 0; pad < subdev->entity.num_pads - 1; ++pad) {\n\t\tstruct v4l2_subdev_format format = {\n\t\t\t.pad = pad,\n\t\t\t.which = sd_state ? V4L2_SUBDEV_FORMAT_TRY\n\t\t\t       : V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t};\n\n\t\tv4l2_subdev_call(subdev, pad, set_fmt, sd_state, &format);\n\t}\n\n\treturn 0;\n}\n\n \nint vsp1_subdev_get_pad_format(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_format *fmt)\n{\n\tstruct vsp1_entity *entity = to_vsp1_entity(subdev);\n\tstruct v4l2_subdev_state *config;\n\n\tconfig = vsp1_entity_get_pad_config(entity, sd_state, fmt->which);\n\tif (!config)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&entity->lock);\n\tfmt->format = *vsp1_entity_get_pad_format(entity, config, fmt->pad);\n\tmutex_unlock(&entity->lock);\n\n\treturn 0;\n}\n\n \nint vsp1_subdev_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_mbus_code_enum *code,\n\t\t\t       const unsigned int *codes, unsigned int ncodes)\n{\n\tstruct vsp1_entity *entity = to_vsp1_entity(subdev);\n\n\tif (code->pad == 0) {\n\t\tif (code->index >= ncodes)\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = codes[code->index];\n\t} else {\n\t\tstruct v4l2_subdev_state *config;\n\t\tstruct v4l2_mbus_framefmt *format;\n\n\t\t \n\t\tif (code->index)\n\t\t\treturn -EINVAL;\n\n\t\tconfig = vsp1_entity_get_pad_config(entity, sd_state,\n\t\t\t\t\t\t    code->which);\n\t\tif (!config)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&entity->lock);\n\t\tformat = vsp1_entity_get_pad_format(entity, config, 0);\n\t\tcode->code = format->code;\n\t\tmutex_unlock(&entity->lock);\n\t}\n\n\treturn 0;\n}\n\n \nint vsp1_subdev_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_frame_size_enum *fse,\n\t\t\t\tunsigned int min_width, unsigned int min_height,\n\t\t\t\tunsigned int max_width, unsigned int max_height)\n{\n\tstruct vsp1_entity *entity = to_vsp1_entity(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tint ret = 0;\n\n\tconfig = vsp1_entity_get_pad_config(entity, sd_state, fse->which);\n\tif (!config)\n\t\treturn -EINVAL;\n\n\tformat = vsp1_entity_get_pad_format(entity, config, fse->pad);\n\n\tmutex_lock(&entity->lock);\n\n\tif (fse->index || fse->code != format->code) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (fse->pad == 0) {\n\t\tfse->min_width = min_width;\n\t\tfse->max_width = max_width;\n\t\tfse->min_height = min_height;\n\t\tfse->max_height = max_height;\n\t} else {\n\t\t \n\t\tfse->min_width = format->width;\n\t\tfse->max_width = format->width;\n\t\tfse->min_height = format->height;\n\t\tfse->max_height = format->height;\n\t}\n\ndone:\n\tmutex_unlock(&entity->lock);\n\treturn ret;\n}\n\n \nint vsp1_subdev_set_pad_format(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_format *fmt,\n\t\t\t       const unsigned int *codes, unsigned int ncodes,\n\t\t\t       unsigned int min_width, unsigned int min_height,\n\t\t\t       unsigned int max_width, unsigned int max_height)\n{\n\tstruct vsp1_entity *entity = to_vsp1_entity(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *selection;\n\tunsigned int i;\n\tint ret = 0;\n\n\tmutex_lock(&entity->lock);\n\n\tconfig = vsp1_entity_get_pad_config(entity, sd_state, fmt->which);\n\tif (!config) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tformat = vsp1_entity_get_pad_format(entity, config, fmt->pad);\n\n\tif (fmt->pad == entity->source_pad) {\n\t\t \n\t\tfmt->format = *format;\n\t\tgoto done;\n\t}\n\n\t \n\tfor (i = 0; i < ncodes; ++i) {\n\t\tif (fmt->format.code == codes[i])\n\t\t\tbreak;\n\t}\n\n\tformat->code = i < ncodes ? codes[i] : codes[0];\n\tformat->width = clamp_t(unsigned int, fmt->format.width,\n\t\t\t\tmin_width, max_width);\n\tformat->height = clamp_t(unsigned int, fmt->format.height,\n\t\t\t\t min_height, max_height);\n\tformat->field = V4L2_FIELD_NONE;\n\tformat->colorspace = V4L2_COLORSPACE_SRGB;\n\n\tfmt->format = *format;\n\n\t \n\tformat = vsp1_entity_get_pad_format(entity, config, entity->source_pad);\n\t*format = fmt->format;\n\n\t \n\tselection = vsp1_entity_get_pad_selection(entity, config, fmt->pad,\n\t\t\t\t\t\t  V4L2_SEL_TGT_CROP);\n\tselection->left = 0;\n\tselection->top = 0;\n\tselection->width = format->width;\n\tselection->height = format->height;\n\n\tselection = vsp1_entity_get_pad_selection(entity, config, fmt->pad,\n\t\t\t\t\t\t  V4L2_SEL_TGT_COMPOSE);\n\tselection->left = 0;\n\tselection->top = 0;\n\tselection->width = format->width;\n\tselection->height = format->height;\n\ndone:\n\tmutex_unlock(&entity->lock);\n\treturn ret;\n}\n\n \n\nstatic inline struct vsp1_entity *\nmedia_entity_to_vsp1_entity(struct media_entity *entity)\n{\n\treturn container_of(entity, struct vsp1_entity, subdev.entity);\n}\n\nstatic int vsp1_entity_link_setup_source(const struct media_pad *source_pad,\n\t\t\t\t\t const struct media_pad *sink_pad,\n\t\t\t\t\t u32 flags)\n{\n\tstruct vsp1_entity *source;\n\n\tsource = media_entity_to_vsp1_entity(source_pad->entity);\n\n\tif (!source->route)\n\t\treturn 0;\n\n\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\tstruct vsp1_entity *sink\n\t\t\t= media_entity_to_vsp1_entity(sink_pad->entity);\n\n\t\t \n\t\tif (sink->type != VSP1_ENTITY_HGO &&\n\t\t    sink->type != VSP1_ENTITY_HGT) {\n\t\t\tif (source->sink)\n\t\t\t\treturn -EBUSY;\n\t\t\tsource->sink = sink;\n\t\t\tsource->sink_pad = sink_pad->index;\n\t\t}\n\t} else {\n\t\tsource->sink = NULL;\n\t\tsource->sink_pad = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int vsp1_entity_link_setup_sink(const struct media_pad *source_pad,\n\t\t\t\t       const struct media_pad *sink_pad,\n\t\t\t\t       u32 flags)\n{\n\tstruct vsp1_entity *sink;\n\tstruct vsp1_entity *source;\n\n\tsink = media_entity_to_vsp1_entity(sink_pad->entity);\n\tsource = media_entity_to_vsp1_entity(source_pad->entity);\n\n\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t \n\t\tif (sink->sources[sink_pad->index])\n\t\t\treturn -EBUSY;\n\n\t\tsink->sources[sink_pad->index] = source;\n\t} else {\n\t\tsink->sources[sink_pad->index] = NULL;\n\t}\n\n\treturn 0;\n}\n\nint vsp1_entity_link_setup(struct media_entity *entity,\n\t\t\t   const struct media_pad *local,\n\t\t\t   const struct media_pad *remote, u32 flags)\n{\n\tif (local->flags & MEDIA_PAD_FL_SOURCE)\n\t\treturn vsp1_entity_link_setup_source(local, remote, flags);\n\telse\n\t\treturn vsp1_entity_link_setup_sink(remote, local, flags);\n}\n\n \nstruct media_pad *vsp1_entity_remote_pad(struct media_pad *pad)\n{\n\tstruct media_link *link;\n\n\tlist_for_each_entry(link, &pad->entity->links, list) {\n\t\tstruct vsp1_entity *entity;\n\n\t\tif (!(link->flags & MEDIA_LNK_FL_ENABLED))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (link->sink == pad)\n\t\t\treturn link->source;\n\n\t\tif (link->source != pad)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!is_media_entity_v4l2_subdev(link->sink->entity))\n\t\t\treturn link->sink;\n\n\t\tentity = media_entity_to_vsp1_entity(link->sink->entity);\n\t\tif (entity->type != VSP1_ENTITY_HGO &&\n\t\t    entity->type != VSP1_ENTITY_HGT)\n\t\t\treturn link->sink;\n\t}\n\n\treturn NULL;\n\n}\n\n \n\n#define VSP1_ENTITY_ROUTE(ent)\t\t\t\t\t\t\\\n\t{ VSP1_ENTITY_##ent, 0, VI6_DPR_##ent##_ROUTE,\t\t\t\\\n\t  { VI6_DPR_NODE_##ent }, VI6_DPR_NODE_##ent }\n\n#define VSP1_ENTITY_ROUTE_RPF(idx)\t\t\t\t\t\\\n\t{ VSP1_ENTITY_RPF, idx, VI6_DPR_RPF_ROUTE(idx),\t\t\t\\\n\t  { 0, }, VI6_DPR_NODE_RPF(idx) }\n\n#define VSP1_ENTITY_ROUTE_UDS(idx)\t\t\t\t\t\\\n\t{ VSP1_ENTITY_UDS, idx, VI6_DPR_UDS_ROUTE(idx),\t\t\t\\\n\t  { VI6_DPR_NODE_UDS(idx) }, VI6_DPR_NODE_UDS(idx) }\n\n#define VSP1_ENTITY_ROUTE_UIF(idx)\t\t\t\t\t\\\n\t{ VSP1_ENTITY_UIF, idx, VI6_DPR_UIF_ROUTE(idx),\t\t\t\\\n\t  { VI6_DPR_NODE_UIF(idx) }, VI6_DPR_NODE_UIF(idx) }\n\n#define VSP1_ENTITY_ROUTE_WPF(idx)\t\t\t\t\t\\\n\t{ VSP1_ENTITY_WPF, idx, 0,\t\t\t\t\t\\\n\t  { VI6_DPR_NODE_WPF(idx) }, VI6_DPR_NODE_WPF(idx) }\n\nstatic const struct vsp1_route vsp1_routes[] = {\n\t{ VSP1_ENTITY_BRS, 0, VI6_DPR_ILV_BRS_ROUTE,\n\t  { VI6_DPR_NODE_BRS_IN(0), VI6_DPR_NODE_BRS_IN(1) }, 0 },\n\t{ VSP1_ENTITY_BRU, 0, VI6_DPR_BRU_ROUTE,\n\t  { VI6_DPR_NODE_BRU_IN(0), VI6_DPR_NODE_BRU_IN(1),\n\t    VI6_DPR_NODE_BRU_IN(2), VI6_DPR_NODE_BRU_IN(3),\n\t    VI6_DPR_NODE_BRU_IN(4) }, VI6_DPR_NODE_BRU_OUT },\n\tVSP1_ENTITY_ROUTE(CLU),\n\t{ VSP1_ENTITY_HGO, 0, 0, { 0, }, 0 },\n\t{ VSP1_ENTITY_HGT, 0, 0, { 0, }, 0 },\n\tVSP1_ENTITY_ROUTE(HSI),\n\tVSP1_ENTITY_ROUTE(HST),\n\t{ VSP1_ENTITY_LIF, 0, 0, { 0, }, 0 },\n\t{ VSP1_ENTITY_LIF, 1, 0, { 0, }, 0 },\n\tVSP1_ENTITY_ROUTE(LUT),\n\tVSP1_ENTITY_ROUTE_RPF(0),\n\tVSP1_ENTITY_ROUTE_RPF(1),\n\tVSP1_ENTITY_ROUTE_RPF(2),\n\tVSP1_ENTITY_ROUTE_RPF(3),\n\tVSP1_ENTITY_ROUTE_RPF(4),\n\tVSP1_ENTITY_ROUTE(SRU),\n\tVSP1_ENTITY_ROUTE_UDS(0),\n\tVSP1_ENTITY_ROUTE_UDS(1),\n\tVSP1_ENTITY_ROUTE_UDS(2),\n\tVSP1_ENTITY_ROUTE_UIF(0),\t \n\tVSP1_ENTITY_ROUTE_UIF(1),\t \n\tVSP1_ENTITY_ROUTE_WPF(0),\n\tVSP1_ENTITY_ROUTE_WPF(1),\n\tVSP1_ENTITY_ROUTE_WPF(2),\n\tVSP1_ENTITY_ROUTE_WPF(3),\n};\n\nint vsp1_entity_init(struct vsp1_device *vsp1, struct vsp1_entity *entity,\n\t\t     const char *name, unsigned int num_pads,\n\t\t     const struct v4l2_subdev_ops *ops, u32 function)\n{\n\tstatic struct lock_class_key key;\n\tstruct v4l2_subdev *subdev;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(vsp1_routes); ++i) {\n\t\tif (vsp1_routes[i].type == entity->type &&\n\t\t    vsp1_routes[i].index == entity->index) {\n\t\t\tentity->route = &vsp1_routes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(vsp1_routes))\n\t\treturn -EINVAL;\n\n\tmutex_init(&entity->lock);\n\n\tentity->vsp1 = vsp1;\n\tentity->source_pad = num_pads - 1;\n\n\t \n\tentity->pads = devm_kcalloc(vsp1->dev,\n\t\t\t\t    num_pads, sizeof(*entity->pads),\n\t\t\t\t    GFP_KERNEL);\n\tif (entity->pads == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_pads - 1; ++i)\n\t\tentity->pads[i].flags = MEDIA_PAD_FL_SINK;\n\n\tentity->sources = devm_kcalloc(vsp1->dev, max(num_pads - 1, 1U),\n\t\t\t\t       sizeof(*entity->sources), GFP_KERNEL);\n\tif (entity->sources == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tentity->pads[num_pads - 1].flags = num_pads > 1 ? MEDIA_PAD_FL_SOURCE\n\t\t\t\t\t : MEDIA_PAD_FL_SINK;\n\n\t \n\tret = media_entity_pads_init(&entity->subdev.entity, num_pads,\n\t\t\t\t     entity->pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsubdev = &entity->subdev;\n\tv4l2_subdev_init(subdev, ops);\n\n\tsubdev->entity.function = function;\n\tsubdev->entity.ops = &vsp1->media_ops;\n\tsubdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tsnprintf(subdev->name, sizeof(subdev->name), \"%s %s\",\n\t\t dev_name(vsp1->dev), name);\n\n\tvsp1_entity_init_cfg(subdev, NULL);\n\n\t \n\t \n\tentity->config = __v4l2_subdev_state_alloc(&entity->subdev,\n\t\t\t\t\t\t   \"vsp1:config->lock\", &key);\n\tif (IS_ERR(entity->config)) {\n\t\tmedia_entity_cleanup(&entity->subdev.entity);\n\t\treturn PTR_ERR(entity->config);\n\t}\n\n\treturn 0;\n}\n\nvoid vsp1_entity_destroy(struct vsp1_entity *entity)\n{\n\tif (entity->ops && entity->ops->destroy)\n\t\tentity->ops->destroy(entity);\n\tif (entity->subdev.ctrl_handler)\n\t\tv4l2_ctrl_handler_free(entity->subdev.ctrl_handler);\n\t__v4l2_subdev_state_free(entity->config);\n\tmedia_entity_cleanup(&entity->subdev.entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}