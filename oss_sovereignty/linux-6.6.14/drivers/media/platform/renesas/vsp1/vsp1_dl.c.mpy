{
  "module_name": "vsp1_dl.c",
  "hash_id": "789f187cc2ee3200bbf59a996d5e114715fd81110e32799c299824c8a2df1525",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_dl.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/gfp.h>\n#include <linux/refcount.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_dl.h\"\n\n#define VSP1_DL_NUM_ENTRIES\t\t256\n\n#define VSP1_DLH_INT_ENABLE\t\t(1 << 1)\n#define VSP1_DLH_AUTO_START\t\t(1 << 0)\n\n#define VSP1_DLH_EXT_PRE_CMD_EXEC\t(1 << 9)\n#define VSP1_DLH_EXT_POST_CMD_EXEC\t(1 << 8)\n\nstruct vsp1_dl_header_list {\n\tu32 num_bytes;\n\tu32 addr;\n} __packed;\n\nstruct vsp1_dl_header {\n\tu32 num_lists;\n\tstruct vsp1_dl_header_list lists[8];\n\tu32 next_header;\n\tu32 flags;\n} __packed;\n\n \nstruct vsp1_dl_ext_header {\n\tu32 padding;\n\n\t \n\tu16 pre_ext_dl_num_cmd;\n\tu16 flags;\n\tu32 pre_ext_dl_plist;\n\n\tu32 post_ext_dl_num_cmd;\n\tu32 post_ext_dl_plist;\n} __packed;\n\nstruct vsp1_dl_header_extended {\n\tstruct vsp1_dl_header header;\n\tstruct vsp1_dl_ext_header ext;\n} __packed;\n\nstruct vsp1_dl_entry {\n\tu32 addr;\n\tu32 data;\n} __packed;\n\n \nstruct vsp1_pre_ext_dl_body {\n\tu32 opcode;\n\tu32 flags;\n\tu32 address_set;\n\tu32 reserved;\n} __packed;\n\n \nstruct vsp1_dl_body {\n\tstruct list_head list;\n\tstruct list_head free;\n\n\trefcount_t refcnt;\n\n\tstruct vsp1_dl_body_pool *pool;\n\n\tstruct vsp1_dl_entry *entries;\n\tdma_addr_t dma;\n\tsize_t size;\n\n\tunsigned int num_entries;\n\tunsigned int max_entries;\n};\n\n \nstruct vsp1_dl_body_pool {\n\t \n\tdma_addr_t dma;\n\tsize_t size;\n\tvoid *mem;\n\n\t \n\tstruct vsp1_dl_body *bodies;\n\tstruct list_head free;\n\tspinlock_t lock;\n\n\tstruct vsp1_device *vsp1;\n};\n\n \nstruct vsp1_dl_cmd_pool {\n\t \n\tdma_addr_t dma;\n\tsize_t size;\n\tvoid *mem;\n\n\tstruct vsp1_dl_ext_cmd *cmds;\n\tstruct list_head free;\n\n\tspinlock_t lock;\n\n\tstruct vsp1_device *vsp1;\n};\n\n \nstruct vsp1_dl_list {\n\tstruct list_head list;\n\tstruct vsp1_dl_manager *dlm;\n\n\tstruct vsp1_dl_header *header;\n\tstruct vsp1_dl_ext_header *extension;\n\tdma_addr_t dma;\n\n\tstruct vsp1_dl_body *body0;\n\tstruct list_head bodies;\n\n\tstruct vsp1_dl_ext_cmd *pre_cmd;\n\tstruct vsp1_dl_ext_cmd *post_cmd;\n\n\tbool has_chain;\n\tstruct list_head chain;\n\n\tunsigned int flags;\n};\n\n \nstruct vsp1_dl_manager {\n\tunsigned int index;\n\tbool singleshot;\n\tstruct vsp1_device *vsp1;\n\n\tspinlock_t lock;\n\tstruct list_head free;\n\tstruct vsp1_dl_list *active;\n\tstruct vsp1_dl_list *queued;\n\tstruct vsp1_dl_list *pending;\n\n\tstruct vsp1_dl_body_pool *pool;\n\tstruct vsp1_dl_cmd_pool *cmdpool;\n};\n\n \n\n \nstruct vsp1_dl_body_pool *\nvsp1_dl_body_pool_create(struct vsp1_device *vsp1, unsigned int num_bodies,\n\t\t\t unsigned int num_entries, size_t extra_size)\n{\n\tstruct vsp1_dl_body_pool *pool;\n\tsize_t dlb_size;\n\tunsigned int i;\n\n\tpool = kzalloc(sizeof(*pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpool->vsp1 = vsp1;\n\n\t \n\tdlb_size = num_entries * sizeof(struct vsp1_dl_entry) + extra_size;\n\tpool->size = dlb_size * num_bodies;\n\n\tpool->bodies = kcalloc(num_bodies, sizeof(*pool->bodies), GFP_KERNEL);\n\tif (!pool->bodies) {\n\t\tkfree(pool);\n\t\treturn NULL;\n\t}\n\n\tpool->mem = dma_alloc_wc(vsp1->bus_master, pool->size, &pool->dma,\n\t\t\t\t GFP_KERNEL);\n\tif (!pool->mem) {\n\t\tkfree(pool->bodies);\n\t\tkfree(pool);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&pool->lock);\n\tINIT_LIST_HEAD(&pool->free);\n\n\tfor (i = 0; i < num_bodies; ++i) {\n\t\tstruct vsp1_dl_body *dlb = &pool->bodies[i];\n\n\t\tdlb->pool = pool;\n\t\tdlb->max_entries = num_entries;\n\n\t\tdlb->dma = pool->dma + i * dlb_size;\n\t\tdlb->entries = pool->mem + i * dlb_size;\n\n\t\tlist_add_tail(&dlb->free, &pool->free);\n\t}\n\n\treturn pool;\n}\n\n \nvoid vsp1_dl_body_pool_destroy(struct vsp1_dl_body_pool *pool)\n{\n\tif (!pool)\n\t\treturn;\n\n\tif (pool->mem)\n\t\tdma_free_wc(pool->vsp1->bus_master, pool->size, pool->mem,\n\t\t\t    pool->dma);\n\n\tkfree(pool->bodies);\n\tkfree(pool);\n}\n\n \nstruct vsp1_dl_body *vsp1_dl_body_get(struct vsp1_dl_body_pool *pool)\n{\n\tstruct vsp1_dl_body *dlb = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\n\tif (!list_empty(&pool->free)) {\n\t\tdlb = list_first_entry(&pool->free, struct vsp1_dl_body, free);\n\t\tlist_del(&dlb->free);\n\t\trefcount_set(&dlb->refcnt, 1);\n\t}\n\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\treturn dlb;\n}\n\n \nvoid vsp1_dl_body_put(struct vsp1_dl_body *dlb)\n{\n\tunsigned long flags;\n\n\tif (!dlb)\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&dlb->refcnt))\n\t\treturn;\n\n\tdlb->num_entries = 0;\n\n\tspin_lock_irqsave(&dlb->pool->lock, flags);\n\tlist_add_tail(&dlb->free, &dlb->pool->free);\n\tspin_unlock_irqrestore(&dlb->pool->lock, flags);\n}\n\n \nvoid vsp1_dl_body_write(struct vsp1_dl_body *dlb, u32 reg, u32 data)\n{\n\tif (WARN_ONCE(dlb->num_entries >= dlb->max_entries,\n\t\t      \"DLB size exceeded (max %u)\", dlb->max_entries))\n\t\treturn;\n\n\tdlb->entries[dlb->num_entries].addr = reg;\n\tdlb->entries[dlb->num_entries].data = data;\n\tdlb->num_entries++;\n}\n\n \n\nenum vsp1_extcmd_type {\n\tVSP1_EXTCMD_AUTODISP,\n\tVSP1_EXTCMD_AUTOFLD,\n};\n\nstruct vsp1_extended_command_info {\n\tu16 opcode;\n\tsize_t body_size;\n};\n\nstatic const struct vsp1_extended_command_info vsp1_extended_commands[] = {\n\t[VSP1_EXTCMD_AUTODISP] = { 0x02, 96 },\n\t[VSP1_EXTCMD_AUTOFLD]  = { 0x03, 160 },\n};\n\n \nstatic struct vsp1_dl_cmd_pool *\nvsp1_dl_cmd_pool_create(struct vsp1_device *vsp1, enum vsp1_extcmd_type type,\n\t\t\tunsigned int num_cmds)\n{\n\tstruct vsp1_dl_cmd_pool *pool;\n\tunsigned int i;\n\tsize_t cmd_size;\n\n\tpool = kzalloc(sizeof(*pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpool->vsp1 = vsp1;\n\n\tspin_lock_init(&pool->lock);\n\tINIT_LIST_HEAD(&pool->free);\n\n\tpool->cmds = kcalloc(num_cmds, sizeof(*pool->cmds), GFP_KERNEL);\n\tif (!pool->cmds) {\n\t\tkfree(pool);\n\t\treturn NULL;\n\t}\n\n\tcmd_size = sizeof(struct vsp1_pre_ext_dl_body) +\n\t\t   vsp1_extended_commands[type].body_size;\n\tcmd_size = ALIGN(cmd_size, 16);\n\n\tpool->size = cmd_size * num_cmds;\n\tpool->mem = dma_alloc_wc(vsp1->bus_master, pool->size, &pool->dma,\n\t\t\t\t GFP_KERNEL);\n\tif (!pool->mem) {\n\t\tkfree(pool->cmds);\n\t\tkfree(pool);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < num_cmds; ++i) {\n\t\tstruct vsp1_dl_ext_cmd *cmd = &pool->cmds[i];\n\t\tsize_t cmd_offset = i * cmd_size;\n\t\t \n\t\tsize_t data_offset = sizeof(struct vsp1_pre_ext_dl_body) +\n\t\t\t\t     cmd_offset;\n\n\t\tcmd->pool = pool;\n\t\tcmd->opcode = vsp1_extended_commands[type].opcode;\n\n\t\t \n\t\tcmd->num_cmds = 1;\n\t\tcmd->cmds = pool->mem + cmd_offset;\n\t\tcmd->cmd_dma = pool->dma + cmd_offset;\n\n\t\tcmd->data = pool->mem + data_offset;\n\t\tcmd->data_dma = pool->dma + data_offset;\n\n\t\tlist_add_tail(&cmd->free, &pool->free);\n\t}\n\n\treturn pool;\n}\n\nstatic\nstruct vsp1_dl_ext_cmd *vsp1_dl_ext_cmd_get(struct vsp1_dl_cmd_pool *pool)\n{\n\tstruct vsp1_dl_ext_cmd *cmd = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\n\tif (!list_empty(&pool->free)) {\n\t\tcmd = list_first_entry(&pool->free, struct vsp1_dl_ext_cmd,\n\t\t\t\t       free);\n\t\tlist_del(&cmd->free);\n\t}\n\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\treturn cmd;\n}\n\nstatic void vsp1_dl_ext_cmd_put(struct vsp1_dl_ext_cmd *cmd)\n{\n\tunsigned long flags;\n\n\tif (!cmd)\n\t\treturn;\n\n\t \n\tcmd->flags = 0;\n\n\tspin_lock_irqsave(&cmd->pool->lock, flags);\n\tlist_add_tail(&cmd->free, &cmd->pool->free);\n\tspin_unlock_irqrestore(&cmd->pool->lock, flags);\n}\n\nstatic void vsp1_dl_ext_cmd_pool_destroy(struct vsp1_dl_cmd_pool *pool)\n{\n\tif (!pool)\n\t\treturn;\n\n\tif (pool->mem)\n\t\tdma_free_wc(pool->vsp1->bus_master, pool->size, pool->mem,\n\t\t\t    pool->dma);\n\n\tkfree(pool->cmds);\n\tkfree(pool);\n}\n\nstruct vsp1_dl_ext_cmd *vsp1_dl_get_pre_cmd(struct vsp1_dl_list *dl)\n{\n\tstruct vsp1_dl_manager *dlm = dl->dlm;\n\n\tif (dl->pre_cmd)\n\t\treturn dl->pre_cmd;\n\n\tdl->pre_cmd = vsp1_dl_ext_cmd_get(dlm->cmdpool);\n\n\treturn dl->pre_cmd;\n}\n\n \n\nstatic struct vsp1_dl_list *vsp1_dl_list_alloc(struct vsp1_dl_manager *dlm)\n{\n\tstruct vsp1_dl_list *dl;\n\tsize_t header_offset;\n\n\tdl = kzalloc(sizeof(*dl), GFP_KERNEL);\n\tif (!dl)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&dl->bodies);\n\tdl->dlm = dlm;\n\n\t \n\tdl->body0 = vsp1_dl_body_get(dlm->pool);\n\tif (!dl->body0) {\n\t\tkfree(dl);\n\t\treturn NULL;\n\t}\n\n\theader_offset = dl->body0->max_entries * sizeof(*dl->body0->entries);\n\n\tdl->header = ((void *)dl->body0->entries) + header_offset;\n\tdl->dma = dl->body0->dma + header_offset;\n\n\tmemset(dl->header, 0, sizeof(*dl->header));\n\tdl->header->lists[0].addr = dl->body0->dma;\n\n\treturn dl;\n}\n\nstatic void vsp1_dl_list_bodies_put(struct vsp1_dl_list *dl)\n{\n\tstruct vsp1_dl_body *dlb, *tmp;\n\n\tlist_for_each_entry_safe(dlb, tmp, &dl->bodies, list) {\n\t\tlist_del(&dlb->list);\n\t\tvsp1_dl_body_put(dlb);\n\t}\n}\n\nstatic void vsp1_dl_list_free(struct vsp1_dl_list *dl)\n{\n\tvsp1_dl_body_put(dl->body0);\n\tvsp1_dl_list_bodies_put(dl);\n\n\tkfree(dl);\n}\n\n \nstruct vsp1_dl_list *vsp1_dl_list_get(struct vsp1_dl_manager *dlm)\n{\n\tstruct vsp1_dl_list *dl = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dlm->lock, flags);\n\n\tif (!list_empty(&dlm->free)) {\n\t\tdl = list_first_entry(&dlm->free, struct vsp1_dl_list, list);\n\t\tlist_del(&dl->list);\n\n\t\t \n\t\tINIT_LIST_HEAD(&dl->chain);\n\t}\n\n\tspin_unlock_irqrestore(&dlm->lock, flags);\n\n\treturn dl;\n}\n\n \nstatic void __vsp1_dl_list_put(struct vsp1_dl_list *dl)\n{\n\tstruct vsp1_dl_list *dl_next;\n\n\tif (!dl)\n\t\treturn;\n\n\t \n\tif (dl->has_chain) {\n\t\tlist_for_each_entry(dl_next, &dl->chain, chain)\n\t\t\t__vsp1_dl_list_put(dl_next);\n\t}\n\n\tdl->has_chain = false;\n\n\tvsp1_dl_list_bodies_put(dl);\n\n\tvsp1_dl_ext_cmd_put(dl->pre_cmd);\n\tvsp1_dl_ext_cmd_put(dl->post_cmd);\n\n\tdl->pre_cmd = NULL;\n\tdl->post_cmd = NULL;\n\n\t \n\tdl->body0->num_entries = 0;\n\n\tlist_add_tail(&dl->list, &dl->dlm->free);\n}\n\n \nvoid vsp1_dl_list_put(struct vsp1_dl_list *dl)\n{\n\tunsigned long flags;\n\n\tif (!dl)\n\t\treturn;\n\n\tspin_lock_irqsave(&dl->dlm->lock, flags);\n\t__vsp1_dl_list_put(dl);\n\tspin_unlock_irqrestore(&dl->dlm->lock, flags);\n}\n\n \nstruct vsp1_dl_body *vsp1_dl_list_get_body0(struct vsp1_dl_list *dl)\n{\n\treturn dl->body0;\n}\n\n \nint vsp1_dl_list_add_body(struct vsp1_dl_list *dl, struct vsp1_dl_body *dlb)\n{\n\trefcount_inc(&dlb->refcnt);\n\n\tlist_add_tail(&dlb->list, &dl->bodies);\n\n\treturn 0;\n}\n\n \nint vsp1_dl_list_add_chain(struct vsp1_dl_list *head,\n\t\t\t   struct vsp1_dl_list *dl)\n{\n\thead->has_chain = true;\n\tlist_add_tail(&dl->chain, &head->chain);\n\treturn 0;\n}\n\nstatic void vsp1_dl_ext_cmd_fill_header(struct vsp1_dl_ext_cmd *cmd)\n{\n\tcmd->cmds[0].opcode = cmd->opcode;\n\tcmd->cmds[0].flags = cmd->flags;\n\tcmd->cmds[0].address_set = cmd->data_dma;\n\tcmd->cmds[0].reserved = 0;\n}\n\nstatic void vsp1_dl_list_fill_header(struct vsp1_dl_list *dl, bool is_last)\n{\n\tstruct vsp1_dl_manager *dlm = dl->dlm;\n\tstruct vsp1_dl_header_list *hdr = dl->header->lists;\n\tstruct vsp1_dl_body *dlb;\n\tunsigned int num_lists = 0;\n\n\t \n\n\thdr->num_bytes = dl->body0->num_entries\n\t\t       * sizeof(*dl->header->lists);\n\n\tlist_for_each_entry(dlb, &dl->bodies, list) {\n\t\tnum_lists++;\n\t\thdr++;\n\n\t\thdr->addr = dlb->dma;\n\t\thdr->num_bytes = dlb->num_entries\n\t\t\t       * sizeof(*dl->header->lists);\n\t}\n\n\tdl->header->num_lists = num_lists;\n\tdl->header->flags = 0;\n\n\t \n\tif (!dlm->singleshot || is_last)\n\t\tdl->header->flags |= VSP1_DLH_INT_ENABLE;\n\n\t \n\tif (!dlm->singleshot || !is_last)\n\t\tdl->header->flags |= VSP1_DLH_AUTO_START;\n\n\tif (!is_last) {\n\t\t \n\t\tstruct vsp1_dl_list *next = list_next_entry(dl, chain);\n\n\t\tdl->header->next_header = next->dma;\n\t} else if (!dlm->singleshot) {\n\t\t \n\t\tdl->header->next_header = dl->dma;\n\t}\n\n\tif (!dl->extension)\n\t\treturn;\n\n\tdl->extension->flags = 0;\n\n\tif (dl->pre_cmd) {\n\t\tdl->extension->pre_ext_dl_plist = dl->pre_cmd->cmd_dma;\n\t\tdl->extension->pre_ext_dl_num_cmd = dl->pre_cmd->num_cmds;\n\t\tdl->extension->flags |= VSP1_DLH_EXT_PRE_CMD_EXEC;\n\n\t\tvsp1_dl_ext_cmd_fill_header(dl->pre_cmd);\n\t}\n\n\tif (dl->post_cmd) {\n\t\tdl->extension->post_ext_dl_plist = dl->post_cmd->cmd_dma;\n\t\tdl->extension->post_ext_dl_num_cmd = dl->post_cmd->num_cmds;\n\t\tdl->extension->flags |= VSP1_DLH_EXT_POST_CMD_EXEC;\n\n\t\tvsp1_dl_ext_cmd_fill_header(dl->post_cmd);\n\t}\n}\n\nstatic bool vsp1_dl_list_hw_update_pending(struct vsp1_dl_manager *dlm)\n{\n\tstruct vsp1_device *vsp1 = dlm->vsp1;\n\n\tif (!dlm->queued)\n\t\treturn false;\n\n\t \n\treturn !!(vsp1_read(vsp1, VI6_CMD(dlm->index)) & VI6_CMD_UPDHDR);\n}\n\nstatic void vsp1_dl_list_hw_enqueue(struct vsp1_dl_list *dl)\n{\n\tstruct vsp1_dl_manager *dlm = dl->dlm;\n\tstruct vsp1_device *vsp1 = dlm->vsp1;\n\n\t \n\tvsp1_write(vsp1, VI6_DL_HDR_ADDR(dlm->index), dl->dma);\n}\n\nstatic void vsp1_dl_list_commit_continuous(struct vsp1_dl_list *dl)\n{\n\tstruct vsp1_dl_manager *dlm = dl->dlm;\n\n\t \n\tif (vsp1_dl_list_hw_update_pending(dlm)) {\n\t\tWARN_ON(dlm->pending &&\n\t\t\t(dlm->pending->flags & VSP1_DL_FRAME_END_INTERNAL));\n\t\t__vsp1_dl_list_put(dlm->pending);\n\t\tdlm->pending = dl;\n\t\treturn;\n\t}\n\n\t \n\tvsp1_dl_list_hw_enqueue(dl);\n\n\t__vsp1_dl_list_put(dlm->queued);\n\tdlm->queued = dl;\n}\n\nstatic void vsp1_dl_list_commit_singleshot(struct vsp1_dl_list *dl)\n{\n\tstruct vsp1_dl_manager *dlm = dl->dlm;\n\n\t \n\tvsp1_dl_list_hw_enqueue(dl);\n\n\tdlm->active = dl;\n}\n\nvoid vsp1_dl_list_commit(struct vsp1_dl_list *dl, unsigned int dl_flags)\n{\n\tstruct vsp1_dl_manager *dlm = dl->dlm;\n\tstruct vsp1_dl_list *dl_next;\n\tunsigned long flags;\n\n\t \n\tvsp1_dl_list_fill_header(dl, list_empty(&dl->chain));\n\n\tlist_for_each_entry(dl_next, &dl->chain, chain) {\n\t\tbool last = list_is_last(&dl_next->chain, &dl->chain);\n\n\t\tvsp1_dl_list_fill_header(dl_next, last);\n\t}\n\n\tdl->flags = dl_flags & ~VSP1_DL_FRAME_END_COMPLETED;\n\n\tspin_lock_irqsave(&dlm->lock, flags);\n\n\tif (dlm->singleshot)\n\t\tvsp1_dl_list_commit_singleshot(dl);\n\telse\n\t\tvsp1_dl_list_commit_continuous(dl);\n\n\tspin_unlock_irqrestore(&dlm->lock, flags);\n}\n\n \n\n \nunsigned int vsp1_dlm_irq_frame_end(struct vsp1_dl_manager *dlm)\n{\n\tstruct vsp1_device *vsp1 = dlm->vsp1;\n\tu32 status = vsp1_read(vsp1, VI6_STATUS);\n\tunsigned int flags = 0;\n\n\tspin_lock(&dlm->lock);\n\n\t \n\tif (dlm->singleshot) {\n\t\t__vsp1_dl_list_put(dlm->active);\n\t\tdlm->active = NULL;\n\t\tflags |= VSP1_DL_FRAME_END_COMPLETED;\n\t\tgoto done;\n\t}\n\n\t \n\tif (vsp1_dl_list_hw_update_pending(dlm))\n\t\tgoto done;\n\n\t \n\tif (status & VI6_STATUS_FLD_STD(dlm->index))\n\t\tgoto done;\n\n\t \n\tif (dlm->active && (dlm->active->flags & VSP1_DL_FRAME_END_WRITEBACK)) {\n\t\tflags |= VSP1_DL_FRAME_END_WRITEBACK;\n\t\tdlm->active->flags &= ~VSP1_DL_FRAME_END_WRITEBACK;\n\t}\n\n\t \n\tif (dlm->queued) {\n\t\tif (dlm->queued->flags & VSP1_DL_FRAME_END_INTERNAL)\n\t\t\tflags |= VSP1_DL_FRAME_END_INTERNAL;\n\t\tdlm->queued->flags &= ~VSP1_DL_FRAME_END_INTERNAL;\n\n\t\t__vsp1_dl_list_put(dlm->active);\n\t\tdlm->active = dlm->queued;\n\t\tdlm->queued = NULL;\n\t\tflags |= VSP1_DL_FRAME_END_COMPLETED;\n\t}\n\n\t \n\tif (dlm->pending) {\n\t\tvsp1_dl_list_hw_enqueue(dlm->pending);\n\t\tdlm->queued = dlm->pending;\n\t\tdlm->pending = NULL;\n\t}\n\ndone:\n\tspin_unlock(&dlm->lock);\n\n\treturn flags;\n}\n\n \nvoid vsp1_dlm_setup(struct vsp1_device *vsp1)\n{\n\tunsigned int i;\n\tu32 ctrl = (256 << VI6_DL_CTRL_AR_WAIT_SHIFT)\n\t\t | VI6_DL_CTRL_DC2 | VI6_DL_CTRL_DC1 | VI6_DL_CTRL_DC0\n\t\t | VI6_DL_CTRL_DLE;\n\tu32 ext_dl = (0x02 << VI6_DL_EXT_CTRL_POLINT_SHIFT)\n\t\t   | VI6_DL_EXT_CTRL_DLPRI | VI6_DL_EXT_CTRL_EXT;\n\n\tif (vsp1_feature(vsp1, VSP1_HAS_EXT_DL)) {\n\t\tfor (i = 0; i < vsp1->info->wpf_count; ++i)\n\t\t\tvsp1_write(vsp1, VI6_DL_EXT_CTRL(i), ext_dl);\n\t}\n\n\tvsp1_write(vsp1, VI6_DL_CTRL, ctrl);\n\tvsp1_write(vsp1, VI6_DL_SWAP, VI6_DL_SWAP_LWS);\n}\n\nvoid vsp1_dlm_reset(struct vsp1_dl_manager *dlm)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dlm->lock, flags);\n\n\t__vsp1_dl_list_put(dlm->active);\n\t__vsp1_dl_list_put(dlm->queued);\n\t__vsp1_dl_list_put(dlm->pending);\n\n\tspin_unlock_irqrestore(&dlm->lock, flags);\n\n\tdlm->active = NULL;\n\tdlm->queued = NULL;\n\tdlm->pending = NULL;\n}\n\nstruct vsp1_dl_body *vsp1_dlm_dl_body_get(struct vsp1_dl_manager *dlm)\n{\n\treturn vsp1_dl_body_get(dlm->pool);\n}\n\nstruct vsp1_dl_manager *vsp1_dlm_create(struct vsp1_device *vsp1,\n\t\t\t\t\tunsigned int index,\n\t\t\t\t\tunsigned int prealloc)\n{\n\tstruct vsp1_dl_manager *dlm;\n\tsize_t header_size;\n\tunsigned int i;\n\n\tdlm = devm_kzalloc(vsp1->dev, sizeof(*dlm), GFP_KERNEL);\n\tif (!dlm)\n\t\treturn NULL;\n\n\tdlm->index = index;\n\tdlm->singleshot = vsp1->info->uapi;\n\tdlm->vsp1 = vsp1;\n\n\tspin_lock_init(&dlm->lock);\n\tINIT_LIST_HEAD(&dlm->free);\n\n\t \n\theader_size = vsp1_feature(vsp1, VSP1_HAS_EXT_DL) ?\n\t\t\tsizeof(struct vsp1_dl_header_extended) :\n\t\t\tsizeof(struct vsp1_dl_header);\n\n\theader_size = ALIGN(header_size, 8);\n\n\tdlm->pool = vsp1_dl_body_pool_create(vsp1, prealloc + 1,\n\t\t\t\t\t     VSP1_DL_NUM_ENTRIES, header_size);\n\tif (!dlm->pool)\n\t\treturn NULL;\n\n\tfor (i = 0; i < prealloc; ++i) {\n\t\tstruct vsp1_dl_list *dl;\n\n\t\tdl = vsp1_dl_list_alloc(dlm);\n\t\tif (!dl) {\n\t\t\tvsp1_dlm_destroy(dlm);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (vsp1_feature(vsp1, VSP1_HAS_EXT_DL))\n\t\t\tdl->extension = (void *)dl->header\n\t\t\t\t      + sizeof(*dl->header);\n\n\t\tlist_add_tail(&dl->list, &dlm->free);\n\t}\n\n\tif (vsp1_feature(vsp1, VSP1_HAS_EXT_DL)) {\n\t\tdlm->cmdpool = vsp1_dl_cmd_pool_create(vsp1,\n\t\t\t\t\tVSP1_EXTCMD_AUTOFLD, prealloc);\n\t\tif (!dlm->cmdpool) {\n\t\t\tvsp1_dlm_destroy(dlm);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn dlm;\n}\n\nvoid vsp1_dlm_destroy(struct vsp1_dl_manager *dlm)\n{\n\tstruct vsp1_dl_list *dl, *next;\n\n\tif (!dlm)\n\t\treturn;\n\n\tlist_for_each_entry_safe(dl, next, &dlm->free, list) {\n\t\tlist_del(&dl->list);\n\t\tvsp1_dl_list_free(dl);\n\t}\n\n\tvsp1_dl_body_pool_destroy(dlm->pool);\n\tvsp1_dl_ext_cmd_pool_destroy(dlm->cmdpool);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}