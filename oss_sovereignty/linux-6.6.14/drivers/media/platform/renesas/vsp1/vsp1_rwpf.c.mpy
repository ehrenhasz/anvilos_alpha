{
  "module_name": "vsp1_rwpf.c",
  "hash_id": "b328a6f4bcf71312ac870bb279e11654e8b80fcdce7c0bb2950618f4825106a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_rwpf.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-subdev.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_rwpf.h\"\n#include \"vsp1_video.h\"\n\n#define RWPF_MIN_WIDTH\t\t\t\t1\n#define RWPF_MIN_HEIGHT\t\t\t\t1\n\nstruct v4l2_rect *vsp1_rwpf_get_crop(struct vsp1_rwpf *rwpf,\n\t\t\t\t     struct v4l2_subdev_state *sd_state)\n{\n\treturn v4l2_subdev_get_try_crop(&rwpf->entity.subdev, sd_state,\n\t\t\t\t\tRWPF_PAD_SINK);\n}\n\n \n\nstatic int vsp1_rwpf_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstatic const unsigned int codes[] = {\n\t\tMEDIA_BUS_FMT_ARGB8888_1X32,\n\t\tMEDIA_BUS_FMT_AHSV8888_1X32,\n\t\tMEDIA_BUS_FMT_AYUV8_1X32,\n\t};\n\n\tif (code->index >= ARRAY_SIZE(codes))\n\t\treturn -EINVAL;\n\n\tcode->code = codes[code->index];\n\n\treturn 0;\n}\n\nstatic int vsp1_rwpf_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct vsp1_rwpf *rwpf = to_rwpf(subdev);\n\n\treturn vsp1_subdev_enum_frame_size(subdev, sd_state, fse,\n\t\t\t\t\t   RWPF_MIN_WIDTH,\n\t\t\t\t\t   RWPF_MIN_HEIGHT, rwpf->max_width,\n\t\t\t\t\t   rwpf->max_height);\n}\n\nstatic int vsp1_rwpf_set_format(struct v4l2_subdev *subdev,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_format *fmt)\n{\n\tstruct vsp1_rwpf *rwpf = to_rwpf(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tint ret = 0;\n\n\tmutex_lock(&rwpf->entity.lock);\n\n\tconfig = vsp1_entity_get_pad_config(&rwpf->entity, sd_state,\n\t\t\t\t\t    fmt->which);\n\tif (!config) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tif (fmt->format.code != MEDIA_BUS_FMT_ARGB8888_1X32 &&\n\t    fmt->format.code != MEDIA_BUS_FMT_AHSV8888_1X32 &&\n\t    fmt->format.code != MEDIA_BUS_FMT_AYUV8_1X32)\n\t\tfmt->format.code = MEDIA_BUS_FMT_AYUV8_1X32;\n\n\tformat = vsp1_entity_get_pad_format(&rwpf->entity, config, fmt->pad);\n\n\tif (fmt->pad == RWPF_PAD_SOURCE) {\n\t\t \n\t\tformat->code = fmt->format.code;\n\t\tfmt->format = *format;\n\t\tgoto done;\n\t}\n\n\tformat->code = fmt->format.code;\n\tformat->width = clamp_t(unsigned int, fmt->format.width,\n\t\t\t\tRWPF_MIN_WIDTH, rwpf->max_width);\n\tformat->height = clamp_t(unsigned int, fmt->format.height,\n\t\t\t\t RWPF_MIN_HEIGHT, rwpf->max_height);\n\tformat->field = V4L2_FIELD_NONE;\n\tformat->colorspace = V4L2_COLORSPACE_SRGB;\n\n\tfmt->format = *format;\n\n\tif (rwpf->entity.type == VSP1_ENTITY_RPF) {\n\t\tstruct v4l2_rect *crop;\n\n\t\t \n\t\tcrop = vsp1_rwpf_get_crop(rwpf, config);\n\t\tcrop->left = 0;\n\t\tcrop->top = 0;\n\t\tcrop->width = fmt->format.width;\n\t\tcrop->height = fmt->format.height;\n\t}\n\n\t \n\tformat = vsp1_entity_get_pad_format(&rwpf->entity, config,\n\t\t\t\t\t    RWPF_PAD_SOURCE);\n\t*format = fmt->format;\n\n\tif (rwpf->flip.rotate) {\n\t\tformat->width = fmt->format.height;\n\t\tformat->height = fmt->format.width;\n\t}\n\ndone:\n\tmutex_unlock(&rwpf->entity.lock);\n\treturn ret;\n}\n\nstatic int vsp1_rwpf_get_selection(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_selection *sel)\n{\n\tstruct vsp1_rwpf *rwpf = to_rwpf(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tint ret = 0;\n\n\t \n\tif (rwpf->entity.type == VSP1_ENTITY_WPF || sel->pad != RWPF_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rwpf->entity.lock);\n\n\tconfig = vsp1_entity_get_pad_config(&rwpf->entity, sd_state,\n\t\t\t\t\t    sel->which);\n\tif (!config) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *vsp1_rwpf_get_crop(rwpf, config);\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tformat = vsp1_entity_get_pad_format(&rwpf->entity, config,\n\t\t\t\t\t\t    RWPF_PAD_SINK);\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = format->width;\n\t\tsel->r.height = format->height;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\ndone:\n\tmutex_unlock(&rwpf->entity.lock);\n\treturn ret;\n}\n\nstatic int vsp1_rwpf_set_selection(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_selection *sel)\n{\n\tstruct vsp1_rwpf *rwpf = to_rwpf(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *crop;\n\tint ret = 0;\n\n\t \n\tif (rwpf->entity.type == VSP1_ENTITY_WPF || sel->pad != RWPF_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rwpf->entity.lock);\n\n\tconfig = vsp1_entity_get_pad_config(&rwpf->entity, sd_state,\n\t\t\t\t\t    sel->which);\n\tif (!config) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tformat = vsp1_entity_get_pad_format(&rwpf->entity, config,\n\t\t\t\t\t    RWPF_PAD_SINK);\n\n\t \n\tif (format->code == MEDIA_BUS_FMT_AYUV8_1X32) {\n\t\tsel->r.left = ALIGN(sel->r.left, 2);\n\t\tsel->r.top = ALIGN(sel->r.top, 2);\n\t\tsel->r.width = round_down(sel->r.width, 2);\n\t\tsel->r.height = round_down(sel->r.height, 2);\n\t}\n\n\tsel->r.left = min_t(unsigned int, sel->r.left, format->width - 2);\n\tsel->r.top = min_t(unsigned int, sel->r.top, format->height - 2);\n\tsel->r.width = min_t(unsigned int, sel->r.width,\n\t\t\t     format->width - sel->r.left);\n\tsel->r.height = min_t(unsigned int, sel->r.height,\n\t\t\t      format->height - sel->r.top);\n\n\tcrop = vsp1_rwpf_get_crop(rwpf, config);\n\t*crop = sel->r;\n\n\t \n\tformat = vsp1_entity_get_pad_format(&rwpf->entity, config,\n\t\t\t\t\t    RWPF_PAD_SOURCE);\n\tformat->width = crop->width;\n\tformat->height = crop->height;\n\ndone:\n\tmutex_unlock(&rwpf->entity.lock);\n\treturn ret;\n}\n\nconst struct v4l2_subdev_pad_ops vsp1_rwpf_pad_ops = {\n\t.init_cfg = vsp1_entity_init_cfg,\n\t.enum_mbus_code = vsp1_rwpf_enum_mbus_code,\n\t.enum_frame_size = vsp1_rwpf_enum_frame_size,\n\t.get_fmt = vsp1_subdev_get_pad_format,\n\t.set_fmt = vsp1_rwpf_set_format,\n\t.get_selection = vsp1_rwpf_get_selection,\n\t.set_selection = vsp1_rwpf_set_selection,\n};\n\n \n\nstatic int vsp1_rwpf_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vsp1_rwpf *rwpf =\n\t\tcontainer_of(ctrl->handler, struct vsp1_rwpf, ctrls);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_ALPHA_COMPONENT:\n\t\trwpf->alpha = ctrl->val;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vsp1_rwpf_ctrl_ops = {\n\t.s_ctrl = vsp1_rwpf_s_ctrl,\n};\n\nint vsp1_rwpf_init_ctrls(struct vsp1_rwpf *rwpf, unsigned int ncontrols)\n{\n\tv4l2_ctrl_handler_init(&rwpf->ctrls, ncontrols + 1);\n\tv4l2_ctrl_new_std(&rwpf->ctrls, &vsp1_rwpf_ctrl_ops,\n\t\t\t  V4L2_CID_ALPHA_COMPONENT, 0, 255, 1, 255);\n\n\trwpf->entity.subdev.ctrl_handler = &rwpf->ctrls;\n\n\treturn rwpf->ctrls.error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}