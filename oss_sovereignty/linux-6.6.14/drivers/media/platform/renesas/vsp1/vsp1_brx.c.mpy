{
  "module_name": "vsp1_brx.c",
  "hash_id": "2b185cb6d47a3aa75eaa4bc2862ca67a4894f00d45cfc7bb7306cf1cd9102c1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_brx.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gfp.h>\n\n#include <media/v4l2-subdev.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_brx.h\"\n#include \"vsp1_dl.h\"\n#include \"vsp1_pipe.h\"\n#include \"vsp1_rwpf.h\"\n#include \"vsp1_video.h\"\n\n#define BRX_MIN_SIZE\t\t\t\t1U\n#define BRX_MAX_SIZE\t\t\t\t8190U\n\n \n\nstatic inline void vsp1_brx_write(struct vsp1_brx *brx,\n\t\t\t\t  struct vsp1_dl_body *dlb, u32 reg, u32 data)\n{\n\tvsp1_dl_body_write(dlb, brx->base + reg, data);\n}\n\n \n\nstatic int brx_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vsp1_brx *brx =\n\t\tcontainer_of(ctrl->handler, struct vsp1_brx, ctrls);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BG_COLOR:\n\t\tbrx->bgcolor = ctrl->val;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops brx_ctrl_ops = {\n\t.s_ctrl = brx_s_ctrl,\n};\n\n \n\n \n\nstatic int brx_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstatic const unsigned int codes[] = {\n\t\tMEDIA_BUS_FMT_ARGB8888_1X32,\n\t\tMEDIA_BUS_FMT_AYUV8_1X32,\n\t};\n\n\treturn vsp1_subdev_enum_mbus_code(subdev, sd_state, code, codes,\n\t\t\t\t\t  ARRAY_SIZE(codes));\n}\n\nstatic int brx_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_frame_size_enum *fse)\n{\n\tif (fse->index)\n\t\treturn -EINVAL;\n\n\tif (fse->code != MEDIA_BUS_FMT_ARGB8888_1X32 &&\n\t    fse->code != MEDIA_BUS_FMT_AYUV8_1X32)\n\t\treturn -EINVAL;\n\n\tfse->min_width = BRX_MIN_SIZE;\n\tfse->max_width = BRX_MAX_SIZE;\n\tfse->min_height = BRX_MIN_SIZE;\n\tfse->max_height = BRX_MAX_SIZE;\n\n\treturn 0;\n}\n\nstatic struct v4l2_rect *brx_get_compose(struct vsp1_brx *brx,\n\t\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t\t unsigned int pad)\n{\n\treturn v4l2_subdev_get_try_compose(&brx->entity.subdev, sd_state, pad);\n}\n\nstatic void brx_try_format(struct vsp1_brx *brx,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   unsigned int pad, struct v4l2_mbus_framefmt *fmt)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\n\tswitch (pad) {\n\tcase BRX_PAD_SINK(0):\n\t\t \n\t\tif (fmt->code != MEDIA_BUS_FMT_ARGB8888_1X32 &&\n\t\t    fmt->code != MEDIA_BUS_FMT_AYUV8_1X32)\n\t\t\tfmt->code = MEDIA_BUS_FMT_AYUV8_1X32;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tformat = vsp1_entity_get_pad_format(&brx->entity, sd_state,\n\t\t\t\t\t\t    BRX_PAD_SINK(0));\n\t\tfmt->code = format->code;\n\t\tbreak;\n\t}\n\n\tfmt->width = clamp(fmt->width, BRX_MIN_SIZE, BRX_MAX_SIZE);\n\tfmt->height = clamp(fmt->height, BRX_MIN_SIZE, BRX_MAX_SIZE);\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n}\n\nstatic int brx_set_format(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct vsp1_brx *brx = to_brx(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tint ret = 0;\n\n\tmutex_lock(&brx->entity.lock);\n\n\tconfig = vsp1_entity_get_pad_config(&brx->entity, sd_state,\n\t\t\t\t\t    fmt->which);\n\tif (!config) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tbrx_try_format(brx, config, fmt->pad, &fmt->format);\n\n\tformat = vsp1_entity_get_pad_format(&brx->entity, config, fmt->pad);\n\t*format = fmt->format;\n\n\t \n\tif (fmt->pad != brx->entity.source_pad) {\n\t\tstruct v4l2_rect *compose;\n\n\t\tcompose = brx_get_compose(brx, config, fmt->pad);\n\t\tcompose->left = 0;\n\t\tcompose->top = 0;\n\t\tcompose->width = format->width;\n\t\tcompose->height = format->height;\n\t}\n\n\t \n\tif (fmt->pad == BRX_PAD_SINK(0)) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i <= brx->entity.source_pad; ++i) {\n\t\t\tformat = vsp1_entity_get_pad_format(&brx->entity,\n\t\t\t\t\t\t\t    config, i);\n\t\t\tformat->code = fmt->format.code;\n\t\t}\n\t}\n\ndone:\n\tmutex_unlock(&brx->entity.lock);\n\treturn ret;\n}\n\nstatic int brx_get_selection(struct v4l2_subdev *subdev,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct vsp1_brx *brx = to_brx(subdev);\n\tstruct v4l2_subdev_state *config;\n\n\tif (sel->pad == brx->entity.source_pad)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = BRX_MAX_SIZE;\n\t\tsel->r.height = BRX_MAX_SIZE;\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tconfig = vsp1_entity_get_pad_config(&brx->entity, sd_state,\n\t\t\t\t\t\t    sel->which);\n\t\tif (!config)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&brx->entity.lock);\n\t\tsel->r = *brx_get_compose(brx, config, sel->pad);\n\t\tmutex_unlock(&brx->entity.lock);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int brx_set_selection(struct v4l2_subdev *subdev,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct vsp1_brx *brx = to_brx(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *compose;\n\tint ret = 0;\n\n\tif (sel->pad == brx->entity.source_pad)\n\t\treturn -EINVAL;\n\n\tif (sel->target != V4L2_SEL_TGT_COMPOSE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&brx->entity.lock);\n\n\tconfig = vsp1_entity_get_pad_config(&brx->entity, sd_state,\n\t\t\t\t\t    sel->which);\n\tif (!config) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tformat = vsp1_entity_get_pad_format(&brx->entity, config,\n\t\t\t\t\t    brx->entity.source_pad);\n\tsel->r.left = clamp_t(unsigned int, sel->r.left, 0, format->width - 1);\n\tsel->r.top = clamp_t(unsigned int, sel->r.top, 0, format->height - 1);\n\n\t \n\tformat = vsp1_entity_get_pad_format(&brx->entity, config, sel->pad);\n\tsel->r.width = format->width;\n\tsel->r.height = format->height;\n\n\tcompose = brx_get_compose(brx, config, sel->pad);\n\t*compose = sel->r;\n\ndone:\n\tmutex_unlock(&brx->entity.lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_pad_ops brx_pad_ops = {\n\t.init_cfg = vsp1_entity_init_cfg,\n\t.enum_mbus_code = brx_enum_mbus_code,\n\t.enum_frame_size = brx_enum_frame_size,\n\t.get_fmt = vsp1_subdev_get_pad_format,\n\t.set_fmt = brx_set_format,\n\t.get_selection = brx_get_selection,\n\t.set_selection = brx_set_selection,\n};\n\nstatic const struct v4l2_subdev_ops brx_ops = {\n\t.pad    = &brx_pad_ops,\n};\n\n \n\nstatic void brx_configure_stream(struct vsp1_entity *entity,\n\t\t\t\t struct vsp1_pipeline *pipe,\n\t\t\t\t struct vsp1_dl_list *dl,\n\t\t\t\t struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_brx *brx = to_brx(&entity->subdev);\n\tstruct v4l2_mbus_framefmt *format;\n\tunsigned int flags;\n\tunsigned int i;\n\n\tformat = vsp1_entity_get_pad_format(&brx->entity, brx->entity.config,\n\t\t\t\t\t    brx->entity.source_pad);\n\n\t \n\n\t \n\tflags = pipe->output ? pipe->output->format.flags : 0;\n\tvsp1_brx_write(brx, dlb, VI6_BRU_INCTRL,\n\t\t       flags & V4L2_PIX_FMT_FLAG_PREMUL_ALPHA ?\n\t\t       0 : VI6_BRU_INCTRL_NRM);\n\n\t \n\tvsp1_brx_write(brx, dlb, VI6_BRU_VIRRPF_SIZE,\n\t\t       (format->width << VI6_BRU_VIRRPF_SIZE_HSIZE_SHIFT) |\n\t\t       (format->height << VI6_BRU_VIRRPF_SIZE_VSIZE_SHIFT));\n\tvsp1_brx_write(brx, dlb, VI6_BRU_VIRRPF_LOC, 0);\n\n\tvsp1_brx_write(brx, dlb, VI6_BRU_VIRRPF_COL, brx->bgcolor |\n\t\t       (0xff << VI6_BRU_VIRRPF_COL_A_SHIFT));\n\n\t \n\tif (entity->type == VSP1_ENTITY_BRU)\n\t\tvsp1_brx_write(brx, dlb, VI6_BRU_ROP,\n\t\t\t       VI6_BRU_ROP_DSTSEL_BRUIN(1) |\n\t\t\t       VI6_BRU_ROP_CROP(VI6_ROP_NOP) |\n\t\t\t       VI6_BRU_ROP_AROP(VI6_ROP_NOP));\n\n\tfor (i = 0; i < brx->entity.source_pad; ++i) {\n\t\tbool premultiplied = false;\n\t\tu32 ctrl = 0;\n\n\t\t \n\t\tif (brx->inputs[i].rpf) {\n\t\t\tctrl |= VI6_BRU_CTRL_RBC;\n\n\t\t\tpremultiplied = brx->inputs[i].rpf->format.flags\n\t\t\t\t      & V4L2_PIX_FMT_FLAG_PREMUL_ALPHA;\n\t\t} else {\n\t\t\tctrl |= VI6_BRU_CTRL_CROP(VI6_ROP_NOP)\n\t\t\t     |  VI6_BRU_CTRL_AROP(VI6_ROP_NOP);\n\t\t}\n\n\t\t \n\t\tif (i == 0)\n\t\t\tctrl |= VI6_BRU_CTRL_DSTSEL_VRPF;\n\n\t\t \n\t\tif (!(entity->type == VSP1_ENTITY_BRU && i == 1))\n\t\t\tctrl |= VI6_BRU_CTRL_SRCSEL_BRUIN(i);\n\n\t\tvsp1_brx_write(brx, dlb, VI6_BRU_CTRL(i), ctrl);\n\n\t\t \n\t\tvsp1_brx_write(brx, dlb, VI6_BRU_BLD(i),\n\t\t\t       VI6_BRU_BLD_CCMDX_255_SRC_A |\n\t\t\t       (premultiplied ? VI6_BRU_BLD_CCMDY_COEFY :\n\t\t\t\t\t\tVI6_BRU_BLD_CCMDY_SRC_A) |\n\t\t\t       VI6_BRU_BLD_ACMDX_255_SRC_A |\n\t\t\t       VI6_BRU_BLD_ACMDY_COEFY |\n\t\t\t       (0xff << VI6_BRU_BLD_COEFY_SHIFT));\n\t}\n}\n\nstatic const struct vsp1_entity_operations brx_entity_ops = {\n\t.configure_stream = brx_configure_stream,\n};\n\n \n\nstruct vsp1_brx *vsp1_brx_create(struct vsp1_device *vsp1,\n\t\t\t\t enum vsp1_entity_type type)\n{\n\tstruct vsp1_brx *brx;\n\tunsigned int num_pads;\n\tconst char *name;\n\tint ret;\n\n\tbrx = devm_kzalloc(vsp1->dev, sizeof(*brx), GFP_KERNEL);\n\tif (brx == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbrx->base = type == VSP1_ENTITY_BRU ? VI6_BRU_BASE : VI6_BRS_BASE;\n\tbrx->entity.ops = &brx_entity_ops;\n\tbrx->entity.type = type;\n\n\tif (type == VSP1_ENTITY_BRU) {\n\t\tnum_pads = vsp1->info->num_bru_inputs + 1;\n\t\tname = \"bru\";\n\t} else {\n\t\tnum_pads = 3;\n\t\tname = \"brs\";\n\t}\n\n\tret = vsp1_entity_init(vsp1, &brx->entity, name, num_pads, &brx_ops,\n\t\t\t       MEDIA_ENT_F_PROC_VIDEO_COMPOSER);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tv4l2_ctrl_handler_init(&brx->ctrls, 1);\n\tv4l2_ctrl_new_std(&brx->ctrls, &brx_ctrl_ops, V4L2_CID_BG_COLOR,\n\t\t\t  0, 0xffffff, 1, 0);\n\n\tbrx->bgcolor = 0;\n\n\tbrx->entity.subdev.ctrl_handler = &brx->ctrls;\n\n\tif (brx->ctrls.error) {\n\t\tdev_err(vsp1->dev, \"%s: failed to initialize controls\\n\", name);\n\t\tret = brx->ctrls.error;\n\t\tvsp1_entity_destroy(&brx->entity);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn brx;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}