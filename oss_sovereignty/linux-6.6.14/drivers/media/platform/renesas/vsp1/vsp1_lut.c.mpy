{
  "module_name": "vsp1_lut.c",
  "hash_id": "29e53269735f6c144a428730156989f62c6ebe7b6adb9e78042317e99579fa68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_lut.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gfp.h>\n\n#include <media/v4l2-subdev.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_dl.h\"\n#include \"vsp1_lut.h\"\n\n#define LUT_MIN_SIZE\t\t\t\t4U\n#define LUT_MAX_SIZE\t\t\t\t8190U\n\n#define LUT_SIZE\t\t\t\t256\n\n \n\nstatic inline void vsp1_lut_write(struct vsp1_lut *lut,\n\t\t\t\t  struct vsp1_dl_body *dlb, u32 reg, u32 data)\n{\n\tvsp1_dl_body_write(dlb, reg, data);\n}\n\n \n\n#define V4L2_CID_VSP1_LUT_TABLE\t\t\t(V4L2_CID_USER_BASE | 0x1001)\n\nstatic int lut_set_table(struct vsp1_lut *lut, struct v4l2_ctrl *ctrl)\n{\n\tstruct vsp1_dl_body *dlb;\n\tunsigned int i;\n\n\tdlb = vsp1_dl_body_get(lut->pool);\n\tif (!dlb)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < LUT_SIZE; ++i)\n\t\tvsp1_dl_body_write(dlb, VI6_LUT_TABLE + 4 * i,\n\t\t\t\t       ctrl->p_new.p_u32[i]);\n\n\tspin_lock_irq(&lut->lock);\n\tswap(lut->lut, dlb);\n\tspin_unlock_irq(&lut->lock);\n\n\tvsp1_dl_body_put(dlb);\n\treturn 0;\n}\n\nstatic int lut_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vsp1_lut *lut =\n\t\tcontainer_of(ctrl->handler, struct vsp1_lut, ctrls);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VSP1_LUT_TABLE:\n\t\tlut_set_table(lut, ctrl);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops lut_ctrl_ops = {\n\t.s_ctrl = lut_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config lut_table_control = {\n\t.ops = &lut_ctrl_ops,\n\t.id = V4L2_CID_VSP1_LUT_TABLE,\n\t.name = \"Look-Up Table\",\n\t.type = V4L2_CTRL_TYPE_U32,\n\t.min = 0x00000000,\n\t.max = 0x00ffffff,\n\t.step = 1,\n\t.def = 0,\n\t.dims = { LUT_SIZE },\n};\n\n \n\nstatic const unsigned int lut_codes[] = {\n\tMEDIA_BUS_FMT_ARGB8888_1X32,\n\tMEDIA_BUS_FMT_AHSV8888_1X32,\n\tMEDIA_BUS_FMT_AYUV8_1X32,\n};\n\nstatic int lut_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\treturn vsp1_subdev_enum_mbus_code(subdev, sd_state, code, lut_codes,\n\t\t\t\t\t  ARRAY_SIZE(lut_codes));\n}\n\nstatic int lut_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_frame_size_enum *fse)\n{\n\treturn vsp1_subdev_enum_frame_size(subdev, sd_state, fse,\n\t\t\t\t\t   LUT_MIN_SIZE,\n\t\t\t\t\t   LUT_MIN_SIZE, LUT_MAX_SIZE,\n\t\t\t\t\t   LUT_MAX_SIZE);\n}\n\nstatic int lut_set_format(struct v4l2_subdev *subdev,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\treturn vsp1_subdev_set_pad_format(subdev, sd_state, fmt, lut_codes,\n\t\t\t\t\t  ARRAY_SIZE(lut_codes),\n\t\t\t\t\t  LUT_MIN_SIZE, LUT_MIN_SIZE,\n\t\t\t\t\t  LUT_MAX_SIZE, LUT_MAX_SIZE);\n}\n\n \n\nstatic const struct v4l2_subdev_pad_ops lut_pad_ops = {\n\t.init_cfg = vsp1_entity_init_cfg,\n\t.enum_mbus_code = lut_enum_mbus_code,\n\t.enum_frame_size = lut_enum_frame_size,\n\t.get_fmt = vsp1_subdev_get_pad_format,\n\t.set_fmt = lut_set_format,\n};\n\nstatic const struct v4l2_subdev_ops lut_ops = {\n\t.pad    = &lut_pad_ops,\n};\n\n \n\nstatic void lut_configure_stream(struct vsp1_entity *entity,\n\t\t\t\t struct vsp1_pipeline *pipe,\n\t\t\t\t struct vsp1_dl_list *dl,\n\t\t\t\t struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_lut *lut = to_lut(&entity->subdev);\n\n\tvsp1_lut_write(lut, dlb, VI6_LUT_CTRL, VI6_LUT_CTRL_EN);\n}\n\nstatic void lut_configure_frame(struct vsp1_entity *entity,\n\t\t\t\tstruct vsp1_pipeline *pipe,\n\t\t\t\tstruct vsp1_dl_list *dl,\n\t\t\t\tstruct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_lut *lut = to_lut(&entity->subdev);\n\tstruct vsp1_dl_body *lut_dlb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lut->lock, flags);\n\tlut_dlb = lut->lut;\n\tlut->lut = NULL;\n\tspin_unlock_irqrestore(&lut->lock, flags);\n\n\tif (lut_dlb) {\n\t\tvsp1_dl_list_add_body(dl, lut_dlb);\n\n\t\t \n\t\tvsp1_dl_body_put(lut_dlb);\n\t}\n}\n\nstatic void lut_destroy(struct vsp1_entity *entity)\n{\n\tstruct vsp1_lut *lut = to_lut(&entity->subdev);\n\n\tvsp1_dl_body_pool_destroy(lut->pool);\n}\n\nstatic const struct vsp1_entity_operations lut_entity_ops = {\n\t.configure_stream = lut_configure_stream,\n\t.configure_frame = lut_configure_frame,\n\t.destroy = lut_destroy,\n};\n\n \n\nstruct vsp1_lut *vsp1_lut_create(struct vsp1_device *vsp1)\n{\n\tstruct vsp1_lut *lut;\n\tint ret;\n\n\tlut = devm_kzalloc(vsp1->dev, sizeof(*lut), GFP_KERNEL);\n\tif (lut == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&lut->lock);\n\n\tlut->entity.ops = &lut_entity_ops;\n\tlut->entity.type = VSP1_ENTITY_LUT;\n\n\tret = vsp1_entity_init(vsp1, &lut->entity, \"lut\", 2, &lut_ops,\n\t\t\t       MEDIA_ENT_F_PROC_VIDEO_LUT);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tlut->pool = vsp1_dl_body_pool_create(vsp1, 3, LUT_SIZE, 0);\n\tif (!lut->pool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tv4l2_ctrl_handler_init(&lut->ctrls, 1);\n\tv4l2_ctrl_new_custom(&lut->ctrls, &lut_table_control, NULL);\n\n\tlut->entity.subdev.ctrl_handler = &lut->ctrls;\n\n\tif (lut->ctrls.error) {\n\t\tdev_err(vsp1->dev, \"lut: failed to initialize controls\\n\");\n\t\tret = lut->ctrls.error;\n\t\tvsp1_entity_destroy(&lut->entity);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tv4l2_ctrl_handler_setup(&lut->ctrls);\n\n\treturn lut;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}