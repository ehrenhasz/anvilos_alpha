{
  "module_name": "vsp1_uif.c",
  "hash_id": "5a66d0a3eda694ccb3374075a4aad5b6c51cbd979060f41f4dca7a2c92b4e298",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_uif.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <linux/sys_soc.h>\n\n#include <media/media-entity.h>\n#include <media/v4l2-subdev.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_dl.h\"\n#include \"vsp1_entity.h\"\n#include \"vsp1_uif.h\"\n\n#define UIF_MIN_SIZE\t\t\t\t4U\n#define UIF_MAX_SIZE\t\t\t\t8190U\n\n \n\nstatic inline u32 vsp1_uif_read(struct vsp1_uif *uif, u32 reg)\n{\n\treturn vsp1_read(uif->entity.vsp1,\n\t\t\t uif->entity.index * VI6_UIF_OFFSET + reg);\n}\n\nstatic inline void vsp1_uif_write(struct vsp1_uif *uif,\n\t\t\t\t  struct vsp1_dl_body *dlb, u32 reg, u32 data)\n{\n\tvsp1_dl_body_write(dlb, reg + uif->entity.index * VI6_UIF_OFFSET, data);\n}\n\nu32 vsp1_uif_get_crc(struct vsp1_uif *uif)\n{\n\treturn vsp1_uif_read(uif, VI6_UIF_DISCOM_DOCMCCRCR);\n}\n\n \n\nstatic const unsigned int uif_codes[] = {\n\tMEDIA_BUS_FMT_ARGB8888_1X32,\n\tMEDIA_BUS_FMT_AHSV8888_1X32,\n\tMEDIA_BUS_FMT_AYUV8_1X32,\n};\n\nstatic int uif_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\treturn vsp1_subdev_enum_mbus_code(subdev, sd_state, code, uif_codes,\n\t\t\t\t\t  ARRAY_SIZE(uif_codes));\n}\n\nstatic int uif_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_frame_size_enum *fse)\n{\n\treturn vsp1_subdev_enum_frame_size(subdev, sd_state, fse,\n\t\t\t\t\t   UIF_MIN_SIZE,\n\t\t\t\t\t   UIF_MIN_SIZE, UIF_MAX_SIZE,\n\t\t\t\t\t   UIF_MAX_SIZE);\n}\n\nstatic int uif_set_format(struct v4l2_subdev *subdev,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\treturn vsp1_subdev_set_pad_format(subdev, sd_state, fmt, uif_codes,\n\t\t\t\t\t  ARRAY_SIZE(uif_codes),\n\t\t\t\t\t  UIF_MIN_SIZE, UIF_MIN_SIZE,\n\t\t\t\t\t  UIF_MAX_SIZE, UIF_MAX_SIZE);\n}\n\nstatic int uif_get_selection(struct v4l2_subdev *subdev,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct vsp1_uif *uif = to_uif(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tint ret = 0;\n\n\tif (sel->pad != UIF_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&uif->entity.lock);\n\n\tconfig = vsp1_entity_get_pad_config(&uif->entity, sd_state,\n\t\t\t\t\t    sel->which);\n\tif (!config) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tformat = vsp1_entity_get_pad_format(&uif->entity, config,\n\t\t\t\t\t\t    UIF_PAD_SINK);\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = format->width;\n\t\tsel->r.height = format->height;\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *vsp1_entity_get_pad_selection(&uif->entity, config,\n\t\t\t\t\t\t\tsel->pad, sel->target);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\ndone:\n\tmutex_unlock(&uif->entity.lock);\n\treturn ret;\n}\n\nstatic int uif_set_selection(struct v4l2_subdev *subdev,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct vsp1_uif *uif = to_uif(subdev);\n\tstruct v4l2_subdev_state *config;\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *selection;\n\tint ret = 0;\n\n\tif (sel->pad != UIF_PAD_SINK ||\n\t    sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&uif->entity.lock);\n\n\tconfig = vsp1_entity_get_pad_config(&uif->entity, sd_state,\n\t\t\t\t\t    sel->which);\n\tif (!config) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tformat = vsp1_entity_get_pad_format(&uif->entity, config, UIF_PAD_SINK);\n\n\tsel->r.left = clamp_t(unsigned int, sel->r.left, 0, format->width - 1);\n\tsel->r.top = clamp_t(unsigned int, sel->r.top, 0, format->height - 1);\n\tsel->r.width = clamp_t(unsigned int, sel->r.width, UIF_MIN_SIZE,\n\t\t\t       format->width - sel->r.left);\n\tsel->r.height = clamp_t(unsigned int, sel->r.height, UIF_MIN_SIZE,\n\t\t\t\tformat->height - sel->r.top);\n\n\t \n\tselection = vsp1_entity_get_pad_selection(&uif->entity, config,\n\t\t\t\t\t\t  sel->pad, V4L2_SEL_TGT_CROP);\n\t*selection = sel->r;\n\ndone:\n\tmutex_unlock(&uif->entity.lock);\n\treturn ret;\n}\n\n \n\nstatic const struct v4l2_subdev_pad_ops uif_pad_ops = {\n\t.init_cfg = vsp1_entity_init_cfg,\n\t.enum_mbus_code = uif_enum_mbus_code,\n\t.enum_frame_size = uif_enum_frame_size,\n\t.get_fmt = vsp1_subdev_get_pad_format,\n\t.set_fmt = uif_set_format,\n\t.get_selection = uif_get_selection,\n\t.set_selection = uif_set_selection,\n};\n\nstatic const struct v4l2_subdev_ops uif_ops = {\n\t.pad    = &uif_pad_ops,\n};\n\n \n\nstatic void uif_configure_stream(struct vsp1_entity *entity,\n\t\t\t\t struct vsp1_pipeline *pipe,\n\t\t\t\t struct vsp1_dl_list *dl,\n\t\t\t\t struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_uif *uif = to_uif(&entity->subdev);\n\tconst struct v4l2_rect *crop;\n\tunsigned int left;\n\tunsigned int width;\n\n\tvsp1_uif_write(uif, dlb, VI6_UIF_DISCOM_DOCMPMR,\n\t\t       VI6_UIF_DISCOM_DOCMPMR_SEL(9));\n\n\tcrop = vsp1_entity_get_pad_selection(entity, entity->config,\n\t\t\t\t\t     UIF_PAD_SINK, V4L2_SEL_TGT_CROP);\n\n\tleft = crop->left;\n\twidth = crop->width;\n\n\t \n\tif (uif->m3w_quirk) {\n\t\tleft /= 2;\n\t\twidth /= 2;\n\t}\n\n\tvsp1_uif_write(uif, dlb, VI6_UIF_DISCOM_DOCMSPXR, left);\n\tvsp1_uif_write(uif, dlb, VI6_UIF_DISCOM_DOCMSPYR, crop->top);\n\tvsp1_uif_write(uif, dlb, VI6_UIF_DISCOM_DOCMSZXR, width);\n\tvsp1_uif_write(uif, dlb, VI6_UIF_DISCOM_DOCMSZYR, crop->height);\n\n\tvsp1_uif_write(uif, dlb, VI6_UIF_DISCOM_DOCMCR,\n\t\t       VI6_UIF_DISCOM_DOCMCR_CMPR);\n}\n\nstatic const struct vsp1_entity_operations uif_entity_ops = {\n\t.configure_stream = uif_configure_stream,\n};\n\n \n\nstatic const struct soc_device_attribute vsp1_r8a7796[] = {\n\t{ .soc_id = \"r8a7796\" },\n\t{   }\n};\n\nstruct vsp1_uif *vsp1_uif_create(struct vsp1_device *vsp1, unsigned int index)\n{\n\tstruct vsp1_uif *uif;\n\tchar name[6];\n\tint ret;\n\n\tuif = devm_kzalloc(vsp1->dev, sizeof(*uif), GFP_KERNEL);\n\tif (!uif)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (soc_device_match(vsp1_r8a7796))\n\t\tuif->m3w_quirk = true;\n\n\tuif->entity.ops = &uif_entity_ops;\n\tuif->entity.type = VSP1_ENTITY_UIF;\n\tuif->entity.index = index;\n\n\t \n\tsprintf(name, \"uif.%u\", index + 4);\n\tret = vsp1_entity_init(vsp1, &uif->entity, name, 2, &uif_ops,\n\t\t\t       MEDIA_ENT_F_PROC_VIDEO_STATISTICS);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\treturn uif;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}