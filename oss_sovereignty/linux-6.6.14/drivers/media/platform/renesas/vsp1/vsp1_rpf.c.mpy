{
  "module_name": "vsp1_rpf.c",
  "hash_id": "686bb24dfa722bde375afe23963dfeb604ea65fd1e9a41fc9ca6fc2068a52c14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_rpf.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n\n#include <media/v4l2-subdev.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_dl.h\"\n#include \"vsp1_pipe.h\"\n#include \"vsp1_rwpf.h\"\n#include \"vsp1_video.h\"\n\n#define RPF_MAX_WIDTH\t\t\t\t8190\n#define RPF_MAX_HEIGHT\t\t\t\t8190\n\n \nstruct vsp1_extcmd_auto_fld_body {\n\tu32 top_y0;\n\tu32 bottom_y0;\n\tu32 top_c0;\n\tu32 bottom_c0;\n\tu32 top_c1;\n\tu32 bottom_c1;\n\tu32 reserved0;\n\tu32 reserved1;\n} __packed;\n\n \n\nstatic inline void vsp1_rpf_write(struct vsp1_rwpf *rpf,\n\t\t\t\t  struct vsp1_dl_body *dlb, u32 reg, u32 data)\n{\n\tvsp1_dl_body_write(dlb, reg + rpf->entity.index * VI6_RPF_OFFSET,\n\t\t\t       data);\n}\n\n \n\nstatic const struct v4l2_subdev_ops rpf_ops = {\n\t.pad    = &vsp1_rwpf_pad_ops,\n};\n\n \n\nstatic void rpf_configure_stream(struct vsp1_entity *entity,\n\t\t\t\t struct vsp1_pipeline *pipe,\n\t\t\t\t struct vsp1_dl_list *dl,\n\t\t\t\t struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_rwpf *rpf = to_rwpf(&entity->subdev);\n\tconst struct vsp1_format_info *fmtinfo = rpf->fmtinfo;\n\tconst struct v4l2_pix_format_mplane *format = &rpf->format;\n\tconst struct v4l2_mbus_framefmt *source_format;\n\tconst struct v4l2_mbus_framefmt *sink_format;\n\tunsigned int left = 0;\n\tunsigned int top = 0;\n\tu32 pstride;\n\tu32 infmt;\n\n\t \n\tpstride = format->plane_fmt[0].bytesperline\n\t\t<< VI6_RPF_SRCM_PSTRIDE_Y_SHIFT;\n\tif (format->num_planes > 1)\n\t\tpstride |= format->plane_fmt[1].bytesperline\n\t\t\t<< VI6_RPF_SRCM_PSTRIDE_C_SHIFT;\n\n\t \n\tif (pipe->interlaced)\n\t\tpstride *= 2;\n\n\tvsp1_rpf_write(rpf, dlb, VI6_RPF_SRCM_PSTRIDE, pstride);\n\n\t \n\tsink_format = vsp1_entity_get_pad_format(&rpf->entity,\n\t\t\t\t\t\t rpf->entity.config,\n\t\t\t\t\t\t RWPF_PAD_SINK);\n\tsource_format = vsp1_entity_get_pad_format(&rpf->entity,\n\t\t\t\t\t\t   rpf->entity.config,\n\t\t\t\t\t\t   RWPF_PAD_SOURCE);\n\n\tinfmt = VI6_RPF_INFMT_CIPM\n\t      | (fmtinfo->hwfmt << VI6_RPF_INFMT_RDFMT_SHIFT);\n\n\tif (fmtinfo->swap_yc)\n\t\tinfmt |= VI6_RPF_INFMT_SPYCS;\n\tif (fmtinfo->swap_uv)\n\t\tinfmt |= VI6_RPF_INFMT_SPUVS;\n\n\tif (sink_format->code != source_format->code)\n\t\tinfmt |= VI6_RPF_INFMT_CSC;\n\n\tvsp1_rpf_write(rpf, dlb, VI6_RPF_INFMT, infmt);\n\tvsp1_rpf_write(rpf, dlb, VI6_RPF_DSWAP, fmtinfo->swap);\n\n\tif (entity->vsp1->info->gen == 4) {\n\t\tu32 ext_infmt0;\n\t\tu32 ext_infmt1;\n\t\tu32 ext_infmt2;\n\n\t\tswitch (fmtinfo->fourcc) {\n\t\tcase V4L2_PIX_FMT_RGBX1010102:\n\t\t\text_infmt0 = VI6_RPF_EXT_INFMT0_BYPP_M1_RGB10;\n\t\t\text_infmt1 = VI6_RPF_EXT_INFMT1_PACK_CPOS(0, 10, 20, 0);\n\t\t\text_infmt2 = VI6_RPF_EXT_INFMT2_PACK_CLEN(10, 10, 10, 0);\n\t\t\tbreak;\n\n\t\tcase V4L2_PIX_FMT_RGBA1010102:\n\t\t\text_infmt0 = VI6_RPF_EXT_INFMT0_BYPP_M1_RGB10;\n\t\t\text_infmt1 = VI6_RPF_EXT_INFMT1_PACK_CPOS(0, 10, 20, 30);\n\t\t\text_infmt2 = VI6_RPF_EXT_INFMT2_PACK_CLEN(10, 10, 10, 2);\n\t\t\tbreak;\n\n\t\tcase V4L2_PIX_FMT_ARGB2101010:\n\t\t\text_infmt0 = VI6_RPF_EXT_INFMT0_BYPP_M1_RGB10;\n\t\t\text_infmt1 = VI6_RPF_EXT_INFMT1_PACK_CPOS(2, 12, 22, 0);\n\t\t\text_infmt2 = VI6_RPF_EXT_INFMT2_PACK_CLEN(10, 10, 10, 2);\n\t\t\tbreak;\n\n\t\tcase V4L2_PIX_FMT_Y210:\n\t\t\text_infmt0 = VI6_RPF_EXT_INFMT0_F2B |\n\t\t\t\t     VI6_RPF_EXT_INFMT0_IPBD_Y_10 |\n\t\t\t\t     VI6_RPF_EXT_INFMT0_IPBD_C_10;\n\t\t\text_infmt1 = 0x0;\n\t\t\text_infmt2 = 0x0;\n\t\t\tbreak;\n\n\t\tcase V4L2_PIX_FMT_Y212:\n\t\t\text_infmt0 = VI6_RPF_EXT_INFMT0_F2B |\n\t\t\t\t     VI6_RPF_EXT_INFMT0_IPBD_Y_12 |\n\t\t\t\t     VI6_RPF_EXT_INFMT0_IPBD_C_12;\n\t\t\text_infmt1 = 0x0;\n\t\t\text_infmt2 = 0x0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\text_infmt0 = 0;\n\t\t\text_infmt1 = 0;\n\t\t\text_infmt2 = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tvsp1_rpf_write(rpf, dlb, VI6_RPF_EXT_INFMT0, ext_infmt0);\n\t\tvsp1_rpf_write(rpf, dlb, VI6_RPF_EXT_INFMT1, ext_infmt1);\n\t\tvsp1_rpf_write(rpf, dlb, VI6_RPF_EXT_INFMT2, ext_infmt2);\n\t}\n\n\t \n\tif (pipe->brx) {\n\t\tconst struct v4l2_rect *compose;\n\n\t\tcompose = vsp1_entity_get_pad_selection(pipe->brx,\n\t\t\t\t\t\t\tpipe->brx->config,\n\t\t\t\t\t\t\trpf->brx_input,\n\t\t\t\t\t\t\tV4L2_SEL_TGT_COMPOSE);\n\t\tleft = compose->left;\n\t\ttop = compose->top;\n\t}\n\n\tif (pipe->interlaced)\n\t\ttop /= 2;\n\n\tvsp1_rpf_write(rpf, dlb, VI6_RPF_LOC,\n\t\t       (left << VI6_RPF_LOC_HCOORD_SHIFT) |\n\t\t       (top << VI6_RPF_LOC_VCOORD_SHIFT));\n\n\t \n\tvsp1_rpf_write(rpf, dlb, VI6_RPF_ALPH_SEL, VI6_RPF_ALPH_SEL_AEXT_EXT |\n\t\t       (fmtinfo->alpha ? VI6_RPF_ALPH_SEL_ASEL_PACKED\n\t\t\t\t       : VI6_RPF_ALPH_SEL_ASEL_FIXED));\n\n\tif (entity->vsp1->info->gen >= 3) {\n\t\tu32 mult;\n\n\t\tif (fmtinfo->alpha) {\n\t\t\t \n\t\t\tbool premultiplied = format->flags\n\t\t\t\t\t   & V4L2_PIX_FMT_FLAG_PREMUL_ALPHA;\n\n\t\t\tmult = VI6_RPF_MULT_ALPHA_A_MMD_RATIO\n\t\t\t     | (premultiplied ?\n\t\t\t\tVI6_RPF_MULT_ALPHA_P_MMD_RATIO :\n\t\t\t\tVI6_RPF_MULT_ALPHA_P_MMD_NONE);\n\t\t} else {\n\t\t\t \n\t\t\tmult = VI6_RPF_MULT_ALPHA_A_MMD_NONE\n\t\t\t     | VI6_RPF_MULT_ALPHA_P_MMD_NONE;\n\t\t}\n\n\t\trpf->mult_alpha = mult;\n\t}\n\n\tvsp1_rpf_write(rpf, dlb, VI6_RPF_MSK_CTRL, 0);\n\tvsp1_rpf_write(rpf, dlb, VI6_RPF_CKEY_CTRL, 0);\n\n}\n\nstatic void vsp1_rpf_configure_autofld(struct vsp1_rwpf *rpf,\n\t\t\t\t       struct vsp1_dl_list *dl)\n{\n\tconst struct v4l2_pix_format_mplane *format = &rpf->format;\n\tstruct vsp1_dl_ext_cmd *cmd;\n\tstruct vsp1_extcmd_auto_fld_body *auto_fld;\n\tu32 offset_y, offset_c;\n\n\tcmd = vsp1_dl_get_pre_cmd(dl);\n\tif (WARN_ONCE(!cmd, \"Failed to obtain an autofld cmd\"))\n\t\treturn;\n\n\t \n\tauto_fld = cmd->data;\n\tauto_fld = &auto_fld[rpf->entity.index];\n\n\tauto_fld->top_y0 = rpf->mem.addr[0];\n\tauto_fld->top_c0 = rpf->mem.addr[1];\n\tauto_fld->top_c1 = rpf->mem.addr[2];\n\n\toffset_y = format->plane_fmt[0].bytesperline;\n\toffset_c = format->plane_fmt[1].bytesperline;\n\n\tauto_fld->bottom_y0 = rpf->mem.addr[0] + offset_y;\n\tauto_fld->bottom_c0 = rpf->mem.addr[1] + offset_c;\n\tauto_fld->bottom_c1 = rpf->mem.addr[2] + offset_c;\n\n\tcmd->flags |= VI6_DL_EXT_AUTOFLD_INT | BIT(16 + rpf->entity.index);\n}\n\nstatic void rpf_configure_frame(struct vsp1_entity *entity,\n\t\t\t\tstruct vsp1_pipeline *pipe,\n\t\t\t\tstruct vsp1_dl_list *dl,\n\t\t\t\tstruct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_rwpf *rpf = to_rwpf(&entity->subdev);\n\n\tvsp1_rpf_write(rpf, dlb, VI6_RPF_VRTCOL_SET,\n\t\t       rpf->alpha << VI6_RPF_VRTCOL_SET_LAYA_SHIFT);\n\tvsp1_rpf_write(rpf, dlb, VI6_RPF_MULT_ALPHA, rpf->mult_alpha |\n\t\t       (rpf->alpha << VI6_RPF_MULT_ALPHA_RATIO_SHIFT));\n\n\tvsp1_pipeline_propagate_alpha(pipe, dlb, rpf->alpha);\n}\n\nstatic void rpf_configure_partition(struct vsp1_entity *entity,\n\t\t\t\t    struct vsp1_pipeline *pipe,\n\t\t\t\t    struct vsp1_dl_list *dl,\n\t\t\t\t    struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_rwpf *rpf = to_rwpf(&entity->subdev);\n\tstruct vsp1_rwpf_memory mem = rpf->mem;\n\tstruct vsp1_device *vsp1 = rpf->entity.vsp1;\n\tconst struct vsp1_format_info *fmtinfo = rpf->fmtinfo;\n\tconst struct v4l2_pix_format_mplane *format = &rpf->format;\n\tstruct v4l2_rect crop;\n\n\t \n\tcrop = *vsp1_rwpf_get_crop(rpf, rpf->entity.config);\n\n\t \n\tif (pipe->partitions > 1) {\n\t\tcrop.width = pipe->partition->rpf.width;\n\t\tcrop.left += pipe->partition->rpf.left;\n\t}\n\n\tif (pipe->interlaced) {\n\t\tcrop.height = round_down(crop.height / 2, fmtinfo->vsub);\n\t\tcrop.top = round_down(crop.top / 2, fmtinfo->vsub);\n\t}\n\n\tvsp1_rpf_write(rpf, dlb, VI6_RPF_SRC_BSIZE,\n\t\t       (crop.width << VI6_RPF_SRC_BSIZE_BHSIZE_SHIFT) |\n\t\t       (crop.height << VI6_RPF_SRC_BSIZE_BVSIZE_SHIFT));\n\tvsp1_rpf_write(rpf, dlb, VI6_RPF_SRC_ESIZE,\n\t\t       (crop.width << VI6_RPF_SRC_ESIZE_EHSIZE_SHIFT) |\n\t\t       (crop.height << VI6_RPF_SRC_ESIZE_EVSIZE_SHIFT));\n\n\tmem.addr[0] += crop.top * format->plane_fmt[0].bytesperline\n\t\t     + crop.left * fmtinfo->bpp[0] / 8;\n\n\tif (format->num_planes > 1) {\n\t\tunsigned int bpl = format->plane_fmt[1].bytesperline;\n\t\tunsigned int offset;\n\n\t\toffset = crop.top / fmtinfo->vsub * bpl\n\t\t       + crop.left / fmtinfo->hsub * fmtinfo->bpp[1] / 8;\n\t\tmem.addr[1] += offset;\n\t\tmem.addr[2] += offset;\n\t}\n\n\t \n\tif (vsp1->info->gen >= 3 && format->num_planes == 3 &&\n\t    fmtinfo->swap_uv)\n\t\tswap(mem.addr[1], mem.addr[2]);\n\n\t \n\tif (pipe->interlaced) {\n\t\tvsp1_rpf_configure_autofld(rpf, dl);\n\t} else {\n\t\tvsp1_rpf_write(rpf, dlb, VI6_RPF_SRCM_ADDR_Y, mem.addr[0]);\n\t\tvsp1_rpf_write(rpf, dlb, VI6_RPF_SRCM_ADDR_C0, mem.addr[1]);\n\t\tvsp1_rpf_write(rpf, dlb, VI6_RPF_SRCM_ADDR_C1, mem.addr[2]);\n\t}\n}\n\nstatic void rpf_partition(struct vsp1_entity *entity,\n\t\t\t  struct vsp1_pipeline *pipe,\n\t\t\t  struct vsp1_partition *partition,\n\t\t\t  unsigned int partition_idx,\n\t\t\t  struct vsp1_partition_window *window)\n{\n\tpartition->rpf = *window;\n}\n\nstatic const struct vsp1_entity_operations rpf_entity_ops = {\n\t.configure_stream = rpf_configure_stream,\n\t.configure_frame = rpf_configure_frame,\n\t.configure_partition = rpf_configure_partition,\n\t.partition = rpf_partition,\n};\n\n \n\nstruct vsp1_rwpf *vsp1_rpf_create(struct vsp1_device *vsp1, unsigned int index)\n{\n\tstruct vsp1_rwpf *rpf;\n\tchar name[6];\n\tint ret;\n\n\trpf = devm_kzalloc(vsp1->dev, sizeof(*rpf), GFP_KERNEL);\n\tif (rpf == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trpf->max_width = RPF_MAX_WIDTH;\n\trpf->max_height = RPF_MAX_HEIGHT;\n\n\trpf->entity.ops = &rpf_entity_ops;\n\trpf->entity.type = VSP1_ENTITY_RPF;\n\trpf->entity.index = index;\n\n\tsprintf(name, \"rpf.%u\", index);\n\tret = vsp1_entity_init(vsp1, &rpf->entity, name, 2, &rpf_ops,\n\t\t\t       MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tret = vsp1_rwpf_init_ctrls(rpf, 0);\n\tif (ret < 0) {\n\t\tdev_err(vsp1->dev, \"rpf%u: failed to initialize controls\\n\",\n\t\t\tindex);\n\t\tgoto error;\n\t}\n\n\tv4l2_ctrl_handler_setup(&rpf->ctrls);\n\n\treturn rpf;\n\nerror:\n\tvsp1_entity_destroy(&rpf->entity);\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}