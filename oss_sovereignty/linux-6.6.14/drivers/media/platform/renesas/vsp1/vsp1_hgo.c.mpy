{
  "module_name": "vsp1_hgo.c",
  "hash_id": "0434e7aa50e6d35707b450dd5fe85f6daa9240a0bc45d62ca8b75eb9ab10ec02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_hgo.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gfp.h>\n\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_dl.h\"\n#include \"vsp1_hgo.h\"\n\n#define HGO_DATA_SIZE\t\t\t\t((2 + 256) * 4)\n\n \n\nstatic inline u32 vsp1_hgo_read(struct vsp1_hgo *hgo, u32 reg)\n{\n\treturn vsp1_read(hgo->histo.entity.vsp1, reg);\n}\n\nstatic inline void vsp1_hgo_write(struct vsp1_hgo *hgo,\n\t\t\t\t  struct vsp1_dl_body *dlb, u32 reg, u32 data)\n{\n\tvsp1_dl_body_write(dlb, reg, data);\n}\n\n \n\nvoid vsp1_hgo_frame_end(struct vsp1_entity *entity)\n{\n\tstruct vsp1_hgo *hgo = to_hgo(&entity->subdev);\n\tstruct vsp1_histogram_buffer *buf;\n\tunsigned int i;\n\tsize_t size;\n\tu32 *data;\n\n\tbuf = vsp1_histogram_buffer_get(&hgo->histo);\n\tif (!buf)\n\t\treturn;\n\n\tdata = buf->addr;\n\n\tif (hgo->num_bins == 256) {\n\t\t*data++ = vsp1_hgo_read(hgo, VI6_HGO_G_MAXMIN);\n\t\t*data++ = vsp1_hgo_read(hgo, VI6_HGO_G_SUM);\n\n\t\tfor (i = 0; i < 256; ++i) {\n\t\t\tvsp1_write(hgo->histo.entity.vsp1,\n\t\t\t\t   VI6_HGO_EXT_HIST_ADDR, i);\n\t\t\t*data++ = vsp1_hgo_read(hgo, VI6_HGO_EXT_HIST_DATA);\n\t\t}\n\n\t\tsize = (2 + 256) * sizeof(u32);\n\t} else if (hgo->max_rgb) {\n\t\t*data++ = vsp1_hgo_read(hgo, VI6_HGO_G_MAXMIN);\n\t\t*data++ = vsp1_hgo_read(hgo, VI6_HGO_G_SUM);\n\n\t\tfor (i = 0; i < 64; ++i)\n\t\t\t*data++ = vsp1_hgo_read(hgo, VI6_HGO_G_HISTO(i));\n\n\t\tsize = (2 + 64) * sizeof(u32);\n\t} else {\n\t\t*data++ = vsp1_hgo_read(hgo, VI6_HGO_R_MAXMIN);\n\t\t*data++ = vsp1_hgo_read(hgo, VI6_HGO_G_MAXMIN);\n\t\t*data++ = vsp1_hgo_read(hgo, VI6_HGO_B_MAXMIN);\n\n\t\t*data++ = vsp1_hgo_read(hgo, VI6_HGO_R_SUM);\n\t\t*data++ = vsp1_hgo_read(hgo, VI6_HGO_G_SUM);\n\t\t*data++ = vsp1_hgo_read(hgo, VI6_HGO_B_SUM);\n\n\t\tfor (i = 0; i < 64; ++i) {\n\t\t\tdata[i] = vsp1_hgo_read(hgo, VI6_HGO_R_HISTO(i));\n\t\t\tdata[i+64] = vsp1_hgo_read(hgo, VI6_HGO_G_HISTO(i));\n\t\t\tdata[i+128] = vsp1_hgo_read(hgo, VI6_HGO_B_HISTO(i));\n\t\t}\n\n\t\tsize = (6 + 64 * 3) * sizeof(u32);\n\t}\n\n\tvsp1_histogram_buffer_complete(&hgo->histo, buf, size);\n}\n\n \n\n#define V4L2_CID_VSP1_HGO_MAX_RGB\t\t(V4L2_CID_USER_BASE | 0x1001)\n#define V4L2_CID_VSP1_HGO_NUM_BINS\t\t(V4L2_CID_USER_BASE | 0x1002)\n\nstatic const struct v4l2_ctrl_config hgo_max_rgb_control = {\n\t.id = V4L2_CID_VSP1_HGO_MAX_RGB,\n\t.name = \"Maximum RGB Mode\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.def = 0,\n\t.step = 1,\n\t.flags = V4L2_CTRL_FLAG_MODIFY_LAYOUT,\n};\n\nstatic const s64 hgo_num_bins[] = {\n\t64, 256,\n};\n\nstatic const struct v4l2_ctrl_config hgo_num_bins_control = {\n\t.id = V4L2_CID_VSP1_HGO_NUM_BINS,\n\t.name = \"Number of Bins\",\n\t.type = V4L2_CTRL_TYPE_INTEGER_MENU,\n\t.min = 0,\n\t.max = 1,\n\t.def = 0,\n\t.qmenu_int = hgo_num_bins,\n\t.flags = V4L2_CTRL_FLAG_MODIFY_LAYOUT,\n};\n\n \n\nstatic void hgo_configure_stream(struct vsp1_entity *entity,\n\t\t\t\t struct vsp1_pipeline *pipe,\n\t\t\t\t struct vsp1_dl_list *dl,\n\t\t\t\t struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_hgo *hgo = to_hgo(&entity->subdev);\n\tstruct v4l2_rect *compose;\n\tstruct v4l2_rect *crop;\n\tunsigned int hratio;\n\tunsigned int vratio;\n\n\tcrop = vsp1_entity_get_pad_selection(entity, entity->config,\n\t\t\t\t\t     HISTO_PAD_SINK, V4L2_SEL_TGT_CROP);\n\tcompose = vsp1_entity_get_pad_selection(entity, entity->config,\n\t\t\t\t\t\tHISTO_PAD_SINK,\n\t\t\t\t\t\tV4L2_SEL_TGT_COMPOSE);\n\n\tvsp1_hgo_write(hgo, dlb, VI6_HGO_REGRST, VI6_HGO_REGRST_RCLEA);\n\n\tvsp1_hgo_write(hgo, dlb, VI6_HGO_OFFSET,\n\t\t       (crop->left << VI6_HGO_OFFSET_HOFFSET_SHIFT) |\n\t\t       (crop->top << VI6_HGO_OFFSET_VOFFSET_SHIFT));\n\tvsp1_hgo_write(hgo, dlb, VI6_HGO_SIZE,\n\t\t       (crop->width << VI6_HGO_SIZE_HSIZE_SHIFT) |\n\t\t       (crop->height << VI6_HGO_SIZE_VSIZE_SHIFT));\n\n\tmutex_lock(hgo->ctrls.handler.lock);\n\thgo->max_rgb = hgo->ctrls.max_rgb->cur.val;\n\tif (hgo->ctrls.num_bins)\n\t\thgo->num_bins = hgo_num_bins[hgo->ctrls.num_bins->cur.val];\n\tmutex_unlock(hgo->ctrls.handler.lock);\n\n\thratio = crop->width * 2 / compose->width / 3;\n\tvratio = crop->height * 2 / compose->height / 3;\n\tvsp1_hgo_write(hgo, dlb, VI6_HGO_MODE,\n\t\t       (hgo->num_bins == 256 ? VI6_HGO_MODE_STEP : 0) |\n\t\t       (hgo->max_rgb ? VI6_HGO_MODE_MAXRGB : 0) |\n\t\t       (hratio << VI6_HGO_MODE_HRATIO_SHIFT) |\n\t\t       (vratio << VI6_HGO_MODE_VRATIO_SHIFT));\n}\n\nstatic const struct vsp1_entity_operations hgo_entity_ops = {\n\t.configure_stream = hgo_configure_stream,\n\t.destroy = vsp1_histogram_destroy,\n};\n\n \n\nstatic const unsigned int hgo_mbus_formats[] = {\n\tMEDIA_BUS_FMT_AYUV8_1X32,\n\tMEDIA_BUS_FMT_ARGB8888_1X32,\n\tMEDIA_BUS_FMT_AHSV8888_1X32,\n};\n\nstruct vsp1_hgo *vsp1_hgo_create(struct vsp1_device *vsp1)\n{\n\tstruct vsp1_hgo *hgo;\n\tint ret;\n\n\thgo = devm_kzalloc(vsp1->dev, sizeof(*hgo), GFP_KERNEL);\n\tif (hgo == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tv4l2_ctrl_handler_init(&hgo->ctrls.handler,\n\t\t\t       vsp1->info->gen >= 3 ? 2 : 1);\n\thgo->ctrls.max_rgb = v4l2_ctrl_new_custom(&hgo->ctrls.handler,\n\t\t\t\t\t\t  &hgo_max_rgb_control, NULL);\n\tif (vsp1->info->gen >= 3)\n\t\thgo->ctrls.num_bins =\n\t\t\tv4l2_ctrl_new_custom(&hgo->ctrls.handler,\n\t\t\t\t\t     &hgo_num_bins_control, NULL);\n\n\thgo->max_rgb = false;\n\thgo->num_bins = 64;\n\n\thgo->histo.entity.subdev.ctrl_handler = &hgo->ctrls.handler;\n\n\t \n\tret = vsp1_histogram_init(vsp1, &hgo->histo, VSP1_ENTITY_HGO, \"hgo\",\n\t\t\t\t  &hgo_entity_ops, hgo_mbus_formats,\n\t\t\t\t  ARRAY_SIZE(hgo_mbus_formats),\n\t\t\t\t  HGO_DATA_SIZE, V4L2_META_FMT_VSP1_HGO);\n\tif (ret < 0) {\n\t\tvsp1_entity_destroy(&hgo->histo.entity);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn hgo;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}