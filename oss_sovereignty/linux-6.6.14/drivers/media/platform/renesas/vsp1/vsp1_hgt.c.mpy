{
  "module_name": "vsp1_hgt.c",
  "hash_id": "97ca69d9c48b8f37e2a7ac3c80acab9cd2695a96b93c0c4a8f9d1bb9c7c51c38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/renesas/vsp1/vsp1_hgt.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gfp.h>\n\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"vsp1.h\"\n#include \"vsp1_dl.h\"\n#include \"vsp1_hgt.h\"\n\n#define HGT_DATA_SIZE\t\t\t\t((2 +  6 * 32) * 4)\n\n \n\nstatic inline u32 vsp1_hgt_read(struct vsp1_hgt *hgt, u32 reg)\n{\n\treturn vsp1_read(hgt->histo.entity.vsp1, reg);\n}\n\nstatic inline void vsp1_hgt_write(struct vsp1_hgt *hgt,\n\t\t\t\t  struct vsp1_dl_body *dlb, u32 reg, u32 data)\n{\n\tvsp1_dl_body_write(dlb, reg, data);\n}\n\n \n\nvoid vsp1_hgt_frame_end(struct vsp1_entity *entity)\n{\n\tstruct vsp1_hgt *hgt = to_hgt(&entity->subdev);\n\tstruct vsp1_histogram_buffer *buf;\n\tunsigned int m;\n\tunsigned int n;\n\tu32 *data;\n\n\tbuf = vsp1_histogram_buffer_get(&hgt->histo);\n\tif (!buf)\n\t\treturn;\n\n\tdata = buf->addr;\n\n\t*data++ = vsp1_hgt_read(hgt, VI6_HGT_MAXMIN);\n\t*data++ = vsp1_hgt_read(hgt, VI6_HGT_SUM);\n\n\tfor (m = 0; m < 6; ++m)\n\t\tfor (n = 0; n < 32; ++n)\n\t\t\t*data++ = vsp1_hgt_read(hgt, VI6_HGT_HISTO(m, n));\n\n\tvsp1_histogram_buffer_complete(&hgt->histo, buf, HGT_DATA_SIZE);\n}\n\n \n\n#define V4L2_CID_VSP1_HGT_HUE_AREAS\t(V4L2_CID_USER_BASE | 0x1001)\n\nstatic int hgt_hue_areas_try_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tconst u8 *values = ctrl->p_new.p_u8;\n\tunsigned int i;\n\n\t \n\tfor (i = 1; i < (HGT_NUM_HUE_AREAS * 2) - 1; ++i) {\n\t\tif (values[i] > values[i+1])\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (values[0] > values[1] && values[11] > values[0])\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hgt_hue_areas_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vsp1_hgt *hgt = container_of(ctrl->handler, struct vsp1_hgt,\n\t\t\t\t\t    ctrls);\n\n\tmemcpy(hgt->hue_areas, ctrl->p_new.p_u8, sizeof(hgt->hue_areas));\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops hgt_hue_areas_ctrl_ops = {\n\t.try_ctrl = hgt_hue_areas_try_ctrl,\n\t.s_ctrl = hgt_hue_areas_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config hgt_hue_areas = {\n\t.ops = &hgt_hue_areas_ctrl_ops,\n\t.id = V4L2_CID_VSP1_HGT_HUE_AREAS,\n\t.name = \"Boundary Values for Hue Area\",\n\t.type = V4L2_CTRL_TYPE_U8,\n\t.min = 0,\n\t.max = 255,\n\t.def = 0,\n\t.step = 1,\n\t.dims = { 12 },\n};\n\n \n\nstatic void hgt_configure_stream(struct vsp1_entity *entity,\n\t\t\t\t struct vsp1_pipeline *pipe,\n\t\t\t\t struct vsp1_dl_list *dl,\n\t\t\t\t struct vsp1_dl_body *dlb)\n{\n\tstruct vsp1_hgt *hgt = to_hgt(&entity->subdev);\n\tstruct v4l2_rect *compose;\n\tstruct v4l2_rect *crop;\n\tunsigned int hratio;\n\tunsigned int vratio;\n\tu8 lower;\n\tu8 upper;\n\tunsigned int i;\n\n\tcrop = vsp1_entity_get_pad_selection(entity, entity->config,\n\t\t\t\t\t     HISTO_PAD_SINK, V4L2_SEL_TGT_CROP);\n\tcompose = vsp1_entity_get_pad_selection(entity, entity->config,\n\t\t\t\t\t\tHISTO_PAD_SINK,\n\t\t\t\t\t\tV4L2_SEL_TGT_COMPOSE);\n\n\tvsp1_hgt_write(hgt, dlb, VI6_HGT_REGRST, VI6_HGT_REGRST_RCLEA);\n\n\tvsp1_hgt_write(hgt, dlb, VI6_HGT_OFFSET,\n\t\t       (crop->left << VI6_HGT_OFFSET_HOFFSET_SHIFT) |\n\t\t       (crop->top << VI6_HGT_OFFSET_VOFFSET_SHIFT));\n\tvsp1_hgt_write(hgt, dlb, VI6_HGT_SIZE,\n\t\t       (crop->width << VI6_HGT_SIZE_HSIZE_SHIFT) |\n\t\t       (crop->height << VI6_HGT_SIZE_VSIZE_SHIFT));\n\n\tmutex_lock(hgt->ctrls.lock);\n\tfor (i = 0; i < HGT_NUM_HUE_AREAS; ++i) {\n\t\tlower = hgt->hue_areas[i*2 + 0];\n\t\tupper = hgt->hue_areas[i*2 + 1];\n\t\tvsp1_hgt_write(hgt, dlb, VI6_HGT_HUE_AREA(i),\n\t\t\t       (lower << VI6_HGT_HUE_AREA_LOWER_SHIFT) |\n\t\t\t       (upper << VI6_HGT_HUE_AREA_UPPER_SHIFT));\n\t}\n\tmutex_unlock(hgt->ctrls.lock);\n\n\thratio = crop->width * 2 / compose->width / 3;\n\tvratio = crop->height * 2 / compose->height / 3;\n\tvsp1_hgt_write(hgt, dlb, VI6_HGT_MODE,\n\t\t       (hratio << VI6_HGT_MODE_HRATIO_SHIFT) |\n\t\t       (vratio << VI6_HGT_MODE_VRATIO_SHIFT));\n}\n\nstatic const struct vsp1_entity_operations hgt_entity_ops = {\n\t.configure_stream = hgt_configure_stream,\n\t.destroy = vsp1_histogram_destroy,\n};\n\n \n\nstatic const unsigned int hgt_mbus_formats[] = {\n\tMEDIA_BUS_FMT_AHSV8888_1X32,\n};\n\nstruct vsp1_hgt *vsp1_hgt_create(struct vsp1_device *vsp1)\n{\n\tstruct vsp1_hgt *hgt;\n\tint ret;\n\n\thgt = devm_kzalloc(vsp1->dev, sizeof(*hgt), GFP_KERNEL);\n\tif (hgt == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tv4l2_ctrl_handler_init(&hgt->ctrls, 1);\n\tv4l2_ctrl_new_custom(&hgt->ctrls, &hgt_hue_areas, NULL);\n\n\thgt->histo.entity.subdev.ctrl_handler = &hgt->ctrls;\n\n\t \n\tret = vsp1_histogram_init(vsp1, &hgt->histo, VSP1_ENTITY_HGT, \"hgt\",\n\t\t\t\t  &hgt_entity_ops, hgt_mbus_formats,\n\t\t\t\t  ARRAY_SIZE(hgt_mbus_formats),\n\t\t\t\t  HGT_DATA_SIZE, V4L2_META_FMT_VSP1_HGT);\n\tif (ret < 0) {\n\t\tvsp1_entity_destroy(&hgt->histo.entity);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tv4l2_ctrl_handler_setup(&hgt->ctrls);\n\n\treturn hgt;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}