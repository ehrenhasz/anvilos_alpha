{
  "module_name": "microchip-sama7g5-isc.c",
  "hash_id": "1a13fb894e9925eac3bef9d5d837445b959fe142f11e638e2100456f0ba7e35b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/microchip/microchip-sama7g5-isc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"microchip-isc-regs.h\"\n#include \"microchip-isc.h\"\n\n#define ISC_SAMA7G5_MAX_SUPPORT_WIDTH   3264\n#define ISC_SAMA7G5_MAX_SUPPORT_HEIGHT  2464\n\n#define ISC_SAMA7G5_PIPELINE \\\n\t(WB_ENABLE | CFA_ENABLE | CC_ENABLE | GAM_ENABLES | CSC_ENABLE | \\\n\tCBC_ENABLE | SUB422_ENABLE | SUB420_ENABLE)\n\n \nstatic const struct isc_format sama7g5_controller_formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_ARGB444,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_ARGB555,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_ABGR32,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_XBGR32,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV420,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_UYVY,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_VYUY,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV422P,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_GREY,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_Y10,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_Y16,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG8,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB8,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR10,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG10,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG10,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB10,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR12,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG12,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG12,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB12,\n\t\t.raw\t\t= true,\n\t},\n};\n\n \nstatic struct isc_format sama7g5_formats_list[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_BGBG,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_GBGB,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_GRGR,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_RGRG,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TEN,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_RGRG,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TEN,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_GBGB,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TEN,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_GRGR,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TEN,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_RGRG,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR12,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TWELVE,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_BGBG,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG12,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TWELVE,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_GBGB,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG12,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TWELVE,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_GRGR,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB12,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TWELVE,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_RGRG,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_GREY,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_Y8_1X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_UYVY,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB565_2X8_LE,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_Y10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_Y10_1X10,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TEN,\n\t},\n};\n\nstatic void isc_sama7g5_config_csc(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\n\t \n\tregmap_write(regmap, ISC_CSC_YR_YG + isc->offsets.csc,\n\t\t     0x42 | (0x81 << 16));\n\tregmap_write(regmap, ISC_CSC_YB_OY + isc->offsets.csc,\n\t\t     0x19 | (0x10 << 16));\n\tregmap_write(regmap, ISC_CSC_CBR_CBG + isc->offsets.csc,\n\t\t     0xFDA | (0xFB6 << 16));\n\tregmap_write(regmap, ISC_CSC_CBB_OCB + isc->offsets.csc,\n\t\t     0x70 | (0x80 << 16));\n\tregmap_write(regmap, ISC_CSC_CRR_CRG + isc->offsets.csc,\n\t\t     0x70 | (0xFA2 << 16));\n\tregmap_write(regmap, ISC_CSC_CRB_OCR + isc->offsets.csc,\n\t\t     0xFEE | (0x80 << 16));\n}\n\nstatic void isc_sama7g5_config_cbc(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\n\t \n\tregmap_write(regmap, ISC_CBC_BRIGHT + isc->offsets.cbc, isc->ctrls.brightness);\n\tregmap_write(regmap, ISC_CBC_CONTRAST + isc->offsets.cbc, isc->ctrls.contrast);\n\t \n\tregmap_write(regmap, ISC_CBCHS_HUE, 0);\n\tregmap_write(regmap, ISC_CBCHS_SAT, (1 << 4));\n}\n\nstatic void isc_sama7g5_config_cc(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\n\t \n\tregmap_write(regmap, ISC_CC_RR_RG, (1 << 8));\n\tregmap_write(regmap, ISC_CC_RB_OR, 0);\n\tregmap_write(regmap, ISC_CC_GR_GG, (1 << 8) << 16);\n\tregmap_write(regmap, ISC_CC_GB_OG, 0);\n\tregmap_write(regmap, ISC_CC_BR_BG, 0);\n\tregmap_write(regmap, ISC_CC_BB_OB, (1 << 8));\n}\n\nstatic void isc_sama7g5_config_ctrls(struct isc_device *isc,\n\t\t\t\t     const struct v4l2_ctrl_ops *ops)\n{\n\tstruct isc_ctrls *ctrls = &isc->ctrls;\n\tstruct v4l2_ctrl_handler *hdl = &ctrls->handler;\n\n\tctrls->contrast = 16;\n\n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_CONTRAST, -2048, 2047, 1, 16);\n}\n\nstatic void isc_sama7g5_config_dpc(struct isc_device *isc)\n{\n\tu32 bay_cfg = isc->config.sd_format->cfa_baycfg;\n\tstruct regmap *regmap = isc->regmap;\n\n\tregmap_update_bits(regmap, ISC_DPC_CFG, ISC_DPC_CFG_BLOFF_MASK,\n\t\t\t   (64 << ISC_DPC_CFG_BLOFF_SHIFT));\n\tregmap_update_bits(regmap, ISC_DPC_CFG, ISC_DPC_CFG_BAYCFG_MASK,\n\t\t\t   (bay_cfg << ISC_DPC_CFG_BAYCFG_SHIFT));\n}\n\nstatic void isc_sama7g5_config_gam(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\n\tregmap_update_bits(regmap, ISC_GAM_CTRL, ISC_GAM_CTRL_BIPART,\n\t\t\t   ISC_GAM_CTRL_BIPART);\n}\n\nstatic void isc_sama7g5_config_rlp(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\tu32 rlp_mode = isc->config.rlp_cfg_mode;\n\n\tregmap_update_bits(regmap, ISC_RLP_CFG + isc->offsets.rlp,\n\t\t\t   ISC_RLP_CFG_MODE_MASK | ISC_RLP_CFG_LSH |\n\t\t\t   ISC_RLP_CFG_YMODE_MASK, rlp_mode);\n}\n\nstatic void isc_sama7g5_adapt_pipeline(struct isc_device *isc)\n{\n\tisc->try_config.bits_pipeline &= ISC_SAMA7G5_PIPELINE;\n}\n\n \nstatic const u32 isc_sama7g5_gamma_table[][GAMMA_ENTRIES] = {\n\t \n\t{\n\t      0x980,  0x4c0320,  0x650260,  0x7801e0,  0x8701a0,  0x940180,\n\t   0xa00160,  0xab0120,  0xb40120,  0xbd0120,  0xc60100,  0xce0100,\n\t   0xd600e0,  0xdd00e0,  0xe400e0,  0xeb00c0,  0xf100c0,  0xf700c0,\n\t   0xfd00c0, 0x10300a0, 0x10800c0, 0x10e00a0, 0x11300a0, 0x11800a0,\n\t  0x11d00a0, 0x12200a0, 0x12700a0, 0x12c0080, 0x13000a0, 0x1350080,\n\t  0x13900a0, 0x13e0080, 0x1420076, 0x17d0062, 0x1ae0054, 0x1d8004a,\n\t  0x1fd0044, 0x21f003e, 0x23e003a, 0x25b0036, 0x2760032, 0x28f0030,\n\t  0x2a7002e, 0x2be002c, 0x2d4002c, 0x2ea0028, 0x2fe0028, 0x3120026,\n\t  0x3250024, 0x3370024, 0x3490022, 0x35a0022, 0x36b0020, 0x37b0020,\n\t  0x38b0020, 0x39b001e, 0x3aa001e, 0x3b9001c, 0x3c7001c, 0x3d5001c,\n\t  0x3e3001c, 0x3f1001c, 0x3ff001a, 0x40c001a },\n};\n\nstatic int xisc_parse_dt(struct device *dev, struct isc_device *isc)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *epn = NULL;\n\tstruct isc_subdev_entity *subdev_entity;\n\tunsigned int flags;\n\tint ret;\n\tbool mipi_mode;\n\n\tINIT_LIST_HEAD(&isc->subdev_entities);\n\n\tmipi_mode = of_property_read_bool(np, \"microchip,mipi-mode\");\n\n\twhile (1) {\n\t\tstruct v4l2_fwnode_endpoint v4l2_epn = { .bus_type = 0 };\n\n\t\tepn = of_graph_get_next_endpoint(np, epn);\n\t\tif (!epn)\n\t\t\treturn 0;\n\n\t\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(epn),\n\t\t\t\t\t\t &v4l2_epn);\n\t\tif (ret) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(dev, \"Could not parse the endpoint\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tsubdev_entity = devm_kzalloc(dev, sizeof(*subdev_entity),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!subdev_entity) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tsubdev_entity->epn = epn;\n\n\t\tflags = v4l2_epn.bus.parallel.flags;\n\n\t\tif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\n\t\t\tsubdev_entity->pfe_cfg0 = ISC_PFE_CFG0_HPOL_LOW;\n\n\t\tif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\n\t\t\tsubdev_entity->pfe_cfg0 |= ISC_PFE_CFG0_VPOL_LOW;\n\n\t\tif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\n\t\t\tsubdev_entity->pfe_cfg0 |= ISC_PFE_CFG0_PPOL_LOW;\n\n\t\tif (v4l2_epn.bus_type == V4L2_MBUS_BT656)\n\t\t\tsubdev_entity->pfe_cfg0 |= ISC_PFE_CFG0_CCIR_CRC |\n\t\t\t\t\tISC_PFE_CFG0_CCIR656;\n\n\t\tif (mipi_mode)\n\t\t\tsubdev_entity->pfe_cfg0 |= ISC_PFE_CFG0_MIPI;\n\n\t\tlist_add_tail(&subdev_entity->list, &isc->subdev_entities);\n\t}\n\tof_node_put(epn);\n\n\treturn ret;\n}\n\nstatic int microchip_xisc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct isc_device *isc;\n\tvoid __iomem *io_base;\n\tstruct isc_subdev_entity *subdev_entity;\n\tint irq;\n\tint ret;\n\tu32 ver;\n\n\tisc = devm_kzalloc(dev, sizeof(*isc), GFP_KERNEL);\n\tif (!isc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, isc);\n\tisc->dev = dev;\n\n\tio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\tisc->regmap = devm_regmap_init_mmio(dev, io_base, &microchip_isc_regmap_config);\n\tif (IS_ERR(isc->regmap)) {\n\t\tret = PTR_ERR(isc->regmap);\n\t\tdev_err(dev, \"failed to init register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, microchip_isc_interrupt, 0,\n\t\t\t       \"microchip-sama7g5-xisc\", isc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't register ISR for IRQ %u (ret=%i)\\n\",\n\t\t\tirq, ret);\n\t\treturn ret;\n\t}\n\n\tisc->gamma_table = isc_sama7g5_gamma_table;\n\tisc->gamma_max = 0;\n\n\tisc->max_width = ISC_SAMA7G5_MAX_SUPPORT_WIDTH;\n\tisc->max_height = ISC_SAMA7G5_MAX_SUPPORT_HEIGHT;\n\n\tisc->config_dpc = isc_sama7g5_config_dpc;\n\tisc->config_csc = isc_sama7g5_config_csc;\n\tisc->config_cbc = isc_sama7g5_config_cbc;\n\tisc->config_cc = isc_sama7g5_config_cc;\n\tisc->config_gam = isc_sama7g5_config_gam;\n\tisc->config_rlp = isc_sama7g5_config_rlp;\n\tisc->config_ctrls = isc_sama7g5_config_ctrls;\n\n\tisc->adapt_pipeline = isc_sama7g5_adapt_pipeline;\n\n\tisc->offsets.csc = ISC_SAMA7G5_CSC_OFFSET;\n\tisc->offsets.cbc = ISC_SAMA7G5_CBC_OFFSET;\n\tisc->offsets.sub422 = ISC_SAMA7G5_SUB422_OFFSET;\n\tisc->offsets.sub420 = ISC_SAMA7G5_SUB420_OFFSET;\n\tisc->offsets.rlp = ISC_SAMA7G5_RLP_OFFSET;\n\tisc->offsets.his = ISC_SAMA7G5_HIS_OFFSET;\n\tisc->offsets.dma = ISC_SAMA7G5_DMA_OFFSET;\n\tisc->offsets.version = ISC_SAMA7G5_VERSION_OFFSET;\n\tisc->offsets.his_entry = ISC_SAMA7G5_HIS_ENTRY_OFFSET;\n\n\tisc->controller_formats = sama7g5_controller_formats;\n\tisc->controller_formats_size = ARRAY_SIZE(sama7g5_controller_formats);\n\tisc->formats_list = sama7g5_formats_list;\n\tisc->formats_list_size = ARRAY_SIZE(sama7g5_formats_list);\n\n\t \n\tisc->dcfg = ISC_DCFG_YMBSIZE_BEATS32 | ISC_DCFG_CMBSIZE_BEATS32;\n\n\t \n\tisc->ispck_required = false;\n\n\tret = microchip_isc_pipeline_init(isc);\n\tif (ret)\n\t\treturn ret;\n\n\tisc->hclock = devm_clk_get(dev, \"hclock\");\n\tif (IS_ERR(isc->hclock)) {\n\t\tret = PTR_ERR(isc->hclock);\n\t\tdev_err(dev, \"failed to get hclock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(isc->hclock);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable hclock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = microchip_isc_clk_init(isc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init isc clock: %d\\n\", ret);\n\t\tgoto unprepare_hclk;\n\t}\n\n\tret = v4l2_device_register(dev, &isc->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to register v4l2 device.\\n\");\n\t\tgoto unprepare_hclk;\n\t}\n\n\tret = xisc_parse_dt(dev, isc);\n\tif (ret) {\n\t\tdev_err(dev, \"fail to parse device tree\\n\");\n\t\tgoto unregister_v4l2_device;\n\t}\n\n\tif (list_empty(&isc->subdev_entities)) {\n\t\tdev_err(dev, \"no subdev found\\n\");\n\t\tret = -ENODEV;\n\t\tgoto unregister_v4l2_device;\n\t}\n\n\tlist_for_each_entry(subdev_entity, &isc->subdev_entities, list) {\n\t\tstruct v4l2_async_connection *asd;\n\t\tstruct fwnode_handle *fwnode =\n\t\t\tof_fwnode_handle(subdev_entity->epn);\n\n\t\tv4l2_async_nf_init(&subdev_entity->notifier, &isc->v4l2_dev);\n\n\t\tasd = v4l2_async_nf_add_fwnode_remote(&subdev_entity->notifier,\n\t\t\t\t\t\t      fwnode,\n\t\t\t\t\t\t      struct v4l2_async_connection);\n\n\t\tof_node_put(subdev_entity->epn);\n\t\tsubdev_entity->epn = NULL;\n\n\t\tif (IS_ERR(asd)) {\n\t\t\tret = PTR_ERR(asd);\n\t\t\tgoto cleanup_subdev;\n\t\t}\n\n\t\tsubdev_entity->notifier.ops = &microchip_isc_async_ops;\n\n\t\tret = v4l2_async_nf_register(&subdev_entity->notifier);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"fail to register async notifier\\n\");\n\t\t\tgoto cleanup_subdev;\n\t\t}\n\n\t\tif (video_is_registered(&isc->video_dev))\n\t\t\tbreak;\n\t}\n\n\tregmap_read(isc->regmap, ISC_VERSION + isc->offsets.version, &ver);\n\n\tret = isc_mc_init(isc, ver);\n\tif (ret < 0)\n\t\tgoto isc_probe_mc_init_err;\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_request_idle(dev);\n\n\tdev_info(dev, \"Microchip XISC version %x\\n\", ver);\n\n\treturn 0;\n\nisc_probe_mc_init_err:\n\tisc_mc_cleanup(isc);\n\ncleanup_subdev:\n\tmicrochip_isc_subdev_cleanup(isc);\n\nunregister_v4l2_device:\n\tv4l2_device_unregister(&isc->v4l2_dev);\n\nunprepare_hclk:\n\tclk_disable_unprepare(isc->hclock);\n\n\tmicrochip_isc_clk_cleanup(isc);\n\n\treturn ret;\n}\n\nstatic void microchip_xisc_remove(struct platform_device *pdev)\n{\n\tstruct isc_device *isc = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tisc_mc_cleanup(isc);\n\n\tmicrochip_isc_subdev_cleanup(isc);\n\n\tv4l2_device_unregister(&isc->v4l2_dev);\n\n\tclk_disable_unprepare(isc->hclock);\n\n\tmicrochip_isc_clk_cleanup(isc);\n}\n\nstatic int __maybe_unused xisc_runtime_suspend(struct device *dev)\n{\n\tstruct isc_device *isc = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(isc->hclock);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused xisc_runtime_resume(struct device *dev)\n{\n\tstruct isc_device *isc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(isc->hclock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops microchip_xisc_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(xisc_runtime_suspend, xisc_runtime_resume, NULL)\n};\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id microchip_xisc_of_match[] = {\n\t{ .compatible = \"microchip,sama7g5-isc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, microchip_xisc_of_match);\n#endif\n\nstatic struct platform_driver microchip_xisc_driver = {\n\t.probe\t= microchip_xisc_probe,\n\t.remove_new = microchip_xisc_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"microchip-sama7g5-xisc\",\n\t\t.pm\t\t= &microchip_xisc_dev_pm_ops,\n\t\t.of_match_table = of_match_ptr(microchip_xisc_of_match),\n\t},\n};\n\nmodule_platform_driver(microchip_xisc_driver);\n\nMODULE_AUTHOR(\"Eugen Hristev <eugen.hristev@microchip.com>\");\nMODULE_DESCRIPTION(\"The V4L2 driver for Microchip-XISC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}