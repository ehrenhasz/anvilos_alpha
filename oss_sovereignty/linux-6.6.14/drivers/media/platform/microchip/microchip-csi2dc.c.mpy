{
  "module_name": "microchip-csi2dc.c",
  "hash_id": "414f8821608240c319dd6436f015a3fe50aadb2c5047b72da631d5cf59dfe8f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/microchip/microchip-csi2dc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n \n#define CSI2DC_GCFG\t\t\t0x0\n\n \n#define CSI2DC_GCFG_MIPIFRN\t\tBIT(0)\n \n#define CSI2DC_GCFG_GPIOSEL\t\tBIT(1)\n \n#define CSI2DC_GCFG_HLC(v)\t\t((v) << 4)\n#define CSI2DC_GCFG_HLC_MASK\t\tGENMASK(7, 4)\n \n#define SAMA7G5_HLC\t\t\t(15)\n\n \n#define CSI2DC_GCTLR\t\t\t0x04\n#define CSI2DC_GCTLR_SWRST\t\tBIT(0)\n\n \n#define CSI2DC_GS\t\t\t0x08\n\n \n#define CSI2DC_SSPIS\t\t\t0x28\n \n#define CSI2DC_PU\t\t\t0xc0\n \n#define CSI2DC_PU_VP\t\t\tBIT(0)\n\n \n#define CSI2DC_PUS\t\t\t0xc4\n\n \n#define CSI2DC_VPISR\t\t\t0xf4\n\n \n#define CSI2DC_VPE\t\t\t0xf8\n#define CSI2DC_VPE_ENABLE\t\tBIT(0)\n\n \n#define CSI2DC_VPCFG\t\t\t0xfc\n \n#define CSI2DC_VPCFG_DT(v)\t\t((v) << 0)\n#define CSI2DC_VPCFG_DT_MASK\t\tGENMASK(5, 0)\n \n#define CSI2DC_VPCFG_VC(v)\t\t((v) << 6)\n#define CSI2DC_VPCFG_VC_MASK\t\tGENMASK(7, 6)\n \n#define CSI2DC_VPCFG_DE\t\t\tBIT(8)\n \n#define CSI2DC_VPCFG_DM(v)\t\t((v) << 9)\n#define CSI2DC_VPCFG_DM_DECODER8TO12\t0\n \n#define CSI2DC_VPCFG_DP2\t\tBIT(12)\n \n#define CSI2DC_VPCFG_RMS\t\tBIT(13)\n \n#define CSI2DC_VPCFG_PA\t\t\tBIT(14)\n\n \n#define CSI2DC_VPCOL\t\t\t0x100\n \n#define CSI2DC_VPCOL_COL(v)\t\t((v) << 0)\n#define CSI2DC_VPCOL_COL_MASK\t\tGENMASK(15, 0)\n\n \n#define CSI2DC_VPROW\t\t\t0x104\n \n#define CSI2DC_VPROW_ROW(v)\t\t((v) << 0)\n#define CSI2DC_VPROW_ROW_MASK\t\tGENMASK(15, 0)\n\n \n#define CSI2DC_VERSION\t\t\t0x1fc\n\n \n#define csi2dc_readl(st, reg)\t\treadl_relaxed((st)->base + (reg))\n#define csi2dc_writel(st, reg, val)\twritel_relaxed((val), \\\n\t\t\t\t\t(st)->base + (reg))\n\n \n#define CSI2DC_DT_RAW6\t\t\t0x28\n#define CSI2DC_DT_RAW7\t\t\t0x29\n#define CSI2DC_DT_RAW8\t\t\t0x2a\n#define CSI2DC_DT_RAW10\t\t\t0x2b\n#define CSI2DC_DT_RAW12\t\t\t0x2c\n#define CSI2DC_DT_RAW14\t\t\t0x2d\n \n#define CSI2DC_DT_YUV422_8B\t\t0x1e\n\n \nstruct csi2dc_format {\n\tu32\t\t\t\tmbus_code;\n\tu32\t\t\t\tdt;\n};\n\nstatic const struct csi2dc_format csi2dc_formats[] = {\n\t{\n\t\t.mbus_code =\t\tMEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.dt =\t\t\tCSI2DC_DT_RAW8,\n\t}, {\n\t\t.mbus_code =\t\tMEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.dt =\t\t\tCSI2DC_DT_RAW8,\n\t}, {\n\t\t.mbus_code =\t\tMEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.dt =\t\t\tCSI2DC_DT_RAW8,\n\t}, {\n\t\t.mbus_code =\t\tMEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.dt =\t\t\tCSI2DC_DT_RAW8,\n\t}, {\n\t\t.mbus_code =\t\tMEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.dt =\t\t\tCSI2DC_DT_RAW10,\n\t}, {\n\t\t.mbus_code =\t\tMEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.dt =\t\t\tCSI2DC_DT_RAW10,\n\t}, {\n\t\t.mbus_code =\t\tMEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.dt =\t\t\tCSI2DC_DT_RAW10,\n\t}, {\n\t\t.mbus_code =\t\tMEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.dt =\t\t\tCSI2DC_DT_RAW10,\n\t}, {\n\t\t.mbus_code =\t\tMEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.dt =\t\t\tCSI2DC_DT_YUV422_8B,\n\t},\n};\n\nenum mipi_csi_pads {\n\tCSI2DC_PAD_SINK\t\t\t= 0,\n\tCSI2DC_PAD_SOURCE\t\t= 1,\n\tCSI2DC_PADS_NUM\t\t\t= 2,\n};\n\n \nstruct csi2dc_device {\n\tvoid __iomem\t\t\t*base;\n\tstruct v4l2_subdev\t\tcsi2dc_sd;\n\tstruct device\t\t\t*dev;\n\tstruct clk\t\t\t*pclk;\n\tstruct clk\t\t\t*scck;\n\n\tstruct v4l2_mbus_framefmt\t format;\n\n\tconst struct csi2dc_format\t*cur_fmt;\n\tconst struct csi2dc_format\t*try_fmt;\n\n\tstruct media_pad\t\tpads[CSI2DC_PADS_NUM];\n\n\tbool\t\t\t\tclk_gated;\n\tbool\t\t\t\tvideo_pipe;\n\tbool\t\t\t\tparallel_mode;\n\tu32\t\t\t\tvc;\n\n\tstruct v4l2_async_notifier\tnotifier;\n\n\tstruct v4l2_subdev\t\t*input_sd;\n\n\tu32\t\t\t\tremote_pad;\n};\n\nstatic inline struct csi2dc_device *\ncsi2dc_sd_to_csi2dc_device(struct v4l2_subdev *csi2dc_sd)\n{\n\treturn container_of(csi2dc_sd, struct csi2dc_device, csi2dc_sd);\n}\n\nstatic int csi2dc_enum_mbus_code(struct v4l2_subdev *csi2dc_sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= ARRAY_SIZE(csi2dc_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = csi2dc_formats[code->index].mbus_code;\n\n\treturn 0;\n}\n\nstatic int csi2dc_get_fmt(struct v4l2_subdev *csi2dc_sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *format)\n{\n\tstruct csi2dc_device *csi2dc = csi2dc_sd_to_csi2dc_device(csi2dc_sd);\n\tstruct v4l2_mbus_framefmt *v4l2_try_fmt;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tv4l2_try_fmt = v4l2_subdev_get_try_format(csi2dc_sd, sd_state,\n\t\t\t\t\t\t\t  format->pad);\n\t\tformat->format = *v4l2_try_fmt;\n\n\t\treturn 0;\n\t}\n\n\tformat->format = csi2dc->format;\n\n\treturn 0;\n}\n\nstatic int csi2dc_set_fmt(struct v4l2_subdev *csi2dc_sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *req_fmt)\n{\n\tstruct csi2dc_device *csi2dc = csi2dc_sd_to_csi2dc_device(csi2dc_sd);\n\tconst struct csi2dc_format *fmt, *try_fmt = NULL;\n\tstruct v4l2_mbus_framefmt *v4l2_try_fmt;\n\tunsigned int i;\n\n\t \n\tif (req_fmt->pad == CSI2DC_PAD_SOURCE)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(csi2dc_formats);  i++) {\n\t\tfmt = &csi2dc_formats[i];\n\t\tif (req_fmt->format.code == fmt->mbus_code)\n\t\t\ttry_fmt = fmt;\n\t\tfmt++;\n\t}\n\n\t \n\tif (!try_fmt) {\n\t\ttry_fmt = &csi2dc_formats[0];\n\n\t\tdev_dbg(csi2dc->dev,\n\t\t\t\"CSI2DC unsupported format 0x%x, defaulting to 0x%x\\n\",\n\t\t\treq_fmt->format.code, csi2dc_formats[0].mbus_code);\n\t}\n\n\treq_fmt->format.code = try_fmt->mbus_code;\n\treq_fmt->format.colorspace = V4L2_COLORSPACE_SRGB;\n\treq_fmt->format.field = V4L2_FIELD_NONE;\n\n\tif (req_fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tv4l2_try_fmt = v4l2_subdev_get_try_format(csi2dc_sd, sd_state,\n\t\t\t\t\t\t\t  req_fmt->pad);\n\t\t*v4l2_try_fmt = req_fmt->format;\n\t\t \n\t\tv4l2_try_fmt = v4l2_subdev_get_try_format(csi2dc_sd,\n\t\t\t\t\t\t\t  sd_state,\n\t\t\t\t\t\t\t  CSI2DC_PAD_SOURCE);\n\t\t*v4l2_try_fmt = req_fmt->format;\n\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tcsi2dc->format = req_fmt->format;\n\n\t \n\tcsi2dc->cur_fmt = try_fmt;\n\n\tdev_dbg(csi2dc->dev, \"new format set: 0x%x @%dx%d\\n\",\n\t\tcsi2dc->format.code, csi2dc->format.width,\n\t\tcsi2dc->format.height);\n\n\treturn 0;\n}\n\nstatic int csi2dc_power(struct csi2dc_device *csi2dc, int on)\n{\n\tint ret = 0;\n\n\tif (on) {\n\t\tret = clk_prepare_enable(csi2dc->pclk);\n\t\tif (ret) {\n\t\t\tdev_err(csi2dc->dev, \"failed to enable pclk:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = clk_prepare_enable(csi2dc->scck);\n\t\tif (ret) {\n\t\t\tdev_err(csi2dc->dev, \"failed to enable scck:%d\\n\", ret);\n\t\t\tclk_disable_unprepare(csi2dc->pclk);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tcsi2dc_writel(csi2dc, CSI2DC_GCTLR, CSI2DC_GCTLR_SWRST);\n\t} else {\n\t\t \n\t\tcsi2dc_writel(csi2dc, CSI2DC_GCTLR, 0);\n\n\t\tclk_disable_unprepare(csi2dc->scck);\n\t\tclk_disable_unprepare(csi2dc->pclk);\n\t}\n\n\treturn ret;\n}\n\nstatic int csi2dc_get_mbus_config(struct csi2dc_device *csi2dc)\n{\n\tstruct v4l2_mbus_config mbus_config = { 0 };\n\tint ret;\n\n\tret = v4l2_subdev_call(csi2dc->input_sd, pad, get_mbus_config,\n\t\t\t       csi2dc->remote_pad, &mbus_config);\n\tif (ret == -ENOIOCTLCMD) {\n\t\tdev_dbg(csi2dc->dev,\n\t\t\t\"no remote mbus configuration available\\n\");\n\t\treturn 0;\n\t}\n\n\tif (ret) {\n\t\tdev_err(csi2dc->dev,\n\t\t\t\"failed to get remote mbus configuration\\n\");\n\t\treturn 0;\n\t}\n\n\tdev_dbg(csi2dc->dev, \"subdev sending on channel %d\\n\", csi2dc->vc);\n\n\tcsi2dc->clk_gated = mbus_config.bus.parallel.flags &\n\t\t\t\tV4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK;\n\n\tdev_dbg(csi2dc->dev, \"mbus_config: %s clock\\n\",\n\t\tcsi2dc->clk_gated ? \"gated\" : \"free running\");\n\n\treturn 0;\n}\n\nstatic void csi2dc_vp_update(struct csi2dc_device *csi2dc)\n{\n\tu32 vp, gcfg;\n\n\tif (!csi2dc->video_pipe) {\n\t\tdev_err(csi2dc->dev, \"video pipeline unavailable\\n\");\n\t\treturn;\n\t}\n\n\tif (csi2dc->parallel_mode) {\n\t\t \n\t\tgcfg = csi2dc_readl(csi2dc, CSI2DC_GCFG);\n\t\tgcfg |= CSI2DC_GCFG_GPIOSEL;\n\t\tcsi2dc_writel(csi2dc, CSI2DC_GCFG, gcfg);\n\t\treturn;\n\t}\n\n\t \n\n\tcsi2dc_writel(csi2dc, CSI2DC_GCFG,\n\t\t      (SAMA7G5_HLC & CSI2DC_GCFG_HLC_MASK) |\n\t\t      (csi2dc->clk_gated ? 0 : CSI2DC_GCFG_MIPIFRN));\n\n\tvp = CSI2DC_VPCFG_DT(csi2dc->cur_fmt->dt) & CSI2DC_VPCFG_DT_MASK;\n\tvp |= CSI2DC_VPCFG_VC(csi2dc->vc) & CSI2DC_VPCFG_VC_MASK;\n\tvp &= ~CSI2DC_VPCFG_DE;\n\tvp |= CSI2DC_VPCFG_DM(CSI2DC_VPCFG_DM_DECODER8TO12);\n\tvp &= ~CSI2DC_VPCFG_DP2;\n\tvp &= ~CSI2DC_VPCFG_RMS;\n\tvp |= CSI2DC_VPCFG_PA;\n\n\tcsi2dc_writel(csi2dc, CSI2DC_VPCFG, vp);\n\tcsi2dc_writel(csi2dc, CSI2DC_VPE, CSI2DC_VPE_ENABLE);\n\tcsi2dc_writel(csi2dc, CSI2DC_PU, CSI2DC_PU_VP);\n}\n\nstatic int csi2dc_s_stream(struct v4l2_subdev *csi2dc_sd, int enable)\n{\n\tstruct csi2dc_device *csi2dc = csi2dc_sd_to_csi2dc_device(csi2dc_sd);\n\tint ret;\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(csi2dc->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcsi2dc_get_mbus_config(csi2dc);\n\n\t\tcsi2dc_vp_update(csi2dc);\n\n\t\treturn v4l2_subdev_call(csi2dc->input_sd, video, s_stream,\n\t\t\t\t\ttrue);\n\t}\n\n\tdev_dbg(csi2dc->dev,\n\t\t\"Last frame received: VPCOLR = %u, VPROWR= %u, VPISR = %x\\n\",\n\t\tcsi2dc_readl(csi2dc, CSI2DC_VPCOL),\n\t\tcsi2dc_readl(csi2dc, CSI2DC_VPROW),\n\t\tcsi2dc_readl(csi2dc, CSI2DC_VPISR));\n\n\t \n\tret = v4l2_subdev_call(csi2dc->input_sd, video, s_stream, false);\n\n\tpm_runtime_put_sync(csi2dc->dev);\n\n\treturn ret;\n}\n\nstatic int csi2dc_init_cfg(struct v4l2_subdev *csi2dc_sd,\n\t\t\t   struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_mbus_framefmt *v4l2_try_fmt =\n\t\tv4l2_subdev_get_try_format(csi2dc_sd, sd_state, 0);\n\n\tv4l2_try_fmt->height = 480;\n\tv4l2_try_fmt->width = 640;\n\tv4l2_try_fmt->code = csi2dc_formats[0].mbus_code;\n\tv4l2_try_fmt->colorspace = V4L2_COLORSPACE_SRGB;\n\tv4l2_try_fmt->field = V4L2_FIELD_NONE;\n\tv4l2_try_fmt->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tv4l2_try_fmt->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tv4l2_try_fmt->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\n\treturn 0;\n}\n\nstatic const struct media_entity_operations csi2dc_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic const struct v4l2_subdev_pad_ops csi2dc_pad_ops = {\n\t.enum_mbus_code = csi2dc_enum_mbus_code,\n\t.set_fmt = csi2dc_set_fmt,\n\t.get_fmt = csi2dc_get_fmt,\n\t.init_cfg = csi2dc_init_cfg,\n};\n\nstatic const struct v4l2_subdev_video_ops csi2dc_video_ops = {\n\t.s_stream = csi2dc_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops csi2dc_subdev_ops = {\n\t.pad = &csi2dc_pad_ops,\n\t.video = &csi2dc_video_ops,\n};\n\nstatic int csi2dc_async_bound(struct v4l2_async_notifier *notifier,\n\t\t\t      struct v4l2_subdev *subdev,\n\t\t\t      struct v4l2_async_connection *asd)\n{\n\tstruct csi2dc_device *csi2dc = container_of(notifier,\n\t\t\t\t\t\tstruct csi2dc_device, notifier);\n\tint pad;\n\tint ret;\n\n\tcsi2dc->input_sd = subdev;\n\n\tpad = media_entity_get_fwnode_pad(&subdev->entity, asd->match.fwnode,\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (pad < 0) {\n\t\tdev_err(csi2dc->dev, \"Failed to find pad for %s\\n\",\n\t\t\tsubdev->name);\n\t\treturn pad;\n\t}\n\n\tcsi2dc->remote_pad = pad;\n\n\tret = media_create_pad_link(&csi2dc->input_sd->entity,\n\t\t\t\t    csi2dc->remote_pad,\n\t\t\t\t    &csi2dc->csi2dc_sd.entity, 0,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\tif (ret) {\n\t\tdev_err(csi2dc->dev,\n\t\t\t\"Failed to create pad link: %s to %s\\n\",\n\t\t\tcsi2dc->input_sd->entity.name,\n\t\t\tcsi2dc->csi2dc_sd.entity.name);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(csi2dc->dev, \"link with %s pad: %d\\n\",\n\t\tcsi2dc->input_sd->name, csi2dc->remote_pad);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_async_notifier_operations csi2dc_async_ops = {\n\t.bound = csi2dc_async_bound,\n};\n\nstatic int csi2dc_prepare_notifier(struct csi2dc_device *csi2dc,\n\t\t\t\t   struct fwnode_handle *input_fwnode)\n{\n\tstruct v4l2_async_connection *asd;\n\tint ret = 0;\n\n\tv4l2_async_subdev_nf_init(&csi2dc->notifier, &csi2dc->csi2dc_sd);\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&csi2dc->notifier,\n\t\t\t\t\t      input_fwnode,\n\t\t\t\t\t      struct v4l2_async_connection);\n\n\tfwnode_handle_put(input_fwnode);\n\n\tif (IS_ERR(asd)) {\n\t\tret = PTR_ERR(asd);\n\t\tdev_err(csi2dc->dev,\n\t\t\t\"failed to add async notifier for node %pOF: %d\\n\",\n\t\t\tto_of_node(input_fwnode), ret);\n\t\tv4l2_async_nf_cleanup(&csi2dc->notifier);\n\t\treturn ret;\n\t}\n\n\tcsi2dc->notifier.ops = &csi2dc_async_ops;\n\n\tret = v4l2_async_nf_register(&csi2dc->notifier);\n\tif (ret) {\n\t\tdev_err(csi2dc->dev, \"fail to register async notifier: %d\\n\",\n\t\t\tret);\n\t\tv4l2_async_nf_cleanup(&csi2dc->notifier);\n\t}\n\n\treturn ret;\n}\n\nstatic int csi2dc_of_parse(struct csi2dc_device *csi2dc,\n\t\t\t   struct device_node *of_node)\n{\n\tstruct fwnode_handle *input_fwnode, *output_fwnode;\n\tstruct v4l2_fwnode_endpoint input_endpoint = { 0 },\n\t\t\t\t    output_endpoint = { 0 };\n\tint ret;\n\n\tinput_fwnode = fwnode_graph_get_next_endpoint(of_fwnode_handle(of_node),\n\t\t\t\t\t\t      NULL);\n\tif (!input_fwnode) {\n\t\tdev_err(csi2dc->dev,\n\t\t\t\"missing port node at %pOF, input node is mandatory.\\n\",\n\t\t\tof_node);\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(input_fwnode, &input_endpoint);\n\tif (ret) {\n\t\tdev_err(csi2dc->dev, \"endpoint not defined at %pOF\\n\", of_node);\n\t\tgoto csi2dc_of_parse_err;\n\t}\n\n\tif (input_endpoint.bus_type == V4L2_MBUS_PARALLEL ||\n\t    input_endpoint.bus_type == V4L2_MBUS_BT656) {\n\t\tcsi2dc->parallel_mode = true;\n\t\tdev_dbg(csi2dc->dev,\n\t\t\t\"subdevice connected on parallel interface\\n\");\n\t}\n\n\tif (input_endpoint.bus_type == V4L2_MBUS_CSI2_DPHY) {\n\t\tcsi2dc->clk_gated = input_endpoint.bus.mipi_csi2.flags &\n\t\t\t\t\tV4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK;\n\t\tdev_dbg(csi2dc->dev,\n\t\t\t\"subdevice connected on serial interface\\n\");\n\t\tdev_dbg(csi2dc->dev, \"DT: %s clock\\n\",\n\t\t\tcsi2dc->clk_gated ? \"gated\" : \"free running\");\n\t}\n\n\toutput_fwnode = fwnode_graph_get_next_endpoint\n\t\t\t\t(of_fwnode_handle(of_node), input_fwnode);\n\n\tif (output_fwnode)\n\t\tret = v4l2_fwnode_endpoint_parse(output_fwnode,\n\t\t\t\t\t\t &output_endpoint);\n\n\tfwnode_handle_put(output_fwnode);\n\n\tif (!output_fwnode || ret) {\n\t\tdev_info(csi2dc->dev,\n\t\t\t \"missing output node at %pOF, data pipe available only.\\n\",\n\t\t\t of_node);\n\t} else {\n\t\tif (output_endpoint.bus_type != V4L2_MBUS_PARALLEL &&\n\t\t    output_endpoint.bus_type != V4L2_MBUS_BT656) {\n\t\t\tdev_err(csi2dc->dev,\n\t\t\t\t\"output port must be parallel/bt656.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto csi2dc_of_parse_err;\n\t\t}\n\n\t\tcsi2dc->video_pipe = true;\n\n\t\tdev_dbg(csi2dc->dev,\n\t\t\t\"block %pOF [%d.%d]->[%d.%d] video pipeline\\n\",\n\t\t\tof_node, input_endpoint.base.port,\n\t\t\tinput_endpoint.base.id, output_endpoint.base.port,\n\t\t\toutput_endpoint.base.id);\n\t}\n\n\t \n\treturn csi2dc_prepare_notifier(csi2dc, input_fwnode);\n\ncsi2dc_of_parse_err:\n\tfwnode_handle_put(input_fwnode);\n\treturn ret;\n}\n\nstatic void csi2dc_default_format(struct csi2dc_device *csi2dc)\n{\n\tcsi2dc->cur_fmt = &csi2dc_formats[0];\n\n\tcsi2dc->format.height = 480;\n\tcsi2dc->format.width = 640;\n\tcsi2dc->format.code = csi2dc_formats[0].mbus_code;\n\tcsi2dc->format.colorspace = V4L2_COLORSPACE_SRGB;\n\tcsi2dc->format.field = V4L2_FIELD_NONE;\n\tcsi2dc->format.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tcsi2dc->format.quantization = V4L2_QUANTIZATION_DEFAULT;\n\tcsi2dc->format.xfer_func = V4L2_XFER_FUNC_DEFAULT;\n}\n\nstatic int csi2dc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct csi2dc_device *csi2dc;\n\tint ret = 0;\n\tu32 ver;\n\n\tcsi2dc = devm_kzalloc(dev, sizeof(*csi2dc), GFP_KERNEL);\n\tif (!csi2dc)\n\t\treturn -ENOMEM;\n\n\tcsi2dc->dev = dev;\n\n\tcsi2dc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(csi2dc->base)) {\n\t\tdev_err(dev, \"base address not set\\n\");\n\t\treturn PTR_ERR(csi2dc->base);\n\t}\n\n\tcsi2dc->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(csi2dc->pclk)) {\n\t\tret = PTR_ERR(csi2dc->pclk);\n\t\tdev_err(dev, \"failed to get pclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcsi2dc->scck = devm_clk_get(dev, \"scck\");\n\tif (IS_ERR(csi2dc->scck)) {\n\t\tret = PTR_ERR(csi2dc->scck);\n\t\tdev_err(dev, \"failed to get scck: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tv4l2_subdev_init(&csi2dc->csi2dc_sd, &csi2dc_subdev_ops);\n\n\tcsi2dc->csi2dc_sd.owner = THIS_MODULE;\n\tcsi2dc->csi2dc_sd.dev = dev;\n\tsnprintf(csi2dc->csi2dc_sd.name, sizeof(csi2dc->csi2dc_sd.name),\n\t\t \"csi2dc\");\n\n\tcsi2dc->csi2dc_sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tcsi2dc->csi2dc_sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tcsi2dc->csi2dc_sd.entity.ops = &csi2dc_entity_ops;\n\n\tplatform_set_drvdata(pdev, csi2dc);\n\n\tret = csi2dc_of_parse(csi2dc, dev->of_node);\n\tif (ret)\n\t\tgoto csi2dc_probe_cleanup_entity;\n\n\tcsi2dc->pads[CSI2DC_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tif (csi2dc->video_pipe)\n\t\tcsi2dc->pads[CSI2DC_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&csi2dc->csi2dc_sd.entity,\n\t\t\t\t     csi2dc->video_pipe ? CSI2DC_PADS_NUM : 1,\n\t\t\t\t     csi2dc->pads);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"media entity init failed\\n\");\n\t\tgoto csi2dc_probe_cleanup_notifier;\n\t}\n\n\tcsi2dc_default_format(csi2dc);\n\n\t \n\tret = csi2dc_power(csi2dc, true);\n\tif (ret < 0)\n\t\tgoto csi2dc_probe_cleanup_notifier;\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tver = csi2dc_readl(csi2dc, CSI2DC_VERSION);\n\n\t \n\tret = v4l2_async_register_subdev(&csi2dc->csi2dc_sd);\n\tif (ret) {\n\t\tdev_err(csi2dc->dev, \"failed to register the subdevice\\n\");\n\t\tgoto csi2dc_probe_cleanup_notifier;\n\t}\n\n\tdev_info(dev, \"Microchip CSI2DC version %x\\n\", ver);\n\n\treturn 0;\n\ncsi2dc_probe_cleanup_notifier:\n\tv4l2_async_nf_cleanup(&csi2dc->notifier);\ncsi2dc_probe_cleanup_entity:\n\tmedia_entity_cleanup(&csi2dc->csi2dc_sd.entity);\n\n\treturn ret;\n}\n\nstatic void csi2dc_remove(struct platform_device *pdev)\n{\n\tstruct csi2dc_device *csi2dc = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tv4l2_async_unregister_subdev(&csi2dc->csi2dc_sd);\n\tv4l2_async_nf_unregister(&csi2dc->notifier);\n\tv4l2_async_nf_cleanup(&csi2dc->notifier);\n\tmedia_entity_cleanup(&csi2dc->csi2dc_sd.entity);\n}\n\nstatic int __maybe_unused csi2dc_runtime_suspend(struct device *dev)\n{\n\tstruct csi2dc_device *csi2dc = dev_get_drvdata(dev);\n\n\treturn csi2dc_power(csi2dc, false);\n}\n\nstatic int __maybe_unused csi2dc_runtime_resume(struct device *dev)\n{\n\tstruct csi2dc_device *csi2dc = dev_get_drvdata(dev);\n\n\treturn csi2dc_power(csi2dc, true);\n}\n\nstatic const struct dev_pm_ops csi2dc_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(csi2dc_runtime_suspend, csi2dc_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id csi2dc_of_match[] = {\n\t{ .compatible = \"microchip,sama7g5-csi2dc\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, csi2dc_of_match);\n\nstatic struct platform_driver csi2dc_driver = {\n\t.probe\t= csi2dc_probe,\n\t.remove_new = csi2dc_remove,\n\t.driver = {\n\t\t.name =\t\t\t\"microchip-csi2dc\",\n\t\t.pm =\t\t\t&csi2dc_dev_pm_ops,\n\t\t.of_match_table =\tof_match_ptr(csi2dc_of_match),\n\t},\n};\n\nmodule_platform_driver(csi2dc_driver);\n\nMODULE_AUTHOR(\"Eugen Hristev <eugen.hristev@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip CSI2 Demux Controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}