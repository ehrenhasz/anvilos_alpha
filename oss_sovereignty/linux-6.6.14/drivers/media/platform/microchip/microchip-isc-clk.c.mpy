{
  "module_name": "microchip-isc-clk.c",
  "hash_id": "0d28568e7cbbe9ccad2c6320fcf502e487693a84155dd98694c75f5cbd2f936f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/microchip/microchip-isc-clk.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include \"microchip-isc-regs.h\"\n#include \"microchip-isc.h\"\n\nstatic int isc_wait_clk_stable(struct clk_hw *hw)\n{\n\tstruct isc_clk *isc_clk = to_isc_clk(hw);\n\tstruct regmap *regmap = isc_clk->regmap;\n\tunsigned long timeout = jiffies + usecs_to_jiffies(1000);\n\tunsigned int status;\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tregmap_read(regmap, ISC_CLKSR, &status);\n\t\tif (!(status & ISC_CLKSR_SIP))\n\t\t\treturn 0;\n\n\t\tusleep_range(10, 250);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int isc_clk_prepare(struct clk_hw *hw)\n{\n\tstruct isc_clk *isc_clk = to_isc_clk(hw);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(isc_clk->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn isc_wait_clk_stable(hw);\n}\n\nstatic void isc_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct isc_clk *isc_clk = to_isc_clk(hw);\n\n\tisc_wait_clk_stable(hw);\n\n\tpm_runtime_put_sync(isc_clk->dev);\n}\n\nstatic int isc_clk_enable(struct clk_hw *hw)\n{\n\tstruct isc_clk *isc_clk = to_isc_clk(hw);\n\tu32 id = isc_clk->id;\n\tstruct regmap *regmap = isc_clk->regmap;\n\tunsigned long flags;\n\tunsigned int status;\n\n\tdev_dbg(isc_clk->dev, \"ISC CLK: %s, id = %d, div = %d, parent id = %d\\n\",\n\t\t__func__, id, isc_clk->div, isc_clk->parent_id);\n\n\tspin_lock_irqsave(&isc_clk->lock, flags);\n\tregmap_update_bits(regmap, ISC_CLKCFG,\n\t\t\t   ISC_CLKCFG_DIV_MASK(id) | ISC_CLKCFG_SEL_MASK(id),\n\t\t\t   (isc_clk->div << ISC_CLKCFG_DIV_SHIFT(id)) |\n\t\t\t   (isc_clk->parent_id << ISC_CLKCFG_SEL_SHIFT(id)));\n\n\tregmap_write(regmap, ISC_CLKEN, ISC_CLK(id));\n\tspin_unlock_irqrestore(&isc_clk->lock, flags);\n\n\tregmap_read(regmap, ISC_CLKSR, &status);\n\tif (status & ISC_CLK(id))\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic void isc_clk_disable(struct clk_hw *hw)\n{\n\tstruct isc_clk *isc_clk = to_isc_clk(hw);\n\tu32 id = isc_clk->id;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&isc_clk->lock, flags);\n\tregmap_write(isc_clk->regmap, ISC_CLKDIS, ISC_CLK(id));\n\tspin_unlock_irqrestore(&isc_clk->lock, flags);\n}\n\nstatic int isc_clk_is_enabled(struct clk_hw *hw)\n{\n\tstruct isc_clk *isc_clk = to_isc_clk(hw);\n\tu32 status;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(isc_clk->dev);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tregmap_read(isc_clk->regmap, ISC_CLKSR, &status);\n\n\tpm_runtime_put_sync(isc_clk->dev);\n\n\treturn status & ISC_CLK(isc_clk->id) ? 1 : 0;\n}\n\nstatic unsigned long\nisc_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tstruct isc_clk *isc_clk = to_isc_clk(hw);\n\n\treturn DIV_ROUND_CLOSEST(parent_rate, isc_clk->div + 1);\n}\n\nstatic int isc_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t  struct clk_rate_request *req)\n{\n\tstruct isc_clk *isc_clk = to_isc_clk(hw);\n\tlong best_rate = -EINVAL;\n\tint best_diff = -1;\n\tunsigned int i, div;\n\n\tfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\n\t\tstruct clk_hw *parent;\n\t\tunsigned long parent_rate;\n\n\t\tparent = clk_hw_get_parent_by_index(hw, i);\n\t\tif (!parent)\n\t\t\tcontinue;\n\n\t\tparent_rate = clk_hw_get_rate(parent);\n\t\tif (!parent_rate)\n\t\t\tcontinue;\n\n\t\tfor (div = 1; div < ISC_CLK_MAX_DIV + 2; div++) {\n\t\t\tunsigned long rate;\n\t\t\tint diff;\n\n\t\t\trate = DIV_ROUND_CLOSEST(parent_rate, div);\n\t\t\tdiff = abs(req->rate - rate);\n\n\t\t\tif (best_diff < 0 || best_diff > diff) {\n\t\t\t\tbest_rate = rate;\n\t\t\t\tbest_diff = diff;\n\t\t\t\treq->best_parent_rate = parent_rate;\n\t\t\t\treq->best_parent_hw = parent;\n\t\t\t}\n\n\t\t\tif (!best_diff || rate < req->rate)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!best_diff)\n\t\t\tbreak;\n\t}\n\n\tdev_dbg(isc_clk->dev,\n\t\t\"ISC CLK: %s, best_rate = %ld, parent clk: %s @ %ld\\n\",\n\t\t__func__, best_rate,\n\t\t__clk_get_name((req->best_parent_hw)->clk),\n\t\treq->best_parent_rate);\n\n\tif (best_rate < 0)\n\t\treturn best_rate;\n\n\treq->rate = best_rate;\n\n\treturn 0;\n}\n\nstatic int isc_clk_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct isc_clk *isc_clk = to_isc_clk(hw);\n\n\tif (index >= clk_hw_get_num_parents(hw))\n\t\treturn -EINVAL;\n\n\tisc_clk->parent_id = index;\n\n\treturn 0;\n}\n\nstatic u8 isc_clk_get_parent(struct clk_hw *hw)\n{\n\tstruct isc_clk *isc_clk = to_isc_clk(hw);\n\n\treturn isc_clk->parent_id;\n}\n\nstatic int isc_clk_set_rate(struct clk_hw *hw,\n\t\t\t    unsigned long rate,\n\t\t\t    unsigned long parent_rate)\n{\n\tstruct isc_clk *isc_clk = to_isc_clk(hw);\n\tu32 div;\n\n\tif (!rate)\n\t\treturn -EINVAL;\n\n\tdiv = DIV_ROUND_CLOSEST(parent_rate, rate);\n\tif (div > (ISC_CLK_MAX_DIV + 1) || !div)\n\t\treturn -EINVAL;\n\n\tisc_clk->div = div - 1;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops isc_clk_ops = {\n\t.prepare\t= isc_clk_prepare,\n\t.unprepare\t= isc_clk_unprepare,\n\t.enable\t\t= isc_clk_enable,\n\t.disable\t= isc_clk_disable,\n\t.is_enabled\t= isc_clk_is_enabled,\n\t.recalc_rate\t= isc_clk_recalc_rate,\n\t.determine_rate\t= isc_clk_determine_rate,\n\t.set_parent\t= isc_clk_set_parent,\n\t.get_parent\t= isc_clk_get_parent,\n\t.set_rate\t= isc_clk_set_rate,\n};\n\nstatic int isc_clk_register(struct isc_device *isc, unsigned int id)\n{\n\tstruct regmap *regmap = isc->regmap;\n\tstruct device_node *np = isc->dev->of_node;\n\tstruct isc_clk *isc_clk;\n\tstruct clk_init_data init;\n\tconst char *clk_name = np->name;\n\tconst char *parent_names[3];\n\tint num_parents;\n\n\tif (id == ISC_ISPCK && !isc->ispck_required)\n\t\treturn 0;\n\n\tnum_parents = of_clk_get_parent_count(np);\n\tif (num_parents < 1 || num_parents > 3)\n\t\treturn -EINVAL;\n\n\tif (num_parents > 2 && id == ISC_ISPCK)\n\t\tnum_parents = 2;\n\n\tof_clk_parent_fill(np, parent_names, num_parents);\n\n\tif (id == ISC_MCK)\n\t\tof_property_read_string(np, \"clock-output-names\", &clk_name);\n\telse\n\t\tclk_name = \"isc-ispck\";\n\n\tinit.parent_names\t= parent_names;\n\tinit.num_parents\t= num_parents;\n\tinit.name\t\t= clk_name;\n\tinit.ops\t\t= &isc_clk_ops;\n\tinit.flags\t\t= CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\n\n\tisc_clk = &isc->isc_clks[id];\n\tisc_clk->hw.init\t= &init;\n\tisc_clk->regmap\t\t= regmap;\n\tisc_clk->id\t\t= id;\n\tisc_clk->dev\t\t= isc->dev;\n\tspin_lock_init(&isc_clk->lock);\n\n\tisc_clk->clk = clk_register(isc->dev, &isc_clk->hw);\n\tif (IS_ERR(isc_clk->clk)) {\n\t\tdev_err(isc->dev, \"%s: clock register fail\\n\", clk_name);\n\t\treturn PTR_ERR(isc_clk->clk);\n\t} else if (id == ISC_MCK) {\n\t\tof_clk_add_provider(np, of_clk_src_simple_get, isc_clk->clk);\n\t}\n\n\treturn 0;\n}\n\nint microchip_isc_clk_init(struct isc_device *isc)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(isc->isc_clks); i++)\n\t\tisc->isc_clks[i].clk = ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < ARRAY_SIZE(isc->isc_clks); i++) {\n\t\tret = isc_clk_register(isc, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(microchip_isc_clk_init);\n\nvoid microchip_isc_clk_cleanup(struct isc_device *isc)\n{\n\tunsigned int i;\n\n\tof_clk_del_provider(isc->dev->of_node);\n\n\tfor (i = 0; i < ARRAY_SIZE(isc->isc_clks); i++) {\n\t\tstruct isc_clk *isc_clk = &isc->isc_clks[i];\n\n\t\tif (!IS_ERR(isc_clk->clk))\n\t\t\tclk_unregister(isc_clk->clk);\n\t}\n}\nEXPORT_SYMBOL_GPL(microchip_isc_clk_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}