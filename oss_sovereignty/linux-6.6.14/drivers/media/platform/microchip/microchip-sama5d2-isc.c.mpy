{
  "module_name": "microchip-sama5d2-isc.c",
  "hash_id": "55540825251a310a35c861e6460a510bfa767b0863f2c400bc32430f146828d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/microchip/microchip-sama5d2-isc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"microchip-isc-regs.h\"\n#include \"microchip-isc.h\"\n\n#define ISC_SAMA5D2_MAX_SUPPORT_WIDTH   2592\n#define ISC_SAMA5D2_MAX_SUPPORT_HEIGHT  1944\n\n#define ISC_SAMA5D2_PIPELINE \\\n\t(WB_ENABLE | CFA_ENABLE | CC_ENABLE | GAM_ENABLES | CSC_ENABLE | \\\n\tCBC_ENABLE | SUB422_ENABLE | SUB420_ENABLE)\n\n \nstatic const struct isc_format sama5d2_controller_formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_ARGB444,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_ARGB555,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_ABGR32,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_XBGR32,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV420,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV422P,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_GREY,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_Y10,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG8,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB8,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR10,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG10,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG10,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB10,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR12,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG12,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG12,\n\t\t.raw\t\t= true,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB12,\n\t\t.raw\t\t= true,\n\t},\n};\n\n \nstatic struct isc_format sama5d2_formats_list[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_BGBG,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_GBGB,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_GRGR,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_RGRG,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TEN,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_RGRG,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TEN,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_GBGB,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TEN,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_GRGR,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TEN,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_RGRG,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR12,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TWELVE,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_BGBG,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG12,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TWELVE,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_GBGB,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG12,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TWELVE,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_GRGR,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB12,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TWELVE,\n\t\t.cfa_baycfg\t= ISC_BAY_CFG_RGRG,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_GREY,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_Y8_1X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB565_2X8_LE,\n\t\t.pfe_cfg0_bps\t= ISC_PFE_CFG0_BPS_EIGHT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_Y10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_Y10_1X10,\n\t\t.pfe_cfg0_bps\t= ISC_PFG_CFG0_BPS_TEN,\n\t},\n\n};\n\nstatic void isc_sama5d2_config_csc(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\n\t \n\tregmap_write(regmap, ISC_CSC_YR_YG + isc->offsets.csc,\n\t\t     0x42 | (0x81 << 16));\n\tregmap_write(regmap, ISC_CSC_YB_OY + isc->offsets.csc,\n\t\t     0x19 | (0x10 << 16));\n\tregmap_write(regmap, ISC_CSC_CBR_CBG + isc->offsets.csc,\n\t\t     0xFDA | (0xFB6 << 16));\n\tregmap_write(regmap, ISC_CSC_CBB_OCB + isc->offsets.csc,\n\t\t     0x70 | (0x80 << 16));\n\tregmap_write(regmap, ISC_CSC_CRR_CRG + isc->offsets.csc,\n\t\t     0x70 | (0xFA2 << 16));\n\tregmap_write(regmap, ISC_CSC_CRB_OCR + isc->offsets.csc,\n\t\t     0xFEE | (0x80 << 16));\n}\n\nstatic void isc_sama5d2_config_cbc(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\n\tregmap_write(regmap, ISC_CBC_BRIGHT + isc->offsets.cbc,\n\t\t     isc->ctrls.brightness);\n\tregmap_write(regmap, ISC_CBC_CONTRAST + isc->offsets.cbc,\n\t\t     isc->ctrls.contrast);\n}\n\nstatic void isc_sama5d2_config_cc(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\n\t \n\tregmap_write(regmap, ISC_CC_RR_RG, (1 << 8));\n\tregmap_write(regmap, ISC_CC_RB_OR, 0);\n\tregmap_write(regmap, ISC_CC_GR_GG, (1 << 8) << 16);\n\tregmap_write(regmap, ISC_CC_GB_OG, 0);\n\tregmap_write(regmap, ISC_CC_BR_BG, 0);\n\tregmap_write(regmap, ISC_CC_BB_OB, (1 << 8));\n}\n\nstatic void isc_sama5d2_config_ctrls(struct isc_device *isc,\n\t\t\t\t     const struct v4l2_ctrl_ops *ops)\n{\n\tstruct isc_ctrls *ctrls = &isc->ctrls;\n\tstruct v4l2_ctrl_handler *hdl = &ctrls->handler;\n\n\tctrls->contrast = 256;\n\n\tv4l2_ctrl_new_std(hdl, ops, V4L2_CID_CONTRAST, -2048, 2047, 1, 256);\n}\n\nstatic void isc_sama5d2_config_dpc(struct isc_device *isc)\n{\n\t \n}\n\nstatic void isc_sama5d2_config_gam(struct isc_device *isc)\n{\n\t \n}\n\nstatic void isc_sama5d2_config_rlp(struct isc_device *isc)\n{\n\tstruct regmap *regmap = isc->regmap;\n\tu32 rlp_mode = isc->config.rlp_cfg_mode;\n\n\t \n\tif ((rlp_mode & ISC_RLP_CFG_MODE_MASK) == ISC_RLP_CFG_MODE_YCYC) {\n\t\trlp_mode &= ~ISC_RLP_CFG_MODE_MASK;\n\t\trlp_mode |= ISC_RLP_CFG_MODE_YYCC;\n\t}\n\n\tregmap_update_bits(regmap, ISC_RLP_CFG + isc->offsets.rlp,\n\t\t\t   ISC_RLP_CFG_MODE_MASK, rlp_mode);\n}\n\nstatic void isc_sama5d2_adapt_pipeline(struct isc_device *isc)\n{\n\tisc->try_config.bits_pipeline &= ISC_SAMA5D2_PIPELINE;\n}\n\n \nstatic const u32 isc_sama5d2_gamma_table[][GAMMA_ENTRIES] = {\n\t \n\t{      0x65,  0x66002F,  0x950025,  0xBB0020,  0xDB001D,  0xF8001A,\n\t  0x1130018, 0x12B0017, 0x1420016, 0x1580014, 0x16D0013, 0x1810012,\n\t  0x1940012, 0x1A60012, 0x1B80011, 0x1C90010, 0x1DA0010, 0x1EA000F,\n\t  0x1FA000F, 0x209000F, 0x218000F, 0x227000E, 0x235000E, 0x243000E,\n\t  0x251000E, 0x25F000D, 0x26C000D, 0x279000D, 0x286000D, 0x293000C,\n\t  0x2A0000C, 0x2AC000C, 0x2B8000C, 0x2C4000C, 0x2D0000B, 0x2DC000B,\n\t  0x2E7000B, 0x2F3000B, 0x2FE000B, 0x309000B, 0x314000B, 0x31F000A,\n\t  0x32A000A, 0x334000B, 0x33F000A, 0x349000A, 0x354000A, 0x35E000A,\n\t  0x368000A, 0x372000A, 0x37C000A, 0x386000A, 0x3900009, 0x399000A,\n\t  0x3A30009, 0x3AD0009, 0x3B60009, 0x3BF000A, 0x3C90009, 0x3D20009,\n\t  0x3DB0009, 0x3E40009, 0x3ED0009, 0x3F60009 },\n\n\t \n\t{      0x7F,  0x800034,  0xB50028,  0xDE0021, 0x100001E, 0x11E001B,\n\t  0x1390019, 0x1520017, 0x16A0015, 0x1800014, 0x1940014, 0x1A80013,\n\t  0x1BB0012, 0x1CD0011, 0x1DF0010, 0x1EF0010, 0x200000F, 0x20F000F,\n\t  0x21F000E, 0x22D000F, 0x23C000E, 0x24A000E, 0x258000D, 0x265000D,\n\t  0x273000C, 0x27F000D, 0x28C000C, 0x299000C, 0x2A5000C, 0x2B1000B,\n\t  0x2BC000C, 0x2C8000B, 0x2D3000C, 0x2DF000B, 0x2EA000A, 0x2F5000A,\n\t  0x2FF000B, 0x30A000A, 0x314000B, 0x31F000A, 0x329000A, 0x333000A,\n\t  0x33D0009, 0x3470009, 0x350000A, 0x35A0009, 0x363000A, 0x36D0009,\n\t  0x3760009, 0x37F0009, 0x3880009, 0x3910009, 0x39A0009, 0x3A30009,\n\t  0x3AC0008, 0x3B40009, 0x3BD0008, 0x3C60008, 0x3CE0008, 0x3D60009,\n\t  0x3DF0008, 0x3E70008, 0x3EF0008, 0x3F70008 },\n\n\t \n\t{      0x99,  0x9B0038,  0xD4002A,  0xFF0023, 0x122001F, 0x141001B,\n\t  0x15D0019, 0x1760017, 0x18E0015, 0x1A30015, 0x1B80013, 0x1CC0012,\n\t  0x1DE0011, 0x1F00010, 0x2010010, 0x2110010, 0x221000F, 0x230000F,\n\t  0x23F000E, 0x24D000E, 0x25B000D, 0x269000C, 0x276000C, 0x283000C,\n\t  0x28F000C, 0x29B000C, 0x2A7000C, 0x2B3000B, 0x2BF000B, 0x2CA000B,\n\t  0x2D5000B, 0x2E0000A, 0x2EB000A, 0x2F5000A, 0x2FF000A, 0x30A000A,\n\t  0x3140009, 0x31E0009, 0x327000A, 0x3310009, 0x33A0009, 0x3440009,\n\t  0x34D0009, 0x3560009, 0x35F0009, 0x3680008, 0x3710008, 0x3790009,\n\t  0x3820008, 0x38A0008, 0x3930008, 0x39B0008, 0x3A30008, 0x3AB0008,\n\t  0x3B30008, 0x3BB0008, 0x3C30008, 0x3CB0007, 0x3D20008, 0x3DA0007,\n\t  0x3E20007, 0x3E90007, 0x3F00008, 0x3F80007 },\n};\n\nstatic int isc_parse_dt(struct device *dev, struct isc_device *isc)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *epn = NULL;\n\tstruct isc_subdev_entity *subdev_entity;\n\tunsigned int flags;\n\tint ret;\n\n\tINIT_LIST_HEAD(&isc->subdev_entities);\n\n\twhile (1) {\n\t\tstruct v4l2_fwnode_endpoint v4l2_epn = { .bus_type = 0 };\n\n\t\tepn = of_graph_get_next_endpoint(np, epn);\n\t\tif (!epn)\n\t\t\treturn 0;\n\n\t\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(epn),\n\t\t\t\t\t\t &v4l2_epn);\n\t\tif (ret) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(dev, \"Could not parse the endpoint\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tsubdev_entity = devm_kzalloc(dev, sizeof(*subdev_entity),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!subdev_entity) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tsubdev_entity->epn = epn;\n\n\t\tflags = v4l2_epn.bus.parallel.flags;\n\n\t\tif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\n\t\t\tsubdev_entity->pfe_cfg0 = ISC_PFE_CFG0_HPOL_LOW;\n\n\t\tif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\n\t\t\tsubdev_entity->pfe_cfg0 |= ISC_PFE_CFG0_VPOL_LOW;\n\n\t\tif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\n\t\t\tsubdev_entity->pfe_cfg0 |= ISC_PFE_CFG0_PPOL_LOW;\n\n\t\tif (v4l2_epn.bus_type == V4L2_MBUS_BT656)\n\t\t\tsubdev_entity->pfe_cfg0 |= ISC_PFE_CFG0_CCIR_CRC |\n\t\t\t\t\tISC_PFE_CFG0_CCIR656;\n\n\t\tlist_add_tail(&subdev_entity->list, &isc->subdev_entities);\n\t}\n\tof_node_put(epn);\n\n\treturn ret;\n}\n\nstatic int microchip_isc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct isc_device *isc;\n\tvoid __iomem *io_base;\n\tstruct isc_subdev_entity *subdev_entity;\n\tint irq;\n\tint ret;\n\tu32 ver;\n\n\tisc = devm_kzalloc(dev, sizeof(*isc), GFP_KERNEL);\n\tif (!isc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, isc);\n\tisc->dev = dev;\n\n\tio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\tisc->regmap = devm_regmap_init_mmio(dev, io_base, &microchip_isc_regmap_config);\n\tif (IS_ERR(isc->regmap)) {\n\t\tret = PTR_ERR(isc->regmap);\n\t\tdev_err(dev, \"failed to init register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, microchip_isc_interrupt, 0,\n\t\t\t       \"microchip-sama5d2-isc\", isc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't register ISR for IRQ %u (ret=%i)\\n\",\n\t\t\tirq, ret);\n\t\treturn ret;\n\t}\n\n\tisc->gamma_table = isc_sama5d2_gamma_table;\n\tisc->gamma_max = 2;\n\n\tisc->max_width = ISC_SAMA5D2_MAX_SUPPORT_WIDTH;\n\tisc->max_height = ISC_SAMA5D2_MAX_SUPPORT_HEIGHT;\n\n\tisc->config_dpc = isc_sama5d2_config_dpc;\n\tisc->config_csc = isc_sama5d2_config_csc;\n\tisc->config_cbc = isc_sama5d2_config_cbc;\n\tisc->config_cc = isc_sama5d2_config_cc;\n\tisc->config_gam = isc_sama5d2_config_gam;\n\tisc->config_rlp = isc_sama5d2_config_rlp;\n\tisc->config_ctrls = isc_sama5d2_config_ctrls;\n\n\tisc->adapt_pipeline = isc_sama5d2_adapt_pipeline;\n\n\tisc->offsets.csc = ISC_SAMA5D2_CSC_OFFSET;\n\tisc->offsets.cbc = ISC_SAMA5D2_CBC_OFFSET;\n\tisc->offsets.sub422 = ISC_SAMA5D2_SUB422_OFFSET;\n\tisc->offsets.sub420 = ISC_SAMA5D2_SUB420_OFFSET;\n\tisc->offsets.rlp = ISC_SAMA5D2_RLP_OFFSET;\n\tisc->offsets.his = ISC_SAMA5D2_HIS_OFFSET;\n\tisc->offsets.dma = ISC_SAMA5D2_DMA_OFFSET;\n\tisc->offsets.version = ISC_SAMA5D2_VERSION_OFFSET;\n\tisc->offsets.his_entry = ISC_SAMA5D2_HIS_ENTRY_OFFSET;\n\n\tisc->controller_formats = sama5d2_controller_formats;\n\tisc->controller_formats_size = ARRAY_SIZE(sama5d2_controller_formats);\n\tisc->formats_list = sama5d2_formats_list;\n\tisc->formats_list_size = ARRAY_SIZE(sama5d2_formats_list);\n\n\t \n\tisc->dcfg = ISC_DCFG_YMBSIZE_BEATS8 | ISC_DCFG_CMBSIZE_BEATS8;\n\n\t \n\tisc->ispck_required = true;\n\n\tret = microchip_isc_pipeline_init(isc);\n\tif (ret)\n\t\treturn ret;\n\n\tisc->hclock = devm_clk_get(dev, \"hclock\");\n\tif (IS_ERR(isc->hclock)) {\n\t\tret = PTR_ERR(isc->hclock);\n\t\tdev_err(dev, \"failed to get hclock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(isc->hclock);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable hclock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = microchip_isc_clk_init(isc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init isc clock: %d\\n\", ret);\n\t\tgoto unprepare_hclk;\n\t}\n\tret = v4l2_device_register(dev, &isc->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to register v4l2 device.\\n\");\n\t\tgoto unprepare_clk;\n\t}\n\n\tret = isc_parse_dt(dev, isc);\n\tif (ret) {\n\t\tdev_err(dev, \"fail to parse device tree\\n\");\n\t\tgoto unregister_v4l2_device;\n\t}\n\n\tif (list_empty(&isc->subdev_entities)) {\n\t\tdev_err(dev, \"no subdev found\\n\");\n\t\tret = -ENODEV;\n\t\tgoto unregister_v4l2_device;\n\t}\n\n\tlist_for_each_entry(subdev_entity, &isc->subdev_entities, list) {\n\t\tstruct v4l2_async_connection *asd;\n\t\tstruct fwnode_handle *fwnode =\n\t\t\tof_fwnode_handle(subdev_entity->epn);\n\n\t\tv4l2_async_nf_init(&subdev_entity->notifier, &isc->v4l2_dev);\n\n\t\tasd = v4l2_async_nf_add_fwnode_remote(&subdev_entity->notifier,\n\t\t\t\t\t\t      fwnode,\n\t\t\t\t\t\t      struct v4l2_async_connection);\n\n\t\tof_node_put(subdev_entity->epn);\n\t\tsubdev_entity->epn = NULL;\n\n\t\tif (IS_ERR(asd)) {\n\t\t\tret = PTR_ERR(asd);\n\t\t\tgoto cleanup_subdev;\n\t\t}\n\n\t\tsubdev_entity->notifier.ops = &microchip_isc_async_ops;\n\n\t\tret = v4l2_async_nf_register(&subdev_entity->notifier);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"fail to register async notifier\\n\");\n\t\t\tgoto cleanup_subdev;\n\t\t}\n\n\t\tif (video_is_registered(&isc->video_dev))\n\t\t\tbreak;\n\t}\n\n\tregmap_read(isc->regmap, ISC_VERSION + isc->offsets.version, &ver);\n\n\tret = isc_mc_init(isc, ver);\n\tif (ret < 0)\n\t\tgoto isc_probe_mc_init_err;\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_request_idle(dev);\n\n\tisc->ispck = isc->isc_clks[ISC_ISPCK].clk;\n\n\tret = clk_prepare_enable(isc->ispck);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable ispck: %d\\n\", ret);\n\t\tgoto disable_pm;\n\t}\n\n\t \n\tret = clk_set_rate(isc->ispck, clk_get_rate(isc->hclock));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set ispck rate: %d\\n\", ret);\n\t\tgoto unprepare_clk;\n\t}\n\n\tdev_info(dev, \"Microchip ISC version %x\\n\", ver);\n\n\treturn 0;\n\nunprepare_clk:\n\tclk_disable_unprepare(isc->ispck);\n\ndisable_pm:\n\tpm_runtime_disable(dev);\n\nisc_probe_mc_init_err:\n\tisc_mc_cleanup(isc);\n\ncleanup_subdev:\n\tmicrochip_isc_subdev_cleanup(isc);\n\nunregister_v4l2_device:\n\tv4l2_device_unregister(&isc->v4l2_dev);\n\nunprepare_hclk:\n\tclk_disable_unprepare(isc->hclock);\n\n\tmicrochip_isc_clk_cleanup(isc);\n\n\treturn ret;\n}\n\nstatic void microchip_isc_remove(struct platform_device *pdev)\n{\n\tstruct isc_device *isc = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tisc_mc_cleanup(isc);\n\n\tmicrochip_isc_subdev_cleanup(isc);\n\n\tv4l2_device_unregister(&isc->v4l2_dev);\n\n\tclk_disable_unprepare(isc->ispck);\n\tclk_disable_unprepare(isc->hclock);\n\n\tmicrochip_isc_clk_cleanup(isc);\n}\n\nstatic int __maybe_unused isc_runtime_suspend(struct device *dev)\n{\n\tstruct isc_device *isc = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(isc->ispck);\n\tclk_disable_unprepare(isc->hclock);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused isc_runtime_resume(struct device *dev)\n{\n\tstruct isc_device *isc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(isc->hclock);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(isc->ispck);\n\tif (ret)\n\t\tclk_disable_unprepare(isc->hclock);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops microchip_isc_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(isc_runtime_suspend, isc_runtime_resume, NULL)\n};\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id microchip_isc_of_match[] = {\n\t{ .compatible = \"atmel,sama5d2-isc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, microchip_isc_of_match);\n#endif\n\nstatic struct platform_driver microchip_isc_driver = {\n\t.probe\t= microchip_isc_probe,\n\t.remove_new = microchip_isc_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"microchip-sama5d2-isc\",\n\t\t.pm\t\t= &microchip_isc_dev_pm_ops,\n\t\t.of_match_table = of_match_ptr(microchip_isc_of_match),\n\t},\n};\n\nmodule_platform_driver(microchip_isc_driver);\n\nMODULE_AUTHOR(\"Songjun Wu\");\nMODULE_DESCRIPTION(\"The V4L2 driver for Microchip-ISC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}