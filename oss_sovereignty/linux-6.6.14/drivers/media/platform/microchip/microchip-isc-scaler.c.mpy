{
  "module_name": "microchip-isc-scaler.c",
  "hash_id": "b4e8fd635c54bc2e0ad9e218223367fca1e9a95ea22b35eb8b2e0d30e4f900ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/microchip/microchip-isc-scaler.c",
  "human_readable_source": "\n \n\n#include <media/media-device.h>\n#include <media/media-entity.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-subdev.h>\n\n#include \"microchip-isc-regs.h\"\n#include \"microchip-isc.h\"\n\nstatic void isc_scaler_prepare_fmt(struct v4l2_mbus_framefmt *framefmt)\n{\n\tframefmt->colorspace = V4L2_COLORSPACE_SRGB;\n\tframefmt->field = V4L2_FIELD_NONE;\n\tframefmt->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tframefmt->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tframefmt->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n};\n\nstatic int isc_scaler_get_fmt(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *format)\n{\n\tstruct isc_device *isc = container_of(sd, struct isc_device, scaler_sd);\n\tstruct v4l2_mbus_framefmt *v4l2_try_fmt;\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tv4l2_try_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\t  format->pad);\n\t\tformat->format = *v4l2_try_fmt;\n\n\t\treturn 0;\n\t}\n\n\tformat->format = isc->scaler_format[format->pad];\n\n\treturn 0;\n}\n\nstatic int isc_scaler_set_fmt(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *req_fmt)\n{\n\tstruct isc_device *isc = container_of(sd, struct isc_device, scaler_sd);\n\tstruct v4l2_mbus_framefmt *v4l2_try_fmt;\n\tstruct isc_format *fmt;\n\tunsigned int i;\n\n\t \n\tif (req_fmt->pad == ISC_SCALER_PAD_SOURCE) {\n\t\treq_fmt->format = isc->scaler_format[ISC_SCALER_PAD_SOURCE];\n\t\treturn 0;\n\t}\n\n\t \n\tv4l_bound_align_image(&req_fmt->format.width, 16, UINT_MAX, 0,\n\t\t\t      &req_fmt->format.height, 16, UINT_MAX, 0, 0);\n\n\tisc_scaler_prepare_fmt(&req_fmt->format);\n\n\tfmt = isc_find_format_by_code(isc, req_fmt->format.code, &i);\n\n\tif (!fmt)\n\t\tfmt = &isc->formats_list[0];\n\n\treq_fmt->format.code = fmt->mbus_code;\n\n\tif (req_fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tv4l2_try_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\t  req_fmt->pad);\n\t\t*v4l2_try_fmt = req_fmt->format;\n\t\t \n\t\tv4l2_try_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\t  ISC_SCALER_PAD_SOURCE);\n\t\t*v4l2_try_fmt = req_fmt->format;\n\n\t\tv4l_bound_align_image(&v4l2_try_fmt->width,\n\t\t\t\t      16, isc->max_width, 0,\n\t\t\t\t      &v4l2_try_fmt->height,\n\t\t\t\t      16, isc->max_height, 0, 0);\n\t\t \n\t\treturn 0;\n\t}\n\n\tisc->scaler_format[ISC_SCALER_PAD_SINK] = req_fmt->format;\n\n\t \n\tisc->scaler_format[ISC_SCALER_PAD_SOURCE] =\n\t\tisc->scaler_format[ISC_SCALER_PAD_SINK];\n\tv4l_bound_align_image\n\t\t(&isc->scaler_format[ISC_SCALER_PAD_SOURCE].width, 16,\n\t\t isc->max_width, 0,\n\t\t &isc->scaler_format[ISC_SCALER_PAD_SOURCE].height, 16,\n\t\t isc->max_height, 0, 0);\n\n\treturn 0;\n}\n\nstatic int isc_scaler_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct isc_device *isc = container_of(sd, struct isc_device, scaler_sd);\n\n\t \n\tif (code->index < isc->formats_list_size) {\n\t\tcode->code = isc->formats_list[code->index].mbus_code;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int isc_scaler_g_sel(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_selection *sel)\n{\n\tstruct isc_device *isc = container_of(sd, struct isc_device, scaler_sd);\n\n\tif (sel->pad == ISC_SCALER_PAD_SOURCE)\n\t\treturn -EINVAL;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP_BOUNDS &&\n\t    sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tsel->r.height = isc->scaler_format[ISC_SCALER_PAD_SOURCE].height;\n\tsel->r.width = isc->scaler_format[ISC_SCALER_PAD_SOURCE].width;\n\n\tsel->r.left = 0;\n\tsel->r.top = 0;\n\n\treturn 0;\n}\n\nstatic int isc_scaler_init_cfg(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_mbus_framefmt *v4l2_try_fmt =\n\t\tv4l2_subdev_get_try_format(sd, sd_state, 0);\n\tstruct v4l2_rect *try_crop;\n\tstruct isc_device *isc = container_of(sd, struct isc_device, scaler_sd);\n\n\t*v4l2_try_fmt = isc->scaler_format[ISC_SCALER_PAD_SOURCE];\n\n\ttry_crop = v4l2_subdev_get_try_crop(sd, sd_state, 0);\n\n\ttry_crop->top = 0;\n\ttry_crop->left = 0;\n\ttry_crop->width = v4l2_try_fmt->width;\n\ttry_crop->height = v4l2_try_fmt->height;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops isc_scaler_pad_ops = {\n\t.enum_mbus_code = isc_scaler_enum_mbus_code,\n\t.set_fmt = isc_scaler_set_fmt,\n\t.get_fmt = isc_scaler_get_fmt,\n\t.get_selection = isc_scaler_g_sel,\n\t.init_cfg = isc_scaler_init_cfg,\n};\n\nstatic const struct media_entity_operations isc_scaler_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic const struct v4l2_subdev_ops xisc_scaler_subdev_ops = {\n\t.pad = &isc_scaler_pad_ops,\n};\n\nint isc_scaler_init(struct isc_device *isc)\n{\n\tint ret;\n\n\tv4l2_subdev_init(&isc->scaler_sd, &xisc_scaler_subdev_ops);\n\n\tisc->scaler_sd.owner = THIS_MODULE;\n\tisc->scaler_sd.dev = isc->dev;\n\tsnprintf(isc->scaler_sd.name, sizeof(isc->scaler_sd.name),\n\t\t \"microchip_isc_scaler\");\n\n\tisc->scaler_sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tisc->scaler_sd.entity.function = MEDIA_ENT_F_PROC_VIDEO_SCALER;\n\tisc->scaler_sd.entity.ops = &isc_scaler_entity_ops;\n\tisc->scaler_pads[ISC_SCALER_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tisc->scaler_pads[ISC_SCALER_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\tisc_scaler_prepare_fmt(&isc->scaler_format[ISC_SCALER_PAD_SOURCE]);\n\tisc->scaler_format[ISC_SCALER_PAD_SOURCE].height = isc->max_height;\n\tisc->scaler_format[ISC_SCALER_PAD_SOURCE].width = isc->max_width;\n\tisc->scaler_format[ISC_SCALER_PAD_SOURCE].code =\n\t\t isc->formats_list[0].mbus_code;\n\n\tisc->scaler_format[ISC_SCALER_PAD_SINK] =\n\t\t isc->scaler_format[ISC_SCALER_PAD_SOURCE];\n\n\tret = media_entity_pads_init(&isc->scaler_sd.entity,\n\t\t\t\t     ISC_SCALER_PADS_NUM,\n\t\t\t\t     isc->scaler_pads);\n\tif (ret < 0) {\n\t\tdev_err(isc->dev, \"scaler sd media entity init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = v4l2_device_register_subdev(&isc->v4l2_dev, &isc->scaler_sd);\n\tif (ret < 0) {\n\t\tdev_err(isc->dev, \"scaler sd failed to register subdev\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(isc_scaler_init);\n\nint isc_scaler_link(struct isc_device *isc)\n{\n\tint ret;\n\n\tret = media_create_pad_link(&isc->current_subdev->sd->entity,\n\t\t\t\t    isc->remote_pad, &isc->scaler_sd.entity,\n\t\t\t\t    ISC_SCALER_PAD_SINK,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\n\tif (ret < 0) {\n\t\tdev_err(isc->dev, \"Failed to create pad link: %s to %s\\n\",\n\t\t\tisc->current_subdev->sd->entity.name,\n\t\t\tisc->scaler_sd.entity.name);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(isc->dev, \"link with %s pad: %d\\n\",\n\t\tisc->current_subdev->sd->name, isc->remote_pad);\n\n\tret = media_create_pad_link(&isc->scaler_sd.entity,\n\t\t\t\t    ISC_SCALER_PAD_SOURCE,\n\t\t\t\t    &isc->video_dev.entity, ISC_PAD_SINK,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\n\tif (ret < 0) {\n\t\tdev_err(isc->dev, \"Failed to create pad link: %s to %s\\n\",\n\t\t\tisc->scaler_sd.entity.name,\n\t\t\tisc->video_dev.entity.name);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(isc->dev, \"link with %s pad: %d\\n\", isc->scaler_sd.name,\n\t\tISC_SCALER_PAD_SOURCE);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(isc_scaler_link);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}