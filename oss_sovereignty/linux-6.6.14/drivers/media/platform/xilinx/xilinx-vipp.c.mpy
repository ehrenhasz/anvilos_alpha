{
  "module_name": "xilinx-vipp.c",
  "hash_id": "ab9f6e640eee655b828182b85cbd067f0dc3df58e04e082dcbd72f4e8e22bf2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/xilinx/xilinx-vipp.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n\n#include \"xilinx-dma.h\"\n#include \"xilinx-vipp.h\"\n\n#define XVIPP_DMA_S2MM\t\t\t\t0\n#define XVIPP_DMA_MM2S\t\t\t\t1\n\n \nstruct xvip_graph_entity {\n\tstruct v4l2_async_connection asd;  \n\tstruct media_entity *entity;\n\tstruct v4l2_subdev *subdev;\n};\n\nstatic inline struct xvip_graph_entity *\nto_xvip_entity(struct v4l2_async_connection *asd)\n{\n\treturn container_of(asd, struct xvip_graph_entity, asd);\n}\n\n \n\nstatic struct xvip_graph_entity *\nxvip_graph_find_entity(struct xvip_composite_device *xdev,\n\t\t       const struct fwnode_handle *fwnode)\n{\n\tstruct xvip_graph_entity *entity;\n\tstruct v4l2_async_connection *asd;\n\tstruct list_head *lists[] = {\n\t\t&xdev->notifier.done_list,\n\t\t&xdev->notifier.waiting_list\n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lists); i++) {\n\t\tlist_for_each_entry(asd, lists[i], asc_entry) {\n\t\t\tentity = to_xvip_entity(asd);\n\t\t\tif (entity->asd.match.fwnode == fwnode)\n\t\t\t\treturn entity;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int xvip_graph_build_one(struct xvip_composite_device *xdev,\n\t\t\t\tstruct xvip_graph_entity *entity)\n{\n\tu32 link_flags = MEDIA_LNK_FL_ENABLED;\n\tstruct media_entity *local = entity->entity;\n\tstruct media_entity *remote;\n\tstruct media_pad *local_pad;\n\tstruct media_pad *remote_pad;\n\tstruct xvip_graph_entity *ent;\n\tstruct v4l2_fwnode_link link;\n\tstruct fwnode_handle *ep = NULL;\n\tint ret = 0;\n\n\tdev_dbg(xdev->dev, \"creating links for entity %s\\n\", local->name);\n\n\twhile (1) {\n\t\t \n\t\tep = fwnode_graph_get_next_endpoint(entity->asd.match.fwnode,\n\t\t\t\t\t\t    ep);\n\t\tif (ep == NULL)\n\t\t\tbreak;\n\n\t\tdev_dbg(xdev->dev, \"processing endpoint %p\\n\", ep);\n\n\t\tret = v4l2_fwnode_parse_link(ep, &link);\n\t\tif (ret < 0) {\n\t\t\tdev_err(xdev->dev, \"failed to parse link for %p\\n\",\n\t\t\t\tep);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (link.local_port >= local->num_pads) {\n\t\t\tdev_err(xdev->dev, \"invalid port number %u for %p\\n\",\n\t\t\t\tlink.local_port, link.local_node);\n\t\t\tv4l2_fwnode_put_link(&link);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tlocal_pad = &local->pads[link.local_port];\n\n\t\tif (local_pad->flags & MEDIA_PAD_FL_SINK) {\n\t\t\tdev_dbg(xdev->dev, \"skipping sink port %p:%u\\n\",\n\t\t\t\tlink.local_node, link.local_port);\n\t\t\tv4l2_fwnode_put_link(&link);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (link.remote_node == of_fwnode_handle(xdev->dev->of_node)) {\n\t\t\tdev_dbg(xdev->dev, \"skipping DMA port %p:%u\\n\",\n\t\t\t\tlink.local_node, link.local_port);\n\t\t\tv4l2_fwnode_put_link(&link);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tent = xvip_graph_find_entity(xdev, link.remote_node);\n\t\tif (ent == NULL) {\n\t\t\tdev_err(xdev->dev, \"no entity found for %p\\n\",\n\t\t\t\tlink.remote_node);\n\t\t\tv4l2_fwnode_put_link(&link);\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tremote = ent->entity;\n\n\t\tif (link.remote_port >= remote->num_pads) {\n\t\t\tdev_err(xdev->dev, \"invalid port number %u on %p\\n\",\n\t\t\t\tlink.remote_port, link.remote_node);\n\t\t\tv4l2_fwnode_put_link(&link);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tremote_pad = &remote->pads[link.remote_port];\n\n\t\tv4l2_fwnode_put_link(&link);\n\n\t\t \n\t\tdev_dbg(xdev->dev, \"creating %s:%u -> %s:%u link\\n\",\n\t\t\tlocal->name, local_pad->index,\n\t\t\tremote->name, remote_pad->index);\n\n\t\tret = media_create_pad_link(local, local_pad->index,\n\t\t\t\t\t       remote, remote_pad->index,\n\t\t\t\t\t       link_flags);\n\t\tif (ret < 0) {\n\t\t\tdev_err(xdev->dev,\n\t\t\t\t\"failed to create %s:%u -> %s:%u link\\n\",\n\t\t\t\tlocal->name, local_pad->index,\n\t\t\t\tremote->name, remote_pad->index);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfwnode_handle_put(ep);\n\treturn ret;\n}\n\nstatic struct xvip_dma *\nxvip_graph_find_dma(struct xvip_composite_device *xdev, unsigned int port)\n{\n\tstruct xvip_dma *dma;\n\n\tlist_for_each_entry(dma, &xdev->dmas, list) {\n\t\tif (dma->port == port)\n\t\t\treturn dma;\n\t}\n\n\treturn NULL;\n}\n\nstatic int xvip_graph_build_dma(struct xvip_composite_device *xdev)\n{\n\tu32 link_flags = MEDIA_LNK_FL_ENABLED;\n\tstruct device_node *node = xdev->dev->of_node;\n\tstruct media_entity *source;\n\tstruct media_entity *sink;\n\tstruct media_pad *source_pad;\n\tstruct media_pad *sink_pad;\n\tstruct xvip_graph_entity *ent;\n\tstruct v4l2_fwnode_link link;\n\tstruct device_node *ep = NULL;\n\tstruct xvip_dma *dma;\n\tint ret = 0;\n\n\tdev_dbg(xdev->dev, \"creating links for DMA engines\\n\");\n\n\twhile (1) {\n\t\t \n\t\tep = of_graph_get_next_endpoint(node, ep);\n\t\tif (ep == NULL)\n\t\t\tbreak;\n\n\t\tdev_dbg(xdev->dev, \"processing endpoint %pOF\\n\", ep);\n\n\t\tret = v4l2_fwnode_parse_link(of_fwnode_handle(ep), &link);\n\t\tif (ret < 0) {\n\t\t\tdev_err(xdev->dev, \"failed to parse link for %pOF\\n\",\n\t\t\t\tep);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdma = xvip_graph_find_dma(xdev, link.local_port);\n\t\tif (dma == NULL) {\n\t\t\tdev_err(xdev->dev, \"no DMA engine found for port %u\\n\",\n\t\t\t\tlink.local_port);\n\t\t\tv4l2_fwnode_put_link(&link);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(xdev->dev, \"creating link for DMA engine %s\\n\",\n\t\t\tdma->video.name);\n\n\t\t \n\t\tent = xvip_graph_find_entity(xdev, link.remote_node);\n\t\tif (ent == NULL) {\n\t\t\tdev_err(xdev->dev, \"no entity found for %pOF\\n\",\n\t\t\t\tto_of_node(link.remote_node));\n\t\t\tv4l2_fwnode_put_link(&link);\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (link.remote_port >= ent->entity->num_pads) {\n\t\t\tdev_err(xdev->dev, \"invalid port number %u on %pOF\\n\",\n\t\t\t\tlink.remote_port,\n\t\t\t\tto_of_node(link.remote_node));\n\t\t\tv4l2_fwnode_put_link(&link);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (dma->pad.flags & MEDIA_PAD_FL_SOURCE) {\n\t\t\tsource = &dma->video.entity;\n\t\t\tsource_pad = &dma->pad;\n\t\t\tsink = ent->entity;\n\t\t\tsink_pad = &sink->pads[link.remote_port];\n\t\t} else {\n\t\t\tsource = ent->entity;\n\t\t\tsource_pad = &source->pads[link.remote_port];\n\t\t\tsink = &dma->video.entity;\n\t\t\tsink_pad = &dma->pad;\n\t\t}\n\n\t\tv4l2_fwnode_put_link(&link);\n\n\t\t \n\t\tdev_dbg(xdev->dev, \"creating %s:%u -> %s:%u link\\n\",\n\t\t\tsource->name, source_pad->index,\n\t\t\tsink->name, sink_pad->index);\n\n\t\tret = media_create_pad_link(source, source_pad->index,\n\t\t\t\t\t       sink, sink_pad->index,\n\t\t\t\t\t       link_flags);\n\t\tif (ret < 0) {\n\t\t\tdev_err(xdev->dev,\n\t\t\t\t\"failed to create %s:%u -> %s:%u link\\n\",\n\t\t\t\tsource->name, source_pad->index,\n\t\t\t\tsink->name, sink_pad->index);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tof_node_put(ep);\n\treturn ret;\n}\n\nstatic int xvip_graph_notify_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct xvip_composite_device *xdev =\n\t\tcontainer_of(notifier, struct xvip_composite_device, notifier);\n\tstruct xvip_graph_entity *entity;\n\tstruct v4l2_async_connection *asd;\n\tint ret;\n\n\tdev_dbg(xdev->dev, \"notify complete, all subdevs registered\\n\");\n\n\t \n\tlist_for_each_entry(asd, &xdev->notifier.done_list, asc_entry) {\n\t\tentity = to_xvip_entity(asd);\n\t\tret = xvip_graph_build_one(xdev, entity);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = xvip_graph_build_dma(xdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = v4l2_device_register_subdev_nodes(&xdev->v4l2_dev);\n\tif (ret < 0)\n\t\tdev_err(xdev->dev, \"failed to register subdev nodes\\n\");\n\n\treturn media_device_register(&xdev->media_dev);\n}\n\nstatic int xvip_graph_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t   struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_async_connection *asc)\n{\n\tstruct xvip_graph_entity *entity = to_xvip_entity(asc);\n\n\tentity->entity = &subdev->entity;\n\tentity->subdev = subdev;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_async_notifier_operations xvip_graph_notify_ops = {\n\t.bound = xvip_graph_notify_bound,\n\t.complete = xvip_graph_notify_complete,\n};\n\nstatic int xvip_graph_parse_one(struct xvip_composite_device *xdev,\n\t\t\t\tstruct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *remote;\n\tstruct fwnode_handle *ep = NULL;\n\tint ret = 0;\n\n\tdev_dbg(xdev->dev, \"parsing node %p\\n\", fwnode);\n\n\twhile (1) {\n\t\tstruct xvip_graph_entity *xge;\n\n\t\tep = fwnode_graph_get_next_endpoint(fwnode, ep);\n\t\tif (ep == NULL)\n\t\t\tbreak;\n\n\t\tdev_dbg(xdev->dev, \"handling endpoint %p\\n\", ep);\n\n\t\tremote = fwnode_graph_get_remote_port_parent(ep);\n\t\tif (remote == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_notifier_cleanup;\n\t\t}\n\n\t\tfwnode_handle_put(ep);\n\n\t\t \n\t\tif (remote == of_fwnode_handle(xdev->dev->of_node) ||\n\t\t    xvip_graph_find_entity(xdev, remote)) {\n\t\t\tfwnode_handle_put(remote);\n\t\t\tcontinue;\n\t\t}\n\n\t\txge = v4l2_async_nf_add_fwnode(&xdev->notifier, remote,\n\t\t\t\t\t       struct xvip_graph_entity);\n\t\tfwnode_handle_put(remote);\n\t\tif (IS_ERR(xge)) {\n\t\t\tret = PTR_ERR(xge);\n\t\t\tgoto err_notifier_cleanup;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_notifier_cleanup:\n\tv4l2_async_nf_cleanup(&xdev->notifier);\n\tfwnode_handle_put(ep);\n\treturn ret;\n}\n\nstatic int xvip_graph_parse(struct xvip_composite_device *xdev)\n{\n\tstruct xvip_graph_entity *entity;\n\tstruct v4l2_async_connection *asd;\n\tint ret;\n\n\t \n\tret = xvip_graph_parse_one(xdev, of_fwnode_handle(xdev->dev->of_node));\n\tif (ret < 0)\n\t\treturn 0;\n\n\tlist_for_each_entry(asd, &xdev->notifier.waiting_list, asc_entry) {\n\t\tentity = to_xvip_entity(asd);\n\t\tret = xvip_graph_parse_one(xdev, entity->asd.match.fwnode);\n\t\tif (ret < 0) {\n\t\t\tv4l2_async_nf_cleanup(&xdev->notifier);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int xvip_graph_dma_init_one(struct xvip_composite_device *xdev,\n\t\t\t\t   struct device_node *node)\n{\n\tstruct xvip_dma *dma;\n\tenum v4l2_buf_type type;\n\tconst char *direction;\n\tunsigned int index;\n\tint ret;\n\n\tret = of_property_read_string(node, \"direction\", &direction);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (strcmp(direction, \"input\") == 0)\n\t\ttype = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\telse if (strcmp(direction, \"output\") == 0)\n\t\ttype = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\telse\n\t\treturn -EINVAL;\n\n\tof_property_read_u32(node, \"reg\", &index);\n\n\tdma = devm_kzalloc(xdev->dev, sizeof(*dma), GFP_KERNEL);\n\tif (dma == NULL)\n\t\treturn -ENOMEM;\n\n\tret = xvip_dma_init(xdev, dma, type, index);\n\tif (ret < 0) {\n\t\tdev_err(xdev->dev, \"%pOF initialization failed\\n\", node);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&dma->list, &xdev->dmas);\n\n\txdev->v4l2_caps |= type == V4L2_BUF_TYPE_VIDEO_CAPTURE\n\t\t\t ? V4L2_CAP_VIDEO_CAPTURE : V4L2_CAP_VIDEO_OUTPUT;\n\n\treturn 0;\n}\n\nstatic int xvip_graph_dma_init(struct xvip_composite_device *xdev)\n{\n\tstruct device_node *ports;\n\tstruct device_node *port;\n\tint ret = 0;\n\n\tports = of_get_child_by_name(xdev->dev->of_node, \"ports\");\n\tif (ports == NULL) {\n\t\tdev_err(xdev->dev, \"ports node not present\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_child_of_node(ports, port) {\n\t\tret = xvip_graph_dma_init_one(xdev, port);\n\t\tif (ret) {\n\t\t\tof_node_put(port);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tof_node_put(ports);\n\treturn ret;\n}\n\nstatic void xvip_graph_cleanup(struct xvip_composite_device *xdev)\n{\n\tstruct xvip_dma *dmap;\n\tstruct xvip_dma *dma;\n\n\tv4l2_async_nf_unregister(&xdev->notifier);\n\tv4l2_async_nf_cleanup(&xdev->notifier);\n\n\tlist_for_each_entry_safe(dma, dmap, &xdev->dmas, list) {\n\t\txvip_dma_cleanup(dma);\n\t\tlist_del(&dma->list);\n\t}\n}\n\nstatic int xvip_graph_init(struct xvip_composite_device *xdev)\n{\n\tint ret;\n\n\t \n\tret = xvip_graph_dma_init(xdev);\n\tif (ret < 0) {\n\t\tdev_err(xdev->dev, \"DMA initialization failed\\n\");\n\t\tgoto done;\n\t}\n\n\tv4l2_async_nf_init(&xdev->notifier, &xdev->v4l2_dev);\n\n\t \n\tret = xvip_graph_parse(xdev);\n\tif (ret < 0) {\n\t\tdev_err(xdev->dev, \"graph parsing failed\\n\");\n\t\tgoto done;\n\t}\n\n\tif (list_empty(&xdev->notifier.waiting_list)) {\n\t\tdev_err(xdev->dev, \"no subdev found in graph\\n\");\n\t\tret = -ENOENT;\n\t\tgoto done;\n\t}\n\n\t \n\txdev->notifier.ops = &xvip_graph_notify_ops;\n\n\tret = v4l2_async_nf_register(&xdev->notifier);\n\tif (ret < 0) {\n\t\tdev_err(xdev->dev, \"notifier registration failed\\n\");\n\t\tgoto done;\n\t}\n\n\tret = 0;\n\ndone:\n\tif (ret < 0)\n\t\txvip_graph_cleanup(xdev);\n\n\treturn ret;\n}\n\n \n\nstatic void xvip_composite_v4l2_cleanup(struct xvip_composite_device *xdev)\n{\n\tv4l2_device_unregister(&xdev->v4l2_dev);\n\tmedia_device_unregister(&xdev->media_dev);\n\tmedia_device_cleanup(&xdev->media_dev);\n}\n\nstatic int xvip_composite_v4l2_init(struct xvip_composite_device *xdev)\n{\n\tint ret;\n\n\txdev->media_dev.dev = xdev->dev;\n\tstrscpy(xdev->media_dev.model, \"Xilinx Video Composite Device\",\n\t\tsizeof(xdev->media_dev.model));\n\txdev->media_dev.hw_revision = 0;\n\n\tmedia_device_init(&xdev->media_dev);\n\n\txdev->v4l2_dev.mdev = &xdev->media_dev;\n\tret = v4l2_device_register(xdev->dev, &xdev->v4l2_dev);\n\tif (ret < 0) {\n\t\tdev_err(xdev->dev, \"V4L2 device registration failed (%d)\\n\",\n\t\t\tret);\n\t\tmedia_device_cleanup(&xdev->media_dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int xvip_composite_probe(struct platform_device *pdev)\n{\n\tstruct xvip_composite_device *xdev;\n\tint ret;\n\n\txdev = devm_kzalloc(&pdev->dev, sizeof(*xdev), GFP_KERNEL);\n\tif (!xdev)\n\t\treturn -ENOMEM;\n\n\txdev->dev = &pdev->dev;\n\tINIT_LIST_HEAD(&xdev->dmas);\n\n\tret = xvip_composite_v4l2_init(xdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = xvip_graph_init(xdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tplatform_set_drvdata(pdev, xdev);\n\n\tdev_info(xdev->dev, \"device registered\\n\");\n\n\treturn 0;\n\nerror:\n\txvip_composite_v4l2_cleanup(xdev);\n\treturn ret;\n}\n\nstatic void xvip_composite_remove(struct platform_device *pdev)\n{\n\tstruct xvip_composite_device *xdev = platform_get_drvdata(pdev);\n\n\txvip_graph_cleanup(xdev);\n\txvip_composite_v4l2_cleanup(xdev);\n}\n\nstatic const struct of_device_id xvip_composite_of_id_table[] = {\n\t{ .compatible = \"xlnx,video\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, xvip_composite_of_id_table);\n\nstatic struct platform_driver xvip_composite_driver = {\n\t.driver = {\n\t\t.name = \"xilinx-video\",\n\t\t.of_match_table = xvip_composite_of_id_table,\n\t},\n\t.probe = xvip_composite_probe,\n\t.remove_new = xvip_composite_remove,\n};\n\nmodule_platform_driver(xvip_composite_driver);\n\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_DESCRIPTION(\"Xilinx Video IP Composite Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}