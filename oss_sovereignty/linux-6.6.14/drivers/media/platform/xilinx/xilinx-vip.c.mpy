{
  "module_name": "xilinx-vip.c",
  "hash_id": "35c34297dc6bde29d02f874b4be7205b02aba09361f2cbb610e912eccc1cd088",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/xilinx/xilinx-vip.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <dt-bindings/media/xilinx-vip.h>\n\n#include \"xilinx-vip.h\"\n\n \n\nstatic const struct xvip_video_format xvip_video_formats[] = {\n\t{ XVIP_VF_YUV_422, 8, NULL, MEDIA_BUS_FMT_UYVY8_1X16,\n\t  2, V4L2_PIX_FMT_YUYV },\n\t{ XVIP_VF_YUV_444, 8, NULL, MEDIA_BUS_FMT_VUY8_1X24,\n\t  3, V4L2_PIX_FMT_YUV444 },\n\t{ XVIP_VF_RBG, 8, NULL, MEDIA_BUS_FMT_RBG888_1X24,\n\t  3, 0 },\n\t{ XVIP_VF_MONO_SENSOR, 8, \"mono\", MEDIA_BUS_FMT_Y8_1X8,\n\t  1, V4L2_PIX_FMT_GREY },\n\t{ XVIP_VF_MONO_SENSOR, 8, \"rggb\", MEDIA_BUS_FMT_SRGGB8_1X8,\n\t  1, V4L2_PIX_FMT_SRGGB8 },\n\t{ XVIP_VF_MONO_SENSOR, 8, \"grbg\", MEDIA_BUS_FMT_SGRBG8_1X8,\n\t  1, V4L2_PIX_FMT_SGRBG8 },\n\t{ XVIP_VF_MONO_SENSOR, 8, \"gbrg\", MEDIA_BUS_FMT_SGBRG8_1X8,\n\t  1, V4L2_PIX_FMT_SGBRG8 },\n\t{ XVIP_VF_MONO_SENSOR, 8, \"bggr\", MEDIA_BUS_FMT_SBGGR8_1X8,\n\t  1, V4L2_PIX_FMT_SBGGR8 },\n\t{ XVIP_VF_MONO_SENSOR, 12, \"mono\", MEDIA_BUS_FMT_Y12_1X12,\n\t  2, V4L2_PIX_FMT_Y12 },\n};\n\n \nconst struct xvip_video_format *xvip_get_format_by_code(unsigned int code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(xvip_video_formats); ++i) {\n\t\tconst struct xvip_video_format *format = &xvip_video_formats[i];\n\n\t\tif (format->code == code)\n\t\t\treturn format;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\nEXPORT_SYMBOL_GPL(xvip_get_format_by_code);\n\n \nconst struct xvip_video_format *xvip_get_format_by_fourcc(u32 fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(xvip_video_formats); ++i) {\n\t\tconst struct xvip_video_format *format = &xvip_video_formats[i];\n\n\t\tif (format->fourcc == fourcc)\n\t\t\treturn format;\n\t}\n\n\treturn &xvip_video_formats[0];\n}\nEXPORT_SYMBOL_GPL(xvip_get_format_by_fourcc);\n\n \nconst struct xvip_video_format *xvip_of_get_format(struct device_node *node)\n{\n\tconst char *pattern = \"mono\";\n\tunsigned int vf_code;\n\tunsigned int i;\n\tu32 width;\n\tint ret;\n\n\tret = of_property_read_u32(node, \"xlnx,video-format\", &vf_code);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tret = of_property_read_u32(node, \"xlnx,video-width\", &width);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (vf_code == XVIP_VF_MONO_SENSOR)\n\t\tof_property_read_string(node, \"xlnx,cfa-pattern\", &pattern);\n\n\tfor (i = 0; i < ARRAY_SIZE(xvip_video_formats); ++i) {\n\t\tconst struct xvip_video_format *format = &xvip_video_formats[i];\n\n\t\tif (format->vf_code != vf_code || format->width != width)\n\t\t\tcontinue;\n\n\t\tif (vf_code == XVIP_VF_MONO_SENSOR &&\n\t\t    strcmp(pattern, format->pattern))\n\t\t\tcontinue;\n\n\t\treturn format;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\nEXPORT_SYMBOL_GPL(xvip_of_get_format);\n\n \nvoid xvip_set_format_size(struct v4l2_mbus_framefmt *format,\n\t\t\t  const struct v4l2_subdev_format *fmt)\n{\n\tformat->width = clamp_t(unsigned int, fmt->format.width,\n\t\t\t\tXVIP_MIN_WIDTH, XVIP_MAX_WIDTH);\n\tformat->height = clamp_t(unsigned int, fmt->format.height,\n\t\t\t XVIP_MIN_HEIGHT, XVIP_MAX_HEIGHT);\n}\nEXPORT_SYMBOL_GPL(xvip_set_format_size);\n\n \nvoid xvip_clr_or_set(struct xvip_device *xvip, u32 addr, u32 mask, bool set)\n{\n\tu32 reg;\n\n\treg = xvip_read(xvip, addr);\n\treg = set ? reg | mask : reg & ~mask;\n\txvip_write(xvip, addr, reg);\n}\nEXPORT_SYMBOL_GPL(xvip_clr_or_set);\n\n \nvoid xvip_clr_and_set(struct xvip_device *xvip, u32 addr, u32 clr, u32 set)\n{\n\tu32 reg;\n\n\treg = xvip_read(xvip, addr);\n\treg &= ~clr;\n\treg |= set;\n\txvip_write(xvip, addr, reg);\n}\nEXPORT_SYMBOL_GPL(xvip_clr_and_set);\n\nint xvip_init_resources(struct xvip_device *xvip)\n{\n\tstruct platform_device *pdev = to_platform_device(xvip->dev);\n\n\txvip->iomem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xvip->iomem))\n\t\treturn PTR_ERR(xvip->iomem);\n\n\txvip->clk = devm_clk_get(xvip->dev, NULL);\n\tif (IS_ERR(xvip->clk))\n\t\treturn PTR_ERR(xvip->clk);\n\n\tclk_prepare_enable(xvip->clk);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xvip_init_resources);\n\nvoid xvip_cleanup_resources(struct xvip_device *xvip)\n{\n\tclk_disable_unprepare(xvip->clk);\n}\nEXPORT_SYMBOL_GPL(xvip_cleanup_resources);\n\n \n\n \nint xvip_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\n\t \n\tif (code->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\n\tif (code->index)\n\t\treturn -EINVAL;\n\n\tformat = v4l2_subdev_get_try_format(subdev, sd_state, code->pad);\n\n\tcode->code = format->code;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xvip_enum_mbus_code);\n\n \nint xvip_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\n\t \n\tif (fse->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\treturn -EINVAL;\n\n\tformat = v4l2_subdev_get_try_format(subdev, sd_state, fse->pad);\n\n\tif (fse->index || fse->code != format->code)\n\t\treturn -EINVAL;\n\n\tif (fse->pad == XVIP_PAD_SINK) {\n\t\tfse->min_width = XVIP_MIN_WIDTH;\n\t\tfse->max_width = XVIP_MAX_WIDTH;\n\t\tfse->min_height = XVIP_MIN_HEIGHT;\n\t\tfse->max_height = XVIP_MAX_HEIGHT;\n\t} else {\n\t\t \n\t\tfse->min_width = format->width;\n\t\tfse->max_width = format->width;\n\t\tfse->min_height = format->height;\n\t\tfse->max_height = format->height;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xvip_enum_frame_size);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}