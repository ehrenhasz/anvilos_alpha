{
  "module_name": "xilinx-csi2rxss.c",
  "hash_id": "47a4c57f6cec4eecd2543ccc918d814abbbe00bf9732935ee2b700be9c93d46b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/xilinx/xilinx-csi2rxss.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/v4l2-subdev.h>\n#include <media/media-entity.h>\n#include <media/mipi-csi2.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n#include \"xilinx-vip.h\"\n\n \n#define XCSI_CCR_OFFSET\t\t0x00\n#define XCSI_CCR_SOFTRESET\tBIT(1)\n#define XCSI_CCR_ENABLE\t\tBIT(0)\n\n#define XCSI_PCR_OFFSET\t\t0x04\n#define XCSI_PCR_MAXLANES_MASK\tGENMASK(4, 3)\n#define XCSI_PCR_ACTLANES_MASK\tGENMASK(1, 0)\n\n#define XCSI_CSR_OFFSET\t\t0x10\n#define XCSI_CSR_PKTCNT\t\tGENMASK(31, 16)\n#define XCSI_CSR_SPFIFOFULL\tBIT(3)\n#define XCSI_CSR_SPFIFONE\tBIT(2)\n#define XCSI_CSR_SLBF\t\tBIT(1)\n#define XCSI_CSR_RIPCD\t\tBIT(0)\n\n#define XCSI_GIER_OFFSET\t0x20\n#define XCSI_GIER_GIE\t\tBIT(0)\n\n#define XCSI_ISR_OFFSET\t\t0x24\n#define XCSI_IER_OFFSET\t\t0x28\n\n#define XCSI_ISR_FR\t\tBIT(31)\n#define XCSI_ISR_VCXFE\t\tBIT(30)\n#define XCSI_ISR_WCC\t\tBIT(22)\n#define XCSI_ISR_ILC\t\tBIT(21)\n#define XCSI_ISR_SPFIFOF\tBIT(20)\n#define XCSI_ISR_SPFIFONE\tBIT(19)\n#define XCSI_ISR_SLBF\t\tBIT(18)\n#define XCSI_ISR_STOP\t\tBIT(17)\n#define XCSI_ISR_SOTERR\t\tBIT(13)\n#define XCSI_ISR_SOTSYNCERR\tBIT(12)\n#define XCSI_ISR_ECC2BERR\tBIT(11)\n#define XCSI_ISR_ECC1BERR\tBIT(10)\n#define XCSI_ISR_CRCERR\t\tBIT(9)\n#define XCSI_ISR_DATAIDERR\tBIT(8)\n#define XCSI_ISR_VC3FSYNCERR\tBIT(7)\n#define XCSI_ISR_VC3FLVLERR\tBIT(6)\n#define XCSI_ISR_VC2FSYNCERR\tBIT(5)\n#define XCSI_ISR_VC2FLVLERR\tBIT(4)\n#define XCSI_ISR_VC1FSYNCERR\tBIT(3)\n#define XCSI_ISR_VC1FLVLERR\tBIT(2)\n#define XCSI_ISR_VC0FSYNCERR\tBIT(1)\n#define XCSI_ISR_VC0FLVLERR\tBIT(0)\n\n#define XCSI_ISR_ALLINTR_MASK\t(0xc07e3fff)\n\n \n#define XCSI_IER_INTR_MASK\t(XCSI_ISR_ALLINTR_MASK &\\\n\t\t\t\t ~(XCSI_ISR_STOP | XCSI_ISR_VCXFE))\n\n#define XCSI_SPKTR_OFFSET\t0x30\n#define XCSI_SPKTR_DATA\t\tGENMASK(23, 8)\n#define XCSI_SPKTR_VC\t\tGENMASK(7, 6)\n#define XCSI_SPKTR_DT\t\tGENMASK(5, 0)\n#define XCSI_SPKT_FIFO_DEPTH\t31\n\n#define XCSI_VCXR_OFFSET\t0x34\n#define XCSI_VCXR_VCERR\t\tGENMASK(23, 0)\n#define XCSI_VCXR_FSYNCERR\tBIT(1)\n#define XCSI_VCXR_FLVLERR\tBIT(0)\n\n#define XCSI_CLKINFR_OFFSET\t0x3C\n#define XCSI_CLKINFR_STOP\tBIT(1)\n\n#define XCSI_DLXINFR_OFFSET\t0x40\n#define XCSI_DLXINFR_STOP\tBIT(5)\n#define XCSI_DLXINFR_SOTERR\tBIT(1)\n#define XCSI_DLXINFR_SOTSYNCERR\tBIT(0)\n#define XCSI_MAXDL_COUNT\t0x4\n\n#define XCSI_VCXINF1R_OFFSET\t\t0x60\n#define XCSI_VCXINF1R_LINECOUNT\t\tGENMASK(31, 16)\n#define XCSI_VCXINF1R_LINECOUNT_SHIFT\t16\n#define XCSI_VCXINF1R_BYTECOUNT\t\tGENMASK(15, 0)\n\n#define XCSI_VCXINF2R_OFFSET\t0x64\n#define XCSI_VCXINF2R_DT\tGENMASK(5, 0)\n#define XCSI_MAXVCX_COUNT\t16\n\n \n#define XCSI_MEDIA_PADS\t\t2\n#define XCSI_DEFAULT_WIDTH\t1920\n#define XCSI_DEFAULT_HEIGHT\t1080\n\n#define XCSI_VCX_START\t\t4\n#define XCSI_MAX_VC\t\t4\n#define XCSI_MAX_VCX\t\t16\n\n#define XCSI_NEXTREG_OFFSET\t4\n\n \n#define XCSI_VCX_NUM_EVENTS\t((XCSI_MAX_VCX - XCSI_MAX_VC) * 2)\n\n \nstruct xcsi2rxss_event {\n\tu32 mask;\n\tconst char *name;\n};\n\nstatic const struct xcsi2rxss_event xcsi2rxss_events[] = {\n\t{ XCSI_ISR_FR, \"Frame Received\" },\n\t{ XCSI_ISR_VCXFE, \"VCX Frame Errors\" },\n\t{ XCSI_ISR_WCC, \"Word Count Errors\" },\n\t{ XCSI_ISR_ILC, \"Invalid Lane Count Error\" },\n\t{ XCSI_ISR_SPFIFOF, \"Short Packet FIFO OverFlow Error\" },\n\t{ XCSI_ISR_SPFIFONE, \"Short Packet FIFO Not Empty\" },\n\t{ XCSI_ISR_SLBF, \"Streamline Buffer Full Error\" },\n\t{ XCSI_ISR_STOP, \"Lane Stop State\" },\n\t{ XCSI_ISR_SOTERR, \"SOT Error\" },\n\t{ XCSI_ISR_SOTSYNCERR, \"SOT Sync Error\" },\n\t{ XCSI_ISR_ECC2BERR, \"2 Bit ECC Unrecoverable Error\" },\n\t{ XCSI_ISR_ECC1BERR, \"1 Bit ECC Recoverable Error\" },\n\t{ XCSI_ISR_CRCERR, \"CRC Error\" },\n\t{ XCSI_ISR_DATAIDERR, \"Data Id Error\" },\n\t{ XCSI_ISR_VC3FSYNCERR, \"Virtual Channel 3 Frame Sync Error\" },\n\t{ XCSI_ISR_VC3FLVLERR, \"Virtual Channel 3 Frame Level Error\" },\n\t{ XCSI_ISR_VC2FSYNCERR, \"Virtual Channel 2 Frame Sync Error\" },\n\t{ XCSI_ISR_VC2FLVLERR, \"Virtual Channel 2 Frame Level Error\" },\n\t{ XCSI_ISR_VC1FSYNCERR, \"Virtual Channel 1 Frame Sync Error\" },\n\t{ XCSI_ISR_VC1FLVLERR, \"Virtual Channel 1 Frame Level Error\" },\n\t{ XCSI_ISR_VC0FSYNCERR, \"Virtual Channel 0 Frame Sync Error\" },\n\t{ XCSI_ISR_VC0FLVLERR, \"Virtual Channel 0 Frame Level Error\" }\n};\n\n#define XCSI_NUM_EVENTS\t\tARRAY_SIZE(xcsi2rxss_events)\n\n \nstatic const u32 xcsi2dt_mbus_lut[][2] = {\n\t{ MIPI_CSI2_DT_YUV422_8B, MEDIA_BUS_FMT_UYVY8_1X16 },\n\t{ MIPI_CSI2_DT_YUV422_10B, MEDIA_BUS_FMT_UYVY10_1X20 },\n\t{ MIPI_CSI2_DT_RGB444, 0 },\n\t{ MIPI_CSI2_DT_RGB555, 0 },\n\t{ MIPI_CSI2_DT_RGB565, 0 },\n\t{ MIPI_CSI2_DT_RGB666, 0 },\n\t{ MIPI_CSI2_DT_RGB888, MEDIA_BUS_FMT_RBG888_1X24 },\n\t{ MIPI_CSI2_DT_RAW6, 0 },\n\t{ MIPI_CSI2_DT_RAW7, 0 },\n\t{ MIPI_CSI2_DT_RAW8, MEDIA_BUS_FMT_SRGGB8_1X8 },\n\t{ MIPI_CSI2_DT_RAW8, MEDIA_BUS_FMT_SBGGR8_1X8 },\n\t{ MIPI_CSI2_DT_RAW8, MEDIA_BUS_FMT_SGBRG8_1X8 },\n\t{ MIPI_CSI2_DT_RAW8, MEDIA_BUS_FMT_SGRBG8_1X8 },\n\t{ MIPI_CSI2_DT_RAW10, MEDIA_BUS_FMT_SRGGB10_1X10 },\n\t{ MIPI_CSI2_DT_RAW10, MEDIA_BUS_FMT_SBGGR10_1X10 },\n\t{ MIPI_CSI2_DT_RAW10, MEDIA_BUS_FMT_SGBRG10_1X10 },\n\t{ MIPI_CSI2_DT_RAW10, MEDIA_BUS_FMT_SGRBG10_1X10 },\n\t{ MIPI_CSI2_DT_RAW12, MEDIA_BUS_FMT_SRGGB12_1X12 },\n\t{ MIPI_CSI2_DT_RAW12, MEDIA_BUS_FMT_SBGGR12_1X12 },\n\t{ MIPI_CSI2_DT_RAW12, MEDIA_BUS_FMT_SGBRG12_1X12 },\n\t{ MIPI_CSI2_DT_RAW12, MEDIA_BUS_FMT_SGRBG12_1X12 },\n\t{ MIPI_CSI2_DT_RAW12, MEDIA_BUS_FMT_Y12_1X12 },\n\t{ MIPI_CSI2_DT_RAW16, MEDIA_BUS_FMT_SRGGB16_1X16 },\n\t{ MIPI_CSI2_DT_RAW16, MEDIA_BUS_FMT_SBGGR16_1X16 },\n\t{ MIPI_CSI2_DT_RAW16, MEDIA_BUS_FMT_SGBRG16_1X16 },\n\t{ MIPI_CSI2_DT_RAW16, MEDIA_BUS_FMT_SGRBG16_1X16 },\n\t{ MIPI_CSI2_DT_RAW20, 0 },\n};\n\n \nstruct xcsi2rxss_state {\n\tstruct v4l2_subdev subdev;\n\tstruct v4l2_mbus_framefmt format;\n\tstruct v4l2_mbus_framefmt default_format;\n\tu32 events[XCSI_NUM_EVENTS];\n\tu32 vcx_events[XCSI_VCX_NUM_EVENTS];\n\tstruct device *dev;\n\tstruct v4l2_subdev *rsubdev;\n\tstruct gpio_desc *rst_gpio;\n\tstruct clk_bulk_data *clks;\n\tvoid __iomem *iomem;\n\tu32 max_num_lanes;\n\tu32 datatype;\n\t \n\tstruct mutex lock;\n\tstruct media_pad pads[XCSI_MEDIA_PADS];\n\tbool streaming;\n\tbool enable_active_lanes;\n\tbool en_vcx;\n};\n\nstatic const struct clk_bulk_data xcsi2rxss_clks[] = {\n\t{ .id = \"lite_aclk\" },\n\t{ .id = \"video_aclk\" },\n};\n\nstatic inline struct xcsi2rxss_state *\nto_xcsi2rxssstate(struct v4l2_subdev *subdev)\n{\n\treturn container_of(subdev, struct xcsi2rxss_state, subdev);\n}\n\n \nstatic inline u32 xcsi2rxss_read(struct xcsi2rxss_state *xcsi2rxss, u32 addr)\n{\n\treturn ioread32(xcsi2rxss->iomem + addr);\n}\n\nstatic inline void xcsi2rxss_write(struct xcsi2rxss_state *xcsi2rxss, u32 addr,\n\t\t\t\t   u32 value)\n{\n\tiowrite32(value, xcsi2rxss->iomem + addr);\n}\n\nstatic inline void xcsi2rxss_clr(struct xcsi2rxss_state *xcsi2rxss, u32 addr,\n\t\t\t\t u32 clr)\n{\n\txcsi2rxss_write(xcsi2rxss, addr,\n\t\t\txcsi2rxss_read(xcsi2rxss, addr) & ~clr);\n}\n\nstatic inline void xcsi2rxss_set(struct xcsi2rxss_state *xcsi2rxss, u32 addr,\n\t\t\t\t u32 set)\n{\n\txcsi2rxss_write(xcsi2rxss, addr, xcsi2rxss_read(xcsi2rxss, addr) | set);\n}\n\n \nstatic u32 xcsi2rxss_get_nth_mbus(u32 dt, u32 n)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(xcsi2dt_mbus_lut); i++) {\n\t\tif (xcsi2dt_mbus_lut[i][0] == dt) {\n\t\t\tif (n-- == 0)\n\t\t\t\treturn xcsi2dt_mbus_lut[i][1];\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic u32 xcsi2rxss_get_dt(u32 mbus)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(xcsi2dt_mbus_lut); i++) {\n\t\tif (xcsi2dt_mbus_lut[i][1] == mbus)\n\t\t\treturn xcsi2dt_mbus_lut[i][0];\n\t}\n\n\treturn 0;\n}\n\n \nstatic int xcsi2rxss_soft_reset(struct xcsi2rxss_state *state)\n{\n\tu32 timeout = 1000;  \n\n\txcsi2rxss_set(state, XCSI_CCR_OFFSET, XCSI_CCR_SOFTRESET);\n\n\twhile (xcsi2rxss_read(state, XCSI_CSR_OFFSET) & XCSI_CSR_RIPCD) {\n\t\tif (timeout == 0) {\n\t\t\tdev_err(state->dev, \"soft reset timed out!\\n\");\n\t\t\treturn -ETIME;\n\t\t}\n\n\t\ttimeout--;\n\t\tudelay(1);\n\t}\n\n\txcsi2rxss_clr(state, XCSI_CCR_OFFSET, XCSI_CCR_SOFTRESET);\n\treturn 0;\n}\n\nstatic void xcsi2rxss_hard_reset(struct xcsi2rxss_state *state)\n{\n\tif (!state->rst_gpio)\n\t\treturn;\n\n\t \n\tgpiod_set_value_cansleep(state->rst_gpio, 1);\n\tusleep_range(1, 2);\n\tgpiod_set_value_cansleep(state->rst_gpio, 0);\n}\n\nstatic void xcsi2rxss_reset_event_counters(struct xcsi2rxss_state *state)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < XCSI_NUM_EVENTS; i++)\n\t\tstate->events[i] = 0;\n\n\tfor (i = 0; i < XCSI_VCX_NUM_EVENTS; i++)\n\t\tstate->vcx_events[i] = 0;\n}\n\n \nstatic void xcsi2rxss_log_counters(struct xcsi2rxss_state *state)\n{\n\tstruct device *dev = state->dev;\n\tunsigned int i;\n\n\tfor (i = 0; i < XCSI_NUM_EVENTS; i++) {\n\t\tif (state->events[i] > 0) {\n\t\t\tdev_info(dev, \"%s events: %d\\n\",\n\t\t\t\t xcsi2rxss_events[i].name,\n\t\t\t\t state->events[i]);\n\t\t}\n\t}\n\n\tif (state->en_vcx) {\n\t\tfor (i = 0; i < XCSI_VCX_NUM_EVENTS; i++) {\n\t\t\tif (state->vcx_events[i] > 0) {\n\t\t\t\tdev_info(dev,\n\t\t\t\t\t \"VC %d Frame %s err vcx events: %d\\n\",\n\t\t\t\t\t (i / 2) + XCSI_VCX_START,\n\t\t\t\t\t i & 1 ? \"Sync\" : \"Level\",\n\t\t\t\t\t state->vcx_events[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int xcsi2rxss_log_status(struct v4l2_subdev *sd)\n{\n\tstruct xcsi2rxss_state *xcsi2rxss = to_xcsi2rxssstate(sd);\n\tstruct device *dev = xcsi2rxss->dev;\n\tu32 reg, data;\n\tunsigned int i, max_vc;\n\n\tmutex_lock(&xcsi2rxss->lock);\n\n\txcsi2rxss_log_counters(xcsi2rxss);\n\n\tdev_info(dev, \"***** Core Status *****\\n\");\n\tdata = xcsi2rxss_read(xcsi2rxss, XCSI_CSR_OFFSET);\n\tdev_info(dev, \"Short Packet FIFO Full = %s\\n\",\n\t\t data & XCSI_CSR_SPFIFOFULL ? \"true\" : \"false\");\n\tdev_info(dev, \"Short Packet FIFO Not Empty = %s\\n\",\n\t\t data & XCSI_CSR_SPFIFONE ? \"true\" : \"false\");\n\tdev_info(dev, \"Stream line buffer full = %s\\n\",\n\t\t data & XCSI_CSR_SLBF ? \"true\" : \"false\");\n\tdev_info(dev, \"Soft reset/Core disable in progress = %s\\n\",\n\t\t data & XCSI_CSR_RIPCD ? \"true\" : \"false\");\n\n\t \n\tdev_info(dev, \"******** Clock Lane Info *********\\n\");\n\tdata = xcsi2rxss_read(xcsi2rxss, XCSI_CLKINFR_OFFSET);\n\tdev_info(dev, \"Clock Lane in Stop State = %s\\n\",\n\t\t data & XCSI_CLKINFR_STOP ? \"true\" : \"false\");\n\n\tdev_info(dev, \"******** Data Lane Info *********\\n\");\n\tdev_info(dev, \"Lane\\tSoT Error\\tSoT Sync Error\\tStop State\\n\");\n\treg = XCSI_DLXINFR_OFFSET;\n\tfor (i = 0; i < XCSI_MAXDL_COUNT; i++) {\n\t\tdata = xcsi2rxss_read(xcsi2rxss, reg);\n\n\t\tdev_info(dev, \"%d\\t%s\\t\\t%s\\t\\t%s\\n\", i,\n\t\t\t data & XCSI_DLXINFR_SOTERR ? \"true\" : \"false\",\n\t\t\t data & XCSI_DLXINFR_SOTSYNCERR ? \"true\" : \"false\",\n\t\t\t data & XCSI_DLXINFR_STOP ? \"true\" : \"false\");\n\n\t\treg += XCSI_NEXTREG_OFFSET;\n\t}\n\n\t \n\tdev_info(dev, \"********** Virtual Channel Info ************\\n\");\n\tdev_info(dev, \"VC\\tLine Count\\tByte Count\\tData Type\\n\");\n\tif (xcsi2rxss->en_vcx)\n\t\tmax_vc = XCSI_MAX_VCX;\n\telse\n\t\tmax_vc = XCSI_MAX_VC;\n\n\treg = XCSI_VCXINF1R_OFFSET;\n\tfor (i = 0; i < max_vc; i++) {\n\t\tu32 line_count, byte_count, data_type;\n\n\t\t \n\t\tdata = xcsi2rxss_read(xcsi2rxss, reg);\n\t\tbyte_count = data & XCSI_VCXINF1R_BYTECOUNT;\n\t\tline_count = data & XCSI_VCXINF1R_LINECOUNT;\n\t\tline_count >>= XCSI_VCXINF1R_LINECOUNT_SHIFT;\n\n\t\t \n\t\treg += XCSI_NEXTREG_OFFSET;\n\t\tdata = xcsi2rxss_read(xcsi2rxss, reg);\n\t\tdata_type = data & XCSI_VCXINF2R_DT;\n\n\t\tdev_info(dev, \"%d\\t%d\\t\\t%d\\t\\t0x%x\\n\", i, line_count,\n\t\t\t byte_count, data_type);\n\n\t\t \n\t\treg += XCSI_NEXTREG_OFFSET;\n\t}\n\n\tmutex_unlock(&xcsi2rxss->lock);\n\n\treturn 0;\n}\n\nstatic struct v4l2_subdev *xcsi2rxss_get_remote_subdev(struct media_pad *local)\n{\n\tstruct media_pad *remote;\n\n\tremote = media_pad_remote_pad_first(local);\n\tif (!remote || !is_media_entity_v4l2_subdev(remote->entity))\n\t\treturn NULL;\n\n\treturn media_entity_to_v4l2_subdev(remote->entity);\n}\n\nstatic int xcsi2rxss_start_stream(struct xcsi2rxss_state *state)\n{\n\tint ret = 0;\n\n\t \n\txcsi2rxss_set(state, XCSI_CCR_OFFSET, XCSI_CCR_ENABLE);\n\n\tret = xcsi2rxss_soft_reset(state);\n\tif (ret) {\n\t\tstate->streaming = false;\n\t\treturn ret;\n\t}\n\n\t \n\txcsi2rxss_clr(state, XCSI_GIER_OFFSET, XCSI_GIER_GIE);\n\txcsi2rxss_write(state, XCSI_IER_OFFSET, XCSI_IER_INTR_MASK);\n\txcsi2rxss_set(state, XCSI_GIER_OFFSET, XCSI_GIER_GIE);\n\n\tstate->streaming = true;\n\n\tstate->rsubdev =\n\t\txcsi2rxss_get_remote_subdev(&state->pads[XVIP_PAD_SINK]);\n\n\tret = v4l2_subdev_call(state->rsubdev, video, s_stream, 1);\n\tif (ret) {\n\t\t \n\t\txcsi2rxss_clr(state, XCSI_IER_OFFSET, XCSI_IER_INTR_MASK);\n\t\txcsi2rxss_clr(state, XCSI_GIER_OFFSET, XCSI_GIER_GIE);\n\n\t\t \n\t\txcsi2rxss_clr(state, XCSI_CCR_OFFSET, XCSI_CCR_ENABLE);\n\t\tstate->streaming = false;\n\t}\n\n\treturn ret;\n}\n\nstatic void xcsi2rxss_stop_stream(struct xcsi2rxss_state *state)\n{\n\tv4l2_subdev_call(state->rsubdev, video, s_stream, 0);\n\n\t \n\txcsi2rxss_clr(state, XCSI_IER_OFFSET, XCSI_IER_INTR_MASK);\n\txcsi2rxss_clr(state, XCSI_GIER_OFFSET, XCSI_GIER_GIE);\n\n\t \n\txcsi2rxss_clr(state, XCSI_CCR_OFFSET, XCSI_CCR_ENABLE);\n\tstate->streaming = false;\n}\n\n \nstatic irqreturn_t xcsi2rxss_irq_handler(int irq, void *data)\n{\n\tstruct xcsi2rxss_state *state = (struct xcsi2rxss_state *)data;\n\tstruct device *dev = state->dev;\n\tu32 status;\n\n\tstatus = xcsi2rxss_read(state, XCSI_ISR_OFFSET) & XCSI_ISR_ALLINTR_MASK;\n\txcsi2rxss_write(state, XCSI_ISR_OFFSET, status);\n\n\t \n\tif (status & XCSI_ISR_SPFIFONE) {\n\t\tu32 count = 0;\n\n\t\t \n\t\tfor (count = 0; count < XCSI_SPKT_FIFO_DEPTH; ++count) {\n\t\t\tu32 spfifostat, spkt;\n\n\t\t\tspkt = xcsi2rxss_read(state, XCSI_SPKTR_OFFSET);\n\t\t\tdev_dbg(dev, \"Short packet = 0x%08x\\n\", spkt);\n\t\t\tspfifostat = xcsi2rxss_read(state, XCSI_ISR_OFFSET);\n\t\t\tspfifostat &= XCSI_ISR_SPFIFONE;\n\t\t\tif (!spfifostat)\n\t\t\t\tbreak;\n\t\t\txcsi2rxss_write(state, XCSI_ISR_OFFSET, spfifostat);\n\t\t}\n\t}\n\n\t \n\tif (status & XCSI_ISR_SPFIFOF)\n\t\tdev_dbg_ratelimited(dev, \"Short packet FIFO overflowed\\n\");\n\n\t \n\tif (status & XCSI_ISR_SLBF) {\n\t\tdev_alert_ratelimited(dev, \"Stream Line Buffer Full!\\n\");\n\n\t\t \n\t\txcsi2rxss_clr(state, XCSI_IER_OFFSET, XCSI_IER_INTR_MASK);\n\t\txcsi2rxss_clr(state, XCSI_GIER_OFFSET, XCSI_GIER_GIE);\n\n\t\t \n\t\txcsi2rxss_clr(state, XCSI_CCR_OFFSET, XCSI_CCR_ENABLE);\n\n\t\t \n\n\t\t \n\t}\n\n\t \n\tif (status & XCSI_ISR_ALLINTR_MASK) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < XCSI_NUM_EVENTS; i++) {\n\t\t\tif (!(status & xcsi2rxss_events[i].mask))\n\t\t\t\tcontinue;\n\t\t\tstate->events[i]++;\n\t\t\tdev_dbg_ratelimited(dev, \"%s: %u\\n\",\n\t\t\t\t\t    xcsi2rxss_events[i].name,\n\t\t\t\t\t    state->events[i]);\n\t\t}\n\n\t\tif (status & XCSI_ISR_VCXFE && state->en_vcx) {\n\t\t\tu32 vcxstatus;\n\n\t\t\tvcxstatus = xcsi2rxss_read(state, XCSI_VCXR_OFFSET);\n\t\t\tvcxstatus &= XCSI_VCXR_VCERR;\n\t\t\tfor (i = 0; i < XCSI_VCX_NUM_EVENTS; i++) {\n\t\t\t\tif (!(vcxstatus & BIT(i)))\n\t\t\t\t\tcontinue;\n\t\t\t\tstate->vcx_events[i]++;\n\t\t\t}\n\t\t\txcsi2rxss_write(state, XCSI_VCXR_OFFSET, vcxstatus);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int xcsi2rxss_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct xcsi2rxss_state *xcsi2rxss = to_xcsi2rxssstate(sd);\n\tint ret = 0;\n\n\tmutex_lock(&xcsi2rxss->lock);\n\n\tif (enable == xcsi2rxss->streaming)\n\t\tgoto stream_done;\n\n\tif (enable) {\n\t\txcsi2rxss_reset_event_counters(xcsi2rxss);\n\t\tret = xcsi2rxss_start_stream(xcsi2rxss);\n\t} else {\n\t\txcsi2rxss_stop_stream(xcsi2rxss);\n\t\txcsi2rxss_hard_reset(xcsi2rxss);\n\t}\n\nstream_done:\n\tmutex_unlock(&xcsi2rxss->lock);\n\treturn ret;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__xcsi2rxss_get_pad_format(struct xcsi2rxss_state *xcsi2rxss,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   unsigned int pad, u32 which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_format(&xcsi2rxss->subdev,\n\t\t\t\t\t\t  sd_state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &xcsi2rxss->format;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \nstatic int xcsi2rxss_init_cfg(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state)\n{\n\tstruct xcsi2rxss_state *xcsi2rxss = to_xcsi2rxssstate(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tunsigned int i;\n\n\tmutex_lock(&xcsi2rxss->lock);\n\tfor (i = 0; i < XCSI_MEDIA_PADS; i++) {\n\t\tformat = v4l2_subdev_get_try_format(sd, sd_state, i);\n\t\t*format = xcsi2rxss->default_format;\n\t}\n\tmutex_unlock(&xcsi2rxss->lock);\n\n\treturn 0;\n}\n\n \nstatic int xcsi2rxss_get_format(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_format *fmt)\n{\n\tstruct xcsi2rxss_state *xcsi2rxss = to_xcsi2rxssstate(sd);\n\n\tmutex_lock(&xcsi2rxss->lock);\n\tfmt->format = *__xcsi2rxss_get_pad_format(xcsi2rxss, sd_state,\n\t\t\t\t\t\t  fmt->pad,\n\t\t\t\t\t\t  fmt->which);\n\tmutex_unlock(&xcsi2rxss->lock);\n\n\treturn 0;\n}\n\n \nstatic int xcsi2rxss_set_format(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_format *fmt)\n{\n\tstruct xcsi2rxss_state *xcsi2rxss = to_xcsi2rxssstate(sd);\n\tstruct v4l2_mbus_framefmt *__format;\n\tu32 dt;\n\n\tmutex_lock(&xcsi2rxss->lock);\n\n\t \n\t__format = __xcsi2rxss_get_pad_format(xcsi2rxss, sd_state,\n\t\t\t\t\t      fmt->pad, fmt->which);\n\n\t \n\tif (fmt->pad == XVIP_PAD_SOURCE) {\n\t\tfmt->format = *__format;\n\t\tmutex_unlock(&xcsi2rxss->lock);\n\t\treturn 0;\n\t}\n\n\t \n\tdt = xcsi2rxss_get_dt(fmt->format.code);\n\tif (dt != xcsi2rxss->datatype && dt != MIPI_CSI2_DT_RAW8) {\n\t\tdev_dbg(xcsi2rxss->dev, \"Unsupported media bus format\");\n\t\t \n\t\tfmt->format.code = xcsi2rxss_get_nth_mbus(xcsi2rxss->datatype,\n\t\t\t\t\t\t\t  0);\n\t}\n\n\t*__format = fmt->format;\n\tmutex_unlock(&xcsi2rxss->lock);\n\n\treturn 0;\n}\n\n \nstatic int xcsi2rxss_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct xcsi2rxss_state *state = to_xcsi2rxssstate(sd);\n\tu32 dt, n;\n\tint ret = 0;\n\n\t \n\tif (code->index < 4) {\n\t\tn = code->index;\n\t\tdt = MIPI_CSI2_DT_RAW8;\n\t} else if (state->datatype != MIPI_CSI2_DT_RAW8) {\n\t\tn = code->index - 4;\n\t\tdt = state->datatype;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tcode->code = xcsi2rxss_get_nth_mbus(dt, n);\n\tif (!code->code)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\n \n\nstatic const struct media_entity_operations xcsi2rxss_media_ops = {\n\t.link_validate = v4l2_subdev_link_validate\n};\n\nstatic const struct v4l2_subdev_core_ops xcsi2rxss_core_ops = {\n\t.log_status = xcsi2rxss_log_status,\n};\n\nstatic const struct v4l2_subdev_video_ops xcsi2rxss_video_ops = {\n\t.s_stream = xcsi2rxss_s_stream\n};\n\nstatic const struct v4l2_subdev_pad_ops xcsi2rxss_pad_ops = {\n\t.init_cfg = xcsi2rxss_init_cfg,\n\t.get_fmt = xcsi2rxss_get_format,\n\t.set_fmt = xcsi2rxss_set_format,\n\t.enum_mbus_code = xcsi2rxss_enum_mbus_code,\n\t.link_validate = v4l2_subdev_link_validate_default,\n};\n\nstatic const struct v4l2_subdev_ops xcsi2rxss_ops = {\n\t.core = &xcsi2rxss_core_ops,\n\t.video = &xcsi2rxss_video_ops,\n\t.pad = &xcsi2rxss_pad_ops\n};\n\nstatic int xcsi2rxss_parse_of(struct xcsi2rxss_state *xcsi2rxss)\n{\n\tstruct device *dev = xcsi2rxss->dev;\n\tstruct device_node *node = dev->of_node;\n\n\tstruct fwnode_handle *ep;\n\tstruct v4l2_fwnode_endpoint vep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY\n\t};\n\tbool en_csi_v20, vfb;\n\tint ret;\n\n\ten_csi_v20 = of_property_read_bool(node, \"xlnx,en-csi-v2-0\");\n\tif (en_csi_v20)\n\t\txcsi2rxss->en_vcx = of_property_read_bool(node, \"xlnx,en-vcx\");\n\n\txcsi2rxss->enable_active_lanes =\n\t\tof_property_read_bool(node, \"xlnx,en-active-lanes\");\n\n\tret = of_property_read_u32(node, \"xlnx,csi-pxl-format\",\n\t\t\t\t   &xcsi2rxss->datatype);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing xlnx,csi-pxl-format property\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (xcsi2rxss->datatype) {\n\tcase MIPI_CSI2_DT_YUV422_8B:\n\tcase MIPI_CSI2_DT_RGB444:\n\tcase MIPI_CSI2_DT_RGB555:\n\tcase MIPI_CSI2_DT_RGB565:\n\tcase MIPI_CSI2_DT_RGB666:\n\tcase MIPI_CSI2_DT_RGB888:\n\tcase MIPI_CSI2_DT_RAW6:\n\tcase MIPI_CSI2_DT_RAW7:\n\tcase MIPI_CSI2_DT_RAW8:\n\tcase MIPI_CSI2_DT_RAW10:\n\tcase MIPI_CSI2_DT_RAW12:\n\tcase MIPI_CSI2_DT_RAW14:\n\t\tbreak;\n\tcase MIPI_CSI2_DT_YUV422_10B:\n\tcase MIPI_CSI2_DT_RAW16:\n\tcase MIPI_CSI2_DT_RAW20:\n\t\tif (!en_csi_v20) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_dbg(dev, \"enable csi v2 for this pixel format\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (ret < 0) {\n\t\tdev_err(dev, \"invalid csi-pxl-format property!\\n\");\n\t\treturn ret;\n\t}\n\n\tvfb = of_property_read_bool(node, \"xlnx,vfb\");\n\tif (!vfb) {\n\t\tdev_err(dev, \"operation without VFB is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev),\n\t\t\t\t\t     XVIP_PAD_SINK, 0,\n\t\t\t\t\t     FWNODE_GRAPH_ENDPOINT_NEXT);\n\tif (!ep) {\n\t\tdev_err(dev, \"no sink port found\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\tfwnode_handle_put(ep);\n\tif (ret) {\n\t\tdev_err(dev, \"error parsing sink port\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"mipi number lanes = %d\\n\",\n\t\tvep.bus.mipi_csi2.num_data_lanes);\n\n\txcsi2rxss->max_num_lanes = vep.bus.mipi_csi2.num_data_lanes;\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev),\n\t\t\t\t\t     XVIP_PAD_SOURCE, 0,\n\t\t\t\t\t     FWNODE_GRAPH_ENDPOINT_NEXT);\n\tif (!ep) {\n\t\tdev_err(dev, \"no source port found\");\n\t\treturn -EINVAL;\n\t}\n\n\tfwnode_handle_put(ep);\n\n\tdev_dbg(dev, \"vcx %s, %u data lanes (%s), data type 0x%02x\\n\",\n\t\txcsi2rxss->en_vcx ? \"enabled\" : \"disabled\",\n\t\txcsi2rxss->max_num_lanes,\n\t\txcsi2rxss->enable_active_lanes ? \"dynamic\" : \"static\",\n\t\txcsi2rxss->datatype);\n\n\treturn 0;\n}\n\nstatic int xcsi2rxss_probe(struct platform_device *pdev)\n{\n\tstruct v4l2_subdev *subdev;\n\tstruct xcsi2rxss_state *xcsi2rxss;\n\tint num_clks = ARRAY_SIZE(xcsi2rxss_clks);\n\tstruct device *dev = &pdev->dev;\n\tint irq, ret;\n\n\txcsi2rxss = devm_kzalloc(dev, sizeof(*xcsi2rxss), GFP_KERNEL);\n\tif (!xcsi2rxss)\n\t\treturn -ENOMEM;\n\n\txcsi2rxss->dev = dev;\n\n\txcsi2rxss->clks = devm_kmemdup(dev, xcsi2rxss_clks,\n\t\t\t\t       sizeof(xcsi2rxss_clks), GFP_KERNEL);\n\tif (!xcsi2rxss->clks)\n\t\treturn -ENOMEM;\n\n\t \n\txcsi2rxss->rst_gpio = devm_gpiod_get_optional(dev, \"video-reset\",\n\t\t\t\t\t\t      GPIOD_OUT_HIGH);\n\tif (IS_ERR(xcsi2rxss->rst_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(xcsi2rxss->rst_gpio),\n\t\t\t\t     \"Video Reset GPIO not setup in DT\\n\");\n\n\tret = xcsi2rxss_parse_of(xcsi2rxss);\n\tif (ret < 0)\n\t\treturn ret;\n\n\txcsi2rxss->iomem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xcsi2rxss->iomem))\n\t\treturn PTR_ERR(xcsi2rxss->iomem);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t\txcsi2rxss_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), xcsi2rxss);\n\tif (ret) {\n\t\tdev_err(dev, \"Err = %d Interrupt handler reg failed!\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_bulk_get(dev, num_clks, xcsi2rxss->clks);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = clk_bulk_prepare_enable(num_clks, xcsi2rxss->clks);\n\tif (ret)\n\t\tgoto err_clk_put;\n\n\tmutex_init(&xcsi2rxss->lock);\n\n\txcsi2rxss_hard_reset(xcsi2rxss);\n\txcsi2rxss_soft_reset(xcsi2rxss);\n\n\t \n\txcsi2rxss->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\txcsi2rxss->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\t \n\txcsi2rxss->default_format.code =\n\t\txcsi2rxss_get_nth_mbus(xcsi2rxss->datatype, 0);\n\txcsi2rxss->default_format.field = V4L2_FIELD_NONE;\n\txcsi2rxss->default_format.colorspace = V4L2_COLORSPACE_SRGB;\n\txcsi2rxss->default_format.width = XCSI_DEFAULT_WIDTH;\n\txcsi2rxss->default_format.height = XCSI_DEFAULT_HEIGHT;\n\txcsi2rxss->format = xcsi2rxss->default_format;\n\n\t \n\tsubdev = &xcsi2rxss->subdev;\n\tv4l2_subdev_init(subdev, &xcsi2rxss_ops);\n\tsubdev->dev = dev;\n\tstrscpy(subdev->name, dev_name(dev), sizeof(subdev->name));\n\tsubdev->flags |= V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsubdev->entity.ops = &xcsi2rxss_media_ops;\n\tv4l2_set_subdevdata(subdev, xcsi2rxss);\n\n\tret = media_entity_pads_init(&subdev->entity, XCSI_MEDIA_PADS,\n\t\t\t\t     xcsi2rxss->pads);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tplatform_set_drvdata(pdev, xcsi2rxss);\n\n\tret = v4l2_async_register_subdev(subdev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register subdev\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tmedia_entity_cleanup(&subdev->entity);\n\tmutex_destroy(&xcsi2rxss->lock);\n\tclk_bulk_disable_unprepare(num_clks, xcsi2rxss->clks);\nerr_clk_put:\n\tclk_bulk_put(num_clks, xcsi2rxss->clks);\n\treturn ret;\n}\n\nstatic void xcsi2rxss_remove(struct platform_device *pdev)\n{\n\tstruct xcsi2rxss_state *xcsi2rxss = platform_get_drvdata(pdev);\n\tstruct v4l2_subdev *subdev = &xcsi2rxss->subdev;\n\tint num_clks = ARRAY_SIZE(xcsi2rxss_clks);\n\n\tv4l2_async_unregister_subdev(subdev);\n\tmedia_entity_cleanup(&subdev->entity);\n\tmutex_destroy(&xcsi2rxss->lock);\n\tclk_bulk_disable_unprepare(num_clks, xcsi2rxss->clks);\n\tclk_bulk_put(num_clks, xcsi2rxss->clks);\n}\n\nstatic const struct of_device_id xcsi2rxss_of_id_table[] = {\n\t{ .compatible = \"xlnx,mipi-csi2-rx-subsystem-5.0\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, xcsi2rxss_of_id_table);\n\nstatic struct platform_driver xcsi2rxss_driver = {\n\t.driver = {\n\t\t.name\t\t= \"xilinx-csi2rxss\",\n\t\t.of_match_table\t= xcsi2rxss_of_id_table,\n\t},\n\t.probe\t\t\t= xcsi2rxss_probe,\n\t.remove_new\t\t= xcsi2rxss_remove,\n};\n\nmodule_platform_driver(xcsi2rxss_driver);\n\nMODULE_AUTHOR(\"Vishal Sagar <vsagar@xilinx.com>\");\nMODULE_DESCRIPTION(\"Xilinx MIPI CSI-2 Rx Subsystem Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}