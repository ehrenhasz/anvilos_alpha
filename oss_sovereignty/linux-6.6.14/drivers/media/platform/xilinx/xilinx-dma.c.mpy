{
  "module_name": "xilinx-dma.c",
  "hash_id": "d5dd5c0eaa8192e6142108d85572f7a0c2c474075fe9fc3b4d2177550a22db67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/xilinx/xilinx-dma.c",
  "human_readable_source": "\n \n\n#include <linux/dma/xilinx_dma.h>\n#include <linux/lcm.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-dev.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"xilinx-dma.h\"\n#include \"xilinx-vip.h\"\n#include \"xilinx-vipp.h\"\n\n#define XVIP_DMA_DEF_WIDTH\t\t1920\n#define XVIP_DMA_DEF_HEIGHT\t\t1080\n\n \n#define XVIP_DMA_MIN_WIDTH\t\t1U\n#define XVIP_DMA_MAX_WIDTH\t\t65535U\n#define XVIP_DMA_MIN_HEIGHT\t\t1U\n#define XVIP_DMA_MAX_HEIGHT\t\t8191U\n\n \n\nstatic struct v4l2_subdev *\nxvip_dma_remote_subdev(struct media_pad *local, u32 *pad)\n{\n\tstruct media_pad *remote;\n\n\tremote = media_pad_remote_pad_first(local);\n\tif (!remote || !is_media_entity_v4l2_subdev(remote->entity))\n\t\treturn NULL;\n\n\tif (pad)\n\t\t*pad = remote->index;\n\n\treturn media_entity_to_v4l2_subdev(remote->entity);\n}\n\nstatic int xvip_dma_verify_format(struct xvip_dma *dma)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev *subdev;\n\tint ret;\n\n\tsubdev = xvip_dma_remote_subdev(&dma->pad, &fmt.pad);\n\tif (subdev == NULL)\n\t\treturn -EPIPE;\n\n\tret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);\n\tif (ret < 0)\n\t\treturn ret == -ENOIOCTLCMD ? -EINVAL : ret;\n\n\tif (dma->fmtinfo->code != fmt.format.code ||\n\t    dma->format.height != fmt.format.height ||\n\t    dma->format.width != fmt.format.width ||\n\t    dma->format.colorspace != fmt.format.colorspace)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \n\n \nstatic int xvip_pipeline_start_stop(struct xvip_pipeline *pipe, bool start)\n{\n\tstruct xvip_dma *dma = pipe->output;\n\tstruct media_entity *entity;\n\tstruct media_pad *pad;\n\tstruct v4l2_subdev *subdev;\n\tint ret;\n\n\tentity = &dma->video.entity;\n\twhile (1) {\n\t\tpad = &entity->pads[0];\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tbreak;\n\n\t\tpad = media_pad_remote_pad_first(pad);\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tbreak;\n\n\t\tentity = pad->entity;\n\t\tsubdev = media_entity_to_v4l2_subdev(entity);\n\n\t\tret = v4l2_subdev_call(subdev, video, s_stream, start);\n\t\tif (start && ret < 0 && ret != -ENOIOCTLCMD)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int xvip_pipeline_set_stream(struct xvip_pipeline *pipe, bool on)\n{\n\tint ret = 0;\n\n\tmutex_lock(&pipe->lock);\n\n\tif (on) {\n\t\tif (pipe->stream_count == pipe->num_dmas - 1) {\n\t\t\tret = xvip_pipeline_start_stop(pipe, true);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t\tpipe->stream_count++;\n\t} else {\n\t\tif (--pipe->stream_count == 0)\n\t\t\txvip_pipeline_start_stop(pipe, false);\n\t}\n\ndone:\n\tmutex_unlock(&pipe->lock);\n\treturn ret;\n}\n\nstatic int xvip_pipeline_validate(struct xvip_pipeline *pipe,\n\t\t\t\t  struct xvip_dma *start)\n{\n\tstruct media_pipeline_pad_iter iter;\n\tunsigned int num_inputs = 0;\n\tunsigned int num_outputs = 0;\n\tstruct media_pad *pad;\n\n\t \n\tmedia_pipeline_for_each_pad(&pipe->pipe, &iter, pad) {\n\t\tstruct xvip_dma *dma;\n\n\t\tif (pad->entity->function != MEDIA_ENT_F_IO_V4L)\n\t\t\tcontinue;\n\n\t\tdma = to_xvip_dma(media_entity_to_video_device(pad->entity));\n\n\t\tif (dma->pad.flags & MEDIA_PAD_FL_SINK) {\n\t\t\tpipe->output = dma;\n\t\t\tnum_outputs++;\n\t\t} else {\n\t\t\tnum_inputs++;\n\t\t}\n\t}\n\n\t \n\tif (num_outputs != 1 || num_inputs > 1)\n\t\treturn -EPIPE;\n\n\tpipe->num_dmas = num_inputs + num_outputs;\n\n\treturn 0;\n}\n\nstatic void __xvip_pipeline_cleanup(struct xvip_pipeline *pipe)\n{\n\tpipe->num_dmas = 0;\n\tpipe->output = NULL;\n}\n\n \nstatic void xvip_pipeline_cleanup(struct xvip_pipeline *pipe)\n{\n\tmutex_lock(&pipe->lock);\n\n\t \n\tif (--pipe->use_count == 0)\n\t\t__xvip_pipeline_cleanup(pipe);\n\n\tmutex_unlock(&pipe->lock);\n}\n\n \nstatic int xvip_pipeline_prepare(struct xvip_pipeline *pipe,\n\t\t\t\t struct xvip_dma *dma)\n{\n\tint ret;\n\n\tmutex_lock(&pipe->lock);\n\n\t \n\tif (pipe->use_count == 0) {\n\t\tret = xvip_pipeline_validate(pipe, dma);\n\t\tif (ret < 0) {\n\t\t\t__xvip_pipeline_cleanup(pipe);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tpipe->use_count++;\n\tret = 0;\n\ndone:\n\tmutex_unlock(&pipe->lock);\n\treturn ret;\n}\n\n \n\n \nstruct xvip_dma_buffer {\n\tstruct vb2_v4l2_buffer buf;\n\tstruct list_head queue;\n\tstruct xvip_dma *dma;\n};\n\n#define to_xvip_dma_buffer(vb)\tcontainer_of(vb, struct xvip_dma_buffer, buf)\n\nstatic void xvip_dma_complete(void *param)\n{\n\tstruct xvip_dma_buffer *buf = param;\n\tstruct xvip_dma *dma = buf->dma;\n\n\tspin_lock(&dma->queued_lock);\n\tlist_del(&buf->queue);\n\tspin_unlock(&dma->queued_lock);\n\n\tbuf->buf.field = V4L2_FIELD_NONE;\n\tbuf->buf.sequence = dma->sequence++;\n\tbuf->buf.vb2_buf.timestamp = ktime_get_ns();\n\tvb2_set_plane_payload(&buf->buf.vb2_buf, 0, dma->format.sizeimage);\n\tvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_DONE);\n}\n\nstatic int\nxvip_dma_queue_setup(struct vb2_queue *vq,\n\t\t     unsigned int *nbuffers, unsigned int *nplanes,\n\t\t     unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct xvip_dma *dma = vb2_get_drv_priv(vq);\n\n\t \n\tif (*nplanes)\n\t\treturn sizes[0] < dma->format.sizeimage ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = dma->format.sizeimage;\n\n\treturn 0;\n}\n\nstatic int xvip_dma_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct xvip_dma *dma = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct xvip_dma_buffer *buf = to_xvip_dma_buffer(vbuf);\n\n\tbuf->dma = dma;\n\n\treturn 0;\n}\n\nstatic void xvip_dma_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct xvip_dma *dma = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct xvip_dma_buffer *buf = to_xvip_dma_buffer(vbuf);\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_addr_t addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\tu32 flags;\n\n\tif (dma->queue.type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tflags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;\n\t\tdma->xt.dir = DMA_DEV_TO_MEM;\n\t\tdma->xt.src_sgl = false;\n\t\tdma->xt.dst_sgl = true;\n\t\tdma->xt.dst_start = addr;\n\t} else {\n\t\tflags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;\n\t\tdma->xt.dir = DMA_MEM_TO_DEV;\n\t\tdma->xt.src_sgl = true;\n\t\tdma->xt.dst_sgl = false;\n\t\tdma->xt.src_start = addr;\n\t}\n\n\tdma->xt.frame_size = 1;\n\tdma->sgl[0].size = dma->format.width * dma->fmtinfo->bpp;\n\tdma->sgl[0].icg = dma->format.bytesperline - dma->sgl[0].size;\n\tdma->xt.numf = dma->format.height;\n\n\tdesc = dmaengine_prep_interleaved_dma(dma->dma, &dma->xt, flags);\n\tif (!desc) {\n\t\tdev_err(dma->xdev->dev, \"Failed to prepare DMA transfer\\n\");\n\t\tvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\treturn;\n\t}\n\tdesc->callback = xvip_dma_complete;\n\tdesc->callback_param = buf;\n\n\tspin_lock_irq(&dma->queued_lock);\n\tlist_add_tail(&buf->queue, &dma->queued_bufs);\n\tspin_unlock_irq(&dma->queued_lock);\n\n\tdmaengine_submit(desc);\n\n\tif (vb2_is_streaming(&dma->queue))\n\t\tdma_async_issue_pending(dma->dma);\n}\n\nstatic int xvip_dma_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct xvip_dma *dma = vb2_get_drv_priv(vq);\n\tstruct xvip_dma_buffer *buf, *nbuf;\n\tstruct xvip_pipeline *pipe;\n\tint ret;\n\n\tdma->sequence = 0;\n\n\t \n\tpipe = to_xvip_pipeline(&dma->video) ? : &dma->pipe;\n\n\tret = video_device_pipeline_start(&dma->video, &pipe->pipe);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tret = xvip_dma_verify_format(dma);\n\tif (ret < 0)\n\t\tgoto error_stop;\n\n\tret = xvip_pipeline_prepare(pipe, dma);\n\tif (ret < 0)\n\t\tgoto error_stop;\n\n\t \n\tdma_async_issue_pending(dma->dma);\n\n\t \n\txvip_pipeline_set_stream(pipe, true);\n\n\treturn 0;\n\nerror_stop:\n\tvideo_device_pipeline_stop(&dma->video);\n\nerror:\n\t \n\tspin_lock_irq(&dma->queued_lock);\n\tlist_for_each_entry_safe(buf, nbuf, &dma->queued_bufs, queue) {\n\t\tvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t\tlist_del(&buf->queue);\n\t}\n\tspin_unlock_irq(&dma->queued_lock);\n\n\treturn ret;\n}\n\nstatic void xvip_dma_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct xvip_dma *dma = vb2_get_drv_priv(vq);\n\tstruct xvip_pipeline *pipe = to_xvip_pipeline(&dma->video);\n\tstruct xvip_dma_buffer *buf, *nbuf;\n\n\t \n\txvip_pipeline_set_stream(pipe, false);\n\n\t \n\tdmaengine_terminate_all(dma->dma);\n\n\t \n\txvip_pipeline_cleanup(pipe);\n\tvideo_device_pipeline_stop(&dma->video);\n\n\t \n\tspin_lock_irq(&dma->queued_lock);\n\tlist_for_each_entry_safe(buf, nbuf, &dma->queued_bufs, queue) {\n\t\tvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tlist_del(&buf->queue);\n\t}\n\tspin_unlock_irq(&dma->queued_lock);\n}\n\nstatic const struct vb2_ops xvip_dma_queue_qops = {\n\t.queue_setup = xvip_dma_queue_setup,\n\t.buf_prepare = xvip_dma_buffer_prepare,\n\t.buf_queue = xvip_dma_buffer_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = xvip_dma_start_streaming,\n\t.stop_streaming = xvip_dma_stop_streaming,\n};\n\n \n\nstatic int\nxvip_dma_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct xvip_dma *dma = to_xvip_dma(vfh->vdev);\n\n\tcap->capabilities = dma->xdev->v4l2_caps | V4L2_CAP_STREAMING |\n\t\t\t    V4L2_CAP_DEVICE_CAPS;\n\n\tstrscpy(cap->driver, \"xilinx-vipp\", sizeof(cap->driver));\n\tstrscpy(cap->card, dma->video.name, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"platform:%pOFn:%u\",\n\t\t dma->xdev->dev->of_node, dma->port);\n\n\treturn 0;\n}\n\n \nstatic int\nxvip_dma_enum_format(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct xvip_dma *dma = to_xvip_dma(vfh->vdev);\n\n\tif (f->index > 0)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = dma->format.pixelformat;\n\n\treturn 0;\n}\n\nstatic int\nxvip_dma_get_format(struct file *file, void *fh, struct v4l2_format *format)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct xvip_dma *dma = to_xvip_dma(vfh->vdev);\n\n\tformat->fmt.pix = dma->format;\n\n\treturn 0;\n}\n\nstatic void\n__xvip_dma_try_format(struct xvip_dma *dma, struct v4l2_pix_format *pix,\n\t\t      const struct xvip_video_format **fmtinfo)\n{\n\tconst struct xvip_video_format *info;\n\tunsigned int min_width;\n\tunsigned int max_width;\n\tunsigned int min_bpl;\n\tunsigned int max_bpl;\n\tunsigned int width;\n\tunsigned int align;\n\tunsigned int bpl;\n\n\t \n\tinfo = xvip_get_format_by_fourcc(pix->pixelformat);\n\n\tpix->pixelformat = info->fourcc;\n\tpix->field = V4L2_FIELD_NONE;\n\n\t \n\talign = lcm(dma->align, info->bpp);\n\tmin_width = roundup(XVIP_DMA_MIN_WIDTH, align);\n\tmax_width = rounddown(XVIP_DMA_MAX_WIDTH, align);\n\twidth = rounddown(pix->width * info->bpp, align);\n\n\tpix->width = clamp(width, min_width, max_width) / info->bpp;\n\tpix->height = clamp(pix->height, XVIP_DMA_MIN_HEIGHT,\n\t\t\t    XVIP_DMA_MAX_HEIGHT);\n\n\t \n\tmin_bpl = pix->width * info->bpp;\n\tmax_bpl = rounddown(XVIP_DMA_MAX_WIDTH, dma->align);\n\tbpl = rounddown(pix->bytesperline, dma->align);\n\n\tpix->bytesperline = clamp(bpl, min_bpl, max_bpl);\n\tpix->sizeimage = pix->bytesperline * pix->height;\n\n\tif (fmtinfo)\n\t\t*fmtinfo = info;\n}\n\nstatic int\nxvip_dma_try_format(struct file *file, void *fh, struct v4l2_format *format)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct xvip_dma *dma = to_xvip_dma(vfh->vdev);\n\n\t__xvip_dma_try_format(dma, &format->fmt.pix, NULL);\n\treturn 0;\n}\n\nstatic int\nxvip_dma_set_format(struct file *file, void *fh, struct v4l2_format *format)\n{\n\tstruct v4l2_fh *vfh = file->private_data;\n\tstruct xvip_dma *dma = to_xvip_dma(vfh->vdev);\n\tconst struct xvip_video_format *info;\n\n\t__xvip_dma_try_format(dma, &format->fmt.pix, &info);\n\n\tif (vb2_is_busy(&dma->queue))\n\t\treturn -EBUSY;\n\n\tdma->format = format->fmt.pix;\n\tdma->fmtinfo = info;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops xvip_dma_ioctl_ops = {\n\t.vidioc_querycap\t\t= xvip_dma_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= xvip_dma_enum_format,\n\t.vidioc_g_fmt_vid_cap\t\t= xvip_dma_get_format,\n\t.vidioc_g_fmt_vid_out\t\t= xvip_dma_get_format,\n\t.vidioc_s_fmt_vid_cap\t\t= xvip_dma_set_format,\n\t.vidioc_s_fmt_vid_out\t\t= xvip_dma_set_format,\n\t.vidioc_try_fmt_vid_cap\t\t= xvip_dma_try_format,\n\t.vidioc_try_fmt_vid_out\t\t= xvip_dma_try_format,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n};\n\n \n\nstatic const struct v4l2_file_operations xvip_dma_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= vb2_fop_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n};\n\n \n\nint xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,\n\t\t  enum v4l2_buf_type type, unsigned int port)\n{\n\tchar name[16];\n\tint ret;\n\n\tdma->xdev = xdev;\n\tdma->port = port;\n\tmutex_init(&dma->lock);\n\tmutex_init(&dma->pipe.lock);\n\tINIT_LIST_HEAD(&dma->queued_bufs);\n\tspin_lock_init(&dma->queued_lock);\n\n\tdma->fmtinfo = xvip_get_format_by_fourcc(V4L2_PIX_FMT_YUYV);\n\tdma->format.pixelformat = dma->fmtinfo->fourcc;\n\tdma->format.colorspace = V4L2_COLORSPACE_SRGB;\n\tdma->format.field = V4L2_FIELD_NONE;\n\tdma->format.width = XVIP_DMA_DEF_WIDTH;\n\tdma->format.height = XVIP_DMA_DEF_HEIGHT;\n\tdma->format.bytesperline = dma->format.width * dma->fmtinfo->bpp;\n\tdma->format.sizeimage = dma->format.bytesperline * dma->format.height;\n\n\t \n\tdma->pad.flags = type == V4L2_BUF_TYPE_VIDEO_CAPTURE\n\t\t       ? MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&dma->video.entity, 1, &dma->pad);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tdma->video.fops = &xvip_dma_fops;\n\tdma->video.v4l2_dev = &xdev->v4l2_dev;\n\tdma->video.queue = &dma->queue;\n\tsnprintf(dma->video.name, sizeof(dma->video.name), \"%pOFn %s %u\",\n\t\t xdev->dev->of_node,\n\t\t type == V4L2_BUF_TYPE_VIDEO_CAPTURE ? \"output\" : \"input\",\n\t\t port);\n\tdma->video.vfl_type = VFL_TYPE_VIDEO;\n\tdma->video.vfl_dir = type == V4L2_BUF_TYPE_VIDEO_CAPTURE\n\t\t\t   ? VFL_DIR_RX : VFL_DIR_TX;\n\tdma->video.release = video_device_release_empty;\n\tdma->video.ioctl_ops = &xvip_dma_ioctl_ops;\n\tdma->video.lock = &dma->lock;\n\tdma->video.device_caps = V4L2_CAP_STREAMING;\n\tif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tdma->video.device_caps |= V4L2_CAP_VIDEO_CAPTURE;\n\telse\n\t\tdma->video.device_caps |= V4L2_CAP_VIDEO_OUTPUT;\n\n\tvideo_set_drvdata(&dma->video, dma);\n\n\t \n\t \n\tdma->queue.type = type;\n\tdma->queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tdma->queue.lock = &dma->lock;\n\tdma->queue.drv_priv = dma;\n\tdma->queue.buf_struct_size = sizeof(struct xvip_dma_buffer);\n\tdma->queue.ops = &xvip_dma_queue_qops;\n\tdma->queue.mem_ops = &vb2_dma_contig_memops;\n\tdma->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC\n\t\t\t\t   | V4L2_BUF_FLAG_TSTAMP_SRC_EOF;\n\tdma->queue.dev = dma->xdev->dev;\n\tret = vb2_queue_init(&dma->queue);\n\tif (ret < 0) {\n\t\tdev_err(dma->xdev->dev, \"failed to initialize VB2 queue\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"port%u\", port);\n\tdma->dma = dma_request_chan(dma->xdev->dev, name);\n\tif (IS_ERR(dma->dma)) {\n\t\tret = PTR_ERR(dma->dma);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dma->xdev->dev, \"no VDMA channel found\\n\");\n\t\tgoto error;\n\t}\n\n\tdma->align = 1 << dma->dma->device->copy_align;\n\n\tret = video_register_device(&dma->video, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0) {\n\t\tdev_err(dma->xdev->dev, \"failed to register video device\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\txvip_dma_cleanup(dma);\n\treturn ret;\n}\n\nvoid xvip_dma_cleanup(struct xvip_dma *dma)\n{\n\tif (video_is_registered(&dma->video))\n\t\tvideo_unregister_device(&dma->video);\n\n\tif (!IS_ERR_OR_NULL(dma->dma))\n\t\tdma_release_channel(dma->dma);\n\n\tmedia_entity_cleanup(&dma->video.entity);\n\n\tmutex_destroy(&dma->lock);\n\tmutex_destroy(&dma->pipe.lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}