{
  "module_name": "xilinx-tpg.c",
  "hash_id": "d619050a1ddc281e2e28a450be16fb85c0fb54107debda1af267275b8c250776",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/xilinx/xilinx-tpg.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/xilinx-v4l2-controls.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-subdev.h>\n\n#include \"xilinx-vip.h\"\n#include \"xilinx-vtc.h\"\n\n#define XTPG_CTRL_STATUS_SLAVE_ERROR\t\t(1 << 16)\n#define XTPG_CTRL_IRQ_SLAVE_ERROR\t\t(1 << 16)\n\n#define XTPG_PATTERN_CONTROL\t\t\t0x0100\n#define XTPG_PATTERN_MASK\t\t\t(0xf << 0)\n#define XTPG_PATTERN_CONTROL_CROSS_HAIRS\t(1 << 4)\n#define XTPG_PATTERN_CONTROL_MOVING_BOX\t\t(1 << 5)\n#define XTPG_PATTERN_CONTROL_COLOR_MASK_SHIFT\t6\n#define XTPG_PATTERN_CONTROL_COLOR_MASK_MASK\t(0xf << 6)\n#define XTPG_PATTERN_CONTROL_STUCK_PIXEL\t(1 << 9)\n#define XTPG_PATTERN_CONTROL_NOISE\t\t(1 << 10)\n#define XTPG_PATTERN_CONTROL_MOTION\t\t(1 << 12)\n#define XTPG_MOTION_SPEED\t\t\t0x0104\n#define XTPG_CROSS_HAIRS\t\t\t0x0108\n#define XTPG_CROSS_HAIRS_ROW_SHIFT\t\t0\n#define XTPG_CROSS_HAIRS_ROW_MASK\t\t(0xfff << 0)\n#define XTPG_CROSS_HAIRS_COLUMN_SHIFT\t\t16\n#define XTPG_CROSS_HAIRS_COLUMN_MASK\t\t(0xfff << 16)\n#define XTPG_ZPLATE_HOR_CONTROL\t\t\t0x010c\n#define XTPG_ZPLATE_VER_CONTROL\t\t\t0x0110\n#define XTPG_ZPLATE_START_SHIFT\t\t\t0\n#define XTPG_ZPLATE_START_MASK\t\t\t(0xffff << 0)\n#define XTPG_ZPLATE_SPEED_SHIFT\t\t\t16\n#define XTPG_ZPLATE_SPEED_MASK\t\t\t(0xffff << 16)\n#define XTPG_BOX_SIZE\t\t\t\t0x0114\n#define XTPG_BOX_COLOR\t\t\t\t0x0118\n#define XTPG_STUCK_PIXEL_THRESH\t\t\t0x011c\n#define XTPG_NOISE_GAIN\t\t\t\t0x0120\n#define XTPG_BAYER_PHASE\t\t\t0x0124\n#define XTPG_BAYER_PHASE_RGGB\t\t\t0\n#define XTPG_BAYER_PHASE_GRBG\t\t\t1\n#define XTPG_BAYER_PHASE_GBRG\t\t\t2\n#define XTPG_BAYER_PHASE_BGGR\t\t\t3\n#define XTPG_BAYER_PHASE_OFF\t\t\t4\n\n \n#define XTPG_MIN_HBLANK\t\t\t3\n#define XTPG_MAX_HBLANK\t\t\t(XVTC_MAX_HSIZE - XVIP_MIN_WIDTH)\n#define XTPG_MIN_VBLANK\t\t\t3\n#define XTPG_MAX_VBLANK\t\t\t(XVTC_MAX_VSIZE - XVIP_MIN_HEIGHT)\n\n \nstruct xtpg_device {\n\tstruct xvip_device xvip;\n\n\tstruct media_pad pads[2];\n\tunsigned int npads;\n\tbool has_input;\n\n\tstruct v4l2_mbus_framefmt formats[2];\n\tstruct v4l2_mbus_framefmt default_format;\n\tconst struct xvip_video_format *vip_format;\n\tbool bayer;\n\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct v4l2_ctrl *hblank;\n\tstruct v4l2_ctrl *vblank;\n\tstruct v4l2_ctrl *pattern;\n\tbool streaming;\n\n\tstruct xvtc_device *vtc;\n\tstruct gpio_desc *vtmux_gpio;\n};\n\nstatic inline struct xtpg_device *to_tpg(struct v4l2_subdev *subdev)\n{\n\treturn container_of(subdev, struct xtpg_device, xvip.subdev);\n}\n\nstatic u32 xtpg_get_bayer_phase(unsigned int code)\n{\n\tswitch (code) {\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\t\treturn XTPG_BAYER_PHASE_RGGB;\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\t\treturn XTPG_BAYER_PHASE_GRBG;\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\t\treturn XTPG_BAYER_PHASE_GBRG;\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\treturn XTPG_BAYER_PHASE_BGGR;\n\tdefault:\n\t\treturn XTPG_BAYER_PHASE_OFF;\n\t}\n}\n\nstatic void __xtpg_update_pattern_control(struct xtpg_device *xtpg,\n\t\t\t\t\t  bool passthrough, bool pattern)\n{\n\tu32 pattern_mask = (1 << (xtpg->pattern->maximum + 1)) - 1;\n\n\t \n\tif (xtpg->npads == 1 || !xtpg->has_input)\n\t\tpassthrough = false;\n\n\t \n\tif (passthrough)\n\t\tpattern_mask &= ~1;\n\n\t \n\tif (pattern)\n\t\tpattern_mask &= 1;\n\n\t__v4l2_ctrl_modify_range(xtpg->pattern, 0, xtpg->pattern->maximum,\n\t\t\t\t pattern_mask, pattern ? 9 : 0);\n}\n\nstatic void xtpg_update_pattern_control(struct xtpg_device *xtpg,\n\t\t\t\t\tbool passthrough, bool pattern)\n{\n\tmutex_lock(xtpg->ctrl_handler.lock);\n\t__xtpg_update_pattern_control(xtpg, passthrough, pattern);\n\tmutex_unlock(xtpg->ctrl_handler.lock);\n}\n\n \n\nstatic int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tstruct xtpg_device *xtpg = to_tpg(subdev);\n\tunsigned int width = xtpg->formats[0].width;\n\tunsigned int height = xtpg->formats[0].height;\n\tbool passthrough;\n\tu32 bayer_phase;\n\n\tif (!enable) {\n\t\txvip_stop(&xtpg->xvip);\n\t\tif (xtpg->vtc)\n\t\t\txvtc_generator_stop(xtpg->vtc);\n\n\t\txtpg_update_pattern_control(xtpg, true, true);\n\t\txtpg->streaming = false;\n\t\treturn 0;\n\t}\n\n\txvip_set_frame_size(&xtpg->xvip, &xtpg->formats[0]);\n\n\tif (xtpg->vtc) {\n\t\tstruct xvtc_config config = {\n\t\t\t.hblank_start = width,\n\t\t\t.hsync_start = width + 1,\n\t\t\t.vblank_start = height,\n\t\t\t.vsync_start = height + 1,\n\t\t};\n\t\tunsigned int htotal;\n\t\tunsigned int vtotal;\n\n\t\thtotal = min_t(unsigned int, XVTC_MAX_HSIZE,\n\t\t\t       v4l2_ctrl_g_ctrl(xtpg->hblank) + width);\n\t\tvtotal = min_t(unsigned int, XVTC_MAX_VSIZE,\n\t\t\t       v4l2_ctrl_g_ctrl(xtpg->vblank) + height);\n\n\t\tconfig.hsync_end = htotal - 1;\n\t\tconfig.hsize = htotal;\n\t\tconfig.vsync_end = vtotal - 1;\n\t\tconfig.vsize = vtotal;\n\n\t\txvtc_generator_start(xtpg->vtc, &config);\n\t}\n\n\t \n\tmutex_lock(xtpg->ctrl_handler.lock);\n\n\txvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\n\t\t\t XTPG_PATTERN_MASK, xtpg->pattern->cur.val);\n\n\t \n\tpassthrough = xtpg->pattern->cur.val == 0;\n\t__xtpg_update_pattern_control(xtpg, passthrough, !passthrough);\n\n\txtpg->streaming = true;\n\n\tmutex_unlock(xtpg->ctrl_handler.lock);\n\n\t \n\tbayer_phase = passthrough ? XTPG_BAYER_PHASE_OFF\n\t\t    : xtpg_get_bayer_phase(xtpg->formats[0].code);\n\txvip_write(&xtpg->xvip, XTPG_BAYER_PHASE, bayer_phase);\n\n\tif (xtpg->vtmux_gpio)\n\t\tgpiod_set_value_cansleep(xtpg->vtmux_gpio, !passthrough);\n\n\txvip_start(&xtpg->xvip);\n\n\treturn 0;\n}\n\n \n\nstatic struct v4l2_mbus_framefmt *\n__xtpg_get_pad_format(struct xtpg_device *xtpg,\n\t\t      struct v4l2_subdev_state *sd_state,\n\t\t      unsigned int pad, u32 which)\n{\n\tswitch (which) {\n\tcase V4L2_SUBDEV_FORMAT_TRY:\n\t\treturn v4l2_subdev_get_try_format(&xtpg->xvip.subdev,\n\t\t\t\t\t\t  sd_state, pad);\n\tcase V4L2_SUBDEV_FORMAT_ACTIVE:\n\t\treturn &xtpg->formats[pad];\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int xtpg_get_format(struct v4l2_subdev *subdev,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct xtpg_device *xtpg = to_tpg(subdev);\n\n\tfmt->format = *__xtpg_get_pad_format(xtpg, sd_state, fmt->pad,\n\t\t\t\t\t     fmt->which);\n\n\treturn 0;\n}\n\nstatic int xtpg_set_format(struct v4l2_subdev *subdev,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct xtpg_device *xtpg = to_tpg(subdev);\n\tstruct v4l2_mbus_framefmt *__format;\n\tu32 bayer_phase;\n\n\t__format = __xtpg_get_pad_format(xtpg, sd_state, fmt->pad, fmt->which);\n\n\t \n\tif (xtpg->npads == 2 && fmt->pad == 1) {\n\t\tfmt->format = *__format;\n\t\treturn 0;\n\t}\n\n\t \n\tif (xtpg->bayer) {\n\t\tbayer_phase = xtpg_get_bayer_phase(fmt->format.code);\n\t\tif (bayer_phase != XTPG_BAYER_PHASE_OFF)\n\t\t\t__format->code = fmt->format.code;\n\t}\n\n\txvip_set_format_size(__format, fmt);\n\n\tfmt->format = *__format;\n\n\t \n\tif (xtpg->npads == 2) {\n\t\t__format = __xtpg_get_pad_format(xtpg, sd_state, 1,\n\t\t\t\t\t\t fmt->which);\n\t\t*__format = fmt->format;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int xtpg_enum_frame_size(struct v4l2_subdev *subdev,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = v4l2_subdev_get_try_format(subdev, sd_state, fse->pad);\n\n\tif (fse->index || fse->code != format->code)\n\t\treturn -EINVAL;\n\n\t \n\tif (fse->pad == 0) {\n\t\tfse->min_width = XVIP_MIN_WIDTH;\n\t\tfse->max_width = XVIP_MAX_WIDTH;\n\t\tfse->min_height = XVIP_MIN_HEIGHT;\n\t\tfse->max_height = XVIP_MAX_HEIGHT;\n\t} else {\n\t\tfse->min_width = format->width;\n\t\tfse->max_width = format->width;\n\t\tfse->min_height = format->height;\n\t\tfse->max_height = format->height;\n\t}\n\n\treturn 0;\n}\n\nstatic int xtpg_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\n{\n\tstruct xtpg_device *xtpg = to_tpg(subdev);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = v4l2_subdev_get_try_format(subdev, fh->state, 0);\n\t*format = xtpg->default_format;\n\n\tif (xtpg->npads == 2) {\n\t\tformat = v4l2_subdev_get_try_format(subdev, fh->state, 1);\n\t\t*format = xtpg->default_format;\n\t}\n\n\treturn 0;\n}\n\nstatic int xtpg_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\n{\n\treturn 0;\n}\n\nstatic int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct xtpg_device *xtpg = container_of(ctrl->handler,\n\t\t\t\t\t\tstruct xtpg_device,\n\t\t\t\t\t\tctrl_handler);\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_TEST_PATTERN:\n\t\txvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\n\t\t\t\t XTPG_PATTERN_MASK, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_CROSS_HAIRS:\n\t\txvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\n\t\t\t\tXTPG_PATTERN_CONTROL_CROSS_HAIRS, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_MOVING_BOX:\n\t\txvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\n\t\t\t\tXTPG_PATTERN_CONTROL_MOVING_BOX, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_COLOR_MASK:\n\t\txvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\n\t\t\t\t XTPG_PATTERN_CONTROL_COLOR_MASK_MASK,\n\t\t\t\t ctrl->val <<\n\t\t\t\t XTPG_PATTERN_CONTROL_COLOR_MASK_SHIFT);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_STUCK_PIXEL:\n\t\txvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\n\t\t\t\tXTPG_PATTERN_CONTROL_STUCK_PIXEL, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_NOISE:\n\t\txvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\n\t\t\t\tXTPG_PATTERN_CONTROL_NOISE, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_MOTION:\n\t\txvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\n\t\t\t\tXTPG_PATTERN_CONTROL_MOTION, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_MOTION_SPEED:\n\t\txvip_write(&xtpg->xvip, XTPG_MOTION_SPEED, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_CROSS_HAIR_ROW:\n\t\txvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,\n\t\t\t\t XTPG_CROSS_HAIRS_ROW_MASK,\n\t\t\t\t ctrl->val << XTPG_CROSS_HAIRS_ROW_SHIFT);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_CROSS_HAIR_COLUMN:\n\t\txvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,\n\t\t\t\t XTPG_CROSS_HAIRS_COLUMN_MASK,\n\t\t\t\t ctrl->val << XTPG_CROSS_HAIRS_COLUMN_SHIFT);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_ZPLATE_HOR_START:\n\t\txvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,\n\t\t\t\t XTPG_ZPLATE_START_MASK,\n\t\t\t\t ctrl->val << XTPG_ZPLATE_START_SHIFT);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_ZPLATE_HOR_SPEED:\n\t\txvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,\n\t\t\t\t XTPG_ZPLATE_SPEED_MASK,\n\t\t\t\t ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_ZPLATE_VER_START:\n\t\txvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,\n\t\t\t\t XTPG_ZPLATE_START_MASK,\n\t\t\t\t ctrl->val << XTPG_ZPLATE_START_SHIFT);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_ZPLATE_VER_SPEED:\n\t\txvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,\n\t\t\t\t XTPG_ZPLATE_SPEED_MASK,\n\t\t\t\t ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_BOX_SIZE:\n\t\txvip_write(&xtpg->xvip, XTPG_BOX_SIZE, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_BOX_COLOR:\n\t\txvip_write(&xtpg->xvip, XTPG_BOX_COLOR, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH:\n\t\txvip_write(&xtpg->xvip, XTPG_STUCK_PIXEL_THRESH, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_XILINX_TPG_NOISE_GAIN:\n\t\txvip_write(&xtpg->xvip, XTPG_NOISE_GAIN, ctrl->val);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops xtpg_ctrl_ops = {\n\t.s_ctrl\t= xtpg_s_ctrl,\n};\n\nstatic const struct v4l2_subdev_core_ops xtpg_core_ops = {\n};\n\nstatic const struct v4l2_subdev_video_ops xtpg_video_ops = {\n\t.s_stream = xtpg_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops xtpg_pad_ops = {\n\t.enum_mbus_code\t\t= xvip_enum_mbus_code,\n\t.enum_frame_size\t= xtpg_enum_frame_size,\n\t.get_fmt\t\t= xtpg_get_format,\n\t.set_fmt\t\t= xtpg_set_format,\n};\n\nstatic const struct v4l2_subdev_ops xtpg_ops = {\n\t.core   = &xtpg_core_ops,\n\t.video  = &xtpg_video_ops,\n\t.pad    = &xtpg_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops xtpg_internal_ops = {\n\t.open\t= xtpg_open,\n\t.close\t= xtpg_close,\n};\n\n \n\nstatic const char *const xtpg_pattern_strings[] = {\n\t\"Passthrough\",\n\t\"Horizontal Ramp\",\n\t\"Vertical Ramp\",\n\t\"Temporal Ramp\",\n\t\"Solid Red\",\n\t\"Solid Green\",\n\t\"Solid Blue\",\n\t\"Solid Black\",\n\t\"Solid White\",\n\t\"Color Bars\",\n\t\"Zone Plate\",\n\t\"Tartan Color Bars\",\n\t\"Cross Hatch\",\n\t\"None\",\n\t\"Vertical/Horizontal Ramps\",\n\t\"Black/White Checker Board\",\n};\n\nstatic struct v4l2_ctrl_config xtpg_ctrls[] = {\n\t{\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_CROSS_HAIRS,\n\t\t.name\t= \"Test Pattern: Cross Hairs\",\n\t\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.min\t= false,\n\t\t.max\t= true,\n\t\t.step\t= 1,\n\t\t.def\t= 0,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_MOVING_BOX,\n\t\t.name\t= \"Test Pattern: Moving Box\",\n\t\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.min\t= false,\n\t\t.max\t= true,\n\t\t.step\t= 1,\n\t\t.def\t= 0,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_COLOR_MASK,\n\t\t.name\t= \"Test Pattern: Color Mask\",\n\t\t.type\t= V4L2_CTRL_TYPE_BITMASK,\n\t\t.min\t= 0,\n\t\t.max\t= 0xf,\n\t\t.def\t= 0,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_STUCK_PIXEL,\n\t\t.name\t= \"Test Pattern: Stuck Pixel\",\n\t\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.min\t= false,\n\t\t.max\t= true,\n\t\t.step\t= 1,\n\t\t.def\t= 0,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_NOISE,\n\t\t.name\t= \"Test Pattern: Noise\",\n\t\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.min\t= false,\n\t\t.max\t= true,\n\t\t.step\t= 1,\n\t\t.def\t= 0,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_MOTION,\n\t\t.name\t= \"Test Pattern: Motion\",\n\t\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.min\t= false,\n\t\t.max\t= true,\n\t\t.step\t= 1,\n\t\t.def\t= 0,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_MOTION_SPEED,\n\t\t.name\t= \"Test Pattern: Motion Speed\",\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.min\t= 0,\n\t\t.max\t= (1 << 8) - 1,\n\t\t.step\t= 1,\n\t\t.def\t= 4,\n\t\t.flags\t= V4L2_CTRL_FLAG_SLIDER,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_CROSS_HAIR_ROW,\n\t\t.name\t= \"Test Pattern: Cross Hairs Row\",\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.min\t= 0,\n\t\t.max\t= (1 << 12) - 1,\n\t\t.step\t= 1,\n\t\t.def\t= 0x64,\n\t\t.flags\t= V4L2_CTRL_FLAG_SLIDER,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_CROSS_HAIR_COLUMN,\n\t\t.name\t= \"Test Pattern: Cross Hairs Column\",\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.min\t= 0,\n\t\t.max\t= (1 << 12) - 1,\n\t\t.step\t= 1,\n\t\t.def\t= 0x64,\n\t\t.flags\t= V4L2_CTRL_FLAG_SLIDER,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_ZPLATE_HOR_START,\n\t\t.name\t= \"Test Pattern: Zplate Horizontal Start Pos\",\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.min\t= 0,\n\t\t.max\t= (1 << 16) - 1,\n\t\t.step\t= 1,\n\t\t.def\t= 0x1e,\n\t\t.flags\t= V4L2_CTRL_FLAG_SLIDER,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_ZPLATE_HOR_SPEED,\n\t\t.name\t= \"Test Pattern: Zplate Horizontal Speed\",\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.min\t= 0,\n\t\t.max\t= (1 << 16) - 1,\n\t\t.step\t= 1,\n\t\t.def\t= 0,\n\t\t.flags\t= V4L2_CTRL_FLAG_SLIDER,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_ZPLATE_VER_START,\n\t\t.name\t= \"Test Pattern: Zplate Vertical Start Pos\",\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.min\t= 0,\n\t\t.max\t= (1 << 16) - 1,\n\t\t.step\t= 1,\n\t\t.def\t= 1,\n\t\t.flags\t= V4L2_CTRL_FLAG_SLIDER,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_ZPLATE_VER_SPEED,\n\t\t.name\t= \"Test Pattern: Zplate Vertical Speed\",\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.min\t= 0,\n\t\t.max\t= (1 << 16) - 1,\n\t\t.step\t= 1,\n\t\t.def\t= 0,\n\t\t.flags\t= V4L2_CTRL_FLAG_SLIDER,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_BOX_SIZE,\n\t\t.name\t= \"Test Pattern: Box Size\",\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.min\t= 0,\n\t\t.max\t= (1 << 12) - 1,\n\t\t.step\t= 1,\n\t\t.def\t= 0x32,\n\t\t.flags\t= V4L2_CTRL_FLAG_SLIDER,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_BOX_COLOR,\n\t\t.name\t= \"Test Pattern: Box Color(RGB)\",\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.min\t= 0,\n\t\t.max\t= (1 << 24) - 1,\n\t\t.step\t= 1,\n\t\t.def\t= 0,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH,\n\t\t.name\t= \"Test Pattern: Stuck Pixel threshold\",\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.min\t= 0,\n\t\t.max\t= (1 << 16) - 1,\n\t\t.step\t= 1,\n\t\t.def\t= 0,\n\t\t.flags\t= V4L2_CTRL_FLAG_SLIDER,\n\t}, {\n\t\t.ops\t= &xtpg_ctrl_ops,\n\t\t.id\t= V4L2_CID_XILINX_TPG_NOISE_GAIN,\n\t\t.name\t= \"Test Pattern: Noise Gain\",\n\t\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t\t.min\t= 0,\n\t\t.max\t= (1 << 8) - 1,\n\t\t.step\t= 1,\n\t\t.def\t= 0,\n\t\t.flags\t= V4L2_CTRL_FLAG_SLIDER,\n\t},\n};\n\n \n\nstatic const struct media_entity_operations xtpg_media_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \n\nstatic int __maybe_unused xtpg_pm_suspend(struct device *dev)\n{\n\tstruct xtpg_device *xtpg = dev_get_drvdata(dev);\n\n\txvip_suspend(&xtpg->xvip);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused xtpg_pm_resume(struct device *dev)\n{\n\tstruct xtpg_device *xtpg = dev_get_drvdata(dev);\n\n\txvip_resume(&xtpg->xvip);\n\n\treturn 0;\n}\n\n \n\nstatic int xtpg_parse_of(struct xtpg_device *xtpg)\n{\n\tstruct device *dev = xtpg->xvip.dev;\n\tstruct device_node *node = xtpg->xvip.dev->of_node;\n\tstruct device_node *ports;\n\tstruct device_node *port;\n\tunsigned int nports = 0;\n\tbool has_endpoint = false;\n\n\tports = of_get_child_by_name(node, \"ports\");\n\tif (ports == NULL)\n\t\tports = node;\n\n\tfor_each_child_of_node(ports, port) {\n\t\tconst struct xvip_video_format *format;\n\t\tstruct device_node *endpoint;\n\n\t\tif (!of_node_name_eq(port, \"port\"))\n\t\t\tcontinue;\n\n\t\tformat = xvip_of_get_format(port);\n\t\tif (IS_ERR(format)) {\n\t\t\tdev_err(dev, \"invalid format in DT\");\n\t\t\tof_node_put(port);\n\t\t\treturn PTR_ERR(format);\n\t\t}\n\n\t\t \n\t\tif (!xtpg->vip_format) {\n\t\t\txtpg->vip_format = format;\n\t\t} else if (xtpg->vip_format != format) {\n\t\t\tdev_err(dev, \"in/out format mismatch in DT\");\n\t\t\tof_node_put(port);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (nports == 0) {\n\t\t\tendpoint = of_get_next_child(port, NULL);\n\t\t\tif (endpoint)\n\t\t\t\thas_endpoint = true;\n\t\t\tof_node_put(endpoint);\n\t\t}\n\n\t\t \n\t\tnports++;\n\t}\n\n\tif (nports != 1 && nports != 2) {\n\t\tdev_err(dev, \"invalid number of ports %u\\n\", nports);\n\t\treturn -EINVAL;\n\t}\n\n\txtpg->npads = nports;\n\tif (nports == 2 && has_endpoint)\n\t\txtpg->has_input = true;\n\n\treturn 0;\n}\n\nstatic int xtpg_probe(struct platform_device *pdev)\n{\n\tstruct v4l2_subdev *subdev;\n\tstruct xtpg_device *xtpg;\n\tu32 i, bayer_phase;\n\tint ret;\n\n\txtpg = devm_kzalloc(&pdev->dev, sizeof(*xtpg), GFP_KERNEL);\n\tif (!xtpg)\n\t\treturn -ENOMEM;\n\n\txtpg->xvip.dev = &pdev->dev;\n\n\tret = xtpg_parse_of(xtpg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = xvip_init_resources(&xtpg->xvip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\txtpg->vtmux_gpio = devm_gpiod_get_optional(&pdev->dev, \"timing\",\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(xtpg->vtmux_gpio)) {\n\t\tret = PTR_ERR(xtpg->vtmux_gpio);\n\t\tgoto error_resource;\n\t}\n\n\txtpg->vtc = xvtc_of_get(pdev->dev.of_node);\n\tif (IS_ERR(xtpg->vtc)) {\n\t\tret = PTR_ERR(xtpg->vtc);\n\t\tgoto error_resource;\n\t}\n\n\t \n\txvip_reset(&xtpg->xvip);\n\n\t \n\tif (xtpg->npads == 2) {\n\t\txtpg->pads[0].flags = MEDIA_PAD_FL_SINK;\n\t\txtpg->pads[1].flags = MEDIA_PAD_FL_SOURCE;\n\t} else {\n\t\txtpg->pads[0].flags = MEDIA_PAD_FL_SOURCE;\n\t}\n\n\t \n\txtpg->default_format.code = xtpg->vip_format->code;\n\txtpg->default_format.field = V4L2_FIELD_NONE;\n\txtpg->default_format.colorspace = V4L2_COLORSPACE_SRGB;\n\txvip_get_frame_size(&xtpg->xvip, &xtpg->default_format);\n\n\tbayer_phase = xtpg_get_bayer_phase(xtpg->vip_format->code);\n\tif (bayer_phase != XTPG_BAYER_PHASE_OFF)\n\t\txtpg->bayer = true;\n\n\txtpg->formats[0] = xtpg->default_format;\n\tif (xtpg->npads == 2)\n\t\txtpg->formats[1] = xtpg->default_format;\n\n\t \n\tsubdev = &xtpg->xvip.subdev;\n\tv4l2_subdev_init(subdev, &xtpg_ops);\n\tsubdev->dev = &pdev->dev;\n\tsubdev->internal_ops = &xtpg_internal_ops;\n\tstrscpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));\n\tv4l2_set_subdevdata(subdev, xtpg);\n\tsubdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsubdev->entity.ops = &xtpg_media_ops;\n\n\tret = media_entity_pads_init(&subdev->entity, xtpg->npads, xtpg->pads);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tv4l2_ctrl_handler_init(&xtpg->ctrl_handler, 3 + ARRAY_SIZE(xtpg_ctrls));\n\n\txtpg->vblank = v4l2_ctrl_new_std(&xtpg->ctrl_handler, &xtpg_ctrl_ops,\n\t\t\t\t\t V4L2_CID_VBLANK, XTPG_MIN_VBLANK,\n\t\t\t\t\t XTPG_MAX_VBLANK, 1, 100);\n\txtpg->hblank = v4l2_ctrl_new_std(&xtpg->ctrl_handler, &xtpg_ctrl_ops,\n\t\t\t\t\t V4L2_CID_HBLANK, XTPG_MIN_HBLANK,\n\t\t\t\t\t XTPG_MAX_HBLANK, 1, 100);\n\txtpg->pattern = v4l2_ctrl_new_std_menu_items(&xtpg->ctrl_handler,\n\t\t\t\t\t&xtpg_ctrl_ops, V4L2_CID_TEST_PATTERN,\n\t\t\t\t\tARRAY_SIZE(xtpg_pattern_strings) - 1,\n\t\t\t\t\t1, 9, xtpg_pattern_strings);\n\n\tfor (i = 0; i < ARRAY_SIZE(xtpg_ctrls); i++)\n\t\tv4l2_ctrl_new_custom(&xtpg->ctrl_handler, &xtpg_ctrls[i], NULL);\n\n\tif (xtpg->ctrl_handler.error) {\n\t\tdev_err(&pdev->dev, \"failed to add controls\\n\");\n\t\tret = xtpg->ctrl_handler.error;\n\t\tgoto error;\n\t}\n\tsubdev->ctrl_handler = &xtpg->ctrl_handler;\n\n\txtpg_update_pattern_control(xtpg, true, true);\n\n\tret = v4l2_ctrl_handler_setup(&xtpg->ctrl_handler);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to set controls\\n\");\n\t\tgoto error;\n\t}\n\n\tplatform_set_drvdata(pdev, xtpg);\n\n\txvip_print_version(&xtpg->xvip);\n\n\tret = v4l2_async_register_subdev(subdev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register subdev\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tv4l2_ctrl_handler_free(&xtpg->ctrl_handler);\n\tmedia_entity_cleanup(&subdev->entity);\n\txvtc_put(xtpg->vtc);\nerror_resource:\n\txvip_cleanup_resources(&xtpg->xvip);\n\treturn ret;\n}\n\nstatic void xtpg_remove(struct platform_device *pdev)\n{\n\tstruct xtpg_device *xtpg = platform_get_drvdata(pdev);\n\tstruct v4l2_subdev *subdev = &xtpg->xvip.subdev;\n\n\tv4l2_async_unregister_subdev(subdev);\n\tv4l2_ctrl_handler_free(&xtpg->ctrl_handler);\n\tmedia_entity_cleanup(&subdev->entity);\n\n\txvip_cleanup_resources(&xtpg->xvip);\n}\n\nstatic SIMPLE_DEV_PM_OPS(xtpg_pm_ops, xtpg_pm_suspend, xtpg_pm_resume);\n\nstatic const struct of_device_id xtpg_of_id_table[] = {\n\t{ .compatible = \"xlnx,v-tpg-5.0\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, xtpg_of_id_table);\n\nstatic struct platform_driver xtpg_driver = {\n\t.driver = {\n\t\t.name\t\t= \"xilinx-tpg\",\n\t\t.pm\t\t= &xtpg_pm_ops,\n\t\t.of_match_table\t= xtpg_of_id_table,\n\t},\n\t.probe\t\t\t= xtpg_probe,\n\t.remove_new\t\t= xtpg_remove,\n};\n\nmodule_platform_driver(xtpg_driver);\n\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_DESCRIPTION(\"Xilinx Test Pattern Generator Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}