{
  "module_name": "pxa_camera.c",
  "hash_id": "1e75a3688e8655d9ec293c50fb4fa8c2166cb34f287eafdd0c98eca6673934f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/intel/pxa_camera.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/time.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/dmaengine.h>\n#include <linux/dma/pxa-dma.h>\n\n#include <media/v4l2-async.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-fwnode.h>\n\n#include <media/videobuf2-dma-sg.h>\n\n#include <linux/videodev2.h>\n\n#include <linux/platform_data/media/camera-pxa.h>\n\n#define PXA_CAM_VERSION \"0.0.6\"\n#define PXA_CAM_DRV_NAME \"pxa27x-camera\"\n\n#define DEFAULT_WIDTH\t640\n#define DEFAULT_HEIGHT\t480\n\n \n#define CICR0\t\t0x0000\n#define CICR1\t\t0x0004\n#define CICR2\t\t0x0008\n#define CICR3\t\t0x000C\n#define CICR4\t\t0x0010\n#define CISR\t\t0x0014\n#define CIFR\t\t0x0018\n#define CITOR\t\t0x001C\n#define CIBR0\t\t0x0028\n#define CIBR1\t\t0x0030\n#define CIBR2\t\t0x0038\n\n#define CICR0_DMAEN\t(1UL << 31)\t \n#define CICR0_PAR_EN\t(1 << 30)\t \n#define CICR0_SL_CAP_EN\t(1 << 29)\t \n#define CICR0_ENB\t(1 << 28)\t \n#define CICR0_DIS\t(1 << 27)\t \n#define CICR0_SIM\t(0x7 << 24)\t \n#define CICR0_TOM\t(1 << 9)\t \n#define CICR0_RDAVM\t(1 << 8)\t \n#define CICR0_FEM\t(1 << 7)\t \n#define CICR0_EOLM\t(1 << 6)\t \n#define CICR0_PERRM\t(1 << 5)\t \n#define CICR0_QDM\t(1 << 4)\t \n#define CICR0_CDM\t(1 << 3)\t \n#define CICR0_SOFM\t(1 << 2)\t \n#define CICR0_EOFM\t(1 << 1)\t \n#define CICR0_FOM\t(1 << 0)\t \n\n#define CICR1_TBIT\t(1UL << 31)\t \n#define CICR1_RGBT_CONV\t(0x3 << 29)\t \n#define CICR1_PPL\t(0x7ff << 15)\t \n#define CICR1_RGB_CONV\t(0x7 << 12)\t \n#define CICR1_RGB_F\t(1 << 11)\t \n#define CICR1_YCBCR_F\t(1 << 10)\t \n#define CICR1_RGB_BPP\t(0x7 << 7)\t \n#define CICR1_RAW_BPP\t(0x3 << 5)\t \n#define CICR1_COLOR_SP\t(0x3 << 3)\t \n#define CICR1_DW\t(0x7 << 0)\t \n\n#define CICR2_BLW\t(0xff << 24)\t \n#define CICR2_ELW\t(0xff << 16)\t \n#define CICR2_HSW\t(0x3f << 10)\t \n#define CICR2_BFPW\t(0x3f << 3)\t \n#define CICR2_FSW\t(0x7 << 0)\t \n\n#define CICR3_BFW\t(0xff << 24)\t \n#define CICR3_EFW\t(0xff << 16)\t \n#define CICR3_VSW\t(0x3f << 10)\t \n#define CICR3_BFPW\t(0x3f << 3)\t \n#define CICR3_LPF\t(0x7ff << 0)\t \n\n#define CICR4_MCLK_DLY\t(0x3 << 24)\t \n#define CICR4_PCLK_EN\t(1 << 23)\t \n#define CICR4_PCP\t(1 << 22)\t \n#define CICR4_HSP\t(1 << 21)\t \n#define CICR4_VSP\t(1 << 20)\t \n#define CICR4_MCLK_EN\t(1 << 19)\t \n#define CICR4_FR_RATE\t(0x7 << 8)\t \n#define CICR4_DIV\t(0xff << 0)\t \n\n#define CISR_FTO\t(1 << 15)\t \n#define CISR_RDAV_2\t(1 << 14)\t \n#define CISR_RDAV_1\t(1 << 13)\t \n#define CISR_RDAV_0\t(1 << 12)\t \n#define CISR_FEMPTY_2\t(1 << 11)\t \n#define CISR_FEMPTY_1\t(1 << 10)\t \n#define CISR_FEMPTY_0\t(1 << 9)\t \n#define CISR_EOL\t(1 << 8)\t \n#define CISR_PAR_ERR\t(1 << 7)\t \n#define CISR_CQD\t(1 << 6)\t \n#define CISR_CDD\t(1 << 5)\t \n#define CISR_SOF\t(1 << 4)\t \n#define CISR_EOF\t(1 << 3)\t \n#define CISR_IFO_2\t(1 << 2)\t \n#define CISR_IFO_1\t(1 << 1)\t \n#define CISR_IFO_0\t(1 << 0)\t \n\n#define CIFR_FLVL2\t(0x7f << 23)\t \n#define CIFR_FLVL1\t(0x7f << 16)\t \n#define CIFR_FLVL0\t(0xff << 8)\t \n#define CIFR_THL_0\t(0x3 << 4)\t \n#define CIFR_RESET_F\t(1 << 3)\t \n#define CIFR_FEN2\t(1 << 2)\t \n#define CIFR_FEN1\t(1 << 1)\t \n#define CIFR_FEN0\t(1 << 0)\t \n\n#define CICR0_SIM_MP\t(0 << 24)\n#define CICR0_SIM_SP\t(1 << 24)\n#define CICR0_SIM_MS\t(2 << 24)\n#define CICR0_SIM_EP\t(3 << 24)\n#define CICR0_SIM_ES\t(4 << 24)\n\n#define CICR1_DW_VAL(x)   ((x) & CICR1_DW)\t     \n#define CICR1_PPL_VAL(x)  (((x) << 15) & CICR1_PPL)  \n#define CICR1_COLOR_SP_VAL(x)\t(((x) << 3) & CICR1_COLOR_SP)\t \n#define CICR1_RGB_BPP_VAL(x)\t(((x) << 7) & CICR1_RGB_BPP)\t \n#define CICR1_RGBT_CONV_VAL(x)\t(((x) << 29) & CICR1_RGBT_CONV)\t \n\n#define CICR2_BLW_VAL(x)  (((x) << 24) & CICR2_BLW)  \n#define CICR2_ELW_VAL(x)  (((x) << 16) & CICR2_ELW)  \n#define CICR2_HSW_VAL(x)  (((x) << 10) & CICR2_HSW)  \n#define CICR2_BFPW_VAL(x) (((x) << 3) & CICR2_BFPW)  \n#define CICR2_FSW_VAL(x)  (((x) << 0) & CICR2_FSW)   \n\n#define CICR3_BFW_VAL(x)  (((x) << 24) & CICR3_BFW)  \n#define CICR3_EFW_VAL(x)  (((x) << 16) & CICR3_EFW)  \n#define CICR3_VSW_VAL(x)  (((x) << 11) & CICR3_VSW)  \n#define CICR3_LPF_VAL(x)  (((x) << 0) & CICR3_LPF)   \n\n#define CICR0_IRQ_MASK (CICR0_TOM | CICR0_RDAVM | CICR0_FEM | CICR0_EOLM | \\\n\t\t\tCICR0_PERRM | CICR0_QDM | CICR0_CDM | CICR0_SOFM | \\\n\t\t\tCICR0_EOFM | CICR0_FOM)\n\n#define sensor_call(cam, o, f, args...) \\\n\tv4l2_subdev_call(cam->sensor, o, f, ##args)\n\n \n\n \nenum pxa_mbus_packing {\n\tPXA_MBUS_PACKING_NONE,\n\tPXA_MBUS_PACKING_2X8_PADHI,\n\tPXA_MBUS_PACKING_EXTEND16,\n};\n\n \nenum pxa_mbus_order {\n\tPXA_MBUS_ORDER_LE,\n\tPXA_MBUS_ORDER_BE,\n};\n\n \nenum pxa_mbus_layout {\n\tPXA_MBUS_LAYOUT_PACKED = 0,\n\tPXA_MBUS_LAYOUT_PLANAR_2Y_U_V,\n\tPXA_MBUS_LAYOUT_PLANAR_2Y_C,\n\tPXA_MBUS_LAYOUT_PLANAR_Y_C,\n};\n\n \nstruct pxa_mbus_pixelfmt {\n\tconst char\t\t*name;\n\tu32\t\t\tfourcc;\n\tenum pxa_mbus_packing\tpacking;\n\tenum pxa_mbus_order\torder;\n\tenum pxa_mbus_layout\tlayout;\n\tu8\t\t\tbits_per_sample;\n};\n\n \nstruct pxa_mbus_lookup {\n\tu32\tcode;\n\tstruct pxa_mbus_pixelfmt\tfmt;\n};\n\nstatic const struct pxa_mbus_lookup mbus_fmt[] = {\n{\n\t.code = MEDIA_BUS_FMT_YUYV8_2X8,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.name\t\t\t= \"YUYV\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_2X8_PADHI,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_YVYU8_2X8,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_YVYU,\n\t\t.name\t\t\t= \"YVYU\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_2X8_PADHI,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_UYVY,\n\t\t.name\t\t\t= \"UYVY\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_2X8_PADHI,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_VYUY8_2X8,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_VYUY,\n\t\t.name\t\t\t= \"VYUY\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_2X8_PADHI,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_RGB555,\n\t\t.name\t\t\t= \"RGB555\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_2X8_PADHI,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_RGB555X,\n\t\t.name\t\t\t= \"RGB555X\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_2X8_PADHI,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_BE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_RGB565_2X8_LE,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.name\t\t\t= \"RGB565\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_2X8_PADHI,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_RGB565_2X8_BE,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_RGB565X,\n\t\t.name\t\t\t= \"RGB565X\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_2X8_PADHI,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_BE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SBGGR8_1X8,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.name\t\t\t= \"Bayer 8 BGGR\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_NONE,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SGBRG8_1X8,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SGBRG8,\n\t\t.name\t\t\t= \"Bayer 8 GBRG\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_NONE,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SGRBG8_1X8,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.name\t\t\t= \"Bayer 8 GRBG\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_NONE,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SRGGB8_1X8,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SRGGB8,\n\t\t.name\t\t\t= \"Bayer 8 RGGB\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_NONE,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SBGGR10_1X10,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SBGGR10,\n\t\t.name\t\t\t= \"Bayer 10 BGGR\",\n\t\t.bits_per_sample\t= 10,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_Y8_1X8,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_GREY,\n\t\t.name\t\t\t= \"Grey\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_NONE,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_Y10_1X10,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_Y10,\n\t\t.name\t\t\t= \"Grey 10bit\",\n\t\t.bits_per_sample\t= 10,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SBGGR10,\n\t\t.name\t\t\t= \"Bayer 10 BGGR\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_2X8_PADHI,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_BE,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SBGGR10,\n\t\t.name\t\t\t= \"Bayer 10 BGGR\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_2X8_PADHI,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_BE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_RGB444,\n\t\t.name\t\t\t= \"RGB444\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_2X8_PADHI,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_BE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_UYVY,\n\t\t.name\t\t\t= \"UYVY 16bit\",\n\t\t.bits_per_sample\t= 16,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_VYUY8_1X16,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_VYUY,\n\t\t.name\t\t\t= \"VYUY 16bit\",\n\t\t.bits_per_sample\t= 16,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_YUYV8_1X16,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.name\t\t\t= \"YUYV 16bit\",\n\t\t.bits_per_sample\t= 16,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_YVYU8_1X16,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_YVYU,\n\t\t.name\t\t\t= \"YVYU 16bit\",\n\t\t.bits_per_sample\t= 16,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SGRBG10DPCM8,\n\t\t.name\t\t\t= \"Bayer 10 BGGR DPCM 8\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_NONE,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SGBRG10_1X10,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SGBRG10,\n\t\t.name\t\t\t= \"Bayer 10 GBRG\",\n\t\t.bits_per_sample\t= 10,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SGRBG10_1X10,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SGRBG10,\n\t\t.name\t\t\t= \"Bayer 10 GRBG\",\n\t\t.bits_per_sample\t= 10,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SRGGB10_1X10,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SRGGB10,\n\t\t.name\t\t\t= \"Bayer 10 RGGB\",\n\t\t.bits_per_sample\t= 10,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SBGGR12_1X12,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SBGGR12,\n\t\t.name\t\t\t= \"Bayer 12 BGGR\",\n\t\t.bits_per_sample\t= 12,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SGBRG12_1X12,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SGBRG12,\n\t\t.name\t\t\t= \"Bayer 12 GBRG\",\n\t\t.bits_per_sample\t= 12,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SGRBG12_1X12,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SGRBG12,\n\t\t.name\t\t\t= \"Bayer 12 GRBG\",\n\t\t.bits_per_sample\t= 12,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n}, {\n\t.code = MEDIA_BUS_FMT_SRGGB12_1X12,\n\t.fmt = {\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_SRGGB12,\n\t\t.name\t\t\t= \"Bayer 12 RGGB\",\n\t\t.bits_per_sample\t= 12,\n\t\t.packing\t\t= PXA_MBUS_PACKING_EXTEND16,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PACKED,\n\t},\n},\n};\n\nstatic s32 pxa_mbus_bytes_per_line(u32 width, const struct pxa_mbus_pixelfmt *mf)\n{\n\tif (mf->layout != PXA_MBUS_LAYOUT_PACKED)\n\t\treturn width * mf->bits_per_sample / 8;\n\n\tswitch (mf->packing) {\n\tcase PXA_MBUS_PACKING_NONE:\n\t\treturn width * mf->bits_per_sample / 8;\n\tcase PXA_MBUS_PACKING_2X8_PADHI:\n\tcase PXA_MBUS_PACKING_EXTEND16:\n\t\treturn width * 2;\n\t}\n\treturn -EINVAL;\n}\n\nstatic s32 pxa_mbus_image_size(const struct pxa_mbus_pixelfmt *mf,\n\t\t\tu32 bytes_per_line, u32 height)\n{\n\tif (mf->layout == PXA_MBUS_LAYOUT_PACKED)\n\t\treturn bytes_per_line * height;\n\n\tswitch (mf->packing) {\n\tcase PXA_MBUS_PACKING_2X8_PADHI:\n\t\treturn bytes_per_line * height * 2;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct pxa_mbus_pixelfmt *pxa_mbus_find_fmtdesc(\n\tu32 code,\n\tconst struct pxa_mbus_lookup *lookup,\n\tint n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tif (lookup[i].code == code)\n\t\t\treturn &lookup[i].fmt;\n\n\treturn NULL;\n}\n\nstatic const struct pxa_mbus_pixelfmt *pxa_mbus_get_fmtdesc(\n\tu32 code)\n{\n\treturn pxa_mbus_find_fmtdesc(code, mbus_fmt, ARRAY_SIZE(mbus_fmt));\n}\n\n \nstruct pxa_camera_format_xlate {\n\tu32 code;\n\tconst struct pxa_mbus_pixelfmt *host_fmt;\n};\n\n \nenum pxa_camera_active_dma {\n\tDMA_Y = 0x1,\n\tDMA_U = 0x2,\n\tDMA_V = 0x4,\n};\n\n \nstruct pxa_buffer {\n\t \n\tstruct vb2_v4l2_buffer\t\tvbuf;\n\tstruct list_head\t\tqueue;\n\tu32\tcode;\n\tint\t\t\t\tnb_planes;\n\t \n\tstruct dma_async_tx_descriptor\t*descs[3];\n\tdma_cookie_t\t\t\tcookie[3];\n\tstruct scatterlist\t\t*sg[3];\n\tint\t\t\t\tsg_len[3];\n\tsize_t\t\t\t\tplane_sizes[3];\n\tint\t\t\t\tinwork;\n\tenum pxa_camera_active_dma\tactive_dma;\n};\n\nstruct pxa_camera_dev {\n\tstruct v4l2_device\tv4l2_dev;\n\tstruct video_device\tvdev;\n\tstruct v4l2_async_notifier notifier;\n\tstruct vb2_queue\tvb2_vq;\n\tstruct v4l2_subdev\t*sensor;\n\tstruct pxa_camera_format_xlate *user_formats;\n\tconst struct pxa_camera_format_xlate *current_fmt;\n\tstruct v4l2_pix_format\tcurrent_pix;\n\n\t \n\tstruct clk\t\t*clk;\n\n\tunsigned int\t\tirq;\n\tvoid __iomem\t\t*base;\n\n\tint\t\t\tchannels;\n\tstruct dma_chan\t\t*dma_chans[3];\n\n\tstruct pxacamera_platform_data *pdata;\n\tstruct resource\t\t*res;\n\tunsigned long\t\tplatform_flags;\n\tunsigned long\t\tciclk;\n\tunsigned long\t\tmclk;\n\tu32\t\t\tmclk_divisor;\n\tu16\t\t\twidth_flags;\t \n\n\tstruct list_head\tcapture;\n\n\tspinlock_t\t\tlock;\n\tstruct mutex\t\tmlock;\n\tunsigned int\t\tbuf_sequence;\n\n\tstruct pxa_buffer\t*active;\n\tstruct tasklet_struct\ttask_eof;\n\n\tu32\t\t\tsave_cicr[5];\n};\n\nstruct pxa_cam {\n\tunsigned long flags;\n};\n\nstatic const char *pxa_cam_driver_description = \"PXA_Camera\";\n\n \nstatic const struct pxa_camera_format_xlate\n*pxa_mbus_xlate_by_fourcc(struct pxa_camera_format_xlate *user_formats,\n\t\t\t  unsigned int fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; user_formats[i].code; i++)\n\t\tif (user_formats[i].host_fmt->fourcc == fourcc)\n\t\t\treturn user_formats + i;\n\treturn NULL;\n}\n\nstatic struct pxa_camera_format_xlate *pxa_mbus_build_fmts_xlate(\n\tstruct v4l2_device *v4l2_dev, struct v4l2_subdev *subdev,\n\tint (*get_formats)(struct v4l2_device *, unsigned int,\n\t\t\t   struct pxa_camera_format_xlate *xlate))\n{\n\tunsigned int i, fmts = 0, raw_fmts = 0;\n\tint ret;\n\tstruct v4l2_subdev_mbus_code_enum code = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct pxa_camera_format_xlate *user_formats;\n\n\twhile (!v4l2_subdev_call(subdev, pad, enum_mbus_code, NULL, &code)) {\n\t\traw_fmts++;\n\t\tcode.index++;\n\t}\n\n\t \n\tfor (i = 0; i < raw_fmts; i++) {\n\t\tret = get_formats(v4l2_dev, i, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t\tfmts += ret;\n\t}\n\n\tif (!fmts)\n\t\treturn ERR_PTR(-ENXIO);\n\n\tuser_formats = kcalloc(fmts + 1, sizeof(*user_formats), GFP_KERNEL);\n\tif (!user_formats)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tfmts = 0;\n\tfor (i = 0; i < raw_fmts; i++) {\n\t\tret = get_formats(v4l2_dev, i, user_formats + fmts);\n\t\tif (ret < 0)\n\t\t\tgoto egfmt;\n\t\tfmts += ret;\n\t}\n\tuser_formats[fmts].code = 0;\n\n\treturn user_formats;\negfmt:\n\tkfree(user_formats);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic struct pxa_buffer *vb2_to_pxa_buffer(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\treturn container_of(vbuf, struct pxa_buffer, vbuf);\n}\n\nstatic struct device *pcdev_to_dev(struct pxa_camera_dev *pcdev)\n{\n\treturn pcdev->v4l2_dev.dev;\n}\n\nstatic struct pxa_camera_dev *v4l2_dev_to_pcdev(struct v4l2_device *v4l2_dev)\n{\n\treturn container_of(v4l2_dev, struct pxa_camera_dev, v4l2_dev);\n}\n\nstatic void pxa_camera_dma_irq(struct pxa_camera_dev *pcdev,\n\t\t\t       enum pxa_camera_active_dma act_dma);\n\nstatic void pxa_camera_dma_irq_y(void *data)\n{\n\tstruct pxa_camera_dev *pcdev = data;\n\n\tpxa_camera_dma_irq(pcdev, DMA_Y);\n}\n\nstatic void pxa_camera_dma_irq_u(void *data)\n{\n\tstruct pxa_camera_dev *pcdev = data;\n\n\tpxa_camera_dma_irq(pcdev, DMA_U);\n}\n\nstatic void pxa_camera_dma_irq_v(void *data)\n{\n\tstruct pxa_camera_dev *pcdev = data;\n\n\tpxa_camera_dma_irq(pcdev, DMA_V);\n}\n\n \nstatic int pxa_init_dma_channel(struct pxa_camera_dev *pcdev,\n\t\t\t\tstruct pxa_buffer *buf, int channel,\n\t\t\t\tstruct scatterlist *sg, int sglen)\n{\n\tstruct dma_chan *dma_chan = pcdev->dma_chans[channel];\n\tstruct dma_async_tx_descriptor *tx;\n\n\ttx = dmaengine_prep_slave_sg(dma_chan, sg, sglen, DMA_DEV_TO_MEM,\n\t\t\t\t     DMA_PREP_INTERRUPT | DMA_CTRL_REUSE);\n\tif (!tx) {\n\t\tdev_err(pcdev_to_dev(pcdev),\n\t\t\t\"dmaengine_prep_slave_sg failed\\n\");\n\t\tgoto fail;\n\t}\n\n\ttx->callback_param = pcdev;\n\tswitch (channel) {\n\tcase 0:\n\t\ttx->callback = pxa_camera_dma_irq_y;\n\t\tbreak;\n\tcase 1:\n\t\ttx->callback = pxa_camera_dma_irq_u;\n\t\tbreak;\n\tcase 2:\n\t\ttx->callback = pxa_camera_dma_irq_v;\n\t\tbreak;\n\t}\n\n\tbuf->descs[channel] = tx;\n\treturn 0;\nfail:\n\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t\"%s (vb=%p) dma_tx=%p\\n\",\n\t\t__func__, buf, tx);\n\n\treturn -ENOMEM;\n}\n\nstatic void pxa_video_buf_set_actdma(struct pxa_camera_dev *pcdev,\n\t\t\t\t    struct pxa_buffer *buf)\n{\n\tbuf->active_dma = DMA_Y;\n\tif (buf->nb_planes == 3)\n\t\tbuf->active_dma |= DMA_U | DMA_V;\n}\n\n \nstatic void pxa_dma_start_channels(struct pxa_camera_dev *pcdev)\n{\n\tint i;\n\n\tfor (i = 0; i < pcdev->channels; i++) {\n\t\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t\t\"%s (channel=%d)\\n\", __func__, i);\n\t\tdma_async_issue_pending(pcdev->dma_chans[i]);\n\t}\n}\n\nstatic void pxa_dma_stop_channels(struct pxa_camera_dev *pcdev)\n{\n\tint i;\n\n\tfor (i = 0; i < pcdev->channels; i++) {\n\t\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t\t\"%s (channel=%d)\\n\", __func__, i);\n\t\tdmaengine_terminate_all(pcdev->dma_chans[i]);\n\t}\n}\n\nstatic void pxa_dma_add_tail_buf(struct pxa_camera_dev *pcdev,\n\t\t\t\t struct pxa_buffer *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < pcdev->channels; i++) {\n\t\tbuf->cookie[i] = dmaengine_submit(buf->descs[i]);\n\t\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t\t\"%s (channel=%d) : submit vb=%p cookie=%d\\n\",\n\t\t\t__func__, i, buf, buf->descs[i]->cookie);\n\t}\n}\n\n \nstatic void pxa_camera_start_capture(struct pxa_camera_dev *pcdev)\n{\n\tunsigned long cicr0;\n\n\tdev_dbg(pcdev_to_dev(pcdev), \"%s\\n\", __func__);\n\t__raw_writel(__raw_readl(pcdev->base + CISR), pcdev->base + CISR);\n\t \n\tcicr0 = __raw_readl(pcdev->base + CICR0) | CICR0_ENB;\n\tcicr0 &= ~CICR0_EOFM;\n\t__raw_writel(cicr0, pcdev->base + CICR0);\n}\n\nstatic void pxa_camera_stop_capture(struct pxa_camera_dev *pcdev)\n{\n\tunsigned long cicr0;\n\n\tpxa_dma_stop_channels(pcdev);\n\n\tcicr0 = __raw_readl(pcdev->base + CICR0) & ~CICR0_ENB;\n\t__raw_writel(cicr0, pcdev->base + CICR0);\n\n\tpcdev->active = NULL;\n\tdev_dbg(pcdev_to_dev(pcdev), \"%s\\n\", __func__);\n}\n\nstatic void pxa_camera_wakeup(struct pxa_camera_dev *pcdev,\n\t\t\t      struct pxa_buffer *buf,\n\t\t\t      enum vb2_buffer_state state)\n{\n\tstruct vb2_buffer *vb = &buf->vbuf.vb2_buf;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\t \n\tlist_del_init(&buf->queue);\n\tvb->timestamp = ktime_get_ns();\n\tvbuf->sequence = pcdev->buf_sequence++;\n\tvbuf->field = V4L2_FIELD_NONE;\n\tvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\n\tdev_dbg(pcdev_to_dev(pcdev), \"%s dequeued buffer (buf=0x%p)\\n\",\n\t\t__func__, buf);\n\n\tif (list_empty(&pcdev->capture)) {\n\t\tpxa_camera_stop_capture(pcdev);\n\t\treturn;\n\t}\n\n\tpcdev->active = list_entry(pcdev->capture.next,\n\t\t\t\t   struct pxa_buffer, queue);\n}\n\n \nstatic void pxa_camera_check_link_miss(struct pxa_camera_dev *pcdev,\n\t\t\t\t       dma_cookie_t last_submitted,\n\t\t\t\t       dma_cookie_t last_issued)\n{\n\tbool is_dma_stopped = last_submitted != last_issued;\n\n\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t\"%s : top queued buffer=%p, is_dma_stopped=%d\\n\",\n\t\t__func__, pcdev->active, is_dma_stopped);\n\n\tif (pcdev->active && is_dma_stopped)\n\t\tpxa_camera_start_capture(pcdev);\n}\n\nstatic void pxa_camera_dma_irq(struct pxa_camera_dev *pcdev,\n\t\t\t       enum pxa_camera_active_dma act_dma)\n{\n\tstruct pxa_buffer *buf, *last_buf;\n\tunsigned long flags;\n\tu32 camera_status, overrun;\n\tint chan;\n\tenum dma_status last_status;\n\tdma_cookie_t last_issued;\n\n\tspin_lock_irqsave(&pcdev->lock, flags);\n\n\tcamera_status = __raw_readl(pcdev->base + CISR);\n\tdev_dbg(pcdev_to_dev(pcdev), \"camera dma irq, cisr=0x%x dma=%d\\n\",\n\t\tcamera_status, act_dma);\n\toverrun = CISR_IFO_0;\n\tif (pcdev->channels == 3)\n\t\toverrun |= CISR_IFO_1 | CISR_IFO_2;\n\n\t \n\tif (!pcdev->active)\n\t\tgoto out;\n\n\tbuf = pcdev->active;\n\tWARN_ON(buf->inwork || list_empty(&buf->queue));\n\n\t \n\tswitch (act_dma) {\n\tcase DMA_U:\n\t\tchan = 1;\n\t\tbreak;\n\tcase DMA_V:\n\t\tchan = 2;\n\t\tbreak;\n\tdefault:\n\t\tchan = 0;\n\t\tbreak;\n\t}\n\tlast_buf = list_entry(pcdev->capture.prev,\n\t\t\t      struct pxa_buffer, queue);\n\tlast_status = dma_async_is_tx_complete(pcdev->dma_chans[chan],\n\t\t\t\t\t       last_buf->cookie[chan],\n\t\t\t\t\t       NULL, &last_issued);\n\tif (camera_status & overrun &&\n\t    last_status != DMA_COMPLETE) {\n\t\tdev_dbg(pcdev_to_dev(pcdev), \"FIFO overrun! CISR: %x\\n\",\n\t\t\tcamera_status);\n\t\tpxa_camera_stop_capture(pcdev);\n\t\tlist_for_each_entry(buf, &pcdev->capture, queue)\n\t\t\tpxa_dma_add_tail_buf(pcdev, buf);\n\t\tpxa_camera_start_capture(pcdev);\n\t\tgoto out;\n\t}\n\tbuf->active_dma &= ~act_dma;\n\tif (!buf->active_dma) {\n\t\tpxa_camera_wakeup(pcdev, buf, VB2_BUF_STATE_DONE);\n\t\tpxa_camera_check_link_miss(pcdev, last_buf->cookie[chan],\n\t\t\t\t\t   last_issued);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&pcdev->lock, flags);\n}\n\nstatic u32 mclk_get_divisor(struct platform_device *pdev,\n\t\t\t    struct pxa_camera_dev *pcdev)\n{\n\tunsigned long mclk = pcdev->mclk;\n\tu32 div;\n\tunsigned long lcdclk;\n\n\tlcdclk = clk_get_rate(pcdev->clk);\n\tpcdev->ciclk = lcdclk;\n\n\t \n\tif (mclk > lcdclk / 4) {\n\t\tmclk = lcdclk / 4;\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Limiting master clock to %lu\\n\", mclk);\n\t}\n\n\t \n\tdiv = (lcdclk + 2 * mclk - 1) / (2 * mclk) - 1;\n\n\t \n\tif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\n\t\tpcdev->mclk = lcdclk / (2 * (div + 1));\n\n\tdev_dbg(&pdev->dev, \"LCD clock %luHz, target freq %luHz, divisor %u\\n\",\n\t\tlcdclk, mclk, div);\n\n\treturn div;\n}\n\nstatic void recalculate_fifo_timeout(struct pxa_camera_dev *pcdev,\n\t\t\t\t     unsigned long pclk)\n{\n\t \n\tu32 ciclk_per_pixel = pcdev->ciclk / pclk + 1;\n\n\t__raw_writel(ciclk_per_pixel, pcdev->base + CITOR);\n}\n\nstatic void pxa_camera_activate(struct pxa_camera_dev *pcdev)\n{\n\tu32 cicr4 = 0;\n\n\t \n\t__raw_writel(0x3ff, pcdev->base + CICR0);\n\n\tif (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)\n\t\tcicr4 |= CICR4_PCLK_EN;\n\tif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\n\t\tcicr4 |= CICR4_MCLK_EN;\n\tif (pcdev->platform_flags & PXA_CAMERA_PCP)\n\t\tcicr4 |= CICR4_PCP;\n\tif (pcdev->platform_flags & PXA_CAMERA_HSP)\n\t\tcicr4 |= CICR4_HSP;\n\tif (pcdev->platform_flags & PXA_CAMERA_VSP)\n\t\tcicr4 |= CICR4_VSP;\n\n\t__raw_writel(pcdev->mclk_divisor | cicr4, pcdev->base + CICR4);\n\n\tif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\n\t\t \n\t\trecalculate_fifo_timeout(pcdev, pcdev->mclk);\n\telse\n\t\t \n\t\trecalculate_fifo_timeout(pcdev, 13000000);\n\n\tclk_prepare_enable(pcdev->clk);\n}\n\nstatic void pxa_camera_deactivate(struct pxa_camera_dev *pcdev)\n{\n\tclk_disable_unprepare(pcdev->clk);\n}\n\nstatic void pxa_camera_eof(struct tasklet_struct *t)\n{\n\tstruct pxa_camera_dev *pcdev = from_tasklet(pcdev, t, task_eof);\n\tunsigned long cifr;\n\tstruct pxa_buffer *buf;\n\n\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t\"Camera interrupt status 0x%x\\n\",\n\t\t__raw_readl(pcdev->base + CISR));\n\n\t \n\tcifr = __raw_readl(pcdev->base + CIFR) | CIFR_RESET_F;\n\t__raw_writel(cifr, pcdev->base + CIFR);\n\n\tpcdev->active = list_first_entry(&pcdev->capture,\n\t\t\t\t\t struct pxa_buffer, queue);\n\tbuf = pcdev->active;\n\tpxa_video_buf_set_actdma(pcdev, buf);\n\n\tpxa_dma_start_channels(pcdev);\n}\n\nstatic irqreturn_t pxa_camera_irq(int irq, void *data)\n{\n\tstruct pxa_camera_dev *pcdev = data;\n\tunsigned long status, cicr0;\n\n\tstatus = __raw_readl(pcdev->base + CISR);\n\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t\"Camera interrupt status 0x%lx\\n\", status);\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\t__raw_writel(status, pcdev->base + CISR);\n\n\tif (status & CISR_EOF) {\n\t\tcicr0 = __raw_readl(pcdev->base + CICR0) | CICR0_EOFM;\n\t\t__raw_writel(cicr0, pcdev->base + CICR0);\n\t\ttasklet_schedule(&pcdev->task_eof);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void pxa_camera_setup_cicr(struct pxa_camera_dev *pcdev,\n\t\t\t\t  unsigned long flags, __u32 pixfmt)\n{\n\tunsigned long dw, bpp;\n\tu32 cicr0, cicr1, cicr2, cicr3, cicr4 = 0, y_skip_top;\n\tint ret = sensor_call(pcdev, sensor, g_skip_top_lines, &y_skip_top);\n\n\tif (ret < 0)\n\t\ty_skip_top = 0;\n\n\t \n\tswitch (pcdev->current_fmt->host_fmt->bits_per_sample) {\n\tcase 10:\n\t\tdw = 4;\n\t\tbpp = 0x40;\n\t\tbreak;\n\tcase 9:\n\t\tdw = 3;\n\t\tbpp = 0x20;\n\t\tbreak;\n\tdefault:\n\t\t \n\tcase 8:\n\t\tdw = 2;\n\t\tbpp = 0;\n\t}\n\n\tif (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)\n\t\tcicr4 |= CICR4_PCLK_EN;\n\tif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\n\t\tcicr4 |= CICR4_MCLK_EN;\n\tif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\n\t\tcicr4 |= CICR4_PCP;\n\tif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\n\t\tcicr4 |= CICR4_HSP;\n\tif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\n\t\tcicr4 |= CICR4_VSP;\n\n\tcicr0 = __raw_readl(pcdev->base + CICR0);\n\tif (cicr0 & CICR0_ENB)\n\t\t__raw_writel(cicr0 & ~CICR0_ENB, pcdev->base + CICR0);\n\n\tcicr1 = CICR1_PPL_VAL(pcdev->current_pix.width - 1) | bpp | dw;\n\n\tswitch (pixfmt) {\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\tpcdev->channels = 3;\n\t\tcicr1 |= CICR1_YCBCR_F;\n\t\t \n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_VYUY:\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_YVYU:\n\t\tcicr1 |= CICR1_COLOR_SP_VAL(2);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB555:\n\t\tcicr1 |= CICR1_RGB_BPP_VAL(1) | CICR1_RGBT_CONV_VAL(2) |\n\t\t\tCICR1_TBIT | CICR1_COLOR_SP_VAL(1);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565:\n\t\tcicr1 |= CICR1_COLOR_SP_VAL(1) | CICR1_RGB_BPP_VAL(2);\n\t\tbreak;\n\t}\n\n\tcicr2 = 0;\n\tcicr3 = CICR3_LPF_VAL(pcdev->current_pix.height - 1) |\n\t\tCICR3_BFW_VAL(min((u32)255, y_skip_top));\n\tcicr4 |= pcdev->mclk_divisor;\n\n\t__raw_writel(cicr1, pcdev->base + CICR1);\n\t__raw_writel(cicr2, pcdev->base + CICR2);\n\t__raw_writel(cicr3, pcdev->base + CICR3);\n\t__raw_writel(cicr4, pcdev->base + CICR4);\n\n\t \n\tcicr0 = (cicr0 & CICR0_ENB) | (pcdev->platform_flags & PXA_CAMERA_MASTER ?\n\t\tCICR0_SIM_MP : (CICR0_SL_CAP_EN | CICR0_SIM_SP));\n\tcicr0 |= CICR0_DMAEN | CICR0_IRQ_MASK;\n\t__raw_writel(cicr0, pcdev->base + CICR0);\n}\n\n \nstatic void pxa_buffer_cleanup(struct pxa_buffer *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < 3 && buf->descs[i]; i++) {\n\t\tdmaengine_desc_free(buf->descs[i]);\n\t\tkfree(buf->sg[i]);\n\t\tbuf->descs[i] = NULL;\n\t\tbuf->sg[i] = NULL;\n\t\tbuf->sg_len[i] = 0;\n\t\tbuf->plane_sizes[i] = 0;\n\t}\n\tbuf->nb_planes = 0;\n}\n\nstatic int pxa_buffer_init(struct pxa_camera_dev *pcdev,\n\t\t\t   struct pxa_buffer *buf)\n{\n\tstruct vb2_buffer *vb = &buf->vbuf.vb2_buf;\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(vb, 0);\n\tint nb_channels = pcdev->channels;\n\tint i, ret = 0;\n\tunsigned long size = vb2_plane_size(vb, 0);\n\n\tswitch (nb_channels) {\n\tcase 1:\n\t\tbuf->plane_sizes[0] = size;\n\t\tbreak;\n\tcase 3:\n\t\tbuf->plane_sizes[0] = size / 2;\n\t\tbuf->plane_sizes[1] = size / 4;\n\t\tbuf->plane_sizes[2] = size / 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tbuf->nb_planes = nb_channels;\n\n\tret = sg_split(sgt->sgl, sgt->nents, 0, nb_channels,\n\t\t       buf->plane_sizes, buf->sg, buf->sg_len, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tdev_err(pcdev_to_dev(pcdev),\n\t\t\t\"sg_split failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tfor (i = 0; i < nb_channels; i++) {\n\t\tret = pxa_init_dma_channel(pcdev, buf, i,\n\t\t\t\t\t   buf->sg[i], buf->sg_len[i]);\n\t\tif (ret) {\n\t\t\tpxa_buffer_cleanup(buf);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tINIT_LIST_HEAD(&buf->queue);\n\n\treturn ret;\n}\n\nstatic void pxac_vb2_cleanup(struct vb2_buffer *vb)\n{\n\tstruct pxa_buffer *buf = vb2_to_pxa_buffer(vb);\n\tstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vb->vb2_queue);\n\n\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t \"%s(vb=%p)\\n\", __func__, vb);\n\tpxa_buffer_cleanup(buf);\n}\n\nstatic void pxac_vb2_queue(struct vb2_buffer *vb)\n{\n\tstruct pxa_buffer *buf = vb2_to_pxa_buffer(vb);\n\tstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vb->vb2_queue);\n\n\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t \"%s(vb=%p) nb_channels=%d size=%lu active=%p\\n\",\n\t\t__func__, vb, pcdev->channels, vb2_get_plane_payload(vb, 0),\n\t\tpcdev->active);\n\n\tlist_add_tail(&buf->queue, &pcdev->capture);\n\n\tpxa_dma_add_tail_buf(pcdev, buf);\n}\n\n \nstatic int pxac_vb2_prepare(struct vb2_buffer *vb)\n{\n\tstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct pxa_buffer *buf = vb2_to_pxa_buffer(vb);\n\tint ret = 0;\n#ifdef DEBUG\n\tint i;\n#endif\n\n\tswitch (pcdev->channels) {\n\tcase 1:\n\tcase 3:\n\t\tvb2_set_plane_payload(vb, 0, pcdev->current_pix.sizeimage);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t \"%s (vb=%p) nb_channels=%d size=%lu\\n\",\n\t\t__func__, vb, pcdev->channels, vb2_get_plane_payload(vb, 0));\n\n\tWARN_ON(!pcdev->current_fmt);\n\n#ifdef DEBUG\n\t \n\tfor (i = 0; i < vb->num_planes; i++)\n\t\tmemset((void *)vb2_plane_vaddr(vb, i),\n\t\t       0xaa, vb2_get_plane_payload(vb, i));\n#endif\n\n\t \n\tbuf->inwork = 0;\n\tpxa_video_buf_set_actdma(pcdev, buf);\n\n\treturn ret;\n}\n\nstatic int pxac_vb2_init(struct vb2_buffer *vb)\n{\n\tstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct pxa_buffer *buf = vb2_to_pxa_buffer(vb);\n\n\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t \"%s(nb_channels=%d)\\n\",\n\t\t__func__, pcdev->channels);\n\n\treturn pxa_buffer_init(pcdev, buf);\n}\n\nstatic int pxac_vb2_queue_setup(struct vb2_queue *vq,\n\t\t\t\tunsigned int *nbufs,\n\t\t\t\tunsigned int *num_planes, unsigned int sizes[],\n\t\t\t\tstruct device *alloc_devs[])\n{\n\tstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vq);\n\tint size = pcdev->current_pix.sizeimage;\n\n\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t \"%s(vq=%p nbufs=%d num_planes=%d size=%d)\\n\",\n\t\t__func__, vq, *nbufs, *num_planes, size);\n\t \n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*num_planes = 1;\n\tswitch (pcdev->channels) {\n\tcase 1:\n\tcase 3:\n\t\tsizes[0] = size;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!*nbufs)\n\t\t*nbufs = 1;\n\n\treturn 0;\n}\n\nstatic int pxac_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vq);\n\n\tdev_dbg(pcdev_to_dev(pcdev), \"%s(count=%d) active=%p\\n\",\n\t\t__func__, count, pcdev->active);\n\n\tpcdev->buf_sequence = 0;\n\tif (!pcdev->active)\n\t\tpxa_camera_start_capture(pcdev);\n\n\treturn 0;\n}\n\nstatic void pxac_vb2_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vq);\n\tstruct pxa_buffer *buf, *tmp;\n\n\tdev_dbg(pcdev_to_dev(pcdev), \"%s active=%p\\n\",\n\t\t__func__, pcdev->active);\n\tpxa_camera_stop_capture(pcdev);\n\n\tlist_for_each_entry_safe(buf, tmp, &pcdev->capture, queue)\n\t\tpxa_camera_wakeup(pcdev, buf, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct vb2_ops pxac_vb2_ops = {\n\t.queue_setup\t\t= pxac_vb2_queue_setup,\n\t.buf_init\t\t= pxac_vb2_init,\n\t.buf_prepare\t\t= pxac_vb2_prepare,\n\t.buf_queue\t\t= pxac_vb2_queue,\n\t.buf_cleanup\t\t= pxac_vb2_cleanup,\n\t.start_streaming\t= pxac_vb2_start_streaming,\n\t.stop_streaming\t\t= pxac_vb2_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic int pxa_camera_init_videobuf2(struct pxa_camera_dev *pcdev)\n{\n\tint ret;\n\tstruct vb2_queue *vq = &pcdev->vb2_vq;\n\n\tmemset(vq, 0, sizeof(*vq));\n\tvq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tvq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tvq->drv_priv = pcdev;\n\tvq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tvq->buf_struct_size = sizeof(struct pxa_buffer);\n\tvq->dev = pcdev->v4l2_dev.dev;\n\n\tvq->ops = &pxac_vb2_ops;\n\tvq->mem_ops = &vb2_dma_sg_memops;\n\tvq->lock = &pcdev->mlock;\n\n\tret = vb2_queue_init(vq);\n\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t \"vb2_queue_init(vq=%p): %d\\n\", vq, ret);\n\n\treturn ret;\n}\n\n \nstatic int pxa_camera_set_bus_param(struct pxa_camera_dev *pcdev)\n{\n\tunsigned int bus_width = pcdev->current_fmt->host_fmt->bits_per_sample;\n\tstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\n\tu32 pixfmt = pcdev->current_fmt->host_fmt->fourcc;\n\tint mbus_config;\n\tint ret;\n\n\tif (!((1 << (bus_width - 1)) & pcdev->width_flags)) {\n\t\tdev_err(pcdev_to_dev(pcdev), \"Unsupported bus width %u\",\n\t\t\tbus_width);\n\t\treturn -EINVAL;\n\t}\n\n\tpcdev->channels = 1;\n\n\t \n\tmbus_config = 0;\n\tif (pcdev->platform_flags & PXA_CAMERA_MASTER)\n\t\tmbus_config |= V4L2_MBUS_MASTER;\n\telse\n\t\tmbus_config |= V4L2_MBUS_SLAVE;\n\n\tif (pcdev->platform_flags & PXA_CAMERA_HSP)\n\t\tmbus_config |= V4L2_MBUS_HSYNC_ACTIVE_HIGH;\n\telse\n\t\tmbus_config |= V4L2_MBUS_HSYNC_ACTIVE_LOW;\n\n\tif (pcdev->platform_flags & PXA_CAMERA_VSP)\n\t\tmbus_config |= V4L2_MBUS_VSYNC_ACTIVE_HIGH;\n\telse\n\t\tmbus_config |= V4L2_MBUS_VSYNC_ACTIVE_LOW;\n\n\tif (pcdev->platform_flags & PXA_CAMERA_PCP)\n\t\tmbus_config |= V4L2_MBUS_PCLK_SAMPLE_RISING;\n\telse\n\t\tmbus_config |= V4L2_MBUS_PCLK_SAMPLE_FALLING;\n\tmbus_config |= V4L2_MBUS_DATA_ACTIVE_HIGH;\n\n\tret = sensor_call(pcdev, pad, get_mbus_config, 0, &cfg);\n\tif (ret < 0 && ret != -ENOIOCTLCMD) {\n\t\tdev_err(pcdev_to_dev(pcdev),\n\t\t\t\"Failed to call get_mbus_config: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (cfg.bus.parallel.flags != mbus_config) {\n\t\tunsigned int pxa_mbus_role = mbus_config & (V4L2_MBUS_MASTER |\n\t\t\t\t\t\t\t    V4L2_MBUS_SLAVE);\n\t\tunsigned int flags = cfg.bus.parallel.flags;\n\n\t\tif (pxa_mbus_role != (flags & (V4L2_MBUS_MASTER |\n\t\t\t\t\t       V4L2_MBUS_SLAVE))) {\n\t\t\tdev_err(pcdev_to_dev(pcdev),\n\t\t\t\t\"Unsupported mbus configuration: bus mastering\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (flags & V4L2_MBUS_DATA_ACTIVE_LOW) {\n\t\t\tdev_err(pcdev_to_dev(pcdev),\n\t\t\t\t\"Unsupported mbus configuration: DATA_ACTIVE_LOW\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpxa_camera_setup_cicr(pcdev, cfg.bus.parallel.flags, pixfmt);\n\n\treturn 0;\n}\n\nstatic const struct pxa_mbus_pixelfmt pxa_camera_formats[] = {\n\t{\n\t\t.fourcc\t\t\t= V4L2_PIX_FMT_YUV422P,\n\t\t.name\t\t\t= \"Planar YUV422 16 bit\",\n\t\t.bits_per_sample\t= 8,\n\t\t.packing\t\t= PXA_MBUS_PACKING_2X8_PADHI,\n\t\t.order\t\t\t= PXA_MBUS_ORDER_LE,\n\t\t.layout\t\t\t= PXA_MBUS_LAYOUT_PLANAR_2Y_U_V,\n\t},\n};\n\n \nstatic bool pxa_camera_packing_supported(const struct pxa_mbus_pixelfmt *fmt)\n{\n\treturn\tfmt->packing == PXA_MBUS_PACKING_NONE ||\n\t\t(fmt->bits_per_sample == 8 &&\n\t\t fmt->packing == PXA_MBUS_PACKING_2X8_PADHI) ||\n\t\t(fmt->bits_per_sample > 8 &&\n\t\t fmt->packing == PXA_MBUS_PACKING_EXTEND16);\n}\n\nstatic int pxa_camera_get_formats(struct v4l2_device *v4l2_dev,\n\t\t\t\t  unsigned int idx,\n\t\t\t\t  struct pxa_camera_format_xlate *xlate)\n{\n\tstruct pxa_camera_dev *pcdev = v4l2_dev_to_pcdev(v4l2_dev);\n\tint formats = 0, ret;\n\tstruct v4l2_subdev_mbus_code_enum code = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.index = idx,\n\t};\n\tconst struct pxa_mbus_pixelfmt *fmt;\n\n\tret = sensor_call(pcdev, pad, enum_mbus_code, NULL, &code);\n\tif (ret < 0)\n\t\t \n\t\treturn 0;\n\n\tfmt = pxa_mbus_get_fmtdesc(code.code);\n\tif (!fmt) {\n\t\tdev_err(pcdev_to_dev(pcdev),\n\t\t\t\"Invalid format code #%u: %d\\n\", idx, code.code);\n\t\treturn 0;\n\t}\n\n\tswitch (code.code) {\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tformats++;\n\t\tif (xlate) {\n\t\t\txlate->host_fmt\t= &pxa_camera_formats[0];\n\t\t\txlate->code\t= code.code;\n\t\t\txlate++;\n\t\t\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t\t\t\"Providing format %s using code %d\\n\",\n\t\t\t\tpxa_camera_formats[0].name, code.code);\n\t\t}\n\t\tfallthrough;\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_LE:\n\tcase MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:\n\t\tif (xlate)\n\t\t\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t\t\t\"Providing format %s packed\\n\",\n\t\t\t\tfmt->name);\n\t\tbreak;\n\tdefault:\n\t\tif (!pxa_camera_packing_supported(fmt))\n\t\t\treturn 0;\n\t\tif (xlate)\n\t\t\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t\t\t\"Providing format %s in pass-through mode\\n\",\n\t\t\t\tfmt->name);\n\t\tbreak;\n\t}\n\n\t \n\tformats++;\n\tif (xlate) {\n\t\txlate->host_fmt\t= fmt;\n\t\txlate->code\t= code.code;\n\t\txlate++;\n\t}\n\n\treturn formats;\n}\n\nstatic int pxa_camera_build_formats(struct pxa_camera_dev *pcdev)\n{\n\tstruct pxa_camera_format_xlate *xlate;\n\n\txlate = pxa_mbus_build_fmts_xlate(&pcdev->v4l2_dev, pcdev->sensor,\n\t\t\t\t\t  pxa_camera_get_formats);\n\tif (IS_ERR(xlate))\n\t\treturn PTR_ERR(xlate);\n\n\tpcdev->user_formats = xlate;\n\treturn 0;\n}\n\nstatic void pxa_camera_destroy_formats(struct pxa_camera_dev *pcdev)\n{\n\tkfree(pcdev->user_formats);\n}\n\nstatic int pxa_camera_check_frame(u32 width, u32 height)\n{\n\t \n\treturn height < 32 || height > 2048 || width < 48 || width > 2048 ||\n\t\t(width & 0x01);\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int pxac_vidioc_g_register(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_dbg_register *reg)\n{\n\tstruct pxa_camera_dev *pcdev = video_drvdata(file);\n\n\tif (reg->reg > CIBR2)\n\t\treturn -ERANGE;\n\n\treg->val = __raw_readl(pcdev->base + reg->reg);\n\treg->size = sizeof(__u32);\n\treturn 0;\n}\n\nstatic int pxac_vidioc_s_register(struct file *file, void *priv,\n\t\t\t\t  const struct v4l2_dbg_register *reg)\n{\n\tstruct pxa_camera_dev *pcdev = video_drvdata(file);\n\n\tif (reg->reg > CIBR2)\n\t\treturn -ERANGE;\n\tif (reg->size != sizeof(__u32))\n\t\treturn -EINVAL;\n\t__raw_writel(reg->val, pcdev->base + reg->reg);\n\treturn 0;\n}\n#endif\n\nstatic int pxac_vidioc_enum_fmt_vid_cap(struct file *filp, void  *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tstruct pxa_camera_dev *pcdev = video_drvdata(filp);\n\tconst struct pxa_mbus_pixelfmt *format;\n\tunsigned int idx;\n\n\tfor (idx = 0; pcdev->user_formats[idx].code; idx++);\n\tif (f->index >= idx)\n\t\treturn -EINVAL;\n\n\tformat = pcdev->user_formats[f->index].host_fmt;\n\tf->pixelformat = format->fourcc;\n\treturn 0;\n}\n\nstatic int pxac_vidioc_g_fmt_vid_cap(struct file *filp, void *priv,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct pxa_camera_dev *pcdev = video_drvdata(filp);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\n\tpix->width\t\t= pcdev->current_pix.width;\n\tpix->height\t\t= pcdev->current_pix.height;\n\tpix->bytesperline\t= pcdev->current_pix.bytesperline;\n\tpix->sizeimage\t\t= pcdev->current_pix.sizeimage;\n\tpix->field\t\t= pcdev->current_pix.field;\n\tpix->pixelformat\t= pcdev->current_fmt->host_fmt->fourcc;\n\tpix->colorspace\t\t= pcdev->current_pix.colorspace;\n\tdev_dbg(pcdev_to_dev(pcdev), \"current_fmt->fourcc: 0x%08x\\n\",\n\t\tpcdev->current_fmt->host_fmt->fourcc);\n\treturn 0;\n}\n\nstatic int pxac_vidioc_try_fmt_vid_cap(struct file *filp, void *priv,\n\t\t\t\t      struct v4l2_format *f)\n{\n\tstruct pxa_camera_dev *pcdev = video_drvdata(filp);\n\tconst struct pxa_camera_format_xlate *xlate;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct v4l2_subdev_pad_config pad_cfg;\n\tstruct v4l2_subdev_state pad_state = {\n\t\t.pads = &pad_cfg,\n\t};\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tstruct v4l2_mbus_framefmt *mf = &format.format;\n\t__u32 pixfmt = pix->pixelformat;\n\tint ret;\n\n\txlate = pxa_mbus_xlate_by_fourcc(pcdev->user_formats, pixfmt);\n\tif (!xlate) {\n\t\tdev_warn(pcdev_to_dev(pcdev), \"Format %x not found\\n\", pixfmt);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tv4l_bound_align_image(&pix->width, 48, 2048, 1,\n\t\t\t      &pix->height, 32, 2048, 0,\n\t\t\t      pixfmt == V4L2_PIX_FMT_YUV422P ? 4 : 0);\n\n\tv4l2_fill_mbus_format(mf, pix, xlate->code);\n\tret = sensor_call(pcdev, pad, set_fmt, &pad_state, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_fill_pix_format(pix, mf);\n\n\t \n\tswitch (mf->field) {\n\tcase V4L2_FIELD_ANY:\n\tcase V4L2_FIELD_NONE:\n\t\tpix->field = V4L2_FIELD_NONE;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(pcdev_to_dev(pcdev), \"Field type %d unsupported.\\n\",\n\t\t\tmf->field);\n\t\treturn -EINVAL;\n\t}\n\n\tret = pxa_mbus_bytes_per_line(pix->width, xlate->host_fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpix->bytesperline = ret;\n\tret = pxa_mbus_image_size(xlate->host_fmt, pix->bytesperline,\n\t\t\t\t  pix->height);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpix->sizeimage = ret;\n\treturn 0;\n}\n\nstatic int pxac_vidioc_s_fmt_vid_cap(struct file *filp, void *priv,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct pxa_camera_dev *pcdev = video_drvdata(filp);\n\tconst struct pxa_camera_format_xlate *xlate;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tunsigned long flags;\n\tint ret, is_busy;\n\n\tdev_dbg(pcdev_to_dev(pcdev),\n\t\t\"s_fmt_vid_cap(pix=%dx%d:%x)\\n\",\n\t\tpix->width, pix->height, pix->pixelformat);\n\n\tspin_lock_irqsave(&pcdev->lock, flags);\n\tis_busy = pcdev->active || vb2_is_busy(&pcdev->vb2_vq);\n\tspin_unlock_irqrestore(&pcdev->lock, flags);\n\n\tif (is_busy)\n\t\treturn -EBUSY;\n\n\tret = pxac_vidioc_try_fmt_vid_cap(filp, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\txlate = pxa_mbus_xlate_by_fourcc(pcdev->user_formats,\n\t\t\t\t\t pix->pixelformat);\n\tv4l2_fill_mbus_format(&format.format, pix, xlate->code);\n\tret = sensor_call(pcdev, pad, set_fmt, NULL, &format);\n\tif (ret < 0) {\n\t\tdev_warn(pcdev_to_dev(pcdev),\n\t\t\t \"Failed to configure for format %x\\n\",\n\t\t\t pix->pixelformat);\n\t} else if (pxa_camera_check_frame(pix->width, pix->height)) {\n\t\tdev_warn(pcdev_to_dev(pcdev),\n\t\t\t \"Camera driver produced an unsupported frame %dx%d\\n\",\n\t\t\t pix->width, pix->height);\n\t\treturn -EINVAL;\n\t}\n\n\tpcdev->current_fmt = xlate;\n\tpcdev->current_pix = *pix;\n\n\tret = pxa_camera_set_bus_param(pcdev);\n\treturn ret;\n}\n\nstatic int pxac_vidioc_querycap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstrscpy(cap->bus_info, \"platform:pxa-camera\", sizeof(cap->bus_info));\n\tstrscpy(cap->driver, PXA_CAM_DRV_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, pxa_cam_driver_description, sizeof(cap->card));\n\treturn 0;\n}\n\nstatic int pxac_vidioc_enum_input(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_input *i)\n{\n\tif (i->index > 0)\n\t\treturn -EINVAL;\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\tstrscpy(i->name, \"Camera\", sizeof(i->name));\n\n\treturn 0;\n}\n\nstatic int pxac_vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\n\treturn 0;\n}\n\nstatic int pxac_vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tif (i > 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int pxac_sensor_set_power(struct pxa_camera_dev *pcdev, int on)\n{\n\tint ret;\n\n\tret = sensor_call(pcdev, core, s_power, on);\n\tif (ret == -ENOIOCTLCMD)\n\t\tret = 0;\n\tif (ret) {\n\t\tdev_warn(pcdev_to_dev(pcdev),\n\t\t\t \"Failed to put subdevice in %s mode: %d\\n\",\n\t\t\t on ? \"normal operation\" : \"power saving\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int pxac_fops_camera_open(struct file *filp)\n{\n\tstruct pxa_camera_dev *pcdev = video_drvdata(filp);\n\tint ret;\n\n\tmutex_lock(&pcdev->mlock);\n\tret = v4l2_fh_open(filp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!v4l2_fh_is_singular_file(filp))\n\t\tgoto out;\n\n\tret = pxac_sensor_set_power(pcdev, 1);\n\tif (ret)\n\t\tv4l2_fh_release(filp);\nout:\n\tmutex_unlock(&pcdev->mlock);\n\treturn ret;\n}\n\nstatic int pxac_fops_camera_release(struct file *filp)\n{\n\tstruct pxa_camera_dev *pcdev = video_drvdata(filp);\n\tint ret;\n\tbool fh_singular;\n\n\tmutex_lock(&pcdev->mlock);\n\n\tfh_singular = v4l2_fh_is_singular_file(filp);\n\n\tret = _vb2_fop_release(filp, NULL);\n\n\tif (fh_singular)\n\t\tret = pxac_sensor_set_power(pcdev, 0);\n\n\tmutex_unlock(&pcdev->mlock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_file_operations pxa_camera_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= pxac_fops_camera_open,\n\t.release\t= pxac_fops_camera_release,\n\t.read\t\t= vb2_fop_read,\n\t.poll\t\t= vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops pxa_camera_ioctl_ops = {\n\t.vidioc_querycap\t\t= pxac_vidioc_querycap,\n\n\t.vidioc_enum_input\t\t= pxac_vidioc_enum_input,\n\t.vidioc_g_input\t\t\t= pxac_vidioc_g_input,\n\t.vidioc_s_input\t\t\t= pxac_vidioc_s_input,\n\n\t.vidioc_enum_fmt_vid_cap\t= pxac_vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= pxac_vidioc_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= pxac_vidioc_s_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= pxac_vidioc_try_fmt_vid_cap,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register\t\t= pxac_vidioc_g_register,\n\t.vidioc_s_register\t\t= pxac_vidioc_s_register,\n#endif\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nstatic const struct video_device pxa_camera_videodev_template = {\n\t.name = \"pxa-camera\",\n\t.minor = -1,\n\t.fops = &pxa_camera_fops,\n\t.ioctl_ops = &pxa_camera_ioctl_ops,\n\t.release = video_device_release_empty,\n\t.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING,\n};\n\nstatic int pxa_camera_sensor_bound(struct v4l2_async_notifier *notifier,\n\t\t     struct v4l2_subdev *subdev,\n\t\t     struct v4l2_async_connection *asd)\n{\n\tint err;\n\tstruct v4l2_device *v4l2_dev = notifier->v4l2_dev;\n\tstruct pxa_camera_dev *pcdev = v4l2_dev_to_pcdev(v4l2_dev);\n\tstruct video_device *vdev = &pcdev->vdev;\n\tstruct v4l2_pix_format *pix = &pcdev->current_pix;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_mbus_framefmt *mf = &format.format;\n\n\tdev_info(pcdev_to_dev(pcdev), \"%s(): trying to bind a device\\n\",\n\t\t __func__);\n\tmutex_lock(&pcdev->mlock);\n\t*vdev = pxa_camera_videodev_template;\n\tvdev->v4l2_dev = v4l2_dev;\n\tvdev->lock = &pcdev->mlock;\n\tpcdev->sensor = subdev;\n\tpcdev->vdev.queue = &pcdev->vb2_vq;\n\tpcdev->vdev.v4l2_dev = &pcdev->v4l2_dev;\n\tpcdev->vdev.ctrl_handler = subdev->ctrl_handler;\n\tvideo_set_drvdata(&pcdev->vdev, pcdev);\n\n\terr = pxa_camera_build_formats(pcdev);\n\tif (err) {\n\t\tdev_err(pcdev_to_dev(pcdev), \"building formats failed: %d\\n\",\n\t\t\terr);\n\t\tgoto out;\n\t}\n\n\tpcdev->current_fmt = pcdev->user_formats;\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->width = DEFAULT_WIDTH;\n\tpix->height = DEFAULT_HEIGHT;\n\tpix->bytesperline =\n\t\tpxa_mbus_bytes_per_line(pix->width,\n\t\t\t\t\tpcdev->current_fmt->host_fmt);\n\tpix->sizeimage =\n\t\tpxa_mbus_image_size(pcdev->current_fmt->host_fmt,\n\t\t\t\t    pix->bytesperline, pix->height);\n\tpix->pixelformat = pcdev->current_fmt->host_fmt->fourcc;\n\tv4l2_fill_mbus_format(mf, pix, pcdev->current_fmt->code);\n\n\terr = pxac_sensor_set_power(pcdev, 1);\n\tif (err)\n\t\tgoto out;\n\n\terr = sensor_call(pcdev, pad, set_fmt, NULL, &format);\n\tif (err)\n\t\tgoto out_sensor_poweroff;\n\n\tv4l2_fill_pix_format(pix, mf);\n\tpr_info(\"%s(): colorspace=0x%x pixfmt=0x%x\\n\",\n\t\t__func__, pix->colorspace, pix->pixelformat);\n\n\terr = pxa_camera_init_videobuf2(pcdev);\n\tif (err)\n\t\tgoto out_sensor_poweroff;\n\n\terr = video_register_device(&pcdev->vdev, VFL_TYPE_VIDEO, -1);\n\tif (err) {\n\t\tv4l2_err(v4l2_dev, \"register video device failed: %d\\n\", err);\n\t\tpcdev->sensor = NULL;\n\t} else {\n\t\tdev_info(pcdev_to_dev(pcdev),\n\t\t\t \"PXA Camera driver attached to camera %s\\n\",\n\t\t\t subdev->name);\n\t}\n\nout_sensor_poweroff:\n\terr = pxac_sensor_set_power(pcdev, 0);\nout:\n\tmutex_unlock(&pcdev->mlock);\n\treturn err;\n}\n\nstatic void pxa_camera_sensor_unbind(struct v4l2_async_notifier *notifier,\n\t\t     struct v4l2_subdev *subdev,\n\t\t     struct v4l2_async_connection *asd)\n{\n\tstruct pxa_camera_dev *pcdev = v4l2_dev_to_pcdev(notifier->v4l2_dev);\n\n\tmutex_lock(&pcdev->mlock);\n\tdev_info(pcdev_to_dev(pcdev),\n\t\t \"PXA Camera driver detached from camera %s\\n\",\n\t\t subdev->name);\n\n\t \n\t__raw_writel(0x3ff, pcdev->base + CICR0);\n\n\t \n\tpxa_dma_stop_channels(pcdev);\n\n\tpxa_camera_destroy_formats(pcdev);\n\n\tvideo_unregister_device(&pcdev->vdev);\n\tpcdev->sensor = NULL;\n\n\tmutex_unlock(&pcdev->mlock);\n}\n\nstatic const struct v4l2_async_notifier_operations pxa_camera_sensor_ops = {\n\t.bound = pxa_camera_sensor_bound,\n\t.unbind = pxa_camera_sensor_unbind,\n};\n\n \nstatic int pxa_camera_suspend(struct device *dev)\n{\n\tstruct pxa_camera_dev *pcdev = dev_get_drvdata(dev);\n\tint i = 0, ret = 0;\n\n\tpcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR0);\n\tpcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR1);\n\tpcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR2);\n\tpcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR3);\n\tpcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR4);\n\n\tif (pcdev->sensor)\n\t\tret = pxac_sensor_set_power(pcdev, 0);\n\n\treturn ret;\n}\n\nstatic int pxa_camera_resume(struct device *dev)\n{\n\tstruct pxa_camera_dev *pcdev = dev_get_drvdata(dev);\n\tint i = 0, ret = 0;\n\n\t__raw_writel(pcdev->save_cicr[i++] & ~CICR0_ENB, pcdev->base + CICR0);\n\t__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR1);\n\t__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR2);\n\t__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR3);\n\t__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR4);\n\n\tif (pcdev->sensor) {\n\t\tret = pxac_sensor_set_power(pcdev, 1);\n\t}\n\n\t \n\tif (!ret && pcdev->active)\n\t\tpxa_camera_start_capture(pcdev);\n\n\treturn ret;\n}\n\nstatic int pxa_camera_pdata_from_dt(struct device *dev,\n\t\t\t\t    struct pxa_camera_dev *pcdev)\n{\n\tu32 mclk_rate;\n\tstruct v4l2_async_connection *asd;\n\tstruct device_node *np = dev->of_node;\n\tstruct v4l2_fwnode_endpoint ep = { .bus_type = 0 };\n\tint err = of_property_read_u32(np, \"clock-frequency\",\n\t\t\t\t       &mclk_rate);\n\tif (!err) {\n\t\tpcdev->platform_flags |= PXA_CAMERA_MCLK_EN;\n\t\tpcdev->mclk = mclk_rate;\n\t}\n\n\tnp = of_graph_get_next_endpoint(np, NULL);\n\tif (!np) {\n\t\tdev_err(dev, \"could not find endpoint\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = v4l2_fwnode_endpoint_parse(of_fwnode_handle(np), &ep);\n\tif (err) {\n\t\tdev_err(dev, \"could not parse endpoint\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch (ep.bus.parallel.bus_width) {\n\tcase 4:\n\t\tpcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_4;\n\t\tbreak;\n\tcase 5:\n\t\tpcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_5;\n\t\tbreak;\n\tcase 8:\n\t\tpcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_8;\n\t\tbreak;\n\tcase 9:\n\t\tpcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_9;\n\t\tbreak;\n\tcase 10:\n\t\tpcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_10;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ep.bus.parallel.flags & V4L2_MBUS_MASTER)\n\t\tpcdev->platform_flags |= PXA_CAMERA_MASTER;\n\tif (ep.bus.parallel.flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\n\t\tpcdev->platform_flags |= PXA_CAMERA_HSP;\n\tif (ep.bus.parallel.flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\n\t\tpcdev->platform_flags |= PXA_CAMERA_VSP;\n\tif (ep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\n\t\tpcdev->platform_flags |= PXA_CAMERA_PCLK_EN | PXA_CAMERA_PCP;\n\tif (ep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\n\t\tpcdev->platform_flags |= PXA_CAMERA_PCLK_EN;\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&pcdev->notifier,\n\t\t\t\t\t      of_fwnode_handle(np),\n\t\t\t\t\t      struct v4l2_async_connection);\n\tif (IS_ERR(asd))\n\t\terr = PTR_ERR(asd);\nout:\n\tof_node_put(np);\n\n\treturn err;\n}\n\nstatic int pxa_camera_probe(struct platform_device *pdev)\n{\n\tstruct pxa_camera_dev *pcdev;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tstruct dma_slave_config config = {\n\t\t.src_addr_width = 0,\n\t\t.src_maxburst = 8,\n\t\t.direction = DMA_DEV_TO_MEM,\n\t};\n\tint irq;\n\tint err = 0, i;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -ENODEV;\n\n\tpcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);\n\tif (!pcdev) {\n\t\tdev_err(&pdev->dev, \"Could not allocate pcdev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpcdev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(pcdev->clk))\n\t\treturn PTR_ERR(pcdev->clk);\n\n\t \n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpcdev->irq = irq;\n\tpcdev->base = base;\n\n\terr = v4l2_device_register(&pdev->dev, &pcdev->v4l2_dev);\n\tif (err)\n\t\treturn err;\n\n\tv4l2_async_nf_init(&pcdev->notifier, &pcdev->v4l2_dev);\n\tpcdev->res = res;\n\tpcdev->pdata = pdev->dev.platform_data;\n\tif (pcdev->pdata) {\n\t\tstruct v4l2_async_connection *asd;\n\n\t\tpcdev->platform_flags = pcdev->pdata->flags;\n\t\tpcdev->mclk = pcdev->pdata->mclk_10khz * 10000;\n\t\tasd = v4l2_async_nf_add_i2c(&pcdev->notifier,\n\t\t\t\t\t    pcdev->pdata->sensor_i2c_adapter_id,\n\t\t\t\t\t    pcdev->pdata->sensor_i2c_address,\n\t\t\t\t\t    struct v4l2_async_connection);\n\t\tif (IS_ERR(asd))\n\t\t\terr = PTR_ERR(asd);\n\t} else if (pdev->dev.of_node) {\n\t\terr = pxa_camera_pdata_from_dt(&pdev->dev, pcdev);\n\t} else {\n\t\terr = -ENODEV;\n\t}\n\tif (err < 0)\n\t\tgoto exit_v4l2_device_unregister;\n\n\tif (!(pcdev->platform_flags & (PXA_CAMERA_DATAWIDTH_8 |\n\t\t\tPXA_CAMERA_DATAWIDTH_9 | PXA_CAMERA_DATAWIDTH_10))) {\n\t\t \n\t\tdev_warn(&pdev->dev, \"WARNING! Platform hasn't set available data widths, using default 10 bit\\n\");\n\t\tpcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_10;\n\t}\n\tif (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_8)\n\t\tpcdev->width_flags = 1 << 7;\n\tif (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_9)\n\t\tpcdev->width_flags |= 1 << 8;\n\tif (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_10)\n\t\tpcdev->width_flags |= 1 << 9;\n\tif (!pcdev->mclk) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"mclk == 0! Please, fix your platform data. Using default 20MHz\\n\");\n\t\tpcdev->mclk = 20000000;\n\t}\n\n\tpcdev->mclk_divisor = mclk_get_divisor(pdev, pcdev);\n\n\tINIT_LIST_HEAD(&pcdev->capture);\n\tspin_lock_init(&pcdev->lock);\n\tmutex_init(&pcdev->mlock);\n\n\t \n\tpcdev->dma_chans[0] = dma_request_chan(&pdev->dev, \"CI_Y\");\n\tif (IS_ERR(pcdev->dma_chans[0])) {\n\t\tdev_err(&pdev->dev, \"Can't request DMA for Y\\n\");\n\t\terr = PTR_ERR(pcdev->dma_chans[0]);\n\t\tgoto exit_notifier_cleanup;\n\t}\n\n\tpcdev->dma_chans[1] = dma_request_chan(&pdev->dev, \"CI_U\");\n\tif (IS_ERR(pcdev->dma_chans[1])) {\n\t\tdev_err(&pdev->dev, \"Can't request DMA for U\\n\");\n\t\terr = PTR_ERR(pcdev->dma_chans[1]);\n\t\tgoto exit_free_dma_y;\n\t}\n\n\tpcdev->dma_chans[2] = dma_request_chan(&pdev->dev, \"CI_V\");\n\tif (IS_ERR(pcdev->dma_chans[2])) {\n\t\tdev_err(&pdev->dev, \"Can't request DMA for V\\n\");\n\t\terr = PTR_ERR(pcdev->dma_chans[2]);\n\t\tgoto exit_free_dma_u;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tconfig.src_addr = pcdev->res->start + CIBR0 + i * 8;\n\t\terr = dmaengine_slave_config(pcdev->dma_chans[i], &config);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev, \"dma slave config failed: %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto exit_free_dma;\n\t\t}\n\t}\n\n\ttasklet_setup(&pcdev->task_eof, pxa_camera_eof);\n\n\tpxa_camera_activate(pcdev);\n\n\tplatform_set_drvdata(pdev, pcdev);\n\n\terr = pxa_camera_init_videobuf2(pcdev);\n\tif (err)\n\t\tgoto exit_deactivate;\n\n\t \n\terr = devm_request_irq(&pdev->dev, pcdev->irq, pxa_camera_irq, 0,\n\t\t\t       PXA_CAM_DRV_NAME, pcdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Camera interrupt register failed\\n\");\n\t\tgoto exit_deactivate;\n\t}\n\n\tpcdev->notifier.ops = &pxa_camera_sensor_ops;\n\terr = v4l2_async_nf_register(&pcdev->notifier);\n\tif (err)\n\t\tgoto exit_deactivate;\n\n\treturn 0;\nexit_deactivate:\n\tpxa_camera_deactivate(pcdev);\n\ttasklet_kill(&pcdev->task_eof);\nexit_free_dma:\n\tdma_release_channel(pcdev->dma_chans[2]);\nexit_free_dma_u:\n\tdma_release_channel(pcdev->dma_chans[1]);\nexit_free_dma_y:\n\tdma_release_channel(pcdev->dma_chans[0]);\nexit_notifier_cleanup:\n\tv4l2_async_nf_cleanup(&pcdev->notifier);\nexit_v4l2_device_unregister:\n\tv4l2_device_unregister(&pcdev->v4l2_dev);\n\treturn err;\n}\n\nstatic void pxa_camera_remove(struct platform_device *pdev)\n{\n\tstruct pxa_camera_dev *pcdev = platform_get_drvdata(pdev);\n\n\tpxa_camera_deactivate(pcdev);\n\ttasklet_kill(&pcdev->task_eof);\n\tdma_release_channel(pcdev->dma_chans[0]);\n\tdma_release_channel(pcdev->dma_chans[1]);\n\tdma_release_channel(pcdev->dma_chans[2]);\n\n\tv4l2_async_nf_unregister(&pcdev->notifier);\n\tv4l2_async_nf_cleanup(&pcdev->notifier);\n\n\tv4l2_device_unregister(&pcdev->v4l2_dev);\n\n\tdev_info(&pdev->dev, \"PXA Camera driver unloaded\\n\");\n}\n\nstatic const struct dev_pm_ops pxa_camera_pm = {\n\t.suspend\t= pxa_camera_suspend,\n\t.resume\t\t= pxa_camera_resume,\n};\n\nstatic const struct of_device_id pxa_camera_of_match[] = {\n\t{ .compatible = \"marvell,pxa270-qci\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pxa_camera_of_match);\n\nstatic struct platform_driver pxa_camera_driver = {\n\t.driver\t\t= {\n\t\t.name\t= PXA_CAM_DRV_NAME,\n\t\t.pm\t= &pxa_camera_pm,\n\t\t.of_match_table = pxa_camera_of_match,\n\t},\n\t.probe\t\t= pxa_camera_probe,\n\t.remove_new\t= pxa_camera_remove,\n};\n\nmodule_platform_driver(pxa_camera_driver);\n\nMODULE_DESCRIPTION(\"PXA27x Camera Driver\");\nMODULE_AUTHOR(\"Guennadi Liakhovetski <kernel@pengutronix.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(PXA_CAM_VERSION);\nMODULE_ALIAS(\"platform:\" PXA_CAM_DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}