{
  "module_name": "cdns-csi2rx.c",
  "hash_id": "f72527db707155685f69252881759773bad612ab4352363f348c8547fbfa992d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/cadence/cdns-csi2rx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define CSI2RX_DEVICE_CFG_REG\t\t\t0x000\n\n#define CSI2RX_SOFT_RESET_REG\t\t\t0x004\n#define CSI2RX_SOFT_RESET_PROTOCOL\t\t\tBIT(1)\n#define CSI2RX_SOFT_RESET_FRONT\t\t\t\tBIT(0)\n\n#define CSI2RX_STATIC_CFG_REG\t\t\t0x008\n#define CSI2RX_STATIC_CFG_DLANE_MAP(llane, plane)\t((plane) << (16 + (llane) * 4))\n#define CSI2RX_STATIC_CFG_LANES_MASK\t\t\tGENMASK(11, 8)\n\n#define CSI2RX_DPHY_LANE_CTRL_REG\t\t0x40\n#define CSI2RX_DPHY_CL_RST\t\t\tBIT(16)\n#define CSI2RX_DPHY_DL_RST(i)\t\t\tBIT((i) + 12)\n#define CSI2RX_DPHY_CL_EN\t\t\tBIT(4)\n#define CSI2RX_DPHY_DL_EN(i)\t\t\tBIT(i)\n\n#define CSI2RX_STREAM_BASE(n)\t\t(((n) + 1) * 0x100)\n\n#define CSI2RX_STREAM_CTRL_REG(n)\t\t(CSI2RX_STREAM_BASE(n) + 0x000)\n#define CSI2RX_STREAM_CTRL_START\t\t\tBIT(0)\n\n#define CSI2RX_STREAM_DATA_CFG_REG(n)\t\t(CSI2RX_STREAM_BASE(n) + 0x008)\n#define CSI2RX_STREAM_DATA_CFG_EN_VC_SELECT\t\tBIT(31)\n#define CSI2RX_STREAM_DATA_CFG_VC_SELECT(n)\t\tBIT((n) + 16)\n\n#define CSI2RX_STREAM_CFG_REG(n)\t\t(CSI2RX_STREAM_BASE(n) + 0x00c)\n#define CSI2RX_STREAM_CFG_FIFO_MODE_LARGE_BUF\t\t(1 << 8)\n\n#define CSI2RX_LANES_MAX\t4\n#define CSI2RX_STREAMS_MAX\t4\n\nenum csi2rx_pads {\n\tCSI2RX_PAD_SINK,\n\tCSI2RX_PAD_SOURCE_STREAM0,\n\tCSI2RX_PAD_SOURCE_STREAM1,\n\tCSI2RX_PAD_SOURCE_STREAM2,\n\tCSI2RX_PAD_SOURCE_STREAM3,\n\tCSI2RX_PAD_MAX,\n};\n\nstruct csi2rx_priv {\n\tstruct device\t\t\t*dev;\n\tunsigned int\t\t\tcount;\n\n\t \n\tstruct mutex\t\t\tlock;\n\n\tvoid __iomem\t\t\t*base;\n\tstruct clk\t\t\t*sys_clk;\n\tstruct clk\t\t\t*p_clk;\n\tstruct clk\t\t\t*pixel_clk[CSI2RX_STREAMS_MAX];\n\tstruct reset_control\t\t*sys_rst;\n\tstruct reset_control\t\t*p_rst;\n\tstruct reset_control\t\t*pixel_rst[CSI2RX_STREAMS_MAX];\n\tstruct phy\t\t\t*dphy;\n\n\tu8\t\t\t\tlanes[CSI2RX_LANES_MAX];\n\tu8\t\t\t\tnum_lanes;\n\tu8\t\t\t\tmax_lanes;\n\tu8\t\t\t\tmax_streams;\n\tbool\t\t\t\thas_internal_dphy;\n\n\tstruct v4l2_subdev\t\tsubdev;\n\tstruct v4l2_async_notifier\tnotifier;\n\tstruct media_pad\t\tpads[CSI2RX_PAD_MAX];\n\n\t \n\tstruct v4l2_subdev\t\t*source_subdev;\n\tint\t\t\t\tsource_pad;\n};\n\nstatic inline\nstruct csi2rx_priv *v4l2_subdev_to_csi2rx(struct v4l2_subdev *subdev)\n{\n\treturn container_of(subdev, struct csi2rx_priv, subdev);\n}\n\nstatic void csi2rx_reset(struct csi2rx_priv *csi2rx)\n{\n\twritel(CSI2RX_SOFT_RESET_PROTOCOL | CSI2RX_SOFT_RESET_FRONT,\n\t       csi2rx->base + CSI2RX_SOFT_RESET_REG);\n\n\tudelay(10);\n\n\twritel(0, csi2rx->base + CSI2RX_SOFT_RESET_REG);\n}\n\nstatic int csi2rx_configure_ext_dphy(struct csi2rx_priv *csi2rx)\n{\n\tunion phy_configure_opts opts = { };\n\tint ret;\n\n\tret = phy_power_on(csi2rx->dphy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_configure(csi2rx->dphy, &opts);\n\tif (ret) {\n\t\tphy_power_off(csi2rx->dphy);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int csi2rx_start(struct csi2rx_priv *csi2rx)\n{\n\tunsigned int i;\n\tunsigned long lanes_used = 0;\n\tu32 reg;\n\tint ret;\n\n\tret = clk_prepare_enable(csi2rx->p_clk);\n\tif (ret)\n\t\treturn ret;\n\n\treset_control_deassert(csi2rx->p_rst);\n\tcsi2rx_reset(csi2rx);\n\n\treg = csi2rx->num_lanes << 8;\n\tfor (i = 0; i < csi2rx->num_lanes; i++) {\n\t\treg |= CSI2RX_STATIC_CFG_DLANE_MAP(i, csi2rx->lanes[i]);\n\t\tset_bit(csi2rx->lanes[i], &lanes_used);\n\t}\n\n\t \n\tfor (i = csi2rx->num_lanes; i < csi2rx->max_lanes; i++) {\n\t\tunsigned int idx = find_first_zero_bit(&lanes_used,\n\t\t\t\t\t\t       csi2rx->max_lanes);\n\t\tset_bit(idx, &lanes_used);\n\t\treg |= CSI2RX_STATIC_CFG_DLANE_MAP(i, i + 1);\n\t}\n\n\twritel(reg, csi2rx->base + CSI2RX_STATIC_CFG_REG);\n\n\tret = v4l2_subdev_call(csi2rx->source_subdev, video, s_stream, true);\n\tif (ret)\n\t\tgoto err_disable_pclk;\n\n\t \n\tif (csi2rx->dphy) {\n\t\treg = CSI2RX_DPHY_CL_EN | CSI2RX_DPHY_CL_RST;\n\t\tfor (i = 0; i < csi2rx->num_lanes; i++) {\n\t\t\treg |= CSI2RX_DPHY_DL_EN(csi2rx->lanes[i] - 1);\n\t\t\treg |= CSI2RX_DPHY_DL_RST(csi2rx->lanes[i] - 1);\n\t\t}\n\n\t\twritel(reg, csi2rx->base + CSI2RX_DPHY_LANE_CTRL_REG);\n\t}\n\n\t \n\tfor (i = 0; i < csi2rx->max_streams; i++) {\n\t\tret = clk_prepare_enable(csi2rx->pixel_clk[i]);\n\t\tif (ret)\n\t\t\tgoto err_disable_pixclk;\n\n\t\treset_control_deassert(csi2rx->pixel_rst[i]);\n\n\t\twritel(CSI2RX_STREAM_CFG_FIFO_MODE_LARGE_BUF,\n\t\t       csi2rx->base + CSI2RX_STREAM_CFG_REG(i));\n\n\t\twritel(CSI2RX_STREAM_DATA_CFG_EN_VC_SELECT |\n\t\t       CSI2RX_STREAM_DATA_CFG_VC_SELECT(i),\n\t\t       csi2rx->base + CSI2RX_STREAM_DATA_CFG_REG(i));\n\n\t\twritel(CSI2RX_STREAM_CTRL_START,\n\t\t       csi2rx->base + CSI2RX_STREAM_CTRL_REG(i));\n\t}\n\n\tret = clk_prepare_enable(csi2rx->sys_clk);\n\tif (ret)\n\t\tgoto err_disable_pixclk;\n\n\treset_control_deassert(csi2rx->sys_rst);\n\n\tif (csi2rx->dphy) {\n\t\tret = csi2rx_configure_ext_dphy(csi2rx);\n\t\tif (ret) {\n\t\t\tdev_err(csi2rx->dev,\n\t\t\t\t\"Failed to configure external DPHY: %d\\n\", ret);\n\t\t\tgoto err_disable_sysclk;\n\t\t}\n\t}\n\n\tclk_disable_unprepare(csi2rx->p_clk);\n\n\treturn 0;\n\nerr_disable_sysclk:\n\tclk_disable_unprepare(csi2rx->sys_clk);\nerr_disable_pixclk:\n\tfor (; i > 0; i--) {\n\t\treset_control_assert(csi2rx->pixel_rst[i - 1]);\n\t\tclk_disable_unprepare(csi2rx->pixel_clk[i - 1]);\n\t}\n\nerr_disable_pclk:\n\tclk_disable_unprepare(csi2rx->p_clk);\n\n\treturn ret;\n}\n\nstatic void csi2rx_stop(struct csi2rx_priv *csi2rx)\n{\n\tunsigned int i;\n\n\tclk_prepare_enable(csi2rx->p_clk);\n\treset_control_assert(csi2rx->sys_rst);\n\tclk_disable_unprepare(csi2rx->sys_clk);\n\n\tfor (i = 0; i < csi2rx->max_streams; i++) {\n\t\twritel(0, csi2rx->base + CSI2RX_STREAM_CTRL_REG(i));\n\n\t\treset_control_assert(csi2rx->pixel_rst[i]);\n\t\tclk_disable_unprepare(csi2rx->pixel_clk[i]);\n\t}\n\n\treset_control_assert(csi2rx->p_rst);\n\tclk_disable_unprepare(csi2rx->p_clk);\n\n\tif (v4l2_subdev_call(csi2rx->source_subdev, video, s_stream, false))\n\t\tdev_warn(csi2rx->dev, \"Couldn't disable our subdev\\n\");\n\n\tif (csi2rx->dphy) {\n\t\twritel(0, csi2rx->base + CSI2RX_DPHY_LANE_CTRL_REG);\n\n\t\tif (phy_power_off(csi2rx->dphy))\n\t\t\tdev_warn(csi2rx->dev, \"Couldn't power off DPHY\\n\");\n\t}\n}\n\nstatic int csi2rx_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tstruct csi2rx_priv *csi2rx = v4l2_subdev_to_csi2rx(subdev);\n\tint ret = 0;\n\n\tmutex_lock(&csi2rx->lock);\n\n\tif (enable) {\n\t\t \n\t\tif (!csi2rx->count) {\n\t\t\tret = csi2rx_start(csi2rx);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcsi2rx->count++;\n\t} else {\n\t\tcsi2rx->count--;\n\n\t\t \n\t\tif (!csi2rx->count)\n\t\t\tcsi2rx_stop(csi2rx);\n\t}\n\nout:\n\tmutex_unlock(&csi2rx->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops csi2rx_video_ops = {\n\t.s_stream\t= csi2rx_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops csi2rx_subdev_ops = {\n\t.video\t\t= &csi2rx_video_ops,\n};\n\nstatic int csi2rx_async_bound(struct v4l2_async_notifier *notifier,\n\t\t\t      struct v4l2_subdev *s_subdev,\n\t\t\t      struct v4l2_async_connection *asd)\n{\n\tstruct v4l2_subdev *subdev = notifier->sd;\n\tstruct csi2rx_priv *csi2rx = v4l2_subdev_to_csi2rx(subdev);\n\n\tcsi2rx->source_pad = media_entity_get_fwnode_pad(&s_subdev->entity,\n\t\t\t\t\t\t\t s_subdev->fwnode,\n\t\t\t\t\t\t\t MEDIA_PAD_FL_SOURCE);\n\tif (csi2rx->source_pad < 0) {\n\t\tdev_err(csi2rx->dev, \"Couldn't find output pad for subdev %s\\n\",\n\t\t\ts_subdev->name);\n\t\treturn csi2rx->source_pad;\n\t}\n\n\tcsi2rx->source_subdev = s_subdev;\n\n\tdev_dbg(csi2rx->dev, \"Bound %s pad: %d\\n\", s_subdev->name,\n\t\tcsi2rx->source_pad);\n\n\treturn media_create_pad_link(&csi2rx->source_subdev->entity,\n\t\t\t\t     csi2rx->source_pad,\n\t\t\t\t     &csi2rx->subdev.entity, 0,\n\t\t\t\t     MEDIA_LNK_FL_ENABLED |\n\t\t\t\t     MEDIA_LNK_FL_IMMUTABLE);\n}\n\nstatic const struct v4l2_async_notifier_operations csi2rx_notifier_ops = {\n\t.bound\t\t= csi2rx_async_bound,\n};\n\nstatic int csi2rx_get_resources(struct csi2rx_priv *csi2rx,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tunsigned char i;\n\tu32 dev_cfg;\n\tint ret;\n\n\tcsi2rx->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(csi2rx->base))\n\t\treturn PTR_ERR(csi2rx->base);\n\n\tcsi2rx->sys_clk = devm_clk_get(&pdev->dev, \"sys_clk\");\n\tif (IS_ERR(csi2rx->sys_clk)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get sys clock\\n\");\n\t\treturn PTR_ERR(csi2rx->sys_clk);\n\t}\n\n\tcsi2rx->p_clk = devm_clk_get(&pdev->dev, \"p_clk\");\n\tif (IS_ERR(csi2rx->p_clk)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get P clock\\n\");\n\t\treturn PTR_ERR(csi2rx->p_clk);\n\t}\n\n\tcsi2rx->sys_rst = devm_reset_control_get_optional_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t\t    \"sys\");\n\tif (IS_ERR(csi2rx->sys_rst))\n\t\treturn PTR_ERR(csi2rx->sys_rst);\n\n\tcsi2rx->p_rst = devm_reset_control_get_optional_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t\t  \"reg_bank\");\n\tif (IS_ERR(csi2rx->p_rst))\n\t\treturn PTR_ERR(csi2rx->p_rst);\n\n\tcsi2rx->dphy = devm_phy_optional_get(&pdev->dev, \"dphy\");\n\tif (IS_ERR(csi2rx->dphy)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get external D-PHY\\n\");\n\t\treturn PTR_ERR(csi2rx->dphy);\n\t}\n\n\tret = clk_prepare_enable(csi2rx->p_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't prepare and enable P clock\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_cfg = readl(csi2rx->base + CSI2RX_DEVICE_CFG_REG);\n\tclk_disable_unprepare(csi2rx->p_clk);\n\n\tcsi2rx->max_lanes = dev_cfg & 7;\n\tif (csi2rx->max_lanes > CSI2RX_LANES_MAX) {\n\t\tdev_err(&pdev->dev, \"Invalid number of lanes: %u\\n\",\n\t\t\tcsi2rx->max_lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tcsi2rx->max_streams = (dev_cfg >> 4) & 7;\n\tif (csi2rx->max_streams > CSI2RX_STREAMS_MAX) {\n\t\tdev_err(&pdev->dev, \"Invalid number of streams: %u\\n\",\n\t\t\tcsi2rx->max_streams);\n\t\treturn -EINVAL;\n\t}\n\n\tcsi2rx->has_internal_dphy = dev_cfg & BIT(3) ? true : false;\n\n\t \n\tif (!csi2rx->dphy && csi2rx->has_internal_dphy) {\n\t\tdev_err(&pdev->dev, \"Internal D-PHY not supported yet\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < csi2rx->max_streams; i++) {\n\t\tchar name[16];\n\n\t\tsnprintf(name, sizeof(name), \"pixel_if%u_clk\", i);\n\t\tcsi2rx->pixel_clk[i] = devm_clk_get(&pdev->dev, name);\n\t\tif (IS_ERR(csi2rx->pixel_clk[i])) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't get clock %s\\n\", name);\n\t\t\treturn PTR_ERR(csi2rx->pixel_clk[i]);\n\t\t}\n\n\t\tsnprintf(name, sizeof(name), \"pixel_if%u\", i);\n\t\tcsi2rx->pixel_rst[i] =\n\t\t\tdevm_reset_control_get_optional_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t\t  name);\n\t\tif (IS_ERR(csi2rx->pixel_rst[i]))\n\t\t\treturn PTR_ERR(csi2rx->pixel_rst[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int csi2rx_parse_dt(struct csi2rx_priv *csi2rx)\n{\n\tstruct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = 0 };\n\tstruct v4l2_async_connection *asd;\n\tstruct fwnode_handle *fwh;\n\tstruct device_node *ep;\n\tint ret;\n\n\tep = of_graph_get_endpoint_by_regs(csi2rx->dev->of_node, 0, 0);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tfwh = of_fwnode_handle(ep);\n\tret = v4l2_fwnode_endpoint_parse(fwh, &v4l2_ep);\n\tif (ret) {\n\t\tdev_err(csi2rx->dev, \"Could not parse v4l2 endpoint\\n\");\n\t\tof_node_put(ep);\n\t\treturn ret;\n\t}\n\n\tif (v4l2_ep.bus_type != V4L2_MBUS_CSI2_DPHY) {\n\t\tdev_err(csi2rx->dev, \"Unsupported media bus type: 0x%x\\n\",\n\t\t\tv4l2_ep.bus_type);\n\t\tof_node_put(ep);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(csi2rx->lanes, v4l2_ep.bus.mipi_csi2.data_lanes,\n\t       sizeof(csi2rx->lanes));\n\tcsi2rx->num_lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;\n\tif (csi2rx->num_lanes > csi2rx->max_lanes) {\n\t\tdev_err(csi2rx->dev, \"Unsupported number of data-lanes: %d\\n\",\n\t\t\tcsi2rx->num_lanes);\n\t\tof_node_put(ep);\n\t\treturn -EINVAL;\n\t}\n\n\tv4l2_async_subdev_nf_init(&csi2rx->notifier, &csi2rx->subdev);\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&csi2rx->notifier, fwh,\n\t\t\t\t\t      struct v4l2_async_connection);\n\tof_node_put(ep);\n\tif (IS_ERR(asd)) {\n\t\tv4l2_async_nf_cleanup(&csi2rx->notifier);\n\t\treturn PTR_ERR(asd);\n\t}\n\n\tcsi2rx->notifier.ops = &csi2rx_notifier_ops;\n\n\tret = v4l2_async_nf_register(&csi2rx->notifier);\n\tif (ret)\n\t\tv4l2_async_nf_cleanup(&csi2rx->notifier);\n\n\treturn ret;\n}\n\nstatic int csi2rx_probe(struct platform_device *pdev)\n{\n\tstruct csi2rx_priv *csi2rx;\n\tunsigned int i;\n\tint ret;\n\n\tcsi2rx = kzalloc(sizeof(*csi2rx), GFP_KERNEL);\n\tif (!csi2rx)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, csi2rx);\n\tcsi2rx->dev = &pdev->dev;\n\tmutex_init(&csi2rx->lock);\n\n\tret = csi2rx_get_resources(csi2rx, pdev);\n\tif (ret)\n\t\tgoto err_free_priv;\n\n\tret = csi2rx_parse_dt(csi2rx);\n\tif (ret)\n\t\tgoto err_free_priv;\n\n\tcsi2rx->subdev.owner = THIS_MODULE;\n\tcsi2rx->subdev.dev = &pdev->dev;\n\tv4l2_subdev_init(&csi2rx->subdev, &csi2rx_subdev_ops);\n\tv4l2_set_subdevdata(&csi2rx->subdev, &pdev->dev);\n\tsnprintf(csi2rx->subdev.name, V4L2_SUBDEV_NAME_SIZE, \"%s.%s\",\n\t\t KBUILD_MODNAME, dev_name(&pdev->dev));\n\n\t \n\tcsi2rx->subdev.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tcsi2rx->pads[CSI2RX_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tfor (i = CSI2RX_PAD_SOURCE_STREAM0; i < CSI2RX_PAD_MAX; i++)\n\t\tcsi2rx->pads[i].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&csi2rx->subdev.entity, CSI2RX_PAD_MAX,\n\t\t\t\t     csi2rx->pads);\n\tif (ret)\n\t\tgoto err_cleanup;\n\n\tret = v4l2_async_register_subdev(&csi2rx->subdev);\n\tif (ret < 0)\n\t\tgoto err_cleanup;\n\n\tdev_info(&pdev->dev,\n\t\t \"Probed CSI2RX with %u/%u lanes, %u streams, %s D-PHY\\n\",\n\t\t csi2rx->num_lanes, csi2rx->max_lanes, csi2rx->max_streams,\n\t\t csi2rx->dphy ? \"external\" :\n\t\t csi2rx->has_internal_dphy ? \"internal\" : \"no\");\n\n\treturn 0;\n\nerr_cleanup:\n\tv4l2_async_nf_unregister(&csi2rx->notifier);\n\tv4l2_async_nf_cleanup(&csi2rx->notifier);\nerr_free_priv:\n\tkfree(csi2rx);\n\treturn ret;\n}\n\nstatic void csi2rx_remove(struct platform_device *pdev)\n{\n\tstruct csi2rx_priv *csi2rx = platform_get_drvdata(pdev);\n\n\tv4l2_async_nf_unregister(&csi2rx->notifier);\n\tv4l2_async_nf_cleanup(&csi2rx->notifier);\n\tv4l2_async_unregister_subdev(&csi2rx->subdev);\n\tkfree(csi2rx);\n}\n\nstatic const struct of_device_id csi2rx_of_table[] = {\n\t{ .compatible = \"starfive,jh7110-csi2rx\" },\n\t{ .compatible = \"cdns,csi2rx\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, csi2rx_of_table);\n\nstatic struct platform_driver csi2rx_driver = {\n\t.probe\t= csi2rx_probe,\n\t.remove_new = csi2rx_remove,\n\n\t.driver\t= {\n\t\t.name\t\t= \"cdns-csi2rx\",\n\t\t.of_match_table\t= csi2rx_of_table,\n\t},\n};\nmodule_platform_driver(csi2rx_driver);\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@bootlin.com>\");\nMODULE_DESCRIPTION(\"Cadence CSI2-RX controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}