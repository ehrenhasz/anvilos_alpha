{
  "module_name": "cdns-csi2tx.c",
  "hash_id": "371e099439009f909348a44db1ea97cb9b0c25fe667a9c17370a321e1a871574",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/cadence/cdns-csi2tx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <media/mipi-csi2.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#define CSI2TX_DEVICE_CONFIG_REG\t0x00\n#define CSI2TX_DEVICE_CONFIG_STREAMS_MASK\tGENMASK(6, 4)\n#define CSI2TX_DEVICE_CONFIG_HAS_DPHY\t\tBIT(3)\n#define CSI2TX_DEVICE_CONFIG_LANES_MASK\t\tGENMASK(2, 0)\n\n#define CSI2TX_CONFIG_REG\t\t0x20\n#define CSI2TX_CONFIG_CFG_REQ\t\t\tBIT(2)\n#define CSI2TX_CONFIG_SRST_REQ\t\t\tBIT(1)\n\n#define CSI2TX_DPHY_CFG_REG\t\t0x28\n#define CSI2TX_DPHY_CFG_CLK_RESET\t\tBIT(16)\n#define CSI2TX_DPHY_CFG_LANE_RESET(n)\t\tBIT((n) + 12)\n#define CSI2TX_DPHY_CFG_MODE_MASK\t\tGENMASK(9, 8)\n#define CSI2TX_DPHY_CFG_MODE_LPDT\t\t(2 << 8)\n#define CSI2TX_DPHY_CFG_MODE_HS\t\t\t(1 << 8)\n#define CSI2TX_DPHY_CFG_MODE_ULPS\t\t(0 << 8)\n#define CSI2TX_DPHY_CFG_CLK_ENABLE\t\tBIT(4)\n#define CSI2TX_DPHY_CFG_LANE_ENABLE(n)\t\tBIT(n)\n\n#define CSI2TX_DPHY_CLK_WAKEUP_REG\t0x2c\n#define CSI2TX_DPHY_CLK_WAKEUP_ULPS_CYCLES(n)\t((n) & 0xffff)\n\n#define CSI2TX_DT_CFG_REG(n)\t\t(0x80 + (n) * 8)\n#define CSI2TX_DT_CFG_DT(n)\t\t\t(((n) & 0x3f) << 2)\n\n#define CSI2TX_DT_FORMAT_REG(n)\t\t(0x84 + (n) * 8)\n#define CSI2TX_DT_FORMAT_BYTES_PER_LINE(n)\t(((n) & 0xffff) << 16)\n#define CSI2TX_DT_FORMAT_MAX_LINE_NUM(n)\t((n) & 0xffff)\n\n#define CSI2TX_STREAM_IF_CFG_REG(n)\t(0x100 + (n) * 4)\n#define CSI2TX_STREAM_IF_CFG_FILL_LEVEL(n)\t((n) & 0x1f)\n\n \n#define CSI2TX_V2_DPHY_CFG_REG\t\t\t0x28\n#define CSI2TX_V2_DPHY_CFG_RESET\t\tBIT(16)\n#define CSI2TX_V2_DPHY_CFG_CLOCK_MODE\t\tBIT(10)\n#define CSI2TX_V2_DPHY_CFG_MODE_MASK\t\tGENMASK(9, 8)\n#define CSI2TX_V2_DPHY_CFG_MODE_LPDT\t\t(2 << 8)\n#define CSI2TX_V2_DPHY_CFG_MODE_HS\t\t(1 << 8)\n#define CSI2TX_V2_DPHY_CFG_MODE_ULPS\t\t(0 << 8)\n#define CSI2TX_V2_DPHY_CFG_CLK_ENABLE\t\tBIT(4)\n#define CSI2TX_V2_DPHY_CFG_LANE_ENABLE(n)\tBIT(n)\n\n#define CSI2TX_LANES_MAX\t4\n#define CSI2TX_STREAMS_MAX\t4\n\nenum csi2tx_pads {\n\tCSI2TX_PAD_SOURCE,\n\tCSI2TX_PAD_SINK_STREAM0,\n\tCSI2TX_PAD_SINK_STREAM1,\n\tCSI2TX_PAD_SINK_STREAM2,\n\tCSI2TX_PAD_SINK_STREAM3,\n\tCSI2TX_PAD_MAX,\n};\n\nstruct csi2tx_fmt {\n\tu32\tmbus;\n\tu32\tdt;\n\tu32\tbpp;\n};\n\nstruct csi2tx_priv;\n\n \nstruct csi2tx_vops {\n\tvoid (*dphy_setup)(struct csi2tx_priv *csi2tx);\n};\n\nstruct csi2tx_priv {\n\tstruct device\t\t\t*dev;\n\tunsigned int\t\t\tcount;\n\n\t \n\tstruct mutex\t\t\tlock;\n\n\tvoid __iomem\t\t\t*base;\n\n\tstruct csi2tx_vops\t\t*vops;\n\n\tstruct clk\t\t\t*esc_clk;\n\tstruct clk\t\t\t*p_clk;\n\tstruct clk\t\t\t*pixel_clk[CSI2TX_STREAMS_MAX];\n\n\tstruct v4l2_subdev\t\tsubdev;\n\tstruct media_pad\t\tpads[CSI2TX_PAD_MAX];\n\tstruct v4l2_mbus_framefmt\tpad_fmts[CSI2TX_PAD_MAX];\n\n\tbool\t\t\t\thas_internal_dphy;\n\tu8\t\t\t\tlanes[CSI2TX_LANES_MAX];\n\tunsigned int\t\t\tnum_lanes;\n\tunsigned int\t\t\tmax_lanes;\n\tunsigned int\t\t\tmax_streams;\n};\n\nstatic const struct csi2tx_fmt csi2tx_formats[] = {\n\t{\n\t\t.mbus\t= MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.bpp\t= 2,\n\t\t.dt\t= MIPI_CSI2_DT_YUV422_8B,\n\t},\n\t{\n\t\t.mbus\t= MEDIA_BUS_FMT_RGB888_1X24,\n\t\t.bpp\t= 3,\n\t\t.dt\t= MIPI_CSI2_DT_RGB888,\n\t},\n};\n\nstatic const struct v4l2_mbus_framefmt fmt_default = {\n\t.width\t\t= 1280,\n\t.height\t\t= 720,\n\t.code\t\t= MEDIA_BUS_FMT_RGB888_1X24,\n\t.field\t\t= V4L2_FIELD_NONE,\n\t.colorspace\t= V4L2_COLORSPACE_DEFAULT,\n};\n\nstatic inline\nstruct csi2tx_priv *v4l2_subdev_to_csi2tx(struct v4l2_subdev *subdev)\n{\n\treturn container_of(subdev, struct csi2tx_priv, subdev);\n}\n\nstatic const struct csi2tx_fmt *csi2tx_get_fmt_from_mbus(u32 mbus)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(csi2tx_formats); i++)\n\t\tif (csi2tx_formats[i].mbus == mbus)\n\t\t\treturn &csi2tx_formats[i];\n\n\treturn NULL;\n}\n\nstatic int csi2tx_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->pad || code->index >= ARRAY_SIZE(csi2tx_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = csi2tx_formats[code->index].mbus;\n\n\treturn 0;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__csi2tx_get_pad_format(struct v4l2_subdev *subdev,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tstruct v4l2_subdev_format *fmt)\n{\n\tstruct csi2tx_priv *csi2tx = v4l2_subdev_to_csi2tx(subdev);\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(subdev, sd_state,\n\t\t\t\t\t\t  fmt->pad);\n\n\treturn &csi2tx->pad_fmts[fmt->pad];\n}\n\nstatic int csi2tx_get_pad_format(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_format *fmt)\n{\n\tconst struct v4l2_mbus_framefmt *format;\n\n\t \n\tif (fmt->pad == CSI2TX_PAD_SOURCE)\n\t\treturn -EINVAL;\n\n\tformat = __csi2tx_get_pad_format(subdev, sd_state, fmt);\n\tif (!format)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\n\treturn 0;\n}\n\nstatic int csi2tx_set_pad_format(struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_format *fmt)\n{\n\tconst struct v4l2_mbus_framefmt *src_format = &fmt->format;\n\tstruct v4l2_mbus_framefmt *dst_format;\n\n\t \n\tif (fmt->pad == CSI2TX_PAD_SOURCE)\n\t\treturn -EINVAL;\n\n\tif (!csi2tx_get_fmt_from_mbus(fmt->format.code))\n\t\tsrc_format = &fmt_default;\n\n\tdst_format = __csi2tx_get_pad_format(subdev, sd_state, fmt);\n\tif (!dst_format)\n\t\treturn -EINVAL;\n\n\t*dst_format = *src_format;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops csi2tx_pad_ops = {\n\t.enum_mbus_code\t= csi2tx_enum_mbus_code,\n\t.get_fmt\t= csi2tx_get_pad_format,\n\t.set_fmt\t= csi2tx_set_pad_format,\n};\n\n \nstatic void csi2tx_dphy_set_wakeup(struct csi2tx_priv *csi2tx)\n{\n\twritel(CSI2TX_DPHY_CLK_WAKEUP_ULPS_CYCLES(32),\n\t       csi2tx->base + CSI2TX_DPHY_CLK_WAKEUP_REG);\n}\n\n \nstatic void csi2tx_dphy_init_finish(struct csi2tx_priv *csi2tx, u32 reg)\n{\n\tunsigned int i;\n\n\tudelay(10);\n\n\t \n\treg |= CSI2TX_DPHY_CFG_CLK_ENABLE;\n\tfor (i = 0; i < csi2tx->num_lanes; i++)\n\t\treg |= CSI2TX_DPHY_CFG_LANE_ENABLE(csi2tx->lanes[i] - 1);\n\twritel(reg, csi2tx->base + CSI2TX_DPHY_CFG_REG);\n\n\tudelay(10);\n\n\t \n\treg &= ~CSI2TX_DPHY_CFG_MODE_MASK;\n\twritel(reg | CSI2TX_DPHY_CFG_MODE_HS,\n\t       csi2tx->base + CSI2TX_DPHY_CFG_REG);\n}\n\n \nstatic void csi2tx_dphy_setup(struct csi2tx_priv *csi2tx)\n{\n\tu32 reg;\n\tunsigned int i;\n\n\tcsi2tx_dphy_set_wakeup(csi2tx);\n\n\t \n\treg = CSI2TX_DPHY_CFG_CLK_RESET | CSI2TX_DPHY_CFG_MODE_LPDT;\n\tfor (i = 0; i < csi2tx->num_lanes; i++)\n\t\treg |= CSI2TX_DPHY_CFG_LANE_RESET(csi2tx->lanes[i] - 1);\n\twritel(reg, csi2tx->base + CSI2TX_DPHY_CFG_REG);\n\n\tcsi2tx_dphy_init_finish(csi2tx, reg);\n}\n\n \nstatic void csi2tx_v2_dphy_setup(struct csi2tx_priv *csi2tx)\n{\n\tu32 reg;\n\n\tcsi2tx_dphy_set_wakeup(csi2tx);\n\n\t \n\treg = CSI2TX_V2_DPHY_CFG_RESET | CSI2TX_V2_DPHY_CFG_MODE_LPDT;\n\twritel(reg, csi2tx->base + CSI2TX_V2_DPHY_CFG_REG);\n\n\tcsi2tx_dphy_init_finish(csi2tx, reg);\n}\n\nstatic void csi2tx_reset(struct csi2tx_priv *csi2tx)\n{\n\twritel(CSI2TX_CONFIG_SRST_REQ, csi2tx->base + CSI2TX_CONFIG_REG);\n\n\tudelay(10);\n}\n\nstatic int csi2tx_start(struct csi2tx_priv *csi2tx)\n{\n\tstruct media_entity *entity = &csi2tx->subdev.entity;\n\tstruct media_link *link;\n\tunsigned int i;\n\n\tcsi2tx_reset(csi2tx);\n\n\twritel(CSI2TX_CONFIG_CFG_REQ, csi2tx->base + CSI2TX_CONFIG_REG);\n\n\tudelay(10);\n\n\tif (csi2tx->vops && csi2tx->vops->dphy_setup) {\n\t\tcsi2tx->vops->dphy_setup(csi2tx);\n\t\tudelay(10);\n\t}\n\n\t \n\tlist_for_each_entry(link, &entity->links, list) {\n\t\tstruct v4l2_mbus_framefmt *mfmt;\n\t\tconst struct csi2tx_fmt *fmt;\n\t\tunsigned int stream;\n\t\tint pad_idx = -1;\n\n\t\t \n\t\tfor (i = CSI2TX_PAD_SINK_STREAM0; i < CSI2TX_PAD_MAX; i++) {\n\t\t\tstruct media_pad *pad = &csi2tx->pads[i];\n\n\t\t\tif ((pad == link->sink) &&\n\t\t\t    (link->flags & MEDIA_LNK_FL_ENABLED)) {\n\t\t\t\tpad_idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (pad_idx < 0)\n\t\t\tcontinue;\n\n\t\tmfmt = &csi2tx->pad_fmts[pad_idx];\n\t\tfmt = csi2tx_get_fmt_from_mbus(mfmt->code);\n\t\tif (!fmt)\n\t\t\tcontinue;\n\n\t\tstream = pad_idx - CSI2TX_PAD_SINK_STREAM0;\n\n\t\t \n\t\twritel(CSI2TX_DT_CFG_DT(fmt->dt),\n\t\t       csi2tx->base + CSI2TX_DT_CFG_REG(stream));\n\n\t\twritel(CSI2TX_DT_FORMAT_BYTES_PER_LINE(mfmt->width * fmt->bpp) |\n\t\t       CSI2TX_DT_FORMAT_MAX_LINE_NUM(mfmt->height + 1),\n\t\t       csi2tx->base + CSI2TX_DT_FORMAT_REG(stream));\n\n\t\t \n\t\twritel(CSI2TX_STREAM_IF_CFG_FILL_LEVEL(4),\n\t\t       csi2tx->base + CSI2TX_STREAM_IF_CFG_REG(stream));\n\t}\n\n\t \n\twritel(0, csi2tx->base + CSI2TX_CONFIG_REG);\n\n\treturn 0;\n}\n\nstatic void csi2tx_stop(struct csi2tx_priv *csi2tx)\n{\n\twritel(CSI2TX_CONFIG_CFG_REQ | CSI2TX_CONFIG_SRST_REQ,\n\t       csi2tx->base + CSI2TX_CONFIG_REG);\n}\n\nstatic int csi2tx_s_stream(struct v4l2_subdev *subdev, int enable)\n{\n\tstruct csi2tx_priv *csi2tx = v4l2_subdev_to_csi2tx(subdev);\n\tint ret = 0;\n\n\tmutex_lock(&csi2tx->lock);\n\n\tif (enable) {\n\t\t \n\t\tif (!csi2tx->count) {\n\t\t\tret = csi2tx_start(csi2tx);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcsi2tx->count++;\n\t} else {\n\t\tcsi2tx->count--;\n\n\t\t \n\t\tif (!csi2tx->count)\n\t\t\tcsi2tx_stop(csi2tx);\n\t}\n\nout:\n\tmutex_unlock(&csi2tx->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops csi2tx_video_ops = {\n\t.s_stream\t= csi2tx_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops csi2tx_subdev_ops = {\n\t.pad\t\t= &csi2tx_pad_ops,\n\t.video\t\t= &csi2tx_video_ops,\n};\n\nstatic int csi2tx_get_resources(struct csi2tx_priv *csi2tx,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tunsigned int i;\n\tu32 dev_cfg;\n\tint ret;\n\n\tcsi2tx->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(csi2tx->base))\n\t\treturn PTR_ERR(csi2tx->base);\n\n\tcsi2tx->p_clk = devm_clk_get(&pdev->dev, \"p_clk\");\n\tif (IS_ERR(csi2tx->p_clk)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get p_clk\\n\");\n\t\treturn PTR_ERR(csi2tx->p_clk);\n\t}\n\n\tcsi2tx->esc_clk = devm_clk_get(&pdev->dev, \"esc_clk\");\n\tif (IS_ERR(csi2tx->esc_clk)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get the esc_clk\\n\");\n\t\treturn PTR_ERR(csi2tx->esc_clk);\n\t}\n\n\tret = clk_prepare_enable(csi2tx->p_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't prepare and enable p_clk\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_cfg = readl(csi2tx->base + CSI2TX_DEVICE_CONFIG_REG);\n\tclk_disable_unprepare(csi2tx->p_clk);\n\n\tcsi2tx->max_lanes = dev_cfg & CSI2TX_DEVICE_CONFIG_LANES_MASK;\n\tif (csi2tx->max_lanes > CSI2TX_LANES_MAX) {\n\t\tdev_err(&pdev->dev, \"Invalid number of lanes: %u\\n\",\n\t\t\tcsi2tx->max_lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tcsi2tx->max_streams = (dev_cfg & CSI2TX_DEVICE_CONFIG_STREAMS_MASK) >> 4;\n\tif (csi2tx->max_streams > CSI2TX_STREAMS_MAX) {\n\t\tdev_err(&pdev->dev, \"Invalid number of streams: %u\\n\",\n\t\t\tcsi2tx->max_streams);\n\t\treturn -EINVAL;\n\t}\n\n\tcsi2tx->has_internal_dphy = !!(dev_cfg & CSI2TX_DEVICE_CONFIG_HAS_DPHY);\n\n\tfor (i = 0; i < csi2tx->max_streams; i++) {\n\t\tchar clk_name[16];\n\n\t\tsnprintf(clk_name, sizeof(clk_name), \"pixel_if%u_clk\", i);\n\t\tcsi2tx->pixel_clk[i] = devm_clk_get(&pdev->dev, clk_name);\n\t\tif (IS_ERR(csi2tx->pixel_clk[i])) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't get clock %s\\n\",\n\t\t\t\tclk_name);\n\t\t\treturn PTR_ERR(csi2tx->pixel_clk[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int csi2tx_check_lanes(struct csi2tx_priv *csi2tx)\n{\n\tstruct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = 0 };\n\tstruct device_node *ep;\n\tint ret, i;\n\n\tep = of_graph_get_endpoint_by_regs(csi2tx->dev->of_node, 0, 0);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep), &v4l2_ep);\n\tif (ret) {\n\t\tdev_err(csi2tx->dev, \"Could not parse v4l2 endpoint\\n\");\n\t\tgoto out;\n\t}\n\n\tif (v4l2_ep.bus_type != V4L2_MBUS_CSI2_DPHY) {\n\t\tdev_err(csi2tx->dev, \"Unsupported media bus type: 0x%x\\n\",\n\t\t\tv4l2_ep.bus_type);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcsi2tx->num_lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;\n\tif (csi2tx->num_lanes > csi2tx->max_lanes) {\n\t\tdev_err(csi2tx->dev,\n\t\t\t\"Current configuration uses more lanes than supported\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < csi2tx->num_lanes; i++) {\n\t\tif (v4l2_ep.bus.mipi_csi2.data_lanes[i] < 1) {\n\t\t\tdev_err(csi2tx->dev, \"Invalid lane[%d] number: %u\\n\",\n\t\t\t\ti, v4l2_ep.bus.mipi_csi2.data_lanes[i]);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemcpy(csi2tx->lanes, v4l2_ep.bus.mipi_csi2.data_lanes,\n\t       sizeof(csi2tx->lanes));\n\nout:\n\tof_node_put(ep);\n\treturn ret;\n}\n\nstatic const struct csi2tx_vops csi2tx_vops = {\n\t.dphy_setup = csi2tx_dphy_setup,\n};\n\nstatic const struct csi2tx_vops csi2tx_v2_vops = {\n\t.dphy_setup = csi2tx_v2_dphy_setup,\n};\n\nstatic const struct of_device_id csi2tx_of_table[] = {\n\t{\n\t\t.compatible = \"cdns,csi2tx\",\n\t\t.data = &csi2tx_vops\n\t},\n\t{\n\t\t.compatible = \"cdns,csi2tx-1.3\",\n\t\t.data = &csi2tx_vops\n\t},\n\t{\n\t\t.compatible = \"cdns,csi2tx-2.1\",\n\t\t.data = &csi2tx_v2_vops\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, csi2tx_of_table);\n\nstatic int csi2tx_probe(struct platform_device *pdev)\n{\n\tstruct csi2tx_priv *csi2tx;\n\tconst struct of_device_id *of_id;\n\tunsigned int i;\n\tint ret;\n\n\tcsi2tx = kzalloc(sizeof(*csi2tx), GFP_KERNEL);\n\tif (!csi2tx)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, csi2tx);\n\tmutex_init(&csi2tx->lock);\n\tcsi2tx->dev = &pdev->dev;\n\n\tret = csi2tx_get_resources(csi2tx, pdev);\n\tif (ret)\n\t\tgoto err_free_priv;\n\n\tof_id = of_match_node(csi2tx_of_table, pdev->dev.of_node);\n\tcsi2tx->vops = (struct csi2tx_vops *)of_id->data;\n\n\tv4l2_subdev_init(&csi2tx->subdev, &csi2tx_subdev_ops);\n\tcsi2tx->subdev.owner = THIS_MODULE;\n\tcsi2tx->subdev.dev = &pdev->dev;\n\tcsi2tx->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsnprintf(csi2tx->subdev.name, V4L2_SUBDEV_NAME_SIZE, \"%s.%s\",\n\t\t KBUILD_MODNAME, dev_name(&pdev->dev));\n\n\tret = csi2tx_check_lanes(csi2tx);\n\tif (ret)\n\t\tgoto err_free_priv;\n\n\t \n\tcsi2tx->subdev.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tcsi2tx->pads[CSI2TX_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\tfor (i = CSI2TX_PAD_SINK_STREAM0; i < CSI2TX_PAD_MAX; i++)\n\t\tcsi2tx->pads[i].flags = MEDIA_PAD_FL_SINK;\n\n\t \n\tfor (i = CSI2TX_PAD_SINK_STREAM0; i < CSI2TX_PAD_MAX; i++)\n\t\tcsi2tx->pad_fmts[i] = fmt_default;\n\n\tret = media_entity_pads_init(&csi2tx->subdev.entity, CSI2TX_PAD_MAX,\n\t\t\t\t     csi2tx->pads);\n\tif (ret)\n\t\tgoto err_free_priv;\n\n\tret = v4l2_async_register_subdev(&csi2tx->subdev);\n\tif (ret < 0)\n\t\tgoto err_free_priv;\n\n\tdev_info(&pdev->dev,\n\t\t \"Probed CSI2TX with %u/%u lanes, %u streams, %s D-PHY\\n\",\n\t\t csi2tx->num_lanes, csi2tx->max_lanes, csi2tx->max_streams,\n\t\t csi2tx->has_internal_dphy ? \"internal\" : \"no\");\n\n\treturn 0;\n\nerr_free_priv:\n\tkfree(csi2tx);\n\treturn ret;\n}\n\nstatic void csi2tx_remove(struct platform_device *pdev)\n{\n\tstruct csi2tx_priv *csi2tx = platform_get_drvdata(pdev);\n\n\tv4l2_async_unregister_subdev(&csi2tx->subdev);\n\tkfree(csi2tx);\n}\n\nstatic struct platform_driver csi2tx_driver = {\n\t.probe\t= csi2tx_probe,\n\t.remove_new = csi2tx_remove,\n\n\t.driver\t= {\n\t\t.name\t\t= \"cdns-csi2tx\",\n\t\t.of_match_table\t= csi2tx_of_table,\n\t},\n};\nmodule_platform_driver(csi2tx_driver);\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@bootlin.com>\");\nMODULE_DESCRIPTION(\"Cadence CSI2-TX controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}