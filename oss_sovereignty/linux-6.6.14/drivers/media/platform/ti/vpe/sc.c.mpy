{
  "module_name": "sc.c",
  "hash_id": "508405b837ea0bdcedafccac072fac057bee15b0e7f82c2b0a6b7d44e2a744c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/vpe/sc.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"sc.h\"\n#include \"sc_coeff.h\"\n\nvoid sc_dump_regs(struct sc_data *sc)\n{\n\tstruct device *dev = &sc->pdev->dev;\n\n#define DUMPREG(r) dev_dbg(dev, \"%-35s %08x\\n\", #r, \\\n\tioread32(sc->base + CFG_##r))\n\n\tdev_dbg(dev, \"SC Registers @ %pa:\\n\", &sc->res->start);\n\n\tDUMPREG(SC0);\n\tDUMPREG(SC1);\n\tDUMPREG(SC2);\n\tDUMPREG(SC3);\n\tDUMPREG(SC4);\n\tDUMPREG(SC5);\n\tDUMPREG(SC6);\n\tDUMPREG(SC8);\n\tDUMPREG(SC9);\n\tDUMPREG(SC10);\n\tDUMPREG(SC11);\n\tDUMPREG(SC12);\n\tDUMPREG(SC13);\n\tDUMPREG(SC17);\n\tDUMPREG(SC18);\n\tDUMPREG(SC19);\n\tDUMPREG(SC20);\n\tDUMPREG(SC21);\n\tDUMPREG(SC22);\n\tDUMPREG(SC23);\n\tDUMPREG(SC24);\n\tDUMPREG(SC25);\n\n#undef DUMPREG\n}\nEXPORT_SYMBOL(sc_dump_regs);\n\n \nvoid sc_set_hs_coeffs(struct sc_data *sc, void *addr, unsigned int src_w,\n\t\tunsigned int dst_w)\n{\n\tint sixteenths;\n\tint idx;\n\tint i, j;\n\tu16 *coeff_h = addr;\n\tconst u16 *cp;\n\n\tif (dst_w > src_w) {\n\t\tidx = HS_UP_SCALE;\n\t} else {\n\t\tif ((dst_w << 1) < src_w)\n\t\t\tdst_w <<= 1;\t \n\t\tif ((dst_w << 1) < src_w)\n\t\t\tdst_w <<= 1;\t \n\n\t\tif (dst_w == src_w) {\n\t\t\tidx = HS_LE_16_16_SCALE;\n\t\t} else {\n\t\t\tsixteenths = (dst_w << 4) / src_w;\n\t\t\tif (sixteenths < 8)\n\t\t\t\tsixteenths = 8;\n\t\t\tidx = HS_LT_9_16_SCALE + sixteenths - 8;\n\t\t}\n\t}\n\n\tcp = scaler_hs_coeffs[idx];\n\n\tfor (i = 0; i < SC_NUM_PHASES * 2; i++) {\n\t\tfor (j = 0; j < SC_H_NUM_TAPS; j++)\n\t\t\t*coeff_h++ = *cp++;\n\t\t \n\t\tcoeff_h += SC_NUM_TAPS_MEM_ALIGN - SC_H_NUM_TAPS;\n\t}\n\n\tsc->load_coeff_h = true;\n}\nEXPORT_SYMBOL(sc_set_hs_coeffs);\n\n \nvoid sc_set_vs_coeffs(struct sc_data *sc, void *addr, unsigned int src_h,\n\t\tunsigned int dst_h)\n{\n\tint sixteenths;\n\tint idx;\n\tint i, j;\n\tu16 *coeff_v = addr;\n\tconst u16 *cp;\n\n\tif (dst_h > src_h) {\n\t\tidx = VS_UP_SCALE;\n\t} else if (dst_h == src_h) {\n\t\tidx = VS_1_TO_1_SCALE;\n\t} else {\n\t\tsixteenths = (dst_h << 4) / src_h;\n\t\tif (sixteenths < 8)\n\t\t\tsixteenths = 8;\n\t\tidx = VS_LT_9_16_SCALE + sixteenths - 8;\n\t}\n\n\tcp = scaler_vs_coeffs[idx];\n\n\tfor (i = 0; i < SC_NUM_PHASES * 2; i++) {\n\t\tfor (j = 0; j < SC_V_NUM_TAPS; j++)\n\t\t\t*coeff_v++ = *cp++;\n\t\t \n\t\tcoeff_v += SC_NUM_TAPS_MEM_ALIGN - SC_V_NUM_TAPS;\n\t}\n\n\tsc->load_coeff_v = true;\n}\nEXPORT_SYMBOL(sc_set_vs_coeffs);\n\nvoid sc_config_scaler(struct sc_data *sc, u32 *sc_reg0, u32 *sc_reg8,\n\t\tu32 *sc_reg17, unsigned int src_w, unsigned int src_h,\n\t\tunsigned int dst_w, unsigned int dst_h)\n{\n\tstruct device *dev = &sc->pdev->dev;\n\tu32 val;\n\tint dcm_x, dcm_shift;\n\tbool use_rav;\n\tunsigned long lltmp;\n\tu32 lin_acc_inc, lin_acc_inc_u;\n\tu32 col_acc_offset;\n\tu16 factor = 0;\n\tint row_acc_init_rav = 0, row_acc_init_rav_b = 0;\n\tu32 row_acc_inc = 0, row_acc_offset = 0, row_acc_offset_b = 0;\n\t \n\tu32 *sc_reg9 = sc_reg8 + 1;\n\tu32 *sc_reg12 = sc_reg8 + 4;\n\tu32 *sc_reg13 = sc_reg8 + 5;\n\tu32 *sc_reg24 = sc_reg17 + 7;\n\n\tval = sc_reg0[0];\n\n\t \n\tval &= ~(CFG_SELFGEN_FID | CFG_TRIM | CFG_ENABLE_SIN2_VER_INTP |\n\t\tCFG_INTERLACE_I | CFG_DCM_4X | CFG_DCM_2X | CFG_AUTO_HS |\n\t\tCFG_ENABLE_EV | CFG_USE_RAV | CFG_INVT_FID | CFG_SC_BYPASS |\n\t\tCFG_INTERLACE_O | CFG_Y_PK_EN | CFG_HP_BYPASS | CFG_LINEAR);\n\n\tif (src_w == dst_w && src_h == dst_h) {\n\t\tval |= CFG_SC_BYPASS;\n\t\tsc_reg0[0] = val;\n\t\treturn;\n\t}\n\n\t \n\tval |= CFG_LINEAR;\n\n\t \n\n\t \n\tdcm_x = src_w / dst_w;\n\tif (dcm_x > 4) {\n\t\tval |= CFG_DCM_4X;\n\t\tdcm_shift = 2;\n\t} else if (dcm_x > 2) {\n\t\tval |= CFG_DCM_2X;\n\t\tdcm_shift = 1;\n\t} else {\n\t\tdcm_shift = 0;\n\t}\n\n\tlltmp = dst_w - 1;\n\tlin_acc_inc = div64_u64(((u64)(src_w >> dcm_shift) - 1) << 24, lltmp);\n\tlin_acc_inc_u = 0;\n\tcol_acc_offset = 0;\n\n\tdev_dbg(dev, \"hs config: src_w = %d, dst_w = %d, decimation = %s, lin_acc_inc = %08x\\n\",\n\t\tsrc_w, dst_w, dcm_shift == 2 ? \"4x\" :\n\t\t(dcm_shift == 1 ? \"2x\" : \"none\"), lin_acc_inc);\n\n\t \n\n\t \n\tif (dst_h < (src_h >> 2)) {\n\t\tuse_rav = true;\n\t\tval |= CFG_USE_RAV;\n\t} else {\n\t\tuse_rav = false;\n\t}\n\n\tif (use_rav) {\n\t\t \n\t\tfactor = (u16) ((dst_h << 10) / src_h);\n\n\t\trow_acc_init_rav = factor + ((1 + factor) >> 1);\n\t\tif (row_acc_init_rav >= 1024)\n\t\t\trow_acc_init_rav -= 1024;\n\n\t\trow_acc_init_rav_b = row_acc_init_rav +\n\t\t\t\t(1 + (row_acc_init_rav >> 1)) -\n\t\t\t\t(1024 >> 1);\n\n\t\tif (row_acc_init_rav_b < 0) {\n\t\t\trow_acc_init_rav_b += row_acc_init_rav;\n\t\t\trow_acc_init_rav *= 2;\n\t\t}\n\n\t\tdev_dbg(dev, \"vs config(RAV): src_h = %d, dst_h = %d, factor = %d, acc_init = %08x, acc_init_b = %08x\\n\",\n\t\t\tsrc_h, dst_h, factor, row_acc_init_rav,\n\t\t\trow_acc_init_rav_b);\n\t} else {\n\t\t \n\t\trow_acc_inc = ((src_h - 1) << 16) / (dst_h - 1);\n\t\trow_acc_offset = 0;\n\t\trow_acc_offset_b = 0;\n\n\t\tdev_dbg(dev, \"vs config(POLY): src_h = %d, dst_h = %d,row_acc_inc = %08x\\n\",\n\t\t\tsrc_h, dst_h, row_acc_inc);\n\t}\n\n\n\tsc_reg0[0] = val;\n\tsc_reg0[1] = row_acc_inc;\n\tsc_reg0[2] = row_acc_offset;\n\tsc_reg0[3] = row_acc_offset_b;\n\n\tsc_reg0[4] = ((lin_acc_inc_u & CFG_LIN_ACC_INC_U_MASK) <<\n\t\t\tCFG_LIN_ACC_INC_U_SHIFT) | (dst_w << CFG_TAR_W_SHIFT) |\n\t\t\t(dst_h << CFG_TAR_H_SHIFT);\n\n\tsc_reg0[5] = (src_w << CFG_SRC_W_SHIFT) | (src_h << CFG_SRC_H_SHIFT);\n\n\tsc_reg0[6] = (row_acc_init_rav_b << CFG_ROW_ACC_INIT_RAV_B_SHIFT) |\n\t\t(row_acc_init_rav << CFG_ROW_ACC_INIT_RAV_SHIFT);\n\n\t*sc_reg9 = lin_acc_inc;\n\n\t*sc_reg12 = col_acc_offset << CFG_COL_ACC_OFFSET_SHIFT;\n\n\t*sc_reg13 = factor;\n\n\t*sc_reg24 = (src_w << CFG_ORG_W_SHIFT) | (src_h << CFG_ORG_H_SHIFT);\n}\nEXPORT_SYMBOL(sc_config_scaler);\n\nstruct sc_data *sc_create(struct platform_device *pdev, const char *res_name)\n{\n\tstruct sc_data *sc;\n\n\tdev_dbg(&pdev->dev, \"sc_create\\n\");\n\n\tsc = devm_kzalloc(&pdev->dev, sizeof(*sc), GFP_KERNEL);\n\tif (!sc) {\n\t\tdev_err(&pdev->dev, \"couldn't alloc sc_data\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tsc->pdev = pdev;\n\n\tsc->res = platform_get_resource_byname(pdev, IORESOURCE_MEM, res_name);\n\tif (!sc->res) {\n\t\tdev_err(&pdev->dev, \"missing '%s' platform resources data\\n\",\n\t\t\tres_name);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tsc->base = devm_ioremap_resource(&pdev->dev, sc->res);\n\tif (IS_ERR(sc->base))\n\t\treturn ERR_CAST(sc->base);\n\n\treturn sc;\n}\nEXPORT_SYMBOL(sc_create);\n\nMODULE_DESCRIPTION(\"TI VIP/VPE Scaler\");\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}