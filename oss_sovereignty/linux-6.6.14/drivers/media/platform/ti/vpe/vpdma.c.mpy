{
  "module_name": "vpdma.c",
  "hash_id": "aae465a19b1c108cfef0ff2e96f8bbb9762a97ddf32aafd47f7713071abf99b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/vpe/vpdma.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/firmware.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n\n#include \"vpdma.h\"\n#include \"vpdma_priv.h\"\n\n#define VPDMA_FIRMWARE\t\"vpdma-1b8.bin\"\n\nconst struct vpdma_data_format vpdma_yuv_fmts[] = {\n\t[VPDMA_DATA_FMT_Y444] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_Y444,\n\t\t.depth\t\t= 8,\n\t},\n\t[VPDMA_DATA_FMT_Y422] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_Y422,\n\t\t.depth\t\t= 8,\n\t},\n\t[VPDMA_DATA_FMT_Y420] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_Y420,\n\t\t.depth\t\t= 8,\n\t},\n\t[VPDMA_DATA_FMT_C444] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_C444,\n\t\t.depth\t\t= 8,\n\t},\n\t[VPDMA_DATA_FMT_C422] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_C422,\n\t\t.depth\t\t= 8,\n\t},\n\t[VPDMA_DATA_FMT_C420] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_C420,\n\t\t.depth\t\t= 4,\n\t},\n\t[VPDMA_DATA_FMT_CB420] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_CB420,\n\t\t.depth\t\t= 4,\n\t},\n\t[VPDMA_DATA_FMT_YCR422] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_YCR422,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_YC444] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_YC444,\n\t\t.depth\t\t= 24,\n\t},\n\t[VPDMA_DATA_FMT_CRY422] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_CRY422,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_CBY422] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_CBY422,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_YCB422] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_YCB422,\n\t\t.depth\t\t= 16,\n\t},\n};\nEXPORT_SYMBOL(vpdma_yuv_fmts);\n\nconst struct vpdma_data_format vpdma_rgb_fmts[] = {\n\t[VPDMA_DATA_FMT_RGB565] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_RGB16_565,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_ARGB16_1555] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_ARGB_1555,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_ARGB16] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_ARGB_4444,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_RGBA16_5551] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_RGBA_5551,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_RGBA16] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_RGBA_4444,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_ARGB24] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_ARGB24_6666,\n\t\t.depth\t\t= 24,\n\t},\n\t[VPDMA_DATA_FMT_RGB24] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_RGB24_888,\n\t\t.depth\t\t= 24,\n\t},\n\t[VPDMA_DATA_FMT_ARGB32] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_ARGB32_8888,\n\t\t.depth\t\t= 32,\n\t},\n\t[VPDMA_DATA_FMT_RGBA24] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_RGBA24_6666,\n\t\t.depth\t\t= 24,\n\t},\n\t[VPDMA_DATA_FMT_RGBA32] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_RGBA32_8888,\n\t\t.depth\t\t= 32,\n\t},\n\t[VPDMA_DATA_FMT_BGR565] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_BGR16_565,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_ABGR16_1555] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_ABGR_1555,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_ABGR16] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_ABGR_4444,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_BGRA16_5551] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_BGRA_5551,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_BGRA16] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_BGRA_4444,\n\t\t.depth\t\t= 16,\n\t},\n\t[VPDMA_DATA_FMT_ABGR24] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_ABGR24_6666,\n\t\t.depth\t\t= 24,\n\t},\n\t[VPDMA_DATA_FMT_BGR24] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_BGR24_888,\n\t\t.depth\t\t= 24,\n\t},\n\t[VPDMA_DATA_FMT_ABGR32] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_ABGR32_8888,\n\t\t.depth\t\t= 32,\n\t},\n\t[VPDMA_DATA_FMT_BGRA24] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_BGRA24_6666,\n\t\t.depth\t\t= 24,\n\t},\n\t[VPDMA_DATA_FMT_BGRA32] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_RGB,\n\t\t.data_type\t= DATA_TYPE_BGRA32_8888,\n\t\t.depth\t\t= 32,\n\t},\n};\nEXPORT_SYMBOL(vpdma_rgb_fmts);\n\n \nconst struct vpdma_data_format vpdma_raw_fmts[] = {\n\t[VPDMA_DATA_FMT_RAW8] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_CBY422,\n\t\t.depth\t\t= 8,\n\t},\n\t[VPDMA_DATA_FMT_RAW16] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_YUV,\n\t\t.data_type\t= DATA_TYPE_CBY422,\n\t\t.depth\t\t= 16,\n\t},\n};\nEXPORT_SYMBOL(vpdma_raw_fmts);\n\nconst struct vpdma_data_format vpdma_misc_fmts[] = {\n\t[VPDMA_DATA_FMT_MV] = {\n\t\t.type\t\t= VPDMA_DATA_FMT_TYPE_MISC,\n\t\t.data_type\t= DATA_TYPE_MV,\n\t\t.depth\t\t= 4,\n\t},\n};\nEXPORT_SYMBOL(vpdma_misc_fmts);\n\nstruct vpdma_channel_info {\n\tint num;\t\t \n\tint cstat_offset;\t \n};\n\nstatic const struct vpdma_channel_info chan_info[] = {\n\t[VPE_CHAN_LUMA1_IN] = {\n\t\t.num\t\t= VPE_CHAN_NUM_LUMA1_IN,\n\t\t.cstat_offset\t= VPDMA_DEI_LUMA1_CSTAT,\n\t},\n\t[VPE_CHAN_CHROMA1_IN] = {\n\t\t.num\t\t= VPE_CHAN_NUM_CHROMA1_IN,\n\t\t.cstat_offset\t= VPDMA_DEI_CHROMA1_CSTAT,\n\t},\n\t[VPE_CHAN_LUMA2_IN] = {\n\t\t.num\t\t= VPE_CHAN_NUM_LUMA2_IN,\n\t\t.cstat_offset\t= VPDMA_DEI_LUMA2_CSTAT,\n\t},\n\t[VPE_CHAN_CHROMA2_IN] = {\n\t\t.num\t\t= VPE_CHAN_NUM_CHROMA2_IN,\n\t\t.cstat_offset\t= VPDMA_DEI_CHROMA2_CSTAT,\n\t},\n\t[VPE_CHAN_LUMA3_IN] = {\n\t\t.num\t\t= VPE_CHAN_NUM_LUMA3_IN,\n\t\t.cstat_offset\t= VPDMA_DEI_LUMA3_CSTAT,\n\t},\n\t[VPE_CHAN_CHROMA3_IN] = {\n\t\t.num\t\t= VPE_CHAN_NUM_CHROMA3_IN,\n\t\t.cstat_offset\t= VPDMA_DEI_CHROMA3_CSTAT,\n\t},\n\t[VPE_CHAN_MV_IN] = {\n\t\t.num\t\t= VPE_CHAN_NUM_MV_IN,\n\t\t.cstat_offset\t= VPDMA_DEI_MV_IN_CSTAT,\n\t},\n\t[VPE_CHAN_MV_OUT] = {\n\t\t.num\t\t= VPE_CHAN_NUM_MV_OUT,\n\t\t.cstat_offset\t= VPDMA_DEI_MV_OUT_CSTAT,\n\t},\n\t[VPE_CHAN_LUMA_OUT] = {\n\t\t.num\t\t= VPE_CHAN_NUM_LUMA_OUT,\n\t\t.cstat_offset\t= VPDMA_VIP_UP_Y_CSTAT,\n\t},\n\t[VPE_CHAN_CHROMA_OUT] = {\n\t\t.num\t\t= VPE_CHAN_NUM_CHROMA_OUT,\n\t\t.cstat_offset\t= VPDMA_VIP_UP_UV_CSTAT,\n\t},\n\t[VPE_CHAN_RGB_OUT] = {\n\t\t.num\t\t= VPE_CHAN_NUM_RGB_OUT,\n\t\t.cstat_offset\t= VPDMA_VIP_UP_Y_CSTAT,\n\t},\n};\n\nstatic u32 read_reg(struct vpdma_data *vpdma, int offset)\n{\n\treturn ioread32(vpdma->base + offset);\n}\n\nstatic void write_reg(struct vpdma_data *vpdma, int offset, u32 value)\n{\n\tiowrite32(value, vpdma->base + offset);\n}\n\nstatic int read_field_reg(struct vpdma_data *vpdma, int offset,\n\t\tu32 mask, int shift)\n{\n\treturn (read_reg(vpdma, offset) & (mask << shift)) >> shift;\n}\n\nstatic void write_field_reg(struct vpdma_data *vpdma, int offset, u32 field,\n\t\tu32 mask, int shift)\n{\n\tu32 val = read_reg(vpdma, offset);\n\n\tval &= ~(mask << shift);\n\tval |= (field & mask) << shift;\n\n\twrite_reg(vpdma, offset, val);\n}\n\nvoid vpdma_dump_regs(struct vpdma_data *vpdma)\n{\n\tstruct device *dev = &vpdma->pdev->dev;\n\n#define DUMPREG(r) dev_dbg(dev, \"%-35s %08x\\n\", #r, read_reg(vpdma, VPDMA_##r))\n\n\tdev_dbg(dev, \"VPDMA Registers:\\n\");\n\n\tDUMPREG(PID);\n\tDUMPREG(LIST_ADDR);\n\tDUMPREG(LIST_ATTR);\n\tDUMPREG(LIST_STAT_SYNC);\n\tDUMPREG(BG_RGB);\n\tDUMPREG(BG_YUV);\n\tDUMPREG(SETUP);\n\tDUMPREG(MAX_SIZE1);\n\tDUMPREG(MAX_SIZE2);\n\tDUMPREG(MAX_SIZE3);\n\n\t \n\tDUMPREG(INT_CHAN_STAT(0));\n\tDUMPREG(INT_CHAN_MASK(0));\n\tDUMPREG(INT_CHAN_STAT(3));\n\tDUMPREG(INT_CHAN_MASK(3));\n\tDUMPREG(INT_CLIENT0_STAT);\n\tDUMPREG(INT_CLIENT0_MASK);\n\tDUMPREG(INT_CLIENT1_STAT);\n\tDUMPREG(INT_CLIENT1_MASK);\n\tDUMPREG(INT_LIST0_STAT);\n\tDUMPREG(INT_LIST0_MASK);\n\n\t \n\tDUMPREG(DEI_CHROMA1_CSTAT);\n\tDUMPREG(DEI_LUMA1_CSTAT);\n\tDUMPREG(DEI_CHROMA2_CSTAT);\n\tDUMPREG(DEI_LUMA2_CSTAT);\n\tDUMPREG(DEI_CHROMA3_CSTAT);\n\tDUMPREG(DEI_LUMA3_CSTAT);\n\tDUMPREG(DEI_MV_IN_CSTAT);\n\tDUMPREG(DEI_MV_OUT_CSTAT);\n\tDUMPREG(VIP_UP_Y_CSTAT);\n\tDUMPREG(VIP_UP_UV_CSTAT);\n\tDUMPREG(VPI_CTL_CSTAT);\n}\nEXPORT_SYMBOL(vpdma_dump_regs);\n\n \nint vpdma_alloc_desc_buf(struct vpdma_buf *buf, size_t size)\n{\n\tbuf->size = size;\n\tbuf->mapped = false;\n\tbuf->addr = kzalloc(size, GFP_KERNEL);\n\tif (!buf->addr)\n\t\treturn -ENOMEM;\n\n\tWARN_ON(((unsigned long)buf->addr & VPDMA_DESC_ALIGN) != 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vpdma_alloc_desc_buf);\n\nvoid vpdma_free_desc_buf(struct vpdma_buf *buf)\n{\n\tWARN_ON(buf->mapped);\n\tkfree(buf->addr);\n\tbuf->addr = NULL;\n\tbuf->size = 0;\n}\nEXPORT_SYMBOL(vpdma_free_desc_buf);\n\n \nint vpdma_map_desc_buf(struct vpdma_data *vpdma, struct vpdma_buf *buf)\n{\n\tstruct device *dev = &vpdma->pdev->dev;\n\n\tWARN_ON(buf->mapped);\n\tbuf->dma_addr = dma_map_single(dev, buf->addr, buf->size,\n\t\t\t\tDMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, buf->dma_addr)) {\n\t\tdev_err(dev, \"failed to map buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbuf->mapped = true;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vpdma_map_desc_buf);\n\n \nvoid vpdma_unmap_desc_buf(struct vpdma_data *vpdma, struct vpdma_buf *buf)\n{\n\tstruct device *dev = &vpdma->pdev->dev;\n\n\tif (buf->mapped)\n\t\tdma_unmap_single(dev, buf->dma_addr, buf->size,\n\t\t\t\tDMA_BIDIRECTIONAL);\n\n\tbuf->mapped = false;\n}\nEXPORT_SYMBOL(vpdma_unmap_desc_buf);\n\n \nint vpdma_list_cleanup(struct vpdma_data *vpdma, int list_num,\n\t\tint *channels, int size)\n{\n\tstruct vpdma_desc_list abort_list;\n\tint i, ret, timeout = 500;\n\n\twrite_reg(vpdma, VPDMA_LIST_ATTR,\n\t\t\t(list_num << VPDMA_LIST_NUM_SHFT) |\n\t\t\t(1 << VPDMA_LIST_STOP_SHFT));\n\n\tif (size <= 0 || !channels)\n\t\treturn 0;\n\n\tret = vpdma_create_desc_list(&abort_list,\n\t\tsize * sizeof(struct vpdma_dtd), VPDMA_LIST_TYPE_NORMAL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < size; i++)\n\t\tvpdma_add_abort_channel_ctd(&abort_list, channels[i]);\n\n\tret = vpdma_map_desc_buf(vpdma, &abort_list.buf);\n\tif (ret)\n\t\tgoto free_desc;\n\tret = vpdma_submit_descs(vpdma, &abort_list, list_num);\n\tif (ret)\n\t\tgoto unmap_desc;\n\n\twhile (vpdma_list_busy(vpdma, list_num) && --timeout)\n\t\t;\n\n\tif (timeout == 0) {\n\t\tdev_err(&vpdma->pdev->dev, \"Timed out cleaning up VPDMA list\\n\");\n\t\tret = -EBUSY;\n\t}\n\nunmap_desc:\n\tvpdma_unmap_desc_buf(vpdma, &abort_list.buf);\nfree_desc:\n\tvpdma_free_desc_buf(&abort_list.buf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vpdma_list_cleanup);\n\n \nint vpdma_create_desc_list(struct vpdma_desc_list *list, size_t size, int type)\n{\n\tint r;\n\n\tr = vpdma_alloc_desc_buf(&list->buf, size);\n\tif (r)\n\t\treturn r;\n\n\tlist->next = list->buf.addr;\n\n\tlist->type = type;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vpdma_create_desc_list);\n\n \nvoid vpdma_reset_desc_list(struct vpdma_desc_list *list)\n{\n\tlist->next = list->buf.addr;\n}\nEXPORT_SYMBOL(vpdma_reset_desc_list);\n\n \nvoid vpdma_free_desc_list(struct vpdma_desc_list *list)\n{\n\tvpdma_free_desc_buf(&list->buf);\n\n\tlist->next = NULL;\n}\nEXPORT_SYMBOL(vpdma_free_desc_list);\n\nbool vpdma_list_busy(struct vpdma_data *vpdma, int list_num)\n{\n\treturn read_reg(vpdma, VPDMA_LIST_STAT_SYNC) & BIT(list_num + 16);\n}\nEXPORT_SYMBOL(vpdma_list_busy);\n\n \nint vpdma_submit_descs(struct vpdma_data *vpdma,\n\t\t\tstruct vpdma_desc_list *list, int list_num)\n{\n\tint list_size;\n\tunsigned long flags;\n\n\tif (vpdma_list_busy(vpdma, list_num))\n\t\treturn -EBUSY;\n\n\t \n\tlist_size = (list->next - list->buf.addr) >> 4;\n\n\tspin_lock_irqsave(&vpdma->lock, flags);\n\twrite_reg(vpdma, VPDMA_LIST_ADDR, (u32) list->buf.dma_addr);\n\n\twrite_reg(vpdma, VPDMA_LIST_ATTR,\n\t\t\t(list_num << VPDMA_LIST_NUM_SHFT) |\n\t\t\t(list->type << VPDMA_LIST_TYPE_SHFT) |\n\t\t\tlist_size);\n\tspin_unlock_irqrestore(&vpdma->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vpdma_submit_descs);\n\nstatic void dump_dtd(struct vpdma_dtd *dtd);\n\nvoid vpdma_update_dma_addr(struct vpdma_data *vpdma,\n\tstruct vpdma_desc_list *list, dma_addr_t dma_addr,\n\tvoid *write_dtd, int drop, int idx)\n{\n\tstruct vpdma_dtd *dtd = list->buf.addr;\n\tdma_addr_t write_desc_addr;\n\tint offset;\n\n\tdtd += idx;\n\tvpdma_unmap_desc_buf(vpdma, &list->buf);\n\n\tdtd->start_addr = dma_addr;\n\n\t \n\toffset = (void *)write_dtd - list->buf.addr;\n\twrite_desc_addr = list->buf.dma_addr + offset;\n\n\tif (drop)\n\t\tdtd->desc_write_addr = dtd_desc_write_addr(write_desc_addr,\n\t\t\t\t\t\t\t   1, 1, 0);\n\telse\n\t\tdtd->desc_write_addr = dtd_desc_write_addr(write_desc_addr,\n\t\t\t\t\t\t\t   1, 0, 0);\n\n\tvpdma_map_desc_buf(vpdma, &list->buf);\n\n\tdump_dtd(dtd);\n}\nEXPORT_SYMBOL(vpdma_update_dma_addr);\n\nvoid vpdma_set_max_size(struct vpdma_data *vpdma, int reg_addr,\n\t\t\tu32 width, u32 height)\n{\n\tif (reg_addr != VPDMA_MAX_SIZE1 && reg_addr != VPDMA_MAX_SIZE2 &&\n\t    reg_addr != VPDMA_MAX_SIZE3)\n\t\treg_addr = VPDMA_MAX_SIZE1;\n\n\twrite_field_reg(vpdma, reg_addr, width - 1,\n\t\t\tVPDMA_MAX_SIZE_WIDTH_MASK, VPDMA_MAX_SIZE_WIDTH_SHFT);\n\n\twrite_field_reg(vpdma, reg_addr, height - 1,\n\t\t\tVPDMA_MAX_SIZE_HEIGHT_MASK, VPDMA_MAX_SIZE_HEIGHT_SHFT);\n\n}\nEXPORT_SYMBOL(vpdma_set_max_size);\n\nstatic void dump_cfd(struct vpdma_cfd *cfd)\n{\n\tint class;\n\n\tclass = cfd_get_class(cfd);\n\n\tpr_debug(\"config descriptor of payload class: %s\\n\",\n\t\tclass == CFD_CLS_BLOCK ? \"simple block\" :\n\t\t\"address data block\");\n\n\tif (class == CFD_CLS_BLOCK)\n\t\tpr_debug(\"word0: dst_addr_offset = 0x%08x\\n\",\n\t\t\tcfd->dest_addr_offset);\n\n\tif (class == CFD_CLS_BLOCK)\n\t\tpr_debug(\"word1: num_data_wrds = %d\\n\", cfd->block_len);\n\n\tpr_debug(\"word2: payload_addr = 0x%08x\\n\", cfd->payload_addr);\n\n\tpr_debug(\"word3: pkt_type = %d, direct = %d, class = %d, dest = %d, payload_len = %d\\n\",\n\t\t cfd_get_pkt_type(cfd),\n\t\t cfd_get_direct(cfd), class, cfd_get_dest(cfd),\n\t\t cfd_get_payload_len(cfd));\n}\n\n \nvoid vpdma_add_cfd_block(struct vpdma_desc_list *list, int client,\n\t\tstruct vpdma_buf *blk, u32 dest_offset)\n{\n\tstruct vpdma_cfd *cfd;\n\tint len = blk->size;\n\n\tWARN_ON(blk->dma_addr & VPDMA_DESC_ALIGN);\n\n\tcfd = list->next;\n\tWARN_ON((void *)(cfd + 1) > (list->buf.addr + list->buf.size));\n\n\tcfd->dest_addr_offset = dest_offset;\n\tcfd->block_len = len;\n\tcfd->payload_addr = (u32) blk->dma_addr;\n\tcfd->ctl_payload_len = cfd_pkt_payload_len(CFD_INDIRECT, CFD_CLS_BLOCK,\n\t\t\t\tclient, len >> 4);\n\n\tlist->next = cfd + 1;\n\n\tdump_cfd(cfd);\n}\nEXPORT_SYMBOL(vpdma_add_cfd_block);\n\n \nvoid vpdma_add_cfd_adb(struct vpdma_desc_list *list, int client,\n\t\tstruct vpdma_buf *adb)\n{\n\tstruct vpdma_cfd *cfd;\n\tunsigned int len = adb->size;\n\n\tWARN_ON(len & VPDMA_ADB_SIZE_ALIGN);\n\tWARN_ON(adb->dma_addr & VPDMA_DESC_ALIGN);\n\n\tcfd = list->next;\n\tBUG_ON((void *)(cfd + 1) > (list->buf.addr + list->buf.size));\n\n\tcfd->w0 = 0;\n\tcfd->w1 = 0;\n\tcfd->payload_addr = (u32) adb->dma_addr;\n\tcfd->ctl_payload_len = cfd_pkt_payload_len(CFD_INDIRECT, CFD_CLS_ADB,\n\t\t\t\tclient, len >> 4);\n\n\tlist->next = cfd + 1;\n\n\tdump_cfd(cfd);\n};\nEXPORT_SYMBOL(vpdma_add_cfd_adb);\n\n \nstatic void dump_ctd(struct vpdma_ctd *ctd)\n{\n\tpr_debug(\"control descriptor\\n\");\n\n\tpr_debug(\"word3: pkt_type = %d, source = %d, ctl_type = %d\\n\",\n\t\tctd_get_pkt_type(ctd), ctd_get_source(ctd), ctd_get_ctl(ctd));\n}\n\n \nvoid vpdma_add_sync_on_channel_ctd(struct vpdma_desc_list *list,\n\t\tenum vpdma_channel chan)\n{\n\tstruct vpdma_ctd *ctd;\n\n\tctd = list->next;\n\tWARN_ON((void *)(ctd + 1) > (list->buf.addr + list->buf.size));\n\n\tctd->w0 = 0;\n\tctd->w1 = 0;\n\tctd->w2 = 0;\n\tctd->type_source_ctl = ctd_type_source_ctl(chan_info[chan].num,\n\t\t\t\tCTD_TYPE_SYNC_ON_CHANNEL);\n\n\tlist->next = ctd + 1;\n\n\tdump_ctd(ctd);\n}\nEXPORT_SYMBOL(vpdma_add_sync_on_channel_ctd);\n\n \nvoid vpdma_add_abort_channel_ctd(struct vpdma_desc_list *list,\n\t\tint chan_num)\n{\n\tstruct vpdma_ctd *ctd;\n\n\tctd = list->next;\n\tWARN_ON((void *)(ctd + 1) > (list->buf.addr + list->buf.size));\n\n\tctd->w0 = 0;\n\tctd->w1 = 0;\n\tctd->w2 = 0;\n\tctd->type_source_ctl = ctd_type_source_ctl(chan_num,\n\t\t\t\tCTD_TYPE_ABORT_CHANNEL);\n\n\tlist->next = ctd + 1;\n\n\tdump_ctd(ctd);\n}\nEXPORT_SYMBOL(vpdma_add_abort_channel_ctd);\n\nstatic void dump_dtd(struct vpdma_dtd *dtd)\n{\n\tint dir, chan;\n\n\tdir = dtd_get_dir(dtd);\n\tchan = dtd_get_chan(dtd);\n\n\tpr_debug(\"%s data transfer descriptor for channel %d\\n\",\n\t\tdir == DTD_DIR_OUT ? \"outbound\" : \"inbound\", chan);\n\n\tpr_debug(\"word0: data_type = %d, notify = %d, field = %d, 1D = %d, even_ln_skp = %d, odd_ln_skp = %d, line_stride = %d\\n\",\n\t\tdtd_get_data_type(dtd), dtd_get_notify(dtd), dtd_get_field(dtd),\n\t\tdtd_get_1d(dtd), dtd_get_even_line_skip(dtd),\n\t\tdtd_get_odd_line_skip(dtd), dtd_get_line_stride(dtd));\n\n\tif (dir == DTD_DIR_IN)\n\t\tpr_debug(\"word1: line_length = %d, xfer_height = %d\\n\",\n\t\t\tdtd_get_line_length(dtd), dtd_get_xfer_height(dtd));\n\n\tpr_debug(\"word2: start_addr = %x\\n\", dtd->start_addr);\n\n\tpr_debug(\"word3: pkt_type = %d, mode = %d, dir = %d, chan = %d, pri = %d, next_chan = %d\\n\",\n\t\t dtd_get_pkt_type(dtd),\n\t\t dtd_get_mode(dtd), dir, chan, dtd_get_priority(dtd),\n\t\t dtd_get_next_chan(dtd));\n\n\tif (dir == DTD_DIR_IN)\n\t\tpr_debug(\"word4: frame_width = %d, frame_height = %d\\n\",\n\t\t\tdtd_get_frame_width(dtd), dtd_get_frame_height(dtd));\n\telse\n\t\tpr_debug(\"word4: desc_write_addr = 0x%08x, write_desc = %d, drp_data = %d, use_desc_reg = %d\\n\",\n\t\t\tdtd_get_desc_write_addr(dtd), dtd_get_write_desc(dtd),\n\t\t\tdtd_get_drop_data(dtd), dtd_get_use_desc(dtd));\n\n\tif (dir == DTD_DIR_IN)\n\t\tpr_debug(\"word5: hor_start = %d, ver_start = %d\\n\",\n\t\t\tdtd_get_h_start(dtd), dtd_get_v_start(dtd));\n\telse\n\t\tpr_debug(\"word5: max_width %d, max_height %d\\n\",\n\t\t\tdtd_get_max_width(dtd), dtd_get_max_height(dtd));\n\n\tpr_debug(\"word6: client specific attr0 = 0x%08x\\n\", dtd->client_attr0);\n\tpr_debug(\"word7: client specific attr1 = 0x%08x\\n\", dtd->client_attr1);\n}\n\n \nvoid vpdma_add_out_dtd(struct vpdma_desc_list *list, int width,\n\t\tint stride, const struct v4l2_rect *c_rect,\n\t\tconst struct vpdma_data_format *fmt, dma_addr_t dma_addr,\n\t\tint max_w, int max_h, enum vpdma_channel chan, u32 flags)\n{\n\tvpdma_rawchan_add_out_dtd(list, width, stride, c_rect, fmt, dma_addr,\n\t\t\t\t  max_w, max_h, chan_info[chan].num, flags);\n}\nEXPORT_SYMBOL(vpdma_add_out_dtd);\n\nvoid vpdma_rawchan_add_out_dtd(struct vpdma_desc_list *list, int width,\n\t\tint stride, const struct v4l2_rect *c_rect,\n\t\tconst struct vpdma_data_format *fmt, dma_addr_t dma_addr,\n\t\tint max_w, int max_h, int raw_vpdma_chan, u32 flags)\n{\n\tint priority = 0;\n\tint field = 0;\n\tint notify = 1;\n\tint channel, next_chan;\n\tstruct v4l2_rect rect = *c_rect;\n\tint depth = fmt->depth;\n\tstruct vpdma_dtd *dtd;\n\n\tchannel = next_chan = raw_vpdma_chan;\n\n\tif (fmt->type == VPDMA_DATA_FMT_TYPE_YUV &&\n\t    (fmt->data_type == DATA_TYPE_C420 ||\n\t     fmt->data_type == DATA_TYPE_CB420)) {\n\t\trect.height >>= 1;\n\t\trect.top >>= 1;\n\t\tdepth = 8;\n\t}\n\n\tdma_addr += rect.top * stride + (rect.left * depth >> 3);\n\n\tdtd = list->next;\n\tWARN_ON((void *)(dtd + 1) > (list->buf.addr + list->buf.size));\n\n\tdtd->type_ctl_stride = dtd_type_ctl_stride(fmt->data_type,\n\t\t\t\t\tnotify,\n\t\t\t\t\tfield,\n\t\t\t\t\t!!(flags & VPDMA_DATA_FRAME_1D),\n\t\t\t\t\t!!(flags & VPDMA_DATA_EVEN_LINE_SKIP),\n\t\t\t\t\t!!(flags & VPDMA_DATA_ODD_LINE_SKIP),\n\t\t\t\t\tstride);\n\tdtd->w1 = 0;\n\tdtd->start_addr = (u32) dma_addr;\n\tdtd->pkt_ctl = dtd_pkt_ctl(!!(flags & VPDMA_DATA_MODE_TILED),\n\t\t\t\tDTD_DIR_OUT, channel, priority, next_chan);\n\tdtd->desc_write_addr = dtd_desc_write_addr(0, 0, 0, 0);\n\tdtd->max_width_height = dtd_max_width_height(max_w, max_h);\n\tdtd->client_attr0 = 0;\n\tdtd->client_attr1 = 0;\n\n\tlist->next = dtd + 1;\n\n\tdump_dtd(dtd);\n}\nEXPORT_SYMBOL(vpdma_rawchan_add_out_dtd);\n\n \nvoid vpdma_add_in_dtd(struct vpdma_desc_list *list, int width,\n\t\tint stride, const struct v4l2_rect *c_rect,\n\t\tconst struct vpdma_data_format *fmt, dma_addr_t dma_addr,\n\t\tenum vpdma_channel chan, int field, u32 flags, int frame_width,\n\t\tint frame_height, int start_h, int start_v)\n{\n\tint priority = 0;\n\tint notify = 1;\n\tint depth = fmt->depth;\n\tint channel, next_chan;\n\tstruct v4l2_rect rect = *c_rect;\n\tstruct vpdma_dtd *dtd;\n\n\tchannel = next_chan = chan_info[chan].num;\n\n\tif (fmt->type == VPDMA_DATA_FMT_TYPE_YUV &&\n\t    (fmt->data_type == DATA_TYPE_C420 ||\n\t     fmt->data_type == DATA_TYPE_CB420)) {\n\t\trect.height >>= 1;\n\t\trect.top >>= 1;\n\t\tdepth = 8;\n\t}\n\n\tdma_addr += rect.top * stride + (rect.left * depth >> 3);\n\n\tdtd = list->next;\n\tWARN_ON((void *)(dtd + 1) > (list->buf.addr + list->buf.size));\n\n\tdtd->type_ctl_stride = dtd_type_ctl_stride(fmt->data_type,\n\t\t\t\t\tnotify,\n\t\t\t\t\tfield,\n\t\t\t\t\t!!(flags & VPDMA_DATA_FRAME_1D),\n\t\t\t\t\t!!(flags & VPDMA_DATA_EVEN_LINE_SKIP),\n\t\t\t\t\t!!(flags & VPDMA_DATA_ODD_LINE_SKIP),\n\t\t\t\t\tstride);\n\n\tdtd->xfer_length_height = dtd_xfer_length_height(rect.width,\n\t\t\t\t\trect.height);\n\tdtd->start_addr = (u32) dma_addr;\n\tdtd->pkt_ctl = dtd_pkt_ctl(!!(flags & VPDMA_DATA_MODE_TILED),\n\t\t\t\tDTD_DIR_IN, channel, priority, next_chan);\n\tdtd->frame_width_height = dtd_frame_width_height(frame_width,\n\t\t\t\t\tframe_height);\n\tdtd->start_h_v = dtd_start_h_v(start_h, start_v);\n\tdtd->client_attr0 = 0;\n\tdtd->client_attr1 = 0;\n\n\tlist->next = dtd + 1;\n\n\tdump_dtd(dtd);\n}\nEXPORT_SYMBOL(vpdma_add_in_dtd);\n\nint vpdma_hwlist_alloc(struct vpdma_data *vpdma, void *priv)\n{\n\tint i, list_num = -1;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vpdma->lock, flags);\n\tfor (i = 0; i < VPDMA_MAX_NUM_LIST && vpdma->hwlist_used[i]; i++)\n\t\t;\n\n\tif (i < VPDMA_MAX_NUM_LIST) {\n\t\tlist_num = i;\n\t\tvpdma->hwlist_used[i] = true;\n\t\tvpdma->hwlist_priv[i] = priv;\n\t}\n\tspin_unlock_irqrestore(&vpdma->lock, flags);\n\n\treturn list_num;\n}\nEXPORT_SYMBOL(vpdma_hwlist_alloc);\n\nvoid *vpdma_hwlist_get_priv(struct vpdma_data *vpdma, int list_num)\n{\n\tif (!vpdma || list_num >= VPDMA_MAX_NUM_LIST)\n\t\treturn NULL;\n\n\treturn vpdma->hwlist_priv[list_num];\n}\nEXPORT_SYMBOL(vpdma_hwlist_get_priv);\n\nvoid *vpdma_hwlist_release(struct vpdma_data *vpdma, int list_num)\n{\n\tvoid *priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vpdma->lock, flags);\n\tvpdma->hwlist_used[list_num] = false;\n\tpriv = vpdma->hwlist_priv;\n\tspin_unlock_irqrestore(&vpdma->lock, flags);\n\n\treturn priv;\n}\nEXPORT_SYMBOL(vpdma_hwlist_release);\n\n \nvoid vpdma_enable_list_complete_irq(struct vpdma_data *vpdma, int irq_num,\n\t\tint list_num, bool enable)\n{\n\tu32 reg_addr = VPDMA_INT_LIST0_MASK + VPDMA_INTX_OFFSET * irq_num;\n\tu32 val;\n\n\tval = read_reg(vpdma, reg_addr);\n\tif (enable)\n\t\tval |= (1 << (list_num * 2));\n\telse\n\t\tval &= ~(1 << (list_num * 2));\n\twrite_reg(vpdma, reg_addr, val);\n}\nEXPORT_SYMBOL(vpdma_enable_list_complete_irq);\n\n \nunsigned int vpdma_get_list_stat(struct vpdma_data *vpdma, int irq_num)\n{\n\tu32 reg_addr = VPDMA_INT_LIST0_STAT + VPDMA_INTX_OFFSET * irq_num;\n\n\treturn read_reg(vpdma, reg_addr);\n}\nEXPORT_SYMBOL(vpdma_get_list_stat);\n\n \nunsigned int vpdma_get_list_mask(struct vpdma_data *vpdma, int irq_num)\n{\n\tu32 reg_addr = VPDMA_INT_LIST0_MASK + VPDMA_INTX_OFFSET * irq_num;\n\n\treturn read_reg(vpdma, reg_addr);\n}\nEXPORT_SYMBOL(vpdma_get_list_mask);\n\n \nvoid vpdma_clear_list_stat(struct vpdma_data *vpdma, int irq_num,\n\t\t\t   int list_num)\n{\n\tu32 reg_addr = VPDMA_INT_LIST0_STAT + VPDMA_INTX_OFFSET * irq_num;\n\n\twrite_reg(vpdma, reg_addr, 3 << (list_num * 2));\n}\nEXPORT_SYMBOL(vpdma_clear_list_stat);\n\nvoid vpdma_set_bg_color(struct vpdma_data *vpdma,\n\t\tstruct vpdma_data_format *fmt, u32 color)\n{\n\tif (fmt->type == VPDMA_DATA_FMT_TYPE_RGB)\n\t\twrite_reg(vpdma, VPDMA_BG_RGB, color);\n\telse if (fmt->type == VPDMA_DATA_FMT_TYPE_YUV)\n\t\twrite_reg(vpdma, VPDMA_BG_YUV, color);\n}\nEXPORT_SYMBOL(vpdma_set_bg_color);\n\n \nvoid vpdma_set_line_mode(struct vpdma_data *vpdma, int line_mode,\n\t\tenum vpdma_channel chan)\n{\n\tint client_cstat = chan_info[chan].cstat_offset;\n\n\twrite_field_reg(vpdma, client_cstat, line_mode,\n\t\tVPDMA_CSTAT_LINE_MODE_MASK, VPDMA_CSTAT_LINE_MODE_SHIFT);\n}\nEXPORT_SYMBOL(vpdma_set_line_mode);\n\n \nvoid vpdma_set_frame_start_event(struct vpdma_data *vpdma,\n\t\tenum vpdma_frame_start_event fs_event,\n\t\tenum vpdma_channel chan)\n{\n\tint client_cstat = chan_info[chan].cstat_offset;\n\n\twrite_field_reg(vpdma, client_cstat, fs_event,\n\t\tVPDMA_CSTAT_FRAME_START_MASK, VPDMA_CSTAT_FRAME_START_SHIFT);\n}\nEXPORT_SYMBOL(vpdma_set_frame_start_event);\n\nstatic void vpdma_firmware_cb(const struct firmware *f, void *context)\n{\n\tstruct vpdma_data *vpdma = context;\n\tstruct vpdma_buf fw_dma_buf;\n\tint i, r;\n\n\tdev_dbg(&vpdma->pdev->dev, \"firmware callback\\n\");\n\n\tif (!f || !f->data) {\n\t\tdev_err(&vpdma->pdev->dev, \"couldn't get firmware\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (read_field_reg(vpdma, VPDMA_LIST_ATTR, VPDMA_LIST_RDY_MASK,\n\t\t\tVPDMA_LIST_RDY_SHFT)) {\n\t\tvpdma->cb(vpdma->pdev);\n\t\treturn;\n\t}\n\n\tr = vpdma_alloc_desc_buf(&fw_dma_buf, f->size);\n\tif (r) {\n\t\tdev_err(&vpdma->pdev->dev,\n\t\t\t\"failed to allocate dma buffer for firmware\\n\");\n\t\tgoto rel_fw;\n\t}\n\n\tmemcpy(fw_dma_buf.addr, f->data, f->size);\n\n\tvpdma_map_desc_buf(vpdma, &fw_dma_buf);\n\n\twrite_reg(vpdma, VPDMA_LIST_ADDR, (u32) fw_dma_buf.dma_addr);\n\n\tfor (i = 0; i < 100; i++) {\t\t \n\t\tmsleep_interruptible(10);\n\n\t\tif (read_field_reg(vpdma, VPDMA_LIST_ATTR, VPDMA_LIST_RDY_MASK,\n\t\t\t\tVPDMA_LIST_RDY_SHFT))\n\t\t\tbreak;\n\t}\n\n\tif (i == 100) {\n\t\tdev_err(&vpdma->pdev->dev, \"firmware upload failed\\n\");\n\t\tgoto free_buf;\n\t}\n\n\tvpdma->cb(vpdma->pdev);\n\nfree_buf:\n\tvpdma_unmap_desc_buf(vpdma, &fw_dma_buf);\n\n\tvpdma_free_desc_buf(&fw_dma_buf);\nrel_fw:\n\trelease_firmware(f);\n}\n\nstatic int vpdma_load_firmware(struct vpdma_data *vpdma)\n{\n\tint r;\n\tstruct device *dev = &vpdma->pdev->dev;\n\n\tr = request_firmware_nowait(THIS_MODULE, 1,\n\t\t(const char *) VPDMA_FIRMWARE, dev, GFP_KERNEL, vpdma,\n\t\tvpdma_firmware_cb);\n\tif (r) {\n\t\tdev_err(dev, \"firmware not available %s\\n\", VPDMA_FIRMWARE);\n\t\treturn r;\n\t} else {\n\t\tdev_info(dev, \"loading firmware %s\\n\", VPDMA_FIRMWARE);\n\t}\n\n\treturn 0;\n}\n\nint vpdma_create(struct platform_device *pdev, struct vpdma_data *vpdma,\n\t\tvoid (*cb)(struct platform_device *pdev))\n{\n\tstruct resource *res;\n\tint r;\n\n\tdev_dbg(&pdev->dev, \"vpdma_create\\n\");\n\n\tvpdma->pdev = pdev;\n\tvpdma->cb = cb;\n\tspin_lock_init(&vpdma->lock);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"vpdma\");\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"missing platform resources data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tvpdma->base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!vpdma->base) {\n\t\tdev_err(&pdev->dev, \"failed to ioremap\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tr = vpdma_load_firmware(vpdma);\n\tif (r) {\n\t\tpr_err(\"failed to load firmware %s\\n\", VPDMA_FIRMWARE);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vpdma_create);\n\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\nMODULE_FIRMWARE(VPDMA_FIRMWARE);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}