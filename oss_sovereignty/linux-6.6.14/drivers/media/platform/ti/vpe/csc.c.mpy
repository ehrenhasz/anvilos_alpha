{
  "module_name": "csc.c",
  "hash_id": "91fce86ce8e403d0749d87a33cfbca2c5c41f75f660f77ad43ed53138a962a15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/vpe/csc.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-common.h>\n\n#include \"csc.h\"\n\n \nstruct quantization {\n\tu16\tcoeff[12];\n};\n\nstruct colorspace {\n\tstruct quantization limited;\n\tstruct quantization full;\n};\n\nstruct encoding_direction {\n\tstruct colorspace r601;\n\tstruct colorspace r709;\n};\n\nstruct csc_coeffs {\n\tstruct encoding_direction y2r;\n\tstruct encoding_direction r2y;\n};\n\n \nstatic struct csc_coeffs csc_coeffs = {\n\t.y2r = {\n\t\t.r601 = {\n\t\t\t.limited = {\n\t\t\t\t{\t \n\t\t\t\t0x0400, 0x0000, 0x057D, 0x0400, 0x1EA7, 0x1D35,\n\t\t\t\t0x0400, 0x06EF, 0x1FFE, 0x0D40, 0x0210, 0x0C88,\n\t\t\t\t}\n\t\t\t},\n\t\t\t.full = {\n\t\t\t\t{\t \n\t\t\t\t0x04A8, 0x1FFE, 0x0662, 0x04A8, 0x1E6F, 0x1CBF,\n\t\t\t\t0x04A8, 0x0812, 0x1FFF, 0x0C84, 0x0220, 0x0BAC,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t.r709 = {\n\t\t\t.limited = {\n\t\t\t\t{\t \n\t\t\t\t0x0400, 0x0000, 0x0629, 0x0400, 0x1F45, 0x1E2B,\n\t\t\t\t0x0400, 0x0742, 0x0000, 0x0CEC, 0x0148, 0x0C60,\n\t\t\t\t}\n\t\t\t},\n\t\t\t.full = {\n\t\t\t\t{\t \n\t\t\t\t0x04A8, 0x0000, 0x072C, 0x04A8, 0x1F26, 0x1DDE,\n\t\t\t\t0x04A8, 0x0873, 0x0000, 0x0C20, 0x0134, 0x0B7C,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t},\n\t.r2y = {\n\t\t.r601 = {\n\t\t\t.limited = {\n\t\t\t\t{\t \n\t\t\t\t0x0132, 0x0259, 0x0075, 0x1F50, 0x1EA5, 0x020B,\n\t\t\t\t0x020B, 0x1E4A, 0x1FAB, 0x0000, 0x0200, 0x0200,\n\t\t\t\t}\n\t\t\t},\n\t\t\t.full = {\n\t\t\t\t{\t \n\t\t\t\t0x0107, 0x0204, 0x0064, 0x1F68, 0x1ED6, 0x01C2,\n\t\t\t\t0x01C2, 0x1E87, 0x1FB7, 0x0040, 0x0200, 0x0200,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t.r709 = {\n\t\t\t.limited = {\n\t\t\t\t{\t \n\t\t\t\t0x00DA, 0x02DC, 0x004A, 0x1F88, 0x1E6C, 0x020C,\n\t\t\t\t0x020C, 0x1E24, 0x1FD0, 0x0000, 0x0200, 0x0200,\n\t\t\t\t}\n\t\t\t},\n\t\t\t.full = {\n\t\t\t\t{\t \n\t\t\t\t0x00bb, 0x0275, 0x003f, 0x1f99, 0x1ea5, 0x01c2,\n\t\t\t\t0x01c2, 0x1e67, 0x1fd7, 0x0040, 0x0200, 0x0200,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t},\n\n};\n\nvoid csc_dump_regs(struct csc_data *csc)\n{\n\tstruct device *dev = &csc->pdev->dev;\n\n#define DUMPREG(r) dev_dbg(dev, \"%-35s %08x\\n\", #r, \\\n\tioread32(csc->base + CSC_##r))\n\n\tdev_dbg(dev, \"CSC Registers @ %pa:\\n\", &csc->res->start);\n\n\tDUMPREG(CSC00);\n\tDUMPREG(CSC01);\n\tDUMPREG(CSC02);\n\tDUMPREG(CSC03);\n\tDUMPREG(CSC04);\n\tDUMPREG(CSC05);\n\n#undef DUMPREG\n}\nEXPORT_SYMBOL(csc_dump_regs);\n\nvoid csc_set_coeff_bypass(struct csc_data *csc, u32 *csc_reg5)\n{\n\t*csc_reg5 |= CSC_BYPASS;\n}\nEXPORT_SYMBOL(csc_set_coeff_bypass);\n\n \nvoid csc_set_coeff(struct csc_data *csc, u32 *csc_reg0,\n\t\t   struct v4l2_format *src_fmt, struct v4l2_format *dst_fmt)\n{\n\tu32 *csc_reg5 = csc_reg0 + 5;\n\tu32 *shadow_csc = csc_reg0;\n\tu16 *coeff, *end_coeff;\n\tconst struct v4l2_pix_format *pix;\n\tconst struct v4l2_pix_format_mplane *mp;\n\tconst struct v4l2_format_info *src_finfo, *dst_finfo;\n\tenum v4l2_ycbcr_encoding src_ycbcr_enc, dst_ycbcr_enc;\n\tenum v4l2_quantization src_quantization, dst_quantization;\n\tu32 src_pixelformat, dst_pixelformat;\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(src_fmt->type)) {\n\t\tmp = &src_fmt->fmt.pix_mp;\n\t\tsrc_pixelformat = mp->pixelformat;\n\t\tsrc_ycbcr_enc = mp->ycbcr_enc;\n\t\tsrc_quantization = mp->quantization;\n\t} else {\n\t\tpix = &src_fmt->fmt.pix;\n\t\tsrc_pixelformat = pix->pixelformat;\n\t\tsrc_ycbcr_enc = pix->ycbcr_enc;\n\t\tsrc_quantization = pix->quantization;\n\t}\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(dst_fmt->type)) {\n\t\tmp = &dst_fmt->fmt.pix_mp;\n\t\tdst_pixelformat = mp->pixelformat;\n\t\tdst_ycbcr_enc = mp->ycbcr_enc;\n\t\tdst_quantization = mp->quantization;\n\t} else {\n\t\tpix = &dst_fmt->fmt.pix;\n\t\tdst_pixelformat = pix->pixelformat;\n\t\tdst_ycbcr_enc = pix->ycbcr_enc;\n\t\tdst_quantization = pix->quantization;\n\t}\n\n\tsrc_finfo = v4l2_format_info(src_pixelformat);\n\tdst_finfo = v4l2_format_info(dst_pixelformat);\n\n\tif (v4l2_is_format_yuv(src_finfo) &&\n\t    v4l2_is_format_rgb(dst_finfo)) {\n\t\t \n\n\t\t \n\t\tif (src_ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT)\n\t\t\tsrc_ycbcr_enc = V4L2_YCBCR_ENC_601;\n\n\t\tif (src_quantization == V4L2_QUANTIZATION_DEFAULT)\n\t\t\tsrc_quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\n\t\tif (src_ycbcr_enc == V4L2_YCBCR_ENC_601) {\n\t\t\tif (src_quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\t\tcoeff = csc_coeffs.y2r.r601.full.coeff;\n\t\t\telse\n\t\t\t\tcoeff = csc_coeffs.y2r.r601.limited.coeff;\n\t\t} else if (src_ycbcr_enc == V4L2_YCBCR_ENC_709) {\n\t\t\tif (src_quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\t\tcoeff = csc_coeffs.y2r.r709.full.coeff;\n\t\t\telse\n\t\t\t\tcoeff = csc_coeffs.y2r.r709.limited.coeff;\n\t\t} else {\n\t\t\t \n\t\t\tcoeff = csc_coeffs.y2r.r601.full.coeff;\n\t\t}\n\t} else if (v4l2_is_format_rgb(src_finfo) &&\n\t\t   v4l2_is_format_yuv(dst_finfo)) {\n\t\t \n\n\t\t \n\t\tif (dst_ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT)\n\t\t\tdst_ycbcr_enc = V4L2_YCBCR_ENC_601;\n\n\t\tif (dst_quantization == V4L2_QUANTIZATION_DEFAULT)\n\t\t\tdst_quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\n\t\tif (dst_ycbcr_enc == V4L2_YCBCR_ENC_601) {\n\t\t\tif (dst_quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\t\tcoeff = csc_coeffs.r2y.r601.full.coeff;\n\t\t\telse\n\t\t\t\tcoeff = csc_coeffs.r2y.r601.limited.coeff;\n\t\t} else if (dst_ycbcr_enc == V4L2_YCBCR_ENC_709) {\n\t\t\tif (dst_quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\t\tcoeff = csc_coeffs.r2y.r709.full.coeff;\n\t\t\telse\n\t\t\t\tcoeff = csc_coeffs.r2y.r709.limited.coeff;\n\t\t} else {\n\t\t\t \n\t\t\tcoeff = csc_coeffs.r2y.r601.full.coeff;\n\t\t}\n\t} else {\n\t\t*csc_reg5 |= CSC_BYPASS;\n\t\treturn;\n\t}\n\n\tend_coeff = coeff + 12;\n\n\tfor (; coeff < end_coeff; coeff += 2)\n\t\t*shadow_csc++ = (*(coeff + 1) << 16) | *coeff;\n}\nEXPORT_SYMBOL(csc_set_coeff);\n\nstruct csc_data *csc_create(struct platform_device *pdev, const char *res_name)\n{\n\tstruct csc_data *csc;\n\n\tdev_dbg(&pdev->dev, \"csc_create\\n\");\n\n\tcsc = devm_kzalloc(&pdev->dev, sizeof(*csc), GFP_KERNEL);\n\tif (!csc) {\n\t\tdev_err(&pdev->dev, \"couldn't alloc csc_data\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tcsc->pdev = pdev;\n\n\tcsc->res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\tres_name);\n\tif (csc->res == NULL) {\n\t\tdev_err(&pdev->dev, \"missing '%s' platform resources data\\n\",\n\t\t\tres_name);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tcsc->base = devm_ioremap_resource(&pdev->dev, csc->res);\n\tif (IS_ERR(csc->base))\n\t\treturn ERR_CAST(csc->base);\n\n\treturn csc;\n}\nEXPORT_SYMBOL(csc_create);\n\nMODULE_DESCRIPTION(\"TI VIP/VPE Color Space Converter\");\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}