{
  "module_name": "vpe.c",
  "hash_id": "d5e500334d47024881049cc41ae9141f08241c84a316b2f4d4b89702dfbca42c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/vpe/vpe.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioctl.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/log2.h>\n#include <linux/sizes.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"vpdma.h\"\n#include \"vpdma_priv.h\"\n#include \"vpe_regs.h\"\n#include \"sc.h\"\n#include \"csc.h\"\n\n#define VPE_MODULE_NAME \"vpe\"\n\n \n#define MIN_W\t\t32\n#define MIN_H\t\t32\n#define MAX_W\t\t2048\n#define MAX_H\t\t2048\n\n \n#define S_ALIGN\t\t0\t \n#define H_ALIGN\t\t1\t \n\n \n#define VPE_FMT_TYPE_CAPTURE\t(1 << 0)\n#define VPE_FMT_TYPE_OUTPUT\t(1 << 1)\n\n \n#define VPE_MAX_PLANES\t2\n#define VPE_LUMA\t0\n#define VPE_CHROMA\t1\n\n \n#define VPE_MAX_SRC_BUFS\t3\t \n\n#define VPE_DEF_BUFS_PER_JOB\t1\t \n\n \n#define VPE_DESC_LIST_SIZE\t(10 * VPDMA_DTD_DESC_SIZE +\t\\\n\t\t\t\t\t13 * VPDMA_CFD_CTD_DESC_SIZE)\n\n#define vpe_dbg(vpedev, fmt, arg...)\t\\\n\t\tdev_dbg((vpedev)->v4l2_dev.dev, fmt, ##arg)\n#define vpe_err(vpedev, fmt, arg...)\t\\\n\t\tdev_err((vpedev)->v4l2_dev.dev, fmt, ##arg)\n\nstruct vpe_us_coeffs {\n\tunsigned short\tanchor_fid0_c0;\n\tunsigned short\tanchor_fid0_c1;\n\tunsigned short\tanchor_fid0_c2;\n\tunsigned short\tanchor_fid0_c3;\n\tunsigned short\tinterp_fid0_c0;\n\tunsigned short\tinterp_fid0_c1;\n\tunsigned short\tinterp_fid0_c2;\n\tunsigned short\tinterp_fid0_c3;\n\tunsigned short\tanchor_fid1_c0;\n\tunsigned short\tanchor_fid1_c1;\n\tunsigned short\tanchor_fid1_c2;\n\tunsigned short\tanchor_fid1_c3;\n\tunsigned short\tinterp_fid1_c0;\n\tunsigned short\tinterp_fid1_c1;\n\tunsigned short\tinterp_fid1_c2;\n\tunsigned short\tinterp_fid1_c3;\n};\n\n \nstatic const struct vpe_us_coeffs us_coeffs[] = {\n\t{\n\t\t \n\t\t0x00C8, 0x0348, 0x0018, 0x3FD8, 0x3FB8, 0x0378, 0x00E8, 0x3FE8,\n\t\t0x00C8, 0x0348, 0x0018, 0x3FD8, 0x3FB8, 0x0378, 0x00E8, 0x3FE8,\n\t},\n\t{\n\t\t \n\t\t0x0051, 0x03D5, 0x3FE3, 0x3FF7, 0x3FB5, 0x02E9, 0x018F, 0x3FD3,\n\t\t \n\t\t0x016B, 0x0247, 0x00B1, 0x3F9D, 0x3FCF, 0x03DB, 0x005D, 0x3FF9,\n\t},\n};\n\n \nstruct vpe_dei_regs {\n\tunsigned long mdt_spacial_freq_thr_reg;\t\t \n\tunsigned long edi_config_reg;\t\t\t \n\tunsigned long edi_lut_reg0;\t\t\t \n\tunsigned long edi_lut_reg1;\t\t\t \n\tunsigned long edi_lut_reg2;\t\t\t \n\tunsigned long edi_lut_reg3;\t\t\t \n};\n\n \nstatic const struct vpe_dei_regs dei_regs = {\n\t.mdt_spacial_freq_thr_reg = 0x020C0804u,\n\t.edi_config_reg = 0x0118100Cu,\n\t.edi_lut_reg0 = 0x08040200u,\n\t.edi_lut_reg1 = 0x1010100Cu,\n\t.edi_lut_reg2 = 0x10101010u,\n\t.edi_lut_reg3 = 0x10101010u,\n};\n\n \nstruct vpe_port_data {\n\tenum vpdma_channel channel;\t \n\tu8\tvb_index;\t\t \n\tu8\tvb_part;\t\t \n};\n\n \n#define VPE_PORT_LUMA1_IN\t0\n#define VPE_PORT_CHROMA1_IN\t1\n#define VPE_PORT_LUMA2_IN\t2\n#define VPE_PORT_CHROMA2_IN\t3\n#define VPE_PORT_LUMA3_IN\t4\n#define VPE_PORT_CHROMA3_IN\t5\n#define VPE_PORT_MV_IN\t\t6\n#define VPE_PORT_MV_OUT\t\t7\n#define VPE_PORT_LUMA_OUT\t8\n#define VPE_PORT_CHROMA_OUT\t9\n#define VPE_PORT_RGB_OUT\t10\n\nstatic const struct vpe_port_data port_data[11] = {\n\t[VPE_PORT_LUMA1_IN] = {\n\t\t.channel\t= VPE_CHAN_LUMA1_IN,\n\t\t.vb_index\t= 0,\n\t\t.vb_part\t= VPE_LUMA,\n\t},\n\t[VPE_PORT_CHROMA1_IN] = {\n\t\t.channel\t= VPE_CHAN_CHROMA1_IN,\n\t\t.vb_index\t= 0,\n\t\t.vb_part\t= VPE_CHROMA,\n\t},\n\t[VPE_PORT_LUMA2_IN] = {\n\t\t.channel\t= VPE_CHAN_LUMA2_IN,\n\t\t.vb_index\t= 1,\n\t\t.vb_part\t= VPE_LUMA,\n\t},\n\t[VPE_PORT_CHROMA2_IN] = {\n\t\t.channel\t= VPE_CHAN_CHROMA2_IN,\n\t\t.vb_index\t= 1,\n\t\t.vb_part\t= VPE_CHROMA,\n\t},\n\t[VPE_PORT_LUMA3_IN] = {\n\t\t.channel\t= VPE_CHAN_LUMA3_IN,\n\t\t.vb_index\t= 2,\n\t\t.vb_part\t= VPE_LUMA,\n\t},\n\t[VPE_PORT_CHROMA3_IN] = {\n\t\t.channel\t= VPE_CHAN_CHROMA3_IN,\n\t\t.vb_index\t= 2,\n\t\t.vb_part\t= VPE_CHROMA,\n\t},\n\t[VPE_PORT_MV_IN] = {\n\t\t.channel\t= VPE_CHAN_MV_IN,\n\t},\n\t[VPE_PORT_MV_OUT] = {\n\t\t.channel\t= VPE_CHAN_MV_OUT,\n\t},\n\t[VPE_PORT_LUMA_OUT] = {\n\t\t.channel\t= VPE_CHAN_LUMA_OUT,\n\t\t.vb_part\t= VPE_LUMA,\n\t},\n\t[VPE_PORT_CHROMA_OUT] = {\n\t\t.channel\t= VPE_CHAN_CHROMA_OUT,\n\t\t.vb_part\t= VPE_CHROMA,\n\t},\n\t[VPE_PORT_RGB_OUT] = {\n\t\t.channel\t= VPE_CHAN_RGB_OUT,\n\t\t.vb_part\t= VPE_LUMA,\n\t},\n};\n\n\n \nstruct vpe_fmt {\n\tu32\tfourcc;\t\t\t \n\tu8\ttypes;\t\t\t \n\tu8\tcoplanar;\t\t \n\t \n\tstruct vpdma_data_format const *vpdma_fmt[VPE_MAX_PLANES];\n};\n\nstatic struct vpe_fmt vpe_formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV16,\n\t\t.types\t\t= VPE_FMT_TYPE_CAPTURE | VPE_FMT_TYPE_OUTPUT,\n\t\t.coplanar\t= 1,\n\t\t.vpdma_fmt\t= { &vpdma_yuv_fmts[VPDMA_DATA_FMT_Y444],\n\t\t\t\t    &vpdma_yuv_fmts[VPDMA_DATA_FMT_C444],\n\t\t\t\t  },\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12,\n\t\t.types\t\t= VPE_FMT_TYPE_CAPTURE | VPE_FMT_TYPE_OUTPUT,\n\t\t.coplanar\t= 1,\n\t\t.vpdma_fmt\t= { &vpdma_yuv_fmts[VPDMA_DATA_FMT_Y420],\n\t\t\t\t    &vpdma_yuv_fmts[VPDMA_DATA_FMT_C420],\n\t\t\t\t  },\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV21,\n\t\t.types\t\t= VPE_FMT_TYPE_CAPTURE | VPE_FMT_TYPE_OUTPUT,\n\t\t.coplanar\t= 1,\n\t\t.vpdma_fmt\t= { &vpdma_yuv_fmts[VPDMA_DATA_FMT_Y420],\n\t\t\t\t    &vpdma_yuv_fmts[VPDMA_DATA_FMT_CB420],\n\t\t\t\t  },\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.types\t\t= VPE_FMT_TYPE_CAPTURE | VPE_FMT_TYPE_OUTPUT,\n\t\t.coplanar\t= 0,\n\t\t.vpdma_fmt\t= { &vpdma_yuv_fmts[VPDMA_DATA_FMT_YCB422],\n\t\t\t\t  },\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_UYVY,\n\t\t.types\t\t= VPE_FMT_TYPE_CAPTURE | VPE_FMT_TYPE_OUTPUT,\n\t\t.coplanar\t= 0,\n\t\t.vpdma_fmt\t= { &vpdma_yuv_fmts[VPDMA_DATA_FMT_CBY422],\n\t\t\t\t  },\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB24,\n\t\t.types\t\t= VPE_FMT_TYPE_CAPTURE,\n\t\t.coplanar\t= 0,\n\t\t.vpdma_fmt\t= { &vpdma_rgb_fmts[VPDMA_DATA_FMT_RGB24],\n\t\t\t\t  },\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB32,\n\t\t.types\t\t= VPE_FMT_TYPE_CAPTURE,\n\t\t.coplanar\t= 0,\n\t\t.vpdma_fmt\t= { &vpdma_rgb_fmts[VPDMA_DATA_FMT_ARGB32],\n\t\t\t\t  },\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_BGR24,\n\t\t.types\t\t= VPE_FMT_TYPE_CAPTURE,\n\t\t.coplanar\t= 0,\n\t\t.vpdma_fmt\t= { &vpdma_rgb_fmts[VPDMA_DATA_FMT_BGR24],\n\t\t\t\t  },\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_BGR32,\n\t\t.types\t\t= VPE_FMT_TYPE_CAPTURE,\n\t\t.coplanar\t= 0,\n\t\t.vpdma_fmt\t= { &vpdma_rgb_fmts[VPDMA_DATA_FMT_ABGR32],\n\t\t\t\t  },\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.types\t\t= VPE_FMT_TYPE_CAPTURE,\n\t\t.coplanar\t= 0,\n\t\t.vpdma_fmt\t= { &vpdma_rgb_fmts[VPDMA_DATA_FMT_RGB565],\n\t\t\t\t  },\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB555,\n\t\t.types\t\t= VPE_FMT_TYPE_CAPTURE,\n\t\t.coplanar\t= 0,\n\t\t.vpdma_fmt\t= { &vpdma_rgb_fmts[VPDMA_DATA_FMT_RGBA16_5551],\n\t\t\t\t  },\n\t},\n};\n\n \nstruct vpe_q_data {\n\t \n\tstruct v4l2_format\tformat;\n\tunsigned int\t\tflags;\n\tstruct v4l2_rect\tc_rect;\t\t\t\t \n\tstruct vpe_fmt\t\t*fmt;\t\t\t\t \n};\n\n \n#define\tQ_DATA_FRAME_1D\t\t\tBIT(0)\n#define\tQ_DATA_MODE_TILED\t\tBIT(1)\n#define\tQ_DATA_INTERLACED_ALTERNATE\tBIT(2)\n#define\tQ_DATA_INTERLACED_SEQ_TB\tBIT(3)\n#define\tQ_DATA_INTERLACED_SEQ_BT\tBIT(4)\n\n#define Q_IS_SEQ_XX\t\t(Q_DATA_INTERLACED_SEQ_TB | \\\n\t\t\t\tQ_DATA_INTERLACED_SEQ_BT)\n\n#define Q_IS_INTERLACED\t\t(Q_DATA_INTERLACED_ALTERNATE | \\\n\t\t\t\tQ_DATA_INTERLACED_SEQ_TB | \\\n\t\t\t\tQ_DATA_INTERLACED_SEQ_BT)\n\nenum {\n\tQ_DATA_SRC = 0,\n\tQ_DATA_DST = 1,\n};\n\n \nstatic struct vpe_fmt *__find_format(u32 fourcc)\n{\n\tstruct vpe_fmt *fmt;\n\tunsigned int k;\n\n\tfor (k = 0; k < ARRAY_SIZE(vpe_formats); k++) {\n\t\tfmt = &vpe_formats[k];\n\t\tif (fmt->fourcc == fourcc)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct vpe_fmt *find_format(struct v4l2_format *f)\n{\n\treturn __find_format(f->fmt.pix.pixelformat);\n}\n\n \nstruct vpe_dev {\n\tstruct v4l2_device\tv4l2_dev;\n\tstruct video_device\tvfd;\n\tstruct v4l2_m2m_dev\t*m2m_dev;\n\n\tatomic_t\t\tnum_instances;\t \n\tdma_addr_t\t\tloaded_mmrs;\t \n\tstruct mutex\t\tdev_mutex;\n\tspinlock_t\t\tlock;\n\n\tint\t\t\tirq;\n\tvoid __iomem\t\t*base;\n\tstruct resource\t\t*res;\n\n\tstruct vpdma_data\tvpdma_data;\n\tstruct vpdma_data\t*vpdma;\t\t \n\tstruct sc_data\t\t*sc;\t\t \n\tstruct csc_data\t\t*csc;\t\t \n};\n\n \nstruct vpe_ctx {\n\tstruct v4l2_fh\t\tfh;\n\tstruct vpe_dev\t\t*dev;\n\tstruct v4l2_ctrl_handler hdl;\n\n\tunsigned int\t\tfield;\t\t\t \n\tunsigned int\t\tsequence;\t\t \n\tunsigned int\t\taborting;\t\t \n\n\tunsigned int\t\tbufs_per_job;\t\t \n\tunsigned int\t\tbufs_completed;\t\t \n\n\tstruct vpe_q_data\tq_data[2];\t\t \n\tstruct vb2_v4l2_buffer\t*src_vbs[VPE_MAX_SRC_BUFS];\n\tstruct vb2_v4l2_buffer\t*dst_vb;\n\n\tdma_addr_t\t\tmv_buf_dma[2];\t\t \n\tvoid\t\t\t*mv_buf[2];\t\t \n\tsize_t\t\t\tmv_buf_size;\t\t \n\tstruct vpdma_buf\tmmr_adb;\t\t \n\tstruct vpdma_buf\tsc_coeff_h;\t\t \n\tstruct vpdma_buf\tsc_coeff_v;\t\t \n\tstruct vpdma_desc_list\tdesc_list;\t\t \n\n\tbool\t\t\tdeinterlacing;\t\t \n\tbool\t\t\tload_mmrs;\t\t \n\n\tunsigned int\t\tsrc_mv_buf_selector;\n};\n\n\n \nstatic struct vpe_q_data *get_q_data(struct vpe_ctx *ctx,\n\t\t\t\t     enum v4l2_buf_type type)\n{\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\treturn &ctx->q_data[Q_DATA_SRC];\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn &ctx->q_data[Q_DATA_DST];\n\tdefault:\n\t\treturn NULL;\n\t}\n\treturn NULL;\n}\n\nstatic u32 read_reg(struct vpe_dev *dev, int offset)\n{\n\treturn ioread32(dev->base + offset);\n}\n\nstatic void write_reg(struct vpe_dev *dev, int offset, u32 value)\n{\n\tiowrite32(value, dev->base + offset);\n}\n\n \nstatic int get_field(u32 value, u32 mask, int shift)\n{\n\treturn (value & (mask << shift)) >> shift;\n}\n\nstatic int read_field_reg(struct vpe_dev *dev, int offset, u32 mask, int shift)\n{\n\treturn get_field(read_reg(dev, offset), mask, shift);\n}\n\nstatic void write_field(u32 *valp, u32 field, u32 mask, int shift)\n{\n\tu32 val = *valp;\n\n\tval &= ~(mask << shift);\n\tval |= (field & mask) << shift;\n\t*valp = val;\n}\n\nstatic void write_field_reg(struct vpe_dev *dev, int offset, u32 field,\n\t\tu32 mask, int shift)\n{\n\tu32 val = read_reg(dev, offset);\n\n\twrite_field(&val, field, mask, shift);\n\n\twrite_reg(dev, offset, val);\n}\n\n \nstruct vpe_mmr_adb {\n\tstruct vpdma_adb_hdr\tout_fmt_hdr;\n\tu32\t\t\tout_fmt_reg[1];\n\tu32\t\t\tout_fmt_pad[3];\n\tstruct vpdma_adb_hdr\tus1_hdr;\n\tu32\t\t\tus1_regs[8];\n\tstruct vpdma_adb_hdr\tus2_hdr;\n\tu32\t\t\tus2_regs[8];\n\tstruct vpdma_adb_hdr\tus3_hdr;\n\tu32\t\t\tus3_regs[8];\n\tstruct vpdma_adb_hdr\tdei_hdr;\n\tu32\t\t\tdei_regs[8];\n\tstruct vpdma_adb_hdr\tsc_hdr0;\n\tu32\t\t\tsc_regs0[7];\n\tu32\t\t\tsc_pad0[1];\n\tstruct vpdma_adb_hdr\tsc_hdr8;\n\tu32\t\t\tsc_regs8[6];\n\tu32\t\t\tsc_pad8[2];\n\tstruct vpdma_adb_hdr\tsc_hdr17;\n\tu32\t\t\tsc_regs17[9];\n\tu32\t\t\tsc_pad17[3];\n\tstruct vpdma_adb_hdr\tcsc_hdr;\n\tu32\t\t\tcsc_regs[6];\n\tu32\t\t\tcsc_pad[2];\n};\n\n#define GET_OFFSET_TOP(ctx, obj, reg)\t\\\n\t((obj)->res->start - ctx->dev->res->start + reg)\n\n#define VPE_SET_MMR_ADB_HDR(ctx, hdr, regs, offset_a)\t\\\n\tVPDMA_SET_MMR_ADB_HDR(ctx->mmr_adb, vpe_mmr_adb, hdr, regs, offset_a)\n \nstatic void init_adb_hdrs(struct vpe_ctx *ctx)\n{\n\tVPE_SET_MMR_ADB_HDR(ctx, out_fmt_hdr, out_fmt_reg, VPE_CLK_FORMAT_SELECT);\n\tVPE_SET_MMR_ADB_HDR(ctx, us1_hdr, us1_regs, VPE_US1_R0);\n\tVPE_SET_MMR_ADB_HDR(ctx, us2_hdr, us2_regs, VPE_US2_R0);\n\tVPE_SET_MMR_ADB_HDR(ctx, us3_hdr, us3_regs, VPE_US3_R0);\n\tVPE_SET_MMR_ADB_HDR(ctx, dei_hdr, dei_regs, VPE_DEI_FRAME_SIZE);\n\tVPE_SET_MMR_ADB_HDR(ctx, sc_hdr0, sc_regs0,\n\t\tGET_OFFSET_TOP(ctx, ctx->dev->sc, CFG_SC0));\n\tVPE_SET_MMR_ADB_HDR(ctx, sc_hdr8, sc_regs8,\n\t\tGET_OFFSET_TOP(ctx, ctx->dev->sc, CFG_SC8));\n\tVPE_SET_MMR_ADB_HDR(ctx, sc_hdr17, sc_regs17,\n\t\tGET_OFFSET_TOP(ctx, ctx->dev->sc, CFG_SC17));\n\tVPE_SET_MMR_ADB_HDR(ctx, csc_hdr, csc_regs,\n\t\tGET_OFFSET_TOP(ctx, ctx->dev->csc, CSC_CSC00));\n};\n\n \nstatic int realloc_mv_buffers(struct vpe_ctx *ctx, size_t size)\n{\n\tstruct device *dev = ctx->dev->v4l2_dev.dev;\n\n\tif (ctx->mv_buf_size == size)\n\t\treturn 0;\n\n\tif (ctx->mv_buf[0])\n\t\tdma_free_coherent(dev, ctx->mv_buf_size, ctx->mv_buf[0],\n\t\t\tctx->mv_buf_dma[0]);\n\n\tif (ctx->mv_buf[1])\n\t\tdma_free_coherent(dev, ctx->mv_buf_size, ctx->mv_buf[1],\n\t\t\tctx->mv_buf_dma[1]);\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tctx->mv_buf[0] = dma_alloc_coherent(dev, size, &ctx->mv_buf_dma[0],\n\t\t\t\tGFP_KERNEL);\n\tif (!ctx->mv_buf[0]) {\n\t\tvpe_err(ctx->dev, \"failed to allocate motion vector buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->mv_buf[1] = dma_alloc_coherent(dev, size, &ctx->mv_buf_dma[1],\n\t\t\t\tGFP_KERNEL);\n\tif (!ctx->mv_buf[1]) {\n\t\tvpe_err(ctx->dev, \"failed to allocate motion vector buffer\\n\");\n\t\tdma_free_coherent(dev, size, ctx->mv_buf[0],\n\t\t\tctx->mv_buf_dma[0]);\n\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->mv_buf_size = size;\n\tctx->src_mv_buf_selector = 0;\n\n\treturn 0;\n}\n\nstatic void free_mv_buffers(struct vpe_ctx *ctx)\n{\n\trealloc_mv_buffers(ctx, 0);\n}\n\n \nstatic void free_vbs(struct vpe_ctx *ctx)\n{\n\tstruct vpe_dev *dev = ctx->dev;\n\tunsigned long flags;\n\n\tif (ctx->src_vbs[2] == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (ctx->src_vbs[2]) {\n\t\tv4l2_m2m_buf_done(ctx->src_vbs[2], VB2_BUF_STATE_DONE);\n\t\tif (ctx->src_vbs[1] && (ctx->src_vbs[1] != ctx->src_vbs[2]))\n\t\t\tv4l2_m2m_buf_done(ctx->src_vbs[1], VB2_BUF_STATE_DONE);\n\t\tctx->src_vbs[2] = NULL;\n\t\tctx->src_vbs[1] = NULL;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\n\n \nstatic void vpe_set_clock_enable(struct vpe_dev *dev, bool on)\n{\n\tu32 val = 0;\n\n\tif (on)\n\t\tval = VPE_DATA_PATH_CLK_ENABLE | VPE_VPEDMA_CLK_ENABLE;\n\twrite_reg(dev, VPE_CLK_ENABLE, val);\n}\n\nstatic void vpe_top_reset(struct vpe_dev *dev)\n{\n\n\twrite_field_reg(dev, VPE_CLK_RESET, 1, VPE_DATA_PATH_CLK_RESET_MASK,\n\t\tVPE_DATA_PATH_CLK_RESET_SHIFT);\n\n\tusleep_range(100, 150);\n\n\twrite_field_reg(dev, VPE_CLK_RESET, 0, VPE_DATA_PATH_CLK_RESET_MASK,\n\t\tVPE_DATA_PATH_CLK_RESET_SHIFT);\n}\n\nstatic void vpe_top_vpdma_reset(struct vpe_dev *dev)\n{\n\twrite_field_reg(dev, VPE_CLK_RESET, 1, VPE_VPDMA_CLK_RESET_MASK,\n\t\tVPE_VPDMA_CLK_RESET_SHIFT);\n\n\tusleep_range(100, 150);\n\n\twrite_field_reg(dev, VPE_CLK_RESET, 0, VPE_VPDMA_CLK_RESET_MASK,\n\t\tVPE_VPDMA_CLK_RESET_SHIFT);\n}\n\n \nstatic void set_us_coefficients(struct vpe_ctx *ctx)\n{\n\tstruct vpe_mmr_adb *mmr_adb = ctx->mmr_adb.addr;\n\tstruct vpe_q_data *s_q_data = &ctx->q_data[Q_DATA_SRC];\n\tu32 *us1_reg = &mmr_adb->us1_regs[0];\n\tu32 *us2_reg = &mmr_adb->us2_regs[0];\n\tu32 *us3_reg = &mmr_adb->us3_regs[0];\n\tconst unsigned short *cp, *end_cp;\n\n\tcp = &us_coeffs[0].anchor_fid0_c0;\n\n\tif (s_q_data->flags & Q_IS_INTERLACED)\t\t \n\t\tcp += sizeof(us_coeffs[0]) / sizeof(*cp);\n\n\tend_cp = cp + sizeof(us_coeffs[0]) / sizeof(*cp);\n\n\twhile (cp < end_cp) {\n\t\twrite_field(us1_reg, *cp++, VPE_US_C0_MASK, VPE_US_C0_SHIFT);\n\t\twrite_field(us1_reg, *cp++, VPE_US_C1_MASK, VPE_US_C1_SHIFT);\n\t\t*us2_reg++ = *us1_reg;\n\t\t*us3_reg++ = *us1_reg++;\n\t}\n\tctx->load_mmrs = true;\n}\n\n \nstatic void set_cfg_modes(struct vpe_ctx *ctx)\n{\n\tstruct vpe_fmt *fmt = ctx->q_data[Q_DATA_SRC].fmt;\n\tstruct vpe_mmr_adb *mmr_adb = ctx->mmr_adb.addr;\n\tu32 *us1_reg0 = &mmr_adb->us1_regs[0];\n\tu32 *us2_reg0 = &mmr_adb->us2_regs[0];\n\tu32 *us3_reg0 = &mmr_adb->us3_regs[0];\n\tint cfg_mode = 1;\n\n\t \n\n\tif (fmt->fourcc == V4L2_PIX_FMT_NV12 ||\n\t    fmt->fourcc == V4L2_PIX_FMT_NV21)\n\t\tcfg_mode = 0;\n\n\twrite_field(us1_reg0, cfg_mode, VPE_US_MODE_MASK, VPE_US_MODE_SHIFT);\n\twrite_field(us2_reg0, cfg_mode, VPE_US_MODE_MASK, VPE_US_MODE_SHIFT);\n\twrite_field(us3_reg0, cfg_mode, VPE_US_MODE_MASK, VPE_US_MODE_SHIFT);\n\n\tctx->load_mmrs = true;\n}\n\nstatic void set_line_modes(struct vpe_ctx *ctx)\n{\n\tstruct vpe_fmt *fmt = ctx->q_data[Q_DATA_SRC].fmt;\n\tint line_mode = 1;\n\n\tif (fmt->fourcc == V4L2_PIX_FMT_NV12 ||\n\t    fmt->fourcc == V4L2_PIX_FMT_NV21)\n\t\tline_mode = 0;\t\t \n\n\t \n\tvpdma_set_line_mode(ctx->dev->vpdma, line_mode, VPE_CHAN_CHROMA1_IN);\n\tvpdma_set_line_mode(ctx->dev->vpdma, line_mode, VPE_CHAN_CHROMA2_IN);\n\tvpdma_set_line_mode(ctx->dev->vpdma, line_mode, VPE_CHAN_CHROMA3_IN);\n\n\t \n\tvpdma_set_frame_start_event(ctx->dev->vpdma, VPDMA_FSEVENT_CHANNEL_ACTIVE,\n\t\tVPE_CHAN_LUMA1_IN);\n\tvpdma_set_frame_start_event(ctx->dev->vpdma, VPDMA_FSEVENT_CHANNEL_ACTIVE,\n\t\tVPE_CHAN_LUMA2_IN);\n\tvpdma_set_frame_start_event(ctx->dev->vpdma, VPDMA_FSEVENT_CHANNEL_ACTIVE,\n\t\tVPE_CHAN_LUMA3_IN);\n\n\t \n\tvpdma_set_frame_start_event(ctx->dev->vpdma, VPDMA_FSEVENT_CHANNEL_ACTIVE,\n\t\tVPE_CHAN_CHROMA1_IN);\n\tvpdma_set_frame_start_event(ctx->dev->vpdma, VPDMA_FSEVENT_CHANNEL_ACTIVE,\n\t\tVPE_CHAN_CHROMA2_IN);\n\tvpdma_set_frame_start_event(ctx->dev->vpdma, VPDMA_FSEVENT_CHANNEL_ACTIVE,\n\t\tVPE_CHAN_CHROMA3_IN);\n\n\t \n\tvpdma_set_frame_start_event(ctx->dev->vpdma, VPDMA_FSEVENT_CHANNEL_ACTIVE,\n\t\tVPE_CHAN_MV_IN);\n}\n\n \nstatic void set_src_registers(struct vpe_ctx *ctx)\n{\n\tset_us_coefficients(ctx);\n}\n\n \nstatic void set_dst_registers(struct vpe_ctx *ctx)\n{\n\tstruct vpe_mmr_adb *mmr_adb = ctx->mmr_adb.addr;\n\tstruct vpe_fmt *fmt = ctx->q_data[Q_DATA_DST].fmt;\n\tconst struct v4l2_format_info *finfo;\n\tu32 val = 0;\n\n\tfinfo = v4l2_format_info(fmt->fourcc);\n\tif (v4l2_is_format_rgb(finfo)) {\n\t\tval |= VPE_RGB_OUT_SELECT;\n\t\tvpdma_set_bg_color(ctx->dev->vpdma,\n\t\t\t(struct vpdma_data_format *)fmt->vpdma_fmt[0], 0xff);\n\t} else if (fmt->fourcc == V4L2_PIX_FMT_NV16)\n\t\tval |= VPE_COLOR_SEPARATE_422;\n\n\t \n\tval |= VPE_DS_SRC_DEI_SCALER | VPE_CSC_SRC_DEI_SCALER;\n\n\tif (fmt->fourcc != V4L2_PIX_FMT_NV12 &&\n\t    fmt->fourcc != V4L2_PIX_FMT_NV21)\n\t\tval |= VPE_DS_BYPASS;\n\n\tmmr_adb->out_fmt_reg[0] = val;\n\n\tctx->load_mmrs = true;\n}\n\n \nstatic void set_dei_regs(struct vpe_ctx *ctx)\n{\n\tstruct vpe_mmr_adb *mmr_adb = ctx->mmr_adb.addr;\n\tstruct vpe_q_data *s_q_data = &ctx->q_data[Q_DATA_SRC];\n\tunsigned int src_h = s_q_data->c_rect.height;\n\tunsigned int src_w = s_q_data->c_rect.width;\n\tu32 *dei_mmr0 = &mmr_adb->dei_regs[0];\n\tbool deinterlace = true;\n\tu32 val = 0;\n\n\t \n\tif (!(s_q_data->flags & Q_IS_INTERLACED) || !ctx->deinterlacing) {\n\t\tdeinterlace = false;\n\t\tval = VPE_DEI_INTERLACE_BYPASS;\n\t}\n\n\tsrc_h = deinterlace ? src_h * 2 : src_h;\n\n\tval |= (src_h << VPE_DEI_HEIGHT_SHIFT) |\n\t\t(src_w << VPE_DEI_WIDTH_SHIFT) |\n\t\tVPE_DEI_FIELD_FLUSH;\n\n\t*dei_mmr0 = val;\n\n\tctx->load_mmrs = true;\n}\n\nstatic void set_dei_shadow_registers(struct vpe_ctx *ctx)\n{\n\tstruct vpe_mmr_adb *mmr_adb = ctx->mmr_adb.addr;\n\tu32 *dei_mmr = &mmr_adb->dei_regs[0];\n\tconst struct vpe_dei_regs *cur = &dei_regs;\n\n\tdei_mmr[2]  = cur->mdt_spacial_freq_thr_reg;\n\tdei_mmr[3]  = cur->edi_config_reg;\n\tdei_mmr[4]  = cur->edi_lut_reg0;\n\tdei_mmr[5]  = cur->edi_lut_reg1;\n\tdei_mmr[6]  = cur->edi_lut_reg2;\n\tdei_mmr[7]  = cur->edi_lut_reg3;\n\n\tctx->load_mmrs = true;\n}\n\nstatic void config_edi_input_mode(struct vpe_ctx *ctx, int mode)\n{\n\tstruct vpe_mmr_adb *mmr_adb = ctx->mmr_adb.addr;\n\tu32 *edi_config_reg = &mmr_adb->dei_regs[3];\n\n\tif (mode & 0x2)\n\t\twrite_field(edi_config_reg, 1, 1, 2);\t \n\n\tif (mode & 0x3)\n\t\twrite_field(edi_config_reg, 1, 1, 3);\t \n\n\twrite_field(edi_config_reg, mode, VPE_EDI_INP_MODE_MASK,\n\t\tVPE_EDI_INP_MODE_SHIFT);\n\n\tctx->load_mmrs = true;\n}\n\n \nstatic int set_srcdst_params(struct vpe_ctx *ctx)\n{\n\tstruct vpe_q_data *s_q_data =  &ctx->q_data[Q_DATA_SRC];\n\tstruct vpe_q_data *d_q_data =  &ctx->q_data[Q_DATA_DST];\n\tstruct vpe_mmr_adb *mmr_adb = ctx->mmr_adb.addr;\n\tunsigned int src_w = s_q_data->c_rect.width;\n\tunsigned int src_h = s_q_data->c_rect.height;\n\tunsigned int dst_w = d_q_data->c_rect.width;\n\tunsigned int dst_h = d_q_data->c_rect.height;\n\tstruct v4l2_pix_format_mplane *spix;\n\tsize_t mv_buf_size;\n\tint ret;\n\n\tctx->sequence = 0;\n\tctx->field = V4L2_FIELD_TOP;\n\tspix = &s_q_data->format.fmt.pix_mp;\n\n\tif ((s_q_data->flags & Q_IS_INTERLACED) &&\n\t\t\t!(d_q_data->flags & Q_IS_INTERLACED)) {\n\t\tint bytes_per_line;\n\t\tconst struct vpdma_data_format *mv =\n\t\t\t&vpdma_misc_fmts[VPDMA_DATA_FMT_MV];\n\n\t\t \n\t\tbytes_per_line = ALIGN((spix->width * mv->depth) >> 3,\n\t\t\t\t       VPDMA_STRIDE_ALIGN);\n\t\tmv_buf_size = bytes_per_line * spix->height;\n\n\t\tctx->deinterlacing = true;\n\t\tsrc_h <<= 1;\n\t} else {\n\t\tctx->deinterlacing = false;\n\t\tmv_buf_size = 0;\n\t}\n\n\tfree_vbs(ctx);\n\tctx->src_vbs[2] = ctx->src_vbs[1] = ctx->src_vbs[0] = NULL;\n\n\tret = realloc_mv_buffers(ctx, mv_buf_size);\n\tif (ret)\n\t\treturn ret;\n\n\tset_cfg_modes(ctx);\n\tset_dei_regs(ctx);\n\n\tcsc_set_coeff(ctx->dev->csc, &mmr_adb->csc_regs[0],\n\t\t      &s_q_data->format, &d_q_data->format);\n\n\tsc_set_hs_coeffs(ctx->dev->sc, ctx->sc_coeff_h.addr, src_w, dst_w);\n\tsc_set_vs_coeffs(ctx->dev->sc, ctx->sc_coeff_v.addr, src_h, dst_h);\n\n\tsc_config_scaler(ctx->dev->sc, &mmr_adb->sc_regs0[0],\n\t\t&mmr_adb->sc_regs8[0], &mmr_adb->sc_regs17[0],\n\t\tsrc_w, src_h, dst_w, dst_h);\n\n\treturn 0;\n}\n\n \n\n \nstatic int job_ready(void *priv)\n{\n\tstruct vpe_ctx *ctx = priv;\n\n\t \n\tif (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) <= 0 ||\n\t\tv4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) <= 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void job_abort(void *priv)\n{\n\tstruct vpe_ctx *ctx = priv;\n\n\t \n\tctx->aborting = 1;\n}\n\nstatic void vpe_dump_regs(struct vpe_dev *dev)\n{\n#define DUMPREG(r) vpe_dbg(dev, \"%-35s %08x\\n\", #r, read_reg(dev, VPE_##r))\n\n\tvpe_dbg(dev, \"VPE Registers:\\n\");\n\n\tDUMPREG(PID);\n\tDUMPREG(SYSCONFIG);\n\tDUMPREG(INT0_STATUS0_RAW);\n\tDUMPREG(INT0_STATUS0);\n\tDUMPREG(INT0_ENABLE0);\n\tDUMPREG(INT0_STATUS1_RAW);\n\tDUMPREG(INT0_STATUS1);\n\tDUMPREG(INT0_ENABLE1);\n\tDUMPREG(CLK_ENABLE);\n\tDUMPREG(CLK_RESET);\n\tDUMPREG(CLK_FORMAT_SELECT);\n\tDUMPREG(CLK_RANGE_MAP);\n\tDUMPREG(US1_R0);\n\tDUMPREG(US1_R1);\n\tDUMPREG(US1_R2);\n\tDUMPREG(US1_R3);\n\tDUMPREG(US1_R4);\n\tDUMPREG(US1_R5);\n\tDUMPREG(US1_R6);\n\tDUMPREG(US1_R7);\n\tDUMPREG(US2_R0);\n\tDUMPREG(US2_R1);\n\tDUMPREG(US2_R2);\n\tDUMPREG(US2_R3);\n\tDUMPREG(US2_R4);\n\tDUMPREG(US2_R5);\n\tDUMPREG(US2_R6);\n\tDUMPREG(US2_R7);\n\tDUMPREG(US3_R0);\n\tDUMPREG(US3_R1);\n\tDUMPREG(US3_R2);\n\tDUMPREG(US3_R3);\n\tDUMPREG(US3_R4);\n\tDUMPREG(US3_R5);\n\tDUMPREG(US3_R6);\n\tDUMPREG(US3_R7);\n\tDUMPREG(DEI_FRAME_SIZE);\n\tDUMPREG(MDT_BYPASS);\n\tDUMPREG(MDT_SF_THRESHOLD);\n\tDUMPREG(EDI_CONFIG);\n\tDUMPREG(DEI_EDI_LUT_R0);\n\tDUMPREG(DEI_EDI_LUT_R1);\n\tDUMPREG(DEI_EDI_LUT_R2);\n\tDUMPREG(DEI_EDI_LUT_R3);\n\tDUMPREG(DEI_FMD_WINDOW_R0);\n\tDUMPREG(DEI_FMD_WINDOW_R1);\n\tDUMPREG(DEI_FMD_CONTROL_R0);\n\tDUMPREG(DEI_FMD_CONTROL_R1);\n\tDUMPREG(DEI_FMD_STATUS_R0);\n\tDUMPREG(DEI_FMD_STATUS_R1);\n\tDUMPREG(DEI_FMD_STATUS_R2);\n#undef DUMPREG\n\n\tsc_dump_regs(dev->sc);\n\tcsc_dump_regs(dev->csc);\n}\n\nstatic void add_out_dtd(struct vpe_ctx *ctx, int port)\n{\n\tstruct vpe_q_data *q_data = &ctx->q_data[Q_DATA_DST];\n\tconst struct vpe_port_data *p_data = &port_data[port];\n\tstruct vb2_buffer *vb = &ctx->dst_vb->vb2_buf;\n\tstruct vpe_fmt *fmt = q_data->fmt;\n\tconst struct vpdma_data_format *vpdma_fmt;\n\tint mv_buf_selector = !ctx->src_mv_buf_selector;\n\tstruct v4l2_pix_format_mplane *pix;\n\tdma_addr_t dma_addr;\n\tu32 flags = 0;\n\tu32 offset = 0;\n\tu32 stride;\n\n\tif (port == VPE_PORT_MV_OUT) {\n\t\tvpdma_fmt = &vpdma_misc_fmts[VPDMA_DATA_FMT_MV];\n\t\tdma_addr = ctx->mv_buf_dma[mv_buf_selector];\n\t\tq_data = &ctx->q_data[Q_DATA_SRC];\n\t\tpix = &q_data->format.fmt.pix_mp;\n\t\tstride = ALIGN((pix->width * vpdma_fmt->depth) >> 3,\n\t\t\t       VPDMA_STRIDE_ALIGN);\n\t} else {\n\t\t \n\t\tint plane = fmt->coplanar ? p_data->vb_part : 0;\n\n\t\tpix = &q_data->format.fmt.pix_mp;\n\t\tvpdma_fmt = fmt->vpdma_fmt[plane];\n\t\t \n\t\tif (pix->num_planes == 1 && plane) {\n\t\t\tdma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\t\t\t \n\t\t\toffset = pix->plane_fmt[0].bytesperline * pix->height;\n\t\t} else {\n\t\t\tdma_addr = vb2_dma_contig_plane_dma_addr(vb, plane);\n\t\t\t \n\t\t\toffset = 0;\n\t\t}\n\t\tif (!dma_addr) {\n\t\t\tvpe_err(ctx->dev,\n\t\t\t\t\"acquiring output buffer(%d) dma_addr failed\\n\",\n\t\t\t\tport);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tdma_addr += offset;\n\t\tstride = pix->plane_fmt[VPE_LUMA].bytesperline;\n\t}\n\n\tif (q_data->flags & Q_DATA_FRAME_1D)\n\t\tflags |= VPDMA_DATA_FRAME_1D;\n\tif (q_data->flags & Q_DATA_MODE_TILED)\n\t\tflags |= VPDMA_DATA_MODE_TILED;\n\n\tvpdma_set_max_size(ctx->dev->vpdma, VPDMA_MAX_SIZE1,\n\t\t\t   MAX_W, MAX_H);\n\n\tvpdma_add_out_dtd(&ctx->desc_list, pix->width,\n\t\t\t  stride, &q_data->c_rect,\n\t\t\t  vpdma_fmt, dma_addr, MAX_OUT_WIDTH_REG1,\n\t\t\t  MAX_OUT_HEIGHT_REG1, p_data->channel, flags);\n}\n\nstatic void add_in_dtd(struct vpe_ctx *ctx, int port)\n{\n\tstruct vpe_q_data *q_data = &ctx->q_data[Q_DATA_SRC];\n\tconst struct vpe_port_data *p_data = &port_data[port];\n\tstruct vb2_buffer *vb = &ctx->src_vbs[p_data->vb_index]->vb2_buf;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vpe_fmt *fmt = q_data->fmt;\n\tstruct v4l2_pix_format_mplane *pix;\n\tconst struct vpdma_data_format *vpdma_fmt;\n\tint mv_buf_selector = ctx->src_mv_buf_selector;\n\tint field = vbuf->field == V4L2_FIELD_BOTTOM;\n\tint frame_width, frame_height;\n\tdma_addr_t dma_addr;\n\tu32 flags = 0;\n\tu32 offset = 0;\n\tu32 stride;\n\n\tpix = &q_data->format.fmt.pix_mp;\n\tif (port == VPE_PORT_MV_IN) {\n\t\tvpdma_fmt = &vpdma_misc_fmts[VPDMA_DATA_FMT_MV];\n\t\tdma_addr = ctx->mv_buf_dma[mv_buf_selector];\n\t\tstride = ALIGN((pix->width * vpdma_fmt->depth) >> 3,\n\t\t\t       VPDMA_STRIDE_ALIGN);\n\t} else {\n\t\t \n\t\tint plane = fmt->coplanar ? p_data->vb_part : 0;\n\n\t\tvpdma_fmt = fmt->vpdma_fmt[plane];\n\t\t \n\t\tif (pix->num_planes == 1 && plane) {\n\t\t\tdma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\t\t\t \n\t\t\toffset = pix->plane_fmt[0].bytesperline * pix->height;\n\t\t} else {\n\t\t\tdma_addr = vb2_dma_contig_plane_dma_addr(vb, plane);\n\t\t\t \n\t\t\toffset = 0;\n\t\t}\n\t\tif (!dma_addr) {\n\t\t\tvpe_err(ctx->dev,\n\t\t\t\t\"acquiring output buffer(%d) dma_addr failed\\n\",\n\t\t\t\tport);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tdma_addr += offset;\n\t\tstride = pix->plane_fmt[VPE_LUMA].bytesperline;\n\n\t\t \n\t\tif (q_data->flags & Q_DATA_INTERLACED_SEQ_TB ||\n\t\t    q_data->flags & Q_DATA_INTERLACED_SEQ_BT) {\n\t\t\t \n\t\t\tif (q_data->flags & Q_DATA_INTERLACED_SEQ_BT)\n\t\t\t\tfield = 1;\n\t\t\telse\n\t\t\t\tfield = 0;\n\n\t\t\t \n\t\t\tfield = (field + p_data->vb_index + ctx->sequence) % 2;\n\n\t\t\tif (field) {\n\t\t\t\tint height = pix->height / 2;\n\t\t\t\tint bpp;\n\n\t\t\t\tif (fmt->fourcc == V4L2_PIX_FMT_NV12 ||\n\t\t\t\t    fmt->fourcc == V4L2_PIX_FMT_NV21)\n\t\t\t\t\tbpp = 1;\n\t\t\t\telse\n\t\t\t\t\tbpp = vpdma_fmt->depth >> 3;\n\n\t\t\t\tif (plane)\n\t\t\t\t\theight /= 2;\n\n\t\t\t\tdma_addr += pix->width * height * bpp;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (q_data->flags & Q_DATA_FRAME_1D)\n\t\tflags |= VPDMA_DATA_FRAME_1D;\n\tif (q_data->flags & Q_DATA_MODE_TILED)\n\t\tflags |= VPDMA_DATA_MODE_TILED;\n\n\tframe_width = q_data->c_rect.width;\n\tframe_height = q_data->c_rect.height;\n\n\tif (p_data->vb_part && (fmt->fourcc == V4L2_PIX_FMT_NV12 ||\n\t\t\t\tfmt->fourcc == V4L2_PIX_FMT_NV21))\n\t\tframe_height /= 2;\n\n\tvpdma_add_in_dtd(&ctx->desc_list, pix->width, stride,\n\t\t\t &q_data->c_rect, vpdma_fmt, dma_addr,\n\t\t\t p_data->channel, field, flags, frame_width,\n\t\t\t frame_height, 0, 0);\n}\n\n \nstatic void enable_irqs(struct vpe_ctx *ctx)\n{\n\twrite_reg(ctx->dev, VPE_INT0_ENABLE0_SET, VPE_INT0_LIST0_COMPLETE);\n\twrite_reg(ctx->dev, VPE_INT0_ENABLE1_SET, VPE_DEI_ERROR_INT |\n\t\t\t\tVPE_DS1_UV_ERROR_INT);\n\n\tvpdma_enable_list_complete_irq(ctx->dev->vpdma, 0, 0, true);\n}\n\nstatic void disable_irqs(struct vpe_ctx *ctx)\n{\n\twrite_reg(ctx->dev, VPE_INT0_ENABLE0_CLR, 0xffffffff);\n\twrite_reg(ctx->dev, VPE_INT0_ENABLE1_CLR, 0xffffffff);\n\n\tvpdma_enable_list_complete_irq(ctx->dev->vpdma, 0, 0, false);\n}\n\n \nstatic void device_run(void *priv)\n{\n\tstruct vpe_ctx *ctx = priv;\n\tstruct sc_data *sc = ctx->dev->sc;\n\tstruct vpe_q_data *d_q_data = &ctx->q_data[Q_DATA_DST];\n\tstruct vpe_q_data *s_q_data = &ctx->q_data[Q_DATA_SRC];\n\tconst struct v4l2_format_info *d_finfo;\n\n\td_finfo = v4l2_format_info(d_q_data->fmt->fourcc);\n\n\tif (ctx->deinterlacing && s_q_data->flags & Q_IS_SEQ_XX &&\n\t    ctx->sequence % 2 == 0) {\n\t\t \n\t\tctx->src_vbs[0] = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\t\tWARN_ON(ctx->src_vbs[0] == NULL);\n\t} else {\n\t\tctx->src_vbs[0] = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\tWARN_ON(ctx->src_vbs[0] == NULL);\n\t}\n\n\tctx->dst_vb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tWARN_ON(ctx->dst_vb == NULL);\n\n\tif (ctx->deinterlacing) {\n\n\t\tif (ctx->src_vbs[2] == NULL) {\n\t\t\tctx->src_vbs[2] = ctx->src_vbs[0];\n\t\t\tWARN_ON(ctx->src_vbs[2] == NULL);\n\t\t\tctx->src_vbs[1] = ctx->src_vbs[0];\n\t\t\tWARN_ON(ctx->src_vbs[1] == NULL);\n\t\t}\n\n\t\t \n\t\tif (ctx->sequence == 2)\n\t\t\tconfig_edi_input_mode(ctx, 0x3);  \n\t}\n\n\t \n\tif (ctx->dev->loaded_mmrs != ctx->mmr_adb.dma_addr || ctx->load_mmrs) {\n\t\tvpdma_map_desc_buf(ctx->dev->vpdma, &ctx->mmr_adb);\n\t\tvpdma_add_cfd_adb(&ctx->desc_list, CFD_MMR_CLIENT, &ctx->mmr_adb);\n\n\t\tset_line_modes(ctx);\n\n\t\tctx->dev->loaded_mmrs = ctx->mmr_adb.dma_addr;\n\t\tctx->load_mmrs = false;\n\t}\n\n\tif (sc->loaded_coeff_h != ctx->sc_coeff_h.dma_addr ||\n\t\t\tsc->load_coeff_h) {\n\t\tvpdma_map_desc_buf(ctx->dev->vpdma, &ctx->sc_coeff_h);\n\t\tvpdma_add_cfd_block(&ctx->desc_list, CFD_SC_CLIENT,\n\t\t\t&ctx->sc_coeff_h, 0);\n\n\t\tsc->loaded_coeff_h = ctx->sc_coeff_h.dma_addr;\n\t\tsc->load_coeff_h = false;\n\t}\n\n\tif (sc->loaded_coeff_v != ctx->sc_coeff_v.dma_addr ||\n\t\t\tsc->load_coeff_v) {\n\t\tvpdma_map_desc_buf(ctx->dev->vpdma, &ctx->sc_coeff_v);\n\t\tvpdma_add_cfd_block(&ctx->desc_list, CFD_SC_CLIENT,\n\t\t\t&ctx->sc_coeff_v, SC_COEF_SRAM_SIZE >> 4);\n\n\t\tsc->loaded_coeff_v = ctx->sc_coeff_v.dma_addr;\n\t\tsc->load_coeff_v = false;\n\t}\n\n\t \n\tif (ctx->deinterlacing)\n\t\tadd_out_dtd(ctx, VPE_PORT_MV_OUT);\n\n\tif (v4l2_is_format_rgb(d_finfo)) {\n\t\tadd_out_dtd(ctx, VPE_PORT_RGB_OUT);\n\t} else {\n\t\tadd_out_dtd(ctx, VPE_PORT_LUMA_OUT);\n\t\tif (d_q_data->fmt->coplanar)\n\t\t\tadd_out_dtd(ctx, VPE_PORT_CHROMA_OUT);\n\t}\n\n\t \n\tif (ctx->deinterlacing) {\n\t\tadd_in_dtd(ctx, VPE_PORT_LUMA3_IN);\n\t\tadd_in_dtd(ctx, VPE_PORT_CHROMA3_IN);\n\n\t\tadd_in_dtd(ctx, VPE_PORT_LUMA2_IN);\n\t\tadd_in_dtd(ctx, VPE_PORT_CHROMA2_IN);\n\t}\n\n\tadd_in_dtd(ctx, VPE_PORT_LUMA1_IN);\n\tadd_in_dtd(ctx, VPE_PORT_CHROMA1_IN);\n\n\tif (ctx->deinterlacing)\n\t\tadd_in_dtd(ctx, VPE_PORT_MV_IN);\n\n\t \n\tvpdma_add_sync_on_channel_ctd(&ctx->desc_list, VPE_CHAN_LUMA1_IN);\n\tvpdma_add_sync_on_channel_ctd(&ctx->desc_list, VPE_CHAN_CHROMA1_IN);\n\n\tif (ctx->deinterlacing) {\n\t\tvpdma_add_sync_on_channel_ctd(&ctx->desc_list,\n\t\t\tVPE_CHAN_LUMA2_IN);\n\t\tvpdma_add_sync_on_channel_ctd(&ctx->desc_list,\n\t\t\tVPE_CHAN_CHROMA2_IN);\n\n\t\tvpdma_add_sync_on_channel_ctd(&ctx->desc_list,\n\t\t\tVPE_CHAN_LUMA3_IN);\n\t\tvpdma_add_sync_on_channel_ctd(&ctx->desc_list,\n\t\t\tVPE_CHAN_CHROMA3_IN);\n\n\t\tvpdma_add_sync_on_channel_ctd(&ctx->desc_list, VPE_CHAN_MV_IN);\n\t}\n\n\t \n\tif (v4l2_is_format_rgb(d_finfo)) {\n\t\tvpdma_add_sync_on_channel_ctd(&ctx->desc_list,\n\t\t\tVPE_CHAN_RGB_OUT);\n\t} else {\n\t\tvpdma_add_sync_on_channel_ctd(&ctx->desc_list,\n\t\t\tVPE_CHAN_LUMA_OUT);\n\t\tif (d_q_data->fmt->coplanar)\n\t\t\tvpdma_add_sync_on_channel_ctd(&ctx->desc_list,\n\t\t\t\tVPE_CHAN_CHROMA_OUT);\n\t}\n\n\tif (ctx->deinterlacing)\n\t\tvpdma_add_sync_on_channel_ctd(&ctx->desc_list, VPE_CHAN_MV_OUT);\n\n\tenable_irqs(ctx);\n\n\tvpdma_map_desc_buf(ctx->dev->vpdma, &ctx->desc_list.buf);\n\tvpdma_submit_descs(ctx->dev->vpdma, &ctx->desc_list, 0);\n}\n\nstatic void dei_error(struct vpe_ctx *ctx)\n{\n\tdev_warn(ctx->dev->v4l2_dev.dev,\n\t\t\"received DEI error interrupt\\n\");\n}\n\nstatic void ds1_uv_error(struct vpe_ctx *ctx)\n{\n\tdev_warn(ctx->dev->v4l2_dev.dev,\n\t\t\"received downsampler error interrupt\\n\");\n}\n\nstatic irqreturn_t vpe_irq(int irq_vpe, void *data)\n{\n\tstruct vpe_dev *dev = (struct vpe_dev *)data;\n\tstruct vpe_ctx *ctx;\n\tstruct vpe_q_data *d_q_data;\n\tstruct vb2_v4l2_buffer *s_vb, *d_vb;\n\tunsigned long flags;\n\tu32 irqst0, irqst1;\n\tbool list_complete = false;\n\n\tirqst0 = read_reg(dev, VPE_INT0_STATUS0);\n\tif (irqst0) {\n\t\twrite_reg(dev, VPE_INT0_STATUS0_CLR, irqst0);\n\t\tvpe_dbg(dev, \"INT0_STATUS0 = 0x%08x\\n\", irqst0);\n\t}\n\n\tirqst1 = read_reg(dev, VPE_INT0_STATUS1);\n\tif (irqst1) {\n\t\twrite_reg(dev, VPE_INT0_STATUS1_CLR, irqst1);\n\t\tvpe_dbg(dev, \"INT0_STATUS1 = 0x%08x\\n\", irqst1);\n\t}\n\n\tctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);\n\tif (!ctx) {\n\t\tvpe_err(dev, \"instance released before end of transaction\\n\");\n\t\tgoto handled;\n\t}\n\n\tif (irqst1) {\n\t\tif (irqst1 & VPE_DEI_ERROR_INT) {\n\t\t\tirqst1 &= ~VPE_DEI_ERROR_INT;\n\t\t\tdei_error(ctx);\n\t\t}\n\t\tif (irqst1 & VPE_DS1_UV_ERROR_INT) {\n\t\t\tirqst1 &= ~VPE_DS1_UV_ERROR_INT;\n\t\t\tds1_uv_error(ctx);\n\t\t}\n\t}\n\n\tif (irqst0) {\n\t\tif (irqst0 & VPE_INT0_LIST0_COMPLETE)\n\t\t\tvpdma_clear_list_stat(ctx->dev->vpdma, 0, 0);\n\n\t\tirqst0 &= ~(VPE_INT0_LIST0_COMPLETE);\n\t\tlist_complete = true;\n\t}\n\n\tif (irqst0 | irqst1) {\n\t\tdev_warn(dev->v4l2_dev.dev, \"Unexpected interrupt: INT0_STATUS0 = 0x%08x, INT0_STATUS1 = 0x%08x\\n\",\n\t\t\tirqst0, irqst1);\n\t}\n\n\t \n\tif (!list_complete)\n\t\tgoto handled;\n\n\tdisable_irqs(ctx);\n\n\tvpdma_unmap_desc_buf(dev->vpdma, &ctx->desc_list.buf);\n\tvpdma_unmap_desc_buf(dev->vpdma, &ctx->mmr_adb);\n\tvpdma_unmap_desc_buf(dev->vpdma, &ctx->sc_coeff_h);\n\tvpdma_unmap_desc_buf(dev->vpdma, &ctx->sc_coeff_v);\n\n\tvpdma_reset_desc_list(&ctx->desc_list);\n\n\t  \n\tctx->src_mv_buf_selector = !ctx->src_mv_buf_selector;\n\n\ts_vb = ctx->src_vbs[0];\n\td_vb = ctx->dst_vb;\n\n\td_vb->flags = s_vb->flags;\n\td_vb->vb2_buf.timestamp = s_vb->vb2_buf.timestamp;\n\n\tif (s_vb->flags & V4L2_BUF_FLAG_TIMECODE)\n\t\td_vb->timecode = s_vb->timecode;\n\n\td_vb->sequence = ctx->sequence;\n\ts_vb->sequence = ctx->sequence;\n\n\td_q_data = &ctx->q_data[Q_DATA_DST];\n\tif (d_q_data->flags & Q_IS_INTERLACED) {\n\t\td_vb->field = ctx->field;\n\t\tif (ctx->field == V4L2_FIELD_BOTTOM) {\n\t\t\tctx->sequence++;\n\t\t\tctx->field = V4L2_FIELD_TOP;\n\t\t} else {\n\t\t\tWARN_ON(ctx->field != V4L2_FIELD_TOP);\n\t\t\tctx->field = V4L2_FIELD_BOTTOM;\n\t\t}\n\t} else {\n\t\td_vb->field = V4L2_FIELD_NONE;\n\t\tctx->sequence++;\n\t}\n\n\tif (ctx->deinterlacing) {\n\t\t \n\t\tif (ctx->src_vbs[2] != ctx->src_vbs[1])\n\t\t\ts_vb = ctx->src_vbs[2];\n\t\telse\n\t\t\ts_vb = NULL;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tif (s_vb)\n\t\tv4l2_m2m_buf_done(s_vb, VB2_BUF_STATE_DONE);\n\n\tv4l2_m2m_buf_done(d_vb, VB2_BUF_STATE_DONE);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (ctx->deinterlacing) {\n\t\tctx->src_vbs[2] = ctx->src_vbs[1];\n\t\tctx->src_vbs[1] = ctx->src_vbs[0];\n\t}\n\n\t \n\tctx->src_vbs[0] = NULL;\n\tctx->dst_vb = NULL;\n\n\tif (ctx->aborting)\n\t\tgoto finished;\n\n\tctx->bufs_completed++;\n\tif (ctx->bufs_completed < ctx->bufs_per_job && job_ready(ctx)) {\n\t\tdevice_run(ctx);\n\t\tgoto handled;\n\t}\n\nfinished:\n\tvpe_dbg(ctx->dev, \"finishing transaction\\n\");\n\tctx->bufs_completed = 0;\n\tv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\nhandled:\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int vpe_querycap(struct file *file, void *priv,\n\t\t\tstruct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, VPE_MODULE_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, VPE_MODULE_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"platform:%s\",\n\t\tVPE_MODULE_NAME);\n\treturn 0;\n}\n\nstatic int __enum_fmt(struct v4l2_fmtdesc *f, u32 type)\n{\n\tint i, index;\n\tstruct vpe_fmt *fmt = NULL;\n\n\tindex = 0;\n\tfor (i = 0; i < ARRAY_SIZE(vpe_formats); ++i) {\n\t\tif (vpe_formats[i].types & type) {\n\t\t\tif (index == f->index) {\n\t\t\t\tfmt = &vpe_formats[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t}\n\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = fmt->fourcc;\n\treturn 0;\n}\n\nstatic int vpe_enum_fmt(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(f->type))\n\t\treturn __enum_fmt(f, VPE_FMT_TYPE_OUTPUT);\n\n\treturn __enum_fmt(f, VPE_FMT_TYPE_CAPTURE);\n}\n\nstatic int vpe_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\n\tstruct vpe_ctx *ctx = file->private_data;\n\tstruct vb2_queue *vq;\n\tstruct vpe_q_data *q_data;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, f->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\t*f = q_data->format;\n\n\tif (V4L2_TYPE_IS_CAPTURE(f->type)) {\n\t\tstruct vpe_q_data *s_q_data;\n\t\tstruct v4l2_pix_format_mplane *spix;\n\n\t\t \n\t\ts_q_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\t\tspix = &s_q_data->format.fmt.pix_mp;\n\n\t\tpix->colorspace = spix->colorspace;\n\t\tpix->xfer_func = spix->xfer_func;\n\t\tpix->ycbcr_enc = spix->ycbcr_enc;\n\t\tpix->quantization = spix->quantization;\n\t}\n\n\treturn 0;\n}\n\nstatic int __vpe_try_fmt(struct vpe_ctx *ctx, struct v4l2_format *f,\n\t\t       struct vpe_fmt *fmt, int type)\n{\n\tstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\n\tstruct v4l2_plane_pix_format *plane_fmt;\n\tunsigned int w_align;\n\tint i, depth, depth_bytes, height;\n\tunsigned int stride = 0;\n\tconst struct v4l2_format_info *finfo;\n\n\tif (!fmt || !(fmt->types & type)) {\n\t\tvpe_dbg(ctx->dev, \"Fourcc format (0x%08x) invalid.\\n\",\n\t\t\tpix->pixelformat);\n\t\tfmt = __find_format(V4L2_PIX_FMT_YUYV);\n\t}\n\n\tif (pix->field != V4L2_FIELD_NONE &&\n\t    pix->field != V4L2_FIELD_ALTERNATE &&\n\t    pix->field != V4L2_FIELD_SEQ_TB &&\n\t    pix->field != V4L2_FIELD_SEQ_BT)\n\t\tpix->field = V4L2_FIELD_NONE;\n\n\tdepth = fmt->vpdma_fmt[VPE_LUMA]->depth;\n\n\t \n\tdepth_bytes = depth >> 3;\n\n\tif (depth_bytes == 3) {\n\t\t \n\t\tw_align = 4;\n\t} else {\n\t\t \n\n\t\t \n\t\tw_align = roundup_pow_of_two(VPDMA_DESC_ALIGN / depth_bytes);\n\t\tw_align = ilog2(w_align);\n\t}\n\n\tv4l_bound_align_image(&pix->width, MIN_W, MAX_W, w_align,\n\t\t\t      &pix->height, MIN_H, MAX_H, H_ALIGN,\n\t\t\t      S_ALIGN);\n\n\tif (!pix->num_planes || pix->num_planes > 2)\n\t\tpix->num_planes = fmt->coplanar ? 2 : 1;\n\telse if (pix->num_planes > 1 && !fmt->coplanar)\n\t\tpix->num_planes = 1;\n\n\tpix->pixelformat = fmt->fourcc;\n\tfinfo = v4l2_format_info(fmt->fourcc);\n\n\t \n\tif (pix->field == V4L2_FIELD_SEQ_TB || pix->field == V4L2_FIELD_SEQ_BT)\n\t\theight = pix->height / 2;\n\telse\n\t\theight = pix->height;\n\n\tif (!pix->colorspace) {\n\t\tif (v4l2_is_format_rgb(finfo)) {\n\t\t\tpix->colorspace = V4L2_COLORSPACE_SRGB;\n\t\t} else {\n\t\t\tif (height > 1280)\t \n\t\t\t\tpix->colorspace = V4L2_COLORSPACE_REC709;\n\t\t\telse\t\t\t \n\t\t\t\tpix->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pix->num_planes; i++) {\n\t\tplane_fmt = &pix->plane_fmt[i];\n\t\tdepth = fmt->vpdma_fmt[i]->depth;\n\n\t\tstride = (pix->width * fmt->vpdma_fmt[VPE_LUMA]->depth) >> 3;\n\t\tif (stride > plane_fmt->bytesperline)\n\t\t\tplane_fmt->bytesperline = stride;\n\n\t\tplane_fmt->bytesperline = clamp_t(u32, plane_fmt->bytesperline,\n\t\t\t\t\t\t  stride,\n\t\t\t\t\t\t  VPDMA_MAX_STRIDE);\n\n\t\tplane_fmt->bytesperline = ALIGN(plane_fmt->bytesperline,\n\t\t\t\t\t\tVPDMA_STRIDE_ALIGN);\n\n\t\tif (i == VPE_LUMA) {\n\t\t\tplane_fmt->sizeimage = pix->height *\n\t\t\t\t\t       plane_fmt->bytesperline;\n\n\t\t\tif (pix->num_planes == 1 && fmt->coplanar)\n\t\t\t\tplane_fmt->sizeimage += pix->height *\n\t\t\t\t\tplane_fmt->bytesperline *\n\t\t\t\t\tfmt->vpdma_fmt[VPE_CHROMA]->depth >> 3;\n\n\t\t} else {  \n\t\t\tplane_fmt->sizeimage = (pix->height *\n\t\t\t\t\t       plane_fmt->bytesperline *\n\t\t\t\t\t       depth) >> 3;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vpe_try_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct vpe_ctx *ctx = file->private_data;\n\tstruct vpe_fmt *fmt = find_format(f);\n\n\tif (V4L2_TYPE_IS_OUTPUT(f->type))\n\t\treturn __vpe_try_fmt(ctx, f, fmt, VPE_FMT_TYPE_OUTPUT);\n\telse\n\t\treturn __vpe_try_fmt(ctx, f, fmt, VPE_FMT_TYPE_CAPTURE);\n}\n\nstatic int __vpe_s_fmt(struct vpe_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\n\tstruct v4l2_pix_format_mplane *qpix;\n\tstruct vpe_q_data *q_data;\n\tstruct vb2_queue *vq;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(vq)) {\n\t\tvpe_err(ctx->dev, \"queue busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tq_data = get_q_data(ctx, f->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tqpix = &q_data->format.fmt.pix_mp;\n\tq_data->fmt\t\t= find_format(f);\n\tq_data->format = *f;\n\n\tq_data->c_rect.left\t= 0;\n\tq_data->c_rect.top\t= 0;\n\tq_data->c_rect.width\t= pix->width;\n\tq_data->c_rect.height\t= pix->height;\n\n\tif (qpix->field == V4L2_FIELD_ALTERNATE)\n\t\tq_data->flags |= Q_DATA_INTERLACED_ALTERNATE;\n\telse if (qpix->field == V4L2_FIELD_SEQ_TB)\n\t\tq_data->flags |= Q_DATA_INTERLACED_SEQ_TB;\n\telse if (qpix->field == V4L2_FIELD_SEQ_BT)\n\t\tq_data->flags |= Q_DATA_INTERLACED_SEQ_BT;\n\telse\n\t\tq_data->flags &= ~Q_IS_INTERLACED;\n\n\t \n\tif (q_data->flags & Q_IS_SEQ_XX)\n\t\tq_data->c_rect.height /= 2;\n\n\tvpe_dbg(ctx->dev, \"Setting format for type %d, wxh: %dx%d, fmt: %d bpl_y %d\",\n\t\tf->type, pix->width, pix->height, pix->pixelformat,\n\t\tpix->plane_fmt[0].bytesperline);\n\tif (pix->num_planes == 2)\n\t\tvpe_dbg(ctx->dev, \" bpl_uv %d\\n\",\n\t\t\tpix->plane_fmt[1].bytesperline);\n\n\treturn 0;\n}\n\nstatic int vpe_s_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tint ret;\n\tstruct vpe_ctx *ctx = file->private_data;\n\n\tret = vpe_try_fmt(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __vpe_s_fmt(ctx, f);\n\tif (ret)\n\t\treturn ret;\n\n\tif (V4L2_TYPE_IS_OUTPUT(f->type))\n\t\tset_src_registers(ctx);\n\telse\n\t\tset_dst_registers(ctx);\n\n\treturn set_srcdst_params(ctx);\n}\n\nstatic int __vpe_try_selection(struct vpe_ctx *ctx, struct v4l2_selection *s)\n{\n\tstruct vpe_q_data *q_data;\n\tstruct v4l2_pix_format_mplane *pix;\n\tint height;\n\n\tif ((s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\n\t    (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT))\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, s->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tpix = &q_data->format.fmt.pix_mp;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\t \n\t\tif (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\t \n\t\tif (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (q_data->flags & Q_IS_SEQ_XX)\n\t\theight = pix->height / 2;\n\telse\n\t\theight = pix->height;\n\n\tif (s->r.top < 0 || s->r.left < 0) {\n\t\tvpe_err(ctx->dev, \"negative values for top and left\\n\");\n\t\ts->r.top = s->r.left = 0;\n\t}\n\n\tv4l_bound_align_image(&s->r.width, MIN_W, pix->width, 1,\n\t\t&s->r.height, MIN_H, height, H_ALIGN, S_ALIGN);\n\n\t \n\tif (s->r.left + s->r.width > pix->width)\n\t\ts->r.left = pix->width - s->r.width;\n\tif (s->r.top + s->r.height > pix->height)\n\t\ts->r.top = pix->height - s->r.height;\n\n\treturn 0;\n}\n\nstatic int vpe_g_selection(struct file *file, void *fh,\n\t\tstruct v4l2_selection *s)\n{\n\tstruct vpe_ctx *ctx = file->private_data;\n\tstruct vpe_q_data *q_data;\n\tstruct v4l2_pix_format_mplane *pix;\n\tbool use_c_rect = false;\n\n\tif ((s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\n\t    (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT))\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, s->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tpix = &q_data->format.fmt.pix_mp;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tif (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tif (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tuse_c_rect = true;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tuse_c_rect = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (use_c_rect) {\n\t\t \n\t\ts->r = q_data->c_rect;\n\t} else {\n\t\t \n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = pix->width;\n\t\ts->r.height = pix->height;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int vpe_s_selection(struct file *file, void *fh,\n\t\tstruct v4l2_selection *s)\n{\n\tstruct vpe_ctx *ctx = file->private_data;\n\tstruct vpe_q_data *q_data;\n\tstruct v4l2_selection sel = *s;\n\tint ret;\n\n\tret = __vpe_try_selection(ctx, &sel);\n\tif (ret)\n\t\treturn ret;\n\n\tq_data = get_q_data(ctx, sel.type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tif ((q_data->c_rect.left == sel.r.left) &&\n\t\t\t(q_data->c_rect.top == sel.r.top) &&\n\t\t\t(q_data->c_rect.width == sel.r.width) &&\n\t\t\t(q_data->c_rect.height == sel.r.height)) {\n\t\tvpe_dbg(ctx->dev,\n\t\t\t\"requested crop/compose values are already set\\n\");\n\t\treturn 0;\n\t}\n\n\tq_data->c_rect = sel.r;\n\n\treturn set_srcdst_params(ctx);\n}\n\n \n#define V4L2_CID_VPE_BUFS_PER_JOB\t\t(V4L2_CID_USER_TI_VPE_BASE + 0)\n\nstatic int vpe_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vpe_ctx *ctx =\n\t\tcontainer_of(ctrl->handler, struct vpe_ctx, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_VPE_BUFS_PER_JOB:\n\t\tctx->bufs_per_job = ctrl->val;\n\t\tbreak;\n\n\tdefault:\n\t\tvpe_err(ctx->dev, \"Invalid control\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops vpe_ctrl_ops = {\n\t.s_ctrl = vpe_s_ctrl,\n};\n\nstatic const struct v4l2_ioctl_ops vpe_ioctl_ops = {\n\t.vidioc_querycap\t\t= vpe_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= vpe_enum_fmt,\n\t.vidioc_g_fmt_vid_cap_mplane\t= vpe_g_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane\t= vpe_try_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane\t= vpe_s_fmt,\n\n\t.vidioc_enum_fmt_vid_out\t= vpe_enum_fmt,\n\t.vidioc_g_fmt_vid_out_mplane\t= vpe_g_fmt,\n\t.vidioc_try_fmt_vid_out_mplane\t= vpe_try_fmt,\n\t.vidioc_s_fmt_vid_out_mplane\t= vpe_s_fmt,\n\n\t.vidioc_g_selection\t\t= vpe_g_selection,\n\t.vidioc_s_selection\t\t= vpe_s_selection,\n\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\n \nstatic int vpe_queue_setup(struct vb2_queue *vq,\n\t\t\t   unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tint i;\n\tstruct vpe_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct vpe_q_data *q_data;\n\tstruct v4l2_pix_format_mplane *pix;\n\n\tq_data = get_q_data(ctx, vq->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tpix = &q_data->format.fmt.pix_mp;\n\t*nplanes = pix->num_planes;\n\n\tfor (i = 0; i < *nplanes; i++)\n\t\tsizes[i] = pix->plane_fmt[i].sizeimage;\n\n\tvpe_dbg(ctx->dev, \"get %d buffer(s) of size %d\", *nbuffers,\n\t\tsizes[VPE_LUMA]);\n\tif (*nplanes == 2)\n\t\tvpe_dbg(ctx->dev, \" and %d\\n\", sizes[VPE_CHROMA]);\n\n\treturn 0;\n}\n\nstatic int vpe_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vpe_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vpe_q_data *q_data;\n\tstruct v4l2_pix_format_mplane *pix;\n\tint i;\n\n\tvpe_dbg(ctx->dev, \"type: %d\\n\", vb->vb2_queue->type);\n\n\tq_data = get_q_data(ctx, vb->vb2_queue->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tpix = &q_data->format.fmt.pix_mp;\n\n\tif (vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tif (!(q_data->flags & Q_IS_INTERLACED)) {\n\t\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\t} else {\n\t\t\tif (vbuf->field != V4L2_FIELD_TOP &&\n\t\t\t    vbuf->field != V4L2_FIELD_BOTTOM &&\n\t\t\t    vbuf->field != V4L2_FIELD_SEQ_TB &&\n\t\t\t    vbuf->field != V4L2_FIELD_SEQ_BT)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pix->num_planes; i++) {\n\t\tif (vb2_plane_size(vb, i) < pix->plane_fmt[i].sizeimage) {\n\t\t\tvpe_err(ctx->dev,\n\t\t\t\t\"data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t\tvb2_plane_size(vb, i),\n\t\t\t\t(long)pix->plane_fmt[i].sizeimage);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pix->num_planes; i++)\n\t\tvb2_set_plane_payload(vb, i, pix->plane_fmt[i].sizeimage);\n\n\treturn 0;\n}\n\nstatic void vpe_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vpe_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int check_srcdst_sizes(struct vpe_ctx *ctx)\n{\n\tstruct vpe_q_data *s_q_data =  &ctx->q_data[Q_DATA_SRC];\n\tstruct vpe_q_data *d_q_data =  &ctx->q_data[Q_DATA_DST];\n\tunsigned int src_w = s_q_data->c_rect.width;\n\tunsigned int src_h = s_q_data->c_rect.height;\n\tunsigned int dst_w = d_q_data->c_rect.width;\n\tunsigned int dst_h = d_q_data->c_rect.height;\n\n\tif (src_w == dst_w && src_h == dst_h)\n\t\treturn 0;\n\n\tif (src_h <= SC_MAX_PIXEL_HEIGHT &&\n\t    src_w <= SC_MAX_PIXEL_WIDTH &&\n\t    dst_h <= SC_MAX_PIXEL_HEIGHT &&\n\t    dst_w <= SC_MAX_PIXEL_WIDTH)\n\t\treturn 0;\n\n\treturn -1;\n}\n\nstatic void vpe_return_all_buffers(struct vpe_ctx *ctx,  struct vb2_queue *q,\n\t\t\t\t   enum vb2_buffer_state state)\n{\n\tstruct vb2_v4l2_buffer *vb;\n\tunsigned long flags;\n\n\tfor (;;) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\t\tvb = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (!vb)\n\t\t\tbreak;\n\t\tspin_lock_irqsave(&ctx->dev->lock, flags);\n\t\tv4l2_m2m_buf_done(vb, state);\n\t\tspin_unlock_irqrestore(&ctx->dev->lock, flags);\n\t}\n\n\t \n\tif (V4L2_TYPE_IS_OUTPUT(q->type)) {\n\t\tspin_lock_irqsave(&ctx->dev->lock, flags);\n\n\t\tif (ctx->src_vbs[2])\n\t\t\tv4l2_m2m_buf_done(ctx->src_vbs[2], state);\n\n\t\tif (ctx->src_vbs[1] && (ctx->src_vbs[1] != ctx->src_vbs[2]))\n\t\t\tv4l2_m2m_buf_done(ctx->src_vbs[1], state);\n\n\t\tif (ctx->src_vbs[0] &&\n\t\t    (ctx->src_vbs[0] != ctx->src_vbs[1]) &&\n\t\t    (ctx->src_vbs[0] != ctx->src_vbs[2]))\n\t\t\tv4l2_m2m_buf_done(ctx->src_vbs[0], state);\n\n\t\tctx->src_vbs[2] = NULL;\n\t\tctx->src_vbs[1] = NULL;\n\t\tctx->src_vbs[0] = NULL;\n\n\t\tspin_unlock_irqrestore(&ctx->dev->lock, flags);\n\t} else {\n\t\tif (ctx->dst_vb) {\n\t\t\tspin_lock_irqsave(&ctx->dev->lock, flags);\n\n\t\t\tv4l2_m2m_buf_done(ctx->dst_vb, state);\n\t\t\tctx->dst_vb = NULL;\n\t\t\tspin_unlock_irqrestore(&ctx->dev->lock, flags);\n\t\t}\n\t}\n}\n\nstatic int vpe_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct vpe_ctx *ctx = vb2_get_drv_priv(q);\n\n\t \n\tif (check_srcdst_sizes(ctx)) {\n\t\tvpe_err(ctx->dev,\n\t\t\t\"Conversion setup failed, check source and destination parameters\\n\"\n\t\t\t);\n\t\tvpe_return_all_buffers(ctx, q, VB2_BUF_STATE_QUEUED);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->deinterlacing)\n\t\tconfig_edi_input_mode(ctx, 0x0);\n\n\tif (ctx->sequence != 0)\n\t\tset_srcdst_params(ctx);\n\n\treturn 0;\n}\n\nstatic void vpe_stop_streaming(struct vb2_queue *q)\n{\n\tstruct vpe_ctx *ctx = vb2_get_drv_priv(q);\n\n\tvpe_dump_regs(ctx->dev);\n\tvpdma_dump_regs(ctx->dev->vpdma);\n\n\tvpe_return_all_buffers(ctx, q, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct vb2_ops vpe_qops = {\n\t.queue_setup\t = vpe_queue_setup,\n\t.buf_prepare\t = vpe_buf_prepare,\n\t.buf_queue\t = vpe_buf_queue,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n\t.start_streaming = vpe_start_streaming,\n\t.stop_streaming  = vpe_stop_streaming,\n};\n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct vpe_ctx *ctx = priv;\n\tstruct vpe_dev *dev = ctx->dev;\n\tint ret;\n\n\tmemset(src_vq, 0, sizeof(*src_vq));\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->ops = &vpe_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &dev->dev_mutex;\n\tsrc_vq->dev = dev->v4l2_dev.dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(dst_vq, 0, sizeof(*dst_vq));\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops = &vpe_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &dev->dev_mutex;\n\tdst_vq->dev = dev->v4l2_dev.dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic const struct v4l2_ctrl_config vpe_bufs_per_job = {\n\t.ops = &vpe_ctrl_ops,\n\t.id = V4L2_CID_VPE_BUFS_PER_JOB,\n\t.name = \"Buffers Per Transaction\",\n\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t.def = VPE_DEF_BUFS_PER_JOB,\n\t.min = 1,\n\t.max = VIDEO_MAX_FRAME,\n\t.step = 1,\n};\n\n \nstatic int vpe_open(struct file *file)\n{\n\tstruct vpe_dev *dev = video_drvdata(file);\n\tstruct vpe_q_data *s_q_data;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct vpe_ctx *ctx;\n\tstruct v4l2_pix_format_mplane *pix;\n\tint ret;\n\n\tvpe_dbg(dev, \"vpe_open\\n\");\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\n\tif (mutex_lock_interruptible(&dev->dev_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_ctx;\n\t}\n\n\tret = vpdma_create_desc_list(&ctx->desc_list, VPE_DESC_LIST_SIZE,\n\t\t\tVPDMA_LIST_TYPE_NORMAL);\n\tif (ret != 0)\n\t\tgoto unlock;\n\n\tret = vpdma_alloc_desc_buf(&ctx->mmr_adb, sizeof(struct vpe_mmr_adb));\n\tif (ret != 0)\n\t\tgoto free_desc_list;\n\n\tret = vpdma_alloc_desc_buf(&ctx->sc_coeff_h, SC_COEF_SRAM_SIZE);\n\tif (ret != 0)\n\t\tgoto free_mmr_adb;\n\n\tret = vpdma_alloc_desc_buf(&ctx->sc_coeff_v, SC_COEF_SRAM_SIZE);\n\tif (ret != 0)\n\t\tgoto free_sc_h;\n\n\tinit_adb_hdrs(ctx);\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = ctx;\n\n\thdl = &ctx->hdl;\n\tv4l2_ctrl_handler_init(hdl, 1);\n\tv4l2_ctrl_new_custom(hdl, &vpe_bufs_per_job, NULL);\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\t\tgoto exit_fh;\n\t}\n\tctx->fh.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_setup(hdl);\n\n\ts_q_data = &ctx->q_data[Q_DATA_SRC];\n\tpix = &s_q_data->format.fmt.pix_mp;\n\ts_q_data->fmt = __find_format(V4L2_PIX_FMT_YUYV);\n\tpix->pixelformat = s_q_data->fmt->fourcc;\n\ts_q_data->format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tpix->width = 1920;\n\tpix->height = 1080;\n\tpix->num_planes = 1;\n\tpix->plane_fmt[VPE_LUMA].bytesperline = (pix->width *\n\t\t\ts_q_data->fmt->vpdma_fmt[VPE_LUMA]->depth) >> 3;\n\tpix->plane_fmt[VPE_LUMA].sizeimage =\n\t\t\tpix->plane_fmt[VPE_LUMA].bytesperline *\n\t\t\tpix->height;\n\tpix->colorspace = V4L2_COLORSPACE_REC709;\n\tpix->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\tpix->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tpix->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tpix->field = V4L2_FIELD_NONE;\n\ts_q_data->c_rect.left = 0;\n\ts_q_data->c_rect.top = 0;\n\ts_q_data->c_rect.width = pix->width;\n\ts_q_data->c_rect.height = pix->height;\n\ts_q_data->flags = 0;\n\n\tctx->q_data[Q_DATA_DST] = *s_q_data;\n\tctx->q_data[Q_DATA_DST].format.type =\n\t\t\tV4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\n\tset_dei_shadow_registers(ctx);\n\tset_src_registers(ctx);\n\tset_dst_registers(ctx);\n\tret = set_srcdst_params(ctx);\n\tif (ret)\n\t\tgoto exit_fh;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx, &queue_init);\n\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto exit_fh;\n\t}\n\n\tv4l2_fh_add(&ctx->fh);\n\n\t \n\tif (atomic_inc_return(&dev->num_instances) == 1)\n\t\tvpe_dbg(dev, \"first instance created\\n\");\n\n\tctx->bufs_per_job = VPE_DEF_BUFS_PER_JOB;\n\n\tctx->load_mmrs = true;\n\n\tvpe_dbg(dev, \"created instance %p, m2m_ctx: %p\\n\",\n\t\tctx, ctx->fh.m2m_ctx);\n\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn 0;\nexit_fh:\n\tv4l2_ctrl_handler_free(hdl);\n\tv4l2_fh_exit(&ctx->fh);\n\tvpdma_free_desc_buf(&ctx->sc_coeff_v);\nfree_sc_h:\n\tvpdma_free_desc_buf(&ctx->sc_coeff_h);\nfree_mmr_adb:\n\tvpdma_free_desc_buf(&ctx->mmr_adb);\nfree_desc_list:\n\tvpdma_free_desc_list(&ctx->desc_list);\nunlock:\n\tmutex_unlock(&dev->dev_mutex);\nfree_ctx:\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic int vpe_release(struct file *file)\n{\n\tstruct vpe_dev *dev = video_drvdata(file);\n\tstruct vpe_ctx *ctx = file->private_data;\n\n\tvpe_dbg(dev, \"releasing instance %p\\n\", ctx);\n\n\tmutex_lock(&dev->dev_mutex);\n\tfree_mv_buffers(ctx);\n\n\tvpdma_unmap_desc_buf(dev->vpdma, &ctx->desc_list.buf);\n\tvpdma_unmap_desc_buf(dev->vpdma, &ctx->mmr_adb);\n\tvpdma_unmap_desc_buf(dev->vpdma, &ctx->sc_coeff_h);\n\tvpdma_unmap_desc_buf(dev->vpdma, &ctx->sc_coeff_v);\n\n\tvpdma_free_desc_list(&ctx->desc_list);\n\tvpdma_free_desc_buf(&ctx->mmr_adb);\n\n\tvpdma_free_desc_buf(&ctx->sc_coeff_v);\n\tvpdma_free_desc_buf(&ctx->sc_coeff_h);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_ctrl_handler_free(&ctx->hdl);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\n\tkfree(ctx);\n\n\t \n\tif (atomic_dec_return(&dev->num_instances) == 0)\n\t\tvpe_dbg(dev, \"last instance released\\n\");\n\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations vpe_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= vpe_open,\n\t.release\t= vpe_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct video_device vpe_videodev = {\n\t.name\t\t= VPE_MODULE_NAME,\n\t.fops\t\t= &vpe_fops,\n\t.ioctl_ops\t= &vpe_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= video_device_release_empty,\n\t.vfl_dir\t= VFL_DIR_M2M,\n\t.device_caps\t= V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING,\n};\n\nstatic const struct v4l2_m2m_ops m2m_ops = {\n\t.device_run\t= device_run,\n\t.job_ready\t= job_ready,\n\t.job_abort\t= job_abort,\n};\n\nstatic int vpe_runtime_get(struct platform_device *pdev)\n{\n\tint r;\n\n\tdev_dbg(&pdev->dev, \"vpe_runtime_get\\n\");\n\n\tr = pm_runtime_resume_and_get(&pdev->dev);\n\tWARN_ON(r < 0);\n\treturn r;\n}\n\nstatic void vpe_runtime_put(struct platform_device *pdev)\n{\n\n\tint r;\n\n\tdev_dbg(&pdev->dev, \"vpe_runtime_put\\n\");\n\n\tr = pm_runtime_put_sync(&pdev->dev);\n\tWARN_ON(r < 0 && r != -ENOSYS);\n}\n\nstatic void vpe_fw_cb(struct platform_device *pdev)\n{\n\tstruct vpe_dev *dev = platform_get_drvdata(pdev);\n\tstruct video_device *vfd;\n\tint ret;\n\n\tvfd = &dev->vfd;\n\t*vfd = vpe_videodev;\n\tvfd->lock = &dev->dev_mutex;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tvpe_err(dev, \"Failed to register video device\\n\");\n\n\t\tvpe_set_clock_enable(dev, 0);\n\t\tvpe_runtime_put(pdev);\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tv4l2_m2m_release(dev->m2m_dev);\n\t\tv4l2_device_unregister(&dev->v4l2_dev);\n\n\t\treturn;\n\t}\n\n\tvideo_set_drvdata(vfd, dev);\n\tdev_info(dev->v4l2_dev.dev, \"Device registered as /dev/video%d\\n\",\n\t\tvfd->num);\n}\n\nstatic int vpe_probe(struct platform_device *pdev)\n{\n\tstruct vpe_dev *dev;\n\tint ret, irq, func;\n\n\tret = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"32-bit consistent DMA enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dev->lock);\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tatomic_set(&dev->num_instances, 0);\n\tmutex_init(&dev->dev_mutex);\n\n\tdev->res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t\"vpe_top\");\n\tif (!dev->res) {\n\t\tdev_err(&pdev->dev, \"missing 'vpe_top' resources data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdev->base = devm_ioremap(&pdev->dev, dev->res->start, SZ_32K);\n\tif (!dev->base) {\n\t\tret = -ENOMEM;\n\t\tgoto v4l2_dev_unreg;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_irq(&pdev->dev, irq, vpe_irq, 0, VPE_MODULE_NAME,\n\t\t\tdev);\n\tif (ret)\n\t\tgoto v4l2_dev_unreg;\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev->m2m_dev = v4l2_m2m_init(&m2m_ops);\n\tif (IS_ERR(dev->m2m_dev)) {\n\t\tvpe_err(dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(dev->m2m_dev);\n\t\tgoto v4l2_dev_unreg;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = vpe_runtime_get(pdev);\n\tif (ret < 0)\n\t\tgoto rel_m2m;\n\n\t \n\tvpe_set_clock_enable(dev, 1);\n\n\tvpe_top_reset(dev);\n\n\tfunc = read_field_reg(dev, VPE_PID, VPE_PID_FUNC_MASK,\n\t\tVPE_PID_FUNC_SHIFT);\n\tvpe_dbg(dev, \"VPE PID function %x\\n\", func);\n\n\tvpe_top_vpdma_reset(dev);\n\n\tdev->sc = sc_create(pdev, \"sc\");\n\tif (IS_ERR(dev->sc)) {\n\t\tret = PTR_ERR(dev->sc);\n\t\tgoto runtime_put;\n\t}\n\n\tdev->csc = csc_create(pdev, \"csc\");\n\tif (IS_ERR(dev->csc)) {\n\t\tret = PTR_ERR(dev->csc);\n\t\tgoto runtime_put;\n\t}\n\n\tdev->vpdma = &dev->vpdma_data;\n\tret = vpdma_create(pdev, dev->vpdma, vpe_fw_cb);\n\tif (ret)\n\t\tgoto runtime_put;\n\n\treturn 0;\n\nruntime_put:\n\tvpe_runtime_put(pdev);\nrel_m2m:\n\tpm_runtime_disable(&pdev->dev);\n\tv4l2_m2m_release(dev->m2m_dev);\nv4l2_dev_unreg:\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\n\treturn ret;\n}\n\nstatic void vpe_remove(struct platform_device *pdev)\n{\n\tstruct vpe_dev *dev = platform_get_drvdata(pdev);\n\n\tv4l2_info(&dev->v4l2_dev, \"Removing \" VPE_MODULE_NAME);\n\n\tv4l2_m2m_release(dev->m2m_dev);\n\tvideo_unregister_device(&dev->vfd);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\n\tvpe_set_clock_enable(dev, 0);\n\tvpe_runtime_put(pdev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id vpe_of_match[] = {\n\t{\n\t\t.compatible = \"ti,dra7-vpe\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, vpe_of_match);\n#endif\n\nstatic struct platform_driver vpe_pdrv = {\n\t.probe\t\t= vpe_probe,\n\t.remove_new\t= vpe_remove,\n\t.driver\t\t= {\n\t\t.name\t= VPE_MODULE_NAME,\n\t\t.of_match_table = of_match_ptr(vpe_of_match),\n\t},\n};\n\nmodule_platform_driver(vpe_pdrv);\n\nMODULE_DESCRIPTION(\"TI VPE driver\");\nMODULE_AUTHOR(\"Dale Farnsworth, <dale@farnsworth.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}