{
  "module_name": "ispcsi2.c",
  "hash_id": "7d18baf8963ee94a5c378562e67ddf436af6d5c110d9178f9396f006146d8fa7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap3isp/ispcsi2.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <media/v4l2-common.h>\n#include <linux/v4l2-mediabus.h>\n#include <linux/mm.h>\n\n#include \"isp.h\"\n#include \"ispreg.h\"\n#include \"ispcsi2.h\"\n\n \nstatic void csi2_if_enable(struct isp_device *isp,\n\t\t\t   struct isp_csi2_device *csi2, u8 enable)\n{\n\tstruct isp_csi2_ctrl_cfg *currctrl = &csi2->ctrl;\n\n\tisp_reg_clr_set(isp, csi2->regs1, ISPCSI2_CTRL, ISPCSI2_CTRL_IF_EN,\n\t\t\tenable ? ISPCSI2_CTRL_IF_EN : 0);\n\n\tcurrctrl->if_enable = enable;\n}\n\n \nstatic void csi2_recv_config(struct isp_device *isp,\n\t\t\t     struct isp_csi2_device *csi2,\n\t\t\t     struct isp_csi2_ctrl_cfg *currctrl)\n{\n\tu32 reg;\n\n\treg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTRL);\n\n\tif (currctrl->frame_mode)\n\t\treg |= ISPCSI2_CTRL_FRAME;\n\telse\n\t\treg &= ~ISPCSI2_CTRL_FRAME;\n\n\tif (currctrl->vp_clk_enable)\n\t\treg |= ISPCSI2_CTRL_VP_CLK_EN;\n\telse\n\t\treg &= ~ISPCSI2_CTRL_VP_CLK_EN;\n\n\tif (currctrl->vp_only_enable)\n\t\treg |= ISPCSI2_CTRL_VP_ONLY_EN;\n\telse\n\t\treg &= ~ISPCSI2_CTRL_VP_ONLY_EN;\n\n\treg &= ~ISPCSI2_CTRL_VP_OUT_CTRL_MASK;\n\treg |= currctrl->vp_out_ctrl << ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT;\n\n\tif (currctrl->ecc_enable)\n\t\treg |= ISPCSI2_CTRL_ECC_EN;\n\telse\n\t\treg &= ~ISPCSI2_CTRL_ECC_EN;\n\n\tisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTRL);\n}\n\nstatic const unsigned int csi2_input_fmts[] = {\n\tMEDIA_BUS_FMT_SGRBG10_1X10,\n\tMEDIA_BUS_FMT_SGRBG10_DPCM8_1X8,\n\tMEDIA_BUS_FMT_SRGGB10_1X10,\n\tMEDIA_BUS_FMT_SRGGB10_DPCM8_1X8,\n\tMEDIA_BUS_FMT_SBGGR10_1X10,\n\tMEDIA_BUS_FMT_SBGGR10_DPCM8_1X8,\n\tMEDIA_BUS_FMT_SGBRG10_1X10,\n\tMEDIA_BUS_FMT_SGBRG10_DPCM8_1X8,\n\tMEDIA_BUS_FMT_YUYV8_2X8,\n};\n\n \nstatic const u16 __csi2_fmt_map[3][2][2][2] = {\n\t \n\t{\n\t\t \n\t\t{\n\t\t\t \n\t\t\t{ CSI2_PIX_FMT_RAW10_EXP16, CSI2_PIX_FMT_RAW10_EXP16 },\n\t\t\t \n\t\t\t{ 0, 0 },\n\t\t},\n\t\t \n\t\t{\n\t\t\t \n\t\t\t{ CSI2_PIX_FMT_RAW10_EXP16_VP,\n\t\t\t  CSI2_PIX_FMT_RAW10_EXP16_VP },\n\t\t\t \n\t\t\t{ 0, 0 },\n\t\t},\n\t},\n\t \n\t{\n\t\t \n\t\t{\n\t\t\t \n\t\t\t{ CSI2_PIX_FMT_RAW8, CSI2_USERDEF_8BIT_DATA1 },\n\t\t\t \n\t\t\t{ CSI2_PIX_FMT_RAW8_DPCM10_EXP16,\n\t\t\t  CSI2_USERDEF_8BIT_DATA1_DPCM10 },\n\t\t},\n\t\t \n\t\t{\n\t\t\t \n\t\t\t{ CSI2_PIX_FMT_RAW8_VP,\n\t\t\t  CSI2_PIX_FMT_RAW8_VP },\n\t\t\t \n\t\t\t{ CSI2_PIX_FMT_RAW8_DPCM10_VP,\n\t\t\t  CSI2_USERDEF_8BIT_DATA1_DPCM10_VP },\n\t\t},\n\t},\n\t \n\t{\n\t\t \n\t\t{\n\t\t\t \n\t\t\t{ CSI2_PIX_FMT_YUV422_8BIT,\n\t\t\t  CSI2_PIX_FMT_YUV422_8BIT },\n\t\t\t \n\t\t\t{ 0, 0 },\n\t\t},\n\t\t \n\t\t{\n\t\t\t \n\t\t\t{ CSI2_PIX_FMT_YUV422_8BIT_VP,\n\t\t\t  CSI2_PIX_FMT_YUV422_8BIT_VP },\n\t\t\t \n\t\t\t{ 0, 0 },\n\t\t},\n\t},\n};\n\n \nstatic u16 csi2_ctx_map_format(struct isp_csi2_device *csi2)\n{\n\tconst struct v4l2_mbus_framefmt *fmt = &csi2->formats[CSI2_PAD_SINK];\n\tint fmtidx, destidx, is_3630;\n\n\tswitch (fmt->code) {\n\tcase MEDIA_BUS_FMT_SGRBG10_1X10:\n\tcase MEDIA_BUS_FMT_SRGGB10_1X10:\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\tcase MEDIA_BUS_FMT_SGBRG10_1X10:\n\t\tfmtidx = 0;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:\n\tcase MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:\n\tcase MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:\n\tcase MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:\n\t\tfmtidx = 1;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\tfmtidx = 2;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, KERN_ERR \"CSI2: pixel format %08x unsupported!\\n\",\n\t\t     fmt->code);\n\t\treturn 0;\n\t}\n\n\tif (!(csi2->output & CSI2_OUTPUT_CCDC) &&\n\t    !(csi2->output & CSI2_OUTPUT_MEMORY)) {\n\t\t \n\t\treturn CSI2_PIX_FMT_OTHERS;\n\t}\n\n\t \n\tdestidx = csi2->frame_skip ? 0 : !!(csi2->output & CSI2_OUTPUT_CCDC);\n\tis_3630 = csi2->isp->revision == ISP_REVISION_15_0;\n\n\treturn __csi2_fmt_map[fmtidx][destidx][csi2->dpcm_decompress][is_3630];\n}\n\n \nstatic void csi2_set_outaddr(struct isp_csi2_device *csi2, u32 addr)\n{\n\tstruct isp_device *isp = csi2->isp;\n\tstruct isp_csi2_ctx_cfg *ctx = &csi2->contexts[0];\n\n\tctx->ping_addr = addr;\n\tctx->pong_addr = addr;\n\tisp_reg_writel(isp, ctx->ping_addr,\n\t\t       csi2->regs1, ISPCSI2_CTX_DAT_PING_ADDR(ctx->ctxnum));\n\tisp_reg_writel(isp, ctx->pong_addr,\n\t\t       csi2->regs1, ISPCSI2_CTX_DAT_PONG_ADDR(ctx->ctxnum));\n}\n\n \nstatic inline int is_usr_def_mapping(u32 format_id)\n{\n\treturn (format_id & 0x40) ? 1 : 0;\n}\n\n \nstatic void csi2_ctx_enable(struct isp_device *isp,\n\t\t\t    struct isp_csi2_device *csi2, u8 ctxnum, u8 enable)\n{\n\tstruct isp_csi2_ctx_cfg *ctx = &csi2->contexts[ctxnum];\n\tunsigned int skip = 0;\n\tu32 reg;\n\n\treg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_CTRL1(ctxnum));\n\n\tif (enable) {\n\t\tif (csi2->frame_skip)\n\t\t\tskip = csi2->frame_skip;\n\t\telse if (csi2->output & CSI2_OUTPUT_MEMORY)\n\t\t\tskip = 1;\n\n\t\treg &= ~ISPCSI2_CTX_CTRL1_COUNT_MASK;\n\t\treg |= ISPCSI2_CTX_CTRL1_COUNT_UNLOCK\n\t\t    |  (skip << ISPCSI2_CTX_CTRL1_COUNT_SHIFT)\n\t\t    |  ISPCSI2_CTX_CTRL1_CTX_EN;\n\t} else {\n\t\treg &= ~ISPCSI2_CTX_CTRL1_CTX_EN;\n\t}\n\n\tisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTX_CTRL1(ctxnum));\n\tctx->enabled = enable;\n}\n\n \nstatic void csi2_ctx_config(struct isp_device *isp,\n\t\t\t    struct isp_csi2_device *csi2,\n\t\t\t    struct isp_csi2_ctx_cfg *ctx)\n{\n\tu32 reg;\n\n\t \n\treg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_CTRL1(ctx->ctxnum));\n\n\tif (ctx->eof_enabled)\n\t\treg |= ISPCSI2_CTX_CTRL1_EOF_EN;\n\telse\n\t\treg &= ~ISPCSI2_CTX_CTRL1_EOF_EN;\n\n\tif (ctx->eol_enabled)\n\t\treg |= ISPCSI2_CTX_CTRL1_EOL_EN;\n\telse\n\t\treg &= ~ISPCSI2_CTX_CTRL1_EOL_EN;\n\n\tif (ctx->checksum_enabled)\n\t\treg |= ISPCSI2_CTX_CTRL1_CS_EN;\n\telse\n\t\treg &= ~ISPCSI2_CTX_CTRL1_CS_EN;\n\n\tisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTX_CTRL1(ctx->ctxnum));\n\n\t \n\treg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_CTRL2(ctx->ctxnum));\n\n\treg &= ~(ISPCSI2_CTX_CTRL2_VIRTUAL_ID_MASK);\n\treg |= ctx->virtual_id << ISPCSI2_CTX_CTRL2_VIRTUAL_ID_SHIFT;\n\n\treg &= ~(ISPCSI2_CTX_CTRL2_FORMAT_MASK);\n\treg |= ctx->format_id << ISPCSI2_CTX_CTRL2_FORMAT_SHIFT;\n\n\tif (ctx->dpcm_decompress) {\n\t\tif (ctx->dpcm_predictor)\n\t\t\treg |= ISPCSI2_CTX_CTRL2_DPCM_PRED;\n\t\telse\n\t\t\treg &= ~ISPCSI2_CTX_CTRL2_DPCM_PRED;\n\t}\n\n\tif (is_usr_def_mapping(ctx->format_id)) {\n\t\treg &= ~ISPCSI2_CTX_CTRL2_USER_DEF_MAP_MASK;\n\t\treg |= 2 << ISPCSI2_CTX_CTRL2_USER_DEF_MAP_SHIFT;\n\t}\n\n\tisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTX_CTRL2(ctx->ctxnum));\n\n\t \n\treg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_CTRL3(ctx->ctxnum));\n\treg &= ~(ISPCSI2_CTX_CTRL3_ALPHA_MASK);\n\treg |= (ctx->alpha << ISPCSI2_CTX_CTRL3_ALPHA_SHIFT);\n\n\tisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTX_CTRL3(ctx->ctxnum));\n\n\t \n\treg = isp_reg_readl(isp, csi2->regs1,\n\t\t\t    ISPCSI2_CTX_DAT_OFST(ctx->ctxnum));\n\treg &= ~ISPCSI2_CTX_DAT_OFST_OFST_MASK;\n\treg |= ctx->data_offset << ISPCSI2_CTX_DAT_OFST_OFST_SHIFT;\n\tisp_reg_writel(isp, reg, csi2->regs1,\n\t\t       ISPCSI2_CTX_DAT_OFST(ctx->ctxnum));\n\n\tisp_reg_writel(isp, ctx->ping_addr,\n\t\t       csi2->regs1, ISPCSI2_CTX_DAT_PING_ADDR(ctx->ctxnum));\n\n\tisp_reg_writel(isp, ctx->pong_addr,\n\t\t       csi2->regs1, ISPCSI2_CTX_DAT_PONG_ADDR(ctx->ctxnum));\n}\n\n \nstatic void csi2_timing_config(struct isp_device *isp,\n\t\t\t       struct isp_csi2_device *csi2,\n\t\t\t       struct isp_csi2_timing_cfg *timing)\n{\n\tu32 reg;\n\n\treg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_TIMING);\n\n\tif (timing->force_rx_mode)\n\t\treg |= ISPCSI2_TIMING_FORCE_RX_MODE_IO(timing->ionum);\n\telse\n\t\treg &= ~ISPCSI2_TIMING_FORCE_RX_MODE_IO(timing->ionum);\n\n\tif (timing->stop_state_16x)\n\t\treg |= ISPCSI2_TIMING_STOP_STATE_X16_IO(timing->ionum);\n\telse\n\t\treg &= ~ISPCSI2_TIMING_STOP_STATE_X16_IO(timing->ionum);\n\n\tif (timing->stop_state_4x)\n\t\treg |= ISPCSI2_TIMING_STOP_STATE_X4_IO(timing->ionum);\n\telse\n\t\treg &= ~ISPCSI2_TIMING_STOP_STATE_X4_IO(timing->ionum);\n\n\treg &= ~ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_MASK(timing->ionum);\n\treg |= timing->stop_state_counter <<\n\t       ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_SHIFT(timing->ionum);\n\n\tisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_TIMING);\n}\n\n \nstatic void csi2_irq_ctx_set(struct isp_device *isp,\n\t\t\t     struct isp_csi2_device *csi2, int enable)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tisp_reg_writel(isp, ISPCSI2_CTX_IRQSTATUS_FE_IRQ, csi2->regs1,\n\t\t\t       ISPCSI2_CTX_IRQSTATUS(i));\n\t\tif (enable)\n\t\t\tisp_reg_set(isp, csi2->regs1, ISPCSI2_CTX_IRQENABLE(i),\n\t\t\t\t    ISPCSI2_CTX_IRQSTATUS_FE_IRQ);\n\t\telse\n\t\t\tisp_reg_clr(isp, csi2->regs1, ISPCSI2_CTX_IRQENABLE(i),\n\t\t\t\t    ISPCSI2_CTX_IRQSTATUS_FE_IRQ);\n\t}\n}\n\n \nstatic void csi2_irq_complexio1_set(struct isp_device *isp,\n\t\t\t\t    struct isp_csi2_device *csi2, int enable)\n{\n\tu32 reg;\n\treg = ISPCSI2_PHY_IRQENABLE_STATEALLULPMEXIT |\n\t\tISPCSI2_PHY_IRQENABLE_STATEALLULPMENTER |\n\t\tISPCSI2_PHY_IRQENABLE_STATEULPM5 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRCONTROL5 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRESC5 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS5 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRSOTHS5 |\n\t\tISPCSI2_PHY_IRQENABLE_STATEULPM4 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRCONTROL4 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRESC4 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS4 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRSOTHS4 |\n\t\tISPCSI2_PHY_IRQENABLE_STATEULPM3 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRCONTROL3 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRESC3 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS3 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRSOTHS3 |\n\t\tISPCSI2_PHY_IRQENABLE_STATEULPM2 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRCONTROL2 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRESC2 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS2 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRSOTHS2 |\n\t\tISPCSI2_PHY_IRQENABLE_STATEULPM1 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRCONTROL1 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRESC1 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS1 |\n\t\tISPCSI2_PHY_IRQENABLE_ERRSOTHS1;\n\tisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_PHY_IRQSTATUS);\n\tif (enable)\n\t\treg |= isp_reg_readl(isp, csi2->regs1, ISPCSI2_PHY_IRQENABLE);\n\telse\n\t\treg = 0;\n\tisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_PHY_IRQENABLE);\n}\n\n \nstatic void csi2_irq_status_set(struct isp_device *isp,\n\t\t\t\tstruct isp_csi2_device *csi2, int enable)\n{\n\tu32 reg;\n\treg = ISPCSI2_IRQSTATUS_OCP_ERR_IRQ |\n\t\tISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ |\n\t\tISPCSI2_IRQSTATUS_ECC_CORRECTION_IRQ |\n\t\tISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ |\n\t\tISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ |\n\t\tISPCSI2_IRQSTATUS_COMPLEXIO1_ERR_IRQ |\n\t\tISPCSI2_IRQSTATUS_FIFO_OVF_IRQ |\n\t\tISPCSI2_IRQSTATUS_CONTEXT(0);\n\tisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_IRQSTATUS);\n\tif (enable)\n\t\treg |= isp_reg_readl(isp, csi2->regs1, ISPCSI2_IRQENABLE);\n\telse\n\t\treg = 0;\n\n\tisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_IRQENABLE);\n}\n\n \nint omap3isp_csi2_reset(struct isp_csi2_device *csi2)\n{\n\tstruct isp_device *isp = csi2->isp;\n\tu8 soft_reset_retries = 0;\n\tu32 reg;\n\tint i;\n\n\tif (!csi2->available)\n\t\treturn -ENODEV;\n\n\tif (csi2->phy->entity)\n\t\treturn -EBUSY;\n\n\tisp_reg_set(isp, csi2->regs1, ISPCSI2_SYSCONFIG,\n\t\t    ISPCSI2_SYSCONFIG_SOFT_RESET);\n\n\tdo {\n\t\treg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_SYSSTATUS) &\n\t\t\t\t    ISPCSI2_SYSSTATUS_RESET_DONE;\n\t\tif (reg == ISPCSI2_SYSSTATUS_RESET_DONE)\n\t\t\tbreak;\n\t\tsoft_reset_retries++;\n\t\tif (soft_reset_retries < 5)\n\t\t\tudelay(100);\n\t} while (soft_reset_retries < 5);\n\n\tif (soft_reset_retries == 5) {\n\t\tdev_err(isp->dev, \"CSI2: Soft reset try count exceeded!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (isp->revision == ISP_REVISION_15_0)\n\t\tisp_reg_set(isp, csi2->regs1, ISPCSI2_PHY_CFG,\n\t\t\t    ISPCSI2_PHY_CFG_RESET_CTRL);\n\n\ti = 100;\n\tdo {\n\t\treg = isp_reg_readl(isp, csi2->phy->phy_regs, ISPCSIPHY_REG1)\n\t\t    & ISPCSIPHY_REG1_RESET_DONE_CTRLCLK;\n\t\tif (reg == ISPCSIPHY_REG1_RESET_DONE_CTRLCLK)\n\t\t\tbreak;\n\t\tudelay(100);\n\t} while (--i > 0);\n\n\tif (i == 0) {\n\t\tdev_err(isp->dev,\n\t\t\t\"CSI2: Reset for CSI2_96M_FCLK domain Failed!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (isp->autoidle)\n\t\tisp_reg_clr_set(isp, csi2->regs1, ISPCSI2_SYSCONFIG,\n\t\t\t\tISPCSI2_SYSCONFIG_MSTANDBY_MODE_MASK |\n\t\t\t\tISPCSI2_SYSCONFIG_AUTO_IDLE,\n\t\t\t\tISPCSI2_SYSCONFIG_MSTANDBY_MODE_SMART |\n\t\t\t\t((isp->revision == ISP_REVISION_15_0) ?\n\t\t\t\t ISPCSI2_SYSCONFIG_AUTO_IDLE : 0));\n\telse\n\t\tisp_reg_clr_set(isp, csi2->regs1, ISPCSI2_SYSCONFIG,\n\t\t\t\tISPCSI2_SYSCONFIG_MSTANDBY_MODE_MASK |\n\t\t\t\tISPCSI2_SYSCONFIG_AUTO_IDLE,\n\t\t\t\tISPCSI2_SYSCONFIG_MSTANDBY_MODE_NO);\n\n\treturn 0;\n}\n\nstatic int csi2_configure(struct isp_csi2_device *csi2)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&csi2->subdev.entity);\n\tconst struct isp_bus_cfg *buscfg;\n\tstruct isp_device *isp = csi2->isp;\n\tstruct isp_csi2_timing_cfg *timing = &csi2->timing[0];\n\tstruct v4l2_subdev *sensor;\n\tstruct media_pad *pad;\n\n\t \n\tif (csi2->contexts[0].enabled || csi2->ctrl.if_enable)\n\t\treturn -EBUSY;\n\n\tpad = media_pad_remote_pad_first(&csi2->pads[CSI2_PAD_SINK]);\n\tsensor = media_entity_to_v4l2_subdev(pad->entity);\n\tbuscfg = v4l2_subdev_to_bus_cfg(pipe->external);\n\tif (WARN_ON(!buscfg))\n\t\treturn -EPIPE;\n\n\tcsi2->frame_skip = 0;\n\tv4l2_subdev_call(sensor, sensor, g_skip_frames, &csi2->frame_skip);\n\n\tcsi2->ctrl.vp_out_ctrl =\n\t\tclamp_t(unsigned int, pipe->l3_ick / pipe->external_rate - 1,\n\t\t\t1, 3);\n\tdev_dbg(isp->dev, \"%s: l3_ick %lu, external_rate %u, vp_out_ctrl %u\\n\",\n\t\t__func__, pipe->l3_ick,  pipe->external_rate,\n\t\tcsi2->ctrl.vp_out_ctrl);\n\tcsi2->ctrl.frame_mode = ISP_CSI2_FRAME_IMMEDIATE;\n\tcsi2->ctrl.ecc_enable = buscfg->bus.csi2.crc;\n\n\ttiming->ionum = 1;\n\ttiming->force_rx_mode = 1;\n\ttiming->stop_state_16x = 1;\n\ttiming->stop_state_4x = 1;\n\ttiming->stop_state_counter = 0x1FF;\n\n\t \n\tif (csi2->formats[CSI2_PAD_SINK].code !=\n\t    csi2->formats[CSI2_PAD_SOURCE].code)\n\t\tcsi2->dpcm_decompress = true;\n\telse\n\t\tcsi2->dpcm_decompress = false;\n\n\tcsi2->contexts[0].format_id = csi2_ctx_map_format(csi2);\n\n\tif (csi2->video_out.bpl_padding == 0)\n\t\tcsi2->contexts[0].data_offset = 0;\n\telse\n\t\tcsi2->contexts[0].data_offset = csi2->video_out.bpl_value;\n\n\t \n\tcsi2->contexts[0].eof_enabled = 1;\n\tcsi2->contexts[0].eol_enabled = 1;\n\n\tcsi2_irq_complexio1_set(isp, csi2, 1);\n\tcsi2_irq_ctx_set(isp, csi2, 1);\n\tcsi2_irq_status_set(isp, csi2, 1);\n\n\t \n\tcsi2_timing_config(isp, csi2, timing);\n\tcsi2_recv_config(isp, csi2, &csi2->ctrl);\n\tcsi2_ctx_config(isp, csi2, &csi2->contexts[0]);\n\n\treturn 0;\n}\n\n \n#define CSI2_PRINT_REGISTER(isp, regs, name)\\\n\tdev_dbg(isp->dev, \"###CSI2 \" #name \"=0x%08x\\n\", \\\n\t\tisp_reg_readl(isp, regs, ISPCSI2_##name))\n\nstatic void csi2_print_status(struct isp_csi2_device *csi2)\n{\n\tstruct isp_device *isp = csi2->isp;\n\n\tif (!csi2->available)\n\t\treturn;\n\n\tdev_dbg(isp->dev, \"-------------CSI2 Register dump-------------\\n\");\n\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, SYSCONFIG);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, SYSSTATUS);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, IRQENABLE);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, IRQSTATUS);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, CTRL);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, DBG_H);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, GNQ);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, PHY_CFG);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, PHY_IRQSTATUS);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, SHORT_PACKET);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, PHY_IRQENABLE);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, DBG_P);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, TIMING);\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_CTRL1(0));\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_CTRL2(0));\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_DAT_OFST(0));\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_DAT_PING_ADDR(0));\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_DAT_PONG_ADDR(0));\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_IRQENABLE(0));\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_IRQSTATUS(0));\n\tCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_CTRL3(0));\n\n\tdev_dbg(isp->dev, \"--------------------------------------------\\n\");\n}\n\n \n\n \nstatic void csi2_isr_buffer(struct isp_csi2_device *csi2)\n{\n\tstruct isp_device *isp = csi2->isp;\n\tstruct isp_buffer *buffer;\n\n\tcsi2_ctx_enable(isp, csi2, 0, 0);\n\n\tbuffer = omap3isp_video_buffer_next(&csi2->video_out);\n\n\t \n\tif (buffer == NULL)\n\t\treturn;\n\n\tcsi2_set_outaddr(csi2, buffer->dma);\n\tcsi2_ctx_enable(isp, csi2, 0, 1);\n}\n\nstatic void csi2_isr_ctx(struct isp_csi2_device *csi2,\n\t\t\t struct isp_csi2_ctx_cfg *ctx)\n{\n\tstruct isp_device *isp = csi2->isp;\n\tunsigned int n = ctx->ctxnum;\n\tu32 status;\n\n\tstatus = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_IRQSTATUS(n));\n\tisp_reg_writel(isp, status, csi2->regs1, ISPCSI2_CTX_IRQSTATUS(n));\n\n\tif (!(status & ISPCSI2_CTX_IRQSTATUS_FE_IRQ))\n\t\treturn;\n\n\t \n\tif (csi2->frame_skip) {\n\t\tcsi2->frame_skip--;\n\t\tif (csi2->frame_skip == 0) {\n\t\t\tctx->format_id = csi2_ctx_map_format(csi2);\n\t\t\tcsi2_ctx_config(isp, csi2, ctx);\n\t\t\tcsi2_ctx_enable(isp, csi2, n, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (csi2->output & CSI2_OUTPUT_MEMORY)\n\t\tcsi2_isr_buffer(csi2);\n}\n\n \nvoid omap3isp_csi2_isr(struct isp_csi2_device *csi2)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&csi2->subdev.entity);\n\tu32 csi2_irqstatus, cpxio1_irqstatus;\n\tstruct isp_device *isp = csi2->isp;\n\n\tif (!csi2->available)\n\t\treturn;\n\n\tcsi2_irqstatus = isp_reg_readl(isp, csi2->regs1, ISPCSI2_IRQSTATUS);\n\tisp_reg_writel(isp, csi2_irqstatus, csi2->regs1, ISPCSI2_IRQSTATUS);\n\n\t \n\tif (csi2_irqstatus & ISPCSI2_IRQSTATUS_COMPLEXIO1_ERR_IRQ) {\n\t\tcpxio1_irqstatus = isp_reg_readl(isp, csi2->regs1,\n\t\t\t\t\t\t ISPCSI2_PHY_IRQSTATUS);\n\t\tisp_reg_writel(isp, cpxio1_irqstatus,\n\t\t\t       csi2->regs1, ISPCSI2_PHY_IRQSTATUS);\n\t\tdev_dbg(isp->dev, \"CSI2: ComplexIO Error IRQ %x\\n\",\n\t\t\tcpxio1_irqstatus);\n\t\tpipe->error = true;\n\t}\n\n\tif (csi2_irqstatus & (ISPCSI2_IRQSTATUS_OCP_ERR_IRQ |\n\t\t\t      ISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ |\n\t\t\t      ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ |\n\t\t\t      ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ |\n\t\t\t      ISPCSI2_IRQSTATUS_FIFO_OVF_IRQ)) {\n\t\tdev_dbg(isp->dev,\n\t\t\t\"CSI2 Err: OCP:%d, Short_pack:%d, ECC:%d, CPXIO2:%d, FIFO_OVF:%d,\\n\",\n\t\t\t(csi2_irqstatus &\n\t\t\t ISPCSI2_IRQSTATUS_OCP_ERR_IRQ) ? 1 : 0,\n\t\t\t(csi2_irqstatus &\n\t\t\t ISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ) ? 1 : 0,\n\t\t\t(csi2_irqstatus &\n\t\t\t ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ) ? 1 : 0,\n\t\t\t(csi2_irqstatus &\n\t\t\t ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ) ? 1 : 0,\n\t\t\t(csi2_irqstatus &\n\t\t\t ISPCSI2_IRQSTATUS_FIFO_OVF_IRQ) ? 1 : 0);\n\t\tpipe->error = true;\n\t}\n\n\tif (omap3isp_module_sync_is_stopping(&csi2->wait, &csi2->stopping))\n\t\treturn;\n\n\t \n\tif (csi2_irqstatus & ISPCSI2_IRQSTATUS_CONTEXT(0))\n\t\tcsi2_isr_ctx(csi2, &csi2->contexts[0]);\n\n\tif (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_CORRECTION_IRQ)\n\t\tdev_dbg(isp->dev, \"CSI2: ECC correction done\\n\");\n}\n\n \n\n \nstatic int csi2_queue(struct isp_video *video, struct isp_buffer *buffer)\n{\n\tstruct isp_device *isp = video->isp;\n\tstruct isp_csi2_device *csi2 = &isp->isp_csi2a;\n\n\tcsi2_set_outaddr(csi2, buffer->dma);\n\n\t \n\tif (csi2->video_out.dmaqueue_flags & ISP_VIDEO_DMAQUEUE_UNDERRUN) {\n\t\t \n\t\tcsi2_if_enable(isp, csi2, 1);\n\t\tcsi2_ctx_enable(isp, csi2, 0, 1);\n\t\tisp_video_dmaqueue_flags_clr(&csi2->video_out);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct isp_video_operations csi2_ispvideo_ops = {\n\t.queue = csi2_queue,\n};\n\n \n\nstatic struct v4l2_mbus_framefmt *\n__csi2_get_format(struct isp_csi2_device *csi2,\n\t\t  struct v4l2_subdev_state *sd_state,\n\t\t  unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&csi2->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\telse\n\t\treturn &csi2->formats[pad];\n}\n\nstatic void\ncsi2_try_format(struct isp_csi2_device *csi2,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tunsigned int pad, struct v4l2_mbus_framefmt *fmt,\n\t\tenum v4l2_subdev_format_whence which)\n{\n\tu32 pixelcode;\n\tstruct v4l2_mbus_framefmt *format;\n\tconst struct isp_format_info *info;\n\tunsigned int i;\n\n\tswitch (pad) {\n\tcase CSI2_PAD_SINK:\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(csi2_input_fmts); i++) {\n\t\t\tif (fmt->code == csi2_input_fmts[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i >= ARRAY_SIZE(csi2_input_fmts))\n\t\t\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\n\t\tfmt->width = clamp_t(u32, fmt->width, 1, 8191);\n\t\tfmt->height = clamp_t(u32, fmt->height, 1, 8191);\n\t\tbreak;\n\n\tcase CSI2_PAD_SOURCE:\n\t\t \n\t\tpixelcode = fmt->code;\n\t\tformat = __csi2_get_format(csi2, sd_state, CSI2_PAD_SINK,\n\t\t\t\t\t   which);\n\t\tmemcpy(fmt, format, sizeof(*fmt));\n\n\t\t \n\t\tinfo = omap3isp_video_format_info(fmt->code);\n\t\tif (info->uncompressed == pixelcode)\n\t\t\tfmt->code = pixelcode;\n\t\tbreak;\n\t}\n\n\t \n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\tfmt->field = V4L2_FIELD_NONE;\n}\n\n \nstatic int csi2_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct isp_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tconst struct isp_format_info *info;\n\n\tif (code->pad == CSI2_PAD_SINK) {\n\t\tif (code->index >= ARRAY_SIZE(csi2_input_fmts))\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = csi2_input_fmts[code->index];\n\t} else {\n\t\tformat = __csi2_get_format(csi2, sd_state, CSI2_PAD_SINK,\n\t\t\t\t\t   code->which);\n\t\tswitch (code->index) {\n\t\tcase 0:\n\t\t\t \n\t\t\tcode->code = format->code;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tinfo = omap3isp_video_format_info(format->code);\n\t\t\tif (info->uncompressed == format->code)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcode->code = info->uncompressed;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int csi2_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct isp_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tcsi2_try_format(csi2, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tcsi2_try_format(csi2, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int csi2_get_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct isp_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __csi2_get_format(csi2, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\treturn 0;\n}\n\n \nstatic int csi2_set_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct isp_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __csi2_get_format(csi2, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tcsi2_try_format(csi2, sd_state, fmt->pad, &fmt->format, fmt->which);\n\t*format = fmt->format;\n\n\t \n\tif (fmt->pad == CSI2_PAD_SINK) {\n\t\tformat = __csi2_get_format(csi2, sd_state, CSI2_PAD_SOURCE,\n\t\t\t\t\t   fmt->which);\n\t\t*format = fmt->format;\n\t\tcsi2_try_format(csi2, sd_state, CSI2_PAD_SOURCE, format,\n\t\t\t\tfmt->which);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int csi2_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format;\n\n\tmemset(&format, 0, sizeof(format));\n\tformat.pad = CSI2_PAD_SINK;\n\tformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\n\tformat.format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\tformat.format.width = 4096;\n\tformat.format.height = 4096;\n\tcsi2_set_format(sd, fh ? fh->state : NULL, &format);\n\n\treturn 0;\n}\n\n \nstatic int csi2_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct isp_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct isp_device *isp = csi2->isp;\n\tstruct isp_video *video_out = &csi2->video_out;\n\n\tswitch (enable) {\n\tcase ISP_PIPELINE_STREAM_CONTINUOUS:\n\t\tif (omap3isp_csiphy_acquire(csi2->phy, &sd->entity) < 0)\n\t\t\treturn -ENODEV;\n\t\tif (csi2->output & CSI2_OUTPUT_MEMORY)\n\t\t\tomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_CSI2A_WRITE);\n\t\tcsi2_configure(csi2);\n\t\tcsi2_print_status(csi2);\n\n\t\t \n\t\tif (csi2->output & CSI2_OUTPUT_MEMORY &&\n\t\t    !(video_out->dmaqueue_flags & ISP_VIDEO_DMAQUEUE_QUEUED))\n\t\t\tbreak;\n\t\t \n\t\tatomic_set(&csi2->stopping, 0);\n\t\tcsi2_ctx_enable(isp, csi2, 0, 1);\n\t\tcsi2_if_enable(isp, csi2, 1);\n\t\tisp_video_dmaqueue_flags_clr(video_out);\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_STOPPED:\n\t\tif (csi2->state == ISP_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\t\tif (omap3isp_module_sync_idle(&sd->entity, &csi2->wait,\n\t\t\t\t\t      &csi2->stopping))\n\t\t\tdev_dbg(isp->dev, \"%s: module stop timeout.\\n\",\n\t\t\t\tsd->name);\n\t\tcsi2_ctx_enable(isp, csi2, 0, 0);\n\t\tcsi2_if_enable(isp, csi2, 0);\n\t\tcsi2_irq_ctx_set(isp, csi2, 0);\n\t\tomap3isp_csiphy_release(csi2->phy);\n\t\tisp_video_dmaqueue_flags_clr(video_out);\n\t\tomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_CSI2A_WRITE);\n\t\tbreak;\n\t}\n\n\tcsi2->state = enable;\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_video_ops csi2_video_ops = {\n\t.s_stream = csi2_set_stream,\n};\n\n \nstatic const struct v4l2_subdev_pad_ops csi2_pad_ops = {\n\t.enum_mbus_code = csi2_enum_mbus_code,\n\t.enum_frame_size = csi2_enum_frame_size,\n\t.get_fmt = csi2_get_format,\n\t.set_fmt = csi2_set_format,\n};\n\n \nstatic const struct v4l2_subdev_ops csi2_ops = {\n\t.video = &csi2_video_ops,\n\t.pad = &csi2_pad_ops,\n};\n\n \nstatic const struct v4l2_subdev_internal_ops csi2_internal_ops = {\n\t.open = csi2_init_formats,\n};\n\n \n\n \nstatic int csi2_link_setup(struct media_entity *entity,\n\t\t\t   const struct media_pad *local,\n\t\t\t   const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct isp_csi2_device *csi2 = v4l2_get_subdevdata(sd);\n\tstruct isp_csi2_ctrl_cfg *ctrl = &csi2->ctrl;\n\tunsigned int index = local->index;\n\n\t \n\n\t \n\tif (is_media_entity_v4l2_subdev(remote->entity))\n\t\tindex |= 2 << 16;\n\n\tswitch (index) {\n\tcase CSI2_PAD_SOURCE:\n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (csi2->output & ~CSI2_OUTPUT_MEMORY)\n\t\t\t\treturn -EBUSY;\n\t\t\tcsi2->output |= CSI2_OUTPUT_MEMORY;\n\t\t} else {\n\t\t\tcsi2->output &= ~CSI2_OUTPUT_MEMORY;\n\t\t}\n\t\tbreak;\n\n\tcase CSI2_PAD_SOURCE | 2 << 16:\n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (csi2->output & ~CSI2_OUTPUT_CCDC)\n\t\t\t\treturn -EBUSY;\n\t\t\tcsi2->output |= CSI2_OUTPUT_CCDC;\n\t\t} else {\n\t\t\tcsi2->output &= ~CSI2_OUTPUT_CCDC;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tctrl->vp_only_enable =\n\t\t(csi2->output & CSI2_OUTPUT_MEMORY) ? false : true;\n\tctrl->vp_clk_enable = !!(csi2->output & CSI2_OUTPUT_CCDC);\n\n\treturn 0;\n}\n\n \nstatic const struct media_entity_operations csi2_media_ops = {\n\t.link_setup = csi2_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nvoid omap3isp_csi2_unregister_entities(struct isp_csi2_device *csi2)\n{\n\tv4l2_device_unregister_subdev(&csi2->subdev);\n\tomap3isp_video_unregister(&csi2->video_out);\n}\n\nint omap3isp_csi2_register_entities(struct isp_csi2_device *csi2,\n\t\t\t\t    struct v4l2_device *vdev)\n{\n\tint ret;\n\n\t \n\tcsi2->subdev.dev = vdev->mdev->dev;\n\tret = v4l2_device_register_subdev(vdev, &csi2->subdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = omap3isp_video_register(&csi2->video_out, vdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tomap3isp_csi2_unregister_entities(csi2);\n\treturn ret;\n}\n\n \n\n \nstatic int csi2_init_entities(struct isp_csi2_device *csi2)\n{\n\tstruct v4l2_subdev *sd = &csi2->subdev;\n\tstruct media_pad *pads = csi2->pads;\n\tstruct media_entity *me = &sd->entity;\n\tint ret;\n\n\tv4l2_subdev_init(sd, &csi2_ops);\n\tsd->internal_ops = &csi2_internal_ops;\n\tstrscpy(sd->name, \"OMAP3 ISP CSI2a\", sizeof(sd->name));\n\n\tsd->grp_id = 1 << 16;\t \n\tv4l2_set_subdevdata(sd, csi2);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tpads[CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\tpads[CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK\n\t\t\t\t    | MEDIA_PAD_FL_MUST_CONNECT;\n\n\tme->ops = &csi2_media_ops;\n\tret = media_entity_pads_init(me, CSI2_PADS_NUM, pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcsi2_init_formats(sd, NULL);\n\n\t \n\tcsi2->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tcsi2->video_out.ops = &csi2_ispvideo_ops;\n\tcsi2->video_out.bpl_alignment = 32;\n\tcsi2->video_out.bpl_zero_padding = 1;\n\tcsi2->video_out.bpl_max = 0x1ffe0;\n\tcsi2->video_out.isp = csi2->isp;\n\tcsi2->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 3;\n\n\tret = omap3isp_video_init(&csi2->video_out, \"CSI2a\");\n\tif (ret < 0)\n\t\tgoto error_video;\n\n\treturn 0;\n\nerror_video:\n\tmedia_entity_cleanup(&csi2->subdev.entity);\n\treturn ret;\n}\n\n \nint omap3isp_csi2_init(struct isp_device *isp)\n{\n\tstruct isp_csi2_device *csi2a = &isp->isp_csi2a;\n\tstruct isp_csi2_device *csi2c = &isp->isp_csi2c;\n\tint ret;\n\n\tcsi2a->isp = isp;\n\tcsi2a->available = 1;\n\tcsi2a->regs1 = OMAP3_ISP_IOMEM_CSI2A_REGS1;\n\tcsi2a->regs2 = OMAP3_ISP_IOMEM_CSI2A_REGS2;\n\tcsi2a->phy = &isp->isp_csiphy2;\n\tcsi2a->state = ISP_PIPELINE_STREAM_STOPPED;\n\tinit_waitqueue_head(&csi2a->wait);\n\n\tret = csi2_init_entities(csi2a);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (isp->revision == ISP_REVISION_15_0) {\n\t\tcsi2c->isp = isp;\n\t\tcsi2c->available = 1;\n\t\tcsi2c->regs1 = OMAP3_ISP_IOMEM_CSI2C_REGS1;\n\t\tcsi2c->regs2 = OMAP3_ISP_IOMEM_CSI2C_REGS2;\n\t\tcsi2c->phy = &isp->isp_csiphy1;\n\t\tcsi2c->state = ISP_PIPELINE_STREAM_STOPPED;\n\t\tinit_waitqueue_head(&csi2c->wait);\n\t}\n\n\treturn 0;\n}\n\n \nvoid omap3isp_csi2_cleanup(struct isp_device *isp)\n{\n\tstruct isp_csi2_device *csi2a = &isp->isp_csi2a;\n\n\tomap3isp_video_cleanup(&csi2a->video_out);\n\tmedia_entity_cleanup(&csi2a->subdev.entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}