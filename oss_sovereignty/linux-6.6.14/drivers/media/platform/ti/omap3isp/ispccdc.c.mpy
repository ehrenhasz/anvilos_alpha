{
  "module_name": "ispccdc.c",
  "hash_id": "15ab89dd0ce571d78dfdca3299c36e23f24029703bc4801666d0d0b49f0a5fa9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap3isp/ispccdc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <media/v4l2-event.h>\n\n#include \"isp.h\"\n#include \"ispreg.h\"\n#include \"ispccdc.h\"\n\n#define CCDC_MIN_WIDTH\t\t32\n#define CCDC_MIN_HEIGHT\t\t32\n\nstatic struct v4l2_mbus_framefmt *\n__ccdc_get_format(struct isp_ccdc_device *ccdc,\n\t\t  struct v4l2_subdev_state *sd_state,\n\t\t  unsigned int pad, enum v4l2_subdev_format_whence which);\n\nstatic const unsigned int ccdc_fmts[] = {\n\tMEDIA_BUS_FMT_Y8_1X8,\n\tMEDIA_BUS_FMT_Y10_1X10,\n\tMEDIA_BUS_FMT_Y12_1X12,\n\tMEDIA_BUS_FMT_SGRBG8_1X8,\n\tMEDIA_BUS_FMT_SRGGB8_1X8,\n\tMEDIA_BUS_FMT_SBGGR8_1X8,\n\tMEDIA_BUS_FMT_SGBRG8_1X8,\n\tMEDIA_BUS_FMT_SGRBG10_1X10,\n\tMEDIA_BUS_FMT_SRGGB10_1X10,\n\tMEDIA_BUS_FMT_SBGGR10_1X10,\n\tMEDIA_BUS_FMT_SGBRG10_1X10,\n\tMEDIA_BUS_FMT_SGRBG12_1X12,\n\tMEDIA_BUS_FMT_SRGGB12_1X12,\n\tMEDIA_BUS_FMT_SBGGR12_1X12,\n\tMEDIA_BUS_FMT_SGBRG12_1X12,\n\tMEDIA_BUS_FMT_YUYV8_2X8,\n\tMEDIA_BUS_FMT_UYVY8_2X8,\n};\n\n \n#define CCDC_PRINT_REGISTER(isp, name)\\\n\tdev_dbg(isp->dev, \"###CCDC \" #name \"=0x%08x\\n\", \\\n\t\tisp_reg_readl(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_##name))\n\nstatic void ccdc_print_status(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\n\tdev_dbg(isp->dev, \"-------------CCDC Register dump-------------\\n\");\n\n\tCCDC_PRINT_REGISTER(isp, PCR);\n\tCCDC_PRINT_REGISTER(isp, SYN_MODE);\n\tCCDC_PRINT_REGISTER(isp, HD_VD_WID);\n\tCCDC_PRINT_REGISTER(isp, PIX_LINES);\n\tCCDC_PRINT_REGISTER(isp, HORZ_INFO);\n\tCCDC_PRINT_REGISTER(isp, VERT_START);\n\tCCDC_PRINT_REGISTER(isp, VERT_LINES);\n\tCCDC_PRINT_REGISTER(isp, CULLING);\n\tCCDC_PRINT_REGISTER(isp, HSIZE_OFF);\n\tCCDC_PRINT_REGISTER(isp, SDOFST);\n\tCCDC_PRINT_REGISTER(isp, SDR_ADDR);\n\tCCDC_PRINT_REGISTER(isp, CLAMP);\n\tCCDC_PRINT_REGISTER(isp, DCSUB);\n\tCCDC_PRINT_REGISTER(isp, COLPTN);\n\tCCDC_PRINT_REGISTER(isp, BLKCMP);\n\tCCDC_PRINT_REGISTER(isp, FPC);\n\tCCDC_PRINT_REGISTER(isp, FPC_ADDR);\n\tCCDC_PRINT_REGISTER(isp, VDINT);\n\tCCDC_PRINT_REGISTER(isp, ALAW);\n\tCCDC_PRINT_REGISTER(isp, REC656IF);\n\tCCDC_PRINT_REGISTER(isp, CFG);\n\tCCDC_PRINT_REGISTER(isp, FMTCFG);\n\tCCDC_PRINT_REGISTER(isp, FMT_HORZ);\n\tCCDC_PRINT_REGISTER(isp, FMT_VERT);\n\tCCDC_PRINT_REGISTER(isp, PRGEVEN0);\n\tCCDC_PRINT_REGISTER(isp, PRGEVEN1);\n\tCCDC_PRINT_REGISTER(isp, PRGODD0);\n\tCCDC_PRINT_REGISTER(isp, PRGODD1);\n\tCCDC_PRINT_REGISTER(isp, VP_OUT);\n\tCCDC_PRINT_REGISTER(isp, LSC_CONFIG);\n\tCCDC_PRINT_REGISTER(isp, LSC_INITIAL);\n\tCCDC_PRINT_REGISTER(isp, LSC_TABLE_BASE);\n\tCCDC_PRINT_REGISTER(isp, LSC_TABLE_OFFSET);\n\n\tdev_dbg(isp->dev, \"--------------------------------------------\\n\");\n}\n\n \nint omap3isp_ccdc_busy(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\n\treturn isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PCR) &\n\t\tISPCCDC_PCR_BUSY;\n}\n\n \n\n \nstatic int ccdc_lsc_validate_config(struct isp_ccdc_device *ccdc,\n\t\t\t\t    struct omap3isp_ccdc_lsc_config *lsc_cfg)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tstruct v4l2_mbus_framefmt *format;\n\tunsigned int paxel_width, paxel_height;\n\tunsigned int paxel_shift_x, paxel_shift_y;\n\tunsigned int min_width, min_height, min_size;\n\tunsigned int input_width, input_height;\n\n\tpaxel_shift_x = lsc_cfg->gain_mode_m;\n\tpaxel_shift_y = lsc_cfg->gain_mode_n;\n\n\tif ((paxel_shift_x < 2) || (paxel_shift_x > 6) ||\n\t    (paxel_shift_y < 2) || (paxel_shift_y > 6)) {\n\t\tdev_dbg(isp->dev, \"CCDC: LSC: Invalid paxel size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (lsc_cfg->offset & 3) {\n\t\tdev_dbg(isp->dev,\n\t\t\t\"CCDC: LSC: Offset must be a multiple of 4\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((lsc_cfg->initial_x & 1) || (lsc_cfg->initial_y & 1)) {\n\t\tdev_dbg(isp->dev, \"CCDC: LSC: initial_x and y must be even\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tformat = __ccdc_get_format(ccdc, NULL, CCDC_PAD_SINK,\n\t\t\t\t   V4L2_SUBDEV_FORMAT_ACTIVE);\n\tinput_width = format->width;\n\tinput_height = format->height;\n\n\t \n\tpaxel_width = 1 << paxel_shift_x;\n\tmin_width = ((input_width + lsc_cfg->initial_x + paxel_width - 1)\n\t\t     >> paxel_shift_x) + 1;\n\n\tpaxel_height = 1 << paxel_shift_y;\n\tmin_height = ((input_height + lsc_cfg->initial_y + paxel_height - 1)\n\t\t     >> paxel_shift_y) + 1;\n\n\tmin_size = 4 * min_width * min_height;\n\tif (min_size > lsc_cfg->size) {\n\t\tdev_dbg(isp->dev, \"CCDC: LSC: too small table\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (lsc_cfg->offset < (min_width * 4)) {\n\t\tdev_dbg(isp->dev, \"CCDC: LSC: Offset is too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((lsc_cfg->size / lsc_cfg->offset) < min_height) {\n\t\tdev_dbg(isp->dev, \"CCDC: LSC: Wrong size/offset combination\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic void ccdc_lsc_program_table(struct isp_ccdc_device *ccdc,\n\t\t\t\t   dma_addr_t addr)\n{\n\tisp_reg_writel(to_isp_device(ccdc), addr,\n\t\t       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_TABLE_BASE);\n}\n\n \nstatic void ccdc_lsc_setup_regs(struct isp_ccdc_device *ccdc,\n\t\t\t\tstruct omap3isp_ccdc_lsc_config *cfg)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tint reg;\n\n\tisp_reg_writel(isp, cfg->offset, OMAP3_ISP_IOMEM_CCDC,\n\t\t       ISPCCDC_LSC_TABLE_OFFSET);\n\n\treg = 0;\n\treg |= cfg->gain_mode_n << ISPCCDC_LSC_GAIN_MODE_N_SHIFT;\n\treg |= cfg->gain_mode_m << ISPCCDC_LSC_GAIN_MODE_M_SHIFT;\n\treg |= cfg->gain_format << ISPCCDC_LSC_GAIN_FORMAT_SHIFT;\n\tisp_reg_writel(isp, reg, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_CONFIG);\n\n\treg = 0;\n\treg &= ~ISPCCDC_LSC_INITIAL_X_MASK;\n\treg |= cfg->initial_x << ISPCCDC_LSC_INITIAL_X_SHIFT;\n\treg &= ~ISPCCDC_LSC_INITIAL_Y_MASK;\n\treg |= cfg->initial_y << ISPCCDC_LSC_INITIAL_Y_SHIFT;\n\tisp_reg_writel(isp, reg, OMAP3_ISP_IOMEM_CCDC,\n\t\t       ISPCCDC_LSC_INITIAL);\n}\n\nstatic int ccdc_lsc_wait_prefetch(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tunsigned int wait;\n\n\tisp_reg_writel(isp, IRQ0STATUS_CCDC_LSC_PREF_COMP_IRQ,\n\t\t       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\n\n\t \n\tfor (wait = 0; wait < 1000; wait++) {\n\t\tif (isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS) &\n\t\t\t\t  IRQ0STATUS_CCDC_LSC_PREF_COMP_IRQ) {\n\t\t\tisp_reg_writel(isp, IRQ0STATUS_CCDC_LSC_PREF_COMP_IRQ,\n\t\t\t\t       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\n\t\t\treturn 0;\n\t\t}\n\n\t\trmb();\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int __ccdc_lsc_enable(struct isp_ccdc_device *ccdc, int enable)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tconst struct v4l2_mbus_framefmt *format =\n\t\t__ccdc_get_format(ccdc, NULL, CCDC_PAD_SINK,\n\t\t\t\t  V4L2_SUBDEV_FORMAT_ACTIVE);\n\n\tif ((format->code != MEDIA_BUS_FMT_SGRBG10_1X10) &&\n\t    (format->code != MEDIA_BUS_FMT_SRGGB10_1X10) &&\n\t    (format->code != MEDIA_BUS_FMT_SBGGR10_1X10) &&\n\t    (format->code != MEDIA_BUS_FMT_SGBRG10_1X10))\n\t\treturn -EINVAL;\n\n\tif (enable)\n\t\tomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_CCDC_LSC_READ);\n\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_CONFIG,\n\t\t\tISPCCDC_LSC_ENABLE, enable ? ISPCCDC_LSC_ENABLE : 0);\n\n\tif (enable) {\n\t\tif (ccdc_lsc_wait_prefetch(ccdc) < 0) {\n\t\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_CCDC,\n\t\t\t\t    ISPCCDC_LSC_CONFIG, ISPCCDC_LSC_ENABLE);\n\t\t\tccdc->lsc.state = LSC_STATE_STOPPED;\n\t\t\tdev_warn(to_device(ccdc), \"LSC prefetch timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tccdc->lsc.state = LSC_STATE_RUNNING;\n\t} else {\n\t\tccdc->lsc.state = LSC_STATE_STOPPING;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccdc_lsc_busy(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\n\treturn isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_CONFIG) &\n\t\t\t     ISPCCDC_LSC_BUSY;\n}\n\n \nstatic int __ccdc_lsc_configure(struct isp_ccdc_device *ccdc,\n\t\t\t\tstruct ispccdc_lsc_config_req *req)\n{\n\tif (!req->enable)\n\t\treturn -EINVAL;\n\n\tif (ccdc_lsc_validate_config(ccdc, &req->config) < 0) {\n\t\tdev_dbg(to_device(ccdc), \"Discard LSC configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ccdc_lsc_busy(ccdc))\n\t\treturn -EBUSY;\n\n\tccdc_lsc_setup_regs(ccdc, &req->config);\n\tccdc_lsc_program_table(ccdc, req->table.dma);\n\treturn 0;\n}\n\n \nstatic void ccdc_lsc_error_handler(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\t \n\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_CONFIG,\n\t\t    ISPCCDC_LSC_ENABLE);\n\tccdc->lsc.state = LSC_STATE_STOPPED;\n}\n\nstatic void ccdc_lsc_free_request(struct isp_ccdc_device *ccdc,\n\t\t\t\t  struct ispccdc_lsc_config_req *req)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\n\tif (req == NULL)\n\t\treturn;\n\n\tif (req->table.addr) {\n\t\tsg_free_table(&req->table.sgt);\n\t\tdma_free_coherent(isp->dev, req->config.size, req->table.addr,\n\t\t\t\t  req->table.dma);\n\t}\n\n\tkfree(req);\n}\n\nstatic void ccdc_lsc_free_queue(struct isp_ccdc_device *ccdc,\n\t\t\t\tstruct list_head *queue)\n{\n\tstruct ispccdc_lsc_config_req *req, *n;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\n\tlist_for_each_entry_safe(req, n, queue, list) {\n\t\tlist_del(&req->list);\n\t\tspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\n\t\tccdc_lsc_free_request(ccdc, req);\n\t\tspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\n}\n\nstatic void ccdc_lsc_free_table_work(struct work_struct *work)\n{\n\tstruct isp_ccdc_device *ccdc;\n\tstruct ispccdc_lsc *lsc;\n\n\tlsc = container_of(work, struct ispccdc_lsc, table_work);\n\tccdc = container_of(lsc, struct isp_ccdc_device, lsc);\n\n\tccdc_lsc_free_queue(ccdc, &lsc->free_queue);\n}\n\n \nstatic int ccdc_lsc_config(struct isp_ccdc_device *ccdc,\n\t\t\t   struct omap3isp_ccdc_update_config *config)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tstruct ispccdc_lsc_config_req *req;\n\tunsigned long flags;\n\tu16 update;\n\tint ret;\n\n\tupdate = config->update &\n\t\t (OMAP3ISP_CCDC_CONFIG_LSC | OMAP3ISP_CCDC_TBL_LSC);\n\tif (!update)\n\t\treturn 0;\n\n\tif (update != (OMAP3ISP_CCDC_CONFIG_LSC | OMAP3ISP_CCDC_TBL_LSC)) {\n\t\tdev_dbg(to_device(ccdc),\n\t\t\t\"%s: Both LSC configuration and table need to be supplied\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (req == NULL)\n\t\treturn -ENOMEM;\n\n\tif (config->flag & OMAP3ISP_CCDC_CONFIG_LSC) {\n\t\tif (copy_from_user(&req->config, config->lsc_cfg,\n\t\t\t\t   sizeof(req->config))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\n\t\treq->enable = 1;\n\n\t\treq->table.addr = dma_alloc_coherent(isp->dev, req->config.size,\n\t\t\t\t\t\t     &req->table.dma,\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (req->table.addr == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = dma_get_sgtable(isp->dev, &req->table.sgt,\n\t\t\t\t      req->table.addr, req->table.dma,\n\t\t\t\t      req->config.size);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tdma_sync_sg_for_cpu(isp->dev, req->table.sgt.sgl,\n\t\t\t\t    req->table.sgt.nents, DMA_TO_DEVICE);\n\n\t\tif (copy_from_user(req->table.addr, config->lsc,\n\t\t\t\t   req->config.size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\n\t\tdma_sync_sg_for_device(isp->dev, req->table.sgt.sgl,\n\t\t\t\t       req->table.sgt.nents, DMA_TO_DEVICE);\n\t}\n\n\tspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\n\tif (ccdc->lsc.request) {\n\t\tlist_add_tail(&ccdc->lsc.request->list, &ccdc->lsc.free_queue);\n\t\tschedule_work(&ccdc->lsc.table_work);\n\t}\n\tccdc->lsc.request = req;\n\tspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\n\n\tret = 0;\n\ndone:\n\tif (ret < 0)\n\t\tccdc_lsc_free_request(ccdc, req);\n\n\treturn ret;\n}\n\nstatic inline int ccdc_lsc_is_configured(struct isp_ccdc_device *ccdc)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\n\tret = ccdc->lsc.active != NULL;\n\tspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\n\n\treturn ret;\n}\n\nstatic int ccdc_lsc_enable(struct isp_ccdc_device *ccdc)\n{\n\tstruct ispccdc_lsc *lsc = &ccdc->lsc;\n\n\tif (lsc->state != LSC_STATE_STOPPED)\n\t\treturn -EINVAL;\n\n\tif (lsc->active) {\n\t\tlist_add_tail(&lsc->active->list, &lsc->free_queue);\n\t\tlsc->active = NULL;\n\t}\n\n\tif (__ccdc_lsc_configure(ccdc, lsc->request) < 0) {\n\t\tomap3isp_sbl_disable(to_isp_device(ccdc),\n\t\t\t\tOMAP3_ISP_SBL_CCDC_LSC_READ);\n\t\tlist_add_tail(&lsc->request->list, &lsc->free_queue);\n\t\tlsc->request = NULL;\n\t\tgoto done;\n\t}\n\n\tlsc->active = lsc->request;\n\tlsc->request = NULL;\n\t__ccdc_lsc_enable(ccdc, 1);\n\ndone:\n\tif (!list_empty(&lsc->free_queue))\n\t\tschedule_work(&lsc->table_work);\n\n\treturn 0;\n}\n\n \n\n \nstatic void ccdc_configure_clamp(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tu32 clamp;\n\n\tif (ccdc->obclamp) {\n\t\tclamp  = ccdc->clamp.obgain << ISPCCDC_CLAMP_OBGAIN_SHIFT;\n\t\tclamp |= ccdc->clamp.oblen << ISPCCDC_CLAMP_OBSLEN_SHIFT;\n\t\tclamp |= ccdc->clamp.oblines << ISPCCDC_CLAMP_OBSLN_SHIFT;\n\t\tclamp |= ccdc->clamp.obstpixel << ISPCCDC_CLAMP_OBST_SHIFT;\n\t\tisp_reg_writel(isp, clamp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP);\n\t} else {\n\t\tisp_reg_writel(isp, ccdc->clamp.dcsubval,\n\t\t\t       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_DCSUB);\n\t}\n\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP,\n\t\t\tISPCCDC_CLAMP_CLAMPEN,\n\t\t\tccdc->obclamp ? ISPCCDC_CLAMP_CLAMPEN : 0);\n}\n\n \nstatic void ccdc_configure_fpc(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\n\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC, ISPCCDC_FPC_FPCEN);\n\n\tif (!ccdc->fpc_en)\n\t\treturn;\n\n\tisp_reg_writel(isp, ccdc->fpc.dma, OMAP3_ISP_IOMEM_CCDC,\n\t\t       ISPCCDC_FPC_ADDR);\n\t \n\tisp_reg_writel(isp, (ccdc->fpc.fpnum << ISPCCDC_FPC_FPNUM_SHIFT),\n\t\t       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);\n\tisp_reg_writel(isp, (ccdc->fpc.fpnum << ISPCCDC_FPC_FPNUM_SHIFT) |\n\t\t       ISPCCDC_FPC_FPCEN, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);\n}\n\n \nstatic void ccdc_configure_black_comp(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tu32 blcomp;\n\n\tblcomp  = ccdc->blcomp.b_mg << ISPCCDC_BLKCMP_B_MG_SHIFT;\n\tblcomp |= ccdc->blcomp.gb_g << ISPCCDC_BLKCMP_GB_G_SHIFT;\n\tblcomp |= ccdc->blcomp.gr_cy << ISPCCDC_BLKCMP_GR_CY_SHIFT;\n\tblcomp |= ccdc->blcomp.r_ye << ISPCCDC_BLKCMP_R_YE_SHIFT;\n\n\tisp_reg_writel(isp, blcomp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_BLKCMP);\n}\n\n \nstatic void ccdc_configure_lpf(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE,\n\t\t\tISPCCDC_SYN_MODE_LPF,\n\t\t\tccdc->lpf ? ISPCCDC_SYN_MODE_LPF : 0);\n}\n\n \nstatic void ccdc_configure_alaw(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tconst struct isp_format_info *info;\n\tu32 alaw = 0;\n\n\tinfo = omap3isp_video_format_info(ccdc->formats[CCDC_PAD_SINK].code);\n\n\tswitch (info->width) {\n\tcase 8:\n\t\treturn;\n\n\tcase 10:\n\t\talaw = ISPCCDC_ALAW_GWDI_9_0;\n\t\tbreak;\n\tcase 11:\n\t\talaw = ISPCCDC_ALAW_GWDI_10_1;\n\t\tbreak;\n\tcase 12:\n\t\talaw = ISPCCDC_ALAW_GWDI_11_2;\n\t\tbreak;\n\tcase 13:\n\t\talaw = ISPCCDC_ALAW_GWDI_12_3;\n\t\tbreak;\n\t}\n\n\tif (ccdc->alaw)\n\t\talaw |= ISPCCDC_ALAW_CCDTBL;\n\n\tisp_reg_writel(isp, alaw, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW);\n}\n\n \nstatic void ccdc_config_imgattr(struct isp_ccdc_device *ccdc, u32 colptn)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\n\tisp_reg_writel(isp, colptn, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_COLPTN);\n}\n\n \nstatic int ccdc_config(struct isp_ccdc_device *ccdc,\n\t\t       struct omap3isp_ccdc_update_config *ccdc_struct)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ccdc->lock, flags);\n\tccdc->shadow_update = 1;\n\tspin_unlock_irqrestore(&ccdc->lock, flags);\n\n\tif (OMAP3ISP_CCDC_ALAW & ccdc_struct->update) {\n\t\tccdc->alaw = !!(OMAP3ISP_CCDC_ALAW & ccdc_struct->flag);\n\t\tccdc->update |= OMAP3ISP_CCDC_ALAW;\n\t}\n\n\tif (OMAP3ISP_CCDC_LPF & ccdc_struct->update) {\n\t\tccdc->lpf = !!(OMAP3ISP_CCDC_LPF & ccdc_struct->flag);\n\t\tccdc->update |= OMAP3ISP_CCDC_LPF;\n\t}\n\n\tif (OMAP3ISP_CCDC_BLCLAMP & ccdc_struct->update) {\n\t\tif (copy_from_user(&ccdc->clamp, ccdc_struct->bclamp,\n\t\t\t\t   sizeof(ccdc->clamp))) {\n\t\t\tccdc->shadow_update = 0;\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tccdc->obclamp = !!(OMAP3ISP_CCDC_BLCLAMP & ccdc_struct->flag);\n\t\tccdc->update |= OMAP3ISP_CCDC_BLCLAMP;\n\t}\n\n\tif (OMAP3ISP_CCDC_BCOMP & ccdc_struct->update) {\n\t\tif (copy_from_user(&ccdc->blcomp, ccdc_struct->blcomp,\n\t\t\t\t   sizeof(ccdc->blcomp))) {\n\t\t\tccdc->shadow_update = 0;\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tccdc->update |= OMAP3ISP_CCDC_BCOMP;\n\t}\n\n\tccdc->shadow_update = 0;\n\n\tif (OMAP3ISP_CCDC_FPC & ccdc_struct->update) {\n\t\tstruct omap3isp_ccdc_fpc fpc;\n\t\tstruct ispccdc_fpc fpc_old = { .addr = NULL, };\n\t\tstruct ispccdc_fpc fpc_new;\n\t\tu32 size;\n\n\t\tif (ccdc->state != ISP_PIPELINE_STREAM_STOPPED)\n\t\t\treturn -EBUSY;\n\n\t\tccdc->fpc_en = !!(OMAP3ISP_CCDC_FPC & ccdc_struct->flag);\n\n\t\tif (ccdc->fpc_en) {\n\t\t\tif (copy_from_user(&fpc, ccdc_struct->fpc, sizeof(fpc)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tsize = fpc.fpnum * 4;\n\n\t\t\t \n\t\t\tfpc_new.fpnum = fpc.fpnum;\n\t\t\tfpc_new.addr = dma_alloc_coherent(isp->dev, size,\n\t\t\t\t\t\t\t  &fpc_new.dma,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (fpc_new.addr == NULL)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (copy_from_user(fpc_new.addr,\n\t\t\t\t\t   (__force void __user *)(long)fpc.fpcaddr,\n\t\t\t\t\t   size)) {\n\t\t\t\tdma_free_coherent(isp->dev, size, fpc_new.addr,\n\t\t\t\t\t\t  fpc_new.dma);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\tfpc_old = ccdc->fpc;\n\t\t\tccdc->fpc = fpc_new;\n\t\t}\n\n\t\tccdc_configure_fpc(ccdc);\n\n\t\tif (fpc_old.addr != NULL)\n\t\t\tdma_free_coherent(isp->dev, fpc_old.fpnum * 4,\n\t\t\t\t\t  fpc_old.addr, fpc_old.dma);\n\t}\n\n\treturn ccdc_lsc_config(ccdc, ccdc_struct);\n}\n\nstatic void ccdc_apply_controls(struct isp_ccdc_device *ccdc)\n{\n\tif (ccdc->update & OMAP3ISP_CCDC_ALAW) {\n\t\tccdc_configure_alaw(ccdc);\n\t\tccdc->update &= ~OMAP3ISP_CCDC_ALAW;\n\t}\n\n\tif (ccdc->update & OMAP3ISP_CCDC_LPF) {\n\t\tccdc_configure_lpf(ccdc);\n\t\tccdc->update &= ~OMAP3ISP_CCDC_LPF;\n\t}\n\n\tif (ccdc->update & OMAP3ISP_CCDC_BLCLAMP) {\n\t\tccdc_configure_clamp(ccdc);\n\t\tccdc->update &= ~OMAP3ISP_CCDC_BLCLAMP;\n\t}\n\n\tif (ccdc->update & OMAP3ISP_CCDC_BCOMP) {\n\t\tccdc_configure_black_comp(ccdc);\n\t\tccdc->update &= ~OMAP3ISP_CCDC_BCOMP;\n\t}\n}\n\n \nvoid omap3isp_ccdc_restore_context(struct isp_device *isp)\n{\n\tstruct isp_ccdc_device *ccdc = &isp->isp_ccdc;\n\n\tisp_reg_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG, ISPCCDC_CFG_VDLC);\n\n\tccdc->update = OMAP3ISP_CCDC_ALAW | OMAP3ISP_CCDC_LPF\n\t\t     | OMAP3ISP_CCDC_BLCLAMP | OMAP3ISP_CCDC_BCOMP;\n\tccdc_apply_controls(ccdc);\n\tccdc_configure_fpc(ccdc);\n}\n\n \n\n \nstatic void ccdc_config_vp(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&ccdc->subdev.entity);\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tconst struct isp_format_info *info;\n\tstruct v4l2_mbus_framefmt *format;\n\tunsigned long l3_ick = pipe->l3_ick;\n\tunsigned int max_div = isp->revision == ISP_REVISION_15_0 ? 64 : 8;\n\tunsigned int div = 0;\n\tu32 fmtcfg = ISPCCDC_FMTCFG_VPEN;\n\n\tformat = &ccdc->formats[CCDC_PAD_SOURCE_VP];\n\n\tif (!format->code) {\n\t\t \n\t\tisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);\n\t\treturn;\n\t}\n\n\tisp_reg_writel(isp, (0 << ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |\n\t\t       (format->width << ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),\n\t\t       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_HORZ);\n\tisp_reg_writel(isp, (0 << ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |\n\t\t       ((format->height + 1) << ISPCCDC_FMT_VERT_FMTLNV_SHIFT),\n\t\t       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_VERT);\n\n\tisp_reg_writel(isp, (format->width << ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |\n\t\t       (format->height << ISPCCDC_VP_OUT_VERT_NUM_SHIFT),\n\t\t       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_VP_OUT);\n\n\tinfo = omap3isp_video_format_info(ccdc->formats[CCDC_PAD_SINK].code);\n\n\tswitch (info->width) {\n\tcase 8:\n\tcase 10:\n\t\tfmtcfg |= ISPCCDC_FMTCFG_VPIN_9_0;\n\t\tbreak;\n\tcase 11:\n\t\tfmtcfg |= ISPCCDC_FMTCFG_VPIN_10_1;\n\t\tbreak;\n\tcase 12:\n\t\tfmtcfg |= ISPCCDC_FMTCFG_VPIN_11_2;\n\t\tbreak;\n\tcase 13:\n\t\tfmtcfg |= ISPCCDC_FMTCFG_VPIN_12_3;\n\t\tbreak;\n\t}\n\n\tif (pipe->input)\n\t\tdiv = DIV_ROUND_UP(l3_ick, pipe->max_rate);\n\telse if (pipe->external_rate)\n\t\tdiv = l3_ick / pipe->external_rate;\n\n\tdiv = clamp(div, 2U, max_div);\n\tfmtcfg |= (div - 2) << ISPCCDC_FMTCFG_VPIF_FRQ_SHIFT;\n\n\tisp_reg_writel(isp, fmtcfg, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);\n}\n\n \nstatic void ccdc_config_outlineoffset(struct isp_ccdc_device *ccdc,\n\t\t\t\t      unsigned int bpl,\n\t\t\t\t      enum v4l2_field field)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tu32 sdofst = 0;\n\n\tisp_reg_writel(isp, bpl & 0xffff, OMAP3_ISP_IOMEM_CCDC,\n\t\t       ISPCCDC_HSIZE_OFF);\n\n\tswitch (field) {\n\tcase V4L2_FIELD_INTERLACED_TB:\n\tcase V4L2_FIELD_INTERLACED_BT:\n\t\t \n\t\tsdofst |= (1 << ISPCCDC_SDOFST_LOFST0_SHIFT)\n\t\t       |  (1 << ISPCCDC_SDOFST_LOFST1_SHIFT)\n\t\t       |  (1 << ISPCCDC_SDOFST_LOFST2_SHIFT)\n\t\t       |  (1 << ISPCCDC_SDOFST_LOFST3_SHIFT);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tisp_reg_writel(isp, sdofst, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST);\n}\n\n \nstatic void ccdc_set_outaddr(struct isp_ccdc_device *ccdc, u32 addr)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\n\tisp_reg_writel(isp, addr, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDR_ADDR);\n}\n\n \nvoid omap3isp_ccdc_max_rate(struct isp_ccdc_device *ccdc,\n\t\t\t    unsigned int *max_rate)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&ccdc->subdev.entity);\n\tunsigned int rate;\n\n\tif (pipe == NULL)\n\t\treturn;\n\n\t \n\tif (ccdc->input == CCDC_INPUT_PARALLEL)\n\t\trate = pipe->l3_ick / 2 * 9 / 10;\n\telse\n\t\trate = pipe->l3_ick / 2;\n\n\t*max_rate = min(*max_rate, rate);\n}\n\n \nstatic void ccdc_config_sync_if(struct isp_ccdc_device *ccdc,\n\t\t\t\tstruct isp_parallel_cfg *parcfg,\n\t\t\t\tunsigned int data_size)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tconst struct v4l2_mbus_framefmt *format;\n\tu32 syn_mode = ISPCCDC_SYN_MODE_VDHDEN;\n\n\tformat = &ccdc->formats[CCDC_PAD_SINK];\n\n\tif (format->code == MEDIA_BUS_FMT_YUYV8_2X8 ||\n\t    format->code == MEDIA_BUS_FMT_UYVY8_2X8) {\n\t\t \n\t\tif (ccdc->bt656)\n\t\t\tsyn_mode |= ISPCCDC_SYN_MODE_INPMOD_YCBCR8;\n\t\telse\n\t\t\tsyn_mode |= ISPCCDC_SYN_MODE_INPMOD_YCBCR16;\n\t}\n\n\tswitch (data_size) {\n\tcase 8:\n\t\tsyn_mode |= ISPCCDC_SYN_MODE_DATSIZ_8;\n\t\tbreak;\n\tcase 10:\n\t\tsyn_mode |= ISPCCDC_SYN_MODE_DATSIZ_10;\n\t\tbreak;\n\tcase 11:\n\t\tsyn_mode |= ISPCCDC_SYN_MODE_DATSIZ_11;\n\t\tbreak;\n\tcase 12:\n\t\tsyn_mode |= ISPCCDC_SYN_MODE_DATSIZ_12;\n\t\tbreak;\n\t}\n\n\tif (parcfg && parcfg->data_pol)\n\t\tsyn_mode |= ISPCCDC_SYN_MODE_DATAPOL;\n\n\tif (parcfg && parcfg->hs_pol)\n\t\tsyn_mode |= ISPCCDC_SYN_MODE_HDPOL;\n\n\t \n\tif ((parcfg && parcfg->vs_pol) || ccdc->bt656)\n\t\tsyn_mode |= ISPCCDC_SYN_MODE_VDPOL;\n\n\tif (parcfg && parcfg->fld_pol)\n\t\tsyn_mode |= ISPCCDC_SYN_MODE_FLDPOL;\n\n\tisp_reg_writel(isp, syn_mode, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);\n\n\t \n\tif (format->code == MEDIA_BUS_FMT_UYVY8_2X8)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,\n\t\t\t    ISPCCDC_CFG_Y8POS);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,\n\t\t\t    ISPCCDC_CFG_Y8POS);\n\n\t \n\tif (ccdc->bt656)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_REC656IF,\n\t\t\t    ISPCCDC_REC656IF_R656ON | ISPCCDC_REC656IF_ECCFVH);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_REC656IF,\n\t\t\t    ISPCCDC_REC656IF_R656ON | ISPCCDC_REC656IF_ECCFVH);\n\n}\n\n \nstatic const u32 ccdc_sgrbg_pattern =\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC0_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP0PLC1_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC2_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP0PLC3_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP1PLC0_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP1PLC1_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP1PLC2_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP1PLC3_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP2PLC0_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP2PLC1_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP2PLC2_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP2PLC3_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP3PLC0_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP3PLC1_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP3PLC2_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP3PLC3_SHIFT;\n\nstatic const u32 ccdc_srggb_pattern =\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP0PLC0_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC1_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP0PLC2_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC3_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP1PLC0_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP1PLC1_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP1PLC2_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP1PLC3_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP2PLC0_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP2PLC1_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP2PLC2_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP2PLC3_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP3PLC0_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP3PLC1_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP3PLC2_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP3PLC3_SHIFT;\n\nstatic const u32 ccdc_sbggr_pattern =\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP0PLC0_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP0PLC1_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP0PLC2_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP0PLC3_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP1PLC0_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP1PLC1_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP1PLC2_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP1PLC3_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP2PLC0_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP2PLC1_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP2PLC2_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP2PLC3_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP3PLC0_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP3PLC1_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP3PLC2_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP3PLC3_SHIFT;\n\nstatic const u32 ccdc_sgbrg_pattern =\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP0PLC0_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP0PLC1_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP0PLC2_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP0PLC3_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP1PLC0_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP1PLC1_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP1PLC2_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP1PLC3_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP2PLC0_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP2PLC1_SHIFT |\n\tISPCCDC_COLPTN_Gb_G  << ISPCCDC_COLPTN_CP2PLC2_SHIFT |\n\tISPCCDC_COLPTN_B_Mg  << ISPCCDC_COLPTN_CP2PLC3_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP3PLC0_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP3PLC1_SHIFT |\n\tISPCCDC_COLPTN_R_Ye  << ISPCCDC_COLPTN_CP3PLC2_SHIFT |\n\tISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP3PLC3_SHIFT;\n\nstatic void ccdc_configure(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tstruct isp_parallel_cfg *parcfg = NULL;\n\tstruct v4l2_subdev *sensor;\n\tstruct v4l2_mbus_framefmt *format;\n\tconst struct v4l2_rect *crop;\n\tconst struct isp_format_info *fmt_info;\n\tstruct v4l2_subdev_format fmt_src = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tunsigned int depth_out;\n\tunsigned int depth_in = 0;\n\tstruct media_pad *pad;\n\tunsigned long flags;\n\tunsigned int bridge;\n\tunsigned int shift;\n\tunsigned int nph;\n\tunsigned int sph;\n\tu32 syn_mode;\n\tu32 ccdc_pattern;\n\n\tccdc->bt656 = false;\n\tccdc->fields = 0;\n\n\tpad = media_pad_remote_pad_first(&ccdc->pads[CCDC_PAD_SINK]);\n\tsensor = media_entity_to_v4l2_subdev(pad->entity);\n\tif (ccdc->input == CCDC_INPUT_PARALLEL) {\n\t\tstruct v4l2_subdev *sd =\n\t\t\tto_isp_pipeline(&ccdc->subdev.entity)->external;\n\t\tstruct isp_bus_cfg *bus_cfg;\n\n\t\tbus_cfg = v4l2_subdev_to_bus_cfg(sd);\n\t\tif (WARN_ON(!bus_cfg))\n\t\t\treturn;\n\n\t\tparcfg = &bus_cfg->bus.parallel;\n\t\tccdc->bt656 = parcfg->bt656;\n\t}\n\n\t \n\tformat = &ccdc->formats[CCDC_PAD_SINK];\n\n\t \n\tfmt_src.pad = pad->index;\n\tif (!v4l2_subdev_call(sensor, pad, get_fmt, NULL, &fmt_src)) {\n\t\tfmt_info = omap3isp_video_format_info(fmt_src.format.code);\n\t\tdepth_in = fmt_info->width;\n\t}\n\n\tfmt_info = omap3isp_video_format_info(format->code);\n\tdepth_out = fmt_info->width;\n\tshift = depth_in - depth_out;\n\n\tif (ccdc->bt656)\n\t\tbridge = ISPCTRL_PAR_BRIDGE_DISABLE;\n\telse if (fmt_info->code == MEDIA_BUS_FMT_YUYV8_2X8)\n\t\tbridge = ISPCTRL_PAR_BRIDGE_LENDIAN;\n\telse if (fmt_info->code == MEDIA_BUS_FMT_UYVY8_2X8)\n\t\tbridge = ISPCTRL_PAR_BRIDGE_BENDIAN;\n\telse\n\t\tbridge = ISPCTRL_PAR_BRIDGE_DISABLE;\n\n\tomap3isp_configure_bridge(isp, ccdc->input, parcfg, shift, bridge);\n\n\t \n\tccdc_config_sync_if(ccdc, parcfg, depth_out);\n\n\tsyn_mode = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);\n\n\t \n\tsyn_mode &= ~ISPCCDC_SYN_MODE_VP2SDR;\n\n\tif (ccdc->output & CCDC_OUTPUT_MEMORY)\n\t\tsyn_mode |= ISPCCDC_SYN_MODE_WEN;\n\telse\n\t\tsyn_mode &= ~ISPCCDC_SYN_MODE_WEN;\n\n\tif (ccdc->output & CCDC_OUTPUT_RESIZER)\n\t\tsyn_mode |= ISPCCDC_SYN_MODE_SDR2RSZ;\n\telse\n\t\tsyn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;\n\n\t \n\tswitch (format->code) {\n\tcase MEDIA_BUS_FMT_SRGGB10_1X10:\n\tcase MEDIA_BUS_FMT_SRGGB12_1X12:\n\t\tccdc_pattern = ccdc_srggb_pattern;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\tcase MEDIA_BUS_FMT_SBGGR12_1X12:\n\t\tccdc_pattern = ccdc_sbggr_pattern;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SGBRG10_1X10:\n\tcase MEDIA_BUS_FMT_SGBRG12_1X12:\n\t\tccdc_pattern = ccdc_sgbrg_pattern;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tccdc_pattern = ccdc_sgrbg_pattern;\n\t\tbreak;\n\t}\n\tccdc_config_imgattr(ccdc, ccdc_pattern);\n\n\t \n\tisp_reg_writel(isp, ((format->height - 2) << ISPCCDC_VDINT_0_SHIFT) |\n\t\t       ((format->height * 2 / 3) << ISPCCDC_VDINT_1_SHIFT),\n\t\t       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_VDINT);\n\n\t \n\tformat = &ccdc->formats[CCDC_PAD_SOURCE_OF];\n\tcrop = &ccdc->crop;\n\n\t \n\tif (ccdc->bt656) {\n\t\tsph = crop->left * 2;\n\t\tnph = crop->width * 2 - 1;\n\t} else {\n\t\tsph = crop->left;\n\t\tnph = crop->width - 1;\n\t}\n\n\tisp_reg_writel(isp, (sph << ISPCCDC_HORZ_INFO_SPH_SHIFT) |\n\t\t       (nph << ISPCCDC_HORZ_INFO_NPH_SHIFT),\n\t\t       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_HORZ_INFO);\n\tisp_reg_writel(isp, (crop->top << ISPCCDC_VERT_START_SLV0_SHIFT) |\n\t\t       (crop->top << ISPCCDC_VERT_START_SLV1_SHIFT),\n\t\t       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_VERT_START);\n\tisp_reg_writel(isp, (crop->height - 1)\n\t\t\t<< ISPCCDC_VERT_LINES_NLV_SHIFT,\n\t\t       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_VERT_LINES);\n\n\tccdc_config_outlineoffset(ccdc, ccdc->video_out.bpl_value,\n\t\t\t\t  format->field);\n\n\t \n\tif (ccdc->formats[CCDC_PAD_SINK].field == V4L2_FIELD_ALTERNATE &&\n\t    (format->field == V4L2_FIELD_INTERLACED_TB ||\n\t     format->field == V4L2_FIELD_INTERLACED_BT))\n\t\tsyn_mode |= ISPCCDC_SYN_MODE_FLDMODE;\n\n\t \n\tif (format->code == MEDIA_BUS_FMT_YUYV8_1X16)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,\n\t\t\t    ISPCCDC_CFG_BSWD);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,\n\t\t\t    ISPCCDC_CFG_BSWD);\n\n\t \n\tif (omap3isp_video_format_info(format->code)->width <= 8 || ccdc->bt656)\n\t\tsyn_mode |= ISPCCDC_SYN_MODE_PACK8;\n\telse\n\t\tsyn_mode &= ~ISPCCDC_SYN_MODE_PACK8;\n\n\tisp_reg_writel(isp, syn_mode, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);\n\n\t \n\tccdc_config_vp(ccdc);\n\n\t \n\tspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\n\tif (ccdc->lsc.request == NULL)\n\t\tgoto unlock;\n\n\tWARN_ON(ccdc->lsc.active);\n\n\t \n\tif (ccdc->lsc.active == NULL &&\n\t    __ccdc_lsc_configure(ccdc, ccdc->lsc.request) == 0) {\n\t\tccdc->lsc.active = ccdc->lsc.request;\n\t} else {\n\t\tlist_add_tail(&ccdc->lsc.request->list, &ccdc->lsc.free_queue);\n\t\tschedule_work(&ccdc->lsc.table_work);\n\t}\n\n\tccdc->lsc.request = NULL;\n\nunlock:\n\tspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\n\n\tccdc_apply_controls(ccdc);\n}\n\nstatic void __ccdc_enable(struct isp_ccdc_device *ccdc, int enable)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\n\t \n\tif (enable && ccdc->stopping & CCDC_STOP_REQUEST)\n\t\treturn;\n\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PCR,\n\t\t\tISPCCDC_PCR_EN, enable ? ISPCCDC_PCR_EN : 0);\n\n\tccdc->running = enable;\n}\n\nstatic int ccdc_disable(struct isp_ccdc_device *ccdc)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&ccdc->lock, flags);\n\tif (ccdc->state == ISP_PIPELINE_STREAM_CONTINUOUS)\n\t\tccdc->stopping = CCDC_STOP_REQUEST;\n\tif (!ccdc->running)\n\t\tccdc->stopping = CCDC_STOP_FINISHED;\n\tspin_unlock_irqrestore(&ccdc->lock, flags);\n\n\tret = wait_event_timeout(ccdc->wait,\n\t\t\t\t ccdc->stopping == CCDC_STOP_FINISHED,\n\t\t\t\t msecs_to_jiffies(2000));\n\tif (ret == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tdev_warn(to_device(ccdc), \"CCDC stop timeout!\\n\");\n\t}\n\n\tomap3isp_sbl_disable(to_isp_device(ccdc), OMAP3_ISP_SBL_CCDC_LSC_READ);\n\n\tmutex_lock(&ccdc->ioctl_lock);\n\tccdc_lsc_free_request(ccdc, ccdc->lsc.request);\n\tccdc->lsc.request = ccdc->lsc.active;\n\tccdc->lsc.active = NULL;\n\tcancel_work_sync(&ccdc->lsc.table_work);\n\tccdc_lsc_free_queue(ccdc, &ccdc->lsc.free_queue);\n\tmutex_unlock(&ccdc->ioctl_lock);\n\n\tccdc->stopping = CCDC_STOP_NOT_REQUESTED;\n\n\treturn ret > 0 ? 0 : ret;\n}\n\nstatic void ccdc_enable(struct isp_ccdc_device *ccdc)\n{\n\tif (ccdc_lsc_is_configured(ccdc))\n\t\t__ccdc_lsc_enable(ccdc, 1);\n\t__ccdc_enable(ccdc, 1);\n}\n\n \n\n \nstatic int ccdc_sbl_busy(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\n\treturn omap3isp_ccdc_busy(ccdc)\n\t\t| (isp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_0) &\n\t\t   ISPSBL_CCDC_WR_0_DATA_READY)\n\t\t| (isp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_1) &\n\t\t   ISPSBL_CCDC_WR_0_DATA_READY)\n\t\t| (isp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_2) &\n\t\t   ISPSBL_CCDC_WR_0_DATA_READY)\n\t\t| (isp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_3) &\n\t\t   ISPSBL_CCDC_WR_0_DATA_READY);\n}\n\n \nstatic int ccdc_sbl_wait_idle(struct isp_ccdc_device *ccdc,\n\t\t\t      unsigned int max_wait)\n{\n\tunsigned int wait = 0;\n\n\tif (max_wait == 0)\n\t\tmax_wait = 10000;  \n\n\tfor (wait = 0; wait <= max_wait; wait++) {\n\t\tif (!ccdc_sbl_busy(ccdc))\n\t\t\treturn 0;\n\n\t\trmb();\n\t\tudelay(1);\n\t}\n\n\treturn -EBUSY;\n}\n\n \nstatic int ccdc_handle_stopping(struct isp_ccdc_device *ccdc, u32 event)\n{\n\tint rval = 0;\n\n\tswitch ((ccdc->stopping & 3) | event) {\n\tcase CCDC_STOP_REQUEST | CCDC_EVENT_VD1:\n\t\tif (ccdc->lsc.state != LSC_STATE_STOPPED)\n\t\t\t__ccdc_lsc_enable(ccdc, 0);\n\t\t__ccdc_enable(ccdc, 0);\n\t\tccdc->stopping = CCDC_STOP_EXECUTED;\n\t\treturn 1;\n\n\tcase CCDC_STOP_EXECUTED | CCDC_EVENT_VD0:\n\t\tccdc->stopping |= CCDC_STOP_CCDC_FINISHED;\n\t\tif (ccdc->lsc.state == LSC_STATE_STOPPED)\n\t\t\tccdc->stopping |= CCDC_STOP_LSC_FINISHED;\n\t\trval = 1;\n\t\tbreak;\n\n\tcase CCDC_STOP_EXECUTED | CCDC_EVENT_LSC_DONE:\n\t\tccdc->stopping |= CCDC_STOP_LSC_FINISHED;\n\t\trval = 1;\n\t\tbreak;\n\n\tcase CCDC_STOP_EXECUTED | CCDC_EVENT_VD1:\n\t\treturn 1;\n\t}\n\n\tif (ccdc->stopping == CCDC_STOP_FINISHED) {\n\t\twake_up(&ccdc->wait);\n\t\trval = 1;\n\t}\n\n\treturn rval;\n}\n\nstatic void ccdc_hs_vs_isr(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&ccdc->subdev.entity);\n\tstruct video_device *vdev = ccdc->subdev.devnode;\n\tstruct v4l2_event event;\n\n\t \n\tatomic_inc(&pipe->frame_number);\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.type = V4L2_EVENT_FRAME_SYNC;\n\tevent.u.frame_sync.frame_sequence = atomic_read(&pipe->frame_number);\n\n\tv4l2_event_queue(vdev, &event);\n}\n\n \nstatic void ccdc_lsc_isr(struct isp_ccdc_device *ccdc, u32 events)\n{\n\tunsigned long flags;\n\n\tif (events & IRQ0STATUS_CCDC_LSC_PREF_ERR_IRQ) {\n\t\tstruct isp_pipeline *pipe =\n\t\t\tto_isp_pipeline(&ccdc->subdev.entity);\n\n\t\tccdc_lsc_error_handler(ccdc);\n\t\tpipe->error = true;\n\t\tdev_dbg(to_device(ccdc), \"lsc prefetch error\\n\");\n\t}\n\n\tif (!(events & IRQ0STATUS_CCDC_LSC_DONE_IRQ))\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\n\n\tif (ccdc->lsc.state == LSC_STATE_STOPPING)\n\t\tccdc->lsc.state = LSC_STATE_STOPPED;\n\n\tif (ccdc_handle_stopping(ccdc, CCDC_EVENT_LSC_DONE))\n\t\tgoto done;\n\n\tif (ccdc->lsc.state != LSC_STATE_RECONFIG)\n\t\tgoto done;\n\n\t \n\tccdc->lsc.state = LSC_STATE_STOPPED;\n\n\t \n\tif (events & IRQ0STATUS_HS_VS_IRQ)\n\t\tgoto done;\n\n\t \n\tif (ccdc->lsc.request == NULL)\n\t\tgoto done;\n\n\tccdc_lsc_enable(ccdc);\n\ndone:\n\tspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\n}\n\n \nstatic bool ccdc_has_all_fields(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&ccdc->subdev.entity);\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tenum v4l2_field of_field = ccdc->formats[CCDC_PAD_SOURCE_OF].field;\n\tenum v4l2_field field;\n\n\t \n\tif (of_field == V4L2_FIELD_NONE)\n\t\treturn true;\n\n\t \n\tfield = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE)\n\t      & ISPCCDC_SYN_MODE_FLDSTAT\n\t      ? V4L2_FIELD_BOTTOM : V4L2_FIELD_TOP;\n\n\t \n\tif (of_field == V4L2_FIELD_ALTERNATE) {\n\t\tpipe->field = field;\n\t\treturn true;\n\t}\n\n\t \n\tccdc->fields |= field == V4L2_FIELD_BOTTOM\n\t\t      ? CCDC_FIELD_BOTTOM : CCDC_FIELD_TOP;\n\n\tif (ccdc->fields != CCDC_FIELD_BOTH)\n\t\treturn false;\n\n\t \n\tif ((of_field == V4L2_FIELD_INTERLACED_TB && field == V4L2_FIELD_TOP) ||\n\t    (of_field == V4L2_FIELD_INTERLACED_BT && field == V4L2_FIELD_BOTTOM))\n\t\treturn false;\n\n\t \n\tccdc->fields = 0;\n\n\treturn true;\n}\n\nstatic int ccdc_isr_buffer(struct isp_ccdc_device *ccdc)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&ccdc->subdev.entity);\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tstruct isp_buffer *buffer;\n\n\t \n\tif (list_empty(&ccdc->video_out.dmaqueue))\n\t\treturn 0;\n\n\t \n\tif (ccdc->state == ISP_PIPELINE_STREAM_CONTINUOUS && ccdc->underrun) {\n\t\tccdc->underrun = 0;\n\t\treturn 1;\n\t}\n\n\t \n\tif (ccdc_sbl_wait_idle(ccdc, 1000)) {\n\t\tdev_info(isp->dev, \"CCDC won't become idle!\\n\");\n\t\tmedia_entity_enum_set(&isp->crashed, &ccdc->subdev.entity);\n\t\tomap3isp_pipeline_cancel_stream(pipe);\n\t\treturn 0;\n\t}\n\n\t \n\tif (ccdc->state == ISP_PIPELINE_STREAM_CONTINUOUS &&\n\t    ccdc->stopping & CCDC_STOP_REQUEST)\n\t\treturn 0;\n\n\tif (!ccdc_has_all_fields(ccdc))\n\t\treturn 1;\n\n\tbuffer = omap3isp_video_buffer_next(&ccdc->video_out);\n\tif (buffer != NULL)\n\t\tccdc_set_outaddr(ccdc, buffer->dma);\n\n\tpipe->state |= ISP_PIPELINE_IDLE_OUTPUT;\n\n\tif (ccdc->state == ISP_PIPELINE_STREAM_SINGLESHOT &&\n\t    isp_pipeline_ready(pipe))\n\t\tomap3isp_pipeline_set_stream(pipe,\n\t\t\t\t\tISP_PIPELINE_STREAM_SINGLESHOT);\n\n\treturn buffer != NULL;\n}\n\n \nstatic void ccdc_vd0_isr(struct isp_ccdc_device *ccdc)\n{\n\tunsigned long flags;\n\tint restart = 0;\n\n\t \n\tif (ccdc->bt656) {\n\t\tstruct isp_pipeline *pipe =\n\t\t\tto_isp_pipeline(&ccdc->subdev.entity);\n\n\t\tatomic_inc(&pipe->frame_number);\n\t}\n\n\t \n\tif (ccdc->bt656) {\n\t\tspin_lock_irqsave(&ccdc->lock, flags);\n\t\tif (ccdc->state == ISP_PIPELINE_STREAM_CONTINUOUS &&\n\t\t    ccdc->output & CCDC_OUTPUT_MEMORY) {\n\t\t\tif (ccdc->lsc.state != LSC_STATE_STOPPED)\n\t\t\t\t__ccdc_lsc_enable(ccdc, 0);\n\t\t\t__ccdc_enable(ccdc, 0);\n\t\t}\n\t\tccdc_handle_stopping(ccdc, CCDC_EVENT_VD1);\n\t\tspin_unlock_irqrestore(&ccdc->lock, flags);\n\t}\n\n\tspin_lock_irqsave(&ccdc->lock, flags);\n\tif (ccdc_handle_stopping(ccdc, CCDC_EVENT_VD0)) {\n\t\tspin_unlock_irqrestore(&ccdc->lock, flags);\n\t\treturn;\n\t}\n\n\tif (ccdc->output & CCDC_OUTPUT_MEMORY)\n\t\trestart = ccdc_isr_buffer(ccdc);\n\n\tif (!ccdc->shadow_update)\n\t\tccdc_apply_controls(ccdc);\n\tspin_unlock_irqrestore(&ccdc->lock, flags);\n\n\tif (restart)\n\t\tccdc_enable(ccdc);\n}\n\n \nstatic void ccdc_vd1_isr(struct isp_ccdc_device *ccdc)\n{\n\tunsigned long flags;\n\n\t \n\tif (ccdc->bt656)\n\t\treturn;\n\n\tspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\n\n\t \n\tswitch (ccdc->state) {\n\tcase ISP_PIPELINE_STREAM_SINGLESHOT:\n\t\tccdc->stopping = CCDC_STOP_REQUEST;\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_CONTINUOUS:\n\t\tif (ccdc->output & CCDC_OUTPUT_MEMORY) {\n\t\t\tif (ccdc->lsc.state != LSC_STATE_STOPPED)\n\t\t\t\t__ccdc_lsc_enable(ccdc, 0);\n\t\t\t__ccdc_enable(ccdc, 0);\n\t\t}\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_STOPPED:\n\t\tbreak;\n\t}\n\n\tif (ccdc_handle_stopping(ccdc, CCDC_EVENT_VD1))\n\t\tgoto done;\n\n\tif (ccdc->lsc.request == NULL)\n\t\tgoto done;\n\n\t \n\tif (ccdc->lsc.state == LSC_STATE_RUNNING) {\n\t\t__ccdc_lsc_enable(ccdc, 0);\n\t\tccdc->lsc.state = LSC_STATE_RECONFIG;\n\t\tgoto done;\n\t}\n\n\t \n\tif (ccdc->lsc.state == LSC_STATE_STOPPED)\n\t\tccdc_lsc_enable(ccdc);\n\ndone:\n\tspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\n}\n\n \nint omap3isp_ccdc_isr(struct isp_ccdc_device *ccdc, u32 events)\n{\n\tif (ccdc->state == ISP_PIPELINE_STREAM_STOPPED)\n\t\treturn 0;\n\n\tif (events & IRQ0STATUS_CCDC_VD1_IRQ)\n\t\tccdc_vd1_isr(ccdc);\n\n\tccdc_lsc_isr(ccdc, events);\n\n\tif (events & IRQ0STATUS_CCDC_VD0_IRQ)\n\t\tccdc_vd0_isr(ccdc);\n\n\tif (events & IRQ0STATUS_HS_VS_IRQ)\n\t\tccdc_hs_vs_isr(ccdc);\n\n\treturn 0;\n}\n\n \n\nstatic int ccdc_video_queue(struct isp_video *video, struct isp_buffer *buffer)\n{\n\tstruct isp_ccdc_device *ccdc = &video->isp->isp_ccdc;\n\tunsigned long flags;\n\tbool restart = false;\n\n\tif (!(ccdc->output & CCDC_OUTPUT_MEMORY))\n\t\treturn -ENODEV;\n\n\tccdc_set_outaddr(ccdc, buffer->dma);\n\n\t \n\tspin_lock_irqsave(&ccdc->lock, flags);\n\tif (ccdc->state == ISP_PIPELINE_STREAM_CONTINUOUS && !ccdc->running &&\n\t    ccdc->bt656)\n\t\trestart = true;\n\telse\n\t\tccdc->underrun = 1;\n\tspin_unlock_irqrestore(&ccdc->lock, flags);\n\n\tif (restart)\n\t\tccdc_enable(ccdc);\n\n\treturn 0;\n}\n\nstatic const struct isp_video_operations ccdc_video_ops = {\n\t.queue = ccdc_video_queue,\n};\n\n \n\n \nstatic long ccdc_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tswitch (cmd) {\n\tcase VIDIOC_OMAP3ISP_CCDC_CFG:\n\t\tmutex_lock(&ccdc->ioctl_lock);\n\t\tret = ccdc_config(ccdc, arg);\n\t\tmutex_unlock(&ccdc->ioctl_lock);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn ret;\n}\n\nstatic int ccdc_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,\n\t\t\t\tstruct v4l2_event_subscription *sub)\n{\n\tif (sub->type != V4L2_EVENT_FRAME_SYNC)\n\t\treturn -EINVAL;\n\n\t \n\tif (sub->id != 0)\n\t\treturn -EINVAL;\n\n\treturn v4l2_event_subscribe(fh, sub, OMAP3ISP_CCDC_NEVENTS, NULL);\n}\n\nstatic int ccdc_unsubscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,\n\t\t\t\t  struct v4l2_event_subscription *sub)\n{\n\treturn v4l2_event_unsubscribe(fh, sub);\n}\n\n \nstatic int ccdc_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tint ret = 0;\n\n\tif (ccdc->state == ISP_PIPELINE_STREAM_STOPPED) {\n\t\tif (enable == ISP_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\n\t\tomap3isp_subclk_enable(isp, OMAP3_ISP_SUBCLK_CCDC);\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,\n\t\t\t    ISPCCDC_CFG_VDLC);\n\n\t\tccdc_configure(ccdc);\n\n\t\tccdc_print_status(ccdc);\n\t}\n\n\tswitch (enable) {\n\tcase ISP_PIPELINE_STREAM_CONTINUOUS:\n\t\tif (ccdc->output & CCDC_OUTPUT_MEMORY)\n\t\t\tomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_CCDC_WRITE);\n\n\t\tif (ccdc->underrun || !(ccdc->output & CCDC_OUTPUT_MEMORY))\n\t\t\tccdc_enable(ccdc);\n\n\t\tccdc->underrun = 0;\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_SINGLESHOT:\n\t\tif (ccdc->output & CCDC_OUTPUT_MEMORY &&\n\t\t    ccdc->state != ISP_PIPELINE_STREAM_SINGLESHOT)\n\t\t\tomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_CCDC_WRITE);\n\n\t\tccdc_enable(ccdc);\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_STOPPED:\n\t\tret = ccdc_disable(ccdc);\n\t\tif (ccdc->output & CCDC_OUTPUT_MEMORY)\n\t\t\tomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_CCDC_WRITE);\n\t\tomap3isp_subclk_disable(isp, OMAP3_ISP_SUBCLK_CCDC);\n\t\tccdc->underrun = 0;\n\t\tbreak;\n\t}\n\n\tccdc->state = enable;\n\treturn ret;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__ccdc_get_format(struct isp_ccdc_device *ccdc,\n\t\t  struct v4l2_subdev_state *sd_state,\n\t\t  unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&ccdc->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\telse\n\t\treturn &ccdc->formats[pad];\n}\n\nstatic struct v4l2_rect *\n__ccdc_get_crop(struct isp_ccdc_device *ccdc,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tenum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_crop(&ccdc->subdev, sd_state,\n\t\t\t\t\t\tCCDC_PAD_SOURCE_OF);\n\telse\n\t\treturn &ccdc->crop;\n}\n\n \nstatic void\nccdc_try_format(struct isp_ccdc_device *ccdc,\n\t\tstruct v4l2_subdev_state *sd_state,\n\t\tunsigned int pad, struct v4l2_mbus_framefmt *fmt,\n\t\tenum v4l2_subdev_format_whence which)\n{\n\tconst struct isp_format_info *info;\n\tu32 pixelcode;\n\tunsigned int width = fmt->width;\n\tunsigned int height = fmt->height;\n\tstruct v4l2_rect *crop;\n\tenum v4l2_field field;\n\tunsigned int i;\n\n\tswitch (pad) {\n\tcase CCDC_PAD_SINK:\n\t\tfor (i = 0; i < ARRAY_SIZE(ccdc_fmts); i++) {\n\t\t\tif (fmt->code == ccdc_fmts[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i >= ARRAY_SIZE(ccdc_fmts))\n\t\t\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\n\t\t \n\t\tfmt->width = clamp_t(u32, width, 32, 4096);\n\t\tfmt->height = clamp_t(u32, height, 32, 4096);\n\n\t\t \n\t\tif (fmt->field == V4L2_FIELD_ANY)\n\t\t\tfmt->field = V4L2_FIELD_NONE;\n\n\t\tbreak;\n\n\tcase CCDC_PAD_SOURCE_OF:\n\t\tpixelcode = fmt->code;\n\t\tfield = fmt->field;\n\t\t*fmt = *__ccdc_get_format(ccdc, sd_state, CCDC_PAD_SINK,\n\t\t\t\t\t  which);\n\n\t\t \n\t\tif (fmt->code == MEDIA_BUS_FMT_YUYV8_2X8 ||\n\t\t    fmt->code == MEDIA_BUS_FMT_UYVY8_2X8) {\n\t\t\t \n\t\t\tif (pixelcode == MEDIA_BUS_FMT_YUYV8_2X8 ||\n\t\t\t    pixelcode == MEDIA_BUS_FMT_UYVY8_2X8 ||\n\t\t\t    pixelcode == MEDIA_BUS_FMT_YUYV8_1X16 ||\n\t\t\t    pixelcode == MEDIA_BUS_FMT_UYVY8_1X16)\n\t\t\t\tfmt->code = pixelcode;\n\n\t\t\tif (fmt->code == MEDIA_BUS_FMT_YUYV8_2X8)\n\t\t\t\tfmt->code = MEDIA_BUS_FMT_YUYV8_1X16;\n\t\t\telse if (fmt->code == MEDIA_BUS_FMT_UYVY8_2X8)\n\t\t\t\tfmt->code = MEDIA_BUS_FMT_UYVY8_1X16;\n\t\t}\n\n\t\t \n\t\tcrop = __ccdc_get_crop(ccdc, sd_state, which);\n\t\tfmt->width = crop->width;\n\t\tfmt->height = crop->height;\n\n\t\t \n\t\tif (fmt->field == V4L2_FIELD_ALTERNATE &&\n\t\t    (field == V4L2_FIELD_INTERLACED_TB ||\n\t\t     field == V4L2_FIELD_INTERLACED_BT)) {\n\t\t\tfmt->field = field;\n\t\t\tfmt->height *= 2;\n\t\t}\n\n\t\tbreak;\n\n\tcase CCDC_PAD_SOURCE_VP:\n\t\t*fmt = *__ccdc_get_format(ccdc, sd_state, CCDC_PAD_SINK,\n\t\t\t\t\t  which);\n\n\t\t \n\t\tinfo = omap3isp_video_format_info(fmt->code);\n\t\tfmt->code = info->truncated;\n\n\t\t \n\t\tif (fmt->code == MEDIA_BUS_FMT_YUYV8_2X8 ||\n\t\t    fmt->code == MEDIA_BUS_FMT_UYVY8_2X8)\n\t\t\tfmt->code = 0;\n\n\t\t \n\t\tfmt->width = clamp_t(u32, width, 32, fmt->width);\n\t\tfmt->height = clamp_t(u32, height, 32, fmt->height - 1);\n\t\tbreak;\n\t}\n\n\t \n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n}\n\n \nstatic void ccdc_try_crop(struct isp_ccdc_device *ccdc,\n\t\t\t  const struct v4l2_mbus_framefmt *sink,\n\t\t\t  struct v4l2_rect *crop)\n{\n\tconst struct isp_format_info *info;\n\tunsigned int max_width;\n\n\t \n\tinfo = omap3isp_video_format_info(sink->code);\n\tif (info->flavor != MEDIA_BUS_FMT_Y8_1X8) {\n\t\tcrop->left &= ~1;\n\t\tcrop->top &= ~1;\n\t}\n\n\tcrop->left = clamp_t(u32, crop->left, 0, sink->width - CCDC_MIN_WIDTH);\n\tcrop->top = clamp_t(u32, crop->top, 0, sink->height - CCDC_MIN_HEIGHT);\n\n\t \n\tmax_width = (sink->width - crop->left + 15) & ~15;\n\tcrop->width = clamp_t(u32, crop->width, CCDC_MIN_WIDTH, max_width)\n\t\t    & ~15;\n\tcrop->height = clamp_t(u32, crop->height, CCDC_MIN_HEIGHT,\n\t\t\t       sink->height - crop->top);\n\n\t \n\tif (info->flavor != MEDIA_BUS_FMT_Y8_1X8) {\n\t\tcrop->width &= ~1;\n\t\tcrop->height &= ~1;\n\t}\n}\n\n \nstatic int ccdc_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tswitch (code->pad) {\n\tcase CCDC_PAD_SINK:\n\t\tif (code->index >= ARRAY_SIZE(ccdc_fmts))\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = ccdc_fmts[code->index];\n\t\tbreak;\n\n\tcase CCDC_PAD_SOURCE_OF:\n\t\tformat = __ccdc_get_format(ccdc, sd_state, code->pad,\n\t\t\t\t\t   code->which);\n\n\t\tif (format->code == MEDIA_BUS_FMT_YUYV8_2X8 ||\n\t\t    format->code == MEDIA_BUS_FMT_UYVY8_2X8) {\n\t\t\t \n\t\t\tif (code->index == 0)\n\t\t\t\tcode->code = MEDIA_BUS_FMT_YUYV8_1X16;\n\t\t\telse if (code->index == 1)\n\t\t\t\tcode->code = MEDIA_BUS_FMT_UYVY8_1X16;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\t \n\t\t\tif (code->index == 0)\n\t\t\t\tcode->code = format->code;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase CCDC_PAD_SOURCE_VP:\n\t\t \n\t\tif (code->index != 0)\n\t\t\treturn -EINVAL;\n\n\t\tformat = __ccdc_get_format(ccdc, sd_state, code->pad,\n\t\t\t\t\t   code->which);\n\n\t\t \n\t\tif (format->code == 0)\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = format->code;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccdc_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tccdc_try_format(ccdc, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tccdc_try_format(ccdc, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int ccdc_get_selection(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_selection *sel)\n{\n\tstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tif (sel->pad != CCDC_PAD_SOURCE_OF)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = INT_MAX;\n\t\tsel->r.height = INT_MAX;\n\n\t\tformat = __ccdc_get_format(ccdc, sd_state, CCDC_PAD_SINK,\n\t\t\t\t\t   sel->which);\n\t\tccdc_try_crop(ccdc, format, &sel->r);\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *__ccdc_get_crop(ccdc, sd_state, sel->which);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ccdc_set_selection(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_selection *sel)\n{\n\tstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP ||\n\t    sel->pad != CCDC_PAD_SOURCE_OF)\n\t\treturn -EINVAL;\n\n\t \n\tif (ccdc->state != ISP_PIPELINE_STREAM_STOPPED)\n\t\treturn -EBUSY;\n\n\t \n\tif (sel->flags & V4L2_SEL_FLAG_KEEP_CONFIG) {\n\t\tsel->r = *__ccdc_get_crop(ccdc, sd_state, sel->which);\n\t\treturn 0;\n\t}\n\n\tformat = __ccdc_get_format(ccdc, sd_state, CCDC_PAD_SINK, sel->which);\n\tccdc_try_crop(ccdc, format, &sel->r);\n\t*__ccdc_get_crop(ccdc, sd_state, sel->which) = sel->r;\n\n\t \n\tformat = __ccdc_get_format(ccdc, sd_state, CCDC_PAD_SOURCE_OF,\n\t\t\t\t   sel->which);\n\tccdc_try_format(ccdc, sd_state, CCDC_PAD_SOURCE_OF, format,\n\t\t\tsel->which);\n\n\treturn 0;\n}\n\n \nstatic int ccdc_get_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __ccdc_get_format(ccdc, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\treturn 0;\n}\n\n \nstatic int ccdc_set_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *crop;\n\n\tformat = __ccdc_get_format(ccdc, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tccdc_try_format(ccdc, sd_state, fmt->pad, &fmt->format, fmt->which);\n\t*format = fmt->format;\n\n\t \n\tif (fmt->pad == CCDC_PAD_SINK) {\n\t\t \n\t\tcrop = __ccdc_get_crop(ccdc, sd_state, fmt->which);\n\t\tcrop->left = 0;\n\t\tcrop->top = 0;\n\t\tcrop->width = fmt->format.width;\n\t\tcrop->height = fmt->format.height;\n\n\t\tccdc_try_crop(ccdc, &fmt->format, crop);\n\n\t\t \n\t\tformat = __ccdc_get_format(ccdc, sd_state, CCDC_PAD_SOURCE_OF,\n\t\t\t\t\t   fmt->which);\n\t\t*format = fmt->format;\n\t\tccdc_try_format(ccdc, sd_state, CCDC_PAD_SOURCE_OF, format,\n\t\t\t\tfmt->which);\n\n\t\tformat = __ccdc_get_format(ccdc, sd_state, CCDC_PAD_SOURCE_VP,\n\t\t\t\t\t   fmt->which);\n\t\t*format = fmt->format;\n\t\tccdc_try_format(ccdc, sd_state, CCDC_PAD_SOURCE_VP, format,\n\t\t\t\tfmt->which);\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool ccdc_is_shiftable(u32 in, u32 out, unsigned int additional_shift)\n{\n\tconst struct isp_format_info *in_info, *out_info;\n\n\tif (in == out)\n\t\treturn true;\n\n\tin_info = omap3isp_video_format_info(in);\n\tout_info = omap3isp_video_format_info(out);\n\n\tif ((in_info->flavor == 0) || (out_info->flavor == 0))\n\t\treturn false;\n\n\tif (in_info->flavor != out_info->flavor)\n\t\treturn false;\n\n\treturn in_info->width - out_info->width + additional_shift <= 6;\n}\n\nstatic int ccdc_link_validate(struct v4l2_subdev *sd,\n\t\t\t      struct media_link *link,\n\t\t\t      struct v4l2_subdev_format *source_fmt,\n\t\t\t      struct v4l2_subdev_format *sink_fmt)\n{\n\tstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\n\tunsigned long parallel_shift;\n\n\t \n\tif (source_fmt->format.width != sink_fmt->format.width ||\n\t    source_fmt->format.height != sink_fmt->format.height)\n\t\treturn -EPIPE;\n\n\t \n\tif (ccdc->input == CCDC_INPUT_PARALLEL) {\n\t\tstruct v4l2_subdev *sd =\n\t\t\tmedia_entity_to_v4l2_subdev(link->source->entity);\n\t\tstruct isp_bus_cfg *bus_cfg;\n\n\t\tbus_cfg = v4l2_subdev_to_bus_cfg(sd);\n\t\tif (WARN_ON(!bus_cfg))\n\t\t\treturn -EPIPE;\n\n\t\tparallel_shift = bus_cfg->bus.parallel.data_lane_shift;\n\t} else {\n\t\tparallel_shift = 0;\n\t}\n\n\t \n\tif (!ccdc_is_shiftable(source_fmt->format.code,\n\t\t\t       sink_fmt->format.code, parallel_shift))\n\t\treturn -EPIPE;\n\n\treturn 0;\n}\n\n \nstatic int ccdc_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format;\n\n\tmemset(&format, 0, sizeof(format));\n\tformat.pad = CCDC_PAD_SINK;\n\tformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\n\tformat.format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\tformat.format.width = 4096;\n\tformat.format.height = 4096;\n\tccdc_set_format(sd, fh ? fh->state : NULL, &format);\n\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_core_ops ccdc_v4l2_core_ops = {\n\t.ioctl = ccdc_ioctl,\n\t.subscribe_event = ccdc_subscribe_event,\n\t.unsubscribe_event = ccdc_unsubscribe_event,\n};\n\n \nstatic const struct v4l2_subdev_video_ops ccdc_v4l2_video_ops = {\n\t.s_stream = ccdc_set_stream,\n};\n\n \nstatic const struct v4l2_subdev_pad_ops ccdc_v4l2_pad_ops = {\n\t.enum_mbus_code = ccdc_enum_mbus_code,\n\t.enum_frame_size = ccdc_enum_frame_size,\n\t.get_fmt = ccdc_get_format,\n\t.set_fmt = ccdc_set_format,\n\t.get_selection = ccdc_get_selection,\n\t.set_selection = ccdc_set_selection,\n\t.link_validate = ccdc_link_validate,\n};\n\n \nstatic const struct v4l2_subdev_ops ccdc_v4l2_ops = {\n\t.core = &ccdc_v4l2_core_ops,\n\t.video = &ccdc_v4l2_video_ops,\n\t.pad = &ccdc_v4l2_pad_ops,\n};\n\n \nstatic const struct v4l2_subdev_internal_ops ccdc_v4l2_internal_ops = {\n\t.open = ccdc_init_formats,\n};\n\n \n\n \nstatic int ccdc_link_setup(struct media_entity *entity,\n\t\t\t   const struct media_pad *local,\n\t\t\t   const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\n\tstruct isp_device *isp = to_isp_device(ccdc);\n\tunsigned int index = local->index;\n\n\t \n\tif (is_media_entity_v4l2_subdev(remote->entity))\n\t\tindex |= 2 << 16;\n\n\tswitch (index) {\n\tcase CCDC_PAD_SINK | 2 << 16:\n\t\t \n\t\tif (!(flags & MEDIA_LNK_FL_ENABLED)) {\n\t\t\tccdc->input = CCDC_INPUT_NONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ccdc->input != CCDC_INPUT_NONE)\n\t\t\treturn -EBUSY;\n\n\t\tif (remote->entity == &isp->isp_ccp2.subdev.entity)\n\t\t\tccdc->input = CCDC_INPUT_CCP2B;\n\t\telse if (remote->entity == &isp->isp_csi2a.subdev.entity)\n\t\t\tccdc->input = CCDC_INPUT_CSI2A;\n\t\telse if (remote->entity == &isp->isp_csi2c.subdev.entity)\n\t\t\tccdc->input = CCDC_INPUT_CSI2C;\n\t\telse\n\t\t\tccdc->input = CCDC_INPUT_PARALLEL;\n\n\t\tbreak;\n\n\t \n\n\tcase CCDC_PAD_SOURCE_VP | 2 << 16:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (ccdc->output & ~CCDC_OUTPUT_PREVIEW)\n\t\t\t\treturn -EBUSY;\n\t\t\tccdc->output |= CCDC_OUTPUT_PREVIEW;\n\t\t} else {\n\t\t\tccdc->output &= ~CCDC_OUTPUT_PREVIEW;\n\t\t}\n\t\tbreak;\n\n\tcase CCDC_PAD_SOURCE_OF:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (ccdc->output & ~CCDC_OUTPUT_MEMORY)\n\t\t\t\treturn -EBUSY;\n\t\t\tccdc->output |= CCDC_OUTPUT_MEMORY;\n\t\t} else {\n\t\t\tccdc->output &= ~CCDC_OUTPUT_MEMORY;\n\t\t}\n\t\tbreak;\n\n\tcase CCDC_PAD_SOURCE_OF | 2 << 16:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (ccdc->output & ~CCDC_OUTPUT_RESIZER)\n\t\t\t\treturn -EBUSY;\n\t\t\tccdc->output |= CCDC_OUTPUT_RESIZER;\n\t\t} else {\n\t\t\tccdc->output &= ~CCDC_OUTPUT_RESIZER;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct media_entity_operations ccdc_media_ops = {\n\t.link_setup = ccdc_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nvoid omap3isp_ccdc_unregister_entities(struct isp_ccdc_device *ccdc)\n{\n\tv4l2_device_unregister_subdev(&ccdc->subdev);\n\tomap3isp_video_unregister(&ccdc->video_out);\n}\n\nint omap3isp_ccdc_register_entities(struct isp_ccdc_device *ccdc,\n\tstruct v4l2_device *vdev)\n{\n\tint ret;\n\n\t \n\tccdc->subdev.dev = vdev->mdev->dev;\n\tret = v4l2_device_register_subdev(vdev, &ccdc->subdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = omap3isp_video_register(&ccdc->video_out, vdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tomap3isp_ccdc_unregister_entities(ccdc);\n\treturn ret;\n}\n\n \n\n \nstatic int ccdc_init_entities(struct isp_ccdc_device *ccdc)\n{\n\tstruct v4l2_subdev *sd = &ccdc->subdev;\n\tstruct media_pad *pads = ccdc->pads;\n\tstruct media_entity *me = &sd->entity;\n\tint ret;\n\n\tccdc->input = CCDC_INPUT_NONE;\n\n\tv4l2_subdev_init(sd, &ccdc_v4l2_ops);\n\tsd->internal_ops = &ccdc_v4l2_internal_ops;\n\tstrscpy(sd->name, \"OMAP3 ISP CCDC\", sizeof(sd->name));\n\tsd->grp_id = 1 << 16;\t \n\tv4l2_set_subdevdata(sd, ccdc);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tpads[CCDC_PAD_SINK].flags = MEDIA_PAD_FL_SINK\n\t\t\t\t    | MEDIA_PAD_FL_MUST_CONNECT;\n\tpads[CCDC_PAD_SOURCE_VP].flags = MEDIA_PAD_FL_SOURCE;\n\tpads[CCDC_PAD_SOURCE_OF].flags = MEDIA_PAD_FL_SOURCE;\n\n\tme->ops = &ccdc_media_ops;\n\tret = media_entity_pads_init(me, CCDC_PADS_NUM, pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tccdc_init_formats(sd, NULL);\n\n\tccdc->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tccdc->video_out.ops = &ccdc_video_ops;\n\tccdc->video_out.isp = to_isp_device(ccdc);\n\tccdc->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 3;\n\tccdc->video_out.bpl_alignment = 32;\n\n\tret = omap3isp_video_init(&ccdc->video_out, \"CCDC\");\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tmedia_entity_cleanup(me);\n\treturn ret;\n}\n\n \nint omap3isp_ccdc_init(struct isp_device *isp)\n{\n\tstruct isp_ccdc_device *ccdc = &isp->isp_ccdc;\n\tint ret;\n\n\tspin_lock_init(&ccdc->lock);\n\tinit_waitqueue_head(&ccdc->wait);\n\tmutex_init(&ccdc->ioctl_lock);\n\n\tccdc->stopping = CCDC_STOP_NOT_REQUESTED;\n\n\tINIT_WORK(&ccdc->lsc.table_work, ccdc_lsc_free_table_work);\n\tccdc->lsc.state = LSC_STATE_STOPPED;\n\tINIT_LIST_HEAD(&ccdc->lsc.free_queue);\n\tspin_lock_init(&ccdc->lsc.req_lock);\n\n\tccdc->clamp.oblen = 0;\n\tccdc->clamp.dcsubval = 0;\n\n\tccdc->update = OMAP3ISP_CCDC_BLCLAMP;\n\tccdc_apply_controls(ccdc);\n\n\tret = ccdc_init_entities(ccdc);\n\tif (ret < 0) {\n\t\tmutex_destroy(&ccdc->ioctl_lock);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nvoid omap3isp_ccdc_cleanup(struct isp_device *isp)\n{\n\tstruct isp_ccdc_device *ccdc = &isp->isp_ccdc;\n\n\tomap3isp_video_cleanup(&ccdc->video_out);\n\tmedia_entity_cleanup(&ccdc->subdev.entity);\n\n\t \n\tccdc_lsc_free_request(ccdc, ccdc->lsc.request);\n\tcancel_work_sync(&ccdc->lsc.table_work);\n\tccdc_lsc_free_queue(ccdc, &ccdc->lsc.free_queue);\n\n\tif (ccdc->fpc.addr != NULL)\n\t\tdma_free_coherent(isp->dev, ccdc->fpc.fpnum * 4, ccdc->fpc.addr,\n\t\t\t\t  ccdc->fpc.dma);\n\n\tmutex_destroy(&ccdc->ioctl_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}