{
  "module_name": "isph3a_af.c",
  "hash_id": "f07594466e0437f6543e0709d399906fd09eb0990f0f8af58bbd52ff8e2c63bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap3isp/isph3a_af.c",
  "human_readable_source": "\n \n\n \n#include <linux/device.h>\n#include <linux/slab.h>\n\n#include \"isp.h\"\n#include \"isph3a.h\"\n#include \"ispstat.h\"\n\n#define IS_OUT_OF_BOUNDS(value, min, max)\t\t\\\n\t((((unsigned int)value) < (min)) || (((unsigned int)value) > (max)))\n\nstatic void h3a_af_setup_regs(struct ispstat *af, void *priv)\n{\n\tstruct omap3isp_h3a_af_config *conf = priv;\n\tu32 pcr;\n\tu32 pax1;\n\tu32 pax2;\n\tu32 paxstart;\n\tu32 coef;\n\tu32 base_coef_set0;\n\tu32 base_coef_set1;\n\tint index;\n\n\tif (af->state == ISPSTAT_DISABLED)\n\t\treturn;\n\n\tisp_reg_writel(af->isp, af->active_buf->dma_addr, OMAP3_ISP_IOMEM_H3A,\n\t\t       ISPH3A_AFBUFST);\n\n\tif (!af->update)\n\t\treturn;\n\n\t \n\tpax1 = ((conf->paxel.width >> 1) - 1) << AF_PAXW_SHIFT;\n\t \n\tpax1 |= (conf->paxel.height >> 1) - 1;\n\tisp_reg_writel(af->isp, pax1, OMAP3_ISP_IOMEM_H3A, ISPH3A_AFPAX1);\n\n\t \n\t \n\tpax2 = ((conf->paxel.line_inc >> 1) - 1) << AF_LINE_INCR_SHIFT;\n\t \n\tpax2 |= (conf->paxel.v_cnt - 1) << AF_VT_COUNT_SHIFT;\n\t \n\tpax2 |= (conf->paxel.h_cnt - 1);\n\tisp_reg_writel(af->isp, pax2, OMAP3_ISP_IOMEM_H3A, ISPH3A_AFPAX2);\n\n\t \n\t \n\tpaxstart = conf->paxel.h_start << AF_HZ_START_SHIFT;\n\t \n\tpaxstart |= conf->paxel.v_start;\n\tisp_reg_writel(af->isp, paxstart, OMAP3_ISP_IOMEM_H3A,\n\t\t       ISPH3A_AFPAXSTART);\n\n\t \n\tisp_reg_writel(af->isp, conf->iir.h_start,\n\t\t       OMAP3_ISP_IOMEM_H3A, ISPH3A_AFIIRSH);\n\n\tbase_coef_set0 = ISPH3A_AFCOEF010;\n\tbase_coef_set1 = ISPH3A_AFCOEF110;\n\tfor (index = 0; index <= 8; index += 2) {\n\t\t \n\t\tcoef = 0;\n\t\tcoef |= conf->iir.coeff_set0[index];\n\t\tcoef |= conf->iir.coeff_set0[index + 1] <<\n\t\t\tAF_COEF_SHIFT;\n\t\tisp_reg_writel(af->isp, coef, OMAP3_ISP_IOMEM_H3A,\n\t\t\t       base_coef_set0);\n\t\tbase_coef_set0 += AFCOEF_OFFSET;\n\n\t\t \n\t\tcoef = 0;\n\t\tcoef |= conf->iir.coeff_set1[index];\n\t\tcoef |= conf->iir.coeff_set1[index + 1] <<\n\t\t\tAF_COEF_SHIFT;\n\t\tisp_reg_writel(af->isp, coef, OMAP3_ISP_IOMEM_H3A,\n\t\t\t       base_coef_set1);\n\t\tbase_coef_set1 += AFCOEF_OFFSET;\n\t}\n\t \n\tisp_reg_writel(af->isp, conf->iir.coeff_set0[10],\n\t\t       OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF0010);\n\t \n\tisp_reg_writel(af->isp, conf->iir.coeff_set1[10],\n\t\t       OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF1010);\n\n\t \n\t \n\tpcr = conf->rgb_pos << AF_RGBPOS_SHIFT;\n\t \n\tif (conf->fvmode == OMAP3ISP_AF_MODE_PEAK)\n\t\tpcr |= AF_FVMODE;\n\t \n\tif (conf->alaw_enable)\n\t\tpcr |= AF_ALAW_EN;\n\t \n\tif (conf->hmf.enable) {\n\t\t \n\t\tpcr |= AF_MED_EN;\n\t\t \n\t\tpcr |= conf->hmf.threshold << AF_MED_TH_SHIFT;\n\t}\n\t \n\tisp_reg_clr_set(af->isp, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR,\n\t\t\tAF_PCR_MASK, pcr);\n\n\taf->update = 0;\n\taf->config_counter += af->inc_config;\n\taf->inc_config = 0;\n\taf->buf_size = conf->buf_size;\n}\n\nstatic void h3a_af_enable(struct ispstat *af, int enable)\n{\n\tif (enable) {\n\t\tisp_reg_set(af->isp, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR,\n\t\t\t    ISPH3A_PCR_AF_EN);\n\t\tomap3isp_subclk_enable(af->isp, OMAP3_ISP_SUBCLK_AF);\n\t} else {\n\t\tisp_reg_clr(af->isp, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR,\n\t\t\t    ISPH3A_PCR_AF_EN);\n\t\tomap3isp_subclk_disable(af->isp, OMAP3_ISP_SUBCLK_AF);\n\t}\n}\n\nstatic int h3a_af_busy(struct ispstat *af)\n{\n\treturn isp_reg_readl(af->isp, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR)\n\t\t\t\t\t\t& ISPH3A_PCR_BUSYAF;\n}\n\nstatic u32 h3a_af_get_buf_size(struct omap3isp_h3a_af_config *conf)\n{\n\treturn conf->paxel.h_cnt * conf->paxel.v_cnt * OMAP3ISP_AF_PAXEL_SIZE;\n}\n\n \nstatic int h3a_af_validate_params(struct ispstat *af, void *new_conf)\n{\n\tstruct omap3isp_h3a_af_config *user_cfg = new_conf;\n\tstruct omap3isp_h3a_af_paxel *paxel_cfg = &user_cfg->paxel;\n\tstruct omap3isp_h3a_af_iir *iir_cfg = &user_cfg->iir;\n\tint index;\n\tu32 buf_size;\n\n\t \n\tif (IS_OUT_OF_BOUNDS(paxel_cfg->h_cnt,\n\t\t\t     OMAP3ISP_AF_PAXEL_HORIZONTAL_COUNT_MIN,\n\t\t\t     OMAP3ISP_AF_PAXEL_HORIZONTAL_COUNT_MAX))\n\t\treturn -EINVAL;\n\n\t \n\tif (IS_OUT_OF_BOUNDS(paxel_cfg->v_cnt,\n\t\t\t     OMAP3ISP_AF_PAXEL_VERTICAL_COUNT_MIN,\n\t\t\t     OMAP3ISP_AF_PAXEL_VERTICAL_COUNT_MAX))\n\t\treturn -EINVAL;\n\n\tif (IS_OUT_OF_BOUNDS(paxel_cfg->height, OMAP3ISP_AF_PAXEL_HEIGHT_MIN,\n\t\t\t     OMAP3ISP_AF_PAXEL_HEIGHT_MAX) ||\n\t    paxel_cfg->height % 2)\n\t\treturn -EINVAL;\n\n\t \n\tif (IS_OUT_OF_BOUNDS(paxel_cfg->width, OMAP3ISP_AF_PAXEL_WIDTH_MIN,\n\t\t\t     OMAP3ISP_AF_PAXEL_WIDTH_MAX) ||\n\t    paxel_cfg->width % 2)\n\t\treturn -EINVAL;\n\n\t \n\tif (IS_OUT_OF_BOUNDS(paxel_cfg->line_inc,\n\t\t\t     OMAP3ISP_AF_PAXEL_INCREMENT_MIN,\n\t\t\t     OMAP3ISP_AF_PAXEL_INCREMENT_MAX) ||\n\t    paxel_cfg->line_inc % 2)\n\t\treturn -EINVAL;\n\n\t \n\tif ((paxel_cfg->h_start < iir_cfg->h_start) ||\n\t    IS_OUT_OF_BOUNDS(paxel_cfg->h_start,\n\t\t\t     OMAP3ISP_AF_PAXEL_HZSTART_MIN,\n\t\t\t     OMAP3ISP_AF_PAXEL_HZSTART_MAX))\n\t\treturn -EINVAL;\n\n\t \n\tfor (index = 0; index < OMAP3ISP_AF_NUM_COEF; index++) {\n\t\tif ((iir_cfg->coeff_set0[index]) > OMAP3ISP_AF_COEF_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tif ((iir_cfg->coeff_set1[index]) > OMAP3ISP_AF_COEF_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (IS_OUT_OF_BOUNDS(iir_cfg->h_start, OMAP3ISP_AF_IIRSH_MIN,\n\t\t\t     OMAP3ISP_AF_IIRSH_MAX))\n\t\treturn -EINVAL;\n\n\t \n\tif ((paxel_cfg->h_cnt * paxel_cfg->v_cnt > 9) &&\n\t    (paxel_cfg->width * paxel_cfg->height == 12))\n\t\treturn -EINVAL;\n\n\tbuf_size = h3a_af_get_buf_size(user_cfg);\n\tif (buf_size > user_cfg->buf_size)\n\t\t \n\t\tuser_cfg->buf_size = buf_size;\n\telse if (user_cfg->buf_size > OMAP3ISP_AF_MAX_BUF_SIZE)\n\t\tuser_cfg->buf_size = OMAP3ISP_AF_MAX_BUF_SIZE;\n\n\treturn 0;\n}\n\n \nstatic void h3a_af_set_params(struct ispstat *af, void *new_conf)\n{\n\tstruct omap3isp_h3a_af_config *user_cfg = new_conf;\n\tstruct omap3isp_h3a_af_config *cur_cfg = af->priv;\n\tint update = 0;\n\tint index;\n\n\t \n\tif (cur_cfg->alaw_enable != user_cfg->alaw_enable) {\n\t\tupdate = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (cur_cfg->hmf.enable != user_cfg->hmf.enable) {\n\t\tupdate = 1;\n\t\tgoto out;\n\t}\n\tif (cur_cfg->hmf.threshold != user_cfg->hmf.threshold) {\n\t\tupdate = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (cur_cfg->rgb_pos != user_cfg->rgb_pos) {\n\t\tupdate = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (cur_cfg->iir.h_start != user_cfg->iir.h_start) {\n\t\tupdate = 1;\n\t\tgoto out;\n\t}\n\tfor (index = 0; index < OMAP3ISP_AF_NUM_COEF; index++) {\n\t\tif (cur_cfg->iir.coeff_set0[index] !=\n\t\t\t\tuser_cfg->iir.coeff_set0[index]) {\n\t\t\tupdate = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cur_cfg->iir.coeff_set1[index] !=\n\t\t\t\tuser_cfg->iir.coeff_set1[index]) {\n\t\t\tupdate = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif ((cur_cfg->paxel.width != user_cfg->paxel.width) ||\n\t    (cur_cfg->paxel.height != user_cfg->paxel.height) ||\n\t    (cur_cfg->paxel.h_start != user_cfg->paxel.h_start) ||\n\t    (cur_cfg->paxel.v_start != user_cfg->paxel.v_start) ||\n\t    (cur_cfg->paxel.h_cnt != user_cfg->paxel.h_cnt) ||\n\t    (cur_cfg->paxel.v_cnt != user_cfg->paxel.v_cnt) ||\n\t    (cur_cfg->paxel.line_inc != user_cfg->paxel.line_inc)) {\n\t\tupdate = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (cur_cfg->fvmode != user_cfg->fvmode)\n\t\tupdate = 1;\n\nout:\n\tif (update || !af->configured) {\n\t\tmemcpy(cur_cfg, user_cfg, sizeof(*cur_cfg));\n\t\taf->inc_config++;\n\t\taf->update = 1;\n\t\t \n\t\tcur_cfg->buf_size = h3a_af_get_buf_size(cur_cfg);\n\t}\n}\n\nstatic long h3a_af_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tstruct ispstat *stat = v4l2_get_subdevdata(sd);\n\n\tswitch (cmd) {\n\tcase VIDIOC_OMAP3ISP_AF_CFG:\n\t\treturn omap3isp_stat_config(stat, arg);\n\tcase VIDIOC_OMAP3ISP_STAT_REQ:\n\t\treturn omap3isp_stat_request_statistics(stat, arg);\n\tcase VIDIOC_OMAP3ISP_STAT_REQ_TIME32:\n\t\treturn omap3isp_stat_request_statistics_time32(stat, arg);\n\tcase VIDIOC_OMAP3ISP_STAT_EN: {\n\t\tint *en = arg;\n\t\treturn omap3isp_stat_enable(stat, !!*en);\n\t}\n\t}\n\n\treturn -ENOIOCTLCMD;\n\n}\n\nstatic const struct ispstat_ops h3a_af_ops = {\n\t.validate_params\t= h3a_af_validate_params,\n\t.set_params\t\t= h3a_af_set_params,\n\t.setup_regs\t\t= h3a_af_setup_regs,\n\t.enable\t\t\t= h3a_af_enable,\n\t.busy\t\t\t= h3a_af_busy,\n};\n\nstatic const struct v4l2_subdev_core_ops h3a_af_subdev_core_ops = {\n\t.ioctl = h3a_af_ioctl,\n\t.subscribe_event = omap3isp_stat_subscribe_event,\n\t.unsubscribe_event = omap3isp_stat_unsubscribe_event,\n};\n\nstatic const struct v4l2_subdev_video_ops h3a_af_subdev_video_ops = {\n\t.s_stream = omap3isp_stat_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops h3a_af_subdev_ops = {\n\t.core = &h3a_af_subdev_core_ops,\n\t.video = &h3a_af_subdev_video_ops,\n};\n\n \nint omap3isp_h3a_af_init(struct isp_device *isp)\n{\n\tstruct ispstat *af = &isp->isp_af;\n\tstruct omap3isp_h3a_af_config *af_cfg;\n\tstruct omap3isp_h3a_af_config *af_recover_cfg = NULL;\n\tint ret;\n\n\taf_cfg = kzalloc(sizeof(*af_cfg), GFP_KERNEL);\n\tif (af_cfg == NULL)\n\t\treturn -ENOMEM;\n\n\taf->ops = &h3a_af_ops;\n\taf->priv = af_cfg;\n\taf->event_type = V4L2_EVENT_OMAP3ISP_AF;\n\taf->isp = isp;\n\n\t \n\taf_recover_cfg = kzalloc(sizeof(*af_recover_cfg), GFP_KERNEL);\n\tif (!af_recover_cfg) {\n\t\tdev_err(af->isp->dev,\n\t\t\t\"AF: cannot allocate memory for recover configuration.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\taf_recover_cfg->paxel.h_start = OMAP3ISP_AF_PAXEL_HZSTART_MIN;\n\taf_recover_cfg->paxel.width = OMAP3ISP_AF_PAXEL_WIDTH_MIN;\n\taf_recover_cfg->paxel.height = OMAP3ISP_AF_PAXEL_HEIGHT_MIN;\n\taf_recover_cfg->paxel.h_cnt = OMAP3ISP_AF_PAXEL_HORIZONTAL_COUNT_MIN;\n\taf_recover_cfg->paxel.v_cnt = OMAP3ISP_AF_PAXEL_VERTICAL_COUNT_MIN;\n\taf_recover_cfg->paxel.line_inc = OMAP3ISP_AF_PAXEL_INCREMENT_MIN;\n\tif (h3a_af_validate_params(af, af_recover_cfg)) {\n\t\tdev_err(af->isp->dev,\n\t\t\t\"AF: recover configuration is invalid.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\taf_recover_cfg->buf_size = h3a_af_get_buf_size(af_recover_cfg);\n\taf->recover_priv = af_recover_cfg;\n\n\tret = omap3isp_stat_init(af, \"AF\", &h3a_af_subdev_ops);\n\nerr:\n\tif (ret) {\n\t\tkfree(af_cfg);\n\t\tkfree(af_recover_cfg);\n\t}\n\n\treturn ret;\n}\n\nvoid omap3isp_h3a_af_cleanup(struct isp_device *isp)\n{\n\tomap3isp_stat_cleanup(&isp->isp_af);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}