{
  "module_name": "isppreview.c",
  "hash_id": "0f2abc0687851c8d45a4c5c83cc6efa00f59ce067be5693214123f6d7980deab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap3isp/isppreview.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n\n#include \"isp.h\"\n#include \"ispreg.h\"\n#include \"isppreview.h\"\n\n \nstatic const struct omap3isp_prev_rgbtorgb flr_rgb2rgb = {\n\t{\t \n\t\t{0x01E2, 0x0F30, 0x0FEE},\n\t\t{0x0F9B, 0x01AC, 0x0FB9},\n\t\t{0x0FE0, 0x0EC0, 0x0260}\n\t},\t \n\t{0x0000, 0x0000, 0x0000}\n};\n\n \nstatic const struct omap3isp_prev_csc flr_prev_csc = {\n\t{\t \n\t\t{66, 129, 25},\n\t\t{-38, -75, 112},\n\t\t{112, -94 , -18}\n\t},\t \n\t{0x0, 0x0, 0x0}\n};\n\n \n#define FLR_CFA_GRADTHRS_HORZ\t0x28\n#define FLR_CFA_GRADTHRS_VERT\t0x28\n\n \n#define FLR_CSUP_GAIN\t\t0x0D\n#define FLR_CSUP_THRES\t\t0xEB\n\n \n#define FLR_NF_STRGTH\t\t0x03\n\n \n#define FLR_WBAL_DGAIN\t\t0x100\n#define FLR_WBAL_COEF\t\t0x20\n\n \n#define FLR_BLKADJ_BLUE\t\t0x0\n#define FLR_BLKADJ_GREEN\t0x0\n#define FLR_BLKADJ_RED\t\t0x0\n\n#define DEF_DETECT_CORRECT_VAL\t0xe\n\n \n\n#define PREV_MARGIN_LEFT\t6\n#define PREV_MARGIN_RIGHT\t4\n#define PREV_MARGIN_TOP\t\t2\n#define PREV_MARGIN_BOTTOM\t2\n\n#define PREV_MIN_IN_WIDTH\t64\n#define PREV_MIN_IN_HEIGHT\t8\n#define PREV_MAX_IN_HEIGHT\t16384\n\n#define PREV_MIN_OUT_WIDTH\t\t0\n#define PREV_MIN_OUT_HEIGHT\t\t0\n#define PREV_MAX_OUT_WIDTH_REV_1\t1280\n#define PREV_MAX_OUT_WIDTH_REV_2\t3300\n#define PREV_MAX_OUT_WIDTH_REV_15\t4096\n\n \n\n \nstatic u32 cfa_coef_table[4][OMAP3ISP_PREV_CFA_BLK_SIZE] = {\n#include \"cfa_coef_table.h\"\n};\n\n \nstatic u32 gamma_table[] = {\n#include \"gamma_table.h\"\n};\n\n \nstatic u32 noise_filter_table[] = {\n#include \"noise_filter_table.h\"\n};\n\n \nstatic u32 luma_enhance_table[] = {\n#include \"luma_enhance_table.h\"\n};\n\n \nstatic void\npreview_config_luma_enhancement(struct isp_prev_device *prev,\n\t\t\t\tconst struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct omap3isp_prev_luma *yt = &params->luma;\n\tunsigned int i;\n\n\tisp_reg_writel(isp, ISPPRV_YENH_TABLE_ADDR,\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\n\tfor (i = 0; i < OMAP3ISP_PREV_YENH_TBL_SIZE; i++) {\n\t\tisp_reg_writel(isp, yt->table[i],\n\t\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);\n\t}\n}\n\n \nstatic void\npreview_enable_luma_enhancement(struct isp_prev_device *prev, bool enable)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tif (enable)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_YNENHEN);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_YNENHEN);\n}\n\n \nstatic void preview_enable_invalaw(struct isp_prev_device *prev, bool enable)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tif (enable)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_INVALAW);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_INVALAW);\n}\n\n \nstatic void preview_config_hmed(struct isp_prev_device *prev,\n\t\t\t\tconst struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct omap3isp_prev_hmed *hmed = &params->hmed;\n\n\tisp_reg_writel(isp, (hmed->odddist == 1 ? 0 : ISPPRV_HMED_ODDDIST) |\n\t\t       (hmed->evendist == 1 ? 0 : ISPPRV_HMED_EVENDIST) |\n\t\t       (hmed->thres << ISPPRV_HMED_THRESHOLD_SHIFT),\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_HMED);\n}\n\n \nstatic void preview_enable_hmed(struct isp_prev_device *prev, bool enable)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tif (enable)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_HMEDEN);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_HMEDEN);\n}\n\n \nstatic void preview_config_cfa(struct isp_prev_device *prev,\n\t\t\t       const struct prev_params *params)\n{\n\tstatic const unsigned int cfa_coef_order[4][4] = {\n\t\t{ 0, 1, 2, 3 },  \n\t\t{ 1, 0, 3, 2 },  \n\t\t{ 2, 3, 0, 1 },  \n\t\t{ 3, 2, 1, 0 },  \n\t};\n\tconst unsigned int *order = cfa_coef_order[prev->params.cfa_order];\n\tconst struct omap3isp_prev_cfa *cfa = &params->cfa;\n\tstruct isp_device *isp = to_isp_device(prev);\n\tunsigned int i;\n\tunsigned int j;\n\n\tisp_reg_writel(isp,\n\t\t(cfa->gradthrs_vert << ISPPRV_CFA_GRADTH_VER_SHIFT) |\n\t\t(cfa->gradthrs_horz << ISPPRV_CFA_GRADTH_HOR_SHIFT),\n\t\tOMAP3_ISP_IOMEM_PREV, ISPPRV_CFA);\n\n\tisp_reg_writel(isp, ISPPRV_CFA_TABLE_ADDR,\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tconst __u32 *block = cfa->table[order[i]];\n\n\t\tfor (j = 0; j < OMAP3ISP_PREV_CFA_BLK_SIZE; ++j)\n\t\t\tisp_reg_writel(isp, block[j], OMAP3_ISP_IOMEM_PREV,\n\t\t\t\t       ISPPRV_SET_TBL_DATA);\n\t}\n}\n\n \nstatic void\npreview_config_chroma_suppression(struct isp_prev_device *prev,\n\t\t\t\t  const struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct omap3isp_prev_csup *cs = &params->csup;\n\n\tisp_reg_writel(isp,\n\t\t       cs->gain | (cs->thres << ISPPRV_CSUP_THRES_SHIFT) |\n\t\t       (cs->hypf_en << ISPPRV_CSUP_HPYF_SHIFT),\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_CSUP);\n}\n\n \nstatic void\npreview_enable_chroma_suppression(struct isp_prev_device *prev, bool enable)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tif (enable)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_SUPEN);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_SUPEN);\n}\n\n \nstatic void\npreview_config_whitebalance(struct isp_prev_device *prev,\n\t\t\t    const struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct omap3isp_prev_wbal *wbal = &params->wbal;\n\tu32 val;\n\n\tisp_reg_writel(isp, wbal->dgain, OMAP3_ISP_IOMEM_PREV, ISPPRV_WB_DGAIN);\n\n\tval = wbal->coef0 << ISPPRV_WBGAIN_COEF0_SHIFT;\n\tval |= wbal->coef1 << ISPPRV_WBGAIN_COEF1_SHIFT;\n\tval |= wbal->coef2 << ISPPRV_WBGAIN_COEF2_SHIFT;\n\tval |= wbal->coef3 << ISPPRV_WBGAIN_COEF3_SHIFT;\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_WBGAIN);\n\n\tisp_reg_writel(isp,\n\t\t       ISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N0_0_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N0_1_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N0_2_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N0_3_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N1_0_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N1_1_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N1_2_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N1_3_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N2_0_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N2_1_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N2_2_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N2_3_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N3_0_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N3_1_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N3_2_SHIFT |\n\t\t       ISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N3_3_SHIFT,\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_WBSEL);\n}\n\n \nstatic void\npreview_config_blkadj(struct isp_prev_device *prev,\n\t\t      const struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct omap3isp_prev_blkadj *blkadj = &params->blkadj;\n\n\tisp_reg_writel(isp, (blkadj->blue << ISPPRV_BLKADJOFF_B_SHIFT) |\n\t\t       (blkadj->green << ISPPRV_BLKADJOFF_G_SHIFT) |\n\t\t       (blkadj->red << ISPPRV_BLKADJOFF_R_SHIFT),\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_BLKADJOFF);\n}\n\n \nstatic void\npreview_config_rgb_blending(struct isp_prev_device *prev,\n\t\t\t    const struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct omap3isp_prev_rgbtorgb *rgbrgb = &params->rgb2rgb;\n\tu32 val;\n\n\tval = (rgbrgb->matrix[0][0] & 0xfff) << ISPPRV_RGB_MAT1_MTX_RR_SHIFT;\n\tval |= (rgbrgb->matrix[0][1] & 0xfff) << ISPPRV_RGB_MAT1_MTX_GR_SHIFT;\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT1);\n\n\tval = (rgbrgb->matrix[0][2] & 0xfff) << ISPPRV_RGB_MAT2_MTX_BR_SHIFT;\n\tval |= (rgbrgb->matrix[1][0] & 0xfff) << ISPPRV_RGB_MAT2_MTX_RG_SHIFT;\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT2);\n\n\tval = (rgbrgb->matrix[1][1] & 0xfff) << ISPPRV_RGB_MAT3_MTX_GG_SHIFT;\n\tval |= (rgbrgb->matrix[1][2] & 0xfff) << ISPPRV_RGB_MAT3_MTX_BG_SHIFT;\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT3);\n\n\tval = (rgbrgb->matrix[2][0] & 0xfff) << ISPPRV_RGB_MAT4_MTX_RB_SHIFT;\n\tval |= (rgbrgb->matrix[2][1] & 0xfff) << ISPPRV_RGB_MAT4_MTX_GB_SHIFT;\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT4);\n\n\tval = (rgbrgb->matrix[2][2] & 0xfff) << ISPPRV_RGB_MAT5_MTX_BB_SHIFT;\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT5);\n\n\tval = (rgbrgb->offset[0] & 0x3ff) << ISPPRV_RGB_OFF1_MTX_OFFR_SHIFT;\n\tval |= (rgbrgb->offset[1] & 0x3ff) << ISPPRV_RGB_OFF1_MTX_OFFG_SHIFT;\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_OFF1);\n\n\tval = (rgbrgb->offset[2] & 0x3ff) << ISPPRV_RGB_OFF2_MTX_OFFB_SHIFT;\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_OFF2);\n}\n\n \nstatic void\npreview_config_csc(struct isp_prev_device *prev,\n\t\t   const struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct omap3isp_prev_csc *csc = &params->csc;\n\tu32 val;\n\n\tval = (csc->matrix[0][0] & 0x3ff) << ISPPRV_CSC0_RY_SHIFT;\n\tval |= (csc->matrix[0][1] & 0x3ff) << ISPPRV_CSC0_GY_SHIFT;\n\tval |= (csc->matrix[0][2] & 0x3ff) << ISPPRV_CSC0_BY_SHIFT;\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC0);\n\n\tval = (csc->matrix[1][0] & 0x3ff) << ISPPRV_CSC1_RCB_SHIFT;\n\tval |= (csc->matrix[1][1] & 0x3ff) << ISPPRV_CSC1_GCB_SHIFT;\n\tval |= (csc->matrix[1][2] & 0x3ff) << ISPPRV_CSC1_BCB_SHIFT;\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC1);\n\n\tval = (csc->matrix[2][0] & 0x3ff) << ISPPRV_CSC2_RCR_SHIFT;\n\tval |= (csc->matrix[2][1] & 0x3ff) << ISPPRV_CSC2_GCR_SHIFT;\n\tval |= (csc->matrix[2][2] & 0x3ff) << ISPPRV_CSC2_BCR_SHIFT;\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC2);\n\n\tval = (csc->offset[0] & 0xff) << ISPPRV_CSC_OFFSET_Y_SHIFT;\n\tval |= (csc->offset[1] & 0xff) << ISPPRV_CSC_OFFSET_CB_SHIFT;\n\tval |= (csc->offset[2] & 0xff) << ISPPRV_CSC_OFFSET_CR_SHIFT;\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC_OFFSET);\n}\n\n \nstatic void\npreview_config_yc_range(struct isp_prev_device *prev,\n\t\t\tconst struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct omap3isp_prev_yclimit *yc = &params->yclimit;\n\n\tisp_reg_writel(isp,\n\t\t       yc->maxC << ISPPRV_SETUP_YC_MAXC_SHIFT |\n\t\t       yc->maxY << ISPPRV_SETUP_YC_MAXY_SHIFT |\n\t\t       yc->minC << ISPPRV_SETUP_YC_MINC_SHIFT |\n\t\t       yc->minY << ISPPRV_SETUP_YC_MINY_SHIFT,\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_SETUP_YC);\n}\n\n \nstatic void\npreview_config_dcor(struct isp_prev_device *prev,\n\t\t    const struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct omap3isp_prev_dcor *dcor = &params->dcor;\n\n\tisp_reg_writel(isp, dcor->detect_correct[0],\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR0);\n\tisp_reg_writel(isp, dcor->detect_correct[1],\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR1);\n\tisp_reg_writel(isp, dcor->detect_correct[2],\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR2);\n\tisp_reg_writel(isp, dcor->detect_correct[3],\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR3);\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\tISPPRV_PCR_DCCOUP,\n\t\t\tdcor->couplet_mode_en ? ISPPRV_PCR_DCCOUP : 0);\n}\n\n \nstatic void preview_enable_dcor(struct isp_prev_device *prev, bool enable)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tif (enable)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_DCOREN);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_DCOREN);\n}\n\n \nstatic void\npreview_enable_drkframe_capture(struct isp_prev_device *prev, bool enable)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tif (enable)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_DRKFCAP);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_DRKFCAP);\n}\n\n \nstatic void preview_enable_drkframe(struct isp_prev_device *prev, bool enable)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tif (enable)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_DRKFEN);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_DRKFEN);\n}\n\n \nstatic void\npreview_config_noisefilter(struct isp_prev_device *prev,\n\t\t\t   const struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct omap3isp_prev_nf *nf = &params->nf;\n\tunsigned int i;\n\n\tisp_reg_writel(isp, nf->spread, OMAP3_ISP_IOMEM_PREV, ISPPRV_NF);\n\tisp_reg_writel(isp, ISPPRV_NF_TABLE_ADDR,\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\n\tfor (i = 0; i < OMAP3ISP_PREV_NF_TBL_SIZE; i++) {\n\t\tisp_reg_writel(isp, nf->table[i],\n\t\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);\n\t}\n}\n\n \nstatic void\npreview_enable_noisefilter(struct isp_prev_device *prev, bool enable)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tif (enable)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_NFEN);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_NFEN);\n}\n\n \nstatic void\npreview_config_gammacorrn(struct isp_prev_device *prev,\n\t\t\t  const struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct omap3isp_prev_gtables *gt = &params->gamma;\n\tunsigned int i;\n\n\tisp_reg_writel(isp, ISPPRV_REDGAMMA_TABLE_ADDR,\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\n\tfor (i = 0; i < OMAP3ISP_PREV_GAMMA_TBL_SIZE; i++)\n\t\tisp_reg_writel(isp, gt->red[i], OMAP3_ISP_IOMEM_PREV,\n\t\t\t       ISPPRV_SET_TBL_DATA);\n\n\tisp_reg_writel(isp, ISPPRV_GREENGAMMA_TABLE_ADDR,\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\n\tfor (i = 0; i < OMAP3ISP_PREV_GAMMA_TBL_SIZE; i++)\n\t\tisp_reg_writel(isp, gt->green[i], OMAP3_ISP_IOMEM_PREV,\n\t\t\t       ISPPRV_SET_TBL_DATA);\n\n\tisp_reg_writel(isp, ISPPRV_BLUEGAMMA_TABLE_ADDR,\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\n\tfor (i = 0; i < OMAP3ISP_PREV_GAMMA_TBL_SIZE; i++)\n\t\tisp_reg_writel(isp, gt->blue[i], OMAP3_ISP_IOMEM_PREV,\n\t\t\t       ISPPRV_SET_TBL_DATA);\n}\n\n \nstatic void\npreview_enable_gammacorrn(struct isp_prev_device *prev, bool enable)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tif (enable)\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_GAMMA_BYPASS);\n\telse\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_GAMMA_BYPASS);\n}\n\n \nstatic void\npreview_config_contrast(struct isp_prev_device *prev,\n\t\t\tconst struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_CNT_BRT,\n\t\t\t0xff << ISPPRV_CNT_BRT_CNT_SHIFT,\n\t\t\tparams->contrast << ISPPRV_CNT_BRT_CNT_SHIFT);\n}\n\n \nstatic void\npreview_config_brightness(struct isp_prev_device *prev,\n\t\t\t  const struct prev_params *params)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_CNT_BRT,\n\t\t\t0xff << ISPPRV_CNT_BRT_BRT_SHIFT,\n\t\t\tparams->brightness << ISPPRV_CNT_BRT_BRT_SHIFT);\n}\n\n \nstatic void\npreview_update_contrast(struct isp_prev_device *prev, u8 contrast)\n{\n\tstruct prev_params *params;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prev->params.lock, flags);\n\tparams = (prev->params.active & OMAP3ISP_PREV_CONTRAST)\n\t       ? &prev->params.params[0] : &prev->params.params[1];\n\n\tif (params->contrast != (contrast * ISPPRV_CONTRAST_UNITS)) {\n\t\tparams->contrast = contrast * ISPPRV_CONTRAST_UNITS;\n\t\tparams->update |= OMAP3ISP_PREV_CONTRAST;\n\t}\n\tspin_unlock_irqrestore(&prev->params.lock, flags);\n}\n\n \nstatic void\npreview_update_brightness(struct isp_prev_device *prev, u8 brightness)\n{\n\tstruct prev_params *params;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prev->params.lock, flags);\n\tparams = (prev->params.active & OMAP3ISP_PREV_BRIGHTNESS)\n\t       ? &prev->params.params[0] : &prev->params.params[1];\n\n\tif (params->brightness != (brightness * ISPPRV_BRIGHT_UNITS)) {\n\t\tparams->brightness = brightness * ISPPRV_BRIGHT_UNITS;\n\t\tparams->update |= OMAP3ISP_PREV_BRIGHTNESS;\n\t}\n\tspin_unlock_irqrestore(&prev->params.lock, flags);\n}\n\nstatic u32\npreview_params_lock(struct isp_prev_device *prev, u32 update, bool shadow)\n{\n\tu32 active = prev->params.active;\n\n\tif (shadow) {\n\t\t \n\t\tprev->params.params[0].busy |= ~active & update;\n\t\tprev->params.params[1].busy |= active & update;\n\t} else {\n\t\t \n\t\tupdate = (prev->params.params[0].update & active)\n\t\t       | (prev->params.params[1].update & ~active);\n\n\t\tprev->params.params[0].busy |= active & update;\n\t\tprev->params.params[1].busy |= ~active & update;\n\t}\n\n\treturn update;\n}\n\nstatic void\npreview_params_unlock(struct isp_prev_device *prev, u32 update, bool shadow)\n{\n\tu32 active = prev->params.active;\n\n\tif (shadow) {\n\t\t \n\t\tprev->params.params[0].update |= (~active & update);\n\t\tprev->params.params[1].update |= (active & update);\n\t\tprev->params.params[0].busy &= active;\n\t\tprev->params.params[1].busy &= ~active;\n\t} else {\n\t\t \n\t\tprev->params.params[0].update &= ~(active & update);\n\t\tprev->params.params[1].update &= ~(~active & update);\n\t\tprev->params.params[0].busy &= ~active;\n\t\tprev->params.params[1].busy &= active;\n\t}\n}\n\nstatic void preview_params_switch(struct isp_prev_device *prev)\n{\n\tu32 to_switch;\n\n\t \n\tto_switch = (prev->params.params[0].update & ~prev->params.active)\n\t\t  | (prev->params.params[1].update & prev->params.active);\n\tto_switch &= ~(prev->params.params[0].busy |\n\t\t       prev->params.params[1].busy);\n\tif (to_switch == 0)\n\t\treturn;\n\n\tprev->params.active ^= to_switch;\n\n\t \n\tprev->params.params[0].update &= ~(~prev->params.active & to_switch);\n\tprev->params.params[1].update &= ~(prev->params.active & to_switch);\n}\n\n \nstruct preview_update {\n\tvoid (*config)(struct isp_prev_device *, const struct prev_params *);\n\tvoid (*enable)(struct isp_prev_device *, bool);\n\tunsigned int param_offset;\n\tunsigned int param_size;\n\tunsigned int config_offset;\n\tbool skip;\n};\n\n \nstatic const struct preview_update update_attrs[] = {\n\t  {\n\t\tpreview_config_luma_enhancement,\n\t\tpreview_enable_luma_enhancement,\n\t\toffsetof(struct prev_params, luma),\n\t\tsizeof_field(struct prev_params, luma),\n\t\toffsetof(struct omap3isp_prev_update_config, luma),\n\t},   {\n\t\tNULL,\n\t\tpreview_enable_invalaw,\n\t},   {\n\t\tpreview_config_hmed,\n\t\tpreview_enable_hmed,\n\t\toffsetof(struct prev_params, hmed),\n\t\tsizeof_field(struct prev_params, hmed),\n\t\toffsetof(struct omap3isp_prev_update_config, hmed),\n\t},   {\n\t\tpreview_config_cfa,\n\t\tNULL,\n\t\toffsetof(struct prev_params, cfa),\n\t\tsizeof_field(struct prev_params, cfa),\n\t\toffsetof(struct omap3isp_prev_update_config, cfa),\n\t},   {\n\t\tpreview_config_chroma_suppression,\n\t\tpreview_enable_chroma_suppression,\n\t\toffsetof(struct prev_params, csup),\n\t\tsizeof_field(struct prev_params, csup),\n\t\toffsetof(struct omap3isp_prev_update_config, csup),\n\t},   {\n\t\tpreview_config_whitebalance,\n\t\tNULL,\n\t\toffsetof(struct prev_params, wbal),\n\t\tsizeof_field(struct prev_params, wbal),\n\t\toffsetof(struct omap3isp_prev_update_config, wbal),\n\t},   {\n\t\tpreview_config_blkadj,\n\t\tNULL,\n\t\toffsetof(struct prev_params, blkadj),\n\t\tsizeof_field(struct prev_params, blkadj),\n\t\toffsetof(struct omap3isp_prev_update_config, blkadj),\n\t},   {\n\t\tpreview_config_rgb_blending,\n\t\tNULL,\n\t\toffsetof(struct prev_params, rgb2rgb),\n\t\tsizeof_field(struct prev_params, rgb2rgb),\n\t\toffsetof(struct omap3isp_prev_update_config, rgb2rgb),\n\t},   {\n\t\tpreview_config_csc,\n\t\tNULL,\n\t\toffsetof(struct prev_params, csc),\n\t\tsizeof_field(struct prev_params, csc),\n\t\toffsetof(struct omap3isp_prev_update_config, csc),\n\t},   {\n\t\tpreview_config_yc_range,\n\t\tNULL,\n\t\toffsetof(struct prev_params, yclimit),\n\t\tsizeof_field(struct prev_params, yclimit),\n\t\toffsetof(struct omap3isp_prev_update_config, yclimit),\n\t},   {\n\t\tpreview_config_dcor,\n\t\tpreview_enable_dcor,\n\t\toffsetof(struct prev_params, dcor),\n\t\tsizeof_field(struct prev_params, dcor),\n\t\toffsetof(struct omap3isp_prev_update_config, dcor),\n\t},   {\n\t\tNULL,\n\t\tNULL,\n\t},   {\n\t\tNULL,\n\t\tpreview_enable_drkframe_capture,\n\t},   {\n\t\tNULL,\n\t\tpreview_enable_drkframe,\n\t},   {\n\t\tNULL,\n\t\tpreview_enable_drkframe,\n\t},   {\n\t\tpreview_config_noisefilter,\n\t\tpreview_enable_noisefilter,\n\t\toffsetof(struct prev_params, nf),\n\t\tsizeof_field(struct prev_params, nf),\n\t\toffsetof(struct omap3isp_prev_update_config, nf),\n\t},   {\n\t\tpreview_config_gammacorrn,\n\t\tpreview_enable_gammacorrn,\n\t\toffsetof(struct prev_params, gamma),\n\t\tsizeof_field(struct prev_params, gamma),\n\t\toffsetof(struct omap3isp_prev_update_config, gamma),\n\t},   {\n\t\tpreview_config_contrast,\n\t\tNULL,\n\t\t0, 0, 0, true,\n\t},   {\n\t\tpreview_config_brightness,\n\t\tNULL,\n\t\t0, 0, 0, true,\n\t},\n};\n\n \nstatic int preview_config(struct isp_prev_device *prev,\n\t\t\t  struct omap3isp_prev_update_config *cfg)\n{\n\tunsigned long flags;\n\tunsigned int i;\n\tint rval = 0;\n\tu32 update;\n\tu32 active;\n\n\tif (cfg->update == 0)\n\t\treturn 0;\n\n\t \n\tspin_lock_irqsave(&prev->params.lock, flags);\n\tpreview_params_lock(prev, cfg->update, true);\n\tactive = prev->params.active;\n\tspin_unlock_irqrestore(&prev->params.lock, flags);\n\n\tupdate = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(update_attrs); i++) {\n\t\tconst struct preview_update *attr = &update_attrs[i];\n\t\tstruct prev_params *params;\n\t\tunsigned int bit = 1 << i;\n\n\t\tif (attr->skip || !(cfg->update & bit))\n\t\t\tcontinue;\n\n\t\tparams = &prev->params.params[!!(active & bit)];\n\n\t\tif (cfg->flag & bit) {\n\t\t\tvoid __user *from = *(void __user **)\n\t\t\t\t((void *)cfg + attr->config_offset);\n\t\t\tvoid *to = (void *)params + attr->param_offset;\n\t\t\tsize_t size = attr->param_size;\n\n\t\t\tif (to && from && size) {\n\t\t\t\tif (copy_from_user(to, from, size)) {\n\t\t\t\t\trval = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparams->features |= bit;\n\t\t} else {\n\t\t\tparams->features &= ~bit;\n\t\t}\n\n\t\tupdate |= bit;\n\t}\n\n\tspin_lock_irqsave(&prev->params.lock, flags);\n\tpreview_params_unlock(prev, update, true);\n\tpreview_params_switch(prev);\n\tspin_unlock_irqrestore(&prev->params.lock, flags);\n\n\treturn rval;\n}\n\n \nstatic void preview_setup_hw(struct isp_prev_device *prev, u32 update,\n\t\t\t     u32 active)\n{\n\tunsigned int i;\n\n\tif (update == 0)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(update_attrs); i++) {\n\t\tconst struct preview_update *attr = &update_attrs[i];\n\t\tstruct prev_params *params;\n\t\tunsigned int bit = 1 << i;\n\n\t\tif (!(update & bit))\n\t\t\tcontinue;\n\n\t\tparams = &prev->params.params[!(active & bit)];\n\n\t\tif (params->features & bit) {\n\t\t\tif (attr->config)\n\t\t\t\tattr->config(prev, params);\n\t\t\tif (attr->enable)\n\t\t\t\tattr->enable(prev, true);\n\t\t} else {\n\t\t\tif (attr->enable)\n\t\t\t\tattr->enable(prev, false);\n\t\t}\n\t}\n}\n\n \nstatic void preview_config_ycpos(struct isp_prev_device *prev, u32 pixelcode)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tenum preview_ycpos_mode mode;\n\n\tswitch (pixelcode) {\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\t\tmode = YCPOS_CrYCbY;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tmode = YCPOS_YCrYCb;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\tISPPRV_PCR_YCPOS_CrYCbY,\n\t\t\tmode << ISPPRV_PCR_YCPOS_SHIFT);\n}\n\n \nstatic void preview_config_averager(struct isp_prev_device *prev, u8 average)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tisp_reg_writel(isp, ISPPRV_AVE_EVENDIST_2 << ISPPRV_AVE_EVENDIST_SHIFT |\n\t\t       ISPPRV_AVE_ODDDIST_2 << ISPPRV_AVE_ODDDIST_SHIFT |\n\t\t       average, OMAP3_ISP_IOMEM_PREV, ISPPRV_AVE);\n}\n\n\n \nstatic void preview_config_input_format(struct isp_prev_device *prev,\n\t\t\t\t\tconst struct isp_format_info *info)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tstruct prev_params *params;\n\n\tif (info->width == 8)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_WIDTH);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_WIDTH);\n\n\tswitch (info->flavor) {\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\t\tprev->params.cfa_order = 0;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\t\tprev->params.cfa_order = 1;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\tprev->params.cfa_order = 2;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\t\tprev->params.cfa_order = 3;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_CFAEN);\n\t\treturn;\n\t}\n\n\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR, ISPPRV_PCR_CFAEN);\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\tISPPRV_PCR_CFAFMT_MASK, ISPPRV_PCR_CFAFMT_BAYER);\n\n\tparams = (prev->params.active & OMAP3ISP_PREV_CFA)\n\t       ? &prev->params.params[0] : &prev->params.params[1];\n\n\tpreview_config_cfa(prev, params);\n}\n\n \nstatic void preview_config_input_size(struct isp_prev_device *prev, u32 active)\n{\n\tconst struct v4l2_mbus_framefmt *format = &prev->formats[PREV_PAD_SINK];\n\tstruct isp_device *isp = to_isp_device(prev);\n\tunsigned int sph = prev->crop.left;\n\tunsigned int eph = prev->crop.left + prev->crop.width - 1;\n\tunsigned int slv = prev->crop.top;\n\tunsigned int elv = prev->crop.top + prev->crop.height - 1;\n\tu32 features;\n\n\tif (format->code != MEDIA_BUS_FMT_Y8_1X8 &&\n\t    format->code != MEDIA_BUS_FMT_Y10_1X10) {\n\t\tsph -= 2;\n\t\teph += 2;\n\t\tslv -= 2;\n\t\telv += 2;\n\t}\n\n\tfeatures = (prev->params.params[0].features & active)\n\t\t | (prev->params.params[1].features & ~active);\n\n\tif (features & (OMAP3ISP_PREV_DEFECT_COR | OMAP3ISP_PREV_NF)) {\n\t\tsph -= 2;\n\t\teph += 2;\n\t\tslv -= 2;\n\t\telv += 2;\n\t}\n\tif (features & OMAP3ISP_PREV_HRZ_MED) {\n\t\tsph -= 2;\n\t\teph += 2;\n\t}\n\tif (features & (OMAP3ISP_PREV_CHROMA_SUPP | OMAP3ISP_PREV_LUMAENH))\n\t\tsph -= 2;\n\n\tisp_reg_writel(isp, (sph << ISPPRV_HORZ_INFO_SPH_SHIFT) | eph,\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_HORZ_INFO);\n\tisp_reg_writel(isp, (slv << ISPPRV_VERT_INFO_SLV_SHIFT) | elv,\n\t\t       OMAP3_ISP_IOMEM_PREV, ISPPRV_VERT_INFO);\n}\n\n \nstatic void\npreview_config_inlineoffset(struct isp_prev_device *prev, u32 offset)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tisp_reg_writel(isp, offset & 0xffff, OMAP3_ISP_IOMEM_PREV,\n\t\t       ISPPRV_RADR_OFFSET);\n}\n\n \nstatic void preview_set_inaddr(struct isp_prev_device *prev, u32 addr)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tisp_reg_writel(isp, addr, OMAP3_ISP_IOMEM_PREV, ISPPRV_RSDR_ADDR);\n}\n\n \nstatic void preview_config_outlineoffset(struct isp_prev_device *prev,\n\t\t\t\t    u32 offset)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tisp_reg_writel(isp, offset & 0xffff, OMAP3_ISP_IOMEM_PREV,\n\t\t       ISPPRV_WADD_OFFSET);\n}\n\n \nstatic void preview_set_outaddr(struct isp_prev_device *prev, u32 addr)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tisp_reg_writel(isp, addr, OMAP3_ISP_IOMEM_PREV, ISPPRV_WSDR_ADDR);\n}\n\nstatic void preview_adjust_bandwidth(struct isp_prev_device *prev)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&prev->subdev.entity);\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct v4l2_mbus_framefmt *ifmt = &prev->formats[PREV_PAD_SINK];\n\tunsigned long l3_ick = pipe->l3_ick;\n\tstruct v4l2_fract *timeperframe;\n\tunsigned int cycles_per_frame;\n\tunsigned int requests_per_frame;\n\tunsigned int cycles_per_request;\n\tunsigned int minimum;\n\tunsigned int maximum;\n\tunsigned int value;\n\n\tif (prev->input != PREVIEW_INPUT_MEMORY) {\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_SDR_REQ_EXP,\n\t\t\t    ISPSBL_SDR_REQ_PRV_EXP_MASK);\n\t\treturn;\n\t}\n\n\t \n\tcycles_per_request = div_u64((u64)l3_ick / 2 * 256 + pipe->max_rate - 1,\n\t\t\t\t     pipe->max_rate);\n\tminimum = DIV_ROUND_UP(cycles_per_request, 32);\n\n\t \n\ttimeperframe = &pipe->max_timeperframe;\n\n\trequests_per_frame = DIV_ROUND_UP(ifmt->width * 2, 256) * ifmt->height;\n\tcycles_per_frame = div_u64((u64)l3_ick * timeperframe->numerator,\n\t\t\t\t   timeperframe->denominator);\n\tcycles_per_request = cycles_per_frame / requests_per_frame;\n\n\tmaximum = cycles_per_request / 32;\n\n\tvalue = max(minimum, maximum);\n\n\tdev_dbg(isp->dev, \"%s: cycles per request = %u\\n\", __func__, value);\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_SDR_REQ_EXP,\n\t\t\tISPSBL_SDR_REQ_PRV_EXP_MASK,\n\t\t\tvalue << ISPSBL_SDR_REQ_PRV_EXP_SHIFT);\n}\n\n \nint omap3isp_preview_busy(struct isp_prev_device *prev)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\treturn isp_reg_readl(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR)\n\t\t& ISPPRV_PCR_BUSY;\n}\n\n \nvoid omap3isp_preview_restore_context(struct isp_device *isp)\n{\n\tstruct isp_prev_device *prev = &isp->isp_prev;\n\tconst u32 update = OMAP3ISP_PREV_FEATURES_END - 1;\n\n\tprev->params.params[0].update = prev->params.active & update;\n\tprev->params.params[1].update = ~prev->params.active & update;\n\n\tpreview_setup_hw(prev, update, prev->params.active);\n\n\tprev->params.params[0].update = 0;\n\tprev->params.params[1].update = 0;\n}\n\n \n#define PREV_PRINT_REGISTER(isp, name)\\\n\tdev_dbg(isp->dev, \"###PRV \" #name \"=0x%08x\\n\", \\\n\t\tisp_reg_readl(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_##name))\n\nstatic void preview_print_status(struct isp_prev_device *prev)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tdev_dbg(isp->dev, \"-------------Preview Register dump----------\\n\");\n\n\tPREV_PRINT_REGISTER(isp, PCR);\n\tPREV_PRINT_REGISTER(isp, HORZ_INFO);\n\tPREV_PRINT_REGISTER(isp, VERT_INFO);\n\tPREV_PRINT_REGISTER(isp, RSDR_ADDR);\n\tPREV_PRINT_REGISTER(isp, RADR_OFFSET);\n\tPREV_PRINT_REGISTER(isp, DSDR_ADDR);\n\tPREV_PRINT_REGISTER(isp, DRKF_OFFSET);\n\tPREV_PRINT_REGISTER(isp, WSDR_ADDR);\n\tPREV_PRINT_REGISTER(isp, WADD_OFFSET);\n\tPREV_PRINT_REGISTER(isp, AVE);\n\tPREV_PRINT_REGISTER(isp, HMED);\n\tPREV_PRINT_REGISTER(isp, NF);\n\tPREV_PRINT_REGISTER(isp, WB_DGAIN);\n\tPREV_PRINT_REGISTER(isp, WBGAIN);\n\tPREV_PRINT_REGISTER(isp, WBSEL);\n\tPREV_PRINT_REGISTER(isp, CFA);\n\tPREV_PRINT_REGISTER(isp, BLKADJOFF);\n\tPREV_PRINT_REGISTER(isp, RGB_MAT1);\n\tPREV_PRINT_REGISTER(isp, RGB_MAT2);\n\tPREV_PRINT_REGISTER(isp, RGB_MAT3);\n\tPREV_PRINT_REGISTER(isp, RGB_MAT4);\n\tPREV_PRINT_REGISTER(isp, RGB_MAT5);\n\tPREV_PRINT_REGISTER(isp, RGB_OFF1);\n\tPREV_PRINT_REGISTER(isp, RGB_OFF2);\n\tPREV_PRINT_REGISTER(isp, CSC0);\n\tPREV_PRINT_REGISTER(isp, CSC1);\n\tPREV_PRINT_REGISTER(isp, CSC2);\n\tPREV_PRINT_REGISTER(isp, CSC_OFFSET);\n\tPREV_PRINT_REGISTER(isp, CNT_BRT);\n\tPREV_PRINT_REGISTER(isp, CSUP);\n\tPREV_PRINT_REGISTER(isp, SETUP_YC);\n\tPREV_PRINT_REGISTER(isp, SET_TBL_ADDR);\n\tPREV_PRINT_REGISTER(isp, CDC_THR0);\n\tPREV_PRINT_REGISTER(isp, CDC_THR1);\n\tPREV_PRINT_REGISTER(isp, CDC_THR2);\n\tPREV_PRINT_REGISTER(isp, CDC_THR3);\n\n\tdev_dbg(isp->dev, \"--------------------------------------------\\n\");\n}\n\n \nstatic void preview_init_params(struct isp_prev_device *prev)\n{\n\tstruct prev_params *params;\n\tunsigned int i;\n\n\tspin_lock_init(&prev->params.lock);\n\n\tprev->params.active = ~0;\n\tprev->params.params[0].busy = 0;\n\tprev->params.params[0].update = OMAP3ISP_PREV_FEATURES_END - 1;\n\tprev->params.params[1].busy = 0;\n\tprev->params.params[1].update = 0;\n\n\tparams = &prev->params.params[0];\n\n\t \n\tparams->contrast = ISPPRV_CONTRAST_DEF * ISPPRV_CONTRAST_UNITS;\n\tparams->brightness = ISPPRV_BRIGHT_DEF * ISPPRV_BRIGHT_UNITS;\n\tparams->cfa.format = OMAP3ISP_CFAFMT_BAYER;\n\tmemcpy(params->cfa.table, cfa_coef_table,\n\t       sizeof(params->cfa.table));\n\tparams->cfa.gradthrs_horz = FLR_CFA_GRADTHRS_HORZ;\n\tparams->cfa.gradthrs_vert = FLR_CFA_GRADTHRS_VERT;\n\tparams->csup.gain = FLR_CSUP_GAIN;\n\tparams->csup.thres = FLR_CSUP_THRES;\n\tparams->csup.hypf_en = 0;\n\tmemcpy(params->luma.table, luma_enhance_table,\n\t       sizeof(params->luma.table));\n\tparams->nf.spread = FLR_NF_STRGTH;\n\tmemcpy(params->nf.table, noise_filter_table, sizeof(params->nf.table));\n\tparams->dcor.couplet_mode_en = 1;\n\tfor (i = 0; i < OMAP3ISP_PREV_DETECT_CORRECT_CHANNELS; i++)\n\t\tparams->dcor.detect_correct[i] = DEF_DETECT_CORRECT_VAL;\n\tmemcpy(params->gamma.blue, gamma_table, sizeof(params->gamma.blue));\n\tmemcpy(params->gamma.green, gamma_table, sizeof(params->gamma.green));\n\tmemcpy(params->gamma.red, gamma_table, sizeof(params->gamma.red));\n\tparams->wbal.dgain = FLR_WBAL_DGAIN;\n\tparams->wbal.coef0 = FLR_WBAL_COEF;\n\tparams->wbal.coef1 = FLR_WBAL_COEF;\n\tparams->wbal.coef2 = FLR_WBAL_COEF;\n\tparams->wbal.coef3 = FLR_WBAL_COEF;\n\tparams->blkadj.red = FLR_BLKADJ_RED;\n\tparams->blkadj.green = FLR_BLKADJ_GREEN;\n\tparams->blkadj.blue = FLR_BLKADJ_BLUE;\n\tparams->rgb2rgb = flr_rgb2rgb;\n\tparams->csc = flr_prev_csc;\n\tparams->yclimit.minC = ISPPRV_YC_MIN;\n\tparams->yclimit.maxC = ISPPRV_YC_MAX;\n\tparams->yclimit.minY = ISPPRV_YC_MIN;\n\tparams->yclimit.maxY = ISPPRV_YC_MAX;\n\n\tparams->features = OMAP3ISP_PREV_CFA | OMAP3ISP_PREV_DEFECT_COR\n\t\t\t | OMAP3ISP_PREV_NF | OMAP3ISP_PREV_GAMMA\n\t\t\t | OMAP3ISP_PREV_BLKADJ | OMAP3ISP_PREV_YC_LIMIT\n\t\t\t | OMAP3ISP_PREV_RGB2RGB | OMAP3ISP_PREV_COLOR_CONV\n\t\t\t | OMAP3ISP_PREV_WB | OMAP3ISP_PREV_BRIGHTNESS\n\t\t\t | OMAP3ISP_PREV_CONTRAST;\n}\n\n \nstatic unsigned int preview_max_out_width(struct isp_prev_device *prev)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\tswitch (isp->revision) {\n\tcase ISP_REVISION_1_0:\n\t\treturn PREV_MAX_OUT_WIDTH_REV_1;\n\n\tcase ISP_REVISION_2_0:\n\tdefault:\n\t\treturn PREV_MAX_OUT_WIDTH_REV_2;\n\n\tcase ISP_REVISION_15_0:\n\t\treturn PREV_MAX_OUT_WIDTH_REV_15;\n\t}\n}\n\nstatic void preview_configure(struct isp_prev_device *prev)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\tconst struct isp_format_info *info;\n\tstruct v4l2_mbus_framefmt *format;\n\tunsigned long flags;\n\tu32 update;\n\tu32 active;\n\n\tspin_lock_irqsave(&prev->params.lock, flags);\n\t \n\tupdate = preview_params_lock(prev, 0, false);\n\tactive = prev->params.active;\n\tspin_unlock_irqrestore(&prev->params.lock, flags);\n\n\t \n\tformat = &prev->formats[PREV_PAD_SINK];\n\tinfo = omap3isp_video_format_info(format->code);\n\n\tpreview_adjust_bandwidth(prev);\n\n\tpreview_config_input_format(prev, info);\n\tpreview_config_input_size(prev, active);\n\n\tif (prev->input == PREVIEW_INPUT_CCDC)\n\t\tpreview_config_inlineoffset(prev, 0);\n\telse\n\t\tpreview_config_inlineoffset(prev, ALIGN(format->width, 0x20) *\n\t\t\t\t\t    info->bpp);\n\n\tpreview_setup_hw(prev, update, active);\n\n\t \n\tformat = &prev->formats[PREV_PAD_SOURCE];\n\n\tif (prev->output & PREVIEW_OUTPUT_MEMORY)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_SDRPORT);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_SDRPORT);\n\n\tif (prev->output & PREVIEW_OUTPUT_RESIZER)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_RSZPORT);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_RSZPORT);\n\n\tif (prev->output & PREVIEW_OUTPUT_MEMORY)\n\t\tpreview_config_outlineoffset(prev,\n\t\t\t\tALIGN(format->width, 0x10) * 2);\n\n\tpreview_config_averager(prev, 0);\n\tpreview_config_ycpos(prev, format->code);\n\n\tspin_lock_irqsave(&prev->params.lock, flags);\n\tpreview_params_unlock(prev, update, false);\n\tspin_unlock_irqrestore(&prev->params.lock, flags);\n}\n\n \n\nstatic void preview_enable_oneshot(struct isp_prev_device *prev)\n{\n\tstruct isp_device *isp = to_isp_device(prev);\n\n\t \n\tif (prev->input == PREVIEW_INPUT_MEMORY)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t\t    ISPPRV_PCR_SOURCE);\n\n\tisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\n\t\t    ISPPRV_PCR_EN | ISPPRV_PCR_ONESHOT);\n}\n\nvoid omap3isp_preview_isr_frame_sync(struct isp_prev_device *prev)\n{\n\t \n\tif (prev->state == ISP_PIPELINE_STREAM_CONTINUOUS &&\n\t    prev->video_out.dmaqueue_flags & ISP_VIDEO_DMAQUEUE_QUEUED) {\n\t\tpreview_enable_oneshot(prev);\n\t\tisp_video_dmaqueue_flags_clr(&prev->video_out);\n\t}\n}\n\nstatic void preview_isr_buffer(struct isp_prev_device *prev)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&prev->subdev.entity);\n\tstruct isp_buffer *buffer;\n\tint restart = 0;\n\n\tif (prev->output & PREVIEW_OUTPUT_MEMORY) {\n\t\tbuffer = omap3isp_video_buffer_next(&prev->video_out);\n\t\tif (buffer != NULL) {\n\t\t\tpreview_set_outaddr(prev, buffer->dma);\n\t\t\trestart = 1;\n\t\t}\n\t\tpipe->state |= ISP_PIPELINE_IDLE_OUTPUT;\n\t}\n\n\tif (prev->input == PREVIEW_INPUT_MEMORY) {\n\t\tbuffer = omap3isp_video_buffer_next(&prev->video_in);\n\t\tif (buffer != NULL)\n\t\t\tpreview_set_inaddr(prev, buffer->dma);\n\t\tpipe->state |= ISP_PIPELINE_IDLE_INPUT;\n\t}\n\n\tswitch (prev->state) {\n\tcase ISP_PIPELINE_STREAM_SINGLESHOT:\n\t\tif (isp_pipeline_ready(pipe))\n\t\t\tomap3isp_pipeline_set_stream(pipe,\n\t\t\t\t\t\tISP_PIPELINE_STREAM_SINGLESHOT);\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_CONTINUOUS:\n\t\t \n\t\tif (restart)\n\t\t\tpreview_enable_oneshot(prev);\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_STOPPED:\n\tdefault:\n\t\treturn;\n\t}\n}\n\n \nvoid omap3isp_preview_isr(struct isp_prev_device *prev)\n{\n\tunsigned long flags;\n\tu32 update;\n\tu32 active;\n\n\tif (omap3isp_module_sync_is_stopping(&prev->wait, &prev->stopping))\n\t\treturn;\n\n\tspin_lock_irqsave(&prev->params.lock, flags);\n\tpreview_params_switch(prev);\n\tupdate = preview_params_lock(prev, 0, false);\n\tactive = prev->params.active;\n\tspin_unlock_irqrestore(&prev->params.lock, flags);\n\n\tpreview_setup_hw(prev, update, active);\n\tpreview_config_input_size(prev, active);\n\n\tif (prev->input == PREVIEW_INPUT_MEMORY ||\n\t    prev->output & PREVIEW_OUTPUT_MEMORY)\n\t\tpreview_isr_buffer(prev);\n\telse if (prev->state == ISP_PIPELINE_STREAM_CONTINUOUS)\n\t\tpreview_enable_oneshot(prev);\n\n\tspin_lock_irqsave(&prev->params.lock, flags);\n\tpreview_params_unlock(prev, update, false);\n\tspin_unlock_irqrestore(&prev->params.lock, flags);\n}\n\n \n\nstatic int preview_video_queue(struct isp_video *video,\n\t\t\t       struct isp_buffer *buffer)\n{\n\tstruct isp_prev_device *prev = &video->isp->isp_prev;\n\n\tif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tpreview_set_inaddr(prev, buffer->dma);\n\n\tif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tpreview_set_outaddr(prev, buffer->dma);\n\n\treturn 0;\n}\n\nstatic const struct isp_video_operations preview_video_ops = {\n\t.queue = preview_video_queue,\n};\n\n \n\n \nstatic int preview_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct isp_prev_device *prev =\n\t\tcontainer_of(ctrl->handler, struct isp_prev_device, ctrls);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tpreview_update_brightness(prev, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tpreview_update_contrast(prev, ctrl->val);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops preview_ctrl_ops = {\n\t.s_ctrl = preview_s_ctrl,\n};\n\n \nstatic long preview_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\n\n\tswitch (cmd) {\n\tcase VIDIOC_OMAP3ISP_PRV_CFG:\n\t\treturn preview_config(prev, arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\n \nstatic int preview_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\n\tstruct isp_video *video_out = &prev->video_out;\n\tstruct isp_device *isp = to_isp_device(prev);\n\tstruct device *dev = to_device(prev);\n\n\tif (prev->state == ISP_PIPELINE_STREAM_STOPPED) {\n\t\tif (enable == ISP_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\n\t\tomap3isp_subclk_enable(isp, OMAP3_ISP_SUBCLK_PREVIEW);\n\t\tpreview_configure(prev);\n\t\tatomic_set(&prev->stopping, 0);\n\t\tpreview_print_status(prev);\n\t}\n\n\tswitch (enable) {\n\tcase ISP_PIPELINE_STREAM_CONTINUOUS:\n\t\tif (prev->output & PREVIEW_OUTPUT_MEMORY)\n\t\t\tomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_PREVIEW_WRITE);\n\n\t\tif (video_out->dmaqueue_flags & ISP_VIDEO_DMAQUEUE_QUEUED ||\n\t\t    !(prev->output & PREVIEW_OUTPUT_MEMORY))\n\t\t\tpreview_enable_oneshot(prev);\n\n\t\tisp_video_dmaqueue_flags_clr(video_out);\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_SINGLESHOT:\n\t\tif (prev->input == PREVIEW_INPUT_MEMORY)\n\t\t\tomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_PREVIEW_READ);\n\t\tif (prev->output & PREVIEW_OUTPUT_MEMORY)\n\t\t\tomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_PREVIEW_WRITE);\n\n\t\tpreview_enable_oneshot(prev);\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_STOPPED:\n\t\tif (omap3isp_module_sync_idle(&sd->entity, &prev->wait,\n\t\t\t\t\t      &prev->stopping))\n\t\t\tdev_dbg(dev, \"%s: stop timeout.\\n\", sd->name);\n\t\tomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_PREVIEW_READ);\n\t\tomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_PREVIEW_WRITE);\n\t\tomap3isp_subclk_disable(isp, OMAP3_ISP_SUBCLK_PREVIEW);\n\t\tisp_video_dmaqueue_flags_clr(video_out);\n\t\tbreak;\n\t}\n\n\tprev->state = enable;\n\treturn 0;\n}\n\nstatic struct v4l2_mbus_framefmt *\n__preview_get_format(struct isp_prev_device *prev,\n\t\t     struct v4l2_subdev_state *sd_state,\n\t\t     unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&prev->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\telse\n\t\treturn &prev->formats[pad];\n}\n\nstatic struct v4l2_rect *\n__preview_get_crop(struct isp_prev_device *prev,\n\t\t   struct v4l2_subdev_state *sd_state,\n\t\t   enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_crop(&prev->subdev, sd_state,\n\t\t\t\t\t\tPREV_PAD_SINK);\n\telse\n\t\treturn &prev->crop;\n}\n\n \nstatic const unsigned int preview_input_fmts[] = {\n\tMEDIA_BUS_FMT_Y8_1X8,\n\tMEDIA_BUS_FMT_SGRBG8_1X8,\n\tMEDIA_BUS_FMT_SRGGB8_1X8,\n\tMEDIA_BUS_FMT_SBGGR8_1X8,\n\tMEDIA_BUS_FMT_SGBRG8_1X8,\n\tMEDIA_BUS_FMT_Y10_1X10,\n\tMEDIA_BUS_FMT_SGRBG10_1X10,\n\tMEDIA_BUS_FMT_SRGGB10_1X10,\n\tMEDIA_BUS_FMT_SBGGR10_1X10,\n\tMEDIA_BUS_FMT_SGBRG10_1X10,\n};\n\nstatic const unsigned int preview_output_fmts[] = {\n\tMEDIA_BUS_FMT_UYVY8_1X16,\n\tMEDIA_BUS_FMT_YUYV8_1X16,\n};\n\n \nstatic void preview_try_format(struct isp_prev_device *prev,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       unsigned int pad,\n\t\t\t       struct v4l2_mbus_framefmt *fmt,\n\t\t\t       enum v4l2_subdev_format_whence which)\n{\n\tu32 pixelcode;\n\tstruct v4l2_rect *crop;\n\tunsigned int i;\n\n\tswitch (pad) {\n\tcase PREV_PAD_SINK:\n\t\t \n\t\tif (prev->input == PREVIEW_INPUT_MEMORY) {\n\t\t\tfmt->width = clamp_t(u32, fmt->width, PREV_MIN_IN_WIDTH,\n\t\t\t\t\t     preview_max_out_width(prev));\n\t\t\tfmt->height = clamp_t(u32, fmt->height,\n\t\t\t\t\t      PREV_MIN_IN_HEIGHT,\n\t\t\t\t\t      PREV_MAX_IN_HEIGHT);\n\t\t}\n\n\t\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(preview_input_fmts); i++) {\n\t\t\tif (fmt->code == preview_input_fmts[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i >= ARRAY_SIZE(preview_input_fmts))\n\t\t\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\t\tbreak;\n\n\tcase PREV_PAD_SOURCE:\n\t\tpixelcode = fmt->code;\n\t\t*fmt = *__preview_get_format(prev, sd_state, PREV_PAD_SINK,\n\t\t\t\t\t     which);\n\n\t\tswitch (pixelcode) {\n\t\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\t\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\t\tfmt->code = pixelcode;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmt->code = MEDIA_BUS_FMT_YUYV8_1X16;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcrop = __preview_get_crop(prev, sd_state, which);\n\t\tfmt->width = crop->width;\n\t\tfmt->height = crop->height;\n\n\t\tfmt->colorspace = V4L2_COLORSPACE_JPEG;\n\t\tbreak;\n\t}\n\n\tfmt->field = V4L2_FIELD_NONE;\n}\n\n \nstatic void preview_try_crop(struct isp_prev_device *prev,\n\t\t\t     const struct v4l2_mbus_framefmt *sink,\n\t\t\t     struct v4l2_rect *crop)\n{\n\tunsigned int left = PREV_MARGIN_LEFT;\n\tunsigned int right = sink->width - PREV_MARGIN_RIGHT;\n\tunsigned int top = PREV_MARGIN_TOP;\n\tunsigned int bottom = sink->height - PREV_MARGIN_BOTTOM;\n\n\t \n\tif (prev->input == PREVIEW_INPUT_CCDC) {\n\t\tleft += 2;\n\t\tright -= 2;\n\t}\n\n\t \n\tif (sink->code != MEDIA_BUS_FMT_Y8_1X8 &&\n\t    sink->code != MEDIA_BUS_FMT_Y10_1X10) {\n\t\tleft += 2;\n\t\tright -= 2;\n\t\ttop += 2;\n\t\tbottom -= 2;\n\t}\n\n\t \n\tcrop->left &= ~1;\n\tcrop->top &= ~1;\n\n\tcrop->left = clamp_t(u32, crop->left, left, right - PREV_MIN_OUT_WIDTH);\n\tcrop->top = clamp_t(u32, crop->top, top, bottom - PREV_MIN_OUT_HEIGHT);\n\tcrop->width = clamp_t(u32, crop->width, PREV_MIN_OUT_WIDTH,\n\t\t\t      right - crop->left);\n\tcrop->height = clamp_t(u32, crop->height, PREV_MIN_OUT_HEIGHT,\n\t\t\t       bottom - crop->top);\n}\n\n \nstatic int preview_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tswitch (code->pad) {\n\tcase PREV_PAD_SINK:\n\t\tif (code->index >= ARRAY_SIZE(preview_input_fmts))\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = preview_input_fmts[code->index];\n\t\tbreak;\n\tcase PREV_PAD_SOURCE:\n\t\tif (code->index >= ARRAY_SIZE(preview_output_fmts))\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = preview_output_fmts[code->index];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int preview_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tpreview_try_format(prev, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tpreview_try_format(prev, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int preview_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tif (sel->pad != PREV_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = INT_MAX;\n\t\tsel->r.height = INT_MAX;\n\n\t\tformat = __preview_get_format(prev, sd_state, PREV_PAD_SINK,\n\t\t\t\t\t      sel->which);\n\t\tpreview_try_crop(prev, format, &sel->r);\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *__preview_get_crop(prev, sd_state, sel->which);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int preview_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP ||\n\t    sel->pad != PREV_PAD_SINK)\n\t\treturn -EINVAL;\n\n\t \n\tif (prev->state != ISP_PIPELINE_STREAM_STOPPED)\n\t\treturn -EBUSY;\n\n\t \n\tif (sel->flags & V4L2_SEL_FLAG_KEEP_CONFIG) {\n\t\tsel->r = *__preview_get_crop(prev, sd_state, sel->which);\n\t\treturn 0;\n\t}\n\n\tformat = __preview_get_format(prev, sd_state, PREV_PAD_SINK,\n\t\t\t\t      sel->which);\n\tpreview_try_crop(prev, format, &sel->r);\n\t*__preview_get_crop(prev, sd_state, sel->which) = sel->r;\n\n\t \n\tformat = __preview_get_format(prev, sd_state, PREV_PAD_SOURCE,\n\t\t\t\t      sel->which);\n\tpreview_try_format(prev, sd_state, PREV_PAD_SOURCE, format,\n\t\t\t   sel->which);\n\n\treturn 0;\n}\n\n \nstatic int preview_get_format(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __preview_get_format(prev, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\treturn 0;\n}\n\n \nstatic int preview_set_format(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *crop;\n\n\tformat = __preview_get_format(prev, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tpreview_try_format(prev, sd_state, fmt->pad, &fmt->format, fmt->which);\n\t*format = fmt->format;\n\n\t \n\tif (fmt->pad == PREV_PAD_SINK) {\n\t\t \n\t\tcrop = __preview_get_crop(prev, sd_state, fmt->which);\n\t\tcrop->left = 0;\n\t\tcrop->top = 0;\n\t\tcrop->width = fmt->format.width;\n\t\tcrop->height = fmt->format.height;\n\n\t\tpreview_try_crop(prev, &fmt->format, crop);\n\n\t\t \n\t\tformat = __preview_get_format(prev, sd_state, PREV_PAD_SOURCE,\n\t\t\t\t\t      fmt->which);\n\t\tpreview_try_format(prev, sd_state, PREV_PAD_SOURCE, format,\n\t\t\t\t   fmt->which);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int preview_init_formats(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format;\n\n\tmemset(&format, 0, sizeof(format));\n\tformat.pad = PREV_PAD_SINK;\n\tformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\n\tformat.format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\tformat.format.width = 4096;\n\tformat.format.height = 4096;\n\tpreview_set_format(sd, fh ? fh->state : NULL, &format);\n\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_core_ops preview_v4l2_core_ops = {\n\t.ioctl = preview_ioctl,\n};\n\n \nstatic const struct v4l2_subdev_video_ops preview_v4l2_video_ops = {\n\t.s_stream = preview_set_stream,\n};\n\n \nstatic const struct v4l2_subdev_pad_ops preview_v4l2_pad_ops = {\n\t.enum_mbus_code = preview_enum_mbus_code,\n\t.enum_frame_size = preview_enum_frame_size,\n\t.get_fmt = preview_get_format,\n\t.set_fmt = preview_set_format,\n\t.get_selection = preview_get_selection,\n\t.set_selection = preview_set_selection,\n};\n\n \nstatic const struct v4l2_subdev_ops preview_v4l2_ops = {\n\t.core = &preview_v4l2_core_ops,\n\t.video = &preview_v4l2_video_ops,\n\t.pad = &preview_v4l2_pad_ops,\n};\n\n \nstatic const struct v4l2_subdev_internal_ops preview_v4l2_internal_ops = {\n\t.open = preview_init_formats,\n};\n\n \n\n \nstatic int preview_link_setup(struct media_entity *entity,\n\t\t\t      const struct media_pad *local,\n\t\t\t      const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\n\tunsigned int index = local->index;\n\n\t \n\tif (is_media_entity_v4l2_subdev(remote->entity))\n\t\tindex |= 2 << 16;\n\n\tswitch (index) {\n\tcase PREV_PAD_SINK:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (prev->input == PREVIEW_INPUT_CCDC)\n\t\t\t\treturn -EBUSY;\n\t\t\tprev->input = PREVIEW_INPUT_MEMORY;\n\t\t} else {\n\t\t\tif (prev->input == PREVIEW_INPUT_MEMORY)\n\t\t\t\tprev->input = PREVIEW_INPUT_NONE;\n\t\t}\n\t\tbreak;\n\n\tcase PREV_PAD_SINK | 2 << 16:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (prev->input == PREVIEW_INPUT_MEMORY)\n\t\t\t\treturn -EBUSY;\n\t\t\tprev->input = PREVIEW_INPUT_CCDC;\n\t\t} else {\n\t\t\tif (prev->input == PREVIEW_INPUT_CCDC)\n\t\t\t\tprev->input = PREVIEW_INPUT_NONE;\n\t\t}\n\t\tbreak;\n\n\t \n\n\tcase PREV_PAD_SOURCE:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (prev->output & ~PREVIEW_OUTPUT_MEMORY)\n\t\t\t\treturn -EBUSY;\n\t\t\tprev->output |= PREVIEW_OUTPUT_MEMORY;\n\t\t} else {\n\t\t\tprev->output &= ~PREVIEW_OUTPUT_MEMORY;\n\t\t}\n\t\tbreak;\n\n\tcase PREV_PAD_SOURCE | 2 << 16:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (prev->output & ~PREVIEW_OUTPUT_RESIZER)\n\t\t\t\treturn -EBUSY;\n\t\t\tprev->output |= PREVIEW_OUTPUT_RESIZER;\n\t\t} else {\n\t\t\tprev->output &= ~PREVIEW_OUTPUT_RESIZER;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct media_entity_operations preview_media_ops = {\n\t.link_setup = preview_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nvoid omap3isp_preview_unregister_entities(struct isp_prev_device *prev)\n{\n\tv4l2_device_unregister_subdev(&prev->subdev);\n\tomap3isp_video_unregister(&prev->video_in);\n\tomap3isp_video_unregister(&prev->video_out);\n}\n\nint omap3isp_preview_register_entities(struct isp_prev_device *prev,\n\tstruct v4l2_device *vdev)\n{\n\tint ret;\n\n\t \n\tprev->subdev.dev = vdev->mdev->dev;\n\tret = v4l2_device_register_subdev(vdev, &prev->subdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = omap3isp_video_register(&prev->video_in, vdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = omap3isp_video_register(&prev->video_out, vdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tomap3isp_preview_unregister_entities(prev);\n\treturn ret;\n}\n\n \n\n \nstatic int preview_init_entities(struct isp_prev_device *prev)\n{\n\tstruct v4l2_subdev *sd = &prev->subdev;\n\tstruct media_pad *pads = prev->pads;\n\tstruct media_entity *me = &sd->entity;\n\tint ret;\n\n\tprev->input = PREVIEW_INPUT_NONE;\n\n\tv4l2_subdev_init(sd, &preview_v4l2_ops);\n\tsd->internal_ops = &preview_v4l2_internal_ops;\n\tstrscpy(sd->name, \"OMAP3 ISP preview\", sizeof(sd->name));\n\tsd->grp_id = 1 << 16;\t \n\tv4l2_set_subdevdata(sd, prev);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tv4l2_ctrl_handler_init(&prev->ctrls, 2);\n\tv4l2_ctrl_new_std(&prev->ctrls, &preview_ctrl_ops, V4L2_CID_BRIGHTNESS,\n\t\t\t  ISPPRV_BRIGHT_LOW, ISPPRV_BRIGHT_HIGH,\n\t\t\t  ISPPRV_BRIGHT_STEP, ISPPRV_BRIGHT_DEF);\n\tv4l2_ctrl_new_std(&prev->ctrls, &preview_ctrl_ops, V4L2_CID_CONTRAST,\n\t\t\t  ISPPRV_CONTRAST_LOW, ISPPRV_CONTRAST_HIGH,\n\t\t\t  ISPPRV_CONTRAST_STEP, ISPPRV_CONTRAST_DEF);\n\tv4l2_ctrl_handler_setup(&prev->ctrls);\n\tsd->ctrl_handler = &prev->ctrls;\n\n\tpads[PREV_PAD_SINK].flags = MEDIA_PAD_FL_SINK\n\t\t\t\t    | MEDIA_PAD_FL_MUST_CONNECT;\n\tpads[PREV_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\tme->ops = &preview_media_ops;\n\tret = media_entity_pads_init(me, PREV_PADS_NUM, pads);\n\tif (ret < 0)\n\t\tgoto error_handler_free;\n\n\tpreview_init_formats(sd, NULL);\n\n\t \n\tprev->video_in.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tprev->video_in.ops = &preview_video_ops;\n\tprev->video_in.isp = to_isp_device(prev);\n\tprev->video_in.capture_mem = PAGE_ALIGN(4096 * 4096) * 2 * 3;\n\tprev->video_in.bpl_alignment = 64;\n\tprev->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tprev->video_out.ops = &preview_video_ops;\n\tprev->video_out.isp = to_isp_device(prev);\n\tprev->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 2 * 3;\n\tprev->video_out.bpl_alignment = 32;\n\n\tret = omap3isp_video_init(&prev->video_in, \"preview\");\n\tif (ret < 0)\n\t\tgoto error_video_in;\n\n\tret = omap3isp_video_init(&prev->video_out, \"preview\");\n\tif (ret < 0)\n\t\tgoto error_video_out;\n\n\treturn 0;\n\nerror_video_out:\n\tomap3isp_video_cleanup(&prev->video_in);\nerror_video_in:\n\tmedia_entity_cleanup(&prev->subdev.entity);\nerror_handler_free:\n\tv4l2_ctrl_handler_free(&prev->ctrls);\n\treturn ret;\n}\n\n \nint omap3isp_preview_init(struct isp_device *isp)\n{\n\tstruct isp_prev_device *prev = &isp->isp_prev;\n\n\tinit_waitqueue_head(&prev->wait);\n\n\tpreview_init_params(prev);\n\n\treturn preview_init_entities(prev);\n}\n\nvoid omap3isp_preview_cleanup(struct isp_device *isp)\n{\n\tstruct isp_prev_device *prev = &isp->isp_prev;\n\n\tv4l2_ctrl_handler_free(&prev->ctrls);\n\tomap3isp_video_cleanup(&prev->video_in);\n\tomap3isp_video_cleanup(&prev->video_out);\n\tmedia_entity_cleanup(&prev->subdev.entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}