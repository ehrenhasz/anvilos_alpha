{
  "module_name": "ispresizer.c",
  "hash_id": "221a7da0cc159cf9d736a10d972a0e018310794c1bb018a8c33703d4ed585a9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap3isp/ispresizer.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\n#include \"isp.h\"\n#include \"ispreg.h\"\n#include \"ispresizer.h\"\n\n \n#define MIN_RESIZE_VALUE\t\t64\n#define MID_RESIZE_VALUE\t\t512\n#define MAX_RESIZE_VALUE\t\t1024\n\n#define MIN_IN_WIDTH\t\t\t32\n#define MIN_IN_HEIGHT\t\t\t32\n#define MAX_IN_WIDTH_MEMORY_MODE\t4095\n#define MAX_IN_WIDTH_ONTHEFLY_MODE_ES1\t1280\n#define MAX_IN_WIDTH_ONTHEFLY_MODE_ES2\t4095\n#define MAX_IN_HEIGHT\t\t\t4095\n\n#define MIN_OUT_WIDTH\t\t\t16\n#define MIN_OUT_HEIGHT\t\t\t2\n#define MAX_OUT_HEIGHT\t\t\t4095\n\n \n#define MAX_4TAP_OUT_WIDTH_ES1\t\t1280\n#define MAX_7TAP_OUT_WIDTH_ES1\t\t640\n#define MAX_4TAP_OUT_WIDTH_ES2\t\t3312\n#define MAX_7TAP_OUT_WIDTH_ES2\t\t1650\n#define MAX_4TAP_OUT_WIDTH_3630\t\t4096\n#define MAX_7TAP_OUT_WIDTH_3630\t\t2048\n\n \n#define RESIZE_DIVISOR\t\t\t256\n#define DEFAULT_PHASE\t\t\t1\n\n \nstatic const struct isprsz_coef filter_coefs = {\n\t \n\t{\n\t\t0x0000, 0x0100, 0x0000, 0x0000,\n\t\t0x03FA, 0x00F6, 0x0010, 0x0000,\n\t\t0x03F9, 0x00DB, 0x002C, 0x0000,\n\t\t0x03FB, 0x00B3, 0x0053, 0x03FF,\n\t\t0x03FD, 0x0082, 0x0084, 0x03FD,\n\t\t0x03FF, 0x0053, 0x00B3, 0x03FB,\n\t\t0x0000, 0x002C, 0x00DB, 0x03F9,\n\t\t0x0000, 0x0010, 0x00F6, 0x03FA\n\t},\n\t \n\t{\n\t\t0x0000, 0x0100, 0x0000, 0x0000,\n\t\t0x03FA, 0x00F6, 0x0010, 0x0000,\n\t\t0x03F9, 0x00DB, 0x002C, 0x0000,\n\t\t0x03FB, 0x00B3, 0x0053, 0x03FF,\n\t\t0x03FD, 0x0082, 0x0084, 0x03FD,\n\t\t0x03FF, 0x0053, 0x00B3, 0x03FB,\n\t\t0x0000, 0x002C, 0x00DB, 0x03F9,\n\t\t0x0000, 0x0010, 0x00F6, 0x03FA\n\t},\n\t \n\t#define DUMMY 0\n\t{\n\t\t0x0004, 0x0023, 0x005A, 0x0058, 0x0023, 0x0004, 0x0000, DUMMY,\n\t\t0x0002, 0x0018, 0x004d, 0x0060, 0x0031, 0x0008, 0x0000, DUMMY,\n\t\t0x0001, 0x000f, 0x003f, 0x0062, 0x003f, 0x000f, 0x0001, DUMMY,\n\t\t0x0000, 0x0008, 0x0031, 0x0060, 0x004d, 0x0018, 0x0002, DUMMY\n\t},\n\t \n\t{\n\t\t0x0004, 0x0023, 0x005A, 0x0058, 0x0023, 0x0004, 0x0000, DUMMY,\n\t\t0x0002, 0x0018, 0x004d, 0x0060, 0x0031, 0x0008, 0x0000, DUMMY,\n\t\t0x0001, 0x000f, 0x003f, 0x0062, 0x003f, 0x000f, 0x0001, DUMMY,\n\t\t0x0000, 0x0008, 0x0031, 0x0060, 0x004d, 0x0018, 0x0002, DUMMY\n\t}\n\t \n\t#undef DUMMY\n};\n\n \nstatic struct v4l2_mbus_framefmt *\n__resizer_get_format(struct isp_res_device *res,\n\t\t     struct v4l2_subdev_state *sd_state,\n\t\t     unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&res->subdev, sd_state, pad);\n\telse\n\t\treturn &res->formats[pad];\n}\n\n \nstatic struct v4l2_rect *\n__resizer_get_crop(struct isp_res_device *res,\n\t\t   struct v4l2_subdev_state *sd_state,\n\t\t   enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_crop(&res->subdev, sd_state,\n\t\t\t\t\t\tRESZ_PAD_SINK);\n\telse\n\t\treturn &res->crop.request;\n}\n\n \nstatic void resizer_set_filters(struct isp_res_device *res, const u16 *h_coeff,\n\t\t\t\tconst u16 *v_coeff)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\tu32 startaddr_h, startaddr_v, tmp_h, tmp_v;\n\tint i;\n\n\tstartaddr_h = ISPRSZ_HFILT10;\n\tstartaddr_v = ISPRSZ_VFILT10;\n\n\tfor (i = 0; i < COEFF_CNT; i += 2) {\n\t\ttmp_h = h_coeff[i] |\n\t\t\t(h_coeff[i + 1] << ISPRSZ_HFILT_COEF1_SHIFT);\n\t\ttmp_v = v_coeff[i] |\n\t\t\t(v_coeff[i + 1] << ISPRSZ_VFILT_COEF1_SHIFT);\n\t\tisp_reg_writel(isp, tmp_h, OMAP3_ISP_IOMEM_RESZ, startaddr_h);\n\t\tisp_reg_writel(isp, tmp_v, OMAP3_ISP_IOMEM_RESZ, startaddr_v);\n\t\tstartaddr_h += 4;\n\t\tstartaddr_v += 4;\n\t}\n}\n\n \nstatic void resizer_set_bilinear(struct isp_res_device *res,\n\t\t\t\t enum resizer_chroma_algo type)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\n\tif (type == RSZ_BILINEAR)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\n\t\t\t    ISPRSZ_CNT_CBILIN);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\n\t\t\t    ISPRSZ_CNT_CBILIN);\n}\n\n \nstatic void resizer_set_ycpos(struct isp_res_device *res, u32 pixelcode)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\n\tswitch (pixelcode) {\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\n\t\t\t    ISPRSZ_CNT_YCPOS);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\n\t\t\t    ISPRSZ_CNT_YCPOS);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\n \nstatic void resizer_set_phase(struct isp_res_device *res, u32 h_phase,\n\t\t\t      u32 v_phase)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\tu32 rgval;\n\n\trgval = isp_reg_readl(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT) &\n\t      ~(ISPRSZ_CNT_HSTPH_MASK | ISPRSZ_CNT_VSTPH_MASK);\n\trgval |= (h_phase << ISPRSZ_CNT_HSTPH_SHIFT) & ISPRSZ_CNT_HSTPH_MASK;\n\trgval |= (v_phase << ISPRSZ_CNT_VSTPH_SHIFT) & ISPRSZ_CNT_VSTPH_MASK;\n\n\tisp_reg_writel(isp, rgval, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT);\n}\n\n \nstatic void resizer_set_luma(struct isp_res_device *res,\n\t\t\t     struct resizer_luma_yenh *luma)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\tu32 rgval;\n\n\trgval  = (luma->algo << ISPRSZ_YENH_ALGO_SHIFT)\n\t\t  & ISPRSZ_YENH_ALGO_MASK;\n\trgval |= (luma->gain << ISPRSZ_YENH_GAIN_SHIFT)\n\t\t  & ISPRSZ_YENH_GAIN_MASK;\n\trgval |= (luma->slope << ISPRSZ_YENH_SLOP_SHIFT)\n\t\t  & ISPRSZ_YENH_SLOP_MASK;\n\trgval |= (luma->core << ISPRSZ_YENH_CORE_SHIFT)\n\t\t  & ISPRSZ_YENH_CORE_MASK;\n\n\tisp_reg_writel(isp, rgval, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_YENH);\n}\n\n \nstatic void resizer_set_source(struct isp_res_device *res,\n\t\t\t       enum resizer_input_entity source)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\n\tif (source == RESIZER_INPUT_MEMORY)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\n\t\t\t    ISPRSZ_CNT_INPSRC);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\n\t\t\t    ISPRSZ_CNT_INPSRC);\n}\n\n \nstatic void resizer_set_ratio(struct isp_res_device *res,\n\t\t\t      const struct resizer_ratio *ratio)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\tconst u16 *h_filter, *v_filter;\n\tu32 rgval;\n\n\trgval = isp_reg_readl(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT) &\n\t\t\t      ~(ISPRSZ_CNT_HRSZ_MASK | ISPRSZ_CNT_VRSZ_MASK);\n\trgval |= ((ratio->horz - 1) << ISPRSZ_CNT_HRSZ_SHIFT)\n\t\t  & ISPRSZ_CNT_HRSZ_MASK;\n\trgval |= ((ratio->vert - 1) << ISPRSZ_CNT_VRSZ_SHIFT)\n\t\t  & ISPRSZ_CNT_VRSZ_MASK;\n\tisp_reg_writel(isp, rgval, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT);\n\n\t \n\tif (ratio->horz > MID_RESIZE_VALUE)\n\t\th_filter = &filter_coefs.h_filter_coef_7tap[0];\n\telse\n\t\th_filter = &filter_coefs.h_filter_coef_4tap[0];\n\n\t \n\tif (ratio->vert > MID_RESIZE_VALUE)\n\t\tv_filter = &filter_coefs.v_filter_coef_7tap[0];\n\telse\n\t\tv_filter = &filter_coefs.v_filter_coef_4tap[0];\n\n\tresizer_set_filters(res, h_filter, v_filter);\n}\n\n \nstatic void resizer_set_output_size(struct isp_res_device *res,\n\t\t\t\t    u32 width, u32 height)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\tu32 rgval;\n\n\trgval  = (width << ISPRSZ_OUT_SIZE_HORZ_SHIFT)\n\t\t & ISPRSZ_OUT_SIZE_HORZ_MASK;\n\trgval |= (height << ISPRSZ_OUT_SIZE_VERT_SHIFT)\n\t\t & ISPRSZ_OUT_SIZE_VERT_MASK;\n\tisp_reg_writel(isp, rgval, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_OUT_SIZE);\n}\n\n \nstatic void resizer_set_output_offset(struct isp_res_device *res, u32 offset)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\n\tisp_reg_writel(isp, offset, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTOFF);\n}\n\n \nstatic void resizer_set_start(struct isp_res_device *res, u32 left, u32 top)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\tu32 rgval;\n\n\trgval = (left << ISPRSZ_IN_START_HORZ_ST_SHIFT)\n\t\t& ISPRSZ_IN_START_HORZ_ST_MASK;\n\trgval |= (top << ISPRSZ_IN_START_VERT_ST_SHIFT)\n\t\t & ISPRSZ_IN_START_VERT_ST_MASK;\n\n\tisp_reg_writel(isp, rgval, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_START);\n}\n\n \nstatic void resizer_set_input_size(struct isp_res_device *res,\n\t\t\t\t   u32 width, u32 height)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\tu32 rgval;\n\n\trgval = (width << ISPRSZ_IN_SIZE_HORZ_SHIFT)\n\t\t& ISPRSZ_IN_SIZE_HORZ_MASK;\n\trgval |= (height << ISPRSZ_IN_SIZE_VERT_SHIFT)\n\t\t & ISPRSZ_IN_SIZE_VERT_MASK;\n\n\tisp_reg_writel(isp, rgval, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_SIZE);\n}\n\n \nstatic void resizer_set_input_offset(struct isp_res_device *res, u32 offset)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\n\tisp_reg_writel(isp, offset, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INOFF);\n}\n\n \nstatic void resizer_set_intype(struct isp_res_device *res,\n\t\t\t       enum resizer_colors_type type)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\n\tif (type == RSZ_COLOR8)\n\t\tisp_reg_set(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\n\t\t\t    ISPRSZ_CNT_INPTYP);\n\telse\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\n\t\t\t    ISPRSZ_CNT_INPTYP);\n}\n\n \nstatic void __resizer_set_inaddr(struct isp_res_device *res, u32 addr)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\n\tisp_reg_writel(isp, addr, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INADD);\n}\n\n \nvoid omap3isp_resizer_max_rate(struct isp_res_device *res,\n\t\t\t       unsigned int *max_rate)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&res->subdev.entity);\n\tconst struct v4l2_mbus_framefmt *ofmt = &res->formats[RESZ_PAD_SOURCE];\n\tunsigned long limit = min(pipe->l3_ick, 200000000UL);\n\tunsigned long clock;\n\n\tclock = div_u64((u64)limit * res->crop.active.height, ofmt->height);\n\tclock = min(clock, limit / 2);\n\t*max_rate = div_u64((u64)clock * res->crop.active.width, ofmt->width);\n}\n\n \nstatic void resizer_adjust_bandwidth(struct isp_res_device *res)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&res->subdev.entity);\n\tstruct isp_device *isp = to_isp_device(res);\n\tunsigned long l3_ick = pipe->l3_ick;\n\tstruct v4l2_fract *timeperframe;\n\tunsigned int cycles_per_frame;\n\tunsigned int requests_per_frame;\n\tunsigned int cycles_per_request;\n\tunsigned int granularity;\n\tunsigned int minimum;\n\tunsigned int maximum;\n\tunsigned int value;\n\n\tif (res->input != RESIZER_INPUT_MEMORY) {\n\t\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_SDR_REQ_EXP,\n\t\t\t    ISPSBL_SDR_REQ_RSZ_EXP_MASK);\n\t\treturn;\n\t}\n\n\tswitch (isp->revision) {\n\tcase ISP_REVISION_1_0:\n\tcase ISP_REVISION_2_0:\n\tdefault:\n\t\tgranularity = 1024;\n\t\tbreak;\n\n\tcase ISP_REVISION_15_0:\n\t\tgranularity = 32;\n\t\tbreak;\n\t}\n\n\t \n\tcycles_per_request = div_u64((u64)l3_ick / 2 * 256 + pipe->max_rate - 1,\n\t\t\t\t     pipe->max_rate);\n\tminimum = DIV_ROUND_UP(cycles_per_request, granularity);\n\n\t \n\ttimeperframe = &pipe->max_timeperframe;\n\n\trequests_per_frame = DIV_ROUND_UP(res->crop.active.width * 2, 256)\n\t\t\t   * res->crop.active.height;\n\tcycles_per_frame = div_u64((u64)l3_ick * timeperframe->numerator,\n\t\t\t\t   timeperframe->denominator);\n\tcycles_per_request = cycles_per_frame / requests_per_frame;\n\n\tmaximum = cycles_per_request / granularity;\n\n\tvalue = max(minimum, maximum);\n\n\tdev_dbg(isp->dev, \"%s: cycles per request = %u\\n\", __func__, value);\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_SDR_REQ_EXP,\n\t\t\tISPSBL_SDR_REQ_RSZ_EXP_MASK,\n\t\t\tvalue << ISPSBL_SDR_REQ_RSZ_EXP_SHIFT);\n}\n\n \nint omap3isp_resizer_busy(struct isp_res_device *res)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\n\treturn isp_reg_readl(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR) &\n\t\t\t     ISPRSZ_PCR_BUSY;\n}\n\n \nstatic void resizer_set_inaddr(struct isp_res_device *res, u32 addr)\n{\n\tres->addr_base = addr;\n\n\t \n\tif (res->crop_offset)\n\t\taddr += res->crop_offset & ~0x1f;\n\n\t__resizer_set_inaddr(res, addr);\n}\n\n \nstatic void resizer_set_outaddr(struct isp_res_device *res, u32 addr)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\n\t \n\tisp_reg_writel(isp, addr << ISPRSZ_SDR_OUTADD_ADDR_SHIFT,\n\t\t       OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTADD);\n}\n\n \n#define RSZ_PRINT_REGISTER(isp, name)\\\n\tdev_dbg(isp->dev, \"###RSZ \" #name \"=0x%08x\\n\", \\\n\t\tisp_reg_readl(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_##name))\n\nstatic void resizer_print_status(struct isp_res_device *res)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\n\tdev_dbg(isp->dev, \"-------------Resizer Register dump----------\\n\");\n\n\tRSZ_PRINT_REGISTER(isp, PCR);\n\tRSZ_PRINT_REGISTER(isp, CNT);\n\tRSZ_PRINT_REGISTER(isp, OUT_SIZE);\n\tRSZ_PRINT_REGISTER(isp, IN_START);\n\tRSZ_PRINT_REGISTER(isp, IN_SIZE);\n\tRSZ_PRINT_REGISTER(isp, SDR_INADD);\n\tRSZ_PRINT_REGISTER(isp, SDR_INOFF);\n\tRSZ_PRINT_REGISTER(isp, SDR_OUTADD);\n\tRSZ_PRINT_REGISTER(isp, SDR_OUTOFF);\n\tRSZ_PRINT_REGISTER(isp, YENH);\n\n\tdev_dbg(isp->dev, \"--------------------------------------------\\n\");\n}\n\n \nstatic void resizer_calc_ratios(struct isp_res_device *res,\n\t\t\t\tstruct v4l2_rect *input,\n\t\t\t\tstruct v4l2_mbus_framefmt *output,\n\t\t\t\tstruct resizer_ratio *ratio)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\tconst unsigned int spv = DEFAULT_PHASE;\n\tconst unsigned int sph = DEFAULT_PHASE;\n\tunsigned int upscaled_width;\n\tunsigned int upscaled_height;\n\tunsigned int min_width;\n\tunsigned int min_height;\n\tunsigned int max_width;\n\tunsigned int max_height;\n\tunsigned int width_alignment;\n\tunsigned int width;\n\tunsigned int height;\n\n\t \n\tmin_height = ((input->height - 7) * 256 - 32 - 64 * spv) / 1024 + 1;\n\tmin_height = max_t(unsigned int, min_height, MIN_OUT_HEIGHT);\n\tmax_height = ((input->height - 4) * 256 + 255 - 16 - 32 * spv) / 64 + 1;\n\tmax_height = min_t(unsigned int, max_height, MAX_OUT_HEIGHT);\n\toutput->height = clamp(output->height, min_height, max_height);\n\n\tratio->vert = ((input->height - 4) * 256 + 255 - 16 - 32 * spv)\n\t\t    / (output->height - 1);\n\tif (ratio->vert > MID_RESIZE_VALUE)\n\t\tratio->vert = ((input->height - 7) * 256 + 255 - 32 - 64 * spv)\n\t\t\t    / (output->height - 1);\n\tratio->vert = clamp_t(unsigned int, ratio->vert,\n\t\t\t      MIN_RESIZE_VALUE, MAX_RESIZE_VALUE);\n\n\tif (ratio->vert <= MID_RESIZE_VALUE) {\n\t\tupscaled_height = (output->height - 1) * ratio->vert\n\t\t\t\t+ 32 * spv + 16;\n\t\theight = (upscaled_height >> 8) + 4;\n\t} else {\n\t\tupscaled_height = (output->height - 1) * ratio->vert\n\t\t\t\t+ 64 * spv + 32;\n\t\theight = (upscaled_height >> 8) + 7;\n\t}\n\n\t \n\tmin_width = ((input->width - 7) * 256 - 32 - 64 * sph) / 1024 + 1;\n\tmin_width = max_t(unsigned int, min_width, MIN_OUT_WIDTH);\n\n\tif (ratio->vert <= MID_RESIZE_VALUE) {\n\t\tswitch (isp->revision) {\n\t\tcase ISP_REVISION_1_0:\n\t\t\tmax_width = MAX_4TAP_OUT_WIDTH_ES1;\n\t\t\tbreak;\n\n\t\tcase ISP_REVISION_2_0:\n\t\tdefault:\n\t\t\tmax_width = MAX_4TAP_OUT_WIDTH_ES2;\n\t\t\tbreak;\n\n\t\tcase ISP_REVISION_15_0:\n\t\t\tmax_width = MAX_4TAP_OUT_WIDTH_3630;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (isp->revision) {\n\t\tcase ISP_REVISION_1_0:\n\t\t\tmax_width = MAX_7TAP_OUT_WIDTH_ES1;\n\t\t\tbreak;\n\n\t\tcase ISP_REVISION_2_0:\n\t\tdefault:\n\t\t\tmax_width = MAX_7TAP_OUT_WIDTH_ES2;\n\t\t\tbreak;\n\n\t\tcase ISP_REVISION_15_0:\n\t\t\tmax_width = MAX_7TAP_OUT_WIDTH_3630;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmax_width = min(((input->width - 7) * 256 + 255 - 16 - 32 * sph) / 64\n\t\t\t+ 1, max_width);\n\n\t \n\twidth_alignment = ratio->vert < 256 ? 8 : 2;\n\toutput->width = clamp(output->width, min_width,\n\t\t\t      max_width & ~(width_alignment - 1));\n\toutput->width = ALIGN(output->width, width_alignment);\n\n\tratio->horz = ((input->width - 7) * 256 + 255 - 16 - 32 * sph)\n\t\t    / (output->width - 1);\n\tif (ratio->horz > MID_RESIZE_VALUE)\n\t\tratio->horz = ((input->width - 7) * 256 + 255 - 32 - 64 * sph)\n\t\t\t    / (output->width - 1);\n\tratio->horz = clamp_t(unsigned int, ratio->horz,\n\t\t\t      MIN_RESIZE_VALUE, MAX_RESIZE_VALUE);\n\n\tif (ratio->horz <= MID_RESIZE_VALUE) {\n\t\tupscaled_width = (output->width - 1) * ratio->horz\n\t\t\t       + 32 * sph + 16;\n\t\twidth = (upscaled_width >> 8) + 7;\n\t} else {\n\t\tupscaled_width = (output->width - 1) * ratio->horz\n\t\t\t       + 64 * sph + 32;\n\t\twidth = (upscaled_width >> 8) + 7;\n\t}\n\n\t \n\tinput->left += (input->width - width) / 2;\n\tinput->top += (input->height - height) / 2;\n\tinput->width = width;\n\tinput->height = height;\n}\n\n \nstatic void resizer_set_crop_params(struct isp_res_device *res,\n\t\t\t\t    const struct v4l2_mbus_framefmt *input,\n\t\t\t\t    const struct v4l2_mbus_framefmt *output)\n{\n\tresizer_set_ratio(res, &res->ratio);\n\n\t \n\tif (res->ratio.horz >= RESIZE_DIVISOR)\n\t\tresizer_set_bilinear(res, RSZ_THE_SAME);\n\telse\n\t\tresizer_set_bilinear(res, RSZ_BILINEAR);\n\n\tresizer_adjust_bandwidth(res);\n\n\tif (res->input == RESIZER_INPUT_MEMORY) {\n\t\t \n\t\tres->crop_offset = (res->crop.active.top * input->width +\n\t\t\t\t    res->crop.active.left) * 2;\n\t\t \n\t\tresizer_set_start(res, (res->crop_offset / 2) & 0xf, 0);\n\n\t\t \n\t\t__resizer_set_inaddr(res,\n\t\t\t\tres->addr_base + (res->crop_offset & ~0x1f));\n\t} else {\n\t\t \n\t\tresizer_set_start(res, res->crop.active.left * 2,\n\t\t\t\t  res->crop.active.top);\n\t\t \n\t\t__resizer_set_inaddr(res, 0);\n\t\tresizer_set_input_offset(res, 0);\n\t}\n\n\t \n\tresizer_set_input_size(res, res->crop.active.width,\n\t\t\t       res->crop.active.height);\n}\n\nstatic void resizer_configure(struct isp_res_device *res)\n{\n\tstruct v4l2_mbus_framefmt *informat, *outformat;\n\tstruct resizer_luma_yenh luma = {0, 0, 0, 0};\n\n\tresizer_set_source(res, res->input);\n\n\tinformat = &res->formats[RESZ_PAD_SINK];\n\toutformat = &res->formats[RESZ_PAD_SOURCE];\n\n\t \n\tif (res->input == RESIZER_INPUT_VP)\n\t\tresizer_set_input_offset(res, 0);\n\telse\n\t\tresizer_set_input_offset(res, ALIGN(informat->width, 0x10) * 2);\n\n\t \n\tresizer_set_intype(res, RSZ_YUV422);\n\tresizer_set_ycpos(res, informat->code);\n\tresizer_set_phase(res, DEFAULT_PHASE, DEFAULT_PHASE);\n\tresizer_set_luma(res, &luma);\n\n\t \n\tresizer_set_output_offset(res, ALIGN(outformat->width * 2, 32));\n\tresizer_set_output_size(res, outformat->width, outformat->height);\n\n\tresizer_set_crop_params(res, informat, outformat);\n}\n\n \n\nstatic void resizer_enable_oneshot(struct isp_res_device *res)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\n\tisp_reg_set(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR,\n\t\t    ISPRSZ_PCR_ENABLE | ISPRSZ_PCR_ONESHOT);\n}\n\nvoid omap3isp_resizer_isr_frame_sync(struct isp_res_device *res)\n{\n\t \n\tif (res->state == ISP_PIPELINE_STREAM_CONTINUOUS &&\n\t    res->video_out.dmaqueue_flags & ISP_VIDEO_DMAQUEUE_QUEUED) {\n\t\tresizer_enable_oneshot(res);\n\t\tisp_video_dmaqueue_flags_clr(&res->video_out);\n\t}\n}\n\nstatic void resizer_isr_buffer(struct isp_res_device *res)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&res->subdev.entity);\n\tstruct isp_buffer *buffer;\n\tint restart = 0;\n\n\tif (res->state == ISP_PIPELINE_STREAM_STOPPED)\n\t\treturn;\n\n\t \n\tbuffer = omap3isp_video_buffer_next(&res->video_out);\n\tif (buffer != NULL) {\n\t\tresizer_set_outaddr(res, buffer->dma);\n\t\trestart = 1;\n\t}\n\n\tpipe->state |= ISP_PIPELINE_IDLE_OUTPUT;\n\n\tif (res->input == RESIZER_INPUT_MEMORY) {\n\t\tbuffer = omap3isp_video_buffer_next(&res->video_in);\n\t\tif (buffer != NULL)\n\t\t\tresizer_set_inaddr(res, buffer->dma);\n\t\tpipe->state |= ISP_PIPELINE_IDLE_INPUT;\n\t}\n\n\tif (res->state == ISP_PIPELINE_STREAM_SINGLESHOT) {\n\t\tif (isp_pipeline_ready(pipe))\n\t\t\tomap3isp_pipeline_set_stream(pipe,\n\t\t\t\t\t\tISP_PIPELINE_STREAM_SINGLESHOT);\n\t} else {\n\t\t \n\t\tif (restart)\n\t\t\tresizer_enable_oneshot(res);\n\t}\n}\n\n \nvoid omap3isp_resizer_isr(struct isp_res_device *res)\n{\n\tstruct v4l2_mbus_framefmt *informat, *outformat;\n\tunsigned long flags;\n\n\tif (omap3isp_module_sync_is_stopping(&res->wait, &res->stopping))\n\t\treturn;\n\n\tspin_lock_irqsave(&res->lock, flags);\n\n\tif (res->applycrop) {\n\t\toutformat = __resizer_get_format(res, NULL, RESZ_PAD_SOURCE,\n\t\t\t\t\t      V4L2_SUBDEV_FORMAT_ACTIVE);\n\t\tinformat = __resizer_get_format(res, NULL, RESZ_PAD_SINK,\n\t\t\t\t\t      V4L2_SUBDEV_FORMAT_ACTIVE);\n\t\tresizer_set_crop_params(res, informat, outformat);\n\t\tres->applycrop = 0;\n\t}\n\n\tspin_unlock_irqrestore(&res->lock, flags);\n\n\tresizer_isr_buffer(res);\n}\n\n \n\nstatic int resizer_video_queue(struct isp_video *video,\n\t\t\t       struct isp_buffer *buffer)\n{\n\tstruct isp_res_device *res = &video->isp->isp_res;\n\n\tif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tresizer_set_inaddr(res, buffer->dma);\n\n\t \n\tif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tresizer_set_outaddr(res, buffer->dma);\n\n\treturn 0;\n}\n\nstatic const struct isp_video_operations resizer_video_ops = {\n\t.queue = resizer_video_queue,\n};\n\n \n\n \nstatic int resizer_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct isp_res_device *res = v4l2_get_subdevdata(sd);\n\tstruct isp_video *video_out = &res->video_out;\n\tstruct isp_device *isp = to_isp_device(res);\n\tstruct device *dev = to_device(res);\n\n\tif (res->state == ISP_PIPELINE_STREAM_STOPPED) {\n\t\tif (enable == ISP_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\n\t\tomap3isp_subclk_enable(isp, OMAP3_ISP_SUBCLK_RESIZER);\n\t\tresizer_configure(res);\n\t\tresizer_print_status(res);\n\t}\n\n\tswitch (enable) {\n\tcase ISP_PIPELINE_STREAM_CONTINUOUS:\n\t\tomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_RESIZER_WRITE);\n\t\tif (video_out->dmaqueue_flags & ISP_VIDEO_DMAQUEUE_QUEUED) {\n\t\t\tresizer_enable_oneshot(res);\n\t\t\tisp_video_dmaqueue_flags_clr(video_out);\n\t\t}\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_SINGLESHOT:\n\t\tif (res->input == RESIZER_INPUT_MEMORY)\n\t\t\tomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_RESIZER_READ);\n\t\tomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_RESIZER_WRITE);\n\n\t\tresizer_enable_oneshot(res);\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_STOPPED:\n\t\tif (omap3isp_module_sync_idle(&sd->entity, &res->wait,\n\t\t\t\t\t      &res->stopping))\n\t\t\tdev_dbg(dev, \"%s: module stop timeout.\\n\", sd->name);\n\t\tomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_RESIZER_READ |\n\t\t\t\tOMAP3_ISP_SBL_RESIZER_WRITE);\n\t\tomap3isp_subclk_disable(isp, OMAP3_ISP_SUBCLK_RESIZER);\n\t\tisp_video_dmaqueue_flags_clr(video_out);\n\t\tbreak;\n\t}\n\n\tres->state = enable;\n\treturn 0;\n}\n\n \nstatic void resizer_try_crop(const struct v4l2_mbus_framefmt *sink,\n\t\t\t     const struct v4l2_mbus_framefmt *source,\n\t\t\t     struct v4l2_rect *crop)\n{\n\tconst unsigned int spv = DEFAULT_PHASE;\n\tconst unsigned int sph = DEFAULT_PHASE;\n\n\t \n\tunsigned int min_width =\n\t\t((32 * sph + (source->width - 1) * 64 + 16) >> 8) + 7;\n\tunsigned int min_height =\n\t\t((32 * spv + (source->height - 1) * 64 + 16) >> 8) + 4;\n\tunsigned int max_width =\n\t\t((64 * sph + (source->width - 1) * 1024 + 32) >> 8) + 7;\n\tunsigned int max_height =\n\t\t((64 * spv + (source->height - 1) * 1024 + 32) >> 8) + 7;\n\n\tcrop->width = clamp_t(u32, crop->width, min_width, max_width);\n\tcrop->height = clamp_t(u32, crop->height, min_height, max_height);\n\n\t \n\tcrop->left = clamp_t(u32, crop->left, 0, sink->width - MIN_IN_WIDTH);\n\tcrop->width = clamp_t(u32, crop->width, MIN_IN_WIDTH,\n\t\t\t      sink->width - crop->left);\n\tcrop->top = clamp_t(u32, crop->top, 0, sink->height - MIN_IN_HEIGHT);\n\tcrop->height = clamp_t(u32, crop->height, MIN_IN_HEIGHT,\n\t\t\t       sink->height - crop->top);\n}\n\n \nstatic int resizer_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct isp_res_device *res = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format_source;\n\tstruct v4l2_mbus_framefmt *format_sink;\n\tstruct resizer_ratio ratio;\n\n\tif (sel->pad != RESZ_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tformat_sink = __resizer_get_format(res, sd_state, RESZ_PAD_SINK,\n\t\t\t\t\t   sel->which);\n\tformat_source = __resizer_get_format(res, sd_state, RESZ_PAD_SOURCE,\n\t\t\t\t\t     sel->which);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = INT_MAX;\n\t\tsel->r.height = INT_MAX;\n\n\t\tresizer_try_crop(format_sink, format_source, &sel->r);\n\t\tresizer_calc_ratios(res, &sel->r, format_source, &ratio);\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *__resizer_get_crop(res, sd_state, sel->which);\n\t\tresizer_calc_ratios(res, &sel->r, format_source, &ratio);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int resizer_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_selection *sel)\n{\n\tstruct isp_res_device *res = v4l2_get_subdevdata(sd);\n\tstruct isp_device *isp = to_isp_device(res);\n\tconst struct v4l2_mbus_framefmt *format_sink;\n\tstruct v4l2_mbus_framefmt format_source;\n\tstruct resizer_ratio ratio;\n\tunsigned long flags;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP ||\n\t    sel->pad != RESZ_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tformat_sink = __resizer_get_format(res, sd_state, RESZ_PAD_SINK,\n\t\t\t\t\t   sel->which);\n\tformat_source = *__resizer_get_format(res, sd_state, RESZ_PAD_SOURCE,\n\t\t\t\t\t      sel->which);\n\n\tdev_dbg(isp->dev, \"%s(%s): req %ux%u -> (%d,%d)/%ux%u -> %ux%u\\n\",\n\t\t__func__, sel->which == V4L2_SUBDEV_FORMAT_TRY ? \"try\" : \"act\",\n\t\tformat_sink->width, format_sink->height,\n\t\tsel->r.left, sel->r.top, sel->r.width, sel->r.height,\n\t\tformat_source.width, format_source.height);\n\n\t \n\tresizer_try_crop(format_sink, &format_source, &sel->r);\n\t*__resizer_get_crop(res, sd_state, sel->which) = sel->r;\n\tresizer_calc_ratios(res, &sel->r, &format_source, &ratio);\n\n\tdev_dbg(isp->dev, \"%s(%s): got %ux%u -> (%d,%d)/%ux%u -> %ux%u\\n\",\n\t\t__func__, sel->which == V4L2_SUBDEV_FORMAT_TRY ? \"try\" : \"act\",\n\t\tformat_sink->width, format_sink->height,\n\t\tsel->r.left, sel->r.top, sel->r.width, sel->r.height,\n\t\tformat_source.width, format_source.height);\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t*__resizer_get_format(res, sd_state, RESZ_PAD_SOURCE,\n\t\t\t\t      sel->which) =\n\t\t\tformat_source;\n\t\treturn 0;\n\t}\n\n\t \n\tspin_lock_irqsave(&res->lock, flags);\n\n\t*__resizer_get_format(res, sd_state, RESZ_PAD_SOURCE, sel->which) =\n\t\tformat_source;\n\n\tres->ratio = ratio;\n\tres->crop.active = sel->r;\n\n\tif (res->state != ISP_PIPELINE_STREAM_STOPPED)\n\t\tres->applycrop = 1;\n\n\tspin_unlock_irqrestore(&res->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic const unsigned int resizer_formats[] = {\n\tMEDIA_BUS_FMT_UYVY8_1X16,\n\tMEDIA_BUS_FMT_YUYV8_1X16,\n};\n\nstatic unsigned int resizer_max_in_width(struct isp_res_device *res)\n{\n\tstruct isp_device *isp = to_isp_device(res);\n\n\tif (res->input == RESIZER_INPUT_MEMORY) {\n\t\treturn MAX_IN_WIDTH_MEMORY_MODE;\n\t} else {\n\t\tif (isp->revision == ISP_REVISION_1_0)\n\t\t\treturn MAX_IN_WIDTH_ONTHEFLY_MODE_ES1;\n\t\telse\n\t\t\treturn MAX_IN_WIDTH_ONTHEFLY_MODE_ES2;\n\t}\n}\n\n \nstatic void resizer_try_format(struct isp_res_device *res,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       unsigned int pad,\n\t\t\t       struct v4l2_mbus_framefmt *fmt,\n\t\t\t       enum v4l2_subdev_format_whence which)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct resizer_ratio ratio;\n\tstruct v4l2_rect crop;\n\n\tswitch (pad) {\n\tcase RESZ_PAD_SINK:\n\t\tif (fmt->code != MEDIA_BUS_FMT_YUYV8_1X16 &&\n\t\t    fmt->code != MEDIA_BUS_FMT_UYVY8_1X16)\n\t\t\tfmt->code = MEDIA_BUS_FMT_YUYV8_1X16;\n\n\t\tfmt->width = clamp_t(u32, fmt->width, MIN_IN_WIDTH,\n\t\t\t\t     resizer_max_in_width(res));\n\t\tfmt->height = clamp_t(u32, fmt->height, MIN_IN_HEIGHT,\n\t\t\t\t      MAX_IN_HEIGHT);\n\t\tbreak;\n\n\tcase RESZ_PAD_SOURCE:\n\t\tformat = __resizer_get_format(res, sd_state, RESZ_PAD_SINK,\n\t\t\t\t\t      which);\n\t\tfmt->code = format->code;\n\n\t\tcrop = *__resizer_get_crop(res, sd_state, which);\n\t\tresizer_calc_ratios(res, &crop, fmt, &ratio);\n\t\tbreak;\n\t}\n\n\tfmt->colorspace = V4L2_COLORSPACE_JPEG;\n\tfmt->field = V4L2_FIELD_NONE;\n}\n\n \nstatic int resizer_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct isp_res_device *res = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tif (code->pad == RESZ_PAD_SINK) {\n\t\tif (code->index >= ARRAY_SIZE(resizer_formats))\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = resizer_formats[code->index];\n\t} else {\n\t\tif (code->index != 0)\n\t\t\treturn -EINVAL;\n\n\t\tformat = __resizer_get_format(res, sd_state, RESZ_PAD_SINK,\n\t\t\t\t\t      code->which);\n\t\tcode->code = format->code;\n\t}\n\n\treturn 0;\n}\n\nstatic int resizer_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct isp_res_device *res = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tresizer_try_format(res, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tresizer_try_format(res, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int resizer_get_format(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct isp_res_device *res = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __resizer_get_format(res, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\treturn 0;\n}\n\n \nstatic int resizer_set_format(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct isp_res_device *res = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *crop;\n\n\tformat = __resizer_get_format(res, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tresizer_try_format(res, sd_state, fmt->pad, &fmt->format, fmt->which);\n\t*format = fmt->format;\n\n\tif (fmt->pad == RESZ_PAD_SINK) {\n\t\t \n\t\tcrop = __resizer_get_crop(res, sd_state, fmt->which);\n\t\tcrop->left = 0;\n\t\tcrop->top = 0;\n\t\tcrop->width = fmt->format.width;\n\t\tcrop->height = fmt->format.height;\n\n\t\t \n\t\tformat = __resizer_get_format(res, sd_state, RESZ_PAD_SOURCE,\n\t\t\t\t\t      fmt->which);\n\t\t*format = fmt->format;\n\t\tresizer_try_format(res, sd_state, RESZ_PAD_SOURCE, format,\n\t\t\t\t   fmt->which);\n\t}\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\n\t\t \n\t\tres->crop.active = res->crop.request;\n\t\tresizer_calc_ratios(res, &res->crop.active, format,\n\t\t\t\t       &res->ratio);\n\t}\n\n\treturn 0;\n}\n\nstatic int resizer_link_validate(struct v4l2_subdev *sd,\n\t\t\t\t struct media_link *link,\n\t\t\t\t struct v4l2_subdev_format *source_fmt,\n\t\t\t\t struct v4l2_subdev_format *sink_fmt)\n{\n\tstruct isp_res_device *res = v4l2_get_subdevdata(sd);\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&sd->entity);\n\n\tomap3isp_resizer_max_rate(res, &pipe->max_rate);\n\n\treturn v4l2_subdev_link_validate_default(sd, link,\n\t\t\t\t\t\t source_fmt, sink_fmt);\n}\n\n \nstatic int resizer_init_formats(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format;\n\n\tmemset(&format, 0, sizeof(format));\n\tformat.pad = RESZ_PAD_SINK;\n\tformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\n\tformat.format.code = MEDIA_BUS_FMT_YUYV8_1X16;\n\tformat.format.width = 4096;\n\tformat.format.height = 4096;\n\tresizer_set_format(sd, fh ? fh->state : NULL, &format);\n\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_video_ops resizer_v4l2_video_ops = {\n\t.s_stream = resizer_set_stream,\n};\n\n \nstatic const struct v4l2_subdev_pad_ops resizer_v4l2_pad_ops = {\n\t.enum_mbus_code = resizer_enum_mbus_code,\n\t.enum_frame_size = resizer_enum_frame_size,\n\t.get_fmt = resizer_get_format,\n\t.set_fmt = resizer_set_format,\n\t.get_selection = resizer_get_selection,\n\t.set_selection = resizer_set_selection,\n\t.link_validate = resizer_link_validate,\n};\n\n \nstatic const struct v4l2_subdev_ops resizer_v4l2_ops = {\n\t.video = &resizer_v4l2_video_ops,\n\t.pad = &resizer_v4l2_pad_ops,\n};\n\n \nstatic const struct v4l2_subdev_internal_ops resizer_v4l2_internal_ops = {\n\t.open = resizer_init_formats,\n};\n\n \n\n \nstatic int resizer_link_setup(struct media_entity *entity,\n\t\t\t      const struct media_pad *local,\n\t\t\t      const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct isp_res_device *res = v4l2_get_subdevdata(sd);\n\tunsigned int index = local->index;\n\n\t \n\tif (is_media_entity_v4l2_subdev(remote->entity))\n\t\tindex |= 2 << 16;\n\n\tswitch (index) {\n\tcase RESZ_PAD_SINK:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (res->input == RESIZER_INPUT_VP)\n\t\t\t\treturn -EBUSY;\n\t\t\tres->input = RESIZER_INPUT_MEMORY;\n\t\t} else {\n\t\t\tif (res->input == RESIZER_INPUT_MEMORY)\n\t\t\t\tres->input = RESIZER_INPUT_NONE;\n\t\t}\n\t\tbreak;\n\n\tcase RESZ_PAD_SINK | 2 << 16:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (res->input == RESIZER_INPUT_MEMORY)\n\t\t\t\treturn -EBUSY;\n\t\t\tres->input = RESIZER_INPUT_VP;\n\t\t} else {\n\t\t\tif (res->input == RESIZER_INPUT_VP)\n\t\t\t\tres->input = RESIZER_INPUT_NONE;\n\t\t}\n\t\tbreak;\n\n\tcase RESZ_PAD_SOURCE:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct media_entity_operations resizer_media_ops = {\n\t.link_setup = resizer_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nvoid omap3isp_resizer_unregister_entities(struct isp_res_device *res)\n{\n\tv4l2_device_unregister_subdev(&res->subdev);\n\tomap3isp_video_unregister(&res->video_in);\n\tomap3isp_video_unregister(&res->video_out);\n}\n\nint omap3isp_resizer_register_entities(struct isp_res_device *res,\n\t\t\t\t       struct v4l2_device *vdev)\n{\n\tint ret;\n\n\t \n\tres->subdev.dev = vdev->mdev->dev;\n\tret = v4l2_device_register_subdev(vdev, &res->subdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = omap3isp_video_register(&res->video_in, vdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = omap3isp_video_register(&res->video_out, vdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tomap3isp_resizer_unregister_entities(res);\n\treturn ret;\n}\n\n \n\n \nstatic int resizer_init_entities(struct isp_res_device *res)\n{\n\tstruct v4l2_subdev *sd = &res->subdev;\n\tstruct media_pad *pads = res->pads;\n\tstruct media_entity *me = &sd->entity;\n\tint ret;\n\n\tres->input = RESIZER_INPUT_NONE;\n\n\tv4l2_subdev_init(sd, &resizer_v4l2_ops);\n\tsd->internal_ops = &resizer_v4l2_internal_ops;\n\tstrscpy(sd->name, \"OMAP3 ISP resizer\", sizeof(sd->name));\n\tsd->grp_id = 1 << 16;\t \n\tv4l2_set_subdevdata(sd, res);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tpads[RESZ_PAD_SINK].flags = MEDIA_PAD_FL_SINK\n\t\t\t\t    | MEDIA_PAD_FL_MUST_CONNECT;\n\tpads[RESZ_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\tme->ops = &resizer_media_ops;\n\tret = media_entity_pads_init(me, RESZ_PADS_NUM, pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tresizer_init_formats(sd, NULL);\n\n\tres->video_in.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tres->video_in.ops = &resizer_video_ops;\n\tres->video_in.isp = to_isp_device(res);\n\tres->video_in.capture_mem = PAGE_ALIGN(4096 * 4096) * 2 * 3;\n\tres->video_in.bpl_alignment = 32;\n\tres->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tres->video_out.ops = &resizer_video_ops;\n\tres->video_out.isp = to_isp_device(res);\n\tres->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 2 * 3;\n\tres->video_out.bpl_alignment = 32;\n\n\tret = omap3isp_video_init(&res->video_in, \"resizer\");\n\tif (ret < 0)\n\t\tgoto error_video_in;\n\n\tret = omap3isp_video_init(&res->video_out, \"resizer\");\n\tif (ret < 0)\n\t\tgoto error_video_out;\n\n\tres->video_out.video.entity.flags |= MEDIA_ENT_FL_DEFAULT;\n\n\treturn 0;\n\nerror_video_out:\n\tomap3isp_video_cleanup(&res->video_in);\nerror_video_in:\n\tmedia_entity_cleanup(&res->subdev.entity);\n\treturn ret;\n}\n\n \nint omap3isp_resizer_init(struct isp_device *isp)\n{\n\tstruct isp_res_device *res = &isp->isp_res;\n\n\tinit_waitqueue_head(&res->wait);\n\tatomic_set(&res->stopping, 0);\n\tspin_lock_init(&res->lock);\n\n\treturn resizer_init_entities(res);\n}\n\nvoid omap3isp_resizer_cleanup(struct isp_device *isp)\n{\n\tstruct isp_res_device *res = &isp->isp_res;\n\n\tomap3isp_video_cleanup(&res->video_in);\n\tomap3isp_video_cleanup(&res->video_out);\n\tmedia_entity_cleanup(&res->subdev.entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}