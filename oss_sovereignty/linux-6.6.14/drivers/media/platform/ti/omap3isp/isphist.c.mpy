{
  "module_name": "isphist.c",
  "hash_id": "285b8633a78e645220362478ab8ee3634aa3629f10c854d77410cc08eb8acef1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap3isp/isphist.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dmaengine.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include \"isp.h\"\n#include \"ispreg.h\"\n#include \"isphist.h\"\n\n#define HIST_CONFIG_DMA\t1\n\n \nstatic void hist_reset_mem(struct ispstat *hist)\n{\n\tstruct isp_device *isp = hist->isp;\n\tstruct omap3isp_hist_config *conf = hist->priv;\n\tunsigned int i;\n\n\tisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);\n\n\t \n\tisp_reg_set(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT, ISPHIST_CNT_CLEAR);\n\n\t \n\tfor (i = OMAP3ISP_HIST_MEM_SIZE / 4; i > 0; i--) {\n\t\tisp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\n\t\tisp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\n\t\tisp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\n\t\tisp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\n\t}\n\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT, ISPHIST_CNT_CLEAR);\n\n\thist->wait_acc_frames = conf->num_acc_frames;\n}\n\n \nstatic void hist_setup_regs(struct ispstat *hist, void *priv)\n{\n\tstruct isp_device *isp = hist->isp;\n\tstruct omap3isp_hist_config *conf = priv;\n\tint c;\n\tu32 cnt;\n\tu32 wb_gain;\n\tu32 reg_hor[OMAP3ISP_HIST_MAX_REGIONS];\n\tu32 reg_ver[OMAP3ISP_HIST_MAX_REGIONS];\n\n\tif (!hist->update || hist->state == ISPSTAT_DISABLED ||\n\t    hist->state == ISPSTAT_DISABLING)\n\t\treturn;\n\n\tcnt = conf->cfa << ISPHIST_CNT_CFA_SHIFT;\n\n\twb_gain = conf->wg[0] << ISPHIST_WB_GAIN_WG00_SHIFT;\n\twb_gain |= conf->wg[1] << ISPHIST_WB_GAIN_WG01_SHIFT;\n\twb_gain |= conf->wg[2] << ISPHIST_WB_GAIN_WG02_SHIFT;\n\tif (conf->cfa == OMAP3ISP_HIST_CFA_BAYER)\n\t\twb_gain |= conf->wg[3] << ISPHIST_WB_GAIN_WG03_SHIFT;\n\n\t \n\tfor (c = 0; c < OMAP3ISP_HIST_MAX_REGIONS; c++) {\n\t\tif (c < conf->num_regions) {\n\t\t\treg_hor[c] = (conf->region[c].h_start <<\n\t\t\t\t     ISPHIST_REG_START_SHIFT)\n\t\t\t\t   | (conf->region[c].h_end <<\n\t\t\t\t     ISPHIST_REG_END_SHIFT);\n\t\t\treg_ver[c] = (conf->region[c].v_start <<\n\t\t\t\t     ISPHIST_REG_START_SHIFT)\n\t\t\t\t   | (conf->region[c].v_end <<\n\t\t\t\t     ISPHIST_REG_END_SHIFT);\n\t\t} else {\n\t\t\treg_hor[c] = 0;\n\t\t\treg_ver[c] = 0;\n\t\t}\n\t}\n\n\tcnt |= conf->hist_bins << ISPHIST_CNT_BINS_SHIFT;\n\tswitch (conf->hist_bins) {\n\tcase OMAP3ISP_HIST_BINS_256:\n\t\tcnt |= (ISPHIST_IN_BIT_WIDTH_CCDC - 8) <<\n\t\t\tISPHIST_CNT_SHIFT_SHIFT;\n\t\tbreak;\n\tcase OMAP3ISP_HIST_BINS_128:\n\t\tcnt |= (ISPHIST_IN_BIT_WIDTH_CCDC - 7) <<\n\t\t\tISPHIST_CNT_SHIFT_SHIFT;\n\t\tbreak;\n\tcase OMAP3ISP_HIST_BINS_64:\n\t\tcnt |= (ISPHIST_IN_BIT_WIDTH_CCDC - 6) <<\n\t\t\tISPHIST_CNT_SHIFT_SHIFT;\n\t\tbreak;\n\tdefault:  \n\t\tcnt |= (ISPHIST_IN_BIT_WIDTH_CCDC - 5) <<\n\t\t\tISPHIST_CNT_SHIFT_SHIFT;\n\t\tbreak;\n\t}\n\n\thist_reset_mem(hist);\n\n\tisp_reg_writel(isp, cnt, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT);\n\tisp_reg_writel(isp, wb_gain,  OMAP3_ISP_IOMEM_HIST, ISPHIST_WB_GAIN);\n\tisp_reg_writel(isp, reg_hor[0], OMAP3_ISP_IOMEM_HIST, ISPHIST_R0_HORZ);\n\tisp_reg_writel(isp, reg_ver[0], OMAP3_ISP_IOMEM_HIST, ISPHIST_R0_VERT);\n\tisp_reg_writel(isp, reg_hor[1], OMAP3_ISP_IOMEM_HIST, ISPHIST_R1_HORZ);\n\tisp_reg_writel(isp, reg_ver[1], OMAP3_ISP_IOMEM_HIST, ISPHIST_R1_VERT);\n\tisp_reg_writel(isp, reg_hor[2], OMAP3_ISP_IOMEM_HIST, ISPHIST_R2_HORZ);\n\tisp_reg_writel(isp, reg_ver[2], OMAP3_ISP_IOMEM_HIST, ISPHIST_R2_VERT);\n\tisp_reg_writel(isp, reg_hor[3], OMAP3_ISP_IOMEM_HIST, ISPHIST_R3_HORZ);\n\tisp_reg_writel(isp, reg_ver[3], OMAP3_ISP_IOMEM_HIST, ISPHIST_R3_VERT);\n\n\thist->update = 0;\n\thist->config_counter += hist->inc_config;\n\thist->inc_config = 0;\n\thist->buf_size = conf->buf_size;\n}\n\nstatic void hist_enable(struct ispstat *hist, int enable)\n{\n\tif (enable) {\n\t\tisp_reg_set(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR,\n\t\t\t    ISPHIST_PCR_ENABLE);\n\t\tomap3isp_subclk_enable(hist->isp, OMAP3_ISP_SUBCLK_HIST);\n\t} else {\n\t\tisp_reg_clr(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR,\n\t\t\t    ISPHIST_PCR_ENABLE);\n\t\tomap3isp_subclk_disable(hist->isp, OMAP3_ISP_SUBCLK_HIST);\n\t}\n}\n\nstatic int hist_busy(struct ispstat *hist)\n{\n\treturn isp_reg_readl(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR)\n\t\t\t\t\t\t& ISPHIST_PCR_BUSY;\n}\n\nstatic void hist_dma_cb(void *data)\n{\n\tstruct ispstat *hist = data;\n\n\t \n\n\tisp_reg_clr(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,\n\t\t    ISPHIST_CNT_CLEAR);\n\n\tomap3isp_stat_dma_isr(hist);\n\tif (hist->state != ISPSTAT_DISABLED)\n\t\tomap3isp_hist_dma_done(hist->isp);\n}\n\nstatic int hist_buf_dma(struct ispstat *hist)\n{\n\tdma_addr_t dma_addr = hist->active_buf->dma_addr;\n\tstruct dma_async_tx_descriptor *tx;\n\tstruct dma_slave_config cfg;\n\tdma_cookie_t cookie;\n\tint ret;\n\n\tif (unlikely(!dma_addr)) {\n\t\tdev_dbg(hist->isp->dev, \"hist: invalid DMA buffer address\\n\");\n\t\tgoto error;\n\t}\n\n\tisp_reg_writel(hist->isp, 0, OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);\n\tisp_reg_set(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,\n\t\t    ISPHIST_CNT_CLEAR);\n\tomap3isp_flush(hist->isp);\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.src_addr = hist->isp->mmio_hist_base_phys + ISPHIST_DATA;\n\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tcfg.src_maxburst = hist->buf_size / 4;\n\n\tret = dmaengine_slave_config(hist->dma_ch, &cfg);\n\tif (ret < 0) {\n\t\tdev_dbg(hist->isp->dev,\n\t\t\t\"hist: DMA slave configuration failed\\n\");\n\t\tgoto error;\n\t}\n\n\ttx = dmaengine_prep_slave_single(hist->dma_ch, dma_addr,\n\t\t\t\t\t hist->buf_size, DMA_DEV_TO_MEM,\n\t\t\t\t\t DMA_CTRL_ACK);\n\tif (tx == NULL) {\n\t\tdev_dbg(hist->isp->dev,\n\t\t\t\"hist: DMA slave preparation failed\\n\");\n\t\tgoto error;\n\t}\n\n\ttx->callback = hist_dma_cb;\n\ttx->callback_param = hist;\n\tcookie = tx->tx_submit(tx);\n\tif (dma_submit_error(cookie)) {\n\t\tdev_dbg(hist->isp->dev, \"hist: DMA submission failed\\n\");\n\t\tgoto error;\n\t}\n\n\tdma_async_issue_pending(hist->dma_ch);\n\n\treturn STAT_BUF_WAITING_DMA;\n\nerror:\n\thist_reset_mem(hist);\n\treturn STAT_NO_BUF;\n}\n\nstatic int hist_buf_pio(struct ispstat *hist)\n{\n\tstruct isp_device *isp = hist->isp;\n\tu32 *buf = hist->active_buf->virt_addr;\n\tunsigned int i;\n\n\tif (!buf) {\n\t\tdev_dbg(isp->dev, \"hist: invalid PIO buffer address\\n\");\n\t\thist_reset_mem(hist);\n\t\treturn STAT_NO_BUF;\n\t}\n\n\tisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);\n\n\t \n\tisp_reg_set(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT, ISPHIST_CNT_CLEAR);\n\n\t \n\tfor (i = hist->buf_size / 16; i > 0; i--) {\n\t\t*buf++ = isp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\n\t\t*buf++ = isp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\n\t\t*buf++ = isp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\n\t\t*buf++ = isp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\n\t}\n\tisp_reg_clr(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,\n\t\t    ISPHIST_CNT_CLEAR);\n\n\treturn STAT_BUF_DONE;\n}\n\n \nstatic int hist_buf_process(struct ispstat *hist)\n{\n\tstruct omap3isp_hist_config *user_cfg = hist->priv;\n\tint ret;\n\n\tif (atomic_read(&hist->buf_err) || hist->state != ISPSTAT_ENABLED) {\n\t\thist_reset_mem(hist);\n\t\treturn STAT_NO_BUF;\n\t}\n\n\tif (--(hist->wait_acc_frames))\n\t\treturn STAT_NO_BUF;\n\n\tif (hist->dma_ch)\n\t\tret = hist_buf_dma(hist);\n\telse\n\t\tret = hist_buf_pio(hist);\n\n\thist->wait_acc_frames = user_cfg->num_acc_frames;\n\n\treturn ret;\n}\n\nstatic u32 hist_get_buf_size(struct omap3isp_hist_config *conf)\n{\n\treturn OMAP3ISP_HIST_MEM_SIZE_BINS(conf->hist_bins) * conf->num_regions;\n}\n\n \nstatic int hist_validate_params(struct ispstat *hist, void *new_conf)\n{\n\tstruct omap3isp_hist_config *user_cfg = new_conf;\n\tint c;\n\tu32 buf_size;\n\n\tif (user_cfg->cfa > OMAP3ISP_HIST_CFA_FOVEONX3)\n\t\treturn -EINVAL;\n\n\t \n\n\tif ((user_cfg->num_regions < OMAP3ISP_HIST_MIN_REGIONS) ||\n\t    (user_cfg->num_regions > OMAP3ISP_HIST_MAX_REGIONS))\n\t\treturn -EINVAL;\n\n\t \n\tfor (c = 0; c < user_cfg->num_regions; c++) {\n\t\tif (user_cfg->region[c].h_start & ~ISPHIST_REG_START_END_MASK)\n\t\t\treturn -EINVAL;\n\t\tif (user_cfg->region[c].h_end & ~ISPHIST_REG_START_END_MASK)\n\t\t\treturn -EINVAL;\n\t\tif (user_cfg->region[c].v_start & ~ISPHIST_REG_START_END_MASK)\n\t\t\treturn -EINVAL;\n\t\tif (user_cfg->region[c].v_end & ~ISPHIST_REG_START_END_MASK)\n\t\t\treturn -EINVAL;\n\t\tif (user_cfg->region[c].h_start > user_cfg->region[c].h_end)\n\t\t\treturn -EINVAL;\n\t\tif (user_cfg->region[c].v_start > user_cfg->region[c].v_end)\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (user_cfg->num_regions) {\n\tcase 1:\n\t\tif (user_cfg->hist_bins > OMAP3ISP_HIST_BINS_256)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase 2:\n\t\tif (user_cfg->hist_bins > OMAP3ISP_HIST_BINS_128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:  \n\t\tif (user_cfg->hist_bins > OMAP3ISP_HIST_BINS_64)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tbuf_size = hist_get_buf_size(user_cfg);\n\tif (buf_size > user_cfg->buf_size)\n\t\t \n\t\tuser_cfg->buf_size = buf_size;\n\telse if (user_cfg->buf_size > OMAP3ISP_HIST_MAX_BUF_SIZE)\n\t\tuser_cfg->buf_size = OMAP3ISP_HIST_MAX_BUF_SIZE;\n\n\treturn 0;\n}\n\nstatic int hist_comp_params(struct ispstat *hist,\n\t\t\t    struct omap3isp_hist_config *user_cfg)\n{\n\tstruct omap3isp_hist_config *cur_cfg = hist->priv;\n\tint c;\n\n\tif (cur_cfg->cfa != user_cfg->cfa)\n\t\treturn 1;\n\n\tif (cur_cfg->num_acc_frames != user_cfg->num_acc_frames)\n\t\treturn 1;\n\n\tif (cur_cfg->hist_bins != user_cfg->hist_bins)\n\t\treturn 1;\n\n\tfor (c = 0; c < OMAP3ISP_HIST_MAX_WG; c++) {\n\t\tif (c == 3 && user_cfg->cfa == OMAP3ISP_HIST_CFA_FOVEONX3)\n\t\t\tbreak;\n\t\telse if (cur_cfg->wg[c] != user_cfg->wg[c])\n\t\t\treturn 1;\n\t}\n\n\tif (cur_cfg->num_regions != user_cfg->num_regions)\n\t\treturn 1;\n\n\t \n\tfor (c = 0; c < user_cfg->num_regions; c++) {\n\t\tif (cur_cfg->region[c].h_start != user_cfg->region[c].h_start)\n\t\t\treturn 1;\n\t\tif (cur_cfg->region[c].h_end != user_cfg->region[c].h_end)\n\t\t\treturn 1;\n\t\tif (cur_cfg->region[c].v_start != user_cfg->region[c].v_start)\n\t\t\treturn 1;\n\t\tif (cur_cfg->region[c].v_end != user_cfg->region[c].v_end)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void hist_set_params(struct ispstat *hist, void *new_conf)\n{\n\tstruct omap3isp_hist_config *user_cfg = new_conf;\n\tstruct omap3isp_hist_config *cur_cfg = hist->priv;\n\n\tif (!hist->configured || hist_comp_params(hist, user_cfg)) {\n\t\tmemcpy(cur_cfg, user_cfg, sizeof(*user_cfg));\n\t\tif (user_cfg->num_acc_frames == 0)\n\t\t\tuser_cfg->num_acc_frames = 1;\n\t\thist->inc_config++;\n\t\thist->update = 1;\n\t\t \n\t\tcur_cfg->buf_size = hist_get_buf_size(cur_cfg);\n\n\t}\n}\n\nstatic long hist_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tstruct ispstat *stat = v4l2_get_subdevdata(sd);\n\n\tswitch (cmd) {\n\tcase VIDIOC_OMAP3ISP_HIST_CFG:\n\t\treturn omap3isp_stat_config(stat, arg);\n\tcase VIDIOC_OMAP3ISP_STAT_REQ:\n\t\treturn omap3isp_stat_request_statistics(stat, arg);\n\tcase VIDIOC_OMAP3ISP_STAT_REQ_TIME32:\n\t\treturn omap3isp_stat_request_statistics_time32(stat, arg);\n\tcase VIDIOC_OMAP3ISP_STAT_EN: {\n\t\tint *en = arg;\n\t\treturn omap3isp_stat_enable(stat, !!*en);\n\t}\n\t}\n\n\treturn -ENOIOCTLCMD;\n\n}\n\nstatic const struct ispstat_ops hist_ops = {\n\t.validate_params\t= hist_validate_params,\n\t.set_params\t\t= hist_set_params,\n\t.setup_regs\t\t= hist_setup_regs,\n\t.enable\t\t\t= hist_enable,\n\t.busy\t\t\t= hist_busy,\n\t.buf_process\t\t= hist_buf_process,\n};\n\nstatic const struct v4l2_subdev_core_ops hist_subdev_core_ops = {\n\t.ioctl = hist_ioctl,\n\t.subscribe_event = omap3isp_stat_subscribe_event,\n\t.unsubscribe_event = omap3isp_stat_unsubscribe_event,\n};\n\nstatic const struct v4l2_subdev_video_ops hist_subdev_video_ops = {\n\t.s_stream = omap3isp_stat_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops hist_subdev_ops = {\n\t.core = &hist_subdev_core_ops,\n\t.video = &hist_subdev_video_ops,\n};\n\n \nint omap3isp_hist_init(struct isp_device *isp)\n{\n\tstruct ispstat *hist = &isp->isp_hist;\n\tstruct omap3isp_hist_config *hist_cfg;\n\tint ret;\n\n\thist_cfg = kzalloc(sizeof(*hist_cfg), GFP_KERNEL);\n\tif (hist_cfg == NULL)\n\t\treturn -ENOMEM;\n\n\thist->isp = isp;\n\n\tif (HIST_CONFIG_DMA) {\n\t\tdma_cap_mask_t mask;\n\n\t\t \n\t\tdma_cap_zero(mask);\n\t\tdma_cap_set(DMA_SLAVE, mask);\n\t\thist->dma_ch = dma_request_chan_by_mask(&mask);\n\t\tif (IS_ERR(hist->dma_ch)) {\n\t\t\tret = PTR_ERR(hist->dma_ch);\n\t\t\tif (ret == -EPROBE_DEFER)\n\t\t\t\tgoto err;\n\n\t\t\thist->dma_ch = NULL;\n\t\t\tdev_warn(isp->dev,\n\t\t\t\t \"hist: DMA channel request failed, using PIO\\n\");\n\t\t} else {\n\t\t\tdev_dbg(isp->dev, \"hist: using DMA channel %s\\n\",\n\t\t\t\tdma_chan_name(hist->dma_ch));\n\t\t}\n\t}\n\n\thist->ops = &hist_ops;\n\thist->priv = hist_cfg;\n\thist->event_type = V4L2_EVENT_OMAP3ISP_HIST;\n\n\tret = omap3isp_stat_init(hist, \"histogram\", &hist_subdev_ops);\n\nerr:\n\tif (ret) {\n\t\tif (!IS_ERR_OR_NULL(hist->dma_ch))\n\t\t\tdma_release_channel(hist->dma_ch);\n\t\tkfree(hist_cfg);\n\t}\n\n\treturn ret;\n}\n\n \nvoid omap3isp_hist_cleanup(struct isp_device *isp)\n{\n\tstruct ispstat *hist = &isp->isp_hist;\n\n\tif (hist->dma_ch)\n\t\tdma_release_channel(hist->dma_ch);\n\n\tomap3isp_stat_cleanup(hist);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}