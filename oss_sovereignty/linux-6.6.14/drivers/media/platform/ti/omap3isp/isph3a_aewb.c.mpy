{
  "module_name": "isph3a_aewb.c",
  "hash_id": "457864dc9555208f726b85b7ba97875dcc8507379b3feb723ebbc4eaad96404a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap3isp/isph3a_aewb.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include \"isp.h\"\n#include \"isph3a.h\"\n#include \"ispstat.h\"\n\n \nstatic void h3a_aewb_setup_regs(struct ispstat *aewb, void *priv)\n{\n\tstruct omap3isp_h3a_aewb_config *conf = priv;\n\tu32 pcr;\n\tu32 win1;\n\tu32 start;\n\tu32 blk;\n\tu32 subwin;\n\n\tif (aewb->state == ISPSTAT_DISABLED)\n\t\treturn;\n\n\tisp_reg_writel(aewb->isp, aewb->active_buf->dma_addr,\n\t\t       OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWBUFST);\n\n\tif (!aewb->update)\n\t\treturn;\n\n\t \n\tpcr = conf->saturation_limit << ISPH3A_PCR_AEW_AVE2LMT_SHIFT;\n\tpcr |= !!conf->alaw_enable << ISPH3A_PCR_AEW_ALAW_EN_SHIFT;\n\n\twin1 = ((conf->win_height >> 1) - 1) << ISPH3A_AEWWIN1_WINH_SHIFT;\n\twin1 |= ((conf->win_width >> 1) - 1) << ISPH3A_AEWWIN1_WINW_SHIFT;\n\twin1 |= (conf->ver_win_count - 1) << ISPH3A_AEWWIN1_WINVC_SHIFT;\n\twin1 |= (conf->hor_win_count - 1) << ISPH3A_AEWWIN1_WINHC_SHIFT;\n\n\tstart = conf->hor_win_start << ISPH3A_AEWINSTART_WINSH_SHIFT;\n\tstart |= conf->ver_win_start << ISPH3A_AEWINSTART_WINSV_SHIFT;\n\n\tblk = conf->blk_ver_win_start << ISPH3A_AEWINBLK_WINSV_SHIFT;\n\tblk |= ((conf->blk_win_height >> 1) - 1) << ISPH3A_AEWINBLK_WINH_SHIFT;\n\n\tsubwin = ((conf->subsample_ver_inc >> 1) - 1) <<\n\t\t ISPH3A_AEWSUBWIN_AEWINCV_SHIFT;\n\tsubwin |= ((conf->subsample_hor_inc >> 1) - 1) <<\n\t\t  ISPH3A_AEWSUBWIN_AEWINCH_SHIFT;\n\n\tisp_reg_writel(aewb->isp, win1, OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWWIN1);\n\tisp_reg_writel(aewb->isp, start, OMAP3_ISP_IOMEM_H3A,\n\t\t       ISPH3A_AEWINSTART);\n\tisp_reg_writel(aewb->isp, blk, OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWINBLK);\n\tisp_reg_writel(aewb->isp, subwin, OMAP3_ISP_IOMEM_H3A,\n\t\t       ISPH3A_AEWSUBWIN);\n\tisp_reg_clr_set(aewb->isp, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR,\n\t\t\tISPH3A_PCR_AEW_MASK, pcr);\n\n\taewb->update = 0;\n\taewb->config_counter += aewb->inc_config;\n\taewb->inc_config = 0;\n\taewb->buf_size = conf->buf_size;\n}\n\nstatic void h3a_aewb_enable(struct ispstat *aewb, int enable)\n{\n\tif (enable) {\n\t\tisp_reg_set(aewb->isp, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR,\n\t\t\t    ISPH3A_PCR_AEW_EN);\n\t\tomap3isp_subclk_enable(aewb->isp, OMAP3_ISP_SUBCLK_AEWB);\n\t} else {\n\t\tisp_reg_clr(aewb->isp, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR,\n\t\t\t    ISPH3A_PCR_AEW_EN);\n\t\tomap3isp_subclk_disable(aewb->isp, OMAP3_ISP_SUBCLK_AEWB);\n\t}\n}\n\nstatic int h3a_aewb_busy(struct ispstat *aewb)\n{\n\treturn isp_reg_readl(aewb->isp, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR)\n\t\t\t\t\t\t& ISPH3A_PCR_BUSYAEAWB;\n}\n\nstatic u32 h3a_aewb_get_buf_size(struct omap3isp_h3a_aewb_config *conf)\n{\n\t \n\tu32 win_count = (conf->ver_win_count + 1) * conf->hor_win_count;\n\n\t \n\twin_count += (win_count + 7) / 8;\n\n\treturn win_count * AEWB_PACKET_SIZE;\n}\n\nstatic int h3a_aewb_validate_params(struct ispstat *aewb, void *new_conf)\n{\n\tstruct omap3isp_h3a_aewb_config *user_cfg = new_conf;\n\tu32 buf_size;\n\n\tif (unlikely(user_cfg->saturation_limit >\n\t\t     OMAP3ISP_AEWB_MAX_SATURATION_LIM))\n\t\treturn -EINVAL;\n\n\tif (unlikely(user_cfg->win_height < OMAP3ISP_AEWB_MIN_WIN_H ||\n\t\t     user_cfg->win_height > OMAP3ISP_AEWB_MAX_WIN_H ||\n\t\t     user_cfg->win_height & 0x01))\n\t\treturn -EINVAL;\n\n\tif (unlikely(user_cfg->win_width < OMAP3ISP_AEWB_MIN_WIN_W ||\n\t\t     user_cfg->win_width > OMAP3ISP_AEWB_MAX_WIN_W ||\n\t\t     user_cfg->win_width & 0x01))\n\t\treturn -EINVAL;\n\n\tif (unlikely(user_cfg->ver_win_count < OMAP3ISP_AEWB_MIN_WINVC ||\n\t\t     user_cfg->ver_win_count > OMAP3ISP_AEWB_MAX_WINVC))\n\t\treturn -EINVAL;\n\n\tif (unlikely(user_cfg->hor_win_count < OMAP3ISP_AEWB_MIN_WINHC ||\n\t\t     user_cfg->hor_win_count > OMAP3ISP_AEWB_MAX_WINHC))\n\t\treturn -EINVAL;\n\n\tif (unlikely(user_cfg->ver_win_start > OMAP3ISP_AEWB_MAX_WINSTART))\n\t\treturn -EINVAL;\n\n\tif (unlikely(user_cfg->hor_win_start > OMAP3ISP_AEWB_MAX_WINSTART))\n\t\treturn -EINVAL;\n\n\tif (unlikely(user_cfg->blk_ver_win_start > OMAP3ISP_AEWB_MAX_WINSTART))\n\t\treturn -EINVAL;\n\n\tif (unlikely(user_cfg->blk_win_height < OMAP3ISP_AEWB_MIN_WIN_H ||\n\t\t     user_cfg->blk_win_height > OMAP3ISP_AEWB_MAX_WIN_H ||\n\t\t     user_cfg->blk_win_height & 0x01))\n\t\treturn -EINVAL;\n\n\tif (unlikely(user_cfg->subsample_ver_inc < OMAP3ISP_AEWB_MIN_SUB_INC ||\n\t\t     user_cfg->subsample_ver_inc > OMAP3ISP_AEWB_MAX_SUB_INC ||\n\t\t     user_cfg->subsample_ver_inc & 0x01))\n\t\treturn -EINVAL;\n\n\tif (unlikely(user_cfg->subsample_hor_inc < OMAP3ISP_AEWB_MIN_SUB_INC ||\n\t\t     user_cfg->subsample_hor_inc > OMAP3ISP_AEWB_MAX_SUB_INC ||\n\t\t     user_cfg->subsample_hor_inc & 0x01))\n\t\treturn -EINVAL;\n\n\tbuf_size = h3a_aewb_get_buf_size(user_cfg);\n\tif (buf_size > user_cfg->buf_size)\n\t\tuser_cfg->buf_size = buf_size;\n\telse if (user_cfg->buf_size > OMAP3ISP_AEWB_MAX_BUF_SIZE)\n\t\tuser_cfg->buf_size = OMAP3ISP_AEWB_MAX_BUF_SIZE;\n\n\treturn 0;\n}\n\n \nstatic void h3a_aewb_set_params(struct ispstat *aewb, void *new_conf)\n{\n\tstruct omap3isp_h3a_aewb_config *user_cfg = new_conf;\n\tstruct omap3isp_h3a_aewb_config *cur_cfg = aewb->priv;\n\tint update = 0;\n\n\tif (cur_cfg->saturation_limit != user_cfg->saturation_limit) {\n\t\tcur_cfg->saturation_limit = user_cfg->saturation_limit;\n\t\tupdate = 1;\n\t}\n\tif (cur_cfg->alaw_enable != user_cfg->alaw_enable) {\n\t\tcur_cfg->alaw_enable = user_cfg->alaw_enable;\n\t\tupdate = 1;\n\t}\n\tif (cur_cfg->win_height != user_cfg->win_height) {\n\t\tcur_cfg->win_height = user_cfg->win_height;\n\t\tupdate = 1;\n\t}\n\tif (cur_cfg->win_width != user_cfg->win_width) {\n\t\tcur_cfg->win_width = user_cfg->win_width;\n\t\tupdate = 1;\n\t}\n\tif (cur_cfg->ver_win_count != user_cfg->ver_win_count) {\n\t\tcur_cfg->ver_win_count = user_cfg->ver_win_count;\n\t\tupdate = 1;\n\t}\n\tif (cur_cfg->hor_win_count != user_cfg->hor_win_count) {\n\t\tcur_cfg->hor_win_count = user_cfg->hor_win_count;\n\t\tupdate = 1;\n\t}\n\tif (cur_cfg->ver_win_start != user_cfg->ver_win_start) {\n\t\tcur_cfg->ver_win_start = user_cfg->ver_win_start;\n\t\tupdate = 1;\n\t}\n\tif (cur_cfg->hor_win_start != user_cfg->hor_win_start) {\n\t\tcur_cfg->hor_win_start = user_cfg->hor_win_start;\n\t\tupdate = 1;\n\t}\n\tif (cur_cfg->blk_ver_win_start != user_cfg->blk_ver_win_start) {\n\t\tcur_cfg->blk_ver_win_start = user_cfg->blk_ver_win_start;\n\t\tupdate = 1;\n\t}\n\tif (cur_cfg->blk_win_height != user_cfg->blk_win_height) {\n\t\tcur_cfg->blk_win_height = user_cfg->blk_win_height;\n\t\tupdate = 1;\n\t}\n\tif (cur_cfg->subsample_ver_inc != user_cfg->subsample_ver_inc) {\n\t\tcur_cfg->subsample_ver_inc = user_cfg->subsample_ver_inc;\n\t\tupdate = 1;\n\t}\n\tif (cur_cfg->subsample_hor_inc != user_cfg->subsample_hor_inc) {\n\t\tcur_cfg->subsample_hor_inc = user_cfg->subsample_hor_inc;\n\t\tupdate = 1;\n\t}\n\n\tif (update || !aewb->configured) {\n\t\taewb->inc_config++;\n\t\taewb->update = 1;\n\t\tcur_cfg->buf_size = h3a_aewb_get_buf_size(cur_cfg);\n\t}\n}\n\nstatic long h3a_aewb_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\n{\n\tstruct ispstat *stat = v4l2_get_subdevdata(sd);\n\n\tswitch (cmd) {\n\tcase VIDIOC_OMAP3ISP_AEWB_CFG:\n\t\treturn omap3isp_stat_config(stat, arg);\n\tcase VIDIOC_OMAP3ISP_STAT_REQ:\n\t\treturn omap3isp_stat_request_statistics(stat, arg);\n\tcase VIDIOC_OMAP3ISP_STAT_REQ_TIME32:\n\t\treturn omap3isp_stat_request_statistics_time32(stat, arg);\n\tcase VIDIOC_OMAP3ISP_STAT_EN: {\n\t\tunsigned long *en = arg;\n\t\treturn omap3isp_stat_enable(stat, !!*en);\n\t}\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic const struct ispstat_ops h3a_aewb_ops = {\n\t.validate_params\t= h3a_aewb_validate_params,\n\t.set_params\t\t= h3a_aewb_set_params,\n\t.setup_regs\t\t= h3a_aewb_setup_regs,\n\t.enable\t\t\t= h3a_aewb_enable,\n\t.busy\t\t\t= h3a_aewb_busy,\n};\n\nstatic const struct v4l2_subdev_core_ops h3a_aewb_subdev_core_ops = {\n\t.ioctl = h3a_aewb_ioctl,\n\t.subscribe_event = omap3isp_stat_subscribe_event,\n\t.unsubscribe_event = omap3isp_stat_unsubscribe_event,\n};\n\nstatic const struct v4l2_subdev_video_ops h3a_aewb_subdev_video_ops = {\n\t.s_stream = omap3isp_stat_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops h3a_aewb_subdev_ops = {\n\t.core = &h3a_aewb_subdev_core_ops,\n\t.video = &h3a_aewb_subdev_video_ops,\n};\n\n \nint omap3isp_h3a_aewb_init(struct isp_device *isp)\n{\n\tstruct ispstat *aewb = &isp->isp_aewb;\n\tstruct omap3isp_h3a_aewb_config *aewb_cfg;\n\tstruct omap3isp_h3a_aewb_config *aewb_recover_cfg = NULL;\n\tint ret;\n\n\taewb_cfg = kzalloc(sizeof(*aewb_cfg), GFP_KERNEL);\n\tif (!aewb_cfg)\n\t\treturn -ENOMEM;\n\n\taewb->ops = &h3a_aewb_ops;\n\taewb->priv = aewb_cfg;\n\taewb->event_type = V4L2_EVENT_OMAP3ISP_AEWB;\n\taewb->isp = isp;\n\n\t \n\taewb_recover_cfg = kzalloc(sizeof(*aewb_recover_cfg), GFP_KERNEL);\n\tif (!aewb_recover_cfg) {\n\t\tdev_err(aewb->isp->dev,\n\t\t\t\"AEWB: cannot allocate memory for recover configuration.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\taewb_recover_cfg->saturation_limit = OMAP3ISP_AEWB_MAX_SATURATION_LIM;\n\taewb_recover_cfg->win_height = OMAP3ISP_AEWB_MIN_WIN_H;\n\taewb_recover_cfg->win_width = OMAP3ISP_AEWB_MIN_WIN_W;\n\taewb_recover_cfg->ver_win_count = OMAP3ISP_AEWB_MIN_WINVC;\n\taewb_recover_cfg->hor_win_count = OMAP3ISP_AEWB_MIN_WINHC;\n\taewb_recover_cfg->blk_ver_win_start = aewb_recover_cfg->ver_win_start +\n\t\taewb_recover_cfg->win_height * aewb_recover_cfg->ver_win_count;\n\taewb_recover_cfg->blk_win_height = OMAP3ISP_AEWB_MIN_WIN_H;\n\taewb_recover_cfg->subsample_ver_inc = OMAP3ISP_AEWB_MIN_SUB_INC;\n\taewb_recover_cfg->subsample_hor_inc = OMAP3ISP_AEWB_MIN_SUB_INC;\n\n\tif (h3a_aewb_validate_params(aewb, aewb_recover_cfg)) {\n\t\tdev_err(aewb->isp->dev,\n\t\t\t\"AEWB: recover configuration is invalid.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\taewb_recover_cfg->buf_size = h3a_aewb_get_buf_size(aewb_recover_cfg);\n\taewb->recover_priv = aewb_recover_cfg;\n\n\tret = omap3isp_stat_init(aewb, \"AEWB\", &h3a_aewb_subdev_ops);\n\nerr:\n\tif (ret) {\n\t\tkfree(aewb_cfg);\n\t\tkfree(aewb_recover_cfg);\n\t}\n\n\treturn ret;\n}\n\n \nvoid omap3isp_h3a_aewb_cleanup(struct isp_device *isp)\n{\n\tomap3isp_stat_cleanup(&isp->isp_aewb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}