{
  "module_name": "isp.c",
  "hash_id": "bbdb115a40ed6d344f0af7e4e155a6f648cf0c696a8647e37425ac94b3fc3f4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap3isp/isp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/omap-iommu.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n\n#ifdef CONFIG_ARM_DMA_USE_IOMMU\n#include <asm/dma-iommu.h>\n#endif\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-mc.h>\n\n#include \"isp.h\"\n#include \"ispreg.h\"\n#include \"ispccdc.h\"\n#include \"isppreview.h\"\n#include \"ispresizer.h\"\n#include \"ispcsi2.h\"\n#include \"ispccp2.h\"\n#include \"isph3a.h\"\n#include \"isphist.h\"\n\nstatic unsigned int autoidle;\nmodule_param(autoidle, int, 0444);\nMODULE_PARM_DESC(autoidle, \"Enable OMAP3ISP AUTOIDLE support\");\n\nstatic void isp_save_ctx(struct isp_device *isp);\n\nstatic void isp_restore_ctx(struct isp_device *isp);\n\nstatic const struct isp_res_mapping isp_res_maps[] = {\n\t{\n\t\t.isp_rev = ISP_REVISION_2_0,\n\t\t.offset = {\n\t\t\t \n\t\t\t0x0000,  \n\t\t\t0x0400,  \n\t\t\t0x0600,  \n\t\t\t0x0a00,  \n\t\t\t0x0c00,  \n\t\t\t0x0e00,  \n\t\t\t0x1000,  \n\t\t\t0x1200,  \n\t\t\t \n\t\t\t0x0000,  \n\t\t\t0x0170,  \n\t\t},\n\t\t.phy_type = ISP_PHY_TYPE_3430,\n\t},\n\t{\n\t\t.isp_rev = ISP_REVISION_15_0,\n\t\t.offset = {\n\t\t\t \n\t\t\t0x0000,  \n\t\t\t0x0400,  \n\t\t\t0x0600,  \n\t\t\t0x0a00,  \n\t\t\t0x0c00,  \n\t\t\t0x0e00,  \n\t\t\t0x1000,  \n\t\t\t0x1200,  \n\t\t\t \n\t\t\t0x0000,  \n\t\t\t0x0170,  \n\t\t\t0x01c0,  \n\t\t\t0x0400,  \n\t\t\t0x0570,  \n\t\t\t0x05c0,  \n\t\t},\n\t\t.phy_type = ISP_PHY_TYPE_3630,\n\t},\n};\n\n \nstatic struct isp_reg isp_reg_list[] = {\n\t{OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG, 0},\n\t{OMAP3_ISP_IOMEM_MAIN, ISP_CTRL, 0},\n\t{OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_CTRL, 0},\n\t{0, ISP_TOK_TERM, 0}\n};\n\n \nvoid omap3isp_flush(struct isp_device *isp)\n{\n\tisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);\n\tisp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);\n}\n\n \n\n#define to_isp_xclk(_hw)\tcontainer_of(_hw, struct isp_xclk, hw)\n\nstatic void isp_xclk_update(struct isp_xclk *xclk, u32 divider)\n{\n\tswitch (xclk->id) {\n\tcase ISP_XCLK_A:\n\t\tisp_reg_clr_set(xclk->isp, OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_CTRL,\n\t\t\t\tISPTCTRL_CTRL_DIVA_MASK,\n\t\t\t\tdivider << ISPTCTRL_CTRL_DIVA_SHIFT);\n\t\tbreak;\n\tcase ISP_XCLK_B:\n\t\tisp_reg_clr_set(xclk->isp, OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_CTRL,\n\t\t\t\tISPTCTRL_CTRL_DIVB_MASK,\n\t\t\t\tdivider << ISPTCTRL_CTRL_DIVB_SHIFT);\n\t\tbreak;\n\t}\n}\n\nstatic int isp_xclk_prepare(struct clk_hw *hw)\n{\n\tstruct isp_xclk *xclk = to_isp_xclk(hw);\n\n\tomap3isp_get(xclk->isp);\n\n\treturn 0;\n}\n\nstatic void isp_xclk_unprepare(struct clk_hw *hw)\n{\n\tstruct isp_xclk *xclk = to_isp_xclk(hw);\n\n\tomap3isp_put(xclk->isp);\n}\n\nstatic int isp_xclk_enable(struct clk_hw *hw)\n{\n\tstruct isp_xclk *xclk = to_isp_xclk(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&xclk->lock, flags);\n\tisp_xclk_update(xclk, xclk->divider);\n\txclk->enabled = true;\n\tspin_unlock_irqrestore(&xclk->lock, flags);\n\n\treturn 0;\n}\n\nstatic void isp_xclk_disable(struct clk_hw *hw)\n{\n\tstruct isp_xclk *xclk = to_isp_xclk(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&xclk->lock, flags);\n\tisp_xclk_update(xclk, 0);\n\txclk->enabled = false;\n\tspin_unlock_irqrestore(&xclk->lock, flags);\n}\n\nstatic unsigned long isp_xclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct isp_xclk *xclk = to_isp_xclk(hw);\n\n\treturn parent_rate / xclk->divider;\n}\n\nstatic u32 isp_xclk_calc_divider(unsigned long *rate, unsigned long parent_rate)\n{\n\tu32 divider;\n\n\tif (*rate >= parent_rate) {\n\t\t*rate = parent_rate;\n\t\treturn ISPTCTRL_CTRL_DIV_BYPASS;\n\t}\n\n\tif (*rate == 0)\n\t\t*rate = 1;\n\n\tdivider = DIV_ROUND_CLOSEST(parent_rate, *rate);\n\tif (divider >= ISPTCTRL_CTRL_DIV_BYPASS)\n\t\tdivider = ISPTCTRL_CTRL_DIV_BYPASS - 1;\n\n\t*rate = parent_rate / divider;\n\treturn divider;\n}\n\nstatic long isp_xclk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *parent_rate)\n{\n\tisp_xclk_calc_divider(&rate, *parent_rate);\n\treturn rate;\n}\n\nstatic int isp_xclk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long parent_rate)\n{\n\tstruct isp_xclk *xclk = to_isp_xclk(hw);\n\tunsigned long flags;\n\tu32 divider;\n\n\tdivider = isp_xclk_calc_divider(&rate, parent_rate);\n\n\tspin_lock_irqsave(&xclk->lock, flags);\n\n\txclk->divider = divider;\n\tif (xclk->enabled)\n\t\tisp_xclk_update(xclk, divider);\n\n\tspin_unlock_irqrestore(&xclk->lock, flags);\n\n\tdev_dbg(xclk->isp->dev, \"%s: cam_xclk%c set to %lu Hz (div %u)\\n\",\n\t\t__func__, xclk->id == ISP_XCLK_A ? 'a' : 'b', rate, divider);\n\treturn 0;\n}\n\nstatic const struct clk_ops isp_xclk_ops = {\n\t.prepare = isp_xclk_prepare,\n\t.unprepare = isp_xclk_unprepare,\n\t.enable = isp_xclk_enable,\n\t.disable = isp_xclk_disable,\n\t.recalc_rate = isp_xclk_recalc_rate,\n\t.round_rate = isp_xclk_round_rate,\n\t.set_rate = isp_xclk_set_rate,\n};\n\nstatic const char *isp_xclk_parent_name = \"cam_mclk\";\n\nstatic struct clk *isp_xclk_src_get(struct of_phandle_args *clkspec, void *data)\n{\n\tunsigned int idx = clkspec->args[0];\n\tstruct isp_device *isp = data;\n\n\tif (idx >= ARRAY_SIZE(isp->xclks))\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn isp->xclks[idx].clk;\n}\n\nstatic int isp_xclk_init(struct isp_device *isp)\n{\n\tstruct device_node *np = isp->dev->of_node;\n\tstruct clk_init_data init = {};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(isp->xclks); ++i)\n\t\tisp->xclks[i].clk = ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < ARRAY_SIZE(isp->xclks); ++i) {\n\t\tstruct isp_xclk *xclk = &isp->xclks[i];\n\n\t\txclk->isp = isp;\n\t\txclk->id = i == 0 ? ISP_XCLK_A : ISP_XCLK_B;\n\t\txclk->divider = 1;\n\t\tspin_lock_init(&xclk->lock);\n\n\t\tinit.name = i == 0 ? \"cam_xclka\" : \"cam_xclkb\";\n\t\tinit.ops = &isp_xclk_ops;\n\t\tinit.parent_names = &isp_xclk_parent_name;\n\t\tinit.num_parents = 1;\n\n\t\txclk->hw.init = &init;\n\t\t \n\t\txclk->clk = clk_register(NULL, &xclk->hw);\n\t\tif (IS_ERR(xclk->clk))\n\t\t\treturn PTR_ERR(xclk->clk);\n\t}\n\n\tif (np)\n\t\tof_clk_add_provider(np, isp_xclk_src_get, isp);\n\n\treturn 0;\n}\n\nstatic void isp_xclk_cleanup(struct isp_device *isp)\n{\n\tstruct device_node *np = isp->dev->of_node;\n\tunsigned int i;\n\n\tif (np)\n\t\tof_clk_del_provider(np);\n\n\tfor (i = 0; i < ARRAY_SIZE(isp->xclks); ++i) {\n\t\tstruct isp_xclk *xclk = &isp->xclks[i];\n\n\t\tif (!IS_ERR(xclk->clk))\n\t\t\tclk_unregister(xclk->clk);\n\t}\n}\n\n \n\n \nstatic void isp_enable_interrupts(struct isp_device *isp)\n{\n\tstatic const u32 irq = IRQ0ENABLE_CSIA_IRQ\n\t\t\t     | IRQ0ENABLE_CSIB_IRQ\n\t\t\t     | IRQ0ENABLE_CCDC_LSC_PREF_ERR_IRQ\n\t\t\t     | IRQ0ENABLE_CCDC_LSC_DONE_IRQ\n\t\t\t     | IRQ0ENABLE_CCDC_VD0_IRQ\n\t\t\t     | IRQ0ENABLE_CCDC_VD1_IRQ\n\t\t\t     | IRQ0ENABLE_HS_VS_IRQ\n\t\t\t     | IRQ0ENABLE_HIST_DONE_IRQ\n\t\t\t     | IRQ0ENABLE_H3A_AWB_DONE_IRQ\n\t\t\t     | IRQ0ENABLE_H3A_AF_DONE_IRQ\n\t\t\t     | IRQ0ENABLE_PRV_DONE_IRQ\n\t\t\t     | IRQ0ENABLE_RSZ_DONE_IRQ;\n\n\tisp_reg_writel(isp, irq, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\n\tisp_reg_writel(isp, irq, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);\n}\n\n \nstatic void isp_disable_interrupts(struct isp_device *isp)\n{\n\tisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);\n}\n\n \nstatic void isp_core_init(struct isp_device *isp, int idle)\n{\n\tisp_reg_writel(isp,\n\t\t       ((idle ? ISP_SYSCONFIG_MIDLEMODE_SMARTSTANDBY :\n\t\t\t\tISP_SYSCONFIG_MIDLEMODE_FORCESTANDBY) <<\n\t\t\tISP_SYSCONFIG_MIDLEMODE_SHIFT) |\n\t\t\t((isp->revision == ISP_REVISION_15_0) ?\n\t\t\t  ISP_SYSCONFIG_AUTOIDLE : 0),\n\t\t       OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG);\n\n\tisp_reg_writel(isp,\n\t\t       (isp->autoidle ? ISPCTRL_SBL_AUTOIDLE : 0) |\n\t\t       ISPCTRL_SYNC_DETECT_VSRISE,\n\t\t       OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);\n}\n\n \nvoid omap3isp_configure_bridge(struct isp_device *isp,\n\t\t\t       enum ccdc_input_entity input,\n\t\t\t       const struct isp_parallel_cfg *parcfg,\n\t\t\t       unsigned int shift, unsigned int bridge)\n{\n\tu32 ispctrl_val;\n\n\tispctrl_val  = isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);\n\tispctrl_val &= ~ISPCTRL_SHIFT_MASK;\n\tispctrl_val &= ~ISPCTRL_PAR_CLK_POL_INV;\n\tispctrl_val &= ~ISPCTRL_PAR_SER_CLK_SEL_MASK;\n\tispctrl_val &= ~ISPCTRL_PAR_BRIDGE_MASK;\n\tispctrl_val |= bridge;\n\n\tswitch (input) {\n\tcase CCDC_INPUT_PARALLEL:\n\t\tispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_PARALLEL;\n\t\tispctrl_val |= parcfg->clk_pol << ISPCTRL_PAR_CLK_POL_SHIFT;\n\t\tshift += parcfg->data_lane_shift;\n\t\tbreak;\n\n\tcase CCDC_INPUT_CSI2A:\n\t\tispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_CSIA;\n\t\tbreak;\n\n\tcase CCDC_INPUT_CCP2B:\n\t\tispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_CSIB;\n\t\tbreak;\n\n\tcase CCDC_INPUT_CSI2C:\n\t\tispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_CSIC;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tispctrl_val |= ((shift/2) << ISPCTRL_SHIFT_SHIFT) & ISPCTRL_SHIFT_MASK;\n\n\tisp_reg_writel(isp, ispctrl_val, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);\n}\n\nvoid omap3isp_hist_dma_done(struct isp_device *isp)\n{\n\tif (omap3isp_ccdc_busy(&isp->isp_ccdc) ||\n\t    omap3isp_stat_pcr_busy(&isp->isp_hist)) {\n\t\t \n\t\tatomic_set(&isp->isp_hist.buf_err, 1);\n\t\tdev_dbg(isp->dev,\n\t\t\t\"hist: Out of synchronization with CCDC. Ignoring next buffer.\\n\");\n\t}\n}\n\nstatic inline void __maybe_unused isp_isr_dbg(struct isp_device *isp,\n\t\t\t\t\t      u32 irqstatus)\n{\n\tstatic const char *name[] = {\n\t\t\"CSIA_IRQ\",\n\t\t\"res1\",\n\t\t\"res2\",\n\t\t\"CSIB_LCM_IRQ\",\n\t\t\"CSIB_IRQ\",\n\t\t\"res5\",\n\t\t\"res6\",\n\t\t\"res7\",\n\t\t\"CCDC_VD0_IRQ\",\n\t\t\"CCDC_VD1_IRQ\",\n\t\t\"CCDC_VD2_IRQ\",\n\t\t\"CCDC_ERR_IRQ\",\n\t\t\"H3A_AF_DONE_IRQ\",\n\t\t\"H3A_AWB_DONE_IRQ\",\n\t\t\"res14\",\n\t\t\"res15\",\n\t\t\"HIST_DONE_IRQ\",\n\t\t\"CCDC_LSC_DONE\",\n\t\t\"CCDC_LSC_PREFETCH_COMPLETED\",\n\t\t\"CCDC_LSC_PREFETCH_ERROR\",\n\t\t\"PRV_DONE_IRQ\",\n\t\t\"CBUFF_IRQ\",\n\t\t\"res22\",\n\t\t\"res23\",\n\t\t\"RSZ_DONE_IRQ\",\n\t\t\"OVF_IRQ\",\n\t\t\"res26\",\n\t\t\"res27\",\n\t\t\"MMU_ERR_IRQ\",\n\t\t\"OCP_ERR_IRQ\",\n\t\t\"SEC_ERR_IRQ\",\n\t\t\"HS_VS_IRQ\",\n\t};\n\tint i;\n\n\tdev_dbg(isp->dev, \"ISP IRQ: \");\n\n\tfor (i = 0; i < ARRAY_SIZE(name); i++) {\n\t\tif ((1 << i) & irqstatus)\n\t\t\tprintk(KERN_CONT \"%s \", name[i]);\n\t}\n\tprintk(KERN_CONT \"\\n\");\n}\n\nstatic void isp_isr_sbl(struct isp_device *isp)\n{\n\tstruct device *dev = isp->dev;\n\tstruct isp_pipeline *pipe;\n\tu32 sbl_pcr;\n\n\t \n\tsbl_pcr = isp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_PCR);\n\tisp_reg_writel(isp, sbl_pcr, OMAP3_ISP_IOMEM_SBL, ISPSBL_PCR);\n\tsbl_pcr &= ~ISPSBL_PCR_CCDCPRV_2_RSZ_OVF;\n\n\tif (sbl_pcr)\n\t\tdev_dbg(dev, \"SBL overflow (PCR = 0x%08x)\\n\", sbl_pcr);\n\n\tif (sbl_pcr & ISPSBL_PCR_CSIB_WBL_OVF) {\n\t\tpipe = to_isp_pipeline(&isp->isp_ccp2.subdev.entity);\n\t\tif (pipe != NULL)\n\t\t\tpipe->error = true;\n\t}\n\n\tif (sbl_pcr & ISPSBL_PCR_CSIA_WBL_OVF) {\n\t\tpipe = to_isp_pipeline(&isp->isp_csi2a.subdev.entity);\n\t\tif (pipe != NULL)\n\t\t\tpipe->error = true;\n\t}\n\n\tif (sbl_pcr & ISPSBL_PCR_CCDC_WBL_OVF) {\n\t\tpipe = to_isp_pipeline(&isp->isp_ccdc.subdev.entity);\n\t\tif (pipe != NULL)\n\t\t\tpipe->error = true;\n\t}\n\n\tif (sbl_pcr & ISPSBL_PCR_PRV_WBL_OVF) {\n\t\tpipe = to_isp_pipeline(&isp->isp_prev.subdev.entity);\n\t\tif (pipe != NULL)\n\t\t\tpipe->error = true;\n\t}\n\n\tif (sbl_pcr & (ISPSBL_PCR_RSZ1_WBL_OVF\n\t\t       | ISPSBL_PCR_RSZ2_WBL_OVF\n\t\t       | ISPSBL_PCR_RSZ3_WBL_OVF\n\t\t       | ISPSBL_PCR_RSZ4_WBL_OVF)) {\n\t\tpipe = to_isp_pipeline(&isp->isp_res.subdev.entity);\n\t\tif (pipe != NULL)\n\t\t\tpipe->error = true;\n\t}\n\n\tif (sbl_pcr & ISPSBL_PCR_H3A_AF_WBL_OVF)\n\t\tomap3isp_stat_sbl_overflow(&isp->isp_af);\n\n\tif (sbl_pcr & ISPSBL_PCR_H3A_AEAWB_WBL_OVF)\n\t\tomap3isp_stat_sbl_overflow(&isp->isp_aewb);\n}\n\n \nstatic irqreturn_t isp_isr(int irq, void *_isp)\n{\n\tstatic const u32 ccdc_events = IRQ0STATUS_CCDC_LSC_PREF_ERR_IRQ |\n\t\t\t\t       IRQ0STATUS_CCDC_LSC_DONE_IRQ |\n\t\t\t\t       IRQ0STATUS_CCDC_VD0_IRQ |\n\t\t\t\t       IRQ0STATUS_CCDC_VD1_IRQ |\n\t\t\t\t       IRQ0STATUS_HS_VS_IRQ;\n\tstruct isp_device *isp = _isp;\n\tu32 irqstatus;\n\n\tirqstatus = isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\n\tisp_reg_writel(isp, irqstatus, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\n\n\tisp_isr_sbl(isp);\n\n\tif (irqstatus & IRQ0STATUS_CSIA_IRQ)\n\t\tomap3isp_csi2_isr(&isp->isp_csi2a);\n\n\tif (irqstatus & IRQ0STATUS_CSIB_IRQ)\n\t\tomap3isp_ccp2_isr(&isp->isp_ccp2);\n\n\tif (irqstatus & IRQ0STATUS_CCDC_VD0_IRQ) {\n\t\tif (isp->isp_ccdc.output & CCDC_OUTPUT_PREVIEW)\n\t\t\tomap3isp_preview_isr_frame_sync(&isp->isp_prev);\n\t\tif (isp->isp_ccdc.output & CCDC_OUTPUT_RESIZER)\n\t\t\tomap3isp_resizer_isr_frame_sync(&isp->isp_res);\n\t\tomap3isp_stat_isr_frame_sync(&isp->isp_aewb);\n\t\tomap3isp_stat_isr_frame_sync(&isp->isp_af);\n\t\tomap3isp_stat_isr_frame_sync(&isp->isp_hist);\n\t}\n\n\tif (irqstatus & ccdc_events)\n\t\tomap3isp_ccdc_isr(&isp->isp_ccdc, irqstatus & ccdc_events);\n\n\tif (irqstatus & IRQ0STATUS_PRV_DONE_IRQ) {\n\t\tif (isp->isp_prev.output & PREVIEW_OUTPUT_RESIZER)\n\t\t\tomap3isp_resizer_isr_frame_sync(&isp->isp_res);\n\t\tomap3isp_preview_isr(&isp->isp_prev);\n\t}\n\n\tif (irqstatus & IRQ0STATUS_RSZ_DONE_IRQ)\n\t\tomap3isp_resizer_isr(&isp->isp_res);\n\n\tif (irqstatus & IRQ0STATUS_H3A_AWB_DONE_IRQ)\n\t\tomap3isp_stat_isr(&isp->isp_aewb);\n\n\tif (irqstatus & IRQ0STATUS_H3A_AF_DONE_IRQ)\n\t\tomap3isp_stat_isr(&isp->isp_af);\n\n\tif (irqstatus & IRQ0STATUS_HIST_DONE_IRQ)\n\t\tomap3isp_stat_isr(&isp->isp_hist);\n\n\tomap3isp_flush(isp);\n\n#if defined(DEBUG) && defined(ISP_ISR_DEBUG)\n\tisp_isr_dbg(isp, irqstatus);\n#endif\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct media_device_ops isp_media_ops = {\n\t.link_notify = v4l2_pipeline_link_notify,\n};\n\n \n\n \nstatic int isp_pipeline_enable(struct isp_pipeline *pipe,\n\t\t\t       enum isp_pipeline_stream_state mode)\n{\n\tstruct isp_device *isp = pipe->output->isp;\n\tstruct media_entity *entity;\n\tstruct media_pad *pad;\n\tstruct v4l2_subdev *subdev;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tif (media_entity_enum_intersects(&pipe->ent_enum, &isp->crashed))\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&pipe->lock, flags);\n\tpipe->state &= ~(ISP_PIPELINE_IDLE_INPUT | ISP_PIPELINE_IDLE_OUTPUT);\n\tspin_unlock_irqrestore(&pipe->lock, flags);\n\n\tpipe->do_propagation = false;\n\n\tmutex_lock(&isp->media_dev.graph_mutex);\n\n\tentity = &pipe->output->video.entity;\n\twhile (1) {\n\t\tpad = &entity->pads[0];\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tbreak;\n\n\t\tpad = media_pad_remote_pad_first(pad);\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tbreak;\n\n\t\tentity = pad->entity;\n\t\tsubdev = media_entity_to_v4l2_subdev(entity);\n\n\t\tret = v4l2_subdev_call(subdev, video, s_stream, mode);\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD) {\n\t\t\tmutex_unlock(&isp->media_dev.graph_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (subdev == &isp->isp_ccdc.subdev) {\n\t\t\tv4l2_subdev_call(&isp->isp_aewb.subdev, video,\n\t\t\t\t\ts_stream, mode);\n\t\t\tv4l2_subdev_call(&isp->isp_af.subdev, video,\n\t\t\t\t\ts_stream, mode);\n\t\t\tv4l2_subdev_call(&isp->isp_hist.subdev, video,\n\t\t\t\t\ts_stream, mode);\n\t\t\tpipe->do_propagation = true;\n\t\t}\n\n\t\t \n\t\tif (subdev->dev != isp->dev)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&isp->media_dev.graph_mutex);\n\n\treturn 0;\n}\n\nstatic int isp_pipeline_wait_resizer(struct isp_device *isp)\n{\n\treturn omap3isp_resizer_busy(&isp->isp_res);\n}\n\nstatic int isp_pipeline_wait_preview(struct isp_device *isp)\n{\n\treturn omap3isp_preview_busy(&isp->isp_prev);\n}\n\nstatic int isp_pipeline_wait_ccdc(struct isp_device *isp)\n{\n\treturn omap3isp_stat_busy(&isp->isp_af)\n\t    || omap3isp_stat_busy(&isp->isp_aewb)\n\t    || omap3isp_stat_busy(&isp->isp_hist)\n\t    || omap3isp_ccdc_busy(&isp->isp_ccdc);\n}\n\n#define ISP_STOP_TIMEOUT\tmsecs_to_jiffies(1000)\n\nstatic int isp_pipeline_wait(struct isp_device *isp,\n\t\t\t     int(*busy)(struct isp_device *isp))\n{\n\tunsigned long timeout = jiffies + ISP_STOP_TIMEOUT;\n\n\twhile (!time_after(jiffies, timeout)) {\n\t\tif (!busy(isp))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int isp_pipeline_disable(struct isp_pipeline *pipe)\n{\n\tstruct isp_device *isp = pipe->output->isp;\n\tstruct media_entity *entity;\n\tstruct media_pad *pad;\n\tstruct v4l2_subdev *subdev;\n\tint failure = 0;\n\tint ret;\n\n\t \n\tentity = &pipe->output->video.entity;\n\twhile (1) {\n\t\tpad = &entity->pads[0];\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tbreak;\n\n\t\tpad = media_pad_remote_pad_first(pad);\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tbreak;\n\n\t\tentity = pad->entity;\n\t\tsubdev = media_entity_to_v4l2_subdev(entity);\n\n\t\tif (subdev == &isp->isp_ccdc.subdev) {\n\t\t\tv4l2_subdev_call(&isp->isp_aewb.subdev,\n\t\t\t\t\t video, s_stream, 0);\n\t\t\tv4l2_subdev_call(&isp->isp_af.subdev,\n\t\t\t\t\t video, s_stream, 0);\n\t\t\tv4l2_subdev_call(&isp->isp_hist.subdev,\n\t\t\t\t\t video, s_stream, 0);\n\t\t}\n\n\t\tret = v4l2_subdev_call(subdev, video, s_stream, 0);\n\n\t\t \n\t\tif (subdev->dev != isp->dev)\n\t\t\tbreak;\n\n\t\tif (subdev == &isp->isp_res.subdev)\n\t\t\tret |= isp_pipeline_wait(isp, isp_pipeline_wait_resizer);\n\t\telse if (subdev == &isp->isp_prev.subdev)\n\t\t\tret |= isp_pipeline_wait(isp, isp_pipeline_wait_preview);\n\t\telse if (subdev == &isp->isp_ccdc.subdev)\n\t\t\tret |= isp_pipeline_wait(isp, isp_pipeline_wait_ccdc);\n\n\t\t \n\t\tif (ret) {\n\t\t\tdev_info(isp->dev, \"Unable to stop %s\\n\", subdev->name);\n\t\t\tisp->stop_failure = true;\n\t\t\tif (subdev == &isp->isp_prev.subdev)\n\t\t\t\tmedia_entity_enum_set(&isp->crashed,\n\t\t\t\t\t\t      &subdev->entity);\n\t\t\tfailure = -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn failure;\n}\n\n \nint omap3isp_pipeline_set_stream(struct isp_pipeline *pipe,\n\t\t\t\t enum isp_pipeline_stream_state state)\n{\n\tint ret;\n\n\tif (state == ISP_PIPELINE_STREAM_STOPPED)\n\t\tret = isp_pipeline_disable(pipe);\n\telse\n\t\tret = isp_pipeline_enable(pipe, state);\n\n\tif (ret == 0 || state == ISP_PIPELINE_STREAM_STOPPED)\n\t\tpipe->stream_state = state;\n\n\treturn ret;\n}\n\n \nvoid omap3isp_pipeline_cancel_stream(struct isp_pipeline *pipe)\n{\n\tif (pipe->input)\n\t\tomap3isp_video_cancel_stream(pipe->input);\n\tif (pipe->output)\n\t\tomap3isp_video_cancel_stream(pipe->output);\n}\n\n \nstatic void isp_pipeline_resume(struct isp_pipeline *pipe)\n{\n\tint singleshot = pipe->stream_state == ISP_PIPELINE_STREAM_SINGLESHOT;\n\n\tomap3isp_video_resume(pipe->output, !singleshot);\n\tif (singleshot)\n\t\tomap3isp_video_resume(pipe->input, 0);\n\tisp_pipeline_enable(pipe, pipe->stream_state);\n}\n\n \nstatic void isp_pipeline_suspend(struct isp_pipeline *pipe)\n{\n\tisp_pipeline_disable(pipe);\n}\n\n \nstatic int isp_pipeline_is_last(struct media_entity *me)\n{\n\tstruct isp_pipeline *pipe;\n\tstruct media_pad *pad;\n\n\tpipe = to_isp_pipeline(me);\n\tif (!pipe || pipe->stream_state == ISP_PIPELINE_STREAM_STOPPED)\n\t\treturn 0;\n\tpad = media_pad_remote_pad_first(&pipe->output->pad);\n\treturn pad->entity == me;\n}\n\n \nstatic void isp_suspend_module_pipeline(struct media_entity *me)\n{\n\tif (isp_pipeline_is_last(me))\n\t\tisp_pipeline_suspend(to_isp_pipeline(me));\n}\n\n \nstatic void isp_resume_module_pipeline(struct media_entity *me)\n{\n\tif (isp_pipeline_is_last(me))\n\t\tisp_pipeline_resume(to_isp_pipeline(me));\n}\n\n \nstatic int __maybe_unused isp_suspend_modules(struct isp_device *isp)\n{\n\tunsigned long timeout;\n\n\tomap3isp_stat_suspend(&isp->isp_aewb);\n\tomap3isp_stat_suspend(&isp->isp_af);\n\tomap3isp_stat_suspend(&isp->isp_hist);\n\tisp_suspend_module_pipeline(&isp->isp_res.subdev.entity);\n\tisp_suspend_module_pipeline(&isp->isp_prev.subdev.entity);\n\tisp_suspend_module_pipeline(&isp->isp_ccdc.subdev.entity);\n\tisp_suspend_module_pipeline(&isp->isp_csi2a.subdev.entity);\n\tisp_suspend_module_pipeline(&isp->isp_ccp2.subdev.entity);\n\n\ttimeout = jiffies + ISP_STOP_TIMEOUT;\n\twhile (omap3isp_stat_busy(&isp->isp_af)\n\t    || omap3isp_stat_busy(&isp->isp_aewb)\n\t    || omap3isp_stat_busy(&isp->isp_hist)\n\t    || omap3isp_preview_busy(&isp->isp_prev)\n\t    || omap3isp_resizer_busy(&isp->isp_res)\n\t    || omap3isp_ccdc_busy(&isp->isp_ccdc)) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_info(isp->dev, \"can't stop modules.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __maybe_unused isp_resume_modules(struct isp_device *isp)\n{\n\tomap3isp_stat_resume(&isp->isp_aewb);\n\tomap3isp_stat_resume(&isp->isp_af);\n\tomap3isp_stat_resume(&isp->isp_hist);\n\tisp_resume_module_pipeline(&isp->isp_res.subdev.entity);\n\tisp_resume_module_pipeline(&isp->isp_prev.subdev.entity);\n\tisp_resume_module_pipeline(&isp->isp_ccdc.subdev.entity);\n\tisp_resume_module_pipeline(&isp->isp_csi2a.subdev.entity);\n\tisp_resume_module_pipeline(&isp->isp_ccp2.subdev.entity);\n}\n\n \nstatic int isp_reset(struct isp_device *isp)\n{\n\tunsigned long timeout = 0;\n\n\tisp_reg_writel(isp,\n\t\t       isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG)\n\t\t       | ISP_SYSCONFIG_SOFTRESET,\n\t\t       OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG);\n\twhile (!(isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN,\n\t\t\t       ISP_SYSSTATUS) & 0x1)) {\n\t\tif (timeout++ > 10000) {\n\t\t\tdev_alert(isp->dev, \"cannot reset ISP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\tisp->stop_failure = false;\n\tmedia_entity_enum_zero(&isp->crashed);\n\treturn 0;\n}\n\n \nstatic void\nisp_save_context(struct isp_device *isp, struct isp_reg *reg_list)\n{\n\tstruct isp_reg *next = reg_list;\n\n\tfor (; next->reg != ISP_TOK_TERM; next++)\n\t\tnext->val = isp_reg_readl(isp, next->mmio_range, next->reg);\n}\n\n \nstatic void\nisp_restore_context(struct isp_device *isp, struct isp_reg *reg_list)\n{\n\tstruct isp_reg *next = reg_list;\n\n\tfor (; next->reg != ISP_TOK_TERM; next++)\n\t\tisp_reg_writel(isp, next->val, next->mmio_range, next->reg);\n}\n\n \nstatic void isp_save_ctx(struct isp_device *isp)\n{\n\tisp_save_context(isp, isp_reg_list);\n\tomap_iommu_save_ctx(isp->dev);\n}\n\n \nstatic void isp_restore_ctx(struct isp_device *isp)\n{\n\tisp_restore_context(isp, isp_reg_list);\n\tomap_iommu_restore_ctx(isp->dev);\n\tomap3isp_ccdc_restore_context(isp);\n\tomap3isp_preview_restore_context(isp);\n}\n\n \n#define OMAP3_ISP_SBL_READ\t(OMAP3_ISP_SBL_CSI1_READ | \\\n\t\t\t\t OMAP3_ISP_SBL_CCDC_LSC_READ | \\\n\t\t\t\t OMAP3_ISP_SBL_PREVIEW_READ | \\\n\t\t\t\t OMAP3_ISP_SBL_RESIZER_READ)\n#define OMAP3_ISP_SBL_WRITE\t(OMAP3_ISP_SBL_CSI1_WRITE | \\\n\t\t\t\t OMAP3_ISP_SBL_CSI2A_WRITE | \\\n\t\t\t\t OMAP3_ISP_SBL_CSI2C_WRITE | \\\n\t\t\t\t OMAP3_ISP_SBL_CCDC_WRITE | \\\n\t\t\t\t OMAP3_ISP_SBL_PREVIEW_WRITE)\n\nvoid omap3isp_sbl_enable(struct isp_device *isp, enum isp_sbl_resource res)\n{\n\tu32 sbl = 0;\n\n\tisp->sbl_resources |= res;\n\n\tif (isp->sbl_resources & OMAP3_ISP_SBL_CSI1_READ)\n\t\tsbl |= ISPCTRL_SBL_SHARED_RPORTA;\n\n\tif (isp->sbl_resources & OMAP3_ISP_SBL_CCDC_LSC_READ)\n\t\tsbl |= ISPCTRL_SBL_SHARED_RPORTB;\n\n\tif (isp->sbl_resources & OMAP3_ISP_SBL_CSI2C_WRITE)\n\t\tsbl |= ISPCTRL_SBL_SHARED_WPORTC;\n\n\tif (isp->sbl_resources & OMAP3_ISP_SBL_RESIZER_WRITE)\n\t\tsbl |= ISPCTRL_SBL_WR0_RAM_EN;\n\n\tif (isp->sbl_resources & OMAP3_ISP_SBL_WRITE)\n\t\tsbl |= ISPCTRL_SBL_WR1_RAM_EN;\n\n\tif (isp->sbl_resources & OMAP3_ISP_SBL_READ)\n\t\tsbl |= ISPCTRL_SBL_RD_RAM_EN;\n\n\tisp_reg_set(isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL, sbl);\n}\n\nvoid omap3isp_sbl_disable(struct isp_device *isp, enum isp_sbl_resource res)\n{\n\tu32 sbl = 0;\n\n\tisp->sbl_resources &= ~res;\n\n\tif (!(isp->sbl_resources & OMAP3_ISP_SBL_CSI1_READ))\n\t\tsbl |= ISPCTRL_SBL_SHARED_RPORTA;\n\n\tif (!(isp->sbl_resources & OMAP3_ISP_SBL_CCDC_LSC_READ))\n\t\tsbl |= ISPCTRL_SBL_SHARED_RPORTB;\n\n\tif (!(isp->sbl_resources & OMAP3_ISP_SBL_CSI2C_WRITE))\n\t\tsbl |= ISPCTRL_SBL_SHARED_WPORTC;\n\n\tif (!(isp->sbl_resources & OMAP3_ISP_SBL_RESIZER_WRITE))\n\t\tsbl |= ISPCTRL_SBL_WR0_RAM_EN;\n\n\tif (!(isp->sbl_resources & OMAP3_ISP_SBL_WRITE))\n\t\tsbl |= ISPCTRL_SBL_WR1_RAM_EN;\n\n\tif (!(isp->sbl_resources & OMAP3_ISP_SBL_READ))\n\t\tsbl |= ISPCTRL_SBL_RD_RAM_EN;\n\n\tisp_reg_clr(isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL, sbl);\n}\n\n \nint omap3isp_module_sync_idle(struct media_entity *me, wait_queue_head_t *wait,\n\t\t\t      atomic_t *stopping)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(me);\n\n\tif (pipe->stream_state == ISP_PIPELINE_STREAM_STOPPED ||\n\t    (pipe->stream_state == ISP_PIPELINE_STREAM_SINGLESHOT &&\n\t     !isp_pipeline_ready(pipe)))\n\t\treturn 0;\n\n\t \n\tatomic_set(stopping, 1);\n\tsmp_mb();\n\n\t \n\tif (isp_pipeline_is_last(me)) {\n\t\tstruct isp_video *video = pipe->output;\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&video->irqlock, flags);\n\t\tif (video->dmaqueue_flags & ISP_VIDEO_DMAQUEUE_UNDERRUN) {\n\t\t\tspin_unlock_irqrestore(&video->irqlock, flags);\n\t\t\tatomic_set(stopping, 0);\n\t\t\tsmp_mb();\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock_irqrestore(&video->irqlock, flags);\n\t\tif (!wait_event_timeout(*wait, !atomic_read(stopping),\n\t\t\t\t\tmsecs_to_jiffies(1000))) {\n\t\t\tatomic_set(stopping, 0);\n\t\t\tsmp_mb();\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint omap3isp_module_sync_is_stopping(wait_queue_head_t *wait,\n\t\t\t\t     atomic_t *stopping)\n{\n\tif (atomic_cmpxchg(stopping, 1, 0)) {\n\t\twake_up(wait);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \n\n#define ISPCTRL_CLKS_MASK\t(ISPCTRL_H3A_CLK_EN | \\\n\t\t\t\t ISPCTRL_HIST_CLK_EN | \\\n\t\t\t\t ISPCTRL_RSZ_CLK_EN | \\\n\t\t\t\t (ISPCTRL_CCDC_CLK_EN | ISPCTRL_CCDC_RAM_EN) | \\\n\t\t\t\t (ISPCTRL_PREV_CLK_EN | ISPCTRL_PREV_RAM_EN))\n\nstatic void __isp_subclk_update(struct isp_device *isp)\n{\n\tu32 clk = 0;\n\n\t \n\tif (isp->subclk_resources &\n\t    (OMAP3_ISP_SUBCLK_AEWB | OMAP3_ISP_SUBCLK_AF))\n\t\tclk |= ISPCTRL_H3A_CLK_EN;\n\n\tif (isp->subclk_resources & OMAP3_ISP_SUBCLK_HIST)\n\t\tclk |= ISPCTRL_HIST_CLK_EN;\n\n\tif (isp->subclk_resources & OMAP3_ISP_SUBCLK_RESIZER)\n\t\tclk |= ISPCTRL_RSZ_CLK_EN;\n\n\t \n\tif (isp->subclk_resources & OMAP3_ISP_SUBCLK_CCDC)\n\t\tclk |= ISPCTRL_CCDC_CLK_EN | ISPCTRL_CCDC_RAM_EN;\n\n\tif (isp->subclk_resources & OMAP3_ISP_SUBCLK_PREVIEW)\n\t\tclk |= ISPCTRL_PREV_CLK_EN | ISPCTRL_PREV_RAM_EN;\n\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,\n\t\t\tISPCTRL_CLKS_MASK, clk);\n}\n\nvoid omap3isp_subclk_enable(struct isp_device *isp,\n\t\t\t    enum isp_subclk_resource res)\n{\n\tisp->subclk_resources |= res;\n\n\t__isp_subclk_update(isp);\n}\n\nvoid omap3isp_subclk_disable(struct isp_device *isp,\n\t\t\t     enum isp_subclk_resource res)\n{\n\tisp->subclk_resources &= ~res;\n\n\t__isp_subclk_update(isp);\n}\n\n \nstatic int isp_enable_clocks(struct isp_device *isp)\n{\n\tint r;\n\tunsigned long rate;\n\n\tr = clk_prepare_enable(isp->clock[ISP_CLK_CAM_ICK]);\n\tif (r) {\n\t\tdev_err(isp->dev, \"failed to enable cam_ick clock\\n\");\n\t\tgoto out_clk_enable_ick;\n\t}\n\tr = clk_set_rate(isp->clock[ISP_CLK_CAM_MCLK], CM_CAM_MCLK_HZ);\n\tif (r) {\n\t\tdev_err(isp->dev, \"clk_set_rate for cam_mclk failed\\n\");\n\t\tgoto out_clk_enable_mclk;\n\t}\n\tr = clk_prepare_enable(isp->clock[ISP_CLK_CAM_MCLK]);\n\tif (r) {\n\t\tdev_err(isp->dev, \"failed to enable cam_mclk clock\\n\");\n\t\tgoto out_clk_enable_mclk;\n\t}\n\trate = clk_get_rate(isp->clock[ISP_CLK_CAM_MCLK]);\n\tif (rate != CM_CAM_MCLK_HZ)\n\t\tdev_warn(isp->dev, \"unexpected cam_mclk rate:\\n\"\n\t\t\t\t   \" expected : %d\\n\"\n\t\t\t\t   \" actual   : %ld\\n\", CM_CAM_MCLK_HZ, rate);\n\tr = clk_prepare_enable(isp->clock[ISP_CLK_CSI2_FCK]);\n\tif (r) {\n\t\tdev_err(isp->dev, \"failed to enable csi2_fck clock\\n\");\n\t\tgoto out_clk_enable_csi2_fclk;\n\t}\n\treturn 0;\n\nout_clk_enable_csi2_fclk:\n\tclk_disable_unprepare(isp->clock[ISP_CLK_CAM_MCLK]);\nout_clk_enable_mclk:\n\tclk_disable_unprepare(isp->clock[ISP_CLK_CAM_ICK]);\nout_clk_enable_ick:\n\treturn r;\n}\n\n \nstatic void isp_disable_clocks(struct isp_device *isp)\n{\n\tclk_disable_unprepare(isp->clock[ISP_CLK_CAM_ICK]);\n\tclk_disable_unprepare(isp->clock[ISP_CLK_CAM_MCLK]);\n\tclk_disable_unprepare(isp->clock[ISP_CLK_CSI2_FCK]);\n}\n\nstatic const char *isp_clocks[] = {\n\t\"cam_ick\",\n\t\"cam_mclk\",\n\t\"csi2_96m_fck\",\n\t\"l3_ick\",\n};\n\nstatic int isp_get_clocks(struct isp_device *isp)\n{\n\tstruct clk *clk;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(isp_clocks); ++i) {\n\t\tclk = devm_clk_get(isp->dev, isp_clocks[i]);\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_err(isp->dev, \"clk_get %s failed\\n\", isp_clocks[i]);\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\n\t\tisp->clock[i] = clk;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct isp_device *__omap3isp_get(struct isp_device *isp, bool irq)\n{\n\tstruct isp_device *__isp = isp;\n\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tmutex_lock(&isp->isp_mutex);\n\tif (isp->ref_count > 0)\n\t\tgoto out;\n\n\tif (isp_enable_clocks(isp) < 0) {\n\t\t__isp = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (isp->has_context)\n\t\tisp_restore_ctx(isp);\n\n\tif (irq)\n\t\tisp_enable_interrupts(isp);\n\nout:\n\tif (__isp != NULL)\n\t\tisp->ref_count++;\n\tmutex_unlock(&isp->isp_mutex);\n\n\treturn __isp;\n}\n\nstruct isp_device *omap3isp_get(struct isp_device *isp)\n{\n\treturn __omap3isp_get(isp, true);\n}\n\n \nstatic void __omap3isp_put(struct isp_device *isp, bool save_ctx)\n{\n\tif (isp == NULL)\n\t\treturn;\n\n\tmutex_lock(&isp->isp_mutex);\n\tBUG_ON(isp->ref_count == 0);\n\tif (--isp->ref_count == 0) {\n\t\tisp_disable_interrupts(isp);\n\t\tif (save_ctx) {\n\t\t\tisp_save_ctx(isp);\n\t\t\tisp->has_context = 1;\n\t\t}\n\t\t \n\t\tif (!media_entity_enum_empty(&isp->crashed) ||\n\t\t    isp->stop_failure)\n\t\t\tisp_reset(isp);\n\t\tisp_disable_clocks(isp);\n\t}\n\tmutex_unlock(&isp->isp_mutex);\n}\n\nvoid omap3isp_put(struct isp_device *isp)\n{\n\t__omap3isp_put(isp, true);\n}\n\n \n\n \n#define ISP_PRINT_REGISTER(isp, name)\\\n\tdev_dbg(isp->dev, \"###ISP \" #name \"=0x%08x\\n\", \\\n\t\tisp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_##name))\n#define SBL_PRINT_REGISTER(isp, name)\\\n\tdev_dbg(isp->dev, \"###SBL \" #name \"=0x%08x\\n\", \\\n\t\tisp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_##name))\n\nvoid omap3isp_print_status(struct isp_device *isp)\n{\n\tdev_dbg(isp->dev, \"-------------ISP Register dump--------------\\n\");\n\n\tISP_PRINT_REGISTER(isp, SYSCONFIG);\n\tISP_PRINT_REGISTER(isp, SYSSTATUS);\n\tISP_PRINT_REGISTER(isp, IRQ0ENABLE);\n\tISP_PRINT_REGISTER(isp, IRQ0STATUS);\n\tISP_PRINT_REGISTER(isp, TCTRL_GRESET_LENGTH);\n\tISP_PRINT_REGISTER(isp, TCTRL_PSTRB_REPLAY);\n\tISP_PRINT_REGISTER(isp, CTRL);\n\tISP_PRINT_REGISTER(isp, TCTRL_CTRL);\n\tISP_PRINT_REGISTER(isp, TCTRL_FRAME);\n\tISP_PRINT_REGISTER(isp, TCTRL_PSTRB_DELAY);\n\tISP_PRINT_REGISTER(isp, TCTRL_STRB_DELAY);\n\tISP_PRINT_REGISTER(isp, TCTRL_SHUT_DELAY);\n\tISP_PRINT_REGISTER(isp, TCTRL_PSTRB_LENGTH);\n\tISP_PRINT_REGISTER(isp, TCTRL_STRB_LENGTH);\n\tISP_PRINT_REGISTER(isp, TCTRL_SHUT_LENGTH);\n\n\tSBL_PRINT_REGISTER(isp, PCR);\n\tSBL_PRINT_REGISTER(isp, SDR_REQ_EXP);\n\n\tdev_dbg(isp->dev, \"--------------------------------------------\\n\");\n}\n\n#ifdef CONFIG_PM\n\n \nstatic int isp_pm_prepare(struct device *dev)\n{\n\tstruct isp_device *isp = dev_get_drvdata(dev);\n\tint reset;\n\n\tWARN_ON(mutex_is_locked(&isp->isp_mutex));\n\n\tif (isp->ref_count == 0)\n\t\treturn 0;\n\n\treset = isp_suspend_modules(isp);\n\tisp_disable_interrupts(isp);\n\tisp_save_ctx(isp);\n\tif (reset)\n\t\tisp_reset(isp);\n\n\treturn 0;\n}\n\nstatic int isp_pm_suspend(struct device *dev)\n{\n\tstruct isp_device *isp = dev_get_drvdata(dev);\n\n\tWARN_ON(mutex_is_locked(&isp->isp_mutex));\n\n\tif (isp->ref_count)\n\t\tisp_disable_clocks(isp);\n\n\treturn 0;\n}\n\nstatic int isp_pm_resume(struct device *dev)\n{\n\tstruct isp_device *isp = dev_get_drvdata(dev);\n\n\tif (isp->ref_count == 0)\n\t\treturn 0;\n\n\treturn isp_enable_clocks(isp);\n}\n\nstatic void isp_pm_complete(struct device *dev)\n{\n\tstruct isp_device *isp = dev_get_drvdata(dev);\n\n\tif (isp->ref_count == 0)\n\t\treturn;\n\n\tisp_restore_ctx(isp);\n\tisp_enable_interrupts(isp);\n\tisp_resume_modules(isp);\n}\n\n#else\n\n#define isp_pm_prepare\tNULL\n#define isp_pm_suspend\tNULL\n#define isp_pm_resume\tNULL\n#define isp_pm_complete\tNULL\n\n#endif  \n\nstatic void isp_unregister_entities(struct isp_device *isp)\n{\n\tmedia_device_unregister(&isp->media_dev);\n\n\tomap3isp_csi2_unregister_entities(&isp->isp_csi2a);\n\tomap3isp_ccp2_unregister_entities(&isp->isp_ccp2);\n\tomap3isp_ccdc_unregister_entities(&isp->isp_ccdc);\n\tomap3isp_preview_unregister_entities(&isp->isp_prev);\n\tomap3isp_resizer_unregister_entities(&isp->isp_res);\n\tomap3isp_stat_unregister_entities(&isp->isp_aewb);\n\tomap3isp_stat_unregister_entities(&isp->isp_af);\n\tomap3isp_stat_unregister_entities(&isp->isp_hist);\n\n\tv4l2_device_unregister(&isp->v4l2_dev);\n\tmedia_device_cleanup(&isp->media_dev);\n}\n\nstatic int isp_link_entity(\n\tstruct isp_device *isp, struct media_entity *entity,\n\tenum isp_interface_type interface)\n{\n\tstruct media_entity *input;\n\tunsigned int flags;\n\tunsigned int pad;\n\tunsigned int i;\n\n\t \n\tswitch (interface) {\n\tcase ISP_INTERFACE_PARALLEL:\n\t\tinput = &isp->isp_ccdc.subdev.entity;\n\t\tpad = CCDC_PAD_SINK;\n\t\tflags = 0;\n\t\tbreak;\n\n\tcase ISP_INTERFACE_CSI2A_PHY2:\n\t\tinput = &isp->isp_csi2a.subdev.entity;\n\t\tpad = CSI2_PAD_SINK;\n\t\tflags = MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED;\n\t\tbreak;\n\n\tcase ISP_INTERFACE_CCP2B_PHY1:\n\tcase ISP_INTERFACE_CCP2B_PHY2:\n\t\tinput = &isp->isp_ccp2.subdev.entity;\n\t\tpad = CCP2_PAD_SINK;\n\t\tflags = 0;\n\t\tbreak;\n\n\tcase ISP_INTERFACE_CSI2C_PHY1:\n\t\tinput = &isp->isp_csi2c.subdev.entity;\n\t\tpad = CSI2_PAD_SINK;\n\t\tflags = MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(isp->dev, \"%s: invalid interface type %u\\n\", __func__,\n\t\t\tinterface);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!input->num_pads) {\n\t\tdev_err(isp->dev, \"%s: invalid input %u\\n\", entity->name,\n\t\t\tinterface);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < entity->num_pads; i++) {\n\t\tif (entity->pads[i].flags & MEDIA_PAD_FL_SOURCE)\n\t\t\tbreak;\n\t}\n\tif (i == entity->num_pads) {\n\t\tdev_err(isp->dev, \"%s: no source pad in external entity %s\\n\",\n\t\t\t__func__, entity->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn media_create_pad_link(entity, i, input, pad, flags);\n}\n\nstatic int isp_register_entities(struct isp_device *isp)\n{\n\tint ret;\n\n\tisp->media_dev.dev = isp->dev;\n\tstrscpy(isp->media_dev.model, \"TI OMAP3 ISP\",\n\t\tsizeof(isp->media_dev.model));\n\tisp->media_dev.hw_revision = isp->revision;\n\tisp->media_dev.ops = &isp_media_ops;\n\tmedia_device_init(&isp->media_dev);\n\n\tisp->v4l2_dev.mdev = &isp->media_dev;\n\tret = v4l2_device_register(isp->dev, &isp->v4l2_dev);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"%s: V4L2 device registration failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\tgoto done;\n\t}\n\n\t \n\tret = omap3isp_ccp2_register_entities(&isp->isp_ccp2, &isp->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = omap3isp_csi2_register_entities(&isp->isp_csi2a, &isp->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = omap3isp_ccdc_register_entities(&isp->isp_ccdc, &isp->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = omap3isp_preview_register_entities(&isp->isp_prev,\n\t\t\t\t\t\t &isp->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = omap3isp_resizer_register_entities(&isp->isp_res, &isp->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = omap3isp_stat_register_entities(&isp->isp_aewb, &isp->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = omap3isp_stat_register_entities(&isp->isp_af, &isp->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = omap3isp_stat_register_entities(&isp->isp_hist, &isp->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto done;\n\ndone:\n\tif (ret < 0)\n\t\tisp_unregister_entities(isp);\n\n\treturn ret;\n}\n\n \nstatic int isp_create_links(struct isp_device *isp)\n{\n\tint ret;\n\n\t \n\tret = media_create_pad_link(\n\t\t\t&isp->isp_csi2a.subdev.entity, CSI2_PAD_SOURCE,\n\t\t\t&isp->isp_csi2a.video_out.video.entity, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_ccp2.video_in.video.entity, 0,\n\t\t\t&isp->isp_ccp2.subdev.entity, CCP2_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_OF,\n\t\t\t&isp->isp_ccdc.video_out.video.entity, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_prev.video_in.video.entity, 0,\n\t\t\t&isp->isp_prev.subdev.entity, PREV_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_prev.subdev.entity, PREV_PAD_SOURCE,\n\t\t\t&isp->isp_prev.video_out.video.entity, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_res.video_in.video.entity, 0,\n\t\t\t&isp->isp_res.subdev.entity, RESZ_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_res.subdev.entity, RESZ_PAD_SOURCE,\n\t\t\t&isp->isp_res.video_out.video.entity, 0, 0);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = media_create_pad_link(\n\t\t\t&isp->isp_csi2a.subdev.entity, CSI2_PAD_SOURCE,\n\t\t\t&isp->isp_ccdc.subdev.entity, CCDC_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_ccp2.subdev.entity, CCP2_PAD_SOURCE,\n\t\t\t&isp->isp_ccdc.subdev.entity, CCDC_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_VP,\n\t\t\t&isp->isp_prev.subdev.entity, PREV_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_OF,\n\t\t\t&isp->isp_res.subdev.entity, RESZ_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_prev.subdev.entity, PREV_PAD_SOURCE,\n\t\t\t&isp->isp_res.subdev.entity, RESZ_PAD_SINK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_VP,\n\t\t\t&isp->isp_aewb.subdev.entity, 0,\n\t\t\tMEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_VP,\n\t\t\t&isp->isp_af.subdev.entity, 0,\n\t\t\tMEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_create_pad_link(\n\t\t\t&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_VP,\n\t\t\t&isp->isp_hist.subdev.entity, 0,\n\t\t\tMEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void isp_cleanup_modules(struct isp_device *isp)\n{\n\tomap3isp_h3a_aewb_cleanup(isp);\n\tomap3isp_h3a_af_cleanup(isp);\n\tomap3isp_hist_cleanup(isp);\n\tomap3isp_resizer_cleanup(isp);\n\tomap3isp_preview_cleanup(isp);\n\tomap3isp_ccdc_cleanup(isp);\n\tomap3isp_ccp2_cleanup(isp);\n\tomap3isp_csi2_cleanup(isp);\n\tomap3isp_csiphy_cleanup(isp);\n}\n\nstatic int isp_initialize_modules(struct isp_device *isp)\n{\n\tint ret;\n\n\tret = omap3isp_csiphy_init(isp);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"CSI PHY initialization failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = omap3isp_csi2_init(isp);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"CSI2 initialization failed\\n\");\n\t\tgoto error_csi2;\n\t}\n\n\tret = omap3isp_ccp2_init(isp);\n\tif (ret < 0) {\n\t\tdev_err_probe(isp->dev, ret, \"CCP2 initialization failed\\n\");\n\t\tgoto error_ccp2;\n\t}\n\n\tret = omap3isp_ccdc_init(isp);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"CCDC initialization failed\\n\");\n\t\tgoto error_ccdc;\n\t}\n\n\tret = omap3isp_preview_init(isp);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"Preview initialization failed\\n\");\n\t\tgoto error_preview;\n\t}\n\n\tret = omap3isp_resizer_init(isp);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"Resizer initialization failed\\n\");\n\t\tgoto error_resizer;\n\t}\n\n\tret = omap3isp_hist_init(isp);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"Histogram initialization failed\\n\");\n\t\tgoto error_hist;\n\t}\n\n\tret = omap3isp_h3a_aewb_init(isp);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"H3A AEWB initialization failed\\n\");\n\t\tgoto error_h3a_aewb;\n\t}\n\n\tret = omap3isp_h3a_af_init(isp);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"H3A AF initialization failed\\n\");\n\t\tgoto error_h3a_af;\n\t}\n\n\treturn 0;\n\nerror_h3a_af:\n\tomap3isp_h3a_aewb_cleanup(isp);\nerror_h3a_aewb:\n\tomap3isp_hist_cleanup(isp);\nerror_hist:\n\tomap3isp_resizer_cleanup(isp);\nerror_resizer:\n\tomap3isp_preview_cleanup(isp);\nerror_preview:\n\tomap3isp_ccdc_cleanup(isp);\nerror_ccdc:\n\tomap3isp_ccp2_cleanup(isp);\nerror_ccp2:\n\tomap3isp_csi2_cleanup(isp);\nerror_csi2:\n\tomap3isp_csiphy_cleanup(isp);\n\n\treturn ret;\n}\n\nstatic void isp_detach_iommu(struct isp_device *isp)\n{\n#ifdef CONFIG_ARM_DMA_USE_IOMMU\n\tarm_iommu_detach_device(isp->dev);\n\tarm_iommu_release_mapping(isp->mapping);\n\tisp->mapping = NULL;\n#endif\n}\n\nstatic int isp_attach_iommu(struct isp_device *isp)\n{\n#ifdef CONFIG_ARM_DMA_USE_IOMMU\n\tstruct dma_iommu_mapping *mapping;\n\tint ret;\n\n\t \n\tmapping = arm_iommu_create_mapping(&platform_bus_type, SZ_1G, SZ_2G);\n\tif (IS_ERR(mapping)) {\n\t\tdev_err(isp->dev, \"failed to create ARM IOMMU mapping\\n\");\n\t\treturn PTR_ERR(mapping);\n\t}\n\n\tisp->mapping = mapping;\n\n\t \n\tret = arm_iommu_attach_device(isp->dev, mapping);\n\tif (ret < 0) {\n\t\tdev_err(isp->dev, \"failed to attach device to VA mapping\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tarm_iommu_release_mapping(isp->mapping);\n\tisp->mapping = NULL;\n\treturn ret;\n#else\n\treturn -ENODEV;\n#endif\n}\n\n \nstatic void isp_remove(struct platform_device *pdev)\n{\n\tstruct isp_device *isp = platform_get_drvdata(pdev);\n\n\tv4l2_async_nf_unregister(&isp->notifier);\n\tv4l2_async_nf_cleanup(&isp->notifier);\n\tisp_unregister_entities(isp);\n\tisp_cleanup_modules(isp);\n\tisp_xclk_cleanup(isp);\n\n\t__omap3isp_get(isp, false);\n\tisp_detach_iommu(isp);\n\t__omap3isp_put(isp, false);\n\n\tmedia_entity_enum_cleanup(&isp->crashed);\n\n\tkfree(isp);\n}\n\nenum isp_of_phy {\n\tISP_OF_PHY_PARALLEL = 0,\n\tISP_OF_PHY_CSIPHY1,\n\tISP_OF_PHY_CSIPHY2,\n};\n\nstatic int isp_subdev_notifier_bound(struct v4l2_async_notifier *async,\n\t\t\t\t     struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_async_connection *asc)\n{\n\tstruct isp_device *isp = container_of(async, struct isp_device,\n\t\t\t\t\t      notifier);\n\tstruct isp_bus_cfg *bus_cfg =\n\t\t&container_of(asc, struct isp_async_subdev, asd)->bus;\n\tint ret;\n\n\tmutex_lock(&isp->media_dev.graph_mutex);\n\tret = isp_link_entity(isp, &sd->entity, bus_cfg->interface);\n\tmutex_unlock(&isp->media_dev.graph_mutex);\n\n\treturn ret;\n}\n\nstatic int isp_subdev_notifier_complete(struct v4l2_async_notifier *async)\n{\n\tstruct isp_device *isp = container_of(async, struct isp_device,\n\t\t\t\t\t      notifier);\n\tint ret;\n\n\tmutex_lock(&isp->media_dev.graph_mutex);\n\tret = media_entity_enum_init(&isp->crashed, &isp->media_dev);\n\tmutex_unlock(&isp->media_dev.graph_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_device_register_subdev_nodes(&isp->v4l2_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn media_device_register(&isp->media_dev);\n}\n\nstatic void isp_parse_of_parallel_endpoint(struct device *dev,\n\t\t\t\t\t   struct v4l2_fwnode_endpoint *vep,\n\t\t\t\t\t   struct isp_bus_cfg *buscfg)\n{\n\tbuscfg->interface = ISP_INTERFACE_PARALLEL;\n\tbuscfg->bus.parallel.data_lane_shift = vep->bus.parallel.data_shift;\n\tbuscfg->bus.parallel.clk_pol =\n\t\t!!(vep->bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_FALLING);\n\tbuscfg->bus.parallel.hs_pol =\n\t\t!!(vep->bus.parallel.flags & V4L2_MBUS_VSYNC_ACTIVE_LOW);\n\tbuscfg->bus.parallel.vs_pol =\n\t\t!!(vep->bus.parallel.flags & V4L2_MBUS_HSYNC_ACTIVE_LOW);\n\tbuscfg->bus.parallel.fld_pol =\n\t\t!!(vep->bus.parallel.flags & V4L2_MBUS_FIELD_EVEN_LOW);\n\tbuscfg->bus.parallel.data_pol =\n\t\t!!(vep->bus.parallel.flags & V4L2_MBUS_DATA_ACTIVE_LOW);\n\tbuscfg->bus.parallel.bt656 = vep->bus_type == V4L2_MBUS_BT656;\n}\n\nstatic void isp_parse_of_csi2_endpoint(struct device *dev,\n\t\t\t\t       struct v4l2_fwnode_endpoint *vep,\n\t\t\t\t       struct isp_bus_cfg *buscfg)\n{\n\tunsigned int i;\n\n\tbuscfg->bus.csi2.lanecfg.clk.pos = vep->bus.mipi_csi2.clock_lane;\n\tbuscfg->bus.csi2.lanecfg.clk.pol =\n\t\tvep->bus.mipi_csi2.lane_polarities[0];\n\tdev_dbg(dev, \"clock lane polarity %u, pos %u\\n\",\n\t\tbuscfg->bus.csi2.lanecfg.clk.pol,\n\t\tbuscfg->bus.csi2.lanecfg.clk.pos);\n\n\tbuscfg->bus.csi2.num_data_lanes = vep->bus.mipi_csi2.num_data_lanes;\n\n\tfor (i = 0; i < buscfg->bus.csi2.num_data_lanes; i++) {\n\t\tbuscfg->bus.csi2.lanecfg.data[i].pos =\n\t\t\tvep->bus.mipi_csi2.data_lanes[i];\n\t\tbuscfg->bus.csi2.lanecfg.data[i].pol =\n\t\t\tvep->bus.mipi_csi2.lane_polarities[i + 1];\n\t\tdev_dbg(dev,\n\t\t\t\"data lane %u polarity %u, pos %u\\n\", i,\n\t\t\tbuscfg->bus.csi2.lanecfg.data[i].pol,\n\t\t\tbuscfg->bus.csi2.lanecfg.data[i].pos);\n\t}\n\t \n\tbuscfg->bus.csi2.crc = 1;\n}\n\nstatic void isp_parse_of_csi1_endpoint(struct device *dev,\n\t\t\t\t       struct v4l2_fwnode_endpoint *vep,\n\t\t\t\t       struct isp_bus_cfg *buscfg)\n{\n\tbuscfg->bus.ccp2.lanecfg.clk.pos = vep->bus.mipi_csi1.clock_lane;\n\tbuscfg->bus.ccp2.lanecfg.clk.pol = vep->bus.mipi_csi1.lane_polarity[0];\n\tdev_dbg(dev, \"clock lane polarity %u, pos %u\\n\",\n\t\tbuscfg->bus.ccp2.lanecfg.clk.pol,\n\tbuscfg->bus.ccp2.lanecfg.clk.pos);\n\n\tbuscfg->bus.ccp2.lanecfg.data[0].pos = vep->bus.mipi_csi1.data_lane;\n\tbuscfg->bus.ccp2.lanecfg.data[0].pol =\n\t\tvep->bus.mipi_csi1.lane_polarity[1];\n\n\tdev_dbg(dev, \"data lane polarity %u, pos %u\\n\",\n\t\tbuscfg->bus.ccp2.lanecfg.data[0].pol,\n\t\tbuscfg->bus.ccp2.lanecfg.data[0].pos);\n\n\tbuscfg->bus.ccp2.strobe_clk_pol = vep->bus.mipi_csi1.clock_inv;\n\tbuscfg->bus.ccp2.phy_layer = vep->bus.mipi_csi1.strobe;\n\tbuscfg->bus.ccp2.ccp2_mode = vep->bus_type == V4L2_MBUS_CCP2;\n\tbuscfg->bus.ccp2.vp_clk_pol = 1;\n\n\tbuscfg->bus.ccp2.crc = 1;\n}\n\nstatic struct {\n\tu32 phy;\n\tu32 csi2_if;\n\tu32 csi1_if;\n} isp_bus_interfaces[2] = {\n\t{ ISP_OF_PHY_CSIPHY1,\n\t  ISP_INTERFACE_CSI2C_PHY1, ISP_INTERFACE_CCP2B_PHY1 },\n\t{ ISP_OF_PHY_CSIPHY2,\n\t  ISP_INTERFACE_CSI2A_PHY2, ISP_INTERFACE_CCP2B_PHY2 },\n};\n\nstatic int isp_parse_of_endpoints(struct isp_device *isp)\n{\n\tstruct fwnode_handle *ep;\n\tstruct isp_async_subdev *isd = NULL;\n\tunsigned int i;\n\n\tep = fwnode_graph_get_endpoint_by_id(\n\t\tdev_fwnode(isp->dev), ISP_OF_PHY_PARALLEL, 0,\n\t\tFWNODE_GRAPH_ENDPOINT_NEXT);\n\n\tif (ep) {\n\t\tstruct v4l2_fwnode_endpoint vep = {\n\t\t\t.bus_type = V4L2_MBUS_PARALLEL\n\t\t};\n\t\tint ret;\n\n\t\tdev_dbg(isp->dev, \"parsing parallel interface\\n\");\n\n\t\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\n\t\tif (!ret) {\n\t\t\tisd = v4l2_async_nf_add_fwnode_remote(&isp->notifier,\n\t\t\t\t\t\t\t      ep, struct\n\t\t\t\t\t\t\t      isp_async_subdev);\n\t\t\tif (!IS_ERR(isd))\n\t\t\t\tisp_parse_of_parallel_endpoint(isp->dev, &vep, &isd->bus);\n\t\t}\n\n\t\tfwnode_handle_put(ep);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(isp_bus_interfaces); i++) {\n\t\tstruct v4l2_fwnode_endpoint vep = {\n\t\t\t.bus_type = V4L2_MBUS_CSI2_DPHY\n\t\t};\n\t\tint ret;\n\n\t\tep = fwnode_graph_get_endpoint_by_id(\n\t\t\tdev_fwnode(isp->dev), isp_bus_interfaces[i].phy, 0,\n\t\t\tFWNODE_GRAPH_ENDPOINT_NEXT);\n\n\t\tif (!ep)\n\t\t\tcontinue;\n\n\t\tdev_dbg(isp->dev, \"parsing serial interface %u, node %pOF\\n\", i,\n\t\t\tto_of_node(ep));\n\n\t\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\t\tif (ret == -ENXIO) {\n\t\t\tvep = (struct v4l2_fwnode_endpoint)\n\t\t\t\t{ .bus_type = V4L2_MBUS_CSI1 };\n\t\t\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\n\t\t\tif (ret == -ENXIO) {\n\t\t\t\tvep = (struct v4l2_fwnode_endpoint)\n\t\t\t\t\t{ .bus_type = V4L2_MBUS_CCP2 };\n\t\t\t\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\t\t\t}\n\t\t}\n\n\t\tif (!ret) {\n\t\t\tisd = v4l2_async_nf_add_fwnode_remote(&isp->notifier,\n\t\t\t\t\t\t\t      ep,\n\t\t\t\t\t\t\t      struct\n\t\t\t\t\t\t\t      isp_async_subdev);\n\n\t\t\tif (!IS_ERR(isd)) {\n\t\t\t\tswitch (vep.bus_type) {\n\t\t\t\tcase V4L2_MBUS_CSI2_DPHY:\n\t\t\t\t\tisd->bus.interface =\n\t\t\t\t\t\tisp_bus_interfaces[i].csi2_if;\n\t\t\t\t\tisp_parse_of_csi2_endpoint(isp->dev, &vep, &isd->bus);\n\t\t\t\t\tbreak;\n\t\t\t\tcase V4L2_MBUS_CSI1:\n\t\t\t\tcase V4L2_MBUS_CCP2:\n\t\t\t\t\tisd->bus.interface =\n\t\t\t\t\t\tisp_bus_interfaces[i].csi1_if;\n\t\t\t\t\tisp_parse_of_csi1_endpoint(isp->dev, &vep,\n\t\t\t\t\t\t\t\t   &isd->bus);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfwnode_handle_put(ep);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_async_notifier_operations isp_subdev_notifier_ops = {\n\t.bound = isp_subdev_notifier_bound,\n\t.complete = isp_subdev_notifier_complete,\n};\n\n \nstatic int isp_probe(struct platform_device *pdev)\n{\n\tstruct isp_device *isp;\n\tstruct resource *mem;\n\tint ret;\n\tint i, m;\n\n\tisp = kzalloc(sizeof(*isp), GFP_KERNEL);\n\tif (!isp) {\n\t\tdev_err(&pdev->dev, \"could not allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = fwnode_property_read_u32(of_fwnode_handle(pdev->dev.of_node),\n\t\t\t\t       \"ti,phy-type\", &isp->phy_type);\n\tif (ret)\n\t\tgoto error_release_isp;\n\n\tisp->syscon = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t      \"syscon\");\n\tif (IS_ERR(isp->syscon)) {\n\t\tret = PTR_ERR(isp->syscon);\n\t\tgoto error_release_isp;\n\t}\n\n\tret = of_property_read_u32_index(pdev->dev.of_node,\n\t\t\t\t\t \"syscon\", 1, &isp->syscon_offset);\n\tif (ret)\n\t\tgoto error_release_isp;\n\n\tisp->autoidle = autoidle;\n\n\tmutex_init(&isp->isp_mutex);\n\tspin_lock_init(&isp->stat_lock);\n\tisp->dev = &pdev->dev;\n\n\tisp->ref_count = 0;\n\n\tret = dma_coerce_mask_and_coherent(isp->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\tgoto error;\n\n\tplatform_set_drvdata(pdev, isp);\n\n\t \n\tisp->isp_csiphy1.vdd = devm_regulator_get(&pdev->dev, \"vdd-csiphy1\");\n\tif (IS_ERR(isp->isp_csiphy1.vdd)) {\n\t\tret = PTR_ERR(isp->isp_csiphy1.vdd);\n\t\tgoto error;\n\t}\n\n\tisp->isp_csiphy2.vdd = devm_regulator_get(&pdev->dev, \"vdd-csiphy2\");\n\tif (IS_ERR(isp->isp_csiphy2.vdd)) {\n\t\tret = PTR_ERR(isp->isp_csiphy2.vdd);\n\t\tgoto error;\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tunsigned int map_idx = i ? OMAP3_ISP_IOMEM_CSI2A_REGS1 : 0;\n\n\t\tisp->mmio_base[map_idx] =\n\t\t\tdevm_platform_get_and_ioremap_resource(pdev, i, &mem);\n\t\tif (IS_ERR(isp->mmio_base[map_idx])) {\n\t\t\tret = PTR_ERR(isp->mmio_base[map_idx]);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = isp_get_clocks(isp);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = clk_enable(isp->clock[ISP_CLK_CAM_ICK]);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tisp->revision = isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);\n\tdev_info(isp->dev, \"Revision %d.%d found\\n\",\n\t\t (isp->revision & 0xf0) >> 4, isp->revision & 0x0f);\n\n\tclk_disable(isp->clock[ISP_CLK_CAM_ICK]);\n\n\tif (__omap3isp_get(isp, false) == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tret = isp_reset(isp);\n\tif (ret < 0)\n\t\tgoto error_isp;\n\n\tret = isp_xclk_init(isp);\n\tif (ret < 0)\n\t\tgoto error_isp;\n\n\t \n\tfor (m = 0; m < ARRAY_SIZE(isp_res_maps); m++)\n\t\tif (isp->revision == isp_res_maps[m].isp_rev)\n\t\t\tbreak;\n\n\tif (m == ARRAY_SIZE(isp_res_maps)) {\n\t\tdev_err(isp->dev, \"No resource map found for ISP rev %d.%d\\n\",\n\t\t\t(isp->revision & 0xf0) >> 4, isp->revision & 0xf);\n\t\tret = -ENODEV;\n\t\tgoto error_isp;\n\t}\n\n\tfor (i = 1; i < OMAP3_ISP_IOMEM_CSI2A_REGS1; i++)\n\t\tisp->mmio_base[i] =\n\t\t\tisp->mmio_base[0] + isp_res_maps[m].offset[i];\n\n\tfor (i = OMAP3_ISP_IOMEM_CSIPHY2; i < OMAP3_ISP_IOMEM_LAST; i++)\n\t\tisp->mmio_base[i] =\n\t\t\tisp->mmio_base[OMAP3_ISP_IOMEM_CSI2A_REGS1]\n\t\t\t+ isp_res_maps[m].offset[i];\n\n\tisp->mmio_hist_base_phys =\n\t\tmem->start + isp_res_maps[m].offset[OMAP3_ISP_IOMEM_HIST];\n\n\t \n\tret = isp_attach_iommu(isp);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"unable to attach to IOMMU\\n\");\n\t\tgoto error_isp;\n\t}\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto error_iommu;\n\tisp->irq_num = ret;\n\n\tif (devm_request_irq(isp->dev, isp->irq_num, isp_isr, IRQF_SHARED,\n\t\t\t     \"OMAP3 ISP\", isp)) {\n\t\tdev_err(isp->dev, \"Unable to request IRQ\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_iommu;\n\t}\n\n\t \n\tret = isp_initialize_modules(isp);\n\tif (ret < 0)\n\t\tgoto error_iommu;\n\n\tret = isp_register_entities(isp);\n\tif (ret < 0)\n\t\tgoto error_modules;\n\n\tret = isp_create_links(isp);\n\tif (ret < 0)\n\t\tgoto error_register_entities;\n\n\tisp->notifier.ops = &isp_subdev_notifier_ops;\n\n\tv4l2_async_nf_init(&isp->notifier, &isp->v4l2_dev);\n\n\tret = isp_parse_of_endpoints(isp);\n\tif (ret < 0)\n\t\tgoto error_register_entities;\n\n\tret = v4l2_async_nf_register(&isp->notifier);\n\tif (ret)\n\t\tgoto error_register_entities;\n\n\tisp_core_init(isp, 1);\n\tomap3isp_put(isp);\n\n\treturn 0;\n\nerror_register_entities:\n\tv4l2_async_nf_cleanup(&isp->notifier);\n\tisp_unregister_entities(isp);\nerror_modules:\n\tisp_cleanup_modules(isp);\nerror_iommu:\n\tisp_detach_iommu(isp);\nerror_isp:\n\tisp_xclk_cleanup(isp);\n\t__omap3isp_put(isp, false);\nerror:\n\tmutex_destroy(&isp->isp_mutex);\nerror_release_isp:\n\tkfree(isp);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops omap3isp_pm_ops = {\n\t.prepare = isp_pm_prepare,\n\t.suspend = isp_pm_suspend,\n\t.resume = isp_pm_resume,\n\t.complete = isp_pm_complete,\n};\n\nstatic const struct platform_device_id omap3isp_id_table[] = {\n\t{ \"omap3isp\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, omap3isp_id_table);\n\nstatic const struct of_device_id omap3isp_of_table[] = {\n\t{ .compatible = \"ti,omap3-isp\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, omap3isp_of_table);\n\nstatic struct platform_driver omap3isp_driver = {\n\t.probe = isp_probe,\n\t.remove_new = isp_remove,\n\t.id_table = omap3isp_id_table,\n\t.driver = {\n\t\t.name = \"omap3isp\",\n\t\t.pm\t= &omap3isp_pm_ops,\n\t\t.of_match_table = omap3isp_of_table,\n\t},\n};\n\nmodule_platform_driver(omap3isp_driver);\n\nMODULE_AUTHOR(\"Nokia Corporation\");\nMODULE_DESCRIPTION(\"TI OMAP3 ISP driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(ISP_VIDEO_DRIVER_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}