{
  "module_name": "ispcsiphy.c",
  "hash_id": "e5a96c3a6ebde956542f6e13fef3221e366a8a411a49f9eebdbb53932737baf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap3isp/ispcsiphy.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include \"isp.h\"\n#include \"ispreg.h\"\n#include \"ispcsiphy.h\"\n\nstatic void csiphy_routing_cfg_3630(struct isp_csiphy *phy,\n\t\t\t\t    enum isp_interface_type iface,\n\t\t\t\t    bool ccp2_strobe)\n{\n\tu32 reg;\n\tu32 shift, mode;\n\n\tregmap_read(phy->isp->syscon, phy->isp->syscon_offset, &reg);\n\n\tswitch (iface) {\n\tdefault:\n\t\t \n\t\treturn;\n\tcase ISP_INTERFACE_CCP2B_PHY1:\n\t\treg &= ~OMAP3630_CONTROL_CAMERA_PHY_CTRL_CSI1_RX_SEL_PHY2;\n\t\tshift = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_PHY1_SHIFT;\n\t\tbreak;\n\tcase ISP_INTERFACE_CSI2C_PHY1:\n\t\tshift = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_PHY1_SHIFT;\n\t\tmode = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_DPHY;\n\t\tbreak;\n\tcase ISP_INTERFACE_CCP2B_PHY2:\n\t\treg |= OMAP3630_CONTROL_CAMERA_PHY_CTRL_CSI1_RX_SEL_PHY2;\n\t\tshift = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_PHY2_SHIFT;\n\t\tbreak;\n\tcase ISP_INTERFACE_CSI2A_PHY2:\n\t\tshift = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_PHY2_SHIFT;\n\t\tmode = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_DPHY;\n\t\tbreak;\n\t}\n\n\t \n\tif (iface == ISP_INTERFACE_CCP2B_PHY1 ||\n\t    iface == ISP_INTERFACE_CCP2B_PHY2) {\n\t\tif (ccp2_strobe)\n\t\t\tmode = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_CCP2_DATA_STROBE;\n\t\telse\n\t\t\tmode = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_CCP2_DATA_CLOCK;\n\t}\n\n\treg &= ~(OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_MASK << shift);\n\treg |= mode << shift;\n\n\tregmap_write(phy->isp->syscon, phy->isp->syscon_offset, reg);\n}\n\nstatic void csiphy_routing_cfg_3430(struct isp_csiphy *phy, u32 iface, bool on,\n\t\t\t\t    bool ccp2_strobe)\n{\n\tu32 csirxfe = OMAP343X_CONTROL_CSIRXFE_PWRDNZ\n\t\t| OMAP343X_CONTROL_CSIRXFE_RESET;\n\n\t \n\tif (iface != ISP_INTERFACE_CCP2B_PHY1)\n\t\treturn;\n\n\tif (!on) {\n\t\tregmap_write(phy->isp->syscon, phy->isp->syscon_offset, 0);\n\t\treturn;\n\t}\n\n\tif (ccp2_strobe)\n\t\tcsirxfe |= OMAP343X_CONTROL_CSIRXFE_SELFORM;\n\n\tregmap_write(phy->isp->syscon, phy->isp->syscon_offset, csirxfe);\n}\n\n \nstatic void csiphy_routing_cfg(struct isp_csiphy *phy,\n\t\t\t       enum isp_interface_type iface, bool on,\n\t\t\t       bool ccp2_strobe)\n{\n\tif (phy->isp->phy_type == ISP_PHY_TYPE_3630 && on)\n\t\treturn csiphy_routing_cfg_3630(phy, iface, ccp2_strobe);\n\tif (phy->isp->phy_type == ISP_PHY_TYPE_3430)\n\t\treturn csiphy_routing_cfg_3430(phy, iface, on, ccp2_strobe);\n}\n\n \nstatic void csiphy_power_autoswitch_enable(struct isp_csiphy *phy, bool enable)\n{\n\tisp_reg_clr_set(phy->isp, phy->cfg_regs, ISPCSI2_PHY_CFG,\n\t\t\tISPCSI2_PHY_CFG_PWR_AUTO,\n\t\t\tenable ? ISPCSI2_PHY_CFG_PWR_AUTO : 0);\n}\n\n \nstatic int csiphy_set_power(struct isp_csiphy *phy, u32 power)\n{\n\tu32 reg;\n\tu8 retry_count;\n\n\tisp_reg_clr_set(phy->isp, phy->cfg_regs, ISPCSI2_PHY_CFG,\n\t\t\tISPCSI2_PHY_CFG_PWR_CMD_MASK, power);\n\n\tretry_count = 0;\n\tdo {\n\t\tudelay(50);\n\t\treg = isp_reg_readl(phy->isp, phy->cfg_regs, ISPCSI2_PHY_CFG) &\n\t\t\t\t    ISPCSI2_PHY_CFG_PWR_STATUS_MASK;\n\n\t\tif (reg != power >> 2)\n\t\t\tretry_count++;\n\n\t} while ((reg != power >> 2) && (retry_count < 100));\n\n\tif (retry_count == 100) {\n\t\tdev_err(phy->isp->dev, \"CSI2 CIO set power failed!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\n \n#define TCLK_TERM\t0\n#define TCLK_MISS\t1\n#define TCLK_SETTLE\t14\n\nstatic int omap3isp_csiphy_config(struct isp_csiphy *phy)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(phy->entity);\n\tstruct isp_bus_cfg *buscfg;\n\tstruct isp_csiphy_lanes_cfg *lanes;\n\tint csi2_ddrclk_khz;\n\tunsigned int num_data_lanes, used_lanes = 0;\n\tunsigned int i;\n\tu32 reg;\n\n\tbuscfg = v4l2_subdev_to_bus_cfg(pipe->external);\n\tif (WARN_ON(!buscfg))\n\t\treturn -EPIPE;\n\n\tif (buscfg->interface == ISP_INTERFACE_CCP2B_PHY1\n\t    || buscfg->interface == ISP_INTERFACE_CCP2B_PHY2) {\n\t\tlanes = &buscfg->bus.ccp2.lanecfg;\n\t\tnum_data_lanes = 1;\n\t} else {\n\t\tlanes = &buscfg->bus.csi2.lanecfg;\n\t\tnum_data_lanes = buscfg->bus.csi2.num_data_lanes;\n\t}\n\n\tif (num_data_lanes > phy->num_data_lanes)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < num_data_lanes; i++) {\n\t\tif (lanes->data[i].pol > 1 || lanes->data[i].pos > 3)\n\t\t\treturn -EINVAL;\n\n\t\tif (used_lanes & (1 << lanes->data[i].pos))\n\t\t\treturn -EINVAL;\n\n\t\tused_lanes |= 1 << lanes->data[i].pos;\n\t}\n\n\tif (lanes->clk.pol > 1 || lanes->clk.pos > 3)\n\t\treturn -EINVAL;\n\n\tif (lanes->clk.pos == 0 || used_lanes & (1 << lanes->clk.pos))\n\t\treturn -EINVAL;\n\n\t \n\tcsiphy_routing_cfg(phy, buscfg->interface, true,\n\t\t\t   buscfg->bus.ccp2.phy_layer);\n\n\t \n\t \n\tcsi2_ddrclk_khz = pipe->external_rate / 1000\n\t\t/ (2 * hweight32(used_lanes)) * pipe->external_width;\n\n\treg = isp_reg_readl(phy->isp, phy->phy_regs, ISPCSIPHY_REG0);\n\n\treg &= ~(ISPCSIPHY_REG0_THS_TERM_MASK |\n\t\t ISPCSIPHY_REG0_THS_SETTLE_MASK);\n\t \n\treg |= (DIV_ROUND_UP(25 * csi2_ddrclk_khz, 2000000) - 1)\n\t\t<< ISPCSIPHY_REG0_THS_TERM_SHIFT;\n\t \n\treg |= (DIV_ROUND_UP(90 * csi2_ddrclk_khz, 1000000) + 3)\n\t\t<< ISPCSIPHY_REG0_THS_SETTLE_SHIFT;\n\n\tisp_reg_writel(phy->isp, reg, phy->phy_regs, ISPCSIPHY_REG0);\n\n\treg = isp_reg_readl(phy->isp, phy->phy_regs, ISPCSIPHY_REG1);\n\n\treg &= ~(ISPCSIPHY_REG1_TCLK_TERM_MASK |\n\t\t ISPCSIPHY_REG1_TCLK_MISS_MASK |\n\t\t ISPCSIPHY_REG1_TCLK_SETTLE_MASK);\n\treg |= TCLK_TERM << ISPCSIPHY_REG1_TCLK_TERM_SHIFT;\n\treg |= TCLK_MISS << ISPCSIPHY_REG1_TCLK_MISS_SHIFT;\n\treg |= TCLK_SETTLE << ISPCSIPHY_REG1_TCLK_SETTLE_SHIFT;\n\n\tisp_reg_writel(phy->isp, reg, phy->phy_regs, ISPCSIPHY_REG1);\n\n\t \n\treg = isp_reg_readl(phy->isp, phy->cfg_regs, ISPCSI2_PHY_CFG);\n\n\tfor (i = 0; i < num_data_lanes; i++) {\n\t\treg &= ~(ISPCSI2_PHY_CFG_DATA_POL_MASK(i + 1) |\n\t\t\t ISPCSI2_PHY_CFG_DATA_POSITION_MASK(i + 1));\n\t\treg |= (lanes->data[i].pol <<\n\t\t\tISPCSI2_PHY_CFG_DATA_POL_SHIFT(i + 1));\n\t\treg |= (lanes->data[i].pos <<\n\t\t\tISPCSI2_PHY_CFG_DATA_POSITION_SHIFT(i + 1));\n\t}\n\n\treg &= ~(ISPCSI2_PHY_CFG_CLOCK_POL_MASK |\n\t\t ISPCSI2_PHY_CFG_CLOCK_POSITION_MASK);\n\treg |= lanes->clk.pol << ISPCSI2_PHY_CFG_CLOCK_POL_SHIFT;\n\treg |= lanes->clk.pos << ISPCSI2_PHY_CFG_CLOCK_POSITION_SHIFT;\n\n\tisp_reg_writel(phy->isp, reg, phy->cfg_regs, ISPCSI2_PHY_CFG);\n\n\treturn 0;\n}\n\nint omap3isp_csiphy_acquire(struct isp_csiphy *phy, struct media_entity *entity)\n{\n\tint rval;\n\n\tif (phy->vdd == NULL) {\n\t\tdev_err(phy->isp->dev,\n\t\t\t\"Power regulator for CSI PHY not available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&phy->mutex);\n\n\trval = regulator_enable(phy->vdd);\n\tif (rval < 0)\n\t\tgoto done;\n\n\trval = omap3isp_csi2_reset(phy->csi2);\n\tif (rval < 0)\n\t\tgoto done;\n\n\tphy->entity = entity;\n\n\trval = omap3isp_csiphy_config(phy);\n\tif (rval < 0)\n\t\tgoto done;\n\n\tif (phy->isp->revision == ISP_REVISION_15_0) {\n\t\trval = csiphy_set_power(phy, ISPCSI2_PHY_CFG_PWR_CMD_ON);\n\t\tif (rval) {\n\t\t\tregulator_disable(phy->vdd);\n\t\t\tgoto done;\n\t\t}\n\n\t\tcsiphy_power_autoswitch_enable(phy, true);\n\t}\ndone:\n\tif (rval < 0)\n\t\tphy->entity = NULL;\n\n\tmutex_unlock(&phy->mutex);\n\treturn rval;\n}\n\nvoid omap3isp_csiphy_release(struct isp_csiphy *phy)\n{\n\tmutex_lock(&phy->mutex);\n\tif (phy->entity) {\n\t\tstruct isp_pipeline *pipe = to_isp_pipeline(phy->entity);\n\t\tstruct isp_bus_cfg *buscfg;\n\n\t\tbuscfg = v4l2_subdev_to_bus_cfg(pipe->external);\n\t\tif (WARN_ON(!buscfg)) {\n\t\t\tmutex_unlock(&phy->mutex);\n\t\t\treturn;\n\t\t}\n\n\t\tcsiphy_routing_cfg(phy, buscfg->interface, false,\n\t\t\t\t   buscfg->bus.ccp2.phy_layer);\n\t\tif (phy->isp->revision == ISP_REVISION_15_0) {\n\t\t\tcsiphy_power_autoswitch_enable(phy, false);\n\t\t\tcsiphy_set_power(phy, ISPCSI2_PHY_CFG_PWR_CMD_OFF);\n\t\t}\n\t\tregulator_disable(phy->vdd);\n\t\tphy->entity = NULL;\n\t}\n\tmutex_unlock(&phy->mutex);\n}\n\n \nint omap3isp_csiphy_init(struct isp_device *isp)\n{\n\tstruct isp_csiphy *phy1 = &isp->isp_csiphy1;\n\tstruct isp_csiphy *phy2 = &isp->isp_csiphy2;\n\n\tphy2->isp = isp;\n\tphy2->csi2 = &isp->isp_csi2a;\n\tphy2->num_data_lanes = ISP_CSIPHY2_NUM_DATA_LANES;\n\tphy2->cfg_regs = OMAP3_ISP_IOMEM_CSI2A_REGS1;\n\tphy2->phy_regs = OMAP3_ISP_IOMEM_CSIPHY2;\n\tmutex_init(&phy2->mutex);\n\n\tphy1->isp = isp;\n\tmutex_init(&phy1->mutex);\n\n\tif (isp->revision == ISP_REVISION_15_0) {\n\t\tphy1->csi2 = &isp->isp_csi2c;\n\t\tphy1->num_data_lanes = ISP_CSIPHY1_NUM_DATA_LANES;\n\t\tphy1->cfg_regs = OMAP3_ISP_IOMEM_CSI2C_REGS1;\n\t\tphy1->phy_regs = OMAP3_ISP_IOMEM_CSIPHY1;\n\t}\n\n\treturn 0;\n}\n\nvoid omap3isp_csiphy_cleanup(struct isp_device *isp)\n{\n\tmutex_destroy(&isp->isp_csiphy1.mutex);\n\tmutex_destroy(&isp->isp_csiphy2.mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}