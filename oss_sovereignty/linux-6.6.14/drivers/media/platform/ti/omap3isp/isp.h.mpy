{
  "module_name": "isp.h",
  "hash_id": "4addfb69a1d3346c1179b3b3634b6f36175cff725f25e126e001b822a499e2b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap3isp/isp.h",
  "human_readable_source": " \n \n\n#ifndef OMAP3_ISP_CORE_H\n#define OMAP3_ISP_CORE_H\n\n#include <media/media-entity.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-device.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/wait.h>\n\n#include \"omap3isp.h\"\n#include \"ispstat.h\"\n#include \"ispccdc.h\"\n#include \"ispreg.h\"\n#include \"ispresizer.h\"\n#include \"isppreview.h\"\n#include \"ispcsiphy.h\"\n#include \"ispcsi2.h\"\n#include \"ispccp2.h\"\n\n#define ISP_TOK_TERM\t\t0xFFFFFFFF\t \n#define to_isp_device(ptr_module)\t\t\t\t\\\n\tcontainer_of(ptr_module, struct isp_device, isp_##ptr_module)\n#define to_device(ptr_module)\t\t\t\t\t\t\\\n\t(to_isp_device(ptr_module)->dev)\n\nenum isp_mem_resources {\n\tOMAP3_ISP_IOMEM_MAIN,\n\tOMAP3_ISP_IOMEM_CCP2,\n\tOMAP3_ISP_IOMEM_CCDC,\n\tOMAP3_ISP_IOMEM_HIST,\n\tOMAP3_ISP_IOMEM_H3A,\n\tOMAP3_ISP_IOMEM_PREV,\n\tOMAP3_ISP_IOMEM_RESZ,\n\tOMAP3_ISP_IOMEM_SBL,\n\tOMAP3_ISP_IOMEM_CSI2A_REGS1,\n\tOMAP3_ISP_IOMEM_CSIPHY2,\n\tOMAP3_ISP_IOMEM_CSI2A_REGS2,\n\tOMAP3_ISP_IOMEM_CSI2C_REGS1,\n\tOMAP3_ISP_IOMEM_CSIPHY1,\n\tOMAP3_ISP_IOMEM_CSI2C_REGS2,\n\tOMAP3_ISP_IOMEM_LAST\n};\n\nenum isp_sbl_resource {\n\tOMAP3_ISP_SBL_CSI1_READ\t\t= 0x1,\n\tOMAP3_ISP_SBL_CSI1_WRITE\t= 0x2,\n\tOMAP3_ISP_SBL_CSI2A_WRITE\t= 0x4,\n\tOMAP3_ISP_SBL_CSI2C_WRITE\t= 0x8,\n\tOMAP3_ISP_SBL_CCDC_LSC_READ\t= 0x10,\n\tOMAP3_ISP_SBL_CCDC_WRITE\t= 0x20,\n\tOMAP3_ISP_SBL_PREVIEW_READ\t= 0x40,\n\tOMAP3_ISP_SBL_PREVIEW_WRITE\t= 0x80,\n\tOMAP3_ISP_SBL_RESIZER_READ\t= 0x100,\n\tOMAP3_ISP_SBL_RESIZER_WRITE\t= 0x200,\n};\n\nenum isp_subclk_resource {\n\tOMAP3_ISP_SUBCLK_CCDC\t\t= (1 << 0),\n\tOMAP3_ISP_SUBCLK_AEWB\t\t= (1 << 1),\n\tOMAP3_ISP_SUBCLK_AF\t\t= (1 << 2),\n\tOMAP3_ISP_SUBCLK_HIST\t\t= (1 << 3),\n\tOMAP3_ISP_SUBCLK_PREVIEW\t= (1 << 4),\n\tOMAP3_ISP_SUBCLK_RESIZER\t= (1 << 5),\n};\n\n \n#define ISP_REVISION_1_0\t\t0x10\n \n#define ISP_REVISION_2_0\t\t0x20\n \n#define ISP_REVISION_15_0\t\t0xF0\n\n#define ISP_PHY_TYPE_3430\t\t0\n#define ISP_PHY_TYPE_3630\t\t1\n\nstruct regmap;\n\n \nstruct isp_res_mapping {\n\tu32 isp_rev;\n\tu32 offset[OMAP3_ISP_IOMEM_LAST];\n\tu32 phy_type;\n};\n\n \nstruct isp_reg {\n\tenum isp_mem_resources mmio_range;\n\tu32 reg;\n\tu32 val;\n};\n\nenum isp_xclk_id {\n\tISP_XCLK_A,\n\tISP_XCLK_B,\n};\n\nstruct isp_xclk {\n\tstruct isp_device *isp;\n\tstruct clk_hw hw;\n\tstruct clk *clk;\n\tenum isp_xclk_id id;\n\n\tspinlock_t lock;\t \n\tbool enabled;\n\tunsigned int divider;\n};\n\n \nstruct isp_device {\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_async_notifier notifier;\n\tstruct media_device media_dev;\n\tstruct device *dev;\n\tu32 revision;\n\n\t \n\tunsigned int irq_num;\n\n\tvoid __iomem *mmio_base[OMAP3_ISP_IOMEM_LAST];\n\tunsigned long mmio_hist_base_phys;\n\tstruct regmap *syscon;\n\tu32 syscon_offset;\n\tu32 phy_type;\n\n\tstruct dma_iommu_mapping *mapping;\n\n\t \n\tspinlock_t stat_lock;\t \n\tstruct mutex isp_mutex;\t \n\tbool stop_failure;\n\tstruct media_entity_enum crashed;\n\tint has_context;\n\tint ref_count;\n\tunsigned int autoidle;\n#define ISP_CLK_CAM_ICK\t\t0\n#define ISP_CLK_CAM_MCLK\t1\n#define ISP_CLK_CSI2_FCK\t2\n#define ISP_CLK_L3_ICK\t\t3\n\tstruct clk *clock[4];\n\tstruct isp_xclk xclks[2];\n\n\t \n\tstruct ispstat isp_af;\n\tstruct ispstat isp_aewb;\n\tstruct ispstat isp_hist;\n\tstruct isp_res_device isp_res;\n\tstruct isp_prev_device isp_prev;\n\tstruct isp_ccdc_device isp_ccdc;\n\tstruct isp_csi2_device isp_csi2a;\n\tstruct isp_csi2_device isp_csi2c;\n\tstruct isp_ccp2_device isp_ccp2;\n\tstruct isp_csiphy isp_csiphy1;\n\tstruct isp_csiphy isp_csiphy2;\n\n\tunsigned int sbl_resources;\n\tunsigned int subclk_resources;\n};\n\nstruct isp_async_subdev {\n\tstruct v4l2_async_connection asd;\n\tstruct isp_bus_cfg bus;\n};\n\nstatic inline struct isp_bus_cfg *\nv4l2_subdev_to_bus_cfg(struct v4l2_subdev *sd)\n{\n\tstruct v4l2_async_connection *asc;\n\n\tasc = v4l2_async_connection_unique(sd);\n\tif (!asc)\n\t\treturn NULL;\n\n\treturn &container_of(asc, struct isp_async_subdev, asd)->bus;\n}\n\n#define v4l2_dev_to_isp_device(dev) \\\n\tcontainer_of(dev, struct isp_device, v4l2_dev)\n\nvoid omap3isp_hist_dma_done(struct isp_device *isp);\n\nvoid omap3isp_flush(struct isp_device *isp);\n\nint omap3isp_module_sync_idle(struct media_entity *me, wait_queue_head_t *wait,\n\t\t\t      atomic_t *stopping);\n\nint omap3isp_module_sync_is_stopping(wait_queue_head_t *wait,\n\t\t\t\t     atomic_t *stopping);\n\nint omap3isp_pipeline_set_stream(struct isp_pipeline *pipe,\n\t\t\t\t enum isp_pipeline_stream_state state);\nvoid omap3isp_pipeline_cancel_stream(struct isp_pipeline *pipe);\nvoid omap3isp_configure_bridge(struct isp_device *isp,\n\t\t\t       enum ccdc_input_entity input,\n\t\t\t       const struct isp_parallel_cfg *buscfg,\n\t\t\t       unsigned int shift, unsigned int bridge);\n\nstruct isp_device *omap3isp_get(struct isp_device *isp);\nvoid omap3isp_put(struct isp_device *isp);\n\nvoid omap3isp_print_status(struct isp_device *isp);\n\nvoid omap3isp_sbl_enable(struct isp_device *isp, enum isp_sbl_resource res);\nvoid omap3isp_sbl_disable(struct isp_device *isp, enum isp_sbl_resource res);\n\nvoid omap3isp_subclk_enable(struct isp_device *isp,\n\t\t\t    enum isp_subclk_resource res);\nvoid omap3isp_subclk_disable(struct isp_device *isp,\n\t\t\t     enum isp_subclk_resource res);\n\nint omap3isp_register_entities(struct platform_device *pdev,\n\t\t\t       struct v4l2_device *v4l2_dev);\nvoid omap3isp_unregister_entities(struct platform_device *pdev);\n\n \nstatic inline\nu32 isp_reg_readl(struct isp_device *isp, enum isp_mem_resources isp_mmio_range,\n\t\t  u32 reg_offset)\n{\n\treturn __raw_readl(isp->mmio_base[isp_mmio_range] + reg_offset);\n}\n\n \nstatic inline\nvoid isp_reg_writel(struct isp_device *isp, u32 reg_value,\n\t\t    enum isp_mem_resources isp_mmio_range, u32 reg_offset)\n{\n\t__raw_writel(reg_value, isp->mmio_base[isp_mmio_range] + reg_offset);\n}\n\n \nstatic inline\nvoid isp_reg_clr(struct isp_device *isp, enum isp_mem_resources mmio_range,\n\t\t u32 reg, u32 clr_bits)\n{\n\tu32 v = isp_reg_readl(isp, mmio_range, reg);\n\n\tisp_reg_writel(isp, v & ~clr_bits, mmio_range, reg);\n}\n\n \nstatic inline\nvoid isp_reg_set(struct isp_device *isp, enum isp_mem_resources mmio_range,\n\t\t u32 reg, u32 set_bits)\n{\n\tu32 v = isp_reg_readl(isp, mmio_range, reg);\n\n\tisp_reg_writel(isp, v | set_bits, mmio_range, reg);\n}\n\n \nstatic inline\nvoid isp_reg_clr_set(struct isp_device *isp, enum isp_mem_resources mmio_range,\n\t\t     u32 reg, u32 clr_bits, u32 set_bits)\n{\n\tu32 v = isp_reg_readl(isp, mmio_range, reg);\n\n\tisp_reg_writel(isp, (v & ~clr_bits) | set_bits, mmio_range, reg);\n}\n\nstatic inline enum v4l2_buf_type\nisp_pad_buffer_type(const struct v4l2_subdev *subdev, int pad)\n{\n\tif (pad >= subdev->entity.num_pads)\n\t\treturn 0;\n\n\tif (subdev->entity.pads[pad].flags & MEDIA_PAD_FL_SINK)\n\t\treturn V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\telse\n\t\treturn V4L2_BUF_TYPE_VIDEO_CAPTURE;\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}