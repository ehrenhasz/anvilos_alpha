{
  "module_name": "ispccp2.c",
  "hash_id": "48e19dade95d10a2f09f32c8b5f3b131e05c47c8baf6f6279094c6ead7a5fb52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap3isp/ispccp2.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/regulator/consumer.h>\n\n#include \"isp.h\"\n#include \"ispreg.h\"\n#include \"ispccp2.h\"\n\n \n#define CCP2_LCx_CHANS_NUM\t\t\t3\n \n#define ISPCCP2_DAT_START_MIN\t\t\t0\n#define ISPCCP2_DAT_START_MAX\t\t\t4095\n#define ISPCCP2_DAT_SIZE_MIN\t\t\t0\n#define ISPCCP2_DAT_SIZE_MAX\t\t\t4095\n#define ISPCCP2_VPCLK_FRACDIV\t\t\t65536\n#define ISPCCP2_LCx_CTRL_FORMAT_RAW8_DPCM10_VP\t0x12\n#define ISPCCP2_LCx_CTRL_FORMAT_RAW10_VP\t0x16\n \n#define ISPCCP2_LCM_HSIZE_COUNT_MIN\t\t16\n#define ISPCCP2_LCM_HSIZE_COUNT_MAX\t\t8191\n#define ISPCCP2_LCM_HSIZE_SKIP_MIN\t\t0\n#define ISPCCP2_LCM_HSIZE_SKIP_MAX\t\t8191\n#define ISPCCP2_LCM_VSIZE_MIN\t\t\t1\n#define ISPCCP2_LCM_VSIZE_MAX\t\t\t8191\n#define ISPCCP2_LCM_HWORDS_MIN\t\t\t1\n#define ISPCCP2_LCM_HWORDS_MAX\t\t\t4095\n#define ISPCCP2_LCM_CTRL_BURST_SIZE_32X\t\t5\n#define ISPCCP2_LCM_CTRL_READ_THROTTLE_FULL\t0\n#define ISPCCP2_LCM_CTRL_SRC_DECOMPR_DPCM10\t2\n#define ISPCCP2_LCM_CTRL_SRC_FORMAT_RAW8\t2\n#define ISPCCP2_LCM_CTRL_SRC_FORMAT_RAW10\t3\n#define ISPCCP2_LCM_CTRL_DST_FORMAT_RAW10\t3\n#define ISPCCP2_LCM_CTRL_DST_PORT_VP\t\t0\n#define ISPCCP2_LCM_CTRL_DST_PORT_MEM\t\t1\n\n \n#define BIT_SET(var, shift, mask, val)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tvar = ((var) & ~((mask) << (shift)))\t\\\n\t\t\t| ((val) << (shift));\t\t\\\n\t} while (0)\n\n \n#define CCP2_PRINT_REGISTER(isp, name)\\\n\tdev_dbg(isp->dev, \"###CCP2 \" #name \"=0x%08x\\n\", \\\n\t\tisp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_##name))\n\nstatic void ccp2_print_status(struct isp_ccp2_device *ccp2)\n{\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\n\tdev_dbg(isp->dev, \"-------------CCP2 Register dump-------------\\n\");\n\n\tCCP2_PRINT_REGISTER(isp, SYSCONFIG);\n\tCCP2_PRINT_REGISTER(isp, SYSSTATUS);\n\tCCP2_PRINT_REGISTER(isp, LC01_IRQENABLE);\n\tCCP2_PRINT_REGISTER(isp, LC01_IRQSTATUS);\n\tCCP2_PRINT_REGISTER(isp, LC23_IRQENABLE);\n\tCCP2_PRINT_REGISTER(isp, LC23_IRQSTATUS);\n\tCCP2_PRINT_REGISTER(isp, LCM_IRQENABLE);\n\tCCP2_PRINT_REGISTER(isp, LCM_IRQSTATUS);\n\tCCP2_PRINT_REGISTER(isp, CTRL);\n\tCCP2_PRINT_REGISTER(isp, LCx_CTRL(0));\n\tCCP2_PRINT_REGISTER(isp, LCx_CODE(0));\n\tCCP2_PRINT_REGISTER(isp, LCx_STAT_START(0));\n\tCCP2_PRINT_REGISTER(isp, LCx_STAT_SIZE(0));\n\tCCP2_PRINT_REGISTER(isp, LCx_SOF_ADDR(0));\n\tCCP2_PRINT_REGISTER(isp, LCx_EOF_ADDR(0));\n\tCCP2_PRINT_REGISTER(isp, LCx_DAT_START(0));\n\tCCP2_PRINT_REGISTER(isp, LCx_DAT_SIZE(0));\n\tCCP2_PRINT_REGISTER(isp, LCx_DAT_PING_ADDR(0));\n\tCCP2_PRINT_REGISTER(isp, LCx_DAT_PONG_ADDR(0));\n\tCCP2_PRINT_REGISTER(isp, LCx_DAT_OFST(0));\n\tCCP2_PRINT_REGISTER(isp, LCM_CTRL);\n\tCCP2_PRINT_REGISTER(isp, LCM_VSIZE);\n\tCCP2_PRINT_REGISTER(isp, LCM_HSIZE);\n\tCCP2_PRINT_REGISTER(isp, LCM_PREFETCH);\n\tCCP2_PRINT_REGISTER(isp, LCM_SRC_ADDR);\n\tCCP2_PRINT_REGISTER(isp, LCM_SRC_OFST);\n\tCCP2_PRINT_REGISTER(isp, LCM_DST_ADDR);\n\tCCP2_PRINT_REGISTER(isp, LCM_DST_OFST);\n\n\tdev_dbg(isp->dev, \"--------------------------------------------\\n\");\n}\n\n \nstatic void ccp2_reset(struct isp_ccp2_device *ccp2)\n{\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\tint i = 0;\n\n\t \n\tisp_reg_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_SYSCONFIG,\n\t\t    ISPCCP2_SYSCONFIG_SOFT_RESET);\n\twhile (!(isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_SYSSTATUS) &\n\t\t ISPCCP2_SYSSTATUS_RESET_DONE)) {\n\t\tudelay(10);\n\t\tif (i++ > 10) {   \n\t\t\tdev_warn(isp->dev,\n\t\t\t\t\"omap3_isp: timeout waiting for ccp2 reset\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void ccp2_pwr_cfg(struct isp_ccp2_device *ccp2)\n{\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\n\tisp_reg_writel(isp, ISPCCP2_SYSCONFIG_MSTANDBY_MODE_SMART |\n\t\t\t((isp->revision == ISP_REVISION_15_0 && isp->autoidle) ?\n\t\t\t  ISPCCP2_SYSCONFIG_AUTO_IDLE : 0),\n\t\t       OMAP3_ISP_IOMEM_CCP2, ISPCCP2_SYSCONFIG);\n}\n\n \nstatic int ccp2_if_enable(struct isp_ccp2_device *ccp2, u8 enable)\n{\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\tint ret;\n\tint i;\n\n\tif (enable && ccp2->vdds_csib) {\n\t\tret = regulator_enable(ccp2->vdds_csib);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < CCP2_LCx_CHANS_NUM; i++)\n\t\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCx_CTRL(i),\n\t\t\t\tISPCCP2_LCx_CTRL_CHAN_EN,\n\t\t\t\tenable ? ISPCCP2_LCx_CTRL_CHAN_EN : 0);\n\n\t \n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL,\n\t\t\tISPCCP2_CTRL_MODE | ISPCCP2_CTRL_IF_EN,\n\t\t\tenable ? (ISPCCP2_CTRL_MODE | ISPCCP2_CTRL_IF_EN) : 0);\n\n\tif (!enable && ccp2->vdds_csib)\n\t\tregulator_disable(ccp2->vdds_csib);\n\n\treturn 0;\n}\n\n \nstatic void ccp2_mem_enable(struct isp_ccp2_device *ccp2, u8 enable)\n{\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\n\tif (enable)\n\t\tccp2_if_enable(ccp2, 0);\n\n\t \n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL,\n\t\t\tISPCCP2_CTRL_MODE, enable ? ISPCCP2_CTRL_MODE : 0);\n\n\tisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_CTRL,\n\t\t\tISPCCP2_LCM_CTRL_CHAN_EN,\n\t\t\tenable ? ISPCCP2_LCM_CTRL_CHAN_EN : 0);\n}\n\n \nstatic int ccp2_phyif_config(struct isp_ccp2_device *ccp2,\n\t\t\t     const struct isp_ccp2_cfg *buscfg)\n{\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\tu32 val;\n\n\tval = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL) |\n\t\t\t    ISPCCP2_CTRL_MODE;\n\t \n\tBIT_SET(val, ISPCCP2_CTRL_PHY_SEL_SHIFT, ISPCCP2_CTRL_PHY_SEL_MASK,\n\t\tbuscfg->phy_layer);\n\tBIT_SET(val, ISPCCP2_CTRL_IO_OUT_SEL_SHIFT,\n\t\tISPCCP2_CTRL_IO_OUT_SEL_MASK, buscfg->ccp2_mode);\n\tBIT_SET(val, ISPCCP2_CTRL_INV_SHIFT, ISPCCP2_CTRL_INV_MASK,\n\t\tbuscfg->strobe_clk_pol);\n\tBIT_SET(val, ISPCCP2_CTRL_VP_CLK_POL_SHIFT,\n\t\tISPCCP2_CTRL_VP_CLK_POL_MASK, buscfg->vp_clk_pol);\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL);\n\n\tval = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL);\n\tif (!(val & ISPCCP2_CTRL_MODE)) {\n\t\tif (buscfg->ccp2_mode == ISP_CCP2_MODE_CCP2)\n\t\t\tdev_warn(isp->dev, \"OMAP3 CCP2 bus not available\\n\");\n\t\tif (buscfg->phy_layer == ISP_CCP2_PHY_DATA_STROBE)\n\t\t\t \n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ccp2_vp_config(struct isp_ccp2_device *ccp2,\n\t\t\t   unsigned int vpclk_div)\n{\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\tu32 val;\n\n\t \n\tval = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL);\n\tval |= ISPCCP2_CTRL_VP_ONLY_EN;\t \n\n\tif (isp->revision == ISP_REVISION_15_0) {\n\t\tvpclk_div = clamp_t(unsigned int, vpclk_div, 1, 65536);\n\t\tvpclk_div = min(ISPCCP2_VPCLK_FRACDIV / vpclk_div, 65535U);\n\t\tBIT_SET(val, ISPCCP2_CTRL_VPCLK_DIV_SHIFT,\n\t\t\tISPCCP2_CTRL_VPCLK_DIV_MASK, vpclk_div);\n\t} else {\n\t\tvpclk_div = clamp_t(unsigned int, vpclk_div, 1, 4);\n\t\tBIT_SET(val, ISPCCP2_CTRL_VP_OUT_CTRL_SHIFT,\n\t\t\tISPCCP2_CTRL_VP_OUT_CTRL_MASK, vpclk_div - 1);\n\t}\n\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL);\n}\n\n \nstatic void ccp2_lcx_config(struct isp_ccp2_device *ccp2,\n\t\t\t    struct isp_interface_lcx_config *config)\n{\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\tu32 val, format;\n\n\tswitch (config->format) {\n\tcase MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:\n\t\tformat = ISPCCP2_LCx_CTRL_FORMAT_RAW8_DPCM10_VP;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_SGRBG10_1X10:\n\tdefault:\n\t\tformat = ISPCCP2_LCx_CTRL_FORMAT_RAW10_VP;\t \n\t\tbreak;\n\t}\n\t \n\tval = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCx_CTRL(0))\n\t\t\t    | (ISPCCP2_LCx_CTRL_REGION_EN);  \n\n\tif (isp->revision == ISP_REVISION_15_0) {\n\t\t \n\t\tBIT_SET(val, ISPCCP2_LCx_CTRL_CRC_SHIFT_15_0,\n\t\t\tISPCCP2_LCx_CTRL_CRC_MASK,\n\t\t\tconfig->crc);\n\t\t \n\t\tBIT_SET(val, ISPCCP2_LCx_CTRL_FORMAT_SHIFT_15_0,\n\t\t\tISPCCP2_LCx_CTRL_FORMAT_MASK_15_0, format);\n\t} else {\n\t\tBIT_SET(val, ISPCCP2_LCx_CTRL_CRC_SHIFT,\n\t\t\tISPCCP2_LCx_CTRL_CRC_MASK,\n\t\t\tconfig->crc);\n\n\t\tBIT_SET(val, ISPCCP2_LCx_CTRL_FORMAT_SHIFT,\n\t\t\tISPCCP2_LCx_CTRL_FORMAT_MASK, format);\n\t}\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCx_CTRL(0));\n\n\t \n\tisp_reg_writel(isp, config->data_start << ISPCCP2_LCx_DAT_SHIFT,\n\t\t       OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCx_DAT_START(0));\n\n\t \n\tisp_reg_writel(isp, config->data_size << ISPCCP2_LCx_DAT_SHIFT,\n\t\t       OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCx_DAT_SIZE(0));\n\n\t \n\tval = ISPCCP2_LC01_IRQSTATUS_LC0_FIFO_OVF_IRQ |\n\t      ISPCCP2_LC01_IRQSTATUS_LC0_CRC_IRQ |\n\t      ISPCCP2_LC01_IRQSTATUS_LC0_FSP_IRQ |\n\t      ISPCCP2_LC01_IRQSTATUS_LC0_FW_IRQ |\n\t      ISPCCP2_LC01_IRQSTATUS_LC0_FSC_IRQ |\n\t      ISPCCP2_LC01_IRQSTATUS_LC0_SSC_IRQ;\n\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LC01_IRQSTATUS);\n\tisp_reg_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LC01_IRQENABLE, val);\n}\n\n \nstatic int ccp2_if_configure(struct isp_ccp2_device *ccp2)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&ccp2->subdev.entity);\n\tconst struct isp_bus_cfg *buscfg;\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct media_pad *pad;\n\tstruct v4l2_subdev *sensor;\n\tu32 lines = 0;\n\tint ret;\n\n\tccp2_pwr_cfg(ccp2);\n\n\tpad = media_pad_remote_pad_first(&ccp2->pads[CCP2_PAD_SINK]);\n\tsensor = media_entity_to_v4l2_subdev(pad->entity);\n\tbuscfg = v4l2_subdev_to_bus_cfg(pipe->external);\n\tif (WARN_ON(!buscfg))\n\t\treturn -EPIPE;\n\n\tret = ccp2_phyif_config(ccp2, &buscfg->bus.ccp2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tccp2_vp_config(ccp2, buscfg->bus.ccp2.vpclk_div + 1);\n\n\tv4l2_subdev_call(sensor, sensor, g_skip_top_lines, &lines);\n\n\tformat = &ccp2->formats[CCP2_PAD_SINK];\n\n\tccp2->if_cfg.data_start = lines;\n\tccp2->if_cfg.crc = buscfg->bus.ccp2.crc;\n\tccp2->if_cfg.format = format->code;\n\tccp2->if_cfg.data_size = format->height;\n\n\tccp2_lcx_config(ccp2, &ccp2->if_cfg);\n\n\treturn 0;\n}\n\nstatic int ccp2_adjust_bandwidth(struct isp_ccp2_device *ccp2)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&ccp2->subdev.entity);\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\tconst struct v4l2_mbus_framefmt *ofmt = &ccp2->formats[CCP2_PAD_SOURCE];\n\tunsigned long l3_ick = pipe->l3_ick;\n\tstruct v4l2_fract *timeperframe;\n\tunsigned int vpclk_div = 2;\n\tunsigned int value;\n\tu64 bound;\n\tu64 area;\n\n\t \n\tvpclk_div = max_t(unsigned int, DIV_ROUND_UP(l3_ick, pipe->max_rate),\n\t\t\t  vpclk_div);\n\n\t \n\ttimeperframe = &pipe->max_timeperframe;\n\n\tif (timeperframe->numerator) {\n\t\tarea = ofmt->width * ofmt->height;\n\t\tbound = div_u64(area * timeperframe->denominator,\n\t\t\t\ttimeperframe->numerator);\n\t\tvalue = min_t(u64, bound, l3_ick);\n\t\tvpclk_div = max_t(unsigned int, l3_ick / value, vpclk_div);\n\t}\n\n\tdev_dbg(isp->dev, \"%s: minimum clock divisor = %u\\n\", __func__,\n\t\tvpclk_div);\n\n\treturn vpclk_div;\n}\n\n \nstatic void ccp2_mem_configure(struct isp_ccp2_device *ccp2,\n\t\t\t       struct isp_interface_mem_config *config)\n{\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\tu32 sink_pixcode = ccp2->formats[CCP2_PAD_SINK].code;\n\tu32 source_pixcode = ccp2->formats[CCP2_PAD_SOURCE].code;\n\tunsigned int dpcm_decompress = 0;\n\tu32 val, hwords;\n\n\tif (sink_pixcode != source_pixcode &&\n\t    sink_pixcode == MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8)\n\t\tdpcm_decompress = 1;\n\n\tccp2_pwr_cfg(ccp2);\n\n\t \n\tisp_reg_writel(isp, ISPCCP2_LCM_HSIZE_SKIP_MIN |\n\t\t       (config->hsize_count << ISPCCP2_LCM_HSIZE_SHIFT),\n\t\t       OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_HSIZE);\n\n\t \n\tisp_reg_writel(isp, config->vsize_count << ISPCCP2_LCM_VSIZE_SHIFT,\n\t\t       OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_VSIZE);\n\n\tif (ccp2->video_in.bpl_padding == 0)\n\t\tconfig->src_ofst = 0;\n\telse\n\t\tconfig->src_ofst = ccp2->video_in.bpl_value;\n\n\tisp_reg_writel(isp, config->src_ofst, OMAP3_ISP_IOMEM_CCP2,\n\t\t       ISPCCP2_LCM_SRC_OFST);\n\n\t \n\tval = ISPCCP2_LCM_CTRL_DST_FORMAT_RAW10 <<\n\t      ISPCCP2_LCM_CTRL_DST_FORMAT_SHIFT;\n\n\tif (dpcm_decompress) {\n\t\t \n\t\tval |= ISPCCP2_LCM_CTRL_SRC_FORMAT_RAW8 <<\n\t\t       ISPCCP2_LCM_CTRL_SRC_FORMAT_SHIFT;\n\n\t\t \n\t\tval |= ISPCCP2_LCM_CTRL_SRC_DPCM_PRED;\n\n\t\t \n\t\tval |= ISPCCP2_LCM_CTRL_SRC_DECOMPR_DPCM10 <<\n\t\t       ISPCCP2_LCM_CTRL_SRC_DECOMPR_SHIFT;\n\t} else {\n\t\t \n\t\tval |= ISPCCP2_LCM_CTRL_SRC_FORMAT_RAW10 <<\n\t\t       ISPCCP2_LCM_CTRL_SRC_FORMAT_SHIFT;\n\t}\n\n\t \n\tval |= ISPCCP2_LCM_CTRL_BURST_SIZE_32X <<\n\t       ISPCCP2_LCM_CTRL_BURST_SIZE_SHIFT;\n\n\tisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_CTRL);\n\n\t \n\tif (dpcm_decompress)\n\t\thwords = (ISPCCP2_LCM_HSIZE_SKIP_MIN +\n\t\t\t  config->hsize_count) >> 3;\n\telse\n\t\thwords = (ISPCCP2_LCM_HSIZE_SKIP_MIN +\n\t\t\t  config->hsize_count) >> 2;\n\n\tisp_reg_writel(isp, hwords << ISPCCP2_LCM_PREFETCH_SHIFT,\n\t\t       OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_PREFETCH);\n\n\t \n\tisp_reg_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL,\n\t\t    ISPCCP2_CTRL_IO_OUT_SEL | ISPCCP2_CTRL_MODE);\n\tccp2_vp_config(ccp2, ccp2_adjust_bandwidth(ccp2));\n\n\t \n\tisp_reg_writel(isp, ISPCCP2_LCM_IRQSTATUS_OCPERROR_IRQ |\n\t\t       ISPCCP2_LCM_IRQSTATUS_EOF_IRQ,\n\t\t       OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_IRQSTATUS);\n\n\t \n\tisp_reg_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_IRQENABLE,\n\t\t    ISPCCP2_LCM_IRQSTATUS_EOF_IRQ |\n\t\t    ISPCCP2_LCM_IRQSTATUS_OCPERROR_IRQ);\n}\n\n \nstatic void ccp2_set_inaddr(struct isp_ccp2_device *ccp2, u32 addr)\n{\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\n\tisp_reg_writel(isp, addr, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_SRC_ADDR);\n}\n\n \n\nstatic void ccp2_isr_buffer(struct isp_ccp2_device *ccp2)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&ccp2->subdev.entity);\n\tstruct isp_buffer *buffer;\n\n\tbuffer = omap3isp_video_buffer_next(&ccp2->video_in);\n\tif (buffer != NULL)\n\t\tccp2_set_inaddr(ccp2, buffer->dma);\n\n\tpipe->state |= ISP_PIPELINE_IDLE_INPUT;\n\n\tif (ccp2->state == ISP_PIPELINE_STREAM_SINGLESHOT) {\n\t\tif (isp_pipeline_ready(pipe))\n\t\t\tomap3isp_pipeline_set_stream(pipe,\n\t\t\t\t\t\tISP_PIPELINE_STREAM_SINGLESHOT);\n\t}\n}\n\n \nvoid omap3isp_ccp2_isr(struct isp_ccp2_device *ccp2)\n{\n\tstruct isp_pipeline *pipe = to_isp_pipeline(&ccp2->subdev.entity);\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\tstatic const u32 ISPCCP2_LC01_ERROR =\n\t\tISPCCP2_LC01_IRQSTATUS_LC0_FIFO_OVF_IRQ |\n\t\tISPCCP2_LC01_IRQSTATUS_LC0_CRC_IRQ |\n\t\tISPCCP2_LC01_IRQSTATUS_LC0_FSP_IRQ |\n\t\tISPCCP2_LC01_IRQSTATUS_LC0_FW_IRQ |\n\t\tISPCCP2_LC01_IRQSTATUS_LC0_FSC_IRQ |\n\t\tISPCCP2_LC01_IRQSTATUS_LC0_SSC_IRQ;\n\tu32 lcx_irqstatus, lcm_irqstatus;\n\n\t \n\tlcx_irqstatus = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2,\n\t\t\t\t      ISPCCP2_LC01_IRQSTATUS);\n\tisp_reg_writel(isp, lcx_irqstatus, OMAP3_ISP_IOMEM_CCP2,\n\t\t       ISPCCP2_LC01_IRQSTATUS);\n\n\tlcm_irqstatus = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2,\n\t\t\t\t      ISPCCP2_LCM_IRQSTATUS);\n\tisp_reg_writel(isp, lcm_irqstatus, OMAP3_ISP_IOMEM_CCP2,\n\t\t       ISPCCP2_LCM_IRQSTATUS);\n\t \n\tif (lcx_irqstatus & ISPCCP2_LC01_ERROR) {\n\t\tpipe->error = true;\n\t\tdev_dbg(isp->dev, \"CCP2 err:%x\\n\", lcx_irqstatus);\n\t\treturn;\n\t}\n\n\tif (lcm_irqstatus & ISPCCP2_LCM_IRQSTATUS_OCPERROR_IRQ) {\n\t\tpipe->error = true;\n\t\tdev_dbg(isp->dev, \"CCP2 OCP err:%x\\n\", lcm_irqstatus);\n\t}\n\n\tif (omap3isp_module_sync_is_stopping(&ccp2->wait, &ccp2->stopping))\n\t\treturn;\n\n\t \n\tif (lcm_irqstatus & ISPCCP2_LCM_IRQSTATUS_EOF_IRQ)\n\t\tccp2_isr_buffer(ccp2);\n}\n\n \n\nstatic const unsigned int ccp2_fmts[] = {\n\tMEDIA_BUS_FMT_SGRBG10_1X10,\n\tMEDIA_BUS_FMT_SGRBG10_DPCM8_1X8,\n};\n\n \nstatic struct v4l2_mbus_framefmt *\n__ccp2_get_format(struct isp_ccp2_device *ccp2,\n\t\t  struct v4l2_subdev_state *sd_state,\n\t\t  unsigned int pad, enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&ccp2->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\telse\n\t\treturn &ccp2->formats[pad];\n}\n\n \nstatic void ccp2_try_format(struct isp_ccp2_device *ccp2,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       unsigned int pad,\n\t\t\t       struct v4l2_mbus_framefmt *fmt,\n\t\t\t       enum v4l2_subdev_format_whence which)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\n\tswitch (pad) {\n\tcase CCP2_PAD_SINK:\n\t\tif (fmt->code != MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8)\n\t\t\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\n\t\tif (ccp2->input == CCP2_INPUT_SENSOR) {\n\t\t\tfmt->width = clamp_t(u32, fmt->width,\n\t\t\t\t\t     ISPCCP2_DAT_START_MIN,\n\t\t\t\t\t     ISPCCP2_DAT_START_MAX);\n\t\t\tfmt->height = clamp_t(u32, fmt->height,\n\t\t\t\t\t      ISPCCP2_DAT_SIZE_MIN,\n\t\t\t\t\t      ISPCCP2_DAT_SIZE_MAX);\n\t\t} else if (ccp2->input == CCP2_INPUT_MEMORY) {\n\t\t\tfmt->width = clamp_t(u32, fmt->width,\n\t\t\t\t\t     ISPCCP2_LCM_HSIZE_COUNT_MIN,\n\t\t\t\t\t     ISPCCP2_LCM_HSIZE_COUNT_MAX);\n\t\t\tfmt->height = clamp_t(u32, fmt->height,\n\t\t\t\t\t      ISPCCP2_LCM_VSIZE_MIN,\n\t\t\t\t\t      ISPCCP2_LCM_VSIZE_MAX);\n\t\t}\n\t\tbreak;\n\n\tcase CCP2_PAD_SOURCE:\n\t\t \n\t\tformat = __ccp2_get_format(ccp2, sd_state, CCP2_PAD_SINK,\n\t\t\t\t\t   which);\n\t\tmemcpy(fmt, format, sizeof(*fmt));\n\t\tfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\t\tbreak;\n\t}\n\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n}\n\n \nstatic int ccp2_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct isp_ccp2_device *ccp2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tif (code->pad == CCP2_PAD_SINK) {\n\t\tif (code->index >= ARRAY_SIZE(ccp2_fmts))\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = ccp2_fmts[code->index];\n\t} else {\n\t\tif (code->index != 0)\n\t\t\treturn -EINVAL;\n\n\t\tformat = __ccp2_get_format(ccp2, sd_state, CCP2_PAD_SINK,\n\t\t\t\t\t   code->which);\n\t\tcode->code = format->code;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccp2_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct isp_ccp2_device *ccp2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tccp2_try_format(ccp2, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tccp2_try_format(ccp2, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int ccp2_get_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct isp_ccp2_device *ccp2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __ccp2_get_format(ccp2, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\treturn 0;\n}\n\n \nstatic int ccp2_set_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct isp_ccp2_device *ccp2 = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __ccp2_get_format(ccp2, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tccp2_try_format(ccp2, sd_state, fmt->pad, &fmt->format, fmt->which);\n\t*format = fmt->format;\n\n\t \n\tif (fmt->pad == CCP2_PAD_SINK) {\n\t\tformat = __ccp2_get_format(ccp2, sd_state, CCP2_PAD_SOURCE,\n\t\t\t\t\t   fmt->which);\n\t\t*format = fmt->format;\n\t\tccp2_try_format(ccp2, sd_state, CCP2_PAD_SOURCE, format,\n\t\t\t\tfmt->which);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ccp2_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format;\n\n\tmemset(&format, 0, sizeof(format));\n\tformat.pad = CCP2_PAD_SINK;\n\tformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\n\tformat.format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\tformat.format.width = 4096;\n\tformat.format.height = 4096;\n\tccp2_set_format(sd, fh ? fh->state : NULL, &format);\n\n\treturn 0;\n}\n\n \nstatic int ccp2_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct isp_ccp2_device *ccp2 = v4l2_get_subdevdata(sd);\n\tstruct isp_device *isp = to_isp_device(ccp2);\n\tstruct device *dev = to_device(ccp2);\n\tint ret;\n\n\tif (ccp2->state == ISP_PIPELINE_STREAM_STOPPED) {\n\t\tif (enable == ISP_PIPELINE_STREAM_STOPPED)\n\t\t\treturn 0;\n\t\tatomic_set(&ccp2->stopping, 0);\n\t}\n\n\tswitch (enable) {\n\tcase ISP_PIPELINE_STREAM_CONTINUOUS:\n\t\tif (ccp2->phy) {\n\t\t\tret = omap3isp_csiphy_acquire(ccp2->phy, &sd->entity);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tccp2_if_configure(ccp2);\n\t\tccp2_print_status(ccp2);\n\n\t\t \n\t\tret = ccp2_if_enable(ccp2, 1);\n\t\tif (ret < 0) {\n\t\t\tif (ccp2->phy)\n\t\t\t\tomap3isp_csiphy_release(ccp2->phy);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_SINGLESHOT:\n\t\tif (ccp2->state != ISP_PIPELINE_STREAM_SINGLESHOT) {\n\t\t\tstruct v4l2_mbus_framefmt *format;\n\n\t\t\tformat = &ccp2->formats[CCP2_PAD_SINK];\n\n\t\t\tccp2->mem_cfg.hsize_count = format->width;\n\t\t\tccp2->mem_cfg.vsize_count = format->height;\n\t\t\tccp2->mem_cfg.src_ofst = 0;\n\n\t\t\tccp2_mem_configure(ccp2, &ccp2->mem_cfg);\n\t\t\tomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_CSI1_READ);\n\t\t\tccp2_print_status(ccp2);\n\t\t}\n\t\tccp2_mem_enable(ccp2, 1);\n\t\tbreak;\n\n\tcase ISP_PIPELINE_STREAM_STOPPED:\n\t\tif (omap3isp_module_sync_idle(&sd->entity, &ccp2->wait,\n\t\t\t\t\t      &ccp2->stopping))\n\t\t\tdev_dbg(dev, \"%s: module stop timeout.\\n\", sd->name);\n\t\tif (ccp2->input == CCP2_INPUT_MEMORY) {\n\t\t\tccp2_mem_enable(ccp2, 0);\n\t\t\tomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_CSI1_READ);\n\t\t} else if (ccp2->input == CCP2_INPUT_SENSOR) {\n\t\t\t \n\t\t\tccp2_if_enable(ccp2, 0);\n\t\t\tif (ccp2->phy)\n\t\t\t\tomap3isp_csiphy_release(ccp2->phy);\n\t\t}\n\t\tbreak;\n\t}\n\n\tccp2->state = enable;\n\treturn 0;\n}\n\n \nstatic const struct v4l2_subdev_video_ops ccp2_sd_video_ops = {\n\t.s_stream = ccp2_s_stream,\n};\n\n \nstatic const struct v4l2_subdev_pad_ops ccp2_sd_pad_ops = {\n\t.enum_mbus_code = ccp2_enum_mbus_code,\n\t.enum_frame_size = ccp2_enum_frame_size,\n\t.get_fmt = ccp2_get_format,\n\t.set_fmt = ccp2_set_format,\n};\n\n \nstatic const struct v4l2_subdev_ops ccp2_sd_ops = {\n\t.video = &ccp2_sd_video_ops,\n\t.pad = &ccp2_sd_pad_ops,\n};\n\n \nstatic const struct v4l2_subdev_internal_ops ccp2_sd_internal_ops = {\n\t.open = ccp2_init_formats,\n};\n\n \n\n \nstatic int ccp2_video_queue(struct isp_video *video, struct isp_buffer *buffer)\n{\n\tstruct isp_ccp2_device *ccp2 = &video->isp->isp_ccp2;\n\n\tccp2_set_inaddr(ccp2, buffer->dma);\n\treturn 0;\n}\n\nstatic const struct isp_video_operations ccp2_video_ops = {\n\t.queue = ccp2_video_queue,\n};\n\n \n\n \nstatic int ccp2_link_setup(struct media_entity *entity,\n\t\t\t   const struct media_pad *local,\n\t\t\t   const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct isp_ccp2_device *ccp2 = v4l2_get_subdevdata(sd);\n\tunsigned int index = local->index;\n\n\t \n\tif (is_media_entity_v4l2_subdev(remote->entity))\n\t\tindex |= 2 << 16;\n\n\tswitch (index) {\n\tcase CCP2_PAD_SINK:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (ccp2->input == CCP2_INPUT_SENSOR)\n\t\t\t\treturn -EBUSY;\n\t\t\tccp2->input = CCP2_INPUT_MEMORY;\n\t\t} else {\n\t\t\tif (ccp2->input == CCP2_INPUT_MEMORY)\n\t\t\t\tccp2->input = CCP2_INPUT_NONE;\n\t\t}\n\t\tbreak;\n\n\tcase CCP2_PAD_SINK | 2 << 16:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (ccp2->input == CCP2_INPUT_MEMORY)\n\t\t\t\treturn -EBUSY;\n\t\t\tccp2->input = CCP2_INPUT_SENSOR;\n\t\t} else {\n\t\t\tif (ccp2->input == CCP2_INPUT_SENSOR)\n\t\t\t\tccp2->input = CCP2_INPUT_NONE;\n\t\t} break;\n\n\tcase CCP2_PAD_SOURCE | 2 << 16:\n\t\t \n\t\tif (flags & MEDIA_LNK_FL_ENABLED)\n\t\t\tccp2->output = CCP2_OUTPUT_CCDC;\n\t\telse\n\t\t\tccp2->output = CCP2_OUTPUT_NONE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct media_entity_operations ccp2_media_ops = {\n\t.link_setup = ccp2_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \nvoid omap3isp_ccp2_unregister_entities(struct isp_ccp2_device *ccp2)\n{\n\tv4l2_device_unregister_subdev(&ccp2->subdev);\n\tomap3isp_video_unregister(&ccp2->video_in);\n}\n\n \n\nint omap3isp_ccp2_register_entities(struct isp_ccp2_device *ccp2,\n\t\t\t\t    struct v4l2_device *vdev)\n{\n\tint ret;\n\n\t \n\tccp2->subdev.dev = vdev->mdev->dev;\n\tret = v4l2_device_register_subdev(vdev, &ccp2->subdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = omap3isp_video_register(&ccp2->video_in, vdev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tomap3isp_ccp2_unregister_entities(ccp2);\n\treturn ret;\n}\n\n \n\n \nstatic int ccp2_init_entities(struct isp_ccp2_device *ccp2)\n{\n\tstruct v4l2_subdev *sd = &ccp2->subdev;\n\tstruct media_pad *pads = ccp2->pads;\n\tstruct media_entity *me = &sd->entity;\n\tint ret;\n\n\tccp2->input = CCP2_INPUT_NONE;\n\tccp2->output = CCP2_OUTPUT_NONE;\n\n\tv4l2_subdev_init(sd, &ccp2_sd_ops);\n\tsd->internal_ops = &ccp2_sd_internal_ops;\n\tstrscpy(sd->name, \"OMAP3 ISP CCP2\", sizeof(sd->name));\n\tsd->grp_id = 1 << 16;    \n\tv4l2_set_subdevdata(sd, ccp2);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tpads[CCP2_PAD_SINK].flags = MEDIA_PAD_FL_SINK\n\t\t\t\t    | MEDIA_PAD_FL_MUST_CONNECT;\n\tpads[CCP2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\tme->ops = &ccp2_media_ops;\n\tret = media_entity_pads_init(me, CCP2_PADS_NUM, pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tccp2_init_formats(sd, NULL);\n\n\t \n\tccp2->video_in.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tccp2->video_in.bpl_alignment = 32;\n\tccp2->video_in.bpl_max = 0xffffffe0;\n\tccp2->video_in.isp = to_isp_device(ccp2);\n\tccp2->video_in.ops = &ccp2_video_ops;\n\tccp2->video_in.capture_mem = PAGE_ALIGN(4096 * 4096) * 3;\n\n\tret = omap3isp_video_init(&ccp2->video_in, \"CCP2\");\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tmedia_entity_cleanup(&ccp2->subdev.entity);\n\treturn ret;\n}\n\n \nint omap3isp_ccp2_init(struct isp_device *isp)\n{\n\tstruct isp_ccp2_device *ccp2 = &isp->isp_ccp2;\n\tint ret;\n\n\tinit_waitqueue_head(&ccp2->wait);\n\n\t \n\tif (isp->revision == ISP_REVISION_2_0) {\n\t\tccp2->vdds_csib = devm_regulator_get(isp->dev, \"vdds_csib\");\n\t\tif (IS_ERR(ccp2->vdds_csib)) {\n\t\t\tif (PTR_ERR(ccp2->vdds_csib) == -EPROBE_DEFER) {\n\t\t\t\tdev_dbg(isp->dev,\n\t\t\t\t\t\"Can't get regulator vdds_csib, deferring probing\\n\");\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\t}\n\t\t\tdev_dbg(isp->dev,\n\t\t\t\t\"Could not get regulator vdds_csib\\n\");\n\t\t\tccp2->vdds_csib = NULL;\n\t\t}\n\t\tccp2->phy = &isp->isp_csiphy2;\n\t} else if (isp->revision == ISP_REVISION_15_0) {\n\t\tccp2->phy = &isp->isp_csiphy1;\n\t}\n\n\tret = ccp2_init_entities(ccp2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tccp2_reset(ccp2);\n\treturn 0;\n}\n\n \nvoid omap3isp_ccp2_cleanup(struct isp_device *isp)\n{\n\tstruct isp_ccp2_device *ccp2 = &isp->isp_ccp2;\n\n\tomap3isp_video_cleanup(&ccp2->video_in);\n\tmedia_entity_cleanup(&ccp2->subdev.entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}