{
  "module_name": "vpif_capture.c",
  "hash_id": "856b4f092f415ab23884e7118f25b50a05225b15c238d703966a4ad25fc241b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/davinci/vpif_capture.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-ioctl.h>\n#include <media/i2c/tvp514x.h>\n#include <media/v4l2-mediabus.h>\n\n#include <linux/videodev2.h>\n\n#include \"vpif.h\"\n#include \"vpif_capture.h\"\n\nMODULE_DESCRIPTION(\"TI DaVinci VPIF Capture driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(VPIF_CAPTURE_VERSION);\n\n#define vpif_err(fmt, arg...)\tv4l2_err(&vpif_obj.v4l2_dev, fmt, ## arg)\n#define vpif_dbg(level, debug, fmt, arg...)\t\\\n\t\tv4l2_dbg(level, debug, &vpif_obj.v4l2_dev, fmt, ## arg)\n\nstatic int debug = 1;\n\nmodule_param(debug, int, 0644);\n\nMODULE_PARM_DESC(debug, \"Debug level 0-1\");\n\n#define VPIF_DRIVER_NAME\t\"vpif_capture\"\nMODULE_ALIAS(\"platform:\" VPIF_DRIVER_NAME);\n\n \nstatic struct vpif_device vpif_obj = { {NULL} };\nstatic struct device *vpif_dev;\nstatic void vpif_calculate_offsets(struct channel_obj *ch);\nstatic void vpif_config_addr(struct channel_obj *ch, int muxmode);\n\nstatic u8 channel_first_int[VPIF_NUMBER_OF_OBJECTS][2] = { {1, 1} };\n\n \nstatic int ycmux_mode;\n\nstatic inline\nstruct vpif_cap_buffer *to_vpif_buffer(struct vb2_v4l2_buffer *vb)\n{\n\treturn container_of(vb, struct vpif_cap_buffer, vb);\n}\n\n \nstatic int vpif_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tstruct channel_obj *ch = vb2_get_drv_priv(q);\n\tstruct common_obj *common;\n\tunsigned long addr;\n\n\tvpif_dbg(2, debug, \"vpif_buffer_prepare\\n\");\n\n\tcommon = &ch->common[VPIF_VIDEO_INDEX];\n\n\tvb2_set_plane_payload(vb, 0, common->fmt.fmt.pix.sizeimage);\n\tif (vb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0))\n\t\treturn -EINVAL;\n\n\tvbuf->field = common->fmt.fmt.pix.field;\n\n\taddr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\tif (!IS_ALIGNED((addr + common->ytop_off), 8) ||\n\t\t!IS_ALIGNED((addr + common->ybtm_off), 8) ||\n\t\t!IS_ALIGNED((addr + common->ctop_off), 8) ||\n\t\t!IS_ALIGNED((addr + common->cbtm_off), 8)) {\n\t\tvpif_dbg(1, debug, \"offset is not aligned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vpif_buffer_queue_setup(struct vb2_queue *vq,\n\t\t\t\tunsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct channel_obj *ch = vb2_get_drv_priv(vq);\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tunsigned size = common->fmt.fmt.pix.sizeimage;\n\n\tvpif_dbg(2, debug, \"vpif_buffer_setup\\n\");\n\n\tif (*nplanes) {\n\t\tif (sizes[0] < size)\n\t\t\treturn -EINVAL;\n\t\tsize = sizes[0];\n\t}\n\n\tif (vq->num_buffers + *nbuffers < 3)\n\t\t*nbuffers = 3 - vq->num_buffers;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\t \n\tvpif_calculate_offsets(ch);\n\n\treturn 0;\n}\n\n \nstatic void vpif_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct channel_obj *ch = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vpif_cap_buffer *buf = to_vpif_buffer(vbuf);\n\tstruct common_obj *common;\n\tunsigned long flags;\n\n\tcommon = &ch->common[VPIF_VIDEO_INDEX];\n\n\tvpif_dbg(2, debug, \"vpif_buffer_queue\\n\");\n\n\tspin_lock_irqsave(&common->irqlock, flags);\n\t \n\tlist_add_tail(&buf->list, &common->dma_queue);\n\tspin_unlock_irqrestore(&common->irqlock, flags);\n}\n\n \nstatic int vpif_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct vpif_capture_config *vpif_config_data =\n\t\t\t\t\tvpif_dev->platform_data;\n\tstruct channel_obj *ch = vb2_get_drv_priv(vq);\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct vpif_params *vpif = &ch->vpifparams;\n\tstruct vpif_cap_buffer *buf, *tmp;\n\tunsigned long addr, flags;\n\tint ret;\n\n\t \n\tch->field_id = 0;\n\n\t \n\tif (vpif_config_data->setup_input_channel_mode) {\n\t\tret = vpif_config_data->\n\t\t\tsetup_input_channel_mode(vpif->std_info.ycmux_mode);\n\t\tif (ret < 0) {\n\t\t\tvpif_dbg(1, debug, \"can't set vpif channel mode\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = v4l2_subdev_call(ch->sd, video, s_stream, 1);\n\tif (ret && ret != -ENOIOCTLCMD && ret != -ENODEV) {\n\t\tvpif_dbg(1, debug, \"stream on failed in subdev\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tret = vpif_set_video_params(vpif, ch->channel_id);\n\tif (ret < 0) {\n\t\tvpif_dbg(1, debug, \"can't set video params\\n\");\n\t\tgoto err;\n\t}\n\n\tycmux_mode = ret;\n\tvpif_config_addr(ch, ret);\n\n\t \n\tspin_lock_irqsave(&common->irqlock, flags);\n\tcommon->cur_frm = common->next_frm = list_entry(common->dma_queue.next,\n\t\t\t\t    struct vpif_cap_buffer, list);\n\t \n\tlist_del(&common->cur_frm->list);\n\tspin_unlock_irqrestore(&common->irqlock, flags);\n\n\taddr = vb2_dma_contig_plane_dma_addr(&common->cur_frm->vb.vb2_buf, 0);\n\n\tcommon->set_addr(addr + common->ytop_off,\n\t\t\t addr + common->ybtm_off,\n\t\t\t addr + common->ctop_off,\n\t\t\t addr + common->cbtm_off);\n\n\t \n\tchannel_first_int[VPIF_VIDEO_INDEX][ch->channel_id] = 1;\n\tif (VPIF_CHANNEL0_VIDEO == ch->channel_id) {\n\t\tchannel0_intr_assert();\n\t\tchannel0_intr_enable(1);\n\t\tenable_channel0(1);\n\t}\n\tif (VPIF_CHANNEL1_VIDEO == ch->channel_id ||\n\t\tycmux_mode == 2) {\n\t\tchannel1_intr_assert();\n\t\tchannel1_intr_enable(1);\n\t\tenable_channel1(1);\n\t}\n\n\treturn 0;\n\nerr:\n\tspin_lock_irqsave(&common->irqlock, flags);\n\tlist_for_each_entry_safe(buf, tmp, &common->dma_queue, list) {\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t}\n\tspin_unlock_irqrestore(&common->irqlock, flags);\n\n\treturn ret;\n}\n\n \nstatic void vpif_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct channel_obj *ch = vb2_get_drv_priv(vq);\n\tstruct common_obj *common;\n\tunsigned long flags;\n\tint ret;\n\n\tcommon = &ch->common[VPIF_VIDEO_INDEX];\n\n\t \n\tif (VPIF_CHANNEL0_VIDEO == ch->channel_id) {\n\t\tenable_channel0(0);\n\t\tchannel0_intr_enable(0);\n\t}\n\tif (VPIF_CHANNEL1_VIDEO == ch->channel_id ||\n\t\tycmux_mode == 2) {\n\t\tenable_channel1(0);\n\t\tchannel1_intr_enable(0);\n\t}\n\n\tycmux_mode = 0;\n\n\tret = v4l2_subdev_call(ch->sd, video, s_stream, 0);\n\tif (ret && ret != -ENOIOCTLCMD && ret != -ENODEV)\n\t\tvpif_dbg(1, debug, \"stream off failed in subdev\\n\");\n\n\t \n\tif (common->cur_frm == common->next_frm) {\n\t\tvb2_buffer_done(&common->cur_frm->vb.vb2_buf,\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\t} else {\n\t\tif (common->cur_frm)\n\t\t\tvb2_buffer_done(&common->cur_frm->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\tif (common->next_frm)\n\t\t\tvb2_buffer_done(&common->next_frm->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_ERROR);\n\t}\n\n\tspin_lock_irqsave(&common->irqlock, flags);\n\twhile (!list_empty(&common->dma_queue)) {\n\t\tcommon->next_frm = list_entry(common->dma_queue.next,\n\t\t\t\t\t\tstruct vpif_cap_buffer, list);\n\t\tlist_del(&common->next_frm->list);\n\t\tvb2_buffer_done(&common->next_frm->vb.vb2_buf,\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&common->irqlock, flags);\n}\n\nstatic const struct vb2_ops video_qops = {\n\t.queue_setup\t\t= vpif_buffer_queue_setup,\n\t.buf_prepare\t\t= vpif_buffer_prepare,\n\t.start_streaming\t= vpif_start_streaming,\n\t.stop_streaming\t\t= vpif_stop_streaming,\n\t.buf_queue\t\t= vpif_buffer_queue,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \nstatic void vpif_process_buffer_complete(struct common_obj *common)\n{\n\tcommon->cur_frm->vb.vb2_buf.timestamp = ktime_get_ns();\n\tvb2_buffer_done(&common->cur_frm->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t \n\tcommon->cur_frm = common->next_frm;\n}\n\n \nstatic void vpif_schedule_next_buffer(struct common_obj *common)\n{\n\tunsigned long addr = 0;\n\n\tspin_lock(&common->irqlock);\n\tcommon->next_frm = list_entry(common->dma_queue.next,\n\t\t\t\t     struct vpif_cap_buffer, list);\n\t \n\tlist_del(&common->next_frm->list);\n\tspin_unlock(&common->irqlock);\n\taddr = vb2_dma_contig_plane_dma_addr(&common->next_frm->vb.vb2_buf, 0);\n\n\t \n\tcommon->set_addr(addr + common->ytop_off,\n\t\t\t addr + common->ybtm_off,\n\t\t\t addr + common->ctop_off,\n\t\t\t addr + common->cbtm_off);\n}\n\n \nstatic irqreturn_t vpif_channel_isr(int irq, void *dev_id)\n{\n\tstruct vpif_device *dev = &vpif_obj;\n\tstruct common_obj *common;\n\tstruct channel_obj *ch;\n\tint channel_id;\n\tint fid = -1, i;\n\n\tchannel_id = *(int *)(dev_id);\n\tif (!vpif_intr_status(channel_id))\n\t\treturn IRQ_NONE;\n\n\tch = dev->dev[channel_id];\n\n\tfor (i = 0; i < VPIF_NUMBER_OF_OBJECTS; i++) {\n\t\tcommon = &ch->common[i];\n\t\t \n\t\t \n\t\tif (1 == ch->vpifparams.std_info.frm_fmt ||\n\t\t    common->fmt.fmt.pix.field == V4L2_FIELD_NONE) {\n\t\t\t \n\t\t\tspin_lock(&common->irqlock);\n\t\t\tif (list_empty(&common->dma_queue)) {\n\t\t\t\tspin_unlock(&common->irqlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&common->irqlock);\n\n\t\t\tif (!channel_first_int[i][channel_id])\n\t\t\t\tvpif_process_buffer_complete(common);\n\n\t\t\tchannel_first_int[i][channel_id] = 0;\n\n\t\t\tvpif_schedule_next_buffer(common);\n\n\n\t\t\tchannel_first_int[i][channel_id] = 0;\n\t\t} else {\n\t\t\t \n\t\t\tif (channel_first_int[i][channel_id]) {\n\t\t\t\tchannel_first_int[i][channel_id] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (0 == i) {\n\t\t\t\tch->field_id ^= 1;\n\t\t\t\t \n\t\t\t\tfid = vpif_channel_getfid(ch->channel_id);\n\t\t\t\tif (fid != ch->field_id) {\n\t\t\t\t\t \n\t\t\t\t\tif (0 == fid)\n\t\t\t\t\t\tch->field_id = fid;\n\t\t\t\t\treturn IRQ_HANDLED;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (0 == fid) {\n\t\t\t\t \n\t\t\t\tif (common->cur_frm == common->next_frm)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tvpif_process_buffer_complete(common);\n\t\t\t} else if (1 == fid) {\n\t\t\t\t \n\t\t\t\tspin_lock(&common->irqlock);\n\t\t\t\tif (list_empty(&common->dma_queue) ||\n\t\t\t\t    (common->cur_frm != common->next_frm)) {\n\t\t\t\t\tspin_unlock(&common->irqlock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tspin_unlock(&common->irqlock);\n\n\t\t\t\tvpif_schedule_next_buffer(common);\n\t\t\t}\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int vpif_update_std_info(struct channel_obj *ch)\n{\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct vpif_params *vpifparams = &ch->vpifparams;\n\tconst struct vpif_channel_config_params *config;\n\tstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\n\tstruct video_obj *vid_ch = &ch->video;\n\tint index;\n\tstruct v4l2_pix_format *pixfmt = &common->fmt.fmt.pix;\n\n\tvpif_dbg(2, debug, \"vpif_update_std_info\\n\");\n\n\t \n\tif (pixfmt->width && pixfmt->height) {\n\t\tif (pixfmt->field == V4L2_FIELD_ANY ||\n\t\t    pixfmt->field == V4L2_FIELD_NONE)\n\t\t\tpixfmt->field = V4L2_FIELD_NONE;\n\n\t\tvpifparams->iface.if_type = VPIF_IF_BT656;\n\t\tif (pixfmt->pixelformat == V4L2_PIX_FMT_SGRBG10 ||\n\t\t    pixfmt->pixelformat == V4L2_PIX_FMT_SBGGR8)\n\t\t\tvpifparams->iface.if_type = VPIF_IF_RAW_BAYER;\n\n\t\tif (pixfmt->pixelformat == V4L2_PIX_FMT_SGRBG10)\n\t\t\tvpifparams->params.data_sz = 1;  \n\n\t\t \n\t\tif (vpifparams->iface.if_type == VPIF_IF_RAW_BAYER) {\n\t\t\tmemset(std_info, 0, sizeof(struct vpif_channel_config_params));\n\t\t\tvpifparams->std_info.capture_format = 1;  \n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (index = 0; index < vpif_ch_params_count; index++) {\n\t\tconfig = &vpif_ch_params[index];\n\t\tif (config->hd_sd == 0) {\n\t\t\tvpif_dbg(2, debug, \"SD format\\n\");\n\t\t\tif (config->stdid & vid_ch->stdid) {\n\t\t\t\tmemcpy(std_info, config, sizeof(*config));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tvpif_dbg(2, debug, \"HD format\\n\");\n\t\t\tif (!memcmp(&config->dv_timings, &vid_ch->dv_timings,\n\t\t\t\tsizeof(vid_ch->dv_timings))) {\n\t\t\t\tmemcpy(std_info, config, sizeof(*config));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (index == vpif_ch_params_count)\n\t\treturn -EINVAL;\n\n\tcommon->fmt.fmt.pix.width = std_info->width;\n\tcommon->width = std_info->width;\n\tcommon->fmt.fmt.pix.height = std_info->height;\n\tcommon->height = std_info->height;\n\tcommon->fmt.fmt.pix.sizeimage = common->height * common->width * 2;\n\tcommon->fmt.fmt.pix.bytesperline = std_info->width;\n\tvpifparams->video_params.hpitch = std_info->width;\n\tvpifparams->video_params.storage_mode = std_info->frm_fmt;\n\n\tif (vid_ch->stdid)\n\t\tcommon->fmt.fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\telse\n\t\tcommon->fmt.fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\n\n\tif (ch->vpifparams.std_info.frm_fmt)\n\t\tcommon->fmt.fmt.pix.field = V4L2_FIELD_NONE;\n\telse\n\t\tcommon->fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;\n\n\tif (ch->vpifparams.iface.if_type == VPIF_IF_RAW_BAYER)\n\t\tcommon->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;\n\telse\n\t\tcommon->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_NV16;\n\n\tcommon->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n\treturn 0;\n}\n\n \nstatic void vpif_calculate_offsets(struct channel_obj *ch)\n{\n\tunsigned int hpitch, sizeimage;\n\tstruct video_obj *vid_ch = &(ch->video);\n\tstruct vpif_params *vpifparams = &ch->vpifparams;\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tenum v4l2_field field = common->fmt.fmt.pix.field;\n\n\tvpif_dbg(2, debug, \"vpif_calculate_offsets\\n\");\n\n\tif (V4L2_FIELD_ANY == field) {\n\t\tif (vpifparams->std_info.frm_fmt)\n\t\t\tvid_ch->buf_field = V4L2_FIELD_NONE;\n\t\telse\n\t\t\tvid_ch->buf_field = V4L2_FIELD_INTERLACED;\n\t} else\n\t\tvid_ch->buf_field = common->fmt.fmt.pix.field;\n\n\tsizeimage = common->fmt.fmt.pix.sizeimage;\n\n\thpitch = common->fmt.fmt.pix.bytesperline;\n\n\tif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\n\t    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {\n\t\t \n\t\tcommon->ytop_off = 0;\n\t\tcommon->ybtm_off = hpitch;\n\t\tcommon->ctop_off = sizeimage / 2;\n\t\tcommon->cbtm_off = sizeimage / 2 + hpitch;\n\t} else if (V4L2_FIELD_SEQ_TB == vid_ch->buf_field) {\n\t\t \n\t\tcommon->ytop_off = 0;\n\t\tcommon->ybtm_off = sizeimage / 4;\n\t\tcommon->ctop_off = sizeimage / 2;\n\t\tcommon->cbtm_off = common->ctop_off + sizeimage / 4;\n\t} else if (V4L2_FIELD_SEQ_BT == vid_ch->buf_field) {\n\t\t \n\t\tcommon->ybtm_off = 0;\n\t\tcommon->ytop_off = sizeimage / 4;\n\t\tcommon->cbtm_off = sizeimage / 2;\n\t\tcommon->ctop_off = common->cbtm_off + sizeimage / 4;\n\t}\n\tif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\n\t    (V4L2_FIELD_INTERLACED == vid_ch->buf_field))\n\t\tvpifparams->video_params.storage_mode = 1;\n\telse\n\t\tvpifparams->video_params.storage_mode = 0;\n\n\tif (1 == vpifparams->std_info.frm_fmt)\n\t\tvpifparams->video_params.hpitch =\n\t\t    common->fmt.fmt.pix.bytesperline;\n\telse {\n\t\tif ((field == V4L2_FIELD_ANY)\n\t\t    || (field == V4L2_FIELD_INTERLACED))\n\t\t\tvpifparams->video_params.hpitch =\n\t\t\t    common->fmt.fmt.pix.bytesperline * 2;\n\t\telse\n\t\t\tvpifparams->video_params.hpitch =\n\t\t\t    common->fmt.fmt.pix.bytesperline;\n\t}\n\n\tch->vpifparams.video_params.stdid = vpifparams->std_info.stdid;\n}\n\n \nstatic void vpif_config_addr(struct channel_obj *ch, int muxmode)\n{\n\tstruct common_obj *common;\n\n\tvpif_dbg(2, debug, \"vpif_config_addr\\n\");\n\n\tcommon = &(ch->common[VPIF_VIDEO_INDEX]);\n\n\tif (VPIF_CHANNEL1_VIDEO == ch->channel_id)\n\t\tcommon->set_addr = ch1_set_video_buf_addr;\n\telse if (2 == muxmode)\n\t\tcommon->set_addr = ch0_set_video_buf_addr_yc_nmux;\n\telse\n\t\tcommon->set_addr = ch0_set_video_buf_addr;\n}\n\n \nstatic int vpif_input_to_subdev(\n\t\tstruct vpif_capture_config *vpif_cfg,\n\t\tstruct vpif_capture_chan_config *chan_cfg,\n\t\tint input_index)\n{\n\tstruct vpif_subdev_info *subdev_info;\n\tconst char *subdev_name;\n\tint i;\n\n\tvpif_dbg(2, debug, \"vpif_input_to_subdev\\n\");\n\n\tif (!chan_cfg)\n\t\treturn -1;\n\tif (input_index >= chan_cfg->input_count)\n\t\treturn -1;\n\tsubdev_name = chan_cfg->inputs[input_index].subdev_name;\n\tif (!subdev_name)\n\t\treturn -1;\n\n\t \n\tfor (i = 0; i < vpif_cfg->subdev_count; i++) {\n\t\tsubdev_info = &vpif_cfg->subdev_info[i];\n\t\tif (subdev_info && !strcmp(subdev_info->name, subdev_name))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n \nstatic int vpif_set_input(\n\t\tstruct vpif_capture_config *vpif_cfg,\n\t\tstruct channel_obj *ch,\n\t\tint index)\n{\n\tstruct vpif_capture_chan_config *chan_cfg =\n\t\t\t&vpif_cfg->chan_config[ch->channel_id];\n\tstruct vpif_subdev_info *subdev_info = NULL;\n\tstruct v4l2_subdev *sd = NULL;\n\tu32 input = 0, output = 0;\n\tint sd_index;\n\tint ret;\n\n\tsd_index = vpif_input_to_subdev(vpif_cfg, chan_cfg, index);\n\tif (sd_index >= 0) {\n\t\tsd = vpif_obj.sd[sd_index];\n\t\tsubdev_info = &vpif_cfg->subdev_info[sd_index];\n\t} else {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (sd && vpif_cfg->setup_input_path) {\n\t\tret = vpif_cfg->setup_input_path(ch->channel_id,\n\t\t\t\t       subdev_info->name);\n\t\tif (ret < 0) {\n\t\t\tvpif_dbg(1, debug, \"couldn't setup input path for the\" \\\n\t\t\t\" sub device %s, for input index %d\\n\",\n\t\t\tsubdev_info->name, index);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (sd) {\n\t\tinput = chan_cfg->inputs[index].input_route;\n\t\toutput = chan_cfg->inputs[index].output_route;\n\t\tret = v4l2_subdev_call(sd, video, s_routing,\n\t\t\t\tinput, output, 0);\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD) {\n\t\t\tvpif_dbg(1, debug, \"Failed to set input\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tch->input_idx = index;\n\tch->sd = sd;\n\t \n\tch->vpifparams.iface = chan_cfg->vpif_if;\n\n\t \n\tch->video_dev.tvnorms = chan_cfg->inputs[index].input.std;\n\treturn 0;\n}\n\n \nstatic int vpif_querystd(struct file *file, void *priv, v4l2_std_id *std_id)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tint ret;\n\n\tvpif_dbg(2, debug, \"vpif_querystd\\n\");\n\n\t \n\tret = v4l2_subdev_call(ch->sd, video, querystd, std_id);\n\n\tif (ret == -ENOIOCTLCMD || ret == -ENODEV)\n\t\treturn -ENODATA;\n\tif (ret) {\n\t\tvpif_dbg(1, debug, \"Failed to query standard for sub devices\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vpif_g_std(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct vpif_capture_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct vpif_capture_chan_config *chan_cfg;\n\tstruct v4l2_input input;\n\n\tvpif_dbg(2, debug, \"vpif_g_std\\n\");\n\n\tif (!config->chan_config[ch->channel_id].inputs)\n\t\treturn -ENODATA;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\tinput = chan_cfg->inputs[ch->input_idx].input;\n\tif (input.capabilities != V4L2_IN_CAP_STD)\n\t\treturn -ENODATA;\n\n\t*std = ch->video.stdid;\n\treturn 0;\n}\n\n \nstatic int vpif_s_std(struct file *file, void *priv, v4l2_std_id std_id)\n{\n\tstruct vpif_capture_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct vpif_capture_chan_config *chan_cfg;\n\tstruct v4l2_input input;\n\tint ret;\n\n\tvpif_dbg(2, debug, \"vpif_s_std\\n\");\n\n\tif (!config->chan_config[ch->channel_id].inputs)\n\t\treturn -ENODATA;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\tinput = chan_cfg->inputs[ch->input_idx].input;\n\tif (input.capabilities != V4L2_IN_CAP_STD)\n\t\treturn -ENODATA;\n\n\tif (vb2_is_busy(&common->buffer_queue))\n\t\treturn -EBUSY;\n\n\t \n\tch->video.stdid = std_id;\n\tmemset(&ch->video.dv_timings, 0, sizeof(ch->video.dv_timings));\n\n\t \n\tif (vpif_update_std_info(ch)) {\n\t\tvpif_err(\"Error getting the standard info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = v4l2_subdev_call(ch->sd, video, s_std, std_id);\n\tif (ret && ret != -ENOIOCTLCMD && ret != -ENODEV) {\n\t\tvpif_dbg(1, debug, \"Failed to set standard for sub devices\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int vpif_enum_input(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_input *input)\n{\n\n\tstruct vpif_capture_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct vpif_capture_chan_config *chan_cfg;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\n\tif (input->index >= chan_cfg->input_count)\n\t\treturn -EINVAL;\n\n\tmemcpy(input, &chan_cfg->inputs[input->index].input,\n\t\tsizeof(*input));\n\treturn 0;\n}\n\n \nstatic int vpif_g_input(struct file *file, void *priv, unsigned int *index)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\n\t*index = ch->input_idx;\n\treturn 0;\n}\n\n \nstatic int vpif_s_input(struct file *file, void *priv, unsigned int index)\n{\n\tstruct vpif_capture_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct vpif_capture_chan_config *chan_cfg;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\n\tif (index >= chan_cfg->input_count)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(&common->buffer_queue))\n\t\treturn -EBUSY;\n\n\treturn vpif_set_input(config, ch, index);\n}\n\n \nstatic int vpif_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *fmt)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\n\tif (fmt->index != 0) {\n\t\tvpif_dbg(1, debug, \"Invalid format index\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ch->vpifparams.iface.if_type == VPIF_IF_RAW_BAYER)\n\t\tfmt->pixelformat = V4L2_PIX_FMT_SBGGR8;\n\telse\n\t\tfmt->pixelformat = V4L2_PIX_FMT_NV16;\n\treturn 0;\n}\n\n \nstatic int vpif_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\n\tstruct common_obj *common = &(ch->common[VPIF_VIDEO_INDEX]);\n\n\tcommon->fmt = *fmt;\n\tvpif_update_std_info(ch);\n\n\tpixfmt->field = common->fmt.fmt.pix.field;\n\tpixfmt->colorspace = common->fmt.fmt.pix.colorspace;\n\tpixfmt->bytesperline = common->fmt.fmt.pix.width;\n\tpixfmt->width = common->fmt.fmt.pix.width;\n\tpixfmt->height = common->fmt.fmt.pix.height;\n\tpixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height * 2;\n\tif (pixfmt->pixelformat == V4L2_PIX_FMT_SGRBG10) {\n\t\tpixfmt->bytesperline = common->fmt.fmt.pix.width * 2;\n\t\tpixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height;\n\t}\n\n\tdev_dbg(vpif_dev, \"%s: %d x %d; pitch=%d pixelformat=0x%08x, field=%d, size=%d\\n\", __func__,\n\t\tpixfmt->width, pixfmt->height,\n\t\tpixfmt->bytesperline, pixfmt->pixelformat,\n\t\tpixfmt->field, pixfmt->sizeimage);\n\n\treturn 0;\n}\n\n\n \nstatic int vpif_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct v4l2_pix_format *pix_fmt = &fmt->fmt.pix;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_mbus_framefmt *mbus_fmt = &format.format;\n\tint ret;\n\n\t \n\tif (common->fmt.type != fmt->type)\n\t\treturn -EINVAL;\n\n\t \n\t*fmt = common->fmt;\n\n\t \n\tret = v4l2_subdev_call(ch->sd, pad, get_fmt, NULL, &format);\n\tif (!ret && mbus_fmt->code) {\n\t\tv4l2_fill_pix_format(pix_fmt, mbus_fmt);\n\t\tpix_fmt->bytesperline = pix_fmt->width;\n\t\tif (mbus_fmt->code == MEDIA_BUS_FMT_SGRBG10_1X10) {\n\t\t\t \n\t\t\tpix_fmt->pixelformat = V4L2_PIX_FMT_SGRBG10;\n\t\t\tpix_fmt->bytesperline = pix_fmt->width * 2;\n\t\t} else if (mbus_fmt->code == MEDIA_BUS_FMT_UYVY8_2X8) {\n\t\t\t \n\t\t\tpix_fmt->pixelformat = V4L2_PIX_FMT_NV16;\n\t\t\tpix_fmt->bytesperline = pix_fmt->width * 2;\n\t\t} else {\n\t\t\tdev_warn(vpif_dev, \"%s: Unhandled media-bus format 0x%x\\n\",\n\t\t\t\t __func__, mbus_fmt->code);\n\t\t}\n\t\tpix_fmt->sizeimage = pix_fmt->bytesperline * pix_fmt->height;\n\t\tdev_dbg(vpif_dev, \"%s: %d x %d; pitch=%d, pixelformat=0x%08x, code=0x%x, field=%d, size=%d\\n\", __func__,\n\t\t\tpix_fmt->width, pix_fmt->height,\n\t\t\tpix_fmt->bytesperline, pix_fmt->pixelformat,\n\t\t\tmbus_fmt->code, pix_fmt->field, pix_fmt->sizeimage);\n\n\t\tcommon->fmt = *fmt;\n\t\tvpif_update_std_info(ch);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vpif_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tint ret;\n\n\tvpif_dbg(2, debug, \"%s\\n\", __func__);\n\n\tif (vb2_is_busy(&common->buffer_queue))\n\t\treturn -EBUSY;\n\n\tret = vpif_try_fmt_vid_cap(file, priv, fmt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcommon->fmt = *fmt;\n\treturn 0;\n}\n\n \nstatic int vpif_querycap(struct file *file, void  *priv,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct vpif_capture_config *config = vpif_dev->platform_data;\n\n\tstrscpy(cap->driver, VPIF_DRIVER_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, config->card_name, sizeof(cap->card));\n\n\treturn 0;\n}\n\n \nstatic int\nvpif_enum_dv_timings(struct file *file, void *priv,\n\t\t     struct v4l2_enum_dv_timings *timings)\n{\n\tstruct vpif_capture_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct vpif_capture_chan_config *chan_cfg;\n\tstruct v4l2_input input;\n\tint ret;\n\n\tif (!config->chan_config[ch->channel_id].inputs)\n\t\treturn -ENODATA;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\tinput = chan_cfg->inputs[ch->input_idx].input;\n\tif (input.capabilities != V4L2_IN_CAP_DV_TIMINGS)\n\t\treturn -ENODATA;\n\n\ttimings->pad = 0;\n\n\tret = v4l2_subdev_call(ch->sd, pad, enum_dv_timings, timings);\n\tif (ret == -ENOIOCTLCMD || ret == -ENODEV)\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\n\n \nstatic int\nvpif_query_dv_timings(struct file *file, void *priv,\n\t\t      struct v4l2_dv_timings *timings)\n{\n\tstruct vpif_capture_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct vpif_capture_chan_config *chan_cfg;\n\tstruct v4l2_input input;\n\tint ret;\n\n\tif (!config->chan_config[ch->channel_id].inputs)\n\t\treturn -ENODATA;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\tinput = chan_cfg->inputs[ch->input_idx].input;\n\tif (input.capabilities != V4L2_IN_CAP_DV_TIMINGS)\n\t\treturn -ENODATA;\n\n\tret = v4l2_subdev_call(ch->sd, video, query_dv_timings, timings);\n\tif (ret == -ENOIOCTLCMD || ret == -ENODEV)\n\t\treturn -ENODATA;\n\n\treturn ret;\n}\n\n \nstatic int vpif_s_dv_timings(struct file *file, void *priv,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct vpif_capture_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct vpif_params *vpifparams = &ch->vpifparams;\n\tstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct video_obj *vid_ch = &ch->video;\n\tstruct v4l2_bt_timings *bt = &vid_ch->dv_timings.bt;\n\tstruct vpif_capture_chan_config *chan_cfg;\n\tstruct v4l2_input input;\n\tint ret;\n\n\tif (!config->chan_config[ch->channel_id].inputs)\n\t\treturn -ENODATA;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\tinput = chan_cfg->inputs[ch->input_idx].input;\n\tif (input.capabilities != V4L2_IN_CAP_DV_TIMINGS)\n\t\treturn -ENODATA;\n\n\tif (timings->type != V4L2_DV_BT_656_1120) {\n\t\tvpif_dbg(2, debug, \"Timing type not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vb2_is_busy(&common->buffer_queue))\n\t\treturn -EBUSY;\n\n\t \n\tret = v4l2_subdev_call(ch->sd, video, s_dv_timings, timings);\n\tif (ret == -ENOIOCTLCMD || ret == -ENODEV)\n\t\tret = 0;\n\tif (ret < 0) {\n\t\tvpif_dbg(2, debug, \"Error setting custom DV timings\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!(timings->bt.width && timings->bt.height &&\n\t\t\t\t(timings->bt.hbackporch ||\n\t\t\t\t timings->bt.hfrontporch ||\n\t\t\t\t timings->bt.hsync) &&\n\t\t\t\ttimings->bt.vfrontporch &&\n\t\t\t\t(timings->bt.vbackporch ||\n\t\t\t\t timings->bt.vsync))) {\n\t\tvpif_dbg(2, debug, \"Timings for width, height, horizontal back porch, horizontal sync, horizontal front porch, vertical back porch, vertical sync and vertical back porch must be defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvid_ch->dv_timings = *timings;\n\n\t \n\n\tstd_info->eav2sav = V4L2_DV_BT_BLANKING_WIDTH(bt) - 8;\n\tstd_info->sav2eav = bt->width;\n\n\tstd_info->l1 = 1;\n\tstd_info->l3 = bt->vsync + bt->vbackporch + 1;\n\n\tstd_info->vsize = V4L2_DV_BT_FRAME_HEIGHT(bt);\n\tif (bt->interlaced) {\n\t\tif (bt->il_vbackporch || bt->il_vfrontporch || bt->il_vsync) {\n\t\t\tstd_info->l5 = std_info->vsize/2 -\n\t\t\t\t(bt->vfrontporch - 1);\n\t\t\tstd_info->l7 = std_info->vsize/2 + 1;\n\t\t\tstd_info->l9 = std_info->l7 + bt->il_vsync +\n\t\t\t\tbt->il_vbackporch + 1;\n\t\t\tstd_info->l11 = std_info->vsize -\n\t\t\t\t(bt->il_vfrontporch - 1);\n\t\t} else {\n\t\t\tvpif_dbg(2, debug, \"Required timing values for interlaced BT format missing\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tstd_info->l5 = std_info->vsize - (bt->vfrontporch - 1);\n\t}\n\tstrscpy(std_info->name, \"Custom timings BT656/1120\",\n\t\tsizeof(std_info->name));\n\tstd_info->width = bt->width;\n\tstd_info->height = bt->height;\n\tstd_info->frm_fmt = bt->interlaced ? 0 : 1;\n\tstd_info->ycmux_mode = 0;\n\tstd_info->capture_format = 0;\n\tstd_info->vbi_supported = 0;\n\tstd_info->hd_sd = 1;\n\tstd_info->stdid = 0;\n\n\tvid_ch->stdid = 0;\n\treturn 0;\n}\n\n \nstatic int vpif_g_dv_timings(struct file *file, void *priv,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct vpif_capture_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct video_obj *vid_ch = &ch->video;\n\tstruct vpif_capture_chan_config *chan_cfg;\n\tstruct v4l2_input input;\n\n\tif (!config->chan_config[ch->channel_id].inputs)\n\t\treturn -ENODATA;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\tinput = chan_cfg->inputs[ch->input_idx].input;\n\tif (input.capabilities != V4L2_IN_CAP_DV_TIMINGS)\n\t\treturn -ENODATA;\n\n\t*timings = vid_ch->dv_timings;\n\n\treturn 0;\n}\n\n \nstatic int vpif_log_status(struct file *filep, void *priv)\n{\n\t \n\tv4l2_device_call_all(&vpif_obj.v4l2_dev, 0, core, log_status);\n\n\treturn 0;\n}\n\n \nstatic const struct v4l2_ioctl_ops vpif_ioctl_ops = {\n\t.vidioc_querycap\t\t= vpif_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= vpif_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= vpif_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= vpif_s_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= vpif_try_fmt_vid_cap,\n\n\t.vidioc_enum_input\t\t= vpif_enum_input,\n\t.vidioc_s_input\t\t\t= vpif_s_input,\n\t.vidioc_g_input\t\t\t= vpif_g_input,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\n\t.vidioc_querystd\t\t= vpif_querystd,\n\t.vidioc_s_std\t\t\t= vpif_s_std,\n\t.vidioc_g_std\t\t\t= vpif_g_std,\n\n\t.vidioc_enum_dv_timings\t\t= vpif_enum_dv_timings,\n\t.vidioc_query_dv_timings\t= vpif_query_dv_timings,\n\t.vidioc_s_dv_timings\t\t= vpif_s_dv_timings,\n\t.vidioc_g_dv_timings\t\t= vpif_g_dv_timings,\n\n\t.vidioc_log_status\t\t= vpif_log_status,\n};\n\n \nstatic const struct v4l2_file_operations vpif_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap = vb2_fop_mmap,\n\t.poll = vb2_fop_poll\n};\n\n \nstatic int initialize_vpif(void)\n{\n\tint err, i, j;\n\tint free_channel_objects_index;\n\n\t \n\tfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {\n\t\tvpif_obj.dev[i] =\n\t\t    kzalloc(sizeof(*vpif_obj.dev[i]), GFP_KERNEL);\n\t\t \n\t\tif (!vpif_obj.dev[i]) {\n\t\t\tfree_channel_objects_index = i;\n\t\t\terr = -ENOMEM;\n\t\t\tgoto vpif_init_free_channel_objects;\n\t\t}\n\t}\n\treturn 0;\n\nvpif_init_free_channel_objects:\n\tfor (j = 0; j < free_channel_objects_index; j++)\n\t\tkfree(vpif_obj.dev[j]);\n\treturn err;\n}\n\nstatic inline void free_vpif_objs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++)\n\t\tkfree(vpif_obj.dev[i]);\n}\n\nstatic int vpif_async_bound(struct v4l2_async_notifier *notifier,\n\t\t\t    struct v4l2_subdev *subdev,\n\t\t\t    struct v4l2_async_connection *asd)\n{\n\tint i;\n\n\tfor (i = 0; i < vpif_obj.config->asd_sizes[0]; i++) {\n\t\tstruct v4l2_async_connection *_asd = vpif_obj.config->asd[i];\n\t\tconst struct fwnode_handle *fwnode = _asd->match.fwnode;\n\n\t\tif (fwnode == subdev->fwnode) {\n\t\t\tvpif_obj.sd[i] = subdev;\n\t\t\tvpif_obj.config->chan_config->inputs[i].subdev_name =\n\t\t\t\t(char *)to_of_node(subdev->fwnode)->full_name;\n\t\t\tvpif_dbg(2, debug,\n\t\t\t\t \"%s: setting input %d subdev_name = %s\\n\",\n\t\t\t\t __func__, i,\n\t\t\t\tvpif_obj.config->chan_config->inputs[i].subdev_name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < vpif_obj.config->subdev_count; i++)\n\t\tif (!strcmp(vpif_obj.config->subdev_info[i].name,\n\t\t\t    subdev->name)) {\n\t\t\tvpif_obj.sd[i] = subdev;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -EINVAL;\n}\n\nstatic int vpif_probe_complete(void)\n{\n\tstruct common_obj *common;\n\tstruct video_device *vdev;\n\tstruct channel_obj *ch;\n\tstruct vb2_queue *q;\n\tint j, err, k;\n\n\tfor (j = 0; j < VPIF_CAPTURE_MAX_DEVICES; j++) {\n\t\tch = vpif_obj.dev[j];\n\t\tch->channel_id = j;\n\t\tcommon = &(ch->common[VPIF_VIDEO_INDEX]);\n\t\tspin_lock_init(&common->irqlock);\n\t\tmutex_init(&common->lock);\n\n\t\t \n\t\terr = vpif_set_input(vpif_obj.config, ch, 0);\n\t\tif (err)\n\t\t\tgoto probe_out;\n\n\t\t \n\t\tch->video.stdid = V4L2_STD_525_60;\n\t\tmemset(&ch->video.dv_timings, 0, sizeof(ch->video.dv_timings));\n\t\tcommon->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tvpif_update_std_info(ch);\n\n\t\t \n\t\tq = &common->buffer_queue;\n\t\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\t\tq->drv_priv = ch;\n\t\tq->ops = &video_qops;\n\t\tq->mem_ops = &vb2_dma_contig_memops;\n\t\tq->buf_struct_size = sizeof(struct vpif_cap_buffer);\n\t\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\t\tq->min_buffers_needed = 1;\n\t\tq->lock = &common->lock;\n\t\tq->dev = vpif_dev;\n\n\t\terr = vb2_queue_init(q);\n\t\tif (err) {\n\t\t\tvpif_err(\"vpif_capture: vb2_queue_init() failed\\n\");\n\t\t\tgoto probe_out;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&common->dma_queue);\n\n\t\t \n\t\tvdev = &ch->video_dev;\n\t\tstrscpy(vdev->name, VPIF_DRIVER_NAME, sizeof(vdev->name));\n\t\tvdev->release = video_device_release_empty;\n\t\tvdev->fops = &vpif_fops;\n\t\tvdev->ioctl_ops = &vpif_ioctl_ops;\n\t\tvdev->v4l2_dev = &vpif_obj.v4l2_dev;\n\t\tvdev->vfl_dir = VFL_DIR_RX;\n\t\tvdev->queue = q;\n\t\tvdev->lock = &common->lock;\n\t\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\n\t\tvideo_set_drvdata(&ch->video_dev, ch);\n\t\terr = video_register_device(vdev,\n\t\t\t\t\t    VFL_TYPE_VIDEO, (j ? 1 : 0));\n\t\tif (err)\n\t\t\tgoto probe_out;\n\t}\n\n\tv4l2_info(&vpif_obj.v4l2_dev, \"VPIF capture driver initialized\\n\");\n\treturn 0;\n\nprobe_out:\n\tfor (k = 0; k < j; k++) {\n\t\t \n\t\tch = vpif_obj.dev[k];\n\t\t \n\t\tvideo_unregister_device(&ch->video_dev);\n\t}\n\n\treturn err;\n}\n\nstatic int vpif_async_complete(struct v4l2_async_notifier *notifier)\n{\n\treturn vpif_probe_complete();\n}\n\nstatic const struct v4l2_async_notifier_operations vpif_async_ops = {\n\t.bound = vpif_async_bound,\n\t.complete = vpif_async_complete,\n};\n\nstatic struct vpif_capture_config *\nvpif_capture_get_pdata(struct platform_device *pdev,\n\t\t       struct v4l2_device *v4l2_dev)\n{\n\tstruct device_node *endpoint = NULL;\n\tstruct device_node *rem = NULL;\n\tstruct vpif_capture_config *pdata;\n\tstruct vpif_subdev_info *sdinfo;\n\tstruct vpif_capture_chan_config *chan;\n\tunsigned int i;\n\n\tv4l2_async_nf_init(&vpif_obj.notifier, v4l2_dev);\n\n\t \n\tif (pdev->dev.parent && pdev->dev.parent->of_node)\n\t\tpdev->dev.of_node = pdev->dev.parent->of_node;\n\tif (!IS_ENABLED(CONFIG_OF) || !pdev->dev.of_node)\n\t\treturn pdev->dev.platform_data;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\tpdata->subdev_info =\n\t\tdevm_kcalloc(&pdev->dev,\n\t\t\t     VPIF_CAPTURE_NUM_CHANNELS,\n\t\t\t     sizeof(*pdata->subdev_info),\n\t\t\t     GFP_KERNEL);\n\n\tif (!pdata->subdev_info)\n\t\treturn NULL;\n\n\tfor (i = 0; i < VPIF_CAPTURE_NUM_CHANNELS; i++) {\n\t\tstruct v4l2_fwnode_endpoint bus_cfg = { .bus_type = 0 };\n\t\tunsigned int flags;\n\t\tint err;\n\n\t\tendpoint = of_graph_get_next_endpoint(pdev->dev.of_node,\n\t\t\t\t\t\t      endpoint);\n\t\tif (!endpoint)\n\t\t\tbreak;\n\n\t\trem = of_graph_get_remote_port_parent(endpoint);\n\t\tif (!rem) {\n\t\t\tdev_dbg(&pdev->dev, \"Remote device at %pOF not found\\n\",\n\t\t\t\tendpoint);\n\t\t\tgoto done;\n\t\t}\n\n\t\tsdinfo = &pdata->subdev_info[i];\n\t\tchan = &pdata->chan_config[i];\n\t\tchan->inputs = devm_kcalloc(&pdev->dev,\n\t\t\t\t\t    VPIF_CAPTURE_NUM_CHANNELS,\n\t\t\t\t\t    sizeof(*chan->inputs),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!chan->inputs)\n\t\t\tgoto err_cleanup;\n\n\t\tchan->input_count++;\n\t\tchan->inputs[i].input.type = V4L2_INPUT_TYPE_CAMERA;\n\t\tchan->inputs[i].input.std = V4L2_STD_ALL;\n\t\tchan->inputs[i].input.capabilities = V4L2_IN_CAP_STD;\n\n\t\terr = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint),\n\t\t\t\t\t\t &bus_cfg);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Could not parse the endpoint\\n\");\n\t\t\tof_node_put(rem);\n\t\t\tgoto done;\n\t\t}\n\n\t\tdev_dbg(&pdev->dev, \"Endpoint %pOF, bus_width = %d\\n\",\n\t\t\tendpoint, bus_cfg.bus.parallel.bus_width);\n\n\t\tflags = bus_cfg.bus.parallel.flags;\n\n\t\tif (flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\n\t\t\tchan->vpif_if.hd_pol = 1;\n\n\t\tif (flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\n\t\t\tchan->vpif_if.vd_pol = 1;\n\n\t\tdev_dbg(&pdev->dev, \"Remote device %pOF found\\n\", rem);\n\t\tsdinfo->name = rem->full_name;\n\n\t\tpdata->asd[i] = v4l2_async_nf_add_fwnode(&vpif_obj.notifier,\n\t\t\t\t\t\t\t of_fwnode_handle(rem),\n\t\t\t\t\t\t\t struct v4l2_async_connection);\n\t\tif (IS_ERR(pdata->asd[i]))\n\t\t\tgoto err_cleanup;\n\n\t\tof_node_put(rem);\n\t}\n\ndone:\n\tof_node_put(endpoint);\n\tpdata->asd_sizes[0] = i;\n\tpdata->subdev_count = i;\n\tpdata->card_name = \"DA850/OMAP-L138 Video Capture\";\n\n\treturn pdata;\n\nerr_cleanup:\n\tof_node_put(rem);\n\tof_node_put(endpoint);\n\tv4l2_async_nf_cleanup(&vpif_obj.notifier);\n\n\treturn NULL;\n}\n\n \nstatic __init int vpif_probe(struct platform_device *pdev)\n{\n\tstruct vpif_subdev_info *subdevdata;\n\tstruct i2c_adapter *i2c_adap;\n\tint subdev_count;\n\tint res_idx = 0;\n\tint i, err;\n\n\tvpif_dev = &pdev->dev;\n\n\terr = initialize_vpif();\n\tif (err) {\n\t\tv4l2_err(vpif_dev->driver, \"Error initializing vpif\\n\");\n\t\treturn err;\n\t}\n\n\terr = v4l2_device_register(vpif_dev, &vpif_obj.v4l2_dev);\n\tif (err) {\n\t\tv4l2_err(vpif_dev->driver, \"Error registering v4l2 device\\n\");\n\t\tgoto vpif_free;\n\t}\n\n\tdo {\n\t\tint irq;\n\n\t\terr = platform_get_irq_optional(pdev, res_idx);\n\t\tif (err < 0 && err != -ENXIO)\n\t\t\tgoto vpif_unregister;\n\t\tif (err > 0)\n\t\t\tirq = err;\n\t\telse\n\t\t\tbreak;\n\n\t\terr = devm_request_irq(&pdev->dev, irq, vpif_channel_isr,\n\t\t\t\t       IRQF_SHARED, VPIF_DRIVER_NAME,\n\t\t\t\t       (void *)(&vpif_obj.dev[res_idx]->channel_id));\n\t\tif (err)\n\t\t\tgoto vpif_unregister;\n\t} while (++res_idx);\n\n\tpdev->dev.platform_data =\n\t\tvpif_capture_get_pdata(pdev, &vpif_obj.v4l2_dev);\n\tif (!pdev->dev.platform_data) {\n\t\terr = -EINVAL;\n\t\tdev_warn(&pdev->dev, \"Missing platform data. Giving up.\\n\");\n\t\tgoto vpif_unregister;\n\t}\n\n\tvpif_obj.config = pdev->dev.platform_data;\n\n\tsubdev_count = vpif_obj.config->subdev_count;\n\tvpif_obj.sd = kcalloc(subdev_count, sizeof(*vpif_obj.sd), GFP_KERNEL);\n\tif (!vpif_obj.sd) {\n\t\terr = -ENOMEM;\n\t\tgoto probe_subdev_out;\n\t}\n\n\tif (!vpif_obj.config->asd_sizes[0]) {\n\t\tint i2c_id = vpif_obj.config->i2c_adapter_id;\n\n\t\ti2c_adap = i2c_get_adapter(i2c_id);\n\t\tWARN_ON(!i2c_adap);\n\t\tfor (i = 0; i < subdev_count; i++) {\n\t\t\tsubdevdata = &vpif_obj.config->subdev_info[i];\n\t\t\tvpif_obj.sd[i] =\n\t\t\t\tv4l2_i2c_new_subdev_board(&vpif_obj.v4l2_dev,\n\t\t\t\t\t\t\t  i2c_adap,\n\t\t\t\t\t\t\t  &subdevdata->\n\t\t\t\t\t\t\t  board_info,\n\t\t\t\t\t\t\t  NULL);\n\n\t\t\tif (!vpif_obj.sd[i]) {\n\t\t\t\tvpif_err(\"Error registering v4l2 subdevice\\n\");\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto probe_subdev_out;\n\t\t\t}\n\t\t\tv4l2_info(&vpif_obj.v4l2_dev,\n\t\t\t\t  \"registered sub device %s\\n\",\n\t\t\t\t   subdevdata->name);\n\t\t}\n\t\terr = vpif_probe_complete();\n\t\tif (err)\n\t\t\tgoto probe_subdev_out;\n\t} else {\n\t\tvpif_obj.notifier.ops = &vpif_async_ops;\n\t\terr = v4l2_async_nf_register(&vpif_obj.notifier);\n\t\tif (err) {\n\t\t\tvpif_err(\"Error registering async notifier\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto probe_subdev_out;\n\t\t}\n\t}\n\n\treturn 0;\n\nprobe_subdev_out:\n\tv4l2_async_nf_cleanup(&vpif_obj.notifier);\n\t \n\tkfree(vpif_obj.sd);\nvpif_unregister:\n\tv4l2_device_unregister(&vpif_obj.v4l2_dev);\nvpif_free:\n\tfree_vpif_objs();\n\n\treturn err;\n}\n\n \nstatic void vpif_remove(struct platform_device *device)\n{\n\tstruct channel_obj *ch;\n\tint i;\n\n\tv4l2_async_nf_unregister(&vpif_obj.notifier);\n\tv4l2_async_nf_cleanup(&vpif_obj.notifier);\n\tv4l2_device_unregister(&vpif_obj.v4l2_dev);\n\n\tkfree(vpif_obj.sd);\n\t \n\tfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {\n\t\t \n\t\tch = vpif_obj.dev[i];\n\t\t \n\t\tvideo_unregister_device(&ch->video_dev);\n\t\tkfree(vpif_obj.dev[i]);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int vpif_suspend(struct device *dev)\n{\n\n\tstruct common_obj *common;\n\tstruct channel_obj *ch;\n\tint i;\n\n\tfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {\n\t\t \n\t\tch = vpif_obj.dev[i];\n\t\tcommon = &ch->common[VPIF_VIDEO_INDEX];\n\n\t\tif (!vb2_start_streaming_called(&common->buffer_queue))\n\t\t\tcontinue;\n\n\t\tmutex_lock(&common->lock);\n\t\t \n\t\tif (ch->channel_id == VPIF_CHANNEL0_VIDEO) {\n\t\t\tenable_channel0(0);\n\t\t\tchannel0_intr_enable(0);\n\t\t}\n\t\tif (ch->channel_id == VPIF_CHANNEL1_VIDEO ||\n\t\t\tycmux_mode == 2) {\n\t\t\tenable_channel1(0);\n\t\t\tchannel1_intr_enable(0);\n\t\t}\n\t\tmutex_unlock(&common->lock);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vpif_resume(struct device *dev)\n{\n\tstruct common_obj *common;\n\tstruct channel_obj *ch;\n\tint i;\n\n\tfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {\n\t\t \n\t\tch = vpif_obj.dev[i];\n\t\tcommon = &ch->common[VPIF_VIDEO_INDEX];\n\n\t\tif (!vb2_start_streaming_called(&common->buffer_queue))\n\t\t\tcontinue;\n\n\t\tmutex_lock(&common->lock);\n\t\t \n\t\tif (ch->channel_id == VPIF_CHANNEL0_VIDEO) {\n\t\t\tenable_channel0(1);\n\t\t\tchannel0_intr_enable(1);\n\t\t}\n\t\tif (ch->channel_id == VPIF_CHANNEL1_VIDEO ||\n\t\t\tycmux_mode == 2) {\n\t\t\tenable_channel1(1);\n\t\t\tchannel1_intr_enable(1);\n\t\t}\n\t\tmutex_unlock(&common->lock);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(vpif_pm_ops, vpif_suspend, vpif_resume);\n\nstatic __refdata struct platform_driver vpif_driver = {\n\t.driver\t= {\n\t\t.name\t= VPIF_DRIVER_NAME,\n\t\t.pm\t= &vpif_pm_ops,\n\t},\n\t.probe = vpif_probe,\n\t.remove_new = vpif_remove,\n};\n\nmodule_platform_driver(vpif_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}