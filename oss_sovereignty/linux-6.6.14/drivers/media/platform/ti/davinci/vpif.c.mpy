{
  "module_name": "vpif.c",
  "hash_id": "2a5010fdf07770357f63b2f8fce04cd9c11e4cf1a311c18f4e3c1c0749cdacf0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/davinci/vpif.c",
  "human_readable_source": " \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spinlock.h>\n#include <linux/v4l2-dv-timings.h>\n#include <linux/of_graph.h>\n\n#include \"vpif.h\"\n\nMODULE_DESCRIPTION(\"TI DaVinci Video Port Interface driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define VPIF_DRIVER_NAME\t\"vpif\"\nMODULE_ALIAS(\"platform:\" VPIF_DRIVER_NAME);\n\n#define VPIF_CH0_MAX_MODES\t22\n#define VPIF_CH1_MAX_MODES\t2\n#define VPIF_CH2_MAX_MODES\t15\n#define VPIF_CH3_MAX_MODES\t2\n\nstruct vpif_data {\n\tstruct platform_device *capture;\n\tstruct platform_device *display;\n};\n\nDEFINE_SPINLOCK(vpif_lock);\nEXPORT_SYMBOL_GPL(vpif_lock);\n\nvoid __iomem *vpif_base;\nEXPORT_SYMBOL_GPL(vpif_base);\n\n \nconst struct vpif_channel_config_params vpif_ch_params[] = {\n\t \n\t{\n\t\t.name = \"480p59_94\",\n\t\t.width = 720,\n\t\t.height = 480,\n\t\t.frm_fmt = 1,\n\t\t.ycmux_mode = 0,\n\t\t.eav2sav = 138-8,\n\t\t.sav2eav = 720,\n\t\t.l1 = 1,\n\t\t.l3 = 43,\n\t\t.l5 = 523,\n\t\t.vsize = 525,\n\t\t.capture_format = 0,\n\t\t.vbi_supported = 0,\n\t\t.hd_sd = 1,\n\t\t.dv_timings = V4L2_DV_BT_CEA_720X480P59_94,\n\t},\n\t{\n\t\t.name = \"576p50\",\n\t\t.width = 720,\n\t\t.height = 576,\n\t\t.frm_fmt = 1,\n\t\t.ycmux_mode = 0,\n\t\t.eav2sav = 144-8,\n\t\t.sav2eav = 720,\n\t\t.l1 = 1,\n\t\t.l3 = 45,\n\t\t.l5 = 621,\n\t\t.vsize = 625,\n\t\t.capture_format = 0,\n\t\t.vbi_supported = 0,\n\t\t.hd_sd = 1,\n\t\t.dv_timings = V4L2_DV_BT_CEA_720X576P50,\n\t},\n\t{\n\t\t.name = \"720p50\",\n\t\t.width = 1280,\n\t\t.height = 720,\n\t\t.frm_fmt = 1,\n\t\t.ycmux_mode = 0,\n\t\t.eav2sav = 700-8,\n\t\t.sav2eav = 1280,\n\t\t.l1 = 1,\n\t\t.l3 = 26,\n\t\t.l5 = 746,\n\t\t.vsize = 750,\n\t\t.capture_format = 0,\n\t\t.vbi_supported = 0,\n\t\t.hd_sd = 1,\n\t\t.dv_timings = V4L2_DV_BT_CEA_1280X720P50,\n\t},\n\t{\n\t\t.name = \"720p60\",\n\t\t.width = 1280,\n\t\t.height = 720,\n\t\t.frm_fmt = 1,\n\t\t.ycmux_mode = 0,\n\t\t.eav2sav = 370 - 8,\n\t\t.sav2eav = 1280,\n\t\t.l1 = 1,\n\t\t.l3 = 26,\n\t\t.l5 = 746,\n\t\t.vsize = 750,\n\t\t.capture_format = 0,\n\t\t.vbi_supported = 0,\n\t\t.hd_sd = 1,\n\t\t.dv_timings = V4L2_DV_BT_CEA_1280X720P60,\n\t},\n\t{\n\t\t.name = \"1080I50\",\n\t\t.width = 1920,\n\t\t.height = 1080,\n\t\t.frm_fmt = 0,\n\t\t.ycmux_mode = 0,\n\t\t.eav2sav = 720 - 8,\n\t\t.sav2eav = 1920,\n\t\t.l1 = 1,\n\t\t.l3 = 21,\n\t\t.l5 = 561,\n\t\t.l7 = 563,\n\t\t.l9 = 584,\n\t\t.l11 = 1124,\n\t\t.vsize = 1125,\n\t\t.capture_format = 0,\n\t\t.vbi_supported = 0,\n\t\t.hd_sd = 1,\n\t\t.dv_timings = V4L2_DV_BT_CEA_1920X1080I50,\n\t},\n\t{\n\t\t.name = \"1080I60\",\n\t\t.width = 1920,\n\t\t.height = 1080,\n\t\t.frm_fmt = 0,\n\t\t.ycmux_mode = 0,\n\t\t.eav2sav = 280 - 8,\n\t\t.sav2eav = 1920,\n\t\t.l1 = 1,\n\t\t.l3 = 21,\n\t\t.l5 = 561,\n\t\t.l7 = 563,\n\t\t.l9 = 584,\n\t\t.l11 = 1124,\n\t\t.vsize = 1125,\n\t\t.capture_format = 0,\n\t\t.vbi_supported = 0,\n\t\t.hd_sd = 1,\n\t\t.dv_timings = V4L2_DV_BT_CEA_1920X1080I60,\n\t},\n\t{\n\t\t.name = \"1080p60\",\n\t\t.width = 1920,\n\t\t.height = 1080,\n\t\t.frm_fmt = 1,\n\t\t.ycmux_mode = 0,\n\t\t.eav2sav = 280 - 8,\n\t\t.sav2eav = 1920,\n\t\t.l1 = 1,\n\t\t.l3 = 42,\n\t\t.l5 = 1122,\n\t\t.vsize = 1125,\n\t\t.capture_format = 0,\n\t\t.vbi_supported = 0,\n\t\t.hd_sd = 1,\n\t\t.dv_timings = V4L2_DV_BT_CEA_1920X1080P60,\n\t},\n\n\t \n\t{\n\t\t.name = \"NTSC_M\",\n\t\t.width = 720,\n\t\t.height = 480,\n\t\t.frm_fmt = 0,\n\t\t.ycmux_mode = 1,\n\t\t.eav2sav = 268,\n\t\t.sav2eav = 1440,\n\t\t.l1 = 1,\n\t\t.l3 = 23,\n\t\t.l5 = 263,\n\t\t.l7 = 266,\n\t\t.l9 = 286,\n\t\t.l11 = 525,\n\t\t.vsize = 525,\n\t\t.capture_format = 0,\n\t\t.vbi_supported = 1,\n\t\t.hd_sd = 0,\n\t\t.stdid = V4L2_STD_525_60,\n\t},\n\t{\n\t\t.name = \"PAL_BDGHIK\",\n\t\t.width = 720,\n\t\t.height = 576,\n\t\t.frm_fmt = 0,\n\t\t.ycmux_mode = 1,\n\t\t.eav2sav = 280,\n\t\t.sav2eav = 1440,\n\t\t.l1 = 1,\n\t\t.l3 = 23,\n\t\t.l5 = 311,\n\t\t.l7 = 313,\n\t\t.l9 = 336,\n\t\t.l11 = 624,\n\t\t.vsize = 625,\n\t\t.capture_format = 0,\n\t\t.vbi_supported = 1,\n\t\t.hd_sd = 0,\n\t\t.stdid = V4L2_STD_625_50,\n\t},\n};\nEXPORT_SYMBOL_GPL(vpif_ch_params);\n\nconst unsigned int vpif_ch_params_count = ARRAY_SIZE(vpif_ch_params);\nEXPORT_SYMBOL_GPL(vpif_ch_params_count);\n\nstatic inline void vpif_wr_bit(u32 reg, u32 bit, u32 val)\n{\n\tif (val)\n\t\tvpif_set_bit(reg, bit);\n\telse\n\t\tvpif_clr_bit(reg, bit);\n}\n\n \nstruct vpif_registers {\n\tu32 h_cfg, v_cfg_00, v_cfg_01, v_cfg_02, v_cfg, ch_ctrl;\n\tu32 line_offset, vanc0_strt, vanc0_size, vanc1_strt;\n\tu32 vanc1_size, width_mask, len_mask;\n\tu8 max_modes;\n};\n\nstatic const struct vpif_registers vpifregs[VPIF_NUM_CHANNELS] = {\n\t \n\t{\n\t\tVPIF_CH0_H_CFG, VPIF_CH0_V_CFG_00, VPIF_CH0_V_CFG_01,\n\t\tVPIF_CH0_V_CFG_02, VPIF_CH0_V_CFG_03, VPIF_CH0_CTRL,\n\t\tVPIF_CH0_IMG_ADD_OFST, 0, 0, 0, 0, 0x1FFF, 0xFFF,\n\t\tVPIF_CH0_MAX_MODES,\n\t},\n\t \n\t{\n\t\tVPIF_CH1_H_CFG, VPIF_CH1_V_CFG_00, VPIF_CH1_V_CFG_01,\n\t\tVPIF_CH1_V_CFG_02, VPIF_CH1_V_CFG_03, VPIF_CH1_CTRL,\n\t\tVPIF_CH1_IMG_ADD_OFST, 0, 0, 0, 0, 0x1FFF, 0xFFF,\n\t\tVPIF_CH1_MAX_MODES,\n\t},\n\t \n\t{\n\t\tVPIF_CH2_H_CFG, VPIF_CH2_V_CFG_00, VPIF_CH2_V_CFG_01,\n\t\tVPIF_CH2_V_CFG_02, VPIF_CH2_V_CFG_03, VPIF_CH2_CTRL,\n\t\tVPIF_CH2_IMG_ADD_OFST, VPIF_CH2_VANC0_STRT, VPIF_CH2_VANC0_SIZE,\n\t\tVPIF_CH2_VANC1_STRT, VPIF_CH2_VANC1_SIZE, 0x7FF, 0x7FF,\n\t\tVPIF_CH2_MAX_MODES\n\t},\n\t \n\t{\n\t\tVPIF_CH3_H_CFG, VPIF_CH3_V_CFG_00, VPIF_CH3_V_CFG_01,\n\t\tVPIF_CH3_V_CFG_02, VPIF_CH3_V_CFG_03, VPIF_CH3_CTRL,\n\t\tVPIF_CH3_IMG_ADD_OFST, VPIF_CH3_VANC0_STRT, VPIF_CH3_VANC0_SIZE,\n\t\tVPIF_CH3_VANC1_STRT, VPIF_CH3_VANC1_SIZE, 0x7FF, 0x7FF,\n\t\tVPIF_CH3_MAX_MODES\n\t},\n};\n\n \nstatic void vpif_set_mode_info(const struct vpif_channel_config_params *config,\n\t\t\t\tu8 channel_id, u8 config_channel_id)\n{\n\tu32 value;\n\n\tvalue = (config->eav2sav & vpifregs[config_channel_id].width_mask);\n\tvalue <<= VPIF_CH_LEN_SHIFT;\n\tvalue |= (config->sav2eav & vpifregs[config_channel_id].width_mask);\n\tregw(value, vpifregs[channel_id].h_cfg);\n\n\tvalue = (config->l1 & vpifregs[config_channel_id].len_mask);\n\tvalue <<= VPIF_CH_LEN_SHIFT;\n\tvalue |= (config->l3 & vpifregs[config_channel_id].len_mask);\n\tregw(value, vpifregs[channel_id].v_cfg_00);\n\n\tvalue = (config->l5 & vpifregs[config_channel_id].len_mask);\n\tvalue <<= VPIF_CH_LEN_SHIFT;\n\tvalue |= (config->l7 & vpifregs[config_channel_id].len_mask);\n\tregw(value, vpifregs[channel_id].v_cfg_01);\n\n\tvalue = (config->l9 & vpifregs[config_channel_id].len_mask);\n\tvalue <<= VPIF_CH_LEN_SHIFT;\n\tvalue |= (config->l11 & vpifregs[config_channel_id].len_mask);\n\tregw(value, vpifregs[channel_id].v_cfg_02);\n\n\tvalue = (config->vsize & vpifregs[config_channel_id].len_mask);\n\tregw(value, vpifregs[channel_id].v_cfg);\n}\n\n \nstatic void config_vpif_params(struct vpif_params *vpifparams,\n\t\t\t\tu8 channel_id, u8 found)\n{\n\tconst struct vpif_channel_config_params *config = &vpifparams->std_info;\n\tu32 value, ch_nip, reg;\n\tu8 start, end;\n\tint i;\n\n\tstart = channel_id;\n\tend = channel_id + found;\n\n\tfor (i = start; i < end; i++) {\n\t\treg = vpifregs[i].ch_ctrl;\n\t\tif (channel_id < 2)\n\t\t\tch_nip = VPIF_CAPTURE_CH_NIP;\n\t\telse\n\t\t\tch_nip = VPIF_DISPLAY_CH_NIP;\n\n\t\tvpif_wr_bit(reg, ch_nip, config->frm_fmt);\n\t\tvpif_wr_bit(reg, VPIF_CH_YC_MUX_BIT, config->ycmux_mode);\n\t\tvpif_wr_bit(reg, VPIF_CH_INPUT_FIELD_FRAME_BIT,\n\t\t\t\t\tvpifparams->video_params.storage_mode);\n\n\t\t \n\t\tvpif_clr_bit(reg, VPIF_CH_SDR_FMT_BIT);\n\t\tvpif_wr_bit(reg, VPIF_CH_DATA_MODE_BIT, config->capture_format);\n\n\t\tif (channel_id > 1)\t \n\t\t\tvpif_set_bit(reg, VPIF_DISPLAY_PIX_EN_BIT);\n\t\telse if (config->capture_format) {\n\t\t\t \n\t\t\tvpif_wr_bit(reg, VPIF_CH_FID_POLARITY_BIT,\n\t\t\t\t\tvpifparams->iface.fid_pol);\n\t\t\tvpif_wr_bit(reg, VPIF_CH_V_VALID_POLARITY_BIT,\n\t\t\t\t\tvpifparams->iface.vd_pol);\n\t\t\tvpif_wr_bit(reg, VPIF_CH_H_VALID_POLARITY_BIT,\n\t\t\t\t\tvpifparams->iface.hd_pol);\n\n\t\t\tvalue = regr(reg);\n\t\t\t \n\t\t\tvalue &= ~(0x3u <<\n\t\t\t\t\tVPIF_CH_DATA_WIDTH_BIT);\n\t\t\tvalue |= ((vpifparams->params.data_sz) <<\n\t\t\t\t\t\t     VPIF_CH_DATA_WIDTH_BIT);\n\t\t\tregw(value, reg);\n\t\t}\n\n\t\t \n\t\tregw((vpifparams->video_params.hpitch),\n\t\t\t\t\t\tvpifregs[i].line_offset);\n\t}\n}\n\n \nint vpif_set_video_params(struct vpif_params *vpifparams, u8 channel_id)\n{\n\tconst struct vpif_channel_config_params *config = &vpifparams->std_info;\n\tint found = 1;\n\n\tvpif_set_mode_info(config, channel_id, channel_id);\n\tif (!config->ycmux_mode) {\n\t\t \n\t\tvpif_set_mode_info(config, channel_id + 1, channel_id);\n\t\tfound = 2;\n\t}\n\n\tconfig_vpif_params(vpifparams, channel_id, found);\n\n\tregw(0x80, VPIF_REQ_SIZE);\n\tregw(0x01, VPIF_EMULATION_CTRL);\n\n\treturn found;\n}\nEXPORT_SYMBOL(vpif_set_video_params);\n\nvoid vpif_set_vbi_display_params(struct vpif_vbi_params *vbiparams,\n\t\t\t\tu8 channel_id)\n{\n\tu32 value;\n\n\tvalue = 0x3F8 & (vbiparams->hstart0);\n\tvalue |= 0x3FFFFFF & ((vbiparams->vstart0) << 16);\n\tregw(value, vpifregs[channel_id].vanc0_strt);\n\n\tvalue = 0x3F8 & (vbiparams->hstart1);\n\tvalue |= 0x3FFFFFF & ((vbiparams->vstart1) << 16);\n\tregw(value, vpifregs[channel_id].vanc1_strt);\n\n\tvalue = 0x3F8 & (vbiparams->hsize0);\n\tvalue |= 0x3FFFFFF & ((vbiparams->vsize0) << 16);\n\tregw(value, vpifregs[channel_id].vanc0_size);\n\n\tvalue = 0x3F8 & (vbiparams->hsize1);\n\tvalue |= 0x3FFFFFF & ((vbiparams->vsize1) << 16);\n\tregw(value, vpifregs[channel_id].vanc1_size);\n\n}\nEXPORT_SYMBOL(vpif_set_vbi_display_params);\n\nint vpif_channel_getfid(u8 channel_id)\n{\n\treturn (regr(vpifregs[channel_id].ch_ctrl) & VPIF_CH_FID_MASK)\n\t\t\t\t\t>> VPIF_CH_FID_SHIFT;\n}\nEXPORT_SYMBOL(vpif_channel_getfid);\n\nstatic void vpif_pdev_release(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tkfree(pdev);\n}\n\nstatic int vpif_probe(struct platform_device *pdev)\n{\n\tstatic struct resource res_irq;\n\tstruct platform_device *pdev_capture, *pdev_display;\n\tstruct device_node *endpoint = NULL;\n\tstruct vpif_data *data;\n\tint ret;\n\tint irq;\n\n\tvpif_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(vpif_base))\n\t\treturn PTR_ERR(vpif_base);\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, data);\n\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get(&pdev->dev);\n\n\t \n\tendpoint = of_graph_get_next_endpoint(pdev->dev.of_node,\n\t\t\t\t\t      endpoint);\n\tif (!endpoint)\n\t\treturn 0;\n\tof_node_put(endpoint);\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_put_rpm;\n\t}\n\tres_irq = DEFINE_RES_IRQ_NAMED(irq, of_node_full_name(pdev->dev.of_node));\n\tres_irq.flags |= irq_get_trigger_type(irq);\n\n\tpdev_capture = kzalloc(sizeof(*pdev_capture), GFP_KERNEL);\n\tif (!pdev_capture) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_rpm;\n\t}\n\n\tpdev_capture->name = \"vpif_capture\";\n\tpdev_capture->id = -1;\n\tpdev_capture->resource = &res_irq;\n\tpdev_capture->num_resources = 1;\n\tpdev_capture->dev.dma_mask = pdev->dev.dma_mask;\n\tpdev_capture->dev.coherent_dma_mask = pdev->dev.coherent_dma_mask;\n\tpdev_capture->dev.parent = &pdev->dev;\n\tpdev_capture->dev.release = vpif_pdev_release;\n\n\tret = platform_device_register(pdev_capture);\n\tif (ret)\n\t\tgoto err_put_pdev_capture;\n\n\tpdev_display = kzalloc(sizeof(*pdev_display), GFP_KERNEL);\n\tif (!pdev_display) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_pdev_capture;\n\t}\n\n\tpdev_display->name = \"vpif_display\";\n\tpdev_display->id = -1;\n\tpdev_display->resource = &res_irq;\n\tpdev_display->num_resources = 1;\n\tpdev_display->dev.dma_mask = pdev->dev.dma_mask;\n\tpdev_display->dev.coherent_dma_mask = pdev->dev.coherent_dma_mask;\n\tpdev_display->dev.parent = &pdev->dev;\n\tpdev_display->dev.release = vpif_pdev_release;\n\n\tret = platform_device_register(pdev_display);\n\tif (ret)\n\t\tgoto err_put_pdev_display;\n\n\tdata->capture = pdev_capture;\n\tdata->display = pdev_display;\n\n\treturn 0;\n\nerr_put_pdev_display:\n\tplatform_device_put(pdev_display);\nerr_put_pdev_capture:\n\tplatform_device_put(pdev_capture);\nerr_put_rpm:\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tkfree(data);\n\n\treturn ret;\n}\n\nstatic void vpif_remove(struct platform_device *pdev)\n{\n\tstruct vpif_data *data = platform_get_drvdata(pdev);\n\n\tif (data->capture)\n\t\tplatform_device_unregister(data->capture);\n\tif (data->display)\n\t\tplatform_device_unregister(data->display);\n\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tkfree(data);\n}\n\n#ifdef CONFIG_PM\nstatic int vpif_suspend(struct device *dev)\n{\n\tpm_runtime_put(dev);\n\treturn 0;\n}\n\nstatic int vpif_resume(struct device *dev)\n{\n\tpm_runtime_get(dev);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops vpif_pm = {\n\t.suspend        = vpif_suspend,\n\t.resume         = vpif_resume,\n};\n\n#define vpif_pm_ops (&vpif_pm)\n#else\n#define vpif_pm_ops NULL\n#endif\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id vpif_of_match[] = {\n\t{ .compatible = \"ti,da850-vpif\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, vpif_of_match);\n#endif\n\nstatic struct platform_driver vpif_driver = {\n\t.driver = {\n\t\t.of_match_table = of_match_ptr(vpif_of_match),\n\t\t.name\t= VPIF_DRIVER_NAME,\n\t\t.pm\t= vpif_pm_ops,\n\t},\n\t.remove_new = vpif_remove,\n\t.probe = vpif_probe,\n};\n\nstatic void vpif_exit(void)\n{\n\tplatform_driver_unregister(&vpif_driver);\n}\n\nstatic int __init vpif_init(void)\n{\n\treturn platform_driver_register(&vpif_driver);\n}\nsubsys_initcall(vpif_init);\nmodule_exit(vpif_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}