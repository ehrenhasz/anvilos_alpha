{
  "module_name": "vpif_display.c",
  "hash_id": "d2cf4ea1fe4b02935a1c0bae69769c4f8f8f414e2db0f3dfe97b5b672604f800",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/davinci/vpif_display.c",
  "human_readable_source": " \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-ioctl.h>\n\n#include \"vpif.h\"\n#include \"vpif_display.h\"\n\nMODULE_DESCRIPTION(\"TI DaVinci VPIF Display driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(VPIF_DISPLAY_VERSION);\n\n#define VPIF_V4L2_STD (V4L2_STD_525_60 | V4L2_STD_625_50)\n\n#define vpif_err(fmt, arg...)\tv4l2_err(&vpif_obj.v4l2_dev, fmt, ## arg)\n#define vpif_dbg(level, debug, fmt, arg...)\t\\\n\t\tv4l2_dbg(level, debug, &vpif_obj.v4l2_dev, fmt, ## arg)\n\nstatic int debug = 1;\n\nmodule_param(debug, int, 0644);\n\nMODULE_PARM_DESC(debug, \"Debug level 0-1\");\n\n#define VPIF_DRIVER_NAME\t\"vpif_display\"\nMODULE_ALIAS(\"platform:\" VPIF_DRIVER_NAME);\n\n \nstatic int ycmux_mode;\n\nstatic u8 channel_first_int[VPIF_NUMOBJECTS][2] = { {1, 1} };\n\nstatic struct vpif_device vpif_obj = { {NULL} };\nstatic struct device *vpif_dev;\nstatic void vpif_calculate_offsets(struct channel_obj *ch);\nstatic void vpif_config_addr(struct channel_obj *ch, int muxmode);\n\nstatic inline\nstruct vpif_disp_buffer *to_vpif_buffer(struct vb2_v4l2_buffer *vb)\n{\n\treturn container_of(vb, struct vpif_disp_buffer, vb);\n}\n\n \nstatic int vpif_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct channel_obj *ch = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct common_obj *common;\n\n\tcommon = &ch->common[VPIF_VIDEO_INDEX];\n\n\tvb2_set_plane_payload(vb, 0, common->fmt.fmt.pix.sizeimage);\n\tif (vb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0))\n\t\treturn -EINVAL;\n\n\tvbuf->field = common->fmt.fmt.pix.field;\n\n\tif (vb->vb2_queue->type != V4L2_BUF_TYPE_SLICED_VBI_OUTPUT) {\n\t\tunsigned long addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\n\t\tif (!ISALIGNED(addr + common->ytop_off) ||\n\t\t\t!ISALIGNED(addr + common->ybtm_off) ||\n\t\t\t!ISALIGNED(addr + common->ctop_off) ||\n\t\t\t!ISALIGNED(addr + common->cbtm_off)) {\n\t\t\tvpif_err(\"buffer offset not aligned to 8 bytes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vpif_buffer_queue_setup(struct vb2_queue *vq,\n\t\t\t\tunsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct channel_obj *ch = vb2_get_drv_priv(vq);\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tunsigned size = common->fmt.fmt.pix.sizeimage;\n\n\tif (*nplanes) {\n\t\tif (sizes[0] < size)\n\t\t\treturn -EINVAL;\n\t\tsize = sizes[0];\n\t}\n\n\tif (vq->num_buffers + *nbuffers < 3)\n\t\t*nbuffers = 3 - vq->num_buffers;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\t \n\tvpif_calculate_offsets(ch);\n\n\treturn 0;\n}\n\n \nstatic void vpif_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vpif_disp_buffer *buf = to_vpif_buffer(vbuf);\n\tstruct channel_obj *ch = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct common_obj *common;\n\tunsigned long flags;\n\n\tcommon = &ch->common[VPIF_VIDEO_INDEX];\n\n\t \n\tspin_lock_irqsave(&common->irqlock, flags);\n\tlist_add_tail(&buf->list, &common->dma_queue);\n\tspin_unlock_irqrestore(&common->irqlock, flags);\n}\n\n \nstatic int vpif_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct vpif_display_config *vpif_config_data =\n\t\t\t\t\tvpif_dev->platform_data;\n\tstruct channel_obj *ch = vb2_get_drv_priv(vq);\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct vpif_params *vpif = &ch->vpifparams;\n\tstruct vpif_disp_buffer *buf, *tmp;\n\tunsigned long addr, flags;\n\tint ret;\n\n\tspin_lock_irqsave(&common->irqlock, flags);\n\n\t \n\tch->field_id = 0;\n\n\t \n\tif (vpif_config_data->set_clock) {\n\t\tret = vpif_config_data->set_clock(ch->vpifparams.std_info.\n\t\tycmux_mode, ch->vpifparams.std_info.hd_sd);\n\t\tif (ret < 0) {\n\t\t\tvpif_err(\"can't set clock\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tret = vpif_set_video_params(vpif, ch->channel_id + 2);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tycmux_mode = ret;\n\tvpif_config_addr(ch, ret);\n\t \n\tcommon->next_frm = common->cur_frm =\n\t\t\t    list_entry(common->dma_queue.next,\n\t\t\t\t       struct vpif_disp_buffer, list);\n\n\tlist_del(&common->cur_frm->list);\n\tspin_unlock_irqrestore(&common->irqlock, flags);\n\n\taddr = vb2_dma_contig_plane_dma_addr(&common->cur_frm->vb.vb2_buf, 0);\n\tcommon->set_addr((addr + common->ytop_off),\n\t\t\t    (addr + common->ybtm_off),\n\t\t\t    (addr + common->ctop_off),\n\t\t\t    (addr + common->cbtm_off));\n\n\t \n\tchannel_first_int[VPIF_VIDEO_INDEX][ch->channel_id] = 1;\n\tif (VPIF_CHANNEL2_VIDEO == ch->channel_id) {\n\t\tchannel2_intr_assert();\n\t\tchannel2_intr_enable(1);\n\t\tenable_channel2(1);\n\t\tif (vpif_config_data->chan_config[VPIF_CHANNEL2_VIDEO].clip_en)\n\t\t\tchannel2_clipping_enable(1);\n\t}\n\n\tif (VPIF_CHANNEL3_VIDEO == ch->channel_id || ycmux_mode == 2) {\n\t\tchannel3_intr_assert();\n\t\tchannel3_intr_enable(1);\n\t\tenable_channel3(1);\n\t\tif (vpif_config_data->chan_config[VPIF_CHANNEL3_VIDEO].clip_en)\n\t\t\tchannel3_clipping_enable(1);\n\t}\n\n\treturn 0;\n\nerr:\n\tlist_for_each_entry_safe(buf, tmp, &common->dma_queue, list) {\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t}\n\tspin_unlock_irqrestore(&common->irqlock, flags);\n\n\treturn ret;\n}\n\n \nstatic void vpif_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct channel_obj *ch = vb2_get_drv_priv(vq);\n\tstruct common_obj *common;\n\tunsigned long flags;\n\n\tcommon = &ch->common[VPIF_VIDEO_INDEX];\n\n\t \n\tif (VPIF_CHANNEL2_VIDEO == ch->channel_id) {\n\t\tenable_channel2(0);\n\t\tchannel2_intr_enable(0);\n\t}\n\tif (VPIF_CHANNEL3_VIDEO == ch->channel_id || ycmux_mode == 2) {\n\t\tenable_channel3(0);\n\t\tchannel3_intr_enable(0);\n\t}\n\n\t \n\tspin_lock_irqsave(&common->irqlock, flags);\n\tif (common->cur_frm == common->next_frm) {\n\t\tvb2_buffer_done(&common->cur_frm->vb.vb2_buf,\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\t} else {\n\t\tif (common->cur_frm)\n\t\t\tvb2_buffer_done(&common->cur_frm->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\tif (common->next_frm)\n\t\t\tvb2_buffer_done(&common->next_frm->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_ERROR);\n\t}\n\n\twhile (!list_empty(&common->dma_queue)) {\n\t\tcommon->next_frm = list_entry(common->dma_queue.next,\n\t\t\t\t\t\tstruct vpif_disp_buffer, list);\n\t\tlist_del(&common->next_frm->list);\n\t\tvb2_buffer_done(&common->next_frm->vb.vb2_buf,\n\t\t\t\tVB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&common->irqlock, flags);\n}\n\nstatic const struct vb2_ops video_qops = {\n\t.queue_setup\t\t= vpif_buffer_queue_setup,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.buf_prepare\t\t= vpif_buffer_prepare,\n\t.start_streaming\t= vpif_start_streaming,\n\t.stop_streaming\t\t= vpif_stop_streaming,\n\t.buf_queue\t\t= vpif_buffer_queue,\n};\n\nstatic void process_progressive_mode(struct common_obj *common)\n{\n\tunsigned long addr;\n\n\tspin_lock(&common->irqlock);\n\t \n\tcommon->next_frm = list_entry(common->dma_queue.next,\n\t\t\t\tstruct vpif_disp_buffer, list);\n\t \n\tlist_del(&common->next_frm->list);\n\tspin_unlock(&common->irqlock);\n\n\t \n\taddr = vb2_dma_contig_plane_dma_addr(&common->next_frm->vb.vb2_buf, 0);\n\tcommon->set_addr(addr + common->ytop_off,\n\t\t\t\t addr + common->ybtm_off,\n\t\t\t\t addr + common->ctop_off,\n\t\t\t\t addr + common->cbtm_off);\n}\n\nstatic void process_interlaced_mode(int fid, struct common_obj *common)\n{\n\t \n\t \n\tif (0 == fid) {\n\t\tif (common->cur_frm == common->next_frm)\n\t\t\treturn;\n\n\t\t \n\t\t \n\t\tcommon->cur_frm->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\t \n\t\tvb2_buffer_done(&common->cur_frm->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_DONE);\n\t\t \n\t\tcommon->cur_frm = common->next_frm;\n\n\t} else if (1 == fid) {\t \n\t\tspin_lock(&common->irqlock);\n\t\tif (list_empty(&common->dma_queue)\n\t\t    || (common->cur_frm != common->next_frm)) {\n\t\t\tspin_unlock(&common->irqlock);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&common->irqlock);\n\t\t \n\t\t \n\t\tprocess_progressive_mode(common);\n\t}\n}\n\n \nstatic irqreturn_t vpif_channel_isr(int irq, void *dev_id)\n{\n\tstruct vpif_device *dev = &vpif_obj;\n\tstruct channel_obj *ch;\n\tstruct common_obj *common;\n\tint fid = -1, i;\n\tint channel_id;\n\n\tchannel_id = *(int *)(dev_id);\n\tif (!vpif_intr_status(channel_id + 2))\n\t\treturn IRQ_NONE;\n\n\tch = dev->dev[channel_id];\n\tfor (i = 0; i < VPIF_NUMOBJECTS; i++) {\n\t\tcommon = &ch->common[i];\n\t\t \n\n\t\tif (1 == ch->vpifparams.std_info.frm_fmt) {\n\t\t\tspin_lock(&common->irqlock);\n\t\t\tif (list_empty(&common->dma_queue)) {\n\t\t\t\tspin_unlock(&common->irqlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&common->irqlock);\n\n\t\t\t \n\t\t\tif (!channel_first_int[i][channel_id]) {\n\t\t\t\t \n\t\t\t\tcommon->cur_frm->vb.vb2_buf.timestamp =\n\t\t\t\t\t\tktime_get_ns();\n\t\t\t\tvb2_buffer_done(&common->cur_frm->vb.vb2_buf,\n\t\t\t\t\t\tVB2_BUF_STATE_DONE);\n\t\t\t\t \n\t\t\t\tcommon->cur_frm = common->next_frm;\n\t\t\t}\n\n\t\t\tchannel_first_int[i][channel_id] = 0;\n\t\t\tprocess_progressive_mode(common);\n\t\t} else {\n\t\t\t \n\t\t\t \n\n\t\t\tif (channel_first_int[i][channel_id]) {\n\t\t\t\tchannel_first_int[i][channel_id] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (0 == i) {\n\t\t\t\tch->field_id ^= 1;\n\t\t\t\t \n\t\t\t\tfid = vpif_channel_getfid(ch->channel_id + 2);\n\t\t\t\t \n\t\t\t\tif (fid != ch->field_id) {\n\t\t\t\t\t \n\t\t\t\t\tif (0 == fid)\n\t\t\t\t\t\tch->field_id = fid;\n\n\t\t\t\t\treturn IRQ_HANDLED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocess_interlaced_mode(fid, common);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vpif_update_std_info(struct channel_obj *ch)\n{\n\tstruct video_obj *vid_ch = &ch->video;\n\tstruct vpif_params *vpifparams = &ch->vpifparams;\n\tstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\n\tconst struct vpif_channel_config_params *config;\n\n\tint i;\n\n\tfor (i = 0; i < vpif_ch_params_count; i++) {\n\t\tconfig = &vpif_ch_params[i];\n\t\tif (config->hd_sd == 0) {\n\t\t\tvpif_dbg(2, debug, \"SD format\\n\");\n\t\t\tif (config->stdid & vid_ch->stdid) {\n\t\t\t\tmemcpy(std_info, config, sizeof(*config));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i == vpif_ch_params_count) {\n\t\tvpif_dbg(1, debug, \"Format not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vpif_update_resolution(struct channel_obj *ch)\n{\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct video_obj *vid_ch = &ch->video;\n\tstruct vpif_params *vpifparams = &ch->vpifparams;\n\tstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\n\n\tif (!vid_ch->stdid && !vid_ch->dv_timings.bt.height)\n\t\treturn -EINVAL;\n\n\tif (vid_ch->stdid) {\n\t\tif (vpif_update_std_info(ch))\n\t\t\treturn -EINVAL;\n\t}\n\n\tcommon->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422P;\n\tcommon->fmt.fmt.pix.width = std_info->width;\n\tcommon->fmt.fmt.pix.height = std_info->height;\n\tvpif_dbg(1, debug, \"Pixel details: Width = %d,Height = %d\\n\",\n\t\t\tcommon->fmt.fmt.pix.width, common->fmt.fmt.pix.height);\n\n\t \n\tcommon->height = std_info->height;\n\tcommon->width = std_info->width;\n\tcommon->fmt.fmt.pix.sizeimage = common->height * common->width * 2;\n\n\tif (vid_ch->stdid)\n\t\tcommon->fmt.fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\telse\n\t\tcommon->fmt.fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\n\n\tif (ch->vpifparams.std_info.frm_fmt)\n\t\tcommon->fmt.fmt.pix.field = V4L2_FIELD_NONE;\n\telse\n\t\tcommon->fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;\n\n\treturn 0;\n}\n\n \nstatic void vpif_calculate_offsets(struct channel_obj *ch)\n{\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct vpif_params *vpifparams = &ch->vpifparams;\n\tenum v4l2_field field = common->fmt.fmt.pix.field;\n\tstruct video_obj *vid_ch = &ch->video;\n\tunsigned int hpitch, sizeimage;\n\n\tif (V4L2_FIELD_ANY == common->fmt.fmt.pix.field) {\n\t\tif (ch->vpifparams.std_info.frm_fmt)\n\t\t\tvid_ch->buf_field = V4L2_FIELD_NONE;\n\t\telse\n\t\t\tvid_ch->buf_field = V4L2_FIELD_INTERLACED;\n\t} else {\n\t\tvid_ch->buf_field = common->fmt.fmt.pix.field;\n\t}\n\n\tsizeimage = common->fmt.fmt.pix.sizeimage;\n\n\thpitch = common->fmt.fmt.pix.bytesperline;\n\tif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\n\t    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {\n\t\tcommon->ytop_off = 0;\n\t\tcommon->ybtm_off = hpitch;\n\t\tcommon->ctop_off = sizeimage / 2;\n\t\tcommon->cbtm_off = sizeimage / 2 + hpitch;\n\t} else if (V4L2_FIELD_SEQ_TB == vid_ch->buf_field) {\n\t\tcommon->ytop_off = 0;\n\t\tcommon->ybtm_off = sizeimage / 4;\n\t\tcommon->ctop_off = sizeimage / 2;\n\t\tcommon->cbtm_off = common->ctop_off + sizeimage / 4;\n\t} else if (V4L2_FIELD_SEQ_BT == vid_ch->buf_field) {\n\t\tcommon->ybtm_off = 0;\n\t\tcommon->ytop_off = sizeimage / 4;\n\t\tcommon->cbtm_off = sizeimage / 2;\n\t\tcommon->ctop_off = common->cbtm_off + sizeimage / 4;\n\t}\n\n\tif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\n\t    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {\n\t\tvpifparams->video_params.storage_mode = 1;\n\t} else {\n\t\tvpifparams->video_params.storage_mode = 0;\n\t}\n\n\tif (ch->vpifparams.std_info.frm_fmt == 1) {\n\t\tvpifparams->video_params.hpitch =\n\t\t    common->fmt.fmt.pix.bytesperline;\n\t} else {\n\t\tif ((field == V4L2_FIELD_ANY) ||\n\t\t\t(field == V4L2_FIELD_INTERLACED))\n\t\t\tvpifparams->video_params.hpitch =\n\t\t\t    common->fmt.fmt.pix.bytesperline * 2;\n\t\telse\n\t\t\tvpifparams->video_params.hpitch =\n\t\t\t    common->fmt.fmt.pix.bytesperline;\n\t}\n\n\tch->vpifparams.video_params.stdid = ch->vpifparams.std_info.stdid;\n}\n\nstatic void vpif_config_addr(struct channel_obj *ch, int muxmode)\n{\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\n\tif (VPIF_CHANNEL3_VIDEO == ch->channel_id) {\n\t\tcommon->set_addr = ch3_set_video_buf_addr;\n\t} else {\n\t\tif (2 == muxmode)\n\t\t\tcommon->set_addr = ch2_set_video_buf_addr_yc_nmux;\n\t\telse\n\t\t\tcommon->set_addr = ch2_set_video_buf_addr;\n\t}\n}\n\n \n \nstatic int vpif_querycap(struct file *file, void  *priv,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct vpif_display_config *config = vpif_dev->platform_data;\n\n\tstrscpy(cap->driver, VPIF_DRIVER_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, config->card_name, sizeof(cap->card));\n\n\treturn 0;\n}\n\nstatic int vpif_enum_fmt_vid_out(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *fmt)\n{\n\tif (fmt->index != 0)\n\t\treturn -EINVAL;\n\n\t \n\tfmt->pixelformat = V4L2_PIX_FMT_YUV422P;\n\treturn 0;\n}\n\nstatic int vpif_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\n\t \n\tif (common->fmt.type != fmt->type)\n\t\treturn -EINVAL;\n\n\tif (vpif_update_resolution(ch))\n\t\treturn -EINVAL;\n\t*fmt = common->fmt;\n\treturn 0;\n}\n\nstatic int vpif_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\n\n\t \n\tif (pixfmt->pixelformat != V4L2_PIX_FMT_YUV422P)\n\t\tpixfmt->pixelformat = common->fmt.fmt.pix.pixelformat;\n\n\tif (vpif_update_resolution(ch))\n\t\treturn -EINVAL;\n\n\tpixfmt->colorspace = common->fmt.fmt.pix.colorspace;\n\tpixfmt->field = common->fmt.fmt.pix.field;\n\tpixfmt->bytesperline = common->fmt.fmt.pix.width;\n\tpixfmt->width = common->fmt.fmt.pix.width;\n\tpixfmt->height = common->fmt.fmt.pix.height;\n\tpixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height * 2;\n\n\treturn 0;\n}\n\nstatic int vpif_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\n\tint ret;\n\n\tif (vb2_is_busy(&common->buffer_queue))\n\t\treturn -EBUSY;\n\n\tret = vpif_try_fmt_vid_out(file, priv, fmt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcommon->fmt.fmt.pix = *pixfmt;\n\n\t \n\tcommon->fmt = *fmt;\n\treturn 0;\n}\n\nstatic int vpif_s_std(struct file *file, void *priv, v4l2_std_id std_id)\n{\n\tstruct vpif_display_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct vpif_display_chan_config *chan_cfg;\n\tstruct v4l2_output output;\n\tint ret;\n\n\tif (!config->chan_config[ch->channel_id].outputs)\n\t\treturn -ENODATA;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\toutput = chan_cfg->outputs[ch->output_idx].output;\n\tif (output.capabilities != V4L2_OUT_CAP_STD)\n\t\treturn -ENODATA;\n\n\tif (vb2_is_busy(&common->buffer_queue))\n\t\treturn -EBUSY;\n\n\n\tif (!(std_id & VPIF_V4L2_STD))\n\t\treturn -EINVAL;\n\n\t \n\tch->video.stdid = std_id;\n\tmemset(&ch->video.dv_timings, 0, sizeof(ch->video.dv_timings));\n\t \n\tif (vpif_update_resolution(ch))\n\t\treturn -EINVAL;\n\n\tcommon->fmt.fmt.pix.bytesperline = common->fmt.fmt.pix.width;\n\n\tret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, video,\n\t\t\t\t\t\ts_std_output, std_id);\n\tif (ret < 0) {\n\t\tvpif_err(\"Failed to set output standard\\n\");\n\t\treturn ret;\n\t}\n\n\tret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, video,\n\t\t\t\t\t\t\ts_std, std_id);\n\tif (ret < 0)\n\t\tvpif_err(\"Failed to set standard for sub devices\\n\");\n\treturn ret;\n}\n\nstatic int vpif_g_std(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct vpif_display_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct vpif_display_chan_config *chan_cfg;\n\tstruct v4l2_output output;\n\n\tif (!config->chan_config[ch->channel_id].outputs)\n\t\treturn -ENODATA;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\toutput = chan_cfg->outputs[ch->output_idx].output;\n\tif (output.capabilities != V4L2_OUT_CAP_STD)\n\t\treturn -ENODATA;\n\n\t*std = ch->video.stdid;\n\treturn 0;\n}\n\nstatic int vpif_enum_output(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_output *output)\n{\n\n\tstruct vpif_display_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct vpif_display_chan_config *chan_cfg;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\tif (output->index >= chan_cfg->output_count) {\n\t\tvpif_dbg(1, debug, \"Invalid output index\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*output = chan_cfg->outputs[output->index].output;\n\treturn 0;\n}\n\n \nstatic int\nvpif_output_to_subdev(struct vpif_display_config *vpif_cfg,\n\t\t      struct vpif_display_chan_config *chan_cfg, int index)\n{\n\tstruct vpif_subdev_info *subdev_info;\n\tconst char *subdev_name;\n\tint i;\n\n\tvpif_dbg(2, debug, \"vpif_output_to_subdev\\n\");\n\n\tif (!chan_cfg->outputs)\n\t\treturn -1;\n\n\tsubdev_name = chan_cfg->outputs[index].subdev_name;\n\tif (!subdev_name)\n\t\treturn -1;\n\n\t \n\tfor (i = 0; i < vpif_cfg->subdev_count; i++) {\n\t\tsubdev_info = &vpif_cfg->subdevinfo[i];\n\t\tif (!strcmp(subdev_info->name, subdev_name))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n \nstatic int vpif_set_output(struct vpif_display_config *vpif_cfg,\n\t\t      struct channel_obj *ch, int index)\n{\n\tstruct vpif_display_chan_config *chan_cfg =\n\t\t&vpif_cfg->chan_config[ch->channel_id];\n\tstruct v4l2_subdev *sd = NULL;\n\tu32 input = 0, output = 0;\n\tint sd_index;\n\tint ret;\n\n\tsd_index = vpif_output_to_subdev(vpif_cfg, chan_cfg, index);\n\tif (sd_index >= 0)\n\t\tsd = vpif_obj.sd[sd_index];\n\n\tif (sd) {\n\t\tinput = chan_cfg->outputs[index].input_route;\n\t\toutput = chan_cfg->outputs[index].output_route;\n\t\tret = v4l2_subdev_call(sd, video, s_routing, input, output, 0);\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD) {\n\t\t\tvpif_err(\"Failed to set output\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\tch->output_idx = index;\n\tch->sd = sd;\n\tif (chan_cfg->outputs)\n\t\t \n\t\tch->video_dev.tvnorms = chan_cfg->outputs[index].output.std;\n\treturn 0;\n}\n\nstatic int vpif_s_output(struct file *file, void *priv, unsigned int i)\n{\n\tstruct vpif_display_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct vpif_display_chan_config *chan_cfg;\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\n\tif (vb2_is_busy(&common->buffer_queue))\n\t\treturn -EBUSY;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\n\tif (i >= chan_cfg->output_count)\n\t\treturn -EINVAL;\n\n\treturn vpif_set_output(config, ch, i);\n}\n\nstatic int vpif_g_output(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\n\t*i = ch->output_idx;\n\n\treturn 0;\n}\n\n \nstatic int\nvpif_enum_dv_timings(struct file *file, void *priv,\n\t\t     struct v4l2_enum_dv_timings *timings)\n{\n\tstruct vpif_display_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct vpif_display_chan_config *chan_cfg;\n\tstruct v4l2_output output;\n\tint ret;\n\n\tif (!config->chan_config[ch->channel_id].outputs)\n\t\treturn -ENODATA;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\toutput = chan_cfg->outputs[ch->output_idx].output;\n\tif (output.capabilities != V4L2_OUT_CAP_DV_TIMINGS)\n\t\treturn -ENODATA;\n\n\ttimings->pad = 0;\n\n\tret = v4l2_subdev_call(ch->sd, pad, enum_dv_timings, timings);\n\tif (ret == -ENOIOCTLCMD || ret == -ENODEV)\n\t\treturn -EINVAL;\n\treturn ret;\n}\n\n \nstatic int vpif_s_dv_timings(struct file *file, void *priv,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct vpif_display_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct vpif_params *vpifparams = &ch->vpifparams;\n\tstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\n\tstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\n\tstruct video_obj *vid_ch = &ch->video;\n\tstruct v4l2_bt_timings *bt = &vid_ch->dv_timings.bt;\n\tstruct vpif_display_chan_config *chan_cfg;\n\tstruct v4l2_output output;\n\tint ret;\n\n\tif (!config->chan_config[ch->channel_id].outputs)\n\t\treturn -ENODATA;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\toutput = chan_cfg->outputs[ch->output_idx].output;\n\tif (output.capabilities != V4L2_OUT_CAP_DV_TIMINGS)\n\t\treturn -ENODATA;\n\n\tif (vb2_is_busy(&common->buffer_queue))\n\t\treturn -EBUSY;\n\n\tif (timings->type != V4L2_DV_BT_656_1120) {\n\t\tvpif_dbg(2, debug, \"Timing type not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = v4l2_subdev_call(ch->sd, video, s_dv_timings, timings);\n\tif (ret == -ENOIOCTLCMD || ret == -ENODEV)\n\t\tret = 0;\n\tif (ret < 0) {\n\t\tvpif_dbg(2, debug, \"Error setting custom DV timings\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!(timings->bt.width && timings->bt.height &&\n\t\t\t\t(timings->bt.hbackporch ||\n\t\t\t\t timings->bt.hfrontporch ||\n\t\t\t\t timings->bt.hsync) &&\n\t\t\t\ttimings->bt.vfrontporch &&\n\t\t\t\t(timings->bt.vbackporch ||\n\t\t\t\t timings->bt.vsync))) {\n\t\tvpif_dbg(2, debug, \"Timings for width, height, horizontal back porch, horizontal sync, horizontal front porch, vertical back porch, vertical sync and vertical back porch must be defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvid_ch->dv_timings = *timings;\n\n\t \n\n\tstd_info->eav2sav = V4L2_DV_BT_BLANKING_WIDTH(bt) - 8;\n\tstd_info->sav2eav = bt->width;\n\n\tstd_info->l1 = 1;\n\tstd_info->l3 = bt->vsync + bt->vbackporch + 1;\n\n\tstd_info->vsize = V4L2_DV_BT_FRAME_HEIGHT(bt);\n\tif (bt->interlaced) {\n\t\tif (bt->il_vbackporch || bt->il_vfrontporch || bt->il_vsync) {\n\t\t\tstd_info->l5 = std_info->vsize/2 -\n\t\t\t\t(bt->vfrontporch - 1);\n\t\t\tstd_info->l7 = std_info->vsize/2 + 1;\n\t\t\tstd_info->l9 = std_info->l7 + bt->il_vsync +\n\t\t\t\tbt->il_vbackporch + 1;\n\t\t\tstd_info->l11 = std_info->vsize -\n\t\t\t\t(bt->il_vfrontporch - 1);\n\t\t} else {\n\t\t\tvpif_dbg(2, debug, \"Required timing values for interlaced BT format missing\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tstd_info->l5 = std_info->vsize - (bt->vfrontporch - 1);\n\t}\n\tstrscpy(std_info->name, \"Custom timings BT656/1120\",\n\t\tsizeof(std_info->name));\n\tstd_info->width = bt->width;\n\tstd_info->height = bt->height;\n\tstd_info->frm_fmt = bt->interlaced ? 0 : 1;\n\tstd_info->ycmux_mode = 0;\n\tstd_info->capture_format = 0;\n\tstd_info->vbi_supported = 0;\n\tstd_info->hd_sd = 1;\n\tstd_info->stdid = 0;\n\tvid_ch->stdid = 0;\n\n\treturn 0;\n}\n\n \nstatic int vpif_g_dv_timings(struct file *file, void *priv,\n\t\tstruct v4l2_dv_timings *timings)\n{\n\tstruct vpif_display_config *config = vpif_dev->platform_data;\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct channel_obj *ch = video_get_drvdata(vdev);\n\tstruct vpif_display_chan_config *chan_cfg;\n\tstruct video_obj *vid_ch = &ch->video;\n\tstruct v4l2_output output;\n\n\tif (!config->chan_config[ch->channel_id].outputs)\n\t\tgoto error;\n\n\tchan_cfg = &config->chan_config[ch->channel_id];\n\toutput = chan_cfg->outputs[ch->output_idx].output;\n\n\tif (output.capabilities != V4L2_OUT_CAP_DV_TIMINGS)\n\t\tgoto error;\n\n\t*timings = vid_ch->dv_timings;\n\n\treturn 0;\nerror:\n\treturn -ENODATA;\n}\n\n \nstatic int vpif_log_status(struct file *filep, void *priv)\n{\n\t \n\tv4l2_device_call_all(&vpif_obj.v4l2_dev, 0, core, log_status);\n\n\treturn 0;\n}\n\n \nstatic const struct v4l2_ioctl_ops vpif_ioctl_ops = {\n\t.vidioc_querycap\t\t= vpif_querycap,\n\t.vidioc_enum_fmt_vid_out\t= vpif_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out\t\t= vpif_g_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t\t= vpif_s_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t\t= vpif_try_fmt_vid_out,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\n\t.vidioc_s_std\t\t\t= vpif_s_std,\n\t.vidioc_g_std\t\t\t= vpif_g_std,\n\n\t.vidioc_enum_output\t\t= vpif_enum_output,\n\t.vidioc_s_output\t\t= vpif_s_output,\n\t.vidioc_g_output\t\t= vpif_g_output,\n\n\t.vidioc_enum_dv_timings\t\t= vpif_enum_dv_timings,\n\t.vidioc_s_dv_timings\t\t= vpif_s_dv_timings,\n\t.vidioc_g_dv_timings\t\t= vpif_g_dv_timings,\n\n\t.vidioc_log_status\t\t= vpif_log_status,\n};\n\nstatic const struct v4l2_file_operations vpif_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= vb2_fop_release,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.poll\t\t= vb2_fop_poll\n};\n\n \nstatic int initialize_vpif(void)\n{\n\tint free_channel_objects_index;\n\tint err, i, j;\n\n\t \n\tfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\n\t\tvpif_obj.dev[i] =\n\t\t    kzalloc(sizeof(struct channel_obj), GFP_KERNEL);\n\t\t \n\t\tif (!vpif_obj.dev[i]) {\n\t\t\tfree_channel_objects_index = i;\n\t\t\terr = -ENOMEM;\n\t\t\tgoto vpif_init_free_channel_objects;\n\t\t}\n\t}\n\n\treturn 0;\n\nvpif_init_free_channel_objects:\n\tfor (j = 0; j < free_channel_objects_index; j++)\n\t\tkfree(vpif_obj.dev[j]);\n\treturn err;\n}\n\nstatic void free_vpif_objs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++)\n\t\tkfree(vpif_obj.dev[i]);\n}\n\nstatic int vpif_probe_complete(void)\n{\n\tstruct common_obj *common;\n\tstruct video_device *vdev;\n\tstruct channel_obj *ch;\n\tstruct vb2_queue *q;\n\tint j, err, k;\n\n\tfor (j = 0; j < VPIF_DISPLAY_MAX_DEVICES; j++) {\n\t\tch = vpif_obj.dev[j];\n\t\t \n\t\tfor (k = 0; k < VPIF_NUMOBJECTS; k++) {\n\t\t\tcommon = &ch->common[k];\n\t\t\tspin_lock_init(&common->irqlock);\n\t\t\tmutex_init(&common->lock);\n\t\t\tcommon->set_addr = NULL;\n\t\t\tcommon->ytop_off = 0;\n\t\t\tcommon->ybtm_off = 0;\n\t\t\tcommon->ctop_off = 0;\n\t\t\tcommon->cbtm_off = 0;\n\t\t\tcommon->cur_frm = NULL;\n\t\t\tcommon->next_frm = NULL;\n\t\t\tmemset(&common->fmt, 0, sizeof(common->fmt));\n\t\t}\n\t\tch->initialized = 0;\n\t\tif (vpif_obj.config->subdev_count)\n\t\t\tch->sd = vpif_obj.sd[0];\n\t\tch->channel_id = j;\n\n\t\tmemset(&ch->vpifparams, 0, sizeof(ch->vpifparams));\n\n\t\tch->common[VPIF_VIDEO_INDEX].fmt.type =\n\t\t\t\t\t\tV4L2_BUF_TYPE_VIDEO_OUTPUT;\n\n\t\t \n\t\terr = vpif_set_output(vpif_obj.config, ch, 0);\n\t\tif (err)\n\t\t\tgoto probe_out;\n\n\t\t \n\t\tch->video.stdid = V4L2_STD_525_60;\n\t\tmemset(&ch->video.dv_timings, 0, sizeof(ch->video.dv_timings));\n\t\tvpif_update_resolution(ch);\n\n\t\t \n\t\tq = &common->buffer_queue;\n\t\tq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\t\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\t\tq->drv_priv = ch;\n\t\tq->ops = &video_qops;\n\t\tq->mem_ops = &vb2_dma_contig_memops;\n\t\tq->buf_struct_size = sizeof(struct vpif_disp_buffer);\n\t\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\t\tq->min_buffers_needed = 1;\n\t\tq->lock = &common->lock;\n\t\tq->dev = vpif_dev;\n\t\terr = vb2_queue_init(q);\n\t\tif (err) {\n\t\t\tvpif_err(\"vpif_display: vb2_queue_init() failed\\n\");\n\t\t\tgoto probe_out;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&common->dma_queue);\n\n\t\t \n\t\tvpif_dbg(1, debug, \"channel=%p,channel->video_dev=%p\\n\",\n\t\t\t ch, &ch->video_dev);\n\n\t\t \n\t\tvdev = &ch->video_dev;\n\t\tstrscpy(vdev->name, VPIF_DRIVER_NAME, sizeof(vdev->name));\n\t\tvdev->release = video_device_release_empty;\n\t\tvdev->fops = &vpif_fops;\n\t\tvdev->ioctl_ops = &vpif_ioctl_ops;\n\t\tvdev->v4l2_dev = &vpif_obj.v4l2_dev;\n\t\tvdev->vfl_dir = VFL_DIR_TX;\n\t\tvdev->queue = q;\n\t\tvdev->lock = &common->lock;\n\t\tvdev->device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\n\t\tvideo_set_drvdata(&ch->video_dev, ch);\n\t\terr = video_register_device(vdev, VFL_TYPE_VIDEO,\n\t\t\t\t\t    (j ? 3 : 2));\n\t\tif (err < 0)\n\t\t\tgoto probe_out;\n\t}\n\n\treturn 0;\n\nprobe_out:\n\tfor (k = 0; k < j; k++) {\n\t\tch = vpif_obj.dev[k];\n\t\tvideo_unregister_device(&ch->video_dev);\n\t}\n\treturn err;\n}\n\n \nstatic __init int vpif_probe(struct platform_device *pdev)\n{\n\tstruct vpif_subdev_info *subdevdata;\n\tstruct i2c_adapter *i2c_adap;\n\tint subdev_count;\n\tint res_idx = 0;\n\tint i, err;\n\n\tif (!pdev->dev.platform_data) {\n\t\tdev_warn(&pdev->dev, \"Missing platform data.  Giving up.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvpif_dev = &pdev->dev;\n\terr = initialize_vpif();\n\n\tif (err) {\n\t\tv4l2_err(vpif_dev->driver, \"Error initializing vpif\\n\");\n\t\treturn err;\n\t}\n\n\terr = v4l2_device_register(vpif_dev, &vpif_obj.v4l2_dev);\n\tif (err) {\n\t\tv4l2_err(vpif_dev->driver, \"Error registering v4l2 device\\n\");\n\t\tgoto vpif_free;\n\t}\n\n\tdo {\n\t\tint irq;\n\n\t\terr = platform_get_irq_optional(pdev, res_idx);\n\t\tif (err < 0 && err != -ENXIO)\n\t\t\tgoto vpif_unregister;\n\t\tif (err > 0)\n\t\t\tirq = err;\n\t\telse\n\t\t\tbreak;\n\n\t\terr = devm_request_irq(&pdev->dev, irq, vpif_channel_isr,\n\t\t\t\t       IRQF_SHARED, VPIF_DRIVER_NAME,\n\t\t\t\t       (void *)(&vpif_obj.dev[res_idx]->channel_id));\n\t\tif (err) {\n\t\t\tvpif_err(\"VPIF IRQ request failed\\n\");\n\t\t\tgoto vpif_unregister;\n\t\t}\n\t} while (++res_idx);\n\n\tvpif_obj.config = pdev->dev.platform_data;\n\tsubdev_count = vpif_obj.config->subdev_count;\n\tsubdevdata = vpif_obj.config->subdevinfo;\n\tvpif_obj.sd = kcalloc(subdev_count, sizeof(*vpif_obj.sd), GFP_KERNEL);\n\tif (!vpif_obj.sd) {\n\t\terr = -ENOMEM;\n\t\tgoto vpif_unregister;\n\t}\n\n\ti2c_adap = i2c_get_adapter(vpif_obj.config->i2c_adapter_id);\n\tfor (i = 0; i < subdev_count; i++) {\n\t\tvpif_obj.sd[i] =\n\t\t\tv4l2_i2c_new_subdev_board(&vpif_obj.v4l2_dev,\n\t\t\t\t\t\t  i2c_adap,\n\t\t\t\t\t\t  &subdevdata[i].board_info,\n\t\t\t\t\t\t  NULL);\n\t\tif (!vpif_obj.sd[i]) {\n\t\t\tvpif_err(\"Error registering v4l2 subdevice\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto probe_subdev_out;\n\t\t}\n\n\t\tvpif_obj.sd[i]->grp_id = 1 << i;\n\t}\n\terr = vpif_probe_complete();\n\tif (err)\n\t\tgoto probe_subdev_out;\n\n\treturn 0;\n\nprobe_subdev_out:\n\tkfree(vpif_obj.sd);\nvpif_unregister:\n\tv4l2_device_unregister(&vpif_obj.v4l2_dev);\nvpif_free:\n\tfree_vpif_objs();\n\n\treturn err;\n}\n\n \nstatic void vpif_remove(struct platform_device *device)\n{\n\tstruct channel_obj *ch;\n\tint i;\n\n\tv4l2_device_unregister(&vpif_obj.v4l2_dev);\n\n\tkfree(vpif_obj.sd);\n\t \n\tfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\n\t\t \n\t\tch = vpif_obj.dev[i];\n\t\t \n\t\tvideo_unregister_device(&ch->video_dev);\n\t}\n\tfree_vpif_objs();\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int vpif_suspend(struct device *dev)\n{\n\tstruct common_obj *common;\n\tstruct channel_obj *ch;\n\tint i;\n\n\tfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\n\t\t \n\t\tch = vpif_obj.dev[i];\n\t\tcommon = &ch->common[VPIF_VIDEO_INDEX];\n\n\t\tif (!vb2_start_streaming_called(&common->buffer_queue))\n\t\t\tcontinue;\n\n\t\tmutex_lock(&common->lock);\n\t\t \n\t\tif (ch->channel_id == VPIF_CHANNEL2_VIDEO) {\n\t\t\tenable_channel2(0);\n\t\t\tchannel2_intr_enable(0);\n\t\t}\n\t\tif (ch->channel_id == VPIF_CHANNEL3_VIDEO ||\n\t\t\tycmux_mode == 2) {\n\t\t\tenable_channel3(0);\n\t\t\tchannel3_intr_enable(0);\n\t\t}\n\t\tmutex_unlock(&common->lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int vpif_resume(struct device *dev)\n{\n\n\tstruct common_obj *common;\n\tstruct channel_obj *ch;\n\tint i;\n\n\tfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\n\t\t \n\t\tch = vpif_obj.dev[i];\n\t\tcommon = &ch->common[VPIF_VIDEO_INDEX];\n\n\t\tif (!vb2_start_streaming_called(&common->buffer_queue))\n\t\t\tcontinue;\n\n\t\tmutex_lock(&common->lock);\n\t\t \n\t\tif (ch->channel_id == VPIF_CHANNEL2_VIDEO) {\n\t\t\tenable_channel2(1);\n\t\t\tchannel2_intr_enable(1);\n\t\t}\n\t\tif (ch->channel_id == VPIF_CHANNEL3_VIDEO ||\n\t\t\t\tycmux_mode == 2) {\n\t\t\tenable_channel3(1);\n\t\t\tchannel3_intr_enable(1);\n\t\t}\n\t\tmutex_unlock(&common->lock);\n\t}\n\n\treturn 0;\n}\n\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(vpif_pm_ops, vpif_suspend, vpif_resume);\n\nstatic __refdata struct platform_driver vpif_driver = {\n\t.driver\t= {\n\t\t\t.name\t= VPIF_DRIVER_NAME,\n\t\t\t.pm\t= &vpif_pm_ops,\n\t},\n\t.probe\t= vpif_probe,\n\t.remove_new = vpif_remove,\n};\n\nmodule_platform_driver(vpif_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}