{
  "module_name": "cal.c",
  "hash_id": "7398a1e71cf900fe4dea2bc239fd15b2117e83e9e903220916513e7aa018e4c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/cal/cal.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n\n#include <media/media-device.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/videobuf2-core.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"cal.h\"\n#include \"cal_regs.h\"\n\nMODULE_DESCRIPTION(\"TI CAL driver\");\nMODULE_AUTHOR(\"Benoit Parrot, <bparrot@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(\"0.1.0\");\n\nint cal_video_nr = -1;\nmodule_param_named(video_nr, cal_video_nr, uint, 0644);\nMODULE_PARM_DESC(video_nr, \"videoX start number, -1 is autodetect\");\n\nunsigned int cal_debug;\nmodule_param_named(debug, cal_debug, uint, 0644);\nMODULE_PARM_DESC(debug, \"activates debug info\");\n\n#ifdef CONFIG_VIDEO_TI_CAL_MC\n#define CAL_MC_API_DEFAULT 1\n#else\n#define CAL_MC_API_DEFAULT 0\n#endif\n\nbool cal_mc_api = CAL_MC_API_DEFAULT;\nmodule_param_named(mc_api, cal_mc_api, bool, 0444);\nMODULE_PARM_DESC(mc_api, \"activates the MC API\");\n\n \n\nconst struct cal_format_info cal_formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.code\t\t= MEDIA_BUS_FMT_YUYV8_1X16,\n\t\t.bpp\t\t= 16,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_UYVY,\n\t\t.code\t\t= MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.bpp\t\t= 16,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YVYU,\n\t\t.code\t\t= MEDIA_BUS_FMT_YVYU8_1X16,\n\t\t.bpp\t\t= 16,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_VYUY,\n\t\t.code\t\t= MEDIA_BUS_FMT_VYUY8_1X16,\n\t\t.bpp\t\t= 16,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.code\t\t= MEDIA_BUS_FMT_RGB565_1X16,\n\t\t.bpp\t\t= 16,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.code\t\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.bpp\t\t= 8,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG8,\n\t\t.code\t\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.bpp\t\t= 8,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.code\t\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.bpp\t\t= 8,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB8,\n\t\t.code\t\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.bpp\t\t= 8,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR10,\n\t\t.code\t\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.bpp\t\t= 10,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG10,\n\t\t.code\t\t= MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.bpp\t\t= 10,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG10,\n\t\t.code\t\t= MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.bpp\t\t= 10,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB10,\n\t\t.code\t\t= MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.bpp\t\t= 10,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR12,\n\t\t.code\t\t= MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.bpp\t\t= 12,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG12,\n\t\t.code\t\t= MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.bpp\t\t= 12,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG12,\n\t\t.code\t\t= MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.bpp\t\t= 12,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB12,\n\t\t.code\t\t= MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.bpp\t\t= 12,\n\t},\n};\n\nconst unsigned int cal_num_formats = ARRAY_SIZE(cal_formats);\n\nconst struct cal_format_info *cal_format_by_fourcc(u32 fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cal_formats); ++i) {\n\t\tif (cal_formats[i].fourcc == fourcc)\n\t\t\treturn &cal_formats[i];\n\t}\n\n\treturn NULL;\n}\n\nconst struct cal_format_info *cal_format_by_code(u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cal_formats); ++i) {\n\t\tif (cal_formats[i].code == code)\n\t\t\treturn &cal_formats[i];\n\t}\n\n\treturn NULL;\n}\n\n \n\nstatic const struct cal_camerarx_data dra72x_cal_camerarx[] = {\n\t{\n\t\t.fields = {\n\t\t\t[F_CTRLCLKEN] = { 10, 10 },\n\t\t\t[F_CAMMODE] = { 11, 12 },\n\t\t\t[F_LANEENABLE] = { 13, 16 },\n\t\t\t[F_CSI_MODE] = { 17, 17 },\n\t\t},\n\t\t.num_lanes = 4,\n\t},\n\t{\n\t\t.fields = {\n\t\t\t[F_CTRLCLKEN] = { 0, 0 },\n\t\t\t[F_CAMMODE] = { 1, 2 },\n\t\t\t[F_LANEENABLE] = { 3, 4 },\n\t\t\t[F_CSI_MODE] = { 5, 5 },\n\t\t},\n\t\t.num_lanes = 2,\n\t},\n};\n\nstatic const struct cal_data dra72x_cal_data = {\n\t.camerarx = dra72x_cal_camerarx,\n\t.num_csi2_phy = ARRAY_SIZE(dra72x_cal_camerarx),\n};\n\nstatic const struct cal_data dra72x_es1_cal_data = {\n\t.camerarx = dra72x_cal_camerarx,\n\t.num_csi2_phy = ARRAY_SIZE(dra72x_cal_camerarx),\n\t.flags = DRA72_CAL_PRE_ES2_LDO_DISABLE,\n};\n\nstatic const struct cal_camerarx_data dra76x_cal_csi_phy[] = {\n\t{\n\t\t.fields = {\n\t\t\t[F_CTRLCLKEN] = { 8, 8 },\n\t\t\t[F_CAMMODE] = { 9, 10 },\n\t\t\t[F_CSI_MODE] = { 11, 11 },\n\t\t\t[F_LANEENABLE] = { 27, 31 },\n\t\t},\n\t\t.num_lanes = 5,\n\t},\n\t{\n\t\t.fields = {\n\t\t\t[F_CTRLCLKEN] = { 0, 0 },\n\t\t\t[F_CAMMODE] = { 1, 2 },\n\t\t\t[F_CSI_MODE] = { 3, 3 },\n\t\t\t[F_LANEENABLE] = { 24, 26 },\n\t\t},\n\t\t.num_lanes = 3,\n\t},\n};\n\nstatic const struct cal_data dra76x_cal_data = {\n\t.camerarx = dra76x_cal_csi_phy,\n\t.num_csi2_phy = ARRAY_SIZE(dra76x_cal_csi_phy),\n};\n\nstatic const struct cal_camerarx_data am654_cal_csi_phy[] = {\n\t{\n\t\t.fields = {\n\t\t\t[F_CTRLCLKEN] = { 15, 15 },\n\t\t\t[F_CAMMODE] = { 24, 25 },\n\t\t\t[F_LANEENABLE] = { 0, 4 },\n\t\t},\n\t\t.num_lanes = 5,\n\t},\n};\n\nstatic const struct cal_data am654_cal_data = {\n\t.camerarx = am654_cal_csi_phy,\n\t.num_csi2_phy = ARRAY_SIZE(am654_cal_csi_phy),\n};\n\n \n\nvoid cal_quickdump_regs(struct cal_dev *cal)\n{\n\tunsigned int i;\n\n\tcal_info(cal, \"CAL Registers @ 0x%pa:\\n\", &cal->res->start);\n\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t       (__force const void *)cal->base,\n\t\t       resource_size(cal->res), false);\n\n\tfor (i = 0; i < cal->data->num_csi2_phy; ++i) {\n\t\tstruct cal_camerarx *phy = cal->phy[i];\n\n\t\tcal_info(cal, \"CSI2 Core %u Registers @ %pa:\\n\", i,\n\t\t\t &phy->res->start);\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t\t       (__force const void *)phy->base,\n\t\t\t       resource_size(phy->res),\n\t\t\t       false);\n\t}\n}\n\n \n\n#define CAL_MAX_PIX_PROC 4\n\nstatic int cal_reserve_pix_proc(struct cal_dev *cal)\n{\n\tunsigned long ret;\n\n\tspin_lock(&cal->v4l2_dev.lock);\n\n\tret = find_first_zero_bit(&cal->reserved_pix_proc_mask, CAL_MAX_PIX_PROC);\n\n\tif (ret == CAL_MAX_PIX_PROC) {\n\t\tspin_unlock(&cal->v4l2_dev.lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tcal->reserved_pix_proc_mask |= BIT(ret);\n\n\tspin_unlock(&cal->v4l2_dev.lock);\n\n\treturn ret;\n}\n\nstatic void cal_release_pix_proc(struct cal_dev *cal, unsigned int pix_proc_num)\n{\n\tspin_lock(&cal->v4l2_dev.lock);\n\n\tcal->reserved_pix_proc_mask &= ~BIT(pix_proc_num);\n\n\tspin_unlock(&cal->v4l2_dev.lock);\n}\n\nstatic void cal_ctx_csi2_config(struct cal_ctx *ctx)\n{\n\tu32 val;\n\n\tval = cal_read(ctx->cal, CAL_CSI2_CTX(ctx->phy->instance, ctx->csi2_ctx));\n\tcal_set_field(&val, ctx->cport, CAL_CSI2_CTX_CPORT_MASK);\n\t \n\tcal_set_field(&val, ctx->datatype, CAL_CSI2_CTX_DT_MASK);\n\tcal_set_field(&val, ctx->vc, CAL_CSI2_CTX_VC_MASK);\n\tcal_set_field(&val, ctx->v_fmt.fmt.pix.height, CAL_CSI2_CTX_LINES_MASK);\n\tcal_set_field(&val, CAL_CSI2_CTX_ATT_PIX, CAL_CSI2_CTX_ATT_MASK);\n\tcal_set_field(&val, CAL_CSI2_CTX_PACK_MODE_LINE,\n\t\t      CAL_CSI2_CTX_PACK_MODE_MASK);\n\tcal_write(ctx->cal, CAL_CSI2_CTX(ctx->phy->instance, ctx->csi2_ctx), val);\n\tctx_dbg(3, ctx, \"CAL_CSI2_CTX(%u, %u) = 0x%08x\\n\",\n\t\tctx->phy->instance, ctx->csi2_ctx,\n\t\tcal_read(ctx->cal, CAL_CSI2_CTX(ctx->phy->instance, ctx->csi2_ctx)));\n}\n\nstatic void cal_ctx_pix_proc_config(struct cal_ctx *ctx)\n{\n\tu32 val, extract, pack;\n\n\tswitch (ctx->fmtinfo->bpp) {\n\tcase 8:\n\t\textract = CAL_PIX_PROC_EXTRACT_B8;\n\t\tpack = CAL_PIX_PROC_PACK_B8;\n\t\tbreak;\n\tcase 10:\n\t\textract = CAL_PIX_PROC_EXTRACT_B10_MIPI;\n\t\tpack = CAL_PIX_PROC_PACK_B16;\n\t\tbreak;\n\tcase 12:\n\t\textract = CAL_PIX_PROC_EXTRACT_B12_MIPI;\n\t\tpack = CAL_PIX_PROC_PACK_B16;\n\t\tbreak;\n\tcase 16:\n\t\textract = CAL_PIX_PROC_EXTRACT_B16_LE;\n\t\tpack = CAL_PIX_PROC_PACK_B16;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_warn_once(ctx->cal->dev,\n\t\t\t      \"%s:%d:%s: bpp:%d unsupported! Overwritten with 8.\\n\",\n\t\t\t      __FILE__, __LINE__, __func__, ctx->fmtinfo->bpp);\n\t\textract = CAL_PIX_PROC_EXTRACT_B8;\n\t\tpack = CAL_PIX_PROC_PACK_B8;\n\t\tbreak;\n\t}\n\n\tval = cal_read(ctx->cal, CAL_PIX_PROC(ctx->pix_proc));\n\tcal_set_field(&val, extract, CAL_PIX_PROC_EXTRACT_MASK);\n\tcal_set_field(&val, CAL_PIX_PROC_DPCMD_BYPASS, CAL_PIX_PROC_DPCMD_MASK);\n\tcal_set_field(&val, CAL_PIX_PROC_DPCME_BYPASS, CAL_PIX_PROC_DPCME_MASK);\n\tcal_set_field(&val, pack, CAL_PIX_PROC_PACK_MASK);\n\tcal_set_field(&val, ctx->cport, CAL_PIX_PROC_CPORT_MASK);\n\tcal_set_field(&val, 1, CAL_PIX_PROC_EN_MASK);\n\tcal_write(ctx->cal, CAL_PIX_PROC(ctx->pix_proc), val);\n\tctx_dbg(3, ctx, \"CAL_PIX_PROC(%u) = 0x%08x\\n\", ctx->pix_proc,\n\t\tcal_read(ctx->cal, CAL_PIX_PROC(ctx->pix_proc)));\n}\n\nstatic void cal_ctx_wr_dma_config(struct cal_ctx *ctx)\n{\n\tunsigned int stride = ctx->v_fmt.fmt.pix.bytesperline;\n\tu32 val;\n\n\tval = cal_read(ctx->cal, CAL_WR_DMA_CTRL(ctx->dma_ctx));\n\tcal_set_field(&val, ctx->cport, CAL_WR_DMA_CTRL_CPORT_MASK);\n\tcal_set_field(&val, ctx->v_fmt.fmt.pix.height,\n\t\t      CAL_WR_DMA_CTRL_YSIZE_MASK);\n\tcal_set_field(&val, CAL_WR_DMA_CTRL_DTAG_PIX_DAT,\n\t\t      CAL_WR_DMA_CTRL_DTAG_MASK);\n\tcal_set_field(&val, CAL_WR_DMA_CTRL_PATTERN_LINEAR,\n\t\t      CAL_WR_DMA_CTRL_PATTERN_MASK);\n\tcal_set_field(&val, 1, CAL_WR_DMA_CTRL_STALL_RD_MASK);\n\tcal_write(ctx->cal, CAL_WR_DMA_CTRL(ctx->dma_ctx), val);\n\tctx_dbg(3, ctx, \"CAL_WR_DMA_CTRL(%d) = 0x%08x\\n\", ctx->dma_ctx,\n\t\tcal_read(ctx->cal, CAL_WR_DMA_CTRL(ctx->dma_ctx)));\n\n\tcal_write_field(ctx->cal, CAL_WR_DMA_OFST(ctx->dma_ctx),\n\t\t\tstride / 16, CAL_WR_DMA_OFST_MASK);\n\tctx_dbg(3, ctx, \"CAL_WR_DMA_OFST(%d) = 0x%08x\\n\", ctx->dma_ctx,\n\t\tcal_read(ctx->cal, CAL_WR_DMA_OFST(ctx->dma_ctx)));\n\n\tval = cal_read(ctx->cal, CAL_WR_DMA_XSIZE(ctx->dma_ctx));\n\t \n\tcal_set_field(&val, 0, CAL_WR_DMA_XSIZE_XSKIP_MASK);\n\t \n\tcal_set_field(&val, stride / 8, CAL_WR_DMA_XSIZE_MASK);\n\tcal_write(ctx->cal, CAL_WR_DMA_XSIZE(ctx->dma_ctx), val);\n\tctx_dbg(3, ctx, \"CAL_WR_DMA_XSIZE(%d) = 0x%08x\\n\", ctx->dma_ctx,\n\t\tcal_read(ctx->cal, CAL_WR_DMA_XSIZE(ctx->dma_ctx)));\n}\n\nvoid cal_ctx_set_dma_addr(struct cal_ctx *ctx, dma_addr_t addr)\n{\n\tcal_write(ctx->cal, CAL_WR_DMA_ADDR(ctx->dma_ctx), addr);\n}\n\nstatic void cal_ctx_wr_dma_enable(struct cal_ctx *ctx)\n{\n\tu32 val = cal_read(ctx->cal, CAL_WR_DMA_CTRL(ctx->dma_ctx));\n\n\tcal_set_field(&val, CAL_WR_DMA_CTRL_MODE_CONST,\n\t\t      CAL_WR_DMA_CTRL_MODE_MASK);\n\tcal_write(ctx->cal, CAL_WR_DMA_CTRL(ctx->dma_ctx), val);\n}\n\nstatic void cal_ctx_wr_dma_disable(struct cal_ctx *ctx)\n{\n\tu32 val = cal_read(ctx->cal, CAL_WR_DMA_CTRL(ctx->dma_ctx));\n\n\tcal_set_field(&val, CAL_WR_DMA_CTRL_MODE_DIS,\n\t\t      CAL_WR_DMA_CTRL_MODE_MASK);\n\tcal_write(ctx->cal, CAL_WR_DMA_CTRL(ctx->dma_ctx), val);\n}\n\nstatic bool cal_ctx_wr_dma_stopped(struct cal_ctx *ctx)\n{\n\tbool stopped;\n\n\tspin_lock_irq(&ctx->dma.lock);\n\tstopped = ctx->dma.state == CAL_DMA_STOPPED;\n\tspin_unlock_irq(&ctx->dma.lock);\n\n\treturn stopped;\n}\n\nstatic int\ncal_get_remote_frame_desc_entry(struct cal_ctx *ctx,\n\t\t\t\tstruct v4l2_mbus_frame_desc_entry *entry)\n{\n\tstruct v4l2_mbus_frame_desc fd;\n\tstruct media_pad *phy_source_pad;\n\tint ret;\n\n\tphy_source_pad = media_pad_remote_pad_first(&ctx->pad);\n\tif (!phy_source_pad)\n\t\treturn -ENODEV;\n\n\tret = v4l2_subdev_call(&ctx->phy->subdev, pad, get_frame_desc,\n\t\t\t       phy_source_pad->index, &fd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fd.num_entries != 1)\n\t\treturn -EINVAL;\n\n\t*entry = fd.entry[0];\n\n\treturn 0;\n}\n\nint cal_ctx_prepare(struct cal_ctx *ctx)\n{\n\tstruct v4l2_mbus_frame_desc_entry entry;\n\tint ret;\n\n\tret = cal_get_remote_frame_desc_entry(ctx, &entry);\n\n\tif (ret == -ENOIOCTLCMD) {\n\t\tctx->vc = 0;\n\t\tctx->datatype = CAL_CSI2_CTX_DT_ANY;\n\t} else if (!ret) {\n\t\tctx_dbg(2, ctx, \"Framedesc: len %u, vc %u, dt %#x\\n\",\n\t\t\tentry.length, entry.bus.csi2.vc, entry.bus.csi2.dt);\n\n\t\tctx->vc = entry.bus.csi2.vc;\n\t\tctx->datatype = entry.bus.csi2.dt;\n\t} else {\n\t\treturn ret;\n\t}\n\n\tctx->use_pix_proc = !ctx->fmtinfo->meta;\n\n\tif (ctx->use_pix_proc) {\n\t\tret = cal_reserve_pix_proc(ctx->cal);\n\t\tif (ret < 0) {\n\t\t\tctx_err(ctx, \"Failed to reserve pix proc: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tctx->pix_proc = ret;\n\t}\n\n\treturn 0;\n}\n\nvoid cal_ctx_unprepare(struct cal_ctx *ctx)\n{\n\tif (ctx->use_pix_proc)\n\t\tcal_release_pix_proc(ctx->cal, ctx->pix_proc);\n}\n\nvoid cal_ctx_start(struct cal_ctx *ctx)\n{\n\tstruct cal_camerarx *phy = ctx->phy;\n\n\t \n\n\tspin_lock(&phy->vc_lock);\n\n\tif (phy->vc_enable_count[ctx->vc]++ == 0) {\n\t\tphy->vc_frame_number[ctx->vc] = 0;\n\t\tphy->vc_sequence[ctx->vc] = 0;\n\t}\n\n\tspin_unlock(&phy->vc_lock);\n\n\tctx->dma.state = CAL_DMA_RUNNING;\n\n\t \n\tcal_ctx_csi2_config(ctx);\n\tif (ctx->use_pix_proc)\n\t\tcal_ctx_pix_proc_config(ctx);\n\tcal_ctx_wr_dma_config(ctx);\n\n\t \n\tcal_write(ctx->cal, CAL_HL_IRQENABLE_SET(1),\n\t\t  CAL_HL_IRQ_WDMA_END_MASK(ctx->dma_ctx));\n\tcal_write(ctx->cal, CAL_HL_IRQENABLE_SET(2),\n\t\t  CAL_HL_IRQ_WDMA_START_MASK(ctx->dma_ctx));\n\n\tcal_ctx_wr_dma_enable(ctx);\n}\n\nvoid cal_ctx_stop(struct cal_ctx *ctx)\n{\n\tstruct cal_camerarx *phy = ctx->phy;\n\tlong timeout;\n\n\tWARN_ON(phy->vc_enable_count[ctx->vc] == 0);\n\n\tspin_lock(&phy->vc_lock);\n\tphy->vc_enable_count[ctx->vc]--;\n\tspin_unlock(&phy->vc_lock);\n\n\t \n\tspin_lock_irq(&ctx->dma.lock);\n\tctx->dma.state = CAL_DMA_STOP_REQUESTED;\n\tspin_unlock_irq(&ctx->dma.lock);\n\n\ttimeout = wait_event_timeout(ctx->dma.wait, cal_ctx_wr_dma_stopped(ctx),\n\t\t\t\t     msecs_to_jiffies(500));\n\tif (!timeout) {\n\t\tctx_err(ctx, \"failed to disable dma cleanly\\n\");\n\t\tcal_ctx_wr_dma_disable(ctx);\n\t}\n\n\t \n\tcal_write(ctx->cal, CAL_HL_IRQENABLE_CLR(1),\n\t\t  CAL_HL_IRQ_WDMA_END_MASK(ctx->dma_ctx));\n\tcal_write(ctx->cal, CAL_HL_IRQENABLE_CLR(2),\n\t\t  CAL_HL_IRQ_WDMA_START_MASK(ctx->dma_ctx));\n\n\tctx->dma.state = CAL_DMA_STOPPED;\n\n\t \n\tcal_write(ctx->cal, CAL_CSI2_CTX(ctx->phy->instance, ctx->csi2_ctx), 0);\n\n\t \n\tif (ctx->use_pix_proc)\n\t\tcal_write(ctx->cal, CAL_PIX_PROC(ctx->pix_proc), 0);\n}\n\n \n\n \nstatic void cal_update_seq_number(struct cal_ctx *ctx)\n{\n\tstruct cal_dev *cal = ctx->cal;\n\tstruct cal_camerarx *phy = ctx->phy;\n\tu16 prev_frame_num, frame_num;\n\tu8 vc = ctx->vc;\n\n\tframe_num =\n\t\tcal_read(cal, CAL_CSI2_STATUS(phy->instance, ctx->csi2_ctx)) &\n\t\t0xffff;\n\n\tif (phy->vc_frame_number[vc] != frame_num) {\n\t\tprev_frame_num = phy->vc_frame_number[vc];\n\n\t\tif (prev_frame_num >= frame_num)\n\t\t\tphy->vc_sequence[vc] += 1;\n\t\telse\n\t\t\tphy->vc_sequence[vc] += frame_num - prev_frame_num;\n\n\t\tphy->vc_frame_number[vc] = frame_num;\n\t}\n}\n\nstatic inline void cal_irq_wdma_start(struct cal_ctx *ctx)\n{\n\tspin_lock(&ctx->dma.lock);\n\n\tif (ctx->dma.state == CAL_DMA_STOP_REQUESTED) {\n\t\t \n\t\tcal_ctx_wr_dma_disable(ctx);\n\t\tctx->dma.state = CAL_DMA_STOP_PENDING;\n\t} else if (!list_empty(&ctx->dma.queue) && !ctx->dma.pending) {\n\t\t \n\t\tstruct cal_buffer *buf;\n\t\tdma_addr_t addr;\n\n\t\tbuf = list_first_entry(&ctx->dma.queue, struct cal_buffer,\n\t\t\t\t       list);\n\t\taddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);\n\t\tcal_ctx_set_dma_addr(ctx, addr);\n\n\t\tctx->dma.pending = buf;\n\t\tlist_del(&buf->list);\n\t}\n\n\tspin_unlock(&ctx->dma.lock);\n\n\tcal_update_seq_number(ctx);\n}\n\nstatic inline void cal_irq_wdma_end(struct cal_ctx *ctx)\n{\n\tstruct cal_buffer *buf = NULL;\n\n\tspin_lock(&ctx->dma.lock);\n\n\t \n\tif (ctx->dma.state == CAL_DMA_STOP_PENDING) {\n\t\tctx->dma.state = CAL_DMA_STOPPED;\n\t\twake_up(&ctx->dma.wait);\n\t}\n\n\t \n\tif (ctx->dma.pending) {\n\t\tbuf = ctx->dma.active;\n\t\tctx->dma.active = ctx->dma.pending;\n\t\tctx->dma.pending = NULL;\n\t}\n\n\tspin_unlock(&ctx->dma.lock);\n\n\tif (buf) {\n\t\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tbuf->vb.field = ctx->v_fmt.fmt.pix.field;\n\t\tbuf->vb.sequence = ctx->phy->vc_sequence[ctx->vc];\n\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t}\n}\n\nstatic void cal_irq_handle_wdma(struct cal_ctx *ctx, bool start, bool end)\n{\n\t \n\tif (ctx->v_fmt.fmt.pix.height < 10) {\n\t\tif (start)\n\t\t\tcal_irq_wdma_start(ctx);\n\n\t\tif (end)\n\t\t\tcal_irq_wdma_end(ctx);\n\t} else {\n\t\tif (end)\n\t\t\tcal_irq_wdma_end(ctx);\n\n\t\tif (start)\n\t\t\tcal_irq_wdma_start(ctx);\n\t}\n}\n\nstatic irqreturn_t cal_irq(int irq_cal, void *data)\n{\n\tstruct cal_dev *cal = data;\n\tu32 status[3];\n\tunsigned int i;\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tstatus[i] = cal_read(cal, CAL_HL_IRQSTATUS(i));\n\t\tif (status[i])\n\t\t\tcal_write(cal, CAL_HL_IRQSTATUS(i), status[i]);\n\t}\n\n\tif (status[0]) {\n\t\tif (status[0] & CAL_HL_IRQ_OCPO_ERR_MASK)\n\t\t\tdev_err_ratelimited(cal->dev, \"OCPO ERROR\\n\");\n\n\t\tfor (i = 0; i < cal->data->num_csi2_phy; ++i) {\n\t\t\tif (status[0] & CAL_HL_IRQ_CIO_MASK(i)) {\n\t\t\t\tu32 cio_stat = cal_read(cal,\n\t\t\t\t\t\t\tCAL_CSI2_COMPLEXIO_IRQSTATUS(i));\n\n\t\t\t\tdev_err_ratelimited(cal->dev,\n\t\t\t\t\t\t    \"CIO%u error: %#08x\\n\", i, cio_stat);\n\n\t\t\t\tcal_write(cal, CAL_CSI2_COMPLEXIO_IRQSTATUS(i),\n\t\t\t\t\t  cio_stat);\n\t\t\t}\n\n\t\t\tif (status[0] & CAL_HL_IRQ_VC_MASK(i)) {\n\t\t\t\tu32 vc_stat = cal_read(cal, CAL_CSI2_VC_IRQSTATUS(i));\n\n\t\t\t\tdev_err_ratelimited(cal->dev,\n\t\t\t\t\t\t    \"CIO%u VC error: %#08x\\n\",\n\t\t\t\t\t\t    i, vc_stat);\n\n\t\t\t\tcal_write(cal, CAL_CSI2_VC_IRQSTATUS(i), vc_stat);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < cal->num_contexts; ++i) {\n\t\tbool end = !!(status[1] & CAL_HL_IRQ_WDMA_END_MASK(i));\n\t\tbool start = !!(status[2] & CAL_HL_IRQ_WDMA_START_MASK(i));\n\n\t\tif (start || end)\n\t\t\tcal_irq_handle_wdma(cal->ctx[i], start, end);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstruct cal_v4l2_async_subdev {\n\tstruct v4l2_async_connection asd;  \n\tstruct cal_camerarx *phy;\n};\n\nstatic inline struct cal_v4l2_async_subdev *\nto_cal_asd(struct v4l2_async_connection *asd)\n{\n\treturn container_of(asd, struct cal_v4l2_async_subdev, asd);\n}\n\nstatic int cal_async_notifier_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t    struct v4l2_subdev *subdev,\n\t\t\t\t    struct v4l2_async_connection *asd)\n{\n\tstruct cal_camerarx *phy = to_cal_asd(asd)->phy;\n\tint pad;\n\tint ret;\n\n\tif (phy->source) {\n\t\tphy_info(phy, \"Rejecting subdev %s (Already set!!)\",\n\t\t\t subdev->name);\n\t\treturn 0;\n\t}\n\n\tphy->source = subdev;\n\tphy_dbg(1, phy, \"Using source %s for capture\\n\", subdev->name);\n\n\tpad = media_entity_get_fwnode_pad(&subdev->entity,\n\t\t\t\t\t  of_fwnode_handle(phy->source_ep_node),\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (pad < 0) {\n\t\tphy_err(phy, \"Source %s has no connected source pad\\n\",\n\t\t\tsubdev->name);\n\t\treturn pad;\n\t}\n\n\tret = media_create_pad_link(&subdev->entity, pad,\n\t\t\t\t    &phy->subdev.entity, CAL_CAMERARX_PAD_SINK,\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\tif (ret) {\n\t\tphy_err(phy, \"Failed to create media link for source %s\\n\",\n\t\t\tsubdev->name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cal_async_notifier_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct cal_dev *cal = container_of(notifier, struct cal_dev, notifier);\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < cal->num_contexts; ++i) {\n\t\tret = cal_ctx_v4l2_register(cal->ctx[i]);\n\t\tif (ret)\n\t\t\tgoto err_ctx_unreg;\n\t}\n\n\tif (!cal_mc_api)\n\t\treturn 0;\n\n\tret = v4l2_device_register_subdev_nodes(&cal->v4l2_dev);\n\tif (ret)\n\t\tgoto err_ctx_unreg;\n\n\treturn 0;\n\nerr_ctx_unreg:\n\tfor (; i > 0; --i) {\n\t\tif (!cal->ctx[i - 1])\n\t\t\tcontinue;\n\n\t\tcal_ctx_v4l2_unregister(cal->ctx[i - 1]);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_async_notifier_operations cal_async_notifier_ops = {\n\t.bound = cal_async_notifier_bound,\n\t.complete = cal_async_notifier_complete,\n};\n\nstatic int cal_async_notifier_register(struct cal_dev *cal)\n{\n\tunsigned int i;\n\tint ret;\n\n\tv4l2_async_nf_init(&cal->notifier, &cal->v4l2_dev);\n\tcal->notifier.ops = &cal_async_notifier_ops;\n\n\tfor (i = 0; i < cal->data->num_csi2_phy; ++i) {\n\t\tstruct cal_camerarx *phy = cal->phy[i];\n\t\tstruct cal_v4l2_async_subdev *casd;\n\t\tstruct fwnode_handle *fwnode;\n\n\t\tif (!phy->source_node)\n\t\t\tcontinue;\n\n\t\tfwnode = of_fwnode_handle(phy->source_node);\n\t\tcasd = v4l2_async_nf_add_fwnode(&cal->notifier,\n\t\t\t\t\t\tfwnode,\n\t\t\t\t\t\tstruct cal_v4l2_async_subdev);\n\t\tif (IS_ERR(casd)) {\n\t\t\tphy_err(phy, \"Failed to add subdev to notifier\\n\");\n\t\t\tret = PTR_ERR(casd);\n\t\t\tgoto error;\n\t\t}\n\n\t\tcasd->phy = phy;\n\t}\n\n\tret = v4l2_async_nf_register(&cal->notifier);\n\tif (ret) {\n\t\tcal_err(cal, \"Error registering async notifier\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tv4l2_async_nf_cleanup(&cal->notifier);\n\treturn ret;\n}\n\nstatic void cal_async_notifier_unregister(struct cal_dev *cal)\n{\n\tv4l2_async_nf_unregister(&cal->notifier);\n\tv4l2_async_nf_cleanup(&cal->notifier);\n}\n\n \n\n \nstatic int cal_media_register(struct cal_dev *cal)\n{\n\tint ret;\n\n\tret = media_device_register(&cal->mdev);\n\tif (ret) {\n\t\tcal_err(cal, \"Failed to register media device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = cal_async_notifier_register(cal);\n\tif (ret) {\n\t\tmedia_device_unregister(&cal->mdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void cal_media_unregister(struct cal_dev *cal)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < cal->num_contexts; i++)\n\t\tcal_ctx_v4l2_unregister(cal->ctx[i]);\n\n\tcal_async_notifier_unregister(cal);\n\tmedia_device_unregister(&cal->mdev);\n}\n\n \nstatic int cal_media_init(struct cal_dev *cal)\n{\n\tstruct media_device *mdev = &cal->mdev;\n\tint ret;\n\n\tmdev->dev = cal->dev;\n\tmdev->hw_revision = cal->revision;\n\tstrscpy(mdev->model, \"CAL\", sizeof(mdev->model));\n\tmedia_device_init(mdev);\n\n\t \n\tcal->v4l2_dev.mdev = mdev;\n\tret = v4l2_device_register(cal->dev, &cal->v4l2_dev);\n\tif (ret) {\n\t\tcal_err(cal, \"Failed to register V4L2 device\\n\");\n\t\treturn ret;\n\t}\n\n\tvb2_dma_contig_set_max_seg_size(cal->dev, DMA_BIT_MASK(32));\n\n\treturn 0;\n}\n\n \nstatic void cal_media_cleanup(struct cal_dev *cal)\n{\n\tv4l2_device_unregister(&cal->v4l2_dev);\n\tmedia_device_cleanup(&cal->mdev);\n\n\tvb2_dma_contig_clear_max_seg_size(cal->dev);\n}\n\n \n\nstatic struct cal_ctx *cal_ctx_create(struct cal_dev *cal, int inst)\n{\n\tstruct cal_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tctx->cal = cal;\n\tctx->phy = cal->phy[inst];\n\tctx->dma_ctx = inst;\n\tctx->csi2_ctx = inst;\n\tctx->cport = inst;\n\n\tret = cal_ctx_v4l2_init(ctx);\n\tif (ret) {\n\t\tkfree(ctx);\n\t\treturn NULL;\n\t}\n\n\treturn ctx;\n}\n\nstatic void cal_ctx_destroy(struct cal_ctx *ctx)\n{\n\tcal_ctx_v4l2_cleanup(ctx);\n\n\tkfree(ctx);\n}\n\nstatic const struct of_device_id cal_of_match[] = {\n\t{\n\t\t.compatible = \"ti,dra72-cal\",\n\t\t.data = (void *)&dra72x_cal_data,\n\t},\n\t{\n\t\t.compatible = \"ti,dra72-pre-es2-cal\",\n\t\t.data = (void *)&dra72x_es1_cal_data,\n\t},\n\t{\n\t\t.compatible = \"ti,dra76-cal\",\n\t\t.data = (void *)&dra76x_cal_data,\n\t},\n\t{\n\t\t.compatible = \"ti,am654-cal\",\n\t\t.data = (void *)&am654_cal_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cal_of_match);\n\n \n\n#define CAL_HL_HWINFO_VALUE\t\t0xa3c90469\n\nstatic void cal_get_hwinfo(struct cal_dev *cal)\n{\n\tu32 hwinfo;\n\n\tcal->revision = cal_read(cal, CAL_HL_REVISION);\n\tswitch (FIELD_GET(CAL_HL_REVISION_SCHEME_MASK, cal->revision)) {\n\tcase CAL_HL_REVISION_SCHEME_H08:\n\t\tcal_dbg(3, cal, \"CAL HW revision %lu.%lu.%lu (0x%08x)\\n\",\n\t\t\tFIELD_GET(CAL_HL_REVISION_MAJOR_MASK, cal->revision),\n\t\t\tFIELD_GET(CAL_HL_REVISION_MINOR_MASK, cal->revision),\n\t\t\tFIELD_GET(CAL_HL_REVISION_RTL_MASK, cal->revision),\n\t\t\tcal->revision);\n\t\tbreak;\n\n\tcase CAL_HL_REVISION_SCHEME_LEGACY:\n\tdefault:\n\t\tcal_info(cal, \"Unexpected CAL HW revision 0x%08x\\n\",\n\t\t\t cal->revision);\n\t\tbreak;\n\t}\n\n\thwinfo = cal_read(cal, CAL_HL_HWINFO);\n\tif (hwinfo != CAL_HL_HWINFO_VALUE)\n\t\tcal_info(cal, \"CAL_HL_HWINFO = 0x%08x, expected 0x%08x\\n\",\n\t\t\t hwinfo, CAL_HL_HWINFO_VALUE);\n}\n\nstatic int cal_init_camerarx_regmap(struct cal_dev *cal)\n{\n\tstruct platform_device *pdev = to_platform_device(cal->dev);\n\tstruct device_node *np = cal->dev->of_node;\n\tstruct regmap_config config = { };\n\tstruct regmap *syscon;\n\tstruct resource *res;\n\tunsigned int offset;\n\tvoid __iomem *base;\n\n\tsyscon = syscon_regmap_lookup_by_phandle_args(np, \"ti,camerrx-control\",\n\t\t\t\t\t\t      1, &offset);\n\tif (!IS_ERR(syscon)) {\n\t\tcal->syscon_camerrx = syscon;\n\t\tcal->syscon_camerrx_offset = offset;\n\t\treturn 0;\n\t}\n\n\tdev_warn(cal->dev, \"failed to get ti,camerrx-control: %ld\\n\",\n\t\t PTR_ERR(syscon));\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"camerrx_control\");\n\tbase = devm_ioremap_resource(cal->dev, res);\n\tif (IS_ERR(base)) {\n\t\tcal_err(cal, \"failed to ioremap camerrx_control\\n\");\n\t\treturn PTR_ERR(base);\n\t}\n\n\tcal_dbg(1, cal, \"ioresource %s at %pa - %pa\\n\",\n\t\tres->name, &res->start, &res->end);\n\n\tconfig.reg_bits = 32;\n\tconfig.reg_stride = 4;\n\tconfig.val_bits = 32;\n\tconfig.max_register = resource_size(res) - 4;\n\n\tsyscon = regmap_init_mmio(NULL, base, &config);\n\tif (IS_ERR(syscon)) {\n\t\tpr_err(\"regmap init failed\\n\");\n\t\treturn PTR_ERR(syscon);\n\t}\n\n\t \n\tcal->syscon_camerrx = syscon;\n\tcal->syscon_camerrx_offset = 0;\n\n\treturn 0;\n}\n\nstatic int cal_probe(struct platform_device *pdev)\n{\n\tstruct cal_dev *cal;\n\tbool connected = false;\n\tunsigned int i;\n\tint ret;\n\tint irq;\n\n\tcal = devm_kzalloc(&pdev->dev, sizeof(*cal), GFP_KERNEL);\n\tif (!cal)\n\t\treturn -ENOMEM;\n\n\tcal->data = of_device_get_match_data(&pdev->dev);\n\tif (!cal->data) {\n\t\tdev_err(&pdev->dev, \"Could not get feature data based on compatible version\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcal->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, cal);\n\n\t \n\tcal->fclk = devm_clk_get(&pdev->dev, \"fck\");\n\tif (IS_ERR(cal->fclk)) {\n\t\tdev_err(&pdev->dev, \"cannot get CAL fclk\\n\");\n\t\treturn PTR_ERR(cal->fclk);\n\t}\n\n\tret = cal_init_camerarx_regmap(cal);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcal->res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t\"cal_top\");\n\tcal->base = devm_ioremap_resource(&pdev->dev, cal->res);\n\tif (IS_ERR(cal->base))\n\t\treturn PTR_ERR(cal->base);\n\n\tcal_dbg(1, cal, \"ioresource %s at %pa - %pa\\n\",\n\t\tcal->res->name, &cal->res->start, &cal->res->end);\n\n\tirq = platform_get_irq(pdev, 0);\n\tcal_dbg(1, cal, \"got irq# %d\\n\", irq);\n\tret = devm_request_irq(&pdev->dev, irq, cal_irq, 0, CAL_MODULE_NAME,\n\t\t\t       cal);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret)\n\t\tgoto error_pm_runtime;\n\n\tcal_get_hwinfo(cal);\n\tpm_runtime_put_sync(&pdev->dev);\n\n\t \n\tret = cal_media_init(cal);\n\tif (ret < 0)\n\t\tgoto error_pm_runtime;\n\n\t \n\tfor (i = 0; i < cal->data->num_csi2_phy; ++i) {\n\t\tcal->phy[i] = cal_camerarx_create(cal, i);\n\t\tif (IS_ERR(cal->phy[i])) {\n\t\t\tret = PTR_ERR(cal->phy[i]);\n\t\t\tcal->phy[i] = NULL;\n\t\t\tgoto error_camerarx;\n\t\t}\n\n\t\tif (cal->phy[i]->source_node)\n\t\t\tconnected = true;\n\t}\n\n\tif (!connected) {\n\t\tcal_err(cal, \"Neither port is configured, no point in staying up\\n\");\n\t\tret = -ENODEV;\n\t\tgoto error_camerarx;\n\t}\n\n\t \n\tfor (i = 0; i < cal->data->num_csi2_phy; ++i) {\n\t\tif (!cal->phy[i]->source_node)\n\t\t\tcontinue;\n\n\t\tcal->ctx[cal->num_contexts] = cal_ctx_create(cal, i);\n\t\tif (!cal->ctx[cal->num_contexts]) {\n\t\t\tcal_err(cal, \"Failed to create context %u\\n\", cal->num_contexts);\n\t\t\tret = -ENODEV;\n\t\t\tgoto error_context;\n\t\t}\n\n\t\tcal->num_contexts++;\n\t}\n\n\t \n\tret = cal_media_register(cal);\n\tif (ret)\n\t\tgoto error_context;\n\n\treturn 0;\n\nerror_context:\n\tfor (i = 0; i < cal->num_contexts; i++)\n\t\tcal_ctx_destroy(cal->ctx[i]);\n\nerror_camerarx:\n\tfor (i = 0; i < cal->data->num_csi2_phy; i++)\n\t\tcal_camerarx_destroy(cal->phy[i]);\n\n\tcal_media_cleanup(cal);\n\nerror_pm_runtime:\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void cal_remove(struct platform_device *pdev)\n{\n\tstruct cal_dev *cal = platform_get_drvdata(pdev);\n\tunsigned int i;\n\tint ret;\n\n\tcal_dbg(1, cal, \"Removing %s\\n\", CAL_MODULE_NAME);\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\n\tcal_media_unregister(cal);\n\n\tfor (i = 0; i < cal->data->num_csi2_phy; i++)\n\t\tcal_camerarx_disable(cal->phy[i]);\n\n\tfor (i = 0; i < cal->num_contexts; i++)\n\t\tcal_ctx_destroy(cal->ctx[i]);\n\n\tfor (i = 0; i < cal->data->num_csi2_phy; i++)\n\t\tcal_camerarx_destroy(cal->phy[i]);\n\n\tcal_media_cleanup(cal);\n\n\tif (ret >= 0)\n\t\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int cal_runtime_resume(struct device *dev)\n{\n\tstruct cal_dev *cal = dev_get_drvdata(dev);\n\tunsigned int i;\n\tu32 val;\n\n\tif (cal->data->flags & DRA72_CAL_PRE_ES2_LDO_DISABLE) {\n\t\t \n\t\tfor (i = 0; i < cal->data->num_csi2_phy; i++)\n\t\t\tcal_camerarx_i913_errata(cal->phy[i]);\n\t}\n\n\t \n\tcal_write(cal, CAL_HL_IRQENABLE_SET(0), CAL_HL_IRQ_OCPO_ERR_MASK);\n\n\tval = cal_read(cal, CAL_CTRL);\n\tcal_set_field(&val, CAL_CTRL_BURSTSIZE_BURST128,\n\t\t      CAL_CTRL_BURSTSIZE_MASK);\n\tcal_set_field(&val, 0xf, CAL_CTRL_TAGCNT_MASK);\n\tcal_set_field(&val, CAL_CTRL_POSTED_WRITES_NONPOSTED,\n\t\t      CAL_CTRL_POSTED_WRITES_MASK);\n\tcal_set_field(&val, 0xff, CAL_CTRL_MFLAGL_MASK);\n\tcal_set_field(&val, 0xff, CAL_CTRL_MFLAGH_MASK);\n\tcal_write(cal, CAL_CTRL, val);\n\tcal_dbg(3, cal, \"CAL_CTRL = 0x%08x\\n\", cal_read(cal, CAL_CTRL));\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cal_pm_ops = {\n\t.runtime_resume = cal_runtime_resume,\n};\n\nstatic struct platform_driver cal_pdrv = {\n\t.probe\t\t= cal_probe,\n\t.remove_new\t= cal_remove,\n\t.driver\t\t= {\n\t\t.name\t= CAL_MODULE_NAME,\n\t\t.pm\t= &cal_pm_ops,\n\t\t.of_match_table = cal_of_match,\n\t},\n};\n\nmodule_platform_driver(cal_pdrv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}