{
  "module_name": "cal-video.c",
  "hash_id": "4db25910a5aa52621e6e7e61d4f71ebf3d3ebd29ce4abb07d1b4f11fea029cc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/cal/cal-video.c",
  "human_readable_source": "\n \n\n#include <linux/ioctl.h>\n#include <linux/pm_runtime.h>\n#include <linux/videodev2.h>\n\n#include <media/media-device.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-core.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"cal.h\"\n\n \nstatic char *fourcc_to_str(u32 fmt)\n{\n\tstatic char code[5];\n\n\tcode[0] = (unsigned char)(fmt & 0xff);\n\tcode[1] = (unsigned char)((fmt >> 8) & 0xff);\n\tcode[2] = (unsigned char)((fmt >> 16) & 0xff);\n\tcode[3] = (unsigned char)((fmt >> 24) & 0xff);\n\tcode[4] = '\\0';\n\n\treturn code;\n}\n\n \n\nstatic int cal_querycap(struct file *file, void *priv,\n\t\t\tstruct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, CAL_MODULE_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, CAL_MODULE_NAME, sizeof(cap->card));\n\n\treturn 0;\n}\n\nstatic int cal_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct cal_ctx *ctx = video_drvdata(file);\n\n\t*f = ctx->v_fmt;\n\n\treturn 0;\n}\n\n \n\nstatic const struct cal_format_info *find_format_by_pix(struct cal_ctx *ctx,\n\t\t\t\t\t\t\tu32 pixelformat)\n{\n\tconst struct cal_format_info *fmtinfo;\n\tunsigned int k;\n\n\tfor (k = 0; k < ctx->num_active_fmt; k++) {\n\t\tfmtinfo = ctx->active_fmt[k];\n\t\tif (fmtinfo->fourcc == pixelformat)\n\t\t\treturn fmtinfo;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct cal_format_info *find_format_by_code(struct cal_ctx *ctx,\n\t\t\t\t\t\t\t u32 code)\n{\n\tconst struct cal_format_info *fmtinfo;\n\tunsigned int k;\n\n\tfor (k = 0; k < ctx->num_active_fmt; k++) {\n\t\tfmtinfo = ctx->active_fmt[k];\n\t\tif (fmtinfo->code == code)\n\t\t\treturn fmtinfo;\n\t}\n\n\treturn NULL;\n}\n\nstatic int cal_legacy_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t       struct v4l2_fmtdesc *f)\n{\n\tstruct cal_ctx *ctx = video_drvdata(file);\n\tconst struct cal_format_info *fmtinfo;\n\n\tif (f->index >= ctx->num_active_fmt)\n\t\treturn -EINVAL;\n\n\tfmtinfo = ctx->active_fmt[f->index];\n\n\tf->pixelformat = fmtinfo->fourcc;\n\tf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\treturn 0;\n}\n\nstatic int __subdev_get_format(struct cal_ctx *ctx,\n\t\t\t       struct v4l2_mbus_framefmt *fmt)\n{\n\tstruct v4l2_subdev_format sd_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.pad = 0,\n\t};\n\tstruct v4l2_mbus_framefmt *mbus_fmt = &sd_fmt.format;\n\tint ret;\n\n\tret = v4l2_subdev_call(ctx->phy->source, pad, get_fmt, NULL, &sd_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\t*fmt = *mbus_fmt;\n\n\tctx_dbg(1, ctx, \"%s %dx%d code:%04X\\n\", __func__,\n\t\tfmt->width, fmt->height, fmt->code);\n\n\treturn 0;\n}\n\nstatic int __subdev_set_format(struct cal_ctx *ctx,\n\t\t\t       struct v4l2_mbus_framefmt *fmt)\n{\n\tstruct v4l2_subdev_format sd_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.pad = 0,\n\t};\n\tstruct v4l2_mbus_framefmt *mbus_fmt = &sd_fmt.format;\n\tint ret;\n\n\t*mbus_fmt = *fmt;\n\n\tret = v4l2_subdev_call(ctx->phy->source, pad, set_fmt, NULL, &sd_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tctx_dbg(1, ctx, \"%s %dx%d code:%04X\\n\", __func__,\n\t\tfmt->width, fmt->height, fmt->code);\n\n\treturn 0;\n}\n\nstatic void cal_calc_format_size(struct cal_ctx *ctx,\n\t\t\t\t const struct cal_format_info *fmtinfo,\n\t\t\t\t struct v4l2_format *f)\n{\n\tu32 bpl, max_width;\n\n\t \n\tmax_width = CAL_MAX_WIDTH_BYTES / (ALIGN(fmtinfo->bpp, 8) >> 3);\n\tv4l_bound_align_image(&f->fmt.pix.width, 48, max_width, 2,\n\t\t\t      &f->fmt.pix.height, 32, CAL_MAX_HEIGHT_LINES,\n\t\t\t      0, 0);\n\n\tbpl = (f->fmt.pix.width * ALIGN(fmtinfo->bpp, 8)) >> 3;\n\tf->fmt.pix.bytesperline = ALIGN(bpl, 16);\n\n\tf->fmt.pix.sizeimage = f->fmt.pix.height *\n\t\t\t       f->fmt.pix.bytesperline;\n\n\tctx_dbg(3, ctx, \"%s: fourcc: %s size: %dx%d bpl:%d img_size:%d\\n\",\n\t\t__func__, fourcc_to_str(f->fmt.pix.pixelformat),\n\t\tf->fmt.pix.width, f->fmt.pix.height,\n\t\tf->fmt.pix.bytesperline, f->fmt.pix.sizeimage);\n}\n\nstatic int cal_legacy_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t      struct v4l2_format *f)\n{\n\tstruct cal_ctx *ctx = video_drvdata(file);\n\tconst struct cal_format_info *fmtinfo;\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint found;\n\n\tfmtinfo = find_format_by_pix(ctx, f->fmt.pix.pixelformat);\n\tif (!fmtinfo) {\n\t\tctx_dbg(3, ctx, \"Fourcc format (0x%08x) not found.\\n\",\n\t\t\tf->fmt.pix.pixelformat);\n\n\t\t \n\t\tfmtinfo = ctx->active_fmt[0];\n\t\tf->fmt.pix.pixelformat = fmtinfo->fourcc;\n\t}\n\n\tf->fmt.pix.field = ctx->v_fmt.fmt.pix.field;\n\n\t \n\tfound = false;\n\tfse.pad = 0;\n\tfse.code = fmtinfo->code;\n\tfor (fse.index = 0; ; fse.index++) {\n\t\tint ret;\n\n\t\tret = v4l2_subdev_call(ctx->phy->source, pad, enum_frame_size,\n\t\t\t\t       NULL, &fse);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif ((f->fmt.pix.width == fse.max_width) &&\n\t\t    (f->fmt.pix.height == fse.max_height)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t} else if ((f->fmt.pix.width >= fse.min_width) &&\n\t\t\t (f->fmt.pix.width <= fse.max_width) &&\n\t\t\t (f->fmt.pix.height >= fse.min_height) &&\n\t\t\t (f->fmt.pix.height <= fse.max_height)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\t \n\t\tf->fmt.pix.width = ctx->v_fmt.fmt.pix.width;\n\t\tf->fmt.pix.height =  ctx->v_fmt.fmt.pix.height;\n\t}\n\n\t \n\tf->fmt.pix.colorspace = ctx->v_fmt.fmt.pix.colorspace;\n\tcal_calc_format_size(ctx, fmtinfo, f);\n\treturn 0;\n}\n\nstatic int cal_legacy_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct cal_ctx *ctx = video_drvdata(file);\n\tstruct vb2_queue *q = &ctx->vb_vidq;\n\tstruct v4l2_subdev_format sd_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.pad = CAL_CAMERARX_PAD_SINK,\n\t};\n\tconst struct cal_format_info *fmtinfo;\n\tint ret;\n\n\tif (vb2_is_busy(q)) {\n\t\tctx_dbg(3, ctx, \"%s device busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tret = cal_legacy_try_fmt_vid_cap(file, priv, f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmtinfo = find_format_by_pix(ctx, f->fmt.pix.pixelformat);\n\n\tv4l2_fill_mbus_format(&sd_fmt.format, &f->fmt.pix, fmtinfo->code);\n\n\tret = __subdev_set_format(ctx, &sd_fmt.format);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (sd_fmt.format.code != fmtinfo->code) {\n\t\tctx_dbg(3, ctx,\n\t\t\t\"%s subdev changed format on us, this should not happen\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tv4l2_fill_pix_format(&ctx->v_fmt.fmt.pix, &sd_fmt.format);\n\tctx->v_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tctx->v_fmt.fmt.pix.pixelformat = fmtinfo->fourcc;\n\tctx->v_fmt.fmt.pix.field = sd_fmt.format.field;\n\tcal_calc_format_size(ctx, fmtinfo, &ctx->v_fmt);\n\n\tv4l2_subdev_call(&ctx->phy->subdev, pad, set_fmt, NULL, &sd_fmt);\n\n\tctx->fmtinfo = fmtinfo;\n\t*f = ctx->v_fmt;\n\n\treturn 0;\n}\n\nstatic int cal_legacy_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_frmsizeenum *fsize)\n{\n\tstruct cal_ctx *ctx = video_drvdata(file);\n\tconst struct cal_format_info *fmtinfo;\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.index = fsize->index,\n\t\t.pad = 0,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\t \n\tfmtinfo = find_format_by_pix(ctx, fsize->pixel_format);\n\tif (!fmtinfo) {\n\t\tctx_dbg(3, ctx, \"Invalid pixel code: %x\\n\",\n\t\t\tfsize->pixel_format);\n\t\treturn -EINVAL;\n\t}\n\n\tfse.code = fmtinfo->code;\n\n\tret = v4l2_subdev_call(ctx->phy->source, pad, enum_frame_size, NULL,\n\t\t\t       &fse);\n\tif (ret)\n\t\treturn ret;\n\n\tctx_dbg(1, ctx, \"%s: index: %d code: %x W:[%d,%d] H:[%d,%d]\\n\",\n\t\t__func__, fse.index, fse.code, fse.min_width, fse.max_width,\n\t\tfse.min_height, fse.max_height);\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = fse.max_width;\n\tfsize->discrete.height = fse.max_height;\n\n\treturn 0;\n}\n\nstatic int cal_legacy_enum_input(struct file *file, void *priv,\n\t\t\t\t struct v4l2_input *inp)\n{\n\tif (inp->index > 0)\n\t\treturn -EINVAL;\n\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tsprintf(inp->name, \"Camera %u\", inp->index);\n\treturn 0;\n}\n\nstatic int cal_legacy_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int cal_legacy_s_input(struct file *file, void *priv, unsigned int i)\n{\n\treturn i > 0 ? -EINVAL : 0;\n}\n\n \nstatic int cal_legacy_enum_frameintervals(struct file *file, void *priv,\n\t\t\t\t\t  struct v4l2_frmivalenum *fival)\n{\n\tstruct cal_ctx *ctx = video_drvdata(file);\n\tconst struct cal_format_info *fmtinfo;\n\tstruct v4l2_subdev_frame_interval_enum fie = {\n\t\t.index = fival->index,\n\t\t.width = fival->width,\n\t\t.height = fival->height,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tfmtinfo = find_format_by_pix(ctx, fival->pixel_format);\n\tif (!fmtinfo)\n\t\treturn -EINVAL;\n\n\tfie.code = fmtinfo->code;\n\tret = v4l2_subdev_call(ctx->phy->source, pad, enum_frame_interval,\n\t\t\t       NULL, &fie);\n\tif (ret)\n\t\treturn ret;\n\tfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tfival->discrete = fie.interval;\n\n\treturn 0;\n}\n\nstatic int cal_legacy_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct cal_ctx *ctx = video_drvdata(file);\n\n\treturn v4l2_g_parm_cap(video_devdata(file), ctx->phy->source, a);\n}\n\nstatic int cal_legacy_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct cal_ctx *ctx = video_drvdata(file);\n\n\treturn v4l2_s_parm_cap(video_devdata(file), ctx->phy->source, a);\n}\n\nstatic const struct v4l2_ioctl_ops cal_ioctl_legacy_ops = {\n\t.vidioc_querycap      = cal_querycap,\n\t.vidioc_enum_fmt_vid_cap  = cal_legacy_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap     = cal_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap   = cal_legacy_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap     = cal_legacy_s_fmt_vid_cap,\n\t.vidioc_enum_framesizes   = cal_legacy_enum_framesizes,\n\t.vidioc_reqbufs       = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs   = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf   = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf      = vb2_ioctl_querybuf,\n\t.vidioc_qbuf          = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf         = vb2_ioctl_dqbuf,\n\t.vidioc_expbuf        = vb2_ioctl_expbuf,\n\t.vidioc_enum_input    = cal_legacy_enum_input,\n\t.vidioc_g_input       = cal_legacy_g_input,\n\t.vidioc_s_input       = cal_legacy_s_input,\n\t.vidioc_enum_frameintervals = cal_legacy_enum_frameintervals,\n\t.vidioc_streamon      = vb2_ioctl_streamon,\n\t.vidioc_streamoff     = vb2_ioctl_streamoff,\n\t.vidioc_log_status    = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_g_parm\t\t= cal_legacy_g_parm,\n\t.vidioc_s_parm\t\t= cal_legacy_s_parm,\n};\n\n \n\nstatic int cal_mc_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tunsigned int i;\n\tunsigned int idx;\n\n\tif (f->index >= cal_num_formats)\n\t\treturn -EINVAL;\n\n\tidx = 0;\n\n\tfor (i = 0; i < cal_num_formats; ++i) {\n\t\tif (f->mbus_code && cal_formats[i].code != f->mbus_code)\n\t\t\tcontinue;\n\n\t\tif (idx == f->index) {\n\t\t\tf->pixelformat = cal_formats[i].fourcc;\n\t\t\tf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void cal_mc_try_fmt(struct cal_ctx *ctx, struct v4l2_format *f,\n\t\t\t   const struct cal_format_info **info)\n{\n\tstruct v4l2_pix_format *format = &f->fmt.pix;\n\tconst struct cal_format_info *fmtinfo;\n\tunsigned int bpp;\n\n\t \n\tfmtinfo = cal_format_by_fourcc(f->fmt.pix.pixelformat);\n\tif (!fmtinfo)\n\t\tfmtinfo = &cal_formats[0];\n\n\t \n\tbpp = ALIGN(fmtinfo->bpp, 8);\n\n\tformat->width = clamp_t(unsigned int, format->width,\n\t\t\t\tCAL_MIN_WIDTH_BYTES * 8 / bpp,\n\t\t\t\tCAL_MAX_WIDTH_BYTES * 8 / bpp);\n\tformat->height = clamp_t(unsigned int, format->height,\n\t\t\t\t CAL_MIN_HEIGHT_LINES, CAL_MAX_HEIGHT_LINES);\n\tformat->pixelformat = fmtinfo->fourcc;\n\n\tif (format->field == V4L2_FIELD_ANY)\n\t\tformat->field = V4L2_FIELD_NONE;\n\n\t \n\tformat->bytesperline = ALIGN(clamp(format->bytesperline,\n\t\t\t\t\t   format->width * bpp / 8,\n\t\t\t\t\t   ((1U << 14) - 1) * 16), 16);\n\n\tformat->sizeimage = format->height * format->bytesperline;\n\n\tformat->colorspace = ctx->v_fmt.fmt.pix.colorspace;\n\n\tif (info)\n\t\t*info = fmtinfo;\n\n\tctx_dbg(3, ctx, \"%s: %s %ux%u (bytesperline %u sizeimage %u)\\n\",\n\t\t__func__, fourcc_to_str(format->pixelformat),\n\t\tformat->width, format->height,\n\t\tformat->bytesperline, format->sizeimage);\n}\n\nstatic int cal_mc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct cal_ctx *ctx = video_drvdata(file);\n\n\tcal_mc_try_fmt(ctx, f, NULL);\n\treturn 0;\n}\n\nstatic int cal_mc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cal_ctx *ctx = video_drvdata(file);\n\tconst struct cal_format_info *fmtinfo;\n\n\tif (vb2_is_busy(&ctx->vb_vidq)) {\n\t\tctx_dbg(3, ctx, \"%s device busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tcal_mc_try_fmt(ctx, f, &fmtinfo);\n\n\tctx->v_fmt = *f;\n\tctx->fmtinfo = fmtinfo;\n\n\treturn 0;\n}\n\nstatic int cal_mc_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tstruct cal_ctx *ctx = video_drvdata(file);\n\tconst struct cal_format_info *fmtinfo;\n\tunsigned int bpp;\n\n\tif (fsize->index > 0)\n\t\treturn -EINVAL;\n\n\tfmtinfo = cal_format_by_fourcc(fsize->pixel_format);\n\tif (!fmtinfo) {\n\t\tctx_dbg(3, ctx, \"Invalid pixel format 0x%08x\\n\",\n\t\t\tfsize->pixel_format);\n\t\treturn -EINVAL;\n\t}\n\n\tbpp = ALIGN(fmtinfo->bpp, 8);\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise.min_width = CAL_MIN_WIDTH_BYTES * 8 / bpp;\n\tfsize->stepwise.max_width = CAL_MAX_WIDTH_BYTES * 8 / bpp;\n\tfsize->stepwise.step_width = 64 / bpp;\n\tfsize->stepwise.min_height = CAL_MIN_HEIGHT_LINES;\n\tfsize->stepwise.max_height = CAL_MAX_HEIGHT_LINES;\n\tfsize->stepwise.step_height = 1;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops cal_ioctl_mc_ops = {\n\t.vidioc_querycap      = cal_querycap,\n\t.vidioc_enum_fmt_vid_cap  = cal_mc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap     = cal_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap   = cal_mc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap     = cal_mc_s_fmt_vid_cap,\n\t.vidioc_enum_framesizes   = cal_mc_enum_framesizes,\n\t.vidioc_reqbufs       = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs   = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf   = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf      = vb2_ioctl_querybuf,\n\t.vidioc_qbuf          = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf         = vb2_ioctl_dqbuf,\n\t.vidioc_expbuf        = vb2_ioctl_expbuf,\n\t.vidioc_streamon      = vb2_ioctl_streamon,\n\t.vidioc_streamoff     = vb2_ioctl_streamoff,\n\t.vidioc_log_status    = v4l2_ctrl_log_status,\n};\n\n \n\nstatic int cal_queue_setup(struct vb2_queue *vq,\n\t\t\t   unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct cal_ctx *ctx = vb2_get_drv_priv(vq);\n\tunsigned int size = ctx->v_fmt.fmt.pix.sizeimage;\n\n\tif (vq->num_buffers + *nbuffers < 3)\n\t\t*nbuffers = 3 - vq->num_buffers;\n\n\tif (*nplanes) {\n\t\tif (sizes[0] < size)\n\t\t\treturn -EINVAL;\n\t\tsize = sizes[0];\n\t}\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\tctx_dbg(3, ctx, \"nbuffers=%d, size=%d\\n\", *nbuffers, sizes[0]);\n\n\treturn 0;\n}\n\nstatic int cal_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct cal_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct cal_buffer *buf = container_of(vb, struct cal_buffer,\n\t\t\t\t\t      vb.vb2_buf);\n\tunsigned long size;\n\n\tsize = ctx->v_fmt.fmt.pix.sizeimage;\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tctx_err(ctx,\n\t\t\t\"data will not fit into plane (%lu < %lu)\\n\",\n\t\t\tvb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);\n\treturn 0;\n}\n\nstatic void cal_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct cal_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct cal_buffer *buf = container_of(vb, struct cal_buffer,\n\t\t\t\t\t      vb.vb2_buf);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ctx->dma.lock, flags);\n\tlist_add_tail(&buf->list, &ctx->dma.queue);\n\tspin_unlock_irqrestore(&ctx->dma.lock, flags);\n}\n\nstatic void cal_release_buffers(struct cal_ctx *ctx,\n\t\t\t\tenum vb2_buffer_state state)\n{\n\tstruct cal_buffer *buf, *tmp;\n\n\t \n\tspin_lock_irq(&ctx->dma.lock);\n\n\tlist_for_each_entry_safe(buf, tmp, &ctx->dma.queue, list) {\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t}\n\n\tif (ctx->dma.pending) {\n\t\tvb2_buffer_done(&ctx->dma.pending->vb.vb2_buf, state);\n\t\tctx->dma.pending = NULL;\n\t}\n\n\tif (ctx->dma.active) {\n\t\tvb2_buffer_done(&ctx->dma.active->vb.vb2_buf, state);\n\t\tctx->dma.active = NULL;\n\t}\n\n\tspin_unlock_irq(&ctx->dma.lock);\n}\n\n \n\nstatic int cal_video_check_format(struct cal_ctx *ctx)\n{\n\tconst struct v4l2_mbus_framefmt *format;\n\tstruct v4l2_subdev_state *state;\n\tstruct media_pad *remote_pad;\n\tint ret = 0;\n\n\tremote_pad = media_pad_remote_pad_first(&ctx->pad);\n\tif (!remote_pad)\n\t\treturn -ENODEV;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(&ctx->phy->subdev);\n\n\tformat = v4l2_subdev_get_pad_format(&ctx->phy->subdev, state, remote_pad->index);\n\tif (!format) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ctx->fmtinfo->code != format->code ||\n\t    ctx->v_fmt.fmt.pix.height != format->height ||\n\t    ctx->v_fmt.fmt.pix.width != format->width ||\n\t    ctx->v_fmt.fmt.pix.field != format->field) {\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\nout:\n\tv4l2_subdev_unlock_state(state);\n\n\treturn ret;\n}\n\nstatic int cal_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct cal_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct cal_buffer *buf;\n\tdma_addr_t addr;\n\tint ret;\n\n\tret = video_device_pipeline_alloc_start(&ctx->vdev);\n\tif (ret < 0) {\n\t\tctx_err(ctx, \"Failed to start media pipeline: %d\\n\", ret);\n\t\tgoto error_release_buffers;\n\t}\n\n\t \n\tret = cal_video_check_format(ctx);\n\tif (ret < 0) {\n\t\tctx_dbg(3, ctx,\n\t\t\t\"Format mismatch between CAMERARX and video node\\n\");\n\t\tgoto error_pipeline;\n\t}\n\n\tret = cal_ctx_prepare(ctx);\n\tif (ret) {\n\t\tctx_err(ctx, \"Failed to prepare context: %d\\n\", ret);\n\t\tgoto error_pipeline;\n\t}\n\n\tspin_lock_irq(&ctx->dma.lock);\n\tbuf = list_first_entry(&ctx->dma.queue, struct cal_buffer, list);\n\tctx->dma.active = buf;\n\tlist_del(&buf->list);\n\tspin_unlock_irq(&ctx->dma.lock);\n\n\taddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);\n\n\tret = pm_runtime_resume_and_get(ctx->cal->dev);\n\tif (ret < 0)\n\t\tgoto error_pipeline;\n\n\tcal_ctx_set_dma_addr(ctx, addr);\n\tcal_ctx_start(ctx);\n\n\tret = v4l2_subdev_call(&ctx->phy->subdev, video, s_stream, 1);\n\tif (ret)\n\t\tgoto error_stop;\n\n\tif (cal_debug >= 4)\n\t\tcal_quickdump_regs(ctx->cal);\n\n\treturn 0;\n\nerror_stop:\n\tcal_ctx_stop(ctx);\n\tpm_runtime_put_sync(ctx->cal->dev);\n\tcal_ctx_unprepare(ctx);\n\nerror_pipeline:\n\tvideo_device_pipeline_stop(&ctx->vdev);\nerror_release_buffers:\n\tcal_release_buffers(ctx, VB2_BUF_STATE_QUEUED);\n\n\treturn ret;\n}\n\nstatic void cal_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct cal_ctx *ctx = vb2_get_drv_priv(vq);\n\n\tcal_ctx_stop(ctx);\n\n\tv4l2_subdev_call(&ctx->phy->subdev, video, s_stream, 0);\n\n\tpm_runtime_put_sync(ctx->cal->dev);\n\n\tcal_ctx_unprepare(ctx);\n\n\tcal_release_buffers(ctx, VB2_BUF_STATE_ERROR);\n\n\tvideo_device_pipeline_stop(&ctx->vdev);\n}\n\nstatic const struct vb2_ops cal_video_qops = {\n\t.queue_setup\t\t= cal_queue_setup,\n\t.buf_prepare\t\t= cal_buffer_prepare,\n\t.buf_queue\t\t= cal_buffer_queue,\n\t.start_streaming\t= cal_start_streaming,\n\t.stop_streaming\t\t= cal_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \n\nstatic const struct v4l2_file_operations cal_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = v4l2_fh_open,\n\t.release        = vb2_fop_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,  \n\t.mmap           = vb2_fop_mmap,\n};\n\nstatic int cal_ctx_v4l2_init_formats(struct cal_ctx *ctx)\n{\n\tstruct v4l2_mbus_framefmt mbus_fmt;\n\tconst struct cal_format_info *fmtinfo;\n\tunsigned int i, j, k;\n\tint ret = 0;\n\n\t \n\tctx->active_fmt = devm_kcalloc(ctx->cal->dev, cal_num_formats,\n\t\t\t\t       sizeof(*ctx->active_fmt), GFP_KERNEL);\n\tif (!ctx->active_fmt)\n\t\treturn -ENOMEM;\n\n\tctx->num_active_fmt = 0;\n\n\tfor (j = 0, i = 0; ; ++j) {\n\t\tstruct v4l2_subdev_mbus_code_enum mbus_code = {\n\t\t\t.index = j,\n\t\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t};\n\n\t\tret = v4l2_subdev_call(ctx->phy->source, pad, enum_mbus_code,\n\t\t\t\t       NULL, &mbus_code);\n\t\tif (ret == -EINVAL)\n\t\t\tbreak;\n\n\t\tif (ret) {\n\t\t\tctx_err(ctx, \"Error enumerating mbus codes in subdev %s: %d\\n\",\n\t\t\t\tctx->phy->source->name, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tctx_dbg(2, ctx,\n\t\t\t\"subdev %s: code: %04x idx: %u\\n\",\n\t\t\tctx->phy->source->name, mbus_code.code, j);\n\n\t\tfor (k = 0; k < cal_num_formats; k++) {\n\t\t\tfmtinfo = &cal_formats[k];\n\n\t\t\tif (mbus_code.code == fmtinfo->code) {\n\t\t\t\tctx->active_fmt[i] = fmtinfo;\n\t\t\t\tctx_dbg(2, ctx,\n\t\t\t\t\t\"matched fourcc: %s: code: %04x idx: %u\\n\",\n\t\t\t\t\tfourcc_to_str(fmtinfo->fourcc),\n\t\t\t\t\tfmtinfo->code, i);\n\t\t\t\tctx->num_active_fmt = ++i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i == 0) {\n\t\tctx_err(ctx, \"No suitable format reported by subdev %s\\n\",\n\t\t\tctx->phy->source->name);\n\t\treturn -EINVAL;\n\t}\n\n\tret = __subdev_get_format(ctx, &mbus_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tfmtinfo = find_format_by_code(ctx, mbus_fmt.code);\n\tif (!fmtinfo) {\n\t\tctx_dbg(3, ctx, \"mbus code format (0x%08x) not found.\\n\",\n\t\t\tmbus_fmt.code);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tv4l2_fill_pix_format(&ctx->v_fmt.fmt.pix, &mbus_fmt);\n\tctx->v_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tctx->v_fmt.fmt.pix.pixelformat = fmtinfo->fourcc;\n\tcal_calc_format_size(ctx, fmtinfo, &ctx->v_fmt);\n\tctx->fmtinfo = fmtinfo;\n\n\treturn 0;\n}\n\nstatic int cal_ctx_v4l2_init_mc_format(struct cal_ctx *ctx)\n{\n\tconst struct cal_format_info *fmtinfo;\n\tstruct v4l2_pix_format *pix_fmt = &ctx->v_fmt.fmt.pix;\n\n\tfmtinfo = cal_format_by_code(MEDIA_BUS_FMT_UYVY8_1X16);\n\tif (!fmtinfo)\n\t\treturn -EINVAL;\n\n\tpix_fmt->width = 640;\n\tpix_fmt->height = 480;\n\tpix_fmt->field = V4L2_FIELD_NONE;\n\tpix_fmt->colorspace = V4L2_COLORSPACE_SRGB;\n\tpix_fmt->ycbcr_enc = V4L2_YCBCR_ENC_601;\n\tpix_fmt->quantization = V4L2_QUANTIZATION_LIM_RANGE;\n\tpix_fmt->xfer_func = V4L2_XFER_FUNC_SRGB;\n\tpix_fmt->pixelformat = fmtinfo->fourcc;\n\n\tctx->v_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n\t \n\tcal_calc_format_size(ctx, fmtinfo, &ctx->v_fmt);\n\tctx->fmtinfo = fmtinfo;\n\n\treturn 0;\n}\n\nint cal_ctx_v4l2_register(struct cal_ctx *ctx)\n{\n\tstruct video_device *vfd = &ctx->vdev;\n\tint ret;\n\n\tif (!cal_mc_api) {\n\t\tstruct v4l2_ctrl_handler *hdl = &ctx->ctrl_handler;\n\n\t\tret = cal_ctx_v4l2_init_formats(ctx);\n\t\tif (ret) {\n\t\t\tctx_err(ctx, \"Failed to init formats: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = v4l2_ctrl_add_handler(hdl, ctx->phy->source->ctrl_handler,\n\t\t\t\t\t    NULL, true);\n\t\tif (ret < 0) {\n\t\t\tctx_err(ctx, \"Failed to add source ctrl handler\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = cal_ctx_v4l2_init_mc_format(ctx);\n\t\tif (ret) {\n\t\t\tctx_err(ctx, \"Failed to init format: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, cal_video_nr);\n\tif (ret < 0) {\n\t\tctx_err(ctx, \"Failed to register video device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = media_create_pad_link(&ctx->phy->subdev.entity,\n\t\t\t\t    CAL_CAMERARX_PAD_FIRST_SOURCE,\n\t\t\t\t    &vfd->entity, 0,\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\tif (ret) {\n\t\tctx_err(ctx, \"Failed to create media link for context %u\\n\",\n\t\t\tctx->dma_ctx);\n\t\tvideo_unregister_device(vfd);\n\t\treturn ret;\n\t}\n\n\tctx_info(ctx, \"V4L2 device registered as %s\\n\",\n\t\t video_device_node_name(vfd));\n\n\treturn 0;\n}\n\nvoid cal_ctx_v4l2_unregister(struct cal_ctx *ctx)\n{\n\tctx_dbg(1, ctx, \"unregistering %s\\n\",\n\t\tvideo_device_node_name(&ctx->vdev));\n\n\tvideo_unregister_device(&ctx->vdev);\n}\n\nint cal_ctx_v4l2_init(struct cal_ctx *ctx)\n{\n\tstruct video_device *vfd = &ctx->vdev;\n\tstruct vb2_queue *q = &ctx->vb_vidq;\n\tint ret;\n\n\tINIT_LIST_HEAD(&ctx->dma.queue);\n\tspin_lock_init(&ctx->dma.lock);\n\tmutex_init(&ctx->mutex);\n\tinit_waitqueue_head(&ctx->dma.wait);\n\n\t \n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tq->drv_priv = ctx;\n\tq->buf_struct_size = sizeof(struct cal_buffer);\n\tq->ops = &cal_video_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &ctx->mutex;\n\tq->min_buffers_needed = 3;\n\tq->dev = ctx->cal->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvfd->fops = &cal_fops;\n\tvfd->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING\n\t\t\t | (cal_mc_api ? V4L2_CAP_IO_MC : 0);\n\tvfd->v4l2_dev = &ctx->cal->v4l2_dev;\n\tvfd->queue = q;\n\tsnprintf(vfd->name, sizeof(vfd->name), \"CAL output %u\", ctx->dma_ctx);\n\tvfd->release = video_device_release_empty;\n\tvfd->ioctl_ops = cal_mc_api ? &cal_ioctl_mc_ops : &cal_ioctl_legacy_ops;\n\tvfd->lock = &ctx->mutex;\n\tvideo_set_drvdata(vfd, ctx);\n\n\tctx->pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&vfd->entity, 1, &ctx->pad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!cal_mc_api) {\n\t\t \n\t\tstruct v4l2_ctrl_handler *hdl = &ctx->ctrl_handler;\n\n\t\tret = v4l2_ctrl_handler_init(hdl, 11);\n\t\tif (ret < 0) {\n\t\t\tctx_err(ctx, \"Failed to init ctrl handler\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tvfd->ctrl_handler = hdl;\n\t}\n\n\treturn 0;\n\nerror:\n\tmedia_entity_cleanup(&vfd->entity);\n\treturn ret;\n}\n\nvoid cal_ctx_v4l2_cleanup(struct cal_ctx *ctx)\n{\n\tif (!cal_mc_api)\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\n\tmedia_entity_cleanup(&ctx->vdev.entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}