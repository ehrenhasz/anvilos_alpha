{
  "module_name": "cal-camerarx.c",
  "hash_id": "10d5407de6691b39e390374e8186a4c62a895ef39c7b6e051b1a4a38db4dde66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/cal/cal-camerarx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#include \"cal.h\"\n#include \"cal_regs.h\"\n\n \n\nstatic inline u32 camerarx_read(struct cal_camerarx *phy, u32 offset)\n{\n\treturn ioread32(phy->base + offset);\n}\n\nstatic inline void camerarx_write(struct cal_camerarx *phy, u32 offset, u32 val)\n{\n\tiowrite32(val, phy->base + offset);\n}\n\n \n\nstatic s64 cal_camerarx_get_ext_link_freq(struct cal_camerarx *phy)\n{\n\tstruct v4l2_mbus_config_mipi_csi2 *mipi_csi2 = &phy->endpoint.bus.mipi_csi2;\n\tu32 num_lanes = mipi_csi2->num_data_lanes;\n\tconst struct cal_format_info *fmtinfo;\n\tstruct v4l2_subdev_state *state;\n\tstruct v4l2_mbus_framefmt *fmt;\n\tu32 bpp;\n\ts64 freq;\n\n\tstate = v4l2_subdev_get_locked_active_state(&phy->subdev);\n\n\tfmt = v4l2_subdev_get_pad_format(&phy->subdev, state, CAL_CAMERARX_PAD_SINK);\n\n\tfmtinfo = cal_format_by_code(fmt->code);\n\tif (!fmtinfo)\n\t\treturn -EINVAL;\n\n\tbpp = fmtinfo->bpp;\n\n\tfreq = v4l2_get_link_freq(phy->source->ctrl_handler, bpp, 2 * num_lanes);\n\tif (freq < 0) {\n\t\tphy_err(phy, \"failed to get link freq for subdev '%s'\\n\",\n\t\t\tphy->source->name);\n\t\treturn freq;\n\t}\n\n\tphy_dbg(3, phy, \"Source Link Freq: %llu\\n\", freq);\n\n\treturn freq;\n}\n\nstatic void cal_camerarx_lane_config(struct cal_camerarx *phy)\n{\n\tu32 val = cal_read(phy->cal, CAL_CSI2_COMPLEXIO_CFG(phy->instance));\n\tu32 lane_mask = CAL_CSI2_COMPLEXIO_CFG_CLOCK_POSITION_MASK;\n\tu32 polarity_mask = CAL_CSI2_COMPLEXIO_CFG_CLOCK_POL_MASK;\n\tstruct v4l2_mbus_config_mipi_csi2 *mipi_csi2 =\n\t\t&phy->endpoint.bus.mipi_csi2;\n\tint lane;\n\n\tcal_set_field(&val, mipi_csi2->clock_lane + 1, lane_mask);\n\tcal_set_field(&val, mipi_csi2->lane_polarities[0], polarity_mask);\n\tfor (lane = 0; lane < mipi_csi2->num_data_lanes; lane++) {\n\t\t \n\t\tlane_mask <<= 4;\n\t\tpolarity_mask <<= 4;\n\t\tcal_set_field(&val, mipi_csi2->data_lanes[lane] + 1, lane_mask);\n\t\tcal_set_field(&val, mipi_csi2->lane_polarities[lane + 1],\n\t\t\t      polarity_mask);\n\t}\n\n\tcal_write(phy->cal, CAL_CSI2_COMPLEXIO_CFG(phy->instance), val);\n\tphy_dbg(3, phy, \"CAL_CSI2_COMPLEXIO_CFG(%d) = 0x%08x\\n\",\n\t\tphy->instance, val);\n}\n\nstatic void cal_camerarx_enable(struct cal_camerarx *phy)\n{\n\tu32 num_lanes = phy->cal->data->camerarx[phy->instance].num_lanes;\n\n\tregmap_field_write(phy->fields[F_CAMMODE], 0);\n\t \n\tregmap_field_write(phy->fields[F_LANEENABLE], (1 << num_lanes) - 1);\n\t \n\tif (phy->fields[F_CSI_MODE])\n\t\tregmap_field_write(phy->fields[F_CSI_MODE], 1);\n\tregmap_field_write(phy->fields[F_CTRLCLKEN], 1);\n}\n\nvoid cal_camerarx_disable(struct cal_camerarx *phy)\n{\n\tregmap_field_write(phy->fields[F_CTRLCLKEN], 0);\n}\n\n \n#define TCLK_TERM\t0\n#define TCLK_MISS\t1\n#define TCLK_SETTLE\t14\n\nstatic void cal_camerarx_config(struct cal_camerarx *phy, s64 link_freq)\n{\n\tunsigned int reg0, reg1;\n\tunsigned int ths_term, ths_settle;\n\n\t \n\n\t \n\tths_term = div_s64(20 * link_freq, 1000 * 1000 * 1000);\n\tphy_dbg(1, phy, \"ths_term: %d (0x%02x)\\n\", ths_term, ths_term);\n\n\t \n\tths_settle = div_s64(105 * link_freq, 1000 * 1000 * 1000) + 4;\n\tphy_dbg(1, phy, \"ths_settle: %d (0x%02x)\\n\", ths_settle, ths_settle);\n\n\treg0 = camerarx_read(phy, CAL_CSI2_PHY_REG0);\n\tcal_set_field(&reg0, CAL_CSI2_PHY_REG0_HSCLOCKCONFIG_DISABLE,\n\t\t      CAL_CSI2_PHY_REG0_HSCLOCKCONFIG_MASK);\n\tcal_set_field(&reg0, ths_term, CAL_CSI2_PHY_REG0_THS_TERM_MASK);\n\tcal_set_field(&reg0, ths_settle, CAL_CSI2_PHY_REG0_THS_SETTLE_MASK);\n\n\tphy_dbg(1, phy, \"CSI2_%d_REG0 = 0x%08x\\n\", phy->instance, reg0);\n\tcamerarx_write(phy, CAL_CSI2_PHY_REG0, reg0);\n\n\treg1 = camerarx_read(phy, CAL_CSI2_PHY_REG1);\n\tcal_set_field(&reg1, TCLK_TERM, CAL_CSI2_PHY_REG1_TCLK_TERM_MASK);\n\tcal_set_field(&reg1, 0xb8, CAL_CSI2_PHY_REG1_DPHY_HS_SYNC_PATTERN_MASK);\n\tcal_set_field(&reg1, TCLK_MISS,\n\t\t      CAL_CSI2_PHY_REG1_CTRLCLK_DIV_FACTOR_MASK);\n\tcal_set_field(&reg1, TCLK_SETTLE, CAL_CSI2_PHY_REG1_TCLK_SETTLE_MASK);\n\n\tphy_dbg(1, phy, \"CSI2_%d_REG1 = 0x%08x\\n\", phy->instance, reg1);\n\tcamerarx_write(phy, CAL_CSI2_PHY_REG1, reg1);\n}\n\nstatic void cal_camerarx_power(struct cal_camerarx *phy, bool enable)\n{\n\tu32 target_state;\n\tunsigned int i;\n\n\ttarget_state = enable ? CAL_CSI2_COMPLEXIO_CFG_PWR_CMD_STATE_ON :\n\t\t       CAL_CSI2_COMPLEXIO_CFG_PWR_CMD_STATE_OFF;\n\n\tcal_write_field(phy->cal, CAL_CSI2_COMPLEXIO_CFG(phy->instance),\n\t\t\ttarget_state, CAL_CSI2_COMPLEXIO_CFG_PWR_CMD_MASK);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tu32 current_state;\n\n\t\tcurrent_state = cal_read_field(phy->cal,\n\t\t\t\t\t       CAL_CSI2_COMPLEXIO_CFG(phy->instance),\n\t\t\t\t\t       CAL_CSI2_COMPLEXIO_CFG_PWR_STATUS_MASK);\n\n\t\tif (current_state == target_state)\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 1100);\n\t}\n\n\tif (i == 10)\n\t\tphy_err(phy, \"Failed to power %s complexio\\n\",\n\t\t\tenable ? \"up\" : \"down\");\n}\n\nstatic void cal_camerarx_wait_reset(struct cal_camerarx *phy)\n{\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(750);\n\twhile (time_before(jiffies, timeout)) {\n\t\tif (cal_read_field(phy->cal,\n\t\t\t\t   CAL_CSI2_COMPLEXIO_CFG(phy->instance),\n\t\t\t\t   CAL_CSI2_COMPLEXIO_CFG_RESET_DONE_MASK) ==\n\t\t    CAL_CSI2_COMPLEXIO_CFG_RESET_DONE_RESETCOMPLETED)\n\t\t\tbreak;\n\t\tusleep_range(500, 5000);\n\t}\n\n\tif (cal_read_field(phy->cal, CAL_CSI2_COMPLEXIO_CFG(phy->instance),\n\t\t\t   CAL_CSI2_COMPLEXIO_CFG_RESET_DONE_MASK) !=\n\t\t\t   CAL_CSI2_COMPLEXIO_CFG_RESET_DONE_RESETCOMPLETED)\n\t\tphy_err(phy, \"Timeout waiting for Complex IO reset done\\n\");\n}\n\nstatic void cal_camerarx_wait_stop_state(struct cal_camerarx *phy)\n{\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(750);\n\twhile (time_before(jiffies, timeout)) {\n\t\tif (cal_read_field(phy->cal,\n\t\t\t\t   CAL_CSI2_TIMING(phy->instance),\n\t\t\t\t   CAL_CSI2_TIMING_FORCE_RX_MODE_IO1_MASK) == 0)\n\t\t\tbreak;\n\t\tusleep_range(500, 5000);\n\t}\n\n\tif (cal_read_field(phy->cal, CAL_CSI2_TIMING(phy->instance),\n\t\t\t   CAL_CSI2_TIMING_FORCE_RX_MODE_IO1_MASK) != 0)\n\t\tphy_err(phy, \"Timeout waiting for stop state\\n\");\n}\n\nstatic void cal_camerarx_enable_irqs(struct cal_camerarx *phy)\n{\n\tconst u32 cio_err_mask =\n\t\tCAL_CSI2_COMPLEXIO_IRQ_LANE_ERRORS_MASK |\n\t\tCAL_CSI2_COMPLEXIO_IRQ_FIFO_OVR_MASK |\n\t\tCAL_CSI2_COMPLEXIO_IRQ_SHORT_PACKET_MASK |\n\t\tCAL_CSI2_COMPLEXIO_IRQ_ECC_NO_CORRECTION_MASK;\n\tconst u32 vc_err_mask =\n\t\tCAL_CSI2_VC_IRQ_CS_IRQ_MASK(0) |\n\t\tCAL_CSI2_VC_IRQ_CS_IRQ_MASK(1) |\n\t\tCAL_CSI2_VC_IRQ_CS_IRQ_MASK(2) |\n\t\tCAL_CSI2_VC_IRQ_CS_IRQ_MASK(3) |\n\t\tCAL_CSI2_VC_IRQ_ECC_CORRECTION_IRQ_MASK(0) |\n\t\tCAL_CSI2_VC_IRQ_ECC_CORRECTION_IRQ_MASK(1) |\n\t\tCAL_CSI2_VC_IRQ_ECC_CORRECTION_IRQ_MASK(2) |\n\t\tCAL_CSI2_VC_IRQ_ECC_CORRECTION_IRQ_MASK(3);\n\n\t \n\tcal_write(phy->cal, CAL_HL_IRQENABLE_SET(0),\n\t\t  CAL_HL_IRQ_CIO_MASK(phy->instance) |\n\t\t  CAL_HL_IRQ_VC_MASK(phy->instance));\n\tcal_write(phy->cal, CAL_CSI2_COMPLEXIO_IRQENABLE(phy->instance),\n\t\t  cio_err_mask);\n\tcal_write(phy->cal, CAL_CSI2_VC_IRQENABLE(phy->instance),\n\t\t  vc_err_mask);\n}\n\nstatic void cal_camerarx_disable_irqs(struct cal_camerarx *phy)\n{\n\t \n\tcal_write(phy->cal, CAL_HL_IRQENABLE_CLR(0),\n\t\t  CAL_HL_IRQ_CIO_MASK(phy->instance) |\n\t\t  CAL_HL_IRQ_VC_MASK(phy->instance));\n\tcal_write(phy->cal, CAL_CSI2_COMPLEXIO_IRQENABLE(phy->instance), 0);\n\tcal_write(phy->cal, CAL_CSI2_VC_IRQENABLE(phy->instance), 0);\n}\n\nstatic void cal_camerarx_ppi_enable(struct cal_camerarx *phy)\n{\n\tcal_write_field(phy->cal, CAL_CSI2_PPI_CTRL(phy->instance),\n\t\t\t1, CAL_CSI2_PPI_CTRL_ECC_EN_MASK);\n\n\tcal_write_field(phy->cal, CAL_CSI2_PPI_CTRL(phy->instance),\n\t\t\t1, CAL_CSI2_PPI_CTRL_IF_EN_MASK);\n}\n\nstatic void cal_camerarx_ppi_disable(struct cal_camerarx *phy)\n{\n\tcal_write_field(phy->cal, CAL_CSI2_PPI_CTRL(phy->instance),\n\t\t\t0, CAL_CSI2_PPI_CTRL_IF_EN_MASK);\n}\n\nstatic int cal_camerarx_start(struct cal_camerarx *phy)\n{\n\ts64 link_freq;\n\tu32 sscounter;\n\tu32 val;\n\tint ret;\n\n\tif (phy->enable_count > 0) {\n\t\tphy->enable_count++;\n\t\treturn 0;\n\t}\n\n\tlink_freq = cal_camerarx_get_ext_link_freq(phy);\n\tif (link_freq < 0)\n\t\treturn link_freq;\n\n\tret = v4l2_subdev_call(phy->source, core, s_power, 1);\n\tif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV) {\n\t\tphy_err(phy, \"power on failed in subdev\\n\");\n\t\treturn ret;\n\t}\n\n\tcal_camerarx_enable_irqs(phy);\n\n\t \n\n\t \n\tcal_camerarx_lane_config(phy);\n\n\t \n\tcal_camerarx_enable(phy);\n\n\t \n\tcal_write_field(phy->cal, CAL_CSI2_COMPLEXIO_CFG(phy->instance),\n\t\t\tCAL_CSI2_COMPLEXIO_CFG_RESET_CTRL_OPERATIONAL,\n\t\t\tCAL_CSI2_COMPLEXIO_CFG_RESET_CTRL_MASK);\n\tphy_dbg(3, phy, \"CAL_CSI2_COMPLEXIO_CFG(%d) = 0x%08x De-assert Complex IO Reset\\n\",\n\t\tphy->instance,\n\t\tcal_read(phy->cal, CAL_CSI2_COMPLEXIO_CFG(phy->instance)));\n\n\t \n\tcamerarx_read(phy, CAL_CSI2_PHY_REG0);\n\n\t \n\tcal_camerarx_config(phy, link_freq);\n\n\t \n\tsscounter = DIV_ROUND_UP(clk_get_rate(phy->cal->fclk), 10000 *  16 * 4);\n\n\tval = cal_read(phy->cal, CAL_CSI2_TIMING(phy->instance));\n\tcal_set_field(&val, 1, CAL_CSI2_TIMING_STOP_STATE_X16_IO1_MASK);\n\tcal_set_field(&val, 1, CAL_CSI2_TIMING_STOP_STATE_X4_IO1_MASK);\n\tcal_set_field(&val, sscounter,\n\t\t      CAL_CSI2_TIMING_STOP_STATE_COUNTER_IO1_MASK);\n\tcal_write(phy->cal, CAL_CSI2_TIMING(phy->instance), val);\n\tphy_dbg(3, phy, \"CAL_CSI2_TIMING(%d) = 0x%08x Stop States\\n\",\n\t\tphy->instance,\n\t\tcal_read(phy->cal, CAL_CSI2_TIMING(phy->instance)));\n\n\t \n\tcal_write_field(phy->cal, CAL_CSI2_TIMING(phy->instance),\n\t\t\t1, CAL_CSI2_TIMING_FORCE_RX_MODE_IO1_MASK);\n\tphy_dbg(3, phy, \"CAL_CSI2_TIMING(%d) = 0x%08x Force RXMODE\\n\",\n\t\tphy->instance,\n\t\tcal_read(phy->cal, CAL_CSI2_TIMING(phy->instance)));\n\n\t \n\n\t \n\tcal_camerarx_power(phy, true);\n\n\t \n\tret = v4l2_subdev_call(phy->source, video, s_stream, 1);\n\tif (ret) {\n\t\tv4l2_subdev_call(phy->source, core, s_power, 0);\n\t\tcal_camerarx_disable_irqs(phy);\n\t\tphy_err(phy, \"stream on failed in subdev\\n\");\n\t\treturn ret;\n\t}\n\n\tcal_camerarx_wait_reset(phy);\n\n\t \n\tcal_camerarx_wait_stop_state(phy);\n\n\tphy_dbg(1, phy, \"CSI2_%u_REG1 = 0x%08x (bits 31-28 should be set)\\n\",\n\t\tphy->instance, camerarx_read(phy, CAL_CSI2_PHY_REG1));\n\n\t \n\n\t \n\tcal_camerarx_ppi_enable(phy);\n\n\tphy->enable_count++;\n\n\treturn 0;\n}\n\nstatic void cal_camerarx_stop(struct cal_camerarx *phy)\n{\n\tint ret;\n\n\tif (--phy->enable_count > 0)\n\t\treturn;\n\n\tcal_camerarx_ppi_disable(phy);\n\n\tcal_camerarx_disable_irqs(phy);\n\n\tcal_camerarx_power(phy, false);\n\n\t \n\tcal_write_field(phy->cal, CAL_CSI2_COMPLEXIO_CFG(phy->instance),\n\t\t\tCAL_CSI2_COMPLEXIO_CFG_RESET_CTRL,\n\t\t\tCAL_CSI2_COMPLEXIO_CFG_RESET_CTRL_MASK);\n\n\tphy_dbg(3, phy, \"CAL_CSI2_COMPLEXIO_CFG(%d) = 0x%08x Complex IO in Reset\\n\",\n\t\tphy->instance,\n\t\tcal_read(phy->cal, CAL_CSI2_COMPLEXIO_CFG(phy->instance)));\n\n\t \n\tcal_camerarx_disable(phy);\n\n\tif (v4l2_subdev_call(phy->source, video, s_stream, 0))\n\t\tphy_err(phy, \"stream off failed in subdev\\n\");\n\n\tret = v4l2_subdev_call(phy->source, core, s_power, 0);\n\tif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)\n\t\tphy_err(phy, \"power off failed in subdev\\n\");\n}\n\n \nvoid cal_camerarx_i913_errata(struct cal_camerarx *phy)\n{\n\tu32 reg10 = camerarx_read(phy, CAL_CSI2_PHY_REG10);\n\n\tcal_set_field(&reg10, 1, CAL_CSI2_PHY_REG10_I933_LDO_DISABLE_MASK);\n\n\tphy_dbg(1, phy, \"CSI2_%d_REG10 = 0x%08x\\n\", phy->instance, reg10);\n\tcamerarx_write(phy, CAL_CSI2_PHY_REG10, reg10);\n}\n\nstatic int cal_camerarx_regmap_init(struct cal_dev *cal,\n\t\t\t\t    struct cal_camerarx *phy)\n{\n\tconst struct cal_camerarx_data *phy_data;\n\tunsigned int i;\n\n\tif (!cal->data)\n\t\treturn -EINVAL;\n\n\tphy_data = &cal->data->camerarx[phy->instance];\n\n\tfor (i = 0; i < F_MAX_FIELDS; i++) {\n\t\tstruct reg_field field = {\n\t\t\t.reg = cal->syscon_camerrx_offset,\n\t\t\t.lsb = phy_data->fields[i].lsb,\n\t\t\t.msb = phy_data->fields[i].msb,\n\t\t};\n\n\t\t \n\t\tphy->fields[i] = devm_regmap_field_alloc(cal->dev,\n\t\t\t\t\t\t\t cal->syscon_camerrx,\n\t\t\t\t\t\t\t field);\n\t\tif (IS_ERR(phy->fields[i])) {\n\t\t\tcal_err(cal, \"Unable to allocate regmap fields\\n\");\n\t\t\treturn PTR_ERR(phy->fields[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cal_camerarx_parse_dt(struct cal_camerarx *phy)\n{\n\tstruct v4l2_fwnode_endpoint *endpoint = &phy->endpoint;\n\tchar data_lanes[V4L2_MBUS_CSI2_MAX_DATA_LANES * 2];\n\tstruct device_node *ep_node;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tep_node = of_graph_get_endpoint_by_regs(phy->cal->dev->of_node,\n\t\t\t\t\t\tphy->instance, 0);\n\tif (!ep_node) {\n\t\t \n\t\tphy_dbg(3, phy, \"Port has no endpoint\\n\");\n\t\treturn 0;\n\t}\n\n\tendpoint->bus_type = V4L2_MBUS_CSI2_DPHY;\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep_node), endpoint);\n\tif (ret < 0) {\n\t\tphy_err(phy, \"Failed to parse endpoint\\n\");\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < endpoint->bus.mipi_csi2.num_data_lanes; i++) {\n\t\tunsigned int lane = endpoint->bus.mipi_csi2.data_lanes[i];\n\n\t\tif (lane > 4) {\n\t\t\tphy_err(phy, \"Invalid position %u for data lane %u\\n\",\n\t\t\t\tlane, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tdata_lanes[i*2] = '0' + lane;\n\t\tdata_lanes[i*2+1] = ' ';\n\t}\n\n\tdata_lanes[i*2-1] = '\\0';\n\n\tphy_dbg(3, phy,\n\t\t\"CSI-2 bus: clock lane <%u>, data lanes <%s>, flags 0x%08x\\n\",\n\t\tendpoint->bus.mipi_csi2.clock_lane, data_lanes,\n\t\tendpoint->bus.mipi_csi2.flags);\n\n\t \n\tphy->source_ep_node = of_graph_get_remote_endpoint(ep_node);\n\tphy->source_node = of_graph_get_port_parent(phy->source_ep_node);\n\tif (!phy->source_node) {\n\t\tphy_dbg(3, phy, \"Can't get remote parent\\n\");\n\t\tof_node_put(phy->source_ep_node);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tphy_dbg(1, phy, \"Found connected device %pOFn\\n\", phy->source_node);\n\ndone:\n\tof_node_put(ep_node);\n\treturn ret;\n}\n\n \n\nstatic inline struct cal_camerarx *to_cal_camerarx(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct cal_camerarx, subdev);\n}\n\nstatic int cal_camerarx_sd_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct cal_camerarx *phy = to_cal_camerarx(sd);\n\tstruct v4l2_subdev_state *state;\n\tint ret = 0;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tif (enable)\n\t\tret = cal_camerarx_start(phy);\n\telse\n\t\tcal_camerarx_stop(phy);\n\n\tv4l2_subdev_unlock_state(state);\n\n\treturn ret;\n}\n\nstatic int cal_camerarx_sd_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t\t  struct v4l2_subdev_state *state,\n\t\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct cal_camerarx *phy = to_cal_camerarx(sd);\n\n\t \n\tif (cal_rx_pad_is_source(code->pad)) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tif (code->index > 0)\n\t\t\treturn -EINVAL;\n\n\t\tfmt = v4l2_subdev_get_pad_format(&phy->subdev, state,\n\t\t\t\t\t\t CAL_CAMERARX_PAD_SINK);\n\t\tcode->code = fmt->code;\n\t} else {\n\t\tif (code->index >= cal_num_formats)\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = cal_formats[code->index].code;\n\t}\n\n\treturn 0;\n}\n\nstatic int cal_camerarx_sd_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t\t   struct v4l2_subdev_state *state,\n\t\t\t\t\t   struct v4l2_subdev_frame_size_enum *fse)\n{\n\tconst struct cal_format_info *fmtinfo;\n\n\tif (fse->index > 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (cal_rx_pad_is_source(fse->pad)) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tfmt = v4l2_subdev_get_pad_format(sd, state,\n\t\t\t\t\t\t CAL_CAMERARX_PAD_SINK);\n\t\tif (fse->code != fmt->code)\n\t\t\treturn -EINVAL;\n\n\t\tfse->min_width = fmt->width;\n\t\tfse->max_width = fmt->width;\n\t\tfse->min_height = fmt->height;\n\t\tfse->max_height = fmt->height;\n\t} else {\n\t\tfmtinfo = cal_format_by_code(fse->code);\n\t\tif (!fmtinfo)\n\t\t\treturn -EINVAL;\n\n\t\tfse->min_width = CAL_MIN_WIDTH_BYTES * 8 / ALIGN(fmtinfo->bpp, 8);\n\t\tfse->max_width = CAL_MAX_WIDTH_BYTES * 8 / ALIGN(fmtinfo->bpp, 8);\n\t\tfse->min_height = CAL_MIN_HEIGHT_LINES;\n\t\tfse->max_height = CAL_MAX_HEIGHT_LINES;\n\t}\n\n\treturn 0;\n}\n\nstatic int cal_camerarx_sd_set_fmt(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *state,\n\t\t\t\t   struct v4l2_subdev_format *format)\n{\n\tconst struct cal_format_info *fmtinfo;\n\tstruct v4l2_mbus_framefmt *fmt;\n\tunsigned int bpp;\n\n\t \n\tif (cal_rx_pad_is_source(format->pad))\n\t\treturn v4l2_subdev_get_fmt(sd, state, format);\n\n\t \n\tfmtinfo = cal_format_by_code(format->format.code);\n\tif (!fmtinfo)\n\t\tfmtinfo = &cal_formats[0];\n\n\t \n\tbpp = ALIGN(fmtinfo->bpp, 8);\n\n\tformat->format.width = clamp_t(unsigned int, format->format.width,\n\t\t\t\t       CAL_MIN_WIDTH_BYTES * 8 / bpp,\n\t\t\t\t       CAL_MAX_WIDTH_BYTES * 8 / bpp);\n\tformat->format.height = clamp_t(unsigned int, format->format.height,\n\t\t\t\t\tCAL_MIN_HEIGHT_LINES,\n\t\t\t\t\tCAL_MAX_HEIGHT_LINES);\n\tformat->format.code = fmtinfo->code;\n\tformat->format.field = V4L2_FIELD_NONE;\n\n\t \n\n\tfmt = v4l2_subdev_get_pad_format(sd, state, CAL_CAMERARX_PAD_SINK);\n\t*fmt = format->format;\n\n\tfmt = v4l2_subdev_get_pad_format(sd, state,\n\t\t\t\t\t CAL_CAMERARX_PAD_FIRST_SOURCE);\n\t*fmt = format->format;\n\n\treturn 0;\n}\n\nstatic int cal_camerarx_sd_init_cfg(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *state)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.which = state ? V4L2_SUBDEV_FORMAT_TRY\n\t\t: V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.pad = CAL_CAMERARX_PAD_SINK,\n\t\t.format = {\n\t\t\t.width = 640,\n\t\t\t.height = 480,\n\t\t\t.code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t\t.field = V4L2_FIELD_NONE,\n\t\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t\t.ycbcr_enc = V4L2_YCBCR_ENC_601,\n\t\t\t.quantization = V4L2_QUANTIZATION_LIM_RANGE,\n\t\t\t.xfer_func = V4L2_XFER_FUNC_SRGB,\n\t\t},\n\t};\n\n\treturn cal_camerarx_sd_set_fmt(sd, state, &format);\n}\n\nstatic int cal_camerarx_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t\t       struct v4l2_mbus_frame_desc *fd)\n{\n\tstruct cal_camerarx *phy = to_cal_camerarx(sd);\n\tstruct v4l2_mbus_frame_desc remote_desc;\n\tconst struct media_pad *remote_pad;\n\tint ret;\n\n\tremote_pad = media_pad_remote_pad_first(&phy->pads[CAL_CAMERARX_PAD_SINK]);\n\tif (!remote_pad)\n\t\treturn -EPIPE;\n\n\tret = v4l2_subdev_call(phy->source, pad, get_frame_desc,\n\t\t\t       remote_pad->index, &remote_desc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (remote_desc.type != V4L2_MBUS_FRAME_DESC_TYPE_CSI2) {\n\t\tcal_err(phy->cal,\n\t\t\t\"Frame descriptor does not describe CSI-2 link\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (remote_desc.num_entries > 1)\n\t\tcal_err(phy->cal,\n\t\t\t\"Multiple streams not supported in remote frame descriptor, using the first one\\n\");\n\n\tfd->type = V4L2_MBUS_FRAME_DESC_TYPE_CSI2;\n\tfd->num_entries = 1;\n\tfd->entry[0] = remote_desc.entry[0];\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops cal_camerarx_video_ops = {\n\t.s_stream = cal_camerarx_sd_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops cal_camerarx_pad_ops = {\n\t.init_cfg = cal_camerarx_sd_init_cfg,\n\t.enum_mbus_code = cal_camerarx_sd_enum_mbus_code,\n\t.enum_frame_size = cal_camerarx_sd_enum_frame_size,\n\t.get_fmt = v4l2_subdev_get_fmt,\n\t.set_fmt = cal_camerarx_sd_set_fmt,\n\t.get_frame_desc = cal_camerarx_get_frame_desc,\n};\n\nstatic const struct v4l2_subdev_ops cal_camerarx_subdev_ops = {\n\t.video = &cal_camerarx_video_ops,\n\t.pad = &cal_camerarx_pad_ops,\n};\n\nstatic struct media_entity_operations cal_camerarx_media_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \n\nstruct cal_camerarx *cal_camerarx_create(struct cal_dev *cal,\n\t\t\t\t\t unsigned int instance)\n{\n\tstruct platform_device *pdev = to_platform_device(cal->dev);\n\tstruct cal_camerarx *phy;\n\tstruct v4l2_subdev *sd;\n\tunsigned int i;\n\tint ret;\n\n\tphy = devm_kzalloc(cal->dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tphy->cal = cal;\n\tphy->instance = instance;\n\n\tspin_lock_init(&phy->vc_lock);\n\n\tphy->res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t(instance == 0) ?\n\t\t\t\t\t\t\"cal_rx_core0\" :\n\t\t\t\t\t\t\"cal_rx_core1\");\n\tphy->base = devm_ioremap_resource(cal->dev, phy->res);\n\tif (IS_ERR(phy->base)) {\n\t\tcal_err(cal, \"failed to ioremap\\n\");\n\t\treturn ERR_CAST(phy->base);\n\t}\n\n\tcal_dbg(1, cal, \"ioresource %s at %pa - %pa\\n\",\n\t\tphy->res->name, &phy->res->start, &phy->res->end);\n\n\tret = cal_camerarx_regmap_init(cal, phy);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = cal_camerarx_parse_dt(phy);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tsd = &phy->subdev;\n\tv4l2_subdev_init(sd, &cal_camerarx_subdev_ops);\n\tsd->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tsd->flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsnprintf(sd->name, sizeof(sd->name), \"CAMERARX%u\", instance);\n\tsd->dev = cal->dev;\n\n\tphy->pads[CAL_CAMERARX_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tfor (i = CAL_CAMERARX_PAD_FIRST_SOURCE; i < CAL_CAMERARX_NUM_PADS; ++i)\n\t\tphy->pads[i].flags = MEDIA_PAD_FL_SOURCE;\n\tsd->entity.ops = &cal_camerarx_media_ops;\n\tret = media_entity_pads_init(&sd->entity, ARRAY_SIZE(phy->pads),\n\t\t\t\t     phy->pads);\n\tif (ret)\n\t\tgoto err_node_put;\n\n\tret = v4l2_subdev_init_finalize(sd);\n\tif (ret)\n\t\tgoto err_entity_cleanup;\n\n\tret = v4l2_device_register_subdev(&cal->v4l2_dev, sd);\n\tif (ret)\n\t\tgoto err_free_state;\n\n\treturn phy;\n\nerr_free_state:\n\tv4l2_subdev_cleanup(sd);\nerr_entity_cleanup:\n\tmedia_entity_cleanup(&phy->subdev.entity);\nerr_node_put:\n\tof_node_put(phy->source_ep_node);\n\tof_node_put(phy->source_node);\n\treturn ERR_PTR(ret);\n}\n\nvoid cal_camerarx_destroy(struct cal_camerarx *phy)\n{\n\tif (!phy)\n\t\treturn;\n\n\tv4l2_device_unregister_subdev(&phy->subdev);\n\tv4l2_subdev_cleanup(&phy->subdev);\n\tmedia_entity_cleanup(&phy->subdev.entity);\n\tof_node_put(phy->source_ep_node);\n\tof_node_put(phy->source_node);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}