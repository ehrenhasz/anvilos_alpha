{
  "module_name": "am437x-vpfe.c",
  "hash_id": "11832ea7a0adf5ecdef33455a31e10ed4592d2944da0e735a2f10662c878b346",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/am437x/am437x-vpfe.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-rect.h>\n\n#include \"am437x-vpfe.h\"\n\n#define VPFE_MODULE_NAME\t\"vpfe\"\n#define VPFE_VERSION\t\t\"0.1.0\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level 0-8\");\n\n#define vpfe_dbg(level, dev, fmt, arg...)\t\\\n\t\tv4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ##arg)\n#define vpfe_info(dev, fmt, arg...)\t\\\n\t\tv4l2_info(&dev->v4l2_dev, fmt, ##arg)\n#define vpfe_err(dev, fmt, arg...)\t\\\n\t\tv4l2_err(&dev->v4l2_dev, fmt, ##arg)\n\n \nstruct vpfe_standard {\n\tv4l2_std_id std_id;\n\tunsigned int width;\n\tunsigned int height;\n\tstruct v4l2_fract pixelaspect;\n\tint frame_format;\n};\n\nstatic const struct vpfe_standard vpfe_standards[] = {\n\t{V4L2_STD_525_60, 720, 480, {11, 10}, 1},\n\t{V4L2_STD_625_50, 720, 576, {54, 59}, 1},\n};\n\nstatic struct vpfe_fmt formats[VPFE_NUM_FORMATS] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.code\t\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.bitsperpixel\t= 16,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_UYVY,\n\t\t.code\t\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.bitsperpixel\t= 16,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YVYU,\n\t\t.code\t\t= MEDIA_BUS_FMT_YVYU8_2X8,\n\t\t.bitsperpixel\t= 16,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_VYUY,\n\t\t.code\t\t= MEDIA_BUS_FMT_VYUY8_2X8,\n\t\t.bitsperpixel\t= 16,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.code\t\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.bitsperpixel\t= 8,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG8,\n\t\t.code\t\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.bitsperpixel\t= 8,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.code\t\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.bitsperpixel\t= 8,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB8,\n\t\t.code\t\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.bitsperpixel\t= 8,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.code\t\t= MEDIA_BUS_FMT_RGB565_2X8_LE,\n\t\t.bitsperpixel\t= 16,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565X,\n\t\t.code\t\t= MEDIA_BUS_FMT_RGB565_2X8_BE,\n\t\t.bitsperpixel\t= 16,\n\t},\n};\n\nstatic int __subdev_get_format(struct vpfe_device *vpfe,\n\t\t\t       struct v4l2_mbus_framefmt *fmt);\nstatic int vpfe_calc_format_size(struct vpfe_device *vpfe,\n\t\t\t\t const struct vpfe_fmt *fmt,\n\t\t\t\t struct v4l2_format *f);\n\nstatic struct vpfe_fmt *find_format_by_code(struct vpfe_device *vpfe,\n\t\t\t\t\t    unsigned int code)\n{\n\tstruct vpfe_fmt *fmt;\n\tunsigned int k;\n\n\tfor (k = 0; k < vpfe->num_active_fmt; k++) {\n\t\tfmt = vpfe->active_fmt[k];\n\t\tif (fmt->code == code)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct vpfe_fmt *find_format_by_pix(struct vpfe_device *vpfe,\n\t\t\t\t\t   unsigned int pixelformat)\n{\n\tstruct vpfe_fmt *fmt;\n\tunsigned int k;\n\n\tfor (k = 0; k < vpfe->num_active_fmt; k++) {\n\t\tfmt = vpfe->active_fmt[k];\n\t\tif (fmt->fourcc == pixelformat)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nstatic unsigned int __get_bytesperpixel(struct vpfe_device *vpfe,\n\t\t\t\t\tconst struct vpfe_fmt *fmt)\n{\n\tstruct vpfe_subdev_info *sdinfo = vpfe->current_subdev;\n\tunsigned int bus_width = sdinfo->vpfe_param.bus_width;\n\tu32 bpp, bus_width_bytes, clocksperpixel;\n\n\tbus_width_bytes = ALIGN(bus_width, 8) >> 3;\n\tclocksperpixel = DIV_ROUND_UP(fmt->bitsperpixel, bus_width);\n\tbpp = clocksperpixel * bus_width_bytes;\n\n\treturn bpp;\n}\n\n \nstatic char *print_fourcc(u32 fmt)\n{\n\tstatic char code[5];\n\n\tcode[0] = (unsigned char)(fmt & 0xff);\n\tcode[1] = (unsigned char)((fmt >> 8) & 0xff);\n\tcode[2] = (unsigned char)((fmt >> 16) & 0xff);\n\tcode[3] = (unsigned char)((fmt >> 24) & 0xff);\n\tcode[4] = '\\0';\n\n\treturn code;\n}\n\nstatic inline u32 vpfe_reg_read(struct vpfe_ccdc *ccdc, u32 offset)\n{\n\treturn ioread32(ccdc->ccdc_cfg.base_addr + offset);\n}\n\nstatic inline void vpfe_reg_write(struct vpfe_ccdc *ccdc, u32 val, u32 offset)\n{\n\tiowrite32(val, ccdc->ccdc_cfg.base_addr + offset);\n}\n\nstatic inline struct vpfe_device *to_vpfe(struct vpfe_ccdc *ccdc)\n{\n\treturn container_of(ccdc, struct vpfe_device, ccdc);\n}\n\nstatic inline\nstruct vpfe_cap_buffer *to_vpfe_buffer(struct vb2_v4l2_buffer *vb)\n{\n\treturn container_of(vb, struct vpfe_cap_buffer, vb);\n}\n\nstatic inline void vpfe_pcr_enable(struct vpfe_ccdc *ccdc, int flag)\n{\n\tvpfe_reg_write(ccdc, !!flag, VPFE_PCR);\n}\n\nstatic void vpfe_config_enable(struct vpfe_ccdc *ccdc, int flag)\n{\n\tunsigned int cfg;\n\n\tif (!flag) {\n\t\tcfg = vpfe_reg_read(ccdc, VPFE_CONFIG);\n\t\tcfg &= ~(VPFE_CONFIG_EN_ENABLE << VPFE_CONFIG_EN_SHIFT);\n\t} else {\n\t\tcfg = VPFE_CONFIG_EN_ENABLE << VPFE_CONFIG_EN_SHIFT;\n\t}\n\n\tvpfe_reg_write(ccdc, cfg, VPFE_CONFIG);\n}\n\nstatic void vpfe_ccdc_setwin(struct vpfe_ccdc *ccdc,\n\t\t\t     struct v4l2_rect *image_win,\n\t\t\t     enum ccdc_frmfmt frm_fmt,\n\t\t\t     int bpp)\n{\n\tint horz_start, horz_nr_pixels;\n\tint vert_start, vert_nr_lines;\n\tint val, mid_img;\n\n\t \n\thorz_start = image_win->left * bpp;\n\thorz_nr_pixels = (image_win->width * bpp) - 1;\n\tvpfe_reg_write(ccdc, (horz_start << VPFE_HORZ_INFO_SPH_SHIFT) |\n\t\t\t\thorz_nr_pixels, VPFE_HORZ_INFO);\n\n\tvert_start = image_win->top;\n\n\tif (frm_fmt == CCDC_FRMFMT_INTERLACED) {\n\t\tvert_nr_lines = (image_win->height >> 1) - 1;\n\t\tvert_start >>= 1;\n\t\t \n\t\tval = (vert_start << VPFE_VDINT_VDINT0_SHIFT);\n\t} else {\n\t\tvert_nr_lines = image_win->height - 1;\n\t\t \n\t\tmid_img = vert_start + (image_win->height / 2);\n\t\tval = (vert_start << VPFE_VDINT_VDINT0_SHIFT) |\n\t\t\t\t(mid_img & VPFE_VDINT_VDINT1_MASK);\n\t}\n\n\tvpfe_reg_write(ccdc, val, VPFE_VDINT);\n\n\tvpfe_reg_write(ccdc, (vert_start << VPFE_VERT_START_SLV0_SHIFT) |\n\t\t\t\tvert_start, VPFE_VERT_START);\n\tvpfe_reg_write(ccdc, vert_nr_lines, VPFE_VERT_LINES);\n}\n\nstatic void vpfe_reg_dump(struct vpfe_ccdc *ccdc)\n{\n\tstruct vpfe_device *vpfe = to_vpfe(ccdc);\n\n\tvpfe_dbg(3, vpfe, \"ALAW: 0x%x\\n\", vpfe_reg_read(ccdc, VPFE_ALAW));\n\tvpfe_dbg(3, vpfe, \"CLAMP: 0x%x\\n\", vpfe_reg_read(ccdc, VPFE_CLAMP));\n\tvpfe_dbg(3, vpfe, \"DCSUB: 0x%x\\n\", vpfe_reg_read(ccdc, VPFE_DCSUB));\n\tvpfe_dbg(3, vpfe, \"BLKCMP: 0x%x\\n\", vpfe_reg_read(ccdc, VPFE_BLKCMP));\n\tvpfe_dbg(3, vpfe, \"COLPTN: 0x%x\\n\", vpfe_reg_read(ccdc, VPFE_COLPTN));\n\tvpfe_dbg(3, vpfe, \"SDOFST: 0x%x\\n\", vpfe_reg_read(ccdc, VPFE_SDOFST));\n\tvpfe_dbg(3, vpfe, \"SYN_MODE: 0x%x\\n\",\n\t\t vpfe_reg_read(ccdc, VPFE_SYNMODE));\n\tvpfe_dbg(3, vpfe, \"HSIZE_OFF: 0x%x\\n\",\n\t\t vpfe_reg_read(ccdc, VPFE_HSIZE_OFF));\n\tvpfe_dbg(3, vpfe, \"HORZ_INFO: 0x%x\\n\",\n\t\t vpfe_reg_read(ccdc, VPFE_HORZ_INFO));\n\tvpfe_dbg(3, vpfe, \"VERT_START: 0x%x\\n\",\n\t\t vpfe_reg_read(ccdc, VPFE_VERT_START));\n\tvpfe_dbg(3, vpfe, \"VERT_LINES: 0x%x\\n\",\n\t\t vpfe_reg_read(ccdc, VPFE_VERT_LINES));\n}\n\nstatic int\nvpfe_ccdc_validate_param(struct vpfe_ccdc *ccdc,\n\t\t\t struct vpfe_ccdc_config_params_raw *ccdcparam)\n{\n\tstruct vpfe_device *vpfe = to_vpfe(ccdc);\n\tu8 max_gamma, max_data;\n\n\tif (!ccdcparam->alaw.enable)\n\t\treturn 0;\n\n\tmax_gamma = ccdc_gamma_width_max_bit(ccdcparam->alaw.gamma_wd);\n\tmax_data = ccdc_data_size_max_bit(ccdcparam->data_sz);\n\n\tif (ccdcparam->alaw.gamma_wd > VPFE_CCDC_GAMMA_BITS_09_0 ||\n\t    ccdcparam->data_sz > VPFE_CCDC_DATA_8BITS ||\n\t    max_gamma > max_data) {\n\t\tvpfe_dbg(1, vpfe, \"Invalid data line select\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nvpfe_ccdc_update_raw_params(struct vpfe_ccdc *ccdc,\n\t\t\t    struct vpfe_ccdc_config_params_raw *raw_params)\n{\n\tstruct vpfe_ccdc_config_params_raw *config_params =\n\t\t\t\t&ccdc->ccdc_cfg.bayer.config_params;\n\n\t*config_params = *raw_params;\n}\n\n \nstatic void vpfe_ccdc_restore_defaults(struct vpfe_ccdc *ccdc)\n{\n\tint i;\n\n\t \n\tvpfe_pcr_enable(ccdc, 0);\n\n\t \n\tfor (i = 4; i <= 0x94; i += 4)\n\t\tvpfe_reg_write(ccdc, 0,  i);\n\n\tvpfe_reg_write(ccdc, VPFE_NO_CULLING, VPFE_CULLING);\n\tvpfe_reg_write(ccdc, VPFE_CCDC_GAMMA_BITS_11_2, VPFE_ALAW);\n}\n\nstatic int vpfe_ccdc_close(struct vpfe_ccdc *ccdc, struct device *dev)\n{\n\tstruct vpfe_device *vpfe = to_vpfe(ccdc);\n\tu32 dma_cntl, pcr;\n\n\tpcr = vpfe_reg_read(ccdc, VPFE_PCR);\n\tif (pcr)\n\t\tvpfe_dbg(1, vpfe, \"VPFE_PCR is still set (%x)\", pcr);\n\n\tdma_cntl = vpfe_reg_read(ccdc, VPFE_DMA_CNTL);\n\tif ((dma_cntl & VPFE_DMA_CNTL_OVERFLOW))\n\t\tvpfe_dbg(1, vpfe, \"VPFE_DMA_CNTL_OVERFLOW is still set (%x)\",\n\t\t\t dma_cntl);\n\n\t \n\tvpfe_ccdc_restore_defaults(ccdc);\n\n\t \n\tvpfe_config_enable(ccdc, 0);\n\n\tpm_runtime_put_sync(dev);\n\treturn 0;\n}\n\nstatic int vpfe_ccdc_set_params(struct vpfe_ccdc *ccdc, void __user *params)\n{\n\tstruct vpfe_device *vpfe = to_vpfe(ccdc);\n\tstruct vpfe_ccdc_config_params_raw raw_params;\n\tint x;\n\n\tif (ccdc->ccdc_cfg.if_type != VPFE_RAW_BAYER)\n\t\treturn -EINVAL;\n\n\tx = copy_from_user(&raw_params, params, sizeof(raw_params));\n\tif (x) {\n\t\tvpfe_dbg(1, vpfe,\n\t\t\t \"%s: error in copying ccdc params, %d\\n\",\n\t\t\t __func__, x);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!vpfe_ccdc_validate_param(ccdc, &raw_params)) {\n\t\tvpfe_ccdc_update_raw_params(ccdc, &raw_params);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic void vpfe_ccdc_config_ycbcr(struct vpfe_ccdc *ccdc)\n{\n\tstruct ccdc_params_ycbcr *params = &ccdc->ccdc_cfg.ycbcr;\n\tu32 syn_mode;\n\n\t \n\tvpfe_ccdc_restore_defaults(ccdc);\n\n\t \n\tsyn_mode = (((params->pix_fmt & VPFE_SYN_MODE_INPMOD_MASK) <<\n\t\t    VPFE_SYN_MODE_INPMOD_SHIFT) |\n\t\t    ((params->frm_fmt & VPFE_SYN_FLDMODE_MASK) <<\n\t\t    VPFE_SYN_FLDMODE_SHIFT) | VPFE_VDHDEN_ENABLE |\n\t\t    VPFE_WEN_ENABLE | VPFE_DATA_PACK_ENABLE);\n\n\t \n\tif (params->bt656_enable) {\n\t\tvpfe_reg_write(ccdc, VPFE_REC656IF_BT656_EN, VPFE_REC656IF);\n\n\t\t \n\t\tsyn_mode |= VPFE_SYN_MODE_VD_POL_NEGATIVE;\n\t\tif (ccdc->ccdc_cfg.if_type == VPFE_BT656_10BIT)\n\t\t\tsyn_mode |= VPFE_SYN_MODE_10BITS;\n\t\telse\n\t\t\tsyn_mode |= VPFE_SYN_MODE_8BITS;\n\t} else {\n\t\t \n\t\tsyn_mode |= (((params->fid_pol & VPFE_FID_POL_MASK) <<\n\t\t\t     VPFE_FID_POL_SHIFT) |\n\t\t\t     ((params->hd_pol & VPFE_HD_POL_MASK) <<\n\t\t\t     VPFE_HD_POL_SHIFT) |\n\t\t\t     ((params->vd_pol & VPFE_VD_POL_MASK) <<\n\t\t\t     VPFE_VD_POL_SHIFT));\n\t}\n\tvpfe_reg_write(ccdc, syn_mode, VPFE_SYNMODE);\n\n\t \n\tvpfe_ccdc_setwin(ccdc, &params->win,\n\t\t\t params->frm_fmt, params->bytesperpixel);\n\n\t \n\tif (ccdc->ccdc_cfg.if_type == VPFE_BT656_10BIT)\n\t\tvpfe_reg_write(ccdc,\n\t\t\t       (params->pix_order << VPFE_CCDCFG_Y8POS_SHIFT) |\n\t\t\t       VPFE_LATCH_ON_VSYNC_DISABLE |\n\t\t\t       VPFE_CCDCFG_BW656_10BIT, VPFE_CCDCFG);\n\telse\n\t\tvpfe_reg_write(ccdc,\n\t\t\t       (params->pix_order << VPFE_CCDCFG_Y8POS_SHIFT) |\n\t\t\t       VPFE_LATCH_ON_VSYNC_DISABLE, VPFE_CCDCFG);\n\n\t \n\tvpfe_reg_write(ccdc, params->bytesperline, VPFE_HSIZE_OFF);\n\n\t \n\tif (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED)\n\t\t \n\t\tvpfe_reg_write(ccdc, VPFE_SDOFST_FIELD_INTERLEAVED,\n\t\t\t       VPFE_SDOFST);\n}\n\nstatic void\nvpfe_ccdc_config_black_clamp(struct vpfe_ccdc *ccdc,\n\t\t\t     struct vpfe_ccdc_black_clamp *bclamp)\n{\n\tu32 val;\n\n\tif (!bclamp->enable) {\n\t\t \n\t\tval = (bclamp->dc_sub) & VPFE_BLK_DC_SUB_MASK;\n\t\tvpfe_reg_write(ccdc, val, VPFE_DCSUB);\n\t\tvpfe_reg_write(ccdc, VPFE_CLAMP_DEFAULT_VAL, VPFE_CLAMP);\n\t\treturn;\n\t}\n\t \n\tval = ((bclamp->sgain & VPFE_BLK_SGAIN_MASK) |\n\t       ((bclamp->start_pixel & VPFE_BLK_ST_PXL_MASK) <<\n\t\tVPFE_BLK_ST_PXL_SHIFT) |\n\t       ((bclamp->sample_ln & VPFE_BLK_SAMPLE_LINE_MASK) <<\n\t\tVPFE_BLK_SAMPLE_LINE_SHIFT) |\n\t       ((bclamp->sample_pixel & VPFE_BLK_SAMPLE_LN_MASK) <<\n\t\tVPFE_BLK_SAMPLE_LN_SHIFT) | VPFE_BLK_CLAMP_ENABLE);\n\tvpfe_reg_write(ccdc, val, VPFE_CLAMP);\n\t \n\tvpfe_reg_write(ccdc, VPFE_DCSUB_DEFAULT_VAL, VPFE_DCSUB);\n}\n\nstatic void\nvpfe_ccdc_config_black_compense(struct vpfe_ccdc *ccdc,\n\t\t\t\tstruct vpfe_ccdc_black_compensation *bcomp)\n{\n\tu32 val;\n\n\tval = ((bcomp->b & VPFE_BLK_COMP_MASK) |\n\t      ((bcomp->gb & VPFE_BLK_COMP_MASK) <<\n\t       VPFE_BLK_COMP_GB_COMP_SHIFT) |\n\t      ((bcomp->gr & VPFE_BLK_COMP_MASK) <<\n\t       VPFE_BLK_COMP_GR_COMP_SHIFT) |\n\t      ((bcomp->r & VPFE_BLK_COMP_MASK) <<\n\t       VPFE_BLK_COMP_R_COMP_SHIFT));\n\tvpfe_reg_write(ccdc, val, VPFE_BLKCMP);\n}\n\n \nstatic void vpfe_ccdc_config_raw(struct vpfe_ccdc *ccdc)\n{\n\tstruct vpfe_device *vpfe = to_vpfe(ccdc);\n\tstruct vpfe_ccdc_config_params_raw *config_params =\n\t\t\t\t&ccdc->ccdc_cfg.bayer.config_params;\n\tstruct ccdc_params_raw *params = &ccdc->ccdc_cfg.bayer;\n\tunsigned int syn_mode;\n\tunsigned int val;\n\n\t \n\tvpfe_ccdc_restore_defaults(ccdc);\n\n\t \n\tvpfe_reg_write(ccdc, VPFE_LATCH_ON_VSYNC_DISABLE, VPFE_CCDCFG);\n\n\t \n\tsyn_mode = (((params->vd_pol & VPFE_VD_POL_MASK) << VPFE_VD_POL_SHIFT) |\n\t\t   ((params->hd_pol & VPFE_HD_POL_MASK) << VPFE_HD_POL_SHIFT) |\n\t\t   ((params->fid_pol & VPFE_FID_POL_MASK) <<\n\t\t   VPFE_FID_POL_SHIFT) | ((params->frm_fmt &\n\t\t   VPFE_FRM_FMT_MASK) << VPFE_FRM_FMT_SHIFT) |\n\t\t   ((config_params->data_sz & VPFE_DATA_SZ_MASK) <<\n\t\t   VPFE_DATA_SZ_SHIFT) | ((params->pix_fmt &\n\t\t   VPFE_PIX_FMT_MASK) << VPFE_PIX_FMT_SHIFT) |\n\t\t   VPFE_WEN_ENABLE | VPFE_VDHDEN_ENABLE);\n\n\t \n\tif (config_params->alaw.enable) {\n\t\tval = ((config_params->alaw.gamma_wd &\n\t\t      VPFE_ALAW_GAMMA_WD_MASK) | VPFE_ALAW_ENABLE);\n\t\tvpfe_reg_write(ccdc, val, VPFE_ALAW);\n\t\tvpfe_dbg(3, vpfe, \"\\nWriting 0x%x to ALAW...\\n\", val);\n\t}\n\n\t \n\tvpfe_ccdc_setwin(ccdc, &params->win, params->frm_fmt,\n\t\t\t params->bytesperpixel);\n\n\t \n\tvpfe_ccdc_config_black_clamp(ccdc, &config_params->blk_clamp);\n\n\t \n\tvpfe_ccdc_config_black_compense(ccdc, &config_params->blk_comp);\n\n\t \n\tif ((config_params->data_sz == VPFE_CCDC_DATA_8BITS) ||\n\t    config_params->alaw.enable)\n\t\tsyn_mode |= VPFE_DATA_PACK_ENABLE;\n\n\t \n\tvpfe_reg_write(ccdc, params->bytesperline, VPFE_HSIZE_OFF);\n\n\tvpfe_dbg(3, vpfe, \"Writing %d (%x) to HSIZE_OFF\\n\",\n\t\tparams->bytesperline, params->bytesperline);\n\n\t \n\tif (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {\n\t\tif (params->image_invert_enable) {\n\t\t\t \n\t\t\tvpfe_reg_write(ccdc, VPFE_INTERLACED_IMAGE_INVERT,\n\t\t\t\t   VPFE_SDOFST);\n\t\t} else {\n\t\t\t \n\t\t\tvpfe_reg_write(ccdc, VPFE_INTERLACED_NO_IMAGE_INVERT,\n\t\t\t\t   VPFE_SDOFST);\n\t\t}\n\t} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {\n\t\tvpfe_reg_write(ccdc, VPFE_PROGRESSIVE_NO_IMAGE_INVERT,\n\t\t\t   VPFE_SDOFST);\n\t}\n\n\tvpfe_reg_write(ccdc, syn_mode, VPFE_SYNMODE);\n\n\tvpfe_reg_dump(ccdc);\n}\n\nstatic inline int\nvpfe_ccdc_set_buftype(struct vpfe_ccdc *ccdc,\n\t\t      enum ccdc_buftype buf_type)\n{\n\tif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER)\n\t\tccdc->ccdc_cfg.bayer.buf_type = buf_type;\n\telse\n\t\tccdc->ccdc_cfg.ycbcr.buf_type = buf_type;\n\n\treturn 0;\n}\n\nstatic inline enum ccdc_buftype vpfe_ccdc_get_buftype(struct vpfe_ccdc *ccdc)\n{\n\tif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER)\n\t\treturn ccdc->ccdc_cfg.bayer.buf_type;\n\n\treturn ccdc->ccdc_cfg.ycbcr.buf_type;\n}\n\nstatic int vpfe_ccdc_set_pixel_format(struct vpfe_ccdc *ccdc, u32 pixfmt)\n{\n\tstruct vpfe_device *vpfe = to_vpfe(ccdc);\n\n\tvpfe_dbg(1, vpfe, \"%s: if_type: %d, pixfmt:%s\\n\",\n\t\t __func__, ccdc->ccdc_cfg.if_type, print_fourcc(pixfmt));\n\n\tif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER) {\n\t\tccdc->ccdc_cfg.bayer.pix_fmt = CCDC_PIXFMT_RAW;\n\t\t \n\t\tccdc->ccdc_cfg.bayer.config_params.alaw.enable = 0;\n\n\t\tswitch (pixfmt) {\n\t\tcase V4L2_PIX_FMT_SBGGR8:\n\t\t\tccdc->ccdc_cfg.bayer.config_params.alaw.enable = 1;\n\t\t\tbreak;\n\n\t\tcase V4L2_PIX_FMT_YUYV:\n\t\tcase V4L2_PIX_FMT_UYVY:\n\t\tcase V4L2_PIX_FMT_YUV420:\n\t\tcase V4L2_PIX_FMT_NV12:\n\t\tcase V4L2_PIX_FMT_RGB565X:\n\t\t\tbreak;\n\n\t\tcase V4L2_PIX_FMT_SBGGR16:\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (pixfmt) {\n\t\tcase V4L2_PIX_FMT_YUYV:\n\t\t\tccdc->ccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_YCBYCR;\n\t\t\tbreak;\n\n\t\tcase V4L2_PIX_FMT_UYVY:\n\t\t\tccdc->ccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic u32 vpfe_ccdc_get_pixel_format(struct vpfe_ccdc *ccdc)\n{\n\tu32 pixfmt;\n\n\tif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER) {\n\t\tpixfmt = V4L2_PIX_FMT_YUYV;\n\t} else {\n\t\tif (ccdc->ccdc_cfg.ycbcr.pix_order == CCDC_PIXORDER_YCBYCR)\n\t\t\tpixfmt = V4L2_PIX_FMT_YUYV;\n\t\telse\n\t\t\tpixfmt = V4L2_PIX_FMT_UYVY;\n\t}\n\n\treturn pixfmt;\n}\n\nstatic int\nvpfe_ccdc_set_image_window(struct vpfe_ccdc *ccdc,\n\t\t\t   struct v4l2_rect *win, unsigned int bpp)\n{\n\tif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER) {\n\t\tccdc->ccdc_cfg.bayer.win = *win;\n\t\tccdc->ccdc_cfg.bayer.bytesperpixel = bpp;\n\t\tccdc->ccdc_cfg.bayer.bytesperline = ALIGN(win->width * bpp, 32);\n\t} else {\n\t\tccdc->ccdc_cfg.ycbcr.win = *win;\n\t\tccdc->ccdc_cfg.ycbcr.bytesperpixel = bpp;\n\t\tccdc->ccdc_cfg.ycbcr.bytesperline = ALIGN(win->width * bpp, 32);\n\t}\n\n\treturn 0;\n}\n\nstatic inline void\nvpfe_ccdc_get_image_window(struct vpfe_ccdc *ccdc,\n\t\t\t   struct v4l2_rect *win)\n{\n\tif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER)\n\t\t*win = ccdc->ccdc_cfg.bayer.win;\n\telse\n\t\t*win = ccdc->ccdc_cfg.ycbcr.win;\n}\n\nstatic inline unsigned int vpfe_ccdc_get_line_length(struct vpfe_ccdc *ccdc)\n{\n\tif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER)\n\t\treturn ccdc->ccdc_cfg.bayer.bytesperline;\n\n\treturn ccdc->ccdc_cfg.ycbcr.bytesperline;\n}\n\nstatic inline int\nvpfe_ccdc_set_frame_format(struct vpfe_ccdc *ccdc,\n\t\t\t   enum ccdc_frmfmt frm_fmt)\n{\n\tif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER)\n\t\tccdc->ccdc_cfg.bayer.frm_fmt = frm_fmt;\n\telse\n\t\tccdc->ccdc_cfg.ycbcr.frm_fmt = frm_fmt;\n\n\treturn 0;\n}\n\nstatic inline enum ccdc_frmfmt\nvpfe_ccdc_get_frame_format(struct vpfe_ccdc *ccdc)\n{\n\tif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER)\n\t\treturn ccdc->ccdc_cfg.bayer.frm_fmt;\n\n\treturn ccdc->ccdc_cfg.ycbcr.frm_fmt;\n}\n\nstatic inline int vpfe_ccdc_getfid(struct vpfe_ccdc *ccdc)\n{\n\treturn (vpfe_reg_read(ccdc, VPFE_SYNMODE) >> 15) & 1;\n}\n\nstatic inline void vpfe_set_sdr_addr(struct vpfe_ccdc *ccdc, unsigned long addr)\n{\n\tvpfe_reg_write(ccdc, addr & 0xffffffe0, VPFE_SDR_ADDR);\n}\n\nstatic int vpfe_ccdc_set_hw_if_params(struct vpfe_ccdc *ccdc,\n\t\t\t\t      struct vpfe_hw_if_param *params)\n{\n\tstruct vpfe_device *vpfe = to_vpfe(ccdc);\n\n\tccdc->ccdc_cfg.if_type = params->if_type;\n\n\tswitch (params->if_type) {\n\tcase VPFE_BT656:\n\tcase VPFE_YCBCR_SYNC_16:\n\tcase VPFE_YCBCR_SYNC_8:\n\tcase VPFE_BT656_10BIT:\n\t\tccdc->ccdc_cfg.ycbcr.vd_pol = params->vdpol;\n\t\tccdc->ccdc_cfg.ycbcr.hd_pol = params->hdpol;\n\t\tbreak;\n\n\tcase VPFE_RAW_BAYER:\n\t\tccdc->ccdc_cfg.bayer.vd_pol = params->vdpol;\n\t\tccdc->ccdc_cfg.bayer.hd_pol = params->hdpol;\n\t\tif (params->bus_width == 10)\n\t\t\tccdc->ccdc_cfg.bayer.config_params.data_sz =\n\t\t\t\tVPFE_CCDC_DATA_10BITS;\n\t\telse\n\t\t\tccdc->ccdc_cfg.bayer.config_params.data_sz =\n\t\t\t\tVPFE_CCDC_DATA_8BITS;\n\t\tvpfe_dbg(1, vpfe, \"params.bus_width: %d\\n\",\n\t\t\tparams->bus_width);\n\t\tvpfe_dbg(1, vpfe, \"config_params.data_sz: %d\\n\",\n\t\t\tccdc->ccdc_cfg.bayer.config_params.data_sz);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void vpfe_clear_intr(struct vpfe_ccdc *ccdc, int vdint)\n{\n\tunsigned int vpfe_int_status;\n\n\tvpfe_int_status = vpfe_reg_read(ccdc, VPFE_IRQ_STS);\n\n\tswitch (vdint) {\n\t \n\tcase VPFE_VDINT0:\n\t\tvpfe_int_status &= ~VPFE_VDINT0;\n\t\tvpfe_int_status |= VPFE_VDINT0;\n\t\tbreak;\n\n\t \n\tcase VPFE_VDINT1:\n\t\tvpfe_int_status &= ~VPFE_VDINT1;\n\t\tvpfe_int_status |= VPFE_VDINT1;\n\t\tbreak;\n\n\t \n\tcase VPFE_VDINT2:\n\t\tvpfe_int_status &= ~VPFE_VDINT2;\n\t\tvpfe_int_status |= VPFE_VDINT2;\n\t\tbreak;\n\n\t \n\tdefault:\n\t\tvpfe_int_status &= ~(VPFE_VDINT0 |\n\t\t\t\tVPFE_VDINT1 |\n\t\t\t\tVPFE_VDINT2);\n\t\tvpfe_int_status |= (VPFE_VDINT0 |\n\t\t\t\tVPFE_VDINT1 |\n\t\t\t\tVPFE_VDINT2);\n\t\tbreak;\n\t}\n\t \n\tvpfe_reg_write(ccdc, vpfe_int_status, VPFE_IRQ_STS);\n\n\tvpfe_int_status = vpfe_reg_read(ccdc, VPFE_IRQ_STS);\n\n\t \n\tvpfe_reg_write(ccdc, 1, VPFE_IRQ_EOI);\n}\n\nstatic void vpfe_ccdc_config_defaults(struct vpfe_ccdc *ccdc)\n{\n\tccdc->ccdc_cfg.if_type = VPFE_RAW_BAYER;\n\n\tccdc->ccdc_cfg.ycbcr.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT;\n\tccdc->ccdc_cfg.ycbcr.frm_fmt = CCDC_FRMFMT_INTERLACED;\n\tccdc->ccdc_cfg.ycbcr.fid_pol = VPFE_PINPOL_POSITIVE;\n\tccdc->ccdc_cfg.ycbcr.vd_pol = VPFE_PINPOL_POSITIVE;\n\tccdc->ccdc_cfg.ycbcr.hd_pol = VPFE_PINPOL_POSITIVE;\n\tccdc->ccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;\n\tccdc->ccdc_cfg.ycbcr.buf_type = CCDC_BUFTYPE_FLD_INTERLEAVED;\n\n\tccdc->ccdc_cfg.ycbcr.win.left = 0;\n\tccdc->ccdc_cfg.ycbcr.win.top = 0;\n\tccdc->ccdc_cfg.ycbcr.win.width = 720;\n\tccdc->ccdc_cfg.ycbcr.win.height = 576;\n\tccdc->ccdc_cfg.ycbcr.bt656_enable = 1;\n\n\tccdc->ccdc_cfg.bayer.pix_fmt = CCDC_PIXFMT_RAW;\n\tccdc->ccdc_cfg.bayer.frm_fmt = CCDC_FRMFMT_PROGRESSIVE;\n\tccdc->ccdc_cfg.bayer.fid_pol = VPFE_PINPOL_POSITIVE;\n\tccdc->ccdc_cfg.bayer.vd_pol = VPFE_PINPOL_POSITIVE;\n\tccdc->ccdc_cfg.bayer.hd_pol = VPFE_PINPOL_POSITIVE;\n\n\tccdc->ccdc_cfg.bayer.win.left = 0;\n\tccdc->ccdc_cfg.bayer.win.top = 0;\n\tccdc->ccdc_cfg.bayer.win.width = 800;\n\tccdc->ccdc_cfg.bayer.win.height = 600;\n\tccdc->ccdc_cfg.bayer.config_params.data_sz = VPFE_CCDC_DATA_8BITS;\n\tccdc->ccdc_cfg.bayer.config_params.alaw.gamma_wd =\n\t\t\t\t\t\tVPFE_CCDC_GAMMA_BITS_09_0;\n}\n\n \nstatic int vpfe_get_ccdc_image_format(struct vpfe_device *vpfe,\n\t\t\t\t      struct v4l2_format *f)\n{\n\tstruct v4l2_rect image_win;\n\tenum ccdc_buftype buf_type;\n\tenum ccdc_frmfmt frm_fmt;\n\n\tmemset(f, 0, sizeof(*f));\n\tf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tvpfe_ccdc_get_image_window(&vpfe->ccdc, &image_win);\n\tf->fmt.pix.width = image_win.width;\n\tf->fmt.pix.height = image_win.height;\n\tf->fmt.pix.bytesperline = vpfe_ccdc_get_line_length(&vpfe->ccdc);\n\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\n\t\t\t\tf->fmt.pix.height;\n\tbuf_type = vpfe_ccdc_get_buftype(&vpfe->ccdc);\n\tf->fmt.pix.pixelformat = vpfe_ccdc_get_pixel_format(&vpfe->ccdc);\n\tfrm_fmt = vpfe_ccdc_get_frame_format(&vpfe->ccdc);\n\n\tif (frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {\n\t\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\t} else if (frm_fmt == CCDC_FRMFMT_INTERLACED) {\n\t\tif (buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED) {\n\t\t\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\t\t } else if (buf_type == CCDC_BUFTYPE_FLD_SEPARATED) {\n\t\t\tf->fmt.pix.field = V4L2_FIELD_SEQ_TB;\n\t\t} else {\n\t\t\tvpfe_err(vpfe, \"Invalid buf_type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tvpfe_err(vpfe, \"Invalid frm_fmt\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vpfe_config_ccdc_image_format(struct vpfe_device *vpfe)\n{\n\tenum ccdc_frmfmt frm_fmt = CCDC_FRMFMT_INTERLACED;\n\tu32 bpp;\n\tint ret = 0;\n\n\tvpfe_dbg(1, vpfe, \"pixelformat: %s\\n\",\n\t\tprint_fourcc(vpfe->fmt.fmt.pix.pixelformat));\n\n\tif (vpfe_ccdc_set_pixel_format(&vpfe->ccdc,\n\t\t\tvpfe->fmt.fmt.pix.pixelformat) < 0) {\n\t\tvpfe_err(vpfe, \"couldn't set pix format in ccdc\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbpp = __get_bytesperpixel(vpfe, vpfe->current_vpfe_fmt);\n\tvpfe_ccdc_set_image_window(&vpfe->ccdc, &vpfe->crop, bpp);\n\n\tswitch (vpfe->fmt.fmt.pix.field) {\n\tcase V4L2_FIELD_INTERLACED:\n\t\t \n\t\tret = vpfe_ccdc_set_buftype(\n\t\t\t\t&vpfe->ccdc,\n\t\t\t\tCCDC_BUFTYPE_FLD_INTERLEAVED);\n\t\tbreak;\n\n\tcase V4L2_FIELD_NONE:\n\t\tfrm_fmt = CCDC_FRMFMT_PROGRESSIVE;\n\t\t \n\t\tbreak;\n\n\tcase V4L2_FIELD_SEQ_TB:\n\t\tret = vpfe_ccdc_set_buftype(\n\t\t\t\t&vpfe->ccdc,\n\t\t\t\tCCDC_BUFTYPE_FLD_SEPARATED);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn vpfe_ccdc_set_frame_format(&vpfe->ccdc, frm_fmt);\n}\n\n \nstatic int vpfe_config_image_format(struct vpfe_device *vpfe,\n\t\t\t\t    v4l2_std_id std_id)\n{\n\tstruct vpfe_fmt *fmt;\n\tstruct v4l2_mbus_framefmt mbus_fmt;\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(vpfe_standards); i++) {\n\t\tif (vpfe_standards[i].std_id & std_id) {\n\t\t\tvpfe->std_info.active_pixels =\n\t\t\t\t\tvpfe_standards[i].width;\n\t\t\tvpfe->std_info.active_lines =\n\t\t\t\t\tvpfe_standards[i].height;\n\t\t\tvpfe->std_info.frame_format =\n\t\t\t\t\tvpfe_standards[i].frame_format;\n\t\t\tvpfe->std_index = i;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i ==  ARRAY_SIZE(vpfe_standards)) {\n\t\tvpfe_err(vpfe, \"standard not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = __subdev_get_format(vpfe, &mbus_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tfmt = find_format_by_code(vpfe, mbus_fmt.code);\n\tif (!fmt) {\n\t\tvpfe_dbg(3, vpfe, \"mbus code format (0x%08x) not found.\\n\",\n\t\t\t mbus_fmt.code);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tv4l2_fill_pix_format(&vpfe->fmt.fmt.pix, &mbus_fmt);\n\tvpfe->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tvpfe->fmt.fmt.pix.pixelformat = fmt->fourcc;\n\tvpfe_calc_format_size(vpfe, fmt, &vpfe->fmt);\n\tvpfe->current_vpfe_fmt = fmt;\n\n\t \n\tvpfe->crop.top = 0;\n\tvpfe->crop.left = 0;\n\tvpfe->crop.width = mbus_fmt.width;\n\tvpfe->crop.height = mbus_fmt.height;\n\n\treturn vpfe_config_ccdc_image_format(vpfe);\n}\n\nstatic int vpfe_initialize_device(struct vpfe_device *vpfe)\n{\n\tstruct vpfe_subdev_info *sdinfo;\n\tint ret;\n\n\tsdinfo = &vpfe->cfg->sub_devs[0];\n\tsdinfo->sd = vpfe->sd[0];\n\tvpfe->current_input = 0;\n\tvpfe->std_index = 0;\n\t \n\tret = vpfe_config_image_format(vpfe,\n\t\t\t\t       vpfe_standards[vpfe->std_index].std_id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(vpfe->pdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvpfe_config_enable(&vpfe->ccdc, 1);\n\n\tvpfe_ccdc_restore_defaults(&vpfe->ccdc);\n\n\t \n\tvpfe_clear_intr(&vpfe->ccdc, -1);\n\n\treturn ret;\n}\n\n \nstatic int vpfe_release(struct file *file)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\tbool fh_singular;\n\tint ret;\n\n\tmutex_lock(&vpfe->lock);\n\n\t \n\tfh_singular = v4l2_fh_is_singular_file(file);\n\n\t \n\tret = _vb2_fop_release(file, NULL);\n\n\t \n\tif (fh_singular)\n\t\tvpfe_ccdc_close(&vpfe->ccdc, vpfe->pdev);\n\n\tmutex_unlock(&vpfe->lock);\n\n\treturn ret;\n}\n\n \nstatic int vpfe_open(struct file *file)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\tint ret;\n\n\tmutex_lock(&vpfe->lock);\n\n\tret = v4l2_fh_open(file);\n\tif (ret) {\n\t\tvpfe_err(vpfe, \"v4l2_fh_open failed\\n\");\n\t\tgoto unlock;\n\t}\n\n\tif (!v4l2_fh_is_singular_file(file))\n\t\tgoto unlock;\n\n\tif (vpfe_initialize_device(vpfe)) {\n\t\tv4l2_fh_release(file);\n\t\tret = -ENODEV;\n\t}\n\nunlock:\n\tmutex_unlock(&vpfe->lock);\n\treturn ret;\n}\n\n \nstatic void vpfe_schedule_next_buffer(struct vpfe_device *vpfe)\n{\n\tdma_addr_t addr;\n\n\tspin_lock(&vpfe->dma_queue_lock);\n\tif (list_empty(&vpfe->dma_queue)) {\n\t\tspin_unlock(&vpfe->dma_queue_lock);\n\t\treturn;\n\t}\n\n\tvpfe->next_frm = list_entry(vpfe->dma_queue.next,\n\t\t\t\t    struct vpfe_cap_buffer, list);\n\tlist_del(&vpfe->next_frm->list);\n\tspin_unlock(&vpfe->dma_queue_lock);\n\n\taddr = vb2_dma_contig_plane_dma_addr(&vpfe->next_frm->vb.vb2_buf, 0);\n\tvpfe_set_sdr_addr(&vpfe->ccdc, addr);\n}\n\nstatic inline void vpfe_schedule_bottom_field(struct vpfe_device *vpfe)\n{\n\tdma_addr_t addr;\n\n\taddr = vb2_dma_contig_plane_dma_addr(&vpfe->next_frm->vb.vb2_buf, 0) +\n\t\t\t\t\tvpfe->field_off;\n\n\tvpfe_set_sdr_addr(&vpfe->ccdc, addr);\n}\n\n \nstatic inline void vpfe_process_buffer_complete(struct vpfe_device *vpfe)\n{\n\tvpfe->cur_frm->vb.vb2_buf.timestamp = ktime_get_ns();\n\tvpfe->cur_frm->vb.field = vpfe->fmt.fmt.pix.field;\n\tvpfe->cur_frm->vb.sequence = vpfe->sequence++;\n\tvb2_buffer_done(&vpfe->cur_frm->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\tvpfe->cur_frm = vpfe->next_frm;\n}\n\nstatic void vpfe_handle_interlaced_irq(struct vpfe_device *vpfe,\n\t\t\t\t       enum v4l2_field field)\n{\n\tint fid;\n\n\t \n\tfid = vpfe_ccdc_getfid(&vpfe->ccdc);\n\n\t \n\tvpfe->field ^= 1;\n\tif (fid == vpfe->field) {\n\t\t \n\t\tif (fid == 0) {\n\t\t\t \n\t\t\tif (vpfe->cur_frm != vpfe->next_frm)\n\t\t\t\tvpfe_process_buffer_complete(vpfe);\n\n\t\t\tif (vpfe->stopping)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tif (field == V4L2_FIELD_SEQ_TB)\n\t\t\t\tvpfe_schedule_bottom_field(vpfe);\n\t\t} else {\n\t\t\t \n\t\t\tif (vpfe->cur_frm == vpfe->next_frm)\n\t\t\t\tvpfe_schedule_next_buffer(vpfe);\n\t\t}\n\t} else if (fid == 0) {\n\t\t \n\t\tvpfe->field = fid;\n\t}\n}\n\n \nstatic irqreturn_t vpfe_isr(int irq, void *dev)\n{\n\tstruct vpfe_device *vpfe = (struct vpfe_device *)dev;\n\tenum v4l2_field field = vpfe->fmt.fmt.pix.field;\n\tint intr_status, stopping = vpfe->stopping;\n\n\tintr_status = vpfe_reg_read(&vpfe->ccdc, VPFE_IRQ_STS);\n\n\tif (intr_status & VPFE_VDINT0) {\n\t\tif (field == V4L2_FIELD_NONE) {\n\t\t\tif (vpfe->cur_frm != vpfe->next_frm)\n\t\t\t\tvpfe_process_buffer_complete(vpfe);\n\t\t} else {\n\t\t\tvpfe_handle_interlaced_irq(vpfe, field);\n\t\t}\n\t\tif (stopping) {\n\t\t\tvpfe->stopping = false;\n\t\t\tcomplete(&vpfe->capture_stop);\n\t\t}\n\t}\n\n\tif (intr_status & VPFE_VDINT1 && !stopping) {\n\t\tif (field == V4L2_FIELD_NONE &&\n\t\t    vpfe->cur_frm == vpfe->next_frm)\n\t\t\tvpfe_schedule_next_buffer(vpfe);\n\t}\n\n\tvpfe_clear_intr(&vpfe->ccdc, intr_status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline void vpfe_detach_irq(struct vpfe_device *vpfe)\n{\n\tunsigned int intr = VPFE_VDINT0;\n\tenum ccdc_frmfmt frame_format;\n\n\tframe_format = vpfe_ccdc_get_frame_format(&vpfe->ccdc);\n\tif (frame_format == CCDC_FRMFMT_PROGRESSIVE)\n\t\tintr |= VPFE_VDINT1;\n\n\tvpfe_reg_write(&vpfe->ccdc, intr, VPFE_IRQ_EN_CLR);\n}\n\nstatic inline void vpfe_attach_irq(struct vpfe_device *vpfe)\n{\n\tunsigned int intr = VPFE_VDINT0;\n\tenum ccdc_frmfmt frame_format;\n\n\tframe_format = vpfe_ccdc_get_frame_format(&vpfe->ccdc);\n\tif (frame_format == CCDC_FRMFMT_PROGRESSIVE)\n\t\tintr |= VPFE_VDINT1;\n\n\tvpfe_reg_write(&vpfe->ccdc, intr, VPFE_IRQ_EN_SET);\n}\n\nstatic int vpfe_querycap(struct file *file, void  *priv,\n\t\t\t struct v4l2_capability *cap)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\n\tstrscpy(cap->driver, VPFE_MODULE_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, \"TI AM437x VPFE\", sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t\t\"platform:%s\", vpfe->v4l2_dev.name);\n\treturn 0;\n}\n\n \nstatic int __subdev_get_format(struct vpfe_device *vpfe,\n\t\t\t       struct v4l2_mbus_framefmt *fmt)\n{\n\tstruct v4l2_subdev *sd = vpfe->current_subdev->sd;\n\tstruct v4l2_subdev_format sd_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.pad = 0,\n\t};\n\tstruct v4l2_mbus_framefmt *mbus_fmt = &sd_fmt.format;\n\tint ret;\n\n\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &sd_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\t*fmt = *mbus_fmt;\n\n\tvpfe_dbg(1, vpfe, \"%s: %dx%d code:%04X\\n\", __func__,\n\t\t fmt->width, fmt->height, fmt->code);\n\n\treturn 0;\n}\n\n \nstatic int __subdev_set_format(struct vpfe_device *vpfe,\n\t\t\t       struct v4l2_mbus_framefmt *fmt)\n{\n\tstruct v4l2_subdev *sd = vpfe->current_subdev->sd;\n\tstruct v4l2_subdev_format sd_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.pad = 0,\n\t};\n\tstruct v4l2_mbus_framefmt *mbus_fmt = &sd_fmt.format;\n\tint ret;\n\n\t*mbus_fmt = *fmt;\n\n\tret = v4l2_subdev_call(sd, pad, set_fmt, NULL, &sd_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tvpfe_dbg(1, vpfe, \"%s %dx%d code:%04X\\n\", __func__,\n\t\t fmt->width, fmt->height, fmt->code);\n\n\treturn 0;\n}\n\nstatic int vpfe_calc_format_size(struct vpfe_device *vpfe,\n\t\t\t\t const struct vpfe_fmt *fmt,\n\t\t\t\t struct v4l2_format *f)\n{\n\tu32 bpp;\n\n\tif (!fmt) {\n\t\tvpfe_dbg(3, vpfe, \"No vpfe_fmt provided!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbpp = __get_bytesperpixel(vpfe, fmt);\n\n\t \n\tf->fmt.pix.bytesperline = ALIGN(f->fmt.pix.width * bpp, 32);\n\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\n\t\t\t       f->fmt.pix.height;\n\n\tvpfe_dbg(3, vpfe, \"%s: fourcc: %s size: %dx%d bpl:%d img_size:%d\\n\",\n\t\t __func__, print_fourcc(f->fmt.pix.pixelformat),\n\t\t f->fmt.pix.width, f->fmt.pix.height,\n\t\t f->fmt.pix.bytesperline, f->fmt.pix.sizeimage);\n\n\treturn 0;\n}\n\nstatic int vpfe_g_fmt(struct file *file, void *priv,\n\t\t      struct v4l2_format *fmt)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\n\t*fmt = vpfe->fmt;\n\n\treturn 0;\n}\n\nstatic int vpfe_enum_fmt(struct file *file, void  *priv,\n\t\t\t struct v4l2_fmtdesc *f)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\tstruct vpfe_subdev_info *sdinfo;\n\tstruct vpfe_fmt *fmt;\n\n\tsdinfo = vpfe->current_subdev;\n\tif (!sdinfo->sd)\n\t\treturn -EINVAL;\n\n\tif (f->index >= vpfe->num_active_fmt)\n\t\treturn -EINVAL;\n\n\tfmt = vpfe->active_fmt[f->index];\n\n\tf->pixelformat = fmt->fourcc;\n\n\tvpfe_dbg(1, vpfe, \"%s: mbus index: %d code: %x pixelformat: %s\\n\",\n\t\t __func__, f->index, fmt->code, print_fourcc(fmt->fourcc));\n\n\treturn 0;\n}\n\nstatic int vpfe_try_fmt(struct file *file, void *priv,\n\t\t\tstruct v4l2_format *f)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\tstruct v4l2_subdev *sd = vpfe->current_subdev->sd;\n\tconst struct vpfe_fmt *fmt;\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret, found;\n\n\tfmt = find_format_by_pix(vpfe, f->fmt.pix.pixelformat);\n\tif (!fmt) {\n\t\t \n\t\tvpfe_dbg(3, vpfe, \"Invalid pixel code: %x, default used instead\\n\",\n\t\t\t f->fmt.pix.pixelformat);\n\t\tfmt = vpfe->active_fmt[0];\n\t\tf->fmt.pix.pixelformat = fmt->fourcc;\n\t}\n\n\tf->fmt.pix.field = vpfe->fmt.fmt.pix.field;\n\n\t \n\tret = 0;\n\tfound = false;\n\tfse.pad = 0;\n\tfse.code = fmt->code;\n\tfor (fse.index = 0; ; fse.index++) {\n\t\tret = v4l2_subdev_call(sd, pad, enum_frame_size,\n\t\t\t\t       NULL, &fse);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (f->fmt.pix.width == fse.max_width &&\n\t\t    f->fmt.pix.height == fse.max_height) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t} else if (f->fmt.pix.width >= fse.min_width &&\n\t\t\t   f->fmt.pix.width <= fse.max_width &&\n\t\t\t   f->fmt.pix.height >= fse.min_height &&\n\t\t\t   f->fmt.pix.height <= fse.max_height) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\t \n\t\tf->fmt.pix.width = vpfe->fmt.fmt.pix.width;\n\t\tf->fmt.pix.height =  vpfe->fmt.fmt.pix.height;\n\t}\n\n\t \n\tf->fmt.pix.colorspace = vpfe->fmt.fmt.pix.colorspace;\n\treturn vpfe_calc_format_size(vpfe, fmt, f);\n}\n\nstatic int vpfe_s_fmt(struct file *file, void *priv,\n\t\t      struct v4l2_format *fmt)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\tstruct vpfe_fmt *f;\n\tstruct v4l2_mbus_framefmt mbus_fmt;\n\tint ret;\n\n\t \n\tif (vb2_is_busy(&vpfe->buffer_queue)) {\n\t\tvpfe_err(vpfe, \"%s device busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tret = vpfe_try_fmt(file, priv, fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tf = find_format_by_pix(vpfe, fmt->fmt.pix.pixelformat);\n\n\tv4l2_fill_mbus_format(&mbus_fmt, &fmt->fmt.pix, f->code);\n\n\tret = __subdev_set_format(vpfe, &mbus_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (mbus_fmt.code != f->code) {\n\t\tvpfe_dbg(3, vpfe,\n\t\t\t \"%s subdev changed format on us, this should not happen\\n\",\n\t\t\t __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tv4l2_fill_pix_format(&vpfe->fmt.fmt.pix, &mbus_fmt);\n\tvpfe->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tvpfe->fmt.fmt.pix.pixelformat  = f->fourcc;\n\tvpfe_calc_format_size(vpfe, f, &vpfe->fmt);\n\t*fmt = vpfe->fmt;\n\tvpfe->current_vpfe_fmt = f;\n\n\t \n\tvpfe->crop.width = fmt->fmt.pix.width;\n\tvpfe->crop.height = fmt->fmt.pix.height;\n\n\t \n\treturn vpfe_config_ccdc_image_format(vpfe);\n}\n\nstatic int vpfe_enum_size(struct file *file, void  *priv,\n\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev *sd = vpfe->current_subdev->sd;\n\tstruct vpfe_fmt *fmt;\n\tint ret;\n\n\t \n\tfmt = find_format_by_pix(vpfe, fsize->pixel_format);\n\tif (!fmt) {\n\t\tvpfe_dbg(3, vpfe, \"Invalid pixel code: %x\\n\",\n\t\t\t fsize->pixel_format);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(fsize->reserved, 0x0, sizeof(fsize->reserved));\n\n\tfse.index = fsize->index;\n\tfse.pad = 0;\n\tfse.code = fmt->code;\n\tret = v4l2_subdev_call(sd, pad, enum_frame_size, NULL, &fse);\n\tif (ret)\n\t\treturn ret;\n\n\tvpfe_dbg(1, vpfe, \"%s: index: %d code: %x W:[%d,%d] H:[%d,%d]\\n\",\n\t\t __func__, fse.index, fse.code, fse.min_width, fse.max_width,\n\t\t fse.min_height, fse.max_height);\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = fse.max_width;\n\tfsize->discrete.height = fse.max_height;\n\n\tvpfe_dbg(1, vpfe, \"%s: index: %d pixformat: %s size: %dx%d\\n\",\n\t\t __func__, fsize->index, print_fourcc(fsize->pixel_format),\n\t\t fsize->discrete.width, fsize->discrete.height);\n\n\treturn 0;\n}\n\n \nstatic int\nvpfe_get_subdev_input_index(struct vpfe_device *vpfe,\n\t\t\t    int *subdev_index,\n\t\t\t    int *subdev_input_index,\n\t\t\t    int app_input_index)\n{\n\tint i, j = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(vpfe->cfg->asd); i++) {\n\t\tif (app_input_index < (j + 1)) {\n\t\t\t*subdev_index = i;\n\t\t\t*subdev_input_index = app_input_index - j;\n\t\t\treturn 0;\n\t\t}\n\t\tj++;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int vpfe_get_app_input_index(struct vpfe_device *vpfe,\n\t\t\t\t    int *app_input_index)\n{\n\tstruct vpfe_config *cfg = vpfe->cfg;\n\tstruct vpfe_subdev_info *sdinfo;\n\tstruct i2c_client *client;\n\tstruct i2c_client *curr_client;\n\tint i, j = 0;\n\n\tcurr_client = v4l2_get_subdevdata(vpfe->current_subdev->sd);\n\tfor (i = 0; i < ARRAY_SIZE(vpfe->cfg->asd); i++) {\n\t\tsdinfo = &cfg->sub_devs[i];\n\t\tclient = v4l2_get_subdevdata(sdinfo->sd);\n\t\tif (client->addr == curr_client->addr &&\n\t\t    client->adapter->nr == curr_client->adapter->nr) {\n\t\t\tif (vpfe->current_input >= 1)\n\t\t\t\treturn -1;\n\t\t\t*app_input_index = j + vpfe->current_input;\n\t\t\treturn 0;\n\t\t}\n\t\tj++;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int vpfe_enum_input(struct file *file, void *priv,\n\t\t\t   struct v4l2_input *inp)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\tstruct vpfe_subdev_info *sdinfo;\n\tint subdev, index;\n\n\tif (vpfe_get_subdev_input_index(vpfe, &subdev, &index,\n\t\t\t\t\tinp->index) < 0) {\n\t\tvpfe_dbg(1, vpfe,\n\t\t\t\"input information not found for the subdev\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsdinfo = &vpfe->cfg->sub_devs[subdev];\n\t*inp = sdinfo->inputs[index];\n\n\treturn 0;\n}\n\nstatic int vpfe_g_input(struct file *file, void *priv, unsigned int *index)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\n\treturn vpfe_get_app_input_index(vpfe, index);\n}\n\n \nstatic int vpfe_set_input(struct vpfe_device *vpfe, unsigned int index)\n{\n\tint subdev_index = 0, inp_index = 0;\n\tstruct vpfe_subdev_info *sdinfo;\n\tstruct vpfe_route *route;\n\tu32 input, output;\n\tint ret;\n\n\t \n\tif (vb2_is_busy(&vpfe->buffer_queue)) {\n\t\tvpfe_err(vpfe, \"%s device busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\tret = vpfe_get_subdev_input_index(vpfe,\n\t\t\t\t\t  &subdev_index,\n\t\t\t\t\t  &inp_index,\n\t\t\t\t\t  index);\n\tif (ret < 0) {\n\t\tvpfe_err(vpfe, \"invalid input index: %d\\n\", index);\n\t\tgoto get_out;\n\t}\n\n\tsdinfo = &vpfe->cfg->sub_devs[subdev_index];\n\tsdinfo->sd = vpfe->sd[subdev_index];\n\troute = &sdinfo->routes[inp_index];\n\tif (route && sdinfo->can_route) {\n\t\tinput = route->input;\n\t\toutput = route->output;\n\t\tif (sdinfo->sd) {\n\t\t\tret = v4l2_subdev_call(sdinfo->sd, video,\n\t\t\t\t\ts_routing, input, output, 0);\n\t\t\tif (ret) {\n\t\t\t\tvpfe_err(vpfe, \"s_routing failed\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto get_out;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tvpfe->current_subdev = sdinfo;\n\tif (sdinfo->sd)\n\t\tvpfe->v4l2_dev.ctrl_handler = sdinfo->sd->ctrl_handler;\n\tvpfe->current_input = index;\n\tvpfe->std_index = 0;\n\n\t \n\tret = vpfe_ccdc_set_hw_if_params(&vpfe->ccdc, &sdinfo->vpfe_param);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn vpfe_config_image_format(vpfe,\n\t\t\t\t\tvpfe_standards[vpfe->std_index].std_id);\n\nget_out:\n\treturn ret;\n}\n\nstatic int vpfe_s_input(struct file *file, void *priv, unsigned int index)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\n\treturn vpfe_set_input(vpfe, index);\n}\n\nstatic int vpfe_querystd(struct file *file, void *priv, v4l2_std_id *std_id)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\tstruct vpfe_subdev_info *sdinfo;\n\n\tsdinfo = vpfe->current_subdev;\n\tif (!(sdinfo->inputs[0].capabilities & V4L2_IN_CAP_STD))\n\t\treturn -ENODATA;\n\n\t \n\treturn v4l2_device_call_until_err(&vpfe->v4l2_dev, sdinfo->grp_id,\n\t\t\t\t\t video, querystd, std_id);\n}\n\nstatic int vpfe_s_std(struct file *file, void *priv, v4l2_std_id std_id)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\tstruct vpfe_subdev_info *sdinfo;\n\tint ret;\n\n\tsdinfo = vpfe->current_subdev;\n\tif (!(sdinfo->inputs[0].capabilities & V4L2_IN_CAP_STD))\n\t\treturn -ENODATA;\n\n\t \n\tif (vpfe_standards[vpfe->std_index].std_id == std_id)\n\t\treturn 0;\n\n\t \n\tif (vb2_is_busy(&vpfe->buffer_queue)) {\n\t\tvpfe_err(vpfe, \"%s device busy\\n\", __func__);\n\t\tret = -EBUSY;\n\t\treturn ret;\n\t}\n\n\tret = v4l2_device_call_until_err(&vpfe->v4l2_dev, sdinfo->grp_id,\n\t\t\t\t\t video, s_std, std_id);\n\tif (ret < 0) {\n\t\tvpfe_err(vpfe, \"Failed to set standard\\n\");\n\t\treturn ret;\n\t}\n\tret = vpfe_config_image_format(vpfe, std_id);\n\n\treturn ret;\n}\n\nstatic int vpfe_g_std(struct file *file, void *priv, v4l2_std_id *std_id)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\tstruct vpfe_subdev_info *sdinfo;\n\n\tsdinfo = vpfe->current_subdev;\n\tif (sdinfo->inputs[0].capabilities != V4L2_IN_CAP_STD)\n\t\treturn -ENODATA;\n\n\t*std_id = vpfe_standards[vpfe->std_index].std_id;\n\n\treturn 0;\n}\n\n \nstatic void vpfe_calculate_offsets(struct vpfe_device *vpfe)\n{\n\tstruct v4l2_rect image_win;\n\n\tvpfe_ccdc_get_image_window(&vpfe->ccdc, &image_win);\n\tvpfe->field_off = image_win.height * image_win.width;\n}\n\n \nstatic int vpfe_queue_setup(struct vb2_queue *vq,\n\t\t\t    unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t    unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct vpfe_device *vpfe = vb2_get_drv_priv(vq);\n\tunsigned size = vpfe->fmt.fmt.pix.sizeimage;\n\n\tif (vq->num_buffers + *nbuffers < 3)\n\t\t*nbuffers = 3 - vq->num_buffers;\n\n\tif (*nplanes) {\n\t\tif (sizes[0] < size)\n\t\t\treturn -EINVAL;\n\t\tsize = sizes[0];\n\t}\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\tvpfe_dbg(1, vpfe,\n\t\t\"nbuffers=%d, size=%u\\n\", *nbuffers, sizes[0]);\n\n\t \n\tvpfe_calculate_offsets(vpfe);\n\n\treturn 0;\n}\n\n \nstatic int vpfe_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vpfe_device *vpfe = vb2_get_drv_priv(vb->vb2_queue);\n\n\tvb2_set_plane_payload(vb, 0, vpfe->fmt.fmt.pix.sizeimage);\n\n\tif (vb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0))\n\t\treturn -EINVAL;\n\n\tvbuf->field = vpfe->fmt.fmt.pix.field;\n\n\treturn 0;\n}\n\n \nstatic void vpfe_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vpfe_device *vpfe = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vpfe_cap_buffer *buf = to_vpfe_buffer(vbuf);\n\tunsigned long flags = 0;\n\n\t \n\tspin_lock_irqsave(&vpfe->dma_queue_lock, flags);\n\tlist_add_tail(&buf->list, &vpfe->dma_queue);\n\tspin_unlock_irqrestore(&vpfe->dma_queue_lock, flags);\n}\n\nstatic void vpfe_return_all_buffers(struct vpfe_device *vpfe,\n\t\t\t\t    enum vb2_buffer_state state)\n{\n\tstruct vpfe_cap_buffer *buf, *node;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vpfe->dma_queue_lock, flags);\n\tlist_for_each_entry_safe(buf, node, &vpfe->dma_queue, list) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t\tlist_del(&buf->list);\n\t}\n\n\tif (vpfe->cur_frm)\n\t\tvb2_buffer_done(&vpfe->cur_frm->vb.vb2_buf, state);\n\n\tif (vpfe->next_frm && vpfe->next_frm != vpfe->cur_frm)\n\t\tvb2_buffer_done(&vpfe->next_frm->vb.vb2_buf, state);\n\n\tvpfe->cur_frm = NULL;\n\tvpfe->next_frm = NULL;\n\tspin_unlock_irqrestore(&vpfe->dma_queue_lock, flags);\n}\n\n \nstatic int vpfe_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct vpfe_device *vpfe = vb2_get_drv_priv(vq);\n\tstruct vpfe_subdev_info *sdinfo;\n\tunsigned long flags;\n\tunsigned long addr;\n\tint ret;\n\n\tspin_lock_irqsave(&vpfe->dma_queue_lock, flags);\n\n\tvpfe->field = 0;\n\tvpfe->sequence = 0;\n\n\tsdinfo = vpfe->current_subdev;\n\n\tvpfe_attach_irq(vpfe);\n\n\tvpfe->stopping = false;\n\tinit_completion(&vpfe->capture_stop);\n\n\tif (vpfe->ccdc.ccdc_cfg.if_type == VPFE_RAW_BAYER)\n\t\tvpfe_ccdc_config_raw(&vpfe->ccdc);\n\telse\n\t\tvpfe_ccdc_config_ycbcr(&vpfe->ccdc);\n\n\t \n\tvpfe->next_frm = list_entry(vpfe->dma_queue.next,\n\t\t\t\t    struct vpfe_cap_buffer, list);\n\tvpfe->cur_frm = vpfe->next_frm;\n\t \n\tlist_del(&vpfe->cur_frm->list);\n\tspin_unlock_irqrestore(&vpfe->dma_queue_lock, flags);\n\n\taddr = vb2_dma_contig_plane_dma_addr(&vpfe->cur_frm->vb.vb2_buf, 0);\n\n\tvpfe_set_sdr_addr(&vpfe->ccdc, (unsigned long)(addr));\n\n\tvpfe_pcr_enable(&vpfe->ccdc, 1);\n\n\tret = v4l2_subdev_call(sdinfo->sd, video, s_stream, 1);\n\tif (ret < 0) {\n\t\tvpfe_err(vpfe, \"Error in attaching interrupt handle\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tvpfe_return_all_buffers(vpfe, VB2_BUF_STATE_QUEUED);\n\tvpfe_pcr_enable(&vpfe->ccdc, 0);\n\treturn ret;\n}\n\n \nstatic void vpfe_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct vpfe_device *vpfe = vb2_get_drv_priv(vq);\n\tstruct vpfe_subdev_info *sdinfo;\n\tint ret;\n\n\tvpfe_pcr_enable(&vpfe->ccdc, 0);\n\n\t \n\tvpfe->stopping = true;\n\twait_for_completion_timeout(&vpfe->capture_stop,\n\t\t\t\t    msecs_to_jiffies(250));\n\n\tvpfe_detach_irq(vpfe);\n\n\tsdinfo = vpfe->current_subdev;\n\tret = v4l2_subdev_call(sdinfo->sd, video, s_stream, 0);\n\tif (ret && ret != -ENOIOCTLCMD && ret != -ENODEV)\n\t\tvpfe_dbg(1, vpfe, \"stream off failed in subdev\\n\");\n\n\t \n\tvpfe_return_all_buffers(vpfe, VB2_BUF_STATE_ERROR);\n}\n\nstatic int vpfe_g_pixelaspect(struct file *file, void *priv,\n\t\t\t      int type, struct v4l2_fract *f)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\n\t    vpfe->std_index >= ARRAY_SIZE(vpfe_standards))\n\t\treturn -EINVAL;\n\n\t*f = vpfe_standards[vpfe->std_index].pixelaspect;\n\n\treturn 0;\n}\n\nstatic int\nvpfe_g_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\n\t    vpfe->std_index >= ARRAY_SIZE(vpfe_standards))\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = vpfe_standards[vpfe->std_index].width;\n\t\ts->r.height = vpfe_standards[vpfe->std_index].height;\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_CROP:\n\t\ts->r = vpfe->crop;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvpfe_s_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\tstruct v4l2_rect cr = vpfe->crop;\n\tstruct v4l2_rect r = s->r;\n\tu32 bpp;\n\n\t \n\tif (vb2_is_busy(&vpfe->buffer_queue)) {\n\t\tvpfe_err(vpfe, \"%s device busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\n\t\t\ts->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tv4l_bound_align_image(&r.width, 0, cr.width, 0,\n\t\t\t      &r.height, 0, cr.height, 0, 0);\n\n\tr.left = clamp_t(unsigned int, r.left, 0, cr.width - r.width);\n\tr.top  = clamp_t(unsigned int, r.top, 0, cr.height - r.height);\n\n\tif (s->flags & V4L2_SEL_FLAG_LE && !v4l2_rect_enclosed(&r, &s->r))\n\t\treturn -ERANGE;\n\n\tif (s->flags & V4L2_SEL_FLAG_GE && !v4l2_rect_enclosed(&s->r, &r))\n\t\treturn -ERANGE;\n\n\ts->r = vpfe->crop = r;\n\n\tbpp = __get_bytesperpixel(vpfe, vpfe->current_vpfe_fmt);\n\tvpfe_ccdc_set_image_window(&vpfe->ccdc, &r, bpp);\n\tvpfe->fmt.fmt.pix.width = r.width;\n\tvpfe->fmt.fmt.pix.height = r.height;\n\tvpfe->fmt.fmt.pix.bytesperline =\n\t\tvpfe_ccdc_get_line_length(&vpfe->ccdc);\n\tvpfe->fmt.fmt.pix.sizeimage = vpfe->fmt.fmt.pix.bytesperline *\n\t\t\t\t\t\tvpfe->fmt.fmt.pix.height;\n\n\tvpfe_dbg(1, vpfe, \"cropped (%d,%d)/%dx%d of %dx%d\\n\",\n\t\t r.left, r.top, r.width, r.height, cr.width, cr.height);\n\n\treturn 0;\n}\n\nstatic long vpfe_ioctl_default(struct file *file, void *priv,\n\t\t\t       bool valid_prio, unsigned int cmd, void *param)\n{\n\tstruct vpfe_device *vpfe = video_drvdata(file);\n\tint ret;\n\n\tif (!valid_prio) {\n\t\tvpfe_err(vpfe, \"%s device busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (vb2_is_busy(&vpfe->buffer_queue)) {\n\t\tvpfe_err(vpfe, \"%s device busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (cmd) {\n\tcase VIDIOC_AM437X_CCDC_CFG:\n\t\tret = vpfe_ccdc_set_params(&vpfe->ccdc, (void __user *)param);\n\t\tif (ret) {\n\t\t\tvpfe_dbg(2, vpfe,\n\t\t\t\t\"Error setting parameters in CCDC\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tret = vpfe_get_ccdc_image_format(vpfe,\n\t\t\t\t\t\t &vpfe->fmt);\n\t\tif (ret < 0) {\n\t\t\tvpfe_dbg(2, vpfe,\n\t\t\t\t\"Invalid image format at CCDC\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct vb2_ops vpfe_video_qops = {\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.queue_setup\t\t= vpfe_queue_setup,\n\t.buf_prepare\t\t= vpfe_buffer_prepare,\n\t.buf_queue\t\t= vpfe_buffer_queue,\n\t.start_streaming\t= vpfe_start_streaming,\n\t.stop_streaming\t\t= vpfe_stop_streaming,\n};\n\n \nstatic const struct v4l2_file_operations vpfe_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= vpfe_open,\n\t.release\t= vpfe_release,\n\t.read\t\t= vb2_fop_read,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= vb2_fop_mmap,\n};\n\n \nstatic const struct v4l2_ioctl_ops vpfe_ioctl_ops = {\n\t.vidioc_querycap\t\t= vpfe_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= vpfe_enum_fmt,\n\t.vidioc_g_fmt_vid_cap\t\t= vpfe_g_fmt,\n\t.vidioc_s_fmt_vid_cap\t\t= vpfe_s_fmt,\n\t.vidioc_try_fmt_vid_cap\t\t= vpfe_try_fmt,\n\n\t.vidioc_enum_framesizes\t\t= vpfe_enum_size,\n\n\t.vidioc_enum_input\t\t= vpfe_enum_input,\n\t.vidioc_g_input\t\t\t= vpfe_g_input,\n\t.vidioc_s_input\t\t\t= vpfe_s_input,\n\n\t.vidioc_querystd\t\t= vpfe_querystd,\n\t.vidioc_s_std\t\t\t= vpfe_s_std,\n\t.vidioc_g_std\t\t\t= vpfe_g_std,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\n\t.vidioc_log_status\t\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n\n\t.vidioc_g_pixelaspect\t\t= vpfe_g_pixelaspect,\n\t.vidioc_g_selection\t\t= vpfe_g_selection,\n\t.vidioc_s_selection\t\t= vpfe_s_selection,\n\n\t.vidioc_default\t\t\t= vpfe_ioctl_default,\n};\n\nstatic int\nvpfe_async_bound(struct v4l2_async_notifier *notifier,\n\t\t struct v4l2_subdev *subdev,\n\t\t struct v4l2_async_connection *asd)\n{\n\tstruct vpfe_device *vpfe = container_of(notifier->v4l2_dev,\n\t\t\t\t\t       struct vpfe_device, v4l2_dev);\n\tstruct vpfe_subdev_info *sdinfo;\n\tstruct vpfe_fmt *fmt;\n\tint ret = 0;\n\tbool found = false;\n\tint i, j, k;\n\n\tfor (i = 0; i < ARRAY_SIZE(vpfe->cfg->asd); i++) {\n\t\tif (vpfe->cfg->asd[i]->match.fwnode ==\n\t\t    asd[i].match.fwnode) {\n\t\t\tsdinfo = &vpfe->cfg->sub_devs[i];\n\t\t\tvpfe->sd[i] = subdev;\n\t\t\tvpfe->sd[i]->grp_id = sdinfo->grp_id;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tvpfe_info(vpfe, \"sub device (%s) not matched\\n\", subdev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tvpfe->video_dev.tvnorms |= sdinfo->inputs[0].std;\n\n\tvpfe->num_active_fmt = 0;\n\tfor (j = 0, i = 0; (ret != -EINVAL); ++j) {\n\t\tstruct v4l2_subdev_mbus_code_enum mbus_code = {\n\t\t\t.index = j,\n\t\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t};\n\n\t\tret = v4l2_subdev_call(subdev, pad, enum_mbus_code,\n\t\t\t\t       NULL, &mbus_code);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tvpfe_dbg(3, vpfe,\n\t\t\t \"subdev %s: code: %04x idx: %d\\n\",\n\t\t\t subdev->name, mbus_code.code, j);\n\n\t\tfor (k = 0; k < ARRAY_SIZE(formats); k++) {\n\t\t\tfmt = &formats[k];\n\t\t\tif (mbus_code.code != fmt->code)\n\t\t\t\tcontinue;\n\t\t\tvpfe->active_fmt[i] = fmt;\n\t\t\tvpfe_dbg(3, vpfe,\n\t\t\t\t \"matched fourcc: %s code: %04x idx: %d\\n\",\n\t\t\t\t print_fourcc(fmt->fourcc), mbus_code.code, i);\n\t\t\tvpfe->num_active_fmt = ++i;\n\t\t}\n\t}\n\n\tif (!i) {\n\t\tvpfe_err(vpfe, \"No suitable format reported by subdev %s\\n\",\n\t\t\t subdev->name);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vpfe_probe_complete(struct vpfe_device *vpfe)\n{\n\tstruct video_device *vdev;\n\tstruct vb2_queue *q;\n\tint err;\n\n\tspin_lock_init(&vpfe->dma_queue_lock);\n\tmutex_init(&vpfe->lock);\n\n\tvpfe->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n\t \n\tvpfe->current_subdev = &vpfe->cfg->sub_devs[0];\n\tvpfe->v4l2_dev.ctrl_handler = vpfe->sd[0]->ctrl_handler;\n\n\terr = vpfe_set_input(vpfe, 0);\n\tif (err)\n\t\tgoto probe_out;\n\n\t \n\tq = &vpfe->buffer_queue;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;\n\tq->drv_priv = vpfe;\n\tq->ops = &vpfe_video_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->buf_struct_size = sizeof(struct vpfe_cap_buffer);\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &vpfe->lock;\n\tq->min_buffers_needed = 1;\n\tq->dev = vpfe->pdev;\n\n\terr = vb2_queue_init(q);\n\tif (err) {\n\t\tvpfe_err(vpfe, \"vb2_queue_init() failed\\n\");\n\t\tgoto probe_out;\n\t}\n\n\tINIT_LIST_HEAD(&vpfe->dma_queue);\n\n\tvdev = &vpfe->video_dev;\n\tstrscpy(vdev->name, VPFE_MODULE_NAME, sizeof(vdev->name));\n\tvdev->release = video_device_release_empty;\n\tvdev->fops = &vpfe_fops;\n\tvdev->ioctl_ops = &vpfe_ioctl_ops;\n\tvdev->v4l2_dev = &vpfe->v4l2_dev;\n\tvdev->vfl_dir = VFL_DIR_RX;\n\tvdev->queue = q;\n\tvdev->lock = &vpfe->lock;\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\n\t\t\t    V4L2_CAP_READWRITE;\n\tvideo_set_drvdata(vdev, vpfe);\n\terr = video_register_device(&vpfe->video_dev, VFL_TYPE_VIDEO, -1);\n\tif (err) {\n\t\tvpfe_err(vpfe,\n\t\t\t\"Unable to register video device.\\n\");\n\t\tgoto probe_out;\n\t}\n\n\treturn 0;\n\nprobe_out:\n\tv4l2_device_unregister(&vpfe->v4l2_dev);\n\treturn err;\n}\n\nstatic int vpfe_async_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct vpfe_device *vpfe = container_of(notifier->v4l2_dev,\n\t\t\t\t\tstruct vpfe_device, v4l2_dev);\n\n\treturn vpfe_probe_complete(vpfe);\n}\n\nstatic const struct v4l2_async_notifier_operations vpfe_async_ops = {\n\t.bound = vpfe_async_bound,\n\t.complete = vpfe_async_complete,\n};\n\nstatic struct vpfe_config *\nvpfe_get_pdata(struct vpfe_device *vpfe)\n{\n\tstruct device_node *endpoint = NULL;\n\tstruct device *dev = vpfe->pdev;\n\tstruct vpfe_subdev_info *sdinfo;\n\tstruct vpfe_config *pdata;\n\tunsigned int flags;\n\tunsigned int i;\n\tint err;\n\n\tdev_dbg(dev, \"vpfe_get_pdata\\n\");\n\n\tv4l2_async_nf_init(&vpfe->notifier, &vpfe->v4l2_dev);\n\n\tif (!IS_ENABLED(CONFIG_OF) || !dev->of_node)\n\t\treturn dev->platform_data;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tfor (i = 0; ; i++) {\n\t\tstruct v4l2_fwnode_endpoint bus_cfg = { .bus_type = 0 };\n\t\tstruct device_node *rem;\n\n\t\tendpoint = of_graph_get_next_endpoint(dev->of_node, endpoint);\n\t\tif (!endpoint)\n\t\t\tbreak;\n\n\t\tsdinfo = &pdata->sub_devs[i];\n\t\tsdinfo->grp_id = 0;\n\n\t\t \n\t\tsdinfo->inputs[0].index = i;\n\t\tstrscpy(sdinfo->inputs[0].name, \"Camera\",\n\t\t\tsizeof(sdinfo->inputs[0].name));\n\t\tsdinfo->inputs[0].type = V4L2_INPUT_TYPE_CAMERA;\n\t\tsdinfo->inputs[0].std = V4L2_STD_ALL;\n\t\tsdinfo->inputs[0].capabilities = V4L2_IN_CAP_STD;\n\n\t\tsdinfo->can_route = 0;\n\t\tsdinfo->routes = NULL;\n\n\t\tof_property_read_u32(endpoint, \"ti,am437x-vpfe-interface\",\n\t\t\t\t     &sdinfo->vpfe_param.if_type);\n\t\tif (sdinfo->vpfe_param.if_type < 0 ||\n\t\t\tsdinfo->vpfe_param.if_type > 4) {\n\t\t\tsdinfo->vpfe_param.if_type = VPFE_RAW_BAYER;\n\t\t}\n\n\t\terr = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint),\n\t\t\t\t\t\t &bus_cfg);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Could not parse the endpoint\\n\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tsdinfo->vpfe_param.bus_width = bus_cfg.bus.parallel.bus_width;\n\n\t\tif (sdinfo->vpfe_param.bus_width < 8 ||\n\t\t\tsdinfo->vpfe_param.bus_width > 16) {\n\t\t\tdev_err(dev, \"Invalid bus width.\\n\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tflags = bus_cfg.bus.parallel.flags;\n\n\t\tif (flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\n\t\t\tsdinfo->vpfe_param.hdpol = 1;\n\n\t\tif (flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\n\t\t\tsdinfo->vpfe_param.vdpol = 1;\n\n\t\trem = of_graph_get_remote_port_parent(endpoint);\n\t\tif (!rem) {\n\t\t\tdev_err(dev, \"Remote device at %pOF not found\\n\",\n\t\t\t\tendpoint);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tpdata->asd[i] = v4l2_async_nf_add_fwnode(&vpfe->notifier,\n\t\t\t\t\t\t\t of_fwnode_handle(rem),\n\t\t\t\t\t\t\t struct v4l2_async_connection);\n\t\tof_node_put(rem);\n\t\tif (IS_ERR(pdata->asd[i]))\n\t\t\tgoto cleanup;\n\t}\n\n\tof_node_put(endpoint);\n\treturn pdata;\n\ncleanup:\n\tv4l2_async_nf_cleanup(&vpfe->notifier);\n\tof_node_put(endpoint);\n\treturn NULL;\n}\n\n \nstatic int vpfe_probe(struct platform_device *pdev)\n{\n\tstruct vpfe_config *vpfe_cfg;\n\tstruct vpfe_device *vpfe;\n\tstruct vpfe_ccdc *ccdc;\n\tint ret;\n\n\tvpfe = devm_kzalloc(&pdev->dev, sizeof(*vpfe), GFP_KERNEL);\n\tif (!vpfe)\n\t\treturn -ENOMEM;\n\n\tvpfe->pdev = &pdev->dev;\n\n\tret = v4l2_device_register(&pdev->dev, &vpfe->v4l2_dev);\n\tif (ret) {\n\t\tvpfe_err(vpfe, \"Unable to register v4l2 device.\\n\");\n\t\treturn ret;\n\t}\n\n\tvpfe_cfg = vpfe_get_pdata(vpfe);\n\tif (!vpfe_cfg) {\n\t\tdev_err(&pdev->dev, \"No platform data\\n\");\n\t\tret = -EINVAL;\n\t\tgoto probe_out_cleanup;\n\t}\n\n\tvpfe->cfg = vpfe_cfg;\n\tccdc = &vpfe->ccdc;\n\n\tccdc->ccdc_cfg.base_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ccdc->ccdc_cfg.base_addr)) {\n\t\tret = PTR_ERR(ccdc->ccdc_cfg.base_addr);\n\t\tgoto probe_out_cleanup;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto probe_out_cleanup;\n\tvpfe->irq = ret;\n\n\tret = devm_request_irq(vpfe->pdev, vpfe->irq, vpfe_isr, 0,\n\t\t\t       \"vpfe_capture0\", vpfe);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to request interrupt\\n\");\n\t\tret = -EINVAL;\n\t\tgoto probe_out_cleanup;\n\t}\n\n\t \n\tplatform_set_drvdata(pdev, vpfe);\n\t \n\tpm_runtime_enable(&pdev->dev);\n\n\t \n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0) {\n\t\tvpfe_err(vpfe, \"Unable to resume device.\\n\");\n\t\tgoto probe_out_cleanup;\n\t}\n\n\tvpfe_ccdc_config_defaults(ccdc);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\n\tvpfe->sd = devm_kcalloc(&pdev->dev,\n\t\t\t\tARRAY_SIZE(vpfe->cfg->asd),\n\t\t\t\tsizeof(struct v4l2_subdev *),\n\t\t\t\tGFP_KERNEL);\n\tif (!vpfe->sd) {\n\t\tret = -ENOMEM;\n\t\tgoto probe_out_cleanup;\n\t}\n\n\tvpfe->notifier.ops = &vpfe_async_ops;\n\tret = v4l2_async_nf_register(&vpfe->notifier);\n\tif (ret) {\n\t\tvpfe_err(vpfe, \"Error registering async notifier\\n\");\n\t\tret = -EINVAL;\n\t\tgoto probe_out_cleanup;\n\t}\n\n\treturn 0;\n\nprobe_out_cleanup:\n\tv4l2_async_nf_cleanup(&vpfe->notifier);\n\tv4l2_device_unregister(&vpfe->v4l2_dev);\n\treturn ret;\n}\n\n \nstatic void vpfe_remove(struct platform_device *pdev)\n{\n\tstruct vpfe_device *vpfe = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tv4l2_async_nf_unregister(&vpfe->notifier);\n\tv4l2_async_nf_cleanup(&vpfe->notifier);\n\tvideo_unregister_device(&vpfe->video_dev);\n\tv4l2_device_unregister(&vpfe->v4l2_dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic void vpfe_save_context(struct vpfe_ccdc *ccdc)\n{\n\tccdc->ccdc_ctx[VPFE_PCR >> 2] = vpfe_reg_read(ccdc, VPFE_PCR);\n\tccdc->ccdc_ctx[VPFE_SYNMODE >> 2] = vpfe_reg_read(ccdc, VPFE_SYNMODE);\n\tccdc->ccdc_ctx[VPFE_SDOFST >> 2] = vpfe_reg_read(ccdc, VPFE_SDOFST);\n\tccdc->ccdc_ctx[VPFE_SDR_ADDR >> 2] = vpfe_reg_read(ccdc, VPFE_SDR_ADDR);\n\tccdc->ccdc_ctx[VPFE_CLAMP >> 2] = vpfe_reg_read(ccdc, VPFE_CLAMP);\n\tccdc->ccdc_ctx[VPFE_DCSUB >> 2] = vpfe_reg_read(ccdc, VPFE_DCSUB);\n\tccdc->ccdc_ctx[VPFE_COLPTN >> 2] = vpfe_reg_read(ccdc, VPFE_COLPTN);\n\tccdc->ccdc_ctx[VPFE_BLKCMP >> 2] = vpfe_reg_read(ccdc, VPFE_BLKCMP);\n\tccdc->ccdc_ctx[VPFE_VDINT >> 2] = vpfe_reg_read(ccdc, VPFE_VDINT);\n\tccdc->ccdc_ctx[VPFE_ALAW >> 2] = vpfe_reg_read(ccdc, VPFE_ALAW);\n\tccdc->ccdc_ctx[VPFE_REC656IF >> 2] = vpfe_reg_read(ccdc, VPFE_REC656IF);\n\tccdc->ccdc_ctx[VPFE_CCDCFG >> 2] = vpfe_reg_read(ccdc, VPFE_CCDCFG);\n\tccdc->ccdc_ctx[VPFE_CULLING >> 2] = vpfe_reg_read(ccdc, VPFE_CULLING);\n\tccdc->ccdc_ctx[VPFE_HD_VD_WID >> 2] = vpfe_reg_read(ccdc,\n\t\t\t\t\t\t\t    VPFE_HD_VD_WID);\n\tccdc->ccdc_ctx[VPFE_PIX_LINES >> 2] = vpfe_reg_read(ccdc,\n\t\t\t\t\t\t\t    VPFE_PIX_LINES);\n\tccdc->ccdc_ctx[VPFE_HORZ_INFO >> 2] = vpfe_reg_read(ccdc,\n\t\t\t\t\t\t\t    VPFE_HORZ_INFO);\n\tccdc->ccdc_ctx[VPFE_VERT_START >> 2] = vpfe_reg_read(ccdc,\n\t\t\t\t\t\t\t     VPFE_VERT_START);\n\tccdc->ccdc_ctx[VPFE_VERT_LINES >> 2] = vpfe_reg_read(ccdc,\n\t\t\t\t\t\t\t     VPFE_VERT_LINES);\n\tccdc->ccdc_ctx[VPFE_HSIZE_OFF >> 2] = vpfe_reg_read(ccdc,\n\t\t\t\t\t\t\t    VPFE_HSIZE_OFF);\n}\n\nstatic int vpfe_suspend(struct device *dev)\n{\n\tstruct vpfe_device *vpfe = dev_get_drvdata(dev);\n\tstruct vpfe_ccdc *ccdc = &vpfe->ccdc;\n\n\t \n\tif (vb2_start_streaming_called(&vpfe->buffer_queue)) {\n\t\t \n\t\tpm_runtime_get_sync(dev);\n\t\tvpfe_config_enable(ccdc, 1);\n\n\t\t \n\t\tvpfe_save_context(ccdc);\n\n\t\t \n\t\tvpfe_pcr_enable(ccdc, 0);\n\t\tvpfe_config_enable(ccdc, 0);\n\n\t\t \n\t\tpm_runtime_put_sync(dev);\n\t}\n\n\t \n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic void vpfe_restore_context(struct vpfe_ccdc *ccdc)\n{\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_SYNMODE >> 2], VPFE_SYNMODE);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_CULLING >> 2], VPFE_CULLING);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_SDOFST >> 2], VPFE_SDOFST);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_SDR_ADDR >> 2], VPFE_SDR_ADDR);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_CLAMP >> 2], VPFE_CLAMP);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_DCSUB >> 2], VPFE_DCSUB);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_COLPTN >> 2], VPFE_COLPTN);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_BLKCMP >> 2], VPFE_BLKCMP);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_VDINT >> 2], VPFE_VDINT);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_ALAW >> 2], VPFE_ALAW);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_REC656IF >> 2], VPFE_REC656IF);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_CCDCFG >> 2], VPFE_CCDCFG);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_PCR >> 2], VPFE_PCR);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_HD_VD_WID >> 2],\n\t\t\t\t\t\tVPFE_HD_VD_WID);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_PIX_LINES >> 2],\n\t\t\t\t\t\tVPFE_PIX_LINES);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_HORZ_INFO >> 2],\n\t\t\t\t\t\tVPFE_HORZ_INFO);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_VERT_START >> 2],\n\t\t\t\t\t\tVPFE_VERT_START);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_VERT_LINES >> 2],\n\t\t\t\t\t\tVPFE_VERT_LINES);\n\tvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_HSIZE_OFF >> 2],\n\t\t\t\t\t\tVPFE_HSIZE_OFF);\n}\n\nstatic int vpfe_resume(struct device *dev)\n{\n\tstruct vpfe_device *vpfe = dev_get_drvdata(dev);\n\tstruct vpfe_ccdc *ccdc = &vpfe->ccdc;\n\n\t \n\tif (vb2_start_streaming_called(&vpfe->buffer_queue)) {\n\t\t \n\t\tpm_runtime_get_sync(dev);\n\t\tvpfe_config_enable(ccdc, 1);\n\n\t\t \n\t\tvpfe_restore_context(ccdc);\n\n\t\tvpfe_config_enable(ccdc, 0);\n\t\tpm_runtime_put_sync(dev);\n\t}\n\n\t \n\tpinctrl_pm_select_default_state(dev);\n\n\treturn 0;\n}\n\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(vpfe_pm_ops, vpfe_suspend, vpfe_resume);\n\nstatic const struct of_device_id vpfe_of_match[] = {\n\t{ .compatible = \"ti,am437x-vpfe\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, vpfe_of_match);\n\nstatic struct platform_driver vpfe_driver = {\n\t.probe\t\t= vpfe_probe,\n\t.remove_new\t= vpfe_remove,\n\t.driver = {\n\t\t.name\t= VPFE_MODULE_NAME,\n\t\t.pm\t= &vpfe_pm_ops,\n\t\t.of_match_table = vpfe_of_match,\n\t},\n};\n\nmodule_platform_driver(vpfe_driver);\n\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_DESCRIPTION(\"TI AM437x VPFE driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(VPFE_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}