{
  "module_name": "omap_vout.c",
  "hash_id": "08b003a4bc6d6b1517fe6699df832ee7f49dc4fec2ad5a4713b9a01e8ce8cc6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap/omap_vout.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/irq.h>\n#include <linux/videodev2.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n\n#include <video/omapvrfb.h>\n#include <video/omapfb_dss.h>\n\n#include \"omap_voutlib.h\"\n#include \"omap_voutdef.h\"\n#include \"omap_vout_vrfb.h\"\n\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_DESCRIPTION(\"OMAP Video for Linux Video out driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define VOUT_NAME\t\t\"omap_vout\"\n\nenum omap_vout_channels {\n\tOMAP_VIDEO1,\n\tOMAP_VIDEO2,\n};\n\n \nstatic bool vid1_static_vrfb_alloc;\nstatic bool vid2_static_vrfb_alloc;\nstatic bool debug;\n\n \nmodule_param(vid1_static_vrfb_alloc, bool, S_IRUGO);\nMODULE_PARM_DESC(vid1_static_vrfb_alloc,\n\t\"Static allocation of the VRFB buffer for video1 device\");\n\nmodule_param(vid2_static_vrfb_alloc, bool, S_IRUGO);\nMODULE_PARM_DESC(vid2_static_vrfb_alloc,\n\t\"Static allocation of the VRFB buffer for video2 device\");\n\nmodule_param(debug, bool, S_IRUGO);\nMODULE_PARM_DESC(debug, \"Debug level (0-1)\");\n\n \nstatic const struct v4l2_fmtdesc omap_formats[] = {\n\t{\n\t\t \n\t\t.pixelformat = V4L2_PIX_FMT_RGB565,\n\t},\n\t{\n\t\t \n\t\t.pixelformat = V4L2_PIX_FMT_RGB32,\n\t},\n\t{\n\t\t \n\t\t.pixelformat = V4L2_PIX_FMT_RGB24,\n\t},\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_YUYV,\n\t},\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_UYVY,\n\t},\n};\n\n#define NUM_OUTPUT_FORMATS (ARRAY_SIZE(omap_formats))\n\n \nstatic int omap_vout_try_format(struct v4l2_pix_format *pix)\n{\n\tint ifmt, bpp = 0;\n\n\tpix->height = clamp(pix->height, (u32)VID_MIN_HEIGHT,\n\t\t\t\t\t\t(u32)VID_MAX_HEIGHT);\n\tpix->width = clamp(pix->width, (u32)VID_MIN_WIDTH, (u32)VID_MAX_WIDTH);\n\n\tfor (ifmt = 0; ifmt < NUM_OUTPUT_FORMATS; ifmt++) {\n\t\tif (pix->pixelformat == omap_formats[ifmt].pixelformat)\n\t\t\tbreak;\n\t}\n\n\tif (ifmt == NUM_OUTPUT_FORMATS)\n\t\tifmt = 0;\n\n\tpix->pixelformat = omap_formats[ifmt].pixelformat;\n\tpix->field = V4L2_FIELD_NONE;\n\n\tswitch (pix->pixelformat) {\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_UYVY:\n\tdefault:\n\t\tpix->colorspace = V4L2_COLORSPACE_SRGB;\n\t\tbpp = YUYV_BPP;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565:\n\tcase V4L2_PIX_FMT_RGB565X:\n\t\tpix->colorspace = V4L2_COLORSPACE_SRGB;\n\t\tbpp = RGB565_BPP;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB24:\n\t\tpix->colorspace = V4L2_COLORSPACE_SRGB;\n\t\tbpp = RGB24_BPP;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB32:\n\tcase V4L2_PIX_FMT_BGR32:\n\t\tpix->colorspace = V4L2_COLORSPACE_SRGB;\n\t\tbpp = RGB32_BPP;\n\t\tbreak;\n\t}\n\tpix->bytesperline = pix->width * bpp;\n\tpix->sizeimage = pix->bytesperline * pix->height;\n\n\treturn bpp;\n}\n\n \nstatic int v4l2_rot_to_dss_rot(int v4l2_rotation,\n\t\t\tenum dss_rotation *rotation, bool mirror)\n{\n\tint ret = 0;\n\n\tswitch (v4l2_rotation) {\n\tcase 90:\n\t\t*rotation = dss_rotation_90_degree;\n\t\tbreak;\n\tcase 180:\n\t\t*rotation = dss_rotation_180_degree;\n\t\tbreak;\n\tcase 270:\n\t\t*rotation = dss_rotation_270_degree;\n\t\tbreak;\n\tcase 0:\n\t\t*rotation = dss_rotation_0_degree;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int omap_vout_calculate_offset(struct omap_vout_device *vout)\n{\n\tstruct omapvideo_info *ovid;\n\tstruct v4l2_rect *crop = &vout->crop;\n\tstruct v4l2_pix_format *pix = &vout->pix;\n\tint *cropped_offset = &vout->cropped_offset;\n\tint ps = 2, line_length = 0;\n\n\tovid = &vout->vid_info;\n\n\tif (ovid->rotation_type == VOUT_ROT_VRFB) {\n\t\tomap_vout_calculate_vrfb_offset(vout);\n\t} else {\n\t\tvout->line_length = line_length = pix->width;\n\n\t\tif (V4L2_PIX_FMT_YUYV == pix->pixelformat ||\n\t\t\tV4L2_PIX_FMT_UYVY == pix->pixelformat)\n\t\t\tps = 2;\n\t\telse if (V4L2_PIX_FMT_RGB32 == pix->pixelformat)\n\t\t\tps = 4;\n\t\telse if (V4L2_PIX_FMT_RGB24 == pix->pixelformat)\n\t\t\tps = 3;\n\n\t\tvout->ps = ps;\n\n\t\t*cropped_offset = (line_length * ps) *\n\t\t\tcrop->top + crop->left * ps;\n\t}\n\n\tv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev, \"%s Offset:%x\\n\",\n\t\t\t__func__, vout->cropped_offset);\n\n\treturn 0;\n}\n\n \nstatic int video_mode_to_dss_mode(struct omap_vout_device *vout)\n{\n\tstruct omap_overlay *ovl;\n\tstruct omapvideo_info *ovid;\n\tstruct v4l2_pix_format *pix = &vout->pix;\n\tenum omap_color_mode mode;\n\n\tovid = &vout->vid_info;\n\tovl = ovid->overlays[0];\n\n\tswitch (pix->pixelformat) {\n\tcase V4L2_PIX_FMT_YUYV:\n\t\tmode = OMAP_DSS_COLOR_YUV2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_UYVY:\n\t\tmode = OMAP_DSS_COLOR_UYVY;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565:\n\t\tmode = OMAP_DSS_COLOR_RGB16;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB24:\n\t\tmode = OMAP_DSS_COLOR_RGB24P;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB32:\n\t\tmode = (ovl->id == OMAP_DSS_VIDEO1) ?\n\t\t\tOMAP_DSS_COLOR_RGB24U : OMAP_DSS_COLOR_ARGB32;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\t\tmode = OMAP_DSS_COLOR_RGBX32;\n\t\tbreak;\n\tdefault:\n\t\tmode = -EINVAL;\n\t\tbreak;\n\t}\n\treturn mode;\n}\n\n \nstatic int omapvid_setup_overlay(struct omap_vout_device *vout,\n\t\tstruct omap_overlay *ovl, int posx, int posy, int outw,\n\t\tint outh, dma_addr_t addr)\n{\n\tint ret = 0;\n\tstruct omap_overlay_info info;\n\tint cropheight, cropwidth, pixwidth;\n\n\tif ((ovl->caps & OMAP_DSS_OVL_CAP_SCALE) == 0 &&\n\t\t\t(outw != vout->pix.width || outh != vout->pix.height)) {\n\t\tret = -EINVAL;\n\t\tgoto setup_ovl_err;\n\t}\n\n\tvout->dss_mode = video_mode_to_dss_mode(vout);\n\tif (vout->dss_mode == -EINVAL) {\n\t\tret = -EINVAL;\n\t\tgoto setup_ovl_err;\n\t}\n\n\t \n\tif (is_rotation_90_or_270(vout)) {\n\t\tcropheight = vout->crop.width;\n\t\tcropwidth = vout->crop.height;\n\t\tpixwidth = vout->pix.height;\n\t} else {\n\t\tcropheight = vout->crop.height;\n\t\tcropwidth = vout->crop.width;\n\t\tpixwidth = vout->pix.width;\n\t}\n\n\tovl->get_overlay_info(ovl, &info);\n\tinfo.paddr = addr;\n\tinfo.width = cropwidth;\n\tinfo.height = cropheight;\n\tinfo.color_mode = vout->dss_mode;\n\tinfo.mirror = vout->mirror;\n\tinfo.pos_x = posx;\n\tinfo.pos_y = posy;\n\tinfo.out_width = outw;\n\tinfo.out_height = outh;\n\tinfo.global_alpha = vout->win.global_alpha;\n\tif (!is_rotation_enabled(vout)) {\n\t\tinfo.rotation = 0;\n\t\tinfo.rotation_type = OMAP_DSS_ROT_DMA;\n\t\tinfo.screen_width = pixwidth;\n\t} else {\n\t\tinfo.rotation = vout->rotation;\n\t\tinfo.rotation_type = OMAP_DSS_ROT_VRFB;\n\t\tinfo.screen_width = 2048;\n\t}\n\n\tv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev,\n\t\t\"%s enable=%d addr=%pad width=%d\\n height=%d color_mode=%d\\n\"\n\t\t\"rotation=%d mirror=%d posx=%d posy=%d out_width = %d \\n\"\n\t\t\"out_height=%d rotation_type=%d screen_width=%d\\n\", __func__,\n\t\tovl->is_enabled(ovl), &info.paddr, info.width, info.height,\n\t\tinfo.color_mode, info.rotation, info.mirror, info.pos_x,\n\t\tinfo.pos_y, info.out_width, info.out_height, info.rotation_type,\n\t\tinfo.screen_width);\n\n\tret = ovl->set_overlay_info(ovl, &info);\n\tif (ret)\n\t\tgoto setup_ovl_err;\n\n\treturn 0;\n\nsetup_ovl_err:\n\tv4l2_warn(&vout->vid_dev->v4l2_dev, \"setup_overlay failed\\n\");\n\treturn ret;\n}\n\n \nstatic int omapvid_init(struct omap_vout_device *vout, dma_addr_t addr)\n{\n\tint ret = 0, i;\n\tstruct v4l2_window *win;\n\tstruct omap_overlay *ovl;\n\tint posx, posy, outw, outh;\n\tstruct omap_video_timings *timing;\n\tstruct omapvideo_info *ovid = &vout->vid_info;\n\n\twin = &vout->win;\n\tfor (i = 0; i < ovid->num_overlays; i++) {\n\t\tstruct omap_dss_device *dssdev;\n\n\t\tovl = ovid->overlays[i];\n\t\tdssdev = ovl->get_device(ovl);\n\n\t\tif (!dssdev)\n\t\t\treturn -EINVAL;\n\n\t\ttiming = &dssdev->panel.timings;\n\n\t\toutw = win->w.width;\n\t\touth = win->w.height;\n\t\tswitch (vout->rotation) {\n\t\tcase dss_rotation_90_degree:\n\t\t\t \n\t\t\tswap(outw, outh);\n\t\t\tposy = (timing->y_res - win->w.width) - win->w.left;\n\t\t\tposx = win->w.top;\n\t\t\tbreak;\n\n\t\tcase dss_rotation_180_degree:\n\t\t\tposx = (timing->x_res - win->w.width) - win->w.left;\n\t\t\tposy = (timing->y_res - win->w.height) - win->w.top;\n\t\t\tbreak;\n\n\t\tcase dss_rotation_270_degree:\n\t\t\tswap(outw, outh);\n\t\t\tposy = win->w.left;\n\t\t\tposx = (timing->x_res - win->w.height) - win->w.top;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tposx = win->w.left;\n\t\t\tposy = win->w.top;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = omapvid_setup_overlay(vout, ovl, posx, posy,\n\t\t\t\toutw, outh, addr);\n\t\tif (ret)\n\t\t\tgoto omapvid_init_err;\n\t}\n\treturn 0;\n\nomapvid_init_err:\n\tv4l2_warn(&vout->vid_dev->v4l2_dev, \"apply_changes failed\\n\");\n\treturn ret;\n}\n\n \nstatic int omapvid_apply_changes(struct omap_vout_device *vout)\n{\n\tint i;\n\tstruct omap_overlay *ovl;\n\tstruct omapvideo_info *ovid = &vout->vid_info;\n\n\tfor (i = 0; i < ovid->num_overlays; i++) {\n\t\tstruct omap_dss_device *dssdev;\n\n\t\tovl = ovid->overlays[i];\n\t\tdssdev = ovl->get_device(ovl);\n\t\tif (!dssdev)\n\t\t\treturn -EINVAL;\n\t\tovl->manager->apply(ovl->manager);\n\t}\n\n\treturn 0;\n}\n\nstatic int omapvid_handle_interlace_display(struct omap_vout_device *vout,\n\t\tunsigned int irqstatus, u64 ts)\n{\n\tu32 fid;\n\n\tif (vout->first_int) {\n\t\tvout->first_int = 0;\n\t\tgoto err;\n\t}\n\n\tif (irqstatus & DISPC_IRQ_EVSYNC_ODD)\n\t\tfid = 1;\n\telse if (irqstatus & DISPC_IRQ_EVSYNC_EVEN)\n\t\tfid = 0;\n\telse\n\t\tgoto err;\n\n\tvout->field_id ^= 1;\n\tif (fid != vout->field_id) {\n\t\tif (fid == 0)\n\t\t\tvout->field_id = fid;\n\t} else if (0 == fid) {\n\t\tif (vout->cur_frm == vout->next_frm)\n\t\t\tgoto err;\n\n\t\tvout->cur_frm->vbuf.vb2_buf.timestamp = ts;\n\t\tvout->cur_frm->vbuf.sequence = vout->sequence++;\n\t\tvb2_buffer_done(&vout->cur_frm->vbuf.vb2_buf, VB2_BUF_STATE_DONE);\n\t\tvout->cur_frm = vout->next_frm;\n\t} else {\n\t\tif (list_empty(&vout->dma_queue) ||\n\t\t\t\t(vout->cur_frm != vout->next_frm))\n\t\t\tgoto err;\n\t}\n\n\treturn vout->field_id;\nerr:\n\treturn 0;\n}\n\nstatic void omap_vout_isr(void *arg, unsigned int irqstatus)\n{\n\tint ret, fid, mgr_id;\n\tdma_addr_t addr;\n\tu32 irq;\n\tstruct omap_overlay *ovl;\n\tu64 ts;\n\tstruct omapvideo_info *ovid;\n\tstruct omap_dss_device *cur_display;\n\tstruct omap_vout_device *vout = (struct omap_vout_device *)arg;\n\n\tovid = &vout->vid_info;\n\tovl = ovid->overlays[0];\n\n\tmgr_id = ovl->manager->id;\n\n\t \n\tcur_display = ovl->get_device(ovl);\n\n\tif (!cur_display)\n\t\treturn;\n\n\tspin_lock(&vout->vbq_lock);\n\tts = ktime_get_ns();\n\n\tswitch (cur_display->type) {\n\tcase OMAP_DISPLAY_TYPE_DSI:\n\tcase OMAP_DISPLAY_TYPE_DPI:\n\tcase OMAP_DISPLAY_TYPE_DVI:\n\t\tif (mgr_id == OMAP_DSS_CHANNEL_LCD)\n\t\t\tirq = DISPC_IRQ_VSYNC;\n\t\telse if (mgr_id == OMAP_DSS_CHANNEL_LCD2)\n\t\t\tirq = DISPC_IRQ_VSYNC2;\n\t\telse\n\t\t\tgoto vout_isr_err;\n\n\t\tif (!(irqstatus & irq))\n\t\t\tgoto vout_isr_err;\n\t\tbreak;\n\tcase OMAP_DISPLAY_TYPE_VENC:\n\t\tfid = omapvid_handle_interlace_display(vout, irqstatus,\n\t\t\t\tts);\n\t\tif (!fid)\n\t\t\tgoto vout_isr_err;\n\t\tbreak;\n\tcase OMAP_DISPLAY_TYPE_HDMI:\n\t\tif (!(irqstatus & DISPC_IRQ_EVSYNC_EVEN))\n\t\t\tgoto vout_isr_err;\n\t\tbreak;\n\tdefault:\n\t\tgoto vout_isr_err;\n\t}\n\n\tif (!vout->first_int && (vout->cur_frm != vout->next_frm)) {\n\t\tvout->cur_frm->vbuf.vb2_buf.timestamp = ts;\n\t\tvout->cur_frm->vbuf.sequence = vout->sequence++;\n\t\tvb2_buffer_done(&vout->cur_frm->vbuf.vb2_buf, VB2_BUF_STATE_DONE);\n\t\tvout->cur_frm = vout->next_frm;\n\t}\n\n\tvout->first_int = 0;\n\tif (list_empty(&vout->dma_queue))\n\t\tgoto vout_isr_err;\n\n\tvout->next_frm = list_entry(vout->dma_queue.next,\n\t\t\tstruct omap_vout_buffer, queue);\n\tlist_del(&vout->next_frm->queue);\n\n\taddr = vout->queued_buf_addr[vout->next_frm->vbuf.vb2_buf.index]\n\t\t+ vout->cropped_offset;\n\n\t \n\tret = omapvid_init(vout, addr);\n\tif (ret) {\n\t\tprintk(KERN_ERR VOUT_NAME\n\t\t\t\"failed to set overlay info\\n\");\n\t\tgoto vout_isr_err;\n\t}\n\n\t \n\tret = omapvid_apply_changes(vout);\n\tif (ret)\n\t\tprintk(KERN_ERR VOUT_NAME \"failed to change mode\\n\");\n\nvout_isr_err:\n\tspin_unlock(&vout->vbq_lock);\n}\n\n\n \nstatic int vidioc_querycap(struct file *file, void *fh,\n\t\tstruct v4l2_capability *cap)\n{\n\tstruct omap_vout_device *vout = video_drvdata(file);\n\n\tstrscpy(cap->driver, VOUT_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, vout->vfd->name, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:%s.%d\", VOUT_NAME, vout->vid);\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *fh,\n\t\t\tstruct v4l2_fmtdesc *fmt)\n{\n\tint index = fmt->index;\n\n\tif (index >= NUM_OUTPUT_FORMATS)\n\t\treturn -EINVAL;\n\n\tfmt->flags = omap_formats[index].flags;\n\tfmt->pixelformat = omap_formats[index].pixelformat;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_out(struct file *file, void *fh,\n\t\t\tstruct v4l2_format *f)\n{\n\tstruct omap_vout_device *vout = video_drvdata(file);\n\n\tf->fmt.pix = vout->pix;\n\treturn 0;\n\n}\n\nstatic int vidioc_try_fmt_vid_out(struct file *file, void *fh,\n\t\t\tstruct v4l2_format *f)\n{\n\tstruct omap_overlay *ovl;\n\tstruct omapvideo_info *ovid;\n\tstruct omap_video_timings *timing;\n\tstruct omap_vout_device *vout = video_drvdata(file);\n\tstruct omap_dss_device *dssdev;\n\n\tovid = &vout->vid_info;\n\tovl = ovid->overlays[0];\n\t \n\tdssdev = ovl->get_device(ovl);\n\n\tif (!dssdev)\n\t\treturn -EINVAL;\n\n\ttiming = &dssdev->panel.timings;\n\n\tvout->fbuf.fmt.height = timing->y_res;\n\tvout->fbuf.fmt.width = timing->x_res;\n\n\tomap_vout_try_format(&f->fmt.pix);\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_out(struct file *file, void *fh,\n\t\t\tstruct v4l2_format *f)\n{\n\tint ret, bpp;\n\tstruct omap_overlay *ovl;\n\tstruct omapvideo_info *ovid;\n\tstruct omap_video_timings *timing;\n\tstruct omap_vout_device *vout = video_drvdata(file);\n\tstruct omap_dss_device *dssdev;\n\n\tif (vb2_is_busy(&vout->vq))\n\t\treturn -EBUSY;\n\n\tovid = &vout->vid_info;\n\tovl = ovid->overlays[0];\n\tdssdev = ovl->get_device(ovl);\n\n\t \n\tif (!dssdev) {\n\t\tret = -EINVAL;\n\t\tgoto s_fmt_vid_out_exit;\n\t}\n\ttiming = &dssdev->panel.timings;\n\n\t \n\tif ((is_rotation_enabled(vout)) &&\n\t\t\tf->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24) {\n\t\tret = -EINVAL;\n\t\tgoto s_fmt_vid_out_exit;\n\t}\n\n\t \n\n\tif (is_rotation_90_or_270(vout)) {\n\t\tvout->fbuf.fmt.height = timing->x_res;\n\t\tvout->fbuf.fmt.width = timing->y_res;\n\t} else {\n\t\tvout->fbuf.fmt.height = timing->y_res;\n\t\tvout->fbuf.fmt.width = timing->x_res;\n\t}\n\n\t \n\n\tbpp = omap_vout_try_format(&f->fmt.pix);\n\tf->fmt.pix.sizeimage = f->fmt.pix.width * f->fmt.pix.height * bpp;\n\n\t \n\tvout->bpp = bpp;\n\tvout->pix = f->fmt.pix;\n\tvout->vrfb_bpp = 1;\n\n\t \n\tif (V4L2_PIX_FMT_YUYV == vout->pix.pixelformat ||\n\t\t\tV4L2_PIX_FMT_UYVY == vout->pix.pixelformat)\n\t\tvout->vrfb_bpp = 2;\n\n\t \n\tomap_vout_new_format(&vout->pix, &vout->fbuf, &vout->crop, &vout->win);\n\n\tret = 0;\n\ns_fmt_vid_out_exit:\n\treturn ret;\n}\n\nstatic int vidioc_try_fmt_vid_overlay(struct file *file, void *fh,\n\t\t\tstruct v4l2_format *f)\n{\n\tint ret = 0;\n\tstruct omap_vout_device *vout = video_drvdata(file);\n\tstruct omap_overlay *ovl;\n\tstruct omapvideo_info *ovid;\n\tstruct v4l2_window *win = &f->fmt.win;\n\n\tovid = &vout->vid_info;\n\tovl = ovid->overlays[0];\n\n\tret = omap_vout_try_window(&vout->fbuf, win);\n\n\tif (!ret && !(ovl->caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA))\n\t\twin->global_alpha = 0;\n\n\treturn ret;\n}\n\nstatic int vidioc_s_fmt_vid_overlay(struct file *file, void *fh,\n\t\t\tstruct v4l2_format *f)\n{\n\tint ret = 0;\n\tstruct omap_overlay *ovl;\n\tstruct omapvideo_info *ovid;\n\tstruct omap_vout_device *vout = video_drvdata(file);\n\tstruct v4l2_window *win = &f->fmt.win;\n\n\tovid = &vout->vid_info;\n\tovl = ovid->overlays[0];\n\n\tret = omap_vout_new_window(&vout->crop, &vout->win, &vout->fbuf, win);\n\tif (!ret) {\n\t\tenum omap_dss_trans_key_type key_type =\n\t\t\tOMAP_DSS_COLOR_KEY_GFX_DST;\n\t\tint enable;\n\n\t\t \n\t\tif (ovl->caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA)\n\t\t\tvout->win.global_alpha = win->global_alpha;\n\t\telse\n\t\t\twin->global_alpha = 0;\n\t\tif (vout->fbuf.flags & (V4L2_FBUF_FLAG_CHROMAKEY |\n\t\t\t\t\tV4L2_FBUF_FLAG_SRC_CHROMAKEY))\n\t\t\tenable = 1;\n\t\telse\n\t\t\tenable = 0;\n\t\tif (vout->fbuf.flags & V4L2_FBUF_FLAG_SRC_CHROMAKEY)\n\t\t\tkey_type = OMAP_DSS_COLOR_KEY_VID_SRC;\n\n\t\tif (ovl->manager && ovl->manager->get_manager_info &&\n\t\t    ovl->manager->set_manager_info) {\n\t\t\tstruct omap_overlay_manager_info info;\n\n\t\t\tovl->manager->get_manager_info(ovl->manager, &info);\n\t\t\tinfo.trans_enabled = enable;\n\t\t\tinfo.trans_key_type = key_type;\n\t\t\tinfo.trans_key = vout->win.chromakey;\n\n\t\t\tif (ovl->manager->set_manager_info(ovl->manager, &info))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int vidioc_g_fmt_vid_overlay(struct file *file, void *fh,\n\t\t\tstruct v4l2_format *f)\n{\n\tstruct omap_overlay *ovl;\n\tstruct omapvideo_info *ovid;\n\tstruct omap_vout_device *vout = video_drvdata(file);\n\tstruct v4l2_window *win = &f->fmt.win;\n\n\tovid = &vout->vid_info;\n\tovl = ovid->overlays[0];\n\n\twin->w = vout->win.w;\n\twin->field = vout->win.field;\n\twin->chromakey = vout->win.chromakey;\n\tif (ovl->caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA)\n\t\twin->global_alpha = vout->win.global_alpha;\n\telse\n\t\twin->global_alpha = 0;\n\twin->clips = NULL;\n\twin->clipcount = 0;\n\twin->bitmap = NULL;\n\treturn 0;\n}\n\nstatic int vidioc_g_selection(struct file *file, void *fh, struct v4l2_selection *sel)\n{\n\tstruct omap_vout_device *vout = video_drvdata(file);\n\tstruct v4l2_pix_format *pix = &vout->pix;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = vout->crop;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tomap_vout_default_crop(&vout->pix, &vout->fbuf, &sel->r);\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\t \n\t\tsel->r.width = pix->width & ~1;\n\t\tsel->r.height = pix->height & ~1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_s_selection(struct file *file, void *fh, struct v4l2_selection *sel)\n{\n\tint ret = -EINVAL;\n\tstruct omap_vout_device *vout = video_drvdata(file);\n\tstruct omapvideo_info *ovid;\n\tstruct omap_overlay *ovl;\n\tstruct omap_video_timings *timing;\n\tstruct omap_dss_device *dssdev;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(&vout->vq))\n\t\treturn -EBUSY;\n\n\tovid = &vout->vid_info;\n\tovl = ovid->overlays[0];\n\t \n\tdssdev = ovl->get_device(ovl);\n\n\tif (!dssdev) {\n\t\tret = -EINVAL;\n\t\tgoto s_crop_err;\n\t}\n\n\ttiming = &dssdev->panel.timings;\n\n\tif (is_rotation_90_or_270(vout)) {\n\t\tvout->fbuf.fmt.height = timing->x_res;\n\t\tvout->fbuf.fmt.width = timing->y_res;\n\t} else {\n\t\tvout->fbuf.fmt.height = timing->y_res;\n\t\tvout->fbuf.fmt.width = timing->x_res;\n\t}\n\n\tret = omap_vout_new_crop(&vout->pix, &vout->crop, &vout->win,\n\t\t\t\t &vout->fbuf, &sel->r);\n\ns_crop_err:\n\treturn ret;\n}\n\nstatic int omap_vout_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct omap_vout_device *vout =\n\t\tcontainer_of(ctrl->handler, struct omap_vout_device, ctrl_handler);\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_ROTATE: {\n\t\tstruct omapvideo_info *ovid;\n\t\tint rotation = ctrl->val;\n\n\t\tovid = &vout->vid_info;\n\n\t\tif (rotation && ovid->rotation_type == VOUT_ROT_NONE) {\n\t\t\tret = -ERANGE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rotation && vout->pix.pixelformat == V4L2_PIX_FMT_RGB24) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (v4l2_rot_to_dss_rot(rotation, &vout->rotation,\n\t\t\t\t\t\t\tvout->mirror)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase V4L2_CID_BG_COLOR:\n\t{\n\t\tstruct omap_overlay *ovl;\n\t\tunsigned int color = ctrl->val;\n\t\tstruct omap_overlay_manager_info info;\n\n\t\tovl = vout->vid_info.overlays[0];\n\n\t\tif (!ovl->manager || !ovl->manager->get_manager_info) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tovl->manager->get_manager_info(ovl->manager, &info);\n\t\tinfo.default_color = color;\n\t\tif (ovl->manager->set_manager_info(ovl->manager, &info)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase V4L2_CID_VFLIP:\n\t{\n\t\tstruct omapvideo_info *ovid;\n\t\tunsigned int mirror = ctrl->val;\n\n\t\tovid = &vout->vid_info;\n\n\t\tif (mirror && ovid->rotation_type == VOUT_ROT_NONE) {\n\t\t\tret = -ERANGE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mirror  && vout->pix.pixelformat == V4L2_PIX_FMT_RGB24) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tvout->mirror = mirror;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops omap_vout_ctrl_ops = {\n\t.s_ctrl = omap_vout_s_ctrl,\n};\n\nstatic int omap_vout_vb2_queue_setup(struct vb2_queue *vq,\n\t\t\t\t     unsigned int *nbufs,\n\t\t\t\t     unsigned int *num_planes, unsigned int sizes[],\n\t\t\t\t     struct device *alloc_devs[])\n{\n\tstruct omap_vout_device *vout = vb2_get_drv_priv(vq);\n\tint size = vout->pix.sizeimage;\n\n\tif (is_rotation_enabled(vout) && vq->num_buffers + *nbufs > VRFB_NUM_BUFS) {\n\t\t*nbufs = VRFB_NUM_BUFS - vq->num_buffers;\n\t\tif (*nbufs == 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*num_planes = 1;\n\tsizes[0] = size;\n\treturn 0;\n}\n\nstatic int omap_vout_vb2_prepare(struct vb2_buffer *vb)\n{\n\tstruct omap_vout_device *vout = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct omapvideo_info *ovid = &vout->vid_info;\n\tstruct omap_vout_buffer *voutbuf = vb2_to_omap_vout_buffer(vb);\n\tdma_addr_t buf_phy_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\n\tif (vb2_plane_size(vb, 0) < vout->pix.sizeimage) {\n\t\tv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev,\n\t\t\t \"%s data will not fit into plane (%lu < %u)\\n\",\n\t\t\t__func__, vb2_plane_size(vb, 0), vout->pix.sizeimage);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, vout->pix.sizeimage);\n\tvoutbuf->vbuf.field = V4L2_FIELD_NONE;\n\n\tvout->queued_buf_addr[vb->index] = buf_phy_addr;\n\tif (ovid->rotation_type == VOUT_ROT_VRFB)\n\t\treturn omap_vout_prepare_vrfb(vout, vb);\n\treturn 0;\n}\n\nstatic void omap_vout_vb2_queue(struct vb2_buffer *vb)\n{\n\tstruct omap_vout_device *vout = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct omap_vout_buffer *voutbuf = vb2_to_omap_vout_buffer(vb);\n\n\tlist_add_tail(&voutbuf->queue, &vout->dma_queue);\n}\n\nstatic int omap_vout_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct omap_vout_device *vout = vb2_get_drv_priv(vq);\n\tstruct omapvideo_info *ovid = &vout->vid_info;\n\tstruct omap_vout_buffer *buf, *tmp;\n\tdma_addr_t addr = 0;\n\tu32 mask = 0;\n\tint ret, j;\n\n\t \n\tvout->next_frm = vout->cur_frm = list_entry(vout->dma_queue.next,\n\t\t\tstruct omap_vout_buffer, queue);\n\t \n\tlist_del(&vout->cur_frm->queue);\n\t \n\tvout->field_id = 0;\n\tvout->first_int = 1;\n\tvout->sequence = 0;\n\n\tif (omap_vout_calculate_offset(vout)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (ovid->rotation_type == VOUT_ROT_VRFB)\n\t\tif (omap_vout_vrfb_buffer_setup(vout, &count, 0)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\taddr = vout->queued_buf_addr[vout->cur_frm->vbuf.vb2_buf.index]\n\t\t+ vout->cropped_offset;\n\n\tmask = DISPC_IRQ_VSYNC | DISPC_IRQ_EVSYNC_EVEN | DISPC_IRQ_EVSYNC_ODD\n\t\t| DISPC_IRQ_VSYNC2;\n\n\t \n\tret = omapvid_init(vout, addr);\n\tif (ret) {\n\t\tv4l2_err(&vout->vid_dev->v4l2_dev,\n\t\t\t\t\"failed to set overlay info\\n\");\n\t\tgoto streamon_err1;\n\t}\n\n\tomap_dispc_register_isr(omap_vout_isr, vout, mask);\n\n\t \n\tret = omapvid_apply_changes(vout);\n\tif (ret)\n\t\tv4l2_err(&vout->vid_dev->v4l2_dev, \"failed to change mode\\n\");\n\n\tfor (j = 0; j < ovid->num_overlays; j++) {\n\t\tstruct omap_overlay *ovl = ovid->overlays[j];\n\t\tstruct omap_dss_device *dssdev = ovl->get_device(ovl);\n\n\t\tif (dssdev) {\n\t\t\tret = ovl->enable(ovl);\n\t\t\tif (ret)\n\t\t\t\tgoto streamon_err1;\n\t\t}\n\t}\n\treturn 0;\n\nstreamon_err1:\n\tmask = DISPC_IRQ_VSYNC | DISPC_IRQ_EVSYNC_EVEN | DISPC_IRQ_EVSYNC_ODD\n\t\t| DISPC_IRQ_VSYNC2;\n\n\tomap_dispc_unregister_isr(omap_vout_isr, vout, mask);\n\n\tfor (j = 0; j < ovid->num_overlays; j++) {\n\t\tstruct omap_overlay *ovl = ovid->overlays[j];\n\t\tstruct omap_dss_device *dssdev = ovl->get_device(ovl);\n\n\t\tif (dssdev)\n\t\t\tovl->disable(ovl);\n\t}\n\t \n\tif (omapvid_apply_changes(vout))\n\t\tv4l2_err(&vout->vid_dev->v4l2_dev,\n\t\t\t \"failed to change mode in streamoff\\n\");\n\nout:\n\tvb2_buffer_done(&vout->cur_frm->vbuf.vb2_buf, VB2_BUF_STATE_QUEUED);\n\tlist_for_each_entry_safe(buf, tmp, &vout->dma_queue, queue) {\n\t\tlist_del(&buf->queue);\n\t\tvb2_buffer_done(&buf->vbuf.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t}\n\treturn ret;\n}\n\nstatic void omap_vout_vb2_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct omap_vout_device *vout = vb2_get_drv_priv(vq);\n\tstruct omapvideo_info *ovid = &vout->vid_info;\n\tstruct omap_vout_buffer *buf, *tmp;\n\tu32 mask = 0;\n\tint j;\n\n\tmask = DISPC_IRQ_VSYNC | DISPC_IRQ_EVSYNC_EVEN | DISPC_IRQ_EVSYNC_ODD\n\t\t| DISPC_IRQ_VSYNC2;\n\n\tomap_dispc_unregister_isr(omap_vout_isr, vout, mask);\n\n\tfor (j = 0; j < ovid->num_overlays; j++) {\n\t\tstruct omap_overlay *ovl = ovid->overlays[j];\n\t\tstruct omap_dss_device *dssdev = ovl->get_device(ovl);\n\n\t\tif (dssdev)\n\t\t\tovl->disable(ovl);\n\t}\n\t \n\tif (omapvid_apply_changes(vout))\n\t\tv4l2_err(&vout->vid_dev->v4l2_dev,\n\t\t\t \"failed to change mode in streamoff\\n\");\n\n\tif (vout->next_frm != vout->cur_frm)\n\t\tvb2_buffer_done(&vout->next_frm->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);\n\tvb2_buffer_done(&vout->cur_frm->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);\n\tlist_for_each_entry_safe(buf, tmp, &vout->dma_queue, queue) {\n\t\tlist_del(&buf->queue);\n\t\tvb2_buffer_done(&buf->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic int vidioc_s_fbuf(struct file *file, void *fh,\n\t\t\t\tconst struct v4l2_framebuffer *a)\n{\n\tint enable = 0;\n\tstruct omap_overlay *ovl;\n\tstruct omapvideo_info *ovid;\n\tstruct omap_vout_device *vout = video_drvdata(file);\n\tstruct omap_overlay_manager_info info;\n\tenum omap_dss_trans_key_type key_type = OMAP_DSS_COLOR_KEY_GFX_DST;\n\n\tovid = &vout->vid_info;\n\tovl = ovid->overlays[0];\n\n\t \n\tif ((a->flags & V4L2_FBUF_FLAG_SRC_CHROMAKEY) &&\n\t\t\t(a->flags & V4L2_FBUF_FLAG_CHROMAKEY))\n\t\treturn -EINVAL;\n\t \n\tif ((a->flags & V4L2_FBUF_FLAG_CHROMAKEY) &&\n\t\t\t(a->flags & V4L2_FBUF_FLAG_LOCAL_ALPHA))\n\t\treturn -EINVAL;\n\n\tif ((a->flags & V4L2_FBUF_FLAG_SRC_CHROMAKEY)) {\n\t\tvout->fbuf.flags |= V4L2_FBUF_FLAG_SRC_CHROMAKEY;\n\t\tkey_type =  OMAP_DSS_COLOR_KEY_VID_SRC;\n\t} else\n\t\tvout->fbuf.flags &= ~V4L2_FBUF_FLAG_SRC_CHROMAKEY;\n\n\tif ((a->flags & V4L2_FBUF_FLAG_CHROMAKEY)) {\n\t\tvout->fbuf.flags |= V4L2_FBUF_FLAG_CHROMAKEY;\n\t\tkey_type =  OMAP_DSS_COLOR_KEY_GFX_DST;\n\t} else\n\t\tvout->fbuf.flags &=  ~V4L2_FBUF_FLAG_CHROMAKEY;\n\n\tif (a->flags & (V4L2_FBUF_FLAG_CHROMAKEY |\n\t\t\t\tV4L2_FBUF_FLAG_SRC_CHROMAKEY))\n\t\tenable = 1;\n\telse\n\t\tenable = 0;\n\tif (ovl->manager && ovl->manager->get_manager_info &&\n\t\t\tovl->manager->set_manager_info) {\n\n\t\tovl->manager->get_manager_info(ovl->manager, &info);\n\t\tinfo.trans_enabled = enable;\n\t\tinfo.trans_key_type = key_type;\n\t\tinfo.trans_key = vout->win.chromakey;\n\n\t\tif (ovl->manager->set_manager_info(ovl->manager, &info))\n\t\t\treturn -EINVAL;\n\t}\n\tif (a->flags & V4L2_FBUF_FLAG_LOCAL_ALPHA) {\n\t\tvout->fbuf.flags |= V4L2_FBUF_FLAG_LOCAL_ALPHA;\n\t\tenable = 1;\n\t} else {\n\t\tvout->fbuf.flags &= ~V4L2_FBUF_FLAG_LOCAL_ALPHA;\n\t\tenable = 0;\n\t}\n\tif (ovl->manager && ovl->manager->get_manager_info &&\n\t\t\tovl->manager->set_manager_info) {\n\t\tovl->manager->get_manager_info(ovl->manager, &info);\n\t\t \n\t\tif ((ovl->caps & OMAP_DSS_OVL_CAP_ZORDER) == 0)\n\t\t\tinfo.partial_alpha_enabled = enable;\n\t\tif (ovl->manager->set_manager_info(ovl->manager, &info))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fbuf(struct file *file, void *fh,\n\t\tstruct v4l2_framebuffer *a)\n{\n\tstruct omap_overlay *ovl;\n\tstruct omapvideo_info *ovid;\n\tstruct omap_vout_device *vout = video_drvdata(file);\n\tstruct omap_overlay_manager_info info;\n\tstruct omap_video_timings *timing;\n\tstruct omap_dss_device *dssdev;\n\n\tovid = &vout->vid_info;\n\tovl = ovid->overlays[0];\n\t \n\tdssdev = ovl->get_device(ovl);\n\n\tif (!dssdev)\n\t\treturn -EINVAL;\n\n\ttiming = &dssdev->panel.timings;\n\n\tvout->fbuf.fmt.height = timing->y_res;\n\tvout->fbuf.fmt.width = timing->x_res;\n\ta->fmt.field = V4L2_FIELD_NONE;\n\ta->fmt.colorspace = V4L2_COLORSPACE_SRGB;\n\ta->fmt.pixelformat = V4L2_PIX_FMT_RGBA32;\n\ta->fmt.height = vout->fbuf.fmt.height;\n\ta->fmt.width = vout->fbuf.fmt.width;\n\ta->fmt.bytesperline = vout->fbuf.fmt.width * 4;\n\ta->fmt.sizeimage = a->fmt.height * a->fmt.bytesperline;\n\ta->base = vout->fbuf.base;\n\n\ta->flags = vout->fbuf.flags;\n\ta->capability = vout->fbuf.capability;\n\ta->flags &= ~(V4L2_FBUF_FLAG_SRC_CHROMAKEY | V4L2_FBUF_FLAG_CHROMAKEY |\n\t\t      V4L2_FBUF_FLAG_LOCAL_ALPHA);\n\n\tif (ovl->manager && ovl->manager->get_manager_info) {\n\t\tovl->manager->get_manager_info(ovl->manager, &info);\n\t\tif (info.trans_key_type == OMAP_DSS_COLOR_KEY_VID_SRC)\n\t\t\ta->flags |= V4L2_FBUF_FLAG_SRC_CHROMAKEY;\n\t\tif (info.trans_key_type == OMAP_DSS_COLOR_KEY_GFX_DST)\n\t\t\ta->flags |= V4L2_FBUF_FLAG_CHROMAKEY;\n\t\tif (info.partial_alpha_enabled)\n\t\t\ta->flags |= V4L2_FBUF_FLAG_LOCAL_ALPHA;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_enum_output(struct file *file, void *priv_fh,\n\t\t\t      struct v4l2_output *out)\n{\n\tif (out->index)\n\t\treturn -EINVAL;\n\tsnprintf(out->name, sizeof(out->name), \"Overlay\");\n\tout->type = V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY;\n\treturn 0;\n}\n\nstatic int vidioc_g_output(struct file *file, void *priv_fh, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int vidioc_s_output(struct file *file, void *priv_fh, unsigned int i)\n{\n\treturn i ? -EINVAL : 0;\n}\n\nstatic const struct v4l2_ioctl_ops vout_ioctl_ops = {\n\t.vidioc_querycap\t\t\t= vidioc_querycap,\n\t.vidioc_enum_fmt_vid_out\t\t= vidioc_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out\t\t\t= vidioc_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t\t\t= vidioc_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t\t\t= vidioc_s_fmt_vid_out,\n\t.vidioc_s_fbuf\t\t\t\t= vidioc_s_fbuf,\n\t.vidioc_g_fbuf\t\t\t\t= vidioc_g_fbuf,\n\t.vidioc_try_fmt_vid_out_overlay\t\t= vidioc_try_fmt_vid_overlay,\n\t.vidioc_s_fmt_vid_out_overlay\t\t= vidioc_s_fmt_vid_overlay,\n\t.vidioc_g_fmt_vid_out_overlay\t\t= vidioc_g_fmt_vid_overlay,\n\t.vidioc_g_selection\t\t\t= vidioc_g_selection,\n\t.vidioc_s_selection\t\t\t= vidioc_s_selection,\n\t.vidioc_enum_output\t\t\t= vidioc_enum_output,\n\t.vidioc_g_output\t\t\t= vidioc_g_output,\n\t.vidioc_s_output\t\t\t= vidioc_s_output,\n\t.vidioc_reqbufs\t\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t\t= vb2_ioctl_streamoff,\n\t.vidioc_subscribe_event\t\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t\t= v4l2_event_unsubscribe,\n};\n\nstatic const struct v4l2_file_operations omap_vout_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.poll\t\t= vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.open\t\t= v4l2_fh_open,\n\t.release\t= vb2_fop_release,\n};\n\nstatic const struct vb2_ops omap_vout_vb2_ops = {\n\t.queue_setup\t\t= omap_vout_vb2_queue_setup,\n\t.buf_queue\t\t= omap_vout_vb2_queue,\n\t.buf_prepare\t\t= omap_vout_vb2_prepare,\n\t.start_streaming\t= omap_vout_vb2_start_streaming,\n\t.stop_streaming\t\t= omap_vout_vb2_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \n \nstatic int __init omap_vout_setup_video_data(struct omap_vout_device *vout)\n{\n\tstruct video_device *vfd;\n\tstruct v4l2_pix_format *pix;\n\tstruct omap_overlay *ovl = vout->vid_info.overlays[0];\n\tstruct omap_dss_device *display = ovl->get_device(ovl);\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\t \n\tpix = &vout->pix;\n\n\t \n\tpix->width = QQVGA_WIDTH;\n\tpix->height = QQVGA_HEIGHT;\n\n\t \n\tpix->pixelformat = V4L2_PIX_FMT_RGB565;\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->bytesperline = pix->width * 2;\n\tpix->sizeimage = pix->bytesperline * pix->height;\n\tpix->colorspace = V4L2_COLORSPACE_SRGB;\n\n\tvout->bpp = RGB565_BPP;\n\tvout->fbuf.fmt.width  =  display->panel.timings.x_res;\n\tvout->fbuf.fmt.height =  display->panel.timings.y_res;\n\tvout->cropped_offset = 0;\n\n\t \n\tvout->fbuf.flags = V4L2_FBUF_FLAG_OVERLAY;\n\tvout->fbuf.capability = V4L2_FBUF_CAP_LOCAL_ALPHA |\n\t\tV4L2_FBUF_CAP_SRC_CHROMAKEY | V4L2_FBUF_CAP_CHROMAKEY |\n\t\tV4L2_FBUF_CAP_EXTERNOVERLAY;\n\tif (ovl->caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA) {\n\t\tvout->win.global_alpha = 255;\n\t\tvout->fbuf.capability |= V4L2_FBUF_CAP_GLOBAL_ALPHA;\n\t\tvout->fbuf.flags |= V4L2_FBUF_FLAG_GLOBAL_ALPHA;\n\t} else {\n\t\tvout->win.global_alpha = 0;\n\t}\n\tvout->win.field = V4L2_FIELD_NONE;\n\n\tomap_vout_new_format(pix, &vout->fbuf, &vout->crop, &vout->win);\n\n\thdl = &vout->ctrl_handler;\n\tv4l2_ctrl_handler_init(hdl, 3);\n\tif (vout->vid_info.rotation_type == VOUT_ROT_VRFB) {\n\t\tv4l2_ctrl_new_std(hdl, &omap_vout_ctrl_ops,\n\t\t\t\t  V4L2_CID_ROTATE, 0, 270, 90, 0);\n\t\tv4l2_ctrl_new_std(hdl, &omap_vout_ctrl_ops,\n\t\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\t}\n\tv4l2_ctrl_new_std(hdl, &omap_vout_ctrl_ops,\n\t\t\t  V4L2_CID_BG_COLOR, 0, 0xffffff, 1, 0);\n\tif (hdl->error)\n\t\treturn hdl->error;\n\n\tvout->rotation = 0;\n\tvout->mirror = false;\n\tINIT_LIST_HEAD(&vout->dma_queue);\n\tif (vout->vid_info.rotation_type == VOUT_ROT_VRFB)\n\t\tvout->vrfb_bpp = 2;\n\n\t \n\tvfd = vout->vfd = video_device_alloc();\n\n\tif (!vfd) {\n\t\tprintk(KERN_ERR VOUT_NAME\n\t\t       \": could not allocate video device struct\\n\");\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\treturn -ENOMEM;\n\t}\n\tvfd->ctrl_handler = hdl;\n\tvfd->release = video_device_release;\n\tvfd->ioctl_ops = &vout_ioctl_ops;\n\n\tstrscpy(vfd->name, VOUT_NAME, sizeof(vfd->name));\n\n\tvfd->fops = &omap_vout_fops;\n\tvfd->v4l2_dev = &vout->vid_dev->v4l2_dev;\n\tvfd->vfl_dir = VFL_DIR_TX;\n\tvfd->minor = -1;\n\tvfd->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT |\n\t\t\t   V4L2_CAP_VIDEO_OUTPUT_OVERLAY;\n\tmutex_init(&vout->lock);\n\n\tvq = &vout->vq;\n\tvq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tvq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tvq->drv_priv = vout;\n\tvq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tvq->buf_struct_size = sizeof(struct omap_vout_buffer);\n\tvq->dev = vfd->v4l2_dev->dev;\n\n\tvq->ops = &omap_vout_vb2_ops;\n\tvq->mem_ops = &vb2_dma_contig_memops;\n\tvq->lock = &vout->lock;\n\tvq->min_buffers_needed = 1;\n\tvfd->queue = vq;\n\n\tret = vb2_queue_init(vq);\n\tif (ret) {\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tvideo_device_release(vfd);\n\t}\n\treturn ret;\n}\n\n \nstatic int __init omap_vout_setup_video_bufs(struct platform_device *pdev,\n\t\tint vid_num)\n{\n\tstruct omapvideo_info *ovid;\n\tstruct omap_vout_device *vout;\n\tstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\n\tstruct omap2video_device *vid_dev =\n\t\tcontainer_of(v4l2_dev, struct omap2video_device, v4l2_dev);\n\tint ret = 0;\n\n\tvout = vid_dev->vouts[vid_num];\n\tovid = &vout->vid_info;\n\n\tif (ovid->rotation_type == VOUT_ROT_VRFB) {\n\t\tbool static_vrfb_allocation = (vid_num == 0) ?\n\t\t\tvid1_static_vrfb_alloc : vid2_static_vrfb_alloc;\n\t\tret = omap_vout_setup_vrfb_bufs(pdev, vid_num,\n\t\t\t\tstatic_vrfb_allocation);\n\t}\n\treturn ret;\n}\n\n \nstatic int __init omap_vout_create_video_devices(struct platform_device *pdev)\n{\n\tint ret = 0, k;\n\tstruct omap_vout_device *vout;\n\tstruct video_device *vfd = NULL;\n\tstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\n\tstruct omap2video_device *vid_dev = container_of(v4l2_dev,\n\t\t\tstruct omap2video_device, v4l2_dev);\n\tstruct omap_overlay *ovl = vid_dev->overlays[0];\n\tstruct omap_overlay_info info;\n\n\tovl->get_overlay_info(ovl, &info);\n\n\tfor (k = 0; k < pdev->num_resources; k++) {\n\n\t\tvout = kzalloc(sizeof(struct omap_vout_device), GFP_KERNEL);\n\t\tif (!vout) {\n\t\t\tdev_err(&pdev->dev, \": could not allocate memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tvout->vid = k;\n\t\tvid_dev->vouts[k] = vout;\n\t\tvout->vid_dev = vid_dev;\n\t\t \n\t\tif (pdev->num_resources == 1)\n\t\t\tvout->vid_info.overlays[0] = vid_dev->overlays[k + 2];\n\t\telse\n\t\t\t \n\t\t\tvout->vid_info.overlays[0] = vid_dev->overlays[k + 1];\n\t\tvout->vid_info.num_overlays = 1;\n\t\tvout->vid_info.id = k + 1;\n\t\tspin_lock_init(&vout->vbq_lock);\n\t\t \n\t\tvout->fbuf.base = (void *)(uintptr_t)info.paddr;\n\n\t\t \n\t\tif (omap_vout_dss_omap24xx() || omap_vout_dss_omap34xx())\n\t\t\tvout->vid_info.rotation_type = VOUT_ROT_VRFB;\n\n\t\t \n\t\tif (omap_vout_setup_video_data(vout) != 0) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (omap_vout_setup_video_bufs(pdev, k) != 0) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error1;\n\t\t}\n\n\t\t \n\t\tvfd = vout->vfd;\n\t\tif (video_register_device(vfd, VFL_TYPE_VIDEO, -1) < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\": Could not register Video for Linux device\\n\");\n\t\t\tvfd->minor = -1;\n\t\t\tret = -ENODEV;\n\t\t\tgoto error2;\n\t\t}\n\t\tvideo_set_drvdata(vfd, vout);\n\n\t\tdev_info(&pdev->dev,\n\t\t\t \": registered and initialized video device %d\\n\",\n\t\t\t vfd->minor);\n\t\tif (k == (pdev->num_resources - 1))\n\t\t\treturn 0;\n\n\t\tcontinue;\nerror2:\n\t\tif (vout->vid_info.rotation_type == VOUT_ROT_VRFB)\n\t\t\tomap_vout_release_vrfb(vout);\nerror1:\n\t\tvideo_device_release(vfd);\nerror:\n\t\tkfree(vout);\n\t\treturn ret;\n\t}\n\n\treturn -ENODEV;\n}\n \nstatic void omap_vout_cleanup_device(struct omap_vout_device *vout)\n{\n\tstruct video_device *vfd;\n\tstruct omapvideo_info *ovid;\n\n\tif (!vout)\n\t\treturn;\n\n\tvfd = vout->vfd;\n\tovid = &vout->vid_info;\n\tif (vfd) {\n\t\tif (!video_is_registered(vfd)) {\n\t\t\t \n\t\t\tvideo_device_release(vfd);\n\t\t} else {\n\t\t\t \n\t\t\tvideo_unregister_device(vfd);\n\t\t}\n\t}\n\tv4l2_ctrl_handler_free(&vout->ctrl_handler);\n\tif (ovid->rotation_type == VOUT_ROT_VRFB) {\n\t\tomap_vout_release_vrfb(vout);\n\t\t \n\t\tif (vout->vrfb_static_allocation)\n\t\t\tomap_vout_free_vrfb_buffers(vout);\n\t}\n\n\tkfree(vout);\n}\n\nstatic void omap_vout_remove(struct platform_device *pdev)\n{\n\tint k;\n\tstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\n\tstruct omap2video_device *vid_dev = container_of(v4l2_dev, struct\n\t\t\tomap2video_device, v4l2_dev);\n\n\tv4l2_device_unregister(v4l2_dev);\n\tfor (k = 0; k < pdev->num_resources; k++)\n\t\tomap_vout_cleanup_device(vid_dev->vouts[k]);\n\n\tfor (k = 0; k < vid_dev->num_displays; k++) {\n\t\tif (vid_dev->displays[k]->state != OMAP_DSS_DISPLAY_DISABLED)\n\t\t\tvid_dev->displays[k]->driver->disable(vid_dev->displays[k]);\n\n\t\tomap_dss_put_device(vid_dev->displays[k]);\n\t}\n\tkfree(vid_dev);\n}\n\nstatic int __init omap_vout_probe(struct platform_device *pdev)\n{\n\tint ret = 0, i;\n\tstruct omap_overlay *ovl;\n\tstruct omap_dss_device *dssdev = NULL;\n\tstruct omap_dss_device *def_display;\n\tstruct omap2video_device *vid_dev = NULL;\n\n\tif (omapdss_is_initialized() == false)\n\t\treturn -EPROBE_DEFER;\n\n\tret = omapdss_compat_init();\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to init dss\\n\");\n\t\treturn ret;\n\t}\n\n\tif (pdev->num_resources == 0) {\n\t\tdev_err(&pdev->dev, \"probed for an unknown device\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_dss_init;\n\t}\n\n\tvid_dev = kzalloc(sizeof(struct omap2video_device), GFP_KERNEL);\n\tif (vid_dev == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dss_init;\n\t}\n\n\tvid_dev->num_displays = 0;\n\tfor_each_dss_dev(dssdev) {\n\t\tomap_dss_get_device(dssdev);\n\n\t\tif (!dssdev->driver) {\n\t\t\tdev_warn(&pdev->dev, \"no driver for display: %s\\n\",\n\t\t\t\t\tdssdev->name);\n\t\t\tomap_dss_put_device(dssdev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvid_dev->displays[vid_dev->num_displays++] = dssdev;\n\t}\n\n\tif (vid_dev->num_displays == 0) {\n\t\tdev_err(&pdev->dev, \"no displays\\n\");\n\t\tret = -EINVAL;\n\t\tgoto probe_err0;\n\t}\n\n\tvid_dev->num_overlays = omap_dss_get_num_overlays();\n\tfor (i = 0; i < vid_dev->num_overlays; i++)\n\t\tvid_dev->overlays[i] = omap_dss_get_overlay(i);\n\n\tvid_dev->num_managers = omap_dss_get_num_overlay_managers();\n\tfor (i = 0; i < vid_dev->num_managers; i++)\n\t\tvid_dev->managers[i] = omap_dss_get_overlay_manager(i);\n\n\t \n\tfor (i = 1; i < vid_dev->num_overlays; i++) {\n\t\tovl = omap_dss_get_overlay(i);\n\t\tdssdev = ovl->get_device(ovl);\n\n\t\tif (dssdev) {\n\t\t\tdef_display = dssdev;\n\t\t} else {\n\t\t\tdev_warn(&pdev->dev, \"cannot find display\\n\");\n\t\t\tdef_display = NULL;\n\t\t}\n\t\tif (def_display) {\n\t\t\tstruct omap_dss_driver *dssdrv = def_display->driver;\n\n\t\t\tret = dssdrv->enable(def_display);\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t\"'%s' Display already enabled\\n\",\n\t\t\t\t\tdef_display->name);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (v4l2_device_register(&pdev->dev, &vid_dev->v4l2_dev) < 0) {\n\t\tdev_err(&pdev->dev, \"v4l2_device_register failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto probe_err1;\n\t}\n\n\tret = omap_vout_create_video_devices(pdev);\n\tif (ret)\n\t\tgoto probe_err2;\n\n\tfor (i = 0; i < vid_dev->num_displays; i++) {\n\t\tstruct omap_dss_device *display = vid_dev->displays[i];\n\n\t\tif (display->driver->update)\n\t\t\tdisplay->driver->update(display, 0, 0,\n\t\t\t\t\tdisplay->panel.timings.x_res,\n\t\t\t\t\tdisplay->panel.timings.y_res);\n\t}\n\treturn 0;\n\nprobe_err2:\n\tv4l2_device_unregister(&vid_dev->v4l2_dev);\nprobe_err1:\n\tfor (i = 1; i < vid_dev->num_overlays; i++) {\n\t\tdef_display = NULL;\n\t\tovl = omap_dss_get_overlay(i);\n\t\tdssdev = ovl->get_device(ovl);\n\n\t\tif (dssdev)\n\t\t\tdef_display = dssdev;\n\n\t\tif (def_display && def_display->driver)\n\t\t\tdef_display->driver->disable(def_display);\n\t}\nprobe_err0:\n\tkfree(vid_dev);\nerr_dss_init:\n\tomapdss_compat_uninit();\n\treturn ret;\n}\n\nstatic struct platform_driver omap_vout_driver = {\n\t.driver = {\n\t\t.name = VOUT_NAME,\n\t},\n\t.remove_new = omap_vout_remove,\n};\n\nstatic int __init omap_vout_init(void)\n{\n\tif (platform_driver_probe(&omap_vout_driver, omap_vout_probe) != 0) {\n\t\tprintk(KERN_ERR VOUT_NAME \":Could not register Video driver\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void omap_vout_cleanup(void)\n{\n\tplatform_driver_unregister(&omap_vout_driver);\n}\n\nlate_initcall(omap_vout_init);\nmodule_exit(omap_vout_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}