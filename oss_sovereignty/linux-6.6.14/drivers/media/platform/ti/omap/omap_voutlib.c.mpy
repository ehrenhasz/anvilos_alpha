{
  "module_name": "omap_voutlib.c",
  "hash_id": "f4df758e34742647d27affe5ffac13ab184b8590838d825a91691d7a3ef586db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap/omap_voutlib.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n\n#include <linux/dma-mapping.h>\n\n#include <video/omapfb_dss.h>\n\n#include \"omap_voutlib.h\"\n\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_DESCRIPTION(\"OMAP Video library\");\nMODULE_LICENSE(\"GPL\");\n\n \nvoid omap_vout_default_crop(struct v4l2_pix_format *pix,\n\t\t  struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop)\n{\n\tcrop->width = (pix->width < fbuf->fmt.width) ?\n\t\tpix->width : fbuf->fmt.width;\n\tcrop->height = (pix->height < fbuf->fmt.height) ?\n\t\tpix->height : fbuf->fmt.height;\n\tcrop->width &= ~1;\n\tcrop->height &= ~1;\n\tcrop->left = ((pix->width - crop->width) >> 1) & ~1;\n\tcrop->top = ((pix->height - crop->height) >> 1) & ~1;\n}\nEXPORT_SYMBOL_GPL(omap_vout_default_crop);\n\n \nint omap_vout_try_window(struct v4l2_framebuffer *fbuf,\n\t\t\tstruct v4l2_window *new_win)\n{\n\tstruct v4l2_rect try_win;\n\n\t \n\ttry_win = new_win->w;\n\n\t \n\tif (try_win.left < 0) {\n\t\ttry_win.width += try_win.left;\n\t\ttry_win.left = 0;\n\t}\n\tif (try_win.top < 0) {\n\t\ttry_win.height += try_win.top;\n\t\ttry_win.top = 0;\n\t}\n\ttry_win.width = (try_win.width < fbuf->fmt.width) ?\n\t\ttry_win.width : fbuf->fmt.width;\n\ttry_win.height = (try_win.height < fbuf->fmt.height) ?\n\t\ttry_win.height : fbuf->fmt.height;\n\tif (try_win.left + try_win.width > fbuf->fmt.width)\n\t\ttry_win.width = fbuf->fmt.width - try_win.left;\n\tif (try_win.top + try_win.height > fbuf->fmt.height)\n\t\ttry_win.height = fbuf->fmt.height - try_win.top;\n\ttry_win.width &= ~1;\n\ttry_win.height &= ~1;\n\n\tif (try_win.width <= 0 || try_win.height <= 0)\n\t\treturn -EINVAL;\n\n\t \n\tnew_win->w = try_win;\n\tnew_win->field = V4L2_FIELD_NONE;\n\tnew_win->clips = NULL;\n\tnew_win->clipcount = 0;\n\tnew_win->bitmap = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(omap_vout_try_window);\n\n \nint omap_vout_new_window(struct v4l2_rect *crop,\n\t\tstruct v4l2_window *win, struct v4l2_framebuffer *fbuf,\n\t\tstruct v4l2_window *new_win)\n{\n\tint err;\n\n\terr = omap_vout_try_window(fbuf, new_win);\n\tif (err)\n\t\treturn err;\n\n\t \n\twin->w = new_win->w;\n\twin->field = new_win->field;\n\twin->chromakey = new_win->chromakey;\n\n\t \n\tif (omap_vout_dss_omap24xx()) {\n\t\t \n\t\tif ((crop->height/win->w.height) >= 2)\n\t\t\tcrop->height = win->w.height * 2;\n\n\t\tif ((crop->width/win->w.width) >= 2)\n\t\t\tcrop->width = win->w.width * 2;\n\n\t\tif (crop->width > 768) {\n\t\t\t \n\t\t\tif (crop->height != win->w.height)\n\t\t\t\tcrop->width = 768;\n\t\t}\n\t} else if (omap_vout_dss_omap34xx()) {\n\t\t \n\t\tif ((crop->height/win->w.height) >= 4)\n\t\t\tcrop->height = win->w.height * 4;\n\n\t\tif ((crop->width/win->w.width) >= 4)\n\t\t\tcrop->width = win->w.width * 4;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(omap_vout_new_window);\n\n \nint omap_vout_new_crop(struct v4l2_pix_format *pix,\n\t      struct v4l2_rect *crop, struct v4l2_window *win,\n\t      struct v4l2_framebuffer *fbuf, const struct v4l2_rect *new_crop)\n{\n\tstruct v4l2_rect try_crop;\n\tunsigned long vresize, hresize;\n\n\t \n\ttry_crop = *new_crop;\n\n\t \n\tif (try_crop.left < 0) {\n\t\ttry_crop.width += try_crop.left;\n\t\ttry_crop.left = 0;\n\t}\n\tif (try_crop.top < 0) {\n\t\ttry_crop.height += try_crop.top;\n\t\ttry_crop.top = 0;\n\t}\n\ttry_crop.width = (try_crop.width < pix->width) ?\n\t\ttry_crop.width : pix->width;\n\ttry_crop.height = (try_crop.height < pix->height) ?\n\t\ttry_crop.height : pix->height;\n\tif (try_crop.left + try_crop.width > pix->width)\n\t\ttry_crop.width = pix->width - try_crop.left;\n\tif (try_crop.top + try_crop.height > pix->height)\n\t\ttry_crop.height = pix->height - try_crop.top;\n\n\ttry_crop.width &= ~1;\n\ttry_crop.height &= ~1;\n\n\tif (try_crop.width <= 0 || try_crop.height <= 0)\n\t\treturn -EINVAL;\n\n\tif (omap_vout_dss_omap24xx()) {\n\t\tif (try_crop.height != win->w.height) {\n\t\t\t \n\t\t\tif (try_crop.width > 768)\n\t\t\t\ttry_crop.width = 768;\n\t\t}\n\t}\n\t \n\tvresize = (1024 * try_crop.height) / win->w.height;\n\tif (omap_vout_dss_omap24xx() && (vresize > 2048))\n\t\tvresize = 2048;\n\telse if (omap_vout_dss_omap34xx() && (vresize > 4096))\n\t\tvresize = 4096;\n\n\twin->w.height = ((1024 * try_crop.height) / vresize) & ~1;\n\tif (win->w.height == 0)\n\t\twin->w.height = 2;\n\tif (win->w.height + win->w.top > fbuf->fmt.height) {\n\t\t \n\t\twin->w.height = (fbuf->fmt.height - win->w.top) & ~1;\n\t\tif (try_crop.height == 0)\n\t\t\ttry_crop.height = 2;\n\t}\n\t \n\thresize = (1024 * try_crop.width) / win->w.width;\n\tif (omap_vout_dss_omap24xx() && (hresize > 2048))\n\t\thresize = 2048;\n\telse if (omap_vout_dss_omap34xx() && (hresize > 4096))\n\t\thresize = 4096;\n\n\twin->w.width = ((1024 * try_crop.width) / hresize) & ~1;\n\tif (win->w.width == 0)\n\t\twin->w.width = 2;\n\tif (win->w.width + win->w.left > fbuf->fmt.width) {\n\t\t \n\t\twin->w.width = (fbuf->fmt.width - win->w.left) & ~1;\n\t\tif (try_crop.width == 0)\n\t\t\ttry_crop.width = 2;\n\t}\n\tif (omap_vout_dss_omap24xx()) {\n\t\tif ((try_crop.height/win->w.height) >= 2)\n\t\t\ttry_crop.height = win->w.height * 2;\n\n\t\tif ((try_crop.width/win->w.width) >= 2)\n\t\t\ttry_crop.width = win->w.width * 2;\n\n\t\tif (try_crop.width > 768) {\n\t\t\t \n\t\t\tif (try_crop.height != win->w.height)\n\t\t\t\ttry_crop.width = 768;\n\t\t}\n\t} else if (omap_vout_dss_omap34xx()) {\n\t\tif ((try_crop.height/win->w.height) >= 4)\n\t\t\ttry_crop.height = win->w.height * 4;\n\n\t\tif ((try_crop.width/win->w.width) >= 4)\n\t\t\ttry_crop.width = win->w.width * 4;\n\t}\n\t \n\t*crop = try_crop;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(omap_vout_new_crop);\n\n \nvoid omap_vout_new_format(struct v4l2_pix_format *pix,\n\t\tstruct v4l2_framebuffer *fbuf, struct v4l2_rect *crop,\n\t\tstruct v4l2_window *win)\n{\n\t \n\tomap_vout_default_crop(pix, fbuf, crop);\n\n\t \n\twin->w.width = crop->width;\n\twin->w.height = crop->height;\n\twin->w.left = ((fbuf->fmt.width - win->w.width) >> 1) & ~1;\n\twin->w.top = ((fbuf->fmt.height - win->w.height) >> 1) & ~1;\n}\nEXPORT_SYMBOL_GPL(omap_vout_new_format);\n\n \nunsigned long omap_vout_alloc_buffer(u32 buf_size, u32 *phys_addr)\n{\n\tu32 order, size;\n\tunsigned long virt_addr, addr;\n\n\tsize = PAGE_ALIGN(buf_size);\n\torder = get_order(size);\n\tvirt_addr = __get_free_pages(GFP_KERNEL, order);\n\taddr = virt_addr;\n\n\tif (virt_addr) {\n\t\twhile (size > 0) {\n\t\t\tSetPageReserved(virt_to_page((void *)addr));\n\t\t\taddr += PAGE_SIZE;\n\t\t\tsize -= PAGE_SIZE;\n\t\t}\n\t}\n\t*phys_addr = (u32) virt_to_phys((void *) virt_addr);\n\treturn virt_addr;\n}\n\n \nvoid omap_vout_free_buffer(unsigned long virtaddr, u32 buf_size)\n{\n\tu32 order, size;\n\tunsigned long addr = virtaddr;\n\n\tsize = PAGE_ALIGN(buf_size);\n\torder = get_order(size);\n\n\twhile (size > 0) {\n\t\tClearPageReserved(virt_to_page((void *)addr));\n\t\taddr += PAGE_SIZE;\n\t\tsize -= PAGE_SIZE;\n\t}\n\tfree_pages((unsigned long) virtaddr, order);\n}\n\nbool omap_vout_dss_omap24xx(void)\n{\n\treturn omapdss_get_version() == OMAPDSS_VER_OMAP24xx;\n}\n\nbool omap_vout_dss_omap34xx(void)\n{\n\tswitch (omapdss_get_version()) {\n\tcase OMAPDSS_VER_OMAP34xx_ES1:\n\tcase OMAPDSS_VER_OMAP34xx_ES3:\n\tcase OMAPDSS_VER_OMAP3630:\n\tcase OMAPDSS_VER_AM35xx:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}