{
  "module_name": "omap_vout_vrfb.c",
  "hash_id": "aee8589629a24e6696bf7e992fa8c5f161b760481f52035a416db13115438504",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/ti/omap/omap_vout_vrfb.c",
  "human_readable_source": " \n\n#include <linux/sched.h>\n#include <linux/platform_device.h>\n#include <linux/videodev2.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-device.h>\n\n#include <video/omapvrfb.h>\n\n#include \"omap_voutdef.h\"\n#include \"omap_voutlib.h\"\n#include \"omap_vout_vrfb.h\"\n\n#define OMAP_DMA_NO_DEVICE\t0\n\n \nstatic int omap_vout_allocate_vrfb_buffers(struct omap_vout_device *vout,\n\t\tunsigned int *count, int startindex)\n{\n\tint i, j;\n\n\tfor (i = 0; i < *count; i++) {\n\t\tif (!vout->smsshado_virt_addr[i]) {\n\t\t\tvout->smsshado_virt_addr[i] =\n\t\t\t\tomap_vout_alloc_buffer(vout->smsshado_size,\n\t\t\t\t\t\t&vout->smsshado_phy_addr[i]);\n\t\t}\n\t\tif (!vout->smsshado_virt_addr[i] && startindex != -1) {\n\t\t\tif (vout->vq.memory == V4L2_MEMORY_MMAP && i >= startindex)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!vout->smsshado_virt_addr[i]) {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tomap_vout_free_buffer(\n\t\t\t\t\t\tvout->smsshado_virt_addr[j],\n\t\t\t\t\t\tvout->smsshado_size);\n\t\t\t\tvout->smsshado_virt_addr[j] = 0;\n\t\t\t\tvout->smsshado_phy_addr[j] = 0;\n\t\t\t}\n\t\t\t*count = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset((void *)(long)vout->smsshado_virt_addr[i], 0,\n\t\t       vout->smsshado_size);\n\t}\n\treturn 0;\n}\n\n \nstatic void omap_vout_vrfb_dma_tx_callback(void *data)\n{\n\tstruct vid_vrfb_dma *t = (struct vid_vrfb_dma *) data;\n\n\tt->tx_status = 1;\n\twake_up_interruptible(&t->wait);\n}\n\n \nvoid omap_vout_free_vrfb_buffers(struct omap_vout_device *vout)\n{\n\tint j;\n\n\tfor (j = 0; j < VRFB_NUM_BUFS; j++) {\n\t\tif (vout->smsshado_virt_addr[j]) {\n\t\t\tomap_vout_free_buffer(vout->smsshado_virt_addr[j],\n\t\t\t\t\t      vout->smsshado_size);\n\t\t\tvout->smsshado_virt_addr[j] = 0;\n\t\t\tvout->smsshado_phy_addr[j] = 0;\n\t\t}\n\t}\n}\n\nint omap_vout_setup_vrfb_bufs(struct platform_device *pdev, int vid_num,\n\t\t\t      bool static_vrfb_allocation)\n{\n\tint ret = 0, i, j;\n\tstruct omap_vout_device *vout;\n\tstruct video_device *vfd;\n\tdma_cap_mask_t mask;\n\tint image_width, image_height;\n\tint vrfb_num_bufs = VRFB_NUM_BUFS;\n\tstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\n\tstruct omap2video_device *vid_dev =\n\t\tcontainer_of(v4l2_dev, struct omap2video_device, v4l2_dev);\n\n\tvout = vid_dev->vouts[vid_num];\n\tvfd = vout->vfd;\n\n\tfor (i = 0; i < VRFB_NUM_BUFS; i++) {\n\t\tif (omap_vrfb_request_ctx(&vout->vrfb_context[i])) {\n\t\t\tdev_info(&pdev->dev, \": VRFB allocation failed\\n\");\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tomap_vrfb_release_ctx(&vout->vrfb_context[j]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\t \n\timage_width = VID_MAX_WIDTH / TILE_SIZE;\n\tif (VID_MAX_WIDTH % TILE_SIZE)\n\t\timage_width++;\n\n\timage_width = image_width * TILE_SIZE;\n\timage_height = VID_MAX_HEIGHT / TILE_SIZE;\n\n\tif (VID_MAX_HEIGHT % TILE_SIZE)\n\t\timage_height++;\n\n\timage_height = image_height * TILE_SIZE;\n\tvout->smsshado_size = PAGE_ALIGN(image_width * image_height * 2 * 2);\n\n\t \n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_INTERLEAVE, mask);\n\tvout->vrfb_dma_tx.chan = dma_request_chan_by_mask(&mask);\n\tif (IS_ERR(vout->vrfb_dma_tx.chan)) {\n\t\tvout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;\n\t} else {\n\t\tsize_t xt_size = sizeof(struct dma_interleaved_template) +\n\t\t\t\t sizeof(struct data_chunk);\n\n\t\tvout->vrfb_dma_tx.xt = kzalloc(xt_size, GFP_KERNEL);\n\t\tif (!vout->vrfb_dma_tx.xt) {\n\t\t\tdma_release_channel(vout->vrfb_dma_tx.chan);\n\t\t\tvout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;\n\t\t}\n\t}\n\n\tif (vout->vrfb_dma_tx.req_status == DMA_CHAN_NOT_ALLOTED)\n\t\tdev_info(&pdev->dev,\n\t\t\t \": failed to allocate DMA Channel for video%d\\n\",\n\t\t\t vfd->minor);\n\n\tinit_waitqueue_head(&vout->vrfb_dma_tx.wait);\n\n\t \n\tif (static_vrfb_allocation) {\n\t\tif (omap_vout_allocate_vrfb_buffers(vout, &vrfb_num_bufs, -1)) {\n\t\t\tret =  -ENOMEM;\n\t\t\tgoto release_vrfb_ctx;\n\t\t}\n\t\tvout->vrfb_static_allocation = true;\n\t}\n\treturn 0;\n\nrelease_vrfb_ctx:\n\tfor (j = 0; j < VRFB_NUM_BUFS; j++)\n\t\tomap_vrfb_release_ctx(&vout->vrfb_context[j]);\n\treturn ret;\n}\n\n \nvoid omap_vout_release_vrfb(struct omap_vout_device *vout)\n{\n\tint i;\n\n\tfor (i = 0; i < VRFB_NUM_BUFS; i++)\n\t\tomap_vrfb_release_ctx(&vout->vrfb_context[i]);\n\n\tif (vout->vrfb_dma_tx.req_status == DMA_CHAN_ALLOTED) {\n\t\tvout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;\n\t\tkfree(vout->vrfb_dma_tx.xt);\n\t\tdmaengine_terminate_sync(vout->vrfb_dma_tx.chan);\n\t\tdma_release_channel(vout->vrfb_dma_tx.chan);\n\t}\n}\n\n \nint omap_vout_vrfb_buffer_setup(struct omap_vout_device *vout,\n\t\t\t  unsigned int *count, unsigned int startindex)\n{\n\tint i;\n\tbool yuv_mode;\n\n\tif (!is_rotation_enabled(vout))\n\t\treturn 0;\n\n\t \n\t*count = *count > VRFB_NUM_BUFS ? VRFB_NUM_BUFS : *count;\n\n\t \n\tif (!vout->vrfb_static_allocation)\n\t\tif (omap_vout_allocate_vrfb_buffers(vout, count, startindex))\n\t\t\treturn -ENOMEM;\n\n\tif (vout->dss_mode == OMAP_DSS_COLOR_YUV2 ||\n\t\t\tvout->dss_mode == OMAP_DSS_COLOR_UYVY)\n\t\tyuv_mode = true;\n\telse\n\t\tyuv_mode = false;\n\n\tfor (i = 0; i < *count; i++)\n\t\tomap_vrfb_setup(&vout->vrfb_context[i],\n\t\t\t\tvout->smsshado_phy_addr[i], vout->pix.width,\n\t\t\t\tvout->pix.height, vout->bpp, yuv_mode);\n\n\treturn 0;\n}\n\nint omap_vout_prepare_vrfb(struct omap_vout_device *vout,\n\t\t\t   struct vb2_buffer *vb)\n{\n\tstruct dma_async_tx_descriptor *tx;\n\tenum dma_ctrl_flags flags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;\n\tstruct dma_chan *chan = vout->vrfb_dma_tx.chan;\n\tstruct dma_interleaved_template *xt = vout->vrfb_dma_tx.xt;\n\tdma_cookie_t cookie;\n\tdma_addr_t buf_phy_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\tenum dma_status status;\n\tenum dss_rotation rotation;\n\tsize_t dst_icg;\n\tu32 pixsize;\n\n\tif (!is_rotation_enabled(vout))\n\t\treturn 0;\n\n\t \n\n\tpixsize = vout->bpp * vout->vrfb_bpp;\n\tdst_icg = MAX_PIXELS_PER_LINE * pixsize - vout->pix.width * vout->bpp;\n\n\txt->src_start = buf_phy_addr;\n\txt->dst_start = vout->vrfb_context[vb->index].paddr[0];\n\n\txt->numf = vout->pix.height;\n\txt->frame_size = 1;\n\txt->sgl[0].size = vout->pix.width * vout->bpp;\n\txt->sgl[0].icg = dst_icg;\n\n\txt->dir = DMA_MEM_TO_MEM;\n\txt->src_sgl = false;\n\txt->src_inc = true;\n\txt->dst_sgl = true;\n\txt->dst_inc = true;\n\n\ttx = dmaengine_prep_interleaved_dma(chan, xt, flags);\n\tif (tx == NULL) {\n\t\tpr_err(\"%s: DMA interleaved prep error\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\ttx->callback = omap_vout_vrfb_dma_tx_callback;\n\ttx->callback_param = &vout->vrfb_dma_tx;\n\n\tcookie = dmaengine_submit(tx);\n\tif (dma_submit_error(cookie)) {\n\t\tpr_err(\"%s: dmaengine_submit failed (%d)\\n\", __func__, cookie);\n\t\treturn -EINVAL;\n\t}\n\n\tvout->vrfb_dma_tx.tx_status = 0;\n\tdma_async_issue_pending(chan);\n\n\twait_event_interruptible_timeout(vout->vrfb_dma_tx.wait,\n\t\t\t\t\t vout->vrfb_dma_tx.tx_status == 1,\n\t\t\t\t\t VRFB_TX_TIMEOUT);\n\n\tstatus = dma_async_is_tx_complete(chan, cookie, NULL, NULL);\n\n\tif (vout->vrfb_dma_tx.tx_status == 0) {\n\t\tpr_err(\"%s: Timeout while waiting for DMA\\n\", __func__);\n\t\tdmaengine_terminate_sync(chan);\n\t\treturn -EINVAL;\n\t} else if (status != DMA_COMPLETE) {\n\t\tpr_err(\"%s: DMA completion %s status\\n\", __func__,\n\t\t       status == DMA_ERROR ? \"error\" : \"busy\");\n\t\tdmaengine_terminate_sync(chan);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trotation = calc_rotation(vout);\n\tvout->queued_buf_addr[vb->index] =\n\t\tvout->vrfb_context[vb->index].paddr[rotation];\n\treturn 0;\n}\n\n \nvoid omap_vout_calculate_vrfb_offset(struct omap_vout_device *vout)\n{\n\tenum dss_rotation rotation;\n\tbool mirroring = vout->mirror;\n\tstruct v4l2_rect *crop = &vout->crop;\n\tstruct v4l2_pix_format *pix = &vout->pix;\n\tint *cropped_offset = &vout->cropped_offset;\n\tint vr_ps = 1, ps = 2, temp_ps = 2;\n\tint offset = 0, ctop = 0, cleft = 0, line_length = 0;\n\n\trotation = calc_rotation(vout);\n\n\tif (V4L2_PIX_FMT_YUYV == pix->pixelformat ||\n\t\t\tV4L2_PIX_FMT_UYVY == pix->pixelformat) {\n\t\tif (is_rotation_enabled(vout)) {\n\t\t\t \n\t\t\tps = 4;\n\t\t\tvr_ps = 2;\n\t\t} else {\n\t\t\tps = 2;\t \n\t\t}\n\t} else if (V4L2_PIX_FMT_RGB32 == pix->pixelformat) {\n\t\tps = 4;\n\t} else if (V4L2_PIX_FMT_RGB24 == pix->pixelformat) {\n\t\tps = 3;\n\t}\n\tvout->ps = ps;\n\tvout->vr_ps = vr_ps;\n\n\tif (is_rotation_enabled(vout)) {\n\t\tline_length = MAX_PIXELS_PER_LINE;\n\t\tctop = (pix->height - crop->height) - crop->top;\n\t\tcleft = (pix->width - crop->width) - crop->left;\n\t} else {\n\t\tline_length = pix->width;\n\t}\n\tvout->line_length = line_length;\n\tswitch (rotation) {\n\tcase dss_rotation_90_degree:\n\t\toffset = vout->vrfb_context[0].yoffset *\n\t\t\tvout->vrfb_context[0].bytespp;\n\t\ttemp_ps = ps / vr_ps;\n\t\tif (!mirroring) {\n\t\t\t*cropped_offset = offset + line_length *\n\t\t\t\ttemp_ps * cleft + crop->top * temp_ps;\n\t\t} else {\n\t\t\t*cropped_offset = offset + line_length * temp_ps *\n\t\t\t\tcleft + crop->top * temp_ps + (line_length *\n\t\t\t\t((crop->width / (vr_ps)) - 1) * ps);\n\t\t}\n\t\tbreak;\n\tcase dss_rotation_180_degree:\n\t\toffset = ((MAX_PIXELS_PER_LINE * vout->vrfb_context[0].yoffset *\n\t\t\tvout->vrfb_context[0].bytespp) +\n\t\t\t(vout->vrfb_context[0].xoffset *\n\t\t\tvout->vrfb_context[0].bytespp));\n\t\tif (!mirroring) {\n\t\t\t*cropped_offset = offset + (line_length * ps * ctop) +\n\t\t\t\t(cleft / vr_ps) * ps;\n\n\t\t} else {\n\t\t\t*cropped_offset = offset + (line_length * ps * ctop) +\n\t\t\t\t(cleft / vr_ps) * ps + (line_length *\n\t\t\t\t(crop->height - 1) * ps);\n\t\t}\n\t\tbreak;\n\tcase dss_rotation_270_degree:\n\t\toffset = MAX_PIXELS_PER_LINE * vout->vrfb_context[0].xoffset *\n\t\t\tvout->vrfb_context[0].bytespp;\n\t\ttemp_ps = ps / vr_ps;\n\t\tif (!mirroring) {\n\t\t\t*cropped_offset = offset + line_length *\n\t\t\t    temp_ps * crop->left + ctop * ps;\n\t\t} else {\n\t\t\t*cropped_offset = offset + line_length *\n\t\t\t\ttemp_ps * crop->left + ctop * ps +\n\t\t\t\t(line_length * ((crop->width / vr_ps) - 1) *\n\t\t\t\t ps);\n\t\t}\n\t\tbreak;\n\tcase dss_rotation_0_degree:\n\t\tif (!mirroring) {\n\t\t\t*cropped_offset = (line_length * ps) *\n\t\t\t\tcrop->top + (crop->left / vr_ps) * ps;\n\t\t} else {\n\t\t\t*cropped_offset = (line_length * ps) *\n\t\t\t\tcrop->top + (crop->left / vr_ps) * ps +\n\t\t\t\t(line_length * (crop->height - 1) * ps);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*cropped_offset = (line_length * ps * crop->top) /\n\t\t\tvr_ps + (crop->left * ps) / vr_ps +\n\t\t\t((crop->width / vr_ps) - 1) * ps;\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}