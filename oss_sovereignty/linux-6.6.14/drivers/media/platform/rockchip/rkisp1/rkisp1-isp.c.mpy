{
  "module_name": "rkisp1-isp.c",
  "hash_id": "cf11f4ad9ed7a431071494d67d19c4f93a6b85f791010eb018223cbf4483d028",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/rockchip/rkisp1/rkisp1-isp.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n#include <linux/pm_runtime.h>\n#include <linux/videodev2.h>\n#include <linux/vmalloc.h>\n\n#include <media/v4l2-event.h>\n\n#include \"rkisp1-common.h\"\n\n#define RKISP1_DEF_SINK_PAD_FMT MEDIA_BUS_FMT_SRGGB10_1X10\n#define RKISP1_DEF_SRC_PAD_FMT MEDIA_BUS_FMT_YUYV8_2X8\n\n#define RKISP1_ISP_DEV_NAME\tRKISP1_DRIVER_NAME \"_isp\"\n\n \n\n \n\n \n\nstatic struct v4l2_mbus_framefmt *\nrkisp1_isp_get_pad_fmt(struct rkisp1_isp *isp,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       unsigned int pad, u32 which)\n{\n\tstruct v4l2_subdev_state state = {\n\t\t.pads = isp->pad_cfg\n\t};\n\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&isp->sd, sd_state, pad);\n\telse\n\t\treturn v4l2_subdev_get_try_format(&isp->sd, &state, pad);\n}\n\nstatic struct v4l2_rect *\nrkisp1_isp_get_pad_crop(struct rkisp1_isp *isp,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tunsigned int pad, u32 which)\n{\n\tstruct v4l2_subdev_state state = {\n\t\t.pads = isp->pad_cfg\n\t};\n\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_crop(&isp->sd, sd_state, pad);\n\telse\n\t\treturn v4l2_subdev_get_try_crop(&isp->sd, &state, pad);\n}\n\n \n\n \nstatic void rkisp1_config_ism(struct rkisp1_isp *isp)\n{\n\tconst struct v4l2_rect *src_crop =\n\t\trkisp1_isp_get_pad_crop(isp, NULL,\n\t\t\t\t\tRKISP1_ISP_PAD_SOURCE_VIDEO,\n\t\t\t\t\tV4L2_SUBDEV_FORMAT_ACTIVE);\n\tstruct rkisp1_device *rkisp1 = isp->rkisp1;\n\tu32 val;\n\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_IS_RECENTER, 0);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_IS_MAX_DX, 0);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_IS_MAX_DY, 0);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_IS_DISPLACE, 0);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_IS_H_OFFS, src_crop->left);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_IS_V_OFFS, src_crop->top);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_IS_H_SIZE, src_crop->width);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_IS_V_SIZE, src_crop->height);\n\n\t \n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_IS_CTRL, 1);\n\tval = rkisp1_read(rkisp1, RKISP1_CIF_ISP_CTRL);\n\tval |= RKISP1_CIF_ISP_CTRL_ISP_CFG_UPD;\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_CTRL, val);\n}\n\n \nstatic int rkisp1_config_isp(struct rkisp1_isp *isp,\n\t\t\t     enum v4l2_mbus_type mbus_type, u32 mbus_flags)\n{\n\tstruct rkisp1_device *rkisp1 = isp->rkisp1;\n\tu32 isp_ctrl = 0, irq_mask = 0, acq_mult = 0, acq_prop = 0;\n\tconst struct rkisp1_mbus_info *sink_fmt = isp->sink_fmt;\n\tconst struct rkisp1_mbus_info *src_fmt = isp->src_fmt;\n\tconst struct v4l2_mbus_framefmt *sink_frm;\n\tconst struct v4l2_rect *sink_crop;\n\n\tsink_frm = rkisp1_isp_get_pad_fmt(isp, NULL,\n\t\t\t\t\t  RKISP1_ISP_PAD_SINK_VIDEO,\n\t\t\t\t\t  V4L2_SUBDEV_FORMAT_ACTIVE);\n\tsink_crop = rkisp1_isp_get_pad_crop(isp, NULL,\n\t\t\t\t\t    RKISP1_ISP_PAD_SINK_VIDEO,\n\t\t\t\t\t    V4L2_SUBDEV_FORMAT_ACTIVE);\n\n\tif (sink_fmt->pixel_enc == V4L2_PIXEL_ENC_BAYER) {\n\t\tacq_mult = 1;\n\t\tif (src_fmt->pixel_enc == V4L2_PIXEL_ENC_BAYER) {\n\t\t\tif (mbus_type == V4L2_MBUS_BT656)\n\t\t\t\tisp_ctrl = RKISP1_CIF_ISP_CTRL_ISP_MODE_RAW_PICT_ITU656;\n\t\t\telse\n\t\t\t\tisp_ctrl = RKISP1_CIF_ISP_CTRL_ISP_MODE_RAW_PICT;\n\t\t} else {\n\t\t\trkisp1_write(rkisp1, RKISP1_CIF_ISP_DEMOSAIC,\n\t\t\t\t     RKISP1_CIF_ISP_DEMOSAIC_TH(0xc));\n\n\t\t\tif (mbus_type == V4L2_MBUS_BT656)\n\t\t\t\tisp_ctrl = RKISP1_CIF_ISP_CTRL_ISP_MODE_BAYER_ITU656;\n\t\t\telse\n\t\t\t\tisp_ctrl = RKISP1_CIF_ISP_CTRL_ISP_MODE_BAYER_ITU601;\n\t\t}\n\t} else if (sink_fmt->pixel_enc == V4L2_PIXEL_ENC_YUV) {\n\t\tacq_mult = 2;\n\t\tif (mbus_type == V4L2_MBUS_CSI2_DPHY) {\n\t\t\tisp_ctrl = RKISP1_CIF_ISP_CTRL_ISP_MODE_ITU601;\n\t\t} else {\n\t\t\tif (mbus_type == V4L2_MBUS_BT656)\n\t\t\t\tisp_ctrl = RKISP1_CIF_ISP_CTRL_ISP_MODE_ITU656;\n\t\t\telse\n\t\t\t\tisp_ctrl = RKISP1_CIF_ISP_CTRL_ISP_MODE_ITU601;\n\t\t}\n\n\t\tirq_mask |= RKISP1_CIF_ISP_DATA_LOSS;\n\t}\n\n\t \n\tif (mbus_type == V4L2_MBUS_BT656 || mbus_type == V4L2_MBUS_PARALLEL) {\n\t\tif (mbus_flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\n\t\t\tacq_prop |= RKISP1_CIF_ISP_ACQ_PROP_POS_EDGE;\n\n\t\tswitch (sink_fmt->bus_width) {\n\t\tcase 8:\n\t\t\tacq_prop |= RKISP1_CIF_ISP_ACQ_PROP_IN_SEL_8B_ZERO;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tacq_prop |= RKISP1_CIF_ISP_ACQ_PROP_IN_SEL_10B_ZERO;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tacq_prop |= RKISP1_CIF_ISP_ACQ_PROP_IN_SEL_12B;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(rkisp1->dev, \"Invalid bus width %u\\n\",\n\t\t\t\tsink_fmt->bus_width);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (mbus_type == V4L2_MBUS_PARALLEL) {\n\t\tif (mbus_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\n\t\t\tacq_prop |= RKISP1_CIF_ISP_ACQ_PROP_VSYNC_LOW;\n\n\t\tif (mbus_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\n\t\t\tacq_prop |= RKISP1_CIF_ISP_ACQ_PROP_HSYNC_LOW;\n\t}\n\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_CTRL, isp_ctrl);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_ACQ_PROP,\n\t\t     acq_prop | sink_fmt->yuv_seq |\n\t\t     RKISP1_CIF_ISP_ACQ_PROP_BAYER_PAT(sink_fmt->bayer_pat) |\n\t\t     RKISP1_CIF_ISP_ACQ_PROP_FIELD_SEL_ALL);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_ACQ_NR_FRAMES, 0);\n\n\t \n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_ACQ_H_OFFS, 0);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_ACQ_V_OFFS, 0);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_ACQ_H_SIZE,\n\t\t     acq_mult * sink_frm->width);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_ACQ_V_SIZE, sink_frm->height);\n\n\t \n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_OUT_H_OFFS, sink_crop->left);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_OUT_V_OFFS, sink_crop->top);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_OUT_H_SIZE, sink_crop->width);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_OUT_V_SIZE, sink_crop->height);\n\n\tirq_mask |= RKISP1_CIF_ISP_FRAME | RKISP1_CIF_ISP_V_START |\n\t\t    RKISP1_CIF_ISP_PIC_SIZE_ERROR;\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_IMSC, irq_mask);\n\n\tif (src_fmt->pixel_enc == V4L2_PIXEL_ENC_BAYER) {\n\t\trkisp1_params_disable(&rkisp1->params);\n\t} else {\n\t\tstruct v4l2_mbus_framefmt *src_frm;\n\n\t\tsrc_frm = rkisp1_isp_get_pad_fmt(isp, NULL,\n\t\t\t\t\t\t RKISP1_ISP_PAD_SOURCE_VIDEO,\n\t\t\t\t\t\t V4L2_SUBDEV_FORMAT_ACTIVE);\n\t\trkisp1_params_pre_configure(&rkisp1->params, sink_fmt->bayer_pat,\n\t\t\t\t\t    src_frm->quantization,\n\t\t\t\t\t    src_frm->ycbcr_enc);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void rkisp1_config_path(struct rkisp1_isp *isp,\n\t\t\t       enum v4l2_mbus_type mbus_type)\n{\n\tstruct rkisp1_device *rkisp1 = isp->rkisp1;\n\tu32 dpcl = rkisp1_read(rkisp1, RKISP1_CIF_VI_DPCL);\n\n\tif (mbus_type == V4L2_MBUS_BT656 || mbus_type == V4L2_MBUS_PARALLEL)\n\t\tdpcl |= RKISP1_CIF_VI_DPCL_IF_SEL_PARALLEL;\n\telse if (mbus_type == V4L2_MBUS_CSI2_DPHY)\n\t\tdpcl |= RKISP1_CIF_VI_DPCL_IF_SEL_MIPI;\n\n\trkisp1_write(rkisp1, RKISP1_CIF_VI_DPCL, dpcl);\n}\n\n \nstatic int rkisp1_config_cif(struct rkisp1_isp *isp,\n\t\t\t     enum v4l2_mbus_type mbus_type, u32 mbus_flags)\n{\n\tint ret;\n\n\tret = rkisp1_config_isp(isp, mbus_type, mbus_flags);\n\tif (ret)\n\t\treturn ret;\n\n\trkisp1_config_path(isp, mbus_type);\n\trkisp1_config_ism(isp);\n\n\treturn 0;\n}\n\nstatic void rkisp1_isp_stop(struct rkisp1_isp *isp)\n{\n\tstruct rkisp1_device *rkisp1 = isp->rkisp1;\n\tu32 val;\n\n\t \n\t \n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_IMSC, 0);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_ICR, ~0);\n\n\trkisp1_write(rkisp1, RKISP1_CIF_MI_IMSC, 0);\n\trkisp1_write(rkisp1, RKISP1_CIF_MI_ICR, ~0);\n\n\t \n\tval = rkisp1_read(rkisp1, RKISP1_CIF_ISP_CTRL);\n\tval &= ~(RKISP1_CIF_ISP_CTRL_ISP_INFORM_ENABLE |\n\t\t RKISP1_CIF_ISP_CTRL_ISP_ENABLE);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_CTRL, val);\n\n\tval = rkisp1_read(rkisp1,\tRKISP1_CIF_ISP_CTRL);\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_CTRL,\n\t\t     val | RKISP1_CIF_ISP_CTRL_ISP_CFG_UPD);\n\n\treadx_poll_timeout(readl, rkisp1->base_addr + RKISP1_CIF_ISP_RIS,\n\t\t\t   val, val & RKISP1_CIF_ISP_OFF, 20, 100);\n\trkisp1_write(rkisp1, RKISP1_CIF_VI_IRCL,\n\t\t     RKISP1_CIF_VI_IRCL_MIPI_SW_RST |\n\t\t     RKISP1_CIF_VI_IRCL_ISP_SW_RST);\n\trkisp1_write(rkisp1, RKISP1_CIF_VI_IRCL, 0x0);\n}\n\nstatic void rkisp1_config_clk(struct rkisp1_isp *isp)\n{\n\tstruct rkisp1_device *rkisp1 = isp->rkisp1;\n\n\tu32 val = RKISP1_CIF_VI_ICCL_ISP_CLK | RKISP1_CIF_VI_ICCL_CP_CLK |\n\t\t  RKISP1_CIF_VI_ICCL_MRSZ_CLK | RKISP1_CIF_VI_ICCL_SRSZ_CLK |\n\t\t  RKISP1_CIF_VI_ICCL_JPEG_CLK | RKISP1_CIF_VI_ICCL_MI_CLK |\n\t\t  RKISP1_CIF_VI_ICCL_IE_CLK | RKISP1_CIF_VI_ICCL_MIPI_CLK |\n\t\t  RKISP1_CIF_VI_ICCL_DCROP_CLK;\n\n\trkisp1_write(rkisp1, RKISP1_CIF_VI_ICCL, val);\n\n\t \n\tif (rkisp1->info->isp_ver == RKISP1_V12) {\n\t\tval = RKISP1_CIF_CLK_CTRL_MI_Y12 | RKISP1_CIF_CLK_CTRL_MI_SP |\n\t\t      RKISP1_CIF_CLK_CTRL_MI_RAW0 | RKISP1_CIF_CLK_CTRL_MI_RAW1 |\n\t\t      RKISP1_CIF_CLK_CTRL_MI_READ | RKISP1_CIF_CLK_CTRL_MI_RAWRD |\n\t\t      RKISP1_CIF_CLK_CTRL_CP | RKISP1_CIF_CLK_CTRL_IE;\n\t\trkisp1_write(rkisp1, RKISP1_CIF_VI_ISP_CLK_CTRL_V12, val);\n\t}\n}\n\nstatic void rkisp1_isp_start(struct rkisp1_isp *isp)\n{\n\tstruct rkisp1_device *rkisp1 = isp->rkisp1;\n\tu32 val;\n\n\trkisp1_config_clk(isp);\n\n\t \n\tval = rkisp1_read(rkisp1, RKISP1_CIF_ISP_CTRL);\n\tval |= RKISP1_CIF_ISP_CTRL_ISP_CFG_UPD |\n\t       RKISP1_CIF_ISP_CTRL_ISP_ENABLE |\n\t       RKISP1_CIF_ISP_CTRL_ISP_INFORM_ENABLE;\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_CTRL, val);\n\n\tif (isp->src_fmt->pixel_enc != V4L2_PIXEL_ENC_BAYER)\n\t\trkisp1_params_post_configure(&rkisp1->params);\n}\n\n \n\nstatic inline struct rkisp1_isp *to_rkisp1_isp(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct rkisp1_isp, sd);\n}\n\nstatic int rkisp1_isp_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_subdev_mbus_code_enum *code)\n{\n\tunsigned int i, dir;\n\tint pos = 0;\n\n\tif (code->pad == RKISP1_ISP_PAD_SINK_VIDEO) {\n\t\tdir = RKISP1_ISP_SD_SINK;\n\t} else if (code->pad == RKISP1_ISP_PAD_SOURCE_VIDEO) {\n\t\tdir = RKISP1_ISP_SD_SRC;\n\t} else {\n\t\tif (code->index > 0)\n\t\t\treturn -EINVAL;\n\t\tcode->code = MEDIA_BUS_FMT_METADATA_FIXED;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct rkisp1_mbus_info *fmt =\n\t\t\trkisp1_mbus_info_get_by_index(i);\n\n\t\tif (!fmt)\n\t\t\treturn -EINVAL;\n\n\t\tif (fmt->direction & dir)\n\t\t\tpos++;\n\n\t\tif (code->index == pos - 1) {\n\t\t\tcode->code = fmt->mbus_code;\n\t\t\tif (fmt->pixel_enc == V4L2_PIXEL_ENC_YUV &&\n\t\t\t    dir == RKISP1_ISP_SD_SRC)\n\t\t\t\tcode->flags =\n\t\t\t\t\tV4L2_SUBDEV_MBUS_CODE_CSC_QUANTIZATION;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int rkisp1_isp_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t\t      struct v4l2_subdev_frame_size_enum *fse)\n{\n\tconst struct rkisp1_mbus_info *mbus_info;\n\n\tif (fse->pad == RKISP1_ISP_PAD_SINK_PARAMS ||\n\t    fse->pad == RKISP1_ISP_PAD_SOURCE_STATS)\n\t\treturn -ENOTTY;\n\n\tif (fse->index > 0)\n\t\treturn -EINVAL;\n\n\tmbus_info = rkisp1_mbus_info_get_by_code(fse->code);\n\tif (!mbus_info)\n\t\treturn -EINVAL;\n\n\tif (!(mbus_info->direction & RKISP1_ISP_SD_SINK) &&\n\t    fse->pad == RKISP1_ISP_PAD_SINK_VIDEO)\n\t\treturn -EINVAL;\n\n\tif (!(mbus_info->direction & RKISP1_ISP_SD_SRC) &&\n\t    fse->pad == RKISP1_ISP_PAD_SOURCE_VIDEO)\n\t\treturn -EINVAL;\n\n\tfse->min_width = RKISP1_ISP_MIN_WIDTH;\n\tfse->max_width = RKISP1_ISP_MAX_WIDTH;\n\tfse->min_height = RKISP1_ISP_MIN_HEIGHT;\n\tfse->max_height = RKISP1_ISP_MAX_HEIGHT;\n\n\treturn 0;\n}\n\nstatic int rkisp1_isp_init_config(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_mbus_framefmt *sink_fmt, *src_fmt;\n\tstruct v4l2_rect *sink_crop, *src_crop;\n\n\t \n\tsink_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t      RKISP1_ISP_PAD_SINK_VIDEO);\n\tsink_fmt->width = RKISP1_DEFAULT_WIDTH;\n\tsink_fmt->height = RKISP1_DEFAULT_HEIGHT;\n\tsink_fmt->field = V4L2_FIELD_NONE;\n\tsink_fmt->code = RKISP1_DEF_SINK_PAD_FMT;\n\tsink_fmt->colorspace = V4L2_COLORSPACE_RAW;\n\tsink_fmt->xfer_func = V4L2_XFER_FUNC_NONE;\n\tsink_fmt->ycbcr_enc = V4L2_YCBCR_ENC_601;\n\tsink_fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\n\tsink_crop = v4l2_subdev_get_try_crop(sd, sd_state,\n\t\t\t\t\t     RKISP1_ISP_PAD_SINK_VIDEO);\n\tsink_crop->width = RKISP1_DEFAULT_WIDTH;\n\tsink_crop->height = RKISP1_DEFAULT_HEIGHT;\n\tsink_crop->left = 0;\n\tsink_crop->top = 0;\n\n\tsrc_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t     RKISP1_ISP_PAD_SOURCE_VIDEO);\n\t*src_fmt = *sink_fmt;\n\tsrc_fmt->code = RKISP1_DEF_SRC_PAD_FMT;\n\tsrc_fmt->colorspace = V4L2_COLORSPACE_SRGB;\n\tsrc_fmt->xfer_func = V4L2_XFER_FUNC_SRGB;\n\tsrc_fmt->ycbcr_enc = V4L2_YCBCR_ENC_601;\n\tsrc_fmt->quantization = V4L2_QUANTIZATION_LIM_RANGE;\n\n\tsrc_crop = v4l2_subdev_get_try_crop(sd, sd_state,\n\t\t\t\t\t    RKISP1_ISP_PAD_SOURCE_VIDEO);\n\t*src_crop = *sink_crop;\n\n\t \n\tsink_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t      RKISP1_ISP_PAD_SINK_PARAMS);\n\tsrc_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t     RKISP1_ISP_PAD_SOURCE_STATS);\n\tsink_fmt->width = 0;\n\tsink_fmt->height = 0;\n\tsink_fmt->field = V4L2_FIELD_NONE;\n\tsink_fmt->code = MEDIA_BUS_FMT_METADATA_FIXED;\n\t*src_fmt = *sink_fmt;\n\n\treturn 0;\n}\n\nstatic void rkisp1_isp_set_src_fmt(struct rkisp1_isp *isp,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_mbus_framefmt *format,\n\t\t\t\t   unsigned int which)\n{\n\tconst struct rkisp1_mbus_info *sink_info;\n\tconst struct rkisp1_mbus_info *src_info;\n\tstruct v4l2_mbus_framefmt *sink_fmt;\n\tstruct v4l2_mbus_framefmt *src_fmt;\n\tconst struct v4l2_rect *src_crop;\n\tbool set_csc;\n\n\tsink_fmt = rkisp1_isp_get_pad_fmt(isp, sd_state,\n\t\t\t\t\t  RKISP1_ISP_PAD_SINK_VIDEO, which);\n\tsrc_fmt = rkisp1_isp_get_pad_fmt(isp, sd_state,\n\t\t\t\t\t RKISP1_ISP_PAD_SOURCE_VIDEO, which);\n\tsrc_crop = rkisp1_isp_get_pad_crop(isp, sd_state,\n\t\t\t\t\t   RKISP1_ISP_PAD_SOURCE_VIDEO, which);\n\n\t \n\tsink_info = rkisp1_mbus_info_get_by_code(sink_fmt->code);\n\n\tsrc_fmt->code = format->code;\n\tsrc_info = rkisp1_mbus_info_get_by_code(src_fmt->code);\n\tif (!src_info || !(src_info->direction & RKISP1_ISP_SD_SRC)) {\n\t\tsrc_fmt->code = RKISP1_DEF_SRC_PAD_FMT;\n\t\tsrc_info = rkisp1_mbus_info_get_by_code(src_fmt->code);\n\t}\n\n\tif (sink_info->pixel_enc == V4L2_PIXEL_ENC_YUV &&\n\t    src_info->pixel_enc == V4L2_PIXEL_ENC_BAYER) {\n\t\tsrc_fmt->code = sink_fmt->code;\n\t\tsrc_info = sink_info;\n\t}\n\n\t \n\tsrc_fmt->width  = src_crop->width;\n\tsrc_fmt->height = src_crop->height;\n\n\t \n\tsrc_fmt->colorspace = sink_fmt->colorspace;\n\tsrc_fmt->xfer_func = sink_fmt->xfer_func;\n\tsrc_fmt->ycbcr_enc = sink_fmt->ycbcr_enc;\n\n\tif (sink_info->pixel_enc == V4L2_PIXEL_ENC_BAYER &&\n\t    src_info->pixel_enc == V4L2_PIXEL_ENC_YUV)\n\t\tsrc_fmt->quantization = V4L2_QUANTIZATION_LIM_RANGE;\n\telse\n\t\tsrc_fmt->quantization = sink_fmt->quantization;\n\n\t \n\tset_csc = format->flags & V4L2_MBUS_FRAMEFMT_SET_CSC;\n\n\tif (set_csc && src_info->pixel_enc == V4L2_PIXEL_ENC_YUV) {\n\t\tif (sink_info->pixel_enc == V4L2_PIXEL_ENC_BAYER) {\n\t\t\tif (format->colorspace != V4L2_COLORSPACE_DEFAULT)\n\t\t\t\tsrc_fmt->colorspace = format->colorspace;\n\t\t\tif (format->xfer_func != V4L2_XFER_FUNC_DEFAULT)\n\t\t\t\tsrc_fmt->xfer_func = format->xfer_func;\n\t\t\tif (format->ycbcr_enc != V4L2_YCBCR_ENC_DEFAULT)\n\t\t\t\tsrc_fmt->ycbcr_enc = format->ycbcr_enc;\n\t\t}\n\n\t\tif (format->quantization != V4L2_QUANTIZATION_DEFAULT)\n\t\t\tsrc_fmt->quantization = format->quantization;\n\t}\n\n\t*format = *src_fmt;\n\n\t \n\tif (set_csc)\n\t\tformat->flags |= V4L2_MBUS_FRAMEFMT_SET_CSC;\n\n\t \n\tif (which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tisp->src_fmt = src_info;\n}\n\nstatic void rkisp1_isp_set_src_crop(struct rkisp1_isp *isp,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_rect *r, unsigned int which)\n{\n\tstruct v4l2_mbus_framefmt *src_fmt;\n\tconst struct v4l2_rect *sink_crop;\n\tstruct v4l2_rect *src_crop;\n\n\tsrc_crop = rkisp1_isp_get_pad_crop(isp, sd_state,\n\t\t\t\t\t   RKISP1_ISP_PAD_SOURCE_VIDEO,\n\t\t\t\t\t   which);\n\tsink_crop = rkisp1_isp_get_pad_crop(isp, sd_state,\n\t\t\t\t\t    RKISP1_ISP_PAD_SINK_VIDEO,\n\t\t\t\t\t    which);\n\n\tsrc_crop->left = ALIGN(r->left, 2);\n\tsrc_crop->width = ALIGN(r->width, 2);\n\tsrc_crop->top = r->top;\n\tsrc_crop->height = r->height;\n\trkisp1_sd_adjust_crop_rect(src_crop, sink_crop);\n\n\t*r = *src_crop;\n\n\t \n\tsrc_fmt = rkisp1_isp_get_pad_fmt(isp, sd_state,\n\t\t\t\t\t RKISP1_ISP_PAD_SOURCE_VIDEO, which);\n\trkisp1_isp_set_src_fmt(isp, sd_state, src_fmt, which);\n}\n\nstatic void rkisp1_isp_set_sink_crop(struct rkisp1_isp *isp,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_rect *r, unsigned int which)\n{\n\tstruct v4l2_rect *sink_crop, *src_crop;\n\tconst struct v4l2_mbus_framefmt *sink_fmt;\n\n\tsink_crop = rkisp1_isp_get_pad_crop(isp, sd_state,\n\t\t\t\t\t    RKISP1_ISP_PAD_SINK_VIDEO,\n\t\t\t\t\t    which);\n\tsink_fmt = rkisp1_isp_get_pad_fmt(isp, sd_state,\n\t\t\t\t\t  RKISP1_ISP_PAD_SINK_VIDEO,\n\t\t\t\t\t  which);\n\n\tsink_crop->left = ALIGN(r->left, 2);\n\tsink_crop->width = ALIGN(r->width, 2);\n\tsink_crop->top = r->top;\n\tsink_crop->height = r->height;\n\trkisp1_sd_adjust_crop(sink_crop, sink_fmt);\n\n\t*r = *sink_crop;\n\n\t \n\tsrc_crop = rkisp1_isp_get_pad_crop(isp, sd_state,\n\t\t\t\t\t   RKISP1_ISP_PAD_SOURCE_VIDEO, which);\n\trkisp1_isp_set_src_crop(isp, sd_state, src_crop, which);\n}\n\nstatic void rkisp1_isp_set_sink_fmt(struct rkisp1_isp *isp,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_mbus_framefmt *format,\n\t\t\t\t    unsigned int which)\n{\n\tconst struct rkisp1_mbus_info *mbus_info;\n\tstruct v4l2_mbus_framefmt *sink_fmt;\n\tstruct v4l2_rect *sink_crop;\n\tbool is_yuv;\n\n\tsink_fmt = rkisp1_isp_get_pad_fmt(isp, sd_state,\n\t\t\t\t\t  RKISP1_ISP_PAD_SINK_VIDEO,\n\t\t\t\t\t  which);\n\tsink_fmt->code = format->code;\n\tmbus_info = rkisp1_mbus_info_get_by_code(sink_fmt->code);\n\tif (!mbus_info || !(mbus_info->direction & RKISP1_ISP_SD_SINK)) {\n\t\tsink_fmt->code = RKISP1_DEF_SINK_PAD_FMT;\n\t\tmbus_info = rkisp1_mbus_info_get_by_code(sink_fmt->code);\n\t}\n\tif (which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tisp->sink_fmt = mbus_info;\n\n\tsink_fmt->width = clamp_t(u32, format->width,\n\t\t\t\t  RKISP1_ISP_MIN_WIDTH,\n\t\t\t\t  RKISP1_ISP_MAX_WIDTH);\n\tsink_fmt->height = clamp_t(u32, format->height,\n\t\t\t\t   RKISP1_ISP_MIN_HEIGHT,\n\t\t\t\t   RKISP1_ISP_MAX_HEIGHT);\n\n\t \n\tis_yuv = mbus_info->pixel_enc == V4L2_PIXEL_ENC_YUV;\n\n\tsink_fmt->colorspace = format->colorspace ? :\n\t\t\t       (is_yuv ? V4L2_COLORSPACE_SRGB :\n\t\t\t\tV4L2_COLORSPACE_RAW);\n\tsink_fmt->xfer_func = format->xfer_func ? :\n\t\t\t      V4L2_MAP_XFER_FUNC_DEFAULT(sink_fmt->colorspace);\n\tif (is_yuv) {\n\t\tsink_fmt->ycbcr_enc = format->ycbcr_enc ? :\n\t\t\tV4L2_MAP_YCBCR_ENC_DEFAULT(sink_fmt->colorspace);\n\t\tsink_fmt->quantization = format->quantization ? :\n\t\t\tV4L2_MAP_QUANTIZATION_DEFAULT(false, sink_fmt->colorspace,\n\t\t\t\t\t\t      sink_fmt->ycbcr_enc);\n\t} else {\n\t\t \n\t\tsink_fmt->ycbcr_enc = V4L2_YCBCR_ENC_601;\n\t\tsink_fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\t}\n\n\t*format = *sink_fmt;\n\n\t \n\tsink_crop = rkisp1_isp_get_pad_crop(isp, sd_state,\n\t\t\t\t\t    RKISP1_ISP_PAD_SINK_VIDEO,\n\t\t\t\t\t    which);\n\trkisp1_isp_set_sink_crop(isp, sd_state, sink_crop, which);\n}\n\nstatic int rkisp1_isp_get_fmt(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct rkisp1_isp *isp = to_rkisp1_isp(sd);\n\n\tmutex_lock(&isp->ops_lock);\n\tfmt->format = *rkisp1_isp_get_pad_fmt(isp, sd_state, fmt->pad,\n\t\t\t\t\t      fmt->which);\n\tmutex_unlock(&isp->ops_lock);\n\treturn 0;\n}\n\nstatic int rkisp1_isp_set_fmt(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct rkisp1_isp *isp = to_rkisp1_isp(sd);\n\n\tmutex_lock(&isp->ops_lock);\n\tif (fmt->pad == RKISP1_ISP_PAD_SINK_VIDEO)\n\t\trkisp1_isp_set_sink_fmt(isp, sd_state, &fmt->format,\n\t\t\t\t\tfmt->which);\n\telse if (fmt->pad == RKISP1_ISP_PAD_SOURCE_VIDEO)\n\t\trkisp1_isp_set_src_fmt(isp, sd_state, &fmt->format,\n\t\t\t\t       fmt->which);\n\telse\n\t\tfmt->format = *rkisp1_isp_get_pad_fmt(isp, sd_state, fmt->pad,\n\t\t\t\t\t\t      fmt->which);\n\n\tmutex_unlock(&isp->ops_lock);\n\treturn 0;\n}\n\nstatic int rkisp1_isp_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_selection *sel)\n{\n\tstruct rkisp1_isp *isp = to_rkisp1_isp(sd);\n\tint ret = 0;\n\n\tif (sel->pad != RKISP1_ISP_PAD_SOURCE_VIDEO &&\n\t    sel->pad != RKISP1_ISP_PAD_SINK_VIDEO)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&isp->ops_lock);\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tif (sel->pad == RKISP1_ISP_PAD_SINK_VIDEO) {\n\t\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\t\tfmt = rkisp1_isp_get_pad_fmt(isp, sd_state, sel->pad,\n\t\t\t\t\t\t     sel->which);\n\t\t\tsel->r.height = fmt->height;\n\t\t\tsel->r.width = fmt->width;\n\t\t\tsel->r.left = 0;\n\t\t\tsel->r.top = 0;\n\t\t} else {\n\t\t\tsel->r = *rkisp1_isp_get_pad_crop(isp, sd_state,\n\t\t\t\t\t\t\t  RKISP1_ISP_PAD_SINK_VIDEO,\n\t\t\t\t\t\t\t  sel->which);\n\t\t}\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *rkisp1_isp_get_pad_crop(isp, sd_state, sel->pad,\n\t\t\t\t\t\t  sel->which);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&isp->ops_lock);\n\treturn ret;\n}\n\nstatic int rkisp1_isp_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_selection *sel)\n{\n\tstruct rkisp1_isp *isp = to_rkisp1_isp(sd);\n\tint ret = 0;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tdev_dbg(isp->rkisp1->dev, \"%s: pad: %d sel(%d,%d)/%dx%d\\n\", __func__,\n\t\tsel->pad, sel->r.left, sel->r.top, sel->r.width, sel->r.height);\n\tmutex_lock(&isp->ops_lock);\n\tif (sel->pad == RKISP1_ISP_PAD_SINK_VIDEO)\n\t\trkisp1_isp_set_sink_crop(isp, sd_state, &sel->r, sel->which);\n\telse if (sel->pad == RKISP1_ISP_PAD_SOURCE_VIDEO)\n\t\trkisp1_isp_set_src_crop(isp, sd_state, &sel->r, sel->which);\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&isp->ops_lock);\n\treturn ret;\n}\n\nstatic int rkisp1_subdev_link_validate(struct media_link *link)\n{\n\tif (link->sink->index == RKISP1_ISP_PAD_SINK_PARAMS)\n\t\treturn 0;\n\n\treturn v4l2_subdev_link_validate(link);\n}\n\nstatic const struct v4l2_subdev_pad_ops rkisp1_isp_pad_ops = {\n\t.enum_mbus_code = rkisp1_isp_enum_mbus_code,\n\t.enum_frame_size = rkisp1_isp_enum_frame_size,\n\t.get_selection = rkisp1_isp_get_selection,\n\t.set_selection = rkisp1_isp_set_selection,\n\t.init_cfg = rkisp1_isp_init_config,\n\t.get_fmt = rkisp1_isp_get_fmt,\n\t.set_fmt = rkisp1_isp_set_fmt,\n\t.link_validate = v4l2_subdev_link_validate_default,\n};\n\n \n\nstatic int rkisp1_isp_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct rkisp1_isp *isp = to_rkisp1_isp(sd);\n\tstruct rkisp1_device *rkisp1 = isp->rkisp1;\n\tstruct media_pad *source_pad;\n\tstruct media_pad *sink_pad;\n\tenum v4l2_mbus_type mbus_type;\n\tu32 mbus_flags;\n\tint ret;\n\n\tif (!enable) {\n\t\tv4l2_subdev_call(rkisp1->source, video, s_stream, false);\n\t\trkisp1_isp_stop(isp);\n\t\treturn 0;\n\t}\n\n\tsink_pad = &isp->pads[RKISP1_ISP_PAD_SINK_VIDEO];\n\tsource_pad = media_pad_remote_pad_unique(sink_pad);\n\tif (IS_ERR(source_pad)) {\n\t\tdev_dbg(rkisp1->dev, \"Failed to get source for ISP: %ld\\n\",\n\t\t\tPTR_ERR(source_pad));\n\t\treturn -EPIPE;\n\t}\n\n\trkisp1->source = media_entity_to_v4l2_subdev(source_pad->entity);\n\tif (!rkisp1->source) {\n\t\t \n\t\treturn -EPIPE;\n\t}\n\n\tif (rkisp1->source == &rkisp1->csi.sd) {\n\t\tmbus_type = V4L2_MBUS_CSI2_DPHY;\n\t\tmbus_flags = 0;\n\t} else {\n\t\tconst struct rkisp1_sensor_async *asd;\n\t\tstruct v4l2_async_connection *asc;\n\n\t\tasc = v4l2_async_connection_unique(rkisp1->source);\n\t\tif (!asc)\n\t\t\treturn -EPIPE;\n\n\t\tasd = container_of(asc, struct rkisp1_sensor_async, asd);\n\n\t\tmbus_type = asd->mbus_type;\n\t\tmbus_flags = asd->mbus_flags;\n\t}\n\n\tisp->frame_sequence = -1;\n\tmutex_lock(&isp->ops_lock);\n\tret = rkisp1_config_cif(isp, mbus_type, mbus_flags);\n\tif (ret)\n\t\tgoto mutex_unlock;\n\n\trkisp1_isp_start(isp);\n\n\tret = v4l2_subdev_call(rkisp1->source, video, s_stream, true);\n\tif (ret) {\n\t\trkisp1_isp_stop(isp);\n\t\tgoto mutex_unlock;\n\t}\n\nmutex_unlock:\n\tmutex_unlock(&isp->ops_lock);\n\treturn ret;\n}\n\nstatic int rkisp1_isp_subs_evt(struct v4l2_subdev *sd, struct v4l2_fh *fh,\n\t\t\t       struct v4l2_event_subscription *sub)\n{\n\tif (sub->type != V4L2_EVENT_FRAME_SYNC)\n\t\treturn -EINVAL;\n\n\t \n\tif (sub->id != 0)\n\t\treturn -EINVAL;\n\n\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n}\n\nstatic const struct media_entity_operations rkisp1_isp_media_ops = {\n\t.link_validate = rkisp1_subdev_link_validate,\n};\n\nstatic const struct v4l2_subdev_video_ops rkisp1_isp_video_ops = {\n\t.s_stream = rkisp1_isp_s_stream,\n};\n\nstatic const struct v4l2_subdev_core_ops rkisp1_isp_core_ops = {\n\t.subscribe_event = rkisp1_isp_subs_evt,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_ops rkisp1_isp_ops = {\n\t.core = &rkisp1_isp_core_ops,\n\t.video = &rkisp1_isp_video_ops,\n\t.pad = &rkisp1_isp_pad_ops,\n};\n\nint rkisp1_isp_register(struct rkisp1_device *rkisp1)\n{\n\tstruct v4l2_subdev_state state = {\n\t\t.pads = rkisp1->isp.pad_cfg\n\t};\n\tstruct rkisp1_isp *isp = &rkisp1->isp;\n\tstruct media_pad *pads = isp->pads;\n\tstruct v4l2_subdev *sd = &isp->sd;\n\tint ret;\n\n\tisp->rkisp1 = rkisp1;\n\n\tv4l2_subdev_init(sd, &rkisp1_isp_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n\tsd->entity.ops = &rkisp1_isp_media_ops;\n\tsd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;\n\tsd->owner = THIS_MODULE;\n\tstrscpy(sd->name, RKISP1_ISP_DEV_NAME, sizeof(sd->name));\n\n\tpads[RKISP1_ISP_PAD_SINK_VIDEO].flags = MEDIA_PAD_FL_SINK |\n\t\t\t\t\t\tMEDIA_PAD_FL_MUST_CONNECT;\n\tpads[RKISP1_ISP_PAD_SINK_PARAMS].flags = MEDIA_PAD_FL_SINK;\n\tpads[RKISP1_ISP_PAD_SOURCE_VIDEO].flags = MEDIA_PAD_FL_SOURCE;\n\tpads[RKISP1_ISP_PAD_SOURCE_STATS].flags = MEDIA_PAD_FL_SOURCE;\n\n\tisp->sink_fmt = rkisp1_mbus_info_get_by_code(RKISP1_DEF_SINK_PAD_FMT);\n\tisp->src_fmt = rkisp1_mbus_info_get_by_code(RKISP1_DEF_SRC_PAD_FMT);\n\n\tmutex_init(&isp->ops_lock);\n\tret = media_entity_pads_init(&sd->entity, RKISP1_ISP_PAD_MAX, pads);\n\tif (ret)\n\t\tgoto error;\n\n\tret = v4l2_device_register_subdev(&rkisp1->v4l2_dev, sd);\n\tif (ret) {\n\t\tdev_err(rkisp1->dev, \"Failed to register isp subdev\\n\");\n\t\tgoto error;\n\t}\n\n\trkisp1_isp_init_config(sd, &state);\n\n\treturn 0;\n\nerror:\n\tmedia_entity_cleanup(&sd->entity);\n\tmutex_destroy(&isp->ops_lock);\n\tisp->sd.v4l2_dev = NULL;\n\treturn ret;\n}\n\nvoid rkisp1_isp_unregister(struct rkisp1_device *rkisp1)\n{\n\tstruct rkisp1_isp *isp = &rkisp1->isp;\n\n\tif (!isp->sd.v4l2_dev)\n\t\treturn;\n\n\tv4l2_device_unregister_subdev(&isp->sd);\n\tmedia_entity_cleanup(&isp->sd.entity);\n\tmutex_destroy(&isp->ops_lock);\n}\n\n \n\nstatic void rkisp1_isp_queue_event_sof(struct rkisp1_isp *isp)\n{\n\tstruct v4l2_event event = {\n\t\t.type = V4L2_EVENT_FRAME_SYNC,\n\t};\n\n\tevent.u.frame_sync.frame_sequence = isp->frame_sequence;\n\tv4l2_event_queue(isp->sd.devnode, &event);\n}\n\nirqreturn_t rkisp1_isp_isr(int irq, void *ctx)\n{\n\tstruct device *dev = ctx;\n\tstruct rkisp1_device *rkisp1 = dev_get_drvdata(dev);\n\tu32 status, isp_err;\n\n\tstatus = rkisp1_read(rkisp1, RKISP1_CIF_ISP_MIS);\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\trkisp1_write(rkisp1, RKISP1_CIF_ISP_ICR, status);\n\n\t \n\tif (status & RKISP1_CIF_ISP_V_START) {\n\t\trkisp1->isp.frame_sequence++;\n\t\trkisp1_isp_queue_event_sof(&rkisp1->isp);\n\t\tif (status & RKISP1_CIF_ISP_FRAME) {\n\t\t\tWARN_ONCE(1, \"irq delay is too long, buffers might not be in sync\\n\");\n\t\t\trkisp1->debug.irq_delay++;\n\t\t}\n\t}\n\tif (status & RKISP1_CIF_ISP_PIC_SIZE_ERROR) {\n\t\t \n\t\tisp_err = rkisp1_read(rkisp1, RKISP1_CIF_ISP_ERR);\n\t\tif (isp_err & RKISP1_CIF_ISP_ERR_INFORM_SIZE)\n\t\t\trkisp1->debug.inform_size_error++;\n\t\tif (isp_err & RKISP1_CIF_ISP_ERR_IS_SIZE)\n\t\t\trkisp1->debug.img_stabilization_size_error++;\n\t\tif (isp_err & RKISP1_CIF_ISP_ERR_OUTFORM_SIZE)\n\t\t\trkisp1->debug.outform_size_error++;\n\t\trkisp1_write(rkisp1, RKISP1_CIF_ISP_ERR_CLR, isp_err);\n\t} else if (status & RKISP1_CIF_ISP_DATA_LOSS) {\n\t\t \n\t\trkisp1->debug.data_loss++;\n\t}\n\n\tif (status & RKISP1_CIF_ISP_FRAME) {\n\t\tu32 isp_ris;\n\n\t\t \n\t\tisp_ris = rkisp1_read(rkisp1, RKISP1_CIF_ISP_RIS);\n\t\tif (isp_ris & RKISP1_STATS_MEAS_MASK)\n\t\t\trkisp1_stats_isr(&rkisp1->stats, isp_ris);\n\t\t \n\t\trkisp1_params_isr(rkisp1);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}