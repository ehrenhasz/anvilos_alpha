{
  "module_name": "rkisp1-resizer.c",
  "hash_id": "cb79fa40632e3bb56c7fdd7c7b80c630153cbd5f494ac51d8c766559dc2dd2b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/rockchip/rkisp1/rkisp1-resizer.c",
  "human_readable_source": "\n \n\n#include \"rkisp1-common.h\"\n\n#define RKISP1_RSZ_SP_DEV_NAME\tRKISP1_DRIVER_NAME \"_resizer_selfpath\"\n#define RKISP1_RSZ_MP_DEV_NAME\tRKISP1_DRIVER_NAME \"_resizer_mainpath\"\n\n#define RKISP1_DEF_FMT MEDIA_BUS_FMT_YUYV8_2X8\n#define RKISP1_DEF_PIXEL_ENC V4L2_PIXEL_ENC_YUV\n\nstruct rkisp1_rsz_yuv_mbus_info {\n\tu32 mbus_code;\n\tu32 hdiv;\n\tu32 vdiv;\n};\n\nstatic const struct rkisp1_rsz_yuv_mbus_info rkisp1_rsz_yuv_src_formats[] = {\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,  \n\t\t.hdiv\t\t= 2,\n\t\t.vdiv\t\t= 1,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_1_5X8,  \n\t\t.hdiv\t\t= 2,\n\t\t.vdiv\t\t= 2,\n\t},\n};\n\nstatic const struct rkisp1_rsz_yuv_mbus_info *rkisp1_rsz_get_yuv_mbus_info(u32 mbus_code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rkisp1_rsz_yuv_src_formats); i++) {\n\t\tif (rkisp1_rsz_yuv_src_formats[i].mbus_code == mbus_code)\n\t\t\treturn &rkisp1_rsz_yuv_src_formats[i];\n\t}\n\n\treturn NULL;\n}\n\nenum rkisp1_shadow_regs_when {\n\tRKISP1_SHADOW_REGS_SYNC,\n\tRKISP1_SHADOW_REGS_ASYNC,\n};\n\nstruct rkisp1_rsz_config {\n\t \n\tconst int max_rsz_width;\n\tconst int max_rsz_height;\n\tconst int min_rsz_width;\n\tconst int min_rsz_height;\n\t \n\tstruct {\n\t\tu32 ctrl;\n\t\tu32 yuvmode_mask;\n\t\tu32 rawmode_mask;\n\t\tu32 h_offset;\n\t\tu32 v_offset;\n\t\tu32 h_size;\n\t\tu32 v_size;\n\t} dual_crop;\n};\n\nstatic const struct rkisp1_rsz_config rkisp1_rsz_config_mp = {\n\t \n\t.max_rsz_width = RKISP1_RSZ_MP_SRC_MAX_WIDTH,\n\t.max_rsz_height = RKISP1_RSZ_MP_SRC_MAX_HEIGHT,\n\t.min_rsz_width = RKISP1_RSZ_SRC_MIN_WIDTH,\n\t.min_rsz_height = RKISP1_RSZ_SRC_MIN_HEIGHT,\n\t \n\t.dual_crop = {\n\t\t.ctrl =\t\t\tRKISP1_CIF_DUAL_CROP_CTRL,\n\t\t.yuvmode_mask =\t\tRKISP1_CIF_DUAL_CROP_MP_MODE_YUV,\n\t\t.rawmode_mask =\t\tRKISP1_CIF_DUAL_CROP_MP_MODE_RAW,\n\t\t.h_offset =\t\tRKISP1_CIF_DUAL_CROP_M_H_OFFS,\n\t\t.v_offset =\t\tRKISP1_CIF_DUAL_CROP_M_V_OFFS,\n\t\t.h_size =\t\tRKISP1_CIF_DUAL_CROP_M_H_SIZE,\n\t\t.v_size =\t\tRKISP1_CIF_DUAL_CROP_M_V_SIZE,\n\t},\n};\n\nstatic const struct rkisp1_rsz_config rkisp1_rsz_config_sp = {\n\t \n\t.max_rsz_width = RKISP1_RSZ_SP_SRC_MAX_WIDTH,\n\t.max_rsz_height = RKISP1_RSZ_SP_SRC_MAX_HEIGHT,\n\t.min_rsz_width = RKISP1_RSZ_SRC_MIN_WIDTH,\n\t.min_rsz_height = RKISP1_RSZ_SRC_MIN_HEIGHT,\n\t \n\t.dual_crop = {\n\t\t.ctrl =\t\t\tRKISP1_CIF_DUAL_CROP_CTRL,\n\t\t.yuvmode_mask =\t\tRKISP1_CIF_DUAL_CROP_SP_MODE_YUV,\n\t\t.rawmode_mask =\t\tRKISP1_CIF_DUAL_CROP_SP_MODE_RAW,\n\t\t.h_offset =\t\tRKISP1_CIF_DUAL_CROP_S_H_OFFS,\n\t\t.v_offset =\t\tRKISP1_CIF_DUAL_CROP_S_V_OFFS,\n\t\t.h_size =\t\tRKISP1_CIF_DUAL_CROP_S_H_SIZE,\n\t\t.v_size =\t\tRKISP1_CIF_DUAL_CROP_S_V_SIZE,\n\t},\n};\n\nstatic inline u32 rkisp1_rsz_read(struct rkisp1_resizer *rsz, u32 offset)\n{\n\treturn rkisp1_read(rsz->rkisp1, rsz->regs_base + offset);\n}\n\nstatic inline void rkisp1_rsz_write(struct rkisp1_resizer *rsz, u32 offset,\n\t\t\t\t    u32 value)\n{\n\trkisp1_write(rsz->rkisp1, rsz->regs_base + offset, value);\n}\n\nstatic struct v4l2_mbus_framefmt *\nrkisp1_rsz_get_pad_fmt(struct rkisp1_resizer *rsz,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       unsigned int pad, u32 which)\n{\n\tstruct v4l2_subdev_state state = {\n\t\t.pads = rsz->pad_cfg,\n\t};\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&rsz->sd, sd_state, pad);\n\telse\n\t\treturn v4l2_subdev_get_try_format(&rsz->sd, &state, pad);\n}\n\nstatic struct v4l2_rect *\nrkisp1_rsz_get_pad_crop(struct rkisp1_resizer *rsz,\n\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\tunsigned int pad, u32 which)\n{\n\tstruct v4l2_subdev_state state = {\n\t\t.pads = rsz->pad_cfg,\n\t};\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_crop(&rsz->sd, sd_state, pad);\n\telse\n\t\treturn v4l2_subdev_get_try_crop(&rsz->sd, &state, pad);\n}\n\n \n\nstatic void rkisp1_dcrop_disable(struct rkisp1_resizer *rsz,\n\t\t\t\t enum rkisp1_shadow_regs_when when)\n{\n\tu32 dc_ctrl = rkisp1_read(rsz->rkisp1, rsz->config->dual_crop.ctrl);\n\tu32 mask = ~(rsz->config->dual_crop.yuvmode_mask |\n\t\t     rsz->config->dual_crop.rawmode_mask);\n\n\tdc_ctrl &= mask;\n\tif (when == RKISP1_SHADOW_REGS_ASYNC)\n\t\tdc_ctrl |= RKISP1_CIF_DUAL_CROP_GEN_CFG_UPD;\n\telse\n\t\tdc_ctrl |= RKISP1_CIF_DUAL_CROP_CFG_UPD;\n\trkisp1_write(rsz->rkisp1, rsz->config->dual_crop.ctrl, dc_ctrl);\n}\n\n \nstatic void rkisp1_dcrop_config(struct rkisp1_resizer *rsz)\n{\n\tstruct rkisp1_device *rkisp1 = rsz->rkisp1;\n\tstruct v4l2_mbus_framefmt *sink_fmt;\n\tstruct v4l2_rect *sink_crop;\n\tu32 dc_ctrl;\n\n\tsink_crop = rkisp1_rsz_get_pad_crop(rsz, NULL, RKISP1_RSZ_PAD_SINK,\n\t\t\t\t\t    V4L2_SUBDEV_FORMAT_ACTIVE);\n\tsink_fmt = rkisp1_rsz_get_pad_fmt(rsz, NULL, RKISP1_RSZ_PAD_SINK,\n\t\t\t\t\t  V4L2_SUBDEV_FORMAT_ACTIVE);\n\n\tif (sink_crop->width == sink_fmt->width &&\n\t    sink_crop->height == sink_fmt->height &&\n\t    sink_crop->left == 0 && sink_crop->top == 0) {\n\t\trkisp1_dcrop_disable(rsz, RKISP1_SHADOW_REGS_SYNC);\n\t\tdev_dbg(rkisp1->dev, \"capture %d crop disabled\\n\", rsz->id);\n\t\treturn;\n\t}\n\n\tdc_ctrl = rkisp1_read(rkisp1, rsz->config->dual_crop.ctrl);\n\trkisp1_write(rkisp1, rsz->config->dual_crop.h_offset, sink_crop->left);\n\trkisp1_write(rkisp1, rsz->config->dual_crop.v_offset, sink_crop->top);\n\trkisp1_write(rkisp1, rsz->config->dual_crop.h_size, sink_crop->width);\n\trkisp1_write(rkisp1, rsz->config->dual_crop.v_size, sink_crop->height);\n\tdc_ctrl |= rsz->config->dual_crop.yuvmode_mask;\n\tdc_ctrl |= RKISP1_CIF_DUAL_CROP_CFG_UPD;\n\trkisp1_write(rkisp1, rsz->config->dual_crop.ctrl, dc_ctrl);\n\n\tdev_dbg(rkisp1->dev, \"stream %d crop: %dx%d -> %dx%d\\n\", rsz->id,\n\t\tsink_fmt->width, sink_fmt->height,\n\t\tsink_crop->width, sink_crop->height);\n}\n\n \n\nstatic void rkisp1_rsz_update_shadow(struct rkisp1_resizer *rsz,\n\t\t\t\t     enum rkisp1_shadow_regs_when when)\n{\n\tu32 ctrl_cfg = rkisp1_rsz_read(rsz, RKISP1_CIF_RSZ_CTRL);\n\n\tif (when == RKISP1_SHADOW_REGS_ASYNC)\n\t\tctrl_cfg |= RKISP1_CIF_RSZ_CTRL_CFG_UPD_AUTO;\n\telse\n\t\tctrl_cfg |= RKISP1_CIF_RSZ_CTRL_CFG_UPD;\n\n\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_CTRL, ctrl_cfg);\n}\n\nstatic u32 rkisp1_rsz_calc_ratio(u32 len_sink, u32 len_src)\n{\n\tif (len_sink < len_src)\n\t\treturn ((len_sink - 1) * RKISP1_CIF_RSZ_SCALER_FACTOR) /\n\t\t       (len_src - 1);\n\n\treturn ((len_src - 1) * RKISP1_CIF_RSZ_SCALER_FACTOR) /\n\t       (len_sink - 1) + 1;\n}\n\nstatic void rkisp1_rsz_disable(struct rkisp1_resizer *rsz,\n\t\t\t       enum rkisp1_shadow_regs_when when)\n{\n\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_CTRL, 0);\n\n\tif (when == RKISP1_SHADOW_REGS_SYNC)\n\t\trkisp1_rsz_update_shadow(rsz, when);\n}\n\nstatic void rkisp1_rsz_config_regs(struct rkisp1_resizer *rsz,\n\t\t\t\t   struct v4l2_rect *sink_y,\n\t\t\t\t   struct v4l2_rect *sink_c,\n\t\t\t\t   struct v4l2_rect *src_y,\n\t\t\t\t   struct v4l2_rect *src_c,\n\t\t\t\t   enum rkisp1_shadow_regs_when when)\n{\n\tu32 ratio, rsz_ctrl = 0;\n\tunsigned int i;\n\n\t \n\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_PHASE_HY, 0);\n\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_PHASE_HC, 0);\n\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_PHASE_VY, 0);\n\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_PHASE_VC, 0);\n\n\t \n\tfor (i = 0; i < 64; i++) {\n\t\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_SCALE_LUT_ADDR, i);\n\t\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_SCALE_LUT, i);\n\t}\n\n\tif (sink_y->width != src_y->width) {\n\t\trsz_ctrl |= RKISP1_CIF_RSZ_CTRL_SCALE_HY_ENABLE;\n\t\tif (sink_y->width < src_y->width)\n\t\t\trsz_ctrl |= RKISP1_CIF_RSZ_CTRL_SCALE_HY_UP;\n\t\tratio = rkisp1_rsz_calc_ratio(sink_y->width, src_y->width);\n\t\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_SCALE_HY, ratio);\n\t}\n\n\tif (sink_c->width != src_c->width) {\n\t\trsz_ctrl |= RKISP1_CIF_RSZ_CTRL_SCALE_HC_ENABLE;\n\t\tif (sink_c->width < src_c->width)\n\t\t\trsz_ctrl |= RKISP1_CIF_RSZ_CTRL_SCALE_HC_UP;\n\t\tratio = rkisp1_rsz_calc_ratio(sink_c->width, src_c->width);\n\t\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_SCALE_HCB, ratio);\n\t\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_SCALE_HCR, ratio);\n\t}\n\n\tif (sink_y->height != src_y->height) {\n\t\trsz_ctrl |= RKISP1_CIF_RSZ_CTRL_SCALE_VY_ENABLE;\n\t\tif (sink_y->height < src_y->height)\n\t\t\trsz_ctrl |= RKISP1_CIF_RSZ_CTRL_SCALE_VY_UP;\n\t\tratio = rkisp1_rsz_calc_ratio(sink_y->height, src_y->height);\n\t\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_SCALE_VY, ratio);\n\t}\n\n\tif (sink_c->height != src_c->height) {\n\t\trsz_ctrl |= RKISP1_CIF_RSZ_CTRL_SCALE_VC_ENABLE;\n\t\tif (sink_c->height < src_c->height)\n\t\t\trsz_ctrl |= RKISP1_CIF_RSZ_CTRL_SCALE_VC_UP;\n\t\tratio = rkisp1_rsz_calc_ratio(sink_c->height, src_c->height);\n\t\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_SCALE_VC, ratio);\n\t}\n\n\trkisp1_rsz_write(rsz, RKISP1_CIF_RSZ_CTRL, rsz_ctrl);\n\n\trkisp1_rsz_update_shadow(rsz, when);\n}\n\nstatic void rkisp1_rsz_config(struct rkisp1_resizer *rsz,\n\t\t\t      enum rkisp1_shadow_regs_when when)\n{\n\tconst struct rkisp1_rsz_yuv_mbus_info *sink_yuv_info, *src_yuv_info;\n\tstruct v4l2_rect sink_y, sink_c, src_y, src_c;\n\tstruct v4l2_mbus_framefmt *src_fmt, *sink_fmt;\n\tstruct v4l2_rect *sink_crop;\n\n\tsink_crop = rkisp1_rsz_get_pad_crop(rsz, NULL, RKISP1_RSZ_PAD_SINK,\n\t\t\t\t\t    V4L2_SUBDEV_FORMAT_ACTIVE);\n\tsrc_fmt = rkisp1_rsz_get_pad_fmt(rsz, NULL, RKISP1_RSZ_PAD_SRC,\n\t\t\t\t\t V4L2_SUBDEV_FORMAT_ACTIVE);\n\tsrc_yuv_info = rkisp1_rsz_get_yuv_mbus_info(src_fmt->code);\n\tsink_fmt = rkisp1_rsz_get_pad_fmt(rsz, NULL, RKISP1_RSZ_PAD_SINK,\n\t\t\t\t\t  V4L2_SUBDEV_FORMAT_ACTIVE);\n\tsink_yuv_info = rkisp1_rsz_get_yuv_mbus_info(sink_fmt->code);\n\n\t \n\tif (rsz->pixel_enc == V4L2_PIXEL_ENC_BAYER) {\n\t\trkisp1_rsz_disable(rsz, when);\n\t\treturn;\n\t}\n\n\tsink_y.width = sink_crop->width;\n\tsink_y.height = sink_crop->height;\n\tsrc_y.width = src_fmt->width;\n\tsrc_y.height = src_fmt->height;\n\n\tsink_c.width = sink_y.width / sink_yuv_info->hdiv;\n\tsink_c.height = sink_y.height / sink_yuv_info->vdiv;\n\n\t \n\tsrc_c.width = src_y.width / src_yuv_info->hdiv;\n\tsrc_c.height = src_y.height / src_yuv_info->vdiv;\n\n\tif (sink_c.width == src_c.width && sink_c.height == src_c.height) {\n\t\trkisp1_rsz_disable(rsz, when);\n\t\treturn;\n\t}\n\n\tdev_dbg(rsz->rkisp1->dev, \"stream %d rsz/scale: %dx%d -> %dx%d\\n\",\n\t\trsz->id, sink_crop->width, sink_crop->height,\n\t\tsrc_fmt->width, src_fmt->height);\n\tdev_dbg(rsz->rkisp1->dev, \"chroma scaling %dx%d -> %dx%d\\n\",\n\t\tsink_c.width, sink_c.height, src_c.width, src_c.height);\n\n\t \n\trkisp1_rsz_config_regs(rsz, &sink_y, &sink_c, &src_y, &src_c, when);\n}\n\n \n\nstatic int rkisp1_rsz_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct rkisp1_resizer *rsz =\n\t\tcontainer_of(sd, struct rkisp1_resizer, sd);\n\tstruct v4l2_subdev_pad_config dummy_cfg;\n\tstruct v4l2_subdev_state pad_state = {\n\t\t.pads = &dummy_cfg\n\t};\n\tu32 pad = code->pad;\n\tint ret;\n\n\tif (code->pad == RKISP1_RSZ_PAD_SRC) {\n\t\t \n\t\tstruct rkisp1_capture *cap = &rsz->rkisp1->capture_devs[rsz->id];\n\n\t\treturn rkisp1_cap_enum_mbus_codes(cap, code);\n\t}\n\n\t \n\tif (rsz->id == RKISP1_SELFPATH) {\n\t\tif (code->index > 0)\n\t\t\treturn -EINVAL;\n\t\tcode->code = MEDIA_BUS_FMT_YUYV8_2X8;\n\t\treturn 0;\n\t}\n\n\t \n\tcode->pad = RKISP1_ISP_PAD_SOURCE_VIDEO;\n\tret = v4l2_subdev_call(&rsz->rkisp1->isp.sd, pad, enum_mbus_code,\n\t\t\t       &pad_state, code);\n\n\t \n\tcode->pad = pad;\n\tcode->flags = 0;\n\treturn ret;\n}\n\nstatic int rkisp1_rsz_init_config(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_mbus_framefmt *sink_fmt, *src_fmt;\n\tstruct v4l2_rect *sink_crop;\n\n\tsink_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t      RKISP1_RSZ_PAD_SRC);\n\tsink_fmt->width = RKISP1_DEFAULT_WIDTH;\n\tsink_fmt->height = RKISP1_DEFAULT_HEIGHT;\n\tsink_fmt->field = V4L2_FIELD_NONE;\n\tsink_fmt->code = RKISP1_DEF_FMT;\n\tsink_fmt->colorspace = V4L2_COLORSPACE_SRGB;\n\tsink_fmt->xfer_func = V4L2_XFER_FUNC_SRGB;\n\tsink_fmt->ycbcr_enc = V4L2_YCBCR_ENC_601;\n\tsink_fmt->quantization = V4L2_QUANTIZATION_LIM_RANGE;\n\n\tsink_crop = v4l2_subdev_get_try_crop(sd, sd_state,\n\t\t\t\t\t     RKISP1_RSZ_PAD_SINK);\n\tsink_crop->width = RKISP1_DEFAULT_WIDTH;\n\tsink_crop->height = RKISP1_DEFAULT_HEIGHT;\n\tsink_crop->left = 0;\n\tsink_crop->top = 0;\n\n\tsrc_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t     RKISP1_RSZ_PAD_SINK);\n\t*src_fmt = *sink_fmt;\n\n\t \n\n\treturn 0;\n}\n\nstatic void rkisp1_rsz_set_src_fmt(struct rkisp1_resizer *rsz,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_mbus_framefmt *format,\n\t\t\t\t   unsigned int which)\n{\n\tconst struct rkisp1_mbus_info *sink_mbus_info;\n\tstruct v4l2_mbus_framefmt *src_fmt, *sink_fmt;\n\n\tsink_fmt = rkisp1_rsz_get_pad_fmt(rsz, sd_state, RKISP1_RSZ_PAD_SINK,\n\t\t\t\t\t  which);\n\tsrc_fmt = rkisp1_rsz_get_pad_fmt(rsz, sd_state, RKISP1_RSZ_PAD_SRC,\n\t\t\t\t\t which);\n\tsink_mbus_info = rkisp1_mbus_info_get_by_code(sink_fmt->code);\n\n\t \n\tif (sink_mbus_info->pixel_enc == V4L2_PIXEL_ENC_YUV &&\n\t    rkisp1_rsz_get_yuv_mbus_info(format->code))\n\t\tsrc_fmt->code = format->code;\n\n\tsrc_fmt->width = clamp_t(u32, format->width,\n\t\t\t\t rsz->config->min_rsz_width,\n\t\t\t\t rsz->config->max_rsz_width);\n\tsrc_fmt->height = clamp_t(u32, format->height,\n\t\t\t\t  rsz->config->min_rsz_height,\n\t\t\t\t  rsz->config->max_rsz_height);\n\n\t*format = *src_fmt;\n}\n\nstatic void rkisp1_rsz_set_sink_crop(struct rkisp1_resizer *rsz,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_rect *r,\n\t\t\t\t     unsigned int which)\n{\n\tconst struct rkisp1_mbus_info *mbus_info;\n\tstruct v4l2_mbus_framefmt *sink_fmt;\n\tstruct v4l2_rect *sink_crop;\n\n\tsink_fmt = rkisp1_rsz_get_pad_fmt(rsz, sd_state, RKISP1_RSZ_PAD_SINK,\n\t\t\t\t\t  which);\n\tsink_crop = rkisp1_rsz_get_pad_crop(rsz, sd_state,\n\t\t\t\t\t    RKISP1_RSZ_PAD_SINK,\n\t\t\t\t\t    which);\n\n\t \n\tmbus_info = rkisp1_mbus_info_get_by_code(sink_fmt->code);\n\n\tif (rsz->id == RKISP1_MAINPATH &&\n\t    mbus_info->pixel_enc == V4L2_PIXEL_ENC_BAYER) {\n\t\tsink_crop->left = 0;\n\t\tsink_crop->top = 0;\n\t\tsink_crop->width = sink_fmt->width;\n\t\tsink_crop->height = sink_fmt->height;\n\n\t\t*r = *sink_crop;\n\t\treturn;\n\t}\n\n\tsink_crop->left = ALIGN(r->left, 2);\n\tsink_crop->width = ALIGN(r->width, 2);\n\tsink_crop->top = r->top;\n\tsink_crop->height = r->height;\n\trkisp1_sd_adjust_crop(sink_crop, sink_fmt);\n\n\t*r = *sink_crop;\n}\n\nstatic void rkisp1_rsz_set_sink_fmt(struct rkisp1_resizer *rsz,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_mbus_framefmt *format,\n\t\t\t\t    unsigned int which)\n{\n\tconst struct rkisp1_mbus_info *mbus_info;\n\tstruct v4l2_mbus_framefmt *sink_fmt, *src_fmt;\n\tstruct v4l2_rect *sink_crop;\n\tbool is_yuv;\n\n\tsink_fmt = rkisp1_rsz_get_pad_fmt(rsz, sd_state, RKISP1_RSZ_PAD_SINK,\n\t\t\t\t\t  which);\n\tsrc_fmt = rkisp1_rsz_get_pad_fmt(rsz, sd_state, RKISP1_RSZ_PAD_SRC,\n\t\t\t\t\t which);\n\tsink_crop = rkisp1_rsz_get_pad_crop(rsz, sd_state,\n\t\t\t\t\t    RKISP1_RSZ_PAD_SINK,\n\t\t\t\t\t    which);\n\tif (rsz->id == RKISP1_SELFPATH)\n\t\tsink_fmt->code = MEDIA_BUS_FMT_YUYV8_2X8;\n\telse\n\t\tsink_fmt->code = format->code;\n\n\tmbus_info = rkisp1_mbus_info_get_by_code(sink_fmt->code);\n\tif (!mbus_info || !(mbus_info->direction & RKISP1_ISP_SD_SRC)) {\n\t\tsink_fmt->code = RKISP1_DEF_FMT;\n\t\tmbus_info = rkisp1_mbus_info_get_by_code(sink_fmt->code);\n\t}\n\tif (which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\trsz->pixel_enc = mbus_info->pixel_enc;\n\n\tsink_fmt->width = clamp_t(u32, format->width,\n\t\t\t\t  RKISP1_ISP_MIN_WIDTH,\n\t\t\t\t  RKISP1_ISP_MAX_WIDTH);\n\tsink_fmt->height = clamp_t(u32, format->height,\n\t\t\t\t   RKISP1_ISP_MIN_HEIGHT,\n\t\t\t\t   RKISP1_ISP_MAX_HEIGHT);\n\n\t \n\tis_yuv = mbus_info->pixel_enc == V4L2_PIXEL_ENC_YUV;\n\n\tsink_fmt->colorspace = format->colorspace ? :\n\t\t\t       (is_yuv ? V4L2_COLORSPACE_SRGB :\n\t\t\t\tV4L2_COLORSPACE_RAW);\n\tsink_fmt->xfer_func = format->xfer_func ? :\n\t\t\t      V4L2_MAP_XFER_FUNC_DEFAULT(sink_fmt->colorspace);\n\tif (is_yuv) {\n\t\tsink_fmt->ycbcr_enc = format->ycbcr_enc ? :\n\t\t\tV4L2_MAP_YCBCR_ENC_DEFAULT(sink_fmt->colorspace);\n\t\tsink_fmt->quantization = format->quantization ? :\n\t\t\tV4L2_MAP_QUANTIZATION_DEFAULT(false, sink_fmt->colorspace,\n\t\t\t\t\t\t      sink_fmt->ycbcr_enc);\n\t} else {\n\t\t \n\t\tsink_fmt->ycbcr_enc = V4L2_YCBCR_ENC_601;\n\t\tsink_fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\t}\n\n\t*format = *sink_fmt;\n\n\t \n\tsrc_fmt->code = sink_fmt->code;\n\tsrc_fmt->colorspace = sink_fmt->colorspace;\n\tsrc_fmt->xfer_func = sink_fmt->xfer_func;\n\tsrc_fmt->ycbcr_enc = sink_fmt->ycbcr_enc;\n\tsrc_fmt->quantization = sink_fmt->quantization;\n\n\t \n\trkisp1_rsz_set_sink_crop(rsz, sd_state, sink_crop, which);\n}\n\nstatic int rkisp1_rsz_get_fmt(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct rkisp1_resizer *rsz =\n\t\tcontainer_of(sd, struct rkisp1_resizer, sd);\n\n\tmutex_lock(&rsz->ops_lock);\n\tfmt->format = *rkisp1_rsz_get_pad_fmt(rsz, sd_state, fmt->pad,\n\t\t\t\t\t      fmt->which);\n\tmutex_unlock(&rsz->ops_lock);\n\treturn 0;\n}\n\nstatic int rkisp1_rsz_set_fmt(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct rkisp1_resizer *rsz =\n\t\tcontainer_of(sd, struct rkisp1_resizer, sd);\n\n\tmutex_lock(&rsz->ops_lock);\n\tif (fmt->pad == RKISP1_RSZ_PAD_SINK)\n\t\trkisp1_rsz_set_sink_fmt(rsz, sd_state, &fmt->format,\n\t\t\t\t\tfmt->which);\n\telse\n\t\trkisp1_rsz_set_src_fmt(rsz, sd_state, &fmt->format,\n\t\t\t\t       fmt->which);\n\n\tmutex_unlock(&rsz->ops_lock);\n\treturn 0;\n}\n\nstatic int rkisp1_rsz_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_selection *sel)\n{\n\tstruct rkisp1_resizer *rsz =\n\t\tcontainer_of(sd, struct rkisp1_resizer, sd);\n\tstruct v4l2_mbus_framefmt *mf_sink;\n\tint ret = 0;\n\n\tif (sel->pad == RKISP1_RSZ_PAD_SRC)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rsz->ops_lock);\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tmf_sink = rkisp1_rsz_get_pad_fmt(rsz, sd_state,\n\t\t\t\t\t\t RKISP1_RSZ_PAD_SINK,\n\t\t\t\t\t\t sel->which);\n\t\tsel->r.height = mf_sink->height;\n\t\tsel->r.width = mf_sink->width;\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r = *rkisp1_rsz_get_pad_crop(rsz, sd_state,\n\t\t\t\t\t\t  RKISP1_RSZ_PAD_SINK,\n\t\t\t\t\t\t  sel->which);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&rsz->ops_lock);\n\treturn ret;\n}\n\nstatic int rkisp1_rsz_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_selection *sel)\n{\n\tstruct rkisp1_resizer *rsz =\n\t\tcontainer_of(sd, struct rkisp1_resizer, sd);\n\n\tif (sel->target != V4L2_SEL_TGT_CROP || sel->pad == RKISP1_RSZ_PAD_SRC)\n\t\treturn -EINVAL;\n\n\tdev_dbg(rsz->rkisp1->dev, \"%s: pad: %d sel(%d,%d)/%dx%d\\n\", __func__,\n\t\tsel->pad, sel->r.left, sel->r.top, sel->r.width, sel->r.height);\n\n\tmutex_lock(&rsz->ops_lock);\n\trkisp1_rsz_set_sink_crop(rsz, sd_state, &sel->r, sel->which);\n\tmutex_unlock(&rsz->ops_lock);\n\n\treturn 0;\n}\n\nstatic const struct media_entity_operations rkisp1_rsz_media_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic const struct v4l2_subdev_pad_ops rkisp1_rsz_pad_ops = {\n\t.enum_mbus_code = rkisp1_rsz_enum_mbus_code,\n\t.get_selection = rkisp1_rsz_get_selection,\n\t.set_selection = rkisp1_rsz_set_selection,\n\t.init_cfg = rkisp1_rsz_init_config,\n\t.get_fmt = rkisp1_rsz_get_fmt,\n\t.set_fmt = rkisp1_rsz_set_fmt,\n\t.link_validate = v4l2_subdev_link_validate_default,\n};\n\n \n\nstatic int rkisp1_rsz_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct rkisp1_resizer *rsz =\n\t\tcontainer_of(sd, struct rkisp1_resizer, sd);\n\tstruct rkisp1_device *rkisp1 = rsz->rkisp1;\n\tstruct rkisp1_capture *other = &rkisp1->capture_devs[rsz->id ^ 1];\n\tenum rkisp1_shadow_regs_when when = RKISP1_SHADOW_REGS_SYNC;\n\n\tif (!enable) {\n\t\trkisp1_dcrop_disable(rsz, RKISP1_SHADOW_REGS_ASYNC);\n\t\trkisp1_rsz_disable(rsz, RKISP1_SHADOW_REGS_ASYNC);\n\t\treturn 0;\n\t}\n\n\tif (other->is_streaming)\n\t\twhen = RKISP1_SHADOW_REGS_ASYNC;\n\n\tmutex_lock(&rsz->ops_lock);\n\trkisp1_rsz_config(rsz, when);\n\trkisp1_dcrop_config(rsz);\n\n\tmutex_unlock(&rsz->ops_lock);\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops rkisp1_rsz_video_ops = {\n\t.s_stream = rkisp1_rsz_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops rkisp1_rsz_ops = {\n\t.video = &rkisp1_rsz_video_ops,\n\t.pad = &rkisp1_rsz_pad_ops,\n};\n\nstatic void rkisp1_rsz_unregister(struct rkisp1_resizer *rsz)\n{\n\tif (!rsz->rkisp1)\n\t\treturn;\n\n\tv4l2_device_unregister_subdev(&rsz->sd);\n\tmedia_entity_cleanup(&rsz->sd.entity);\n\tmutex_destroy(&rsz->ops_lock);\n}\n\nstatic int rkisp1_rsz_register(struct rkisp1_resizer *rsz)\n{\n\tstruct v4l2_subdev_state state = {\n\t\t.pads = rsz->pad_cfg,\n\t};\n\tstatic const char * const dev_names[] = {\n\t\tRKISP1_RSZ_MP_DEV_NAME,\n\t\tRKISP1_RSZ_SP_DEV_NAME\n\t};\n\tstruct media_pad *pads = rsz->pads;\n\tstruct v4l2_subdev *sd = &rsz->sd;\n\tint ret;\n\n\tif (rsz->id == RKISP1_SELFPATH) {\n\t\trsz->regs_base = RKISP1_CIF_SRSZ_BASE;\n\t\trsz->config = &rkisp1_rsz_config_sp;\n\t} else {\n\t\trsz->regs_base = RKISP1_CIF_MRSZ_BASE;\n\t\trsz->config = &rkisp1_rsz_config_mp;\n\t}\n\n\tv4l2_subdev_init(sd, &rkisp1_rsz_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsd->entity.ops = &rkisp1_rsz_media_ops;\n\tsd->entity.function = MEDIA_ENT_F_PROC_VIDEO_SCALER;\n\tsd->owner = THIS_MODULE;\n\tstrscpy(sd->name, dev_names[rsz->id], sizeof(sd->name));\n\n\tpads[RKISP1_RSZ_PAD_SINK].flags = MEDIA_PAD_FL_SINK |\n\t\t\t\t\t  MEDIA_PAD_FL_MUST_CONNECT;\n\tpads[RKISP1_RSZ_PAD_SRC].flags = MEDIA_PAD_FL_SOURCE |\n\t\t\t\t\t MEDIA_PAD_FL_MUST_CONNECT;\n\n\trsz->pixel_enc = RKISP1_DEF_PIXEL_ENC;\n\n\tmutex_init(&rsz->ops_lock);\n\tret = media_entity_pads_init(&sd->entity, RKISP1_RSZ_PAD_MAX, pads);\n\tif (ret)\n\t\tgoto error;\n\n\tret = v4l2_device_register_subdev(&rsz->rkisp1->v4l2_dev, sd);\n\tif (ret) {\n\t\tdev_err(sd->dev, \"Failed to register resizer subdev\\n\");\n\t\tgoto error;\n\t}\n\n\trkisp1_rsz_init_config(sd, &state);\n\treturn 0;\n\nerror:\n\tmedia_entity_cleanup(&sd->entity);\n\tmutex_destroy(&rsz->ops_lock);\n\treturn ret;\n}\n\nint rkisp1_resizer_devs_register(struct rkisp1_device *rkisp1)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(rkisp1->resizer_devs); i++) {\n\t\tstruct rkisp1_resizer *rsz = &rkisp1->resizer_devs[i];\n\n\t\trsz->rkisp1 = rkisp1;\n\t\trsz->id = i;\n\n\t\tret = rkisp1_rsz_register(rsz);\n\t\tif (ret) {\n\t\t\trsz->rkisp1 = NULL;\n\t\t\trkisp1_resizer_devs_unregister(rkisp1);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid rkisp1_resizer_devs_unregister(struct rkisp1_device *rkisp1)\n{\n\tstruct rkisp1_resizer *mp = &rkisp1->resizer_devs[RKISP1_MAINPATH];\n\tstruct rkisp1_resizer *sp = &rkisp1->resizer_devs[RKISP1_SELFPATH];\n\n\trkisp1_rsz_unregister(mp);\n\trkisp1_rsz_unregister(sp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}