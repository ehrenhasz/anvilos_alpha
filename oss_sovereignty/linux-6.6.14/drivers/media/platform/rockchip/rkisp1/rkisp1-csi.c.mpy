{
  "module_name": "rkisp1-csi.c",
  "hash_id": "c400f3f76b67cdce543859ef5b418f6017d5f7bae18b44426c25d7409a812b3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/rockchip/rkisp1/rkisp1-csi.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/lockdep.h>\n#include <linux/phy/phy.h>\n#include <linux/phy/phy-mipi-dphy.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n\n#include \"rkisp1-common.h\"\n#include \"rkisp1-csi.h\"\n\n#define RKISP1_CSI_DEV_NAME\tRKISP1_DRIVER_NAME \"_csi\"\n\n#define RKISP1_CSI_DEF_FMT\tMEDIA_BUS_FMT_SRGGB10_1X10\n\nstatic inline struct rkisp1_csi *to_rkisp1_csi(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct rkisp1_csi, sd);\n}\n\nstatic struct v4l2_mbus_framefmt *\nrkisp1_csi_get_pad_fmt(struct rkisp1_csi *csi,\n\t\t       struct v4l2_subdev_state *sd_state,\n\t\t       unsigned int pad, u32 which)\n{\n\tstruct v4l2_subdev_state state = {\n\t\t.pads = csi->pad_cfg\n\t};\n\n\tlockdep_assert_held(&csi->lock);\n\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&csi->sd, sd_state, pad);\n\telse\n\t\treturn v4l2_subdev_get_try_format(&csi->sd, &state, pad);\n}\n\nint rkisp1_csi_link_sensor(struct rkisp1_device *rkisp1, struct v4l2_subdev *sd,\n\t\t\t   struct rkisp1_sensor_async *s_asd,\n\t\t\t   unsigned int source_pad)\n{\n\tstruct rkisp1_csi *csi = &rkisp1->csi;\n\tint ret;\n\n\ts_asd->pixel_rate_ctrl = v4l2_ctrl_find(sd->ctrl_handler,\n\t\t\t\t\t\tV4L2_CID_PIXEL_RATE);\n\tif (!s_asd->pixel_rate_ctrl) {\n\t\tdev_err(rkisp1->dev, \"No pixel rate control in subdev %s\\n\",\n\t\t\tsd->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = media_create_pad_link(&sd->entity, source_pad,\n\t\t\t\t    &csi->sd.entity, RKISP1_CSI_PAD_SINK,\n\t\t\t\t    !s_asd->index ? MEDIA_LNK_FL_ENABLED : 0);\n\tif (ret) {\n\t\tdev_err(csi->rkisp1->dev, \"failed to link src pad of %s\\n\",\n\t\t\tsd->name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rkisp1_csi_config(struct rkisp1_csi *csi,\n\t\t\t     const struct rkisp1_sensor_async *sensor)\n{\n\tstruct rkisp1_device *rkisp1 = csi->rkisp1;\n\tunsigned int lanes = sensor->lanes;\n\tu32 mipi_ctrl;\n\n\tif (lanes < 1 || lanes > 4)\n\t\treturn -EINVAL;\n\n\tmipi_ctrl = RKISP1_CIF_MIPI_CTRL_NUM_LANES(lanes - 1) |\n\t\t    RKISP1_CIF_MIPI_CTRL_SHUTDOWNLANES(0xf) |\n\t\t    RKISP1_CIF_MIPI_CTRL_ERR_SOT_SYNC_HS_SKIP |\n\t\t    RKISP1_CIF_MIPI_CTRL_CLOCKLANE_ENA;\n\n\trkisp1_write(rkisp1, RKISP1_CIF_MIPI_CTRL, mipi_ctrl);\n\n\t \n\tif (rkisp1->info->isp_ver == RKISP1_V12)\n\t\trkisp1_write(rkisp1, RKISP1_CIF_ISP_CSI0_CTRL0, 0);\n\n\t \n\trkisp1_write(rkisp1, RKISP1_CIF_MIPI_IMG_DATA_SEL,\n\t\t     RKISP1_CIF_MIPI_DATA_SEL_DT(csi->sink_fmt->mipi_dt) |\n\t\t     RKISP1_CIF_MIPI_DATA_SEL_VC(0));\n\n\t \n\trkisp1_write(rkisp1, RKISP1_CIF_MIPI_ICR, ~0);\n\n\t \n\trkisp1_write(rkisp1, RKISP1_CIF_MIPI_IMSC,\n\t\t     RKISP1_CIF_MIPI_FRAME_END | RKISP1_CIF_MIPI_ERR_CSI |\n\t\t     RKISP1_CIF_MIPI_ERR_DPHY |\n\t\t     RKISP1_CIF_MIPI_SYNC_FIFO_OVFLW(0x03) |\n\t\t     RKISP1_CIF_MIPI_ADD_DATA_OVFLW);\n\n\tdev_dbg(rkisp1->dev, \"\\n  MIPI_CTRL 0x%08x\\n\"\n\t\t\"  MIPI_IMG_DATA_SEL 0x%08x\\n\"\n\t\t\"  MIPI_STATUS 0x%08x\\n\"\n\t\t\"  MIPI_IMSC 0x%08x\\n\",\n\t\trkisp1_read(rkisp1, RKISP1_CIF_MIPI_CTRL),\n\t\trkisp1_read(rkisp1, RKISP1_CIF_MIPI_IMG_DATA_SEL),\n\t\trkisp1_read(rkisp1, RKISP1_CIF_MIPI_STATUS),\n\t\trkisp1_read(rkisp1, RKISP1_CIF_MIPI_IMSC));\n\n\treturn 0;\n}\n\nstatic void rkisp1_csi_enable(struct rkisp1_csi *csi)\n{\n\tstruct rkisp1_device *rkisp1 = csi->rkisp1;\n\tu32 val;\n\n\tval = rkisp1_read(rkisp1, RKISP1_CIF_MIPI_CTRL);\n\trkisp1_write(rkisp1, RKISP1_CIF_MIPI_CTRL,\n\t\t     val | RKISP1_CIF_MIPI_CTRL_OUTPUT_ENA);\n}\n\nstatic void rkisp1_csi_disable(struct rkisp1_csi *csi)\n{\n\tstruct rkisp1_device *rkisp1 = csi->rkisp1;\n\tu32 val;\n\n\t \n\trkisp1_write(rkisp1, RKISP1_CIF_MIPI_IMSC, 0);\n\trkisp1_write(rkisp1, RKISP1_CIF_MIPI_ICR, ~0);\n\n\tval = rkisp1_read(rkisp1, RKISP1_CIF_MIPI_CTRL);\n\trkisp1_write(rkisp1, RKISP1_CIF_MIPI_CTRL,\n\t\t     val & (~RKISP1_CIF_MIPI_CTRL_OUTPUT_ENA));\n}\n\nstatic int rkisp1_csi_start(struct rkisp1_csi *csi,\n\t\t\t    const struct rkisp1_sensor_async *sensor)\n{\n\tstruct rkisp1_device *rkisp1 = csi->rkisp1;\n\tunion phy_configure_opts opts;\n\tstruct phy_configure_opts_mipi_dphy *cfg = &opts.mipi_dphy;\n\ts64 pixel_clock;\n\tint ret;\n\n\tret = rkisp1_csi_config(csi, sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tpixel_clock = v4l2_ctrl_g_ctrl_int64(sensor->pixel_rate_ctrl);\n\tif (!pixel_clock) {\n\t\tdev_err(rkisp1->dev, \"Invalid pixel rate value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tphy_mipi_dphy_get_default_config(pixel_clock, csi->sink_fmt->bus_width,\n\t\t\t\t\t sensor->lanes, cfg);\n\tphy_set_mode(csi->dphy, PHY_MODE_MIPI_DPHY);\n\tphy_configure(csi->dphy, &opts);\n\tphy_power_on(csi->dphy);\n\n\trkisp1_csi_enable(csi);\n\n\t \n\tusleep_range(1000, 1200);\n\n\treturn 0;\n}\n\nstatic void rkisp1_csi_stop(struct rkisp1_csi *csi)\n{\n\trkisp1_csi_disable(csi);\n\n\tphy_power_off(csi->dphy);\n}\n\nirqreturn_t rkisp1_csi_isr(int irq, void *ctx)\n{\n\tstruct device *dev = ctx;\n\tstruct rkisp1_device *rkisp1 = dev_get_drvdata(dev);\n\tu32 val, status;\n\n\tstatus = rkisp1_read(rkisp1, RKISP1_CIF_MIPI_MIS);\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\trkisp1_write(rkisp1, RKISP1_CIF_MIPI_ICR, status);\n\n\t \n\tif (status & RKISP1_CIF_MIPI_ERR_CTRL(0x0f)) {\n\t\tval = rkisp1_read(rkisp1, RKISP1_CIF_MIPI_IMSC);\n\t\trkisp1_write(rkisp1, RKISP1_CIF_MIPI_IMSC,\n\t\t\t     val & ~RKISP1_CIF_MIPI_ERR_CTRL(0x0f));\n\t\trkisp1->csi.is_dphy_errctrl_disabled = true;\n\t}\n\n\t \n\tif (status == RKISP1_CIF_MIPI_FRAME_END) {\n\t\t \n\t\tif (rkisp1->csi.is_dphy_errctrl_disabled) {\n\t\t\tval = rkisp1_read(rkisp1, RKISP1_CIF_MIPI_IMSC);\n\t\t\tval |= RKISP1_CIF_MIPI_ERR_CTRL(0x0f);\n\t\t\trkisp1_write(rkisp1, RKISP1_CIF_MIPI_IMSC, val);\n\t\t\trkisp1->csi.is_dphy_errctrl_disabled = false;\n\t\t}\n\t} else {\n\t\trkisp1->debug.mipi_error++;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int rkisp1_csi_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct rkisp1_csi *csi = to_rkisp1_csi(sd);\n\tunsigned int i;\n\tint pos = 0;\n\n\tif (code->pad == RKISP1_CSI_PAD_SRC) {\n\t\tconst struct v4l2_mbus_framefmt *sink_fmt;\n\n\t\tif (code->index)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&csi->lock);\n\n\t\tsink_fmt = rkisp1_csi_get_pad_fmt(csi, sd_state,\n\t\t\t\t\t\t  RKISP1_CSI_PAD_SINK,\n\t\t\t\t\t\t  code->which);\n\t\tcode->code = sink_fmt->code;\n\n\t\tmutex_unlock(&csi->lock);\n\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct rkisp1_mbus_info *fmt =\n\t\t\trkisp1_mbus_info_get_by_index(i);\n\n\t\tif (!fmt)\n\t\t\treturn -EINVAL;\n\n\t\tif (!(fmt->direction & RKISP1_ISP_SD_SINK))\n\t\t\tcontinue;\n\n\t\tif (code->index == pos) {\n\t\t\tcode->code = fmt->mbus_code;\n\t\t\treturn 0;\n\t\t}\n\n\t\tpos++;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int rkisp1_csi_init_config(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_mbus_framefmt *sink_fmt, *src_fmt;\n\n\tsink_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t      RKISP1_CSI_PAD_SINK);\n\tsrc_fmt = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t     RKISP1_CSI_PAD_SRC);\n\n\tsink_fmt->width = RKISP1_DEFAULT_WIDTH;\n\tsink_fmt->height = RKISP1_DEFAULT_HEIGHT;\n\tsink_fmt->field = V4L2_FIELD_NONE;\n\tsink_fmt->code = RKISP1_CSI_DEF_FMT;\n\n\t*src_fmt = *sink_fmt;\n\n\treturn 0;\n}\n\nstatic int rkisp1_csi_get_fmt(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct rkisp1_csi *csi = to_rkisp1_csi(sd);\n\n\tmutex_lock(&csi->lock);\n\tfmt->format = *rkisp1_csi_get_pad_fmt(csi, sd_state, fmt->pad,\n\t\t\t\t\t      fmt->which);\n\tmutex_unlock(&csi->lock);\n\n\treturn 0;\n}\n\nstatic int rkisp1_csi_set_fmt(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_format *fmt)\n{\n\tstruct rkisp1_csi *csi = to_rkisp1_csi(sd);\n\tconst struct rkisp1_mbus_info *mbus_info;\n\tstruct v4l2_mbus_framefmt *sink_fmt, *src_fmt;\n\n\t \n\tif (fmt->pad == RKISP1_CSI_PAD_SRC)\n\t\treturn rkisp1_csi_get_fmt(sd, sd_state, fmt);\n\n\tmutex_lock(&csi->lock);\n\n\tsink_fmt = rkisp1_csi_get_pad_fmt(csi, sd_state, RKISP1_CSI_PAD_SINK,\n\t\t\t\t\t  fmt->which);\n\n\tsink_fmt->code = fmt->format.code;\n\n\tmbus_info = rkisp1_mbus_info_get_by_code(sink_fmt->code);\n\tif (!mbus_info || !(mbus_info->direction & RKISP1_ISP_SD_SINK)) {\n\t\tsink_fmt->code = RKISP1_CSI_DEF_FMT;\n\t\tmbus_info = rkisp1_mbus_info_get_by_code(sink_fmt->code);\n\t}\n\n\tsink_fmt->width = clamp_t(u32, fmt->format.width,\n\t\t\t\t  RKISP1_ISP_MIN_WIDTH,\n\t\t\t\t  RKISP1_ISP_MAX_WIDTH);\n\tsink_fmt->height = clamp_t(u32, fmt->format.height,\n\t\t\t\t   RKISP1_ISP_MIN_HEIGHT,\n\t\t\t\t   RKISP1_ISP_MAX_HEIGHT);\n\n\tfmt->format = *sink_fmt;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\tcsi->sink_fmt = mbus_info;\n\n\t \n\tsrc_fmt = rkisp1_csi_get_pad_fmt(csi, sd_state, RKISP1_CSI_PAD_SRC,\n\t\t\t\t\t fmt->which);\n\t*src_fmt = *sink_fmt;\n\n\tmutex_unlock(&csi->lock);\n\n\treturn 0;\n}\n\n \n\nstatic int rkisp1_csi_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct rkisp1_csi *csi = to_rkisp1_csi(sd);\n\tstruct rkisp1_device *rkisp1 = csi->rkisp1;\n\tstruct rkisp1_sensor_async *source_asd;\n\tstruct v4l2_async_connection *asc;\n\tstruct media_pad *source_pad;\n\tstruct v4l2_subdev *source;\n\tint ret;\n\n\tif (!enable) {\n\t\tv4l2_subdev_call(csi->source, video, s_stream, false);\n\n\t\trkisp1_csi_stop(csi);\n\n\t\treturn 0;\n\t}\n\n\tsource_pad = media_entity_remote_source_pad_unique(&sd->entity);\n\tif (IS_ERR(source_pad)) {\n\t\tdev_dbg(rkisp1->dev, \"Failed to get source for CSI: %ld\\n\",\n\t\t\tPTR_ERR(source_pad));\n\t\treturn -EPIPE;\n\t}\n\n\tsource = media_entity_to_v4l2_subdev(source_pad->entity);\n\tif (!source) {\n\t\t \n\t\treturn -EPIPE;\n\t}\n\n\tasc = v4l2_async_connection_unique(source);\n\tif (!asc)\n\t\treturn -EPIPE;\n\n\tsource_asd = container_of(asc, struct rkisp1_sensor_async, asd);\n\tif (source_asd->mbus_type != V4L2_MBUS_CSI2_DPHY)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&csi->lock);\n\tret = rkisp1_csi_start(csi, source_asd);\n\tmutex_unlock(&csi->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_subdev_call(source, video, s_stream, true);\n\tif (ret) {\n\t\trkisp1_csi_stop(csi);\n\t\treturn ret;\n\t}\n\n\tcsi->source = source;\n\n\treturn 0;\n}\n\n \n\nstatic const struct media_entity_operations rkisp1_csi_media_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic const struct v4l2_subdev_video_ops rkisp1_csi_video_ops = {\n\t.s_stream = rkisp1_csi_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops rkisp1_csi_pad_ops = {\n\t.enum_mbus_code = rkisp1_csi_enum_mbus_code,\n\t.init_cfg = rkisp1_csi_init_config,\n\t.get_fmt = rkisp1_csi_get_fmt,\n\t.set_fmt = rkisp1_csi_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops rkisp1_csi_ops = {\n\t.video = &rkisp1_csi_video_ops,\n\t.pad = &rkisp1_csi_pad_ops,\n};\n\nint rkisp1_csi_register(struct rkisp1_device *rkisp1)\n{\n\tstruct rkisp1_csi *csi = &rkisp1->csi;\n\tstruct v4l2_subdev_state state = {};\n\tstruct media_pad *pads;\n\tstruct v4l2_subdev *sd;\n\tint ret;\n\n\tcsi->rkisp1 = rkisp1;\n\tmutex_init(&csi->lock);\n\n\tsd = &csi->sd;\n\tv4l2_subdev_init(sd, &rkisp1_csi_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsd->entity.ops = &rkisp1_csi_media_ops;\n\tsd->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tsd->owner = THIS_MODULE;\n\tstrscpy(sd->name, RKISP1_CSI_DEV_NAME, sizeof(sd->name));\n\n\tpads = csi->pads;\n\tpads[RKISP1_CSI_PAD_SINK].flags = MEDIA_PAD_FL_SINK |\n\t\t\t\t\t  MEDIA_PAD_FL_MUST_CONNECT;\n\tpads[RKISP1_CSI_PAD_SRC].flags = MEDIA_PAD_FL_SOURCE |\n\t\t\t\t\t MEDIA_PAD_FL_MUST_CONNECT;\n\n\tcsi->sink_fmt = rkisp1_mbus_info_get_by_code(RKISP1_CSI_DEF_FMT);\n\n\tret = media_entity_pads_init(&sd->entity, RKISP1_CSI_PAD_NUM, pads);\n\tif (ret)\n\t\tgoto error;\n\n\tstate.pads = csi->pad_cfg;\n\trkisp1_csi_init_config(sd, &state);\n\n\tret = v4l2_device_register_subdev(&csi->rkisp1->v4l2_dev, sd);\n\tif (ret) {\n\t\tdev_err(sd->dev, \"Failed to register csi receiver subdev\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tmedia_entity_cleanup(&sd->entity);\n\tmutex_destroy(&csi->lock);\n\tcsi->rkisp1 = NULL;\n\treturn ret;\n}\n\nvoid rkisp1_csi_unregister(struct rkisp1_device *rkisp1)\n{\n\tstruct rkisp1_csi *csi = &rkisp1->csi;\n\n\tif (!csi->rkisp1)\n\t\treturn;\n\n\tv4l2_device_unregister_subdev(&csi->sd);\n\tmedia_entity_cleanup(&csi->sd.entity);\n\tmutex_destroy(&csi->lock);\n}\n\nint rkisp1_csi_init(struct rkisp1_device *rkisp1)\n{\n\tstruct rkisp1_csi *csi = &rkisp1->csi;\n\n\tcsi->rkisp1 = rkisp1;\n\n\tcsi->dphy = devm_phy_get(rkisp1->dev, \"dphy\");\n\tif (IS_ERR(csi->dphy))\n\t\treturn dev_err_probe(rkisp1->dev, PTR_ERR(csi->dphy),\n\t\t\t\t     \"Couldn't get the MIPI D-PHY\\n\");\n\n\tphy_init(csi->dphy);\n\n\treturn 0;\n}\n\nvoid rkisp1_csi_cleanup(struct rkisp1_device *rkisp1)\n{\n\tstruct rkisp1_csi *csi = &rkisp1->csi;\n\n\tphy_exit(csi->dphy);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}