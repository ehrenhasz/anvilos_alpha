{
  "module_name": "rkisp1-capture.c",
  "hash_id": "c189688d63bfc24fdb1699f771e4ed8e9496ac2c04aed23231e7469f2d1a9fc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/rockchip/rkisp1/rkisp1-capture.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"rkisp1-common.h\"\n\n \n\n#define RKISP1_SP_DEV_NAME\tRKISP1_DRIVER_NAME \"_selfpath\"\n#define RKISP1_MP_DEV_NAME\tRKISP1_DRIVER_NAME \"_mainpath\"\n\n#define RKISP1_MIN_BUFFERS_NEEDED 3\n\nenum rkisp1_plane {\n\tRKISP1_PLANE_Y\t= 0,\n\tRKISP1_PLANE_CB\t= 1,\n\tRKISP1_PLANE_CR\t= 2\n};\n\n \nstruct rkisp1_capture_fmt_cfg {\n\tu32 fourcc;\n\tu8 uv_swap;\n\tu32 write_format;\n\tu32 output_format;\n\tu32 mbus;\n};\n\nstruct rkisp1_capture_ops {\n\tvoid (*config)(struct rkisp1_capture *cap);\n\tvoid (*stop)(struct rkisp1_capture *cap);\n\tvoid (*enable)(struct rkisp1_capture *cap);\n\tvoid (*disable)(struct rkisp1_capture *cap);\n\tvoid (*set_data_path)(struct rkisp1_capture *cap);\n\tbool (*is_stopped)(struct rkisp1_capture *cap);\n};\n\nstruct rkisp1_capture_config {\n\tconst struct rkisp1_capture_fmt_cfg *fmts;\n\tint fmt_size;\n\tstruct {\n\t\tu32 y_size_init;\n\t\tu32 cb_size_init;\n\t\tu32 cr_size_init;\n\t\tu32 y_base_ad_init;\n\t\tu32 cb_base_ad_init;\n\t\tu32 cr_base_ad_init;\n\t\tu32 y_offs_cnt_init;\n\t\tu32 cb_offs_cnt_init;\n\t\tu32 cr_offs_cnt_init;\n\t} mi;\n};\n\n \nstatic const struct rkisp1_capture_fmt_cfg rkisp1_mp_fmts[] = {\n\t \n\t{\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUVINT,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUV422P,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_PLA_OR_RAW8,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV16,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_SPLA,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV61,\n\t\t.uv_swap = 1,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_SPLA,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV16M,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_SPLA,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV61M,\n\t\t.uv_swap = 1,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_SPLA,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YVU422M,\n\t\t.uv_swap = 1,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_PLA_OR_RAW8,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t},\n\t \n\t{\n\t\t.fourcc = V4L2_PIX_FMT_GREY,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_PLA_OR_RAW8,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t},\n\t \n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV21,\n\t\t.uv_swap = 1,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_SPLA,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV12,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_SPLA,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV21M,\n\t\t.uv_swap = 1,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_SPLA,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV12M,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_SPLA,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUV420,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_PLA_OR_RAW8,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YVU420,\n\t\t.uv_swap = 1,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_PLA_OR_RAW8,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t},\n\t \n\t{\n\t\t.fourcc = V4L2_PIX_FMT_SRGGB8,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_PLA_OR_RAW8,\n\t\t.mbus = MEDIA_BUS_FMT_SRGGB8_1X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGRBG8,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_PLA_OR_RAW8,\n\t\t.mbus = MEDIA_BUS_FMT_SGRBG8_1X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGBRG8,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_PLA_OR_RAW8,\n\t\t.mbus = MEDIA_BUS_FMT_SGBRG8_1X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SBGGR8,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_YUV_PLA_OR_RAW8,\n\t\t.mbus = MEDIA_BUS_FMT_SBGGR8_1X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SRGGB10,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_RAW12,\n\t\t.mbus = MEDIA_BUS_FMT_SRGGB10_1X10,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGRBG10,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_RAW12,\n\t\t.mbus = MEDIA_BUS_FMT_SGRBG10_1X10,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGBRG10,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_RAW12,\n\t\t.mbus = MEDIA_BUS_FMT_SGBRG10_1X10,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SBGGR10,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_RAW12,\n\t\t.mbus = MEDIA_BUS_FMT_SBGGR10_1X10,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SRGGB12,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_RAW12,\n\t\t.mbus = MEDIA_BUS_FMT_SRGGB12_1X12,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGRBG12,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_RAW12,\n\t\t.mbus = MEDIA_BUS_FMT_SGRBG12_1X12,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGBRG12,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_RAW12,\n\t\t.mbus = MEDIA_BUS_FMT_SGBRG12_1X12,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SBGGR12,\n\t\t.write_format = RKISP1_MI_CTRL_MP_WRITE_RAW12,\n\t\t.mbus = MEDIA_BUS_FMT_SBGGR12_1X12,\n\t},\n};\n\n \nstatic const struct rkisp1_capture_fmt_cfg rkisp1_sp_fmts[] = {\n\t \n\t{\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_INT,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV422,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUV422P,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_PLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV422,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV16,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_SPLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV422,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV61,\n\t\t.uv_swap = 1,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_SPLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV422,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV16M,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_SPLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV422,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV61M,\n\t\t.uv_swap = 1,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_SPLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV422,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YVU422M,\n\t\t.uv_swap = 1,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_PLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV422,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t},\n\t \n\t{\n\t\t.fourcc = V4L2_PIX_FMT_GREY,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_PLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV422,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t},\n\t \n\t{\n\t\t.fourcc = V4L2_PIX_FMT_XBGR32,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_PLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_RGB888,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_RGB565,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_PLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_RGB565,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_2X8,\n\t},\n\t \n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV21,\n\t\t.uv_swap = 1,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_SPLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV420,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV12,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_SPLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV420,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV21M,\n\t\t.uv_swap = 1,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_SPLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV420,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV12M,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_SPLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV420,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUV420,\n\t\t.uv_swap = 0,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_PLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV420,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YVU420,\n\t\t.uv_swap = 1,\n\t\t.write_format = RKISP1_MI_CTRL_SP_WRITE_PLA,\n\t\t.output_format = RKISP1_MI_CTRL_SP_OUTPUT_YUV420,\n\t\t.mbus = MEDIA_BUS_FMT_YUYV8_1_5X8,\n\t},\n};\n\nstatic const struct rkisp1_capture_config rkisp1_capture_config_mp = {\n\t.fmts = rkisp1_mp_fmts,\n\t.fmt_size = ARRAY_SIZE(rkisp1_mp_fmts),\n\t.mi = {\n\t\t.y_size_init =\t\tRKISP1_CIF_MI_MP_Y_SIZE_INIT,\n\t\t.cb_size_init =\t\tRKISP1_CIF_MI_MP_CB_SIZE_INIT,\n\t\t.cr_size_init =\t\tRKISP1_CIF_MI_MP_CR_SIZE_INIT,\n\t\t.y_base_ad_init =\tRKISP1_CIF_MI_MP_Y_BASE_AD_INIT,\n\t\t.cb_base_ad_init =\tRKISP1_CIF_MI_MP_CB_BASE_AD_INIT,\n\t\t.cr_base_ad_init =\tRKISP1_CIF_MI_MP_CR_BASE_AD_INIT,\n\t\t.y_offs_cnt_init =\tRKISP1_CIF_MI_MP_Y_OFFS_CNT_INIT,\n\t\t.cb_offs_cnt_init =\tRKISP1_CIF_MI_MP_CB_OFFS_CNT_INIT,\n\t\t.cr_offs_cnt_init =\tRKISP1_CIF_MI_MP_CR_OFFS_CNT_INIT,\n\t},\n};\n\nstatic const struct rkisp1_capture_config rkisp1_capture_config_sp = {\n\t.fmts = rkisp1_sp_fmts,\n\t.fmt_size = ARRAY_SIZE(rkisp1_sp_fmts),\n\t.mi = {\n\t\t.y_size_init =\t\tRKISP1_CIF_MI_SP_Y_SIZE_INIT,\n\t\t.cb_size_init =\t\tRKISP1_CIF_MI_SP_CB_SIZE_INIT,\n\t\t.cr_size_init =\t\tRKISP1_CIF_MI_SP_CR_SIZE_INIT,\n\t\t.y_base_ad_init =\tRKISP1_CIF_MI_SP_Y_BASE_AD_INIT,\n\t\t.cb_base_ad_init =\tRKISP1_CIF_MI_SP_CB_BASE_AD_INIT,\n\t\t.cr_base_ad_init =\tRKISP1_CIF_MI_SP_CR_BASE_AD_INIT,\n\t\t.y_offs_cnt_init =\tRKISP1_CIF_MI_SP_Y_OFFS_CNT_INIT,\n\t\t.cb_offs_cnt_init =\tRKISP1_CIF_MI_SP_CB_OFFS_CNT_INIT,\n\t\t.cr_offs_cnt_init =\tRKISP1_CIF_MI_SP_CR_OFFS_CNT_INIT,\n\t},\n};\n\nstatic inline struct rkisp1_vdev_node *\nrkisp1_vdev_to_node(struct video_device *vdev)\n{\n\treturn container_of(vdev, struct rkisp1_vdev_node, vdev);\n}\n\nint rkisp1_cap_enum_mbus_codes(struct rkisp1_capture *cap,\n\t\t\t       struct v4l2_subdev_mbus_code_enum *code)\n{\n\tconst struct rkisp1_capture_fmt_cfg *fmts = cap->config->fmts;\n\t \n\tu32 curr_mbus = 0;\n\tint i, n = 0;\n\n\tfor (i = 0; i < cap->config->fmt_size; i++) {\n\t\tif (fmts[i].mbus == curr_mbus)\n\t\t\tcontinue;\n\n\t\tcurr_mbus = fmts[i].mbus;\n\t\tif (n++ == code->index) {\n\t\t\tcode->code = curr_mbus;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n \n\nstatic void rkisp1_mi_config_ctrl(struct rkisp1_capture *cap)\n{\n\tu32 mi_ctrl = rkisp1_read(cap->rkisp1, RKISP1_CIF_MI_CTRL);\n\n\tmi_ctrl &= ~GENMASK(17, 16);\n\tmi_ctrl |= RKISP1_CIF_MI_CTRL_BURST_LEN_LUM_64;\n\n\tmi_ctrl &= ~GENMASK(19, 18);\n\tmi_ctrl |= RKISP1_CIF_MI_CTRL_BURST_LEN_CHROM_64;\n\n\tmi_ctrl |= RKISP1_CIF_MI_CTRL_INIT_BASE_EN |\n\t\t   RKISP1_CIF_MI_CTRL_INIT_OFFSET_EN;\n\n\trkisp1_write(cap->rkisp1, RKISP1_CIF_MI_CTRL, mi_ctrl);\n}\n\nstatic u32 rkisp1_pixfmt_comp_size(const struct v4l2_pix_format_mplane *pixm,\n\t\t\t\t   unsigned int component)\n{\n\t \n\tif (!component && pixm->num_planes == 1)\n\t\treturn pixm->plane_fmt[0].bytesperline * pixm->height;\n\treturn pixm->plane_fmt[component].sizeimage;\n}\n\nstatic void rkisp1_irq_frame_end_enable(struct rkisp1_capture *cap)\n{\n\tu32 mi_imsc = rkisp1_read(cap->rkisp1, RKISP1_CIF_MI_IMSC);\n\n\tmi_imsc |= RKISP1_CIF_MI_FRAME(cap);\n\trkisp1_write(cap->rkisp1, RKISP1_CIF_MI_IMSC, mi_imsc);\n}\n\nstatic void rkisp1_mp_config(struct rkisp1_capture *cap)\n{\n\tconst struct v4l2_pix_format_mplane *pixm = &cap->pix.fmt;\n\tstruct rkisp1_device *rkisp1 = cap->rkisp1;\n\tu32 reg;\n\n\trkisp1_write(rkisp1, cap->config->mi.y_size_init,\n\t\t     rkisp1_pixfmt_comp_size(pixm, RKISP1_PLANE_Y));\n\trkisp1_write(rkisp1, cap->config->mi.cb_size_init,\n\t\t     rkisp1_pixfmt_comp_size(pixm, RKISP1_PLANE_CB));\n\trkisp1_write(rkisp1, cap->config->mi.cr_size_init,\n\t\t     rkisp1_pixfmt_comp_size(pixm, RKISP1_PLANE_CR));\n\n\trkisp1_irq_frame_end_enable(cap);\n\n\t \n\tif (cap->pix.info->comp_planes == 2) {\n\t\treg = rkisp1_read(rkisp1, RKISP1_CIF_MI_XTD_FORMAT_CTRL);\n\t\tif (cap->pix.cfg->uv_swap)\n\t\t\treg |= RKISP1_CIF_MI_XTD_FMT_CTRL_MP_CB_CR_SWAP;\n\t\telse\n\t\t\treg &= ~RKISP1_CIF_MI_XTD_FMT_CTRL_MP_CB_CR_SWAP;\n\t\trkisp1_write(rkisp1, RKISP1_CIF_MI_XTD_FORMAT_CTRL, reg);\n\t}\n\n\trkisp1_mi_config_ctrl(cap);\n\n\treg = rkisp1_read(rkisp1, RKISP1_CIF_MI_CTRL);\n\treg &= ~RKISP1_MI_CTRL_MP_FMT_MASK;\n\treg |= cap->pix.cfg->write_format;\n\trkisp1_write(rkisp1, RKISP1_CIF_MI_CTRL, reg);\n\n\treg = rkisp1_read(rkisp1, RKISP1_CIF_MI_CTRL);\n\treg |= RKISP1_CIF_MI_MP_AUTOUPDATE_ENABLE;\n\trkisp1_write(rkisp1, RKISP1_CIF_MI_CTRL, reg);\n}\n\nstatic void rkisp1_sp_config(struct rkisp1_capture *cap)\n{\n\tconst struct v4l2_pix_format_mplane *pixm = &cap->pix.fmt;\n\tstruct rkisp1_device *rkisp1 = cap->rkisp1;\n\tu32 mi_ctrl, reg;\n\n\trkisp1_write(rkisp1, cap->config->mi.y_size_init,\n\t\t     rkisp1_pixfmt_comp_size(pixm, RKISP1_PLANE_Y));\n\trkisp1_write(rkisp1, cap->config->mi.cb_size_init,\n\t\t     rkisp1_pixfmt_comp_size(pixm, RKISP1_PLANE_CB));\n\trkisp1_write(rkisp1, cap->config->mi.cr_size_init,\n\t\t     rkisp1_pixfmt_comp_size(pixm, RKISP1_PLANE_CR));\n\n\trkisp1_write(rkisp1, RKISP1_CIF_MI_SP_Y_PIC_WIDTH, pixm->width);\n\trkisp1_write(rkisp1, RKISP1_CIF_MI_SP_Y_PIC_HEIGHT, pixm->height);\n\trkisp1_write(rkisp1, RKISP1_CIF_MI_SP_Y_LLENGTH, cap->sp_y_stride);\n\n\trkisp1_irq_frame_end_enable(cap);\n\n\t \n\tif (cap->pix.info->comp_planes == 2) {\n\t\treg = rkisp1_read(rkisp1, RKISP1_CIF_MI_XTD_FORMAT_CTRL);\n\t\tif (cap->pix.cfg->uv_swap)\n\t\t\treg |= RKISP1_CIF_MI_XTD_FMT_CTRL_SP_CB_CR_SWAP;\n\t\telse\n\t\t\treg &= ~RKISP1_CIF_MI_XTD_FMT_CTRL_SP_CB_CR_SWAP;\n\t\trkisp1_write(rkisp1, RKISP1_CIF_MI_XTD_FORMAT_CTRL, reg);\n\t}\n\n\trkisp1_mi_config_ctrl(cap);\n\n\tmi_ctrl = rkisp1_read(rkisp1, RKISP1_CIF_MI_CTRL);\n\tmi_ctrl &= ~RKISP1_MI_CTRL_SP_FMT_MASK;\n\tmi_ctrl |= cap->pix.cfg->write_format |\n\t\t   RKISP1_MI_CTRL_SP_INPUT_YUV422 |\n\t\t   cap->pix.cfg->output_format |\n\t\t   RKISP1_CIF_MI_SP_AUTOUPDATE_ENABLE;\n\trkisp1_write(rkisp1, RKISP1_CIF_MI_CTRL, mi_ctrl);\n}\n\nstatic void rkisp1_mp_disable(struct rkisp1_capture *cap)\n{\n\tu32 mi_ctrl = rkisp1_read(cap->rkisp1, RKISP1_CIF_MI_CTRL);\n\n\tmi_ctrl &= ~(RKISP1_CIF_MI_CTRL_MP_ENABLE |\n\t\t     RKISP1_CIF_MI_CTRL_RAW_ENABLE);\n\trkisp1_write(cap->rkisp1, RKISP1_CIF_MI_CTRL, mi_ctrl);\n}\n\nstatic void rkisp1_sp_disable(struct rkisp1_capture *cap)\n{\n\tu32 mi_ctrl = rkisp1_read(cap->rkisp1, RKISP1_CIF_MI_CTRL);\n\n\tmi_ctrl &= ~RKISP1_CIF_MI_CTRL_SP_ENABLE;\n\trkisp1_write(cap->rkisp1, RKISP1_CIF_MI_CTRL, mi_ctrl);\n}\n\nstatic void rkisp1_mp_enable(struct rkisp1_capture *cap)\n{\n\tu32 mi_ctrl;\n\n\trkisp1_mp_disable(cap);\n\n\tmi_ctrl = rkisp1_read(cap->rkisp1, RKISP1_CIF_MI_CTRL);\n\tif (v4l2_is_format_bayer(cap->pix.info))\n\t\tmi_ctrl |= RKISP1_CIF_MI_CTRL_RAW_ENABLE;\n\t \n\telse\n\t\tmi_ctrl |= RKISP1_CIF_MI_CTRL_MP_ENABLE;\n\n\trkisp1_write(cap->rkisp1, RKISP1_CIF_MI_CTRL, mi_ctrl);\n}\n\nstatic void rkisp1_sp_enable(struct rkisp1_capture *cap)\n{\n\tu32 mi_ctrl = rkisp1_read(cap->rkisp1, RKISP1_CIF_MI_CTRL);\n\n\tmi_ctrl |= RKISP1_CIF_MI_CTRL_SP_ENABLE;\n\trkisp1_write(cap->rkisp1, RKISP1_CIF_MI_CTRL, mi_ctrl);\n}\n\nstatic void rkisp1_mp_sp_stop(struct rkisp1_capture *cap)\n{\n\tif (!cap->is_streaming)\n\t\treturn;\n\trkisp1_write(cap->rkisp1, RKISP1_CIF_MI_ICR, RKISP1_CIF_MI_FRAME(cap));\n\tcap->ops->disable(cap);\n}\n\nstatic bool rkisp1_mp_is_stopped(struct rkisp1_capture *cap)\n{\n\tu32 en = RKISP1_CIF_MI_CTRL_SHD_MP_IN_ENABLED |\n\t\t RKISP1_CIF_MI_CTRL_SHD_RAW_OUT_ENABLED;\n\n\treturn !(rkisp1_read(cap->rkisp1, RKISP1_CIF_MI_CTRL_SHD) & en);\n}\n\nstatic bool rkisp1_sp_is_stopped(struct rkisp1_capture *cap)\n{\n\treturn !(rkisp1_read(cap->rkisp1, RKISP1_CIF_MI_CTRL_SHD) &\n\t\t RKISP1_CIF_MI_CTRL_SHD_SP_IN_ENABLED);\n}\n\nstatic void rkisp1_mp_set_data_path(struct rkisp1_capture *cap)\n{\n\tu32 dpcl = rkisp1_read(cap->rkisp1, RKISP1_CIF_VI_DPCL);\n\n\tdpcl = dpcl | RKISP1_CIF_VI_DPCL_CHAN_MODE_MP |\n\t       RKISP1_CIF_VI_DPCL_MP_MUX_MRSZ_MI;\n\trkisp1_write(cap->rkisp1, RKISP1_CIF_VI_DPCL, dpcl);\n}\n\nstatic void rkisp1_sp_set_data_path(struct rkisp1_capture *cap)\n{\n\tu32 dpcl = rkisp1_read(cap->rkisp1, RKISP1_CIF_VI_DPCL);\n\n\tdpcl |= RKISP1_CIF_VI_DPCL_CHAN_MODE_SP;\n\trkisp1_write(cap->rkisp1, RKISP1_CIF_VI_DPCL, dpcl);\n}\n\nstatic const struct rkisp1_capture_ops rkisp1_capture_ops_mp = {\n\t.config = rkisp1_mp_config,\n\t.enable = rkisp1_mp_enable,\n\t.disable = rkisp1_mp_disable,\n\t.stop = rkisp1_mp_sp_stop,\n\t.set_data_path = rkisp1_mp_set_data_path,\n\t.is_stopped = rkisp1_mp_is_stopped,\n};\n\nstatic const struct rkisp1_capture_ops rkisp1_capture_ops_sp = {\n\t.config = rkisp1_sp_config,\n\t.enable = rkisp1_sp_enable,\n\t.disable = rkisp1_sp_disable,\n\t.stop = rkisp1_mp_sp_stop,\n\t.set_data_path = rkisp1_sp_set_data_path,\n\t.is_stopped = rkisp1_sp_is_stopped,\n};\n\n \n\nstatic int rkisp1_dummy_buf_create(struct rkisp1_capture *cap)\n{\n\tconst struct v4l2_pix_format_mplane *pixm = &cap->pix.fmt;\n\tstruct rkisp1_dummy_buffer *dummy_buf = &cap->buf.dummy;\n\n\tdummy_buf->size = max3(rkisp1_pixfmt_comp_size(pixm, RKISP1_PLANE_Y),\n\t\t\t       rkisp1_pixfmt_comp_size(pixm, RKISP1_PLANE_CB),\n\t\t\t       rkisp1_pixfmt_comp_size(pixm, RKISP1_PLANE_CR));\n\n\t \n\tdummy_buf->vaddr = dma_alloc_attrs(cap->rkisp1->dev,\n\t\t\t\t\t   dummy_buf->size,\n\t\t\t\t\t   &dummy_buf->dma_addr,\n\t\t\t\t\t   GFP_KERNEL,\n\t\t\t\t\t   DMA_ATTR_NO_KERNEL_MAPPING);\n\tif (!dummy_buf->vaddr)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void rkisp1_dummy_buf_destroy(struct rkisp1_capture *cap)\n{\n\tdma_free_attrs(cap->rkisp1->dev,\n\t\t       cap->buf.dummy.size, cap->buf.dummy.vaddr,\n\t\t       cap->buf.dummy.dma_addr, DMA_ATTR_NO_KERNEL_MAPPING);\n}\n\nstatic void rkisp1_set_next_buf(struct rkisp1_capture *cap)\n{\n\tcap->buf.curr = cap->buf.next;\n\tcap->buf.next = NULL;\n\n\tif (!list_empty(&cap->buf.queue)) {\n\t\tu32 *buff_addr;\n\n\t\tcap->buf.next = list_first_entry(&cap->buf.queue, struct rkisp1_buffer, queue);\n\t\tlist_del(&cap->buf.next->queue);\n\n\t\tbuff_addr = cap->buf.next->buff_addr;\n\n\t\trkisp1_write(cap->rkisp1, cap->config->mi.y_base_ad_init,\n\t\t\t     buff_addr[RKISP1_PLANE_Y]);\n\t\t \n\t\tif (cap->pix.cfg->fourcc == V4L2_PIX_FMT_GREY) {\n\t\t\trkisp1_write(cap->rkisp1,\n\t\t\t\t     cap->config->mi.cb_base_ad_init,\n\t\t\t\t     cap->buf.dummy.dma_addr);\n\t\t\trkisp1_write(cap->rkisp1,\n\t\t\t\t     cap->config->mi.cr_base_ad_init,\n\t\t\t\t     cap->buf.dummy.dma_addr);\n\t\t} else {\n\t\t\trkisp1_write(cap->rkisp1,\n\t\t\t\t     cap->config->mi.cb_base_ad_init,\n\t\t\t\t     buff_addr[RKISP1_PLANE_CB]);\n\t\t\trkisp1_write(cap->rkisp1,\n\t\t\t\t     cap->config->mi.cr_base_ad_init,\n\t\t\t\t     buff_addr[RKISP1_PLANE_CR]);\n\t\t}\n\t} else {\n\t\t \n\t\trkisp1_write(cap->rkisp1, cap->config->mi.y_base_ad_init,\n\t\t\t     cap->buf.dummy.dma_addr);\n\t\trkisp1_write(cap->rkisp1, cap->config->mi.cb_base_ad_init,\n\t\t\t     cap->buf.dummy.dma_addr);\n\t\trkisp1_write(cap->rkisp1, cap->config->mi.cr_base_ad_init,\n\t\t\t     cap->buf.dummy.dma_addr);\n\t}\n\n\t \n\trkisp1_write(cap->rkisp1, cap->config->mi.y_offs_cnt_init, 0);\n\trkisp1_write(cap->rkisp1, cap->config->mi.cb_offs_cnt_init, 0);\n\trkisp1_write(cap->rkisp1, cap->config->mi.cr_offs_cnt_init, 0);\n}\n\n \nstatic void rkisp1_handle_buffer(struct rkisp1_capture *cap)\n{\n\tstruct rkisp1_isp *isp = &cap->rkisp1->isp;\n\tstruct rkisp1_buffer *curr_buf;\n\n\tspin_lock(&cap->buf.lock);\n\tcurr_buf = cap->buf.curr;\n\n\tif (curr_buf) {\n\t\tcurr_buf->vb.sequence = isp->frame_sequence;\n\t\tcurr_buf->vb.vb2_buf.timestamp = ktime_get_boottime_ns();\n\t\tcurr_buf->vb.field = V4L2_FIELD_NONE;\n\t\tvb2_buffer_done(&curr_buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t} else {\n\t\tcap->rkisp1->debug.frame_drop[cap->id]++;\n\t}\n\n\trkisp1_set_next_buf(cap);\n\tspin_unlock(&cap->buf.lock);\n}\n\nirqreturn_t rkisp1_capture_isr(int irq, void *ctx)\n{\n\tstruct device *dev = ctx;\n\tstruct rkisp1_device *rkisp1 = dev_get_drvdata(dev);\n\tunsigned int i;\n\tu32 status;\n\n\tstatus = rkisp1_read(rkisp1, RKISP1_CIF_MI_MIS);\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\trkisp1_write(rkisp1, RKISP1_CIF_MI_ICR, status);\n\n\tfor (i = 0; i < ARRAY_SIZE(rkisp1->capture_devs); ++i) {\n\t\tstruct rkisp1_capture *cap = &rkisp1->capture_devs[i];\n\n\t\tif (!(status & RKISP1_CIF_MI_FRAME(cap)))\n\t\t\tcontinue;\n\t\tif (!cap->is_stopping) {\n\t\t\trkisp1_handle_buffer(cap);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (!cap->ops->is_stopped(cap)) {\n\t\t\tcap->ops->stop(cap);\n\t\t\tcontinue;\n\t\t}\n\t\tcap->is_stopping = false;\n\t\tcap->is_streaming = false;\n\t\twake_up(&cap->done);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int rkisp1_vb2_queue_setup(struct vb2_queue *queue,\n\t\t\t\t  unsigned int *num_buffers,\n\t\t\t\t  unsigned int *num_planes,\n\t\t\t\t  unsigned int sizes[],\n\t\t\t\t  struct device *alloc_devs[])\n{\n\tstruct rkisp1_capture *cap = queue->drv_priv;\n\tconst struct v4l2_pix_format_mplane *pixm = &cap->pix.fmt;\n\tunsigned int i;\n\n\tif (*num_planes) {\n\t\tif (*num_planes != pixm->num_planes)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < pixm->num_planes; i++)\n\t\t\tif (sizes[i] < pixm->plane_fmt[i].sizeimage)\n\t\t\t\treturn -EINVAL;\n\t} else {\n\t\t*num_planes = pixm->num_planes;\n\t\tfor (i = 0; i < pixm->num_planes; i++)\n\t\t\tsizes[i] = pixm->plane_fmt[i].sizeimage;\n\t}\n\n\treturn 0;\n}\n\nstatic int rkisp1_vb2_buf_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct rkisp1_buffer *ispbuf =\n\t\tcontainer_of(vbuf, struct rkisp1_buffer, vb);\n\tstruct rkisp1_capture *cap = vb->vb2_queue->drv_priv;\n\tconst struct v4l2_pix_format_mplane *pixm = &cap->pix.fmt;\n\tunsigned int i;\n\n\tmemset(ispbuf->buff_addr, 0, sizeof(ispbuf->buff_addr));\n\tfor (i = 0; i < pixm->num_planes; i++)\n\t\tispbuf->buff_addr[i] = vb2_dma_contig_plane_dma_addr(vb, i);\n\n\t \n\tif (pixm->num_planes == 1) {\n\t\tispbuf->buff_addr[RKISP1_PLANE_CB] =\n\t\t\tispbuf->buff_addr[RKISP1_PLANE_Y] +\n\t\t\trkisp1_pixfmt_comp_size(pixm, RKISP1_PLANE_Y);\n\t\tispbuf->buff_addr[RKISP1_PLANE_CR] =\n\t\t\tispbuf->buff_addr[RKISP1_PLANE_CB] +\n\t\t\trkisp1_pixfmt_comp_size(pixm, RKISP1_PLANE_CB);\n\t}\n\n\t \n\tif (cap->pix.info->comp_planes == 3 && cap->pix.cfg->uv_swap)\n\t\tswap(ispbuf->buff_addr[RKISP1_PLANE_CR],\n\t\t     ispbuf->buff_addr[RKISP1_PLANE_CB]);\n\treturn 0;\n}\n\nstatic void rkisp1_vb2_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct rkisp1_buffer *ispbuf =\n\t\tcontainer_of(vbuf, struct rkisp1_buffer, vb);\n\tstruct rkisp1_capture *cap = vb->vb2_queue->drv_priv;\n\n\tspin_lock_irq(&cap->buf.lock);\n\tlist_add_tail(&ispbuf->queue, &cap->buf.queue);\n\tspin_unlock_irq(&cap->buf.lock);\n}\n\nstatic int rkisp1_vb2_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct rkisp1_capture *cap = vb->vb2_queue->drv_priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < cap->pix.fmt.num_planes; i++) {\n\t\tunsigned long size = cap->pix.fmt.plane_fmt[i].sizeimage;\n\n\t\tif (vb2_plane_size(vb, i) < size) {\n\t\t\tdev_err(cap->rkisp1->dev,\n\t\t\t\t\"User buffer too small (%ld < %ld)\\n\",\n\t\t\t\tvb2_plane_size(vb, i), size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvb2_set_plane_payload(vb, i, size);\n\t}\n\n\treturn 0;\n}\n\nstatic void rkisp1_return_all_buffers(struct rkisp1_capture *cap,\n\t\t\t\t      enum vb2_buffer_state state)\n{\n\tstruct rkisp1_buffer *buf;\n\n\tspin_lock_irq(&cap->buf.lock);\n\tif (cap->buf.curr) {\n\t\tvb2_buffer_done(&cap->buf.curr->vb.vb2_buf, state);\n\t\tcap->buf.curr = NULL;\n\t}\n\tif (cap->buf.next) {\n\t\tvb2_buffer_done(&cap->buf.next->vb.vb2_buf, state);\n\t\tcap->buf.next = NULL;\n\t}\n\twhile (!list_empty(&cap->buf.queue)) {\n\t\tbuf = list_first_entry(&cap->buf.queue,\n\t\t\t\t       struct rkisp1_buffer, queue);\n\t\tlist_del(&buf->queue);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t}\n\tspin_unlock_irq(&cap->buf.lock);\n}\n\n \nstatic void rkisp1_cap_stream_enable(struct rkisp1_capture *cap)\n{\n\tstruct rkisp1_device *rkisp1 = cap->rkisp1;\n\tstruct rkisp1_capture *other = &rkisp1->capture_devs[cap->id ^ 1];\n\n\tcap->ops->set_data_path(cap);\n\tcap->ops->config(cap);\n\n\t \n\tspin_lock_irq(&cap->buf.lock);\n\trkisp1_set_next_buf(cap);\n\tcap->ops->enable(cap);\n\t \n\tif (!other->is_streaming) {\n\t\t \n\t\trkisp1_write(rkisp1, RKISP1_CIF_MI_INIT,\n\t\t\t     RKISP1_CIF_MI_INIT_SOFT_UPD);\n\t\trkisp1_set_next_buf(cap);\n\t}\n\tspin_unlock_irq(&cap->buf.lock);\n\tcap->is_streaming = true;\n}\n\nstatic void rkisp1_cap_stream_disable(struct rkisp1_capture *cap)\n{\n\tint ret;\n\n\t \n\tcap->is_stopping = true;\n\tret = wait_event_timeout(cap->done,\n\t\t\t\t !cap->is_streaming,\n\t\t\t\t msecs_to_jiffies(1000));\n\tif (!ret) {\n\t\tcap->rkisp1->debug.stop_timeout[cap->id]++;\n\t\tcap->ops->stop(cap);\n\t\tcap->is_stopping = false;\n\t\tcap->is_streaming = false;\n\t}\n}\n\n \nstatic void rkisp1_pipeline_stream_disable(struct rkisp1_capture *cap)\n\t__must_hold(&cap->rkisp1->stream_lock)\n{\n\tstruct rkisp1_device *rkisp1 = cap->rkisp1;\n\n\trkisp1_cap_stream_disable(cap);\n\n\t \n\tif (rkisp1->pipe.start_count < 2)\n\t\tv4l2_subdev_call(&rkisp1->isp.sd, video, s_stream, false);\n\n\tv4l2_subdev_call(&rkisp1->resizer_devs[cap->id].sd, video, s_stream,\n\t\t\t false);\n}\n\n \nstatic int rkisp1_pipeline_stream_enable(struct rkisp1_capture *cap)\n\t__must_hold(&cap->rkisp1->stream_lock)\n{\n\tstruct rkisp1_device *rkisp1 = cap->rkisp1;\n\tint ret;\n\n\trkisp1_cap_stream_enable(cap);\n\n\tret = v4l2_subdev_call(&rkisp1->resizer_devs[cap->id].sd, video,\n\t\t\t       s_stream, true);\n\tif (ret)\n\t\tgoto err_disable_cap;\n\n\t \n\tif (rkisp1->pipe.start_count > 1)\n\t\treturn 0;\n\n\tret = v4l2_subdev_call(&rkisp1->isp.sd, video, s_stream, true);\n\tif (ret)\n\t\tgoto err_disable_rsz;\n\n\treturn 0;\n\nerr_disable_rsz:\n\tv4l2_subdev_call(&rkisp1->resizer_devs[cap->id].sd, video, s_stream,\n\t\t\t false);\nerr_disable_cap:\n\trkisp1_cap_stream_disable(cap);\n\n\treturn ret;\n}\n\nstatic void rkisp1_vb2_stop_streaming(struct vb2_queue *queue)\n{\n\tstruct rkisp1_capture *cap = queue->drv_priv;\n\tstruct rkisp1_vdev_node *node = &cap->vnode;\n\tstruct rkisp1_device *rkisp1 = cap->rkisp1;\n\tint ret;\n\n\tmutex_lock(&cap->rkisp1->stream_lock);\n\n\trkisp1_pipeline_stream_disable(cap);\n\n\trkisp1_return_all_buffers(cap, VB2_BUF_STATE_ERROR);\n\n\tv4l2_pipeline_pm_put(&node->vdev.entity);\n\tret = pm_runtime_put(rkisp1->dev);\n\tif (ret < 0)\n\t\tdev_err(rkisp1->dev, \"power down failed error:%d\\n\", ret);\n\n\trkisp1_dummy_buf_destroy(cap);\n\n\tvideo_device_pipeline_stop(&node->vdev);\n\n\tmutex_unlock(&cap->rkisp1->stream_lock);\n}\n\nstatic int\nrkisp1_vb2_start_streaming(struct vb2_queue *queue, unsigned int count)\n{\n\tstruct rkisp1_capture *cap = queue->drv_priv;\n\tstruct media_entity *entity = &cap->vnode.vdev.entity;\n\tint ret;\n\n\tmutex_lock(&cap->rkisp1->stream_lock);\n\n\tret = video_device_pipeline_start(&cap->vnode.vdev, &cap->rkisp1->pipe);\n\tif (ret) {\n\t\tdev_err(cap->rkisp1->dev, \"start pipeline failed %d\\n\", ret);\n\t\tgoto err_ret_buffers;\n\t}\n\n\tret = rkisp1_dummy_buf_create(cap);\n\tif (ret)\n\t\tgoto err_pipeline_stop;\n\n\tret = pm_runtime_resume_and_get(cap->rkisp1->dev);\n\tif (ret < 0) {\n\t\tdev_err(cap->rkisp1->dev, \"power up failed %d\\n\", ret);\n\t\tgoto err_destroy_dummy;\n\t}\n\tret = v4l2_pipeline_pm_get(entity);\n\tif (ret) {\n\t\tdev_err(cap->rkisp1->dev, \"open cif pipeline failed %d\\n\", ret);\n\t\tgoto err_pipe_pm_put;\n\t}\n\n\tret = rkisp1_pipeline_stream_enable(cap);\n\tif (ret)\n\t\tgoto err_v4l2_pm_put;\n\n\tmutex_unlock(&cap->rkisp1->stream_lock);\n\n\treturn 0;\n\nerr_v4l2_pm_put:\n\tv4l2_pipeline_pm_put(entity);\nerr_pipe_pm_put:\n\tpm_runtime_put(cap->rkisp1->dev);\nerr_destroy_dummy:\n\trkisp1_dummy_buf_destroy(cap);\nerr_pipeline_stop:\n\tvideo_device_pipeline_stop(&cap->vnode.vdev);\nerr_ret_buffers:\n\trkisp1_return_all_buffers(cap, VB2_BUF_STATE_QUEUED);\n\tmutex_unlock(&cap->rkisp1->stream_lock);\n\n\treturn ret;\n}\n\nstatic const struct vb2_ops rkisp1_vb2_ops = {\n\t.queue_setup = rkisp1_vb2_queue_setup,\n\t.buf_init = rkisp1_vb2_buf_init,\n\t.buf_queue = rkisp1_vb2_buf_queue,\n\t.buf_prepare = rkisp1_vb2_buf_prepare,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.stop_streaming = rkisp1_vb2_stop_streaming,\n\t.start_streaming = rkisp1_vb2_start_streaming,\n};\n\n \n\nstatic const struct v4l2_format_info *\nrkisp1_fill_pixfmt(struct v4l2_pix_format_mplane *pixm,\n\t\t   enum rkisp1_stream_id id)\n{\n\tstruct v4l2_plane_pix_format *plane_y = &pixm->plane_fmt[0];\n\tconst struct v4l2_format_info *info;\n\tunsigned int i;\n\tu32 stride;\n\n\tmemset(pixm->plane_fmt, 0, sizeof(pixm->plane_fmt));\n\tinfo = v4l2_format_info(pixm->pixelformat);\n\tpixm->num_planes = info->mem_planes;\n\tstride = info->bpp[0] * pixm->width;\n\t \n\tif (id == RKISP1_MAINPATH || plane_y->bytesperline < stride)\n\t\tplane_y->bytesperline = stride;\n\tplane_y->sizeimage = plane_y->bytesperline * pixm->height;\n\n\t \n\tstride = DIV_ROUND_UP(plane_y->bytesperline, info->bpp[0]);\n\n\tfor (i = 1; i < info->comp_planes; i++) {\n\t\tstruct v4l2_plane_pix_format *plane = &pixm->plane_fmt[i];\n\n\t\t \n\t\tplane->bytesperline = DIV_ROUND_UP(stride, info->hdiv) *\n\t\t\t\t      info->bpp[i];\n\t\tplane->sizeimage = plane->bytesperline *\n\t\t\t\t   DIV_ROUND_UP(pixm->height, info->vdiv);\n\t}\n\n\t \n\tif (info->mem_planes == 1)\n\t\tfor (i = 1; i < info->comp_planes; i++)\n\t\t\tplane_y->sizeimage += pixm->plane_fmt[i].sizeimage;\n\n\treturn info;\n}\n\nstatic const struct rkisp1_capture_fmt_cfg *\nrkisp1_find_fmt_cfg(const struct rkisp1_capture *cap, const u32 pixelfmt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < cap->config->fmt_size; i++) {\n\t\tif (cap->config->fmts[i].fourcc == pixelfmt)\n\t\t\treturn &cap->config->fmts[i];\n\t}\n\treturn NULL;\n}\n\nstatic void rkisp1_try_fmt(const struct rkisp1_capture *cap,\n\t\t\t   struct v4l2_pix_format_mplane *pixm,\n\t\t\t   const struct rkisp1_capture_fmt_cfg **fmt_cfg,\n\t\t\t   const struct v4l2_format_info **fmt_info)\n{\n\tconst struct rkisp1_capture_config *config = cap->config;\n\tconst struct rkisp1_capture_fmt_cfg *fmt;\n\tconst struct v4l2_format_info *info;\n\tstatic const unsigned int max_widths[] = {\n\t\tRKISP1_RSZ_MP_SRC_MAX_WIDTH, RKISP1_RSZ_SP_SRC_MAX_WIDTH\n\t};\n\tstatic const unsigned int max_heights[] = {\n\t\tRKISP1_RSZ_MP_SRC_MAX_HEIGHT, RKISP1_RSZ_SP_SRC_MAX_HEIGHT\n\t};\n\n\tfmt = rkisp1_find_fmt_cfg(cap, pixm->pixelformat);\n\tif (!fmt) {\n\t\tfmt = config->fmts;\n\t\tpixm->pixelformat = fmt->fourcc;\n\t}\n\n\tpixm->width = clamp_t(u32, pixm->width,\n\t\t\t      RKISP1_RSZ_SRC_MIN_WIDTH, max_widths[cap->id]);\n\tpixm->height = clamp_t(u32, pixm->height,\n\t\t\t       RKISP1_RSZ_SRC_MIN_HEIGHT, max_heights[cap->id]);\n\n\tpixm->field = V4L2_FIELD_NONE;\n\tpixm->colorspace = V4L2_COLORSPACE_DEFAULT;\n\tpixm->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tpixm->quantization = V4L2_QUANTIZATION_DEFAULT;\n\n\tinfo = rkisp1_fill_pixfmt(pixm, cap->id);\n\n\tif (fmt_cfg)\n\t\t*fmt_cfg = fmt;\n\tif (fmt_info)\n\t\t*fmt_info = info;\n}\n\nstatic void rkisp1_set_fmt(struct rkisp1_capture *cap,\n\t\t\t   struct v4l2_pix_format_mplane *pixm)\n{\n\trkisp1_try_fmt(cap, pixm, &cap->pix.cfg, &cap->pix.info);\n\tcap->pix.fmt = *pixm;\n\n\t \n\tif (cap->id == RKISP1_SELFPATH)\n\t\tcap->sp_y_stride = pixm->plane_fmt[0].bytesperline /\n\t\t\t\t   cap->pix.info->bpp[0];\n}\n\nstatic int rkisp1_try_fmt_vid_cap_mplane(struct file *file, void *fh,\n\t\t\t\t\t struct v4l2_format *f)\n{\n\tstruct rkisp1_capture *cap = video_drvdata(file);\n\n\trkisp1_try_fmt(cap, &f->fmt.pix_mp, NULL, NULL);\n\n\treturn 0;\n}\n\nstatic int rkisp1_enum_fmt_vid_cap_mplane(struct file *file, void *priv,\n\t\t\t\t\t  struct v4l2_fmtdesc *f)\n{\n\tstruct rkisp1_capture *cap = video_drvdata(file);\n\tconst struct rkisp1_capture_fmt_cfg *fmt = NULL;\n\tunsigned int i, n = 0;\n\n\tif (!f->mbus_code) {\n\t\tif (f->index >= cap->config->fmt_size)\n\t\t\treturn -EINVAL;\n\n\t\tfmt = &cap->config->fmts[f->index];\n\t\tf->pixelformat = fmt->fourcc;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < cap->config->fmt_size; i++) {\n\t\tif (cap->config->fmts[i].mbus != f->mbus_code)\n\t\t\tcontinue;\n\n\t\tif (n++ == f->index) {\n\t\t\tf->pixelformat = cap->config->fmts[i].fourcc;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int rkisp1_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tstatic const unsigned int max_widths[] = {\n\t\tRKISP1_RSZ_MP_SRC_MAX_WIDTH,\n\t\tRKISP1_RSZ_SP_SRC_MAX_WIDTH,\n\t};\n\tstatic const unsigned int max_heights[] = {\n\t\tRKISP1_RSZ_MP_SRC_MAX_HEIGHT,\n\t\tRKISP1_RSZ_SP_SRC_MAX_HEIGHT,\n\t};\n\tstruct rkisp1_capture *cap = video_drvdata(file);\n\n\tif (fsize->index != 0)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\n\tfsize->stepwise.min_width = RKISP1_RSZ_SRC_MIN_WIDTH;\n\tfsize->stepwise.max_width = max_widths[cap->id];\n\tfsize->stepwise.step_width = 2;\n\n\tfsize->stepwise.min_height = RKISP1_RSZ_SRC_MIN_HEIGHT;\n\tfsize->stepwise.max_height = max_heights[cap->id];\n\tfsize->stepwise.step_height = 2;\n\n\treturn 0;\n}\n\nstatic int rkisp1_s_fmt_vid_cap_mplane(struct file *file,\n\t\t\t\t       void *priv, struct v4l2_format *f)\n{\n\tstruct rkisp1_capture *cap = video_drvdata(file);\n\tstruct rkisp1_vdev_node *node =\n\t\t\t\trkisp1_vdev_to_node(&cap->vnode.vdev);\n\n\tif (vb2_is_busy(&node->buf_queue))\n\t\treturn -EBUSY;\n\n\trkisp1_set_fmt(cap, &f->fmt.pix_mp);\n\n\treturn 0;\n}\n\nstatic int rkisp1_g_fmt_vid_cap_mplane(struct file *file, void *fh,\n\t\t\t\t       struct v4l2_format *f)\n{\n\tstruct rkisp1_capture *cap = video_drvdata(file);\n\n\tf->fmt.pix_mp = cap->pix.fmt;\n\n\treturn 0;\n}\n\nstatic int\nrkisp1_querycap(struct file *file, void *priv, struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, RKISP1_DRIVER_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, RKISP1_DRIVER_NAME, sizeof(cap->card));\n\tstrscpy(cap->bus_info, RKISP1_BUS_INFO, sizeof(cap->bus_info));\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops rkisp1_v4l2_ioctl_ops = {\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_expbuf = vb2_ioctl_expbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_prepare_buf = vb2_ioctl_prepare_buf,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n\t.vidioc_try_fmt_vid_cap_mplane = rkisp1_try_fmt_vid_cap_mplane,\n\t.vidioc_s_fmt_vid_cap_mplane = rkisp1_s_fmt_vid_cap_mplane,\n\t.vidioc_g_fmt_vid_cap_mplane = rkisp1_g_fmt_vid_cap_mplane,\n\t.vidioc_enum_fmt_vid_cap = rkisp1_enum_fmt_vid_cap_mplane,\n\t.vidioc_enum_framesizes = rkisp1_enum_framesizes,\n\t.vidioc_querycap = rkisp1_querycap,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic int rkisp1_capture_link_validate(struct media_link *link)\n{\n\tstruct video_device *vdev =\n\t\tmedia_entity_to_video_device(link->sink->entity);\n\tstruct v4l2_subdev *sd =\n\t\tmedia_entity_to_v4l2_subdev(link->source->entity);\n\tstruct rkisp1_capture *cap = video_get_drvdata(vdev);\n\tconst struct rkisp1_capture_fmt_cfg *fmt =\n\t\trkisp1_find_fmt_cfg(cap, cap->pix.fmt.pixelformat);\n\tstruct v4l2_subdev_format sd_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.pad = link->source->index,\n\t};\n\tint ret;\n\n\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &sd_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sd_fmt.format.height != cap->pix.fmt.height ||\n\t    sd_fmt.format.width != cap->pix.fmt.width ||\n\t    sd_fmt.format.code != fmt->mbus) {\n\t\tdev_dbg(cap->rkisp1->dev,\n\t\t\t\"link '%s':%u -> '%s':%u not valid: 0x%04x/%ux%u != 0x%04x/%ux%u\\n\",\n\t\t\tlink->source->entity->name, link->source->index,\n\t\t\tlink->sink->entity->name, link->sink->index,\n\t\t\tsd_fmt.format.code, sd_fmt.format.width,\n\t\t\tsd_fmt.format.height, fmt->mbus, cap->pix.fmt.width,\n\t\t\tcap->pix.fmt.height);\n\t\treturn -EPIPE;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct media_entity_operations rkisp1_media_ops = {\n\t.link_validate = rkisp1_capture_link_validate,\n};\n\nstatic const struct v4l2_file_operations rkisp1_fops = {\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.unlocked_ioctl = video_ioctl2,\n\t.poll = vb2_fop_poll,\n\t.mmap = vb2_fop_mmap,\n};\n\nstatic void rkisp1_unregister_capture(struct rkisp1_capture *cap)\n{\n\tif (!video_is_registered(&cap->vnode.vdev))\n\t\treturn;\n\n\tmedia_entity_cleanup(&cap->vnode.vdev.entity);\n\tvb2_video_unregister_device(&cap->vnode.vdev);\n\tmutex_destroy(&cap->vnode.vlock);\n}\n\nvoid rkisp1_capture_devs_unregister(struct rkisp1_device *rkisp1)\n{\n\tstruct rkisp1_capture *mp = &rkisp1->capture_devs[RKISP1_MAINPATH];\n\tstruct rkisp1_capture *sp = &rkisp1->capture_devs[RKISP1_SELFPATH];\n\n\trkisp1_unregister_capture(mp);\n\trkisp1_unregister_capture(sp);\n}\n\nstatic int rkisp1_register_capture(struct rkisp1_capture *cap)\n{\n\tstatic const char * const dev_names[] = {\n\t\tRKISP1_MP_DEV_NAME, RKISP1_SP_DEV_NAME\n\t};\n\tstruct v4l2_device *v4l2_dev = &cap->rkisp1->v4l2_dev;\n\tstruct video_device *vdev = &cap->vnode.vdev;\n\tstruct rkisp1_vdev_node *node;\n\tstruct vb2_queue *q;\n\tint ret;\n\n\tstrscpy(vdev->name, dev_names[cap->id], sizeof(vdev->name));\n\tnode = rkisp1_vdev_to_node(vdev);\n\tmutex_init(&node->vlock);\n\n\tvdev->ioctl_ops = &rkisp1_v4l2_ioctl_ops;\n\tvdev->release = video_device_release_empty;\n\tvdev->fops = &rkisp1_fops;\n\tvdev->minor = -1;\n\tvdev->v4l2_dev = v4l2_dev;\n\tvdev->lock = &node->vlock;\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE_MPLANE |\n\t\t\t    V4L2_CAP_STREAMING | V4L2_CAP_IO_MC;\n\tvdev->entity.ops = &rkisp1_media_ops;\n\tvideo_set_drvdata(vdev, cap);\n\tvdev->vfl_dir = VFL_DIR_RX;\n\tnode->pad.flags = MEDIA_PAD_FL_SINK;\n\n\tq = &node->buf_queue;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tq->drv_priv = cap;\n\tq->ops = &rkisp1_vb2_ops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->buf_struct_size = sizeof(struct rkisp1_buffer);\n\tq->min_buffers_needed = RKISP1_MIN_BUFFERS_NEEDED;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &node->vlock;\n\tq->dev = cap->rkisp1->dev;\n\tret = vb2_queue_init(q);\n\tif (ret) {\n\t\tdev_err(cap->rkisp1->dev,\n\t\t\t\"vb2 queue init failed (err=%d)\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tvdev->queue = q;\n\n\tret = media_entity_pads_init(&vdev->entity, 1, &node->pad);\n\tif (ret)\n\t\tgoto error;\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(cap->rkisp1->dev,\n\t\t\t\"failed to register %s, ret=%d\\n\", vdev->name, ret);\n\t\tgoto error;\n\t}\n\n\tv4l2_info(v4l2_dev, \"registered %s as /dev/video%d\\n\", vdev->name,\n\t\t  vdev->num);\n\n\treturn 0;\n\nerror:\n\tmedia_entity_cleanup(&vdev->entity);\n\tmutex_destroy(&node->vlock);\n\treturn ret;\n}\n\nstatic void\nrkisp1_capture_init(struct rkisp1_device *rkisp1, enum rkisp1_stream_id id)\n{\n\tstruct rkisp1_capture *cap = &rkisp1->capture_devs[id];\n\tstruct v4l2_pix_format_mplane pixm;\n\n\tmemset(cap, 0, sizeof(*cap));\n\tcap->id = id;\n\tcap->rkisp1 = rkisp1;\n\n\tINIT_LIST_HEAD(&cap->buf.queue);\n\tinit_waitqueue_head(&cap->done);\n\tspin_lock_init(&cap->buf.lock);\n\tif (cap->id == RKISP1_SELFPATH) {\n\t\tcap->ops = &rkisp1_capture_ops_sp;\n\t\tcap->config = &rkisp1_capture_config_sp;\n\t} else {\n\t\tcap->ops = &rkisp1_capture_ops_mp;\n\t\tcap->config = &rkisp1_capture_config_mp;\n\t}\n\n\tcap->is_streaming = false;\n\n\tmemset(&pixm, 0, sizeof(pixm));\n\tpixm.pixelformat = V4L2_PIX_FMT_YUYV;\n\tpixm.width = RKISP1_DEFAULT_WIDTH;\n\tpixm.height = RKISP1_DEFAULT_HEIGHT;\n\trkisp1_set_fmt(cap, &pixm);\n}\n\nint rkisp1_capture_devs_register(struct rkisp1_device *rkisp1)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(rkisp1->capture_devs); i++) {\n\t\tstruct rkisp1_capture *cap = &rkisp1->capture_devs[i];\n\n\t\trkisp1_capture_init(rkisp1, i);\n\n\t\tret = rkisp1_register_capture(cap);\n\t\tif (ret) {\n\t\t\trkisp1_capture_devs_unregister(rkisp1);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}