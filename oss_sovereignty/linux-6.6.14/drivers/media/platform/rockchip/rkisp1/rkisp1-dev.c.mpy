{
  "module_name": "rkisp1-dev.c",
  "hash_id": "37aa2ac4a969dfb23791e411db5f6af66357481f7f26a092134c75c57841b24f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/rockchip/rkisp1/rkisp1-dev.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mc.h>\n\n#include \"rkisp1-common.h\"\n#include \"rkisp1-csi.h\"\n\n \n\nstruct rkisp1_isr_data {\n\tconst char *name;\n\tirqreturn_t (*isr)(int irq, void *ctx);\n};\n\n \n\nstatic int rkisp1_subdev_notifier_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t\tstruct v4l2_subdev *sd,\n\t\t\t\t\tstruct v4l2_async_connection *asc)\n{\n\tstruct rkisp1_device *rkisp1 =\n\t\tcontainer_of(notifier, struct rkisp1_device, notifier);\n\tstruct rkisp1_sensor_async *s_asd =\n\t\tcontainer_of(asc, struct rkisp1_sensor_async, asd);\n\tint source_pad;\n\tint ret;\n\n\ts_asd->sd = sd;\n\n\tsource_pad = media_entity_get_fwnode_pad(&sd->entity, s_asd->source_ep,\n\t\t\t\t\t\t MEDIA_PAD_FL_SOURCE);\n\tif (source_pad < 0) {\n\t\tdev_err(rkisp1->dev, \"failed to find source pad for %s\\n\",\n\t\t\tsd->name);\n\t\treturn source_pad;\n\t}\n\n\tif (s_asd->port == 0)\n\t\treturn rkisp1_csi_link_sensor(rkisp1, sd, s_asd, source_pad);\n\n\tret = media_create_pad_link(&sd->entity, source_pad,\n\t\t\t\t    &rkisp1->isp.sd.entity,\n\t\t\t\t    RKISP1_ISP_PAD_SINK_VIDEO,\n\t\t\t\t    !s_asd->index ? MEDIA_LNK_FL_ENABLED : 0);\n\tif (ret) {\n\t\tdev_err(rkisp1->dev, \"failed to link source pad of %s\\n\",\n\t\t\tsd->name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rkisp1_subdev_notifier_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct rkisp1_device *rkisp1 =\n\t\tcontainer_of(notifier, struct rkisp1_device, notifier);\n\n\treturn v4l2_device_register_subdev_nodes(&rkisp1->v4l2_dev);\n}\n\nstatic void rkisp1_subdev_notifier_destroy(struct v4l2_async_connection *asc)\n{\n\tstruct rkisp1_sensor_async *rk_asd =\n\t\tcontainer_of(asc, struct rkisp1_sensor_async, asd);\n\n\tfwnode_handle_put(rk_asd->source_ep);\n}\n\nstatic const struct v4l2_async_notifier_operations rkisp1_subdev_notifier_ops = {\n\t.bound = rkisp1_subdev_notifier_bound,\n\t.complete = rkisp1_subdev_notifier_complete,\n\t.destroy = rkisp1_subdev_notifier_destroy,\n};\n\nstatic int rkisp1_subdev_notifier_register(struct rkisp1_device *rkisp1)\n{\n\tstruct v4l2_async_notifier *ntf = &rkisp1->notifier;\n\tstruct fwnode_handle *fwnode = dev_fwnode(rkisp1->dev);\n\tstruct fwnode_handle *ep;\n\tunsigned int index = 0;\n\tint ret = 0;\n\n\tv4l2_async_nf_init(ntf, &rkisp1->v4l2_dev);\n\n\tntf->ops = &rkisp1_subdev_notifier_ops;\n\n\tfwnode_graph_for_each_endpoint(fwnode, ep) {\n\t\tstruct fwnode_handle *port;\n\t\tstruct v4l2_fwnode_endpoint vep = { };\n\t\tstruct rkisp1_sensor_async *rk_asd;\n\t\tstruct fwnode_handle *source;\n\t\tu32 reg = 0;\n\n\t\t \n\t\tport = fwnode_get_parent(ep);\n\t\tfwnode_property_read_u32(port, \"reg\", &reg);\n\t\tfwnode_handle_put(port);\n\n\t\tswitch (reg) {\n\t\tcase 0:\n\t\t\t \n\t\t\tif (!(rkisp1->info->features & RKISP1_FEATURE_MIPI_CSI2)) {\n\t\t\t\tdev_err(rkisp1->dev,\n\t\t\t\t\t\"internal CSI must be available for port 0\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvep.bus_type = V4L2_MBUS_CSI2_DPHY;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t \n\t\t\tvep.bus_type = V4L2_MBUS_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\t\tif (ret) {\n\t\t\tdev_err(rkisp1->dev, \"failed to parse endpoint %pfw\\n\",\n\t\t\t\tep);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (vep.base.port == 1) {\n\t\t\tif (vep.bus_type != V4L2_MBUS_PARALLEL &&\n\t\t\t    vep.bus_type != V4L2_MBUS_BT656) {\n\t\t\t\tdev_err(rkisp1->dev,\n\t\t\t\t\t\"port 1 must be parallel or BT656\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tsource = fwnode_graph_get_remote_endpoint(ep);\n\t\tif (!source) {\n\t\t\tdev_err(rkisp1->dev,\n\t\t\t\t\"endpoint %pfw has no remote endpoint\\n\",\n\t\t\t\tep);\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\trk_asd = v4l2_async_nf_add_fwnode(ntf, source,\n\t\t\t\t\t\t  struct rkisp1_sensor_async);\n\t\tif (IS_ERR(rk_asd)) {\n\t\t\tfwnode_handle_put(source);\n\t\t\tret = PTR_ERR(rk_asd);\n\t\t\tbreak;\n\t\t}\n\n\t\trk_asd->index = index++;\n\t\trk_asd->source_ep = source;\n\t\trk_asd->mbus_type = vep.bus_type;\n\t\trk_asd->port = vep.base.port;\n\n\t\tif (vep.bus_type == V4L2_MBUS_CSI2_DPHY) {\n\t\t\trk_asd->mbus_flags = vep.bus.mipi_csi2.flags;\n\t\t\trk_asd->lanes = vep.bus.mipi_csi2.num_data_lanes;\n\t\t} else {\n\t\t\trk_asd->mbus_flags = vep.bus.parallel.flags;\n\t\t}\n\n\t\tdev_dbg(rkisp1->dev, \"registered ep id %d, bus type %u, %u lanes\\n\",\n\t\t\tvep.base.id, rk_asd->mbus_type, rk_asd->lanes);\n\t}\n\n\tif (ret) {\n\t\tfwnode_handle_put(ep);\n\t\tv4l2_async_nf_cleanup(ntf);\n\t\treturn ret;\n\t}\n\n\tif (!index)\n\t\tdev_dbg(rkisp1->dev, \"no remote subdevice found\\n\");\n\n\tret = v4l2_async_nf_register(ntf);\n\tif (ret) {\n\t\tv4l2_async_nf_cleanup(ntf);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int __maybe_unused rkisp1_runtime_suspend(struct device *dev)\n{\n\tstruct rkisp1_device *rkisp1 = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(rkisp1->clk_size, rkisp1->clks);\n\treturn pinctrl_pm_select_sleep_state(dev);\n}\n\nstatic int __maybe_unused rkisp1_runtime_resume(struct device *dev)\n{\n\tstruct rkisp1_device *rkisp1 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pinctrl_pm_select_default_state(dev);\n\tif (ret)\n\t\treturn ret;\n\tret = clk_bulk_prepare_enable(rkisp1->clk_size, rkisp1->clks);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rkisp1_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(rkisp1_runtime_suspend, rkisp1_runtime_resume, NULL)\n};\n\n \n\nstatic int rkisp1_create_links(struct rkisp1_device *rkisp1)\n{\n\tunsigned int i;\n\tint ret;\n\n\tif (rkisp1->info->features & RKISP1_FEATURE_MIPI_CSI2) {\n\t\t \n\t\tret = media_create_pad_link(&rkisp1->csi.sd.entity,\n\t\t\t\t\t    RKISP1_CSI_PAD_SRC,\n\t\t\t\t\t    &rkisp1->isp.sd.entity,\n\t\t\t\t\t    RKISP1_ISP_PAD_SINK_VIDEO,\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tstruct media_entity *resizer =\n\t\t\t&rkisp1->resizer_devs[i].sd.entity;\n\t\tstruct media_entity *capture =\n\t\t\t&rkisp1->capture_devs[i].vnode.vdev.entity;\n\n\t\tret = media_create_pad_link(&rkisp1->isp.sd.entity,\n\t\t\t\t\t    RKISP1_ISP_PAD_SOURCE_VIDEO,\n\t\t\t\t\t    resizer, RKISP1_RSZ_PAD_SINK,\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = media_create_pad_link(resizer, RKISP1_RSZ_PAD_SRC,\n\t\t\t\t\t    capture, 0,\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = media_create_pad_link(&rkisp1->params.vnode.vdev.entity, 0,\n\t\t\t\t    &rkisp1->isp.sd.entity,\n\t\t\t\t    RKISP1_ISP_PAD_SINK_PARAMS,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn media_create_pad_link(&rkisp1->isp.sd.entity,\n\t\t\t\t     RKISP1_ISP_PAD_SOURCE_STATS,\n\t\t\t\t     &rkisp1->stats.vnode.vdev.entity, 0,\n\t\t\t\t     MEDIA_LNK_FL_ENABLED |\n\t\t\t\t     MEDIA_LNK_FL_IMMUTABLE);\n}\n\nstatic void rkisp1_entities_unregister(struct rkisp1_device *rkisp1)\n{\n\tif (rkisp1->info->features & RKISP1_FEATURE_MIPI_CSI2)\n\t\trkisp1_csi_unregister(rkisp1);\n\trkisp1_params_unregister(rkisp1);\n\trkisp1_stats_unregister(rkisp1);\n\trkisp1_capture_devs_unregister(rkisp1);\n\trkisp1_resizer_devs_unregister(rkisp1);\n\trkisp1_isp_unregister(rkisp1);\n}\n\nstatic int rkisp1_entities_register(struct rkisp1_device *rkisp1)\n{\n\tint ret;\n\n\tret = rkisp1_isp_register(rkisp1);\n\tif (ret)\n\t\tgoto error;\n\n\tret = rkisp1_resizer_devs_register(rkisp1);\n\tif (ret)\n\t\tgoto error;\n\n\tret = rkisp1_capture_devs_register(rkisp1);\n\tif (ret)\n\t\tgoto error;\n\n\tret = rkisp1_stats_register(rkisp1);\n\tif (ret)\n\t\tgoto error;\n\n\tret = rkisp1_params_register(rkisp1);\n\tif (ret)\n\t\tgoto error;\n\n\tif (rkisp1->info->features & RKISP1_FEATURE_MIPI_CSI2) {\n\t\tret = rkisp1_csi_register(rkisp1);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tret = rkisp1_create_links(rkisp1);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\trkisp1_entities_unregister(rkisp1);\n\treturn ret;\n}\n\nstatic irqreturn_t rkisp1_isr(int irq, void *ctx)\n{\n\t \n\trkisp1_capture_isr(irq, ctx);\n\trkisp1_isp_isr(irq, ctx);\n\trkisp1_csi_isr(irq, ctx);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const char * const px30_isp_clks[] = {\n\t\"isp\",\n\t\"aclk\",\n\t\"hclk\",\n\t\"pclk\",\n};\n\nstatic const struct rkisp1_isr_data px30_isp_isrs[] = {\n\t{ \"isp\", rkisp1_isp_isr },\n\t{ \"mi\", rkisp1_capture_isr },\n\t{ \"mipi\", rkisp1_csi_isr },\n};\n\nstatic const struct rkisp1_info px30_isp_info = {\n\t.clks = px30_isp_clks,\n\t.clk_size = ARRAY_SIZE(px30_isp_clks),\n\t.isrs = px30_isp_isrs,\n\t.isr_size = ARRAY_SIZE(px30_isp_isrs),\n\t.isp_ver = RKISP1_V12,\n\t.features = RKISP1_FEATURE_MIPI_CSI2,\n};\n\nstatic const char * const rk3399_isp_clks[] = {\n\t\"isp\",\n\t\"aclk\",\n\t\"hclk\",\n};\n\nstatic const struct rkisp1_isr_data rk3399_isp_isrs[] = {\n\t{ NULL, rkisp1_isr },\n};\n\nstatic const struct rkisp1_info rk3399_isp_info = {\n\t.clks = rk3399_isp_clks,\n\t.clk_size = ARRAY_SIZE(rk3399_isp_clks),\n\t.isrs = rk3399_isp_isrs,\n\t.isr_size = ARRAY_SIZE(rk3399_isp_isrs),\n\t.isp_ver = RKISP1_V10,\n\t.features = RKISP1_FEATURE_MIPI_CSI2,\n};\n\nstatic const struct of_device_id rkisp1_of_match[] = {\n\t{\n\t\t.compatible = \"rockchip,px30-cif-isp\",\n\t\t.data = &px30_isp_info,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3399-cif-isp\",\n\t\t.data = &rk3399_isp_info,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rkisp1_of_match);\n\nstatic int rkisp1_probe(struct platform_device *pdev)\n{\n\tconst struct rkisp1_info *info;\n\tstruct device *dev = &pdev->dev;\n\tstruct rkisp1_device *rkisp1;\n\tstruct v4l2_device *v4l2_dev;\n\tunsigned int i;\n\tint ret, irq;\n\tu32 cif_id;\n\n\trkisp1 = devm_kzalloc(dev, sizeof(*rkisp1), GFP_KERNEL);\n\tif (!rkisp1)\n\t\treturn -ENOMEM;\n\n\tinfo = of_device_get_match_data(dev);\n\trkisp1->info = info;\n\n\tdev_set_drvdata(dev, rkisp1);\n\trkisp1->dev = dev;\n\n\tmutex_init(&rkisp1->stream_lock);\n\n\trkisp1->base_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rkisp1->base_addr))\n\t\treturn PTR_ERR(rkisp1->base_addr);\n\n\tfor (i = 0; i < info->isr_size; i++) {\n\t\tirq = info->isrs[i].name\n\t\t    ? platform_get_irq_byname(pdev, info->isrs[i].name)\n\t\t    : platform_get_irq(pdev, i);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_irq(dev, irq, info->isrs[i].isr, IRQF_SHARED,\n\t\t\t\t       dev_driver_string(dev), dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"request irq failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < info->clk_size; i++)\n\t\trkisp1->clks[i].id = info->clks[i];\n\tret = devm_clk_bulk_get(dev, info->clk_size, rkisp1->clks);\n\tif (ret)\n\t\treturn ret;\n\trkisp1->clk_size = info->clk_size;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret)\n\t\tgoto err_pm_runtime_disable;\n\n\tcif_id = rkisp1_read(rkisp1, RKISP1_CIF_VI_ID);\n\tdev_dbg(rkisp1->dev, \"CIF_ID 0x%08x\\n\", cif_id);\n\n\tpm_runtime_put(&pdev->dev);\n\n\trkisp1->media_dev.hw_revision = info->isp_ver;\n\tstrscpy(rkisp1->media_dev.model, RKISP1_DRIVER_NAME,\n\t\tsizeof(rkisp1->media_dev.model));\n\trkisp1->media_dev.dev = &pdev->dev;\n\tstrscpy(rkisp1->media_dev.bus_info, RKISP1_BUS_INFO,\n\t\tsizeof(rkisp1->media_dev.bus_info));\n\tmedia_device_init(&rkisp1->media_dev);\n\n\tv4l2_dev = &rkisp1->v4l2_dev;\n\tv4l2_dev->mdev = &rkisp1->media_dev;\n\tstrscpy(v4l2_dev->name, RKISP1_DRIVER_NAME, sizeof(v4l2_dev->name));\n\n\tret = v4l2_device_register(rkisp1->dev, &rkisp1->v4l2_dev);\n\tif (ret)\n\t\tgoto err_media_dev_cleanup;\n\n\tret = media_device_register(&rkisp1->media_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register media device: %d\\n\", ret);\n\t\tgoto err_unreg_v4l2_dev;\n\t}\n\n\tif (rkisp1->info->features & RKISP1_FEATURE_MIPI_CSI2) {\n\t\tret = rkisp1_csi_init(rkisp1);\n\t\tif (ret)\n\t\t\tgoto err_unreg_media_dev;\n\t}\n\n\tret = rkisp1_entities_register(rkisp1);\n\tif (ret)\n\t\tgoto err_cleanup_csi;\n\n\tret = rkisp1_subdev_notifier_register(rkisp1);\n\tif (ret)\n\t\tgoto err_unreg_entities;\n\n\trkisp1_debug_init(rkisp1);\n\n\treturn 0;\n\nerr_unreg_entities:\n\trkisp1_entities_unregister(rkisp1);\nerr_cleanup_csi:\n\tif (rkisp1->info->features & RKISP1_FEATURE_MIPI_CSI2)\n\t\trkisp1_csi_cleanup(rkisp1);\nerr_unreg_media_dev:\n\tmedia_device_unregister(&rkisp1->media_dev);\nerr_unreg_v4l2_dev:\n\tv4l2_device_unregister(&rkisp1->v4l2_dev);\nerr_media_dev_cleanup:\n\tmedia_device_cleanup(&rkisp1->media_dev);\nerr_pm_runtime_disable:\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void rkisp1_remove(struct platform_device *pdev)\n{\n\tstruct rkisp1_device *rkisp1 = platform_get_drvdata(pdev);\n\n\tv4l2_async_nf_unregister(&rkisp1->notifier);\n\tv4l2_async_nf_cleanup(&rkisp1->notifier);\n\n\trkisp1_entities_unregister(rkisp1);\n\tif (rkisp1->info->features & RKISP1_FEATURE_MIPI_CSI2)\n\t\trkisp1_csi_cleanup(rkisp1);\n\trkisp1_debug_cleanup(rkisp1);\n\n\tmedia_device_unregister(&rkisp1->media_dev);\n\tv4l2_device_unregister(&rkisp1->v4l2_dev);\n\n\tmedia_device_cleanup(&rkisp1->media_dev);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic struct platform_driver rkisp1_drv = {\n\t.driver = {\n\t\t.name = RKISP1_DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(rkisp1_of_match),\n\t\t.pm = &rkisp1_pm_ops,\n\t},\n\t.probe = rkisp1_probe,\n\t.remove_new = rkisp1_remove,\n};\n\nmodule_platform_driver(rkisp1_drv);\nMODULE_DESCRIPTION(\"Rockchip ISP1 platform driver\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}