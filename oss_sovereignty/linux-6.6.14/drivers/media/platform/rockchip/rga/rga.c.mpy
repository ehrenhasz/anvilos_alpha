{
  "module_name": "rga.c",
  "hash_id": "205ad4be3e052ee4688c86df17802ead93b4bde96ce1303fb2f7cfba1255c254",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/rockchip/rga/rga.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n\n#include <linux/platform_device.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-sg.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"rga-hw.h\"\n#include \"rga.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\n\nstatic void device_run(void *prv)\n{\n\tstruct rga_ctx *ctx = prv;\n\tstruct rockchip_rga *rga = ctx->rga;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rga->ctrl_lock, flags);\n\n\trga->curr = ctx;\n\n\tsrc = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\trga_buf_map(&src->vb2_buf);\n\trga_buf_map(&dst->vb2_buf);\n\n\trga_hw_start(rga);\n\n\tspin_unlock_irqrestore(&rga->ctrl_lock, flags);\n}\n\nstatic irqreturn_t rga_isr(int irq, void *prv)\n{\n\tstruct rockchip_rga *rga = prv;\n\tint intr;\n\n\tintr = rga_read(rga, RGA_INT) & 0xf;\n\n\trga_mod(rga, RGA_INT, intr << 4, 0xf << 4);\n\n\tif (intr & 0x04) {\n\t\tstruct vb2_v4l2_buffer *src, *dst;\n\t\tstruct rga_ctx *ctx = rga->curr;\n\n\t\tWARN_ON(!ctx);\n\n\t\trga->curr = NULL;\n\n\t\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tWARN_ON(!src);\n\t\tWARN_ON(!dst);\n\n\t\tv4l2_m2m_buf_copy_metadata(src, dst, true);\n\n\t\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_job_finish(rga->m2m_dev, ctx->fh.m2m_ctx);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct v4l2_m2m_ops rga_m2m_ops = {\n\t.device_run = device_run,\n};\n\nstatic int\nqueue_init(void *priv, struct vb2_queue *src_vq, struct vb2_queue *dst_vq)\n{\n\tstruct rga_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->ops = &rga_qops;\n\tsrc_vq->mem_ops = &vb2_dma_sg_memops;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->rga->mutex;\n\tsrc_vq->dev = ctx->rga->v4l2_dev.dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->ops = &rga_qops;\n\tdst_vq->mem_ops = &vb2_dma_sg_memops;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->rga->mutex;\n\tdst_vq->dev = ctx->rga->v4l2_dev.dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int rga_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct rga_ctx *ctx = container_of(ctrl->handler, struct rga_ctx,\n\t\t\t\t\t   ctrl_handler);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->rga->ctrl_lock, flags);\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tctx->hflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tctx->vflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_ROTATE:\n\t\tctx->rotate = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_BG_COLOR:\n\t\tctx->fill_color = ctrl->val;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ctx->rga->ctrl_lock, flags);\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops rga_ctrl_ops = {\n\t.s_ctrl = rga_s_ctrl,\n};\n\nstatic int rga_setup_ctrls(struct rga_ctx *ctx)\n{\n\tstruct rockchip_rga *rga = ctx->rga;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, 4);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &rga_ctrl_ops,\n\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &rga_ctrl_ops,\n\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &rga_ctrl_ops,\n\t\t\t  V4L2_CID_ROTATE, 0, 270, 90, 0);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &rga_ctrl_ops,\n\t\t\t  V4L2_CID_BG_COLOR, 0, 0xffffffff, 1, 0);\n\n\tif (ctx->ctrl_handler.error) {\n\t\tint err = ctx->ctrl_handler.error;\n\n\t\tv4l2_err(&rga->v4l2_dev, \"%s failed\\n\", __func__);\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct rga_fmt formats[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_ARGB32,\n\t\t.color_swap = RGA_COLOR_RB_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_ABGR8888,\n\t\t.depth = 32,\n\t\t.uv_factor = 1,\n\t\t.y_div = 1,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_XRGB32,\n\t\t.color_swap = RGA_COLOR_RB_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_XBGR8888,\n\t\t.depth = 32,\n\t\t.uv_factor = 1,\n\t\t.y_div = 1,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_ABGR32,\n\t\t.color_swap = RGA_COLOR_ALPHA_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_ABGR8888,\n\t\t.depth = 32,\n\t\t.uv_factor = 1,\n\t\t.y_div = 1,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_XBGR32,\n\t\t.color_swap = RGA_COLOR_ALPHA_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_XBGR8888,\n\t\t.depth = 32,\n\t\t.uv_factor = 1,\n\t\t.y_div = 1,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_RGB24,\n\t\t.color_swap = RGA_COLOR_NONE_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_RGB888,\n\t\t.depth = 24,\n\t\t.uv_factor = 1,\n\t\t.y_div = 1,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_BGR24,\n\t\t.color_swap = RGA_COLOR_RB_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_RGB888,\n\t\t.depth = 24,\n\t\t.uv_factor = 1,\n\t\t.y_div = 1,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_ARGB444,\n\t\t.color_swap = RGA_COLOR_RB_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_ABGR4444,\n\t\t.depth = 16,\n\t\t.uv_factor = 1,\n\t\t.y_div = 1,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_ARGB555,\n\t\t.color_swap = RGA_COLOR_RB_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_ABGR1555,\n\t\t.depth = 16,\n\t\t.uv_factor = 1,\n\t\t.y_div = 1,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_RGB565,\n\t\t.color_swap = RGA_COLOR_RB_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_BGR565,\n\t\t.depth = 16,\n\t\t.uv_factor = 1,\n\t\t.y_div = 1,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV21,\n\t\t.color_swap = RGA_COLOR_UV_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_YUV420SP,\n\t\t.depth = 12,\n\t\t.uv_factor = 4,\n\t\t.y_div = 2,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV61,\n\t\t.color_swap = RGA_COLOR_UV_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_YUV422SP,\n\t\t.depth = 16,\n\t\t.uv_factor = 2,\n\t\t.y_div = 1,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV12,\n\t\t.color_swap = RGA_COLOR_NONE_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_YUV420SP,\n\t\t.depth = 12,\n\t\t.uv_factor = 4,\n\t\t.y_div = 2,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV16,\n\t\t.color_swap = RGA_COLOR_NONE_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_YUV422SP,\n\t\t.depth = 16,\n\t\t.uv_factor = 2,\n\t\t.y_div = 1,\n\t\t.x_div = 1,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_YUV420,\n\t\t.color_swap = RGA_COLOR_NONE_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_YUV420P,\n\t\t.depth = 12,\n\t\t.uv_factor = 4,\n\t\t.y_div = 2,\n\t\t.x_div = 2,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_YUV422P,\n\t\t.color_swap = RGA_COLOR_NONE_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_YUV422P,\n\t\t.depth = 16,\n\t\t.uv_factor = 2,\n\t\t.y_div = 1,\n\t\t.x_div = 2,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_YVU420,\n\t\t.color_swap = RGA_COLOR_UV_SWAP,\n\t\t.hw_format = RGA_COLOR_FMT_YUV420P,\n\t\t.depth = 12,\n\t\t.uv_factor = 4,\n\t\t.y_div = 2,\n\t\t.x_div = 2,\n\t},\n};\n\n#define NUM_FORMATS ARRAY_SIZE(formats)\n\nstatic struct rga_fmt *rga_fmt_find(struct v4l2_format *f)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < NUM_FORMATS; i++) {\n\t\tif (formats[i].fourcc == f->fmt.pix.pixelformat)\n\t\t\treturn &formats[i];\n\t}\n\treturn NULL;\n}\n\nstatic struct rga_frame def_frame = {\n\t.width = DEFAULT_WIDTH,\n\t.height = DEFAULT_HEIGHT,\n\t.colorspace = V4L2_COLORSPACE_DEFAULT,\n\t.crop.left = 0,\n\t.crop.top = 0,\n\t.crop.width = DEFAULT_WIDTH,\n\t.crop.height = DEFAULT_HEIGHT,\n\t.fmt = &formats[0],\n};\n\nstruct rga_frame *rga_get_frame(struct rga_ctx *ctx, enum v4l2_buf_type type)\n{\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\treturn &ctx->in;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn &ctx->out;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic int rga_open(struct file *file)\n{\n\tstruct rockchip_rga *rga = video_drvdata(file);\n\tstruct rga_ctx *ctx = NULL;\n\tint ret = 0;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->rga = rga;\n\t \n\tctx->in = def_frame;\n\tctx->out = def_frame;\n\n\tif (mutex_lock_interruptible(&rga->mutex)) {\n\t\tkfree(ctx);\n\t\treturn -ERESTARTSYS;\n\t}\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(rga->m2m_dev, ctx, &queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tmutex_unlock(&rga->mutex);\n\t\tkfree(ctx);\n\t\treturn ret;\n\t}\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\trga_setup_ctrls(ctx);\n\n\t \n\tv4l2_ctrl_handler_setup(&ctx->ctrl_handler);\n\n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\tmutex_unlock(&rga->mutex);\n\n\treturn 0;\n}\n\nstatic int rga_release(struct file *file)\n{\n\tstruct rga_ctx *ctx =\n\t\tcontainer_of(file->private_data, struct rga_ctx, fh);\n\tstruct rockchip_rga *rga = ctx->rga;\n\n\tmutex_lock(&rga->mutex);\n\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\n\tmutex_unlock(&rga->mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations rga_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rga_open,\n\t.release = rga_release,\n\t.poll = v4l2_m2m_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap = v4l2_m2m_fop_mmap,\n};\n\nstatic int\nvidioc_querycap(struct file *file, void *priv, struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, RGA_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, \"rockchip-rga\", sizeof(cap->card));\n\tstrscpy(cap->bus_info, \"platform:rga\", sizeof(cap->bus_info));\n\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt(struct file *file, void *prv, struct v4l2_fmtdesc *f)\n{\n\tstruct rga_fmt *fmt;\n\n\tif (f->index >= NUM_FORMATS)\n\t\treturn -EINVAL;\n\n\tfmt = &formats[f->index];\n\tf->pixelformat = fmt->fourcc;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt(struct file *file, void *prv, struct v4l2_format *f)\n{\n\tstruct rga_ctx *ctx = prv;\n\tstruct vb2_queue *vq;\n\tstruct rga_frame *frm;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\tfrm = rga_get_frame(ctx, f->type);\n\tif (IS_ERR(frm))\n\t\treturn PTR_ERR(frm);\n\n\tf->fmt.pix.width = frm->width;\n\tf->fmt.pix.height = frm->height;\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\tf->fmt.pix.pixelformat = frm->fmt->fourcc;\n\tf->fmt.pix.bytesperline = frm->stride;\n\tf->fmt.pix.sizeimage = frm->size;\n\tf->fmt.pix.colorspace = frm->colorspace;\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt(struct file *file, void *prv, struct v4l2_format *f)\n{\n\tstruct rga_fmt *fmt;\n\n\tfmt = rga_fmt_find(f);\n\tif (!fmt) {\n\t\tfmt = &formats[0];\n\t\tf->fmt.pix.pixelformat = fmt->fourcc;\n\t}\n\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\n\tif (f->fmt.pix.width > MAX_WIDTH)\n\t\tf->fmt.pix.width = MAX_WIDTH;\n\tif (f->fmt.pix.height > MAX_HEIGHT)\n\t\tf->fmt.pix.height = MAX_HEIGHT;\n\n\tif (f->fmt.pix.width < MIN_WIDTH)\n\t\tf->fmt.pix.width = MIN_WIDTH;\n\tif (f->fmt.pix.height < MIN_HEIGHT)\n\t\tf->fmt.pix.height = MIN_HEIGHT;\n\n\tif (fmt->hw_format >= RGA_COLOR_FMT_YUV422SP)\n\t\tf->fmt.pix.bytesperline = f->fmt.pix.width;\n\telse\n\t\tf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\n\n\tf->fmt.pix.sizeimage =\n\t\tf->fmt.pix.height * (f->fmt.pix.width * fmt->depth) >> 3;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt(struct file *file, void *prv, struct v4l2_format *f)\n{\n\tstruct rga_ctx *ctx = prv;\n\tstruct rockchip_rga *rga = ctx->rga;\n\tstruct vb2_queue *vq;\n\tstruct rga_frame *frm;\n\tstruct rga_fmt *fmt;\n\tint ret = 0;\n\n\t \n\tret = vidioc_try_fmt(file, prv, f);\n\tif (ret)\n\t\treturn ret;\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&rga->v4l2_dev, \"queue (%d) bust\\n\", f->type);\n\t\treturn -EBUSY;\n\t}\n\tfrm = rga_get_frame(ctx, f->type);\n\tif (IS_ERR(frm))\n\t\treturn PTR_ERR(frm);\n\tfmt = rga_fmt_find(f);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\tfrm->width = f->fmt.pix.width;\n\tfrm->height = f->fmt.pix.height;\n\tfrm->size = f->fmt.pix.sizeimage;\n\tfrm->fmt = fmt;\n\tfrm->stride = f->fmt.pix.bytesperline;\n\tfrm->colorspace = f->fmt.pix.colorspace;\n\n\t \n\tfrm->crop.left = 0;\n\tfrm->crop.top = 0;\n\tfrm->crop.width = frm->width;\n\tfrm->crop.height = frm->height;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_selection(struct file *file, void *prv,\n\t\t\t      struct v4l2_selection *s)\n{\n\tstruct rga_ctx *ctx = prv;\n\tstruct rga_frame *f;\n\tbool use_frame = false;\n\n\tf = rga_get_frame(ctx, s->type);\n\tif (IS_ERR(f))\n\t\treturn PTR_ERR(f);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tuse_frame = true;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tuse_frame = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (use_frame) {\n\t\ts->r = f->crop;\n\t} else {\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = f->width;\n\t\ts->r.height = f->height;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_s_selection(struct file *file, void *prv,\n\t\t\t      struct v4l2_selection *s)\n{\n\tstruct rga_ctx *ctx = prv;\n\tstruct rockchip_rga *rga = ctx->rga;\n\tstruct rga_frame *f;\n\tint ret = 0;\n\n\tf = rga_get_frame(ctx, s->type);\n\tif (IS_ERR(f))\n\t\treturn PTR_ERR(f);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\t \n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\t \n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (s->r.top < 0 || s->r.left < 0) {\n\t\tv4l2_dbg(debug, 1, &rga->v4l2_dev,\n\t\t\t \"doesn't support negative values for top & left.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (s->r.left + s->r.width > f->width ||\n\t    s->r.top + s->r.height > f->height ||\n\t    s->r.width < MIN_WIDTH || s->r.height < MIN_HEIGHT) {\n\t\tv4l2_dbg(debug, 1, &rga->v4l2_dev, \"unsupported crop value.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tf->crop = s->r;\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ioctl_ops rga_ioctl_ops = {\n\t.vidioc_querycap = vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt,\n\t.vidioc_g_fmt_vid_cap = vidioc_g_fmt,\n\t.vidioc_try_fmt_vid_cap = vidioc_try_fmt,\n\t.vidioc_s_fmt_vid_cap = vidioc_s_fmt,\n\n\t.vidioc_enum_fmt_vid_out = vidioc_enum_fmt,\n\t.vidioc_g_fmt_vid_out = vidioc_g_fmt,\n\t.vidioc_try_fmt_vid_out = vidioc_try_fmt,\n\t.vidioc_s_fmt_vid_out = vidioc_s_fmt,\n\n\t.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\n\t.vidioc_streamon = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_g_selection = vidioc_g_selection,\n\t.vidioc_s_selection = vidioc_s_selection,\n};\n\nstatic const struct video_device rga_videodev = {\n\t.name = \"rockchip-rga\",\n\t.fops = &rga_fops,\n\t.ioctl_ops = &rga_ioctl_ops,\n\t.minor = -1,\n\t.release = video_device_release,\n\t.vfl_dir = VFL_DIR_M2M,\n\t.device_caps = V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING,\n};\n\nstatic int rga_enable_clocks(struct rockchip_rga *rga)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(rga->sclk);\n\tif (ret) {\n\t\tdev_err(rga->dev, \"Cannot enable rga sclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(rga->aclk);\n\tif (ret) {\n\t\tdev_err(rga->dev, \"Cannot enable rga aclk: %d\\n\", ret);\n\t\tgoto err_disable_sclk;\n\t}\n\n\tret = clk_prepare_enable(rga->hclk);\n\tif (ret) {\n\t\tdev_err(rga->dev, \"Cannot enable rga hclk: %d\\n\", ret);\n\t\tgoto err_disable_aclk;\n\t}\n\n\treturn 0;\n\nerr_disable_aclk:\n\tclk_disable_unprepare(rga->aclk);\nerr_disable_sclk:\n\tclk_disable_unprepare(rga->sclk);\n\n\treturn ret;\n}\n\nstatic void rga_disable_clocks(struct rockchip_rga *rga)\n{\n\tclk_disable_unprepare(rga->sclk);\n\tclk_disable_unprepare(rga->hclk);\n\tclk_disable_unprepare(rga->aclk);\n}\n\nstatic int rga_parse_dt(struct rockchip_rga *rga)\n{\n\tstruct reset_control *core_rst, *axi_rst, *ahb_rst;\n\n\tcore_rst = devm_reset_control_get(rga->dev, \"core\");\n\tif (IS_ERR(core_rst)) {\n\t\tdev_err(rga->dev, \"failed to get core reset controller\\n\");\n\t\treturn PTR_ERR(core_rst);\n\t}\n\n\taxi_rst = devm_reset_control_get(rga->dev, \"axi\");\n\tif (IS_ERR(axi_rst)) {\n\t\tdev_err(rga->dev, \"failed to get axi reset controller\\n\");\n\t\treturn PTR_ERR(axi_rst);\n\t}\n\n\tahb_rst = devm_reset_control_get(rga->dev, \"ahb\");\n\tif (IS_ERR(ahb_rst)) {\n\t\tdev_err(rga->dev, \"failed to get ahb reset controller\\n\");\n\t\treturn PTR_ERR(ahb_rst);\n\t}\n\n\treset_control_assert(core_rst);\n\tudelay(1);\n\treset_control_deassert(core_rst);\n\n\treset_control_assert(axi_rst);\n\tudelay(1);\n\treset_control_deassert(axi_rst);\n\n\treset_control_assert(ahb_rst);\n\tudelay(1);\n\treset_control_deassert(ahb_rst);\n\n\trga->sclk = devm_clk_get(rga->dev, \"sclk\");\n\tif (IS_ERR(rga->sclk)) {\n\t\tdev_err(rga->dev, \"failed to get sclk clock\\n\");\n\t\treturn PTR_ERR(rga->sclk);\n\t}\n\n\trga->aclk = devm_clk_get(rga->dev, \"aclk\");\n\tif (IS_ERR(rga->aclk)) {\n\t\tdev_err(rga->dev, \"failed to get aclk clock\\n\");\n\t\treturn PTR_ERR(rga->aclk);\n\t}\n\n\trga->hclk = devm_clk_get(rga->dev, \"hclk\");\n\tif (IS_ERR(rga->hclk)) {\n\t\tdev_err(rga->dev, \"failed to get hclk clock\\n\");\n\t\treturn PTR_ERR(rga->hclk);\n\t}\n\n\treturn 0;\n}\n\nstatic int rga_probe(struct platform_device *pdev)\n{\n\tstruct rockchip_rga *rga;\n\tstruct video_device *vfd;\n\tint ret = 0;\n\tint irq;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\trga = devm_kzalloc(&pdev->dev, sizeof(*rga), GFP_KERNEL);\n\tif (!rga)\n\t\treturn -ENOMEM;\n\n\trga->dev = &pdev->dev;\n\tspin_lock_init(&rga->ctrl_lock);\n\tmutex_init(&rga->mutex);\n\n\tret = rga_parse_dt(rga);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Unable to parse OF data\\n\");\n\n\tpm_runtime_enable(rga->dev);\n\n\trga->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rga->regs)) {\n\t\tret = PTR_ERR(rga->regs);\n\t\tgoto err_put_clk;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_put_clk;\n\t}\n\n\tret = devm_request_irq(rga->dev, irq, rga_isr, 0,\n\t\t\t       dev_name(rga->dev), rga);\n\tif (ret < 0) {\n\t\tdev_err(rga->dev, \"failed to request irq\\n\");\n\t\tgoto err_put_clk;\n\t}\n\n\tret = v4l2_device_register(&pdev->dev, &rga->v4l2_dev);\n\tif (ret)\n\t\tgoto err_put_clk;\n\tvfd = video_device_alloc();\n\tif (!vfd) {\n\t\tv4l2_err(&rga->v4l2_dev, \"Failed to allocate video device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto unreg_v4l2_dev;\n\t}\n\t*vfd = rga_videodev;\n\tvfd->lock = &rga->mutex;\n\tvfd->v4l2_dev = &rga->v4l2_dev;\n\n\tvideo_set_drvdata(vfd, rga);\n\trga->vfd = vfd;\n\n\tplatform_set_drvdata(pdev, rga);\n\trga->m2m_dev = v4l2_m2m_init(&rga_m2m_ops);\n\tif (IS_ERR(rga->m2m_dev)) {\n\t\tv4l2_err(&rga->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(rga->m2m_dev);\n\t\tgoto rel_vdev;\n\t}\n\n\tret = pm_runtime_resume_and_get(rga->dev);\n\tif (ret < 0)\n\t\tgoto rel_m2m;\n\n\trga->version.major = (rga_read(rga, RGA_VERSION_INFO) >> 24) & 0xFF;\n\trga->version.minor = (rga_read(rga, RGA_VERSION_INFO) >> 20) & 0x0F;\n\n\tv4l2_info(&rga->v4l2_dev, \"HW Version: 0x%02x.%02x\\n\",\n\t\t  rga->version.major, rga->version.minor);\n\n\tpm_runtime_put(rga->dev);\n\n\t \n\trga->cmdbuf_virt = dma_alloc_attrs(rga->dev, RGA_CMDBUF_SIZE,\n\t\t\t\t\t   &rga->cmdbuf_phy, GFP_KERNEL,\n\t\t\t\t\t   DMA_ATTR_WRITE_COMBINE);\n\tif (!rga->cmdbuf_virt) {\n\t\tret = -ENOMEM;\n\t\tgoto rel_m2m;\n\t}\n\n\trga->src_mmu_pages =\n\t\t(unsigned int *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 3);\n\tif (!rga->src_mmu_pages) {\n\t\tret = -ENOMEM;\n\t\tgoto free_dma;\n\t}\n\trga->dst_mmu_pages =\n\t\t(unsigned int *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 3);\n\tif (!rga->dst_mmu_pages) {\n\t\tret = -ENOMEM;\n\t\tgoto free_src_pages;\n\t}\n\n\tdef_frame.stride = (def_frame.width * def_frame.fmt->depth) >> 3;\n\tdef_frame.size = def_frame.stride * def_frame.height;\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(&rga->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto free_dst_pages;\n\t}\n\n\tv4l2_info(&rga->v4l2_dev, \"Registered %s as /dev/%s\\n\",\n\t\t  vfd->name, video_device_node_name(vfd));\n\n\treturn 0;\n\nfree_dst_pages:\n\tfree_pages((unsigned long)rga->dst_mmu_pages, 3);\nfree_src_pages:\n\tfree_pages((unsigned long)rga->src_mmu_pages, 3);\nfree_dma:\n\tdma_free_attrs(rga->dev, RGA_CMDBUF_SIZE, rga->cmdbuf_virt,\n\t\t       rga->cmdbuf_phy, DMA_ATTR_WRITE_COMBINE);\nrel_m2m:\n\tv4l2_m2m_release(rga->m2m_dev);\nrel_vdev:\n\tvideo_device_release(vfd);\nunreg_v4l2_dev:\n\tv4l2_device_unregister(&rga->v4l2_dev);\nerr_put_clk:\n\tpm_runtime_disable(rga->dev);\n\n\treturn ret;\n}\n\nstatic void rga_remove(struct platform_device *pdev)\n{\n\tstruct rockchip_rga *rga = platform_get_drvdata(pdev);\n\n\tdma_free_attrs(rga->dev, RGA_CMDBUF_SIZE, rga->cmdbuf_virt,\n\t\t       rga->cmdbuf_phy, DMA_ATTR_WRITE_COMBINE);\n\n\tfree_pages((unsigned long)rga->src_mmu_pages, 3);\n\tfree_pages((unsigned long)rga->dst_mmu_pages, 3);\n\n\tv4l2_info(&rga->v4l2_dev, \"Removing\\n\");\n\n\tv4l2_m2m_release(rga->m2m_dev);\n\tvideo_unregister_device(rga->vfd);\n\tv4l2_device_unregister(&rga->v4l2_dev);\n\n\tpm_runtime_disable(rga->dev);\n}\n\nstatic int __maybe_unused rga_runtime_suspend(struct device *dev)\n{\n\tstruct rockchip_rga *rga = dev_get_drvdata(dev);\n\n\trga_disable_clocks(rga);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rga_runtime_resume(struct device *dev)\n{\n\tstruct rockchip_rga *rga = dev_get_drvdata(dev);\n\n\treturn rga_enable_clocks(rga);\n}\n\nstatic const struct dev_pm_ops rga_pm = {\n\tSET_RUNTIME_PM_OPS(rga_runtime_suspend,\n\t\t\t   rga_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id rockchip_rga_match[] = {\n\t{\n\t\t.compatible = \"rockchip,rk3288-rga\",\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3399-rga\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, rockchip_rga_match);\n\nstatic struct platform_driver rga_pdrv = {\n\t.probe = rga_probe,\n\t.remove_new = rga_remove,\n\t.driver = {\n\t\t.name = RGA_NAME,\n\t\t.pm = &rga_pm,\n\t\t.of_match_table = rockchip_rga_match,\n\t},\n};\n\nmodule_platform_driver(rga_pdrv);\n\nMODULE_AUTHOR(\"Jacob Chen <jacob-chen@iotwrt.com>\");\nMODULE_DESCRIPTION(\"Rockchip Raster 2d Graphic Acceleration Unit\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}