{
  "module_name": "rga-buf.c",
  "hash_id": "95c3be922ee98760efcf52cdea260ef00b43e384a702dece9e3e4ff7f8e8e4a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/rockchip/rga/rga-buf.c",
  "human_readable_source": "\n \n\n#include <linux/pm_runtime.h>\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-sg.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"rga-hw.h\"\n#include \"rga.h\"\n\nstatic int\nrga_queue_setup(struct vb2_queue *vq,\n\t\tunsigned int *nbuffers, unsigned int *nplanes,\n\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct rga_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct rga_frame *f = rga_get_frame(ctx, vq->type);\n\n\tif (IS_ERR(f))\n\t\treturn PTR_ERR(f);\n\n\tif (*nplanes)\n\t\treturn sizes[0] < f->size ? -EINVAL : 0;\n\n\tsizes[0] = f->size;\n\t*nplanes = 1;\n\n\treturn 0;\n}\n\nstatic int rga_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct rga_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct rga_frame *f = rga_get_frame(ctx, vb->vb2_queue->type);\n\n\tif (IS_ERR(f))\n\t\treturn PTR_ERR(f);\n\n\tvb2_set_plane_payload(vb, 0, f->size);\n\n\treturn 0;\n}\n\nstatic void rga_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct rga_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic void rga_buf_return_buffers(struct vb2_queue *q,\n\t\t\t\t   enum vb2_buffer_state state)\n{\n\tstruct rga_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tfor (;;) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (!vbuf)\n\t\t\tbreak;\n\t\tv4l2_m2m_buf_done(vbuf, state);\n\t}\n}\n\nstatic int rga_buf_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct rga_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct rockchip_rga *rga = ctx->rga;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(rga->dev);\n\tif (ret < 0) {\n\t\trga_buf_return_buffers(q, VB2_BUF_STATE_QUEUED);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rga_buf_stop_streaming(struct vb2_queue *q)\n{\n\tstruct rga_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct rockchip_rga *rga = ctx->rga;\n\n\trga_buf_return_buffers(q, VB2_BUF_STATE_ERROR);\n\tpm_runtime_put(rga->dev);\n}\n\nconst struct vb2_ops rga_qops = {\n\t.queue_setup = rga_queue_setup,\n\t.buf_prepare = rga_buf_prepare,\n\t.buf_queue = rga_buf_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = rga_buf_start_streaming,\n\t.stop_streaming = rga_buf_stop_streaming,\n};\n\n \nvoid rga_buf_map(struct vb2_buffer *vb)\n{\n\tstruct rga_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct rockchip_rga *rga = ctx->rga;\n\tstruct sg_table *sgt;\n\tstruct scatterlist *sgl;\n\tunsigned int *pages;\n\tunsigned int address, len, i, p;\n\tunsigned int mapped_size = 0;\n\n\tif (vb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tpages = rga->src_mmu_pages;\n\telse\n\t\tpages = rga->dst_mmu_pages;\n\n\t \n\tsgt = vb2_plane_cookie(vb, 0);\n\n\tfor_each_sg(sgt->sgl, sgl, sgt->nents, i) {\n\t\tlen = sg_dma_len(sgl) >> PAGE_SHIFT;\n\t\taddress = sg_phys(sgl);\n\n\t\tfor (p = 0; p < len; p++) {\n\t\t\tdma_addr_t phys = address +\n\t\t\t\t\t  ((dma_addr_t)p << PAGE_SHIFT);\n\n\t\t\tpages[mapped_size + p] = phys;\n\t\t}\n\n\t\tmapped_size += len;\n\t}\n\n\t \n\tdma_sync_single_for_device(rga->dev, virt_to_phys(pages),\n\t\t\t\t   8 * PAGE_SIZE, DMA_BIDIRECTIONAL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}