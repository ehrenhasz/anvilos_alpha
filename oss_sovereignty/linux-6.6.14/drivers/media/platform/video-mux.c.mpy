{
  "module_name": "video-mux.c",
  "hash_id": "45378e8049731c9f98bca1a2aa1eba9e60db8a289a5be07f8098a2fab4268e6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/video-mux.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/mux/consumer.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n\nstruct video_mux {\n\tstruct v4l2_subdev subdev;\n\tstruct v4l2_async_notifier notifier;\n\tstruct media_pad *pads;\n\tstruct mux_control *mux;\n\tstruct mutex lock;\n\tint active;\n};\n\nstatic const struct v4l2_mbus_framefmt video_mux_format_mbus_default = {\n\t.width = 1,\n\t.height = 1,\n\t.code = MEDIA_BUS_FMT_Y8_1X8,\n\t.field = V4L2_FIELD_NONE,\n};\n\nstatic inline struct video_mux *\nnotifier_to_video_mux(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct video_mux, notifier);\n}\n\nstatic inline struct video_mux *v4l2_subdev_to_video_mux(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct video_mux, subdev);\n}\n\nstatic int video_mux_link_setup(struct media_entity *entity,\n\t\t\t\tconst struct media_pad *local,\n\t\t\t\tconst struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct video_mux *vmux = v4l2_subdev_to_video_mux(sd);\n\tu16 source_pad = entity->num_pads - 1;\n\tint ret = 0;\n\n\t \n\tif (local->flags & MEDIA_PAD_FL_SOURCE)\n\t\treturn 0;\n\n\tdev_dbg(sd->dev, \"link setup '%s':%d->'%s':%d[%d]\",\n\t\tremote->entity->name, remote->index, local->entity->name,\n\t\tlocal->index, flags & MEDIA_LNK_FL_ENABLED);\n\n\tmutex_lock(&vmux->lock);\n\n\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\tstruct v4l2_subdev_state *sd_state;\n\t\tstruct v4l2_mbus_framefmt *source_mbusformat;\n\n\t\tif (vmux->active == local->index)\n\t\t\tgoto out;\n\n\t\tif (vmux->active >= 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdev_dbg(sd->dev, \"setting %d active\\n\", local->index);\n\t\tret = mux_control_try_select(vmux->mux, local->index);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tvmux->active = local->index;\n\n\t\t \n\t\tsd_state = v4l2_subdev_lock_and_get_active_state(sd);\n\t\tsource_mbusformat = v4l2_subdev_get_pad_format(sd, sd_state,\n\t\t\t\t\t\t\t       source_pad);\n\t\t*source_mbusformat = *v4l2_subdev_get_pad_format(sd, sd_state,\n\t\t\t\t\t\t\t\t vmux->active);\n\t\tv4l2_subdev_unlock_state(sd_state);\n\t} else {\n\t\tif (vmux->active != local->index)\n\t\t\tgoto out;\n\n\t\tdev_dbg(sd->dev, \"going inactive\\n\");\n\t\tmux_control_deselect(vmux->mux);\n\t\tvmux->active = -1;\n\t}\n\nout:\n\tmutex_unlock(&vmux->lock);\n\treturn ret;\n}\n\nstatic const struct media_entity_operations video_mux_ops = {\n\t.link_setup = video_mux_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n\t.get_fwnode_pad = v4l2_subdev_get_fwnode_pad_1_to_1,\n};\n\nstatic int video_mux_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct video_mux *vmux = v4l2_subdev_to_video_mux(sd);\n\tstruct v4l2_subdev *upstream_sd;\n\tstruct media_pad *pad;\n\n\tif (vmux->active == -1) {\n\t\tdev_err(sd->dev, \"Can not start streaming on inactive mux\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpad = media_pad_remote_pad_first(&sd->entity.pads[vmux->active]);\n\tif (!pad) {\n\t\tdev_err(sd->dev, \"Failed to find remote source pad\\n\");\n\t\treturn -ENOLINK;\n\t}\n\n\tif (!is_media_entity_v4l2_subdev(pad->entity)) {\n\t\tdev_err(sd->dev, \"Upstream entity is not a v4l2 subdev\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tupstream_sd = media_entity_to_v4l2_subdev(pad->entity);\n\n\treturn v4l2_subdev_call(upstream_sd, video, s_stream, enable);\n}\n\nstatic const struct v4l2_subdev_video_ops video_mux_subdev_video_ops = {\n\t.s_stream = video_mux_s_stream,\n};\n\nstatic int video_mux_set_format(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *sdformat)\n{\n\tstruct video_mux *vmux = v4l2_subdev_to_video_mux(sd);\n\tstruct v4l2_mbus_framefmt *mbusformat, *source_mbusformat;\n\tstruct media_pad *pad = &vmux->pads[sdformat->pad];\n\tu16 source_pad = sd->entity.num_pads - 1;\n\n\tmbusformat = v4l2_subdev_get_pad_format(sd, sd_state, sdformat->pad);\n\tif (!mbusformat)\n\t\treturn -EINVAL;\n\n\tsource_mbusformat = v4l2_subdev_get_pad_format(sd, sd_state, source_pad);\n\tif (!source_mbusformat)\n\t\treturn -EINVAL;\n\n\t \n\tv4l_bound_align_image(&sdformat->format.width, 1, 65536, 0,\n\t\t\t      &sdformat->format.height, 1, 65536, 0, 0);\n\n\t \n\tswitch (sdformat->format.code) {\n\tcase MEDIA_BUS_FMT_RGB444_1X12:\n\tcase MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE:\n\tcase MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE:\n\tcase MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE:\n\tcase MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\tcase MEDIA_BUS_FMT_BGR565_2X8_BE:\n\tcase MEDIA_BUS_FMT_BGR565_2X8_LE:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_BE:\n\tcase MEDIA_BUS_FMT_RGB565_2X8_LE:\n\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\tcase MEDIA_BUS_FMT_RBG888_1X24:\n\tcase MEDIA_BUS_FMT_RGB666_1X24_CPADHI:\n\tcase MEDIA_BUS_FMT_BGR888_1X24:\n\tcase MEDIA_BUS_FMT_GBR888_1X24:\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\tcase MEDIA_BUS_FMT_RGB888_2X12_BE:\n\tcase MEDIA_BUS_FMT_RGB888_2X12_LE:\n\tcase MEDIA_BUS_FMT_ARGB8888_1X32:\n\tcase MEDIA_BUS_FMT_RGB888_1X32_PADHI:\n\tcase MEDIA_BUS_FMT_RGB101010_1X30:\n\tcase MEDIA_BUS_FMT_RGB121212_1X36:\n\tcase MEDIA_BUS_FMT_RGB161616_1X48:\n\tcase MEDIA_BUS_FMT_Y8_1X8:\n\tcase MEDIA_BUS_FMT_UV8_1X8:\n\tcase MEDIA_BUS_FMT_UYVY8_1_5X8:\n\tcase MEDIA_BUS_FMT_VYUY8_1_5X8:\n\tcase MEDIA_BUS_FMT_YUYV8_1_5X8:\n\tcase MEDIA_BUS_FMT_YVYU8_1_5X8:\n\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\tcase MEDIA_BUS_FMT_Y10_1X10:\n\tcase MEDIA_BUS_FMT_UYVY10_2X10:\n\tcase MEDIA_BUS_FMT_VYUY10_2X10:\n\tcase MEDIA_BUS_FMT_YUYV10_2X10:\n\tcase MEDIA_BUS_FMT_YVYU10_2X10:\n\tcase MEDIA_BUS_FMT_Y12_1X12:\n\tcase MEDIA_BUS_FMT_UYVY12_2X12:\n\tcase MEDIA_BUS_FMT_VYUY12_2X12:\n\tcase MEDIA_BUS_FMT_YUYV12_2X12:\n\tcase MEDIA_BUS_FMT_YVYU12_2X12:\n\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\tcase MEDIA_BUS_FMT_VYUY8_1X16:\n\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\tcase MEDIA_BUS_FMT_YVYU8_1X16:\n\tcase MEDIA_BUS_FMT_YDYUYDYV8_1X16:\n\tcase MEDIA_BUS_FMT_UYVY10_1X20:\n\tcase MEDIA_BUS_FMT_VYUY10_1X20:\n\tcase MEDIA_BUS_FMT_YUYV10_1X20:\n\tcase MEDIA_BUS_FMT_YVYU10_1X20:\n\tcase MEDIA_BUS_FMT_VUY8_1X24:\n\tcase MEDIA_BUS_FMT_YUV8_1X24:\n\tcase MEDIA_BUS_FMT_UYYVYY8_0_5X24:\n\tcase MEDIA_BUS_FMT_UYVY12_1X24:\n\tcase MEDIA_BUS_FMT_VYUY12_1X24:\n\tcase MEDIA_BUS_FMT_YUYV12_1X24:\n\tcase MEDIA_BUS_FMT_YVYU12_1X24:\n\tcase MEDIA_BUS_FMT_YUV10_1X30:\n\tcase MEDIA_BUS_FMT_UYYVYY10_0_5X30:\n\tcase MEDIA_BUS_FMT_AYUV8_1X32:\n\tcase MEDIA_BUS_FMT_UYYVYY12_0_5X36:\n\tcase MEDIA_BUS_FMT_YUV12_1X36:\n\tcase MEDIA_BUS_FMT_YUV16_1X48:\n\tcase MEDIA_BUS_FMT_UYYVYY16_0_5X48:\n\tcase MEDIA_BUS_FMT_JPEG_1X8:\n\tcase MEDIA_BUS_FMT_AHSV8888_1X32:\n\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\tcase MEDIA_BUS_FMT_SGBRG10_1X10:\n\tcase MEDIA_BUS_FMT_SGRBG10_1X10:\n\tcase MEDIA_BUS_FMT_SRGGB10_1X10:\n\tcase MEDIA_BUS_FMT_SBGGR12_1X12:\n\tcase MEDIA_BUS_FMT_SGBRG12_1X12:\n\tcase MEDIA_BUS_FMT_SGRBG12_1X12:\n\tcase MEDIA_BUS_FMT_SRGGB12_1X12:\n\tcase MEDIA_BUS_FMT_SBGGR14_1X14:\n\tcase MEDIA_BUS_FMT_SGBRG14_1X14:\n\tcase MEDIA_BUS_FMT_SGRBG14_1X14:\n\tcase MEDIA_BUS_FMT_SRGGB14_1X14:\n\tcase MEDIA_BUS_FMT_SBGGR16_1X16:\n\tcase MEDIA_BUS_FMT_SGBRG16_1X16:\n\tcase MEDIA_BUS_FMT_SGRBG16_1X16:\n\tcase MEDIA_BUS_FMT_SRGGB16_1X16:\n\t\tbreak;\n\tdefault:\n\t\tsdformat->format.code = MEDIA_BUS_FMT_Y8_1X8;\n\t\tbreak;\n\t}\n\tif (sdformat->format.field == V4L2_FIELD_ANY)\n\t\tsdformat->format.field = V4L2_FIELD_NONE;\n\n\tmutex_lock(&vmux->lock);\n\n\t \n\tif ((pad->flags & MEDIA_PAD_FL_SOURCE) && vmux->active >= 0)\n\t\tsdformat->format = *v4l2_subdev_get_pad_format(sd, sd_state,\n\t\t\t\t\t\t\t       vmux->active);\n\n\t*mbusformat = sdformat->format;\n\n\t \n\tif ((pad->flags & MEDIA_PAD_FL_SINK) && (pad->index == vmux->active))\n\t\t*source_mbusformat = sdformat->format;\n\n\tmutex_unlock(&vmux->lock);\n\n\treturn 0;\n}\n\nstatic int video_mux_init_cfg(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state)\n{\n\tstruct video_mux *vmux = v4l2_subdev_to_video_mux(sd);\n\tstruct v4l2_mbus_framefmt *mbusformat;\n\tunsigned int i;\n\n\tmutex_lock(&vmux->lock);\n\n\tfor (i = 0; i < sd->entity.num_pads; i++) {\n\t\tmbusformat = v4l2_subdev_get_pad_format(sd, sd_state, i);\n\t\t*mbusformat = video_mux_format_mbus_default;\n\t}\n\n\tmutex_unlock(&vmux->lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops video_mux_pad_ops = {\n\t.init_cfg = video_mux_init_cfg,\n\t.get_fmt = v4l2_subdev_get_fmt,\n\t.set_fmt = video_mux_set_format,\n};\n\nstatic const struct v4l2_subdev_ops video_mux_subdev_ops = {\n\t.pad = &video_mux_pad_ops,\n\t.video = &video_mux_subdev_video_ops,\n};\n\nstatic int video_mux_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t  struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_async_connection *asd)\n{\n\tstruct video_mux *vmux = notifier_to_video_mux(notifier);\n\n\treturn v4l2_create_fwnode_links(sd, &vmux->subdev);\n}\n\nstatic const struct v4l2_async_notifier_operations video_mux_notify_ops = {\n\t.bound = video_mux_notify_bound,\n};\n\nstatic int video_mux_async_register(struct video_mux *vmux,\n\t\t\t\t    unsigned int num_input_pads)\n{\n\tunsigned int i;\n\tint ret;\n\n\tv4l2_async_subdev_nf_init(&vmux->notifier, &vmux->subdev);\n\n\tfor (i = 0; i < num_input_pads; i++) {\n\t\tstruct v4l2_async_connection *asd;\n\t\tstruct fwnode_handle *ep, *remote_ep;\n\n\t\tep = fwnode_graph_get_endpoint_by_id(\n\t\t\tdev_fwnode(vmux->subdev.dev), i, 0,\n\t\t\tFWNODE_GRAPH_ENDPOINT_NEXT);\n\t\tif (!ep)\n\t\t\tcontinue;\n\n\t\t \n\t\tremote_ep = fwnode_graph_get_remote_endpoint(ep);\n\t\tif (!remote_ep) {\n\t\t\tfwnode_handle_put(ep);\n\t\t\tcontinue;\n\t\t}\n\t\tfwnode_handle_put(remote_ep);\n\n\t\tasd = v4l2_async_nf_add_fwnode_remote(&vmux->notifier, ep,\n\t\t\t\t\t\t      struct v4l2_async_connection);\n\n\t\tfwnode_handle_put(ep);\n\n\t\tif (IS_ERR(asd)) {\n\t\t\tret = PTR_ERR(asd);\n\t\t\t \n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto err_nf_cleanup;\n\t\t}\n\t}\n\n\tvmux->notifier.ops = &video_mux_notify_ops;\n\n\tret = v4l2_async_nf_register(&vmux->notifier);\n\tif (ret)\n\t\tgoto err_nf_cleanup;\n\n\tret = v4l2_async_register_subdev(&vmux->subdev);\n\tif (ret)\n\t\tgoto err_nf_unregister;\n\n\treturn 0;\n\nerr_nf_unregister:\n\tv4l2_async_nf_unregister(&vmux->notifier);\nerr_nf_cleanup:\n\tv4l2_async_nf_cleanup(&vmux->notifier);\n\treturn ret;\n}\n\nstatic int video_mux_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *ep;\n\tstruct video_mux *vmux;\n\tunsigned int num_pads = 0;\n\tunsigned int i;\n\tint ret;\n\n\tvmux = devm_kzalloc(dev, sizeof(*vmux), GFP_KERNEL);\n\tif (!vmux)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, vmux);\n\n\tv4l2_subdev_init(&vmux->subdev, &video_mux_subdev_ops);\n\tsnprintf(vmux->subdev.name, sizeof(vmux->subdev.name), \"%pOFn\", np);\n\tvmux->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tvmux->subdev.dev = dev;\n\n\t \n\tfor_each_endpoint_of_node(np, ep) {\n\t\tstruct of_endpoint endpoint;\n\n\t\tof_graph_parse_endpoint(ep, &endpoint);\n\t\tnum_pads = max(num_pads, endpoint.port + 1);\n\t}\n\n\tif (num_pads < 2) {\n\t\tdev_err(dev, \"Not enough ports %d\\n\", num_pads);\n\t\treturn -EINVAL;\n\t}\n\n\tvmux->mux = devm_mux_control_get(dev, NULL);\n\tif (IS_ERR(vmux->mux)) {\n\t\tret = PTR_ERR(vmux->mux);\n\t\treturn dev_err_probe(dev, ret, \"Failed to get mux\\n\");\n\t}\n\n\tmutex_init(&vmux->lock);\n\tvmux->active = -1;\n\tvmux->pads = devm_kcalloc(dev, num_pads, sizeof(*vmux->pads),\n\t\t\t\t  GFP_KERNEL);\n\tif (!vmux->pads)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_pads; i++)\n\t\tvmux->pads[i].flags = (i < num_pads - 1) ? MEDIA_PAD_FL_SINK\n\t\t\t\t\t\t\t : MEDIA_PAD_FL_SOURCE;\n\n\tvmux->subdev.entity.function = MEDIA_ENT_F_VID_MUX;\n\tret = media_entity_pads_init(&vmux->subdev.entity, num_pads,\n\t\t\t\t     vmux->pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvmux->subdev.entity.ops = &video_mux_ops;\n\n\tret = v4l2_subdev_init_finalize(&vmux->subdev);\n\tif (ret < 0)\n\t\tgoto err_entity_cleanup;\n\n\tret = video_mux_async_register(vmux, num_pads - 1);\n\tif (ret)\n\t\tgoto err_subdev_cleanup;\n\n\treturn 0;\n\nerr_subdev_cleanup:\n\tv4l2_subdev_cleanup(&vmux->subdev);\nerr_entity_cleanup:\n\tmedia_entity_cleanup(&vmux->subdev.entity);\n\treturn ret;\n}\n\nstatic void video_mux_remove(struct platform_device *pdev)\n{\n\tstruct video_mux *vmux = platform_get_drvdata(pdev);\n\tstruct v4l2_subdev *sd = &vmux->subdev;\n\n\tv4l2_async_nf_unregister(&vmux->notifier);\n\tv4l2_async_nf_cleanup(&vmux->notifier);\n\tv4l2_async_unregister_subdev(sd);\n\tv4l2_subdev_cleanup(sd);\n\tmedia_entity_cleanup(&sd->entity);\n}\n\nstatic const struct of_device_id video_mux_dt_ids[] = {\n\t{ .compatible = \"video-mux\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, video_mux_dt_ids);\n\nstatic struct platform_driver video_mux_driver = {\n\t.probe\t\t= video_mux_probe,\n\t.remove_new\t= video_mux_remove,\n\t.driver\t\t= {\n\t\t.of_match_table = video_mux_dt_ids,\n\t\t.name = \"video-mux\",\n\t},\n};\n\nmodule_platform_driver(video_mux_driver);\n\nMODULE_DESCRIPTION(\"video stream multiplexer\");\nMODULE_AUTHOR(\"Sascha Hauer, Pengutronix\");\nMODULE_AUTHOR(\"Philipp Zabel, Pengutronix\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}