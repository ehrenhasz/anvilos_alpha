{
  "module_name": "stm32-dcmi.c",
  "hash_id": "c4ba364829aaf301e3047a21a7288ac3bce497b0706b123e5a2e7b3f9f378de1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/st/stm32/stm32-dcmi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_graph.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-rect.h>\n#include <media/videobuf2-dma-contig.h>\n\n#define DRV_NAME \"stm32-dcmi\"\n\n \n#define DCMI_CR\t\t0x00  \n#define DCMI_SR\t\t0x04  \n#define DCMI_RIS\t0x08  \n#define DCMI_IER\t0x0C  \n#define DCMI_MIS\t0x10  \n#define DCMI_ICR\t0x14  \n#define DCMI_ESCR\t0x18  \n#define DCMI_ESUR\t0x1C  \n#define DCMI_CWSTRT\t0x20  \n#define DCMI_CWSIZE\t0x24  \n#define DCMI_DR\t\t0x28  \n#define DCMI_IDR\t0x2C  \n\n \n#define CR_CAPTURE\tBIT(0)\n#define CR_CM\t\tBIT(1)\n#define CR_CROP\t\tBIT(2)\n#define CR_JPEG\t\tBIT(3)\n#define CR_ESS\t\tBIT(4)\n#define CR_PCKPOL\tBIT(5)\n#define CR_HSPOL\tBIT(6)\n#define CR_VSPOL\tBIT(7)\n#define CR_FCRC_0\tBIT(8)\n#define CR_FCRC_1\tBIT(9)\n#define CR_EDM_0\tBIT(10)\n#define CR_EDM_1\tBIT(11)\n#define CR_ENABLE\tBIT(14)\n\n \n#define SR_HSYNC\tBIT(0)\n#define SR_VSYNC\tBIT(1)\n#define SR_FNE\t\tBIT(2)\n\n \n#define IT_FRAME\tBIT(0)\n#define IT_OVR\t\tBIT(1)\n#define IT_ERR\t\tBIT(2)\n#define IT_VSYNC\tBIT(3)\n#define IT_LINE\t\tBIT(4)\n\nenum state {\n\tSTOPPED = 0,\n\tWAIT_FOR_BUFFER,\n\tRUNNING,\n};\n\n#define MIN_WIDTH\t16U\n#define MAX_WIDTH\t2592U\n#define MIN_HEIGHT\t16U\n#define MAX_HEIGHT\t2592U\n\n#define TIMEOUT_MS\t1000\n\n#define OVERRUN_ERROR_THRESHOLD\t3\n\nstruct dcmi_format {\n\tu32\tfourcc;\n\tu32\tmbus_code;\n\tu8\tbpp;\n};\n\nstruct dcmi_framesize {\n\tu32\twidth;\n\tu32\theight;\n};\n\nstruct dcmi_buf {\n\tstruct vb2_v4l2_buffer\tvb;\n\tbool\t\t\tprepared;\n\tstruct sg_table\t\tsgt;\n\tsize_t\t\t\tsize;\n\tstruct list_head\tlist;\n};\n\nstruct stm32_dcmi {\n\t \n\tspinlock_t\t\t\tirqlock;\n\tstruct device\t\t\t*dev;\n\tvoid __iomem\t\t\t*regs;\n\tstruct resource\t\t\t*res;\n\tstruct reset_control\t\t*rstc;\n\tint\t\t\t\tsequence;\n\tstruct list_head\t\tbuffers;\n\tstruct dcmi_buf\t\t\t*active;\n\tint\t\t\tirq;\n\n\tstruct v4l2_device\t\tv4l2_dev;\n\tstruct video_device\t\t*vdev;\n\tstruct v4l2_async_notifier\tnotifier;\n\tstruct v4l2_subdev\t\t*source;\n\tstruct v4l2_subdev\t\t*s_subdev;\n\tstruct v4l2_format\t\tfmt;\n\tstruct v4l2_rect\t\tcrop;\n\tbool\t\t\t\tdo_crop;\n\n\tconst struct dcmi_format\t**sd_formats;\n\tunsigned int\t\t\tnum_of_sd_formats;\n\tconst struct dcmi_format\t*sd_format;\n\tstruct dcmi_framesize\t\t*sd_framesizes;\n\tunsigned int\t\t\tnum_of_sd_framesizes;\n\tstruct dcmi_framesize\t\tsd_framesize;\n\tstruct v4l2_rect\t\tsd_bounds;\n\n\t \n\tstruct mutex\t\t\tlock;\n\tstruct vb2_queue\t\tqueue;\n\n\tstruct v4l2_mbus_config_parallel\tbus;\n\tenum v4l2_mbus_type\t\tbus_type;\n\tstruct completion\t\tcomplete;\n\tstruct clk\t\t\t*mclk;\n\tenum state\t\t\tstate;\n\tstruct dma_chan\t\t\t*dma_chan;\n\tdma_cookie_t\t\t\tdma_cookie;\n\tu32\t\t\t\tdma_max_burst;\n\tu32\t\t\t\tmisr;\n\tint\t\t\t\terrors_count;\n\tint\t\t\t\toverrun_count;\n\tint\t\t\t\tbuffers_count;\n\n\t \n\tstruct mutex\t\t\tdma_lock;\n\n\tstruct media_device\t\tmdev;\n\tstruct media_pad\t\tvid_cap_pad;\n\tstruct media_pipeline\t\tpipeline;\n};\n\nstatic inline struct stm32_dcmi *notifier_to_dcmi(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct stm32_dcmi, notifier);\n}\n\nstatic inline u32 reg_read(void __iomem *base, u32 reg)\n{\n\treturn readl_relaxed(base + reg);\n}\n\nstatic inline void reg_write(void __iomem *base, u32 reg, u32 val)\n{\n\twritel_relaxed(val, base + reg);\n}\n\nstatic inline void reg_set(void __iomem *base, u32 reg, u32 mask)\n{\n\treg_write(base, reg, reg_read(base, reg) | mask);\n}\n\nstatic inline void reg_clear(void __iomem *base, u32 reg, u32 mask)\n{\n\treg_write(base, reg, reg_read(base, reg) & ~mask);\n}\n\nstatic int dcmi_start_capture(struct stm32_dcmi *dcmi, struct dcmi_buf *buf);\n\nstatic void dcmi_buffer_done(struct stm32_dcmi *dcmi,\n\t\t\t     struct dcmi_buf *buf,\n\t\t\t     size_t bytesused,\n\t\t\t     int err)\n{\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tif (!buf)\n\t\treturn;\n\n\tlist_del_init(&buf->list);\n\n\tvbuf = &buf->vb;\n\n\tvbuf->sequence = dcmi->sequence++;\n\tvbuf->field = V4L2_FIELD_NONE;\n\tvbuf->vb2_buf.timestamp = ktime_get_ns();\n\tvb2_set_plane_payload(&vbuf->vb2_buf, 0, bytesused);\n\tvb2_buffer_done(&vbuf->vb2_buf,\n\t\t\terr ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\tdev_dbg(dcmi->dev, \"buffer[%d] done seq=%d, bytesused=%zu\\n\",\n\t\tvbuf->vb2_buf.index, vbuf->sequence, bytesused);\n\n\tdcmi->buffers_count++;\n\tdcmi->active = NULL;\n}\n\nstatic int dcmi_restart_capture(struct stm32_dcmi *dcmi)\n{\n\tstruct dcmi_buf *buf;\n\n\tspin_lock_irq(&dcmi->irqlock);\n\n\tif (dcmi->state != RUNNING) {\n\t\tspin_unlock_irq(&dcmi->irqlock);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (list_empty(&dcmi->buffers)) {\n\t\tdev_dbg(dcmi->dev, \"Capture restart is deferred to next buffer queueing\\n\");\n\t\tdcmi->state = WAIT_FOR_BUFFER;\n\t\tspin_unlock_irq(&dcmi->irqlock);\n\t\treturn 0;\n\t}\n\tbuf = list_entry(dcmi->buffers.next, struct dcmi_buf, list);\n\tdcmi->active = buf;\n\n\tspin_unlock_irq(&dcmi->irqlock);\n\n\treturn dcmi_start_capture(dcmi, buf);\n}\n\nstatic void dcmi_dma_callback(void *param)\n{\n\tstruct stm32_dcmi *dcmi = (struct stm32_dcmi *)param;\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\tstruct dcmi_buf *buf = dcmi->active;\n\n\tspin_lock_irq(&dcmi->irqlock);\n\n\t \n\tstatus = dmaengine_tx_status(dcmi->dma_chan, dcmi->dma_cookie, &state);\n\n\tswitch (status) {\n\tcase DMA_IN_PROGRESS:\n\t\tdev_dbg(dcmi->dev, \"%s: Received DMA_IN_PROGRESS\\n\", __func__);\n\t\tbreak;\n\tcase DMA_PAUSED:\n\t\tdev_err(dcmi->dev, \"%s: Received DMA_PAUSED\\n\", __func__);\n\t\tbreak;\n\tcase DMA_ERROR:\n\t\tdev_err(dcmi->dev, \"%s: Received DMA_ERROR\\n\", __func__);\n\n\t\t \n\t\tdcmi_buffer_done(dcmi, buf, 0, -EIO);\n\t\tbreak;\n\tcase DMA_COMPLETE:\n\t\tdev_dbg(dcmi->dev, \"%s: Received DMA_COMPLETE\\n\", __func__);\n\n\t\t \n\t\tdcmi_buffer_done(dcmi, buf, buf->size, 0);\n\n\t\tspin_unlock_irq(&dcmi->irqlock);\n\n\t\t \n\t\tif (dcmi_restart_capture(dcmi))\n\t\t\tdev_err(dcmi->dev, \"%s: Cannot restart capture on DMA complete\\n\",\n\t\t\t\t__func__);\n\t\treturn;\n\tdefault:\n\t\tdev_err(dcmi->dev, \"%s: Received unknown status\\n\", __func__);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irq(&dcmi->irqlock);\n}\n\nstatic int dcmi_start_dma(struct stm32_dcmi *dcmi,\n\t\t\t  struct dcmi_buf *buf)\n{\n\tstruct dma_async_tx_descriptor *desc = NULL;\n\tstruct dma_slave_config config;\n\tint ret;\n\n\tmemset(&config, 0, sizeof(config));\n\n\tconfig.src_addr = (dma_addr_t)dcmi->res->start + DCMI_DR;\n\tconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tconfig.dst_maxburst = 4;\n\n\t \n\tret = dmaengine_slave_config(dcmi->dma_chan, &config);\n\tif (ret < 0) {\n\t\tdev_err(dcmi->dev, \"%s: DMA channel config failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmutex_lock(&dcmi->dma_lock);\n\n\t \n\tdesc = dmaengine_prep_slave_sg(dcmi->dma_chan, buf->sgt.sgl, buf->sgt.nents,\n\t\t\t\t       DMA_DEV_TO_MEM,\n\t\t\t\t       DMA_PREP_INTERRUPT);\n\tif (!desc) {\n\t\tdev_err(dcmi->dev, \"%s: DMA dmaengine_prep_slave_sg failed\\n\", __func__);\n\t\tmutex_unlock(&dcmi->dma_lock);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdesc->callback = dcmi_dma_callback;\n\tdesc->callback_param = dcmi;\n\n\t \n\tdcmi->dma_cookie = dmaengine_submit(desc);\n\tif (dma_submit_error(dcmi->dma_cookie)) {\n\t\tdev_err(dcmi->dev, \"%s: DMA submission failed\\n\", __func__);\n\t\tmutex_unlock(&dcmi->dma_lock);\n\t\treturn -ENXIO;\n\t}\n\n\tmutex_unlock(&dcmi->dma_lock);\n\n\tdma_async_issue_pending(dcmi->dma_chan);\n\n\treturn 0;\n}\n\nstatic int dcmi_start_capture(struct stm32_dcmi *dcmi, struct dcmi_buf *buf)\n{\n\tint ret;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tret = dcmi_start_dma(dcmi, buf);\n\tif (ret) {\n\t\tdcmi->errors_count++;\n\t\treturn ret;\n\t}\n\n\t \n\treg_set(dcmi->regs, DCMI_CR, CR_CAPTURE);\n\n\treturn 0;\n}\n\nstatic void dcmi_set_crop(struct stm32_dcmi *dcmi)\n{\n\tu32 size, start;\n\n\t \n\tsize = ((dcmi->crop.height - 1) << 16) |\n\t\t((dcmi->crop.width << 1) - 1);\n\treg_write(dcmi->regs, DCMI_CWSIZE, size);\n\n\t \n\tstart = ((dcmi->crop.top) << 16) |\n\t\t ((dcmi->crop.left << 1));\n\treg_write(dcmi->regs, DCMI_CWSTRT, start);\n\n\tdev_dbg(dcmi->dev, \"Cropping to %ux%u@%u:%u\\n\",\n\t\tdcmi->crop.width, dcmi->crop.height,\n\t\tdcmi->crop.left, dcmi->crop.top);\n\n\t \n\treg_set(dcmi->regs, DCMI_CR, CR_CROP);\n}\n\nstatic void dcmi_process_jpeg(struct stm32_dcmi *dcmi)\n{\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\tstruct dcmi_buf *buf = dcmi->active;\n\n\tif (!buf)\n\t\treturn;\n\n\t \n\n\t \n\tdmaengine_synchronize(dcmi->dma_chan);\n\n\t \n\tstatus = dmaengine_tx_status(dcmi->dma_chan, dcmi->dma_cookie, &state);\n\tif (status != DMA_ERROR && state.residue < buf->size) {\n\t\t \n\t\tdcmi_buffer_done(dcmi, buf, buf->size - state.residue, 0);\n\t} else {\n\t\tdcmi->errors_count++;\n\t\tdev_err(dcmi->dev, \"%s: Cannot get JPEG size from DMA\\n\",\n\t\t\t__func__);\n\t\t \n\t\tdcmi_buffer_done(dcmi, buf, 0, -EIO);\n\t}\n\n\t \n\tdmaengine_terminate_sync(dcmi->dma_chan);\n\n\t \n\tif (dcmi_restart_capture(dcmi))\n\t\tdev_err(dcmi->dev, \"%s: Cannot restart capture on JPEG received\\n\",\n\t\t\t__func__);\n}\n\nstatic irqreturn_t dcmi_irq_thread(int irq, void *arg)\n{\n\tstruct stm32_dcmi *dcmi = arg;\n\n\tspin_lock_irq(&dcmi->irqlock);\n\n\tif (dcmi->misr & IT_OVR) {\n\t\tdcmi->overrun_count++;\n\t\tif (dcmi->overrun_count > OVERRUN_ERROR_THRESHOLD)\n\t\t\tdcmi->errors_count++;\n\t}\n\tif (dcmi->misr & IT_ERR)\n\t\tdcmi->errors_count++;\n\n\tif (dcmi->sd_format->fourcc == V4L2_PIX_FMT_JPEG &&\n\t    dcmi->misr & IT_FRAME) {\n\t\t \n\t\tspin_unlock_irq(&dcmi->irqlock);\n\t\tdcmi_process_jpeg(dcmi);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_unlock_irq(&dcmi->irqlock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t dcmi_irq_callback(int irq, void *arg)\n{\n\tstruct stm32_dcmi *dcmi = arg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dcmi->irqlock, flags);\n\n\tdcmi->misr = reg_read(dcmi->regs, DCMI_MIS);\n\n\t \n\treg_set(dcmi->regs, DCMI_ICR, IT_FRAME | IT_OVR | IT_ERR);\n\n\tspin_unlock_irqrestore(&dcmi->irqlock, flags);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic int dcmi_queue_setup(struct vb2_queue *vq,\n\t\t\t    unsigned int *nbuffers,\n\t\t\t    unsigned int *nplanes,\n\t\t\t    unsigned int sizes[],\n\t\t\t    struct device *alloc_devs[])\n{\n\tstruct stm32_dcmi *dcmi = vb2_get_drv_priv(vq);\n\tunsigned int size;\n\n\tsize = dcmi->fmt.fmt.pix.sizeimage;\n\n\t \n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\tdev_dbg(dcmi->dev, \"Setup queue, count=%d, size=%d\\n\",\n\t\t*nbuffers, size);\n\n\treturn 0;\n}\n\nstatic int dcmi_buf_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct dcmi_buf *buf = container_of(vbuf, struct dcmi_buf, vb);\n\n\tINIT_LIST_HEAD(&buf->list);\n\n\treturn 0;\n}\n\nstatic int dcmi_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct stm32_dcmi *dcmi =  vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct dcmi_buf *buf = container_of(vbuf, struct dcmi_buf, vb);\n\tunsigned long size;\n\tunsigned int num_sgs = 1;\n\tdma_addr_t dma_buf;\n\tstruct scatterlist *sg;\n\tint i, ret;\n\n\tsize = dcmi->fmt.fmt.pix.sizeimage;\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdev_err(dcmi->dev, \"%s data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t__func__, vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, size);\n\n\tif (!buf->prepared) {\n\t\t \n\t\tbuf->size = vb2_plane_size(&buf->vb.vb2_buf, 0);\n\t\tif (buf->size > dcmi->dma_max_burst)\n\t\t\tnum_sgs = DIV_ROUND_UP(buf->size, dcmi->dma_max_burst);\n\n\t\tret = sg_alloc_table(&buf->sgt, num_sgs, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tdev_err(dcmi->dev, \"sg table alloc failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdma_buf = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);\n\n\t\tdev_dbg(dcmi->dev, \"buffer[%d] phy=%pad size=%zu\\n\",\n\t\t\tvb->index, &dma_buf, buf->size);\n\n\t\tfor_each_sg(buf->sgt.sgl, sg, num_sgs, i) {\n\t\t\tsize_t bytes = min_t(size_t, size, dcmi->dma_max_burst);\n\n\t\t\tsg_dma_address(sg) = dma_buf;\n\t\t\tsg_dma_len(sg) = bytes;\n\t\t\tdma_buf += bytes;\n\t\t\tsize -= bytes;\n\t\t}\n\n\t\tbuf->prepared = true;\n\n\t\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);\n\t}\n\n\treturn 0;\n}\n\nstatic void dcmi_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct stm32_dcmi *dcmi =  vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct dcmi_buf *buf = container_of(vbuf, struct dcmi_buf, vb);\n\n\tspin_lock_irq(&dcmi->irqlock);\n\n\t \n\tlist_add_tail(&buf->list, &dcmi->buffers);\n\n\tif (dcmi->state == WAIT_FOR_BUFFER) {\n\t\tdcmi->state = RUNNING;\n\t\tdcmi->active = buf;\n\n\t\tdev_dbg(dcmi->dev, \"Starting capture on buffer[%d] queued\\n\",\n\t\t\tbuf->vb.vb2_buf.index);\n\n\t\tspin_unlock_irq(&dcmi->irqlock);\n\t\tif (dcmi_start_capture(dcmi, buf))\n\t\t\tdev_err(dcmi->dev, \"%s: Cannot restart capture on overflow or error\\n\",\n\t\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tspin_unlock_irq(&dcmi->irqlock);\n}\n\nstatic struct media_entity *dcmi_find_source(struct stm32_dcmi *dcmi)\n{\n\tstruct media_entity *entity = &dcmi->vdev->entity;\n\tstruct media_pad *pad;\n\n\t \n\twhile (1) {\n\t\tpad = &entity->pads[0];\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tbreak;\n\n\t\tpad = media_pad_remote_pad_first(pad);\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tbreak;\n\n\t\tentity = pad->entity;\n\t}\n\n\treturn entity;\n}\n\nstatic int dcmi_pipeline_s_fmt(struct stm32_dcmi *dcmi,\n\t\t\t       struct v4l2_subdev_format *format)\n{\n\tstruct media_entity *entity = &dcmi->source->entity;\n\tstruct v4l2_subdev *subdev;\n\tstruct media_pad *sink_pad = NULL;\n\tstruct media_pad *src_pad = NULL;\n\tstruct media_pad *pad = NULL;\n\tstruct v4l2_subdev_format fmt = *format;\n\tbool found = false;\n\tint ret;\n\n\t \n\twhile (1) {\n\t\tunsigned int i;\n\n\t\t \n\t\tfor (i = 0; i < entity->num_pads; i++) {\n\t\t\tpad = &entity->pads[i];\n\t\t\tif (pad->flags & MEDIA_PAD_FL_SOURCE) {\n\t\t\t\tsrc_pad = pad;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\n\t\tsubdev = media_entity_to_v4l2_subdev(entity);\n\n\t\t \n\t\tif (sink_pad)\n\t\t\tpad = sink_pad;\n\n\t\tdev_dbg(dcmi->dev, \"\\\"%s\\\":%d pad format set to 0x%x %ux%u\\n\",\n\t\t\tsubdev->name, pad->index, format->format.code,\n\t\t\tformat->format.width, format->format.height);\n\n\t\tfmt.pad = pad->index;\n\t\tret = v4l2_subdev_call(subdev, pad, set_fmt, NULL, &fmt);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dcmi->dev, \"%s: Failed to set format 0x%x %ux%u on \\\"%s\\\":%d pad (%d)\\n\",\n\t\t\t\t__func__, format->format.code,\n\t\t\t\tformat->format.width, format->format.height,\n\t\t\t\tsubdev->name, pad->index, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (fmt.format.code != format->format.code ||\n\t\t    fmt.format.width != format->format.width ||\n\t\t    fmt.format.height != format->format.height) {\n\t\t\tdev_dbg(dcmi->dev, \"\\\"%s\\\":%d pad format has been changed to 0x%x %ux%u\\n\",\n\t\t\t\tsubdev->name, pad->index, fmt.format.code,\n\t\t\t\tfmt.format.width, fmt.format.height);\n\t\t}\n\n\t\t \n\t\tsink_pad = media_pad_remote_pad_first(src_pad);\n\t\tif (!sink_pad || !is_media_entity_v4l2_subdev(sink_pad->entity))\n\t\t\tbreak;\n\n\t\tentity = sink_pad->entity;\n\t}\n\t*format = fmt;\n\n\treturn 0;\n}\n\nstatic int dcmi_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct stm32_dcmi *dcmi = vb2_get_drv_priv(vq);\n\tstruct dcmi_buf *buf, *node;\n\tu32 val = 0;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dcmi->dev);\n\tif (ret < 0) {\n\t\tdev_err(dcmi->dev, \"%s: Failed to start streaming, cannot get sync (%d)\\n\",\n\t\t\t__func__, ret);\n\t\tgoto err_unlocked;\n\t}\n\n\tret = video_device_pipeline_start(dcmi->vdev, &dcmi->pipeline);\n\tif (ret < 0) {\n\t\tdev_err(dcmi->dev, \"%s: Failed to start streaming, media pipeline start error (%d)\\n\",\n\t\t\t__func__, ret);\n\t\tgoto err_pm_put;\n\t}\n\n\tret = v4l2_subdev_call(dcmi->s_subdev, video, s_stream, 1);\n\tif (ret < 0) {\n\t\tdev_err(dcmi->dev, \"%s: Failed to start source subdev, error (%d)\\n\",\n\t\t\t__func__, ret);\n\t\tgoto err_media_pipeline_stop;\n\t}\n\n\tspin_lock_irq(&dcmi->irqlock);\n\n\t \n\tswitch (dcmi->bus.bus_width) {\n\tcase 14:\n\t\tval |= CR_EDM_0 | CR_EDM_1;\n\t\tbreak;\n\tcase 12:\n\t\tval |= CR_EDM_1;\n\t\tbreak;\n\tcase 10:\n\t\tval |= CR_EDM_0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tif (dcmi->bus.flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\n\t\tval |= CR_VSPOL;\n\n\t \n\tif (dcmi->bus.flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\n\t\tval |= CR_HSPOL;\n\n\t \n\tif (dcmi->bus.flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\n\t\tval |= CR_PCKPOL;\n\n\t \n\tif (dcmi->bus_type == V4L2_MBUS_BT656) {\n\t\tval |= CR_ESS;\n\n\t\t \n\t\treg_write(dcmi->regs, DCMI_ESUR, 0xffffffff); \n\n\t\t \n\t\treg_write(dcmi->regs, DCMI_ESCR, 0xff9d80ff); \n\t}\n\n\treg_write(dcmi->regs, DCMI_CR, val);\n\n\t \n\tif (dcmi->do_crop)\n\t\tdcmi_set_crop(dcmi);\n\n\t \n\tif (dcmi->sd_format->fourcc == V4L2_PIX_FMT_JPEG)\n\t\treg_set(dcmi->regs, DCMI_CR, CR_CM); \n\n\t \n\treg_set(dcmi->regs, DCMI_CR, CR_ENABLE);\n\n\tdcmi->sequence = 0;\n\tdcmi->errors_count = 0;\n\tdcmi->overrun_count = 0;\n\tdcmi->buffers_count = 0;\n\n\t \n\tif (list_empty(&dcmi->buffers)) {\n\t\tdev_dbg(dcmi->dev, \"Start streaming is deferred to next buffer queueing\\n\");\n\t\tdcmi->state = WAIT_FOR_BUFFER;\n\t\tspin_unlock_irq(&dcmi->irqlock);\n\t\treturn 0;\n\t}\n\n\tbuf = list_entry(dcmi->buffers.next, struct dcmi_buf, list);\n\tdcmi->active = buf;\n\n\tdcmi->state = RUNNING;\n\n\tdev_dbg(dcmi->dev, \"Start streaming, starting capture\\n\");\n\n\tspin_unlock_irq(&dcmi->irqlock);\n\tret = dcmi_start_capture(dcmi, buf);\n\tif (ret) {\n\t\tdev_err(dcmi->dev, \"%s: Start streaming failed, cannot start capture\\n\",\n\t\t\t__func__);\n\t\tgoto err_pipeline_stop;\n\t}\n\n\t \n\tif (dcmi->sd_format->fourcc == V4L2_PIX_FMT_JPEG)\n\t\treg_set(dcmi->regs, DCMI_IER, IT_FRAME | IT_OVR | IT_ERR);\n\telse\n\t\treg_set(dcmi->regs, DCMI_IER, IT_OVR | IT_ERR);\n\n\treturn 0;\n\nerr_pipeline_stop:\n\tv4l2_subdev_call(dcmi->s_subdev, video, s_stream, 0);\n\nerr_media_pipeline_stop:\n\tvideo_device_pipeline_stop(dcmi->vdev);\n\nerr_pm_put:\n\tpm_runtime_put(dcmi->dev);\nerr_unlocked:\n\tspin_lock_irq(&dcmi->irqlock);\n\t \n\tlist_for_each_entry_safe(buf, node, &dcmi->buffers, list) {\n\t\tlist_del_init(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t}\n\tdcmi->active = NULL;\n\tspin_unlock_irq(&dcmi->irqlock);\n\n\treturn ret;\n}\n\nstatic void dcmi_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct stm32_dcmi *dcmi = vb2_get_drv_priv(vq);\n\tstruct dcmi_buf *buf, *node;\n\tint ret;\n\n\tret = v4l2_subdev_call(dcmi->s_subdev, video, s_stream, 0);\n\tif (ret < 0)\n\t\tdev_err(dcmi->dev, \"%s: Failed to stop source subdev, error (%d)\\n\",\n\t\t\t__func__, ret);\n\n\tvideo_device_pipeline_stop(dcmi->vdev);\n\n\tspin_lock_irq(&dcmi->irqlock);\n\n\t \n\treg_clear(dcmi->regs, DCMI_IER, IT_FRAME | IT_OVR | IT_ERR);\n\n\t \n\treg_clear(dcmi->regs, DCMI_CR, CR_ENABLE);\n\n\t \n\tlist_for_each_entry_safe(buf, node, &dcmi->buffers, list) {\n\t\tlist_del_init(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\n\tdcmi->active = NULL;\n\tdcmi->state = STOPPED;\n\n\tspin_unlock_irq(&dcmi->irqlock);\n\n\t \n\tmutex_lock(&dcmi->dma_lock);\n\tdmaengine_terminate_sync(dcmi->dma_chan);\n\tmutex_unlock(&dcmi->dma_lock);\n\n\tpm_runtime_put(dcmi->dev);\n\n\tif (dcmi->errors_count)\n\t\tdev_warn(dcmi->dev, \"Some errors found while streaming: errors=%d (overrun=%d), buffers=%d\\n\",\n\t\t\t dcmi->errors_count, dcmi->overrun_count,\n\t\t\t dcmi->buffers_count);\n\tdev_dbg(dcmi->dev, \"Stop streaming, errors=%d (overrun=%d), buffers=%d\\n\",\n\t\tdcmi->errors_count, dcmi->overrun_count,\n\t\tdcmi->buffers_count);\n}\n\nstatic const struct vb2_ops dcmi_video_qops = {\n\t.queue_setup\t\t= dcmi_queue_setup,\n\t.buf_init\t\t= dcmi_buf_init,\n\t.buf_prepare\t\t= dcmi_buf_prepare,\n\t.buf_queue\t\t= dcmi_buf_queue,\n\t.start_streaming\t= dcmi_start_streaming,\n\t.stop_streaming\t\t= dcmi_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic int dcmi_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *fmt)\n{\n\tstruct stm32_dcmi *dcmi = video_drvdata(file);\n\n\t*fmt = dcmi->fmt;\n\n\treturn 0;\n}\n\nstatic const struct dcmi_format *find_format_by_fourcc(struct stm32_dcmi *dcmi,\n\t\t\t\t\t\t       unsigned int fourcc)\n{\n\tunsigned int num_formats = dcmi->num_of_sd_formats;\n\tconst struct dcmi_format *fmt;\n\tunsigned int i;\n\n\tfor (i = 0; i < num_formats; i++) {\n\t\tfmt = dcmi->sd_formats[i];\n\t\tif (fmt->fourcc == fourcc)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nstatic void __find_outer_frame_size(struct stm32_dcmi *dcmi,\n\t\t\t\t    struct v4l2_pix_format *pix,\n\t\t\t\t    struct dcmi_framesize *framesize)\n{\n\tstruct dcmi_framesize *match = NULL;\n\tunsigned int i;\n\tunsigned int min_err = UINT_MAX;\n\n\tfor (i = 0; i < dcmi->num_of_sd_framesizes; i++) {\n\t\tstruct dcmi_framesize *fsize = &dcmi->sd_framesizes[i];\n\t\tint w_err = (fsize->width - pix->width);\n\t\tint h_err = (fsize->height - pix->height);\n\t\tint err = w_err + h_err;\n\n\t\tif (w_err >= 0 && h_err >= 0 && err < min_err) {\n\t\t\tmin_err = err;\n\t\t\tmatch = fsize;\n\t\t}\n\t}\n\tif (!match)\n\t\tmatch = &dcmi->sd_framesizes[0];\n\n\t*framesize = *match;\n}\n\nstatic int dcmi_try_fmt(struct stm32_dcmi *dcmi, struct v4l2_format *f,\n\t\t\tconst struct dcmi_format **sd_format,\n\t\t\tstruct dcmi_framesize *sd_framesize)\n{\n\tconst struct dcmi_format *sd_fmt;\n\tstruct dcmi_framesize sd_fsize;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tbool do_crop;\n\tint ret;\n\n\tsd_fmt = find_format_by_fourcc(dcmi, pix->pixelformat);\n\tif (!sd_fmt) {\n\t\tif (!dcmi->num_of_sd_formats)\n\t\t\treturn -ENODATA;\n\n\t\tsd_fmt = dcmi->sd_formats[dcmi->num_of_sd_formats - 1];\n\t\tpix->pixelformat = sd_fmt->fourcc;\n\t}\n\n\t \n\tpix->width = clamp(pix->width, MIN_WIDTH, MAX_WIDTH);\n\tpix->height = clamp(pix->height, MIN_HEIGHT, MAX_HEIGHT);\n\n\t \n\tdo_crop = dcmi->do_crop && (pix->pixelformat != V4L2_PIX_FMT_JPEG);\n\n\tif (do_crop && dcmi->num_of_sd_framesizes) {\n\t\tstruct dcmi_framesize outer_sd_fsize;\n\t\t \n\t\t__find_outer_frame_size(dcmi, pix, &outer_sd_fsize);\n\t\tpix->width = outer_sd_fsize.width;\n\t\tpix->height = outer_sd_fsize.height;\n\t}\n\n\tv4l2_fill_mbus_format(&format.format, pix, sd_fmt->mbus_code);\n\tret = v4l2_subdev_call_state_try(dcmi->source, pad, set_fmt, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tv4l2_fill_pix_format(pix, &format.format);\n\n\t \n\tsd_fsize.width = pix->width;\n\tsd_fsize.height = pix->height;\n\n\tif (do_crop) {\n\t\tstruct v4l2_rect c = dcmi->crop;\n\t\tstruct v4l2_rect max_rect;\n\n\t\t \n\t\tmax_rect.top = 0;\n\t\tmax_rect.left = 0;\n\t\tmax_rect.width = pix->width;\n\t\tmax_rect.height = pix->height;\n\t\tv4l2_rect_map_inside(&c, &max_rect);\n\t\tc.top  = clamp_t(s32, c.top, 0, pix->height - c.height);\n\t\tc.left = clamp_t(s32, c.left, 0, pix->width - c.width);\n\t\tdcmi->crop = c;\n\n\t\t \n\t\tpix->width = dcmi->crop.width;\n\t\tpix->height = dcmi->crop.height;\n\t}\n\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->bytesperline = pix->width * sd_fmt->bpp;\n\tpix->sizeimage = pix->bytesperline * pix->height;\n\n\tif (sd_format)\n\t\t*sd_format = sd_fmt;\n\tif (sd_framesize)\n\t\t*sd_framesize = sd_fsize;\n\n\treturn 0;\n}\n\nstatic int dcmi_set_fmt(struct stm32_dcmi *dcmi, struct v4l2_format *f)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tconst struct dcmi_format *sd_format;\n\tstruct dcmi_framesize sd_framesize;\n\tstruct v4l2_mbus_framefmt *mf = &format.format;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tint ret;\n\n\t \n\tret = dcmi_try_fmt(dcmi, f, &sd_format, &sd_framesize);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (pix->pixelformat == V4L2_PIX_FMT_JPEG &&\n\t    dcmi->bus_type != V4L2_MBUS_BT656)\n\t\tdcmi->do_crop = false;\n\n\t \n\tv4l2_fill_mbus_format(mf, pix,\n\t\t\t      sd_format->mbus_code);\n\tmf->width = sd_framesize.width;\n\tmf->height = sd_framesize.height;\n\n\tret = dcmi_pipeline_s_fmt(dcmi, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(dcmi->dev, \"Sensor format set to 0x%x %ux%u\\n\",\n\t\tmf->code, mf->width, mf->height);\n\tdev_dbg(dcmi->dev, \"Buffer format set to %4.4s %ux%u\\n\",\n\t\t(char *)&pix->pixelformat,\n\t\tpix->width, pix->height);\n\n\tdcmi->fmt = *f;\n\tdcmi->sd_format = sd_format;\n\tdcmi->sd_framesize = sd_framesize;\n\n\treturn 0;\n}\n\nstatic int dcmi_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct stm32_dcmi *dcmi = video_drvdata(file);\n\n\tif (vb2_is_streaming(&dcmi->queue))\n\t\treturn -EBUSY;\n\n\treturn dcmi_set_fmt(dcmi, f);\n}\n\nstatic int dcmi_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct stm32_dcmi *dcmi = video_drvdata(file);\n\n\treturn dcmi_try_fmt(dcmi, f, NULL, NULL);\n}\n\nstatic int dcmi_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t struct v4l2_fmtdesc *f)\n{\n\tstruct stm32_dcmi *dcmi = video_drvdata(file);\n\n\tif (f->index >= dcmi->num_of_sd_formats)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = dcmi->sd_formats[f->index]->fourcc;\n\treturn 0;\n}\n\nstatic int dcmi_get_sensor_format(struct stm32_dcmi *dcmi,\n\t\t\t\t  struct v4l2_pix_format *pix)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tret = v4l2_subdev_call(dcmi->source, pad, get_fmt, NULL, &fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tv4l2_fill_pix_format(pix, &fmt.format);\n\n\treturn 0;\n}\n\nstatic int dcmi_set_sensor_format(struct stm32_dcmi *dcmi,\n\t\t\t\t  struct v4l2_pix_format *pix)\n{\n\tconst struct dcmi_format *sd_fmt;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tint ret;\n\n\tsd_fmt = find_format_by_fourcc(dcmi, pix->pixelformat);\n\tif (!sd_fmt) {\n\t\tif (!dcmi->num_of_sd_formats)\n\t\t\treturn -ENODATA;\n\n\t\tsd_fmt = dcmi->sd_formats[dcmi->num_of_sd_formats - 1];\n\t\tpix->pixelformat = sd_fmt->fourcc;\n\t}\n\n\tv4l2_fill_mbus_format(&format.format, pix, sd_fmt->mbus_code);\n\tret = v4l2_subdev_call_state_try(dcmi->source, pad, set_fmt, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int dcmi_get_sensor_bounds(struct stm32_dcmi *dcmi,\n\t\t\t\t  struct v4l2_rect *r)\n{\n\tstruct v4l2_subdev_selection bounds = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.target = V4L2_SEL_TGT_CROP_BOUNDS,\n\t};\n\tunsigned int max_width, max_height, max_pixsize;\n\tstruct v4l2_pix_format pix;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tret = v4l2_subdev_call(dcmi->source, pad, get_selection,\n\t\t\t       NULL, &bounds);\n\tif (!ret)\n\t\t*r = bounds.r;\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\t \n\tmax_width = 0;\n\tmax_height = 0;\n\tmax_pixsize = 0;\n\tfor (i = 0; i < dcmi->num_of_sd_framesizes; i++) {\n\t\tstruct dcmi_framesize *fsize = &dcmi->sd_framesizes[i];\n\t\tunsigned int pixsize = fsize->width * fsize->height;\n\n\t\tif (pixsize > max_pixsize) {\n\t\t\tmax_pixsize = pixsize;\n\t\t\tmax_width = fsize->width;\n\t\t\tmax_height = fsize->height;\n\t\t}\n\t}\n\tif (max_pixsize > 0) {\n\t\tr->top = 0;\n\t\tr->left = 0;\n\t\tr->width = max_width;\n\t\tr->height = max_height;\n\t\treturn 0;\n\t}\n\n\t \n\tret = dcmi_get_sensor_format(dcmi, &pix);\n\tif (ret)\n\t\treturn ret;\n\n\tr->top = 0;\n\tr->left = 0;\n\tr->width = pix.width;\n\tr->height = pix.height;\n\n\treturn 0;\n}\n\nstatic int dcmi_g_selection(struct file *file, void *fh,\n\t\t\t    struct v4l2_selection *s)\n{\n\tstruct stm32_dcmi *dcmi = video_drvdata(file);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\ts->r = dcmi->sd_bounds;\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (dcmi->do_crop) {\n\t\t\ts->r = dcmi->crop;\n\t\t} else {\n\t\t\ts->r.top = 0;\n\t\t\ts->r.left = 0;\n\t\t\ts->r.width = dcmi->fmt.fmt.pix.width;\n\t\t\ts->r.height = dcmi->fmt.fmt.pix.height;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dcmi_s_selection(struct file *file, void *priv,\n\t\t\t    struct v4l2_selection *s)\n{\n\tstruct stm32_dcmi *dcmi = video_drvdata(file);\n\tstruct v4l2_rect r = s->r;\n\tstruct v4l2_rect max_rect;\n\tstruct v4l2_pix_format pix;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\n\t    s->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\t \n\tpix.pixelformat = dcmi->fmt.fmt.pix.pixelformat;\n\tpix.width = dcmi->sd_bounds.width;\n\tpix.height = dcmi->sd_bounds.height;\n\tdcmi_set_sensor_format(dcmi, &pix);\n\n\t \n\tmax_rect.top = 0;\n\tmax_rect.left = 0;\n\tmax_rect.width = pix.width;\n\tmax_rect.height = pix.height;\n\tv4l2_rect_map_inside(&r, &max_rect);\n\tr.top  = clamp_t(s32, r.top, 0, pix.height - r.height);\n\tr.left = clamp_t(s32, r.left, 0, pix.width - r.width);\n\n\tif (!(r.top == dcmi->sd_bounds.top &&\n\t      r.left == dcmi->sd_bounds.left &&\n\t      r.width == dcmi->sd_bounds.width &&\n\t      r.height == dcmi->sd_bounds.height)) {\n\t\t \n\t\tdcmi->do_crop = true;\n\t\tdcmi->crop = r;\n\t\tdev_dbg(dcmi->dev, \"s_selection: crop %ux%u@(%u,%u) from %ux%u\\n\",\n\t\t\tr.width, r.height, r.left, r.top,\n\t\t\tpix.width, pix.height);\n\t} else {\n\t\t \n\t\tdcmi->do_crop = false;\n\t\tdev_dbg(dcmi->dev, \"s_selection: crop is disabled\\n\");\n\t}\n\n\ts->r = r;\n\treturn 0;\n}\n\nstatic int dcmi_querycap(struct file *file, void *priv,\n\t\t\t struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, DRV_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, \"STM32 Camera Memory Interface\",\n\t\tsizeof(cap->card));\n\tstrscpy(cap->bus_info, \"platform:dcmi\", sizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic int dcmi_enum_input(struct file *file, void *priv,\n\t\t\t   struct v4l2_input *i)\n{\n\tif (i->index != 0)\n\t\treturn -EINVAL;\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\tstrscpy(i->name, \"Camera\", sizeof(i->name));\n\treturn 0;\n}\n\nstatic int dcmi_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int dcmi_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tif (i > 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int dcmi_enum_framesizes(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_frmsizeenum *fsize)\n{\n\tstruct stm32_dcmi *dcmi = video_drvdata(file);\n\tconst struct dcmi_format *sd_fmt;\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.index = fsize->index,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tsd_fmt = find_format_by_fourcc(dcmi, fsize->pixel_format);\n\tif (!sd_fmt)\n\t\treturn -EINVAL;\n\n\tfse.code = sd_fmt->mbus_code;\n\n\tret = v4l2_subdev_call(dcmi->source, pad, enum_frame_size,\n\t\t\t       NULL, &fse);\n\tif (ret)\n\t\treturn ret;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = fse.max_width;\n\tfsize->discrete.height = fse.max_height;\n\n\treturn 0;\n}\n\nstatic int dcmi_g_parm(struct file *file, void *priv,\n\t\t       struct v4l2_streamparm *p)\n{\n\tstruct stm32_dcmi *dcmi = video_drvdata(file);\n\n\treturn v4l2_g_parm_cap(video_devdata(file), dcmi->source, p);\n}\n\nstatic int dcmi_s_parm(struct file *file, void *priv,\n\t\t       struct v4l2_streamparm *p)\n{\n\tstruct stm32_dcmi *dcmi = video_drvdata(file);\n\n\treturn v4l2_s_parm_cap(video_devdata(file), dcmi->source, p);\n}\n\nstatic int dcmi_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_frmivalenum *fival)\n{\n\tstruct stm32_dcmi *dcmi = video_drvdata(file);\n\tconst struct dcmi_format *sd_fmt;\n\tstruct v4l2_subdev_frame_interval_enum fie = {\n\t\t.index = fival->index,\n\t\t.width = fival->width,\n\t\t.height = fival->height,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tsd_fmt = find_format_by_fourcc(dcmi, fival->pixel_format);\n\tif (!sd_fmt)\n\t\treturn -EINVAL;\n\n\tfie.code = sd_fmt->mbus_code;\n\n\tret = v4l2_subdev_call(dcmi->source, pad,\n\t\t\t       enum_frame_interval, NULL, &fie);\n\tif (ret)\n\t\treturn ret;\n\n\tfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tfival->discrete = fie.interval;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id stm32_dcmi_of_match[] = {\n\t{ .compatible = \"st,stm32-dcmi\"},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, stm32_dcmi_of_match);\n\nstatic int dcmi_open(struct file *file)\n{\n\tstruct stm32_dcmi *dcmi = video_drvdata(file);\n\tstruct v4l2_subdev *sd = dcmi->source;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&dcmi->lock))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_fh_open(file);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tif (!v4l2_fh_is_singular_file(file))\n\t\tgoto fh_rel;\n\n\tret = v4l2_subdev_call(sd, core, s_power, 1);\n\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\tgoto fh_rel;\n\n\tret = dcmi_set_fmt(dcmi, &dcmi->fmt);\n\tif (ret)\n\t\tv4l2_subdev_call(sd, core, s_power, 0);\nfh_rel:\n\tif (ret)\n\t\tv4l2_fh_release(file);\nunlock:\n\tmutex_unlock(&dcmi->lock);\n\treturn ret;\n}\n\nstatic int dcmi_release(struct file *file)\n{\n\tstruct stm32_dcmi *dcmi = video_drvdata(file);\n\tstruct v4l2_subdev *sd = dcmi->source;\n\tbool fh_singular;\n\tint ret;\n\n\tmutex_lock(&dcmi->lock);\n\n\tfh_singular = v4l2_fh_is_singular_file(file);\n\n\tret = _vb2_fop_release(file, NULL);\n\n\tif (fh_singular)\n\t\tv4l2_subdev_call(sd, core, s_power, 0);\n\n\tmutex_unlock(&dcmi->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ioctl_ops dcmi_ioctl_ops = {\n\t.vidioc_querycap\t\t= dcmi_querycap,\n\n\t.vidioc_try_fmt_vid_cap\t\t= dcmi_try_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= dcmi_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= dcmi_s_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_cap\t= dcmi_enum_fmt_vid_cap,\n\t.vidioc_g_selection\t\t= dcmi_g_selection,\n\t.vidioc_s_selection\t\t= dcmi_s_selection,\n\n\t.vidioc_enum_input\t\t= dcmi_enum_input,\n\t.vidioc_g_input\t\t\t= dcmi_g_input,\n\t.vidioc_s_input\t\t\t= dcmi_s_input,\n\n\t.vidioc_g_parm\t\t\t= dcmi_g_parm,\n\t.vidioc_s_parm\t\t\t= dcmi_s_parm,\n\n\t.vidioc_enum_framesizes\t\t= dcmi_enum_framesizes,\n\t.vidioc_enum_frameintervals\t= dcmi_enum_frameintervals,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\n\t.vidioc_log_status\t\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nstatic const struct v4l2_file_operations dcmi_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.open\t\t= dcmi_open,\n\t.release\t= dcmi_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n#ifndef CONFIG_MMU\n\t.get_unmapped_area = vb2_fop_get_unmapped_area,\n#endif\n\t.read\t\t= vb2_fop_read,\n};\n\nstatic int dcmi_set_default_fmt(struct stm32_dcmi *dcmi)\n{\n\tstruct v4l2_format f = {\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t\t.fmt.pix = {\n\t\t\t.width\t\t= CIF_WIDTH,\n\t\t\t.height\t\t= CIF_HEIGHT,\n\t\t\t.field\t\t= V4L2_FIELD_NONE,\n\t\t\t.pixelformat\t= dcmi->sd_formats[0]->fourcc,\n\t\t},\n\t};\n\tint ret;\n\n\tret = dcmi_try_fmt(dcmi, &f, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\tdcmi->sd_format = dcmi->sd_formats[0];\n\tdcmi->fmt = f;\n\treturn 0;\n}\n\nstatic const struct dcmi_format dcmi_formats[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_RGB565,\n\t\t.mbus_code = MEDIA_BUS_FMT_RGB565_2X8_LE,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_RGB565,\n\t\t.mbus_code = MEDIA_BUS_FMT_RGB565_1X16,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.mbus_code = MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.mbus_code = MEDIA_BUS_FMT_YUYV8_1X16,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_UYVY,\n\t\t.mbus_code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_UYVY,\n\t\t.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_JPEG,\n\t\t.mbus_code = MEDIA_BUS_FMT_JPEG_1X8,\n\t\t.bpp = 1,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SBGGR8,\n\t\t.mbus_code = MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.bpp = 1,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGBRG8,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.bpp = 1,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGRBG8,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.bpp = 1,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SRGGB8,\n\t\t.mbus_code = MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.bpp = 1,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SBGGR10,\n\t\t.mbus_code = MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGBRG10,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGRBG10,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SRGGB10,\n\t\t.mbus_code = MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SBGGR12,\n\t\t.mbus_code = MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGBRG12,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGRBG12,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SRGGB12,\n\t\t.mbus_code = MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SBGGR14,\n\t\t.mbus_code = MEDIA_BUS_FMT_SBGGR14_1X14,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGBRG14,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGBRG14_1X14,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGRBG14,\n\t\t.mbus_code = MEDIA_BUS_FMT_SGRBG14_1X14,\n\t\t.bpp = 2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SRGGB14,\n\t\t.mbus_code = MEDIA_BUS_FMT_SRGGB14_1X14,\n\t\t.bpp = 2,\n\t},\n};\n\nstatic int dcmi_formats_init(struct stm32_dcmi *dcmi)\n{\n\tconst struct dcmi_format *sd_fmts[ARRAY_SIZE(dcmi_formats)];\n\tunsigned int num_fmts = 0, i, j;\n\tstruct v4l2_subdev *subdev = dcmi->source;\n\tstruct v4l2_subdev_mbus_code_enum mbus_code = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\twhile (!v4l2_subdev_call(subdev, pad, enum_mbus_code,\n\t\t\t\t NULL, &mbus_code)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(dcmi_formats); i++) {\n\t\t\tif (dcmi_formats[i].mbus_code != mbus_code.code)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (dcmi_formats[i].fourcc == V4L2_PIX_FMT_JPEG &&\n\t\t\t    dcmi->bus_type == V4L2_MBUS_BT656)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tfor (j = 0; j < num_fmts; j++)\n\t\t\t\tif (sd_fmts[j]->fourcc ==\n\t\t\t\t\t\tdcmi_formats[i].fourcc) {\n\t\t\t\t\t \n\t\t\t\t\tdev_dbg(dcmi->dev, \"Skipping fourcc/code: %4.4s/0x%x\\n\",\n\t\t\t\t\t\t(char *)&sd_fmts[j]->fourcc,\n\t\t\t\t\t\tmbus_code.code);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (j == num_fmts) {\n\t\t\t\t \n\t\t\t\tsd_fmts[num_fmts++] = dcmi_formats + i;\n\t\t\t\tdev_dbg(dcmi->dev, \"Supported fourcc/code: %4.4s/0x%x\\n\",\n\t\t\t\t\t(char *)&sd_fmts[num_fmts - 1]->fourcc,\n\t\t\t\t\tsd_fmts[num_fmts - 1]->mbus_code);\n\t\t\t}\n\t\t}\n\t\tmbus_code.index++;\n\t}\n\n\tif (!num_fmts)\n\t\treturn -ENXIO;\n\n\tdcmi->num_of_sd_formats = num_fmts;\n\tdcmi->sd_formats = devm_kcalloc(dcmi->dev,\n\t\t\t\t\tnum_fmts, sizeof(struct dcmi_format *),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!dcmi->sd_formats) {\n\t\tdev_err(dcmi->dev, \"Could not allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(dcmi->sd_formats, sd_fmts,\n\t       num_fmts * sizeof(struct dcmi_format *));\n\tdcmi->sd_format = dcmi->sd_formats[0];\n\n\treturn 0;\n}\n\nstatic int dcmi_framesizes_init(struct stm32_dcmi *dcmi)\n{\n\tunsigned int num_fsize = 0;\n\tstruct v4l2_subdev *subdev = dcmi->source;\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.code = dcmi->sd_format->mbus_code,\n\t};\n\tunsigned int ret;\n\tunsigned int i;\n\n\t \n\twhile (!v4l2_subdev_call(subdev, pad, enum_frame_size,\n\t\t\t\t NULL, &fse))\n\t\tfse.index++;\n\n\tnum_fsize = fse.index;\n\tif (!num_fsize)\n\t\treturn 0;\n\n\tdcmi->num_of_sd_framesizes = num_fsize;\n\tdcmi->sd_framesizes = devm_kcalloc(dcmi->dev, num_fsize,\n\t\t\t\t\t   sizeof(struct dcmi_framesize),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!dcmi->sd_framesizes) {\n\t\tdev_err(dcmi->dev, \"Could not allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdev_dbg(dcmi->dev, \"Sensor supports %u frame sizes:\\n\", num_fsize);\n\tfor (i = 0; i < dcmi->num_of_sd_framesizes; i++) {\n\t\tfse.index = i;\n\t\tret = v4l2_subdev_call(subdev, pad, enum_frame_size,\n\t\t\t\t       NULL, &fse);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdcmi->sd_framesizes[fse.index].width = fse.max_width;\n\t\tdcmi->sd_framesizes[fse.index].height = fse.max_height;\n\t\tdev_dbg(dcmi->dev, \"%ux%u\\n\", fse.max_width, fse.max_height);\n\t}\n\n\treturn 0;\n}\n\nstatic int dcmi_graph_notify_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct stm32_dcmi *dcmi = notifier_to_dcmi(notifier);\n\tint ret;\n\n\t \n\tdcmi->source = media_entity_to_v4l2_subdev(dcmi_find_source(dcmi));\n\tif (!dcmi->source) {\n\t\tdev_err(dcmi->dev, \"Source subdevice not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdcmi->vdev->ctrl_handler = dcmi->source->ctrl_handler;\n\n\tret = dcmi_formats_init(dcmi);\n\tif (ret) {\n\t\tdev_err(dcmi->dev, \"No supported mediabus format found\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dcmi_framesizes_init(dcmi);\n\tif (ret) {\n\t\tdev_err(dcmi->dev, \"Could not initialize framesizes\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dcmi_get_sensor_bounds(dcmi, &dcmi->sd_bounds);\n\tif (ret) {\n\t\tdev_err(dcmi->dev, \"Could not get sensor bounds\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dcmi_set_default_fmt(dcmi);\n\tif (ret) {\n\t\tdev_err(dcmi->dev, \"Could not set default format\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(dcmi->dev, dcmi->irq, dcmi_irq_callback,\n\t\t\t\t\tdcmi_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dcmi->dev), dcmi);\n\tif (ret) {\n\t\tdev_err(dcmi->dev, \"Unable to request irq %d\\n\", dcmi->irq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void dcmi_graph_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\t     struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_async_connection *asd)\n{\n\tstruct stm32_dcmi *dcmi = notifier_to_dcmi(notifier);\n\n\tdev_dbg(dcmi->dev, \"Removing %s\\n\", video_device_node_name(dcmi->vdev));\n\n\t \n\tvideo_unregister_device(dcmi->vdev);\n}\n\nstatic int dcmi_graph_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t   struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_async_connection *asd)\n{\n\tstruct stm32_dcmi *dcmi = notifier_to_dcmi(notifier);\n\tunsigned int ret;\n\tint src_pad;\n\n\tdev_dbg(dcmi->dev, \"Subdev \\\"%s\\\" bound\\n\", subdev->name);\n\n\t \n\tsrc_pad = media_entity_get_fwnode_pad(&subdev->entity,\n\t\t\t\t\t      subdev->fwnode,\n\t\t\t\t\t      MEDIA_PAD_FL_SOURCE);\n\n\tret = media_create_pad_link(&subdev->entity, src_pad,\n\t\t\t\t    &dcmi->vdev->entity, 0,\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\tif (ret)\n\t\tdev_err(dcmi->dev, \"Failed to create media pad link with subdev \\\"%s\\\"\\n\",\n\t\t\tsubdev->name);\n\telse\n\t\tdev_dbg(dcmi->dev, \"DCMI is now linked to \\\"%s\\\"\\n\",\n\t\t\tsubdev->name);\n\n\tdcmi->s_subdev = subdev;\n\n\treturn ret;\n}\n\nstatic const struct v4l2_async_notifier_operations dcmi_graph_notify_ops = {\n\t.bound = dcmi_graph_notify_bound,\n\t.unbind = dcmi_graph_notify_unbind,\n\t.complete = dcmi_graph_notify_complete,\n};\n\nstatic int dcmi_graph_init(struct stm32_dcmi *dcmi)\n{\n\tstruct v4l2_async_connection *asd;\n\tstruct device_node *ep;\n\tint ret;\n\n\tep = of_graph_get_next_endpoint(dcmi->dev->of_node, NULL);\n\tif (!ep) {\n\t\tdev_err(dcmi->dev, \"Failed to get next endpoint\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tv4l2_async_nf_init(&dcmi->notifier, &dcmi->v4l2_dev);\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&dcmi->notifier,\n\t\t\t\t\t      of_fwnode_handle(ep),\n\t\t\t\t\t      struct v4l2_async_connection);\n\n\tof_node_put(ep);\n\n\tif (IS_ERR(asd)) {\n\t\tdev_err(dcmi->dev, \"Failed to add subdev notifier\\n\");\n\t\treturn PTR_ERR(asd);\n\t}\n\n\tdcmi->notifier.ops = &dcmi_graph_notify_ops;\n\n\tret = v4l2_async_nf_register(&dcmi->notifier);\n\tif (ret < 0) {\n\t\tdev_err(dcmi->dev, \"Failed to register notifier\\n\");\n\t\tv4l2_async_nf_cleanup(&dcmi->notifier);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dcmi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *match = NULL;\n\tstruct v4l2_fwnode_endpoint ep = { .bus_type = 0 };\n\tstruct stm32_dcmi *dcmi;\n\tstruct vb2_queue *q;\n\tstruct dma_chan *chan;\n\tstruct dma_slave_caps caps;\n\tstruct clk *mclk;\n\tint ret = 0;\n\n\tmatch = of_match_device(of_match_ptr(stm32_dcmi_of_match), &pdev->dev);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"Could not find a match in devicetree\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdcmi = devm_kzalloc(&pdev->dev, sizeof(struct stm32_dcmi), GFP_KERNEL);\n\tif (!dcmi)\n\t\treturn -ENOMEM;\n\n\tdcmi->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(dcmi->rstc))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(dcmi->rstc),\n\t\t\t\t     \"Could not get reset control\\n\");\n\n\t \n\tnp = of_graph_get_next_endpoint(np, NULL);\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"Could not find the endpoint\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(np), &ep);\n\tof_node_put(np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not parse the endpoint\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ep.bus_type == V4L2_MBUS_CSI2_DPHY) {\n\t\tdev_err(&pdev->dev, \"CSI bus not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (ep.bus_type == V4L2_MBUS_BT656 &&\n\t    ep.bus.parallel.bus_width != 8) {\n\t\tdev_err(&pdev->dev, \"BT656 bus conflicts with %u bits bus width (8 bits required)\\n\",\n\t\t\tep.bus.parallel.bus_width);\n\t\treturn -ENODEV;\n\t}\n\n\tdcmi->bus.flags = ep.bus.parallel.flags;\n\tdcmi->bus.bus_width = ep.bus.parallel.bus_width;\n\tdcmi->bus.data_shift = ep.bus.parallel.data_shift;\n\tdcmi->bus_type = ep.bus_type;\n\n\tdcmi->irq = platform_get_irq(pdev, 0);\n\tif (dcmi->irq < 0)\n\t\treturn dcmi->irq;\n\n\tdcmi->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &dcmi->res);\n\tif (IS_ERR(dcmi->regs))\n\t\treturn PTR_ERR(dcmi->regs);\n\n\tmclk = devm_clk_get(&pdev->dev, \"mclk\");\n\tif (IS_ERR(mclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(mclk),\n\t\t\t\t     \"Unable to get mclk\\n\");\n\n\tchan = dma_request_chan(&pdev->dev, \"tx\");\n\tif (IS_ERR(chan))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(chan),\n\t\t\t\t     \"Failed to request DMA channel\\n\");\n\n\tdcmi->dma_max_burst = UINT_MAX;\n\tret = dma_get_slave_caps(chan, &caps);\n\tif (!ret && caps.max_sg_burst)\n\t\tdcmi->dma_max_burst = caps.max_sg_burst\t* DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\tspin_lock_init(&dcmi->irqlock);\n\tmutex_init(&dcmi->lock);\n\tmutex_init(&dcmi->dma_lock);\n\tinit_completion(&dcmi->complete);\n\tINIT_LIST_HEAD(&dcmi->buffers);\n\n\tdcmi->dev = &pdev->dev;\n\tdcmi->mclk = mclk;\n\tdcmi->state = STOPPED;\n\tdcmi->dma_chan = chan;\n\n\tq = &dcmi->queue;\n\n\tdcmi->v4l2_dev.mdev = &dcmi->mdev;\n\n\t \n\tstrscpy(dcmi->mdev.model, DRV_NAME, sizeof(dcmi->mdev.model));\n\tdcmi->mdev.dev = &pdev->dev;\n\tmedia_device_init(&dcmi->mdev);\n\n\t \n\tret = v4l2_device_register(&pdev->dev, &dcmi->v4l2_dev);\n\tif (ret)\n\t\tgoto err_media_device_cleanup;\n\n\tdcmi->vdev = video_device_alloc();\n\tif (!dcmi->vdev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_device_unregister;\n\t}\n\n\t \n\tdcmi->vdev->fops = &dcmi_fops;\n\tdcmi->vdev->v4l2_dev = &dcmi->v4l2_dev;\n\tdcmi->vdev->queue = &dcmi->queue;\n\tstrscpy(dcmi->vdev->name, KBUILD_MODNAME, sizeof(dcmi->vdev->name));\n\tdcmi->vdev->release = video_device_release;\n\tdcmi->vdev->ioctl_ops = &dcmi_ioctl_ops;\n\tdcmi->vdev->lock = &dcmi->lock;\n\tdcmi->vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\n\t\t\t\t  V4L2_CAP_READWRITE;\n\tvideo_set_drvdata(dcmi->vdev, dcmi);\n\n\t \n\tdcmi->vid_cap_pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&dcmi->vdev->entity,\n\t\t\t\t     1, &dcmi->vid_cap_pad);\n\tif (ret) {\n\t\tdev_err(dcmi->dev, \"Failed to init media entity pad\\n\");\n\t\tgoto err_device_release;\n\t}\n\tdcmi->vdev->entity.flags |= MEDIA_ENT_FL_DEFAULT;\n\n\tret = video_register_device(dcmi->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(dcmi->dev, \"Failed to register video device\\n\");\n\t\tgoto err_media_entity_cleanup;\n\t}\n\n\tdev_dbg(dcmi->dev, \"Device registered as %s\\n\",\n\t\tvideo_device_node_name(dcmi->vdev));\n\n\t \n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;\n\tq->lock = &dcmi->lock;\n\tq->drv_priv = dcmi;\n\tq->buf_struct_size = sizeof(struct dcmi_buf);\n\tq->ops = &dcmi_video_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = 2;\n\tq->allow_cache_hints = 1;\n\tq->dev = &pdev->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize vb2 queue\\n\");\n\t\tgoto err_media_entity_cleanup;\n\t}\n\n\tret = dcmi_graph_init(dcmi);\n\tif (ret < 0)\n\t\tgoto err_media_entity_cleanup;\n\n\t \n\tret = reset_control_assert(dcmi->rstc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to assert the reset line\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\tusleep_range(3000, 5000);\n\n\tret = reset_control_deassert(dcmi->rstc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to deassert the reset line\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\tdev_info(&pdev->dev, \"Probe done\\n\");\n\n\tplatform_set_drvdata(pdev, dcmi);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n\nerr_cleanup:\n\tv4l2_async_nf_cleanup(&dcmi->notifier);\nerr_media_entity_cleanup:\n\tmedia_entity_cleanup(&dcmi->vdev->entity);\nerr_device_release:\n\tvideo_device_release(dcmi->vdev);\nerr_device_unregister:\n\tv4l2_device_unregister(&dcmi->v4l2_dev);\nerr_media_device_cleanup:\n\tmedia_device_cleanup(&dcmi->mdev);\n\tdma_release_channel(dcmi->dma_chan);\n\n\treturn ret;\n}\n\nstatic void dcmi_remove(struct platform_device *pdev)\n{\n\tstruct stm32_dcmi *dcmi = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tv4l2_async_nf_unregister(&dcmi->notifier);\n\tv4l2_async_nf_cleanup(&dcmi->notifier);\n\tmedia_entity_cleanup(&dcmi->vdev->entity);\n\tv4l2_device_unregister(&dcmi->v4l2_dev);\n\tmedia_device_cleanup(&dcmi->mdev);\n\n\tdma_release_channel(dcmi->dma_chan);\n}\n\nstatic __maybe_unused int dcmi_runtime_suspend(struct device *dev)\n{\n\tstruct stm32_dcmi *dcmi = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(dcmi->mclk);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int dcmi_runtime_resume(struct device *dev)\n{\n\tstruct stm32_dcmi *dcmi = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(dcmi->mclk);\n\tif (ret)\n\t\tdev_err(dev, \"%s: Failed to prepare_enable clock\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic __maybe_unused int dcmi_suspend(struct device *dev)\n{\n\t \n\tpm_runtime_force_suspend(dev);\n\n\t \n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int dcmi_resume(struct device *dev)\n{\n\t \n\tpinctrl_pm_select_default_state(dev);\n\n\t \n\tpm_runtime_force_resume(dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dcmi_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dcmi_suspend, dcmi_resume)\n\tSET_RUNTIME_PM_OPS(dcmi_runtime_suspend,\n\t\t\t   dcmi_runtime_resume, NULL)\n};\n\nstatic struct platform_driver stm32_dcmi_driver = {\n\t.probe\t\t= dcmi_probe,\n\t.remove_new\t= dcmi_remove,\n\t.driver\t\t= {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(stm32_dcmi_of_match),\n\t\t.pm = &dcmi_pm_ops,\n\t},\n};\n\nmodule_platform_driver(stm32_dcmi_driver);\n\nMODULE_AUTHOR(\"Yannick Fertre <yannick.fertre@st.com>\");\nMODULE_AUTHOR(\"Hugues Fruchet <hugues.fruchet@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 Digital Camera Memory Interface driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}