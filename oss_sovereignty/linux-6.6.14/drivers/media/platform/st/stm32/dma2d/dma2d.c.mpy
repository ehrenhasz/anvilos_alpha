{
  "module_name": "dma2d.c",
  "hash_id": "f9e61775f33177fce4d5adade89c66fdefc437e02516f7b63b5da1decee7c3aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/st/stm32/dma2d/dma2d.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/timer.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n\n#include <linux/platform_device.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"dma2d.h\"\n#include \"dma2d-regs.h\"\n\n \n\n#define fh2ctx(__fh) container_of(__fh, struct dma2d_ctx, fh)\n\nstatic const struct dma2d_fmt formats[] = {\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_ARGB32,\n\t\t.cmode = DMA2D_CMODE_ARGB8888,\n\t\t.depth = 32,\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB24,\n\t\t.cmode = DMA2D_CMODE_RGB888,\n\t\t.depth = 24,\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB565,\n\t\t.cmode = DMA2D_CMODE_RGB565,\n\t\t.depth = 16,\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_ARGB555,\n\t\t.cmode = DMA2D_CMODE_ARGB1555,\n\t\t.depth = 16,\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_ARGB444,\n\t\t.cmode = DMA2D_CMODE_ARGB4444,\n\t\t.depth = 16,\n\t},\n};\n\n#define NUM_FORMATS ARRAY_SIZE(formats)\n\nstatic const struct dma2d_frame def_frame = {\n\t.width\t\t= DEFAULT_WIDTH,\n\t.height\t\t= DEFAULT_HEIGHT,\n\t.line_offset\t= 0,\n\t.a_rgb\t\t= {0x00, 0x00, 0x00, 0xff},\n\t.a_mode\t\t= DMA2D_ALPHA_MODE_NO_MODIF,\n\t.fmt\t\t= (struct dma2d_fmt *)&formats[0],\n\t.size\t\t= DEFAULT_SIZE,\n};\n\nstatic struct dma2d_fmt *find_fmt(int pixelformat)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < NUM_FORMATS; i++) {\n\t\tif (formats[i].fourcc == pixelformat)\n\t\t\treturn (struct dma2d_fmt *)&formats[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic struct dma2d_frame *get_frame(struct dma2d_ctx *ctx,\n\t\t\t\t     enum v4l2_buf_type type)\n{\n\treturn V4L2_TYPE_IS_OUTPUT(type) ? &ctx->cap : &ctx->out;\n}\n\nstatic int dma2d_queue_setup(struct vb2_queue *vq,\n\t\t\t     unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t     unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct dma2d_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct dma2d_frame *f = get_frame(ctx, vq->type);\n\n\tif (*nplanes)\n\t\treturn sizes[0] < f->size ? -EINVAL : 0;\n\n\tsizes[0] = f->size;\n\t*nplanes = 1;\n\n\treturn 0;\n}\n\nstatic int dma2d_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tif (vbuf->field == V4L2_FIELD_ANY)\n\t\tvbuf->field = V4L2_FIELD_NONE;\n\tif (vbuf->field != V4L2_FIELD_NONE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int dma2d_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct dma2d_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct dma2d_frame *f = get_frame(ctx, vb->vb2_queue->type);\n\n\tif (vb2_plane_size(vb, 0) < f->size)\n\t\treturn -EINVAL;\n\n\tvb2_set_plane_payload(vb, 0, f->size);\n\n\treturn 0;\n}\n\nstatic void dma2d_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct dma2d_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int dma2d_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct dma2d_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct dma2d_frame *f = get_frame(ctx, q->type);\n\n\tf->sequence = 0;\n\treturn 0;\n}\n\nstatic void dma2d_stop_streaming(struct vb2_queue *q)\n{\n\tstruct dma2d_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tfor (;;) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (!vbuf)\n\t\t\treturn;\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic const struct vb2_ops dma2d_qops = {\n\t.queue_setup\t= dma2d_queue_setup,\n\t.buf_out_validate\t = dma2d_buf_out_validate,\n\t.buf_prepare\t= dma2d_buf_prepare,\n\t.buf_queue\t= dma2d_buf_queue,\n\t.start_streaming = dma2d_start_streaming,\n\t.stop_streaming  = dma2d_stop_streaming,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n};\n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct dma2d_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->ops = &dma2d_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->dev->mutex;\n\tsrc_vq->dev = ctx->dev->v4l2_dev.dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->ops = &dma2d_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->dev->mutex;\n\tdst_vq->dev = ctx->dev->v4l2_dev.dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int dma2d_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct dma2d_frame *frm;\n\tstruct dma2d_ctx *ctx = container_of(ctrl->handler, struct dma2d_ctx,\n\t\t\t\t\t\t\t\tctrl_handler);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->dev->ctrl_lock, flags);\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_COLORFX:\n\t\tif (ctrl->val == V4L2_COLORFX_SET_RGB)\n\t\t\tctx->op_mode = DMA2D_MODE_R2M;\n\t\telse if (ctrl->val == V4L2_COLORFX_NONE)\n\t\t\tctx->op_mode = DMA2D_MODE_M2M;\n\t\tbreak;\n\tcase V4L2_CID_COLORFX_RGB:\n\t\tfrm = get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\tfrm->a_rgb[2] = (ctrl->val >> 16) & 0xff;\n\t\tfrm->a_rgb[1] = (ctrl->val >> 8) & 0xff;\n\t\tfrm->a_rgb[0] = (ctrl->val >> 0) & 0xff;\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock_irqrestore(&ctx->dev->ctrl_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&ctx->dev->ctrl_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops dma2d_ctrl_ops = {\n\t.s_ctrl\t= dma2d_s_ctrl,\n};\n\nstatic int dma2d_setup_ctrls(struct dma2d_ctx *ctx)\n{\n\tstruct v4l2_ctrl_handler *handler = &ctx->ctrl_handler;\n\n\tv4l2_ctrl_handler_init(handler, 2);\n\n\tv4l2_ctrl_new_std_menu(handler, &dma2d_ctrl_ops, V4L2_CID_COLORFX,\n\t\t\t       V4L2_COLORFX_SET_RGB, ~0x10001,\n\t\t\t       V4L2_COLORFX_NONE);\n\n\tv4l2_ctrl_new_std(handler, &dma2d_ctrl_ops, V4L2_CID_COLORFX_RGB, 0,\n\t\t\t  0xffffff, 1, 0);\n\n\treturn 0;\n}\n\nstatic int dma2d_open(struct file *file)\n{\n\tstruct dma2d_dev *dev = video_drvdata(file);\n\tstruct dma2d_ctx *ctx = NULL;\n\tint ret = 0;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->dev = dev;\n\t \n\tctx->cap\t\t= def_frame;\n\tctx->bg\t\t= def_frame;\n\tctx->out\t= def_frame;\n\tctx->op_mode\t= DMA2D_MODE_M2M_FPC;\n\tctx->colorspace = V4L2_COLORSPACE_REC709;\n\tif (mutex_lock_interruptible(&dev->mutex)) {\n\t\tkfree(ctx);\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx, &queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tmutex_unlock(&dev->mutex);\n\t\tkfree(ctx);\n\t\treturn ret;\n\t}\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\tdma2d_setup_ctrls(ctx);\n\n\t \n\tv4l2_ctrl_handler_setup(&ctx->ctrl_handler);\n\n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\tmutex_unlock(&dev->mutex);\n\n\treturn 0;\n}\n\nstatic int dma2d_release(struct file *file)\n{\n\tstruct dma2d_dev *dev = video_drvdata(file);\n\tstruct dma2d_ctx *ctx = fh2ctx(file->private_data);\n\n\tmutex_lock(&dev->mutex);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tmutex_unlock(&dev->mutex);\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, DMA2D_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, DMA2D_NAME, sizeof(cap->card));\n\tstrscpy(cap->bus_info, BUS_INFO, sizeof(cap->bus_info));\n\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt(struct file *file, void *prv, struct v4l2_fmtdesc *f)\n{\n\tif (f->index >= NUM_FORMATS)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[f->index].fourcc;\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt(struct file *file, void *prv, struct v4l2_format *f)\n{\n\tstruct dma2d_ctx *ctx = prv;\n\tstruct vb2_queue *vq;\n\tstruct dma2d_frame *frm;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tfrm = get_frame(ctx, f->type);\n\tf->fmt.pix.width\t\t= frm->width;\n\tf->fmt.pix.height\t\t= frm->height;\n\tf->fmt.pix.field\t\t= V4L2_FIELD_NONE;\n\tf->fmt.pix.pixelformat\t\t= frm->fmt->fourcc;\n\tf->fmt.pix.bytesperline\t\t= (frm->width * frm->fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage\t\t= frm->size;\n\tf->fmt.pix.colorspace\t\t= ctx->colorspace;\n\tf->fmt.pix.xfer_func\t\t= ctx->xfer_func;\n\tf->fmt.pix.ycbcr_enc\t\t= ctx->ycbcr_enc;\n\tf->fmt.pix.quantization\t\t= ctx->quant;\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt(struct file *file, void *prv, struct v4l2_format *f)\n{\n\tstruct dma2d_ctx *ctx = prv;\n\tstruct dma2d_fmt *fmt;\n\tenum v4l2_field *field;\n\tu32 fourcc = f->fmt.pix.pixelformat;\n\n\tfmt = find_fmt(fourcc);\n\tif (!fmt) {\n\t\tf->fmt.pix.pixelformat = formats[0].fourcc;\n\t\tfmt = find_fmt(f->fmt.pix.pixelformat);\n\t}\n\n\tfield = &f->fmt.pix.field;\n\tif (*field == V4L2_FIELD_ANY)\n\t\t*field = V4L2_FIELD_NONE;\n\telse if (*field != V4L2_FIELD_NONE)\n\t\treturn -EINVAL;\n\n\tif (f->fmt.pix.width > MAX_WIDTH)\n\t\tf->fmt.pix.width = MAX_WIDTH;\n\tif (f->fmt.pix.height > MAX_HEIGHT)\n\t\tf->fmt.pix.height = MAX_HEIGHT;\n\n\tif (f->fmt.pix.width < 1)\n\t\tf->fmt.pix.width = 1;\n\tif (f->fmt.pix.height < 1)\n\t\tf->fmt.pix.height = 1;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT && !f->fmt.pix.colorspace) {\n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tf->fmt.pix.colorspace\t= ctx->colorspace;\n\t\tf->fmt.pix.xfer_func = ctx->xfer_func;\n\t\tf->fmt.pix.ycbcr_enc = ctx->ycbcr_enc;\n\t\tf->fmt.pix.quantization = ctx->quant;\n\t}\n\tf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt(struct file *file, void *prv, struct v4l2_format *f)\n{\n\tstruct dma2d_ctx *ctx = prv;\n\tstruct vb2_queue *vq;\n\tstruct dma2d_frame *frm;\n\tstruct dma2d_fmt *fmt;\n\tint ret = 0;\n\n\t \n\tret = vidioc_try_fmt(file, prv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\tfmt = find_fmt(f->fmt.pix.pixelformat);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tctx->colorspace = f->fmt.pix.colorspace;\n\t\tctx->xfer_func = f->fmt.pix.xfer_func;\n\t\tctx->ycbcr_enc = f->fmt.pix.ycbcr_enc;\n\t\tctx->quant = f->fmt.pix.quantization;\n\t}\n\n\tfrm = get_frame(ctx, f->type);\n\tfrm->width = f->fmt.pix.width;\n\tfrm->height = f->fmt.pix.height;\n\tfrm->size = f->fmt.pix.sizeimage;\n\t \n\tfrm->o_width = 0;\n\tfrm->o_height = 0;\n\tfrm->c_width = frm->width;\n\tfrm->c_height = frm->height;\n\tfrm->right = frm->width;\n\tfrm->bottom = frm->height;\n\tfrm->fmt = fmt;\n\tfrm->line_offset = 0;\n\n\treturn 0;\n}\n\nstatic void device_run(void *prv)\n{\n\tstruct dma2d_ctx *ctx = prv;\n\tstruct dma2d_dev *dev = ctx->dev;\n\tstruct dma2d_frame *frm_out, *frm_cap;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->ctrl_lock, flags);\n\tdev->curr = ctx;\n\n\tsrc = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tif (!dst || !src)\n\t\tgoto end;\n\n\tfrm_cap = get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tfrm_out = get_frame(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tif (!frm_cap || !frm_out)\n\t\tgoto end;\n\n\tsrc->sequence = frm_out->sequence++;\n\tdst->sequence = frm_cap->sequence++;\n\tv4l2_m2m_buf_copy_metadata(src, dst, true);\n\n\tclk_enable(dev->gate);\n\n\tdma2d_config_fg(dev, frm_out,\n\t\t\tvb2_dma_contig_plane_dma_addr(&src->vb2_buf, 0));\n\n\t \n\n\tif (ctx->op_mode != DMA2D_MODE_R2M) {\n\t\tif (frm_out->fmt->fourcc == frm_cap->fmt->fourcc)\n\t\t\tctx->op_mode = DMA2D_MODE_M2M;\n\t\telse\n\t\t\tctx->op_mode = DMA2D_MODE_M2M_FPC;\n\t}\n\n\tdma2d_config_out(dev, frm_cap,\n\t\t\t vb2_dma_contig_plane_dma_addr(&dst->vb2_buf, 0));\n\tdma2d_config_common(dev, ctx->op_mode, frm_cap->width, frm_cap->height);\n\n\tdma2d_start(dev);\nend:\n\tspin_unlock_irqrestore(&dev->ctrl_lock, flags);\n}\n\nstatic irqreturn_t dma2d_isr(int irq, void *prv)\n{\n\tstruct dma2d_dev *dev = prv;\n\tstruct dma2d_ctx *ctx = dev->curr;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\tu32 s = dma2d_get_int(dev);\n\n\tdma2d_clear_int(dev);\n\tif (s & ISR_TCIF || s == 0) {\n\t\tclk_disable(dev->gate);\n\n\t\tWARN_ON(!ctx);\n\n\t\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tWARN_ON(!dst);\n\t\tWARN_ON(!src);\n\n\t\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\n\n\t\tdev->curr = NULL;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct v4l2_file_operations dma2d_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= dma2d_open,\n\t.release\t= dma2d_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n#ifndef CONFIG_MMU\n\t.get_unmapped_area = v4l2_m2m_get_unmapped_area,\n#endif\n};\n\nstatic const struct v4l2_ioctl_ops dma2d_ioctl_ops = {\n\t.vidioc_querycap\t= vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= vidioc_enum_fmt,\n\t.vidioc_g_fmt_vid_cap\t\t= vidioc_g_fmt,\n\t.vidioc_try_fmt_vid_cap\t\t= vidioc_try_fmt,\n\t.vidioc_s_fmt_vid_cap\t\t= vidioc_s_fmt,\n\n\t.vidioc_enum_fmt_vid_out\t= vidioc_enum_fmt,\n\t.vidioc_g_fmt_vid_out\t\t= vidioc_g_fmt,\n\t.vidioc_try_fmt_vid_out\t\t= vidioc_try_fmt,\n\t.vidioc_s_fmt_vid_out\t\t= vidioc_s_fmt,\n\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic const struct video_device dma2d_videodev = {\n\t.name\t\t= DMA2D_NAME,\n\t.fops\t\t= &dma2d_fops,\n\t.ioctl_ops\t= &dma2d_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= video_device_release,\n\t.vfl_dir\t= VFL_DIR_M2M,\n};\n\nstatic const struct v4l2_m2m_ops dma2d_m2m_ops = {\n\t.device_run\t= device_run,\n};\n\nstatic const struct of_device_id stm32_dma2d_match[];\n\nstatic int dma2d_probe(struct platform_device *pdev)\n{\n\tstruct dma2d_dev *dev;\n\tstruct video_device *vfd;\n\tint ret = 0;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dev->ctrl_lock);\n\tmutex_init(&dev->mutex);\n\tatomic_set(&dev->num_inst, 0);\n\n\tdev->regs = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(dev->regs))\n\t\treturn PTR_ERR(dev->regs);\n\n\tdev->gate = clk_get(&pdev->dev, \"dma2d\");\n\tif (IS_ERR(dev->gate)) {\n\t\tdev_err(&pdev->dev, \"failed to get dma2d clock gate\\n\");\n\t\tret = -ENXIO;\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare(dev->gate);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to prepare dma2d clock gate\\n\");\n\t\tgoto put_clk_gate;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto unprep_clk_gate;\n\n\tdev->irq = ret;\n\n\tret = devm_request_irq(&pdev->dev, dev->irq, dma2d_isr,\n\t\t\t       0, pdev->name, dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to install IRQ\\n\");\n\t\tgoto unprep_clk_gate;\n\t}\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret)\n\t\tgoto unprep_clk_gate;\n\n\tvfd = video_device_alloc();\n\tif (!vfd) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to allocate video device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto unreg_v4l2_dev;\n\t}\n\n\t*vfd = dma2d_videodev;\n\tvfd->lock = &dev->mutex;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\tvfd->device_caps = V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING;\n\n\tplatform_set_drvdata(pdev, dev);\n\tdev->m2m_dev = v4l2_m2m_init(&dma2d_m2m_ops);\n\tif (IS_ERR(dev->m2m_dev)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(dev->m2m_dev);\n\t\tgoto rel_vdev;\n\t}\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto free_m2m;\n\t}\n\n\tvideo_set_drvdata(vfd, dev);\n\tdev->vfd = vfd;\n\tv4l2_info(&dev->v4l2_dev, \"device registered as /dev/video%d\\n\",\n\t\t  vfd->num);\n\treturn 0;\n\nfree_m2m:\n\tv4l2_m2m_release(dev->m2m_dev);\nrel_vdev:\n\tvideo_device_release(vfd);\nunreg_v4l2_dev:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nunprep_clk_gate:\n\tclk_unprepare(dev->gate);\nput_clk_gate:\n\tclk_put(dev->gate);\n\n\treturn ret;\n}\n\nstatic void dma2d_remove(struct platform_device *pdev)\n{\n\tstruct dma2d_dev *dev = platform_get_drvdata(pdev);\n\n\tv4l2_info(&dev->v4l2_dev, \"Removing \" DMA2D_NAME);\n\tv4l2_m2m_release(dev->m2m_dev);\n\tvideo_unregister_device(dev->vfd);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tvb2_dma_contig_clear_max_seg_size(&pdev->dev);\n\tclk_unprepare(dev->gate);\n\tclk_put(dev->gate);\n}\n\nstatic const struct of_device_id stm32_dma2d_match[] = {\n\t{\n\t\t.compatible = \"st,stm32-dma2d\",\n\t\t.data = NULL,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_dma2d_match);\n\nstatic struct platform_driver dma2d_pdrv = {\n\t.probe\t\t= dma2d_probe,\n\t.remove_new\t= dma2d_remove,\n\t.driver\t\t= {\n\t\t.name = DMA2D_NAME,\n\t\t.of_match_table = stm32_dma2d_match,\n\t},\n};\n\nmodule_platform_driver(dma2d_pdrv);\n\nMODULE_AUTHOR(\"Dillon Min <dillon.minfei@gmail.com>\");\nMODULE_DESCRIPTION(\"STM32 Chrom-Art Accelerator DMA2D driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}