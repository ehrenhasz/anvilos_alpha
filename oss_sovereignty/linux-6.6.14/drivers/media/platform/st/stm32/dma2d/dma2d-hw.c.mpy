{
  "module_name": "dma2d-hw.c",
  "hash_id": "914e3d0ba9266ad88bc8d3a7c2c64bc4d6463b3d0ab23571b0e73559ebb5f308",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/st/stm32/dma2d/dma2d-hw.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n\n#include \"dma2d.h\"\n#include \"dma2d-regs.h\"\n\nstatic inline u32 reg_read(void __iomem *base, u32 reg)\n{\n\treturn readl_relaxed(base + reg);\n}\n\nstatic inline void reg_write(void __iomem *base, u32 reg, u32 val)\n{\n\twritel_relaxed(val, base + reg);\n}\n\nstatic inline void reg_update_bits(void __iomem *base, u32 reg, u32 mask,\n\t\t\t\t   u32 val)\n{\n\treg_write(base, reg, (reg_read(base, reg) & ~mask) | val);\n}\n\nvoid dma2d_start(struct dma2d_dev *d)\n{\n\treg_update_bits(d->regs, DMA2D_CR_REG, CR_START, CR_START);\n}\n\nu32 dma2d_get_int(struct dma2d_dev *d)\n{\n\treturn reg_read(d->regs, DMA2D_ISR_REG);\n}\n\nvoid dma2d_clear_int(struct dma2d_dev *d)\n{\n\tu32 isr_val = reg_read(d->regs, DMA2D_ISR_REG);\n\n\treg_write(d->regs, DMA2D_IFCR_REG, isr_val & 0x003f);\n}\n\nvoid dma2d_config_common(struct dma2d_dev *d, enum dma2d_op_mode op_mode,\n\t\t\t u16 width, u16 height)\n{\n\treg_update_bits(d->regs, DMA2D_CR_REG, CR_MODE_MASK,\n\t\t\top_mode << CR_MODE_SHIFT);\n\n\treg_write(d->regs, DMA2D_NLR_REG, (width << 16) | height);\n}\n\nvoid dma2d_config_out(struct dma2d_dev *d, struct dma2d_frame *frm,\n\t\t      dma_addr_t o_addr)\n{\n\treg_update_bits(d->regs, DMA2D_CR_REG, CR_CEIE, CR_CEIE);\n\treg_update_bits(d->regs, DMA2D_CR_REG, CR_CTCIE, CR_CTCIE);\n\treg_update_bits(d->regs, DMA2D_CR_REG, CR_CAEIE, CR_CAEIE);\n\treg_update_bits(d->regs, DMA2D_CR_REG, CR_TCIE, CR_TCIE);\n\treg_update_bits(d->regs, DMA2D_CR_REG, CR_TEIE, CR_TEIE);\n\n\tif (frm->fmt->cmode >= CM_MODE_ARGB8888 &&\n\t    frm->fmt->cmode <= CM_MODE_ARGB4444)\n\t\treg_update_bits(d->regs, DMA2D_OPFCCR_REG, OPFCCR_CM_MASK,\n\t\t\t\tfrm->fmt->cmode);\n\n\treg_write(d->regs, DMA2D_OMAR_REG, o_addr);\n\n\treg_write(d->regs, DMA2D_OCOLR_REG,\n\t\t  (frm->a_rgb[3] << 24) |\n\t\t  (frm->a_rgb[2] << 16) |\n\t\t  (frm->a_rgb[1] << 8) |\n\t\t  frm->a_rgb[0]);\n\n\treg_update_bits(d->regs, DMA2D_OOR_REG, OOR_LO_MASK,\n\t\t\tfrm->line_offset & 0x3fff);\n}\n\nvoid dma2d_config_fg(struct dma2d_dev *d, struct dma2d_frame *frm,\n\t\t     dma_addr_t f_addr)\n{\n\treg_write(d->regs, DMA2D_FGMAR_REG, f_addr);\n\treg_update_bits(d->regs, DMA2D_FGOR_REG, FGOR_LO_MASK,\n\t\t\tfrm->line_offset);\n\n\tif (frm->fmt->cmode >= CM_MODE_ARGB8888 &&\n\t    frm->fmt->cmode <= CM_MODE_A4)\n\t\treg_update_bits(d->regs, DMA2D_FGPFCCR_REG, FGPFCCR_CM_MASK,\n\t\t\t\tfrm->fmt->cmode);\n\n\treg_update_bits(d->regs, DMA2D_FGPFCCR_REG, FGPFCCR_AM_MASK,\n\t\t\t(frm->a_mode << 16) & 0x03);\n\n\treg_update_bits(d->regs, DMA2D_FGPFCCR_REG, FGPFCCR_ALPHA_MASK,\n\t\t\tfrm->a_rgb[3] << 24);\n\n\treg_write(d->regs, DMA2D_FGCOLR_REG,\n\t\t  (frm->a_rgb[2] << 16) |\n\t\t  (frm->a_rgb[1] << 8) |\n\t\t  frm->a_rgb[0]);\n}\n\nvoid dma2d_config_bg(struct dma2d_dev *d, struct dma2d_frame *frm,\n\t\t     dma_addr_t b_addr)\n{\n\treg_write(d->regs, DMA2D_BGMAR_REG, b_addr);\n\treg_update_bits(d->regs, DMA2D_BGOR_REG, BGOR_LO_MASK,\n\t\t\tfrm->line_offset);\n\n\tif (frm->fmt->cmode >= CM_MODE_ARGB8888 &&\n\t    frm->fmt->cmode <= CM_MODE_A4)\n\t\treg_update_bits(d->regs, DMA2D_BGPFCCR_REG, BGPFCCR_CM_MASK,\n\t\t\t\tfrm->fmt->cmode);\n\n\treg_update_bits(d->regs, DMA2D_BGPFCCR_REG, BGPFCCR_AM_MASK,\n\t\t\t(frm->a_mode << 16) & 0x03);\n\n\treg_update_bits(d->regs, DMA2D_BGPFCCR_REG, BGPFCCR_ALPHA_MASK,\n\t\t\tfrm->a_rgb[3] << 24);\n\n\treg_write(d->regs, DMA2D_BGCOLR_REG,\n\t\t  (frm->a_rgb[2] << 16) |\n\t\t  (frm->a_rgb[1] << 8) |\n\t\t  frm->a_rgb[0]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}