{
  "module_name": "delta-mjpeg-dec.c",
  "hash_id": "9abd2d245b199c460d2fc4c95de582fb993a3b6f7b4460426efff3abcb545e6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/st/sti/delta/delta-mjpeg-dec.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"delta.h\"\n#include \"delta-ipc.h\"\n#include \"delta-mjpeg.h\"\n#include \"delta-mjpeg-fw.h\"\n\n#define DELTA_MJPEG_MAX_RESO DELTA_MAX_RESO\n\nstruct delta_mjpeg_ctx {\n\t \n\tstruct mjpeg_header header_struct;\n\tstruct mjpeg_header *header;\n\n\t \n\tvoid *ipc_hdl;\n\tstruct delta_buf *ipc_buf;\n\n\t \n\tstruct delta_frame *out_frame;\n\n\tunsigned char str[3000];\n};\n\n#define to_ctx(ctx) ((struct delta_mjpeg_ctx *)(ctx)->priv)\n\nstatic char *ipc_open_param_str(struct jpeg_video_decode_init_params_t *p,\n\t\t\t\tchar *str, unsigned int len)\n{\n\tchar *b = str;\n\n\tif (!p)\n\t\treturn \"\";\n\n\tb += snprintf(b, len,\n\t\t      \"jpeg_video_decode_init_params_t\\n\"\n\t\t      \"circular_buffer_begin_addr_p 0x%x\\n\"\n\t\t      \"circular_buffer_end_addr_p   0x%x\\n\",\n\t\t      p->circular_buffer_begin_addr_p,\n\t\t      p->circular_buffer_end_addr_p);\n\n\treturn str;\n}\n\nstatic char *ipc_decode_param_str(struct jpeg_decode_params_t *p,\n\t\t\t\t  char *str, unsigned int len)\n{\n\tchar *b = str;\n\n\tif (!p)\n\t\treturn \"\";\n\n\tb += snprintf(b, len,\n\t\t      \"jpeg_decode_params_t\\n\"\n\t\t      \"picture_start_addr_p                  0x%x\\n\"\n\t\t      \"picture_end_addr_p                    0x%x\\n\"\n\t\t      \"decoding_mode                        %d\\n\"\n\t\t      \"display_buffer_addr.display_decimated_luma_p   0x%x\\n\"\n\t\t      \"display_buffer_addr.display_decimated_chroma_p 0x%x\\n\"\n\t\t      \"main_aux_enable                       %d\\n\"\n\t\t      \"additional_flags                     0x%x\\n\"\n\t\t      \"field_flag                           %x\\n\"\n\t\t      \"is_jpeg_image                        %x\\n\",\n\t\t      p->picture_start_addr_p,\n\t\t      p->picture_end_addr_p,\n\t\t      p->decoding_mode,\n\t\t      p->display_buffer_addr.display_decimated_luma_p,\n\t\t      p->display_buffer_addr.display_decimated_chroma_p,\n\t\t      p->main_aux_enable, p->additional_flags,\n\t\t      p->field_flag,\n\t\t      p->is_jpeg_image);\n\n\treturn str;\n}\n\nstatic inline bool is_stream_error(enum jpeg_decoding_error_t err)\n{\n\tswitch (err) {\n\tcase JPEG_DECODER_UNDEFINED_HUFF_TABLE:\n\tcase JPEG_DECODER_BAD_RESTART_MARKER:\n\tcase JPEG_DECODER_BAD_SOS_SPECTRAL:\n\tcase JPEG_DECODER_BAD_SOS_SUCCESSIVE:\n\tcase JPEG_DECODER_BAD_HEADER_LENGTH:\n\tcase JPEG_DECODER_BAD_COUNT_VALUE:\n\tcase JPEG_DECODER_BAD_DHT_MARKER:\n\tcase JPEG_DECODER_BAD_INDEX_VALUE:\n\tcase JPEG_DECODER_BAD_NUMBER_HUFFMAN_TABLES:\n\tcase JPEG_DECODER_BAD_QUANT_TABLE_LENGTH:\n\tcase JPEG_DECODER_BAD_NUMBER_QUANT_TABLES:\n\tcase JPEG_DECODER_BAD_COMPONENT_COUNT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline const char *err_str(enum jpeg_decoding_error_t err)\n{\n\tswitch (err) {\n\tcase JPEG_DECODER_NO_ERROR:\n\t\treturn \"JPEG_DECODER_NO_ERROR\";\n\tcase JPEG_DECODER_UNDEFINED_HUFF_TABLE:\n\t\treturn \"JPEG_DECODER_UNDEFINED_HUFF_TABLE\";\n\tcase JPEG_DECODER_UNSUPPORTED_MARKER:\n\t\treturn \"JPEG_DECODER_UNSUPPORTED_MARKER\";\n\tcase JPEG_DECODER_UNABLE_ALLOCATE_MEMORY:\n\t\treturn \"JPEG_DECODER_UNABLE_ALLOCATE_MEMORY\";\n\tcase JPEG_DECODER_NON_SUPPORTED_SAMP_FACTORS:\n\t\treturn \"JPEG_DECODER_NON_SUPPORTED_SAMP_FACTORS\";\n\tcase JPEG_DECODER_BAD_PARAMETER:\n\t\treturn \"JPEG_DECODER_BAD_PARAMETER\";\n\tcase JPEG_DECODER_DECODE_ERROR:\n\t\treturn \"JPEG_DECODER_DECODE_ERROR\";\n\tcase JPEG_DECODER_BAD_RESTART_MARKER:\n\t\treturn \"JPEG_DECODER_BAD_RESTART_MARKER\";\n\tcase JPEG_DECODER_UNSUPPORTED_COLORSPACE:\n\t\treturn \"JPEG_DECODER_UNSUPPORTED_COLORSPACE\";\n\tcase JPEG_DECODER_BAD_SOS_SPECTRAL:\n\t\treturn \"JPEG_DECODER_BAD_SOS_SPECTRAL\";\n\tcase JPEG_DECODER_BAD_SOS_SUCCESSIVE:\n\t\treturn \"JPEG_DECODER_BAD_SOS_SUCCESSIVE\";\n\tcase JPEG_DECODER_BAD_HEADER_LENGTH:\n\t\treturn \"JPEG_DECODER_BAD_HEADER_LENGTH\";\n\tcase JPEG_DECODER_BAD_COUNT_VALUE:\n\t\treturn \"JPEG_DECODER_BAD_COUNT_VALUE\";\n\tcase JPEG_DECODER_BAD_DHT_MARKER:\n\t\treturn \"JPEG_DECODER_BAD_DHT_MARKER\";\n\tcase JPEG_DECODER_BAD_INDEX_VALUE:\n\t\treturn \"JPEG_DECODER_BAD_INDEX_VALUE\";\n\tcase JPEG_DECODER_BAD_NUMBER_HUFFMAN_TABLES:\n\t\treturn \"JPEG_DECODER_BAD_NUMBER_HUFFMAN_TABLES\";\n\tcase JPEG_DECODER_BAD_QUANT_TABLE_LENGTH:\n\t\treturn \"JPEG_DECODER_BAD_QUANT_TABLE_LENGTH\";\n\tcase JPEG_DECODER_BAD_NUMBER_QUANT_TABLES:\n\t\treturn \"JPEG_DECODER_BAD_NUMBER_QUANT_TABLES\";\n\tcase JPEG_DECODER_BAD_COMPONENT_COUNT:\n\t\treturn \"JPEG_DECODER_BAD_COMPONENT_COUNT\";\n\tcase JPEG_DECODER_DIVIDE_BY_ZERO_ERROR:\n\t\treturn \"JPEG_DECODER_DIVIDE_BY_ZERO_ERROR\";\n\tcase JPEG_DECODER_NOT_JPG_IMAGE:\n\t\treturn \"JPEG_DECODER_NOT_JPG_IMAGE\";\n\tcase JPEG_DECODER_UNSUPPORTED_ROTATION_ANGLE:\n\t\treturn \"JPEG_DECODER_UNSUPPORTED_ROTATION_ANGLE\";\n\tcase JPEG_DECODER_UNSUPPORTED_SCALING:\n\t\treturn \"JPEG_DECODER_UNSUPPORTED_SCALING\";\n\tcase JPEG_DECODER_INSUFFICIENT_OUTPUTBUFFER_SIZE:\n\t\treturn \"JPEG_DECODER_INSUFFICIENT_OUTPUTBUFFER_SIZE\";\n\tcase JPEG_DECODER_BAD_HWCFG_GP_VERSION_VALUE:\n\t\treturn \"JPEG_DECODER_BAD_HWCFG_GP_VERSION_VALUE\";\n\tcase JPEG_DECODER_BAD_VALUE_FROM_RED:\n\t\treturn \"JPEG_DECODER_BAD_VALUE_FROM_RED\";\n\tcase JPEG_DECODER_BAD_SUBREGION_PARAMETERS:\n\t\treturn \"JPEG_DECODER_BAD_SUBREGION_PARAMETERS\";\n\tcase JPEG_DECODER_PROGRESSIVE_DECODE_NOT_SUPPORTED:\n\t\treturn \"JPEG_DECODER_PROGRESSIVE_DECODE_NOT_SUPPORTED\";\n\tcase JPEG_DECODER_ERROR_TASK_TIMEOUT:\n\t\treturn \"JPEG_DECODER_ERROR_TASK_TIMEOUT\";\n\tcase JPEG_DECODER_ERROR_FEATURE_NOT_SUPPORTED:\n\t\treturn \"JPEG_DECODER_ERROR_FEATURE_NOT_SUPPORTED\";\n\tdefault:\n\t\treturn \"!unknown MJPEG error!\";\n\t}\n}\n\nstatic bool delta_mjpeg_check_status(struct delta_ctx *pctx,\n\t\t\t\t     struct jpeg_decode_return_params_t *status)\n{\n\tstruct delta_dev *delta = pctx->dev;\n\tbool dump = false;\n\n\tif (status->error_code == JPEG_DECODER_NO_ERROR)\n\t\tgoto out;\n\n\tif (is_stream_error(status->error_code)) {\n\t\tdev_warn_ratelimited(delta->dev,\n\t\t\t\t     \"%s  firmware: stream error @ frame %d (%s)\\n\",\n\t\t\t\t     pctx->name, pctx->decoded_frames,\n\t\t\t\t     err_str(status->error_code));\n\t\tpctx->stream_errors++;\n\t} else {\n\t\tdev_warn_ratelimited(delta->dev,\n\t\t\t\t     \"%s  firmware: decode error @ frame %d (%s)\\n\",\n\t\t\t\t     pctx->name, pctx->decoded_frames,\n\t\t\t\t     err_str(status->error_code));\n\t\tpctx->decode_errors++;\n\t\tdump = true;\n\t}\n\nout:\n\tdev_dbg(delta->dev,\n\t\t\"%s  firmware: decoding time(us)=%d\\n\", pctx->name,\n\t\tstatus->decode_time_in_us);\n\n\treturn dump;\n}\n\nstatic int delta_mjpeg_ipc_open(struct delta_ctx *pctx)\n{\n\tstruct delta_dev *delta = pctx->dev;\n\tstruct delta_mjpeg_ctx *ctx = to_ctx(pctx);\n\tint ret = 0;\n\tstruct jpeg_video_decode_init_params_t params_struct;\n\tstruct jpeg_video_decode_init_params_t *params = &params_struct;\n\tstruct delta_buf *ipc_buf;\n\tu32 ipc_buf_size;\n\tstruct delta_ipc_param ipc_param;\n\tvoid *hdl;\n\n\tmemset(params, 0, sizeof(*params));\n\tparams->circular_buffer_begin_addr_p = 0x00000000;\n\tparams->circular_buffer_end_addr_p = 0xffffffff;\n\n\tdev_vdbg(delta->dev,\n\t\t \"%s  %s\\n\", pctx->name,\n\t\t ipc_open_param_str(params, ctx->str, sizeof(ctx->str)));\n\n\tipc_param.size = sizeof(*params);\n\tipc_param.data = params;\n\tipc_buf_size = sizeof(struct jpeg_decode_params_t) +\n\t    sizeof(struct jpeg_decode_return_params_t);\n\tret = delta_ipc_open(pctx, \"JPEG_DECODER_HW0\", &ipc_param,\n\t\t\t     ipc_buf_size, &ipc_buf, &hdl);\n\tif (ret) {\n\t\tdev_err(delta->dev,\n\t\t\t\"%s  dumping command %s\\n\", pctx->name,\n\t\t\tipc_open_param_str(params, ctx->str, sizeof(ctx->str)));\n\t\treturn ret;\n\t}\n\n\tctx->ipc_buf = ipc_buf;\n\tctx->ipc_hdl = hdl;\n\n\treturn 0;\n}\n\nstatic int delta_mjpeg_ipc_decode(struct delta_ctx *pctx, struct delta_au *au)\n{\n\tstruct delta_dev *delta = pctx->dev;\n\tstruct delta_mjpeg_ctx *ctx = to_ctx(pctx);\n\tint ret = 0;\n\tstruct jpeg_decode_params_t *params = ctx->ipc_buf->vaddr;\n\tstruct jpeg_decode_return_params_t *status =\n\t    ctx->ipc_buf->vaddr + sizeof(*params);\n\tstruct delta_frame *frame;\n\tstruct delta_ipc_param ipc_param, ipc_status;\n\n\tret = delta_get_free_frame(pctx, &frame);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(params, 0, sizeof(*params));\n\n\tparams->picture_start_addr_p = (u32)(au->paddr);\n\tparams->picture_end_addr_p = (u32)(au->paddr + au->size - 1);\n\n\t \n\tparams->main_aux_enable = JPEG_DISP_AUX_EN;\n\tparams->additional_flags = JPEG_ADDITIONAL_FLAG_420MB;\n\tparams->horizontal_decimation_factor = JPEG_HDEC_1;\n\tparams->vertical_decimation_factor = JPEG_VDEC_1;\n\tparams->decoding_mode = JPEG_NORMAL_DECODE;\n\n\tparams->display_buffer_addr.struct_size =\n\t    sizeof(struct jpeg_display_buffer_address_t);\n\tparams->display_buffer_addr.display_decimated_luma_p =\n\t    (u32)frame->paddr;\n\tparams->display_buffer_addr.display_decimated_chroma_p =\n\t    (u32)(frame->paddr\n\t\t  + frame->info.aligned_width * frame->info.aligned_height);\n\n\tdev_vdbg(delta->dev,\n\t\t \"%s  %s\\n\", pctx->name,\n\t\t ipc_decode_param_str(params, ctx->str, sizeof(ctx->str)));\n\n\t \n\tmemset(status, 0, sizeof(*status));\n\tstatus->error_code = JPEG_DECODER_NO_ERROR;\n\n\tipc_param.size = sizeof(*params);\n\tipc_param.data = params;\n\tipc_status.size = sizeof(*status);\n\tipc_status.data = status;\n\tret = delta_ipc_decode(ctx->ipc_hdl, &ipc_param, &ipc_status);\n\tif (ret) {\n\t\tdev_err(delta->dev,\n\t\t\t\"%s  dumping command %s\\n\", pctx->name,\n\t\t\tipc_decode_param_str(params, ctx->str,\n\t\t\t\t\t     sizeof(ctx->str)));\n\t\treturn ret;\n\t}\n\n\tpctx->decoded_frames++;\n\n\t \n\tif (delta_mjpeg_check_status(pctx, status)) {\n\t\tdev_err(delta->dev,\n\t\t\t\"%s  dumping command %s\\n\", pctx->name,\n\t\t\tipc_decode_param_str(params, ctx->str,\n\t\t\t\t\t     sizeof(ctx->str)));\n\t}\n\n\tframe->field = V4L2_FIELD_NONE;\n\tframe->flags = V4L2_BUF_FLAG_KEYFRAME;\n\tframe->state |= DELTA_FRAME_DEC;\n\n\tctx->out_frame = frame;\n\n\treturn 0;\n}\n\nstatic int delta_mjpeg_open(struct delta_ctx *pctx)\n{\n\tstruct delta_mjpeg_ctx *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tpctx->priv = ctx;\n\n\treturn 0;\n}\n\nstatic int delta_mjpeg_close(struct delta_ctx *pctx)\n{\n\tstruct delta_mjpeg_ctx *ctx = to_ctx(pctx);\n\n\tif (ctx->ipc_hdl) {\n\t\tdelta_ipc_close(ctx->ipc_hdl);\n\t\tctx->ipc_hdl = NULL;\n\t}\n\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic int delta_mjpeg_get_streaminfo(struct delta_ctx *pctx,\n\t\t\t\t      struct delta_streaminfo *streaminfo)\n{\n\tstruct delta_mjpeg_ctx *ctx = to_ctx(pctx);\n\n\tif (!ctx->header)\n\t\tgoto nodata;\n\n\tstreaminfo->streamformat = V4L2_PIX_FMT_MJPEG;\n\tstreaminfo->width = ctx->header->frame_width;\n\tstreaminfo->height = ctx->header->frame_height;\n\n\t \n\tstreaminfo->field = V4L2_FIELD_NONE;\n\n\tstreaminfo->dpb = 1;\n\n\treturn 0;\n\nnodata:\n\treturn -ENODATA;\n}\n\nstatic int delta_mjpeg_decode(struct delta_ctx *pctx, struct delta_au *pau)\n{\n\tstruct delta_dev *delta = pctx->dev;\n\tstruct delta_mjpeg_ctx *ctx = to_ctx(pctx);\n\tint ret;\n\tstruct delta_au au = *pau;\n\tunsigned int data_offset = 0;\n\tstruct mjpeg_header *header = &ctx->header_struct;\n\n\tif (!ctx->header) {\n\t\tret = delta_mjpeg_read_header(pctx, au.vaddr, au.size,\n\t\t\t\t\t      header, &data_offset);\n\t\tif (ret) {\n\t\t\tpctx->stream_errors++;\n\t\t\tgoto err;\n\t\t}\n\t\tif (header->frame_width * header->frame_height >\n\t\t    DELTA_MJPEG_MAX_RESO) {\n\t\t\tdev_err(delta->dev,\n\t\t\t\t\"%s  stream resolution too large: %dx%d > %d pixels budget\\n\",\n\t\t\t\tpctx->name,\n\t\t\t\theader->frame_width,\n\t\t\t\theader->frame_height, DELTA_MJPEG_MAX_RESO);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tctx->header = header;\n\t\tgoto out;\n\t}\n\n\tif (!ctx->ipc_hdl) {\n\t\tret = delta_mjpeg_ipc_open(pctx);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = delta_mjpeg_read_header(pctx, au.vaddr, au.size,\n\t\t\t\t      ctx->header, &data_offset);\n\tif (ret) {\n\t\tpctx->stream_errors++;\n\t\tgoto err;\n\t}\n\n\tau.paddr += data_offset;\n\tau.vaddr += data_offset;\n\n\tret = delta_mjpeg_ipc_decode(pctx, &au);\n\tif (ret)\n\t\tgoto err;\n\nout:\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic int delta_mjpeg_get_frame(struct delta_ctx *pctx,\n\t\t\t\t struct delta_frame **frame)\n{\n\tstruct delta_mjpeg_ctx *ctx = to_ctx(pctx);\n\n\tif (!ctx->out_frame)\n\t\treturn -ENODATA;\n\n\t*frame = ctx->out_frame;\n\n\tctx->out_frame = NULL;\n\n\treturn 0;\n}\n\nconst struct delta_dec mjpegdec = {\n\t.name = \"MJPEG\",\n\t.streamformat = V4L2_PIX_FMT_MJPEG,\n\t.pixelformat = V4L2_PIX_FMT_NV12,\n\t.open = delta_mjpeg_open,\n\t.close = delta_mjpeg_close,\n\t.get_streaminfo = delta_mjpeg_get_streaminfo,\n\t.get_frameinfo = delta_get_frameinfo_default,\n\t.decode = delta_mjpeg_decode,\n\t.get_frame = delta_mjpeg_get_frame,\n\t.recycle = delta_recycle_default,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}