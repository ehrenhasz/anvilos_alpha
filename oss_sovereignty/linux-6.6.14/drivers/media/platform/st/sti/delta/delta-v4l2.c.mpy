{
  "module_name": "delta-v4l2.c",
  "hash_id": "5e108c451e3c6943ec4cb93a7f920b67259bc74647d62afd5ec4e7b1cf2dd38a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/st/sti/delta/delta-v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"delta.h\"\n#include \"delta-debug.h\"\n#include \"delta-ipc.h\"\n\n#define DELTA_NAME\t\"st-delta\"\n\n#define DELTA_PREFIX \"[---:----]\"\n\n#define to_ctx(__fh) container_of(__fh, struct delta_ctx, fh)\n#define to_au(__vbuf) container_of(__vbuf, struct delta_au, vbuf)\n#define to_frame(__vbuf) container_of(__vbuf, struct delta_frame, vbuf)\n\n#define call_dec_op(dec, op, args...)\\\n\t\t((dec && (dec)->op) ? (dec)->op(args) : 0)\n\n \nstatic const struct delta_dec *delta_decoders[] = {\n#ifdef CONFIG_VIDEO_STI_DELTA_MJPEG\n\t&mjpegdec,\n#endif\n};\n\nstatic inline int frame_size(u32 w, u32 h, u32 fmt)\n{\n\tswitch (fmt) {\n\tcase V4L2_PIX_FMT_NV12:\n\t\treturn (w * h * 3) / 2;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline int frame_stride(u32 w, u32 fmt)\n{\n\tswitch (fmt) {\n\tcase V4L2_PIX_FMT_NV12:\n\t\treturn w;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void dump_au(struct delta_ctx *ctx, struct delta_au *au)\n{\n\tstruct delta_dev *delta = ctx->dev;\n\tu32 size = 10;\t \n\tu8 *data = (u8 *)(au->vaddr);\n\n\tif (au->size <= (size * 2))\n\t\tdev_dbg(delta->dev, \"%s dump au[%d] dts=%lld size=%d data=%*ph\\n\",\n\t\t\tctx->name, au->vbuf.vb2_buf.index, au->dts, au->size,\n\t\t\tau->size, data);\n\telse\n\t\tdev_dbg(delta->dev, \"%s dump au[%d] dts=%lld size=%d data=%*ph..%*ph\\n\",\n\t\t\tctx->name, au->vbuf.vb2_buf.index, au->dts, au->size,\n\t\t\tsize, data, size, data + au->size - size);\n}\n\nstatic void dump_frame(struct delta_ctx *ctx, struct delta_frame *frame)\n{\n\tstruct delta_dev *delta = ctx->dev;\n\tu32 size = 10;\t \n\tu8 *data = (u8 *)(frame->vaddr);\n\n\tdev_dbg(delta->dev, \"%s dump frame[%d] dts=%lld type=%s field=%s data=%*ph\\n\",\n\t\tctx->name, frame->index, frame->dts,\n\t\tframe_type_str(frame->flags),\n\t\tframe_field_str(frame->field),\n\t\tsize, data);\n}\n\nstatic void delta_au_done(struct delta_ctx *ctx, struct delta_au *au, int err)\n{\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tvbuf = &au->vbuf;\n\tvbuf->sequence = ctx->au_num++;\n\tv4l2_m2m_buf_done(vbuf, err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n}\n\nstatic void delta_frame_done(struct delta_ctx *ctx, struct delta_frame *frame,\n\t\t\t     int err)\n{\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tdump_frame(ctx, frame);\n\n\t \n\tframe->state |= DELTA_FRAME_OUT;\n\n\tvbuf = &frame->vbuf;\n\tvbuf->sequence = ctx->frame_num++;\n\tv4l2_m2m_buf_done(vbuf, err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\n\tif (frame->info.size)  \n\t\tctx->output_frames++;\n}\n\nstatic void requeue_free_frames(struct delta_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct delta_frame *frame;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ctx->nb_of_frames; i++) {\n\t\tframe = ctx->frames[i];\n\t\tif (frame->state == DELTA_FRAME_FREE) {\n\t\t\tvbuf = &frame->vbuf;\n\t\t\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n\t\t\tframe->state = DELTA_FRAME_M2M;\n\t\t}\n\t}\n}\n\nstatic int delta_recycle(struct delta_ctx *ctx, struct delta_frame *frame)\n{\n\tconst struct delta_dec *dec = ctx->dec;\n\n\t \n\tcall_dec_op(dec, recycle, ctx, frame);\n\n\t \n\tframe->state &= ~DELTA_FRAME_OUT;\n\n\t \n\tif (frame->state == DELTA_FRAME_FREE) {\n\t\tstruct vb2_v4l2_buffer *vbuf = &frame->vbuf;\n\n\t\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n\t\tframe->state = DELTA_FRAME_M2M;\n\t}\n\n\t \n\tframe->flags = 0;\n\tframe->dts = 0;\n\n\treturn 0;\n}\n\nstatic void delta_push_dts(struct delta_ctx *ctx, u64 val)\n{\n\tstruct delta_dts *dts;\n\n\tdts = kzalloc(sizeof(*dts), GFP_KERNEL);\n\tif (!dts)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&dts->list);\n\n\t \n\tdts->val = val;\n\tlist_add_tail(&dts->list, &ctx->dts);\n}\n\nstatic void delta_pop_dts(struct delta_ctx *ctx, u64 *val)\n{\n\tstruct delta_dev *delta = ctx->dev;\n\tstruct delta_dts *dts;\n\n\t \n\tif (list_empty(&ctx->dts)) {\n\t\tdev_warn(delta->dev, \"%s no dts to pop ... output dts = 0\\n\",\n\t\t\t ctx->name);\n\t\t*val = 0;\n\t\treturn;\n\t}\n\n\tdts = list_first_entry(&ctx->dts, struct delta_dts, list);\n\tlist_del(&dts->list);\n\n\t*val = dts->val;\n\n\tkfree(dts);\n}\n\nstatic void delta_flush_dts(struct delta_ctx *ctx)\n{\n\tstruct delta_dts *dts;\n\tstruct delta_dts *next;\n\n\t \n\n\t \n\tlist_for_each_entry_safe(dts, next, &ctx->dts, list)\n\t\tkfree(dts);\n\n\t \n\tINIT_LIST_HEAD(&ctx->dts);\n}\n\nstatic inline int frame_alignment(u32 fmt)\n{\n\tswitch (fmt) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\t \n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic inline int estimated_au_size(u32 w, u32 h)\n{\n\t \n\treturn (w * h);\n}\n\nstatic void set_default_params(struct delta_ctx *ctx)\n{\n\tstruct delta_frameinfo *frameinfo = &ctx->frameinfo;\n\tstruct delta_streaminfo *streaminfo = &ctx->streaminfo;\n\n\tmemset(frameinfo, 0, sizeof(*frameinfo));\n\tframeinfo->pixelformat = V4L2_PIX_FMT_NV12;\n\tframeinfo->width = DELTA_DEFAULT_WIDTH;\n\tframeinfo->height = DELTA_DEFAULT_HEIGHT;\n\tframeinfo->aligned_width = ALIGN(frameinfo->width,\n\t\t\t\t\t DELTA_WIDTH_ALIGNMENT);\n\tframeinfo->aligned_height = ALIGN(frameinfo->height,\n\t\t\t\t\t  DELTA_HEIGHT_ALIGNMENT);\n\tframeinfo->size = frame_size(frameinfo->aligned_width,\n\t\t\t\t     frameinfo->aligned_height,\n\t\t\t\t     frameinfo->pixelformat);\n\tframeinfo->field = V4L2_FIELD_NONE;\n\tframeinfo->colorspace = V4L2_COLORSPACE_REC709;\n\tframeinfo->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\tframeinfo->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tframeinfo->quantization = V4L2_QUANTIZATION_DEFAULT;\n\n\tmemset(streaminfo, 0, sizeof(*streaminfo));\n\tstreaminfo->streamformat = DELTA_DEFAULT_STREAMFORMAT;\n\tstreaminfo->width = DELTA_DEFAULT_WIDTH;\n\tstreaminfo->height = DELTA_DEFAULT_HEIGHT;\n\tstreaminfo->field = V4L2_FIELD_NONE;\n\tstreaminfo->colorspace = V4L2_COLORSPACE_REC709;\n\tstreaminfo->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\tstreaminfo->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tstreaminfo->quantization = V4L2_QUANTIZATION_DEFAULT;\n\n\tctx->max_au_size = estimated_au_size(streaminfo->width,\n\t\t\t\t\t     streaminfo->height);\n}\n\nstatic const struct delta_dec *delta_find_decoder(struct delta_ctx *ctx,\n\t\t\t\t\t\t  u32 streamformat,\n\t\t\t\t\t\t  u32 pixelformat)\n{\n\tstruct delta_dev *delta = ctx->dev;\n\tconst struct delta_dec *dec;\n\tunsigned int i;\n\n\tfor (i = 0; i < delta->nb_of_decoders; i++) {\n\t\tdec = delta->decoders[i];\n\t\tif ((dec->pixelformat == pixelformat) &&\n\t\t    (dec->streamformat == streamformat))\n\t\t\treturn dec;\n\t}\n\n\treturn NULL;\n}\n\nstatic void register_format(u32 format, u32 formats[], u32 *nb_of_formats)\n{\n\tu32 i;\n\n\tfor (i = 0; i < *nb_of_formats; i++) {\n\t\tif (format == formats[i])\n\t\t\treturn;\n\t}\n\n\tformats[(*nb_of_formats)++] = format;\n}\n\nstatic void register_formats(struct delta_dev *delta)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < delta->nb_of_decoders; i++) {\n\t\tregister_format(delta->decoders[i]->pixelformat,\n\t\t\t\tdelta->pixelformats,\n\t\t\t\t&delta->nb_of_pixelformats);\n\n\t\tregister_format(delta->decoders[i]->streamformat,\n\t\t\t\tdelta->streamformats,\n\t\t\t\t&delta->nb_of_streamformats);\n\t}\n}\n\nstatic void register_decoders(struct delta_dev *delta)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(delta_decoders); i++) {\n\t\tif (delta->nb_of_decoders >= DELTA_MAX_DECODERS) {\n\t\t\tdev_dbg(delta->dev,\n\t\t\t\t\"%s failed to register %s decoder (%d maximum reached)\\n\",\n\t\t\t\tDELTA_PREFIX, delta_decoders[i]->name,\n\t\t\t\tDELTA_MAX_DECODERS);\n\t\t\treturn;\n\t\t}\n\n\t\tdelta->decoders[delta->nb_of_decoders++] = delta_decoders[i];\n\t\tdev_info(delta->dev, \"%s %s decoder registered\\n\",\n\t\t\t DELTA_PREFIX, delta_decoders[i]->name);\n\t}\n}\n\nstatic int delta_open_decoder(struct delta_ctx *ctx, u32 streamformat,\n\t\t\t      u32 pixelformat, const struct delta_dec **pdec)\n{\n\tstruct delta_dev *delta = ctx->dev;\n\tconst struct delta_dec *dec;\n\tint ret;\n\n\tdec = delta_find_decoder(ctx, streamformat, ctx->frameinfo.pixelformat);\n\tif (!dec) {\n\t\tdev_err(delta->dev, \"%s no decoder found matching %4.4s => %4.4s\\n\",\n\t\t\tctx->name, (char *)&streamformat, (char *)&pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(delta->dev, \"%s one decoder matching %4.4s => %4.4s\\n\",\n\t\tctx->name, (char *)&streamformat, (char *)&pixelformat);\n\n\t \n\tsnprintf(ctx->name, sizeof(ctx->name), \"[%3d:%4.4s]\",\n\t\t delta->instance_id, (char *)&streamformat);\n\n\t \n\tret = call_dec_op(dec, open, ctx);\n\tif (ret) {\n\t\tdev_err(delta->dev, \"%s failed to open decoder instance (%d)\\n\",\n\t\t\tctx->name, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(delta->dev, \"%s %s decoder opened\\n\", ctx->name, dec->name);\n\n\t*pdec = dec;\n\n\treturn ret;\n}\n\n \n\nstatic int delta_querycap(struct file *file, void *priv,\n\t\t\t  struct v4l2_capability *cap)\n{\n\tstruct delta_ctx *ctx = to_ctx(file->private_data);\n\tstruct delta_dev *delta = ctx->dev;\n\n\tstrscpy(cap->driver, DELTA_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, delta->vdev->name, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"platform:%s\",\n\t\t delta->pdev->name);\n\n\treturn 0;\n}\n\nstatic int delta_enum_fmt_stream(struct file *file, void *priv,\n\t\t\t\t struct v4l2_fmtdesc *f)\n{\n\tstruct delta_ctx *ctx = to_ctx(file->private_data);\n\tstruct delta_dev *delta = ctx->dev;\n\n\tif (unlikely(f->index >= delta->nb_of_streamformats))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = delta->streamformats[f->index];\n\n\treturn 0;\n}\n\nstatic int delta_enum_fmt_frame(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tstruct delta_ctx *ctx = to_ctx(file->private_data);\n\tstruct delta_dev *delta = ctx->dev;\n\n\tif (unlikely(f->index >= delta->nb_of_pixelformats))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = delta->pixelformats[f->index];\n\n\treturn 0;\n}\n\nstatic int delta_g_fmt_stream(struct file *file, void *fh,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct delta_ctx *ctx = to_ctx(file->private_data);\n\tstruct delta_dev *delta = ctx->dev;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct delta_streaminfo *streaminfo = &ctx->streaminfo;\n\tunsigned char str[100] = \"\";\n\n\tif (!(ctx->flags & DELTA_FLAG_STREAMINFO))\n\t\tdev_dbg(delta->dev,\n\t\t\t\"%s V4L2 GET_FMT (OUTPUT): no stream information available, default to %s\\n\",\n\t\t\tctx->name,\n\t\t\tdelta_streaminfo_str(streaminfo, str, sizeof(str)));\n\n\tpix->pixelformat = streaminfo->streamformat;\n\tpix->width = streaminfo->width;\n\tpix->height = streaminfo->height;\n\tpix->field = streaminfo->field;\n\tpix->bytesperline = 0;\n\tpix->sizeimage = ctx->max_au_size;\n\tpix->colorspace = streaminfo->colorspace;\n\tpix->xfer_func = streaminfo->xfer_func;\n\tpix->ycbcr_enc = streaminfo->ycbcr_enc;\n\tpix->quantization = streaminfo->quantization;\n\n\treturn 0;\n}\n\nstatic int delta_g_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct delta_ctx *ctx = to_ctx(file->private_data);\n\tstruct delta_dev *delta = ctx->dev;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct delta_frameinfo *frameinfo = &ctx->frameinfo;\n\tstruct delta_streaminfo *streaminfo = &ctx->streaminfo;\n\tunsigned char str[100] = \"\";\n\n\tif (!(ctx->flags & DELTA_FLAG_FRAMEINFO))\n\t\tdev_dbg(delta->dev,\n\t\t\t\"%s V4L2 GET_FMT (CAPTURE): no frame information available, default to %s\\n\",\n\t\t\tctx->name,\n\t\t\tdelta_frameinfo_str(frameinfo, str, sizeof(str)));\n\n\tpix->pixelformat = frameinfo->pixelformat;\n\tpix->width = frameinfo->aligned_width;\n\tpix->height = frameinfo->aligned_height;\n\tpix->field = frameinfo->field;\n\tpix->bytesperline = frame_stride(frameinfo->aligned_width,\n\t\t\t\t\t       frameinfo->pixelformat);\n\tpix->sizeimage = frameinfo->size;\n\n\tif (ctx->flags & DELTA_FLAG_STREAMINFO) {\n\t\t \n\t\tframeinfo->colorspace = streaminfo->colorspace;\n\t\tframeinfo->xfer_func = streaminfo->xfer_func;\n\t\tframeinfo->ycbcr_enc = streaminfo->ycbcr_enc;\n\t\tframeinfo->quantization = streaminfo->quantization;\n\t}\n\tpix->colorspace = frameinfo->colorspace;\n\tpix->xfer_func = frameinfo->xfer_func;\n\tpix->ycbcr_enc = frameinfo->ycbcr_enc;\n\tpix->quantization = frameinfo->quantization;\n\n\treturn 0;\n}\n\nstatic int delta_try_fmt_stream(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct delta_ctx *ctx = to_ctx(file->private_data);\n\tstruct delta_dev *delta = ctx->dev;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tu32 streamformat = pix->pixelformat;\n\tconst struct delta_dec *dec;\n\tu32 width, height;\n\tu32 au_size;\n\n\tdec = delta_find_decoder(ctx, streamformat, ctx->frameinfo.pixelformat);\n\tif (!dec) {\n\t\tdev_dbg(delta->dev,\n\t\t\t\"%s V4L2 TRY_FMT (OUTPUT): unsupported format %4.4s\\n\",\n\t\t\tctx->name, (char *)&pix->pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twidth = pix->width;\n\theight = pix->height;\n\tv4l_bound_align_image\n\t\t(&pix->width,\n\t\t DELTA_MIN_WIDTH,\n\t\t dec->max_width ? dec->max_width : DELTA_MAX_WIDTH,\n\t\t 0,\n\t\t &pix->height,\n\t\t DELTA_MIN_HEIGHT,\n\t\t dec->max_height ? dec->max_height : DELTA_MAX_HEIGHT,\n\t\t 0, 0);\n\n\tif ((pix->width != width) || (pix->height != height))\n\t\tdev_dbg(delta->dev,\n\t\t\t\"%s V4L2 TRY_FMT (OUTPUT): resolution updated %dx%d -> %dx%d to fit min/max/alignment\\n\",\n\t\t\tctx->name, width, height,\n\t\t\tpix->width, pix->height);\n\n\tau_size = estimated_au_size(pix->width, pix->height);\n\tif (pix->sizeimage < au_size) {\n\t\tdev_dbg(delta->dev,\n\t\t\t\"%s V4L2 TRY_FMT (OUTPUT): size updated %d -> %d to fit estimated size\\n\",\n\t\t\tctx->name, pix->sizeimage, au_size);\n\t\tpix->sizeimage = au_size;\n\t}\n\n\tpix->bytesperline = 0;\n\n\tif (pix->field == V4L2_FIELD_ANY)\n\t\tpix->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int delta_try_fmt_frame(struct file *file, void *priv,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct delta_ctx *ctx = to_ctx(file->private_data);\n\tstruct delta_dev *delta = ctx->dev;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tu32 pixelformat = pix->pixelformat;\n\tconst struct delta_dec *dec;\n\tu32 width, height;\n\n\tdec = delta_find_decoder(ctx, ctx->streaminfo.streamformat,\n\t\t\t\t pixelformat);\n\tif (!dec) {\n\t\tdev_dbg(delta->dev,\n\t\t\t\"%s V4L2 TRY_FMT (CAPTURE): unsupported format %4.4s\\n\",\n\t\t\tctx->name, (char *)&pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twidth = pix->width;\n\theight = pix->height;\n\tv4l_bound_align_image(&pix->width,\n\t\t\t      DELTA_MIN_WIDTH, DELTA_MAX_WIDTH,\n\t\t\t      frame_alignment(pixelformat) - 1,\n\t\t\t      &pix->height,\n\t\t\t      DELTA_MIN_HEIGHT, DELTA_MAX_HEIGHT,\n\t\t\t      frame_alignment(pixelformat) - 1, 0);\n\n\tif ((pix->width != width) || (pix->height != height))\n\t\tdev_dbg(delta->dev,\n\t\t\t\"%s V4L2 TRY_FMT (CAPTURE): resolution updated %dx%d -> %dx%d to fit min/max/alignment\\n\",\n\t\t\tctx->name, width, height, pix->width, pix->height);\n\n\t \n\twidth = ALIGN(pix->width, DELTA_WIDTH_ALIGNMENT);\n\theight = ALIGN(pix->height, DELTA_HEIGHT_ALIGNMENT);\n\tif ((pix->width != width) || (pix->height != height))\n\t\tdev_dbg(delta->dev,\n\t\t\t\"%s V4L2 TRY_FMT (CAPTURE): resolution updated %dx%d -> %dx%d to fit decoder alignment\\n\",\n\t\t\tctx->name, width, height, pix->width, pix->height);\n\n\tif (!pix->colorspace) {\n\t\tpix->colorspace = V4L2_COLORSPACE_REC709;\n\t\tpix->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\t\tpix->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\t\tpix->quantization = V4L2_QUANTIZATION_DEFAULT;\n\t}\n\n\tpix->width = width;\n\tpix->height = height;\n\tpix->bytesperline = frame_stride(pix->width, pixelformat);\n\tpix->sizeimage = frame_size(pix->width, pix->height, pixelformat);\n\n\tif (pix->field == V4L2_FIELD_ANY)\n\t\tpix->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int delta_s_fmt_stream(struct file *file, void *fh,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct delta_ctx *ctx = to_ctx(file->private_data);\n\tstruct delta_dev *delta = ctx->dev;\n\tstruct vb2_queue *vq;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tint ret;\n\n\tret = delta_try_fmt_stream(file, fh, f);\n\tif (ret) {\n\t\tdev_dbg(delta->dev,\n\t\t\t\"%s V4L2 S_FMT (OUTPUT): unsupported format %4.4s\\n\",\n\t\t\tctx->name, (char *)&pix->pixelformat);\n\t\treturn ret;\n\t}\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_streaming(vq)) {\n\t\tdev_dbg(delta->dev, \"%s V4L2 S_FMT (OUTPUT): queue busy\\n\",\n\t\t\tctx->name);\n\t\treturn -EBUSY;\n\t}\n\n\tctx->max_au_size = pix->sizeimage;\n\tctx->streaminfo.width = pix->width;\n\tctx->streaminfo.height = pix->height;\n\tctx->streaminfo.streamformat = pix->pixelformat;\n\tctx->streaminfo.colorspace = pix->colorspace;\n\tctx->streaminfo.xfer_func = pix->xfer_func;\n\tctx->streaminfo.ycbcr_enc = pix->ycbcr_enc;\n\tctx->streaminfo.quantization = pix->quantization;\n\tctx->flags |= DELTA_FLAG_STREAMINFO;\n\n\treturn 0;\n}\n\nstatic int delta_s_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct delta_ctx *ctx = to_ctx(file->private_data);\n\tstruct delta_dev *delta = ctx->dev;\n\tconst struct delta_dec *dec = ctx->dec;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct delta_frameinfo frameinfo;\n\tunsigned char str[100] = \"\";\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_streaming(vq)) {\n\t\tdev_dbg(delta->dev, \"%s V4L2 S_FMT (CAPTURE): queue busy\\n\",\n\t\t\tctx->name);\n\t\treturn -EBUSY;\n\t}\n\n\tif (ctx->state < DELTA_STATE_READY) {\n\t\t \n\t\tret = delta_try_fmt_frame(file, fh, f);\n\t\tif (ret) {\n\t\t\tdev_dbg(delta->dev,\n\t\t\t\t\"%s V4L2 S_FMT (CAPTURE): unsupported format %4.4s\\n\",\n\t\t\t\tctx->name, (char *)&pix->pixelformat);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tmemset(&frameinfo, 0, sizeof(frameinfo));\n\tframeinfo.pixelformat = pix->pixelformat;\n\tframeinfo.width = pix->width;\n\tframeinfo.height = pix->height;\n\tframeinfo.aligned_width = pix->width;\n\tframeinfo.aligned_height = pix->height;\n\tframeinfo.size = pix->sizeimage;\n\tframeinfo.field = pix->field;\n\tframeinfo.colorspace = pix->colorspace;\n\tframeinfo.xfer_func = pix->xfer_func;\n\tframeinfo.ycbcr_enc = pix->ycbcr_enc;\n\tframeinfo.quantization = pix->quantization;\n\tret = call_dec_op(dec, set_frameinfo, ctx, &frameinfo);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = call_dec_op(dec, get_frameinfo, ctx, &frameinfo);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->flags |= DELTA_FLAG_FRAMEINFO;\n\tctx->frameinfo = frameinfo;\n\tdev_dbg(delta->dev,\n\t\t\"%s V4L2 SET_FMT (CAPTURE): frameinfo updated to %s\\n\",\n\t\tctx->name,\n\t\tdelta_frameinfo_str(&frameinfo, str, sizeof(str)));\n\n\tpix->pixelformat = frameinfo.pixelformat;\n\tpix->width = frameinfo.aligned_width;\n\tpix->height = frameinfo.aligned_height;\n\tpix->bytesperline = frame_stride(pix->width, pix->pixelformat);\n\tpix->sizeimage = frameinfo.size;\n\tpix->field = frameinfo.field;\n\tpix->colorspace = frameinfo.colorspace;\n\tpix->xfer_func = frameinfo.xfer_func;\n\tpix->ycbcr_enc = frameinfo.ycbcr_enc;\n\tpix->quantization = frameinfo.quantization;\n\n\treturn 0;\n}\n\nstatic int delta_g_selection(struct file *file, void *fh,\n\t\t\t     struct v4l2_selection *s)\n{\n\tstruct delta_ctx *ctx = to_ctx(fh);\n\tstruct delta_frameinfo *frameinfo = &ctx->frameinfo;\n\tstruct v4l2_rect crop;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif ((ctx->flags & DELTA_FLAG_FRAMEINFO) &&\n\t    (frameinfo->flags & DELTA_FRAMEINFO_FLAG_CROP)) {\n\t\tcrop = frameinfo->crop;\n\t} else {\n\t\t \n\t\tcrop.left = 0;\n\t\tcrop.top = 0;\n\t\tcrop.width = frameinfo->width;\n\t\tcrop.height = frameinfo->height;\n\t}\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\t \n\t\ts->r = crop;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_PADDED:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\t \n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = frameinfo->aligned_width;\n\t\ts->r.height = frameinfo->aligned_height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void delta_complete_eos(struct delta_ctx *ctx,\n\t\t\t       struct delta_frame *frame)\n{\n\tstruct delta_dev *delta = ctx->dev;\n\tconst struct v4l2_event ev = {.type = V4L2_EVENT_EOS};\n\n\t \n\n\t \n\tframe->info.size = 0;\n\n\t \n\tframe->flags |= V4L2_BUF_FLAG_LAST;\n\n\t \n\tdelta_frame_done(ctx, frame, 0);\n\n\t \n\tv4l2_event_queue_fh(&ctx->fh, &ev);\n\n\tdev_dbg(delta->dev, \"%s EOS completed\\n\", ctx->name);\n}\n\nstatic int delta_try_decoder_cmd(struct file *file, void *fh,\n\t\t\t\t struct v4l2_decoder_cmd *cmd)\n{\n\tif (cmd->cmd != V4L2_DEC_CMD_STOP)\n\t\treturn -EINVAL;\n\n\tif (cmd->flags & V4L2_DEC_CMD_STOP_TO_BLACK)\n\t\treturn -EINVAL;\n\n\tif (!(cmd->flags & V4L2_DEC_CMD_STOP_IMMEDIATELY) &&\n\t    (cmd->stop.pts != 0))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int delta_decoder_stop_cmd(struct delta_ctx *ctx, void *fh)\n{\n\tconst struct delta_dec *dec = ctx->dec;\n\tstruct delta_dev *delta = ctx->dev;\n\tstruct delta_frame *frame = NULL;\n\tint ret = 0;\n\n\tdev_dbg(delta->dev, \"%s EOS received\\n\", ctx->name);\n\n\tif (ctx->state != DELTA_STATE_READY)\n\t\treturn 0;\n\n\t \n\tcall_dec_op(dec, drain, ctx);\n\n\t \n\twhile (1) {\n\t\tframe = NULL;\n\t\tret = call_dec_op(dec, get_frame, ctx, &frame);\n\t\tif (ret == -ENODATA) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tif (frame) {\n\t\t\tdev_dbg(delta->dev, \"%s drain frame[%d]\\n\",\n\t\t\t\tctx->name, frame->index);\n\n\t\t\t \n\t\t\tdelta_pop_dts(ctx, &frame->dts);\n\n\t\t\t \n\t\t\tdelta_frame_done(ctx, frame, 0);\n\t\t}\n\t}\n\n\t \n\tret = delta_get_free_frame(ctx, &frame);\n\tif (ret)\n\t\tgoto delay_eos;\n\n\t \n\tdelta_complete_eos(ctx, frame);\n\n\tctx->state = DELTA_STATE_EOS;\n\n\treturn 0;\n\ndelay_eos:\n\t \n\tctx->state = DELTA_STATE_WF_EOS;\n\tdev_dbg(delta->dev, \"%s EOS delayed\\n\", ctx->name);\n\n\treturn 0;\n}\n\nstatic int delta_decoder_cmd(struct file *file, void *fh,\n\t\t\t     struct v4l2_decoder_cmd *cmd)\n{\n\tstruct delta_ctx *ctx = to_ctx(fh);\n\tint ret = 0;\n\n\tret = delta_try_decoder_cmd(file, fh, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn delta_decoder_stop_cmd(ctx, fh);\n}\n\nstatic int delta_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_EOS:\n\t\treturn v4l2_event_subscribe(fh, sub, 2, NULL);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct v4l2_ioctl_ops delta_ioctl_ops = {\n\t.vidioc_querycap = delta_querycap,\n\t.vidioc_enum_fmt_vid_cap = delta_enum_fmt_frame,\n\t.vidioc_g_fmt_vid_cap = delta_g_fmt_frame,\n\t.vidioc_try_fmt_vid_cap = delta_try_fmt_frame,\n\t.vidioc_s_fmt_vid_cap = delta_s_fmt_frame,\n\t.vidioc_enum_fmt_vid_out = delta_enum_fmt_stream,\n\t.vidioc_g_fmt_vid_out = delta_g_fmt_stream,\n\t.vidioc_try_fmt_vid_out = delta_try_fmt_stream,\n\t.vidioc_s_fmt_vid_out = delta_s_fmt_stream,\n\t.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,\n\t.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_streamon = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,\n\t.vidioc_g_selection = delta_g_selection,\n\t.vidioc_try_decoder_cmd = delta_try_decoder_cmd,\n\t.vidioc_decoder_cmd = delta_decoder_cmd,\n\t.vidioc_subscribe_event = delta_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n \n\nstatic void delta_run_work(struct work_struct *work)\n{\n\tstruct delta_ctx *ctx = container_of(work, struct delta_ctx, run_work);\n\tstruct delta_dev *delta = ctx->dev;\n\tconst struct delta_dec *dec = ctx->dec;\n\tstruct delta_au *au;\n\tstruct delta_frame *frame = NULL;\n\tint ret = 0;\n\tbool discard = false;\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tif (!dec) {\n\t\tdev_err(delta->dev, \"%s no decoder opened yet\\n\", ctx->name);\n\t\treturn;\n\t}\n\n\t \n\tmutex_lock(&ctx->lock);\n\n\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tif (!vbuf) {\n\t\tdev_err(delta->dev, \"%s no buffer to decode\\n\", ctx->name);\n\t\tmutex_unlock(&ctx->lock);\n\t\treturn;\n\t}\n\tau = to_au(vbuf);\n\tau->size = vb2_get_plane_payload(&vbuf->vb2_buf, 0);\n\tau->dts = vbuf->vb2_buf.timestamp;\n\n\t \n\tdump_au(ctx, au);\n\n\t \n\tif (!dec->pm) {\n\t\tret = delta_get_sync(ctx);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tret = call_dec_op(dec, decode, ctx, au);\n\n\t \n\tif (ret == -ENODATA) {\n\t\tdiscard = true;\n\t} else if (ret) {\n\t\tdev_err(delta->dev, \"%s decoding failed (%d)\\n\",\n\t\t\tctx->name, ret);\n\n\t\t \n\t\tif (!dec->pm)\n\t\t\tdelta_put_autosuspend(ctx);\n\n\t\tgoto err;\n\t}\n\n\t \n\tif (!dec->pm)\n\t\tdelta_put_autosuspend(ctx);\n\n\t \n\tif (!discard)\n\t\tdelta_push_dts(ctx, au->dts);\n\n\t \n\twhile (1) {\n\t\tret = call_dec_op(dec, get_frame, ctx, &frame);\n\t\tif (ret == -ENODATA) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\t\tif (ret) {\n\t\t\tdev_err(delta->dev, \"%s  cannot get decoded frame (%d)\\n\",\n\t\t\t\tctx->name, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!frame) {\n\t\t\tdev_err(delta->dev,\n\t\t\t\t\"%s  NULL decoded frame\\n\",\n\t\t\t\tctx->name);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tdelta_pop_dts(ctx, &frame->dts);\n\n\t\t \n\t\tdelta_frame_done(ctx, frame, 0);\n\t}\n\nout:\n\trequeue_free_frames(ctx);\n\tdelta_au_done(ctx, au, (discard ? -ENODATA : 0));\n\tmutex_unlock(&ctx->lock);\n\tv4l2_m2m_job_finish(delta->m2m_dev, ctx->fh.m2m_ctx);\n\treturn;\n\nerr:\n\trequeue_free_frames(ctx);\n\tdelta_au_done(ctx, au, ret);\n\tmutex_unlock(&ctx->lock);\n\tv4l2_m2m_job_finish(delta->m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic void delta_device_run(void *priv)\n{\n\tstruct delta_ctx *ctx = priv;\n\tstruct delta_dev *delta = ctx->dev;\n\n\tqueue_work(delta->work_queue, &ctx->run_work);\n}\n\nstatic void delta_job_abort(void *priv)\n{\n\tstruct delta_ctx *ctx = priv;\n\tstruct delta_dev *delta = ctx->dev;\n\n\tdev_dbg(delta->dev, \"%s aborting job\\n\", ctx->name);\n\n\tctx->aborting = true;\n}\n\nstatic int delta_job_ready(void *priv)\n{\n\tstruct delta_ctx *ctx = priv;\n\tstruct delta_dev *delta = ctx->dev;\n\tint src_bufs = v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx);\n\n\tif (!src_bufs) {\n\t\tdev_dbg(delta->dev, \"%s not ready: not enough video buffers.\\n\",\n\t\t\tctx->name);\n\t\treturn 0;\n\t}\n\n\tif (!v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx)) {\n\t\tdev_dbg(delta->dev, \"%s not ready: not enough video capture buffers.\\n\",\n\t\t\tctx->name);\n\t\treturn 0;\n\t}\n\n\tif (ctx->aborting) {\n\t\tdev_dbg(delta->dev, \"%s job not ready: aborting\\n\", ctx->name);\n\t\treturn 0;\n\t}\n\n\tdev_dbg(delta->dev, \"%s job ready\\n\", ctx->name);\n\n\treturn 1;\n}\n\n \nstatic const struct v4l2_m2m_ops delta_m2m_ops = {\n\t.device_run     = delta_device_run,\n\t.job_ready\t= delta_job_ready,\n\t.job_abort      = delta_job_abort,\n};\n\n \n\nstatic int delta_vb2_au_queue_setup(struct vb2_queue *vq,\n\t\t\t\t    unsigned int *num_buffers,\n\t\t\t\t    unsigned int *num_planes,\n\t\t\t\t    unsigned int sizes[],\n\t\t\t\t    struct device *alloc_devs[])\n{\n\tstruct delta_ctx *ctx = vb2_get_drv_priv(vq);\n\tunsigned int size = ctx->max_au_size;\n\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*num_planes = 1;\n\tif (*num_buffers < 1)\n\t\t*num_buffers = 1;\n\tif (*num_buffers > DELTA_MAX_AUS)\n\t\t*num_buffers = DELTA_MAX_AUS;\n\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic int delta_vb2_au_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tstruct delta_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct delta_dev *delta = ctx->dev;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct delta_au *au = to_au(vbuf);\n\n\tif (!au->prepared) {\n\t\t \n\t\tau->vaddr = vb2_plane_vaddr(&au->vbuf.vb2_buf, 0);\n\t\tau->paddr = vb2_dma_contig_plane_dma_addr\n\t\t\t\t(&au->vbuf.vb2_buf, 0);\n\t\tau->prepared = true;\n\t\tdev_dbg(delta->dev, \"%s au[%d] prepared; virt=0x%p, phy=0x%pad\\n\",\n\t\t\tctx->name, vb->index, au->vaddr, &au->paddr);\n\t}\n\n\tif (vbuf->field == V4L2_FIELD_ANY)\n\t\tvbuf->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int delta_setup_frame(struct delta_ctx *ctx,\n\t\t\t     struct delta_frame *frame)\n{\n\tstruct delta_dev *delta = ctx->dev;\n\tconst struct delta_dec *dec = ctx->dec;\n\n\tif (frame->index >= DELTA_MAX_FRAMES) {\n\t\tdev_err(delta->dev,\n\t\t\t\"%s frame index=%d exceeds output frame count (%d)\\n\",\n\t\t\tctx->name, frame->index, DELTA_MAX_FRAMES);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->nb_of_frames >= DELTA_MAX_FRAMES) {\n\t\tdev_err(delta->dev,\n\t\t\t\"%s number of frames exceeds output frame count (%d > %d)\\n\",\n\t\t\tctx->name, ctx->nb_of_frames, DELTA_MAX_FRAMES);\n\t\treturn -EINVAL;\n\t}\n\n\tif (frame->index != ctx->nb_of_frames) {\n\t\tdev_warn(delta->dev,\n\t\t\t \"%s frame index discontinuity detected, expected %d, got %d\\n\",\n\t\t\t ctx->name, ctx->nb_of_frames, frame->index);\n\t}\n\n\tframe->state = DELTA_FRAME_FREE;\n\tctx->frames[ctx->nb_of_frames] = frame;\n\tctx->nb_of_frames++;\n\n\t \n\treturn call_dec_op(dec, setup_frame, ctx, frame);\n}\n\n \nint delta_get_frameinfo_default(struct delta_ctx *ctx,\n\t\t\t\tstruct delta_frameinfo *frameinfo)\n{\n\tstruct delta_streaminfo *streaminfo = &ctx->streaminfo;\n\n\tmemset(frameinfo, 0, sizeof(*frameinfo));\n\tframeinfo->pixelformat = V4L2_PIX_FMT_NV12;\n\tframeinfo->width = streaminfo->width;\n\tframeinfo->height = streaminfo->height;\n\tframeinfo->aligned_width = ALIGN(streaminfo->width,\n\t\t\t\t\t DELTA_WIDTH_ALIGNMENT);\n\tframeinfo->aligned_height = ALIGN(streaminfo->height,\n\t\t\t\t\t  DELTA_HEIGHT_ALIGNMENT);\n\tframeinfo->size = frame_size(frameinfo->aligned_width,\n\t\t\t\t     frameinfo->aligned_height,\n\t\t\t\t     frameinfo->pixelformat);\n\tif (streaminfo->flags & DELTA_STREAMINFO_FLAG_CROP) {\n\t\tframeinfo->flags |= DELTA_FRAMEINFO_FLAG_CROP;\n\t\tframeinfo->crop = streaminfo->crop;\n\t}\n\tif (streaminfo->flags & DELTA_STREAMINFO_FLAG_PIXELASPECT) {\n\t\tframeinfo->flags |= DELTA_FRAMEINFO_FLAG_PIXELASPECT;\n\t\tframeinfo->pixelaspect = streaminfo->pixelaspect;\n\t}\n\tframeinfo->field = streaminfo->field;\n\n\treturn 0;\n}\n\n \nint delta_recycle_default(struct delta_ctx *pctx,\n\t\t\t  struct delta_frame *frame)\n{\n\tframe->state &= ~DELTA_FRAME_DEC;\n\n\treturn 0;\n}\n\nstatic void dump_frames_status(struct delta_ctx *ctx)\n{\n\tstruct delta_dev *delta = ctx->dev;\n\tunsigned int i;\n\tstruct delta_frame *frame;\n\tunsigned char str[100] = \"\";\n\n\tdev_info(delta->dev,\n\t\t \"%s dumping frames status...\\n\", ctx->name);\n\n\tfor (i = 0; i < ctx->nb_of_frames; i++) {\n\t\tframe = ctx->frames[i];\n\t\tdev_info(delta->dev,\n\t\t\t \"%s frame[%d] %s\\n\",\n\t\t\t ctx->name, frame->index,\n\t\t\t frame_state_str(frame->state,\n\t\t\t\t\t str, sizeof(str)));\n\t}\n}\n\nint delta_get_free_frame(struct delta_ctx *ctx,\n\t\t\t struct delta_frame **pframe)\n{\n\tstruct delta_dev *delta = ctx->dev;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct delta_frame *frame;\n\n\t*pframe = NULL;\n\n\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tif (!vbuf) {\n\t\tdev_err(delta->dev, \"%s no frame available\",\n\t\t\tctx->name);\n\t\treturn -EIO;\n\t}\n\n\tframe = to_frame(vbuf);\n\tframe->state &= ~DELTA_FRAME_M2M;\n\tif (frame->state != DELTA_FRAME_FREE) {\n\t\tdev_err(delta->dev,\n\t\t\t\"%s frame[%d] is not free\\n\",\n\t\t\tctx->name, frame->index);\n\t\tdump_frames_status(ctx);\n\t\treturn -ENODATA;\n\t}\n\n\tdev_dbg(delta->dev,\n\t\t\"%s get free frame[%d]\\n\", ctx->name, frame->index);\n\n\t*pframe = frame;\n\treturn 0;\n}\n\nint delta_get_sync(struct delta_ctx *ctx)\n{\n\tstruct delta_dev *delta = ctx->dev;\n\tint ret = 0;\n\n\t \n\tret = pm_runtime_resume_and_get(delta->dev);\n\tif (ret < 0) {\n\t\tdev_err(delta->dev, \"%s pm_runtime_resume_and_get failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid delta_put_autosuspend(struct delta_ctx *ctx)\n{\n\tstruct delta_dev *delta = ctx->dev;\n\n\tpm_runtime_put_autosuspend(delta->dev);\n}\n\nstatic void delta_vb2_au_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tstruct delta_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int delta_vb2_au_start_streaming(struct vb2_queue *q,\n\t\t\t\t\tunsigned int count)\n{\n\tstruct delta_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct delta_dev *delta = ctx->dev;\n\tconst struct delta_dec *dec = ctx->dec;\n\tstruct delta_au *au;\n\tint ret = 0;\n\tstruct vb2_v4l2_buffer *vbuf = NULL;\n\tstruct delta_streaminfo *streaminfo = &ctx->streaminfo;\n\tstruct delta_frameinfo *frameinfo = &ctx->frameinfo;\n\tunsigned char str1[100] = \"\";\n\tunsigned char str2[100] = \"\";\n\n\tif ((ctx->state != DELTA_STATE_WF_FORMAT) &&\n\t    (ctx->state != DELTA_STATE_WF_STREAMINFO))\n\t\treturn 0;\n\n\tif (ctx->state == DELTA_STATE_WF_FORMAT) {\n\t\t \n\t\tret = delta_open_decoder(ctx,\n\t\t\t\t\t ctx->streaminfo.streamformat,\n\t\t\t\t\t ctx->frameinfo.pixelformat, &dec);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tctx->dec = dec;\n\t\tctx->state = DELTA_STATE_WF_STREAMINFO;\n\t}\n\n\t \n\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tif (!vbuf) {\n\t\tdev_err(delta->dev, \"%s failed to start streaming, no stream header buffer enqueued\\n\",\n\t\t\tctx->name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tau = to_au(vbuf);\n\tau->size = vb2_get_plane_payload(&vbuf->vb2_buf, 0);\n\tau->dts = vbuf->vb2_buf.timestamp;\n\n\tdelta_push_dts(ctx, au->dts);\n\n\t \n\tdump_au(ctx, au);\n\n\t \n\tret = call_dec_op(dec, decode, ctx, au);\n\tif (ret) {\n\t\tdev_err(delta->dev, \"%s failed to start streaming, header decoding failed (%d)\\n\",\n\t\t\tctx->name, ret);\n\t\tgoto err;\n\t}\n\n\tret = call_dec_op(dec, get_streaminfo, ctx, streaminfo);\n\tif (ret) {\n\t\tdev_dbg_ratelimited(delta->dev,\n\t\t\t\t    \"%s failed to start streaming, valid stream header not yet decoded\\n\",\n\t\t\t\t    ctx->name);\n\t\tgoto err;\n\t}\n\tctx->flags |= DELTA_FLAG_STREAMINFO;\n\n\tret = call_dec_op(dec, get_frameinfo, ctx, frameinfo);\n\tif (ret)\n\t\tgoto err;\n\tctx->flags |= DELTA_FLAG_FRAMEINFO;\n\n\tctx->state = DELTA_STATE_READY;\n\n\tdev_dbg(delta->dev, \"%s %s => %s\\n\", ctx->name,\n\t\tdelta_streaminfo_str(streaminfo, str1, sizeof(str1)),\n\t\tdelta_frameinfo_str(frameinfo, str2, sizeof(str2)));\n\n\tdelta_au_done(ctx, au, ret);\n\treturn 0;\n\nerr:\n\t \n\tif (vbuf)\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_QUEUED);\n\n\twhile ((vbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_QUEUED);\n\treturn ret;\n}\n\nstatic void delta_vb2_au_stop_streaming(struct vb2_queue *q)\n{\n\tstruct delta_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tdelta_flush_dts(ctx);\n\n\t \n\twhile ((vbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\n\tctx->au_num = 0;\n\n\tctx->aborting = false;\n}\n\nstatic int delta_vb2_frame_queue_setup(struct vb2_queue *vq,\n\t\t\t\t       unsigned int *num_buffers,\n\t\t\t\t       unsigned int *num_planes,\n\t\t\t\t       unsigned int sizes[],\n\t\t\t\t       struct device *alloc_devs[])\n{\n\tstruct delta_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct delta_dev *delta = ctx->dev;\n\tstruct delta_streaminfo *streaminfo = &ctx->streaminfo;\n\tstruct delta_frameinfo *frameinfo = &ctx->frameinfo;\n\tunsigned int size = frameinfo->size;\n\n\t \n\tif (*num_buffers < DELTA_MIN_FRAME_USER) {\n\t\tdev_dbg(delta->dev,\n\t\t\t\"%s num_buffers too low (%d), increasing to %d\\n\",\n\t\t\tctx->name, *num_buffers, DELTA_MIN_FRAME_USER);\n\t\t*num_buffers = DELTA_MIN_FRAME_USER;\n\t}\n\n\t*num_buffers += streaminfo->dpb + DELTA_PEAK_FRAME_SMOOTHING;\n\n\tif (*num_buffers > DELTA_MAX_FRAMES) {\n\t\tdev_dbg(delta->dev,\n\t\t\t\"%s output frame count too high (%d), cut to %d\\n\",\n\t\t\tctx->name, *num_buffers, DELTA_MAX_FRAMES);\n\t\t*num_buffers = DELTA_MAX_FRAMES;\n\t}\n\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t \n\t*num_planes = 1;\n\n\tsizes[0] = size;\n\n\tctx->nb_of_frames = 0;\n\n\treturn 0;\n}\n\nstatic int delta_vb2_frame_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tstruct delta_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct delta_dev *delta = ctx->dev;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct delta_frame *frame = to_frame(vbuf);\n\tint ret = 0;\n\n\tif (!frame->prepared) {\n\t\tframe->index = vbuf->vb2_buf.index;\n\t\tframe->vaddr = vb2_plane_vaddr(&vbuf->vb2_buf, 0);\n\t\tframe->paddr = vb2_dma_contig_plane_dma_addr(&vbuf->vb2_buf, 0);\n\t\tframe->info = ctx->frameinfo;\n\n\t\tret = delta_setup_frame(ctx, frame);\n\t\tif (ret) {\n\t\t\tdev_err(delta->dev,\n\t\t\t\t\"%s setup_frame() failed (%d)\\n\",\n\t\t\t\tctx->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tframe->prepared = true;\n\t\tdev_dbg(delta->dev,\n\t\t\t\"%s frame[%d] prepared; virt=0x%p, phy=0x%pad\\n\",\n\t\t\tctx->name, vb->index, frame->vaddr,\n\t\t\t&frame->paddr);\n\t}\n\n\tframe->flags = vbuf->flags;\n\n\treturn 0;\n}\n\nstatic void delta_vb2_frame_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct delta_frame *frame = to_frame(vbuf);\n\n\t \n\tvb2_set_plane_payload(&vbuf->vb2_buf, 0, frame->info.size);\n\tvb->timestamp = frame->dts;\n\tvbuf->field = frame->field;\n\tvbuf->flags = frame->flags;\n}\n\nstatic void delta_vb2_frame_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *q = vb->vb2_queue;\n\tstruct delta_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct delta_frame *frame = to_frame(vbuf);\n\n\tif (ctx->state == DELTA_STATE_WF_EOS) {\n\t\t \n\t\tdelta_complete_eos(ctx, frame);\n\n\t\tctx->state = DELTA_STATE_EOS;\n\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tdelta_recycle(ctx, frame);\n}\n\nstatic void delta_vb2_frame_stop_streaming(struct vb2_queue *q)\n{\n\tstruct delta_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct delta_frame *frame;\n\tconst struct delta_dec *dec = ctx->dec;\n\tunsigned int i;\n\n\tdelta_flush_dts(ctx);\n\n\tcall_dec_op(dec, flush, ctx);\n\n\t \n\tfor (i = 0; i < ctx->nb_of_frames; i++) {\n\t\tframe = ctx->frames[i];\n\t\tif (!(frame->state & DELTA_FRAME_OUT)) {\n\t\t\tvbuf = &frame->vbuf;\n\t\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t\t}\n\t\tframe->state = DELTA_FRAME_OUT;\n\t}\n\n\tctx->frame_num = 0;\n\n\tctx->aborting = false;\n}\n\n \nstatic const struct vb2_ops delta_vb2_au_ops = {\n\t.queue_setup = delta_vb2_au_queue_setup,\n\t.buf_prepare = delta_vb2_au_prepare,\n\t.buf_queue = delta_vb2_au_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = delta_vb2_au_start_streaming,\n\t.stop_streaming = delta_vb2_au_stop_streaming,\n};\n\nstatic const struct vb2_ops delta_vb2_frame_ops = {\n\t.queue_setup = delta_vb2_frame_queue_setup,\n\t.buf_prepare = delta_vb2_frame_prepare,\n\t.buf_finish = delta_vb2_frame_finish,\n\t.buf_queue = delta_vb2_frame_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.stop_streaming = delta_vb2_frame_stop_streaming,\n};\n\n \n\nstatic int queue_init(void *priv,\n\t\t      struct vb2_queue *src_vq, struct vb2_queue *dst_vq)\n{\n\tstruct vb2_queue *q;\n\tstruct delta_ctx *ctx = priv;\n\tstruct delta_dev *delta = ctx->dev;\n\tint ret;\n\n\t \n\tq = src_vq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tq->drv_priv = ctx;\n\t \n\tq->buf_struct_size = sizeof(struct delta_au);\n\tq->ops = &delta_vb2_au_ops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tq->lock = &delta->lock;\n\tq->dev = delta->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tq = dst_vq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tq->drv_priv = ctx;\n\t \n\tq->buf_struct_size = sizeof(struct delta_frame)\n\t\t\t     + DELTA_MAX_FRAME_PRIV_SIZE;\n\tq->ops = &delta_vb2_frame_ops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tq->lock = &delta->lock;\n\tq->dev = delta->dev;\n\n\treturn vb2_queue_init(q);\n}\n\nstatic int delta_open(struct file *file)\n{\n\tstruct delta_dev *delta = video_drvdata(file);\n\tstruct delta_ctx *ctx = NULL;\n\tint ret = 0;\n\n\tmutex_lock(&delta->lock);\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tctx->dev = delta;\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\tINIT_WORK(&ctx->run_work, delta_run_work);\n\tmutex_init(&ctx->lock);\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(delta->m2m_dev, ctx,\n\t\t\t\t\t    queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tdev_err(delta->dev, \"%s failed to initialize m2m context (%d)\\n\",\n\t\t\tDELTA_PREFIX, ret);\n\t\tgoto err_fh_del;\n\t}\n\n\t \n\tctx->state = DELTA_STATE_WF_FORMAT;\n\n\tINIT_LIST_HEAD(&ctx->dts);\n\n\t \n\tdelta->instance_id++;\n\tsnprintf(ctx->name, sizeof(ctx->name), \"[%3d:----]\",\n\t\t delta->instance_id);\n\n\t \n\tset_default_params(ctx);\n\n\t \n\tif (clk_prepare_enable(delta->clk_st231))\n\t\tdev_warn(delta->dev, \"failed to enable st231 clk\\n\");\n\n\t \n\tif (clk_prepare_enable(delta->clk_flash_promip))\n\t\tdev_warn(delta->dev, \"failed to enable delta promip clk\\n\");\n\n\tmutex_unlock(&delta->lock);\n\n\tdev_dbg(delta->dev, \"%s decoder instance created\\n\", ctx->name);\n\n\treturn 0;\n\nerr_fh_del:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\nerr:\n\tmutex_unlock(&delta->lock);\n\n\treturn ret;\n}\n\nstatic int delta_release(struct file *file)\n{\n\tstruct delta_ctx *ctx = to_ctx(file->private_data);\n\tstruct delta_dev *delta = ctx->dev;\n\tconst struct delta_dec *dec = ctx->dec;\n\n\tmutex_lock(&delta->lock);\n\n\t \n\tcall_dec_op(dec, close, ctx);\n\n\t \n\tdelta_trace_summary(ctx);\n\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\n\t \n\tclk_disable_unprepare(delta->clk_st231);\n\n\t \n\tclk_disable_unprepare(delta->clk_flash_promip);\n\n\tdev_dbg(delta->dev, \"%s decoder instance released\\n\", ctx->name);\n\n\tkfree(ctx);\n\n\tmutex_unlock(&delta->lock);\n\treturn 0;\n}\n\n \nstatic const struct v4l2_file_operations delta_fops = {\n\t.owner = THIS_MODULE,\n\t.open = delta_open,\n\t.release = delta_release,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap = v4l2_m2m_fop_mmap,\n\t.poll = v4l2_m2m_fop_poll,\n};\n\n \n\nstatic int delta_register_device(struct delta_dev *delta)\n{\n\tint ret;\n\tstruct video_device *vdev;\n\n\tif (!delta)\n\t\treturn -ENODEV;\n\n\tdelta->m2m_dev = v4l2_m2m_init(&delta_m2m_ops);\n\tif (IS_ERR(delta->m2m_dev)) {\n\t\tdev_err(delta->dev, \"%s failed to initialize v4l2-m2m device\\n\",\n\t\t\tDELTA_PREFIX);\n\t\tret = PTR_ERR(delta->m2m_dev);\n\t\tgoto err;\n\t}\n\n\tvdev = video_device_alloc();\n\tif (!vdev) {\n\t\tdev_err(delta->dev, \"%s failed to allocate video device\\n\",\n\t\t\tDELTA_PREFIX);\n\t\tret = -ENOMEM;\n\t\tgoto err_m2m_release;\n\t}\n\n\tvdev->fops = &delta_fops;\n\tvdev->ioctl_ops = &delta_ioctl_ops;\n\tvdev->release = video_device_release;\n\tvdev->lock = &delta->lock;\n\tvdev->vfl_dir = VFL_DIR_M2M;\n\tvdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M;\n\tvdev->v4l2_dev = &delta->v4l2_dev;\n\tsnprintf(vdev->name, sizeof(vdev->name), \"%s-%s\",\n\t\t DELTA_NAME, DELTA_FW_VERSION);\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(delta->dev, \"%s failed to register video device\\n\",\n\t\t\tDELTA_PREFIX);\n\t\tgoto err_vdev_release;\n\t}\n\n\tdelta->vdev = vdev;\n\tvideo_set_drvdata(vdev, delta);\n\treturn 0;\n\nerr_vdev_release:\n\tvideo_device_release(vdev);\nerr_m2m_release:\n\tv4l2_m2m_release(delta->m2m_dev);\nerr:\n\treturn ret;\n}\n\nstatic void delta_unregister_device(struct delta_dev *delta)\n{\n\tif (!delta)\n\t\treturn;\n\n\tif (delta->m2m_dev)\n\t\tv4l2_m2m_release(delta->m2m_dev);\n\n\tvideo_unregister_device(delta->vdev);\n}\n\nstatic int delta_probe(struct platform_device *pdev)\n{\n\tstruct delta_dev *delta;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tdelta = devm_kzalloc(dev, sizeof(*delta), GFP_KERNEL);\n\tif (!delta) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdelta->dev = dev;\n\tdelta->pdev = pdev;\n\tplatform_set_drvdata(pdev, delta);\n\n\tmutex_init(&delta->lock);\n\n\t \n\tdelta->clk_delta = devm_clk_get(dev, \"delta\");\n\tif (IS_ERR(delta->clk_delta)) {\n\t\tdev_dbg(dev, \"%s can't get delta clock\\n\", DELTA_PREFIX);\n\t\tdelta->clk_delta = NULL;\n\t}\n\n\tdelta->clk_st231 = devm_clk_get(dev, \"delta-st231\");\n\tif (IS_ERR(delta->clk_st231)) {\n\t\tdev_dbg(dev, \"%s can't get delta-st231 clock\\n\", DELTA_PREFIX);\n\t\tdelta->clk_st231 = NULL;\n\t}\n\n\tdelta->clk_flash_promip = devm_clk_get(dev, \"delta-flash-promip\");\n\tif (IS_ERR(delta->clk_flash_promip)) {\n\t\tdev_dbg(dev, \"%s can't get delta-flash-promip clock\\n\",\n\t\t\tDELTA_PREFIX);\n\t\tdelta->clk_flash_promip = NULL;\n\t}\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, DELTA_HW_AUTOSUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_enable(dev);\n\n\t \n\tret = delta_ipc_init(delta);\n\tif (ret) {\n\t\tdev_err(delta->dev, \"%s failed to initialize firmware ipc channel\\n\",\n\t\t\tDELTA_PREFIX);\n\t\tgoto err_pm_disable;\n\t}\n\n\t \n\tregister_decoders(delta);\n\n\t \n\tregister_formats(delta);\n\n\t \n\tret = v4l2_device_register(dev, &delta->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(delta->dev, \"%s failed to register V4L2 device\\n\",\n\t\t\tDELTA_PREFIX);\n\t\tgoto err_pm_disable;\n\t}\n\n\tdelta->work_queue = create_workqueue(DELTA_NAME);\n\tif (!delta->work_queue) {\n\t\tdev_err(delta->dev, \"%s failed to allocate work queue\\n\",\n\t\t\tDELTA_PREFIX);\n\t\tret = -ENOMEM;\n\t\tgoto err_v4l2;\n\t}\n\n\t \n\tret = delta_register_device(delta);\n\tif (ret)\n\t\tgoto err_work_queue;\n\n\tdev_info(dev, \"%s %s registered as /dev/video%d\\n\",\n\t\t DELTA_PREFIX, delta->vdev->name, delta->vdev->num);\n\n\treturn 0;\n\nerr_work_queue:\n\tdestroy_workqueue(delta->work_queue);\nerr_v4l2:\n\tv4l2_device_unregister(&delta->v4l2_dev);\nerr_pm_disable:\n\tpm_runtime_disable(dev);\nerr:\n\treturn ret;\n}\n\nstatic void delta_remove(struct platform_device *pdev)\n{\n\tstruct delta_dev *delta = platform_get_drvdata(pdev);\n\n\tdelta_ipc_exit(delta);\n\n\tdelta_unregister_device(delta);\n\n\tdestroy_workqueue(delta->work_queue);\n\n\tpm_runtime_put_autosuspend(delta->dev);\n\tpm_runtime_disable(delta->dev);\n\n\tv4l2_device_unregister(&delta->v4l2_dev);\n}\n\nstatic int delta_runtime_suspend(struct device *dev)\n{\n\tstruct delta_dev *delta = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(delta->clk_delta);\n\n\treturn 0;\n}\n\nstatic int delta_runtime_resume(struct device *dev)\n{\n\tstruct delta_dev *delta = dev_get_drvdata(dev);\n\n\tif (clk_prepare_enable(delta->clk_delta))\n\t\tdev_warn(dev, \"failed to prepare/enable delta clk\\n\");\n\n\treturn 0;\n}\n\n \nstatic const struct dev_pm_ops delta_pm_ops = {\n\t.runtime_suspend = delta_runtime_suspend,\n\t.runtime_resume = delta_runtime_resume,\n};\n\nstatic const struct of_device_id delta_match_types[] = {\n\t{\n\t .compatible = \"st,st-delta\",\n\t},\n\t{\n\t  \n\t}\n};\n\nMODULE_DEVICE_TABLE(of, delta_match_types);\n\nstatic struct platform_driver delta_driver = {\n\t.probe = delta_probe,\n\t.remove_new = delta_remove,\n\t.driver = {\n\t\t   .name = DELTA_NAME,\n\t\t   .of_match_table = delta_match_types,\n\t\t   .pm = &delta_pm_ops},\n};\n\nmodule_platform_driver(delta_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Hugues Fruchet <hugues.fruchet@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics DELTA video decoder V4L2 driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}