{
  "module_name": "c8sectpfe-common.c",
  "hash_id": "59bbb11799a59aae063d75bcea6b69a0f43fd808eccf13ee0a3ea95e9b0242d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/st/sti/c8sectpfe/c8sectpfe-common.c",
  "human_readable_source": "\n \n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dvb/dmx.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n\n#include <media/dmxdev.h>\n#include <media/dvbdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n#include <media/dvb_net.h>\n\n#include \"c8sectpfe-common.h\"\n#include \"c8sectpfe-core.h\"\n#include \"c8sectpfe-dvb.h\"\n\nstatic int register_dvb(struct stdemux *demux, struct dvb_adapter *adap,\n\t\t\t\tvoid *start_feed, void *stop_feed,\n\t\t\t\tstruct c8sectpfei *fei)\n{\n\tint result;\n\n\tdemux->dvb_demux.dmx.capabilities = DMX_TS_FILTERING |\n\t\t\t\t\tDMX_SECTION_FILTERING |\n\t\t\t\t\tDMX_MEMORY_BASED_FILTERING;\n\n\tdemux->dvb_demux.priv = demux;\n\tdemux->dvb_demux.filternum = C8SECTPFE_MAXCHANNEL;\n\tdemux->dvb_demux.feednum = C8SECTPFE_MAXCHANNEL;\n\n\tdemux->dvb_demux.start_feed = start_feed;\n\tdemux->dvb_demux.stop_feed = stop_feed;\n\tdemux->dvb_demux.write_to_decoder = NULL;\n\n\tresult = dvb_dmx_init(&demux->dvb_demux);\n\tif (result < 0) {\n\t\tdev_err(fei->dev, \"dvb_dmx_init failed (errno = %d)\\n\",\n\t\t\tresult);\n\t\tgoto err_dmx;\n\t}\n\n\tdemux->dmxdev.filternum = demux->dvb_demux.filternum;\n\tdemux->dmxdev.demux = &demux->dvb_demux.dmx;\n\tdemux->dmxdev.capabilities = 0;\n\n\tresult = dvb_dmxdev_init(&demux->dmxdev, adap);\n\tif (result < 0) {\n\t\tdev_err(fei->dev, \"dvb_dmxdev_init failed (errno = %d)\\n\",\n\t\t\tresult);\n\n\t\tgoto err_dmxdev;\n\t}\n\n\tdemux->hw_frontend.source = DMX_FRONTEND_0 + demux->tsin_index;\n\n\tresult = demux->dvb_demux.dmx.add_frontend(&demux->dvb_demux.dmx,\n\t\t\t\t\t\t&demux->hw_frontend);\n\tif (result < 0) {\n\t\tdev_err(fei->dev, \"add_frontend failed (errno = %d)\\n\", result);\n\t\tgoto err_fe_hw;\n\t}\n\n\tdemux->mem_frontend.source = DMX_MEMORY_FE;\n\tresult = demux->dvb_demux.dmx.add_frontend(&demux->dvb_demux.dmx,\n\t\t\t\t\t\t&demux->mem_frontend);\n\tif (result < 0) {\n\t\tdev_err(fei->dev, \"add_frontend failed (%d)\\n\", result);\n\t\tgoto err_fe_mem;\n\t}\n\n\tresult = demux->dvb_demux.dmx.connect_frontend(&demux->dvb_demux.dmx,\n\t\t\t\t\t\t\t&demux->hw_frontend);\n\tif (result < 0) {\n\t\tdev_err(fei->dev, \"connect_frontend (%d)\\n\", result);\n\t\tgoto err_fe_con;\n\t}\n\n\treturn 0;\n\nerr_fe_con:\n\tdemux->dvb_demux.dmx.remove_frontend(&demux->dvb_demux.dmx,\n\t\t\t\t\t\t     &demux->mem_frontend);\nerr_fe_mem:\n\tdemux->dvb_demux.dmx.remove_frontend(&demux->dvb_demux.dmx,\n\t\t\t\t\t\t     &demux->hw_frontend);\nerr_fe_hw:\n\tdvb_dmxdev_release(&demux->dmxdev);\nerr_dmxdev:\n\tdvb_dmx_release(&demux->dvb_demux);\nerr_dmx:\n\treturn result;\n\n}\n\nstatic void unregister_dvb(struct stdemux *demux)\n{\n\n\tdemux->dvb_demux.dmx.remove_frontend(&demux->dvb_demux.dmx,\n\t\t\t\t\t\t     &demux->mem_frontend);\n\n\tdemux->dvb_demux.dmx.remove_frontend(&demux->dvb_demux.dmx,\n\t\t\t\t\t\t     &demux->hw_frontend);\n\n\tdvb_dmxdev_release(&demux->dmxdev);\n\n\tdvb_dmx_release(&demux->dvb_demux);\n}\n\nstatic struct c8sectpfe *c8sectpfe_create(struct c8sectpfei *fei,\n\t\t\t\tvoid *start_feed,\n\t\t\t\tvoid *stop_feed)\n{\n\tstruct c8sectpfe *c8sectpfe;\n\tint result;\n\tint i, j;\n\n\tshort int ids[] = { -1 };\n\n\tc8sectpfe = kzalloc(sizeof(struct c8sectpfe), GFP_KERNEL);\n\tif (!c8sectpfe)\n\t\tgoto err1;\n\n\tmutex_init(&c8sectpfe->lock);\n\n\tc8sectpfe->device = fei->dev;\n\n\tresult = dvb_register_adapter(&c8sectpfe->adapter, \"STi c8sectpfe\",\n\t\t\t\t\tTHIS_MODULE, fei->dev, ids);\n\tif (result < 0) {\n\t\tdev_err(fei->dev, \"dvb_register_adapter failed (errno = %d)\\n\",\n\t\t\tresult);\n\t\tgoto err2;\n\t}\n\n\tc8sectpfe->adapter.priv = fei;\n\n\tfor (i = 0; i < fei->tsin_count; i++) {\n\n\t\tc8sectpfe->demux[i].tsin_index = i;\n\t\tc8sectpfe->demux[i].c8sectpfei = fei;\n\n\t\tresult = register_dvb(&c8sectpfe->demux[i], &c8sectpfe->adapter,\n\t\t\t\tstart_feed, stop_feed, fei);\n\t\tif (result < 0) {\n\t\t\tdev_err(fei->dev,\n\t\t\t\t\"register_dvb feed=%d failed (errno = %d)\\n\",\n\t\t\t\tresult, i);\n\n\t\t\t \n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tunregister_dvb(&c8sectpfe->demux[j]);\n\t\t\tgoto err3;\n\t\t}\n\t}\n\n\tc8sectpfe->num_feeds = fei->tsin_count;\n\n\treturn c8sectpfe;\nerr3:\n\tdvb_unregister_adapter(&c8sectpfe->adapter);\nerr2:\n\tkfree(c8sectpfe);\nerr1:\n\treturn NULL;\n};\n\nstatic void c8sectpfe_delete(struct c8sectpfe *c8sectpfe)\n{\n\tint i;\n\n\tif (!c8sectpfe)\n\t\treturn;\n\n\tfor (i = 0; i < c8sectpfe->num_feeds; i++)\n\t\tunregister_dvb(&c8sectpfe->demux[i]);\n\n\tdvb_unregister_adapter(&c8sectpfe->adapter);\n\n\tkfree(c8sectpfe);\n};\n\nvoid c8sectpfe_tuner_unregister_frontend(struct c8sectpfe *c8sectpfe,\n\t\t\t\t\tstruct c8sectpfei *fei)\n{\n\tint n;\n\tstruct channel_info *tsin;\n\n\tfor (n = 0; n < fei->tsin_count; n++) {\n\n\t\ttsin = fei->channel_data[n];\n\n\t\tif (tsin) {\n\t\t\tif (tsin->frontend) {\n\t\t\t\tdvb_unregister_frontend(tsin->frontend);\n\t\t\t\tdvb_frontend_detach(tsin->frontend);\n\t\t\t}\n\n\t\t\ti2c_put_adapter(tsin->i2c_adapter);\n\n\t\t\tif (tsin->i2c_client) {\n\t\t\t\tmodule_put(tsin->i2c_client->dev.driver->owner);\n\t\t\t\ti2c_unregister_device(tsin->i2c_client);\n\t\t\t}\n\t\t}\n\t}\n\n\tc8sectpfe_delete(c8sectpfe);\n};\n\nint c8sectpfe_tuner_register_frontend(struct c8sectpfe **c8sectpfe,\n\t\t\t\tstruct c8sectpfei *fei,\n\t\t\t\tvoid *start_feed,\n\t\t\t\tvoid *stop_feed)\n{\n\tstruct channel_info *tsin;\n\tstruct dvb_frontend *frontend;\n\tint n, res;\n\n\t*c8sectpfe = c8sectpfe_create(fei, start_feed, stop_feed);\n\tif (!*c8sectpfe)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < fei->tsin_count; n++) {\n\t\ttsin = fei->channel_data[n];\n\n\t\tres = c8sectpfe_frontend_attach(&frontend, *c8sectpfe, tsin, n);\n\t\tif (res)\n\t\t\tgoto err;\n\n\t\tres = dvb_register_frontend(&c8sectpfe[0]->adapter, frontend);\n\t\tif (res < 0) {\n\t\t\tdev_err(fei->dev, \"dvb_register_frontend failed (%d)\\n\",\n\t\t\t\tres);\n\t\t\tgoto err;\n\t\t}\n\n\t\ttsin->frontend = frontend;\n\t}\n\n\treturn 0;\n\nerr:\n\tc8sectpfe_tuner_unregister_frontend(*c8sectpfe, fei);\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}