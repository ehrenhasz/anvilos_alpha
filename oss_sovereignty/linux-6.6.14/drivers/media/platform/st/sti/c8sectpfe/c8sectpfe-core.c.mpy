{
  "module_name": "c8sectpfe-core.c",
  "hash_id": "dc4a2f5fe7df3ee7cfcafc6bf19dfa697c88d07a0864eead17b86e37156d57f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/st/sti/c8sectpfe/c8sectpfe-core.c",
  "human_readable_source": "\n \n#include <linux/atomic.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/dvb/dmx.h>\n#include <linux/dvb/frontend.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_gpio.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/usb.h>\n#include <linux/wait.h>\n\n#include \"c8sectpfe-common.h\"\n#include \"c8sectpfe-core.h\"\n#include \"c8sectpfe-debugfs.h\"\n\n#include <media/dmxdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n#include <media/dvb_net.h>\n\n#define FIRMWARE_MEMDMA \"pti_memdma_h407.elf\"\nMODULE_FIRMWARE(FIRMWARE_MEMDMA);\n\n#define PID_TABLE_SIZE 1024\n#define POLL_MSECS 50\n\nstatic int load_c8sectpfe_fw(struct c8sectpfei *fei);\n\n#define TS_PKT_SIZE 188\n#define HEADER_SIZE (4)\n#define PACKET_SIZE (TS_PKT_SIZE+HEADER_SIZE)\n\n#define FEI_ALIGNMENT (32)\n \n#define FEI_BUFFER_SIZE (8*PACKET_SIZE*340)\n\n#define FIFO_LEN 1024\n\nstatic void c8sectpfe_timer_interrupt(struct timer_list *t)\n{\n\tstruct c8sectpfei *fei = from_timer(fei, t, timer);\n\tstruct channel_info *channel;\n\tint chan_num;\n\n\t \n\tfor (chan_num = 0; chan_num < fei->tsin_count; chan_num++) {\n\t\tchannel = fei->channel_data[chan_num];\n\n\t\t \n\t\tif (channel->irec && readl(channel->irec + DMA_PRDS_TPENABLE))\n\t\t\ttasklet_schedule(&channel->tsklet);\n\t}\n\n\tfei->timer.expires = jiffies +\tmsecs_to_jiffies(POLL_MSECS);\n\tadd_timer(&fei->timer);\n}\n\nstatic void channel_swdemux_tsklet(struct tasklet_struct *t)\n{\n\tstruct channel_info *channel = from_tasklet(channel, t, tsklet);\n\tstruct c8sectpfei *fei;\n\tunsigned long wp, rp;\n\tint pos, num_packets, n, size;\n\tu8 *buf;\n\n\tif (unlikely(!channel || !channel->irec))\n\t\treturn;\n\n\tfei = channel->fei;\n\n\twp = readl(channel->irec + DMA_PRDS_BUSWP_TP(0));\n\trp = readl(channel->irec + DMA_PRDS_BUSRP_TP(0));\n\n\tpos = rp - channel->back_buffer_busaddr;\n\n\t \n\tif (wp < rp)\n\t\twp = channel->back_buffer_busaddr + FEI_BUFFER_SIZE;\n\n\tsize = wp - rp;\n\tnum_packets = size / PACKET_SIZE;\n\n\t \n\tdma_sync_single_for_cpu(fei->dev,\n\t\t\t\trp,\n\t\t\t\tsize,\n\t\t\t\tDMA_FROM_DEVICE);\n\n\tbuf = channel->back_buffer_aligned;\n\n\tdev_dbg(fei->dev,\n\t\t\"chan=%d channel=%p num_packets = %d, buf = %p, pos = 0x%x\\n\\trp=0x%lx, wp=0x%lx\\n\",\n\t\tchannel->tsin_id, channel, num_packets, buf, pos, rp, wp);\n\n\tfor (n = 0; n < num_packets; n++) {\n\t\tdvb_dmx_swfilter_packets(\n\t\t\t&fei->c8sectpfe[0]->\n\t\t\t\tdemux[channel->demux_mapping].dvb_demux,\n\t\t\t&buf[pos], 1);\n\n\t\tpos += PACKET_SIZE;\n\t}\n\n\t \n\tif (wp == (channel->back_buffer_busaddr + FEI_BUFFER_SIZE))\n\t\twritel(channel->back_buffer_busaddr, channel->irec +\n\t\t\tDMA_PRDS_BUSRP_TP(0));\n\telse\n\t\twritel(wp, channel->irec + DMA_PRDS_BUSRP_TP(0));\n}\n\nstatic int c8sectpfe_start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *demux = dvbdmxfeed->demux;\n\tstruct stdemux *stdemux = demux->priv;\n\tstruct c8sectpfei *fei = stdemux->c8sectpfei;\n\tstruct channel_info *channel;\n\tu32 tmp;\n\tunsigned long *bitmap;\n\tint ret;\n\n\tswitch (dvbdmxfeed->type) {\n\tcase DMX_TYPE_TS:\n\t\tbreak;\n\tcase DMX_TYPE_SEC:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(fei->dev, \"%s:%d Error bailing\\n\"\n\t\t\t, __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dvbdmxfeed->type == DMX_TYPE_TS) {\n\t\tswitch (dvbdmxfeed->pes_type) {\n\t\tcase DMX_PES_VIDEO:\n\t\tcase DMX_PES_AUDIO:\n\t\tcase DMX_PES_TELETEXT:\n\t\tcase DMX_PES_PCR:\n\t\tcase DMX_PES_OTHER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(fei->dev, \"%s:%d Error bailing\\n\"\n\t\t\t\t, __func__, __LINE__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!atomic_read(&fei->fw_loaded)) {\n\t\tret = load_c8sectpfe_fw(fei);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&fei->lock);\n\n\tchannel = fei->channel_data[stdemux->tsin_index];\n\n\tbitmap = channel->pid_buffer_aligned;\n\n\t \n\tif (dvbdmxfeed->pid == 8192) {\n\t\ttmp = readl(fei->io + C8SECTPFE_IB_PID_SET(channel->tsin_id));\n\t\ttmp &= ~C8SECTPFE_PID_ENABLE;\n\t\twritel(tmp, fei->io + C8SECTPFE_IB_PID_SET(channel->tsin_id));\n\n\t} else {\n\t\tbitmap_set(bitmap, dvbdmxfeed->pid, 1);\n\t}\n\n\t \n\tdma_sync_single_for_device(fei->dev,\n\t\t\t\t\tchannel->pid_buffer_busaddr,\n\t\t\t\t\tPID_TABLE_SIZE,\n\t\t\t\t\tDMA_TO_DEVICE);\n\n\tchannel->active = 1;\n\n\tif (fei->global_feed_count == 0) {\n\t\tfei->timer.expires = jiffies +\n\t\t\tmsecs_to_jiffies(msecs_to_jiffies(POLL_MSECS));\n\n\t\tadd_timer(&fei->timer);\n\t}\n\n\tif (stdemux->running_feed_count == 0) {\n\n\t\tdev_dbg(fei->dev, \"Starting channel=%p\\n\", channel);\n\n\t\ttasklet_setup(&channel->tsklet, channel_swdemux_tsklet);\n\n\t\t \n\t\twritel(channel->fifo,\n\t\t\tfei->io + C8SECTPFE_IB_BUFF_STRT(channel->tsin_id));\n\t\twritel(channel->fifo + FIFO_LEN - 1,\n\t\t\tfei->io + C8SECTPFE_IB_BUFF_END(channel->tsin_id));\n\n\t\twritel(channel->fifo,\n\t\t\tfei->io + C8SECTPFE_IB_READ_PNT(channel->tsin_id));\n\t\twritel(channel->fifo,\n\t\t\tfei->io + C8SECTPFE_IB_WRT_PNT(channel->tsin_id));\n\n\n\t\t \n\t\twritel(channel->back_buffer_busaddr, channel->irec +\n\t\t\tDMA_PRDS_BUSBASE_TP(0));\n\n\t\ttmp = channel->back_buffer_busaddr + FEI_BUFFER_SIZE - 1;\n\t\twritel(tmp, channel->irec + DMA_PRDS_BUSTOP_TP(0));\n\n\t\twritel(channel->back_buffer_busaddr, channel->irec +\n\t\t\tDMA_PRDS_BUSWP_TP(0));\n\n\t\t \n\t\twritel(C8SECTPFE_SYS_ENABLE | C8SECTPFE_SYS_RESET\n\t\t\t, fei->io + C8SECTPFE_IB_SYS(channel->tsin_id));\n\n\t\t \n\t\twritel(0x1, channel->irec + DMA_PRDS_TPENABLE);\n\n\t\tdev_dbg(fei->dev, \"%s:%d Starting DMA feed on stdemux=%p\\n\"\n\t\t\t, __func__, __LINE__, stdemux);\n\t}\n\n\tstdemux->running_feed_count++;\n\tfei->global_feed_count++;\n\n\tmutex_unlock(&fei->lock);\n\n\treturn 0;\n}\n\nstatic int c8sectpfe_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\n\tstruct dvb_demux *demux = dvbdmxfeed->demux;\n\tstruct stdemux *stdemux = demux->priv;\n\tstruct c8sectpfei *fei = stdemux->c8sectpfei;\n\tstruct channel_info *channel;\n\tint idlereq;\n\tu32 tmp;\n\tint ret;\n\tunsigned long *bitmap;\n\n\tif (!atomic_read(&fei->fw_loaded)) {\n\t\tret = load_c8sectpfe_fw(fei);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&fei->lock);\n\n\tchannel = fei->channel_data[stdemux->tsin_index];\n\n\tbitmap = channel->pid_buffer_aligned;\n\n\tif (dvbdmxfeed->pid == 8192) {\n\t\ttmp = readl(fei->io + C8SECTPFE_IB_PID_SET(channel->tsin_id));\n\t\ttmp |= C8SECTPFE_PID_ENABLE;\n\t\twritel(tmp, fei->io + C8SECTPFE_IB_PID_SET(channel->tsin_id));\n\t} else {\n\t\tbitmap_clear(bitmap, dvbdmxfeed->pid, 1);\n\t}\n\n\t \n\tdma_sync_single_for_device(fei->dev,\n\t\t\t\t\tchannel->pid_buffer_busaddr,\n\t\t\t\t\tPID_TABLE_SIZE,\n\t\t\t\t\tDMA_TO_DEVICE);\n\n\tif (--stdemux->running_feed_count == 0) {\n\n\t\tchannel = fei->channel_data[stdemux->tsin_index];\n\n\t\t \n\n\t\t \n\t\twritel(0, fei->io + C8SECTPFE_IB_SYS(channel->tsin_id));\n\n\t\t \n\t\twritel(0,  channel->irec + DMA_PRDS_TPENABLE);\n\n\t\ttasklet_disable(&channel->tsklet);\n\n\t\t \n\t\tidlereq = (1 << channel->tsin_id) | IDLEREQ;\n\t\twritel(idlereq, fei->io + DMA_IDLE_REQ);\n\n\t\t \n\t\tret = wait_for_completion_timeout(&channel->idle_completion,\n\t\t\t\t\t\tmsecs_to_jiffies(100));\n\n\t\tif (ret == 0)\n\t\t\tdev_warn(fei->dev,\n\t\t\t\t\"Timeout waiting for idle irq on tsin%d\\n\",\n\t\t\t\tchannel->tsin_id);\n\n\t\treinit_completion(&channel->idle_completion);\n\n\t\t \n\n\t\twritel(channel->back_buffer_busaddr,\n\t\t\tchannel->irec + DMA_PRDS_BUSBASE_TP(0));\n\n\t\ttmp = channel->back_buffer_busaddr + FEI_BUFFER_SIZE - 1;\n\t\twritel(tmp, channel->irec + DMA_PRDS_BUSTOP_TP(0));\n\n\t\twritel(channel->back_buffer_busaddr,\n\t\t\tchannel->irec + DMA_PRDS_BUSWP_TP(0));\n\n\t\tdev_dbg(fei->dev,\n\t\t\t\"%s:%d stopping DMA feed on stdemux=%p channel=%d\\n\",\n\t\t\t__func__, __LINE__, stdemux, channel->tsin_id);\n\n\t\t \n\t\tmemset(channel->pid_buffer_aligned, 0, PID_TABLE_SIZE);\n\n\t\t \n\t\tdma_sync_single_for_device(fei->dev,\n\t\t\t\t\tchannel->pid_buffer_busaddr,\n\t\t\t\t\tPID_TABLE_SIZE,\n\t\t\t\t\tDMA_TO_DEVICE);\n\n\t\tchannel->active = 0;\n\t}\n\n\tif (--fei->global_feed_count == 0) {\n\t\tdev_dbg(fei->dev, \"%s:%d global_feed_count=%d\\n\"\n\t\t\t, __func__, __LINE__, fei->global_feed_count);\n\n\t\tdel_timer(&fei->timer);\n\t}\n\n\tmutex_unlock(&fei->lock);\n\n\treturn 0;\n}\n\nstatic struct channel_info *find_channel(struct c8sectpfei *fei, int tsin_num)\n{\n\tint i;\n\n\tfor (i = 0; i < C8SECTPFE_MAX_TSIN_CHAN; i++) {\n\t\tif (!fei->channel_data[i])\n\t\t\tcontinue;\n\n\t\tif (fei->channel_data[i]->tsin_id == tsin_num)\n\t\t\treturn fei->channel_data[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic void c8sectpfe_getconfig(struct c8sectpfei *fei)\n{\n\tstruct c8sectpfe_hw *hw = &fei->hw_stats;\n\n\thw->num_ib = readl(fei->io + SYS_CFG_NUM_IB);\n\thw->num_mib = readl(fei->io + SYS_CFG_NUM_MIB);\n\thw->num_swts = readl(fei->io + SYS_CFG_NUM_SWTS);\n\thw->num_tsout = readl(fei->io + SYS_CFG_NUM_TSOUT);\n\thw->num_ccsc = readl(fei->io + SYS_CFG_NUM_CCSC);\n\thw->num_ram = readl(fei->io + SYS_CFG_NUM_RAM);\n\thw->num_tp = readl(fei->io + SYS_CFG_NUM_TP);\n\n\tdev_info(fei->dev, \"C8SECTPFE hw supports the following:\\n\");\n\tdev_info(fei->dev, \"Input Blocks: %d\\n\", hw->num_ib);\n\tdev_info(fei->dev, \"Merged Input Blocks: %d\\n\", hw->num_mib);\n\tdev_info(fei->dev, \"Software Transport Stream Inputs: %d\\n\"\n\t\t\t\t, hw->num_swts);\n\tdev_info(fei->dev, \"Transport Stream Output: %d\\n\", hw->num_tsout);\n\tdev_info(fei->dev, \"Cable Card Converter: %d\\n\", hw->num_ccsc);\n\tdev_info(fei->dev, \"RAMs supported by C8SECTPFE: %d\\n\", hw->num_ram);\n\tdev_info(fei->dev, \"Tango TPs supported by C8SECTPFE: %d\\n\"\n\t\t\t, hw->num_tp);\n}\n\nstatic irqreturn_t c8sectpfe_idle_irq_handler(int irq, void *priv)\n{\n\tstruct c8sectpfei *fei = priv;\n\tstruct channel_info *chan;\n\tint bit;\n\tunsigned long tmp = readl(fei->io + DMA_IDLE_REQ);\n\n\t \n\n\t \n\tfor_each_set_bit(bit, &tmp, fei->hw_stats.num_ib) {\n\n\t\tchan = find_channel(fei, bit);\n\n\t\tif (chan)\n\t\t\tcomplete(&chan->idle_completion);\n\t}\n\n\twritel(0, fei->io + DMA_IDLE_REQ);\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic void free_input_block(struct c8sectpfei *fei, struct channel_info *tsin)\n{\n\tif (!fei || !tsin)\n\t\treturn;\n\n\tif (tsin->back_buffer_busaddr)\n\t\tif (!dma_mapping_error(fei->dev, tsin->back_buffer_busaddr))\n\t\t\tdma_unmap_single(fei->dev, tsin->back_buffer_busaddr,\n\t\t\t\tFEI_BUFFER_SIZE, DMA_BIDIRECTIONAL);\n\n\tkfree(tsin->back_buffer_start);\n\n\tif (tsin->pid_buffer_busaddr)\n\t\tif (!dma_mapping_error(fei->dev, tsin->pid_buffer_busaddr))\n\t\t\tdma_unmap_single(fei->dev, tsin->pid_buffer_busaddr,\n\t\t\t\tPID_TABLE_SIZE, DMA_BIDIRECTIONAL);\n\n\tkfree(tsin->pid_buffer_start);\n}\n\n#define MAX_NAME 20\n\nstatic int configure_memdma_and_inputblock(struct c8sectpfei *fei,\n\t\t\t\tstruct channel_info *tsin)\n{\n\tint ret;\n\tu32 tmp;\n\tchar tsin_pin_name[MAX_NAME];\n\n\tif (!fei || !tsin)\n\t\treturn -EINVAL;\n\n\tdev_dbg(fei->dev, \"%s:%d Configuring channel=%p tsin=%d\\n\"\n\t\t, __func__, __LINE__, tsin, tsin->tsin_id);\n\n\tinit_completion(&tsin->idle_completion);\n\n\ttsin->back_buffer_start = kzalloc(FEI_BUFFER_SIZE + FEI_ALIGNMENT, GFP_KERNEL);\n\tif (!tsin->back_buffer_start) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unmap;\n\t}\n\n\t \n\ttsin->back_buffer_aligned = tsin->back_buffer_start + FEI_ALIGNMENT;\n\n\ttsin->back_buffer_aligned = PTR_ALIGN(tsin->back_buffer_aligned, FEI_ALIGNMENT);\n\n\ttsin->back_buffer_busaddr = dma_map_single(fei->dev,\n\t\t\t\t\ttsin->back_buffer_aligned,\n\t\t\t\t\tFEI_BUFFER_SIZE,\n\t\t\t\t\tDMA_BIDIRECTIONAL);\n\n\tif (dma_mapping_error(fei->dev, tsin->back_buffer_busaddr)) {\n\t\tdev_err(fei->dev, \"failed to map back_buffer\\n\");\n\t\tret = -EFAULT;\n\t\tgoto err_unmap;\n\t}\n\n\t \n\ttsin->pid_buffer_start = kzalloc(PID_TABLE_SIZE + PID_TABLE_SIZE, GFP_KERNEL);\n\tif (!tsin->pid_buffer_start) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unmap;\n\t}\n\n\t \n\n\ttsin->pid_buffer_aligned = tsin->pid_buffer_start + PID_TABLE_SIZE;\n\n\ttsin->pid_buffer_aligned = PTR_ALIGN(tsin->pid_buffer_aligned, PID_TABLE_SIZE);\n\n\ttsin->pid_buffer_busaddr = dma_map_single(fei->dev,\n\t\t\t\t\t\ttsin->pid_buffer_aligned,\n\t\t\t\t\t\tPID_TABLE_SIZE,\n\t\t\t\t\t\tDMA_BIDIRECTIONAL);\n\n\tif (dma_mapping_error(fei->dev, tsin->pid_buffer_busaddr)) {\n\t\tdev_err(fei->dev, \"failed to map pid_bitmap\\n\");\n\t\tret = -EFAULT;\n\t\tgoto err_unmap;\n\t}\n\n\t \n\tdma_sync_single_for_device(fei->dev,\n\t\t\t\ttsin->pid_buffer_busaddr,\n\t\t\t\tPID_TABLE_SIZE,\n\t\t\t\tDMA_TO_DEVICE);\n\n\tsnprintf(tsin_pin_name, MAX_NAME, \"tsin%d-%s\", tsin->tsin_id,\n\t\t(tsin->serial_not_parallel ? \"serial\" : \"parallel\"));\n\n\ttsin->pstate = pinctrl_lookup_state(fei->pinctrl, tsin_pin_name);\n\tif (IS_ERR(tsin->pstate)) {\n\t\tdev_err(fei->dev, \"%s: pinctrl_lookup_state couldn't find %s state\\n\"\n\t\t\t, __func__, tsin_pin_name);\n\t\tret = PTR_ERR(tsin->pstate);\n\t\tgoto err_unmap;\n\t}\n\n\tret = pinctrl_select_state(fei->pinctrl, tsin->pstate);\n\n\tif (ret) {\n\t\tdev_err(fei->dev, \"%s: pinctrl_select_state failed\\n\"\n\t\t\t, __func__);\n\t\tgoto err_unmap;\n\t}\n\n\t \n\ttmp = readl(fei->io + SYS_INPUT_CLKEN);\n\ttmp |= BIT(tsin->tsin_id);\n\twritel(tmp, fei->io + SYS_INPUT_CLKEN);\n\n\tif (tsin->serial_not_parallel)\n\t\ttmp |= C8SECTPFE_SERIAL_NOT_PARALLEL;\n\n\tif (tsin->invert_ts_clk)\n\t\ttmp |= C8SECTPFE_INVERT_TSCLK;\n\n\tif (tsin->async_not_sync)\n\t\ttmp |= C8SECTPFE_ASYNC_NOT_SYNC;\n\n\ttmp |= C8SECTPFE_ALIGN_BYTE_SOP | C8SECTPFE_BYTE_ENDIANNESS_MSB;\n\n\twritel(tmp, fei->io + C8SECTPFE_IB_IP_FMT_CFG(tsin->tsin_id));\n\n\twritel(C8SECTPFE_SYNC(0x9) |\n\t\tC8SECTPFE_DROP(0x9) |\n\t\tC8SECTPFE_TOKEN(0x47),\n\t\tfei->io + C8SECTPFE_IB_SYNCLCKDRP_CFG(tsin->tsin_id));\n\n\twritel(TS_PKT_SIZE, fei->io + C8SECTPFE_IB_PKT_LEN(tsin->tsin_id));\n\n\t \n\n\ttsin->fifo = (tsin->tsin_id * FIFO_LEN);\n\n\twritel(tsin->fifo, fei->io + C8SECTPFE_IB_BUFF_STRT(tsin->tsin_id));\n\twritel(tsin->fifo + FIFO_LEN - 1,\n\t\tfei->io + C8SECTPFE_IB_BUFF_END(tsin->tsin_id));\n\n\twritel(tsin->fifo, fei->io + C8SECTPFE_IB_READ_PNT(tsin->tsin_id));\n\twritel(tsin->fifo, fei->io + C8SECTPFE_IB_WRT_PNT(tsin->tsin_id));\n\n\twritel(tsin->pid_buffer_busaddr,\n\t\tfei->io + PIDF_BASE(tsin->tsin_id));\n\n\tdev_dbg(fei->dev, \"chan=%d PIDF_BASE=0x%x pid_bus_addr=%pad\\n\",\n\t\ttsin->tsin_id, readl(fei->io + PIDF_BASE(tsin->tsin_id)),\n\t\t&tsin->pid_buffer_busaddr);\n\n\t \n\n\t \n\ttmp = (C8SECTPFE_PID_ENABLE | C8SECTPFE_PID_NUMBITS(13)\n\t\t| C8SECTPFE_PID_OFFSET(40));\n\n\twritel(tmp, fei->io + C8SECTPFE_IB_PID_SET(tsin->tsin_id));\n\n\tdev_dbg(fei->dev, \"chan=%d setting wp: %d, rp: %d, buf: %d-%d\\n\",\n\t\ttsin->tsin_id,\n\t\treadl(fei->io + C8SECTPFE_IB_WRT_PNT(tsin->tsin_id)),\n\t\treadl(fei->io + C8SECTPFE_IB_READ_PNT(tsin->tsin_id)),\n\t\treadl(fei->io + C8SECTPFE_IB_BUFF_STRT(tsin->tsin_id)),\n\t\treadl(fei->io + C8SECTPFE_IB_BUFF_END(tsin->tsin_id)));\n\n\t \n\ttsin->irec = fei->io + DMA_MEMDMA_OFFSET + DMA_DMEM_OFFSET +\n\t\t\treadl(fei->io + DMA_PTRREC_BASE);\n\n\t \n\n\t \n\ttsin->irec += (tsin->tsin_id * DMA_PRDS_SIZE);\n\n\twritel(tsin->fifo, tsin->irec + DMA_PRDS_MEMBASE);\n\n\twritel(tsin->fifo + FIFO_LEN - 1, tsin->irec + DMA_PRDS_MEMTOP);\n\n\twritel((188 + 7)&~7, tsin->irec + DMA_PRDS_PKTSIZE);\n\n\twritel(0x1, tsin->irec + DMA_PRDS_TPENABLE);\n\n\t \n\n\twritel(tsin->back_buffer_busaddr, tsin->irec + DMA_PRDS_BUSBASE_TP(0));\n\n\ttmp = tsin->back_buffer_busaddr + FEI_BUFFER_SIZE - 1;\n\twritel(tmp, tsin->irec + DMA_PRDS_BUSTOP_TP(0));\n\n\twritel(tsin->back_buffer_busaddr, tsin->irec + DMA_PRDS_BUSWP_TP(0));\n\twritel(tsin->back_buffer_busaddr, tsin->irec + DMA_PRDS_BUSRP_TP(0));\n\n\t \n\ttasklet_setup(&tsin->tsklet, channel_swdemux_tsklet);\n\n\treturn 0;\n\nerr_unmap:\n\tfree_input_block(fei, tsin);\n\treturn ret;\n}\n\nstatic irqreturn_t c8sectpfe_error_irq_handler(int irq, void *priv)\n{\n\tstruct c8sectpfei *fei = priv;\n\n\tdev_err(fei->dev, \"%s: error handling not yet implemented\\n\"\n\t\t, __func__);\n\n\t \n\n\treturn IRQ_HANDLED;\n}\n\nstatic int c8sectpfe_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *child, *np = dev->of_node;\n\tstruct c8sectpfei *fei;\n\tstruct resource *res;\n\tint ret, index = 0;\n\tstruct channel_info *tsin;\n\n\t \n\tfei = devm_kzalloc(dev, sizeof(struct c8sectpfei), GFP_KERNEL);\n\tif (!fei)\n\t\treturn -ENOMEM;\n\n\tfei->dev = dev;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"c8sectpfe\");\n\tfei->io = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(fei->io))\n\t\treturn PTR_ERR(fei->io);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\"c8sectpfe-ram\");\n\tfei->sram = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(fei->sram))\n\t\treturn PTR_ERR(fei->sram);\n\n\tfei->sram_size = resource_size(res);\n\n\tfei->idle_irq = platform_get_irq_byname(pdev, \"c8sectpfe-idle-irq\");\n\tif (fei->idle_irq < 0)\n\t\treturn fei->idle_irq;\n\n\tfei->error_irq = platform_get_irq_byname(pdev, \"c8sectpfe-error-irq\");\n\tif (fei->error_irq < 0)\n\t\treturn fei->error_irq;\n\n\tplatform_set_drvdata(pdev, fei);\n\n\tfei->c8sectpfeclk = devm_clk_get(dev, \"c8sectpfe\");\n\tif (IS_ERR(fei->c8sectpfeclk)) {\n\t\tdev_err(dev, \"c8sectpfe clk not found\\n\");\n\t\treturn PTR_ERR(fei->c8sectpfeclk);\n\t}\n\n\tret = clk_prepare_enable(fei->c8sectpfeclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable c8sectpfe clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\twritel(0, fei->io + SYS_INPUT_CLKEN);\n\n\t \n\twritel(MEMDMAENABLE, fei->io + SYS_OTHER_CLKEN);\n\n\t \n\tmemset_io(fei->sram, 0x0, fei->sram_size);\n\n\tc8sectpfe_getconfig(fei);\n\n\tret = devm_request_irq(dev, fei->idle_irq, c8sectpfe_idle_irq_handler,\n\t\t\t0, \"c8sectpfe-idle-irq\", fei);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't register c8sectpfe-idle-irq IRQ.\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\tret = devm_request_irq(dev, fei->error_irq,\n\t\t\t\tc8sectpfe_error_irq_handler, 0,\n\t\t\t\t\"c8sectpfe-error-irq\", fei);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't register c8sectpfe-error-irq IRQ.\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\tfei->tsin_count = of_get_child_count(np);\n\n\tif (fei->tsin_count > C8SECTPFE_MAX_TSIN_CHAN ||\n\t\tfei->tsin_count > fei->hw_stats.num_ib) {\n\n\t\tdev_err(dev, \"More tsin declared than exist on SoC!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\tfei->pinctrl = devm_pinctrl_get(dev);\n\n\tif (IS_ERR(fei->pinctrl)) {\n\t\tdev_err(dev, \"Error getting tsin pins\\n\");\n\t\tret = PTR_ERR(fei->pinctrl);\n\t\tgoto err_clk_disable;\n\t}\n\n\tfor_each_child_of_node(np, child) {\n\t\tstruct device_node *i2c_bus;\n\n\t\tfei->channel_data[index] = devm_kzalloc(dev,\n\t\t\t\t\t\tsizeof(struct channel_info),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!fei->channel_data[index]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\ttsin = fei->channel_data[index];\n\n\t\ttsin->fei = fei;\n\n\t\tret = of_property_read_u32(child, \"tsin-num\", &tsin->tsin_id);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"No tsin_num found\\n\");\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\t \n\t\tif (tsin->tsin_id > fei->hw_stats.num_ib) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"tsin-num %d specified greater than number\\n\\tof input block hw in SoC! (%d)\",\n\t\t\t\ttsin->tsin_id, fei->hw_stats.num_ib);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\ttsin->invert_ts_clk = of_property_read_bool(child,\n\t\t\t\t\t\t\t\"invert-ts-clk\");\n\n\t\ttsin->serial_not_parallel = of_property_read_bool(child,\n\t\t\t\t\t\t\t\"serial-not-parallel\");\n\n\t\ttsin->async_not_sync = of_property_read_bool(child,\n\t\t\t\t\t\t\t\"async-not-sync\");\n\n\t\tret = of_property_read_u32(child, \"dvb-card\",\n\t\t\t\t\t&tsin->dvb_card);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"No dvb-card found\\n\");\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\ti2c_bus = of_parse_phandle(child, \"i2c-bus\", 0);\n\t\tif (!i2c_bus) {\n\t\t\tdev_err(&pdev->dev, \"No i2c-bus found\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_node_put;\n\t\t}\n\t\ttsin->i2c_adapter =\n\t\t\tof_find_i2c_adapter_by_node(i2c_bus);\n\t\tif (!tsin->i2c_adapter) {\n\t\t\tdev_err(&pdev->dev, \"No i2c adapter found\\n\");\n\t\t\tof_node_put(i2c_bus);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_node_put;\n\t\t}\n\t\tof_node_put(i2c_bus);\n\n\t\t \n\t\ttsin->rst_gpio = devm_fwnode_gpiod_get(dev,\n\t\t\t\t\t\t       of_fwnode_handle(child),\n\t\t\t\t\t\t       \"reset\", GPIOD_OUT_HIGH,\n\t\t\t\t\t\t       \"NIM reset\");\n\t\tret = PTR_ERR_OR_ZERO(tsin->rst_gpio);\n\t\tif (ret && ret != -EBUSY) {\n\t\t\tdev_err(dev, \"Can't request tsin%d reset gpio\\n\",\n\t\t\t\tfei->channel_data[index]->tsin_id);\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tif (!ret) {\n\t\t\t \n\t\t\tusleep_range(3500, 5000);\n\t\t\t \n\t\t\tgpiod_set_value_cansleep(tsin->rst_gpio, 0);\n\t\t\tusleep_range(3000, 5000);\n\t\t}\n\n\t\ttsin->demux_mapping = index;\n\n\t\tdev_dbg(fei->dev,\n\t\t\t\"channel=%p n=%d tsin_num=%d, invert-ts-clk=%d\\n\\tserial-not-parallel=%d pkt-clk-valid=%d dvb-card=%d\\n\",\n\t\t\tfei->channel_data[index], index,\n\t\t\ttsin->tsin_id, tsin->invert_ts_clk,\n\t\t\ttsin->serial_not_parallel, tsin->async_not_sync,\n\t\t\ttsin->dvb_card);\n\n\t\tindex++;\n\t}\n\n\t \n\ttimer_setup(&fei->timer, c8sectpfe_timer_interrupt, 0);\n\n\tmutex_init(&fei->lock);\n\n\t \n\tret = c8sectpfe_tuner_register_frontend(&fei->c8sectpfe[0],\n\t\t\t\t\t(void *)fei,\n\t\t\t\t\tc8sectpfe_start_feed,\n\t\t\t\t\tc8sectpfe_stop_feed);\n\tif (ret) {\n\t\tdev_err(dev, \"c8sectpfe_tuner_register_frontend failed (%d)\\n\",\n\t\t\tret);\n\t\tgoto err_clk_disable;\n\t}\n\n\tc8sectpfe_debugfs_init(fei);\n\n\treturn 0;\n\nerr_node_put:\n\tof_node_put(child);\nerr_clk_disable:\n\tclk_disable_unprepare(fei->c8sectpfeclk);\n\treturn ret;\n}\n\nstatic void c8sectpfe_remove(struct platform_device *pdev)\n{\n\tstruct c8sectpfei *fei = platform_get_drvdata(pdev);\n\tstruct channel_info *channel;\n\tint i;\n\n\twait_for_completion(&fei->fw_ack);\n\n\tc8sectpfe_tuner_unregister_frontend(fei->c8sectpfe[0], fei);\n\n\t \n\tfor (i = 0; i < fei->tsin_count; i++) {\n\t\tchannel = fei->channel_data[i];\n\t\tfree_input_block(fei, channel);\n\t}\n\n\tc8sectpfe_debugfs_exit(fei);\n\n\tdev_info(fei->dev, \"Stopping memdma SLIM core\\n\");\n\tif (readl(fei->io + DMA_CPU_RUN))\n\t\twritel(0x0,  fei->io + DMA_CPU_RUN);\n\n\t \n\tif (readl(fei->io + SYS_INPUT_CLKEN))\n\t\twritel(0, fei->io + SYS_INPUT_CLKEN);\n\n\tif (readl(fei->io + SYS_OTHER_CLKEN))\n\t\twritel(0, fei->io + SYS_OTHER_CLKEN);\n\n\tclk_disable_unprepare(fei->c8sectpfeclk);\n}\n\n\nstatic int configure_channels(struct c8sectpfei *fei)\n{\n\tint index = 0, ret;\n\tstruct device_node *child, *np = fei->dev->of_node;\n\n\t \n\tfor_each_child_of_node(np, child) {\n\t\tret = configure_memdma_and_inputblock(fei,\n\t\t\t\t\t\tfei->channel_data[index]);\n\t\tif (ret) {\n\t\t\tdev_err(fei->dev,\n\t\t\t\t\"configure_memdma_and_inputblock failed\\n\");\n\t\t\tof_node_put(child);\n\t\t\tgoto err_unmap;\n\t\t}\n\t\tindex++;\n\t}\n\n\treturn 0;\n\nerr_unmap:\n\twhile (--index >= 0)\n\t\tfree_input_block(fei, fei->channel_data[index]);\n\n\treturn ret;\n}\n\nstatic int\nc8sectpfe_elf_sanity_check(struct c8sectpfei *fei, const struct firmware *fw)\n{\n\tstruct elf32_hdr *ehdr;\n\tchar class;\n\n\tif (!fw) {\n\t\tdev_err(fei->dev, \"failed to load %s\\n\", FIRMWARE_MEMDMA);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fw->size < sizeof(struct elf32_hdr)) {\n\t\tdev_err(fei->dev, \"Image is too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tehdr = (struct elf32_hdr *)fw->data;\n\n\t \n\tclass = ehdr->e_ident[EI_CLASS];\n\tif (class != ELFCLASS32) {\n\t\tdev_err(fei->dev, \"Unsupported class: %d\\n\", class);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ehdr->e_ident[EI_DATA] != ELFDATA2LSB) {\n\t\tdev_err(fei->dev, \"Unsupported firmware endianness\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fw->size < ehdr->e_shoff + sizeof(struct elf32_shdr)) {\n\t\tdev_err(fei->dev, \"Image is too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(ehdr->e_ident, ELFMAG, SELFMAG)) {\n\t\tdev_err(fei->dev, \"Image is corrupted (bad magic)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tehdr = (Elf32_Ehdr *)fw->data;\n\tif (ehdr->e_ident[EI_MAG0] != ELFMAG0 ||\n\t    ehdr->e_ident[EI_MAG1] != ELFMAG1 ||\n\t    ehdr->e_ident[EI_MAG2] != ELFMAG2 ||\n\t    ehdr->e_ident[EI_MAG3] != ELFMAG3) {\n\t\tdev_err(fei->dev, \"Invalid ELF magic\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ehdr->e_type != ET_EXEC) {\n\t\tdev_err(fei->dev, \"Unsupported ELF header type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ehdr->e_phoff > fw->size) {\n\t\tdev_err(fei->dev, \"Firmware size is too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void load_imem_segment(struct c8sectpfei *fei, Elf32_Phdr *phdr,\n\t\t\tconst struct firmware *fw, u8 __iomem *dest,\n\t\t\tint seg_num)\n{\n\tconst u8 *imem_src = fw->data + phdr->p_offset;\n\tint i;\n\n\t \n\n\tdev_dbg(fei->dev,\n\t\t\"Loading IMEM segment %d 0x%08x\\n\\t (0x%x bytes) -> 0x%p (0x%x bytes)\\n\",\n\t\tseg_num, phdr->p_paddr, phdr->p_filesz, dest,\n\t\tphdr->p_memsz + phdr->p_memsz / 3);\n\n\tfor (i = 0; i < phdr->p_filesz; i++) {\n\n\t\twriteb(readb((void __iomem *)imem_src), (void __iomem *)dest);\n\n\t\t \n\t\tif (i % 3 == 2) {\n\t\t\tdest++;\n\t\t\twriteb(0x00, (void __iomem *)dest);\n\t\t}\n\n\t\tdest++;\n\t\timem_src++;\n\t}\n}\n\nstatic void load_dmem_segment(struct c8sectpfei *fei, Elf32_Phdr *phdr,\n\t\t\tconst struct firmware *fw, u8 __iomem *dst, int seg_num)\n{\n\t \n\n\tdev_dbg(fei->dev,\n\t\t\"Loading DMEM segment %d 0x%08x\\n\\t(0x%x bytes) -> 0x%p (0x%x bytes)\\n\",\n\t\tseg_num, phdr->p_paddr, phdr->p_filesz,\n\t\tdst, phdr->p_memsz);\n\n\tmemcpy((void __force *)dst, (void *)fw->data + phdr->p_offset,\n\t\tphdr->p_filesz);\n\n\tmemset((void __force *)dst + phdr->p_filesz, 0,\n\t\tphdr->p_memsz - phdr->p_filesz);\n}\n\nstatic int load_slim_core_fw(const struct firmware *fw, struct c8sectpfei *fei)\n{\n\tElf32_Ehdr *ehdr;\n\tElf32_Phdr *phdr;\n\tu8 __iomem *dst;\n\tint err = 0, i;\n\n\tif (!fw || !fei)\n\t\treturn -EINVAL;\n\n\tehdr = (Elf32_Ehdr *)fw->data;\n\tphdr = (Elf32_Phdr *)(fw->data + ehdr->e_phoff);\n\n\t \n\tfor (i = 0; i < ehdr->e_phnum; i++, phdr++) {\n\n\t\t \n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (phdr->p_offset + phdr->p_filesz > fw->size) {\n\t\t\tdev_err(fei->dev,\n\t\t\t\t\"Segment %d is outside of firmware file\\n\", i);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tif (phdr->p_flags & PF_X) {\n\t\t\tdst = (u8 __iomem *) fei->io + DMA_MEMDMA_IMEM;\n\t\t\t \n\t\t\tdst += (phdr->p_paddr & 0xFFFFF) * sizeof(unsigned int);\n\t\t\tload_imem_segment(fei, phdr, fw, dst, i);\n\t\t} else {\n\t\t\tdst = (u8 __iomem *) fei->io + DMA_MEMDMA_DMEM;\n\t\t\t \n\t\t\tdst += (phdr->p_paddr & 0xFFFFF) * sizeof(unsigned int);\n\t\t\tload_dmem_segment(fei, phdr, fw, dst, i);\n\t\t}\n\t}\n\n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic int load_c8sectpfe_fw(struct c8sectpfei *fei)\n{\n\tconst struct firmware *fw;\n\tint err;\n\n\tdev_info(fei->dev, \"Loading firmware: %s\\n\", FIRMWARE_MEMDMA);\n\n\terr = request_firmware(&fw, FIRMWARE_MEMDMA, fei->dev);\n\tif (err)\n\t\treturn err;\n\n\terr = c8sectpfe_elf_sanity_check(fei, fw);\n\tif (err) {\n\t\tdev_err(fei->dev, \"c8sectpfe_elf_sanity_check failed err=(%d)\\n\"\n\t\t\t, err);\n\t\trelease_firmware(fw);\n\t\treturn err;\n\t}\n\n\terr = load_slim_core_fw(fw, fei);\n\tif (err) {\n\t\tdev_err(fei->dev, \"load_slim_core_fw failed err=(%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = configure_channels(fei);\n\tif (err) {\n\t\tdev_err(fei->dev, \"configure_channels failed err=(%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\twritel(0x1, fei->io + DMA_PER_STBUS_SYNC);\n\n\tdev_info(fei->dev, \"Boot the memdma SLIM core\\n\");\n\twritel(0x1,  fei->io + DMA_CPU_RUN);\n\n\tatomic_set(&fei->fw_loaded, 1);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id c8sectpfe_match[] = {\n\t{ .compatible = \"st,stih407-c8sectpfe\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, c8sectpfe_match);\n\nstatic struct platform_driver c8sectpfe_driver = {\n\t.driver = {\n\t\t.name = \"c8sectpfe\",\n\t\t.of_match_table = c8sectpfe_match,\n\t},\n\t.probe\t= c8sectpfe_probe,\n\t.remove_new = c8sectpfe_remove,\n};\n\nmodule_platform_driver(c8sectpfe_driver);\n\nMODULE_AUTHOR(\"Peter Bennett <peter.bennett@st.com>\");\nMODULE_AUTHOR(\"Peter Griffin <peter.griffin@linaro.org>\");\nMODULE_DESCRIPTION(\"C8SECTPFE STi DVB Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}