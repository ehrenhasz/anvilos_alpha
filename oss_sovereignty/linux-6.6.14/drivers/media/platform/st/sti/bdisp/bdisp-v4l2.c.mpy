{
  "module_name": "bdisp-v4l2.c",
  "hash_id": "f66e5a9fd67121482a7e487e6340f5876695569d19eb354dfe2d63a307295fa7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/st/sti/bdisp/bdisp-v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"bdisp.h\"\n\n#define BDISP_MAX_CTRL_NUM      10\n\n#define BDISP_WORK_TIMEOUT      ((100 * HZ) / 1000)\n\n \n#define BDISP_PARAMS            BIT(0)  \n#define BDISP_SRC_FMT           BIT(1)  \n#define BDISP_DST_FMT           BIT(2)  \n#define BDISP_CTX_STOP_REQ      BIT(3)  \n#define BDISP_CTX_ABORT         BIT(4)  \n\n#define BDISP_MIN_W             1\n#define BDISP_MAX_W             8191\n#define BDISP_MIN_H             1\n#define BDISP_MAX_H             8191\n\n#define fh_to_ctx(__fh) container_of(__fh, struct bdisp_ctx, fh)\n\nenum bdisp_dev_flags {\n\tST_M2M_OPEN,             \n\tST_M2M_RUNNING,          \n\tST_M2M_SUSPENDED,        \n\tST_M2M_SUSPENDING,       \n};\n\nstatic const struct bdisp_fmt bdisp_formats[] = {\n\t \n\t{\n\t\t.pixelformat    = V4L2_PIX_FMT_ABGR32,  \n\t\t.nb_planes      = 1,\n\t\t.bpp            = 32,\n\t\t.bpp_plane0     = 32,\n\t\t.w_align        = 1,\n\t\t.h_align        = 1\n\t},\n\t \n\t{\n\t\t.pixelformat    = V4L2_PIX_FMT_XBGR32,  \n\t\t.nb_planes      = 1,\n\t\t.bpp            = 32,\n\t\t.bpp_plane0     = 32,\n\t\t.w_align        = 1,\n\t\t.h_align        = 1\n\t},\n\t \n\t{\n\t\t.pixelformat    = V4L2_PIX_FMT_RGB565,\n\t\t.nb_planes      = 1,\n\t\t.bpp            = 16,\n\t\t.bpp_plane0     = 16,\n\t\t.w_align        = 1,\n\t\t.h_align        = 1\n\t},\n\t \n\t{\n\t\t.pixelformat    = V4L2_PIX_FMT_NV12,\n\t\t.nb_planes      = 2,\n\t\t.bpp            = 12,\n\t\t.bpp_plane0     = 8,\n\t\t.w_align        = 2,\n\t\t.h_align        = 2\n\t},\n\t \n\t{\n\t\t.pixelformat    = V4L2_PIX_FMT_RGB24,\n\t\t.nb_planes      = 1,\n\t\t.bpp            = 24,\n\t\t.bpp_plane0     = 24,\n\t\t.w_align        = 1,\n\t\t.h_align        = 1\n\t},\n\t \n\t{\n\t\t.pixelformat    = V4L2_PIX_FMT_YUV420,\n\t\t.nb_planes      = 3,\n\t\t.bpp            = 12,\n\t\t.bpp_plane0     = 8,\n\t\t.w_align        = 2,\n\t\t.h_align        = 2\n\t}\n};\n\n \n#define BDISP_DEF_WIDTH         1920\n#define BDISP_DEF_HEIGHT        1080\n\nstatic const struct bdisp_frame bdisp_dflt_fmt = {\n\t\t.width          = BDISP_DEF_WIDTH,\n\t\t.height         = BDISP_DEF_HEIGHT,\n\t\t.fmt            = &bdisp_formats[0],\n\t\t.field          = V4L2_FIELD_NONE,\n\t\t.bytesperline   = BDISP_DEF_WIDTH * 4,\n\t\t.sizeimage      = BDISP_DEF_WIDTH * BDISP_DEF_HEIGHT * 4,\n\t\t.colorspace     = V4L2_COLORSPACE_REC709,\n\t\t.crop           = {0, 0, BDISP_DEF_WIDTH, BDISP_DEF_HEIGHT},\n\t\t.paddr          = {0, 0, 0, 0}\n};\n\nstatic inline void bdisp_ctx_state_lock_set(u32 state, struct bdisp_ctx *ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->bdisp_dev->slock, flags);\n\tctx->state |= state;\n\tspin_unlock_irqrestore(&ctx->bdisp_dev->slock, flags);\n}\n\nstatic inline void bdisp_ctx_state_lock_clear(u32 state, struct bdisp_ctx *ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->bdisp_dev->slock, flags);\n\tctx->state &= ~state;\n\tspin_unlock_irqrestore(&ctx->bdisp_dev->slock, flags);\n}\n\nstatic inline bool bdisp_ctx_state_is_set(u32 mask, struct bdisp_ctx *ctx)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\tspin_lock_irqsave(&ctx->bdisp_dev->slock, flags);\n\tret = (ctx->state & mask) == mask;\n\tspin_unlock_irqrestore(&ctx->bdisp_dev->slock, flags);\n\n\treturn ret;\n}\n\nstatic const struct bdisp_fmt *bdisp_find_fmt(u32 pixelformat)\n{\n\tconst struct bdisp_fmt *fmt;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bdisp_formats); i++) {\n\t\tfmt = &bdisp_formats[i];\n\t\tif (fmt->pixelformat == pixelformat)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct bdisp_frame *ctx_get_frame(struct bdisp_ctx *ctx,\n\t\t\t\t\t enum v4l2_buf_type type)\n{\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\treturn &ctx->src;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn &ctx->dst;\n\tdefault:\n\t\tdev_err(ctx->bdisp_dev->dev,\n\t\t\t\"Wrong buffer/video queue type (%d)\\n\", type);\n\t\tbreak;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void bdisp_job_finish(struct bdisp_ctx *ctx, int vb_state)\n{\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\n\tif (WARN(!ctx || !ctx->fh.m2m_ctx, \"Null hardware context\\n\"))\n\t\treturn;\n\n\tdev_dbg(ctx->bdisp_dev->dev, \"%s\\n\", __func__);\n\n\tsrc_vb = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst_vb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tif (src_vb && dst_vb) {\n\t\tdst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;\n\t\tdst_vb->timecode = src_vb->timecode;\n\t\tdst_vb->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\t\tdst_vb->flags |= src_vb->flags &\n\t\t\t\t\t  V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\t\tv4l2_m2m_buf_done(src_vb, vb_state);\n\t\tv4l2_m2m_buf_done(dst_vb, vb_state);\n\n\t\tv4l2_m2m_job_finish(ctx->bdisp_dev->m2m.m2m_dev,\n\t\t\t\t    ctx->fh.m2m_ctx);\n\t}\n}\n\nstatic int bdisp_ctx_stop_req(struct bdisp_ctx *ctx)\n{\n\tstruct bdisp_ctx *curr_ctx;\n\tstruct bdisp_dev *bdisp = ctx->bdisp_dev;\n\tint ret;\n\n\tdev_dbg(ctx->bdisp_dev->dev, \"%s\\n\", __func__);\n\n\tcancel_delayed_work(&bdisp->timeout_work);\n\n\tcurr_ctx = v4l2_m2m_get_curr_priv(bdisp->m2m.m2m_dev);\n\tif (!test_bit(ST_M2M_RUNNING, &bdisp->state) || (curr_ctx != ctx))\n\t\treturn 0;\n\n\tbdisp_ctx_state_lock_set(BDISP_CTX_STOP_REQ, ctx);\n\n\tret = wait_event_timeout(bdisp->irq_queue,\n\t\t\t!bdisp_ctx_state_is_set(BDISP_CTX_STOP_REQ, ctx),\n\t\t\tBDISP_WORK_TIMEOUT);\n\n\tif (!ret) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"%s IRQ timeout\\n\", __func__);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void __bdisp_job_abort(struct bdisp_ctx *ctx)\n{\n\tint ret;\n\n\tret = bdisp_ctx_stop_req(ctx);\n\tif ((ret == -ETIMEDOUT) || (ctx->state & BDISP_CTX_ABORT)) {\n\t\tbdisp_ctx_state_lock_clear(BDISP_CTX_STOP_REQ | BDISP_CTX_ABORT,\n\t\t\t\t\t   ctx);\n\t\tbdisp_job_finish(ctx, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic void bdisp_job_abort(void *priv)\n{\n\t__bdisp_job_abort((struct bdisp_ctx *)priv);\n}\n\nstatic int bdisp_get_addr(struct bdisp_ctx *ctx, struct vb2_buffer *vb,\n\t\t\t  struct bdisp_frame *frame, dma_addr_t *paddr)\n{\n\tif (!vb || !frame)\n\t\treturn -EINVAL;\n\n\tpaddr[0] = vb2_dma_contig_plane_dma_addr(vb, 0);\n\n\tif (frame->fmt->nb_planes > 1)\n\t\t \n\t\tpaddr[1] = (dma_addr_t)(paddr[0] +\n\t\t\t\tframe->bytesperline * frame->height);\n\n\tif (frame->fmt->nb_planes > 2)\n\t\t \n\t\tpaddr[2] = (dma_addr_t)(paddr[1] +\n\t\t\t\t(frame->bytesperline * frame->height) / 4);\n\n\tif (frame->fmt->nb_planes > 3)\n\t\tdev_dbg(ctx->bdisp_dev->dev, \"ignoring some planes\\n\");\n\n\tdev_dbg(ctx->bdisp_dev->dev,\n\t\t\"%s plane[0]=%pad plane[1]=%pad plane[2]=%pad\\n\",\n\t\t__func__, &paddr[0], &paddr[1], &paddr[2]);\n\n\treturn 0;\n}\n\nstatic int bdisp_get_bufs(struct bdisp_ctx *ctx)\n{\n\tstruct bdisp_frame *src, *dst;\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\tint ret;\n\n\tsrc = &ctx->src;\n\tdst = &ctx->dst;\n\n\tsrc_vb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tret = bdisp_get_addr(ctx, &src_vb->vb2_buf, src, src->paddr);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vb = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tret = bdisp_get_addr(ctx, &dst_vb->vb2_buf, dst, dst->paddr);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;\n\n\treturn 0;\n}\n\nstatic void bdisp_device_run(void *priv)\n{\n\tstruct bdisp_ctx *ctx = priv;\n\tstruct bdisp_dev *bdisp;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (WARN(!ctx, \"Null hardware context\\n\"))\n\t\treturn;\n\n\tbdisp = ctx->bdisp_dev;\n\tdev_dbg(bdisp->dev, \"%s\\n\", __func__);\n\tspin_lock_irqsave(&bdisp->slock, flags);\n\n\tif (bdisp->m2m.ctx != ctx) {\n\t\tdev_dbg(bdisp->dev, \"ctx updated: %p -> %p\\n\",\n\t\t\tbdisp->m2m.ctx, ctx);\n\t\tctx->state |= BDISP_PARAMS;\n\t\tbdisp->m2m.ctx = ctx;\n\t}\n\n\tif (ctx->state & BDISP_CTX_STOP_REQ) {\n\t\tctx->state &= ~BDISP_CTX_STOP_REQ;\n\t\tctx->state |= BDISP_CTX_ABORT;\n\t\twake_up(&bdisp->irq_queue);\n\t\tgoto out;\n\t}\n\n\terr = bdisp_get_bufs(ctx);\n\tif (err) {\n\t\tdev_err(bdisp->dev, \"cannot get address\\n\");\n\t\tgoto out;\n\t}\n\n\tbdisp_dbg_perf_begin(bdisp);\n\n\terr = bdisp_hw_reset(bdisp);\n\tif (err) {\n\t\tdev_err(bdisp->dev, \"could not get HW ready\\n\");\n\t\tgoto out;\n\t}\n\n\terr = bdisp_hw_update(ctx);\n\tif (err) {\n\t\tdev_err(bdisp->dev, \"could not send HW request\\n\");\n\t\tgoto out;\n\t}\n\n\tqueue_delayed_work(bdisp->work_queue, &bdisp->timeout_work,\n\t\t\t   BDISP_WORK_TIMEOUT);\n\tset_bit(ST_M2M_RUNNING, &bdisp->state);\nout:\n\tctx->state &= ~BDISP_PARAMS;\n\tspin_unlock_irqrestore(&bdisp->slock, flags);\n\tif (err)\n\t\tbdisp_job_finish(ctx, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct v4l2_m2m_ops bdisp_m2m_ops = {\n\t.device_run     = bdisp_device_run,\n\t.job_abort      = bdisp_job_abort,\n};\n\nstatic int __bdisp_s_ctrl(struct bdisp_ctx *ctx, struct v4l2_ctrl *ctrl)\n{\n\tif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tctx->hflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tctx->vflip = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ctx->bdisp_dev->dev, \"unknown control %d\\n\", ctrl->id);\n\t\treturn -EINVAL;\n\t}\n\n\tctx->state |= BDISP_PARAMS;\n\n\treturn 0;\n}\n\nstatic int bdisp_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct bdisp_ctx *ctx = container_of(ctrl->handler, struct bdisp_ctx,\n\t\t\t\t\t\tctrl_handler);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&ctx->bdisp_dev->slock, flags);\n\tret = __bdisp_s_ctrl(ctx, ctrl);\n\tspin_unlock_irqrestore(&ctx->bdisp_dev->slock, flags);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops bdisp_c_ops = {\n\t.s_ctrl = bdisp_s_ctrl,\n};\n\nstatic int bdisp_ctrls_create(struct bdisp_ctx *ctx)\n{\n\tif (ctx->ctrls_rdy)\n\t\treturn 0;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, BDISP_MAX_CTRL_NUM);\n\n\tctx->bdisp_ctrls.hflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t\t&bdisp_c_ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tctx->bdisp_ctrls.vflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t\t&bdisp_c_ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tif (ctx->ctrl_handler.error) {\n\t\tint err = ctx->ctrl_handler.error;\n\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\t\treturn err;\n\t}\n\n\tctx->ctrls_rdy = true;\n\n\treturn 0;\n}\n\nstatic void bdisp_ctrls_delete(struct bdisp_ctx *ctx)\n{\n\tif (ctx->ctrls_rdy) {\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\t\tctx->ctrls_rdy = false;\n\t}\n}\n\nstatic int bdisp_queue_setup(struct vb2_queue *vq,\n\t\t\t     unsigned int *nb_buf, unsigned int *nb_planes,\n\t\t\t     unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct bdisp_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct bdisp_frame *frame = ctx_get_frame(ctx, vq->type);\n\n\tif (IS_ERR(frame)) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"Invalid frame (%p)\\n\", frame);\n\t\treturn PTR_ERR(frame);\n\t}\n\n\tif (!frame->fmt) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"Invalid format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*nb_planes)\n\t\treturn sizes[0] < frame->sizeimage ? -EINVAL : 0;\n\n\t*nb_planes = 1;\n\tsizes[0] = frame->sizeimage;\n\n\treturn 0;\n}\n\nstatic int bdisp_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct bdisp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct bdisp_frame *frame = ctx_get_frame(ctx, vb->vb2_queue->type);\n\n\tif (IS_ERR(frame)) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"Invalid frame (%p)\\n\", frame);\n\t\treturn PTR_ERR(frame);\n\t}\n\n\tif (vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tvb2_set_plane_payload(vb, 0, frame->sizeimage);\n\n\treturn 0;\n}\n\nstatic void bdisp_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct bdisp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\t \n\tif (!vb2_get_plane_payload(vb, 0)) {\n\t\tdev_dbg(ctx->bdisp_dev->dev, \"0 data buffer, skip it\\n\");\n\t\tvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\n\t\treturn;\n\t}\n\n\tif (ctx->fh.m2m_ctx)\n\t\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int bdisp_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct bdisp_ctx *ctx = q->drv_priv;\n\tstruct vb2_v4l2_buffer *buf;\n\tint ret = pm_runtime_resume_and_get(ctx->bdisp_dev->dev);\n\n\tif (ret < 0) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"failed to set runtime PM\\n\");\n\n\t\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\t\twhile ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);\n\t\t} else {\n\t\t\twhile ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void bdisp_stop_streaming(struct vb2_queue *q)\n{\n\tstruct bdisp_ctx *ctx = q->drv_priv;\n\n\t__bdisp_job_abort(ctx);\n\n\tpm_runtime_put(ctx->bdisp_dev->dev);\n}\n\nstatic const struct vb2_ops bdisp_qops = {\n\t.queue_setup     = bdisp_queue_setup,\n\t.buf_prepare     = bdisp_buf_prepare,\n\t.buf_queue       = bdisp_buf_queue,\n\t.wait_prepare    = vb2_ops_wait_prepare,\n\t.wait_finish     = vb2_ops_wait_finish,\n\t.stop_streaming  = bdisp_stop_streaming,\n\t.start_streaming = bdisp_start_streaming,\n};\n\nstatic int queue_init(void *priv,\n\t\t      struct vb2_queue *src_vq, struct vb2_queue *dst_vq)\n{\n\tstruct bdisp_ctx *ctx = priv;\n\tint ret;\n\n\tmemset(src_vq, 0, sizeof(*src_vq));\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->ops = &bdisp_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->bdisp_dev->lock;\n\tsrc_vq->dev = ctx->bdisp_dev->v4l2_dev.dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(dst_vq, 0, sizeof(*dst_vq));\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->ops = &bdisp_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->bdisp_dev->lock;\n\tdst_vq->dev = ctx->bdisp_dev->v4l2_dev.dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int bdisp_open(struct file *file)\n{\n\tstruct bdisp_dev *bdisp = video_drvdata(file);\n\tstruct bdisp_ctx *ctx = NULL;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&bdisp->lock))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tctx->bdisp_dev = bdisp;\n\n\tif (bdisp_hw_alloc_nodes(ctx)) {\n\t\tdev_err(bdisp->dev, \"no memory for nodes\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto mem_ctx;\n\t}\n\n\tv4l2_fh_init(&ctx->fh, bdisp->m2m.vdev);\n\n\tret = bdisp_ctrls_create(ctx);\n\tif (ret) {\n\t\tdev_err(bdisp->dev, \"Failed to create control\\n\");\n\t\tgoto error_fh;\n\t}\n\n\t \n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\t \n\tctx->src = bdisp_dflt_fmt;\n\tctx->dst = bdisp_dflt_fmt;\n\n\t \n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(bdisp->m2m.m2m_dev, ctx,\n\t\t\t\t\t    queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tdev_err(bdisp->dev, \"Failed to initialize m2m context\\n\");\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto error_ctrls;\n\t}\n\n\tbdisp->m2m.refcnt++;\n\tset_bit(ST_M2M_OPEN, &bdisp->state);\n\n\tdev_dbg(bdisp->dev, \"driver opened, ctx = 0x%p\\n\", ctx);\n\n\tmutex_unlock(&bdisp->lock);\n\n\treturn 0;\n\nerror_ctrls:\n\tbdisp_ctrls_delete(ctx);\n\tv4l2_fh_del(&ctx->fh);\nerror_fh:\n\tv4l2_fh_exit(&ctx->fh);\n\tbdisp_hw_free_nodes(ctx);\nmem_ctx:\n\tkfree(ctx);\nunlock:\n\tmutex_unlock(&bdisp->lock);\n\n\treturn ret;\n}\n\nstatic int bdisp_release(struct file *file)\n{\n\tstruct bdisp_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct bdisp_dev *bdisp = ctx->bdisp_dev;\n\n\tdev_dbg(bdisp->dev, \"%s\\n\", __func__);\n\n\tmutex_lock(&bdisp->lock);\n\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\n\tbdisp_ctrls_delete(ctx);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\n\tif (--bdisp->m2m.refcnt <= 0)\n\t\tclear_bit(ST_M2M_OPEN, &bdisp->state);\n\n\tbdisp_hw_free_nodes(ctx);\n\n\tkfree(ctx);\n\n\tmutex_unlock(&bdisp->lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations bdisp_fops = {\n\t.owner          = THIS_MODULE,\n\t.open           = bdisp_open,\n\t.release        = bdisp_release,\n\t.poll           = v4l2_m2m_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap           = v4l2_m2m_fop_mmap,\n};\n\nstatic int bdisp_querycap(struct file *file, void *fh,\n\t\t\t  struct v4l2_capability *cap)\n{\n\tstruct bdisp_ctx *ctx = fh_to_ctx(fh);\n\tstruct bdisp_dev *bdisp = ctx->bdisp_dev;\n\n\tstrscpy(cap->driver, bdisp->pdev->name, sizeof(cap->driver));\n\tstrscpy(cap->card, bdisp->pdev->name, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"platform:%s%d\",\n\t\t BDISP_NAME, bdisp->id);\n\treturn 0;\n}\n\nstatic int bdisp_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tstruct bdisp_ctx *ctx = fh_to_ctx(fh);\n\tconst struct bdisp_fmt *fmt;\n\n\tif (f->index >= ARRAY_SIZE(bdisp_formats))\n\t\treturn -EINVAL;\n\n\tfmt = &bdisp_formats[f->index];\n\n\tif ((fmt->pixelformat == V4L2_PIX_FMT_YUV420) &&\n\t    (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)) {\n\t\tdev_dbg(ctx->bdisp_dev->dev, \"No YU12 on capture\\n\");\n\t\treturn -EINVAL;\n\t}\n\tf->pixelformat = fmt->pixelformat;\n\n\treturn 0;\n}\n\nstatic int bdisp_g_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct bdisp_ctx *ctx = fh_to_ctx(fh);\n\tstruct v4l2_pix_format *pix;\n\tstruct bdisp_frame *frame  = ctx_get_frame(ctx, f->type);\n\n\tif (IS_ERR(frame)) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"Invalid frame (%p)\\n\", frame);\n\t\treturn PTR_ERR(frame);\n\t}\n\n\tpix = &f->fmt.pix;\n\tpix->width = frame->width;\n\tpix->height = frame->height;\n\tpix->pixelformat = frame->fmt->pixelformat;\n\tpix->field = frame->field;\n\tpix->bytesperline = frame->bytesperline;\n\tpix->sizeimage = frame->sizeimage;\n\tpix->colorspace = (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?\n\t\t\t\tframe->colorspace : bdisp_dflt_fmt.colorspace;\n\n\treturn 0;\n}\n\nstatic int bdisp_try_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct bdisp_ctx *ctx = fh_to_ctx(fh);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tconst struct bdisp_fmt *format;\n\tu32 in_w, in_h;\n\n\tformat = bdisp_find_fmt(pix->pixelformat);\n\tif (!format) {\n\t\tdev_dbg(ctx->bdisp_dev->dev, \"Unknown format 0x%x\\n\",\n\t\t\tpix->pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((format->pixelformat == V4L2_PIX_FMT_YUV420) &&\n\t    (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)) {\n\t\tdev_dbg(ctx->bdisp_dev->dev, \"No YU12 on capture\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ||\n\t    (pix->field != V4L2_FIELD_INTERLACED))\n\t\tpix->field = V4L2_FIELD_NONE;\n\n\t \n\tin_w = pix->width;\n\tin_h = pix->height;\n\tv4l_bound_align_image(&pix->width,\n\t\t\t      BDISP_MIN_W, BDISP_MAX_W,\n\t\t\t      ffs(format->w_align) - 1,\n\t\t\t      &pix->height,\n\t\t\t      BDISP_MIN_H, BDISP_MAX_H,\n\t\t\t      ffs(format->h_align) - 1,\n\t\t\t      0);\n\tif ((pix->width != in_w) || (pix->height != in_h))\n\t\tdev_dbg(ctx->bdisp_dev->dev,\n\t\t\t\"%s size updated: %dx%d -> %dx%d\\n\", __func__,\n\t\t\tin_w, in_h, pix->width, pix->height);\n\n\tpix->bytesperline = (pix->width * format->bpp_plane0) / 8;\n\tpix->sizeimage = (pix->width * pix->height * format->bpp) / 8;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tpix->colorspace = bdisp_dflt_fmt.colorspace;\n\n\treturn 0;\n}\n\nstatic int bdisp_s_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct bdisp_ctx *ctx = fh_to_ctx(fh);\n\tstruct vb2_queue *vq;\n\tstruct bdisp_frame *frame;\n\tstruct v4l2_pix_format *pix;\n\tint ret;\n\tu32 state;\n\n\tret = bdisp_try_fmt(file, fh, f);\n\tif (ret) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"Cannot set format\\n\");\n\t\treturn ret;\n\t}\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_streaming(vq)) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"queue (%d) busy\\n\", f->type);\n\t\treturn -EBUSY;\n\t}\n\n\tframe = (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?\n\t\t\t&ctx->src : &ctx->dst;\n\tpix = &f->fmt.pix;\n\tframe->fmt = bdisp_find_fmt(pix->pixelformat);\n\tif (!frame->fmt) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"Unknown format 0x%x\\n\",\n\t\t\tpix->pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\tframe->width = pix->width;\n\tframe->height = pix->height;\n\tframe->bytesperline = pix->bytesperline;\n\tframe->sizeimage = pix->sizeimage;\n\tframe->field = pix->field;\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tframe->colorspace = pix->colorspace;\n\n\tframe->crop.width = frame->width;\n\tframe->crop.height = frame->height;\n\tframe->crop.left = 0;\n\tframe->crop.top = 0;\n\n\tstate = BDISP_PARAMS;\n\tstate |= (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?\n\t\t\tBDISP_DST_FMT : BDISP_SRC_FMT;\n\tbdisp_ctx_state_lock_set(state, ctx);\n\n\treturn 0;\n}\n\nstatic int bdisp_g_selection(struct file *file, void *fh,\n\t\t\t     struct v4l2_selection *s)\n{\n\tstruct bdisp_frame *frame;\n\tstruct bdisp_ctx *ctx = fh_to_ctx(fh);\n\n\tframe = ctx_get_frame(ctx, s->type);\n\tif (IS_ERR(frame)) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"Invalid frame (%p)\\n\", frame);\n\t\treturn PTR_ERR(frame);\n\t}\n\n\tswitch (s->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tswitch (s->target) {\n\t\tcase V4L2_SEL_TGT_CROP:\n\t\t\t \n\t\t\ts->r = frame->crop;\n\t\t\tbreak;\n\t\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\t\t \n\t\t\ts->r.left = 0;\n\t\t\ts->r.top = 0;\n\t\t\ts->r.width = frame->width;\n\t\t\ts->r.height = frame->height;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(ctx->bdisp_dev->dev, \"Invalid target\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tswitch (s->target) {\n\t\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tcase V4L2_SEL_TGT_COMPOSE_PADDED:\n\t\t\t \n\t\t\ts->r = frame->crop;\n\t\t\tbreak;\n\t\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\t\t \n\t\t\ts->r.left = 0;\n\t\t\ts->r.top = 0;\n\t\t\ts->r.width = frame->width;\n\t\t\ts->r.height = frame->height;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(ctx->bdisp_dev->dev, \"Invalid target\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(ctx->bdisp_dev->dev, \"Invalid type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int is_rect_enclosed(struct v4l2_rect *a, struct v4l2_rect *b)\n{\n\t \n\n\tif (a->left < b->left || a->top < b->top)\n\t\treturn 0;\n\n\tif (a->left + a->width > b->left + b->width)\n\t\treturn 0;\n\n\tif (a->top + a->height > b->top + b->height)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int bdisp_s_selection(struct file *file, void *fh,\n\t\t\t     struct v4l2_selection *s)\n{\n\tstruct bdisp_frame *frame;\n\tstruct bdisp_ctx *ctx = fh_to_ctx(fh);\n\tstruct v4l2_rect *in, out;\n\tbool valid = false;\n\n\tif ((s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) &&\n\t    (s->target == V4L2_SEL_TGT_CROP))\n\t\tvalid = true;\n\n\tif ((s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\n\t    (s->target == V4L2_SEL_TGT_COMPOSE))\n\t\tvalid = true;\n\n\tif (!valid) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"Invalid type / target\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tframe = ctx_get_frame(ctx, s->type);\n\tif (IS_ERR(frame)) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"Invalid frame (%p)\\n\", frame);\n\t\treturn PTR_ERR(frame);\n\t}\n\n\tin = &s->r;\n\tout = *in;\n\n\t \n\tout.left = ALIGN(in->left, frame->fmt->w_align);\n\tout.top = ALIGN(in->top, frame->fmt->h_align);\n\n\tif ((out.left < 0) || (out.left >= frame->width) ||\n\t    (out.top < 0) || (out.top >= frame->height)) {\n\t\tdev_err(ctx->bdisp_dev->dev,\n\t\t\t\"Invalid crop: %dx%d@(%d,%d) vs frame: %dx%d\\n\",\n\t\t\tout.width, out.height, out.left, out.top,\n\t\t\tframe->width, frame->height);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tout.width = ALIGN(in->width, frame->fmt->w_align);\n\tout.height = ALIGN(in->height, frame->fmt->w_align);\n\n\tif (((out.left + out.width) > frame->width) ||\n\t    ((out.top + out.height) > frame->height)) {\n\t\tdev_err(ctx->bdisp_dev->dev,\n\t\t\t\"Invalid crop: %dx%d@(%d,%d) vs frame: %dx%d\\n\",\n\t\t\tout.width, out.height, out.left, out.top,\n\t\t\tframe->width, frame->height);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (s->flags & V4L2_SEL_FLAG_LE && !is_rect_enclosed(&out, in))\n\t\treturn -ERANGE;\n\n\tif (s->flags & V4L2_SEL_FLAG_GE && !is_rect_enclosed(in, &out))\n\t\treturn -ERANGE;\n\n\tif ((out.left != in->left) || (out.top != in->top) ||\n\t    (out.width != in->width) || (out.height != in->height)) {\n\t\tdev_dbg(ctx->bdisp_dev->dev,\n\t\t\t\"%s crop updated: %dx%d@(%d,%d) -> %dx%d@(%d,%d)\\n\",\n\t\t\t__func__, in->width, in->height, in->left, in->top,\n\t\t\tout.width, out.height, out.left, out.top);\n\t\t*in = out;\n\t}\n\n\tframe->crop = out;\n\n\tbdisp_ctx_state_lock_set(BDISP_PARAMS, ctx);\n\n\treturn 0;\n}\n\nstatic int bdisp_streamon(struct file *file, void *fh, enum v4l2_buf_type type)\n{\n\tstruct bdisp_ctx *ctx = fh_to_ctx(fh);\n\n\tif ((type == V4L2_BUF_TYPE_VIDEO_OUTPUT) &&\n\t    !bdisp_ctx_state_is_set(BDISP_SRC_FMT, ctx)) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"src not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((type == V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\n\t    !bdisp_ctx_state_is_set(BDISP_DST_FMT, ctx)) {\n\t\tdev_err(ctx->bdisp_dev->dev, \"dst not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn v4l2_m2m_streamon(file, ctx->fh.m2m_ctx, type);\n}\n\nstatic const struct v4l2_ioctl_ops bdisp_ioctl_ops = {\n\t.vidioc_querycap                = bdisp_querycap,\n\t.vidioc_enum_fmt_vid_cap        = bdisp_enum_fmt,\n\t.vidioc_enum_fmt_vid_out        = bdisp_enum_fmt,\n\t.vidioc_g_fmt_vid_cap           = bdisp_g_fmt,\n\t.vidioc_g_fmt_vid_out           = bdisp_g_fmt,\n\t.vidioc_try_fmt_vid_cap         = bdisp_try_fmt,\n\t.vidioc_try_fmt_vid_out         = bdisp_try_fmt,\n\t.vidioc_s_fmt_vid_cap           = bdisp_s_fmt,\n\t.vidioc_s_fmt_vid_out           = bdisp_s_fmt,\n\t.vidioc_g_selection\t\t= bdisp_g_selection,\n\t.vidioc_s_selection\t\t= bdisp_s_selection,\n\t.vidioc_reqbufs                 = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_create_bufs             = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf                  = v4l2_m2m_ioctl_expbuf,\n\t.vidioc_querybuf                = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf                    = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf                   = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_streamon                = bdisp_streamon,\n\t.vidioc_streamoff               = v4l2_m2m_ioctl_streamoff,\n\t.vidioc_subscribe_event         = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event       = v4l2_event_unsubscribe,\n};\n\nstatic int bdisp_register_device(struct bdisp_dev *bdisp)\n{\n\tint ret;\n\n\tif (!bdisp)\n\t\treturn -ENODEV;\n\n\tbdisp->vdev.fops        = &bdisp_fops;\n\tbdisp->vdev.ioctl_ops   = &bdisp_ioctl_ops;\n\tbdisp->vdev.release     = video_device_release_empty;\n\tbdisp->vdev.lock        = &bdisp->lock;\n\tbdisp->vdev.vfl_dir     = VFL_DIR_M2M;\n\tbdisp->vdev.v4l2_dev    = &bdisp->v4l2_dev;\n\tbdisp->vdev.device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M;\n\tsnprintf(bdisp->vdev.name, sizeof(bdisp->vdev.name), \"%s.%d\",\n\t\t BDISP_NAME, bdisp->id);\n\n\tvideo_set_drvdata(&bdisp->vdev, bdisp);\n\n\tbdisp->m2m.vdev = &bdisp->vdev;\n\tbdisp->m2m.m2m_dev = v4l2_m2m_init(&bdisp_m2m_ops);\n\tif (IS_ERR(bdisp->m2m.m2m_dev)) {\n\t\tdev_err(bdisp->dev, \"failed to initialize v4l2-m2m device\\n\");\n\t\treturn PTR_ERR(bdisp->m2m.m2m_dev);\n\t}\n\n\tret = video_register_device(&bdisp->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(bdisp->dev,\n\t\t\t\"%s(): failed to register video device\\n\", __func__);\n\t\tv4l2_m2m_release(bdisp->m2m.m2m_dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void bdisp_unregister_device(struct bdisp_dev *bdisp)\n{\n\tif (!bdisp)\n\t\treturn;\n\n\tif (bdisp->m2m.m2m_dev)\n\t\tv4l2_m2m_release(bdisp->m2m.m2m_dev);\n\n\tvideo_unregister_device(bdisp->m2m.vdev);\n}\n\nstatic irqreturn_t bdisp_irq_thread(int irq, void *priv)\n{\n\tstruct bdisp_dev *bdisp = priv;\n\tstruct bdisp_ctx *ctx;\n\n\tspin_lock(&bdisp->slock);\n\n\tbdisp_dbg_perf_end(bdisp);\n\n\tcancel_delayed_work(&bdisp->timeout_work);\n\n\tif (!test_and_clear_bit(ST_M2M_RUNNING, &bdisp->state))\n\t\tgoto isr_unlock;\n\n\tif (test_and_clear_bit(ST_M2M_SUSPENDING, &bdisp->state)) {\n\t\tset_bit(ST_M2M_SUSPENDED, &bdisp->state);\n\t\twake_up(&bdisp->irq_queue);\n\t\tgoto isr_unlock;\n\t}\n\n\tctx = v4l2_m2m_get_curr_priv(bdisp->m2m.m2m_dev);\n\tif (!ctx || !ctx->fh.m2m_ctx)\n\t\tgoto isr_unlock;\n\n\tspin_unlock(&bdisp->slock);\n\n\tbdisp_job_finish(ctx, VB2_BUF_STATE_DONE);\n\n\tif (bdisp_ctx_state_is_set(BDISP_CTX_STOP_REQ, ctx)) {\n\t\tbdisp_ctx_state_lock_clear(BDISP_CTX_STOP_REQ, ctx);\n\t\twake_up(&bdisp->irq_queue);\n\t}\n\n\treturn IRQ_HANDLED;\n\nisr_unlock:\n\tspin_unlock(&bdisp->slock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t bdisp_irq_handler(int irq, void *priv)\n{\n\tif (bdisp_hw_get_and_clear_irq((struct bdisp_dev *)priv))\n\t\treturn IRQ_NONE;\n\telse\n\t\treturn IRQ_WAKE_THREAD;\n}\n\nstatic void bdisp_irq_timeout(struct work_struct *ptr)\n{\n\tstruct delayed_work *twork = to_delayed_work(ptr);\n\tstruct bdisp_dev *bdisp = container_of(twork, struct bdisp_dev,\n\t\t\ttimeout_work);\n\tstruct bdisp_ctx *ctx;\n\n\tctx = v4l2_m2m_get_curr_priv(bdisp->m2m.m2m_dev);\n\n\tdev_err(ctx->bdisp_dev->dev, \"Device work timeout\\n\");\n\n\tspin_lock(&bdisp->slock);\n\tclear_bit(ST_M2M_RUNNING, &bdisp->state);\n\tspin_unlock(&bdisp->slock);\n\n\tbdisp_hw_reset(bdisp);\n\n\tbdisp_job_finish(ctx, VB2_BUF_STATE_ERROR);\n}\n\nstatic int bdisp_m2m_suspend(struct bdisp_dev *bdisp)\n{\n\tunsigned long flags;\n\tint timeout;\n\n\tspin_lock_irqsave(&bdisp->slock, flags);\n\tif (!test_bit(ST_M2M_RUNNING, &bdisp->state)) {\n\t\tspin_unlock_irqrestore(&bdisp->slock, flags);\n\t\treturn 0;\n\t}\n\tclear_bit(ST_M2M_SUSPENDED, &bdisp->state);\n\tset_bit(ST_M2M_SUSPENDING, &bdisp->state);\n\tspin_unlock_irqrestore(&bdisp->slock, flags);\n\n\ttimeout = wait_event_timeout(bdisp->irq_queue,\n\t\t\t\t     test_bit(ST_M2M_SUSPENDED, &bdisp->state),\n\t\t\t\t     BDISP_WORK_TIMEOUT);\n\n\tclear_bit(ST_M2M_SUSPENDING, &bdisp->state);\n\n\tif (!timeout) {\n\t\tdev_err(bdisp->dev, \"%s IRQ timeout\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic int bdisp_m2m_resume(struct bdisp_dev *bdisp)\n{\n\tstruct bdisp_ctx *ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bdisp->slock, flags);\n\tctx = bdisp->m2m.ctx;\n\tbdisp->m2m.ctx = NULL;\n\tspin_unlock_irqrestore(&bdisp->slock, flags);\n\n\tif (test_and_clear_bit(ST_M2M_SUSPENDED, &bdisp->state))\n\t\tbdisp_job_finish(ctx, VB2_BUF_STATE_ERROR);\n\n\treturn 0;\n}\n\nstatic int bdisp_runtime_resume(struct device *dev)\n{\n\tstruct bdisp_dev *bdisp = dev_get_drvdata(dev);\n\tint ret = clk_enable(bdisp->clock);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn bdisp_m2m_resume(bdisp);\n}\n\nstatic int bdisp_runtime_suspend(struct device *dev)\n{\n\tstruct bdisp_dev *bdisp = dev_get_drvdata(dev);\n\tint ret = bdisp_m2m_suspend(bdisp);\n\n\tif (!ret)\n\t\tclk_disable(bdisp->clock);\n\n\treturn ret;\n}\n\nstatic int bdisp_resume(struct device *dev)\n{\n\tstruct bdisp_dev *bdisp = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tint opened;\n\n\tspin_lock_irqsave(&bdisp->slock, flags);\n\topened = test_bit(ST_M2M_OPEN, &bdisp->state);\n\tspin_unlock_irqrestore(&bdisp->slock, flags);\n\n\tif (!opened)\n\t\treturn 0;\n\n\tif (!pm_runtime_suspended(dev))\n\t\treturn bdisp_runtime_resume(dev);\n\n\treturn 0;\n}\n\nstatic int bdisp_suspend(struct device *dev)\n{\n\tif (!pm_runtime_suspended(dev))\n\t\treturn bdisp_runtime_suspend(dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops bdisp_pm_ops = {\n\t.suspend                = bdisp_suspend,\n\t.resume                 = bdisp_resume,\n\t.runtime_suspend        = bdisp_runtime_suspend,\n\t.runtime_resume         = bdisp_runtime_resume,\n};\n\nstatic void bdisp_remove(struct platform_device *pdev)\n{\n\tstruct bdisp_dev *bdisp = platform_get_drvdata(pdev);\n\n\tbdisp_unregister_device(bdisp);\n\n\tbdisp_hw_free_filters(bdisp->dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tbdisp_debugfs_remove(bdisp);\n\n\tv4l2_device_unregister(&bdisp->v4l2_dev);\n\n\tif (!IS_ERR(bdisp->clock))\n\t\tclk_unprepare(bdisp->clock);\n\n\tdestroy_workqueue(bdisp->work_queue);\n\n\tdev_dbg(&pdev->dev, \"%s driver unloaded\\n\", pdev->name);\n}\n\nstatic int bdisp_probe(struct platform_device *pdev)\n{\n\tstruct bdisp_dev *bdisp;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tbdisp = devm_kzalloc(dev, sizeof(struct bdisp_dev), GFP_KERNEL);\n\tif (!bdisp)\n\t\treturn -ENOMEM;\n\n\tret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tbdisp->pdev = pdev;\n\tbdisp->dev = dev;\n\tplatform_set_drvdata(pdev, bdisp);\n\n\tif (dev->of_node)\n\t\tbdisp->id = of_alias_get_id(pdev->dev.of_node, BDISP_NAME);\n\telse\n\t\tbdisp->id = pdev->id;\n\n\tinit_waitqueue_head(&bdisp->irq_queue);\n\tINIT_DELAYED_WORK(&bdisp->timeout_work, bdisp_irq_timeout);\n\tbdisp->work_queue = create_workqueue(BDISP_NAME);\n\tif (!bdisp->work_queue)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&bdisp->slock);\n\tmutex_init(&bdisp->lock);\n\n\t \n\tbdisp->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(bdisp->regs)) {\n\t\tret = PTR_ERR(bdisp->regs);\n\t\tgoto err_wq;\n\t}\n\n\tbdisp->clock = devm_clk_get(dev, BDISP_NAME);\n\tif (IS_ERR(bdisp->clock)) {\n\t\tdev_err(dev, \"failed to get clock\\n\");\n\t\tret = PTR_ERR(bdisp->clock);\n\t\tgoto err_wq;\n\t}\n\n\tret = clk_prepare(bdisp->clock);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"clock prepare failed\\n\");\n\t\tbdisp->clock = ERR_PTR(-EINVAL);\n\t\tgoto err_wq;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_clk;\n\n\tret = devm_request_threaded_irq(dev, ret, bdisp_irq_handler,\n\t\t\t\t\tbdisp_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\tpdev->name, bdisp);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to install irq\\n\");\n\t\tgoto err_clk;\n\t}\n\n\t \n\tret = v4l2_device_register(dev, &bdisp->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register\\n\");\n\t\tgoto err_clk;\n\t}\n\n\t \n\tbdisp_debugfs_create(bdisp);\n\n\t \n\tpm_runtime_enable(dev);\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to set PM\\n\");\n\t\tgoto err_remove;\n\t}\n\n\t \n\tif (bdisp_hw_alloc_filters(bdisp->dev)) {\n\t\tdev_err(bdisp->dev, \"no memory for filters\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_pm;\n\t}\n\n\t \n\tret = bdisp_register_device(bdisp);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register\\n\");\n\t\tgoto err_filter;\n\t}\n\n\tdev_info(dev, \"%s%d registered as /dev/video%d\\n\", BDISP_NAME,\n\t\t bdisp->id, bdisp->vdev.num);\n\n\tpm_runtime_put(dev);\n\n\treturn 0;\n\nerr_filter:\n\tbdisp_hw_free_filters(bdisp->dev);\nerr_pm:\n\tpm_runtime_put(dev);\nerr_remove:\n\tpm_runtime_disable(dev);\n\tbdisp_debugfs_remove(bdisp);\n\tv4l2_device_unregister(&bdisp->v4l2_dev);\nerr_clk:\n\tclk_unprepare(bdisp->clock);\nerr_wq:\n\tdestroy_workqueue(bdisp->work_queue);\n\treturn ret;\n}\n\nstatic const struct of_device_id bdisp_match_types[] = {\n\t{\n\t\t.compatible = \"st,stih407-bdisp\",\n\t},\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, bdisp_match_types);\n\nstatic struct platform_driver bdisp_driver = {\n\t.probe          = bdisp_probe,\n\t.remove_new     = bdisp_remove,\n\t.driver         = {\n\t\t.name           = BDISP_NAME,\n\t\t.of_match_table = bdisp_match_types,\n\t\t.pm             = &bdisp_pm_ops,\n\t},\n};\n\nmodule_platform_driver(bdisp_driver);\n\nMODULE_DESCRIPTION(\"2D blitter for STMicroelectronics SoC\");\nMODULE_AUTHOR(\"Fabien Dessenne <fabien.dessenne@st.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}