{
  "module_name": "hva-hw.c",
  "hash_id": "47cd9105849682d40215af4bca1bbba56f7a8121a53b6a57e08cf2bfd1e04b53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/st/sti/hva/hva-hw.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\n#include <linux/seq_file.h>\n#endif\n\n#include \"hva.h\"\n#include \"hva-hw.h\"\n\n \n#define HVA_HIF_REG_RST                 0x0100U\n#define HVA_HIF_REG_RST_ACK             0x0104U\n#define HVA_HIF_REG_MIF_CFG             0x0108U\n#define HVA_HIF_REG_HEC_MIF_CFG         0x010CU\n#define HVA_HIF_REG_CFL                 0x0110U\n#define HVA_HIF_FIFO_CMD                0x0114U\n#define HVA_HIF_FIFO_STS                0x0118U\n#define HVA_HIF_REG_SFL                 0x011CU\n#define HVA_HIF_REG_IT_ACK              0x0120U\n#define HVA_HIF_REG_ERR_IT_ACK          0x0124U\n#define HVA_HIF_REG_LMI_ERR             0x0128U\n#define HVA_HIF_REG_EMI_ERR             0x012CU\n#define HVA_HIF_REG_HEC_MIF_ERR         0x0130U\n#define HVA_HIF_REG_HEC_STS             0x0134U\n#define HVA_HIF_REG_HVC_STS             0x0138U\n#define HVA_HIF_REG_HJE_STS             0x013CU\n#define HVA_HIF_REG_CNT                 0x0140U\n#define HVA_HIF_REG_HEC_CHKSYN_DIS      0x0144U\n#define HVA_HIF_REG_CLK_GATING          0x0148U\n#define HVA_HIF_REG_VERSION             0x014CU\n#define HVA_HIF_REG_BSM                 0x0150U\n\n \n#define VERSION_ID_MASK\t0x0000FFFF\n\n \n#define BSM_CFG_VAL1\t0x0003F000\n#define BSM_CFG_VAL2\t0x003F0000\n\n \n#define MIF_CFG_VAL1\t0x04460446\n#define MIF_CFG_VAL2\t0x04460806\n#define MIF_CFG_VAL3\t0x00000000\n\n \n#define HEC_MIF_CFG_VAL\t0x000000C4\n\n \n#define CLK_GATING_HVC\tBIT(0)\n#define CLK_GATING_HEC\tBIT(1)\n#define CLK_GATING_HJE\tBIT(2)\n\n \n#define CLK_RATE\t\t300000000\n\n \n#define AUTOSUSPEND_DELAY_MS\t3\n\n \nenum hva_hw_error {\n\tNO_ERROR = 0x0,\n\tH264_BITSTREAM_OVERSIZE = 0x2,\n\tH264_FRAME_SKIPPED = 0x4,\n\tH264_SLICE_LIMIT_SIZE = 0x5,\n\tH264_MAX_SLICE_NUMBER = 0x7,\n\tH264_SLICE_READY = 0x8,\n\tTASK_LIST_FULL = 0xF0,\n\tUNKNOWN_COMMAND = 0xF1,\n\tWRONG_CODEC_OR_RESOLUTION = 0xF4,\n\tNO_INT_COMPLETION = 0x100,\n\tLMI_ERR = 0x101,\n\tEMI_ERR = 0x102,\n\tHECMI_ERR = 0x103,\n};\n\nstatic irqreturn_t hva_hw_its_interrupt(int irq, void *data)\n{\n\tstruct hva_dev *hva = data;\n\n\t \n\thva->sts_reg = readl_relaxed(hva->regs + HVA_HIF_FIFO_STS);\n\thva->sfl_reg = readl_relaxed(hva->regs + HVA_HIF_REG_SFL);\n\n\t \n\twritel_relaxed(0x1, hva->regs + HVA_HIF_REG_IT_ACK);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t hva_hw_its_irq_thread(int irq, void *arg)\n{\n\tstruct hva_dev *hva = arg;\n\tstruct device *dev = hva_to_dev(hva);\n\tu32 status = hva->sts_reg & 0xFF;\n\tu8 ctx_id = 0;\n\tstruct hva_ctx *ctx = NULL;\n\n\tdev_dbg(dev, \"%s     %s: status: 0x%02x fifo level: 0x%02x\\n\",\n\t\tHVA_PREFIX, __func__, hva->sts_reg & 0xFF, hva->sfl_reg & 0xF);\n\n\t \n\tctx_id = (hva->sts_reg & 0xFF00) >> 8;\n\tif (ctx_id >= HVA_MAX_INSTANCES) {\n\t\tdev_err(dev, \"%s     %s: bad context identifier: %d\\n\",\n\t\t\tHVA_PREFIX, __func__, ctx_id);\n\t\tgoto out;\n\t}\n\n\tctx = hva->instances[ctx_id];\n\tif (!ctx)\n\t\tgoto out;\n\n\tswitch (status) {\n\tcase NO_ERROR:\n\t\tdev_dbg(dev, \"%s     %s: no error\\n\",\n\t\t\tctx->name, __func__);\n\t\tctx->hw_err = false;\n\t\tbreak;\n\tcase H264_SLICE_READY:\n\t\tdev_dbg(dev, \"%s     %s: h264 slice ready\\n\",\n\t\t\tctx->name, __func__);\n\t\tctx->hw_err = false;\n\t\tbreak;\n\tcase H264_FRAME_SKIPPED:\n\t\tdev_dbg(dev, \"%s     %s: h264 frame skipped\\n\",\n\t\t\tctx->name, __func__);\n\t\tctx->hw_err = false;\n\t\tbreak;\n\tcase H264_BITSTREAM_OVERSIZE:\n\t\tdev_err(dev, \"%s     %s:h264 bitstream oversize\\n\",\n\t\t\tctx->name, __func__);\n\t\tctx->hw_err = true;\n\t\tbreak;\n\tcase H264_SLICE_LIMIT_SIZE:\n\t\tdev_err(dev, \"%s     %s: h264 slice limit size is reached\\n\",\n\t\t\tctx->name, __func__);\n\t\tctx->hw_err = true;\n\t\tbreak;\n\tcase H264_MAX_SLICE_NUMBER:\n\t\tdev_err(dev, \"%s     %s: h264 max slice number is reached\\n\",\n\t\t\tctx->name, __func__);\n\t\tctx->hw_err = true;\n\t\tbreak;\n\tcase TASK_LIST_FULL:\n\t\tdev_err(dev, \"%s     %s:task list full\\n\",\n\t\t\tctx->name, __func__);\n\t\tctx->hw_err = true;\n\t\tbreak;\n\tcase UNKNOWN_COMMAND:\n\t\tdev_err(dev, \"%s     %s: command not known\\n\",\n\t\t\tctx->name, __func__);\n\t\tctx->hw_err = true;\n\t\tbreak;\n\tcase WRONG_CODEC_OR_RESOLUTION:\n\t\tdev_err(dev, \"%s     %s: wrong codec or resolution\\n\",\n\t\t\tctx->name, __func__);\n\t\tctx->hw_err = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s     %s: status not recognized\\n\",\n\t\t\tctx->name, __func__);\n\t\tctx->hw_err = true;\n\t\tbreak;\n\t}\nout:\n\tcomplete(&hva->interrupt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t hva_hw_err_interrupt(int irq, void *data)\n{\n\tstruct hva_dev *hva = data;\n\n\t \n\thva->sts_reg = readl_relaxed(hva->regs + HVA_HIF_FIFO_STS);\n\thva->sfl_reg = readl_relaxed(hva->regs + HVA_HIF_REG_SFL);\n\n\t \n\thva->lmi_err_reg = readl_relaxed(hva->regs + HVA_HIF_REG_LMI_ERR);\n\thva->emi_err_reg = readl_relaxed(hva->regs + HVA_HIF_REG_EMI_ERR);\n\thva->hec_mif_err_reg = readl_relaxed(hva->regs +\n\t\t\t\t\t     HVA_HIF_REG_HEC_MIF_ERR);\n\n\t \n\twritel_relaxed(0x1, hva->regs + HVA_HIF_REG_IT_ACK);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t hva_hw_err_irq_thread(int irq, void *arg)\n{\n\tstruct hva_dev *hva = arg;\n\tstruct device *dev = hva_to_dev(hva);\n\tu8 ctx_id = 0;\n\tstruct hva_ctx *ctx;\n\n\tdev_dbg(dev, \"%s     status: 0x%02x fifo level: 0x%02x\\n\",\n\t\tHVA_PREFIX, hva->sts_reg & 0xFF, hva->sfl_reg & 0xF);\n\n\t \n\tctx_id = (hva->sts_reg & 0xFF00) >> 8;\n\tif (ctx_id >= HVA_MAX_INSTANCES) {\n\t\tdev_err(dev, \"%s     bad context identifier: %d\\n\", HVA_PREFIX,\n\t\t\tctx_id);\n\t\tgoto out;\n\t}\n\n\tctx = hva->instances[ctx_id];\n\tif (!ctx)\n\t\tgoto out;\n\n\tif (hva->lmi_err_reg) {\n\t\tdev_err(dev, \"%s     local memory interface error: 0x%08x\\n\",\n\t\t\tctx->name, hva->lmi_err_reg);\n\t\tctx->hw_err = true;\n\t}\n\n\tif (hva->emi_err_reg) {\n\t\tdev_err(dev, \"%s     external memory interface error: 0x%08x\\n\",\n\t\t\tctx->name, hva->emi_err_reg);\n\t\tctx->hw_err = true;\n\t}\n\n\tif (hva->hec_mif_err_reg) {\n\t\tdev_err(dev, \"%s     hec memory interface error: 0x%08x\\n\",\n\t\t\tctx->name, hva->hec_mif_err_reg);\n\t\tctx->hw_err = true;\n\t}\nout:\n\tcomplete(&hva->interrupt);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned long int hva_hw_get_ip_version(struct hva_dev *hva)\n{\n\tstruct device *dev = hva_to_dev(hva);\n\tunsigned long int version;\n\n\tif (pm_runtime_resume_and_get(dev) < 0) {\n\t\tdev_err(dev, \"%s     failed to get pm_runtime\\n\", HVA_PREFIX);\n\t\tmutex_unlock(&hva->protect_mutex);\n\t\treturn -EFAULT;\n\t}\n\n\tversion = readl_relaxed(hva->regs + HVA_HIF_REG_VERSION) &\n\t\t\t\tVERSION_ID_MASK;\n\n\tpm_runtime_put_autosuspend(dev);\n\n\tswitch (version) {\n\tcase HVA_VERSION_V400:\n\t\tdev_dbg(dev, \"%s     IP hardware version 0x%lx\\n\",\n\t\t\tHVA_PREFIX, version);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s     unknown IP hardware version 0x%lx\\n\",\n\t\t\tHVA_PREFIX, version);\n\t\tversion = HVA_VERSION_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn version;\n}\n\nint hva_hw_probe(struct platform_device *pdev, struct hva_dev *hva)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *esram;\n\tint ret;\n\n\tWARN_ON(!hva);\n\n\t \n\thva->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hva->regs)) {\n\t\tdev_err(dev, \"%s     failed to get regs\\n\", HVA_PREFIX);\n\t\treturn PTR_ERR(hva->regs);\n\t}\n\n\t \n\tesram = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!esram) {\n\t\tdev_err(dev, \"%s     failed to get esram\\n\", HVA_PREFIX);\n\t\treturn -ENODEV;\n\t}\n\thva->esram_addr = esram->start;\n\thva->esram_size = resource_size(esram);\n\n\tdev_info(dev, \"%s     esram reserved for address: 0x%x size:%d\\n\",\n\t\t HVA_PREFIX, hva->esram_addr, hva->esram_size);\n\n\t \n\thva->clk = devm_clk_get(dev, \"clk_hva\");\n\tif (IS_ERR(hva->clk)) {\n\t\tdev_err(dev, \"%s     failed to get clock\\n\", HVA_PREFIX);\n\t\treturn PTR_ERR(hva->clk);\n\t}\n\n\tret = clk_prepare(hva->clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s     failed to prepare clock\\n\", HVA_PREFIX);\n\t\thva->clk = ERR_PTR(-EINVAL);\n\t\treturn ret;\n\t}\n\n\t \n\tret  = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_clk;\n\thva->irq_its = ret;\n\n\tret = devm_request_threaded_irq(dev, hva->irq_its, hva_hw_its_interrupt,\n\t\t\t\t\thva_hw_its_irq_thread,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\"hva_its_irq\", hva);\n\tif (ret) {\n\t\tdev_err(dev, \"%s     failed to install status IRQ 0x%x\\n\",\n\t\t\tHVA_PREFIX, hva->irq_its);\n\t\tgoto err_clk;\n\t}\n\tdisable_irq(hva->irq_its);\n\n\t \n\tret = platform_get_irq(pdev, 1);\n\tif (ret < 0)\n\t\tgoto err_clk;\n\thva->irq_err = ret;\n\n\tret = devm_request_threaded_irq(dev, hva->irq_err, hva_hw_err_interrupt,\n\t\t\t\t\thva_hw_err_irq_thread,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\"hva_err_irq\", hva);\n\tif (ret) {\n\t\tdev_err(dev, \"%s     failed to install error IRQ 0x%x\\n\",\n\t\t\tHVA_PREFIX, hva->irq_err);\n\t\tgoto err_clk;\n\t}\n\tdisable_irq(hva->irq_err);\n\n\t \n\tmutex_init(&hva->protect_mutex);\n\n\t \n\tinit_completion(&hva->interrupt);\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, AUTOSUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_enable(dev);\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s     failed to set PM\\n\", HVA_PREFIX);\n\t\tgoto err_disable;\n\t}\n\n\t \n\thva->ip_version = hva_hw_get_ip_version(hva);\n\n\tif (hva->ip_version == HVA_VERSION_UNKNOWN) {\n\t\tret = -EINVAL;\n\t\tgoto err_pm;\n\t}\n\n\tdev_info(dev, \"%s     found hva device (version 0x%lx)\\n\", HVA_PREFIX,\n\t\t hva->ip_version);\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_put(dev);\nerr_disable:\n\tpm_runtime_disable(dev);\nerr_clk:\n\tif (hva->clk)\n\t\tclk_unprepare(hva->clk);\n\n\treturn ret;\n}\n\nvoid hva_hw_remove(struct hva_dev *hva)\n{\n\tstruct device *dev = hva_to_dev(hva);\n\n\tdisable_irq(hva->irq_its);\n\tdisable_irq(hva->irq_err);\n\n\tpm_runtime_put_autosuspend(dev);\n\tpm_runtime_disable(dev);\n}\n\nint hva_hw_runtime_suspend(struct device *dev)\n{\n\tstruct hva_dev *hva = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(hva->clk);\n\n\treturn 0;\n}\n\nint hva_hw_runtime_resume(struct device *dev)\n{\n\tstruct hva_dev *hva = dev_get_drvdata(dev);\n\n\tif (clk_prepare_enable(hva->clk)) {\n\t\tdev_err(hva->dev, \"%s     failed to prepare hva clk\\n\",\n\t\t\tHVA_PREFIX);\n\t\treturn -EINVAL;\n\t}\n\n\tif (clk_set_rate(hva->clk, CLK_RATE)) {\n\t\tdev_err(dev, \"%s     failed to set clock frequency\\n\",\n\t\t\tHVA_PREFIX);\n\t\tclk_disable_unprepare(hva->clk);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint hva_hw_execute_task(struct hva_ctx *ctx, enum hva_hw_cmd_type cmd,\n\t\t\tstruct hva_buffer *task)\n{\n\tstruct hva_dev *hva = ctx_to_hdev(ctx);\n\tstruct device *dev = hva_to_dev(hva);\n\tu8 client_id = ctx->id;\n\tint ret;\n\tu32 reg = 0;\n\tbool got_pm = false;\n\n\tmutex_lock(&hva->protect_mutex);\n\n\t \n\tenable_irq(hva->irq_its);\n\tenable_irq(hva->irq_err);\n\n\tif (pm_runtime_resume_and_get(dev) < 0) {\n\t\tdev_err(dev, \"%s     failed to get pm_runtime\\n\", ctx->name);\n\t\tctx->sys_errors++;\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tgot_pm = true;\n\n\treg = readl_relaxed(hva->regs + HVA_HIF_REG_CLK_GATING);\n\tswitch (cmd) {\n\tcase H264_ENC:\n\t\treg |= CLK_GATING_HVC;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"%s     unknown command 0x%x\\n\", ctx->name, cmd);\n\t\tctx->encode_errors++;\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\twritel_relaxed(reg, hva->regs + HVA_HIF_REG_CLK_GATING);\n\n\tdev_dbg(dev, \"%s     %s: write configuration registers\\n\", ctx->name,\n\t\t__func__);\n\n\t \n\twritel_relaxed(BSM_CFG_VAL1, hva->regs + HVA_HIF_REG_BSM);\n\n\t \n\twritel_relaxed(MIF_CFG_VAL3, hva->regs + HVA_HIF_REG_MIF_CFG);\n\twritel_relaxed(HEC_MIF_CFG_VAL, hva->regs + HVA_HIF_REG_HEC_MIF_CFG);\n\n\t \n\tdev_dbg(dev, \"%s     %s: send task (cmd: %d, task_desc: %pad)\\n\",\n\t\tctx->name, __func__, cmd + (client_id << 8), &task->paddr);\n\twritel_relaxed(cmd + (client_id << 8), hva->regs + HVA_HIF_FIFO_CMD);\n\twritel_relaxed(task->paddr, hva->regs + HVA_HIF_FIFO_CMD);\n\n\tif (!wait_for_completion_timeout(&hva->interrupt,\n\t\t\t\t\t msecs_to_jiffies(2000))) {\n\t\tdev_err(dev, \"%s     %s: time out on completion\\n\", ctx->name,\n\t\t\t__func__);\n\t\tctx->encode_errors++;\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t \n\tret = ctx->hw_err ? -EFAULT : 0;\n\n\tctx->encode_errors += ctx->hw_err ? 1 : 0;\n\nout:\n\tdisable_irq(hva->irq_its);\n\tdisable_irq(hva->irq_err);\n\n\tswitch (cmd) {\n\tcase H264_ENC:\n\t\treg &= ~CLK_GATING_HVC;\n\t\twritel_relaxed(reg, hva->regs + HVA_HIF_REG_CLK_GATING);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"%s     unknown command 0x%x\\n\", ctx->name, cmd);\n\t}\n\n\tif (got_pm)\n\t\tpm_runtime_put_autosuspend(dev);\n\tmutex_unlock(&hva->protect_mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\n#define DUMP(reg) seq_printf(s, \"%-30s: 0x%08X\\n\",\\\n\t\t\t     #reg, readl_relaxed(hva->regs + reg))\n\nvoid hva_hw_dump_regs(struct hva_dev *hva, struct seq_file *s)\n{\n\tstruct device *dev = hva_to_dev(hva);\n\n\tmutex_lock(&hva->protect_mutex);\n\n\tif (pm_runtime_resume_and_get(dev) < 0) {\n\t\tseq_puts(s, \"Cannot wake up IP\\n\");\n\t\tmutex_unlock(&hva->protect_mutex);\n\t\treturn;\n\t}\n\n\tseq_printf(s, \"Registers:\\nReg @ = 0x%p\\n\", hva->regs);\n\n\tDUMP(HVA_HIF_REG_RST);\n\tDUMP(HVA_HIF_REG_RST_ACK);\n\tDUMP(HVA_HIF_REG_MIF_CFG);\n\tDUMP(HVA_HIF_REG_HEC_MIF_CFG);\n\tDUMP(HVA_HIF_REG_CFL);\n\tDUMP(HVA_HIF_REG_SFL);\n\tDUMP(HVA_HIF_REG_LMI_ERR);\n\tDUMP(HVA_HIF_REG_EMI_ERR);\n\tDUMP(HVA_HIF_REG_HEC_MIF_ERR);\n\tDUMP(HVA_HIF_REG_HEC_STS);\n\tDUMP(HVA_HIF_REG_HVC_STS);\n\tDUMP(HVA_HIF_REG_HJE_STS);\n\tDUMP(HVA_HIF_REG_CNT);\n\tDUMP(HVA_HIF_REG_HEC_CHKSYN_DIS);\n\tDUMP(HVA_HIF_REG_CLK_GATING);\n\tDUMP(HVA_HIF_REG_VERSION);\n\n\tpm_runtime_put_autosuspend(dev);\n\tmutex_unlock(&hva->protect_mutex);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}