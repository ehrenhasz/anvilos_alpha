{
  "module_name": "hva-h264.c",
  "hash_id": "111f58cd94df1d7c142d3a346e856d9d86cd476f25b2f19e31b1261252f55688",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/st/sti/hva/hva-h264.c",
  "human_readable_source": "\n \n\n#include \"hva.h\"\n#include \"hva-hw.h\"\n\n#define MAX_SPS_PPS_SIZE 128\n\n#define BITSTREAM_OFFSET_MASK 0x7F\n\n \n#define H264_MAX_SIZE_W 1920\n#define H264_MAX_SIZE_H 1920\n\n \n#define MB_W(w) ((w + 0xF)  / 0x10)\n#define MB_H(h) ((h + 0xF)  / 0x10)\n\n \n#define DATA_SIZE(w, h) (MB_W(w) * MB_H(h) * 16)\n\n#define SEARCH_WINDOW_BUFFER_MAX_SIZE(w) ((4 * MB_W(w) + 42) * 256 * 3 / 2)\n#define CABAC_CONTEXT_BUFFER_MAX_SIZE(w) (MB_W(w) * 16)\n#define CTX_MB_BUFFER_MAX_SIZE(w) (MB_W(w) * 16 * 8)\n#define SLICE_HEADER_SIZE (4 * 16)\n#define BRC_DATA_SIZE (5 * 16)\n\n \n#define CURRENT_WINDOW_BUFFER_MAX_SIZE (16 * 256 * 3 / 2)\n\n \n#define LOCAL_RECONSTRUCTED_BUFFER_MAX_SIZE(w) (4 * 16 * MB_W(w) * 2)\n\n \n#define H264_FACTOR_HIGH 1200\n\n \n#define H264_FACTOR_BASELINE 1000\n\n \n#define H264_FILLER_DATA_SIZE 6\n\nstruct h264_profile {\n\tenum v4l2_mpeg_video_h264_level level;\n\tu32 max_mb_per_seconds;\n\tu32 max_frame_size;\n\tu32 max_bitrate;\n\tu32 max_cpb_size;\n\tu32 min_comp_ratio;\n};\n\nstatic const struct h264_profile h264_infos_list[] = {\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_1_0, 1485, 99, 64, 175, 2},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_1B, 1485, 99, 128, 350, 2},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_1_1, 3000, 396, 192, 500, 2},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_1_2, 6000, 396, 384, 1000, 2},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_1_3, 11880, 396, 768, 2000, 2},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_2_0, 11880, 396, 2000, 2000, 2},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_2_1, 19800, 792, 4000, 4000, 2},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_2_2, 20250, 1620, 4000, 4000, 2},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_3_0, 40500, 1620, 10000, 10000, 2},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_3_1, 108000, 3600, 14000, 14000, 4},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_3_2, 216000, 5120, 20000, 20000, 4},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_4_0, 245760, 8192, 20000, 25000, 4},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_4_1, 245760, 8192, 50000, 62500, 2},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_4_2, 522240, 8704, 50000, 62500, 2},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_5_0, 589824, 22080, 135000, 135000, 2},\n\t{V4L2_MPEG_VIDEO_H264_LEVEL_5_1, 983040, 36864, 240000, 240000, 2}\n};\n\nenum hva_brc_type {\n\tBRC_TYPE_NONE = 0,\n\tBRC_TYPE_CBR = 1,\n\tBRC_TYPE_VBR = 2,\n\tBRC_TYPE_VBR_LOW_DELAY = 3\n};\n\nenum hva_entropy_coding_mode {\n\tCAVLC = 0,\n\tCABAC = 1\n};\n\nenum hva_picture_coding_type {\n\tPICTURE_CODING_TYPE_I = 0,\n\tPICTURE_CODING_TYPE_P = 1,\n\tPICTURE_CODING_TYPE_B = 2\n};\n\nenum hva_h264_sampling_mode {\n\tSAMPLING_MODE_NV12 = 0,\n\tSAMPLING_MODE_UYVY = 1,\n\tSAMPLING_MODE_RGB3 = 3,\n\tSAMPLING_MODE_XRGB4 = 4,\n\tSAMPLING_MODE_NV21 = 8,\n\tSAMPLING_MODE_VYUY = 9,\n\tSAMPLING_MODE_BGR3 = 11,\n\tSAMPLING_MODE_XBGR4 = 12,\n\tSAMPLING_MODE_RGBX4 = 20,\n\tSAMPLING_MODE_BGRX4 = 28\n};\n\nenum hva_h264_nalu_type {\n\tNALU_TYPE_UNKNOWN = 0,\n\tNALU_TYPE_SLICE = 1,\n\tNALU_TYPE_SLICE_DPA = 2,\n\tNALU_TYPE_SLICE_DPB = 3,\n\tNALU_TYPE_SLICE_DPC = 4,\n\tNALU_TYPE_SLICE_IDR = 5,\n\tNALU_TYPE_SEI = 6,\n\tNALU_TYPE_SPS = 7,\n\tNALU_TYPE_PPS = 8,\n\tNALU_TYPE_AU_DELIMITER = 9,\n\tNALU_TYPE_SEQ_END = 10,\n\tNALU_TYPE_STREAM_END = 11,\n\tNALU_TYPE_FILLER_DATA = 12,\n\tNALU_TYPE_SPS_EXT = 13,\n\tNALU_TYPE_PREFIX_UNIT = 14,\n\tNALU_TYPE_SUBSET_SPS = 15,\n\tNALU_TYPE_SLICE_AUX = 19,\n\tNALU_TYPE_SLICE_EXT = 20\n};\n\nenum hva_h264_sei_payload_type {\n\tSEI_BUFFERING_PERIOD = 0,\n\tSEI_PICTURE_TIMING = 1,\n\tSEI_STEREO_VIDEO_INFO = 21,\n\tSEI_FRAME_PACKING_ARRANGEMENT = 45\n};\n\n \nstruct hva_h264_stereo_video_sei {\n\tu8 field_views_flag;\n\tu8 top_field_is_left_view_flag;\n\tu8 current_frame_is_left_view_flag;\n\tu8 next_frame_is_second_view_flag;\n\tu8 left_view_self_contained_flag;\n\tu8 right_view_self_contained_flag;\n};\n\n \nstruct hva_h264_td {\n\tu16 frame_width;\n\tu16 frame_height;\n\tu32 frame_num;\n\tu16 picture_coding_type;\n\tu16 reserved1;\n\tu16 pic_order_cnt_type;\n\tu16 first_picture_in_sequence;\n\tu16 slice_size_type;\n\tu16 reserved2;\n\tu32 slice_mb_size;\n\tu16 ir_param_option;\n\tu16 intra_refresh_type;\n\tu16 use_constrained_intra_flag;\n\tu16 transform_mode;\n\tu16 disable_deblocking_filter_idc;\n\ts16 slice_alpha_c0_offset_div2;\n\ts16 slice_beta_offset_div2;\n\tu16 encoder_complexity;\n\ts16 chroma_qp_index_offset;\n\tu16 entropy_coding_mode;\n\tu16 brc_type;\n\tu16 quant;\n\tu32 non_vcl_nalu_size;\n\tu32 cpb_buffer_size;\n\tu32 bit_rate;\n\tu16 qp_min;\n\tu16 qp_max;\n\tu16 framerate_num;\n\tu16 framerate_den;\n\tu16 delay;\n\tu16 strict_hrd_compliancy;\n\tu32 addr_source_buffer;\n\tu32 addr_fwd_ref_buffer;\n\tu32 addr_rec_buffer;\n\tu32 addr_output_bitstream_start;\n\tu32 addr_output_bitstream_end;\n\tu32 addr_external_sw;\n\tu32 addr_lctx;\n\tu32 addr_local_rec_buffer;\n\tu32 addr_spatial_context;\n\tu16 bitstream_offset;\n\tu16 sampling_mode;\n\tu32 addr_param_out;\n\tu32 addr_scaling_matrix;\n\tu32 addr_scaling_matrix_dir;\n\tu32 addr_cabac_context_buffer;\n\tu32 reserved3;\n\tu32 reserved4;\n\ts16 gmv_x;\n\ts16 gmv_y;\n\tu16 window_width;\n\tu16 window_height;\n\tu16 window_horizontal_offset;\n\tu16 window_vertical_offset;\n\tu32 addr_roi;\n\tu32 addr_slice_header;\n\tu16 slice_header_size_in_bits;\n\tu16 slice_header_offset0;\n\tu16 slice_header_offset1;\n\tu16 slice_header_offset2;\n\tu32 reserved5;\n\tu32 reserved6;\n\tu16 reserved7;\n\tu16 reserved8;\n\tu16 slice_synchro_enable;\n\tu16 max_slice_number;\n\tu32 rgb2_yuv_y_coeff;\n\tu32 rgb2_yuv_u_coeff;\n\tu32 rgb2_yuv_v_coeff;\n\tu32 slice_byte_size;\n\tu16 max_air_intra_mb_nb;\n\tu16 brc_no_skip;\n\tu32 addr_temporal_context;\n\tu32 addr_brc_in_out_parameter;\n};\n\n \nstruct hva_h264_slice_po {\n\tu32 slice_size;\n\tu32 slice_start_time;\n\tu32 slice_end_time;\n\tu32 slice_num;\n};\n\n \nstruct hva_h264_po {\n\tu32 bitstream_size;\n\tu32 dct_bitstream_size;\n\tu32 stuffing_bits;\n\tu32 removal_time;\n\tu32 hvc_start_time;\n\tu32 hvc_stop_time;\n\tu32 slice_count;\n\tu32 reserved0;\n\tstruct hva_h264_slice_po slice_params[16];\n};\n\nstruct hva_h264_task {\n\tstruct hva_h264_td td;\n\tstruct hva_h264_po po;\n};\n\n \nstruct hva_h264_ctx {\n\tstruct hva_buffer *seq_info;\n\tstruct hva_buffer *ref_frame;\n\tstruct hva_buffer *rec_frame;\n\tstruct hva_buffer *task;\n};\n\nstatic int hva_h264_fill_slice_header(struct hva_ctx *pctx,\n\t\t\t\t      u8 *slice_header_addr,\n\t\t\t\t      struct hva_controls *ctrls,\n\t\t\t\t      int frame_num,\n\t\t\t\t      u16 *header_size,\n\t\t\t\t      u16 *header_offset0,\n\t\t\t\t      u16 *header_offset1,\n\t\t\t\t      u16 *header_offset2)\n{\n\t \n\tstruct device *dev = ctx_to_dev(pctx);\n\tint  cabac = V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC;\n\tstatic const unsigned char slice_header[] = {\n\t\t0x00, 0x00, 0x00, 0x01,\n\t\t0x41, 0x34, 0x07, 0x00\n\t};\n\tint idr_pic_id = frame_num % 2;\n\tenum hva_picture_coding_type type;\n\tu32 frame_order = frame_num % ctrls->gop_size;\n\n\tif (!(frame_num % ctrls->gop_size))\n\t\ttype = PICTURE_CODING_TYPE_I;\n\telse\n\t\ttype = PICTURE_CODING_TYPE_P;\n\n\tmemcpy(slice_header_addr, slice_header, sizeof(slice_header));\n\n\t*header_size = 56;\n\t*header_offset0 = 40;\n\t*header_offset1 = 13;\n\t*header_offset2 = 0;\n\n\tif (type == PICTURE_CODING_TYPE_I) {\n\t\tslice_header_addr[4] = 0x65;\n\t\tslice_header_addr[5] = 0x11;\n\n\t\t \n\t\tif ((frame_num / ctrls->gop_size) % 2) {\n\t\t\t*header_size += 4;\n\t\t\t*header_offset1 += 4;\n\t\t\tslice_header_addr[6] = 0x04;\n\t\t\tslice_header_addr[7] = 0x70;\n\n\t\t} else {\n\t\t\t*header_size += 2;\n\t\t\t*header_offset1 += 2;\n\t\t\tslice_header_addr[6] = 0x09;\n\t\t\tslice_header_addr[7] = 0xC0;\n\t\t}\n\t} else {\n\t\tif (ctrls->entropy_mode == cabac) {\n\t\t\t*header_size += 1;\n\t\t\t*header_offset1 += 1;\n\t\t\tslice_header_addr[7] = 0x80;\n\t\t}\n\t\t \n\t\tslice_header_addr[5] += ((frame_order & 0x0C) >> 2);\n\t\tslice_header_addr[6] += ((frame_order & 0x03) << 6);\n\t}\n\n\tdev_dbg(dev,\n\t\t\"%s   %s slice header order %d idrPicId %d header size %d\\n\",\n\t\tpctx->name, __func__, frame_order, idr_pic_id, *header_size);\n\treturn 0;\n}\n\nstatic int hva_h264_fill_data_nal(struct hva_ctx *pctx,\n\t\t\t\t  unsigned int stuffing_bytes, u8 *addr,\n\t\t\t\t  unsigned int stream_size, unsigned int *size)\n{\n\tstruct device *dev = ctx_to_dev(pctx);\n\tstatic const u8 start[] = { 0x00, 0x00, 0x00, 0x01 };\n\n\tdev_dbg(dev, \"%s   %s stuffing bytes %d\\n\", pctx->name, __func__,\n\t\tstuffing_bytes);\n\n\tif ((*size + stuffing_bytes + H264_FILLER_DATA_SIZE) > stream_size) {\n\t\tdev_dbg(dev, \"%s   %s too many stuffing bytes %d\\n\",\n\t\t\tpctx->name, __func__, stuffing_bytes);\n\t\treturn 0;\n\t}\n\n\t \n\tmemcpy(addr + *size, start, sizeof(start));\n\t*size += sizeof(start);\n\n\t \n\taddr[*size] = NALU_TYPE_FILLER_DATA;\n\t*size += 1;\n\n\tmemset(addr + *size, 0xff, stuffing_bytes);\n\t*size += stuffing_bytes;\n\n\taddr[*size] = 0x80;\n\t*size += 1;\n\n\treturn 0;\n}\n\nstatic int hva_h264_fill_sei_nal(struct hva_ctx *pctx,\n\t\t\t\t enum hva_h264_sei_payload_type type,\n\t\t\t\t u8 *addr, u32 *size)\n{\n\tstruct device *dev = ctx_to_dev(pctx);\n\tstatic const u8 start[] = { 0x00, 0x00, 0x00, 0x01 };\n\tstruct hva_h264_stereo_video_sei info;\n\tu8 offset = 7;\n\tu8 msg = 0;\n\n\t \n\tmemcpy(addr + *size, start, sizeof(start));\n\t*size += sizeof(start);\n\n\t \n\taddr[*size] = NALU_TYPE_SEI;\n\t*size += 1;\n\n\t \n\taddr[*size] = type;\n\t*size += 1;\n\n\tswitch (type) {\n\tcase SEI_STEREO_VIDEO_INFO:\n\t\tmemset(&info, 0, sizeof(info));\n\n\t\t \n\t\tinfo.field_views_flag = 1;\n\t\tinfo.top_field_is_left_view_flag = 1;\n\n\t\t \n\t\taddr[*size] = 1;\n\t\t*size += 1;\n\n\t\t \n\t\tmsg = info.field_views_flag << offset--;\n\n\t\tif (info.field_views_flag) {\n\t\t\tmsg |= info.top_field_is_left_view_flag <<\n\t\t\t       offset--;\n\t\t} else {\n\t\t\tmsg |= info.current_frame_is_left_view_flag <<\n\t\t\t       offset--;\n\t\t\tmsg |= info.next_frame_is_second_view_flag <<\n\t\t\t       offset--;\n\t\t}\n\t\tmsg |= info.left_view_self_contained_flag << offset--;\n\t\tmsg |= info.right_view_self_contained_flag << offset--;\n\n\t\taddr[*size] = msg;\n\t\t*size += 1;\n\n\t\taddr[*size] = 0x80;\n\t\t*size += 1;\n\n\t\treturn 0;\n\tcase SEI_BUFFERING_PERIOD:\n\tcase SEI_PICTURE_TIMING:\n\tcase SEI_FRAME_PACKING_ARRANGEMENT:\n\tdefault:\n\t\tdev_err(dev, \"%s   sei nal type not supported %d\\n\",\n\t\t\tpctx->name, type);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int hva_h264_prepare_task(struct hva_ctx *pctx,\n\t\t\t\t struct hva_h264_task *task,\n\t\t\t\t struct hva_frame *frame,\n\t\t\t\t struct hva_stream *stream)\n{\n\tstruct hva_dev *hva = ctx_to_hdev(pctx);\n\tstruct device *dev = ctx_to_dev(pctx);\n\tstruct hva_h264_ctx *ctx = pctx->priv;\n\tstruct hva_buffer *seq_info = ctx->seq_info;\n\tstruct hva_buffer *fwd_ref_frame = ctx->ref_frame;\n\tstruct hva_buffer *loc_rec_frame = ctx->rec_frame;\n\tstruct hva_h264_td *td = &task->td;\n\tstruct hva_controls *ctrls = &pctx->ctrls;\n\tstruct v4l2_fract *time_per_frame = &pctx->ctrls.time_per_frame;\n\tint cavlc =  V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC;\n\tu32 frame_num = pctx->stream_num;\n\tu32 addr_esram = hva->esram_addr;\n\tenum v4l2_mpeg_video_h264_level level;\n\tdma_addr_t paddr = 0;\n\tu8 *slice_header_vaddr;\n\tu32 frame_width = frame->info.aligned_width;\n\tu32 frame_height = frame->info.aligned_height;\n\tu32 max_cpb_buffer_size;\n\tunsigned int payload = stream->bytesused;\n\tu32 max_bitrate;\n\n\t \n\tif ((frame_width > max(H264_MAX_SIZE_W, H264_MAX_SIZE_H)) ||\n\t    (frame_height > max(H264_MAX_SIZE_W, H264_MAX_SIZE_H))) {\n\t\tdev_err(dev,\n\t\t\t\"%s   width(%d) or height(%d) exceeds limits (%dx%d)\\n\",\n\t\t\tpctx->name, frame_width, frame_height,\n\t\t\tH264_MAX_SIZE_W, H264_MAX_SIZE_H);\n\t\tpctx->frame_errors++;\n\t\treturn -EINVAL;\n\t}\n\n\tlevel = ctrls->level;\n\n\tmemset(td, 0, sizeof(struct hva_h264_td));\n\n\ttd->frame_width = frame_width;\n\ttd->frame_height = frame_height;\n\n\t \n\ttd->window_width =  frame_width;\n\ttd->window_height = frame_height;\n\ttd->window_horizontal_offset = 0;\n\ttd->window_vertical_offset = 0;\n\n\ttd->first_picture_in_sequence = (!frame_num) ? 1 : 0;\n\n\t \n\ttd->pic_order_cnt_type = 2;\n\n\t \n\ttd->use_constrained_intra_flag = false;\n\ttd->brc_type = (ctrls->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR)\n\t\t\t? BRC_TYPE_CBR : BRC_TYPE_VBR;\n\n\ttd->entropy_coding_mode = (ctrls->entropy_mode == cavlc) ? CAVLC :\n\t\t\t\t  CABAC;\n\n\ttd->bit_rate = ctrls->bitrate;\n\n\t \n\tif (time_per_frame->numerator >= 536) {\n\t\t \n\t\ttd->framerate_den = 1;\n\t\ttd->framerate_num = (time_per_frame->denominator +\n\t\t\t\t    (time_per_frame->numerator >> 1) - 1) /\n\t\t\t\t    time_per_frame->numerator;\n\n\t\t \n\t\ttd->bit_rate /= time_per_frame->numerator;\n\t\ttd->bit_rate *= time_per_frame->denominator;\n\t\ttd->bit_rate /= td->framerate_num;\n\t} else {\n\t\ttd->framerate_den = time_per_frame->numerator;\n\t\ttd->framerate_num = time_per_frame->denominator;\n\t}\n\n\t \n\tif (ctrls->profile >= V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)\n\t\tmax_bitrate = h264_infos_list[level].max_bitrate *\n\t\t\t      H264_FACTOR_HIGH;\n\telse\n\t\tmax_bitrate = h264_infos_list[level].max_bitrate *\n\t\t\t      H264_FACTOR_BASELINE;\n\n\t \n\tif (td->bit_rate > max_bitrate) {\n\t\tdev_dbg(dev,\n\t\t\t\"%s   bitrate (%d) larger than level and profile allow, clip to %d\\n\",\n\t\t\tpctx->name, td->bit_rate, max_bitrate);\n\t\ttd->bit_rate = max_bitrate;\n\t}\n\n\t \n\ttd->cpb_buffer_size = ctrls->cpb_size * 8000;\n\n\t \n\tif (ctrls->profile >= V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)\n\t\tmax_cpb_buffer_size =\n\t\t    h264_infos_list[level].max_cpb_size * H264_FACTOR_HIGH;\n\telse\n\t\tmax_cpb_buffer_size =\n\t\t    h264_infos_list[level].max_cpb_size * H264_FACTOR_BASELINE;\n\n\t \n\tif (td->cpb_buffer_size > max_cpb_buffer_size) {\n\t\tdev_dbg(dev,\n\t\t\t\"%s   cpb size larger than level %d allows, clip to %d\\n\",\n\t\t\tpctx->name, td->cpb_buffer_size, max_cpb_buffer_size);\n\t\ttd->cpb_buffer_size = max_cpb_buffer_size;\n\t}\n\n\t \n\ttd->brc_no_skip = 0;\n\n\t \n\tif ((ctrls->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR) &&\n\t    td->bit_rate)\n\t\ttd->delay = 1000 * (td->cpb_buffer_size / td->bit_rate);\n\telse\n\t\ttd->delay = 0;\n\n\tswitch (frame->info.pixelformat) {\n\tcase V4L2_PIX_FMT_NV12:\n\t\ttd->sampling_mode = SAMPLING_MODE_NV12;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV21:\n\t\ttd->sampling_mode = SAMPLING_MODE_NV21;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s   invalid source pixel format\\n\",\n\t\t\tpctx->name);\n\t\tpctx->frame_errors++;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttd->rgb2_yuv_y_coeff = 0x12031008;\n\ttd->rgb2_yuv_u_coeff = 0x800EF7FB;\n\ttd->rgb2_yuv_v_coeff = 0x80FEF40E;\n\n\t \n\ttd->transform_mode = ctrls->dct8x8;\n\n\t \n\ttd->encoder_complexity = 2;\n\n\t \n\ttd->quant = 28;\n\n\tif (td->framerate_den == 0) {\n\t\tdev_err(dev, \"%s   invalid framerate\\n\", pctx->name);\n\t\tpctx->frame_errors++;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (td->framerate_num == 0)\n\t\ttd->brc_type = 0;\n\n\t \n\ttd->strict_hrd_compliancy = 1;\n\n\t \n\ttd->qp_min = clamp_val(ctrls->qpmin, 0, 51);\n\ttd->qp_max = clamp_val(ctrls->qpmax, 0, 51);\n\n\ttd->addr_source_buffer = frame->paddr;\n\ttd->addr_fwd_ref_buffer = fwd_ref_frame->paddr;\n\ttd->addr_rec_buffer = loc_rec_frame->paddr;\n\n\ttd->addr_output_bitstream_end = (u32)stream->paddr + stream->size;\n\n\ttd->addr_output_bitstream_start = (u32)stream->paddr;\n\ttd->bitstream_offset = (((u32)stream->paddr & 0xF) << 3) &\n\t\t\t       BITSTREAM_OFFSET_MASK;\n\n\ttd->addr_param_out = (u32)ctx->task->paddr +\n\t\t\t     offsetof(struct hva_h264_task, po);\n\n\t \n\tif (frame_num % 2) {\n\t\tpaddr = seq_info->paddr;\n\t\ttd->addr_spatial_context =  ALIGN(paddr, 0x100);\n\t\tpaddr = seq_info->paddr + DATA_SIZE(frame_width,\n\t\t\t\t\t\t\tframe_height);\n\t\ttd->addr_temporal_context = ALIGN(paddr, 0x100);\n\t} else {\n\t\tpaddr = seq_info->paddr;\n\t\ttd->addr_temporal_context = ALIGN(paddr, 0x100);\n\t\tpaddr = seq_info->paddr + DATA_SIZE(frame_width,\n\t\t\t\t\t\t\tframe_height);\n\t\ttd->addr_spatial_context =  ALIGN(paddr, 0x100);\n\t}\n\n\tpaddr = seq_info->paddr + 2 * DATA_SIZE(frame_width, frame_height);\n\n\ttd->addr_brc_in_out_parameter =  ALIGN(paddr, 0x100);\n\n\tpaddr = td->addr_brc_in_out_parameter + BRC_DATA_SIZE;\n\ttd->addr_slice_header =  ALIGN(paddr, 0x100);\n\ttd->addr_external_sw =  ALIGN(addr_esram, 0x100);\n\n\taddr_esram += SEARCH_WINDOW_BUFFER_MAX_SIZE(frame_width);\n\ttd->addr_local_rec_buffer = ALIGN(addr_esram, 0x100);\n\n\taddr_esram += LOCAL_RECONSTRUCTED_BUFFER_MAX_SIZE(frame_width);\n\ttd->addr_lctx = ALIGN(addr_esram, 0x100);\n\n\taddr_esram += CTX_MB_BUFFER_MAX_SIZE(max(frame_width, frame_height));\n\ttd->addr_cabac_context_buffer = ALIGN(addr_esram, 0x100);\n\n\tif (!(frame_num % ctrls->gop_size)) {\n\t\ttd->picture_coding_type = PICTURE_CODING_TYPE_I;\n\t\tstream->vbuf.flags |= V4L2_BUF_FLAG_KEYFRAME;\n\t} else {\n\t\ttd->picture_coding_type = PICTURE_CODING_TYPE_P;\n\t\tstream->vbuf.flags &= ~V4L2_BUF_FLAG_KEYFRAME;\n\t}\n\n\t \n\tslice_header_vaddr = seq_info->vaddr + (td->addr_slice_header -\n\t\t\t     seq_info->paddr);\n\n\thva_h264_fill_slice_header(pctx, slice_header_vaddr, ctrls, frame_num,\n\t\t\t\t   &td->slice_header_size_in_bits,\n\t\t\t\t   &td->slice_header_offset0,\n\t\t\t\t   &td->slice_header_offset1,\n\t\t\t\t   &td->slice_header_offset2);\n\n\ttd->chroma_qp_index_offset = 2;\n\ttd->slice_synchro_enable = 0;\n\ttd->max_slice_number = 1;\n\n\t \n\tif ((stream->vbuf.flags == V4L2_BUF_FLAG_KEYFRAME) &&\n\t    (payload > MAX_SPS_PPS_SIZE)) {\n\t\tdev_err(dev, \"%s   invalid sps/pps size %d\\n\", pctx->name,\n\t\t\tpayload);\n\t\tpctx->frame_errors++;\n\t\treturn -EINVAL;\n\t}\n\n\tif (stream->vbuf.flags != V4L2_BUF_FLAG_KEYFRAME)\n\t\tpayload = 0;\n\n\t \n\tif (ctrls->sei_fp && hva_h264_fill_sei_nal(pctx, SEI_STEREO_VIDEO_INFO,\n\t\t\t\t\t\t   (u8 *)stream->vaddr,\n\t\t\t\t\t\t   &payload)) {\n\t\tdev_err(dev, \"%s   fail to get SEI nal\\n\", pctx->name);\n\t\tpctx->frame_errors++;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttd->non_vcl_nalu_size = payload * 8;\n\n\t \n\ttd->addr_output_bitstream_start += ((payload >> 4) << 4);\n\ttd->bitstream_offset += (payload - ((payload >> 4) << 4)) * 8;\n\n\tstream->bytesused = payload;\n\n\treturn 0;\n}\n\nstatic unsigned int hva_h264_get_stream_size(struct hva_h264_task *task)\n{\n\tstruct hva_h264_po *po = &task->po;\n\n\treturn po->bitstream_size;\n}\n\nstatic u32 hva_h264_get_stuffing_bytes(struct hva_h264_task *task)\n{\n\tstruct hva_h264_po *po = &task->po;\n\n\treturn po->stuffing_bits >> 3;\n}\n\nstatic int hva_h264_open(struct hva_ctx *pctx)\n{\n\tstruct device *dev = ctx_to_dev(pctx);\n\tstruct hva_h264_ctx *ctx;\n\tstruct hva_dev *hva = ctx_to_hdev(pctx);\n\tu32 frame_width = pctx->frameinfo.aligned_width;\n\tu32 frame_height = pctx->frameinfo.aligned_height;\n\tu32 size;\n\tint ret;\n\n\t \n\tsize = SEARCH_WINDOW_BUFFER_MAX_SIZE(frame_width) +\n\t       LOCAL_RECONSTRUCTED_BUFFER_MAX_SIZE(frame_width) +\n\t       CTX_MB_BUFFER_MAX_SIZE(max(frame_width, frame_height)) +\n\t       CABAC_CONTEXT_BUFFER_MAX_SIZE(frame_width);\n\n\tif (hva->esram_size < size) {\n\t\tdev_err(dev, \"%s   not enough esram (max:%d request:%d)\\n\",\n\t\t\tpctx->name, hva->esram_size, size);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tret = hva_mem_alloc(pctx,\n\t\t\t    2 * DATA_SIZE(frame_width, frame_height) +\n\t\t\t    SLICE_HEADER_SIZE +\n\t\t\t    BRC_DATA_SIZE,\n\t\t\t    \"hva sequence info\",\n\t\t\t    &ctx->seq_info);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"%s   failed to allocate sequence info buffer\\n\",\n\t\t\tpctx->name);\n\t\tgoto err_ctx;\n\t}\n\n\t \n\tret = hva_mem_alloc(pctx,\n\t\t\t    frame_width * frame_height * 3 / 2,\n\t\t\t    \"hva reference frame\",\n\t\t\t    &ctx->ref_frame);\n\tif (ret) {\n\t\tdev_err(dev, \"%s   failed to allocate reference frame buffer\\n\",\n\t\t\tpctx->name);\n\t\tgoto err_seq_info;\n\t}\n\n\t \n\tret = hva_mem_alloc(pctx,\n\t\t\t    frame_width * frame_height * 3 / 2,\n\t\t\t    \"hva reconstructed frame\",\n\t\t\t    &ctx->rec_frame);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"%s   failed to allocate reconstructed frame buffer\\n\",\n\t\t\tpctx->name);\n\t\tgoto err_ref_frame;\n\t}\n\n\t \n\tret = hva_mem_alloc(pctx,\n\t\t\t    sizeof(struct hva_h264_task),\n\t\t\t    \"hva task descriptor\",\n\t\t\t    &ctx->task);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"%s   failed to allocate task descriptor\\n\",\n\t\t\tpctx->name);\n\t\tgoto err_rec_frame;\n\t}\n\n\tpctx->priv = (void *)ctx;\n\n\treturn 0;\n\nerr_rec_frame:\n\thva_mem_free(pctx, ctx->rec_frame);\nerr_ref_frame:\n\thva_mem_free(pctx, ctx->ref_frame);\nerr_seq_info:\n\thva_mem_free(pctx, ctx->seq_info);\nerr_ctx:\n\tdevm_kfree(dev, ctx);\nerr:\n\tpctx->sys_errors++;\n\treturn ret;\n}\n\nstatic int hva_h264_close(struct hva_ctx *pctx)\n{\n\tstruct hva_h264_ctx *ctx = pctx->priv;\n\tstruct device *dev = ctx_to_dev(pctx);\n\n\tif (ctx->seq_info)\n\t\thva_mem_free(pctx, ctx->seq_info);\n\n\tif (ctx->ref_frame)\n\t\thva_mem_free(pctx, ctx->ref_frame);\n\n\tif (ctx->rec_frame)\n\t\thva_mem_free(pctx, ctx->rec_frame);\n\n\tif (ctx->task)\n\t\thva_mem_free(pctx, ctx->task);\n\n\tdevm_kfree(dev, ctx);\n\n\treturn 0;\n}\n\nstatic int hva_h264_encode(struct hva_ctx *pctx, struct hva_frame *frame,\n\t\t\t   struct hva_stream *stream)\n{\n\tstruct hva_h264_ctx *ctx = pctx->priv;\n\tstruct hva_h264_task *task = ctx->task->vaddr;\n\tu32 stuffing_bytes = 0;\n\tint ret = 0;\n\n\tret = hva_h264_prepare_task(pctx, task, frame, stream);\n\tif (ret)\n\t\tgoto err;\n\n\tret = hva_hw_execute_task(pctx, H264_ENC, ctx->task);\n\tif (ret)\n\t\tgoto err;\n\n\tpctx->stream_num++;\n\tstream->bytesused += hva_h264_get_stream_size(task);\n\n\tstuffing_bytes = hva_h264_get_stuffing_bytes(task);\n\n\tif (stuffing_bytes)\n\t\thva_h264_fill_data_nal(pctx, stuffing_bytes,\n\t\t\t\t       (u8 *)stream->vaddr,\n\t\t\t\t       stream->size,\n\t\t\t\t       &stream->bytesused);\n\n\t \n\tswap(ctx->ref_frame, ctx->rec_frame);\n\n\treturn 0;\nerr:\n\tstream->bytesused = 0;\n\treturn ret;\n}\n\nconst struct hva_enc nv12h264enc = {\n\t.name = \"H264(NV12)\",\n\t.pixelformat = V4L2_PIX_FMT_NV12,\n\t.streamformat = V4L2_PIX_FMT_H264,\n\t.max_width = H264_MAX_SIZE_W,\n\t.max_height = H264_MAX_SIZE_H,\n\t.open = hva_h264_open,\n\t.close = hva_h264_close,\n\t.encode = hva_h264_encode,\n};\n\nconst struct hva_enc nv21h264enc = {\n\t.name = \"H264(NV21)\",\n\t.pixelformat = V4L2_PIX_FMT_NV21,\n\t.streamformat = V4L2_PIX_FMT_H264,\n\t.max_width = H264_MAX_SIZE_W,\n\t.max_height = H264_MAX_SIZE_H,\n\t.open = hva_h264_open,\n\t.close = hva_h264_close,\n\t.encode = hva_h264_encode,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}