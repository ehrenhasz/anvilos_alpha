{
  "module_name": "hva-debugfs.c",
  "hash_id": "1ce740888c229614c6209de8c22a1f095bcd843c2aa5a4bdd0c0db662d386e19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/st/sti/hva/hva-debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n\n#include \"hva.h\"\n#include \"hva-hw.h\"\n\nstatic void format_ctx(struct seq_file *s, struct hva_ctx *ctx)\n{\n\tstruct hva_streaminfo *stream = &ctx->streaminfo;\n\tstruct hva_frameinfo *frame = &ctx->frameinfo;\n\tstruct hva_controls *ctrls = &ctx->ctrls;\n\tstruct hva_ctx_dbg *dbg = &ctx->dbg;\n\tu32 bitrate_mode, aspect, entropy, vui_sar, sei_fp;\n\n\tseq_printf(s, \"|-%s\\n  |\\n\", ctx->name);\n\n\tseq_printf(s, \"  |-[%sframe info]\\n\",\n\t\t   ctx->flags & HVA_FLAG_FRAMEINFO ? \"\" : \"default \");\n\tseq_printf(s, \"  | |- pixel format=%4.4s\\n\"\n\t\t      \"  | |- wxh=%dx%d\\n\"\n\t\t      \"  | |- wxh (w/ encoder alignment constraint)=%dx%d\\n\"\n\t\t      \"  |\\n\",\n\t\t      (char *)&frame->pixelformat,\n\t\t      frame->width, frame->height,\n\t\t      frame->aligned_width, frame->aligned_height);\n\n\tseq_printf(s, \"  |-[%sstream info]\\n\",\n\t\t   ctx->flags & HVA_FLAG_STREAMINFO ? \"\" : \"default \");\n\tseq_printf(s, \"  | |- stream format=%4.4s\\n\"\n\t\t      \"  | |- wxh=%dx%d\\n\"\n\t\t      \"  | |- %s\\n\"\n\t\t      \"  | |- %s\\n\"\n\t\t      \"  |\\n\",\n\t\t      (char *)&stream->streamformat,\n\t\t      stream->width, stream->height,\n\t\t      stream->profile, stream->level);\n\n\tbitrate_mode = V4L2_CID_MPEG_VIDEO_BITRATE_MODE;\n\taspect = V4L2_CID_MPEG_VIDEO_ASPECT;\n\tseq_puts(s, \"  |-[parameters]\\n\");\n\tseq_printf(s, \"  | |- %s\\n\"\n\t\t      \"  | |- bitrate=%d bps\\n\"\n\t\t      \"  | |- GOP size=%d\\n\"\n\t\t      \"  | |- video aspect=%s\\n\"\n\t\t      \"  | |- framerate=%d/%d\\n\",\n\t\t      v4l2_ctrl_get_menu(bitrate_mode)[ctrls->bitrate_mode],\n\t\t      ctrls->bitrate,\n\t\t      ctrls->gop_size,\n\t\t      v4l2_ctrl_get_menu(aspect)[ctrls->aspect],\n\t\t      ctrls->time_per_frame.denominator,\n\t\t      ctrls->time_per_frame.numerator);\n\n\tentropy = V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE;\n\tvui_sar = V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC;\n\tsei_fp =  V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE;\n\tif (stream->streamformat == V4L2_PIX_FMT_H264) {\n\t\tseq_printf(s, \"  | |- %s entropy mode\\n\"\n\t\t\t      \"  | |- CPB size=%d kB\\n\"\n\t\t\t      \"  | |- DCT8x8 enable=%s\\n\"\n\t\t\t      \"  | |- qpmin=%d\\n\"\n\t\t\t      \"  | |- qpmax=%d\\n\"\n\t\t\t      \"  | |- PAR enable=%s\\n\"\n\t\t\t      \"  | |- PAR id=%s\\n\"\n\t\t\t      \"  | |- SEI frame packing enable=%s\\n\"\n\t\t\t      \"  | |- SEI frame packing type=%s\\n\",\n\t\t\t      v4l2_ctrl_get_menu(entropy)[ctrls->entropy_mode],\n\t\t\t      ctrls->cpb_size,\n\t\t\t      ctrls->dct8x8 ? \"true\" : \"false\",\n\t\t\t      ctrls->qpmin,\n\t\t\t      ctrls->qpmax,\n\t\t\t      ctrls->vui_sar ? \"true\" : \"false\",\n\t\t\t      v4l2_ctrl_get_menu(vui_sar)[ctrls->vui_sar_idc],\n\t\t\t      ctrls->sei_fp ? \"true\" : \"false\",\n\t\t\t      v4l2_ctrl_get_menu(sei_fp)[ctrls->sei_fp_type]);\n\t}\n\n\tif (ctx->sys_errors || ctx->encode_errors || ctx->frame_errors) {\n\t\tseq_puts(s, \"  |\\n  |-[errors]\\n\");\n\t\tseq_printf(s, \"  | |- system=%d\\n\"\n\t\t\t      \"  | |- encoding=%d\\n\"\n\t\t\t      \"  | |- frame=%d\\n\",\n\t\t\t      ctx->sys_errors,\n\t\t\t      ctx->encode_errors,\n\t\t\t      ctx->frame_errors);\n\t}\n\n\tseq_puts(s, \"  |\\n  |-[performances]\\n\");\n\tseq_printf(s, \"  | |- frames encoded=%d\\n\"\n\t\t      \"  | |- avg HW processing duration (0.1ms)=%d [min=%d, max=%d]\\n\"\n\t\t      \"  | |- avg encoding period (0.1ms)=%d [min=%d, max=%d]\\n\"\n\t\t      \"  | |- avg fps (0.1Hz)=%d\\n\"\n\t\t      \"  | |- max reachable fps (0.1Hz)=%d\\n\"\n\t\t      \"  | |- avg bitrate (kbps)=%d [min=%d, max=%d]\\n\"\n\t\t      \"  | |- last bitrate (kbps)=%d\\n\",\n\t\t      dbg->cnt_duration,\n\t\t      dbg->avg_duration,\n\t\t      dbg->min_duration,\n\t\t      dbg->max_duration,\n\t\t      dbg->avg_period,\n\t\t      dbg->min_period,\n\t\t      dbg->max_period,\n\t\t      dbg->avg_fps,\n\t\t      dbg->max_fps,\n\t\t      dbg->avg_bitrate,\n\t\t      dbg->min_bitrate,\n\t\t      dbg->max_bitrate,\n\t\t      dbg->last_bitrate);\n}\n\n \nvoid hva_dbg_perf_begin(struct hva_ctx *ctx)\n{\n\tu64 div;\n\tu32 period;\n\tu32 bitrate;\n\tstruct hva_ctx_dbg *dbg = &ctx->dbg;\n\tktime_t prev = dbg->begin;\n\n\tdbg->begin = ktime_get();\n\n\tif (dbg->is_valid_period) {\n\t\t \n\t\tdiv = (u64)ktime_us_delta(dbg->begin, prev);\n\t\tdo_div(div, 100);\n\t\tperiod = (u32)div;\n\t\tdbg->min_period = min(period, dbg->min_period);\n\t\tdbg->max_period = max(period, dbg->max_period);\n\t\tdbg->total_period += period;\n\t\tdbg->cnt_period++;\n\n\t\t \n\t\tdbg->window_duration += period;\n\t\tdbg->cnt_window++;\n\t\tif (dbg->cnt_window >= 32) {\n\t\t\t \n\t\t\tif (dbg->window_duration > 0) {\n\t\t\t\tdiv = (u64)dbg->window_stream_size * 80;\n\t\t\t\tdo_div(div, dbg->window_duration);\n\t\t\t\tbitrate = (u32)div;\n\t\t\t\tdbg->last_bitrate = bitrate;\n\t\t\t\tdbg->min_bitrate = min(bitrate,\n\t\t\t\t\t\t       dbg->min_bitrate);\n\t\t\t\tdbg->max_bitrate = max(bitrate,\n\t\t\t\t\t\t       dbg->max_bitrate);\n\t\t\t}\n\t\t\tdbg->window_stream_size = 0;\n\t\t\tdbg->window_duration = 0;\n\t\t\tdbg->cnt_window = 0;\n\t\t}\n\t}\n\n\t \n\tdbg->is_valid_period = false;\n}\n\nvoid hva_dbg_perf_end(struct hva_ctx *ctx, struct hva_stream *stream)\n{\n\tstruct device *dev = ctx_to_dev(ctx);\n\tu64 div;\n\tu32 duration;\n\tu32 bytesused;\n\tu32 timestamp;\n\tstruct hva_ctx_dbg *dbg = &ctx->dbg;\n\tktime_t end = ktime_get();\n\n\t \n\tbytesused = vb2_get_plane_payload(&stream->vbuf.vb2_buf, 0);\n\tdiv = stream->vbuf.vb2_buf.timestamp;\n\tdo_div(div, 1000);\n\ttimestamp = (u32)div;\n\n\t \n\tdiv = (u64)ktime_us_delta(end, dbg->begin);\n\n\tdev_dbg(dev,\n\t\t\"%s perf stream[%d] dts=%d encoded using %d bytes in %d us\",\n\t\tctx->name,\n\t\tstream->vbuf.sequence,\n\t\ttimestamp,\n\t\tbytesused, (u32)div);\n\n\tdo_div(div, 100);\n\tduration = (u32)div;\n\n\tdbg->min_duration = min(duration, dbg->min_duration);\n\tdbg->max_duration = max(duration, dbg->max_duration);\n\tdbg->total_duration += duration;\n\tdbg->cnt_duration++;\n\n\t \n\tdbg->total_stream_size += bytesused;\n\tdbg->window_stream_size += bytesused;\n\n\tdbg->is_valid_period = true;\n}\n\nstatic void hva_dbg_perf_compute(struct hva_ctx *ctx)\n{\n\tu64 div;\n\tstruct hva_ctx_dbg *dbg = &ctx->dbg;\n\n\tif (dbg->cnt_duration > 0) {\n\t\tdiv = (u64)dbg->total_duration;\n\t\tdo_div(div, dbg->cnt_duration);\n\t\tdbg->avg_duration = (u32)div;\n\t} else {\n\t\tdbg->avg_duration = 0;\n\t}\n\n\tif (dbg->total_duration > 0) {\n\t\tdiv = (u64)dbg->cnt_duration * 100000;\n\t\tdo_div(div, dbg->total_duration);\n\t\tdbg->max_fps = (u32)div;\n\t} else {\n\t\tdbg->max_fps = 0;\n\t}\n\n\tif (dbg->cnt_period > 0) {\n\t\tdiv = (u64)dbg->total_period;\n\t\tdo_div(div, dbg->cnt_period);\n\t\tdbg->avg_period = (u32)div;\n\t} else {\n\t\tdbg->avg_period = 0;\n\t}\n\n\tif (dbg->total_period > 0) {\n\t\tdiv = (u64)dbg->cnt_period * 100000;\n\t\tdo_div(div, dbg->total_period);\n\t\tdbg->avg_fps = (u32)div;\n\t} else {\n\t\tdbg->avg_fps = 0;\n\t}\n\n\tif (dbg->total_period > 0) {\n\t\t \n\t\tdiv = (u64)dbg->total_stream_size * 80;\n\t\tdo_div(div, dbg->total_period);\n\t\tdbg->avg_bitrate = (u32)div;\n\t} else {\n\t\tdbg->avg_bitrate = 0;\n\t}\n}\n\n \n\nstatic int device_show(struct seq_file *s, void *data)\n{\n\tstruct hva_dev *hva = s->private;\n\n\tseq_printf(s, \"[%s]\\n\", hva->v4l2_dev.name);\n\tseq_printf(s, \"registered as /dev/video%d\\n\", hva->vdev->num);\n\n\treturn 0;\n}\n\nstatic int encoders_show(struct seq_file *s, void *data)\n{\n\tstruct hva_dev *hva = s->private;\n\tunsigned int i = 0;\n\n\tseq_printf(s, \"[encoders]\\n|- %d registered encoders:\\n\",\n\t\t   hva->nb_of_encoders);\n\n\twhile (hva->encoders[i]) {\n\t\tseq_printf(s, \"|- %s: %4.4s => %4.4s\\n\", hva->encoders[i]->name,\n\t\t\t   (char *)&hva->encoders[i]->pixelformat,\n\t\t\t   (char *)&hva->encoders[i]->streamformat);\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int last_show(struct seq_file *s, void *data)\n{\n\tstruct hva_dev *hva = s->private;\n\tstruct hva_ctx *last_ctx = &hva->dbg.last_ctx;\n\n\tif (last_ctx->flags & HVA_FLAG_STREAMINFO) {\n\t\tseq_puts(s, \"[last encoding]\\n\");\n\n\t\thva_dbg_perf_compute(last_ctx);\n\t\tformat_ctx(s, last_ctx);\n\t} else {\n\t\tseq_puts(s, \"[no information recorded about last encoding]\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int regs_show(struct seq_file *s, void *data)\n{\n\tstruct hva_dev *hva = s->private;\n\n\thva_hw_dump_regs(hva, s);\n\n\treturn 0;\n}\n\n#define hva_dbg_create_entry(name)\t\t\t\t\t \\\n\tdebugfs_create_file(#name, 0444, hva->dbg.debugfs_entry, hva, \\\n\t\t\t    &name##_fops)\n\nDEFINE_SHOW_ATTRIBUTE(device);\nDEFINE_SHOW_ATTRIBUTE(encoders);\nDEFINE_SHOW_ATTRIBUTE(last);\nDEFINE_SHOW_ATTRIBUTE(regs);\n\nvoid hva_debugfs_create(struct hva_dev *hva)\n{\n\thva->dbg.debugfs_entry = debugfs_create_dir(HVA_NAME, NULL);\n\n\thva_dbg_create_entry(device);\n\thva_dbg_create_entry(encoders);\n\thva_dbg_create_entry(last);\n\thva_dbg_create_entry(regs);\n}\n\nvoid hva_debugfs_remove(struct hva_dev *hva)\n{\n\tdebugfs_remove_recursive(hva->dbg.debugfs_entry);\n\thva->dbg.debugfs_entry = NULL;\n}\n\n \n\nstatic int ctx_show(struct seq_file *s, void *data)\n{\n\tstruct hva_ctx *ctx = s->private;\n\n\tseq_printf(s, \"[running encoding %d]\\n\", ctx->id);\n\n\thva_dbg_perf_compute(ctx);\n\tformat_ctx(s, ctx);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(ctx);\n\nvoid hva_dbg_ctx_create(struct hva_ctx *ctx)\n{\n\tstruct hva_dev *hva = ctx->hva_dev;\n\tchar name[4] = \"\";\n\n\tctx->dbg.min_duration = UINT_MAX;\n\tctx->dbg.min_period = UINT_MAX;\n\tctx->dbg.min_bitrate = UINT_MAX;\n\n\tsnprintf(name, sizeof(name), \"%d\", hva->instance_id);\n\n\tctx->dbg.debugfs_entry = debugfs_create_file(name, 0444,\n\t\t\t\t\t\t     hva->dbg.debugfs_entry,\n\t\t\t\t\t\t     ctx, &ctx_fops);\n}\n\nvoid hva_dbg_ctx_remove(struct hva_ctx *ctx)\n{\n\tstruct hva_dev *hva = ctx->hva_dev;\n\n\tif (ctx->flags & HVA_FLAG_STREAMINFO)\n\t\t \n\t\tmemcpy(&hva->dbg.last_ctx, ctx, sizeof(*ctx));\n\n\tdebugfs_remove(ctx->dbg.debugfs_entry);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}