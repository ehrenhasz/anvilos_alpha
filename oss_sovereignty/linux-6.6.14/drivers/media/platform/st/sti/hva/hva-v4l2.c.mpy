{
  "module_name": "hva-v4l2.c",
  "hash_id": "a8cda8912f03ee0ae864f87931a2fdc601cc1499ae4f106bfbc5d8298890a251",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/st/sti/hva/hva-v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"hva.h\"\n#include \"hva-hw.h\"\n\n#define MIN_FRAMES\t1\n#define MIN_STREAMS\t1\n\n#define HVA_MIN_WIDTH\t32\n#define HVA_MAX_WIDTH\t1920\n#define HVA_MIN_HEIGHT\t32\n#define HVA_MAX_HEIGHT\t1920\n\n \n#define HVA_WIDTH_ALIGNMENT\t16\n#define HVA_HEIGHT_ALIGNMENT\t16\n\n#define HVA_DEFAULT_WIDTH\tHVA_MIN_WIDTH\n#define\tHVA_DEFAULT_HEIGHT\tHVA_MIN_HEIGHT\n#define HVA_DEFAULT_FRAME_NUM\t1\n#define HVA_DEFAULT_FRAME_DEN\t30\n\n#define to_type_str(type) (type == V4L2_BUF_TYPE_VIDEO_OUTPUT ? \\\n\t\t\t   \"frame\" : \"stream\")\n\n#define fh_to_ctx(f)    (container_of(f, struct hva_ctx, fh))\n\n \nstatic const struct hva_enc *hva_encoders[] = {\n\t&nv12h264enc,\n\t&nv21h264enc,\n};\n\nstatic inline int frame_size(u32 w, u32 h, u32 fmt)\n{\n\tswitch (fmt) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\treturn (w * h * 3) / 2;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline int frame_stride(u32 w, u32 fmt)\n{\n\tswitch (fmt) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\treturn w;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline int frame_alignment(u32 fmt)\n{\n\tswitch (fmt) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\t \n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic inline int estimated_stream_size(u32 w, u32 h)\n{\n\t \n\treturn (w * h * 3) / 4;\n}\n\nstatic void set_default_params(struct hva_ctx *ctx)\n{\n\tstruct hva_frameinfo *frameinfo = &ctx->frameinfo;\n\tstruct hva_streaminfo *streaminfo = &ctx->streaminfo;\n\n\tframeinfo->pixelformat = V4L2_PIX_FMT_NV12;\n\tframeinfo->width = HVA_DEFAULT_WIDTH;\n\tframeinfo->height = HVA_DEFAULT_HEIGHT;\n\tframeinfo->aligned_width = ALIGN(frameinfo->width,\n\t\t\t\t\t HVA_WIDTH_ALIGNMENT);\n\tframeinfo->aligned_height = ALIGN(frameinfo->height,\n\t\t\t\t\t  HVA_HEIGHT_ALIGNMENT);\n\tframeinfo->size = frame_size(frameinfo->aligned_width,\n\t\t\t\t     frameinfo->aligned_height,\n\t\t\t\t     frameinfo->pixelformat);\n\n\tstreaminfo->streamformat = V4L2_PIX_FMT_H264;\n\tstreaminfo->width = HVA_DEFAULT_WIDTH;\n\tstreaminfo->height = HVA_DEFAULT_HEIGHT;\n\n\tctx->colorspace = V4L2_COLORSPACE_REC709;\n\tctx->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\tctx->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tctx->quantization = V4L2_QUANTIZATION_DEFAULT;\n\n\tctx->max_stream_size = estimated_stream_size(streaminfo->width,\n\t\t\t\t\t\t     streaminfo->height);\n}\n\nstatic const struct hva_enc *hva_find_encoder(struct hva_ctx *ctx,\n\t\t\t\t\t      u32 pixelformat,\n\t\t\t\t\t      u32 streamformat)\n{\n\tstruct hva_dev *hva = ctx_to_hdev(ctx);\n\tconst struct hva_enc *enc;\n\tunsigned int i;\n\n\tfor (i = 0; i < hva->nb_of_encoders; i++) {\n\t\tenc = hva->encoders[i];\n\t\tif ((enc->pixelformat == pixelformat) &&\n\t\t    (enc->streamformat == streamformat))\n\t\t\treturn enc;\n\t}\n\n\treturn NULL;\n}\n\nstatic void register_format(u32 format, u32 formats[], u32 *nb_of_formats)\n{\n\tu32 i;\n\tbool found = false;\n\n\tfor (i = 0; i < *nb_of_formats; i++) {\n\t\tif (format == formats[i]) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tformats[(*nb_of_formats)++] = format;\n}\n\nstatic void register_formats(struct hva_dev *hva)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hva->nb_of_encoders; i++) {\n\t\tregister_format(hva->encoders[i]->pixelformat,\n\t\t\t\thva->pixelformats,\n\t\t\t\t&hva->nb_of_pixelformats);\n\n\t\tregister_format(hva->encoders[i]->streamformat,\n\t\t\t\thva->streamformats,\n\t\t\t\t&hva->nb_of_streamformats);\n\t}\n}\n\nstatic void register_encoders(struct hva_dev *hva)\n{\n\tstruct device *dev = hva_to_dev(hva);\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hva_encoders); i++) {\n\t\tif (hva->nb_of_encoders >= HVA_MAX_ENCODERS) {\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"%s failed to register %s encoder (%d maximum reached)\\n\",\n\t\t\t\tHVA_PREFIX, hva_encoders[i]->name,\n\t\t\t\tHVA_MAX_ENCODERS);\n\t\t\treturn;\n\t\t}\n\n\t\thva->encoders[hva->nb_of_encoders++] = hva_encoders[i];\n\t\tdev_info(dev, \"%s %s encoder registered\\n\", HVA_PREFIX,\n\t\t\t hva_encoders[i]->name);\n\t}\n}\n\nstatic int hva_open_encoder(struct hva_ctx *ctx, u32 streamformat,\n\t\t\t    u32 pixelformat, struct hva_enc **penc)\n{\n\tstruct hva_dev *hva = ctx_to_hdev(ctx);\n\tstruct device *dev = ctx_to_dev(ctx);\n\tstruct hva_enc *enc;\n\tint ret;\n\n\t \n\tenc = (struct hva_enc *)hva_find_encoder(ctx, pixelformat,\n\t\t\t\t\t\t streamformat);\n\tif (!enc) {\n\t\tdev_err(dev, \"%s no encoder found matching %4.4s => %4.4s\\n\",\n\t\t\tctx->name, (char *)&pixelformat, (char *)&streamformat);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"%s one encoder matching %4.4s => %4.4s\\n\",\n\t\tctx->name, (char *)&pixelformat, (char *)&streamformat);\n\n\t \n\tsnprintf(ctx->name, sizeof(ctx->name), \"[%3d:%4.4s]\",\n\t\t hva->instance_id, (char *)&streamformat);\n\n\t \n\tret = enc->open(ctx);\n\tif (ret) {\n\t\tdev_err(dev, \"%s failed to open encoder instance (%d)\\n\",\n\t\t\tctx->name, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"%s %s encoder opened\\n\", ctx->name, enc->name);\n\n\t*penc = enc;\n\n\treturn ret;\n}\n\nstatic void hva_dbg_summary(struct hva_ctx *ctx)\n{\n\tstruct device *dev = ctx_to_dev(ctx);\n\tstruct hva_streaminfo *stream = &ctx->streaminfo;\n\tstruct hva_frameinfo *frame = &ctx->frameinfo;\n\n\tif (!(ctx->flags & HVA_FLAG_STREAMINFO))\n\t\treturn;\n\n\tdev_dbg(dev, \"%s %4.4s %dx%d > %4.4s %dx%d %s %s: %d frames encoded, %d system errors, %d encoding errors, %d frame errors\\n\",\n\t\tctx->name,\n\t\t(char *)&frame->pixelformat,\n\t\tframe->aligned_width, frame->aligned_height,\n\t\t(char *)&stream->streamformat,\n\t\tstream->width, stream->height,\n\t\tstream->profile, stream->level,\n\t\tctx->encoded_frames,\n\t\tctx->sys_errors,\n\t\tctx->encode_errors,\n\t\tctx->frame_errors);\n}\n\n \n\nstatic int hva_querycap(struct file *file, void *priv,\n\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct hva_dev *hva = ctx_to_hdev(ctx);\n\n\tstrscpy(cap->driver, HVA_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, hva->vdev->name, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"platform:%s\",\n\t\t hva->pdev->name);\n\n\treturn 0;\n}\n\nstatic int hva_enum_fmt_stream(struct file *file, void *priv,\n\t\t\t       struct v4l2_fmtdesc *f)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct hva_dev *hva = ctx_to_hdev(ctx);\n\n\tif (unlikely(f->index >= hva->nb_of_streamformats))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = hva->streamformats[f->index];\n\n\treturn 0;\n}\n\nstatic int hva_enum_fmt_frame(struct file *file, void *priv,\n\t\t\t      struct v4l2_fmtdesc *f)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct hva_dev *hva = ctx_to_hdev(ctx);\n\n\tif (unlikely(f->index >= hva->nb_of_pixelformats))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = hva->pixelformats[f->index];\n\n\treturn 0;\n}\n\nstatic int hva_g_fmt_stream(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct hva_streaminfo *streaminfo = &ctx->streaminfo;\n\n\tf->fmt.pix.width = streaminfo->width;\n\tf->fmt.pix.height = streaminfo->height;\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\tf->fmt.pix.colorspace = ctx->colorspace;\n\tf->fmt.pix.xfer_func = ctx->xfer_func;\n\tf->fmt.pix.ycbcr_enc = ctx->ycbcr_enc;\n\tf->fmt.pix.quantization = ctx->quantization;\n\tf->fmt.pix.pixelformat = streaminfo->streamformat;\n\tf->fmt.pix.bytesperline = 0;\n\tf->fmt.pix.sizeimage = ctx->max_stream_size;\n\n\treturn 0;\n}\n\nstatic int hva_g_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct hva_frameinfo *frameinfo = &ctx->frameinfo;\n\n\tf->fmt.pix.width = frameinfo->width;\n\tf->fmt.pix.height = frameinfo->height;\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\tf->fmt.pix.colorspace = ctx->colorspace;\n\tf->fmt.pix.xfer_func = ctx->xfer_func;\n\tf->fmt.pix.ycbcr_enc = ctx->ycbcr_enc;\n\tf->fmt.pix.quantization = ctx->quantization;\n\tf->fmt.pix.pixelformat = frameinfo->pixelformat;\n\tf->fmt.pix.bytesperline = frame_stride(frameinfo->aligned_width,\n\t\t\t\t\t       frameinfo->pixelformat);\n\tf->fmt.pix.sizeimage = frameinfo->size;\n\n\treturn 0;\n}\n\nstatic int hva_try_fmt_stream(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct device *dev = ctx_to_dev(ctx);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tu32 streamformat = pix->pixelformat;\n\tconst struct hva_enc *enc;\n\tu32 width, height;\n\tu32 stream_size;\n\n\tenc = hva_find_encoder(ctx, ctx->frameinfo.pixelformat, streamformat);\n\tif (!enc) {\n\t\tdev_dbg(dev,\n\t\t\t\"%s V4L2 TRY_FMT (CAPTURE): unsupported format %.4s\\n\",\n\t\t\tctx->name, (char *)&pix->pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\twidth = pix->width;\n\theight = pix->height;\n\tif (ctx->flags & HVA_FLAG_FRAMEINFO) {\n\t\t \n\t\tpix->width = ctx->frameinfo.width;\n\t\tpix->height = ctx->frameinfo.height;\n\t\tif ((pix->width != width) || (pix->height != height))\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"%s V4L2 TRY_FMT (CAPTURE): resolution updated %dx%d -> %dx%d to fit frame resolution\\n\",\n\t\t\t\tctx->name, width, height,\n\t\t\t\tpix->width, pix->height);\n\t} else {\n\t\t \n\t\tv4l_bound_align_image(&pix->width,\n\t\t\t\t      HVA_MIN_WIDTH, enc->max_width,\n\t\t\t\t      0,\n\t\t\t\t      &pix->height,\n\t\t\t\t      HVA_MIN_HEIGHT, enc->max_height,\n\t\t\t\t      0,\n\t\t\t\t      0);\n\n\t\tif ((pix->width != width) || (pix->height != height))\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"%s V4L2 TRY_FMT (CAPTURE): resolution updated %dx%d -> %dx%d to fit min/max/alignment\\n\",\n\t\t\t\tctx->name, width, height,\n\t\t\t\tpix->width, pix->height);\n\t}\n\n\tstream_size = estimated_stream_size(pix->width, pix->height);\n\tif (pix->sizeimage < stream_size)\n\t\tpix->sizeimage = stream_size;\n\n\tpix->bytesperline = 0;\n\tpix->colorspace = ctx->colorspace;\n\tpix->xfer_func = ctx->xfer_func;\n\tpix->ycbcr_enc = ctx->ycbcr_enc;\n\tpix->quantization = ctx->quantization;\n\tpix->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int hva_try_fmt_frame(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct device *dev = ctx_to_dev(ctx);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tu32 pixelformat = pix->pixelformat;\n\tconst struct hva_enc *enc;\n\tu32 width, height;\n\n\tenc = hva_find_encoder(ctx, pixelformat, ctx->streaminfo.streamformat);\n\tif (!enc) {\n\t\tdev_dbg(dev,\n\t\t\t\"%s V4L2 TRY_FMT (OUTPUT): unsupported format %.4s\\n\",\n\t\t\tctx->name, (char *)&pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twidth = pix->width;\n\theight = pix->height;\n\tv4l_bound_align_image(&pix->width,\n\t\t\t      HVA_MIN_WIDTH, HVA_MAX_WIDTH,\n\t\t\t      frame_alignment(pixelformat) - 1,\n\t\t\t      &pix->height,\n\t\t\t      HVA_MIN_HEIGHT, HVA_MAX_HEIGHT,\n\t\t\t      frame_alignment(pixelformat) - 1,\n\t\t\t      0);\n\n\tif ((pix->width != width) || (pix->height != height))\n\t\tdev_dbg(dev,\n\t\t\t\"%s V4L2 TRY_FMT (OUTPUT): resolution updated %dx%d -> %dx%d to fit min/max/alignment\\n\",\n\t\t\tctx->name, width, height, pix->width, pix->height);\n\n\twidth = ALIGN(pix->width, HVA_WIDTH_ALIGNMENT);\n\theight = ALIGN(pix->height, HVA_HEIGHT_ALIGNMENT);\n\n\tif (!pix->colorspace) {\n\t\tpix->colorspace = V4L2_COLORSPACE_REC709;\n\t\tpix->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\t\tpix->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\t\tpix->quantization = V4L2_QUANTIZATION_DEFAULT;\n\t}\n\n\tpix->bytesperline = frame_stride(width, pixelformat);\n\tpix->sizeimage = frame_size(width, height, pixelformat);\n\tpix->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int hva_s_fmt_stream(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct device *dev = ctx_to_dev(ctx);\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tret = hva_try_fmt_stream(file, fh, f);\n\tif (ret) {\n\t\tdev_dbg(dev, \"%s V4L2 S_FMT (CAPTURE): unsupported format %.4s\\n\",\n\t\t\tctx->name, (char *)&f->fmt.pix.pixelformat);\n\t\treturn ret;\n\t}\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_streaming(vq)) {\n\t\tdev_dbg(dev, \"%s V4L2 S_FMT (CAPTURE): queue busy\\n\",\n\t\t\tctx->name);\n\t\treturn -EBUSY;\n\t}\n\n\tctx->max_stream_size = f->fmt.pix.sizeimage;\n\tctx->streaminfo.width = f->fmt.pix.width;\n\tctx->streaminfo.height = f->fmt.pix.height;\n\tctx->streaminfo.streamformat = f->fmt.pix.pixelformat;\n\tctx->flags |= HVA_FLAG_STREAMINFO;\n\n\treturn 0;\n}\n\nstatic int hva_s_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct device *dev = ctx_to_dev(ctx);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tret = hva_try_fmt_frame(file, fh, f);\n\tif (ret) {\n\t\tdev_dbg(dev, \"%s V4L2 S_FMT (OUTPUT): unsupported format %.4s\\n\",\n\t\t\tctx->name, (char *)&pix->pixelformat);\n\t\treturn ret;\n\t}\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_streaming(vq)) {\n\t\tdev_dbg(dev, \"%s V4L2 S_FMT (OUTPUT): queue busy\\n\", ctx->name);\n\t\treturn -EBUSY;\n\t}\n\n\tctx->colorspace = pix->colorspace;\n\tctx->xfer_func = pix->xfer_func;\n\tctx->ycbcr_enc = pix->ycbcr_enc;\n\tctx->quantization = pix->quantization;\n\n\tctx->frameinfo.aligned_width = ALIGN(pix->width, HVA_WIDTH_ALIGNMENT);\n\tctx->frameinfo.aligned_height = ALIGN(pix->height,\n\t\t\t\t\t      HVA_HEIGHT_ALIGNMENT);\n\tctx->frameinfo.size = pix->sizeimage;\n\tctx->frameinfo.pixelformat = pix->pixelformat;\n\tctx->frameinfo.width = pix->width;\n\tctx->frameinfo.height = pix->height;\n\tctx->flags |= HVA_FLAG_FRAMEINFO;\n\n\treturn 0;\n}\n\nstatic int hva_g_parm(struct file *file, void *fh, struct v4l2_streamparm *sp)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct v4l2_fract *time_per_frame = &ctx->ctrls.time_per_frame;\n\n\tif (sp->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tsp->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\n\tsp->parm.output.timeperframe.numerator = time_per_frame->numerator;\n\tsp->parm.output.timeperframe.denominator =\n\t\ttime_per_frame->denominator;\n\n\treturn 0;\n}\n\nstatic int hva_s_parm(struct file *file, void *fh, struct v4l2_streamparm *sp)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct v4l2_fract *time_per_frame = &ctx->ctrls.time_per_frame;\n\n\tif (sp->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tif (!sp->parm.output.timeperframe.numerator ||\n\t    !sp->parm.output.timeperframe.denominator)\n\t\treturn hva_g_parm(file, fh, sp);\n\n\tsp->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\n\ttime_per_frame->numerator = sp->parm.output.timeperframe.numerator;\n\ttime_per_frame->denominator =\n\t\tsp->parm.output.timeperframe.denominator;\n\n\treturn 0;\n}\n\nstatic int hva_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct device *dev = ctx_to_dev(ctx);\n\n\tif (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\t \n\t\tstruct vb2_queue *vq;\n\t\tstruct hva_stream *stream;\n\t\tstruct vb2_buffer *vb2_buf;\n\n\t\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, buf->type);\n\n\t\tif (buf->index >= vq->num_buffers) {\n\t\t\tdev_dbg(dev, \"%s buffer index %d out of range (%d)\\n\",\n\t\t\t\tctx->name, buf->index, vq->num_buffers);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvb2_buf = vb2_get_buffer(vq, buf->index);\n\t\tstream = to_hva_stream(to_vb2_v4l2_buffer(vb2_buf));\n\t\tstream->bytesused = buf->bytesused;\n\t}\n\n\treturn v4l2_m2m_qbuf(file, ctx->fh.m2m_ctx, buf);\n}\n\n \nstatic const struct v4l2_ioctl_ops hva_ioctl_ops = {\n\t.vidioc_querycap\t\t= hva_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= hva_enum_fmt_stream,\n\t.vidioc_enum_fmt_vid_out\t= hva_enum_fmt_frame,\n\t.vidioc_g_fmt_vid_cap\t\t= hva_g_fmt_stream,\n\t.vidioc_g_fmt_vid_out\t\t= hva_g_fmt_frame,\n\t.vidioc_try_fmt_vid_cap\t\t= hva_try_fmt_stream,\n\t.vidioc_try_fmt_vid_out\t\t= hva_try_fmt_frame,\n\t.vidioc_s_fmt_vid_cap\t\t= hva_s_fmt_stream,\n\t.vidioc_s_fmt_vid_out\t\t= hva_s_fmt_frame,\n\t.vidioc_g_parm\t\t\t= hva_g_parm,\n\t.vidioc_s_parm\t\t\t= hva_s_parm,\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_create_bufs             = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\t.vidioc_qbuf\t\t\t= hva_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\n \n\nstatic int hva_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct hva_ctx *ctx = container_of(ctrl->handler, struct hva_ctx,\n\t\t\t\t\t   ctrl_handler);\n\tstruct device *dev = ctx_to_dev(ctx);\n\n\tdev_dbg(dev, \"%s S_CTRL: id = %d, val = %d\\n\", ctx->name,\n\t\tctrl->id, ctrl->val);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\n\t\tctx->ctrls.bitrate_mode = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\n\t\tctx->ctrls.gop_size = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE:\n\t\tctx->ctrls.bitrate = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_ASPECT:\n\t\tctx->ctrls.aspect = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_PROFILE:\n\t\tctx->ctrls.profile = ctrl->val;\n\t\tsnprintf(ctx->streaminfo.profile,\n\t\t\t sizeof(ctx->streaminfo.profile),\n\t\t\t \"%s profile\",\n\t\t\t v4l2_ctrl_get_menu(ctrl->id)[ctrl->val]);\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_LEVEL:\n\t\tctx->ctrls.level = ctrl->val;\n\t\tsnprintf(ctx->streaminfo.level,\n\t\t\t sizeof(ctx->streaminfo.level),\n\t\t\t \"level %s\",\n\t\t\t v4l2_ctrl_get_menu(ctrl->id)[ctrl->val]);\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:\n\t\tctx->ctrls.entropy_mode = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE:\n\t\tctx->ctrls.cpb_size = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM:\n\t\tctx->ctrls.dct8x8 = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_MIN_QP:\n\t\tctx->ctrls.qpmin = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_MAX_QP:\n\t\tctx->ctrls.qpmax = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE:\n\t\tctx->ctrls.vui_sar = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:\n\t\tctx->ctrls.vui_sar_idc = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING:\n\t\tctx->ctrls.sei_fp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE:\n\t\tctx->ctrls.sei_fp_type = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"%s S_CTRL: invalid control (id = %d)\\n\",\n\t\t\tctx->name, ctrl->id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct v4l2_ctrl_ops hva_ctrl_ops = {\n\t.s_ctrl = hva_s_ctrl,\n};\n\nstatic int hva_ctrls_setup(struct hva_ctx *ctx)\n{\n\tstruct device *dev = ctx_to_dev(ctx);\n\tu64 mask;\n\tenum v4l2_mpeg_video_h264_sei_fp_arrangement_type sei_fp_type =\n\t\tV4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TOP_BOTTOM;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, 15);\n\n\tv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_BITRATE_MODE,\n\t\t\t       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR,\n\t\t\t       0,\n\t\t\t       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_GOP_SIZE,\n\t\t\t  1, 60, 1, 16);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_BITRATE,\n\t\t\t  1000, 60000000, 1000, 20000000);\n\n\tmask = ~(1 << V4L2_MPEG_VIDEO_ASPECT_1x1);\n\tv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_ASPECT,\n\t\t\t       V4L2_MPEG_VIDEO_ASPECT_1x1,\n\t\t\t       mask,\n\t\t\t       V4L2_MPEG_VIDEO_ASPECT_1x1);\n\n\tmask = ~((1 << V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE) |\n\t\t (1 << V4L2_MPEG_VIDEO_H264_PROFILE_MAIN) |\n\t\t (1 << V4L2_MPEG_VIDEO_H264_PROFILE_HIGH) |\n\t\t (1 << V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH));\n\tv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_H264_PROFILE,\n\t\t\t       V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH,\n\t\t\t       mask,\n\t\t\t       V4L2_MPEG_VIDEO_H264_PROFILE_HIGH);\n\n\tv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_H264_LEVEL,\n\t\t\t       V4L2_MPEG_VIDEO_H264_LEVEL_4_2,\n\t\t\t       0,\n\t\t\t       V4L2_MPEG_VIDEO_H264_LEVEL_4_0);\n\n\tv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE,\n\t\t\t       V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC,\n\t\t\t       0,\n\t\t\t       V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE,\n\t\t\t  1, 10000, 1, 3000);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM,\n\t\t\t  0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_MIN_QP,\n\t\t\t  0, 51, 1, 5);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_MAX_QP,\n\t\t\t  0, 51, 1, 51);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE,\n\t\t\t  0, 1, 1, 1);\n\n\tmask = ~(1 << V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1);\n\tv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC,\n\t\t\t       V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1,\n\t\t\t       mask,\n\t\t\t       V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING,\n\t\t\t  0, 1, 1, 0);\n\n\tmask = ~(1 << sei_fp_type);\n\tv4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE,\n\t\t\t       sei_fp_type,\n\t\t\t       mask,\n\t\t\t       sei_fp_type);\n\n\tif (ctx->ctrl_handler.error) {\n\t\tint err = ctx->ctrl_handler.error;\n\n\t\tdev_dbg(dev, \"%s controls setup failed (%d)\\n\",\n\t\t\tctx->name, err);\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\t\treturn err;\n\t}\n\n\tv4l2_ctrl_handler_setup(&ctx->ctrl_handler);\n\n\t \n\tctx->ctrls.time_per_frame.numerator = HVA_DEFAULT_FRAME_NUM;\n\tctx->ctrls.time_per_frame.denominator = HVA_DEFAULT_FRAME_DEN;\n\n\treturn 0;\n}\n\n \n\nstatic void hva_run_work(struct work_struct *work)\n{\n\tstruct hva_ctx *ctx = container_of(work, struct hva_ctx, run_work);\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tconst struct hva_enc *enc = ctx->enc;\n\tstruct hva_frame *frame;\n\tstruct hva_stream *stream;\n\tint ret;\n\n\t \n\tmutex_lock(&ctx->lock);\n\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\n\thva_dbg_perf_begin(ctx);\n#endif\n\n\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tframe = to_hva_frame(src_buf);\n\tstream = to_hva_stream(dst_buf);\n\tframe->vbuf.sequence = ctx->frame_num++;\n\n\tret = enc->encode(ctx, frame, stream);\n\n\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, stream->bytesused);\n\tif (ret) {\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\n\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\n\t} else {\n\t\t \n\t\tdst_buf->vb2_buf.timestamp = src_buf->vb2_buf.timestamp;\n\t\tdst_buf->field = V4L2_FIELD_NONE;\n\t\tdst_buf->sequence = ctx->stream_num - 1;\n\n\t\tctx->encoded_frames++;\n\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\n\t\thva_dbg_perf_end(ctx, stream);\n#endif\n\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);\n\t}\n\n\tmutex_unlock(&ctx->lock);\n\n\tv4l2_m2m_job_finish(ctx->hva_dev->m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic void hva_device_run(void *priv)\n{\n\tstruct hva_ctx *ctx = priv;\n\tstruct hva_dev *hva = ctx_to_hdev(ctx);\n\n\tqueue_work(hva->work_queue, &ctx->run_work);\n}\n\nstatic void hva_job_abort(void *priv)\n{\n\tstruct hva_ctx *ctx = priv;\n\tstruct device *dev = ctx_to_dev(ctx);\n\n\tdev_dbg(dev, \"%s aborting job\\n\", ctx->name);\n\n\tctx->aborting = true;\n}\n\nstatic int hva_job_ready(void *priv)\n{\n\tstruct hva_ctx *ctx = priv;\n\tstruct device *dev = ctx_to_dev(ctx);\n\n\tif (!v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx)) {\n\t\tdev_dbg(dev, \"%s job not ready: no frame buffers\\n\",\n\t\t\tctx->name);\n\t\treturn 0;\n\t}\n\n\tif (!v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx)) {\n\t\tdev_dbg(dev, \"%s job not ready: no stream buffers\\n\",\n\t\t\tctx->name);\n\t\treturn 0;\n\t}\n\n\tif (ctx->aborting) {\n\t\tdev_dbg(dev, \"%s job not ready: aborting\\n\", ctx->name);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic const struct v4l2_m2m_ops hva_m2m_ops = {\n\t.device_run\t= hva_device_run,\n\t.job_abort\t= hva_job_abort,\n\t.job_ready\t= hva_job_ready,\n};\n\n \n\nstatic int hva_queue_setup(struct vb2_queue *vq,\n\t\t\t   unsigned int *num_buffers, unsigned int *num_planes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct hva_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct device *dev = ctx_to_dev(ctx);\n\tunsigned int size;\n\n\tdev_dbg(dev, \"%s %s queue setup: num_buffers %d\\n\", ctx->name,\n\t\tto_type_str(vq->type), *num_buffers);\n\n\tsize = vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT ?\n\t\tctx->frameinfo.size : ctx->max_stream_size;\n\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t \n\t*num_planes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic int hva_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct hva_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct device *dev = ctx_to_dev(ctx);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tif (vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tstruct hva_frame *frame = to_hva_frame(vbuf);\n\n\t\tif (vbuf->field == V4L2_FIELD_ANY)\n\t\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tif (vbuf->field != V4L2_FIELD_NONE) {\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"%s frame[%d] prepare: %d field not supported\\n\",\n\t\t\t\tctx->name, vb->index, vbuf->field);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!frame->prepared) {\n\t\t\t \n\t\t\tframe->vaddr = vb2_plane_vaddr(&vbuf->vb2_buf, 0);\n\t\t\tframe->paddr = vb2_dma_contig_plane_dma_addr(\n\t\t\t\t\t&vbuf->vb2_buf, 0);\n\t\t\tframe->info = ctx->frameinfo;\n\t\t\tframe->prepared = true;\n\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"%s frame[%d] prepared; virt=%p, phy=%pad\\n\",\n\t\t\t\tctx->name, vb->index,\n\t\t\t\tframe->vaddr, &frame->paddr);\n\t\t}\n\t} else {\n\t\tstruct hva_stream *stream = to_hva_stream(vbuf);\n\n\t\tif (!stream->prepared) {\n\t\t\t \n\t\t\tstream->vaddr = vb2_plane_vaddr(&vbuf->vb2_buf, 0);\n\t\t\tstream->paddr = vb2_dma_contig_plane_dma_addr(\n\t\t\t\t\t&vbuf->vb2_buf, 0);\n\t\t\tstream->size = vb2_plane_size(&vbuf->vb2_buf, 0);\n\t\t\tstream->prepared = true;\n\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"%s stream[%d] prepared; virt=%p, phy=%pad\\n\",\n\t\t\t\tctx->name, vb->index,\n\t\t\t\tstream->vaddr, &stream->paddr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void hva_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct hva_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tif (ctx->fh.m2m_ctx)\n\t\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int hva_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct hva_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct hva_dev *hva = ctx_to_hdev(ctx);\n\tstruct device *dev = ctx_to_dev(ctx);\n\tstruct vb2_v4l2_buffer *vbuf;\n\tint ret;\n\tunsigned int i;\n\tbool found = false;\n\n\tdev_dbg(dev, \"%s %s start streaming\\n\", ctx->name,\n\t\tto_type_str(vq->type));\n\n\t \n\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\tif (!vb2_start_streaming_called(&ctx->fh.m2m_ctx->cap_q_ctx.q))\n\t\t\treturn 0;\n\t} else {\n\t\tif (!vb2_start_streaming_called(&ctx->fh.m2m_ctx->out_q_ctx.q))\n\t\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < HVA_MAX_INSTANCES; i++) {\n\t\tif (!hva->instances[i]) {\n\t\t\thva->instances[i] = ctx;\n\t\t\t \n\t\t\tctx->id = i;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tdev_err(dev, \"%s maximum instances reached\\n\", ctx->name);\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\thva->nb_of_instances++;\n\n\tif (!ctx->enc) {\n\t\tret = hva_open_encoder(ctx,\n\t\t\t\t       ctx->streaminfo.streamformat,\n\t\t\t\t       ctx->frameinfo.pixelformat,\n\t\t\t\t       &ctx->enc);\n\t\tif (ret < 0)\n\t\t\tgoto err_ctx;\n\t}\n\n\treturn 0;\n\nerr_ctx:\n\thva->instances[ctx->id] = NULL;\n\thva->nb_of_instances--;\nerr:\n\tif (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\t \n\t\twhile ((vbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_QUEUED);\n\t} else {\n\t\t \n\t\twhile ((vbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_QUEUED);\n\t}\n\n\tctx->sys_errors++;\n\n\treturn ret;\n}\n\nstatic void hva_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct hva_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct hva_dev *hva = ctx_to_hdev(ctx);\n\tstruct device *dev = ctx_to_dev(ctx);\n\tconst struct hva_enc *enc = ctx->enc;\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tdev_dbg(dev, \"%s %s stop streaming\\n\", ctx->name,\n\t\tto_type_str(vq->type));\n\n\tif (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\t \n\t\tctx->frame_num = 0;\n\t\twhile ((vbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t} else {\n\t\t \n\t\tctx->stream_num = 0;\n\t\twhile ((vbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t}\n\n\tif ((V4L2_TYPE_IS_OUTPUT(vq->type) &&\n\t     vb2_is_streaming(&ctx->fh.m2m_ctx->cap_q_ctx.q)) ||\n\t    (V4L2_TYPE_IS_CAPTURE(vq->type) &&\n\t     vb2_is_streaming(&ctx->fh.m2m_ctx->out_q_ctx.q))) {\n\t\tdev_dbg(dev, \"%s %s out=%d cap=%d\\n\",\n\t\t\tctx->name, to_type_str(vq->type),\n\t\t\tvb2_is_streaming(&ctx->fh.m2m_ctx->out_q_ctx.q),\n\t\t\tvb2_is_streaming(&ctx->fh.m2m_ctx->cap_q_ctx.q));\n\t\treturn;\n\t}\n\n\t \n\tif (enc) {\n\t\tdev_dbg(dev, \"%s %s encoder closed\\n\", ctx->name, enc->name);\n\t\tenc->close(ctx);\n\t\tctx->enc = NULL;\n\n\t\t \n\t\thva->instances[ctx->id] = NULL;\n\t\thva->nb_of_instances--;\n\t}\n\n\tctx->aborting = false;\n}\n\n \nstatic const struct vb2_ops hva_qops = {\n\t.queue_setup\t\t= hva_queue_setup,\n\t.buf_prepare\t\t= hva_buf_prepare,\n\t.buf_queue\t\t= hva_buf_queue,\n\t.start_streaming\t= hva_start_streaming,\n\t.stop_streaming\t\t= hva_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \n\nstatic int queue_init(struct hva_ctx *ctx, struct vb2_queue *vq)\n{\n\tvq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tvq->drv_priv = ctx;\n\tvq->ops = &hva_qops;\n\tvq->mem_ops = &vb2_dma_contig_memops;\n\tvq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tvq->lock = &ctx->hva_dev->lock;\n\n\treturn vb2_queue_init(vq);\n}\n\nstatic int hva_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t  struct vb2_queue *dst_vq)\n{\n\tstruct hva_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->buf_struct_size = sizeof(struct hva_frame);\n\tsrc_vq->min_buffers_needed = MIN_FRAMES;\n\tsrc_vq->dev = ctx->hva_dev->dev;\n\n\tret = queue_init(ctx, src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->buf_struct_size = sizeof(struct hva_stream);\n\tdst_vq->min_buffers_needed = MIN_STREAMS;\n\tdst_vq->dev = ctx->hva_dev->dev;\n\n\treturn queue_init(ctx, dst_vq);\n}\n\nstatic int hva_open(struct file *file)\n{\n\tstruct hva_dev *hva = video_drvdata(file);\n\tstruct device *dev = hva_to_dev(hva);\n\tstruct hva_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tctx->hva_dev = hva;\n\n\tINIT_WORK(&ctx->run_work, hva_run_work);\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\tret = hva_ctrls_setup(ctx);\n\tif (ret) {\n\t\tdev_err(dev, \"%s [x:x] failed to setup controls\\n\",\n\t\t\tHVA_PREFIX);\n\t\tctx->sys_errors++;\n\t\tgoto err_fh;\n\t}\n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\n\tmutex_init(&ctx->lock);\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(hva->m2m_dev, ctx,\n\t\t\t\t\t    &hva_queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tdev_err(dev, \"%s failed to initialize m2m context (%d)\\n\",\n\t\t\tHVA_PREFIX, ret);\n\t\tctx->sys_errors++;\n\t\tgoto err_ctrls;\n\t}\n\n\t \n\tmutex_lock(&hva->lock);\n\thva->instance_id++;\n\tsnprintf(ctx->name, sizeof(ctx->name), \"[%3d:----]\",\n\t\t hva->instance_id);\n\tmutex_unlock(&hva->lock);\n\n\t \n\tset_default_params(ctx);\n\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\n\thva_dbg_ctx_create(ctx);\n#endif\n\n\tdev_info(dev, \"%s encoder instance created\\n\", ctx->name);\n\n\treturn 0;\n\nerr_ctrls:\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\nerr_fh:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\nout:\n\treturn ret;\n}\n\nstatic int hva_release(struct file *file)\n{\n\tstruct hva_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct hva_dev *hva = ctx_to_hdev(ctx);\n\tstruct device *dev = ctx_to_dev(ctx);\n\tconst struct hva_enc *enc = ctx->enc;\n\n\tif (enc) {\n\t\tdev_dbg(dev, \"%s %s encoder closed\\n\", ctx->name, enc->name);\n\t\tenc->close(ctx);\n\t\tctx->enc = NULL;\n\n\t\t \n\t\thva->instances[ctx->id] = NULL;\n\t\thva->nb_of_instances--;\n\t}\n\n\t \n\thva_dbg_summary(ctx);\n\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\n\thva_dbg_ctx_remove(ctx);\n#endif\n\n\tdev_info(dev, \"%s encoder instance released\\n\", ctx->name);\n\n\tkfree(ctx);\n\n\treturn 0;\n}\n\n \nstatic const struct v4l2_file_operations hva_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= hva_open,\n\t.release\t\t= hva_release,\n\t.unlocked_ioctl\t\t= video_ioctl2,\n\t.mmap\t\t\t= v4l2_m2m_fop_mmap,\n\t.poll\t\t\t= v4l2_m2m_fop_poll,\n};\n\n \n\nstatic int hva_register_device(struct hva_dev *hva)\n{\n\tint ret;\n\tstruct video_device *vdev;\n\tstruct device *dev;\n\n\tif (!hva)\n\t\treturn -ENODEV;\n\tdev = hva_to_dev(hva);\n\n\thva->m2m_dev = v4l2_m2m_init(&hva_m2m_ops);\n\tif (IS_ERR(hva->m2m_dev)) {\n\t\tdev_err(dev, \"%s failed to initialize v4l2-m2m device\\n\",\n\t\t\tHVA_PREFIX);\n\t\tret = PTR_ERR(hva->m2m_dev);\n\t\tgoto err;\n\t}\n\n\tvdev = video_device_alloc();\n\tif (!vdev) {\n\t\tdev_err(dev, \"%s failed to allocate video device\\n\",\n\t\t\tHVA_PREFIX);\n\t\tret = -ENOMEM;\n\t\tgoto err_m2m_release;\n\t}\n\n\tvdev->fops = &hva_fops;\n\tvdev->ioctl_ops = &hva_ioctl_ops;\n\tvdev->release = video_device_release;\n\tvdev->lock = &hva->lock;\n\tvdev->vfl_dir = VFL_DIR_M2M;\n\tvdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M;\n\tvdev->v4l2_dev = &hva->v4l2_dev;\n\tsnprintf(vdev->name, sizeof(vdev->name), \"%s%lx\", HVA_NAME,\n\t\t hva->ip_version);\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"%s failed to register video device\\n\",\n\t\t\tHVA_PREFIX);\n\t\tgoto err_vdev_release;\n\t}\n\n\thva->vdev = vdev;\n\tvideo_set_drvdata(vdev, hva);\n\treturn 0;\n\nerr_vdev_release:\n\tvideo_device_release(vdev);\nerr_m2m_release:\n\tv4l2_m2m_release(hva->m2m_dev);\nerr:\n\treturn ret;\n}\n\nstatic void hva_unregister_device(struct hva_dev *hva)\n{\n\tif (!hva)\n\t\treturn;\n\n\tif (hva->m2m_dev)\n\t\tv4l2_m2m_release(hva->m2m_dev);\n\n\tvideo_unregister_device(hva->vdev);\n}\n\nstatic int hva_probe(struct platform_device *pdev)\n{\n\tstruct hva_dev *hva;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\thva = devm_kzalloc(dev, sizeof(*hva), GFP_KERNEL);\n\tif (!hva) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\thva->dev = dev;\n\thva->pdev = pdev;\n\tplatform_set_drvdata(pdev, hva);\n\n\tmutex_init(&hva->lock);\n\n\t \n\tret = hva_hw_probe(pdev, hva);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tregister_encoders(hva);\n\n\t \n\tregister_formats(hva);\n\n\t \n\tret = v4l2_device_register(dev, &hva->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"%s %s failed to register V4L2 device\\n\",\n\t\t\tHVA_PREFIX, HVA_NAME);\n\t\tgoto err_hw;\n\t}\n\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\n\thva_debugfs_create(hva);\n#endif\n\n\thva->work_queue = create_workqueue(HVA_NAME);\n\tif (!hva->work_queue) {\n\t\tdev_err(dev, \"%s %s failed to allocate work queue\\n\",\n\t\t\tHVA_PREFIX, HVA_NAME);\n\t\tret = -ENOMEM;\n\t\tgoto err_v4l2;\n\t}\n\n\t \n\tret = hva_register_device(hva);\n\tif (ret)\n\t\tgoto err_work_queue;\n\n\tdev_info(dev, \"%s %s registered as /dev/video%d\\n\", HVA_PREFIX,\n\t\t HVA_NAME, hva->vdev->num);\n\n\treturn 0;\n\nerr_work_queue:\n\tdestroy_workqueue(hva->work_queue);\nerr_v4l2:\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\n\thva_debugfs_remove(hva);\n#endif\n\tv4l2_device_unregister(&hva->v4l2_dev);\nerr_hw:\n\thva_hw_remove(hva);\nerr:\n\treturn ret;\n}\n\nstatic void hva_remove(struct platform_device *pdev)\n{\n\tstruct hva_dev *hva = platform_get_drvdata(pdev);\n\tstruct device *dev = hva_to_dev(hva);\n\n\thva_unregister_device(hva);\n\n\tdestroy_workqueue(hva->work_queue);\n\n\thva_hw_remove(hva);\n\n#ifdef CONFIG_VIDEO_STI_HVA_DEBUGFS\n\thva_debugfs_remove(hva);\n#endif\n\n\tv4l2_device_unregister(&hva->v4l2_dev);\n\n\tdev_info(dev, \"%s %s removed\\n\", HVA_PREFIX, pdev->name);\n}\n\n \nstatic const struct dev_pm_ops hva_pm_ops = {\n\t.runtime_suspend\t= hva_hw_runtime_suspend,\n\t.runtime_resume\t\t= hva_hw_runtime_resume,\n};\n\nstatic const struct of_device_id hva_match_types[] = {\n\t{\n\t .compatible = \"st,st-hva\",\n\t},\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, hva_match_types);\n\nstatic struct platform_driver hva_driver = {\n\t.probe  = hva_probe,\n\t.remove_new = hva_remove,\n\t.driver = {\n\t\t.name\t\t= HVA_NAME,\n\t\t.of_match_table\t= hva_match_types,\n\t\t.pm\t\t= &hva_pm_ops,\n\t\t},\n};\n\nmodule_platform_driver(hva_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Yannick Fertre <yannick.fertre@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics HVA video encoder V4L2 driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}