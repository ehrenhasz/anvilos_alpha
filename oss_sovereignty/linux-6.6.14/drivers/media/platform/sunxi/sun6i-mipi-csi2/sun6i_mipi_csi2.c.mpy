{
  "module_name": "sun6i_mipi_csi2.c",
  "hash_id": "2ba240792d10f5ef15c8bf2e46eede0a36d90cd881650e0165969ed1b1ea842d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/sunxi/sun6i-mipi-csi2/sun6i_mipi_csi2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <media/mipi-csi2.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n\n#include \"sun6i_mipi_csi2.h\"\n#include \"sun6i_mipi_csi2_reg.h\"\n\n \n\nstatic const struct sun6i_mipi_csi2_format sun6i_mipi_csi2_formats[] = {\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.data_type\t= MIPI_CSI2_DT_RAW8,\n\t\t.bpp\t\t= 8,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.data_type\t= MIPI_CSI2_DT_RAW8,\n\t\t.bpp\t\t= 8,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.data_type\t= MIPI_CSI2_DT_RAW8,\n\t\t.bpp\t\t= 8,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.data_type\t= MIPI_CSI2_DT_RAW8,\n\t\t.bpp\t\t= 8,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.data_type\t= MIPI_CSI2_DT_RAW10,\n\t\t.bpp\t\t= 10,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.data_type\t= MIPI_CSI2_DT_RAW10,\n\t\t.bpp\t\t= 10,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.data_type\t= MIPI_CSI2_DT_RAW10,\n\t\t.bpp\t\t= 10,\n\t},\n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.data_type\t= MIPI_CSI2_DT_RAW10,\n\t\t.bpp\t\t= 10,\n\t},\n};\n\nstatic const struct sun6i_mipi_csi2_format *\nsun6i_mipi_csi2_format_find(u32 mbus_code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sun6i_mipi_csi2_formats); i++)\n\t\tif (sun6i_mipi_csi2_formats[i].mbus_code == mbus_code)\n\t\t\treturn &sun6i_mipi_csi2_formats[i];\n\n\treturn NULL;\n}\n\n \n\nstatic void sun6i_mipi_csi2_enable(struct sun6i_mipi_csi2_device *csi2_dev)\n{\n\tstruct regmap *regmap = csi2_dev->regmap;\n\n\tregmap_update_bits(regmap, SUN6I_MIPI_CSI2_CTL_REG,\n\t\t\t   SUN6I_MIPI_CSI2_CTL_EN, SUN6I_MIPI_CSI2_CTL_EN);\n}\n\nstatic void sun6i_mipi_csi2_disable(struct sun6i_mipi_csi2_device *csi2_dev)\n{\n\tstruct regmap *regmap = csi2_dev->regmap;\n\n\tregmap_update_bits(regmap, SUN6I_MIPI_CSI2_CTL_REG,\n\t\t\t   SUN6I_MIPI_CSI2_CTL_EN, 0);\n}\n\nstatic void sun6i_mipi_csi2_configure(struct sun6i_mipi_csi2_device *csi2_dev)\n{\n\tstruct regmap *regmap = csi2_dev->regmap;\n\tunsigned int lanes_count =\n\t\tcsi2_dev->bridge.endpoint.bus.mipi_csi2.num_data_lanes;\n\tstruct v4l2_mbus_framefmt *mbus_format = &csi2_dev->bridge.mbus_format;\n\tconst struct sun6i_mipi_csi2_format *format;\n\tstruct device *dev = csi2_dev->dev;\n\tu32 version = 0;\n\n\tformat = sun6i_mipi_csi2_format_find(mbus_format->code);\n\tif (WARN_ON(!format))\n\t\treturn;\n\n\t \n\tregmap_write(regmap, SUN6I_MIPI_CSI2_CTL_REG,\n\t\t     SUN6I_MIPI_CSI2_CTL_RESET_N |\n\t\t     SUN6I_MIPI_CSI2_CTL_VERSION_EN |\n\t\t     SUN6I_MIPI_CSI2_CTL_UNPK_EN);\n\n\tregmap_read(regmap, SUN6I_MIPI_CSI2_VERSION_REG, &version);\n\n\tregmap_update_bits(regmap, SUN6I_MIPI_CSI2_CTL_REG,\n\t\t\t   SUN6I_MIPI_CSI2_CTL_VERSION_EN, 0);\n\n\tdev_dbg(dev, \"A31 MIPI CSI-2 version: %04x\\n\", version);\n\n\tregmap_write(regmap, SUN6I_MIPI_CSI2_CFG_REG,\n\t\t     SUN6I_MIPI_CSI2_CFG_CHANNEL_MODE(1) |\n\t\t     SUN6I_MIPI_CSI2_CFG_LANE_COUNT(lanes_count));\n\n\t \n\n\tregmap_write(regmap, SUN6I_MIPI_CSI2_VCDT_RX_REG,\n\t\t     SUN6I_MIPI_CSI2_VCDT_RX_CH_VC(3, 3) |\n\t\t     SUN6I_MIPI_CSI2_VCDT_RX_CH_VC(2, 2) |\n\t\t     SUN6I_MIPI_CSI2_VCDT_RX_CH_VC(1, 1) |\n\t\t     SUN6I_MIPI_CSI2_VCDT_RX_CH_VC(0, 0) |\n\t\t     SUN6I_MIPI_CSI2_VCDT_RX_CH_DT(0, format->data_type));\n\n\tregmap_write(regmap, SUN6I_MIPI_CSI2_CH_INT_PD_REG,\n\t\t     SUN6I_MIPI_CSI2_CH_INT_PD_CLEAR);\n}\n\n \n\nstatic int sun6i_mipi_csi2_s_stream(struct v4l2_subdev *subdev, int on)\n{\n\tstruct sun6i_mipi_csi2_device *csi2_dev = v4l2_get_subdevdata(subdev);\n\tstruct v4l2_subdev *source_subdev = csi2_dev->bridge.source_subdev;\n\tunion phy_configure_opts dphy_opts = { 0 };\n\tstruct phy_configure_opts_mipi_dphy *dphy_cfg = &dphy_opts.mipi_dphy;\n\tstruct v4l2_mbus_framefmt *mbus_format = &csi2_dev->bridge.mbus_format;\n\tconst struct sun6i_mipi_csi2_format *format;\n\tstruct phy *dphy = csi2_dev->dphy;\n\tstruct device *dev = csi2_dev->dev;\n\tstruct v4l2_ctrl *ctrl;\n\tunsigned int lanes_count =\n\t\tcsi2_dev->bridge.endpoint.bus.mipi_csi2.num_data_lanes;\n\tunsigned long pixel_rate;\n\tint ret;\n\n\tif (!source_subdev)\n\t\treturn -ENODEV;\n\n\tif (!on) {\n\t\tv4l2_subdev_call(source_subdev, video, s_stream, 0);\n\t\tret = 0;\n\t\tgoto disable;\n\t}\n\n\t \n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\tctrl = v4l2_ctrl_find(source_subdev->ctrl_handler, V4L2_CID_PIXEL_RATE);\n\tif (!ctrl) {\n\t\tdev_err(dev, \"missing sensor pixel rate\\n\");\n\t\tret = -ENODEV;\n\t\tgoto error_pm;\n\t}\n\n\tpixel_rate = (unsigned long)v4l2_ctrl_g_ctrl_int64(ctrl);\n\tif (!pixel_rate) {\n\t\tdev_err(dev, \"missing (zero) sensor pixel rate\\n\");\n\t\tret = -ENODEV;\n\t\tgoto error_pm;\n\t}\n\n\t \n\n\tif (!lanes_count) {\n\t\tdev_err(dev, \"missing (zero) MIPI CSI-2 lanes count\\n\");\n\t\tret = -ENODEV;\n\t\tgoto error_pm;\n\t}\n\n\tformat = sun6i_mipi_csi2_format_find(mbus_format->code);\n\tif (WARN_ON(!format)) {\n\t\tret = -ENODEV;\n\t\tgoto error_pm;\n\t}\n\n\tphy_mipi_dphy_get_default_config(pixel_rate, format->bpp, lanes_count,\n\t\t\t\t\t dphy_cfg);\n\n\t \n\n\tdev_dbg(dev, \"A31 MIPI CSI-2 config:\\n\");\n\tdev_dbg(dev, \"%ld pixels/s, %u bits/pixel, %u lanes, %lu Hz clock\\n\",\n\t\tpixel_rate, format->bpp, lanes_count,\n\t\tdphy_cfg->hs_clk_rate / 2);\n\n\tret = phy_reset(dphy);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to reset MIPI D-PHY\\n\");\n\t\tgoto error_pm;\n\t}\n\n\tret = phy_configure(dphy, &dphy_opts);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to configure MIPI D-PHY\\n\");\n\t\tgoto error_pm;\n\t}\n\n\t \n\n\tsun6i_mipi_csi2_configure(csi2_dev);\n\tsun6i_mipi_csi2_enable(csi2_dev);\n\n\t \n\n\tret = phy_power_on(dphy);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to power on MIPI D-PHY\\n\");\n\t\tgoto error_pm;\n\t}\n\n\t \n\n\tret = v4l2_subdev_call(source_subdev, video, s_stream, 1);\n\tif (ret && ret != -ENOIOCTLCMD)\n\t\tgoto disable;\n\n\treturn 0;\n\ndisable:\n\tphy_power_off(dphy);\n\tsun6i_mipi_csi2_disable(csi2_dev);\n\nerror_pm:\n\tpm_runtime_put(dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops sun6i_mipi_csi2_video_ops = {\n\t.s_stream\t= sun6i_mipi_csi2_s_stream,\n};\n\nstatic void\nsun6i_mipi_csi2_mbus_format_prepare(struct v4l2_mbus_framefmt *mbus_format)\n{\n\tif (!sun6i_mipi_csi2_format_find(mbus_format->code))\n\t\tmbus_format->code = sun6i_mipi_csi2_formats[0].mbus_code;\n\n\tmbus_format->field = V4L2_FIELD_NONE;\n\tmbus_format->colorspace = V4L2_COLORSPACE_RAW;\n\tmbus_format->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tmbus_format->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n}\n\nstatic int sun6i_mipi_csi2_init_cfg(struct v4l2_subdev *subdev,\n\t\t\t\t    struct v4l2_subdev_state *state)\n{\n\tstruct sun6i_mipi_csi2_device *csi2_dev = v4l2_get_subdevdata(subdev);\n\tunsigned int pad = SUN6I_MIPI_CSI2_PAD_SINK;\n\tstruct v4l2_mbus_framefmt *mbus_format =\n\t\tv4l2_subdev_get_try_format(subdev, state, pad);\n\tstruct mutex *lock = &csi2_dev->bridge.lock;\n\n\tmutex_lock(lock);\n\n\tmbus_format->code = sun6i_mipi_csi2_formats[0].mbus_code;\n\tmbus_format->width = 640;\n\tmbus_format->height = 480;\n\n\tsun6i_mipi_csi2_mbus_format_prepare(mbus_format);\n\n\tmutex_unlock(lock);\n\n\treturn 0;\n}\n\nstatic int\nsun6i_mipi_csi2_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t       struct v4l2_subdev_state *state,\n\t\t\t       struct v4l2_subdev_mbus_code_enum *code_enum)\n{\n\tif (code_enum->index >= ARRAY_SIZE(sun6i_mipi_csi2_formats))\n\t\treturn -EINVAL;\n\n\tcode_enum->code = sun6i_mipi_csi2_formats[code_enum->index].mbus_code;\n\n\treturn 0;\n}\n\nstatic int sun6i_mipi_csi2_get_fmt(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_state *state,\n\t\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct sun6i_mipi_csi2_device *csi2_dev = v4l2_get_subdevdata(subdev);\n\tstruct v4l2_mbus_framefmt *mbus_format = &format->format;\n\tstruct mutex *lock = &csi2_dev->bridge.lock;\n\n\tmutex_lock(lock);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t*mbus_format = *v4l2_subdev_get_try_format(subdev, state,\n\t\t\t\t\t\t\t   format->pad);\n\telse\n\t\t*mbus_format = csi2_dev->bridge.mbus_format;\n\n\tmutex_unlock(lock);\n\n\treturn 0;\n}\n\nstatic int sun6i_mipi_csi2_set_fmt(struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_subdev_state *state,\n\t\t\t\t   struct v4l2_subdev_format *format)\n{\n\tstruct sun6i_mipi_csi2_device *csi2_dev = v4l2_get_subdevdata(subdev);\n\tstruct v4l2_mbus_framefmt *mbus_format = &format->format;\n\tstruct mutex *lock = &csi2_dev->bridge.lock;\n\n\tmutex_lock(lock);\n\n\tsun6i_mipi_csi2_mbus_format_prepare(mbus_format);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t*v4l2_subdev_get_try_format(subdev, state, format->pad) =\n\t\t\t*mbus_format;\n\telse\n\t\tcsi2_dev->bridge.mbus_format = *mbus_format;\n\n\tmutex_unlock(lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops sun6i_mipi_csi2_pad_ops = {\n\t.init_cfg\t= sun6i_mipi_csi2_init_cfg,\n\t.enum_mbus_code\t= sun6i_mipi_csi2_enum_mbus_code,\n\t.get_fmt\t= sun6i_mipi_csi2_get_fmt,\n\t.set_fmt\t= sun6i_mipi_csi2_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops sun6i_mipi_csi2_subdev_ops = {\n\t.video\t= &sun6i_mipi_csi2_video_ops,\n\t.pad\t= &sun6i_mipi_csi2_pad_ops,\n};\n\n \n\nstatic const struct media_entity_operations sun6i_mipi_csi2_entity_ops = {\n\t.link_validate\t= v4l2_subdev_link_validate,\n};\n\n \n\nstatic int\nsun6i_mipi_csi2_notifier_bound(struct v4l2_async_notifier *notifier,\n\t\t\t       struct v4l2_subdev *remote_subdev,\n\t\t\t       struct v4l2_async_connection *async_subdev)\n{\n\tstruct v4l2_subdev *subdev = notifier->sd;\n\tstruct sun6i_mipi_csi2_device *csi2_dev =\n\t\tcontainer_of(notifier, struct sun6i_mipi_csi2_device,\n\t\t\t     bridge.notifier);\n\tstruct media_entity *sink_entity = &subdev->entity;\n\tstruct media_entity *source_entity = &remote_subdev->entity;\n\tstruct device *dev = csi2_dev->dev;\n\tint sink_pad_index = 0;\n\tint source_pad_index;\n\tint ret;\n\n\tret = media_entity_get_fwnode_pad(source_entity, remote_subdev->fwnode,\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing source pad in external entity %s\\n\",\n\t\t\tsource_entity->name);\n\t\treturn -EINVAL;\n\t}\n\n\tsource_pad_index = ret;\n\n\tdev_dbg(dev, \"creating %s:%u -> %s:%u link\\n\", source_entity->name,\n\t\tsource_pad_index, sink_entity->name, sink_pad_index);\n\n\tret = media_create_pad_link(source_entity, source_pad_index,\n\t\t\t\t    sink_entity, sink_pad_index,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to create %s:%u -> %s:%u link\\n\",\n\t\t\tsource_entity->name, source_pad_index,\n\t\t\tsink_entity->name, sink_pad_index);\n\t\treturn ret;\n\t}\n\n\tcsi2_dev->bridge.source_subdev = remote_subdev;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_async_notifier_operations\nsun6i_mipi_csi2_notifier_ops = {\n\t.bound\t= sun6i_mipi_csi2_notifier_bound,\n};\n\n \n\nstatic int\nsun6i_mipi_csi2_bridge_source_setup(struct sun6i_mipi_csi2_device *csi2_dev)\n{\n\tstruct v4l2_async_notifier *notifier = &csi2_dev->bridge.notifier;\n\tstruct v4l2_fwnode_endpoint *endpoint = &csi2_dev->bridge.endpoint;\n\tstruct v4l2_async_connection *subdev_async;\n\tstruct fwnode_handle *handle;\n\tstruct device *dev = csi2_dev->dev;\n\tint ret;\n\n\thandle = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev), 0, 0,\n\t\t\t\t\t\t FWNODE_GRAPH_ENDPOINT_NEXT);\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tendpoint->bus_type = V4L2_MBUS_CSI2_DPHY;\n\n\tret = v4l2_fwnode_endpoint_parse(handle, endpoint);\n\tif (ret)\n\t\tgoto complete;\n\n\tsubdev_async =\n\t\tv4l2_async_nf_add_fwnode_remote(notifier, handle,\n\t\t\t\t\t\tstruct v4l2_async_connection);\n\tif (IS_ERR(subdev_async))\n\t\tret = PTR_ERR(subdev_async);\n\ncomplete:\n\tfwnode_handle_put(handle);\n\n\treturn ret;\n}\n\nstatic int sun6i_mipi_csi2_bridge_setup(struct sun6i_mipi_csi2_device *csi2_dev)\n{\n\tstruct sun6i_mipi_csi2_bridge *bridge = &csi2_dev->bridge;\n\tstruct v4l2_subdev *subdev = &bridge->subdev;\n\tstruct v4l2_async_notifier *notifier = &bridge->notifier;\n\tstruct media_pad *pads = bridge->pads;\n\tstruct device *dev = csi2_dev->dev;\n\tbool notifier_registered = false;\n\tint ret;\n\n\tmutex_init(&bridge->lock);\n\n\t \n\n\tv4l2_subdev_init(subdev, &sun6i_mipi_csi2_subdev_ops);\n\tstrscpy(subdev->name, SUN6I_MIPI_CSI2_NAME, sizeof(subdev->name));\n\tsubdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsubdev->owner = THIS_MODULE;\n\tsubdev->dev = dev;\n\n\tv4l2_set_subdevdata(subdev, csi2_dev);\n\n\t \n\n\tsubdev->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tsubdev->entity.ops = &sun6i_mipi_csi2_entity_ops;\n\n\t \n\n\tpads[SUN6I_MIPI_CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK |\n\t\t\t\t\t       MEDIA_PAD_FL_MUST_CONNECT;\n\tpads[SUN6I_MIPI_CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE |\n\t\t\t\t\t\t MEDIA_PAD_FL_MUST_CONNECT;\n\n\tret = media_entity_pads_init(&subdev->entity, SUN6I_MIPI_CSI2_PAD_COUNT,\n\t\t\t\t     pads);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tv4l2_async_subdev_nf_init(notifier, subdev);\n\tnotifier->ops = &sun6i_mipi_csi2_notifier_ops;\n\n\tret = sun6i_mipi_csi2_bridge_source_setup(csi2_dev);\n\tif (ret && ret != -ENODEV)\n\t\tgoto error_v4l2_notifier_cleanup;\n\n\t \n\tif (ret != -ENODEV) {\n\t\tret = v4l2_async_nf_register(notifier);\n\t\tif (ret < 0)\n\t\t\tgoto error_v4l2_notifier_cleanup;\n\n\t\tnotifier_registered = true;\n\t}\n\n\t \n\n\tret = v4l2_async_register_subdev(subdev);\n\tif (ret < 0)\n\t\tgoto error_v4l2_notifier_unregister;\n\n\treturn 0;\n\nerror_v4l2_notifier_unregister:\n\tif (notifier_registered)\n\t\tv4l2_async_nf_unregister(notifier);\n\nerror_v4l2_notifier_cleanup:\n\tv4l2_async_nf_cleanup(notifier);\n\n\tmedia_entity_cleanup(&subdev->entity);\n\n\treturn ret;\n}\n\nstatic void\nsun6i_mipi_csi2_bridge_cleanup(struct sun6i_mipi_csi2_device *csi2_dev)\n{\n\tstruct v4l2_subdev *subdev = &csi2_dev->bridge.subdev;\n\tstruct v4l2_async_notifier *notifier = &csi2_dev->bridge.notifier;\n\n\tv4l2_async_unregister_subdev(subdev);\n\tv4l2_async_nf_unregister(notifier);\n\tv4l2_async_nf_cleanup(notifier);\n\tmedia_entity_cleanup(&subdev->entity);\n}\n\n \n\nstatic int sun6i_mipi_csi2_suspend(struct device *dev)\n{\n\tstruct sun6i_mipi_csi2_device *csi2_dev = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(csi2_dev->clock_mod);\n\treset_control_assert(csi2_dev->reset);\n\n\treturn 0;\n}\n\nstatic int sun6i_mipi_csi2_resume(struct device *dev)\n{\n\tstruct sun6i_mipi_csi2_device *csi2_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = reset_control_deassert(csi2_dev->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to deassert reset\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(csi2_dev->clock_mod);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable module clock\\n\");\n\t\tgoto error_reset;\n\t}\n\n\treturn 0;\n\nerror_reset:\n\treset_control_assert(csi2_dev->reset);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops sun6i_mipi_csi2_pm_ops = {\n\t.runtime_suspend\t= sun6i_mipi_csi2_suspend,\n\t.runtime_resume\t\t= sun6i_mipi_csi2_resume,\n};\n\nstatic const struct regmap_config sun6i_mipi_csi2_regmap_config = {\n\t.reg_bits       = 32,\n\t.reg_stride     = 4,\n\t.val_bits       = 32,\n\t.max_register\t= 0x400,\n};\n\nstatic int\nsun6i_mipi_csi2_resources_setup(struct sun6i_mipi_csi2_device *csi2_dev,\n\t\t\t\tstruct platform_device *platform_dev)\n{\n\tstruct device *dev = csi2_dev->dev;\n\tvoid __iomem *io_base;\n\tint ret;\n\n\t \n\n\tio_base = devm_platform_ioremap_resource(platform_dev, 0);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\tcsi2_dev->regmap =\n\t\tdevm_regmap_init_mmio_clk(dev, \"bus\", io_base,\n\t\t\t\t\t  &sun6i_mipi_csi2_regmap_config);\n\tif (IS_ERR(csi2_dev->regmap)) {\n\t\tdev_err(dev, \"failed to init register map\\n\");\n\t\treturn PTR_ERR(csi2_dev->regmap);\n\t}\n\n\t \n\n\tcsi2_dev->clock_mod = devm_clk_get(dev, \"mod\");\n\tif (IS_ERR(csi2_dev->clock_mod)) {\n\t\tdev_err(dev, \"failed to acquire mod clock\\n\");\n\t\treturn PTR_ERR(csi2_dev->clock_mod);\n\t}\n\n\tret = clk_set_rate_exclusive(csi2_dev->clock_mod, 297000000);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set mod clock rate\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\tcsi2_dev->reset = devm_reset_control_get_shared(dev, NULL);\n\tif (IS_ERR(csi2_dev->reset)) {\n\t\tdev_err(dev, \"failed to get reset controller\\n\");\n\t\tret = PTR_ERR(csi2_dev->reset);\n\t\tgoto error_clock_rate_exclusive;\n\t}\n\n\t \n\n\tcsi2_dev->dphy = devm_phy_get(dev, \"dphy\");\n\tif (IS_ERR(csi2_dev->dphy)) {\n\t\tdev_err(dev, \"failed to get MIPI D-PHY\\n\");\n\t\tret = PTR_ERR(csi2_dev->dphy);\n\t\tgoto error_clock_rate_exclusive;\n\t}\n\n\tret = phy_init(csi2_dev->dphy);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize MIPI D-PHY\\n\");\n\t\tgoto error_clock_rate_exclusive;\n\t}\n\n\t \n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nerror_clock_rate_exclusive:\n\tclk_rate_exclusive_put(csi2_dev->clock_mod);\n\n\treturn ret;\n}\n\nstatic void\nsun6i_mipi_csi2_resources_cleanup(struct sun6i_mipi_csi2_device *csi2_dev)\n{\n\tpm_runtime_disable(csi2_dev->dev);\n\tphy_exit(csi2_dev->dphy);\n\tclk_rate_exclusive_put(csi2_dev->clock_mod);\n}\n\nstatic int sun6i_mipi_csi2_probe(struct platform_device *platform_dev)\n{\n\tstruct sun6i_mipi_csi2_device *csi2_dev;\n\tstruct device *dev = &platform_dev->dev;\n\tint ret;\n\n\tcsi2_dev = devm_kzalloc(dev, sizeof(*csi2_dev), GFP_KERNEL);\n\tif (!csi2_dev)\n\t\treturn -ENOMEM;\n\n\tcsi2_dev->dev = dev;\n\tplatform_set_drvdata(platform_dev, csi2_dev);\n\n\tret = sun6i_mipi_csi2_resources_setup(csi2_dev, platform_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sun6i_mipi_csi2_bridge_setup(csi2_dev);\n\tif (ret)\n\t\tgoto error_resources;\n\n\treturn 0;\n\nerror_resources:\n\tsun6i_mipi_csi2_resources_cleanup(csi2_dev);\n\n\treturn ret;\n}\n\nstatic void sun6i_mipi_csi2_remove(struct platform_device *platform_dev)\n{\n\tstruct sun6i_mipi_csi2_device *csi2_dev =\n\t\tplatform_get_drvdata(platform_dev);\n\n\tsun6i_mipi_csi2_bridge_cleanup(csi2_dev);\n\tsun6i_mipi_csi2_resources_cleanup(csi2_dev);\n}\n\nstatic const struct of_device_id sun6i_mipi_csi2_of_match[] = {\n\t{ .compatible\t= \"allwinner,sun6i-a31-mipi-csi2\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sun6i_mipi_csi2_of_match);\n\nstatic struct platform_driver sun6i_mipi_csi2_platform_driver = {\n\t.probe\t= sun6i_mipi_csi2_probe,\n\t.remove_new = sun6i_mipi_csi2_remove,\n\t.driver\t= {\n\t\t.name\t\t= SUN6I_MIPI_CSI2_NAME,\n\t\t.of_match_table\t= sun6i_mipi_csi2_of_match,\n\t\t.pm\t\t= &sun6i_mipi_csi2_pm_ops,\n\t},\n};\nmodule_platform_driver(sun6i_mipi_csi2_platform_driver);\n\nMODULE_DESCRIPTION(\"Allwinner A31 MIPI CSI-2 Controller Driver\");\nMODULE_AUTHOR(\"Paul Kocialkowski <paul.kocialkowski@bootlin.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}