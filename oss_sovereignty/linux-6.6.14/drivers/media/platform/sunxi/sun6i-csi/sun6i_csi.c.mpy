{
  "module_name": "sun6i_csi.c",
  "hash_id": "8f0dad8bf06aba904ac2e9ab11f77b4dcf76762d8081e2f45f4f896a50e429f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-mc.h>\n\n#include \"sun6i_csi.h\"\n#include \"sun6i_csi_bridge.h\"\n#include \"sun6i_csi_capture.h\"\n#include \"sun6i_csi_reg.h\"\n\n \n\nint sun6i_csi_isp_complete(struct sun6i_csi_device *csi_dev,\n\t\t\t   struct v4l2_device *v4l2_dev)\n{\n\tif (csi_dev->v4l2_dev && csi_dev->v4l2_dev != v4l2_dev)\n\t\treturn -EINVAL;\n\n\tcsi_dev->v4l2_dev = v4l2_dev;\n\tcsi_dev->media_dev = v4l2_dev->mdev;\n\n\treturn sun6i_csi_capture_setup(csi_dev);\n}\n\nstatic int sun6i_csi_isp_detect(struct sun6i_csi_device *csi_dev)\n{\n\tstruct device *dev = csi_dev->dev;\n\tstruct fwnode_handle *handle;\n\n\t \n\thandle = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev),\n\t\t\t\t\t\t SUN6I_CSI_PORT_ISP, 0,\n\t\t\t\t\t\t FWNODE_GRAPH_ENDPOINT_NEXT);\n\tif (!handle)\n\t\treturn 0;\n\n\tfwnode_handle_put(handle);\n\n\tif (!IS_ENABLED(CONFIG_VIDEO_SUN6I_ISP)) {\n\t\tdev_warn(dev,\n\t\t\t \"ISP link is detected but not enabled in kernel config!\");\n\t\treturn 0;\n\t}\n\n\tcsi_dev->isp_available = true;\n\n\treturn 0;\n}\n\n \n\nstatic const struct media_device_ops sun6i_csi_media_ops = {\n\t.link_notify = v4l2_pipeline_link_notify,\n};\n\n \n\nstatic int sun6i_csi_v4l2_setup(struct sun6i_csi_device *csi_dev)\n{\n\tstruct sun6i_csi_v4l2 *v4l2 = &csi_dev->v4l2;\n\tstruct media_device *media_dev = &v4l2->media_dev;\n\tstruct v4l2_device *v4l2_dev = &v4l2->v4l2_dev;\n\tstruct device *dev = csi_dev->dev;\n\tint ret;\n\n\t \n\n\tstrscpy(media_dev->model, SUN6I_CSI_DESCRIPTION,\n\t\tsizeof(media_dev->model));\n\tmedia_dev->hw_revision = 0;\n\tmedia_dev->ops = &sun6i_csi_media_ops;\n\tmedia_dev->dev = dev;\n\n\tmedia_device_init(media_dev);\n\n\tret = media_device_register(media_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register media device: %d\\n\", ret);\n\t\tgoto error_media;\n\t}\n\n\t \n\n\tv4l2_dev->mdev = media_dev;\n\n\tret = v4l2_device_register(dev, v4l2_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register v4l2 device: %d\\n\", ret);\n\t\tgoto error_media;\n\t}\n\n\tcsi_dev->v4l2_dev = v4l2_dev;\n\tcsi_dev->media_dev = media_dev;\n\n\treturn 0;\n\nerror_media:\n\tmedia_device_unregister(media_dev);\n\tmedia_device_cleanup(media_dev);\n\n\treturn ret;\n}\n\nstatic void sun6i_csi_v4l2_cleanup(struct sun6i_csi_device *csi_dev)\n{\n\tstruct sun6i_csi_v4l2 *v4l2 = &csi_dev->v4l2;\n\n\tmedia_device_unregister(&v4l2->media_dev);\n\tv4l2_device_unregister(&v4l2->v4l2_dev);\n\tmedia_device_cleanup(&v4l2->media_dev);\n}\n\n \n\nstatic irqreturn_t sun6i_csi_interrupt(int irq, void *private)\n{\n\tstruct sun6i_csi_device *csi_dev = private;\n\tbool capture_streaming = csi_dev->capture.state.streaming;\n\tstruct regmap *regmap = csi_dev->regmap;\n\tu32 status = 0, enable = 0;\n\n\tregmap_read(regmap, SUN6I_CSI_CH_INT_STA_REG, &status);\n\tregmap_read(regmap, SUN6I_CSI_CH_INT_EN_REG, &enable);\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\telse if (!(status & enable) || !capture_streaming)\n\t\tgoto complete;\n\n\tif ((status & SUN6I_CSI_CH_INT_STA_FIFO0_OF) ||\n\t    (status & SUN6I_CSI_CH_INT_STA_FIFO1_OF) ||\n\t    (status & SUN6I_CSI_CH_INT_STA_FIFO2_OF) ||\n\t    (status & SUN6I_CSI_CH_INT_STA_HB_OF)) {\n\t\tregmap_write(regmap, SUN6I_CSI_CH_INT_STA_REG, status);\n\n\t\tregmap_update_bits(regmap, SUN6I_CSI_EN_REG,\n\t\t\t\t   SUN6I_CSI_EN_CSI_EN, 0);\n\t\tregmap_update_bits(regmap, SUN6I_CSI_EN_REG,\n\t\t\t\t   SUN6I_CSI_EN_CSI_EN, SUN6I_CSI_EN_CSI_EN);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (status & SUN6I_CSI_CH_INT_STA_FD)\n\t\tsun6i_csi_capture_frame_done(csi_dev);\n\n\tif (status & SUN6I_CSI_CH_INT_STA_VS)\n\t\tsun6i_csi_capture_sync(csi_dev);\n\ncomplete:\n\tregmap_write(regmap, SUN6I_CSI_CH_INT_STA_REG, status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sun6i_csi_suspend(struct device *dev)\n{\n\tstruct sun6i_csi_device *csi_dev = dev_get_drvdata(dev);\n\n\treset_control_assert(csi_dev->reset);\n\tclk_disable_unprepare(csi_dev->clock_ram);\n\tclk_disable_unprepare(csi_dev->clock_mod);\n\n\treturn 0;\n}\n\nstatic int sun6i_csi_resume(struct device *dev)\n{\n\tstruct sun6i_csi_device *csi_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = reset_control_deassert(csi_dev->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to deassert reset\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(csi_dev->clock_mod);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable module clock\\n\");\n\t\tgoto error_reset;\n\t}\n\n\tret = clk_prepare_enable(csi_dev->clock_ram);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable ram clock\\n\");\n\t\tgoto error_clock_mod;\n\t}\n\n\treturn 0;\n\nerror_clock_mod:\n\tclk_disable_unprepare(csi_dev->clock_mod);\n\nerror_reset:\n\treset_control_assert(csi_dev->reset);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops sun6i_csi_pm_ops = {\n\t.runtime_suspend\t= sun6i_csi_suspend,\n\t.runtime_resume\t\t= sun6i_csi_resume,\n};\n\nstatic const struct regmap_config sun6i_csi_regmap_config = {\n\t.reg_bits       = 32,\n\t.reg_stride     = 4,\n\t.val_bits       = 32,\n\t.max_register\t= 0x9c,\n};\n\nstatic int sun6i_csi_resources_setup(struct sun6i_csi_device *csi_dev,\n\t\t\t\t     struct platform_device *platform_dev)\n{\n\tstruct device *dev = csi_dev->dev;\n\tconst struct sun6i_csi_variant *variant;\n\tvoid __iomem *io_base;\n\tint ret;\n\tint irq;\n\n\tvariant = of_device_get_match_data(dev);\n\tif (!variant)\n\t\treturn -EINVAL;\n\n\t \n\n\tio_base = devm_platform_ioremap_resource(platform_dev, 0);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\tcsi_dev->regmap = devm_regmap_init_mmio_clk(dev, \"bus\", io_base,\n\t\t\t\t\t\t    &sun6i_csi_regmap_config);\n\tif (IS_ERR(csi_dev->regmap)) {\n\t\tdev_err(dev, \"failed to init register map\\n\");\n\t\treturn PTR_ERR(csi_dev->regmap);\n\t}\n\n\t \n\n\tcsi_dev->clock_mod = devm_clk_get(dev, \"mod\");\n\tif (IS_ERR(csi_dev->clock_mod)) {\n\t\tdev_err(dev, \"failed to acquire module clock\\n\");\n\t\treturn PTR_ERR(csi_dev->clock_mod);\n\t}\n\n\tcsi_dev->clock_ram = devm_clk_get(dev, \"ram\");\n\tif (IS_ERR(csi_dev->clock_ram)) {\n\t\tdev_err(dev, \"failed to acquire ram clock\\n\");\n\t\treturn PTR_ERR(csi_dev->clock_ram);\n\t}\n\n\tret = clk_set_rate_exclusive(csi_dev->clock_mod,\n\t\t\t\t     variant->clock_mod_rate);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set mod clock rate\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\tcsi_dev->reset = devm_reset_control_get_shared(dev, NULL);\n\tif (IS_ERR(csi_dev->reset)) {\n\t\tdev_err(dev, \"failed to acquire reset\\n\");\n\t\tret = PTR_ERR(csi_dev->reset);\n\t\tgoto error_clock_rate_exclusive;\n\t}\n\n\t \n\n\tirq = platform_get_irq(platform_dev, 0);\n\tif (irq < 0) {\n\t\tret = -ENXIO;\n\t\tgoto error_clock_rate_exclusive;\n\t}\n\n\tret = devm_request_irq(dev, irq, sun6i_csi_interrupt, IRQF_SHARED,\n\t\t\t       SUN6I_CSI_NAME, csi_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request interrupt\\n\");\n\t\tgoto error_clock_rate_exclusive;\n\t}\n\n\t \n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nerror_clock_rate_exclusive:\n\tclk_rate_exclusive_put(csi_dev->clock_mod);\n\n\treturn ret;\n}\n\nstatic void sun6i_csi_resources_cleanup(struct sun6i_csi_device *csi_dev)\n{\n\tpm_runtime_disable(csi_dev->dev);\n\tclk_rate_exclusive_put(csi_dev->clock_mod);\n}\n\nstatic int sun6i_csi_probe(struct platform_device *platform_dev)\n{\n\tstruct sun6i_csi_device *csi_dev;\n\tstruct device *dev = &platform_dev->dev;\n\tint ret;\n\n\tcsi_dev = devm_kzalloc(dev, sizeof(*csi_dev), GFP_KERNEL);\n\tif (!csi_dev)\n\t\treturn -ENOMEM;\n\n\tcsi_dev->dev = &platform_dev->dev;\n\tplatform_set_drvdata(platform_dev, csi_dev);\n\n\tret = sun6i_csi_resources_setup(csi_dev, platform_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sun6i_csi_isp_detect(csi_dev);\n\tif (ret)\n\t\tgoto error_resources;\n\n\t \n\tif (!csi_dev->isp_available) {\n\t\tret = sun6i_csi_v4l2_setup(csi_dev);\n\t\tif (ret)\n\t\t\tgoto error_resources;\n\t}\n\n\tret = sun6i_csi_bridge_setup(csi_dev);\n\tif (ret)\n\t\tgoto error_v4l2;\n\n\tif (!csi_dev->isp_available) {\n\t\tret = sun6i_csi_capture_setup(csi_dev);\n\t\tif (ret)\n\t\t\tgoto error_bridge;\n\t}\n\n\treturn 0;\n\nerror_bridge:\n\tsun6i_csi_bridge_cleanup(csi_dev);\n\nerror_v4l2:\n\tif (!csi_dev->isp_available)\n\t\tsun6i_csi_v4l2_cleanup(csi_dev);\n\nerror_resources:\n\tsun6i_csi_resources_cleanup(csi_dev);\n\n\treturn ret;\n}\n\nstatic void sun6i_csi_remove(struct platform_device *pdev)\n{\n\tstruct sun6i_csi_device *csi_dev = platform_get_drvdata(pdev);\n\n\tsun6i_csi_capture_cleanup(csi_dev);\n\tsun6i_csi_bridge_cleanup(csi_dev);\n\n\tif (!csi_dev->isp_available)\n\t\tsun6i_csi_v4l2_cleanup(csi_dev);\n\n\tsun6i_csi_resources_cleanup(csi_dev);\n}\n\nstatic const struct sun6i_csi_variant sun6i_a31_csi_variant = {\n\t.clock_mod_rate\t= 297000000,\n};\n\nstatic const struct sun6i_csi_variant sun50i_a64_csi_variant = {\n\t.clock_mod_rate\t= 300000000,\n};\n\nstatic const struct of_device_id sun6i_csi_of_match[] = {\n\t{\n\t\t.compatible\t= \"allwinner,sun6i-a31-csi\",\n\t\t.data\t\t= &sun6i_a31_csi_variant,\n\t},\n\t{\n\t\t.compatible\t= \"allwinner,sun8i-a83t-csi\",\n\t\t.data\t\t= &sun6i_a31_csi_variant,\n\t},\n\t{\n\t\t.compatible\t= \"allwinner,sun8i-h3-csi\",\n\t\t.data\t\t= &sun6i_a31_csi_variant,\n\t},\n\t{\n\t\t.compatible\t= \"allwinner,sun8i-v3s-csi\",\n\t\t.data\t\t= &sun6i_a31_csi_variant,\n\t},\n\t{\n\t\t.compatible\t= \"allwinner,sun50i-a64-csi\",\n\t\t.data\t\t= &sun50i_a64_csi_variant,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, sun6i_csi_of_match);\n\nstatic struct platform_driver sun6i_csi_platform_driver = {\n\t.probe\t= sun6i_csi_probe,\n\t.remove_new = sun6i_csi_remove,\n\t.driver\t= {\n\t\t.name\t\t= SUN6I_CSI_NAME,\n\t\t.of_match_table\t= sun6i_csi_of_match,\n\t\t.pm\t\t= &sun6i_csi_pm_ops,\n\t},\n};\n\nmodule_platform_driver(sun6i_csi_platform_driver);\n\nMODULE_DESCRIPTION(\"Allwinner A31 Camera Sensor Interface driver\");\nMODULE_AUTHOR(\"Yong Deng <yong.deng@magewell.com>\");\nMODULE_AUTHOR(\"Paul Kocialkowski <paul.kocialkowski@bootlin.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}