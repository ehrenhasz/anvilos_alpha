{
  "module_name": "sun6i_csi_capture.c",
  "hash_id": "18f6ac6620f7e4b5fabe4044233bb4d75441574cd097bd27ac9e912a2bd8fbba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi_capture.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mc.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"sun6i_csi.h\"\n#include \"sun6i_csi_bridge.h\"\n#include \"sun6i_csi_capture.h\"\n#include \"sun6i_csi_reg.h\"\n\n \n\nvoid sun6i_csi_capture_dimensions(struct sun6i_csi_device *csi_dev,\n\t\t\t\t  unsigned int *width, unsigned int *height)\n{\n\tif (width)\n\t\t*width = csi_dev->capture.format.fmt.pix.width;\n\tif (height)\n\t\t*height = csi_dev->capture.format.fmt.pix.height;\n}\n\nvoid sun6i_csi_capture_format(struct sun6i_csi_device *csi_dev,\n\t\t\t      u32 *pixelformat, u32 *field)\n{\n\tif (pixelformat)\n\t\t*pixelformat = csi_dev->capture.format.fmt.pix.pixelformat;\n\n\tif (field)\n\t\t*field = csi_dev->capture.format.fmt.pix.field;\n}\n\n \n\nstatic const struct sun6i_csi_capture_format sun6i_csi_capture_formats[] = {\n\t \n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_8,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_8,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_SGBRG8,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_8,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_8,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_8,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_8,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_SRGGB8,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_8,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_8,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_SBGGR10,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_10,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_10,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_SGBRG10,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_10,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_10,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_SGRBG10,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_10,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_10,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_SRGGB10,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_10,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_10,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_SBGGR12,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_12,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_12,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_SGBRG12,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_12,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_12,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_SGRBG12,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_12,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_12,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_SRGGB12,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_12,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_12,\n\t},\n\t \n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RGB565,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RGB565,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_RGB565X,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RGB565,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RGB565,\n\t},\n\t \n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_8,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_8,\n\t\t.input_format_raw\t= true,\n\t\t.hsize_len_factor\t= 2,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_YVYU,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_8,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_8,\n\t\t.input_format_raw\t= true,\n\t\t.hsize_len_factor\t= 2,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_UYVY,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_8,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_8,\n\t\t.input_format_raw\t= true,\n\t\t.hsize_len_factor\t= 2,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_VYUY,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_8,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_8,\n\t\t.input_format_raw\t= true,\n\t\t.hsize_len_factor\t= 2,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_NV16,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_YUV422SP,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_YUV422SP,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_NV61,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_YUV422SP,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_YUV422SP,\n\t\t.input_yuv_seq_invert\t= true,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_YUV422P,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_YUV422P,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_YUV422P,\n\t},\n\t \n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_NV12_16L16,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_YUV420MB,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_YUV420MB,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_NV12,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_YUV420SP,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_YUV420SP,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_NV21,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_YUV420SP,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_YUV420SP,\n\t\t.input_yuv_seq_invert\t= true,\n\t},\n\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_YUV420,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_YUV420P,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_YUV420P,\n\t},\n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_YVU420,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_YUV420P,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_YUV420P,\n\t\t.input_yuv_seq_invert\t= true,\n\t},\n\t \n\t{\n\t\t.pixelformat\t\t= V4L2_PIX_FMT_JPEG,\n\t\t.output_format_frame\t= SUN6I_CSI_OUTPUT_FMT_FRAME_RAW_8,\n\t\t.output_format_field\t= SUN6I_CSI_OUTPUT_FMT_FIELD_RAW_8,\n\t},\n};\n\nconst\nstruct sun6i_csi_capture_format *sun6i_csi_capture_format_find(u32 pixelformat)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sun6i_csi_capture_formats); i++)\n\t\tif (sun6i_csi_capture_formats[i].pixelformat == pixelformat)\n\t\t\treturn &sun6i_csi_capture_formats[i];\n\n\treturn NULL;\n}\n\n \nstatic const\nstruct sun6i_csi_capture_format_match sun6i_csi_capture_format_matches[] = {\n\t \n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUYV,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUYV,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_1X16,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_YVYU,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YVYU8_2X8,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_YVYU,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YVYU8_1X16,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_UYVY,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_UYVY,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_UYVY8_1X16,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_VYUY,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_VYUY8_2X8,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_VYUY,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_VYUY8_1X16,\n\t},\n\t \n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_RGB565,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB565_2X8_LE,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_RGB565X,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB565_2X8_BE,\n\t},\n\t \n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SGBRG8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SRGGB8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SBGGR10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SGBRG10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG10_1X10,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SGRBG10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG10_1X10,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SRGGB10,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB10_1X10,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SBGGR12,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR12_1X12,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SGBRG12,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG12_1X12,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SGRBG12,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG12_1X12,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SRGGB12,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB12_1X12,\n\t},\n\t \n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_JPEG,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_JPEG_1X8,\n\t},\n};\n\nstatic bool sun6i_csi_capture_format_match(u32 pixelformat, u32 mbus_code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sun6i_csi_capture_format_matches); i++) {\n\t\tconst struct sun6i_csi_capture_format_match *match =\n\t\t\t&sun6i_csi_capture_format_matches[i];\n\n\t\tif (match->pixelformat == pixelformat &&\n\t\t    match->mbus_code == mbus_code)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \n\nstatic void\nsun6i_csi_capture_buffer_configure(struct sun6i_csi_device *csi_dev,\n\t\t\t\t   struct sun6i_csi_buffer *csi_buffer)\n{\n\tstruct regmap *regmap = csi_dev->regmap;\n\tconst struct v4l2_format_info *info;\n\tstruct vb2_buffer *vb2_buffer;\n\tunsigned int width, height;\n\tdma_addr_t address;\n\tu32 pixelformat;\n\n\tvb2_buffer = &csi_buffer->v4l2_buffer.vb2_buf;\n\taddress = vb2_dma_contig_plane_dma_addr(vb2_buffer, 0);\n\n\tregmap_write(regmap, SUN6I_CSI_CH_FIFO0_ADDR_REG,\n\t\t     SUN6I_CSI_ADDR_VALUE(address));\n\n\tsun6i_csi_capture_dimensions(csi_dev, &width, &height);\n\tsun6i_csi_capture_format(csi_dev, &pixelformat, NULL);\n\n\tinfo = v4l2_format_info(pixelformat);\n\t \n\tif (!info)\n\t\treturn;\n\n\tif (info->comp_planes > 1) {\n\t\taddress += info->bpp[0] * width * height;\n\n\t\tregmap_write(regmap, SUN6I_CSI_CH_FIFO1_ADDR_REG,\n\t\t\t     SUN6I_CSI_ADDR_VALUE(address));\n\t}\n\n\tif (info->comp_planes > 2) {\n\t\taddress += info->bpp[1] * DIV_ROUND_UP(width, info->hdiv) *\n\t\t\t   DIV_ROUND_UP(height, info->vdiv);\n\n\t\tregmap_write(regmap, SUN6I_CSI_CH_FIFO2_ADDR_REG,\n\t\t\t     SUN6I_CSI_ADDR_VALUE(address));\n\t}\n}\n\nvoid sun6i_csi_capture_configure(struct sun6i_csi_device *csi_dev)\n{\n\tstruct regmap *regmap = csi_dev->regmap;\n\tconst struct sun6i_csi_capture_format *format;\n\tconst struct v4l2_format_info *info;\n\tu32 hsize_len, vsize_len;\n\tu32 luma_line, chroma_line = 0;\n\tu32 pixelformat, field;\n\tu32 width, height;\n\n\tsun6i_csi_capture_dimensions(csi_dev, &width, &height);\n\tsun6i_csi_capture_format(csi_dev, &pixelformat, &field);\n\n\tformat = sun6i_csi_capture_format_find(pixelformat);\n\tif (WARN_ON(!format))\n\t\treturn;\n\n\thsize_len = width;\n\tvsize_len = height;\n\n\t \n\tif (format->hsize_len_factor)\n\t\thsize_len *= format->hsize_len_factor;\n\n\tregmap_write(regmap, SUN6I_CSI_CH_HSIZE_REG,\n\t\t     SUN6I_CSI_CH_HSIZE_LEN(hsize_len) |\n\t\t     SUN6I_CSI_CH_HSIZE_START(0));\n\n\tregmap_write(regmap, SUN6I_CSI_CH_VSIZE_REG,\n\t\t     SUN6I_CSI_CH_VSIZE_LEN(vsize_len) |\n\t\t     SUN6I_CSI_CH_VSIZE_START(0));\n\n\tswitch (pixelformat) {\n\tcase V4L2_PIX_FMT_RGB565X:\n\t\tluma_line = width * 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12_16L16:\n\t\tluma_line = width;\n\t\tchroma_line = width;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_JPEG:\n\t\tluma_line = width;\n\t\tbreak;\n\tdefault:\n\t\tinfo = v4l2_format_info(pixelformat);\n\t\tif (WARN_ON(!info))\n\t\t\treturn;\n\n\t\tluma_line = width * info->bpp[0];\n\n\t\tif (info->comp_planes > 1)\n\t\t\tchroma_line = width * info->bpp[1] / info->hdiv;\n\t\tbreak;\n\t}\n\n\tregmap_write(regmap, SUN6I_CSI_CH_BUF_LEN_REG,\n\t\t     SUN6I_CSI_CH_BUF_LEN_CHROMA_LINE(chroma_line) |\n\t\t     SUN6I_CSI_CH_BUF_LEN_LUMA_LINE(luma_line));\n}\n\n \n\nstatic void sun6i_csi_capture_state_cleanup(struct sun6i_csi_device *csi_dev,\n\t\t\t\t\t    bool error)\n{\n\tstruct sun6i_csi_capture_state *state = &csi_dev->capture.state;\n\tstruct sun6i_csi_buffer **csi_buffer_states[] = {\n\t\t&state->pending, &state->current, &state->complete,\n\t};\n\tstruct sun6i_csi_buffer *csi_buffer;\n\tstruct vb2_buffer *vb2_buffer;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&state->lock, flags);\n\n\tfor (i = 0; i < ARRAY_SIZE(csi_buffer_states); i++) {\n\t\tcsi_buffer = *csi_buffer_states[i];\n\t\tif (!csi_buffer)\n\t\t\tcontinue;\n\n\t\tvb2_buffer = &csi_buffer->v4l2_buffer.vb2_buf;\n\t\tvb2_buffer_done(vb2_buffer, error ? VB2_BUF_STATE_ERROR :\n\t\t\t\tVB2_BUF_STATE_QUEUED);\n\n\t\t*csi_buffer_states[i] = NULL;\n\t}\n\n\tlist_for_each_entry(csi_buffer, &state->queue, list) {\n\t\tvb2_buffer = &csi_buffer->v4l2_buffer.vb2_buf;\n\t\tvb2_buffer_done(vb2_buffer, error ? VB2_BUF_STATE_ERROR :\n\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t}\n\n\tINIT_LIST_HEAD(&state->queue);\n\n\tspin_unlock_irqrestore(&state->lock, flags);\n}\n\nvoid sun6i_csi_capture_state_update(struct sun6i_csi_device *csi_dev)\n{\n\tstruct sun6i_csi_capture_state *state = &csi_dev->capture.state;\n\tstruct sun6i_csi_buffer *csi_buffer;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&state->lock, flags);\n\n\tif (list_empty(&state->queue))\n\t\tgoto complete;\n\n\tif (state->pending)\n\t\tgoto complete;\n\n\tcsi_buffer = list_first_entry(&state->queue, struct sun6i_csi_buffer,\n\t\t\t\t      list);\n\n\tsun6i_csi_capture_buffer_configure(csi_dev, csi_buffer);\n\n\tlist_del(&csi_buffer->list);\n\n\tstate->pending = csi_buffer;\n\ncomplete:\n\tspin_unlock_irqrestore(&state->lock, flags);\n}\n\nstatic void sun6i_csi_capture_state_complete(struct sun6i_csi_device *csi_dev)\n{\n\tstruct sun6i_csi_capture_state *state = &csi_dev->capture.state;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&state->lock, flags);\n\n\tif (!state->pending)\n\t\tgoto complete;\n\n\tstate->complete = state->current;\n\tstate->current = state->pending;\n\tstate->pending = NULL;\n\n\tif (state->complete) {\n\t\tstruct sun6i_csi_buffer *csi_buffer = state->complete;\n\t\tstruct vb2_buffer *vb2_buffer =\n\t\t\t&csi_buffer->v4l2_buffer.vb2_buf;\n\n\t\tvb2_buffer->timestamp = ktime_get_ns();\n\t\tcsi_buffer->v4l2_buffer.sequence = state->sequence;\n\n\t\tvb2_buffer_done(vb2_buffer, VB2_BUF_STATE_DONE);\n\n\t\tstate->complete = NULL;\n\t}\n\ncomplete:\n\tspin_unlock_irqrestore(&state->lock, flags);\n}\n\nvoid sun6i_csi_capture_frame_done(struct sun6i_csi_device *csi_dev)\n{\n\tstruct sun6i_csi_capture_state *state = &csi_dev->capture.state;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&state->lock, flags);\n\tstate->sequence++;\n\tspin_unlock_irqrestore(&state->lock, flags);\n}\n\nvoid sun6i_csi_capture_sync(struct sun6i_csi_device *csi_dev)\n{\n\tsun6i_csi_capture_state_complete(csi_dev);\n\tsun6i_csi_capture_state_update(csi_dev);\n}\n\n \n\nstatic int sun6i_csi_capture_queue_setup(struct vb2_queue *queue,\n\t\t\t\t\t unsigned int *buffers_count,\n\t\t\t\t\t unsigned int *planes_count,\n\t\t\t\t\t unsigned int sizes[],\n\t\t\t\t\t struct device *alloc_devs[])\n{\n\tstruct sun6i_csi_device *csi_dev = vb2_get_drv_priv(queue);\n\tunsigned int size = csi_dev->capture.format.fmt.pix.sizeimage;\n\n\tif (*planes_count)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*planes_count = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic int sun6i_csi_capture_buffer_prepare(struct vb2_buffer *buffer)\n{\n\tstruct sun6i_csi_device *csi_dev = vb2_get_drv_priv(buffer->vb2_queue);\n\tstruct sun6i_csi_capture *capture = &csi_dev->capture;\n\tstruct v4l2_device *v4l2_dev = csi_dev->v4l2_dev;\n\tstruct vb2_v4l2_buffer *v4l2_buffer = to_vb2_v4l2_buffer(buffer);\n\tunsigned long size = capture->format.fmt.pix.sizeimage;\n\n\tif (vb2_plane_size(buffer, 0) < size) {\n\t\tv4l2_err(v4l2_dev, \"buffer too small (%lu < %lu)\\n\",\n\t\t\t vb2_plane_size(buffer, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(buffer, 0, size);\n\n\tv4l2_buffer->field = capture->format.fmt.pix.field;\n\n\treturn 0;\n}\n\nstatic void sun6i_csi_capture_buffer_queue(struct vb2_buffer *buffer)\n{\n\tstruct sun6i_csi_device *csi_dev = vb2_get_drv_priv(buffer->vb2_queue);\n\tstruct sun6i_csi_capture_state *state = &csi_dev->capture.state;\n\tstruct vb2_v4l2_buffer *v4l2_buffer = to_vb2_v4l2_buffer(buffer);\n\tstruct sun6i_csi_buffer *csi_buffer =\n\t\tcontainer_of(v4l2_buffer, struct sun6i_csi_buffer, v4l2_buffer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&state->lock, flags);\n\tlist_add_tail(&csi_buffer->list, &state->queue);\n\tspin_unlock_irqrestore(&state->lock, flags);\n}\n\nstatic int sun6i_csi_capture_start_streaming(struct vb2_queue *queue,\n\t\t\t\t\t     unsigned int count)\n{\n\tstruct sun6i_csi_device *csi_dev = vb2_get_drv_priv(queue);\n\tstruct sun6i_csi_capture_state *state = &csi_dev->capture.state;\n\tstruct video_device *video_dev = &csi_dev->capture.video_dev;\n\tstruct v4l2_subdev *subdev = &csi_dev->bridge.subdev;\n\tint ret;\n\n\tstate->sequence = 0;\n\n\tret = video_device_pipeline_alloc_start(video_dev);\n\tif (ret < 0)\n\t\tgoto error_state;\n\n\tstate->streaming = true;\n\n\tret = v4l2_subdev_call(subdev, video, s_stream, 1);\n\tif (ret && ret != -ENOIOCTLCMD)\n\t\tgoto error_streaming;\n\n\treturn 0;\n\nerror_streaming:\n\tstate->streaming = false;\n\n\tvideo_device_pipeline_stop(video_dev);\n\nerror_state:\n\tsun6i_csi_capture_state_cleanup(csi_dev, false);\n\n\treturn ret;\n}\n\nstatic void sun6i_csi_capture_stop_streaming(struct vb2_queue *queue)\n{\n\tstruct sun6i_csi_device *csi_dev = vb2_get_drv_priv(queue);\n\tstruct sun6i_csi_capture_state *state = &csi_dev->capture.state;\n\tstruct video_device *video_dev = &csi_dev->capture.video_dev;\n\tstruct v4l2_subdev *subdev = &csi_dev->bridge.subdev;\n\n\tv4l2_subdev_call(subdev, video, s_stream, 0);\n\n\tstate->streaming = false;\n\n\tvideo_device_pipeline_stop(video_dev);\n\n\tsun6i_csi_capture_state_cleanup(csi_dev, true);\n}\n\nstatic const struct vb2_ops sun6i_csi_capture_queue_ops = {\n\t.queue_setup\t\t= sun6i_csi_capture_queue_setup,\n\t.buf_prepare\t\t= sun6i_csi_capture_buffer_prepare,\n\t.buf_queue\t\t= sun6i_csi_capture_buffer_queue,\n\t.start_streaming\t= sun6i_csi_capture_start_streaming,\n\t.stop_streaming\t\t= sun6i_csi_capture_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \n\nstatic void sun6i_csi_capture_format_prepare(struct v4l2_format *format)\n{\n\tstruct v4l2_pix_format *pix_format = &format->fmt.pix;\n\tconst struct v4l2_format_info *info;\n\tunsigned int width, height;\n\n\tv4l_bound_align_image(&pix_format->width, SUN6I_CSI_CAPTURE_WIDTH_MIN,\n\t\t\t      SUN6I_CSI_CAPTURE_WIDTH_MAX, 1,\n\t\t\t      &pix_format->height, SUN6I_CSI_CAPTURE_HEIGHT_MIN,\n\t\t\t      SUN6I_CSI_CAPTURE_HEIGHT_MAX, 1, 0);\n\n\tif (!sun6i_csi_capture_format_find(pix_format->pixelformat))\n\t\tpix_format->pixelformat =\n\t\t\tsun6i_csi_capture_formats[0].pixelformat;\n\n\twidth = pix_format->width;\n\theight = pix_format->height;\n\n\tinfo = v4l2_format_info(pix_format->pixelformat);\n\n\tswitch (pix_format->pixelformat) {\n\tcase V4L2_PIX_FMT_NV12_16L16:\n\t\tpix_format->bytesperline = width * 12 / 8;\n\t\tpix_format->sizeimage = pix_format->bytesperline * height;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_JPEG:\n\t\tpix_format->bytesperline = width;\n\t\tpix_format->sizeimage = pix_format->bytesperline * height;\n\t\tbreak;\n\tdefault:\n\t\tv4l2_fill_pixfmt(pix_format, pix_format->pixelformat,\n\t\t\t\t width, height);\n\t\tbreak;\n\t}\n\n\tif (pix_format->field == V4L2_FIELD_ANY)\n\t\tpix_format->field = V4L2_FIELD_NONE;\n\n\tif (pix_format->pixelformat == V4L2_PIX_FMT_JPEG)\n\t\tpix_format->colorspace = V4L2_COLORSPACE_JPEG;\n\telse if (info && info->pixel_enc == V4L2_PIXEL_ENC_BAYER)\n\t\tpix_format->colorspace = V4L2_COLORSPACE_RAW;\n\telse\n\t\tpix_format->colorspace = V4L2_COLORSPACE_SRGB;\n\n\tpix_format->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tpix_format->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tpix_format->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n}\n\nstatic int sun6i_csi_capture_querycap(struct file *file, void *private,\n\t\t\t\t      struct v4l2_capability *capability)\n{\n\tstruct sun6i_csi_device *csi_dev = video_drvdata(file);\n\tstruct video_device *video_dev = &csi_dev->capture.video_dev;\n\n\tstrscpy(capability->driver, SUN6I_CSI_NAME, sizeof(capability->driver));\n\tstrscpy(capability->card, video_dev->name, sizeof(capability->card));\n\tsnprintf(capability->bus_info, sizeof(capability->bus_info),\n\t\t \"platform:%s\", dev_name(csi_dev->dev));\n\n\treturn 0;\n}\n\nstatic int sun6i_csi_capture_enum_fmt(struct file *file, void *private,\n\t\t\t\t      struct v4l2_fmtdesc *fmtdesc)\n{\n\tu32 index = fmtdesc->index;\n\n\tif (index >= ARRAY_SIZE(sun6i_csi_capture_formats))\n\t\treturn -EINVAL;\n\n\tfmtdesc->pixelformat = sun6i_csi_capture_formats[index].pixelformat;\n\n\treturn 0;\n}\n\nstatic int sun6i_csi_capture_g_fmt(struct file *file, void *private,\n\t\t\t\t   struct v4l2_format *format)\n{\n\tstruct sun6i_csi_device *csi_dev = video_drvdata(file);\n\n\t*format = csi_dev->capture.format;\n\n\treturn 0;\n}\n\nstatic int sun6i_csi_capture_s_fmt(struct file *file, void *private,\n\t\t\t\t   struct v4l2_format *format)\n{\n\tstruct sun6i_csi_device *csi_dev = video_drvdata(file);\n\tstruct sun6i_csi_capture *capture = &csi_dev->capture;\n\n\tif (vb2_is_busy(&capture->queue))\n\t\treturn -EBUSY;\n\n\tsun6i_csi_capture_format_prepare(format);\n\n\tcsi_dev->capture.format = *format;\n\n\treturn 0;\n}\n\nstatic int sun6i_csi_capture_try_fmt(struct file *file, void *private,\n\t\t\t\t     struct v4l2_format *format)\n{\n\tsun6i_csi_capture_format_prepare(format);\n\n\treturn 0;\n}\n\nstatic int sun6i_csi_capture_enum_input(struct file *file, void *private,\n\t\t\t\t\tstruct v4l2_input *input)\n{\n\tif (input->index != 0)\n\t\treturn -EINVAL;\n\n\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\tstrscpy(input->name, \"Camera\", sizeof(input->name));\n\n\treturn 0;\n}\n\nstatic int sun6i_csi_capture_g_input(struct file *file, void *private,\n\t\t\t\t     unsigned int *index)\n{\n\t*index = 0;\n\n\treturn 0;\n}\n\nstatic int sun6i_csi_capture_s_input(struct file *file, void *private,\n\t\t\t\t     unsigned int index)\n{\n\tif (index != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops sun6i_csi_capture_ioctl_ops = {\n\t.vidioc_querycap\t\t= sun6i_csi_capture_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= sun6i_csi_capture_enum_fmt,\n\t.vidioc_g_fmt_vid_cap\t\t= sun6i_csi_capture_g_fmt,\n\t.vidioc_s_fmt_vid_cap\t\t= sun6i_csi_capture_s_fmt,\n\t.vidioc_try_fmt_vid_cap\t\t= sun6i_csi_capture_try_fmt,\n\n\t.vidioc_enum_input\t\t= sun6i_csi_capture_enum_input,\n\t.vidioc_g_input\t\t\t= sun6i_csi_capture_g_input,\n\t.vidioc_s_input\t\t\t= sun6i_csi_capture_s_input,\n\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n};\n\n \n\nstatic int sun6i_csi_capture_open(struct file *file)\n{\n\tstruct sun6i_csi_device *csi_dev = video_drvdata(file);\n\tstruct sun6i_csi_capture *capture = &csi_dev->capture;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&capture->lock))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_pipeline_pm_get(&capture->video_dev.entity);\n\tif (ret < 0)\n\t\tgoto error_lock;\n\n\tret = v4l2_fh_open(file);\n\tif (ret < 0)\n\t\tgoto error_pipeline;\n\n\tmutex_unlock(&capture->lock);\n\n\treturn 0;\n\nerror_pipeline:\n\tv4l2_pipeline_pm_put(&capture->video_dev.entity);\n\nerror_lock:\n\tmutex_unlock(&capture->lock);\n\n\treturn ret;\n}\n\nstatic int sun6i_csi_capture_close(struct file *file)\n{\n\tstruct sun6i_csi_device *csi_dev = video_drvdata(file);\n\tstruct sun6i_csi_capture *capture = &csi_dev->capture;\n\n\tmutex_lock(&capture->lock);\n\n\t_vb2_fop_release(file, NULL);\n\tv4l2_pipeline_pm_put(&capture->video_dev.entity);\n\n\tmutex_unlock(&capture->lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations sun6i_csi_capture_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= sun6i_csi_capture_open,\n\t.release\t= sun6i_csi_capture_close,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.poll\t\t= vb2_fop_poll\n};\n\n \n\nstatic int sun6i_csi_capture_link_validate(struct media_link *link)\n{\n\tstruct video_device *video_dev =\n\t\tmedia_entity_to_video_device(link->sink->entity);\n\tstruct sun6i_csi_device *csi_dev = video_get_drvdata(video_dev);\n\tstruct v4l2_device *v4l2_dev = csi_dev->v4l2_dev;\n\tconst struct sun6i_csi_capture_format *capture_format;\n\tconst struct sun6i_csi_bridge_format *bridge_format;\n\tunsigned int capture_width, capture_height;\n\tunsigned int bridge_width, bridge_height;\n\tconst struct v4l2_format_info *format_info;\n\tu32 pixelformat, capture_field;\n\tu32 mbus_code, bridge_field;\n\tbool match;\n\n\tsun6i_csi_capture_dimensions(csi_dev, &capture_width, &capture_height);\n\n\tsun6i_csi_capture_format(csi_dev, &pixelformat, &capture_field);\n\tcapture_format = sun6i_csi_capture_format_find(pixelformat);\n\tif (WARN_ON(!capture_format))\n\t\treturn -EINVAL;\n\n\tsun6i_csi_bridge_dimensions(csi_dev, &bridge_width, &bridge_height);\n\n\tsun6i_csi_bridge_format(csi_dev, &mbus_code, &bridge_field);\n\tbridge_format = sun6i_csi_bridge_format_find(mbus_code);\n\tif (WARN_ON(!bridge_format))\n\t\treturn -EINVAL;\n\n\t \n\tif (capture_width != bridge_width || capture_height != bridge_height) {\n\t\tv4l2_err(v4l2_dev,\n\t\t\t \"invalid input/output dimensions: %ux%u/%ux%u\\n\",\n\t\t\t bridge_width, bridge_height, capture_width,\n\t\t\t capture_height);\n\t\treturn -EINVAL;\n\t}\n\n\tformat_info = v4l2_format_info(pixelformat);\n\t \n\tif (!format_info)\n\t\treturn 0;\n\n\tif (format_info->pixel_enc == V4L2_PIXEL_ENC_BAYER &&\n\t    bridge_format->input_format != SUN6I_CSI_INPUT_FMT_RAW)\n\t\tgoto invalid;\n\n\tif (format_info->pixel_enc == V4L2_PIXEL_ENC_RGB &&\n\t    bridge_format->input_format != SUN6I_CSI_INPUT_FMT_RAW)\n\t\tgoto invalid;\n\n\tif (format_info->pixel_enc == V4L2_PIXEL_ENC_YUV) {\n\t\tif (bridge_format->input_format != SUN6I_CSI_INPUT_FMT_YUV420 &&\n\t\t    bridge_format->input_format != SUN6I_CSI_INPUT_FMT_YUV422)\n\t\t\tgoto invalid;\n\n\t\t \n\t\tif (bridge_format->input_format == SUN6I_CSI_INPUT_FMT_YUV420 &&\n\t\t    format_info->vdiv == 1)\n\t\t\tgoto invalid;\n\t}\n\n\t \n\tif (bridge_format->input_format == SUN6I_CSI_INPUT_FMT_RAW ||\n\t    capture_format->input_format_raw) {\n\t\tmatch = sun6i_csi_capture_format_match(pixelformat, mbus_code);\n\t\tif (!match)\n\t\t\tgoto invalid;\n\t}\n\n\treturn 0;\n\ninvalid:\n\tv4l2_err(v4l2_dev, \"invalid input/output format combination\\n\");\n\treturn -EINVAL;\n}\n\nstatic const struct media_entity_operations sun6i_csi_capture_media_ops = {\n\t.link_validate = sun6i_csi_capture_link_validate\n};\n\n \n\nint sun6i_csi_capture_setup(struct sun6i_csi_device *csi_dev)\n{\n\tstruct sun6i_csi_capture *capture = &csi_dev->capture;\n\tstruct sun6i_csi_capture_state *state = &capture->state;\n\tstruct v4l2_device *v4l2_dev = csi_dev->v4l2_dev;\n\tstruct v4l2_subdev *bridge_subdev = &csi_dev->bridge.subdev;\n\tstruct video_device *video_dev = &capture->video_dev;\n\tstruct vb2_queue *queue = &capture->queue;\n\tstruct media_pad *pad = &capture->pad;\n\tstruct v4l2_format *format = &csi_dev->capture.format;\n\tstruct v4l2_pix_format *pix_format = &format->fmt.pix;\n\tint ret;\n\n\t \n\tif (state->setup)\n\t\treturn 0;\n\n\t \n\n\tINIT_LIST_HEAD(&state->queue);\n\tspin_lock_init(&state->lock);\n\n\t \n\n\tvideo_dev->entity.ops = &sun6i_csi_capture_media_ops;\n\n\t \n\n\tpad->flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT;\n\n\tret = media_entity_pads_init(&video_dev->entity, 1, pad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\tmutex_init(&capture->lock);\n\n\tqueue->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tqueue->io_modes = VB2_MMAP | VB2_DMABUF;\n\tqueue->buf_struct_size = sizeof(struct sun6i_csi_buffer);\n\tqueue->ops = &sun6i_csi_capture_queue_ops;\n\tqueue->mem_ops = &vb2_dma_contig_memops;\n\tqueue->min_buffers_needed = 2;\n\tqueue->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tqueue->lock = &capture->lock;\n\tqueue->dev = csi_dev->dev;\n\tqueue->drv_priv = csi_dev;\n\n\tret = vb2_queue_init(queue);\n\tif (ret) {\n\t\tv4l2_err(v4l2_dev, \"failed to initialize vb2 queue: %d\\n\", ret);\n\t\tgoto error_media_entity;\n\t}\n\n\t \n\n\tformat->type = queue->type;\n\tpix_format->pixelformat = sun6i_csi_capture_formats[0].pixelformat;\n\tpix_format->width = 1280;\n\tpix_format->height = 720;\n\tpix_format->field = V4L2_FIELD_NONE;\n\n\tsun6i_csi_capture_format_prepare(format);\n\n\t \n\n\tstrscpy(video_dev->name, SUN6I_CSI_CAPTURE_NAME,\n\t\tsizeof(video_dev->name));\n\tvideo_dev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\n\tvideo_dev->vfl_dir = VFL_DIR_RX;\n\tvideo_dev->release = video_device_release_empty;\n\tvideo_dev->fops = &sun6i_csi_capture_fops;\n\tvideo_dev->ioctl_ops = &sun6i_csi_capture_ioctl_ops;\n\tvideo_dev->v4l2_dev = v4l2_dev;\n\tvideo_dev->queue = queue;\n\tvideo_dev->lock = &capture->lock;\n\n\tvideo_set_drvdata(video_dev, csi_dev);\n\n\tret = video_register_device(video_dev, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0) {\n\t\tv4l2_err(v4l2_dev, \"failed to register video device: %d\\n\",\n\t\t\t ret);\n\t\tgoto error_media_entity;\n\t}\n\n\t \n\n\tret = media_create_pad_link(&bridge_subdev->entity,\n\t\t\t\t    SUN6I_CSI_BRIDGE_PAD_SOURCE,\n\t\t\t\t    &video_dev->entity, 0,\n\t\t\t\t    csi_dev->isp_available ? 0 :\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret < 0) {\n\t\tv4l2_err(v4l2_dev, \"failed to create %s:%u -> %s:%u link\\n\",\n\t\t\t bridge_subdev->entity.name,\n\t\t\t SUN6I_CSI_BRIDGE_PAD_SOURCE,\n\t\t\t video_dev->entity.name, 0);\n\t\tgoto error_video_device;\n\t}\n\n\tstate->setup = true;\n\n\treturn 0;\n\nerror_video_device:\n\tvb2_video_unregister_device(video_dev);\n\nerror_media_entity:\n\tmedia_entity_cleanup(&video_dev->entity);\n\n\tmutex_destroy(&capture->lock);\n\n\treturn ret;\n}\n\nvoid sun6i_csi_capture_cleanup(struct sun6i_csi_device *csi_dev)\n{\n\tstruct sun6i_csi_capture *capture = &csi_dev->capture;\n\tstruct video_device *video_dev = &capture->video_dev;\n\n\t \n\tif (!capture->state.setup)\n\t\treturn;\n\n\tvb2_video_unregister_device(video_dev);\n\tmedia_entity_cleanup(&video_dev->entity);\n\tmutex_destroy(&capture->lock);\n\n\tcapture->state.setup = false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}