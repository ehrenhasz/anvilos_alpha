{
  "module_name": "sun6i_csi_bridge.c",
  "hash_id": "dca1019e6b057a230fad48cfef39c65ec235376e50cf33d982ddbcae87e1bd69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/sunxi/sun6i-csi/sun6i_csi_bridge.c",
  "human_readable_source": "\n \n\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n\n#include \"sun6i_csi.h\"\n#include \"sun6i_csi_bridge.h\"\n#include \"sun6i_csi_reg.h\"\n\n \n\nvoid sun6i_csi_bridge_dimensions(struct sun6i_csi_device *csi_dev,\n\t\t\t\t unsigned int *width, unsigned int *height)\n{\n\tif (width)\n\t\t*width = csi_dev->bridge.mbus_format.width;\n\tif (height)\n\t\t*height = csi_dev->bridge.mbus_format.height;\n}\n\nvoid sun6i_csi_bridge_format(struct sun6i_csi_device *csi_dev,\n\t\t\t     u32 *mbus_code, u32 *field)\n{\n\tif (mbus_code)\n\t\t*mbus_code = csi_dev->bridge.mbus_format.code;\n\tif (field)\n\t\t*field = csi_dev->bridge.mbus_format.field;\n}\n\n \n\nstatic const struct sun6i_csi_bridge_format sun6i_csi_bridge_formats[] = {\n\t \n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t \n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_RGB565_2X8_LE,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_RGB565_2X8_BE,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n\t \n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_YUV422,\n\t\t.input_yuv_seq\t\t= SUN6I_CSI_INPUT_YUV_SEQ_YUYV,\n\t\t.input_yuv_seq_invert\t= SUN6I_CSI_INPUT_YUV_SEQ_YVYU,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_YUV422,\n\t\t.input_yuv_seq\t\t= SUN6I_CSI_INPUT_YUV_SEQ_UYVY,\n\t\t.input_yuv_seq_invert\t= SUN6I_CSI_INPUT_YUV_SEQ_VYUY,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_YVYU8_2X8,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_YUV422,\n\t\t.input_yuv_seq\t\t= SUN6I_CSI_INPUT_YUV_SEQ_YVYU,\n\t\t.input_yuv_seq_invert\t= SUN6I_CSI_INPUT_YUV_SEQ_YUYV,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_YUV422,\n\t\t.input_yuv_seq\t\t= SUN6I_CSI_INPUT_YUV_SEQ_UYVY,\n\t\t.input_yuv_seq_invert\t= SUN6I_CSI_INPUT_YUV_SEQ_VYUY,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_VYUY8_2X8,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_YUV422,\n\t\t.input_yuv_seq\t\t= SUN6I_CSI_INPUT_YUV_SEQ_VYUY,\n\t\t.input_yuv_seq_invert\t= SUN6I_CSI_INPUT_YUV_SEQ_UYVY,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_YUYV8_1X16,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_YUV422,\n\t\t.input_yuv_seq\t\t= SUN6I_CSI_INPUT_YUV_SEQ_YUYV,\n\t\t.input_yuv_seq_invert\t= SUN6I_CSI_INPUT_YUV_SEQ_YVYU,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_YUV422,\n\t\t.input_yuv_seq\t\t= SUN6I_CSI_INPUT_YUV_SEQ_UYVY,\n\t\t.input_yuv_seq_invert\t= SUN6I_CSI_INPUT_YUV_SEQ_VYUY,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_YVYU8_1X16,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_YUV422,\n\t\t.input_yuv_seq\t\t= SUN6I_CSI_INPUT_YUV_SEQ_YVYU,\n\t\t.input_yuv_seq_invert\t= SUN6I_CSI_INPUT_YUV_SEQ_YUYV,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_YUV422,\n\t\t.input_yuv_seq\t\t= SUN6I_CSI_INPUT_YUV_SEQ_UYVY,\n\t\t.input_yuv_seq_invert\t= SUN6I_CSI_INPUT_YUV_SEQ_VYUY,\n\t},\n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_VYUY8_1X16,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_YUV422,\n\t\t.input_yuv_seq\t\t= SUN6I_CSI_INPUT_YUV_SEQ_VYUY,\n\t\t.input_yuv_seq_invert\t= SUN6I_CSI_INPUT_YUV_SEQ_UYVY,\n\t},\n\t \n\t{\n\t\t.mbus_code\t\t= MEDIA_BUS_FMT_JPEG_1X8,\n\t\t.input_format\t\t= SUN6I_CSI_INPUT_FMT_RAW,\n\t},\n};\n\nconst struct sun6i_csi_bridge_format *\nsun6i_csi_bridge_format_find(u32 mbus_code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sun6i_csi_bridge_formats); i++)\n\t\tif (sun6i_csi_bridge_formats[i].mbus_code == mbus_code)\n\t\t\treturn &sun6i_csi_bridge_formats[i];\n\n\treturn NULL;\n}\n\n \n\nstatic void sun6i_csi_bridge_irq_enable(struct sun6i_csi_device *csi_dev)\n{\n\tstruct regmap *regmap = csi_dev->regmap;\n\n\tregmap_write(regmap, SUN6I_CSI_CH_INT_EN_REG,\n\t\t     SUN6I_CSI_CH_INT_EN_VS |\n\t\t     SUN6I_CSI_CH_INT_EN_HB_OF |\n\t\t     SUN6I_CSI_CH_INT_EN_FIFO2_OF |\n\t\t     SUN6I_CSI_CH_INT_EN_FIFO1_OF |\n\t\t     SUN6I_CSI_CH_INT_EN_FIFO0_OF |\n\t\t     SUN6I_CSI_CH_INT_EN_FD |\n\t\t     SUN6I_CSI_CH_INT_EN_CD);\n}\n\nstatic void sun6i_csi_bridge_irq_disable(struct sun6i_csi_device *csi_dev)\n{\n\tstruct regmap *regmap = csi_dev->regmap;\n\n\tregmap_write(regmap, SUN6I_CSI_CH_INT_EN_REG, 0);\n}\n\nstatic void sun6i_csi_bridge_irq_clear(struct sun6i_csi_device *csi_dev)\n{\n\tstruct regmap *regmap = csi_dev->regmap;\n\n\tregmap_write(regmap, SUN6I_CSI_CH_INT_EN_REG, 0);\n\tregmap_write(regmap, SUN6I_CSI_CH_INT_STA_REG,\n\t\t     SUN6I_CSI_CH_INT_STA_CLEAR);\n}\n\nstatic void sun6i_csi_bridge_enable(struct sun6i_csi_device *csi_dev)\n{\n\tstruct regmap *regmap = csi_dev->regmap;\n\n\tregmap_update_bits(regmap, SUN6I_CSI_EN_REG, SUN6I_CSI_EN_CSI_EN,\n\t\t\t   SUN6I_CSI_EN_CSI_EN);\n\n\tregmap_update_bits(regmap, SUN6I_CSI_CAP_REG, SUN6I_CSI_CAP_VCAP_ON,\n\t\t\t   SUN6I_CSI_CAP_VCAP_ON);\n}\n\nstatic void sun6i_csi_bridge_disable(struct sun6i_csi_device *csi_dev)\n{\n\tstruct regmap *regmap = csi_dev->regmap;\n\n\tregmap_update_bits(regmap, SUN6I_CSI_CAP_REG, SUN6I_CSI_CAP_VCAP_ON, 0);\n\tregmap_update_bits(regmap, SUN6I_CSI_EN_REG, SUN6I_CSI_EN_CSI_EN, 0);\n}\n\nstatic void\nsun6i_csi_bridge_configure_parallel(struct sun6i_csi_device *csi_dev)\n{\n\tstruct device *dev = csi_dev->dev;\n\tstruct regmap *regmap = csi_dev->regmap;\n\tstruct v4l2_fwnode_endpoint *endpoint =\n\t\t&csi_dev->bridge.source_parallel.endpoint;\n\tunsigned char bus_width = endpoint->bus.parallel.bus_width;\n\tunsigned int flags = endpoint->bus.parallel.flags;\n\tu32 field;\n\tu32 value = SUN6I_CSI_IF_CFG_IF_CSI;\n\n\tsun6i_csi_bridge_format(csi_dev, NULL, &field);\n\n\tif (field == V4L2_FIELD_INTERLACED ||\n\t    field == V4L2_FIELD_INTERLACED_TB ||\n\t    field == V4L2_FIELD_INTERLACED_BT)\n\t\tvalue |= SUN6I_CSI_IF_CFG_SRC_TYPE_INTERLACED |\n\t\t\t SUN6I_CSI_IF_CFG_FIELD_DT_PCLK_SHIFT(1) |\n\t\t\t SUN6I_CSI_IF_CFG_FIELD_DT_FIELD_VSYNC;\n\telse\n\t\tvalue |= SUN6I_CSI_IF_CFG_SRC_TYPE_PROGRESSIVE;\n\n\tswitch (endpoint->bus_type) {\n\tcase V4L2_MBUS_PARALLEL:\n\t\tif (bus_width == 16)\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_IF_CSI_YUV_COMBINED;\n\t\telse\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_IF_CSI_YUV_RAW;\n\n\t\tif (flags & V4L2_MBUS_FIELD_EVEN_LOW)\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_FIELD_NEGATIVE;\n\t\telse\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_FIELD_POSITIVE;\n\n\t\tif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_VREF_POL_NEGATIVE;\n\t\telse\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_VREF_POL_POSITIVE;\n\n\t\tif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_HREF_POL_NEGATIVE;\n\t\telse\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_HREF_POL_POSITIVE;\n\n\t\tif (flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_CLK_POL_RISING;\n\t\telse\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_CLK_POL_FALLING;\n\t\tbreak;\n\tcase V4L2_MBUS_BT656:\n\t\tif (bus_width == 16)\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_IF_CSI_BT1120;\n\t\telse\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_IF_CSI_BT656;\n\n\t\tif (flags & V4L2_MBUS_FIELD_EVEN_LOW)\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_FIELD_NEGATIVE;\n\t\telse\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_FIELD_POSITIVE;\n\n\t\tif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_CLK_POL_RISING;\n\t\telse\n\t\t\tvalue |= SUN6I_CSI_IF_CFG_CLK_POL_FALLING;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"unsupported bus type: %d\\n\", endpoint->bus_type);\n\t\tbreak;\n\t}\n\n\tswitch (bus_width) {\n\tcase 8:\n\t \n\tcase 16:\n\t\tvalue |= SUN6I_CSI_IF_CFG_DATA_WIDTH_8;\n\t\tbreak;\n\tcase 10:\n\t\tvalue |= SUN6I_CSI_IF_CFG_DATA_WIDTH_10;\n\t\tbreak;\n\tcase 12:\n\t\tvalue |= SUN6I_CSI_IF_CFG_DATA_WIDTH_12;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"unsupported bus width: %u\\n\", bus_width);\n\t\tbreak;\n\t}\n\n\tregmap_write(regmap, SUN6I_CSI_IF_CFG_REG, value);\n}\n\nstatic void\nsun6i_csi_bridge_configure_mipi_csi2(struct sun6i_csi_device *csi_dev)\n{\n\tstruct regmap *regmap = csi_dev->regmap;\n\tu32 value = SUN6I_CSI_IF_CFG_IF_MIPI;\n\tu32 field;\n\n\tsun6i_csi_bridge_format(csi_dev, NULL, &field);\n\n\tif (field == V4L2_FIELD_INTERLACED ||\n\t    field == V4L2_FIELD_INTERLACED_TB ||\n\t    field == V4L2_FIELD_INTERLACED_BT)\n\t\tvalue |= SUN6I_CSI_IF_CFG_SRC_TYPE_INTERLACED;\n\telse\n\t\tvalue |= SUN6I_CSI_IF_CFG_SRC_TYPE_PROGRESSIVE;\n\n\tregmap_write(regmap, SUN6I_CSI_IF_CFG_REG, value);\n}\n\nstatic void sun6i_csi_bridge_configure_format(struct sun6i_csi_device *csi_dev)\n{\n\tstruct regmap *regmap = csi_dev->regmap;\n\tbool capture_streaming = csi_dev->capture.state.streaming;\n\tconst struct sun6i_csi_bridge_format *bridge_format;\n\tconst struct sun6i_csi_capture_format *capture_format;\n\tu32 mbus_code, field, pixelformat;\n\tu8 input_format, input_yuv_seq, output_format;\n\tu32 value = 0;\n\n\tsun6i_csi_bridge_format(csi_dev, &mbus_code, &field);\n\n\tbridge_format = sun6i_csi_bridge_format_find(mbus_code);\n\tif (WARN_ON(!bridge_format))\n\t\treturn;\n\n\tinput_format = bridge_format->input_format;\n\tinput_yuv_seq = bridge_format->input_yuv_seq;\n\n\tif (capture_streaming) {\n\t\tsun6i_csi_capture_format(csi_dev, &pixelformat, NULL);\n\n\t\tcapture_format = sun6i_csi_capture_format_find(pixelformat);\n\t\tif (WARN_ON(!capture_format))\n\t\t\treturn;\n\n\t\tif (capture_format->input_format_raw)\n\t\t\tinput_format = SUN6I_CSI_INPUT_FMT_RAW;\n\n\t\tif (capture_format->input_yuv_seq_invert)\n\t\t\tinput_yuv_seq = bridge_format->input_yuv_seq_invert;\n\n\t\tif (field == V4L2_FIELD_INTERLACED ||\n\t\t    field == V4L2_FIELD_INTERLACED_TB ||\n\t\t    field == V4L2_FIELD_INTERLACED_BT)\n\t\t\toutput_format = capture_format->output_format_field;\n\t\telse\n\t\t\toutput_format = capture_format->output_format_frame;\n\n\t\tvalue |= SUN6I_CSI_CH_CFG_OUTPUT_FMT(output_format);\n\t}\n\n\tvalue |= SUN6I_CSI_CH_CFG_INPUT_FMT(input_format);\n\tvalue |= SUN6I_CSI_CH_CFG_INPUT_YUV_SEQ(input_yuv_seq);\n\n\tif (field == V4L2_FIELD_TOP)\n\t\tvalue |= SUN6I_CSI_CH_CFG_FIELD_SEL_FIELD0;\n\telse if (field == V4L2_FIELD_BOTTOM)\n\t\tvalue |= SUN6I_CSI_CH_CFG_FIELD_SEL_FIELD1;\n\telse\n\t\tvalue |= SUN6I_CSI_CH_CFG_FIELD_SEL_EITHER;\n\n\tregmap_write(regmap, SUN6I_CSI_CH_CFG_REG, value);\n}\n\nstatic void sun6i_csi_bridge_configure(struct sun6i_csi_device *csi_dev,\n\t\t\t\t       struct sun6i_csi_bridge_source *source)\n{\n\tstruct sun6i_csi_bridge *bridge = &csi_dev->bridge;\n\n\tif (source == &bridge->source_parallel)\n\t\tsun6i_csi_bridge_configure_parallel(csi_dev);\n\telse\n\t\tsun6i_csi_bridge_configure_mipi_csi2(csi_dev);\n\n\tsun6i_csi_bridge_configure_format(csi_dev);\n}\n\n \n\nstatic int sun6i_csi_bridge_s_stream(struct v4l2_subdev *subdev, int on)\n{\n\tstruct sun6i_csi_device *csi_dev = v4l2_get_subdevdata(subdev);\n\tstruct sun6i_csi_bridge *bridge = &csi_dev->bridge;\n\tstruct media_pad *local_pad = &bridge->pads[SUN6I_CSI_BRIDGE_PAD_SINK];\n\tbool capture_streaming = csi_dev->capture.state.streaming;\n\tstruct device *dev = csi_dev->dev;\n\tstruct sun6i_csi_bridge_source *source;\n\tstruct v4l2_subdev *source_subdev;\n\tstruct media_pad *remote_pad;\n\tint ret;\n\n\t \n\n\tremote_pad = media_pad_remote_pad_unique(local_pad);\n\tif (IS_ERR(remote_pad)) {\n\t\tdev_err(dev,\n\t\t\t\"zero or more than a single source connected to the bridge\\n\");\n\t\treturn PTR_ERR(remote_pad);\n\t}\n\n\tsource_subdev = media_entity_to_v4l2_subdev(remote_pad->entity);\n\n\tif (source_subdev == bridge->source_parallel.subdev)\n\t\tsource = &bridge->source_parallel;\n\telse\n\t\tsource = &bridge->source_mipi_csi2;\n\n\tif (!on) {\n\t\tv4l2_subdev_call(source_subdev, video, s_stream, 0);\n\t\tret = 0;\n\t\tgoto disable;\n\t}\n\n\t \n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\tsun6i_csi_bridge_irq_clear(csi_dev);\n\n\t \n\n\tsun6i_csi_bridge_configure(csi_dev, source);\n\n\tif (capture_streaming)\n\t\tsun6i_csi_capture_configure(csi_dev);\n\n\t \n\n\tif (capture_streaming)\n\t\tsun6i_csi_capture_state_update(csi_dev);\n\n\t \n\n\tif (capture_streaming)\n\t\tsun6i_csi_bridge_irq_enable(csi_dev);\n\n\tsun6i_csi_bridge_enable(csi_dev);\n\n\tret = v4l2_subdev_call(source_subdev, video, s_stream, 1);\n\tif (ret && ret != -ENOIOCTLCMD)\n\t\tgoto disable;\n\n\treturn 0;\n\ndisable:\n\tif (capture_streaming)\n\t\tsun6i_csi_bridge_irq_disable(csi_dev);\n\n\tsun6i_csi_bridge_disable(csi_dev);\n\n\tpm_runtime_put(dev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_video_ops sun6i_csi_bridge_video_ops = {\n\t.s_stream\t= sun6i_csi_bridge_s_stream,\n};\n\nstatic void\nsun6i_csi_bridge_mbus_format_prepare(struct v4l2_mbus_framefmt *mbus_format)\n{\n\tif (!sun6i_csi_bridge_format_find(mbus_format->code))\n\t\tmbus_format->code = sun6i_csi_bridge_formats[0].mbus_code;\n\n\tmbus_format->field = V4L2_FIELD_NONE;\n\tmbus_format->colorspace = V4L2_COLORSPACE_RAW;\n\tmbus_format->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tmbus_format->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n}\n\nstatic int sun6i_csi_bridge_init_cfg(struct v4l2_subdev *subdev,\n\t\t\t\t     struct v4l2_subdev_state *state)\n{\n\tstruct sun6i_csi_device *csi_dev = v4l2_get_subdevdata(subdev);\n\tunsigned int pad = SUN6I_CSI_BRIDGE_PAD_SINK;\n\tstruct v4l2_mbus_framefmt *mbus_format =\n\t\tv4l2_subdev_get_try_format(subdev, state, pad);\n\tstruct mutex *lock = &csi_dev->bridge.lock;\n\n\tmutex_lock(lock);\n\n\tmbus_format->code = sun6i_csi_bridge_formats[0].mbus_code;\n\tmbus_format->width = 1280;\n\tmbus_format->height = 720;\n\n\tsun6i_csi_bridge_mbus_format_prepare(mbus_format);\n\n\tmutex_unlock(lock);\n\n\treturn 0;\n}\n\nstatic int\nsun6i_csi_bridge_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t\tstruct v4l2_subdev_state *state,\n\t\t\t\tstruct v4l2_subdev_mbus_code_enum *code_enum)\n{\n\tif (code_enum->index >= ARRAY_SIZE(sun6i_csi_bridge_formats))\n\t\treturn -EINVAL;\n\n\tcode_enum->code = sun6i_csi_bridge_formats[code_enum->index].mbus_code;\n\n\treturn 0;\n}\n\nstatic int sun6i_csi_bridge_get_fmt(struct v4l2_subdev *subdev,\n\t\t\t\t    struct v4l2_subdev_state *state,\n\t\t\t\t    struct v4l2_subdev_format *format)\n{\n\tstruct sun6i_csi_device *csi_dev = v4l2_get_subdevdata(subdev);\n\tstruct v4l2_mbus_framefmt *mbus_format = &format->format;\n\tstruct mutex *lock = &csi_dev->bridge.lock;\n\n\tmutex_lock(lock);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t*mbus_format = *v4l2_subdev_get_try_format(subdev, state,\n\t\t\t\t\t\t\t   format->pad);\n\telse\n\t\t*mbus_format = csi_dev->bridge.mbus_format;\n\n\tmutex_unlock(lock);\n\n\treturn 0;\n}\n\nstatic int sun6i_csi_bridge_set_fmt(struct v4l2_subdev *subdev,\n\t\t\t\t    struct v4l2_subdev_state *state,\n\t\t\t\t    struct v4l2_subdev_format *format)\n{\n\tstruct sun6i_csi_device *csi_dev = v4l2_get_subdevdata(subdev);\n\tstruct v4l2_mbus_framefmt *mbus_format = &format->format;\n\tstruct mutex *lock = &csi_dev->bridge.lock;\n\n\tmutex_lock(lock);\n\n\tsun6i_csi_bridge_mbus_format_prepare(mbus_format);\n\n\tif (format->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t*v4l2_subdev_get_try_format(subdev, state, format->pad) =\n\t\t\t*mbus_format;\n\telse\n\t\tcsi_dev->bridge.mbus_format = *mbus_format;\n\n\tmutex_unlock(lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops sun6i_csi_bridge_pad_ops = {\n\t.init_cfg\t= sun6i_csi_bridge_init_cfg,\n\t.enum_mbus_code\t= sun6i_csi_bridge_enum_mbus_code,\n\t.get_fmt\t= sun6i_csi_bridge_get_fmt,\n\t.set_fmt\t= sun6i_csi_bridge_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops sun6i_csi_bridge_subdev_ops = {\n\t.video\t= &sun6i_csi_bridge_video_ops,\n\t.pad\t= &sun6i_csi_bridge_pad_ops,\n};\n\n \n\nstatic const struct media_entity_operations sun6i_csi_bridge_entity_ops = {\n\t.link_validate\t= v4l2_subdev_link_validate,\n};\n\n \n\nstatic int sun6i_csi_bridge_link(struct sun6i_csi_device *csi_dev,\n\t\t\t\t int sink_pad_index,\n\t\t\t\t struct v4l2_subdev *remote_subdev,\n\t\t\t\t bool enabled)\n{\n\tstruct device *dev = csi_dev->dev;\n\tstruct v4l2_subdev *subdev = &csi_dev->bridge.subdev;\n\tstruct media_entity *sink_entity = &subdev->entity;\n\tstruct media_entity *source_entity = &remote_subdev->entity;\n\tint source_pad_index;\n\tint ret;\n\n\t \n\tret = media_entity_get_fwnode_pad(source_entity, remote_subdev->fwnode,\n\t\t\t\t\t  MEDIA_PAD_FL_SOURCE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing source pad in external entity %s\\n\",\n\t\t\tsource_entity->name);\n\t\treturn -EINVAL;\n\t}\n\n\tsource_pad_index = ret;\n\n\tdev_dbg(dev, \"creating %s:%u -> %s:%u link\\n\", source_entity->name,\n\t\tsource_pad_index, sink_entity->name, sink_pad_index);\n\n\tret = media_create_pad_link(source_entity, source_pad_index,\n\t\t\t\t    sink_entity, sink_pad_index,\n\t\t\t\t    enabled ? MEDIA_LNK_FL_ENABLED : 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to create %s:%u -> %s:%u link\\n\",\n\t\t\tsource_entity->name, source_pad_index,\n\t\t\tsink_entity->name, sink_pad_index);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nsun6i_csi_bridge_notifier_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\tstruct v4l2_subdev *remote_subdev,\n\t\t\t\tstruct v4l2_async_connection *async_subdev)\n{\n\tstruct sun6i_csi_device *csi_dev =\n\t\tcontainer_of(notifier, struct sun6i_csi_device,\n\t\t\t     bridge.notifier);\n\tstruct sun6i_csi_bridge_async_subdev *bridge_async_subdev =\n\t\tcontainer_of(async_subdev, struct sun6i_csi_bridge_async_subdev,\n\t\t\t     async_subdev);\n\tstruct sun6i_csi_bridge *bridge = &csi_dev->bridge;\n\tstruct sun6i_csi_bridge_source *source = bridge_async_subdev->source;\n\tbool enabled = false;\n\tint ret;\n\n\tswitch (source->endpoint.base.port) {\n\tcase SUN6I_CSI_PORT_PARALLEL:\n\t\tenabled = true;\n\t\tbreak;\n\tcase SUN6I_CSI_PORT_MIPI_CSI2:\n\t\tenabled = !bridge->source_parallel.expected;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsource->subdev = remote_subdev;\n\n\tif (csi_dev->isp_available) {\n\t\t \n\t\tret = sun6i_csi_isp_complete(csi_dev, remote_subdev->v4l2_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn sun6i_csi_bridge_link(csi_dev, SUN6I_CSI_BRIDGE_PAD_SINK,\n\t\t\t\t     remote_subdev, enabled);\n}\n\nstatic int\nsun6i_csi_bridge_notifier_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct sun6i_csi_device *csi_dev =\n\t\tcontainer_of(notifier, struct sun6i_csi_device,\n\t\t\t     bridge.notifier);\n\tstruct v4l2_device *v4l2_dev = &csi_dev->v4l2.v4l2_dev;\n\n\tif (csi_dev->isp_available)\n\t\treturn 0;\n\n\treturn v4l2_device_register_subdev_nodes(v4l2_dev);\n}\n\nstatic const struct v4l2_async_notifier_operations\nsun6i_csi_bridge_notifier_ops = {\n\t.bound\t\t= sun6i_csi_bridge_notifier_bound,\n\t.complete\t= sun6i_csi_bridge_notifier_complete,\n};\n\n \n\nstatic int sun6i_csi_bridge_source_setup(struct sun6i_csi_device *csi_dev,\n\t\t\t\t\t struct sun6i_csi_bridge_source *source,\n\t\t\t\t\t u32 port,\n\t\t\t\t\t enum v4l2_mbus_type *bus_types)\n{\n\tstruct device *dev = csi_dev->dev;\n\tstruct v4l2_async_notifier *notifier = &csi_dev->bridge.notifier;\n\tstruct v4l2_fwnode_endpoint *endpoint = &source->endpoint;\n\tstruct sun6i_csi_bridge_async_subdev *bridge_async_subdev;\n\tstruct fwnode_handle *handle;\n\tint ret;\n\n\thandle = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev), port, 0, 0);\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tret = v4l2_fwnode_endpoint_parse(handle, endpoint);\n\tif (ret)\n\t\tgoto complete;\n\n\tif (bus_types) {\n\t\tbool valid = false;\n\t\tunsigned int i;\n\n\t\tfor (i = 0; bus_types[i] != V4L2_MBUS_INVALID; i++) {\n\t\t\tif (endpoint->bus_type == bus_types[i]) {\n\t\t\t\tvalid = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!valid) {\n\t\t\tdev_err(dev, \"unsupported bus type for port %d\\n\",\n\t\t\t\tport);\n\t\t\tret = -EINVAL;\n\t\t\tgoto complete;\n\t\t}\n\t}\n\n\tbridge_async_subdev =\n\t\tv4l2_async_nf_add_fwnode_remote(notifier, handle,\n\t\t\t\t\t\tstruct\n\t\t\t\t\t\tsun6i_csi_bridge_async_subdev);\n\tif (IS_ERR(bridge_async_subdev)) {\n\t\tret = PTR_ERR(bridge_async_subdev);\n\t\tgoto complete;\n\t}\n\n\tbridge_async_subdev->source = source;\n\n\tsource->expected = true;\n\ncomplete:\n\tfwnode_handle_put(handle);\n\n\treturn ret;\n}\n\nint sun6i_csi_bridge_setup(struct sun6i_csi_device *csi_dev)\n{\n\tstruct device *dev = csi_dev->dev;\n\tstruct sun6i_csi_bridge *bridge = &csi_dev->bridge;\n\tstruct v4l2_device *v4l2_dev = csi_dev->v4l2_dev;\n\tstruct v4l2_subdev *subdev = &bridge->subdev;\n\tstruct v4l2_async_notifier *notifier = &bridge->notifier;\n\tstruct media_pad *pads = bridge->pads;\n\tenum v4l2_mbus_type parallel_mbus_types[] = {\n\t\tV4L2_MBUS_PARALLEL,\n\t\tV4L2_MBUS_BT656,\n\t\tV4L2_MBUS_INVALID\n\t};\n\tint ret;\n\n\tmutex_init(&bridge->lock);\n\n\t \n\n\tv4l2_subdev_init(subdev, &sun6i_csi_bridge_subdev_ops);\n\tstrscpy(subdev->name, SUN6I_CSI_BRIDGE_NAME, sizeof(subdev->name));\n\tsubdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsubdev->owner = THIS_MODULE;\n\tsubdev->dev = dev;\n\n\tv4l2_set_subdevdata(subdev, csi_dev);\n\n\t \n\n\tsubdev->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tsubdev->entity.ops = &sun6i_csi_bridge_entity_ops;\n\n\t \n\n\tpads[SUN6I_CSI_BRIDGE_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tpads[SUN6I_CSI_BRIDGE_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE |\n\t\t\t\t\t\t  MEDIA_PAD_FL_MUST_CONNECT;\n\n\tret = media_entity_pads_init(&subdev->entity,\n\t\t\t\t     SUN6I_CSI_BRIDGE_PAD_COUNT, pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\tif (csi_dev->isp_available)\n\t\tret = v4l2_async_register_subdev(subdev);\n\telse\n\t\tret = v4l2_device_register_subdev(v4l2_dev, subdev);\n\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register v4l2 subdev: %d\\n\", ret);\n\t\tgoto error_media_entity;\n\t}\n\n\t \n\n\tif (csi_dev->isp_available)\n\t\tv4l2_async_subdev_nf_init(notifier, subdev);\n\telse\n\t\tv4l2_async_nf_init(notifier, v4l2_dev);\n\tnotifier->ops = &sun6i_csi_bridge_notifier_ops;\n\n\tsun6i_csi_bridge_source_setup(csi_dev, &bridge->source_parallel,\n\t\t\t\t      SUN6I_CSI_PORT_PARALLEL,\n\t\t\t\t      parallel_mbus_types);\n\tsun6i_csi_bridge_source_setup(csi_dev, &bridge->source_mipi_csi2,\n\t\t\t\t      SUN6I_CSI_PORT_MIPI_CSI2, NULL);\n\n\tret = v4l2_async_nf_register(notifier);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register v4l2 async notifier: %d\\n\",\n\t\t\tret);\n\t\tgoto error_v4l2_async_notifier;\n\t}\n\n\treturn 0;\n\nerror_v4l2_async_notifier:\n\tv4l2_async_nf_cleanup(notifier);\n\n\tif (csi_dev->isp_available)\n\t\tv4l2_async_unregister_subdev(subdev);\n\telse\n\t\tv4l2_device_unregister_subdev(subdev);\n\nerror_media_entity:\n\tmedia_entity_cleanup(&subdev->entity);\n\n\treturn ret;\n}\n\nvoid sun6i_csi_bridge_cleanup(struct sun6i_csi_device *csi_dev)\n{\n\tstruct v4l2_subdev *subdev = &csi_dev->bridge.subdev;\n\tstruct v4l2_async_notifier *notifier = &csi_dev->bridge.notifier;\n\n\tv4l2_async_nf_unregister(notifier);\n\tv4l2_async_nf_cleanup(notifier);\n\n\tv4l2_device_unregister_subdev(subdev);\n\n\tmedia_entity_cleanup(&subdev->entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}