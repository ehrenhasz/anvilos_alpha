{
  "module_name": "sun4i_v4l2.c",
  "hash_id": "52f2b22bf12f6cf7e6351e4dc9feb30462b723579fab2573e6a065c7ba589537",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/sunxi/sun4i-csi/sun4i_v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mc.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"sun4i_csi.h\"\n\n#define CSI_DEFAULT_WIDTH\t640\n#define CSI_DEFAULT_HEIGHT\t480\n\nstatic const struct sun4i_csi_format sun4i_csi_formats[] = {\n\t \n\t{\n\t\t.mbus\t\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV420M,\n\t\t.input\t\t= CSI_INPUT_YUV,\n\t\t.output\t\t= CSI_OUTPUT_YUV_420_PLANAR,\n\t\t.num_planes\t= 3,\n\t\t.bpp\t\t= { 8, 8, 8 },\n\t\t.hsub\t\t= 2,\n\t\t.vsub\t\t= 2,\n\t},\n};\n\nconst struct sun4i_csi_format *sun4i_csi_find_format(const u32 *fourcc,\n\t\t\t\t\t\t     const u32 *mbus)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sun4i_csi_formats); i++) {\n\t\tif (fourcc && *fourcc != sun4i_csi_formats[i].fourcc)\n\t\t\tcontinue;\n\n\t\tif (mbus && *mbus != sun4i_csi_formats[i].mbus)\n\t\t\tcontinue;\n\n\t\treturn &sun4i_csi_formats[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int sun4i_csi_querycap(struct file *file, void *priv,\n\t\t\t      struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrscpy(cap->card, \"sun4i-csi\", sizeof(cap->card));\n\n\treturn 0;\n}\n\nstatic int sun4i_csi_enum_input(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_input *inp)\n{\n\tif (inp->index != 0)\n\t\treturn -EINVAL;\n\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tstrscpy(inp->name, \"Camera\", sizeof(inp->name));\n\n\treturn 0;\n}\n\nstatic int sun4i_csi_g_input(struct file *file, void *fh,\n\t\t\t     unsigned int *i)\n{\n\t*i = 0;\n\n\treturn 0;\n}\n\nstatic int sun4i_csi_s_input(struct file *file, void *fh,\n\t\t\t     unsigned int i)\n{\n\tif (i != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void _sun4i_csi_try_fmt(struct sun4i_csi *csi,\n\t\t\t       struct v4l2_pix_format_mplane *pix)\n{\n\tconst struct sun4i_csi_format *_fmt;\n\tunsigned int height, width;\n\tunsigned int i;\n\n\t_fmt = sun4i_csi_find_format(&pix->pixelformat, NULL);\n\tif (!_fmt)\n\t\t_fmt = &sun4i_csi_formats[0];\n\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->colorspace = V4L2_COLORSPACE_SRGB;\n\tpix->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(pix->colorspace);\n\tpix->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(pix->colorspace);\n\tpix->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true, pix->colorspace,\n\t\t\t\t\t\t\t  pix->ycbcr_enc);\n\n\tpix->num_planes = _fmt->num_planes;\n\tpix->pixelformat = _fmt->fourcc;\n\n\t \n\twidth = ALIGN(pix->width, _fmt->hsub);\n\theight = ALIGN(pix->height, _fmt->vsub);\n\n\t \n\tpix->width = clamp(width, _fmt->hsub, CSI_MAX_WIDTH);\n\tpix->height = clamp(height, _fmt->vsub, CSI_MAX_HEIGHT);\n\n\tfor (i = 0; i < _fmt->num_planes; i++) {\n\t\tunsigned int hsub = i > 0 ? _fmt->hsub : 1;\n\t\tunsigned int vsub = i > 0 ? _fmt->vsub : 1;\n\t\tunsigned int bpl;\n\n\t\tbpl = pix->width / hsub * _fmt->bpp[i] / 8;\n\t\tpix->plane_fmt[i].bytesperline = bpl;\n\t\tpix->plane_fmt[i].sizeimage = bpl * pix->height / vsub;\n\t}\n}\n\nstatic int sun4i_csi_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_format *f)\n{\n\tstruct sun4i_csi *csi = video_drvdata(file);\n\n\t_sun4i_csi_try_fmt(csi, &f->fmt.pix_mp);\n\n\treturn 0;\n}\n\nstatic int sun4i_csi_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct sun4i_csi *csi = video_drvdata(file);\n\n\t_sun4i_csi_try_fmt(csi, &f->fmt.pix_mp);\n\tcsi->fmt = f->fmt.pix_mp;\n\n\treturn 0;\n}\n\nstatic int sun4i_csi_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct sun4i_csi *csi = video_drvdata(file);\n\n\tf->fmt.pix_mp = csi->fmt;\n\n\treturn 0;\n}\n\nstatic int sun4i_csi_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t      struct v4l2_fmtdesc *f)\n{\n\tif (f->index >= ARRAY_SIZE(sun4i_csi_formats))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = sun4i_csi_formats[f->index].fourcc;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops sun4i_csi_ioctl_ops = {\n\t.vidioc_querycap\t\t= sun4i_csi_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= sun4i_csi_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap_mplane\t= sun4i_csi_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap_mplane\t= sun4i_csi_s_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap_mplane\t= sun4i_csi_try_fmt_vid_cap,\n\n\t.vidioc_enum_input\t\t= sun4i_csi_enum_input,\n\t.vidioc_g_input\t\t\t= sun4i_csi_g_input,\n\t.vidioc_s_input\t\t\t= sun4i_csi_s_input,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n};\n\nstatic int sun4i_csi_open(struct file *file)\n{\n\tstruct sun4i_csi *csi = video_drvdata(file);\n\tint ret;\n\n\tret = mutex_lock_interruptible(&csi->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(csi->dev);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\tret = v4l2_pipeline_pm_get(&csi->vdev.entity);\n\tif (ret)\n\t\tgoto err_pm_put;\n\n\tret = v4l2_fh_open(file);\n\tif (ret)\n\t\tgoto err_pipeline_pm_put;\n\n\tmutex_unlock(&csi->lock);\n\n\treturn 0;\n\nerr_pipeline_pm_put:\n\tv4l2_pipeline_pm_put(&csi->vdev.entity);\n\nerr_pm_put:\n\tpm_runtime_put(csi->dev);\n\nerr_unlock:\n\tmutex_unlock(&csi->lock);\n\n\treturn ret;\n}\n\nstatic int sun4i_csi_release(struct file *file)\n{\n\tstruct sun4i_csi *csi = video_drvdata(file);\n\n\tmutex_lock(&csi->lock);\n\n\t_vb2_fop_release(file, NULL);\n\n\tv4l2_pipeline_pm_put(&csi->vdev.entity);\n\tpm_runtime_put(csi->dev);\n\n\tmutex_unlock(&csi->lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations sun4i_csi_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= sun4i_csi_open,\n\t.release\t= sun4i_csi_release,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.poll\t\t= vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n};\n\nstatic const struct v4l2_mbus_framefmt sun4i_csi_pad_fmt_default = {\n\t.width = CSI_DEFAULT_WIDTH,\n\t.height = CSI_DEFAULT_HEIGHT,\n\t.code = MEDIA_BUS_FMT_YUYV8_2X8,\n\t.field = V4L2_FIELD_NONE,\n\t.colorspace = V4L2_COLORSPACE_RAW,\n\t.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,\n\t.quantization = V4L2_QUANTIZATION_DEFAULT,\n\t.xfer_func = V4L2_XFER_FUNC_DEFAULT,\n};\n\nstatic int sun4i_csi_subdev_init_cfg(struct v4l2_subdev *subdev,\n\t\t\t\t     struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tfmt = v4l2_subdev_get_try_format(subdev, sd_state, CSI_SUBDEV_SINK);\n\t*fmt = sun4i_csi_pad_fmt_default;\n\n\treturn 0;\n}\n\nstatic int sun4i_csi_subdev_get_fmt(struct v4l2_subdev *subdev,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct sun4i_csi *csi = container_of(subdev, struct sun4i_csi, subdev);\n\tstruct v4l2_mbus_framefmt *subdev_fmt;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\tsubdev_fmt = v4l2_subdev_get_try_format(subdev, sd_state,\n\t\t\t\t\t\t\tfmt->pad);\n\telse\n\t\tsubdev_fmt = &csi->subdev_fmt;\n\n\tfmt->format = *subdev_fmt;\n\n\treturn 0;\n}\n\nstatic int sun4i_csi_subdev_set_fmt(struct v4l2_subdev *subdev,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct sun4i_csi *csi = container_of(subdev, struct sun4i_csi, subdev);\n\tstruct v4l2_mbus_framefmt *subdev_fmt;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\tsubdev_fmt = v4l2_subdev_get_try_format(subdev, sd_state,\n\t\t\t\t\t\t\tfmt->pad);\n\telse\n\t\tsubdev_fmt = &csi->subdev_fmt;\n\n\t \n\tif (fmt->pad == CSI_SUBDEV_SINK) {\n\t\t \n\t\tsubdev_fmt->width = fmt->format.width;\n\t\tsubdev_fmt->height = fmt->format.height;\n\t\tsubdev_fmt->code = fmt->format.code;\n\t}\n\n\tfmt->format = *subdev_fmt;\n\n\treturn 0;\n}\n\nstatic int\nsun4i_csi_subdev_enum_mbus_code(struct v4l2_subdev *subdev,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_mbus_code_enum *mbus)\n{\n\tif (mbus->index >= ARRAY_SIZE(sun4i_csi_formats))\n\t\treturn -EINVAL;\n\n\tmbus->code = sun4i_csi_formats[mbus->index].mbus;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops sun4i_csi_subdev_pad_ops = {\n\t.link_validate\t= v4l2_subdev_link_validate_default,\n\t.init_cfg\t= sun4i_csi_subdev_init_cfg,\n\t.get_fmt\t= sun4i_csi_subdev_get_fmt,\n\t.set_fmt\t= sun4i_csi_subdev_set_fmt,\n\t.enum_mbus_code\t= sun4i_csi_subdev_enum_mbus_code,\n};\n\nconst struct v4l2_subdev_ops sun4i_csi_subdev_ops = {\n\t.pad = &sun4i_csi_subdev_pad_ops,\n};\n\nint sun4i_csi_v4l2_register(struct sun4i_csi *csi)\n{\n\tstruct video_device *vdev = &csi->vdev;\n\tint ret;\n\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING;\n\tvdev->v4l2_dev = &csi->v4l;\n\tvdev->queue = &csi->queue;\n\tstrscpy(vdev->name, KBUILD_MODNAME, sizeof(vdev->name));\n\tvdev->release = video_device_release_empty;\n\tvdev->lock = &csi->lock;\n\n\t \n\tcsi->fmt.pixelformat = sun4i_csi_formats[0].fourcc;\n\tcsi->fmt.width = CSI_DEFAULT_WIDTH;\n\tcsi->fmt.height = CSI_DEFAULT_HEIGHT;\n\t_sun4i_csi_try_fmt(csi, &csi->fmt);\n\tcsi->subdev_fmt = sun4i_csi_pad_fmt_default;\n\n\tvdev->fops = &sun4i_csi_fops;\n\tvdev->ioctl_ops = &sun4i_csi_ioctl_ops;\n\tvideo_set_drvdata(vdev, csi);\n\n\tret = video_register_device(&csi->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(csi->dev, \"Device registered as %s\\n\",\n\t\t video_device_node_name(vdev));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}