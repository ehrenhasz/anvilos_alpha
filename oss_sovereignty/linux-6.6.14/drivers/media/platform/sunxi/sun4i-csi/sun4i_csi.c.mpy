{
  "module_name": "sun4i_csi.c",
  "hash_id": "9e7db82a81a605aeb80cfc3abbb250e38ad9e3b85d8e75df9aa26ee0ed3a68b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/sunxi/sun4i-csi/sun4i_csi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-dev.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mediabus.h>\n\n#include <media/videobuf2-core.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"sun4i_csi.h\"\n\nstruct sun4i_csi_traits {\n\tunsigned int channels;\n\tunsigned int max_width;\n\tbool has_isp;\n};\n\nstatic const struct media_entity_operations sun4i_csi_video_entity_ops = {\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\nstatic int sun4i_csi_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t  struct v4l2_subdev *subdev,\n\t\t\t\t  struct v4l2_async_connection *asd)\n{\n\tstruct sun4i_csi *csi = container_of(notifier, struct sun4i_csi,\n\t\t\t\t\t     notifier);\n\n\tcsi->src_subdev = subdev;\n\tcsi->src_pad = media_entity_get_fwnode_pad(&subdev->entity,\n\t\t\t\t\t\t   subdev->fwnode,\n\t\t\t\t\t\t   MEDIA_PAD_FL_SOURCE);\n\tif (csi->src_pad < 0) {\n\t\tdev_err(csi->dev, \"Couldn't find output pad for subdev %s\\n\",\n\t\t\tsubdev->name);\n\t\treturn csi->src_pad;\n\t}\n\n\tdev_dbg(csi->dev, \"Bound %s pad: %d\\n\", subdev->name, csi->src_pad);\n\treturn 0;\n}\n\nstatic int sun4i_csi_notify_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct sun4i_csi *csi = container_of(notifier, struct sun4i_csi,\n\t\t\t\t\t     notifier);\n\tstruct v4l2_subdev *subdev = &csi->subdev;\n\tstruct video_device *vdev = &csi->vdev;\n\tint ret;\n\n\tret = v4l2_device_register_subdev(&csi->v4l, subdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = sun4i_csi_v4l2_register(csi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = media_device_register(&csi->mdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = media_create_pad_link(&subdev->entity, CSI_SUBDEV_SOURCE,\n\t\t\t\t    &vdev->entity, 0,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret)\n\t\tgoto err_clean_media;\n\n\tret = media_create_pad_link(&csi->src_subdev->entity, csi->src_pad,\n\t\t\t\t    &subdev->entity, CSI_SUBDEV_SINK,\n\t\t\t\t    MEDIA_LNK_FL_ENABLED |\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE);\n\tif (ret)\n\t\tgoto err_clean_media;\n\n\tret = v4l2_device_register_subdev_nodes(&csi->v4l);\n\tif (ret < 0)\n\t\tgoto err_clean_media;\n\n\treturn 0;\n\nerr_clean_media:\n\tmedia_device_unregister(&csi->mdev);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_async_notifier_operations sun4i_csi_notify_ops = {\n\t.bound\t\t= sun4i_csi_notify_bound,\n\t.complete\t= sun4i_csi_notify_complete,\n};\n\nstatic int sun4i_csi_notifier_init(struct sun4i_csi *csi)\n{\n\tstruct v4l2_fwnode_endpoint vep = {\n\t\t.bus_type = V4L2_MBUS_PARALLEL,\n\t};\n\tstruct v4l2_async_connection *asd;\n\tstruct fwnode_handle *ep;\n\tint ret;\n\n\tv4l2_async_nf_init(&csi->notifier, &csi->v4l);\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(csi->dev), 0, 0,\n\t\t\t\t\t     FWNODE_GRAPH_ENDPOINT_NEXT);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\tif (ret)\n\t\tgoto out;\n\n\tcsi->bus = vep.bus.parallel;\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&csi->notifier, ep,\n\t\t\t\t\t      struct v4l2_async_connection);\n\tif (IS_ERR(asd)) {\n\t\tret = PTR_ERR(asd);\n\t\tgoto out;\n\t}\n\n\tcsi->notifier.ops = &sun4i_csi_notify_ops;\n\nout:\n\tfwnode_handle_put(ep);\n\treturn ret;\n}\n\nstatic int sun4i_csi_probe(struct platform_device *pdev)\n{\n\tstruct v4l2_subdev *subdev;\n\tstruct video_device *vdev;\n\tstruct sun4i_csi *csi;\n\tint ret;\n\tint irq;\n\n\tcsi = devm_kzalloc(&pdev->dev, sizeof(*csi), GFP_KERNEL);\n\tif (!csi)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, csi);\n\tcsi->dev = &pdev->dev;\n\tsubdev = &csi->subdev;\n\tvdev = &csi->vdev;\n\n\tcsi->traits = of_device_get_match_data(&pdev->dev);\n\tif (!csi->traits)\n\t\treturn -EINVAL;\n\n\tcsi->mdev.dev = csi->dev;\n\tstrscpy(csi->mdev.model, \"Allwinner Video Capture Device\",\n\t\tsizeof(csi->mdev.model));\n\tcsi->mdev.hw_revision = 0;\n\tmedia_device_init(&csi->mdev);\n\tcsi->v4l.mdev = &csi->mdev;\n\n\tcsi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(csi->regs))\n\t\treturn PTR_ERR(csi->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tcsi->bus_clk = devm_clk_get(&pdev->dev, \"bus\");\n\tif (IS_ERR(csi->bus_clk)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get our bus clock\\n\");\n\t\treturn PTR_ERR(csi->bus_clk);\n\t}\n\n\tif (csi->traits->has_isp) {\n\t\tcsi->isp_clk = devm_clk_get(&pdev->dev, \"isp\");\n\t\tif (IS_ERR(csi->isp_clk)) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't get our ISP clock\\n\");\n\t\t\treturn PTR_ERR(csi->isp_clk);\n\t\t}\n\t}\n\n\tcsi->ram_clk = devm_clk_get(&pdev->dev, \"ram\");\n\tif (IS_ERR(csi->ram_clk)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get our ram clock\\n\");\n\t\treturn PTR_ERR(csi->ram_clk);\n\t}\n\n\tcsi->rst = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(csi->rst)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get our reset line\\n\");\n\t\treturn PTR_ERR(csi->rst);\n\t}\n\n\t \n\tv4l2_subdev_init(subdev, &sun4i_csi_subdev_ops);\n\tsubdev->flags = V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\n\tsubdev->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tsubdev->owner = THIS_MODULE;\n\tsnprintf(subdev->name, sizeof(subdev->name), \"sun4i-csi-0\");\n\tv4l2_set_subdevdata(subdev, csi);\n\n\tcsi->subdev_pads[CSI_SUBDEV_SINK].flags =\n\t\tMEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT;\n\tcsi->subdev_pads[CSI_SUBDEV_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&subdev->entity, CSI_SUBDEV_PADS,\n\t\t\t\t     csi->subdev_pads);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcsi->vdev_pad.flags = MEDIA_PAD_FL_SINK | MEDIA_PAD_FL_MUST_CONNECT;\n\tvdev->entity.ops = &sun4i_csi_video_entity_ops;\n\tret = media_entity_pads_init(&vdev->entity, 1, &csi->vdev_pad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = sun4i_csi_dma_register(csi, irq);\n\tif (ret)\n\t\tgoto err_clean_pad;\n\n\tret = sun4i_csi_notifier_init(csi);\n\tif (ret)\n\t\tgoto err_unregister_media;\n\n\tret = v4l2_async_nf_register(&csi->notifier);\n\tif (ret) {\n\t\tdev_err(csi->dev, \"Couldn't register our notifier.\\n\");\n\t\tgoto err_unregister_media;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n\nerr_unregister_media:\n\tmedia_device_unregister(&csi->mdev);\n\tsun4i_csi_dma_unregister(csi);\n\nerr_clean_pad:\n\tmedia_device_cleanup(&csi->mdev);\n\n\treturn ret;\n}\n\nstatic void sun4i_csi_remove(struct platform_device *pdev)\n{\n\tstruct sun4i_csi *csi = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tv4l2_async_nf_unregister(&csi->notifier);\n\tv4l2_async_nf_cleanup(&csi->notifier);\n\tvb2_video_unregister_device(&csi->vdev);\n\tmedia_device_unregister(&csi->mdev);\n\tsun4i_csi_dma_unregister(csi);\n\tmedia_device_cleanup(&csi->mdev);\n}\n\nstatic const struct sun4i_csi_traits sun4i_a10_csi1_traits = {\n\t.channels = 1,\n\t.max_width = 24,\n\t.has_isp = false,\n};\n\nstatic const struct sun4i_csi_traits sun7i_a20_csi0_traits = {\n\t.channels = 4,\n\t.max_width = 16,\n\t.has_isp = true,\n};\n\nstatic const struct of_device_id sun4i_csi_of_match[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-csi1\", .data = &sun4i_a10_csi1_traits },\n\t{ .compatible = \"allwinner,sun7i-a20-csi0\", .data = &sun7i_a20_csi0_traits },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sun4i_csi_of_match);\n\nstatic int __maybe_unused sun4i_csi_runtime_resume(struct device *dev)\n{\n\tstruct sun4i_csi *csi = dev_get_drvdata(dev);\n\n\treset_control_deassert(csi->rst);\n\tclk_prepare_enable(csi->bus_clk);\n\tclk_prepare_enable(csi->ram_clk);\n\tclk_set_rate(csi->isp_clk, 80000000);\n\tclk_prepare_enable(csi->isp_clk);\n\n\twritel(1, csi->regs + CSI_EN_REG);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sun4i_csi_runtime_suspend(struct device *dev)\n{\n\tstruct sun4i_csi *csi = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(csi->isp_clk);\n\tclk_disable_unprepare(csi->ram_clk);\n\tclk_disable_unprepare(csi->bus_clk);\n\n\treset_control_assert(csi->rst);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops sun4i_csi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(sun4i_csi_runtime_suspend,\n\t\t\t   sun4i_csi_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver sun4i_csi_driver = {\n\t.probe\t= sun4i_csi_probe,\n\t.remove_new = sun4i_csi_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"sun4i-csi\",\n\t\t.of_match_table\t= sun4i_csi_of_match,\n\t\t.pm\t\t= &sun4i_csi_pm_ops,\n\t},\n};\nmodule_platform_driver(sun4i_csi_driver);\n\nMODULE_DESCRIPTION(\"Allwinner A10 Camera Sensor Interface driver\");\nMODULE_AUTHOR(\"Maxime Ripard <mripard@kernel.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}