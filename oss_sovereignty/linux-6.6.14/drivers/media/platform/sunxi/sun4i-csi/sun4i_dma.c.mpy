{
  "module_name": "sun4i_dma.c",
  "hash_id": "a9ed0dfa7ec8d8d22744f7f9176ec6663bc1094d5552b117f15cf0d0f02b7632",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/sunxi/sun4i-csi/sun4i_dma.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"sun4i_csi.h\"\n\nstruct sun4i_csi_buffer {\n\tstruct vb2_v4l2_buffer\tvb;\n\tstruct list_head\tlist;\n};\n\nstatic inline struct sun4i_csi_buffer *\nvb2_v4l2_to_csi_buffer(const struct vb2_v4l2_buffer *p)\n{\n\treturn container_of(p, struct sun4i_csi_buffer, vb);\n}\n\nstatic inline struct sun4i_csi_buffer *\nvb2_to_csi_buffer(const struct vb2_buffer *p)\n{\n\treturn vb2_v4l2_to_csi_buffer(to_vb2_v4l2_buffer(p));\n}\n\nstatic void sun4i_csi_capture_start(struct sun4i_csi *csi)\n{\n\twritel(CSI_CPT_CTRL_VIDEO_START, csi->regs + CSI_CPT_CTRL_REG);\n}\n\nstatic void sun4i_csi_capture_stop(struct sun4i_csi *csi)\n{\n\twritel(0, csi->regs + CSI_CPT_CTRL_REG);\n}\n\nstatic int sun4i_csi_queue_setup(struct vb2_queue *vq,\n\t\t\t\t unsigned int *nbuffers,\n\t\t\t\t unsigned int *nplanes,\n\t\t\t\t unsigned int sizes[],\n\t\t\t\t struct device *alloc_devs[])\n{\n\tstruct sun4i_csi *csi = vb2_get_drv_priv(vq);\n\tunsigned int num_planes = csi->fmt.num_planes;\n\tunsigned int i;\n\n\tif (*nplanes) {\n\t\tif (*nplanes != num_planes)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < num_planes; i++)\n\t\t\tif (sizes[i] < csi->fmt.plane_fmt[i].sizeimage)\n\t\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t*nplanes = num_planes;\n\tfor (i = 0; i < num_planes; i++)\n\t\tsizes[i] = csi->fmt.plane_fmt[i].sizeimage;\n\n\treturn 0;\n};\n\nstatic int sun4i_csi_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct sun4i_csi *csi = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned int i;\n\n\tfor (i = 0; i < csi->fmt.num_planes; i++) {\n\t\tunsigned long size = csi->fmt.plane_fmt[i].sizeimage;\n\n\t\tif (vb2_plane_size(vb, i) < size) {\n\t\t\tdev_err(csi->dev, \"buffer too small (%lu < %lu)\\n\",\n\t\t\t\tvb2_plane_size(vb, i), size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvb2_set_plane_payload(vb, i, size);\n\t}\n\n\treturn 0;\n}\n\nstatic int sun4i_csi_setup_scratch_buffer(struct sun4i_csi *csi,\n\t\t\t\t\t  unsigned int slot)\n{\n\tdma_addr_t addr = csi->scratch.paddr;\n\tunsigned int plane;\n\n\tdev_dbg(csi->dev,\n\t\t\"No more available buffer, using the scratch buffer\\n\");\n\n\tfor (plane = 0; plane < csi->fmt.num_planes; plane++) {\n\t\twritel(addr, csi->regs + CSI_BUF_ADDR_REG(plane, slot));\n\t\taddr += csi->fmt.plane_fmt[plane].sizeimage;\n\t}\n\n\tcsi->current_buf[slot] = NULL;\n\treturn 0;\n}\n\nstatic int sun4i_csi_buffer_fill_slot(struct sun4i_csi *csi, unsigned int slot)\n{\n\tstruct sun4i_csi_buffer *c_buf;\n\tstruct vb2_v4l2_buffer *v_buf;\n\tunsigned int plane;\n\n\t \n\tif (WARN_ON(csi->current_buf[slot]))\n\t\treturn -EINVAL;\n\n\tif (list_empty(&csi->buf_list))\n\t\treturn sun4i_csi_setup_scratch_buffer(csi, slot);\n\n\tc_buf = list_first_entry(&csi->buf_list, struct sun4i_csi_buffer, list);\n\tlist_del_init(&c_buf->list);\n\n\tv_buf = &c_buf->vb;\n\tcsi->current_buf[slot] = v_buf;\n\n\tfor (plane = 0; plane < csi->fmt.num_planes; plane++) {\n\t\tdma_addr_t buf_addr;\n\n\t\tbuf_addr = vb2_dma_contig_plane_dma_addr(&v_buf->vb2_buf,\n\t\t\t\t\t\t\t plane);\n\t\twritel(buf_addr, csi->regs + CSI_BUF_ADDR_REG(plane, slot));\n\t}\n\n\treturn 0;\n}\n\nstatic int sun4i_csi_buffer_fill_all(struct sun4i_csi *csi)\n{\n\tunsigned int slot;\n\tint ret;\n\n\tfor (slot = 0; slot < CSI_MAX_BUFFER; slot++) {\n\t\tret = sun4i_csi_buffer_fill_slot(csi, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void sun4i_csi_buffer_mark_done(struct sun4i_csi *csi,\n\t\t\t\t       unsigned int slot,\n\t\t\t\t       unsigned int sequence)\n{\n\tstruct vb2_v4l2_buffer *v_buf;\n\n\tif (!csi->current_buf[slot]) {\n\t\tdev_dbg(csi->dev, \"Scratch buffer was used, ignoring..\\n\");\n\t\treturn;\n\t}\n\n\tv_buf = csi->current_buf[slot];\n\tv_buf->field = csi->fmt.field;\n\tv_buf->sequence = sequence;\n\tv_buf->vb2_buf.timestamp = ktime_get_ns();\n\tvb2_buffer_done(&v_buf->vb2_buf, VB2_BUF_STATE_DONE);\n\n\tcsi->current_buf[slot] = NULL;\n}\n\nstatic int sun4i_csi_buffer_flip(struct sun4i_csi *csi, unsigned int sequence)\n{\n\tu32 reg = readl(csi->regs + CSI_BUF_CTRL_REG);\n\tunsigned int next;\n\n\t \n\tnext = !(reg & CSI_BUF_CTRL_DBS);\n\n\t \n\tsun4i_csi_buffer_mark_done(csi, next, sequence);\n\n\t \n\treturn sun4i_csi_buffer_fill_slot(csi, next);\n}\n\nstatic void sun4i_csi_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct sun4i_csi *csi = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct sun4i_csi_buffer *buf = vb2_to_csi_buffer(vb);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&csi->qlock, flags);\n\tlist_add_tail(&buf->list, &csi->buf_list);\n\tspin_unlock_irqrestore(&csi->qlock, flags);\n}\n\nstatic void return_all_buffers(struct sun4i_csi *csi,\n\t\t\t       enum vb2_buffer_state state)\n{\n\tstruct sun4i_csi_buffer *buf, *node;\n\tunsigned int slot;\n\n\tlist_for_each_entry_safe(buf, node, &csi->buf_list, list) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t\tlist_del(&buf->list);\n\t}\n\n\tfor (slot = 0; slot < CSI_MAX_BUFFER; slot++) {\n\t\tstruct vb2_v4l2_buffer *v_buf = csi->current_buf[slot];\n\n\t\tif (!v_buf)\n\t\t\tcontinue;\n\n\t\tvb2_buffer_done(&v_buf->vb2_buf, state);\n\t\tcsi->current_buf[slot] = NULL;\n\t}\n}\n\nstatic int sun4i_csi_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct sun4i_csi *csi = vb2_get_drv_priv(vq);\n\tstruct v4l2_mbus_config_parallel *bus = &csi->bus;\n\tconst struct sun4i_csi_format *csi_fmt;\n\tunsigned long href_pol, pclk_pol, vref_pol;\n\tunsigned long flags;\n\tunsigned int i;\n\tint ret;\n\n\tcsi_fmt = sun4i_csi_find_format(&csi->fmt.pixelformat, NULL);\n\tif (!csi_fmt)\n\t\treturn -EINVAL;\n\n\tdev_dbg(csi->dev, \"Starting capture\\n\");\n\n\tcsi->sequence = 0;\n\n\t \n\tcsi->scratch.size = 0;\n\tfor (i = 0; i < csi->fmt.num_planes; i++)\n\t\tcsi->scratch.size += csi->fmt.plane_fmt[i].sizeimage;\n\n\tcsi->scratch.vaddr = dma_alloc_coherent(csi->dev,\n\t\t\t\t\t\tcsi->scratch.size,\n\t\t\t\t\t\t&csi->scratch.paddr,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!csi->scratch.vaddr) {\n\t\tdev_err(csi->dev, \"Failed to allocate scratch buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_clear_dma_queue;\n\t}\n\n\tret = video_device_pipeline_alloc_start(&csi->vdev);\n\tif (ret < 0)\n\t\tgoto err_free_scratch_buffer;\n\n\tspin_lock_irqsave(&csi->qlock, flags);\n\n\t \n\twritel(CSI_WIN_CTRL_W_ACTIVE(csi->fmt.width * 2),\n\t       csi->regs + CSI_WIN_CTRL_W_REG);\n\twritel(CSI_WIN_CTRL_H_ACTIVE(csi->fmt.height),\n\t       csi->regs + CSI_WIN_CTRL_H_REG);\n\n\t \n\thref_pol = !!(bus->flags & V4L2_MBUS_HSYNC_ACTIVE_LOW);\n\tvref_pol = !!(bus->flags & V4L2_MBUS_VSYNC_ACTIVE_LOW);\n\tpclk_pol = !!(bus->flags & V4L2_MBUS_PCLK_SAMPLE_RISING);\n\twritel(CSI_CFG_INPUT_FMT(csi_fmt->input) |\n\t       CSI_CFG_OUTPUT_FMT(csi_fmt->output) |\n\t       CSI_CFG_VREF_POL(vref_pol) |\n\t       CSI_CFG_HREF_POL(href_pol) |\n\t       CSI_CFG_PCLK_POL(pclk_pol),\n\t       csi->regs + CSI_CFG_REG);\n\n\t \n\twritel(csi->fmt.plane_fmt[0].bytesperline,\n\t       csi->regs + CSI_BUF_LEN_REG);\n\n\t \n\tret = sun4i_csi_buffer_fill_all(csi);\n\tif (ret) {\n\t\tspin_unlock_irqrestore(&csi->qlock, flags);\n\t\tgoto err_disable_pipeline;\n\t}\n\n\t \n\twritel(CSI_BUF_CTRL_DBE, csi->regs + CSI_BUF_CTRL_REG);\n\n\t \n\twritel(CSI_INT_FRM_DONE, csi->regs + CSI_INT_STA_REG);\n\n\t \n\twritel(CSI_INT_FRM_DONE, csi->regs + CSI_INT_EN_REG);\n\n\tsun4i_csi_capture_start(csi);\n\n\tspin_unlock_irqrestore(&csi->qlock, flags);\n\n\tret = v4l2_subdev_call(csi->src_subdev, video, s_stream, 1);\n\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\tgoto err_disable_device;\n\n\treturn 0;\n\nerr_disable_device:\n\tsun4i_csi_capture_stop(csi);\n\nerr_disable_pipeline:\n\tvideo_device_pipeline_stop(&csi->vdev);\n\nerr_free_scratch_buffer:\n\tdma_free_coherent(csi->dev, csi->scratch.size, csi->scratch.vaddr,\n\t\t\t  csi->scratch.paddr);\n\nerr_clear_dma_queue:\n\tspin_lock_irqsave(&csi->qlock, flags);\n\treturn_all_buffers(csi, VB2_BUF_STATE_QUEUED);\n\tspin_unlock_irqrestore(&csi->qlock, flags);\n\n\treturn ret;\n}\n\nstatic void sun4i_csi_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct sun4i_csi *csi = vb2_get_drv_priv(vq);\n\tunsigned long flags;\n\n\tdev_dbg(csi->dev, \"Stopping capture\\n\");\n\n\tv4l2_subdev_call(csi->src_subdev, video, s_stream, 0);\n\tsun4i_csi_capture_stop(csi);\n\n\t \n\tspin_lock_irqsave(&csi->qlock, flags);\n\treturn_all_buffers(csi, VB2_BUF_STATE_ERROR);\n\tspin_unlock_irqrestore(&csi->qlock, flags);\n\n\tvideo_device_pipeline_stop(&csi->vdev);\n\n\tdma_free_coherent(csi->dev, csi->scratch.size, csi->scratch.vaddr,\n\t\t\t  csi->scratch.paddr);\n}\n\nstatic const struct vb2_ops sun4i_csi_qops = {\n\t.queue_setup\t\t= sun4i_csi_queue_setup,\n\t.buf_prepare\t\t= sun4i_csi_buffer_prepare,\n\t.buf_queue\t\t= sun4i_csi_buffer_queue,\n\t.start_streaming\t= sun4i_csi_start_streaming,\n\t.stop_streaming\t\t= sun4i_csi_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic irqreturn_t sun4i_csi_irq(int irq, void *data)\n{\n\tstruct sun4i_csi *csi = data;\n\tu32 reg;\n\n\treg = readl(csi->regs + CSI_INT_STA_REG);\n\n\t \n\twritel(reg, csi->regs + CSI_INT_STA_REG);\n\n\tif (!(reg & CSI_INT_FRM_DONE))\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock(&csi->qlock);\n\tif (sun4i_csi_buffer_flip(csi, csi->sequence++)) {\n\t\tdev_warn(csi->dev, \"%s: Flip failed\\n\", __func__);\n\t\tsun4i_csi_capture_stop(csi);\n\t}\n\tspin_unlock(&csi->qlock);\n\n\treturn IRQ_HANDLED;\n}\n\nint sun4i_csi_dma_register(struct sun4i_csi *csi, int irq)\n{\n\tstruct vb2_queue *q = &csi->queue;\n\tint ret;\n\tint i;\n\n\tspin_lock_init(&csi->qlock);\n\tmutex_init(&csi->lock);\n\n\tINIT_LIST_HEAD(&csi->buf_list);\n\tfor (i = 0; i < CSI_MAX_BUFFER; i++)\n\t\tcsi->current_buf[i] = NULL;\n\n\tq->min_buffers_needed = 3;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tq->lock = &csi->lock;\n\tq->drv_priv = csi;\n\tq->buf_struct_size = sizeof(struct sun4i_csi_buffer);\n\tq->ops = &sun4i_csi_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->dev = csi->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret < 0) {\n\t\tdev_err(csi->dev, \"failed to initialize VB2 queue\\n\");\n\t\tgoto err_free_mutex;\n\t}\n\n\tret = v4l2_device_register(csi->dev, &csi->v4l);\n\tif (ret) {\n\t\tdev_err(csi->dev, \"Couldn't register the v4l2 device\\n\");\n\t\tgoto err_free_mutex;\n\t}\n\n\tret = devm_request_irq(csi->dev, irq, sun4i_csi_irq, 0,\n\t\t\t       dev_name(csi->dev), csi);\n\tif (ret) {\n\t\tdev_err(csi->dev, \"Couldn't register our interrupt\\n\");\n\t\tgoto err_unregister_device;\n\t}\n\n\treturn 0;\n\nerr_unregister_device:\n\tv4l2_device_unregister(&csi->v4l);\n\nerr_free_mutex:\n\tmutex_destroy(&csi->lock);\n\treturn ret;\n}\n\nvoid sun4i_csi_dma_unregister(struct sun4i_csi *csi)\n{\n\tv4l2_device_unregister(&csi->v4l);\n\tmutex_destroy(&csi->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}