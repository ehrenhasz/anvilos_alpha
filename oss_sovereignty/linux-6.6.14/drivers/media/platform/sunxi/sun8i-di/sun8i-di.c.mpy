{
  "module_name": "sun8i-di.c",
  "hash_id": "ba98670bc7a9197c8a0758ed2107b3a4e0d8684014745567c57279ed4fc474fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/sunxi/sun8i-di/sun8i-di.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n\n#include \"sun8i-di.h\"\n\n#define FLAG_SIZE (DEINTERLACE_MAX_WIDTH * DEINTERLACE_MAX_HEIGHT / 4)\n\nstatic u32 deinterlace_formats[] = {\n\tV4L2_PIX_FMT_NV12,\n\tV4L2_PIX_FMT_NV21,\n};\n\nstatic inline u32 deinterlace_read(struct deinterlace_dev *dev, u32 reg)\n{\n\treturn readl(dev->base + reg);\n}\n\nstatic inline void deinterlace_write(struct deinterlace_dev *dev,\n\t\t\t\t     u32 reg, u32 value)\n{\n\twritel(value, dev->base + reg);\n}\n\nstatic inline void deinterlace_set_bits(struct deinterlace_dev *dev,\n\t\t\t\t\tu32 reg, u32 bits)\n{\n\twritel(readl(dev->base + reg) | bits, dev->base + reg);\n}\n\nstatic inline void deinterlace_clr_set_bits(struct deinterlace_dev *dev,\n\t\t\t\t\t    u32 reg, u32 clr, u32 set)\n{\n\tu32 val = readl(dev->base + reg);\n\n\tval &= ~clr;\n\tval |= set;\n\n\twritel(val, dev->base + reg);\n}\n\nstatic void deinterlace_device_run(void *priv)\n{\n\tstruct deinterlace_ctx *ctx = priv;\n\tstruct deinterlace_dev *dev = ctx->dev;\n\tu32 size, stride, width, height, val;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\tunsigned int hstep, vstep;\n\tdma_addr_t addr;\n\n\tsrc = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\tv4l2_m2m_buf_copy_metadata(src, dst, true);\n\n\tdeinterlace_write(dev, DEINTERLACE_MOD_ENABLE,\n\t\t\t  DEINTERLACE_MOD_ENABLE_EN);\n\n\tif (ctx->field) {\n\t\tdeinterlace_write(dev, DEINTERLACE_TILE_FLAG0,\n\t\t\t\t  ctx->flag1_buf_dma);\n\t\tdeinterlace_write(dev, DEINTERLACE_TILE_FLAG1,\n\t\t\t\t  ctx->flag2_buf_dma);\n\t} else {\n\t\tdeinterlace_write(dev, DEINTERLACE_TILE_FLAG0,\n\t\t\t\t  ctx->flag2_buf_dma);\n\t\tdeinterlace_write(dev, DEINTERLACE_TILE_FLAG1,\n\t\t\t\t  ctx->flag1_buf_dma);\n\t}\n\tdeinterlace_write(dev, DEINTERLACE_FLAG_LINE_STRIDE, 0x200);\n\n\twidth = ctx->src_fmt.width;\n\theight = ctx->src_fmt.height;\n\tstride = ctx->src_fmt.bytesperline;\n\tsize = stride * height;\n\n\taddr = vb2_dma_contig_plane_dma_addr(&src->vb2_buf, 0);\n\tdeinterlace_write(dev, DEINTERLACE_BUF_ADDR0, addr);\n\tdeinterlace_write(dev, DEINTERLACE_BUF_ADDR1, addr + size);\n\tdeinterlace_write(dev, DEINTERLACE_BUF_ADDR2, 0);\n\n\tdeinterlace_write(dev, DEINTERLACE_LINE_STRIDE0, stride);\n\tdeinterlace_write(dev, DEINTERLACE_LINE_STRIDE1, stride);\n\n\tdeinterlace_write(dev, DEINTERLACE_CH0_IN_SIZE,\n\t\t\t  DEINTERLACE_SIZE(width, height));\n\tdeinterlace_write(dev, DEINTERLACE_CH1_IN_SIZE,\n\t\t\t  DEINTERLACE_SIZE(width / 2, height / 2));\n\n\tval = DEINTERLACE_IN_FMT_FMT(DEINTERLACE_IN_FMT_YUV420) |\n\t      DEINTERLACE_IN_FMT_MOD(DEINTERLACE_MODE_UV_COMBINED);\n\tswitch (ctx->src_fmt.pixelformat) {\n\tcase V4L2_PIX_FMT_NV12:\n\t\tval |= DEINTERLACE_IN_FMT_PS(DEINTERLACE_PS_UVUV);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV21:\n\t\tval |= DEINTERLACE_IN_FMT_PS(DEINTERLACE_PS_VUVU);\n\t\tbreak;\n\t}\n\tdeinterlace_write(dev, DEINTERLACE_IN_FMT, val);\n\n\tif (ctx->prev)\n\t\taddr = vb2_dma_contig_plane_dma_addr(&ctx->prev->vb2_buf, 0);\n\n\tdeinterlace_write(dev, DEINTERLACE_PRELUMA, addr);\n\tdeinterlace_write(dev, DEINTERLACE_PRECHROMA, addr + size);\n\n\tval = DEINTERLACE_OUT_FMT_FMT(DEINTERLACE_OUT_FMT_YUV420SP);\n\tswitch (ctx->src_fmt.pixelformat) {\n\tcase V4L2_PIX_FMT_NV12:\n\t\tval |= DEINTERLACE_OUT_FMT_PS(DEINTERLACE_PS_UVUV);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV21:\n\t\tval |= DEINTERLACE_OUT_FMT_PS(DEINTERLACE_PS_VUVU);\n\t\tbreak;\n\t}\n\tdeinterlace_write(dev, DEINTERLACE_OUT_FMT, val);\n\n\twidth = ctx->dst_fmt.width;\n\theight = ctx->dst_fmt.height;\n\tstride = ctx->dst_fmt.bytesperline;\n\tsize = stride * height;\n\n\tdeinterlace_write(dev, DEINTERLACE_CH0_OUT_SIZE,\n\t\t\t  DEINTERLACE_SIZE(width, height));\n\tdeinterlace_write(dev, DEINTERLACE_CH1_OUT_SIZE,\n\t\t\t  DEINTERLACE_SIZE(width / 2, height / 2));\n\n\tdeinterlace_write(dev, DEINTERLACE_WB_LINE_STRIDE0, stride);\n\tdeinterlace_write(dev, DEINTERLACE_WB_LINE_STRIDE1, stride);\n\n\taddr = vb2_dma_contig_plane_dma_addr(&dst->vb2_buf, 0);\n\tdeinterlace_write(dev, DEINTERLACE_WB_ADDR0, addr);\n\tdeinterlace_write(dev, DEINTERLACE_WB_ADDR1, addr + size);\n\tdeinterlace_write(dev, DEINTERLACE_WB_ADDR2, 0);\n\n\thstep = (ctx->src_fmt.width << 16) / ctx->dst_fmt.width;\n\tvstep = (ctx->src_fmt.height << 16) / ctx->dst_fmt.height;\n\tdeinterlace_write(dev, DEINTERLACE_CH0_HORZ_FACT, hstep);\n\tdeinterlace_write(dev, DEINTERLACE_CH0_VERT_FACT, vstep);\n\tdeinterlace_write(dev, DEINTERLACE_CH1_HORZ_FACT, hstep);\n\tdeinterlace_write(dev, DEINTERLACE_CH1_VERT_FACT, vstep);\n\n\tdeinterlace_clr_set_bits(dev, DEINTERLACE_FIELD_CTRL,\n\t\t\t\t DEINTERLACE_FIELD_CTRL_FIELD_CNT_MSK,\n\t\t\t\t DEINTERLACE_FIELD_CTRL_FIELD_CNT(ctx->field));\n\n\tdeinterlace_set_bits(dev, DEINTERLACE_FRM_CTRL,\n\t\t\t     DEINTERLACE_FRM_CTRL_START);\n\n\tdeinterlace_set_bits(dev, DEINTERLACE_FRM_CTRL,\n\t\t\t     DEINTERLACE_FRM_CTRL_REG_READY);\n\n\tdeinterlace_set_bits(dev, DEINTERLACE_INT_ENABLE,\n\t\t\t     DEINTERLACE_INT_ENABLE_WB_EN);\n\n\tdeinterlace_set_bits(dev, DEINTERLACE_FRM_CTRL,\n\t\t\t     DEINTERLACE_FRM_CTRL_WB_EN);\n}\n\nstatic int deinterlace_job_ready(void *priv)\n{\n\tstruct deinterlace_ctx *ctx = priv;\n\n\treturn v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) >= 1 &&\n\t       v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) >= 2;\n}\n\nstatic void deinterlace_job_abort(void *priv)\n{\n\tstruct deinterlace_ctx *ctx = priv;\n\n\t \n\tctx->aborting = 1;\n}\n\nstatic irqreturn_t deinterlace_irq(int irq, void *data)\n{\n\tstruct deinterlace_dev *dev = data;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\tenum vb2_buffer_state state;\n\tstruct deinterlace_ctx *ctx;\n\tunsigned int val;\n\n\tctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);\n\tif (!ctx) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Instance released before the end of transaction\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tval = deinterlace_read(dev, DEINTERLACE_INT_STATUS);\n\tif (!(val & DEINTERLACE_INT_STATUS_WRITEBACK))\n\t\treturn IRQ_NONE;\n\n\tdeinterlace_write(dev, DEINTERLACE_INT_ENABLE, 0);\n\tdeinterlace_set_bits(dev, DEINTERLACE_INT_STATUS,\n\t\t\t     DEINTERLACE_INT_STATUS_WRITEBACK);\n\tdeinterlace_write(dev, DEINTERLACE_MOD_ENABLE, 0);\n\tdeinterlace_clr_set_bits(dev, DEINTERLACE_FRM_CTRL,\n\t\t\t\t DEINTERLACE_FRM_CTRL_START, 0);\n\n\tval = deinterlace_read(dev, DEINTERLACE_STATUS);\n\tif (val & DEINTERLACE_STATUS_WB_ERROR)\n\t\tstate = VB2_BUF_STATE_ERROR;\n\telse\n\t\tstate = VB2_BUF_STATE_DONE;\n\n\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_buf_done(dst, state);\n\n\tif (ctx->field != ctx->first_field || ctx->aborting) {\n\t\tctx->field = ctx->first_field;\n\n\t\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (ctx->prev)\n\t\t\tv4l2_m2m_buf_done(ctx->prev, state);\n\t\tctx->prev = src;\n\n\t\tv4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);\n\t} else {\n\t\tctx->field = !ctx->first_field;\n\t\tdeinterlace_device_run(ctx);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void deinterlace_init(struct deinterlace_dev *dev)\n{\n\tu32 val;\n\tint i;\n\n\tdeinterlace_write(dev, DEINTERLACE_BYPASS,\n\t\t\t  DEINTERLACE_BYPASS_CSC);\n\tdeinterlace_write(dev, DEINTERLACE_WB_LINE_STRIDE_CTRL,\n\t\t\t  DEINTERLACE_WB_LINE_STRIDE_CTRL_EN);\n\tdeinterlace_set_bits(dev, DEINTERLACE_FRM_CTRL,\n\t\t\t     DEINTERLACE_FRM_CTRL_OUT_CTRL);\n\tdeinterlace_write(dev, DEINTERLACE_AGTH_SEL,\n\t\t\t  DEINTERLACE_AGTH_SEL_LINEBUF);\n\n\tval = DEINTERLACE_CTRL_EN |\n\t      DEINTERLACE_CTRL_MODE_MIXED |\n\t      DEINTERLACE_CTRL_DIAG_INTP_EN |\n\t      DEINTERLACE_CTRL_TEMP_DIFF_EN;\n\tdeinterlace_write(dev, DEINTERLACE_CTRL, val);\n\n\tdeinterlace_clr_set_bits(dev, DEINTERLACE_LUMA_TH,\n\t\t\t\t DEINTERLACE_LUMA_TH_MIN_LUMA_MSK,\n\t\t\t\t DEINTERLACE_LUMA_TH_MIN_LUMA(4));\n\n\tdeinterlace_clr_set_bits(dev, DEINTERLACE_SPAT_COMP,\n\t\t\t\t DEINTERLACE_SPAT_COMP_TH2_MSK,\n\t\t\t\t DEINTERLACE_SPAT_COMP_TH2(5));\n\n\tdeinterlace_clr_set_bits(dev, DEINTERLACE_TEMP_DIFF,\n\t\t\t\t DEINTERLACE_TEMP_DIFF_AMBIGUITY_TH_MSK,\n\t\t\t\t DEINTERLACE_TEMP_DIFF_AMBIGUITY_TH(5));\n\n\tval = DEINTERLACE_DIAG_INTP_TH0(60) |\n\t      DEINTERLACE_DIAG_INTP_TH1(0) |\n\t      DEINTERLACE_DIAG_INTP_TH3(30);\n\tdeinterlace_write(dev, DEINTERLACE_DIAG_INTP, val);\n\n\tdeinterlace_clr_set_bits(dev, DEINTERLACE_CHROMA_DIFF,\n\t\t\t\t DEINTERLACE_CHROMA_DIFF_TH_MSK,\n\t\t\t\t DEINTERLACE_CHROMA_DIFF_TH(5));\n\n\t \n\tdeinterlace_set_bits(dev, DEINTERLACE_FRM_CTRL,\n\t\t\t     DEINTERLACE_FRM_CTRL_COEF_ACCESS);\n\treadl_poll_timeout(dev->base + DEINTERLACE_STATUS, val,\n\t\t\t   val & DEINTERLACE_STATUS_COEF_STATUS, 2, 40);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tdeinterlace_write(dev, DEINTERLACE_CH0_HORZ_COEF0 + i * 4,\n\t\t\t\t  DEINTERLACE_IDENTITY_COEF);\n\t\tdeinterlace_write(dev, DEINTERLACE_CH0_VERT_COEF + i * 4,\n\t\t\t\t  DEINTERLACE_IDENTITY_COEF);\n\t\tdeinterlace_write(dev, DEINTERLACE_CH1_HORZ_COEF0 + i * 4,\n\t\t\t\t  DEINTERLACE_IDENTITY_COEF);\n\t\tdeinterlace_write(dev, DEINTERLACE_CH1_VERT_COEF + i * 4,\n\t\t\t\t  DEINTERLACE_IDENTITY_COEF);\n\t}\n\n\tdeinterlace_clr_set_bits(dev, DEINTERLACE_FRM_CTRL,\n\t\t\t\t DEINTERLACE_FRM_CTRL_COEF_ACCESS, 0);\n}\n\nstatic inline struct deinterlace_ctx *deinterlace_file2ctx(struct file *file)\n{\n\treturn container_of(file->private_data, struct deinterlace_ctx, fh);\n}\n\nstatic bool deinterlace_check_format(u32 pixelformat)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(deinterlace_formats); i++)\n\t\tif (deinterlace_formats[i] == pixelformat)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void deinterlace_prepare_format(struct v4l2_pix_format *pix_fmt)\n{\n\tunsigned int height = pix_fmt->height;\n\tunsigned int width = pix_fmt->width;\n\tunsigned int bytesperline;\n\tunsigned int sizeimage;\n\n\twidth = clamp(width, DEINTERLACE_MIN_WIDTH,\n\t\t      DEINTERLACE_MAX_WIDTH);\n\theight = clamp(height, DEINTERLACE_MIN_HEIGHT,\n\t\t       DEINTERLACE_MAX_HEIGHT);\n\n\tbytesperline = ALIGN(width, 2);\n\t \n\tsizeimage = bytesperline * height;\n\t \n\tsizeimage += bytesperline * height / 2;\n\n\tpix_fmt->width = width;\n\tpix_fmt->height = height;\n\tpix_fmt->bytesperline = bytesperline;\n\tpix_fmt->sizeimage = sizeimage;\n}\n\nstatic int deinterlace_querycap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, DEINTERLACE_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, DEINTERLACE_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:%s\", DEINTERLACE_NAME);\n\n\treturn 0;\n}\n\nstatic int deinterlace_enum_fmt(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index < ARRAY_SIZE(deinterlace_formats)) {\n\t\tf->pixelformat = deinterlace_formats[f->index];\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int deinterlace_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t       struct v4l2_frmsizeenum *fsize)\n{\n\tif (fsize->index != 0)\n\t\treturn -EINVAL;\n\n\tif (!deinterlace_check_format(fsize->pixel_format))\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise.min_width = DEINTERLACE_MIN_WIDTH;\n\tfsize->stepwise.min_height = DEINTERLACE_MIN_HEIGHT;\n\tfsize->stepwise.max_width = DEINTERLACE_MAX_WIDTH;\n\tfsize->stepwise.max_height = DEINTERLACE_MAX_HEIGHT;\n\tfsize->stepwise.step_width = 2;\n\tfsize->stepwise.step_height = 1;\n\n\treturn 0;\n}\n\nstatic int deinterlace_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_format *f)\n{\n\tstruct deinterlace_ctx *ctx = deinterlace_file2ctx(file);\n\n\tf->fmt.pix = ctx->dst_fmt;\n\n\treturn 0;\n}\n\nstatic int deinterlace_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_format *f)\n{\n\tstruct deinterlace_ctx *ctx = deinterlace_file2ctx(file);\n\n\tf->fmt.pix = ctx->src_fmt;\n\n\treturn 0;\n}\n\nstatic int deinterlace_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t       struct v4l2_format *f)\n{\n\tif (!deinterlace_check_format(f->fmt.pix.pixelformat))\n\t\tf->fmt.pix.pixelformat = deinterlace_formats[0];\n\n\tif (f->fmt.pix.field != V4L2_FIELD_NONE)\n\t\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\n\tdeinterlace_prepare_format(&f->fmt.pix);\n\n\treturn 0;\n}\n\nstatic int deinterlace_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t       struct v4l2_format *f)\n{\n\tif (!deinterlace_check_format(f->fmt.pix.pixelformat))\n\t\tf->fmt.pix.pixelformat = deinterlace_formats[0];\n\n\tif (f->fmt.pix.field != V4L2_FIELD_INTERLACED_TB &&\n\t    f->fmt.pix.field != V4L2_FIELD_INTERLACED_BT &&\n\t    f->fmt.pix.field != V4L2_FIELD_INTERLACED)\n\t\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\n\tdeinterlace_prepare_format(&f->fmt.pix);\n\n\treturn 0;\n}\n\nstatic int deinterlace_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_format *f)\n{\n\tstruct deinterlace_ctx *ctx = deinterlace_file2ctx(file);\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tret = deinterlace_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\tctx->dst_fmt = f->fmt.pix;\n\n\treturn 0;\n}\n\nstatic int deinterlace_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_format *f)\n{\n\tstruct deinterlace_ctx *ctx = deinterlace_file2ctx(file);\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tret = deinterlace_try_fmt_vid_out(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\tctx->src_fmt = f->fmt.pix;\n\n\t \n\tctx->dst_fmt.colorspace = f->fmt.pix.colorspace;\n\tctx->dst_fmt.xfer_func = f->fmt.pix.xfer_func;\n\tctx->dst_fmt.ycbcr_enc = f->fmt.pix.ycbcr_enc;\n\tctx->dst_fmt.quantization = f->fmt.pix.quantization;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops deinterlace_ioctl_ops = {\n\t.vidioc_querycap\t\t= deinterlace_querycap,\n\n\t.vidioc_enum_framesizes\t\t= deinterlace_enum_framesizes,\n\n\t.vidioc_enum_fmt_vid_cap\t= deinterlace_enum_fmt,\n\t.vidioc_g_fmt_vid_cap\t\t= deinterlace_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= deinterlace_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= deinterlace_s_fmt_vid_cap,\n\n\t.vidioc_enum_fmt_vid_out\t= deinterlace_enum_fmt,\n\t.vidioc_g_fmt_vid_out\t\t= deinterlace_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t\t= deinterlace_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t\t= deinterlace_s_fmt_vid_out,\n\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n};\n\nstatic int deinterlace_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\n\t\t\t\t   unsigned int *nplanes, unsigned int sizes[],\n\t\t\t\t   struct device *alloc_devs[])\n{\n\tstruct deinterlace_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format *pix_fmt;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\tpix_fmt = &ctx->src_fmt;\n\telse\n\t\tpix_fmt = &ctx->dst_fmt;\n\n\tif (*nplanes) {\n\t\tif (sizes[0] < pix_fmt->sizeimage)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tsizes[0] = pix_fmt->sizeimage;\n\t\t*nplanes = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int deinterlace_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct deinterlace_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format *pix_fmt;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\tpix_fmt = &ctx->src_fmt;\n\telse\n\t\tpix_fmt = &ctx->dst_fmt;\n\n\tif (vb2_plane_size(vb, 0) < pix_fmt->sizeimage)\n\t\treturn -EINVAL;\n\n\tvb2_set_plane_payload(vb, 0, pix_fmt->sizeimage);\n\n\treturn 0;\n}\n\nstatic void deinterlace_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct deinterlace_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic void deinterlace_queue_cleanup(struct vb2_queue *vq, u32 state)\n{\n\tstruct deinterlace_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tdo {\n\t\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tif (vbuf)\n\t\t\tv4l2_m2m_buf_done(vbuf, state);\n\t} while (vbuf);\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type) && ctx->prev)\n\t\tv4l2_m2m_buf_done(ctx->prev, state);\n}\n\nstatic int deinterlace_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct deinterlace_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct device *dev = ctx->dev->dev;\n\tint ret;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to enable module\\n\");\n\n\t\t\tgoto err_runtime_get;\n\t\t}\n\n\t\tctx->first_field =\n\t\t\tctx->src_fmt.field == V4L2_FIELD_INTERLACED_BT;\n\t\tctx->field = ctx->first_field;\n\n\t\tctx->prev = NULL;\n\t\tctx->aborting = 0;\n\n\t\tctx->flag1_buf = dma_alloc_coherent(dev, FLAG_SIZE,\n\t\t\t\t\t\t    &ctx->flag1_buf_dma,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!ctx->flag1_buf) {\n\t\t\tret = -ENOMEM;\n\n\t\t\tgoto err_no_mem1;\n\t\t}\n\n\t\tctx->flag2_buf = dma_alloc_coherent(dev, FLAG_SIZE,\n\t\t\t\t\t\t    &ctx->flag2_buf_dma,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!ctx->flag2_buf) {\n\t\t\tret = -ENOMEM;\n\n\t\t\tgoto err_no_mem2;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_no_mem2:\n\tdma_free_coherent(dev, FLAG_SIZE, ctx->flag1_buf,\n\t\t\t  ctx->flag1_buf_dma);\nerr_no_mem1:\n\tpm_runtime_put(dev);\nerr_runtime_get:\n\tdeinterlace_queue_cleanup(vq, VB2_BUF_STATE_QUEUED);\n\n\treturn ret;\n}\n\nstatic void deinterlace_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct deinterlace_ctx *ctx = vb2_get_drv_priv(vq);\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\tstruct device *dev = ctx->dev->dev;\n\n\t\tdma_free_coherent(dev, FLAG_SIZE, ctx->flag1_buf,\n\t\t\t\t  ctx->flag1_buf_dma);\n\t\tdma_free_coherent(dev, FLAG_SIZE, ctx->flag2_buf,\n\t\t\t\t  ctx->flag2_buf_dma);\n\n\t\tpm_runtime_put(dev);\n\t}\n\n\tdeinterlace_queue_cleanup(vq, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct vb2_ops deinterlace_qops = {\n\t.queue_setup\t\t= deinterlace_queue_setup,\n\t.buf_prepare\t\t= deinterlace_buf_prepare,\n\t.buf_queue\t\t= deinterlace_buf_queue,\n\t.start_streaming\t= deinterlace_start_streaming,\n\t.stop_streaming\t\t= deinterlace_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic int deinterlace_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t\t  struct vb2_queue *dst_vq)\n{\n\tstruct deinterlace_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->min_buffers_needed = 1;\n\tsrc_vq->ops = &deinterlace_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->dev->dev_mutex;\n\tsrc_vq->dev = ctx->dev->dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->min_buffers_needed = 2;\n\tdst_vq->ops = &deinterlace_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->dev->dev_mutex;\n\tdst_vq->dev = ctx->dev->dev;\n\n\tret = vb2_queue_init(dst_vq);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int deinterlace_open(struct file *file)\n{\n\tstruct deinterlace_dev *dev = video_drvdata(file);\n\tstruct deinterlace_ctx *ctx = NULL;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&dev->dev_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tmutex_unlock(&dev->dev_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tctx->src_fmt.pixelformat = deinterlace_formats[0];\n\tctx->src_fmt.field = V4L2_FIELD_INTERLACED;\n\tctx->src_fmt.width = 640;\n\tctx->src_fmt.height = 480;\n\tdeinterlace_prepare_format(&ctx->src_fmt);\n\n\t \n\tctx->dst_fmt.pixelformat = deinterlace_formats[0];\n\tctx->dst_fmt.field = V4L2_FIELD_NONE;\n\tctx->dst_fmt.width = 640;\n\tctx->dst_fmt.height = 480;\n\tdeinterlace_prepare_format(&ctx->dst_fmt);\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tctx->dev = dev;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx,\n\t\t\t\t\t    &deinterlace_queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto err_free;\n\t}\n\n\tv4l2_fh_add(&ctx->fh);\n\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn 0;\n\nerr_free:\n\tkfree(ctx);\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn ret;\n}\n\nstatic int deinterlace_release(struct file *file)\n{\n\tstruct deinterlace_dev *dev = video_drvdata(file);\n\tstruct deinterlace_ctx *ctx = container_of(file->private_data,\n\t\t\t\t\t\t   struct deinterlace_ctx, fh);\n\n\tmutex_lock(&dev->dev_mutex);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\n\tkfree(ctx);\n\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations deinterlace_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= deinterlace_open,\n\t.release\t= deinterlace_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct video_device deinterlace_video_device = {\n\t.name\t\t= DEINTERLACE_NAME,\n\t.vfl_dir\t= VFL_DIR_M2M,\n\t.fops\t\t= &deinterlace_fops,\n\t.ioctl_ops\t= &deinterlace_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= video_device_release_empty,\n\t.device_caps\t= V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING,\n};\n\nstatic const struct v4l2_m2m_ops deinterlace_m2m_ops = {\n\t.device_run\t= deinterlace_device_run,\n\t.job_ready\t= deinterlace_job_ready,\n\t.job_abort\t= deinterlace_job_abort,\n};\n\nstatic int deinterlace_probe(struct platform_device *pdev)\n{\n\tstruct deinterlace_dev *dev;\n\tstruct video_device *vfd;\n\tint irq, ret;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->vfd = deinterlace_video_device;\n\tdev->dev = &pdev->dev;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq <= 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev->dev, irq, deinterlace_irq,\n\t\t\t       0, dev_name(dev->dev), dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to request IRQ\\n\");\n\n\t\treturn ret;\n\t}\n\n\tdev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->base))\n\t\treturn PTR_ERR(dev->base);\n\n\tdev->bus_clk = devm_clk_get(dev->dev, \"bus\");\n\tif (IS_ERR(dev->bus_clk)) {\n\t\tdev_err(dev->dev, \"Failed to get bus clock\\n\");\n\n\t\treturn PTR_ERR(dev->bus_clk);\n\t}\n\n\tdev->mod_clk = devm_clk_get(dev->dev, \"mod\");\n\tif (IS_ERR(dev->mod_clk)) {\n\t\tdev_err(dev->dev, \"Failed to get mod clock\\n\");\n\n\t\treturn PTR_ERR(dev->mod_clk);\n\t}\n\n\tdev->ram_clk = devm_clk_get(dev->dev, \"ram\");\n\tif (IS_ERR(dev->ram_clk)) {\n\t\tdev_err(dev->dev, \"Failed to get ram clock\\n\");\n\n\t\treturn PTR_ERR(dev->ram_clk);\n\t}\n\n\tdev->rstc = devm_reset_control_get(dev->dev, NULL);\n\tif (IS_ERR(dev->rstc)) {\n\t\tdev_err(dev->dev, \"Failed to get reset control\\n\");\n\n\t\treturn PTR_ERR(dev->rstc);\n\t}\n\n\tmutex_init(&dev->dev_mutex);\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to register V4L2 device\\n\");\n\n\t\treturn ret;\n\t}\n\n\tvfd = &dev->vfd;\n\tvfd->lock = &dev->dev_mutex;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s\",\n\t\t deinterlace_video_device.name);\n\tvideo_set_drvdata(vfd, dev);\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register video device\\n\");\n\n\t\tgoto err_v4l2;\n\t}\n\n\tv4l2_info(&dev->v4l2_dev,\n\t\t  \"Device registered as /dev/video%d\\n\", vfd->num);\n\n\tdev->m2m_dev = v4l2_m2m_init(&deinterlace_m2m_ops);\n\tif (IS_ERR(dev->m2m_dev)) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Failed to initialize V4L2 M2M device\\n\");\n\t\tret = PTR_ERR(dev->m2m_dev);\n\n\t\tgoto err_video;\n\t}\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tpm_runtime_enable(dev->dev);\n\n\treturn 0;\n\nerr_video:\n\tvideo_unregister_device(&dev->vfd);\nerr_v4l2:\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\n\treturn ret;\n}\n\nstatic void deinterlace_remove(struct platform_device *pdev)\n{\n\tstruct deinterlace_dev *dev = platform_get_drvdata(pdev);\n\n\tv4l2_m2m_release(dev->m2m_dev);\n\tvideo_unregister_device(&dev->vfd);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\n\tpm_runtime_force_suspend(&pdev->dev);\n}\n\nstatic int deinterlace_runtime_resume(struct device *device)\n{\n\tstruct deinterlace_dev *dev = dev_get_drvdata(device);\n\tint ret;\n\n\tret = clk_set_rate_exclusive(dev->mod_clk, 300000000);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to set exclusive mod clock rate\\n\");\n\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(dev->bus_clk);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to enable bus clock\\n\");\n\n\t\tgoto err_exclusive_rate;\n\t}\n\n\tret = clk_prepare_enable(dev->mod_clk);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to enable mod clock\\n\");\n\n\t\tgoto err_bus_clk;\n\t}\n\n\tret = clk_prepare_enable(dev->ram_clk);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to enable ram clock\\n\");\n\n\t\tgoto err_mod_clk;\n\t}\n\n\tret = reset_control_deassert(dev->rstc);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to apply reset\\n\");\n\n\t\tgoto err_ram_clk;\n\t}\n\n\tdeinterlace_init(dev);\n\n\treturn 0;\n\nerr_ram_clk:\n\tclk_disable_unprepare(dev->ram_clk);\nerr_mod_clk:\n\tclk_disable_unprepare(dev->mod_clk);\nerr_bus_clk:\n\tclk_disable_unprepare(dev->bus_clk);\nerr_exclusive_rate:\n\tclk_rate_exclusive_put(dev->mod_clk);\n\n\treturn ret;\n}\n\nstatic int deinterlace_runtime_suspend(struct device *device)\n{\n\tstruct deinterlace_dev *dev = dev_get_drvdata(device);\n\n\treset_control_assert(dev->rstc);\n\n\tclk_disable_unprepare(dev->ram_clk);\n\tclk_disable_unprepare(dev->mod_clk);\n\tclk_disable_unprepare(dev->bus_clk);\n\tclk_rate_exclusive_put(dev->mod_clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id deinterlace_dt_match[] = {\n\t{ .compatible = \"allwinner,sun8i-h3-deinterlace\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, deinterlace_dt_match);\n\nstatic const struct dev_pm_ops deinterlace_pm_ops = {\n\t.runtime_resume\t\t= deinterlace_runtime_resume,\n\t.runtime_suspend\t= deinterlace_runtime_suspend,\n};\n\nstatic struct platform_driver deinterlace_driver = {\n\t.probe\t\t= deinterlace_probe,\n\t.remove_new\t= deinterlace_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= DEINTERLACE_NAME,\n\t\t.of_match_table\t= deinterlace_dt_match,\n\t\t.pm\t\t= &deinterlace_pm_ops,\n\t},\n};\nmodule_platform_driver(deinterlace_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jernej Skrabec <jernej.skrabec@siol.net>\");\nMODULE_DESCRIPTION(\"Allwinner Deinterlace driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}