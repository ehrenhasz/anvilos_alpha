{
  "module_name": "sun8i_rotate.c",
  "hash_id": "c85eef9f837361c9840c4295685d7417ce069ae8a14ee5b29e9ad134df35f113",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/sunxi/sun8i-rotate/sun8i_rotate.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n\n#include \"sun8i-formats.h\"\n#include \"sun8i-rotate.h\"\n\nstatic inline u32 rotate_read(struct rotate_dev *dev, u32 reg)\n{\n\treturn readl(dev->base + reg);\n}\n\nstatic inline void rotate_write(struct rotate_dev *dev, u32 reg, u32 value)\n{\n\twritel(value, dev->base + reg);\n}\n\nstatic inline void rotate_set_bits(struct rotate_dev *dev, u32 reg, u32 bits)\n{\n\twritel(readl(dev->base + reg) | bits, dev->base + reg);\n}\n\nstatic void rotate_calc_addr_pitch(dma_addr_t buffer,\n\t\t\t\t   u32 bytesperline, u32 height,\n\t\t\t\t   const struct rotate_format *fmt,\n\t\t\t\t   dma_addr_t *addr, u32 *pitch)\n{\n\tu32 size;\n\tint i;\n\n\tfor (i = 0; i < fmt->planes; i++) {\n\t\tpitch[i] = bytesperline;\n\t\taddr[i] = buffer;\n\t\tif (i > 0)\n\t\t\tpitch[i] /= fmt->hsub / fmt->bpp[i];\n\t\tsize = pitch[i] * height;\n\t\tif (i > 0)\n\t\t\tsize /= fmt->vsub;\n\t\tbuffer += size;\n\t}\n}\n\nstatic void rotate_device_run(void *priv)\n{\n\tstruct rotate_ctx *ctx = priv;\n\tstruct rotate_dev *dev = ctx->dev;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\tconst struct rotate_format *fmt;\n\tdma_addr_t addr[3];\n\tu32 val, pitch[3];\n\n\tsrc = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\tv4l2_m2m_buf_copy_metadata(src, dst, true);\n\n\tval = ROTATE_GLB_CTL_MODE(ROTATE_MODE_COPY_ROTATE);\n\tif (ctx->hflip)\n\t\tval |= ROTATE_GLB_CTL_HFLIP;\n\tif (ctx->vflip)\n\t\tval |= ROTATE_GLB_CTL_VFLIP;\n\tval |= ROTATE_GLB_CTL_ROTATION(ctx->rotate / 90);\n\tif (ctx->rotate != 90 && ctx->rotate != 270)\n\t\tval |= ROTATE_GLB_CTL_BURST_LEN(ROTATE_BURST_64);\n\telse\n\t\tval |= ROTATE_GLB_CTL_BURST_LEN(ROTATE_BURST_8);\n\trotate_write(dev, ROTATE_GLB_CTL, val);\n\n\tfmt = rotate_find_format(ctx->src_fmt.pixelformat);\n\tif (!fmt)\n\t\treturn;\n\n\trotate_write(dev, ROTATE_IN_FMT, ROTATE_IN_FMT_FORMAT(fmt->hw_format));\n\n\trotate_calc_addr_pitch(vb2_dma_contig_plane_dma_addr(&src->vb2_buf, 0),\n\t\t\t       ctx->src_fmt.bytesperline, ctx->src_fmt.height,\n\t\t\t       fmt, addr, pitch);\n\n\trotate_write(dev, ROTATE_IN_SIZE,\n\t\t     ROTATE_SIZE(ctx->src_fmt.width, ctx->src_fmt.height));\n\n\trotate_write(dev, ROTATE_IN_PITCH0, pitch[0]);\n\trotate_write(dev, ROTATE_IN_PITCH1, pitch[1]);\n\trotate_write(dev, ROTATE_IN_PITCH2, pitch[2]);\n\n\trotate_write(dev, ROTATE_IN_ADDRL0, addr[0]);\n\trotate_write(dev, ROTATE_IN_ADDRL1, addr[1]);\n\trotate_write(dev, ROTATE_IN_ADDRL2, addr[2]);\n\n\trotate_write(dev, ROTATE_IN_ADDRH0, 0);\n\trotate_write(dev, ROTATE_IN_ADDRH1, 0);\n\trotate_write(dev, ROTATE_IN_ADDRH2, 0);\n\n\tfmt = rotate_find_format(ctx->dst_fmt.pixelformat);\n\tif (!fmt)\n\t\treturn;\n\n\trotate_calc_addr_pitch(vb2_dma_contig_plane_dma_addr(&dst->vb2_buf, 0),\n\t\t\t       ctx->dst_fmt.bytesperline, ctx->dst_fmt.height,\n\t\t\t       fmt, addr, pitch);\n\n\trotate_write(dev, ROTATE_OUT_SIZE,\n\t\t     ROTATE_SIZE(ctx->dst_fmt.width, ctx->dst_fmt.height));\n\n\trotate_write(dev, ROTATE_OUT_PITCH0, pitch[0]);\n\trotate_write(dev, ROTATE_OUT_PITCH1, pitch[1]);\n\trotate_write(dev, ROTATE_OUT_PITCH2, pitch[2]);\n\n\trotate_write(dev, ROTATE_OUT_ADDRL0, addr[0]);\n\trotate_write(dev, ROTATE_OUT_ADDRL1, addr[1]);\n\trotate_write(dev, ROTATE_OUT_ADDRL2, addr[2]);\n\n\trotate_write(dev, ROTATE_OUT_ADDRH0, 0);\n\trotate_write(dev, ROTATE_OUT_ADDRH1, 0);\n\trotate_write(dev, ROTATE_OUT_ADDRH2, 0);\n\n\trotate_set_bits(dev, ROTATE_INT, ROTATE_INT_FINISH_IRQ_EN);\n\trotate_set_bits(dev, ROTATE_GLB_CTL, ROTATE_GLB_CTL_START);\n}\n\nstatic irqreturn_t rotate_irq(int irq, void *data)\n{\n\tstruct vb2_v4l2_buffer *buffer;\n\tstruct rotate_dev *dev = data;\n\tstruct rotate_ctx *ctx;\n\tunsigned int val;\n\n\tctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);\n\tif (!ctx) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Instance released before the end of transaction\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tval = rotate_read(dev, ROTATE_INT);\n\tif (!(val & ROTATE_INT_FINISH_IRQ))\n\t\treturn IRQ_NONE;\n\n\t \n\trotate_write(dev, ROTATE_INT, ROTATE_INT_FINISH_IRQ);\n\n\tbuffer = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_buf_done(buffer, VB2_BUF_STATE_DONE);\n\n\tbuffer = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_buf_done(buffer, VB2_BUF_STATE_DONE);\n\n\tv4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline struct rotate_ctx *rotate_file2ctx(struct file *file)\n{\n\treturn container_of(file->private_data, struct rotate_ctx, fh);\n}\n\nstatic void rotate_prepare_format(struct v4l2_pix_format *pix_fmt)\n{\n\tunsigned int height, width, alignment, sizeimage, size, bpl;\n\tconst struct rotate_format *fmt;\n\tint i;\n\n\tfmt = rotate_find_format(pix_fmt->pixelformat);\n\tif (!fmt)\n\t\treturn;\n\n\twidth = ALIGN(pix_fmt->width, fmt->hsub);\n\theight = ALIGN(pix_fmt->height, fmt->vsub);\n\n\t \n\talignment = 16;\n\tif (fmt->planes > 1)\n\t\talignment *= fmt->hsub / fmt->bpp[1];\n\tbpl = ALIGN(width * fmt->bpp[0], alignment);\n\n\tsizeimage = 0;\n\tfor (i = 0; i < fmt->planes; i++) {\n\t\tsize = bpl * height;\n\t\tif (i > 0) {\n\t\t\tsize *= fmt->bpp[i];\n\t\t\tsize /= fmt->hsub;\n\t\t\tsize /= fmt->vsub;\n\t\t}\n\t\tsizeimage += size;\n\t}\n\n\tpix_fmt->width = width;\n\tpix_fmt->height = height;\n\tpix_fmt->bytesperline = bpl;\n\tpix_fmt->sizeimage = sizeimage;\n}\n\nstatic int rotate_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, ROTATE_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, ROTATE_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:%s\", ROTATE_NAME);\n\n\treturn 0;\n}\n\nstatic int rotate_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn rotate_enum_fmt(f, true);\n}\n\nstatic int rotate_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn rotate_enum_fmt(f, false);\n}\n\nstatic int rotate_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tconst struct rotate_format *fmt;\n\n\tif (fsize->index != 0)\n\t\treturn -EINVAL;\n\n\tfmt = rotate_find_format(fsize->pixel_format);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise.min_width = ROTATE_MIN_WIDTH;\n\tfsize->stepwise.min_height = ROTATE_MIN_HEIGHT;\n\tfsize->stepwise.max_width = ROTATE_MAX_WIDTH;\n\tfsize->stepwise.max_height = ROTATE_MAX_HEIGHT;\n\tfsize->stepwise.step_width = fmt->hsub;\n\tfsize->stepwise.step_height = fmt->vsub;\n\n\treturn 0;\n}\n\nstatic int rotate_set_cap_format(struct rotate_ctx *ctx,\n\t\t\t\t struct v4l2_pix_format *f,\n\t\t\t\t u32 rotate)\n{\n\tconst struct rotate_format *fmt;\n\n\tfmt = rotate_find_format(ctx->src_fmt.pixelformat);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tif (fmt->flags & ROTATE_FLAG_YUV)\n\t\tf->pixelformat = V4L2_PIX_FMT_YUV420;\n\telse\n\t\tf->pixelformat = ctx->src_fmt.pixelformat;\n\n\tf->field = V4L2_FIELD_NONE;\n\n\tif (rotate == 90 || rotate == 270) {\n\t\tf->width = ctx->src_fmt.height;\n\t\tf->height = ctx->src_fmt.width;\n\t} else {\n\t\tf->width = ctx->src_fmt.width;\n\t\tf->height = ctx->src_fmt.height;\n\t}\n\n\trotate_prepare_format(f);\n\n\treturn 0;\n}\n\nstatic int rotate_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct rotate_ctx *ctx = rotate_file2ctx(file);\n\n\tf->fmt.pix = ctx->dst_fmt;\n\n\treturn 0;\n}\n\nstatic int rotate_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct rotate_ctx *ctx = rotate_file2ctx(file);\n\n\tf->fmt.pix = ctx->src_fmt;\n\n\treturn 0;\n}\n\nstatic int rotate_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct rotate_ctx *ctx = rotate_file2ctx(file);\n\n\treturn rotate_set_cap_format(ctx, &f->fmt.pix, ctx->rotate);\n}\n\nstatic int rotate_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tif (!rotate_find_format(f->fmt.pix.pixelformat))\n\t\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_ARGB32;\n\n\tif (f->fmt.pix.width < ROTATE_MIN_WIDTH)\n\t\tf->fmt.pix.width = ROTATE_MIN_WIDTH;\n\tif (f->fmt.pix.height < ROTATE_MIN_HEIGHT)\n\t\tf->fmt.pix.height = ROTATE_MIN_HEIGHT;\n\n\tif (f->fmt.pix.width > ROTATE_MAX_WIDTH)\n\t\tf->fmt.pix.width = ROTATE_MAX_WIDTH;\n\tif (f->fmt.pix.height > ROTATE_MAX_HEIGHT)\n\t\tf->fmt.pix.height = ROTATE_MAX_HEIGHT;\n\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\n\trotate_prepare_format(&f->fmt.pix);\n\n\treturn 0;\n}\n\nstatic int rotate_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct rotate_ctx *ctx = rotate_file2ctx(file);\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tret = rotate_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\tctx->dst_fmt = f->fmt.pix;\n\n\treturn 0;\n}\n\nstatic int rotate_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct rotate_ctx *ctx = rotate_file2ctx(file);\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tret = rotate_try_fmt_vid_out(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\t \n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\tctx->src_fmt = f->fmt.pix;\n\n\t \n\tctx->dst_fmt.colorspace = f->fmt.pix.colorspace;\n\tctx->dst_fmt.xfer_func = f->fmt.pix.xfer_func;\n\tctx->dst_fmt.ycbcr_enc = f->fmt.pix.ycbcr_enc;\n\tctx->dst_fmt.quantization = f->fmt.pix.quantization;\n\n\treturn rotate_set_cap_format(ctx, &ctx->dst_fmt, ctx->rotate);\n}\n\nstatic const struct v4l2_ioctl_ops rotate_ioctl_ops = {\n\t.vidioc_querycap\t\t= rotate_querycap,\n\n\t.vidioc_enum_framesizes\t\t= rotate_enum_framesizes,\n\n\t.vidioc_enum_fmt_vid_cap\t= rotate_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= rotate_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= rotate_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= rotate_s_fmt_vid_cap,\n\n\t.vidioc_enum_fmt_vid_out\t= rotate_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out\t\t= rotate_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t\t= rotate_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t\t= rotate_s_fmt_vid_out,\n\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_log_status\t\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nstatic int rotate_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\n\t\t\t      unsigned int *nplanes, unsigned int sizes[],\n\t\t\t      struct device *alloc_devs[])\n{\n\tstruct rotate_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format *pix_fmt;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\tpix_fmt = &ctx->src_fmt;\n\telse\n\t\tpix_fmt = &ctx->dst_fmt;\n\n\tif (*nplanes) {\n\t\tif (sizes[0] < pix_fmt->sizeimage)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tsizes[0] = pix_fmt->sizeimage;\n\t\t*nplanes = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int rotate_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct rotate_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format *pix_fmt;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\tpix_fmt = &ctx->src_fmt;\n\telse\n\t\tpix_fmt = &ctx->dst_fmt;\n\n\tif (vb2_plane_size(vb, 0) < pix_fmt->sizeimage)\n\t\treturn -EINVAL;\n\n\tvb2_set_plane_payload(vb, 0, pix_fmt->sizeimage);\n\n\treturn 0;\n}\n\nstatic void rotate_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct rotate_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic void rotate_queue_cleanup(struct vb2_queue *vq, u32 state)\n{\n\tstruct rotate_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tdo {\n\t\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tif (vbuf)\n\t\t\tv4l2_m2m_buf_done(vbuf, state);\n\t} while (vbuf);\n}\n\nstatic int rotate_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\tstruct rotate_ctx *ctx = vb2_get_drv_priv(vq);\n\t\tstruct device *dev = ctx->dev->dev;\n\t\tint ret;\n\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to enable module\\n\");\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void rotate_stop_streaming(struct vb2_queue *vq)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\tstruct rotate_ctx *ctx = vb2_get_drv_priv(vq);\n\n\t\tpm_runtime_put(ctx->dev->dev);\n\t}\n\n\trotate_queue_cleanup(vq, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct vb2_ops rotate_qops = {\n\t.queue_setup\t\t= rotate_queue_setup,\n\t.buf_prepare\t\t= rotate_buf_prepare,\n\t.buf_queue\t\t= rotate_buf_queue,\n\t.start_streaming\t= rotate_start_streaming,\n\t.stop_streaming\t\t= rotate_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic int rotate_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t     struct vb2_queue *dst_vq)\n{\n\tstruct rotate_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->min_buffers_needed = 1;\n\tsrc_vq->ops = &rotate_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->dev->dev_mutex;\n\tsrc_vq->dev = ctx->dev->dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->min_buffers_needed = 2;\n\tdst_vq->ops = &rotate_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->dev->dev_mutex;\n\tdst_vq->dev = ctx->dev->dev;\n\n\tret = vb2_queue_init(dst_vq);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rotate_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct rotate_ctx *ctx = container_of(ctrl->handler,\n\t\t\t\t\t      struct rotate_ctx,\n\t\t\t\t\t      ctrl_handler);\n\tstruct v4l2_pix_format fmt;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tctx->hflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tctx->vflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_ROTATE:\n\t\trotate_set_cap_format(ctx, &fmt, ctrl->val);\n\n\t\t \n\t\tif (fmt.width != ctx->dst_fmt.width ||\n\t\t    fmt.height != ctx->dst_fmt.height ||\n\t\t    fmt.bytesperline != ctx->dst_fmt.bytesperline ||\n\t\t    fmt.sizeimage != ctx->dst_fmt.sizeimage) {\n\t\t\tstruct vb2_queue *vq;\n\n\t\t\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t     V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\t\tif (vb2_is_busy(vq))\n\t\t\t\treturn -EBUSY;\n\n\t\t\trotate_set_cap_format(ctx, &ctx->dst_fmt, ctrl->val);\n\t\t}\n\n\t\tctx->rotate = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops rotate_ctrl_ops = {\n\t.s_ctrl = rotate_s_ctrl,\n};\n\nstatic int rotate_setup_ctrls(struct rotate_ctx *ctx)\n{\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, 3);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &rotate_ctrl_ops,\n\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &rotate_ctrl_ops,\n\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &rotate_ctrl_ops,\n\t\t\t  V4L2_CID_ROTATE, 0, 270, 90, 0);\n\n\tif (ctx->ctrl_handler.error) {\n\t\tint err = ctx->ctrl_handler.error;\n\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"control setup failed!\\n\");\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\n\t\treturn err;\n\t}\n\n\treturn v4l2_ctrl_handler_setup(&ctx->ctrl_handler);\n}\n\nstatic int rotate_open(struct file *file)\n{\n\tstruct rotate_dev *dev = video_drvdata(file);\n\tstruct rotate_ctx *ctx = NULL;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&dev->dev_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tmutex_unlock(&dev->dev_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tctx->src_fmt.pixelformat = V4L2_PIX_FMT_ARGB32;\n\tctx->src_fmt.field = V4L2_FIELD_NONE;\n\tctx->src_fmt.width = 640;\n\tctx->src_fmt.height = 480;\n\trotate_prepare_format(&ctx->src_fmt);\n\n\t \n\trotate_set_cap_format(ctx, &ctx->dst_fmt, ctx->rotate);\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tctx->dev = dev;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx,\n\t\t\t\t\t    &rotate_queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto err_free;\n\t}\n\n\tv4l2_fh_add(&ctx->fh);\n\n\tret = rotate_setup_ctrls(ctx);\n\tif (ret)\n\t\tgoto err_free;\n\n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn 0;\n\nerr_free:\n\tkfree(ctx);\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn ret;\n}\n\nstatic int rotate_release(struct file *file)\n{\n\tstruct rotate_dev *dev = video_drvdata(file);\n\tstruct rotate_ctx *ctx = container_of(file->private_data,\n\t\t\t\t\t\t   struct rotate_ctx, fh);\n\n\tmutex_lock(&dev->dev_mutex);\n\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\n\tkfree(ctx);\n\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations rotate_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= rotate_open,\n\t.release\t= rotate_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct video_device rotate_video_device = {\n\t.name\t\t= ROTATE_NAME,\n\t.vfl_dir\t= VFL_DIR_M2M,\n\t.fops\t\t= &rotate_fops,\n\t.ioctl_ops\t= &rotate_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= video_device_release_empty,\n\t.device_caps\t= V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING,\n};\n\nstatic const struct v4l2_m2m_ops rotate_m2m_ops = {\n\t.device_run\t= rotate_device_run,\n};\n\nstatic int rotate_probe(struct platform_device *pdev)\n{\n\tstruct rotate_dev *dev;\n\tstruct video_device *vfd;\n\tint irq, ret;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->vfd = rotate_video_device;\n\tdev->dev = &pdev->dev;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq <= 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev->dev, irq, rotate_irq,\n\t\t\t       0, dev_name(dev->dev), dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to request IRQ\\n\");\n\n\t\treturn ret;\n\t}\n\n\tdev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->base))\n\t\treturn PTR_ERR(dev->base);\n\n\tdev->bus_clk = devm_clk_get(dev->dev, \"bus\");\n\tif (IS_ERR(dev->bus_clk)) {\n\t\tdev_err(dev->dev, \"Failed to get bus clock\\n\");\n\n\t\treturn PTR_ERR(dev->bus_clk);\n\t}\n\n\tdev->mod_clk = devm_clk_get(dev->dev, \"mod\");\n\tif (IS_ERR(dev->mod_clk)) {\n\t\tdev_err(dev->dev, \"Failed to get mod clock\\n\");\n\n\t\treturn PTR_ERR(dev->mod_clk);\n\t}\n\n\tdev->rstc = devm_reset_control_get(dev->dev, NULL);\n\tif (IS_ERR(dev->rstc)) {\n\t\tdev_err(dev->dev, \"Failed to get reset control\\n\");\n\n\t\treturn PTR_ERR(dev->rstc);\n\t}\n\n\tmutex_init(&dev->dev_mutex);\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to register V4L2 device\\n\");\n\n\t\treturn ret;\n\t}\n\n\tvfd = &dev->vfd;\n\tvfd->lock = &dev->dev_mutex;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s\",\n\t\t rotate_video_device.name);\n\tvideo_set_drvdata(vfd, dev);\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register video device\\n\");\n\n\t\tgoto err_v4l2;\n\t}\n\n\tv4l2_info(&dev->v4l2_dev,\n\t\t  \"Device registered as /dev/video%d\\n\", vfd->num);\n\n\tdev->m2m_dev = v4l2_m2m_init(&rotate_m2m_ops);\n\tif (IS_ERR(dev->m2m_dev)) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Failed to initialize V4L2 M2M device\\n\");\n\t\tret = PTR_ERR(dev->m2m_dev);\n\n\t\tgoto err_video;\n\t}\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tpm_runtime_enable(dev->dev);\n\n\treturn 0;\n\nerr_video:\n\tvideo_unregister_device(&dev->vfd);\nerr_v4l2:\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\n\treturn ret;\n}\n\nstatic void rotate_remove(struct platform_device *pdev)\n{\n\tstruct rotate_dev *dev = platform_get_drvdata(pdev);\n\n\tv4l2_m2m_release(dev->m2m_dev);\n\tvideo_unregister_device(&dev->vfd);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\n\tpm_runtime_force_suspend(&pdev->dev);\n}\n\nstatic int rotate_runtime_resume(struct device *device)\n{\n\tstruct rotate_dev *dev = dev_get_drvdata(device);\n\tint ret;\n\n\tret = clk_prepare_enable(dev->bus_clk);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to enable bus clock\\n\");\n\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(dev->mod_clk);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to enable mod clock\\n\");\n\n\t\tgoto err_bus_clk;\n\t}\n\n\tret = reset_control_deassert(dev->rstc);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to apply reset\\n\");\n\n\t\tgoto err_mod_clk;\n\t}\n\n\treturn 0;\n\nerr_mod_clk:\n\tclk_disable_unprepare(dev->mod_clk);\nerr_bus_clk:\n\tclk_disable_unprepare(dev->bus_clk);\n\n\treturn ret;\n}\n\nstatic int rotate_runtime_suspend(struct device *device)\n{\n\tstruct rotate_dev *dev = dev_get_drvdata(device);\n\n\treset_control_assert(dev->rstc);\n\n\tclk_disable_unprepare(dev->mod_clk);\n\tclk_disable_unprepare(dev->bus_clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rotate_dt_match[] = {\n\t{ .compatible = \"allwinner,sun8i-a83t-de2-rotate\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rotate_dt_match);\n\nstatic const struct dev_pm_ops rotate_pm_ops = {\n\t.runtime_resume\t\t= rotate_runtime_resume,\n\t.runtime_suspend\t= rotate_runtime_suspend,\n};\n\nstatic struct platform_driver rotate_driver = {\n\t.probe\t\t= rotate_probe,\n\t.remove_new\t= rotate_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= ROTATE_NAME,\n\t\t.of_match_table\t= rotate_dt_match,\n\t\t.pm\t\t= &rotate_pm_ops,\n\t},\n};\nmodule_platform_driver(rotate_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jernej Skrabec <jernej.skrabec@siol.net>\");\nMODULE_DESCRIPTION(\"Allwinner DE2 rotate driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}