{
  "module_name": "via-camera.c",
  "hash_id": "c4b2665070d1deb93c27f0bf29c80a5e25f835d680a3f6e129f9d439f55f69e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/via/via-camera.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-image-sizes.h>\n#include <media/i2c/ov7670.h>\n#include <media/videobuf2-dma-sg.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/pm_qos.h>\n#include <linux/via-core.h>\n#include <linux/via_i2c.h>\n\n#ifdef CONFIG_X86\n#include <asm/olpc.h>\n#else\n#define machine_is_olpc(x) 0\n#endif\n\n#include \"via-camera.h\"\n\nMODULE_ALIAS(\"platform:viafb-camera\");\nMODULE_AUTHOR(\"Jonathan Corbet <corbet@lwn.net>\");\nMODULE_DESCRIPTION(\"VIA framebuffer-based camera controller driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool flip_image;\nmodule_param(flip_image, bool, 0444);\nMODULE_PARM_DESC(flip_image,\n\t\t\"If set, the sensor will be instructed to flip the image vertically.\");\n\nstatic bool override_serial;\nmodule_param(override_serial, bool, 0444);\nMODULE_PARM_DESC(override_serial,\n\t\t\"The camera driver will normally refuse to load if the XO 1.5 serial port is enabled.  Set this option to force-enable the camera.\");\n\n \nenum viacam_opstate { S_IDLE = 0, S_RUNNING = 1 };\n\nstruct via_camera {\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct video_device vdev;\n\tstruct v4l2_subdev *sensor;\n\tstruct platform_device *platdev;\n\tstruct viafb_dev *viadev;\n\tstruct mutex lock;\n\tenum viacam_opstate opstate;\n\tunsigned long flags;\n\tstruct pm_qos_request qos_request;\n\t \n\tstruct gpio_desc *power_gpio;\n\tstruct gpio_desc *reset_gpio;\n\t \n\tvoid __iomem *mmio;\t \n\tvoid __iomem *fbmem;\t \n\tu32 fb_offset;\t\t \n\t \n\tunsigned int cb_offsets[3];\t \n\tu8 __iomem *cb_addrs[3];\t \n\tint n_cap_bufs;\t\t\t \n\tstruct vb2_queue vq;\n\tstruct list_head buffer_queue;\n\tu32 sequence;\n\t \n\tstruct v4l2_pix_format sensor_format;\n\tstruct v4l2_pix_format user_format;\n\tu32 mbus_code;\n};\n\n \nstruct via_buffer {\n\t \n\tstruct vb2_v4l2_buffer\t\tvbuf;\n\tstruct list_head\t\tqueue;\n};\n\n \nstatic struct via_camera *via_cam_info;\n\n \n#define CF_DMA_ACTIVE\t 0\t \n#define CF_CONFIG_NEEDED 1\t \n\n\n \n#define sensor_call(cam, optype, func, args...) \\\n\tv4l2_subdev_call(cam->sensor, optype, func, ##args)\n\n \n#define cam_err(cam, fmt, arg...) \\\n\tdev_err(&(cam)->platdev->dev, fmt, ##arg)\n#define cam_warn(cam, fmt, arg...) \\\n\tdev_warn(&(cam)->platdev->dev, fmt, ##arg)\n#define cam_dbg(cam, fmt, arg...) \\\n\tdev_dbg(&(cam)->platdev->dev, fmt, ##arg)\n\n \nstatic struct via_format {\n\t__u32 pixelformat;\n\tint bpp;    \n\tu32 mbus_code;\n} via_formats[] = {\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUYV,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.bpp\t\t= 2,\n\t},\n\t \n};\n#define N_VIA_FMTS ARRAY_SIZE(via_formats)\n\nstatic struct via_format *via_find_format(u32 pixelformat)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < N_VIA_FMTS; i++)\n\t\tif (via_formats[i].pixelformat == pixelformat)\n\t\t\treturn via_formats + i;\n\t \n\treturn via_formats;\n}\n\n\n \n \nstatic int via_sensor_power_setup(struct via_camera *cam)\n{\n\tstruct device *dev = &cam->platdev->dev;\n\n\tcam->power_gpio = devm_gpiod_get(dev, \"VGPIO3\", GPIOD_OUT_LOW);\n\tif (IS_ERR(cam->power_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(cam->power_gpio),\n\t\t\t\t     \"failed to get power GPIO\");\n\n\t \n\tcam->reset_gpio = devm_gpiod_get(dev, \"VGPIO2\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(cam->reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(cam->reset_gpio),\n\t\t\t\t     \"failed to get reset GPIO\");\n\n\treturn 0;\n}\n\n \nstatic void via_sensor_power_up(struct via_camera *cam)\n{\n\tgpiod_set_value(cam->power_gpio, 1);\n\tgpiod_set_value(cam->reset_gpio, 1);\n\tmsleep(20);   \n\tgpiod_set_value(cam->reset_gpio, 0);\n\tmsleep(20);\n}\n\nstatic void via_sensor_power_down(struct via_camera *cam)\n{\n\tgpiod_set_value(cam->power_gpio, 0);\n\tgpiod_set_value(cam->reset_gpio, 1);\n}\n\n\nstatic void via_sensor_power_release(struct via_camera *cam)\n{\n\tvia_sensor_power_down(cam);\n}\n\n \n \n\n \nstatic int viacam_set_flip(struct via_camera *cam)\n{\n\tstruct v4l2_control ctrl;\n\n\tmemset(&ctrl, 0, sizeof(ctrl));\n\tctrl.id = V4L2_CID_VFLIP;\n\tctrl.value = flip_image;\n\treturn v4l2_s_ctrl(NULL, cam->sensor->ctrl_handler, &ctrl);\n}\n\n \nstatic int viacam_configure_sensor(struct via_camera *cam)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tv4l2_fill_mbus_format(&format.format, &cam->sensor_format, cam->mbus_code);\n\tret = sensor_call(cam, core, init, 0);\n\tif (ret == 0)\n\t\tret = sensor_call(cam, pad, set_fmt, NULL, &format);\n\t \n\tif (ret == 0)\n\t\tret = viacam_set_flip(cam);\n\treturn ret;\n}\n\n\n\n \n \nstatic inline void viacam_write_reg(struct via_camera *cam,\n\t\tint reg, int value)\n{\n\tiowrite32(value, cam->mmio + reg);\n}\n\nstatic inline int viacam_read_reg(struct via_camera *cam, int reg)\n{\n\treturn ioread32(cam->mmio + reg);\n}\n\nstatic inline void viacam_write_reg_mask(struct via_camera *cam,\n\t\tint reg, int value, int mask)\n{\n\tint tmp = viacam_read_reg(cam, reg);\n\n\ttmp = (tmp & ~mask) | (value & mask);\n\tviacam_write_reg(cam, reg, tmp);\n}\n\n\n \n \n\nstatic irqreturn_t viacam_quick_irq(int irq, void *data)\n{\n\tstruct via_camera *cam = data;\n\tirqreturn_t ret = IRQ_NONE;\n\tint icv;\n\n\t \n\tspin_lock(&cam->viadev->reg_lock);\n\ticv = viacam_read_reg(cam, VCR_INTCTRL);\n\tif (icv & VCR_IC_EAV) {\n\t\ticv |= VCR_IC_EAV|VCR_IC_EVBI|VCR_IC_FFULL;\n\t\tviacam_write_reg(cam, VCR_INTCTRL, icv);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\tspin_unlock(&cam->viadev->reg_lock);\n\treturn ret;\n}\n\n \nstatic struct via_buffer *viacam_next_buffer(struct via_camera *cam)\n{\n\tif (cam->opstate != S_RUNNING)\n\t\treturn NULL;\n\tif (list_empty(&cam->buffer_queue))\n\t\treturn NULL;\n\treturn list_entry(cam->buffer_queue.next, struct via_buffer, queue);\n}\n\n \nstatic irqreturn_t viacam_irq(int irq, void *data)\n{\n\tstruct via_camera *cam = data;\n\tstruct via_buffer *vb;\n\tint bufn;\n\tstruct sg_table *sgt;\n\n\tmutex_lock(&cam->lock);\n\t \n\tvb = viacam_next_buffer(cam);\n\tif (vb == NULL)\n\t\tgoto done;\n\t \n\tbufn = (viacam_read_reg(cam, VCR_INTCTRL) & VCR_IC_ACTBUF) >> 3;\n\tbufn -= 1;\n\tif (bufn < 0)\n\t\tbufn = cam->n_cap_bufs - 1;\n\t \n\tsgt = vb2_dma_sg_plane_desc(&vb->vbuf.vb2_buf, 0);\n\tvb->vbuf.vb2_buf.timestamp = ktime_get_ns();\n\tviafb_dma_copy_out_sg(cam->cb_offsets[bufn], sgt->sgl, sgt->nents);\n\tvb->vbuf.sequence = cam->sequence++;\n\tvb->vbuf.field = V4L2_FIELD_NONE;\n\tlist_del(&vb->queue);\n\tvb2_buffer_done(&vb->vbuf.vb2_buf, VB2_BUF_STATE_DONE);\ndone:\n\tmutex_unlock(&cam->lock);\n\treturn IRQ_HANDLED;\n}\n\n\n \nstatic void viacam_int_enable(struct via_camera *cam)\n{\n\tviacam_write_reg(cam, VCR_INTCTRL,\n\t\t\tVCR_IC_INTEN|VCR_IC_EAV|VCR_IC_EVBI|VCR_IC_FFULL);\n\tviafb_irq_enable(VDE_I_C0AVEN);\n}\n\nstatic void viacam_int_disable(struct via_camera *cam)\n{\n\tviafb_irq_disable(VDE_I_C0AVEN);\n\tviacam_write_reg(cam, VCR_INTCTRL, 0);\n}\n\n\n\n \n \n\n \nstatic int viacam_ctlr_cbufs(struct via_camera *cam)\n{\n\tint nbuf = cam->viadev->camera_fbmem_size/cam->sensor_format.sizeimage;\n\tint i;\n\tunsigned int offset;\n\n\t \n\tif (nbuf >= 3) {\n\t\tcam->n_cap_bufs = 3;\n\t\tviacam_write_reg_mask(cam, VCR_CAPINTC, VCR_CI_3BUFS,\n\t\t\t\tVCR_CI_3BUFS);\n\t} else if (nbuf == 2) {\n\t\tcam->n_cap_bufs = 2;\n\t\tviacam_write_reg_mask(cam, VCR_CAPINTC, 0, VCR_CI_3BUFS);\n\t} else {\n\t\tcam_warn(cam, \"Insufficient frame buffer memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t \n\toffset = cam->fb_offset;\n\tfor (i = 0; i < cam->n_cap_bufs; i++) {\n\t\tcam->cb_offsets[i] = offset;\n\t\tcam->cb_addrs[i] = cam->fbmem + offset;\n\t\tviacam_write_reg(cam, VCR_VBUF1 + i*4, offset & VCR_VBUF_MASK);\n\t\toffset += cam->sensor_format.sizeimage;\n\t}\n\treturn 0;\n}\n\n \nstatic void viacam_set_scale(struct via_camera *cam)\n{\n\tunsigned int avscale;\n\tint sf;\n\n\tif (cam->user_format.width == VGA_WIDTH)\n\t\tavscale = 0;\n\telse {\n\t\tsf = (cam->user_format.width*2048)/VGA_WIDTH;\n\t\tavscale = VCR_AVS_HEN | sf;\n\t}\n\tif (cam->user_format.height < VGA_HEIGHT) {\n\t\tsf = (1024*cam->user_format.height)/VGA_HEIGHT;\n\t\tavscale |= VCR_AVS_VEN | (sf << 16);\n\t}\n\tviacam_write_reg(cam, VCR_AVSCALE, avscale);\n}\n\n\n \nstatic void viacam_ctlr_image(struct via_camera *cam)\n{\n\tint cicreg;\n\n\t \n\tviacam_write_reg(cam, VCR_CAPINTC, ~(VCR_CI_ENABLE|VCR_CI_CLKEN));\n\t \n\tviacam_write_reg(cam, VCR_HORRANGE, 0x06200120);\n\tviacam_write_reg(cam, VCR_VERTRANGE, 0x01de0000);\n\tviacam_set_scale(cam);\n\t \n\tviacam_write_reg(cam, VCR_MAXDATA,\n\t\t\t(cam->sensor_format.height << 16) |\n\t\t\t(cam->sensor_format.bytesperline >> 3));\n\tviacam_write_reg(cam, VCR_MAXVBI, 0);\n\tviacam_write_reg(cam, VCR_VSTRIDE,\n\t\t\tcam->user_format.bytesperline & VCR_VS_STRIDE);\n\t \n\tcicreg = VCR_CI_CLKEN |\n\t\t0x08000000 |\t\t \n\t\tVCR_CI_FLDINV |\t\t \n\t\tVCR_CI_VREFINV |\t \n\t\tVCR_CI_DIBOTH |\t\t \n\t\tVCR_CI_CCIR601_8;\n\tif (cam->n_cap_bufs == 3)\n\t\tcicreg |= VCR_CI_3BUFS;\n\t \n\tif (cam->user_format.pixelformat == V4L2_PIX_FMT_YUYV)\n\t\tcicreg |= VCR_CI_YUYV;\n\telse\n\t\tcicreg |= VCR_CI_UYVY;\n\tviacam_write_reg(cam, VCR_CAPINTC, cicreg);\n}\n\n\nstatic int viacam_config_controller(struct via_camera *cam)\n{\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cam->viadev->reg_lock, flags);\n\tret = viacam_ctlr_cbufs(cam);\n\tif (!ret)\n\t\tviacam_ctlr_image(cam);\n\tspin_unlock_irqrestore(&cam->viadev->reg_lock, flags);\n\tclear_bit(CF_CONFIG_NEEDED, &cam->flags);\n\treturn ret;\n}\n\n \nstatic void viacam_start_engine(struct via_camera *cam)\n{\n\tspin_lock_irq(&cam->viadev->reg_lock);\n\tviacam_write_reg_mask(cam, VCR_CAPINTC, VCR_CI_ENABLE, VCR_CI_ENABLE);\n\tviacam_int_enable(cam);\n\t(void) viacam_read_reg(cam, VCR_CAPINTC);  \n\tcam->opstate = S_RUNNING;\n\tspin_unlock_irq(&cam->viadev->reg_lock);\n}\n\n\nstatic void viacam_stop_engine(struct via_camera *cam)\n{\n\tspin_lock_irq(&cam->viadev->reg_lock);\n\tviacam_int_disable(cam);\n\tviacam_write_reg_mask(cam, VCR_CAPINTC, 0, VCR_CI_ENABLE);\n\t(void) viacam_read_reg(cam, VCR_CAPINTC);  \n\tcam->opstate = S_IDLE;\n\tspin_unlock_irq(&cam->viadev->reg_lock);\n}\n\n\n \n \n\nstatic struct via_buffer *vb2_to_via_buffer(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\treturn container_of(vbuf, struct via_buffer, vbuf);\n}\n\nstatic void viacam_vb2_queue(struct vb2_buffer *vb)\n{\n\tstruct via_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct via_buffer *via = vb2_to_via_buffer(vb);\n\n\tlist_add_tail(&via->queue, &cam->buffer_queue);\n}\n\nstatic int viacam_vb2_prepare(struct vb2_buffer *vb)\n{\n\tstruct via_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\n\n\tif (vb2_plane_size(vb, 0) < cam->user_format.sizeimage) {\n\t\tcam_dbg(cam,\n\t\t\t\"Plane size too small (%lu < %u)\\n\",\n\t\t\tvb2_plane_size(vb, 0),\n\t\t\tcam->user_format.sizeimage);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, cam->user_format.sizeimage);\n\n\treturn 0;\n}\n\nstatic int viacam_vb2_queue_setup(struct vb2_queue *vq,\n\t\t\t\t  unsigned int *nbufs,\n\t\t\t\t  unsigned int *num_planes, unsigned int sizes[],\n\t\t\t\t  struct device *alloc_devs[])\n{\n\tstruct via_camera *cam = vb2_get_drv_priv(vq);\n\tint size = cam->user_format.sizeimage;\n\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*num_planes = 1;\n\tsizes[0] = size;\n\treturn 0;\n}\n\nstatic int viacam_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct via_camera *cam = vb2_get_drv_priv(vq);\n\tstruct via_buffer *buf, *tmp;\n\tint ret = 0;\n\n\tif (cam->opstate != S_IDLE) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\t \n\tif (test_bit(CF_CONFIG_NEEDED, &cam->flags)) {\n\t\tret = viacam_configure_sensor(cam);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = viacam_config_controller(cam);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tcam->sequence = 0;\n\t \n\tcpu_latency_qos_add_request(&cam->qos_request, 50);\n\tviacam_start_engine(cam);\n\treturn 0;\nout:\n\tlist_for_each_entry_safe(buf, tmp, &cam->buffer_queue, queue) {\n\t\tlist_del(&buf->queue);\n\t\tvb2_buffer_done(&buf->vbuf.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t}\n\treturn ret;\n}\n\nstatic void viacam_vb2_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct via_camera *cam = vb2_get_drv_priv(vq);\n\tstruct via_buffer *buf, *tmp;\n\n\tcpu_latency_qos_remove_request(&cam->qos_request);\n\tviacam_stop_engine(cam);\n\n\tlist_for_each_entry_safe(buf, tmp, &cam->buffer_queue, queue) {\n\t\tlist_del(&buf->queue);\n\t\tvb2_buffer_done(&buf->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic const struct vb2_ops viacam_vb2_ops = {\n\t.queue_setup\t\t= viacam_vb2_queue_setup,\n\t.buf_queue\t\t= viacam_vb2_queue,\n\t.buf_prepare\t\t= viacam_vb2_prepare,\n\t.start_streaming\t= viacam_vb2_start_streaming,\n\t.stop_streaming\t\t= viacam_vb2_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \n \n\nstatic int viacam_open(struct file *filp)\n{\n\tstruct via_camera *cam = video_drvdata(filp);\n\tint ret;\n\n\t \n\tmutex_lock(&cam->lock);\n\tret = v4l2_fh_open(filp);\n\tif (ret)\n\t\tgoto out;\n\tif (v4l2_fh_is_singular_file(filp)) {\n\t\tret = viafb_request_dma();\n\n\t\tif (ret) {\n\t\t\tv4l2_fh_release(filp);\n\t\t\tgoto out;\n\t\t}\n\t\tvia_sensor_power_up(cam);\n\t\tset_bit(CF_CONFIG_NEEDED, &cam->flags);\n\t}\nout:\n\tmutex_unlock(&cam->lock);\n\treturn ret;\n}\n\nstatic int viacam_release(struct file *filp)\n{\n\tstruct via_camera *cam = video_drvdata(filp);\n\tbool last_open;\n\n\tmutex_lock(&cam->lock);\n\tlast_open = v4l2_fh_is_singular_file(filp);\n\t_vb2_fop_release(filp, NULL);\n\t \n\tif (last_open) {\n\t\tvia_sensor_power_down(cam);\n\t\tviafb_release_dma();\n\t}\n\tmutex_unlock(&cam->lock);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations viacam_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= viacam_open,\n\t.release\t= viacam_release,\n\t.read\t\t= vb2_fop_read,\n\t.poll\t\t= vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\n \n \n\n \nstatic int viacam_enum_input(struct file *filp, void *priv,\n\t\tstruct v4l2_input *input)\n{\n\tif (input->index != 0)\n\t\treturn -EINVAL;\n\n\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\tstrscpy(input->name, \"Camera\", sizeof(input->name));\n\treturn 0;\n}\n\nstatic int viacam_g_input(struct file *filp, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int viacam_s_input(struct file *filp, void *priv, unsigned int i)\n{\n\tif (i != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic const struct v4l2_pix_format viacam_def_pix_format = {\n\t.width\t\t= VGA_WIDTH,\n\t.height\t\t= VGA_HEIGHT,\n\t.pixelformat\t= V4L2_PIX_FMT_YUYV,\n\t.field\t\t= V4L2_FIELD_NONE,\n\t.bytesperline\t= VGA_WIDTH * 2,\n\t.sizeimage\t= VGA_WIDTH * VGA_HEIGHT * 2,\n\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n};\n\nstatic const u32 via_def_mbus_code = MEDIA_BUS_FMT_YUYV8_2X8;\n\nstatic int viacam_enum_fmt_vid_cap(struct file *filp, void *priv,\n\t\tstruct v4l2_fmtdesc *fmt)\n{\n\tif (fmt->index >= N_VIA_FMTS)\n\t\treturn -EINVAL;\n\tfmt->pixelformat = via_formats[fmt->index].pixelformat;\n\treturn 0;\n}\n\n \nstatic void viacam_fmt_pre(struct v4l2_pix_format *userfmt,\n\t\tstruct v4l2_pix_format *sensorfmt)\n{\n\t*sensorfmt = *userfmt;\n\tif (userfmt->width < QCIF_WIDTH || userfmt->height < QCIF_HEIGHT) {\n\t\tuserfmt->width = QCIF_WIDTH;\n\t\tuserfmt->height = QCIF_HEIGHT;\n\t}\n\tif (userfmt->width > VGA_WIDTH || userfmt->height > VGA_HEIGHT) {\n\t\tuserfmt->width = VGA_WIDTH;\n\t\tuserfmt->height = VGA_HEIGHT;\n\t}\n\tsensorfmt->width = VGA_WIDTH;\n\tsensorfmt->height = VGA_HEIGHT;\n}\n\nstatic void viacam_fmt_post(struct v4l2_pix_format *userfmt,\n\t\tstruct v4l2_pix_format *sensorfmt)\n{\n\tstruct via_format *f = via_find_format(userfmt->pixelformat);\n\n\tsensorfmt->bytesperline = sensorfmt->width * f->bpp;\n\tsensorfmt->sizeimage = sensorfmt->height * sensorfmt->bytesperline;\n\tuserfmt->pixelformat = sensorfmt->pixelformat;\n\tuserfmt->field = sensorfmt->field;\n\tuserfmt->bytesperline = 2 * userfmt->width;\n\tuserfmt->sizeimage = userfmt->bytesperline * userfmt->height;\n\tuserfmt->colorspace = sensorfmt->colorspace;\n\tuserfmt->ycbcr_enc = sensorfmt->ycbcr_enc;\n\tuserfmt->quantization = sensorfmt->quantization;\n\tuserfmt->xfer_func = sensorfmt->xfer_func;\n}\n\n\n \nstatic int viacam_do_try_fmt(struct via_camera *cam,\n\t\tstruct v4l2_pix_format *upix, struct v4l2_pix_format *spix)\n{\n\tint ret;\n\tstruct v4l2_subdev_pad_config pad_cfg;\n\tstruct v4l2_subdev_state pad_state = {\n\t\t.pads = &pad_cfg,\n\t};\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tstruct via_format *f = via_find_format(upix->pixelformat);\n\n\tupix->pixelformat = f->pixelformat;\n\tviacam_fmt_pre(upix, spix);\n\tv4l2_fill_mbus_format(&format.format, spix, f->mbus_code);\n\tret = sensor_call(cam, pad, set_fmt, &pad_state, &format);\n\tv4l2_fill_pix_format(spix, &format.format);\n\tviacam_fmt_post(upix, spix);\n\treturn ret;\n}\n\n\n\nstatic int viacam_try_fmt_vid_cap(struct file *filp, void *priv,\n\t\tstruct v4l2_format *fmt)\n{\n\tstruct via_camera *cam = video_drvdata(filp);\n\tstruct v4l2_format sfmt;\n\n\treturn viacam_do_try_fmt(cam, &fmt->fmt.pix, &sfmt.fmt.pix);\n}\n\n\nstatic int viacam_g_fmt_vid_cap(struct file *filp, void *priv,\n\t\tstruct v4l2_format *fmt)\n{\n\tstruct via_camera *cam = video_drvdata(filp);\n\n\tfmt->fmt.pix = cam->user_format;\n\treturn 0;\n}\n\nstatic int viacam_s_fmt_vid_cap(struct file *filp, void *priv,\n\t\tstruct v4l2_format *fmt)\n{\n\tstruct via_camera *cam = video_drvdata(filp);\n\tint ret;\n\tstruct v4l2_format sfmt;\n\tstruct via_format *f = via_find_format(fmt->fmt.pix.pixelformat);\n\n\t \n\tif (cam->opstate != S_IDLE)\n\t\treturn -EBUSY;\n\t \n\tret = viacam_do_try_fmt(cam, &fmt->fmt.pix, &sfmt.fmt.pix);\n\tif (ret)\n\t\treturn ret;\n\t \n\tcam->user_format = fmt->fmt.pix;\n\tcam->sensor_format = sfmt.fmt.pix;\n\tcam->mbus_code = f->mbus_code;\n\tret = viacam_configure_sensor(cam);\n\tif (!ret)\n\t\tret = viacam_config_controller(cam);\n\treturn ret;\n}\n\nstatic int viacam_querycap(struct file *filp, void *priv,\n\t\tstruct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, \"via-camera\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"via-camera\", sizeof(cap->card));\n\tstrscpy(cap->bus_info, \"platform:via-camera\", sizeof(cap->bus_info));\n\treturn 0;\n}\n\n \n\nstatic int viacam_g_parm(struct file *filp, void *priv,\n\t\tstruct v4l2_streamparm *parm)\n{\n\tstruct via_camera *cam = video_drvdata(filp);\n\n\treturn v4l2_g_parm_cap(video_devdata(filp), cam->sensor, parm);\n}\n\nstatic int viacam_s_parm(struct file *filp, void *priv,\n\t\tstruct v4l2_streamparm *parm)\n{\n\tstruct via_camera *cam = video_drvdata(filp);\n\n\treturn v4l2_s_parm_cap(video_devdata(filp), cam->sensor, parm);\n}\n\nstatic int viacam_enum_framesizes(struct file *filp, void *priv,\n\t\tstruct v4l2_frmsizeenum *sizes)\n{\n\tunsigned int i;\n\n\tif (sizes->index != 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < N_VIA_FMTS; i++)\n\t\tif (sizes->pixel_format == via_formats[i].pixelformat)\n\t\t\tbreak;\n\tif (i >= N_VIA_FMTS)\n\t\treturn -EINVAL;\n\tsizes->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\tsizes->stepwise.min_width = QCIF_WIDTH;\n\tsizes->stepwise.min_height = QCIF_HEIGHT;\n\tsizes->stepwise.max_width = VGA_WIDTH;\n\tsizes->stepwise.max_height = VGA_HEIGHT;\n\tsizes->stepwise.step_width = sizes->stepwise.step_height = 1;\n\treturn 0;\n}\n\nstatic int viacam_enum_frameintervals(struct file *filp, void *priv,\n\t\tstruct v4l2_frmivalenum *interval)\n{\n\tstruct via_camera *cam = video_drvdata(filp);\n\tstruct v4l2_subdev_frame_interval_enum fie = {\n\t\t.index = interval->index,\n\t\t.code = cam->mbus_code,\n\t\t.width = cam->sensor_format.width,\n\t\t.height = cam->sensor_format.height,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < N_VIA_FMTS; i++)\n\t\tif (interval->pixel_format == via_formats[i].pixelformat)\n\t\t\tbreak;\n\tif (i >= N_VIA_FMTS)\n\t\treturn -EINVAL;\n\tif (interval->width < QCIF_WIDTH || interval->width > VGA_WIDTH ||\n\t    interval->height < QCIF_HEIGHT || interval->height > VGA_HEIGHT)\n\t\treturn -EINVAL;\n\tret = sensor_call(cam, pad, enum_frame_interval, NULL, &fie);\n\tif (ret)\n\t\treturn ret;\n\tinterval->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tinterval->discrete = fie.interval;\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops viacam_ioctl_ops = {\n\t.vidioc_enum_input\t= viacam_enum_input,\n\t.vidioc_g_input\t\t= viacam_g_input,\n\t.vidioc_s_input\t\t= viacam_s_input,\n\t.vidioc_enum_fmt_vid_cap = viacam_enum_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap = viacam_try_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t= viacam_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t= viacam_s_fmt_vid_cap,\n\t.vidioc_querycap\t= viacam_querycap,\n\t.vidioc_reqbufs\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t= vb2_ioctl_querybuf,\n\t.vidioc_prepare_buf\t= vb2_ioctl_prepare_buf,\n\t.vidioc_qbuf\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t= vb2_ioctl_streamoff,\n\t.vidioc_g_parm\t\t= viacam_g_parm,\n\t.vidioc_s_parm\t\t= viacam_s_parm,\n\t.vidioc_enum_framesizes = viacam_enum_framesizes,\n\t.vidioc_enum_frameintervals = viacam_enum_frameintervals,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\n \n\n \n#ifdef CONFIG_PM\n\nstatic int viacam_suspend(void *priv)\n{\n\tstruct via_camera *cam = priv;\n\tenum viacam_opstate state = cam->opstate;\n\n\tif (cam->opstate != S_IDLE) {\n\t\tviacam_stop_engine(cam);\n\t\tcam->opstate = state;  \n\t}\n\n\treturn 0;\n}\n\nstatic int viacam_resume(void *priv)\n{\n\tstruct via_camera *cam = priv;\n\tint ret = 0;\n\n\t \n\tvia_write_reg_mask(VIASR, 0x78, 0, 0x80);\n\tvia_write_reg_mask(VIASR, 0x1e, 0xc0, 0xc0);\n\tviacam_int_disable(cam);\n\tset_bit(CF_CONFIG_NEEDED, &cam->flags);\n\t \n\tif (!list_empty(&cam->vdev.fh_list))\n\t\tvia_sensor_power_up(cam);\n\telse\n\t\tvia_sensor_power_down(cam);\n\t \n\tif (cam->opstate != S_IDLE) {\n\t\tmutex_lock(&cam->lock);\n\t\tret = viacam_configure_sensor(cam);\n\t\tif (!ret)\n\t\t\tret = viacam_config_controller(cam);\n\t\tmutex_unlock(&cam->lock);\n\t\tif (!ret)\n\t\t\tviacam_start_engine(cam);\n\t}\n\n\treturn ret;\n}\n\nstatic struct viafb_pm_hooks viacam_pm_hooks = {\n\t.suspend = viacam_suspend,\n\t.resume = viacam_resume\n};\n\n#endif  \n\n \n\nstatic const struct video_device viacam_v4l_template = {\n\t.name\t\t= \"via-camera\",\n\t.minor\t\t= -1,\n\t.fops\t\t= &viacam_fops,\n\t.ioctl_ops\t= &viacam_ioctl_ops,\n\t.release\t= video_device_release_empty,  \n\t.device_caps\t= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t\t  V4L2_CAP_STREAMING,\n};\n\n \n#define VIACAM_SERIAL_DEVFN 0x88\n#define VIACAM_SERIAL_CREG 0x46\n#define VIACAM_SERIAL_BIT 0x40\n\nstatic bool viacam_serial_is_enabled(void)\n{\n\tstruct pci_bus *pbus = pci_find_bus(0, 0);\n\tu8 cbyte;\n\n\tif (!pbus)\n\t\treturn false;\n\tpci_bus_read_config_byte(pbus, VIACAM_SERIAL_DEVFN,\n\t\t\tVIACAM_SERIAL_CREG, &cbyte);\n\tif ((cbyte & VIACAM_SERIAL_BIT) == 0)\n\t\treturn false;  \n\tif (!override_serial) {\n\t\tprintk(KERN_NOTICE \"Via camera: serial port is enabled, \" \\\n\t\t\t\t\"refusing to load.\\n\");\n\t\tprintk(KERN_NOTICE \"Specify override_serial=1 to force \" \\\n\t\t\t\t\"module loading.\\n\");\n\t\treturn true;\n\t}\n\tprintk(KERN_NOTICE \"Via camera: overriding serial port\\n\");\n\tpci_bus_write_config_byte(pbus, VIACAM_SERIAL_DEVFN,\n\t\t\tVIACAM_SERIAL_CREG, cbyte & ~VIACAM_SERIAL_BIT);\n\treturn false;\n}\n\nstatic struct ov7670_config sensor_cfg = {\n\t \n\t.clock_speed = 90,\n};\n\nstatic int viacam_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct i2c_adapter *sensor_adapter;\n\tstruct viafb_dev *viadev = pdev->dev.platform_data;\n\tstruct vb2_queue *vq;\n\tstruct i2c_board_info ov7670_info = {\n\t\t.type = \"ov7670\",\n\t\t.addr = 0x42 >> 1,\n\t\t.platform_data = &sensor_cfg,\n\t};\n\n\t \n\tstruct via_camera *cam;\n\n\t \n\tif (viadev->camera_fbmem_size < (VGA_HEIGHT*VGA_WIDTH*4)) {\n\t\tprintk(KERN_ERR \"viacam: insufficient FB memory reserved\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (viadev->engine_mmio == NULL) {\n\t\tprintk(KERN_ERR \"viacam: No I/O memory, so no pictures\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (machine_is_olpc() && viacam_serial_is_enabled())\n\t\treturn -EBUSY;\n\n\t \n\tcam = kzalloc (sizeof(struct via_camera), GFP_KERNEL);\n\tif (cam == NULL)\n\t\treturn -ENOMEM;\n\tvia_cam_info = cam;\n\tcam->platdev = pdev;\n\tcam->viadev = viadev;\n\tcam->opstate = S_IDLE;\n\tcam->user_format = cam->sensor_format = viacam_def_pix_format;\n\tmutex_init(&cam->lock);\n\tINIT_LIST_HEAD(&cam->buffer_queue);\n\tcam->mmio = viadev->engine_mmio;\n\tcam->fbmem = viadev->fbmem;\n\tcam->fb_offset = viadev->camera_fbmem_offset;\n\tcam->flags = 1 << CF_CONFIG_NEEDED;\n\tcam->mbus_code = via_def_mbus_code;\n\t \n\tret = v4l2_device_register(&pdev->dev, &cam->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to register v4l2 device\\n\");\n\t\tgoto out_free;\n\t}\n\tret = v4l2_ctrl_handler_init(&cam->ctrl_handler, 10);\n\tif (ret)\n\t\tgoto out_unregister;\n\tcam->v4l2_dev.ctrl_handler = &cam->ctrl_handler;\n\t \n\tpdev->dev.dma_mask = &viadev->pdev->dma_mask;\n\tret = dma_set_mask(&pdev->dev, 0xffffffff);\n\tif (ret)\n\t\tgoto out_ctrl_hdl_free;\n\t \n\tvia_write_reg_mask(VIASR, 0x78, 0, 0x80);\n\tvia_write_reg_mask(VIASR, 0x1e, 0xc0, 0xc0);\n\t \n\tret = via_sensor_power_setup(cam);\n\tif (ret)\n\t\tgoto out_ctrl_hdl_free;\n\tvia_sensor_power_up(cam);\n\n\t \n\tsensor_adapter = viafb_find_i2c_adapter(VIA_PORT_31);\n\tcam->sensor = v4l2_i2c_new_subdev_board(&cam->v4l2_dev, sensor_adapter,\n\t\t\t&ov7670_info, NULL);\n\tif (cam->sensor == NULL) {\n\t\tdev_err(&pdev->dev, \"Unable to find the sensor!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_power_down;\n\t}\n\t \n\tviacam_int_disable(cam);\n\tret = request_threaded_irq(viadev->pdev->irq, viacam_quick_irq,\n\t\t\tviacam_irq, IRQF_SHARED, \"via-camera\", cam);\n\tif (ret)\n\t\tgoto out_power_down;\n\n\tvq = &cam->vq;\n\tvq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tvq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\n\tvq->drv_priv = cam;\n\tvq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tvq->buf_struct_size = sizeof(struct via_buffer);\n\tvq->dev = cam->v4l2_dev.dev;\n\n\tvq->ops = &viacam_vb2_ops;\n\tvq->mem_ops = &vb2_dma_sg_memops;\n\tvq->lock = &cam->lock;\n\n\tret = vb2_queue_init(vq);\n\t \n\tcam->vdev = viacam_v4l_template;\n\tcam->vdev.v4l2_dev = &cam->v4l2_dev;\n\tcam->vdev.lock = &cam->lock;\n\tcam->vdev.queue = vq;\n\tvideo_set_drvdata(&cam->vdev, cam);\n\tret = video_register_device(&cam->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret)\n\t\tgoto out_irq;\n\n#ifdef CONFIG_PM\n\t \n\tviacam_pm_hooks.private = cam;\n\tviafb_pm_register(&viacam_pm_hooks);\n#endif\n\n\t \n\tvia_sensor_power_down(cam);\n\treturn 0;\n\nout_irq:\n\tfree_irq(viadev->pdev->irq, cam);\nout_power_down:\n\tvia_sensor_power_release(cam);\nout_ctrl_hdl_free:\n\tv4l2_ctrl_handler_free(&cam->ctrl_handler);\nout_unregister:\n\tv4l2_device_unregister(&cam->v4l2_dev);\nout_free:\n\tkfree(cam);\n\treturn ret;\n}\n\nstatic void viacam_remove(struct platform_device *pdev)\n{\n\tstruct via_camera *cam = via_cam_info;\n\tstruct viafb_dev *viadev = pdev->dev.platform_data;\n\n\tvideo_unregister_device(&cam->vdev);\n\tv4l2_device_unregister(&cam->v4l2_dev);\n#ifdef CONFIG_PM\n\tviafb_pm_unregister(&viacam_pm_hooks);\n#endif\n\tfree_irq(viadev->pdev->irq, cam);\n\tvia_sensor_power_release(cam);\n\tv4l2_ctrl_handler_free(&cam->ctrl_handler);\n\tkfree(cam);\n\tvia_cam_info = NULL;\n}\n\nstatic struct platform_driver viacam_driver = {\n\t.driver = {\n\t\t.name = \"viafb-camera\",\n\t},\n\t.probe = viacam_probe,\n\t.remove_new = viacam_remove,\n};\n\nmodule_platform_driver(viacam_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}