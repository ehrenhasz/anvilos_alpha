{
  "module_name": "mmp-driver.c",
  "hash_id": "63430e2e3bd61fcf6aac9078adeb2098738b8cbe12a24c0ef451bb5100850ba5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/marvell/mmp-driver.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <linux/platform_data/media/mmp-camera.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/pm.h>\n#include <linux/clk.h>\n\n#include \"mcam-core.h\"\n\nMODULE_ALIAS(\"platform:mmp-camera\");\nMODULE_AUTHOR(\"Jonathan Corbet <corbet@lwn.net>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic char *mcam_clks[] = {\"axi\", \"func\", \"phy\"};\n\nstruct mmp_camera {\n\tstruct platform_device *pdev;\n\tstruct mcam_camera mcam;\n\tstruct list_head devlist;\n\tstruct clk *mipi_clk;\n\tint irq;\n};\n\nstatic inline struct mmp_camera *mcam_to_cam(struct mcam_camera *mcam)\n{\n\treturn container_of(mcam, struct mmp_camera, mcam);\n}\n\n \nstatic void mmpcam_calc_dphy(struct mcam_camera *mcam)\n{\n\tstruct mmp_camera *cam = mcam_to_cam(mcam);\n\tstruct mmp_camera_platform_data *pdata = cam->pdev->dev.platform_data;\n\tstruct device *dev = &cam->pdev->dev;\n\tunsigned long tx_clk_esc;\n\n\t \n\t \n\tswitch (pdata->dphy3_algo) {\n\tcase DPHY3_ALGO_PXA910:\n\t\t \n\t\tpdata->dphy[0] =\n\t\t\t(((1 + (pdata->lane_clk * 80) / 1000) & 0xff) << 8)\n\t\t\t| (1 + pdata->lane_clk * 35 / 1000);\n\t\tbreak;\n\tcase DPHY3_ALGO_PXA2128:\n\t\t \n\t\tpdata->dphy[0] =\n\t\t\t(((2 + (pdata->lane_clk * 110) / 1000) & 0xff) << 8)\n\t\t\t| (1 + pdata->lane_clk * 35 / 1000);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_dbg(dev, \"camera: use the default CSI2_DPHY3 value\\n\");\n\t}\n\n\t \n\tif (IS_ERR(cam->mipi_clk))\n\t\treturn;\n\n\t \n\tclk_prepare_enable(cam->mipi_clk);\n\ttx_clk_esc = (clk_get_rate(cam->mipi_clk) / 1000000) / 12;\n\tclk_disable_unprepare(cam->mipi_clk);\n\t \n\tpdata->dphy[2] =\n\t\t((((534 * tx_clk_esc) / 2000 - 1) & 0xff) << 8)\n\t\t| (((38 * tx_clk_esc) / 1000 - 1) & 0xff);\n\n\tdev_dbg(dev, \"camera: DPHY sets: dphy3=0x%x, dphy5=0x%x, dphy6=0x%x\\n\",\n\t\tpdata->dphy[0], pdata->dphy[1], pdata->dphy[2]);\n}\n\nstatic irqreturn_t mmpcam_irq(int irq, void *data)\n{\n\tstruct mcam_camera *mcam = data;\n\tunsigned int irqs, handled;\n\n\tspin_lock(&mcam->dev_lock);\n\tirqs = mcam_reg_read(mcam, REG_IRQSTAT);\n\thandled = mccic_irq(mcam, irqs);\n\tspin_unlock(&mcam->dev_lock);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void mcam_init_clk(struct mcam_camera *mcam)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < NR_MCAM_CLK; i++) {\n\t\tif (mcam_clks[i] != NULL) {\n\t\t\t \n\t\t\tmcam->clk[i] = devm_clk_get(mcam->dev, mcam_clks[i]);\n\t\t\tif (IS_ERR(mcam->clk[i]))\n\t\t\t\tdev_warn(mcam->dev, \"Could not get clk: %s\\n\",\n\t\t\t\t\t\tmcam_clks[i]);\n\t\t}\n\t}\n}\n\nstatic int mmpcam_probe(struct platform_device *pdev)\n{\n\tstruct mmp_camera *cam;\n\tstruct mcam_camera *mcam;\n\tstruct resource *res;\n\tstruct fwnode_handle *ep;\n\tstruct mmp_camera_platform_data *pdata;\n\tstruct v4l2_async_connection *asd;\n\tint ret;\n\n\tcam = devm_kzalloc(&pdev->dev, sizeof(*cam), GFP_KERNEL);\n\tif (cam == NULL)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, cam);\n\tcam->pdev = pdev;\n\tINIT_LIST_HEAD(&cam->devlist);\n\n\tmcam = &cam->mcam;\n\tmcam->calc_dphy = mmpcam_calc_dphy;\n\tmcam->dev = &pdev->dev;\n\tpdata = pdev->dev.platform_data;\n\tif (pdata) {\n\t\tmcam->mclk_src = pdata->mclk_src;\n\t\tmcam->mclk_div = pdata->mclk_div;\n\t\tmcam->bus_type = pdata->bus_type;\n\t\tmcam->dphy = pdata->dphy;\n\t\tmcam->lane = pdata->lane;\n\t} else {\n\t\t \n\t\tmcam->mclk_src = 3;\n\t\tmcam->mclk_div = 2;\n\t}\n\tif (mcam->bus_type == V4L2_MBUS_CSI2_DPHY) {\n\t\tcam->mipi_clk = devm_clk_get(mcam->dev, \"mipi\");\n\t\tif ((IS_ERR(cam->mipi_clk) && mcam->dphy[2] == 0))\n\t\t\treturn PTR_ERR(cam->mipi_clk);\n\t}\n\tmcam->mipi_enabled = false;\n\tmcam->chip_id = MCAM_ARMADA610;\n\tmcam->buffer_mode = B_DMA_sg;\n\tstrscpy(mcam->bus_info, \"platform:mmp-camera\", sizeof(mcam->bus_info));\n\tspin_lock_init(&mcam->dev_lock);\n\t \n\tmcam->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(mcam->regs))\n\t\treturn PTR_ERR(mcam->regs);\n\tmcam->regs_size = resource_size(res);\n\n\tmcam_init_clk(mcam);\n\n\t \n\tep = fwnode_graph_get_next_endpoint(of_fwnode_handle(pdev->dev.of_node),\n\t\t\t\t\t    NULL);\n\tif (!ep)\n\t\treturn -ENODEV;\n\n\tv4l2_async_nf_init(&mcam->notifier, &mcam->v4l2_dev);\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&mcam->notifier, ep,\n\t\t\t\t\t      struct v4l2_async_connection);\n\tfwnode_handle_put(ep);\n\tif (IS_ERR(asd)) {\n\t\tret = PTR_ERR(asd);\n\t\tgoto out;\n\t}\n\n\t \n\tret = mccic_register(mcam);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = of_clk_add_provider(pdev->dev.of_node, of_clk_src_simple_get,\n\t\t\t\t\t\t\t\tmcam->mclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't add DT clock provider\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tcam->irq = ret;\n\tret = devm_request_irq(&pdev->dev, cam->irq, mmpcam_irq, IRQF_SHARED,\n\t\t\t\t\t\"mmp-camera\", mcam);\n\tif (ret)\n\t\tgoto out;\n\n\tpm_runtime_enable(&pdev->dev);\n\treturn 0;\nout:\n\tmccic_shutdown(mcam);\n\n\treturn ret;\n}\n\nstatic void mmpcam_remove(struct platform_device *pdev)\n{\n\tstruct mmp_camera *cam = platform_get_drvdata(pdev);\n\tstruct mcam_camera *mcam = &cam->mcam;\n\n\tmccic_shutdown(mcam);\n\tpm_runtime_force_suspend(mcam->dev);\n}\n\n \n\nstatic int __maybe_unused mmpcam_runtime_resume(struct device *dev)\n{\n\tstruct mmp_camera *cam = dev_get_drvdata(dev);\n\tstruct mcam_camera *mcam = &cam->mcam;\n\tunsigned int i;\n\n\tfor (i = 0; i < NR_MCAM_CLK; i++) {\n\t\tif (!IS_ERR(mcam->clk[i]))\n\t\t\tclk_prepare_enable(mcam->clk[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mmpcam_runtime_suspend(struct device *dev)\n{\n\tstruct mmp_camera *cam = dev_get_drvdata(dev);\n\tstruct mcam_camera *mcam = &cam->mcam;\n\tint i;\n\n\tfor (i = NR_MCAM_CLK - 1; i >= 0; i--) {\n\t\tif (!IS_ERR(mcam->clk[i]))\n\t\t\tclk_disable_unprepare(mcam->clk[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mmpcam_suspend(struct device *dev)\n{\n\tstruct mmp_camera *cam = dev_get_drvdata(dev);\n\n\tif (!pm_runtime_suspended(dev))\n\t\tmccic_suspend(&cam->mcam);\n\treturn 0;\n}\n\nstatic int __maybe_unused mmpcam_resume(struct device *dev)\n{\n\tstruct mmp_camera *cam = dev_get_drvdata(dev);\n\n\tif (!pm_runtime_suspended(dev))\n\t\treturn mccic_resume(&cam->mcam);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mmpcam_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mmpcam_runtime_suspend, mmpcam_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(mmpcam_suspend, mmpcam_resume)\n};\n\nstatic const struct of_device_id mmpcam_of_match[] = {\n\t{ .compatible = \"marvell,mmp2-ccic\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mmpcam_of_match);\n\nstatic struct platform_driver mmpcam_driver = {\n\t.probe\t\t= mmpcam_probe,\n\t.remove_new\t= mmpcam_remove,\n\t.driver = {\n\t\t.name\t= \"mmp-camera\",\n\t\t.of_match_table = mmpcam_of_match,\n\t\t.pm = &mmpcam_pm_ops,\n\t}\n};\n\nmodule_platform_driver(mmpcam_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}