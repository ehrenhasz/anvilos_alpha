{
  "module_name": "mcam-core.c",
  "hash_id": "82bb7259f30852b1d038053db47e04ac55f89064586437448a539cdb09ef743b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/marvell/mcam-core.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/vmalloc.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/videodev2.h>\n#include <linux/pm_runtime.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-vmalloc.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-dma-sg.h>\n\n#include \"mcam-core.h\"\n\n#ifdef MCAM_MODE_VMALLOC\n \n\nstatic bool alloc_bufs_at_read;\nmodule_param(alloc_bufs_at_read, bool, 0444);\nMODULE_PARM_DESC(alloc_bufs_at_read,\n\t\t\"Non-zero value causes DMA buffers to be allocated when the video capture device is read, rather than at module load time.  This saves memory, but decreases the chances of successfully getting those buffers.  This parameter is only used in the vmalloc buffer mode\");\n\nstatic int n_dma_bufs = 3;\nmodule_param(n_dma_bufs, uint, 0644);\nMODULE_PARM_DESC(n_dma_bufs,\n\t\t\"The number of DMA buffers to allocate.  Can be either two (saves memory, makes timing tighter) or three.\");\n\nstatic int dma_buf_size = VGA_WIDTH * VGA_HEIGHT * 2;   \nmodule_param(dma_buf_size, uint, 0444);\nMODULE_PARM_DESC(dma_buf_size,\n\t\t\"The size of the allocated DMA buffers.  If actual operating parameters require larger buffers, an attempt to reallocate will be made.\");\n#else  \nstatic const bool alloc_bufs_at_read;\nstatic const int n_dma_bufs = 3;   \n#endif  \n\nstatic bool flip;\nmodule_param(flip, bool, 0444);\nMODULE_PARM_DESC(flip,\n\t\t\"If set, the sensor will be instructed to flip the image vertically.\");\n\nstatic int buffer_mode = -1;\nmodule_param(buffer_mode, int, 0444);\nMODULE_PARM_DESC(buffer_mode,\n\t\t\"Set the buffer mode to be used; default is to go with what the platform driver asks for.  Set to 0 for vmalloc, 1 for DMA contiguous.\");\n\n \n#define CF_BUF0_VALID\t 0\t \n#define CF_BUF1_VALID\t 1\n#define CF_BUF2_VALID\t 2\n#define CF_DMA_ACTIVE\t 3\t \n#define CF_CONFIG_NEEDED 4\t \n#define CF_SINGLE_BUFFER 5\t \n#define CF_SG_RESTART\t 6\t \n#define CF_FRAME_SOF0\t 7\t \n#define CF_FRAME_SOF1\t 8\n#define CF_FRAME_SOF2\t 9\n\n#define sensor_call(cam, o, f, args...) \\\n\tv4l2_subdev_call(cam->sensor, o, f, ##args)\n\n#define notifier_to_mcam(notifier) \\\n\tcontainer_of(notifier, struct mcam_camera, notifier)\n\nstatic struct mcam_format_struct {\n\t__u32 pixelformat;\n\tint bpp;    \n\tbool planar;\n\tu32 mbus_code;\n} mcam_formats[] = {\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUYV,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.bpp\t\t= 2,\n\t\t.planar\t\t= false,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_YVYU,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.bpp\t\t= 2,\n\t\t.planar\t\t= false,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUV420,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.bpp\t\t= 1,\n\t\t.planar\t\t= true,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_YVU420,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.bpp\t\t= 1,\n\t\t.planar\t\t= true,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_XRGB444,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE,\n\t\t.bpp\t\t= 2,\n\t\t.planar\t\t= false,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_RGB565,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB565_2X8_LE,\n\t\t.bpp\t\t= 2,\n\t\t.planar\t\t= false,\n\t},\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.bpp\t\t= 1,\n\t\t.planar\t\t= false,\n\t},\n};\n#define N_MCAM_FMTS ARRAY_SIZE(mcam_formats)\n\nstatic struct mcam_format_struct *mcam_find_format(u32 pixelformat)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < N_MCAM_FMTS; i++)\n\t\tif (mcam_formats[i].pixelformat == pixelformat)\n\t\t\treturn mcam_formats + i;\n\t \n\treturn mcam_formats;\n}\n\n \nstatic const struct v4l2_pix_format mcam_def_pix_format = {\n\t.width\t\t= VGA_WIDTH,\n\t.height\t\t= VGA_HEIGHT,\n\t.pixelformat\t= V4L2_PIX_FMT_YUYV,\n\t.field\t\t= V4L2_FIELD_NONE,\n\t.bytesperline\t= VGA_WIDTH*2,\n\t.sizeimage\t= VGA_WIDTH*VGA_HEIGHT*2,\n\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n};\n\nstatic const u32 mcam_def_mbus_code = MEDIA_BUS_FMT_YUYV8_2X8;\n\n\n \nstruct mcam_dma_desc {\n\tu32 dma_addr;\n\tu32 segment_len;\n};\n\n \nstruct mcam_vb_buffer {\n\tstruct vb2_v4l2_buffer vb_buf;\n\tstruct list_head queue;\n\tstruct mcam_dma_desc *dma_desc;\t \n\tdma_addr_t dma_desc_pa;\t\t \n};\n\nstatic inline struct mcam_vb_buffer *vb_to_mvb(struct vb2_v4l2_buffer *vb)\n{\n\treturn container_of(vb, struct mcam_vb_buffer, vb_buf);\n}\n\n \nstatic void mcam_buffer_done(struct mcam_camera *cam, int frame,\n\t\tstruct vb2_v4l2_buffer *vbuf)\n{\n\tvbuf->vb2_buf.planes[0].bytesused = cam->pix_format.sizeimage;\n\tvbuf->sequence = cam->buf_seq[frame];\n\tvbuf->field = V4L2_FIELD_NONE;\n\tvbuf->vb2_buf.timestamp = ktime_get_ns();\n\tvb2_set_plane_payload(&vbuf->vb2_buf, 0, cam->pix_format.sizeimage);\n\tvb2_buffer_done(&vbuf->vb2_buf, VB2_BUF_STATE_DONE);\n}\n\n\n\n \n#define cam_err(cam, fmt, arg...) \\\n\tdev_err((cam)->dev, fmt, ##arg);\n#define cam_warn(cam, fmt, arg...) \\\n\tdev_warn((cam)->dev, fmt, ##arg);\n#define cam_dbg(cam, fmt, arg...) \\\n\tdev_dbg((cam)->dev, fmt, ##arg);\n\n\n \nstatic void mcam_reset_buffers(struct mcam_camera *cam)\n{\n\tint i;\n\n\tcam->next_buf = -1;\n\tfor (i = 0; i < cam->nbufs; i++) {\n\t\tclear_bit(i, &cam->flags);\n\t\tclear_bit(CF_FRAME_SOF0 + i, &cam->flags);\n\t}\n}\n\nstatic inline int mcam_needs_config(struct mcam_camera *cam)\n{\n\treturn test_bit(CF_CONFIG_NEEDED, &cam->flags);\n}\n\nstatic void mcam_set_config_needed(struct mcam_camera *cam, int needed)\n{\n\tif (needed)\n\t\tset_bit(CF_CONFIG_NEEDED, &cam->flags);\n\telse\n\t\tclear_bit(CF_CONFIG_NEEDED, &cam->flags);\n}\n\n \n \nstatic void mcam_ctlr_start(struct mcam_camera *cam)\n{\n\t \n\tmcam_reg_set_bit(cam, REG_CTRL0, C0_ENABLE);\n}\n\nstatic void mcam_ctlr_stop(struct mcam_camera *cam)\n{\n\tmcam_reg_clear_bit(cam, REG_CTRL0, C0_ENABLE);\n}\n\nstatic void mcam_enable_mipi(struct mcam_camera *mcam)\n{\n\t \n\tif (mcam->calc_dphy)\n\t\tmcam->calc_dphy(mcam);\n\tcam_dbg(mcam, \"camera: DPHY3=0x%x, DPHY5=0x%x, DPHY6=0x%x\\n\",\n\t\t\tmcam->dphy[0], mcam->dphy[1], mcam->dphy[2]);\n\tmcam_reg_write(mcam, REG_CSI2_DPHY3, mcam->dphy[0]);\n\tmcam_reg_write(mcam, REG_CSI2_DPHY5, mcam->dphy[1]);\n\tmcam_reg_write(mcam, REG_CSI2_DPHY6, mcam->dphy[2]);\n\n\tif (!mcam->mipi_enabled) {\n\t\tif (mcam->lane > 4 || mcam->lane <= 0) {\n\t\t\tcam_warn(mcam, \"lane number error\\n\");\n\t\t\tmcam->lane = 1;\t \n\t\t}\n\t\t \n\t\tmcam_reg_write(mcam, REG_CSI2_CTRL0,\n\t\t\tCSI2_C0_MIPI_EN | CSI2_C0_ACT_LANE(mcam->lane));\n\t\tmcam->mipi_enabled = true;\n\t}\n}\n\nstatic void mcam_disable_mipi(struct mcam_camera *mcam)\n{\n\t \n\tmcam_reg_write(mcam, REG_CSI2_CTRL0, 0x0);\n\tmcam_reg_write(mcam, REG_CSI2_DPHY3, 0x0);\n\tmcam_reg_write(mcam, REG_CSI2_DPHY5, 0x0);\n\tmcam_reg_write(mcam, REG_CSI2_DPHY6, 0x0);\n\tmcam->mipi_enabled = false;\n}\n\nstatic bool mcam_fmt_is_planar(__u32 pfmt)\n{\n\tstruct mcam_format_struct *f;\n\n\tf = mcam_find_format(pfmt);\n\treturn f->planar;\n}\n\nstatic void mcam_write_yuv_bases(struct mcam_camera *cam,\n\t\t\t\t unsigned frame, dma_addr_t base)\n{\n\tstruct v4l2_pix_format *fmt = &cam->pix_format;\n\tu32 pixel_count = fmt->width * fmt->height;\n\tdma_addr_t y, u = 0, v = 0;\n\n\ty = base;\n\n\tswitch (fmt->pixelformat) {\n\tcase V4L2_PIX_FMT_YUV420:\n\t\tu = y + pixel_count;\n\t\tv = u + pixel_count / 4;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YVU420:\n\t\tv = y + pixel_count;\n\t\tu = v + pixel_count / 4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmcam_reg_write(cam, REG_Y0BAR + frame * 4, y);\n\tif (mcam_fmt_is_planar(fmt->pixelformat)) {\n\t\tmcam_reg_write(cam, REG_U0BAR + frame * 4, u);\n\t\tmcam_reg_write(cam, REG_V0BAR + frame * 4, v);\n\t}\n}\n\n \n\n#ifdef MCAM_MODE_VMALLOC\n \n\n \nstatic int mcam_alloc_dma_bufs(struct mcam_camera *cam, int loadtime)\n{\n\tint i;\n\n\tmcam_set_config_needed(cam, 1);\n\tif (loadtime)\n\t\tcam->dma_buf_size = dma_buf_size;\n\telse\n\t\tcam->dma_buf_size = cam->pix_format.sizeimage;\n\tif (n_dma_bufs > 3)\n\t\tn_dma_bufs = 3;\n\n\tcam->nbufs = 0;\n\tfor (i = 0; i < n_dma_bufs; i++) {\n\t\tcam->dma_bufs[i] = dma_alloc_coherent(cam->dev,\n\t\t\t\tcam->dma_buf_size, cam->dma_handles + i,\n\t\t\t\tGFP_KERNEL);\n\t\tif (cam->dma_bufs[i] == NULL) {\n\t\t\tcam_warn(cam, \"Failed to allocate DMA buffer\\n\");\n\t\t\tbreak;\n\t\t}\n\t\t(cam->nbufs)++;\n\t}\n\n\tswitch (cam->nbufs) {\n\tcase 1:\n\t\tdma_free_coherent(cam->dev, cam->dma_buf_size,\n\t\t\t\tcam->dma_bufs[0], cam->dma_handles[0]);\n\t\tcam->nbufs = 0;\n\t\tfallthrough;\n\tcase 0:\n\t\tcam_err(cam, \"Insufficient DMA buffers, cannot operate\\n\");\n\t\treturn -ENOMEM;\n\n\tcase 2:\n\t\tif (n_dma_bufs > 2)\n\t\t\tcam_warn(cam, \"Will limp along with only 2 buffers\\n\");\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void mcam_free_dma_bufs(struct mcam_camera *cam)\n{\n\tint i;\n\n\tfor (i = 0; i < cam->nbufs; i++) {\n\t\tdma_free_coherent(cam->dev, cam->dma_buf_size,\n\t\t\t\tcam->dma_bufs[i], cam->dma_handles[i]);\n\t\tcam->dma_bufs[i] = NULL;\n\t}\n\tcam->nbufs = 0;\n}\n\n\n \nstatic void mcam_ctlr_dma_vmalloc(struct mcam_camera *cam)\n{\n\t \n\tmcam_write_yuv_bases(cam, 0, cam->dma_handles[0]);\n\tmcam_write_yuv_bases(cam, 1, cam->dma_handles[1]);\n\tif (cam->nbufs > 2) {\n\t\tmcam_write_yuv_bases(cam, 2, cam->dma_handles[2]);\n\t\tmcam_reg_clear_bit(cam, REG_CTRL1, C1_TWOBUFS);\n\t} else\n\t\tmcam_reg_set_bit(cam, REG_CTRL1, C1_TWOBUFS);\n\tif (cam->chip_id == MCAM_CAFE)\n\t\tmcam_reg_write(cam, REG_UBAR, 0);  \n}\n\n \nstatic void mcam_frame_tasklet(struct tasklet_struct *t)\n{\n\tstruct mcam_camera *cam = from_tasklet(cam, t, s_tasklet);\n\tint i;\n\tunsigned long flags;\n\tstruct mcam_vb_buffer *buf;\n\n\tspin_lock_irqsave(&cam->dev_lock, flags);\n\tfor (i = 0; i < cam->nbufs; i++) {\n\t\tint bufno = cam->next_buf;\n\n\t\tif (cam->state != S_STREAMING || bufno < 0)\n\t\t\tbreak;   \n\t\tif (++(cam->next_buf) >= cam->nbufs)\n\t\t\tcam->next_buf = 0;\n\t\tif (!test_bit(bufno, &cam->flags))\n\t\t\tcontinue;\n\t\tif (list_empty(&cam->buffers)) {\n\t\t\tcam->frame_state.singles++;\n\t\t\tbreak;   \n\t\t}\n\t\tcam->frame_state.delivered++;\n\t\tclear_bit(bufno, &cam->flags);\n\t\tbuf = list_first_entry(&cam->buffers, struct mcam_vb_buffer,\n\t\t\t\tqueue);\n\t\tlist_del_init(&buf->queue);\n\t\t \n\t\tspin_unlock_irqrestore(&cam->dev_lock, flags);\n\t\tmemcpy(vb2_plane_vaddr(&buf->vb_buf.vb2_buf, 0),\n\t\t\t\tcam->dma_bufs[bufno],\n\t\t\t\tcam->pix_format.sizeimage);\n\t\tmcam_buffer_done(cam, bufno, &buf->vb_buf);\n\t\tspin_lock_irqsave(&cam->dev_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&cam->dev_lock, flags);\n}\n\n\n \nstatic int mcam_check_dma_buffers(struct mcam_camera *cam)\n{\n\tif (cam->nbufs > 0 && cam->dma_buf_size < cam->pix_format.sizeimage)\n\t\t\tmcam_free_dma_bufs(cam);\n\tif (cam->nbufs == 0)\n\t\treturn mcam_alloc_dma_bufs(cam, 0);\n\treturn 0;\n}\n\nstatic void mcam_vmalloc_done(struct mcam_camera *cam, int frame)\n{\n\ttasklet_schedule(&cam->s_tasklet);\n}\n\n#else  \n\nstatic inline int mcam_alloc_dma_bufs(struct mcam_camera *cam, int loadtime)\n{\n\treturn 0;\n}\n\nstatic inline void mcam_free_dma_bufs(struct mcam_camera *cam)\n{\n\treturn;\n}\n\nstatic inline int mcam_check_dma_buffers(struct mcam_camera *cam)\n{\n\treturn 0;\n}\n\n\n\n#endif  \n\n\n#ifdef MCAM_MODE_DMA_CONTIG\n \n \n\n \nstatic void mcam_set_contig_buffer(struct mcam_camera *cam, int frame)\n{\n\tstruct mcam_vb_buffer *buf;\n\tdma_addr_t dma_handle;\n\tstruct vb2_v4l2_buffer *vb;\n\n\t \n\tif (list_empty(&cam->buffers)) {\n\t\tbuf = cam->vb_bufs[frame ^ 0x1];\n\t\tset_bit(CF_SINGLE_BUFFER, &cam->flags);\n\t\tcam->frame_state.singles++;\n\t} else {\n\t\t \n\t\tbuf = list_first_entry(&cam->buffers, struct mcam_vb_buffer,\n\t\t\t\t\tqueue);\n\t\tlist_del_init(&buf->queue);\n\t\tclear_bit(CF_SINGLE_BUFFER, &cam->flags);\n\t}\n\n\tcam->vb_bufs[frame] = buf;\n\tvb = &buf->vb_buf;\n\n\tdma_handle = vb2_dma_contig_plane_dma_addr(&vb->vb2_buf, 0);\n\tmcam_write_yuv_bases(cam, frame, dma_handle);\n}\n\n \nstatic void mcam_ctlr_dma_contig(struct mcam_camera *cam)\n{\n\tmcam_reg_set_bit(cam, REG_CTRL1, C1_TWOBUFS);\n\tcam->nbufs = 2;\n\tmcam_set_contig_buffer(cam, 0);\n\tmcam_set_contig_buffer(cam, 1);\n}\n\n \nstatic void mcam_dma_contig_done(struct mcam_camera *cam, int frame)\n{\n\tstruct mcam_vb_buffer *buf = cam->vb_bufs[frame];\n\n\tif (!test_bit(CF_SINGLE_BUFFER, &cam->flags)) {\n\t\tcam->frame_state.delivered++;\n\t\tcam->vb_bufs[frame] = NULL;\n\t\tmcam_buffer_done(cam, frame, &buf->vb_buf);\n\t}\n\tmcam_set_contig_buffer(cam, frame);\n}\n\n#endif  \n\n#ifdef MCAM_MODE_DMA_SG\n \n \n\n \nstatic void mcam_sg_next_buffer(struct mcam_camera *cam)\n{\n\tstruct mcam_vb_buffer *buf;\n\tstruct sg_table *sg_table;\n\n\tbuf = list_first_entry(&cam->buffers, struct mcam_vb_buffer, queue);\n\tlist_del_init(&buf->queue);\n\tsg_table = vb2_dma_sg_plane_desc(&buf->vb_buf.vb2_buf, 0);\n\t \n\tmcam_reg_clear_bit(cam, REG_CTRL1, C1_DESC_ENA);\n\tmcam_reg_write(cam, REG_DMA_DESC_Y, buf->dma_desc_pa);\n\tmcam_reg_write(cam, REG_DESC_LEN_Y,\n\t\t\tsg_table->nents * sizeof(struct mcam_dma_desc));\n\tmcam_reg_write(cam, REG_DESC_LEN_U, 0);\n\tmcam_reg_write(cam, REG_DESC_LEN_V, 0);\n\tmcam_reg_set_bit(cam, REG_CTRL1, C1_DESC_ENA);\n\tcam->vb_bufs[0] = buf;\n}\n\n \nstatic void mcam_ctlr_dma_sg(struct mcam_camera *cam)\n{\n\t \n\tif (list_empty(&cam->buffers)) {\n\t\tset_bit(CF_SG_RESTART, &cam->flags);\n\t\treturn;\n\t}\n\n\tmcam_reg_clear_bit(cam, REG_CTRL1, C1_DESC_3WORD);\n\tmcam_sg_next_buffer(cam);\n\tcam->nbufs = 3;\n}\n\n\n \nstatic void mcam_dma_sg_done(struct mcam_camera *cam, int frame)\n{\n\tstruct mcam_vb_buffer *buf = cam->vb_bufs[0];\n\n\t \n\tif (cam->state != S_STREAMING)\n\t\treturn;\n\t \n\tif (!list_empty(&cam->buffers)) {\n\t\tmcam_sg_next_buffer(cam);\n\t\tmcam_ctlr_start(cam);\n\t \n\t} else {\n\t\tset_bit(CF_SG_RESTART, &cam->flags);\n\t\tcam->frame_state.singles++;\n\t\tcam->vb_bufs[0] = NULL;\n\t}\n\t \n\tcam->frame_state.delivered++;\n\tmcam_buffer_done(cam, frame, &buf->vb_buf);\n}\n\n\n \nstatic void mcam_sg_restart(struct mcam_camera *cam)\n{\n\tmcam_ctlr_dma_sg(cam);\n\tmcam_ctlr_start(cam);\n\tclear_bit(CF_SG_RESTART, &cam->flags);\n}\n\n#else  \n\nstatic inline void mcam_sg_restart(struct mcam_camera *cam)\n{\n\treturn;\n}\n\n#endif  \n\n \n \n\n \nstatic void mcam_ctlr_image(struct mcam_camera *cam)\n{\n\tstruct v4l2_pix_format *fmt = &cam->pix_format;\n\tu32 widthy = 0, widthuv = 0, imgsz_h, imgsz_w;\n\n\tcam_dbg(cam, \"camera: bytesperline = %d; height = %d\\n\",\n\t\tfmt->bytesperline, fmt->sizeimage / fmt->bytesperline);\n\timgsz_h = (fmt->height << IMGSZ_V_SHIFT) & IMGSZ_V_MASK;\n\timgsz_w = (fmt->width * 2) & IMGSZ_H_MASK;\n\n\tswitch (fmt->pixelformat) {\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_YVYU:\n\t\twidthy = fmt->width * 2;\n\t\twidthuv = 0;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\t\twidthy = fmt->width;\n\t\twidthuv = fmt->width / 2;\n\t\tbreak;\n\tdefault:\n\t\twidthy = fmt->bytesperline;\n\t\twidthuv = 0;\n\t\tbreak;\n\t}\n\n\tmcam_reg_write_mask(cam, REG_IMGPITCH, widthuv << 16 | widthy,\n\t\t\tIMGP_YP_MASK | IMGP_UVP_MASK);\n\tmcam_reg_write(cam, REG_IMGSIZE, imgsz_h | imgsz_w);\n\tmcam_reg_write(cam, REG_IMGOFFSET, 0x0);\n\n\t \n\tswitch (fmt->pixelformat) {\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\t\tmcam_reg_write_mask(cam, REG_CTRL0,\n\t\t\tC0_DF_YUV | C0_YUV_420PL | C0_YUVE_VYUY, C0_DF_MASK);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\t\tmcam_reg_write_mask(cam, REG_CTRL0,\n\t\t\tC0_DF_YUV | C0_YUV_PACKED | C0_YUVE_NOSWAP, C0_DF_MASK);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YVYU:\n\t\tmcam_reg_write_mask(cam, REG_CTRL0,\n\t\t\tC0_DF_YUV | C0_YUV_PACKED | C0_YUVE_SWAP24, C0_DF_MASK);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_XRGB444:\n\t\tmcam_reg_write_mask(cam, REG_CTRL0,\n\t\t\tC0_DF_RGB | C0_RGBF_444 | C0_RGB4_XBGR, C0_DF_MASK);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565:\n\t\tmcam_reg_write_mask(cam, REG_CTRL0,\n\t\t\tC0_DF_RGB | C0_RGBF_565 | C0_RGB5_BGGR, C0_DF_MASK);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_SBGGR8:\n\t\tmcam_reg_write_mask(cam, REG_CTRL0,\n\t\t\tC0_DF_RGB | C0_RGB5_GRBG, C0_DF_MASK);\n\t\tbreak;\n\tdefault:\n\t\tcam_err(cam, \"camera: unknown format: %#x\\n\", fmt->pixelformat);\n\t\tbreak;\n\t}\n\n\t \n\tmcam_reg_write_mask(cam, REG_CTRL0, C0_SIF_HVSYNC, C0_SIFM_MASK);\n}\n\n\n \nstatic int mcam_ctlr_configure(struct mcam_camera *cam)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cam->dev_lock, flags);\n\tclear_bit(CF_SG_RESTART, &cam->flags);\n\tcam->dma_setup(cam);\n\tmcam_ctlr_image(cam);\n\tmcam_set_config_needed(cam, 0);\n\tspin_unlock_irqrestore(&cam->dev_lock, flags);\n\treturn 0;\n}\n\nstatic void mcam_ctlr_irq_enable(struct mcam_camera *cam)\n{\n\t \n\tmcam_reg_write(cam, REG_IRQSTAT, FRAMEIRQS);\n\tmcam_reg_set_bit(cam, REG_IRQMASK, FRAMEIRQS);\n}\n\nstatic void mcam_ctlr_irq_disable(struct mcam_camera *cam)\n{\n\tmcam_reg_clear_bit(cam, REG_IRQMASK, FRAMEIRQS);\n}\n\n \nstatic void mcam_ctlr_stop_dma(struct mcam_camera *cam)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&cam->dev_lock, flags);\n\tclear_bit(CF_SG_RESTART, &cam->flags);\n\tmcam_ctlr_stop(cam);\n\tcam->state = S_IDLE;\n\tspin_unlock_irqrestore(&cam->dev_lock, flags);\n\t \n\tmsleep(150);\n\tif (test_bit(CF_DMA_ACTIVE, &cam->flags))\n\t\tcam_err(cam, \"Timeout waiting for DMA to end\\n\");\n\t\t \n\tspin_lock_irqsave(&cam->dev_lock, flags);\n\tmcam_ctlr_irq_disable(cam);\n\tspin_unlock_irqrestore(&cam->dev_lock, flags);\n}\n\n \nstatic int mcam_ctlr_power_up(struct mcam_camera *cam)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cam->dev_lock, flags);\n\tif (cam->plat_power_up) {\n\t\tret = cam->plat_power_up(cam);\n\t\tif (ret) {\n\t\t\tspin_unlock_irqrestore(&cam->dev_lock, flags);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmcam_reg_clear_bit(cam, REG_CTRL1, C1_PWRDWN);\n\tspin_unlock_irqrestore(&cam->dev_lock, flags);\n\treturn 0;\n}\n\nstatic void mcam_ctlr_power_down(struct mcam_camera *cam)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cam->dev_lock, flags);\n\t \n\tmcam_reg_set_bit(cam, REG_CTRL1, C1_PWRDWN);\n\tif (cam->plat_power_down)\n\t\tcam->plat_power_down(cam);\n\tspin_unlock_irqrestore(&cam->dev_lock, flags);\n}\n\n \n \nstatic int mclk_prepare(struct clk_hw *hw)\n{\n\tstruct mcam_camera *cam = container_of(hw, struct mcam_camera, mclk_hw);\n\n\tclk_prepare(cam->clk[0]);\n\treturn 0;\n}\n\nstatic void mclk_unprepare(struct clk_hw *hw)\n{\n\tstruct mcam_camera *cam = container_of(hw, struct mcam_camera, mclk_hw);\n\n\tclk_unprepare(cam->clk[0]);\n}\n\nstatic int mclk_enable(struct clk_hw *hw)\n{\n\tstruct mcam_camera *cam = container_of(hw, struct mcam_camera, mclk_hw);\n\tint mclk_src;\n\tint mclk_div;\n\tint ret;\n\n\t \n\tif (cam->bus_type == V4L2_MBUS_CSI2_DPHY) {\n\t\tmclk_src = cam->mclk_src;\n\t\tmclk_div = cam->mclk_div;\n\t} else {\n\t\tmclk_src = 3;\n\t\tmclk_div = 2;\n\t}\n\n\tret = pm_runtime_resume_and_get(cam->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tclk_enable(cam->clk[0]);\n\tmcam_reg_write(cam, REG_CLKCTRL, (mclk_src << 29) | mclk_div);\n\tmcam_ctlr_power_up(cam);\n\n\treturn 0;\n}\n\nstatic void mclk_disable(struct clk_hw *hw)\n{\n\tstruct mcam_camera *cam = container_of(hw, struct mcam_camera, mclk_hw);\n\n\tmcam_ctlr_power_down(cam);\n\tclk_disable(cam->clk[0]);\n\tpm_runtime_put(cam->dev);\n}\n\nstatic unsigned long mclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\tunsigned long parent_rate)\n{\n\treturn 48000000;\n}\n\nstatic const struct clk_ops mclk_ops = {\n\t.prepare = mclk_prepare,\n\t.unprepare = mclk_unprepare,\n\t.enable = mclk_enable,\n\t.disable = mclk_disable,\n\t.recalc_rate = mclk_recalc_rate,\n};\n\n \n \n\nstatic int __mcam_cam_reset(struct mcam_camera *cam)\n{\n\treturn sensor_call(cam, core, reset, 0);\n}\n\n \nstatic int mcam_cam_init(struct mcam_camera *cam)\n{\n\tint ret;\n\n\tif (cam->state != S_NOTREADY)\n\t\tcam_warn(cam, \"Cam init with device in funky state %d\",\n\t\t\t\tcam->state);\n\tret = __mcam_cam_reset(cam);\n\t \n\tcam->state = S_IDLE;\n\treturn ret;\n}\n\n \nstatic int mcam_cam_set_flip(struct mcam_camera *cam)\n{\n\tstruct v4l2_control ctrl;\n\n\tmemset(&ctrl, 0, sizeof(ctrl));\n\tctrl.id = V4L2_CID_VFLIP;\n\tctrl.value = flip;\n\treturn v4l2_s_ctrl(NULL, cam->sensor->ctrl_handler, &ctrl);\n}\n\n\nstatic int mcam_cam_configure(struct mcam_camera *cam)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tv4l2_fill_mbus_format(&format.format, &cam->pix_format, cam->mbus_code);\n\tret = sensor_call(cam, core, init, 0);\n\tif (ret == 0)\n\t\tret = sensor_call(cam, pad, set_fmt, NULL, &format);\n\t \n\tret += mcam_cam_set_flip(cam);\n\treturn ret;\n}\n\n \nstatic int mcam_read_setup(struct mcam_camera *cam)\n{\n\tint ret;\n\tunsigned long flags;\n\n\t \n\tif (cam->buffer_mode == B_vmalloc && cam->nbufs == 0 &&\n\t\t\tmcam_alloc_dma_bufs(cam, 0))\n\t\treturn -ENOMEM;\n\n\tif (mcam_needs_config(cam)) {\n\t\tmcam_cam_configure(cam);\n\t\tret = mcam_ctlr_configure(cam);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tspin_lock_irqsave(&cam->dev_lock, flags);\n\tclear_bit(CF_DMA_ACTIVE, &cam->flags);\n\tmcam_reset_buffers(cam);\n\tif (cam->bus_type == V4L2_MBUS_CSI2_DPHY)\n\t\tmcam_enable_mipi(cam);\n\telse\n\t\tmcam_disable_mipi(cam);\n\tmcam_ctlr_irq_enable(cam);\n\tcam->state = S_STREAMING;\n\tif (!test_bit(CF_SG_RESTART, &cam->flags))\n\t\tmcam_ctlr_start(cam);\n\tspin_unlock_irqrestore(&cam->dev_lock, flags);\n\treturn 0;\n}\n\n \n \n\nstatic int mcam_vb_queue_setup(struct vb2_queue *vq,\n\t\tunsigned int *nbufs,\n\t\tunsigned int *num_planes, unsigned int sizes[],\n\t\tstruct device *alloc_devs[])\n{\n\tstruct mcam_camera *cam = vb2_get_drv_priv(vq);\n\tint minbufs = (cam->buffer_mode == B_DMA_contig) ? 3 : 2;\n\tunsigned size = cam->pix_format.sizeimage;\n\n\tif (*nbufs < minbufs)\n\t\t*nbufs = minbufs;\n\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\tsizes[0] = size;\n\t*num_planes = 1;  \n\treturn 0;\n}\n\n\nstatic void mcam_vb_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct mcam_vb_buffer *mvb = vb_to_mvb(vbuf);\n\tstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long flags;\n\tint start;\n\n\tspin_lock_irqsave(&cam->dev_lock, flags);\n\tstart = (cam->state == S_BUFWAIT) && !list_empty(&cam->buffers);\n\tlist_add(&mvb->queue, &cam->buffers);\n\tif (cam->state == S_STREAMING && test_bit(CF_SG_RESTART, &cam->flags))\n\t\tmcam_sg_restart(cam);\n\tspin_unlock_irqrestore(&cam->dev_lock, flags);\n\tif (start)\n\t\tmcam_read_setup(cam);\n}\n\nstatic void mcam_vb_requeue_bufs(struct vb2_queue *vq,\n\t\t\t\t enum vb2_buffer_state state)\n{\n\tstruct mcam_camera *cam = vb2_get_drv_priv(vq);\n\tstruct mcam_vb_buffer *buf, *node;\n\tunsigned long flags;\n\tunsigned i;\n\n\tspin_lock_irqsave(&cam->dev_lock, flags);\n\tlist_for_each_entry_safe(buf, node, &cam->buffers, queue) {\n\t\tvb2_buffer_done(&buf->vb_buf.vb2_buf, state);\n\t\tlist_del(&buf->queue);\n\t}\n\tfor (i = 0; i < MAX_DMA_BUFS; i++) {\n\t\tbuf = cam->vb_bufs[i];\n\n\t\tif (buf) {\n\t\t\tvb2_buffer_done(&buf->vb_buf.vb2_buf, state);\n\t\t\tcam->vb_bufs[i] = NULL;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cam->dev_lock, flags);\n}\n\n \nstatic int mcam_vb_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct mcam_camera *cam = vb2_get_drv_priv(vq);\n\tunsigned int frame;\n\tint ret;\n\n\tif (cam->state != S_IDLE) {\n\t\tmcam_vb_requeue_bufs(vq, VB2_BUF_STATE_QUEUED);\n\t\treturn -EINVAL;\n\t}\n\tcam->frame_state.frames = 0;\n\tcam->frame_state.singles = 0;\n\tcam->frame_state.delivered = 0;\n\tcam->sequence = 0;\n\t \n\tif (cam->buffer_mode != B_vmalloc && list_empty(&cam->buffers)) {\n\t\tcam->state = S_BUFWAIT;\n\t\treturn 0;\n\t}\n\n\t \n\tfor (frame = 0; frame < cam->nbufs; frame++)\n\t\tclear_bit(CF_FRAME_SOF0 + frame, &cam->flags);\n\n\tret = mcam_read_setup(cam);\n\tif (ret)\n\t\tmcam_vb_requeue_bufs(vq, VB2_BUF_STATE_QUEUED);\n\treturn ret;\n}\n\nstatic void mcam_vb_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct mcam_camera *cam = vb2_get_drv_priv(vq);\n\n\tcam_dbg(cam, \"stop_streaming: %d frames, %d singles, %d delivered\\n\",\n\t\t\tcam->frame_state.frames, cam->frame_state.singles,\n\t\t\tcam->frame_state.delivered);\n\tif (cam->state == S_BUFWAIT) {\n\t\t \n\t\tcam->state = S_IDLE;\n\t\treturn;\n\t}\n\tif (cam->state != S_STREAMING)\n\t\treturn;\n\tmcam_ctlr_stop_dma(cam);\n\t \n\tmcam_vb_requeue_bufs(vq, VB2_BUF_STATE_ERROR);\n}\n\n\nstatic const struct vb2_ops mcam_vb2_ops = {\n\t.queue_setup\t\t= mcam_vb_queue_setup,\n\t.buf_queue\t\t= mcam_vb_buf_queue,\n\t.start_streaming\t= mcam_vb_start_streaming,\n\t.stop_streaming\t\t= mcam_vb_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n\n#ifdef MCAM_MODE_DMA_SG\n \nstatic int mcam_vb_sg_buf_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct mcam_vb_buffer *mvb = vb_to_mvb(vbuf);\n\tstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\n\tint ndesc = cam->pix_format.sizeimage/PAGE_SIZE + 1;\n\n\tmvb->dma_desc = dma_alloc_coherent(cam->dev,\n\t\t\tndesc * sizeof(struct mcam_dma_desc),\n\t\t\t&mvb->dma_desc_pa, GFP_KERNEL);\n\tif (mvb->dma_desc == NULL) {\n\t\tcam_err(cam, \"Unable to get DMA descriptor array\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int mcam_vb_sg_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct mcam_vb_buffer *mvb = vb_to_mvb(vbuf);\n\tstruct sg_table *sg_table = vb2_dma_sg_plane_desc(vb, 0);\n\tstruct mcam_dma_desc *desc = mvb->dma_desc;\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sg_table->sgl, sg, sg_table->nents, i) {\n\t\tdesc->dma_addr = sg_dma_address(sg);\n\t\tdesc->segment_len = sg_dma_len(sg);\n\t\tdesc++;\n\t}\n\treturn 0;\n}\n\nstatic void mcam_vb_sg_buf_cleanup(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct mcam_vb_buffer *mvb = vb_to_mvb(vbuf);\n\tint ndesc = cam->pix_format.sizeimage/PAGE_SIZE + 1;\n\n\tdma_free_coherent(cam->dev, ndesc * sizeof(struct mcam_dma_desc),\n\t\t\tmvb->dma_desc, mvb->dma_desc_pa);\n}\n\n\nstatic const struct vb2_ops mcam_vb2_sg_ops = {\n\t.queue_setup\t\t= mcam_vb_queue_setup,\n\t.buf_init\t\t= mcam_vb_sg_buf_init,\n\t.buf_prepare\t\t= mcam_vb_sg_buf_prepare,\n\t.buf_queue\t\t= mcam_vb_buf_queue,\n\t.buf_cleanup\t\t= mcam_vb_sg_buf_cleanup,\n\t.start_streaming\t= mcam_vb_start_streaming,\n\t.stop_streaming\t\t= mcam_vb_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n#endif  \n\nstatic int mcam_setup_vb2(struct mcam_camera *cam)\n{\n\tstruct vb2_queue *vq = &cam->vb_queue;\n\n\tmemset(vq, 0, sizeof(*vq));\n\tvq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tvq->drv_priv = cam;\n\tvq->lock = &cam->s_mutex;\n\tvq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tvq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\n\tvq->buf_struct_size = sizeof(struct mcam_vb_buffer);\n\tvq->dev = cam->dev;\n\tINIT_LIST_HEAD(&cam->buffers);\n\tswitch (cam->buffer_mode) {\n\tcase B_DMA_contig:\n#ifdef MCAM_MODE_DMA_CONTIG\n\t\tvq->ops = &mcam_vb2_ops;\n\t\tvq->mem_ops = &vb2_dma_contig_memops;\n\t\tcam->dma_setup = mcam_ctlr_dma_contig;\n\t\tcam->frame_complete = mcam_dma_contig_done;\n#endif\n\t\tbreak;\n\tcase B_DMA_sg:\n#ifdef MCAM_MODE_DMA_SG\n\t\tvq->ops = &mcam_vb2_sg_ops;\n\t\tvq->mem_ops = &vb2_dma_sg_memops;\n\t\tcam->dma_setup = mcam_ctlr_dma_sg;\n\t\tcam->frame_complete = mcam_dma_sg_done;\n#endif\n\t\tbreak;\n\tcase B_vmalloc:\n#ifdef MCAM_MODE_VMALLOC\n\t\ttasklet_setup(&cam->s_tasklet, mcam_frame_tasklet);\n\t\tvq->ops = &mcam_vb2_ops;\n\t\tvq->mem_ops = &vb2_vmalloc_memops;\n\t\tcam->dma_setup = mcam_ctlr_dma_vmalloc;\n\t\tcam->frame_complete = mcam_vmalloc_done;\n#endif\n\t\tbreak;\n\t}\n\treturn vb2_queue_init(vq);\n}\n\n\n \n \n\nstatic int mcam_vidioc_querycap(struct file *file, void *priv,\n\t\tstruct v4l2_capability *cap)\n{\n\tstruct mcam_camera *cam = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"marvell_ccic\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"marvell_ccic\", sizeof(cap->card));\n\tstrscpy(cap->bus_info, cam->bus_info, sizeof(cap->bus_info));\n\treturn 0;\n}\n\n\nstatic int mcam_vidioc_enum_fmt_vid_cap(struct file *filp,\n\t\tvoid *priv, struct v4l2_fmtdesc *fmt)\n{\n\tif (fmt->index >= N_MCAM_FMTS)\n\t\treturn -EINVAL;\n\tfmt->pixelformat = mcam_formats[fmt->index].pixelformat;\n\treturn 0;\n}\n\nstatic int mcam_vidioc_try_fmt_vid_cap(struct file *filp, void *priv,\n\t\tstruct v4l2_format *fmt)\n{\n\tstruct mcam_camera *cam = video_drvdata(filp);\n\tstruct mcam_format_struct *f;\n\tstruct v4l2_pix_format *pix = &fmt->fmt.pix;\n\tstruct v4l2_subdev_pad_config pad_cfg;\n\tstruct v4l2_subdev_state pad_state = {\n\t\t.pads = &pad_cfg,\n\t};\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tint ret;\n\n\tf = mcam_find_format(pix->pixelformat);\n\tpix->pixelformat = f->pixelformat;\n\tv4l2_fill_mbus_format(&format.format, pix, f->mbus_code);\n\tret = sensor_call(cam, pad, set_fmt, &pad_state, &format);\n\tv4l2_fill_pix_format(pix, &format.format);\n\tpix->bytesperline = pix->width * f->bpp;\n\tswitch (f->pixelformat) {\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\t\tpix->sizeimage = pix->height * pix->bytesperline * 3 / 2;\n\t\tbreak;\n\tdefault:\n\t\tpix->sizeimage = pix->height * pix->bytesperline;\n\t\tbreak;\n\t}\n\tpix->colorspace = V4L2_COLORSPACE_SRGB;\n\treturn ret;\n}\n\nstatic int mcam_vidioc_s_fmt_vid_cap(struct file *filp, void *priv,\n\t\tstruct v4l2_format *fmt)\n{\n\tstruct mcam_camera *cam = video_drvdata(filp);\n\tstruct mcam_format_struct *f;\n\tint ret;\n\n\t \n\tif (cam->state != S_IDLE || vb2_is_busy(&cam->vb_queue))\n\t\treturn -EBUSY;\n\n\tf = mcam_find_format(fmt->fmt.pix.pixelformat);\n\n\t \n\tret = mcam_vidioc_try_fmt_vid_cap(filp, priv, fmt);\n\tif (ret)\n\t\treturn ret;\n\t \n\tcam->pix_format = fmt->fmt.pix;\n\tcam->mbus_code = f->mbus_code;\n\n\t \n\tif (cam->buffer_mode == B_vmalloc) {\n\t\tret = mcam_check_dma_buffers(cam);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tmcam_set_config_needed(cam, 1);\nout:\n\treturn ret;\n}\n\n \nstatic int mcam_vidioc_g_fmt_vid_cap(struct file *filp, void *priv,\n\t\tstruct v4l2_format *f)\n{\n\tstruct mcam_camera *cam = video_drvdata(filp);\n\n\tf->fmt.pix = cam->pix_format;\n\treturn 0;\n}\n\n \nstatic int mcam_vidioc_enum_input(struct file *filp, void *priv,\n\t\tstruct v4l2_input *input)\n{\n\tif (input->index != 0)\n\t\treturn -EINVAL;\n\n\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\tstrscpy(input->name, \"Camera\", sizeof(input->name));\n\treturn 0;\n}\n\nstatic int mcam_vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int mcam_vidioc_s_input(struct file *filp, void *priv, unsigned int i)\n{\n\tif (i != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int mcam_vidioc_g_parm(struct file *filp, void *priv,\n\t\tstruct v4l2_streamparm *a)\n{\n\tstruct mcam_camera *cam = video_drvdata(filp);\n\tint ret;\n\n\tret = v4l2_g_parm_cap(video_devdata(filp), cam->sensor, a);\n\ta->parm.capture.readbuffers = n_dma_bufs;\n\treturn ret;\n}\n\nstatic int mcam_vidioc_s_parm(struct file *filp, void *priv,\n\t\tstruct v4l2_streamparm *a)\n{\n\tstruct mcam_camera *cam = video_drvdata(filp);\n\tint ret;\n\n\tret = v4l2_s_parm_cap(video_devdata(filp), cam->sensor, a);\n\ta->parm.capture.readbuffers = n_dma_bufs;\n\treturn ret;\n}\n\nstatic int mcam_vidioc_enum_framesizes(struct file *filp, void *priv,\n\t\tstruct v4l2_frmsizeenum *sizes)\n{\n\tstruct mcam_camera *cam = video_drvdata(filp);\n\tstruct mcam_format_struct *f;\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.index = sizes->index,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tf = mcam_find_format(sizes->pixel_format);\n\tif (f->pixelformat != sizes->pixel_format)\n\t\treturn -EINVAL;\n\tfse.code = f->mbus_code;\n\tret = sensor_call(cam, pad, enum_frame_size, NULL, &fse);\n\tif (ret)\n\t\treturn ret;\n\tif (fse.min_width == fse.max_width &&\n\t    fse.min_height == fse.max_height) {\n\t\tsizes->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\t\tsizes->discrete.width = fse.min_width;\n\t\tsizes->discrete.height = fse.min_height;\n\t\treturn 0;\n\t}\n\tsizes->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\tsizes->stepwise.min_width = fse.min_width;\n\tsizes->stepwise.max_width = fse.max_width;\n\tsizes->stepwise.min_height = fse.min_height;\n\tsizes->stepwise.max_height = fse.max_height;\n\tsizes->stepwise.step_width = 1;\n\tsizes->stepwise.step_height = 1;\n\treturn 0;\n}\n\nstatic int mcam_vidioc_enum_frameintervals(struct file *filp, void *priv,\n\t\tstruct v4l2_frmivalenum *interval)\n{\n\tstruct mcam_camera *cam = video_drvdata(filp);\n\tstruct mcam_format_struct *f;\n\tstruct v4l2_subdev_frame_interval_enum fie = {\n\t\t.index = interval->index,\n\t\t.width = interval->width,\n\t\t.height = interval->height,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tf = mcam_find_format(interval->pixel_format);\n\tif (f->pixelformat != interval->pixel_format)\n\t\treturn -EINVAL;\n\tfie.code = f->mbus_code;\n\tret = sensor_call(cam, pad, enum_frame_interval, NULL, &fie);\n\tif (ret)\n\t\treturn ret;\n\tinterval->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tinterval->discrete = fie.interval;\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int mcam_vidioc_g_register(struct file *file, void *priv,\n\t\tstruct v4l2_dbg_register *reg)\n{\n\tstruct mcam_camera *cam = video_drvdata(file);\n\n\tif (reg->reg > cam->regs_size - 4)\n\t\treturn -EINVAL;\n\treg->val = mcam_reg_read(cam, reg->reg);\n\treg->size = 4;\n\treturn 0;\n}\n\nstatic int mcam_vidioc_s_register(struct file *file, void *priv,\n\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct mcam_camera *cam = video_drvdata(file);\n\n\tif (reg->reg > cam->regs_size - 4)\n\t\treturn -EINVAL;\n\tmcam_reg_write(cam, reg->reg, reg->val);\n\treturn 0;\n}\n#endif\n\nstatic const struct v4l2_ioctl_ops mcam_v4l_ioctl_ops = {\n\t.vidioc_querycap\t= mcam_vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap = mcam_vidioc_enum_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t= mcam_vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t= mcam_vidioc_s_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t= mcam_vidioc_g_fmt_vid_cap,\n\t.vidioc_enum_input\t= mcam_vidioc_enum_input,\n\t.vidioc_g_input\t\t= mcam_vidioc_g_input,\n\t.vidioc_s_input\t\t= mcam_vidioc_s_input,\n\t.vidioc_reqbufs\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t= vb2_ioctl_streamoff,\n\t.vidioc_g_parm\t\t= mcam_vidioc_g_parm,\n\t.vidioc_s_parm\t\t= mcam_vidioc_s_parm,\n\t.vidioc_enum_framesizes = mcam_vidioc_enum_framesizes,\n\t.vidioc_enum_frameintervals = mcam_vidioc_enum_frameintervals,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register\t= mcam_vidioc_g_register,\n\t.vidioc_s_register\t= mcam_vidioc_s_register,\n#endif\n};\n\n \n \nstatic int mcam_v4l_open(struct file *filp)\n{\n\tstruct mcam_camera *cam = video_drvdata(filp);\n\tint ret;\n\n\tmutex_lock(&cam->s_mutex);\n\tret = v4l2_fh_open(filp);\n\tif (ret)\n\t\tgoto out;\n\tif (v4l2_fh_is_singular_file(filp)) {\n\t\tret = sensor_call(cam, core, s_power, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = pm_runtime_resume_and_get(cam->dev);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t__mcam_cam_reset(cam);\n\t\tmcam_set_config_needed(cam, 1);\n\t}\nout:\n\tmutex_unlock(&cam->s_mutex);\n\tif (ret)\n\t\tv4l2_fh_release(filp);\n\treturn ret;\n}\n\n\nstatic int mcam_v4l_release(struct file *filp)\n{\n\tstruct mcam_camera *cam = video_drvdata(filp);\n\tbool last_open;\n\n\tmutex_lock(&cam->s_mutex);\n\tlast_open = v4l2_fh_is_singular_file(filp);\n\t_vb2_fop_release(filp, NULL);\n\tif (last_open) {\n\t\tmcam_disable_mipi(cam);\n\t\tsensor_call(cam, core, s_power, 0);\n\t\tpm_runtime_put(cam->dev);\n\t\tif (cam->buffer_mode == B_vmalloc && alloc_bufs_at_read)\n\t\t\tmcam_free_dma_bufs(cam);\n\t}\n\n\tmutex_unlock(&cam->s_mutex);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations mcam_v4l_fops = {\n\t.owner = THIS_MODULE,\n\t.open = mcam_v4l_open,\n\t.release = mcam_v4l_release,\n\t.read = vb2_fop_read,\n\t.poll = vb2_fop_poll,\n\t.mmap = vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\n\n \nstatic const struct video_device mcam_v4l_template = {\n\t.name = \"mcam\",\n\t.fops = &mcam_v4l_fops,\n\t.ioctl_ops = &mcam_v4l_ioctl_ops,\n\t.release = video_device_release_empty,\n\t.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t       V4L2_CAP_STREAMING,\n};\n\n \n \nstatic void mcam_frame_complete(struct mcam_camera *cam, int frame)\n{\n\t \n\tset_bit(frame, &cam->flags);\n\tclear_bit(CF_DMA_ACTIVE, &cam->flags);\n\tcam->next_buf = frame;\n\tcam->buf_seq[frame] = cam->sequence++;\n\tcam->frame_state.frames++;\n\t \n\tif (cam->state != S_STREAMING)\n\t\treturn;\n\t \n\tcam->frame_complete(cam, frame);\n}\n\n\n \nint mccic_irq(struct mcam_camera *cam, unsigned int irqs)\n{\n\tunsigned int frame, handled = 0;\n\n\tmcam_reg_write(cam, REG_IRQSTAT, FRAMEIRQS);  \n\t \n\tfor (frame = 0; frame < cam->nbufs; frame++)\n\t\tif (irqs & (IRQ_EOF0 << frame) &&\n\t\t\ttest_bit(CF_FRAME_SOF0 + frame, &cam->flags)) {\n\t\t\tmcam_frame_complete(cam, frame);\n\t\t\thandled = 1;\n\t\t\tclear_bit(CF_FRAME_SOF0 + frame, &cam->flags);\n\t\t\tif (cam->buffer_mode == B_DMA_sg)\n\t\t\t\tbreak;\n\t\t}\n\t \n\tfor (frame = 0; frame < cam->nbufs; frame++) {\n\t\tif (irqs & (IRQ_SOF0 << frame)) {\n\t\t\tset_bit(CF_FRAME_SOF0 + frame, &cam->flags);\n\t\t\thandled = IRQ_HANDLED;\n\t\t}\n\t}\n\n\tif (handled == IRQ_HANDLED) {\n\t\tset_bit(CF_DMA_ACTIVE, &cam->flags);\n\t\tif (cam->buffer_mode == B_DMA_sg)\n\t\t\tmcam_ctlr_stop(cam);\n\t}\n\treturn handled;\n}\nEXPORT_SYMBOL_GPL(mccic_irq);\n\n \n \n\nstatic int mccic_notify_bound(struct v4l2_async_notifier *notifier,\n\tstruct v4l2_subdev *subdev, struct v4l2_async_connection *asd)\n{\n\tstruct mcam_camera *cam = notifier_to_mcam(notifier);\n\tint ret;\n\n\tmutex_lock(&cam->s_mutex);\n\tif (cam->sensor) {\n\t\tcam_err(cam, \"sensor already bound\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tv4l2_set_subdev_hostdata(subdev, cam);\n\tcam->sensor = subdev;\n\n\tret = mcam_cam_init(cam);\n\tif (ret) {\n\t\tcam->sensor = NULL;\n\t\tgoto out;\n\t}\n\n\tret = mcam_setup_vb2(cam);\n\tif (ret) {\n\t\tcam->sensor = NULL;\n\t\tgoto out;\n\t}\n\n\tcam->vdev = mcam_v4l_template;\n\tcam->vdev.v4l2_dev = &cam->v4l2_dev;\n\tcam->vdev.lock = &cam->s_mutex;\n\tcam->vdev.queue = &cam->vb_queue;\n\tvideo_set_drvdata(&cam->vdev, cam);\n\tret = video_register_device(&cam->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tcam->sensor = NULL;\n\t\tgoto out;\n\t}\n\n\tcam_dbg(cam, \"sensor %s bound\\n\", subdev->name);\nout:\n\tmutex_unlock(&cam->s_mutex);\n\treturn ret;\n}\n\nstatic void mccic_notify_unbind(struct v4l2_async_notifier *notifier,\n\tstruct v4l2_subdev *subdev, struct v4l2_async_connection *asd)\n{\n\tstruct mcam_camera *cam = notifier_to_mcam(notifier);\n\n\tmutex_lock(&cam->s_mutex);\n\tif (cam->sensor != subdev) {\n\t\tcam_err(cam, \"sensor %s not bound\\n\", subdev->name);\n\t\tgoto out;\n\t}\n\n\tvideo_unregister_device(&cam->vdev);\n\tcam->sensor = NULL;\n\tcam_dbg(cam, \"sensor %s unbound\\n\", subdev->name);\n\nout:\n\tmutex_unlock(&cam->s_mutex);\n}\n\nstatic int mccic_notify_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct mcam_camera *cam = notifier_to_mcam(notifier);\n\tint ret;\n\n\t \n\tret = v4l2_ctrl_handler_init(&cam->ctrl_handler, 10);\n\tif (!ret)\n\t\tcam->v4l2_dev.ctrl_handler = &cam->ctrl_handler;\n\n\treturn ret;\n}\n\nstatic const struct v4l2_async_notifier_operations mccic_notify_ops = {\n\t.bound = mccic_notify_bound,\n\t.unbind = mccic_notify_unbind,\n\t.complete = mccic_notify_complete,\n};\n\nint mccic_register(struct mcam_camera *cam)\n{\n\tstruct clk_init_data mclk_init = { };\n\tint ret;\n\n\t \n\tif (buffer_mode >= 0)\n\t\tcam->buffer_mode = buffer_mode;\n\tif (cam->buffer_mode == B_DMA_sg &&\n\t\t\tcam->chip_id == MCAM_CAFE) {\n\t\tprintk(KERN_ERR \"marvell-cam: Cafe can't do S/G I/O, attempting vmalloc mode instead\\n\");\n\t\tcam->buffer_mode = B_vmalloc;\n\t}\n\n\tif (!mcam_buffer_mode_supported(cam->buffer_mode)) {\n\t\tprintk(KERN_ERR \"marvell-cam: buffer mode %d unsupported\\n\",\n\t\t\t\tcam->buffer_mode);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_init(&cam->s_mutex);\n\tcam->state = S_NOTREADY;\n\tmcam_set_config_needed(cam, 1);\n\tcam->pix_format = mcam_def_pix_format;\n\tcam->mbus_code = mcam_def_mbus_code;\n\n\tcam->notifier.ops = &mccic_notify_ops;\n\tret = v4l2_async_nf_register(&cam->notifier);\n\tif (ret < 0) {\n\t\tcam_warn(cam, \"failed to register a sensor notifier\");\n\t\tgoto out;\n\t}\n\n\t \n\tmclk_init.parent_names = NULL;\n\tmclk_init.num_parents = 0;\n\tmclk_init.ops = &mclk_ops;\n\tmclk_init.name = \"mclk\";\n\n\tof_property_read_string(cam->dev->of_node, \"clock-output-names\",\n\t\t\t\t\t\t\t&mclk_init.name);\n\n\tcam->mclk_hw.init = &mclk_init;\n\n\tcam->mclk = devm_clk_register(cam->dev, &cam->mclk_hw);\n\tif (IS_ERR(cam->mclk)) {\n\t\tret = PTR_ERR(cam->mclk);\n\t\tdev_err(cam->dev, \"can't register clock\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (cam->buffer_mode == B_vmalloc && !alloc_bufs_at_read) {\n\t\tif (mcam_alloc_dma_bufs(cam, 1))\n\t\t\tcam_warn(cam, \"Unable to alloc DMA buffers at load will try again later.\");\n\t}\n\n\treturn 0;\n\nout:\n\tv4l2_async_nf_unregister(&cam->notifier);\n\tv4l2_async_nf_cleanup(&cam->notifier);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mccic_register);\n\nvoid mccic_shutdown(struct mcam_camera *cam)\n{\n\t \n\tif (!list_empty(&cam->vdev.fh_list)) {\n\t\tcam_warn(cam, \"Removing a device with users!\\n\");\n\t\tsensor_call(cam, core, s_power, 0);\n\t}\n\tif (cam->buffer_mode == B_vmalloc)\n\t\tmcam_free_dma_bufs(cam);\n\tv4l2_ctrl_handler_free(&cam->ctrl_handler);\n\tv4l2_async_nf_unregister(&cam->notifier);\n\tv4l2_async_nf_cleanup(&cam->notifier);\n}\nEXPORT_SYMBOL_GPL(mccic_shutdown);\n\n \nvoid mccic_suspend(struct mcam_camera *cam)\n{\n\tmutex_lock(&cam->s_mutex);\n\tif (!list_empty(&cam->vdev.fh_list)) {\n\t\tenum mcam_state cstate = cam->state;\n\n\t\tmcam_ctlr_stop_dma(cam);\n\t\tsensor_call(cam, core, s_power, 0);\n\t\tcam->state = cstate;\n\t}\n\tmutex_unlock(&cam->s_mutex);\n}\nEXPORT_SYMBOL_GPL(mccic_suspend);\n\nint mccic_resume(struct mcam_camera *cam)\n{\n\tint ret = 0;\n\n\tmutex_lock(&cam->s_mutex);\n\tif (!list_empty(&cam->vdev.fh_list)) {\n\t\tret = sensor_call(cam, core, s_power, 1);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&cam->s_mutex);\n\t\t\treturn ret;\n\t\t}\n\t\t__mcam_cam_reset(cam);\n\t} else {\n\t\tsensor_call(cam, core, s_power, 0);\n\t}\n\tmutex_unlock(&cam->s_mutex);\n\n\tset_bit(CF_CONFIG_NEEDED, &cam->flags);\n\tif (cam->state == S_STREAMING) {\n\t\t \n\t\tif (cam->buffer_mode == B_DMA_sg && cam->vb_bufs[0])\n\t\t\tlist_add(&cam->vb_bufs[0]->queue, &cam->buffers);\n\t\tret = mcam_read_setup(cam);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mccic_resume);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jonathan Corbet <corbet@lwn.net>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}