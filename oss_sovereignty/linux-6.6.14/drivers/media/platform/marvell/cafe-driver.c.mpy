{
  "module_name": "cafe-driver.c",
  "hash_id": "d54e76cb14f232c2b575d82945a2bf6e3a4861b6c17114abce1ffe412e039db1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/marvell/cafe-driver.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/i2c/ov7670.h>\n#include <linux/device.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/clkdev.h>\n\n#include \"mcam-core.h\"\n\n#define CAFE_VERSION 0x000002\n\n\n \nMODULE_AUTHOR(\"Jonathan Corbet <corbet@lwn.net>\");\nMODULE_DESCRIPTION(\"Marvell 88ALP01 CMOS Camera Controller driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct cafe_camera {\n\tint registered;\t\t\t \n\tstruct mcam_camera mcam;\n\tstruct pci_dev *pdev;\n\tstruct i2c_adapter *i2c_adapter;\n\twait_queue_head_t smbus_wait;\t \n};\n\n \n\n \n#define REG_GPR\t\t0xb4\n#define\t  GPR_C1EN\t  0x00000020\t \n#define\t  GPR_C0EN\t  0x00000010\t \n#define\t  GPR_C1\t  0x00000002\t \n \n#define\t  GPR_C0\t  0x00000001\t \n\n \n#define REG_TWSIC0\t0xb8\t \n#define\t  TWSIC0_EN\t  0x00000001\t \n#define\t  TWSIC0_MODE\t  0x00000002\t \n#define\t  TWSIC0_SID\t  0x000003fc\t \n \n#define\t  TWSIC0_SID_SHIFT 3\n#define\t  TWSIC0_CLKDIV\t  0x0007fc00\t \n#define\t  TWSIC0_MASKACK  0x00400000\t \n#define\t  TWSIC0_OVMAGIC  0x00800000\t \n\n#define REG_TWSIC1\t0xbc\t \n#define\t  TWSIC1_DATA\t  0x0000ffff\t \n#define\t  TWSIC1_ADDR\t  0x00ff0000\t \n#define\t  TWSIC1_ADDR_SHIFT 16\n#define\t  TWSIC1_READ\t  0x01000000\t \n#define\t  TWSIC1_WSTAT\t  0x02000000\t \n#define\t  TWSIC1_RVALID\t  0x04000000\t \n#define\t  TWSIC1_ERROR\t  0x08000000\t \n\n \n#define REG_GL_CSR     0x3004   \n#define\t  GCSR_SRS\t 0x00000001\t \n#define\t  GCSR_SRC\t 0x00000002\t \n#define\t  GCSR_MRS\t 0x00000004\t \n#define\t  GCSR_MRC\t 0x00000008\t \n#define\t  GCSR_CCIC_EN\t 0x00004000     \n#define REG_GL_IMASK   0x300c   \n#define\t  GIMSK_CCIC_EN\t\t 0x00000004     \n\n#define REG_GL_FCR\t0x3038\t \n#define\t  GFCR_GPIO_ON\t  0x08\t\t \n#define REG_GL_GPIOR\t0x315c\t \n#define\t  GGPIO_OUT\t\t0x80000\t \n#define\t  GGPIO_VAL\t\t0x00008\t \n\n#define REG_LEN\t\t       (REG_GL_IMASK + 4)\n\n\n \n#define cam_err(cam, fmt, arg...) \\\n\tdev_err(&(cam)->pdev->dev, fmt, ##arg);\n#define cam_warn(cam, fmt, arg...) \\\n\tdev_warn(&(cam)->pdev->dev, fmt, ##arg);\n\n \n \n#define CAFE_SMBUS_TIMEOUT (HZ)   \n\nstatic int cafe_smbus_write_done(struct mcam_camera *mcam)\n{\n\tunsigned long flags;\n\tint c1;\n\n\t \n\tudelay(20);\n\tspin_lock_irqsave(&mcam->dev_lock, flags);\n\tc1 = mcam_reg_read(mcam, REG_TWSIC1);\n\tspin_unlock_irqrestore(&mcam->dev_lock, flags);\n\treturn (c1 & (TWSIC1_WSTAT|TWSIC1_ERROR)) != TWSIC1_WSTAT;\n}\n\nstatic int cafe_smbus_write_data(struct cafe_camera *cam,\n\t\tu16 addr, u8 command, u8 value)\n{\n\tunsigned int rval;\n\tunsigned long flags;\n\tstruct mcam_camera *mcam = &cam->mcam;\n\n\tspin_lock_irqsave(&mcam->dev_lock, flags);\n\trval = TWSIC0_EN | ((addr << TWSIC0_SID_SHIFT) & TWSIC0_SID);\n\trval |= TWSIC0_OVMAGIC;   \n\t \n\trval |= TWSIC0_CLKDIV;\n\tmcam_reg_write(mcam, REG_TWSIC0, rval);\n\t(void) mcam_reg_read(mcam, REG_TWSIC1);  \n\trval = value | ((command << TWSIC1_ADDR_SHIFT) & TWSIC1_ADDR);\n\tmcam_reg_write(mcam, REG_TWSIC1, rval);\n\tspin_unlock_irqrestore(&mcam->dev_lock, flags);\n\n\t \n\tmdelay(2);\n\n\t \n\twait_event_timeout(cam->smbus_wait, cafe_smbus_write_done(mcam),\n\t\t\tCAFE_SMBUS_TIMEOUT);\n\n\tspin_lock_irqsave(&mcam->dev_lock, flags);\n\trval = mcam_reg_read(mcam, REG_TWSIC1);\n\tspin_unlock_irqrestore(&mcam->dev_lock, flags);\n\n\tif (rval & TWSIC1_WSTAT) {\n\t\tcam_err(cam, \"SMBUS write (%02x/%02x/%02x) timed out\\n\", addr,\n\t\t\t\tcommand, value);\n\t\treturn -EIO;\n\t}\n\tif (rval & TWSIC1_ERROR) {\n\t\tcam_err(cam, \"SMBUS write (%02x/%02x/%02x) error\\n\", addr,\n\t\t\t\tcommand, value);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n\n\nstatic int cafe_smbus_read_done(struct mcam_camera *mcam)\n{\n\tunsigned long flags;\n\tint c1;\n\n\t \n\tudelay(20);\n\tspin_lock_irqsave(&mcam->dev_lock, flags);\n\tc1 = mcam_reg_read(mcam, REG_TWSIC1);\n\tspin_unlock_irqrestore(&mcam->dev_lock, flags);\n\treturn c1 & (TWSIC1_RVALID|TWSIC1_ERROR);\n}\n\n\n\nstatic int cafe_smbus_read_data(struct cafe_camera *cam,\n\t\tu16 addr, u8 command, u8 *value)\n{\n\tunsigned int rval;\n\tunsigned long flags;\n\tstruct mcam_camera *mcam = &cam->mcam;\n\n\tspin_lock_irqsave(&mcam->dev_lock, flags);\n\trval = TWSIC0_EN | ((addr << TWSIC0_SID_SHIFT) & TWSIC0_SID);\n\trval |= TWSIC0_OVMAGIC;  \n\t \n\trval |= TWSIC0_CLKDIV;\n\tmcam_reg_write(mcam, REG_TWSIC0, rval);\n\t(void) mcam_reg_read(mcam, REG_TWSIC1);  \n\trval = TWSIC1_READ | ((command << TWSIC1_ADDR_SHIFT) & TWSIC1_ADDR);\n\tmcam_reg_write(mcam, REG_TWSIC1, rval);\n\tspin_unlock_irqrestore(&mcam->dev_lock, flags);\n\n\twait_event_timeout(cam->smbus_wait,\n\t\t\tcafe_smbus_read_done(mcam), CAFE_SMBUS_TIMEOUT);\n\tspin_lock_irqsave(&mcam->dev_lock, flags);\n\trval = mcam_reg_read(mcam, REG_TWSIC1);\n\tspin_unlock_irqrestore(&mcam->dev_lock, flags);\n\n\tif (rval & TWSIC1_ERROR) {\n\t\tcam_err(cam, \"SMBUS read (%02x/%02x) error\\n\", addr, command);\n\t\treturn -EIO;\n\t}\n\tif (!(rval & TWSIC1_RVALID)) {\n\t\tcam_err(cam, \"SMBUS read (%02x/%02x) timed out\\n\", addr,\n\t\t\t\tcommand);\n\t\treturn -EIO;\n\t}\n\t*value = rval & 0xff;\n\treturn 0;\n}\n\n \nstatic int cafe_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\n\t\tunsigned short flags, char rw, u8 command,\n\t\tint size, union i2c_smbus_data *data)\n{\n\tstruct cafe_camera *cam = i2c_get_adapdata(adapter);\n\tint ret = -EINVAL;\n\n\t \n\tif (size != I2C_SMBUS_BYTE_DATA) {\n\t\tcam_err(cam, \"funky xfer size %d\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rw == I2C_SMBUS_WRITE)\n\t\tret = cafe_smbus_write_data(cam, addr, command, data->byte);\n\telse if (rw == I2C_SMBUS_READ)\n\t\tret = cafe_smbus_read_data(cam, addr, command, &data->byte);\n\treturn ret;\n}\n\n\nstatic void cafe_smbus_enable_irq(struct cafe_camera *cam)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cam->mcam.dev_lock, flags);\n\tmcam_reg_set_bit(&cam->mcam, REG_IRQMASK, TWSIIRQS);\n\tspin_unlock_irqrestore(&cam->mcam.dev_lock, flags);\n}\n\nstatic u32 cafe_smbus_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_READ_BYTE_DATA  |\n\t       I2C_FUNC_SMBUS_WRITE_BYTE_DATA;\n}\n\nstatic const struct i2c_algorithm cafe_smbus_algo = {\n\t.smbus_xfer = cafe_smbus_xfer,\n\t.functionality = cafe_smbus_func\n};\n\nstatic int cafe_smbus_setup(struct cafe_camera *cam)\n{\n\tstruct i2c_adapter *adap;\n\tint ret;\n\n\tadap = kzalloc(sizeof(*adap), GFP_KERNEL);\n\tif (adap == NULL)\n\t\treturn -ENOMEM;\n\tadap->owner = THIS_MODULE;\n\tadap->algo = &cafe_smbus_algo;\n\tstrscpy(adap->name, \"cafe_ccic\", sizeof(adap->name));\n\tadap->dev.parent = &cam->pdev->dev;\n\ti2c_set_adapdata(adap, cam);\n\tret = i2c_add_adapter(adap);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"Unable to register cafe i2c adapter\\n\");\n\t\tkfree(adap);\n\t\treturn ret;\n\t}\n\n\tcam->i2c_adapter = adap;\n\tcafe_smbus_enable_irq(cam);\n\treturn 0;\n}\n\nstatic void cafe_smbus_shutdown(struct cafe_camera *cam)\n{\n\ti2c_del_adapter(cam->i2c_adapter);\n\tkfree(cam->i2c_adapter);\n}\n\n\n \n\nstatic void cafe_ctlr_init(struct mcam_camera *mcam)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mcam->dev_lock, flags);\n\t \n\tmcam_reg_write(mcam, 0x3038, 0x8);\n\tmcam_reg_write(mcam, 0x315c, 0x80008);\n\t \n\tmcam_reg_write(mcam, REG_GL_CSR, GCSR_SRS|GCSR_MRS);  \n\tmcam_reg_write(mcam, REG_GL_CSR, GCSR_SRC|GCSR_MRC);\n\tmcam_reg_write(mcam, REG_GL_CSR, GCSR_SRC|GCSR_MRS);\n\t \n\tspin_unlock_irqrestore(&mcam->dev_lock, flags);\n\tmsleep(5);\n\tspin_lock_irqsave(&mcam->dev_lock, flags);\n\n\tmcam_reg_write(mcam, REG_GL_CSR, GCSR_CCIC_EN|GCSR_SRC|GCSR_MRC);\n\tmcam_reg_set_bit(mcam, REG_GL_IMASK, GIMSK_CCIC_EN);\n\t \n\tmcam_reg_write(mcam, REG_IRQMASK, 0);\n\tspin_unlock_irqrestore(&mcam->dev_lock, flags);\n}\n\n\nstatic int cafe_ctlr_power_up(struct mcam_camera *mcam)\n{\n\t \n\tmcam_reg_write(mcam, REG_GL_FCR, GFCR_GPIO_ON);\n\tmcam_reg_write(mcam, REG_GL_GPIOR, GGPIO_OUT|GGPIO_VAL);\n\t \n\tmcam_reg_write(mcam, REG_GPR, GPR_C1EN|GPR_C0EN);  \n\tmcam_reg_write(mcam, REG_GPR, GPR_C1EN|GPR_C0EN|GPR_C0);\n\n\treturn 0;\n}\n\nstatic void cafe_ctlr_power_down(struct mcam_camera *mcam)\n{\n\tmcam_reg_write(mcam, REG_GPR, GPR_C1EN|GPR_C0EN|GPR_C1);\n\tmcam_reg_write(mcam, REG_GL_FCR, GFCR_GPIO_ON);\n\tmcam_reg_write(mcam, REG_GL_GPIOR, GGPIO_OUT);\n}\n\n\n\n \nstatic irqreturn_t cafe_irq(int irq, void *data)\n{\n\tstruct cafe_camera *cam = data;\n\tstruct mcam_camera *mcam = &cam->mcam;\n\tunsigned int irqs, handled;\n\n\tspin_lock(&mcam->dev_lock);\n\tirqs = mcam_reg_read(mcam, REG_IRQSTAT);\n\thandled = cam->registered && mccic_irq(mcam, irqs);\n\tif (irqs & TWSIIRQS) {\n\t\tmcam_reg_write(mcam, REG_IRQSTAT, TWSIIRQS);\n\t\twake_up(&cam->smbus_wait);\n\t\thandled = 1;\n\t}\n\tspin_unlock(&mcam->dev_lock);\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\nstatic struct ov7670_config sensor_cfg = {\n\t \n\t.min_width = 320,\n\t.min_height = 240,\n\n\t \n\t.clock_speed = 45,\n\t.use_smbus = 1,\n};\n\nstatic struct i2c_board_info ov7670_info = {\n\t.type = \"ov7670\",\n\t.addr = 0x42 >> 1,\n\t.platform_data = &sensor_cfg,\n};\n\n \n \n\nstatic int cafe_pci_probe(struct pci_dev *pdev,\n\t\tconst struct pci_device_id *id)\n{\n\tint ret;\n\tstruct cafe_camera *cam;\n\tstruct mcam_camera *mcam;\n\tstruct v4l2_async_connection *asd;\n\tstruct i2c_client *i2c_dev;\n\n\t \n\tret = -ENOMEM;\n\tcam = kzalloc(sizeof(struct cafe_camera), GFP_KERNEL);\n\tif (cam == NULL)\n\t\tgoto out;\n\tpci_set_drvdata(pdev, cam);\n\tcam->pdev = pdev;\n\tmcam = &cam->mcam;\n\tmcam->chip_id = MCAM_CAFE;\n\tspin_lock_init(&mcam->dev_lock);\n\tinit_waitqueue_head(&cam->smbus_wait);\n\tmcam->plat_power_up = cafe_ctlr_power_up;\n\tmcam->plat_power_down = cafe_ctlr_power_down;\n\tmcam->dev = &pdev->dev;\n\t \n\tmcam->buffer_mode = B_vmalloc;\n\t \n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\tgoto out_free;\n\tpci_set_master(pdev);\n\n\tret = -EIO;\n\tmcam->regs = pci_iomap(pdev, 0, 0);\n\tif (!mcam->regs) {\n\t\tprintk(KERN_ERR \"Unable to ioremap cafe-ccic regs\\n\");\n\t\tgoto out_disable;\n\t}\n\tmcam->regs_size = pci_resource_len(pdev, 0);\n\tret = request_irq(pdev->irq, cafe_irq, IRQF_SHARED, \"cafe-ccic\", cam);\n\tif (ret)\n\t\tgoto out_iounmap;\n\n\t \n\tcafe_ctlr_init(mcam);\n\n\t \n\tret = cafe_smbus_setup(cam);\n\tif (ret)\n\t\tgoto out_pdown;\n\n\tret = v4l2_device_register(mcam->dev, &mcam->v4l2_dev);\n\tif (ret)\n\t\tgoto out_smbus_shutdown;\n\n\tv4l2_async_nf_init(&mcam->notifier, &mcam->v4l2_dev);\n\n\tasd = v4l2_async_nf_add_i2c(&mcam->notifier,\n\t\t\t\t    i2c_adapter_id(cam->i2c_adapter),\n\t\t\t\t    ov7670_info.addr,\n\t\t\t\t    struct v4l2_async_connection);\n\tif (IS_ERR(asd)) {\n\t\tret = PTR_ERR(asd);\n\t\tgoto out_v4l2_device_unregister;\n\t}\n\n\tret = mccic_register(mcam);\n\tif (ret)\n\t\tgoto out_v4l2_device_unregister;\n\n\tclkdev_create(mcam->mclk, \"xclk\", \"%d-%04x\",\n\t\ti2c_adapter_id(cam->i2c_adapter), ov7670_info.addr);\n\n\ti2c_dev = i2c_new_client_device(cam->i2c_adapter, &ov7670_info);\n\tif (IS_ERR(i2c_dev)) {\n\t\tret = PTR_ERR(i2c_dev);\n\t\tgoto out_mccic_shutdown;\n\t}\n\n\tcam->registered = 1;\n\treturn 0;\n\nout_mccic_shutdown:\n\tmccic_shutdown(mcam);\nout_v4l2_device_unregister:\n\tv4l2_device_unregister(&mcam->v4l2_dev);\nout_smbus_shutdown:\n\tcafe_smbus_shutdown(cam);\nout_pdown:\n\tcafe_ctlr_power_down(mcam);\n\tfree_irq(pdev->irq, cam);\nout_iounmap:\n\tpci_iounmap(pdev, mcam->regs);\nout_disable:\n\tpci_disable_device(pdev);\nout_free:\n\tkfree(cam);\nout:\n\treturn ret;\n}\n\n\n \nstatic void cafe_shutdown(struct cafe_camera *cam)\n{\n\tmccic_shutdown(&cam->mcam);\n\tv4l2_device_unregister(&cam->mcam.v4l2_dev);\n\tcafe_smbus_shutdown(cam);\n\tfree_irq(cam->pdev->irq, cam);\n\tpci_iounmap(cam->pdev, cam->mcam.regs);\n}\n\n\nstatic void cafe_pci_remove(struct pci_dev *pdev)\n{\n\tstruct cafe_camera *cam = pci_get_drvdata(pdev);\n\n\tif (cam == NULL) {\n\t\tprintk(KERN_WARNING \"pci_remove on unknown pdev %p\\n\", pdev);\n\t\treturn;\n\t}\n\tcafe_shutdown(cam);\n\tkfree(cam);\n}\n\n\n \nstatic int __maybe_unused cafe_pci_suspend(struct device *dev)\n{\n\tstruct cafe_camera *cam = dev_get_drvdata(dev);\n\n\tmccic_suspend(&cam->mcam);\n\treturn 0;\n}\n\n\nstatic int __maybe_unused cafe_pci_resume(struct device *dev)\n{\n\tstruct cafe_camera *cam = dev_get_drvdata(dev);\n\n\tcafe_ctlr_init(&cam->mcam);\n\treturn mccic_resume(&cam->mcam);\n}\n\nstatic const struct pci_device_id cafe_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL,\n\t\t     PCI_DEVICE_ID_MARVELL_88ALP01_CCIC) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, cafe_ids);\n\nstatic SIMPLE_DEV_PM_OPS(cafe_pci_pm_ops, cafe_pci_suspend, cafe_pci_resume);\n\nstatic struct pci_driver cafe_pci_driver = {\n\t.name = \"cafe1000-ccic\",\n\t.id_table = cafe_ids,\n\t.probe = cafe_pci_probe,\n\t.remove = cafe_pci_remove,\n\t.driver.pm = &cafe_pci_pm_ops,\n};\n\n\n\n\nstatic int __init cafe_init(void)\n{\n\tint ret;\n\n\tprintk(KERN_NOTICE \"Marvell M88ALP01 'CAFE' Camera Controller version %d\\n\",\n\t\t\tCAFE_VERSION);\n\tret = pci_register_driver(&cafe_pci_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"Unable to register cafe_ccic driver\\n\");\n\t\tgoto out;\n\t}\n\tret = 0;\n\nout:\n\treturn ret;\n}\n\n\nstatic void __exit cafe_exit(void)\n{\n\tpci_unregister_driver(&cafe_pci_driver);\n}\n\nmodule_init(cafe_init);\nmodule_exit(cafe_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}