{
  "module_name": "mcam-core.h",
  "hash_id": "1486359894d84537c6d41d9ab58869cfca11b2b464771ce59b602e12e9da2502",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/marvell/mcam-core.h",
  "human_readable_source": " \n \n#ifndef _MCAM_CORE_H\n#define _MCAM_CORE_H\n\n#include <linux/list.h>\n#include <linux/clk-provider.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-dev.h>\n#include <media/videobuf2-v4l2.h>\n\n \n#if IS_ENABLED(CONFIG_VIDEOBUF2_VMALLOC)\n#define MCAM_MODE_VMALLOC 1\n#endif\n\n#if IS_ENABLED(CONFIG_VIDEOBUF2_DMA_CONTIG)\n#define MCAM_MODE_DMA_CONTIG 1\n#endif\n\n#if IS_ENABLED(CONFIG_VIDEOBUF2_DMA_SG)\n#define MCAM_MODE_DMA_SG 1\n#endif\n\n#if !defined(MCAM_MODE_VMALLOC) && !defined(MCAM_MODE_DMA_CONTIG) && \\\n\t!defined(MCAM_MODE_DMA_SG)\n#error One of the vb2 buffer modes must be selected in the config\n#endif\n\n\nenum mcam_state {\n\tS_NOTREADY,\t \n\tS_IDLE,\t\t \n\tS_FLAKED,\t \n\tS_STREAMING,\t \n\tS_BUFWAIT\t \n};\n#define MAX_DMA_BUFS 3\n\n \nenum mcam_buffer_mode {\n\tB_vmalloc = 0,\n\tB_DMA_contig = 1,\n\tB_DMA_sg = 2\n};\n\nenum mcam_chip_id {\n\tMCAM_CAFE,\n\tMCAM_ARMADA610,\n};\n\n \nstatic inline int mcam_buffer_mode_supported(enum mcam_buffer_mode mode)\n{\n\tswitch (mode) {\n#ifdef MCAM_MODE_VMALLOC\n\tcase B_vmalloc:\n#endif\n#ifdef MCAM_MODE_DMA_CONTIG\n\tcase B_DMA_contig:\n#endif\n#ifdef MCAM_MODE_DMA_SG\n\tcase B_DMA_sg:\n#endif\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstruct mcam_frame_state {\n\tunsigned int frames;\n\tunsigned int singles;\n\tunsigned int delivered;\n};\n\n#define NR_MCAM_CLK 3\n\n \nstruct mcam_camera {\n\t \n\tunsigned char __iomem *regs;\n\tunsigned regs_size;  \n\tspinlock_t dev_lock;\n\tstruct device *dev;  \n\tenum mcam_chip_id chip_id;\n\tenum mcam_buffer_mode buffer_mode;\n\n\tint mclk_src;\t \n\tint mclk_div;\t \n\n\tenum v4l2_mbus_type bus_type;\n\t \n\t \n\tint *dphy;\n\tbool mipi_enabled;\t \n\tint lane;\t\t\t \n\n\t \n\tstruct clk *clk[NR_MCAM_CLK];\n\tstruct clk_hw mclk_hw;\n\tstruct clk *mclk;\n\n\t \n\tint (*plat_power_up) (struct mcam_camera *cam);\n\tvoid (*plat_power_down) (struct mcam_camera *cam);\n\tvoid (*calc_dphy) (struct mcam_camera *cam);\n\n\t \n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tenum mcam_state state;\n\tunsigned long flags;\t\t \n\n\tstruct mcam_frame_state frame_state;\t \n\t \n\tstruct video_device vdev;\n\tstruct v4l2_async_notifier notifier;\n\tstruct v4l2_subdev *sensor;\n\n\t \n\tstruct vb2_queue vb_queue;\n\tstruct list_head buffers;\t \n\n\tunsigned int nbufs;\t\t \n\tint next_buf;\t\t\t \n\n\tchar bus_info[32];\t\t \n\n\t \n#ifdef MCAM_MODE_VMALLOC\n\tunsigned int dma_buf_size;\t \n\tvoid *dma_bufs[MAX_DMA_BUFS];\t \n\tdma_addr_t dma_handles[MAX_DMA_BUFS];  \n\tstruct tasklet_struct s_tasklet;\n#endif\n\tunsigned int sequence;\t\t \n\tunsigned int buf_seq[MAX_DMA_BUFS];  \n\n\t \n\tstruct mcam_vb_buffer *vb_bufs[MAX_DMA_BUFS];\n\n\t \n\tvoid (*dma_setup)(struct mcam_camera *cam);\n\tvoid (*frame_complete)(struct mcam_camera *cam, int frame);\n\n\t \n\tstruct v4l2_pix_format pix_format;\n\tu32 mbus_code;\n\n\t \n\tstruct mutex s_mutex;  \n};\n\n\n \n \nstatic inline void mcam_reg_write(struct mcam_camera *cam, unsigned int reg,\n\t\tunsigned int val)\n{\n\tiowrite32(val, cam->regs + reg);\n}\n\nstatic inline unsigned int mcam_reg_read(struct mcam_camera *cam,\n\t\tunsigned int reg)\n{\n\treturn ioread32(cam->regs + reg);\n}\n\n\nstatic inline void mcam_reg_write_mask(struct mcam_camera *cam, unsigned int reg,\n\t\tunsigned int val, unsigned int mask)\n{\n\tunsigned int v = mcam_reg_read(cam, reg);\n\n\tv = (v & ~mask) | (val & mask);\n\tmcam_reg_write(cam, reg, v);\n}\n\nstatic inline void mcam_reg_clear_bit(struct mcam_camera *cam,\n\t\tunsigned int reg, unsigned int val)\n{\n\tmcam_reg_write_mask(cam, reg, 0, val);\n}\n\nstatic inline void mcam_reg_set_bit(struct mcam_camera *cam,\n\t\tunsigned int reg, unsigned int val)\n{\n\tmcam_reg_write_mask(cam, reg, val, val);\n}\n\n \nint mccic_register(struct mcam_camera *cam);\nint mccic_irq(struct mcam_camera *cam, unsigned int irqs);\nvoid mccic_shutdown(struct mcam_camera *cam);\nvoid mccic_suspend(struct mcam_camera *cam);\nint mccic_resume(struct mcam_camera *cam);\n\n \n#define REG_Y0BAR\t0x00\n#define REG_Y1BAR\t0x04\n#define REG_Y2BAR\t0x08\n#define REG_U0BAR\t0x0c\n#define REG_U1BAR\t0x10\n#define REG_U2BAR\t0x14\n#define REG_V0BAR\t0x18\n#define REG_V1BAR\t0x1C\n#define REG_V2BAR\t0x20\n\n \n#define REG_CSI2_CTRL0\t0x100\n#define   CSI2_C0_MIPI_EN (0x1 << 0)\n#define   CSI2_C0_ACT_LANE(n) ((n-1) << 1)\n#define REG_CSI2_DPHY3\t0x12c\n#define REG_CSI2_DPHY5\t0x134\n#define REG_CSI2_DPHY6\t0x138\n\n \n\n#define REG_IMGPITCH\t0x24\t \n#define   IMGP_YP_SHFT\t  2\t\t \n#define   IMGP_YP_MASK\t  0x00003ffc\t \n#define\t  IMGP_UVP_SHFT\t  18\t\t \n#define   IMGP_UVP_MASK   0x3ffc0000\n#define REG_IRQSTATRAW\t0x28\t \n#define   IRQ_EOF0\t  0x00000001\t \n#define   IRQ_EOF1\t  0x00000002\t \n#define   IRQ_EOF2\t  0x00000004\t \n#define   IRQ_SOF0\t  0x00000008\t \n#define   IRQ_SOF1\t  0x00000010\t \n#define   IRQ_SOF2\t  0x00000020\t \n#define   IRQ_OVERFLOW\t  0x00000040\t \n#define   IRQ_TWSIW\t  0x00010000\t \n#define   IRQ_TWSIR\t  0x00020000\t \n#define   IRQ_TWSIE\t  0x00040000\t \n#define   TWSIIRQS (IRQ_TWSIW|IRQ_TWSIR|IRQ_TWSIE)\n#define   FRAMEIRQS (IRQ_EOF0|IRQ_EOF1|IRQ_EOF2|IRQ_SOF0|IRQ_SOF1|IRQ_SOF2)\n#define   ALLIRQS (TWSIIRQS|FRAMEIRQS|IRQ_OVERFLOW)\n#define REG_IRQMASK\t0x2c\t \n#define REG_IRQSTAT\t0x30\t \n\n#define REG_IMGSIZE\t0x34\t \n#define  IMGSZ_V_MASK\t  0x1fff0000\n#define  IMGSZ_V_SHIFT\t  16\n#define\t IMGSZ_H_MASK\t  0x00003fff\n#define REG_IMGOFFSET\t0x38\t \n\n#define REG_CTRL0\t0x3c\t \n#define   C0_ENABLE\t  0x00000001\t \n\n \n#define   C0_DF_MASK\t  0x00fffffc     \n\n \n#define\t  C0_RGB4_RGBX\t  0x00000000\n#define\t  C0_RGB4_XRGB\t  0x00000004\n#define\t  C0_RGB4_BGRX\t  0x00000008\n#define\t  C0_RGB4_XBGR\t  0x0000000c\n#define\t  C0_RGB5_RGGB\t  0x00000000\n#define\t  C0_RGB5_GRBG\t  0x00000004\n#define\t  C0_RGB5_GBRG\t  0x00000008\n#define\t  C0_RGB5_BGGR\t  0x0000000c\n\n \n#define\t  C0_DF_YUV\t  0x00000000\t \n#define\t  C0_DF_RGB\t  0x000000a0\t \n#define\t  C0_DF_BAYER\t  0x00000140\t \n \n#define\t  C0_RGBF_565\t  0x00000000\n#define\t  C0_RGBF_444\t  0x00000800\n#define\t  C0_RGB_BGR\t  0x00001000\t \n#define\t  C0_YUV_PLANAR\t  0x00000000\t \n#define\t  C0_YUV_PACKED\t  0x00008000\t \n#define\t  C0_YUV_420PL\t  0x0000a000\t \n \n#define\t  C0_YUVE_YUYV\t  0x00000000\t \n#define\t  C0_YUVE_YVYU\t  0x00010000\t \n#define\t  C0_YUVE_VYUY\t  0x00020000\t \n#define\t  C0_YUVE_UYVY\t  0x00030000\t \n#define\t  C0_YUVE_NOSWAP  0x00000000\t \n#define\t  C0_YUVE_SWAP13  0x00010000\t \n#define\t  C0_YUVE_SWAP24  0x00020000\t \n#define\t  C0_YUVE_SWAP1324 0x00030000\t \n \n#define\t  C0_EOF_VSYNC\t  0x00400000\t \n#define\t  C0_VEDGE_CTRL   0x00800000\t \n#define\t  C0_HPOL_LOW\t  0x01000000\t \n#define\t  C0_VPOL_LOW\t  0x02000000\t \n#define\t  C0_VCLK_LOW\t  0x04000000\t \n#define\t  C0_DOWNSCALE\t  0x08000000\t \n \n#define\t  C0_SIF_HVSYNC\t  0x00000000\t \n#define\t  C0_SOF_NOSYNC\t  0x40000000\t \n#define\t  C0_SIFM_MASK\t  0xc0000000\t \n\n \n#define REG_CTRL1\t0x40\t \n#define\t  C1_CLKGATE\t  0x00000001\t \n#define   C1_DESC_ENA\t  0x00000100\t \n#define   C1_DESC_3WORD   0x00000200\t \n#define\t  C1_444ALPHA\t  0x00f00000\t \n#define\t  C1_ALPHA_SHFT\t  20\n#define\t  C1_DMAB32\t  0x00000000\t \n#define\t  C1_DMAB16\t  0x02000000\t \n#define\t  C1_DMAB64\t  0x04000000\t \n#define\t  C1_DMAB_MASK\t  0x06000000\n#define\t  C1_TWOBUFS\t  0x08000000\t \n#define\t  C1_PWRDWN\t  0x10000000\t \n\n#define REG_CLKCTRL\t0x88\t \n#define\t  CLK_DIV_MASK\t  0x0000ffff\t \n\n \n#define REG_UBAR\t0xc4\t \n\n \n#define\tREG_DMA_DESC_Y\t0x200\n#define\tREG_DMA_DESC_U\t0x204\n#define\tREG_DMA_DESC_V\t0x208\n#define REG_DESC_LEN_Y\t0x20c\t \n#define\tREG_DESC_LEN_U\t0x210\n#define REG_DESC_LEN_V\t0x214\n\n \n#define VGA_WIDTH\t640\n#define VGA_HEIGHT\t480\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}