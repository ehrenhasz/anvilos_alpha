{
  "module_name": "v4l2.c",
  "hash_id": "7f71dcb7df11b96fcf1e8b012beeeb7b10e04076914138bea478b65e5758107c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nvidia/tegra-vde/v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/slab.h>\n\n#include \"vde.h\"\n\nstatic const struct v4l2_ctrl_config ctrl_cfgs[] = {\n\t{\t.id = V4L2_CID_STATELESS_H264_DECODE_PARAMS,\t},\n\t{\t.id = V4L2_CID_STATELESS_H264_SPS,\t\t},\n\t{\t.id = V4L2_CID_STATELESS_H264_PPS,\t\t},\n\t{\n\t\t.id = V4L2_CID_STATELESS_H264_DECODE_MODE,\n\t\t.min = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,\n\t\t.max = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,\n\t\t.def = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,\n\t},\n\t{\n\t\t.id = V4L2_CID_STATELESS_H264_START_CODE,\n\t\t.min = V4L2_STATELESS_H264_START_CODE_ANNEX_B,\n\t\t.max = V4L2_STATELESS_H264_START_CODE_ANNEX_B,\n\t\t.def = V4L2_STATELESS_H264_START_CODE_ANNEX_B,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_PROFILE,\n\t\t.min = V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE,\n\t\t.max = V4L2_MPEG_VIDEO_H264_PROFILE_MAIN,\n\t\t.def = V4L2_MPEG_VIDEO_H264_PROFILE_MAIN,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_LEVEL,\n\t\t.min = V4L2_MPEG_VIDEO_H264_LEVEL_1_0,\n\t\t.max = V4L2_MPEG_VIDEO_H264_LEVEL_5_1,\n\t},\n};\n\nstatic inline struct tegra_ctx *fh_to_tegra_ctx(struct v4l2_fh *fh)\n{\n\treturn container_of(fh, struct tegra_ctx, fh);\n}\n\nstatic void tegra_set_control_data(struct tegra_ctx *ctx, void *data, u32 id)\n{\n\tswitch (id) {\n\tcase V4L2_CID_STATELESS_H264_DECODE_PARAMS:\n\t\tctx->h264.decode_params = data;\n\t\tbreak;\n\tcase V4L2_CID_STATELESS_H264_SPS:\n\t\tctx->h264.sps = data;\n\t\tbreak;\n\tcase V4L2_CID_STATELESS_H264_PPS:\n\t\tctx->h264.pps = data;\n\t\tbreak;\n\t}\n}\n\nvoid tegra_vde_prepare_control_data(struct tegra_ctx *ctx, u32 id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctrl_cfgs); i++) {\n\t\tif (ctx->ctrls[i]->id == id) {\n\t\t\ttegra_set_control_data(ctx, ctx->ctrls[i]->p_cur.p, id);\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttegra_set_control_data(ctx, NULL, id);\n}\n\nstatic int tegra_queue_setup(struct vb2_queue *vq,\n\t\t\t     unsigned int *nbufs,\n\t\t\t     unsigned int *num_planes,\n\t\t\t     unsigned int sizes[],\n\t\t\t     struct device *alloc_devs[])\n{\n\tstruct tegra_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct v4l2_format *f;\n\tunsigned int i;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\tf = &ctx->coded_fmt;\n\telse\n\t\tf = &ctx->decoded_fmt;\n\n\tif (*num_planes) {\n\t\tif (*num_planes != f->fmt.pix_mp.num_planes)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < f->fmt.pix_mp.num_planes; i++) {\n\t\t\tif (sizes[i] < f->fmt.pix_mp.plane_fmt[i].sizeimage)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t*num_planes = f->fmt.pix_mp.num_planes;\n\n\t\tfor (i = 0; i < f->fmt.pix_mp.num_planes; i++)\n\t\t\tsizes[i] = f->fmt.pix_mp.plane_fmt[i].sizeimage;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\treturn 0;\n}\n\nstatic void __tegra_buf_cleanup(struct vb2_buffer *vb, unsigned int i)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct tegra_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct tegra_m2m_buffer *tb = vb_to_tegra_buf(vb);\n\n\twhile (i--) {\n\t\tif (tb->a[i]) {\n\t\t\ttegra_vde_dmabuf_cache_unmap(ctx->vde, tb->a[i], true);\n\t\t\ttb->a[i] = NULL;\n\t\t}\n\n\t\tif (tb->iova[i]) {\n\t\t\ttegra_vde_iommu_unmap(ctx->vde, tb->iova[i]);\n\t\t\ttb->iova[i] = NULL;\n\t\t}\n\t}\n\n\tif (tb->aux) {\n\t\ttegra_vde_free_bo(tb->aux);\n\t\ttb->aux = NULL;\n\t}\n}\n\nstatic int tegra_buf_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct tegra_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct tegra_m2m_buffer *tb = vb_to_tegra_buf(vb);\n\tstruct tegra_vde *vde = ctx->vde;\n\tenum dma_data_direction dma_dir;\n\tstruct sg_table *sgt;\n\tunsigned int i;\n\tint err;\n\n\tif (V4L2_TYPE_IS_CAPTURE(vq->type) && vb->num_planes > 1) {\n\t\t \n\t\terr = tegra_vde_alloc_bo(vde, &tb->aux, DMA_FROM_DEVICE,\n\t\t\t\t\t vb2_plane_size(vb, 1));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\tdma_dir = DMA_TO_DEVICE;\n\telse\n\t\tdma_dir = DMA_FROM_DEVICE;\n\n\tfor (i = 0; i < vb->num_planes; i++) {\n\t\tif (vq->memory == VB2_MEMORY_DMABUF) {\n\t\t\tget_dma_buf(vb->planes[i].dbuf);\n\n\t\t\terr = tegra_vde_dmabuf_cache_map(vde, vb->planes[i].dbuf,\n\t\t\t\t\t\t\t dma_dir, &tb->a[i],\n\t\t\t\t\t\t\t &tb->dma_base[i]);\n\t\t\tif (err) {\n\t\t\t\tdma_buf_put(vb->planes[i].dbuf);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (vde->domain) {\n\t\t\tsgt = vb2_dma_sg_plane_desc(vb, i);\n\n\t\t\terr = tegra_vde_iommu_map(vde, sgt, &tb->iova[i],\n\t\t\t\t\t\t  vb2_plane_size(vb, i));\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\n\t\t\ttb->dma_base[i] = iova_dma_addr(&vde->iova, tb->iova[i]);\n\t\t} else {\n\t\t\ttb->dma_base[i] = vb2_dma_contig_plane_dma_addr(vb, i);\n\t\t}\n\t}\n\n\treturn 0;\n\ncleanup:\n\t__tegra_buf_cleanup(vb, i);\n\n\treturn err;\n}\n\nstatic void tegra_buf_cleanup(struct vb2_buffer *vb)\n{\n\t__tegra_buf_cleanup(vb, vb->num_planes);\n}\n\nstatic int tegra_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct tegra_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct tegra_m2m_buffer *tb = vb_to_tegra_buf(vb);\n\tsize_t hw_align, hw_size, hw_payload, size, offset;\n\tstruct v4l2_pix_format_mplane *pixfmt;\n\tunsigned int i;\n\tvoid *vb_data;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\thw_align = BSEV_ALIGN;\n\t\tpixfmt = &ctx->coded_fmt.fmt.pix_mp;\n\t} else {\n\t\thw_align = FRAMEID_ALIGN;\n\t\tpixfmt = &ctx->decoded_fmt.fmt.pix_mp;\n\t}\n\n\tfor (i = 0; i < vb->num_planes; i++) {\n\t\toffset = vb->planes[i].data_offset;\n\n\t\tif (offset & (hw_align - 1))\n\t\t\treturn -EINVAL;\n\n\t\tif (V4L2_TYPE_IS_CAPTURE(vq->type)) {\n\t\t\tsize = pixfmt->plane_fmt[i].sizeimage;\n\t\t\thw_payload = ALIGN(size, VDE_ATOM);\n\t\t} else {\n\t\t\tsize = vb2_get_plane_payload(vb, i) - offset;\n\t\t\thw_payload = ALIGN(size + VDE_ATOM, SXE_BUFFER);\n\t\t}\n\n\t\thw_size = offset + hw_payload;\n\n\t\tif (vb2_plane_size(vb, i) < hw_size)\n\t\t\treturn -EINVAL;\n\n\t\tvb2_set_plane_payload(vb, i, hw_payload);\n\n\t\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\t\tvb_data = vb2_plane_vaddr(vb, i);\n\n\t\t\t \n\t\t\tif (vb_data)\n\t\t\t\tmemset(vb_data + offset + size, 0,\n\t\t\t\t       hw_size - offset - size);\n\t\t}\n\n\t\ttb->dma_addr[i] = tb->dma_base[i] + offset;\n\t}\n\n\tswitch (pixfmt->pixelformat) {\n\tcase V4L2_PIX_FMT_YVU420M:\n\t\tswap(tb->dma_addr[1], tb->dma_addr[2]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct tegra_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic void tegra_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct tegra_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &ctx->hdl);\n}\n\nstatic int tegra_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\treturn 0;\n}\n\nstatic void tegra_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct tegra_ctx *ctx = vb2_get_drv_priv(vq);\n\n\twhile (true) {\n\t\tstruct vb2_v4l2_buffer *vbuf;\n\n\t\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tif (!vbuf)\n\t\t\tbreak;\n\n\t\tv4l2_ctrl_request_complete(vbuf->vb2_buf.req_obj.req, &ctx->hdl);\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic const struct vb2_ops tegra_qops = {\n\t.queue_setup = tegra_queue_setup,\n\t.buf_init = tegra_buf_init,\n\t.buf_cleanup = tegra_buf_cleanup,\n\t.buf_prepare = tegra_buf_prepare,\n\t.buf_queue = tegra_buf_queue,\n\t.buf_out_validate = tegra_buf_out_validate,\n\t.buf_request_complete = tegra_buf_request_complete,\n\t.start_streaming = tegra_start_streaming,\n\t.stop_streaming = tegra_stop_streaming,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\nstatic int tegra_queue_init(void *priv,\n\t\t\t    struct vb2_queue *src_vq,\n\t\t\t    struct vb2_queue *dst_vq)\n{\n\tstruct tegra_ctx *ctx = priv;\n\tstruct tegra_vde *vde = ctx->vde;\n\tconst struct vb2_mem_ops *mem_ops;\n\tunsigned long dma_attrs;\n\tint err;\n\n\t \n\tif (vde->domain)\n\t\tmem_ops = &vb2_dma_sg_memops;\n\telse\n\t\tmem_ops = &vb2_dma_contig_memops;\n\n\tdma_attrs = DMA_ATTR_WRITE_COMBINE;\n\n\tsrc_vq->buf_struct_size = sizeof(struct tegra_m2m_buffer);\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_DMABUF | VB2_MMAP;\n\tsrc_vq->supports_requests = true;\n\tsrc_vq->requires_requests = true;\n\tsrc_vq->lock = &vde->v4l2_lock;\n\tsrc_vq->dma_attrs = dma_attrs;\n\tsrc_vq->mem_ops = mem_ops;\n\tsrc_vq->ops = &tegra_qops;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->dev = vde->dev;\n\n\terr = vb2_queue_init(src_vq);\n\tif (err) {\n\t\tv4l2_err(&vde->v4l2_dev,\n\t\t\t \"failed to initialize src queue: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tdma_attrs |= DMA_ATTR_NO_KERNEL_MAPPING;\n\n\tdst_vq->buf_struct_size = sizeof(struct tegra_m2m_buffer);\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_DMABUF | VB2_MMAP;\n\tdst_vq->lock = &vde->v4l2_lock;\n\tdst_vq->dma_attrs = dma_attrs;\n\tdst_vq->mem_ops = mem_ops;\n\tdst_vq->ops = &tegra_qops;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->dev = vde->dev;\n\n\terr = vb2_queue_init(dst_vq);\n\tif (err) {\n\t\tv4l2_err(&vde->v4l2_dev,\n\t\t\t \"failed to initialize dst queue: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_reset_fmt(struct tegra_ctx *ctx, struct v4l2_format *f,\n\t\t\t    u32 fourcc)\n{\n\tmemset(f, 0, sizeof(*f));\n\tf->fmt.pix_mp.pixelformat = fourcc;\n\tf->fmt.pix_mp.field = V4L2_FIELD_NONE;\n\tf->fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\tf->fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tf->fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709;\n\tf->fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT;\n}\n\nstatic void tegra_reset_coded_fmt(struct tegra_ctx *ctx)\n{\n\tconst struct tegra_vde_soc *soc = ctx->vde->soc;\n\tstruct v4l2_format *f = &ctx->coded_fmt;\n\n\tctx->coded_fmt_desc = &soc->coded_fmts[0];\n\ttegra_reset_fmt(ctx, f, ctx->coded_fmt_desc->fourcc);\n\n\tf->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tf->fmt.pix_mp.width = ctx->coded_fmt_desc->frmsize.min_width;\n\tf->fmt.pix_mp.height = ctx->coded_fmt_desc->frmsize.min_height;\n}\n\nstatic void tegra_fill_pixfmt_mp(struct v4l2_pix_format_mplane *pixfmt,\n\t\t\t\t u32 pixelformat, u32 width, u32 height)\n{\n\tconst struct v4l2_format_info *info = v4l2_format_info(pixelformat);\n\tstruct v4l2_plane_pix_format *plane;\n\tunsigned int i;\n\n\tswitch (pixelformat) {\n\tcase V4L2_PIX_FMT_YUV420M:\n\tcase V4L2_PIX_FMT_YVU420M:\n\t\tpixfmt->width = width;\n\t\tpixfmt->height = height;\n\t\tpixfmt->pixelformat = pixelformat;\n\t\tpixfmt->num_planes = info->mem_planes;\n\n\t\tfor (i = 0; i < pixfmt->num_planes; i++) {\n\t\t\tunsigned int hdiv = (i == 0) ? 1 : 2;\n\t\t\tunsigned int vdiv = (i == 0) ? 1 : 2;\n\n\t\t\t \n\t\t\tplane = &pixfmt->plane_fmt[i];\n\t\t\tplane->bytesperline = ALIGN(width, VDE_ATOM * 2) / hdiv;\n\t\t\tplane->sizeimage = plane->bytesperline * height / vdiv;\n\t\t}\n\n\t\tbreak;\n\t}\n}\n\nstatic void tegra_reset_decoded_fmt(struct tegra_ctx *ctx)\n{\n\tstruct v4l2_format *f = &ctx->decoded_fmt;\n\n\ttegra_reset_fmt(ctx, f, ctx->coded_fmt_desc->decoded_fmts[0]);\n\tf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\ttegra_fill_pixfmt_mp(&f->fmt.pix_mp,\n\t\t\t     ctx->coded_fmt_desc->decoded_fmts[0],\n\t\t\t     ctx->coded_fmt.fmt.pix_mp.width,\n\t\t\t     ctx->coded_fmt.fmt.pix_mp.height);\n}\n\nstatic void tegra_job_finish(struct tegra_ctx *ctx,\n\t\t\t     enum vb2_buffer_state result)\n{\n\tv4l2_m2m_buf_done_and_job_finish(ctx->vde->m2m, ctx->fh.m2m_ctx,\n\t\t\t\t\t result);\n}\n\nstatic void tegra_decode_complete(struct work_struct *work)\n{\n\tstruct tegra_ctx *ctx = container_of(work, struct tegra_ctx, work);\n\tint err;\n\n\terr = ctx->coded_fmt_desc->decode_wait(ctx);\n\tif (err)\n\t\ttegra_job_finish(ctx, VB2_BUF_STATE_ERROR);\n\telse\n\t\ttegra_job_finish(ctx, VB2_BUF_STATE_DONE);\n}\n\nstatic int tegra_querycap(struct file *file, void *priv,\n\t\t\t  struct v4l2_capability *cap)\n{\n\tstrscpy(cap->bus_info, \"platform:tegra-vde\", sizeof(cap->bus_info));\n\tstrscpy(cap->driver, \"tegra-vde\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"tegra-vde\", sizeof(cap->card));\n\n\treturn 0;\n}\n\nstatic int tegra_enum_decoded_fmt(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_fmtdesc *f)\n{\n\tstruct tegra_ctx *ctx = fh_to_tegra_ctx(priv);\n\n\tif (WARN_ON(!ctx->coded_fmt_desc))\n\t\treturn -EINVAL;\n\n\tif (f->index >= ctx->coded_fmt_desc->num_decoded_fmts)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = ctx->coded_fmt_desc->decoded_fmts[f->index];\n\n\treturn 0;\n}\n\nstatic int tegra_g_decoded_fmt(struct file *file, void *priv,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct tegra_ctx *ctx = fh_to_tegra_ctx(priv);\n\n\t*f = ctx->decoded_fmt;\n\treturn 0;\n}\n\nstatic int tegra_try_decoded_fmt(struct file *file, void *priv,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tstruct tegra_ctx *ctx = fh_to_tegra_ctx(priv);\n\tconst struct tegra_coded_fmt_desc *coded_desc;\n\tunsigned int i;\n\n\t \n\tcoded_desc = ctx->coded_fmt_desc;\n\tif (WARN_ON(!coded_desc))\n\t\treturn -EINVAL;\n\n\tif (!coded_desc->num_decoded_fmts)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < coded_desc->num_decoded_fmts; i++) {\n\t\tif (coded_desc->decoded_fmts[i] == pix_mp->pixelformat)\n\t\t\tbreak;\n\t}\n\n\tif (i == coded_desc->num_decoded_fmts)\n\t\tpix_mp->pixelformat = coded_desc->decoded_fmts[0];\n\n\t \n\tv4l2_apply_frmsize_constraints(&pix_mp->width,\n\t\t\t\t       &pix_mp->height,\n\t\t\t\t       &coded_desc->frmsize);\n\n\ttegra_fill_pixfmt_mp(pix_mp, pix_mp->pixelformat,\n\t\t\t     pix_mp->width, pix_mp->height);\n\tpix_mp->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int tegra_s_decoded_fmt(struct file *file, void *priv,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct tegra_ctx *ctx = fh_to_tegra_ctx(priv);\n\tstruct vb2_queue *vq;\n\tint err;\n\n\t \n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t     V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\terr = tegra_try_decoded_fmt(file, priv, f);\n\tif (err)\n\t\treturn err;\n\n\tctx->decoded_fmt = *f;\n\n\treturn 0;\n}\n\nstatic int tegra_enum_coded_fmt(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tstruct tegra_ctx *ctx = fh_to_tegra_ctx(priv);\n\tconst struct tegra_vde_soc *soc = ctx->vde->soc;\n\n\tif (f->index >= soc->num_coded_fmts)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = soc->coded_fmts[f->index].fourcc;\n\n\treturn 0;\n}\n\nstatic int tegra_g_coded_fmt(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct tegra_ctx *ctx = fh_to_tegra_ctx(priv);\n\n\t*f = ctx->coded_fmt;\n\treturn 0;\n}\n\nstatic const struct tegra_coded_fmt_desc *\ntegra_find_coded_fmt_desc(struct tegra_ctx *ctx, u32 fourcc)\n{\n\tconst struct tegra_vde_soc *soc = ctx->vde->soc;\n\tunsigned int i;\n\n\tfor (i = 0; i < soc->num_coded_fmts; i++) {\n\t\tif (soc->coded_fmts[i].fourcc == fourcc)\n\t\t\treturn &soc->coded_fmts[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int tegra_try_coded_fmt(struct file *file, void *priv,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tstruct tegra_ctx *ctx = fh_to_tegra_ctx(priv);\n\tconst struct tegra_vde_soc *soc = ctx->vde->soc;\n\tint size = pix_mp->plane_fmt[0].sizeimage;\n\tconst struct tegra_coded_fmt_desc *desc;\n\n\tdesc = tegra_find_coded_fmt_desc(ctx, pix_mp->pixelformat);\n\tif (!desc) {\n\t\tpix_mp->pixelformat = soc->coded_fmts[0].fourcc;\n\t\tdesc = &soc->coded_fmts[0];\n\t}\n\n\tv4l2_apply_frmsize_constraints(&pix_mp->width,\n\t\t\t\t       &pix_mp->height,\n\t\t\t\t       &desc->frmsize);\n\n\tpix_mp->plane_fmt[0].sizeimage = max(ALIGN(size, SXE_BUFFER), SZ_2M);\n\tpix_mp->field = V4L2_FIELD_NONE;\n\tpix_mp->num_planes = 1;\n\n\treturn 0;\n}\n\nstatic int tegra_s_coded_fmt(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct tegra_ctx *ctx = fh_to_tegra_ctx(priv);\n\tstruct v4l2_m2m_ctx *m2m_ctx = ctx->fh.m2m_ctx;\n\tconst struct tegra_coded_fmt_desc *desc;\n\tstruct vb2_queue *peer_vq, *vq;\n\tstruct v4l2_format *cap_fmt;\n\tint err;\n\n\t \n\tvq = v4l2_m2m_get_vq(m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\tif (vb2_is_streaming(vq) ||\n\t    (vb2_is_busy(vq) &&\n\t     f->fmt.pix_mp.pixelformat != ctx->coded_fmt.fmt.pix_mp.pixelformat))\n\t\treturn -EBUSY;\n\n\t \n\tpeer_vq = v4l2_m2m_get_vq(m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (vb2_is_busy(peer_vq))\n\t\treturn -EBUSY;\n\n\terr = tegra_try_coded_fmt(file, priv, f);\n\tif (err)\n\t\treturn err;\n\n\tdesc = tegra_find_coded_fmt_desc(ctx, f->fmt.pix_mp.pixelformat);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tctx->coded_fmt_desc = desc;\n\tctx->coded_fmt = *f;\n\n\t \n\ttegra_reset_decoded_fmt(ctx);\n\n\t \n\tcap_fmt = &ctx->decoded_fmt;\n\tcap_fmt->fmt.pix_mp.xfer_func = f->fmt.pix_mp.xfer_func;\n\tcap_fmt->fmt.pix_mp.ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;\n\tcap_fmt->fmt.pix_mp.colorspace = f->fmt.pix_mp.colorspace;\n\tcap_fmt->fmt.pix_mp.quantization = f->fmt.pix_mp.quantization;\n\n\treturn 0;\n}\n\nstatic int tegra_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t struct v4l2_frmsizeenum *fsize)\n{\n\tstruct tegra_ctx *ctx = fh_to_tegra_ctx(priv);\n\tconst struct tegra_coded_fmt_desc *fmt;\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\n\tfmt = tegra_find_coded_fmt_desc(ctx, fsize->pixel_format);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise = fmt->frmsize;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops tegra_v4l2_ioctl_ops = {\n\t.vidioc_querycap = tegra_querycap,\n\t.vidioc_enum_framesizes = tegra_enum_framesizes,\n\n\t.vidioc_try_fmt_vid_out_mplane = tegra_try_coded_fmt,\n\t.vidioc_g_fmt_vid_out_mplane = tegra_g_coded_fmt,\n\t.vidioc_s_fmt_vid_out_mplane = tegra_s_coded_fmt,\n\t.vidioc_enum_fmt_vid_out = tegra_enum_coded_fmt,\n\n\t.vidioc_try_fmt_vid_cap_mplane = tegra_try_decoded_fmt,\n\t.vidioc_g_fmt_vid_cap_mplane = tegra_g_decoded_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane = tegra_s_decoded_fmt,\n\t.vidioc_enum_fmt_vid_cap = tegra_enum_decoded_fmt,\n\n\t.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic int tegra_init_ctrls(struct tegra_ctx *ctx)\n{\n\tunsigned int i;\n\tint err;\n\n\terr = v4l2_ctrl_handler_init(&ctx->hdl, ARRAY_SIZE(ctrl_cfgs));\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctrl_cfgs); i++) {\n\t\tctx->ctrls[i] = v4l2_ctrl_new_custom(&ctx->hdl, &ctrl_cfgs[i],\n\t\t\t\t\t\t     NULL);\n\t\tif (ctx->hdl.error) {\n\t\t\terr = ctx->hdl.error;\n\t\t\tgoto free_ctrls;\n\t\t}\n\t}\n\n\terr = v4l2_ctrl_handler_setup(&ctx->hdl);\n\tif (err)\n\t\tgoto free_ctrls;\n\n\tctx->fh.ctrl_handler = &ctx->hdl;\n\n\treturn 0;\n\nfree_ctrls:\n\tv4l2_ctrl_handler_free(&ctx->hdl);\n\n\treturn err;\n}\n\nstatic int tegra_init_m2m(struct tegra_ctx *ctx)\n{\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(ctx->vde->m2m,\n\t\t\t\t\t    ctx, tegra_queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx))\n\t\treturn PTR_ERR(ctx->fh.m2m_ctx);\n\n\treturn 0;\n}\n\nstatic int tegra_open(struct file *file)\n{\n\tstruct tegra_vde *vde = video_drvdata(file);\n\tstruct tegra_ctx *ctx;\n\tint err;\n\n\tctx = kzalloc(offsetof(struct tegra_ctx, ctrls[ARRAY_SIZE(ctrl_cfgs)]),\n\t\t      GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->vde = vde;\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tINIT_WORK(&ctx->work, tegra_decode_complete);\n\n\terr = tegra_init_ctrls(ctx);\n\tif (err) {\n\t\tv4l2_err(&vde->v4l2_dev, \"failed to add controls: %d\\n\", err);\n\t\tgoto free_ctx;\n\t}\n\n\terr = tegra_init_m2m(ctx);\n\tif (err) {\n\t\tv4l2_err(&vde->v4l2_dev, \"failed to initialize m2m: %d\\n\", err);\n\t\tgoto free_ctrls;\n\t}\n\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\ttegra_reset_coded_fmt(ctx);\n\ttegra_try_coded_fmt(file, file->private_data, &ctx->coded_fmt);\n\n\ttegra_reset_decoded_fmt(ctx);\n\ttegra_try_decoded_fmt(file, file->private_data, &ctx->decoded_fmt);\n\n\treturn 0;\n\nfree_ctrls:\n\tv4l2_ctrl_handler_free(&ctx->hdl);\nfree_ctx:\n\tkfree(ctx);\n\n\treturn err;\n}\n\nstatic int tegra_release(struct file *file)\n{\n\tstruct v4l2_fh *fh = file->private_data;\n\tstruct tegra_ctx *ctx = fh_to_tegra_ctx(fh);\n\tstruct tegra_vde *vde = ctx->vde;\n\n\tv4l2_fh_del(fh);\n\tv4l2_m2m_ctx_release(fh->m2m_ctx);\n\tv4l2_ctrl_handler_free(&ctx->hdl);\n\tv4l2_fh_exit(fh);\n\tkfree(ctx);\n\n\ttegra_vde_dmabuf_cache_unmap_sync(vde);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations tegra_v4l2_fops = {\n\t.owner = THIS_MODULE,\n\t.open = tegra_open,\n\t.poll = v4l2_m2m_fop_poll,\n\t.mmap = v4l2_m2m_fop_mmap,\n\t.release = tegra_release,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\nstatic void tegra_device_run(void *priv)\n{\n\tstruct tegra_ctx *ctx = priv;\n\tstruct vb2_v4l2_buffer *src = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tstruct media_request *src_req = src->vb2_buf.req_obj.req;\n\tint err;\n\n\tv4l2_ctrl_request_setup(src_req, &ctx->hdl);\n\n\terr = ctx->coded_fmt_desc->decode_run(ctx);\n\n\tv4l2_ctrl_request_complete(src_req, &ctx->hdl);\n\n\tif (err)\n\t\ttegra_job_finish(ctx, VB2_BUF_STATE_ERROR);\n\telse\n\t\tqueue_work(ctx->vde->wq, &ctx->work);\n}\n\nstatic const struct v4l2_m2m_ops tegra_v4l2_m2m_ops = {\n\t.device_run = tegra_device_run,\n};\n\nstatic int tegra_request_validate(struct media_request *req)\n{\n\tunsigned int count;\n\n\tcount = vb2_request_buffer_cnt(req);\n\tif (!count)\n\t\treturn -ENOENT;\n\telse if (count > 1)\n\t\treturn -EINVAL;\n\n\treturn vb2_request_validate(req);\n}\n\nstatic const struct media_device_ops tegra_media_device_ops = {\n\t.req_validate = tegra_request_validate,\n\t.req_queue = v4l2_m2m_request_queue,\n};\n\nint tegra_vde_v4l2_init(struct tegra_vde *vde)\n{\n\tstruct device *dev = vde->dev;\n\tint err;\n\n\tmutex_init(&vde->v4l2_lock);\n\tmedia_device_init(&vde->mdev);\n\tvideo_set_drvdata(&vde->vdev, vde);\n\n\tvde->vdev.lock = &vde->v4l2_lock,\n\tvde->vdev.fops = &tegra_v4l2_fops,\n\tvde->vdev.vfl_dir = VFL_DIR_M2M,\n\tvde->vdev.release = video_device_release_empty,\n\tvde->vdev.v4l2_dev = &vde->v4l2_dev;\n\tvde->vdev.ioctl_ops = &tegra_v4l2_ioctl_ops,\n\tvde->vdev.device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING,\n\n\tvde->v4l2_dev.mdev = &vde->mdev;\n\tvde->mdev.ops = &tegra_media_device_ops;\n\tvde->mdev.dev = dev;\n\n\tstrscpy(vde->mdev.model, \"tegra-vde\", sizeof(vde->mdev.model));\n\tstrscpy(vde->vdev.name,  \"tegra-vde\", sizeof(vde->vdev.name));\n\tstrscpy(vde->mdev.bus_info, \"platform:tegra-vde\",\n\t\tsizeof(vde->mdev.bus_info));\n\n\tvde->wq = create_workqueue(\"tegra-vde\");\n\tif (!vde->wq)\n\t\treturn -ENOMEM;\n\n\terr = media_device_register(&vde->mdev);\n\tif (err) {\n\t\tdev_err(dev, \"failed to register media device: %d\\n\", err);\n\t\tgoto clean_up_media_device;\n\t}\n\n\terr = v4l2_device_register(dev, &vde->v4l2_dev);\n\tif (err) {\n\t\tdev_err(dev, \"failed to register v4l2 device: %d\\n\", err);\n\t\tgoto unreg_media_device;\n\t}\n\n\terr = video_register_device(&vde->vdev, VFL_TYPE_VIDEO, -1);\n\tif (err) {\n\t\tdev_err(dev, \"failed to register video device: %d\\n\", err);\n\t\tgoto unreg_v4l2;\n\t}\n\n\tvde->m2m = v4l2_m2m_init(&tegra_v4l2_m2m_ops);\n\terr = PTR_ERR_OR_ZERO(vde->m2m);\n\tif (err) {\n\t\tdev_err(dev, \"failed to initialize m2m device: %d\\n\", err);\n\t\tgoto unreg_video_device;\n\t}\n\n\terr = v4l2_m2m_register_media_controller(vde->m2m, &vde->vdev,\n\t\t\t\t\t\t MEDIA_ENT_F_PROC_VIDEO_DECODER);\n\tif (err) {\n\t\tdev_err(dev, \"failed to register media controller: %d\\n\", err);\n\t\tgoto release_m2m;\n\t}\n\n\tv4l2_info(&vde->v4l2_dev, \"v4l2 device registered as /dev/video%d\\n\",\n\t\t  vde->vdev.num);\n\n\treturn 0;\n\nrelease_m2m:\n\tv4l2_m2m_release(vde->m2m);\nunreg_video_device:\n\tvideo_unregister_device(&vde->vdev);\nunreg_v4l2:\n\tv4l2_device_unregister(&vde->v4l2_dev);\nunreg_media_device:\n\tmedia_device_unregister(&vde->mdev);\nclean_up_media_device:\n\tmedia_device_cleanup(&vde->mdev);\n\n\tdestroy_workqueue(vde->wq);\n\n\treturn err;\n}\n\nvoid tegra_vde_v4l2_deinit(struct tegra_vde *vde)\n{\n\tv4l2_m2m_unregister_media_controller(vde->m2m);\n\tv4l2_m2m_release(vde->m2m);\n\n\tvideo_unregister_device(&vde->vdev);\n\tv4l2_device_unregister(&vde->v4l2_dev);\n\n\tmedia_device_unregister(&vde->mdev);\n\tmedia_device_cleanup(&vde->mdev);\n\n\tdestroy_workqueue(vde->wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}