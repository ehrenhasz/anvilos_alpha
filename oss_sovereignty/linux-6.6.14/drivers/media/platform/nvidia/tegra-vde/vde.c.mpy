{
  "module_name": "vde.c",
  "hash_id": "2bd0aad492fcb470b5d4110c634215cd393b2df6ae40350c9a4aec2c51749ad4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nvidia/tegra-vde/vde.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-buf.h>\n#include <linux/genalloc.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <soc/tegra/common.h>\n#include <soc/tegra/pmc.h>\n\n#include \"vde.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\nvoid tegra_vde_writel(struct tegra_vde *vde, u32 value,\n\t\t      void __iomem *base, u32 offset)\n{\n\ttrace_vde_writel(vde, base, offset, value);\n\n\twritel_relaxed(value, base + offset);\n}\n\nu32 tegra_vde_readl(struct tegra_vde *vde, void __iomem *base, u32 offset)\n{\n\tu32 value = readl_relaxed(base + offset);\n\n\ttrace_vde_readl(vde, base, offset, value);\n\n\treturn value;\n}\n\nvoid tegra_vde_set_bits(struct tegra_vde *vde, u32 mask,\n\t\t\tvoid __iomem *base, u32 offset)\n{\n\tu32 value = tegra_vde_readl(vde, base, offset);\n\n\ttegra_vde_writel(vde, value | mask, base, offset);\n}\n\nint tegra_vde_alloc_bo(struct tegra_vde *vde,\n\t\t       struct tegra_vde_bo **ret_bo,\n\t\t       enum dma_data_direction dma_dir,\n\t\t       size_t size)\n{\n\tstruct device *dev = vde->dev;\n\tstruct tegra_vde_bo *bo;\n\tint err;\n\n\tbo = kzalloc(sizeof(*bo), GFP_KERNEL);\n\tif (!bo)\n\t\treturn -ENOMEM;\n\n\tbo->vde = vde;\n\tbo->size = size;\n\tbo->dma_dir = dma_dir;\n\tbo->dma_attrs = DMA_ATTR_WRITE_COMBINE |\n\t\t\tDMA_ATTR_NO_KERNEL_MAPPING;\n\n\tif (!vde->domain)\n\t\tbo->dma_attrs |= DMA_ATTR_FORCE_CONTIGUOUS;\n\n\tbo->dma_cookie = dma_alloc_attrs(dev, bo->size, &bo->dma_handle,\n\t\t\t\t\t GFP_KERNEL, bo->dma_attrs);\n\tif (!bo->dma_cookie) {\n\t\tdev_err(dev, \"Failed to allocate DMA buffer of size: %zu\\n\",\n\t\t\tbo->size);\n\t\terr = -ENOMEM;\n\t\tgoto free_bo;\n\t}\n\n\terr = dma_get_sgtable_attrs(dev, &bo->sgt, bo->dma_cookie,\n\t\t\t\t    bo->dma_handle, bo->size, bo->dma_attrs);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to get DMA buffer SG table: %d\\n\", err);\n\t\tgoto free_attrs;\n\t}\n\n\terr = dma_map_sgtable(dev, &bo->sgt, bo->dma_dir, bo->dma_attrs);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to map DMA buffer SG table: %d\\n\", err);\n\t\tgoto free_table;\n\t}\n\n\tif (vde->domain) {\n\t\terr = tegra_vde_iommu_map(vde, &bo->sgt, &bo->iova, bo->size);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to map DMA buffer IOVA: %d\\n\", err);\n\t\t\tgoto unmap_sgtable;\n\t\t}\n\n\t\tbo->dma_addr = iova_dma_addr(&vde->iova, bo->iova);\n\t} else {\n\t\tbo->dma_addr = sg_dma_address(bo->sgt.sgl);\n\t}\n\n\t*ret_bo = bo;\n\n\treturn 0;\n\nunmap_sgtable:\n\tdma_unmap_sgtable(dev, &bo->sgt, bo->dma_dir, bo->dma_attrs);\nfree_table:\n\tsg_free_table(&bo->sgt);\nfree_attrs:\n\tdma_free_attrs(dev, bo->size, bo->dma_cookie, bo->dma_handle,\n\t\t       bo->dma_attrs);\nfree_bo:\n\tkfree(bo);\n\n\treturn err;\n}\n\nvoid tegra_vde_free_bo(struct tegra_vde_bo *bo)\n{\n\tstruct tegra_vde *vde = bo->vde;\n\tstruct device *dev = vde->dev;\n\n\tif (vde->domain)\n\t\ttegra_vde_iommu_unmap(vde, bo->iova);\n\n\tdma_unmap_sgtable(dev, &bo->sgt, bo->dma_dir, bo->dma_attrs);\n\n\tsg_free_table(&bo->sgt);\n\n\tdma_free_attrs(dev, bo->size, bo->dma_cookie, bo->dma_handle,\n\t\t       bo->dma_attrs);\n\tkfree(bo);\n}\n\nstatic irqreturn_t tegra_vde_isr(int irq, void *data)\n{\n\tstruct tegra_vde *vde = data;\n\n\tif (completion_done(&vde->decode_completion))\n\t\treturn IRQ_NONE;\n\n\ttegra_vde_set_bits(vde, 0, vde->frameid, 0x208);\n\tcomplete(&vde->decode_completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic __maybe_unused int tegra_vde_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_vde *vde = dev_get_drvdata(dev);\n\tint err;\n\n\tif (!dev->pm_domain) {\n\t\terr = tegra_powergate_power_off(TEGRA_POWERGATE_VDEC);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to power down HW: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tclk_disable_unprepare(vde->clk);\n\treset_control_release(vde->rst);\n\treset_control_release(vde->rst_mc);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int tegra_vde_runtime_resume(struct device *dev)\n{\n\tstruct tegra_vde *vde = dev_get_drvdata(dev);\n\tint err;\n\n\terr = reset_control_acquire(vde->rst_mc);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to acquire mc reset: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = reset_control_acquire(vde->rst);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to acquire reset: %d\\n\", err);\n\t\tgoto release_mc_reset;\n\t}\n\n\tif (!dev->pm_domain) {\n\t\terr = tegra_powergate_sequence_power_up(TEGRA_POWERGATE_VDEC,\n\t\t\t\t\t\t\tvde->clk, vde->rst);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to power up HW : %d\\n\", err);\n\t\t\tgoto release_reset;\n\t\t}\n\t} else {\n\t\t \n\t\terr = clk_prepare_enable(vde->clk);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to enable clock: %d\\n\", err);\n\t\t\tgoto release_reset;\n\t\t}\n\t}\n\n\treturn 0;\n\nrelease_reset:\n\treset_control_release(vde->rst);\nrelease_mc_reset:\n\treset_control_release(vde->rst_mc);\n\n\treturn err;\n}\n\nstatic int tegra_vde_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra_vde *vde;\n\tint irq, err;\n\n\tvde = devm_kzalloc(dev, sizeof(*vde), GFP_KERNEL);\n\tif (!vde)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, vde);\n\n\tvde->soc = of_device_get_match_data(&pdev->dev);\n\tvde->dev = dev;\n\n\tvde->sxe = devm_platform_ioremap_resource_byname(pdev, \"sxe\");\n\tif (IS_ERR(vde->sxe))\n\t\treturn PTR_ERR(vde->sxe);\n\n\tvde->bsev = devm_platform_ioremap_resource_byname(pdev, \"bsev\");\n\tif (IS_ERR(vde->bsev))\n\t\treturn PTR_ERR(vde->bsev);\n\n\tvde->mbe = devm_platform_ioremap_resource_byname(pdev, \"mbe\");\n\tif (IS_ERR(vde->mbe))\n\t\treturn PTR_ERR(vde->mbe);\n\n\tvde->ppe = devm_platform_ioremap_resource_byname(pdev, \"ppe\");\n\tif (IS_ERR(vde->ppe))\n\t\treturn PTR_ERR(vde->ppe);\n\n\tvde->mce = devm_platform_ioremap_resource_byname(pdev, \"mce\");\n\tif (IS_ERR(vde->mce))\n\t\treturn PTR_ERR(vde->mce);\n\n\tvde->tfe = devm_platform_ioremap_resource_byname(pdev, \"tfe\");\n\tif (IS_ERR(vde->tfe))\n\t\treturn PTR_ERR(vde->tfe);\n\n\tvde->ppb = devm_platform_ioremap_resource_byname(pdev, \"ppb\");\n\tif (IS_ERR(vde->ppb))\n\t\treturn PTR_ERR(vde->ppb);\n\n\tvde->vdma = devm_platform_ioremap_resource_byname(pdev, \"vdma\");\n\tif (IS_ERR(vde->vdma))\n\t\treturn PTR_ERR(vde->vdma);\n\n\tvde->frameid = devm_platform_ioremap_resource_byname(pdev, \"frameid\");\n\tif (IS_ERR(vde->frameid))\n\t\treturn PTR_ERR(vde->frameid);\n\n\tvde->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(vde->clk)) {\n\t\terr = PTR_ERR(vde->clk);\n\t\tdev_err(dev, \"Could not get VDE clk %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tvde->rst = devm_reset_control_get_exclusive_released(dev, NULL);\n\tif (IS_ERR(vde->rst)) {\n\t\terr = PTR_ERR(vde->rst);\n\t\tdev_err(dev, \"Could not get VDE reset %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tvde->rst_mc = devm_reset_control_get_optional_exclusive_released(dev, \"mc\");\n\tif (IS_ERR(vde->rst_mc)) {\n\t\terr = PTR_ERR(vde->rst_mc);\n\t\tdev_err(dev, \"Could not get MC reset %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tirq = platform_get_irq_byname(pdev, \"sync-token\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\terr = devm_request_irq(dev, irq, tegra_vde_isr, 0,\n\t\t\t       dev_name(dev), vde);\n\tif (err) {\n\t\tdev_err(dev, \"Could not request IRQ %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_tegra_core_dev_init_opp_table_common(dev);\n\tif (err) {\n\t\tdev_err(dev, \"Could initialize OPP table %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tvde->iram_pool = of_gen_pool_get(dev->of_node, \"iram\", 0);\n\tif (!vde->iram_pool) {\n\t\tdev_err(dev, \"Could not get IRAM pool\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tvde->iram = gen_pool_dma_alloc(vde->iram_pool,\n\t\t\t\t       gen_pool_size(vde->iram_pool),\n\t\t\t\t       &vde->iram_lists_addr);\n\tif (!vde->iram) {\n\t\tdev_err(dev, \"Could not reserve IRAM\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&vde->map_list);\n\tmutex_init(&vde->map_lock);\n\tmutex_init(&vde->lock);\n\tinit_completion(&vde->decode_completion);\n\n\terr = tegra_vde_iommu_init(vde);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to initialize IOMMU: %d\\n\", err);\n\t\tgoto err_gen_free;\n\t}\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 300);\n\n\t \n\terr = pm_runtime_resume_and_get(dev);\n\tif (err)\n\t\tgoto err_pm_runtime;\n\n\tpm_runtime_put(dev);\n\n\terr = tegra_vde_alloc_bo(vde, &vde->secure_bo, DMA_FROM_DEVICE, 4096);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to allocate secure BO: %d\\n\", err);\n\t\tgoto err_pm_runtime;\n\t}\n\n\terr = tegra_vde_v4l2_init(vde);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to initialize V4L2: %d\\n\", err);\n\t\tgoto err_free_secure_bo;\n\t}\n\n\treturn 0;\n\nerr_free_secure_bo:\n\ttegra_vde_free_bo(vde->secure_bo);\nerr_pm_runtime:\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\n\ttegra_vde_iommu_deinit(vde);\n\nerr_gen_free:\n\tgen_pool_free(vde->iram_pool, (unsigned long)vde->iram,\n\t\t      gen_pool_size(vde->iram_pool));\n\n\treturn err;\n}\n\nstatic void tegra_vde_remove(struct platform_device *pdev)\n{\n\tstruct tegra_vde *vde = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\ttegra_vde_v4l2_deinit(vde);\n\ttegra_vde_free_bo(vde->secure_bo);\n\n\t \n\tpm_runtime_get_sync(dev);\n\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\n\t \n\tpm_runtime_put_noidle(dev);\n\tclk_disable_unprepare(vde->clk);\n\n\ttegra_vde_dmabuf_cache_unmap_all(vde);\n\ttegra_vde_iommu_deinit(vde);\n\n\tgen_pool_free(vde->iram_pool, (unsigned long)vde->iram,\n\t\t      gen_pool_size(vde->iram_pool));\n}\n\nstatic void tegra_vde_shutdown(struct platform_device *pdev)\n{\n\t \n\tpm_runtime_get_sync(&pdev->dev);\n}\n\nstatic __maybe_unused int tegra_vde_pm_suspend(struct device *dev)\n{\n\tstruct tegra_vde *vde = dev_get_drvdata(dev);\n\tint err;\n\n\tmutex_lock(&vde->lock);\n\n\terr = pm_runtime_force_suspend(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic __maybe_unused int tegra_vde_pm_resume(struct device *dev)\n{\n\tstruct tegra_vde *vde = dev_get_drvdata(dev);\n\tint err;\n\n\terr = pm_runtime_force_resume(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_unlock(&vde->lock);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_vde_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra_vde_runtime_suspend,\n\t\t\t   tegra_vde_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(tegra_vde_pm_suspend,\n\t\t\t\ttegra_vde_pm_resume)\n};\n\nstatic const u32 tegra124_decoded_fmts[] = {\n\t \n};\n\nstatic const struct tegra_coded_fmt_desc tegra124_coded_fmts[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_H264_SLICE,\n\t\t.frmsize = {\n\t\t\t.min_width = 16,\n\t\t\t.max_width = 1920,\n\t\t\t.step_width = 16,\n\t\t\t.min_height = 16,\n\t\t\t.max_height = 2032,\n\t\t\t.step_height = 16,\n\t\t},\n\t\t.num_decoded_fmts = ARRAY_SIZE(tegra124_decoded_fmts),\n\t\t.decoded_fmts = tegra124_decoded_fmts,\n\t\t.decode_run = tegra_vde_h264_decode_run,\n\t\t.decode_wait = tegra_vde_h264_decode_wait,\n\t},\n};\n\nstatic const u32 tegra20_decoded_fmts[] = {\n\tV4L2_PIX_FMT_YUV420M,\n\tV4L2_PIX_FMT_YVU420M,\n};\n\nstatic const struct tegra_coded_fmt_desc tegra20_coded_fmts[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_H264_SLICE,\n\t\t.frmsize = {\n\t\t\t.min_width = 16,\n\t\t\t.max_width = 1920,\n\t\t\t.step_width = 16,\n\t\t\t.min_height = 16,\n\t\t\t.max_height = 2032,\n\t\t\t.step_height = 16,\n\t\t},\n\t\t.num_decoded_fmts = ARRAY_SIZE(tegra20_decoded_fmts),\n\t\t.decoded_fmts = tegra20_decoded_fmts,\n\t\t.decode_run = tegra_vde_h264_decode_run,\n\t\t.decode_wait = tegra_vde_h264_decode_wait,\n\t},\n};\n\nstatic const struct tegra_vde_soc tegra124_vde_soc = {\n\t.supports_ref_pic_marking = true,\n\t.coded_fmts = tegra124_coded_fmts,\n\t.num_coded_fmts = ARRAY_SIZE(tegra124_coded_fmts),\n};\n\nstatic const struct tegra_vde_soc tegra114_vde_soc = {\n\t.supports_ref_pic_marking = true,\n\t.coded_fmts = tegra20_coded_fmts,\n\t.num_coded_fmts = ARRAY_SIZE(tegra20_coded_fmts),\n};\n\nstatic const struct tegra_vde_soc tegra30_vde_soc = {\n\t.supports_ref_pic_marking = false,\n\t.coded_fmts = tegra20_coded_fmts,\n\t.num_coded_fmts = ARRAY_SIZE(tegra20_coded_fmts),\n};\n\nstatic const struct tegra_vde_soc tegra20_vde_soc = {\n\t.supports_ref_pic_marking = false,\n\t.coded_fmts = tegra20_coded_fmts,\n\t.num_coded_fmts = ARRAY_SIZE(tegra20_coded_fmts),\n};\n\nstatic const struct of_device_id tegra_vde_of_match[] = {\n\t{ .compatible = \"nvidia,tegra124-vde\", .data = &tegra124_vde_soc },\n\t{ .compatible = \"nvidia,tegra114-vde\", .data = &tegra114_vde_soc },\n\t{ .compatible = \"nvidia,tegra30-vde\", .data = &tegra30_vde_soc },\n\t{ .compatible = \"nvidia,tegra20-vde\", .data = &tegra20_vde_soc },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_vde_of_match);\n\nstatic struct platform_driver tegra_vde_driver = {\n\t.probe\t\t= tegra_vde_probe,\n\t.remove_new\t= tegra_vde_remove,\n\t.shutdown\t= tegra_vde_shutdown,\n\t.driver\t\t= {\n\t\t.name\t\t= \"tegra-vde\",\n\t\t.of_match_table = tegra_vde_of_match,\n\t\t.pm\t\t= &tegra_vde_pm_ops,\n\t},\n};\nmodule_platform_driver(tegra_vde_driver);\n\nMODULE_DESCRIPTION(\"NVIDIA Tegra Video Decoder driver\");\nMODULE_AUTHOR(\"Dmitry Osipenko <digetx@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}