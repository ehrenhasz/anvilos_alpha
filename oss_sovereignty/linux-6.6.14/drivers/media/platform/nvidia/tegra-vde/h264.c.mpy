{
  "module_name": "h264.c",
  "hash_id": "1038154403e4f1c9d18ce47bd311e6fa051fb0a9bfbe8871cf6d26e1bfe7d607",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nvidia/tegra-vde/h264.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include <media/v4l2-h264.h>\n\n#include \"trace.h\"\n#include \"vde.h\"\n\n#define FLAG_B_FRAME\t\t0x1\n#define FLAG_REFERENCE\t\t0x2\n\nstruct tegra_vde_h264_frame {\n\tunsigned int frame_num;\n\tunsigned int flags;\n};\n\nstruct tegra_vde_h264_decoder_ctx {\n\tunsigned int dpb_frames_nb;\n\tunsigned int dpb_ref_frames_with_earlier_poc_nb;\n\tunsigned int baseline_profile;\n\tunsigned int level_idc;\n\tunsigned int log2_max_pic_order_cnt_lsb;\n\tunsigned int log2_max_frame_num;\n\tunsigned int pic_order_cnt_type;\n\tunsigned int direct_8x8_inference_flag;\n\tunsigned int pic_width_in_mbs;\n\tunsigned int pic_height_in_mbs;\n\tunsigned int pic_init_qp;\n\tunsigned int deblocking_filter_control_present_flag;\n\tunsigned int constrained_intra_pred_flag;\n\tunsigned int chroma_qp_index_offset;\n\tunsigned int pic_order_present_flag;\n\tunsigned int num_ref_idx_l0_active_minus1;\n\tunsigned int num_ref_idx_l1_active_minus1;\n};\n\nstruct h264_reflists {\n\tstruct v4l2_h264_reference p[V4L2_H264_NUM_DPB_ENTRIES];\n\tstruct v4l2_h264_reference b0[V4L2_H264_NUM_DPB_ENTRIES];\n\tstruct v4l2_h264_reference b1[V4L2_H264_NUM_DPB_ENTRIES];\n};\n\nstatic int tegra_vde_wait_mbe(struct tegra_vde *vde)\n{\n\tu32 tmp;\n\n\treturn readl_relaxed_poll_timeout(vde->mbe + 0x8C, tmp,\n\t\t\t\t\t  tmp >= 0x10, 1, 100);\n}\n\nstatic int tegra_vde_setup_mbe_frame_idx(struct tegra_vde *vde,\n\t\t\t\t\t unsigned int refs_nb,\n\t\t\t\t\t bool setup_refs)\n{\n\tu32 value, frame_idx_enb_mask = 0;\n\tunsigned int frame_idx;\n\tunsigned int idx;\n\tint err;\n\n\ttegra_vde_writel(vde, 0xD0000000 | (0 << 23), vde->mbe, 0x80);\n\ttegra_vde_writel(vde, 0xD0200000 | (0 << 23), vde->mbe, 0x80);\n\n\terr = tegra_vde_wait_mbe(vde);\n\tif (err)\n\t\treturn err;\n\n\tif (!setup_refs)\n\t\treturn 0;\n\n\tfor (idx = 0, frame_idx = 1; idx < refs_nb; idx++, frame_idx++) {\n\t\ttegra_vde_writel(vde, 0xD0000000 | (frame_idx << 23),\n\t\t\t\t vde->mbe, 0x80);\n\t\ttegra_vde_writel(vde, 0xD0200000 | (frame_idx << 23),\n\t\t\t\t vde->mbe, 0x80);\n\n\t\tframe_idx_enb_mask |= frame_idx << (6 * (idx % 4));\n\n\t\tif (idx % 4 == 3 || idx == refs_nb - 1) {\n\t\t\tvalue = 0xC0000000;\n\t\t\tvalue |= (idx >> 2) << 24;\n\t\t\tvalue |= frame_idx_enb_mask;\n\n\t\t\ttegra_vde_writel(vde, value, vde->mbe, 0x80);\n\n\t\t\terr = tegra_vde_wait_mbe(vde);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tframe_idx_enb_mask = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_vde_mbe_set_0xa_reg(struct tegra_vde *vde, int reg, u32 val)\n{\n\ttegra_vde_writel(vde, 0xA0000000 | (reg << 24) | (val & 0xFFFF),\n\t\t\t vde->mbe, 0x80);\n\ttegra_vde_writel(vde, 0xA0000000 | ((reg + 1) << 24) | (val >> 16),\n\t\t\t vde->mbe, 0x80);\n}\n\nstatic int tegra_vde_wait_bsev(struct tegra_vde *vde, bool wait_dma)\n{\n\tstruct device *dev = vde->dev;\n\tu32 value;\n\tint err;\n\n\terr = readl_relaxed_poll_timeout(vde->bsev + INTR_STATUS, value,\n\t\t\t\t\t !(value & BIT(2)), 1, 100);\n\tif (err) {\n\t\tdev_err(dev, \"BSEV unknown bit timeout\\n\");\n\t\treturn err;\n\t}\n\n\terr = readl_relaxed_poll_timeout(vde->bsev + INTR_STATUS, value,\n\t\t\t\t\t (value & BSE_ICMDQUE_EMPTY), 1, 100);\n\tif (err) {\n\t\tdev_err(dev, \"BSEV ICMDQUE flush timeout\\n\");\n\t\treturn err;\n\t}\n\n\tif (!wait_dma)\n\t\treturn 0;\n\n\terr = readl_relaxed_poll_timeout(vde->bsev + INTR_STATUS, value,\n\t\t\t\t\t !(value & BSE_DMA_BUSY), 1, 1000);\n\tif (err) {\n\t\tdev_err(dev, \"BSEV DMA timeout\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_vde_push_to_bsev_icmdqueue(struct tegra_vde *vde,\n\t\t\t\t\t    u32 value, bool wait_dma)\n{\n\ttegra_vde_writel(vde, value, vde->bsev, ICMDQUE_WR);\n\n\treturn tegra_vde_wait_bsev(vde, wait_dma);\n}\n\nstatic void tegra_vde_setup_frameid(struct tegra_vde *vde,\n\t\t\t\t    struct tegra_video_frame *frame,\n\t\t\t\t    unsigned int frameid,\n\t\t\t\t    u32 mbs_width, u32 mbs_height)\n{\n\tu32 y_addr  = frame ? frame->y_addr  : 0x6CDEAD00;\n\tu32 cb_addr = frame ? frame->cb_addr : 0x6CDEAD00;\n\tu32 cr_addr = frame ? frame->cr_addr : 0x6CDEAD00;\n\tu32 value1 = frame ? ((frame->luma_atoms_pitch << 16) | mbs_height) : 0;\n\tu32 value2 = frame ? ((frame->chroma_atoms_pitch << 6) | 1) : 0;\n\n\ttegra_vde_writel(vde, y_addr  >> 8, vde->frameid, 0x000 + frameid * 4);\n\ttegra_vde_writel(vde, cb_addr >> 8, vde->frameid, 0x100 + frameid * 4);\n\ttegra_vde_writel(vde, cr_addr >> 8, vde->frameid, 0x180 + frameid * 4);\n\ttegra_vde_writel(vde, value1,       vde->frameid, 0x080 + frameid * 4);\n\ttegra_vde_writel(vde, value2,       vde->frameid, 0x280 + frameid * 4);\n}\n\nstatic void tegra_setup_frameidx(struct tegra_vde *vde,\n\t\t\t\t struct tegra_video_frame *frames,\n\t\t\t\t unsigned int frames_nb,\n\t\t\t\t u32 mbs_width, u32 mbs_height)\n{\n\tunsigned int idx;\n\n\tfor (idx = 0; idx < frames_nb; idx++)\n\t\ttegra_vde_setup_frameid(vde, &frames[idx], idx,\n\t\t\t\t\tmbs_width, mbs_height);\n\n\tfor (; idx < 17; idx++)\n\t\ttegra_vde_setup_frameid(vde, NULL, idx, 0, 0);\n}\n\nstatic void tegra_vde_setup_iram_entry(struct tegra_vde *vde,\n\t\t\t\t       unsigned int table,\n\t\t\t\t       unsigned int row,\n\t\t\t\t       u32 value1, u32 value2)\n{\n\tu32 *iram_tables = vde->iram;\n\n\ttrace_vde_setup_iram_entry(table, row, value1, value2);\n\n\tiram_tables[0x20 * table + row * 2 + 0] = value1;\n\tiram_tables[0x20 * table + row * 2 + 1] = value2;\n}\n\nstatic void tegra_vde_setup_iram_tables(struct tegra_vde *vde,\n\t\t\t\t\tstruct tegra_video_frame *dpb_frames,\n\t\t\t\t\tunsigned int ref_frames_nb,\n\t\t\t\t\tunsigned int with_earlier_poc_nb)\n{\n\tstruct tegra_video_frame *frame;\n\tint with_later_poc_nb;\n\tu32 value, aux_addr;\n\tunsigned int i, k;\n\n\ttrace_vde_ref_l0(dpb_frames[0].frame_num);\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (i < ref_frames_nb) {\n\t\t\tframe = &dpb_frames[i + 1];\n\n\t\t\taux_addr = frame->aux_addr;\n\n\t\t\tvalue  = (i + 1) << 26;\n\t\t\tvalue |= !(frame->flags & FLAG_B_FRAME) << 25;\n\t\t\tvalue |= 1 << 24;\n\t\t\tvalue |= frame->frame_num;\n\t\t} else {\n\t\t\taux_addr = 0x6ADEAD00;\n\t\t\tvalue = 0x3f;\n\t\t}\n\n\t\ttegra_vde_setup_iram_entry(vde, 0, i, value, aux_addr);\n\t\ttegra_vde_setup_iram_entry(vde, 1, i, value, aux_addr);\n\t\ttegra_vde_setup_iram_entry(vde, 2, i, value, aux_addr);\n\t\ttegra_vde_setup_iram_entry(vde, 3, i, value, aux_addr);\n\t}\n\n\tif (!(dpb_frames[0].flags & FLAG_B_FRAME))\n\t\treturn;\n\n\tif (with_earlier_poc_nb >= ref_frames_nb)\n\t\treturn;\n\n\twith_later_poc_nb = ref_frames_nb - with_earlier_poc_nb;\n\n\ttrace_vde_ref_l1(with_later_poc_nb, with_earlier_poc_nb);\n\n\tfor (i = 0, k = with_earlier_poc_nb; i < with_later_poc_nb; i++, k++) {\n\t\tframe = &dpb_frames[k + 1];\n\n\t\taux_addr = frame->aux_addr;\n\n\t\tvalue  = (k + 1) << 26;\n\t\tvalue |= !(frame->flags & FLAG_B_FRAME) << 25;\n\t\tvalue |= 1 << 24;\n\t\tvalue |= frame->frame_num;\n\n\t\ttegra_vde_setup_iram_entry(vde, 2, i, value, aux_addr);\n\t}\n\n\tfor (k = 0; i < ref_frames_nb; i++, k++) {\n\t\tframe = &dpb_frames[k + 1];\n\n\t\taux_addr = frame->aux_addr;\n\n\t\tvalue  = (k + 1) << 26;\n\t\tvalue |= !(frame->flags & FLAG_B_FRAME) << 25;\n\t\tvalue |= 1 << 24;\n\t\tvalue |= frame->frame_num;\n\n\t\ttegra_vde_setup_iram_entry(vde, 2, i, value, aux_addr);\n\t}\n}\n\nstatic int tegra_vde_setup_hw_context(struct tegra_vde *vde,\n\t\t\t\t      struct tegra_vde_h264_decoder_ctx *ctx,\n\t\t\t\t      struct tegra_video_frame *dpb_frames,\n\t\t\t\t      dma_addr_t bitstream_data_addr,\n\t\t\t\t      size_t bitstream_data_size,\n\t\t\t\t      unsigned int macroblocks_nb)\n{\n\tstruct device *dev = vde->dev;\n\tu32 value;\n\tint err;\n\n\ttegra_vde_set_bits(vde, 0x000A, vde->sxe, 0xF0);\n\ttegra_vde_set_bits(vde, 0x000B, vde->bsev, CMDQUE_CONTROL);\n\ttegra_vde_set_bits(vde, 0x8002, vde->mbe, 0x50);\n\ttegra_vde_set_bits(vde, 0x000A, vde->mbe, 0xA0);\n\ttegra_vde_set_bits(vde, 0x000A, vde->ppe, 0x14);\n\ttegra_vde_set_bits(vde, 0x000A, vde->ppe, 0x28);\n\ttegra_vde_set_bits(vde, 0x0A00, vde->mce, 0x08);\n\ttegra_vde_set_bits(vde, 0x000A, vde->tfe, 0x00);\n\ttegra_vde_set_bits(vde, 0x0005, vde->vdma, 0x04);\n\n\ttegra_vde_writel(vde, 0x00000000, vde->vdma, 0x1C);\n\ttegra_vde_writel(vde, 0x00000000, vde->vdma, 0x00);\n\ttegra_vde_writel(vde, 0x00000007, vde->vdma, 0x04);\n\ttegra_vde_writel(vde, 0x00000007, vde->frameid, 0x200);\n\ttegra_vde_writel(vde, 0x00000005, vde->tfe, 0x04);\n\ttegra_vde_writel(vde, 0x00000000, vde->mbe, 0x84);\n\ttegra_vde_writel(vde, 0x00000010, vde->sxe, 0x08);\n\ttegra_vde_writel(vde, 0x00000150, vde->sxe, 0x54);\n\ttegra_vde_writel(vde, 0x0000054C, vde->sxe, 0x58);\n\ttegra_vde_writel(vde, 0x00000E34, vde->sxe, 0x5C);\n\ttegra_vde_writel(vde, 0x063C063C, vde->mce, 0x10);\n\ttegra_vde_writel(vde, 0x0003FC00, vde->bsev, INTR_STATUS);\n\ttegra_vde_writel(vde, 0x0000150D, vde->bsev, BSE_CONFIG);\n\ttegra_vde_writel(vde, 0x00000100, vde->bsev, BSE_INT_ENB);\n\ttegra_vde_writel(vde, 0x00000000, vde->bsev, 0x98);\n\ttegra_vde_writel(vde, 0x00000060, vde->bsev, 0x9C);\n\n\tmemset(vde->iram + 128, 0, macroblocks_nb / 2);\n\n\ttegra_setup_frameidx(vde, dpb_frames, ctx->dpb_frames_nb,\n\t\t\t     ctx->pic_width_in_mbs, ctx->pic_height_in_mbs);\n\n\ttegra_vde_setup_iram_tables(vde, dpb_frames,\n\t\t\t\t    ctx->dpb_frames_nb - 1,\n\t\t\t\t    ctx->dpb_ref_frames_with_earlier_poc_nb);\n\n\t \n\twmb();\n\n\ttegra_vde_writel(vde, 0x00000000, vde->bsev, 0x8C);\n\ttegra_vde_writel(vde, bitstream_data_addr + bitstream_data_size,\n\t\t\t vde->bsev, 0x54);\n\n\tvde->bitstream_data_addr = bitstream_data_addr;\n\n\tvalue = ctx->pic_width_in_mbs << 11 | ctx->pic_height_in_mbs << 3;\n\n\ttegra_vde_writel(vde, value, vde->bsev, 0x88);\n\n\terr = tegra_vde_wait_bsev(vde, false);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_vde_push_to_bsev_icmdqueue(vde, 0x800003FC, false);\n\tif (err)\n\t\treturn err;\n\n\tvalue = 0x01500000;\n\tvalue |= ((vde->iram_lists_addr + 512) >> 2) & 0xFFFF;\n\n\terr = tegra_vde_push_to_bsev_icmdqueue(vde, value, true);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_vde_push_to_bsev_icmdqueue(vde, 0x840F054C, false);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_vde_push_to_bsev_icmdqueue(vde, 0x80000080, false);\n\tif (err)\n\t\treturn err;\n\n\tvalue = 0x0E340000 | ((vde->iram_lists_addr >> 2) & 0xFFFF);\n\n\terr = tegra_vde_push_to_bsev_icmdqueue(vde, value, true);\n\tif (err)\n\t\treturn err;\n\n\tvalue = 0x00800005;\n\tvalue |= ctx->pic_width_in_mbs << 11;\n\tvalue |= ctx->pic_height_in_mbs << 3;\n\n\ttegra_vde_writel(vde, value, vde->sxe, 0x10);\n\n\tvalue = !ctx->baseline_profile << 17;\n\tvalue |= ctx->level_idc << 13;\n\tvalue |= ctx->log2_max_pic_order_cnt_lsb << 7;\n\tvalue |= ctx->pic_order_cnt_type << 5;\n\tvalue |= ctx->log2_max_frame_num;\n\n\ttegra_vde_writel(vde, value, vde->sxe, 0x40);\n\n\tvalue = ctx->pic_init_qp << 25;\n\tvalue |= !!(ctx->deblocking_filter_control_present_flag) << 2;\n\tvalue |= !!ctx->pic_order_present_flag;\n\n\ttegra_vde_writel(vde, value, vde->sxe, 0x44);\n\n\tvalue = ctx->chroma_qp_index_offset;\n\tvalue |= ctx->num_ref_idx_l0_active_minus1 << 5;\n\tvalue |= ctx->num_ref_idx_l1_active_minus1 << 10;\n\tvalue |= !!ctx->constrained_intra_pred_flag << 15;\n\n\ttegra_vde_writel(vde, value, vde->sxe, 0x48);\n\n\tvalue = 0x0C000000;\n\tvalue |= !!(dpb_frames[0].flags & FLAG_B_FRAME) << 24;\n\n\ttegra_vde_writel(vde, value, vde->sxe, 0x4C);\n\n\tvalue = 0x03800000;\n\tvalue |= bitstream_data_size & GENMASK(19, 15);\n\n\ttegra_vde_writel(vde, value, vde->sxe, 0x68);\n\n\ttegra_vde_writel(vde, bitstream_data_addr, vde->sxe, 0x6C);\n\n\tif (vde->soc->supports_ref_pic_marking)\n\t\ttegra_vde_writel(vde, vde->secure_bo->dma_addr, vde->sxe, 0x7c);\n\n\tvalue = 0x10000005;\n\tvalue |= ctx->pic_width_in_mbs << 11;\n\tvalue |= ctx->pic_height_in_mbs << 3;\n\n\ttegra_vde_writel(vde, value, vde->mbe, 0x80);\n\n\tvalue = 0x26800000;\n\tvalue |= ctx->level_idc << 4;\n\tvalue |= !ctx->baseline_profile << 1;\n\tvalue |= !!ctx->direct_8x8_inference_flag;\n\n\ttegra_vde_writel(vde, value, vde->mbe, 0x80);\n\n\ttegra_vde_writel(vde, 0xF4000001, vde->mbe, 0x80);\n\ttegra_vde_writel(vde, 0x20000000, vde->mbe, 0x80);\n\ttegra_vde_writel(vde, 0xF4000101, vde->mbe, 0x80);\n\n\tvalue = 0x20000000;\n\tvalue |= ctx->chroma_qp_index_offset << 8;\n\n\ttegra_vde_writel(vde, value, vde->mbe, 0x80);\n\n\terr = tegra_vde_setup_mbe_frame_idx(vde,\n\t\t\t\t\t    ctx->dpb_frames_nb - 1,\n\t\t\t\t\t    ctx->pic_order_cnt_type == 0);\n\tif (err) {\n\t\tdev_err(dev, \"MBE frames setup failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttegra_vde_mbe_set_0xa_reg(vde, 0, 0x000009FC);\n\ttegra_vde_mbe_set_0xa_reg(vde, 2, 0x61DEAD00);\n\ttegra_vde_mbe_set_0xa_reg(vde, 4, 0x62DEAD00);\n\ttegra_vde_mbe_set_0xa_reg(vde, 6, 0x63DEAD00);\n\ttegra_vde_mbe_set_0xa_reg(vde, 8, dpb_frames[0].aux_addr);\n\n\tvalue = 0xFC000000;\n\tvalue |= !!(dpb_frames[0].flags & FLAG_B_FRAME) << 2;\n\n\tif (!ctx->baseline_profile)\n\t\tvalue |= !!(dpb_frames[0].flags & FLAG_REFERENCE) << 1;\n\n\ttegra_vde_writel(vde, value, vde->mbe, 0x80);\n\n\terr = tegra_vde_wait_mbe(vde);\n\tif (err) {\n\t\tdev_err(dev, \"MBE programming failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_vde_decode_frame(struct tegra_vde *vde,\n\t\t\t\t   unsigned int macroblocks_nb)\n{\n\treinit_completion(&vde->decode_completion);\n\n\ttegra_vde_writel(vde, 0x00000001, vde->bsev, 0x8C);\n\ttegra_vde_writel(vde, 0x20000000 | (macroblocks_nb - 1),\n\t\t\t vde->sxe, 0x00);\n}\n\nstatic int tegra_vde_validate_h264_ctx(struct device *dev,\n\t\t\t\t       struct tegra_vde_h264_decoder_ctx *ctx)\n{\n\tif (ctx->dpb_frames_nb == 0 || ctx->dpb_frames_nb > 17) {\n\t\tdev_err(dev, \"Bad DPB size %u\\n\", ctx->dpb_frames_nb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->level_idc > 15) {\n\t\tdev_err(dev, \"Bad level value %u\\n\", ctx->level_idc);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->pic_init_qp > 52) {\n\t\tdev_err(dev, \"Bad pic_init_qp value %u\\n\", ctx->pic_init_qp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->log2_max_pic_order_cnt_lsb > 16) {\n\t\tdev_err(dev, \"Bad log2_max_pic_order_cnt_lsb value %u\\n\",\n\t\t\tctx->log2_max_pic_order_cnt_lsb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->log2_max_frame_num > 16) {\n\t\tdev_err(dev, \"Bad log2_max_frame_num value %u\\n\",\n\t\t\tctx->log2_max_frame_num);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->chroma_qp_index_offset > 31) {\n\t\tdev_err(dev, \"Bad chroma_qp_index_offset value %u\\n\",\n\t\t\tctx->chroma_qp_index_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->pic_order_cnt_type > 2) {\n\t\tdev_err(dev, \"Bad pic_order_cnt_type value %u\\n\",\n\t\t\tctx->pic_order_cnt_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->num_ref_idx_l0_active_minus1 > 15) {\n\t\tdev_err(dev, \"Bad num_ref_idx_l0_active_minus1 value %u\\n\",\n\t\t\tctx->num_ref_idx_l0_active_minus1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->num_ref_idx_l1_active_minus1 > 15) {\n\t\tdev_err(dev, \"Bad num_ref_idx_l1_active_minus1 value %u\\n\",\n\t\t\tctx->num_ref_idx_l1_active_minus1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ctx->pic_width_in_mbs || ctx->pic_width_in_mbs > 127) {\n\t\tdev_err(dev, \"Bad pic_width_in_mbs value %u\\n\",\n\t\t\tctx->pic_width_in_mbs);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ctx->pic_height_in_mbs || ctx->pic_height_in_mbs > 127) {\n\t\tdev_err(dev, \"Bad pic_height_in_mbs value %u\\n\",\n\t\t\tctx->pic_height_in_mbs);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_vde_decode_begin(struct tegra_vde *vde,\n\t\t\t\t  struct tegra_vde_h264_decoder_ctx *ctx,\n\t\t\t\t  struct tegra_video_frame *dpb_frames,\n\t\t\t\t  dma_addr_t bitstream_data_addr,\n\t\t\t\t  size_t bitstream_data_size)\n{\n\tstruct device *dev = vde->dev;\n\tunsigned int macroblocks_nb;\n\tint err;\n\n\terr = mutex_lock_interruptible(&vde->lock);\n\tif (err)\n\t\treturn err;\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\t \n\terr = reset_control_assert(vde->rst_mc);\n\tif (err) {\n\t\tdev_err(dev, \"DEC start: Failed to assert MC reset: %d\\n\",\n\t\t\terr);\n\t\tgoto put_runtime_pm;\n\t}\n\n\terr = reset_control_reset(vde->rst);\n\tif (err) {\n\t\tdev_err(dev, \"DEC start: Failed to reset HW: %d\\n\", err);\n\t\tgoto put_runtime_pm;\n\t}\n\n\terr = reset_control_deassert(vde->rst_mc);\n\tif (err) {\n\t\tdev_err(dev, \"DEC start: Failed to deassert MC reset: %d\\n\",\n\t\t\terr);\n\t\tgoto put_runtime_pm;\n\t}\n\n\tmacroblocks_nb = ctx->pic_width_in_mbs * ctx->pic_height_in_mbs;\n\n\terr = tegra_vde_setup_hw_context(vde, ctx, dpb_frames,\n\t\t\t\t\t bitstream_data_addr,\n\t\t\t\t\t bitstream_data_size,\n\t\t\t\t\t macroblocks_nb);\n\tif (err)\n\t\tgoto put_runtime_pm;\n\n\ttegra_vde_decode_frame(vde, macroblocks_nb);\n\n\treturn 0;\n\nput_runtime_pm:\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\nunlock:\n\tmutex_unlock(&vde->lock);\n\n\treturn err;\n}\n\nstatic void tegra_vde_decode_abort(struct tegra_vde *vde)\n{\n\tstruct device *dev = vde->dev;\n\tint err;\n\n\t \n\terr = reset_control_assert(vde->rst_mc);\n\tif (err)\n\t\tdev_err(dev, \"DEC end: Failed to assert MC reset: %d\\n\", err);\n\n\terr = reset_control_assert(vde->rst);\n\tif (err)\n\t\tdev_err(dev, \"DEC end: Failed to assert HW reset: %d\\n\", err);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\tmutex_unlock(&vde->lock);\n}\n\nstatic int tegra_vde_decode_end(struct tegra_vde *vde)\n{\n\tunsigned int read_bytes, macroblocks_nb;\n\tstruct device *dev = vde->dev;\n\tdma_addr_t bsev_ptr;\n\tlong timeout;\n\tint ret;\n\n\ttimeout = wait_for_completion_interruptible_timeout(\n\t\t\t&vde->decode_completion, msecs_to_jiffies(1000));\n\tif (timeout == 0) {\n\t\tbsev_ptr = tegra_vde_readl(vde, vde->bsev, 0x10);\n\t\tmacroblocks_nb = tegra_vde_readl(vde, vde->sxe, 0xC8) & 0x1FFF;\n\t\tread_bytes = bsev_ptr ? bsev_ptr - vde->bitstream_data_addr : 0;\n\n\t\tdev_err(dev, \"Decoding failed: read 0x%X bytes, %u macroblocks parsed\\n\",\n\t\t\tread_bytes, macroblocks_nb);\n\n\t\tret = -EIO;\n\t} else if (timeout < 0) {\n\t\tret = timeout;\n\t} else {\n\t\tret = 0;\n\t}\n\n\ttegra_vde_decode_abort(vde);\n\n\treturn ret;\n}\n\nstatic struct vb2_buffer *get_ref_buf(struct tegra_ctx *ctx,\n\t\t\t\t      struct vb2_v4l2_buffer *dst,\n\t\t\t\t      unsigned int dpb_idx)\n{\n\tconst struct v4l2_h264_dpb_entry *dpb = ctx->h264.decode_params->dpb;\n\tstruct vb2_queue *cap_q = &ctx->fh.m2m_ctx->cap_q_ctx.q;\n\tstruct vb2_buffer *vb = NULL;\n\n\tif (dpb[dpb_idx].flags & V4L2_H264_DPB_ENTRY_FLAG_ACTIVE)\n\t\tvb = vb2_find_buffer(cap_q, dpb[dpb_idx].reference_ts);\n\n\t \n\tif (!vb)\n\t\treturn &dst->vb2_buf;\n\n\treturn vb;\n}\n\nstatic int tegra_vde_validate_vb_size(struct tegra_ctx *ctx,\n\t\t\t\t      struct vb2_buffer *vb,\n\t\t\t\t      unsigned int plane_id,\n\t\t\t\t      size_t min_size)\n{\n\tu64 offset = vb->planes[plane_id].data_offset;\n\tstruct device *dev = ctx->vde->dev;\n\n\tif (offset + min_size > vb2_plane_size(vb, plane_id)) {\n\t\tdev_err(dev, \"Too small plane[%u] size %lu @0x%llX, should be at least %zu\\n\",\n\t\t\tplane_id, vb2_plane_size(vb, plane_id), offset, min_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_vde_h264_setup_frame(struct tegra_ctx *ctx,\n\t\t\t\t      struct tegra_vde_h264_decoder_ctx *h264,\n\t\t\t\t      struct v4l2_h264_reflist_builder *b,\n\t\t\t\t      struct vb2_buffer *vb,\n\t\t\t\t      unsigned int ref_id,\n\t\t\t\t      unsigned int id)\n{\n\tstruct v4l2_pix_format_mplane *pixfmt = &ctx->decoded_fmt.fmt.pix_mp;\n\tstruct tegra_m2m_buffer *tb = vb_to_tegra_buf(vb);\n\tstruct tegra_ctx_h264 *h = &ctx->h264;\n\tstruct tegra_vde *vde = ctx->vde;\n\tstruct device *dev = vde->dev;\n\tunsigned int cstride, lstride;\n\tunsigned int flags = 0;\n\tsize_t lsize, csize;\n\tint err, frame_num;\n\n\tlsize = h264->pic_width_in_mbs * 16 * h264->pic_height_in_mbs * 16;\n\tcsize = h264->pic_width_in_mbs *  8 * h264->pic_height_in_mbs *  8;\n\tlstride = pixfmt->plane_fmt[0].bytesperline;\n\tcstride = pixfmt->plane_fmt[1].bytesperline;\n\n\terr = tegra_vde_validate_vb_size(ctx, vb, 0, lsize);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_vde_validate_vb_size(ctx, vb, 1, csize);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_vde_validate_vb_size(ctx, vb, 2, csize);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb->aux || tb->aux->size < csize) {\n\t\tdev_err(dev, \"Too small aux size %zd, should be at least %zu\\n\",\n\t\t\ttb->aux ? tb->aux->size : -1, csize);\n\t\treturn -EINVAL;\n\t}\n\n\tif (id == 0) {\n\t\tframe_num = h->decode_params->frame_num;\n\n\t\tif (h->decode_params->nal_ref_idc)\n\t\t\tflags |= FLAG_REFERENCE;\n\t} else {\n\t\tframe_num = b->refs[ref_id].frame_num;\n\t}\n\n\tif (tb->b_frame)\n\t\tflags |= FLAG_B_FRAME;\n\n\tvde->frames[id].flags = flags;\n\tvde->frames[id].y_addr = tb->dma_addr[0];\n\tvde->frames[id].cb_addr = tb->dma_addr[1];\n\tvde->frames[id].cr_addr = tb->dma_addr[2];\n\tvde->frames[id].aux_addr = tb->aux->dma_addr;\n\tvde->frames[id].frame_num = frame_num & 0x7fffff;\n\tvde->frames[id].luma_atoms_pitch = lstride / VDE_ATOM;\n\tvde->frames[id].chroma_atoms_pitch = cstride / VDE_ATOM;\n\n\treturn 0;\n}\n\nstatic int tegra_vde_h264_setup_frames(struct tegra_ctx *ctx,\n\t\t\t\t       struct tegra_vde_h264_decoder_ctx *h264)\n{\n\tstruct vb2_v4l2_buffer *src = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tstruct vb2_v4l2_buffer *dst = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tconst struct v4l2_h264_dpb_entry *dpb = ctx->h264.decode_params->dpb;\n\tstruct tegra_m2m_buffer *tb = vb_to_tegra_buf(&dst->vb2_buf);\n\tstruct tegra_ctx_h264 *h = &ctx->h264;\n\tstruct v4l2_h264_reflist_builder b;\n\tstruct v4l2_h264_reference *dpb_id;\n\tstruct h264_reflists reflists;\n\tstruct vb2_buffer *ref;\n\tunsigned int i;\n\tint err;\n\n\t \n\tv4l2_m2m_buf_copy_metadata(src, dst, true);\n\n\tif (h->decode_params->flags & V4L2_H264_DECODE_PARAM_FLAG_BFRAME)\n\t\ttb->b_frame = true;\n\telse\n\t\ttb->b_frame = false;\n\n\terr = tegra_vde_h264_setup_frame(ctx, h264, NULL, &dst->vb2_buf, 0,\n\t\t\t\t\t h264->dpb_frames_nb++);\n\tif (err)\n\t\treturn err;\n\n\tif (!(h->decode_params->flags & (V4L2_H264_DECODE_PARAM_FLAG_PFRAME |\n\t\t\t\t\t V4L2_H264_DECODE_PARAM_FLAG_BFRAME)))\n\t\treturn 0;\n\n\tv4l2_h264_init_reflist_builder(&b, h->decode_params, h->sps, dpb);\n\n\tif (h->decode_params->flags & V4L2_H264_DECODE_PARAM_FLAG_BFRAME) {\n\t\tv4l2_h264_build_b_ref_lists(&b, reflists.b0, reflists.b1);\n\t\tdpb_id = reflists.b0;\n\t} else {\n\t\tv4l2_h264_build_p_ref_list(&b, reflists.p);\n\t\tdpb_id = reflists.p;\n\t}\n\n\tfor (i = 0; i < b.num_valid; i++) {\n\t\tint dpb_idx = dpb_id[i].index;\n\n\t\tref = get_ref_buf(ctx, dst, dpb_idx);\n\n\t\terr = tegra_vde_h264_setup_frame(ctx, h264, &b, ref, dpb_idx,\n\t\t\t\t\t\t h264->dpb_frames_nb++);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (b.refs[dpb_idx].top_field_order_cnt < b.cur_pic_order_count)\n\t\t\th264->dpb_ref_frames_with_earlier_poc_nb++;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int to_tegra_vde_h264_level_idc(unsigned int level_idc)\n{\n\tswitch (level_idc) {\n\tcase 11:\n\t\treturn 2;\n\tcase 12:\n\t\treturn 3;\n\tcase 13:\n\t\treturn 4;\n\tcase 20:\n\t\treturn 5;\n\tcase 21:\n\t\treturn 6;\n\tcase 22:\n\t\treturn 7;\n\tcase 30:\n\t\treturn 8;\n\tcase 31:\n\t\treturn 9;\n\tcase 32:\n\t\treturn 10;\n\tcase 40:\n\t\treturn 11;\n\tcase 41:\n\t\treturn 12;\n\tcase 42:\n\t\treturn 13;\n\tcase 50:\n\t\treturn 14;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 15;\n}\n\nstatic int tegra_vde_h264_setup_context(struct tegra_ctx *ctx,\n\t\t\t\t\tstruct tegra_vde_h264_decoder_ctx *h264)\n{\n\tstruct tegra_ctx_h264 *h = &ctx->h264;\n\tstruct tegra_vde *vde = ctx->vde;\n\tstruct device *dev = vde->dev;\n\tint err;\n\n\tmemset(h264, 0, sizeof(*h264));\n\tmemset(vde->frames, 0, sizeof(vde->frames));\n\n\ttegra_vde_prepare_control_data(ctx, V4L2_CID_STATELESS_H264_DECODE_PARAMS);\n\ttegra_vde_prepare_control_data(ctx, V4L2_CID_STATELESS_H264_SPS);\n\ttegra_vde_prepare_control_data(ctx, V4L2_CID_STATELESS_H264_PPS);\n\n\t \n\tif (h->pps->flags & V4L2_H264_PPS_FLAG_ENTROPY_CODING_MODE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (h->decode_params->flags & V4L2_H264_DECODE_PARAM_FLAG_FIELD_PIC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (h->sps->profile_idc == 66)\n\t\th264->baseline_profile = 1;\n\n\tif (h->sps->flags & V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE)\n\t\th264->direct_8x8_inference_flag = 1;\n\n\tif (h->pps->flags & V4L2_H264_PPS_FLAG_CONSTRAINED_INTRA_PRED)\n\t\th264->constrained_intra_pred_flag = 1;\n\n\tif (h->pps->flags & V4L2_H264_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT)\n\t\th264->deblocking_filter_control_present_flag = 1;\n\n\tif (h->pps->flags & V4L2_H264_PPS_FLAG_BOTTOM_FIELD_PIC_ORDER_IN_FRAME_PRESENT)\n\t\th264->pic_order_present_flag = 1;\n\n\th264->level_idc\t\t\t\t= to_tegra_vde_h264_level_idc(h->sps->level_idc);\n\th264->log2_max_pic_order_cnt_lsb\t= h->sps->log2_max_pic_order_cnt_lsb_minus4 + 4;\n\th264->log2_max_frame_num\t\t= h->sps->log2_max_frame_num_minus4 + 4;\n\th264->pic_order_cnt_type\t\t= h->sps->pic_order_cnt_type;\n\th264->pic_width_in_mbs\t\t\t= h->sps->pic_width_in_mbs_minus1 + 1;\n\th264->pic_height_in_mbs\t\t\t= h->sps->pic_height_in_map_units_minus1 + 1;\n\n\th264->num_ref_idx_l0_active_minus1\t= h->pps->num_ref_idx_l0_default_active_minus1;\n\th264->num_ref_idx_l1_active_minus1\t= h->pps->num_ref_idx_l1_default_active_minus1;\n\th264->chroma_qp_index_offset\t\t= h->pps->chroma_qp_index_offset & 0x1f;\n\th264->pic_init_qp\t\t\t= h->pps->pic_init_qp_minus26 + 26;\n\n\terr = tegra_vde_h264_setup_frames(ctx, h264);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_vde_validate_h264_ctx(dev, h264);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nint tegra_vde_h264_decode_run(struct tegra_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *src = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tstruct tegra_m2m_buffer *bitstream = vb_to_tegra_buf(&src->vb2_buf);\n\tsize_t bitstream_size = vb2_get_plane_payload(&src->vb2_buf, 0);\n\tstruct tegra_vde_h264_decoder_ctx h264;\n\tstruct tegra_vde *vde = ctx->vde;\n\tint err;\n\n\terr = tegra_vde_h264_setup_context(ctx, &h264);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_vde_decode_begin(vde, &h264, vde->frames,\n\t\t\t\t     bitstream->dma_addr[0],\n\t\t\t\t     bitstream_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nint tegra_vde_h264_decode_wait(struct tegra_ctx *ctx)\n{\n\treturn tegra_vde_decode_end(ctx->vde);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}