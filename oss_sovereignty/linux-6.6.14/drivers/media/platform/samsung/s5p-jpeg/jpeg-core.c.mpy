{
  "module_name": "jpeg-core.c",
  "hash_id": "d19ac3d3d9cbb4c16de20559f73dcc1092fedc5672c26e80b5e14696fd29cd54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s5p-jpeg/jpeg-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-rect.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"jpeg-core.h\"\n#include \"jpeg-hw-s5p.h\"\n#include \"jpeg-hw-exynos4.h\"\n#include \"jpeg-hw-exynos3250.h\"\n#include \"jpeg-regs.h\"\n\nstatic struct s5p_jpeg_fmt sjpeg_formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_JPEG,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_S5P |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS3250 |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 4,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_S5P |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 1,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 2,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS3250 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YVYU,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 1,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YVYU,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 2,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS3250 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_UYVY,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 2,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS3250 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_VYUY,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 2,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS3250 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 0,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4 |\n\t\t\t\t  SJPEG_FMT_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 2,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS3250 |\n\t\t\t\t  SJPEG_FMT_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565X,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 2,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS3250 |\n\t\t\t\t  SJPEG_FMT_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 0,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_S5P |\n\t\t\t\t  SJPEG_FMT_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB32,\n\t\t.depth\t\t= 32,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 0,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4 |\n\t\t\t\t  SJPEG_FMT_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB32,\n\t\t.depth\t\t= 32,\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 2,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS3250 |\n\t\t\t\t  SJPEG_FMT_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV24,\n\t\t.depth\t\t= 24,\n\t\t.colplanes\t= 2,\n\t\t.h_align\t= 0,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV42,\n\t\t.depth\t\t= 24,\n\t\t.colplanes\t= 2,\n\t\t.h_align\t= 0,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV61,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 2,\n\t\t.h_align\t= 1,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV16,\n\t\t.depth\t\t= 16,\n\t\t.colplanes\t= 2,\n\t\t.h_align\t= 1,\n\t\t.v_align\t= 0,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12,\n\t\t.depth\t\t= 12,\n\t\t.colplanes\t= 2,\n\t\t.h_align\t= 1,\n\t\t.v_align\t= 1,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_420,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12,\n\t\t.depth\t\t= 12,\n\t\t.colplanes\t= 2,\n\t\t.h_align\t= 3,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS3250 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_420,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12,\n\t\t.depth\t\t= 12,\n\t\t.colplanes\t= 2,\n\t\t.h_align\t= 4,\n\t\t.v_align\t= 4,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_S5P |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_420,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV21,\n\t\t.depth\t\t= 12,\n\t\t.colplanes\t= 2,\n\t\t.h_align\t= 3,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS3250 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_420,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV21,\n\t\t.depth\t\t= 12,\n\t\t.colplanes\t= 2,\n\t\t.h_align\t= 1,\n\t\t.v_align\t= 1,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS3250 |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_420,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV420,\n\t\t.depth\t\t= 12,\n\t\t.colplanes\t= 3,\n\t\t.h_align\t= 1,\n\t\t.v_align\t= 1,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_420,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV420,\n\t\t.depth\t\t= 12,\n\t\t.colplanes\t= 3,\n\t\t.h_align\t= 4,\n\t\t.v_align\t= 4,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS3250 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_420,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_GREY,\n\t\t.depth\t\t= 8,\n\t\t.colplanes\t= 1,\n\t\t.flags\t\t= SJPEG_FMT_FLAG_ENC_OUTPUT |\n\t\t\t\t  SJPEG_FMT_FLAG_DEC_CAPTURE |\n\t\t\t\t  SJPEG_FMT_FLAG_EXYNOS4 |\n\t\t\t\t  SJPEG_FMT_NON_RGB,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY,\n\t},\n};\n#define SJPEG_NUM_FORMATS ARRAY_SIZE(sjpeg_formats)\n\nstatic const unsigned char qtbl_luminance[4][64] = {\n\t{ \n\t\t20, 16, 25, 39, 50, 46, 62, 68,\n\t\t16, 18, 23, 38, 38, 53, 65, 68,\n\t\t25, 23, 31, 38, 53, 65, 68, 68,\n\t\t39, 38, 38, 53, 65, 68, 68, 68,\n\t\t50, 38, 53, 65, 68, 68, 68, 68,\n\t\t46, 53, 65, 68, 68, 68, 68, 68,\n\t\t62, 65, 68, 68, 68, 68, 68, 68,\n\t\t68, 68, 68, 68, 68, 68, 68, 68\n\t},\n\t{ \n\t\t16, 11, 11, 16, 23, 27, 31, 30,\n\t\t11, 12, 12, 15, 20, 23, 23, 30,\n\t\t11, 12, 13, 16, 23, 26, 35, 47,\n\t\t16, 15, 16, 23, 26, 37, 47, 64,\n\t\t23, 20, 23, 26, 39, 51, 64, 64,\n\t\t27, 23, 26, 37, 51, 64, 64, 64,\n\t\t31, 23, 35, 47, 64, 64, 64, 64,\n\t\t30, 30, 47, 64, 64, 64, 64, 64\n\t},\n\t{ \n\t\t12,  8,  8, 12, 17, 21, 24, 23,\n\t\t 8,  9,  9, 11, 15, 19, 18, 23,\n\t\t 8,  9, 10, 12, 19, 20, 27, 36,\n\t\t12, 11, 12, 21, 20, 28, 36, 53,\n\t\t17, 15, 19, 20, 30, 39, 51, 59,\n\t\t21, 19, 20, 28, 39, 51, 59, 59,\n\t\t24, 18, 27, 36, 51, 59, 59, 59,\n\t\t23, 23, 36, 53, 59, 59, 59, 59\n\t},\n\t{ \n\t\t 8,  6,  6,  8, 12, 14, 16, 17,\n\t\t 6,  6,  6,  8, 10, 13, 12, 15,\n\t\t 6,  6,  7,  8, 13, 14, 18, 24,\n\t\t 8,  8,  8, 14, 13, 19, 24, 35,\n\t\t12, 10, 13, 13, 20, 26, 34, 39,\n\t\t14, 13, 14, 19, 26, 34, 39, 39,\n\t\t16, 12, 18, 24, 34, 39, 39, 39,\n\t\t17, 15, 24, 35, 39, 39, 39, 39\n\t}\n};\n\nstatic const unsigned char qtbl_chrominance[4][64] = {\n\t{ \n\t\t21, 25, 32, 38, 54, 68, 68, 68,\n\t\t25, 28, 24, 38, 54, 68, 68, 68,\n\t\t32, 24, 32, 43, 66, 68, 68, 68,\n\t\t38, 38, 43, 53, 68, 68, 68, 68,\n\t\t54, 54, 66, 68, 68, 68, 68, 68,\n\t\t68, 68, 68, 68, 68, 68, 68, 68,\n\t\t68, 68, 68, 68, 68, 68, 68, 68,\n\t\t68, 68, 68, 68, 68, 68, 68, 68\n\t},\n\t{ \n\t\t17, 15, 17, 21, 20, 26, 38, 48,\n\t\t15, 19, 18, 17, 20, 26, 35, 43,\n\t\t17, 18, 20, 22, 26, 30, 46, 53,\n\t\t21, 17, 22, 28, 30, 39, 53, 64,\n\t\t20, 20, 26, 30, 39, 48, 64, 64,\n\t\t26, 26, 30, 39, 48, 63, 64, 64,\n\t\t38, 35, 46, 53, 64, 64, 64, 64,\n\t\t48, 43, 53, 64, 64, 64, 64, 64\n\t},\n\t{ \n\t\t13, 11, 13, 16, 20, 20, 29, 37,\n\t\t11, 14, 14, 14, 16, 20, 26, 32,\n\t\t13, 14, 15, 17, 20, 23, 35, 40,\n\t\t16, 14, 17, 21, 23, 30, 40, 50,\n\t\t20, 16, 20, 23, 30, 37, 50, 59,\n\t\t20, 20, 23, 30, 37, 48, 59, 59,\n\t\t29, 26, 35, 40, 50, 59, 59, 59,\n\t\t37, 32, 40, 50, 59, 59, 59, 59\n\t},\n\t{ \n\t\t 9,  8,  9, 11, 14, 17, 19, 24,\n\t\t 8, 10,  9, 11, 14, 13, 17, 22,\n\t\t 9,  9, 13, 14, 13, 15, 23, 26,\n\t\t11, 11, 14, 14, 15, 20, 26, 33,\n\t\t14, 14, 13, 15, 20, 24, 33, 39,\n\t\t17, 13, 15, 20, 24, 32, 39, 39,\n\t\t19, 17, 23, 26, 33, 39, 39, 39,\n\t\t24, 22, 26, 33, 39, 39, 39, 39\n\t}\n};\n\nstatic const unsigned char hdctbl0[16] = {\n\t0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0\n};\n\nstatic const unsigned char hdctblg0[12] = {\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb\n};\nstatic const unsigned char hactbl0[16] = {\n\t0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d\n};\nstatic const unsigned char hactblg0[162] = {\n\t0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,\n\t0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,\n\t0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,\n\t0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,\n\t0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,\n\t0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,\n\t0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,\n\t0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n\t0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,\n\t0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,\n\t0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,\n\t0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,\n\t0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,\n\t0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n\t0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,\n\t0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,\n\t0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,\n\t0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,\n\t0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,\n\t0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n\t0xf9, 0xfa\n};\n\n \nstatic const u32 subs422_fourcc_dwngrd_schema[] = {\n\tV4L2_PIX_FMT_NV16,\n\tV4L2_PIX_FMT_NV61,\n};\n\nstatic const u32 subs420_fourcc_dwngrd_schema[] = {\n\tV4L2_PIX_FMT_NV12,\n\tV4L2_PIX_FMT_NV21,\n\tV4L2_PIX_FMT_NV12,\n\tV4L2_PIX_FMT_NV21,\n\tV4L2_PIX_FMT_NV12,\n\tV4L2_PIX_FMT_NV21,\n\tV4L2_PIX_FMT_GREY,\n\tV4L2_PIX_FMT_GREY,\n\tV4L2_PIX_FMT_GREY,\n\tV4L2_PIX_FMT_GREY,\n};\n\n \nstatic const u32 fourcc_to_dwngrd_schema_id[] = {\n\tV4L2_PIX_FMT_NV24,\n\tV4L2_PIX_FMT_NV42,\n\tV4L2_PIX_FMT_NV16,\n\tV4L2_PIX_FMT_NV61,\n\tV4L2_PIX_FMT_YUYV,\n\tV4L2_PIX_FMT_YVYU,\n\tV4L2_PIX_FMT_NV12,\n\tV4L2_PIX_FMT_NV21,\n\tV4L2_PIX_FMT_YUV420,\n\tV4L2_PIX_FMT_GREY,\n};\n\nstatic int s5p_jpeg_get_dwngrd_sch_id_by_fourcc(u32 fourcc)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fourcc_to_dwngrd_schema_id); ++i) {\n\t\tif (fourcc_to_dwngrd_schema_id[i] == fourcc)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int s5p_jpeg_adjust_fourcc_to_subsampling(\n\t\t\t\t\tenum v4l2_jpeg_chroma_subsampling subs,\n\t\t\t\t\tu32 in_fourcc,\n\t\t\t\t\tu32 *out_fourcc,\n\t\t\t\t\tstruct s5p_jpeg_ctx *ctx)\n{\n\tint dwngrd_sch_id;\n\n\tif (ctx->subsampling != V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY) {\n\t\tdwngrd_sch_id =\n\t\t\ts5p_jpeg_get_dwngrd_sch_id_by_fourcc(in_fourcc);\n\t\tif (dwngrd_sch_id < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (ctx->subsampling) {\n\tcase V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY:\n\t\t*out_fourcc = V4L2_PIX_FMT_GREY;\n\t\tbreak;\n\tcase V4L2_JPEG_CHROMA_SUBSAMPLING_420:\n\t\tif (dwngrd_sch_id >\n\t\t\t\tARRAY_SIZE(subs420_fourcc_dwngrd_schema) - 1)\n\t\t\treturn -EINVAL;\n\t\t*out_fourcc = subs420_fourcc_dwngrd_schema[dwngrd_sch_id];\n\t\tbreak;\n\tcase V4L2_JPEG_CHROMA_SUBSAMPLING_422:\n\t\tif (dwngrd_sch_id >\n\t\t\t\tARRAY_SIZE(subs422_fourcc_dwngrd_schema) - 1)\n\t\t\treturn -EINVAL;\n\t\t*out_fourcc = subs422_fourcc_dwngrd_schema[dwngrd_sch_id];\n\t\tbreak;\n\tdefault:\n\t\t*out_fourcc = V4L2_PIX_FMT_GREY;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int exynos4x12_decoded_subsampling[] = {\n\tV4L2_JPEG_CHROMA_SUBSAMPLING_GRAY,\n\tV4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\tV4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\tV4L2_JPEG_CHROMA_SUBSAMPLING_420,\n};\n\nstatic int exynos3250_decoded_subsampling[] = {\n\tV4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\tV4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\tV4L2_JPEG_CHROMA_SUBSAMPLING_420,\n\tV4L2_JPEG_CHROMA_SUBSAMPLING_GRAY,\n\t-1,\n\t-1,\n\tV4L2_JPEG_CHROMA_SUBSAMPLING_411,\n};\n\nstatic inline struct s5p_jpeg_ctx *ctrl_to_ctx(struct v4l2_ctrl *c)\n{\n\treturn container_of(c->handler, struct s5p_jpeg_ctx, ctrl_handler);\n}\n\nstatic inline struct s5p_jpeg_ctx *fh_to_ctx(struct v4l2_fh *fh)\n{\n\treturn container_of(fh, struct s5p_jpeg_ctx, fh);\n}\n\nstatic int s5p_jpeg_to_user_subsampling(struct s5p_jpeg_ctx *ctx)\n{\n\tswitch (ctx->jpeg->variant->version) {\n\tcase SJPEG_S5P:\n\t\tWARN_ON(ctx->subsampling > 3);\n\t\tif (ctx->subsampling > 2)\n\t\t\treturn V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY;\n\t\treturn ctx->subsampling;\n\tcase SJPEG_EXYNOS3250:\n\tcase SJPEG_EXYNOS5420:\n\t\tWARN_ON(ctx->subsampling > 6);\n\t\tif (ctx->subsampling > 3)\n\t\t\treturn V4L2_JPEG_CHROMA_SUBSAMPLING_411;\n\t\treturn exynos3250_decoded_subsampling[ctx->subsampling];\n\tcase SJPEG_EXYNOS4:\n\t\tWARN_ON(ctx->subsampling > 3);\n\t\tif (ctx->subsampling > 2)\n\t\t\treturn V4L2_JPEG_CHROMA_SUBSAMPLING_420;\n\t\treturn exynos4x12_decoded_subsampling[ctx->subsampling];\n\tcase SJPEG_EXYNOS5433:\n\t\treturn ctx->subsampling;  \n\tdefault:\n\t\tWARN_ON(ctx->subsampling > 3);\n\t\treturn V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY;\n\t}\n}\n\nstatic inline void s5p_jpeg_set_qtbl(void __iomem *regs,\n\t\t\t\t     const unsigned char *qtbl,\n\t\t\t\t     unsigned long tab, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\twritel((unsigned int)qtbl[i], regs + tab + (i * 0x04));\n}\n\nstatic inline void s5p_jpeg_set_qtbl_lum(void __iomem *regs, int quality)\n{\n\t \n\ts5p_jpeg_set_qtbl(regs, qtbl_luminance[quality],\n\t\t\t  S5P_JPG_QTBL_CONTENT(0),\n\t\t\t  ARRAY_SIZE(qtbl_luminance[quality]));\n}\n\nstatic inline void s5p_jpeg_set_qtbl_chr(void __iomem *regs, int quality)\n{\n\t \n\ts5p_jpeg_set_qtbl(regs, qtbl_chrominance[quality],\n\t\t\t  S5P_JPG_QTBL_CONTENT(1),\n\t\t\t  ARRAY_SIZE(qtbl_chrominance[quality]));\n}\n\nstatic inline void s5p_jpeg_set_htbl(void __iomem *regs,\n\t\t\t\t     const unsigned char *htbl,\n\t\t\t\t     unsigned long tab, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\twritel((unsigned int)htbl[i], regs + tab + (i * 0x04));\n}\n\nstatic inline void s5p_jpeg_set_hdctbl(void __iomem *regs)\n{\n\t \n\ts5p_jpeg_set_htbl(regs, hdctbl0, S5P_JPG_HDCTBL(0),\n\t\t\t\t\t\tARRAY_SIZE(hdctbl0));\n}\n\nstatic inline void s5p_jpeg_set_hdctblg(void __iomem *regs)\n{\n\t \n\ts5p_jpeg_set_htbl(regs, hdctblg0, S5P_JPG_HDCTBLG(0),\n\t\t\t\t\t\tARRAY_SIZE(hdctblg0));\n}\n\nstatic inline void s5p_jpeg_set_hactbl(void __iomem *regs)\n{\n\t \n\ts5p_jpeg_set_htbl(regs, hactbl0, S5P_JPG_HACTBL(0),\n\t\t\t\t\t\tARRAY_SIZE(hactbl0));\n}\n\nstatic inline void s5p_jpeg_set_hactblg(void __iomem *regs)\n{\n\t \n\ts5p_jpeg_set_htbl(regs, hactblg0, S5P_JPG_HACTBLG(0),\n\t\t\t\t\t\tARRAY_SIZE(hactblg0));\n}\n\nstatic inline void exynos4_jpeg_set_tbl(void __iomem *regs,\n\t\t\t\t\tconst unsigned char *tbl,\n\t\t\t\t\tunsigned long tab, int len)\n{\n\tint i;\n\tunsigned int dword;\n\n\tfor (i = 0; i < len; i += 4) {\n\t\tdword = tbl[i] |\n\t\t\t(tbl[i + 1] << 8) |\n\t\t\t(tbl[i + 2] << 16) |\n\t\t\t(tbl[i + 3] << 24);\n\t\twritel(dword, regs + tab + i);\n\t}\n}\n\nstatic inline void exynos4_jpeg_set_qtbl_lum(void __iomem *regs, int quality)\n{\n\t \n\texynos4_jpeg_set_tbl(regs, qtbl_luminance[quality],\n\t\t\t     EXYNOS4_QTBL_CONTENT(0),\n\t\t\t     ARRAY_SIZE(qtbl_luminance[quality]));\n}\n\nstatic inline void exynos4_jpeg_set_qtbl_chr(void __iomem *regs, int quality)\n{\n\t \n\texynos4_jpeg_set_tbl(regs, qtbl_chrominance[quality],\n\t\t\t     EXYNOS4_QTBL_CONTENT(1),\n\t\t\t     ARRAY_SIZE(qtbl_chrominance[quality]));\n}\n\nstatic void exynos4_jpeg_set_huff_tbl(void __iomem *base)\n{\n\texynos4_jpeg_set_tbl(base, hdctbl0, EXYNOS4_HUFF_TBL_HDCLL,\n\t\t\t\t\t\t\tARRAY_SIZE(hdctbl0));\n\texynos4_jpeg_set_tbl(base, hdctbl0, EXYNOS4_HUFF_TBL_HDCCL,\n\t\t\t\t\t\t\tARRAY_SIZE(hdctbl0));\n\texynos4_jpeg_set_tbl(base, hdctblg0, EXYNOS4_HUFF_TBL_HDCLV,\n\t\t\t\t\t\t\tARRAY_SIZE(hdctblg0));\n\texynos4_jpeg_set_tbl(base, hdctblg0, EXYNOS4_HUFF_TBL_HDCCV,\n\t\t\t\t\t\t\tARRAY_SIZE(hdctblg0));\n\texynos4_jpeg_set_tbl(base, hactbl0, EXYNOS4_HUFF_TBL_HACLL,\n\t\t\t\t\t\t\tARRAY_SIZE(hactbl0));\n\texynos4_jpeg_set_tbl(base, hactbl0, EXYNOS4_HUFF_TBL_HACCL,\n\t\t\t\t\t\t\tARRAY_SIZE(hactbl0));\n\texynos4_jpeg_set_tbl(base, hactblg0, EXYNOS4_HUFF_TBL_HACLV,\n\t\t\t\t\t\t\tARRAY_SIZE(hactblg0));\n\texynos4_jpeg_set_tbl(base, hactblg0, EXYNOS4_HUFF_TBL_HACCV,\n\t\t\t\t\t\t\tARRAY_SIZE(hactblg0));\n}\n\nstatic inline int __exynos4_huff_tbl(int class, int id, bool lenval)\n{\n\t \n\tif (class) {\n\t\tif (id)\n\t\t\treturn lenval ? EXYNOS4_HUFF_TBL_HACCL :\n\t\t\t\tEXYNOS4_HUFF_TBL_HACCV;\n\t\treturn lenval ? EXYNOS4_HUFF_TBL_HACLL : EXYNOS4_HUFF_TBL_HACLV;\n\n\t}\n\t \n\tif (id)\n\t\treturn lenval ? EXYNOS4_HUFF_TBL_HDCCL : EXYNOS4_HUFF_TBL_HDCCV;\n\n\treturn lenval ? EXYNOS4_HUFF_TBL_HDCLL : EXYNOS4_HUFF_TBL_HDCLV;\n}\n\nstatic inline int exynos4_huff_tbl_len(int class, int id)\n{\n\treturn __exynos4_huff_tbl(class, id, true);\n}\n\nstatic inline int exynos4_huff_tbl_val(int class, int id)\n{\n\treturn __exynos4_huff_tbl(class, id, false);\n}\n\nstatic int get_byte(struct s5p_jpeg_buffer *buf);\nstatic int get_word_be(struct s5p_jpeg_buffer *buf, unsigned int *word);\nstatic void skip(struct s5p_jpeg_buffer *buf, long len);\n\nstatic void exynos4_jpeg_parse_decode_h_tbl(struct s5p_jpeg_ctx *ctx)\n{\n\tstruct s5p_jpeg *jpeg = ctx->jpeg;\n\tstruct vb2_v4l2_buffer *vb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tstruct s5p_jpeg_buffer jpeg_buffer;\n\tunsigned int word;\n\tint c, x, components;\n\n\tjpeg_buffer.size = 2;  \n\tjpeg_buffer.data =\n\t\t(unsigned long)vb2_plane_vaddr(&vb->vb2_buf, 0) + ctx->out_q.sos + 2;\n\tjpeg_buffer.curr = 0;\n\n\tword = 0;\n\n\tif (get_word_be(&jpeg_buffer, &word))\n\t\treturn;\n\tjpeg_buffer.size = (long)word - 2;\n\tjpeg_buffer.data += 2;\n\tjpeg_buffer.curr = 0;\n\n\tcomponents = get_byte(&jpeg_buffer);\n\tif (components == -1)\n\t\treturn;\n\twhile (components--) {\n\t\tc = get_byte(&jpeg_buffer);\n\t\tif (c == -1)\n\t\t\treturn;\n\t\tx = get_byte(&jpeg_buffer);\n\t\tif (x == -1)\n\t\t\treturn;\n\t\texynos4_jpeg_select_dec_h_tbl(jpeg->regs, c,\n\t\t\t\t\t(((x >> 4) & 0x1) << 1) | (x & 0x1));\n\t}\n\n}\n\nstatic void exynos4_jpeg_parse_huff_tbl(struct s5p_jpeg_ctx *ctx)\n{\n\tstruct s5p_jpeg *jpeg = ctx->jpeg;\n\tstruct vb2_v4l2_buffer *vb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tstruct s5p_jpeg_buffer jpeg_buffer;\n\tunsigned int word;\n\tint c, i, n, j;\n\n\tfor (j = 0; j < ctx->out_q.dht.n; ++j) {\n\t\tjpeg_buffer.size = ctx->out_q.dht.len[j];\n\t\tjpeg_buffer.data = (unsigned long)vb2_plane_vaddr(&vb->vb2_buf, 0) +\n\t\t\t\t   ctx->out_q.dht.marker[j];\n\t\tjpeg_buffer.curr = 0;\n\n\t\tword = 0;\n\t\twhile (jpeg_buffer.curr < jpeg_buffer.size) {\n\t\t\tchar id, class;\n\n\t\t\tc = get_byte(&jpeg_buffer);\n\t\t\tif (c == -1)\n\t\t\t\treturn;\n\t\t\tid = c & 0xf;\n\t\t\tclass = (c >> 4) & 0xf;\n\t\t\tn = 0;\n\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\tc = get_byte(&jpeg_buffer);\n\t\t\t\tif (c == -1)\n\t\t\t\t\treturn;\n\t\t\t\tword |= c << ((i % 4) * 8);\n\t\t\t\tif ((i + 1) % 4 == 0) {\n\t\t\t\t\twritel(word, jpeg->regs +\n\t\t\t\t\texynos4_huff_tbl_len(class, id) +\n\t\t\t\t\t(i / 4) * 4);\n\t\t\t\t\tword = 0;\n\t\t\t\t}\n\t\t\t\tn += c;\n\t\t\t}\n\t\t\tword = 0;\n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tc = get_byte(&jpeg_buffer);\n\t\t\t\tif (c == -1)\n\t\t\t\t\treturn;\n\t\t\t\tword |= c << ((i % 4) * 8);\n\t\t\t\tif ((i + 1) % 4 == 0) {\n\t\t\t\t\twritel(word, jpeg->regs +\n\t\t\t\t\texynos4_huff_tbl_val(class, id) +\n\t\t\t\t\t(i / 4) * 4);\n\t\t\t\t\tword = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i % 4) {\n\t\t\t\twritel(word, jpeg->regs +\n\t\t\t\texynos4_huff_tbl_val(class, id) + (i / 4) * 4);\n\t\t\t}\n\t\t\tword = 0;\n\t\t}\n\t}\n}\n\nstatic void exynos4_jpeg_parse_decode_q_tbl(struct s5p_jpeg_ctx *ctx)\n{\n\tstruct s5p_jpeg *jpeg = ctx->jpeg;\n\tstruct vb2_v4l2_buffer *vb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tstruct s5p_jpeg_buffer jpeg_buffer;\n\tint c, x, components;\n\n\tjpeg_buffer.size = ctx->out_q.sof_len;\n\tjpeg_buffer.data =\n\t\t(unsigned long)vb2_plane_vaddr(&vb->vb2_buf, 0) + ctx->out_q.sof;\n\tjpeg_buffer.curr = 0;\n\n\tskip(&jpeg_buffer, 5);  \n\tcomponents = get_byte(&jpeg_buffer);\n\tif (components == -1)\n\t\treturn;\n\n\texynos4_jpeg_set_dec_components(jpeg->regs, components);\n\n\twhile (components--) {\n\t\tc = get_byte(&jpeg_buffer);\n\t\tif (c == -1)\n\t\t\treturn;\n\t\tskip(&jpeg_buffer, 1);\n\t\tx = get_byte(&jpeg_buffer);\n\t\tif (x == -1)\n\t\t\treturn;\n\t\texynos4_jpeg_select_dec_q_tbl(jpeg->regs, c, x);\n\t}\n}\n\nstatic void exynos4_jpeg_parse_q_tbl(struct s5p_jpeg_ctx *ctx)\n{\n\tstruct s5p_jpeg *jpeg = ctx->jpeg;\n\tstruct vb2_v4l2_buffer *vb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tstruct s5p_jpeg_buffer jpeg_buffer;\n\tunsigned int word;\n\tint c, i, j;\n\n\tfor (j = 0; j < ctx->out_q.dqt.n; ++j) {\n\t\tjpeg_buffer.size = ctx->out_q.dqt.len[j];\n\t\tjpeg_buffer.data = (unsigned long)vb2_plane_vaddr(&vb->vb2_buf, 0) +\n\t\t\t\t   ctx->out_q.dqt.marker[j];\n\t\tjpeg_buffer.curr = 0;\n\n\t\tword = 0;\n\t\twhile (jpeg_buffer.size - jpeg_buffer.curr >= 65) {\n\t\t\tchar id;\n\n\t\t\tc = get_byte(&jpeg_buffer);\n\t\t\tif (c == -1)\n\t\t\t\treturn;\n\t\t\tid = c & 0xf;\n\t\t\t \n\t\t\tif ((c >> 4) & 0xf)\n\t\t\t\treturn;\n\t\t\tfor (i = 0; i < 64; ++i) {\n\t\t\t\tc = get_byte(&jpeg_buffer);\n\t\t\t\tif (c == -1)\n\t\t\t\t\treturn;\n\t\t\t\tword |= c << ((i % 4) * 8);\n\t\t\t\tif ((i + 1) % 4 == 0) {\n\t\t\t\t\twritel(word, jpeg->regs +\n\t\t\t\t\tEXYNOS4_QTBL_CONTENT(id) + (i / 4) * 4);\n\t\t\t\t\tword = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tword = 0;\n\t\t}\n\t}\n}\n\n \n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t      struct vb2_queue *dst_vq);\nstatic struct s5p_jpeg_fmt *s5p_jpeg_find_format(struct s5p_jpeg_ctx *ctx,\n\t\t\t\t__u32 pixelformat, unsigned int fmt_type);\nstatic int s5p_jpeg_controls_create(struct s5p_jpeg_ctx *ctx);\n\nstatic int s5p_jpeg_open(struct file *file)\n{\n\tstruct s5p_jpeg *jpeg = video_drvdata(file);\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct s5p_jpeg_ctx *ctx;\n\tstruct s5p_jpeg_fmt *out_fmt, *cap_fmt;\n\tint ret = 0;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (mutex_lock_interruptible(&jpeg->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free;\n\t}\n\n\tv4l2_fh_init(&ctx->fh, vfd);\n\t \n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\tctx->jpeg = jpeg;\n\tif (vfd == jpeg->vfd_encoder) {\n\t\tctx->mode = S5P_JPEG_ENCODE;\n\t\tout_fmt = s5p_jpeg_find_format(ctx, V4L2_PIX_FMT_RGB565,\n\t\t\t\t\t\t\tFMT_TYPE_OUTPUT);\n\t\tcap_fmt = s5p_jpeg_find_format(ctx, V4L2_PIX_FMT_JPEG,\n\t\t\t\t\t\t\tFMT_TYPE_CAPTURE);\n\t} else {\n\t\tctx->mode = S5P_JPEG_DECODE;\n\t\tout_fmt = s5p_jpeg_find_format(ctx, V4L2_PIX_FMT_JPEG,\n\t\t\t\t\t\t\tFMT_TYPE_OUTPUT);\n\t\tcap_fmt = s5p_jpeg_find_format(ctx, V4L2_PIX_FMT_YUYV,\n\t\t\t\t\t\t\tFMT_TYPE_CAPTURE);\n\t\tctx->scale_factor = EXYNOS3250_DEC_SCALE_FACTOR_8_8;\n\t}\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(jpeg->m2m_dev, ctx, queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto error;\n\t}\n\n\tctx->out_q.fmt = out_fmt;\n\tctx->cap_q.fmt = cap_fmt;\n\n\tret = s5p_jpeg_controls_create(ctx);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tmutex_unlock(&jpeg->lock);\n\treturn 0;\n\nerror:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tmutex_unlock(&jpeg->lock);\nfree:\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic int s5p_jpeg_release(struct file *file)\n{\n\tstruct s5p_jpeg *jpeg = video_drvdata(file);\n\tstruct s5p_jpeg_ctx *ctx = fh_to_ctx(file->private_data);\n\n\tmutex_lock(&jpeg->lock);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\tmutex_unlock(&jpeg->lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations s5p_jpeg_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= s5p_jpeg_open,\n\t.release\t= s5p_jpeg_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\n \n\nstatic int get_byte(struct s5p_jpeg_buffer *buf)\n{\n\tif (buf->curr >= buf->size)\n\t\treturn -1;\n\n\treturn ((unsigned char *)buf->data)[buf->curr++];\n}\n\nstatic int get_word_be(struct s5p_jpeg_buffer *buf, unsigned int *word)\n{\n\tunsigned int temp;\n\tint byte;\n\n\tbyte = get_byte(buf);\n\tif (byte == -1)\n\t\treturn -1;\n\ttemp = byte << 8;\n\tbyte = get_byte(buf);\n\tif (byte == -1)\n\t\treturn -1;\n\t*word = (unsigned int)byte | temp;\n\treturn 0;\n}\n\nstatic void skip(struct s5p_jpeg_buffer *buf, long len)\n{\n\tif (len <= 0)\n\t\treturn;\n\n\twhile (len--)\n\t\tget_byte(buf);\n}\n\nstatic bool s5p_jpeg_subsampling_decode(struct s5p_jpeg_ctx *ctx,\n\t\t\t\t\tunsigned int subsampling)\n{\n\tunsigned int version;\n\n\tswitch (subsampling) {\n\tcase 0x11:\n\t\tctx->subsampling = V4L2_JPEG_CHROMA_SUBSAMPLING_444;\n\t\tbreak;\n\tcase 0x21:\n\t\tctx->subsampling = V4L2_JPEG_CHROMA_SUBSAMPLING_422;\n\t\tbreak;\n\tcase 0x22:\n\t\tctx->subsampling = V4L2_JPEG_CHROMA_SUBSAMPLING_420;\n\t\tbreak;\n\tcase 0x33:\n\t\tctx->subsampling = V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY;\n\t\tbreak;\n\tcase 0x41:\n\t\t \n\t\tversion = ctx->jpeg->variant->version;\n\t\tif (version != SJPEG_EXYNOS3250 &&\n\t\t    version != SJPEG_EXYNOS5420 &&\n\t\t    version != SJPEG_EXYNOS5433)\n\t\t\treturn false;\n\n\t\tctx->subsampling = V4L2_JPEG_CHROMA_SUBSAMPLING_411;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool s5p_jpeg_parse_hdr(struct s5p_jpeg_q_data *result,\n\t\t\t       unsigned long buffer, unsigned long size,\n\t\t\t       struct s5p_jpeg_ctx *ctx)\n{\n\tint c, components = 0, notfound, n_dht = 0, n_dqt = 0;\n\tunsigned int height = 0, width = 0, word, subsampling = 0;\n\tunsigned int sos = 0, sof = 0, sof_len = 0;\n\tunsigned int dht[S5P_JPEG_MAX_MARKER], dht_len[S5P_JPEG_MAX_MARKER];\n\tunsigned int dqt[S5P_JPEG_MAX_MARKER], dqt_len[S5P_JPEG_MAX_MARKER];\n\tlong length;\n\tstruct s5p_jpeg_buffer jpeg_buffer;\n\n\tjpeg_buffer.size = size;\n\tjpeg_buffer.data = buffer;\n\tjpeg_buffer.curr = 0;\n\n\tnotfound = 1;\n\twhile (notfound || !sos) {\n\t\tc = get_byte(&jpeg_buffer);\n\t\tif (c == -1)\n\t\t\treturn false;\n\t\tif (c != 0xff)\n\t\t\tcontinue;\n\t\tdo\n\t\t\tc = get_byte(&jpeg_buffer);\n\t\twhile (c == 0xff);\n\t\tif (c == -1)\n\t\t\treturn false;\n\t\tif (c == 0)\n\t\t\tcontinue;\n\t\tlength = 0;\n\t\tswitch (c) {\n\t\t \n\t\tcase JPEG_MARKER_SOF0:\n\t\t\tif (get_word_be(&jpeg_buffer, &word))\n\t\t\t\tbreak;\n\t\t\tlength = (long)word - 2;\n\t\t\tif (!length)\n\t\t\t\treturn false;\n\t\t\tsof = jpeg_buffer.curr;  \n\t\t\tsof_len = length;\n\t\t\tif (get_byte(&jpeg_buffer) == -1)\n\t\t\t\tbreak;\n\t\t\tif (get_word_be(&jpeg_buffer, &height))\n\t\t\t\tbreak;\n\t\t\tif (get_word_be(&jpeg_buffer, &width))\n\t\t\t\tbreak;\n\t\t\tcomponents = get_byte(&jpeg_buffer);\n\t\t\tif (components == -1)\n\t\t\t\tbreak;\n\n\t\t\tif (components == 1) {\n\t\t\t\tsubsampling = 0x33;\n\t\t\t} else {\n\t\t\t\tskip(&jpeg_buffer, 1);\n\t\t\t\tsubsampling = get_byte(&jpeg_buffer);\n\t\t\t\tskip(&jpeg_buffer, 1);\n\t\t\t}\n\t\t\tif (components > 3)\n\t\t\t\treturn false;\n\t\t\tskip(&jpeg_buffer, components * 2);\n\t\t\tnotfound = 0;\n\t\t\tbreak;\n\n\t\tcase JPEG_MARKER_DQT:\n\t\t\tif (get_word_be(&jpeg_buffer, &word))\n\t\t\t\tbreak;\n\t\t\tlength = (long)word - 2;\n\t\t\tif (!length)\n\t\t\t\treturn false;\n\t\t\tif (n_dqt >= S5P_JPEG_MAX_MARKER)\n\t\t\t\treturn false;\n\t\t\tdqt[n_dqt] = jpeg_buffer.curr;  \n\t\t\tdqt_len[n_dqt++] = length;\n\t\t\tskip(&jpeg_buffer, length);\n\t\t\tbreak;\n\n\t\tcase JPEG_MARKER_DHT:\n\t\t\tif (get_word_be(&jpeg_buffer, &word))\n\t\t\t\tbreak;\n\t\t\tlength = (long)word - 2;\n\t\t\tif (!length)\n\t\t\t\treturn false;\n\t\t\tif (n_dht >= S5P_JPEG_MAX_MARKER)\n\t\t\t\treturn false;\n\t\t\tdht[n_dht] = jpeg_buffer.curr;  \n\t\t\tdht_len[n_dht++] = length;\n\t\t\tskip(&jpeg_buffer, length);\n\t\t\tbreak;\n\n\t\tcase JPEG_MARKER_SOS:\n\t\t\tsos = jpeg_buffer.curr - 2;  \n\t\t\tbreak;\n\n\t\t \n\t\tcase JPEG_MARKER_RST ... JPEG_MARKER_RST + 7:\n\t\tcase JPEG_MARKER_SOI:\n\t\tcase JPEG_MARKER_EOI:\n\t\tcase JPEG_MARKER_TEM:\n\t\t\tbreak;\n\n\t\t \n\t\tdefault:\n\t\t\tif (get_word_be(&jpeg_buffer, &word))\n\t\t\t\tbreak;\n\t\t\tlength = (long)word - 2;\n\t\t\tskip(&jpeg_buffer, length);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (notfound || !sos || !s5p_jpeg_subsampling_decode(ctx, subsampling))\n\t\treturn false;\n\n\tresult->w = width;\n\tresult->h = height;\n\tresult->sos = sos;\n\tresult->dht.n = n_dht;\n\twhile (n_dht--) {\n\t\tresult->dht.marker[n_dht] = dht[n_dht];\n\t\tresult->dht.len[n_dht] = dht_len[n_dht];\n\t}\n\tresult->dqt.n = n_dqt;\n\twhile (n_dqt--) {\n\t\tresult->dqt.marker[n_dqt] = dqt[n_dqt];\n\t\tresult->dqt.len[n_dqt] = dqt_len[n_dqt];\n\t}\n\tresult->sof = sof;\n\tresult->sof_len = sof_len;\n\n\treturn true;\n}\n\nstatic int s5p_jpeg_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\n\n\tif (ctx->mode == S5P_JPEG_ENCODE) {\n\t\tstrscpy(cap->driver, S5P_JPEG_M2M_NAME,\n\t\t\tsizeof(cap->driver));\n\t\tstrscpy(cap->card, S5P_JPEG_M2M_NAME \" encoder\",\n\t\t\tsizeof(cap->card));\n\t} else {\n\t\tstrscpy(cap->driver, S5P_JPEG_M2M_NAME,\n\t\t\tsizeof(cap->driver));\n\t\tstrscpy(cap->card, S5P_JPEG_M2M_NAME \" decoder\",\n\t\t\tsizeof(cap->card));\n\t}\n\treturn 0;\n}\n\nstatic int enum_fmt(struct s5p_jpeg_ctx *ctx,\n\t\t    struct s5p_jpeg_fmt *sjpeg_formats, int n,\n\t\t    struct v4l2_fmtdesc *f, u32 type)\n{\n\tint i, num = 0;\n\tunsigned int fmt_ver_flag = ctx->jpeg->variant->fmt_ver_flag;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tif (sjpeg_formats[i].flags & type &&\n\t\t    sjpeg_formats[i].flags & fmt_ver_flag) {\n\t\t\t \n\t\t\tif (num == f->index)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\t++num;\n\t\t}\n\t}\n\n\t \n\tif (i >= n)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = sjpeg_formats[i].fourcc;\n\n\treturn 0;\n}\n\nstatic int s5p_jpeg_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\n\n\tif (ctx->mode == S5P_JPEG_ENCODE)\n\t\treturn enum_fmt(ctx, sjpeg_formats, SJPEG_NUM_FORMATS, f,\n\t\t\t\tSJPEG_FMT_FLAG_ENC_CAPTURE);\n\n\treturn enum_fmt(ctx, sjpeg_formats, SJPEG_NUM_FORMATS, f,\n\t\t\tSJPEG_FMT_FLAG_DEC_CAPTURE);\n}\n\nstatic int s5p_jpeg_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\n\n\tif (ctx->mode == S5P_JPEG_ENCODE)\n\t\treturn enum_fmt(ctx, sjpeg_formats, SJPEG_NUM_FORMATS, f,\n\t\t\t\tSJPEG_FMT_FLAG_ENC_OUTPUT);\n\n\treturn enum_fmt(ctx, sjpeg_formats, SJPEG_NUM_FORMATS, f,\n\t\t\tSJPEG_FMT_FLAG_DEC_OUTPUT);\n}\n\nstatic struct s5p_jpeg_q_data *get_q_data(struct s5p_jpeg_ctx *ctx,\n\t\t\t\t\t  enum v4l2_buf_type type)\n{\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn &ctx->out_q;\n\tif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn &ctx->cap_q;\n\n\treturn NULL;\n}\n\nstatic int s5p_jpeg_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct s5p_jpeg_q_data *q_data = NULL;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct s5p_jpeg_ctx *ct = fh_to_ctx(priv);\n\n\tvq = v4l2_m2m_get_vq(ct->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    ct->mode == S5P_JPEG_DECODE && !ct->hdr_parsed)\n\t\treturn -EINVAL;\n\tq_data = get_q_data(ct, f->type);\n\tBUG_ON(q_data == NULL);\n\n\tpix->width = q_data->w;\n\tpix->height = q_data->h;\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->pixelformat = q_data->fmt->fourcc;\n\tpix->bytesperline = 0;\n\tif (q_data->fmt->fourcc != V4L2_PIX_FMT_JPEG) {\n\t\tu32 bpl = q_data->w;\n\n\t\tif (q_data->fmt->colplanes == 1)\n\t\t\tbpl = (bpl * q_data->fmt->depth) >> 3;\n\t\tpix->bytesperline = bpl;\n\t}\n\tpix->sizeimage = q_data->size;\n\n\treturn 0;\n}\n\nstatic struct s5p_jpeg_fmt *s5p_jpeg_find_format(struct s5p_jpeg_ctx *ctx,\n\t\t\t\tu32 pixelformat, unsigned int fmt_type)\n{\n\tunsigned int k, fmt_flag;\n\n\tif (ctx->mode == S5P_JPEG_ENCODE)\n\t\tfmt_flag = (fmt_type == FMT_TYPE_OUTPUT) ?\n\t\t\t\tSJPEG_FMT_FLAG_ENC_OUTPUT :\n\t\t\t\tSJPEG_FMT_FLAG_ENC_CAPTURE;\n\telse\n\t\tfmt_flag = (fmt_type == FMT_TYPE_OUTPUT) ?\n\t\t\t\tSJPEG_FMT_FLAG_DEC_OUTPUT :\n\t\t\t\tSJPEG_FMT_FLAG_DEC_CAPTURE;\n\n\tfor (k = 0; k < ARRAY_SIZE(sjpeg_formats); k++) {\n\t\tstruct s5p_jpeg_fmt *fmt = &sjpeg_formats[k];\n\n\t\tif (fmt->fourcc == pixelformat &&\n\t\t    fmt->flags & fmt_flag &&\n\t\t    fmt->flags & ctx->jpeg->variant->fmt_ver_flag) {\n\t\t\treturn fmt;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void jpeg_bound_align_image(struct s5p_jpeg_ctx *ctx,\n\t\t\t\t   u32 *w, unsigned int wmin, unsigned int wmax,\n\t\t\t\t   unsigned int walign,\n\t\t\t\t   u32 *h, unsigned int hmin, unsigned int hmax,\n\t\t\t\t   unsigned int halign)\n{\n\tint width, height, w_step, h_step;\n\n\twidth = *w;\n\theight = *h;\n\n\tw_step = 1 << walign;\n\th_step = 1 << halign;\n\n\tif (ctx->jpeg->variant->hw3250_compat) {\n\t\t \n\t\tif (w_step == 4 && ((width & 3) == 1)) {\n\t\t\twmax = width;\n\t\t\thmax = height;\n\t\t}\n\t}\n\n\tv4l_bound_align_image(w, wmin, wmax, walign, h, hmin, hmax, halign, 0);\n\n\tif (*w < width && (*w + w_step) < wmax)\n\t\t*w += w_step;\n\tif (*h < height && (*h + h_step) < hmax)\n\t\t*h += h_step;\n}\n\nstatic int vidioc_try_fmt(struct v4l2_format *f, struct s5p_jpeg_fmt *fmt,\n\t\t\t  struct s5p_jpeg_ctx *ctx, int q_type)\n{\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\n\tif (pix->field == V4L2_FIELD_ANY)\n\t\tpix->field = V4L2_FIELD_NONE;\n\telse if (pix->field != V4L2_FIELD_NONE)\n\t\treturn -EINVAL;\n\n\t \n\tif (q_type == FMT_TYPE_OUTPUT)\n\t\tjpeg_bound_align_image(ctx, &pix->width, S5P_JPEG_MIN_WIDTH,\n\t\t\t\t       S5P_JPEG_MAX_WIDTH, 0,\n\t\t\t\t       &pix->height, S5P_JPEG_MIN_HEIGHT,\n\t\t\t\t       S5P_JPEG_MAX_HEIGHT, 0);\n\telse\n\t\tjpeg_bound_align_image(ctx, &pix->width, S5P_JPEG_MIN_WIDTH,\n\t\t\t\t       S5P_JPEG_MAX_WIDTH, fmt->h_align,\n\t\t\t\t       &pix->height, S5P_JPEG_MIN_HEIGHT,\n\t\t\t\t       S5P_JPEG_MAX_HEIGHT, fmt->v_align);\n\n\tif (fmt->fourcc == V4L2_PIX_FMT_JPEG) {\n\t\tif (pix->sizeimage <= 0)\n\t\t\tpix->sizeimage = PAGE_SIZE;\n\t\tpix->bytesperline = 0;\n\t} else {\n\t\tu32 bpl = pix->bytesperline;\n\n\t\tif (fmt->colplanes > 1 && bpl < pix->width)\n\t\t\tbpl = pix->width;  \n\n\t\tif (fmt->colplanes == 1 &&  \n\t\t    (bpl << 3) / fmt->depth < pix->width)\n\t\t\tbpl = (pix->width * fmt->depth) >> 3;\n\n\t\tpix->bytesperline = bpl;\n\t\tpix->sizeimage = (pix->width * pix->height * fmt->depth) >> 3;\n\t}\n\n\treturn 0;\n}\n\nstatic int s5p_jpeg_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct s5p_jpeg_fmt *fmt;\n\tint ret;\n\n\tfmt = s5p_jpeg_find_format(ctx, f->fmt.pix.pixelformat,\n\t\t\t\t\t\tFMT_TYPE_CAPTURE);\n\tif (!fmt) {\n\t\tv4l2_err(&ctx->jpeg->v4l2_dev,\n\t\t\t \"Fourcc format (0x%08x) invalid.\\n\",\n\t\t\t f->fmt.pix.pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ctx->jpeg->variant->hw_ex4_compat || ctx->mode != S5P_JPEG_DECODE)\n\t\tgoto exit;\n\n\t \n\tif ((fmt->flags & SJPEG_FMT_NON_RGB) &&\n\t    (fmt->subsampling < ctx->subsampling)) {\n\t\tret = s5p_jpeg_adjust_fourcc_to_subsampling(ctx->subsampling,\n\t\t\t\t\t\t\t    fmt->fourcc,\n\t\t\t\t\t\t\t    &pix->pixelformat,\n\t\t\t\t\t\t\t    ctx);\n\t\tif (ret < 0)\n\t\t\tpix->pixelformat = V4L2_PIX_FMT_GREY;\n\n\t\tfmt = s5p_jpeg_find_format(ctx, pix->pixelformat,\n\t\t\t\t\t\t\tFMT_TYPE_CAPTURE);\n\t}\n\n\t \n\tif (ctx->subsampling == V4L2_JPEG_CHROMA_SUBSAMPLING_420 &&\n\t    (ctx->out_q.w & 1) &&\n\t    (pix->pixelformat == V4L2_PIX_FMT_NV12 ||\n\t     pix->pixelformat == V4L2_PIX_FMT_NV21 ||\n\t     pix->pixelformat == V4L2_PIX_FMT_YUV420)) {\n\t\tpix->pixelformat = V4L2_PIX_FMT_RGB565;\n\t\tfmt = s5p_jpeg_find_format(ctx, pix->pixelformat,\n\t\t\t\t\t\t\tFMT_TYPE_CAPTURE);\n\t}\n\nexit:\n\treturn vidioc_try_fmt(f, fmt, ctx, FMT_TYPE_CAPTURE);\n}\n\nstatic int s5p_jpeg_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\n\tstruct s5p_jpeg_fmt *fmt;\n\n\tfmt = s5p_jpeg_find_format(ctx, f->fmt.pix.pixelformat,\n\t\t\t\t\t\tFMT_TYPE_OUTPUT);\n\tif (!fmt) {\n\t\tv4l2_err(&ctx->jpeg->v4l2_dev,\n\t\t\t \"Fourcc format (0x%08x) invalid.\\n\",\n\t\t\t f->fmt.pix.pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\treturn vidioc_try_fmt(f, fmt, ctx, FMT_TYPE_OUTPUT);\n}\n\nstatic int exynos4_jpeg_get_output_buffer_size(struct s5p_jpeg_ctx *ctx,\n\t\t\t\t\t\tstruct v4l2_format *f,\n\t\t\t\t\t\tint fmt_depth)\n{\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tu32 pix_fmt = f->fmt.pix.pixelformat;\n\tint w = pix->width, h = pix->height, wh_align;\n\tint padding = 0;\n\n\tif (pix_fmt == V4L2_PIX_FMT_RGB32 ||\n\t    pix_fmt == V4L2_PIX_FMT_RGB565 ||\n\t    pix_fmt == V4L2_PIX_FMT_NV24 ||\n\t    pix_fmt == V4L2_PIX_FMT_NV42 ||\n\t    pix_fmt == V4L2_PIX_FMT_NV12 ||\n\t    pix_fmt == V4L2_PIX_FMT_NV21 ||\n\t    pix_fmt == V4L2_PIX_FMT_YUV420)\n\t\twh_align = 4;\n\telse\n\t\twh_align = 1;\n\n\tjpeg_bound_align_image(ctx, &w, S5P_JPEG_MIN_WIDTH,\n\t\t\t       S5P_JPEG_MAX_WIDTH, wh_align,\n\t\t\t       &h, S5P_JPEG_MIN_HEIGHT,\n\t\t\t       S5P_JPEG_MAX_HEIGHT, wh_align);\n\n\tif (ctx->jpeg->variant->version == SJPEG_EXYNOS4)\n\t\tpadding = PAGE_SIZE;\n\n\treturn (w * h * fmt_depth >> 3) + padding;\n}\n\nstatic int exynos3250_jpeg_try_downscale(struct s5p_jpeg_ctx *ctx,\n\t\t\t\t   struct v4l2_rect *r);\n\nstatic int s5p_jpeg_s_fmt(struct s5p_jpeg_ctx *ct, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct s5p_jpeg_q_data *q_data = NULL;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct v4l2_ctrl *ctrl_subs;\n\tstruct v4l2_rect scale_rect;\n\tunsigned int f_type;\n\n\tvq = v4l2_m2m_get_vq(ct->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ct, f->type);\n\tBUG_ON(q_data == NULL);\n\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&ct->jpeg->v4l2_dev, \"%s queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tf_type = V4L2_TYPE_IS_OUTPUT(f->type) ?\n\t\t\tFMT_TYPE_OUTPUT : FMT_TYPE_CAPTURE;\n\n\tq_data->fmt = s5p_jpeg_find_format(ct, pix->pixelformat, f_type);\n\tif (ct->mode == S5P_JPEG_ENCODE ||\n\t\t(ct->mode == S5P_JPEG_DECODE &&\n\t\tq_data->fmt->fourcc != V4L2_PIX_FMT_JPEG)) {\n\t\tq_data->w = pix->width;\n\t\tq_data->h = pix->height;\n\t}\n\tif (q_data->fmt->fourcc != V4L2_PIX_FMT_JPEG) {\n\t\t \n\t\tif (ct->jpeg->variant->hw_ex4_compat &&\n\t\t    f_type == FMT_TYPE_OUTPUT && ct->mode == S5P_JPEG_ENCODE)\n\t\t\tq_data->size = exynos4_jpeg_get_output_buffer_size(ct,\n\t\t\t\t\t\t\tf,\n\t\t\t\t\t\t\tq_data->fmt->depth);\n\t\telse\n\t\t\tq_data->size = q_data->w * q_data->h *\n\t\t\t\t\t\tq_data->fmt->depth >> 3;\n\t} else {\n\t\tq_data->size = pix->sizeimage;\n\t}\n\n\tif (f_type == FMT_TYPE_OUTPUT) {\n\t\tctrl_subs = v4l2_ctrl_find(&ct->ctrl_handler,\n\t\t\t\t\tV4L2_CID_JPEG_CHROMA_SUBSAMPLING);\n\t\tif (ctrl_subs)\n\t\t\tv4l2_ctrl_s_ctrl(ctrl_subs, q_data->fmt->subsampling);\n\t\tct->crop_altered = false;\n\t}\n\n\t \n\tif (!ct->crop_altered &&\n\t    ((ct->mode == S5P_JPEG_DECODE && f_type == FMT_TYPE_CAPTURE) ||\n\t     (ct->mode == S5P_JPEG_ENCODE && f_type == FMT_TYPE_OUTPUT))) {\n\t\tct->crop_rect.width = pix->width;\n\t\tct->crop_rect.height = pix->height;\n\t}\n\n\t \n\tif (ct->mode == S5P_JPEG_DECODE &&\n\t    f_type == FMT_TYPE_CAPTURE &&\n\t    ct->jpeg->variant->hw3250_compat &&\n\t    pix->pixelformat == V4L2_PIX_FMT_YUV420 &&\n\t    ct->scale_factor > 2) {\n\t\tscale_rect.width = ct->out_q.w / 2;\n\t\tscale_rect.height = ct->out_q.h / 2;\n\t\texynos3250_jpeg_try_downscale(ct, &scale_rect);\n\t}\n\n\treturn 0;\n}\n\nstatic int s5p_jpeg_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tint ret;\n\n\tret = s5p_jpeg_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\treturn s5p_jpeg_s_fmt(fh_to_ctx(priv), f);\n}\n\nstatic int s5p_jpeg_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tint ret;\n\n\tret = s5p_jpeg_try_fmt_vid_out(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\treturn s5p_jpeg_s_fmt(fh_to_ctx(priv), f);\n}\n\nstatic int s5p_jpeg_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t    const struct v4l2_event_subscription *sub)\n{\n\tif (sub->type == V4L2_EVENT_SOURCE_CHANGE)\n\t\treturn v4l2_src_change_event_subscribe(fh, sub);\n\n\treturn -EINVAL;\n}\n\nstatic int exynos3250_jpeg_try_downscale(struct s5p_jpeg_ctx *ctx,\n\t\t\t\t   struct v4l2_rect *r)\n{\n\tint w_ratio, h_ratio, scale_factor, cur_ratio, i;\n\n\tw_ratio = ctx->out_q.w / r->width;\n\th_ratio = ctx->out_q.h / r->height;\n\n\tscale_factor = max(w_ratio, h_ratio);\n\tscale_factor = clamp_val(scale_factor, 1, 8);\n\n\t \n\tfor (i = 0; i <= 3; ++i) {\n\t\tcur_ratio = 1 << i;\n\t\tif (scale_factor <= cur_ratio) {\n\t\t\tctx->scale_factor = cur_ratio;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tr->width = round_down(ctx->out_q.w / ctx->scale_factor, 2);\n\tr->height = round_down(ctx->out_q.h / ctx->scale_factor, 2);\n\n\tctx->crop_rect.width = r->width;\n\tctx->crop_rect.height = r->height;\n\tctx->crop_rect.left = 0;\n\tctx->crop_rect.top = 0;\n\n\tctx->crop_altered = true;\n\n\treturn 0;\n}\n\nstatic int exynos3250_jpeg_try_crop(struct s5p_jpeg_ctx *ctx,\n\t\t\t\t   struct v4l2_rect *r)\n{\n\tstruct v4l2_rect base_rect;\n\tint w_step, h_step;\n\n\tswitch (ctx->cap_q.fmt->fourcc) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\tw_step = 1;\n\t\th_step = 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420:\n\t\tw_step = 2;\n\t\th_step = 2;\n\t\tbreak;\n\tdefault:\n\t\tw_step = 1;\n\t\th_step = 1;\n\t\tbreak;\n\t}\n\n\tbase_rect.top = 0;\n\tbase_rect.left = 0;\n\tbase_rect.width = ctx->out_q.w;\n\tbase_rect.height = ctx->out_q.h;\n\n\tr->width = round_down(r->width, w_step);\n\tr->height = round_down(r->height, h_step);\n\tr->left = round_down(r->left, 2);\n\tr->top = round_down(r->top, 2);\n\n\tif (!v4l2_rect_enclosed(r, &base_rect))\n\t\treturn -EINVAL;\n\n\tctx->crop_rect.left = r->left;\n\tctx->crop_rect.top = r->top;\n\tctx->crop_rect.width = r->width;\n\tctx->crop_rect.height = r->height;\n\n\tctx->crop_altered = true;\n\n\treturn 0;\n}\n\n \n\nstatic int s5p_jpeg_g_selection(struct file *file, void *priv,\n\t\t\t struct v4l2_selection *s)\n{\n\tstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\n\t    s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\ts->r.width = ctx->out_q.w;\n\t\ts->r.height = ctx->out_q.h;\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\tcase V4L2_SEL_TGT_COMPOSE_PADDED:\n\t\ts->r.width = ctx->crop_rect.width;\n\t\ts->r.height =  ctx->crop_rect.height;\n\t\ts->r.left = ctx->crop_rect.left;\n\t\ts->r.top = ctx->crop_rect.top;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int s5p_jpeg_s_selection(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_selection *s)\n{\n\tstruct s5p_jpeg_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct v4l2_rect *rect = &s->r;\n\tint ret = -EINVAL;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (s->target == V4L2_SEL_TGT_COMPOSE) {\n\t\tif (ctx->mode != S5P_JPEG_DECODE)\n\t\t\treturn -EINVAL;\n\t\tif (ctx->jpeg->variant->hw3250_compat)\n\t\t\tret = exynos3250_jpeg_try_downscale(ctx, rect);\n\t} else if (s->target == V4L2_SEL_TGT_CROP) {\n\t\tif (ctx->mode != S5P_JPEG_ENCODE)\n\t\t\treturn -EINVAL;\n\t\tif (ctx->jpeg->variant->hw3250_compat)\n\t\t\tret = exynos3250_jpeg_try_crop(ctx, rect);\n\t}\n\n\treturn ret;\n}\n\nstatic int s5p_jpeg_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct s5p_jpeg_ctx *ctx = ctrl_to_ctx(ctrl);\n\tstruct s5p_jpeg *jpeg = ctx->jpeg;\n\tunsigned long flags;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_JPEG_CHROMA_SUBSAMPLING:\n\t\tspin_lock_irqsave(&jpeg->slock, flags);\n\t\tctrl->val = s5p_jpeg_to_user_subsampling(ctx);\n\t\tspin_unlock_irqrestore(&jpeg->slock, flags);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int s5p_jpeg_adjust_subs_ctrl(struct s5p_jpeg_ctx *ctx, int *ctrl_val)\n{\n\tswitch (ctx->jpeg->variant->version) {\n\tcase SJPEG_S5P:\n\t\treturn 0;\n\tcase SJPEG_EXYNOS3250:\n\tcase SJPEG_EXYNOS5420:\n\t\t \n\t\tif (ctx->out_q.fmt->fourcc == V4L2_PIX_FMT_RGB32)\n\t\t\t*ctrl_val = 0;\n\t\tbreak;\n\tcase SJPEG_EXYNOS4:\n\t\t \n\t\tif (ctx->out_q.fmt->fourcc != V4L2_PIX_FMT_GREY &&\n\t\t    *ctrl_val == V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\t \n\tif (ctx->out_q.fmt->subsampling > *ctrl_val)\n\t\t*ctrl_val = ctx->out_q.fmt->subsampling;\n\n\treturn 0;\n}\n\nstatic int s5p_jpeg_try_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct s5p_jpeg_ctx *ctx = ctrl_to_ctx(ctrl);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&ctx->jpeg->slock, flags);\n\n\tif (ctrl->id == V4L2_CID_JPEG_CHROMA_SUBSAMPLING)\n\t\tret = s5p_jpeg_adjust_subs_ctrl(ctx, &ctrl->val);\n\n\tspin_unlock_irqrestore(&ctx->jpeg->slock, flags);\n\treturn ret;\n}\n\nstatic int s5p_jpeg_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct s5p_jpeg_ctx *ctx = ctrl_to_ctx(ctrl);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->jpeg->slock, flags);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\tctx->compr_quality = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_JPEG_RESTART_INTERVAL:\n\t\tctx->restart_interval = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_JPEG_CHROMA_SUBSAMPLING:\n\t\tctx->subsampling = ctrl->val;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&ctx->jpeg->slock, flags);\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops s5p_jpeg_ctrl_ops = {\n\t.g_volatile_ctrl\t= s5p_jpeg_g_volatile_ctrl,\n\t.try_ctrl\t\t= s5p_jpeg_try_ctrl,\n\t.s_ctrl\t\t\t= s5p_jpeg_s_ctrl,\n};\n\nstatic int s5p_jpeg_controls_create(struct s5p_jpeg_ctx *ctx)\n{\n\tunsigned int mask = ~0x27;  \n\tstruct v4l2_ctrl *ctrl;\n\tint ret;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, 3);\n\n\tif (ctx->mode == S5P_JPEG_ENCODE) {\n\t\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &s5p_jpeg_ctrl_ops,\n\t\t\t\t  V4L2_CID_JPEG_COMPRESSION_QUALITY,\n\t\t\t\t  0, 3, 1, S5P_JPEG_COMPR_QUAL_WORST);\n\n\t\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &s5p_jpeg_ctrl_ops,\n\t\t\t\t  V4L2_CID_JPEG_RESTART_INTERVAL,\n\t\t\t\t  0, 0xffff, 1, 0);\n\t\tif (ctx->jpeg->variant->version == SJPEG_S5P)\n\t\t\tmask = ~0x06;  \n\t}\n\n\tctrl = v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &s5p_jpeg_ctrl_ops,\n\t\t\t\t      V4L2_CID_JPEG_CHROMA_SUBSAMPLING,\n\t\t\t\t      V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY, mask,\n\t\t\t\t      V4L2_JPEG_CHROMA_SUBSAMPLING_422);\n\n\tif (ctx->ctrl_handler.error) {\n\t\tret = ctx->ctrl_handler.error;\n\t\tgoto error_free;\n\t}\n\n\tif (ctx->mode == S5P_JPEG_DECODE)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |\n\t\t\tV4L2_CTRL_FLAG_READ_ONLY;\n\n\tret = v4l2_ctrl_handler_setup(&ctx->ctrl_handler);\n\tif (ret < 0)\n\t\tgoto error_free;\n\n\treturn ret;\n\nerror_free:\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\treturn ret;\n}\n\nstatic const struct v4l2_ioctl_ops s5p_jpeg_ioctl_ops = {\n\t.vidioc_querycap\t\t= s5p_jpeg_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= s5p_jpeg_enum_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_out\t= s5p_jpeg_enum_fmt_vid_out,\n\n\t.vidioc_g_fmt_vid_cap\t\t= s5p_jpeg_g_fmt,\n\t.vidioc_g_fmt_vid_out\t\t= s5p_jpeg_g_fmt,\n\n\t.vidioc_try_fmt_vid_cap\t\t= s5p_jpeg_try_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_out\t\t= s5p_jpeg_try_fmt_vid_out,\n\n\t.vidioc_s_fmt_vid_cap\t\t= s5p_jpeg_s_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_out\t\t= s5p_jpeg_s_fmt_vid_out,\n\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_g_selection\t\t= s5p_jpeg_g_selection,\n\t.vidioc_s_selection\t\t= s5p_jpeg_s_selection,\n\n\t.vidioc_subscribe_event\t\t= s5p_jpeg_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\n \n\nstatic void s5p_jpeg_device_run(void *priv)\n{\n\tstruct s5p_jpeg_ctx *ctx = priv;\n\tstruct s5p_jpeg *jpeg = ctx->jpeg;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tunsigned long src_addr, dst_addr, flags;\n\n\tspin_lock_irqsave(&ctx->jpeg->slock, flags);\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tsrc_addr = vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\n\tdst_addr = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\n\ts5p_jpeg_reset(jpeg->regs);\n\ts5p_jpeg_poweron(jpeg->regs);\n\ts5p_jpeg_proc_mode(jpeg->regs, ctx->mode);\n\tif (ctx->mode == S5P_JPEG_ENCODE) {\n\t\tif (ctx->out_q.fmt->fourcc == V4L2_PIX_FMT_RGB565)\n\t\t\ts5p_jpeg_input_raw_mode(jpeg->regs,\n\t\t\t\t\t\t\tS5P_JPEG_RAW_IN_565);\n\t\telse\n\t\t\ts5p_jpeg_input_raw_mode(jpeg->regs,\n\t\t\t\t\t\t\tS5P_JPEG_RAW_IN_422);\n\t\ts5p_jpeg_subsampling_mode(jpeg->regs, ctx->subsampling);\n\t\ts5p_jpeg_dri(jpeg->regs, ctx->restart_interval);\n\t\ts5p_jpeg_x(jpeg->regs, ctx->out_q.w);\n\t\ts5p_jpeg_y(jpeg->regs, ctx->out_q.h);\n\t\ts5p_jpeg_imgadr(jpeg->regs, src_addr);\n\t\ts5p_jpeg_jpgadr(jpeg->regs, dst_addr);\n\n\t\t \n\t\ts5p_jpeg_enc_stream_int(jpeg->regs, ctx->cap_q.size);\n\n\t\t \n\t\ts5p_jpeg_coef(jpeg->regs, 1, 1, S5P_JPEG_COEF11);\n\t\ts5p_jpeg_coef(jpeg->regs, 1, 2, S5P_JPEG_COEF12);\n\t\ts5p_jpeg_coef(jpeg->regs, 1, 3, S5P_JPEG_COEF13);\n\t\ts5p_jpeg_coef(jpeg->regs, 2, 1, S5P_JPEG_COEF21);\n\t\ts5p_jpeg_coef(jpeg->regs, 2, 2, S5P_JPEG_COEF22);\n\t\ts5p_jpeg_coef(jpeg->regs, 2, 3, S5P_JPEG_COEF23);\n\t\ts5p_jpeg_coef(jpeg->regs, 3, 1, S5P_JPEG_COEF31);\n\t\ts5p_jpeg_coef(jpeg->regs, 3, 2, S5P_JPEG_COEF32);\n\t\ts5p_jpeg_coef(jpeg->regs, 3, 3, S5P_JPEG_COEF33);\n\n\t\t \n\t\ts5p_jpeg_set_qtbl_lum(jpeg->regs, ctx->compr_quality);\n\t\ts5p_jpeg_set_qtbl_chr(jpeg->regs, ctx->compr_quality);\n\t\t \n\t\ts5p_jpeg_qtbl(jpeg->regs, 1, 0);\n\t\t \n\t\ts5p_jpeg_qtbl(jpeg->regs, 2, 1);\n\t\ts5p_jpeg_qtbl(jpeg->regs, 3, 1);\n\n\t\t \n\t\ts5p_jpeg_htbl_ac(jpeg->regs, 1);\n\t\ts5p_jpeg_htbl_dc(jpeg->regs, 1);\n\t\ts5p_jpeg_htbl_ac(jpeg->regs, 2);\n\t\ts5p_jpeg_htbl_dc(jpeg->regs, 2);\n\t\ts5p_jpeg_htbl_ac(jpeg->regs, 3);\n\t\ts5p_jpeg_htbl_dc(jpeg->regs, 3);\n\t} else {  \n\t\ts5p_jpeg_rst_int_enable(jpeg->regs, true);\n\t\ts5p_jpeg_data_num_int_enable(jpeg->regs, true);\n\t\ts5p_jpeg_final_mcu_num_int_enable(jpeg->regs, true);\n\t\tif (ctx->cap_q.fmt->fourcc == V4L2_PIX_FMT_YUYV)\n\t\t\ts5p_jpeg_outform_raw(jpeg->regs, S5P_JPEG_RAW_OUT_422);\n\t\telse\n\t\t\ts5p_jpeg_outform_raw(jpeg->regs, S5P_JPEG_RAW_OUT_420);\n\t\ts5p_jpeg_jpgadr(jpeg->regs, src_addr);\n\t\ts5p_jpeg_imgadr(jpeg->regs, dst_addr);\n\t}\n\n\ts5p_jpeg_start(jpeg->regs);\n\n\tspin_unlock_irqrestore(&ctx->jpeg->slock, flags);\n}\n\nstatic void exynos4_jpeg_set_img_addr(struct s5p_jpeg_ctx *ctx)\n{\n\tstruct s5p_jpeg *jpeg = ctx->jpeg;\n\tstruct s5p_jpeg_fmt *fmt;\n\tstruct vb2_v4l2_buffer *vb;\n\tstruct s5p_jpeg_addr jpeg_addr = {};\n\tu32 pix_size, padding_bytes = 0;\n\n\tjpeg_addr.cb = 0;\n\tjpeg_addr.cr = 0;\n\n\tpix_size = ctx->cap_q.w * ctx->cap_q.h;\n\n\tif (ctx->mode == S5P_JPEG_ENCODE) {\n\t\tvb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\t\tfmt = ctx->out_q.fmt;\n\t\tif (ctx->out_q.w % 2 && fmt->h_align > 0)\n\t\t\tpadding_bytes = ctx->out_q.h;\n\t} else {\n\t\tfmt = ctx->cap_q.fmt;\n\t\tvb = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\t}\n\n\tjpeg_addr.y = vb2_dma_contig_plane_dma_addr(&vb->vb2_buf, 0);\n\n\tif (fmt->colplanes == 2) {\n\t\tjpeg_addr.cb = jpeg_addr.y + pix_size - padding_bytes;\n\t} else if (fmt->colplanes == 3) {\n\t\tjpeg_addr.cb = jpeg_addr.y + pix_size;\n\t\tif (fmt->fourcc == V4L2_PIX_FMT_YUV420)\n\t\t\tjpeg_addr.cr = jpeg_addr.cb + pix_size / 4;\n\t\telse\n\t\t\tjpeg_addr.cr = jpeg_addr.cb + pix_size / 2;\n\t}\n\n\texynos4_jpeg_set_frame_buf_address(jpeg->regs, &jpeg_addr);\n}\n\nstatic void exynos4_jpeg_set_jpeg_addr(struct s5p_jpeg_ctx *ctx)\n{\n\tstruct s5p_jpeg *jpeg = ctx->jpeg;\n\tstruct vb2_v4l2_buffer *vb;\n\tunsigned int jpeg_addr = 0;\n\n\tif (ctx->mode == S5P_JPEG_ENCODE)\n\t\tvb = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\telse\n\t\tvb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\n\tjpeg_addr = vb2_dma_contig_plane_dma_addr(&vb->vb2_buf, 0);\n\tif (jpeg->variant->version == SJPEG_EXYNOS5433 &&\n\t    ctx->mode == S5P_JPEG_DECODE)\n\t\tjpeg_addr += ctx->out_q.sos;\n\texynos4_jpeg_set_stream_buf_address(jpeg->regs, jpeg_addr);\n}\n\nstatic inline void exynos4_jpeg_set_img_fmt(void __iomem *base,\n\t\t\t\t\t    unsigned int img_fmt)\n{\n\t__exynos4_jpeg_set_img_fmt(base, img_fmt, SJPEG_EXYNOS4);\n}\n\nstatic inline void exynos5433_jpeg_set_img_fmt(void __iomem *base,\n\t\t\t\t\t       unsigned int img_fmt)\n{\n\t__exynos4_jpeg_set_img_fmt(base, img_fmt, SJPEG_EXYNOS5433);\n}\n\nstatic inline void exynos4_jpeg_set_enc_out_fmt(void __iomem *base,\n\t\t\t\t\t\tunsigned int out_fmt)\n{\n\t__exynos4_jpeg_set_enc_out_fmt(base, out_fmt, SJPEG_EXYNOS4);\n}\n\nstatic inline void exynos5433_jpeg_set_enc_out_fmt(void __iomem *base,\n\t\t\t\t\t\t   unsigned int out_fmt)\n{\n\t__exynos4_jpeg_set_enc_out_fmt(base, out_fmt, SJPEG_EXYNOS5433);\n}\n\nstatic void exynos4_jpeg_device_run(void *priv)\n{\n\tstruct s5p_jpeg_ctx *ctx = priv;\n\tstruct s5p_jpeg *jpeg = ctx->jpeg;\n\tunsigned int bitstream_size;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&jpeg->slock, flags);\n\n\tif (ctx->mode == S5P_JPEG_ENCODE) {\n\t\texynos4_jpeg_sw_reset(jpeg->regs);\n\t\texynos4_jpeg_set_interrupt(jpeg->regs, jpeg->variant->version);\n\t\texynos4_jpeg_set_huf_table_enable(jpeg->regs, 1);\n\n\t\texynos4_jpeg_set_huff_tbl(jpeg->regs);\n\n\t\t \n\t\texynos4_jpeg_set_qtbl_lum(jpeg->regs, ctx->compr_quality);\n\t\texynos4_jpeg_set_qtbl_chr(jpeg->regs, ctx->compr_quality);\n\n\t\texynos4_jpeg_set_encode_tbl_select(jpeg->regs,\n\t\t\t\t\t\t\tctx->compr_quality);\n\t\texynos4_jpeg_set_stream_size(jpeg->regs, ctx->cap_q.w,\n\t\t\t\t\t\t\tctx->cap_q.h);\n\n\t\tif (ctx->jpeg->variant->version == SJPEG_EXYNOS4) {\n\t\t\texynos4_jpeg_set_enc_out_fmt(jpeg->regs,\n\t\t\t\t\t\t     ctx->subsampling);\n\t\t\texynos4_jpeg_set_img_fmt(jpeg->regs,\n\t\t\t\t\t\t ctx->out_q.fmt->fourcc);\n\t\t} else {\n\t\t\texynos5433_jpeg_set_enc_out_fmt(jpeg->regs,\n\t\t\t\t\t\t\tctx->subsampling);\n\t\t\texynos5433_jpeg_set_img_fmt(jpeg->regs,\n\t\t\t\t\t\t    ctx->out_q.fmt->fourcc);\n\t\t}\n\t\texynos4_jpeg_set_img_addr(ctx);\n\t\texynos4_jpeg_set_jpeg_addr(ctx);\n\t\texynos4_jpeg_set_encode_hoff_cnt(jpeg->regs,\n\t\t\t\t\t\t\tctx->out_q.fmt->fourcc);\n\t} else {\n\t\texynos4_jpeg_sw_reset(jpeg->regs);\n\t\texynos4_jpeg_set_interrupt(jpeg->regs,\n\t\t\t\t\t   jpeg->variant->version);\n\t\texynos4_jpeg_set_img_addr(ctx);\n\t\texynos4_jpeg_set_jpeg_addr(ctx);\n\n\t\tif (jpeg->variant->version == SJPEG_EXYNOS5433) {\n\t\t\texynos4_jpeg_parse_huff_tbl(ctx);\n\t\t\texynos4_jpeg_parse_decode_h_tbl(ctx);\n\n\t\t\texynos4_jpeg_parse_q_tbl(ctx);\n\t\t\texynos4_jpeg_parse_decode_q_tbl(ctx);\n\n\t\t\texynos4_jpeg_set_huf_table_enable(jpeg->regs, 1);\n\n\t\t\texynos4_jpeg_set_stream_size(jpeg->regs, ctx->cap_q.w,\n\t\t\t\t\tctx->cap_q.h);\n\t\t\texynos5433_jpeg_set_enc_out_fmt(jpeg->regs,\n\t\t\t\t\t\t\tctx->subsampling);\n\t\t\texynos5433_jpeg_set_img_fmt(jpeg->regs,\n\t\t\t\t\t\t    ctx->cap_q.fmt->fourcc);\n\t\t\tbitstream_size = DIV_ROUND_UP(ctx->out_q.size, 16);\n\t\t} else {\n\t\t\texynos4_jpeg_set_img_fmt(jpeg->regs,\n\t\t\t\t\t\t ctx->cap_q.fmt->fourcc);\n\t\t\tbitstream_size = DIV_ROUND_UP(ctx->out_q.size, 32);\n\t\t}\n\n\t\texynos4_jpeg_set_dec_bitstream_size(jpeg->regs, bitstream_size);\n\t}\n\n\texynos4_jpeg_set_sys_int_enable(jpeg->regs, 1);\n\texynos4_jpeg_set_enc_dec_mode(jpeg->regs, ctx->mode);\n\n\tspin_unlock_irqrestore(&jpeg->slock, flags);\n}\n\nstatic void exynos3250_jpeg_set_img_addr(struct s5p_jpeg_ctx *ctx)\n{\n\tstruct s5p_jpeg *jpeg = ctx->jpeg;\n\tstruct s5p_jpeg_fmt *fmt;\n\tstruct vb2_v4l2_buffer *vb;\n\tstruct s5p_jpeg_addr jpeg_addr = {};\n\tu32 pix_size;\n\n\tpix_size = ctx->cap_q.w * ctx->cap_q.h;\n\n\tif (ctx->mode == S5P_JPEG_ENCODE) {\n\t\tvb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\t\tfmt = ctx->out_q.fmt;\n\t} else {\n\t\tvb = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\t\tfmt = ctx->cap_q.fmt;\n\t}\n\n\tjpeg_addr.y = vb2_dma_contig_plane_dma_addr(&vb->vb2_buf, 0);\n\n\tif (fmt->colplanes == 2) {\n\t\tjpeg_addr.cb = jpeg_addr.y + pix_size;\n\t} else if (fmt->colplanes == 3) {\n\t\tjpeg_addr.cb = jpeg_addr.y + pix_size;\n\t\tif (fmt->fourcc == V4L2_PIX_FMT_YUV420)\n\t\t\tjpeg_addr.cr = jpeg_addr.cb + pix_size / 4;\n\t\telse\n\t\t\tjpeg_addr.cr = jpeg_addr.cb + pix_size / 2;\n\t}\n\n\texynos3250_jpeg_imgadr(jpeg->regs, &jpeg_addr);\n}\n\nstatic void exynos3250_jpeg_set_jpeg_addr(struct s5p_jpeg_ctx *ctx)\n{\n\tstruct s5p_jpeg *jpeg = ctx->jpeg;\n\tstruct vb2_v4l2_buffer *vb;\n\tunsigned int jpeg_addr = 0;\n\n\tif (ctx->mode == S5P_JPEG_ENCODE)\n\t\tvb = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\telse\n\t\tvb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\n\tjpeg_addr = vb2_dma_contig_plane_dma_addr(&vb->vb2_buf, 0);\n\texynos3250_jpeg_jpgadr(jpeg->regs, jpeg_addr);\n}\n\nstatic void exynos3250_jpeg_device_run(void *priv)\n{\n\tstruct s5p_jpeg_ctx *ctx = priv;\n\tstruct s5p_jpeg *jpeg = ctx->jpeg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->jpeg->slock, flags);\n\n\texynos3250_jpeg_reset(jpeg->regs);\n\texynos3250_jpeg_set_dma_num(jpeg->regs);\n\texynos3250_jpeg_poweron(jpeg->regs);\n\texynos3250_jpeg_clk_set(jpeg->regs);\n\texynos3250_jpeg_proc_mode(jpeg->regs, ctx->mode);\n\n\tif (ctx->mode == S5P_JPEG_ENCODE) {\n\t\texynos3250_jpeg_input_raw_fmt(jpeg->regs,\n\t\t\t\t\t      ctx->out_q.fmt->fourcc);\n\t\texynos3250_jpeg_dri(jpeg->regs, ctx->restart_interval);\n\n\t\t \n\t\ts5p_jpeg_set_qtbl_lum(jpeg->regs, ctx->compr_quality);\n\t\ts5p_jpeg_set_qtbl_chr(jpeg->regs, ctx->compr_quality);\n\t\t \n\t\texynos3250_jpeg_qtbl(jpeg->regs, 1, 0);\n\t\t \n\t\texynos3250_jpeg_qtbl(jpeg->regs, 2, 1);\n\t\texynos3250_jpeg_qtbl(jpeg->regs, 3, 1);\n\n\t\t \n\t\tif (jpeg->variant->htbl_reinit) {\n\t\t\ts5p_jpeg_set_hdctbl(jpeg->regs);\n\t\t\ts5p_jpeg_set_hdctblg(jpeg->regs);\n\t\t\ts5p_jpeg_set_hactbl(jpeg->regs);\n\t\t\ts5p_jpeg_set_hactblg(jpeg->regs);\n\t\t}\n\n\t\t \n\t\texynos3250_jpeg_htbl_ac(jpeg->regs, 1);\n\t\texynos3250_jpeg_htbl_dc(jpeg->regs, 1);\n\t\texynos3250_jpeg_htbl_ac(jpeg->regs, 2);\n\t\texynos3250_jpeg_htbl_dc(jpeg->regs, 2);\n\t\texynos3250_jpeg_htbl_ac(jpeg->regs, 3);\n\t\texynos3250_jpeg_htbl_dc(jpeg->regs, 3);\n\n\t\texynos3250_jpeg_set_x(jpeg->regs, ctx->crop_rect.width);\n\t\texynos3250_jpeg_set_y(jpeg->regs, ctx->crop_rect.height);\n\t\texynos3250_jpeg_stride(jpeg->regs, ctx->out_q.fmt->fourcc,\n\t\t\t\t\t\t\t\tctx->out_q.w);\n\t\texynos3250_jpeg_offset(jpeg->regs, ctx->crop_rect.left,\n\t\t\t\t\t\t\tctx->crop_rect.top);\n\t\texynos3250_jpeg_set_img_addr(ctx);\n\t\texynos3250_jpeg_set_jpeg_addr(ctx);\n\t\texynos3250_jpeg_subsampling_mode(jpeg->regs, ctx->subsampling);\n\n\t\t \n\t\texynos3250_jpeg_enc_stream_bound(jpeg->regs, ctx->cap_q.size);\n\n\t\tif (ctx->out_q.fmt->fourcc == V4L2_PIX_FMT_RGB565 ||\n\t\t    ctx->out_q.fmt->fourcc == V4L2_PIX_FMT_RGB565X ||\n\t\t    ctx->out_q.fmt->fourcc == V4L2_PIX_FMT_RGB32)\n\t\t\texynos3250_jpeg_set_y16(jpeg->regs, true);\n\t} else {\n\t\texynos3250_jpeg_set_img_addr(ctx);\n\t\texynos3250_jpeg_set_jpeg_addr(ctx);\n\t\texynos3250_jpeg_stride(jpeg->regs, ctx->cap_q.fmt->fourcc,\n\t\t\t\t\t\t\t\tctx->cap_q.w);\n\t\texynos3250_jpeg_offset(jpeg->regs, 0, 0);\n\t\texynos3250_jpeg_dec_scaling_ratio(jpeg->regs,\n\t\t\t\t\t\t\tctx->scale_factor);\n\t\texynos3250_jpeg_dec_stream_size(jpeg->regs, ctx->out_q.size);\n\t\texynos3250_jpeg_output_raw_fmt(jpeg->regs,\n\t\t\t\t\t\tctx->cap_q.fmt->fourcc);\n\t}\n\n\texynos3250_jpeg_interrupts_enable(jpeg->regs);\n\n\t \n\texynos3250_jpeg_coef(jpeg->regs, ctx->mode);\n\n\texynos3250_jpeg_set_timer(jpeg->regs, EXYNOS3250_IRQ_TIMEOUT);\n\tjpeg->irq_status = 0;\n\texynos3250_jpeg_start(jpeg->regs);\n\n\tspin_unlock_irqrestore(&ctx->jpeg->slock, flags);\n}\n\nstatic int s5p_jpeg_job_ready(void *priv)\n{\n\tstruct s5p_jpeg_ctx *ctx = priv;\n\n\tif (ctx->mode == S5P_JPEG_DECODE) {\n\t\t \n\t\tif (ctx->state == JPEGCTX_RESOLUTION_CHANGE)\n\t\t\treturn 0;\n\n\t\treturn ctx->hdr_parsed;\n\t}\n\n\treturn 1;\n}\n\nstatic const struct v4l2_m2m_ops s5p_jpeg_m2m_ops = {\n\t.device_run\t= s5p_jpeg_device_run,\n\t.job_ready\t= s5p_jpeg_job_ready,\n};\n\nstatic const struct v4l2_m2m_ops exynos3250_jpeg_m2m_ops = {\n\t.device_run\t= exynos3250_jpeg_device_run,\n\t.job_ready\t= s5p_jpeg_job_ready,\n};\n\nstatic const struct v4l2_m2m_ops exynos4_jpeg_m2m_ops = {\n\t.device_run\t= exynos4_jpeg_device_run,\n\t.job_ready\t= s5p_jpeg_job_ready,\n};\n\n \n\nstatic int s5p_jpeg_queue_setup(struct vb2_queue *vq,\n\t\t\t   unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct s5p_jpeg_q_data *q_data = NULL;\n\tunsigned int size, count = *nbuffers;\n\n\tq_data = get_q_data(ctx, vq->type);\n\tBUG_ON(q_data == NULL);\n\n\tsize = q_data->size;\n\n\t \n\tif (ctx->mode == S5P_JPEG_DECODE)\n\t\tcount = 1;\n\n\t*nbuffers = count;\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic int s5p_jpeg_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct s5p_jpeg_q_data *q_data = NULL;\n\n\tq_data = get_q_data(ctx, vb->vb2_queue->type);\n\tBUG_ON(q_data == NULL);\n\n\tif (vb2_plane_size(vb, 0) < q_data->size) {\n\t\tpr_err(\"%s data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t\t__func__, vb2_plane_size(vb, 0),\n\t\t\t\t(long)q_data->size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, q_data->size);\n\n\treturn 0;\n}\n\nstatic void s5p_jpeg_set_capture_queue_data(struct s5p_jpeg_ctx *ctx)\n{\n\tstruct s5p_jpeg_q_data *q_data = &ctx->cap_q;\n\n\tq_data->w = ctx->out_q.w;\n\tq_data->h = ctx->out_q.h;\n\n\t \n\tjpeg_bound_align_image(ctx, &q_data->w, S5P_JPEG_MIN_WIDTH,\n\t\t\t       S5P_JPEG_MAX_WIDTH, q_data->fmt->h_align,\n\t\t\t       &q_data->h, S5P_JPEG_MIN_HEIGHT,\n\t\t\t       S5P_JPEG_MAX_HEIGHT, q_data->fmt->v_align);\n\n\tq_data->size = q_data->w * q_data->h * q_data->fmt->depth >> 3;\n}\n\nstatic void s5p_jpeg_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tif (ctx->mode == S5P_JPEG_DECODE &&\n\t    vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tstatic const struct v4l2_event ev_src_ch = {\n\t\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n\t\t};\n\t\tstruct vb2_queue *dst_vq;\n\t\tu32 ori_w;\n\t\tu32 ori_h;\n\n\t\tdst_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\tori_w = ctx->out_q.w;\n\t\tori_h = ctx->out_q.h;\n\n\t\tctx->hdr_parsed = s5p_jpeg_parse_hdr(&ctx->out_q,\n\t\t     (unsigned long)vb2_plane_vaddr(vb, 0),\n\t\t     min((unsigned long)ctx->out_q.size,\n\t\t\t vb2_get_plane_payload(vb, 0)), ctx);\n\t\tif (!ctx->hdr_parsed) {\n\t\t\tvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (ctx->out_q.w != ori_w || ctx->out_q.h != ori_h) {\n\t\t\tv4l2_event_queue_fh(&ctx->fh, &ev_src_ch);\n\t\t\tif (vb2_is_streaming(dst_vq))\n\t\t\t\tctx->state = JPEGCTX_RESOLUTION_CHANGE;\n\t\t\telse\n\t\t\t\ts5p_jpeg_set_capture_queue_data(ctx);\n\t\t}\n\t}\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int s5p_jpeg_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(q);\n\n\treturn pm_runtime_resume_and_get(ctx->jpeg->dev);\n}\n\nstatic void s5p_jpeg_stop_streaming(struct vb2_queue *q)\n{\n\tstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(q);\n\n\t \n\tif (ctx->state == JPEGCTX_RESOLUTION_CHANGE &&\n\t    q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\ts5p_jpeg_set_capture_queue_data(ctx);\n\t\tctx->state = JPEGCTX_RUNNING;\n\t}\n\n\tpm_runtime_put(ctx->jpeg->dev);\n}\n\nstatic const struct vb2_ops s5p_jpeg_qops = {\n\t.queue_setup\t\t= s5p_jpeg_queue_setup,\n\t.buf_prepare\t\t= s5p_jpeg_buf_prepare,\n\t.buf_queue\t\t= s5p_jpeg_buf_queue,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.start_streaming\t= s5p_jpeg_start_streaming,\n\t.stop_streaming\t\t= s5p_jpeg_stop_streaming,\n};\n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct s5p_jpeg_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->ops = &s5p_jpeg_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->jpeg->lock;\n\tsrc_vq->dev = ctx->jpeg->dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_USERPTR;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops = &s5p_jpeg_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->jpeg->lock;\n\tdst_vq->dev = ctx->jpeg->dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\n \n\nstatic irqreturn_t s5p_jpeg_irq(int irq, void *dev_id)\n{\n\tstruct s5p_jpeg *jpeg = dev_id;\n\tstruct s5p_jpeg_ctx *curr_ctx;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tunsigned long payload_size = 0;\n\tenum vb2_buffer_state state = VB2_BUF_STATE_DONE;\n\tbool enc_jpeg_too_large = false;\n\tbool timer_elapsed = false;\n\tbool op_completed = false;\n\n\tspin_lock(&jpeg->slock);\n\n\tcurr_ctx = v4l2_m2m_get_curr_priv(jpeg->m2m_dev);\n\n\tsrc_buf = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\n\n\tif (curr_ctx->mode == S5P_JPEG_ENCODE)\n\t\tenc_jpeg_too_large = s5p_jpeg_enc_stream_stat(jpeg->regs);\n\ttimer_elapsed = s5p_jpeg_timer_stat(jpeg->regs);\n\top_completed = s5p_jpeg_result_stat_ok(jpeg->regs);\n\tif (curr_ctx->mode == S5P_JPEG_DECODE)\n\t\top_completed = op_completed &&\n\t\t\t\t\ts5p_jpeg_stream_stat_ok(jpeg->regs);\n\n\tif (enc_jpeg_too_large) {\n\t\tstate = VB2_BUF_STATE_ERROR;\n\t\ts5p_jpeg_clear_enc_stream_stat(jpeg->regs);\n\t} else if (timer_elapsed) {\n\t\tstate = VB2_BUF_STATE_ERROR;\n\t\ts5p_jpeg_clear_timer_stat(jpeg->regs);\n\t} else if (!op_completed) {\n\t\tstate = VB2_BUF_STATE_ERROR;\n\t} else {\n\t\tpayload_size = s5p_jpeg_compressed_size(jpeg->regs);\n\t}\n\n\tdst_buf->timecode = src_buf->timecode;\n\tdst_buf->vb2_buf.timestamp = src_buf->vb2_buf.timestamp;\n\tdst_buf->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst_buf->flags |=\n\t\tsrc_buf->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\tv4l2_m2m_buf_done(src_buf, state);\n\tif (curr_ctx->mode == S5P_JPEG_ENCODE)\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, payload_size);\n\tv4l2_m2m_buf_done(dst_buf, state);\n\n\tcurr_ctx->subsampling = s5p_jpeg_get_subsampling_mode(jpeg->regs);\n\tspin_unlock(&jpeg->slock);\n\n\ts5p_jpeg_clear_int(jpeg->regs);\n\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, curr_ctx->fh.m2m_ctx);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t exynos4_jpeg_irq(int irq, void *priv)\n{\n\tunsigned int int_status;\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\tstruct s5p_jpeg *jpeg = priv;\n\tstruct s5p_jpeg_ctx *curr_ctx;\n\tunsigned long payload_size = 0;\n\n\tspin_lock(&jpeg->slock);\n\n\texynos4_jpeg_set_sys_int_enable(jpeg->regs, 0);\n\n\tcurr_ctx = v4l2_m2m_get_curr_priv(jpeg->m2m_dev);\n\n\tsrc_vb = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\n\tdst_vb = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\n\n\tint_status = exynos4_jpeg_get_int_status(jpeg->regs);\n\n\tif (int_status) {\n\t\tswitch (int_status & 0x1f) {\n\t\tcase 0x1:\n\t\t\tjpeg->irq_ret = ERR_PROT;\n\t\t\tbreak;\n\t\tcase 0x2:\n\t\t\tjpeg->irq_ret = OK_ENC_OR_DEC;\n\t\t\tbreak;\n\t\tcase 0x4:\n\t\t\tjpeg->irq_ret = ERR_DEC_INVALID_FORMAT;\n\t\t\tbreak;\n\t\tcase 0x8:\n\t\t\tjpeg->irq_ret = ERR_MULTI_SCAN;\n\t\t\tbreak;\n\t\tcase 0x10:\n\t\t\tjpeg->irq_ret = ERR_FRAME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjpeg->irq_ret = ERR_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tjpeg->irq_ret = ERR_UNKNOWN;\n\t}\n\n\tif (jpeg->irq_ret == OK_ENC_OR_DEC) {\n\t\tif (curr_ctx->mode == S5P_JPEG_ENCODE) {\n\t\t\tpayload_size = exynos4_jpeg_get_stream_size(jpeg->regs);\n\t\t\tvb2_set_plane_payload(&dst_vb->vb2_buf,\n\t\t\t\t\t0, payload_size);\n\t\t}\n\t\tv4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_DONE);\n\t} else {\n\t\tv4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_ERROR);\n\t\tv4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_ERROR);\n\t}\n\n\tif (jpeg->variant->version == SJPEG_EXYNOS4)\n\t\tcurr_ctx->subsampling = exynos4_jpeg_get_frame_fmt(jpeg->regs);\n\n\texynos4_jpeg_set_enc_dec_mode(jpeg->regs, S5P_JPEG_DISABLE);\n\n\tspin_unlock(&jpeg->slock);\n\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, curr_ctx->fh.m2m_ctx);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t exynos3250_jpeg_irq(int irq, void *dev_id)\n{\n\tstruct s5p_jpeg *jpeg = dev_id;\n\tstruct s5p_jpeg_ctx *curr_ctx;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tunsigned long payload_size = 0;\n\tenum vb2_buffer_state state = VB2_BUF_STATE_DONE;\n\tbool interrupt_timeout = false;\n\tbool stream_error = false;\n\tu32 irq_status;\n\n\tspin_lock(&jpeg->slock);\n\n\tirq_status = exynos3250_jpeg_get_timer_status(jpeg->regs);\n\tif (irq_status & EXYNOS3250_TIMER_INT_STAT) {\n\t\texynos3250_jpeg_clear_timer_status(jpeg->regs);\n\t\tinterrupt_timeout = true;\n\t\tdev_err(jpeg->dev, \"Interrupt timeout occurred.\\n\");\n\t}\n\n\tirq_status = exynos3250_jpeg_get_int_status(jpeg->regs);\n\texynos3250_jpeg_clear_int_status(jpeg->regs, irq_status);\n\n\tjpeg->irq_status |= irq_status;\n\n\tif (jpeg->variant->version == SJPEG_EXYNOS5420 &&\n\t    irq_status & EXYNOS3250_STREAM_STAT) {\n\t\tstream_error = true;\n\t\tdev_err(jpeg->dev, \"Syntax error or unrecoverable error occurred.\\n\");\n\t}\n\n\tcurr_ctx = v4l2_m2m_get_curr_priv(jpeg->m2m_dev);\n\n\tif (!curr_ctx)\n\t\tgoto exit_unlock;\n\n\tif ((irq_status & EXYNOS3250_HEADER_STAT) &&\n\t    (curr_ctx->mode == S5P_JPEG_DECODE)) {\n\t\texynos3250_jpeg_rstart(jpeg->regs);\n\t\tgoto exit_unlock;\n\t}\n\n\tif (jpeg->irq_status & (EXYNOS3250_JPEG_DONE |\n\t\t\t\tEXYNOS3250_WDMA_DONE |\n\t\t\t\tEXYNOS3250_RDMA_DONE |\n\t\t\t\tEXYNOS3250_RESULT_STAT))\n\t\tpayload_size = exynos3250_jpeg_compressed_size(jpeg->regs);\n\telse if (interrupt_timeout || stream_error)\n\t\tstate = VB2_BUF_STATE_ERROR;\n\telse\n\t\tgoto exit_unlock;\n\n\tsrc_buf = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\n\n\tdst_buf->timecode = src_buf->timecode;\n\tdst_buf->vb2_buf.timestamp = src_buf->vb2_buf.timestamp;\n\n\tv4l2_m2m_buf_done(src_buf, state);\n\tif (curr_ctx->mode == S5P_JPEG_ENCODE)\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, payload_size);\n\tv4l2_m2m_buf_done(dst_buf, state);\n\n\tcurr_ctx->subsampling =\n\t\t\texynos3250_jpeg_get_subsampling_mode(jpeg->regs);\n\n\tspin_unlock(&jpeg->slock);\n\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, curr_ctx->fh.m2m_ctx);\n\treturn IRQ_HANDLED;\n\nexit_unlock:\n\tspin_unlock(&jpeg->slock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void *jpeg_get_drv_data(struct device *dev);\n\n \n\nstatic int s5p_jpeg_probe(struct platform_device *pdev)\n{\n\tstruct s5p_jpeg *jpeg;\n\tint i, ret;\n\n\t \n\tjpeg = devm_kzalloc(&pdev->dev, sizeof(struct s5p_jpeg), GFP_KERNEL);\n\tif (!jpeg)\n\t\treturn -ENOMEM;\n\n\tjpeg->variant = jpeg_get_drv_data(&pdev->dev);\n\tif (!jpeg->variant)\n\t\treturn -ENODEV;\n\n\tmutex_init(&jpeg->lock);\n\tspin_lock_init(&jpeg->slock);\n\tjpeg->dev = &pdev->dev;\n\n\t \n\tjpeg->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(jpeg->regs))\n\t\treturn PTR_ERR(jpeg->regs);\n\n\t \n\tjpeg->irq = ret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_request_irq(&pdev->dev, jpeg->irq, jpeg->variant->jpeg_irq,\n\t\t\t\t0, dev_name(&pdev->dev), jpeg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot claim IRQ %d\\n\", jpeg->irq);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < jpeg->variant->num_clocks; i++) {\n\t\tjpeg->clocks[i] = devm_clk_get(&pdev->dev,\n\t\t\t\t\t      jpeg->variant->clk_names[i]);\n\t\tif (IS_ERR(jpeg->clocks[i])) {\n\t\t\tdev_err(&pdev->dev, \"failed to get clock: %s\\n\",\n\t\t\t\tjpeg->variant->clk_names[i]);\n\t\t\treturn PTR_ERR(jpeg->clocks[i]);\n\t\t}\n\t}\n\n\t \n\tret = v4l2_device_register(&pdev->dev, &jpeg->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register v4l2 device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tjpeg->m2m_dev = v4l2_m2m_init(jpeg->variant->m2m_ops);\n\tif (IS_ERR(jpeg->m2m_dev)) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(jpeg->m2m_dev);\n\t\tgoto device_register_rollback;\n\t}\n\n\tvb2_dma_contig_set_max_seg_size(&pdev->dev, DMA_BIT_MASK(32));\n\n\t \n\tjpeg->vfd_encoder = video_device_alloc();\n\tif (!jpeg->vfd_encoder) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"Failed to allocate video device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto m2m_init_rollback;\n\t}\n\tsnprintf(jpeg->vfd_encoder->name, sizeof(jpeg->vfd_encoder->name),\n\t\t\t\t\"%s-enc\", S5P_JPEG_M2M_NAME);\n\tjpeg->vfd_encoder->fops\t\t= &s5p_jpeg_fops;\n\tjpeg->vfd_encoder->ioctl_ops\t= &s5p_jpeg_ioctl_ops;\n\tjpeg->vfd_encoder->minor\t= -1;\n\tjpeg->vfd_encoder->release\t= video_device_release;\n\tjpeg->vfd_encoder->lock\t\t= &jpeg->lock;\n\tjpeg->vfd_encoder->v4l2_dev\t= &jpeg->v4l2_dev;\n\tjpeg->vfd_encoder->vfl_dir\t= VFL_DIR_M2M;\n\tjpeg->vfd_encoder->device_caps\t= V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M;\n\n\tret = video_register_device(jpeg->vfd_encoder, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"Failed to register video device\\n\");\n\t\tvideo_device_release(jpeg->vfd_encoder);\n\t\tgoto m2m_init_rollback;\n\t}\n\n\tvideo_set_drvdata(jpeg->vfd_encoder, jpeg);\n\tv4l2_info(&jpeg->v4l2_dev,\n\t\t  \"encoder device registered as /dev/video%d\\n\",\n\t\t  jpeg->vfd_encoder->num);\n\n\t \n\tjpeg->vfd_decoder = video_device_alloc();\n\tif (!jpeg->vfd_decoder) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"Failed to allocate video device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto enc_vdev_register_rollback;\n\t}\n\tsnprintf(jpeg->vfd_decoder->name, sizeof(jpeg->vfd_decoder->name),\n\t\t\t\t\"%s-dec\", S5P_JPEG_M2M_NAME);\n\tjpeg->vfd_decoder->fops\t\t= &s5p_jpeg_fops;\n\tjpeg->vfd_decoder->ioctl_ops\t= &s5p_jpeg_ioctl_ops;\n\tjpeg->vfd_decoder->minor\t= -1;\n\tjpeg->vfd_decoder->release\t= video_device_release;\n\tjpeg->vfd_decoder->lock\t\t= &jpeg->lock;\n\tjpeg->vfd_decoder->v4l2_dev\t= &jpeg->v4l2_dev;\n\tjpeg->vfd_decoder->vfl_dir\t= VFL_DIR_M2M;\n\tjpeg->vfd_decoder->device_caps\t= V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M;\n\n\tret = video_register_device(jpeg->vfd_decoder, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"Failed to register video device\\n\");\n\t\tvideo_device_release(jpeg->vfd_decoder);\n\t\tgoto enc_vdev_register_rollback;\n\t}\n\n\tvideo_set_drvdata(jpeg->vfd_decoder, jpeg);\n\tv4l2_info(&jpeg->v4l2_dev,\n\t\t  \"decoder device registered as /dev/video%d\\n\",\n\t\t  jpeg->vfd_decoder->num);\n\n\t \n\tplatform_set_drvdata(pdev, jpeg);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tv4l2_info(&jpeg->v4l2_dev, \"Samsung S5P JPEG codec\\n\");\n\n\treturn 0;\n\nenc_vdev_register_rollback:\n\tvideo_unregister_device(jpeg->vfd_encoder);\n\nm2m_init_rollback:\n\tv4l2_m2m_release(jpeg->m2m_dev);\n\ndevice_register_rollback:\n\tv4l2_device_unregister(&jpeg->v4l2_dev);\n\n\treturn ret;\n}\n\nstatic void s5p_jpeg_remove(struct platform_device *pdev)\n{\n\tstruct s5p_jpeg *jpeg = platform_get_drvdata(pdev);\n\tint i;\n\n\tpm_runtime_disable(jpeg->dev);\n\n\tvideo_unregister_device(jpeg->vfd_decoder);\n\tvideo_unregister_device(jpeg->vfd_encoder);\n\tvb2_dma_contig_clear_max_seg_size(&pdev->dev);\n\tv4l2_m2m_release(jpeg->m2m_dev);\n\tv4l2_device_unregister(&jpeg->v4l2_dev);\n\n\tif (!pm_runtime_status_suspended(&pdev->dev)) {\n\t\tfor (i = jpeg->variant->num_clocks - 1; i >= 0; i--)\n\t\t\tclk_disable_unprepare(jpeg->clocks[i]);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int s5p_jpeg_runtime_suspend(struct device *dev)\n{\n\tstruct s5p_jpeg *jpeg = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = jpeg->variant->num_clocks - 1; i >= 0; i--)\n\t\tclk_disable_unprepare(jpeg->clocks[i]);\n\n\treturn 0;\n}\n\nstatic int s5p_jpeg_runtime_resume(struct device *dev)\n{\n\tstruct s5p_jpeg *jpeg = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tint i, ret;\n\n\tfor (i = 0; i < jpeg->variant->num_clocks; i++) {\n\t\tret = clk_prepare_enable(jpeg->clocks[i]);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tclk_disable_unprepare(jpeg->clocks[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&jpeg->slock, flags);\n\n\t \n\tif (!jpeg->variant->htbl_reinit) {\n\t\ts5p_jpeg_set_hdctbl(jpeg->regs);\n\t\ts5p_jpeg_set_hdctblg(jpeg->regs);\n\t\ts5p_jpeg_set_hactbl(jpeg->regs);\n\t\ts5p_jpeg_set_hactblg(jpeg->regs);\n\t}\n\n\tspin_unlock_irqrestore(&jpeg->slock, flags);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct dev_pm_ops s5p_jpeg_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(s5p_jpeg_runtime_suspend, s5p_jpeg_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct s5p_jpeg_variant s5p_jpeg_drvdata = {\n\t.version\t= SJPEG_S5P,\n\t.jpeg_irq\t= s5p_jpeg_irq,\n\t.m2m_ops\t= &s5p_jpeg_m2m_ops,\n\t.fmt_ver_flag\t= SJPEG_FMT_FLAG_S5P,\n\t.clk_names\t= {\"jpeg\"},\n\t.num_clocks\t= 1,\n};\n\nstatic struct s5p_jpeg_variant exynos3250_jpeg_drvdata = {\n\t.version\t= SJPEG_EXYNOS3250,\n\t.jpeg_irq\t= exynos3250_jpeg_irq,\n\t.m2m_ops\t= &exynos3250_jpeg_m2m_ops,\n\t.fmt_ver_flag\t= SJPEG_FMT_FLAG_EXYNOS3250,\n\t.hw3250_compat\t= 1,\n\t.clk_names\t= {\"jpeg\", \"sclk\"},\n\t.num_clocks\t= 2,\n};\n\nstatic struct s5p_jpeg_variant exynos4_jpeg_drvdata = {\n\t.version\t= SJPEG_EXYNOS4,\n\t.jpeg_irq\t= exynos4_jpeg_irq,\n\t.m2m_ops\t= &exynos4_jpeg_m2m_ops,\n\t.fmt_ver_flag\t= SJPEG_FMT_FLAG_EXYNOS4,\n\t.htbl_reinit\t= 1,\n\t.clk_names\t= {\"jpeg\"},\n\t.num_clocks\t= 1,\n\t.hw_ex4_compat\t= 1,\n};\n\nstatic struct s5p_jpeg_variant exynos5420_jpeg_drvdata = {\n\t.version\t= SJPEG_EXYNOS5420,\n\t.jpeg_irq\t= exynos3250_jpeg_irq,\t\t \n\t.m2m_ops\t= &exynos3250_jpeg_m2m_ops,\t \n\t.fmt_ver_flag\t= SJPEG_FMT_FLAG_EXYNOS3250,\t \n\t.hw3250_compat\t= 1,\n\t.htbl_reinit\t= 1,\n\t.clk_names\t= {\"jpeg\"},\n\t.num_clocks\t= 1,\n};\n\nstatic struct s5p_jpeg_variant exynos5433_jpeg_drvdata = {\n\t.version\t= SJPEG_EXYNOS5433,\n\t.jpeg_irq\t= exynos4_jpeg_irq,\n\t.m2m_ops\t= &exynos4_jpeg_m2m_ops,\n\t.fmt_ver_flag\t= SJPEG_FMT_FLAG_EXYNOS4,\n\t.htbl_reinit\t= 1,\n\t.clk_names\t= {\"pclk\", \"aclk\", \"aclk_xiu\", \"sclk\"},\n\t.num_clocks\t= 4,\n\t.hw_ex4_compat\t= 1,\n};\n\nstatic const struct of_device_id samsung_jpeg_match[] = {\n\t{\n\t\t.compatible = \"samsung,s5pv210-jpeg\",\n\t\t.data = &s5p_jpeg_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos3250-jpeg\",\n\t\t.data = &exynos3250_jpeg_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos4210-jpeg\",\n\t\t.data = &exynos4_jpeg_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos4212-jpeg\",\n\t\t.data = &exynos4_jpeg_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos5420-jpeg\",\n\t\t.data = &exynos5420_jpeg_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos5433-jpeg\",\n\t\t.data = &exynos5433_jpeg_drvdata,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, samsung_jpeg_match);\n\nstatic void *jpeg_get_drv_data(struct device *dev)\n{\n\tstruct s5p_jpeg_variant *driver_data = NULL;\n\tconst struct of_device_id *match;\n\n\tif (!IS_ENABLED(CONFIG_OF) || !dev->of_node)\n\t\treturn &s5p_jpeg_drvdata;\n\n\tmatch = of_match_node(samsung_jpeg_match, dev->of_node);\n\n\tif (match)\n\t\tdriver_data = (struct s5p_jpeg_variant *)match->data;\n\n\treturn driver_data;\n}\n\nstatic struct platform_driver s5p_jpeg_driver = {\n\t.probe = s5p_jpeg_probe,\n\t.remove_new = s5p_jpeg_remove,\n\t.driver = {\n\t\t.of_match_table\t= samsung_jpeg_match,\n\t\t.name\t\t= S5P_JPEG_M2M_NAME,\n\t\t.pm\t\t= &s5p_jpeg_pm_ops,\n\t},\n};\n\nmodule_platform_driver(s5p_jpeg_driver);\n\nMODULE_AUTHOR(\"Andrzej Pietrasiewicz <andrzejtp2010@gmail.com>\");\nMODULE_AUTHOR(\"Jacek Anaszewski <j.anaszewski@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung JPEG codec driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}