{
  "module_name": "jpeg-hw-exynos3250.c",
  "hash_id": "03888d7e99ddcacd29bbf7a7e66916d9f5ba9ddef87018275c615df1f70a5f3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s5p-jpeg/jpeg-hw-exynos3250.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/videodev2.h>\n#include <linux/delay.h>\n\n#include \"jpeg-core.h\"\n#include \"jpeg-regs.h\"\n#include \"jpeg-hw-exynos3250.h\"\n\nvoid exynos3250_jpeg_reset(void __iomem *regs)\n{\n\tu32 reg = 1;\n\tint count = 1000;\n\n\twritel(1, regs + EXYNOS3250_SW_RESET);\n\t \n\twhile (reg != 0 && --count > 0) {\n\t\tudelay(1);\n\t\tcpu_relax();\n\t\treg = readl(regs + EXYNOS3250_SW_RESET);\n\t}\n\n\treg = 0;\n\tcount = 1000;\n\n\twhile (reg != 1 && --count > 0) {\n\t\twritel(1, regs + EXYNOS3250_JPGDRI);\n\t\tudelay(1);\n\t\tcpu_relax();\n\t\treg = readl(regs + EXYNOS3250_JPGDRI);\n\t}\n\n\twritel(0, regs + EXYNOS3250_JPGDRI);\n}\n\nvoid exynos3250_jpeg_poweron(void __iomem *regs)\n{\n\twritel(EXYNOS3250_POWER_ON, regs + EXYNOS3250_JPGCLKCON);\n}\n\nvoid exynos3250_jpeg_set_dma_num(void __iomem *regs)\n{\n\twritel(((EXYNOS3250_DMA_MO_COUNT << EXYNOS3250_WDMA_ISSUE_NUM_SHIFT) &\n\t\t\tEXYNOS3250_WDMA_ISSUE_NUM_MASK) |\n\t       ((EXYNOS3250_DMA_MO_COUNT << EXYNOS3250_RDMA_ISSUE_NUM_SHIFT) &\n\t\t\tEXYNOS3250_RDMA_ISSUE_NUM_MASK) |\n\t       ((EXYNOS3250_DMA_MO_COUNT << EXYNOS3250_ISSUE_GATHER_NUM_SHIFT) &\n\t\t\tEXYNOS3250_ISSUE_GATHER_NUM_MASK),\n\t\tregs + EXYNOS3250_DMA_ISSUE_NUM);\n}\n\nvoid exynos3250_jpeg_clk_set(void __iomem *base)\n{\n\tu32 reg;\n\n\treg = readl(base + EXYNOS3250_JPGCMOD) & ~EXYNOS3250_HALF_EN_MASK;\n\n\twritel(reg | EXYNOS3250_HALF_EN, base + EXYNOS3250_JPGCMOD);\n}\n\nvoid exynos3250_jpeg_input_raw_fmt(void __iomem *regs, unsigned int fmt)\n{\n\tu32 reg;\n\n\treg = readl(regs + EXYNOS3250_JPGCMOD) &\n\t\t\tEXYNOS3250_MODE_Y16_MASK;\n\n\tswitch (fmt) {\n\tcase V4L2_PIX_FMT_RGB32:\n\t\treg |= EXYNOS3250_MODE_SEL_ARGB8888;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\t\treg |= EXYNOS3250_MODE_SEL_ARGB8888 | EXYNOS3250_SRC_SWAP_RGB;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565:\n\t\treg |= EXYNOS3250_MODE_SEL_RGB565;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565X:\n\t\treg |= EXYNOS3250_MODE_SEL_RGB565 | EXYNOS3250_SRC_SWAP_RGB;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\t\treg |= EXYNOS3250_MODE_SEL_422_1P_LUM_CHR;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YVYU:\n\t\treg |= EXYNOS3250_MODE_SEL_422_1P_LUM_CHR |\n\t\t\tEXYNOS3250_SRC_SWAP_UV;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_UYVY:\n\t\treg |= EXYNOS3250_MODE_SEL_422_1P_CHR_LUM;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VYUY:\n\t\treg |= EXYNOS3250_MODE_SEL_422_1P_CHR_LUM |\n\t\t\tEXYNOS3250_SRC_SWAP_UV;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12:\n\t\treg |= EXYNOS3250_MODE_SEL_420_2P | EXYNOS3250_SRC_NV12;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV21:\n\t\treg |= EXYNOS3250_MODE_SEL_420_2P | EXYNOS3250_SRC_NV21;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420:\n\t\treg |= EXYNOS3250_MODE_SEL_420_3P;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n\n\twritel(reg, regs + EXYNOS3250_JPGCMOD);\n}\n\nvoid exynos3250_jpeg_set_y16(void __iomem *regs, bool y16)\n{\n\tu32 reg;\n\n\treg = readl(regs + EXYNOS3250_JPGCMOD);\n\tif (y16)\n\t\treg |= EXYNOS3250_MODE_Y16;\n\telse\n\t\treg &= ~EXYNOS3250_MODE_Y16_MASK;\n\twritel(reg, regs + EXYNOS3250_JPGCMOD);\n}\n\nvoid exynos3250_jpeg_proc_mode(void __iomem *regs, unsigned int mode)\n{\n\tu32 reg, m;\n\n\tif (mode == S5P_JPEG_ENCODE)\n\t\tm = EXYNOS3250_PROC_MODE_COMPR;\n\telse\n\t\tm = EXYNOS3250_PROC_MODE_DECOMPR;\n\treg = readl(regs + EXYNOS3250_JPGMOD);\n\treg &= ~EXYNOS3250_PROC_MODE_MASK;\n\treg |= m;\n\twritel(reg, regs + EXYNOS3250_JPGMOD);\n}\n\nvoid exynos3250_jpeg_subsampling_mode(void __iomem *regs, unsigned int mode)\n{\n\tu32 reg, m = 0;\n\n\tswitch (mode) {\n\tcase V4L2_JPEG_CHROMA_SUBSAMPLING_444:\n\t\tm = EXYNOS3250_SUBSAMPLING_MODE_444;\n\t\tbreak;\n\tcase V4L2_JPEG_CHROMA_SUBSAMPLING_422:\n\t\tm = EXYNOS3250_SUBSAMPLING_MODE_422;\n\t\tbreak;\n\tcase V4L2_JPEG_CHROMA_SUBSAMPLING_420:\n\t\tm = EXYNOS3250_SUBSAMPLING_MODE_420;\n\t\tbreak;\n\t}\n\n\treg = readl(regs + EXYNOS3250_JPGMOD);\n\treg &= ~EXYNOS3250_SUBSAMPLING_MODE_MASK;\n\treg |= m;\n\twritel(reg, regs + EXYNOS3250_JPGMOD);\n}\n\nunsigned int exynos3250_jpeg_get_subsampling_mode(void __iomem *regs)\n{\n\treturn readl(regs + EXYNOS3250_JPGMOD) &\n\t\t\t\tEXYNOS3250_SUBSAMPLING_MODE_MASK;\n}\n\nvoid exynos3250_jpeg_dri(void __iomem *regs, unsigned int dri)\n{\n\tu32 reg;\n\n\treg = dri & EXYNOS3250_JPGDRI_MASK;\n\twritel(reg, regs + EXYNOS3250_JPGDRI);\n}\n\nvoid exynos3250_jpeg_qtbl(void __iomem *regs, unsigned int t, unsigned int n)\n{\n\tunsigned long reg;\n\n\treg = readl(regs + EXYNOS3250_QHTBL);\n\treg &= ~EXYNOS3250_QT_NUM_MASK(t);\n\treg |= (n << EXYNOS3250_QT_NUM_SHIFT(t)) &\n\t\t\t\t\tEXYNOS3250_QT_NUM_MASK(t);\n\twritel(reg, regs + EXYNOS3250_QHTBL);\n}\n\nvoid exynos3250_jpeg_htbl_ac(void __iomem *regs, unsigned int t)\n{\n\tunsigned long reg;\n\n\treg = readl(regs + EXYNOS3250_QHTBL);\n\treg &= ~EXYNOS3250_HT_NUM_AC_MASK(t);\n\t \n\treg |= (0 << EXYNOS3250_HT_NUM_AC_SHIFT(t)) &\n\t\t\t\t\tEXYNOS3250_HT_NUM_AC_MASK(t);\n\twritel(reg, regs + EXYNOS3250_QHTBL);\n}\n\nvoid exynos3250_jpeg_htbl_dc(void __iomem *regs, unsigned int t)\n{\n\tunsigned long reg;\n\n\treg = readl(regs + EXYNOS3250_QHTBL);\n\treg &= ~EXYNOS3250_HT_NUM_DC_MASK(t);\n\t \n\treg |= (0 << EXYNOS3250_HT_NUM_DC_SHIFT(t)) &\n\t\t\t\t\tEXYNOS3250_HT_NUM_DC_MASK(t);\n\twritel(reg, regs + EXYNOS3250_QHTBL);\n}\n\nvoid exynos3250_jpeg_set_y(void __iomem *regs, unsigned int y)\n{\n\tu32 reg;\n\n\treg = y & EXYNOS3250_JPGY_MASK;\n\twritel(reg, regs + EXYNOS3250_JPGY);\n}\n\nvoid exynos3250_jpeg_set_x(void __iomem *regs, unsigned int x)\n{\n\tu32 reg;\n\n\treg = x & EXYNOS3250_JPGX_MASK;\n\twritel(reg, regs + EXYNOS3250_JPGX);\n}\n\n#if 0\t \nunsigned int exynos3250_jpeg_get_y(void __iomem *regs)\n{\n\treturn readl(regs + EXYNOS3250_JPGY);\n}\n\nunsigned int exynos3250_jpeg_get_x(void __iomem *regs)\n{\n\treturn readl(regs + EXYNOS3250_JPGX);\n}\n#endif\n\nvoid exynos3250_jpeg_interrupts_enable(void __iomem *regs)\n{\n\tu32 reg;\n\n\treg = readl(regs + EXYNOS3250_JPGINTSE);\n\treg |= (EXYNOS3250_JPEG_DONE_EN |\n\t\tEXYNOS3250_WDMA_DONE_EN |\n\t\tEXYNOS3250_RDMA_DONE_EN |\n\t\tEXYNOS3250_ENC_STREAM_INT_EN |\n\t\tEXYNOS3250_CORE_DONE_EN |\n\t\tEXYNOS3250_ERR_INT_EN |\n\t\tEXYNOS3250_HEAD_INT_EN);\n\twritel(reg, regs + EXYNOS3250_JPGINTSE);\n}\n\nvoid exynos3250_jpeg_enc_stream_bound(void __iomem *regs, unsigned int size)\n{\n\tu32 reg;\n\n\treg = size & EXYNOS3250_ENC_STREAM_BOUND_MASK;\n\twritel(reg, regs + EXYNOS3250_ENC_STREAM_BOUND);\n}\n\nvoid exynos3250_jpeg_output_raw_fmt(void __iomem *regs, unsigned int fmt)\n{\n\tu32 reg;\n\n\tswitch (fmt) {\n\tcase V4L2_PIX_FMT_RGB32:\n\t\treg = EXYNOS3250_OUT_FMT_ARGB8888;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_BGR32:\n\t\treg = EXYNOS3250_OUT_FMT_ARGB8888 | EXYNOS3250_OUT_SWAP_RGB;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565:\n\t\treg = EXYNOS3250_OUT_FMT_RGB565;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565X:\n\t\treg = EXYNOS3250_OUT_FMT_RGB565 | EXYNOS3250_OUT_SWAP_RGB;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\t\treg = EXYNOS3250_OUT_FMT_422_1P_LUM_CHR;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YVYU:\n\t\treg = EXYNOS3250_OUT_FMT_422_1P_LUM_CHR |\n\t\t\tEXYNOS3250_OUT_SWAP_UV;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_UYVY:\n\t\treg = EXYNOS3250_OUT_FMT_422_1P_CHR_LUM;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VYUY:\n\t\treg = EXYNOS3250_OUT_FMT_422_1P_CHR_LUM |\n\t\t\tEXYNOS3250_OUT_SWAP_UV;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12:\n\t\treg = EXYNOS3250_OUT_FMT_420_2P | EXYNOS3250_OUT_NV12;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV21:\n\t\treg = EXYNOS3250_OUT_FMT_420_2P | EXYNOS3250_OUT_NV21;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420:\n\t\treg = EXYNOS3250_OUT_FMT_420_3P;\n\t\tbreak;\n\tdefault:\n\t\treg = 0;\n\t\tbreak;\n\t}\n\n\twritel(reg, regs + EXYNOS3250_OUTFORM);\n}\n\nvoid exynos3250_jpeg_jpgadr(void __iomem *regs, unsigned int addr)\n{\n\twritel(addr, regs + EXYNOS3250_JPG_JPGADR);\n}\n\nvoid exynos3250_jpeg_imgadr(void __iomem *regs, struct s5p_jpeg_addr *img_addr)\n{\n\twritel(img_addr->y, regs + EXYNOS3250_LUMA_BASE);\n\twritel(img_addr->cb, regs + EXYNOS3250_CHROMA_BASE);\n\twritel(img_addr->cr, regs + EXYNOS3250_CHROMA_CR_BASE);\n}\n\nvoid exynos3250_jpeg_stride(void __iomem *regs, unsigned int img_fmt,\n\t\t\t    unsigned int width)\n{\n\tu32 reg_luma = 0, reg_cr = 0, reg_cb = 0;\n\n\tswitch (img_fmt) {\n\tcase V4L2_PIX_FMT_RGB32:\n\t\treg_luma = 4 * width;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_RGB565:\n\tcase V4L2_PIX_FMT_RGB565X:\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_YVYU:\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_VYUY:\n\t\treg_luma = 2 * width;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\t\treg_luma = width;\n\t\treg_cb = reg_luma;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV420:\n\t\treg_luma = width;\n\t\treg_cb = reg_cr = reg_luma / 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twritel(reg_luma, regs + EXYNOS3250_LUMA_STRIDE);\n\twritel(reg_cb, regs + EXYNOS3250_CHROMA_STRIDE);\n\twritel(reg_cr, regs + EXYNOS3250_CHROMA_CR_STRIDE);\n}\n\nvoid exynos3250_jpeg_offset(void __iomem *regs, unsigned int x_offset,\n\t\t\t\tunsigned int y_offset)\n{\n\tu32 reg;\n\n\treg = (y_offset << EXYNOS3250_LUMA_YY_OFFSET_SHIFT) &\n\t\t\tEXYNOS3250_LUMA_YY_OFFSET_MASK;\n\treg |= (x_offset << EXYNOS3250_LUMA_YX_OFFSET_SHIFT) &\n\t\t\tEXYNOS3250_LUMA_YX_OFFSET_MASK;\n\n\twritel(reg, regs + EXYNOS3250_LUMA_XY_OFFSET);\n\n\treg = (y_offset << EXYNOS3250_CHROMA_YY_OFFSET_SHIFT) &\n\t\t\tEXYNOS3250_CHROMA_YY_OFFSET_MASK;\n\treg |= (x_offset << EXYNOS3250_CHROMA_YX_OFFSET_SHIFT) &\n\t\t\tEXYNOS3250_CHROMA_YX_OFFSET_MASK;\n\n\twritel(reg, regs + EXYNOS3250_CHROMA_XY_OFFSET);\n\n\treg = (y_offset << EXYNOS3250_CHROMA_CR_YY_OFFSET_SHIFT) &\n\t\t\tEXYNOS3250_CHROMA_CR_YY_OFFSET_MASK;\n\treg |= (x_offset << EXYNOS3250_CHROMA_CR_YX_OFFSET_SHIFT) &\n\t\t\tEXYNOS3250_CHROMA_CR_YX_OFFSET_MASK;\n\n\twritel(reg, regs + EXYNOS3250_CHROMA_CR_XY_OFFSET);\n}\n\nvoid exynos3250_jpeg_coef(void __iomem *base, unsigned int mode)\n{\n\tif (mode == S5P_JPEG_ENCODE) {\n\t\twritel(EXYNOS3250_JPEG_ENC_COEF1,\n\t\t\t\t\tbase + EXYNOS3250_JPG_COEF(1));\n\t\twritel(EXYNOS3250_JPEG_ENC_COEF2,\n\t\t\t\t\tbase + EXYNOS3250_JPG_COEF(2));\n\t\twritel(EXYNOS3250_JPEG_ENC_COEF3,\n\t\t\t\t\tbase + EXYNOS3250_JPG_COEF(3));\n\t} else {\n\t\twritel(EXYNOS3250_JPEG_DEC_COEF1,\n\t\t\t\t\tbase + EXYNOS3250_JPG_COEF(1));\n\t\twritel(EXYNOS3250_JPEG_DEC_COEF2,\n\t\t\t\t\tbase + EXYNOS3250_JPG_COEF(2));\n\t\twritel(EXYNOS3250_JPEG_DEC_COEF3,\n\t\t\t\t\tbase + EXYNOS3250_JPG_COEF(3));\n\t}\n}\n\nvoid exynos3250_jpeg_start(void __iomem *regs)\n{\n\twritel(1, regs + EXYNOS3250_JSTART);\n}\n\nvoid exynos3250_jpeg_rstart(void __iomem *regs)\n{\n\twritel(1, regs + EXYNOS3250_JRSTART);\n}\n\nunsigned int exynos3250_jpeg_get_int_status(void __iomem *regs)\n{\n\treturn readl(regs + EXYNOS3250_JPGINTST);\n}\n\nvoid exynos3250_jpeg_clear_int_status(void __iomem *regs,\n\t\t\t\t      unsigned int value)\n{\n\twritel(value, regs + EXYNOS3250_JPGINTST);\n}\n\nunsigned int exynos3250_jpeg_operating(void __iomem *regs)\n{\n\treturn readl(regs + S5P_JPGOPR) & EXYNOS3250_JPGOPR_MASK;\n}\n\nunsigned int exynos3250_jpeg_compressed_size(void __iomem *regs)\n{\n\treturn readl(regs + EXYNOS3250_JPGCNT) & EXYNOS3250_JPGCNT_MASK;\n}\n\nvoid exynos3250_jpeg_dec_stream_size(void __iomem *regs,\n\t\t\t\t\t\tunsigned int size)\n{\n\twritel(size & EXYNOS3250_DEC_STREAM_MASK,\n\t\t\t\tregs + EXYNOS3250_DEC_STREAM_SIZE);\n}\n\nvoid exynos3250_jpeg_dec_scaling_ratio(void __iomem *regs,\n\t\t\t\t\t\tunsigned int sratio)\n{\n\tswitch (sratio) {\n\tcase 1:\n\tdefault:\n\t\tsratio = EXYNOS3250_DEC_SCALE_FACTOR_8_8;\n\t\tbreak;\n\tcase 2:\n\t\tsratio = EXYNOS3250_DEC_SCALE_FACTOR_4_8;\n\t\tbreak;\n\tcase 4:\n\t\tsratio = EXYNOS3250_DEC_SCALE_FACTOR_2_8;\n\t\tbreak;\n\tcase 8:\n\t\tsratio = EXYNOS3250_DEC_SCALE_FACTOR_1_8;\n\t\tbreak;\n\t}\n\n\twritel(sratio & EXYNOS3250_DEC_SCALE_FACTOR_MASK,\n\t\t\t\tregs + EXYNOS3250_DEC_SCALING_RATIO);\n}\n\nvoid exynos3250_jpeg_set_timer(void __iomem *regs, unsigned int time_value)\n{\n\ttime_value &= EXYNOS3250_TIMER_INIT_MASK;\n\n\twritel(EXYNOS3250_TIMER_INT_STAT | time_value,\n\t\t\t\t\tregs + EXYNOS3250_TIMER_SE);\n}\n\nunsigned int exynos3250_jpeg_get_timer_status(void __iomem *regs)\n{\n\treturn readl(regs + EXYNOS3250_TIMER_ST);\n}\n\nvoid exynos3250_jpeg_clear_timer_status(void __iomem *regs)\n{\n\twritel(EXYNOS3250_TIMER_INT_STAT, regs + EXYNOS3250_TIMER_ST);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}