{
  "module_name": "camif-core.h",
  "hash_id": "43b698f591e7b9e1b34887832b6974196d7f6d8fe8193a0d42b01a7f09ae720a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s3c-camif/camif-core.h",
  "human_readable_source": " \n \n\n#ifndef CAMIF_CORE_H_\n#define CAMIF_CORE_H_\n\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n\n#include <media/media-entity.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-mediabus.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/drv-intf/s3c_camif.h>\n\n#define S3C_CAMIF_DRIVER_NAME\t\"s3c-camif\"\n#define CAMIF_REQ_BUFS_MIN\t3\n#define CAMIF_MAX_OUT_BUFS\t4\n#define CAMIF_MAX_PIX_WIDTH\t4096\n#define CAMIF_MAX_PIX_HEIGHT\t4096\n#define SCALER_MAX_RATIO\t64\n#define CAMIF_DEF_WIDTH\t\t640\n#define CAMIF_DEF_HEIGHT\t480\n#define CAMIF_STOP_TIMEOUT\t1500  \n\n#define S3C244X_CAMIF_IP_REV\t0x20  \n#define S3C2450_CAMIF_IP_REV\t0x30  \n#define S3C6400_CAMIF_IP_REV\t0x31  \n#define S3C6410_CAMIF_IP_REV\t0x32  \n\n \n\n#define ST_VP_PENDING\t\t(1 << 0)\n#define ST_VP_RUNNING\t\t(1 << 1)\n#define ST_VP_STREAMING\t\t(1 << 2)\n#define ST_VP_SENSOR_STREAMING\t(1 << 3)\n\n#define ST_VP_ABORTING\t\t(1 << 4)\n#define ST_VP_OFF\t\t(1 << 5)\n#define ST_VP_LASTIRQ\t\t(1 << 6)\n\n#define ST_VP_CONFIG\t\t(1 << 8)\n\n#define CAMIF_SD_PAD_SINK\t0\n#define CAMIF_SD_PAD_SOURCE_C\t1\n#define CAMIF_SD_PAD_SOURCE_P\t2\n#define CAMIF_SD_PADS_NUM\t3\n\nenum img_fmt {\n\tIMG_FMT_RGB565 = 0x0010,\n\tIMG_FMT_RGB666,\n\tIMG_FMT_XRGB8888,\n\tIMG_FMT_YCBCR420 = 0x0020,\n\tIMG_FMT_YCRCB420,\n\tIMG_FMT_YCBCR422P,\n\tIMG_FMT_YCBYCR422 = 0x0040,\n\tIMG_FMT_YCRYCB422,\n\tIMG_FMT_CBYCRY422,\n\tIMG_FMT_CRYCBY422,\n};\n\n#define img_fmt_is_rgb(x) ((x) & 0x10)\n#define img_fmt_is_ycbcr(x) ((x) & 0x60)\n\n \n#define FMT_FL_S3C24XX_CODEC\t(1 << 0)\n#define FMT_FL_S3C24XX_PREVIEW\t(1 << 1)\n#define FMT_FL_S3C64XX\t\t(1 << 2)\n\n \nstruct camif_fmt {\n\tu32 fourcc;\n\tu32 color;\n\tu16 colplanes;\n\tu16 flags;\n\tu8 depth;\n\tu8 ybpp;\n};\n\n \nstruct camif_dma_offset {\n\tint\tinitial;\n\tint\tline;\n};\n\n \nstruct camif_frame {\n\tu16 f_width;\n\tu16 f_height;\n\tstruct v4l2_rect rect;\n\tstruct camif_dma_offset dma_offset;\n};\n\n \nenum {\n\tCLK_GATE,\n\tCLK_CAM,\n\tCLK_MAX_NUM,\n};\n\nstruct vp_pix_limits {\n\tu16 max_out_width;\n\tu16 max_sc_out_width;\n\tu16 out_width_align;\n\tu16 max_height;\n\tu8 min_out_width;\n\tu16 out_hor_offset_align;\n};\n\nstruct camif_pix_limits {\n\tu16 win_hor_offset_align;\n};\n\n \nstruct s3c_camif_variant {\n\tstruct vp_pix_limits vp_pix_limits[2];\n\tstruct camif_pix_limits pix_limits;\n\tu8 ip_revision;\n\tu8 has_img_effect;\n\tunsigned int vp_offset;\n};\n\nstruct s3c_camif_drvdata {\n\tconst struct s3c_camif_variant *variant;\n\tunsigned long bus_clk_freq;\n};\n\nstruct camif_scaler {\n\tu8 scaleup_h;\n\tu8 scaleup_v;\n\tu8 copy;\n\tu8 enable;\n\tu32 h_shift;\n\tu32 v_shift;\n\tu32 pre_h_ratio;\n\tu32 pre_v_ratio;\n\tu32 pre_dst_width;\n\tu32 pre_dst_height;\n\tu32 main_h_ratio;\n\tu32 main_v_ratio;\n};\n\nstruct camif_dev;\n\n \nstruct camif_vp {\n\twait_queue_head_t\tirq_queue;\n\tint\t\t\tirq;\n\tstruct camif_dev\t*camif;\n\tstruct media_pad\tpad;\n\tstruct video_device\tvdev;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct v4l2_fh\t\t*owner;\n\tstruct vb2_queue\tvb_queue;\n\tstruct list_head\tpending_buf_q;\n\tstruct list_head\tactive_buf_q;\n\tunsigned int\t\tactive_buffers;\n\tunsigned int\t\tbuf_index;\n\tunsigned int\t\tframe_sequence;\n\tunsigned int\t\treqbufs_count;\n\tstruct camif_scaler\tscaler;\n\tconst struct camif_fmt\t*out_fmt;\n\tunsigned int\t\tpayload;\n\tstruct camif_frame\tout_frame;\n\tunsigned int\t\tstate;\n\tu16\t\t\tfmt_flags;\n\tu8\t\t\tid;\n\tu16\t\t\trotation;\n\tu8\t\t\thflip;\n\tu8\t\t\tvflip;\n\tunsigned int\t\toffset;\n};\n\n \n#define VP_CODEC\t0\n#define VP_PREVIEW\t1\n#define CAMIF_VP_NUM\t2\n\n \nstruct camif_dev {\n\tstruct media_device\t\tmedia_dev;\n\tstruct v4l2_device\t\tv4l2_dev;\n\tstruct v4l2_subdev\t\tsubdev;\n\tstruct v4l2_mbus_framefmt\tmbus_fmt;\n\tstruct v4l2_rect\t\tcamif_crop;\n\tstruct media_pad\t\tpads[CAMIF_SD_PADS_NUM];\n\tint\t\t\t\tstream_count;\n\n\tstruct cam_sensor {\n\t\tstruct v4l2_subdev\t*sd;\n\t\tshort\t\t\tpower_count;\n\t\tshort\t\t\tstream_count;\n\t} sensor;\n\tstruct media_pipeline\t\t*m_pipeline;\n\n\tstruct v4l2_ctrl_handler\tctrl_handler;\n\tstruct v4l2_ctrl\t\t*ctrl_test_pattern;\n\tstruct {\n\t\tstruct v4l2_ctrl\t*ctrl_colorfx;\n\t\tstruct v4l2_ctrl\t*ctrl_colorfx_cbcr;\n\t};\n\tu8\t\t\t\ttest_pattern;\n\tu8\t\t\t\tcolorfx;\n\tu8\t\t\t\tcolorfx_cb;\n\tu8\t\t\t\tcolorfx_cr;\n\n\tstruct camif_vp\t\t\tvp[CAMIF_VP_NUM];\n\n\tconst struct s3c_camif_variant\t*variant;\n\tstruct device\t\t\t*dev;\n\tstruct s3c_camif_plat_data\tpdata;\n\tstruct clk\t\t\t*clock[CLK_MAX_NUM];\n\tstruct mutex\t\t\tlock;\n\tspinlock_t\t\t\tslock;\n\tvoid __iomem\t\t\t*io_base;\n};\n\n \nstruct camif_addr {\n\tdma_addr_t y;\n\tdma_addr_t cb;\n\tdma_addr_t cr;\n};\n\n \nstruct camif_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n\tstruct camif_addr paddr;\n\tunsigned int index;\n};\n\nconst struct camif_fmt *s3c_camif_find_format(struct camif_vp *vp,\n\t      const u32 *pixelformat, int index);\nint s3c_camif_register_video_node(struct camif_dev *camif, int idx);\nvoid s3c_camif_unregister_video_node(struct camif_dev *camif, int idx);\nirqreturn_t s3c_camif_irq_handler(int irq, void *priv);\nint s3c_camif_create_subdev(struct camif_dev *camif);\nvoid s3c_camif_unregister_subdev(struct camif_dev *camif);\nint s3c_camif_set_defaults(struct camif_dev *camif);\nint s3c_camif_get_scaler_config(struct camif_vp *vp,\n\t\t\t\tstruct camif_scaler *scaler);\n\nstatic inline void camif_active_queue_add(struct camif_vp *vp,\n\t\t\t\t\t  struct camif_buffer *buf)\n{\n\tlist_add_tail(&buf->list, &vp->active_buf_q);\n\tvp->active_buffers++;\n}\n\nstatic inline struct camif_buffer *camif_active_queue_pop(\n\t\t\t\t\tstruct camif_vp *vp)\n{\n\tstruct camif_buffer *buf = list_first_entry(&vp->active_buf_q,\n\t\t\t\t\t      struct camif_buffer, list);\n\tlist_del(&buf->list);\n\tvp->active_buffers--;\n\treturn buf;\n}\n\nstatic inline struct camif_buffer *camif_active_queue_peek(\n\t\t\t   struct camif_vp *vp, int index)\n{\n\tstruct camif_buffer *tmp, *buf;\n\n\tif (WARN_ON(list_empty(&vp->active_buf_q)))\n\t\treturn NULL;\n\n\tlist_for_each_entry_safe(buf, tmp, &vp->active_buf_q, list) {\n\t\tif (buf->index == index) {\n\t\t\tlist_del(&buf->list);\n\t\t\tvp->active_buffers--;\n\t\t\treturn buf;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic inline void camif_pending_queue_add(struct camif_vp *vp,\n\t\t\t\t\t   struct camif_buffer *buf)\n{\n\tlist_add_tail(&buf->list, &vp->pending_buf_q);\n}\n\nstatic inline struct camif_buffer *camif_pending_queue_pop(\n\t\t\t\t\tstruct camif_vp *vp)\n{\n\tstruct camif_buffer *buf = list_first_entry(&vp->pending_buf_q,\n\t\t\t\t\t      struct camif_buffer, list);\n\tlist_del(&buf->list);\n\treturn buf;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}