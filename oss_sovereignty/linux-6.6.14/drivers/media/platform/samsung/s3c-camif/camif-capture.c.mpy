{
  "module_name": "camif-capture.c",
  "hash_id": "0d847c0d115989b75a5522b5894a0f893896158a8233e3bb509552af11c0abc5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s3c-camif/camif-capture.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"%s:%d \" fmt, __func__, __LINE__\n\n#include <linux/bug.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n\n#include <media/media-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"camif-core.h\"\n#include \"camif-regs.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\n\n \nstatic void camif_cfg_video_path(struct camif_vp *vp)\n{\n\tWARN_ON(s3c_camif_get_scaler_config(vp, &vp->scaler));\n\tcamif_hw_set_scaler(vp);\n\tcamif_hw_set_flip(vp);\n\tcamif_hw_set_target_format(vp);\n\tcamif_hw_set_output_dma(vp);\n}\n\nstatic void camif_prepare_dma_offset(struct camif_vp *vp)\n{\n\tstruct camif_frame *f = &vp->out_frame;\n\n\tf->dma_offset.initial = f->rect.top * f->f_width + f->rect.left;\n\tf->dma_offset.line = f->f_width - (f->rect.left + f->rect.width);\n\n\tpr_debug(\"dma_offset: initial: %d, line: %d\\n\",\n\t\t f->dma_offset.initial, f->dma_offset.line);\n}\n\n \nstatic int s3c_camif_hw_init(struct camif_dev *camif, struct camif_vp *vp)\n{\n\tconst struct s3c_camif_variant *variant = camif->variant;\n\n\tif (camif->sensor.sd == NULL || vp->out_fmt == NULL)\n\t\treturn -EINVAL;\n\n\tif (variant->ip_revision == S3C244X_CAMIF_IP_REV)\n\t\tcamif_hw_clear_fifo_overflow(vp);\n\tcamif_hw_set_camera_bus(camif);\n\tcamif_hw_set_source_format(camif);\n\tcamif_hw_set_camera_crop(camif);\n\tcamif_hw_set_test_pattern(camif, camif->test_pattern);\n\tif (variant->has_img_effect)\n\t\tcamif_hw_set_effect(camif, camif->colorfx,\n\t\t\t\tcamif->colorfx_cr, camif->colorfx_cb);\n\tif (variant->ip_revision == S3C6410_CAMIF_IP_REV)\n\t\tcamif_hw_set_input_path(vp);\n\tcamif_cfg_video_path(vp);\n\tvp->state &= ~ST_VP_CONFIG;\n\n\treturn 0;\n}\n\n \nstatic int s3c_camif_hw_vp_init(struct camif_dev *camif, struct camif_vp *vp)\n{\n\tunsigned int ip_rev = camif->variant->ip_revision;\n\n\tif (vp->out_fmt == NULL)\n\t\treturn -EINVAL;\n\n\tcamif_prepare_dma_offset(vp);\n\tif (ip_rev == S3C244X_CAMIF_IP_REV)\n\t\tcamif_hw_clear_fifo_overflow(vp);\n\tcamif_cfg_video_path(vp);\n\tvp->state &= ~ST_VP_CONFIG;\n\treturn 0;\n}\n\nstatic int sensor_set_power(struct camif_dev *camif, int on)\n{\n\tstruct cam_sensor *sensor = &camif->sensor;\n\tint err = 0;\n\n\tif (camif->sensor.power_count == !on)\n\t\terr = v4l2_subdev_call(sensor->sd, core, s_power, on);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = 0;\n\tif (!err)\n\t\tsensor->power_count += on ? 1 : -1;\n\n\tpr_debug(\"on: %d, power_count: %d, err: %d\\n\",\n\t\t on, sensor->power_count, err);\n\n\treturn err;\n}\n\nstatic int sensor_set_streaming(struct camif_dev *camif, int on)\n{\n\tstruct cam_sensor *sensor = &camif->sensor;\n\tint err = 0;\n\n\tif (camif->sensor.stream_count == !on)\n\t\terr = v4l2_subdev_call(sensor->sd, video, s_stream, on);\n\tif (!err)\n\t\tsensor->stream_count += on ? 1 : -1;\n\n\tpr_debug(\"on: %d, stream_count: %d, err: %d\\n\",\n\t\t on, sensor->stream_count, err);\n\n\treturn err;\n}\n\n \nstatic int camif_reinitialize(struct camif_vp *vp)\n{\n\tstruct camif_dev *camif = vp->camif;\n\tstruct camif_buffer *buf;\n\tunsigned long flags;\n\tbool streaming;\n\n\tspin_lock_irqsave(&camif->slock, flags);\n\tstreaming = vp->state & ST_VP_SENSOR_STREAMING;\n\n\tvp->state &= ~(ST_VP_PENDING | ST_VP_RUNNING | ST_VP_OFF |\n\t\t       ST_VP_ABORTING | ST_VP_STREAMING |\n\t\t       ST_VP_SENSOR_STREAMING | ST_VP_LASTIRQ);\n\n\t \n\twhile (!list_empty(&vp->pending_buf_q)) {\n\t\tbuf = camif_pending_queue_pop(vp);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\n\twhile (!list_empty(&vp->active_buf_q)) {\n\t\tbuf = camif_active_queue_pop(vp);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\n\tspin_unlock_irqrestore(&camif->slock, flags);\n\n\tif (!streaming)\n\t\treturn 0;\n\n\treturn sensor_set_streaming(camif, 0);\n}\n\nstatic bool s3c_vp_active(struct camif_vp *vp)\n{\n\tstruct camif_dev *camif = vp->camif;\n\tunsigned long flags;\n\tbool ret;\n\n\tspin_lock_irqsave(&camif->slock, flags);\n\tret = (vp->state & ST_VP_RUNNING) || (vp->state & ST_VP_PENDING);\n\tspin_unlock_irqrestore(&camif->slock, flags);\n\n\treturn ret;\n}\n\nstatic bool camif_is_streaming(struct camif_dev *camif)\n{\n\tunsigned long flags;\n\tbool status;\n\n\tspin_lock_irqsave(&camif->slock, flags);\n\tstatus = camif->stream_count > 0;\n\tspin_unlock_irqrestore(&camif->slock, flags);\n\n\treturn status;\n}\n\nstatic int camif_stop_capture(struct camif_vp *vp)\n{\n\tstruct camif_dev *camif = vp->camif;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!s3c_vp_active(vp))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&camif->slock, flags);\n\tvp->state &= ~(ST_VP_OFF | ST_VP_LASTIRQ);\n\tvp->state |= ST_VP_ABORTING;\n\tspin_unlock_irqrestore(&camif->slock, flags);\n\n\tret = wait_event_timeout(vp->irq_queue,\n\t\t\t   !(vp->state & ST_VP_ABORTING),\n\t\t\t   msecs_to_jiffies(CAMIF_STOP_TIMEOUT));\n\n\tspin_lock_irqsave(&camif->slock, flags);\n\n\tif (ret == 0 && !(vp->state & ST_VP_OFF)) {\n\t\t \n\t\tvp->state &= ~(ST_VP_OFF | ST_VP_ABORTING |\n\t\t\t       ST_VP_LASTIRQ);\n\n\t\tcamif_hw_disable_capture(vp);\n\t\tcamif_hw_enable_scaler(vp, false);\n\t}\n\n\tspin_unlock_irqrestore(&camif->slock, flags);\n\n\treturn camif_reinitialize(vp);\n}\n\nstatic int camif_prepare_addr(struct camif_vp *vp, struct vb2_buffer *vb,\n\t\t\t      struct camif_addr *paddr)\n{\n\tstruct camif_frame *frame = &vp->out_frame;\n\tu32 pix_size;\n\n\tif (vb == NULL || frame == NULL)\n\t\treturn -EINVAL;\n\n\tpix_size = frame->rect.width * frame->rect.height;\n\n\tpr_debug(\"colplanes: %d, pix_size: %u\\n\",\n\t\t vp->out_fmt->colplanes, pix_size);\n\n\tpaddr->y = vb2_dma_contig_plane_dma_addr(vb, 0);\n\n\tswitch (vp->out_fmt->colplanes) {\n\tcase 1:\n\t\tpaddr->cb = 0;\n\t\tpaddr->cr = 0;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tpaddr->cb = (u32)(paddr->y + pix_size);\n\t\tpaddr->cr = 0;\n\t\tbreak;\n\tcase 3:\n\t\tpaddr->cb = (u32)(paddr->y + pix_size);\n\t\t \n\t\tif (vp->out_fmt->color == IMG_FMT_YCBCR422P)\n\t\t\tpaddr->cr = (u32)(paddr->cb + (pix_size >> 1));\n\t\telse  \n\t\t\tpaddr->cr = (u32)(paddr->cb + (pix_size >> 2));\n\n\t\tif (vp->out_fmt->color == IMG_FMT_YCRCB420)\n\t\t\tswap(paddr->cb, paddr->cr);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"DMA address: y: %pad  cb: %pad cr: %pad\\n\",\n\t\t &paddr->y, &paddr->cb, &paddr->cr);\n\n\treturn 0;\n}\n\nirqreturn_t s3c_camif_irq_handler(int irq, void *priv)\n{\n\tstruct camif_vp *vp = priv;\n\tstruct camif_dev *camif = vp->camif;\n\tunsigned int ip_rev = camif->variant->ip_revision;\n\tunsigned int status;\n\n\tspin_lock(&camif->slock);\n\n\tif (ip_rev == S3C6410_CAMIF_IP_REV)\n\t\tcamif_hw_clear_pending_irq(vp);\n\n\tstatus = camif_hw_get_status(vp);\n\n\tif (ip_rev == S3C244X_CAMIF_IP_REV && (status & CISTATUS_OVF_MASK)) {\n\t\tcamif_hw_clear_fifo_overflow(vp);\n\t\tgoto unlock;\n\t}\n\n\tif (vp->state & ST_VP_ABORTING) {\n\t\tif (vp->state & ST_VP_OFF) {\n\t\t\t \n\t\t\tvp->state &= ~(ST_VP_OFF | ST_VP_ABORTING |\n\t\t\t\t       ST_VP_LASTIRQ);\n\t\t\twake_up(&vp->irq_queue);\n\t\t\tgoto unlock;\n\t\t} else if (vp->state & ST_VP_LASTIRQ) {\n\t\t\tcamif_hw_disable_capture(vp);\n\t\t\tcamif_hw_enable_scaler(vp, false);\n\t\t\tcamif_hw_set_lastirq(vp, false);\n\t\t\tvp->state |= ST_VP_OFF;\n\t\t} else {\n\t\t\t \n\t\t\tcamif_hw_set_lastirq(vp, true);\n\t\t\tvp->state |= ST_VP_LASTIRQ;\n\t\t}\n\t}\n\n\tif (!list_empty(&vp->pending_buf_q) && (vp->state & ST_VP_RUNNING) &&\n\t    !list_empty(&vp->active_buf_q)) {\n\t\tunsigned int index;\n\t\tstruct camif_buffer *vbuf;\n\t\t \n\t\tindex = (CISTATUS_FRAMECNT(status) + 2) & 1;\n\t\tvbuf = camif_active_queue_peek(vp, index);\n\n\t\tif (!WARN_ON(vbuf == NULL)) {\n\t\t\t \n\t\t\tvbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\t\tvbuf->vb.sequence = vp->frame_sequence++;\n\t\t\tvb2_buffer_done(&vbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\n\t\t\t \n\t\t\tvbuf = camif_pending_queue_pop(vp);\n\t\t\tvbuf->index = index;\n\t\t\tcamif_hw_set_output_addr(vp, &vbuf->paddr, index);\n\t\t\tcamif_hw_set_output_addr(vp, &vbuf->paddr, index + 2);\n\n\t\t\t \n\t\t\tcamif_active_queue_add(vp, vbuf);\n\t\t}\n\t} else if (!(vp->state & ST_VP_ABORTING) &&\n\t\t   (vp->state & ST_VP_PENDING))  {\n\t\tvp->state |= ST_VP_RUNNING;\n\t}\n\n\tif (vp->state & ST_VP_CONFIG) {\n\t\tcamif_prepare_dma_offset(vp);\n\t\tcamif_hw_set_camera_crop(camif);\n\t\tcamif_hw_set_scaler(vp);\n\t\tcamif_hw_set_flip(vp);\n\t\tcamif_hw_set_test_pattern(camif, camif->test_pattern);\n\t\tif (camif->variant->has_img_effect)\n\t\t\tcamif_hw_set_effect(camif, camif->colorfx,\n\t\t\t\t    camif->colorfx_cr, camif->colorfx_cb);\n\t\tvp->state &= ~ST_VP_CONFIG;\n\t}\nunlock:\n\tspin_unlock(&camif->slock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct camif_vp *vp = vb2_get_drv_priv(vq);\n\tstruct camif_dev *camif = vp->camif;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tspin_lock_irqsave(&camif->slock, flags);\n\n\tif (camif->stream_count == 0) {\n\t\tcamif_hw_reset(camif);\n\t\tret = s3c_camif_hw_init(camif, vp);\n\t} else {\n\t\tret = s3c_camif_hw_vp_init(camif, vp);\n\t}\n\tspin_unlock_irqrestore(&camif->slock, flags);\n\n\tif (ret < 0) {\n\t\tcamif_reinitialize(vp);\n\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&camif->slock, flags);\n\tvp->frame_sequence = 0;\n\tvp->state |= ST_VP_PENDING;\n\n\tif (!list_empty(&vp->pending_buf_q) &&\n\t    (!(vp->state & ST_VP_STREAMING) ||\n\t     !(vp->state & ST_VP_SENSOR_STREAMING))) {\n\n\t\tcamif_hw_enable_scaler(vp, vp->scaler.enable);\n\t\tcamif_hw_enable_capture(vp);\n\t\tvp->state |= ST_VP_STREAMING;\n\n\t\tif (!(vp->state & ST_VP_SENSOR_STREAMING)) {\n\t\t\tvp->state |= ST_VP_SENSOR_STREAMING;\n\t\t\tspin_unlock_irqrestore(&camif->slock, flags);\n\t\t\tret = sensor_set_streaming(camif, 1);\n\t\t\tif (ret)\n\t\t\t\tv4l2_err(&vp->vdev, \"Sensor s_stream failed\\n\");\n\t\t\tif (debug)\n\t\t\t\tcamif_hw_dump_regs(camif, __func__);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&camif->slock, flags);\n\treturn 0;\n}\n\nstatic void stop_streaming(struct vb2_queue *vq)\n{\n\tstruct camif_vp *vp = vb2_get_drv_priv(vq);\n\tcamif_stop_capture(vp);\n}\n\nstatic int queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *num_buffers, unsigned int *num_planes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct camif_vp *vp = vb2_get_drv_priv(vq);\n\tstruct camif_frame *frame = &vp->out_frame;\n\tconst struct camif_fmt *fmt = vp->out_fmt;\n\tunsigned int size;\n\n\tif (fmt == NULL)\n\t\treturn -EINVAL;\n\n\tsize = (frame->f_width * frame->f_height * fmt->depth) / 8;\n\n\tif (*num_planes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*num_planes = 1;\n\tsizes[0] = size;\n\n\tpr_debug(\"size: %u\\n\", sizes[0]);\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct camif_vp *vp = vb2_get_drv_priv(vb->vb2_queue);\n\n\tif (vp->out_fmt == NULL)\n\t\treturn -EINVAL;\n\n\tif (vb2_plane_size(vb, 0) < vp->payload) {\n\t\tv4l2_err(&vp->vdev, \"buffer too small: %lu, required: %u\\n\",\n\t\t\t vb2_plane_size(vb, 0), vp->payload);\n\t\treturn -EINVAL;\n\t}\n\tvb2_set_plane_payload(vb, 0, vp->payload);\n\n\treturn 0;\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct camif_buffer *buf = container_of(vbuf, struct camif_buffer, vb);\n\tstruct camif_vp *vp = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct camif_dev *camif = vp->camif;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&camif->slock, flags);\n\tWARN_ON(camif_prepare_addr(vp, &buf->vb.vb2_buf, &buf->paddr));\n\n\tif (!(vp->state & ST_VP_STREAMING) && vp->active_buffers < 2) {\n\t\t \n\t\tbuf->index = vp->buf_index;\n\n\t\tcamif_hw_set_output_addr(vp, &buf->paddr, buf->index);\n\t\tcamif_hw_set_output_addr(vp, &buf->paddr, buf->index + 2);\n\n\t\tcamif_active_queue_add(vp, buf);\n\t\tvp->buf_index = !vp->buf_index;\n\t} else {\n\t\tcamif_pending_queue_add(vp, buf);\n\t}\n\n\tif (vb2_is_streaming(&vp->vb_queue) && !list_empty(&vp->pending_buf_q)\n\t\t&& !(vp->state & ST_VP_STREAMING)) {\n\n\t\tvp->state |= ST_VP_STREAMING;\n\t\tcamif_hw_enable_scaler(vp, vp->scaler.enable);\n\t\tcamif_hw_enable_capture(vp);\n\t\tspin_unlock_irqrestore(&camif->slock, flags);\n\n\t\tif (!(vp->state & ST_VP_SENSOR_STREAMING)) {\n\t\t\tif (sensor_set_streaming(camif, 1) == 0)\n\t\t\t\tvp->state |= ST_VP_SENSOR_STREAMING;\n\t\t\telse\n\t\t\t\tv4l2_err(&vp->vdev, \"Sensor s_stream failed\\n\");\n\n\t\t\tif (debug)\n\t\t\t\tcamif_hw_dump_regs(camif, __func__);\n\t\t}\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&camif->slock, flags);\n}\n\nstatic const struct vb2_ops s3c_camif_qops = {\n\t.queue_setup\t = queue_setup,\n\t.buf_prepare\t = buffer_prepare,\n\t.buf_queue\t = buffer_queue,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n\t.start_streaming = start_streaming,\n\t.stop_streaming\t = stop_streaming,\n};\n\nstatic int s3c_camif_open(struct file *file)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\tstruct camif_dev *camif = vp->camif;\n\tint ret;\n\n\tpr_debug(\"[vp%d] state: %#x,  owner: %p, pid: %d\\n\", vp->id,\n\t\t vp->state, vp->owner, task_pid_nr(current));\n\n\tif (mutex_lock_interruptible(&camif->lock))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_fh_open(file);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = pm_runtime_resume_and_get(camif->dev);\n\tif (ret < 0)\n\t\tgoto err_pm;\n\n\tret = sensor_set_power(camif, 1);\n\tif (!ret)\n\t\tgoto unlock;\n\n\tpm_runtime_put(camif->dev);\nerr_pm:\n\tv4l2_fh_release(file);\nunlock:\n\tmutex_unlock(&camif->lock);\n\treturn ret;\n}\n\nstatic int s3c_camif_close(struct file *file)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\tstruct camif_dev *camif = vp->camif;\n\tint ret;\n\n\tpr_debug(\"[vp%d] state: %#x, owner: %p, pid: %d\\n\", vp->id,\n\t\t vp->state, vp->owner, task_pid_nr(current));\n\n\tmutex_lock(&camif->lock);\n\n\tif (vp->owner == file->private_data) {\n\t\tcamif_stop_capture(vp);\n\t\tvb2_queue_release(&vp->vb_queue);\n\t\tvp->owner = NULL;\n\t}\n\n\tsensor_set_power(camif, 0);\n\n\tpm_runtime_put(camif->dev);\n\tret = v4l2_fh_release(file);\n\n\tmutex_unlock(&camif->lock);\n\treturn ret;\n}\n\nstatic __poll_t s3c_camif_poll(struct file *file,\n\t\t\t\t   struct poll_table_struct *wait)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\tstruct camif_dev *camif = vp->camif;\n\t__poll_t ret;\n\n\tmutex_lock(&camif->lock);\n\tif (vp->owner && vp->owner != file->private_data)\n\t\tret = EPOLLERR;\n\telse\n\t\tret = vb2_poll(&vp->vb_queue, file, wait);\n\n\tmutex_unlock(&camif->lock);\n\treturn ret;\n}\n\nstatic int s3c_camif_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\tint ret;\n\n\tif (vp->owner && vp->owner != file->private_data)\n\t\tret = -EBUSY;\n\telse\n\t\tret = vb2_mmap(&vp->vb_queue, vma);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_file_operations s3c_camif_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= s3c_camif_open,\n\t.release\t= s3c_camif_close,\n\t.poll\t\t= s3c_camif_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= s3c_camif_mmap,\n};\n\n \n\nstatic int s3c_camif_vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_capability *cap)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\n\tstrscpy(cap->driver, S3C_CAMIF_DRIVER_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, S3C_CAMIF_DRIVER_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"platform:%s.%d\",\n\t\t dev_name(vp->camif->dev), vp->id);\n\treturn 0;\n}\n\nstatic int s3c_camif_vidioc_enum_input(struct file *file, void *priv,\n\t\t\t\t       struct v4l2_input *input)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\tstruct v4l2_subdev *sensor = vp->camif->sensor.sd;\n\n\tif (input->index || sensor == NULL)\n\t\treturn -EINVAL;\n\n\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\tstrscpy(input->name, sensor->name, sizeof(input->name));\n\treturn 0;\n}\n\nstatic int s3c_camif_vidioc_s_input(struct file *file, void *priv,\n\t\t\t\t    unsigned int i)\n{\n\treturn i == 0 ? 0 : -EINVAL;\n}\n\nstatic int s3c_camif_vidioc_g_input(struct file *file, void *priv,\n\t\t\t\t    unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int s3c_camif_vidioc_enum_fmt(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_fmtdesc *f)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\tconst struct camif_fmt *fmt;\n\n\tfmt = s3c_camif_find_format(vp, NULL, f->index);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = fmt->fourcc;\n\treturn 0;\n}\n\nstatic int s3c_camif_vidioc_g_fmt(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct camif_frame *frame = &vp->out_frame;\n\tconst struct camif_fmt *fmt = vp->out_fmt;\n\n\tpix->bytesperline = frame->f_width * fmt->ybpp;\n\tpix->sizeimage = vp->payload;\n\n\tpix->pixelformat = fmt->fourcc;\n\tpix->width = frame->f_width;\n\tpix->height = frame->f_height;\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->colorspace = V4L2_COLORSPACE_JPEG;\n\n\treturn 0;\n}\n\nstatic int __camif_video_try_format(struct camif_vp *vp,\n\t\t\t\t    struct v4l2_pix_format *pix,\n\t\t\t\t    const struct camif_fmt **ffmt)\n{\n\tstruct camif_dev *camif = vp->camif;\n\tstruct v4l2_rect *crop = &camif->camif_crop;\n\tunsigned int wmin, hmin, sc_hrmax, sc_vrmax;\n\tconst struct vp_pix_limits *pix_lim;\n\tconst struct camif_fmt *fmt;\n\n\tfmt = s3c_camif_find_format(vp, &pix->pixelformat, 0);\n\n\tif (WARN_ON(fmt == NULL))\n\t\treturn -EINVAL;\n\n\tif (ffmt)\n\t\t*ffmt = fmt;\n\n\tpix_lim = &camif->variant->vp_pix_limits[vp->id];\n\n\tpr_debug(\"fmt: %ux%u, crop: %ux%u, bytesperline: %u\\n\",\n\t\t pix->width, pix->height, crop->width, crop->height,\n\t\t pix->bytesperline);\n\t \n\tsc_hrmax = min(SCALER_MAX_RATIO, 1 << (ffs(crop->width) - 3));\n\tsc_vrmax = min(SCALER_MAX_RATIO, 1 << (ffs(crop->height) - 1));\n\n\twmin = max_t(u32, pix_lim->min_out_width, crop->width / sc_hrmax);\n\twmin = round_up(wmin, pix_lim->out_width_align);\n\thmin = max_t(u32, 8, crop->height / sc_vrmax);\n\thmin = round_up(hmin, 8);\n\n\tv4l_bound_align_image(&pix->width, wmin, pix_lim->max_sc_out_width,\n\t\t\t      ffs(pix_lim->out_width_align) - 1,\n\t\t\t      &pix->height, hmin, pix_lim->max_height, 0, 0);\n\n\tpix->bytesperline = pix->width * fmt->ybpp;\n\tpix->sizeimage = (pix->width * pix->height * fmt->depth) / 8;\n\tpix->pixelformat = fmt->fourcc;\n\tpix->colorspace = V4L2_COLORSPACE_JPEG;\n\tpix->field = V4L2_FIELD_NONE;\n\n\tpr_debug(\"%ux%u, wmin: %d, hmin: %d, sc_hrmax: %d, sc_vrmax: %d\\n\",\n\t\t pix->width, pix->height, wmin, hmin, sc_hrmax, sc_vrmax);\n\n\treturn 0;\n}\n\nstatic int s3c_camif_vidioc_try_fmt(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\treturn __camif_video_try_format(vp, &f->fmt.pix, NULL);\n}\n\nstatic int s3c_camif_vidioc_s_fmt(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct camif_vp *vp = video_drvdata(file);\n\tstruct camif_frame *out_frame = &vp->out_frame;\n\tconst struct camif_fmt *fmt = NULL;\n\tint ret;\n\n\tpr_debug(\"[vp%d]\\n\", vp->id);\n\n\tif (vb2_is_busy(&vp->vb_queue))\n\t\treturn -EBUSY;\n\n\tret = __camif_video_try_format(vp, &f->fmt.pix, &fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvp->out_fmt = fmt;\n\tvp->payload = pix->sizeimage;\n\tout_frame->f_width = pix->width;\n\tout_frame->f_height = pix->height;\n\n\t \n\tout_frame->rect.width = pix->width;\n\tout_frame->rect.height = pix->height;\n\tout_frame->rect.left = 0;\n\tout_frame->rect.top = 0;\n\n\tif (vp->owner == NULL)\n\t\tvp->owner = priv;\n\n\tpr_debug(\"%ux%u. payload: %u. fmt: 0x%08x. %d %d. sizeimage: %d. bpl: %d\\n\",\n\t\t out_frame->f_width, out_frame->f_height, vp->payload,\n\t\t fmt->fourcc, pix->width * pix->height * fmt->depth,\n\t\t fmt->depth, pix->sizeimage, pix->bytesperline);\n\n\treturn 0;\n}\n\n \nstatic int camif_pipeline_validate(struct camif_dev *camif)\n{\n\tstruct v4l2_subdev_format src_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct media_pad *pad;\n\tint ret;\n\n\t \n\tpad = media_pad_remote_pad_first(&camif->pads[0]);\n\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\treturn -EPIPE;\n\n\tsrc_fmt.pad = pad->index;\n\tret = v4l2_subdev_call(camif->sensor.sd, pad, get_fmt, NULL, &src_fmt);\n\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\treturn -EPIPE;\n\n\tif (src_fmt.format.width != camif->mbus_fmt.width ||\n\t    src_fmt.format.height != camif->mbus_fmt.height ||\n\t    src_fmt.format.code != camif->mbus_fmt.code)\n\t\treturn -EPIPE;\n\n\treturn 0;\n}\n\nstatic int s3c_camif_streamon(struct file *file, void *priv,\n\t\t\t      enum v4l2_buf_type type)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\tstruct camif_dev *camif = vp->camif;\n\tstruct media_entity *sensor = &camif->sensor.sd->entity;\n\tint ret;\n\n\tpr_debug(\"[vp%d]\\n\", vp->id);\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (vp->owner && vp->owner != priv)\n\t\treturn -EBUSY;\n\n\tif (s3c_vp_active(vp))\n\t\treturn 0;\n\n\tret = media_pipeline_start(sensor->pads, camif->m_pipeline);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = camif_pipeline_validate(camif);\n\tif (ret < 0) {\n\t\tmedia_pipeline_stop(sensor->pads);\n\t\treturn ret;\n\t}\n\n\treturn vb2_streamon(&vp->vb_queue, type);\n}\n\nstatic int s3c_camif_streamoff(struct file *file, void *priv,\n\t\t\t       enum v4l2_buf_type type)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\tstruct camif_dev *camif = vp->camif;\n\tint ret;\n\n\tpr_debug(\"[vp%d]\\n\", vp->id);\n\n\tif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (vp->owner && vp->owner != priv)\n\t\treturn -EBUSY;\n\n\tret = vb2_streamoff(&vp->vb_queue, type);\n\tif (ret == 0)\n\t\tmedia_pipeline_stop(camif->sensor.sd->entity.pads);\n\treturn ret;\n}\n\nstatic int s3c_camif_reqbufs(struct file *file, void *priv,\n\t\t\t     struct v4l2_requestbuffers *rb)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\tint ret;\n\n\tpr_debug(\"[vp%d] rb count: %d, owner: %p, priv: %p\\n\",\n\t\t vp->id, rb->count, vp->owner, priv);\n\n\tif (vp->owner && vp->owner != priv)\n\t\treturn -EBUSY;\n\n\tif (rb->count)\n\t\trb->count = max_t(u32, CAMIF_REQ_BUFS_MIN, rb->count);\n\telse\n\t\tvp->owner = NULL;\n\n\tret = vb2_reqbufs(&vp->vb_queue, rb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (rb->count && rb->count < CAMIF_REQ_BUFS_MIN) {\n\t\trb->count = 0;\n\t\tvb2_reqbufs(&vp->vb_queue, rb);\n\t\tret = -ENOMEM;\n\t}\n\n\tvp->reqbufs_count = rb->count;\n\tif (vp->owner == NULL && rb->count > 0)\n\t\tvp->owner = priv;\n\n\treturn ret;\n}\n\nstatic int s3c_camif_querybuf(struct file *file, void *priv,\n\t\t\t      struct v4l2_buffer *buf)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\treturn vb2_querybuf(&vp->vb_queue, buf);\n}\n\nstatic int s3c_camif_qbuf(struct file *file, void *priv,\n\t\t\t  struct v4l2_buffer *buf)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\n\tpr_debug(\"[vp%d]\\n\", vp->id);\n\n\tif (vp->owner && vp->owner != priv)\n\t\treturn -EBUSY;\n\n\treturn vb2_qbuf(&vp->vb_queue, vp->vdev.v4l2_dev->mdev, buf);\n}\n\nstatic int s3c_camif_dqbuf(struct file *file, void *priv,\n\t\t\t   struct v4l2_buffer *buf)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\n\tpr_debug(\"[vp%d] sequence: %d\\n\", vp->id, vp->frame_sequence);\n\n\tif (vp->owner && vp->owner != priv)\n\t\treturn -EBUSY;\n\n\treturn vb2_dqbuf(&vp->vb_queue, buf, file->f_flags & O_NONBLOCK);\n}\n\nstatic int s3c_camif_create_bufs(struct file *file, void *priv,\n\t\t\t\t struct v4l2_create_buffers *create)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\tint ret;\n\n\tif (vp->owner && vp->owner != priv)\n\t\treturn -EBUSY;\n\n\tcreate->count = max_t(u32, 1, create->count);\n\tret = vb2_create_bufs(&vp->vb_queue, create);\n\n\tif (!ret && vp->owner == NULL)\n\t\tvp->owner = priv;\n\n\treturn ret;\n}\n\nstatic int s3c_camif_prepare_buf(struct file *file, void *priv,\n\t\t\t\t struct v4l2_buffer *b)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\treturn vb2_prepare_buf(&vp->vb_queue, vp->vdev.v4l2_dev->mdev, b);\n}\n\nstatic int s3c_camif_g_selection(struct file *file, void *priv,\n\t\t\t\t struct v4l2_selection *sel)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = vp->out_frame.f_width;\n\t\tsel->r.height = vp->out_frame.f_height;\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tsel->r = vp->out_frame.rect;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void __camif_try_compose(struct camif_dev *camif, struct camif_vp *vp,\n\t\t\t\tstruct v4l2_rect *r)\n{\n\t \n\tif (camif->variant->ip_revision == S3C244X_CAMIF_IP_REV) {\n\t\t*r = vp->out_frame.rect;\n\t\treturn;\n\t}\n\n\t \n}\n\nstatic int s3c_camif_s_selection(struct file *file, void *priv,\n\t\t\t\t struct v4l2_selection *sel)\n{\n\tstruct camif_vp *vp = video_drvdata(file);\n\tstruct camif_dev *camif = vp->camif;\n\tstruct v4l2_rect rect = sel->r;\n\tunsigned long flags;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\n\t    sel->target != V4L2_SEL_TGT_COMPOSE)\n\t\treturn -EINVAL;\n\n\t__camif_try_compose(camif, vp, &rect);\n\n\tsel->r = rect;\n\tspin_lock_irqsave(&camif->slock, flags);\n\tvp->out_frame.rect = rect;\n\tvp->state |= ST_VP_CONFIG;\n\tspin_unlock_irqrestore(&camif->slock, flags);\n\n\tpr_debug(\"type: %#x, target: %#x, flags: %#x, (%d,%d)/%dx%d\\n\",\n\t\tsel->type, sel->target, sel->flags,\n\t\tsel->r.left, sel->r.top, sel->r.width, sel->r.height);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops s3c_camif_ioctl_ops = {\n\t.vidioc_querycap\t  = s3c_camif_vidioc_querycap,\n\t.vidioc_enum_input\t  = s3c_camif_vidioc_enum_input,\n\t.vidioc_g_input\t\t  = s3c_camif_vidioc_g_input,\n\t.vidioc_s_input\t\t  = s3c_camif_vidioc_s_input,\n\t.vidioc_enum_fmt_vid_cap  = s3c_camif_vidioc_enum_fmt,\n\t.vidioc_try_fmt_vid_cap\t  = s3c_camif_vidioc_try_fmt,\n\t.vidioc_s_fmt_vid_cap\t  = s3c_camif_vidioc_s_fmt,\n\t.vidioc_g_fmt_vid_cap\t  = s3c_camif_vidioc_g_fmt,\n\t.vidioc_g_selection\t  = s3c_camif_g_selection,\n\t.vidioc_s_selection\t  = s3c_camif_s_selection,\n\t.vidioc_reqbufs\t\t  = s3c_camif_reqbufs,\n\t.vidioc_querybuf\t  = s3c_camif_querybuf,\n\t.vidioc_prepare_buf\t  = s3c_camif_prepare_buf,\n\t.vidioc_create_bufs\t  = s3c_camif_create_bufs,\n\t.vidioc_qbuf\t\t  = s3c_camif_qbuf,\n\t.vidioc_dqbuf\t\t  = s3c_camif_dqbuf,\n\t.vidioc_streamon\t  = s3c_camif_streamon,\n\t.vidioc_streamoff\t  = s3c_camif_streamoff,\n\t.vidioc_subscribe_event\t  = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_log_status\t  = v4l2_ctrl_log_status,\n};\n\n \nstatic int s3c_camif_video_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct camif_vp *vp = ctrl->priv;\n\tstruct camif_dev *camif = vp->camif;\n\tunsigned long flags;\n\n\tpr_debug(\"[vp%d] ctrl: %s, value: %d\\n\", vp->id,\n\t\t ctrl->name, ctrl->val);\n\n\tspin_lock_irqsave(&camif->slock, flags);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tvp->hflip = ctrl->val;\n\t\tbreak;\n\n\tcase V4L2_CID_VFLIP:\n\t\tvp->vflip = ctrl->val;\n\t\tbreak;\n\t}\n\n\tvp->state |= ST_VP_CONFIG;\n\tspin_unlock_irqrestore(&camif->slock, flags);\n\treturn 0;\n}\n\n \nstatic const struct v4l2_ctrl_ops s3c_camif_video_ctrl_ops = {\n\t.s_ctrl = s3c_camif_video_s_ctrl,\n};\n\nint s3c_camif_register_video_node(struct camif_dev *camif, int idx)\n{\n\tstruct camif_vp *vp = &camif->vp[idx];\n\tstruct vb2_queue *q = &vp->vb_queue;\n\tstruct video_device *vfd = &vp->vdev;\n\tstruct v4l2_ctrl *ctrl;\n\tint ret;\n\n\tmemset(vfd, 0, sizeof(*vfd));\n\tsnprintf(vfd->name, sizeof(vfd->name), \"camif-%s\",\n\t\t vp->id == 0 ? \"codec\" : \"preview\");\n\n\tvfd->fops = &s3c_camif_fops;\n\tvfd->ioctl_ops = &s3c_camif_ioctl_ops;\n\tvfd->v4l2_dev = &camif->v4l2_dev;\n\tvfd->minor = -1;\n\tvfd->release = video_device_release_empty;\n\tvfd->lock = &camif->lock;\n\tvp->reqbufs_count = 0;\n\n\tINIT_LIST_HEAD(&vp->pending_buf_q);\n\tINIT_LIST_HEAD(&vp->active_buf_q);\n\n\tmemset(q, 0, sizeof(*q));\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR;\n\tq->ops = &s3c_camif_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->buf_struct_size = sizeof(struct camif_buffer);\n\tq->drv_priv = vp;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &vp->camif->lock;\n\tq->dev = camif->v4l2_dev.dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\treturn ret;\n\n\tvp->pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&vfd->entity, 1, &vp->pad);\n\tif (ret)\n\t\treturn ret;\n\n\tvideo_set_drvdata(vfd, vp);\n\n\tv4l2_ctrl_handler_init(&vp->ctrl_handler, 1);\n\tctrl = v4l2_ctrl_new_std(&vp->ctrl_handler, &s3c_camif_video_ctrl_ops,\n\t\t\t\t V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tif (ctrl)\n\t\tctrl->priv = vp;\n\tctrl = v4l2_ctrl_new_std(&vp->ctrl_handler, &s3c_camif_video_ctrl_ops,\n\t\t\t\t V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tif (ctrl)\n\t\tctrl->priv = vp;\n\n\tret = vp->ctrl_handler.error;\n\tif (ret < 0)\n\t\tgoto err_me_cleanup;\n\n\tvfd->ctrl_handler = &vp->ctrl_handler;\n\tvfd->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE;\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, -1);\n\tif (ret)\n\t\tgoto err_ctrlh_free;\n\n\tv4l2_info(&camif->v4l2_dev, \"registered %s as /dev/%s\\n\",\n\t\t  vfd->name, video_device_node_name(vfd));\n\treturn 0;\n\nerr_ctrlh_free:\n\tv4l2_ctrl_handler_free(&vp->ctrl_handler);\nerr_me_cleanup:\n\tmedia_entity_cleanup(&vfd->entity);\n\treturn ret;\n}\n\nvoid s3c_camif_unregister_video_node(struct camif_dev *camif, int idx)\n{\n\tstruct video_device *vfd = &camif->vp[idx].vdev;\n\n\tif (video_is_registered(vfd)) {\n\t\tvideo_unregister_device(vfd);\n\t\tmedia_entity_cleanup(&vfd->entity);\n\t\tv4l2_ctrl_handler_free(vfd->ctrl_handler);\n\t}\n}\n\n \nstatic const u32 camif_mbus_formats[] = {\n\tMEDIA_BUS_FMT_YUYV8_2X8,\n\tMEDIA_BUS_FMT_YVYU8_2X8,\n\tMEDIA_BUS_FMT_UYVY8_2X8,\n\tMEDIA_BUS_FMT_VYUY8_2X8,\n};\n\n \n\nstatic int s3c_camif_subdev_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= ARRAY_SIZE(camif_mbus_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = camif_mbus_formats[code->index];\n\treturn 0;\n}\n\nstatic int s3c_camif_subdev_get_fmt(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct camif_dev *camif = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *mf = &fmt->format;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);\n\t\tfmt->format = *mf;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&camif->lock);\n\n\tswitch (fmt->pad) {\n\tcase CAMIF_SD_PAD_SINK:\n\t\t \n\t\t*mf = camif->mbus_fmt;\n\t\tbreak;\n\n\tcase CAMIF_SD_PAD_SOURCE_C...CAMIF_SD_PAD_SOURCE_P:\n\t\t \n\t\tmf->width = camif->camif_crop.width;\n\t\tmf->height = camif->camif_crop.height;\n\t\tmf->code = camif->mbus_fmt.code;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&camif->lock);\n\tmf->field = V4L2_FIELD_NONE;\n\tmf->colorspace = V4L2_COLORSPACE_JPEG;\n\treturn 0;\n}\n\nstatic void __camif_subdev_try_format(struct camif_dev *camif,\n\t\t\t\tstruct v4l2_mbus_framefmt *mf, int pad)\n{\n\tconst struct s3c_camif_variant *variant = camif->variant;\n\tconst struct vp_pix_limits *pix_lim;\n\tunsigned int i;\n\n\t \n\tpix_lim = &variant->vp_pix_limits[VP_CODEC];\n\n\tfor (i = 0; i < ARRAY_SIZE(camif_mbus_formats); i++)\n\t\tif (camif_mbus_formats[i] == mf->code)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(camif_mbus_formats))\n\t\tmf->code = camif_mbus_formats[0];\n\n\tif (pad == CAMIF_SD_PAD_SINK) {\n\t\tv4l_bound_align_image(&mf->width, 8, CAMIF_MAX_PIX_WIDTH,\n\t\t\t\t      ffs(pix_lim->out_width_align) - 1,\n\t\t\t\t      &mf->height, 8, CAMIF_MAX_PIX_HEIGHT, 0,\n\t\t\t\t      0);\n\t} else {\n\t\tstruct v4l2_rect *crop = &camif->camif_crop;\n\t\tv4l_bound_align_image(&mf->width, 8, crop->width,\n\t\t\t\t      ffs(pix_lim->out_width_align) - 1,\n\t\t\t\t      &mf->height, 8, crop->height,\n\t\t\t\t      0, 0);\n\t}\n\n\tv4l2_dbg(1, debug, &camif->subdev, \"%ux%u\\n\", mf->width, mf->height);\n}\n\nstatic int s3c_camif_subdev_set_fmt(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct camif_dev *camif = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *mf = &fmt->format;\n\tstruct v4l2_rect *crop = &camif->camif_crop;\n\tint i;\n\n\tv4l2_dbg(1, debug, sd, \"pad%d: code: 0x%x, %ux%u\\n\",\n\t\t fmt->pad, mf->code, mf->width, mf->height);\n\n\tmf->field = V4L2_FIELD_NONE;\n\tmf->colorspace = V4L2_COLORSPACE_JPEG;\n\tmutex_lock(&camif->lock);\n\n\t \n\tif (vb2_is_busy(&camif->vp[VP_CODEC].vb_queue) ||\n\t    vb2_is_busy(&camif->vp[VP_PREVIEW].vb_queue)) {\n\t\tmutex_unlock(&camif->lock);\n\t\treturn -EBUSY;\n\t}\n\n\t__camif_subdev_try_format(camif, mf, fmt->pad);\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);\n\t\t*mf = fmt->format;\n\t\tmutex_unlock(&camif->lock);\n\t\treturn 0;\n\t}\n\n\tswitch (fmt->pad) {\n\tcase CAMIF_SD_PAD_SINK:\n\t\tcamif->mbus_fmt = *mf;\n\t\t \n\t\tcrop->width = mf->width;\n\t\tcrop->height = mf->height;\n\t\tcrop->left = 0;\n\t\tcrop->top = 0;\n\t\t \n\t\tfor (i = 0; i < CAMIF_VP_NUM; i++) {\n\t\t\tstruct camif_frame *frame = &camif->vp[i].out_frame;\n\t\t\tframe->rect = *crop;\n\t\t\tframe->f_width = mf->width;\n\t\t\tframe->f_height = mf->height;\n\t\t}\n\t\tbreak;\n\n\tcase CAMIF_SD_PAD_SOURCE_C...CAMIF_SD_PAD_SOURCE_P:\n\t\t \n\t\tmf->code = camif->mbus_fmt.code;\n\t\tmf->width = crop->width;\n\t\tmf->height = crop->height;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&camif->lock);\n\treturn 0;\n}\n\nstatic int s3c_camif_subdev_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t\t  struct v4l2_subdev_selection *sel)\n{\n\tstruct camif_dev *camif = v4l2_get_subdevdata(sd);\n\tstruct v4l2_rect *crop = &camif->camif_crop;\n\tstruct v4l2_mbus_framefmt *mf = &camif->mbus_fmt;\n\n\tif ((sel->target != V4L2_SEL_TGT_CROP &&\n\t    sel->target != V4L2_SEL_TGT_CROP_BOUNDS) ||\n\t    sel->pad != CAMIF_SD_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsel->r = *v4l2_subdev_get_try_crop(sd, sd_state, sel->pad);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&camif->lock);\n\n\tif (sel->target == V4L2_SEL_TGT_CROP) {\n\t\tsel->r = *crop;\n\t} else {  \n\t\tsel->r.width = mf->width;\n\t\tsel->r.height = mf->height;\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t}\n\n\tmutex_unlock(&camif->lock);\n\n\tv4l2_dbg(1, debug, sd, \"%s: crop: (%d,%d) %dx%d, size: %ux%u\\n\",\n\t\t __func__, crop->left, crop->top, crop->width,\n\t\t crop->height, mf->width, mf->height);\n\n\treturn 0;\n}\n\nstatic void __camif_try_crop(struct camif_dev *camif, struct v4l2_rect *r)\n{\n\tstruct v4l2_mbus_framefmt *mf = &camif->mbus_fmt;\n\tconst struct camif_pix_limits *pix_lim = &camif->variant->pix_limits;\n\tunsigned int left = 2 * r->left;\n\tunsigned int top = 2 * r->top;\n\n\t \n\tv4l_bound_align_image(&r->width, 0, mf->width,\n\t\t\t      ffs(pix_lim->win_hor_offset_align) - 1,\n\t\t\t      &r->height, 0, mf->height, 1, 0);\n\n\tv4l_bound_align_image(&left, 0, mf->width - r->width,\n\t\t\t      ffs(pix_lim->win_hor_offset_align),\n\t\t\t      &top, 0, mf->height - r->height, 2, 0);\n\n\tr->left = left / 2;\n\tr->top = top / 2;\n\tr->width = mf->width - left;\n\tr->height = mf->height - top;\n\t \n\tif (camif->variant->ip_revision == S3C244X_CAMIF_IP_REV &&\n\t    camif_is_streaming(camif)) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < CAMIF_VP_NUM; i++) {\n\t\t\tstruct v4l2_rect *or = &camif->vp[i].out_frame.rect;\n\t\t\tif ((or->width > r->width) == (or->height > r->height))\n\t\t\t\tcontinue;\n\t\t\t*r = camif->camif_crop;\n\t\t\tpr_debug(\"Width/height scaling direction limitation\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tv4l2_dbg(1, debug, &camif->v4l2_dev, \"crop: (%d,%d)/%dx%d, fmt: %ux%u\\n\",\n\t\t r->left, r->top, r->width, r->height, mf->width, mf->height);\n}\n\nstatic int s3c_camif_subdev_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t\t  struct v4l2_subdev_selection *sel)\n{\n\tstruct camif_dev *camif = v4l2_get_subdevdata(sd);\n\tstruct v4l2_rect *crop = &camif->camif_crop;\n\tstruct camif_scaler scaler;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP || sel->pad != CAMIF_SD_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&camif->lock);\n\t__camif_try_crop(camif, &sel->r);\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t*v4l2_subdev_get_try_crop(sd, sd_state, sel->pad) = sel->r;\n\t} else {\n\t\tunsigned long flags;\n\t\tunsigned int i;\n\n\t\tspin_lock_irqsave(&camif->slock, flags);\n\t\t*crop = sel->r;\n\n\t\tfor (i = 0; i < CAMIF_VP_NUM; i++) {\n\t\t\tstruct camif_vp *vp = &camif->vp[i];\n\t\t\tscaler = vp->scaler;\n\t\t\tif (s3c_camif_get_scaler_config(vp, &scaler))\n\t\t\t\tcontinue;\n\t\t\tvp->scaler = scaler;\n\t\t\tvp->state |= ST_VP_CONFIG;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&camif->slock, flags);\n\t}\n\tmutex_unlock(&camif->lock);\n\n\tv4l2_dbg(1, debug, sd, \"%s: (%d,%d) %dx%d, f_w: %u, f_h: %u\\n\",\n\t\t __func__, crop->left, crop->top, crop->width, crop->height,\n\t\t camif->mbus_fmt.width, camif->mbus_fmt.height);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops s3c_camif_subdev_pad_ops = {\n\t.enum_mbus_code = s3c_camif_subdev_enum_mbus_code,\n\t.get_selection = s3c_camif_subdev_get_selection,\n\t.set_selection = s3c_camif_subdev_set_selection,\n\t.get_fmt = s3c_camif_subdev_get_fmt,\n\t.set_fmt = s3c_camif_subdev_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops s3c_camif_subdev_ops = {\n\t.pad = &s3c_camif_subdev_pad_ops,\n};\n\nstatic int s3c_camif_subdev_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct camif_dev *camif = container_of(ctrl->handler, struct camif_dev,\n\t\t\t\t\t       ctrl_handler);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&camif->slock, flags);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_COLORFX:\n\t\tcamif->colorfx = camif->ctrl_colorfx->val;\n\t\t \n\t\tswitch (ctrl->val) {\n\t\tcase V4L2_COLORFX_SEPIA:\n\t\t\tcamif->colorfx_cb = 115;\n\t\t\tcamif->colorfx_cr = 145;\n\t\t\tbreak;\n\t\tcase V4L2_COLORFX_SET_CBCR:\n\t\t\tcamif->colorfx_cb = camif->ctrl_colorfx_cbcr->val >> 8;\n\t\t\tcamif->colorfx_cr = camif->ctrl_colorfx_cbcr->val & 0xff;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tcamif->colorfx_cb = 128;\n\t\t\tcamif->colorfx_cr = 128;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tcamif->test_pattern = camif->ctrl_test_pattern->val;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tcamif->vp[VP_CODEC].state |= ST_VP_CONFIG;\n\tcamif->vp[VP_PREVIEW].state |= ST_VP_CONFIG;\n\tspin_unlock_irqrestore(&camif->slock, flags);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops s3c_camif_subdev_ctrl_ops = {\n\t.s_ctrl\t= s3c_camif_subdev_s_ctrl,\n};\n\nstatic const char * const s3c_camif_test_pattern_menu[] = {\n\t\"Disabled\",\n\t\"Color bars\",\n\t\"Horizontal increment\",\n\t\"Vertical increment\",\n};\n\nint s3c_camif_create_subdev(struct camif_dev *camif)\n{\n\tstruct v4l2_ctrl_handler *handler = &camif->ctrl_handler;\n\tstruct v4l2_subdev *sd = &camif->subdev;\n\tint ret;\n\n\tv4l2_subdev_init(sd, &s3c_camif_subdev_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tstrscpy(sd->name, \"S3C-CAMIF\", sizeof(sd->name));\n\n\tcamif->pads[CAMIF_SD_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tcamif->pads[CAMIF_SD_PAD_SOURCE_C].flags = MEDIA_PAD_FL_SOURCE;\n\tcamif->pads[CAMIF_SD_PAD_SOURCE_P].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&sd->entity, CAMIF_SD_PADS_NUM,\n\t\t\t\tcamif->pads);\n\tif (ret)\n\t\treturn ret;\n\n\tv4l2_ctrl_handler_init(handler, 3);\n\tcamif->ctrl_test_pattern = v4l2_ctrl_new_std_menu_items(handler,\n\t\t\t&s3c_camif_subdev_ctrl_ops, V4L2_CID_TEST_PATTERN,\n\t\t\tARRAY_SIZE(s3c_camif_test_pattern_menu) - 1, 0, 0,\n\t\t\ts3c_camif_test_pattern_menu);\n\n\tif (camif->variant->has_img_effect) {\n\t\tcamif->ctrl_colorfx = v4l2_ctrl_new_std_menu(handler,\n\t\t\t\t&s3c_camif_subdev_ctrl_ops,\n\t\t\t\tV4L2_CID_COLORFX, V4L2_COLORFX_SET_CBCR,\n\t\t\t\t~0x981f, V4L2_COLORFX_NONE);\n\n\t\tcamif->ctrl_colorfx_cbcr = v4l2_ctrl_new_std(handler,\n\t\t\t\t&s3c_camif_subdev_ctrl_ops,\n\t\t\t\tV4L2_CID_COLORFX_CBCR, 0, 0xffff, 1, 0);\n\t}\n\n\tif (handler->error) {\n\t\tv4l2_ctrl_handler_free(handler);\n\t\tmedia_entity_cleanup(&sd->entity);\n\t\treturn handler->error;\n\t}\n\n\tif (camif->variant->has_img_effect)\n\t\tv4l2_ctrl_auto_cluster(2, &camif->ctrl_colorfx,\n\t\t\t       V4L2_COLORFX_SET_CBCR, false);\n\n\tsd->ctrl_handler = handler;\n\tv4l2_set_subdevdata(sd, camif);\n\n\treturn 0;\n}\n\nvoid s3c_camif_unregister_subdev(struct camif_dev *camif)\n{\n\tstruct v4l2_subdev *sd = &camif->subdev;\n\n\t \n\tif (v4l2_get_subdevdata(sd) == NULL)\n\t\treturn;\n\n\tv4l2_device_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\tv4l2_ctrl_handler_free(&camif->ctrl_handler);\n\tv4l2_set_subdevdata(sd, NULL);\n}\n\nint s3c_camif_set_defaults(struct camif_dev *camif)\n{\n\tunsigned int ip_rev = camif->variant->ip_revision;\n\tint i;\n\n\tfor (i = 0; i < CAMIF_VP_NUM; i++) {\n\t\tstruct camif_vp *vp = &camif->vp[i];\n\t\tstruct camif_frame *f = &vp->out_frame;\n\n\t\tvp->camif = camif;\n\t\tvp->id = i;\n\t\tvp->offset = camif->variant->vp_offset;\n\n\t\tif (ip_rev == S3C244X_CAMIF_IP_REV)\n\t\t\tvp->fmt_flags = i ? FMT_FL_S3C24XX_PREVIEW :\n\t\t\t\t\tFMT_FL_S3C24XX_CODEC;\n\t\telse\n\t\t\tvp->fmt_flags = FMT_FL_S3C64XX;\n\n\t\tvp->out_fmt = s3c_camif_find_format(vp, NULL, 0);\n\t\tBUG_ON(vp->out_fmt == NULL);\n\n\t\tmemset(f, 0, sizeof(*f));\n\t\tf->f_width = CAMIF_DEF_WIDTH;\n\t\tf->f_height = CAMIF_DEF_HEIGHT;\n\t\tf->rect.width = CAMIF_DEF_WIDTH;\n\t\tf->rect.height = CAMIF_DEF_HEIGHT;\n\n\t\t \n\t\tvp->scaler.enable = 1;\n\n\t\tvp->payload = (f->f_width * f->f_height *\n\t\t\t       vp->out_fmt->depth) / 8;\n\t}\n\n\tmemset(&camif->mbus_fmt, 0, sizeof(camif->mbus_fmt));\n\tcamif->mbus_fmt.width = CAMIF_DEF_WIDTH;\n\tcamif->mbus_fmt.height = CAMIF_DEF_HEIGHT;\n\tcamif->mbus_fmt.code  = camif_mbus_formats[0];\n\n\tmemset(&camif->camif_crop, 0, sizeof(camif->camif_crop));\n\tcamif->camif_crop.width = CAMIF_DEF_WIDTH;\n\tcamif->camif_crop.height = CAMIF_DEF_HEIGHT;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}