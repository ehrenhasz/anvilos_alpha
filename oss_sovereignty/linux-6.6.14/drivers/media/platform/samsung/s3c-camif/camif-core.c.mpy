{
  "module_name": "camif-core.c",
  "hash_id": "17456c5e2627605017bec7accd638f93b2c7c2a700728a095b82bce629c0ea8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s3c-camif/camif-core.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"%s:%d \" fmt, __func__, __LINE__\n\n#include <linux/bug.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/gpio.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <media/media-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"camif-core.h\"\n\nstatic char *camif_clocks[CLK_MAX_NUM] = {\n\t \n\t[CLK_GATE]\t= \"camif\",\n\t \n\t[CLK_CAM]\t= \"camera\",\n};\n\nstatic const struct camif_fmt camif_formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV422P,\n\t\t.depth\t\t= 16,\n\t\t.ybpp\t\t= 1,\n\t\t.color\t\t= IMG_FMT_YCBCR422P,\n\t\t.colplanes\t= 3,\n\t\t.flags\t\t= FMT_FL_S3C24XX_CODEC |\n\t\t\t\t  FMT_FL_S3C64XX,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV420,\n\t\t.depth\t\t= 12,\n\t\t.ybpp\t\t= 1,\n\t\t.color\t\t= IMG_FMT_YCBCR420,\n\t\t.colplanes\t= 3,\n\t\t.flags\t\t= FMT_FL_S3C24XX_CODEC |\n\t\t\t\t  FMT_FL_S3C64XX,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YVU420,\n\t\t.depth\t\t= 12,\n\t\t.ybpp\t\t= 1,\n\t\t.color\t\t= IMG_FMT_YCRCB420,\n\t\t.colplanes\t= 3,\n\t\t.flags\t\t= FMT_FL_S3C24XX_CODEC |\n\t\t\t\t  FMT_FL_S3C64XX,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565X,\n\t\t.depth\t\t= 16,\n\t\t.ybpp\t\t= 2,\n\t\t.color\t\t= IMG_FMT_RGB565,\n\t\t.colplanes\t= 1,\n\t\t.flags\t\t= FMT_FL_S3C24XX_PREVIEW |\n\t\t\t\t  FMT_FL_S3C64XX,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB32,\n\t\t.depth\t\t= 32,\n\t\t.ybpp\t\t= 4,\n\t\t.color\t\t= IMG_FMT_XRGB8888,\n\t\t.colplanes\t= 1,\n\t\t.flags\t\t= FMT_FL_S3C24XX_PREVIEW |\n\t\t\t\t  FMT_FL_S3C64XX,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_BGR666,\n\t\t.depth\t\t= 32,\n\t\t.ybpp\t\t= 4,\n\t\t.color\t\t= IMG_FMT_RGB666,\n\t\t.colplanes\t= 1,\n\t\t.flags\t\t= FMT_FL_S3C64XX,\n\t}\n};\n\n \nconst struct camif_fmt *s3c_camif_find_format(struct camif_vp *vp,\n\t\t\t\t\t      const u32 *pixelformat,\n\t\t\t\t\t      int index)\n{\n\tconst struct camif_fmt *fmt, *def_fmt = NULL;\n\tunsigned int i;\n\tint id = 0;\n\n\tif (index >= (int)ARRAY_SIZE(camif_formats))\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(camif_formats); ++i) {\n\t\tfmt = &camif_formats[i];\n\t\tif (vp && !(vp->fmt_flags & fmt->flags))\n\t\t\tcontinue;\n\t\tif (pixelformat && fmt->fourcc == *pixelformat)\n\t\t\treturn fmt;\n\t\tif (index == id)\n\t\t\tdef_fmt = fmt;\n\t\tid++;\n\t}\n\treturn def_fmt;\n}\n\nstatic int camif_get_scaler_factor(u32 src, u32 tar, u32 *ratio, u32 *shift)\n{\n\tunsigned int sh = 6;\n\n\tif (src >= 64 * tar)\n\t\treturn -EINVAL;\n\n\twhile (sh--) {\n\t\tunsigned int tmp = 1 << sh;\n\t\tif (src >= tar * tmp) {\n\t\t\t*shift = sh;\n\t\t\t*ratio = tmp;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*shift = 0;\n\t*ratio = 1;\n\treturn 0;\n}\n\nint s3c_camif_get_scaler_config(struct camif_vp *vp,\n\t\t\t\tstruct camif_scaler *scaler)\n{\n\tstruct v4l2_rect *camif_crop = &vp->camif->camif_crop;\n\tint source_x = camif_crop->width;\n\tint source_y = camif_crop->height;\n\tint target_x = vp->out_frame.rect.width;\n\tint target_y = vp->out_frame.rect.height;\n\tint ret;\n\n\tif (vp->rotation == 90 || vp->rotation == 270)\n\t\tswap(target_x, target_y);\n\n\tret = camif_get_scaler_factor(source_x, target_x, &scaler->pre_h_ratio,\n\t\t\t\t      &scaler->h_shift);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = camif_get_scaler_factor(source_y, target_y, &scaler->pre_v_ratio,\n\t\t\t\t      &scaler->v_shift);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tscaler->pre_dst_width = source_x / scaler->pre_h_ratio;\n\tscaler->pre_dst_height = source_y / scaler->pre_v_ratio;\n\n\tscaler->main_h_ratio = (source_x << 8) / (target_x << scaler->h_shift);\n\tscaler->main_v_ratio = (source_y << 8) / (target_y << scaler->v_shift);\n\n\tscaler->scaleup_h = (target_x >= source_x);\n\tscaler->scaleup_v = (target_y >= source_y);\n\n\tscaler->copy = 0;\n\n\tpr_debug(\"H: ratio: %u, shift: %u. V: ratio: %u, shift: %u.\\n\",\n\t\t scaler->pre_h_ratio, scaler->h_shift,\n\t\t scaler->pre_v_ratio, scaler->v_shift);\n\n\tpr_debug(\"Source: %dx%d, Target: %dx%d, scaleup_h/v: %d/%d\\n\",\n\t\t source_x, source_y, target_x, target_y,\n\t\t scaler->scaleup_h, scaler->scaleup_v);\n\n\treturn 0;\n}\n\nstatic int camif_register_sensor(struct camif_dev *camif)\n{\n\tstruct s3c_camif_sensor_info *sensor = &camif->pdata.sensor;\n\tstruct v4l2_device *v4l2_dev = &camif->v4l2_dev;\n\tstruct i2c_adapter *adapter;\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev *sd;\n\tint ret;\n\n\tcamif->sensor.sd = NULL;\n\n\tif (sensor->i2c_board_info.addr == 0)\n\t\treturn -EINVAL;\n\n\tadapter = i2c_get_adapter(sensor->i2c_bus_num);\n\tif (adapter == NULL) {\n\t\tv4l2_warn(v4l2_dev, \"failed to get I2C adapter %d\\n\",\n\t\t\t  sensor->i2c_bus_num);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tsd = v4l2_i2c_new_subdev_board(v4l2_dev, adapter,\n\t\t\t\t       &sensor->i2c_board_info, NULL);\n\tif (sd == NULL) {\n\t\ti2c_put_adapter(adapter);\n\t\tv4l2_warn(v4l2_dev, \"failed to acquire subdev %s\\n\",\n\t\t\t  sensor->i2c_board_info.type);\n\t\treturn -EPROBE_DEFER;\n\t}\n\tcamif->sensor.sd = sd;\n\n\tv4l2_info(v4l2_dev, \"registered sensor subdevice %s\\n\", sd->name);\n\n\t \n\tformat.pad = 0;\n\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &format);\n\n\tif (ret < 0)\n\t\treturn 0;\n\n\tformat.pad = CAMIF_SD_PAD_SINK;\n\tv4l2_subdev_call(&camif->subdev, pad, set_fmt, NULL, &format);\n\n\tv4l2_info(sd, \"Initial format from sensor: %dx%d, %#x\\n\",\n\t\t  format.format.width, format.format.height,\n\t\t  format.format.code);\n\treturn 0;\n}\n\nstatic void camif_unregister_sensor(struct camif_dev *camif)\n{\n\tstruct v4l2_subdev *sd = camif->sensor.sd;\n\tstruct i2c_client *client = sd ? v4l2_get_subdevdata(sd) : NULL;\n\tstruct i2c_adapter *adapter;\n\n\tif (client == NULL)\n\t\treturn;\n\n\tadapter = client->adapter;\n\tv4l2_device_unregister_subdev(sd);\n\tcamif->sensor.sd = NULL;\n\ti2c_unregister_device(client);\n\ti2c_put_adapter(adapter);\n}\n\nstatic int camif_create_media_links(struct camif_dev *camif)\n{\n\tint i, ret;\n\n\tret = media_create_pad_link(&camif->sensor.sd->entity, 0,\n\t\t\t\t&camif->subdev.entity, CAMIF_SD_PAD_SINK,\n\t\t\t\tMEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\tMEDIA_LNK_FL_ENABLED);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 1; i < CAMIF_SD_PADS_NUM && !ret; i++) {\n\t\tret = media_create_pad_link(&camif->subdev.entity, i,\n\t\t\t\t&camif->vp[i - 1].vdev.entity, 0,\n\t\t\t\tMEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\tMEDIA_LNK_FL_ENABLED);\n\t}\n\n\treturn ret;\n}\n\nstatic int camif_register_video_nodes(struct camif_dev *camif)\n{\n\tint ret = s3c_camif_register_video_node(camif, VP_CODEC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn s3c_camif_register_video_node(camif, VP_PREVIEW);\n}\n\nstatic void camif_unregister_video_nodes(struct camif_dev *camif)\n{\n\ts3c_camif_unregister_video_node(camif, VP_CODEC);\n\ts3c_camif_unregister_video_node(camif, VP_PREVIEW);\n}\n\nstatic void camif_unregister_media_entities(struct camif_dev *camif)\n{\n\tcamif_unregister_video_nodes(camif);\n\tcamif_unregister_sensor(camif);\n}\n\n \nstatic int camif_media_dev_init(struct camif_dev *camif)\n{\n\tstruct media_device *md = &camif->media_dev;\n\tstruct v4l2_device *v4l2_dev = &camif->v4l2_dev;\n\tunsigned int ip_rev = camif->variant->ip_revision;\n\tint ret;\n\n\tmemset(md, 0, sizeof(*md));\n\tsnprintf(md->model, sizeof(md->model), \"Samsung S3C%s CAMIF\",\n\t\t ip_rev == S3C6410_CAMIF_IP_REV ? \"6410\" : \"244X\");\n\tstrscpy(md->bus_info, \"platform\", sizeof(md->bus_info));\n\tmd->hw_revision = ip_rev;\n\n\tmd->dev = camif->dev;\n\n\tstrscpy(v4l2_dev->name, \"s3c-camif\", sizeof(v4l2_dev->name));\n\tv4l2_dev->mdev = md;\n\n\tmedia_device_init(md);\n\n\tret = v4l2_device_register(camif->dev, v4l2_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic void camif_clk_put(struct camif_dev *camif)\n{\n\tint i;\n\n\tfor (i = 0; i < CLK_MAX_NUM; i++) {\n\t\tif (IS_ERR(camif->clock[i]))\n\t\t\tcontinue;\n\t\tclk_unprepare(camif->clock[i]);\n\t\tclk_put(camif->clock[i]);\n\t\tcamif->clock[i] = ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic int camif_clk_get(struct camif_dev *camif)\n{\n\tint ret, i;\n\n\tfor (i = 1; i < CLK_MAX_NUM; i++)\n\t\tcamif->clock[i] = ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < CLK_MAX_NUM; i++) {\n\t\tcamif->clock[i] = clk_get(camif->dev, camif_clocks[i]);\n\t\tif (IS_ERR(camif->clock[i])) {\n\t\t\tret = PTR_ERR(camif->clock[i]);\n\t\t\tgoto err;\n\t\t}\n\t\tret = clk_prepare(camif->clock[i]);\n\t\tif (ret < 0) {\n\t\t\tclk_put(camif->clock[i]);\n\t\t\tcamif->clock[i] = NULL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 0;\nerr:\n\tcamif_clk_put(camif);\n\tdev_err(camif->dev, \"failed to get clock: %s\\n\",\n\t\tcamif_clocks[i]);\n\treturn ret;\n}\n\n \nstatic int camif_request_irqs(struct platform_device *pdev,\n\t\t\t      struct camif_dev *camif)\n{\n\tint irq, ret, i;\n\n\tfor (i = 0; i < CAMIF_VP_NUM; i++) {\n\t\tstruct camif_vp *vp = &camif->vp[i];\n\n\t\tinit_waitqueue_head(&vp->irq_queue);\n\n\t\tirq = platform_get_irq(pdev, i);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_irq(&pdev->dev, irq, s3c_camif_irq_handler,\n\t\t\t\t       0, dev_name(&pdev->dev), vp);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to install IRQ: %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int s3c_camif_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct s3c_camif_plat_data *pdata = dev->platform_data;\n\tstruct s3c_camif_drvdata *drvdata;\n\tstruct camif_dev *camif;\n\tint ret = 0;\n\n\tcamif = devm_kzalloc(dev, sizeof(*camif), GFP_KERNEL);\n\tif (!camif)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&camif->slock);\n\tmutex_init(&camif->lock);\n\n\tcamif->dev = dev;\n\n\tif (!pdata || !pdata->gpio_get || !pdata->gpio_put) {\n\t\tdev_err(dev, \"wrong platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcamif->pdata = *pdata;\n\tdrvdata = (void *)platform_get_device_id(pdev)->driver_data;\n\tcamif->variant = drvdata->variant;\n\n\tcamif->io_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(camif->io_base))\n\t\treturn PTR_ERR(camif->io_base);\n\n\tret = camif_request_irqs(pdev, camif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pdata->gpio_get();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s3c_camif_create_subdev(camif);\n\tif (ret < 0)\n\t\tgoto err_sd;\n\n\tret = camif_clk_get(camif);\n\tif (ret < 0)\n\t\tgoto err_clk;\n\n\tplatform_set_drvdata(pdev, camif);\n\tclk_set_rate(camif->clock[CLK_CAM],\n\t\t\tcamif->pdata.sensor.clock_frequency);\n\n\tdev_info(dev, \"sensor clock frequency: %lu\\n\",\n\t\t clk_get_rate(camif->clock[CLK_CAM]));\n\t \n\ts3c_camif_set_defaults(camif);\n\n\tpm_runtime_enable(dev);\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\tgoto err_disable;\n\n\tret = camif_media_dev_init(camif);\n\tif (ret < 0)\n\t\tgoto err_pm;\n\n\tret = camif_register_sensor(camif);\n\tif (ret < 0)\n\t\tgoto err_sens;\n\n\tret = v4l2_device_register_subdev(&camif->v4l2_dev, &camif->subdev);\n\tif (ret < 0)\n\t\tgoto err_sens;\n\n\tret = v4l2_device_register_subdev_nodes(&camif->v4l2_dev);\n\tif (ret < 0)\n\t\tgoto err_sens;\n\n\tret = camif_register_video_nodes(camif);\n\tif (ret < 0)\n\t\tgoto err_sens;\n\n\tret = camif_create_media_links(camif);\n\tif (ret < 0)\n\t\tgoto err_sens;\n\n\tret = media_device_register(&camif->media_dev);\n\tif (ret < 0)\n\t\tgoto err_sens;\n\n\tpm_runtime_put(dev);\n\treturn 0;\n\nerr_sens:\n\tv4l2_device_unregister(&camif->v4l2_dev);\n\tmedia_device_unregister(&camif->media_dev);\n\tmedia_device_cleanup(&camif->media_dev);\n\tcamif_unregister_media_entities(camif);\nerr_pm:\n\tpm_runtime_put(dev);\nerr_disable:\n\tpm_runtime_disable(dev);\n\tcamif_clk_put(camif);\nerr_clk:\n\ts3c_camif_unregister_subdev(camif);\nerr_sd:\n\tpdata->gpio_put();\n\treturn ret;\n}\n\nstatic void s3c_camif_remove(struct platform_device *pdev)\n{\n\tstruct camif_dev *camif = platform_get_drvdata(pdev);\n\tstruct s3c_camif_plat_data *pdata = &camif->pdata;\n\n\tmedia_device_unregister(&camif->media_dev);\n\tmedia_device_cleanup(&camif->media_dev);\n\tcamif_unregister_media_entities(camif);\n\tv4l2_device_unregister(&camif->v4l2_dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tcamif_clk_put(camif);\n\ts3c_camif_unregister_subdev(camif);\n\tpdata->gpio_put();\n}\n\nstatic int s3c_camif_runtime_resume(struct device *dev)\n{\n\tstruct camif_dev *camif = dev_get_drvdata(dev);\n\n\tclk_enable(camif->clock[CLK_GATE]);\n\t \n\tclk_enable(camif->clock[CLK_CAM]);\n\treturn 0;\n}\n\nstatic int s3c_camif_runtime_suspend(struct device *dev)\n{\n\tstruct camif_dev *camif = dev_get_drvdata(dev);\n\n\t \n\tclk_disable(camif->clock[CLK_CAM]);\n\n\tclk_disable(camif->clock[CLK_GATE]);\n\treturn 0;\n}\n\nstatic const struct s3c_camif_variant s3c244x_camif_variant = {\n\t.vp_pix_limits = {\n\t\t[VP_CODEC] = {\n\t\t\t.max_out_width\t\t= 4096,\n\t\t\t.max_sc_out_width\t= 2048,\n\t\t\t.out_width_align\t= 16,\n\t\t\t.min_out_width\t\t= 16,\n\t\t\t.max_height\t\t= 4096,\n\t\t},\n\t\t[VP_PREVIEW] = {\n\t\t\t.max_out_width\t\t= 640,\n\t\t\t.max_sc_out_width\t= 640,\n\t\t\t.out_width_align\t= 16,\n\t\t\t.min_out_width\t\t= 16,\n\t\t\t.max_height\t\t= 480,\n\t\t}\n\t},\n\t.pix_limits = {\n\t\t.win_hor_offset_align\t= 8,\n\t},\n\t.ip_revision = S3C244X_CAMIF_IP_REV,\n};\n\nstatic struct s3c_camif_drvdata s3c244x_camif_drvdata = {\n\t.variant\t= &s3c244x_camif_variant,\n\t.bus_clk_freq\t= 24000000UL,\n};\n\nstatic const struct s3c_camif_variant s3c6410_camif_variant = {\n\t.vp_pix_limits = {\n\t\t[VP_CODEC] = {\n\t\t\t.max_out_width\t\t= 4096,\n\t\t\t.max_sc_out_width\t= 2048,\n\t\t\t.out_width_align\t= 16,\n\t\t\t.min_out_width\t\t= 16,\n\t\t\t.max_height\t\t= 4096,\n\t\t},\n\t\t[VP_PREVIEW] = {\n\t\t\t.max_out_width\t\t= 4096,\n\t\t\t.max_sc_out_width\t= 720,\n\t\t\t.out_width_align\t= 16,\n\t\t\t.min_out_width\t\t= 16,\n\t\t\t.max_height\t\t= 4096,\n\t\t}\n\t},\n\t.pix_limits = {\n\t\t.win_hor_offset_align\t= 8,\n\t},\n\t.ip_revision = S3C6410_CAMIF_IP_REV,\n\t.has_img_effect = 1,\n\t.vp_offset = 0x20,\n};\n\nstatic struct s3c_camif_drvdata s3c6410_camif_drvdata = {\n\t.variant\t= &s3c6410_camif_variant,\n\t.bus_clk_freq\t= 133000000UL,\n};\n\nstatic const struct platform_device_id s3c_camif_driver_ids[] = {\n\t{\n\t\t.name\t\t= \"s3c2440-camif\",\n\t\t.driver_data\t= (unsigned long)&s3c244x_camif_drvdata,\n\t}, {\n\t\t.name\t\t= \"s3c6410-camif\",\n\t\t.driver_data\t= (unsigned long)&s3c6410_camif_drvdata,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(platform, s3c_camif_driver_ids);\n\nstatic const struct dev_pm_ops s3c_camif_pm_ops = {\n\t.runtime_suspend\t= s3c_camif_runtime_suspend,\n\t.runtime_resume\t\t= s3c_camif_runtime_resume,\n};\n\nstatic struct platform_driver s3c_camif_driver = {\n\t.probe\t\t= s3c_camif_probe,\n\t.remove_new\t= s3c_camif_remove,\n\t.id_table\t= s3c_camif_driver_ids,\n\t.driver = {\n\t\t.name\t= S3C_CAMIF_DRIVER_NAME,\n\t\t.pm\t= &s3c_camif_pm_ops,\n\t}\n};\n\nmodule_platform_driver(s3c_camif_driver);\n\nMODULE_AUTHOR(\"Sylwester Nawrocki <sylvester.nawrocki@gmail.com>\");\nMODULE_AUTHOR(\"Tomasz Figa <tomasz.figa@gmail.com>\");\nMODULE_DESCRIPTION(\"S3C24XX/S3C64XX SoC camera interface driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}