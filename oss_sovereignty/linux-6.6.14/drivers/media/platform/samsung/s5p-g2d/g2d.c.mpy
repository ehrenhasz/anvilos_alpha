{
  "module_name": "g2d.c",
  "hash_id": "bb72e73603d94fc741da805c7e701d6af1e5af9dad02ac2dd27a843ade93fb19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s5p-g2d/g2d.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/timer.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n\n#include <linux/platform_device.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"g2d.h\"\n#include \"g2d-regs.h\"\n\n#define fh2ctx(__fh) container_of(__fh, struct g2d_ctx, fh)\n\nstatic struct g2d_fmt formats[] = {\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB32,\n\t\t.depth\t= 32,\n\t\t.hw\t= COLOR_MODE(ORDER_XRGB, MODE_XRGB_8888),\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB565X,\n\t\t.depth\t= 16,\n\t\t.hw\t= COLOR_MODE(ORDER_XRGB, MODE_RGB_565),\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB555X,\n\t\t.depth\t= 16,\n\t\t.hw\t= COLOR_MODE(ORDER_XRGB, MODE_XRGB_1555),\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB444,\n\t\t.depth\t= 16,\n\t\t.hw\t= COLOR_MODE(ORDER_XRGB, MODE_XRGB_4444),\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB24,\n\t\t.depth\t= 24,\n\t\t.hw\t= COLOR_MODE(ORDER_XRGB, MODE_PACKED_RGB_888),\n\t},\n};\n#define NUM_FORMATS ARRAY_SIZE(formats)\n\nstatic struct g2d_frame def_frame = {\n\t.width\t\t= DEFAULT_WIDTH,\n\t.height\t\t= DEFAULT_HEIGHT,\n\t.c_width\t= DEFAULT_WIDTH,\n\t.c_height\t= DEFAULT_HEIGHT,\n\t.o_width\t= 0,\n\t.o_height\t= 0,\n\t.fmt\t\t= &formats[0],\n\t.right\t\t= DEFAULT_WIDTH,\n\t.bottom\t\t= DEFAULT_HEIGHT,\n};\n\nstatic struct g2d_fmt *find_fmt(struct v4l2_format *f)\n{\n\tunsigned int i;\n\tfor (i = 0; i < NUM_FORMATS; i++) {\n\t\tif (formats[i].fourcc == f->fmt.pix.pixelformat)\n\t\t\treturn &formats[i];\n\t}\n\treturn NULL;\n}\n\n\nstatic struct g2d_frame *get_frame(struct g2d_ctx *ctx,\n\t\t\t\t   enum v4l2_buf_type type)\n{\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\treturn &ctx->in;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn &ctx->out;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic int g2d_queue_setup(struct vb2_queue *vq,\n\t\t\t   unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct g2d_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct g2d_frame *f = get_frame(ctx, vq->type);\n\n\tif (IS_ERR(f))\n\t\treturn PTR_ERR(f);\n\n\tsizes[0] = f->size;\n\t*nplanes = 1;\n\n\tif (*nbuffers == 0)\n\t\t*nbuffers = 1;\n\n\treturn 0;\n}\n\nstatic int g2d_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct g2d_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct g2d_frame *f = get_frame(ctx, vb->vb2_queue->type);\n\n\tif (IS_ERR(f))\n\t\treturn PTR_ERR(f);\n\tvb2_set_plane_payload(vb, 0, f->size);\n\treturn 0;\n}\n\nstatic void g2d_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct g2d_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic const struct vb2_ops g2d_qops = {\n\t.queue_setup\t= g2d_queue_setup,\n\t.buf_prepare\t= g2d_buf_prepare,\n\t.buf_queue\t= g2d_buf_queue,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n};\n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t\t\t\tstruct vb2_queue *dst_vq)\n{\n\tstruct g2d_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->ops = &g2d_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->dev->mutex;\n\tsrc_vq->dev = ctx->dev->v4l2_dev.dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_USERPTR;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->ops = &g2d_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->dev->mutex;\n\tdst_vq->dev = ctx->dev->v4l2_dev.dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int g2d_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct g2d_ctx *ctx = container_of(ctrl->handler, struct g2d_ctx,\n\t\t\t\t\t\t\t\tctrl_handler);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->dev->ctrl_lock, flags);\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_COLORFX:\n\t\tif (ctrl->val == V4L2_COLORFX_NEGATIVE)\n\t\t\tctx->rop = ROP4_INVERT;\n\t\telse\n\t\t\tctx->rop = ROP4_COPY;\n\t\tbreak;\n\n\tcase V4L2_CID_HFLIP:\n\t\tctx->flip = ctx->ctrl_hflip->val | (ctx->ctrl_vflip->val << 1);\n\t\tbreak;\n\n\t}\n\tspin_unlock_irqrestore(&ctx->dev->ctrl_lock, flags);\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops g2d_ctrl_ops = {\n\t.s_ctrl\t\t= g2d_s_ctrl,\n};\n\nstatic int g2d_setup_ctrls(struct g2d_ctx *ctx)\n{\n\tstruct g2d_dev *dev = ctx->dev;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, 3);\n\n\tctx->ctrl_hflip = v4l2_ctrl_new_std(&ctx->ctrl_handler, &g2d_ctrl_ops,\n\t\t\t\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\n\tctx->ctrl_vflip = v4l2_ctrl_new_std(&ctx->ctrl_handler, &g2d_ctrl_ops,\n\t\t\t\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std_menu(\n\t\t&ctx->ctrl_handler,\n\t\t&g2d_ctrl_ops,\n\t\tV4L2_CID_COLORFX,\n\t\tV4L2_COLORFX_NEGATIVE,\n\t\t~((1 << V4L2_COLORFX_NONE) | (1 << V4L2_COLORFX_NEGATIVE)),\n\t\tV4L2_COLORFX_NONE);\n\n\tif (ctx->ctrl_handler.error) {\n\t\tint err = ctx->ctrl_handler.error;\n\t\tv4l2_err(&dev->v4l2_dev, \"g2d_setup_ctrls failed\\n\");\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\t\treturn err;\n\t}\n\n\tv4l2_ctrl_cluster(2, &ctx->ctrl_hflip);\n\n\treturn 0;\n}\n\nstatic int g2d_open(struct file *file)\n{\n\tstruct g2d_dev *dev = video_drvdata(file);\n\tstruct g2d_ctx *ctx = NULL;\n\tint ret = 0;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->dev = dev;\n\t \n\tctx->in\t\t= def_frame;\n\tctx->out\t= def_frame;\n\n\tif (mutex_lock_interruptible(&dev->mutex)) {\n\t\tkfree(ctx);\n\t\treturn -ERESTARTSYS;\n\t}\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx, &queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tmutex_unlock(&dev->mutex);\n\t\tkfree(ctx);\n\t\treturn ret;\n\t}\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\tg2d_setup_ctrls(ctx);\n\n\t \n\tv4l2_ctrl_handler_setup(&ctx->ctrl_handler);\n\n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\tmutex_unlock(&dev->mutex);\n\n\tv4l2_info(&dev->v4l2_dev, \"instance opened\\n\");\n\treturn 0;\n}\n\nstatic int g2d_release(struct file *file)\n{\n\tstruct g2d_dev *dev = video_drvdata(file);\n\tstruct g2d_ctx *ctx = fh2ctx(file->private_data);\n\n\tmutex_lock(&dev->mutex);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tmutex_unlock(&dev->mutex);\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\tv4l2_info(&dev->v4l2_dev, \"instance closed\\n\");\n\treturn 0;\n}\n\n\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, G2D_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, G2D_NAME, sizeof(cap->card));\n\tcap->bus_info[0] = 0;\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt(struct file *file, void *prv, struct v4l2_fmtdesc *f)\n{\n\tif (f->index >= NUM_FORMATS)\n\t\treturn -EINVAL;\n\tf->pixelformat = formats[f->index].fourcc;\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt(struct file *file, void *prv, struct v4l2_format *f)\n{\n\tstruct g2d_ctx *ctx = prv;\n\tstruct vb2_queue *vq;\n\tstruct g2d_frame *frm;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\tfrm = get_frame(ctx, f->type);\n\tif (IS_ERR(frm))\n\t\treturn PTR_ERR(frm);\n\n\tf->fmt.pix.width\t\t= frm->width;\n\tf->fmt.pix.height\t\t= frm->height;\n\tf->fmt.pix.field\t\t= V4L2_FIELD_NONE;\n\tf->fmt.pix.pixelformat\t\t= frm->fmt->fourcc;\n\tf->fmt.pix.bytesperline\t\t= (frm->width * frm->fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage\t\t= frm->size;\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt(struct file *file, void *prv, struct v4l2_format *f)\n{\n\tstruct g2d_fmt *fmt;\n\tenum v4l2_field *field;\n\n\tfmt = find_fmt(f);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tfield = &f->fmt.pix.field;\n\tif (*field == V4L2_FIELD_ANY)\n\t\t*field = V4L2_FIELD_NONE;\n\telse if (*field != V4L2_FIELD_NONE)\n\t\treturn -EINVAL;\n\n\tif (f->fmt.pix.width > MAX_WIDTH)\n\t\tf->fmt.pix.width = MAX_WIDTH;\n\tif (f->fmt.pix.height > MAX_HEIGHT)\n\t\tf->fmt.pix.height = MAX_HEIGHT;\n\n\tif (f->fmt.pix.width < 1)\n\t\tf->fmt.pix.width = 1;\n\tif (f->fmt.pix.height < 1)\n\t\tf->fmt.pix.height = 1;\n\n\tf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt(struct file *file, void *prv, struct v4l2_format *f)\n{\n\tstruct g2d_ctx *ctx = prv;\n\tstruct g2d_dev *dev = ctx->dev;\n\tstruct vb2_queue *vq;\n\tstruct g2d_frame *frm;\n\tstruct g2d_fmt *fmt;\n\tint ret = 0;\n\n\t \n\tret = vidioc_try_fmt(file, prv, f);\n\tif (ret)\n\t\treturn ret;\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"queue (%d) bust\\n\", f->type);\n\t\treturn -EBUSY;\n\t}\n\tfrm = get_frame(ctx, f->type);\n\tif (IS_ERR(frm))\n\t\treturn PTR_ERR(frm);\n\tfmt = find_fmt(f);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\tfrm->width\t= f->fmt.pix.width;\n\tfrm->height\t= f->fmt.pix.height;\n\tfrm->size\t= f->fmt.pix.sizeimage;\n\t \n\tfrm->o_width\t= 0;\n\tfrm->o_height\t= 0;\n\tfrm->c_width\t= frm->width;\n\tfrm->c_height\t= frm->height;\n\tfrm->right\t= frm->width;\n\tfrm->bottom\t= frm->height;\n\tfrm->fmt\t= fmt;\n\tfrm->stride\t= f->fmt.pix.bytesperline;\n\treturn 0;\n}\n\nstatic int vidioc_g_selection(struct file *file, void *prv,\n\t\t\t      struct v4l2_selection *s)\n{\n\tstruct g2d_ctx *ctx = prv;\n\tstruct g2d_frame *f;\n\n\tf = get_frame(ctx, s->type);\n\tif (IS_ERR(f))\n\t\treturn PTR_ERR(f);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\ts->r.left = f->o_height;\n\t\ts->r.top = f->o_width;\n\t\ts->r.width = f->c_width;\n\t\ts->r.height = f->c_height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = f->width;\n\t\ts->r.height = f->height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_try_selection(struct file *file, void *prv,\n\t\t\t\tconst struct v4l2_selection *s)\n{\n\tstruct g2d_ctx *ctx = prv;\n\tstruct g2d_dev *dev = ctx->dev;\n\tstruct g2d_frame *f;\n\n\tf = get_frame(ctx, s->type);\n\tif (IS_ERR(f))\n\t\treturn PTR_ERR(f);\n\n\tif (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tif (s->target != V4L2_SEL_TGT_COMPOSE)\n\t\t\treturn -EINVAL;\n\t} else if (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tif (s->target != V4L2_SEL_TGT_CROP)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (s->r.top < 0 || s->r.left < 0) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\"doesn't support negative values for top & left\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_s_selection(struct file *file, void *prv,\n\t\t\t      struct v4l2_selection *s)\n{\n\tstruct g2d_ctx *ctx = prv;\n\tstruct g2d_frame *f;\n\tint ret;\n\n\tret = vidioc_try_selection(file, prv, s);\n\tif (ret)\n\t\treturn ret;\n\tf = get_frame(ctx, s->type);\n\tif (IS_ERR(f))\n\t\treturn PTR_ERR(f);\n\n\tf->c_width\t= s->r.width;\n\tf->c_height\t= s->r.height;\n\tf->o_width\t= s->r.left;\n\tf->o_height\t= s->r.top;\n\tf->bottom\t= f->o_height + f->c_height;\n\tf->right\t= f->o_width + f->c_width;\n\treturn 0;\n}\n\nstatic void device_run(void *prv)\n{\n\tstruct g2d_ctx *ctx = prv;\n\tstruct g2d_dev *dev = ctx->dev;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\tunsigned long flags;\n\tu32 cmd = 0;\n\n\tdev->curr = ctx;\n\n\tsrc = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\tclk_enable(dev->gate);\n\tg2d_reset(dev);\n\n\tspin_lock_irqsave(&dev->ctrl_lock, flags);\n\n\tg2d_set_src_size(dev, &ctx->in);\n\tg2d_set_src_addr(dev, vb2_dma_contig_plane_dma_addr(&src->vb2_buf, 0));\n\n\tg2d_set_dst_size(dev, &ctx->out);\n\tg2d_set_dst_addr(dev, vb2_dma_contig_plane_dma_addr(&dst->vb2_buf, 0));\n\n\tg2d_set_rop4(dev, ctx->rop);\n\tg2d_set_flip(dev, ctx->flip);\n\n\tif (ctx->in.c_width != ctx->out.c_width ||\n\t\tctx->in.c_height != ctx->out.c_height) {\n\t\tif (dev->variant->hw_rev == TYPE_G2D_3X)\n\t\t\tcmd |= CMD_V3_ENABLE_STRETCH;\n\t\telse\n\t\t\tg2d_set_v41_stretch(dev, &ctx->in, &ctx->out);\n\t}\n\n\tg2d_set_cmd(dev, cmd);\n\tg2d_start(dev);\n\n\tspin_unlock_irqrestore(&dev->ctrl_lock, flags);\n}\n\nstatic irqreturn_t g2d_isr(int irq, void *prv)\n{\n\tstruct g2d_dev *dev = prv;\n\tstruct g2d_ctx *ctx = dev->curr;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\n\tg2d_clear_int(dev);\n\tclk_disable(dev->gate);\n\n\tBUG_ON(ctx == NULL);\n\n\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tBUG_ON(src == NULL);\n\tBUG_ON(dst == NULL);\n\n\tdst->timecode = src->timecode;\n\tdst->vb2_buf.timestamp = src->vb2_buf.timestamp;\n\tdst->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst->flags |=\n\t\tsrc->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\n\n\tdev->curr = NULL;\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct v4l2_file_operations g2d_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= g2d_open,\n\t.release\t= g2d_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct v4l2_ioctl_ops g2d_ioctl_ops = {\n\t.vidioc_querycap\t= vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= vidioc_enum_fmt,\n\t.vidioc_g_fmt_vid_cap\t\t= vidioc_g_fmt,\n\t.vidioc_try_fmt_vid_cap\t\t= vidioc_try_fmt,\n\t.vidioc_s_fmt_vid_cap\t\t= vidioc_s_fmt,\n\n\t.vidioc_enum_fmt_vid_out\t= vidioc_enum_fmt,\n\t.vidioc_g_fmt_vid_out\t\t= vidioc_g_fmt,\n\t.vidioc_try_fmt_vid_out\t\t= vidioc_try_fmt,\n\t.vidioc_s_fmt_vid_out\t\t= vidioc_s_fmt,\n\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_g_selection\t\t= vidioc_g_selection,\n\t.vidioc_s_selection\t\t= vidioc_s_selection,\n};\n\nstatic const struct video_device g2d_videodev = {\n\t.name\t\t= G2D_NAME,\n\t.fops\t\t= &g2d_fops,\n\t.ioctl_ops\t= &g2d_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= video_device_release,\n\t.vfl_dir\t= VFL_DIR_M2M,\n};\n\nstatic const struct v4l2_m2m_ops g2d_m2m_ops = {\n\t.device_run\t= device_run,\n};\n\nstatic const struct of_device_id exynos_g2d_match[];\n\nstatic int g2d_probe(struct platform_device *pdev)\n{\n\tstruct g2d_dev *dev;\n\tstruct video_device *vfd;\n\tconst struct of_device_id *of_id;\n\tint ret = 0;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dev->ctrl_lock);\n\tmutex_init(&dev->mutex);\n\tatomic_set(&dev->num_inst, 0);\n\n\tdev->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->regs))\n\t\treturn PTR_ERR(dev->regs);\n\n\tdev->clk = clk_get(&pdev->dev, \"sclk_fimg2d\");\n\tif (IS_ERR(dev->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get g2d clock\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = clk_prepare(dev->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to prepare g2d clock\\n\");\n\t\tgoto put_clk;\n\t}\n\n\tdev->gate = clk_get(&pdev->dev, \"fimg2d\");\n\tif (IS_ERR(dev->gate)) {\n\t\tdev_err(&pdev->dev, \"failed to get g2d clock gate\\n\");\n\t\tret = -ENXIO;\n\t\tgoto unprep_clk;\n\t}\n\n\tret = clk_prepare(dev->gate);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to prepare g2d clock gate\\n\");\n\t\tgoto put_clk_gate;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto unprep_clk_gate;\n\n\tdev->irq = ret;\n\n\tret = devm_request_irq(&pdev->dev, dev->irq, g2d_isr,\n\t\t\t\t\t\t0, pdev->name, dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to install IRQ\\n\");\n\t\tgoto unprep_clk_gate;\n\t}\n\n\tvb2_dma_contig_set_max_seg_size(&pdev->dev, DMA_BIT_MASK(32));\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret)\n\t\tgoto unprep_clk_gate;\n\tvfd = video_device_alloc();\n\tif (!vfd) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to allocate video device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto unreg_v4l2_dev;\n\t}\n\t*vfd = g2d_videodev;\n\tset_bit(V4L2_FL_QUIRK_INVERTED_CROP, &vfd->flags);\n\tvfd->lock = &dev->mutex;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\tvfd->device_caps = V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING;\n\n\tplatform_set_drvdata(pdev, dev);\n\tdev->m2m_dev = v4l2_m2m_init(&g2d_m2m_ops);\n\tif (IS_ERR(dev->m2m_dev)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(dev->m2m_dev);\n\t\tgoto rel_vdev;\n\t}\n\n\tdef_frame.stride = (def_frame.width * def_frame.fmt->depth) >> 3;\n\n\tof_id = of_match_node(exynos_g2d_match, pdev->dev.of_node);\n\tif (!of_id) {\n\t\tret = -ENODEV;\n\t\tgoto free_m2m;\n\t}\n\tdev->variant = (struct g2d_variant *)of_id->data;\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto free_m2m;\n\t}\n\tvideo_set_drvdata(vfd, dev);\n\tdev->vfd = vfd;\n\tv4l2_info(&dev->v4l2_dev, \"device registered as /dev/video%d\\n\",\n\t\t  vfd->num);\n\n\treturn 0;\n\nfree_m2m:\n\tv4l2_m2m_release(dev->m2m_dev);\nrel_vdev:\n\tvideo_device_release(vfd);\nunreg_v4l2_dev:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nunprep_clk_gate:\n\tclk_unprepare(dev->gate);\nput_clk_gate:\n\tclk_put(dev->gate);\nunprep_clk:\n\tclk_unprepare(dev->clk);\nput_clk:\n\tclk_put(dev->clk);\n\n\treturn ret;\n}\n\nstatic void g2d_remove(struct platform_device *pdev)\n{\n\tstruct g2d_dev *dev = platform_get_drvdata(pdev);\n\n\tv4l2_info(&dev->v4l2_dev, \"Removing \" G2D_NAME);\n\tv4l2_m2m_release(dev->m2m_dev);\n\tvideo_unregister_device(dev->vfd);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tvb2_dma_contig_clear_max_seg_size(&pdev->dev);\n\tclk_unprepare(dev->gate);\n\tclk_put(dev->gate);\n\tclk_unprepare(dev->clk);\n\tclk_put(dev->clk);\n}\n\nstatic struct g2d_variant g2d_drvdata_v3x = {\n\t.hw_rev = TYPE_G2D_3X,  \n};\n\nstatic struct g2d_variant g2d_drvdata_v4x = {\n\t.hw_rev = TYPE_G2D_4X,  \n};\n\nstatic const struct of_device_id exynos_g2d_match[] = {\n\t{\n\t\t.compatible = \"samsung,s5pv210-g2d\",\n\t\t.data = &g2d_drvdata_v3x,\n\t}, {\n\t\t.compatible = \"samsung,exynos4212-g2d\",\n\t\t.data = &g2d_drvdata_v4x,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, exynos_g2d_match);\n\nstatic struct platform_driver g2d_pdrv = {\n\t.probe\t\t= g2d_probe,\n\t.remove_new\t= g2d_remove,\n\t.driver\t\t= {\n\t\t.name = G2D_NAME,\n\t\t.of_match_table = exynos_g2d_match,\n\t},\n};\n\nmodule_platform_driver(g2d_pdrv);\n\nMODULE_AUTHOR(\"Kamil Debski <k.debski@samsung.com>\");\nMODULE_DESCRIPTION(\"S5P G2D 2d graphics accelerator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}