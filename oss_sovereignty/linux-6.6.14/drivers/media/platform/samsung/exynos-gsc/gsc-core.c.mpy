{
  "module_name": "gsc-core.c",
  "hash_id": "30e991de6292fcfce8d6a5d6c581681248f0597adfb30fd255a6f43c3747638e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos-gsc/gsc-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/bug.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"gsc-core.h\"\n\nstatic const struct gsc_fmt gsc_formats[] = {\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_RGB565X,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= GSC_RGB,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 1,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_BGR32,\n\t\t.depth\t\t= { 32 },\n\t\t.color\t\t= GSC_RGB,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 1,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUYV,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= GSC_YUV422,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CBCR,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_UYVY,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= GSC_YUV422,\n\t\t.yorder\t\t= GSC_LSB_C,\n\t\t.corder\t\t= GSC_CBCR,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_VYUY,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= GSC_YUV422,\n\t\t.yorder\t\t= GSC_LSB_C,\n\t\t.corder\t\t= GSC_CRCB,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_VYUY8_2X8,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YVYU,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= GSC_YUV422,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CRCB,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YVYU8_2X8,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUV32,\n\t\t.depth\t\t= { 32 },\n\t\t.color\t\t= GSC_YUV444,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CBCR,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 1,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUV422P,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= GSC_YUV422,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CBCR,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 3,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_NV16,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= GSC_YUV422,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CBCR,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 2,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_NV16M,\n\t\t.depth\t\t= { 8, 8 },\n\t\t.color\t\t= GSC_YUV422,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CBCR,\n\t\t.num_planes\t= 2,\n\t\t.num_comp\t= 2,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_NV61,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= GSC_YUV422,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CRCB,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 2,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_NV61M,\n\t\t.depth\t\t= { 8, 8 },\n\t\t.color\t\t= GSC_YUV422,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CRCB,\n\t\t.num_planes\t= 2,\n\t\t.num_comp\t= 2,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUV420,\n\t\t.depth\t\t= { 12 },\n\t\t.color\t\t= GSC_YUV420,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CBCR,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 3,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YVU420,\n\t\t.depth\t\t= { 12 },\n\t\t.color\t\t= GSC_YUV420,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CRCB,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 3,\n\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_NV12,\n\t\t.depth\t\t= { 12 },\n\t\t.color\t\t= GSC_YUV420,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CBCR,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 2,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_NV21,\n\t\t.depth\t\t= { 12 },\n\t\t.color\t\t= GSC_YUV420,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CRCB,\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 2,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_NV21M,\n\t\t.depth\t\t= { 8, 4 },\n\t\t.color\t\t= GSC_YUV420,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CRCB,\n\t\t.num_planes\t= 2,\n\t\t.num_comp\t= 2,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_NV12M,\n\t\t.depth\t\t= { 8, 4 },\n\t\t.color\t\t= GSC_YUV420,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CBCR,\n\t\t.num_planes\t= 2,\n\t\t.num_comp\t= 2,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUV420M,\n\t\t.depth\t\t= { 8, 2, 2 },\n\t\t.color\t\t= GSC_YUV420,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CBCR,\n\t\t.num_planes\t= 3,\n\t\t.num_comp\t= 3,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YVU420M,\n\t\t.depth\t\t= { 8, 2, 2 },\n\t\t.color\t\t= GSC_YUV420,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CRCB,\n\t\t.num_planes\t= 3,\n\t\t.num_comp\t= 3,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_NV12MT_16X16,\n\t\t.depth\t\t= { 8, 4 },\n\t\t.color\t\t= GSC_YUV420,\n\t\t.yorder\t\t= GSC_LSB_Y,\n\t\t.corder\t\t= GSC_CBCR,\n\t\t.num_planes\t= 2,\n\t\t.num_comp\t= 2,\n\t}\n};\n\nconst struct gsc_fmt *get_format(int index)\n{\n\tif (index >= ARRAY_SIZE(gsc_formats))\n\t\treturn NULL;\n\n\treturn (struct gsc_fmt *)&gsc_formats[index];\n}\n\nconst struct gsc_fmt *find_fmt(u32 *pixelformat, u32 *mbus_code, u32 index)\n{\n\tconst struct gsc_fmt *fmt, *def_fmt = NULL;\n\tunsigned int i;\n\n\tif (index >= ARRAY_SIZE(gsc_formats))\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(gsc_formats); ++i) {\n\t\tfmt = get_format(i);\n\t\tif (pixelformat && fmt->pixelformat == *pixelformat)\n\t\t\treturn fmt;\n\t\tif (mbus_code && fmt->mbus_code == *mbus_code)\n\t\t\treturn fmt;\n\t\tif (index == i)\n\t\t\tdef_fmt = fmt;\n\t}\n\treturn def_fmt;\n\n}\n\nvoid gsc_set_frame_size(struct gsc_frame *frame, int width, int height)\n{\n\tframe->f_width\t= width;\n\tframe->f_height\t= height;\n\tframe->crop.width = width;\n\tframe->crop.height = height;\n\tframe->crop.left = 0;\n\tframe->crop.top = 0;\n}\n\nint gsc_cal_prescaler_ratio(struct gsc_variant *var, u32 src, u32 dst,\n\t\t\t\t\t\t\t\tu32 *ratio)\n{\n\tif ((dst > src) || (dst >= src / var->poly_sc_down_max)) {\n\t\t*ratio = 1;\n\t\treturn 0;\n\t}\n\n\tif ((src / var->poly_sc_down_max / var->pre_sc_down_max) > dst) {\n\t\tpr_err(\"Exceeded maximum downscaling ratio (1/16))\");\n\t\treturn -EINVAL;\n\t}\n\n\t*ratio = (dst > (src / 8)) ? 2 : 4;\n\n\treturn 0;\n}\n\nvoid gsc_get_prescaler_shfactor(u32 hratio, u32 vratio, u32 *sh)\n{\n\tif (hratio == 4 && vratio == 4)\n\t\t*sh = 4;\n\telse if ((hratio == 4 && vratio == 2) ||\n\t\t (hratio == 2 && vratio == 4))\n\t\t*sh = 3;\n\telse if ((hratio == 4 && vratio == 1) ||\n\t\t (hratio == 1 && vratio == 4) ||\n\t\t (hratio == 2 && vratio == 2))\n\t\t*sh = 2;\n\telse if (hratio == 1 && vratio == 1)\n\t\t*sh = 0;\n\telse\n\t\t*sh = 1;\n}\n\nvoid gsc_check_src_scale_info(struct gsc_variant *var,\n\t\t\t\tstruct gsc_frame *s_frame, u32 *wratio,\n\t\t\t\t u32 tx, u32 ty, u32 *hratio)\n{\n\tint remainder = 0, walign, halign;\n\n\tif (is_yuv420(s_frame->fmt->color)) {\n\t\twalign = GSC_SC_ALIGN_4;\n\t\thalign = GSC_SC_ALIGN_4;\n\t} else if (is_yuv422(s_frame->fmt->color)) {\n\t\twalign = GSC_SC_ALIGN_4;\n\t\thalign = GSC_SC_ALIGN_2;\n\t} else {\n\t\twalign = GSC_SC_ALIGN_2;\n\t\thalign = GSC_SC_ALIGN_2;\n\t}\n\n\tremainder = s_frame->crop.width % (*wratio * walign);\n\tif (remainder) {\n\t\ts_frame->crop.width -= remainder;\n\t\tgsc_cal_prescaler_ratio(var, s_frame->crop.width, tx, wratio);\n\t\tpr_info(\"cropped src width size is recalculated from %d to %d\",\n\t\t\ts_frame->crop.width + remainder, s_frame->crop.width);\n\t}\n\n\tremainder = s_frame->crop.height % (*hratio * halign);\n\tif (remainder) {\n\t\ts_frame->crop.height -= remainder;\n\t\tgsc_cal_prescaler_ratio(var, s_frame->crop.height, ty, hratio);\n\t\tpr_info(\"cropped src height size is recalculated from %d to %d\",\n\t\t\ts_frame->crop.height + remainder, s_frame->crop.height);\n\t}\n}\n\nint gsc_enum_fmt(struct v4l2_fmtdesc *f)\n{\n\tconst struct gsc_fmt *fmt;\n\n\tfmt = find_fmt(NULL, NULL, f->index);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = fmt->pixelformat;\n\n\treturn 0;\n}\n\nstatic int get_plane_info(struct gsc_frame *frm, u32 addr, u32 *index, u32 *ret_addr)\n{\n\tif (frm->addr.y == addr) {\n\t\t*index = 0;\n\t\t*ret_addr = frm->addr.y;\n\t} else if (frm->addr.cb == addr) {\n\t\t*index = 1;\n\t\t*ret_addr = frm->addr.cb;\n\t} else if (frm->addr.cr == addr) {\n\t\t*index = 2;\n\t\t*ret_addr = frm->addr.cr;\n\t} else {\n\t\tpr_err(\"Plane address is wrong\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nvoid gsc_set_prefbuf(struct gsc_dev *gsc, struct gsc_frame *frm)\n{\n\tu32 f_chk_addr, f_chk_len, s_chk_addr = 0, s_chk_len = 0;\n\n\tf_chk_addr = frm->addr.y;\n\tf_chk_len = frm->payload[0];\n\tif (frm->fmt->num_planes == 2) {\n\t\ts_chk_addr = frm->addr.cb;\n\t\ts_chk_len = frm->payload[1];\n\t} else if (frm->fmt->num_planes == 3) {\n\t\tu32 low_addr, low_plane, mid_addr, mid_plane;\n\t\tu32 high_addr, high_plane;\n\t\tu32 t_min, t_max;\n\n\t\tt_min = min3(frm->addr.y, frm->addr.cb, frm->addr.cr);\n\t\tif (get_plane_info(frm, t_min, &low_plane, &low_addr))\n\t\t\treturn;\n\t\tt_max = max3(frm->addr.y, frm->addr.cb, frm->addr.cr);\n\t\tif (get_plane_info(frm, t_max, &high_plane, &high_addr))\n\t\t\treturn;\n\n\t\tmid_plane = 3 - (low_plane + high_plane);\n\t\tif (mid_plane == 0)\n\t\t\tmid_addr = frm->addr.y;\n\t\telse if (mid_plane == 1)\n\t\t\tmid_addr = frm->addr.cb;\n\t\telse if (mid_plane == 2)\n\t\t\tmid_addr = frm->addr.cr;\n\t\telse\n\t\t\treturn;\n\n\t\tf_chk_addr = low_addr;\n\t\tif (mid_addr + frm->payload[mid_plane] - low_addr >\n\t\t    high_addr + frm->payload[high_plane] - mid_addr) {\n\t\t\tf_chk_len = frm->payload[low_plane];\n\t\t\ts_chk_addr = mid_addr;\n\t\t\ts_chk_len = high_addr +\n\t\t\t\t\tfrm->payload[high_plane] - mid_addr;\n\t\t} else {\n\t\t\tf_chk_len = mid_addr +\n\t\t\t\t\tfrm->payload[mid_plane] - low_addr;\n\t\t\ts_chk_addr = high_addr;\n\t\t\ts_chk_len = frm->payload[high_plane];\n\t\t}\n\t}\n\tpr_debug(\"f_addr = 0x%08x, f_len = %d, s_addr = 0x%08x, s_len = %d\\n\",\n\t\t\tf_chk_addr, f_chk_len, s_chk_addr, s_chk_len);\n}\n\nint gsc_try_fmt_mplane(struct gsc_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct gsc_dev *gsc = ctx->gsc_dev;\n\tstruct gsc_variant *variant = gsc->variant;\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tconst struct gsc_fmt *fmt;\n\tu32 max_w, max_h, mod_x, mod_y;\n\tu32 min_w, min_h, tmp_w, tmp_h;\n\tint i;\n\n\tpr_debug(\"user put w: %d, h: %d\", pix_mp->width, pix_mp->height);\n\n\tfmt = find_fmt(&pix_mp->pixelformat, NULL, 0);\n\tif (!fmt) {\n\t\tpr_err(\"pixelformat format (0x%X) invalid\\n\",\n\t\t\t\t\t\tpix_mp->pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pix_mp->field == V4L2_FIELD_ANY)\n\t\tpix_mp->field = V4L2_FIELD_NONE;\n\telse if (pix_mp->field != V4L2_FIELD_NONE) {\n\t\tpr_debug(\"Not supported field order(%d)\\n\", pix_mp->field);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_w = variant->pix_max->target_rot_dis_w;\n\tmax_h = variant->pix_max->target_rot_dis_h;\n\n\tmod_x = ffs(variant->pix_align->org_w) - 1;\n\tif (is_yuv420(fmt->color))\n\t\tmod_y = ffs(variant->pix_align->org_h) - 1;\n\telse\n\t\tmod_y = ffs(variant->pix_align->org_h) - 2;\n\n\tif (V4L2_TYPE_IS_OUTPUT(f->type)) {\n\t\tmin_w = variant->pix_min->org_w;\n\t\tmin_h = variant->pix_min->org_h;\n\t} else {\n\t\tmin_w = variant->pix_min->target_rot_dis_w;\n\t\tmin_h = variant->pix_min->target_rot_dis_h;\n\t\tpix_mp->colorspace = ctx->out_colorspace;\n\t}\n\n\tpr_debug(\"mod_x: %d, mod_y: %d, max_w: %d, max_h = %d\",\n\t\t\tmod_x, mod_y, max_w, max_h);\n\n\t \n\ttmp_w = pix_mp->width;\n\ttmp_h = pix_mp->height;\n\n\tv4l_bound_align_image(&pix_mp->width, min_w, max_w, mod_x,\n\t\t&pix_mp->height, min_h, max_h, mod_y, 0);\n\tif (tmp_w != pix_mp->width || tmp_h != pix_mp->height)\n\t\tpr_debug(\"Image size has been modified from %dx%d to %dx%d\\n\",\n\t\t\t tmp_w, tmp_h, pix_mp->width, pix_mp->height);\n\n\tpix_mp->num_planes = fmt->num_planes;\n\n\tif (V4L2_TYPE_IS_OUTPUT(f->type))\n\t\tctx->out_colorspace = pix_mp->colorspace;\n\n\tfor (i = 0; i < pix_mp->num_planes; ++i) {\n\t\tstruct v4l2_plane_pix_format *plane_fmt = &pix_mp->plane_fmt[i];\n\t\tu32 bpl = plane_fmt->bytesperline;\n\n\t\tif (fmt->num_comp == 1 &&  \n\t\t    (bpl == 0 || (bpl * 8 / fmt->depth[i]) < pix_mp->width))\n\t\t\tbpl = pix_mp->width * fmt->depth[i] / 8;\n\n\t\tif (fmt->num_comp > 1 &&  \n\t\t    (bpl == 0 || bpl < pix_mp->width))\n\t\t\tbpl = pix_mp->width;\n\n\t\tif (i != 0 && fmt->num_comp == 3)\n\t\t\tbpl /= 2;\n\n\t\tplane_fmt->bytesperline = bpl;\n\t\tplane_fmt->sizeimage = max(pix_mp->width * pix_mp->height *\n\t\t\t\t\t   fmt->depth[i] / 8,\n\t\t\t\t\t   plane_fmt->sizeimage);\n\t\tpr_debug(\"[%d]: bpl: %d, sizeimage: %d\",\n\t\t\t\ti, bpl, pix_mp->plane_fmt[i].sizeimage);\n\t}\n\n\treturn 0;\n}\n\nint gsc_g_fmt_mplane(struct gsc_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct gsc_frame *frame;\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tint i;\n\n\tframe = ctx_get_frame(ctx, f->type);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\tpix_mp = &f->fmt.pix_mp;\n\n\tpix_mp->width\t\t= frame->f_width;\n\tpix_mp->height\t\t= frame->f_height;\n\tpix_mp->field\t\t= V4L2_FIELD_NONE;\n\tpix_mp->pixelformat\t= frame->fmt->pixelformat;\n\tpix_mp->num_planes\t= frame->fmt->num_planes;\n\tpix_mp->colorspace = ctx->out_colorspace;\n\n\tfor (i = 0; i < pix_mp->num_planes; ++i) {\n\t\tpix_mp->plane_fmt[i].bytesperline = (frame->f_width *\n\t\t\tframe->fmt->depth[i]) / 8;\n\t\tpix_mp->plane_fmt[i].sizeimage =\n\t\t\t pix_mp->plane_fmt[i].bytesperline * frame->f_height;\n\t}\n\n\treturn 0;\n}\n\nvoid gsc_check_crop_change(u32 tmp_w, u32 tmp_h, u32 *w, u32 *h)\n{\n\tif (tmp_w != *w || tmp_h != *h) {\n\t\tpr_info(\"Cropped size has been modified from %dx%d to %dx%d\",\n\t\t\t\t\t\t\t*w, *h, tmp_w, tmp_h);\n\t\t*w = tmp_w;\n\t\t*h = tmp_h;\n\t}\n}\n\nint gsc_try_selection(struct gsc_ctx *ctx, struct v4l2_selection *s)\n{\n\tstruct gsc_frame *f;\n\tstruct gsc_dev *gsc = ctx->gsc_dev;\n\tstruct gsc_variant *variant = gsc->variant;\n\tu32 mod_x = 0, mod_y = 0, tmp_w, tmp_h;\n\tu32 min_w, min_h, max_w, max_h;\n\n\tif (s->r.top < 0 || s->r.left < 0) {\n\t\tpr_err(\"doesn't support negative values for top & left\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpr_debug(\"user put w: %d, h: %d\", s->r.width, s->r.height);\n\n\tif (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tf = &ctx->d_frame;\n\telse if (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tf = &ctx->s_frame;\n\telse\n\t\treturn -EINVAL;\n\n\tmax_w = f->f_width;\n\tmax_h = f->f_height;\n\ttmp_w = s->r.width;\n\ttmp_h = s->r.height;\n\n\tif (V4L2_TYPE_IS_OUTPUT(s->type)) {\n\t\tif ((is_yuv422(f->fmt->color) && f->fmt->num_comp == 1) ||\n\t\t    is_rgb(f->fmt->color))\n\t\t\tmin_w = 32;\n\t\telse\n\t\t\tmin_w = 64;\n\t\tif ((is_yuv422(f->fmt->color) && f->fmt->num_comp == 3) ||\n\t\t    is_yuv420(f->fmt->color))\n\t\t\tmin_h = 32;\n\t\telse\n\t\t\tmin_h = 16;\n\t} else {\n\t\tif (is_yuv420(f->fmt->color) || is_yuv422(f->fmt->color))\n\t\t\tmod_x = ffs(variant->pix_align->target_w) - 1;\n\t\tif (is_yuv420(f->fmt->color))\n\t\t\tmod_y = ffs(variant->pix_align->target_h) - 1;\n\t\tif (ctx->gsc_ctrls.rotate->val == 90 ||\n\t\t    ctx->gsc_ctrls.rotate->val == 270) {\n\t\t\tmax_w = f->f_height;\n\t\t\tmax_h = f->f_width;\n\t\t\tmin_w = variant->pix_min->target_rot_en_w;\n\t\t\tmin_h = variant->pix_min->target_rot_en_h;\n\t\t\ttmp_w = s->r.height;\n\t\t\ttmp_h = s->r.width;\n\t\t} else {\n\t\t\tmin_w = variant->pix_min->target_rot_dis_w;\n\t\t\tmin_h = variant->pix_min->target_rot_dis_h;\n\t\t}\n\t}\n\tpr_debug(\"mod_x: %d, mod_y: %d, min_w: %d, min_h = %d\",\n\t\t\t\t\tmod_x, mod_y, min_w, min_h);\n\tpr_debug(\"tmp_w : %d, tmp_h : %d\", tmp_w, tmp_h);\n\n\tv4l_bound_align_image(&tmp_w, min_w, max_w, mod_x,\n\t\t\t      &tmp_h, min_h, max_h, mod_y, 0);\n\n\tif (V4L2_TYPE_IS_CAPTURE(s->type) &&\n\t    (ctx->gsc_ctrls.rotate->val == 90 ||\n\t     ctx->gsc_ctrls.rotate->val == 270))\n\t\tgsc_check_crop_change(tmp_h, tmp_w,\n\t\t\t\t\t&s->r.width, &s->r.height);\n\telse\n\t\tgsc_check_crop_change(tmp_w, tmp_h,\n\t\t\t\t\t&s->r.width, &s->r.height);\n\n\n\t \n\t \n\tif (s->r.left + tmp_w > max_w)\n\t\ts->r.left = max_w - tmp_w;\n\tif (s->r.top + tmp_h > max_h)\n\t\ts->r.top = max_h - tmp_h;\n\n\tif ((is_yuv420(f->fmt->color) || is_yuv422(f->fmt->color)) &&\n\t    s->r.left & 1)\n\t\ts->r.left -= 1;\n\n\tpr_debug(\"Aligned l:%d, t:%d, w:%d, h:%d, f_w: %d, f_h: %d\",\n\t\t s->r.left, s->r.top, s->r.width, s->r.height, max_w, max_h);\n\n\treturn 0;\n}\n\nint gsc_check_scaler_ratio(struct gsc_variant *var, int sw, int sh, int dw,\n\t\t\t   int dh, int rot, int out_path)\n{\n\tint tmp_w, tmp_h, sc_down_max;\n\n\tif (out_path == GSC_DMA)\n\t\tsc_down_max = var->sc_down_max;\n\telse\n\t\tsc_down_max = var->local_sc_down;\n\n\tif (rot == 90 || rot == 270) {\n\t\ttmp_w = dh;\n\t\ttmp_h = dw;\n\t} else {\n\t\ttmp_w = dw;\n\t\ttmp_h = dh;\n\t}\n\n\tif ((sw / tmp_w) > sc_down_max ||\n\t    (sh / tmp_h) > sc_down_max ||\n\t    (tmp_w / sw) > var->sc_up_max ||\n\t    (tmp_h / sh) > var->sc_up_max)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint gsc_set_scaler_info(struct gsc_ctx *ctx)\n{\n\tstruct gsc_scaler *sc = &ctx->scaler;\n\tstruct gsc_frame *s_frame = &ctx->s_frame;\n\tstruct gsc_frame *d_frame = &ctx->d_frame;\n\tstruct gsc_variant *variant = ctx->gsc_dev->variant;\n\tstruct device *dev = &ctx->gsc_dev->pdev->dev;\n\tint tx, ty;\n\tint ret;\n\n\tret = gsc_check_scaler_ratio(variant, s_frame->crop.width,\n\t\ts_frame->crop.height, d_frame->crop.width, d_frame->crop.height,\n\t\tctx->gsc_ctrls.rotate->val, ctx->out_path);\n\tif (ret) {\n\t\tpr_err(\"out of scaler range\");\n\t\treturn ret;\n\t}\n\n\tif (ctx->gsc_ctrls.rotate->val == 90 ||\n\t    ctx->gsc_ctrls.rotate->val == 270) {\n\t\tty = d_frame->crop.width;\n\t\ttx = d_frame->crop.height;\n\t} else {\n\t\ttx = d_frame->crop.width;\n\t\tty = d_frame->crop.height;\n\t}\n\n\tif (tx <= 0 || ty <= 0) {\n\t\tdev_err(dev, \"Invalid target size: %dx%d\", tx, ty);\n\t\treturn -EINVAL;\n\t}\n\n\tret = gsc_cal_prescaler_ratio(variant, s_frame->crop.width,\n\t\t\t\t      tx, &sc->pre_hratio);\n\tif (ret) {\n\t\tpr_err(\"Horizontal scale ratio is out of range\");\n\t\treturn ret;\n\t}\n\n\tret = gsc_cal_prescaler_ratio(variant, s_frame->crop.height,\n\t\t\t\t      ty, &sc->pre_vratio);\n\tif (ret) {\n\t\tpr_err(\"Vertical scale ratio is out of range\");\n\t\treturn ret;\n\t}\n\n\tgsc_check_src_scale_info(variant, s_frame, &sc->pre_hratio,\n\t\t\t\t tx, ty, &sc->pre_vratio);\n\n\tgsc_get_prescaler_shfactor(sc->pre_hratio, sc->pre_vratio,\n\t\t\t\t   &sc->pre_shfactor);\n\n\tsc->main_hratio = (s_frame->crop.width << 16) / tx;\n\tsc->main_vratio = (s_frame->crop.height << 16) / ty;\n\n\tpr_debug(\"scaler input/output size : sx = %d, sy = %d, tx = %d, ty = %d\",\n\t\t\ts_frame->crop.width, s_frame->crop.height, tx, ty);\n\tpr_debug(\"scaler ratio info : pre_shfactor : %d, pre_h : %d\",\n\t\t\tsc->pre_shfactor, sc->pre_hratio);\n\tpr_debug(\"pre_v :%d, main_h : %d, main_v : %d\",\n\t\t\tsc->pre_vratio, sc->main_hratio, sc->main_vratio);\n\n\treturn 0;\n}\n\nstatic int __gsc_s_ctrl(struct gsc_ctx *ctx, struct v4l2_ctrl *ctrl)\n{\n\tstruct gsc_dev *gsc = ctx->gsc_dev;\n\tstruct gsc_variant *variant = gsc->variant;\n\tunsigned int flags = GSC_DST_FMT | GSC_SRC_FMT;\n\tint ret = 0;\n\n\tif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tctx->hflip = ctrl->val;\n\t\tbreak;\n\n\tcase V4L2_CID_VFLIP:\n\t\tctx->vflip = ctrl->val;\n\t\tbreak;\n\n\tcase V4L2_CID_ROTATE:\n\t\tif ((ctx->state & flags) == flags) {\n\t\t\tret = gsc_check_scaler_ratio(variant,\n\t\t\t\t\tctx->s_frame.crop.width,\n\t\t\t\t\tctx->s_frame.crop.height,\n\t\t\t\t\tctx->d_frame.crop.width,\n\t\t\t\t\tctx->d_frame.crop.height,\n\t\t\t\t\tctx->gsc_ctrls.rotate->val,\n\t\t\t\t\tctx->out_path);\n\n\t\t\tif (ret)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tctx->rotation = ctrl->val;\n\t\tbreak;\n\n\tcase V4L2_CID_ALPHA_COMPONENT:\n\t\tctx->d_frame.alpha = ctrl->val;\n\t\tbreak;\n\t}\n\n\tctx->state |= GSC_PARAMS;\n\treturn 0;\n}\n\nstatic int gsc_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct gsc_ctx *ctx = ctrl_to_ctx(ctrl);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&ctx->gsc_dev->slock, flags);\n\tret = __gsc_s_ctrl(ctx, ctrl);\n\tspin_unlock_irqrestore(&ctx->gsc_dev->slock, flags);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops gsc_ctrl_ops = {\n\t.s_ctrl = gsc_s_ctrl,\n};\n\nint gsc_ctrls_create(struct gsc_ctx *ctx)\n{\n\tif (ctx->ctrls_rdy) {\n\t\tpr_err(\"Control handler of this context was created already\");\n\t\treturn 0;\n\t}\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, GSC_MAX_CTRL_NUM);\n\n\tctx->gsc_ctrls.rotate = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t\t&gsc_ctrl_ops, V4L2_CID_ROTATE, 0, 270, 90, 0);\n\tctx->gsc_ctrls.hflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t\t&gsc_ctrl_ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tctx->gsc_ctrls.vflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t\t&gsc_ctrl_ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tctx->gsc_ctrls.global_alpha = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t&gsc_ctrl_ops, V4L2_CID_ALPHA_COMPONENT, 0, 255, 1, 0);\n\n\tctx->ctrls_rdy = ctx->ctrl_handler.error == 0;\n\n\tif (ctx->ctrl_handler.error) {\n\t\tint err = ctx->ctrl_handler.error;\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\t\tpr_err(\"Failed to create G-Scaler control handlers\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid gsc_ctrls_delete(struct gsc_ctx *ctx)\n{\n\tif (ctx->ctrls_rdy) {\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\t\tctx->ctrls_rdy = false;\n\t}\n}\n\n \nint gsc_prepare_addr(struct gsc_ctx *ctx, struct vb2_buffer *vb,\n\t\t\tstruct gsc_frame *frame, struct gsc_addr *addr)\n{\n\tint ret = 0;\n\tu32 pix_size;\n\n\tif ((vb == NULL) || (frame == NULL))\n\t\treturn -EINVAL;\n\n\tpix_size = frame->f_width * frame->f_height;\n\n\tpr_debug(\"num_planes= %d, num_comp= %d, pix_size= %d\",\n\t\tframe->fmt->num_planes, frame->fmt->num_comp, pix_size);\n\n\taddr->y = vb2_dma_contig_plane_dma_addr(vb, 0);\n\n\tif (frame->fmt->num_planes == 1) {\n\t\tswitch (frame->fmt->num_comp) {\n\t\tcase 1:\n\t\t\taddr->cb = 0;\n\t\t\taddr->cr = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\taddr->cb = (dma_addr_t)(addr->y + pix_size);\n\t\t\taddr->cr = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t \n\t\t\taddr->cb = (dma_addr_t)(addr->y + pix_size);\n\t\t\tif (GSC_YUV420 == frame->fmt->color)\n\t\t\t\taddr->cr = (dma_addr_t)(addr->cb\n\t\t\t\t\t\t+ (pix_size >> 2));\n\t\t\telse  \n\t\t\t\taddr->cr = (dma_addr_t)(addr->cb\n\t\t\t\t\t\t+ (pix_size >> 1));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid the number of color planes\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (frame->fmt->num_planes >= 2)\n\t\t\taddr->cb = vb2_dma_contig_plane_dma_addr(vb, 1);\n\n\t\tif (frame->fmt->num_planes == 3)\n\t\t\taddr->cr = vb2_dma_contig_plane_dma_addr(vb, 2);\n\t}\n\n\tif ((frame->fmt->pixelformat == V4L2_PIX_FMT_VYUY) ||\n\t\t(frame->fmt->pixelformat == V4L2_PIX_FMT_YVYU) ||\n\t\t(frame->fmt->pixelformat == V4L2_PIX_FMT_YVU420) ||\n\t\t(frame->fmt->pixelformat == V4L2_PIX_FMT_YVU420M))\n\t\tswap(addr->cb, addr->cr);\n\n\tpr_debug(\"ADDR: y= %pad  cb= %pad cr= %pad ret= %d\",\n\t\t&addr->y, &addr->cb, &addr->cr, ret);\n\n\treturn ret;\n}\n\nstatic irqreturn_t gsc_irq_handler(int irq, void *priv)\n{\n\tstruct gsc_dev *gsc = priv;\n\tstruct gsc_ctx *ctx;\n\tint gsc_irq;\n\n\tgsc_irq = gsc_hw_get_irq_status(gsc);\n\tgsc_hw_clear_irq(gsc, gsc_irq);\n\n\tif (gsc_irq == GSC_IRQ_OVERRUN) {\n\t\tpr_err(\"Local path input over-run interrupt has occurred!\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_lock(&gsc->slock);\n\n\tif (test_and_clear_bit(ST_M2M_PEND, &gsc->state)) {\n\n\t\tgsc_hw_enable_control(gsc, false);\n\n\t\tif (test_and_clear_bit(ST_M2M_SUSPENDING, &gsc->state)) {\n\t\t\tset_bit(ST_M2M_SUSPENDED, &gsc->state);\n\t\t\twake_up(&gsc->irq_queue);\n\t\t\tgoto isr_unlock;\n\t\t}\n\t\tctx = v4l2_m2m_get_curr_priv(gsc->m2m.m2m_dev);\n\n\t\tif (!ctx || !ctx->m2m_ctx)\n\t\t\tgoto isr_unlock;\n\n\t\tspin_unlock(&gsc->slock);\n\t\tgsc_m2m_job_finish(ctx, VB2_BUF_STATE_DONE);\n\n\t\t \n\t\tif (ctx->state & GSC_CTX_STOP_REQ) {\n\t\t\tctx->state &= ~GSC_CTX_STOP_REQ;\n\t\t\twake_up(&gsc->irq_queue);\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\nisr_unlock:\n\tspin_unlock(&gsc->slock);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct gsc_pix_max gsc_v_100_max = {\n\t.org_scaler_bypass_w\t= 8192,\n\t.org_scaler_bypass_h\t= 8192,\n\t.org_scaler_input_w\t= 4800,\n\t.org_scaler_input_h\t= 3344,\n\t.real_rot_dis_w\t\t= 4800,\n\t.real_rot_dis_h\t\t= 3344,\n\t.real_rot_en_w\t\t= 2047,\n\t.real_rot_en_h\t\t= 2047,\n\t.target_rot_dis_w\t= 4800,\n\t.target_rot_dis_h\t= 3344,\n\t.target_rot_en_w\t= 2016,\n\t.target_rot_en_h\t= 2016,\n};\n\nstatic struct gsc_pix_max gsc_v_5250_max = {\n\t.org_scaler_bypass_w\t= 8192,\n\t.org_scaler_bypass_h\t= 8192,\n\t.org_scaler_input_w\t= 4800,\n\t.org_scaler_input_h\t= 3344,\n\t.real_rot_dis_w\t\t= 4800,\n\t.real_rot_dis_h\t\t= 3344,\n\t.real_rot_en_w\t\t= 2016,\n\t.real_rot_en_h\t\t= 2016,\n\t.target_rot_dis_w\t= 4800,\n\t.target_rot_dis_h\t= 3344,\n\t.target_rot_en_w\t= 2016,\n\t.target_rot_en_h\t= 2016,\n};\n\nstatic struct gsc_pix_max gsc_v_5420_max = {\n\t.org_scaler_bypass_w\t= 8192,\n\t.org_scaler_bypass_h\t= 8192,\n\t.org_scaler_input_w\t= 4800,\n\t.org_scaler_input_h\t= 3344,\n\t.real_rot_dis_w\t\t= 4800,\n\t.real_rot_dis_h\t\t= 3344,\n\t.real_rot_en_w\t\t= 2048,\n\t.real_rot_en_h\t\t= 2048,\n\t.target_rot_dis_w\t= 4800,\n\t.target_rot_dis_h\t= 3344,\n\t.target_rot_en_w\t= 2016,\n\t.target_rot_en_h\t= 2016,\n};\n\nstatic struct gsc_pix_max gsc_v_5433_max = {\n\t.org_scaler_bypass_w\t= 8192,\n\t.org_scaler_bypass_h\t= 8192,\n\t.org_scaler_input_w\t= 4800,\n\t.org_scaler_input_h\t= 3344,\n\t.real_rot_dis_w\t\t= 4800,\n\t.real_rot_dis_h\t\t= 3344,\n\t.real_rot_en_w\t\t= 2047,\n\t.real_rot_en_h\t\t= 2047,\n\t.target_rot_dis_w\t= 4800,\n\t.target_rot_dis_h\t= 3344,\n\t.target_rot_en_w\t= 2016,\n\t.target_rot_en_h\t= 2016,\n};\n\nstatic struct gsc_pix_min gsc_v_100_min = {\n\t.org_w\t\t\t= 64,\n\t.org_h\t\t\t= 32,\n\t.real_w\t\t\t= 64,\n\t.real_h\t\t\t= 32,\n\t.target_rot_dis_w\t= 64,\n\t.target_rot_dis_h\t= 32,\n\t.target_rot_en_w\t= 32,\n\t.target_rot_en_h\t= 16,\n};\n\nstatic struct gsc_pix_align gsc_v_100_align = {\n\t.org_h\t\t\t= 16,\n\t.org_w\t\t\t= 16,  \n\t.offset_h\t\t= 2,   \n\t.real_w\t\t\t= 16,  \n\t.real_h\t\t\t= 16,  \n\t.target_w\t\t= 2,   \n\t.target_h\t\t= 2,   \n};\n\nstatic struct gsc_variant gsc_v_100_variant = {\n\t.pix_max\t\t= &gsc_v_100_max,\n\t.pix_min\t\t= &gsc_v_100_min,\n\t.pix_align\t\t= &gsc_v_100_align,\n\t.in_buf_cnt\t\t= 32,\n\t.out_buf_cnt\t\t= 32,\n\t.sc_up_max\t\t= 8,\n\t.sc_down_max\t\t= 16,\n\t.poly_sc_down_max\t= 4,\n\t.pre_sc_down_max\t= 4,\n\t.local_sc_down\t\t= 2,\n};\n\nstatic struct gsc_variant gsc_v_5250_variant = {\n\t.pix_max\t\t= &gsc_v_5250_max,\n\t.pix_min\t\t= &gsc_v_100_min,\n\t.pix_align\t\t= &gsc_v_100_align,\n\t.in_buf_cnt\t\t= 32,\n\t.out_buf_cnt\t\t= 32,\n\t.sc_up_max\t\t= 8,\n\t.sc_down_max\t\t= 16,\n\t.poly_sc_down_max\t= 4,\n\t.pre_sc_down_max\t= 4,\n\t.local_sc_down\t\t= 2,\n};\n\nstatic struct gsc_variant gsc_v_5420_variant = {\n\t.pix_max\t\t= &gsc_v_5420_max,\n\t.pix_min\t\t= &gsc_v_100_min,\n\t.pix_align\t\t= &gsc_v_100_align,\n\t.in_buf_cnt\t\t= 32,\n\t.out_buf_cnt\t\t= 32,\n\t.sc_up_max\t\t= 8,\n\t.sc_down_max\t\t= 16,\n\t.poly_sc_down_max\t= 4,\n\t.pre_sc_down_max\t= 4,\n\t.local_sc_down\t\t= 2,\n};\n\nstatic struct gsc_variant gsc_v_5433_variant = {\n\t.pix_max\t\t= &gsc_v_5433_max,\n\t.pix_min\t\t= &gsc_v_100_min,\n\t.pix_align\t\t= &gsc_v_100_align,\n\t.in_buf_cnt\t\t= 32,\n\t.out_buf_cnt\t\t= 32,\n\t.sc_up_max\t\t= 8,\n\t.sc_down_max\t\t= 16,\n\t.poly_sc_down_max\t= 4,\n\t.pre_sc_down_max\t= 4,\n\t.local_sc_down\t\t= 2,\n};\n\nstatic struct gsc_driverdata gsc_v_100_drvdata = {\n\t.variant = {\n\t\t[0] = &gsc_v_100_variant,\n\t\t[1] = &gsc_v_100_variant,\n\t\t[2] = &gsc_v_100_variant,\n\t\t[3] = &gsc_v_100_variant,\n\t},\n\t.num_entities = 4,\n\t.clk_names = { \"gscl\" },\n\t.num_clocks = 1,\n};\n\nstatic struct gsc_driverdata gsc_v_5250_drvdata = {\n\t.variant = {\n\t\t[0] = &gsc_v_5250_variant,\n\t\t[1] = &gsc_v_5250_variant,\n\t\t[2] = &gsc_v_5250_variant,\n\t\t[3] = &gsc_v_5250_variant,\n\t},\n\t.num_entities = 4,\n\t.clk_names = { \"gscl\" },\n\t.num_clocks = 1,\n};\n\nstatic struct gsc_driverdata gsc_v_5420_drvdata = {\n\t.variant = {\n\t\t[0] = &gsc_v_5420_variant,\n\t\t[1] = &gsc_v_5420_variant,\n\t},\n\t.num_entities = 2,\n\t.clk_names = { \"gscl\" },\n\t.num_clocks = 1,\n};\n\nstatic struct gsc_driverdata gsc_5433_drvdata = {\n\t.variant = {\n\t\t[0] = &gsc_v_5433_variant,\n\t\t[1] = &gsc_v_5433_variant,\n\t\t[2] = &gsc_v_5433_variant,\n\t},\n\t.num_entities = 3,\n\t.clk_names = { \"pclk\", \"aclk\", \"aclk_xiu\", \"aclk_gsclbend\" },\n\t.num_clocks = 4,\n};\n\nstatic const struct of_device_id exynos_gsc_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos5250-gsc\",\n\t\t.data = &gsc_v_5250_drvdata,\n\t},\n\t{\n\t\t.compatible = \"samsung,exynos5420-gsc\",\n\t\t.data = &gsc_v_5420_drvdata,\n\t},\n\t{\n\t\t.compatible = \"samsung,exynos5433-gsc\",\n\t\t.data = &gsc_5433_drvdata,\n\t},\n\t{\n\t\t.compatible = \"samsung,exynos5-gsc\",\n\t\t.data = &gsc_v_100_drvdata,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, exynos_gsc_match);\n\nstatic int gsc_probe(struct platform_device *pdev)\n{\n\tstruct gsc_dev *gsc;\n\tstruct device *dev = &pdev->dev;\n\tconst struct gsc_driverdata *drv_data = of_device_get_match_data(dev);\n\tint irq;\n\tint ret;\n\tint i;\n\n\tgsc = devm_kzalloc(dev, sizeof(struct gsc_dev), GFP_KERNEL);\n\tif (!gsc)\n\t\treturn -ENOMEM;\n\n\tret = of_alias_get_id(pdev->dev.of_node, \"gsc\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (drv_data == &gsc_v_100_drvdata)\n\t\tdev_info(dev, \"compatible 'exynos5-gsc' is deprecated\\n\");\n\n\tgsc->id = ret;\n\tif (gsc->id >= drv_data->num_entities) {\n\t\tdev_err(dev, \"Invalid platform device id: %d\\n\", gsc->id);\n\t\treturn -EINVAL;\n\t}\n\n\tgsc->num_clocks = drv_data->num_clocks;\n\tgsc->variant = drv_data->variant[gsc->id];\n\tgsc->pdev = pdev;\n\n\tinit_waitqueue_head(&gsc->irq_queue);\n\tspin_lock_init(&gsc->slock);\n\tmutex_init(&gsc->lock);\n\n\tgsc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gsc->regs))\n\t\treturn PTR_ERR(gsc->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tfor (i = 0; i < gsc->num_clocks; i++) {\n\t\tgsc->clock[i] = devm_clk_get(dev, drv_data->clk_names[i]);\n\t\tif (IS_ERR(gsc->clock[i])) {\n\t\t\tdev_err(dev, \"failed to get clock: %s\\n\",\n\t\t\t\tdrv_data->clk_names[i]);\n\t\t\treturn PTR_ERR(gsc->clock[i]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < gsc->num_clocks; i++) {\n\t\tret = clk_prepare_enable(gsc->clock[i]);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"clock prepare failed for clock: %s\\n\",\n\t\t\t\tdrv_data->clk_names[i]);\n\t\t\twhile (--i >= 0)\n\t\t\t\tclk_disable_unprepare(gsc->clock[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_request_irq(dev, irq, gsc_irq_handler,\n\t\t\t       0, pdev->name, gsc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to install irq (%d)\\n\", ret);\n\t\tgoto err_clk;\n\t}\n\n\tret = v4l2_device_register(dev, &gsc->v4l2_dev);\n\tif (ret)\n\t\tgoto err_clk;\n\n\tret = gsc_register_m2m_device(gsc);\n\tif (ret)\n\t\tgoto err_v4l2;\n\n\tplatform_set_drvdata(pdev, gsc);\n\n\tgsc_hw_set_sw_reset(gsc);\n\tgsc_wait_reset(gsc);\n\n\tvb2_dma_contig_set_max_seg_size(dev, DMA_BIT_MASK(32));\n\n\tdev_dbg(dev, \"gsc-%d registered successfully\\n\", gsc->id);\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nerr_v4l2:\n\tv4l2_device_unregister(&gsc->v4l2_dev);\nerr_clk:\n\tfor (i = gsc->num_clocks - 1; i >= 0; i--)\n\t\tclk_disable_unprepare(gsc->clock[i]);\n\treturn ret;\n}\n\nstatic void gsc_remove(struct platform_device *pdev)\n{\n\tstruct gsc_dev *gsc = platform_get_drvdata(pdev);\n\tint i;\n\n\tgsc_unregister_m2m_device(gsc);\n\tv4l2_device_unregister(&gsc->v4l2_dev);\n\n\tvb2_dma_contig_clear_max_seg_size(&pdev->dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\tfor (i = 0; i < gsc->num_clocks; i++)\n\t\t\tclk_disable_unprepare(gsc->clock[i]);\n\n\tpm_runtime_set_suspended(&pdev->dev);\n\n\tdev_dbg(&pdev->dev, \"%s driver unloaded\\n\", pdev->name);\n}\n\n#ifdef CONFIG_PM\nstatic int gsc_m2m_suspend(struct gsc_dev *gsc)\n{\n\tunsigned long flags;\n\tint timeout;\n\n\tspin_lock_irqsave(&gsc->slock, flags);\n\tif (!gsc_m2m_pending(gsc)) {\n\t\tspin_unlock_irqrestore(&gsc->slock, flags);\n\t\treturn 0;\n\t}\n\tclear_bit(ST_M2M_SUSPENDED, &gsc->state);\n\tset_bit(ST_M2M_SUSPENDING, &gsc->state);\n\tspin_unlock_irqrestore(&gsc->slock, flags);\n\n\ttimeout = wait_event_timeout(gsc->irq_queue,\n\t\t\t     test_bit(ST_M2M_SUSPENDED, &gsc->state),\n\t\t\t     GSC_SHUTDOWN_TIMEOUT);\n\n\tclear_bit(ST_M2M_SUSPENDING, &gsc->state);\n\treturn timeout == 0 ? -EAGAIN : 0;\n}\n\nstatic void gsc_m2m_resume(struct gsc_dev *gsc)\n{\n\tstruct gsc_ctx *ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsc->slock, flags);\n\t \n\tctx = gsc->m2m.ctx;\n\tgsc->m2m.ctx = NULL;\n\tspin_unlock_irqrestore(&gsc->slock, flags);\n\n\tif (test_and_clear_bit(ST_M2M_SUSPENDED, &gsc->state))\n\t\tgsc_m2m_job_finish(ctx, VB2_BUF_STATE_ERROR);\n}\n\nstatic int gsc_runtime_resume(struct device *dev)\n{\n\tstruct gsc_dev *gsc = dev_get_drvdata(dev);\n\tint ret = 0;\n\tint i;\n\n\tpr_debug(\"gsc%d: state: 0x%lx\\n\", gsc->id, gsc->state);\n\n\tfor (i = 0; i < gsc->num_clocks; i++) {\n\t\tret = clk_prepare_enable(gsc->clock[i]);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tclk_disable_unprepare(gsc->clock[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tgsc_hw_set_sw_reset(gsc);\n\tgsc_wait_reset(gsc);\n\tgsc_m2m_resume(gsc);\n\n\treturn 0;\n}\n\nstatic int gsc_runtime_suspend(struct device *dev)\n{\n\tstruct gsc_dev *gsc = dev_get_drvdata(dev);\n\tint ret = 0;\n\tint i;\n\n\tret = gsc_m2m_suspend(gsc);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = gsc->num_clocks - 1; i >= 0; i--)\n\t\tclk_disable_unprepare(gsc->clock[i]);\n\n\tpr_debug(\"gsc%d: state: 0x%lx\\n\", gsc->id, gsc->state);\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops gsc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(gsc_runtime_suspend, gsc_runtime_resume, NULL)\n};\n\nstatic struct platform_driver gsc_driver = {\n\t.probe\t\t= gsc_probe,\n\t.remove_new\t= gsc_remove,\n\t.driver = {\n\t\t.name\t= GSC_MODULE_NAME,\n\t\t.pm\t= &gsc_pm_ops,\n\t\t.of_match_table = exynos_gsc_match,\n\t}\n};\n\nmodule_platform_driver(gsc_driver);\n\nMODULE_AUTHOR(\"Hyunwong Kim <khw0178.kim@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung EXYNOS5 Soc series G-Scaler driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}