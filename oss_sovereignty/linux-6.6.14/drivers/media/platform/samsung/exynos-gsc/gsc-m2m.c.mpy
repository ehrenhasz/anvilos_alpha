{
  "module_name": "gsc-m2m.c",
  "hash_id": "02841c62978cd1affb94d68a352c5feef309d36765b97124009bcf7c2dd6ebcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos-gsc/gsc-m2m.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/bug.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n\n#include <media/v4l2-ioctl.h>\n\n#include \"gsc-core.h\"\n\nstatic int gsc_m2m_ctx_stop_req(struct gsc_ctx *ctx)\n{\n\tstruct gsc_ctx *curr_ctx;\n\tstruct gsc_dev *gsc = ctx->gsc_dev;\n\tint ret;\n\n\tcurr_ctx = v4l2_m2m_get_curr_priv(gsc->m2m.m2m_dev);\n\tif (!gsc_m2m_pending(gsc) || (curr_ctx != ctx))\n\t\treturn 0;\n\n\tgsc_ctx_state_lock_set(GSC_CTX_STOP_REQ, ctx);\n\tret = wait_event_timeout(gsc->irq_queue,\n\t\t\t!gsc_ctx_state_is_set(GSC_CTX_STOP_REQ, ctx),\n\t\t\tGSC_SHUTDOWN_TIMEOUT);\n\n\treturn ret == 0 ? -ETIMEDOUT : ret;\n}\n\nstatic void __gsc_m2m_job_abort(struct gsc_ctx *ctx)\n{\n\tint ret;\n\n\tret = gsc_m2m_ctx_stop_req(ctx);\n\tif ((ret == -ETIMEDOUT) || (ctx->state & GSC_CTX_ABORT)) {\n\t\tgsc_ctx_state_lock_clear(GSC_CTX_STOP_REQ | GSC_CTX_ABORT, ctx);\n\t\tgsc_m2m_job_finish(ctx, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic int gsc_m2m_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct gsc_ctx *ctx = q->drv_priv;\n\n\treturn pm_runtime_resume_and_get(&ctx->gsc_dev->pdev->dev);\n}\n\nstatic void __gsc_m2m_cleanup_queue(struct gsc_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\n\twhile (v4l2_m2m_num_src_bufs_ready(ctx->m2m_ctx) > 0) {\n\t\tsrc_vb = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\t\tv4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_ERROR);\n\t}\n\n\twhile (v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx) > 0) {\n\t\tdst_vb = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\n\t\tv4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic void gsc_m2m_stop_streaming(struct vb2_queue *q)\n{\n\tstruct gsc_ctx *ctx = q->drv_priv;\n\n\t__gsc_m2m_job_abort(ctx);\n\n\t__gsc_m2m_cleanup_queue(ctx);\n\n\tpm_runtime_put(&ctx->gsc_dev->pdev->dev);\n}\n\nvoid gsc_m2m_job_finish(struct gsc_ctx *ctx, int vb_state)\n{\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\n\tif (!ctx || !ctx->m2m_ctx)\n\t\treturn;\n\n\tsrc_vb = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\tdst_vb = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\n\n\tif (src_vb && dst_vb) {\n\t\tdst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;\n\t\tdst_vb->timecode = src_vb->timecode;\n\t\tdst_vb->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\t\tdst_vb->flags |=\n\t\t\tsrc_vb->flags\n\t\t\t& V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\t\tv4l2_m2m_buf_done(src_vb, vb_state);\n\t\tv4l2_m2m_buf_done(dst_vb, vb_state);\n\n\t\tv4l2_m2m_job_finish(ctx->gsc_dev->m2m.m2m_dev,\n\t\t\t\t    ctx->m2m_ctx);\n\t}\n}\n\nstatic void gsc_m2m_job_abort(void *priv)\n{\n\t__gsc_m2m_job_abort((struct gsc_ctx *)priv);\n}\n\nstatic int gsc_get_bufs(struct gsc_ctx *ctx)\n{\n\tstruct gsc_frame *s_frame, *d_frame;\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\tint ret;\n\n\ts_frame = &ctx->s_frame;\n\td_frame = &ctx->d_frame;\n\n\tsrc_vb = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\n\tret = gsc_prepare_addr(ctx, &src_vb->vb2_buf, s_frame, &s_frame->addr);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vb = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\n\tret = gsc_prepare_addr(ctx, &dst_vb->vb2_buf, d_frame, &d_frame->addr);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;\n\n\treturn 0;\n}\n\nstatic void gsc_m2m_device_run(void *priv)\n{\n\tstruct gsc_ctx *ctx = priv;\n\tstruct gsc_dev *gsc;\n\tunsigned long flags;\n\tint ret;\n\tbool is_set = false;\n\n\tif (WARN(!ctx, \"null hardware context\\n\"))\n\t\treturn;\n\n\tgsc = ctx->gsc_dev;\n\tspin_lock_irqsave(&gsc->slock, flags);\n\n\tset_bit(ST_M2M_PEND, &gsc->state);\n\n\t \n\tif (gsc->m2m.ctx != ctx) {\n\t\tpr_debug(\"gsc->m2m.ctx = 0x%p, current_ctx = 0x%p\",\n\t\t\t\tgsc->m2m.ctx, ctx);\n\t\tctx->state |= GSC_PARAMS;\n\t\tgsc->m2m.ctx = ctx;\n\t}\n\n\tis_set = ctx->state & GSC_CTX_STOP_REQ;\n\tif (is_set) {\n\t\tctx->state &= ~GSC_CTX_STOP_REQ;\n\t\tctx->state |= GSC_CTX_ABORT;\n\t\twake_up(&gsc->irq_queue);\n\t\tgoto put_device;\n\t}\n\n\tret = gsc_get_bufs(ctx);\n\tif (ret) {\n\t\tpr_err(\"Wrong address\");\n\t\tgoto put_device;\n\t}\n\n\tgsc_set_prefbuf(gsc, &ctx->s_frame);\n\tgsc_hw_set_input_addr(gsc, &ctx->s_frame.addr, GSC_M2M_BUF_NUM);\n\tgsc_hw_set_output_addr(gsc, &ctx->d_frame.addr, GSC_M2M_BUF_NUM);\n\n\tif (ctx->state & GSC_PARAMS) {\n\t\tgsc_hw_set_input_buf_masking(gsc, GSC_M2M_BUF_NUM, false);\n\t\tgsc_hw_set_output_buf_masking(gsc, GSC_M2M_BUF_NUM, false);\n\t\tgsc_hw_set_frm_done_irq_mask(gsc, false);\n\t\tgsc_hw_set_gsc_irq_enable(gsc, true);\n\n\t\tif (gsc_set_scaler_info(ctx)) {\n\t\t\tpr_err(\"Scaler setup error\");\n\t\t\tgoto put_device;\n\t\t}\n\n\t\tgsc_hw_set_input_path(ctx);\n\t\tgsc_hw_set_in_size(ctx);\n\t\tgsc_hw_set_in_image_format(ctx);\n\n\t\tgsc_hw_set_output_path(ctx);\n\t\tgsc_hw_set_out_size(ctx);\n\t\tgsc_hw_set_out_image_format(ctx);\n\n\t\tgsc_hw_set_prescaler(ctx);\n\t\tgsc_hw_set_mainscaler(ctx);\n\t\tgsc_hw_set_rotation(ctx);\n\t\tgsc_hw_set_global_alpha(ctx);\n\t}\n\n\t \n\tgsc_hw_set_sfr_update(ctx);\n\n\tctx->state &= ~GSC_PARAMS;\n\tgsc_hw_enable_control(gsc, true);\n\n\tspin_unlock_irqrestore(&gsc->slock, flags);\n\treturn;\n\nput_device:\n\tctx->state &= ~GSC_PARAMS;\n\tspin_unlock_irqrestore(&gsc->slock, flags);\n}\n\nstatic int gsc_m2m_queue_setup(struct vb2_queue *vq,\n\t\t\tunsigned int *num_buffers, unsigned int *num_planes,\n\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct gsc_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct gsc_frame *frame;\n\tint i;\n\n\tframe = ctx_get_frame(ctx, vq->type);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\tif (!frame->fmt)\n\t\treturn -EINVAL;\n\n\t*num_planes = frame->fmt->num_planes;\n\tfor (i = 0; i < frame->fmt->num_planes; i++)\n\t\tsizes[i] = frame->payload[i];\n\treturn 0;\n}\n\nstatic int gsc_m2m_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct gsc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct gsc_frame *frame;\n\tint i;\n\n\tframe = ctx_get_frame(ctx, vb->vb2_queue->type);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\tif (V4L2_TYPE_IS_CAPTURE(vb->vb2_queue->type)) {\n\t\tfor (i = 0; i < frame->fmt->num_planes; i++)\n\t\t\tvb2_set_plane_payload(vb, i, frame->payload[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic void gsc_m2m_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct gsc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tpr_debug(\"ctx: %p, ctx->state: 0x%x\", ctx, ctx->state);\n\n\tif (ctx->m2m_ctx)\n\t\tv4l2_m2m_buf_queue(ctx->m2m_ctx, vbuf);\n}\n\nstatic const struct vb2_ops gsc_m2m_qops = {\n\t.queue_setup\t = gsc_m2m_queue_setup,\n\t.buf_prepare\t = gsc_m2m_buf_prepare,\n\t.buf_queue\t = gsc_m2m_buf_queue,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n\t.stop_streaming\t = gsc_m2m_stop_streaming,\n\t.start_streaming = gsc_m2m_start_streaming,\n};\n\nstatic int gsc_m2m_querycap(struct file *file, void *fh,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, GSC_MODULE_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, GSC_MODULE_NAME \" gscaler\", sizeof(cap->card));\n\treturn 0;\n}\n\nstatic int gsc_m2m_enum_fmt(struct file *file, void *priv,\n\t\t\t    struct v4l2_fmtdesc *f)\n{\n\treturn gsc_enum_fmt(f);\n}\n\nstatic int gsc_m2m_g_fmt_mplane(struct file *file, void *fh,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(fh);\n\n\treturn gsc_g_fmt_mplane(ctx, f);\n}\n\nstatic int gsc_m2m_try_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(fh);\n\n\treturn gsc_try_fmt_mplane(ctx, f);\n}\n\nstatic int gsc_m2m_s_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(fh);\n\tstruct vb2_queue *vq;\n\tstruct gsc_frame *frame;\n\tstruct v4l2_pix_format_mplane *pix;\n\tint i, ret = 0;\n\n\tret = gsc_m2m_try_fmt_mplane(file, fh, f);\n\tif (ret)\n\t\treturn ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\n\n\tif (vb2_is_streaming(vq)) {\n\t\tpr_err(\"queue (%d) busy\", f->type);\n\t\treturn -EBUSY;\n\t}\n\n\tif (V4L2_TYPE_IS_OUTPUT(f->type))\n\t\tframe = &ctx->s_frame;\n\telse\n\t\tframe = &ctx->d_frame;\n\n\tpix = &f->fmt.pix_mp;\n\tframe->fmt = find_fmt(&pix->pixelformat, NULL, 0);\n\tframe->colorspace = pix->colorspace;\n\tif (!frame->fmt)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < frame->fmt->num_planes; i++)\n\t\tframe->payload[i] = pix->plane_fmt[i].sizeimage;\n\n\tgsc_set_frame_size(frame, pix->width, pix->height);\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tgsc_ctx_state_lock_set(GSC_PARAMS | GSC_DST_FMT, ctx);\n\telse\n\t\tgsc_ctx_state_lock_set(GSC_PARAMS | GSC_SRC_FMT, ctx);\n\n\tpr_debug(\"f_w: %d, f_h: %d\", frame->f_width, frame->f_height);\n\n\treturn 0;\n}\n\nstatic int gsc_m2m_reqbufs(struct file *file, void *fh,\n\t\t\t  struct v4l2_requestbuffers *reqbufs)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(fh);\n\tstruct gsc_dev *gsc = ctx->gsc_dev;\n\tu32 max_cnt;\n\n\tmax_cnt = (reqbufs->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) ?\n\t\tgsc->variant->in_buf_cnt : gsc->variant->out_buf_cnt;\n\tif (reqbufs->count > max_cnt)\n\t\treturn -EINVAL;\n\n\treturn v4l2_m2m_reqbufs(file, ctx->m2m_ctx, reqbufs);\n}\n\nstatic int gsc_m2m_expbuf(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_exportbuffer *eb)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(fh);\n\treturn v4l2_m2m_expbuf(file, ctx->m2m_ctx, eb);\n}\n\nstatic int gsc_m2m_querybuf(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_buffer *buf)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(fh);\n\treturn v4l2_m2m_querybuf(file, ctx->m2m_ctx, buf);\n}\n\nstatic int gsc_m2m_qbuf(struct file *file, void *fh,\n\t\t\t  struct v4l2_buffer *buf)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(fh);\n\treturn v4l2_m2m_qbuf(file, ctx->m2m_ctx, buf);\n}\n\nstatic int gsc_m2m_dqbuf(struct file *file, void *fh,\n\t\t\t   struct v4l2_buffer *buf)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(fh);\n\treturn v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);\n}\n\nstatic int gsc_m2m_streamon(struct file *file, void *fh,\n\t\t\t   enum v4l2_buf_type type)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(fh);\n\n\t \n\tif (V4L2_TYPE_IS_OUTPUT(type)) {\n\t\tif (!gsc_ctx_state_is_set(GSC_SRC_FMT, ctx))\n\t\t\treturn -EINVAL;\n\t} else if (!gsc_ctx_state_is_set(GSC_DST_FMT, ctx)) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn v4l2_m2m_streamon(file, ctx->m2m_ctx, type);\n}\n\nstatic int gsc_m2m_streamoff(struct file *file, void *fh,\n\t\t\t    enum v4l2_buf_type type)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(fh);\n\treturn v4l2_m2m_streamoff(file, ctx->m2m_ctx, type);\n}\n\n \nstatic int is_rectangle_enclosed(struct v4l2_rect *a, struct v4l2_rect *b)\n{\n\tif (a->left < b->left || a->top < b->top)\n\t\treturn 0;\n\n\tif (a->left + a->width > b->left + b->width)\n\t\treturn 0;\n\n\tif (a->top + a->height > b->top + b->height)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int gsc_m2m_g_selection(struct file *file, void *fh,\n\t\t\tstruct v4l2_selection *s)\n{\n\tstruct gsc_frame *frame;\n\tstruct gsc_ctx *ctx = fh_to_ctx(fh);\n\n\tif ((s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\n\t    (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT))\n\t\treturn -EINVAL;\n\n\tframe = ctx_get_frame(ctx, s->type);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = frame->f_width;\n\t\ts->r.height = frame->f_height;\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_CROP:\n\t\ts->r.left = frame->crop.left;\n\t\ts->r.top = frame->crop.top;\n\t\ts->r.width = frame->crop.width;\n\t\ts->r.height = frame->crop.height;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int gsc_m2m_s_selection(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_selection *s)\n{\n\tstruct gsc_frame *frame;\n\tstruct gsc_ctx *ctx = fh_to_ctx(fh);\n\tstruct gsc_variant *variant = ctx->gsc_dev->variant;\n\tstruct v4l2_selection sel = *s;\n\tint ret;\n\n\tif ((s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\n\t    (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT))\n\t\treturn -EINVAL;\n\n\tret = gsc_try_selection(ctx, &sel);\n\tif (ret)\n\t\treturn ret;\n\n\tif (s->flags & V4L2_SEL_FLAG_LE &&\n\t    !is_rectangle_enclosed(&sel.r, &s->r))\n\t\treturn -ERANGE;\n\n\tif (s->flags & V4L2_SEL_FLAG_GE &&\n\t    !is_rectangle_enclosed(&s->r, &sel.r))\n\t\treturn -ERANGE;\n\n\ts->r = sel.r;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tframe = &ctx->s_frame;\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\tframe = &ctx->d_frame;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (gsc_ctx_state_is_set(GSC_DST_FMT | GSC_SRC_FMT, ctx)) {\n\t\tif (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\t\tret = gsc_check_scaler_ratio(variant, sel.r.width,\n\t\t\t\tsel.r.height, ctx->d_frame.crop.width,\n\t\t\t\tctx->d_frame.crop.height,\n\t\t\t\tctx->gsc_ctrls.rotate->val, ctx->out_path);\n\t\t} else {\n\t\t\tret = gsc_check_scaler_ratio(variant,\n\t\t\t\tctx->s_frame.crop.width,\n\t\t\t\tctx->s_frame.crop.height, sel.r.width,\n\t\t\t\tsel.r.height, ctx->gsc_ctrls.rotate->val,\n\t\t\t\tctx->out_path);\n\t\t}\n\n\t\tif (ret) {\n\t\t\tpr_err(\"Out of scaler range\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tframe->crop = sel.r;\n\n\tgsc_ctx_state_lock_set(GSC_PARAMS, ctx);\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops gsc_m2m_ioctl_ops = {\n\t.vidioc_querycap\t\t= gsc_m2m_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= gsc_m2m_enum_fmt,\n\t.vidioc_enum_fmt_vid_out\t= gsc_m2m_enum_fmt,\n\t.vidioc_g_fmt_vid_cap_mplane\t= gsc_m2m_g_fmt_mplane,\n\t.vidioc_g_fmt_vid_out_mplane\t= gsc_m2m_g_fmt_mplane,\n\t.vidioc_try_fmt_vid_cap_mplane\t= gsc_m2m_try_fmt_mplane,\n\t.vidioc_try_fmt_vid_out_mplane\t= gsc_m2m_try_fmt_mplane,\n\t.vidioc_s_fmt_vid_cap_mplane\t= gsc_m2m_s_fmt_mplane,\n\t.vidioc_s_fmt_vid_out_mplane\t= gsc_m2m_s_fmt_mplane,\n\t.vidioc_reqbufs\t\t\t= gsc_m2m_reqbufs,\n\t.vidioc_expbuf                  = gsc_m2m_expbuf,\n\t.vidioc_querybuf\t\t= gsc_m2m_querybuf,\n\t.vidioc_qbuf\t\t\t= gsc_m2m_qbuf,\n\t.vidioc_dqbuf\t\t\t= gsc_m2m_dqbuf,\n\t.vidioc_streamon\t\t= gsc_m2m_streamon,\n\t.vidioc_streamoff\t\t= gsc_m2m_streamoff,\n\t.vidioc_g_selection\t\t= gsc_m2m_g_selection,\n\t.vidioc_s_selection\t\t= gsc_m2m_s_selection\n};\n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\tstruct vb2_queue *dst_vq)\n{\n\tstruct gsc_ctx *ctx = priv;\n\tint ret;\n\n\tmemset(src_vq, 0, sizeof(*src_vq));\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->ops = &gsc_m2m_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->gsc_dev->lock;\n\tsrc_vq->dev = &ctx->gsc_dev->pdev->dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(dst_vq, 0, sizeof(*dst_vq));\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->ops = &gsc_m2m_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->gsc_dev->lock;\n\tdst_vq->dev = &ctx->gsc_dev->pdev->dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int gsc_m2m_open(struct file *file)\n{\n\tstruct gsc_dev *gsc = video_drvdata(file);\n\tstruct gsc_ctx *ctx = NULL;\n\tint ret;\n\n\tpr_debug(\"pid: %d, state: 0x%lx\", task_pid_nr(current), gsc->state);\n\n\tif (mutex_lock_interruptible(&gsc->lock))\n\t\treturn -ERESTARTSYS;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tv4l2_fh_init(&ctx->fh, gsc->m2m.vfd);\n\tret = gsc_ctrls_create(ctx);\n\tif (ret)\n\t\tgoto error_fh;\n\n\t \n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\tctx->gsc_dev = gsc;\n\t \n\tctx->s_frame.fmt = get_format(0);\n\tctx->d_frame.fmt = get_format(0);\n\t \n\tctx->state = GSC_CTX_M2M;\n\tctx->flags = 0;\n\tctx->in_path = GSC_DMA;\n\tctx->out_path = GSC_DMA;\n\n\tctx->m2m_ctx = v4l2_m2m_ctx_init(gsc->m2m.m2m_dev, ctx, queue_init);\n\tif (IS_ERR(ctx->m2m_ctx)) {\n\t\tpr_err(\"Failed to initialize m2m context\");\n\t\tret = PTR_ERR(ctx->m2m_ctx);\n\t\tgoto error_ctrls;\n\t}\n\n\tif (gsc->m2m.refcnt++ == 0)\n\t\tset_bit(ST_M2M_OPEN, &gsc->state);\n\n\tpr_debug(\"gsc m2m driver is opened, ctx(0x%p)\", ctx);\n\n\tmutex_unlock(&gsc->lock);\n\treturn 0;\n\nerror_ctrls:\n\tgsc_ctrls_delete(ctx);\n\tv4l2_fh_del(&ctx->fh);\nerror_fh:\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\nunlock:\n\tmutex_unlock(&gsc->lock);\n\treturn ret;\n}\n\nstatic int gsc_m2m_release(struct file *file)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct gsc_dev *gsc = ctx->gsc_dev;\n\n\tpr_debug(\"pid: %d, state: 0x%lx, refcnt= %d\",\n\t\ttask_pid_nr(current), gsc->state, gsc->m2m.refcnt);\n\n\tmutex_lock(&gsc->lock);\n\n\tv4l2_m2m_ctx_release(ctx->m2m_ctx);\n\tgsc_ctrls_delete(ctx);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\n\tif (--gsc->m2m.refcnt <= 0)\n\t\tclear_bit(ST_M2M_OPEN, &gsc->state);\n\tkfree(ctx);\n\n\tmutex_unlock(&gsc->lock);\n\treturn 0;\n}\n\nstatic __poll_t gsc_m2m_poll(struct file *file,\n\t\t\t\t\tstruct poll_table_struct *wait)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct gsc_dev *gsc = ctx->gsc_dev;\n\t__poll_t ret;\n\n\tif (mutex_lock_interruptible(&gsc->lock))\n\t\treturn EPOLLERR;\n\n\tret = v4l2_m2m_poll(file, ctx->m2m_ctx, wait);\n\tmutex_unlock(&gsc->lock);\n\n\treturn ret;\n}\n\nstatic int gsc_m2m_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct gsc_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct gsc_dev *gsc = ctx->gsc_dev;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&gsc->lock))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_m2m_mmap(file, ctx->m2m_ctx, vma);\n\tmutex_unlock(&gsc->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_file_operations gsc_m2m_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= gsc_m2m_open,\n\t.release\t= gsc_m2m_release,\n\t.poll\t\t= gsc_m2m_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= gsc_m2m_mmap,\n};\n\nstatic const struct v4l2_m2m_ops gsc_m2m_ops = {\n\t.device_run\t= gsc_m2m_device_run,\n\t.job_abort\t= gsc_m2m_job_abort,\n};\n\nint gsc_register_m2m_device(struct gsc_dev *gsc)\n{\n\tstruct platform_device *pdev;\n\tint ret;\n\n\tif (!gsc)\n\t\treturn -ENODEV;\n\n\tpdev = gsc->pdev;\n\n\tgsc->vdev.fops\t\t= &gsc_m2m_fops;\n\tgsc->vdev.ioctl_ops\t= &gsc_m2m_ioctl_ops;\n\tgsc->vdev.release\t= video_device_release_empty;\n\tgsc->vdev.lock\t\t= &gsc->lock;\n\tgsc->vdev.vfl_dir\t= VFL_DIR_M2M;\n\tgsc->vdev.v4l2_dev\t= &gsc->v4l2_dev;\n\tgsc->vdev.device_caps\t= V4L2_CAP_STREAMING |\n\t\t\t\t  V4L2_CAP_VIDEO_M2M_MPLANE;\n\tsnprintf(gsc->vdev.name, sizeof(gsc->vdev.name), \"%s.%d:m2m\",\n\t\t\t\t\tGSC_MODULE_NAME, gsc->id);\n\n\tvideo_set_drvdata(&gsc->vdev, gsc);\n\n\tgsc->m2m.vfd = &gsc->vdev;\n\tgsc->m2m.m2m_dev = v4l2_m2m_init(&gsc_m2m_ops);\n\tif (IS_ERR(gsc->m2m.m2m_dev)) {\n\t\tdev_err(&pdev->dev, \"failed to initialize v4l2-m2m device\\n\");\n\t\treturn PTR_ERR(gsc->m2m.m2m_dev);\n\t}\n\n\tret = video_register_device(&gsc->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t \"%s(): failed to register video device\\n\", __func__);\n\t\tgoto err_m2m_release;\n\t}\n\n\tpr_debug(\"gsc m2m driver registered as /dev/video%d\", gsc->vdev.num);\n\treturn 0;\n\nerr_m2m_release:\n\tv4l2_m2m_release(gsc->m2m.m2m_dev);\n\n\treturn ret;\n}\n\nvoid gsc_unregister_m2m_device(struct gsc_dev *gsc)\n{\n\tif (gsc) {\n\t\tv4l2_m2m_release(gsc->m2m.m2m_dev);\n\t\tvideo_unregister_device(&gsc->vdev);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}