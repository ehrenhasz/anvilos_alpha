{
  "module_name": "gsc-core.h",
  "hash_id": "eb00fcbd09e878d0d246ec1a672ffda0d94144ab163094a05a8761fc7fdf67ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos-gsc/gsc-core.h",
  "human_readable_source": " \n \n\n#ifndef GSC_CORE_H_\n#define GSC_CORE_H_\n\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n#include <linux/io.h>\n#include <linux/pm_runtime.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-mediabus.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"gsc-regs.h\"\n\n#define CONFIG_VB2_GSC_DMA_CONTIG\t1\n#define GSC_MODULE_NAME\t\t\t\"exynos-gsc\"\n\n#define GSC_SHUTDOWN_TIMEOUT\t\t((100*HZ)/1000)\n#define GSC_MAX_DEVS\t\t\t4\n#define GSC_MAX_CLOCKS\t\t\t4\n#define GSC_M2M_BUF_NUM\t\t\t0\n#define GSC_MAX_CTRL_NUM\t\t10\n#define GSC_SC_ALIGN_4\t\t\t4\n#define GSC_SC_ALIGN_2\t\t\t2\n#define DEFAULT_CSC_EQ\t\t\t1\n#define DEFAULT_CSC_RANGE\t\t1\n\n#define GSC_PARAMS\t\t\t(1 << 0)\n#define GSC_SRC_FMT\t\t\t(1 << 1)\n#define GSC_DST_FMT\t\t\t(1 << 2)\n#define GSC_CTX_M2M\t\t\t(1 << 3)\n#define GSC_CTX_STOP_REQ\t\t(1 << 6)\n#define\tGSC_CTX_ABORT\t\t\t(1 << 7)\n\nenum gsc_dev_flags {\n\t \n\tST_M2M_OPEN,\n\tST_M2M_RUN,\n\tST_M2M_PEND,\n\tST_M2M_SUSPENDED,\n\tST_M2M_SUSPENDING,\n};\n\nenum gsc_irq {\n\tGSC_IRQ_DONE,\n\tGSC_IRQ_OVERRUN\n};\n\n \nenum gsc_datapath {\n\tGSC_CAMERA = 0x1,\n\tGSC_DMA,\n\tGSC_WRITEBACK,\n};\n\nenum gsc_color_fmt {\n\tGSC_RGB = 0x1,\n\tGSC_YUV420 = 0x2,\n\tGSC_YUV422 = 0x4,\n\tGSC_YUV444 = 0x8,\n};\n\nenum gsc_yuv_fmt {\n\tGSC_LSB_Y = 0x10,\n\tGSC_LSB_C,\n\tGSC_CBCR = 0x20,\n\tGSC_CRCB,\n};\n\n#define fh_to_ctx(__fh) container_of(__fh, struct gsc_ctx, fh)\n#define is_rgb(x) (!!((x) & 0x1))\n#define is_yuv420(x) (!!((x) & 0x2))\n#define is_yuv422(x) (!!((x) & 0x4))\n\n#define gsc_m2m_active(dev)\ttest_bit(ST_M2M_RUN, &(dev)->state)\n#define gsc_m2m_pending(dev)\ttest_bit(ST_M2M_PEND, &(dev)->state)\n#define gsc_m2m_opened(dev)\ttest_bit(ST_M2M_OPEN, &(dev)->state)\n\n#define ctrl_to_ctx(__ctrl) \\\n\tcontainer_of((__ctrl)->handler, struct gsc_ctx, ctrl_handler)\n \nstruct gsc_fmt {\n\tu32 mbus_code;\n\tu32\tpixelformat;\n\tu32\tcolor;\n\tu32\tyorder;\n\tu32\tcorder;\n\tu16\tnum_planes;\n\tu16\tnum_comp;\n\tu8\tdepth[VIDEO_MAX_PLANES];\n\tu32\tflags;\n};\n\n \nstruct gsc_input_buf {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head\tlist;\n\tint\t\t\tidx;\n};\n\n \nstruct gsc_addr {\n\tdma_addr_t y;\n\tdma_addr_t cb;\n\tdma_addr_t cr;\n};\n\n \nstruct gsc_ctrls {\n\tstruct v4l2_ctrl *rotate;\n\tstruct v4l2_ctrl *hflip;\n\tstruct v4l2_ctrl *vflip;\n\tstruct v4l2_ctrl *global_alpha;\n};\n\n \nstruct gsc_scaler {\n\tu32 pre_shfactor;\n\tu32 pre_hratio;\n\tu32 pre_vratio;\n\tu32 main_hratio;\n\tu32 main_vratio;\n};\n\nstruct gsc_dev;\n\nstruct gsc_ctx;\n\n \nstruct gsc_frame {\n\tu32 f_width;\n\tu32 f_height;\n\tstruct v4l2_rect crop;\n\tunsigned long payload[VIDEO_MAX_PLANES];\n\tstruct gsc_addr\taddr;\n\tconst struct gsc_fmt *fmt;\n\tu32 colorspace;\n\tu8 alpha;\n};\n\n \nstruct gsc_m2m_device {\n\tstruct video_device\t*vfd;\n\tstruct v4l2_m2m_dev\t*m2m_dev;\n\tstruct gsc_ctx\t\t*ctx;\n\tint\t\t\trefcnt;\n};\n\n \nstruct gsc_pix_max {\n\tu16 org_scaler_bypass_w;\n\tu16 org_scaler_bypass_h;\n\tu16 org_scaler_input_w;\n\tu16 org_scaler_input_h;\n\tu16 real_rot_dis_w;\n\tu16 real_rot_dis_h;\n\tu16 real_rot_en_w;\n\tu16 real_rot_en_h;\n\tu16 target_rot_dis_w;\n\tu16 target_rot_dis_h;\n\tu16 target_rot_en_w;\n\tu16 target_rot_en_h;\n};\n\n \nstruct gsc_pix_min {\n\tu16 org_w;\n\tu16 org_h;\n\tu16 real_w;\n\tu16 real_h;\n\tu16 target_rot_dis_w;\n\tu16 target_rot_dis_h;\n\tu16 target_rot_en_w;\n\tu16 target_rot_en_h;\n};\n\nstruct gsc_pix_align {\n\tu16 org_h;\n\tu16 org_w;\n\tu16 offset_h;\n\tu16 real_w;\n\tu16 real_h;\n\tu16 target_w;\n\tu16 target_h;\n};\n\n \nstruct gsc_variant {\n\tstruct gsc_pix_max *pix_max;\n\tstruct gsc_pix_min *pix_min;\n\tstruct gsc_pix_align *pix_align;\n\tu16\t\tin_buf_cnt;\n\tu16\t\tout_buf_cnt;\n\tu16\t\tsc_up_max;\n\tu16\t\tsc_down_max;\n\tu16\t\tpoly_sc_down_max;\n\tu16\t\tpre_sc_down_max;\n\tu16\t\tlocal_sc_down;\n};\n\n \nstruct gsc_driverdata {\n\tstruct gsc_variant *variant[GSC_MAX_DEVS];\n\tconst char\t*clk_names[GSC_MAX_CLOCKS];\n\tint\t\tnum_clocks;\n\tint\t\tnum_entities;\n};\n\n \nstruct gsc_dev {\n\tspinlock_t\t\t\tslock;\n\tstruct mutex\t\t\tlock;\n\tstruct platform_device\t\t*pdev;\n\tstruct gsc_variant\t\t*variant;\n\tu16\t\t\t\tid;\n\tint\t\t\t\tnum_clocks;\n\tstruct clk\t\t\t*clock[GSC_MAX_CLOCKS];\n\tvoid __iomem\t\t\t*regs;\n\twait_queue_head_t\t\tirq_queue;\n\tstruct gsc_m2m_device\t\tm2m;\n\tunsigned long\t\t\tstate;\n\tstruct video_device\t\tvdev;\n\tstruct v4l2_device\t\tv4l2_dev;\n};\n\n \nstruct gsc_ctx {\n\tstruct gsc_frame\ts_frame;\n\tstruct gsc_frame\td_frame;\n\tenum gsc_datapath\tin_path;\n\tenum gsc_datapath\tout_path;\n\tstruct gsc_scaler\tscaler;\n\tu32\t\t\tflags;\n\tu32\t\t\tstate;\n\tint\t\t\trotation;\n\tunsigned int\t\thflip:1;\n\tunsigned int\t\tvflip:1;\n\tstruct gsc_dev\t\t*gsc_dev;\n\tstruct v4l2_m2m_ctx\t*m2m_ctx;\n\tstruct v4l2_fh\t\tfh;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct gsc_ctrls\tgsc_ctrls;\n\tbool\t\t\tctrls_rdy;\n\tenum v4l2_colorspace out_colorspace;\n};\n\nvoid gsc_set_prefbuf(struct gsc_dev *gsc, struct gsc_frame *frm);\nint gsc_register_m2m_device(struct gsc_dev *gsc);\nvoid gsc_unregister_m2m_device(struct gsc_dev *gsc);\nvoid gsc_m2m_job_finish(struct gsc_ctx *ctx, int vb_state);\n\nu32 get_plane_size(struct gsc_frame *fr, unsigned int plane);\nconst struct gsc_fmt *get_format(int index);\nconst struct gsc_fmt *find_fmt(u32 *pixelformat, u32 *mbus_code, u32 index);\nint gsc_enum_fmt(struct v4l2_fmtdesc *f);\nint gsc_try_fmt_mplane(struct gsc_ctx *ctx, struct v4l2_format *f);\nvoid gsc_set_frame_size(struct gsc_frame *frame, int width, int height);\nint gsc_g_fmt_mplane(struct gsc_ctx *ctx, struct v4l2_format *f);\nvoid gsc_check_crop_change(u32 tmp_w, u32 tmp_h, u32 *w, u32 *h);\nint gsc_try_selection(struct gsc_ctx *ctx, struct v4l2_selection *s);\nint gsc_cal_prescaler_ratio(struct gsc_variant *var, u32 src, u32 dst,\n\t\t\t\t\t\t\tu32 *ratio);\nvoid gsc_get_prescaler_shfactor(u32 hratio, u32 vratio, u32 *sh);\nvoid gsc_check_src_scale_info(struct gsc_variant *var,\n\t\t\t\tstruct gsc_frame *s_frame,\n\t\t\t\tu32 *wratio, u32 tx, u32 ty, u32 *hratio);\nint gsc_check_scaler_ratio(struct gsc_variant *var, int sw, int sh, int dw,\n\t\t\t   int dh, int rot, int out_path);\nint gsc_set_scaler_info(struct gsc_ctx *ctx);\nint gsc_ctrls_create(struct gsc_ctx *ctx);\nvoid gsc_ctrls_delete(struct gsc_ctx *ctx);\nint gsc_prepare_addr(struct gsc_ctx *ctx, struct vb2_buffer *vb,\n\t\t     struct gsc_frame *frame, struct gsc_addr *addr);\n\nstatic inline void gsc_ctx_state_lock_set(u32 state, struct gsc_ctx *ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->gsc_dev->slock, flags);\n\tctx->state |= state;\n\tspin_unlock_irqrestore(&ctx->gsc_dev->slock, flags);\n}\n\nstatic inline void gsc_ctx_state_lock_clear(u32 state, struct gsc_ctx *ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->gsc_dev->slock, flags);\n\tctx->state &= ~state;\n\tspin_unlock_irqrestore(&ctx->gsc_dev->slock, flags);\n}\n\nstatic inline int is_tiled(const struct gsc_fmt *fmt)\n{\n\treturn fmt->pixelformat == V4L2_PIX_FMT_NV12MT_16X16;\n}\n\nstatic inline void gsc_hw_enable_control(struct gsc_dev *dev, bool on)\n{\n\tu32 cfg = readl(dev->regs + GSC_ENABLE);\n\n\tif (on)\n\t\tcfg |= GSC_ENABLE_ON;\n\telse\n\t\tcfg &= ~GSC_ENABLE_ON;\n\n\twritel(cfg, dev->regs + GSC_ENABLE);\n}\n\nstatic inline int gsc_hw_get_irq_status(struct gsc_dev *dev)\n{\n\tu32 cfg = readl(dev->regs + GSC_IRQ);\n\tif (cfg & GSC_IRQ_STATUS_OR_IRQ)\n\t\treturn GSC_IRQ_OVERRUN;\n\telse\n\t\treturn GSC_IRQ_DONE;\n\n}\n\nstatic inline void gsc_hw_clear_irq(struct gsc_dev *dev, int irq)\n{\n\tu32 cfg = readl(dev->regs + GSC_IRQ);\n\tif (irq == GSC_IRQ_OVERRUN)\n\t\tcfg |= GSC_IRQ_STATUS_OR_IRQ;\n\telse if (irq == GSC_IRQ_DONE)\n\t\tcfg |= GSC_IRQ_STATUS_FRM_DONE_IRQ;\n\twritel(cfg, dev->regs + GSC_IRQ);\n}\n\nstatic inline bool gsc_ctx_state_is_set(u32 mask, struct gsc_ctx *ctx)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\tspin_lock_irqsave(&ctx->gsc_dev->slock, flags);\n\tret = (ctx->state & mask) == mask;\n\tspin_unlock_irqrestore(&ctx->gsc_dev->slock, flags);\n\treturn ret;\n}\n\nstatic inline struct gsc_frame *ctx_get_frame(struct gsc_ctx *ctx,\n\t\t\t\t\t      enum v4l2_buf_type type)\n{\n\tstruct gsc_frame *frame;\n\n\tif (V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE == type) {\n\t\tframe = &ctx->s_frame;\n\t} else if (V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE == type) {\n\t\tframe = &ctx->d_frame;\n\t} else {\n\t\tpr_err(\"Wrong buffer/video queue type (%d)\", type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn frame;\n}\n\nvoid gsc_hw_set_sw_reset(struct gsc_dev *dev);\nint gsc_wait_reset(struct gsc_dev *dev);\n\nvoid gsc_hw_set_frm_done_irq_mask(struct gsc_dev *dev, bool mask);\nvoid gsc_hw_set_gsc_irq_enable(struct gsc_dev *dev, bool mask);\nvoid gsc_hw_set_input_buf_masking(struct gsc_dev *dev, u32 shift, bool enable);\nvoid gsc_hw_set_output_buf_masking(struct gsc_dev *dev, u32 shift, bool enable);\nvoid gsc_hw_set_input_addr(struct gsc_dev *dev, struct gsc_addr *addr,\n\t\t\t\t\t\t\tint index);\nvoid gsc_hw_set_output_addr(struct gsc_dev *dev, struct gsc_addr *addr,\n\t\t\t\t\t\t\tint index);\nvoid gsc_hw_set_input_path(struct gsc_ctx *ctx);\nvoid gsc_hw_set_in_size(struct gsc_ctx *ctx);\nvoid gsc_hw_set_in_image_rgb(struct gsc_ctx *ctx);\nvoid gsc_hw_set_in_image_format(struct gsc_ctx *ctx);\nvoid gsc_hw_set_output_path(struct gsc_ctx *ctx);\nvoid gsc_hw_set_out_size(struct gsc_ctx *ctx);\nvoid gsc_hw_set_out_image_rgb(struct gsc_ctx *ctx);\nvoid gsc_hw_set_out_image_format(struct gsc_ctx *ctx);\nvoid gsc_hw_set_prescaler(struct gsc_ctx *ctx);\nvoid gsc_hw_set_mainscaler(struct gsc_ctx *ctx);\nvoid gsc_hw_set_rotation(struct gsc_ctx *ctx);\nvoid gsc_hw_set_global_alpha(struct gsc_ctx *ctx);\nvoid gsc_hw_set_sfr_update(struct gsc_ctx *ctx);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}