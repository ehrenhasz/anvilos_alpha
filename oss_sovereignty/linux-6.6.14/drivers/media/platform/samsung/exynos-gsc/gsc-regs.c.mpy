{
  "module_name": "gsc-regs.c",
  "hash_id": "6901c5b8cf342b5c1c41fe05ed5efc8f24f80471441246df5ef37a84a77c855a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos-gsc/gsc-regs.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n\n#include \"gsc-core.h\"\n\nvoid gsc_hw_set_sw_reset(struct gsc_dev *dev)\n{\n\twritel(GSC_SW_RESET_SRESET, dev->regs + GSC_SW_RESET);\n}\n\nint gsc_wait_reset(struct gsc_dev *dev)\n{\n\tunsigned long end = jiffies + msecs_to_jiffies(50);\n\tu32 cfg;\n\n\twhile (time_before(jiffies, end)) {\n\t\tcfg = readl(dev->regs + GSC_SW_RESET);\n\t\tif (!cfg)\n\t\t\treturn 0;\n\t\tusleep_range(10, 20);\n\t}\n\n\treturn -EBUSY;\n}\n\nvoid gsc_hw_set_frm_done_irq_mask(struct gsc_dev *dev, bool mask)\n{\n\tu32 cfg;\n\n\tcfg = readl(dev->regs + GSC_IRQ);\n\tif (mask)\n\t\tcfg |= GSC_IRQ_FRMDONE_MASK;\n\telse\n\t\tcfg &= ~GSC_IRQ_FRMDONE_MASK;\n\twritel(cfg, dev->regs + GSC_IRQ);\n}\n\nvoid gsc_hw_set_gsc_irq_enable(struct gsc_dev *dev, bool mask)\n{\n\tu32 cfg;\n\n\tcfg = readl(dev->regs + GSC_IRQ);\n\tif (mask)\n\t\tcfg |= GSC_IRQ_ENABLE;\n\telse\n\t\tcfg &= ~GSC_IRQ_ENABLE;\n\twritel(cfg, dev->regs + GSC_IRQ);\n}\n\nvoid gsc_hw_set_input_buf_masking(struct gsc_dev *dev, u32 shift,\n\t\t\t\tbool enable)\n{\n\tu32 cfg = readl(dev->regs + GSC_IN_BASE_ADDR_Y_MASK);\n\tu32 mask = 1 << shift;\n\n\tcfg &= ~mask;\n\tcfg |= enable << shift;\n\n\twritel(cfg, dev->regs + GSC_IN_BASE_ADDR_Y_MASK);\n\twritel(cfg, dev->regs + GSC_IN_BASE_ADDR_CB_MASK);\n\twritel(cfg, dev->regs + GSC_IN_BASE_ADDR_CR_MASK);\n}\n\nvoid gsc_hw_set_output_buf_masking(struct gsc_dev *dev, u32 shift,\n\t\t\t\tbool enable)\n{\n\tu32 cfg = readl(dev->regs + GSC_OUT_BASE_ADDR_Y_MASK);\n\tu32 mask = 1 << shift;\n\n\tcfg &= ~mask;\n\tcfg |= enable << shift;\n\n\twritel(cfg, dev->regs + GSC_OUT_BASE_ADDR_Y_MASK);\n\twritel(cfg, dev->regs + GSC_OUT_BASE_ADDR_CB_MASK);\n\twritel(cfg, dev->regs + GSC_OUT_BASE_ADDR_CR_MASK);\n}\n\nvoid gsc_hw_set_input_addr(struct gsc_dev *dev, struct gsc_addr *addr,\n\t\t\t\tint index)\n{\n\tpr_debug(\"src_buf[%d]: %pad, cb: %pad, cr: %pad\", index,\n\t\t\t&addr->y, &addr->cb, &addr->cr);\n\twritel(addr->y, dev->regs + GSC_IN_BASE_ADDR_Y(index));\n\twritel(addr->cb, dev->regs + GSC_IN_BASE_ADDR_CB(index));\n\twritel(addr->cr, dev->regs + GSC_IN_BASE_ADDR_CR(index));\n\n}\n\nvoid gsc_hw_set_output_addr(struct gsc_dev *dev,\n\t\t\t     struct gsc_addr *addr, int index)\n{\n\tpr_debug(\"dst_buf[%d]: %pad, cb: %pad, cr: %pad\",\n\t\t\tindex, &addr->y, &addr->cb, &addr->cr);\n\twritel(addr->y, dev->regs + GSC_OUT_BASE_ADDR_Y(index));\n\twritel(addr->cb, dev->regs + GSC_OUT_BASE_ADDR_CB(index));\n\twritel(addr->cr, dev->regs + GSC_OUT_BASE_ADDR_CR(index));\n}\n\nvoid gsc_hw_set_input_path(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\n\tu32 cfg = readl(dev->regs + GSC_IN_CON);\n\tcfg &= ~(GSC_IN_PATH_MASK | GSC_IN_LOCAL_SEL_MASK);\n\n\tif (ctx->in_path == GSC_DMA)\n\t\tcfg |= GSC_IN_PATH_MEMORY;\n\n\twritel(cfg, dev->regs + GSC_IN_CON);\n}\n\nvoid gsc_hw_set_in_size(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\tstruct gsc_frame *frame = &ctx->s_frame;\n\tu32 cfg;\n\n\t \n\tcfg = GSC_SRCIMG_OFFSET_X(frame->crop.left);\n\tcfg |= GSC_SRCIMG_OFFSET_Y(frame->crop.top);\n\twritel(cfg, dev->regs + GSC_SRCIMG_OFFSET);\n\n\t \n\tcfg = GSC_SRCIMG_WIDTH(frame->f_width);\n\tcfg |= GSC_SRCIMG_HEIGHT(frame->f_height);\n\twritel(cfg, dev->regs + GSC_SRCIMG_SIZE);\n\n\t \n\tcfg = GSC_CROPPED_WIDTH(frame->crop.width);\n\tcfg |= GSC_CROPPED_HEIGHT(frame->crop.height);\n\twritel(cfg, dev->regs + GSC_CROPPED_SIZE);\n}\n\nvoid gsc_hw_set_in_image_rgb(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\tstruct gsc_frame *frame = &ctx->s_frame;\n\tu32 cfg;\n\n\tcfg = readl(dev->regs + GSC_IN_CON);\n\tif (frame->colorspace == V4L2_COLORSPACE_REC709)\n\t\tcfg |= GSC_IN_RGB_HD_WIDE;\n\telse\n\t\tcfg |= GSC_IN_RGB_SD_WIDE;\n\n\tif (frame->fmt->pixelformat == V4L2_PIX_FMT_RGB565X)\n\t\tcfg |= GSC_IN_RGB565;\n\telse if (frame->fmt->pixelformat == V4L2_PIX_FMT_RGB32)\n\t\tcfg |= GSC_IN_XRGB8888;\n\n\twritel(cfg, dev->regs + GSC_IN_CON);\n}\n\nvoid gsc_hw_set_in_image_format(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\tstruct gsc_frame *frame = &ctx->s_frame;\n\tu32 i, depth = 0;\n\tu32 cfg;\n\n\tcfg = readl(dev->regs + GSC_IN_CON);\n\tcfg &= ~(GSC_IN_RGB_TYPE_MASK | GSC_IN_YUV422_1P_ORDER_MASK |\n\t\t GSC_IN_CHROMA_ORDER_MASK | GSC_IN_FORMAT_MASK |\n\t\t GSC_IN_TILE_TYPE_MASK | GSC_IN_TILE_MODE);\n\twritel(cfg, dev->regs + GSC_IN_CON);\n\n\tif (is_rgb(frame->fmt->color)) {\n\t\tgsc_hw_set_in_image_rgb(ctx);\n\t\treturn;\n\t}\n\tfor (i = 0; i < frame->fmt->num_planes; i++)\n\t\tdepth += frame->fmt->depth[i];\n\n\tswitch (frame->fmt->num_comp) {\n\tcase 1:\n\t\tcfg |= GSC_IN_YUV422_1P;\n\t\tif (frame->fmt->yorder == GSC_LSB_Y)\n\t\t\tcfg |= GSC_IN_YUV422_1P_ORDER_LSB_Y;\n\t\telse\n\t\t\tcfg |= GSC_IN_YUV422_1P_OEDER_LSB_C;\n\t\tif (frame->fmt->corder == GSC_CBCR)\n\t\t\tcfg |= GSC_IN_CHROMA_ORDER_CBCR;\n\t\telse\n\t\t\tcfg |= GSC_IN_CHROMA_ORDER_CRCB;\n\t\tbreak;\n\tcase 2:\n\t\tif (depth == 12)\n\t\t\tcfg |= GSC_IN_YUV420_2P;\n\t\telse\n\t\t\tcfg |= GSC_IN_YUV422_2P;\n\t\tif (frame->fmt->corder == GSC_CBCR)\n\t\t\tcfg |= GSC_IN_CHROMA_ORDER_CBCR;\n\t\telse\n\t\t\tcfg |= GSC_IN_CHROMA_ORDER_CRCB;\n\t\tbreak;\n\tcase 3:\n\t\tif (depth == 12)\n\t\t\tcfg |= GSC_IN_YUV420_3P;\n\t\telse\n\t\t\tcfg |= GSC_IN_YUV422_3P;\n\t\tbreak;\n\t}\n\n\tif (is_tiled(frame->fmt))\n\t\tcfg |= GSC_IN_TILE_C_16x8 | GSC_IN_TILE_MODE;\n\n\twritel(cfg, dev->regs + GSC_IN_CON);\n}\n\nvoid gsc_hw_set_output_path(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\n\tu32 cfg = readl(dev->regs + GSC_OUT_CON);\n\tcfg &= ~GSC_OUT_PATH_MASK;\n\n\tif (ctx->out_path == GSC_DMA)\n\t\tcfg |= GSC_OUT_PATH_MEMORY;\n\telse\n\t\tcfg |= GSC_OUT_PATH_LOCAL;\n\n\twritel(cfg, dev->regs + GSC_OUT_CON);\n}\n\nvoid gsc_hw_set_out_size(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\tstruct gsc_frame *frame = &ctx->d_frame;\n\tu32 cfg;\n\n\t \n\tif (ctx->out_path == GSC_DMA) {\n\t\tcfg = GSC_DSTIMG_OFFSET_X(frame->crop.left);\n\t\tcfg |= GSC_DSTIMG_OFFSET_Y(frame->crop.top);\n\t\twritel(cfg, dev->regs + GSC_DSTIMG_OFFSET);\n\n\t\tcfg = GSC_DSTIMG_WIDTH(frame->f_width);\n\t\tcfg |= GSC_DSTIMG_HEIGHT(frame->f_height);\n\t\twritel(cfg, dev->regs + GSC_DSTIMG_SIZE);\n\t}\n\n\t \n\tif (ctx->gsc_ctrls.rotate->val == 90 ||\n\t    ctx->gsc_ctrls.rotate->val == 270) {\n\t\tcfg = GSC_SCALED_WIDTH(frame->crop.height);\n\t\tcfg |= GSC_SCALED_HEIGHT(frame->crop.width);\n\t} else {\n\t\tcfg = GSC_SCALED_WIDTH(frame->crop.width);\n\t\tcfg |= GSC_SCALED_HEIGHT(frame->crop.height);\n\t}\n\twritel(cfg, dev->regs + GSC_SCALED_SIZE);\n}\n\nvoid gsc_hw_set_out_image_rgb(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\tstruct gsc_frame *frame = &ctx->d_frame;\n\tu32 cfg;\n\n\tcfg = readl(dev->regs + GSC_OUT_CON);\n\tif (frame->colorspace == V4L2_COLORSPACE_REC709)\n\t\tcfg |= GSC_OUT_RGB_HD_WIDE;\n\telse\n\t\tcfg |= GSC_OUT_RGB_SD_WIDE;\n\n\tif (frame->fmt->pixelformat == V4L2_PIX_FMT_RGB565X)\n\t\tcfg |= GSC_OUT_RGB565;\n\telse if (frame->fmt->pixelformat == V4L2_PIX_FMT_RGB32)\n\t\tcfg |= GSC_OUT_XRGB8888;\n\n\twritel(cfg, dev->regs + GSC_OUT_CON);\n}\n\nvoid gsc_hw_set_out_image_format(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\tstruct gsc_frame *frame = &ctx->d_frame;\n\tu32 i, depth = 0;\n\tu32 cfg;\n\n\tcfg = readl(dev->regs + GSC_OUT_CON);\n\tcfg &= ~(GSC_OUT_RGB_TYPE_MASK | GSC_OUT_YUV422_1P_ORDER_MASK |\n\t\t GSC_OUT_CHROMA_ORDER_MASK | GSC_OUT_FORMAT_MASK |\n\t\t GSC_OUT_TILE_TYPE_MASK | GSC_OUT_TILE_MODE);\n\twritel(cfg, dev->regs + GSC_OUT_CON);\n\n\tif (is_rgb(frame->fmt->color)) {\n\t\tgsc_hw_set_out_image_rgb(ctx);\n\t\treturn;\n\t}\n\n\tif (ctx->out_path != GSC_DMA) {\n\t\tcfg |= GSC_OUT_YUV444;\n\t\tgoto end_set;\n\t}\n\n\tfor (i = 0; i < frame->fmt->num_planes; i++)\n\t\tdepth += frame->fmt->depth[i];\n\n\tswitch (frame->fmt->num_comp) {\n\tcase 1:\n\t\tcfg |= GSC_OUT_YUV422_1P;\n\t\tif (frame->fmt->yorder == GSC_LSB_Y)\n\t\t\tcfg |= GSC_OUT_YUV422_1P_ORDER_LSB_Y;\n\t\telse\n\t\t\tcfg |= GSC_OUT_YUV422_1P_OEDER_LSB_C;\n\t\tif (frame->fmt->corder == GSC_CBCR)\n\t\t\tcfg |= GSC_OUT_CHROMA_ORDER_CBCR;\n\t\telse\n\t\t\tcfg |= GSC_OUT_CHROMA_ORDER_CRCB;\n\t\tbreak;\n\tcase 2:\n\t\tif (depth == 12)\n\t\t\tcfg |= GSC_OUT_YUV420_2P;\n\t\telse\n\t\t\tcfg |= GSC_OUT_YUV422_2P;\n\t\tif (frame->fmt->corder == GSC_CBCR)\n\t\t\tcfg |= GSC_OUT_CHROMA_ORDER_CBCR;\n\t\telse\n\t\t\tcfg |= GSC_OUT_CHROMA_ORDER_CRCB;\n\t\tbreak;\n\tcase 3:\n\t\tcfg |= GSC_OUT_YUV420_3P;\n\t\tbreak;\n\t}\n\n\tif (is_tiled(frame->fmt))\n\t\tcfg |= GSC_OUT_TILE_C_16x8 | GSC_OUT_TILE_MODE;\n\nend_set:\n\twritel(cfg, dev->regs + GSC_OUT_CON);\n}\n\nvoid gsc_hw_set_prescaler(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\tstruct gsc_scaler *sc = &ctx->scaler;\n\tu32 cfg;\n\n\tcfg = GSC_PRESC_SHFACTOR(sc->pre_shfactor);\n\tcfg |= GSC_PRESC_H_RATIO(sc->pre_hratio);\n\tcfg |= GSC_PRESC_V_RATIO(sc->pre_vratio);\n\twritel(cfg, dev->regs + GSC_PRE_SCALE_RATIO);\n}\n\nvoid gsc_hw_set_mainscaler(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\tstruct gsc_scaler *sc = &ctx->scaler;\n\tu32 cfg;\n\n\tcfg = GSC_MAIN_H_RATIO_VALUE(sc->main_hratio);\n\twritel(cfg, dev->regs + GSC_MAIN_H_RATIO);\n\n\tcfg = GSC_MAIN_V_RATIO_VALUE(sc->main_vratio);\n\twritel(cfg, dev->regs + GSC_MAIN_V_RATIO);\n}\n\nvoid gsc_hw_set_rotation(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\tu32 cfg;\n\n\tcfg = readl(dev->regs + GSC_IN_CON);\n\tcfg &= ~GSC_IN_ROT_MASK;\n\n\tswitch (ctx->gsc_ctrls.rotate->val) {\n\tcase 270:\n\t\tcfg |= GSC_IN_ROT_270;\n\t\tbreak;\n\tcase 180:\n\t\tcfg |= GSC_IN_ROT_180;\n\t\tbreak;\n\tcase 90:\n\t\tif (ctx->gsc_ctrls.hflip->val)\n\t\t\tcfg |= GSC_IN_ROT_90_XFLIP;\n\t\telse if (ctx->gsc_ctrls.vflip->val)\n\t\t\tcfg |= GSC_IN_ROT_90_YFLIP;\n\t\telse\n\t\t\tcfg |= GSC_IN_ROT_90;\n\t\tbreak;\n\tcase 0:\n\t\tif (ctx->gsc_ctrls.hflip->val)\n\t\t\tcfg |= GSC_IN_ROT_XFLIP;\n\t\telse if (ctx->gsc_ctrls.vflip->val)\n\t\t\tcfg |= GSC_IN_ROT_YFLIP;\n\t}\n\n\twritel(cfg, dev->regs + GSC_IN_CON);\n}\n\nvoid gsc_hw_set_global_alpha(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\tstruct gsc_frame *frame = &ctx->d_frame;\n\tu32 cfg;\n\n\tif (!is_rgb(frame->fmt->color)) {\n\t\tpr_debug(\"Not a RGB format\");\n\t\treturn;\n\t}\n\n\tcfg = readl(dev->regs + GSC_OUT_CON);\n\tcfg &= ~GSC_OUT_GLOBAL_ALPHA_MASK;\n\n\tcfg |= GSC_OUT_GLOBAL_ALPHA(ctx->gsc_ctrls.global_alpha->val);\n\twritel(cfg, dev->regs + GSC_OUT_CON);\n}\n\nvoid gsc_hw_set_sfr_update(struct gsc_ctx *ctx)\n{\n\tstruct gsc_dev *dev = ctx->gsc_dev;\n\tu32 cfg;\n\n\tcfg = readl(dev->regs + GSC_ENABLE);\n\tcfg |= GSC_ENABLE_SFR_UPDATE;\n\twritel(cfg, dev->regs + GSC_ENABLE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}