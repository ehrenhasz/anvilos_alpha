{
  "module_name": "media-dev.h",
  "hash_id": "5c941dc17916f397fd926f98ebe776b37640fcbd073d13678735ba3fd7b1e73c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/media-dev.h",
  "human_readable_source": " \n \n\n#ifndef FIMC_MDEVICE_H_\n#define FIMC_MDEVICE_H_\n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <media/media-device.h>\n#include <media/media-entity.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-subdev.h>\n#include <media/drv-intf/exynos-fimc.h>\n\n#include \"fimc-core.h\"\n#include \"fimc-lite.h\"\n#include \"mipi-csis.h\"\n\n#define FIMC_OF_NODE_NAME\t\"fimc\"\n#define FIMC_LITE_OF_NODE_NAME\t\"fimc-lite\"\n#define FIMC_IS_OF_NODE_NAME\t\"fimc-is\"\n#define CSIS_OF_NODE_NAME\t\"csis\"\n\n#define FIMC_MAX_SENSORS\t4\n#define FIMC_MAX_CAMCLKS\t2\n#define DEFAULT_SENSOR_CLK_FREQ\t24000000U\n\n \nenum {\n\tCLK_IDX_WB_A,\n\tCLK_IDX_WB_B,\n\tFIMC_MAX_WBCLKS\n};\n\nenum fimc_subdev_index {\n\tIDX_SENSOR,\n\tIDX_CSIS,\n\tIDX_FLITE,\n\tIDX_IS_ISP,\n\tIDX_FIMC,\n\tIDX_MAX,\n};\n\n \nstruct fimc_pipeline {\n\tstruct exynos_media_pipeline ep;\n\tstruct list_head list;\n\tstruct media_entity *vdev_entity;\n\tstruct v4l2_subdev *subdevs[IDX_MAX];\n};\n\n#define to_fimc_pipeline(_ep) container_of(_ep, struct fimc_pipeline, ep)\n\nstruct fimc_csis_info {\n\tstruct v4l2_subdev *sd;\n\tint id;\n};\n\nstruct fimc_camclk_info {\n\tstruct clk *clock;\n\tint use_count;\n\tunsigned long frequency;\n};\n\n \nstruct fimc_sensor_info {\n\tstruct fimc_source_info pdata;\n\tstruct v4l2_async_connection *asd;\n\tstruct v4l2_subdev *subdev;\n\tstruct fimc_dev *host;\n};\n\nstruct cam_clk {\n\tstruct clk_hw hw;\n\tstruct fimc_md *fmd;\n};\n#define to_cam_clk(_hw) container_of(_hw, struct cam_clk, hw)\n\n \nstruct fimc_md {\n\tstruct fimc_csis_info csis[CSIS_MAX_ENTITIES];\n\tstruct fimc_sensor_info sensor[FIMC_MAX_SENSORS];\n\tint num_sensors;\n\tstruct fimc_camclk_info camclk[FIMC_MAX_CAMCLKS];\n\tstruct clk *wbclk[FIMC_MAX_WBCLKS];\n\tstruct fimc_lite *fimc_lite[FIMC_LITE_MAX_DEVS];\n\tstruct fimc_dev *fimc[FIMC_MAX_DEVS];\n\tstruct fimc_is *fimc_is;\n\tbool use_isp;\n\tstruct device *pmf;\n\tstruct media_device media_dev;\n\tstruct v4l2_device v4l2_dev;\n\tstruct platform_device *pdev;\n\n\tstruct cam_clk_provider {\n\t\tstruct clk *clks[FIMC_MAX_CAMCLKS];\n\t\tstruct clk_onecell_data clk_data;\n\t\tstruct device_node *of_node;\n\t\tstruct cam_clk camclk[FIMC_MAX_CAMCLKS];\n\t\tint num_clocks;\n\t} clk_provider;\n\n\tstruct v4l2_async_notifier subdev_notifier;\n\n\tbool user_subdev_api;\n\tspinlock_t slock;\n\tstruct list_head pipelines;\n\tstruct media_graph link_setup_graph;\n};\n\nstatic inline\nstruct fimc_sensor_info *source_to_sensor_info(struct fimc_source_info *si)\n{\n\treturn container_of(si, struct fimc_sensor_info, pdata);\n}\n\nstatic inline struct fimc_md *entity_to_fimc_mdev(struct media_entity *me)\n{\n\treturn me->graph_obj.mdev == NULL ? NULL :\n\t\tcontainer_of(me->graph_obj.mdev, struct fimc_md, media_dev);\n}\n\nstatic inline struct fimc_md *notifier_to_fimc_md(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct fimc_md, subdev_notifier);\n}\n\nstatic inline void fimc_md_graph_lock(struct exynos_video_entity *ve)\n{\n\tmutex_lock(&ve->vdev.entity.graph_obj.mdev->graph_mutex);\n}\n\nstatic inline void fimc_md_graph_unlock(struct exynos_video_entity *ve)\n{\n\tmutex_unlock(&ve->vdev.entity.graph_obj.mdev->graph_mutex);\n}\n\nint fimc_md_set_camclk(struct v4l2_subdev *sd, bool on);\n\n#ifdef CONFIG_OF\nstatic inline bool fimc_md_is_isp_available(struct device_node *node)\n{\n\tnode = of_get_child_by_name(node, FIMC_IS_OF_NODE_NAME);\n\treturn node ? of_device_is_available(node) : false;\n}\n#else\n#define fimc_md_is_isp_available(node) (false)\n#endif  \n\nstatic inline struct v4l2_subdev *__fimc_md_get_subdev(\n\t\t\t\tstruct exynos_media_pipeline *ep,\n\t\t\t\tunsigned int index)\n{\n\tstruct fimc_pipeline *p = to_fimc_pipeline(ep);\n\n\tif (!p || index >= IDX_MAX)\n\t\treturn NULL;\n\telse\n\t\treturn p->subdevs[index];\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}