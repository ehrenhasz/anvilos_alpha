{
  "module_name": "fimc-m2m.c",
  "hash_id": "9268d450868fbb4a296eb4daa3a4f0d2d948e887f12bd5d0204bd3ac1ce7e030",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-m2m.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/bug.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"common.h\"\n#include \"fimc-core.h\"\n#include \"fimc-reg.h\"\n#include \"media-dev.h\"\n\nstatic unsigned int get_m2m_fmt_flags(unsigned int stream_type)\n{\n\tif (stream_type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn FMT_FLAGS_M2M_IN;\n\telse\n\t\treturn FMT_FLAGS_M2M_OUT;\n}\n\nvoid fimc_m2m_job_finish(struct fimc_ctx *ctx, int vb_state)\n{\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\n\tif (!ctx || !ctx->fh.m2m_ctx)\n\t\treturn;\n\n\tsrc_vb = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst_vb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tif (src_vb)\n\t\tv4l2_m2m_buf_done(src_vb, vb_state);\n\tif (dst_vb)\n\t\tv4l2_m2m_buf_done(dst_vb, vb_state);\n\tif (src_vb && dst_vb)\n\t\tv4l2_m2m_job_finish(ctx->fimc_dev->m2m.m2m_dev,\n\t\t\t\t    ctx->fh.m2m_ctx);\n}\n\n \nstatic void fimc_m2m_shutdown(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\n\tif (!fimc_m2m_pending(fimc))\n\t\treturn;\n\n\tfimc_ctx_state_set(FIMC_CTX_SHUT, ctx);\n\n\twait_event_timeout(fimc->irq_queue,\n\t\t\t!fimc_ctx_state_is_set(FIMC_CTX_SHUT, ctx),\n\t\t\tFIMC_SHUTDOWN_TIMEOUT);\n}\n\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct fimc_ctx *ctx = q->drv_priv;\n\n\treturn pm_runtime_resume_and_get(&ctx->fimc_dev->pdev->dev);\n}\n\nstatic void stop_streaming(struct vb2_queue *q)\n{\n\tstruct fimc_ctx *ctx = q->drv_priv;\n\n\tfimc_m2m_shutdown(ctx);\n\tfimc_m2m_job_finish(ctx, VB2_BUF_STATE_ERROR);\n\tpm_runtime_put(&ctx->fimc_dev->pdev->dev);\n}\n\nstatic void fimc_device_run(void *priv)\n{\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\tstruct fimc_ctx *ctx = priv;\n\tstruct fimc_frame *sf, *df;\n\tstruct fimc_dev *fimc;\n\tunsigned long flags;\n\tint ret;\n\n\tif (WARN(!ctx, \"Null context\\n\"))\n\t\treturn;\n\n\tfimc = ctx->fimc_dev;\n\tspin_lock_irqsave(&fimc->slock, flags);\n\n\tset_bit(ST_M2M_PEND, &fimc->state);\n\tsf = &ctx->s_frame;\n\tdf = &ctx->d_frame;\n\n\tif (ctx->state & FIMC_PARAMS) {\n\t\t \n\t\tfimc_prepare_dma_offset(ctx, sf);\n\t\tfimc_prepare_dma_offset(ctx, df);\n\t}\n\n\tsrc_vb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tret = fimc_prepare_addr(ctx, &src_vb->vb2_buf, sf, &sf->addr);\n\tif (ret)\n\t\tgoto dma_unlock;\n\n\tdst_vb = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tret = fimc_prepare_addr(ctx, &dst_vb->vb2_buf, df, &df->addr);\n\tif (ret)\n\t\tgoto dma_unlock;\n\n\tdst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;\n\tdst_vb->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst_vb->flags |=\n\t\tsrc_vb->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\t \n\tif (fimc->m2m.ctx != ctx) {\n\t\tctx->state |= FIMC_PARAMS;\n\t\tfimc->m2m.ctx = ctx;\n\t}\n\n\tif (ctx->state & FIMC_PARAMS) {\n\t\tfimc_set_yuv_order(ctx);\n\t\tfimc_hw_set_input_path(ctx);\n\t\tfimc_hw_set_in_dma(ctx);\n\t\tret = fimc_set_scaler_info(ctx);\n\t\tif (ret)\n\t\t\tgoto dma_unlock;\n\t\tfimc_hw_set_prescaler(ctx);\n\t\tfimc_hw_set_mainscaler(ctx);\n\t\tfimc_hw_set_target_format(ctx);\n\t\tfimc_hw_set_rotation(ctx);\n\t\tfimc_hw_set_effect(ctx);\n\t\tfimc_hw_set_out_dma(ctx);\n\t\tif (fimc->drv_data->alpha_color)\n\t\t\tfimc_hw_set_rgb_alpha(ctx);\n\t\tfimc_hw_set_output_path(ctx);\n\t}\n\tfimc_hw_set_input_addr(fimc, &sf->addr);\n\tfimc_hw_set_output_addr(fimc, &df->addr, -1);\n\n\tfimc_activate_capture(ctx);\n\tctx->state &= (FIMC_CTX_M2M | FIMC_CTX_CAP);\n\tfimc_hw_activate_input_dma(fimc, true);\n\ndma_unlock:\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n}\n\nstatic void fimc_job_abort(void *priv)\n{\n\tfimc_m2m_shutdown(priv);\n}\n\nstatic int fimc_queue_setup(struct vb2_queue *vq,\n\t\t\t    unsigned int *num_buffers, unsigned int *num_planes,\n\t\t\t    unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct fimc_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct fimc_frame *f;\n\tint i;\n\n\tf = ctx_get_frame(ctx, vq->type);\n\tif (IS_ERR(f))\n\t\treturn PTR_ERR(f);\n\t \n\tif (!f->fmt)\n\t\treturn -EINVAL;\n\n\t*num_planes = f->fmt->memplanes;\n\tfor (i = 0; i < f->fmt->memplanes; i++)\n\t\tsizes[i] = f->payload[i];\n\treturn 0;\n}\n\nstatic int fimc_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct fimc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct fimc_frame *frame;\n\tint i;\n\n\tframe = ctx_get_frame(ctx, vb->vb2_queue->type);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\tfor (i = 0; i < frame->fmt->memplanes; i++)\n\t\tvb2_set_plane_payload(vb, i, frame->payload[i]);\n\n\treturn 0;\n}\n\nstatic void fimc_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct fimc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic const struct vb2_ops fimc_qops = {\n\t.queue_setup\t = fimc_queue_setup,\n\t.buf_prepare\t = fimc_buf_prepare,\n\t.buf_queue\t = fimc_buf_queue,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n\t.stop_streaming\t = stop_streaming,\n\t.start_streaming = start_streaming,\n};\n\n \nstatic int fimc_m2m_querycap(struct file *file, void *fh,\n\t\t\t\t     struct v4l2_capability *cap)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\n\t__fimc_vidioc_querycap(&fimc->pdev->dev, cap);\n\treturn 0;\n}\n\nstatic int fimc_m2m_enum_fmt(struct file *file, void *priv,\n\t\t\t     struct v4l2_fmtdesc *f)\n{\n\tstruct fimc_fmt *fmt;\n\n\tfmt = fimc_find_format(NULL, NULL, get_m2m_fmt_flags(f->type),\n\t\t\t       f->index);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = fmt->fourcc;\n\treturn 0;\n}\n\nstatic int fimc_m2m_g_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct fimc_ctx *ctx = fh_to_ctx(fh);\n\tstruct fimc_frame *frame = ctx_get_frame(ctx, f->type);\n\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\t__fimc_get_format(frame, f);\n\treturn 0;\n}\n\nstatic int fimc_try_fmt_mplane(struct fimc_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\tconst struct fimc_variant *variant = fimc->variant;\n\tstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\n\tstruct fimc_fmt *fmt;\n\tu32 max_w, mod_x, mod_y;\n\n\tif (!IS_M2M(f->type))\n\t\treturn -EINVAL;\n\n\tfmt = fimc_find_format(&pix->pixelformat, NULL,\n\t\t\t       get_m2m_fmt_flags(f->type), 0);\n\tif (WARN(fmt == NULL, \"Pixel format lookup failed\"))\n\t\treturn -EINVAL;\n\n\tif (pix->field == V4L2_FIELD_ANY)\n\t\tpix->field = V4L2_FIELD_NONE;\n\telse if (pix->field != V4L2_FIELD_NONE)\n\t\treturn -EINVAL;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tmax_w = variant->pix_limit->scaler_dis_w;\n\t\tmod_x = ffs(variant->min_inp_pixsize) - 1;\n\t} else {\n\t\tmax_w = variant->pix_limit->out_rot_dis_w;\n\t\tmod_x = ffs(variant->min_out_pixsize) - 1;\n\t}\n\n\tif (tiled_fmt(fmt)) {\n\t\tmod_x = 6;  \n\t\tmod_y = 5;\n\t} else {\n\t\tif (variant->min_vsize_align == 1)\n\t\t\tmod_y = fimc_fmt_is_rgb(fmt->color) ? 0 : 1;\n\t\telse\n\t\t\tmod_y = ffs(variant->min_vsize_align) - 1;\n\t}\n\n\tv4l_bound_align_image(&pix->width, 16, max_w, mod_x,\n\t\t&pix->height, 8, variant->pix_limit->scaler_dis_w, mod_y, 0);\n\n\tfimc_adjust_mplane_format(fmt, pix->width, pix->height, &f->fmt.pix_mp);\n\treturn 0;\n}\n\nstatic int fimc_m2m_try_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct fimc_ctx *ctx = fh_to_ctx(fh);\n\treturn fimc_try_fmt_mplane(ctx, f);\n}\n\nstatic void __set_frame_format(struct fimc_frame *frame, struct fimc_fmt *fmt,\n\t\t\t       struct v4l2_pix_format_mplane *pixm)\n{\n\tint i;\n\n\tfor (i = 0; i < fmt->memplanes; i++) {\n\t\tframe->bytesperline[i] = pixm->plane_fmt[i].bytesperline;\n\t\tframe->payload[i] = pixm->plane_fmt[i].sizeimage;\n\t}\n\n\tframe->f_width = pixm->width;\n\tframe->f_height\t= pixm->height;\n\tframe->o_width = pixm->width;\n\tframe->o_height = pixm->height;\n\tframe->width = pixm->width;\n\tframe->height = pixm->height;\n\tframe->offs_h = 0;\n\tframe->offs_v = 0;\n\tframe->fmt = fmt;\n}\n\nstatic int fimc_m2m_s_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct fimc_ctx *ctx = fh_to_ctx(fh);\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\tstruct fimc_fmt *fmt;\n\tstruct vb2_queue *vq;\n\tstruct fimc_frame *frame;\n\tint ret;\n\n\tret = fimc_try_fmt_mplane(ctx, f);\n\tif (ret)\n\t\treturn ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&fimc->m2m.vfd, \"queue (%d) busy\\n\", f->type);\n\t\treturn -EBUSY;\n\t}\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tframe = &ctx->s_frame;\n\telse\n\t\tframe = &ctx->d_frame;\n\n\tfmt = fimc_find_format(&f->fmt.pix_mp.pixelformat, NULL,\n\t\t\t       get_m2m_fmt_flags(f->type), 0);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\t__set_frame_format(frame, fmt, &f->fmt.pix_mp);\n\n\t \n\tfimc_alpha_ctrl_update(ctx);\n\n\treturn 0;\n}\n\nstatic int fimc_m2m_g_selection(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_selection *s)\n{\n\tstruct fimc_ctx *ctx = fh_to_ctx(fh);\n\tstruct fimc_frame *frame;\n\n\tframe = ctx_get_frame(ctx, s->type);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\ts->r.left = frame->offs_h;\n\t\ts->r.top = frame->offs_v;\n\t\ts->r.width = frame->width;\n\t\ts->r.height = frame->height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = frame->o_width;\n\t\ts->r.height = frame->o_height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int fimc_m2m_try_selection(struct fimc_ctx *ctx,\n\t\t\t\t  struct v4l2_selection *s)\n{\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\tstruct fimc_frame *f;\n\tu32 min_size, halign, depth = 0;\n\tint i;\n\n\tif (s->r.top < 0 || s->r.left < 0) {\n\t\tv4l2_err(&fimc->m2m.vfd,\n\t\t\t\"doesn't support negative values for top & left\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tf = &ctx->d_frame;\n\t\tif (s->target != V4L2_SEL_TGT_COMPOSE)\n\t\t\treturn -EINVAL;\n\t} else if (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tf = &ctx->s_frame;\n\t\tif (s->target != V4L2_SEL_TGT_CROP)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tmin_size = (f == &ctx->s_frame) ?\n\t\tfimc->variant->min_inp_pixsize : fimc->variant->min_out_pixsize;\n\n\t \n\tif (fimc->variant->min_vsize_align == 1)\n\t\thalign = fimc_fmt_is_rgb(f->fmt->color) ? 0 : 1;\n\telse\n\t\thalign = ffs(fimc->variant->min_vsize_align) - 1;\n\n\tfor (i = 0; i < f->fmt->memplanes; i++)\n\t\tdepth += f->fmt->depth[i];\n\n\tv4l_bound_align_image(&s->r.width, min_size, f->o_width,\n\t\t\t      ffs(min_size) - 1,\n\t\t\t      &s->r.height, min_size, f->o_height,\n\t\t\t      halign, 64/(ALIGN(depth, 8)));\n\n\t \n\tif (s->r.left + s->r.width > f->o_width)\n\t\ts->r.left = f->o_width - s->r.width;\n\tif (s->r.top + s->r.height > f->o_height)\n\t\ts->r.top = f->o_height - s->r.height;\n\n\ts->r.left = round_down(s->r.left, min_size);\n\ts->r.top  = round_down(s->r.top, fimc->variant->hor_offs_align);\n\n\tdbg(\"l:%d, t:%d, w:%d, h:%d, f_w: %d, f_h: %d\",\n\t    s->r.left, s->r.top, s->r.width, s->r.height,\n\t    f->f_width, f->f_height);\n\n\treturn 0;\n}\n\nstatic int fimc_m2m_s_selection(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_selection *s)\n{\n\tstruct fimc_ctx *ctx = fh_to_ctx(fh);\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\tstruct fimc_frame *f;\n\tint ret;\n\n\tret = fimc_m2m_try_selection(ctx, s);\n\tif (ret)\n\t\treturn ret;\n\n\tf = (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?\n\t\t&ctx->s_frame : &ctx->d_frame;\n\n\t \n\tif (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tret = fimc_check_scaler_ratio(ctx, s->r.width,\n\t\t\t\ts->r.height, ctx->d_frame.width,\n\t\t\t\tctx->d_frame.height, ctx->rotation);\n\t} else {\n\t\tret = fimc_check_scaler_ratio(ctx, ctx->s_frame.width,\n\t\t\t\tctx->s_frame.height, s->r.width,\n\t\t\t\ts->r.height, ctx->rotation);\n\t}\n\tif (ret) {\n\t\tv4l2_err(&fimc->m2m.vfd, \"Out of scaler range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tf->offs_h = s->r.left;\n\tf->offs_v = s->r.top;\n\tf->width  = s->r.width;\n\tf->height = s->r.height;\n\n\tfimc_ctx_state_set(FIMC_PARAMS, ctx);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops fimc_m2m_ioctl_ops = {\n\t.vidioc_querycap\t\t= fimc_m2m_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= fimc_m2m_enum_fmt,\n\t.vidioc_enum_fmt_vid_out\t= fimc_m2m_enum_fmt,\n\t.vidioc_g_fmt_vid_cap_mplane\t= fimc_m2m_g_fmt_mplane,\n\t.vidioc_g_fmt_vid_out_mplane\t= fimc_m2m_g_fmt_mplane,\n\t.vidioc_try_fmt_vid_cap_mplane\t= fimc_m2m_try_fmt_mplane,\n\t.vidioc_try_fmt_vid_out_mplane\t= fimc_m2m_try_fmt_mplane,\n\t.vidioc_s_fmt_vid_cap_mplane\t= fimc_m2m_s_fmt_mplane,\n\t.vidioc_s_fmt_vid_out_mplane\t= fimc_m2m_s_fmt_mplane,\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\t.vidioc_g_selection\t\t= fimc_m2m_g_selection,\n\t.vidioc_s_selection\t\t= fimc_m2m_s_selection,\n\n};\n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct fimc_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->ops = &fimc_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->fimc_dev->lock;\n\tsrc_vq->dev = &ctx->fimc_dev->pdev->dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->ops = &fimc_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->fimc_dev->lock;\n\tdst_vq->dev = &ctx->fimc_dev->pdev->dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int fimc_m2m_set_default_format(struct fimc_ctx *ctx)\n{\n\tstruct v4l2_pix_format_mplane pixm = {\n\t\t.pixelformat\t= V4L2_PIX_FMT_RGB32,\n\t\t.width\t\t= 800,\n\t\t.height\t\t= 600,\n\t\t.plane_fmt[0]\t= {\n\t\t\t.bytesperline = 800 * 4,\n\t\t\t.sizeimage = 800 * 4 * 600,\n\t\t},\n\t};\n\tstruct fimc_fmt *fmt;\n\n\tfmt = fimc_find_format(&pixm.pixelformat, NULL, FMT_FLAGS_M2M, 0);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\t__set_frame_format(&ctx->s_frame, fmt, &pixm);\n\t__set_frame_format(&ctx->d_frame, fmt, &pixm);\n\n\treturn 0;\n}\n\nstatic int fimc_m2m_open(struct file *file)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\tstruct fimc_ctx *ctx;\n\tint ret = -EBUSY;\n\n\tpr_debug(\"pid: %d, state: %#lx\\n\", task_pid_nr(current), fimc->state);\n\n\tif (mutex_lock_interruptible(&fimc->lock))\n\t\treturn -ERESTARTSYS;\n\t \n\tif (test_bit(ST_CAPT_BUSY, &fimc->state))\n\t\tgoto unlock;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tv4l2_fh_init(&ctx->fh, &fimc->m2m.vfd);\n\tctx->fimc_dev = fimc;\n\n\t \n\tctx->s_frame.fmt = fimc_get_format(0);\n\tctx->d_frame.fmt = fimc_get_format(0);\n\n\tret = fimc_ctrls_create(ctx);\n\tif (ret)\n\t\tgoto error_fh;\n\n\t \n\tctx->fh.ctrl_handler = &ctx->ctrls.handler;\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\t \n\tctx->state = FIMC_CTX_M2M;\n\tctx->flags = 0;\n\tctx->in_path = FIMC_IO_DMA;\n\tctx->out_path = FIMC_IO_DMA;\n\tctx->scaler.enabled = 1;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(fimc->m2m.m2m_dev, ctx, queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto error_c;\n\t}\n\n\tif (fimc->m2m.refcnt++ == 0)\n\t\tset_bit(ST_M2M_RUN, &fimc->state);\n\n\tret = fimc_m2m_set_default_format(ctx);\n\tif (ret < 0)\n\t\tgoto error_m2m_ctx;\n\n\tmutex_unlock(&fimc->lock);\n\treturn 0;\n\nerror_m2m_ctx:\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\nerror_c:\n\tfimc_ctrls_delete(ctx);\n\tv4l2_fh_del(&ctx->fh);\nerror_fh:\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\nunlock:\n\tmutex_unlock(&fimc->lock);\n\treturn ret;\n}\n\nstatic int fimc_m2m_release(struct file *file)\n{\n\tstruct fimc_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\n\tdbg(\"pid: %d, state: 0x%lx, refcnt= %d\",\n\t\ttask_pid_nr(current), fimc->state, fimc->m2m.refcnt);\n\n\tmutex_lock(&fimc->lock);\n\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tfimc_ctrls_delete(ctx);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\n\tif (--fimc->m2m.refcnt <= 0)\n\t\tclear_bit(ST_M2M_RUN, &fimc->state);\n\tkfree(ctx);\n\n\tmutex_unlock(&fimc->lock);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations fimc_m2m_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= fimc_m2m_open,\n\t.release\t= fimc_m2m_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct v4l2_m2m_ops m2m_ops = {\n\t.device_run\t= fimc_device_run,\n\t.job_abort\t= fimc_job_abort,\n};\n\nint fimc_register_m2m_device(struct fimc_dev *fimc,\n\t\t\t     struct v4l2_device *v4l2_dev)\n{\n\tstruct video_device *vfd = &fimc->m2m.vfd;\n\tint ret;\n\n\tfimc->v4l2_dev = v4l2_dev;\n\n\tmemset(vfd, 0, sizeof(*vfd));\n\tvfd->fops = &fimc_m2m_fops;\n\tvfd->ioctl_ops = &fimc_m2m_ioctl_ops;\n\tvfd->v4l2_dev = v4l2_dev;\n\tvfd->minor = -1;\n\tvfd->release = video_device_release_empty;\n\tvfd->lock = &fimc->lock;\n\tvfd->vfl_dir = VFL_DIR_M2M;\n\tvfd->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE;\n\tset_bit(V4L2_FL_QUIRK_INVERTED_CROP, &vfd->flags);\n\n\tsnprintf(vfd->name, sizeof(vfd->name), \"fimc.%d.m2m\", fimc->id);\n\tvideo_set_drvdata(vfd, fimc);\n\n\tfimc->m2m.m2m_dev = v4l2_m2m_init(&m2m_ops);\n\tif (IS_ERR(fimc->m2m.m2m_dev)) {\n\t\tv4l2_err(v4l2_dev, \"failed to initialize v4l2-m2m device\\n\");\n\t\treturn PTR_ERR(fimc->m2m.m2m_dev);\n\t}\n\n\tret = media_entity_pads_init(&vfd->entity, 0, NULL);\n\tif (ret)\n\t\tgoto err_me;\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, -1);\n\tif (ret)\n\t\tgoto err_vd;\n\n\tv4l2_info(v4l2_dev, \"Registered %s as /dev/%s\\n\",\n\t\t  vfd->name, video_device_node_name(vfd));\n\treturn 0;\n\nerr_vd:\n\tmedia_entity_cleanup(&vfd->entity);\nerr_me:\n\tv4l2_m2m_release(fimc->m2m.m2m_dev);\n\treturn ret;\n}\n\nvoid fimc_unregister_m2m_device(struct fimc_dev *fimc)\n{\n\tif (!fimc)\n\t\treturn;\n\n\tif (fimc->m2m.m2m_dev)\n\t\tv4l2_m2m_release(fimc->m2m.m2m_dev);\n\n\tif (video_is_registered(&fimc->m2m.vfd)) {\n\t\tvideo_unregister_device(&fimc->m2m.vfd);\n\t\tmedia_entity_cleanup(&fimc->m2m.vfd.entity);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}