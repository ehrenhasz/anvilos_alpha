{
  "module_name": "fimc-reg.c",
  "hash_id": "677e90456cc30f060fef4c1e41343814c0b442716560665ae864f86fec84959d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-reg.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/regmap.h>\n\n#include <media/drv-intf/exynos-fimc.h>\n#include \"media-dev.h\"\n\n#include \"fimc-reg.h\"\n#include \"fimc-core.h\"\n\nvoid fimc_hw_reset(struct fimc_dev *dev)\n{\n\tu32 cfg;\n\n\tcfg = readl(dev->regs + FIMC_REG_CISRCFMT);\n\tcfg |= FIMC_REG_CISRCFMT_ITU601_8BIT;\n\twritel(cfg, dev->regs + FIMC_REG_CISRCFMT);\n\n\t \n\tcfg = readl(dev->regs + FIMC_REG_CIGCTRL);\n\tcfg |= (FIMC_REG_CIGCTRL_SWRST | FIMC_REG_CIGCTRL_IRQ_LEVEL);\n\twritel(cfg, dev->regs + FIMC_REG_CIGCTRL);\n\tudelay(10);\n\n\tcfg = readl(dev->regs + FIMC_REG_CIGCTRL);\n\tcfg &= ~FIMC_REG_CIGCTRL_SWRST;\n\twritel(cfg, dev->regs + FIMC_REG_CIGCTRL);\n\n\tif (dev->drv_data->out_buf_count > 4)\n\t\tfimc_hw_set_dma_seq(dev, 0xF);\n}\n\nstatic u32 fimc_hw_get_in_flip(struct fimc_ctx *ctx)\n{\n\tu32 flip = FIMC_REG_MSCTRL_FLIP_NORMAL;\n\n\tif (ctx->hflip)\n\t\tflip = FIMC_REG_MSCTRL_FLIP_Y_MIRROR;\n\tif (ctx->vflip)\n\t\tflip = FIMC_REG_MSCTRL_FLIP_X_MIRROR;\n\n\tif (ctx->rotation <= 90)\n\t\treturn flip;\n\n\treturn (flip ^ FIMC_REG_MSCTRL_FLIP_180) & FIMC_REG_MSCTRL_FLIP_180;\n}\n\nstatic u32 fimc_hw_get_target_flip(struct fimc_ctx *ctx)\n{\n\tu32 flip = FIMC_REG_CITRGFMT_FLIP_NORMAL;\n\n\tif (ctx->hflip)\n\t\tflip |= FIMC_REG_CITRGFMT_FLIP_Y_MIRROR;\n\tif (ctx->vflip)\n\t\tflip |= FIMC_REG_CITRGFMT_FLIP_X_MIRROR;\n\n\tif (ctx->rotation <= 90)\n\t\treturn flip;\n\n\treturn (flip ^ FIMC_REG_CITRGFMT_FLIP_180) & FIMC_REG_CITRGFMT_FLIP_180;\n}\n\nvoid fimc_hw_set_rotation(struct fimc_ctx *ctx)\n{\n\tu32 cfg, flip;\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\n\tcfg = readl(dev->regs + FIMC_REG_CITRGFMT);\n\tcfg &= ~(FIMC_REG_CITRGFMT_INROT90 | FIMC_REG_CITRGFMT_OUTROT90 |\n\t\t FIMC_REG_CITRGFMT_FLIP_180);\n\n\t \n\tif (ctx->rotation == 90 || ctx->rotation == 270) {\n\t\tif (ctx->out_path == FIMC_IO_LCDFIFO)\n\t\t\tcfg |= FIMC_REG_CITRGFMT_INROT90;\n\t\telse\n\t\t\tcfg |= FIMC_REG_CITRGFMT_OUTROT90;\n\t}\n\n\tif (ctx->out_path == FIMC_IO_DMA) {\n\t\tcfg |= fimc_hw_get_target_flip(ctx);\n\t\twritel(cfg, dev->regs + FIMC_REG_CITRGFMT);\n\t} else {\n\t\t \n\t\tflip = readl(dev->regs + FIMC_REG_MSCTRL);\n\t\tflip &= ~FIMC_REG_MSCTRL_FLIP_MASK;\n\t\tflip |= fimc_hw_get_in_flip(ctx);\n\t\twritel(flip, dev->regs + FIMC_REG_MSCTRL);\n\t}\n}\n\nvoid fimc_hw_set_target_format(struct fimc_ctx *ctx)\n{\n\tu32 cfg;\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\tstruct fimc_frame *frame = &ctx->d_frame;\n\n\tdbg(\"w= %d, h= %d color: %d\", frame->width,\n\t    frame->height, frame->fmt->color);\n\n\tcfg = readl(dev->regs + FIMC_REG_CITRGFMT);\n\tcfg &= ~(FIMC_REG_CITRGFMT_FMT_MASK | FIMC_REG_CITRGFMT_HSIZE_MASK |\n\t\t FIMC_REG_CITRGFMT_VSIZE_MASK);\n\n\tswitch (frame->fmt->color) {\n\tcase FIMC_FMT_RGB444...FIMC_FMT_RGB888:\n\t\tcfg |= FIMC_REG_CITRGFMT_RGB;\n\t\tbreak;\n\tcase FIMC_FMT_YCBCR420:\n\t\tcfg |= FIMC_REG_CITRGFMT_YCBCR420;\n\t\tbreak;\n\tcase FIMC_FMT_YCBYCR422...FIMC_FMT_CRYCBY422:\n\t\tif (frame->fmt->colplanes == 1)\n\t\t\tcfg |= FIMC_REG_CITRGFMT_YCBCR422_1P;\n\t\telse\n\t\t\tcfg |= FIMC_REG_CITRGFMT_YCBCR422;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ctx->rotation == 90 || ctx->rotation == 270)\n\t\tcfg |= (frame->height << 16) | frame->width;\n\telse\n\t\tcfg |= (frame->width << 16) | frame->height;\n\n\twritel(cfg, dev->regs + FIMC_REG_CITRGFMT);\n\n\tcfg = readl(dev->regs + FIMC_REG_CITAREA);\n\tcfg &= ~FIMC_REG_CITAREA_MASK;\n\tcfg |= (frame->width * frame->height);\n\twritel(cfg, dev->regs + FIMC_REG_CITAREA);\n}\n\nstatic void fimc_hw_set_out_dma_size(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\tstruct fimc_frame *frame = &ctx->d_frame;\n\tu32 cfg;\n\n\tcfg = (frame->f_height << 16) | frame->f_width;\n\twritel(cfg, dev->regs + FIMC_REG_ORGOSIZE);\n\n\t \n\tcfg = readl(dev->regs + FIMC_REG_CIGCTRL);\n\tif (frame->f_width >= 1280)  \n\t\tcfg |= FIMC_REG_CIGCTRL_CSC_ITU601_709;\n\telse\t \n\t\tcfg &= ~FIMC_REG_CIGCTRL_CSC_ITU601_709;\n\twritel(cfg, dev->regs + FIMC_REG_CIGCTRL);\n\n}\n\nvoid fimc_hw_set_out_dma(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\tstruct fimc_frame *frame = &ctx->d_frame;\n\tstruct fimc_dma_offset *offset = &frame->dma_offset;\n\tstruct fimc_fmt *fmt = frame->fmt;\n\tu32 cfg;\n\n\t \n\tcfg = (offset->y_v << 16) | offset->y_h;\n\twritel(cfg, dev->regs + FIMC_REG_CIOYOFF);\n\n\tcfg = (offset->cb_v << 16) | offset->cb_h;\n\twritel(cfg, dev->regs + FIMC_REG_CIOCBOFF);\n\n\tcfg = (offset->cr_v << 16) | offset->cr_h;\n\twritel(cfg, dev->regs + FIMC_REG_CIOCROFF);\n\n\tfimc_hw_set_out_dma_size(ctx);\n\n\t \n\tcfg = readl(dev->regs + FIMC_REG_CIOCTRL);\n\n\tcfg &= ~(FIMC_REG_CIOCTRL_ORDER2P_MASK |\n\t\t FIMC_REG_CIOCTRL_ORDER422_MASK |\n\t\t FIMC_REG_CIOCTRL_YCBCR_PLANE_MASK |\n\t\t FIMC_REG_CIOCTRL_RGB16FMT_MASK);\n\n\tif (fmt->colplanes == 1)\n\t\tcfg |= ctx->out_order_1p;\n\telse if (fmt->colplanes == 2)\n\t\tcfg |= ctx->out_order_2p | FIMC_REG_CIOCTRL_YCBCR_2PLANE;\n\telse if (fmt->colplanes == 3)\n\t\tcfg |= FIMC_REG_CIOCTRL_YCBCR_3PLANE;\n\n\tif (fmt->color == FIMC_FMT_RGB565)\n\t\tcfg |= FIMC_REG_CIOCTRL_RGB565;\n\telse if (fmt->color == FIMC_FMT_RGB555)\n\t\tcfg |= FIMC_REG_CIOCTRL_ARGB1555;\n\telse if (fmt->color == FIMC_FMT_RGB444)\n\t\tcfg |= FIMC_REG_CIOCTRL_ARGB4444;\n\n\twritel(cfg, dev->regs + FIMC_REG_CIOCTRL);\n}\n\nstatic void fimc_hw_en_autoload(struct fimc_dev *dev, int enable)\n{\n\tu32 cfg = readl(dev->regs + FIMC_REG_ORGISIZE);\n\tif (enable)\n\t\tcfg |= FIMC_REG_CIREAL_ISIZE_AUTOLOAD_EN;\n\telse\n\t\tcfg &= ~FIMC_REG_CIREAL_ISIZE_AUTOLOAD_EN;\n\twritel(cfg, dev->regs + FIMC_REG_ORGISIZE);\n}\n\nvoid fimc_hw_en_lastirq(struct fimc_dev *dev, int enable)\n{\n\tu32 cfg = readl(dev->regs + FIMC_REG_CIOCTRL);\n\tif (enable)\n\t\tcfg |= FIMC_REG_CIOCTRL_LASTIRQ_ENABLE;\n\telse\n\t\tcfg &= ~FIMC_REG_CIOCTRL_LASTIRQ_ENABLE;\n\twritel(cfg, dev->regs + FIMC_REG_CIOCTRL);\n}\n\nvoid fimc_hw_set_prescaler(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *dev =  ctx->fimc_dev;\n\tstruct fimc_scaler *sc = &ctx->scaler;\n\tu32 cfg, shfactor;\n\n\tshfactor = 10 - (sc->hfactor + sc->vfactor);\n\tcfg = shfactor << 28;\n\n\tcfg |= (sc->pre_hratio << 16) | sc->pre_vratio;\n\twritel(cfg, dev->regs + FIMC_REG_CISCPRERATIO);\n\n\tcfg = (sc->pre_dst_width << 16) | sc->pre_dst_height;\n\twritel(cfg, dev->regs + FIMC_REG_CISCPREDST);\n}\n\nstatic void fimc_hw_set_scaler(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\tstruct fimc_scaler *sc = &ctx->scaler;\n\tstruct fimc_frame *src_frame = &ctx->s_frame;\n\tstruct fimc_frame *dst_frame = &ctx->d_frame;\n\n\tu32 cfg = readl(dev->regs + FIMC_REG_CISCCTRL);\n\n\tcfg &= ~(FIMC_REG_CISCCTRL_CSCR2Y_WIDE | FIMC_REG_CISCCTRL_CSCY2R_WIDE |\n\t\t FIMC_REG_CISCCTRL_SCALEUP_H | FIMC_REG_CISCCTRL_SCALEUP_V |\n\t\t FIMC_REG_CISCCTRL_SCALERBYPASS | FIMC_REG_CISCCTRL_ONE2ONE |\n\t\t FIMC_REG_CISCCTRL_INRGB_FMT_MASK | FIMC_REG_CISCCTRL_OUTRGB_FMT_MASK |\n\t\t FIMC_REG_CISCCTRL_INTERLACE | FIMC_REG_CISCCTRL_RGB_EXT);\n\n\tif (!(ctx->flags & FIMC_COLOR_RANGE_NARROW))\n\t\tcfg |= (FIMC_REG_CISCCTRL_CSCR2Y_WIDE |\n\t\t\tFIMC_REG_CISCCTRL_CSCY2R_WIDE);\n\n\tif (!sc->enabled)\n\t\tcfg |= FIMC_REG_CISCCTRL_SCALERBYPASS;\n\n\tif (sc->scaleup_h)\n\t\tcfg |= FIMC_REG_CISCCTRL_SCALEUP_H;\n\n\tif (sc->scaleup_v)\n\t\tcfg |= FIMC_REG_CISCCTRL_SCALEUP_V;\n\n\tif (sc->copy_mode)\n\t\tcfg |= FIMC_REG_CISCCTRL_ONE2ONE;\n\n\tif (ctx->in_path == FIMC_IO_DMA) {\n\t\tswitch (src_frame->fmt->color) {\n\t\tcase FIMC_FMT_RGB565:\n\t\t\tcfg |= FIMC_REG_CISCCTRL_INRGB_FMT_RGB565;\n\t\t\tbreak;\n\t\tcase FIMC_FMT_RGB666:\n\t\t\tcfg |= FIMC_REG_CISCCTRL_INRGB_FMT_RGB666;\n\t\t\tbreak;\n\t\tcase FIMC_FMT_RGB888:\n\t\t\tcfg |= FIMC_REG_CISCCTRL_INRGB_FMT_RGB888;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctx->out_path == FIMC_IO_DMA) {\n\t\tu32 color = dst_frame->fmt->color;\n\n\t\tif (color >= FIMC_FMT_RGB444 && color <= FIMC_FMT_RGB565)\n\t\t\tcfg |= FIMC_REG_CISCCTRL_OUTRGB_FMT_RGB565;\n\t\telse if (color == FIMC_FMT_RGB666)\n\t\t\tcfg |= FIMC_REG_CISCCTRL_OUTRGB_FMT_RGB666;\n\t\telse if (color == FIMC_FMT_RGB888)\n\t\t\tcfg |= FIMC_REG_CISCCTRL_OUTRGB_FMT_RGB888;\n\t} else {\n\t\tcfg |= FIMC_REG_CISCCTRL_OUTRGB_FMT_RGB888;\n\n\t\tif (ctx->flags & FIMC_SCAN_MODE_INTERLACED)\n\t\t\tcfg |= FIMC_REG_CISCCTRL_INTERLACE;\n\t}\n\n\twritel(cfg, dev->regs + FIMC_REG_CISCCTRL);\n}\n\nvoid fimc_hw_set_mainscaler(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\tconst struct fimc_variant *variant = dev->variant;\n\tstruct fimc_scaler *sc = &ctx->scaler;\n\tu32 cfg;\n\n\tdbg(\"main_hratio= 0x%X  main_vratio= 0x%X\",\n\t    sc->main_hratio, sc->main_vratio);\n\n\tfimc_hw_set_scaler(ctx);\n\n\tcfg = readl(dev->regs + FIMC_REG_CISCCTRL);\n\tcfg &= ~(FIMC_REG_CISCCTRL_MHRATIO_MASK |\n\t\t FIMC_REG_CISCCTRL_MVRATIO_MASK);\n\n\tif (variant->has_mainscaler_ext) {\n\t\tcfg |= FIMC_REG_CISCCTRL_MHRATIO_EXT(sc->main_hratio);\n\t\tcfg |= FIMC_REG_CISCCTRL_MVRATIO_EXT(sc->main_vratio);\n\t\twritel(cfg, dev->regs + FIMC_REG_CISCCTRL);\n\n\t\tcfg = readl(dev->regs + FIMC_REG_CIEXTEN);\n\n\t\tcfg &= ~(FIMC_REG_CIEXTEN_MVRATIO_EXT_MASK |\n\t\t\t FIMC_REG_CIEXTEN_MHRATIO_EXT_MASK);\n\t\tcfg |= FIMC_REG_CIEXTEN_MHRATIO_EXT(sc->main_hratio);\n\t\tcfg |= FIMC_REG_CIEXTEN_MVRATIO_EXT(sc->main_vratio);\n\t\twritel(cfg, dev->regs + FIMC_REG_CIEXTEN);\n\t} else {\n\t\tcfg |= FIMC_REG_CISCCTRL_MHRATIO(sc->main_hratio);\n\t\tcfg |= FIMC_REG_CISCCTRL_MVRATIO(sc->main_vratio);\n\t\twritel(cfg, dev->regs + FIMC_REG_CISCCTRL);\n\t}\n}\n\nvoid fimc_hw_enable_capture(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\tu32 cfg;\n\n\tcfg = readl(dev->regs + FIMC_REG_CIIMGCPT);\n\tcfg |= FIMC_REG_CIIMGCPT_CPT_FREN_ENABLE;\n\n\tif (ctx->scaler.enabled)\n\t\tcfg |= FIMC_REG_CIIMGCPT_IMGCPTEN_SC;\n\telse\n\t\tcfg &= FIMC_REG_CIIMGCPT_IMGCPTEN_SC;\n\n\tcfg |= FIMC_REG_CIIMGCPT_IMGCPTEN;\n\twritel(cfg, dev->regs + FIMC_REG_CIIMGCPT);\n}\n\nvoid fimc_hw_disable_capture(struct fimc_dev *dev)\n{\n\tu32 cfg = readl(dev->regs + FIMC_REG_CIIMGCPT);\n\tcfg &= ~(FIMC_REG_CIIMGCPT_IMGCPTEN |\n\t\t FIMC_REG_CIIMGCPT_IMGCPTEN_SC);\n\twritel(cfg, dev->regs + FIMC_REG_CIIMGCPT);\n}\n\nvoid fimc_hw_set_effect(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\tstruct fimc_effect *effect = &ctx->effect;\n\tu32 cfg = 0;\n\n\tif (effect->type != FIMC_REG_CIIMGEFF_FIN_BYPASS) {\n\t\tcfg |= FIMC_REG_CIIMGEFF_IE_SC_AFTER |\n\t\t\tFIMC_REG_CIIMGEFF_IE_ENABLE;\n\t\tcfg |= effect->type;\n\t\tif (effect->type == FIMC_REG_CIIMGEFF_FIN_ARBITRARY)\n\t\t\tcfg |= (effect->pat_cb << 13) | effect->pat_cr;\n\t}\n\n\twritel(cfg, dev->regs + FIMC_REG_CIIMGEFF);\n}\n\nvoid fimc_hw_set_rgb_alpha(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\tstruct fimc_frame *frame = &ctx->d_frame;\n\tu32 cfg;\n\n\tif (!(frame->fmt->flags & FMT_HAS_ALPHA))\n\t\treturn;\n\n\tcfg = readl(dev->regs + FIMC_REG_CIOCTRL);\n\tcfg &= ~FIMC_REG_CIOCTRL_ALPHA_OUT_MASK;\n\tcfg |= (frame->alpha << 4);\n\twritel(cfg, dev->regs + FIMC_REG_CIOCTRL);\n}\n\nstatic void fimc_hw_set_in_dma_size(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\tstruct fimc_frame *frame = &ctx->s_frame;\n\tu32 cfg_o = 0;\n\tu32 cfg_r = 0;\n\n\tif (FIMC_IO_LCDFIFO == ctx->out_path)\n\t\tcfg_r |= FIMC_REG_CIREAL_ISIZE_AUTOLOAD_EN;\n\n\tcfg_o |= (frame->f_height << 16) | frame->f_width;\n\tcfg_r |= (frame->height << 16) | frame->width;\n\n\twritel(cfg_o, dev->regs + FIMC_REG_ORGISIZE);\n\twritel(cfg_r, dev->regs + FIMC_REG_CIREAL_ISIZE);\n}\n\nvoid fimc_hw_set_in_dma(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\tstruct fimc_frame *frame = &ctx->s_frame;\n\tstruct fimc_dma_offset *offset = &frame->dma_offset;\n\tu32 cfg;\n\n\t \n\tcfg = (offset->y_v << 16) | offset->y_h;\n\twritel(cfg, dev->regs + FIMC_REG_CIIYOFF);\n\n\tcfg = (offset->cb_v << 16) | offset->cb_h;\n\twritel(cfg, dev->regs + FIMC_REG_CIICBOFF);\n\n\tcfg = (offset->cr_v << 16) | offset->cr_h;\n\twritel(cfg, dev->regs + FIMC_REG_CIICROFF);\n\n\t \n\tfimc_hw_set_in_dma_size(ctx);\n\n\t \n\tfimc_hw_en_autoload(dev, ctx->out_path == FIMC_IO_LCDFIFO);\n\n\t \n\tcfg = readl(dev->regs + FIMC_REG_MSCTRL);\n\tcfg &= ~(FIMC_REG_MSCTRL_INFORMAT_MASK\n\t\t | FIMC_REG_MSCTRL_IN_BURST_COUNT_MASK\n\t\t | FIMC_REG_MSCTRL_INPUT_MASK\n\t\t | FIMC_REG_MSCTRL_C_INT_IN_MASK\n\t\t | FIMC_REG_MSCTRL_2P_IN_ORDER_MASK\n\t\t | FIMC_REG_MSCTRL_ORDER422_MASK);\n\n\tcfg |= (FIMC_REG_MSCTRL_IN_BURST_COUNT(4)\n\t\t| FIMC_REG_MSCTRL_INPUT_MEMORY\n\t\t| FIMC_REG_MSCTRL_FIFO_CTRL_FULL);\n\n\tswitch (frame->fmt->color) {\n\tcase FIMC_FMT_RGB565...FIMC_FMT_RGB888:\n\t\tcfg |= FIMC_REG_MSCTRL_INFORMAT_RGB;\n\t\tbreak;\n\tcase FIMC_FMT_YCBCR420:\n\t\tcfg |= FIMC_REG_MSCTRL_INFORMAT_YCBCR420;\n\n\t\tif (frame->fmt->colplanes == 2)\n\t\t\tcfg |= ctx->in_order_2p | FIMC_REG_MSCTRL_C_INT_IN_2PLANE;\n\t\telse\n\t\t\tcfg |= FIMC_REG_MSCTRL_C_INT_IN_3PLANE;\n\n\t\tbreak;\n\tcase FIMC_FMT_YCBYCR422...FIMC_FMT_CRYCBY422:\n\t\tif (frame->fmt->colplanes == 1) {\n\t\t\tcfg |= ctx->in_order_1p\n\t\t\t\t| FIMC_REG_MSCTRL_INFORMAT_YCBCR422_1P;\n\t\t} else {\n\t\t\tcfg |= FIMC_REG_MSCTRL_INFORMAT_YCBCR422;\n\n\t\t\tif (frame->fmt->colplanes == 2)\n\t\t\t\tcfg |= ctx->in_order_2p\n\t\t\t\t\t| FIMC_REG_MSCTRL_C_INT_IN_2PLANE;\n\t\t\telse\n\t\t\t\tcfg |= FIMC_REG_MSCTRL_C_INT_IN_3PLANE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twritel(cfg, dev->regs + FIMC_REG_MSCTRL);\n\n\t \n\tcfg = readl(dev->regs + FIMC_REG_CIDMAPARAM);\n\tcfg &= ~FIMC_REG_CIDMAPARAM_TILE_MASK;\n\n\tif (tiled_fmt(ctx->s_frame.fmt))\n\t\tcfg |= FIMC_REG_CIDMAPARAM_R_64X32;\n\n\tif (tiled_fmt(ctx->d_frame.fmt))\n\t\tcfg |= FIMC_REG_CIDMAPARAM_W_64X32;\n\n\twritel(cfg, dev->regs + FIMC_REG_CIDMAPARAM);\n}\n\n\nvoid fimc_hw_set_input_path(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\n\tu32 cfg = readl(dev->regs + FIMC_REG_MSCTRL);\n\tcfg &= ~FIMC_REG_MSCTRL_INPUT_MASK;\n\n\tif (ctx->in_path == FIMC_IO_DMA)\n\t\tcfg |= FIMC_REG_MSCTRL_INPUT_MEMORY;\n\telse\n\t\tcfg |= FIMC_REG_MSCTRL_INPUT_EXTCAM;\n\n\twritel(cfg, dev->regs + FIMC_REG_MSCTRL);\n}\n\nvoid fimc_hw_set_output_path(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *dev = ctx->fimc_dev;\n\n\tu32 cfg = readl(dev->regs + FIMC_REG_CISCCTRL);\n\tcfg &= ~FIMC_REG_CISCCTRL_LCDPATHEN_FIFO;\n\tif (ctx->out_path == FIMC_IO_LCDFIFO)\n\t\tcfg |= FIMC_REG_CISCCTRL_LCDPATHEN_FIFO;\n\twritel(cfg, dev->regs + FIMC_REG_CISCCTRL);\n}\n\nvoid fimc_hw_set_input_addr(struct fimc_dev *dev, struct fimc_addr *addr)\n{\n\tu32 cfg = readl(dev->regs + FIMC_REG_CIREAL_ISIZE);\n\tcfg |= FIMC_REG_CIREAL_ISIZE_ADDR_CH_DIS;\n\twritel(cfg, dev->regs + FIMC_REG_CIREAL_ISIZE);\n\n\twritel(addr->y, dev->regs + FIMC_REG_CIIYSA(0));\n\twritel(addr->cb, dev->regs + FIMC_REG_CIICBSA(0));\n\twritel(addr->cr, dev->regs + FIMC_REG_CIICRSA(0));\n\n\tcfg &= ~FIMC_REG_CIREAL_ISIZE_ADDR_CH_DIS;\n\twritel(cfg, dev->regs + FIMC_REG_CIREAL_ISIZE);\n}\n\nvoid fimc_hw_set_output_addr(struct fimc_dev *dev,\n\t\t\t     struct fimc_addr *addr, int index)\n{\n\tint i = (index == -1) ? 0 : index;\n\tdo {\n\t\twritel(addr->y, dev->regs + FIMC_REG_CIOYSA(i));\n\t\twritel(addr->cb, dev->regs + FIMC_REG_CIOCBSA(i));\n\t\twritel(addr->cr, dev->regs + FIMC_REG_CIOCRSA(i));\n\t\tdbg(\"dst_buf[%d]: 0x%X, cb: 0x%X, cr: 0x%X\",\n\t\t    i, addr->y, addr->cb, addr->cr);\n\t} while (index == -1 && ++i < FIMC_MAX_OUT_BUFS);\n}\n\nint fimc_hw_set_camera_polarity(struct fimc_dev *fimc,\n\t\t\t\tstruct fimc_source_info *cam)\n{\n\tu32 cfg = readl(fimc->regs + FIMC_REG_CIGCTRL);\n\n\tcfg &= ~(FIMC_REG_CIGCTRL_INVPOLPCLK | FIMC_REG_CIGCTRL_INVPOLVSYNC |\n\t\t FIMC_REG_CIGCTRL_INVPOLHREF | FIMC_REG_CIGCTRL_INVPOLHSYNC |\n\t\t FIMC_REG_CIGCTRL_INVPOLFIELD);\n\n\tif (cam->flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\n\t\tcfg |= FIMC_REG_CIGCTRL_INVPOLPCLK;\n\n\tif (cam->flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\n\t\tcfg |= FIMC_REG_CIGCTRL_INVPOLVSYNC;\n\n\tif (cam->flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\n\t\tcfg |= FIMC_REG_CIGCTRL_INVPOLHREF;\n\n\tif (cam->flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\n\t\tcfg |= FIMC_REG_CIGCTRL_INVPOLHSYNC;\n\n\tif (cam->flags & V4L2_MBUS_FIELD_EVEN_LOW)\n\t\tcfg |= FIMC_REG_CIGCTRL_INVPOLFIELD;\n\n\twritel(cfg, fimc->regs + FIMC_REG_CIGCTRL);\n\n\treturn 0;\n}\n\nstruct mbus_pixfmt_desc {\n\tu32 pixelcode;\n\tu32 cisrcfmt;\n\tu16 bus_width;\n};\n\nstatic const struct mbus_pixfmt_desc pix_desc[] = {\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, FIMC_REG_CISRCFMT_ORDER422_YCBYCR, 8 },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, FIMC_REG_CISRCFMT_ORDER422_YCRYCB, 8 },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, FIMC_REG_CISRCFMT_ORDER422_CRYCBY, 8 },\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, FIMC_REG_CISRCFMT_ORDER422_CBYCRY, 8 },\n};\n\nint fimc_hw_set_camera_source(struct fimc_dev *fimc,\n\t\t\t      struct fimc_source_info *source)\n{\n\tstruct fimc_vid_cap *vc = &fimc->vid_cap;\n\tstruct fimc_frame *f = &vc->ctx->s_frame;\n\tu32 bus_width, cfg = 0;\n\tint i;\n\n\tswitch (source->fimc_bus_type) {\n\tcase FIMC_BUS_TYPE_ITU_601:\n\tcase FIMC_BUS_TYPE_ITU_656:\n\t\tif (fimc_fmt_is_user_defined(f->fmt->color)) {\n\t\t\tcfg |= FIMC_REG_CISRCFMT_ITU601_8BIT;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(pix_desc); i++) {\n\t\t\tif (vc->ci_fmt.code == pix_desc[i].pixelcode) {\n\t\t\t\tcfg = pix_desc[i].cisrcfmt;\n\t\t\t\tbus_width = pix_desc[i].bus_width;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(pix_desc)) {\n\t\t\tv4l2_err(&vc->ve.vdev,\n\t\t\t\t \"Camera color format not supported: %d\\n\",\n\t\t\t\t vc->ci_fmt.code);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (source->fimc_bus_type == FIMC_BUS_TYPE_ITU_601) {\n\t\t\tif (bus_width == 8)\n\t\t\t\tcfg |= FIMC_REG_CISRCFMT_ITU601_8BIT;\n\t\t\telse if (bus_width == 16)\n\t\t\t\tcfg |= FIMC_REG_CISRCFMT_ITU601_16BIT;\n\t\t}  \n\t\tbreak;\n\tcase FIMC_BUS_TYPE_MIPI_CSI2:\n\t\tif (fimc_fmt_is_user_defined(f->fmt->color))\n\t\t\tcfg |= FIMC_REG_CISRCFMT_ITU601_8BIT;\n\t\tbreak;\n\tdefault:\n\tcase FIMC_BUS_TYPE_ISP_WRITEBACK:\n\t\t \n\t\tbreak;\n\t}\n\n\tcfg |= (f->o_width << 16) | f->o_height;\n\twritel(cfg, fimc->regs + FIMC_REG_CISRCFMT);\n\treturn 0;\n}\n\nvoid fimc_hw_set_camera_offset(struct fimc_dev *fimc, struct fimc_frame *f)\n{\n\tu32 hoff2, voff2;\n\n\tu32 cfg = readl(fimc->regs + FIMC_REG_CIWDOFST);\n\n\tcfg &= ~(FIMC_REG_CIWDOFST_HOROFF_MASK | FIMC_REG_CIWDOFST_VEROFF_MASK);\n\tcfg |=  FIMC_REG_CIWDOFST_OFF_EN |\n\t\t(f->offs_h << 16) | f->offs_v;\n\n\twritel(cfg, fimc->regs + FIMC_REG_CIWDOFST);\n\n\t \n\thoff2 = f->o_width - f->width - f->offs_h;\n\tvoff2 = f->o_height - f->height - f->offs_v;\n\tcfg = (hoff2 << 16) | voff2;\n\twritel(cfg, fimc->regs + FIMC_REG_CIWDOFST2);\n}\n\nint fimc_hw_set_camera_type(struct fimc_dev *fimc,\n\t\t\t    struct fimc_source_info *source)\n{\n\tstruct fimc_vid_cap *vid_cap = &fimc->vid_cap;\n\tu32 csis_data_alignment = 32;\n\tu32 cfg, tmp;\n\n\tcfg = readl(fimc->regs + FIMC_REG_CIGCTRL);\n\n\t \n\tcfg &= ~(FIMC_REG_CIGCTRL_TESTPAT_MASK | FIMC_REG_CIGCTRL_SELCAM_ITU_A |\n\t\tFIMC_REG_CIGCTRL_SELCAM_MIPI | FIMC_REG_CIGCTRL_CAMIF_SELWB |\n\t\tFIMC_REG_CIGCTRL_SELCAM_MIPI_A | FIMC_REG_CIGCTRL_CAM_JPEG |\n\t\tFIMC_REG_CIGCTRL_SELWB_A);\n\n\tswitch (source->fimc_bus_type) {\n\tcase FIMC_BUS_TYPE_MIPI_CSI2:\n\t\tcfg |= FIMC_REG_CIGCTRL_SELCAM_MIPI;\n\n\t\tif (source->mux_id == 0)\n\t\t\tcfg |= FIMC_REG_CIGCTRL_SELCAM_MIPI_A;\n\n\t\t \n\t\tswitch (vid_cap->ci_fmt.code) {\n\t\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\t\t\ttmp = FIMC_REG_CSIIMGFMT_YCBCR422_8BIT;\n\t\t\tbreak;\n\t\tcase MEDIA_BUS_FMT_JPEG_1X8:\n\t\tcase MEDIA_BUS_FMT_S5C_UYVY_JPEG_1X8:\n\t\t\ttmp = FIMC_REG_CSIIMGFMT_USER(1);\n\t\t\tcfg |= FIMC_REG_CIGCTRL_CAM_JPEG;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv4l2_err(&vid_cap->ve.vdev,\n\t\t\t\t \"Not supported camera pixel format: %#x\\n\",\n\t\t\t\t vid_cap->ci_fmt.code);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp |= (csis_data_alignment == 32) << 8;\n\n\t\twritel(tmp, fimc->regs + FIMC_REG_CSIIMGFMT);\n\t\tbreak;\n\tcase FIMC_BUS_TYPE_ITU_601...FIMC_BUS_TYPE_ITU_656:\n\t\tif (source->mux_id == 0)  \n\t\t\tcfg |= FIMC_REG_CIGCTRL_SELCAM_ITU_A;\n\t\tif (vid_cap->ci_fmt.code == MEDIA_BUS_FMT_JPEG_1X8)\n\t\t\tcfg |= FIMC_REG_CIGCTRL_CAM_JPEG;\n\t\tbreak;\n\tcase FIMC_BUS_TYPE_LCD_WRITEBACK_A:\n\t\tcfg |= FIMC_REG_CIGCTRL_CAMIF_SELWB;\n\t\tfallthrough;\n\tcase FIMC_BUS_TYPE_ISP_WRITEBACK:\n\t\tif (fimc->variant->has_isp_wb)\n\t\t\tcfg |= FIMC_REG_CIGCTRL_CAMIF_SELWB;\n\t\telse\n\t\t\tWARN_ONCE(1, \"ISP Writeback input is not supported\\n\");\n\t\tbreak;\n\tdefault:\n\t\tv4l2_err(&vid_cap->ve.vdev,\n\t\t\t \"Invalid FIMC bus type selected: %d\\n\",\n\t\t\t source->fimc_bus_type);\n\t\treturn -EINVAL;\n\t}\n\twritel(cfg, fimc->regs + FIMC_REG_CIGCTRL);\n\n\treturn 0;\n}\n\nvoid fimc_hw_clear_irq(struct fimc_dev *dev)\n{\n\tu32 cfg = readl(dev->regs + FIMC_REG_CIGCTRL);\n\tcfg |= FIMC_REG_CIGCTRL_IRQ_CLR;\n\twritel(cfg, dev->regs + FIMC_REG_CIGCTRL);\n}\n\nvoid fimc_hw_enable_scaler(struct fimc_dev *dev, bool on)\n{\n\tu32 cfg = readl(dev->regs + FIMC_REG_CISCCTRL);\n\tif (on)\n\t\tcfg |= FIMC_REG_CISCCTRL_SCALERSTART;\n\telse\n\t\tcfg &= ~FIMC_REG_CISCCTRL_SCALERSTART;\n\twritel(cfg, dev->regs + FIMC_REG_CISCCTRL);\n}\n\nvoid fimc_hw_activate_input_dma(struct fimc_dev *dev, bool on)\n{\n\tu32 cfg = readl(dev->regs + FIMC_REG_MSCTRL);\n\tif (on)\n\t\tcfg |= FIMC_REG_MSCTRL_ENVID;\n\telse\n\t\tcfg &= ~FIMC_REG_MSCTRL_ENVID;\n\twritel(cfg, dev->regs + FIMC_REG_MSCTRL);\n}\n\n \ns32 fimc_hw_get_frame_index(struct fimc_dev *dev)\n{\n\ts32 reg;\n\n\tif (dev->drv_data->cistatus2) {\n\t\treg = readl(dev->regs + FIMC_REG_CISTATUS2) & 0x3f;\n\t\treturn reg - 1;\n\t}\n\n\treg = readl(dev->regs + FIMC_REG_CISTATUS);\n\n\treturn (reg & FIMC_REG_CISTATUS_FRAMECNT_MASK) >>\n\t\tFIMC_REG_CISTATUS_FRAMECNT_SHIFT;\n}\n\n \ns32 fimc_hw_get_prev_frame_index(struct fimc_dev *dev)\n{\n\ts32 reg;\n\n\tif (!dev->drv_data->cistatus2)\n\t\treturn -1;\n\n\treg = readl(dev->regs + FIMC_REG_CISTATUS2);\n\treturn ((reg >> 7) & 0x3f) - 1;\n}\n\n \nvoid fimc_activate_capture(struct fimc_ctx *ctx)\n{\n\tfimc_hw_enable_scaler(ctx->fimc_dev, ctx->scaler.enabled);\n\tfimc_hw_enable_capture(ctx);\n}\n\nvoid fimc_deactivate_capture(struct fimc_dev *fimc)\n{\n\tfimc_hw_en_lastirq(fimc, true);\n\tfimc_hw_disable_capture(fimc);\n\tfimc_hw_enable_scaler(fimc, false);\n\tfimc_hw_en_lastirq(fimc, false);\n}\n\nint fimc_hw_camblk_cfg_writeback(struct fimc_dev *fimc)\n{\n\tstruct regmap *map = fimc->sysreg;\n\tunsigned int mask, val, camblk_cfg;\n\tint ret;\n\n\tif (map == NULL)\n\t\treturn 0;\n\n\tret = regmap_read(map, SYSREG_CAMBLK, &camblk_cfg);\n\tif (ret < 0 || ((camblk_cfg & 0x00700000) >> 20 != 0x3))\n\t\treturn ret;\n\n\tif (!WARN(fimc->id >= 3, \"not supported id: %d\\n\", fimc->id))\n\t\tval = 0x1 << (fimc->id + 20);\n\telse\n\t\tval = 0;\n\n\tmask = SYSREG_CAMBLK_FIFORST_ISP | SYSREG_CAMBLK_ISPWB_FULL_EN;\n\tret = regmap_update_bits(map, SYSREG_CAMBLK, mask, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(1000, 2000);\n\n\tval |= SYSREG_CAMBLK_FIFORST_ISP;\n\tret = regmap_update_bits(map, SYSREG_CAMBLK, mask, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmask = SYSREG_ISPBLK_FIFORST_CAM_BLK;\n\tret = regmap_update_bits(map, SYSREG_ISPBLK, mask, ~mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(1000, 2000);\n\n\treturn regmap_update_bits(map, SYSREG_ISPBLK, mask, mask);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}