{
  "module_name": "fimc-isp.c",
  "hash_id": "510f58e8472d8acab5b82bbe489cc670646867650be3cf39c49a588975e93fcf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-isp.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"%s:%d \" fmt, __func__, __LINE__\n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <media/v4l2-device.h>\n\n#include \"media-dev.h\"\n#include \"fimc-isp-video.h\"\n#include \"fimc-is-command.h\"\n#include \"fimc-is-param.h\"\n#include \"fimc-is-regs.h\"\n#include \"fimc-is.h\"\n\nint fimc_isp_debug;\nmodule_param_named(debug_isp, fimc_isp_debug, int, S_IRUGO | S_IWUSR);\n\nstatic const struct fimc_fmt fimc_isp_formats[FIMC_ISP_NUM_FORMATS] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.depth\t\t= { 8 },\n\t\t.color\t\t= FIMC_FMT_RAW8,\n\t\t.memplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG10,\n\t\t.depth\t\t= { 10 },\n\t\t.color\t\t= FIMC_FMT_RAW10,\n\t\t.memplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG10_1X10,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG12,\n\t\t.depth\t\t= { 12 },\n\t\t.color\t\t= FIMC_FMT_RAW12,\n\t\t.memplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG12_1X12,\n\t},\n};\n\n \nconst struct fimc_fmt *fimc_isp_find_format(const u32 *pixelformat,\n\t\t\t\t\tconst u32 *mbus_code, int index)\n{\n\tconst struct fimc_fmt *fmt, *def_fmt = NULL;\n\tunsigned int i;\n\tint id = 0;\n\n\tif (index >= (int)ARRAY_SIZE(fimc_isp_formats))\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(fimc_isp_formats); ++i) {\n\t\tfmt = &fimc_isp_formats[i];\n\t\tif (pixelformat && fmt->fourcc == *pixelformat)\n\t\t\treturn fmt;\n\t\tif (mbus_code && fmt->mbus_code == *mbus_code)\n\t\t\treturn fmt;\n\t\tif (index == id)\n\t\t\tdef_fmt = fmt;\n\t\tid++;\n\t}\n\treturn def_fmt;\n}\n\nvoid fimc_isp_irq_handler(struct fimc_is *is)\n{\n\tis->i2h_cmd.args[0] = mcuctl_read(is, MCUCTL_REG_ISSR(20));\n\tis->i2h_cmd.args[1] = mcuctl_read(is, MCUCTL_REG_ISSR(21));\n\n\tfimc_is_fw_clear_irq1(is, FIMC_IS_INT_FRAME_DONE_ISP);\n\tfimc_isp_video_irq_handler(is);\n\n\twake_up(&is->irq_queue);\n}\n\n \nstatic int fimc_is_link_setup(struct media_entity *entity,\n\t\t\t\tconst struct media_pad *local,\n\t\t\t\tconst struct media_pad *remote, u32 flags)\n{\n\treturn 0;\n}\n\nstatic const struct media_entity_operations fimc_is_subdev_media_ops = {\n\t.link_setup = fimc_is_link_setup,\n};\n\nstatic int fimc_is_subdev_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tconst struct fimc_fmt *fmt;\n\n\tfmt = fimc_isp_find_format(NULL, NULL, code->index);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\tcode->code = fmt->mbus_code;\n\treturn 0;\n}\n\nstatic int fimc_isp_subdev_get_fmt(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct fimc_isp *isp = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *mf = &fmt->format;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t*mf = *v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);\n\t\treturn 0;\n\t}\n\n\tmf->colorspace = V4L2_COLORSPACE_SRGB;\n\n\tmutex_lock(&isp->subdev_lock);\n\n\tif (fmt->pad == FIMC_ISP_SD_PAD_SINK) {\n\t\t \n\t\t*mf = isp->sink_fmt;\n\t} else {\n\t\t \n\t\t*mf = isp->src_fmt;\n\n\t\tif (fmt->pad == FIMC_ISP_SD_PAD_SRC_FIFO) {\n\t\t\tmf->colorspace = V4L2_COLORSPACE_JPEG;\n\t\t\tmf->code = MEDIA_BUS_FMT_YUV10_1X30;\n\t\t}\n\t}\n\n\tmutex_unlock(&isp->subdev_lock);\n\n\tisp_dbg(1, sd, \"%s: pad%d: fmt: 0x%x, %dx%d\\n\", __func__,\n\t\tfmt->pad, mf->code, mf->width, mf->height);\n\n\treturn 0;\n}\n\nstatic void __isp_subdev_try_format(struct fimc_isp *isp,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct v4l2_mbus_framefmt *mf = &fmt->format;\n\tstruct v4l2_mbus_framefmt *format;\n\n\tmf->colorspace = V4L2_COLORSPACE_SRGB;\n\n\tif (fmt->pad == FIMC_ISP_SD_PAD_SINK) {\n\t\tv4l_bound_align_image(&mf->width, FIMC_ISP_SINK_WIDTH_MIN,\n\t\t\t\tFIMC_ISP_SINK_WIDTH_MAX, 0,\n\t\t\t\t&mf->height, FIMC_ISP_SINK_HEIGHT_MIN,\n\t\t\t\tFIMC_ISP_SINK_HEIGHT_MAX, 0, 0);\n\t\tmf->code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\t} else {\n\t\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY)\n\t\t\tformat = v4l2_subdev_get_try_format(&isp->subdev,\n\t\t\t\t\t\t\t    sd_state,\n\t\t\t\t\t\t\t    FIMC_ISP_SD_PAD_SINK);\n\t\telse\n\t\t\tformat = &isp->sink_fmt;\n\n\t\t \n\t\tmf->width = format->width - FIMC_ISP_CAC_MARGIN_WIDTH;\n\t\tmf->height = format->height - FIMC_ISP_CAC_MARGIN_HEIGHT;\n\n\t\tif (fmt->pad == FIMC_ISP_SD_PAD_SRC_FIFO) {\n\t\t\tmf->code = MEDIA_BUS_FMT_YUV10_1X30;\n\t\t\tmf->colorspace = V4L2_COLORSPACE_JPEG;\n\t\t} else {\n\t\t\tmf->code = format->code;\n\t\t}\n\t}\n}\n\nstatic int fimc_isp_subdev_set_fmt(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct fimc_isp *isp = v4l2_get_subdevdata(sd);\n\tstruct fimc_is *is = fimc_isp_to_is(isp);\n\tstruct v4l2_mbus_framefmt *mf = &fmt->format;\n\tint ret = 0;\n\n\tisp_dbg(1, sd, \"%s: pad%d: code: 0x%x, %dx%d\\n\",\n\t\t __func__, fmt->pad, mf->code, mf->width, mf->height);\n\n\tmutex_lock(&isp->subdev_lock);\n\t__isp_subdev_try_format(isp, sd_state, fmt);\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);\n\t\t*mf = fmt->format;\n\n\t\t \n\t\tif (fmt->pad == FIMC_ISP_SD_PAD_SINK) {\n\t\t\tstruct v4l2_subdev_format format = *fmt;\n\t\t\tunsigned int pad;\n\n\t\t\tfor (pad = FIMC_ISP_SD_PAD_SRC_FIFO;\n\t\t\t\t\tpad < FIMC_ISP_SD_PADS_NUM; pad++) {\n\t\t\t\tformat.pad = pad;\n\t\t\t\t__isp_subdev_try_format(isp, sd_state,\n\t\t\t\t\t\t\t&format);\n\t\t\t\tmf = v4l2_subdev_get_try_format(sd, sd_state,\n\t\t\t\t\t\t\t\tpad);\n\t\t\t\t*mf = format.format;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!media_entity_is_streaming(&sd->entity)) {\n\t\t\tif (fmt->pad == FIMC_ISP_SD_PAD_SINK) {\n\t\t\t\tstruct v4l2_subdev_format format = *fmt;\n\n\t\t\t\tisp->sink_fmt = *mf;\n\n\t\t\t\tformat.pad = FIMC_ISP_SD_PAD_SRC_DMA;\n\t\t\t\t__isp_subdev_try_format(isp, sd_state,\n\t\t\t\t\t\t\t&format);\n\n\t\t\t\tisp->src_fmt = format.format;\n\t\t\t\t__is_set_frame_size(is, &isp->src_fmt);\n\t\t\t} else {\n\t\t\t\tisp->src_fmt = *mf;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EBUSY;\n\t\t}\n\t}\n\n\tmutex_unlock(&isp->subdev_lock);\n\treturn ret;\n}\n\nstatic int fimc_isp_subdev_s_stream(struct v4l2_subdev *sd, int on)\n{\n\tstruct fimc_isp *isp = v4l2_get_subdevdata(sd);\n\tstruct fimc_is *is = fimc_isp_to_is(isp);\n\tint ret;\n\n\tisp_dbg(1, sd, \"%s: on: %d\\n\", __func__, on);\n\n\tif (!test_bit(IS_ST_INIT_DONE, &is->state))\n\t\treturn -EBUSY;\n\n\tfimc_is_mem_barrier();\n\n\tif (on) {\n\t\tif (__get_pending_param_count(is)) {\n\t\t\tret = fimc_is_itf_s_param(is, true);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tisp_dbg(1, sd, \"changing mode to %d\\n\", is->config_index);\n\n\t\tret = fimc_is_itf_mode_change(is);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\tclear_bit(IS_ST_STREAM_ON, &is->state);\n\t\tfimc_is_hw_stream_on(is);\n\t\tret = fimc_is_wait_event(is, IS_ST_STREAM_ON, 1,\n\t\t\t\t\t FIMC_IS_CONFIG_TIMEOUT);\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(sd, \"stream on timeout\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tclear_bit(IS_ST_STREAM_OFF, &is->state);\n\t\tfimc_is_hw_stream_off(is);\n\t\tret = fimc_is_wait_event(is, IS_ST_STREAM_OFF, 1,\n\t\t\t\t\t FIMC_IS_CONFIG_TIMEOUT);\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(sd, \"stream off timeout\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tis->setfile.sub_index = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int fimc_isp_subdev_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct fimc_isp *isp = v4l2_get_subdevdata(sd);\n\tstruct fimc_is *is = fimc_isp_to_is(isp);\n\tint ret = 0;\n\n\tpr_debug(\"on: %d\\n\", on);\n\n\tif (on) {\n\t\tret = pm_runtime_resume_and_get(&is->pdev->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tset_bit(IS_ST_PWR_ON, &is->state);\n\n\t\tret = fimc_is_start_firmware(is);\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(sd, \"firmware booting failed\\n\");\n\t\t\tpm_runtime_put(&is->pdev->dev);\n\t\t\treturn ret;\n\t\t}\n\t\tset_bit(IS_ST_PWR_SUBIP_ON, &is->state);\n\n\t\tret = fimc_is_hw_initialize(is);\n\t} else {\n\t\t \n\t\tif (!test_bit(IS_ST_PWR_ON, &is->state)) {\n\t\t\tfimc_is_hw_close_sensor(is, 0);\n\n\t\t\tret = fimc_is_wait_event(is, IS_ST_OPEN_SENSOR, 0,\n\t\t\t\t\t\t FIMC_IS_CONFIG_TIMEOUT);\n\t\t\tif (ret < 0) {\n\t\t\t\tv4l2_err(sd, \"sensor close timeout\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (test_bit(IS_ST_PWR_SUBIP_ON, &is->state)) {\n\t\t\tfimc_is_hw_subip_power_off(is);\n\t\t\tret = fimc_is_wait_event(is, IS_ST_PWR_SUBIP_ON, 0,\n\t\t\t\t\t\t FIMC_IS_CONFIG_TIMEOUT);\n\t\t\tif (ret < 0) {\n\t\t\t\tv4l2_err(sd, \"sub-IP power off timeout\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tfimc_is_cpu_set_power(is, 0);\n\t\tpm_runtime_put_sync(&is->pdev->dev);\n\n\t\tclear_bit(IS_ST_PWR_ON, &is->state);\n\t\tclear_bit(IS_ST_INIT_DONE, &is->state);\n\t\tis->state = 0;\n\t\tis->config[is->config_index].p_region_index[0] = 0;\n\t\tis->config[is->config_index].p_region_index[1] = 0;\n\t\tset_bit(IS_ST_IDLE, &is->state);\n\t\twmb();\n\t}\n\n\treturn ret;\n}\n\nstatic int fimc_isp_subdev_open(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_mbus_framefmt fmt = {\n\t\t.colorspace = V4L2_COLORSPACE_SRGB,\n\t\t.code = fimc_isp_formats[0].mbus_code,\n\t\t.width = DEFAULT_PREVIEW_STILL_WIDTH + FIMC_ISP_CAC_MARGIN_WIDTH,\n\t\t.height = DEFAULT_PREVIEW_STILL_HEIGHT + FIMC_ISP_CAC_MARGIN_HEIGHT,\n\t\t.field = V4L2_FIELD_NONE,\n\t};\n\n\tformat = v4l2_subdev_get_try_format(sd, fh->state,\n\t\t\t\t\t    FIMC_ISP_SD_PAD_SINK);\n\t*format = fmt;\n\n\tformat = v4l2_subdev_get_try_format(sd, fh->state,\n\t\t\t\t\t    FIMC_ISP_SD_PAD_SRC_FIFO);\n\tfmt.width = DEFAULT_PREVIEW_STILL_WIDTH;\n\tfmt.height = DEFAULT_PREVIEW_STILL_HEIGHT;\n\t*format = fmt;\n\n\tformat = v4l2_subdev_get_try_format(sd, fh->state,\n\t\t\t\t\t    FIMC_ISP_SD_PAD_SRC_DMA);\n\t*format = fmt;\n\n\treturn 0;\n}\n\nstatic int fimc_isp_subdev_registered(struct v4l2_subdev *sd)\n{\n\tstruct fimc_isp *isp = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\t \n\tisp->video_capture.ve.pipe = v4l2_get_subdev_hostdata(sd);\n\n\tret = fimc_isp_video_device_register(isp, sd->v4l2_dev,\n\t\t\tV4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (ret < 0)\n\t\tisp->video_capture.ve.pipe = NULL;\n\n\treturn ret;\n}\n\nstatic void fimc_isp_subdev_unregistered(struct v4l2_subdev *sd)\n{\n\tstruct fimc_isp *isp = v4l2_get_subdevdata(sd);\n\n\tfimc_isp_video_device_unregister(isp,\n\t\t\tV4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n}\n\nstatic const struct v4l2_subdev_internal_ops fimc_is_subdev_internal_ops = {\n\t.registered = fimc_isp_subdev_registered,\n\t.unregistered = fimc_isp_subdev_unregistered,\n\t.open = fimc_isp_subdev_open,\n};\n\nstatic const struct v4l2_subdev_pad_ops fimc_is_subdev_pad_ops = {\n\t.enum_mbus_code = fimc_is_subdev_enum_mbus_code,\n\t.get_fmt = fimc_isp_subdev_get_fmt,\n\t.set_fmt = fimc_isp_subdev_set_fmt,\n};\n\nstatic const struct v4l2_subdev_video_ops fimc_is_subdev_video_ops = {\n\t.s_stream = fimc_isp_subdev_s_stream,\n};\n\nstatic const struct v4l2_subdev_core_ops fimc_is_core_ops = {\n\t.s_power = fimc_isp_subdev_s_power,\n};\n\nstatic const struct v4l2_subdev_ops fimc_is_subdev_ops = {\n\t.core = &fimc_is_core_ops,\n\t.video = &fimc_is_subdev_video_ops,\n\t.pad = &fimc_is_subdev_pad_ops,\n};\n\nstatic int __ctrl_set_white_balance(struct fimc_is *is, int value)\n{\n\tswitch (value) {\n\tcase V4L2_WHITE_BALANCE_AUTO:\n\t\t__is_set_isp_awb(is, ISP_AWB_COMMAND_AUTO, 0);\n\t\tbreak;\n\tcase V4L2_WHITE_BALANCE_DAYLIGHT:\n\t\t__is_set_isp_awb(is, ISP_AWB_COMMAND_ILLUMINATION,\n\t\t\t\t\tISP_AWB_ILLUMINATION_DAYLIGHT);\n\t\tbreak;\n\tcase V4L2_WHITE_BALANCE_CLOUDY:\n\t\t__is_set_isp_awb(is, ISP_AWB_COMMAND_ILLUMINATION,\n\t\t\t\t\tISP_AWB_ILLUMINATION_CLOUDY);\n\t\tbreak;\n\tcase V4L2_WHITE_BALANCE_INCANDESCENT:\n\t\t__is_set_isp_awb(is, ISP_AWB_COMMAND_ILLUMINATION,\n\t\t\t\t\tISP_AWB_ILLUMINATION_TUNGSTEN);\n\t\tbreak;\n\tcase V4L2_WHITE_BALANCE_FLUORESCENT:\n\t\t__is_set_isp_awb(is, ISP_AWB_COMMAND_ILLUMINATION,\n\t\t\t\t\tISP_AWB_ILLUMINATION_FLUORESCENT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __ctrl_set_aewb_lock(struct fimc_is *is,\n\t\t\t\t      struct v4l2_ctrl *ctrl)\n{\n\tbool awb_lock = ctrl->val & V4L2_LOCK_WHITE_BALANCE;\n\tbool ae_lock = ctrl->val & V4L2_LOCK_EXPOSURE;\n\tstruct isp_param *isp = &is->is_p_region->parameter.isp;\n\tint cmd, ret;\n\n\tcmd = ae_lock ? ISP_AA_COMMAND_STOP : ISP_AA_COMMAND_START;\n\tisp->aa.cmd = cmd;\n\tisp->aa.target = ISP_AA_TARGET_AE;\n\tfimc_is_set_param_bit(is, PARAM_ISP_AA);\n\tis->af.ae_lock_state = ae_lock;\n\twmb();\n\n\tret = fimc_is_itf_s_param(is, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcmd = awb_lock ? ISP_AA_COMMAND_STOP : ISP_AA_COMMAND_START;\n\tisp->aa.cmd = cmd;\n\tisp->aa.target = ISP_AA_TARGET_AE;\n\tfimc_is_set_param_bit(is, PARAM_ISP_AA);\n\tis->af.awb_lock_state = awb_lock;\n\twmb();\n\n\treturn fimc_is_itf_s_param(is, false);\n}\n\n \nstatic const s64 iso_qmenu[] = {\n\t50, 100, 200, 400, 800,\n};\n\nstatic int __ctrl_set_iso(struct fimc_is *is, int value)\n{\n\tunsigned int idx, iso;\n\n\tif (value == V4L2_ISO_SENSITIVITY_AUTO) {\n\t\t__is_set_isp_iso(is, ISP_ISO_COMMAND_AUTO, 0);\n\t\treturn 0;\n\t}\n\tidx = is->isp.ctrls.iso->val;\n\tif (idx >= ARRAY_SIZE(iso_qmenu))\n\t\treturn -EINVAL;\n\n\tiso = iso_qmenu[idx];\n\t__is_set_isp_iso(is, ISP_ISO_COMMAND_MANUAL, iso);\n\treturn 0;\n}\n\nstatic int __ctrl_set_metering(struct fimc_is *is, unsigned int value)\n{\n\tunsigned int val;\n\n\tswitch (value) {\n\tcase V4L2_EXPOSURE_METERING_AVERAGE:\n\t\tval = ISP_METERING_COMMAND_AVERAGE;\n\t\tbreak;\n\tcase V4L2_EXPOSURE_METERING_CENTER_WEIGHTED:\n\t\tval = ISP_METERING_COMMAND_CENTER;\n\t\tbreak;\n\tcase V4L2_EXPOSURE_METERING_SPOT:\n\t\tval = ISP_METERING_COMMAND_SPOT;\n\t\tbreak;\n\tcase V4L2_EXPOSURE_METERING_MATRIX:\n\t\tval = ISP_METERING_COMMAND_MATRIX;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t__is_set_isp_metering(is, IS_METERING_CONFIG_CMD, val);\n\treturn 0;\n}\n\nstatic int __ctrl_set_afc(struct fimc_is *is, int value)\n{\n\tswitch (value) {\n\tcase V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:\n\t\t__is_set_isp_afc(is, ISP_AFC_COMMAND_DISABLE, 0);\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY_50HZ:\n\t\t__is_set_isp_afc(is, ISP_AFC_COMMAND_MANUAL, 50);\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY_60HZ:\n\t\t__is_set_isp_afc(is, ISP_AFC_COMMAND_MANUAL, 60);\n\t\tbreak;\n\tcase V4L2_CID_POWER_LINE_FREQUENCY_AUTO:\n\t\t__is_set_isp_afc(is, ISP_AFC_COMMAND_AUTO, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __ctrl_set_image_effect(struct fimc_is *is, int value)\n{\n\tstatic const u8 effects[][2] = {\n\t\t{ V4L2_COLORFX_NONE,\t ISP_IMAGE_EFFECT_DISABLE },\n\t\t{ V4L2_COLORFX_BW,\t ISP_IMAGE_EFFECT_MONOCHROME },\n\t\t{ V4L2_COLORFX_SEPIA,\t ISP_IMAGE_EFFECT_SEPIA },\n\t\t{ V4L2_COLORFX_NEGATIVE, ISP_IMAGE_EFFECT_NEGATIVE_MONO },\n\t\t{ 16  ,\t ISP_IMAGE_EFFECT_NEGATIVE_COLOR },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(effects); i++) {\n\t\tif (effects[i][0] != value)\n\t\t\tcontinue;\n\n\t\t__is_set_isp_effect(is, effects[i][1]);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int fimc_is_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct fimc_isp *isp = ctrl_to_fimc_isp(ctrl);\n\tstruct fimc_is *is = fimc_isp_to_is(isp);\n\tbool set_param = true;\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_CONTRAST:\n\t\t__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_CONTRAST,\n\t\t\t\t    ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_SATURATION:\n\t\t__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_SATURATION,\n\t\t\t\t    ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_SHARPNESS:\n\t\t__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_SHARPNESS,\n\t\t\t\t    ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_EXPOSURE_ABSOLUTE:\n\t\t__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_EXPOSURE,\n\t\t\t\t    ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_BRIGHTNESS:\n\t\t__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_BRIGHTNESS,\n\t\t\t\t    ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_HUE:\n\t\t__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_HUE,\n\t\t\t\t    ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_EXPOSURE_METERING:\n\t\tret = __ctrl_set_metering(is, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:\n\t\tret = __ctrl_set_white_balance(is, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_3A_LOCK:\n\t\tret = __ctrl_set_aewb_lock(is, ctrl);\n\t\tset_param = false;\n\t\tbreak;\n\n\tcase V4L2_CID_ISO_SENSITIVITY_AUTO:\n\t\tret = __ctrl_set_iso(is, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_POWER_LINE_FREQUENCY:\n\t\tret = __ctrl_set_afc(is, ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_COLORFX:\n\t\t__ctrl_set_image_effect(is, ctrl->val);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret < 0) {\n\t\tv4l2_err(&isp->subdev, \"Failed to set control: %s (%d)\\n\",\n\t\t\t\t\t\tctrl->name, ctrl->val);\n\t\treturn ret;\n\t}\n\n\tif (set_param && test_bit(IS_ST_STREAM_ON, &is->state))\n\t\treturn fimc_is_itf_s_param(is, true);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops fimc_isp_ctrl_ops = {\n\t.s_ctrl\t= fimc_is_s_ctrl,\n};\n\nstatic void __isp_subdev_set_default_format(struct fimc_isp *isp)\n{\n\tstruct fimc_is *is = fimc_isp_to_is(isp);\n\n\tisp->sink_fmt.width = DEFAULT_PREVIEW_STILL_WIDTH +\n\t\t\t\tFIMC_ISP_CAC_MARGIN_WIDTH;\n\tisp->sink_fmt.height = DEFAULT_PREVIEW_STILL_HEIGHT +\n\t\t\t\tFIMC_ISP_CAC_MARGIN_HEIGHT;\n\tisp->sink_fmt.code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\n\tisp->src_fmt.width = DEFAULT_PREVIEW_STILL_WIDTH;\n\tisp->src_fmt.height = DEFAULT_PREVIEW_STILL_HEIGHT;\n\tisp->src_fmt.code = MEDIA_BUS_FMT_SGRBG10_1X10;\n\t__is_set_frame_size(is, &isp->src_fmt);\n}\n\nint fimc_isp_subdev_create(struct fimc_isp *isp)\n{\n\tconst struct v4l2_ctrl_ops *ops = &fimc_isp_ctrl_ops;\n\tstruct v4l2_ctrl_handler *handler = &isp->ctrls.handler;\n\tstruct v4l2_subdev *sd = &isp->subdev;\n\tstruct fimc_isp_ctrls *ctrls = &isp->ctrls;\n\tint ret;\n\n\tmutex_init(&isp->subdev_lock);\n\n\tv4l2_subdev_init(sd, &fimc_is_subdev_ops);\n\n\tsd->owner = THIS_MODULE;\n\tsd->grp_id = GRP_ID_FIMC_IS;\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsnprintf(sd->name, sizeof(sd->name), \"FIMC-IS-ISP\");\n\n\tsd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;\n\tisp->subdev_pads[FIMC_ISP_SD_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tisp->subdev_pads[FIMC_ISP_SD_PAD_SRC_FIFO].flags = MEDIA_PAD_FL_SOURCE;\n\tisp->subdev_pads[FIMC_ISP_SD_PAD_SRC_DMA].flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&sd->entity, FIMC_ISP_SD_PADS_NUM,\n\t\t\t\tisp->subdev_pads);\n\tif (ret)\n\t\treturn ret;\n\n\tv4l2_ctrl_handler_init(handler, 20);\n\n\tctrls->saturation = v4l2_ctrl_new_std(handler, ops, V4L2_CID_SATURATION,\n\t\t\t\t\t\t-2, 2, 1, 0);\n\tctrls->brightness = v4l2_ctrl_new_std(handler, ops, V4L2_CID_BRIGHTNESS,\n\t\t\t\t\t\t-4, 4, 1, 0);\n\tctrls->contrast = v4l2_ctrl_new_std(handler, ops, V4L2_CID_CONTRAST,\n\t\t\t\t\t\t-2, 2, 1, 0);\n\tctrls->sharpness = v4l2_ctrl_new_std(handler, ops, V4L2_CID_SHARPNESS,\n\t\t\t\t\t\t-2, 2, 1, 0);\n\tctrls->hue = v4l2_ctrl_new_std(handler, ops, V4L2_CID_HUE,\n\t\t\t\t\t\t-2, 2, 1, 0);\n\n\tctrls->auto_wb = v4l2_ctrl_new_std_menu(handler, ops,\n\t\t\t\t\tV4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,\n\t\t\t\t\t8, ~0x14e, V4L2_WHITE_BALANCE_AUTO);\n\n\tctrls->exposure = v4l2_ctrl_new_std(handler, ops,\n\t\t\t\t\tV4L2_CID_EXPOSURE_ABSOLUTE,\n\t\t\t\t\t-4, 4, 1, 0);\n\n\tctrls->exp_metering = v4l2_ctrl_new_std_menu(handler, ops,\n\t\t\t\t\tV4L2_CID_EXPOSURE_METERING, 3,\n\t\t\t\t\t~0xf, V4L2_EXPOSURE_METERING_AVERAGE);\n\n\tv4l2_ctrl_new_std_menu(handler, ops, V4L2_CID_POWER_LINE_FREQUENCY,\n\t\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,\n\t\t\t\t\tV4L2_CID_POWER_LINE_FREQUENCY_AUTO);\n\t \n\tctrls->auto_iso = v4l2_ctrl_new_std_menu(handler, ops,\n\t\t\tV4L2_CID_ISO_SENSITIVITY_AUTO, 1, 0,\n\t\t\tV4L2_ISO_SENSITIVITY_AUTO);\n\n\tctrls->iso = v4l2_ctrl_new_int_menu(handler, ops,\n\t\t\tV4L2_CID_ISO_SENSITIVITY, ARRAY_SIZE(iso_qmenu) - 1,\n\t\t\tARRAY_SIZE(iso_qmenu)/2 - 1, iso_qmenu);\n\n\tctrls->aewb_lock = v4l2_ctrl_new_std(handler, ops,\n\t\t\t\t\tV4L2_CID_3A_LOCK, 0, 0x3, 0, 0);\n\n\t \n\tctrls->colorfx = v4l2_ctrl_new_std_menu(handler, ops, V4L2_CID_COLORFX,\n\t\t\tV4L2_COLORFX_SET_CBCR + 1, ~0x1000f, V4L2_COLORFX_NONE);\n\n\tif (handler->error) {\n\t\tmedia_entity_cleanup(&sd->entity);\n\t\treturn handler->error;\n\t}\n\n\tv4l2_ctrl_auto_cluster(2, &ctrls->auto_iso,\n\t\t\tV4L2_ISO_SENSITIVITY_MANUAL, false);\n\n\tsd->ctrl_handler = handler;\n\tsd->internal_ops = &fimc_is_subdev_internal_ops;\n\tsd->entity.ops = &fimc_is_subdev_media_ops;\n\tv4l2_set_subdevdata(sd, isp);\n\n\t__isp_subdev_set_default_format(isp);\n\n\treturn 0;\n}\n\nvoid fimc_isp_subdev_destroy(struct fimc_isp *isp)\n{\n\tstruct v4l2_subdev *sd = &isp->subdev;\n\n\tv4l2_device_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\tv4l2_ctrl_handler_free(&isp->ctrls.handler);\n\tv4l2_set_subdevdata(sd, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}