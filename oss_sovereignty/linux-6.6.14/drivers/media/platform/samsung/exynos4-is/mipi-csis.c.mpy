{
  "module_name": "mipi-csis.c",
  "hash_id": "7572ae41a54d34366d1b8ff4607e57da7fe67cb0fc0a16fba82bcc654195cf06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/mipi-csis.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/memory.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/videodev2.h>\n#include <media/drv-intf/exynos-fimc.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-subdev.h>\n\n#include \"mipi-csis.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level (0-2)\");\n\n \n\n \n#define S5PCSIS_CTRL\t\t\t0x00\n#define S5PCSIS_CTRL_DPDN_DEFAULT\t(0 << 31)\n#define S5PCSIS_CTRL_DPDN_SWAP\t\t(1UL << 31)\n#define S5PCSIS_CTRL_ALIGN_32BIT\t(1 << 20)\n#define S5PCSIS_CTRL_UPDATE_SHADOW\t(1 << 16)\n#define S5PCSIS_CTRL_WCLK_EXTCLK\t(1 << 8)\n#define S5PCSIS_CTRL_RESET\t\t(1 << 4)\n#define S5PCSIS_CTRL_ENABLE\t\t(1 << 0)\n\n \n#define S5PCSIS_DPHYCTRL\t\t0x04\n#define S5PCSIS_DPHYCTRL_HSS_MASK\t(0x1f << 27)\n#define S5PCSIS_DPHYCTRL_ENABLE\t\t(0x1f << 0)\n\n#define S5PCSIS_CONFIG\t\t\t0x08\n#define S5PCSIS_CFG_FMT_YCBCR422_8BIT\t(0x1e << 2)\n#define S5PCSIS_CFG_FMT_RAW8\t\t(0x2a << 2)\n#define S5PCSIS_CFG_FMT_RAW10\t\t(0x2b << 2)\n#define S5PCSIS_CFG_FMT_RAW12\t\t(0x2c << 2)\n \n#define S5PCSIS_CFG_FMT_USER(x)\t\t((0x30 + x - 1) << 2)\n#define S5PCSIS_CFG_FMT_MASK\t\t(0x3f << 2)\n#define S5PCSIS_CFG_NR_LANE_MASK\t3\n\n \n#define S5PCSIS_INTMSK\t\t\t0x10\n#define S5PCSIS_INTMSK_EVEN_BEFORE\t(1UL << 31)\n#define S5PCSIS_INTMSK_EVEN_AFTER\t(1 << 30)\n#define S5PCSIS_INTMSK_ODD_BEFORE\t(1 << 29)\n#define S5PCSIS_INTMSK_ODD_AFTER\t(1 << 28)\n#define S5PCSIS_INTMSK_FRAME_START\t(1 << 27)\n#define S5PCSIS_INTMSK_FRAME_END\t(1 << 26)\n#define S5PCSIS_INTMSK_ERR_SOT_HS\t(1 << 12)\n#define S5PCSIS_INTMSK_ERR_LOST_FS\t(1 << 5)\n#define S5PCSIS_INTMSK_ERR_LOST_FE\t(1 << 4)\n#define S5PCSIS_INTMSK_ERR_OVER\t\t(1 << 3)\n#define S5PCSIS_INTMSK_ERR_ECC\t\t(1 << 2)\n#define S5PCSIS_INTMSK_ERR_CRC\t\t(1 << 1)\n#define S5PCSIS_INTMSK_ERR_UNKNOWN\t(1 << 0)\n#define S5PCSIS_INTMSK_EXYNOS4_EN_ALL\t0xf000103f\n#define S5PCSIS_INTMSK_EXYNOS5_EN_ALL\t0xfc00103f\n\n \n#define S5PCSIS_INTSRC\t\t\t0x14\n#define S5PCSIS_INTSRC_EVEN_BEFORE\t(1UL << 31)\n#define S5PCSIS_INTSRC_EVEN_AFTER\t(1 << 30)\n#define S5PCSIS_INTSRC_EVEN\t\t(0x3 << 30)\n#define S5PCSIS_INTSRC_ODD_BEFORE\t(1 << 29)\n#define S5PCSIS_INTSRC_ODD_AFTER\t(1 << 28)\n#define S5PCSIS_INTSRC_ODD\t\t(0x3 << 28)\n#define S5PCSIS_INTSRC_NON_IMAGE_DATA\t(0xf << 28)\n#define S5PCSIS_INTSRC_FRAME_START\t(1 << 27)\n#define S5PCSIS_INTSRC_FRAME_END\t(1 << 26)\n#define S5PCSIS_INTSRC_ERR_SOT_HS\t(0xf << 12)\n#define S5PCSIS_INTSRC_ERR_LOST_FS\t(1 << 5)\n#define S5PCSIS_INTSRC_ERR_LOST_FE\t(1 << 4)\n#define S5PCSIS_INTSRC_ERR_OVER\t\t(1 << 3)\n#define S5PCSIS_INTSRC_ERR_ECC\t\t(1 << 2)\n#define S5PCSIS_INTSRC_ERR_CRC\t\t(1 << 1)\n#define S5PCSIS_INTSRC_ERR_UNKNOWN\t(1 << 0)\n#define S5PCSIS_INTSRC_ERRORS\t\t0xf03f\n\n \n#define S5PCSIS_RESOL\t\t\t0x2c\n#define CSIS_MAX_PIX_WIDTH\t\t0xffff\n#define CSIS_MAX_PIX_HEIGHT\t\t0xffff\n\n \n#define S5PCSIS_PKTDATA_ODD\t\t0x2000\n#define S5PCSIS_PKTDATA_EVEN\t\t0x3000\n#define S5PCSIS_PKTDATA_SIZE\t\tSZ_4K\n\nenum {\n\tCSIS_CLK_MUX,\n\tCSIS_CLK_GATE,\n};\n\nstatic char *csi_clock_name[] = {\n\t[CSIS_CLK_MUX]  = \"sclk_csis\",\n\t[CSIS_CLK_GATE] = \"csis\",\n};\n#define NUM_CSIS_CLOCKS\tARRAY_SIZE(csi_clock_name)\n#define DEFAULT_SCLK_CSIS_FREQ\t166000000UL\n\nstatic const char * const csis_supply_name[] = {\n\t\"vddcore\",   \n\t\"vddio\",     \n};\n#define CSIS_NUM_SUPPLIES ARRAY_SIZE(csis_supply_name)\n\nenum {\n\tST_POWERED\t= 1,\n\tST_STREAMING\t= 2,\n\tST_SUSPENDED\t= 4,\n};\n\nstruct s5pcsis_event {\n\tu32 mask;\n\tconst char * const name;\n\tunsigned int counter;\n};\n\nstatic const struct s5pcsis_event s5pcsis_events[] = {\n\t \n\t{ S5PCSIS_INTSRC_ERR_SOT_HS,\t\"SOT Error\" },\n\t{ S5PCSIS_INTSRC_ERR_LOST_FS,\t\"Lost Frame Start Error\" },\n\t{ S5PCSIS_INTSRC_ERR_LOST_FE,\t\"Lost Frame End Error\" },\n\t{ S5PCSIS_INTSRC_ERR_OVER,\t\"FIFO Overflow Error\" },\n\t{ S5PCSIS_INTSRC_ERR_ECC,\t\"ECC Error\" },\n\t{ S5PCSIS_INTSRC_ERR_CRC,\t\"CRC Error\" },\n\t{ S5PCSIS_INTSRC_ERR_UNKNOWN,\t\"Unknown Error\" },\n\t \n\t{ S5PCSIS_INTSRC_EVEN_BEFORE,\t\"Non-image data before even frame\" },\n\t{ S5PCSIS_INTSRC_EVEN_AFTER,\t\"Non-image data after even frame\" },\n\t{ S5PCSIS_INTSRC_ODD_BEFORE,\t\"Non-image data before odd frame\" },\n\t{ S5PCSIS_INTSRC_ODD_AFTER,\t\"Non-image data after odd frame\" },\n\t \n\t{ S5PCSIS_INTSRC_FRAME_START,\t\"Frame Start\" },\n\t{ S5PCSIS_INTSRC_FRAME_END,\t\"Frame End\" },\n};\n#define S5PCSIS_NUM_EVENTS ARRAY_SIZE(s5pcsis_events)\n\nstruct csis_pktbuf {\n\tu32 *data;\n\tunsigned int len;\n};\n\nstruct csis_drvdata {\n\t \n\tu32 interrupt_mask;\n};\n\n \nstruct csis_state {\n\tstruct mutex lock;\n\tstruct media_pad pads[CSIS_PADS_NUM];\n\tstruct v4l2_subdev sd;\n\tu8 index;\n\tstruct platform_device *pdev;\n\tstruct phy *phy;\n\tvoid __iomem *regs;\n\tstruct regulator_bulk_data supplies[CSIS_NUM_SUPPLIES];\n\tstruct clk *clock[NUM_CSIS_CLOCKS];\n\tint irq;\n\tu32 interrupt_mask;\n\tu32 flags;\n\n\tu32 clk_frequency;\n\tu32 hs_settle;\n\tu32 num_lanes;\n\tu32 max_num_lanes;\n\tu8 wclk_ext;\n\n\tconst struct csis_pix_format *csis_fmt;\n\tstruct v4l2_mbus_framefmt format;\n\n\tspinlock_t slock;\n\tstruct csis_pktbuf pkt_buf;\n\tstruct s5pcsis_event events[S5PCSIS_NUM_EVENTS];\n};\n\n \nstruct csis_pix_format {\n\tunsigned int pix_width_alignment;\n\tu32 code;\n\tu32 fmt_reg;\n\tu8 data_alignment;\n};\n\nstatic const struct csis_pix_format s5pcsis_formats[] = {\n\t{\n\t\t.code = MEDIA_BUS_FMT_VYUY8_2X8,\n\t\t.fmt_reg = S5PCSIS_CFG_FMT_YCBCR422_8BIT,\n\t\t.data_alignment = 32,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_JPEG_1X8,\n\t\t.fmt_reg = S5PCSIS_CFG_FMT_USER(1),\n\t\t.data_alignment = 32,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_S5C_UYVY_JPEG_1X8,\n\t\t.fmt_reg = S5PCSIS_CFG_FMT_USER(1),\n\t\t.data_alignment = 32,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.fmt_reg = S5PCSIS_CFG_FMT_RAW8,\n\t\t.data_alignment = 24,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.fmt_reg = S5PCSIS_CFG_FMT_RAW10,\n\t\t.data_alignment = 24,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.fmt_reg = S5PCSIS_CFG_FMT_RAW12,\n\t\t.data_alignment = 24,\n\t}\n};\n\n#define s5pcsis_write(__csis, __r, __v) writel(__v, __csis->regs + __r)\n#define s5pcsis_read(__csis, __r) readl(__csis->regs + __r)\n\nstatic struct csis_state *sd_to_csis_state(struct v4l2_subdev *sdev)\n{\n\treturn container_of(sdev, struct csis_state, sd);\n}\n\nstatic const struct csis_pix_format *find_csis_format(\n\tstruct v4l2_mbus_framefmt *mf)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s5pcsis_formats); i++)\n\t\tif (mf->code == s5pcsis_formats[i].code)\n\t\t\treturn &s5pcsis_formats[i];\n\treturn NULL;\n}\n\nstatic void s5pcsis_enable_interrupts(struct csis_state *state, bool on)\n{\n\tu32 val = s5pcsis_read(state, S5PCSIS_INTMSK);\n\tif (on)\n\t\tval |= state->interrupt_mask;\n\telse\n\t\tval &= ~state->interrupt_mask;\n\ts5pcsis_write(state, S5PCSIS_INTMSK, val);\n}\n\nstatic void s5pcsis_reset(struct csis_state *state)\n{\n\tu32 val = s5pcsis_read(state, S5PCSIS_CTRL);\n\n\ts5pcsis_write(state, S5PCSIS_CTRL, val | S5PCSIS_CTRL_RESET);\n\tudelay(10);\n}\n\nstatic void s5pcsis_system_enable(struct csis_state *state, int on)\n{\n\tu32 val, mask;\n\n\tval = s5pcsis_read(state, S5PCSIS_CTRL);\n\tif (on)\n\t\tval |= S5PCSIS_CTRL_ENABLE;\n\telse\n\t\tval &= ~S5PCSIS_CTRL_ENABLE;\n\ts5pcsis_write(state, S5PCSIS_CTRL, val);\n\n\tval = s5pcsis_read(state, S5PCSIS_DPHYCTRL);\n\tval &= ~S5PCSIS_DPHYCTRL_ENABLE;\n\tif (on) {\n\t\tmask = (1 << (state->num_lanes + 1)) - 1;\n\t\tval |= (mask & S5PCSIS_DPHYCTRL_ENABLE);\n\t}\n\ts5pcsis_write(state, S5PCSIS_DPHYCTRL, val);\n}\n\n \nstatic void __s5pcsis_set_format(struct csis_state *state)\n{\n\tstruct v4l2_mbus_framefmt *mf = &state->format;\n\tu32 val;\n\n\tv4l2_dbg(1, debug, &state->sd, \"fmt: %#x, %d x %d\\n\",\n\t\t mf->code, mf->width, mf->height);\n\n\t \n\tval = s5pcsis_read(state, S5PCSIS_CONFIG);\n\tval = (val & ~S5PCSIS_CFG_FMT_MASK) | state->csis_fmt->fmt_reg;\n\ts5pcsis_write(state, S5PCSIS_CONFIG, val);\n\n\t \n\tval = (mf->width << 16) | mf->height;\n\ts5pcsis_write(state, S5PCSIS_RESOL, val);\n}\n\nstatic void s5pcsis_set_hsync_settle(struct csis_state *state, int settle)\n{\n\tu32 val = s5pcsis_read(state, S5PCSIS_DPHYCTRL);\n\n\tval = (val & ~S5PCSIS_DPHYCTRL_HSS_MASK) | (settle << 27);\n\ts5pcsis_write(state, S5PCSIS_DPHYCTRL, val);\n}\n\nstatic void s5pcsis_set_params(struct csis_state *state)\n{\n\tu32 val;\n\n\tval = s5pcsis_read(state, S5PCSIS_CONFIG);\n\tval = (val & ~S5PCSIS_CFG_NR_LANE_MASK) | (state->num_lanes - 1);\n\ts5pcsis_write(state, S5PCSIS_CONFIG, val);\n\n\t__s5pcsis_set_format(state);\n\ts5pcsis_set_hsync_settle(state, state->hs_settle);\n\n\tval = s5pcsis_read(state, S5PCSIS_CTRL);\n\tif (state->csis_fmt->data_alignment == 32)\n\t\tval |= S5PCSIS_CTRL_ALIGN_32BIT;\n\telse  \n\t\tval &= ~S5PCSIS_CTRL_ALIGN_32BIT;\n\n\tval &= ~S5PCSIS_CTRL_WCLK_EXTCLK;\n\tif (state->wclk_ext)\n\t\tval |= S5PCSIS_CTRL_WCLK_EXTCLK;\n\ts5pcsis_write(state, S5PCSIS_CTRL, val);\n\n\t \n\tval = s5pcsis_read(state, S5PCSIS_CTRL);\n\ts5pcsis_write(state, S5PCSIS_CTRL, val | S5PCSIS_CTRL_UPDATE_SHADOW);\n}\n\nstatic void s5pcsis_clk_put(struct csis_state *state)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_CSIS_CLOCKS; i++) {\n\t\tif (IS_ERR(state->clock[i]))\n\t\t\tcontinue;\n\t\tclk_unprepare(state->clock[i]);\n\t\tclk_put(state->clock[i]);\n\t\tstate->clock[i] = ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic int s5pcsis_clk_get(struct csis_state *state)\n{\n\tstruct device *dev = &state->pdev->dev;\n\tint i, ret;\n\n\tfor (i = 0; i < NUM_CSIS_CLOCKS; i++)\n\t\tstate->clock[i] = ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < NUM_CSIS_CLOCKS; i++) {\n\t\tstate->clock[i] = clk_get(dev, csi_clock_name[i]);\n\t\tif (IS_ERR(state->clock[i])) {\n\t\t\tret = PTR_ERR(state->clock[i]);\n\t\t\tgoto err;\n\t\t}\n\t\tret = clk_prepare(state->clock[i]);\n\t\tif (ret < 0) {\n\t\t\tclk_put(state->clock[i]);\n\t\t\tstate->clock[i] = ERR_PTR(-EINVAL);\n\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 0;\nerr:\n\ts5pcsis_clk_put(state);\n\tdev_err(dev, \"failed to get clock: %s\\n\", csi_clock_name[i]);\n\treturn ret;\n}\n\nstatic void dump_regs(struct csis_state *state, const char *label)\n{\n\tstruct {\n\t\tu32 offset;\n\t\tconst char * const name;\n\t} registers[] = {\n\t\t{ 0x00, \"CTRL\" },\n\t\t{ 0x04, \"DPHYCTRL\" },\n\t\t{ 0x08, \"CONFIG\" },\n\t\t{ 0x0c, \"DPHYSTS\" },\n\t\t{ 0x10, \"INTMSK\" },\n\t\t{ 0x2c, \"RESOL\" },\n\t\t{ 0x38, \"SDW_CONFIG\" },\n\t};\n\tu32 i;\n\n\tv4l2_info(&state->sd, \"--- %s ---\\n\", label);\n\n\tfor (i = 0; i < ARRAY_SIZE(registers); i++) {\n\t\tu32 cfg = s5pcsis_read(state, registers[i].offset);\n\t\tv4l2_info(&state->sd, \"%10s: 0x%08x\\n\", registers[i].name, cfg);\n\t}\n}\n\nstatic void s5pcsis_start_stream(struct csis_state *state)\n{\n\ts5pcsis_reset(state);\n\ts5pcsis_set_params(state);\n\ts5pcsis_system_enable(state, true);\n\ts5pcsis_enable_interrupts(state, true);\n}\n\nstatic void s5pcsis_stop_stream(struct csis_state *state)\n{\n\ts5pcsis_enable_interrupts(state, false);\n\ts5pcsis_system_enable(state, false);\n}\n\nstatic void s5pcsis_clear_counters(struct csis_state *state)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&state->slock, flags);\n\tfor (i = 0; i < S5PCSIS_NUM_EVENTS; i++)\n\t\tstate->events[i].counter = 0;\n\tspin_unlock_irqrestore(&state->slock, flags);\n}\n\nstatic void s5pcsis_log_counters(struct csis_state *state, bool non_errors)\n{\n\tint i = non_errors ? S5PCSIS_NUM_EVENTS : S5PCSIS_NUM_EVENTS - 4;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&state->slock, flags);\n\n\tfor (i--; i >= 0; i--) {\n\t\tif (state->events[i].counter > 0 || debug)\n\t\t\tv4l2_info(&state->sd, \"%s events: %d\\n\",\n\t\t\t\t  state->events[i].name,\n\t\t\t\t  state->events[i].counter);\n\t}\n\tspin_unlock_irqrestore(&state->slock, flags);\n}\n\n \nstatic int s5pcsis_s_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct csis_state *state = sd_to_csis_state(sd);\n\tstruct device *dev = &state->pdev->dev;\n\n\tif (on)\n\t\treturn pm_runtime_resume_and_get(dev);\n\n\treturn pm_runtime_put_sync(dev);\n}\n\nstatic int s5pcsis_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct csis_state *state = sd_to_csis_state(sd);\n\tint ret = 0;\n\n\tv4l2_dbg(1, debug, sd, \"%s: %d, state: 0x%x\\n\",\n\t\t __func__, enable, state->flags);\n\n\tif (enable) {\n\t\ts5pcsis_clear_counters(state);\n\t\tret = pm_runtime_resume_and_get(&state->pdev->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&state->lock);\n\tif (enable) {\n\t\tif (state->flags & ST_SUSPENDED) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\t\ts5pcsis_start_stream(state);\n\t\tstate->flags |= ST_STREAMING;\n\t} else {\n\t\ts5pcsis_stop_stream(state);\n\t\tstate->flags &= ~ST_STREAMING;\n\t\tif (debug > 0)\n\t\t\ts5pcsis_log_counters(state, true);\n\t}\nunlock:\n\tmutex_unlock(&state->lock);\n\tif (!enable)\n\t\tpm_runtime_put(&state->pdev->dev);\n\n\treturn ret;\n}\n\nstatic int s5pcsis_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\tif (code->index >= ARRAY_SIZE(s5pcsis_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = s5pcsis_formats[code->index].code;\n\treturn 0;\n}\n\nstatic struct csis_pix_format const *s5pcsis_try_format(\n\tstruct v4l2_mbus_framefmt *mf)\n{\n\tstruct csis_pix_format const *csis_fmt;\n\n\tcsis_fmt = find_csis_format(mf);\n\tif (csis_fmt == NULL)\n\t\tcsis_fmt = &s5pcsis_formats[0];\n\n\tmf->code = csis_fmt->code;\n\tv4l_bound_align_image(&mf->width, 1, CSIS_MAX_PIX_WIDTH,\n\t\t\t      csis_fmt->pix_width_alignment,\n\t\t\t      &mf->height, 1, CSIS_MAX_PIX_HEIGHT, 1,\n\t\t\t      0);\n\treturn csis_fmt;\n}\n\nstatic struct v4l2_mbus_framefmt *__s5pcsis_get_format(\n\t\tstruct csis_state *state, struct v4l2_subdev_state *sd_state,\n\t\tenum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn sd_state ? v4l2_subdev_get_try_format(&state->sd,\n\t\t\t\t\t\t\t     sd_state, 0) : NULL;\n\n\treturn &state->format;\n}\n\nstatic int s5pcsis_set_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct csis_state *state = sd_to_csis_state(sd);\n\tstruct csis_pix_format const *csis_fmt;\n\tstruct v4l2_mbus_framefmt *mf;\n\n\tmf = __s5pcsis_get_format(state, sd_state, fmt->which);\n\n\tif (fmt->pad == CSIS_PAD_SOURCE) {\n\t\tif (mf) {\n\t\t\tmutex_lock(&state->lock);\n\t\t\tfmt->format = *mf;\n\t\t\tmutex_unlock(&state->lock);\n\t\t}\n\t\treturn 0;\n\t}\n\tcsis_fmt = s5pcsis_try_format(&fmt->format);\n\tif (mf) {\n\t\tmutex_lock(&state->lock);\n\t\t*mf = fmt->format;\n\t\tif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\n\t\t\tstate->csis_fmt = csis_fmt;\n\t\tmutex_unlock(&state->lock);\n\t}\n\treturn 0;\n}\n\nstatic int s5pcsis_get_fmt(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct csis_state *state = sd_to_csis_state(sd);\n\tstruct v4l2_mbus_framefmt *mf;\n\n\tmf = __s5pcsis_get_format(state, sd_state, fmt->which);\n\tif (!mf)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&state->lock);\n\tfmt->format = *mf;\n\tmutex_unlock(&state->lock);\n\treturn 0;\n}\n\nstatic int s5pcsis_s_rx_buffer(struct v4l2_subdev *sd, void *buf,\n\t\t\t       unsigned int *size)\n{\n\tstruct csis_state *state = sd_to_csis_state(sd);\n\tunsigned long flags;\n\n\t*size = min_t(unsigned int, *size, S5PCSIS_PKTDATA_SIZE);\n\n\tspin_lock_irqsave(&state->slock, flags);\n\tstate->pkt_buf.data = buf;\n\tstate->pkt_buf.len = *size;\n\tspin_unlock_irqrestore(&state->slock, flags);\n\n\treturn 0;\n}\n\nstatic int s5pcsis_log_status(struct v4l2_subdev *sd)\n{\n\tstruct csis_state *state = sd_to_csis_state(sd);\n\n\tmutex_lock(&state->lock);\n\ts5pcsis_log_counters(state, true);\n\tif (debug && (state->flags & ST_POWERED))\n\t\tdump_regs(state, __func__);\n\tmutex_unlock(&state->lock);\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops s5pcsis_core_ops = {\n\t.s_power = s5pcsis_s_power,\n\t.log_status = s5pcsis_log_status,\n};\n\nstatic const struct v4l2_subdev_pad_ops s5pcsis_pad_ops = {\n\t.enum_mbus_code = s5pcsis_enum_mbus_code,\n\t.get_fmt = s5pcsis_get_fmt,\n\t.set_fmt = s5pcsis_set_fmt,\n};\n\nstatic const struct v4l2_subdev_video_ops s5pcsis_video_ops = {\n\t.s_rx_buffer = s5pcsis_s_rx_buffer,\n\t.s_stream = s5pcsis_s_stream,\n};\n\nstatic const struct v4l2_subdev_ops s5pcsis_subdev_ops = {\n\t.core = &s5pcsis_core_ops,\n\t.pad = &s5pcsis_pad_ops,\n\t.video = &s5pcsis_video_ops,\n};\n\nstatic irqreturn_t s5pcsis_irq_handler(int irq, void *dev_id)\n{\n\tstruct csis_state *state = dev_id;\n\tstruct csis_pktbuf *pktbuf = &state->pkt_buf;\n\tunsigned long flags;\n\tu32 status;\n\n\tstatus = s5pcsis_read(state, S5PCSIS_INTSRC);\n\tspin_lock_irqsave(&state->slock, flags);\n\n\tif ((status & S5PCSIS_INTSRC_NON_IMAGE_DATA) && pktbuf->data) {\n\t\tu32 offset;\n\n\t\tif (status & S5PCSIS_INTSRC_EVEN)\n\t\t\toffset = S5PCSIS_PKTDATA_EVEN;\n\t\telse\n\t\t\toffset = S5PCSIS_PKTDATA_ODD;\n\n\t\tmemcpy(pktbuf->data, (u8 __force *)state->regs + offset,\n\t\t       pktbuf->len);\n\t\tpktbuf->data = NULL;\n\t\trmb();\n\t}\n\n\t \n\tif ((status & S5PCSIS_INTSRC_ERRORS) || debug) {\n\t\tint i;\n\t\tfor (i = 0; i < S5PCSIS_NUM_EVENTS; i++) {\n\t\t\tif (!(status & state->events[i].mask))\n\t\t\t\tcontinue;\n\t\t\tstate->events[i].counter++;\n\t\t\tv4l2_dbg(2, debug, &state->sd, \"%s: %d\\n\",\n\t\t\t\t state->events[i].name,\n\t\t\t\t state->events[i].counter);\n\t\t}\n\t\tv4l2_dbg(2, debug, &state->sd, \"status: %08x\\n\", status);\n\t}\n\tspin_unlock_irqrestore(&state->slock, flags);\n\n\ts5pcsis_write(state, S5PCSIS_INTSRC, status);\n\treturn IRQ_HANDLED;\n}\n\nstatic int s5pcsis_parse_dt(struct platform_device *pdev,\n\t\t\t    struct csis_state *state)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct v4l2_fwnode_endpoint endpoint = { .bus_type = 0 };\n\tint ret;\n\n\tif (of_property_read_u32(node, \"clock-frequency\",\n\t\t\t\t &state->clk_frequency))\n\t\tstate->clk_frequency = DEFAULT_SCLK_CSIS_FREQ;\n\tif (of_property_read_u32(node, \"bus-width\",\n\t\t\t\t &state->max_num_lanes))\n\t\treturn -EINVAL;\n\n\tnode = of_graph_get_next_endpoint(node, NULL);\n\tif (!node) {\n\t\tdev_err(&pdev->dev, \"No port node at %pOF\\n\",\n\t\t\t\tpdev->dev.of_node);\n\t\treturn -EINVAL;\n\t}\n\t \n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(node), &endpoint);\n\tif (ret)\n\t\tgoto err;\n\n\tstate->index = endpoint.base.port - FIMC_INPUT_MIPI_CSI2_0;\n\tif (state->index >= CSIS_MAX_ENTITIES) {\n\t\tret = -ENXIO;\n\t\tgoto err;\n\t}\n\n\t \n\tof_property_read_u32(node, \"samsung,csis-hs-settle\",\n\t\t\t\t\t&state->hs_settle);\n\tstate->wclk_ext = of_property_read_bool(node,\n\t\t\t\t\t\"samsung,csis-wclk\");\n\n\tstate->num_lanes = endpoint.bus.mipi_csi2.num_data_lanes;\n\nerr:\n\tof_node_put(node);\n\treturn ret;\n}\n\nstatic int s5pcsis_pm_resume(struct device *dev, bool runtime);\nstatic const struct of_device_id s5pcsis_of_match[];\n\nstatic int s5pcsis_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id;\n\tconst struct csis_drvdata *drv_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct csis_state *state;\n\tint ret = -ENOMEM;\n\tint i;\n\n\tstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&state->lock);\n\tspin_lock_init(&state->slock);\n\tstate->pdev = pdev;\n\n\tof_id = of_match_node(s5pcsis_of_match, dev->of_node);\n\tif (WARN_ON(of_id == NULL))\n\t\treturn -EINVAL;\n\n\tdrv_data = of_id->data;\n\tstate->interrupt_mask = drv_data->interrupt_mask;\n\n\tret = s5pcsis_parse_dt(pdev, state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (state->num_lanes == 0 || state->num_lanes > state->max_num_lanes) {\n\t\tdev_err(dev, \"Unsupported number of data lanes: %d (max. %d)\\n\",\n\t\t\tstate->num_lanes, state->max_num_lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tstate->phy = devm_phy_get(dev, \"csis\");\n\tif (IS_ERR(state->phy))\n\t\treturn PTR_ERR(state->phy);\n\n\tstate->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(state->regs))\n\t\treturn PTR_ERR(state->regs);\n\n\tstate->irq = platform_get_irq(pdev, 0);\n\tif (state->irq < 0)\n\t\treturn state->irq;\n\n\tfor (i = 0; i < CSIS_NUM_SUPPLIES; i++)\n\t\tstate->supplies[i].supply = csis_supply_name[i];\n\n\tret = devm_regulator_bulk_get(dev, CSIS_NUM_SUPPLIES,\n\t\t\t\t state->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tret = s5pcsis_clk_get(state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (state->clk_frequency)\n\t\tret = clk_set_rate(state->clock[CSIS_CLK_MUX],\n\t\t\t\t   state->clk_frequency);\n\telse\n\t\tdev_WARN(dev, \"No clock frequency specified!\\n\");\n\tif (ret < 0)\n\t\tgoto e_clkput;\n\n\tret = clk_enable(state->clock[CSIS_CLK_MUX]);\n\tif (ret < 0)\n\t\tgoto e_clkput;\n\n\tret = devm_request_irq(dev, state->irq, s5pcsis_irq_handler,\n\t\t\t       0, dev_name(dev), state);\n\tif (ret) {\n\t\tdev_err(dev, \"Interrupt request failed\\n\");\n\t\tgoto e_clkdis;\n\t}\n\n\tv4l2_subdev_init(&state->sd, &s5pcsis_subdev_ops);\n\tstate->sd.owner = THIS_MODULE;\n\tsnprintf(state->sd.name, sizeof(state->sd.name), \"%s.%d\",\n\t\t CSIS_SUBDEV_NAME, state->index);\n\tstate->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tstate->csis_fmt = &s5pcsis_formats[0];\n\n\tstate->format.code = s5pcsis_formats[0].code;\n\tstate->format.width = S5PCSIS_DEF_PIX_WIDTH;\n\tstate->format.height = S5PCSIS_DEF_PIX_HEIGHT;\n\n\tstate->sd.entity.function = MEDIA_ENT_F_IO_V4L;\n\tstate->pads[CSIS_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tstate->pads[CSIS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&state->sd.entity,\n\t\t\t\tCSIS_PADS_NUM, state->pads);\n\tif (ret < 0)\n\t\tgoto e_clkdis;\n\n\t \n\tv4l2_set_subdevdata(&state->sd, pdev);\n\n\t \n\tplatform_set_drvdata(pdev, &state->sd);\n\tmemcpy(state->events, s5pcsis_events, sizeof(state->events));\n\n\tpm_runtime_enable(dev);\n\tif (!pm_runtime_enabled(dev)) {\n\t\tret = s5pcsis_pm_resume(dev, true);\n\t\tif (ret < 0)\n\t\t\tgoto e_m_ent;\n\t}\n\n\tdev_info(&pdev->dev, \"lanes: %d, hs_settle: %d, wclk: %d, freq: %u\\n\",\n\t\t state->num_lanes, state->hs_settle, state->wclk_ext,\n\t\t state->clk_frequency);\n\treturn 0;\n\ne_m_ent:\n\tmedia_entity_cleanup(&state->sd.entity);\ne_clkdis:\n\tclk_disable(state->clock[CSIS_CLK_MUX]);\ne_clkput:\n\ts5pcsis_clk_put(state);\n\treturn ret;\n}\n\nstatic int s5pcsis_pm_suspend(struct device *dev, bool runtime)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct csis_state *state = sd_to_csis_state(sd);\n\tint ret = 0;\n\n\tv4l2_dbg(1, debug, sd, \"%s: flags: 0x%x\\n\",\n\t\t __func__, state->flags);\n\n\tmutex_lock(&state->lock);\n\tif (state->flags & ST_POWERED) {\n\t\ts5pcsis_stop_stream(state);\n\t\tret = phy_power_off(state->phy);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\tret = regulator_bulk_disable(CSIS_NUM_SUPPLIES,\n\t\t\t\t\t     state->supplies);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\tclk_disable(state->clock[CSIS_CLK_GATE]);\n\t\tstate->flags &= ~ST_POWERED;\n\t\tif (!runtime)\n\t\t\tstate->flags |= ST_SUSPENDED;\n\t}\n unlock:\n\tmutex_unlock(&state->lock);\n\treturn ret ? -EAGAIN : 0;\n}\n\nstatic int s5pcsis_pm_resume(struct device *dev, bool runtime)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct csis_state *state = sd_to_csis_state(sd);\n\tint ret = 0;\n\n\tv4l2_dbg(1, debug, sd, \"%s: flags: 0x%x\\n\",\n\t\t __func__, state->flags);\n\n\tmutex_lock(&state->lock);\n\tif (!runtime && !(state->flags & ST_SUSPENDED))\n\t\tgoto unlock;\n\n\tif (!(state->flags & ST_POWERED)) {\n\t\tret = regulator_bulk_enable(CSIS_NUM_SUPPLIES,\n\t\t\t\t\t    state->supplies);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\tret = phy_power_on(state->phy);\n\t\tif (!ret) {\n\t\t\tstate->flags |= ST_POWERED;\n\t\t} else {\n\t\t\tregulator_bulk_disable(CSIS_NUM_SUPPLIES,\n\t\t\t\t\t       state->supplies);\n\t\t\tgoto unlock;\n\t\t}\n\t\tclk_enable(state->clock[CSIS_CLK_GATE]);\n\t}\n\tif (state->flags & ST_STREAMING)\n\t\ts5pcsis_start_stream(state);\n\n\tstate->flags &= ~ST_SUSPENDED;\n unlock:\n\tmutex_unlock(&state->lock);\n\treturn ret ? -EAGAIN : 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int s5pcsis_suspend(struct device *dev)\n{\n\treturn s5pcsis_pm_suspend(dev, false);\n}\n\nstatic int s5pcsis_resume(struct device *dev)\n{\n\treturn s5pcsis_pm_resume(dev, false);\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int s5pcsis_runtime_suspend(struct device *dev)\n{\n\treturn s5pcsis_pm_suspend(dev, true);\n}\n\nstatic int s5pcsis_runtime_resume(struct device *dev)\n{\n\treturn s5pcsis_pm_resume(dev, true);\n}\n#endif\n\nstatic void s5pcsis_remove(struct platform_device *pdev)\n{\n\tstruct v4l2_subdev *sd = platform_get_drvdata(pdev);\n\tstruct csis_state *state = sd_to_csis_state(sd);\n\n\tpm_runtime_disable(&pdev->dev);\n\ts5pcsis_pm_suspend(&pdev->dev, true);\n\tclk_disable(state->clock[CSIS_CLK_MUX]);\n\tpm_runtime_set_suspended(&pdev->dev);\n\ts5pcsis_clk_put(state);\n\n\tmedia_entity_cleanup(&state->sd.entity);\n}\n\nstatic const struct dev_pm_ops s5pcsis_pm_ops = {\n\tSET_RUNTIME_PM_OPS(s5pcsis_runtime_suspend, s5pcsis_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(s5pcsis_suspend, s5pcsis_resume)\n};\n\nstatic const struct csis_drvdata exynos4_csis_drvdata = {\n\t.interrupt_mask = S5PCSIS_INTMSK_EXYNOS4_EN_ALL,\n};\n\nstatic const struct csis_drvdata exynos5_csis_drvdata = {\n\t.interrupt_mask = S5PCSIS_INTMSK_EXYNOS5_EN_ALL,\n};\n\nstatic const struct of_device_id s5pcsis_of_match[] = {\n\t{\n\t\t.compatible = \"samsung,s5pv210-csis\",\n\t\t.data = &exynos4_csis_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos4210-csis\",\n\t\t.data = &exynos4_csis_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos5250-csis\",\n\t\t.data = &exynos5_csis_drvdata,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, s5pcsis_of_match);\n\nstatic struct platform_driver s5pcsis_driver = {\n\t.probe\t\t= s5pcsis_probe,\n\t.remove_new\t= s5pcsis_remove,\n\t.driver\t\t= {\n\t\t.of_match_table = s5pcsis_of_match,\n\t\t.name\t\t= CSIS_DRIVER_NAME,\n\t\t.pm\t\t= &s5pcsis_pm_ops,\n\t},\n};\n\nmodule_platform_driver(s5pcsis_driver);\n\nMODULE_AUTHOR(\"Sylwester Nawrocki <s.nawrocki@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung S5P/EXYNOS SoC MIPI-CSI2 receiver driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}