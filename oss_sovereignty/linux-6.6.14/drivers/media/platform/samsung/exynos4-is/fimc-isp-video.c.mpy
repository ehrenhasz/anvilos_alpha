{
  "module_name": "fimc-isp-video.c",
  "hash_id": "934ca141665d4bfe1f710c0f34a4e558e5fa0ade54b524b2145d65fe8b423a98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-isp-video.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/printk.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/drv-intf/exynos-fimc.h>\n\n#include \"common.h\"\n#include \"media-dev.h\"\n#include \"fimc-is.h\"\n#include \"fimc-isp-video.h\"\n#include \"fimc-is-param.h\"\n\nstatic int isp_video_capture_queue_setup(struct vb2_queue *vq,\n\t\t\tunsigned int *num_buffers, unsigned int *num_planes,\n\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct fimc_isp *isp = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format_mplane *vid_fmt = &isp->video_capture.pixfmt;\n\tconst struct fimc_fmt *fmt = isp->video_capture.format;\n\tunsigned int wh, i;\n\n\twh = vid_fmt->width * vid_fmt->height;\n\n\tif (fmt == NULL)\n\t\treturn -EINVAL;\n\n\t*num_buffers = clamp_t(u32, *num_buffers, FIMC_ISP_REQ_BUFS_MIN,\n\t\t\t\t\t\tFIMC_ISP_REQ_BUFS_MAX);\n\tif (*num_planes) {\n\t\tif (*num_planes != fmt->memplanes)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < *num_planes; i++)\n\t\t\tif (sizes[i] < (wh * fmt->depth[i]) / 8)\n\t\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t*num_planes = fmt->memplanes;\n\n\tfor (i = 0; i < fmt->memplanes; i++)\n\t\tsizes[i] = (wh * fmt->depth[i]) / 8;\n\n\treturn 0;\n}\n\nstatic inline struct param_dma_output *__get_isp_dma2(struct fimc_is *is)\n{\n\treturn &__get_curr_is_config(is)->isp.dma2_output;\n}\n\nstatic int isp_video_capture_start_streaming(struct vb2_queue *q,\n\t\t\t\t\t\tunsigned int count)\n{\n\tstruct fimc_isp *isp = vb2_get_drv_priv(q);\n\tstruct fimc_is *is = fimc_isp_to_is(isp);\n\tstruct param_dma_output *dma = __get_isp_dma2(is);\n\tstruct fimc_is_video *video = &isp->video_capture;\n\tint ret;\n\n\tif (!test_bit(ST_ISP_VID_CAP_BUF_PREP, &isp->state) ||\n\t    test_bit(ST_ISP_VID_CAP_STREAMING, &isp->state))\n\t\treturn 0;\n\n\n\tdma->cmd = DMA_OUTPUT_COMMAND_ENABLE;\n\tdma->notify_dma_done = DMA_OUTPUT_NOTIFY_DMA_DONE_ENABLE;\n\tdma->buffer_address = is->is_dma_p_region +\n\t\t\t\tDMA2_OUTPUT_ADDR_ARRAY_OFFS;\n\tdma->buffer_number = video->reqbufs_count;\n\tdma->dma_out_mask = video->buf_mask;\n\n\tisp_dbg(2, &video->ve.vdev,\n\t\t\"buf_count: %d, planes: %d, dma addr table: %#x\\n\",\n\t\tvideo->buf_count, video->format->memplanes,\n\t\tdma->buffer_address);\n\n\tfimc_is_mem_barrier();\n\n\tfimc_is_set_param_bit(is, PARAM_ISP_DMA2_OUTPUT);\n\t__fimc_is_hw_update_param(is, PARAM_ISP_DMA2_OUTPUT);\n\n\tret = fimc_is_itf_s_param(is, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = fimc_pipeline_call(&video->ve, set_stream, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tset_bit(ST_ISP_VID_CAP_STREAMING, &isp->state);\n\treturn ret;\n}\n\nstatic void isp_video_capture_stop_streaming(struct vb2_queue *q)\n{\n\tstruct fimc_isp *isp = vb2_get_drv_priv(q);\n\tstruct fimc_is *is = fimc_isp_to_is(isp);\n\tstruct param_dma_output *dma = __get_isp_dma2(is);\n\tint ret;\n\n\tret = fimc_pipeline_call(&isp->video_capture.ve, set_stream, 0);\n\tif (ret < 0)\n\t\treturn;\n\n\tdma->cmd = DMA_OUTPUT_COMMAND_DISABLE;\n\tdma->notify_dma_done = DMA_OUTPUT_NOTIFY_DMA_DONE_DISABLE;\n\tdma->buffer_number = 0;\n\tdma->buffer_address = 0;\n\tdma->dma_out_mask = 0;\n\n\tfimc_is_set_param_bit(is, PARAM_ISP_DMA2_OUTPUT);\n\t__fimc_is_hw_update_param(is, PARAM_ISP_DMA2_OUTPUT);\n\n\tret = fimc_is_itf_s_param(is, false);\n\tif (ret < 0)\n\t\tdev_warn(&is->pdev->dev, \"%s: DMA stop failed\\n\", __func__);\n\n\tfimc_is_hw_set_isp_buf_mask(is, 0);\n\n\tclear_bit(ST_ISP_VID_CAP_BUF_PREP, &isp->state);\n\tclear_bit(ST_ISP_VID_CAP_STREAMING, &isp->state);\n\n\tisp->video_capture.buf_count = 0;\n}\n\nstatic int isp_video_capture_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct fimc_isp *isp = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct fimc_is_video *video = &isp->video_capture;\n\tint i;\n\n\tif (video->format == NULL)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < video->format->memplanes; i++) {\n\t\tunsigned long size = video->pixfmt.plane_fmt[i].sizeimage;\n\n\t\tif (vb2_plane_size(vb, i) < size) {\n\t\t\tv4l2_err(&video->ve.vdev,\n\t\t\t\t \"User buffer too small (%ld < %ld)\\n\",\n\t\t\t\t vb2_plane_size(vb, i), size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvb2_set_plane_payload(vb, i, size);\n\t}\n\n\t \n\tif (test_bit(ST_ISP_VID_CAP_BUF_PREP, &isp->state)) {\n\t\tdma_addr_t dma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\t\tint i;\n\n\t\tfor (i = 0; i < video->buf_count; i++)\n\t\t\tif (video->buffers[i]->dma_addr[0] == dma_addr)\n\t\t\t\treturn 0;\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void isp_video_capture_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct fimc_isp *isp = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct fimc_is_video *video = &isp->video_capture;\n\tstruct fimc_is *is = fimc_isp_to_is(isp);\n\tstruct isp_video_buf *ivb = to_isp_video_buf(vbuf);\n\tunsigned long flags;\n\tunsigned int i;\n\n\tif (test_bit(ST_ISP_VID_CAP_BUF_PREP, &isp->state)) {\n\t\tspin_lock_irqsave(&is->slock, flags);\n\t\tvideo->buf_mask |= BIT(ivb->index);\n\t\tspin_unlock_irqrestore(&is->slock, flags);\n\t} else {\n\t\tunsigned int num_planes = video->format->memplanes;\n\n\t\tivb->index = video->buf_count;\n\t\tvideo->buffers[ivb->index] = ivb;\n\n\t\tfor (i = 0; i < num_planes; i++) {\n\t\t\tint buf_index = ivb->index * num_planes + i;\n\n\t\t\tivb->dma_addr[i] = vb2_dma_contig_plane_dma_addr(vb, i);\n\t\t\tis->is_p_region->shared[32 + buf_index] =\n\t\t\t\t\t\t\tivb->dma_addr[i];\n\n\t\t\tisp_dbg(2, &video->ve.vdev,\n\t\t\t\t\"dma_buf %d (%d/%d/%d) addr: %pad\\n\",\n\t\t\t\tbuf_index, ivb->index, i, vb->index,\n\t\t\t\t&ivb->dma_addr[i]);\n\t\t}\n\n\t\tif (++video->buf_count < video->reqbufs_count)\n\t\t\treturn;\n\n\t\tvideo->buf_mask = (1UL << video->buf_count) - 1;\n\t\tset_bit(ST_ISP_VID_CAP_BUF_PREP, &isp->state);\n\t}\n\n\tif (!test_bit(ST_ISP_VID_CAP_STREAMING, &isp->state))\n\t\tisp_video_capture_start_streaming(vb->vb2_queue, 0);\n}\n\n \nvoid fimc_isp_video_irq_handler(struct fimc_is *is)\n{\n\tstruct fimc_is_video *video = &is->isp.video_capture;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tint buf_index;\n\n\t \n\tif (!test_bit(ST_ISP_VID_CAP_STREAMING, &is->isp.state))\n\t\treturn;\n\n\tbuf_index = (is->i2h_cmd.args[1] - 1) % video->buf_count;\n\tvbuf = &video->buffers[buf_index]->vb;\n\n\tvbuf->vb2_buf.timestamp = ktime_get_ns();\n\tvb2_buffer_done(&vbuf->vb2_buf, VB2_BUF_STATE_DONE);\n\n\tvideo->buf_mask &= ~BIT(buf_index);\n\tfimc_is_hw_set_isp_buf_mask(is, video->buf_mask);\n}\n\nstatic const struct vb2_ops isp_video_capture_qops = {\n\t.queue_setup\t = isp_video_capture_queue_setup,\n\t.buf_prepare\t = isp_video_capture_buffer_prepare,\n\t.buf_queue\t = isp_video_capture_buffer_queue,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n\t.start_streaming = isp_video_capture_start_streaming,\n\t.stop_streaming\t = isp_video_capture_stop_streaming,\n};\n\nstatic int isp_video_open(struct file *file)\n{\n\tstruct fimc_isp *isp = video_drvdata(file);\n\tstruct exynos_video_entity *ve = &isp->video_capture.ve;\n\tstruct media_entity *me = &ve->vdev.entity;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&isp->video_lock))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_fh_open(file);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = pm_runtime_resume_and_get(&isp->pdev->dev);\n\tif (ret < 0)\n\t\tgoto rel_fh;\n\n\tif (v4l2_fh_is_singular_file(file)) {\n\t\tmutex_lock(&me->graph_obj.mdev->graph_mutex);\n\n\t\tret = fimc_pipeline_call(ve, open, me, true);\n\n\t\t \n\t\tif (ret == 0)\n\t\t\tme->use_count++;\n\n\t\tmutex_unlock(&me->graph_obj.mdev->graph_mutex);\n\t}\n\tif (!ret)\n\t\tgoto unlock;\nrel_fh:\n\tv4l2_fh_release(file);\nunlock:\n\tmutex_unlock(&isp->video_lock);\n\treturn ret;\n}\n\nstatic int isp_video_release(struct file *file)\n{\n\tstruct fimc_isp *isp = video_drvdata(file);\n\tstruct fimc_is_video *ivc = &isp->video_capture;\n\tstruct media_entity *entity = &ivc->ve.vdev.entity;\n\tstruct media_device *mdev = entity->graph_obj.mdev;\n\tbool is_singular_file;\n\n\tmutex_lock(&isp->video_lock);\n\n\tis_singular_file = v4l2_fh_is_singular_file(file);\n\n\tif (is_singular_file && ivc->streaming) {\n\t\tvideo_device_pipeline_stop(&ivc->ve.vdev);\n\t\tivc->streaming = 0;\n\t}\n\n\t_vb2_fop_release(file, NULL);\n\n\tif (is_singular_file) {\n\t\tfimc_pipeline_call(&ivc->ve, close);\n\n\t\tmutex_lock(&mdev->graph_mutex);\n\t\tentity->use_count--;\n\t\tmutex_unlock(&mdev->graph_mutex);\n\t}\n\n\tpm_runtime_put(&isp->pdev->dev);\n\tmutex_unlock(&isp->video_lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations isp_video_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= isp_video_open,\n\t.release\t= isp_video_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= vb2_fop_mmap,\n};\n\n \nstatic int isp_video_querycap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct fimc_isp *isp = video_drvdata(file);\n\n\t__fimc_vidioc_querycap(&isp->pdev->dev, cap);\n\treturn 0;\n}\n\nstatic int isp_video_enum_fmt(struct file *file, void *priv,\n\t\t\t      struct v4l2_fmtdesc *f)\n{\n\tconst struct fimc_fmt *fmt;\n\n\tif (f->index >= FIMC_ISP_NUM_FORMATS)\n\t\treturn -EINVAL;\n\n\tfmt = fimc_isp_find_format(NULL, NULL, f->index);\n\tif (WARN_ON(fmt == NULL))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = fmt->fourcc;\n\n\treturn 0;\n}\n\nstatic int isp_video_g_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct fimc_isp *isp = video_drvdata(file);\n\n\tf->fmt.pix_mp = isp->video_capture.pixfmt;\n\treturn 0;\n}\n\nstatic void __isp_video_try_fmt(struct fimc_isp *isp,\n\t\t\t\tstruct v4l2_pix_format_mplane *pixm,\n\t\t\t\tconst struct fimc_fmt **fmt)\n{\n\tconst struct fimc_fmt *__fmt;\n\n\t__fmt = fimc_isp_find_format(&pixm->pixelformat, NULL, 2);\n\n\tif (fmt)\n\t\t*fmt = __fmt;\n\n\tpixm->colorspace = V4L2_COLORSPACE_SRGB;\n\tpixm->field = V4L2_FIELD_NONE;\n\tpixm->num_planes = __fmt->memplanes;\n\tpixm->pixelformat = __fmt->fourcc;\n\t \n\tv4l_bound_align_image(&pixm->width, FIMC_ISP_SOURCE_WIDTH_MIN,\n\t\t\t      FIMC_ISP_SOURCE_WIDTH_MAX, 3,\n\t\t\t      &pixm->height, FIMC_ISP_SOURCE_HEIGHT_MIN,\n\t\t\t      FIMC_ISP_SOURCE_HEIGHT_MAX, 0, 0);\n}\n\nstatic int isp_video_try_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct fimc_isp *isp = video_drvdata(file);\n\n\t__isp_video_try_fmt(isp, &f->fmt.pix_mp, NULL);\n\treturn 0;\n}\n\nstatic int isp_video_s_fmt_mplane(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct fimc_isp *isp = video_drvdata(file);\n\tstruct fimc_is *is = fimc_isp_to_is(isp);\n\tstruct v4l2_pix_format_mplane *pixm = &f->fmt.pix_mp;\n\tconst struct fimc_fmt *ifmt = NULL;\n\tstruct param_dma_output *dma = __get_isp_dma2(is);\n\n\t__isp_video_try_fmt(isp, pixm, &ifmt);\n\n\tif (WARN_ON(ifmt == NULL))\n\t\treturn -EINVAL;\n\n\tdma->format = DMA_OUTPUT_FORMAT_BAYER;\n\tdma->order = DMA_OUTPUT_ORDER_GB_BG;\n\tdma->plane = ifmt->memplanes;\n\tdma->bitwidth = ifmt->depth[0];\n\tdma->width = pixm->width;\n\tdma->height = pixm->height;\n\n\tfimc_is_mem_barrier();\n\n\tisp->video_capture.format = ifmt;\n\tisp->video_capture.pixfmt = *pixm;\n\n\treturn 0;\n}\n\n \nstatic int isp_video_pipeline_validate(struct fimc_isp *isp)\n{\n\tstruct v4l2_subdev *sd = &isp->subdev;\n\tstruct media_pad *pad;\n\tint ret;\n\n\twhile (1) {\n\t\tstruct v4l2_subdev_format sink_fmt = {\n\t\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t};\n\t\tstruct v4l2_subdev_format src_fmt = {\n\t\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t};\n\n\t\t \n\t\tpad = &sd->entity.pads[0];\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tbreak;\n\t\tsink_fmt.pad = pad->index;\n\t\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &sink_fmt);\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\t\treturn -EPIPE;\n\n\t\t \n\t\tpad = media_pad_remote_pad_first(pad);\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tbreak;\n\n\t\tsd = media_entity_to_v4l2_subdev(pad->entity);\n\t\tsrc_fmt.pad = pad->index;\n\t\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &src_fmt);\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\t\treturn -EPIPE;\n\n\t\tif (src_fmt.format.width != sink_fmt.format.width ||\n\t\t    src_fmt.format.height != sink_fmt.format.height ||\n\t\t    src_fmt.format.code != sink_fmt.format.code)\n\t\t\treturn -EPIPE;\n\t}\n\n\treturn 0;\n}\n\nstatic int isp_video_streamon(struct file *file, void *priv,\n\t\t\t\t      enum v4l2_buf_type type)\n{\n\tstruct fimc_isp *isp = video_drvdata(file);\n\tstruct exynos_video_entity *ve = &isp->video_capture.ve;\n\tint ret;\n\n\tret = video_device_pipeline_start(&ve->vdev, &ve->pipe->mp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = isp_video_pipeline_validate(isp);\n\tif (ret < 0)\n\t\tgoto p_stop;\n\n\tret = vb2_ioctl_streamon(file, priv, type);\n\tif (ret < 0)\n\t\tgoto p_stop;\n\n\tisp->video_capture.streaming = 1;\n\treturn 0;\np_stop:\n\tvideo_device_pipeline_stop(&ve->vdev);\n\treturn ret;\n}\n\nstatic int isp_video_streamoff(struct file *file, void *priv,\n\t\t\t\t\tenum v4l2_buf_type type)\n{\n\tstruct fimc_isp *isp = video_drvdata(file);\n\tstruct fimc_is_video *video = &isp->video_capture;\n\tint ret;\n\n\tret = vb2_ioctl_streamoff(file, priv, type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvideo_device_pipeline_stop(&video->ve.vdev);\n\tvideo->streaming = 0;\n\treturn 0;\n}\n\nstatic int isp_video_reqbufs(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_requestbuffers *rb)\n{\n\tstruct fimc_isp *isp = video_drvdata(file);\n\tint ret;\n\n\tret = vb2_ioctl_reqbufs(file, priv, rb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (rb->count && rb->count < FIMC_ISP_REQ_BUFS_MIN) {\n\t\trb->count = 0;\n\t\tvb2_ioctl_reqbufs(file, priv, rb);\n\t\tret = -ENOMEM;\n\t}\n\n\tisp->video_capture.reqbufs_count = rb->count;\n\treturn ret;\n}\n\nstatic const struct v4l2_ioctl_ops isp_video_ioctl_ops = {\n\t.vidioc_querycap\t\t= isp_video_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= isp_video_enum_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane\t= isp_video_try_fmt_mplane,\n\t.vidioc_s_fmt_vid_cap_mplane\t= isp_video_s_fmt_mplane,\n\t.vidioc_g_fmt_vid_cap_mplane\t= isp_video_g_fmt_mplane,\n\t.vidioc_reqbufs\t\t\t= isp_video_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_streamon\t\t= isp_video_streamon,\n\t.vidioc_streamoff\t\t= isp_video_streamoff,\n};\n\nint fimc_isp_video_device_register(struct fimc_isp *isp,\n\t\t\t\t   struct v4l2_device *v4l2_dev,\n\t\t\t\t   enum v4l2_buf_type type)\n{\n\tstruct vb2_queue *q = &isp->video_capture.vb_queue;\n\tstruct fimc_is_video *iv;\n\tstruct video_device *vdev;\n\tint ret;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tiv = &isp->video_capture;\n\telse\n\t\treturn -ENOSYS;\n\n\tmutex_init(&isp->video_lock);\n\tINIT_LIST_HEAD(&iv->pending_buf_q);\n\tINIT_LIST_HEAD(&iv->active_buf_q);\n\tiv->format = fimc_isp_find_format(NULL, NULL, 0);\n\tiv->pixfmt.width = IS_DEFAULT_WIDTH;\n\tiv->pixfmt.height = IS_DEFAULT_HEIGHT;\n\tiv->pixfmt.pixelformat = iv->format->fourcc;\n\tiv->pixfmt.colorspace = V4L2_COLORSPACE_SRGB;\n\tiv->reqbufs_count = 0;\n\n\tmemset(q, 0, sizeof(*q));\n\tq->type = type;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR;\n\tq->ops = &isp_video_capture_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->buf_struct_size = sizeof(struct isp_video_buf);\n\tq->drv_priv = isp;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &isp->video_lock;\n\tq->dev = &isp->pdev->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvdev = &iv->ve.vdev;\n\tmemset(vdev, 0, sizeof(*vdev));\n\tstrscpy(vdev->name, \"fimc-is-isp.capture\", sizeof(vdev->name));\n\tvdev->queue = q;\n\tvdev->fops = &isp_video_fops;\n\tvdev->ioctl_ops = &isp_video_ioctl_ops;\n\tvdev->v4l2_dev = v4l2_dev;\n\tvdev->minor = -1;\n\tvdev->release = video_device_release_empty;\n\tvdev->lock = &isp->video_lock;\n\tvdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE_MPLANE;\n\n\tiv->pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&vdev->entity, 1, &iv->pad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvideo_set_drvdata(vdev, isp);\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0) {\n\t\tmedia_entity_cleanup(&vdev->entity);\n\t\treturn ret;\n\t}\n\n\tv4l2_info(v4l2_dev, \"Registered %s as /dev/%s\\n\",\n\t\t  vdev->name, video_device_node_name(vdev));\n\n\treturn 0;\n}\n\nvoid fimc_isp_video_device_unregister(struct fimc_isp *isp,\n\t\t\t\t      enum v4l2_buf_type type)\n{\n\tstruct exynos_video_entity *ve;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tve = &isp->video_capture.ve;\n\telse\n\t\treturn;\n\n\tmutex_lock(&isp->video_lock);\n\n\tif (video_is_registered(&ve->vdev)) {\n\t\tvideo_unregister_device(&ve->vdev);\n\t\tmedia_entity_cleanup(&ve->vdev.entity);\n\t\tve->pipe = NULL;\n\t}\n\n\tmutex_unlock(&isp->video_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}