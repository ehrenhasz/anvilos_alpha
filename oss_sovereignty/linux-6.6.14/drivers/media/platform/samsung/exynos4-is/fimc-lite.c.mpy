{
  "module_name": "fimc-lite.c",
  "hash_id": "0a3b220e23442856e6bf5c2b661026694468c23cfb8ff43e9d17c5a22ac2e404",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-lite.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"%s:%d \" fmt, __func__, __LINE__\n\n#include <linux/bug.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-rect.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/drv-intf/exynos-fimc.h>\n\n#include \"common.h\"\n#include \"fimc-core.h\"\n#include \"fimc-lite.h\"\n#include \"fimc-lite-reg.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\n\nstatic const struct fimc_fmt fimc_lite_formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.colorspace\t= V4L2_COLORSPACE_JPEG,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_YCBYCR422,\n\t\t.memplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.flags\t\t= FMT_FLAGS_YUV,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_UYVY,\n\t\t.colorspace\t= V4L2_COLORSPACE_JPEG,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_CBYCRY422,\n\t\t.memplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.flags\t\t= FMT_FLAGS_YUV,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_VYUY,\n\t\t.colorspace\t= V4L2_COLORSPACE_JPEG,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_CRYCBY422,\n\t\t.memplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_VYUY8_2X8,\n\t\t.flags\t\t= FMT_FLAGS_YUV,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YVYU,\n\t\t.colorspace\t= V4L2_COLORSPACE_JPEG,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_YCRYCB422,\n\t\t.memplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YVYU8_2X8,\n\t\t.flags\t\t= FMT_FLAGS_YUV,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.depth\t\t= { 8 },\n\t\t.color\t\t= FIMC_FMT_RAW8,\n\t\t.memplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.flags\t\t= FMT_FLAGS_RAW_BAYER,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG10,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_RAW10,\n\t\t.memplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.flags\t\t= FMT_FLAGS_RAW_BAYER,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG12,\n\t\t.colorspace\t= V4L2_COLORSPACE_SRGB,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_RAW12,\n\t\t.memplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.flags\t\t= FMT_FLAGS_RAW_BAYER,\n\t},\n};\n\n \nstatic const struct fimc_fmt *fimc_lite_find_format(const u32 *pixelformat,\n\t\t\tconst u32 *mbus_code, unsigned int mask, int index)\n{\n\tconst struct fimc_fmt *fmt, *def_fmt = NULL;\n\tunsigned int i;\n\tint id = 0;\n\n\tif (index >= (int)ARRAY_SIZE(fimc_lite_formats))\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(fimc_lite_formats); ++i) {\n\t\tfmt = &fimc_lite_formats[i];\n\t\tif (mask && !(fmt->flags & mask))\n\t\t\tcontinue;\n\t\tif (pixelformat && fmt->fourcc == *pixelformat)\n\t\t\treturn fmt;\n\t\tif (mbus_code && fmt->mbus_code == *mbus_code)\n\t\t\treturn fmt;\n\t\tif (index == id)\n\t\t\tdef_fmt = fmt;\n\t\tid++;\n\t}\n\treturn def_fmt;\n}\n\nstatic int fimc_lite_hw_init(struct fimc_lite *fimc, bool isp_output)\n{\n\tstruct fimc_source_info *si;\n\tunsigned long flags;\n\n\tif (fimc->sensor == NULL)\n\t\treturn -ENXIO;\n\n\tif (fimc->inp_frame.fmt == NULL || fimc->out_frame.fmt == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tsi = v4l2_get_subdev_hostdata(fimc->sensor);\n\tif (!si)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\n\tflite_hw_set_camera_bus(fimc, si);\n\tflite_hw_set_source_format(fimc, &fimc->inp_frame);\n\tflite_hw_set_window_offset(fimc, &fimc->inp_frame);\n\tflite_hw_set_dma_buf_mask(fimc, 0);\n\tflite_hw_set_output_dma(fimc, &fimc->out_frame, !isp_output);\n\tflite_hw_set_interrupt_mask(fimc);\n\tflite_hw_set_test_pattern(fimc, fimc->test_pattern->val);\n\n\tif (debug > 0)\n\t\tflite_hw_dump_regs(fimc, __func__);\n\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\treturn 0;\n}\n\n \nstatic int fimc_lite_reinit(struct fimc_lite *fimc, bool suspend)\n{\n\tstruct flite_buffer *buf;\n\tunsigned long flags;\n\tbool streaming;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tstreaming = fimc->state & (1 << ST_SENSOR_STREAM);\n\n\tfimc->state &= ~(1 << ST_FLITE_RUN | 1 << ST_FLITE_OFF |\n\t\t\t 1 << ST_FLITE_STREAM | 1 << ST_SENSOR_STREAM);\n\tif (suspend)\n\t\tfimc->state |= (1 << ST_FLITE_SUSPENDED);\n\telse\n\t\tfimc->state &= ~(1 << ST_FLITE_PENDING |\n\t\t\t\t 1 << ST_FLITE_SUSPENDED);\n\n\t \n\twhile (!suspend && !list_empty(&fimc->pending_buf_q)) {\n\t\tbuf = fimc_lite_pending_queue_pop(fimc);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\t \n\twhile (!list_empty(&fimc->active_buf_q)) {\n\t\tbuf = fimc_lite_active_queue_pop(fimc);\n\t\tif (suspend)\n\t\t\tfimc_lite_pending_queue_add(fimc, buf);\n\t\telse\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\tflite_hw_reset(fimc);\n\n\tif (!streaming)\n\t\treturn 0;\n\n\treturn fimc_pipeline_call(&fimc->ve, set_stream, 0);\n}\n\nstatic int fimc_lite_stop_capture(struct fimc_lite *fimc, bool suspend)\n{\n\tunsigned long flags;\n\n\tif (!fimc_lite_active(fimc))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tset_bit(ST_FLITE_OFF, &fimc->state);\n\tflite_hw_capture_stop(fimc);\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\twait_event_timeout(fimc->irq_queue,\n\t\t\t   !test_bit(ST_FLITE_OFF, &fimc->state),\n\t\t\t   (2*HZ/10));  \n\n\treturn fimc_lite_reinit(fimc, suspend);\n}\n\n \nstatic void fimc_lite_config_update(struct fimc_lite *fimc)\n{\n\tflite_hw_set_window_offset(fimc, &fimc->inp_frame);\n\tflite_hw_set_dma_window(fimc, &fimc->out_frame);\n\tflite_hw_set_test_pattern(fimc, fimc->test_pattern->val);\n\tclear_bit(ST_FLITE_CONFIG, &fimc->state);\n}\n\nstatic irqreturn_t flite_irq_handler(int irq, void *priv)\n{\n\tstruct fimc_lite *fimc = priv;\n\tstruct flite_buffer *vbuf;\n\tunsigned long flags;\n\tu32 intsrc;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\n\tintsrc = flite_hw_get_interrupt_source(fimc);\n\tflite_hw_clear_pending_irq(fimc);\n\n\tif (test_and_clear_bit(ST_FLITE_OFF, &fimc->state)) {\n\t\twake_up(&fimc->irq_queue);\n\t\tgoto done;\n\t}\n\n\tif (intsrc & FLITE_REG_CISTATUS_IRQ_SRC_OVERFLOW) {\n\t\tclear_bit(ST_FLITE_RUN, &fimc->state);\n\t\tfimc->events.data_overflow++;\n\t}\n\n\tif (intsrc & FLITE_REG_CISTATUS_IRQ_SRC_LASTCAPEND) {\n\t\tflite_hw_clear_last_capture_end(fimc);\n\t\tclear_bit(ST_FLITE_STREAM, &fimc->state);\n\t\twake_up(&fimc->irq_queue);\n\t}\n\n\tif (atomic_read(&fimc->out_path) != FIMC_IO_DMA)\n\t\tgoto done;\n\n\tif ((intsrc & FLITE_REG_CISTATUS_IRQ_SRC_FRMSTART) &&\n\t    test_bit(ST_FLITE_RUN, &fimc->state) &&\n\t    !list_empty(&fimc->pending_buf_q)) {\n\t\tvbuf = fimc_lite_pending_queue_pop(fimc);\n\t\tflite_hw_set_dma_buffer(fimc, vbuf);\n\t\tfimc_lite_active_queue_add(fimc, vbuf);\n\t}\n\n\tif ((intsrc & FLITE_REG_CISTATUS_IRQ_SRC_FRMEND) &&\n\t    test_bit(ST_FLITE_RUN, &fimc->state) &&\n\t    !list_empty(&fimc->active_buf_q)) {\n\t\tvbuf = fimc_lite_active_queue_pop(fimc);\n\t\tvbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tvbuf->vb.sequence = fimc->frame_count++;\n\t\tflite_hw_mask_dma_buffer(fimc, vbuf->index);\n\t\tvb2_buffer_done(&vbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t}\n\n\tif (test_bit(ST_FLITE_CONFIG, &fimc->state))\n\t\tfimc_lite_config_update(fimc);\n\n\tif (list_empty(&fimc->pending_buf_q)) {\n\t\tflite_hw_capture_stop(fimc);\n\t\tclear_bit(ST_FLITE_STREAM, &fimc->state);\n\t}\ndone:\n\tset_bit(ST_FLITE_RUN, &fimc->state);\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct fimc_lite *fimc = q->drv_priv;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\n\tfimc->buf_index = 0;\n\tfimc->frame_count = 0;\n\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\tret = fimc_lite_hw_init(fimc, false);\n\tif (ret) {\n\t\tfimc_lite_reinit(fimc, false);\n\t\treturn ret;\n\t}\n\n\tset_bit(ST_FLITE_PENDING, &fimc->state);\n\n\tif (!list_empty(&fimc->active_buf_q) &&\n\t    !test_and_set_bit(ST_FLITE_STREAM, &fimc->state)) {\n\t\tflite_hw_capture_start(fimc);\n\n\t\tif (!test_and_set_bit(ST_SENSOR_STREAM, &fimc->state))\n\t\t\tfimc_pipeline_call(&fimc->ve, set_stream, 1);\n\t}\n\tif (debug > 0)\n\t\tflite_hw_dump_regs(fimc, __func__);\n\n\treturn 0;\n}\n\nstatic void stop_streaming(struct vb2_queue *q)\n{\n\tstruct fimc_lite *fimc = q->drv_priv;\n\n\tif (!fimc_lite_active(fimc))\n\t\treturn;\n\n\tfimc_lite_stop_capture(fimc, false);\n}\n\nstatic int queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *num_buffers, unsigned int *num_planes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct fimc_lite *fimc = vq->drv_priv;\n\tstruct flite_frame *frame = &fimc->out_frame;\n\tconst struct fimc_fmt *fmt = frame->fmt;\n\tunsigned long wh = frame->f_width * frame->f_height;\n\tint i;\n\n\tif (fmt == NULL)\n\t\treturn -EINVAL;\n\n\tif (*num_planes) {\n\t\tif (*num_planes != fmt->memplanes)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < *num_planes; i++)\n\t\t\tif (sizes[i] < (wh * fmt->depth[i]) / 8)\n\t\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t*num_planes = fmt->memplanes;\n\n\tfor (i = 0; i < fmt->memplanes; i++)\n\t\tsizes[i] = (wh * fmt->depth[i]) / 8;\n\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct fimc_lite *fimc = vq->drv_priv;\n\tint i;\n\n\tif (fimc->out_frame.fmt == NULL)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < fimc->out_frame.fmt->memplanes; i++) {\n\t\tunsigned long size = fimc->payload[i];\n\n\t\tif (vb2_plane_size(vb, i) < size) {\n\t\t\tv4l2_err(&fimc->ve.vdev,\n\t\t\t\t \"User buffer too small (%ld < %ld)\\n\",\n\t\t\t\t vb2_plane_size(vb, i), size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvb2_set_plane_payload(vb, i, size);\n\t}\n\n\treturn 0;\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct flite_buffer *buf\n\t\t= container_of(vbuf, struct flite_buffer, vb);\n\tstruct fimc_lite *fimc = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tbuf->addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\n\tbuf->index = fimc->buf_index++;\n\tif (fimc->buf_index >= fimc->reqbufs_count)\n\t\tfimc->buf_index = 0;\n\n\tif (!test_bit(ST_FLITE_SUSPENDED, &fimc->state) &&\n\t    !test_bit(ST_FLITE_STREAM, &fimc->state) &&\n\t    list_empty(&fimc->active_buf_q)) {\n\t\tflite_hw_set_dma_buffer(fimc, buf);\n\t\tfimc_lite_active_queue_add(fimc, buf);\n\t} else {\n\t\tfimc_lite_pending_queue_add(fimc, buf);\n\t}\n\n\tif (vb2_is_streaming(&fimc->vb_queue) &&\n\t    !list_empty(&fimc->pending_buf_q) &&\n\t    !test_and_set_bit(ST_FLITE_STREAM, &fimc->state)) {\n\t\tflite_hw_capture_start(fimc);\n\t\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\t\tif (!test_and_set_bit(ST_SENSOR_STREAM, &fimc->state))\n\t\t\tfimc_pipeline_call(&fimc->ve, set_stream, 1);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n}\n\nstatic const struct vb2_ops fimc_lite_qops = {\n\t.queue_setup\t = queue_setup,\n\t.buf_prepare\t = buffer_prepare,\n\t.buf_queue\t = buffer_queue,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n\t.start_streaming = start_streaming,\n\t.stop_streaming\t = stop_streaming,\n};\n\nstatic void fimc_lite_clear_event_counters(struct fimc_lite *fimc)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tmemset(&fimc->events, 0, sizeof(fimc->events));\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n}\n\nstatic int fimc_lite_open(struct file *file)\n{\n\tstruct fimc_lite *fimc = video_drvdata(file);\n\tstruct media_entity *me = &fimc->ve.vdev.entity;\n\tint ret;\n\n\tmutex_lock(&fimc->lock);\n\tif (atomic_read(&fimc->out_path) != FIMC_IO_DMA) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tset_bit(ST_FLITE_IN_USE, &fimc->state);\n\tret = pm_runtime_resume_and_get(&fimc->pdev->dev);\n\tif (ret < 0)\n\t\tgoto err_in_use;\n\n\tret = v4l2_fh_open(file);\n\tif (ret < 0)\n\t\tgoto err_pm;\n\n\tif (!v4l2_fh_is_singular_file(file) ||\n\t    atomic_read(&fimc->out_path) != FIMC_IO_DMA)\n\t\tgoto unlock;\n\n\tmutex_lock(&me->graph_obj.mdev->graph_mutex);\n\n\tret = fimc_pipeline_call(&fimc->ve, open, me, true);\n\n\t \n\tif (ret == 0)\n\t\tme->use_count++;\n\n\tmutex_unlock(&me->graph_obj.mdev->graph_mutex);\n\n\tif (!ret) {\n\t\tfimc_lite_clear_event_counters(fimc);\n\t\tgoto unlock;\n\t}\n\n\tv4l2_fh_release(file);\nerr_pm:\n\tpm_runtime_put_sync(&fimc->pdev->dev);\nerr_in_use:\n\tclear_bit(ST_FLITE_IN_USE, &fimc->state);\nunlock:\n\tmutex_unlock(&fimc->lock);\n\treturn ret;\n}\n\nstatic int fimc_lite_release(struct file *file)\n{\n\tstruct fimc_lite *fimc = video_drvdata(file);\n\tstruct media_entity *entity = &fimc->ve.vdev.entity;\n\n\tmutex_lock(&fimc->lock);\n\n\tif (v4l2_fh_is_singular_file(file) &&\n\t    atomic_read(&fimc->out_path) == FIMC_IO_DMA) {\n\t\tif (fimc->streaming) {\n\t\t\tvideo_device_pipeline_stop(&fimc->ve.vdev);\n\t\t\tfimc->streaming = false;\n\t\t}\n\t\tfimc_lite_stop_capture(fimc, false);\n\t\tfimc_pipeline_call(&fimc->ve, close);\n\t\tclear_bit(ST_FLITE_IN_USE, &fimc->state);\n\n\t\tmutex_lock(&entity->graph_obj.mdev->graph_mutex);\n\t\tentity->use_count--;\n\t\tmutex_unlock(&entity->graph_obj.mdev->graph_mutex);\n\t}\n\n\t_vb2_fop_release(file, NULL);\n\tpm_runtime_put(&fimc->pdev->dev);\n\tclear_bit(ST_FLITE_SUSPENDED, &fimc->state);\n\n\tmutex_unlock(&fimc->lock);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations fimc_lite_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= fimc_lite_open,\n\t.release\t= fimc_lite_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= vb2_fop_mmap,\n};\n\n \n\nstatic const struct fimc_fmt *fimc_lite_subdev_try_fmt(struct fimc_lite *fimc,\n\t\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\t\tstruct v4l2_subdev_format *format)\n{\n\tstruct flite_drvdata *dd = fimc->dd;\n\tstruct v4l2_mbus_framefmt *mf = &format->format;\n\tconst struct fimc_fmt *fmt = NULL;\n\n\tif (format->pad == FLITE_SD_PAD_SINK) {\n\t\tv4l_bound_align_image(&mf->width, 8, dd->max_width,\n\t\t\t\tffs(dd->out_width_align) - 1,\n\t\t\t\t&mf->height, 0, dd->max_height, 0, 0);\n\n\t\tfmt = fimc_lite_find_format(NULL, &mf->code, 0, 0);\n\t\tif (WARN_ON(!fmt))\n\t\t\treturn NULL;\n\n\t\tmf->colorspace = fmt->colorspace;\n\t\tmf->code = fmt->mbus_code;\n\t} else {\n\t\tstruct flite_frame *sink = &fimc->inp_frame;\n\t\tstruct v4l2_mbus_framefmt *sink_fmt;\n\t\tstruct v4l2_rect *rect;\n\n\t\tif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t\tsink_fmt = v4l2_subdev_get_try_format(&fimc->subdev,\n\t\t\t\t\t\t\t      sd_state,\n\t\t\t\t\t\t\t      FLITE_SD_PAD_SINK);\n\n\t\t\tmf->code = sink_fmt->code;\n\t\t\tmf->colorspace = sink_fmt->colorspace;\n\n\t\t\trect = v4l2_subdev_get_try_crop(&fimc->subdev,\n\t\t\t\t\t\t\tsd_state,\n\t\t\t\t\t\t\tFLITE_SD_PAD_SINK);\n\t\t} else {\n\t\t\tmf->code = sink->fmt->mbus_code;\n\t\t\tmf->colorspace = sink->fmt->colorspace;\n\t\t\trect = &sink->rect;\n\t\t}\n\n\t\t \n\t\tmf->width = rect->width;\n\t\tmf->height = rect->height;\n\t}\n\n\tmf->field = V4L2_FIELD_NONE;\n\n\tv4l2_dbg(1, debug, &fimc->subdev, \"code: %#x (%d), %dx%d\\n\",\n\t\t mf->code, mf->colorspace, mf->width, mf->height);\n\n\treturn fmt;\n}\n\nstatic void fimc_lite_try_crop(struct fimc_lite *fimc, struct v4l2_rect *r)\n{\n\tstruct flite_frame *frame = &fimc->inp_frame;\n\n\tv4l_bound_align_image(&r->width, 0, frame->f_width, 0,\n\t\t\t      &r->height, 0, frame->f_height, 0, 0);\n\n\t \n\tr->left = clamp_t(u32, r->left, 0, frame->f_width - r->width);\n\tr->left = round_down(r->left, fimc->dd->win_hor_offs_align);\n\tr->top  = clamp_t(u32, r->top, 0, frame->f_height - r->height);\n\n\tv4l2_dbg(1, debug, &fimc->subdev, \"(%d,%d)/%dx%d, sink fmt: %dx%d\\n\",\n\t\t r->left, r->top, r->width, r->height,\n\t\t frame->f_width, frame->f_height);\n}\n\nstatic void fimc_lite_try_compose(struct fimc_lite *fimc, struct v4l2_rect *r)\n{\n\tstruct flite_frame *frame = &fimc->out_frame;\n\tstruct v4l2_rect *crop_rect = &fimc->inp_frame.rect;\n\n\t \n\tr->width = crop_rect->width;\n\tr->height = crop_rect->height;\n\n\t \n\tr->left = clamp_t(u32, r->left, 0, frame->f_width - r->width);\n\tr->left = round_down(r->left, fimc->dd->out_hor_offs_align);\n\tr->top  = clamp_t(u32, r->top, 0, fimc->out_frame.f_height - r->height);\n\n\tv4l2_dbg(1, debug, &fimc->subdev, \"(%d,%d)/%dx%d, source fmt: %dx%d\\n\",\n\t\t r->left, r->top, r->width, r->height,\n\t\t frame->f_width, frame->f_height);\n}\n\n \nstatic int fimc_lite_querycap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, FIMC_LITE_DRV_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, FIMC_LITE_DRV_NAME, sizeof(cap->card));\n\treturn 0;\n}\n\nstatic int fimc_lite_enum_fmt(struct file *file, void *priv,\n\t\t\t      struct v4l2_fmtdesc *f)\n{\n\tconst struct fimc_fmt *fmt;\n\n\tif (f->index >= ARRAY_SIZE(fimc_lite_formats))\n\t\treturn -EINVAL;\n\n\tfmt = &fimc_lite_formats[f->index];\n\tf->pixelformat = fmt->fourcc;\n\n\treturn 0;\n}\n\nstatic int fimc_lite_g_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct fimc_lite *fimc = video_drvdata(file);\n\tstruct v4l2_pix_format_mplane *pixm = &f->fmt.pix_mp;\n\tstruct v4l2_plane_pix_format *plane_fmt = &pixm->plane_fmt[0];\n\tstruct flite_frame *frame = &fimc->out_frame;\n\tconst struct fimc_fmt *fmt = frame->fmt;\n\n\tplane_fmt->bytesperline = (frame->f_width * fmt->depth[0]) / 8;\n\tplane_fmt->sizeimage = plane_fmt->bytesperline * frame->f_height;\n\n\tpixm->num_planes = fmt->memplanes;\n\tpixm->pixelformat = fmt->fourcc;\n\tpixm->width = frame->f_width;\n\tpixm->height = frame->f_height;\n\tpixm->field = V4L2_FIELD_NONE;\n\tpixm->colorspace = fmt->colorspace;\n\treturn 0;\n}\n\nstatic int fimc_lite_try_fmt(struct fimc_lite *fimc,\n\t\t\t     struct v4l2_pix_format_mplane *pixm,\n\t\t\t     const struct fimc_fmt **ffmt)\n{\n\tu32 bpl = pixm->plane_fmt[0].bytesperline;\n\tstruct flite_drvdata *dd = fimc->dd;\n\tconst struct fimc_fmt *inp_fmt = fimc->inp_frame.fmt;\n\tconst struct fimc_fmt *fmt;\n\n\tif (WARN_ON(inp_fmt == NULL))\n\t\treturn -EINVAL;\n\t \n\tif (inp_fmt->flags & FMT_FLAGS_YUV)\n\t\tfmt = fimc_lite_find_format(&pixm->pixelformat, NULL,\n\t\t\t\t\t\tinp_fmt->flags, 0);\n\telse\n\t\tfmt = inp_fmt;\n\n\tif (WARN_ON(fmt == NULL))\n\t\treturn -EINVAL;\n\tif (ffmt)\n\t\t*ffmt = fmt;\n\tv4l_bound_align_image(&pixm->width, 8, dd->max_width,\n\t\t\t      ffs(dd->out_width_align) - 1,\n\t\t\t      &pixm->height, 0, dd->max_height, 0, 0);\n\n\tif ((bpl == 0 || ((bpl * 8) / fmt->depth[0]) < pixm->width))\n\t\tpixm->plane_fmt[0].bytesperline = (pixm->width *\n\t\t\t\t\t\t   fmt->depth[0]) / 8;\n\n\tif (pixm->plane_fmt[0].sizeimage == 0)\n\t\tpixm->plane_fmt[0].sizeimage = (pixm->width * pixm->height *\n\t\t\t\t\t\tfmt->depth[0]) / 8;\n\tpixm->num_planes = fmt->memplanes;\n\tpixm->pixelformat = fmt->fourcc;\n\tpixm->colorspace = fmt->colorspace;\n\tpixm->field = V4L2_FIELD_NONE;\n\treturn 0;\n}\n\nstatic int fimc_lite_try_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct fimc_lite *fimc = video_drvdata(file);\n\treturn fimc_lite_try_fmt(fimc, &f->fmt.pix_mp, NULL);\n}\n\nstatic int fimc_lite_s_fmt_mplane(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pixm = &f->fmt.pix_mp;\n\tstruct fimc_lite *fimc = video_drvdata(file);\n\tstruct flite_frame *frame = &fimc->out_frame;\n\tconst struct fimc_fmt *fmt = NULL;\n\tint ret;\n\n\tif (vb2_is_busy(&fimc->vb_queue))\n\t\treturn -EBUSY;\n\n\tret = fimc_lite_try_fmt(fimc, &f->fmt.pix_mp, &fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tframe->fmt = fmt;\n\tfimc->payload[0] = max((pixm->width * pixm->height * fmt->depth[0]) / 8,\n\t\t\t       pixm->plane_fmt[0].sizeimage);\n\tframe->f_width = pixm->width;\n\tframe->f_height = pixm->height;\n\n\treturn 0;\n}\n\nstatic int fimc_pipeline_validate(struct fimc_lite *fimc)\n{\n\tstruct v4l2_subdev *sd = &fimc->subdev;\n\tstruct v4l2_subdev_format sink_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev_format src_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct media_pad *pad;\n\tint ret;\n\n\twhile (1) {\n\t\t \n\t\tpad = &sd->entity.pads[0];\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tbreak;\n\t\t \n\t\tif (sd == &fimc->subdev) {\n\t\t\tstruct flite_frame *ff = &fimc->out_frame;\n\t\t\tsink_fmt.format.width = ff->f_width;\n\t\t\tsink_fmt.format.height = ff->f_height;\n\t\t\tsink_fmt.format.code = fimc->inp_frame.fmt->mbus_code;\n\t\t} else {\n\t\t\tsink_fmt.pad = pad->index;\n\t\t\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL,\n\t\t\t\t\t       &sink_fmt);\n\t\t\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\t\t\treturn -EPIPE;\n\t\t}\n\t\t \n\t\tpad = media_pad_remote_pad_first(pad);\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tbreak;\n\n\t\tsd = media_entity_to_v4l2_subdev(pad->entity);\n\t\tsrc_fmt.pad = pad->index;\n\t\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &src_fmt);\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\t\treturn -EPIPE;\n\n\t\tif (src_fmt.format.width != sink_fmt.format.width ||\n\t\t    src_fmt.format.height != sink_fmt.format.height ||\n\t\t    src_fmt.format.code != sink_fmt.format.code)\n\t\t\treturn -EPIPE;\n\t}\n\treturn 0;\n}\n\nstatic int fimc_lite_streamon(struct file *file, void *priv,\n\t\t\t      enum v4l2_buf_type type)\n{\n\tstruct fimc_lite *fimc = video_drvdata(file);\n\tint ret;\n\n\tif (fimc_lite_active(fimc))\n\t\treturn -EBUSY;\n\n\tret = video_device_pipeline_start(&fimc->ve.vdev, &fimc->ve.pipe->mp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = fimc_pipeline_validate(fimc);\n\tif (ret < 0)\n\t\tgoto err_p_stop;\n\n\tfimc->sensor = fimc_find_remote_sensor(&fimc->subdev.entity);\n\n\tret = vb2_ioctl_streamon(file, priv, type);\n\tif (!ret) {\n\t\tfimc->streaming = true;\n\t\treturn ret;\n\t}\n\nerr_p_stop:\n\tvideo_device_pipeline_stop(&fimc->ve.vdev);\n\treturn 0;\n}\n\nstatic int fimc_lite_streamoff(struct file *file, void *priv,\n\t\t\t       enum v4l2_buf_type type)\n{\n\tstruct fimc_lite *fimc = video_drvdata(file);\n\tint ret;\n\n\tret = vb2_ioctl_streamoff(file, priv, type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvideo_device_pipeline_stop(&fimc->ve.vdev);\n\tfimc->streaming = false;\n\treturn 0;\n}\n\nstatic int fimc_lite_reqbufs(struct file *file, void *priv,\n\t\t\t     struct v4l2_requestbuffers *reqbufs)\n{\n\tstruct fimc_lite *fimc = video_drvdata(file);\n\tint ret;\n\n\treqbufs->count = max_t(u32, FLITE_REQ_BUFS_MIN, reqbufs->count);\n\tret = vb2_ioctl_reqbufs(file, priv, reqbufs);\n\tif (!ret)\n\t\tfimc->reqbufs_count = reqbufs->count;\n\n\treturn ret;\n}\n\nstatic int fimc_lite_g_selection(struct file *file, void *fh,\n\t\t\t\t struct v4l2_selection *sel)\n{\n\tstruct fimc_lite *fimc = video_drvdata(file);\n\tstruct flite_frame *f = &fimc->out_frame;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = f->f_width;\n\t\tsel->r.height = f->f_height;\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tsel->r = f->rect;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int fimc_lite_s_selection(struct file *file, void *fh,\n\t\t\t\t struct v4l2_selection *sel)\n{\n\tstruct fimc_lite *fimc = video_drvdata(file);\n\tstruct flite_frame *f = &fimc->out_frame;\n\tstruct v4l2_rect rect = sel->r;\n\tunsigned long flags;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\n\t    sel->target != V4L2_SEL_TGT_COMPOSE)\n\t\treturn -EINVAL;\n\n\tfimc_lite_try_compose(fimc, &rect);\n\n\tif ((sel->flags & V4L2_SEL_FLAG_LE) &&\n\t    !v4l2_rect_enclosed(&rect, &sel->r))\n\t\treturn -ERANGE;\n\n\tif ((sel->flags & V4L2_SEL_FLAG_GE) &&\n\t    !v4l2_rect_enclosed(&sel->r, &rect))\n\t\treturn -ERANGE;\n\n\tsel->r = rect;\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tf->rect = rect;\n\tset_bit(ST_FLITE_CONFIG, &fimc->state);\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops fimc_lite_ioctl_ops = {\n\t.vidioc_querycap\t\t= fimc_lite_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= fimc_lite_enum_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane\t= fimc_lite_try_fmt_mplane,\n\t.vidioc_s_fmt_vid_cap_mplane\t= fimc_lite_s_fmt_mplane,\n\t.vidioc_g_fmt_vid_cap_mplane\t= fimc_lite_g_fmt_mplane,\n\t.vidioc_g_selection\t\t= fimc_lite_g_selection,\n\t.vidioc_s_selection\t\t= fimc_lite_s_selection,\n\t.vidioc_reqbufs\t\t\t= fimc_lite_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_streamon\t\t= fimc_lite_streamon,\n\t.vidioc_streamoff\t\t= fimc_lite_streamoff,\n};\n\n \nstatic int fimc_lite_link_setup(struct media_entity *entity,\n\t\t\t\tconst struct media_pad *local,\n\t\t\t\tconst struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tif (WARN_ON(fimc == NULL))\n\t\treturn 0;\n\n\tv4l2_dbg(1, debug, sd, \"%s: %s --> %s, flags: 0x%x. source_id: 0x%x\\n\",\n\t\t __func__, remote->entity->name, local->entity->name,\n\t\t flags, fimc->source_subdev_grp_id);\n\n\tswitch (local->index) {\n\tcase FLITE_SD_PAD_SINK:\n\t\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\t\tif (fimc->source_subdev_grp_id == 0)\n\t\t\t\tfimc->source_subdev_grp_id = sd->grp_id;\n\t\t\telse\n\t\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tfimc->source_subdev_grp_id = 0;\n\t\t\tfimc->sensor = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase FLITE_SD_PAD_SOURCE_DMA:\n\t\tif (!(flags & MEDIA_LNK_FL_ENABLED))\n\t\t\tatomic_set(&fimc->out_path, FIMC_IO_NONE);\n\t\telse\n\t\t\tatomic_set(&fimc->out_path, FIMC_IO_DMA);\n\t\tbreak;\n\n\tcase FLITE_SD_PAD_SOURCE_ISP:\n\t\tif (!(flags & MEDIA_LNK_FL_ENABLED))\n\t\t\tatomic_set(&fimc->out_path, FIMC_IO_NONE);\n\t\telse\n\t\t\tatomic_set(&fimc->out_path, FIMC_IO_ISP);\n\t\tbreak;\n\n\tdefault:\n\t\tv4l2_err(sd, \"Invalid pad index\\n\");\n\t\tret = -EINVAL;\n\t}\n\tmb();\n\n\treturn ret;\n}\n\nstatic const struct media_entity_operations fimc_lite_subdev_media_ops = {\n\t.link_setup = fimc_lite_link_setup,\n};\n\nstatic int fimc_lite_subdev_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t\t   struct v4l2_subdev_mbus_code_enum *code)\n{\n\tconst struct fimc_fmt *fmt;\n\n\tfmt = fimc_lite_find_format(NULL, NULL, 0, code->index);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\tcode->code = fmt->mbus_code;\n\treturn 0;\n}\n\nstatic struct v4l2_mbus_framefmt *__fimc_lite_subdev_get_try_fmt(\n\t\tstruct v4l2_subdev *sd,\n\t\tstruct v4l2_subdev_state *sd_state, unsigned int pad)\n{\n\tif (pad != FLITE_SD_PAD_SINK)\n\t\tpad = FLITE_SD_PAD_SOURCE_DMA;\n\n\treturn v4l2_subdev_get_try_format(sd, sd_state, pad);\n}\n\nstatic int fimc_lite_subdev_get_fmt(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *mf = &fmt->format;\n\tstruct flite_frame *f = &fimc->inp_frame;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmf = __fimc_lite_subdev_get_try_fmt(sd, sd_state, fmt->pad);\n\t\tfmt->format = *mf;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&fimc->lock);\n\tmf->colorspace = f->fmt->colorspace;\n\tmf->code = f->fmt->mbus_code;\n\n\tif (fmt->pad == FLITE_SD_PAD_SINK) {\n\t\t \n\t\tmf->width = f->f_width;\n\t\tmf->height = f->f_height;\n\t} else {\n\t\t \n\t\tmf->width = f->rect.width;\n\t\tmf->height = f->rect.height;\n\t}\n\tmutex_unlock(&fimc->lock);\n\treturn 0;\n}\n\nstatic int fimc_lite_subdev_set_fmt(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *mf = &fmt->format;\n\tstruct flite_frame *sink = &fimc->inp_frame;\n\tstruct flite_frame *source = &fimc->out_frame;\n\tconst struct fimc_fmt *ffmt;\n\n\tv4l2_dbg(1, debug, sd, \"pad%d: code: 0x%x, %dx%d\\n\",\n\t\t fmt->pad, mf->code, mf->width, mf->height);\n\n\tmutex_lock(&fimc->lock);\n\n\tif ((atomic_read(&fimc->out_path) == FIMC_IO_ISP &&\n\t    media_entity_is_streaming(&sd->entity)) ||\n\t    (atomic_read(&fimc->out_path) == FIMC_IO_DMA &&\n\t    vb2_is_busy(&fimc->vb_queue))) {\n\t\tmutex_unlock(&fimc->lock);\n\t\treturn -EBUSY;\n\t}\n\n\tffmt = fimc_lite_subdev_try_fmt(fimc, sd_state, fmt);\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tstruct v4l2_mbus_framefmt *src_fmt;\n\n\t\tmf = __fimc_lite_subdev_get_try_fmt(sd, sd_state, fmt->pad);\n\t\t*mf = fmt->format;\n\n\t\tif (fmt->pad == FLITE_SD_PAD_SINK) {\n\t\t\tunsigned int pad = FLITE_SD_PAD_SOURCE_DMA;\n\t\t\tsrc_fmt = __fimc_lite_subdev_get_try_fmt(sd, sd_state,\n\t\t\t\t\t\t\t\t pad);\n\t\t\t*src_fmt = *mf;\n\t\t}\n\n\t\tmutex_unlock(&fimc->lock);\n\t\treturn 0;\n\t}\n\n\tif (fmt->pad == FLITE_SD_PAD_SINK) {\n\t\tsink->f_width = mf->width;\n\t\tsink->f_height = mf->height;\n\t\tsink->fmt = ffmt;\n\t\t \n\t\tsink->rect.width = mf->width;\n\t\tsink->rect.height = mf->height;\n\t\tsink->rect.left = 0;\n\t\tsink->rect.top = 0;\n\t\t \n\t\tsource->rect = sink->rect;\n\t\tsource->f_width = mf->width;\n\t\tsource->f_height = mf->height;\n\t}\n\n\tmutex_unlock(&fimc->lock);\n\treturn 0;\n}\n\nstatic int fimc_lite_subdev_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t\t  struct v4l2_subdev_selection *sel)\n{\n\tstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\n\tstruct flite_frame *f = &fimc->inp_frame;\n\n\tif ((sel->target != V4L2_SEL_TGT_CROP &&\n\t     sel->target != V4L2_SEL_TGT_CROP_BOUNDS) ||\n\t     sel->pad != FLITE_SD_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsel->r = *v4l2_subdev_get_try_crop(sd, sd_state, sel->pad);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&fimc->lock);\n\tif (sel->target == V4L2_SEL_TGT_CROP) {\n\t\tsel->r = f->rect;\n\t} else {\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = f->f_width;\n\t\tsel->r.height = f->f_height;\n\t}\n\tmutex_unlock(&fimc->lock);\n\n\tv4l2_dbg(1, debug, sd, \"%s: (%d,%d) %dx%d, f_w: %d, f_h: %d\\n\",\n\t\t __func__, f->rect.left, f->rect.top, f->rect.width,\n\t\t f->rect.height, f->f_width, f->f_height);\n\n\treturn 0;\n}\n\nstatic int fimc_lite_subdev_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t\t  struct v4l2_subdev_selection *sel)\n{\n\tstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\n\tstruct flite_frame *f = &fimc->inp_frame;\n\tint ret = 0;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP || sel->pad != FLITE_SD_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&fimc->lock);\n\tfimc_lite_try_crop(fimc, &sel->r);\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t*v4l2_subdev_get_try_crop(sd, sd_state, sel->pad) = sel->r;\n\t} else {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&fimc->slock, flags);\n\t\tf->rect = sel->r;\n\t\t \n\t\tfimc->out_frame.rect = sel->r;\n\t\tset_bit(ST_FLITE_CONFIG, &fimc->state);\n\t\tspin_unlock_irqrestore(&fimc->slock, flags);\n\t}\n\tmutex_unlock(&fimc->lock);\n\n\tv4l2_dbg(1, debug, sd, \"%s: (%d,%d) %dx%d, f_w: %d, f_h: %d\\n\",\n\t\t __func__, f->rect.left, f->rect.top, f->rect.width,\n\t\t f->rect.height, f->f_width, f->f_height);\n\n\treturn ret;\n}\n\nstatic int fimc_lite_subdev_s_stream(struct v4l2_subdev *sd, int on)\n{\n\tstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tfimc->sensor = fimc_find_remote_sensor(&sd->entity);\n\n\tif (atomic_read(&fimc->out_path) != FIMC_IO_ISP)\n\t\treturn -ENOIOCTLCMD;\n\n\tmutex_lock(&fimc->lock);\n\tif (on) {\n\t\tflite_hw_reset(fimc);\n\t\tret = fimc_lite_hw_init(fimc, true);\n\t\tif (!ret) {\n\t\t\tspin_lock_irqsave(&fimc->slock, flags);\n\t\t\tflite_hw_capture_start(fimc);\n\t\t\tspin_unlock_irqrestore(&fimc->slock, flags);\n\t\t}\n\t} else {\n\t\tset_bit(ST_FLITE_OFF, &fimc->state);\n\n\t\tspin_lock_irqsave(&fimc->slock, flags);\n\t\tflite_hw_capture_stop(fimc);\n\t\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\t\tret = wait_event_timeout(fimc->irq_queue,\n\t\t\t\t!test_bit(ST_FLITE_OFF, &fimc->state),\n\t\t\t\tmsecs_to_jiffies(200));\n\t\tif (ret == 0)\n\t\t\tv4l2_err(sd, \"s_stream(0) timeout\\n\");\n\t\tclear_bit(ST_FLITE_RUN, &fimc->state);\n\t}\n\n\tmutex_unlock(&fimc->lock);\n\treturn ret;\n}\n\nstatic int fimc_lite_log_status(struct v4l2_subdev *sd)\n{\n\tstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\n\n\tflite_hw_dump_regs(fimc, __func__);\n\treturn 0;\n}\n\nstatic int fimc_lite_subdev_registered(struct v4l2_subdev *sd)\n{\n\tstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\n\tstruct vb2_queue *q = &fimc->vb_queue;\n\tstruct video_device *vfd = &fimc->ve.vdev;\n\tint ret;\n\n\tmemset(vfd, 0, sizeof(*vfd));\n\tatomic_set(&fimc->out_path, FIMC_IO_DMA);\n\n\tsnprintf(vfd->name, sizeof(vfd->name), \"fimc-lite.%d.capture\",\n\t\t fimc->index);\n\n\tvfd->fops = &fimc_lite_fops;\n\tvfd->ioctl_ops = &fimc_lite_ioctl_ops;\n\tvfd->v4l2_dev = sd->v4l2_dev;\n\tvfd->minor = -1;\n\tvfd->release = video_device_release_empty;\n\tvfd->queue = q;\n\tvfd->device_caps = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING;\n\tfimc->reqbufs_count = 0;\n\n\tINIT_LIST_HEAD(&fimc->pending_buf_q);\n\tINIT_LIST_HEAD(&fimc->active_buf_q);\n\n\tmemset(q, 0, sizeof(*q));\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR;\n\tq->ops = &fimc_lite_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->buf_struct_size = sizeof(struct flite_buffer);\n\tq->drv_priv = fimc;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &fimc->lock;\n\tq->dev = &fimc->pdev->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfimc->vd_pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&vfd->entity, 1, &fimc->vd_pad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvideo_set_drvdata(vfd, fimc);\n\tfimc->ve.pipe = v4l2_get_subdev_hostdata(sd);\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0) {\n\t\tmedia_entity_cleanup(&vfd->entity);\n\t\tfimc->ve.pipe = NULL;\n\t\treturn ret;\n\t}\n\n\tv4l2_info(sd->v4l2_dev, \"Registered %s as /dev/%s\\n\",\n\t\t  vfd->name, video_device_node_name(vfd));\n\treturn 0;\n}\n\nstatic void fimc_lite_subdev_unregistered(struct v4l2_subdev *sd)\n{\n\tstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\n\n\tif (fimc == NULL)\n\t\treturn;\n\n\tmutex_lock(&fimc->lock);\n\n\tif (video_is_registered(&fimc->ve.vdev)) {\n\t\tvideo_unregister_device(&fimc->ve.vdev);\n\t\tmedia_entity_cleanup(&fimc->ve.vdev.entity);\n\t\tfimc->ve.pipe = NULL;\n\t}\n\n\tmutex_unlock(&fimc->lock);\n}\n\nstatic const struct v4l2_subdev_internal_ops fimc_lite_subdev_internal_ops = {\n\t.registered = fimc_lite_subdev_registered,\n\t.unregistered = fimc_lite_subdev_unregistered,\n};\n\nstatic const struct v4l2_subdev_pad_ops fimc_lite_subdev_pad_ops = {\n\t.enum_mbus_code = fimc_lite_subdev_enum_mbus_code,\n\t.get_selection = fimc_lite_subdev_get_selection,\n\t.set_selection = fimc_lite_subdev_set_selection,\n\t.get_fmt = fimc_lite_subdev_get_fmt,\n\t.set_fmt = fimc_lite_subdev_set_fmt,\n};\n\nstatic const struct v4l2_subdev_video_ops fimc_lite_subdev_video_ops = {\n\t.s_stream = fimc_lite_subdev_s_stream,\n};\n\nstatic const struct v4l2_subdev_core_ops fimc_lite_core_ops = {\n\t.log_status = fimc_lite_log_status,\n};\n\nstatic const struct v4l2_subdev_ops fimc_lite_subdev_ops = {\n\t.core = &fimc_lite_core_ops,\n\t.video = &fimc_lite_subdev_video_ops,\n\t.pad = &fimc_lite_subdev_pad_ops,\n};\n\nstatic int fimc_lite_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct fimc_lite *fimc = container_of(ctrl->handler, struct fimc_lite,\n\t\t\t\t\t      ctrl_handler);\n\tset_bit(ST_FLITE_CONFIG, &fimc->state);\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops fimc_lite_ctrl_ops = {\n\t.s_ctrl\t= fimc_lite_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config fimc_lite_ctrl = {\n\t.ops\t= &fimc_lite_ctrl_ops,\n\t.id\t= V4L2_CTRL_CLASS_USER | 0x1001,\n\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t.name\t= \"Test Pattern 640x480\",\n\t.step\t= 1,\n};\n\nstatic void fimc_lite_set_default_config(struct fimc_lite *fimc)\n{\n\tstruct flite_frame *sink = &fimc->inp_frame;\n\tstruct flite_frame *source = &fimc->out_frame;\n\n\tsink->fmt = &fimc_lite_formats[0];\n\tsink->f_width = FLITE_DEFAULT_WIDTH;\n\tsink->f_height = FLITE_DEFAULT_HEIGHT;\n\n\tsink->rect.width = FLITE_DEFAULT_WIDTH;\n\tsink->rect.height = FLITE_DEFAULT_HEIGHT;\n\tsink->rect.left = 0;\n\tsink->rect.top = 0;\n\n\t*source = *sink;\n}\n\nstatic int fimc_lite_create_capture_subdev(struct fimc_lite *fimc)\n{\n\tstruct v4l2_ctrl_handler *handler = &fimc->ctrl_handler;\n\tstruct v4l2_subdev *sd = &fimc->subdev;\n\tint ret;\n\n\tv4l2_subdev_init(sd, &fimc_lite_subdev_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsnprintf(sd->name, sizeof(sd->name), \"FIMC-LITE.%d\", fimc->index);\n\n\tfimc->subdev_pads[FLITE_SD_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tfimc->subdev_pads[FLITE_SD_PAD_SOURCE_DMA].flags = MEDIA_PAD_FL_SOURCE;\n\tfimc->subdev_pads[FLITE_SD_PAD_SOURCE_ISP].flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&sd->entity, FLITE_SD_PADS_NUM,\n\t\t\t\tfimc->subdev_pads);\n\tif (ret)\n\t\treturn ret;\n\n\tv4l2_ctrl_handler_init(handler, 1);\n\tfimc->test_pattern = v4l2_ctrl_new_custom(handler, &fimc_lite_ctrl,\n\t\t\t\t\t\t  NULL);\n\tif (handler->error) {\n\t\tmedia_entity_cleanup(&sd->entity);\n\t\treturn handler->error;\n\t}\n\n\tsd->ctrl_handler = handler;\n\tsd->internal_ops = &fimc_lite_subdev_internal_ops;\n\tsd->entity.function = MEDIA_ENT_F_PROC_VIDEO_SCALER;\n\tsd->entity.ops = &fimc_lite_subdev_media_ops;\n\tsd->owner = THIS_MODULE;\n\tv4l2_set_subdevdata(sd, fimc);\n\n\treturn 0;\n}\n\nstatic void fimc_lite_unregister_capture_subdev(struct fimc_lite *fimc)\n{\n\tstruct v4l2_subdev *sd = &fimc->subdev;\n\n\tv4l2_device_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\tv4l2_ctrl_handler_free(&fimc->ctrl_handler);\n\tv4l2_set_subdevdata(sd, NULL);\n}\n\nstatic void fimc_lite_clk_put(struct fimc_lite *fimc)\n{\n\tif (IS_ERR(fimc->clock))\n\t\treturn;\n\n\tclk_put(fimc->clock);\n\tfimc->clock = ERR_PTR(-EINVAL);\n}\n\nstatic int fimc_lite_clk_get(struct fimc_lite *fimc)\n{\n\tfimc->clock = clk_get(&fimc->pdev->dev, FLITE_CLK_NAME);\n\treturn PTR_ERR_OR_ZERO(fimc->clock);\n}\n\nstatic const struct of_device_id flite_of_match[];\n\nstatic int fimc_lite_probe(struct platform_device *pdev)\n{\n\tstruct flite_drvdata *drv_data = NULL;\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *of_id;\n\tstruct fimc_lite *fimc;\n\tint ret;\n\tint irq;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tfimc = devm_kzalloc(dev, sizeof(*fimc), GFP_KERNEL);\n\tif (!fimc)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_node(flite_of_match, dev->of_node);\n\tif (of_id)\n\t\tdrv_data = (struct flite_drvdata *)of_id->data;\n\tfimc->index = of_alias_get_id(dev->of_node, \"fimc-lite\");\n\n\tif (!drv_data || fimc->index >= drv_data->num_instances ||\n\t\t\t\t\t\tfimc->index < 0) {\n\t\tdev_err(dev, \"Wrong %pOF node alias\\n\", dev->of_node);\n\t\treturn -EINVAL;\n\t}\n\n\tfimc->dd = drv_data;\n\tfimc->pdev = pdev;\n\n\tinit_waitqueue_head(&fimc->irq_queue);\n\tspin_lock_init(&fimc->slock);\n\tmutex_init(&fimc->lock);\n\n\tfimc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(fimc->regs))\n\t\treturn PTR_ERR(fimc->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = fimc_lite_clk_get(fimc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, irq, flite_irq_handler,\n\t\t\t       0, dev_name(dev), fimc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to install irq (%d)\\n\", ret);\n\t\tgoto err_clk_put;\n\t}\n\n\t \n\tret = fimc_lite_create_capture_subdev(fimc);\n\tif (ret)\n\t\tgoto err_clk_put;\n\n\tplatform_set_drvdata(pdev, fimc);\n\tpm_runtime_enable(dev);\n\n\tif (!pm_runtime_enabled(dev)) {\n\t\tret = clk_prepare_enable(fimc->clock);\n\t\tif (ret < 0)\n\t\t\tgoto err_sd;\n\t}\n\n\tvb2_dma_contig_set_max_seg_size(dev, DMA_BIT_MASK(32));\n\n\tfimc_lite_set_default_config(fimc);\n\n\tdev_dbg(dev, \"FIMC-LITE.%d registered successfully\\n\",\n\t\tfimc->index);\n\treturn 0;\n\nerr_sd:\n\tfimc_lite_unregister_capture_subdev(fimc);\nerr_clk_put:\n\tfimc_lite_clk_put(fimc);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic int fimc_lite_runtime_resume(struct device *dev)\n{\n\tstruct fimc_lite *fimc = dev_get_drvdata(dev);\n\n\tclk_prepare_enable(fimc->clock);\n\treturn 0;\n}\n\nstatic int fimc_lite_runtime_suspend(struct device *dev)\n{\n\tstruct fimc_lite *fimc = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(fimc->clock);\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int fimc_lite_resume(struct device *dev)\n{\n\tstruct fimc_lite *fimc = dev_get_drvdata(dev);\n\tstruct flite_buffer *buf;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tif (!test_and_clear_bit(ST_LPM, &fimc->state) ||\n\t    !test_bit(ST_FLITE_IN_USE, &fimc->state)) {\n\t\tspin_unlock_irqrestore(&fimc->slock, flags);\n\t\treturn 0;\n\t}\n\tflite_hw_reset(fimc);\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\tif (!test_and_clear_bit(ST_FLITE_SUSPENDED, &fimc->state))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&fimc->active_buf_q);\n\tfimc_pipeline_call(&fimc->ve, open,\n\t\t\t   &fimc->ve.vdev.entity, false);\n\tfimc_lite_hw_init(fimc, atomic_read(&fimc->out_path) == FIMC_IO_ISP);\n\tclear_bit(ST_FLITE_SUSPENDED, &fimc->state);\n\n\tfor (i = 0; i < fimc->reqbufs_count; i++) {\n\t\tif (list_empty(&fimc->pending_buf_q))\n\t\t\tbreak;\n\t\tbuf = fimc_lite_pending_queue_pop(fimc);\n\t\tbuffer_queue(&buf->vb.vb2_buf);\n\t}\n\treturn 0;\n}\n\nstatic int fimc_lite_suspend(struct device *dev)\n{\n\tstruct fimc_lite *fimc = dev_get_drvdata(dev);\n\tbool suspend = test_bit(ST_FLITE_IN_USE, &fimc->state);\n\tint ret;\n\n\tif (test_and_set_bit(ST_LPM, &fimc->state))\n\t\treturn 0;\n\n\tret = fimc_lite_stop_capture(fimc, suspend);\n\tif (ret < 0 || !fimc_lite_active(fimc))\n\t\treturn ret;\n\n\treturn fimc_pipeline_call(&fimc->ve, close);\n}\n#endif  \n\nstatic void fimc_lite_remove(struct platform_device *pdev)\n{\n\tstruct fimc_lite *fimc = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\tif (!pm_runtime_enabled(dev))\n\t\tclk_disable_unprepare(fimc->clock);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tfimc_lite_unregister_capture_subdev(fimc);\n\tvb2_dma_contig_clear_max_seg_size(dev);\n\tfimc_lite_clk_put(fimc);\n\n\tdev_info(dev, \"Driver unloaded\\n\");\n}\n\nstatic const struct dev_pm_ops fimc_lite_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(fimc_lite_suspend, fimc_lite_resume)\n\tSET_RUNTIME_PM_OPS(fimc_lite_runtime_suspend, fimc_lite_runtime_resume,\n\t\t\t   NULL)\n};\n\n \nstatic struct flite_drvdata fimc_lite_drvdata_exynos4 = {\n\t.max_width\t\t= 8192,\n\t.max_height\t\t= 8192,\n\t.out_width_align\t= 8,\n\t.win_hor_offs_align\t= 2,\n\t.out_hor_offs_align\t= 8,\n\t.max_dma_bufs\t\t= 1,\n\t.num_instances\t\t= 2,\n};\n\n \nstatic struct flite_drvdata fimc_lite_drvdata_exynos5 = {\n\t.max_width\t\t= 8192,\n\t.max_height\t\t= 8192,\n\t.out_width_align\t= 8,\n\t.win_hor_offs_align\t= 2,\n\t.out_hor_offs_align\t= 8,\n\t.max_dma_bufs\t\t= 32,\n\t.num_instances\t\t= 3,\n};\n\nstatic const struct of_device_id flite_of_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos4212-fimc-lite\",\n\t\t.data = &fimc_lite_drvdata_exynos4,\n\t},\n\t{\n\t\t.compatible = \"samsung,exynos5250-fimc-lite\",\n\t\t.data = &fimc_lite_drvdata_exynos5,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, flite_of_match);\n\nstatic struct platform_driver fimc_lite_driver = {\n\t.probe\t\t= fimc_lite_probe,\n\t.remove_new\t= fimc_lite_remove,\n\t.driver = {\n\t\t.of_match_table = flite_of_match,\n\t\t.name\t\t= FIMC_LITE_DRV_NAME,\n\t\t.pm\t\t= &fimc_lite_pm_ops,\n\t}\n};\nmodule_platform_driver(fimc_lite_driver);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" FIMC_LITE_DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}