{
  "module_name": "fimc-lite.h",
  "hash_id": "2ac043f3b7b58321034b7229c1cd199854f42a8d488cc8409e650b4157b1e9f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-lite.h",
  "human_readable_source": " \n \n\n#ifndef FIMC_LITE_H_\n#define FIMC_LITE_H_\n\n#include <linux/sizes.h>\n#include <linux/io.h>\n#include <linux/irqreturn.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n\n#include <media/media-entity.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-mediabus.h>\n#include <media/drv-intf/exynos-fimc.h>\n\n#define FIMC_LITE_DRV_NAME\t\"exynos-fimc-lite\"\n#define FLITE_CLK_NAME\t\t\"flite\"\n#define FIMC_LITE_MAX_DEVS\t3\n#define FLITE_REQ_BUFS_MIN\t2\n#define FLITE_DEFAULT_WIDTH\t640\n#define FLITE_DEFAULT_HEIGHT\t480\n\n \nenum {\n\tST_FLITE_LPM,\n\tST_FLITE_PENDING,\n\tST_FLITE_RUN,\n\tST_FLITE_STREAM,\n\tST_FLITE_SUSPENDED,\n\tST_FLITE_OFF,\n\tST_FLITE_IN_USE,\n\tST_FLITE_CONFIG,\n\tST_SENSOR_STREAM,\n};\n\n#define FLITE_SD_PAD_SINK\t0\n#define FLITE_SD_PAD_SOURCE_DMA\t1\n#define FLITE_SD_PAD_SOURCE_ISP\t2\n#define FLITE_SD_PADS_NUM\t3\n\n \nstruct flite_drvdata {\n\tunsigned short max_width;\n\tunsigned short max_height;\n\tunsigned short out_width_align;\n\tunsigned short win_hor_offs_align;\n\tunsigned short out_hor_offs_align;\n\tunsigned short max_dma_bufs;\n\tunsigned short num_instances;\n};\n\nstruct fimc_lite_events {\n\tunsigned int data_overflow;\n};\n\n#define FLITE_MAX_PLANES\t1\n\n \nstruct flite_frame {\n\tu16 f_width;\n\tu16 f_height;\n\tstruct v4l2_rect rect;\n\tconst struct fimc_fmt *fmt;\n};\n\n \nstruct flite_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n\tdma_addr_t addr;\n\tunsigned short index;\n};\n\n \nstruct fimc_lite {\n\tstruct platform_device\t*pdev;\n\tstruct flite_drvdata\t*dd;\n\tstruct exynos_video_entity ve;\n\tstruct v4l2_device\t*v4l2_dev;\n\tstruct v4l2_fh\t\tfh;\n\tstruct v4l2_subdev\tsubdev;\n\tstruct media_pad\tvd_pad;\n\tstruct media_pad\tsubdev_pads[FLITE_SD_PADS_NUM];\n\tstruct v4l2_subdev\t*sensor;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct v4l2_ctrl\t*test_pattern;\n\tint\t\t\tindex;\n\n\tstruct mutex\t\tlock;\n\tspinlock_t\t\tslock;\n\n\tstruct clk\t\t*clock;\n\tvoid __iomem\t\t*regs;\n\twait_queue_head_t\tirq_queue;\n\n\tunsigned long\t\tpayload[FLITE_MAX_PLANES];\n\tstruct flite_frame\tinp_frame;\n\tstruct flite_frame\tout_frame;\n\tatomic_t\t\tout_path;\n\tunsigned int\t\tsource_subdev_grp_id;\n\n\tunsigned long\t\tstate;\n\tstruct list_head\tpending_buf_q;\n\tstruct list_head\tactive_buf_q;\n\tstruct vb2_queue\tvb_queue;\n\tunsigned short\t\tbuf_index;\n\tunsigned int\t\tframe_count;\n\tunsigned int\t\treqbufs_count;\n\n\tstruct fimc_lite_events\tevents;\n\tbool\t\t\tstreaming;\n};\n\nstatic inline bool fimc_lite_active(struct fimc_lite *fimc)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tret = fimc->state & (1 << ST_FLITE_RUN) ||\n\t\tfimc->state & (1 << ST_FLITE_PENDING);\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\treturn ret;\n}\n\nstatic inline void fimc_lite_active_queue_add(struct fimc_lite *dev,\n\t\t\t\t\t struct flite_buffer *buf)\n{\n\tlist_add_tail(&buf->list, &dev->active_buf_q);\n}\n\nstatic inline struct flite_buffer *fimc_lite_active_queue_pop(\n\t\t\t\t\tstruct fimc_lite *dev)\n{\n\tstruct flite_buffer *buf = list_entry(dev->active_buf_q.next,\n\t\t\t\t\t      struct flite_buffer, list);\n\tlist_del(&buf->list);\n\treturn buf;\n}\n\nstatic inline void fimc_lite_pending_queue_add(struct fimc_lite *dev,\n\t\t\t\t\tstruct flite_buffer *buf)\n{\n\tlist_add_tail(&buf->list, &dev->pending_buf_q);\n}\n\nstatic inline struct flite_buffer *fimc_lite_pending_queue_pop(\n\t\t\t\t\tstruct fimc_lite *dev)\n{\n\tstruct flite_buffer *buf = list_entry(dev->pending_buf_q.next,\n\t\t\t\t\t      struct flite_buffer, list);\n\tlist_del(&buf->list);\n\treturn buf;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}