{
  "module_name": "fimc-is-i2c.c",
  "hash_id": "c1fa95c729014d692b273e91c830626294ff81d3086c57fee0ef127cbd159eb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-is-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include \"fimc-is-i2c.h\"\n\nstruct fimc_is_i2c {\n\tstruct i2c_adapter adapter;\n\tstruct clk *clock;\n};\n\n \nstatic u32 is_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm fimc_is_i2c_algorithm = {\n\t.functionality\t= is_i2c_func,\n};\n\nstatic int fimc_is_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct fimc_is_i2c *isp_i2c;\n\tstruct i2c_adapter *i2c_adap;\n\tint ret;\n\n\tisp_i2c = devm_kzalloc(&pdev->dev, sizeof(*isp_i2c), GFP_KERNEL);\n\tif (!isp_i2c)\n\t\treturn -ENOMEM;\n\n\tisp_i2c->clock = devm_clk_get(&pdev->dev, \"i2c_isp\");\n\tif (IS_ERR(isp_i2c->clock)) {\n\t\tdev_err(&pdev->dev, \"failed to get the clock\\n\");\n\t\treturn PTR_ERR(isp_i2c->clock);\n\t}\n\n\ti2c_adap = &isp_i2c->adapter;\n\ti2c_adap->dev.of_node = node;\n\ti2c_adap->dev.parent = &pdev->dev;\n\tstrscpy(i2c_adap->name, \"exynos4x12-isp-i2c\", sizeof(i2c_adap->name));\n\ti2c_adap->owner = THIS_MODULE;\n\ti2c_adap->algo = &fimc_is_i2c_algorithm;\n\ti2c_adap->class = I2C_CLASS_SPD;\n\n\tplatform_set_drvdata(pdev, isp_i2c);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = i2c_add_adapter(i2c_adap);\n\tif (ret < 0)\n\t\tgoto err_pm_dis;\n\t \n\tpm_suspend_ignore_children(&i2c_adap->dev, false);\n\treturn 0;\n\nerr_pm_dis:\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void fimc_is_i2c_remove(struct platform_device *pdev)\n{\n\tstruct fimc_is_i2c *isp_i2c = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\ti2c_del_adapter(&isp_i2c->adapter);\n}\n\n#ifdef CONFIG_PM\nstatic int fimc_is_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct fimc_is_i2c *isp_i2c = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(isp_i2c->clock);\n\treturn 0;\n}\n\nstatic int fimc_is_i2c_runtime_resume(struct device *dev)\n{\n\tstruct fimc_is_i2c *isp_i2c = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(isp_i2c->clock);\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int fimc_is_i2c_suspend(struct device *dev)\n{\n\tif (pm_runtime_suspended(dev))\n\t\treturn 0;\n\n\treturn fimc_is_i2c_runtime_suspend(dev);\n}\n\nstatic int fimc_is_i2c_resume(struct device *dev)\n{\n\tif (pm_runtime_suspended(dev))\n\t\treturn 0;\n\n\treturn fimc_is_i2c_runtime_resume(dev);\n}\n#endif\n\nstatic const struct dev_pm_ops fimc_is_i2c_pm_ops = {\n\tSET_RUNTIME_PM_OPS(fimc_is_i2c_runtime_suspend,\n\t\t\t\t\tfimc_is_i2c_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(fimc_is_i2c_suspend, fimc_is_i2c_resume)\n};\n\nstatic const struct of_device_id fimc_is_i2c_of_match[] = {\n\t{ .compatible = FIMC_IS_I2C_COMPATIBLE },\n\t{ },\n};\n\nstatic struct platform_driver fimc_is_i2c_driver = {\n\t.probe\t\t= fimc_is_i2c_probe,\n\t.remove_new\t= fimc_is_i2c_remove,\n\t.driver = {\n\t\t.of_match_table = fimc_is_i2c_of_match,\n\t\t.name\t\t= \"fimc-isp-i2c\",\n\t\t.pm\t\t= &fimc_is_i2c_pm_ops,\n\t}\n};\n\nint fimc_is_register_i2c_driver(void)\n{\n\treturn platform_driver_register(&fimc_is_i2c_driver);\n}\n\nvoid fimc_is_unregister_i2c_driver(void)\n{\n\tplatform_driver_unregister(&fimc_is_i2c_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}