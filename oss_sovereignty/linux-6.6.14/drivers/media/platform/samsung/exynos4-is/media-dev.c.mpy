{
  "module_name": "media-dev.c",
  "hash_id": "d75e752f7786502bd091662c6f0a3b102c64a9a12c002b593c42b3c9d5b2e1df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/media-dev.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_graph.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fwnode.h>\n#include <media/media-device.h>\n#include <media/drv-intf/exynos-fimc.h>\n\n#include \"media-dev.h\"\n#include \"fimc-core.h\"\n#include \"fimc-is.h\"\n#include \"fimc-lite.h\"\n#include \"mipi-csis.h\"\n\n \nstatic void __setup_sensor_notification(struct fimc_md *fmd,\n\t\t\t\t\tstruct v4l2_subdev *sensor,\n\t\t\t\t\tstruct v4l2_subdev *fimc_sd)\n{\n\tstruct fimc_source_info *src_inf;\n\tstruct fimc_sensor_info *md_si;\n\tunsigned long flags;\n\n\tsrc_inf = v4l2_get_subdev_hostdata(sensor);\n\tif (!src_inf || WARN_ON(fmd == NULL))\n\t\treturn;\n\n\tmd_si = source_to_sensor_info(src_inf);\n\tspin_lock_irqsave(&fmd->slock, flags);\n\tmd_si->host = v4l2_get_subdevdata(fimc_sd);\n\tspin_unlock_irqrestore(&fmd->slock, flags);\n}\n\n \nstatic void fimc_pipeline_prepare(struct fimc_pipeline *p,\n\t\t\t\t\tstruct media_entity *me)\n{\n\tstruct fimc_md *fmd = entity_to_fimc_mdev(me);\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev *sensor = NULL;\n\tint i;\n\n\tfor (i = 0; i < IDX_MAX; i++)\n\t\tp->subdevs[i] = NULL;\n\n\twhile (1) {\n\t\tstruct media_pad *pad = NULL;\n\n\t\t \n\t\tfor (i = 0; i < me->num_pads; i++) {\n\t\t\tstruct media_pad *spad = &me->pads[i];\n\t\t\tif (!(spad->flags & MEDIA_PAD_FL_SINK))\n\t\t\t\tcontinue;\n\t\t\tpad = media_pad_remote_pad_first(spad);\n\t\t\tif (pad)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tbreak;\n\t\tsd = media_entity_to_v4l2_subdev(pad->entity);\n\n\t\tswitch (sd->grp_id) {\n\t\tcase GRP_ID_SENSOR:\n\t\t\tsensor = sd;\n\t\t\tfallthrough;\n\t\tcase GRP_ID_FIMC_IS_SENSOR:\n\t\t\tp->subdevs[IDX_SENSOR] = sd;\n\t\t\tbreak;\n\t\tcase GRP_ID_CSIS:\n\t\t\tp->subdevs[IDX_CSIS] = sd;\n\t\t\tbreak;\n\t\tcase GRP_ID_FLITE:\n\t\t\tp->subdevs[IDX_FLITE] = sd;\n\t\t\tbreak;\n\t\tcase GRP_ID_FIMC:\n\t\t\tp->subdevs[IDX_FIMC] = sd;\n\t\t\tbreak;\n\t\tcase GRP_ID_FIMC_IS:\n\t\t\tp->subdevs[IDX_IS_ISP] = sd;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tme = &sd->entity;\n\t\tif (me->num_pads == 1)\n\t\t\tbreak;\n\t}\n\n\tif (sensor && p->subdevs[IDX_FIMC])\n\t\t__setup_sensor_notification(fmd, sensor, p->subdevs[IDX_FIMC]);\n}\n\n \nstatic int __subdev_set_power(struct v4l2_subdev *sd, int on)\n{\n\tint *use_count;\n\tint ret;\n\n\tif (sd == NULL)\n\t\treturn -ENXIO;\n\n\tuse_count = &sd->entity.use_count;\n\tif (on && (*use_count)++ > 0)\n\t\treturn 0;\n\telse if (!on && (*use_count == 0 || --(*use_count) > 0))\n\t\treturn 0;\n\tret = v4l2_subdev_call(sd, core, s_power, on);\n\n\treturn ret != -ENOIOCTLCMD ? ret : 0;\n}\n\n \nstatic int fimc_pipeline_s_power(struct fimc_pipeline *p, bool on)\n{\n\tstatic const u8 seq[2][IDX_MAX - 1] = {\n\t\t{ IDX_IS_ISP, IDX_SENSOR, IDX_CSIS, IDX_FLITE },\n\t\t{ IDX_CSIS, IDX_FLITE, IDX_SENSOR, IDX_IS_ISP },\n\t};\n\tint i, ret = 0;\n\n\tif (p->subdevs[IDX_SENSOR] == NULL)\n\t\treturn -ENXIO;\n\n\tfor (i = 0; i < IDX_MAX - 1; i++) {\n\t\tunsigned int idx = seq[on][i];\n\n\t\tret = __subdev_set_power(p->subdevs[idx], on);\n\n\n\t\tif (ret < 0 && ret != -ENXIO)\n\t\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tfor (; i >= 0; i--) {\n\t\tunsigned int idx = seq[on][i];\n\t\t__subdev_set_power(p->subdevs[idx], !on);\n\t}\n\treturn ret;\n}\n\n \nstatic int __fimc_pipeline_enable(struct exynos_media_pipeline *ep,\n\t\t\t\t  struct fimc_md *fmd)\n{\n\tstruct fimc_pipeline *p = to_fimc_pipeline(ep);\n\tint ret;\n\n\t \n\tif (!IS_ERR(fmd->wbclk[CLK_IDX_WB_B]) && p->subdevs[IDX_IS_ISP]) {\n\t\tret = clk_prepare_enable(fmd->wbclk[CLK_IDX_WB_B]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = fimc_pipeline_s_power(p, 1);\n\tif (!ret)\n\t\treturn 0;\n\n\tif (!IS_ERR(fmd->wbclk[CLK_IDX_WB_B]) && p->subdevs[IDX_IS_ISP])\n\t\tclk_disable_unprepare(fmd->wbclk[CLK_IDX_WB_B]);\n\n\treturn ret;\n}\n\n \nstatic int __fimc_pipeline_open(struct exynos_media_pipeline *ep,\n\t\t\t\tstruct media_entity *me, bool prepare)\n{\n\tstruct fimc_md *fmd = entity_to_fimc_mdev(me);\n\tstruct fimc_pipeline *p = to_fimc_pipeline(ep);\n\tstruct v4l2_subdev *sd;\n\n\tif (WARN_ON(p == NULL || me == NULL))\n\t\treturn -EINVAL;\n\n\tif (prepare)\n\t\tfimc_pipeline_prepare(p, me);\n\n\tsd = p->subdevs[IDX_SENSOR];\n\tif (sd == NULL) {\n\t\tpr_warn(\"%s(): No sensor subdev\\n\", __func__);\n\t\t \n\t\treturn 0;\n\t}\n\n\treturn __fimc_pipeline_enable(ep, fmd);\n}\n\n \nstatic int __fimc_pipeline_close(struct exynos_media_pipeline *ep)\n{\n\tstruct fimc_pipeline *p = to_fimc_pipeline(ep);\n\tstruct v4l2_subdev *sd = p ? p->subdevs[IDX_SENSOR] : NULL;\n\tstruct fimc_md *fmd;\n\tint ret;\n\n\tif (sd == NULL) {\n\t\tpr_warn(\"%s(): No sensor subdev\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tret = fimc_pipeline_s_power(p, 0);\n\n\tfmd = entity_to_fimc_mdev(&sd->entity);\n\n\t \n\tif (!IS_ERR(fmd->wbclk[CLK_IDX_WB_B]) && p->subdevs[IDX_IS_ISP])\n\t\tclk_disable_unprepare(fmd->wbclk[CLK_IDX_WB_B]);\n\n\treturn ret == -ENXIO ? 0 : ret;\n}\n\n \nstatic int __fimc_pipeline_s_stream(struct exynos_media_pipeline *ep, bool on)\n{\n\tstatic const u8 seq[2][IDX_MAX] = {\n\t\t{ IDX_FIMC, IDX_SENSOR, IDX_IS_ISP, IDX_CSIS, IDX_FLITE },\n\t\t{ IDX_CSIS, IDX_FLITE, IDX_FIMC, IDX_SENSOR, IDX_IS_ISP },\n\t};\n\tstruct fimc_pipeline *p = to_fimc_pipeline(ep);\n\tenum fimc_subdev_index sd_id;\n\tint i, ret = 0;\n\n\tif (p->subdevs[IDX_SENSOR] == NULL) {\n\t\tstruct fimc_md *fmd;\n\t\tstruct v4l2_subdev *sd = p->subdevs[IDX_CSIS];\n\n\t\tif (!sd)\n\t\t\tsd = p->subdevs[IDX_FIMC];\n\n\t\tif (!sd) {\n\t\t\t \n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tfmd = entity_to_fimc_mdev(&sd->entity);\n\n\t\tif (!fmd->user_subdev_api) {\n\t\t\t \n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tif (p->subdevs[IDX_FIMC])\n\t\t\tsd_id = IDX_FIMC;\n\t\telse if (p->subdevs[IDX_IS_ISP])\n\t\t\tsd_id = IDX_IS_ISP;\n\t\telse if (p->subdevs[IDX_FLITE])\n\t\t\tsd_id = IDX_FLITE;\n\t\telse\n\t\t\treturn -ENODEV;\n\n\t\t \n\t\tfimc_pipeline_prepare(p, &p->subdevs[sd_id]->entity);\n\n\t\tif (p->subdevs[IDX_SENSOR] == NULL)\n\t\t\treturn -ENODEV;\n\n\t\tret = __fimc_pipeline_enable(ep, fmd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t}\n\n\tfor (i = 0; i < IDX_MAX; i++) {\n\t\tunsigned int idx = seq[on][i];\n\n\t\tret = v4l2_subdev_call(p->subdevs[idx], video, s_stream, on);\n\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tfimc_pipeline_s_power(p, !on);\n\tfor (; i >= 0; i--) {\n\t\tunsigned int idx = seq[on][i];\n\t\tv4l2_subdev_call(p->subdevs[idx], video, s_stream, !on);\n\t}\n\treturn ret;\n}\n\n \nstatic const struct exynos_media_pipeline_ops fimc_pipeline_ops = {\n\t.open\t\t= __fimc_pipeline_open,\n\t.close\t\t= __fimc_pipeline_close,\n\t.set_stream\t= __fimc_pipeline_s_stream,\n};\n\nstatic struct exynos_media_pipeline *fimc_md_pipeline_create(\n\t\t\t\t\t\tstruct fimc_md *fmd)\n{\n\tstruct fimc_pipeline *p;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tlist_add_tail(&p->list, &fmd->pipelines);\n\n\tp->ep.ops = &fimc_pipeline_ops;\n\treturn &p->ep;\n}\n\nstatic void fimc_md_pipelines_free(struct fimc_md *fmd)\n{\n\twhile (!list_empty(&fmd->pipelines)) {\n\t\tstruct fimc_pipeline *p;\n\n\t\tp = list_entry(fmd->pipelines.next, typeof(*p), list);\n\t\tlist_del(&p->list);\n\t\tkfree(p);\n\t}\n}\n\nstatic int fimc_md_parse_one_endpoint(struct fimc_md *fmd,\n\t\t\t\t   struct device_node *ep)\n{\n\tint index = fmd->num_sensors;\n\tstruct fimc_source_info *pd = &fmd->sensor[index].pdata;\n\tstruct device_node *rem, *np;\n\tstruct v4l2_async_connection *asd;\n\tstruct v4l2_fwnode_endpoint endpoint = { .bus_type = 0 };\n\tint ret;\n\n\tret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep), &endpoint);\n\tif (ret) {\n\t\tof_node_put(ep);\n\t\treturn ret;\n\t}\n\n\tif (WARN_ON(endpoint.base.port == 0) || index >= FIMC_MAX_SENSORS) {\n\t\tof_node_put(ep);\n\t\treturn -EINVAL;\n\t}\n\n\tpd->mux_id = (endpoint.base.port - 1) & 0x1;\n\n\trem = of_graph_get_remote_port_parent(ep);\n\tif (rem == NULL) {\n\t\tv4l2_info(&fmd->v4l2_dev, \"Remote device at %pOF not found\\n\",\n\t\t\t\t\t\t\tep);\n\t\tof_node_put(ep);\n\t\treturn 0;\n\t}\n\n\tif (fimc_input_is_parallel(endpoint.base.port)) {\n\t\tif (endpoint.bus_type == V4L2_MBUS_PARALLEL)\n\t\t\tpd->sensor_bus_type = FIMC_BUS_TYPE_ITU_601;\n\t\telse\n\t\t\tpd->sensor_bus_type = FIMC_BUS_TYPE_ITU_656;\n\t\tpd->flags = endpoint.bus.parallel.flags;\n\t} else if (fimc_input_is_mipi_csi(endpoint.base.port)) {\n\t\t \n\t\tpd->sensor_bus_type = FIMC_BUS_TYPE_MIPI_CSI2;\n\t} else {\n\t\tv4l2_err(&fmd->v4l2_dev, \"Wrong port id (%u) at node %pOF\\n\",\n\t\t\t endpoint.base.port, rem);\n\t}\n\t \n\tnp = of_get_parent(rem);\n\tof_node_put(rem);\n\n\tif (of_node_name_eq(np, \"i2c-isp\"))\n\t\tpd->fimc_bus_type = FIMC_BUS_TYPE_ISP_WRITEBACK;\n\telse\n\t\tpd->fimc_bus_type = pd->sensor_bus_type;\n\tof_node_put(np);\n\n\tif (WARN_ON(index >= ARRAY_SIZE(fmd->sensor))) {\n\t\tof_node_put(ep);\n\t\treturn -EINVAL;\n\t}\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&fmd->subdev_notifier,\n\t\t\t\t\t      of_fwnode_handle(ep),\n\t\t\t\t\t      struct v4l2_async_connection);\n\n\tof_node_put(ep);\n\n\tif (IS_ERR(asd))\n\t\treturn PTR_ERR(asd);\n\n\tfmd->sensor[index].asd = asd;\n\tfmd->num_sensors++;\n\n\treturn 0;\n}\n\n \nstatic int fimc_md_parse_port_node(struct fimc_md *fmd,\n\t\t\t\t   struct device_node *port)\n{\n\tstruct device_node *ep;\n\tint ret;\n\n\tfor_each_child_of_node(port, ep) {\n\t\tret = fimc_md_parse_one_endpoint(fmd, ep);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(ep);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fimc_md_register_sensor_entities(struct fimc_md *fmd)\n{\n\tstruct device_node *parent = fmd->pdev->dev.of_node;\n\tstruct device_node *ports = NULL;\n\tstruct device_node *node;\n\tint ret;\n\n\t \n\tif (!fmd->pmf)\n\t\treturn -ENXIO;\n\n\tret = pm_runtime_resume_and_get(fmd->pmf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmd->num_sensors = 0;\n\n\t \n\tfor_each_available_child_of_node(parent, node) {\n\t\tstruct device_node *port;\n\n\t\tif (!of_node_name_eq(node, \"csis\"))\n\t\t\tcontinue;\n\t\t \n\t\tport = of_get_next_child(node, NULL);\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\tret = fimc_md_parse_port_node(fmd, port);\n\t\tof_node_put(port);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(node);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\tports = of_get_child_by_name(parent, \"parallel-ports\");\n\tif (!ports)\n\t\tgoto rpm_put;\n\n\tfor_each_child_of_node(ports, node) {\n\t\tret = fimc_md_parse_port_node(fmd, node);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(node);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tof_node_put(ports);\n\nrpm_put:\n\tpm_runtime_put(fmd->pmf);\n\treturn 0;\n\ncleanup:\n\tof_node_put(ports);\n\tv4l2_async_nf_cleanup(&fmd->subdev_notifier);\n\tpm_runtime_put(fmd->pmf);\n\treturn ret;\n}\n\nstatic int __of_get_csis_id(struct device_node *np)\n{\n\tu32 reg = 0;\n\n\tnp = of_get_child_by_name(np, \"port\");\n\tif (!np)\n\t\treturn -EINVAL;\n\tof_property_read_u32(np, \"reg\", &reg);\n\tof_node_put(np);\n\treturn reg - FIMC_INPUT_MIPI_CSI2_0;\n}\n\n \nstatic int register_fimc_lite_entity(struct fimc_md *fmd,\n\t\t\t\t     struct fimc_lite *fimc_lite)\n{\n\tstruct v4l2_subdev *sd;\n\tstruct exynos_media_pipeline *ep;\n\tint ret;\n\n\tif (WARN_ON(fimc_lite->index >= FIMC_LITE_MAX_DEVS ||\n\t\t    fmd->fimc_lite[fimc_lite->index]))\n\t\treturn -EBUSY;\n\n\tsd = &fimc_lite->subdev;\n\tsd->grp_id = GRP_ID_FLITE;\n\n\tep = fimc_md_pipeline_create(fmd);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tv4l2_set_subdev_hostdata(sd, ep);\n\n\tret = v4l2_device_register_subdev(&fmd->v4l2_dev, sd);\n\tif (!ret)\n\t\tfmd->fimc_lite[fimc_lite->index] = fimc_lite;\n\telse\n\t\tv4l2_err(&fmd->v4l2_dev, \"Failed to register FIMC.LITE%d\\n\",\n\t\t\t fimc_lite->index);\n\treturn ret;\n}\n\nstatic int register_fimc_entity(struct fimc_md *fmd, struct fimc_dev *fimc)\n{\n\tstruct v4l2_subdev *sd;\n\tstruct exynos_media_pipeline *ep;\n\tint ret;\n\n\tif (WARN_ON(fimc->id >= FIMC_MAX_DEVS || fmd->fimc[fimc->id]))\n\t\treturn -EBUSY;\n\n\tsd = &fimc->vid_cap.subdev;\n\tsd->grp_id = GRP_ID_FIMC;\n\n\tep = fimc_md_pipeline_create(fmd);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tv4l2_set_subdev_hostdata(sd, ep);\n\n\tret = v4l2_device_register_subdev(&fmd->v4l2_dev, sd);\n\tif (!ret) {\n\t\tif (!fmd->pmf && fimc->pdev)\n\t\t\tfmd->pmf = &fimc->pdev->dev;\n\t\tfmd->fimc[fimc->id] = fimc;\n\t\tfimc->vid_cap.user_subdev_api = fmd->user_subdev_api;\n\t} else {\n\t\tv4l2_err(&fmd->v4l2_dev, \"Failed to register FIMC.%d (%d)\\n\",\n\t\t\t fimc->id, ret);\n\t}\n\treturn ret;\n}\n\nstatic int register_csis_entity(struct fimc_md *fmd,\n\t\t\t\tstruct platform_device *pdev,\n\t\t\t\tstruct v4l2_subdev *sd)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tint id, ret;\n\n\tid = node ? __of_get_csis_id(node) : max(0, pdev->id);\n\n\tif (WARN_ON(id < 0 || id >= CSIS_MAX_ENTITIES))\n\t\treturn -ENOENT;\n\n\tif (WARN_ON(fmd->csis[id].sd))\n\t\treturn -EBUSY;\n\n\tsd->grp_id = GRP_ID_CSIS;\n\tret = v4l2_device_register_subdev(&fmd->v4l2_dev, sd);\n\tif (!ret)\n\t\tfmd->csis[id].sd = sd;\n\telse\n\t\tv4l2_err(&fmd->v4l2_dev,\n\t\t\t \"Failed to register MIPI-CSIS.%d (%d)\\n\", id, ret);\n\treturn ret;\n}\n\nstatic int register_fimc_is_entity(struct fimc_md *fmd, struct fimc_is *is)\n{\n\tstruct v4l2_subdev *sd = &is->isp.subdev;\n\tstruct exynos_media_pipeline *ep;\n\tint ret;\n\n\t \n\tep = fimc_md_pipeline_create(fmd);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tv4l2_set_subdev_hostdata(sd, ep);\n\n\tret = v4l2_device_register_subdev(&fmd->v4l2_dev, sd);\n\tif (ret) {\n\t\tv4l2_err(&fmd->v4l2_dev,\n\t\t\t \"Failed to register FIMC-ISP (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfmd->fimc_is = is;\n\treturn 0;\n}\n\nstatic int fimc_md_register_platform_entity(struct fimc_md *fmd,\n\t\t\t\t\t    struct platform_device *pdev,\n\t\t\t\t\t    int plat_entity)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret = -EPROBE_DEFER;\n\tvoid *drvdata;\n\n\t \n\tdevice_lock(dev);\n\n\tif (!dev->driver || !try_module_get(dev->driver->owner))\n\t\tgoto dev_unlock;\n\n\tdrvdata = dev_get_drvdata(dev);\n\t \n\tif (drvdata) {\n\t\tswitch (plat_entity) {\n\t\tcase IDX_FIMC:\n\t\t\tret = register_fimc_entity(fmd, drvdata);\n\t\t\tbreak;\n\t\tcase IDX_FLITE:\n\t\t\tret = register_fimc_lite_entity(fmd, drvdata);\n\t\t\tbreak;\n\t\tcase IDX_CSIS:\n\t\t\tret = register_csis_entity(fmd, pdev, drvdata);\n\t\t\tbreak;\n\t\tcase IDX_IS_ISP:\n\t\t\tret = register_fimc_is_entity(fmd, drvdata);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -ENODEV;\n\t\t}\n\t}\n\n\tmodule_put(dev->driver->owner);\ndev_unlock:\n\tdevice_unlock(dev);\n\tif (ret == -EPROBE_DEFER)\n\t\tdev_info(&fmd->pdev->dev, \"deferring %s device registration\\n\",\n\t\t\tdev_name(dev));\n\telse if (ret < 0)\n\t\tdev_err(&fmd->pdev->dev, \"%s device registration failed (%d)\\n\",\n\t\t\tdev_name(dev), ret);\n\treturn ret;\n}\n\n \nstatic int fimc_md_register_platform_entities(struct fimc_md *fmd,\n\t\t\t\t\t      struct device_node *parent)\n{\n\tstruct device_node *node;\n\tint ret = 0;\n\n\tfor_each_available_child_of_node(parent, node) {\n\t\tstruct platform_device *pdev;\n\t\tint plat_entity = -1;\n\n\t\tpdev = of_find_device_by_node(node);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (of_node_name_eq(node, CSIS_OF_NODE_NAME))\n\t\t\tplat_entity = IDX_CSIS;\n\t\telse if (of_node_name_eq(node, FIMC_IS_OF_NODE_NAME))\n\t\t\tplat_entity = IDX_IS_ISP;\n\t\telse if (of_node_name_eq(node, FIMC_LITE_OF_NODE_NAME))\n\t\t\tplat_entity = IDX_FLITE;\n\t\telse if (of_node_name_eq(node, FIMC_OF_NODE_NAME) &&\n\t\t\t !of_property_read_bool(node, \"samsung,lcd-wb\"))\n\t\t\tplat_entity = IDX_FIMC;\n\n\t\tif (plat_entity >= 0)\n\t\t\tret = fimc_md_register_platform_entity(fmd, pdev,\n\t\t\t\t\t\t\tplat_entity);\n\t\tput_device(&pdev->dev);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void fimc_md_unregister_entities(struct fimc_md *fmd)\n{\n\tint i;\n\n\tfor (i = 0; i < FIMC_MAX_DEVS; i++) {\n\t\tstruct fimc_dev *dev = fmd->fimc[i];\n\t\tif (dev == NULL)\n\t\t\tcontinue;\n\t\tv4l2_device_unregister_subdev(&dev->vid_cap.subdev);\n\t\tdev->vid_cap.ve.pipe = NULL;\n\t\tfmd->fimc[i] = NULL;\n\t}\n\tfor (i = 0; i < FIMC_LITE_MAX_DEVS; i++) {\n\t\tstruct fimc_lite *dev = fmd->fimc_lite[i];\n\t\tif (dev == NULL)\n\t\t\tcontinue;\n\t\tv4l2_device_unregister_subdev(&dev->subdev);\n\t\tdev->ve.pipe = NULL;\n\t\tfmd->fimc_lite[i] = NULL;\n\t}\n\tfor (i = 0; i < CSIS_MAX_ENTITIES; i++) {\n\t\tif (fmd->csis[i].sd == NULL)\n\t\t\tcontinue;\n\t\tv4l2_device_unregister_subdev(fmd->csis[i].sd);\n\t\tfmd->csis[i].sd = NULL;\n\t}\n\n\tif (fmd->fimc_is)\n\t\tv4l2_device_unregister_subdev(&fmd->fimc_is->isp.subdev);\n\n\tv4l2_info(&fmd->v4l2_dev, \"Unregistered all entities\\n\");\n}\n\n \nstatic int __fimc_md_create_fimc_sink_links(struct fimc_md *fmd,\n\t\t\t\t\t    struct media_entity *source,\n\t\t\t\t\t    struct v4l2_subdev *sensor,\n\t\t\t\t\t    int pad, int link_mask)\n{\n\tstruct fimc_source_info *si = NULL;\n\tstruct media_entity *sink;\n\tunsigned int flags = 0;\n\tint i, ret = 0;\n\n\tif (sensor) {\n\t\tsi = v4l2_get_subdev_hostdata(sensor);\n\t\t \n\t\tif (si && si->fimc_bus_type == FIMC_BUS_TYPE_ISP_WRITEBACK)\n\t\t\tret = 1;\n\t}\n\n\tfor (i = 0; !ret && i < FIMC_MAX_DEVS; i++) {\n\t\tif (!fmd->fimc[i])\n\t\t\tcontinue;\n\t\t \n\t\tif (!fmd->fimc[i]->variant->has_cam_if)\n\t\t\tcontinue;\n\n\t\tflags = ((1 << i) & link_mask) ? MEDIA_LNK_FL_ENABLED : 0;\n\n\t\tsink = &fmd->fimc[i]->vid_cap.subdev.entity;\n\t\tret = media_create_pad_link(source, pad, sink,\n\t\t\t\t\t      FIMC_SD_PAD_SINK_CAM, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = media_entity_call(sink, link_setup, &sink->pads[0],\n\t\t\t\t\t&source->pads[pad], flags);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tv4l2_info(&fmd->v4l2_dev, \"created link [%s] %c> [%s]\\n\",\n\t\t\t  source->name, flags ? '=' : '-', sink->name);\n\t}\n\n\tfor (i = 0; i < FIMC_LITE_MAX_DEVS; i++) {\n\t\tif (!fmd->fimc_lite[i])\n\t\t\tcontinue;\n\n\t\tsink = &fmd->fimc_lite[i]->subdev.entity;\n\t\tret = media_create_pad_link(source, pad, sink,\n\t\t\t\t\t       FLITE_SD_PAD_SINK, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = media_entity_call(sink, link_setup, &sink->pads[0],\n\t\t\t\t\t&source->pads[pad], 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tv4l2_info(&fmd->v4l2_dev, \"created link [%s] -> [%s]\\n\",\n\t\t\t  source->name, sink->name);\n\t}\n\treturn 0;\n}\n\n \nstatic int __fimc_md_create_flite_source_links(struct fimc_md *fmd)\n{\n\tstruct media_entity *source, *sink;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < FIMC_LITE_MAX_DEVS; i++) {\n\t\tstruct fimc_lite *fimc = fmd->fimc_lite[i];\n\n\t\tif (fimc == NULL)\n\t\t\tcontinue;\n\n\t\tsource = &fimc->subdev.entity;\n\t\tsink = &fimc->ve.vdev.entity;\n\t\t \n\t\tret = media_create_pad_link(source, FLITE_SD_PAD_SOURCE_DMA,\n\t\t\t\t\t       sink, 0, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t \n\t\tsink = &fmd->fimc_is->isp.subdev.entity;\n\t\tret = media_create_pad_link(source, FLITE_SD_PAD_SOURCE_ISP,\n\t\t\t\t\t       sink, 0, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int __fimc_md_create_fimc_is_links(struct fimc_md *fmd)\n{\n\tstruct fimc_isp *isp = &fmd->fimc_is->isp;\n\tstruct media_entity *source, *sink;\n\tint i, ret;\n\n\tsource = &isp->subdev.entity;\n\n\tfor (i = 0; i < FIMC_MAX_DEVS; i++) {\n\t\tif (fmd->fimc[i] == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tsink = &fmd->fimc[i]->vid_cap.subdev.entity;\n\t\tret = media_create_pad_link(source, FIMC_ISP_SD_PAD_SRC_FIFO,\n\t\t\t\t\t       sink, FIMC_SD_PAD_SINK_FIFO, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tsink = &isp->video_capture.ve.vdev.entity;\n\n\t \n\tif (sink->num_pads == 0)\n\t\treturn 0;\n\n\treturn media_create_pad_link(source, FIMC_ISP_SD_PAD_SRC_DMA,\n\t\t\t\t\tsink, 0, 0);\n}\n\n \nstatic int fimc_md_create_links(struct fimc_md *fmd)\n{\n\tstruct v4l2_subdev *csi_sensors[CSIS_MAX_ENTITIES] = { NULL };\n\tstruct v4l2_subdev *sensor, *csis;\n\tstruct fimc_source_info *pdata;\n\tstruct media_entity *source, *sink;\n\tint i, pad, fimc_id = 0, ret = 0;\n\tu32 flags, link_mask = 0;\n\n\tfor (i = 0; i < fmd->num_sensors; i++) {\n\t\tif (fmd->sensor[i].subdev == NULL)\n\t\t\tcontinue;\n\n\t\tsensor = fmd->sensor[i].subdev;\n\t\tpdata = v4l2_get_subdev_hostdata(sensor);\n\t\tif (!pdata)\n\t\t\tcontinue;\n\n\t\tsource = NULL;\n\n\t\tswitch (pdata->sensor_bus_type) {\n\t\tcase FIMC_BUS_TYPE_MIPI_CSI2:\n\t\t\tif (WARN(pdata->mux_id >= CSIS_MAX_ENTITIES,\n\t\t\t\t\"Wrong CSI channel id: %d\\n\", pdata->mux_id))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcsis = fmd->csis[pdata->mux_id].sd;\n\t\t\tif (WARN(csis == NULL,\n\t\t\t\t \"MIPI-CSI interface specified but s5p-csis module is not loaded!\\n\"))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tpad = sensor->entity.num_pads - 1;\n\t\t\tret = media_create_pad_link(&sensor->entity, pad,\n\t\t\t\t\t      &csis->entity, CSIS_PAD_SINK,\n\t\t\t\t\t      MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t\t      MEDIA_LNK_FL_ENABLED);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tv4l2_info(&fmd->v4l2_dev, \"created link [%s] => [%s]\\n\",\n\t\t\t\t  sensor->entity.name, csis->entity.name);\n\n\t\t\tsource = NULL;\n\t\t\tcsi_sensors[pdata->mux_id] = sensor;\n\t\t\tbreak;\n\n\t\tcase FIMC_BUS_TYPE_ITU_601...FIMC_BUS_TYPE_ITU_656:\n\t\t\tsource = &sensor->entity;\n\t\t\tpad = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tv4l2_err(&fmd->v4l2_dev, \"Wrong bus_type: %x\\n\",\n\t\t\t\t pdata->sensor_bus_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (source == NULL)\n\t\t\tcontinue;\n\n\t\tlink_mask = 1 << fimc_id++;\n\t\tret = __fimc_md_create_fimc_sink_links(fmd, source, sensor,\n\t\t\t\t\t\t       pad, link_mask);\n\t}\n\n\tfor (i = 0; i < CSIS_MAX_ENTITIES; i++) {\n\t\tif (fmd->csis[i].sd == NULL)\n\t\t\tcontinue;\n\n\t\tsource = &fmd->csis[i].sd->entity;\n\t\tpad = CSIS_PAD_SOURCE;\n\t\tsensor = csi_sensors[i];\n\n\t\tlink_mask = 1 << fimc_id++;\n\t\tret = __fimc_md_create_fimc_sink_links(fmd, source, sensor,\n\t\t\t\t\t\t       pad, link_mask);\n\t}\n\n\t \n\tflags = MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED;\n\tfor (i = 0; i < FIMC_MAX_DEVS; i++) {\n\t\tif (!fmd->fimc[i])\n\t\t\tcontinue;\n\n\t\tsource = &fmd->fimc[i]->vid_cap.subdev.entity;\n\t\tsink = &fmd->fimc[i]->vid_cap.ve.vdev.entity;\n\n\t\tret = media_create_pad_link(source, FIMC_SD_PAD_SOURCE,\n\t\t\t\t\t      sink, 0, flags);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tret = __fimc_md_create_flite_source_links(fmd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (fmd->use_isp)\n\t\tret = __fimc_md_create_fimc_is_links(fmd);\n\n\treturn ret;\n}\n\n \nstatic void fimc_md_put_clocks(struct fimc_md *fmd)\n{\n\tint i = FIMC_MAX_CAMCLKS;\n\n\twhile (--i >= 0) {\n\t\tif (IS_ERR(fmd->camclk[i].clock))\n\t\t\tcontinue;\n\t\tclk_put(fmd->camclk[i].clock);\n\t\tfmd->camclk[i].clock = ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tfor (i = 0; i < FIMC_MAX_WBCLKS; i++) {\n\t\tif (IS_ERR(fmd->wbclk[i]))\n\t\t\tcontinue;\n\t\tclk_put(fmd->wbclk[i]);\n\t\tfmd->wbclk[i] = ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic int fimc_md_get_clocks(struct fimc_md *fmd)\n{\n\tstruct device *dev = &fmd->pdev->dev;\n\tchar clk_name[32];\n\tstruct clk *clock;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < FIMC_MAX_CAMCLKS; i++)\n\t\tfmd->camclk[i].clock = ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < FIMC_MAX_CAMCLKS; i++) {\n\t\tsnprintf(clk_name, sizeof(clk_name), \"sclk_cam%u\", i);\n\t\tclock = clk_get(dev, clk_name);\n\n\t\tif (IS_ERR(clock)) {\n\t\t\tdev_err(dev, \"Failed to get clock: %s\\n\", clk_name);\n\t\t\tret = PTR_ERR(clock);\n\t\t\tbreak;\n\t\t}\n\t\tfmd->camclk[i].clock = clock;\n\t}\n\tif (ret)\n\t\tfimc_md_put_clocks(fmd);\n\n\tif (!fmd->use_isp)\n\t\treturn 0;\n\t \n\tfmd->wbclk[CLK_IDX_WB_A] = ERR_PTR(-EINVAL);\n\n\tfor (i = CLK_IDX_WB_B; i < FIMC_MAX_WBCLKS; i++) {\n\t\tsnprintf(clk_name, sizeof(clk_name), \"pxl_async%u\", i);\n\t\tclock = clk_get(dev, clk_name);\n\t\tif (IS_ERR(clock)) {\n\t\t\tv4l2_err(&fmd->v4l2_dev, \"Failed to get clock: %s\\n\",\n\t\t\t\t  clk_name);\n\t\t\tret = PTR_ERR(clock);\n\t\t\tbreak;\n\t\t}\n\t\tfmd->wbclk[i] = clock;\n\t}\n\tif (ret)\n\t\tfimc_md_put_clocks(fmd);\n\n\treturn ret;\n}\n\nstatic int __fimc_md_modify_pipeline(struct media_entity *entity, bool enable)\n{\n\tstruct exynos_video_entity *ve;\n\tstruct fimc_pipeline *p;\n\tstruct video_device *vdev;\n\tint ret;\n\n\tvdev = media_entity_to_video_device(entity);\n\tif (vdev->entity.use_count == 0)\n\t\treturn 0;\n\n\tve = vdev_to_exynos_video_entity(vdev);\n\tp = to_fimc_pipeline(ve->pipe);\n\t \n\tif (!enable && p->subdevs[IDX_SENSOR] == NULL)\n\t\treturn 0;\n\n\tif (enable)\n\t\tret = __fimc_pipeline_open(ve->pipe, entity, true);\n\telse\n\t\tret = __fimc_pipeline_close(ve->pipe);\n\n\tif (ret == 0 && !enable)\n\t\tmemset(p->subdevs, 0, sizeof(p->subdevs));\n\n\treturn ret;\n}\n\n \nstatic int __fimc_md_modify_pipelines(struct media_entity *entity, bool enable,\n\t\t\t\t      struct media_graph *graph)\n{\n\tstruct media_entity *entity_err = entity;\n\tint ret;\n\n\t \n\tmedia_graph_walk_start(graph, entity);\n\n\twhile ((entity = media_graph_walk_next(graph))) {\n\t\tif (!is_media_entity_v4l2_video_device(entity))\n\t\t\tcontinue;\n\n\t\tret  = __fimc_md_modify_pipeline(entity, enable);\n\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tmedia_graph_walk_start(graph, entity_err);\n\n\twhile ((entity_err = media_graph_walk_next(graph))) {\n\t\tif (!is_media_entity_v4l2_video_device(entity_err))\n\t\t\tcontinue;\n\n\t\t__fimc_md_modify_pipeline(entity_err, !enable);\n\n\t\tif (entity_err == entity)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int fimc_md_link_notify(struct media_link *link, unsigned int flags,\n\t\t\t\tunsigned int notification)\n{\n\tstruct media_graph *graph =\n\t\t&container_of(link->graph_obj.mdev, struct fimc_md,\n\t\t\t      media_dev)->link_setup_graph;\n\tstruct media_entity *sink = link->sink->entity;\n\tint ret = 0;\n\n\t \n\tif (notification == MEDIA_DEV_NOTIFY_PRE_LINK_CH) {\n\t\tret = media_graph_walk_init(graph,\n\t\t\t\t\t\t   link->graph_obj.mdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (!(flags & MEDIA_LNK_FL_ENABLED))\n\t\t\tret = __fimc_md_modify_pipelines(sink, false, graph);\n#if 0\n\t\telse\n\t\t\t \n#endif\n\t \n\t} else if (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH) {\n\t\tif (link->flags & MEDIA_LNK_FL_ENABLED)\n\t\t\tret = __fimc_md_modify_pipelines(sink, true, graph);\n\t\tmedia_graph_walk_cleanup(graph);\n\t}\n\n\treturn ret ? -EPIPE : 0;\n}\n\nstatic const struct media_device_ops fimc_md_ops = {\n\t.link_notify = fimc_md_link_notify,\n};\n\nstatic ssize_t subdev_conf_mode_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct fimc_md *fmd = dev_get_drvdata(dev);\n\n\tif (fmd->user_subdev_api)\n\t\treturn strscpy(buf, \"Sub-device API (sub-dev)\\n\", PAGE_SIZE);\n\n\treturn strscpy(buf, \"V4L2 video node only API (vid-dev)\\n\", PAGE_SIZE);\n}\n\nstatic ssize_t subdev_conf_mode_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct fimc_md *fmd = dev_get_drvdata(dev);\n\tbool subdev_api;\n\tint i;\n\n\tif (!strcmp(buf, \"vid-dev\\n\"))\n\t\tsubdev_api = false;\n\telse if (!strcmp(buf, \"sub-dev\\n\"))\n\t\tsubdev_api = true;\n\telse\n\t\treturn count;\n\n\tfmd->user_subdev_api = subdev_api;\n\tfor (i = 0; i < FIMC_MAX_DEVS; i++)\n\t\tif (fmd->fimc[i])\n\t\t\tfmd->fimc[i]->vid_cap.user_subdev_api = subdev_api;\n\treturn count;\n}\n \nstatic DEVICE_ATTR_RW(subdev_conf_mode);\n\nstatic int cam_clk_prepare(struct clk_hw *hw)\n{\n\tstruct cam_clk *camclk = to_cam_clk(hw);\n\n\tif (camclk->fmd->pmf == NULL)\n\t\treturn -ENODEV;\n\n\treturn pm_runtime_resume_and_get(camclk->fmd->pmf);\n}\n\nstatic void cam_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct cam_clk *camclk = to_cam_clk(hw);\n\n\tif (camclk->fmd->pmf == NULL)\n\t\treturn;\n\n\tpm_runtime_put_sync(camclk->fmd->pmf);\n}\n\nstatic const struct clk_ops cam_clk_ops = {\n\t.prepare = cam_clk_prepare,\n\t.unprepare = cam_clk_unprepare,\n};\n\nstatic void fimc_md_unregister_clk_provider(struct fimc_md *fmd)\n{\n\tstruct cam_clk_provider *cp = &fmd->clk_provider;\n\tunsigned int i;\n\n\tif (cp->of_node)\n\t\tof_clk_del_provider(cp->of_node);\n\n\tfor (i = 0; i < cp->num_clocks; i++)\n\t\tclk_unregister(cp->clks[i]);\n}\n\nstatic int fimc_md_register_clk_provider(struct fimc_md *fmd)\n{\n\tstruct cam_clk_provider *cp = &fmd->clk_provider;\n\tstruct device *dev = &fmd->pdev->dev;\n\tint i, ret;\n\n\tfor (i = 0; i < FIMC_MAX_CAMCLKS; i++) {\n\t\tstruct cam_clk *camclk = &cp->camclk[i];\n\t\tstruct clk_init_data init;\n\t\tconst char *p_name;\n\n\t\tret = of_property_read_string_index(dev->of_node,\n\t\t\t\t\t\"clock-output-names\", i, &init.name);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tp_name = __clk_get_name(fmd->camclk[i].clock);\n\n\t\t \n\t\tinit.parent_names = &p_name;\n\t\tinit.num_parents = 1;\n\t\tinit.ops = &cam_clk_ops;\n\t\tinit.flags = CLK_SET_RATE_PARENT;\n\t\tcamclk->hw.init = &init;\n\t\tcamclk->fmd = fmd;\n\n\t\tcp->clks[i] = clk_register(NULL, &camclk->hw);\n\t\tif (IS_ERR(cp->clks[i])) {\n\t\t\tdev_err(dev, \"failed to register clock: %s (%ld)\\n\",\n\t\t\t\t\tinit.name, PTR_ERR(cp->clks[i]));\n\t\t\tret = PTR_ERR(cp->clks[i]);\n\t\t\tgoto err;\n\t\t}\n\t\tcp->num_clocks++;\n\t}\n\n\tif (cp->num_clocks == 0) {\n\t\tdev_warn(dev, \"clk provider not registered\\n\");\n\t\treturn 0;\n\t}\n\n\tcp->clk_data.clks = cp->clks;\n\tcp->clk_data.clk_num = cp->num_clocks;\n\tcp->of_node = dev->of_node;\n\tret = of_clk_add_provider(dev->of_node, of_clk_src_onecell_get,\n\t\t\t\t  &cp->clk_data);\n\tif (ret == 0)\n\t\treturn 0;\nerr:\n\tfimc_md_unregister_clk_provider(fmd);\n\treturn ret;\n}\n\nstatic int subdev_notifier_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t struct v4l2_subdev *subdev,\n\t\t\t\t struct v4l2_async_connection *asd)\n{\n\tstruct fimc_md *fmd = notifier_to_fimc_md(notifier);\n\tstruct fimc_sensor_info *si = NULL;\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fmd->sensor); i++)\n\t\tif (fmd->sensor[i].asd == asd)\n\t\t\tsi = &fmd->sensor[i];\n\n\tif (si == NULL)\n\t\treturn -EINVAL;\n\n\tv4l2_set_subdev_hostdata(subdev, &si->pdata);\n\n\tif (si->pdata.fimc_bus_type == FIMC_BUS_TYPE_ISP_WRITEBACK)\n\t\tsubdev->grp_id = GRP_ID_FIMC_IS_SENSOR;\n\telse\n\t\tsubdev->grp_id = GRP_ID_SENSOR;\n\n\tsi->subdev = subdev;\n\n\tv4l2_info(&fmd->v4l2_dev, \"Registered sensor subdevice: %s (%d)\\n\",\n\t\t  subdev->name, fmd->num_sensors);\n\n\tfmd->num_sensors++;\n\n\treturn 0;\n}\n\nstatic int subdev_notifier_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct fimc_md *fmd = notifier_to_fimc_md(notifier);\n\tint ret;\n\n\tmutex_lock(&fmd->media_dev.graph_mutex);\n\n\tret = fimc_md_create_links(fmd);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = v4l2_device_register_subdev_nodes(&fmd->v4l2_dev);\nunlock:\n\tmutex_unlock(&fmd->media_dev.graph_mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn media_device_register(&fmd->media_dev);\n}\n\nstatic const struct v4l2_async_notifier_operations subdev_notifier_ops = {\n\t.bound = subdev_notifier_bound,\n\t.complete = subdev_notifier_complete,\n};\n\nstatic int fimc_md_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct v4l2_device *v4l2_dev;\n\tstruct pinctrl *pinctrl;\n\tstruct fimc_md *fmd;\n\tint ret;\n\n\tfmd = devm_kzalloc(dev, sizeof(*fmd), GFP_KERNEL);\n\tif (!fmd)\n\t\treturn -ENOMEM;\n\n\tret = of_platform_populate(dev->of_node, NULL, NULL, dev);\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&fmd->slock);\n\tINIT_LIST_HEAD(&fmd->pipelines);\n\tfmd->pdev = pdev;\n\n\tstrscpy(fmd->media_dev.model, \"Samsung S5P FIMC\",\n\t\tsizeof(fmd->media_dev.model));\n\tfmd->media_dev.ops = &fimc_md_ops;\n\tfmd->media_dev.dev = dev;\n\n\tv4l2_dev = &fmd->v4l2_dev;\n\tv4l2_dev->mdev = &fmd->media_dev;\n\tv4l2_dev->notify = fimc_sensor_notify;\n\tstrscpy(v4l2_dev->name, \"s5p-fimc-md\", sizeof(v4l2_dev->name));\n\n\tfmd->use_isp = fimc_md_is_isp_available(dev->of_node);\n\tfmd->user_subdev_api = true;\n\n\tmedia_device_init(&fmd->media_dev);\n\n\tret = v4l2_device_register(dev, &fmd->v4l2_dev);\n\tif (ret < 0) {\n\t\tv4l2_err(v4l2_dev, \"Failed to register v4l2_device: %d\\n\", ret);\n\t\tgoto err_md;\n\t}\n\n\tret = fimc_md_get_clocks(fmd);\n\tif (ret)\n\t\tgoto err_v4l2dev;\n\n\tpinctrl = devm_pinctrl_get(dev);\n\tif (IS_ERR(pinctrl))\n\t\tdev_dbg(dev, \"Failed to get pinctrl: %pe\\n\", pinctrl);\n\n\tplatform_set_drvdata(pdev, fmd);\n\n\tv4l2_async_nf_init(&fmd->subdev_notifier, &fmd->v4l2_dev);\n\n\tret = fimc_md_register_platform_entities(fmd, dev->of_node);\n\tif (ret)\n\t\tgoto err_clk;\n\n\tret = fimc_md_register_sensor_entities(fmd);\n\tif (ret)\n\t\tgoto err_m_ent;\n\n\tret = device_create_file(&pdev->dev, &dev_attr_subdev_conf_mode);\n\tif (ret)\n\t\tgoto err_cleanup;\n\t \n\tret = fimc_md_register_clk_provider(fmd);\n\tif (ret < 0) {\n\t\tv4l2_err(v4l2_dev, \"clock provider registration failed\\n\");\n\t\tgoto err_attr;\n\t}\n\n\tif (fmd->num_sensors > 0) {\n\t\tfmd->subdev_notifier.ops = &subdev_notifier_ops;\n\t\tfmd->num_sensors = 0;\n\n\t\tret = v4l2_async_nf_register(&fmd->subdev_notifier);\n\t\tif (ret)\n\t\t\tgoto err_clk_p;\n\t}\n\n\treturn 0;\n\nerr_clk_p:\n\tfimc_md_unregister_clk_provider(fmd);\nerr_attr:\n\tdevice_remove_file(&pdev->dev, &dev_attr_subdev_conf_mode);\nerr_cleanup:\n\tv4l2_async_nf_cleanup(&fmd->subdev_notifier);\nerr_m_ent:\n\tfimc_md_unregister_entities(fmd);\nerr_clk:\n\tfimc_md_put_clocks(fmd);\nerr_v4l2dev:\n\tv4l2_device_unregister(&fmd->v4l2_dev);\nerr_md:\n\tmedia_device_cleanup(&fmd->media_dev);\n\treturn ret;\n}\n\nstatic void fimc_md_remove(struct platform_device *pdev)\n{\n\tstruct fimc_md *fmd = platform_get_drvdata(pdev);\n\n\tif (!fmd)\n\t\treturn;\n\n\tfimc_md_unregister_clk_provider(fmd);\n\tv4l2_async_nf_unregister(&fmd->subdev_notifier);\n\tv4l2_async_nf_cleanup(&fmd->subdev_notifier);\n\n\tv4l2_device_unregister(&fmd->v4l2_dev);\n\tdevice_remove_file(&pdev->dev, &dev_attr_subdev_conf_mode);\n\tfimc_md_unregister_entities(fmd);\n\tfimc_md_pipelines_free(fmd);\n\tmedia_device_unregister(&fmd->media_dev);\n\tmedia_device_cleanup(&fmd->media_dev);\n\tfimc_md_put_clocks(fmd);\n}\n\nstatic const struct platform_device_id fimc_driver_ids[] __always_unused = {\n\t{ .name = \"s5p-fimc-md\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, fimc_driver_ids);\n\nstatic const struct of_device_id fimc_md_of_match[] = {\n\t{ .compatible = \"samsung,fimc\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, fimc_md_of_match);\n\nstatic struct platform_driver fimc_md_driver = {\n\t.probe\t\t= fimc_md_probe,\n\t.remove_new\t= fimc_md_remove,\n\t.driver = {\n\t\t.of_match_table = of_match_ptr(fimc_md_of_match),\n\t\t.name\t\t= \"s5p-fimc-md\",\n\t}\n};\n\nstatic int __init fimc_md_init(void)\n{\n\tint ret;\n\n\trequest_module(\"s5p-csis\");\n\tret = fimc_register_driver();\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&fimc_md_driver);\n\tif (ret)\n\t\tfimc_unregister_driver();\n\n\treturn ret;\n}\n\nstatic void __exit fimc_md_exit(void)\n{\n\tplatform_driver_unregister(&fimc_md_driver);\n\tfimc_unregister_driver();\n}\n\nmodule_init(fimc_md_init);\nmodule_exit(fimc_md_exit);\n\nMODULE_AUTHOR(\"Sylwester Nawrocki <s.nawrocki@samsung.com>\");\nMODULE_DESCRIPTION(\"S5P FIMC camera host interface/video postprocessor driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"2.0.1\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}