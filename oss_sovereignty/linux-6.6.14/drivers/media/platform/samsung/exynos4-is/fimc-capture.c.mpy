{
  "module_name": "fimc-capture.c",
  "hash_id": "310aedb0070fd8c79d7434cc3563fb99da385a41681f6d83950d283d746ad5c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-capture.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/bug.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-rect.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"common.h\"\n#include \"fimc-core.h\"\n#include \"fimc-reg.h\"\n#include \"media-dev.h\"\n\nstatic int fimc_capture_hw_init(struct fimc_dev *fimc)\n{\n\tstruct fimc_source_info *si = &fimc->vid_cap.source_config;\n\tstruct fimc_ctx *ctx = fimc->vid_cap.ctx;\n\tint ret;\n\tunsigned long flags;\n\n\tif (ctx == NULL || ctx->s_frame.fmt == NULL)\n\t\treturn -EINVAL;\n\n\tif (si->fimc_bus_type == FIMC_BUS_TYPE_ISP_WRITEBACK) {\n\t\tret = fimc_hw_camblk_cfg_writeback(fimc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tfimc_prepare_dma_offset(ctx, &ctx->d_frame);\n\tfimc_set_yuv_order(ctx);\n\n\tfimc_hw_set_camera_polarity(fimc, si);\n\tfimc_hw_set_camera_type(fimc, si);\n\tfimc_hw_set_camera_source(fimc, si);\n\tfimc_hw_set_camera_offset(fimc, &ctx->s_frame);\n\n\tret = fimc_set_scaler_info(ctx);\n\tif (!ret) {\n\t\tfimc_hw_set_input_path(ctx);\n\t\tfimc_hw_set_prescaler(ctx);\n\t\tfimc_hw_set_mainscaler(ctx);\n\t\tfimc_hw_set_target_format(ctx);\n\t\tfimc_hw_set_rotation(ctx);\n\t\tfimc_hw_set_effect(ctx);\n\t\tfimc_hw_set_output_path(ctx);\n\t\tfimc_hw_set_out_dma(ctx);\n\t\tif (fimc->drv_data->alpha_color)\n\t\t\tfimc_hw_set_rgb_alpha(ctx);\n\t\tclear_bit(ST_CAPT_APPLY_CFG, &fimc->state);\n\t}\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\treturn ret;\n}\n\n \nstatic int fimc_capture_state_cleanup(struct fimc_dev *fimc, bool suspend)\n{\n\tstruct fimc_vid_cap *cap = &fimc->vid_cap;\n\tstruct fimc_vid_buffer *buf;\n\tunsigned long flags;\n\tbool streaming;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tstreaming = fimc->state & (1 << ST_CAPT_ISP_STREAM);\n\n\tfimc->state &= ~(1 << ST_CAPT_RUN | 1 << ST_CAPT_SHUT |\n\t\t\t 1 << ST_CAPT_STREAM | 1 << ST_CAPT_ISP_STREAM);\n\tif (suspend)\n\t\tfimc->state |= (1 << ST_CAPT_SUSPENDED);\n\telse\n\t\tfimc->state &= ~(1 << ST_CAPT_PEND | 1 << ST_CAPT_SUSPENDED);\n\n\t \n\twhile (!suspend && !list_empty(&cap->pending_buf_q)) {\n\t\tbuf = fimc_pending_queue_pop(cap);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\t \n\twhile (!list_empty(&cap->active_buf_q)) {\n\t\tbuf = fimc_active_queue_pop(cap);\n\t\tif (suspend)\n\t\t\tfimc_pending_queue_add(cap, buf);\n\t\telse\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\n\tfimc_hw_reset(fimc);\n\tcap->buf_index = 0;\n\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\tif (streaming)\n\t\treturn fimc_pipeline_call(&cap->ve, set_stream, 0);\n\telse\n\t\treturn 0;\n}\n\nstatic int fimc_stop_capture(struct fimc_dev *fimc, bool suspend)\n{\n\tunsigned long flags;\n\n\tif (!fimc_capture_active(fimc))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tset_bit(ST_CAPT_SHUT, &fimc->state);\n\tfimc_deactivate_capture(fimc);\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\twait_event_timeout(fimc->irq_queue,\n\t\t\t   !test_bit(ST_CAPT_SHUT, &fimc->state),\n\t\t\t   (2*HZ/10));  \n\n\treturn fimc_capture_state_cleanup(fimc, suspend);\n}\n\n \nstatic int fimc_capture_config_update(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\tint ret;\n\n\tfimc_hw_set_camera_offset(fimc, &ctx->s_frame);\n\n\tret = fimc_set_scaler_info(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tfimc_hw_set_prescaler(ctx);\n\tfimc_hw_set_mainscaler(ctx);\n\tfimc_hw_set_target_format(ctx);\n\tfimc_hw_set_rotation(ctx);\n\tfimc_hw_set_effect(ctx);\n\tfimc_prepare_dma_offset(ctx, &ctx->d_frame);\n\tfimc_hw_set_out_dma(ctx);\n\tif (fimc->drv_data->alpha_color)\n\t\tfimc_hw_set_rgb_alpha(ctx);\n\n\tclear_bit(ST_CAPT_APPLY_CFG, &fimc->state);\n\treturn ret;\n}\n\nvoid fimc_capture_irq_handler(struct fimc_dev *fimc, int deq_buf)\n{\n\tstruct fimc_vid_cap *cap = &fimc->vid_cap;\n\tstruct fimc_pipeline *p = to_fimc_pipeline(cap->ve.pipe);\n\tstruct v4l2_subdev *csis = p->subdevs[IDX_CSIS];\n\tstruct fimc_frame *f = &cap->ctx->d_frame;\n\tstruct fimc_vid_buffer *v_buf;\n\n\tif (test_and_clear_bit(ST_CAPT_SHUT, &fimc->state)) {\n\t\twake_up(&fimc->irq_queue);\n\t\tgoto done;\n\t}\n\n\tif (!list_empty(&cap->active_buf_q) &&\n\t    test_bit(ST_CAPT_RUN, &fimc->state) && deq_buf) {\n\t\tv_buf = fimc_active_queue_pop(cap);\n\n\t\tv_buf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tv_buf->vb.sequence = cap->frame_count++;\n\n\t\tvb2_buffer_done(&v_buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t}\n\n\tif (!list_empty(&cap->pending_buf_q)) {\n\n\t\tv_buf = fimc_pending_queue_pop(cap);\n\t\tfimc_hw_set_output_addr(fimc, &v_buf->addr, cap->buf_index);\n\t\tv_buf->index = cap->buf_index;\n\n\t\t \n\t\tfimc_active_queue_add(cap, v_buf);\n\n\t\tdbg(\"next frame: %d, done frame: %d\",\n\t\t    fimc_hw_get_frame_index(fimc), v_buf->index);\n\n\t\tif (++cap->buf_index >= FIMC_MAX_OUT_BUFS)\n\t\t\tcap->buf_index = 0;\n\t}\n\t \n\tif (f->fmt->mdataplanes && !list_empty(&cap->active_buf_q)) {\n\t\tunsigned int plane = ffs(f->fmt->mdataplanes) - 1;\n\t\tunsigned int size = f->payload[plane];\n\t\ts32 index = fimc_hw_get_frame_index(fimc);\n\t\tvoid *vaddr;\n\n\t\tlist_for_each_entry(v_buf, &cap->active_buf_q, list) {\n\t\t\tif (v_buf->index != index)\n\t\t\t\tcontinue;\n\t\t\tvaddr = vb2_plane_vaddr(&v_buf->vb.vb2_buf, plane);\n\t\t\tv4l2_subdev_call(csis, video, s_rx_buffer,\n\t\t\t\t\t vaddr, &size);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cap->active_buf_cnt == 0) {\n\t\tif (deq_buf)\n\t\t\tclear_bit(ST_CAPT_RUN, &fimc->state);\n\n\t\tif (++cap->buf_index >= FIMC_MAX_OUT_BUFS)\n\t\t\tcap->buf_index = 0;\n\t} else {\n\t\tset_bit(ST_CAPT_RUN, &fimc->state);\n\t}\n\n\tif (test_bit(ST_CAPT_APPLY_CFG, &fimc->state))\n\t\tfimc_capture_config_update(cap->ctx);\ndone:\n\tif (cap->active_buf_cnt == 1) {\n\t\tfimc_deactivate_capture(fimc);\n\t\tclear_bit(ST_CAPT_STREAM, &fimc->state);\n\t}\n\n\tdbg(\"frame: %d, active_buf_cnt: %d\",\n\t    fimc_hw_get_frame_index(fimc), cap->active_buf_cnt);\n}\n\n\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct fimc_ctx *ctx = q->drv_priv;\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\tstruct fimc_vid_cap *vid_cap = &fimc->vid_cap;\n\tint min_bufs;\n\tint ret;\n\n\tvid_cap->frame_count = 0;\n\n\tret = fimc_capture_hw_init(fimc);\n\tif (ret) {\n\t\tfimc_capture_state_cleanup(fimc, false);\n\t\treturn ret;\n\t}\n\n\tset_bit(ST_CAPT_PEND, &fimc->state);\n\n\tmin_bufs = fimc->vid_cap.reqbufs_count > 1 ? 2 : 1;\n\n\tif (vid_cap->active_buf_cnt >= min_bufs &&\n\t    !test_and_set_bit(ST_CAPT_STREAM, &fimc->state)) {\n\t\tfimc_activate_capture(ctx);\n\n\t\tif (!test_and_set_bit(ST_CAPT_ISP_STREAM, &fimc->state))\n\t\t\treturn fimc_pipeline_call(&vid_cap->ve, set_stream, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic void stop_streaming(struct vb2_queue *q)\n{\n\tstruct fimc_ctx *ctx = q->drv_priv;\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\n\tif (!fimc_capture_active(fimc))\n\t\treturn;\n\n\tfimc_stop_capture(fimc, false);\n}\n\nint fimc_capture_suspend(struct fimc_dev *fimc)\n{\n\tbool suspend = fimc_capture_busy(fimc);\n\n\tint ret = fimc_stop_capture(fimc, suspend);\n\tif (ret)\n\t\treturn ret;\n\treturn fimc_pipeline_call(&fimc->vid_cap.ve, close);\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb);\n\nint fimc_capture_resume(struct fimc_dev *fimc)\n{\n\tstruct fimc_vid_cap *vid_cap = &fimc->vid_cap;\n\tstruct exynos_video_entity *ve = &vid_cap->ve;\n\tstruct fimc_vid_buffer *buf;\n\tint i;\n\n\tif (!test_and_clear_bit(ST_CAPT_SUSPENDED, &fimc->state))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&fimc->vid_cap.active_buf_q);\n\tvid_cap->buf_index = 0;\n\tfimc_pipeline_call(ve, open, &ve->vdev.entity, false);\n\tfimc_capture_hw_init(fimc);\n\n\tclear_bit(ST_CAPT_SUSPENDED, &fimc->state);\n\n\tfor (i = 0; i < vid_cap->reqbufs_count; i++) {\n\t\tif (list_empty(&vid_cap->pending_buf_q))\n\t\t\tbreak;\n\t\tbuf = fimc_pending_queue_pop(vid_cap);\n\t\tbuffer_queue(&buf->vb.vb2_buf);\n\t}\n\treturn 0;\n\n}\n\nstatic int queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *num_buffers, unsigned int *num_planes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct fimc_ctx *ctx = vq->drv_priv;\n\tstruct fimc_frame *frame = &ctx->d_frame;\n\tstruct fimc_fmt *fmt = frame->fmt;\n\tunsigned long wh = frame->f_width * frame->f_height;\n\tint i;\n\n\tif (fmt == NULL)\n\t\treturn -EINVAL;\n\n\tif (*num_planes) {\n\t\tif (*num_planes != fmt->memplanes)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < *num_planes; i++)\n\t\t\tif (sizes[i] < (wh * fmt->depth[i]) / 8)\n\t\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t*num_planes = fmt->memplanes;\n\n\tfor (i = 0; i < fmt->memplanes; i++) {\n\t\tunsigned int size = (wh * fmt->depth[i]) / 8;\n\n\t\tif (fimc_fmt_is_user_defined(fmt->color))\n\t\t\tsizes[i] = frame->payload[i];\n\t\telse\n\t\t\tsizes[i] = max_t(u32, size, frame->payload[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct fimc_ctx *ctx = vq->drv_priv;\n\tint i;\n\n\tif (ctx->d_frame.fmt == NULL)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ctx->d_frame.fmt->memplanes; i++) {\n\t\tunsigned long size = ctx->d_frame.payload[i];\n\n\t\tif (vb2_plane_size(vb, i) < size) {\n\t\t\tv4l2_err(&ctx->fimc_dev->vid_cap.ve.vdev,\n\t\t\t\t \"User buffer too small (%ld < %ld)\\n\",\n\t\t\t\t vb2_plane_size(vb, i), size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvb2_set_plane_payload(vb, i, size);\n\t}\n\n\treturn 0;\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct fimc_vid_buffer *buf\n\t\t= container_of(vbuf, struct fimc_vid_buffer, vb);\n\tstruct fimc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\tstruct fimc_vid_cap *vid_cap = &fimc->vid_cap;\n\tstruct exynos_video_entity *ve = &vid_cap->ve;\n\tunsigned long flags;\n\tint min_bufs;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tfimc_prepare_addr(ctx, &buf->vb.vb2_buf, &ctx->d_frame, &buf->addr);\n\n\tif (!test_bit(ST_CAPT_SUSPENDED, &fimc->state) &&\n\t    !test_bit(ST_CAPT_STREAM, &fimc->state) &&\n\t    vid_cap->active_buf_cnt < FIMC_MAX_OUT_BUFS) {\n\t\t \n\t\tint buf_id = (vid_cap->reqbufs_count == 1) ? -1 :\n\t\t\t\tvid_cap->buf_index;\n\n\t\tfimc_hw_set_output_addr(fimc, &buf->addr, buf_id);\n\t\tbuf->index = vid_cap->buf_index;\n\t\tfimc_active_queue_add(vid_cap, buf);\n\n\t\tif (++vid_cap->buf_index >= FIMC_MAX_OUT_BUFS)\n\t\t\tvid_cap->buf_index = 0;\n\t} else {\n\t\tfimc_pending_queue_add(vid_cap, buf);\n\t}\n\n\tmin_bufs = vid_cap->reqbufs_count > 1 ? 2 : 1;\n\n\n\tif (vb2_is_streaming(&vid_cap->vbq) &&\n\t    vid_cap->active_buf_cnt >= min_bufs &&\n\t    !test_and_set_bit(ST_CAPT_STREAM, &fimc->state)) {\n\t\tint ret;\n\n\t\tfimc_activate_capture(ctx);\n\t\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\t\tif (test_and_set_bit(ST_CAPT_ISP_STREAM, &fimc->state))\n\t\t\treturn;\n\n\t\tret = fimc_pipeline_call(ve, set_stream, 1);\n\t\tif (ret < 0)\n\t\t\tv4l2_err(&ve->vdev, \"stream on failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n}\n\nstatic const struct vb2_ops fimc_capture_qops = {\n\t.queue_setup\t\t= queue_setup,\n\t.buf_prepare\t\t= buffer_prepare,\n\t.buf_queue\t\t= buffer_queue,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.start_streaming\t= start_streaming,\n\t.stop_streaming\t\t= stop_streaming,\n};\n\nstatic int fimc_capture_set_default_format(struct fimc_dev *fimc);\n\nstatic int fimc_capture_open(struct file *file)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\tstruct fimc_vid_cap *vc = &fimc->vid_cap;\n\tstruct exynos_video_entity *ve = &vc->ve;\n\tint ret = -EBUSY;\n\n\tdbg(\"pid: %d, state: 0x%lx\", task_pid_nr(current), fimc->state);\n\n\tmutex_lock(&fimc->lock);\n\n\tif (fimc_m2m_active(fimc))\n\t\tgoto unlock;\n\n\tset_bit(ST_CAPT_BUSY, &fimc->state);\n\tret = pm_runtime_resume_and_get(&fimc->pdev->dev);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tret = v4l2_fh_open(file);\n\tif (ret) {\n\t\tpm_runtime_put_sync(&fimc->pdev->dev);\n\t\tgoto unlock;\n\t}\n\n\tif (v4l2_fh_is_singular_file(file)) {\n\t\tfimc_md_graph_lock(ve);\n\n\t\tret = fimc_pipeline_call(ve, open, &ve->vdev.entity, true);\n\n\t\tif (ret == 0)\n\t\t\tve->vdev.entity.use_count++;\n\n\t\tfimc_md_graph_unlock(ve);\n\n\t\tif (ret == 0)\n\t\t\tret = fimc_capture_set_default_format(fimc);\n\n\t\tif (ret < 0) {\n\t\t\tclear_bit(ST_CAPT_BUSY, &fimc->state);\n\t\t\tpm_runtime_put_sync(&fimc->pdev->dev);\n\t\t\tv4l2_fh_release(file);\n\t\t}\n\t}\nunlock:\n\tmutex_unlock(&fimc->lock);\n\treturn ret;\n}\n\nstatic int fimc_capture_release(struct file *file)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\tstruct fimc_vid_cap *vc = &fimc->vid_cap;\n\tbool close = v4l2_fh_is_singular_file(file);\n\tint ret;\n\n\tdbg(\"pid: %d, state: 0x%lx\", task_pid_nr(current), fimc->state);\n\n\tmutex_lock(&fimc->lock);\n\n\tif (close && vc->streaming) {\n\t\tvideo_device_pipeline_stop(&vc->ve.vdev);\n\t\tvc->streaming = false;\n\t}\n\n\tret = _vb2_fop_release(file, NULL);\n\n\tif (close) {\n\t\tclear_bit(ST_CAPT_BUSY, &fimc->state);\n\t\tfimc_pipeline_call(&vc->ve, close);\n\t\tclear_bit(ST_CAPT_SUSPENDED, &fimc->state);\n\n\t\tfimc_md_graph_lock(&vc->ve);\n\t\tvc->ve.vdev.entity.use_count--;\n\t\tfimc_md_graph_unlock(&vc->ve);\n\t}\n\n\tpm_runtime_put_sync(&fimc->pdev->dev);\n\tmutex_unlock(&fimc->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_file_operations fimc_capture_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= fimc_capture_open,\n\t.release\t= fimc_capture_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= vb2_fop_mmap,\n};\n\n \n\nstatic struct fimc_fmt *fimc_capture_try_format(struct fimc_ctx *ctx,\n\t\t\t\t\t\tu32 *width, u32 *height,\n\t\t\t\t\t\tu32 *code, u32 *fourcc, int pad)\n{\n\tbool rotation = ctx->rotation == 90 || ctx->rotation == 270;\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\tconst struct fimc_variant *var = fimc->variant;\n\tconst struct fimc_pix_limit *pl = var->pix_limit;\n\tstruct fimc_frame *dst = &ctx->d_frame;\n\tu32 depth, min_w, max_w, min_h, align_h = 3;\n\tu32 mask = FMT_FLAGS_CAM;\n\tstruct fimc_fmt *ffmt;\n\n\t \n\tif (code && ctx->s_frame.fmt && pad == FIMC_SD_PAD_SOURCE &&\n\t    fimc_fmt_is_user_defined(ctx->s_frame.fmt->color))\n\t\t*code = ctx->s_frame.fmt->mbus_code;\n\n\tif (fourcc && *fourcc != V4L2_PIX_FMT_JPEG && pad == FIMC_SD_PAD_SOURCE)\n\t\tmask |= FMT_FLAGS_M2M;\n\n\tif (pad == FIMC_SD_PAD_SINK_FIFO)\n\t\tmask = FMT_FLAGS_WRITEBACK;\n\n\tffmt = fimc_find_format(fourcc, code, mask, 0);\n\tif (WARN_ON(!ffmt))\n\t\treturn NULL;\n\n\tif (code)\n\t\t*code = ffmt->mbus_code;\n\tif (fourcc)\n\t\t*fourcc = ffmt->fourcc;\n\n\tif (pad != FIMC_SD_PAD_SOURCE) {\n\t\tmax_w = fimc_fmt_is_user_defined(ffmt->color) ?\n\t\t\tpl->scaler_dis_w : pl->scaler_en_w;\n\t\t \n\t\tv4l_bound_align_image(width, max_t(u32, *width, 32), max_w, 4,\n\t\t\t\t      height, max_t(u32, *height, 32),\n\t\t\t\t      FIMC_CAMIF_MAX_HEIGHT,\n\t\t\t\t      fimc_fmt_is_user_defined(ffmt->color) ?\n\t\t\t\t      3 : 1,\n\t\t\t\t      0);\n\t\treturn ffmt;\n\t}\n\t \n\tif (fimc_fmt_is_user_defined(ffmt->color)) {\n\t\t*width  = ctx->s_frame.f_width;\n\t\t*height = ctx->s_frame.f_height;\n\t\treturn ffmt;\n\t}\n\t \n\tmax_w = rotation ? pl->out_rot_en_w : pl->out_rot_dis_w;\n\tif (ctx->state & FIMC_COMPOSE) {\n\t\tmin_w = dst->offs_h + dst->width;\n\t\tmin_h = dst->offs_v + dst->height;\n\t} else {\n\t\tmin_w = var->min_out_pixsize;\n\t\tmin_h = var->min_out_pixsize;\n\t}\n\tif (var->min_vsize_align == 1 && !rotation)\n\t\talign_h = fimc_fmt_is_rgb(ffmt->color) ? 0 : 1;\n\n\tdepth = fimc_get_format_depth(ffmt);\n\tv4l_bound_align_image(width, min_w, max_w,\n\t\t\t      ffs(var->min_out_pixsize) - 1,\n\t\t\t      height, min_h, FIMC_CAMIF_MAX_HEIGHT,\n\t\t\t      align_h,\n\t\t\t      64/(ALIGN(depth, 8)));\n\n\tdbg(\"pad%d: code: 0x%x, %dx%d. dst fmt: %dx%d\",\n\t    pad, code ? *code : 0, *width, *height,\n\t    dst->f_width, dst->f_height);\n\n\treturn ffmt;\n}\n\nstatic void fimc_capture_try_selection(struct fimc_ctx *ctx,\n\t\t\t\t       struct v4l2_rect *r,\n\t\t\t\t       int target)\n{\n\tbool rotate = ctx->rotation == 90 || ctx->rotation == 270;\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\tconst struct fimc_variant *var = fimc->variant;\n\tconst struct fimc_pix_limit *pl = var->pix_limit;\n\tstruct fimc_frame *sink = &ctx->s_frame;\n\tu32 max_w, max_h, min_w = 0, min_h = 0, min_sz;\n\tu32 align_sz = 0, align_h = 4;\n\tu32 max_sc_h, max_sc_v;\n\n\t \n\tif (fimc_fmt_is_user_defined(ctx->d_frame.fmt->color)) {\n\t\tr->width  = sink->f_width;\n\t\tr->height = sink->f_height;\n\t\tr->left   = r->top = 0;\n\t\treturn;\n\t}\n\tif (target == V4L2_SEL_TGT_COMPOSE) {\n\t\tu32 tmp_min_h = ffs(sink->width) - 3;\n\t\tu32 tmp_min_v = ffs(sink->height) - 1;\n\n\t\tif (ctx->rotation != 90 && ctx->rotation != 270)\n\t\t\talign_h = 1;\n\t\tmax_sc_h = min(SCALER_MAX_HRATIO, 1 << tmp_min_h);\n\t\tmax_sc_v = min(SCALER_MAX_VRATIO, 1 << tmp_min_v);\n\t\tmin_sz = var->min_out_pixsize;\n\t} else {\n\t\tu32 depth = fimc_get_format_depth(sink->fmt);\n\t\talign_sz = 64/ALIGN(depth, 8);\n\t\tmin_sz = var->min_inp_pixsize;\n\t\tmin_w = min_h = min_sz;\n\t\tmax_sc_h = max_sc_v = 1;\n\t}\n\t \n\tmax_w = min_t(u32,\n\t\t      rotate ? pl->out_rot_en_w : pl->out_rot_dis_w,\n\t\t      rotate ? sink->f_height : sink->f_width);\n\tmax_h = min_t(u32, FIMC_CAMIF_MAX_HEIGHT, sink->f_height);\n\n\tif (target == V4L2_SEL_TGT_COMPOSE) {\n\t\tmin_w = min_t(u32, max_w, sink->f_width / max_sc_h);\n\t\tmin_h = min_t(u32, max_h, sink->f_height / max_sc_v);\n\t\tif (rotate) {\n\t\t\tswap(max_sc_h, max_sc_v);\n\t\t\tswap(min_w, min_h);\n\t\t}\n\t}\n\tv4l_bound_align_image(&r->width, min_w, max_w, ffs(min_sz) - 1,\n\t\t\t      &r->height, min_h, max_h, align_h,\n\t\t\t      align_sz);\n\t \n\tr->left = clamp_t(u32, r->left, 0, sink->f_width - r->width);\n\tr->top  = clamp_t(u32, r->top, 0, sink->f_height - r->height);\n\tr->left = round_down(r->left, var->hor_offs_align);\n\n\tdbg(\"target %#x: (%d,%d)/%dx%d, sink fmt: %dx%d\",\n\t    target, r->left, r->top, r->width, r->height,\n\t    sink->f_width, sink->f_height);\n}\n\n \nstatic int fimc_cap_querycap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\n\t__fimc_vidioc_querycap(&fimc->pdev->dev, cap);\n\treturn 0;\n}\n\nstatic int fimc_cap_enum_fmt(struct file *file, void *priv,\n\t\t\t     struct v4l2_fmtdesc *f)\n{\n\tstruct fimc_fmt *fmt;\n\n\tfmt = fimc_find_format(NULL, NULL, FMT_FLAGS_CAM | FMT_FLAGS_M2M,\n\t\t\t       f->index);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\tf->pixelformat = fmt->fourcc;\n\treturn 0;\n}\n\nstatic struct media_entity *fimc_pipeline_get_head(struct media_entity *me)\n{\n\tstruct media_pad *pad = &me->pads[0];\n\n\twhile (!(pad->flags & MEDIA_PAD_FL_SOURCE)) {\n\t\tpad = media_pad_remote_pad_first(pad);\n\t\tif (!pad)\n\t\t\tbreak;\n\t\tme = pad->entity;\n\t\tpad = &me->pads[0];\n\t}\n\n\treturn me;\n}\n\n \nstatic int fimc_pipeline_try_format(struct fimc_ctx *ctx,\n\t\t\t\t    struct v4l2_mbus_framefmt *tfmt,\n\t\t\t\t    struct fimc_fmt **fmt_id,\n\t\t\t\t    bool set)\n{\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\tstruct fimc_pipeline *p = to_fimc_pipeline(fimc->vid_cap.ve.pipe);\n\tstruct v4l2_subdev *sd = p->subdevs[IDX_SENSOR];\n\tstruct v4l2_subdev_format sfmt = {\n\t\t.which = set ? V4L2_SUBDEV_FORMAT_ACTIVE\n\t\t       : V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tstruct v4l2_mbus_framefmt *mf = &sfmt.format;\n\tstruct media_entity *me;\n\tstruct fimc_fmt *ffmt;\n\tstruct media_pad *pad;\n\tint ret, i = 1;\n\tu32 fcc;\n\n\tif (WARN_ON(!sd || !tfmt))\n\t\treturn -EINVAL;\n\n\tsfmt.format = *tfmt;\n\n\tme = fimc_pipeline_get_head(&sd->entity);\n\n\twhile (1) {\n\t\tffmt = fimc_find_format(NULL, mf->code != 0 ? &mf->code : NULL,\n\t\t\t\t\tFMT_FLAGS_CAM, i++);\n\t\tif (ffmt == NULL) {\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmf->code = tfmt->code = ffmt->mbus_code;\n\n\t\t \n\t\twhile (me != &fimc->vid_cap.subdev.entity) {\n\t\t\tsd = media_entity_to_v4l2_subdev(me);\n\n\t\t\tsfmt.pad = 0;\n\t\t\tret = v4l2_subdev_call(sd, pad, set_fmt, NULL, &sfmt);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (me->pads[0].flags & MEDIA_PAD_FL_SINK) {\n\t\t\t\tsfmt.pad = me->num_pads - 1;\n\t\t\t\tmf->code = tfmt->code;\n\t\t\t\tret = v4l2_subdev_call(sd, pad, set_fmt, NULL,\n\t\t\t\t\t\t\t\t\t&sfmt);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpad = media_pad_remote_pad_first(&me->pads[sfmt.pad]);\n\t\t\tif (!pad)\n\t\t\t\treturn -EINVAL;\n\t\t\tme = pad->entity;\n\t\t}\n\n\t\tif (mf->code != tfmt->code)\n\t\t\tcontinue;\n\n\t\tfcc = ffmt->fourcc;\n\t\ttfmt->width  = mf->width;\n\t\ttfmt->height = mf->height;\n\t\tffmt = fimc_capture_try_format(ctx, &tfmt->width, &tfmt->height,\n\t\t\t\t\tNULL, &fcc, FIMC_SD_PAD_SINK_CAM);\n\t\tffmt = fimc_capture_try_format(ctx, &tfmt->width, &tfmt->height,\n\t\t\t\t\tNULL, &fcc, FIMC_SD_PAD_SOURCE);\n\t\tif (ffmt && ffmt->mbus_code)\n\t\t\tmf->code = ffmt->mbus_code;\n\t\tif (mf->width != tfmt->width || mf->height != tfmt->height)\n\t\t\tcontinue;\n\t\ttfmt->code = mf->code;\n\t\tbreak;\n\t}\n\n\tif (fmt_id && ffmt)\n\t\t*fmt_id = ffmt;\n\t*tfmt = *mf;\n\n\treturn 0;\n}\n\n \nstatic int fimc_get_sensor_frame_desc(struct v4l2_subdev *sensor,\n\t\t\t\t      struct v4l2_plane_pix_format *plane_fmt,\n\t\t\t\t      unsigned int num_planes, bool try)\n{\n\tstruct v4l2_mbus_frame_desc fd = { };\n\tint i, ret;\n\tint pad;\n\n\tfor (i = 0; i < num_planes; i++)\n\t\tfd.entry[i].length = plane_fmt[i].sizeimage;\n\n\tpad = sensor->entity.num_pads - 1;\n\tif (try)\n\t\tret = v4l2_subdev_call(sensor, pad, set_frame_desc, pad, &fd);\n\telse\n\t\tret = v4l2_subdev_call(sensor, pad, get_frame_desc, pad, &fd);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (num_planes != fd.num_entries)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_planes; i++)\n\t\tplane_fmt[i].sizeimage = fd.entry[i].length;\n\n\tif (fd.entry[0].length > FIMC_MAX_JPEG_BUF_SIZE) {\n\t\tv4l2_err(sensor->v4l2_dev,  \"Unsupported buffer size: %u\\n\",\n\t\t\t fd.entry[0].length);\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fimc_cap_g_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\n\t__fimc_get_format(&fimc->vid_cap.ctx->d_frame, f);\n\treturn 0;\n}\n\n \nstatic int __video_try_or_set_format(struct fimc_dev *fimc,\n\t\t\t\t     struct v4l2_format *f, bool try,\n\t\t\t\t     struct fimc_fmt **inp_fmt,\n\t\t\t\t     struct fimc_fmt **out_fmt)\n{\n\tstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\n\tstruct fimc_vid_cap *vc = &fimc->vid_cap;\n\tstruct exynos_video_entity *ve = &vc->ve;\n\tstruct fimc_ctx *ctx = vc->ctx;\n\tunsigned int width = 0, height = 0;\n\tint ret = 0;\n\n\t \n\tif (fimc_jpeg_fourcc(pix->pixelformat)) {\n\t\tfimc_capture_try_format(ctx, &pix->width, &pix->height,\n\t\t\t\t\tNULL, &pix->pixelformat,\n\t\t\t\t\tFIMC_SD_PAD_SINK_CAM);\n\t\tif (try) {\n\t\t\twidth = pix->width;\n\t\t\theight = pix->height;\n\t\t} else {\n\t\t\tctx->s_frame.f_width = pix->width;\n\t\t\tctx->s_frame.f_height = pix->height;\n\t\t}\n\t}\n\n\t \n\t*out_fmt = fimc_capture_try_format(ctx, &pix->width, &pix->height,\n\t\t\t\t\t  NULL, &pix->pixelformat,\n\t\t\t\t\t  FIMC_SD_PAD_SOURCE);\n\tif (*out_fmt == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tif (try && fimc_jpeg_fourcc(pix->pixelformat)) {\n\t\tpix->width = width;\n\t\tpix->height = height;\n\t}\n\n\t \n\tif (!vc->user_subdev_api) {\n\t\tstruct v4l2_mbus_framefmt mbus_fmt;\n\t\tstruct v4l2_mbus_framefmt *mf;\n\n\t\tmf = try ? &mbus_fmt : &fimc->vid_cap.ci_fmt;\n\n\t\tmf->code = (*out_fmt)->mbus_code;\n\t\tmf->width = pix->width;\n\t\tmf->height = pix->height;\n\n\t\tfimc_md_graph_lock(ve);\n\t\tret = fimc_pipeline_try_format(ctx, mf, inp_fmt, try);\n\t\tfimc_md_graph_unlock(ve);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tpix->width = mf->width;\n\t\tpix->height = mf->height;\n\t}\n\n\tfimc_adjust_mplane_format(*out_fmt, pix->width, pix->height, pix);\n\n\tif ((*out_fmt)->flags & FMT_FLAGS_COMPRESSED) {\n\t\tstruct v4l2_subdev *sensor;\n\n\t\tfimc_md_graph_lock(ve);\n\n\t\tsensor = __fimc_md_get_subdev(ve->pipe, IDX_SENSOR);\n\t\tif (sensor)\n\t\t\tfimc_get_sensor_frame_desc(sensor, pix->plane_fmt,\n\t\t\t\t\t\t   (*out_fmt)->memplanes, try);\n\t\telse\n\t\t\tret = -EPIPE;\n\n\t\tfimc_md_graph_unlock(ve);\n\t}\n\n\treturn ret;\n}\n\nstatic int fimc_cap_try_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\tstruct fimc_fmt *out_fmt = NULL, *inp_fmt = NULL;\n\n\treturn __video_try_or_set_format(fimc, f, true, &inp_fmt, &out_fmt);\n}\n\nstatic void fimc_capture_mark_jpeg_xfer(struct fimc_ctx *ctx,\n\t\t\t\t\tenum fimc_color_fmt color)\n{\n\tbool jpeg = fimc_fmt_is_user_defined(color);\n\n\tctx->scaler.enabled = !jpeg;\n\tfimc_ctrls_activate(ctx, !jpeg);\n\n\tif (jpeg)\n\t\tset_bit(ST_CAPT_JPEG, &ctx->fimc_dev->state);\n\telse\n\t\tclear_bit(ST_CAPT_JPEG, &ctx->fimc_dev->state);\n}\n\nstatic int __fimc_capture_set_format(struct fimc_dev *fimc,\n\t\t\t\t     struct v4l2_format *f)\n{\n\tstruct fimc_vid_cap *vc = &fimc->vid_cap;\n\tstruct fimc_ctx *ctx = vc->ctx;\n\tstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\n\tstruct fimc_frame *ff = &ctx->d_frame;\n\tstruct fimc_fmt *inp_fmt = NULL;\n\tint ret, i;\n\n\tif (vb2_is_busy(&fimc->vid_cap.vbq))\n\t\treturn -EBUSY;\n\n\tret = __video_try_or_set_format(fimc, f, false, &inp_fmt, &ff->fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfimc_alpha_ctrl_update(ctx);\n\n\tfor (i = 0; i < ff->fmt->memplanes; i++) {\n\t\tff->bytesperline[i] = pix->plane_fmt[i].bytesperline;\n\t\tff->payload[i] = pix->plane_fmt[i].sizeimage;\n\t}\n\n\tset_frame_bounds(ff, pix->width, pix->height);\n\t \n\tif (!(ctx->state & FIMC_COMPOSE))\n\t\tset_frame_crop(ff, 0, 0, pix->width, pix->height);\n\n\tfimc_capture_mark_jpeg_xfer(ctx, ff->fmt->color);\n\n\t \n\tif (!vc->user_subdev_api) {\n\t\tctx->s_frame.fmt = inp_fmt;\n\t\tset_frame_bounds(&ctx->s_frame, pix->width, pix->height);\n\t\tset_frame_crop(&ctx->s_frame, 0, 0, pix->width, pix->height);\n\t}\n\n\treturn ret;\n}\n\nstatic int fimc_cap_s_fmt_mplane(struct file *file, void *priv,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\n\treturn __fimc_capture_set_format(fimc, f);\n}\n\nstatic int fimc_cap_enum_input(struct file *file, void *priv,\n\t\t\t       struct v4l2_input *i)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\tstruct exynos_video_entity *ve = &fimc->vid_cap.ve;\n\tstruct v4l2_subdev *sd;\n\n\tif (i->index != 0)\n\t\treturn -EINVAL;\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\tfimc_md_graph_lock(ve);\n\tsd = __fimc_md_get_subdev(ve->pipe, IDX_SENSOR);\n\tfimc_md_graph_unlock(ve);\n\n\tif (sd)\n\t\tstrscpy(i->name, sd->name, sizeof(i->name));\n\n\treturn 0;\n}\n\nstatic int fimc_cap_s_input(struct file *file, void *priv, unsigned int i)\n{\n\treturn i == 0 ? i : -EINVAL;\n}\n\nstatic int fimc_cap_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\n \nstatic int fimc_pipeline_validate(struct fimc_dev *fimc)\n{\n\tstruct v4l2_subdev_format sink_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev_format src_fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct fimc_vid_cap *vc = &fimc->vid_cap;\n\tstruct v4l2_subdev *sd = &vc->subdev;\n\tstruct fimc_pipeline *p = to_fimc_pipeline(vc->ve.pipe);\n\tstruct media_pad *sink_pad, *src_pad;\n\tint i, ret;\n\n\twhile (1) {\n\t\t \n\t\tsrc_pad = NULL;\n\n\t\tfor (i = 0; i < sd->entity.num_pads; i++) {\n\t\t\tstruct media_pad *p = &sd->entity.pads[i];\n\n\t\t\tif (p->flags & MEDIA_PAD_FL_SINK) {\n\t\t\t\tsink_pad = p;\n\t\t\t\tsrc_pad = media_pad_remote_pad_first(sink_pad);\n\t\t\t\tif (src_pad)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!src_pad || !is_media_entity_v4l2_subdev(src_pad->entity))\n\t\t\tbreak;\n\n\t\t \n\t\tif (sd == &vc->subdev) {\n\t\t\tstruct fimc_frame *ff = &vc->ctx->s_frame;\n\t\t\tsink_fmt.format.width = ff->f_width;\n\t\t\tsink_fmt.format.height = ff->f_height;\n\t\t\tsink_fmt.format.code = ff->fmt ? ff->fmt->mbus_code : 0;\n\t\t} else {\n\t\t\tsink_fmt.pad = sink_pad->index;\n\t\t\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &sink_fmt);\n\t\t\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\t\t\treturn -EPIPE;\n\t\t}\n\n\t\t \n\t\tsd = media_entity_to_v4l2_subdev(src_pad->entity);\n\t\tsrc_fmt.pad = src_pad->index;\n\t\tret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &src_fmt);\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\t\treturn -EPIPE;\n\n\t\tif (src_fmt.format.width != sink_fmt.format.width ||\n\t\t    src_fmt.format.height != sink_fmt.format.height ||\n\t\t    src_fmt.format.code != sink_fmt.format.code)\n\t\t\treturn -EPIPE;\n\n\t\tif (sd == p->subdevs[IDX_SENSOR] &&\n\t\t    fimc_user_defined_mbus_fmt(src_fmt.format.code)) {\n\t\t\tstruct v4l2_plane_pix_format plane_fmt[FIMC_MAX_PLANES];\n\t\t\tstruct fimc_frame *frame = &vc->ctx->d_frame;\n\t\t\tunsigned int i;\n\n\t\t\tret = fimc_get_sensor_frame_desc(sd, plane_fmt,\n\t\t\t\t\t\t\t frame->fmt->memplanes,\n\t\t\t\t\t\t\t false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -EPIPE;\n\n\t\t\tfor (i = 0; i < frame->fmt->memplanes; i++)\n\t\t\t\tif (frame->payload[i] < plane_fmt[i].sizeimage)\n\t\t\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int fimc_cap_streamon(struct file *file, void *priv,\n\t\t\t     enum v4l2_buf_type type)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\tstruct fimc_vid_cap *vc = &fimc->vid_cap;\n\tstruct fimc_source_info *si = NULL;\n\tstruct v4l2_subdev *sd;\n\tint ret;\n\n\tif (fimc_capture_active(fimc))\n\t\treturn -EBUSY;\n\n\tret = video_device_pipeline_start(&vc->ve.vdev, &vc->ve.pipe->mp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsd = __fimc_md_get_subdev(vc->ve.pipe, IDX_SENSOR);\n\tif (sd)\n\t\tsi = v4l2_get_subdev_hostdata(sd);\n\n\tif (si == NULL) {\n\t\tret = -EPIPE;\n\t\tgoto err_p_stop;\n\t}\n\t \n\tvc->source_config = *si;\n\n\tif (vc->input == GRP_ID_FIMC_IS)\n\t\tvc->source_config.fimc_bus_type = FIMC_BUS_TYPE_ISP_WRITEBACK;\n\n\tif (vc->user_subdev_api) {\n\t\tret = fimc_pipeline_validate(fimc);\n\t\tif (ret < 0)\n\t\t\tgoto err_p_stop;\n\t}\n\n\tret = vb2_ioctl_streamon(file, priv, type);\n\tif (!ret) {\n\t\tvc->streaming = true;\n\t\treturn ret;\n\t}\n\nerr_p_stop:\n\tvideo_device_pipeline_stop(&vc->ve.vdev);\n\treturn ret;\n}\n\nstatic int fimc_cap_streamoff(struct file *file, void *priv,\n\t\t\t    enum v4l2_buf_type type)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\tstruct fimc_vid_cap *vc = &fimc->vid_cap;\n\tint ret;\n\n\tret = vb2_ioctl_streamoff(file, priv, type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (vc->streaming) {\n\t\tvideo_device_pipeline_stop(&vc->ve.vdev);\n\t\tvc->streaming = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int fimc_cap_reqbufs(struct file *file, void *priv,\n\t\t\t    struct v4l2_requestbuffers *reqbufs)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\tint ret;\n\n\tret = vb2_ioctl_reqbufs(file, priv, reqbufs);\n\n\tif (!ret)\n\t\tfimc->vid_cap.reqbufs_count = reqbufs->count;\n\n\treturn ret;\n}\n\nstatic int fimc_cap_g_selection(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_selection *s)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\tstruct fimc_ctx *ctx = fimc->vid_cap.ctx;\n\tstruct fimc_frame *f = &ctx->s_frame;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tf = &ctx->d_frame;\n\t\tfallthrough;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = f->o_width;\n\t\ts->r.height = f->o_height;\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tf = &ctx->d_frame;\n\t\tfallthrough;\n\tcase V4L2_SEL_TGT_CROP:\n\t\ts->r.left = f->offs_h;\n\t\ts->r.top = f->offs_v;\n\t\ts->r.width = f->width;\n\t\ts->r.height = f->height;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int fimc_cap_s_selection(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_selection *s)\n{\n\tstruct fimc_dev *fimc = video_drvdata(file);\n\tstruct fimc_ctx *ctx = fimc->vid_cap.ctx;\n\tstruct v4l2_rect rect = s->r;\n\tstruct fimc_frame *f;\n\tunsigned long flags;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (s->target == V4L2_SEL_TGT_COMPOSE)\n\t\tf = &ctx->d_frame;\n\telse if (s->target == V4L2_SEL_TGT_CROP)\n\t\tf = &ctx->s_frame;\n\telse\n\t\treturn -EINVAL;\n\n\tfimc_capture_try_selection(ctx, &rect, s->target);\n\n\tif (s->flags & V4L2_SEL_FLAG_LE &&\n\t    !v4l2_rect_enclosed(&rect, &s->r))\n\t\treturn -ERANGE;\n\n\tif (s->flags & V4L2_SEL_FLAG_GE &&\n\t    !v4l2_rect_enclosed(&s->r, &rect))\n\t\treturn -ERANGE;\n\n\ts->r = rect;\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tset_frame_crop(f, s->r.left, s->r.top, s->r.width,\n\t\t       s->r.height);\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\tset_bit(ST_CAPT_APPLY_CFG, &fimc->state);\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops fimc_capture_ioctl_ops = {\n\t.vidioc_querycap\t\t= fimc_cap_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= fimc_cap_enum_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane\t= fimc_cap_try_fmt_mplane,\n\t.vidioc_s_fmt_vid_cap_mplane\t= fimc_cap_s_fmt_mplane,\n\t.vidioc_g_fmt_vid_cap_mplane\t= fimc_cap_g_fmt_mplane,\n\n\t.vidioc_reqbufs\t\t\t= fimc_cap_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\n\t.vidioc_streamon\t\t= fimc_cap_streamon,\n\t.vidioc_streamoff\t\t= fimc_cap_streamoff,\n\n\t.vidioc_g_selection\t\t= fimc_cap_g_selection,\n\t.vidioc_s_selection\t\t= fimc_cap_s_selection,\n\n\t.vidioc_enum_input\t\t= fimc_cap_enum_input,\n\t.vidioc_s_input\t\t\t= fimc_cap_s_input,\n\t.vidioc_g_input\t\t\t= fimc_cap_g_input,\n};\n\n \nstatic int fimc_link_setup(struct media_entity *entity,\n\t\t\t   const struct media_pad *local,\n\t\t\t   const struct media_pad *remote, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\n\tstruct fimc_vid_cap *vc = &fimc->vid_cap;\n\tstruct v4l2_subdev *sensor;\n\n\tif (!is_media_entity_v4l2_subdev(remote->entity))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(fimc == NULL))\n\t\treturn 0;\n\n\tdbg(\"%s --> %s, flags: 0x%x. input: 0x%x\",\n\t    local->entity->name, remote->entity->name, flags,\n\t    fimc->vid_cap.input);\n\n\tif (!(flags & MEDIA_LNK_FL_ENABLED)) {\n\t\tfimc->vid_cap.input = 0;\n\t\treturn 0;\n\t}\n\n\tif (vc->input != 0)\n\t\treturn -EBUSY;\n\n\tvc->input = sd->grp_id;\n\n\tif (vc->user_subdev_api)\n\t\treturn 0;\n\n\t \n\tsensor = fimc_find_remote_sensor(&vc->subdev.entity);\n\tif (sensor == NULL)\n\t\treturn 0;\n\n\treturn v4l2_ctrl_add_handler(&vc->ctx->ctrls.handler,\n\t\t\t\t     sensor->ctrl_handler, NULL, true);\n}\n\nstatic const struct media_entity_operations fimc_sd_media_ops = {\n\t.link_setup = fimc_link_setup,\n};\n\n \nvoid fimc_sensor_notify(struct v4l2_subdev *sd, unsigned int notification,\n\t\t\tvoid *arg)\n{\n\tstruct fimc_source_info\t*si;\n\tstruct fimc_vid_buffer *buf;\n\tstruct fimc_md *fmd;\n\tstruct fimc_dev *fimc;\n\tunsigned long flags;\n\n\tif (sd == NULL)\n\t\treturn;\n\n\tsi = v4l2_get_subdev_hostdata(sd);\n\tfmd = entity_to_fimc_mdev(&sd->entity);\n\n\tspin_lock_irqsave(&fmd->slock, flags);\n\n\tfimc = si ? source_to_sensor_info(si)->host : NULL;\n\n\tif (fimc && arg && notification == S5P_FIMC_TX_END_NOTIFY &&\n\t    test_bit(ST_CAPT_PEND, &fimc->state)) {\n\t\tunsigned long irq_flags;\n\t\tspin_lock_irqsave(&fimc->slock, irq_flags);\n\t\tif (!list_empty(&fimc->vid_cap.active_buf_q)) {\n\t\t\tbuf = list_entry(fimc->vid_cap.active_buf_q.next,\n\t\t\t\t\t struct fimc_vid_buffer, list);\n\t\t\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0,\n\t\t\t\t\t      *((u32 *)arg));\n\t\t}\n\t\tfimc_capture_irq_handler(fimc, 1);\n\t\tfimc_deactivate_capture(fimc);\n\t\tspin_unlock_irqrestore(&fimc->slock, irq_flags);\n\t}\n\tspin_unlock_irqrestore(&fmd->slock, flags);\n}\n\nstatic int fimc_subdev_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct fimc_fmt *fmt;\n\n\tfmt = fimc_find_format(NULL, NULL, FMT_FLAGS_CAM, code->index);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\tcode->code = fmt->mbus_code;\n\treturn 0;\n}\n\nstatic int fimc_subdev_get_fmt(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_format *fmt)\n{\n\tstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\n\tstruct fimc_ctx *ctx = fimc->vid_cap.ctx;\n\tstruct fimc_frame *ff = &ctx->s_frame;\n\tstruct v4l2_mbus_framefmt *mf;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);\n\t\tfmt->format = *mf;\n\t\treturn 0;\n\t}\n\n\tmf = &fmt->format;\n\tmutex_lock(&fimc->lock);\n\n\tswitch (fmt->pad) {\n\tcase FIMC_SD_PAD_SOURCE:\n\t\tif (!WARN_ON(ff->fmt == NULL))\n\t\t\tmf->code = ff->fmt->mbus_code;\n\t\t \n\t\tmf->width = ff->width;\n\t\tmf->height = ff->height;\n\t\tbreak;\n\tcase FIMC_SD_PAD_SINK_FIFO:\n\t\t*mf = fimc->vid_cap.wb_fmt;\n\t\tbreak;\n\tcase FIMC_SD_PAD_SINK_CAM:\n\tdefault:\n\t\t*mf = fimc->vid_cap.ci_fmt;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&fimc->lock);\n\tmf->colorspace = V4L2_COLORSPACE_JPEG;\n\n\treturn 0;\n}\n\nstatic int fimc_subdev_set_fmt(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_format *fmt)\n{\n\tstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *mf = &fmt->format;\n\tstruct fimc_vid_cap *vc = &fimc->vid_cap;\n\tstruct fimc_ctx *ctx = vc->ctx;\n\tstruct fimc_frame *ff;\n\tstruct fimc_fmt *ffmt;\n\n\tdbg(\"pad%d: code: 0x%x, %dx%d\",\n\t    fmt->pad, mf->code, mf->width, mf->height);\n\n\tif (fmt->pad == FIMC_SD_PAD_SOURCE && vb2_is_busy(&vc->vbq))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&fimc->lock);\n\tffmt = fimc_capture_try_format(ctx, &mf->width, &mf->height,\n\t\t\t\t       &mf->code, NULL, fmt->pad);\n\tmutex_unlock(&fimc->lock);\n\tmf->colorspace = V4L2_COLORSPACE_JPEG;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tmf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);\n\t\t*mf = fmt->format;\n\t\treturn 0;\n\t}\n\t \n\tif (WARN_ON(ffmt == NULL))\n\t\treturn -EINVAL;\n\n\t \n\tfimc_alpha_ctrl_update(ctx);\n\n\tfimc_capture_mark_jpeg_xfer(ctx, ffmt->color);\n\tif (fmt->pad == FIMC_SD_PAD_SOURCE) {\n\t\tff = &ctx->d_frame;\n\t\t \n\t\tmf->width = ctx->s_frame.width;\n\t\tmf->height = ctx->s_frame.height;\n\t} else {\n\t\tff = &ctx->s_frame;\n\t}\n\n\tmutex_lock(&fimc->lock);\n\tset_frame_bounds(ff, mf->width, mf->height);\n\n\tif (fmt->pad == FIMC_SD_PAD_SINK_FIFO)\n\t\tvc->wb_fmt = *mf;\n\telse if (fmt->pad == FIMC_SD_PAD_SINK_CAM)\n\t\tvc->ci_fmt = *mf;\n\n\tff->fmt = ffmt;\n\n\t \n\tif (!(fmt->pad == FIMC_SD_PAD_SOURCE && (ctx->state & FIMC_COMPOSE)))\n\t\tset_frame_crop(ff, 0, 0, mf->width, mf->height);\n\n\tif (fmt->pad != FIMC_SD_PAD_SOURCE)\n\t\tctx->state &= ~FIMC_COMPOSE;\n\n\tmutex_unlock(&fimc->lock);\n\treturn 0;\n}\n\nstatic int fimc_subdev_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\n\tstruct fimc_ctx *ctx = fimc->vid_cap.ctx;\n\tstruct fimc_frame *f = &ctx->s_frame;\n\tstruct v4l2_rect *r = &sel->r;\n\tstruct v4l2_rect *try_sel;\n\n\tif (sel->pad == FIMC_SD_PAD_SOURCE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&fimc->lock);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tf = &ctx->d_frame;\n\t\tfallthrough;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tr->width = f->o_width;\n\t\tr->height = f->o_height;\n\t\tr->left = 0;\n\t\tr->top = 0;\n\t\tmutex_unlock(&fimc->lock);\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_CROP:\n\t\ttry_sel = v4l2_subdev_get_try_crop(sd, sd_state, sel->pad);\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\ttry_sel = v4l2_subdev_get_try_compose(sd, sd_state, sel->pad);\n\t\tf = &ctx->d_frame;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&fimc->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\tsel->r = *try_sel;\n\t} else {\n\t\tr->left = f->offs_h;\n\t\tr->top = f->offs_v;\n\t\tr->width = f->width;\n\t\tr->height = f->height;\n\t}\n\n\tdbg(\"target %#x: l:%d, t:%d, %dx%d, f_w: %d, f_h: %d\",\n\t    sel->pad, r->left, r->top, r->width, r->height,\n\t    f->f_width, f->f_height);\n\n\tmutex_unlock(&fimc->lock);\n\treturn 0;\n}\n\nstatic int fimc_subdev_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\n\tstruct fimc_ctx *ctx = fimc->vid_cap.ctx;\n\tstruct fimc_frame *f = &ctx->s_frame;\n\tstruct v4l2_rect *r = &sel->r;\n\tstruct v4l2_rect *try_sel;\n\tunsigned long flags;\n\n\tif (sel->pad == FIMC_SD_PAD_SOURCE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&fimc->lock);\n\tfimc_capture_try_selection(ctx, r, V4L2_SEL_TGT_CROP);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\ttry_sel = v4l2_subdev_get_try_crop(sd, sd_state, sel->pad);\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\ttry_sel = v4l2_subdev_get_try_compose(sd, sd_state, sel->pad);\n\t\tf = &ctx->d_frame;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&fimc->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\n\t\t*try_sel = sel->r;\n\t} else {\n\t\tspin_lock_irqsave(&fimc->slock, flags);\n\t\tset_frame_crop(f, r->left, r->top, r->width, r->height);\n\t\tset_bit(ST_CAPT_APPLY_CFG, &fimc->state);\n\t\tif (sel->target == V4L2_SEL_TGT_COMPOSE)\n\t\t\tctx->state |= FIMC_COMPOSE;\n\t\tspin_unlock_irqrestore(&fimc->slock, flags);\n\t}\n\n\tdbg(\"target %#x: (%d,%d)/%dx%d\", sel->target, r->left, r->top,\n\t    r->width, r->height);\n\n\tmutex_unlock(&fimc->lock);\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops fimc_subdev_pad_ops = {\n\t.enum_mbus_code = fimc_subdev_enum_mbus_code,\n\t.get_selection = fimc_subdev_get_selection,\n\t.set_selection = fimc_subdev_set_selection,\n\t.get_fmt = fimc_subdev_get_fmt,\n\t.set_fmt = fimc_subdev_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops fimc_subdev_ops = {\n\t.pad = &fimc_subdev_pad_ops,\n};\n\n \nstatic int fimc_capture_set_default_format(struct fimc_dev *fimc)\n{\n\tstruct v4l2_format fmt = {\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t\t.fmt.pix_mp = {\n\t\t\t.width\t\t= FIMC_DEFAULT_WIDTH,\n\t\t\t.height\t\t= FIMC_DEFAULT_HEIGHT,\n\t\t\t.pixelformat\t= V4L2_PIX_FMT_YUYV,\n\t\t\t.field\t\t= V4L2_FIELD_NONE,\n\t\t\t.colorspace\t= V4L2_COLORSPACE_JPEG,\n\t\t},\n\t};\n\n\treturn __fimc_capture_set_format(fimc, &fmt);\n}\n\n \nstatic int fimc_register_capture_device(struct fimc_dev *fimc,\n\t\t\t\t struct v4l2_device *v4l2_dev)\n{\n\tstruct video_device *vfd = &fimc->vid_cap.ve.vdev;\n\tstruct vb2_queue *q = &fimc->vid_cap.vbq;\n\tstruct fimc_ctx *ctx;\n\tstruct fimc_vid_cap *vid_cap;\n\tstruct fimc_fmt *fmt;\n\tint ret = -ENOMEM;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->fimc_dev\t = fimc;\n\tctx->in_path\t = FIMC_IO_CAMERA;\n\tctx->out_path\t = FIMC_IO_DMA;\n\tctx->state\t = FIMC_CTX_CAP;\n\tctx->s_frame.fmt = fimc_find_format(NULL, NULL, FMT_FLAGS_CAM, 0);\n\tctx->d_frame.fmt = ctx->s_frame.fmt;\n\n\tmemset(vfd, 0, sizeof(*vfd));\n\tsnprintf(vfd->name, sizeof(vfd->name), \"fimc.%d.capture\", fimc->id);\n\n\tvfd->fops\t= &fimc_capture_fops;\n\tvfd->ioctl_ops\t= &fimc_capture_ioctl_ops;\n\tvfd->v4l2_dev\t= v4l2_dev;\n\tvfd->minor\t= -1;\n\tvfd->release\t= video_device_release_empty;\n\tvfd->queue\t= q;\n\tvfd->lock\t= &fimc->lock;\n\tvfd->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE_MPLANE;\n\n\tvideo_set_drvdata(vfd, fimc);\n\tvid_cap = &fimc->vid_cap;\n\tvid_cap->active_buf_cnt = 0;\n\tvid_cap->reqbufs_count = 0;\n\tvid_cap->ctx = ctx;\n\n\tINIT_LIST_HEAD(&vid_cap->pending_buf_q);\n\tINIT_LIST_HEAD(&vid_cap->active_buf_q);\n\n\tmemset(q, 0, sizeof(*q));\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tq->drv_priv = ctx;\n\tq->ops = &fimc_capture_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->buf_struct_size = sizeof(struct fimc_vid_buffer);\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &fimc->lock;\n\tq->dev = &fimc->pdev->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\tgoto err_free_ctx;\n\n\t \n\tfmt = fimc_find_format(NULL, NULL, FMT_FLAGS_CAM, 0);\n\tvid_cap->ci_fmt.width = FIMC_DEFAULT_WIDTH;\n\tvid_cap->ci_fmt.height = FIMC_DEFAULT_HEIGHT;\n\tvid_cap->ci_fmt.code = fmt->mbus_code;\n\n\tctx->s_frame.width = FIMC_DEFAULT_WIDTH;\n\tctx->s_frame.height = FIMC_DEFAULT_HEIGHT;\n\tctx->s_frame.fmt = fmt;\n\n\tfmt = fimc_find_format(NULL, NULL, FMT_FLAGS_WRITEBACK, 0);\n\tvid_cap->wb_fmt = vid_cap->ci_fmt;\n\tvid_cap->wb_fmt.code = fmt->mbus_code;\n\n\tvid_cap->vd_pad.flags = MEDIA_PAD_FL_SINK;\n\tvfd->entity.function = MEDIA_ENT_F_PROC_VIDEO_SCALER;\n\tret = media_entity_pads_init(&vfd->entity, 1, &vid_cap->vd_pad);\n\tif (ret)\n\t\tgoto err_free_ctx;\n\n\tret = fimc_ctrls_create(ctx);\n\tif (ret)\n\t\tgoto err_me_cleanup;\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, -1);\n\tif (ret)\n\t\tgoto err_ctrl_free;\n\n\tv4l2_info(v4l2_dev, \"Registered %s as /dev/%s\\n\",\n\t\t  vfd->name, video_device_node_name(vfd));\n\n\tvfd->ctrl_handler = &ctx->ctrls.handler;\n\treturn 0;\n\nerr_ctrl_free:\n\tfimc_ctrls_delete(ctx);\nerr_me_cleanup:\n\tmedia_entity_cleanup(&vfd->entity);\nerr_free_ctx:\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic int fimc_capture_subdev_registered(struct v4l2_subdev *sd)\n{\n\tstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tif (fimc == NULL)\n\t\treturn -ENXIO;\n\n\tret = fimc_register_m2m_device(fimc, sd->v4l2_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tfimc->vid_cap.ve.pipe = v4l2_get_subdev_hostdata(sd);\n\n\tret = fimc_register_capture_device(fimc, sd->v4l2_dev);\n\tif (ret) {\n\t\tfimc_unregister_m2m_device(fimc);\n\t\tfimc->vid_cap.ve.pipe = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void fimc_capture_subdev_unregistered(struct v4l2_subdev *sd)\n{\n\tstruct fimc_dev *fimc = v4l2_get_subdevdata(sd);\n\tstruct video_device *vdev;\n\n\tif (fimc == NULL)\n\t\treturn;\n\n\tmutex_lock(&fimc->lock);\n\n\tfimc_unregister_m2m_device(fimc);\n\tvdev = &fimc->vid_cap.ve.vdev;\n\n\tif (video_is_registered(vdev)) {\n\t\tvideo_unregister_device(vdev);\n\t\tmedia_entity_cleanup(&vdev->entity);\n\t\tfimc_ctrls_delete(fimc->vid_cap.ctx);\n\t\tfimc->vid_cap.ve.pipe = NULL;\n\t}\n\tkfree(fimc->vid_cap.ctx);\n\tfimc->vid_cap.ctx = NULL;\n\n\tmutex_unlock(&fimc->lock);\n}\n\nstatic const struct v4l2_subdev_internal_ops fimc_capture_sd_internal_ops = {\n\t.registered = fimc_capture_subdev_registered,\n\t.unregistered = fimc_capture_subdev_unregistered,\n};\n\nint fimc_initialize_capture_subdev(struct fimc_dev *fimc)\n{\n\tstruct v4l2_subdev *sd = &fimc->vid_cap.subdev;\n\tint ret;\n\n\tv4l2_subdev_init(sd, &fimc_subdev_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsnprintf(sd->name, sizeof(sd->name), \"FIMC.%d\", fimc->id);\n\n\tfimc->vid_cap.sd_pads[FIMC_SD_PAD_SINK_CAM].flags = MEDIA_PAD_FL_SINK;\n\tfimc->vid_cap.sd_pads[FIMC_SD_PAD_SINK_FIFO].flags = MEDIA_PAD_FL_SINK;\n\tfimc->vid_cap.sd_pads[FIMC_SD_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\tret = media_entity_pads_init(&sd->entity, FIMC_SD_PADS_NUM,\n\t\t\t\tfimc->vid_cap.sd_pads);\n\tif (ret)\n\t\treturn ret;\n\n\tsd->entity.ops = &fimc_sd_media_ops;\n\tsd->entity.function = MEDIA_ENT_F_PROC_VIDEO_SCALER;\n\tsd->internal_ops = &fimc_capture_sd_internal_ops;\n\tv4l2_set_subdevdata(sd, fimc);\n\treturn 0;\n}\n\nvoid fimc_unregister_capture_subdev(struct fimc_dev *fimc)\n{\n\tstruct v4l2_subdev *sd = &fimc->vid_cap.subdev;\n\n\tv4l2_device_unregister_subdev(sd);\n\tmedia_entity_cleanup(&sd->entity);\n\tv4l2_set_subdevdata(sd, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}