{
  "module_name": "fimc-is.h",
  "hash_id": "d829cdc11a8ce33a06c664684d4725b392d86b97d129a59519c49024ebc33f88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-is.h",
  "human_readable_source": " \n \n#ifndef FIMC_IS_H_\n#define FIMC_IS_H_\n\n#include <asm/barrier.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/sizes.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/v4l2-ctrls.h>\n\n#include \"fimc-isp.h\"\n#include \"fimc-is-command.h\"\n#include \"fimc-is-sensor.h\"\n#include \"fimc-is-param.h\"\n#include \"fimc-is-regs.h\"\n\n#define FIMC_IS_DRV_NAME\t\t\"exynos4-fimc-is\"\n\n#define FIMC_IS_FW_FILENAME\t\t\"exynos4_fimc_is_fw.bin\"\n#define FIMC_IS_SETFILE_6A3\t\t\"exynos4_s5k6a3_setfile.bin\"\n\n#define FIMC_IS_FW_LOAD_TIMEOUT\t\t1000  \n#define FIMC_IS_POWER_ON_TIMEOUT\t1000  \n\n#define FIMC_IS_SENSORS_NUM\t\t2\n\n \n#define FIMC_IS_CPU_MEM_SIZE\t\t(0xa00000)\n#define FIMC_IS_CPU_BASE_MASK\t\t((1 << 26) - 1)\n#define FIMC_IS_REGION_SIZE\t\t0x5000\n\n#define FIMC_IS_DEBUG_REGION_OFFSET\t0x0084b000\n#define FIMC_IS_SHARED_REGION_OFFSET\t0x008c0000\n#define FIMC_IS_FW_INFO_LEN\t\t31\n#define FIMC_IS_FW_VER_LEN\t\t7\n#define FIMC_IS_FW_DESC_LEN\t\t(FIMC_IS_FW_INFO_LEN + \\\n\t\t\t\t\t FIMC_IS_FW_VER_LEN)\n#define FIMC_IS_SETFILE_INFO_LEN\t39\n\n#define FIMC_IS_EXTRA_MEM_SIZE\t\t(FIMC_IS_EXTRA_FW_SIZE + \\\n\t\t\t\t\t FIMC_IS_EXTRA_SETFILE_SIZE + 0x1000)\n#define FIMC_IS_EXTRA_FW_SIZE\t\t0x180000\n#define FIMC_IS_EXTRA_SETFILE_SIZE\t0x4b000\n\n \n#define FIMC_IS_FW_ADDR_MASK\t\t((1 << 26) - 1)\n#define FIMC_IS_FW_SIZE_MAX\t\t(SZ_4M)\n#define FIMC_IS_FW_SIZE_MIN\t\t(SZ_32K)\n\n#define ATCLK_MCUISP_FREQUENCY\t\t100000000UL\n#define ACLK_AXI_FREQUENCY\t\t100000000UL\n\nenum {\n\tISS_CLK_PPMUISPX,\n\tISS_CLK_PPMUISPMX,\n\tISS_CLK_LITE0,\n\tISS_CLK_LITE1,\n\tISS_CLK_MPLL,\n\tISS_CLK_ISP,\n\tISS_CLK_DRC,\n\tISS_CLK_FD,\n\tISS_CLK_MCUISP,\n\tISS_CLK_GICISP,\n\tISS_CLK_PWM_ISP,\n\tISS_CLK_MCUCTL_ISP,\n\tISS_CLK_UART,\n\tISS_GATE_CLKS_MAX,\n\tISS_CLK_ISP_DIV0 = ISS_GATE_CLKS_MAX,\n\tISS_CLK_ISP_DIV1,\n\tISS_CLK_MCUISP_DIV0,\n\tISS_CLK_MCUISP_DIV1,\n\tISS_CLK_ACLK200,\n\tISS_CLK_ACLK200_DIV,\n\tISS_CLK_ACLK400MCUISP,\n\tISS_CLK_ACLK400MCUISP_DIV,\n\tISS_CLKS_MAX\n};\n\n \nenum {\n\tIS_ST_IDLE,\n\tIS_ST_PWR_ON,\n\tIS_ST_A5_PWR_ON,\n\tIS_ST_FW_LOADED,\n\tIS_ST_OPEN_SENSOR,\n\tIS_ST_SETFILE_LOADED,\n\tIS_ST_INIT_DONE,\n\tIS_ST_STREAM_ON,\n\tIS_ST_STREAM_OFF,\n\tIS_ST_CHANGE_MODE,\n\tIS_ST_BLOCK_CMD_CLEARED,\n\tIS_ST_SET_ZOOM,\n\tIS_ST_PWR_SUBIP_ON,\n\tIS_ST_END,\n};\n\nenum af_state {\n\tFIMC_IS_AF_IDLE\t\t= 0,\n\tFIMC_IS_AF_SETCONFIG\t= 1,\n\tFIMC_IS_AF_RUNNING\t= 2,\n\tFIMC_IS_AF_LOCK\t\t= 3,\n\tFIMC_IS_AF_ABORT\t= 4,\n\tFIMC_IS_AF_FAILED\t= 5,\n};\n\nenum af_lock_state {\n\tFIMC_IS_AF_UNLOCKED\t= 0,\n\tFIMC_IS_AF_LOCKED\t= 2\n};\n\nenum ae_lock_state {\n\tFIMC_IS_AE_UNLOCKED\t= 0,\n\tFIMC_IS_AE_LOCKED\t= 1\n};\n\nenum awb_lock_state {\n\tFIMC_IS_AWB_UNLOCKED\t= 0,\n\tFIMC_IS_AWB_LOCKED\t= 1\n};\n\nenum {\n\tIS_METERING_CONFIG_CMD,\n\tIS_METERING_CONFIG_WIN_POS_X,\n\tIS_METERING_CONFIG_WIN_POS_Y,\n\tIS_METERING_CONFIG_WIN_WIDTH,\n\tIS_METERING_CONFIG_WIN_HEIGHT,\n\tIS_METERING_CONFIG_MAX\n};\n\nstruct is_setfile {\n\tconst struct firmware *info;\n\tint state;\n\tu32 sub_index;\n\tu32 base;\n\tsize_t size;\n};\n\nstruct is_fd_result_header {\n\tu32 offset;\n\tu32 count;\n\tu32 index;\n\tu32 curr_index;\n\tu32 width;\n\tu32 height;\n};\n\nstruct is_af_info {\n\tu16 mode;\n\tu32 af_state;\n\tu32 af_lock_state;\n\tu32 ae_lock_state;\n\tu32 awb_lock_state;\n\tu16 pos_x;\n\tu16 pos_y;\n\tu16 prev_pos_x;\n\tu16 prev_pos_y;\n\tu16 use_af;\n};\n\nstruct fimc_is_firmware {\n\tconst struct firmware *f_w;\n\n\tdma_addr_t addr;\n\tvoid *vaddr;\n\tunsigned int size;\n\n\tchar info[FIMC_IS_FW_INFO_LEN + 1];\n\tchar version[FIMC_IS_FW_VER_LEN + 1];\n\tchar setfile_info[FIMC_IS_SETFILE_INFO_LEN + 1];\n\tu8 state;\n};\n\nstruct fimc_is_memory {\n\t \n\tdma_addr_t addr;\n\t \n\tvoid *vaddr;\n\t \n\tunsigned int size;\n};\n\n#define FIMC_IS_I2H_MAX_ARGS\t12\n\nstruct i2h_cmd {\n\tu32 cmd;\n\tu32 sensor_id;\n\tu16 num_args;\n\tu32 args[FIMC_IS_I2H_MAX_ARGS];\n};\n\nstruct h2i_cmd {\n\tu16 cmd_type;\n\tu32 entry_id;\n};\n\n#define FIMC_IS_DEBUG_MSG\t0x3f\n#define FIMC_IS_DEBUG_LEVEL\t3\n\nstruct fimc_is_setfile {\n\tconst struct firmware *info;\n\tunsigned int state;\n\tunsigned int size;\n\tu32 sub_index;\n\tu32 base;\n};\n\nstruct chain_config {\n\tstruct global_param\tglobal;\n\tstruct sensor_param\tsensor;\n\tstruct isp_param\tisp;\n\tstruct drc_param\tdrc;\n\tstruct fd_param\t\tfd;\n\n\tunsigned long\t\tp_region_index[2];\n};\n\n \nstruct fimc_is {\n\tstruct platform_device\t\t*pdev;\n\tstruct v4l2_device\t\t*v4l2_dev;\n\n\tstruct fimc_is_firmware\t\tfw;\n\tstruct fimc_is_memory\t\tmemory;\n\n\tstruct fimc_isp\t\t\tisp;\n\tstruct fimc_is_sensor\t\tsensor[FIMC_IS_SENSORS_NUM];\n\tstruct fimc_is_setfile\t\tsetfile;\n\n\tstruct v4l2_ctrl_handler\tctrl_handler;\n\n\tstruct mutex\t\t\tlock;\n\tspinlock_t\t\t\tslock;\n\n\tstruct clk\t\t\t*clocks[ISS_CLKS_MAX];\n\tvoid __iomem\t\t\t*regs;\n\tvoid __iomem\t\t\t*pmu_regs;\n\tint\t\t\t\tirq;\n\twait_queue_head_t\t\tirq_queue;\n\tu8\t\t\t\tlpm;\n\n\tunsigned long\t\t\tstate;\n\tunsigned int\t\t\tsensor_index;\n\n\tstruct i2h_cmd\t\t\ti2h_cmd;\n\tstruct h2i_cmd\t\t\th2i_cmd;\n\tstruct is_fd_result_header\tfd_header;\n\n\tstruct chain_config\t\tconfig[IS_SC_MAX];\n\tunsigned\t\t\tconfig_index;\n\n\tstruct is_region\t\t*is_p_region;\n\tdma_addr_t\t\t\tis_dma_p_region;\n\tstruct is_share_region\t\t*is_shared_region;\n\tstruct is_af_info\t\taf;\n\n\tstruct dentry\t\t\t*debugfs_entry;\n};\n\nstatic inline struct fimc_is *fimc_isp_to_is(struct fimc_isp *isp)\n{\n\treturn container_of(isp, struct fimc_is, isp);\n}\n\nstatic inline struct chain_config *__get_curr_is_config(struct fimc_is *is)\n{\n\treturn &is->config[is->config_index];\n}\n\nstatic inline void fimc_is_mem_barrier(void)\n{\n\tmb();\n}\n\nstatic inline void fimc_is_set_param_bit(struct fimc_is *is, int num)\n{\n\tstruct chain_config *cfg = &is->config[is->config_index];\n\n\tset_bit(num, &cfg->p_region_index[0]);\n}\n\nstatic inline void fimc_is_set_param_ctrl_cmd(struct fimc_is *is, int cmd)\n{\n\tis->is_p_region->parameter.isp.control.cmd = cmd;\n}\n\nstatic inline void mcuctl_write(u32 v, struct fimc_is *is, unsigned int offset)\n{\n\twritel(v, is->regs + offset);\n}\n\nstatic inline u32 mcuctl_read(struct fimc_is *is, unsigned int offset)\n{\n\treturn readl(is->regs + offset);\n}\n\nstatic inline void pmuisp_write(u32 v, struct fimc_is *is, unsigned int offset)\n{\n\twritel(v, is->pmu_regs + offset);\n}\n\nstatic inline u32 pmuisp_read(struct fimc_is *is, unsigned int offset)\n{\n\treturn readl(is->pmu_regs + offset);\n}\n\nint fimc_is_wait_event(struct fimc_is *is, unsigned long bit,\n\t\t       unsigned int state, unsigned int timeout);\nint fimc_is_cpu_set_power(struct fimc_is *is, int on);\nint fimc_is_start_firmware(struct fimc_is *is);\nint fimc_is_hw_initialize(struct fimc_is *is);\nvoid fimc_is_log_dump(const char *level, const void *buf, size_t len);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}