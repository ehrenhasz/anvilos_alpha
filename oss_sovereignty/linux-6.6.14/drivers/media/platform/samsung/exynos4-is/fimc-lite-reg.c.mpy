{
  "module_name": "fimc-lite-reg.c",
  "hash_id": "a2d7f7e6e6dff6307e6264964d6b125c1dcc11c124583ffc5a01e21bc0b96441",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-lite-reg.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <media/drv-intf/exynos-fimc.h>\n\n#include \"fimc-lite-reg.h\"\n#include \"fimc-lite.h\"\n#include \"fimc-core.h\"\n\n#define FLITE_RESET_TIMEOUT 50  \n\nvoid flite_hw_reset(struct fimc_lite *dev)\n{\n\tunsigned long end = jiffies + msecs_to_jiffies(FLITE_RESET_TIMEOUT);\n\tu32 cfg;\n\n\tcfg = readl(dev->regs + FLITE_REG_CIGCTRL);\n\tcfg |= FLITE_REG_CIGCTRL_SWRST_REQ;\n\twritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\n\n\twhile (time_is_after_jiffies(end)) {\n\t\tcfg = readl(dev->regs + FLITE_REG_CIGCTRL);\n\t\tif (cfg & FLITE_REG_CIGCTRL_SWRST_RDY)\n\t\t\tbreak;\n\t\tusleep_range(1000, 5000);\n\t}\n\n\tcfg |= FLITE_REG_CIGCTRL_SWRST;\n\twritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\n}\n\nvoid flite_hw_clear_pending_irq(struct fimc_lite *dev)\n{\n\tu32 cfg = readl(dev->regs + FLITE_REG_CISTATUS);\n\tcfg &= ~FLITE_REG_CISTATUS_IRQ_CAM;\n\twritel(cfg, dev->regs + FLITE_REG_CISTATUS);\n}\n\nu32 flite_hw_get_interrupt_source(struct fimc_lite *dev)\n{\n\tu32 intsrc = readl(dev->regs + FLITE_REG_CISTATUS);\n\treturn intsrc & FLITE_REG_CISTATUS_IRQ_MASK;\n}\n\nvoid flite_hw_clear_last_capture_end(struct fimc_lite *dev)\n{\n\n\tu32 cfg = readl(dev->regs + FLITE_REG_CISTATUS2);\n\tcfg &= ~FLITE_REG_CISTATUS2_LASTCAPEND;\n\twritel(cfg, dev->regs + FLITE_REG_CISTATUS2);\n}\n\nvoid flite_hw_set_interrupt_mask(struct fimc_lite *dev)\n{\n\tu32 cfg, intsrc;\n\n\t \n\tif (atomic_read(&dev->out_path) == FIMC_IO_DMA) {\n\t\tintsrc = FLITE_REG_CIGCTRL_IRQ_OVFEN |\n\t\t\t FLITE_REG_CIGCTRL_IRQ_LASTEN |\n\t\t\t FLITE_REG_CIGCTRL_IRQ_STARTEN |\n\t\t\t FLITE_REG_CIGCTRL_IRQ_ENDEN;\n\t} else {\n\t\t \n\t\tintsrc = FLITE_REG_CIGCTRL_IRQ_OVFEN |\n\t\t\t FLITE_REG_CIGCTRL_IRQ_LASTEN;\n\t}\n\n\tcfg = readl(dev->regs + FLITE_REG_CIGCTRL);\n\tcfg |= FLITE_REG_CIGCTRL_IRQ_DISABLE_MASK;\n\tcfg &= ~intsrc;\n\twritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\n}\n\nvoid flite_hw_capture_start(struct fimc_lite *dev)\n{\n\tu32 cfg = readl(dev->regs + FLITE_REG_CIIMGCPT);\n\tcfg |= FLITE_REG_CIIMGCPT_IMGCPTEN;\n\twritel(cfg, dev->regs + FLITE_REG_CIIMGCPT);\n}\n\nvoid flite_hw_capture_stop(struct fimc_lite *dev)\n{\n\tu32 cfg = readl(dev->regs + FLITE_REG_CIIMGCPT);\n\tcfg &= ~FLITE_REG_CIIMGCPT_IMGCPTEN;\n\twritel(cfg, dev->regs + FLITE_REG_CIIMGCPT);\n}\n\n \nvoid flite_hw_set_test_pattern(struct fimc_lite *dev, bool on)\n{\n\tu32 cfg = readl(dev->regs + FLITE_REG_CIGCTRL);\n\tif (on)\n\t\tcfg |= FLITE_REG_CIGCTRL_TEST_PATTERN_COLORBAR;\n\telse\n\t\tcfg &= ~FLITE_REG_CIGCTRL_TEST_PATTERN_COLORBAR;\n\twritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\n}\n\nstatic const u32 src_pixfmt_map[8][3] = {\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, FLITE_REG_CISRCSIZE_ORDER422_IN_YCBYCR,\n\t  FLITE_REG_CIGCTRL_YUV422_1P },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, FLITE_REG_CISRCSIZE_ORDER422_IN_YCRYCB,\n\t  FLITE_REG_CIGCTRL_YUV422_1P },\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, FLITE_REG_CISRCSIZE_ORDER422_IN_CBYCRY,\n\t  FLITE_REG_CIGCTRL_YUV422_1P },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, FLITE_REG_CISRCSIZE_ORDER422_IN_CRYCBY,\n\t  FLITE_REG_CIGCTRL_YUV422_1P },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, 0, FLITE_REG_CIGCTRL_RAW8 },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, 0, FLITE_REG_CIGCTRL_RAW10 },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, 0, FLITE_REG_CIGCTRL_RAW12 },\n\t{ MEDIA_BUS_FMT_JPEG_1X8, 0, FLITE_REG_CIGCTRL_USER(1) },\n};\n\n \nvoid flite_hw_set_source_format(struct fimc_lite *dev, struct flite_frame *f)\n{\n\tu32 pixelcode = f->fmt->mbus_code;\n\tint i = ARRAY_SIZE(src_pixfmt_map);\n\tu32 cfg;\n\n\twhile (--i) {\n\t\tif (src_pixfmt_map[i][0] == pixelcode)\n\t\t\tbreak;\n\t}\n\n\tif (i == 0 && src_pixfmt_map[i][0] != pixelcode) {\n\t\tv4l2_err(&dev->ve.vdev,\n\t\t\t \"Unsupported pixel code, falling back to %#08x\\n\",\n\t\t\t src_pixfmt_map[i][0]);\n\t}\n\n\tcfg = readl(dev->regs + FLITE_REG_CIGCTRL);\n\tcfg &= ~FLITE_REG_CIGCTRL_FMT_MASK;\n\tcfg |= src_pixfmt_map[i][2];\n\twritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\n\n\tcfg = readl(dev->regs + FLITE_REG_CISRCSIZE);\n\tcfg &= ~(FLITE_REG_CISRCSIZE_ORDER422_MASK |\n\t\t FLITE_REG_CISRCSIZE_SIZE_CAM_MASK);\n\tcfg |= (f->f_width << 16) | f->f_height;\n\tcfg |= src_pixfmt_map[i][1];\n\twritel(cfg, dev->regs + FLITE_REG_CISRCSIZE);\n}\n\n \nvoid flite_hw_set_window_offset(struct fimc_lite *dev, struct flite_frame *f)\n{\n\tu32 hoff2, voff2;\n\tu32 cfg;\n\n\tcfg = readl(dev->regs + FLITE_REG_CIWDOFST);\n\tcfg &= ~FLITE_REG_CIWDOFST_OFST_MASK;\n\tcfg |= (f->rect.left << 16) | f->rect.top;\n\tcfg |= FLITE_REG_CIWDOFST_WINOFSEN;\n\twritel(cfg, dev->regs + FLITE_REG_CIWDOFST);\n\n\thoff2 = f->f_width - f->rect.width - f->rect.left;\n\tvoff2 = f->f_height - f->rect.height - f->rect.top;\n\n\tcfg = (hoff2 << 16) | voff2;\n\twritel(cfg, dev->regs + FLITE_REG_CIWDOFST2);\n}\n\n \nstatic void flite_hw_set_camera_port(struct fimc_lite *dev, int id)\n{\n\tu32 cfg = readl(dev->regs + FLITE_REG_CIGENERAL);\n\tif (id == 0)\n\t\tcfg &= ~FLITE_REG_CIGENERAL_CAM_B;\n\telse\n\t\tcfg |= FLITE_REG_CIGENERAL_CAM_B;\n\twritel(cfg, dev->regs + FLITE_REG_CIGENERAL);\n}\n\n \nvoid flite_hw_set_camera_bus(struct fimc_lite *dev,\n\t\t\t     struct fimc_source_info *si)\n{\n\tu32 cfg = readl(dev->regs + FLITE_REG_CIGCTRL);\n\tunsigned int flags = si->flags;\n\n\tif (si->sensor_bus_type != FIMC_BUS_TYPE_MIPI_CSI2) {\n\t\tcfg &= ~(FLITE_REG_CIGCTRL_SELCAM_MIPI |\n\t\t\t FLITE_REG_CIGCTRL_INVPOLPCLK |\n\t\t\t FLITE_REG_CIGCTRL_INVPOLVSYNC |\n\t\t\t FLITE_REG_CIGCTRL_INVPOLHREF);\n\n\t\tif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\n\t\t\tcfg |= FLITE_REG_CIGCTRL_INVPOLPCLK;\n\n\t\tif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\n\t\t\tcfg |= FLITE_REG_CIGCTRL_INVPOLVSYNC;\n\n\t\tif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\n\t\t\tcfg |= FLITE_REG_CIGCTRL_INVPOLHREF;\n\t} else {\n\t\tcfg |= FLITE_REG_CIGCTRL_SELCAM_MIPI;\n\t}\n\n\twritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\n\n\tflite_hw_set_camera_port(dev, si->mux_id);\n}\n\nstatic void flite_hw_set_pack12(struct fimc_lite *dev, int on)\n{\n\tu32 cfg = readl(dev->regs + FLITE_REG_CIODMAFMT);\n\n\tcfg &= ~FLITE_REG_CIODMAFMT_PACK12;\n\n\tif (on)\n\t\tcfg |= FLITE_REG_CIODMAFMT_PACK12;\n\n\twritel(cfg, dev->regs + FLITE_REG_CIODMAFMT);\n}\n\nstatic void flite_hw_set_out_order(struct fimc_lite *dev, struct flite_frame *f)\n{\n\tstatic const u32 pixcode[4][2] = {\n\t\t{ MEDIA_BUS_FMT_YUYV8_2X8, FLITE_REG_CIODMAFMT_YCBYCR },\n\t\t{ MEDIA_BUS_FMT_YVYU8_2X8, FLITE_REG_CIODMAFMT_YCRYCB },\n\t\t{ MEDIA_BUS_FMT_UYVY8_2X8, FLITE_REG_CIODMAFMT_CBYCRY },\n\t\t{ MEDIA_BUS_FMT_VYUY8_2X8, FLITE_REG_CIODMAFMT_CRYCBY },\n\t};\n\tu32 cfg = readl(dev->regs + FLITE_REG_CIODMAFMT);\n\tint i = ARRAY_SIZE(pixcode);\n\n\twhile (--i)\n\t\tif (pixcode[i][0] == f->fmt->mbus_code)\n\t\t\tbreak;\n\tcfg &= ~FLITE_REG_CIODMAFMT_YCBCR_ORDER_MASK;\n\twritel(cfg | pixcode[i][1], dev->regs + FLITE_REG_CIODMAFMT);\n}\n\nvoid flite_hw_set_dma_window(struct fimc_lite *dev, struct flite_frame *f)\n{\n\tu32 cfg;\n\n\t \n\tcfg = readl(dev->regs + FLITE_REG_CIOCAN);\n\tcfg &= ~FLITE_REG_CIOCAN_MASK;\n\tcfg |= (f->f_height << 16) | f->f_width;\n\twritel(cfg, dev->regs + FLITE_REG_CIOCAN);\n\n\t \n\tcfg = readl(dev->regs + FLITE_REG_CIOOFF);\n\tcfg &= ~FLITE_REG_CIOOFF_MASK;\n\tcfg |= (f->rect.top << 16) | f->rect.left;\n\twritel(cfg, dev->regs + FLITE_REG_CIOOFF);\n}\n\nvoid flite_hw_set_dma_buffer(struct fimc_lite *dev, struct flite_buffer *buf)\n{\n\tunsigned int index;\n\tu32 cfg;\n\n\tif (dev->dd->max_dma_bufs == 1)\n\t\tindex = 0;\n\telse\n\t\tindex = buf->index;\n\n\tif (index == 0)\n\t\twritel(buf->addr, dev->regs + FLITE_REG_CIOSA);\n\telse\n\t\twritel(buf->addr, dev->regs + FLITE_REG_CIOSAN(index - 1));\n\n\tcfg = readl(dev->regs + FLITE_REG_CIFCNTSEQ);\n\tcfg |= BIT(index);\n\twritel(cfg, dev->regs + FLITE_REG_CIFCNTSEQ);\n}\n\nvoid flite_hw_mask_dma_buffer(struct fimc_lite *dev, u32 index)\n{\n\tu32 cfg;\n\n\tif (dev->dd->max_dma_bufs == 1)\n\t\tindex = 0;\n\n\tcfg = readl(dev->regs + FLITE_REG_CIFCNTSEQ);\n\tcfg &= ~BIT(index);\n\twritel(cfg, dev->regs + FLITE_REG_CIFCNTSEQ);\n}\n\n \nvoid flite_hw_set_output_dma(struct fimc_lite *dev, struct flite_frame *f,\n\t\t\t     bool enable)\n{\n\tu32 cfg = readl(dev->regs + FLITE_REG_CIGCTRL);\n\n\tif (!enable) {\n\t\tcfg |= FLITE_REG_CIGCTRL_ODMA_DISABLE;\n\t\twritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\n\t\treturn;\n\t}\n\n\tcfg &= ~FLITE_REG_CIGCTRL_ODMA_DISABLE;\n\twritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\n\n\tflite_hw_set_out_order(dev, f);\n\tflite_hw_set_dma_window(dev, f);\n\tflite_hw_set_pack12(dev, 0);\n}\n\nvoid flite_hw_dump_regs(struct fimc_lite *dev, const char *label)\n{\n\tstruct {\n\t\tu32 offset;\n\t\tconst char * const name;\n\t} registers[] = {\n\t\t{ 0x00, \"CISRCSIZE\" },\n\t\t{ 0x04, \"CIGCTRL\" },\n\t\t{ 0x08, \"CIIMGCPT\" },\n\t\t{ 0x0c, \"CICPTSEQ\" },\n\t\t{ 0x10, \"CIWDOFST\" },\n\t\t{ 0x14, \"CIWDOFST2\" },\n\t\t{ 0x18, \"CIODMAFMT\" },\n\t\t{ 0x20, \"CIOCAN\" },\n\t\t{ 0x24, \"CIOOFF\" },\n\t\t{ 0x30, \"CIOSA\" },\n\t\t{ 0x40, \"CISTATUS\" },\n\t\t{ 0x44, \"CISTATUS2\" },\n\t\t{ 0xf0, \"CITHOLD\" },\n\t\t{ 0xfc, \"CIGENERAL\" },\n\t};\n\tu32 i;\n\n\tv4l2_info(&dev->subdev, \"--- %s ---\\n\", label);\n\n\tfor (i = 0; i < ARRAY_SIZE(registers); i++) {\n\t\tu32 cfg = readl(dev->regs + registers[i].offset);\n\t\tv4l2_info(&dev->subdev, \"%9s: 0x%08x\\n\",\n\t\t\t  registers[i].name, cfg);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}