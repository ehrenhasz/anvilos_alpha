{
  "module_name": "fimc-core.h",
  "hash_id": "550789d80ce90c6d8489b302466fb8fe5a019638f4cf31a75fe203a7ccb19da1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-core.h",
  "human_readable_source": " \n \n\n#ifndef FIMC_CORE_H_\n#define FIMC_CORE_H_\n\n \n\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/mfd/syscon.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n#include <linux/io.h>\n#include <linux/sizes.h>\n\n#include <media/media-entity.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-mediabus.h>\n#include <media/drv-intf/exynos-fimc.h>\n\n#define dbg(fmt, args...) \\\n\tpr_debug(\"%s:%d: \" fmt \"\\n\", __func__, __LINE__, ##args)\n\n \n#define FIMC_SHUTDOWN_TIMEOUT\t((100*HZ)/1000)\n#define MAX_FIMC_CLOCKS\t\t2\n#define FIMC_DRIVER_NAME\t\"exynos4-fimc\"\n#define FIMC_MAX_DEVS\t\t4\n#define FIMC_MAX_OUT_BUFS\t4\n#define SCALER_MAX_HRATIO\t64\n#define SCALER_MAX_VRATIO\t64\n#define DMA_MIN_SIZE\t\t8\n#define FIMC_CAMIF_MAX_HEIGHT\t0x2000\n#define FIMC_MAX_JPEG_BUF_SIZE\t(10 * SZ_1M)\n#define FIMC_MAX_PLANES\t\t3\n#define FIMC_PIX_LIMITS_MAX\t4\n#define FIMC_DEF_MIN_SIZE\t16\n#define FIMC_DEF_HEIGHT_ALIGN\t2\n#define FIMC_DEF_HOR_OFFS_ALIGN\t1\n#define FIMC_DEFAULT_WIDTH\t640\n#define FIMC_DEFAULT_HEIGHT\t480\n\n \nenum {\n\tCLK_BUS,\n\tCLK_GATE,\n};\n\nenum fimc_dev_flags {\n\tST_LPM,\n\t \n\tST_M2M_RUN,\n\tST_M2M_PEND,\n\tST_M2M_SUSPENDING,\n\tST_M2M_SUSPENDED,\n\t \n\tST_CAPT_PEND,\n\tST_CAPT_RUN,\n\tST_CAPT_STREAM,\n\tST_CAPT_ISP_STREAM,\n\tST_CAPT_SUSPENDED,\n\tST_CAPT_SHUT,\n\tST_CAPT_BUSY,\n\tST_CAPT_APPLY_CFG,\n\tST_CAPT_JPEG,\n};\n\n#define fimc_m2m_active(dev) test_bit(ST_M2M_RUN, &(dev)->state)\n#define fimc_m2m_pending(dev) test_bit(ST_M2M_PEND, &(dev)->state)\n\n#define fimc_capture_running(dev) test_bit(ST_CAPT_RUN, &(dev)->state)\n#define fimc_capture_pending(dev) test_bit(ST_CAPT_PEND, &(dev)->state)\n#define fimc_capture_busy(dev) test_bit(ST_CAPT_BUSY, &(dev)->state)\n\nenum fimc_datapath {\n\tFIMC_IO_NONE,\n\tFIMC_IO_CAMERA,\n\tFIMC_IO_DMA,\n\tFIMC_IO_LCDFIFO,\n\tFIMC_IO_WRITEBACK,\n\tFIMC_IO_ISP,\n};\n\nenum fimc_color_fmt {\n\tFIMC_FMT_RGB444\t= 0x10,\n\tFIMC_FMT_RGB555,\n\tFIMC_FMT_RGB565,\n\tFIMC_FMT_RGB666,\n\tFIMC_FMT_RGB888,\n\tFIMC_FMT_RGB30_LOCAL,\n\tFIMC_FMT_YCBCR420 = 0x20,\n\tFIMC_FMT_YCBYCR422,\n\tFIMC_FMT_YCRYCB422,\n\tFIMC_FMT_CBYCRY422,\n\tFIMC_FMT_CRYCBY422,\n\tFIMC_FMT_YCBCR444_LOCAL,\n\tFIMC_FMT_RAW8 = 0x40,\n\tFIMC_FMT_RAW10,\n\tFIMC_FMT_RAW12,\n\tFIMC_FMT_JPEG = 0x80,\n\tFIMC_FMT_YUYV_JPEG = 0x100,\n};\n\n#define fimc_fmt_is_user_defined(x) (!!((x) & 0x180))\n#define fimc_fmt_is_rgb(x) (!!((x) & 0x10))\n\n#define IS_M2M(__strt) ((__strt) == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE || \\\n\t\t\t__strt == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\n \n#define\tFIMC_PARAMS\t\t(1 << 0)\n#define\tFIMC_COMPOSE\t\t(1 << 1)\n#define\tFIMC_CTX_M2M\t\t(1 << 16)\n#define\tFIMC_CTX_CAP\t\t(1 << 17)\n#define\tFIMC_CTX_SHUT\t\t(1 << 18)\n\n \n#define\tFIMC_IN_DMA_ACCESS_TILED\t(1 << 0)\n#define\tFIMC_IN_DMA_ACCESS_LINEAR\t(0 << 0)\n#define\tFIMC_OUT_DMA_ACCESS_TILED\t(1 << 1)\n#define\tFIMC_OUT_DMA_ACCESS_LINEAR\t(0 << 1)\n#define\tFIMC_SCAN_MODE_PROGRESSIVE\t(0 << 2)\n#define\tFIMC_SCAN_MODE_INTERLACED\t(1 << 2)\n \n#define\tFIMC_COLOR_RANGE_WIDE\t\t(0 << 3)\n \n#define\tFIMC_COLOR_RANGE_NARROW\t\t(1 << 3)\n\n \nstruct fimc_dma_offset {\n\tint\ty_h;\n\tint\ty_v;\n\tint\tcb_h;\n\tint\tcb_v;\n\tint\tcr_h;\n\tint\tcr_v;\n};\n\n \nstruct fimc_effect {\n\tu32\ttype;\n\tu8\tpat_cb;\n\tu8\tpat_cr;\n};\n\n \nstruct fimc_scaler {\n\tunsigned int scaleup_h:1;\n\tunsigned int scaleup_v:1;\n\tunsigned int copy_mode:1;\n\tunsigned int enabled:1;\n\tu32\thfactor;\n\tu32\tvfactor;\n\tu32\tpre_hratio;\n\tu32\tpre_vratio;\n\tu32\tpre_dst_width;\n\tu32\tpre_dst_height;\n\tu32\tmain_hratio;\n\tu32\tmain_vratio;\n\tu32\treal_width;\n\tu32\treal_height;\n};\n\n \nstruct fimc_addr {\n\tu32\ty;\n\tu32\tcb;\n\tu32\tcr;\n};\n\n \nstruct fimc_vid_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head\tlist;\n\tstruct fimc_addr\taddr;\n\tint\t\t\tindex;\n};\n\n \nstruct fimc_frame {\n\tu32\tf_width;\n\tu32\tf_height;\n\tu32\to_width;\n\tu32\to_height;\n\tu32\toffs_h;\n\tu32\toffs_v;\n\tu32\twidth;\n\tu32\theight;\n\tunsigned int\t\tpayload[VIDEO_MAX_PLANES];\n\tunsigned int\t\tbytesperline[VIDEO_MAX_PLANES];\n\tstruct fimc_addr\taddr;\n\tstruct fimc_dma_offset\tdma_offset;\n\tstruct fimc_fmt\t\t*fmt;\n\tu8\t\t\talpha;\n};\n\n \nstruct fimc_m2m_device {\n\tstruct video_device\tvfd;\n\tstruct v4l2_m2m_dev\t*m2m_dev;\n\tstruct fimc_ctx\t\t*ctx;\n\tint\t\t\trefcnt;\n};\n\n#define FIMC_SD_PAD_SINK_CAM\t0\n#define FIMC_SD_PAD_SINK_FIFO\t1\n#define FIMC_SD_PAD_SOURCE\t2\n#define FIMC_SD_PADS_NUM\t3\n\n \nstruct fimc_vid_cap {\n\tstruct fimc_ctx\t\t\t*ctx;\n\tstruct v4l2_subdev\t\tsubdev;\n\tstruct exynos_video_entity\tve;\n\tstruct media_pad\t\tvd_pad;\n\tstruct media_pad\t\tsd_pads[FIMC_SD_PADS_NUM];\n\tstruct v4l2_mbus_framefmt\tci_fmt;\n\tstruct v4l2_mbus_framefmt\twb_fmt;\n\tstruct fimc_source_info\t\tsource_config;\n\tstruct list_head\t\tpending_buf_q;\n\tstruct list_head\t\tactive_buf_q;\n\tstruct vb2_queue\t\tvbq;\n\tint\t\t\t\tactive_buf_cnt;\n\tint\t\t\t\tbuf_index;\n\tunsigned int\t\t\tframe_count;\n\tunsigned int\t\t\treqbufs_count;\n\tbool\t\t\t\tstreaming;\n\tu32\t\t\t\tinput;\n\tbool\t\t\t\tuser_subdev_api;\n};\n\n \nstruct fimc_pix_limit {\n\tu16 scaler_en_w;\n\tu16 scaler_dis_w;\n\tu16 in_rot_en_h;\n\tu16 in_rot_dis_w;\n\tu16 out_rot_en_w;\n\tu16 out_rot_dis_w;\n};\n\n \nstruct fimc_variant {\n\tunsigned int\thas_inp_rot:1;\n\tunsigned int\thas_out_rot:1;\n\tunsigned int\thas_mainscaler_ext:1;\n\tunsigned int\thas_cam_if:1;\n\tunsigned int\thas_isp_wb:1;\n\tconst struct fimc_pix_limit *pix_limit;\n\tu16\t\tmin_inp_pixsize;\n\tu16\t\tmin_out_pixsize;\n\tu16\t\thor_offs_align;\n\tu16\t\tmin_vsize_align;\n};\n\n \nstruct fimc_drvdata {\n\tconst struct fimc_variant *variant[FIMC_MAX_DEVS];\n\tint num_entities;\n\tunsigned long lclk_frequency;\n\t \n\tu8 cistatus2;\n\tu8 dma_pix_hoff;\n\tu8 alpha_color;\n\tu8 out_buf_count;\n};\n\n#define fimc_get_drvdata(_pdev) \\\n\t((struct fimc_drvdata *) platform_get_device_id(_pdev)->driver_data)\n\nstruct fimc_ctx;\n\n \nstruct fimc_dev {\n\tspinlock_t\t\t\tslock;\n\tstruct mutex\t\t\tlock;\n\tstruct platform_device\t\t*pdev;\n\tstruct s5p_platform_fimc\t*pdata;\n\tstruct regmap\t\t\t*sysreg;\n\tconst struct fimc_variant\t*variant;\n\tconst struct fimc_drvdata\t*drv_data;\n\tint\t\t\t\tid;\n\tstruct clk\t\t\t*clock[MAX_FIMC_CLOCKS];\n\tvoid __iomem\t\t\t*regs;\n\twait_queue_head_t\t\tirq_queue;\n\tstruct v4l2_device\t\t*v4l2_dev;\n\tstruct fimc_m2m_device\t\tm2m;\n\tstruct fimc_vid_cap\t\tvid_cap;\n\tunsigned long\t\t\tstate;\n};\n\n \nstruct fimc_ctrls {\n\tstruct v4l2_ctrl_handler handler;\n\tstruct {\n\t\tstruct v4l2_ctrl *colorfx;\n\t\tstruct v4l2_ctrl *colorfx_cbcr;\n\t};\n\tstruct v4l2_ctrl *rotate;\n\tstruct v4l2_ctrl *hflip;\n\tstruct v4l2_ctrl *vflip;\n\tstruct v4l2_ctrl *alpha;\n\tbool ready;\n};\n\n \nstruct fimc_ctx {\n\tstruct fimc_frame\ts_frame;\n\tstruct fimc_frame\td_frame;\n\tu32\t\t\tout_order_1p;\n\tu32\t\t\tout_order_2p;\n\tu32\t\t\tin_order_1p;\n\tu32\t\t\tin_order_2p;\n\tenum fimc_datapath\tin_path;\n\tenum fimc_datapath\tout_path;\n\tstruct fimc_scaler\tscaler;\n\tstruct fimc_effect\teffect;\n\tint\t\t\trotation;\n\tunsigned int\t\thflip:1;\n\tunsigned int\t\tvflip:1;\n\tu32\t\t\tflags;\n\tu32\t\t\tstate;\n\tstruct fimc_dev\t\t*fimc_dev;\n\tstruct v4l2_fh\t\tfh;\n\tstruct fimc_ctrls\tctrls;\n};\n\n#define fh_to_ctx(__fh) container_of(__fh, struct fimc_ctx, fh)\n\nstatic inline void set_frame_bounds(struct fimc_frame *f, u32 width, u32 height)\n{\n\tf->o_width  = width;\n\tf->o_height = height;\n\tf->f_width  = width;\n\tf->f_height = height;\n}\n\nstatic inline void set_frame_crop(struct fimc_frame *f,\n\t\t\t\t  u32 left, u32 top, u32 width, u32 height)\n{\n\tf->offs_h = left;\n\tf->offs_v = top;\n\tf->width  = width;\n\tf->height = height;\n}\n\nstatic inline u32 fimc_get_format_depth(struct fimc_fmt *ff)\n{\n\tu32 i, depth = 0;\n\n\tif (ff != NULL)\n\t\tfor (i = 0; i < ff->colplanes; i++)\n\t\t\tdepth += ff->depth[i];\n\treturn depth;\n}\n\nstatic inline bool fimc_capture_active(struct fimc_dev *fimc)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tret = !!(fimc->state & (1 << ST_CAPT_RUN) ||\n\t\t fimc->state & (1 << ST_CAPT_PEND));\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\treturn ret;\n}\n\nstatic inline void fimc_ctx_state_set(u32 state, struct fimc_ctx *ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->fimc_dev->slock, flags);\n\tctx->state |= state;\n\tspin_unlock_irqrestore(&ctx->fimc_dev->slock, flags);\n}\n\nstatic inline bool fimc_ctx_state_is_set(u32 mask, struct fimc_ctx *ctx)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\tspin_lock_irqsave(&ctx->fimc_dev->slock, flags);\n\tret = (ctx->state & mask) == mask;\n\tspin_unlock_irqrestore(&ctx->fimc_dev->slock, flags);\n\treturn ret;\n}\n\nstatic inline int tiled_fmt(struct fimc_fmt *fmt)\n{\n\treturn fmt->fourcc == V4L2_PIX_FMT_NV12MT;\n}\n\nstatic inline bool fimc_jpeg_fourcc(u32 pixelformat)\n{\n\treturn (pixelformat == V4L2_PIX_FMT_JPEG ||\n\t\tpixelformat == V4L2_PIX_FMT_S5C_UYVY_JPG);\n}\n\nstatic inline bool fimc_user_defined_mbus_fmt(u32 code)\n{\n\treturn (code == MEDIA_BUS_FMT_JPEG_1X8 ||\n\t\tcode == MEDIA_BUS_FMT_S5C_UYVY_JPEG_1X8);\n}\n\n \nstatic inline int fimc_get_alpha_mask(struct fimc_fmt *fmt)\n{\n\tswitch (fmt->color) {\n\tcase FIMC_FMT_RGB444:\treturn 0x0f;\n\tcase FIMC_FMT_RGB555:\treturn 0x01;\n\tcase FIMC_FMT_RGB888:\treturn 0xff;\n\tdefault:\t\treturn 0;\n\t};\n}\n\nstatic inline struct fimc_frame *ctx_get_frame(struct fimc_ctx *ctx,\n\t\t\t\t\t       enum v4l2_buf_type type)\n{\n\tstruct fimc_frame *frame;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE ||\n\t    type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tif (fimc_ctx_state_is_set(FIMC_CTX_M2M, ctx))\n\t\t\tframe = &ctx->s_frame;\n\t\telse\n\t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE ||\n\t\t   type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tframe = &ctx->d_frame;\n\t} else {\n\t\tv4l2_err(ctx->fimc_dev->v4l2_dev,\n\t\t\t\"Wrong buffer/video queue type (%d)\\n\", type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn frame;\n}\n\n \n \nint fimc_vidioc_enum_fmt_mplane(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_fmtdesc *f);\nint fimc_ctrls_create(struct fimc_ctx *ctx);\nvoid fimc_ctrls_delete(struct fimc_ctx *ctx);\nvoid fimc_ctrls_activate(struct fimc_ctx *ctx, bool active);\nvoid fimc_alpha_ctrl_update(struct fimc_ctx *ctx);\nvoid __fimc_get_format(struct fimc_frame *frame, struct v4l2_format *f);\nvoid fimc_adjust_mplane_format(struct fimc_fmt *fmt, u32 width, u32 height,\n\t\t\t       struct v4l2_pix_format_mplane *pix);\nstruct fimc_fmt *fimc_find_format(const u32 *pixelformat, const u32 *mbus_code,\n\t\t\t\t  unsigned int mask, int index);\nstruct fimc_fmt *fimc_get_format(unsigned int index);\n\nint fimc_check_scaler_ratio(struct fimc_ctx *ctx, int sw, int sh,\n\t\t\t    int dw, int dh, int rotation);\nint fimc_set_scaler_info(struct fimc_ctx *ctx);\nint fimc_prepare_config(struct fimc_ctx *ctx, u32 flags);\nint fimc_prepare_addr(struct fimc_ctx *ctx, struct vb2_buffer *vb,\n\t\t      struct fimc_frame *frame, struct fimc_addr *addr);\nvoid fimc_prepare_dma_offset(struct fimc_ctx *ctx, struct fimc_frame *f);\nvoid fimc_set_yuv_order(struct fimc_ctx *ctx);\nvoid fimc_capture_irq_handler(struct fimc_dev *fimc, int deq_buf);\n\nint fimc_register_m2m_device(struct fimc_dev *fimc,\n\t\t\t     struct v4l2_device *v4l2_dev);\nvoid fimc_unregister_m2m_device(struct fimc_dev *fimc);\nint fimc_register_driver(void);\nvoid fimc_unregister_driver(void);\n\n#ifdef CONFIG_MFD_SYSCON\nstatic inline struct regmap * fimc_get_sysreg_regmap(struct device_node *node)\n{\n\treturn syscon_regmap_lookup_by_phandle(node, \"samsung,sysreg\");\n}\n#else\n#define fimc_get_sysreg_regmap(node) (NULL)\n#endif\n\n \n \nvoid fimc_m2m_job_finish(struct fimc_ctx *ctx, int vb_state);\n\n \n \nint fimc_initialize_capture_subdev(struct fimc_dev *fimc);\nvoid fimc_unregister_capture_subdev(struct fimc_dev *fimc);\nint fimc_capture_ctrls_create(struct fimc_dev *fimc);\nvoid fimc_sensor_notify(struct v4l2_subdev *sd, unsigned int notification,\n\t\t\tvoid *arg);\nint fimc_capture_suspend(struct fimc_dev *fimc);\nint fimc_capture_resume(struct fimc_dev *fimc);\n\n \n\n \nstatic inline void fimc_active_queue_add(struct fimc_vid_cap *vid_cap,\n\t\t\t\t\t struct fimc_vid_buffer *buf)\n{\n\tlist_add_tail(&buf->list, &vid_cap->active_buf_q);\n\tvid_cap->active_buf_cnt++;\n}\n\n \nstatic inline struct fimc_vid_buffer *fimc_active_queue_pop(\n\t\t\t\t    struct fimc_vid_cap *vid_cap)\n{\n\tstruct fimc_vid_buffer *buf;\n\tbuf = list_entry(vid_cap->active_buf_q.next,\n\t\t\t struct fimc_vid_buffer, list);\n\tlist_del(&buf->list);\n\tvid_cap->active_buf_cnt--;\n\treturn buf;\n}\n\n \nstatic inline void fimc_pending_queue_add(struct fimc_vid_cap *vid_cap,\n\t\t\t\t\t  struct fimc_vid_buffer *buf)\n{\n\tlist_add_tail(&buf->list, &vid_cap->pending_buf_q);\n}\n\n \nstatic inline struct fimc_vid_buffer *fimc_pending_queue_pop(\n\t\t\t\t     struct fimc_vid_cap *vid_cap)\n{\n\tstruct fimc_vid_buffer *buf;\n\tbuf = list_entry(vid_cap->pending_buf_q.next,\n\t\t\tstruct fimc_vid_buffer, list);\n\tlist_del(&buf->list);\n\treturn buf;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}