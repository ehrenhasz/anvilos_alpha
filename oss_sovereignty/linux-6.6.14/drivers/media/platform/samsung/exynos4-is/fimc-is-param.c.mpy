{
  "module_name": "fimc-is-param.c",
  "hash_id": "52e9e6ba1eed9db23cf56d9bf04dbe5bcfdf29b61e0a0de471a5c72a83f193e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-is-param.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"%s:%d \" fmt, __func__, __LINE__\n\n#include <linux/bitops.h>\n#include <linux/bug.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"fimc-is.h\"\n#include \"fimc-is-command.h\"\n#include \"fimc-is-errno.h\"\n#include \"fimc-is-param.h\"\n#include \"fimc-is-regs.h\"\n#include \"fimc-is-sensor.h\"\n\nstatic void __hw_param_copy(void *dst, void *src)\n{\n\tmemcpy(dst, src, FIMC_IS_PARAM_MAX_SIZE);\n}\n\nstatic void __fimc_is_hw_update_param_global_shotmode(struct fimc_is *is)\n{\n\tstruct param_global_shotmode *dst, *src;\n\n\tdst = &is->is_p_region->parameter.global.shotmode;\n\tsrc = &is->config[is->config_index].global.shotmode;\n\t__hw_param_copy(dst, src);\n}\n\nstatic void __fimc_is_hw_update_param_sensor_framerate(struct fimc_is *is)\n{\n\tstruct param_sensor_framerate *dst, *src;\n\n\tdst = &is->is_p_region->parameter.sensor.frame_rate;\n\tsrc = &is->config[is->config_index].sensor.frame_rate;\n\t__hw_param_copy(dst, src);\n}\n\nint __fimc_is_hw_update_param(struct fimc_is *is, u32 offset)\n{\n\tstruct is_param_region *par = &is->is_p_region->parameter;\n\tstruct chain_config *cfg = &is->config[is->config_index];\n\n\tswitch (offset) {\n\tcase PARAM_ISP_CONTROL:\n\t\t__hw_param_copy(&par->isp.control, &cfg->isp.control);\n\t\tbreak;\n\n\tcase PARAM_ISP_OTF_INPUT:\n\t\t__hw_param_copy(&par->isp.otf_input, &cfg->isp.otf_input);\n\t\tbreak;\n\n\tcase PARAM_ISP_DMA1_INPUT:\n\t\t__hw_param_copy(&par->isp.dma1_input, &cfg->isp.dma1_input);\n\t\tbreak;\n\n\tcase PARAM_ISP_DMA2_INPUT:\n\t\t__hw_param_copy(&par->isp.dma2_input, &cfg->isp.dma2_input);\n\t\tbreak;\n\n\tcase PARAM_ISP_AA:\n\t\t__hw_param_copy(&par->isp.aa, &cfg->isp.aa);\n\t\tbreak;\n\n\tcase PARAM_ISP_FLASH:\n\t\t__hw_param_copy(&par->isp.flash, &cfg->isp.flash);\n\t\tbreak;\n\n\tcase PARAM_ISP_AWB:\n\t\t__hw_param_copy(&par->isp.awb, &cfg->isp.awb);\n\t\tbreak;\n\n\tcase PARAM_ISP_IMAGE_EFFECT:\n\t\t__hw_param_copy(&par->isp.effect, &cfg->isp.effect);\n\t\tbreak;\n\n\tcase PARAM_ISP_ISO:\n\t\t__hw_param_copy(&par->isp.iso, &cfg->isp.iso);\n\t\tbreak;\n\n\tcase PARAM_ISP_ADJUST:\n\t\t__hw_param_copy(&par->isp.adjust, &cfg->isp.adjust);\n\t\tbreak;\n\n\tcase PARAM_ISP_METERING:\n\t\t__hw_param_copy(&par->isp.metering, &cfg->isp.metering);\n\t\tbreak;\n\n\tcase PARAM_ISP_AFC:\n\t\t__hw_param_copy(&par->isp.afc, &cfg->isp.afc);\n\t\tbreak;\n\n\tcase PARAM_ISP_OTF_OUTPUT:\n\t\t__hw_param_copy(&par->isp.otf_output, &cfg->isp.otf_output);\n\t\tbreak;\n\n\tcase PARAM_ISP_DMA1_OUTPUT:\n\t\t__hw_param_copy(&par->isp.dma1_output, &cfg->isp.dma1_output);\n\t\tbreak;\n\n\tcase PARAM_ISP_DMA2_OUTPUT:\n\t\t__hw_param_copy(&par->isp.dma2_output, &cfg->isp.dma2_output);\n\t\tbreak;\n\n\tcase PARAM_DRC_CONTROL:\n\t\t__hw_param_copy(&par->drc.control, &cfg->drc.control);\n\t\tbreak;\n\n\tcase PARAM_DRC_OTF_INPUT:\n\t\t__hw_param_copy(&par->drc.otf_input, &cfg->drc.otf_input);\n\t\tbreak;\n\n\tcase PARAM_DRC_DMA_INPUT:\n\t\t__hw_param_copy(&par->drc.dma_input, &cfg->drc.dma_input);\n\t\tbreak;\n\n\tcase PARAM_DRC_OTF_OUTPUT:\n\t\t__hw_param_copy(&par->drc.otf_output, &cfg->drc.otf_output);\n\t\tbreak;\n\n\tcase PARAM_FD_CONTROL:\n\t\t__hw_param_copy(&par->fd.control, &cfg->fd.control);\n\t\tbreak;\n\n\tcase PARAM_FD_OTF_INPUT:\n\t\t__hw_param_copy(&par->fd.otf_input, &cfg->fd.otf_input);\n\t\tbreak;\n\n\tcase PARAM_FD_DMA_INPUT:\n\t\t__hw_param_copy(&par->fd.dma_input, &cfg->fd.dma_input);\n\t\tbreak;\n\n\tcase PARAM_FD_CONFIG:\n\t\t__hw_param_copy(&par->fd.config, &cfg->fd.config);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nunsigned int __get_pending_param_count(struct fimc_is *is)\n{\n\tstruct chain_config *config = &is->config[is->config_index];\n\tunsigned long flags;\n\tunsigned int count;\n\n\tspin_lock_irqsave(&is->slock, flags);\n\tcount = hweight32(config->p_region_index[0]);\n\tcount += hweight32(config->p_region_index[1]);\n\tspin_unlock_irqrestore(&is->slock, flags);\n\n\treturn count;\n}\n\nint __is_hw_update_params(struct fimc_is *is)\n{\n\tunsigned long *p_index;\n\tint i, id, ret = 0;\n\n\tid = is->config_index;\n\tp_index = &is->config[id].p_region_index[0];\n\n\tif (test_bit(PARAM_GLOBAL_SHOTMODE, p_index))\n\t\t__fimc_is_hw_update_param_global_shotmode(is);\n\n\tif (test_bit(PARAM_SENSOR_FRAME_RATE, p_index))\n\t\t__fimc_is_hw_update_param_sensor_framerate(is);\n\n\tfor (i = PARAM_ISP_CONTROL; i < PARAM_DRC_CONTROL; i++) {\n\t\tif (test_bit(i, p_index))\n\t\t\tret = __fimc_is_hw_update_param(is, i);\n\t}\n\n\tfor (i = PARAM_DRC_CONTROL; i < PARAM_SCALERC_CONTROL; i++) {\n\t\tif (test_bit(i, p_index))\n\t\t\tret = __fimc_is_hw_update_param(is, i);\n\t}\n\n\tfor (i = PARAM_FD_CONTROL; i <= PARAM_FD_CONFIG; i++) {\n\t\tif (test_bit(i, p_index))\n\t\t\tret = __fimc_is_hw_update_param(is, i);\n\t}\n\n\treturn ret;\n}\n\nvoid __is_get_frame_size(struct fimc_is *is, struct v4l2_mbus_framefmt *mf)\n{\n\tstruct isp_param *isp;\n\n\tisp = &is->config[is->config_index].isp;\n\tmf->width = isp->otf_input.width;\n\tmf->height = isp->otf_input.height;\n}\n\nvoid __is_set_frame_size(struct fimc_is *is, struct v4l2_mbus_framefmt *mf)\n{\n\tunsigned int index = is->config_index;\n\tstruct isp_param *isp;\n\tstruct drc_param *drc;\n\tstruct fd_param *fd;\n\n\tisp = &is->config[index].isp;\n\tdrc = &is->config[index].drc;\n\tfd = &is->config[index].fd;\n\n\t \n\tisp->otf_input.width = mf->width;\n\tisp->otf_input.height = mf->height;\n\tisp->otf_output.width = mf->width;\n\tisp->otf_output.height = mf->height;\n\t \n\tdrc->otf_input.width = mf->width;\n\tdrc->otf_input.height = mf->height;\n\tdrc->otf_output.width = mf->width;\n\tdrc->otf_output.height = mf->height;\n\t \n\tfd->otf_input.width = mf->width;\n\tfd->otf_input.height = mf->height;\n\n\tif (test_bit(PARAM_ISP_OTF_INPUT,\n\t\t      &is->config[index].p_region_index[0]))\n\t\treturn;\n\n\t \n\tfimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);\n\tfimc_is_set_param_bit(is, PARAM_ISP_OTF_OUTPUT);\n\tfimc_is_set_param_bit(is, PARAM_DRC_OTF_INPUT);\n\tfimc_is_set_param_bit(is, PARAM_DRC_OTF_OUTPUT);\n\tfimc_is_set_param_bit(is, PARAM_FD_OTF_INPUT);\n}\n\nint fimc_is_hw_get_sensor_max_framerate(struct fimc_is *is)\n{\n\tswitch (is->sensor->drvdata->id) {\n\tcase FIMC_IS_SENSOR_ID_S5K6A3:\n\t\treturn 30;\n\tdefault:\n\t\treturn 15;\n\t}\n}\n\nvoid __is_set_sensor(struct fimc_is *is, int fps)\n{\n\tunsigned int index = is->config_index;\n\tstruct sensor_param *sensor;\n\tstruct isp_param *isp;\n\n\tsensor = &is->config[index].sensor;\n\tisp = &is->config[index].isp;\n\n\tif (fps == 0) {\n\t\tsensor->frame_rate.frame_rate =\n\t\t\t\tfimc_is_hw_get_sensor_max_framerate(is);\n\t\tisp->otf_input.frametime_min = 0;\n\t\tisp->otf_input.frametime_max = 66666;\n\t} else {\n\t\tsensor->frame_rate.frame_rate = fps;\n\t\tisp->otf_input.frametime_min = 0;\n\t\tisp->otf_input.frametime_max = (u32)1000000 / fps;\n\t}\n\n\tfimc_is_set_param_bit(is, PARAM_SENSOR_FRAME_RATE);\n\tfimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);\n}\n\nstatic void __maybe_unused __is_set_init_isp_aa(struct fimc_is *is)\n{\n\tstruct isp_param *isp;\n\n\tisp = &is->config[is->config_index].isp;\n\n\tisp->aa.cmd = ISP_AA_COMMAND_START;\n\tisp->aa.target = ISP_AA_TARGET_AF | ISP_AA_TARGET_AE |\n\t\t\t ISP_AA_TARGET_AWB;\n\tisp->aa.mode = 0;\n\tisp->aa.scene = 0;\n\tisp->aa.sleep = 0;\n\tisp->aa.face = 0;\n\tisp->aa.touch_x = 0;\n\tisp->aa.touch_y = 0;\n\tisp->aa.manual_af_setting = 0;\n\tisp->aa.err = ISP_AF_ERROR_NONE;\n\n\tfimc_is_set_param_bit(is, PARAM_ISP_AA);\n}\n\nvoid __is_set_isp_flash(struct fimc_is *is, u32 cmd, u32 redeye)\n{\n\tunsigned int index = is->config_index;\n\tstruct isp_param *isp = &is->config[index].isp;\n\n\tisp->flash.cmd = cmd;\n\tisp->flash.redeye = redeye;\n\tisp->flash.err = ISP_FLASH_ERROR_NONE;\n\n\tfimc_is_set_param_bit(is, PARAM_ISP_FLASH);\n}\n\nvoid __is_set_isp_awb(struct fimc_is *is, u32 cmd, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct isp_param *isp;\n\n\tisp = &is->config[index].isp;\n\n\tisp->awb.cmd = cmd;\n\tisp->awb.illumination = val;\n\tisp->awb.err = ISP_AWB_ERROR_NONE;\n\n\tfimc_is_set_param_bit(is, PARAM_ISP_AWB);\n}\n\nvoid __is_set_isp_effect(struct fimc_is *is, u32 cmd)\n{\n\tunsigned int index = is->config_index;\n\tstruct isp_param *isp;\n\n\tisp = &is->config[index].isp;\n\n\tisp->effect.cmd = cmd;\n\tisp->effect.err = ISP_IMAGE_EFFECT_ERROR_NONE;\n\n\tfimc_is_set_param_bit(is, PARAM_ISP_IMAGE_EFFECT);\n}\n\nvoid __is_set_isp_iso(struct fimc_is *is, u32 cmd, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct isp_param *isp;\n\n\tisp = &is->config[index].isp;\n\n\tisp->iso.cmd = cmd;\n\tisp->iso.value = val;\n\tisp->iso.err = ISP_ISO_ERROR_NONE;\n\n\tfimc_is_set_param_bit(is, PARAM_ISP_ISO);\n}\n\nvoid __is_set_isp_adjust(struct fimc_is *is, u32 cmd, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tunsigned long *p_index;\n\tstruct isp_param *isp;\n\n\tp_index = &is->config[index].p_region_index[0];\n\tisp = &is->config[index].isp;\n\n\tswitch (cmd) {\n\tcase ISP_ADJUST_COMMAND_MANUAL_CONTRAST:\n\t\tisp->adjust.contrast = val;\n\t\tbreak;\n\tcase ISP_ADJUST_COMMAND_MANUAL_SATURATION:\n\t\tisp->adjust.saturation = val;\n\t\tbreak;\n\tcase ISP_ADJUST_COMMAND_MANUAL_SHARPNESS:\n\t\tisp->adjust.sharpness = val;\n\t\tbreak;\n\tcase ISP_ADJUST_COMMAND_MANUAL_EXPOSURE:\n\t\tisp->adjust.exposure = val;\n\t\tbreak;\n\tcase ISP_ADJUST_COMMAND_MANUAL_BRIGHTNESS:\n\t\tisp->adjust.brightness = val;\n\t\tbreak;\n\tcase ISP_ADJUST_COMMAND_MANUAL_HUE:\n\t\tisp->adjust.hue = val;\n\t\tbreak;\n\tcase ISP_ADJUST_COMMAND_AUTO:\n\t\tisp->adjust.contrast = 0;\n\t\tisp->adjust.saturation = 0;\n\t\tisp->adjust.sharpness = 0;\n\t\tisp->adjust.exposure = 0;\n\t\tisp->adjust.brightness = 0;\n\t\tisp->adjust.hue = 0;\n\t\tbreak;\n\t}\n\n\tif (!test_bit(PARAM_ISP_ADJUST, p_index)) {\n\t\tisp->adjust.cmd = cmd;\n\t\tisp->adjust.err = ISP_ADJUST_ERROR_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_ISP_ADJUST);\n\t} else {\n\t\tisp->adjust.cmd |= cmd;\n\t}\n}\n\nvoid __is_set_isp_metering(struct fimc_is *is, u32 id, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct isp_param *isp;\n\tunsigned long *p_index;\n\n\tp_index = &is->config[index].p_region_index[0];\n\tisp = &is->config[index].isp;\n\n\tswitch (id) {\n\tcase IS_METERING_CONFIG_CMD:\n\t\tisp->metering.cmd = val;\n\t\tbreak;\n\tcase IS_METERING_CONFIG_WIN_POS_X:\n\t\tisp->metering.win_pos_x = val;\n\t\tbreak;\n\tcase IS_METERING_CONFIG_WIN_POS_Y:\n\t\tisp->metering.win_pos_y = val;\n\t\tbreak;\n\tcase IS_METERING_CONFIG_WIN_WIDTH:\n\t\tisp->metering.win_width = val;\n\t\tbreak;\n\tcase IS_METERING_CONFIG_WIN_HEIGHT:\n\t\tisp->metering.win_height = val;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (!test_bit(PARAM_ISP_METERING, p_index)) {\n\t\tisp->metering.err = ISP_METERING_ERROR_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_ISP_METERING);\n\t}\n}\n\nvoid __is_set_isp_afc(struct fimc_is *is, u32 cmd, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct isp_param *isp;\n\n\tisp = &is->config[index].isp;\n\n\tisp->afc.cmd = cmd;\n\tisp->afc.manual = val;\n\tisp->afc.err = ISP_AFC_ERROR_NONE;\n\n\tfimc_is_set_param_bit(is, PARAM_ISP_AFC);\n}\n\nvoid __is_set_drc_control(struct fimc_is *is, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct drc_param *drc;\n\n\tdrc = &is->config[index].drc;\n\n\tdrc->control.bypass = val;\n\n\tfimc_is_set_param_bit(is, PARAM_DRC_CONTROL);\n}\n\nvoid __is_set_fd_control(struct fimc_is *is, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct fd_param *fd;\n\tunsigned long *p_index;\n\n\tp_index = &is->config[index].p_region_index[1];\n\tfd = &is->config[index].fd;\n\n\tfd->control.cmd = val;\n\n\tif (!test_bit((PARAM_FD_CONFIG - 32), p_index))\n\t\tfimc_is_set_param_bit(is, PARAM_FD_CONTROL);\n}\n\nvoid __is_set_fd_config_maxface(struct fimc_is *is, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct fd_param *fd;\n\tunsigned long *p_index;\n\n\tp_index = &is->config[index].p_region_index[1];\n\tfd = &is->config[index].fd;\n\n\tfd->config.max_number = val;\n\n\tif (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {\n\t\tfd->config.cmd = FD_CONFIG_COMMAND_MAXIMUM_NUMBER;\n\t\tfd->config.err = ERROR_FD_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_FD_CONFIG);\n\t} else {\n\t\tfd->config.cmd |= FD_CONFIG_COMMAND_MAXIMUM_NUMBER;\n\t}\n}\n\nvoid __is_set_fd_config_rollangle(struct fimc_is *is, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct fd_param *fd;\n\tunsigned long *p_index;\n\n\tp_index = &is->config[index].p_region_index[1];\n\tfd = &is->config[index].fd;\n\n\tfd->config.roll_angle = val;\n\n\tif (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {\n\t\tfd->config.cmd = FD_CONFIG_COMMAND_ROLL_ANGLE;\n\t\tfd->config.err = ERROR_FD_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_FD_CONFIG);\n\t} else {\n\t\tfd->config.cmd |= FD_CONFIG_COMMAND_ROLL_ANGLE;\n\t}\n}\n\nvoid __is_set_fd_config_yawangle(struct fimc_is *is, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct fd_param *fd;\n\tunsigned long *p_index;\n\n\tp_index = &is->config[index].p_region_index[1];\n\tfd = &is->config[index].fd;\n\n\tfd->config.yaw_angle = val;\n\n\tif (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {\n\t\tfd->config.cmd = FD_CONFIG_COMMAND_YAW_ANGLE;\n\t\tfd->config.err = ERROR_FD_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_FD_CONFIG);\n\t} else {\n\t\tfd->config.cmd |= FD_CONFIG_COMMAND_YAW_ANGLE;\n\t}\n}\n\nvoid __is_set_fd_config_smilemode(struct fimc_is *is, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct fd_param *fd;\n\tunsigned long *p_index;\n\n\tp_index = &is->config[index].p_region_index[1];\n\tfd = &is->config[index].fd;\n\n\tfd->config.smile_mode = val;\n\n\tif (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {\n\t\tfd->config.cmd = FD_CONFIG_COMMAND_SMILE_MODE;\n\t\tfd->config.err = ERROR_FD_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_FD_CONFIG);\n\t} else {\n\t\tfd->config.cmd |= FD_CONFIG_COMMAND_SMILE_MODE;\n\t}\n}\n\nvoid __is_set_fd_config_blinkmode(struct fimc_is *is, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct fd_param *fd;\n\tunsigned long *p_index;\n\n\tp_index = &is->config[index].p_region_index[1];\n\tfd = &is->config[index].fd;\n\n\tfd->config.blink_mode = val;\n\n\tif (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {\n\t\tfd->config.cmd = FD_CONFIG_COMMAND_BLINK_MODE;\n\t\tfd->config.err = ERROR_FD_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_FD_CONFIG);\n\t} else {\n\t\tfd->config.cmd |= FD_CONFIG_COMMAND_BLINK_MODE;\n\t}\n}\n\nvoid __is_set_fd_config_eyedetect(struct fimc_is *is, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct fd_param *fd;\n\tunsigned long *p_index;\n\n\tp_index = &is->config[index].p_region_index[1];\n\tfd = &is->config[index].fd;\n\n\tfd->config.eye_detect = val;\n\n\tif (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {\n\t\tfd->config.cmd = FD_CONFIG_COMMAND_EYES_DETECT;\n\t\tfd->config.err = ERROR_FD_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_FD_CONFIG);\n\t} else {\n\t\tfd->config.cmd |= FD_CONFIG_COMMAND_EYES_DETECT;\n\t}\n}\n\nvoid __is_set_fd_config_mouthdetect(struct fimc_is *is, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct fd_param *fd;\n\tunsigned long *p_index;\n\n\tp_index = &is->config[index].p_region_index[1];\n\tfd = &is->config[index].fd;\n\n\tfd->config.mouth_detect = val;\n\n\tif (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {\n\t\tfd->config.cmd = FD_CONFIG_COMMAND_MOUTH_DETECT;\n\t\tfd->config.err = ERROR_FD_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_FD_CONFIG);\n\t} else {\n\t\tfd->config.cmd |= FD_CONFIG_COMMAND_MOUTH_DETECT;\n\t}\n}\n\nvoid __is_set_fd_config_orientation(struct fimc_is *is, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct fd_param *fd;\n\tunsigned long *p_index;\n\n\tp_index = &is->config[index].p_region_index[1];\n\tfd = &is->config[index].fd;\n\n\tfd->config.orientation = val;\n\n\tif (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {\n\t\tfd->config.cmd = FD_CONFIG_COMMAND_ORIENTATION;\n\t\tfd->config.err = ERROR_FD_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_FD_CONFIG);\n\t} else {\n\t\tfd->config.cmd |= FD_CONFIG_COMMAND_ORIENTATION;\n\t}\n}\n\nvoid __is_set_fd_config_orientation_val(struct fimc_is *is, u32 val)\n{\n\tunsigned int index = is->config_index;\n\tstruct fd_param *fd;\n\tunsigned long *p_index;\n\n\tp_index = &is->config[index].p_region_index[1];\n\tfd = &is->config[index].fd;\n\n\tfd->config.orientation_value = val;\n\n\tif (!test_bit((PARAM_FD_CONFIG - 32), p_index)) {\n\t\tfd->config.cmd = FD_CONFIG_COMMAND_ORIENTATION_VALUE;\n\t\tfd->config.err = ERROR_FD_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_FD_CONFIG);\n\t} else {\n\t\tfd->config.cmd |= FD_CONFIG_COMMAND_ORIENTATION_VALUE;\n\t}\n}\n\nvoid fimc_is_set_initial_params(struct fimc_is *is)\n{\n\tstruct global_param *global;\n\tstruct isp_param *isp;\n\tstruct drc_param *drc;\n\tstruct fd_param *fd;\n\tunsigned long *p_index;\n\tunsigned int index;\n\n\tindex = is->config_index;\n\tglobal = &is->config[index].global;\n\tisp = &is->config[index].isp;\n\tdrc = &is->config[index].drc;\n\tfd = &is->config[index].fd;\n\tp_index = &is->config[index].p_region_index[0];\n\n\t \n\tglobal->shotmode.cmd = 1;\n\tfimc_is_set_param_bit(is, PARAM_GLOBAL_SHOTMODE);\n\n\t \n\tisp->control.cmd = CONTROL_COMMAND_START;\n\tisp->control.bypass = CONTROL_BYPASS_DISABLE;\n\tisp->control.err = CONTROL_ERROR_NONE;\n\tfimc_is_set_param_bit(is, PARAM_ISP_CONTROL);\n\n\tisp->otf_input.cmd = OTF_INPUT_COMMAND_ENABLE;\n\tif (!test_bit(PARAM_ISP_OTF_INPUT, p_index)) {\n\t\tisp->otf_input.width = DEFAULT_PREVIEW_STILL_WIDTH;\n\t\tisp->otf_input.height = DEFAULT_PREVIEW_STILL_HEIGHT;\n\t\tfimc_is_set_param_bit(is, PARAM_ISP_OTF_INPUT);\n\t}\n\tif (is->sensor->test_pattern)\n\t\tisp->otf_input.format = OTF_INPUT_FORMAT_STRGEN_COLORBAR_BAYER;\n\telse\n\t\tisp->otf_input.format = OTF_INPUT_FORMAT_BAYER;\n\tisp->otf_input.bitwidth = 10;\n\tisp->otf_input.order = OTF_INPUT_ORDER_BAYER_GR_BG;\n\tisp->otf_input.crop_offset_x = 0;\n\tisp->otf_input.crop_offset_y = 0;\n\tisp->otf_input.err = OTF_INPUT_ERROR_NONE;\n\n\tisp->dma1_input.cmd = DMA_INPUT_COMMAND_DISABLE;\n\tisp->dma1_input.width = 0;\n\tisp->dma1_input.height = 0;\n\tisp->dma1_input.format = 0;\n\tisp->dma1_input.bitwidth = 0;\n\tisp->dma1_input.plane = 0;\n\tisp->dma1_input.order = 0;\n\tisp->dma1_input.buffer_number = 0;\n\tisp->dma1_input.width = 0;\n\tisp->dma1_input.err = DMA_INPUT_ERROR_NONE;\n\tfimc_is_set_param_bit(is, PARAM_ISP_DMA1_INPUT);\n\n\tisp->dma2_input.cmd = DMA_INPUT_COMMAND_DISABLE;\n\tisp->dma2_input.width = 0;\n\tisp->dma2_input.height = 0;\n\tisp->dma2_input.format = 0;\n\tisp->dma2_input.bitwidth = 0;\n\tisp->dma2_input.plane = 0;\n\tisp->dma2_input.order = 0;\n\tisp->dma2_input.buffer_number = 0;\n\tisp->dma2_input.width = 0;\n\tisp->dma2_input.err = DMA_INPUT_ERROR_NONE;\n\tfimc_is_set_param_bit(is, PARAM_ISP_DMA2_INPUT);\n\n\tisp->aa.cmd = ISP_AA_COMMAND_START;\n\tisp->aa.target = ISP_AA_TARGET_AE | ISP_AA_TARGET_AWB;\n\tfimc_is_set_param_bit(is, PARAM_ISP_AA);\n\n\tif (!test_bit(PARAM_ISP_FLASH, p_index))\n\t\t__is_set_isp_flash(is, ISP_FLASH_COMMAND_DISABLE,\n\t\t\t\t\t\tISP_FLASH_REDEYE_DISABLE);\n\n\tif (!test_bit(PARAM_ISP_AWB, p_index))\n\t\t__is_set_isp_awb(is, ISP_AWB_COMMAND_AUTO, 0);\n\n\tif (!test_bit(PARAM_ISP_IMAGE_EFFECT, p_index))\n\t\t__is_set_isp_effect(is, ISP_IMAGE_EFFECT_DISABLE);\n\n\tif (!test_bit(PARAM_ISP_ISO, p_index))\n\t\t__is_set_isp_iso(is, ISP_ISO_COMMAND_AUTO, 0);\n\n\tif (!test_bit(PARAM_ISP_ADJUST, p_index)) {\n\t\t__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_CONTRAST, 0);\n\t\t__is_set_isp_adjust(is,\n\t\t\t\tISP_ADJUST_COMMAND_MANUAL_SATURATION, 0);\n\t\t__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_SHARPNESS, 0);\n\t\t__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_EXPOSURE, 0);\n\t\t__is_set_isp_adjust(is,\n\t\t\t\tISP_ADJUST_COMMAND_MANUAL_BRIGHTNESS, 0);\n\t\t__is_set_isp_adjust(is, ISP_ADJUST_COMMAND_MANUAL_HUE, 0);\n\t}\n\n\tif (!test_bit(PARAM_ISP_METERING, p_index)) {\n\t\t__is_set_isp_metering(is, 0, ISP_METERING_COMMAND_CENTER);\n\t\t__is_set_isp_metering(is, 1, 0);\n\t\t__is_set_isp_metering(is, 2, 0);\n\t\t__is_set_isp_metering(is, 3, 0);\n\t\t__is_set_isp_metering(is, 4, 0);\n\t}\n\n\tif (!test_bit(PARAM_ISP_AFC, p_index))\n\t\t__is_set_isp_afc(is, ISP_AFC_COMMAND_AUTO, 0);\n\n\tisp->otf_output.cmd = OTF_OUTPUT_COMMAND_ENABLE;\n\tif (!test_bit(PARAM_ISP_OTF_OUTPUT, p_index)) {\n\t\tisp->otf_output.width = DEFAULT_PREVIEW_STILL_WIDTH;\n\t\tisp->otf_output.height = DEFAULT_PREVIEW_STILL_HEIGHT;\n\t\tfimc_is_set_param_bit(is, PARAM_ISP_OTF_OUTPUT);\n\t}\n\tisp->otf_output.format = OTF_OUTPUT_FORMAT_YUV444;\n\tisp->otf_output.bitwidth = 12;\n\tisp->otf_output.order = 0;\n\tisp->otf_output.err = OTF_OUTPUT_ERROR_NONE;\n\n\tif (!test_bit(PARAM_ISP_DMA1_OUTPUT, p_index)) {\n\t\tisp->dma1_output.cmd = DMA_OUTPUT_COMMAND_DISABLE;\n\t\tisp->dma1_output.width = 0;\n\t\tisp->dma1_output.height = 0;\n\t\tisp->dma1_output.format = 0;\n\t\tisp->dma1_output.bitwidth = 0;\n\t\tisp->dma1_output.plane = 0;\n\t\tisp->dma1_output.order = 0;\n\t\tisp->dma1_output.buffer_number = 0;\n\t\tisp->dma1_output.buffer_address = 0;\n\t\tisp->dma1_output.notify_dma_done = 0;\n\t\tisp->dma1_output.dma_out_mask = 0;\n\t\tisp->dma1_output.err = DMA_OUTPUT_ERROR_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_ISP_DMA1_OUTPUT);\n\t}\n\n\tif (!test_bit(PARAM_ISP_DMA2_OUTPUT, p_index)) {\n\t\tisp->dma2_output.cmd = DMA_OUTPUT_COMMAND_DISABLE;\n\t\tisp->dma2_output.width = 0;\n\t\tisp->dma2_output.height = 0;\n\t\tisp->dma2_output.format = 0;\n\t\tisp->dma2_output.bitwidth = 0;\n\t\tisp->dma2_output.plane = 0;\n\t\tisp->dma2_output.order = 0;\n\t\tisp->dma2_output.buffer_number = 0;\n\t\tisp->dma2_output.buffer_address = 0;\n\t\tisp->dma2_output.notify_dma_done = 0;\n\t\tisp->dma2_output.dma_out_mask = 0;\n\t\tisp->dma2_output.err = DMA_OUTPUT_ERROR_NONE;\n\t\tfimc_is_set_param_bit(is, PARAM_ISP_DMA2_OUTPUT);\n\t}\n\n\t \n\tif (!test_bit(PARAM_SENSOR_FRAME_RATE, p_index)) {\n\t\tif (is->config_index == 0)\n\t\t\t__is_set_sensor(is, 0);\n\t}\n\n\t \n\tdrc->control.cmd = CONTROL_COMMAND_START;\n\t__is_set_drc_control(is, CONTROL_BYPASS_ENABLE);\n\n\tdrc->otf_input.cmd = OTF_INPUT_COMMAND_ENABLE;\n\tif (!test_bit(PARAM_DRC_OTF_INPUT, p_index)) {\n\t\tdrc->otf_input.width = DEFAULT_PREVIEW_STILL_WIDTH;\n\t\tdrc->otf_input.height = DEFAULT_PREVIEW_STILL_HEIGHT;\n\t\tfimc_is_set_param_bit(is, PARAM_DRC_OTF_INPUT);\n\t}\n\tdrc->otf_input.format = OTF_INPUT_FORMAT_YUV444;\n\tdrc->otf_input.bitwidth = 12;\n\tdrc->otf_input.order = 0;\n\tdrc->otf_input.err = OTF_INPUT_ERROR_NONE;\n\n\tdrc->dma_input.cmd = DMA_INPUT_COMMAND_DISABLE;\n\tdrc->dma_input.width = 0;\n\tdrc->dma_input.height = 0;\n\tdrc->dma_input.format = 0;\n\tdrc->dma_input.bitwidth = 0;\n\tdrc->dma_input.plane = 0;\n\tdrc->dma_input.order = 0;\n\tdrc->dma_input.buffer_number = 0;\n\tdrc->dma_input.width = 0;\n\tdrc->dma_input.err = DMA_INPUT_ERROR_NONE;\n\tfimc_is_set_param_bit(is, PARAM_DRC_DMA_INPUT);\n\n\tdrc->otf_output.cmd = OTF_OUTPUT_COMMAND_ENABLE;\n\tif (!test_bit(PARAM_DRC_OTF_OUTPUT, p_index)) {\n\t\tdrc->otf_output.width = DEFAULT_PREVIEW_STILL_WIDTH;\n\t\tdrc->otf_output.height = DEFAULT_PREVIEW_STILL_HEIGHT;\n\t\tfimc_is_set_param_bit(is, PARAM_DRC_OTF_OUTPUT);\n\t}\n\tdrc->otf_output.format = OTF_OUTPUT_FORMAT_YUV444;\n\tdrc->otf_output.bitwidth = 8;\n\tdrc->otf_output.order = 0;\n\tdrc->otf_output.err = OTF_OUTPUT_ERROR_NONE;\n\n\t \n\t__is_set_fd_control(is, CONTROL_COMMAND_STOP);\n\tfd->control.bypass = CONTROL_BYPASS_DISABLE;\n\n\tfd->otf_input.cmd = OTF_INPUT_COMMAND_ENABLE;\n\tif (!test_bit(PARAM_FD_OTF_INPUT, p_index)) {\n\t\tfd->otf_input.width = DEFAULT_PREVIEW_STILL_WIDTH;\n\t\tfd->otf_input.height = DEFAULT_PREVIEW_STILL_HEIGHT;\n\t\tfimc_is_set_param_bit(is, PARAM_FD_OTF_INPUT);\n\t}\n\n\tfd->otf_input.format = OTF_INPUT_FORMAT_YUV444;\n\tfd->otf_input.bitwidth = 8;\n\tfd->otf_input.order = 0;\n\tfd->otf_input.err = OTF_INPUT_ERROR_NONE;\n\n\tfd->dma_input.cmd = DMA_INPUT_COMMAND_DISABLE;\n\tfd->dma_input.width = 0;\n\tfd->dma_input.height = 0;\n\tfd->dma_input.format = 0;\n\tfd->dma_input.bitwidth = 0;\n\tfd->dma_input.plane = 0;\n\tfd->dma_input.order = 0;\n\tfd->dma_input.buffer_number = 0;\n\tfd->dma_input.width = 0;\n\tfd->dma_input.err = DMA_INPUT_ERROR_NONE;\n\tfimc_is_set_param_bit(is, PARAM_FD_DMA_INPUT);\n\n\t__is_set_fd_config_maxface(is, 5);\n\t__is_set_fd_config_rollangle(is, FD_CONFIG_ROLL_ANGLE_FULL);\n\t__is_set_fd_config_yawangle(is, FD_CONFIG_YAW_ANGLE_45_90);\n\t__is_set_fd_config_smilemode(is, FD_CONFIG_SMILE_MODE_DISABLE);\n\t__is_set_fd_config_blinkmode(is, FD_CONFIG_BLINK_MODE_DISABLE);\n\t__is_set_fd_config_eyedetect(is, FD_CONFIG_EYES_DETECT_ENABLE);\n\t__is_set_fd_config_mouthdetect(is, FD_CONFIG_MOUTH_DETECT_DISABLE);\n\t__is_set_fd_config_orientation(is, FD_CONFIG_ORIENTATION_DISABLE);\n\t__is_set_fd_config_orientation_val(is, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}