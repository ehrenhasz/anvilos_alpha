{
  "module_name": "fimc-core.c",
  "hash_id": "80e263031b021920311dcf67b34f98289ef05b6babe867fc4e842467aea34980",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/bug.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/list.h>\n#include <linux/mfd/syscon.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"fimc-core.h\"\n#include \"fimc-reg.h\"\n#include \"media-dev.h\"\n\nstatic char *fimc_clocks[MAX_FIMC_CLOCKS] = {\n\t\"sclk_fimc\", \"fimc\"\n};\n\nstatic struct fimc_fmt fimc_formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_RGB565,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 1,\n\t\t.flags\t\t= FMT_FLAGS_M2M,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_BGR666,\n\t\t.depth\t\t= { 32 },\n\t\t.color\t\t= FIMC_FMT_RGB666,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 1,\n\t\t.flags\t\t= FMT_FLAGS_M2M,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_BGR32,\n\t\t.depth\t\t= { 32 },\n\t\t.color\t\t= FIMC_FMT_RGB888,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 1,\n\t\t.flags\t\t= FMT_FLAGS_M2M | FMT_HAS_ALPHA,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB555,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_RGB555,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 1,\n\t\t.flags\t\t= FMT_FLAGS_M2M_OUT | FMT_HAS_ALPHA,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB444,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_RGB444,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 1,\n\t\t.flags\t\t= FMT_FLAGS_M2M_OUT | FMT_HAS_ALPHA,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUV10_1X30,\n\t\t.flags\t\t= FMT_FLAGS_WRITEBACK,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_YCBYCR422,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.flags\t\t= FMT_FLAGS_M2M | FMT_FLAGS_CAM,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_UYVY,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_CBYCRY422,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.flags\t\t= FMT_FLAGS_M2M | FMT_FLAGS_CAM,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_VYUY,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_CRYCBY422,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_VYUY8_2X8,\n\t\t.flags\t\t= FMT_FLAGS_M2M | FMT_FLAGS_CAM,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YVYU,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_YCRYCB422,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YVYU8_2X8,\n\t\t.flags\t\t= FMT_FLAGS_M2M | FMT_FLAGS_CAM,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV422P,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_YCBYCR422,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 3,\n\t\t.flags\t\t= FMT_FLAGS_M2M,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV16,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_YCBYCR422,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 2,\n\t\t.flags\t\t= FMT_FLAGS_M2M,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV61,\n\t\t.depth\t\t= { 16 },\n\t\t.color\t\t= FIMC_FMT_YCRYCB422,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 2,\n\t\t.flags\t\t= FMT_FLAGS_M2M,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV420,\n\t\t.depth\t\t= { 12 },\n\t\t.color\t\t= FIMC_FMT_YCBCR420,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 3,\n\t\t.flags\t\t= FMT_FLAGS_M2M,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12,\n\t\t.depth\t\t= { 12 },\n\t\t.color\t\t= FIMC_FMT_YCBCR420,\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 2,\n\t\t.flags\t\t= FMT_FLAGS_M2M,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12M,\n\t\t.color\t\t= FIMC_FMT_YCBCR420,\n\t\t.depth\t\t= { 8, 4 },\n\t\t.memplanes\t= 2,\n\t\t.colplanes\t= 2,\n\t\t.flags\t\t= FMT_FLAGS_M2M,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV420M,\n\t\t.color\t\t= FIMC_FMT_YCBCR420,\n\t\t.depth\t\t= { 8, 2, 2 },\n\t\t.memplanes\t= 3,\n\t\t.colplanes\t= 3,\n\t\t.flags\t\t= FMT_FLAGS_M2M,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12MT,\n\t\t.color\t\t= FIMC_FMT_YCBCR420,\n\t\t.depth\t\t= { 8, 4 },\n\t\t.memplanes\t= 2,\n\t\t.colplanes\t= 2,\n\t\t.flags\t\t= FMT_FLAGS_M2M,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_JPEG,\n\t\t.color\t\t= FIMC_FMT_JPEG,\n\t\t.depth\t\t= { 8 },\n\t\t.memplanes\t= 1,\n\t\t.colplanes\t= 1,\n\t\t.mbus_code\t= MEDIA_BUS_FMT_JPEG_1X8,\n\t\t.flags\t\t= FMT_FLAGS_CAM | FMT_FLAGS_COMPRESSED,\n\t}, {\n\t\t.fourcc\t\t= V4L2_PIX_FMT_S5C_UYVY_JPG,\n\t\t.color\t\t= FIMC_FMT_YUYV_JPEG,\n\t\t.depth\t\t= { 8 },\n\t\t.memplanes\t= 2,\n\t\t.colplanes\t= 1,\n\t\t.mdataplanes\t= 0x2,  \n\t\t.mbus_code\t= MEDIA_BUS_FMT_S5C_UYVY_JPEG_1X8,\n\t\t.flags\t\t= FMT_FLAGS_CAM | FMT_FLAGS_COMPRESSED,\n\t},\n};\n\nstruct fimc_fmt *fimc_get_format(unsigned int index)\n{\n\tif (index >= ARRAY_SIZE(fimc_formats))\n\t\treturn NULL;\n\n\treturn &fimc_formats[index];\n}\n\nint fimc_check_scaler_ratio(struct fimc_ctx *ctx, int sw, int sh,\n\t\t\t    int dw, int dh, int rotation)\n{\n\tif (rotation == 90 || rotation == 270)\n\t\tswap(dw, dh);\n\n\tif (!ctx->scaler.enabled)\n\t\treturn (sw == dw && sh == dh) ? 0 : -EINVAL;\n\n\tif ((sw >= SCALER_MAX_HRATIO * dw) || (sh >= SCALER_MAX_VRATIO * dh))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int fimc_get_scaler_factor(u32 src, u32 tar, u32 *ratio, u32 *shift)\n{\n\tu32 sh = 6;\n\n\tif (src >= 64 * tar)\n\t\treturn -EINVAL;\n\n\twhile (sh--) {\n\t\tu32 tmp = 1 << sh;\n\t\tif (src >= tar * tmp) {\n\t\t\t*shift = sh;\n\t\t\t*ratio = tmp;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*shift = 0;\n\t*ratio = 1;\n\treturn 0;\n}\n\nint fimc_set_scaler_info(struct fimc_ctx *ctx)\n{\n\tconst struct fimc_variant *variant = ctx->fimc_dev->variant;\n\tstruct device *dev = &ctx->fimc_dev->pdev->dev;\n\tstruct fimc_scaler *sc = &ctx->scaler;\n\tstruct fimc_frame *s_frame = &ctx->s_frame;\n\tstruct fimc_frame *d_frame = &ctx->d_frame;\n\tint tx, ty, sx, sy;\n\tint ret;\n\n\tif (ctx->rotation == 90 || ctx->rotation == 270) {\n\t\tty = d_frame->width;\n\t\ttx = d_frame->height;\n\t} else {\n\t\ttx = d_frame->width;\n\t\tty = d_frame->height;\n\t}\n\tif (tx <= 0 || ty <= 0) {\n\t\tdev_err(dev, \"Invalid target size: %dx%d\\n\", tx, ty);\n\t\treturn -EINVAL;\n\t}\n\n\tsx = s_frame->width;\n\tsy = s_frame->height;\n\tif (sx <= 0 || sy <= 0) {\n\t\tdev_err(dev, \"Invalid source size: %dx%d\\n\", sx, sy);\n\t\treturn -EINVAL;\n\t}\n\tsc->real_width = sx;\n\tsc->real_height = sy;\n\n\tret = fimc_get_scaler_factor(sx, tx, &sc->pre_hratio, &sc->hfactor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fimc_get_scaler_factor(sy, ty,  &sc->pre_vratio, &sc->vfactor);\n\tif (ret)\n\t\treturn ret;\n\n\tsc->pre_dst_width = sx / sc->pre_hratio;\n\tsc->pre_dst_height = sy / sc->pre_vratio;\n\n\tif (variant->has_mainscaler_ext) {\n\t\tsc->main_hratio = (sx << 14) / (tx << sc->hfactor);\n\t\tsc->main_vratio = (sy << 14) / (ty << sc->vfactor);\n\t} else {\n\t\tsc->main_hratio = (sx << 8) / (tx << sc->hfactor);\n\t\tsc->main_vratio = (sy << 8) / (ty << sc->vfactor);\n\n\t}\n\n\tsc->scaleup_h = (tx >= sx) ? 1 : 0;\n\tsc->scaleup_v = (ty >= sy) ? 1 : 0;\n\n\t \n\tif (s_frame->fmt->color == d_frame->fmt->color\n\t\t&& s_frame->width == d_frame->width\n\t\t&& s_frame->height == d_frame->height)\n\t\tsc->copy_mode = 1;\n\telse\n\t\tsc->copy_mode = 0;\n\n\treturn 0;\n}\n\nstatic irqreturn_t fimc_irq_handler(int irq, void *priv)\n{\n\tstruct fimc_dev *fimc = priv;\n\tstruct fimc_ctx *ctx;\n\n\tfimc_hw_clear_irq(fimc);\n\n\tspin_lock(&fimc->slock);\n\n\tif (test_and_clear_bit(ST_M2M_PEND, &fimc->state)) {\n\t\tif (test_and_clear_bit(ST_M2M_SUSPENDING, &fimc->state)) {\n\t\t\tset_bit(ST_M2M_SUSPENDED, &fimc->state);\n\t\t\twake_up(&fimc->irq_queue);\n\t\t\tgoto out;\n\t\t}\n\t\tctx = v4l2_m2m_get_curr_priv(fimc->m2m.m2m_dev);\n\t\tif (ctx != NULL) {\n\t\t\tspin_unlock(&fimc->slock);\n\t\t\tfimc_m2m_job_finish(ctx, VB2_BUF_STATE_DONE);\n\n\t\t\tif (ctx->state & FIMC_CTX_SHUT) {\n\t\t\t\tctx->state &= ~FIMC_CTX_SHUT;\n\t\t\t\twake_up(&fimc->irq_queue);\n\t\t\t}\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t} else if (test_bit(ST_CAPT_PEND, &fimc->state)) {\n\t\tint last_buf = test_bit(ST_CAPT_JPEG, &fimc->state) &&\n\t\t\t\tfimc->vid_cap.reqbufs_count == 1;\n\t\tfimc_capture_irq_handler(fimc, !last_buf);\n\t}\nout:\n\tspin_unlock(&fimc->slock);\n\treturn IRQ_HANDLED;\n}\n\n \nint fimc_prepare_addr(struct fimc_ctx *ctx, struct vb2_buffer *vb,\n\t\t      struct fimc_frame *frame, struct fimc_addr *addr)\n{\n\tint ret = 0;\n\tu32 pix_size;\n\n\tif (vb == NULL || frame == NULL)\n\t\treturn -EINVAL;\n\n\tpix_size = frame->width * frame->height;\n\n\tdbg(\"memplanes= %d, colplanes= %d, pix_size= %d\",\n\t\tframe->fmt->memplanes, frame->fmt->colplanes, pix_size);\n\n\taddr->y = vb2_dma_contig_plane_dma_addr(vb, 0);\n\n\tif (frame->fmt->memplanes == 1) {\n\t\tswitch (frame->fmt->colplanes) {\n\t\tcase 1:\n\t\t\taddr->cb = 0;\n\t\t\taddr->cr = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\taddr->cb = (u32)(addr->y + pix_size);\n\t\t\taddr->cr = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\taddr->cb = (u32)(addr->y + pix_size);\n\t\t\t \n\t\t\tif (FIMC_FMT_YCBCR420 == frame->fmt->color)\n\t\t\t\taddr->cr = (u32)(addr->cb + (pix_size >> 2));\n\t\t\telse  \n\t\t\t\taddr->cr = (u32)(addr->cb + (pix_size >> 1));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!frame->fmt->mdataplanes) {\n\t\tif (frame->fmt->memplanes >= 2)\n\t\t\taddr->cb = vb2_dma_contig_plane_dma_addr(vb, 1);\n\n\t\tif (frame->fmt->memplanes == 3)\n\t\t\taddr->cr = vb2_dma_contig_plane_dma_addr(vb, 2);\n\t}\n\n\tdbg(\"DMA ADDR: y= 0x%X  cb= 0x%X cr= 0x%X ret= %d\",\n\t    addr->y, addr->cb, addr->cr, ret);\n\n\treturn ret;\n}\n\n \nvoid fimc_set_yuv_order(struct fimc_ctx *ctx)\n{\n\t \n\tctx->in_order_2p = FIMC_REG_CIOCTRL_ORDER422_2P_LSB_CRCB;\n\tctx->out_order_2p = FIMC_REG_CIOCTRL_ORDER422_2P_LSB_CRCB;\n\n\t \n\tswitch (ctx->s_frame.fmt->color) {\n\tcase FIMC_FMT_YCRYCB422:\n\t\tctx->in_order_1p = FIMC_REG_MSCTRL_ORDER422_YCRYCB;\n\t\tbreak;\n\tcase FIMC_FMT_CBYCRY422:\n\t\tctx->in_order_1p = FIMC_REG_MSCTRL_ORDER422_CBYCRY;\n\t\tbreak;\n\tcase FIMC_FMT_CRYCBY422:\n\t\tctx->in_order_1p = FIMC_REG_MSCTRL_ORDER422_CRYCBY;\n\t\tbreak;\n\tcase FIMC_FMT_YCBYCR422:\n\tdefault:\n\t\tctx->in_order_1p = FIMC_REG_MSCTRL_ORDER422_YCBYCR;\n\t\tbreak;\n\t}\n\tdbg(\"ctx->in_order_1p= %d\", ctx->in_order_1p);\n\n\tswitch (ctx->d_frame.fmt->color) {\n\tcase FIMC_FMT_YCRYCB422:\n\t\tctx->out_order_1p = FIMC_REG_CIOCTRL_ORDER422_YCRYCB;\n\t\tbreak;\n\tcase FIMC_FMT_CBYCRY422:\n\t\tctx->out_order_1p = FIMC_REG_CIOCTRL_ORDER422_CBYCRY;\n\t\tbreak;\n\tcase FIMC_FMT_CRYCBY422:\n\t\tctx->out_order_1p = FIMC_REG_CIOCTRL_ORDER422_CRYCBY;\n\t\tbreak;\n\tcase FIMC_FMT_YCBYCR422:\n\tdefault:\n\t\tctx->out_order_1p = FIMC_REG_CIOCTRL_ORDER422_YCBYCR;\n\t\tbreak;\n\t}\n\tdbg(\"ctx->out_order_1p= %d\", ctx->out_order_1p);\n}\n\nvoid fimc_prepare_dma_offset(struct fimc_ctx *ctx, struct fimc_frame *f)\n{\n\tbool pix_hoff = ctx->fimc_dev->drv_data->dma_pix_hoff;\n\tu32 i, depth = 0;\n\n\tfor (i = 0; i < f->fmt->memplanes; i++)\n\t\tdepth += f->fmt->depth[i];\n\n\tf->dma_offset.y_h = f->offs_h;\n\tif (!pix_hoff)\n\t\tf->dma_offset.y_h *= (depth >> 3);\n\n\tf->dma_offset.y_v = f->offs_v;\n\n\tf->dma_offset.cb_h = f->offs_h;\n\tf->dma_offset.cb_v = f->offs_v;\n\n\tf->dma_offset.cr_h = f->offs_h;\n\tf->dma_offset.cr_v = f->offs_v;\n\n\tif (!pix_hoff) {\n\t\tif (f->fmt->colplanes == 3) {\n\t\t\tf->dma_offset.cb_h >>= 1;\n\t\t\tf->dma_offset.cr_h >>= 1;\n\t\t}\n\t\tif (f->fmt->color == FIMC_FMT_YCBCR420) {\n\t\t\tf->dma_offset.cb_v >>= 1;\n\t\t\tf->dma_offset.cr_v >>= 1;\n\t\t}\n\t}\n\n\tdbg(\"in_offset: color= %d, y_h= %d, y_v= %d\",\n\t    f->fmt->color, f->dma_offset.y_h, f->dma_offset.y_v);\n}\n\nstatic int fimc_set_color_effect(struct fimc_ctx *ctx, enum v4l2_colorfx colorfx)\n{\n\tstruct fimc_effect *effect = &ctx->effect;\n\n\tswitch (colorfx) {\n\tcase V4L2_COLORFX_NONE:\n\t\teffect->type = FIMC_REG_CIIMGEFF_FIN_BYPASS;\n\t\tbreak;\n\tcase V4L2_COLORFX_BW:\n\t\teffect->type = FIMC_REG_CIIMGEFF_FIN_ARBITRARY;\n\t\teffect->pat_cb = 128;\n\t\teffect->pat_cr = 128;\n\t\tbreak;\n\tcase V4L2_COLORFX_SEPIA:\n\t\teffect->type = FIMC_REG_CIIMGEFF_FIN_ARBITRARY;\n\t\teffect->pat_cb = 115;\n\t\teffect->pat_cr = 145;\n\t\tbreak;\n\tcase V4L2_COLORFX_NEGATIVE:\n\t\teffect->type = FIMC_REG_CIIMGEFF_FIN_NEGATIVE;\n\t\tbreak;\n\tcase V4L2_COLORFX_EMBOSS:\n\t\teffect->type = FIMC_REG_CIIMGEFF_FIN_EMBOSSING;\n\t\tbreak;\n\tcase V4L2_COLORFX_ART_FREEZE:\n\t\teffect->type = FIMC_REG_CIIMGEFF_FIN_ARTFREEZE;\n\t\tbreak;\n\tcase V4L2_COLORFX_SILHOUETTE:\n\t\teffect->type = FIMC_REG_CIIMGEFF_FIN_SILHOUETTE;\n\t\tbreak;\n\tcase V4L2_COLORFX_SET_CBCR:\n\t\teffect->type = FIMC_REG_CIIMGEFF_FIN_ARBITRARY;\n\t\teffect->pat_cb = ctx->ctrls.colorfx_cbcr->val >> 8;\n\t\teffect->pat_cr = ctx->ctrls.colorfx_cbcr->val & 0xff;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n#define ctrl_to_ctx(__ctrl) \\\n\tcontainer_of((__ctrl)->handler, struct fimc_ctx, ctrls.handler)\n\nstatic int __fimc_s_ctrl(struct fimc_ctx *ctx, struct v4l2_ctrl *ctrl)\n{\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\tconst struct fimc_variant *variant = fimc->variant;\n\tint ret = 0;\n\n\tif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tctx->hflip = ctrl->val;\n\t\tbreak;\n\n\tcase V4L2_CID_VFLIP:\n\t\tctx->vflip = ctrl->val;\n\t\tbreak;\n\n\tcase V4L2_CID_ROTATE:\n\t\tif (fimc_capture_pending(fimc)) {\n\t\t\tret = fimc_check_scaler_ratio(ctx, ctx->s_frame.width,\n\t\t\t\t\tctx->s_frame.height, ctx->d_frame.width,\n\t\t\t\t\tctx->d_frame.height, ctrl->val);\n\t\t\tif (ret)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((ctrl->val == 90 || ctrl->val == 270) &&\n\t\t    !variant->has_out_rot)\n\t\t\treturn -EINVAL;\n\n\t\tctx->rotation = ctrl->val;\n\t\tbreak;\n\n\tcase V4L2_CID_ALPHA_COMPONENT:\n\t\tctx->d_frame.alpha = ctrl->val;\n\t\tbreak;\n\n\tcase V4L2_CID_COLORFX:\n\t\tret = fimc_set_color_effect(ctx, ctrl->val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tctx->state |= FIMC_PARAMS;\n\tset_bit(ST_CAPT_APPLY_CFG, &fimc->state);\n\treturn 0;\n}\n\nstatic int fimc_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct fimc_ctx *ctx = ctrl_to_ctx(ctrl);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&ctx->fimc_dev->slock, flags);\n\tret = __fimc_s_ctrl(ctx, ctrl);\n\tspin_unlock_irqrestore(&ctx->fimc_dev->slock, flags);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops fimc_ctrl_ops = {\n\t.s_ctrl = fimc_s_ctrl,\n};\n\nint fimc_ctrls_create(struct fimc_ctx *ctx)\n{\n\tunsigned int max_alpha = fimc_get_alpha_mask(ctx->d_frame.fmt);\n\tstruct fimc_ctrls *ctrls = &ctx->ctrls;\n\tstruct v4l2_ctrl_handler *handler = &ctrls->handler;\n\n\tif (ctx->ctrls.ready)\n\t\treturn 0;\n\n\tv4l2_ctrl_handler_init(handler, 6);\n\n\tctrls->rotate = v4l2_ctrl_new_std(handler, &fimc_ctrl_ops,\n\t\t\t\t\tV4L2_CID_ROTATE, 0, 270, 90, 0);\n\tctrls->hflip = v4l2_ctrl_new_std(handler, &fimc_ctrl_ops,\n\t\t\t\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tctrls->vflip = v4l2_ctrl_new_std(handler, &fimc_ctrl_ops,\n\t\t\t\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tif (ctx->fimc_dev->drv_data->alpha_color)\n\t\tctrls->alpha = v4l2_ctrl_new_std(handler, &fimc_ctrl_ops,\n\t\t\t\t\tV4L2_CID_ALPHA_COMPONENT,\n\t\t\t\t\t0, max_alpha, 1, 0);\n\telse\n\t\tctrls->alpha = NULL;\n\n\tctrls->colorfx = v4l2_ctrl_new_std_menu(handler, &fimc_ctrl_ops,\n\t\t\t\tV4L2_CID_COLORFX, V4L2_COLORFX_SET_CBCR,\n\t\t\t\t~0x983f, V4L2_COLORFX_NONE);\n\n\tctrls->colorfx_cbcr = v4l2_ctrl_new_std(handler, &fimc_ctrl_ops,\n\t\t\t\tV4L2_CID_COLORFX_CBCR, 0, 0xffff, 1, 0);\n\n\tctx->effect.type = FIMC_REG_CIIMGEFF_FIN_BYPASS;\n\n\tif (!handler->error) {\n\t\tv4l2_ctrl_cluster(2, &ctrls->colorfx);\n\t\tctrls->ready = true;\n\t}\n\n\treturn handler->error;\n}\n\nvoid fimc_ctrls_delete(struct fimc_ctx *ctx)\n{\n\tstruct fimc_ctrls *ctrls = &ctx->ctrls;\n\n\tif (ctrls->ready) {\n\t\tv4l2_ctrl_handler_free(&ctrls->handler);\n\t\tctrls->ready = false;\n\t\tctrls->alpha = NULL;\n\t}\n}\n\nvoid fimc_ctrls_activate(struct fimc_ctx *ctx, bool active)\n{\n\tunsigned int has_alpha = ctx->d_frame.fmt->flags & FMT_HAS_ALPHA;\n\tstruct fimc_ctrls *ctrls = &ctx->ctrls;\n\n\tif (!ctrls->ready)\n\t\treturn;\n\n\tmutex_lock(ctrls->handler.lock);\n\tv4l2_ctrl_activate(ctrls->rotate, active);\n\tv4l2_ctrl_activate(ctrls->hflip, active);\n\tv4l2_ctrl_activate(ctrls->vflip, active);\n\tv4l2_ctrl_activate(ctrls->colorfx, active);\n\tif (ctrls->alpha)\n\t\tv4l2_ctrl_activate(ctrls->alpha, active && has_alpha);\n\n\tif (active) {\n\t\tfimc_set_color_effect(ctx, ctrls->colorfx->cur.val);\n\t\tctx->rotation = ctrls->rotate->val;\n\t\tctx->hflip    = ctrls->hflip->val;\n\t\tctx->vflip    = ctrls->vflip->val;\n\t} else {\n\t\tctx->effect.type = FIMC_REG_CIIMGEFF_FIN_BYPASS;\n\t\tctx->rotation = 0;\n\t\tctx->hflip    = 0;\n\t\tctx->vflip    = 0;\n\t}\n\tmutex_unlock(ctrls->handler.lock);\n}\n\n \nvoid fimc_alpha_ctrl_update(struct fimc_ctx *ctx)\n{\n\tstruct fimc_dev *fimc = ctx->fimc_dev;\n\tstruct v4l2_ctrl *ctrl = ctx->ctrls.alpha;\n\n\tif (ctrl == NULL || !fimc->drv_data->alpha_color)\n\t\treturn;\n\n\tv4l2_ctrl_lock(ctrl);\n\tctrl->maximum = fimc_get_alpha_mask(ctx->d_frame.fmt);\n\n\tif (ctrl->cur.val > ctrl->maximum)\n\t\tctrl->cur.val = ctrl->maximum;\n\n\tv4l2_ctrl_unlock(ctrl);\n}\n\nvoid __fimc_get_format(struct fimc_frame *frame, struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pixm = &f->fmt.pix_mp;\n\tint i;\n\n\tpixm->width = frame->o_width;\n\tpixm->height = frame->o_height;\n\tpixm->field = V4L2_FIELD_NONE;\n\tpixm->pixelformat = frame->fmt->fourcc;\n\tpixm->colorspace = V4L2_COLORSPACE_JPEG;\n\tpixm->num_planes = frame->fmt->memplanes;\n\n\tfor (i = 0; i < pixm->num_planes; ++i) {\n\t\tpixm->plane_fmt[i].bytesperline = frame->bytesperline[i];\n\t\tpixm->plane_fmt[i].sizeimage = frame->payload[i];\n\t}\n}\n\n \nvoid fimc_adjust_mplane_format(struct fimc_fmt *fmt, u32 width, u32 height,\n\t\t\t       struct v4l2_pix_format_mplane *pix)\n{\n\tu32 bytesperline = 0;\n\tint i;\n\n\tpix->colorspace\t= V4L2_COLORSPACE_JPEG;\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->num_planes = fmt->memplanes;\n\tpix->pixelformat = fmt->fourcc;\n\tpix->height = height;\n\tpix->width = width;\n\n\tfor (i = 0; i < pix->num_planes; ++i) {\n\t\tstruct v4l2_plane_pix_format *plane_fmt = &pix->plane_fmt[i];\n\t\tu32 bpl = plane_fmt->bytesperline;\n\t\tu32 sizeimage;\n\n\t\tif (fmt->colplanes > 1 && (bpl == 0 || bpl < pix->width))\n\t\t\tbpl = pix->width;  \n\n\t\tif (fmt->colplanes == 1 &&  \n\t\t    (bpl == 0 || ((bpl * 8) / fmt->depth[i]) < pix->width))\n\t\t\tbpl = (pix->width * fmt->depth[0]) / 8;\n\t\t \n\t\tif (i == 0)\n\t\t\tbytesperline = bpl;\n\t\telse if (i == 1 && fmt->memplanes == 3)\n\t\t\tbytesperline /= 2;\n\n\t\tplane_fmt->bytesperline = bytesperline;\n\t\tsizeimage = pix->width * pix->height * fmt->depth[i] / 8;\n\n\t\t \n\t\tif (tiled_fmt(fmt)) {\n\t\t\t \n\t\t\tu32 row_size = plane_fmt->bytesperline * 32;\n\n\t\t\tsizeimage = roundup(sizeimage, row_size);\n\t\t}\n\n\t\tplane_fmt->sizeimage = max(sizeimage, plane_fmt->sizeimage);\n\t}\n}\n\n \nstruct fimc_fmt *fimc_find_format(const u32 *pixelformat, const u32 *mbus_code,\n\t\t\t\t  unsigned int mask, int index)\n{\n\tstruct fimc_fmt *fmt, *def_fmt = NULL;\n\tunsigned int i;\n\tint id = 0;\n\n\tif (index >= (int)ARRAY_SIZE(fimc_formats))\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(fimc_formats); ++i) {\n\t\tfmt = &fimc_formats[i];\n\t\tif (!(fmt->flags & mask))\n\t\t\tcontinue;\n\t\tif (pixelformat && fmt->fourcc == *pixelformat)\n\t\t\treturn fmt;\n\t\tif (mbus_code && fmt->mbus_code == *mbus_code)\n\t\t\treturn fmt;\n\t\tif (index == id)\n\t\t\tdef_fmt = fmt;\n\t\tid++;\n\t}\n\treturn def_fmt;\n}\n\nstatic void fimc_clk_put(struct fimc_dev *fimc)\n{\n\tint i;\n\tfor (i = 0; i < MAX_FIMC_CLOCKS; i++) {\n\t\tif (IS_ERR(fimc->clock[i]))\n\t\t\tcontinue;\n\t\tclk_unprepare(fimc->clock[i]);\n\t\tclk_put(fimc->clock[i]);\n\t\tfimc->clock[i] = ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic int fimc_clk_get(struct fimc_dev *fimc)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < MAX_FIMC_CLOCKS; i++)\n\t\tfimc->clock[i] = ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < MAX_FIMC_CLOCKS; i++) {\n\t\tfimc->clock[i] = clk_get(&fimc->pdev->dev, fimc_clocks[i]);\n\t\tif (IS_ERR(fimc->clock[i])) {\n\t\t\tret = PTR_ERR(fimc->clock[i]);\n\t\t\tgoto err;\n\t\t}\n\t\tret = clk_prepare(fimc->clock[i]);\n\t\tif (ret < 0) {\n\t\t\tclk_put(fimc->clock[i]);\n\t\t\tfimc->clock[i] = ERR_PTR(-EINVAL);\n\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 0;\nerr:\n\tfimc_clk_put(fimc);\n\tdev_err(&fimc->pdev->dev, \"failed to get clock: %s\\n\",\n\t\tfimc_clocks[i]);\n\treturn -ENXIO;\n}\n\n#ifdef CONFIG_PM\nstatic int fimc_m2m_suspend(struct fimc_dev *fimc)\n{\n\tunsigned long flags;\n\tint timeout;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\tif (!fimc_m2m_pending(fimc)) {\n\t\tspin_unlock_irqrestore(&fimc->slock, flags);\n\t\treturn 0;\n\t}\n\tclear_bit(ST_M2M_SUSPENDED, &fimc->state);\n\tset_bit(ST_M2M_SUSPENDING, &fimc->state);\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\ttimeout = wait_event_timeout(fimc->irq_queue,\n\t\t\t     test_bit(ST_M2M_SUSPENDED, &fimc->state),\n\t\t\t     FIMC_SHUTDOWN_TIMEOUT);\n\n\tclear_bit(ST_M2M_SUSPENDING, &fimc->state);\n\treturn timeout == 0 ? -EAGAIN : 0;\n}\n\nstatic int fimc_m2m_resume(struct fimc_dev *fimc)\n{\n\tstruct fimc_ctx *ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fimc->slock, flags);\n\t \n\tctx = fimc->m2m.ctx;\n\tfimc->m2m.ctx = NULL;\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\tif (test_and_clear_bit(ST_M2M_SUSPENDED, &fimc->state))\n\t\tfimc_m2m_job_finish(ctx, VB2_BUF_STATE_ERROR);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct of_device_id fimc_of_match[];\n\nstatic int fimc_parse_dt(struct fimc_dev *fimc, u32 *clk_freq)\n{\n\tstruct device *dev = &fimc->pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tconst struct of_device_id *of_id;\n\tstruct fimc_variant *v;\n\tstruct fimc_pix_limit *lim;\n\tu32 args[FIMC_PIX_LIMITS_MAX];\n\tint ret;\n\n\tif (of_property_read_bool(node, \"samsung,lcd-wb\"))\n\t\treturn -ENODEV;\n\n\tv = devm_kzalloc(dev, sizeof(*v) + sizeof(*lim), GFP_KERNEL);\n\tif (!v)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_node(fimc_of_match, node);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\tfimc->drv_data = of_id->data;\n\tret = of_property_read_u32_array(node, \"samsung,pix-limits\",\n\t\t\t\t\t args, FIMC_PIX_LIMITS_MAX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlim = (struct fimc_pix_limit *)&v[1];\n\n\tlim->scaler_en_w = args[0];\n\tlim->scaler_dis_w = args[1];\n\tlim->out_rot_en_w = args[2];\n\tlim->out_rot_dis_w = args[3];\n\tv->pix_limit = lim;\n\n\tret = of_property_read_u32_array(node, \"samsung,min-pix-sizes\",\n\t\t\t\t\t\t\t\targs, 2);\n\tv->min_inp_pixsize = ret ? FIMC_DEF_MIN_SIZE : args[0];\n\tv->min_out_pixsize = ret ? FIMC_DEF_MIN_SIZE : args[1];\n\tret = of_property_read_u32_array(node, \"samsung,min-pix-alignment\",\n\t\t\t\t\t\t\t\targs, 2);\n\tv->min_vsize_align = ret ? FIMC_DEF_HEIGHT_ALIGN : args[0];\n\tv->hor_offs_align = ret ? FIMC_DEF_HOR_OFFS_ALIGN : args[1];\n\n\tret = of_property_read_u32(node, \"samsung,rotators\", &args[1]);\n\tv->has_inp_rot = ret ? 1 : args[1] & 0x01;\n\tv->has_out_rot = ret ? 1 : args[1] & 0x10;\n\tv->has_mainscaler_ext = of_property_read_bool(node,\n\t\t\t\t\t\"samsung,mainscaler-ext\");\n\n\tv->has_isp_wb = of_property_read_bool(node, \"samsung,isp-wb\");\n\tv->has_cam_if = of_property_read_bool(node, \"samsung,cam-if\");\n\tof_property_read_u32(node, \"clock-frequency\", clk_freq);\n\tfimc->id = of_alias_get_id(node, \"fimc\");\n\n\tfimc->variant = v;\n\treturn 0;\n}\n\nstatic int fimc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tu32 lclk_freq = 0;\n\tstruct fimc_dev *fimc;\n\tint ret = 0;\n\tint irq;\n\n\tfimc = devm_kzalloc(dev, sizeof(*fimc), GFP_KERNEL);\n\tif (!fimc)\n\t\treturn -ENOMEM;\n\n\tfimc->pdev = pdev;\n\n\tif (dev->of_node) {\n\t\tret = fimc_parse_dt(fimc, &lclk_freq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tfimc->drv_data = fimc_get_drvdata(pdev);\n\t\tfimc->id = pdev->id;\n\t}\n\tif (!fimc->drv_data || fimc->id >= fimc->drv_data->num_entities ||\n\t    fimc->id < 0) {\n\t\tdev_err(dev, \"Invalid driver data or device id (%d)\\n\",\n\t\t\tfimc->id);\n\t\treturn -EINVAL;\n\t}\n\tif (!dev->of_node)\n\t\tfimc->variant = fimc->drv_data->variant[fimc->id];\n\n\tinit_waitqueue_head(&fimc->irq_queue);\n\tspin_lock_init(&fimc->slock);\n\tmutex_init(&fimc->lock);\n\n\tif (fimc->variant->has_isp_wb) {\n\t\tfimc->sysreg = fimc_get_sysreg_regmap(dev->of_node);\n\t\tif (IS_ERR(fimc->sysreg))\n\t\t\treturn PTR_ERR(fimc->sysreg);\n\t}\n\n\tfimc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(fimc->regs))\n\t\treturn PTR_ERR(fimc->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = fimc_clk_get(fimc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (lclk_freq == 0)\n\t\tlclk_freq = fimc->drv_data->lclk_frequency;\n\n\tret = clk_set_rate(fimc->clock[CLK_BUS], lclk_freq);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_enable(fimc->clock[CLK_BUS]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, irq, fimc_irq_handler,\n\t\t\t       0, dev_name(dev), fimc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to install irq (%d)\\n\", ret);\n\t\tgoto err_sclk;\n\t}\n\n\tret = fimc_initialize_capture_subdev(fimc);\n\tif (ret < 0)\n\t\tgoto err_sclk;\n\n\tplatform_set_drvdata(pdev, fimc);\n\tpm_runtime_enable(dev);\n\n\tif (!pm_runtime_enabled(dev)) {\n\t\tret = clk_enable(fimc->clock[CLK_GATE]);\n\t\tif (ret < 0)\n\t\t\tgoto err_sd;\n\t}\n\n\tvb2_dma_contig_set_max_seg_size(dev, DMA_BIT_MASK(32));\n\n\tdev_dbg(dev, \"FIMC.%d registered successfully\\n\", fimc->id);\n\treturn 0;\n\nerr_sd:\n\tfimc_unregister_capture_subdev(fimc);\nerr_sclk:\n\tclk_disable(fimc->clock[CLK_BUS]);\n\tfimc_clk_put(fimc);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic int fimc_runtime_resume(struct device *dev)\n{\n\tstruct fimc_dev *fimc =\tdev_get_drvdata(dev);\n\n\tdbg(\"fimc%d: state: 0x%lx\", fimc->id, fimc->state);\n\n\t \n\tclk_enable(fimc->clock[CLK_GATE]);\n\tfimc_hw_reset(fimc);\n\n\t \n\tif (fimc_capture_busy(fimc))\n\t\treturn fimc_capture_resume(fimc);\n\n\treturn fimc_m2m_resume(fimc);\n}\n\nstatic int fimc_runtime_suspend(struct device *dev)\n{\n\tstruct fimc_dev *fimc =\tdev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (fimc_capture_busy(fimc))\n\t\tret = fimc_capture_suspend(fimc);\n\telse\n\t\tret = fimc_m2m_suspend(fimc);\n\tif (!ret)\n\t\tclk_disable(fimc->clock[CLK_GATE]);\n\n\tdbg(\"fimc%d: state: 0x%lx\", fimc->id, fimc->state);\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int fimc_resume(struct device *dev)\n{\n\tstruct fimc_dev *fimc =\tdev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tdbg(\"fimc%d: state: 0x%lx\", fimc->id, fimc->state);\n\n\t \n\tspin_lock_irqsave(&fimc->slock, flags);\n\tif (!test_and_clear_bit(ST_LPM, &fimc->state) ||\n\t    (!fimc_m2m_active(fimc) && !fimc_capture_busy(fimc))) {\n\t\tspin_unlock_irqrestore(&fimc->slock, flags);\n\t\treturn 0;\n\t}\n\tfimc_hw_reset(fimc);\n\tspin_unlock_irqrestore(&fimc->slock, flags);\n\n\tif (fimc_capture_busy(fimc))\n\t\treturn fimc_capture_resume(fimc);\n\n\treturn fimc_m2m_resume(fimc);\n}\n\nstatic int fimc_suspend(struct device *dev)\n{\n\tstruct fimc_dev *fimc =\tdev_get_drvdata(dev);\n\n\tdbg(\"fimc%d: state: 0x%lx\", fimc->id, fimc->state);\n\n\tif (test_and_set_bit(ST_LPM, &fimc->state))\n\t\treturn 0;\n\tif (fimc_capture_busy(fimc))\n\t\treturn fimc_capture_suspend(fimc);\n\n\treturn fimc_m2m_suspend(fimc);\n}\n#endif  \n\nstatic void fimc_remove(struct platform_device *pdev)\n{\n\tstruct fimc_dev *fimc = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\tclk_disable(fimc->clock[CLK_GATE]);\n\tpm_runtime_set_suspended(&pdev->dev);\n\n\tfimc_unregister_capture_subdev(fimc);\n\tvb2_dma_contig_clear_max_seg_size(&pdev->dev);\n\n\tclk_disable(fimc->clock[CLK_BUS]);\n\tfimc_clk_put(fimc);\n\n\tdev_info(&pdev->dev, \"driver unloaded\\n\");\n}\n\n \nstatic const struct fimc_drvdata fimc_drvdata_s5pv210 = {\n\t.num_entities\t= 3,\n\t.lclk_frequency\t= 166000000UL,\n\t.out_buf_count\t= 4,\n\t.dma_pix_hoff\t= 1,\n};\n\n \nstatic const struct fimc_drvdata fimc_drvdata_exynos4210 = {\n\t.num_entities\t= 4,\n\t.lclk_frequency = 166000000UL,\n\t.dma_pix_hoff\t= 1,\n\t.cistatus2\t= 1,\n\t.alpha_color\t= 1,\n\t.out_buf_count\t= 32,\n};\n\n \nstatic const struct fimc_drvdata fimc_drvdata_exynos4x12 = {\n\t.num_entities\t= 4,\n\t.lclk_frequency\t= 166000000UL,\n\t.dma_pix_hoff\t= 1,\n\t.cistatus2\t= 1,\n\t.alpha_color\t= 1,\n\t.out_buf_count\t= 32,\n};\n\nstatic const struct of_device_id fimc_of_match[] = {\n\t{\n\t\t.compatible = \"samsung,s5pv210-fimc\",\n\t\t.data = &fimc_drvdata_s5pv210,\n\t}, {\n\t\t.compatible = \"samsung,exynos4210-fimc\",\n\t\t.data = &fimc_drvdata_exynos4210,\n\t}, {\n\t\t.compatible = \"samsung,exynos4212-fimc\",\n\t\t.data = &fimc_drvdata_exynos4x12,\n\t},\n\t{   },\n};\n\nstatic const struct dev_pm_ops fimc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(fimc_suspend, fimc_resume)\n\tSET_RUNTIME_PM_OPS(fimc_runtime_suspend, fimc_runtime_resume, NULL)\n};\n\nstatic struct platform_driver fimc_driver = {\n\t.probe\t\t= fimc_probe,\n\t.remove_new\t= fimc_remove,\n\t.driver = {\n\t\t.of_match_table = fimc_of_match,\n\t\t.name\t\t= FIMC_DRIVER_NAME,\n\t\t.pm\t\t= &fimc_pm_ops,\n\t}\n};\n\nint __init fimc_register_driver(void)\n{\n\treturn platform_driver_register(&fimc_driver);\n}\n\nvoid fimc_unregister_driver(void)\n{\n\tplatform_driver_unregister(&fimc_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}