{
  "module_name": "fimc-is-regs.c",
  "hash_id": "1f4e49a18677ab1a8cb9de1fad95757043746e94d3eaa9eaa9983fa0169c970c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-is-regs.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n\n#include \"fimc-is.h\"\n#include \"fimc-is-command.h\"\n#include \"fimc-is-regs.h\"\n#include \"fimc-is-sensor.h\"\n\nvoid fimc_is_fw_clear_irq1(struct fimc_is *is, unsigned int nr)\n{\n\tmcuctl_write(1UL << nr, is, MCUCTL_REG_INTCR1);\n}\n\nvoid fimc_is_fw_clear_irq2(struct fimc_is *is)\n{\n\tu32 cfg = mcuctl_read(is, MCUCTL_REG_INTSR2);\n\tmcuctl_write(cfg, is, MCUCTL_REG_INTCR2);\n}\n\nvoid fimc_is_hw_set_intgr0_gd0(struct fimc_is *is)\n{\n\tmcuctl_write(INTGR0_INTGD(0), is, MCUCTL_REG_INTGR0);\n}\n\nint fimc_is_hw_wait_intmsr0_intmsd0(struct fimc_is *is)\n{\n\tunsigned int timeout = 2000;\n\tu32 cfg, status;\n\n\tdo {\n\t\tcfg = mcuctl_read(is, MCUCTL_REG_INTMSR0);\n\t\tstatus = INTMSR0_GET_INTMSD(0, cfg);\n\n\t\tif (--timeout == 0) {\n\t\t\tdev_warn(&is->pdev->dev, \"%s timeout\\n\",\n\t\t\t\t __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(1);\n\t} while (status != 0);\n\n\treturn 0;\n}\n\nint fimc_is_hw_set_param(struct fimc_is *is)\n{\n\tstruct chain_config *config = &is->config[is->config_index];\n\tunsigned int param_count = __get_pending_param_count(is);\n\n\tfimc_is_hw_wait_intmsr0_intmsd0(is);\n\n\tmcuctl_write(HIC_SET_PARAMETER, is, MCUCTL_REG_ISSR(0));\n\tmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(1));\n\tmcuctl_write(is->config_index, is, MCUCTL_REG_ISSR(2));\n\n\tmcuctl_write(param_count, is, MCUCTL_REG_ISSR(3));\n\tmcuctl_write(config->p_region_index[0], is, MCUCTL_REG_ISSR(4));\n\tmcuctl_write(config->p_region_index[1], is, MCUCTL_REG_ISSR(5));\n\n\tfimc_is_hw_set_intgr0_gd0(is);\n\treturn 0;\n}\n\nstatic int __maybe_unused fimc_is_hw_set_tune(struct fimc_is *is)\n{\n\tfimc_is_hw_wait_intmsr0_intmsd0(is);\n\n\tmcuctl_write(HIC_SET_TUNE, is, MCUCTL_REG_ISSR(0));\n\tmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(1));\n\tmcuctl_write(is->h2i_cmd.entry_id, is, MCUCTL_REG_ISSR(2));\n\n\tfimc_is_hw_set_intgr0_gd0(is);\n\treturn 0;\n}\n\n#define FIMC_IS_MAX_PARAMS\t4\n\nint fimc_is_hw_get_params(struct fimc_is *is, unsigned int num_args)\n{\n\tint i;\n\n\tif (num_args > FIMC_IS_MAX_PARAMS)\n\t\treturn -EINVAL;\n\n\tis->i2h_cmd.num_args = num_args;\n\n\tfor (i = 0; i < FIMC_IS_MAX_PARAMS; i++) {\n\t\tif (i < num_args)\n\t\t\tis->i2h_cmd.args[i] = mcuctl_read(is,\n\t\t\t\t\tMCUCTL_REG_ISSR(12 + i));\n\t\telse\n\t\t\tis->i2h_cmd.args[i] = 0;\n\t}\n\treturn 0;\n}\n\nvoid fimc_is_hw_set_isp_buf_mask(struct fimc_is *is, unsigned int mask)\n{\n\tif (hweight32(mask) == 1) {\n\t\tdev_err(&is->pdev->dev, \"%s(): not enough buffers (mask %#x)\\n\",\n\t\t\t\t\t\t\t__func__, mask);\n\t\treturn;\n\t}\n\n\tif (mcuctl_read(is, MCUCTL_REG_ISSR(23)) != 0)\n\t\tdev_dbg(&is->pdev->dev, \"non-zero DMA buffer mask\\n\");\n\n\tmcuctl_write(mask, is, MCUCTL_REG_ISSR(23));\n}\n\nvoid fimc_is_hw_set_sensor_num(struct fimc_is *is)\n{\n\tpr_debug(\"setting sensor index to: %d\\n\", is->sensor_index);\n\n\tmcuctl_write(IH_REPLY_DONE, is, MCUCTL_REG_ISSR(0));\n\tmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(1));\n\tmcuctl_write(IHC_GET_SENSOR_NUM, is, MCUCTL_REG_ISSR(2));\n\tmcuctl_write(FIMC_IS_SENSORS_NUM, is, MCUCTL_REG_ISSR(3));\n}\n\nvoid fimc_is_hw_close_sensor(struct fimc_is *is, unsigned int index)\n{\n\tif (is->sensor_index != index)\n\t\treturn;\n\n\tfimc_is_hw_wait_intmsr0_intmsd0(is);\n\tmcuctl_write(HIC_CLOSE_SENSOR, is, MCUCTL_REG_ISSR(0));\n\tmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(1));\n\tmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(2));\n\tfimc_is_hw_set_intgr0_gd0(is);\n}\n\nvoid fimc_is_hw_get_setfile_addr(struct fimc_is *is)\n{\n\tfimc_is_hw_wait_intmsr0_intmsd0(is);\n\tmcuctl_write(HIC_GET_SET_FILE_ADDR, is, MCUCTL_REG_ISSR(0));\n\tmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(1));\n\tfimc_is_hw_set_intgr0_gd0(is);\n}\n\nvoid fimc_is_hw_load_setfile(struct fimc_is *is)\n{\n\tfimc_is_hw_wait_intmsr0_intmsd0(is);\n\tmcuctl_write(HIC_LOAD_SET_FILE, is, MCUCTL_REG_ISSR(0));\n\tmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(1));\n\tfimc_is_hw_set_intgr0_gd0(is);\n}\n\nint fimc_is_hw_change_mode(struct fimc_is *is)\n{\n\tstatic const u8 cmd[] = {\n\t\tHIC_PREVIEW_STILL, HIC_PREVIEW_VIDEO,\n\t\tHIC_CAPTURE_STILL, HIC_CAPTURE_VIDEO,\n\t};\n\n\tif (WARN_ON(is->config_index >= ARRAY_SIZE(cmd)))\n\t\treturn -EINVAL;\n\n\tmcuctl_write(cmd[is->config_index], is, MCUCTL_REG_ISSR(0));\n\tmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(1));\n\tmcuctl_write(is->setfile.sub_index, is, MCUCTL_REG_ISSR(2));\n\tfimc_is_hw_set_intgr0_gd0(is);\n\treturn 0;\n}\n\nvoid fimc_is_hw_stream_on(struct fimc_is *is)\n{\n\tfimc_is_hw_wait_intmsr0_intmsd0(is);\n\tmcuctl_write(HIC_STREAM_ON, is, MCUCTL_REG_ISSR(0));\n\tmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(1));\n\tmcuctl_write(0, is, MCUCTL_REG_ISSR(2));\n\tfimc_is_hw_set_intgr0_gd0(is);\n}\n\nvoid fimc_is_hw_stream_off(struct fimc_is *is)\n{\n\tfimc_is_hw_wait_intmsr0_intmsd0(is);\n\tmcuctl_write(HIC_STREAM_OFF, is, MCUCTL_REG_ISSR(0));\n\tmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(1));\n\tfimc_is_hw_set_intgr0_gd0(is);\n}\n\nvoid fimc_is_hw_subip_power_off(struct fimc_is *is)\n{\n\tfimc_is_hw_wait_intmsr0_intmsd0(is);\n\tmcuctl_write(HIC_POWER_DOWN, is, MCUCTL_REG_ISSR(0));\n\tmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(1));\n\tfimc_is_hw_set_intgr0_gd0(is);\n}\n\nint fimc_is_itf_s_param(struct fimc_is *is, bool update)\n{\n\tint ret;\n\n\tif (update)\n\t\t__is_hw_update_params(is);\n\n\tfimc_is_mem_barrier();\n\n\tclear_bit(IS_ST_BLOCK_CMD_CLEARED, &is->state);\n\tfimc_is_hw_set_param(is);\n\tret = fimc_is_wait_event(is, IS_ST_BLOCK_CMD_CLEARED, 1,\n\t\t\t\tFIMC_IS_CONFIG_TIMEOUT);\n\tif (ret < 0)\n\t\tdev_err(&is->pdev->dev, \"%s() timeout\\n\", __func__);\n\n\treturn ret;\n}\n\nint fimc_is_itf_mode_change(struct fimc_is *is)\n{\n\tint ret;\n\n\tclear_bit(IS_ST_CHANGE_MODE, &is->state);\n\tfimc_is_hw_change_mode(is);\n\tret = fimc_is_wait_event(is, IS_ST_CHANGE_MODE, 1,\n\t\t\t\tFIMC_IS_CONFIG_TIMEOUT);\n\tif (ret < 0)\n\t\tdev_err(&is->pdev->dev, \"%s(): mode change (%d) timeout\\n\",\n\t\t\t__func__, is->config_index);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}