{
  "module_name": "fimc-is.c",
  "hash_id": "c105ef4eda0b337158e4d694a0efba297b9cc7837adc974be81120fb62b70a1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/exynos4-is/fimc-is.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"%s:%d \" fmt, __func__, __LINE__\n\n#include <linux/device.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of_graph.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"media-dev.h\"\n#include \"fimc-is.h\"\n#include \"fimc-is-command.h\"\n#include \"fimc-is-errno.h\"\n#include \"fimc-is-i2c.h\"\n#include \"fimc-is-param.h\"\n#include \"fimc-is-regs.h\"\n\n\nstatic char *fimc_is_clocks[ISS_CLKS_MAX] = {\n\t[ISS_CLK_PPMUISPX]\t\t= \"ppmuispx\",\n\t[ISS_CLK_PPMUISPMX]\t\t= \"ppmuispmx\",\n\t[ISS_CLK_LITE0]\t\t\t= \"lite0\",\n\t[ISS_CLK_LITE1]\t\t\t= \"lite1\",\n\t[ISS_CLK_MPLL]\t\t\t= \"mpll\",\n\t[ISS_CLK_ISP]\t\t\t= \"isp\",\n\t[ISS_CLK_DRC]\t\t\t= \"drc\",\n\t[ISS_CLK_FD]\t\t\t= \"fd\",\n\t[ISS_CLK_MCUISP]\t\t= \"mcuisp\",\n\t[ISS_CLK_GICISP]\t\t= \"gicisp\",\n\t[ISS_CLK_PWM_ISP]\t\t= \"pwm_isp\",\n\t[ISS_CLK_MCUCTL_ISP]\t\t= \"mcuctl_isp\",\n\t[ISS_CLK_UART]\t\t\t= \"uart\",\n\t[ISS_CLK_ISP_DIV0]\t\t= \"ispdiv0\",\n\t[ISS_CLK_ISP_DIV1]\t\t= \"ispdiv1\",\n\t[ISS_CLK_MCUISP_DIV0]\t\t= \"mcuispdiv0\",\n\t[ISS_CLK_MCUISP_DIV1]\t\t= \"mcuispdiv1\",\n\t[ISS_CLK_ACLK200]\t\t= \"aclk200\",\n\t[ISS_CLK_ACLK200_DIV]\t\t= \"div_aclk200\",\n\t[ISS_CLK_ACLK400MCUISP]\t\t= \"aclk400mcuisp\",\n\t[ISS_CLK_ACLK400MCUISP_DIV]\t= \"div_aclk400mcuisp\",\n};\n\nstatic void fimc_is_put_clocks(struct fimc_is *is)\n{\n\tint i;\n\n\tfor (i = 0; i < ISS_CLKS_MAX; i++) {\n\t\tif (IS_ERR(is->clocks[i]))\n\t\t\tcontinue;\n\t\tclk_put(is->clocks[i]);\n\t\tis->clocks[i] = ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic int fimc_is_get_clocks(struct fimc_is *is)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ISS_CLKS_MAX; i++)\n\t\tis->clocks[i] = ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < ISS_CLKS_MAX; i++) {\n\t\tis->clocks[i] = clk_get(&is->pdev->dev, fimc_is_clocks[i]);\n\t\tif (IS_ERR(is->clocks[i])) {\n\t\t\tret = PTR_ERR(is->clocks[i]);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tfimc_is_put_clocks(is);\n\tdev_err(&is->pdev->dev, \"failed to get clock: %s\\n\",\n\t\tfimc_is_clocks[i]);\n\treturn ret;\n}\n\nstatic int fimc_is_setup_clocks(struct fimc_is *is)\n{\n\tint ret;\n\n\tret = clk_set_parent(is->clocks[ISS_CLK_ACLK200],\n\t\t\t\t\tis->clocks[ISS_CLK_ACLK200_DIV]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_set_parent(is->clocks[ISS_CLK_ACLK400MCUISP],\n\t\t\t\t\tis->clocks[ISS_CLK_ACLK400MCUISP_DIV]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_set_rate(is->clocks[ISS_CLK_ISP_DIV0], ACLK_AXI_FREQUENCY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_set_rate(is->clocks[ISS_CLK_ISP_DIV1], ACLK_AXI_FREQUENCY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_set_rate(is->clocks[ISS_CLK_MCUISP_DIV0],\n\t\t\t\t\tATCLK_MCUISP_FREQUENCY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn clk_set_rate(is->clocks[ISS_CLK_MCUISP_DIV1],\n\t\t\t\t\tATCLK_MCUISP_FREQUENCY);\n}\n\nstatic int fimc_is_enable_clocks(struct fimc_is *is)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ISS_GATE_CLKS_MAX; i++) {\n\t\tif (IS_ERR(is->clocks[i]))\n\t\t\tcontinue;\n\t\tret = clk_prepare_enable(is->clocks[i]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&is->pdev->dev, \"clock %s enable failed\\n\",\n\t\t\t\tfimc_is_clocks[i]);\n\t\t\tfor (--i; i >= 0; i--)\n\t\t\t\tclk_disable_unprepare(is->clocks[i]);\n\t\t\treturn ret;\n\t\t}\n\t\tpr_debug(\"enabled clock: %s\\n\", fimc_is_clocks[i]);\n\t}\n\treturn 0;\n}\n\nstatic void fimc_is_disable_clocks(struct fimc_is *is)\n{\n\tint i;\n\n\tfor (i = 0; i < ISS_GATE_CLKS_MAX; i++) {\n\t\tif (!IS_ERR(is->clocks[i])) {\n\t\t\tclk_disable_unprepare(is->clocks[i]);\n\t\t\tpr_debug(\"disabled clock: %s\\n\", fimc_is_clocks[i]);\n\t\t}\n\t}\n}\n\nstatic int fimc_is_parse_sensor_config(struct fimc_is *is, unsigned int index,\n\t\t\t\t\t\tstruct device_node *node)\n{\n\tstruct fimc_is_sensor *sensor = &is->sensor[index];\n\tstruct device_node *ep, *port;\n\tu32 tmp = 0;\n\tint ret;\n\n\tsensor->drvdata = fimc_is_sensor_get_drvdata(node);\n\tif (!sensor->drvdata) {\n\t\tdev_err(&is->pdev->dev, \"no driver data found for: %pOF\\n\",\n\t\t\t\t\t\t\t node);\n\t\treturn -EINVAL;\n\t}\n\n\tep = of_graph_get_next_endpoint(node, NULL);\n\tif (!ep)\n\t\treturn -ENXIO;\n\n\tport = of_graph_get_remote_port(ep);\n\tof_node_put(ep);\n\tif (!port)\n\t\treturn -ENXIO;\n\n\t \n\tret = of_property_read_u32(port, \"reg\", &tmp);\n\tif (ret < 0) {\n\t\tdev_err(&is->pdev->dev, \"reg property not found at: %pOF\\n\",\n\t\t\t\t\t\t\t port);\n\t\tof_node_put(port);\n\t\treturn ret;\n\t}\n\n\tof_node_put(port);\n\tsensor->i2c_bus = tmp - FIMC_INPUT_MIPI_CSI2_0;\n\treturn 0;\n}\n\nstatic int fimc_is_register_subdevs(struct fimc_is *is)\n{\n\tstruct device_node *i2c_bus, *child;\n\tint ret, index = 0;\n\n\tret = fimc_isp_subdev_create(&is->isp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor_each_compatible_node(i2c_bus, NULL, FIMC_IS_I2C_COMPATIBLE) {\n\t\tfor_each_available_child_of_node(i2c_bus, child) {\n\t\t\tret = fimc_is_parse_sensor_config(is, index, child);\n\n\t\t\tif (ret < 0 || index >= FIMC_IS_SENSORS_NUM) {\n\t\t\t\tof_node_put(child);\n\t\t\t\tof_node_put(i2c_bus);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int fimc_is_unregister_subdevs(struct fimc_is *is)\n{\n\tfimc_isp_subdev_destroy(&is->isp);\n\treturn 0;\n}\n\nstatic int fimc_is_load_setfile(struct fimc_is *is, char *file_name)\n{\n\tconst struct firmware *fw;\n\tvoid *buf;\n\tint ret;\n\n\tret = request_firmware(&fw, file_name, &is->pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&is->pdev->dev, \"firmware request failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tbuf = is->memory.vaddr + is->setfile.base;\n\tmemcpy(buf, fw->data, fw->size);\n\tfimc_is_mem_barrier();\n\tis->setfile.size = fw->size;\n\n\tpr_debug(\"mem vaddr: %p, setfile buf: %p\\n\", is->memory.vaddr, buf);\n\n\tmemcpy(is->fw.setfile_info,\n\t\tfw->data + fw->size - FIMC_IS_SETFILE_INFO_LEN,\n\t\tFIMC_IS_SETFILE_INFO_LEN - 1);\n\n\tis->fw.setfile_info[FIMC_IS_SETFILE_INFO_LEN - 1] = '\\0';\n\tis->setfile.state = 1;\n\n\tpr_debug(\"FIMC-IS setfile loaded: base: %#x, size: %zu B\\n\",\n\t\t is->setfile.base, fw->size);\n\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nint fimc_is_cpu_set_power(struct fimc_is *is, int on)\n{\n\tunsigned int timeout = FIMC_IS_POWER_ON_TIMEOUT;\n\n\tif (on) {\n\t\t \n\t\tmcuctl_write(0, is, REG_WDT_ISP);\n\n\t\t \n\t\tmcuctl_write(is->memory.addr, is, MCUCTL_REG_BBOAR);\n\n\t\t \n\t\tpmuisp_write(0x18000, is, REG_PMU_ISP_ARM_OPTION);\n\t\tpmuisp_write(0x1, is, REG_PMU_ISP_ARM_CONFIGURATION);\n\t} else {\n\t\t \n\t\tpmuisp_write(0x10000, is, REG_PMU_ISP_ARM_OPTION);\n\t\tpmuisp_write(0x0, is, REG_PMU_ISP_ARM_CONFIGURATION);\n\n\t\twhile (pmuisp_read(is, REG_PMU_ISP_ARM_STATUS) & 1) {\n\t\t\tif (timeout == 0)\n\t\t\t\treturn -ETIME;\n\t\t\ttimeout--;\n\t\t\tudelay(1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint fimc_is_wait_event(struct fimc_is *is, unsigned long bit,\n\t\t       unsigned int state, unsigned int timeout)\n{\n\n\tint ret = wait_event_timeout(is->irq_queue,\n\t\t\t\t     !state ^ test_bit(bit, &is->state),\n\t\t\t\t     timeout);\n\tif (ret == 0) {\n\t\tdev_WARN(&is->pdev->dev, \"%s() timed out\\n\", __func__);\n\t\treturn -ETIME;\n\t}\n\treturn 0;\n}\n\nint fimc_is_start_firmware(struct fimc_is *is)\n{\n\tstruct device *dev = &is->pdev->dev;\n\tint ret;\n\n\tif (is->fw.f_w == NULL) {\n\t\tdev_err(dev, \"firmware is not loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(is->memory.vaddr, is->fw.f_w->data, is->fw.f_w->size);\n\twmb();\n\n\tret = fimc_is_cpu_set_power(is, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = fimc_is_wait_event(is, IS_ST_A5_PWR_ON, 1,\n\t\t\t\t msecs_to_jiffies(FIMC_IS_FW_LOAD_TIMEOUT));\n\tif (ret < 0)\n\t\tdev_err(dev, \"FIMC-IS CPU power on failed\\n\");\n\n\treturn ret;\n}\n\n \nstatic int fimc_is_alloc_cpu_memory(struct fimc_is *is)\n{\n\tstruct device *dev = &is->pdev->dev;\n\n\tis->memory.vaddr = dma_alloc_coherent(dev, FIMC_IS_CPU_MEM_SIZE,\n\t\t\t\t\t      &is->memory.addr, GFP_KERNEL);\n\tif (is->memory.vaddr == NULL)\n\t\treturn -ENOMEM;\n\n\tis->memory.size = FIMC_IS_CPU_MEM_SIZE;\n\n\tdev_info(dev, \"FIMC-IS CPU memory base: %pad\\n\", &is->memory.addr);\n\n\tif (((u32)is->memory.addr) & FIMC_IS_FW_ADDR_MASK) {\n\t\tdev_err(dev, \"invalid firmware memory alignment: %#x\\n\",\n\t\t\t(u32)is->memory.addr);\n\t\tdma_free_coherent(dev, is->memory.size, is->memory.vaddr,\n\t\t\t\t  is->memory.addr);\n\t\treturn -EIO;\n\t}\n\n\tis->is_p_region = (struct is_region *)(is->memory.vaddr +\n\t\t\t\tFIMC_IS_CPU_MEM_SIZE - FIMC_IS_REGION_SIZE);\n\n\tis->is_dma_p_region = is->memory.addr +\n\t\t\t\tFIMC_IS_CPU_MEM_SIZE - FIMC_IS_REGION_SIZE;\n\n\tis->is_shared_region = (struct is_share_region *)(is->memory.vaddr +\n\t\t\t\tFIMC_IS_SHARED_REGION_OFFSET);\n\treturn 0;\n}\n\nstatic void fimc_is_free_cpu_memory(struct fimc_is *is)\n{\n\tstruct device *dev = &is->pdev->dev;\n\n\tif (is->memory.vaddr == NULL)\n\t\treturn;\n\n\tdma_free_coherent(dev, is->memory.size, is->memory.vaddr,\n\t\t\t  is->memory.addr);\n}\n\nstatic void fimc_is_load_firmware(const struct firmware *fw, void *context)\n{\n\tstruct fimc_is *is = context;\n\tstruct device *dev = &is->pdev->dev;\n\tvoid *buf;\n\tint ret;\n\n\tif (fw == NULL) {\n\t\tdev_err(dev, \"firmware request failed\\n\");\n\t\treturn;\n\t}\n\tmutex_lock(&is->lock);\n\n\tif (fw->size < FIMC_IS_FW_SIZE_MIN || fw->size > FIMC_IS_FW_SIZE_MAX) {\n\t\tdev_err(dev, \"wrong firmware size: %zu\\n\", fw->size);\n\t\tgoto done;\n\t}\n\n\tis->fw.size = fw->size;\n\n\tret = fimc_is_alloc_cpu_memory(is);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to allocate FIMC-IS CPU memory\\n\");\n\t\tgoto done;\n\t}\n\n\tmemcpy(is->memory.vaddr, fw->data, fw->size);\n\twmb();\n\n\t \n\tbuf = (void *)(is->memory.vaddr + fw->size - FIMC_IS_FW_DESC_LEN);\n\tmemcpy(&is->fw.info, buf, FIMC_IS_FW_INFO_LEN);\n\tis->fw.info[FIMC_IS_FW_INFO_LEN] = 0;\n\n\tbuf = (void *)(is->memory.vaddr + fw->size - FIMC_IS_FW_VER_LEN);\n\tmemcpy(&is->fw.version, buf, FIMC_IS_FW_VER_LEN);\n\tis->fw.version[FIMC_IS_FW_VER_LEN - 1] = 0;\n\n\tis->fw.state = 1;\n\n\tdev_info(dev, \"loaded firmware: %s, rev. %s\\n\",\n\t\t is->fw.info, is->fw.version);\n\tdev_dbg(dev, \"FW size: %zu, DMA addr: %pad\\n\", fw->size, &is->memory.addr);\n\n\tis->is_shared_region->chip_id = 0xe4412;\n\tis->is_shared_region->chip_rev_no = 1;\n\n\tfimc_is_mem_barrier();\n\n\t \n\trelease_firmware(is->fw.f_w);\n\tis->fw.f_w = fw;\ndone:\n\tmutex_unlock(&is->lock);\n}\n\nstatic int fimc_is_request_firmware(struct fimc_is *is, const char *fw_name)\n{\n\treturn request_firmware_nowait(THIS_MODULE,\n\t\t\t\tFW_ACTION_UEVENT, fw_name, &is->pdev->dev,\n\t\t\t\tGFP_KERNEL, is, fimc_is_load_firmware);\n}\n\n \nstatic void fimc_is_general_irq_handler(struct fimc_is *is)\n{\n\tis->i2h_cmd.cmd = mcuctl_read(is, MCUCTL_REG_ISSR(10));\n\n\tswitch (is->i2h_cmd.cmd) {\n\tcase IHC_GET_SENSOR_NUM:\n\t\tfimc_is_hw_get_params(is, 1);\n\t\tfimc_is_hw_wait_intmsr0_intmsd0(is);\n\t\tfimc_is_hw_set_sensor_num(is);\n\t\tpr_debug(\"ISP FW version: %#x\\n\", is->i2h_cmd.args[0]);\n\t\tbreak;\n\tcase IHC_SET_FACE_MARK:\n\tcase IHC_FRAME_DONE:\n\t\tfimc_is_hw_get_params(is, 2);\n\t\tbreak;\n\tcase IHC_SET_SHOT_MARK:\n\tcase IHC_AA_DONE:\n\tcase IH_REPLY_DONE:\n\t\tfimc_is_hw_get_params(is, 3);\n\t\tbreak;\n\tcase IH_REPLY_NOT_DONE:\n\t\tfimc_is_hw_get_params(is, 4);\n\t\tbreak;\n\tcase IHC_NOT_READY:\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"unknown command: %#x\\n\", is->i2h_cmd.cmd);\n\t}\n\n\tfimc_is_fw_clear_irq1(is, FIMC_IS_INT_GENERAL);\n\n\tswitch (is->i2h_cmd.cmd) {\n\tcase IHC_GET_SENSOR_NUM:\n\t\tfimc_is_hw_set_intgr0_gd0(is);\n\t\tset_bit(IS_ST_A5_PWR_ON, &is->state);\n\t\tbreak;\n\n\tcase IHC_SET_SHOT_MARK:\n\t\tbreak;\n\n\tcase IHC_SET_FACE_MARK:\n\t\tis->fd_header.count = is->i2h_cmd.args[0];\n\t\tis->fd_header.index = is->i2h_cmd.args[1];\n\t\tis->fd_header.offset = 0;\n\t\tbreak;\n\n\tcase IHC_FRAME_DONE:\n\t\tbreak;\n\n\tcase IHC_AA_DONE:\n\t\tpr_debug(\"AA_DONE - %d, %d, %d\\n\", is->i2h_cmd.args[0],\n\t\t\t is->i2h_cmd.args[1], is->i2h_cmd.args[2]);\n\t\tbreak;\n\n\tcase IH_REPLY_DONE:\n\t\tpr_debug(\"ISR_DONE: args[0]: %#x\\n\", is->i2h_cmd.args[0]);\n\n\t\tswitch (is->i2h_cmd.args[0]) {\n\t\tcase HIC_PREVIEW_STILL...HIC_CAPTURE_VIDEO:\n\t\t\t \n\t\t\tset_bit(IS_ST_CHANGE_MODE, &is->state);\n\t\t\tis->isp.cac_margin_x = is->i2h_cmd.args[1];\n\t\t\tis->isp.cac_margin_y = is->i2h_cmd.args[2];\n\t\t\tpr_debug(\"CAC margin (x,y): (%d,%d)\\n\",\n\t\t\t\t is->isp.cac_margin_x, is->isp.cac_margin_y);\n\t\t\tbreak;\n\n\t\tcase HIC_STREAM_ON:\n\t\t\tclear_bit(IS_ST_STREAM_OFF, &is->state);\n\t\t\tset_bit(IS_ST_STREAM_ON, &is->state);\n\t\t\tbreak;\n\n\t\tcase HIC_STREAM_OFF:\n\t\t\tclear_bit(IS_ST_STREAM_ON, &is->state);\n\t\t\tset_bit(IS_ST_STREAM_OFF, &is->state);\n\t\t\tbreak;\n\n\t\tcase HIC_SET_PARAMETER:\n\t\t\tis->config[is->config_index].p_region_index[0] = 0;\n\t\t\tis->config[is->config_index].p_region_index[1] = 0;\n\t\t\tset_bit(IS_ST_BLOCK_CMD_CLEARED, &is->state);\n\t\t\tpr_debug(\"HIC_SET_PARAMETER\\n\");\n\t\t\tbreak;\n\n\t\tcase HIC_GET_PARAMETER:\n\t\t\tbreak;\n\n\t\tcase HIC_SET_TUNE:\n\t\t\tbreak;\n\n\t\tcase HIC_GET_STATUS:\n\t\t\tbreak;\n\n\t\tcase HIC_OPEN_SENSOR:\n\t\t\tset_bit(IS_ST_OPEN_SENSOR, &is->state);\n\t\t\tpr_debug(\"data lanes: %d, settle line: %d\\n\",\n\t\t\t\t is->i2h_cmd.args[2], is->i2h_cmd.args[1]);\n\t\t\tbreak;\n\n\t\tcase HIC_CLOSE_SENSOR:\n\t\t\tclear_bit(IS_ST_OPEN_SENSOR, &is->state);\n\t\t\tis->sensor_index = 0;\n\t\t\tbreak;\n\n\t\tcase HIC_MSG_TEST:\n\t\t\tpr_debug(\"config MSG level completed\\n\");\n\t\t\tbreak;\n\n\t\tcase HIC_POWER_DOWN:\n\t\t\tclear_bit(IS_ST_PWR_SUBIP_ON, &is->state);\n\t\t\tbreak;\n\n\t\tcase HIC_GET_SET_FILE_ADDR:\n\t\t\tis->setfile.base = is->i2h_cmd.args[1];\n\t\t\tset_bit(IS_ST_SETFILE_LOADED, &is->state);\n\t\t\tbreak;\n\n\t\tcase HIC_LOAD_SET_FILE:\n\t\t\tset_bit(IS_ST_SETFILE_LOADED, &is->state);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IH_REPLY_NOT_DONE:\n\t\tpr_err(\"ISR_NDONE: %d: %#x, %s\\n\", is->i2h_cmd.args[0],\n\t\t       is->i2h_cmd.args[1],\n\t\t       fimc_is_strerr(is->i2h_cmd.args[1]));\n\n\t\tif (is->i2h_cmd.args[1] & IS_ERROR_TIME_OUT_FLAG)\n\t\t\tpr_err(\"IS_ERROR_TIME_OUT\\n\");\n\n\t\tswitch (is->i2h_cmd.args[1]) {\n\t\tcase IS_ERROR_SET_PARAMETER:\n\t\t\tfimc_is_mem_barrier();\n\t\t}\n\n\t\tswitch (is->i2h_cmd.args[0]) {\n\t\tcase HIC_SET_PARAMETER:\n\t\t\tis->config[is->config_index].p_region_index[0] = 0;\n\t\t\tis->config[is->config_index].p_region_index[1] = 0;\n\t\t\tset_bit(IS_ST_BLOCK_CMD_CLEARED, &is->state);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IHC_NOT_READY:\n\t\tpr_err(\"IS control sequence error: Not Ready\\n\");\n\t\tbreak;\n\t}\n\n\twake_up(&is->irq_queue);\n}\n\nstatic irqreturn_t fimc_is_irq_handler(int irq, void *priv)\n{\n\tstruct fimc_is *is = priv;\n\tunsigned long flags;\n\tu32 status;\n\n\tspin_lock_irqsave(&is->slock, flags);\n\tstatus = mcuctl_read(is, MCUCTL_REG_INTSR1);\n\n\tif (status & (1UL << FIMC_IS_INT_GENERAL))\n\t\tfimc_is_general_irq_handler(is);\n\n\tif (status & (1UL << FIMC_IS_INT_FRAME_DONE_ISP))\n\t\tfimc_isp_irq_handler(is);\n\n\tspin_unlock_irqrestore(&is->slock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic int fimc_is_hw_open_sensor(struct fimc_is *is,\n\t\t\t\t  struct fimc_is_sensor *sensor)\n{\n\tstruct sensor_open_extended *soe = (void *)&is->is_p_region->shared;\n\n\tfimc_is_hw_wait_intmsr0_intmsd0(is);\n\n\tsoe->self_calibration_mode = 1;\n\tsoe->actuator_type = 0;\n\tsoe->mipi_lane_num = 0;\n\tsoe->mclk = 0;\n\tsoe->mipi_speed\t= 0;\n\tsoe->fast_open_sensor = 0;\n\tsoe->i2c_sclk = 88000000;\n\n\tfimc_is_mem_barrier();\n\n\t \n\tudelay(100);\n\n\tmcuctl_write(HIC_OPEN_SENSOR, is, MCUCTL_REG_ISSR(0));\n\tmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(1));\n\tmcuctl_write(sensor->drvdata->id, is, MCUCTL_REG_ISSR(2));\n\tmcuctl_write(sensor->i2c_bus, is, MCUCTL_REG_ISSR(3));\n\tmcuctl_write(is->is_dma_p_region, is, MCUCTL_REG_ISSR(4));\n\n\tfimc_is_hw_set_intgr0_gd0(is);\n\n\treturn fimc_is_wait_event(is, IS_ST_OPEN_SENSOR, 1,\n\t\t\t\t  sensor->drvdata->open_timeout);\n}\n\n\nint fimc_is_hw_initialize(struct fimc_is *is)\n{\n\tstatic const int config_ids[] = {\n\t\tIS_SC_PREVIEW_STILL, IS_SC_PREVIEW_VIDEO,\n\t\tIS_SC_CAPTURE_STILL, IS_SC_CAPTURE_VIDEO\n\t};\n\tstruct device *dev = &is->pdev->dev;\n\tu32 prev_id;\n\tint i, ret;\n\n\t \n\tret = fimc_is_hw_open_sensor(is, &is->sensor[0]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfimc_is_hw_get_setfile_addr(is);\n\n\tret = fimc_is_wait_event(is, IS_ST_SETFILE_LOADED, 1,\n\t\t\t\t FIMC_IS_CONFIG_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"get setfile address timed out\\n\");\n\t\treturn ret;\n\t}\n\tpr_debug(\"setfile.base: %#x\\n\", is->setfile.base);\n\n\t \n\tfimc_is_load_setfile(is, FIMC_IS_SETFILE_6A3);\n\tclear_bit(IS_ST_SETFILE_LOADED, &is->state);\n\tfimc_is_hw_load_setfile(is);\n\tret = fimc_is_wait_event(is, IS_ST_SETFILE_LOADED, 1,\n\t\t\t\t FIMC_IS_CONFIG_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"loading setfile timed out\\n\");\n\t\treturn ret;\n\t}\n\n\tpr_debug(\"setfile: base: %#x, size: %d\\n\",\n\t\t is->setfile.base, is->setfile.size);\n\tpr_info(\"FIMC-IS Setfile info: %s\\n\", is->fw.setfile_info);\n\n\t \n\tif (is->is_p_region->shared[MAX_SHARED_COUNT - 1] !=\n\t    FIMC_IS_MAGIC_NUMBER) {\n\t\tdev_err(dev, \"magic number error!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpr_debug(\"shared region: %pad, parameter region: %pad\\n\",\n\t\t &is->memory.addr + FIMC_IS_SHARED_REGION_OFFSET,\n\t\t &is->is_dma_p_region);\n\n\tis->setfile.sub_index = 0;\n\n\t \n\tfimc_is_hw_stream_off(is);\n\tret = fimc_is_wait_event(is, IS_ST_STREAM_OFF, 1,\n\t\t\t\t FIMC_IS_CONFIG_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"stream off timeout\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tprev_id = is->config_index;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(config_ids); i++) {\n\t\tis->config_index = config_ids[i];\n\t\tfimc_is_set_initial_params(is);\n\t\tret = fimc_is_itf_s_param(is, true);\n\t\tif (ret < 0) {\n\t\t\tis->config_index = prev_id;\n\t\t\treturn ret;\n\t\t}\n\t}\n\tis->config_index = prev_id;\n\n\tset_bit(IS_ST_INIT_DONE, &is->state);\n\tdev_info(dev, \"initialization sequence completed (%d)\\n\",\n\t\t\t\t\t\tis->config_index);\n\treturn 0;\n}\n\nstatic int fimc_is_show(struct seq_file *s, void *data)\n{\n\tstruct fimc_is *is = s->private;\n\tconst u8 *buf = is->memory.vaddr + FIMC_IS_DEBUG_REGION_OFFSET;\n\n\tif (is->memory.vaddr == NULL) {\n\t\tdev_err(&is->pdev->dev, \"firmware memory is not initialized\\n\");\n\t\treturn -EIO;\n\t}\n\n\tseq_printf(s, \"%s\\n\", buf);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(fimc_is);\n\nstatic void fimc_is_debugfs_remove(struct fimc_is *is)\n{\n\tdebugfs_remove_recursive(is->debugfs_entry);\n\tis->debugfs_entry = NULL;\n}\n\nstatic void fimc_is_debugfs_create(struct fimc_is *is)\n{\n\tis->debugfs_entry = debugfs_create_dir(\"fimc_is\", NULL);\n\n\tdebugfs_create_file(\"fw_log\", S_IRUGO, is->debugfs_entry, is,\n\t\t\t    &fimc_is_fops);\n}\n\nstatic int fimc_is_runtime_resume(struct device *dev);\nstatic int fimc_is_runtime_suspend(struct device *dev);\n\nstatic int fimc_is_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fimc_is *is;\n\tstruct resource res;\n\tstruct device_node *node;\n\tint ret;\n\n\tis = devm_kzalloc(&pdev->dev, sizeof(*is), GFP_KERNEL);\n\tif (!is)\n\t\treturn -ENOMEM;\n\n\tis->pdev = pdev;\n\tis->isp.pdev = pdev;\n\n\tinit_waitqueue_head(&is->irq_queue);\n\tspin_lock_init(&is->slock);\n\tmutex_init(&is->lock);\n\n\tret = of_address_to_resource(dev->of_node, 0, &res);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tis->regs = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(is->regs))\n\t\treturn PTR_ERR(is->regs);\n\n\tnode = of_get_child_by_name(dev->of_node, \"pmu\");\n\tif (!node)\n\t\treturn -ENODEV;\n\n\tis->pmu_regs = of_iomap(node, 0);\n\tof_node_put(node);\n\tif (!is->pmu_regs)\n\t\treturn -ENOMEM;\n\n\tis->irq = irq_of_parse_and_map(dev->of_node, 0);\n\tif (!is->irq) {\n\t\tdev_err(dev, \"no irq found\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_iounmap;\n\t}\n\n\tret = fimc_is_get_clocks(is);\n\tif (ret < 0)\n\t\tgoto err_iounmap;\n\n\tplatform_set_drvdata(pdev, is);\n\n\tret = request_irq(is->irq, fimc_is_irq_handler, 0, dev_name(dev), is);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"irq request failed\\n\");\n\t\tgoto err_clk;\n\t}\n\tpm_runtime_enable(dev);\n\n\tif (!pm_runtime_enabled(dev)) {\n\t\tret = fimc_is_runtime_resume(dev);\n\t\tif (ret < 0)\n\t\t\tgoto err_irq;\n\t}\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\tgoto err_pm_disable;\n\n\tvb2_dma_contig_set_max_seg_size(dev, DMA_BIT_MASK(32));\n\n\tret = devm_of_platform_populate(dev);\n\tif (ret < 0)\n\t\tgoto err_pm;\n\n\t \n\tret = fimc_is_register_subdevs(is);\n\tif (ret < 0)\n\t\tgoto err_pm;\n\n\tfimc_is_debugfs_create(is);\n\n\tret = fimc_is_request_firmware(is, FIMC_IS_FW_FILENAME);\n\tif (ret < 0)\n\t\tgoto err_dfs;\n\n\tpm_runtime_put_sync(dev);\n\n\tdev_dbg(dev, \"FIMC-IS registered successfully\\n\");\n\treturn 0;\n\nerr_dfs:\n\tfimc_is_debugfs_remove(is);\n\tfimc_is_unregister_subdevs(is);\nerr_pm:\n\tpm_runtime_put_noidle(dev);\n\tif (!pm_runtime_enabled(dev))\n\t\tfimc_is_runtime_suspend(dev);\nerr_pm_disable:\n\tpm_runtime_disable(dev);\nerr_irq:\n\tfree_irq(is->irq, is);\nerr_clk:\n\tfimc_is_put_clocks(is);\nerr_iounmap:\n\tiounmap(is->pmu_regs);\n\treturn ret;\n}\n\nstatic int fimc_is_runtime_resume(struct device *dev)\n{\n\tstruct fimc_is *is = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = fimc_is_setup_clocks(is);\n\tif (ret)\n\t\treturn ret;\n\n\treturn fimc_is_enable_clocks(is);\n}\n\nstatic int fimc_is_runtime_suspend(struct device *dev)\n{\n\tstruct fimc_is *is = dev_get_drvdata(dev);\n\n\tfimc_is_disable_clocks(is);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int fimc_is_resume(struct device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic int fimc_is_suspend(struct device *dev)\n{\n\tstruct fimc_is *is = dev_get_drvdata(dev);\n\n\t \n\tif (test_bit(IS_ST_A5_PWR_ON, &is->state))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n#endif  \n\nstatic void fimc_is_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fimc_is *is = dev_get_drvdata(dev);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tif (!pm_runtime_status_suspended(dev))\n\t\tfimc_is_runtime_suspend(dev);\n\tfree_irq(is->irq, is);\n\tfimc_is_unregister_subdevs(is);\n\tvb2_dma_contig_clear_max_seg_size(dev);\n\tfimc_is_put_clocks(is);\n\tiounmap(is->pmu_regs);\n\tfimc_is_debugfs_remove(is);\n\trelease_firmware(is->fw.f_w);\n\tfimc_is_free_cpu_memory(is);\n}\n\nstatic const struct of_device_id fimc_is_of_match[] = {\n\t{ .compatible = \"samsung,exynos4212-fimc-is\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, fimc_is_of_match);\n\nstatic const struct dev_pm_ops fimc_is_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(fimc_is_suspend, fimc_is_resume)\n\tSET_RUNTIME_PM_OPS(fimc_is_runtime_suspend, fimc_is_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver fimc_is_driver = {\n\t.probe\t\t= fimc_is_probe,\n\t.remove_new\t= fimc_is_remove,\n\t.driver = {\n\t\t.of_match_table\t= fimc_is_of_match,\n\t\t.name\t\t= FIMC_IS_DRV_NAME,\n\t\t.pm\t\t= &fimc_is_pm_ops,\n\t}\n};\n\nstatic int fimc_is_module_init(void)\n{\n\tint ret;\n\n\tret = fimc_is_register_i2c_driver();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = platform_driver_register(&fimc_is_driver);\n\n\tif (ret < 0)\n\t\tfimc_is_unregister_i2c_driver();\n\n\treturn ret;\n}\n\nstatic void fimc_is_module_exit(void)\n{\n\tfimc_is_unregister_i2c_driver();\n\tplatform_driver_unregister(&fimc_is_driver);\n}\n\nmodule_init(fimc_is_module_init);\nmodule_exit(fimc_is_module_exit);\n\nMODULE_ALIAS(\"platform:\" FIMC_IS_DRV_NAME);\nMODULE_AUTHOR(\"Younghwan Joo <yhwan.joo@samsung.com>\");\nMODULE_AUTHOR(\"Sylwester Nawrocki <s.nawrocki@samsung.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}