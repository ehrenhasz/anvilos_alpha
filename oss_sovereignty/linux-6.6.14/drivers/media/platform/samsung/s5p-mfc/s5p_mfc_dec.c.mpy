{
  "module_name": "s5p_mfc_dec.c",
  "hash_id": "d6d8290b9360dff830df84abe96594f833f45653b9f45de3589df49f1fc1f6d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s5p-mfc/s5p_mfc_dec.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/workqueue.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-v4l2.h>\n#include \"s5p_mfc_common.h\"\n#include \"s5p_mfc_ctrl.h\"\n#include \"s5p_mfc_debug.h\"\n#include \"s5p_mfc_dec.h\"\n#include \"s5p_mfc_intr.h\"\n#include \"s5p_mfc_opr.h\"\n#include \"s5p_mfc_pm.h\"\n\nstatic struct s5p_mfc_fmt formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12MT_16X16,\n\t\t.codec_mode\t= S5P_MFC_CODEC_NONE,\n\t\t.type\t\t= MFC_FMT_RAW,\n\t\t.num_planes\t= 2,\n\t\t.versions\t= MFC_V6_BIT | MFC_V7_BIT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12MT,\n\t\t.codec_mode\t= S5P_MFC_CODEC_NONE,\n\t\t.type\t\t= MFC_FMT_RAW,\n\t\t.num_planes\t= 2,\n\t\t.versions\t= MFC_V5_BIT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12M,\n\t\t.codec_mode\t= S5P_MFC_CODEC_NONE,\n\t\t.type\t\t= MFC_FMT_RAW,\n\t\t.num_planes\t= 2,\n\t\t.versions\t= MFC_V6PLUS_BITS,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV21M,\n\t\t.codec_mode\t= S5P_MFC_CODEC_NONE,\n\t\t.type\t\t= MFC_FMT_RAW,\n\t\t.num_planes\t= 2,\n\t\t.versions\t= MFC_V6PLUS_BITS,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_H264,\n\t\t.codec_mode\t= S5P_MFC_CODEC_H264_DEC,\n\t\t.type\t\t= MFC_FMT_DEC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V5PLUS_BITS,\n\t\t.flags\t\t= V4L2_FMT_FLAG_DYN_RESOLUTION |\n\t\t\t\t  V4L2_FMT_FLAG_CONTINUOUS_BYTESTREAM,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_H264_MVC,\n\t\t.codec_mode\t= S5P_MFC_CODEC_H264_MVC_DEC,\n\t\t.type\t\t= MFC_FMT_DEC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V6PLUS_BITS,\n\t\t.flags\t\t= V4L2_FMT_FLAG_DYN_RESOLUTION |\n\t\t\t\t  V4L2_FMT_FLAG_CONTINUOUS_BYTESTREAM,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_H263,\n\t\t.codec_mode\t= S5P_MFC_CODEC_H263_DEC,\n\t\t.type\t\t= MFC_FMT_DEC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V5PLUS_BITS,\n\t\t.flags\t\t= V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_MPEG1,\n\t\t.codec_mode\t= S5P_MFC_CODEC_MPEG2_DEC,\n\t\t.type\t\t= MFC_FMT_DEC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V5PLUS_BITS,\n\t\t.flags\t\t= V4L2_FMT_FLAG_DYN_RESOLUTION |\n\t\t\t\t  V4L2_FMT_FLAG_CONTINUOUS_BYTESTREAM,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_MPEG2,\n\t\t.codec_mode\t= S5P_MFC_CODEC_MPEG2_DEC,\n\t\t.type\t\t= MFC_FMT_DEC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V5PLUS_BITS,\n\t\t.flags\t\t= V4L2_FMT_FLAG_DYN_RESOLUTION |\n\t\t\t\t  V4L2_FMT_FLAG_CONTINUOUS_BYTESTREAM,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_MPEG4,\n\t\t.codec_mode\t= S5P_MFC_CODEC_MPEG4_DEC,\n\t\t.type\t\t= MFC_FMT_DEC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V5PLUS_BITS,\n\t\t.flags\t\t= V4L2_FMT_FLAG_DYN_RESOLUTION |\n\t\t\t\t  V4L2_FMT_FLAG_CONTINUOUS_BYTESTREAM,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_XVID,\n\t\t.codec_mode\t= S5P_MFC_CODEC_MPEG4_DEC,\n\t\t.type\t\t= MFC_FMT_DEC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V5PLUS_BITS,\n\t\t.flags\t\t= V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_VC1_ANNEX_G,\n\t\t.codec_mode\t= S5P_MFC_CODEC_VC1_DEC,\n\t\t.type\t\t= MFC_FMT_DEC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V5PLUS_BITS,\n\t\t.flags\t\t= V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_VC1_ANNEX_L,\n\t\t.codec_mode\t= S5P_MFC_CODEC_VC1RCV_DEC,\n\t\t.type\t\t= MFC_FMT_DEC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V5PLUS_BITS,\n\t\t.flags\t\t= V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_VP8,\n\t\t.codec_mode\t= S5P_MFC_CODEC_VP8_DEC,\n\t\t.type\t\t= MFC_FMT_DEC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V6PLUS_BITS,\n\t\t.flags\t\t= V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_HEVC,\n\t\t.codec_mode\t= S5P_FIMV_CODEC_HEVC_DEC,\n\t\t.type\t\t= MFC_FMT_DEC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V10_BIT,\n\t\t.flags\t\t= V4L2_FMT_FLAG_DYN_RESOLUTION |\n\t\t\t\t  V4L2_FMT_FLAG_CONTINUOUS_BYTESTREAM,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_VP9,\n\t\t.codec_mode\t= S5P_FIMV_CODEC_VP9_DEC,\n\t\t.type\t\t= MFC_FMT_DEC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V10_BIT,\n\t\t.flags\t\t= V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n};\n\n#define NUM_FORMATS ARRAY_SIZE(formats)\n\n \nstatic struct s5p_mfc_fmt *find_format(struct v4l2_format *f, unsigned int t)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < NUM_FORMATS; i++) {\n\t\tif (formats[i].fourcc == f->fmt.pix_mp.pixelformat &&\n\t\t    formats[i].type == t)\n\t\t\treturn &formats[i];\n\t}\n\treturn NULL;\n}\n\nstatic struct mfc_control controls[] = {\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"H264 Display Delay\",\n\t\t.minimum = 0,\n\t\t.maximum = 16383,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 16383,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY_ENABLE,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"H264 Display Delay Enable\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY_ENABLE,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"Mpeg4 Loop Filter Enable\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"Slice Interface Enable\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MIN_BUFFERS_FOR_CAPTURE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Minimum number of cap bufs\",\n\t\t.minimum = 1,\n\t\t.maximum = 32,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t\t.is_volatile = 1,\n\t},\n};\n\n#define NUM_CTRLS ARRAY_SIZE(controls)\n\n \nstatic int s5p_mfc_ctx_ready(struct s5p_mfc_ctx *ctx)\n{\n\t \n\tif (ctx->src_queue_cnt >= 1 && ctx->state == MFCINST_GOT_INST)\n\t\treturn 1;\n\t \n\tif (ctx->src_queue_cnt >= 1 &&\n\t    ctx->state == MFCINST_RUNNING &&\n\t    ctx->dst_queue_cnt >= ctx->pb_count)\n\t\treturn 1;\n\t \n\tif (ctx->state == MFCINST_FINISHING &&\n\t    ctx->dst_queue_cnt >= ctx->pb_count)\n\t\treturn 1;\n\t \n\tif (ctx->src_queue_cnt >= 1 &&\n\t    ctx->state == MFCINST_HEAD_PARSED &&\n\t    ctx->capture_state == QUEUE_BUFS_MMAPED)\n\t\treturn 1;\n\t \n\tif ((ctx->state == MFCINST_RES_CHANGE_INIT ||\n\t\tctx->state == MFCINST_RES_CHANGE_FLUSH) &&\n\t\tctx->dst_queue_cnt >= ctx->pb_count)\n\t\treturn 1;\n\tif (ctx->state == MFCINST_RES_CHANGE_END &&\n\t\tctx->src_queue_cnt >= 1)\n\t\treturn 1;\n\tmfc_debug(2, \"ctx is not ready\\n\");\n\treturn 0;\n}\n\nstatic const struct s5p_mfc_codec_ops decoder_codec_ops = {\n\t.pre_seq_start\t\t= NULL,\n\t.post_seq_start\t\t= NULL,\n\t.pre_frame_start\t= NULL,\n\t.post_frame_start\t= NULL,\n};\n\n \nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct s5p_mfc_dev *dev = video_drvdata(file);\n\n\tstrscpy(cap->driver, S5P_MFC_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, dev->vfd_dec->name, sizeof(cap->card));\n\treturn 0;\n}\n\n \nstatic int vidioc_enum_fmt(struct file *file, struct v4l2_fmtdesc *f,\n\t\t\t\t\t\t\tbool out)\n{\n\tstruct s5p_mfc_dev *dev = video_drvdata(file);\n\tint i, j = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); ++i) {\n\t\tif (out && formats[i].type != MFC_FMT_DEC)\n\t\t\tcontinue;\n\t\telse if (!out && formats[i].type != MFC_FMT_RAW)\n\t\t\tcontinue;\n\t\telse if ((dev->variant->version_bit & formats[i].versions) == 0)\n\t\t\tcontinue;\n\n\t\tif (j == f->index)\n\t\t\tbreak;\n\t\t++j;\n\t}\n\tif (i == ARRAY_SIZE(formats))\n\t\treturn -EINVAL;\n\tf->pixelformat = formats[i].fourcc;\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *pirv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn vidioc_enum_fmt(file, f, false);\n}\n\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn vidioc_enum_fmt(file, f, true);\n}\n\n \nstatic int vidioc_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\n\tmfc_debug_enter();\n\tpix_mp = &f->fmt.pix_mp;\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\n\t    (ctx->state == MFCINST_GOT_INST || ctx->state ==\n\t\t\t\t\t\tMFCINST_RES_CHANGE_END)) {\n\t\t \n\t\ts5p_mfc_wait_for_done_ctx(ctx, S5P_MFC_R2H_CMD_SEQ_DONE_RET,\n\t\t\t\t\t\t\t\t\t0);\n\t}\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\n\t    ctx->state >= MFCINST_HEAD_PARSED &&\n\t    ctx->state < MFCINST_ABORT) {\n\t\t \n\t\t \n\t\tpix_mp->width = ctx->buf_width;\n\t\tpix_mp->height = ctx->buf_height;\n\t\tpix_mp->field = V4L2_FIELD_NONE;\n\t\tpix_mp->num_planes = 2;\n\t\t \n\t\tpix_mp->pixelformat = ctx->dst_fmt->fourcc;\n\t\tpix_mp->plane_fmt[0].bytesperline = ctx->buf_width;\n\t\tpix_mp->plane_fmt[0].sizeimage = ctx->luma_size;\n\t\tpix_mp->plane_fmt[1].bytesperline = ctx->buf_width;\n\t\tpix_mp->plane_fmt[1].sizeimage = ctx->chroma_size;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\t \n\t\tpix_mp->width = 0;\n\t\tpix_mp->height = 0;\n\t\tpix_mp->field = V4L2_FIELD_NONE;\n\t\tpix_mp->plane_fmt[0].bytesperline = ctx->dec_src_buf_size;\n\t\tpix_mp->plane_fmt[0].sizeimage = ctx->dec_src_buf_size;\n\t\tpix_mp->pixelformat = ctx->src_fmt->fourcc;\n\t\tpix_mp->num_planes = ctx->src_fmt->num_planes;\n\t} else {\n\t\tmfc_err(\"Format could not be read\\n\");\n\t\tmfc_debug(2, \"%s-- with error\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tmfc_debug_leave();\n\treturn 0;\n}\n\n \nstatic int vidioc_try_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct s5p_mfc_dev *dev = video_drvdata(file);\n\tstruct s5p_mfc_fmt *fmt;\n\n\tmfc_debug(2, \"Type is %d\\n\", f->type);\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tfmt = find_format(f, MFC_FMT_DEC);\n\t\tif (!fmt) {\n\t\t\tmfc_err(\"Unsupported format for source.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (fmt->codec_mode == S5P_FIMV_CODEC_NONE) {\n\t\t\tmfc_err(\"Unknown codec\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((dev->variant->version_bit & fmt->versions) == 0) {\n\t\t\tmfc_err(\"Unsupported format by this MFC version.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tfmt = find_format(f, MFC_FMT_RAW);\n\t\tif (!fmt) {\n\t\t\tmfc_err(\"Unsupported format for destination.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((dev->variant->version_bit & fmt->versions) == 0) {\n\t\t\tmfc_err(\"Unsupported format by this MFC version.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vidioc_s_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct s5p_mfc_dev *dev = video_drvdata(file);\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tint ret = 0;\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tstruct s5p_mfc_buf_size *buf_size = dev->variant->buf_size;\n\n\tmfc_debug_enter();\n\tret = vidioc_try_fmt(file, priv, f);\n\tpix_mp = &f->fmt.pix_mp;\n\tif (ret)\n\t\treturn ret;\n\tif (vb2_is_streaming(&ctx->vq_src) || vb2_is_streaming(&ctx->vq_dst)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"%s queue busy\\n\", __func__);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\t \n\t\tctx->dst_fmt = find_format(f, MFC_FMT_RAW);\n\t\tret = 0;\n\t\tgoto out;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\t \n\t\tctx->src_fmt = find_format(f, MFC_FMT_DEC);\n\t\tctx->codec_mode = ctx->src_fmt->codec_mode;\n\t\tmfc_debug(2, \"The codec number is: %d\\n\", ctx->codec_mode);\n\t\tpix_mp->height = 0;\n\t\tpix_mp->width = 0;\n\t\tif (pix_mp->plane_fmt[0].sizeimage == 0)\n\t\t\tpix_mp->plane_fmt[0].sizeimage = ctx->dec_src_buf_size =\n\t\t\t\t\t\t\t\tDEF_CPB_SIZE;\n\t\telse if (pix_mp->plane_fmt[0].sizeimage > buf_size->cpb)\n\t\t\tctx->dec_src_buf_size = buf_size->cpb;\n\t\telse\n\t\t\tctx->dec_src_buf_size = pix_mp->plane_fmt[0].sizeimage;\n\t\tpix_mp->plane_fmt[0].bytesperline = 0;\n\t\tctx->state = MFCINST_INIT;\n\t\tret = 0;\n\t\tgoto out;\n\t} else {\n\t\tmfc_err(\"Wrong type error for S_FMT : %d\", f->type);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\tmfc_debug_leave();\n\treturn ret;\n}\n\nstatic int reqbufs_output(struct s5p_mfc_dev *dev, struct s5p_mfc_ctx *ctx,\n\t\t\t\tstruct v4l2_requestbuffers *reqbufs)\n{\n\tint ret = 0;\n\n\ts5p_mfc_clock_on();\n\n\tif (reqbufs->count == 0) {\n\t\tmfc_debug(2, \"Freeing buffers\\n\");\n\t\tret = vb2_reqbufs(&ctx->vq_src, reqbufs);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tctx->src_bufs_cnt = 0;\n\t\tctx->output_state = QUEUE_FREE;\n\t} else if (ctx->output_state == QUEUE_FREE) {\n\t\t \n\t\tWARN_ON(ctx->src_bufs_cnt != 0);\n\t\tif (ctx->state != MFCINST_INIT) {\n\t\t\tmfc_err(\"Reqbufs called in an invalid state\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmfc_debug(2, \"Allocating %d buffers for OUTPUT queue\\n\",\n\t\t\t\treqbufs->count);\n\t\tret = vb2_reqbufs(&ctx->vq_src, reqbufs);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = s5p_mfc_open_mfc_inst(dev, ctx);\n\t\tif (ret) {\n\t\t\treqbufs->count = 0;\n\t\t\tvb2_reqbufs(&ctx->vq_src, reqbufs);\n\t\t\tgoto out;\n\t\t}\n\n\t\tctx->output_state = QUEUE_BUFS_REQUESTED;\n\t} else {\n\t\tmfc_err(\"Buffers have already been requested\\n\");\n\t\tret = -EINVAL;\n\t}\nout:\n\ts5p_mfc_clock_off();\n\tif (ret)\n\t\tmfc_err(\"Failed allocating buffers for OUTPUT queue\\n\");\n\treturn ret;\n}\n\nstatic int reqbufs_capture(struct s5p_mfc_dev *dev, struct s5p_mfc_ctx *ctx,\n\t\t\t\tstruct v4l2_requestbuffers *reqbufs)\n{\n\tint ret = 0;\n\n\ts5p_mfc_clock_on();\n\n\tif (reqbufs->count == 0) {\n\t\tmfc_debug(2, \"Freeing buffers\\n\");\n\t\tret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\ts5p_mfc_hw_call(dev->mfc_ops, release_codec_buffers, ctx);\n\t\tctx->dst_bufs_cnt = 0;\n\t} else if (ctx->capture_state == QUEUE_FREE) {\n\t\tWARN_ON(ctx->dst_bufs_cnt != 0);\n\t\tmfc_debug(2, \"Allocating %d buffers for CAPTURE queue\\n\",\n\t\t\t\treqbufs->count);\n\t\tret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tctx->capture_state = QUEUE_BUFS_REQUESTED;\n\t\tctx->total_dpb_count = reqbufs->count;\n\n\t\tret = s5p_mfc_hw_call(dev->mfc_ops, alloc_codec_buffers, ctx);\n\t\tif (ret) {\n\t\t\tmfc_err(\"Failed to allocate decoding buffers\\n\");\n\t\t\treqbufs->count = 0;\n\t\t\tvb2_reqbufs(&ctx->vq_dst, reqbufs);\n\t\t\tret = -ENOMEM;\n\t\t\tctx->capture_state = QUEUE_FREE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tWARN_ON(ctx->dst_bufs_cnt != ctx->total_dpb_count);\n\t\tctx->capture_state = QUEUE_BUFS_MMAPED;\n\n\t\tif (s5p_mfc_ctx_ready(ctx))\n\t\t\tset_work_bit_irqsave(ctx);\n\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\t\ts5p_mfc_wait_for_done_ctx(ctx, S5P_MFC_R2H_CMD_INIT_BUFFERS_RET,\n\t\t\t\t\t  0);\n\t} else {\n\t\tmfc_err(\"Buffers have already been requested\\n\");\n\t\tret = -EINVAL;\n\t}\nout:\n\ts5p_mfc_clock_off();\n\tif (ret)\n\t\tmfc_err(\"Failed allocating buffers for CAPTURE queue\\n\");\n\treturn ret;\n}\n\n \nstatic int vidioc_reqbufs(struct file *file, void *priv,\n\t\t\t\t\t  struct v4l2_requestbuffers *reqbufs)\n{\n\tstruct s5p_mfc_dev *dev = video_drvdata(file);\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\n\tif (reqbufs->memory != V4L2_MEMORY_MMAP) {\n\t\tmfc_debug(2, \"Only V4L2_MEMORY_MMAP is supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reqbufs->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\treturn reqbufs_output(dev, ctx, reqbufs);\n\t} else if (reqbufs->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\treturn reqbufs_capture(dev, ctx, reqbufs);\n\t} else {\n\t\tmfc_err(\"Invalid type requested\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int vidioc_querybuf(struct file *file, void *priv,\n\t\t\t\t\t\t   struct v4l2_buffer *buf)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tint ret;\n\tint i;\n\n\tif (buf->memory != V4L2_MEMORY_MMAP) {\n\t\tmfc_err(\"Only mmapped buffers can be used\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmfc_debug(2, \"State: %d, buf->type: %d\\n\", ctx->state, buf->type);\n\tif (ctx->state == MFCINST_GOT_INST &&\n\t\t\tbuf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tret = vb2_querybuf(&ctx->vq_src, buf);\n\t} else if (ctx->state == MFCINST_RUNNING &&\n\t\t\tbuf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tret = vb2_querybuf(&ctx->vq_dst, buf);\n\t\tfor (i = 0; i < buf->length; i++)\n\t\t\tbuf->m.planes[i].m.mem_offset += DST_QUEUE_OFF_BASE;\n\t} else {\n\t\tmfc_err(\"vidioc_querybuf called in an inappropriate state\\n\");\n\t\tret = -EINVAL;\n\t}\n\tmfc_debug_leave();\n\treturn ret;\n}\n\n \nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\n\tif (ctx->state == MFCINST_ERROR) {\n\t\tmfc_err(\"Call on QBUF after unrecoverable error\\n\");\n\t\treturn -EIO;\n\t}\n\tif (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn vb2_qbuf(&ctx->vq_src, NULL, buf);\n\telse if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn vb2_qbuf(&ctx->vq_dst, NULL, buf);\n\treturn -EINVAL;\n}\n\n \nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\n{\n\tconst struct v4l2_event ev = {\n\t\t.type = V4L2_EVENT_EOS\n\t};\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tint ret;\n\n\tif (ctx->state == MFCINST_ERROR) {\n\t\tmfc_err_limited(\"Call on DQBUF after unrecoverable error\\n\");\n\t\treturn -EIO;\n\t}\n\n\tswitch (buf->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\treturn vb2_dqbuf(&ctx->vq_src, buf, file->f_flags & O_NONBLOCK);\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tret = vb2_dqbuf(&ctx->vq_dst, buf, file->f_flags & O_NONBLOCK);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (ctx->state == MFCINST_FINISHED &&\n\t\t    (ctx->dst_bufs[buf->index].flags & MFC_BUF_FLAG_EOS))\n\t\t\tv4l2_event_queue_fh(&ctx->fh, &ev);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int vidioc_expbuf(struct file *file, void *priv,\n\tstruct v4l2_exportbuffer *eb)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\n\tif (eb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn vb2_expbuf(&ctx->vq_src, eb);\n\tif (eb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn vb2_expbuf(&ctx->vq_dst, eb);\n\treturn -EINVAL;\n}\n\n \nstatic int vidioc_streamon(struct file *file, void *priv,\n\t\t\t   enum v4l2_buf_type type)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tint ret = -EINVAL;\n\n\tmfc_debug_enter();\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tret = vb2_streamon(&ctx->vq_src, type);\n\telse if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tret = vb2_streamon(&ctx->vq_dst, type);\n\tmfc_debug_leave();\n\treturn ret;\n}\n\n \nstatic int vidioc_streamoff(struct file *file, void *priv,\n\t\t\t    enum v4l2_buf_type type)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn vb2_streamoff(&ctx->vq_src, type);\n\telse if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn vb2_streamoff(&ctx->vq_dst, type);\n\treturn -EINVAL;\n}\n\n \nstatic int s5p_mfc_dec_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct s5p_mfc_ctx *ctx = ctrl_to_ctx(ctrl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY:\n\tcase V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY:\n\t\tctx->display_delay = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY_ENABLE:\n\tcase V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY_ENABLE:\n\t\tctx->display_delay_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER:\n\t\tctx->loop_filter_mpeg4 = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE:\n\t\tctx->slice_interface = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\tmfc_err(\"Invalid control 0x%08x\\n\", ctrl->id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int s5p_mfc_dec_g_v_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct s5p_mfc_ctx *ctx = ctrl_to_ctx(ctrl);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:\n\t\tif (ctx->state >= MFCINST_HEAD_PARSED &&\n\t\t    ctx->state < MFCINST_ABORT) {\n\t\t\tctrl->val = ctx->pb_count;\n\t\t\tbreak;\n\t\t} else if (ctx->state != MFCINST_INIT &&\n\t\t\t\tctx->state != MFCINST_RES_CHANGE_END) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"Decoding not initialised\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\ts5p_mfc_wait_for_done_ctx(ctx,\n\t\t\t\tS5P_MFC_R2H_CMD_SEQ_DONE_RET, 0);\n\t\tif (ctx->state >= MFCINST_HEAD_PARSED &&\n\t\t    ctx->state < MFCINST_ABORT) {\n\t\t\tctrl->val = ctx->pb_count;\n\t\t} else {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"Decoding not initialised\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\nstatic const struct v4l2_ctrl_ops s5p_mfc_dec_ctrl_ops = {\n\t.s_ctrl = s5p_mfc_dec_s_ctrl,\n\t.g_volatile_ctrl = s5p_mfc_dec_g_v_ctrl,\n};\n\n \nstatic int vidioc_g_selection(struct file *file, void *priv,\n\t\t\t      struct v4l2_selection *s)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tu32 left, right, top, bottom;\n\tu32 width, height;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (ctx->state != MFCINST_HEAD_PARSED &&\n\t    ctx->state != MFCINST_RUNNING &&\n\t    ctx->state != MFCINST_FINISHING &&\n\t    ctx->state != MFCINST_FINISHED) {\n\t\tmfc_err(\"Can not get compose information\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (ctx->src_fmt->fourcc == V4L2_PIX_FMT_H264) {\n\t\tleft = s5p_mfc_hw_call(dev->mfc_ops, get_crop_info_h, ctx);\n\t\tright = left >> S5P_FIMV_SHARED_CROP_RIGHT_SHIFT;\n\t\tleft = left & S5P_FIMV_SHARED_CROP_LEFT_MASK;\n\t\ttop = s5p_mfc_hw_call(dev->mfc_ops, get_crop_info_v, ctx);\n\t\tbottom = top >> S5P_FIMV_SHARED_CROP_BOTTOM_SHIFT;\n\t\ttop = top & S5P_FIMV_SHARED_CROP_TOP_MASK;\n\t\twidth = ctx->img_width - left - right;\n\t\theight = ctx->img_height - top - bottom;\n\t\tmfc_debug(2, \"Composing info [h264]: l=%d t=%d w=%d h=%d (r=%d b=%d fw=%d fh=%d\\n\",\n\t\t\t  left, top, s->r.width, s->r.height, right, bottom,\n\t\t\t  ctx->buf_width, ctx->buf_height);\n\t} else {\n\t\tleft = 0;\n\t\ttop = 0;\n\t\twidth = ctx->img_width;\n\t\theight = ctx->img_height;\n\t\tmfc_debug(2, \"Composing info: w=%d h=%d fw=%d fh=%d\\n\",\n\t\t\t  s->r.width, s->r.height, ctx->buf_width,\n\t\t\t  ctx->buf_height);\n\t}\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\ts->r.left = left;\n\t\ts->r.top = top;\n\t\ts->r.width = width;\n\t\ts->r.height = height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_decoder_cmd(struct file *file, void *priv,\n\t\t\t      struct v4l2_decoder_cmd *cmd)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *buf;\n\tunsigned long flags;\n\n\tswitch (cmd->cmd) {\n\tcase V4L2_DEC_CMD_STOP:\n\t\tif (cmd->flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (!vb2_is_streaming(&ctx->vq_src))\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irqsave(&dev->irqlock, flags);\n\t\tif (list_empty(&ctx->src_queue)) {\n\t\t\tmfc_err(\"EOS: empty src queue, entering finishing state\");\n\t\t\tctx->state = MFCINST_FINISHING;\n\t\t\tif (s5p_mfc_ctx_ready(ctx))\n\t\t\t\tset_work_bit_irqsave(ctx);\n\t\t\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\t\t} else {\n\t\t\tmfc_err(\"EOS: marking last buffer of stream\");\n\t\t\tbuf = list_entry(ctx->src_queue.prev,\n\t\t\t\t\t\tstruct s5p_mfc_buf, list);\n\t\t\tif (buf->flags & MFC_BUF_FLAG_USED)\n\t\t\t\tctx->state = MFCINST_FINISHING;\n\t\t\telse\n\t\t\t\tbuf->flags |= MFC_BUF_FLAG_EOS;\n\t\t\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\tconst struct  v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_EOS:\n\t\treturn v4l2_event_subscribe(fh, sub, 2, NULL);\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subscribe(fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n\n \nstatic const struct v4l2_ioctl_ops s5p_mfc_dec_ioctl_ops = {\n\t.vidioc_querycap = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_out = vidioc_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_cap_mplane = vidioc_g_fmt,\n\t.vidioc_g_fmt_vid_out_mplane = vidioc_g_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane = vidioc_try_fmt,\n\t.vidioc_try_fmt_vid_out_mplane = vidioc_try_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane = vidioc_s_fmt,\n\t.vidioc_s_fmt_vid_out_mplane = vidioc_s_fmt,\n\t.vidioc_reqbufs = vidioc_reqbufs,\n\t.vidioc_querybuf = vidioc_querybuf,\n\t.vidioc_qbuf = vidioc_qbuf,\n\t.vidioc_dqbuf = vidioc_dqbuf,\n\t.vidioc_expbuf = vidioc_expbuf,\n\t.vidioc_streamon = vidioc_streamon,\n\t.vidioc_streamoff = vidioc_streamoff,\n\t.vidioc_g_selection = vidioc_g_selection,\n\t.vidioc_decoder_cmd = vidioc_decoder_cmd,\n\t.vidioc_subscribe_event = vidioc_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic int s5p_mfc_queue_setup(struct vb2_queue *vq,\n\t\t\tunsigned int *buf_count,\n\t\t\tunsigned int *plane_count, unsigned int psize[],\n\t\t\tstruct device *alloc_devs[])\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\t \n\tif (ctx->state == MFCINST_INIT &&\n\t    vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\t \n\t\t*plane_count = 1;\n\t\tif (*buf_count < 1)\n\t\t\t*buf_count = 1;\n\t\tif (*buf_count > MFC_MAX_BUFFERS)\n\t\t\t*buf_count = MFC_MAX_BUFFERS;\n\t \n\t} else if (ctx->state == MFCINST_HEAD_PARSED &&\n\t\t   vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\t \n\t\t*plane_count = 2;\n\t\t \n\t\tif (*buf_count < ctx->pb_count)\n\t\t\t*buf_count = ctx->pb_count;\n\t\tif (*buf_count > ctx->pb_count + MFC_MAX_EXTRA_DPB)\n\t\t\t*buf_count = ctx->pb_count + MFC_MAX_EXTRA_DPB;\n\t\tif (*buf_count > MFC_MAX_BUFFERS)\n\t\t\t*buf_count = MFC_MAX_BUFFERS;\n\t} else {\n\t\tmfc_err(\"State seems invalid. State = %d, vq->type = %d\\n\",\n\t\t\t\t\t\t\tctx->state, vq->type);\n\t\treturn -EINVAL;\n\t}\n\tmfc_debug(2, \"Buffer count=%d, plane count=%d\\n\",\n\t\t\t\t\t\t*buf_count, *plane_count);\n\tif (ctx->state == MFCINST_HEAD_PARSED &&\n\t    vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tpsize[0] = ctx->luma_size;\n\t\tpsize[1] = ctx->chroma_size;\n\n\t\tif (IS_MFCV6_PLUS(dev))\n\t\t\talloc_devs[0] = ctx->dev->mem_dev[BANK_L_CTX];\n\t\telse\n\t\t\talloc_devs[0] = ctx->dev->mem_dev[BANK_R_CTX];\n\t\talloc_devs[1] = ctx->dev->mem_dev[BANK_L_CTX];\n\t} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&\n\t\t   ctx->state == MFCINST_INIT) {\n\t\tpsize[0] = ctx->dec_src_buf_size;\n\t\talloc_devs[0] = ctx->dev->mem_dev[BANK_L_CTX];\n\t} else {\n\t\tmfc_err(\"This video node is dedicated to decoding. Decoding not initialized\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int s5p_mfc_buf_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\n\tunsigned int i;\n\n\tif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tif (ctx->capture_state == QUEUE_BUFS_MMAPED)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < ctx->dst_fmt->num_planes; i++) {\n\t\t\tif (IS_ERR_OR_NULL(ERR_PTR(\n\t\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, i)))) {\n\t\t\t\tmfc_err(\"Plane mem not allocated\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (vb2_plane_size(vb, 0) < ctx->luma_size ||\n\t\t\tvb2_plane_size(vb, 1) < ctx->chroma_size) {\n\t\t\tmfc_err(\"Plane buffer (CAPTURE) is too small\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ti = vb->index;\n\t\tctx->dst_bufs[i].b = vbuf;\n\t\tctx->dst_bufs[i].cookie.raw.luma =\n\t\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, 0);\n\t\tctx->dst_bufs[i].cookie.raw.chroma =\n\t\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, 1);\n\t\tctx->dst_bufs_cnt++;\n\t} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tif (IS_ERR_OR_NULL(ERR_PTR(\n\t\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, 0)))) {\n\t\t\tmfc_err(\"Plane memory not allocated\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (vb2_plane_size(vb, 0) < ctx->dec_src_buf_size) {\n\t\t\tmfc_err(\"Plane buffer (OUTPUT) is too small\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ti = vb->index;\n\t\tctx->src_bufs[i].b = vbuf;\n\t\tctx->src_bufs[i].cookie.stream =\n\t\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, 0);\n\t\tctx->src_bufs_cnt++;\n\t} else {\n\t\tmfc_err(\"s5p_mfc_buf_init: unknown queue type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int s5p_mfc_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(q->drv_priv);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tv4l2_ctrl_handler_setup(&ctx->ctrl_handler);\n\tif (ctx->state == MFCINST_FINISHING ||\n\t\tctx->state == MFCINST_FINISHED)\n\t\tctx->state = MFCINST_RUNNING;\n\t \n\tif (s5p_mfc_ctx_ready(ctx))\n\t\tset_work_bit_irqsave(ctx);\n\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\treturn 0;\n}\n\nstatic void s5p_mfc_stop_streaming(struct vb2_queue *q)\n{\n\tunsigned long flags;\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(q->drv_priv);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tint aborted = 0;\n\n\tspin_lock_irqsave(&dev->irqlock, flags);\n\tif ((ctx->state == MFCINST_FINISHING ||\n\t\tctx->state ==  MFCINST_RUNNING) &&\n\t\tdev->curr_ctx == ctx->num && dev->hw_lock) {\n\t\tctx->state = MFCINST_ABORT;\n\t\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\t\ts5p_mfc_wait_for_done_ctx(ctx,\n\t\t\t\t\tS5P_MFC_R2H_CMD_FRAME_DONE_RET, 0);\n\t\taborted = 1;\n\t\tspin_lock_irqsave(&dev->irqlock, flags);\n\t}\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\ts5p_mfc_cleanup_queue(&ctx->dst_queue, &ctx->vq_dst);\n\t\tINIT_LIST_HEAD(&ctx->dst_queue);\n\t\tctx->dst_queue_cnt = 0;\n\t\tctx->dpb_flush_flag = 1;\n\t\tctx->dec_dst_flag = 0;\n\t\tif (IS_MFCV6_PLUS(dev) && (ctx->state == MFCINST_RUNNING)) {\n\t\t\tctx->state = MFCINST_FLUSH;\n\t\t\tset_work_bit_irqsave(ctx);\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\t\t\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\t\t\tif (s5p_mfc_wait_for_done_ctx(ctx,\n\t\t\t\tS5P_MFC_R2H_CMD_DPB_FLUSH_RET, 0))\n\t\t\t\tmfc_err(\"Err flushing buffers\\n\");\n\t\t\tspin_lock_irqsave(&dev->irqlock, flags);\n\t\t}\n\t} else if (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\ts5p_mfc_cleanup_queue(&ctx->src_queue, &ctx->vq_src);\n\t\tINIT_LIST_HEAD(&ctx->src_queue);\n\t\tctx->src_queue_cnt = 0;\n\t}\n\tif (aborted)\n\t\tctx->state = MFCINST_RUNNING;\n\tspin_unlock_irqrestore(&dev->irqlock, flags);\n}\n\n\nstatic void s5p_mfc_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tunsigned long flags;\n\tstruct s5p_mfc_buf *mfc_buf;\n\n\tif (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tmfc_buf = &ctx->src_bufs[vb->index];\n\t\tmfc_buf->flags &= ~MFC_BUF_FLAG_USED;\n\t\tspin_lock_irqsave(&dev->irqlock, flags);\n\t\tlist_add_tail(&mfc_buf->list, &ctx->src_queue);\n\t\tctx->src_queue_cnt++;\n\t\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\t} else if (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tmfc_buf = &ctx->dst_bufs[vb->index];\n\t\tmfc_buf->flags &= ~MFC_BUF_FLAG_USED;\n\t\t \n\t\tspin_lock_irqsave(&dev->irqlock, flags);\n\t\tset_bit(vb->index, &ctx->dec_dst_flag);\n\t\tlist_add_tail(&mfc_buf->list, &ctx->dst_queue);\n\t\tctx->dst_queue_cnt++;\n\t\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\t} else {\n\t\tmfc_err(\"Unsupported buffer type (%d)\\n\", vq->type);\n\t}\n\tif (s5p_mfc_ctx_ready(ctx))\n\t\tset_work_bit_irqsave(ctx);\n\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n}\n\nstatic struct vb2_ops s5p_mfc_dec_qops = {\n\t.queue_setup\t\t= s5p_mfc_queue_setup,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.buf_init\t\t= s5p_mfc_buf_init,\n\t.start_streaming\t= s5p_mfc_start_streaming,\n\t.stop_streaming\t\t= s5p_mfc_stop_streaming,\n\t.buf_queue\t\t= s5p_mfc_buf_queue,\n};\n\nconst struct s5p_mfc_codec_ops *get_dec_codec_ops(void)\n{\n\treturn &decoder_codec_ops;\n}\n\nstruct vb2_ops *get_dec_queue_ops(void)\n{\n\treturn &s5p_mfc_dec_qops;\n}\n\nconst struct v4l2_ioctl_ops *get_dec_v4l2_ioctl_ops(void)\n{\n\treturn &s5p_mfc_dec_ioctl_ops;\n}\n\n#define IS_MFC51_PRIV(x) ((V4L2_CTRL_ID2WHICH(x) == V4L2_CTRL_CLASS_CODEC) \\\n\t\t\t\t\t\t&& V4L2_CTRL_DRIVER_PRIV(x))\n\nint s5p_mfc_dec_ctrls_setup(struct s5p_mfc_ctx *ctx)\n{\n\tstruct v4l2_ctrl_config cfg;\n\tint i;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, NUM_CTRLS);\n\tif (ctx->ctrl_handler.error) {\n\t\tmfc_err(\"v4l2_ctrl_handler_init failed\\n\");\n\t\treturn ctx->ctrl_handler.error;\n\t}\n\n\tfor (i = 0; i < NUM_CTRLS; i++) {\n\t\tif (IS_MFC51_PRIV(controls[i].id)) {\n\t\t\tmemset(&cfg, 0, sizeof(struct v4l2_ctrl_config));\n\t\t\tcfg.ops = &s5p_mfc_dec_ctrl_ops;\n\t\t\tcfg.id = controls[i].id;\n\t\t\tcfg.min = controls[i].minimum;\n\t\t\tcfg.max = controls[i].maximum;\n\t\t\tcfg.def = controls[i].default_value;\n\t\t\tcfg.name = controls[i].name;\n\t\t\tcfg.type = controls[i].type;\n\n\t\t\tcfg.step = controls[i].step;\n\t\t\tcfg.menu_skip_mask = 0;\n\n\t\t\tctx->ctrls[i] = v4l2_ctrl_new_custom(&ctx->ctrl_handler,\n\t\t\t\t\t&cfg, NULL);\n\t\t} else {\n\t\t\tctx->ctrls[i] = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t\t\t&s5p_mfc_dec_ctrl_ops,\n\t\t\t\t\tcontrols[i].id, controls[i].minimum,\n\t\t\t\t\tcontrols[i].maximum, controls[i].step,\n\t\t\t\t\tcontrols[i].default_value);\n\t\t}\n\t\tif (ctx->ctrl_handler.error) {\n\t\t\tmfc_err(\"Adding control (%d) failed\\n\", i);\n\t\t\treturn ctx->ctrl_handler.error;\n\t\t}\n\t\tif (controls[i].is_volatile && ctx->ctrls[i])\n\t\t\tctx->ctrls[i]->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\t}\n\treturn 0;\n}\n\nvoid s5p_mfc_dec_ctrls_delete(struct s5p_mfc_ctx *ctx)\n{\n\tint i;\n\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tfor (i = 0; i < NUM_CTRLS; i++)\n\t\tctx->ctrls[i] = NULL;\n}\n\nvoid s5p_mfc_dec_init(struct s5p_mfc_ctx *ctx)\n{\n\tstruct v4l2_format f;\n\tf.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H264;\n\tctx->src_fmt = find_format(&f, MFC_FMT_DEC);\n\tif (IS_MFCV8_PLUS(ctx->dev))\n\t\tf.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;\n\telse if (IS_MFCV6_PLUS(ctx->dev))\n\t\tf.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12MT_16X16;\n\telse\n\t\tf.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12MT;\n\tctx->dst_fmt = find_format(&f, MFC_FMT_RAW);\n\tmfc_debug(2, \"Default src_fmt is %p, dest_fmt is %p\\n\",\n\t\t\tctx->src_fmt, ctx->dst_fmt);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}