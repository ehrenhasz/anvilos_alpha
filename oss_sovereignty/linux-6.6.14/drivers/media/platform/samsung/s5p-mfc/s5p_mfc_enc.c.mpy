{
  "module_name": "s5p_mfc_enc.c",
  "hash_id": "49825589aacc329ab56959c9856870cc1f4db62468adee11180a211b59439a76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s5p-mfc/s5p_mfc_enc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-event.h>\n#include <linux/workqueue.h>\n#include <media/v4l2-ctrls.h>\n#include <media/videobuf2-v4l2.h>\n#include \"s5p_mfc_common.h\"\n#include \"s5p_mfc_ctrl.h\"\n#include \"s5p_mfc_debug.h\"\n#include \"s5p_mfc_enc.h\"\n#include \"s5p_mfc_intr.h\"\n#include \"s5p_mfc_opr.h\"\n\n#define DEF_SRC_FMT_ENC\tV4L2_PIX_FMT_NV12M\n#define DEF_DST_FMT_ENC\tV4L2_PIX_FMT_H264\n\nstatic struct s5p_mfc_fmt formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12MT_16X16,\n\t\t.codec_mode\t= S5P_MFC_CODEC_NONE,\n\t\t.type\t\t= MFC_FMT_RAW,\n\t\t.num_planes\t= 2,\n\t\t.versions\t= MFC_V6_BIT | MFC_V7_BIT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12MT,\n\t\t.codec_mode\t= S5P_MFC_CODEC_NONE,\n\t\t.type\t\t= MFC_FMT_RAW,\n\t\t.num_planes\t= 2,\n\t\t.versions\t= MFC_V5_BIT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12M,\n\t\t.codec_mode\t= S5P_MFC_CODEC_NONE,\n\t\t.type\t\t= MFC_FMT_RAW,\n\t\t.num_planes\t= 2,\n\t\t.versions\t= MFC_V5PLUS_BITS,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV21M,\n\t\t.codec_mode\t= S5P_MFC_CODEC_NONE,\n\t\t.type\t\t= MFC_FMT_RAW,\n\t\t.num_planes\t= 2,\n\t\t.versions\t= MFC_V6PLUS_BITS,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_H264,\n\t\t.codec_mode\t= S5P_MFC_CODEC_H264_ENC,\n\t\t.type\t\t= MFC_FMT_ENC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V5PLUS_BITS,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_MPEG4,\n\t\t.codec_mode\t= S5P_MFC_CODEC_MPEG4_ENC,\n\t\t.type\t\t= MFC_FMT_ENC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V5PLUS_BITS,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_H263,\n\t\t.codec_mode\t= S5P_MFC_CODEC_H263_ENC,\n\t\t.type\t\t= MFC_FMT_ENC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V5PLUS_BITS,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_VP8,\n\t\t.codec_mode\t= S5P_MFC_CODEC_VP8_ENC,\n\t\t.type\t\t= MFC_FMT_ENC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V7PLUS_BITS,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_HEVC,\n\t\t.codec_mode\t= S5P_FIMV_CODEC_HEVC_ENC,\n\t\t.type\t\t= MFC_FMT_ENC,\n\t\t.num_planes\t= 1,\n\t\t.versions\t= MFC_V10_BIT,\n\t},\n};\n\n#define NUM_FORMATS ARRAY_SIZE(formats)\nstatic struct s5p_mfc_fmt *find_format(struct v4l2_format *f, unsigned int t)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < NUM_FORMATS; i++) {\n\t\tif (formats[i].fourcc == f->fmt.pix_mp.pixelformat &&\n\t\t    formats[i].type == t)\n\t\t\treturn &formats[i];\n\t}\n\treturn NULL;\n}\n\nstatic struct mfc_control controls[] = {\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_GOP_SIZE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = (1 << 16) - 1,\n\t\t.step = 1,\n\t\t.default_value = 12,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE,\n\t\t.maximum = V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES,\n\t\t.default_value = V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 1,\n\t\t.maximum = (1 << 16) - 1,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 1900,\n\t\t.maximum = (1 << 30) - 1,\n\t\t.step = 1,\n\t\t.default_value = 1900,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = (1 << 16) - 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_PADDING,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"Padding Control Enable\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_PADDING_YUV,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Padding Color YUV Value\",\n\t\t.minimum = 0,\n\t\t.maximum = (1 << 25) - 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_BITRATE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 1,\n\t\t.maximum = (1 << 30) - 1,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_RC_REACTION_COEFF,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Rate Control Reaction Coeff.\",\n\t\t.minimum = 1,\n\t\t.maximum = (1 << 16) - 1,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.name = \"Force frame type\",\n\t\t.minimum = V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_DISABLED,\n\t\t.maximum = V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_NOT_CODED,\n\t\t.default_value = V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_DISABLED,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME,\n\t\t.type = V4L2_CTRL_TYPE_BUTTON,\n\t\t.minimum = 0,\n\t\t.maximum = 0,\n\t\t.step = 0,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VBV_SIZE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = (1 << 16) - 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Horizontal MV Search Range\",\n\t\t.minimum = 16,\n\t\t.maximum = 128,\n\t\t.step = 16,\n\t\t.default_value = 32,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Vertical MV Search Range\",\n\t\t.minimum = 16,\n\t\t.maximum = 128,\n\t\t.step = 16,\n\t\t.default_value = 32,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = (1 << 16) - 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEADER_MODE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE,\n\t\t.maximum = V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME,\n\t\t.default_value = V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.name = \"Frame Skip Enable\",\n\t\t.minimum = V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_DISABLED,\n\t\t.maximum = V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT,\n\t\t.menu_skip_mask = 0,\n\t\t.default_value = V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_DISABLED,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_FRAME_SKIP_MODE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.maximum = V4L2_MPEG_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT,\n\t\t.default_value = V4L2_MPEG_VIDEO_FRAME_SKIP_MODE_DISABLED,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_RC_FIXED_TARGET_BIT,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"Fixed Target Bit Enable\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.default_value = 0,\n\t\t.step = 1,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_B_FRAMES,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 2,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_PROFILE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE,\n\t\t.maximum = V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH,\n\t\t.default_value = V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE,\n\t\t.menu_skip_mask = ~(\n\t\t\t\t(1 << V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE) |\n\t\t\t\t(1 << V4L2_MPEG_VIDEO_H264_PROFILE_MAIN) |\n\t\t\t\t(1 << V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)\n\t\t\t\t),\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_LEVEL,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_H264_LEVEL_1_0,\n\t\t.maximum = V4L2_MPEG_VIDEO_H264_LEVEL_4_0,\n\t\t.default_value = V4L2_MPEG_VIDEO_H264_LEVEL_1_0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_MPEG4_LEVEL_0,\n\t\t.maximum = V4L2_MPEG_VIDEO_MPEG4_LEVEL_5,\n\t\t.default_value = V4L2_MPEG_VIDEO_MPEG4_LEVEL_0,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED,\n\t\t.maximum = V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY,\n\t\t.default_value = V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = -6,\n\t\t.maximum = 6,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = -6,\n\t\t.maximum = 6,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC,\n\t\t.maximum = V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC,\n\t\t.default_value = V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_H264_NUM_REF_PIC_FOR_P,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"The Number of Ref. Pic for P\",\n\t\t.minimum = 1,\n\t\t.maximum = 2,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_MIN_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_MAX_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 51,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"H263 I-Frame QP value\",\n\t\t.minimum = 1,\n\t\t.maximum = 31,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H263_MIN_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"H263 Minimum QP value\",\n\t\t.minimum = 1,\n\t\t.maximum = 31,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H263_MAX_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"H263 Maximum QP value\",\n\t\t.minimum = 1,\n\t\t.maximum = 31,\n\t\t.step = 1,\n\t\t.default_value = 31,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"H263 P frame QP value\",\n\t\t.minimum = 1,\n\t\t.maximum = 31,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"H263 B frame QP value\",\n\t\t.minimum = 1,\n\t\t.maximum = 31,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"MPEG4 I-Frame QP value\",\n\t\t.minimum = 1,\n\t\t.maximum = 31,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"MPEG4 Minimum QP value\",\n\t\t.minimum = 1,\n\t\t.maximum = 31,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"MPEG4 Maximum QP value\",\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 51,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"MPEG4 P frame QP value\",\n\t\t.minimum = 1,\n\t\t.maximum = 31,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"MPEG4 B frame QP value\",\n\t\t.minimum = 1,\n\t\t.maximum = 31,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_DARK,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"H264 Dark Reg Adaptive RC\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_SMOOTH,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"H264 Smooth Reg Adaptive RC\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_STATIC,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"H264 Static Reg Adaptive RC\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_ACTIVITY,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.name = \"H264 Activity Reg Adaptive RC\",\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_UNSPECIFIED,\n\t\t.maximum = V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_EXTENDED,\n\t\t.default_value = V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_UNSPECIFIED,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = (1 << 16) - 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = (1 << 16) - 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_GOP_CLOSURE,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_H264_I_PERIOD,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = (1 << 16) - 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE,\n\t\t.maximum = V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_SIMPLE,\n\t\t.default_value = V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_MPEG4_QPEL,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER_MENU,\n\t\t.maximum = V4L2_CID_MPEG_VIDEO_VPX_8_PARTITIONS,\n\t\t.default_value = V4L2_CID_MPEG_VIDEO_VPX_1_PARTITION,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER_MENU,\n\t\t.maximum = V4L2_CID_MPEG_VIDEO_VPX_2_REF_FRAME,\n\t\t.default_value = V4L2_CID_MPEG_VIDEO_VPX_1_REF_FRAME,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 63,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 7,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = (1 << 16) - 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_PREV,\n\t\t.maximum = V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_REF_PERIOD,\n\t\t.default_value = V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_PREV,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VPX_MAX_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 127,\n\t\t.step = 1,\n\t\t.default_value = 127,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VPX_MIN_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 11,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 127,\n\t\t.step = 1,\n\t\t.default_value = 10,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 127,\n\t\t.step = 1,\n\t\t.default_value = 10,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_VP8_PROFILE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_VP8_PROFILE_0,\n\t\t.maximum = V4L2_MPEG_VIDEO_VP8_PROFILE_3,\n\t\t.default_value = V4L2_MPEG_VIDEO_VP8_PROFILE_0,\n\t\t.menu_skip_mask = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"HEVC I Frame QP Value\",\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"HEVC P Frame QP Value\",\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_PROFILE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN,\n\t\t.maximum = V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE,\n\t\t.step = 1,\n\t\t.default_value = V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_LEVEL,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_HEVC_LEVEL_1,\n\t\t.maximum = V4L2_MPEG_VIDEO_HEVC_LEVEL_6_2,\n\t\t.step = 1,\n\t\t.default_value = V4L2_MPEG_VIDEO_HEVC_LEVEL_1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_TIER,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_HEVC_TIER_MAIN,\n\t\t.maximum = V4L2_MPEG_VIDEO_HEVC_TIER_HIGH,\n\t\t.step = 1,\n\t\t.default_value = V4L2_MPEG_VIDEO_HEVC_TIER_MAIN,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_FRAME_RATE_RESOLUTION,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 1,\n\t\t.maximum = (1 << 16) - 1,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_MAX_PARTITION_DEPTH,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_REF_NUMBER_FOR_PFRAMES,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 1,\n\t\t.maximum = 2,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_TYPE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_HEVC_REFRESH_NONE,\n\t\t.maximum = V4L2_MPEG_VIDEO_HEVC_REFRESH_IDR,\n\t\t.step = 1,\n\t\t.default_value = V4L2_MPEG_VIDEO_HEVC_REFRESH_NONE,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_CONST_INTRA_PRED,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_LOSSLESS_CU,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_WAVEFRONT,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED,\n\t\t.maximum = V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY,\n\t\t.step = 1,\n\t\t.default_value = V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_QP,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_TYPE,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_B,\n\t\t.maximum = V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_P,\n\t\t.step = 1,\n\t\t.default_value = V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_B,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_LAYER,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 6,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_QP,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 51,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_BR,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = INT_MIN,\n\t\t.maximum = INT_MAX,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_BR,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = INT_MIN,\n\t\t.maximum = INT_MAX,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_BR,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = INT_MIN,\n\t\t.maximum = INT_MAX,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_BR,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = INT_MIN,\n\t\t.maximum = INT_MAX,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_BR,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = INT_MIN,\n\t\t.maximum = INT_MAX,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_BR,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = INT_MIN,\n\t\t.maximum = INT_MAX,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_BR,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = INT_MIN,\n\t\t.maximum = INT_MAX,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_GENERAL_PB,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_TEMPORAL_ID,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_STRONG_SMOOTHING,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_INTRA_PU_SPLIT,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_TMV_PREDICTION,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_MAX_NUM_MERGE_MV_MINUS1,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 4,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_WITHOUT_STARTCODE,\n\t\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_PERIOD,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = (1 << 16) - 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_LF_BETA_OFFSET_DIV2,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = -6,\n\t\t.maximum = 6,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_LF_TC_OFFSET_DIV2,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = -6,\n\t\t.maximum = 6,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_SIZE_OF_LENGTH_FIELD,\n\t\t.type = V4L2_CTRL_TYPE_MENU,\n\t\t.minimum = V4L2_MPEG_VIDEO_HEVC_SIZE_0,\n\t\t.maximum = V4L2_MPEG_VIDEO_HEVC_SIZE_4,\n\t\t.step = 1,\n\t\t.default_value = V4L2_MPEG_VIDEO_HEVC_SIZE_0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MPEG_VIDEO_PREPEND_SPSPPS_TO_IDR,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.minimum = 0,\n\t\t.maximum = 1,\n\t\t.step = 1,\n\t\t.default_value = 0,\n\t},\n\t{\n\t\t.id = V4L2_CID_MIN_BUFFERS_FOR_OUTPUT,\n\t\t.type = V4L2_CTRL_TYPE_INTEGER,\n\t\t.name = \"Minimum number of output bufs\",\n\t\t.minimum = 1,\n\t\t.maximum = 32,\n\t\t.step = 1,\n\t\t.default_value = 1,\n\t\t.is_volatile = 1,\n\t},\n};\n\n#define NUM_CTRLS ARRAY_SIZE(controls)\nstatic const char * const *mfc51_get_menu(u32 id)\n{\n\tstatic const char * const mfc51_video_frame_skip[] = {\n\t\t\"Disabled\",\n\t\t\"Level Limit\",\n\t\t\"VBV/CPB Limit\",\n\t\tNULL,\n\t};\n\tstatic const char * const mfc51_video_force_frame[] = {\n\t\t\"Disabled\",\n\t\t\"I Frame\",\n\t\t\"Not Coded\",\n\t\tNULL,\n\t};\n\tswitch (id) {\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE:\n\t\treturn mfc51_video_frame_skip;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE:\n\t\treturn mfc51_video_force_frame;\n\t}\n\treturn NULL;\n}\n\nstatic int s5p_mfc_ctx_ready(struct s5p_mfc_ctx *ctx)\n{\n\tmfc_debug(2, \"src=%d, dst=%d, state=%d\\n\",\n\t\t  ctx->src_queue_cnt, ctx->dst_queue_cnt, ctx->state);\n\t \n\tif (ctx->state == MFCINST_GOT_INST && ctx->dst_queue_cnt >= 1)\n\t\treturn 1;\n\t \n\tif ((ctx->state == MFCINST_RUNNING ||\n\t\tctx->state == MFCINST_HEAD_PRODUCED) &&\n\t\tctx->src_queue_cnt >= 1 && ctx->dst_queue_cnt >= 1)\n\t\treturn 1;\n\t \n\tif (ctx->state == MFCINST_FINISHING &&\n\t\tctx->dst_queue_cnt >= 1)\n\t\treturn 1;\n\tmfc_debug(2, \"ctx is not ready\\n\");\n\treturn 0;\n}\n\nstatic void cleanup_ref_queue(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_buf *mb_entry;\n\n\t \n\twhile (!list_empty(&ctx->ref_queue)) {\n\t\tmb_entry = list_entry((&ctx->ref_queue)->next,\n\t\t\t\t\t\tstruct s5p_mfc_buf, list);\n\t\tlist_del(&mb_entry->list);\n\t\tctx->ref_queue_cnt--;\n\t\tlist_add_tail(&mb_entry->list, &ctx->src_queue);\n\t\tctx->src_queue_cnt++;\n\t}\n\tmfc_debug(2, \"enc src count: %d, enc ref count: %d\\n\",\n\t\t  ctx->src_queue_cnt, ctx->ref_queue_cnt);\n\tINIT_LIST_HEAD(&ctx->ref_queue);\n\tctx->ref_queue_cnt = 0;\n}\n\nstatic int enc_pre_seq_start(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *dst_mb;\n\tunsigned long dst_addr;\n\tunsigned int dst_size;\n\n\tdst_mb = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf, list);\n\tdst_addr = vb2_dma_contig_plane_dma_addr(&dst_mb->b->vb2_buf, 0);\n\tdst_size = vb2_plane_size(&dst_mb->b->vb2_buf, 0);\n\ts5p_mfc_hw_call(dev->mfc_ops, set_enc_stream_buffer, ctx, dst_addr,\n\t\t\tdst_size);\n\treturn 0;\n}\n\nstatic int enc_post_seq_start(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tstruct s5p_mfc_buf *dst_mb;\n\tunsigned int enc_pb_count;\n\n\tif (p->seq_hdr_mode == V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE) {\n\t\tif (!list_empty(&ctx->dst_queue)) {\n\t\t\tdst_mb = list_entry(ctx->dst_queue.next,\n\t\t\t\t\tstruct s5p_mfc_buf, list);\n\t\t\tlist_del(&dst_mb->list);\n\t\t\tctx->dst_queue_cnt--;\n\t\t\tvb2_set_plane_payload(&dst_mb->b->vb2_buf, 0,\n\t\t\t\ts5p_mfc_hw_call(dev->mfc_ops, get_enc_strm_size,\n\t\t\t\t\t\tdev));\n\t\t\tvb2_buffer_done(&dst_mb->b->vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_DONE);\n\t\t}\n\t}\n\n\tif (!IS_MFCV6_PLUS(dev)) {\n\t\tctx->state = MFCINST_RUNNING;\n\t\tif (s5p_mfc_ctx_ready(ctx))\n\t\t\tset_work_bit_irqsave(ctx);\n\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\t} else {\n\t\tenc_pb_count = s5p_mfc_hw_call(dev->mfc_ops,\n\t\t\t\tget_enc_dpb_count, dev);\n\t\tif (ctx->pb_count < enc_pb_count)\n\t\t\tctx->pb_count = enc_pb_count;\n\t\tif (FW_HAS_E_MIN_SCRATCH_BUF(dev)) {\n\t\t\tctx->scratch_buf_size = s5p_mfc_hw_call(dev->mfc_ops,\n\t\t\t\t\tget_e_min_scratch_buf_size, dev);\n\t\t\tctx->bank1.size += ctx->scratch_buf_size;\n\t\t}\n\t\tctx->state = MFCINST_HEAD_PRODUCED;\n\t}\n\n\treturn 0;\n}\n\nstatic int enc_pre_frame_start(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *dst_mb;\n\tstruct s5p_mfc_buf *src_mb;\n\tunsigned long src_y_addr, src_c_addr, dst_addr;\n\tunsigned int dst_size;\n\n\tsrc_mb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\n\tsrc_y_addr = vb2_dma_contig_plane_dma_addr(&src_mb->b->vb2_buf, 0);\n\tsrc_c_addr = vb2_dma_contig_plane_dma_addr(&src_mb->b->vb2_buf, 1);\n\ts5p_mfc_hw_call(dev->mfc_ops, set_enc_frame_buffer, ctx,\n\t\t\t\t\t\t\tsrc_y_addr, src_c_addr);\n\n\tdst_mb = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf, list);\n\tdst_addr = vb2_dma_contig_plane_dma_addr(&dst_mb->b->vb2_buf, 0);\n\tdst_size = vb2_plane_size(&dst_mb->b->vb2_buf, 0);\n\ts5p_mfc_hw_call(dev->mfc_ops, set_enc_stream_buffer, ctx, dst_addr,\n\t\t\tdst_size);\n\n\treturn 0;\n}\n\nstatic int enc_post_frame_start(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *mb_entry;\n\tunsigned long enc_y_addr = 0, enc_c_addr = 0;\n\tunsigned long mb_y_addr, mb_c_addr;\n\tint slice_type;\n\tunsigned int strm_size;\n\tbool src_ready;\n\n\tslice_type = s5p_mfc_hw_call(dev->mfc_ops, get_enc_slice_type, dev);\n\tstrm_size = s5p_mfc_hw_call(dev->mfc_ops, get_enc_strm_size, dev);\n\tmfc_debug(2, \"Encoded slice type: %d\\n\", slice_type);\n\tmfc_debug(2, \"Encoded stream size: %d\\n\", strm_size);\n\tmfc_debug(2, \"Display order: %d\\n\",\n\t\t  mfc_read(dev, S5P_FIMV_ENC_SI_PIC_CNT));\n\tif (slice_type >= 0) {\n\t\ts5p_mfc_hw_call(dev->mfc_ops, get_enc_frame_buffer, ctx,\n\t\t\t\t&enc_y_addr, &enc_c_addr);\n\t\tlist_for_each_entry(mb_entry, &ctx->src_queue, list) {\n\t\t\tmb_y_addr = vb2_dma_contig_plane_dma_addr(\n\t\t\t\t\t&mb_entry->b->vb2_buf, 0);\n\t\t\tmb_c_addr = vb2_dma_contig_plane_dma_addr(\n\t\t\t\t\t&mb_entry->b->vb2_buf, 1);\n\t\t\tif ((enc_y_addr == mb_y_addr) &&\n\t\t\t\t\t\t(enc_c_addr == mb_c_addr)) {\n\t\t\t\tlist_del(&mb_entry->list);\n\t\t\t\tctx->src_queue_cnt--;\n\t\t\t\tvb2_buffer_done(&mb_entry->b->vb2_buf,\n\t\t\t\t\t\t\tVB2_BUF_STATE_DONE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist_for_each_entry(mb_entry, &ctx->ref_queue, list) {\n\t\t\tmb_y_addr = vb2_dma_contig_plane_dma_addr(\n\t\t\t\t\t&mb_entry->b->vb2_buf, 0);\n\t\t\tmb_c_addr = vb2_dma_contig_plane_dma_addr(\n\t\t\t\t\t&mb_entry->b->vb2_buf, 1);\n\t\t\tif ((enc_y_addr == mb_y_addr) &&\n\t\t\t\t\t\t(enc_c_addr == mb_c_addr)) {\n\t\t\t\tlist_del(&mb_entry->list);\n\t\t\t\tctx->ref_queue_cnt--;\n\t\t\t\tvb2_buffer_done(&mb_entry->b->vb2_buf,\n\t\t\t\t\t\t\tVB2_BUF_STATE_DONE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (ctx->src_queue_cnt > 0 && (ctx->state == MFCINST_RUNNING ||\n\t\t\t\t       ctx->state == MFCINST_FINISHING)) {\n\t\tmb_entry = list_entry(ctx->src_queue.next, struct s5p_mfc_buf,\n\t\t\t\t\t\t\t\t\tlist);\n\t\tif (mb_entry->flags & MFC_BUF_FLAG_USED) {\n\t\t\tlist_del(&mb_entry->list);\n\t\t\tctx->src_queue_cnt--;\n\t\t\tlist_add_tail(&mb_entry->list, &ctx->ref_queue);\n\t\t\tctx->ref_queue_cnt++;\n\t\t}\n\t}\n\tmfc_debug(2, \"enc src count: %d, enc ref count: %d\\n\",\n\t\t  ctx->src_queue_cnt, ctx->ref_queue_cnt);\n\tif ((ctx->dst_queue_cnt > 0) && (strm_size > 0)) {\n\t\tmb_entry = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf,\n\t\t\t\t\t\t\t\t\tlist);\n\t\tlist_del(&mb_entry->list);\n\t\tctx->dst_queue_cnt--;\n\t\tswitch (slice_type) {\n\t\tcase S5P_FIMV_ENC_SI_SLICE_TYPE_I:\n\t\t\tmb_entry->b->flags |= V4L2_BUF_FLAG_KEYFRAME;\n\t\t\tbreak;\n\t\tcase S5P_FIMV_ENC_SI_SLICE_TYPE_P:\n\t\t\tmb_entry->b->flags |= V4L2_BUF_FLAG_PFRAME;\n\t\t\tbreak;\n\t\tcase S5P_FIMV_ENC_SI_SLICE_TYPE_B:\n\t\t\tmb_entry->b->flags |= V4L2_BUF_FLAG_BFRAME;\n\t\t\tbreak;\n\t\t}\n\t\tvb2_set_plane_payload(&mb_entry->b->vb2_buf, 0, strm_size);\n\t\tvb2_buffer_done(&mb_entry->b->vb2_buf, VB2_BUF_STATE_DONE);\n\t}\n\n\tsrc_ready = true;\n\tif (ctx->state == MFCINST_RUNNING && ctx->src_queue_cnt == 0)\n\t\tsrc_ready = false;\n\tif (ctx->state == MFCINST_FINISHING && ctx->ref_queue_cnt == 0)\n\t\tsrc_ready = false;\n\tif (!src_ready || ctx->dst_queue_cnt == 0)\n\t\tclear_work_bit(ctx);\n\n\treturn 0;\n}\n\nstatic const struct s5p_mfc_codec_ops encoder_codec_ops = {\n\t.pre_seq_start\t\t= enc_pre_seq_start,\n\t.post_seq_start\t\t= enc_post_seq_start,\n\t.pre_frame_start\t= enc_pre_frame_start,\n\t.post_frame_start\t= enc_post_frame_start,\n};\n\n \nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct s5p_mfc_dev *dev = video_drvdata(file);\n\n\tstrscpy(cap->driver, S5P_MFC_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, dev->vfd_enc->name, sizeof(cap->card));\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt(struct file *file, struct v4l2_fmtdesc *f,\n\t\t\t\t\t\t\tbool out)\n{\n\tstruct s5p_mfc_dev *dev = video_drvdata(file);\n\tint i, j = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); ++i) {\n\t\tif (out && formats[i].type != MFC_FMT_RAW)\n\t\t\tcontinue;\n\t\telse if (!out && formats[i].type != MFC_FMT_ENC)\n\t\t\tcontinue;\n\t\telse if ((dev->variant->version_bit & formats[i].versions) == 0)\n\t\t\tcontinue;\n\n\t\tif (j == f->index) {\n\t\t\tf->pixelformat = formats[i].fourcc;\n\t\t\treturn 0;\n\t\t}\n\t\t++j;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *pirv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn vidioc_enum_fmt(file, f, false);\n}\n\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn vidioc_enum_fmt(file, f, true);\n}\n\nstatic int vidioc_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\n\n\tmfc_debug(2, \"f->type = %d ctx->state = %d\\n\", f->type, ctx->state);\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\t \n\t\tpix_fmt_mp->width = 0;\n\t\tpix_fmt_mp->height = 0;\n\t\tpix_fmt_mp->field = V4L2_FIELD_NONE;\n\t\tpix_fmt_mp->pixelformat = ctx->dst_fmt->fourcc;\n\t\tpix_fmt_mp->num_planes = ctx->dst_fmt->num_planes;\n\n\t\tpix_fmt_mp->plane_fmt[0].bytesperline = ctx->enc_dst_buf_size;\n\t\tpix_fmt_mp->plane_fmt[0].sizeimage = ctx->enc_dst_buf_size;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\t \n\t\tpix_fmt_mp->width = ctx->img_width;\n\t\tpix_fmt_mp->height = ctx->img_height;\n\n\t\tpix_fmt_mp->field = V4L2_FIELD_NONE;\n\t\tpix_fmt_mp->pixelformat = ctx->src_fmt->fourcc;\n\t\tpix_fmt_mp->num_planes = ctx->src_fmt->num_planes;\n\n\t\tpix_fmt_mp->plane_fmt[0].bytesperline = ctx->buf_width;\n\t\tpix_fmt_mp->plane_fmt[0].sizeimage = ctx->luma_size;\n\t\tpix_fmt_mp->plane_fmt[1].bytesperline = ctx->buf_width;\n\t\tpix_fmt_mp->plane_fmt[1].sizeimage = ctx->chroma_size;\n\t} else {\n\t\tmfc_err(\"invalid buf type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct s5p_mfc_dev *dev = video_drvdata(file);\n\tstruct s5p_mfc_fmt *fmt;\n\tstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tfmt = find_format(f, MFC_FMT_ENC);\n\t\tif (!fmt) {\n\t\t\tmfc_err(\"failed to try output format\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((dev->variant->version_bit & fmt->versions) == 0) {\n\t\t\tmfc_err(\"Unsupported format by this MFC version.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpix_fmt_mp->plane_fmt[0].bytesperline =\n\t\t\tpix_fmt_mp->plane_fmt[0].sizeimage;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tfmt = find_format(f, MFC_FMT_RAW);\n\t\tif (!fmt) {\n\t\t\tmfc_err(\"failed to try output format\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((dev->variant->version_bit & fmt->versions) == 0) {\n\t\t\tmfc_err(\"Unsupported format by this MFC version.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tv4l_bound_align_image(&pix_fmt_mp->width, 8, 1920, 1,\n\t\t\t&pix_fmt_mp->height, 4, 1080, 1, 0);\n\t} else {\n\t\tmfc_err(\"invalid buf type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct s5p_mfc_dev *dev = video_drvdata(file);\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\n\tint ret = 0;\n\n\tret = vidioc_try_fmt(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\tif (ctx->vq_src.streaming || ctx->vq_dst.streaming) {\n\t\tv4l2_err(&dev->v4l2_dev, \"%s queue busy\\n\", __func__);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\t \n\t\tctx->dst_fmt = find_format(f, MFC_FMT_ENC);\n\t\tctx->state = MFCINST_INIT;\n\t\tctx->codec_mode = ctx->dst_fmt->codec_mode;\n\t\tctx->enc_dst_buf_size =\tpix_fmt_mp->plane_fmt[0].sizeimage;\n\t\tpix_fmt_mp->plane_fmt[0].bytesperline = 0;\n\t\tctx->dst_bufs_cnt = 0;\n\t\tctx->capture_state = QUEUE_FREE;\n\t\tret = s5p_mfc_open_mfc_inst(dev, ctx);\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\t \n\t\tctx->src_fmt = find_format(f, MFC_FMT_RAW);\n\t\tctx->img_width = pix_fmt_mp->width;\n\t\tctx->img_height = pix_fmt_mp->height;\n\t\tmfc_debug(2, \"codec number: %d\\n\", ctx->src_fmt->codec_mode);\n\t\tmfc_debug(2, \"fmt - w: %d, h: %d, ctx - w: %d, h: %d\\n\",\n\t\t\tpix_fmt_mp->width, pix_fmt_mp->height,\n\t\t\tctx->img_width, ctx->img_height);\n\n\t\ts5p_mfc_hw_call(dev->mfc_ops, enc_calc_src_size, ctx);\n\t\tpix_fmt_mp->plane_fmt[0].sizeimage = ctx->luma_size;\n\t\tpix_fmt_mp->plane_fmt[0].bytesperline = ctx->buf_width;\n\t\tpix_fmt_mp->plane_fmt[1].sizeimage = ctx->chroma_size;\n\t\tpix_fmt_mp->plane_fmt[1].bytesperline = ctx->buf_width;\n\n\t\tctx->src_bufs_cnt = 0;\n\t\tctx->output_state = QUEUE_FREE;\n\t} else {\n\t\tmfc_err(\"invalid buf type\\n\");\n\t\tret = -EINVAL;\n\t}\nout:\n\tmfc_debug_leave();\n\treturn ret;\n}\n\nstatic int vidioc_reqbufs(struct file *file, void *priv,\n\t\t\t\t\t  struct v4l2_requestbuffers *reqbufs)\n{\n\tstruct s5p_mfc_dev *dev = video_drvdata(file);\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tint ret = 0;\n\n\t \n\tif ((reqbufs->memory != V4L2_MEMORY_MMAP) &&\n\t\t(reqbufs->memory != V4L2_MEMORY_USERPTR))\n\t\treturn -EINVAL;\n\tif (reqbufs->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tif (reqbufs->count == 0) {\n\t\t\tmfc_debug(2, \"Freeing buffers\\n\");\n\t\t\tret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, release_codec_buffers,\n\t\t\t\t\tctx);\n\t\t\tctx->capture_state = QUEUE_FREE;\n\t\t\treturn ret;\n\t\t}\n\t\tif (ctx->capture_state != QUEUE_FREE) {\n\t\t\tmfc_err(\"invalid capture state: %d\\n\",\n\t\t\t\t\t\t\tctx->capture_state);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\n\t\tif (ret != 0) {\n\t\t\tmfc_err(\"error in vb2_reqbufs() for E(D)\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tctx->capture_state = QUEUE_BUFS_REQUESTED;\n\n\t\tret = s5p_mfc_hw_call(ctx->dev->mfc_ops,\n\t\t\t\talloc_codec_buffers, ctx);\n\t\tif (ret) {\n\t\t\tmfc_err(\"Failed to allocate encoding buffers\\n\");\n\t\t\treqbufs->count = 0;\n\t\t\tret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else if (reqbufs->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tif (reqbufs->count == 0) {\n\t\t\tmfc_debug(2, \"Freeing buffers\\n\");\n\t\t\tret = vb2_reqbufs(&ctx->vq_src, reqbufs);\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, release_codec_buffers,\n\t\t\t\t\tctx);\n\t\t\tctx->output_state = QUEUE_FREE;\n\t\t\treturn ret;\n\t\t}\n\t\tif (ctx->output_state != QUEUE_FREE) {\n\t\t\tmfc_err(\"invalid output state: %d\\n\",\n\t\t\t\t\t\t\tctx->output_state);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IS_MFCV6_PLUS(dev)) {\n\t\t\t \n\t\t\tif (ctx->pb_count &&\n\t\t\t\t(reqbufs->count < ctx->pb_count)) {\n\t\t\t\treqbufs->count = ctx->pb_count;\n\t\t\t\tmfc_debug(2, \"Minimum %d output buffers needed\\n\",\n\t\t\t\t\t\tctx->pb_count);\n\t\t\t} else {\n\t\t\t\tctx->pb_count = reqbufs->count;\n\t\t\t}\n\t\t}\n\n\t\tret = vb2_reqbufs(&ctx->vq_src, reqbufs);\n\t\tif (ret != 0) {\n\t\t\tmfc_err(\"error in vb2_reqbufs() for E(S)\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tctx->output_state = QUEUE_BUFS_REQUESTED;\n\t} else {\n\t\tmfc_err(\"invalid buf type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int vidioc_querybuf(struct file *file, void *priv,\n\t\t\t\t\t\t   struct v4l2_buffer *buf)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tint ret = 0;\n\n\t \n\tif ((buf->memory != V4L2_MEMORY_MMAP) &&\n\t\t(buf->memory != V4L2_MEMORY_USERPTR))\n\t\treturn -EINVAL;\n\tif (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tif (ctx->state != MFCINST_GOT_INST) {\n\t\t\tmfc_err(\"invalid context state: %d\\n\", ctx->state);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = vb2_querybuf(&ctx->vq_dst, buf);\n\t\tif (ret != 0) {\n\t\t\tmfc_err(\"error in vb2_querybuf() for E(D)\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbuf->m.planes[0].m.mem_offset += DST_QUEUE_OFF_BASE;\n\t} else if (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tret = vb2_querybuf(&ctx->vq_src, buf);\n\t\tif (ret != 0) {\n\t\t\tmfc_err(\"error in vb2_querybuf() for E(S)\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tmfc_err(\"invalid buf type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}\n\n \nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\n\tif (ctx->state == MFCINST_ERROR) {\n\t\tmfc_err(\"Call on QBUF after unrecoverable error\\n\");\n\t\treturn -EIO;\n\t}\n\tif (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tif (ctx->state == MFCINST_FINISHING) {\n\t\t\tmfc_err(\"Call on QBUF after EOS command\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn vb2_qbuf(&ctx->vq_src, NULL, buf);\n\t} else if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\treturn vb2_qbuf(&ctx->vq_dst, NULL, buf);\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\n{\n\tconst struct v4l2_event ev = {\n\t\t.type = V4L2_EVENT_EOS\n\t};\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tint ret;\n\n\tif (ctx->state == MFCINST_ERROR) {\n\t\tmfc_err_limited(\"Call on DQBUF after unrecoverable error\\n\");\n\t\treturn -EIO;\n\t}\n\tif (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tret = vb2_dqbuf(&ctx->vq_src, buf, file->f_flags & O_NONBLOCK);\n\t} else if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tret = vb2_dqbuf(&ctx->vq_dst, buf, file->f_flags & O_NONBLOCK);\n\t\tif (ret == 0 && ctx->state == MFCINST_FINISHED\n\t\t\t\t\t&& list_empty(&ctx->vq_dst.done_list))\n\t\t\tv4l2_event_queue_fh(&ctx->fh, &ev);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int vidioc_expbuf(struct file *file, void *priv,\n\tstruct v4l2_exportbuffer *eb)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\n\tif (eb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn vb2_expbuf(&ctx->vq_src, eb);\n\tif (eb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn vb2_expbuf(&ctx->vq_dst, eb);\n\treturn -EINVAL;\n}\n\n \nstatic int vidioc_streamon(struct file *file, void *priv,\n\t\t\t   enum v4l2_buf_type type)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn vb2_streamon(&ctx->vq_src, type);\n\telse if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn vb2_streamon(&ctx->vq_dst, type);\n\treturn -EINVAL;\n}\n\n \nstatic int vidioc_streamoff(struct file *file, void *priv,\n\t\t\t    enum v4l2_buf_type type)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn vb2_streamoff(&ctx->vq_src, type);\n\telse if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn vb2_streamoff(&ctx->vq_dst, type);\n\treturn -EINVAL;\n}\n\nstatic inline int h264_level(enum v4l2_mpeg_video_h264_level lvl)\n{\n\tstatic unsigned int t[V4L2_MPEG_VIDEO_H264_LEVEL_4_0 + 1] = {\n\t\t  10,\n\t\t  9,\n\t\t  11,\n\t\t  12,\n\t\t  13,\n\t\t  20,\n\t\t  21,\n\t\t  22,\n\t\t  30,\n\t\t  31,\n\t\t  32,\n\t\t  40,\n\t};\n\treturn t[lvl];\n}\n\nstatic inline int mpeg4_level(enum v4l2_mpeg_video_mpeg4_level lvl)\n{\n\tstatic unsigned int t[V4L2_MPEG_VIDEO_MPEG4_LEVEL_5 + 1] = {\n\t\t  0,\n\t\t  9,\n\t\t  1,\n\t\t  2,\n\t\t  3,\n\t\t  7,\n\t\t  4,\n\t\t  5,\n\t};\n\treturn t[lvl];\n}\n\nstatic inline int hevc_level(enum v4l2_mpeg_video_hevc_level lvl)\n{\n\tstatic unsigned int t[] = {\n\t\t  10,\n\t\t  20,\n\t\t  21,\n\t\t  30,\n\t\t  31,\n\t\t  40,\n\t\t  41,\n\t\t  50,\n\t\t  51,\n\t\t  52,\n\t\t  60,\n\t\t  61,\n\t\t  62,\n\t};\n\treturn t[lvl];\n}\n\nstatic inline int vui_sar_idc(enum v4l2_mpeg_video_h264_vui_sar_idc sar)\n{\n\tstatic unsigned int t[V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_EXTENDED + 1] = {\n\t\t  0,\n\t\t  1,\n\t\t  2,\n\t\t  3,\n\t\t  4,\n\t\t  5,\n\t\t  6,\n\t\t  7,\n\t\t  8,\n\t\t  9,\n\t\t  10,\n\t\t  11,\n\t\t  12,\n\t\t  13,\n\t\t  14,\n\t\t  15,\n\t\t  16,\n\t\t  255,\n\t};\n\treturn t[sar];\n}\n\n \nstatic void __enc_update_hevc_qp_ctrls_range(struct s5p_mfc_ctx *ctx,\n\t\t\t\t\t     int min, int max)\n{\n\tstatic const int __hevc_qp_ctrls[] = {\n\t\tV4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP,\n\t\tV4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP,\n\t\tV4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP,\n\t\tV4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_QP,\n\t\tV4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_QP,\n\t\tV4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_QP,\n\t\tV4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_QP,\n\t\tV4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_QP,\n\t\tV4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_QP,\n\t\tV4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_QP,\n\t};\n\tstruct v4l2_ctrl *ctrl = NULL;\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(__hevc_qp_ctrls); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(ctx->ctrls); j++) {\n\t\t\tif (ctx->ctrls[j]->id == __hevc_qp_ctrls[i]) {\n\t\t\t\tctrl = ctx->ctrls[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (WARN_ON(!ctrl))\n\t\t\tbreak;\n\n\t\t__v4l2_ctrl_modify_range(ctrl, min, max, ctrl->step, min);\n\t}\n}\n\nstatic int s5p_mfc_enc_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct s5p_mfc_ctx *ctx = ctrl_to_ctx(ctrl);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\n\t\tp->gop_size = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:\n\t\tp->slice_mode = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB:\n\t\tp->slice_mb = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES:\n\t\tp->slice_bit = ctrl->val * 8;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB:\n\t\tp->intra_refresh_mb = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_PADDING:\n\t\tp->pad = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_PADDING_YUV:\n\t\tp->pad_luma = (ctrl->val >> 16) & 0xff;\n\t\tp->pad_cb = (ctrl->val >> 8) & 0xff;\n\t\tp->pad_cr = (ctrl->val >> 0) & 0xff;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:\n\t\tp->rc_frame = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE:\n\t\tp->rc_bitrate = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_RC_REACTION_COEFF:\n\t\tp->rc_reaction_coeff = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE:\n\t\tctx->force_frame_type = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME:\n\t\tctx->force_frame_type =\n\t\t\tV4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_I_FRAME;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VBV_SIZE:\n\t\tp->vbv_size = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE:\n\t\tp->mv_h_range = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE:\n\t\tp->mv_v_range = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE:\n\t\tp->codec.h264.cpb_size = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEADER_MODE:\n\t\tp->seq_hdr_mode = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE:\n\tcase V4L2_CID_MPEG_VIDEO_FRAME_SKIP_MODE:\n\t\tp->frame_skip_mode = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_RC_FIXED_TARGET_BIT:\n\t\tp->fixed_target_bit = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_B_FRAMES:\n\t\tp->num_b_frame = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_PROFILE:\n\t\tswitch (ctrl->val) {\n\t\tcase V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:\n\t\t\tp->codec.h264.profile =\n\t\t\t\t\tS5P_FIMV_ENC_PROFILE_H264_MAIN;\n\t\t\tbreak;\n\t\tcase V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:\n\t\t\tp->codec.h264.profile =\n\t\t\t\t\tS5P_FIMV_ENC_PROFILE_H264_HIGH;\n\t\t\tbreak;\n\t\tcase V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:\n\t\t\tp->codec.h264.profile =\n\t\t\t\tS5P_FIMV_ENC_PROFILE_H264_BASELINE;\n\t\t\tbreak;\n\t\tcase V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE:\n\t\t\tif (IS_MFCV6_PLUS(dev))\n\t\t\t\tp->codec.h264.profile =\n\t\t\t\tS5P_FIMV_ENC_PROFILE_H264_CONSTRAINED_BASELINE;\n\t\t\telse\n\t\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_LEVEL:\n\t\tp->codec.h264.level_v4l2 = ctrl->val;\n\t\tp->codec.h264.level = h264_level(ctrl->val);\n\t\tif (p->codec.h264.level < 0) {\n\t\t\tmfc_err(\"Level number is wrong\\n\");\n\t\t\tret = p->codec.h264.level;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL:\n\t\tp->codec.mpeg4.level_v4l2 = ctrl->val;\n\t\tp->codec.mpeg4.level = mpeg4_level(ctrl->val);\n\t\tif (p->codec.mpeg4.level < 0) {\n\t\t\tmfc_err(\"Level number is wrong\\n\");\n\t\t\tret = p->codec.mpeg4.level;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE:\n\t\tp->codec.h264.loop_filter_mode = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA:\n\t\tp->codec.h264.loop_filter_alpha = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA:\n\t\tp->codec.h264.loop_filter_beta = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:\n\t\tp->codec.h264.entropy_mode = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_H264_NUM_REF_PIC_FOR_P:\n\t\tp->codec.h264.num_ref_pic_4p = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM:\n\t\tp->codec.h264._8x8_transform = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE:\n\t\tp->rc_mb = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP:\n\t\tp->codec.h264.rc_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_MIN_QP:\n\t\tp->codec.h264.rc_min_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_MAX_QP:\n\t\tp->codec.h264.rc_max_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP:\n\t\tp->codec.h264.rc_p_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP:\n\t\tp->codec.h264.rc_b_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP:\n\tcase V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP:\n\t\tp->codec.mpeg4.rc_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP:\n\tcase V4L2_CID_MPEG_VIDEO_H263_MIN_QP:\n\t\tp->codec.mpeg4.rc_min_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP:\n\tcase V4L2_CID_MPEG_VIDEO_H263_MAX_QP:\n\t\tp->codec.mpeg4.rc_max_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP:\n\tcase V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP:\n\t\tp->codec.mpeg4.rc_p_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP:\n\tcase V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP:\n\t\tp->codec.mpeg4.rc_b_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_DARK:\n\t\tp->codec.h264.rc_mb_dark = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_SMOOTH:\n\t\tp->codec.h264.rc_mb_smooth = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_STATIC:\n\t\tp->codec.h264.rc_mb_static = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_ACTIVITY:\n\t\tp->codec.h264.rc_mb_activity = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE:\n\t\tp->codec.h264.vui_sar = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:\n\t\tp->codec.h264.vui_sar_idc = vui_sar_idc(ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH:\n\t\tp->codec.h264.vui_ext_sar_width = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT:\n\t\tp->codec.h264.vui_ext_sar_height = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_GOP_CLOSURE:\n\t\tp->codec.h264.open_gop = !ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_I_PERIOD:\n\t\tp->codec.h264.open_gop_size = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE:\n\t\tswitch (ctrl->val) {\n\t\tcase V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE:\n\t\t\tp->codec.mpeg4.profile =\n\t\t\t\tS5P_FIMV_ENC_PROFILE_MPEG4_SIMPLE;\n\t\t\tbreak;\n\t\tcase V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_SIMPLE:\n\t\t\tp->codec.mpeg4.profile =\n\t\t\tS5P_FIMV_ENC_PROFILE_MPEG4_ADVANCED_SIMPLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MPEG4_QPEL:\n\t\tp->codec.mpeg4.quarter_pixel = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS:\n\t\tp->codec.vp8.num_partitions = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4:\n\t\tp->codec.vp8.imd_4x4 = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES:\n\t\tp->codec.vp8.num_ref = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL:\n\t\tp->codec.vp8.filter_level = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS:\n\t\tp->codec.vp8.filter_sharpness = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD:\n\t\tp->codec.vp8.golden_frame_ref_period = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL:\n\t\tp->codec.vp8.golden_frame_sel = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_MIN_QP:\n\t\tp->codec.vp8.rc_min_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_MAX_QP:\n\t\tp->codec.vp8.rc_max_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP:\n\t\tp->codec.vp8.rc_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP:\n\t\tp->codec.vp8.rc_p_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VP8_PROFILE:\n\t\tp->codec.vp8.profile = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP:\n\t\tp->codec.hevc.rc_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP:\n\t\tp->codec.hevc.rc_p_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP:\n\t\tp->codec.hevc.rc_b_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_FRAME_RATE_RESOLUTION:\n\t\tp->codec.hevc.rc_framerate = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP:\n\t\tp->codec.hevc.rc_min_qp = ctrl->val;\n\t\t__enc_update_hevc_qp_ctrls_range(ctx, ctrl->val,\n\t\t\t\t\t\t p->codec.hevc.rc_max_qp);\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP:\n\t\tp->codec.hevc.rc_max_qp = ctrl->val;\n\t\t__enc_update_hevc_qp_ctrls_range(ctx, p->codec.hevc.rc_min_qp,\n\t\t\t\t\t\t ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_LEVEL:\n\t\tp->codec.hevc.level_v4l2 = ctrl->val;\n\t\tp->codec.hevc.level = hevc_level(ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_PROFILE:\n\t\tswitch (ctrl->val) {\n\t\tcase V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN:\n\t\t\tp->codec.hevc.profile =\n\t\t\t\tV4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN;\n\t\t\tbreak;\n\t\tcase V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE:\n\t\t\tp->codec.hevc.profile =\n\t\t\tV4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_TIER:\n\t\tp->codec.hevc.tier = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_MAX_PARTITION_DEPTH:\n\t\tp->codec.hevc.max_partition_depth = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_REF_NUMBER_FOR_PFRAMES:\n\t\tp->codec.hevc.num_refs_for_p = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_TYPE:\n\t\tp->codec.hevc.refreshtype = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_CONST_INTRA_PRED:\n\t\tp->codec.hevc.const_intra_period_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_LOSSLESS_CU:\n\t\tp->codec.hevc.lossless_cu_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_WAVEFRONT:\n\t\tp->codec.hevc.wavefront_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE:\n\t\tp->codec.hevc.loopfilter = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_QP:\n\t\tp->codec.hevc.hier_qp_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_TYPE:\n\t\tp->codec.hevc.hier_qp_type = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_LAYER:\n\t\tp->codec.hevc.num_hier_layer = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_QP:\n\t\tp->codec.hevc.hier_qp_layer[0] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_QP:\n\t\tp->codec.hevc.hier_qp_layer[1] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_QP:\n\t\tp->codec.hevc.hier_qp_layer[2] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_QP:\n\t\tp->codec.hevc.hier_qp_layer[3] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_QP:\n\t\tp->codec.hevc.hier_qp_layer[4] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_QP:\n\t\tp->codec.hevc.hier_qp_layer[5] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_QP:\n\t\tp->codec.hevc.hier_qp_layer[6] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_BR:\n\t\tp->codec.hevc.hier_bit_layer[0] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_BR:\n\t\tp->codec.hevc.hier_bit_layer[1] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_BR:\n\t\tp->codec.hevc.hier_bit_layer[2] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_BR:\n\t\tp->codec.hevc.hier_bit_layer[3] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_BR:\n\t\tp->codec.hevc.hier_bit_layer[4] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_BR:\n\t\tp->codec.hevc.hier_bit_layer[5] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_BR:\n\t\tp->codec.hevc.hier_bit_layer[6] = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_GENERAL_PB:\n\t\tp->codec.hevc.general_pb_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_TEMPORAL_ID:\n\t\tp->codec.hevc.temporal_id_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_STRONG_SMOOTHING:\n\t\tp->codec.hevc.strong_intra_smooth = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_INTRA_PU_SPLIT:\n\t\tp->codec.hevc.intra_pu_split_disable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_TMV_PREDICTION:\n\t\tp->codec.hevc.tmv_prediction_disable = !ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_MAX_NUM_MERGE_MV_MINUS1:\n\t\tp->codec.hevc.max_num_merge_mv = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_WITHOUT_STARTCODE:\n\t\tp->codec.hevc.encoding_nostartcode_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_PERIOD:\n\t\tp->codec.hevc.refreshperiod = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_LF_BETA_OFFSET_DIV2:\n\t\tp->codec.hevc.lf_beta_offset_div2 = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_LF_TC_OFFSET_DIV2:\n\t\tp->codec.hevc.lf_tc_offset_div2 = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEVC_SIZE_OF_LENGTH_FIELD:\n\t\tp->codec.hevc.size_of_length_field = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_PREPEND_SPSPPS_TO_IDR:\n\t\tp->codec.hevc.prepend_sps_pps_to_idr = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\tv4l2_err(&dev->v4l2_dev, \"Invalid control, id=%d, val=%d\\n\",\n\t\t\t\t\t\t\tctrl->id, ctrl->val);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int s5p_mfc_enc_g_v_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct s5p_mfc_ctx *ctx = ctrl_to_ctx(ctrl);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:\n\t\tif (ctx->state >= MFCINST_HEAD_PARSED &&\n\t\t    ctx->state < MFCINST_ABORT) {\n\t\t\tctrl->val = ctx->pb_count;\n\t\t\tbreak;\n\t\t} else if (ctx->state != MFCINST_INIT) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"Encoding not initialised\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\ts5p_mfc_wait_for_done_ctx(ctx,\n\t\t\t\tS5P_MFC_R2H_CMD_SEQ_DONE_RET, 0);\n\t\tif (ctx->state >= MFCINST_HEAD_PARSED &&\n\t\t    ctx->state < MFCINST_ABORT) {\n\t\t\tctrl->val = ctx->pb_count;\n\t\t} else {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"Encoding not initialised\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops s5p_mfc_enc_ctrl_ops = {\n\t.s_ctrl = s5p_mfc_enc_s_ctrl,\n\t.g_volatile_ctrl = s5p_mfc_enc_g_v_ctrl,\n};\n\nstatic int vidioc_s_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *a)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\n\tif (a->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tctx->enc_params.rc_framerate_num =\n\t\t\t\t\ta->parm.output.timeperframe.denominator;\n\t\tctx->enc_params.rc_framerate_denom =\n\t\t\t\t\ta->parm.output.timeperframe.numerator;\n\t} else {\n\t\tmfc_err(\"Setting FPS is only possible for the output queue\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_g_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *a)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\n\tif (a->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\ta->parm.output.timeperframe.denominator =\n\t\t\t\t\tctx->enc_params.rc_framerate_num;\n\t\ta->parm.output.timeperframe.numerator =\n\t\t\t\t\tctx->enc_params.rc_framerate_denom;\n\t} else {\n\t\tmfc_err(\"Setting FPS is only possible for the output queue\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_encoder_cmd(struct file *file, void *priv,\n\t\t\t      struct v4l2_encoder_cmd *cmd)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *buf;\n\tunsigned long flags;\n\n\tswitch (cmd->cmd) {\n\tcase V4L2_ENC_CMD_STOP:\n\t\tif (cmd->flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (!ctx->vq_src.streaming)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irqsave(&dev->irqlock, flags);\n\t\tif (list_empty(&ctx->src_queue)) {\n\t\t\tmfc_debug(2, \"EOS: empty src queue, entering finishing state\\n\");\n\t\t\tctx->state = MFCINST_FINISHING;\n\t\t\tif (s5p_mfc_ctx_ready(ctx))\n\t\t\t\tset_work_bit_irqsave(ctx);\n\t\t\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\t\t} else {\n\t\t\tmfc_debug(2, \"EOS: marking last buffer of stream\\n\");\n\t\t\tbuf = list_entry(ctx->src_queue.prev,\n\t\t\t\t\t\tstruct s5p_mfc_buf, list);\n\t\t\tif (buf->flags & MFC_BUF_FLAG_USED)\n\t\t\t\tctx->state = MFCINST_FINISHING;\n\t\t\telse\n\t\t\t\tbuf->flags |= MFC_BUF_FLAG_EOS;\n\t\t\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t  const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_EOS:\n\t\treturn v4l2_event_subscribe(fh, sub, 2, NULL);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_ioctl_ops s5p_mfc_enc_ioctl_ops = {\n\t.vidioc_querycap = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_out = vidioc_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_cap_mplane = vidioc_g_fmt,\n\t.vidioc_g_fmt_vid_out_mplane = vidioc_g_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane = vidioc_try_fmt,\n\t.vidioc_try_fmt_vid_out_mplane = vidioc_try_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane = vidioc_s_fmt,\n\t.vidioc_s_fmt_vid_out_mplane = vidioc_s_fmt,\n\t.vidioc_reqbufs = vidioc_reqbufs,\n\t.vidioc_querybuf = vidioc_querybuf,\n\t.vidioc_qbuf = vidioc_qbuf,\n\t.vidioc_dqbuf = vidioc_dqbuf,\n\t.vidioc_expbuf = vidioc_expbuf,\n\t.vidioc_streamon = vidioc_streamon,\n\t.vidioc_streamoff = vidioc_streamoff,\n\t.vidioc_s_parm = vidioc_s_parm,\n\t.vidioc_g_parm = vidioc_g_parm,\n\t.vidioc_encoder_cmd = vidioc_encoder_cmd,\n\t.vidioc_subscribe_event = vidioc_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic int check_vb_with_fmt(struct s5p_mfc_fmt *fmt, struct vb2_buffer *vb)\n{\n\tint i;\n\n\tif (!fmt)\n\t\treturn -EINVAL;\n\tif (fmt->num_planes != vb->num_planes) {\n\t\tmfc_err(\"invalid plane number for the format\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < fmt->num_planes; i++) {\n\t\tdma_addr_t dma = vb2_dma_contig_plane_dma_addr(vb, i);\n\t\tif (!dma) {\n\t\t\tmfc_err(\"failed to get plane cookie\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmfc_debug(2, \"index: %d, plane[%d] cookie: %pad\\n\",\n\t\t\t  vb->index, i, &dma);\n\t}\n\treturn 0;\n}\n\nstatic int s5p_mfc_queue_setup(struct vb2_queue *vq,\n\t\t\tunsigned int *buf_count, unsigned int *plane_count,\n\t\t\tunsigned int psize[], struct device *alloc_devs[])\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tif (ctx->state != MFCINST_GOT_INST) {\n\t\t\tmfc_err(\"invalid state: %d\\n\", ctx->state);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ctx->dst_fmt)\n\t\t\t*plane_count = ctx->dst_fmt->num_planes;\n\t\telse\n\t\t\t*plane_count = MFC_ENC_CAP_PLANE_COUNT;\n\t\tif (*buf_count < 1)\n\t\t\t*buf_count = 1;\n\t\tif (*buf_count > MFC_MAX_BUFFERS)\n\t\t\t*buf_count = MFC_MAX_BUFFERS;\n\t\tpsize[0] = ctx->enc_dst_buf_size;\n\t\talloc_devs[0] = ctx->dev->mem_dev[BANK_L_CTX];\n\t} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tif (ctx->src_fmt)\n\t\t\t*plane_count = ctx->src_fmt->num_planes;\n\t\telse\n\t\t\t*plane_count = MFC_ENC_OUT_PLANE_COUNT;\n\n\t\tif (*buf_count < 1)\n\t\t\t*buf_count = 1;\n\t\tif (*buf_count > MFC_MAX_BUFFERS)\n\t\t\t*buf_count = MFC_MAX_BUFFERS;\n\n\t\tpsize[0] = ctx->luma_size;\n\t\tpsize[1] = ctx->chroma_size;\n\n\t\tif (IS_MFCV6_PLUS(dev)) {\n\t\t\talloc_devs[0] = ctx->dev->mem_dev[BANK_L_CTX];\n\t\t\talloc_devs[1] = ctx->dev->mem_dev[BANK_L_CTX];\n\t\t} else {\n\t\t\talloc_devs[0] = ctx->dev->mem_dev[BANK_R_CTX];\n\t\t\talloc_devs[1] = ctx->dev->mem_dev[BANK_R_CTX];\n\t\t}\n\t} else {\n\t\tmfc_err(\"invalid queue type: %d\\n\", vq->type);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int s5p_mfc_buf_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\n\tunsigned int i;\n\tint ret;\n\n\tif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tret = check_vb_with_fmt(ctx->dst_fmt, vb);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti = vb->index;\n\t\tctx->dst_bufs[i].b = vbuf;\n\t\tctx->dst_bufs[i].cookie.stream =\n\t\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, 0);\n\t\tctx->dst_bufs_cnt++;\n\t} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tret = check_vb_with_fmt(ctx->src_fmt, vb);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti = vb->index;\n\t\tctx->src_bufs[i].b = vbuf;\n\t\tctx->src_bufs[i].cookie.raw.luma =\n\t\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, 0);\n\t\tctx->src_bufs[i].cookie.raw.chroma =\n\t\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, 1);\n\t\tctx->src_bufs_cnt++;\n\t} else {\n\t\tmfc_err(\"invalid queue type: %d\\n\", vq->type);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int s5p_mfc_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\n\tint ret;\n\n\tif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tret = check_vb_with_fmt(ctx->dst_fmt, vb);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmfc_debug(2, \"plane size: %ld, dst size: %zu\\n\",\n\t\t\tvb2_plane_size(vb, 0), ctx->enc_dst_buf_size);\n\t\tif (vb2_plane_size(vb, 0) < ctx->enc_dst_buf_size) {\n\t\t\tmfc_err(\"plane size is too small for capture\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tret = check_vb_with_fmt(ctx->src_fmt, vb);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmfc_debug(2, \"plane size: %ld, luma size: %d\\n\",\n\t\t\tvb2_plane_size(vb, 0), ctx->luma_size);\n\t\tmfc_debug(2, \"plane size: %ld, chroma size: %d\\n\",\n\t\t\tvb2_plane_size(vb, 1), ctx->chroma_size);\n\t\tif (vb2_plane_size(vb, 0) < ctx->luma_size ||\n\t\t    vb2_plane_size(vb, 1) < ctx->chroma_size) {\n\t\t\tmfc_err(\"plane size is too small for output\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tmfc_err(\"invalid queue type: %d\\n\", vq->type);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int s5p_mfc_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(q->drv_priv);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tif (IS_MFCV6_PLUS(dev) &&\n\t\t\t(q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)) {\n\n\t\tif ((ctx->state == MFCINST_GOT_INST) &&\n\t\t\t(dev->curr_ctx == ctx->num) && dev->hw_lock) {\n\t\t\ts5p_mfc_wait_for_done_ctx(ctx,\n\t\t\t\t\t\tS5P_MFC_R2H_CMD_SEQ_DONE_RET,\n\t\t\t\t\t\t0);\n\t\t}\n\n\t\tif (ctx->src_bufs_cnt < ctx->pb_count) {\n\t\t\tmfc_err(\"Need minimum %d OUTPUT buffers\\n\",\n\t\t\t\t\tctx->pb_count);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t}\n\n\t \n\tif (s5p_mfc_ctx_ready(ctx))\n\t\tset_work_bit_irqsave(ctx);\n\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\n\treturn 0;\n}\n\nstatic void s5p_mfc_stop_streaming(struct vb2_queue *q)\n{\n\tunsigned long flags;\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(q->drv_priv);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tif ((ctx->state == MFCINST_FINISHING ||\n\t\tctx->state == MFCINST_RUNNING) &&\n\t\tdev->curr_ctx == ctx->num && dev->hw_lock) {\n\t\tctx->state = MFCINST_ABORT;\n\t\ts5p_mfc_wait_for_done_ctx(ctx, S5P_MFC_R2H_CMD_FRAME_DONE_RET,\n\t\t\t\t\t  0);\n\t}\n\tctx->state = MFCINST_FINISHED;\n\tspin_lock_irqsave(&dev->irqlock, flags);\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\ts5p_mfc_cleanup_queue(&ctx->dst_queue, &ctx->vq_dst);\n\t\tINIT_LIST_HEAD(&ctx->dst_queue);\n\t\tctx->dst_queue_cnt = 0;\n\t}\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tcleanup_ref_queue(ctx);\n\t\ts5p_mfc_cleanup_queue(&ctx->src_queue, &ctx->vq_src);\n\t\tINIT_LIST_HEAD(&ctx->src_queue);\n\t\tctx->src_queue_cnt = 0;\n\t}\n\tspin_unlock_irqrestore(&dev->irqlock, flags);\n}\n\nstatic void s5p_mfc_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tunsigned long flags;\n\tstruct s5p_mfc_buf *mfc_buf;\n\n\tif (ctx->state == MFCINST_ERROR) {\n\t\tvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\n\t\tcleanup_ref_queue(ctx);\n\t\treturn;\n\t}\n\tif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tmfc_buf = &ctx->dst_bufs[vb->index];\n\t\tmfc_buf->flags &= ~MFC_BUF_FLAG_USED;\n\t\t \n\t\tspin_lock_irqsave(&dev->irqlock, flags);\n\t\tlist_add_tail(&mfc_buf->list, &ctx->dst_queue);\n\t\tctx->dst_queue_cnt++;\n\t\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\t} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tmfc_buf = &ctx->src_bufs[vb->index];\n\t\tmfc_buf->flags &= ~MFC_BUF_FLAG_USED;\n\t\tspin_lock_irqsave(&dev->irqlock, flags);\n\t\tlist_add_tail(&mfc_buf->list, &ctx->src_queue);\n\t\tctx->src_queue_cnt++;\n\t\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\t} else {\n\t\tmfc_err(\"unsupported buffer type (%d)\\n\", vq->type);\n\t}\n\tif (s5p_mfc_ctx_ready(ctx))\n\t\tset_work_bit_irqsave(ctx);\n\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n}\n\nstatic struct vb2_ops s5p_mfc_enc_qops = {\n\t.queue_setup\t\t= s5p_mfc_queue_setup,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.buf_init\t\t= s5p_mfc_buf_init,\n\t.buf_prepare\t\t= s5p_mfc_buf_prepare,\n\t.start_streaming\t= s5p_mfc_start_streaming,\n\t.stop_streaming\t\t= s5p_mfc_stop_streaming,\n\t.buf_queue\t\t= s5p_mfc_buf_queue,\n};\n\nconst struct s5p_mfc_codec_ops *get_enc_codec_ops(void)\n{\n\treturn &encoder_codec_ops;\n}\n\nstruct vb2_ops *get_enc_queue_ops(void)\n{\n\treturn &s5p_mfc_enc_qops;\n}\n\nconst struct v4l2_ioctl_ops *get_enc_v4l2_ioctl_ops(void)\n{\n\treturn &s5p_mfc_enc_ioctl_ops;\n}\n\n#define IS_MFC51_PRIV(x) ((V4L2_CTRL_ID2WHICH(x) == V4L2_CTRL_CLASS_CODEC) \\\n\t\t\t\t\t\t&& V4L2_CTRL_DRIVER_PRIV(x))\n\nint s5p_mfc_enc_ctrls_setup(struct s5p_mfc_ctx *ctx)\n{\n\tstruct v4l2_ctrl_config cfg;\n\tint i;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, NUM_CTRLS);\n\tif (ctx->ctrl_handler.error) {\n\t\tmfc_err(\"v4l2_ctrl_handler_init failed\\n\");\n\t\treturn ctx->ctrl_handler.error;\n\t}\n\tfor (i = 0; i < NUM_CTRLS; i++) {\n\t\tif (IS_MFC51_PRIV(controls[i].id)) {\n\t\t\tmemset(&cfg, 0, sizeof(struct v4l2_ctrl_config));\n\t\t\tcfg.ops = &s5p_mfc_enc_ctrl_ops;\n\t\t\tcfg.id = controls[i].id;\n\t\t\tcfg.min = controls[i].minimum;\n\t\t\tcfg.max = controls[i].maximum;\n\t\t\tcfg.def = controls[i].default_value;\n\t\t\tcfg.name = controls[i].name;\n\t\t\tcfg.type = controls[i].type;\n\t\t\tcfg.flags = 0;\n\n\t\t\tif (cfg.type == V4L2_CTRL_TYPE_MENU) {\n\t\t\t\tcfg.step = 0;\n\t\t\t\tcfg.menu_skip_mask = controls[i].menu_skip_mask;\n\t\t\t\tcfg.qmenu = mfc51_get_menu(cfg.id);\n\t\t\t} else {\n\t\t\t\tcfg.step = controls[i].step;\n\t\t\t\tcfg.menu_skip_mask = 0;\n\t\t\t}\n\t\t\tctx->ctrls[i] = v4l2_ctrl_new_custom(&ctx->ctrl_handler,\n\t\t\t\t\t&cfg, NULL);\n\t\t} else {\n\t\t\tif ((controls[i].type == V4L2_CTRL_TYPE_MENU) ||\n\t\t\t\t(controls[i].type ==\n\t\t\t\t\tV4L2_CTRL_TYPE_INTEGER_MENU)) {\n\t\t\t\tctx->ctrls[i] = v4l2_ctrl_new_std_menu(\n\t\t\t\t\t&ctx->ctrl_handler,\n\t\t\t\t\t&s5p_mfc_enc_ctrl_ops, controls[i].id,\n\t\t\t\t\tcontrols[i].maximum, 0,\n\t\t\t\t\tcontrols[i].default_value);\n\t\t\t} else {\n\t\t\t\tctx->ctrls[i] = v4l2_ctrl_new_std(\n\t\t\t\t\t&ctx->ctrl_handler,\n\t\t\t\t\t&s5p_mfc_enc_ctrl_ops, controls[i].id,\n\t\t\t\t\tcontrols[i].minimum,\n\t\t\t\t\tcontrols[i].maximum, controls[i].step,\n\t\t\t\t\tcontrols[i].default_value);\n\t\t\t}\n\t\t}\n\t\tif (ctx->ctrl_handler.error) {\n\t\t\tmfc_err(\"Adding control (%d) failed\\n\", i);\n\t\t\treturn ctx->ctrl_handler.error;\n\t\t}\n\t\tif (controls[i].is_volatile && ctx->ctrls[i])\n\t\t\tctx->ctrls[i]->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\t}\n\tv4l2_ctrl_handler_setup(&ctx->ctrl_handler);\n\treturn 0;\n}\n\nvoid s5p_mfc_enc_ctrls_delete(struct s5p_mfc_ctx *ctx)\n{\n\tint i;\n\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tfor (i = 0; i < NUM_CTRLS; i++)\n\t\tctx->ctrls[i] = NULL;\n}\n\nvoid s5p_mfc_enc_init(struct s5p_mfc_ctx *ctx)\n{\n\tstruct v4l2_format f;\n\tf.fmt.pix_mp.pixelformat = DEF_SRC_FMT_ENC;\n\tctx->src_fmt = find_format(&f, MFC_FMT_RAW);\n\tf.fmt.pix_mp.pixelformat = DEF_DST_FMT_ENC;\n\tctx->dst_fmt = find_format(&f, MFC_FMT_ENC);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}