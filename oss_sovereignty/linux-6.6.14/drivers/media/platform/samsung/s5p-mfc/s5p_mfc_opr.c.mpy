{
  "module_name": "s5p_mfc_opr.c",
  "hash_id": "a16d301096ac4a45197449f2f5efca1ed9dcd8638296e6e818364b9c745d1e5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s5p-mfc/s5p_mfc_opr.c",
  "human_readable_source": "\n \n\n#include \"s5p_mfc_debug.h\"\n#include \"s5p_mfc_opr.h\"\n#include \"s5p_mfc_opr_v5.h\"\n#include \"s5p_mfc_opr_v6.h\"\n\nstatic struct s5p_mfc_hw_ops *s5p_mfc_ops;\n\nvoid s5p_mfc_init_hw_ops(struct s5p_mfc_dev *dev)\n{\n\tif (IS_MFCV6_PLUS(dev)) {\n\t\ts5p_mfc_ops = s5p_mfc_init_hw_ops_v6();\n\t\tdev->warn_start = S5P_FIMV_ERR_WARNINGS_START_V6;\n\t} else {\n\t\ts5p_mfc_ops = s5p_mfc_init_hw_ops_v5();\n\t\tdev->warn_start = S5P_FIMV_ERR_WARNINGS_START;\n\t}\n\tdev->mfc_ops = s5p_mfc_ops;\n}\n\nvoid s5p_mfc_init_regs(struct s5p_mfc_dev *dev)\n{\n\tif (IS_MFCV6_PLUS(dev))\n\t\tdev->mfc_regs = s5p_mfc_init_regs_v6_plus(dev);\n}\n\nint s5p_mfc_alloc_priv_buf(struct s5p_mfc_dev *dev, unsigned int mem_ctx,\n\t\t\t   struct s5p_mfc_priv_buf *b)\n{\n\tunsigned int bits = dev->mem_size >> PAGE_SHIFT;\n\tunsigned int count = b->size >> PAGE_SHIFT;\n\tunsigned int align = (SZ_64K >> PAGE_SHIFT) - 1;\n\tunsigned int start, offset;\n\n\tmfc_debug(3, \"Allocating priv: %zu\\n\", b->size);\n\n\tif (dev->mem_virt) {\n\t\tstart = bitmap_find_next_zero_area(dev->mem_bitmap, bits, 0, count, align);\n\t\tif (start > bits)\n\t\t\tgoto no_mem;\n\n\t\tbitmap_set(dev->mem_bitmap, start, count);\n\t\toffset = start << PAGE_SHIFT;\n\t\tb->virt = dev->mem_virt + offset;\n\t\tb->dma = dev->mem_base + offset;\n\t} else {\n\t\tstruct device *mem_dev = dev->mem_dev[mem_ctx];\n\t\tdma_addr_t base = dev->dma_base[mem_ctx];\n\n\t\tb->ctx = mem_ctx;\n\t\tb->virt = dma_alloc_coherent(mem_dev, b->size, &b->dma, GFP_KERNEL);\n\t\tif (!b->virt)\n\t\t\tgoto no_mem;\n\t\tif (b->dma < base) {\n\t\t\tmfc_err(\"Invalid memory configuration - buffer (%pad) is below base memory address(%pad)\\n\",\n\t\t\t\t&b->dma, &base);\n\t\t\tdma_free_coherent(mem_dev, b->size, b->virt, b->dma);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmfc_debug(3, \"Allocated addr %p %pad\\n\", b->virt, &b->dma);\n\treturn 0;\nno_mem:\n\tmfc_err(\"Allocating private buffer of size %zu failed\\n\", b->size);\n\treturn -ENOMEM;\n}\n\nint s5p_mfc_alloc_generic_buf(struct s5p_mfc_dev *dev, unsigned int mem_ctx,\n\t\t\t   struct s5p_mfc_priv_buf *b)\n{\n\tstruct device *mem_dev = dev->mem_dev[mem_ctx];\n\n\tmfc_debug(3, \"Allocating generic buf: %zu\\n\", b->size);\n\n\tb->ctx = mem_ctx;\n\tb->virt = dma_alloc_coherent(mem_dev, b->size, &b->dma, GFP_KERNEL);\n\tif (!b->virt)\n\t\tgoto no_mem;\n\n\tmfc_debug(3, \"Allocated addr %p %pad\\n\", b->virt, &b->dma);\n\treturn 0;\nno_mem:\n\tmfc_err(\"Allocating generic buffer of size %zu failed\\n\", b->size);\n\treturn -ENOMEM;\n}\n\nvoid s5p_mfc_release_priv_buf(struct s5p_mfc_dev *dev,\n\t\t\t      struct s5p_mfc_priv_buf *b)\n{\n\tif (dev->mem_virt) {\n\t\tunsigned int start = (b->dma - dev->mem_base) >> PAGE_SHIFT;\n\t\tunsigned int count = b->size >> PAGE_SHIFT;\n\n\t\tbitmap_clear(dev->mem_bitmap, start, count);\n\t} else {\n\t\tstruct device *mem_dev = dev->mem_dev[b->ctx];\n\n\t\tdma_free_coherent(mem_dev, b->size, b->virt, b->dma);\n\t}\n\tb->virt = NULL;\n\tb->dma = 0;\n\tb->size = 0;\n}\n\nvoid s5p_mfc_release_generic_buf(struct s5p_mfc_dev *dev,\n\t\t\t      struct s5p_mfc_priv_buf *b)\n{\n\tstruct device *mem_dev = dev->mem_dev[b->ctx];\n\tdma_free_coherent(mem_dev, b->size, b->virt, b->dma);\n\tb->virt = NULL;\n\tb->dma = 0;\n\tb->size = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}