{
  "module_name": "s5p_mfc_cmd_v5.c",
  "hash_id": "ab8577df3a2b9fb85844f939c4585c3f8dfa3c30a574fc35b111fe334aa42f91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s5p-mfc/s5p_mfc_cmd_v5.c",
  "human_readable_source": "\n \n\n#include \"regs-mfc.h\"\n#include \"s5p_mfc_cmd.h\"\n#include \"s5p_mfc_common.h\"\n#include \"s5p_mfc_debug.h\"\n#include \"s5p_mfc_cmd_v5.h\"\n\n \nstatic int s5p_mfc_cmd_host2risc_v5(struct s5p_mfc_dev *dev, int cmd,\n\t\t\t\tstruct s5p_mfc_cmd_args *args)\n{\n\tint cur_cmd;\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(MFC_BW_TIMEOUT);\n\t \n\tdo {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tmfc_err(\"Timeout while waiting for hardware\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tcur_cmd = mfc_read(dev, S5P_FIMV_HOST2RISC_CMD);\n\t} while (cur_cmd != S5P_FIMV_H2R_CMD_EMPTY);\n\tmfc_write(dev, args->arg[0], S5P_FIMV_HOST2RISC_ARG1);\n\tmfc_write(dev, args->arg[1], S5P_FIMV_HOST2RISC_ARG2);\n\tmfc_write(dev, args->arg[2], S5P_FIMV_HOST2RISC_ARG3);\n\tmfc_write(dev, args->arg[3], S5P_FIMV_HOST2RISC_ARG4);\n\t \n\tmfc_write(dev, cmd, S5P_FIMV_HOST2RISC_CMD);\n\treturn 0;\n}\n\n \nstatic int s5p_mfc_sys_init_cmd_v5(struct s5p_mfc_dev *dev)\n{\n\tstruct s5p_mfc_cmd_args h2r_args;\n\n\tmemset(&h2r_args, 0, sizeof(struct s5p_mfc_cmd_args));\n\th2r_args.arg[0] = dev->fw_buf.size;\n\treturn s5p_mfc_cmd_host2risc_v5(dev, S5P_FIMV_H2R_CMD_SYS_INIT,\n\t\t\t&h2r_args);\n}\n\n \nstatic int s5p_mfc_sleep_cmd_v5(struct s5p_mfc_dev *dev)\n{\n\tstruct s5p_mfc_cmd_args h2r_args;\n\n\tmemset(&h2r_args, 0, sizeof(struct s5p_mfc_cmd_args));\n\treturn s5p_mfc_cmd_host2risc_v5(dev, S5P_FIMV_H2R_CMD_SLEEP, &h2r_args);\n}\n\n \nstatic int s5p_mfc_wakeup_cmd_v5(struct s5p_mfc_dev *dev)\n{\n\tstruct s5p_mfc_cmd_args h2r_args;\n\n\tmemset(&h2r_args, 0, sizeof(struct s5p_mfc_cmd_args));\n\treturn s5p_mfc_cmd_host2risc_v5(dev, S5P_FIMV_H2R_CMD_WAKEUP,\n\t\t\t&h2r_args);\n}\n\n\nstatic int s5p_mfc_open_inst_cmd_v5(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_cmd_args h2r_args;\n\tint ret;\n\n\t \n\tmfc_debug(2, \"Getting instance number (codec: %d)\\n\", ctx->codec_mode);\n\tdev->curr_ctx = ctx->num;\n\tmemset(&h2r_args, 0, sizeof(struct s5p_mfc_cmd_args));\n\tswitch (ctx->codec_mode) {\n\tcase S5P_MFC_CODEC_H264_DEC:\n\t\th2r_args.arg[0] = S5P_FIMV_CODEC_H264_DEC;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_VC1_DEC:\n\t\th2r_args.arg[0] = S5P_FIMV_CODEC_VC1_DEC;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG4_DEC:\n\t\th2r_args.arg[0] = S5P_FIMV_CODEC_MPEG4_DEC;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG2_DEC:\n\t\th2r_args.arg[0] = S5P_FIMV_CODEC_MPEG2_DEC;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_H263_DEC:\n\t\th2r_args.arg[0] = S5P_FIMV_CODEC_H263_DEC;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_VC1RCV_DEC:\n\t\th2r_args.arg[0] = S5P_FIMV_CODEC_VC1RCV_DEC;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_H264_ENC:\n\t\th2r_args.arg[0] = S5P_FIMV_CODEC_H264_ENC;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG4_ENC:\n\t\th2r_args.arg[0] = S5P_FIMV_CODEC_MPEG4_ENC;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_H263_ENC:\n\t\th2r_args.arg[0] = S5P_FIMV_CODEC_H263_ENC;\n\t\tbreak;\n\tdefault:\n\t\th2r_args.arg[0] = S5P_FIMV_CODEC_NONE;\n\t}\n\th2r_args.arg[1] = 0;  \n\th2r_args.arg[2] = ctx->ctx.ofs;\n\th2r_args.arg[3] = ctx->ctx.size;\n\tret = s5p_mfc_cmd_host2risc_v5(dev, S5P_FIMV_H2R_CMD_OPEN_INSTANCE,\n\t\t\t\t\t\t\t\t&h2r_args);\n\tif (ret) {\n\t\tmfc_err(\"Failed to create a new instance\\n\");\n\t\tctx->state = MFCINST_ERROR;\n\t}\n\treturn ret;\n}\n\nstatic int s5p_mfc_close_inst_cmd_v5(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_cmd_args h2r_args;\n\tint ret;\n\n\tif (ctx->state == MFCINST_FREE) {\n\t\tmfc_err(\"Instance already returned\\n\");\n\t\tctx->state = MFCINST_ERROR;\n\t\treturn -EINVAL;\n\t}\n\t \n\tmfc_debug(2, \"Returning instance number %d\\n\", ctx->inst_no);\n\tdev->curr_ctx = ctx->num;\n\tmemset(&h2r_args, 0, sizeof(struct s5p_mfc_cmd_args));\n\th2r_args.arg[0] = ctx->inst_no;\n\tret = s5p_mfc_cmd_host2risc_v5(dev, S5P_FIMV_H2R_CMD_CLOSE_INSTANCE,\n\t\t\t\t\t\t\t\t&h2r_args);\n\tif (ret) {\n\t\tmfc_err(\"Failed to return an instance\\n\");\n\t\tctx->state = MFCINST_ERROR;\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic struct s5p_mfc_hw_cmds s5p_mfc_cmds_v5 = {\n\t.cmd_host2risc = s5p_mfc_cmd_host2risc_v5,\n\t.sys_init_cmd = s5p_mfc_sys_init_cmd_v5,\n\t.sleep_cmd = s5p_mfc_sleep_cmd_v5,\n\t.wakeup_cmd = s5p_mfc_wakeup_cmd_v5,\n\t.open_inst_cmd = s5p_mfc_open_inst_cmd_v5,\n\t.close_inst_cmd = s5p_mfc_close_inst_cmd_v5,\n};\n\nstruct s5p_mfc_hw_cmds *s5p_mfc_init_hw_cmds_v5(void)\n{\n\treturn &s5p_mfc_cmds_v5;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}