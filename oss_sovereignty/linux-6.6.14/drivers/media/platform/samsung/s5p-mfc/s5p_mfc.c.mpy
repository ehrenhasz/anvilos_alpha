{
  "module_name": "s5p_mfc.c",
  "hash_id": "563e64d44fb7b7bb8e169118311b497c5583c61ec5dbf27b26903df7aa1fc305",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s5p-mfc/s5p_mfc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-event.h>\n#include <linux/workqueue.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_reserved_mem.h>\n#include <media/videobuf2-v4l2.h>\n#include \"s5p_mfc_common.h\"\n#include \"s5p_mfc_ctrl.h\"\n#include \"s5p_mfc_debug.h\"\n#include \"s5p_mfc_dec.h\"\n#include \"s5p_mfc_enc.h\"\n#include \"s5p_mfc_intr.h\"\n#include \"s5p_mfc_iommu.h\"\n#include \"s5p_mfc_opr.h\"\n#include \"s5p_mfc_cmd.h\"\n#include \"s5p_mfc_pm.h\"\n\n#define S5P_MFC_DEC_NAME\t\"s5p-mfc-dec\"\n#define S5P_MFC_ENC_NAME\t\"s5p-mfc-enc\"\n\nint mfc_debug_level;\nmodule_param_named(debug, mfc_debug_level, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level - higher value produces more verbose messages\");\n\nstatic char *mfc_mem_size;\nmodule_param_named(mem, mfc_mem_size, charp, 0644);\nMODULE_PARM_DESC(mem, \"Preallocated memory size for the firmware and context buffers\");\n\n \n\n \nvoid clear_work_bit(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tspin_lock(&dev->condlock);\n\t__clear_bit(ctx->num, &dev->ctx_work_bits);\n\tspin_unlock(&dev->condlock);\n}\n\n \nvoid set_work_bit(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tspin_lock(&dev->condlock);\n\t__set_bit(ctx->num, &dev->ctx_work_bits);\n\tspin_unlock(&dev->condlock);\n}\n\n \nvoid clear_work_bit_irqsave(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->condlock, flags);\n\t__clear_bit(ctx->num, &dev->ctx_work_bits);\n\tspin_unlock_irqrestore(&dev->condlock, flags);\n}\n\n \nvoid set_work_bit_irqsave(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->condlock, flags);\n\t__set_bit(ctx->num, &dev->ctx_work_bits);\n\tspin_unlock_irqrestore(&dev->condlock, flags);\n}\n\nint s5p_mfc_get_new_ctx(struct s5p_mfc_dev *dev)\n{\n\tunsigned long flags;\n\tint ctx;\n\n\tspin_lock_irqsave(&dev->condlock, flags);\n\tctx = dev->curr_ctx;\n\tdo {\n\t\tctx = (ctx + 1) % MFC_NUM_CONTEXTS;\n\t\tif (ctx == dev->curr_ctx) {\n\t\t\tif (!test_bit(ctx, &dev->ctx_work_bits))\n\t\t\t\tctx = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t} while (!test_bit(ctx, &dev->ctx_work_bits));\n\tspin_unlock_irqrestore(&dev->condlock, flags);\n\n\treturn ctx;\n}\n\n \nstatic void wake_up_ctx(struct s5p_mfc_ctx *ctx, unsigned int reason,\n\t\t\tunsigned int err)\n{\n\tctx->int_cond = 1;\n\tctx->int_type = reason;\n\tctx->int_err = err;\n\twake_up(&ctx->queue);\n}\n\n \nstatic void wake_up_dev(struct s5p_mfc_dev *dev, unsigned int reason,\n\t\t\tunsigned int err)\n{\n\tdev->int_cond = 1;\n\tdev->int_type = reason;\n\tdev->int_err = err;\n\twake_up(&dev->queue);\n}\n\nvoid s5p_mfc_cleanup_queue(struct list_head *lh, struct vb2_queue *vq)\n{\n\tstruct s5p_mfc_buf *b;\n\tint i;\n\n\twhile (!list_empty(lh)) {\n\t\tb = list_entry(lh->next, struct s5p_mfc_buf, list);\n\t\tfor (i = 0; i < b->b->vb2_buf.num_planes; i++)\n\t\t\tvb2_set_plane_payload(&b->b->vb2_buf, i, 0);\n\t\tvb2_buffer_done(&b->b->vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tlist_del(&b->list);\n\t}\n}\n\nstatic void s5p_mfc_watchdog(struct timer_list *t)\n{\n\tstruct s5p_mfc_dev *dev = from_timer(dev, t, watchdog_timer);\n\n\tif (test_bit(0, &dev->hw_lock))\n\t\tatomic_inc(&dev->watchdog_cnt);\n\tif (atomic_read(&dev->watchdog_cnt) >= MFC_WATCHDOG_CNT) {\n\t\t \n\t\tmfc_err(\"Time out during waiting for HW\\n\");\n\t\tschedule_work(&dev->watchdog_work);\n\t}\n\tdev->watchdog_timer.expires = jiffies +\n\t\t\t\t\tmsecs_to_jiffies(MFC_WATCHDOG_INTERVAL);\n\tadd_timer(&dev->watchdog_timer);\n}\n\nstatic void s5p_mfc_watchdog_worker(struct work_struct *work)\n{\n\tstruct s5p_mfc_dev *dev;\n\tstruct s5p_mfc_ctx *ctx;\n\tunsigned long flags;\n\tint mutex_locked;\n\tint i, ret;\n\n\tdev = container_of(work, struct s5p_mfc_dev, watchdog_work);\n\n\tmfc_err(\"Driver timeout error handling\\n\");\n\t \n\tmutex_locked = mutex_trylock(&dev->mfc_mutex);\n\tif (!mutex_locked)\n\t\tmfc_err(\"Error: some instance may be closing/opening\\n\");\n\tspin_lock_irqsave(&dev->irqlock, flags);\n\n\ts5p_mfc_clock_off();\n\n\tfor (i = 0; i < MFC_NUM_CONTEXTS; i++) {\n\t\tctx = dev->ctx[i];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\t\tctx->state = MFCINST_ERROR;\n\t\ts5p_mfc_cleanup_queue(&ctx->dst_queue, &ctx->vq_dst);\n\t\ts5p_mfc_cleanup_queue(&ctx->src_queue, &ctx->vq_src);\n\t\tclear_work_bit(ctx);\n\t\twake_up_ctx(ctx, S5P_MFC_R2H_CMD_ERR_RET, 0);\n\t}\n\tclear_bit(0, &dev->hw_lock);\n\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\n\t \n\ts5p_mfc_deinit_hw(dev);\n\n\t \n\tif (dev->num_inst > 0) {\n\t\tret = s5p_mfc_load_firmware(dev);\n\t\tif (ret) {\n\t\t\tmfc_err(\"Failed to reload FW\\n\");\n\t\t\tgoto unlock;\n\t\t}\n\t\ts5p_mfc_clock_on();\n\t\tret = s5p_mfc_init_hw(dev);\n\t\ts5p_mfc_clock_off();\n\t\tif (ret)\n\t\t\tmfc_err(\"Failed to reinit FW\\n\");\n\t}\nunlock:\n\tif (mutex_locked)\n\t\tmutex_unlock(&dev->mfc_mutex);\n}\n\nstatic void s5p_mfc_handle_frame_all_extracted(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_buf *dst_buf;\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tctx->state = MFCINST_FINISHED;\n\tctx->sequence++;\n\twhile (!list_empty(&ctx->dst_queue)) {\n\t\tdst_buf = list_entry(ctx->dst_queue.next,\n\t\t\t\t     struct s5p_mfc_buf, list);\n\t\tmfc_debug(2, \"Cleaning up buffer: %d\\n\",\n\t\t\t\t\t  dst_buf->b->vb2_buf.index);\n\t\tvb2_set_plane_payload(&dst_buf->b->vb2_buf, 0, 0);\n\t\tvb2_set_plane_payload(&dst_buf->b->vb2_buf, 1, 0);\n\t\tlist_del(&dst_buf->list);\n\t\tdst_buf->flags |= MFC_BUF_FLAG_EOS;\n\t\tctx->dst_queue_cnt--;\n\t\tdst_buf->b->sequence = (ctx->sequence++);\n\n\t\tif (s5p_mfc_hw_call(dev->mfc_ops, get_pic_type_top, ctx) ==\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, get_pic_type_bot, ctx))\n\t\t\tdst_buf->b->field = V4L2_FIELD_NONE;\n\t\telse\n\t\t\tdst_buf->b->field = V4L2_FIELD_INTERLACED;\n\t\tdst_buf->b->flags |= V4L2_BUF_FLAG_LAST;\n\n\t\tctx->dec_dst_flag &= ~(1 << dst_buf->b->vb2_buf.index);\n\t\tvb2_buffer_done(&dst_buf->b->vb2_buf, VB2_BUF_STATE_DONE);\n\t}\n}\n\nstatic void s5p_mfc_handle_frame_copy_time(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *dst_buf, *src_buf;\n\tu32 dec_y_addr;\n\tunsigned int frame_type;\n\n\t \n\tframe_type = s5p_mfc_hw_call(dev->mfc_ops, get_dec_frame_type, dev);\n\tif (frame_type == S5P_FIMV_DECODE_FRAME_SKIPPED)\n\t\treturn;\n\tdec_y_addr = (u32)s5p_mfc_hw_call(dev->mfc_ops, get_dec_y_adr, dev);\n\n\t \n\tsrc_buf = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\n\tlist_for_each_entry(dst_buf, &ctx->dst_queue, list) {\n\t\tu32 addr = (u32)vb2_dma_contig_plane_dma_addr(&dst_buf->b->vb2_buf, 0);\n\n\t\tif (addr == dec_y_addr) {\n\t\t\tdst_buf->b->timecode = src_buf->b->timecode;\n\t\t\tdst_buf->b->vb2_buf.timestamp =\n\t\t\t\t\t\tsrc_buf->b->vb2_buf.timestamp;\n\t\t\tdst_buf->b->flags &=\n\t\t\t\t~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\t\t\tdst_buf->b->flags |=\n\t\t\t\tsrc_buf->b->flags\n\t\t\t\t& V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\t\t\tswitch (frame_type) {\n\t\t\tcase S5P_FIMV_DECODE_FRAME_I_FRAME:\n\t\t\t\tdst_buf->b->flags |=\n\t\t\t\t\t\tV4L2_BUF_FLAG_KEYFRAME;\n\t\t\t\tbreak;\n\t\t\tcase S5P_FIMV_DECODE_FRAME_P_FRAME:\n\t\t\t\tdst_buf->b->flags |=\n\t\t\t\t\t\tV4L2_BUF_FLAG_PFRAME;\n\t\t\t\tbreak;\n\t\t\tcase S5P_FIMV_DECODE_FRAME_B_FRAME:\n\t\t\t\tdst_buf->b->flags |=\n\t\t\t\t\t\tV4L2_BUF_FLAG_BFRAME;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tmfc_debug(2, \"Unexpected frame type: %d\\n\",\n\t\t\t\t\t\tframe_type);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void s5p_mfc_handle_frame_new(struct s5p_mfc_ctx *ctx, unsigned int err)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf  *dst_buf;\n\tu32 dspl_y_addr;\n\tunsigned int frame_type;\n\n\tdspl_y_addr = (u32)s5p_mfc_hw_call(dev->mfc_ops, get_dspl_y_adr, dev);\n\tif (IS_MFCV6_PLUS(dev))\n\t\tframe_type = s5p_mfc_hw_call(dev->mfc_ops,\n\t\t\tget_disp_frame_type, ctx);\n\telse\n\t\tframe_type = s5p_mfc_hw_call(dev->mfc_ops,\n\t\t\tget_dec_frame_type, dev);\n\n\t \n\tif (frame_type == S5P_FIMV_DECODE_FRAME_SKIPPED) {\n\t\tif (!ctx->after_packed_pb)\n\t\t\tctx->sequence++;\n\t\tctx->after_packed_pb = 0;\n\t\treturn;\n\t}\n\tctx->sequence++;\n\t \n\tlist_for_each_entry(dst_buf, &ctx->dst_queue, list) {\n\t\tu32 addr = (u32)vb2_dma_contig_plane_dma_addr(&dst_buf->b->vb2_buf, 0);\n\n\t\t \n\t\tif (addr == dspl_y_addr) {\n\t\t\tlist_del(&dst_buf->list);\n\t\t\tctx->dst_queue_cnt--;\n\t\t\tdst_buf->b->sequence = ctx->sequence;\n\t\t\tif (s5p_mfc_hw_call(dev->mfc_ops,\n\t\t\t\t\tget_pic_type_top, ctx) ==\n\t\t\t\ts5p_mfc_hw_call(dev->mfc_ops,\n\t\t\t\t\tget_pic_type_bot, ctx))\n\t\t\t\tdst_buf->b->field = V4L2_FIELD_NONE;\n\t\t\telse\n\t\t\t\tdst_buf->b->field =\n\t\t\t\t\t\t\tV4L2_FIELD_INTERLACED;\n\t\t\tvb2_set_plane_payload(&dst_buf->b->vb2_buf, 0,\n\t\t\t\t\t\tctx->luma_size);\n\t\t\tvb2_set_plane_payload(&dst_buf->b->vb2_buf, 1,\n\t\t\t\t\t\tctx->chroma_size);\n\t\t\tclear_bit(dst_buf->b->vb2_buf.index,\n\t\t\t\t\t\t\t&ctx->dec_dst_flag);\n\n\t\t\tvb2_buffer_done(&dst_buf->b->vb2_buf, err ?\n\t\t\t\tVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void s5p_mfc_handle_frame(struct s5p_mfc_ctx *ctx,\n\t\t\t\t\tunsigned int reason, unsigned int err)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tunsigned int dst_frame_status;\n\tunsigned int dec_frame_status;\n\tstruct s5p_mfc_buf *src_buf;\n\tunsigned int res_change;\n\n\tdst_frame_status = s5p_mfc_hw_call(dev->mfc_ops, get_dspl_status, dev)\n\t\t\t\t& S5P_FIMV_DEC_STATUS_DECODING_STATUS_MASK;\n\tdec_frame_status = s5p_mfc_hw_call(dev->mfc_ops, get_dec_status, dev)\n\t\t\t\t& S5P_FIMV_DEC_STATUS_DECODING_STATUS_MASK;\n\tres_change = (s5p_mfc_hw_call(dev->mfc_ops, get_dspl_status, dev)\n\t\t\t\t& S5P_FIMV_DEC_STATUS_RESOLUTION_MASK)\n\t\t\t\t>> S5P_FIMV_DEC_STATUS_RESOLUTION_SHIFT;\n\tmfc_debug(2, \"Frame Status: %x\\n\", dst_frame_status);\n\tif (ctx->state == MFCINST_RES_CHANGE_INIT)\n\t\tctx->state = MFCINST_RES_CHANGE_FLUSH;\n\tif (res_change == S5P_FIMV_RES_INCREASE ||\n\t\tres_change == S5P_FIMV_RES_DECREASE) {\n\t\tctx->state = MFCINST_RES_CHANGE_INIT;\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\twake_up_ctx(ctx, reason, err);\n\t\tWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\n\t\ts5p_mfc_clock_off();\n\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\t\treturn;\n\t}\n\tif (ctx->dpb_flush_flag)\n\t\tctx->dpb_flush_flag = 0;\n\n\t \n\tif (dst_frame_status == S5P_FIMV_DEC_STATUS_DECODING_EMPTY) {\n\t\tif (ctx->state == MFCINST_RES_CHANGE_FLUSH) {\n\t\t\tstatic const struct v4l2_event ev_src_ch = {\n\t\t\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t\t\t.u.src_change.changes =\n\t\t\t\t\tV4L2_EVENT_SRC_CH_RESOLUTION,\n\t\t\t};\n\n\t\t\ts5p_mfc_handle_frame_all_extracted(ctx);\n\t\t\tctx->state = MFCINST_RES_CHANGE_END;\n\t\t\tv4l2_event_queue_fh(&ctx->fh, &ev_src_ch);\n\n\t\t\tgoto leave_handle_frame;\n\t\t} else {\n\t\t\ts5p_mfc_handle_frame_all_extracted(ctx);\n\t\t}\n\t}\n\n\tif (dec_frame_status == S5P_FIMV_DEC_STATUS_DECODING_DISPLAY)\n\t\ts5p_mfc_handle_frame_copy_time(ctx);\n\n\t \n\tif (dst_frame_status == S5P_FIMV_DEC_STATUS_DISPLAY_ONLY ||\n\t    dst_frame_status == S5P_FIMV_DEC_STATUS_DECODING_DISPLAY) {\n\t\ts5p_mfc_handle_frame_new(ctx, err);\n\t} else {\n\t\tmfc_debug(2, \"No frame decode\\n\");\n\t}\n\t \n\tif (dst_frame_status != S5P_FIMV_DEC_STATUS_DISPLAY_ONLY\n\t\t&& !list_empty(&ctx->src_queue)) {\n\t\tsrc_buf = list_entry(ctx->src_queue.next, struct s5p_mfc_buf,\n\t\t\t\t\t\t\t\tlist);\n\t\tctx->consumed_stream += s5p_mfc_hw_call(dev->mfc_ops,\n\t\t\t\t\t\tget_consumed_stream, dev);\n\t\tif (ctx->codec_mode != S5P_MFC_CODEC_H264_DEC &&\n\t\t\tctx->codec_mode != S5P_MFC_CODEC_VP8_DEC &&\n\t\t\tctx->consumed_stream + STUFF_BYTE <\n\t\t\tsrc_buf->b->vb2_buf.planes[0].bytesused) {\n\t\t\t \n\t\t\tmfc_debug(2, \"Running again the same buffer\\n\");\n\t\t\tctx->after_packed_pb = 1;\n\t\t} else {\n\t\t\tmfc_debug(2, \"MFC needs next buffer\\n\");\n\t\t\tctx->consumed_stream = 0;\n\t\t\tif (src_buf->flags & MFC_BUF_FLAG_EOS)\n\t\t\t\tctx->state = MFCINST_FINISHING;\n\t\t\tlist_del(&src_buf->list);\n\t\t\tctx->src_queue_cnt--;\n\t\t\tif (s5p_mfc_hw_call(dev->mfc_ops, err_dec, err) > 0)\n\t\t\t\tvb2_buffer_done(&src_buf->b->vb2_buf,\n\t\t\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\t\telse\n\t\t\t\tvb2_buffer_done(&src_buf->b->vb2_buf,\n\t\t\t\t\t\tVB2_BUF_STATE_DONE);\n\t\t}\n\t}\nleave_handle_frame:\n\tif ((ctx->src_queue_cnt == 0 && ctx->state != MFCINST_FINISHING)\n\t\t\t\t    || ctx->dst_queue_cnt < ctx->pb_count)\n\t\tclear_work_bit(ctx);\n\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\twake_up_ctx(ctx, reason, err);\n\tWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\n\ts5p_mfc_clock_off();\n\t \n\tif (test_bit(0, &dev->enter_suspend))\n\t\twake_up_dev(dev, reason, err);\n\telse\n\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n}\n\n \nstatic void s5p_mfc_handle_error(struct s5p_mfc_dev *dev,\n\t\tstruct s5p_mfc_ctx *ctx, unsigned int reason, unsigned int err)\n{\n\tmfc_err(\"Interrupt Error: %08x\\n\", err);\n\n\tif (ctx) {\n\t\t \n\t\tswitch (ctx->state) {\n\t\tcase MFCINST_RES_CHANGE_INIT:\n\t\tcase MFCINST_RES_CHANGE_FLUSH:\n\t\tcase MFCINST_RES_CHANGE_END:\n\t\tcase MFCINST_FINISHING:\n\t\tcase MFCINST_FINISHED:\n\t\tcase MFCINST_RUNNING:\n\t\t\t \n\t\t\tclear_work_bit(ctx);\n\t\t\tctx->state = MFCINST_ERROR;\n\t\t\t \n\t\t\ts5p_mfc_cleanup_queue(&ctx->dst_queue, &ctx->vq_dst);\n\t\t\t \n\t\t\ts5p_mfc_cleanup_queue(&ctx->src_queue, &ctx->vq_src);\n\t\t\twake_up_ctx(ctx, reason, err);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclear_work_bit(ctx);\n\t\t\tctx->state = MFCINST_ERROR;\n\t\t\twake_up_ctx(ctx, reason, err);\n\t\t\tbreak;\n\t\t}\n\t}\n\tWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\n\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\ts5p_mfc_clock_off();\n\twake_up_dev(dev, reason, err);\n}\n\n \nstatic void s5p_mfc_handle_seq_done(struct s5p_mfc_ctx *ctx,\n\t\t\t\t unsigned int reason, unsigned int err)\n{\n\tstruct s5p_mfc_dev *dev;\n\n\tif (!ctx)\n\t\treturn;\n\tdev = ctx->dev;\n\tif (ctx->c_ops->post_seq_start) {\n\t\tif (ctx->c_ops->post_seq_start(ctx))\n\t\t\tmfc_err(\"post_seq_start() failed\\n\");\n\t} else {\n\t\tctx->img_width = s5p_mfc_hw_call(dev->mfc_ops, get_img_width,\n\t\t\t\tdev);\n\t\tctx->img_height = s5p_mfc_hw_call(dev->mfc_ops, get_img_height,\n\t\t\t\tdev);\n\n\t\ts5p_mfc_hw_call(dev->mfc_ops, dec_calc_dpb_size, ctx);\n\n\t\tctx->pb_count = s5p_mfc_hw_call(dev->mfc_ops, get_dpb_count,\n\t\t\t\tdev);\n\t\tctx->mv_count = s5p_mfc_hw_call(dev->mfc_ops, get_mv_count,\n\t\t\t\tdev);\n\t\tif (FW_HAS_E_MIN_SCRATCH_BUF(dev))\n\t\t\tctx->scratch_buf_size = s5p_mfc_hw_call(dev->mfc_ops,\n\t\t\t\t\t\tget_min_scratch_buf_size, dev);\n\t\tif (ctx->img_width == 0 || ctx->img_height == 0)\n\t\t\tctx->state = MFCINST_ERROR;\n\t\telse\n\t\t\tctx->state = MFCINST_HEAD_PARSED;\n\n\t\tif ((ctx->codec_mode == S5P_MFC_CODEC_H264_DEC ||\n\t\t\tctx->codec_mode == S5P_MFC_CODEC_H264_MVC_DEC) &&\n\t\t\t\t!list_empty(&ctx->src_queue)) {\n\t\t\tstruct s5p_mfc_buf *src_buf;\n\n\t\t\tsrc_buf = list_entry(ctx->src_queue.next,\n\t\t\t\t\tstruct s5p_mfc_buf, list);\n\t\t\tif (s5p_mfc_hw_call(dev->mfc_ops, get_consumed_stream,\n\t\t\t\t\t\tdev) <\n\t\t\t\t\tsrc_buf->b->vb2_buf.planes[0].bytesused)\n\t\t\t\tctx->head_processed = 0;\n\t\t\telse\n\t\t\t\tctx->head_processed = 1;\n\t\t} else {\n\t\t\tctx->head_processed = 1;\n\t\t}\n\t}\n\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\tclear_work_bit(ctx);\n\tWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\n\ts5p_mfc_clock_off();\n\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\twake_up_ctx(ctx, reason, err);\n}\n\n \nstatic void s5p_mfc_handle_init_buffers(struct s5p_mfc_ctx *ctx,\n\t\t\t\t unsigned int reason, unsigned int err)\n{\n\tstruct s5p_mfc_buf *src_buf;\n\tstruct s5p_mfc_dev *dev;\n\n\tif (!ctx)\n\t\treturn;\n\tdev = ctx->dev;\n\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\tctx->int_type = reason;\n\tctx->int_err = err;\n\tctx->int_cond = 1;\n\tclear_work_bit(ctx);\n\tif (err == 0) {\n\t\tctx->state = MFCINST_RUNNING;\n\t\tif (!ctx->dpb_flush_flag && ctx->head_processed) {\n\t\t\tif (!list_empty(&ctx->src_queue)) {\n\t\t\t\tsrc_buf = list_entry(ctx->src_queue.next,\n\t\t\t\t\t     struct s5p_mfc_buf, list);\n\t\t\t\tlist_del(&src_buf->list);\n\t\t\t\tctx->src_queue_cnt--;\n\t\t\t\tvb2_buffer_done(&src_buf->b->vb2_buf,\n\t\t\t\t\t\tVB2_BUF_STATE_DONE);\n\t\t\t}\n\t\t} else {\n\t\t\tctx->dpb_flush_flag = 0;\n\t\t}\n\t\tWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\n\n\t\ts5p_mfc_clock_off();\n\n\t\twake_up(&ctx->queue);\n\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\t} else {\n\t\tWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\n\n\t\ts5p_mfc_clock_off();\n\n\t\twake_up(&ctx->queue);\n\t}\n}\n\nstatic void s5p_mfc_handle_stream_complete(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *mb_entry;\n\n\tmfc_debug(2, \"Stream completed\\n\");\n\n\tctx->state = MFCINST_FINISHED;\n\n\tif (!list_empty(&ctx->dst_queue)) {\n\t\tmb_entry = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf,\n\t\t\t\t\t\t\t\t\tlist);\n\t\tlist_del(&mb_entry->list);\n\t\tctx->dst_queue_cnt--;\n\t\tvb2_set_plane_payload(&mb_entry->b->vb2_buf, 0, 0);\n\t\tvb2_buffer_done(&mb_entry->b->vb2_buf, VB2_BUF_STATE_DONE);\n\t}\n\n\tclear_work_bit(ctx);\n\n\tWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\n\n\ts5p_mfc_clock_off();\n\twake_up(&ctx->queue);\n\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n}\n\n \nstatic irqreturn_t s5p_mfc_irq(int irq, void *priv)\n{\n\tstruct s5p_mfc_dev *dev = priv;\n\tstruct s5p_mfc_ctx *ctx;\n\tunsigned int reason;\n\tunsigned int err;\n\n\tmfc_debug_enter();\n\t \n\tatomic_set(&dev->watchdog_cnt, 0);\n\tspin_lock(&dev->irqlock);\n\tctx = dev->ctx[dev->curr_ctx];\n\t \n\treason = s5p_mfc_hw_call(dev->mfc_ops, get_int_reason, dev);\n\terr = s5p_mfc_hw_call(dev->mfc_ops, get_int_err, dev);\n\tmfc_debug(1, \"Int reason: %d (err: %08x)\\n\", reason, err);\n\tswitch (reason) {\n\tcase S5P_MFC_R2H_CMD_ERR_RET:\n\t\t \n\t\tif (ctx->state == MFCINST_RUNNING &&\n\t\t\t(s5p_mfc_hw_call(dev->mfc_ops, err_dec, err) >=\n\t\t\t\tdev->warn_start ||\n\t\t\t\terr == S5P_FIMV_ERR_NO_VALID_SEQ_HDR ||\n\t\t\t\terr == S5P_FIMV_ERR_INCOMPLETE_FRAME ||\n\t\t\t\terr == S5P_FIMV_ERR_TIMEOUT))\n\t\t\ts5p_mfc_handle_frame(ctx, reason, err);\n\t\telse\n\t\t\ts5p_mfc_handle_error(dev, ctx, reason, err);\n\t\tclear_bit(0, &dev->enter_suspend);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_SLICE_DONE_RET:\n\tcase S5P_MFC_R2H_CMD_FIELD_DONE_RET:\n\tcase S5P_MFC_R2H_CMD_FRAME_DONE_RET:\n\t\tif (ctx->c_ops->post_frame_start) {\n\t\t\tif (ctx->c_ops->post_frame_start(ctx))\n\t\t\t\tmfc_err(\"post_frame_start() failed\\n\");\n\n\t\t\tif (ctx->state == MFCINST_FINISHING &&\n\t\t\t\t\t\tlist_empty(&ctx->ref_queue)) {\n\t\t\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\t\t\ts5p_mfc_handle_stream_complete(ctx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\t\tWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\n\t\t\ts5p_mfc_clock_off();\n\t\t\twake_up_ctx(ctx, reason, err);\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\t\t} else {\n\t\t\ts5p_mfc_handle_frame(ctx, reason, err);\n\t\t}\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_SEQ_DONE_RET:\n\t\ts5p_mfc_handle_seq_done(ctx, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_OPEN_INSTANCE_RET:\n\t\tctx->inst_no = s5p_mfc_hw_call(dev->mfc_ops, get_inst_no, dev);\n\t\tctx->state = MFCINST_GOT_INST;\n\t\tgoto irq_cleanup_hw;\n\n\tcase S5P_MFC_R2H_CMD_CLOSE_INSTANCE_RET:\n\t\tctx->inst_no = MFC_NO_INSTANCE_SET;\n\t\tctx->state = MFCINST_FREE;\n\t\tgoto irq_cleanup_hw;\n\n\tcase S5P_MFC_R2H_CMD_SYS_INIT_RET:\n\tcase S5P_MFC_R2H_CMD_FW_STATUS_RET:\n\tcase S5P_MFC_R2H_CMD_SLEEP_RET:\n\tcase S5P_MFC_R2H_CMD_WAKEUP_RET:\n\t\tif (ctx)\n\t\t\tclear_work_bit(ctx);\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\tclear_bit(0, &dev->hw_lock);\n\t\tclear_bit(0, &dev->enter_suspend);\n\t\twake_up_dev(dev, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_INIT_BUFFERS_RET:\n\t\ts5p_mfc_handle_init_buffers(ctx, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_COMPLETE_SEQ_RET:\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\tctx->int_type = reason;\n\t\tctx->int_err = err;\n\t\ts5p_mfc_handle_stream_complete(ctx);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_DPB_FLUSH_RET:\n\t\tctx->state = MFCINST_RUNNING;\n\t\tgoto irq_cleanup_hw;\n\n\tdefault:\n\t\tmfc_debug(2, \"Unknown int reason\\n\");\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t}\n\tspin_unlock(&dev->irqlock);\n\tmfc_debug_leave();\n\treturn IRQ_HANDLED;\nirq_cleanup_hw:\n\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\tctx->int_type = reason;\n\tctx->int_err = err;\n\tctx->int_cond = 1;\n\tif (test_and_clear_bit(0, &dev->hw_lock) == 0)\n\t\tmfc_err(\"Failed to unlock hw\\n\");\n\n\ts5p_mfc_clock_off();\n\tclear_work_bit(ctx);\n\twake_up(&ctx->queue);\n\n\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\tspin_unlock(&dev->irqlock);\n\tmfc_debug(2, \"Exit via irq_cleanup_hw\\n\");\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int s5p_mfc_open(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct s5p_mfc_dev *dev = video_drvdata(file);\n\tstruct s5p_mfc_ctx *ctx = NULL;\n\tstruct vb2_queue *q;\n\tint ret = 0;\n\n\tmfc_debug_enter();\n\tif (mutex_lock_interruptible(&dev->mfc_mutex))\n\t\treturn -ERESTARTSYS;\n\tdev->num_inst++;\t \n\t \n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\tinit_waitqueue_head(&ctx->queue);\n\tv4l2_fh_init(&ctx->fh, vdev);\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\tctx->dev = dev;\n\tINIT_LIST_HEAD(&ctx->src_queue);\n\tINIT_LIST_HEAD(&ctx->dst_queue);\n\tctx->src_queue_cnt = 0;\n\tctx->dst_queue_cnt = 0;\n\t \n\tctx->num = 0;\n\twhile (dev->ctx[ctx->num]) {\n\t\tctx->num++;\n\t\tif (ctx->num >= MFC_NUM_CONTEXTS) {\n\t\t\tmfc_debug(2, \"Too many open contexts\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_no_ctx;\n\t\t}\n\t}\n\t \n\tclear_work_bit_irqsave(ctx);\n\tdev->ctx[ctx->num] = ctx;\n\tif (vdev == dev->vfd_dec) {\n\t\tctx->type = MFCINST_DECODER;\n\t\tctx->c_ops = get_dec_codec_ops();\n\t\ts5p_mfc_dec_init(ctx);\n\t\t \n\t\tret = s5p_mfc_dec_ctrls_setup(ctx);\n\t\tif (ret) {\n\t\t\tmfc_err(\"Failed to setup mfc controls\\n\");\n\t\t\tgoto err_ctrls_setup;\n\t\t}\n\t} else if (vdev == dev->vfd_enc) {\n\t\tctx->type = MFCINST_ENCODER;\n\t\tctx->c_ops = get_enc_codec_ops();\n\t\t \n\t\tINIT_LIST_HEAD(&ctx->ref_queue);\n\t\tctx->ref_queue_cnt = 0;\n\t\ts5p_mfc_enc_init(ctx);\n\t\t \n\t\tret = s5p_mfc_enc_ctrls_setup(ctx);\n\t\tif (ret) {\n\t\t\tmfc_err(\"Failed to setup mfc controls\\n\");\n\t\t\tgoto err_ctrls_setup;\n\t\t}\n\t} else {\n\t\tret = -ENOENT;\n\t\tgoto err_bad_node;\n\t}\n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\tctx->inst_no = MFC_NO_INSTANCE_SET;\n\t \n\tif (dev->num_inst == 1) {\n\t\tdev->watchdog_timer.expires = jiffies +\n\t\t\t\t\tmsecs_to_jiffies(MFC_WATCHDOG_INTERVAL);\n\t\tadd_timer(&dev->watchdog_timer);\n\t\tret = s5p_mfc_power_on();\n\t\tif (ret < 0) {\n\t\t\tmfc_err(\"power on failed\\n\");\n\t\t\tgoto err_pwr_enable;\n\t\t}\n\t\ts5p_mfc_clock_on();\n\t\tret = s5p_mfc_load_firmware(dev);\n\t\tif (ret) {\n\t\t\ts5p_mfc_clock_off();\n\t\t\tgoto err_load_fw;\n\t\t}\n\t\t \n\t\tret = s5p_mfc_init_hw(dev);\n\t\ts5p_mfc_clock_off();\n\t\tif (ret)\n\t\t\tgoto err_init_hw;\n\t}\n\t \n\tq = &ctx->vq_dst;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tq->drv_priv = &ctx->fh;\n\tq->lock = &dev->mfc_mutex;\n\tif (vdev == dev->vfd_dec) {\n\t\tq->io_modes = VB2_MMAP;\n\t\tq->ops = get_dec_queue_ops();\n\t} else if (vdev == dev->vfd_enc) {\n\t\tq->io_modes = VB2_MMAP | VB2_USERPTR;\n\t\tq->ops = get_enc_queue_ops();\n\t} else {\n\t\tret = -ENOENT;\n\t\tgoto err_queue_init;\n\t}\n\t \n\tq->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tret = vb2_queue_init(q);\n\tif (ret) {\n\t\tmfc_err(\"Failed to initialize videobuf2 queue(capture)\\n\");\n\t\tgoto err_queue_init;\n\t}\n\t \n\tq = &ctx->vq_src;\n\tq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tq->drv_priv = &ctx->fh;\n\tq->lock = &dev->mfc_mutex;\n\tif (vdev == dev->vfd_dec) {\n\t\tq->io_modes = VB2_MMAP;\n\t\tq->ops = get_dec_queue_ops();\n\t} else if (vdev == dev->vfd_enc) {\n\t\tq->io_modes = VB2_MMAP | VB2_USERPTR;\n\t\tq->ops = get_enc_queue_ops();\n\t} else {\n\t\tret = -ENOENT;\n\t\tgoto err_queue_init;\n\t}\n\t \n\tq->allow_zero_bytesused = 1;\n\n\t \n\tq->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tret = vb2_queue_init(q);\n\tif (ret) {\n\t\tmfc_err(\"Failed to initialize videobuf2 queue(output)\\n\");\n\t\tgoto err_queue_init;\n\t}\n\tmutex_unlock(&dev->mfc_mutex);\n\tmfc_debug_leave();\n\treturn ret;\n\t \nerr_queue_init:\n\tif (dev->num_inst == 1)\n\t\ts5p_mfc_deinit_hw(dev);\nerr_init_hw:\nerr_load_fw:\nerr_pwr_enable:\n\tif (dev->num_inst == 1) {\n\t\tif (s5p_mfc_power_off() < 0)\n\t\t\tmfc_err(\"power off failed\\n\");\n\t\tdel_timer_sync(&dev->watchdog_timer);\n\t}\nerr_ctrls_setup:\n\ts5p_mfc_dec_ctrls_delete(ctx);\nerr_bad_node:\n\tdev->ctx[ctx->num] = NULL;\nerr_no_ctx:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\nerr_alloc:\n\tdev->num_inst--;\n\tmutex_unlock(&dev->mfc_mutex);\n\tmfc_debug_leave();\n\treturn ret;\n}\n\n \nstatic int s5p_mfc_release(struct file *file)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\t \n\tmfc_debug_enter();\n\tif (dev)\n\t\tmutex_lock(&dev->mfc_mutex);\n\tvb2_queue_release(&ctx->vq_src);\n\tvb2_queue_release(&ctx->vq_dst);\n\tif (dev) {\n\t\ts5p_mfc_clock_on();\n\n\t\t \n\t\tclear_work_bit_irqsave(ctx);\n\t\t \n\t\tif (ctx->state != MFCINST_FREE && ctx->state != MFCINST_INIT) {\n\t\t\tmfc_debug(2, \"Has to free instance\\n\");\n\t\t\ts5p_mfc_close_mfc_inst(dev, ctx);\n\t\t}\n\t\t \n\t\tif (dev->curr_ctx == ctx->num)\n\t\t\tclear_bit(0, &dev->hw_lock);\n\t\tdev->num_inst--;\n\t\tif (dev->num_inst == 0) {\n\t\t\tmfc_debug(2, \"Last instance\\n\");\n\t\t\ts5p_mfc_deinit_hw(dev);\n\t\t\tdel_timer_sync(&dev->watchdog_timer);\n\t\t\ts5p_mfc_clock_off();\n\t\t\tif (s5p_mfc_power_off() < 0)\n\t\t\t\tmfc_err(\"Power off failed\\n\");\n\t\t} else {\n\t\t\tmfc_debug(2, \"Shutting down clock\\n\");\n\t\t\ts5p_mfc_clock_off();\n\t\t}\n\t}\n\tif (dev)\n\t\tdev->ctx[ctx->num] = NULL;\n\ts5p_mfc_dec_ctrls_delete(ctx);\n\tv4l2_fh_del(&ctx->fh);\n\t \n\tif (dev)\n\t\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\tmfc_debug_leave();\n\tif (dev)\n\t\tmutex_unlock(&dev->mfc_mutex);\n\n\treturn 0;\n}\n\n \nstatic __poll_t s5p_mfc_poll(struct file *file,\n\t\t\t\t struct poll_table_struct *wait)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct vb2_queue *src_q, *dst_q;\n\tstruct vb2_buffer *src_vb = NULL, *dst_vb = NULL;\n\t__poll_t rc = 0;\n\tunsigned long flags;\n\n\tmutex_lock(&dev->mfc_mutex);\n\tsrc_q = &ctx->vq_src;\n\tdst_q = &ctx->vq_dst;\n\t \n\tif ((!vb2_is_streaming(src_q) || list_empty(&src_q->queued_list)) &&\n\t    (!vb2_is_streaming(dst_q) || list_empty(&dst_q->queued_list))) {\n\t\trc = EPOLLERR;\n\t\tgoto end;\n\t}\n\tmutex_unlock(&dev->mfc_mutex);\n\tpoll_wait(file, &ctx->fh.wait, wait);\n\tpoll_wait(file, &src_q->done_wq, wait);\n\tpoll_wait(file, &dst_q->done_wq, wait);\n\tmutex_lock(&dev->mfc_mutex);\n\tif (v4l2_event_pending(&ctx->fh))\n\t\trc |= EPOLLPRI;\n\tspin_lock_irqsave(&src_q->done_lock, flags);\n\tif (!list_empty(&src_q->done_list))\n\t\tsrc_vb = list_first_entry(&src_q->done_list, struct vb2_buffer,\n\t\t\t\t\t\t\t\tdone_entry);\n\tif (src_vb && (src_vb->state == VB2_BUF_STATE_DONE\n\t\t\t\t|| src_vb->state == VB2_BUF_STATE_ERROR))\n\t\trc |= EPOLLOUT | EPOLLWRNORM;\n\tspin_unlock_irqrestore(&src_q->done_lock, flags);\n\tspin_lock_irqsave(&dst_q->done_lock, flags);\n\tif (!list_empty(&dst_q->done_list))\n\t\tdst_vb = list_first_entry(&dst_q->done_list, struct vb2_buffer,\n\t\t\t\t\t\t\t\tdone_entry);\n\tif (dst_vb && (dst_vb->state == VB2_BUF_STATE_DONE\n\t\t\t\t|| dst_vb->state == VB2_BUF_STATE_ERROR))\n\t\trc |= EPOLLIN | EPOLLRDNORM;\n\tspin_unlock_irqrestore(&dst_q->done_lock, flags);\nend:\n\tmutex_unlock(&dev->mfc_mutex);\n\treturn rc;\n}\n\n \nstatic int s5p_mfc_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct s5p_mfc_ctx *ctx = fh_to_ctx(file->private_data);\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\tint ret;\n\n\tif (offset < DST_QUEUE_OFF_BASE) {\n\t\tmfc_debug(2, \"mmapping source\\n\");\n\t\tret = vb2_mmap(&ctx->vq_src, vma);\n\t} else {\t\t \n\t\tmfc_debug(2, \"mmapping destination\\n\");\n\t\tvma->vm_pgoff -= (DST_QUEUE_OFF_BASE >> PAGE_SHIFT);\n\t\tret = vb2_mmap(&ctx->vq_dst, vma);\n\t}\n\treturn ret;\n}\n\n \nstatic const struct v4l2_file_operations s5p_mfc_fops = {\n\t.owner = THIS_MODULE,\n\t.open = s5p_mfc_open,\n\t.release = s5p_mfc_release,\n\t.poll = s5p_mfc_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap = s5p_mfc_mmap,\n};\n\n \nstatic void s5p_mfc_memdev_release(struct device *dev)\n{\n\tof_reserved_mem_device_release(dev);\n}\n\nstatic struct device *s5p_mfc_alloc_memdev(struct device *dev,\n\t\t\t\t\t   const char *name, unsigned int idx)\n{\n\tstruct device *child;\n\tint ret;\n\n\tchild = devm_kzalloc(dev, sizeof(*child), GFP_KERNEL);\n\tif (!child)\n\t\treturn NULL;\n\n\tdevice_initialize(child);\n\tdev_set_name(child, \"%s:%s\", dev_name(dev), name);\n\tchild->parent = dev;\n\tchild->coherent_dma_mask = dev->coherent_dma_mask;\n\tchild->dma_mask = dev->dma_mask;\n\tchild->release = s5p_mfc_memdev_release;\n\tchild->dma_parms = devm_kzalloc(dev, sizeof(*child->dma_parms),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!child->dma_parms)\n\t\tgoto err;\n\n\t \n\tof_dma_configure(child, dev->of_node, true);\n\n\tif (device_add(child) == 0) {\n\t\tret = of_reserved_mem_device_init_by_idx(child, dev->of_node,\n\t\t\t\t\t\t\t idx);\n\t\tif (ret == 0)\n\t\t\treturn child;\n\t\tdevice_del(child);\n\t}\nerr:\n\tput_device(child);\n\treturn NULL;\n}\n\nstatic int s5p_mfc_configure_2port_memory(struct s5p_mfc_dev *mfc_dev)\n{\n\tstruct device *dev = &mfc_dev->plat_dev->dev;\n\tvoid *bank2_virt;\n\tdma_addr_t bank2_dma_addr;\n\tunsigned long align_size = 1 << MFC_BASE_ALIGN_ORDER;\n\tint ret;\n\n\t \n\tmfc_dev->mem_dev[BANK_L_CTX] = s5p_mfc_alloc_memdev(dev, \"left\",\n\t\t\t\t\t\t\t   BANK_L_CTX);\n\tif (!mfc_dev->mem_dev[BANK_L_CTX])\n\t\treturn -ENODEV;\n\tmfc_dev->mem_dev[BANK_R_CTX] = s5p_mfc_alloc_memdev(dev, \"right\",\n\t\t\t\t\t\t\t   BANK_R_CTX);\n\tif (!mfc_dev->mem_dev[BANK_R_CTX]) {\n\t\tdevice_unregister(mfc_dev->mem_dev[BANK_L_CTX]);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = s5p_mfc_alloc_firmware(mfc_dev);\n\tif (ret) {\n\t\tdevice_unregister(mfc_dev->mem_dev[BANK_R_CTX]);\n\t\tdevice_unregister(mfc_dev->mem_dev[BANK_L_CTX]);\n\t\treturn ret;\n\t}\n\n\tmfc_dev->dma_base[BANK_L_CTX] = mfc_dev->fw_buf.dma;\n\n\tbank2_virt = dma_alloc_coherent(mfc_dev->mem_dev[BANK_R_CTX],\n\t\t\t\t       align_size, &bank2_dma_addr, GFP_KERNEL);\n\tif (!bank2_virt) {\n\t\ts5p_mfc_release_firmware(mfc_dev);\n\t\tdevice_unregister(mfc_dev->mem_dev[BANK_R_CTX]);\n\t\tdevice_unregister(mfc_dev->mem_dev[BANK_L_CTX]);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmfc_dev->dma_base[BANK_R_CTX] = bank2_dma_addr - align_size;\n\n\tdma_free_coherent(mfc_dev->mem_dev[BANK_R_CTX], align_size, bank2_virt,\n\t\t\t  bank2_dma_addr);\n\n\tvb2_dma_contig_set_max_seg_size(mfc_dev->mem_dev[BANK_L_CTX],\n\t\t\t\t\tDMA_BIT_MASK(32));\n\tvb2_dma_contig_set_max_seg_size(mfc_dev->mem_dev[BANK_R_CTX],\n\t\t\t\t\tDMA_BIT_MASK(32));\n\n\treturn 0;\n}\n\nstatic void s5p_mfc_unconfigure_2port_memory(struct s5p_mfc_dev *mfc_dev)\n{\n\tdevice_unregister(mfc_dev->mem_dev[BANK_L_CTX]);\n\tdevice_unregister(mfc_dev->mem_dev[BANK_R_CTX]);\n\tvb2_dma_contig_clear_max_seg_size(mfc_dev->mem_dev[BANK_L_CTX]);\n\tvb2_dma_contig_clear_max_seg_size(mfc_dev->mem_dev[BANK_R_CTX]);\n}\n\nstatic int s5p_mfc_configure_common_memory(struct s5p_mfc_dev *mfc_dev)\n{\n\tstruct device *dev = &mfc_dev->plat_dev->dev;\n\tunsigned long mem_size = SZ_4M;\n\n\tif (IS_ENABLED(CONFIG_DMA_CMA) || exynos_is_iommu_available(dev))\n\t\tmem_size = SZ_8M;\n\n\tif (mfc_mem_size)\n\t\tmem_size = memparse(mfc_mem_size, NULL);\n\n\tmfc_dev->mem_bitmap = bitmap_zalloc(mem_size >> PAGE_SHIFT, GFP_KERNEL);\n\tif (!mfc_dev->mem_bitmap)\n\t\treturn -ENOMEM;\n\n\tmfc_dev->mem_virt = dma_alloc_coherent(dev, mem_size,\n\t\t\t\t\t       &mfc_dev->mem_base, GFP_KERNEL);\n\tif (!mfc_dev->mem_virt) {\n\t\tbitmap_free(mfc_dev->mem_bitmap);\n\t\tdev_err(dev, \"failed to preallocate %ld MiB for the firmware and context buffers\\n\",\n\t\t\t(mem_size / SZ_1M));\n\t\treturn -ENOMEM;\n\t}\n\tmfc_dev->mem_size = mem_size;\n\tmfc_dev->dma_base[BANK_L_CTX] = mfc_dev->mem_base;\n\tmfc_dev->dma_base[BANK_R_CTX] = mfc_dev->mem_base;\n\n\t \n\tif (mfc_dev->mem_base == (dma_addr_t)0) {\n\t\tunsigned int offset = 1 << MFC_BASE_ALIGN_ORDER;\n\n\t\tbitmap_set(mfc_dev->mem_bitmap, 0, offset >> PAGE_SHIFT);\n\t\tmfc_dev->dma_base[BANK_L_CTX] += offset;\n\t\tmfc_dev->dma_base[BANK_R_CTX] += offset;\n\t}\n\n\t \n\ts5p_mfc_alloc_firmware(mfc_dev);\n\n\tmfc_dev->mem_dev[BANK_L_CTX] = mfc_dev->mem_dev[BANK_R_CTX] = dev;\n\tvb2_dma_contig_set_max_seg_size(dev, DMA_BIT_MASK(32));\n\n\tdev_info(dev, \"preallocated %ld MiB buffer for the firmware and context buffers\\n\",\n\t\t (mem_size / SZ_1M));\n\n\treturn 0;\n}\n\nstatic void s5p_mfc_unconfigure_common_memory(struct s5p_mfc_dev *mfc_dev)\n{\n\tstruct device *dev = &mfc_dev->plat_dev->dev;\n\n\tdma_free_coherent(dev, mfc_dev->mem_size, mfc_dev->mem_virt,\n\t\t\t  mfc_dev->mem_base);\n\tbitmap_free(mfc_dev->mem_bitmap);\n\tvb2_dma_contig_clear_max_seg_size(dev);\n}\n\nstatic int s5p_mfc_configure_dma_memory(struct s5p_mfc_dev *mfc_dev)\n{\n\tstruct device *dev = &mfc_dev->plat_dev->dev;\n\n\tif (exynos_is_iommu_available(dev) || !IS_TWOPORT(mfc_dev))\n\t\treturn s5p_mfc_configure_common_memory(mfc_dev);\n\telse\n\t\treturn s5p_mfc_configure_2port_memory(mfc_dev);\n}\n\nstatic void s5p_mfc_unconfigure_dma_memory(struct s5p_mfc_dev *mfc_dev)\n{\n\tstruct device *dev = &mfc_dev->plat_dev->dev;\n\n\ts5p_mfc_release_firmware(mfc_dev);\n\tif (exynos_is_iommu_available(dev) || !IS_TWOPORT(mfc_dev))\n\t\ts5p_mfc_unconfigure_common_memory(mfc_dev);\n\telse\n\t\ts5p_mfc_unconfigure_2port_memory(mfc_dev);\n}\n\n \nstatic int s5p_mfc_probe(struct platform_device *pdev)\n{\n\tstruct s5p_mfc_dev *dev;\n\tstruct video_device *vfd;\n\tint ret;\n\n\tpr_debug(\"%s++\\n\", __func__);\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dev->irqlock);\n\tspin_lock_init(&dev->condlock);\n\tdev->plat_dev = pdev;\n\tif (!dev->plat_dev) {\n\t\tmfc_err(\"No platform data specified\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev->variant = of_device_get_match_data(&pdev->dev);\n\tif (!dev->variant) {\n\t\tdev_err(&pdev->dev, \"Failed to get device MFC hardware variant information\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tdev->regs_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->regs_base))\n\t\treturn PTR_ERR(dev->regs_base);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev->irq = ret;\n\tret = devm_request_irq(&pdev->dev, dev->irq, s5p_mfc_irq,\n\t\t\t\t\t0, pdev->name, dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to install irq (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = s5p_mfc_configure_dma_memory(dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to configure DMA memory\\n\");\n\t\treturn ret;\n\t}\n\n\tret = s5p_mfc_init_pm(dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get mfc clock source\\n\");\n\t\tgoto err_dma;\n\t}\n\n\t \n\ts5p_mfc_load_firmware(dev);\n\n\tmutex_init(&dev->mfc_mutex);\n\tinit_waitqueue_head(&dev->queue);\n\tdev->hw_lock = 0;\n\tINIT_WORK(&dev->watchdog_work, s5p_mfc_watchdog_worker);\n\tatomic_set(&dev->watchdog_cnt, 0);\n\ttimer_setup(&dev->watchdog_timer, s5p_mfc_watchdog, 0);\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret)\n\t\tgoto err_v4l2_dev_reg;\n\n\t \n\tvfd = video_device_alloc();\n\tif (!vfd) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to allocate video device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_dec_alloc;\n\t}\n\tvfd->fops\t= &s5p_mfc_fops;\n\tvfd->ioctl_ops\t= get_dec_v4l2_ioctl_ops();\n\tvfd->release\t= video_device_release;\n\tvfd->lock\t= &dev->mfc_mutex;\n\tvfd->v4l2_dev\t= &dev->v4l2_dev;\n\tvfd->vfl_dir\t= VFL_DIR_M2M;\n\tvfd->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;\n\tset_bit(V4L2_FL_QUIRK_INVERTED_CROP, &vfd->flags);\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s\", S5P_MFC_DEC_NAME);\n\tdev->vfd_dec\t= vfd;\n\tvideo_set_drvdata(vfd, dev);\n\n\t \n\tvfd = video_device_alloc();\n\tif (!vfd) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to allocate video device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_enc_alloc;\n\t}\n\tvfd->fops\t= &s5p_mfc_fops;\n\tvfd->ioctl_ops\t= get_enc_v4l2_ioctl_ops();\n\tvfd->release\t= video_device_release;\n\tvfd->lock\t= &dev->mfc_mutex;\n\tvfd->v4l2_dev\t= &dev->v4l2_dev;\n\tvfd->vfl_dir\t= VFL_DIR_M2M;\n\tvfd->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s\", S5P_MFC_ENC_NAME);\n\tdev->vfd_enc\t= vfd;\n\tvideo_set_drvdata(vfd, dev);\n\tplatform_set_drvdata(pdev, dev);\n\n\t \n\ts5p_mfc_init_hw_ops(dev);\n\ts5p_mfc_init_hw_cmds(dev);\n\ts5p_mfc_init_regs(dev);\n\n\t \n\tret = video_register_device(dev->vfd_dec, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto err_dec_reg;\n\t}\n\tv4l2_info(&dev->v4l2_dev,\n\t\t  \"decoder registered as /dev/video%d\\n\", dev->vfd_dec->num);\n\n\tret = video_register_device(dev->vfd_enc, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto err_enc_reg;\n\t}\n\tv4l2_info(&dev->v4l2_dev,\n\t\t  \"encoder registered as /dev/video%d\\n\", dev->vfd_enc->num);\n\n\tpr_debug(\"%s--\\n\", __func__);\n\treturn 0;\n\n \nerr_enc_reg:\n\tvideo_unregister_device(dev->vfd_dec);\n\tdev->vfd_dec = NULL;\nerr_dec_reg:\n\tvideo_device_release(dev->vfd_enc);\nerr_enc_alloc:\n\tvideo_device_release(dev->vfd_dec);\nerr_dec_alloc:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nerr_v4l2_dev_reg:\n\ts5p_mfc_final_pm(dev);\nerr_dma:\n\ts5p_mfc_unconfigure_dma_memory(dev);\n\n\tpr_debug(\"%s-- with error\\n\", __func__);\n\treturn ret;\n\n}\n\n \nstatic void s5p_mfc_remove(struct platform_device *pdev)\n{\n\tstruct s5p_mfc_dev *dev = platform_get_drvdata(pdev);\n\tstruct s5p_mfc_ctx *ctx;\n\tint i;\n\n\tv4l2_info(&dev->v4l2_dev, \"Removing %s\\n\", pdev->name);\n\n\t \n\tmutex_lock(&dev->mfc_mutex);\n\tfor (i = 0; i < MFC_NUM_CONTEXTS; i++) {\n\t\tctx = dev->ctx[i];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\t\t \n\t\tctx->dev = NULL;\n\t}\n\tmutex_unlock(&dev->mfc_mutex);\n\n\tdel_timer_sync(&dev->watchdog_timer);\n\tflush_work(&dev->watchdog_work);\n\n\tvideo_unregister_device(dev->vfd_enc);\n\tvideo_unregister_device(dev->vfd_dec);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\ts5p_mfc_unconfigure_dma_memory(dev);\n\n\ts5p_mfc_final_pm(dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int s5p_mfc_suspend(struct device *dev)\n{\n\tstruct s5p_mfc_dev *m_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (m_dev->num_inst == 0)\n\t\treturn 0;\n\n\tif (test_and_set_bit(0, &m_dev->enter_suspend) != 0) {\n\t\tmfc_err(\"Error: going to suspend for a second time\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\twhile (test_and_set_bit(0, &m_dev->hw_lock) != 0) {\n\t\t \n\t\t \n\t\tret = wait_event_interruptible_timeout(m_dev->queue,\n\t\t\tm_dev->int_cond, msecs_to_jiffies(MFC_INT_TIMEOUT));\n\t\tif (ret == 0) {\n\t\t\tmfc_err(\"Waiting for hardware to finish timed out\\n\");\n\t\t\tclear_bit(0, &m_dev->enter_suspend);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tret = s5p_mfc_sleep(m_dev);\n\tif (ret) {\n\t\tclear_bit(0, &m_dev->enter_suspend);\n\t\tclear_bit(0, &m_dev->hw_lock);\n\t}\n\treturn ret;\n}\n\nstatic int s5p_mfc_resume(struct device *dev)\n{\n\tstruct s5p_mfc_dev *m_dev = dev_get_drvdata(dev);\n\n\tif (m_dev->num_inst == 0)\n\t\treturn 0;\n\treturn s5p_mfc_wakeup(m_dev);\n}\n#endif\n\n \nstatic const struct dev_pm_ops s5p_mfc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(s5p_mfc_suspend, s5p_mfc_resume)\n};\n\nstatic struct s5p_mfc_buf_size_v5 mfc_buf_size_v5 = {\n\t.h264_ctx\t= MFC_H264_CTX_BUF_SIZE,\n\t.non_h264_ctx\t= MFC_CTX_BUF_SIZE,\n\t.dsc\t\t= DESC_BUF_SIZE,\n\t.shm\t\t= SHARED_BUF_SIZE,\n};\n\nstatic struct s5p_mfc_buf_size buf_size_v5 = {\n\t.fw\t= MAX_FW_SIZE,\n\t.cpb\t= MAX_CPB_SIZE,\n\t.priv\t= &mfc_buf_size_v5,\n};\n\nstatic struct s5p_mfc_variant mfc_drvdata_v5 = {\n\t.version\t= MFC_VERSION,\n\t.version_bit\t= MFC_V5_BIT,\n\t.port_num\t= MFC_NUM_PORTS,\n\t.buf_size\t= &buf_size_v5,\n\t.fw_name[0]\t= \"s5p-mfc.fw\",\n\t.clk_names\t= {\"mfc\", \"sclk_mfc\"},\n\t.num_clocks\t= 2,\n\t.use_clock_gating = true,\n};\n\nstatic struct s5p_mfc_buf_size_v6 mfc_buf_size_v6 = {\n\t.dev_ctx\t= MFC_CTX_BUF_SIZE_V6,\n\t.h264_dec_ctx\t= MFC_H264_DEC_CTX_BUF_SIZE_V6,\n\t.other_dec_ctx\t= MFC_OTHER_DEC_CTX_BUF_SIZE_V6,\n\t.h264_enc_ctx\t= MFC_H264_ENC_CTX_BUF_SIZE_V6,\n\t.other_enc_ctx\t= MFC_OTHER_ENC_CTX_BUF_SIZE_V6,\n};\n\nstatic struct s5p_mfc_buf_size buf_size_v6 = {\n\t.fw\t= MAX_FW_SIZE_V6,\n\t.cpb\t= MAX_CPB_SIZE_V6,\n\t.priv\t= &mfc_buf_size_v6,\n};\n\nstatic struct s5p_mfc_variant mfc_drvdata_v6 = {\n\t.version\t= MFC_VERSION_V6,\n\t.version_bit\t= MFC_V6_BIT,\n\t.port_num\t= MFC_NUM_PORTS_V6,\n\t.buf_size\t= &buf_size_v6,\n\t.fw_name[0]     = \"s5p-mfc-v6.fw\",\n\t \n\t.fw_name[1]     = \"s5p-mfc-v6-v2.fw\",\n\t.clk_names\t= {\"mfc\"},\n\t.num_clocks\t= 1,\n};\n\nstatic struct s5p_mfc_buf_size_v6 mfc_buf_size_v7 = {\n\t.dev_ctx\t= MFC_CTX_BUF_SIZE_V7,\n\t.h264_dec_ctx\t= MFC_H264_DEC_CTX_BUF_SIZE_V7,\n\t.other_dec_ctx\t= MFC_OTHER_DEC_CTX_BUF_SIZE_V7,\n\t.h264_enc_ctx\t= MFC_H264_ENC_CTX_BUF_SIZE_V7,\n\t.other_enc_ctx\t= MFC_OTHER_ENC_CTX_BUF_SIZE_V7,\n};\n\nstatic struct s5p_mfc_buf_size buf_size_v7 = {\n\t.fw\t= MAX_FW_SIZE_V7,\n\t.cpb\t= MAX_CPB_SIZE_V7,\n\t.priv\t= &mfc_buf_size_v7,\n};\n\nstatic struct s5p_mfc_variant mfc_drvdata_v7 = {\n\t.version\t= MFC_VERSION_V7,\n\t.version_bit\t= MFC_V7_BIT,\n\t.port_num\t= MFC_NUM_PORTS_V7,\n\t.buf_size\t= &buf_size_v7,\n\t.fw_name[0]     = \"s5p-mfc-v7.fw\",\n\t.clk_names\t= {\"mfc\"},\n\t.num_clocks\t= 1,\n};\n\nstatic struct s5p_mfc_variant mfc_drvdata_v7_3250 = {\n\t.version        = MFC_VERSION_V7,\n\t.version_bit    = MFC_V7_BIT,\n\t.port_num       = MFC_NUM_PORTS_V7,\n\t.buf_size       = &buf_size_v7,\n\t.fw_name[0]     = \"s5p-mfc-v7.fw\",\n\t.clk_names      = {\"mfc\", \"sclk_mfc\"},\n\t.num_clocks     = 2,\n};\n\nstatic struct s5p_mfc_buf_size_v6 mfc_buf_size_v8 = {\n\t.dev_ctx\t= MFC_CTX_BUF_SIZE_V8,\n\t.h264_dec_ctx\t= MFC_H264_DEC_CTX_BUF_SIZE_V8,\n\t.other_dec_ctx\t= MFC_OTHER_DEC_CTX_BUF_SIZE_V8,\n\t.h264_enc_ctx\t= MFC_H264_ENC_CTX_BUF_SIZE_V8,\n\t.other_enc_ctx\t= MFC_OTHER_ENC_CTX_BUF_SIZE_V8,\n};\n\nstatic struct s5p_mfc_buf_size buf_size_v8 = {\n\t.fw\t= MAX_FW_SIZE_V8,\n\t.cpb\t= MAX_CPB_SIZE_V8,\n\t.priv\t= &mfc_buf_size_v8,\n};\n\nstatic struct s5p_mfc_variant mfc_drvdata_v8 = {\n\t.version\t= MFC_VERSION_V8,\n\t.version_bit\t= MFC_V8_BIT,\n\t.port_num\t= MFC_NUM_PORTS_V8,\n\t.buf_size\t= &buf_size_v8,\n\t.fw_name[0]     = \"s5p-mfc-v8.fw\",\n\t.clk_names\t= {\"mfc\"},\n\t.num_clocks\t= 1,\n};\n\nstatic struct s5p_mfc_variant mfc_drvdata_v8_5433 = {\n\t.version\t= MFC_VERSION_V8,\n\t.version_bit\t= MFC_V8_BIT,\n\t.port_num\t= MFC_NUM_PORTS_V8,\n\t.buf_size\t= &buf_size_v8,\n\t.fw_name[0]     = \"s5p-mfc-v8.fw\",\n\t.clk_names\t= {\"pclk\", \"aclk\", \"aclk_xiu\"},\n\t.num_clocks\t= 3,\n};\n\nstatic struct s5p_mfc_buf_size_v6 mfc_buf_size_v10 = {\n\t.dev_ctx        = MFC_CTX_BUF_SIZE_V10,\n\t.h264_dec_ctx   = MFC_H264_DEC_CTX_BUF_SIZE_V10,\n\t.other_dec_ctx  = MFC_OTHER_DEC_CTX_BUF_SIZE_V10,\n\t.h264_enc_ctx   = MFC_H264_ENC_CTX_BUF_SIZE_V10,\n\t.hevc_enc_ctx   = MFC_HEVC_ENC_CTX_BUF_SIZE_V10,\n\t.other_enc_ctx  = MFC_OTHER_ENC_CTX_BUF_SIZE_V10,\n};\n\nstatic struct s5p_mfc_buf_size buf_size_v10 = {\n\t.fw     = MAX_FW_SIZE_V10,\n\t.cpb    = MAX_CPB_SIZE_V10,\n\t.priv   = &mfc_buf_size_v10,\n};\n\nstatic struct s5p_mfc_variant mfc_drvdata_v10 = {\n\t.version        = MFC_VERSION_V10,\n\t.version_bit    = MFC_V10_BIT,\n\t.port_num       = MFC_NUM_PORTS_V10,\n\t.buf_size       = &buf_size_v10,\n\t.fw_name[0]     = \"s5p-mfc-v10.fw\",\n};\n\nstatic const struct of_device_id exynos_mfc_match[] = {\n\t{\n\t\t.compatible = \"samsung,mfc-v5\",\n\t\t.data = &mfc_drvdata_v5,\n\t}, {\n\t\t.compatible = \"samsung,mfc-v6\",\n\t\t.data = &mfc_drvdata_v6,\n\t}, {\n\t\t.compatible = \"samsung,mfc-v7\",\n\t\t.data = &mfc_drvdata_v7,\n\t}, {\n\t\t.compatible = \"samsung,exynos3250-mfc\",\n\t\t.data = &mfc_drvdata_v7_3250,\n\t}, {\n\t\t.compatible = \"samsung,mfc-v8\",\n\t\t.data = &mfc_drvdata_v8,\n\t}, {\n\t\t.compatible = \"samsung,exynos5433-mfc\",\n\t\t.data = &mfc_drvdata_v8_5433,\n\t}, {\n\t\t.compatible = \"samsung,mfc-v10\",\n\t\t.data = &mfc_drvdata_v10,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, exynos_mfc_match);\n\nstatic struct platform_driver s5p_mfc_driver = {\n\t.probe\t\t= s5p_mfc_probe,\n\t.remove_new\t= s5p_mfc_remove,\n\t.driver\t= {\n\t\t.name\t= S5P_MFC_NAME,\n\t\t.pm\t= &s5p_mfc_pm_ops,\n\t\t.of_match_table = exynos_mfc_match,\n\t},\n};\n\nmodule_platform_driver(s5p_mfc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kamil Debski <k.debski@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung S5P Multi Format Codec V4L2 driver\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}