{
  "module_name": "s5p_mfc_opr_v6.c",
  "hash_id": "87fc2dd41bd48d4cb5abd64fd6c9e125e8a1760c1901a4942edbf50739f44d6c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s5p-mfc/s5p_mfc_opr_v6.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/firmware.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/dma-mapping.h>\n\n#include <asm/cacheflush.h>\n\n#include \"s5p_mfc_common.h\"\n#include \"s5p_mfc_cmd.h\"\n#include \"s5p_mfc_intr.h\"\n#include \"s5p_mfc_pm.h\"\n#include \"s5p_mfc_debug.h\"\n#include \"s5p_mfc_opr.h\"\n#include \"s5p_mfc_opr_v6.h\"\n\n \n#ifdef S5P_MFC_DEBUG_REGWRITE\n#undef writel\n#define writel(v, r)\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tpr_err(\"MFCWRITE(%p): %08x\\n\", r, (unsigned int)v);\t\\\n\t__raw_writel(v, r);\t\t\t\t\t\t\\\n\t} while (0)\n#endif  \n\n#define IS_MFCV6_V2(dev) (!IS_MFCV7_PLUS(dev) && dev->fw_ver == MFC_FW_V2)\n\n \nstatic int s5p_mfc_alloc_dec_temp_buffers_v6(struct s5p_mfc_ctx *ctx)\n{\n\t \n\n\treturn 0;\n}\n\n \nstatic void s5p_mfc_release_dec_desc_buffer_v6(struct s5p_mfc_ctx *ctx)\n{\n\t \n}\n\n \nstatic int s5p_mfc_alloc_codec_buffers_v6(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tunsigned int mb_width, mb_height;\n\tunsigned int lcu_width = 0, lcu_height = 0;\n\tint ret;\n\n\tmb_width = MB_WIDTH(ctx->img_width);\n\tmb_height = MB_HEIGHT(ctx->img_height);\n\n\tif (ctx->type == MFCINST_DECODER) {\n\t\tmfc_debug(2, \"Luma size:%d Chroma size:%d MV size:%d\\n\",\n\t\t\t  ctx->luma_size, ctx->chroma_size, ctx->mv_size);\n\t\tmfc_debug(2, \"Totals bufs: %d\\n\", ctx->total_dpb_count);\n\t} else if (ctx->type == MFCINST_ENCODER) {\n\t\tif (IS_MFCV10(dev)) {\n\t\t\tctx->tmv_buffer_size = 0;\n\t\t} else if (IS_MFCV8_PLUS(dev))\n\t\t\tctx->tmv_buffer_size = S5P_FIMV_NUM_TMV_BUFFERS_V6 *\n\t\t\tALIGN(S5P_FIMV_TMV_BUFFER_SIZE_V8(mb_width, mb_height),\n\t\t\tS5P_FIMV_TMV_BUFFER_ALIGN_V6);\n\t\telse\n\t\t\tctx->tmv_buffer_size = S5P_FIMV_NUM_TMV_BUFFERS_V6 *\n\t\t\tALIGN(S5P_FIMV_TMV_BUFFER_SIZE_V6(mb_width, mb_height),\n\t\t\tS5P_FIMV_TMV_BUFFER_ALIGN_V6);\n\t\tif (IS_MFCV10(dev)) {\n\t\t\tlcu_width = S5P_MFC_LCU_WIDTH(ctx->img_width);\n\t\t\tlcu_height = S5P_MFC_LCU_HEIGHT(ctx->img_height);\n\t\t\tif (ctx->codec_mode != S5P_FIMV_CODEC_HEVC_ENC) {\n\t\t\t\tctx->luma_dpb_size =\n\t\t\t\t\tALIGN((mb_width * 16), 64)\n\t\t\t\t\t* ALIGN((mb_height * 16), 32)\n\t\t\t\t\t\t+ 64;\n\t\t\t\tctx->chroma_dpb_size =\n\t\t\t\t\tALIGN((mb_width * 16), 64)\n\t\t\t\t\t\t\t* (mb_height * 8)\n\t\t\t\t\t\t\t+ 64;\n\t\t\t} else {\n\t\t\t\tctx->luma_dpb_size =\n\t\t\t\t\tALIGN((lcu_width * 32), 64)\n\t\t\t\t\t* ALIGN((lcu_height * 32), 32)\n\t\t\t\t\t\t+ 64;\n\t\t\t\tctx->chroma_dpb_size =\n\t\t\t\t\tALIGN((lcu_width * 32), 64)\n\t\t\t\t\t\t\t* (lcu_height * 16)\n\t\t\t\t\t\t\t+ 64;\n\t\t\t}\n\t\t} else {\n\t\t\tctx->luma_dpb_size = ALIGN((mb_width * mb_height) *\n\t\t\t\t\tS5P_FIMV_LUMA_MB_TO_PIXEL_V6,\n\t\t\t\t\tS5P_FIMV_LUMA_DPB_BUFFER_ALIGN_V6);\n\t\t\tctx->chroma_dpb_size = ALIGN((mb_width * mb_height) *\n\t\t\t\t\tS5P_FIMV_CHROMA_MB_TO_PIXEL_V6,\n\t\t\t\t\tS5P_FIMV_CHROMA_DPB_BUFFER_ALIGN_V6);\n\t\t}\n\t\tif (IS_MFCV8_PLUS(dev))\n\t\t\tctx->me_buffer_size = ALIGN(S5P_FIMV_ME_BUFFER_SIZE_V8(\n\t\t\t\t\t\tctx->img_width, ctx->img_height,\n\t\t\t\t\t\tmb_width, mb_height),\n\t\t\t\t\t\tS5P_FIMV_ME_BUFFER_ALIGN_V6);\n\t\telse\n\t\t\tctx->me_buffer_size = ALIGN(S5P_FIMV_ME_BUFFER_SIZE_V6(\n\t\t\t\t\t\tctx->img_width, ctx->img_height,\n\t\t\t\t\t\tmb_width, mb_height),\n\t\t\t\t\t\tS5P_FIMV_ME_BUFFER_ALIGN_V6);\n\n\t\tmfc_debug(2, \"recon luma size: %zu chroma size: %zu\\n\",\n\t\t\t  ctx->luma_dpb_size, ctx->chroma_dpb_size);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (ctx->codec_mode) {\n\tcase S5P_MFC_CODEC_H264_DEC:\n\tcase S5P_MFC_CODEC_H264_MVC_DEC:\n\t\tif (IS_MFCV10(dev))\n\t\t\tmfc_debug(2, \"Use min scratch buffer size\\n\");\n\t\telse if (IS_MFCV8_PLUS(dev))\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_H264_DEC_V8(\n\t\t\t\t\tmb_width,\n\t\t\t\t\tmb_height);\n\t\telse\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_H264_DEC_V6(\n\t\t\t\t\tmb_width,\n\t\t\t\t\tmb_height);\n\t\tctx->scratch_buf_size = ALIGN(ctx->scratch_buf_size,\n\t\t\t\tS5P_FIMV_SCRATCH_BUFFER_ALIGN_V6);\n\t\tctx->bank1.size =\n\t\t\tctx->scratch_buf_size +\n\t\t\t(ctx->mv_count * ctx->mv_size);\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG4_DEC:\n\t\tif (IS_MFCV10(dev))\n\t\t\tmfc_debug(2, \"Use min scratch buffer size\\n\");\n\t\telse if (IS_MFCV7_PLUS(dev)) {\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_MPEG4_DEC_V7(\n\t\t\t\t\t\tmb_width,\n\t\t\t\t\t\tmb_height);\n\t\t} else {\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_MPEG4_DEC_V6(\n\t\t\t\t\t\tmb_width,\n\t\t\t\t\t\tmb_height);\n\t\t}\n\n\t\tctx->scratch_buf_size = ALIGN(ctx->scratch_buf_size,\n\t\t\t\tS5P_FIMV_SCRATCH_BUFFER_ALIGN_V6);\n\t\tctx->bank1.size = ctx->scratch_buf_size;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_VC1RCV_DEC:\n\tcase S5P_MFC_CODEC_VC1_DEC:\n\t\tif (IS_MFCV10(dev))\n\t\t\tmfc_debug(2, \"Use min scratch buffer size\\n\");\n\t\telse\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_VC1_DEC_V6(\n\t\t\t\t\t\tmb_width,\n\t\t\t\t\t\tmb_height);\n\n\t\tctx->scratch_buf_size = ALIGN(ctx->scratch_buf_size,\n\t\t\t\tS5P_FIMV_SCRATCH_BUFFER_ALIGN_V6);\n\t\tctx->bank1.size = ctx->scratch_buf_size;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG2_DEC:\n\t\tctx->bank1.size = 0;\n\t\tctx->bank2.size = 0;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_H263_DEC:\n\t\tif (IS_MFCV10(dev))\n\t\t\tmfc_debug(2, \"Use min scratch buffer size\\n\");\n\t\telse\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_H263_DEC_V6(\n\t\t\t\t\t\tmb_width,\n\t\t\t\t\t\tmb_height);\n\t\tctx->scratch_buf_size = ALIGN(ctx->scratch_buf_size,\n\t\t\t\tS5P_FIMV_SCRATCH_BUFFER_ALIGN_V6);\n\t\tctx->bank1.size = ctx->scratch_buf_size;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_VP8_DEC:\n\t\tif (IS_MFCV10(dev))\n\t\t\tmfc_debug(2, \"Use min scratch buffer size\\n\");\n\t\telse if (IS_MFCV8_PLUS(dev))\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_VP8_DEC_V8(\n\t\t\t\t\t\tmb_width,\n\t\t\t\t\t\tmb_height);\n\t\telse\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_VP8_DEC_V6(\n\t\t\t\t\t\tmb_width,\n\t\t\t\t\t\tmb_height);\n\t\tctx->scratch_buf_size = ALIGN(ctx->scratch_buf_size,\n\t\t\t\tS5P_FIMV_SCRATCH_BUFFER_ALIGN_V6);\n\t\tctx->bank1.size = ctx->scratch_buf_size;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_HEVC_DEC:\n\t\tmfc_debug(2, \"Use min scratch buffer size\\n\");\n\t\tctx->bank1.size =\n\t\t\tctx->scratch_buf_size +\n\t\t\t(ctx->mv_count * ctx->mv_size);\n\t\tbreak;\n\tcase S5P_MFC_CODEC_VP9_DEC:\n\t\tmfc_debug(2, \"Use min scratch buffer size\\n\");\n\t\tctx->bank1.size =\n\t\t\tctx->scratch_buf_size +\n\t\t\tDEC_VP9_STATIC_BUFFER_SIZE;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_H264_ENC:\n\t\tif (IS_MFCV10(dev)) {\n\t\t\tmfc_debug(2, \"Use min scratch buffer size\\n\");\n\t\t\tctx->me_buffer_size =\n\t\t\tALIGN(ENC_V100_H264_ME_SIZE(mb_width, mb_height), 16);\n\t\t} else if (IS_MFCV8_PLUS(dev))\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_H264_ENC_V8(\n\t\t\t\t\tmb_width,\n\t\t\t\t\tmb_height);\n\t\telse\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_H264_ENC_V6(\n\t\t\t\t\t\tmb_width,\n\t\t\t\t\t\tmb_height);\n\t\tctx->scratch_buf_size = ALIGN(ctx->scratch_buf_size,\n\t\t\t\tS5P_FIMV_SCRATCH_BUFFER_ALIGN_V6);\n\t\tctx->bank1.size =\n\t\t\tctx->scratch_buf_size + ctx->tmv_buffer_size +\n\t\t\t(ctx->pb_count * (ctx->luma_dpb_size +\n\t\t\tctx->chroma_dpb_size + ctx->me_buffer_size));\n\t\tctx->bank2.size = 0;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG4_ENC:\n\tcase S5P_MFC_CODEC_H263_ENC:\n\t\tif (IS_MFCV10(dev)) {\n\t\t\tmfc_debug(2, \"Use min scratch buffer size\\n\");\n\t\t\tctx->me_buffer_size =\n\t\t\t\tALIGN(ENC_V100_MPEG4_ME_SIZE(mb_width,\n\t\t\t\t\t\t\tmb_height), 16);\n\t\t} else\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_MPEG4_ENC_V6(\n\t\t\t\t\t\tmb_width,\n\t\t\t\t\t\tmb_height);\n\t\tctx->scratch_buf_size = ALIGN(ctx->scratch_buf_size,\n\t\t\t\tS5P_FIMV_SCRATCH_BUFFER_ALIGN_V6);\n\t\tctx->bank1.size =\n\t\t\tctx->scratch_buf_size + ctx->tmv_buffer_size +\n\t\t\t(ctx->pb_count * (ctx->luma_dpb_size +\n\t\t\tctx->chroma_dpb_size + ctx->me_buffer_size));\n\t\tctx->bank2.size = 0;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_VP8_ENC:\n\t\tif (IS_MFCV10(dev)) {\n\t\t\tmfc_debug(2, \"Use min scratch buffer size\\n\");\n\t\t\tctx->me_buffer_size =\n\t\t\t\tALIGN(ENC_V100_VP8_ME_SIZE(mb_width, mb_height),\n\t\t\t\t\t\t16);\n\t\t} else if (IS_MFCV8_PLUS(dev))\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_VP8_ENC_V8(\n\t\t\t\t\tmb_width,\n\t\t\t\t\tmb_height);\n\t\telse\n\t\t\tctx->scratch_buf_size =\n\t\t\t\tS5P_FIMV_SCRATCH_BUF_SIZE_VP8_ENC_V7(\n\t\t\t\t\t\tmb_width,\n\t\t\t\t\t\tmb_height);\n\t\tctx->scratch_buf_size = ALIGN(ctx->scratch_buf_size,\n\t\t\t\tS5P_FIMV_SCRATCH_BUFFER_ALIGN_V6);\n\t\tctx->bank1.size =\n\t\t\tctx->scratch_buf_size + ctx->tmv_buffer_size +\n\t\t\t(ctx->pb_count * (ctx->luma_dpb_size +\n\t\t\tctx->chroma_dpb_size + ctx->me_buffer_size));\n\t\tctx->bank2.size = 0;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_HEVC_ENC:\n\t\tmfc_debug(2, \"Use min scratch buffer size\\n\");\n\t\tctx->me_buffer_size =\n\t\t\tALIGN(ENC_V100_HEVC_ME_SIZE(lcu_width, lcu_height), 16);\n\t\tctx->scratch_buf_size = ALIGN(ctx->scratch_buf_size, 256);\n\t\tctx->bank1.size =\n\t\t\tctx->scratch_buf_size + ctx->tmv_buffer_size +\n\t\t\t(ctx->pb_count * (ctx->luma_dpb_size +\n\t\t\tctx->chroma_dpb_size + ctx->me_buffer_size));\n\t\tctx->bank2.size = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (ctx->bank1.size > 0) {\n\t\tret = s5p_mfc_alloc_generic_buf(dev, BANK_L_CTX, &ctx->bank1);\n\t\tif (ret) {\n\t\t\tmfc_err(\"Failed to allocate Bank1 memory\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tBUG_ON(ctx->bank1.dma & ((1 << MFC_BANK1_ALIGN_ORDER) - 1));\n\t}\n\treturn 0;\n}\n\n \nstatic void s5p_mfc_release_codec_buffers_v6(struct s5p_mfc_ctx *ctx)\n{\n\ts5p_mfc_release_generic_buf(ctx->dev, &ctx->bank1);\n}\n\n \nstatic int s5p_mfc_alloc_instance_buffer_v6(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf_size_v6 *buf_size = dev->variant->buf_size->priv;\n\tint ret;\n\n\tmfc_debug_enter();\n\n\tswitch (ctx->codec_mode) {\n\tcase S5P_MFC_CODEC_H264_DEC:\n\tcase S5P_MFC_CODEC_H264_MVC_DEC:\n\tcase S5P_MFC_CODEC_HEVC_DEC:\n\t\tctx->ctx.size = buf_size->h264_dec_ctx;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG4_DEC:\n\tcase S5P_MFC_CODEC_H263_DEC:\n\tcase S5P_MFC_CODEC_VC1RCV_DEC:\n\tcase S5P_MFC_CODEC_VC1_DEC:\n\tcase S5P_MFC_CODEC_MPEG2_DEC:\n\tcase S5P_MFC_CODEC_VP8_DEC:\n\tcase S5P_MFC_CODEC_VP9_DEC:\n\t\tctx->ctx.size = buf_size->other_dec_ctx;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_H264_ENC:\n\t\tctx->ctx.size = buf_size->h264_enc_ctx;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_HEVC_ENC:\n\t\tctx->ctx.size = buf_size->hevc_enc_ctx;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG4_ENC:\n\tcase S5P_MFC_CODEC_H263_ENC:\n\tcase S5P_MFC_CODEC_VP8_ENC:\n\t\tctx->ctx.size = buf_size->other_enc_ctx;\n\t\tbreak;\n\tdefault:\n\t\tctx->ctx.size = 0;\n\t\tmfc_err(\"Codec type(%d) should be checked!\\n\", ctx->codec_mode);\n\t\tbreak;\n\t}\n\n\tret = s5p_mfc_alloc_priv_buf(dev, BANK_L_CTX, &ctx->ctx);\n\tif (ret) {\n\t\tmfc_err(\"Failed to allocate instance buffer\\n\");\n\t\treturn ret;\n\t}\n\n\tmemset(ctx->ctx.virt, 0, ctx->ctx.size);\n\twmb();\n\n\tmfc_debug_leave();\n\n\treturn 0;\n}\n\n \nstatic void s5p_mfc_release_instance_buffer_v6(struct s5p_mfc_ctx *ctx)\n{\n\ts5p_mfc_release_priv_buf(ctx->dev, &ctx->ctx);\n}\n\n \nstatic int s5p_mfc_alloc_dev_context_buffer_v6(struct s5p_mfc_dev *dev)\n{\n\tstruct s5p_mfc_buf_size_v6 *buf_size = dev->variant->buf_size->priv;\n\tint ret;\n\n\tmfc_debug_enter();\n\n\tdev->ctx_buf.size = buf_size->dev_ctx;\n\tret = s5p_mfc_alloc_priv_buf(dev, BANK_L_CTX, &dev->ctx_buf);\n\tif (ret) {\n\t\tmfc_err(\"Failed to allocate device context buffer\\n\");\n\t\treturn ret;\n\t}\n\n\tmemset(dev->ctx_buf.virt, 0, buf_size->dev_ctx);\n\twmb();\n\n\tmfc_debug_leave();\n\n\treturn 0;\n}\n\n \nstatic void s5p_mfc_release_dev_context_buffer_v6(struct s5p_mfc_dev *dev)\n{\n\ts5p_mfc_release_priv_buf(dev, &dev->ctx_buf);\n}\n\nstatic int calc_plane(int width, int height)\n{\n\tint mbX, mbY;\n\n\tmbX = DIV_ROUND_UP(width, S5P_FIMV_NUM_PIXELS_IN_MB_ROW_V6);\n\tmbY = DIV_ROUND_UP(height, S5P_FIMV_NUM_PIXELS_IN_MB_COL_V6);\n\n\tif (width * height < S5P_FIMV_MAX_FRAME_SIZE_V6)\n\t\tmbY = (mbY + 1) / 2 * 2;\n\n\treturn (mbX * S5P_FIMV_NUM_PIXELS_IN_MB_COL_V6) *\n\t\t(mbY * S5P_FIMV_NUM_PIXELS_IN_MB_ROW_V6);\n}\n\nstatic void s5p_mfc_dec_calc_dpb_size_v6(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tctx->buf_width = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN_V6);\n\tctx->buf_height = ALIGN(ctx->img_height, S5P_FIMV_NV12MT_VALIGN_V6);\n\tmfc_debug(2, \"SEQ Done: Movie dimensions %dx%d,\\n\"\n\t\t\t\"buffer dimensions: %dx%d\\n\", ctx->img_width,\n\t\t\tctx->img_height, ctx->buf_width, ctx->buf_height);\n\n\tctx->luma_size = calc_plane(ctx->img_width, ctx->img_height);\n\tctx->chroma_size = calc_plane(ctx->img_width, (ctx->img_height >> 1));\n\tif (IS_MFCV8_PLUS(ctx->dev)) {\n\t\t \n\t\tctx->luma_size += S5P_FIMV_D_ALIGN_PLANE_SIZE_V8;\n\t\tctx->chroma_size += S5P_FIMV_D_ALIGN_PLANE_SIZE_V8;\n\t}\n\n\tif (ctx->codec_mode == S5P_MFC_CODEC_H264_DEC ||\n\t\t\tctx->codec_mode == S5P_MFC_CODEC_H264_MVC_DEC) {\n\t\tif (IS_MFCV10(dev)) {\n\t\t\tctx->mv_size = S5P_MFC_DEC_MV_SIZE_V10(ctx->img_width,\n\t\t\t\t\tctx->img_height);\n\t\t} else {\n\t\t\tctx->mv_size = S5P_MFC_DEC_MV_SIZE_V6(ctx->img_width,\n\t\t\t\t\tctx->img_height);\n\t\t}\n\t} else if (ctx->codec_mode == S5P_MFC_CODEC_HEVC_DEC) {\n\t\tctx->mv_size = s5p_mfc_dec_hevc_mv_size(ctx->img_width,\n\t\t\t\tctx->img_height);\n\t\tctx->mv_size = ALIGN(ctx->mv_size, 32);\n\t} else {\n\t\tctx->mv_size = 0;\n\t}\n}\n\nstatic void s5p_mfc_enc_calc_src_size_v6(struct s5p_mfc_ctx *ctx)\n{\n\tunsigned int mb_width, mb_height;\n\n\tmb_width = MB_WIDTH(ctx->img_width);\n\tmb_height = MB_HEIGHT(ctx->img_height);\n\n\tctx->buf_width = ALIGN(ctx->img_width, S5P_FIMV_NV12M_HALIGN_V6);\n\tctx->luma_size = ALIGN((mb_width * mb_height) * 256, 256);\n\tctx->chroma_size = ALIGN((mb_width * mb_height) * 128, 256);\n\n\t \n\tif (IS_MFCV7_PLUS(ctx->dev)) {\n\t\tctx->luma_size += MFC_LUMA_PAD_BYTES_V7;\n\t\tctx->chroma_size += MFC_CHROMA_PAD_BYTES_V7;\n\t}\n}\n\n \nstatic int s5p_mfc_set_dec_stream_buffer_v6(struct s5p_mfc_ctx *ctx,\n\t\t\tint buf_addr, unsigned int start_num_byte,\n\t\t\tunsigned int strm_size)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tstruct s5p_mfc_buf_size *buf_size = dev->variant->buf_size;\n\n\tmfc_debug_enter();\n\tmfc_debug(2, \"inst_no: %d, buf_addr: 0x%08x,\\n\"\n\t\t\"buf_size: 0x%08x (%d)\\n\",\n\t\tctx->inst_no, buf_addr, strm_size, strm_size);\n\twritel(strm_size, mfc_regs->d_stream_data_size);\n\twritel(buf_addr, mfc_regs->d_cpb_buffer_addr);\n\twritel(buf_size->cpb, mfc_regs->d_cpb_buffer_size);\n\twritel(start_num_byte, mfc_regs->d_cpb_buffer_offset);\n\n\tmfc_debug_leave();\n\treturn 0;\n}\n\n \nstatic int s5p_mfc_set_dec_frame_buffer_v6(struct s5p_mfc_ctx *ctx)\n{\n\tunsigned int frame_size, i;\n\tunsigned int frame_size_ch, frame_size_mv;\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tsize_t buf_addr1;\n\tint buf_size1;\n\tint align_gap;\n\n\tbuf_addr1 = ctx->bank1.dma;\n\tbuf_size1 = ctx->bank1.size;\n\n\tmfc_debug(2, \"Buf1: %p (%d)\\n\", (void *)buf_addr1, buf_size1);\n\tmfc_debug(2, \"Total DPB COUNT: %d\\n\", ctx->total_dpb_count);\n\tmfc_debug(2, \"Setting display delay to %d\\n\", ctx->display_delay);\n\n\twritel(ctx->total_dpb_count, mfc_regs->d_num_dpb);\n\twritel(ctx->luma_size, mfc_regs->d_first_plane_dpb_size);\n\twritel(ctx->chroma_size, mfc_regs->d_second_plane_dpb_size);\n\n\twritel(buf_addr1, mfc_regs->d_scratch_buffer_addr);\n\twritel(ctx->scratch_buf_size, mfc_regs->d_scratch_buffer_size);\n\n\tif (IS_MFCV8_PLUS(dev)) {\n\t\twritel(ctx->img_width,\n\t\t\tmfc_regs->d_first_plane_dpb_stride_size);\n\t\twritel(ctx->img_width,\n\t\t\tmfc_regs->d_second_plane_dpb_stride_size);\n\t}\n\n\tbuf_addr1 += ctx->scratch_buf_size;\n\tbuf_size1 -= ctx->scratch_buf_size;\n\n\tif (ctx->codec_mode == S5P_FIMV_CODEC_H264_DEC ||\n\t\t\tctx->codec_mode == S5P_FIMV_CODEC_H264_MVC_DEC ||\n\t\t\tctx->codec_mode == S5P_FIMV_CODEC_HEVC_DEC) {\n\t\twritel(ctx->mv_size, mfc_regs->d_mv_buffer_size);\n\t\twritel(ctx->mv_count, mfc_regs->d_num_mv);\n\t}\n\n\tframe_size = ctx->luma_size;\n\tframe_size_ch = ctx->chroma_size;\n\tframe_size_mv = ctx->mv_size;\n\tmfc_debug(2, \"Frame size: %d ch: %d mv: %d\\n\",\n\t\t\tframe_size, frame_size_ch, frame_size_mv);\n\n\tfor (i = 0; i < ctx->total_dpb_count; i++) {\n\t\t \n\t\tmfc_debug(2, \"Luma %d: %zx\\n\", i,\n\t\t\t\t\tctx->dst_bufs[i].cookie.raw.luma);\n\t\twritel(ctx->dst_bufs[i].cookie.raw.luma,\n\t\t\t\tmfc_regs->d_first_plane_dpb + i * 4);\n\t\tmfc_debug(2, \"\\tChroma %d: %zx\\n\", i,\n\t\t\t\t\tctx->dst_bufs[i].cookie.raw.chroma);\n\t\twritel(ctx->dst_bufs[i].cookie.raw.chroma,\n\t\t\t\tmfc_regs->d_second_plane_dpb + i * 4);\n\t}\n\tif (ctx->codec_mode == S5P_MFC_CODEC_H264_DEC ||\n\t\t\tctx->codec_mode == S5P_MFC_CODEC_H264_MVC_DEC ||\n\t\t\tctx->codec_mode == S5P_MFC_CODEC_HEVC_DEC) {\n\t\tfor (i = 0; i < ctx->mv_count; i++) {\n\t\t\t \n\t\t\talign_gap = buf_addr1;\n\t\t\tbuf_addr1 = ALIGN(buf_addr1, 16);\n\t\t\talign_gap = buf_addr1 - align_gap;\n\t\t\tbuf_size1 -= align_gap;\n\n\t\t\tmfc_debug(2, \"\\tBuf1: %zx, size: %d\\n\",\n\t\t\t\t\tbuf_addr1, buf_size1);\n\t\t\twritel(buf_addr1, mfc_regs->d_mv_buffer + i * 4);\n\t\t\tbuf_addr1 += frame_size_mv;\n\t\t\tbuf_size1 -= frame_size_mv;\n\t\t}\n\t}\n\tif (ctx->codec_mode == S5P_FIMV_CODEC_VP9_DEC) {\n\t\twritel(buf_addr1, mfc_regs->d_static_buffer_addr);\n\t\twritel(DEC_VP9_STATIC_BUFFER_SIZE,\n\t\t\t\tmfc_regs->d_static_buffer_size);\n\t\tbuf_addr1 += DEC_VP9_STATIC_BUFFER_SIZE;\n\t\tbuf_size1 -= DEC_VP9_STATIC_BUFFER_SIZE;\n\t}\n\n\tmfc_debug(2, \"Buf1: %zx, buf_size1: %d (frames %d)\\n\",\n\t\t\tbuf_addr1, buf_size1, ctx->total_dpb_count);\n\tif (buf_size1 < 0) {\n\t\tmfc_debug(2, \"Not enough memory has been allocated.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twritel(ctx->inst_no, mfc_regs->instance_id);\n\ts5p_mfc_hw_call(dev->mfc_cmds, cmd_host2risc, dev,\n\t\t\tS5P_FIMV_CH_INIT_BUFS_V6, NULL);\n\n\tmfc_debug(2, \"After setting buffers.\\n\");\n\treturn 0;\n}\n\n \nstatic int s5p_mfc_set_enc_stream_buffer_v6(struct s5p_mfc_ctx *ctx,\n\t\tunsigned long addr, unsigned int size)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\n\twritel(addr, mfc_regs->e_stream_buffer_addr);  \n\twritel(size, mfc_regs->e_stream_buffer_size);\n\n\tmfc_debug(2, \"stream buf addr: 0x%08lx, size: 0x%x\\n\",\n\t\t  addr, size);\n\n\treturn 0;\n}\n\nstatic void s5p_mfc_set_enc_frame_buffer_v6(struct s5p_mfc_ctx *ctx,\n\t\tunsigned long y_addr, unsigned long c_addr)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\n\twritel(y_addr, mfc_regs->e_source_first_plane_addr);\n\twritel(c_addr, mfc_regs->e_source_second_plane_addr);\n\n\tmfc_debug(2, \"enc src y buf addr: 0x%08lx\\n\", y_addr);\n\tmfc_debug(2, \"enc src c buf addr: 0x%08lx\\n\", c_addr);\n}\n\nstatic void s5p_mfc_get_enc_frame_buffer_v6(struct s5p_mfc_ctx *ctx,\n\t\tunsigned long *y_addr, unsigned long *c_addr)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tunsigned long enc_recon_y_addr, enc_recon_c_addr;\n\n\t*y_addr = readl(mfc_regs->e_encoded_source_first_plane_addr);\n\t*c_addr = readl(mfc_regs->e_encoded_source_second_plane_addr);\n\n\tenc_recon_y_addr = readl(mfc_regs->e_recon_luma_dpb_addr);\n\tenc_recon_c_addr = readl(mfc_regs->e_recon_chroma_dpb_addr);\n\n\tmfc_debug(2, \"recon y addr: 0x%08lx y_addr: 0x%08lx\\n\", enc_recon_y_addr, *y_addr);\n\tmfc_debug(2, \"recon c addr: 0x%08lx\\n\", enc_recon_c_addr);\n}\n\n \nstatic int s5p_mfc_set_enc_ref_buffer_v6(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tsize_t buf_addr1;\n\tint i, buf_size1;\n\n\tmfc_debug_enter();\n\n\tbuf_addr1 = ctx->bank1.dma;\n\tbuf_size1 = ctx->bank1.size;\n\n\tmfc_debug(2, \"Buf1: %p (%d)\\n\", (void *)buf_addr1, buf_size1);\n\n\tif (IS_MFCV10(dev)) {\n\t\t \n\t\tfor (i = 0; i < ctx->pb_count; i++) {\n\t\t\twritel(buf_addr1, mfc_regs->e_luma_dpb + (4 * i));\n\t\t\tbuf_addr1 += ctx->luma_dpb_size;\n\t\t\tbuf_size1 -= ctx->luma_dpb_size;\n\t\t}\n\t\tfor (i = 0; i < ctx->pb_count; i++) {\n\t\t\twritel(buf_addr1, mfc_regs->e_chroma_dpb + (4 * i));\n\t\t\tbuf_addr1 += ctx->chroma_dpb_size;\n\t\t\tbuf_size1 -= ctx->chroma_dpb_size;\n\t\t}\n\t\tfor (i = 0; i < ctx->pb_count; i++) {\n\t\t\twritel(buf_addr1, mfc_regs->e_me_buffer + (4 * i));\n\t\t\tbuf_addr1 += ctx->me_buffer_size;\n\t\t\tbuf_size1 -= ctx->me_buffer_size;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ctx->pb_count; i++) {\n\t\t\twritel(buf_addr1, mfc_regs->e_luma_dpb + (4 * i));\n\t\t\tbuf_addr1 += ctx->luma_dpb_size;\n\t\t\twritel(buf_addr1, mfc_regs->e_chroma_dpb + (4 * i));\n\t\t\tbuf_addr1 += ctx->chroma_dpb_size;\n\t\t\twritel(buf_addr1, mfc_regs->e_me_buffer + (4 * i));\n\t\t\tbuf_addr1 += ctx->me_buffer_size;\n\t\t\tbuf_size1 -= (ctx->luma_dpb_size + ctx->chroma_dpb_size\n\t\t\t\t\t+ ctx->me_buffer_size);\n\t\t}\n\t}\n\n\twritel(buf_addr1, mfc_regs->e_scratch_buffer_addr);\n\twritel(ctx->scratch_buf_size, mfc_regs->e_scratch_buffer_size);\n\tbuf_addr1 += ctx->scratch_buf_size;\n\tbuf_size1 -= ctx->scratch_buf_size;\n\n\twritel(buf_addr1, mfc_regs->e_tmv_buffer0);\n\tbuf_addr1 += ctx->tmv_buffer_size >> 1;\n\twritel(buf_addr1, mfc_regs->e_tmv_buffer1);\n\tbuf_addr1 += ctx->tmv_buffer_size >> 1;\n\tbuf_size1 -= ctx->tmv_buffer_size;\n\n\tmfc_debug(2, \"Buf1: %zu, buf_size1: %d (ref frames %d)\\n\",\n\t\t\tbuf_addr1, buf_size1, ctx->pb_count);\n\tif (buf_size1 < 0) {\n\t\tmfc_debug(2, \"Not enough memory has been allocated.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twritel(ctx->inst_no, mfc_regs->instance_id);\n\ts5p_mfc_hw_call(dev->mfc_cmds, cmd_host2risc, dev,\n\t\t\tS5P_FIMV_CH_INIT_BUFS_V6, NULL);\n\n\tmfc_debug_leave();\n\n\treturn 0;\n}\n\nstatic int s5p_mfc_set_slice_mode(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\n\t \n\t \n\twritel(ctx->slice_mode, mfc_regs->e_mslice_mode);\n\tif (ctx->slice_mode == V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB) {\n\t\twritel(ctx->slice_size.mb, mfc_regs->e_mslice_size_mb);\n\t} else if (ctx->slice_mode ==\n\t\t\tV4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES) {\n\t\twritel(ctx->slice_size.bits, mfc_regs->e_mslice_size_bits);\n\t} else {\n\t\twritel(0x0, mfc_regs->e_mslice_size_mb);\n\t\twritel(0x0, mfc_regs->e_mslice_size_bits);\n\t}\n\n\treturn 0;\n}\n\nstatic int s5p_mfc_set_enc_params(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tunsigned int reg = 0;\n\n\tmfc_debug_enter();\n\n\t \n\twritel(ctx->img_width, mfc_regs->e_frame_width);  \n\t \n\twritel(ctx->img_height, mfc_regs->e_frame_height);  \n\n\t \n\twritel(ctx->img_width, mfc_regs->e_cropped_frame_width);\n\t \n\twritel(ctx->img_height, mfc_regs->e_cropped_frame_height);\n\t \n\twritel(0x0, mfc_regs->e_frame_crop_offset);\n\n\t \n\treg = 0;\n\treg |= p->gop_size & 0xFFFF;\n\twritel(reg, mfc_regs->e_gop_config);\n\n\t \n\t \n\tctx->slice_mode = p->slice_mode;\n\treg = 0;\n\tif (p->slice_mode == V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB) {\n\t\treg |= (0x1 << 3);\n\t\twritel(reg, mfc_regs->e_enc_options);\n\t\tctx->slice_size.mb = p->slice_mb;\n\t} else if (p->slice_mode == V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES) {\n\t\treg |= (0x1 << 3);\n\t\twritel(reg, mfc_regs->e_enc_options);\n\t\tctx->slice_size.bits = p->slice_bit;\n\t} else {\n\t\treg &= ~(0x1 << 3);\n\t\twritel(reg, mfc_regs->e_enc_options);\n\t}\n\n\ts5p_mfc_set_slice_mode(ctx);\n\n\t \n\twritel(p->intra_refresh_mb, mfc_regs->e_ir_size);\n\treg = readl(mfc_regs->e_enc_options);\n\tif (p->intra_refresh_mb == 0)\n\t\treg &= ~(0x1 << 4);\n\telse\n\t\treg |= (0x1 << 4);\n\twritel(reg, mfc_regs->e_enc_options);\n\n\t \n\treg = readl(mfc_regs->e_enc_options);\n\treg &= ~(0x1 << 9);\n\twritel(reg, mfc_regs->e_enc_options);\n\n\t \n\tif (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12M) {\n\t\t \n\t\treg = readl(mfc_regs->e_enc_options);\n\t\treg &= ~(0x1 << 7);\n\t\twritel(reg, mfc_regs->e_enc_options);\n\t\t \n\t\twritel(0x0, mfc_regs->pixel_format);\n\t} else if (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV21M) {\n\t\t \n\t\treg = readl(mfc_regs->e_enc_options);\n\t\treg &= ~(0x1 << 7);\n\t\twritel(reg, mfc_regs->e_enc_options);\n\t\t \n\t\twritel(0x1, mfc_regs->pixel_format);\n\t} else if (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12MT_16X16) {\n\t\t \n\t\treg = readl(mfc_regs->e_enc_options);\n\t\treg |= (0x1 << 7);\n\t\twritel(reg, mfc_regs->e_enc_options);\n\t\t \n\t\twritel(0x0, mfc_regs->pixel_format);\n\t}\n\n\t \n\t \n\treg = readl(mfc_regs->e_enc_options);\n\treg |= (0x1 << 8);\n\twritel(reg, mfc_regs->e_enc_options);\n\n\t \n\twritel(0x0, mfc_regs->e_padding_ctrl);\n\tif (p->pad) {\n\t\treg = 0;\n\t\t \n\t\treg |= (1UL << 31);\n\t\t \n\t\treg |= ((p->pad_cr & 0xFF) << 16);\n\t\t \n\t\treg |= ((p->pad_cb & 0xFF) << 8);\n\t\t \n\t\treg |= p->pad_luma & 0xFF;\n\t\twritel(reg, mfc_regs->e_padding_ctrl);\n\t}\n\n\t \n\treg = 0;\n\t \n\treg |= ((p->rc_frame & 0x1) << 9);\n\twritel(reg, mfc_regs->e_rc_config);\n\n\t \n\tif (p->rc_frame)\n\t\twritel(p->rc_bitrate,\n\t\t\tmfc_regs->e_rc_bit_rate);\n\telse\n\t\twritel(1, mfc_regs->e_rc_bit_rate);\n\n\t \n\tif (p->rc_frame) {\n\t\tif (p->rc_reaction_coeff < TIGHT_CBR_MAX)  \n\t\t\twritel(1, mfc_regs->e_rc_mode);\n\t\telse\t\t\t\t\t   \n\t\t\twritel(2, mfc_regs->e_rc_mode);\n\t}\n\n\t \n\treg = readl(mfc_regs->e_enc_options);\n\treg &= ~(0x1 << 2);\n\treg |= ((p->seq_hdr_mode & 0x1) << 2);\n\n\t \n\treg &= ~(0x3);\n\treg |= (p->frame_skip_mode & 0x3);\n\twritel(reg, mfc_regs->e_enc_options);\n\n\t \n\treg = readl(mfc_regs->e_rc_config);\n\treg &= ~(0x1 << 10);\n\twritel(reg, mfc_regs->e_rc_config);\n\n\t \n\treg = (p->mv_h_range & S5P_FIMV_E_MV_RANGE_V6_MASK);\n\twritel(reg, mfc_regs->e_mv_hor_range);\n\n\treg = (p->mv_v_range & S5P_FIMV_E_MV_RANGE_V6_MASK);\n\twritel(reg, mfc_regs->e_mv_ver_range);\n\n\twritel(0x0, mfc_regs->e_frame_insertion);\n\twritel(0x0, mfc_regs->e_roi_buffer_addr);\n\twritel(0x0, mfc_regs->e_param_change);\n\twritel(0x0, mfc_regs->e_rc_roi_ctrl);\n\twritel(0x0, mfc_regs->e_picture_tag);\n\n\twritel(0x0, mfc_regs->e_bit_count_enable);\n\twritel(0x0, mfc_regs->e_max_bit_count);\n\twritel(0x0, mfc_regs->e_min_bit_count);\n\n\twritel(0x0, mfc_regs->e_metadata_buffer_addr);\n\twritel(0x0, mfc_regs->e_metadata_buffer_size);\n\n\tmfc_debug_leave();\n\n\treturn 0;\n}\n\nstatic int s5p_mfc_set_enc_params_h264(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tstruct s5p_mfc_h264_enc_params *p_h264 = &p->codec.h264;\n\tunsigned int reg = 0;\n\tint i;\n\n\tmfc_debug_enter();\n\n\ts5p_mfc_set_enc_params(ctx);\n\n\t \n\treg = readl(mfc_regs->e_gop_config);\n\treg &= ~(0x3 << 16);\n\treg |= ((p->num_b_frame & 0x3) << 16);\n\twritel(reg, mfc_regs->e_gop_config);\n\n\t \n\treg = 0;\n\t \n\treg |= ((p_h264->level & 0xFF) << 8);\n\t \n\treg |= p_h264->profile & 0x3F;\n\twritel(reg, mfc_regs->e_picture_profile);\n\n\t \n\treg = readl(mfc_regs->e_rc_config);\n\t \n\treg &= ~(0x1 << 8);\n\treg |= ((p->rc_mb & 0x1) << 8);\n\twritel(reg, mfc_regs->e_rc_config);\n\n\t \n\treg &= ~(0x3F);\n\treg |= p_h264->rc_frame_qp & 0x3F;\n\twritel(reg, mfc_regs->e_rc_config);\n\n\t \n\treg = 0;\n\t \n\treg |= ((p_h264->rc_max_qp & 0x3F) << 8);\n\t \n\treg |= p_h264->rc_min_qp & 0x3F;\n\twritel(reg, mfc_regs->e_rc_qp_bound);\n\n\t \n\twritel(0x0, mfc_regs->e_fixed_picture_qp);\n\tif (!p->rc_frame && !p->rc_mb) {\n\t\treg = 0;\n\t\treg |= ((p_h264->rc_b_frame_qp & 0x3F) << 16);\n\t\treg |= ((p_h264->rc_p_frame_qp & 0x3F) << 8);\n\t\treg |= p_h264->rc_frame_qp & 0x3F;\n\t\twritel(reg, mfc_regs->e_fixed_picture_qp);\n\t}\n\n\t \n\tif (p->rc_frame && p->rc_framerate_num && p->rc_framerate_denom) {\n\t\treg = 0;\n\t\treg |= ((p->rc_framerate_num & 0xFFFF) << 16);\n\t\treg |= p->rc_framerate_denom & 0xFFFF;\n\t\twritel(reg, mfc_regs->e_rc_frame_rate);\n\t}\n\n\t \n\tif (p->frame_skip_mode ==\n\t\t\tV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\n\t\twritel(p_h264->cpb_size & 0xFFFF,\n\t\t\t\tmfc_regs->e_vbv_buffer_size);\n\n\t\tif (p->rc_frame)\n\t\t\twritel(p->vbv_delay, mfc_regs->e_vbv_init_delay);\n\t}\n\n\t \n\treg = 0;\n\treg |= ((p_h264->interlace & 0x1) << 3);\n\twritel(reg, mfc_regs->e_h264_options);\n\n\t \n\tif (p_h264->interlace) {\n\t\twritel(ctx->img_height >> 1,\n\t\t\t\tmfc_regs->e_frame_height);  \n\t\t \n\t\twritel(ctx->img_height >> 1,\n\t\t\t\tmfc_regs->e_cropped_frame_height);\n\t}\n\n\t \n\treg = readl(mfc_regs->e_h264_options);\n\treg &= ~(0x3 << 1);\n\treg |= ((p_h264->loop_filter_mode & 0x3) << 1);\n\twritel(reg, mfc_regs->e_h264_options);\n\n\t \n\tif (p_h264->loop_filter_alpha < 0) {\n\t\treg = 0x10;\n\t\treg |= (0xFF - p_h264->loop_filter_alpha) + 1;\n\t} else {\n\t\treg = 0x00;\n\t\treg |= (p_h264->loop_filter_alpha & 0xF);\n\t}\n\twritel(reg, mfc_regs->e_h264_lf_alpha_offset);\n\n\t \n\tif (p_h264->loop_filter_beta < 0) {\n\t\treg = 0x10;\n\t\treg |= (0xFF - p_h264->loop_filter_beta) + 1;\n\t} else {\n\t\treg = 0x00;\n\t\treg |= (p_h264->loop_filter_beta & 0xF);\n\t}\n\twritel(reg, mfc_regs->e_h264_lf_beta_offset);\n\n\t \n\treg = readl(mfc_regs->e_h264_options);\n\treg &= ~(0x1);\n\treg |= p_h264->entropy_mode & 0x1;\n\twritel(reg, mfc_regs->e_h264_options);\n\n\t \n\treg = readl(mfc_regs->e_h264_options);\n\treg &= ~(0x1 << 7);\n\treg |= (((p_h264->num_ref_pic_4p - 1) & 0x1) << 7);\n\twritel(reg, mfc_regs->e_h264_options);\n\n\t \n\treg = readl(mfc_regs->e_h264_options);\n\treg &= ~(0x3 << 12);\n\treg |= ((p_h264->_8x8_transform & 0x3) << 12);\n\twritel(reg, mfc_regs->e_h264_options);\n\n\t \n\twritel(0x0, mfc_regs->e_mb_rc_config);\n\tif (p->rc_mb) {\n\t\treg = 0;\n\t\t \n\t\treg |= ((p_h264->rc_mb_dark & 0x1) << 3);\n\t\t \n\t\treg |= ((p_h264->rc_mb_smooth & 0x1) << 2);\n\t\t \n\t\treg |= ((p_h264->rc_mb_static & 0x1) << 1);\n\t\t \n\t\treg |= p_h264->rc_mb_activity & 0x1;\n\t\twritel(reg, mfc_regs->e_mb_rc_config);\n\t}\n\n\t \n\treg = readl(mfc_regs->e_h264_options);\n\treg &= ~(0x1 << 5);\n\treg |= ((p_h264->vui_sar & 0x1) << 5);\n\twritel(reg, mfc_regs->e_h264_options);\n\n\twritel(0x0, mfc_regs->e_aspect_ratio);\n\twritel(0x0, mfc_regs->e_extended_sar);\n\tif (p_h264->vui_sar) {\n\t\t \n\t\treg = 0;\n\t\treg |= p_h264->vui_sar_idc & 0xFF;\n\t\twritel(reg, mfc_regs->e_aspect_ratio);\n\t\tif (p_h264->vui_sar_idc == 0xFF) {\n\t\t\t \n\t\t\treg = 0;\n\t\t\treg |= (p_h264->vui_ext_sar_width & 0xFFFF) << 16;\n\t\t\treg |= p_h264->vui_ext_sar_height & 0xFFFF;\n\t\t\twritel(reg, mfc_regs->e_extended_sar);\n\t\t}\n\t}\n\n\t \n\t \n\treg = readl(mfc_regs->e_h264_options);\n\treg &= ~(0x1 << 4);\n\treg |= ((p_h264->open_gop & 0x1) << 4);\n\twritel(reg, mfc_regs->e_h264_options);\n\n\t \n\twritel(0x0, mfc_regs->e_h264_i_period);\n\tif (p_h264->open_gop) {\n\t\treg = 0;\n\t\treg |= p_h264->open_gop_size & 0xFFFF;\n\t\twritel(reg, mfc_regs->e_h264_i_period);\n\t}\n\n\t \n\treg = readl(mfc_regs->e_h264_options);\n\treg &= ~(0x3 << 9);\n\twritel(reg, mfc_regs->e_h264_options);\n\n\t \n\treg = readl(mfc_regs->e_h264_options);\n\treg &= ~(0x1 << 14);\n\twritel(reg, mfc_regs->e_h264_options);\n\n\t \n\treg = readl(mfc_regs->e_h264_options);\n\treg &= ~(0x1 << 6);\n\treg |= ((p_h264->aso & 0x1) << 6);\n\twritel(reg, mfc_regs->e_h264_options);\n\n\t \n\treg = readl(mfc_regs->e_h264_options);\n\treg &= ~(0x1 << 8);\n\treg |= ((p_h264->open_gop & 0x1) << 8);\n\twritel(reg, mfc_regs->e_h264_options);\n\treg = 0;\n\tif (p_h264->hier_qp && p_h264->hier_qp_layer) {\n\t\treg |= (p_h264->hier_qp_type & 0x1) << 0x3;\n\t\treg |= p_h264->hier_qp_layer & 0x7;\n\t\twritel(reg, mfc_regs->e_h264_num_t_layer);\n\t\t \n\t\tfor (i = 0; i < p_h264->hier_qp_layer &&\n\t\t\t\ti < ARRAY_SIZE(p_h264->hier_qp_layer_qp); i++) {\n\t\t\twritel(p_h264->hier_qp_layer_qp[i],\n\t\t\t\tmfc_regs->e_h264_hierarchical_qp_layer0\n\t\t\t\t+ i * 4);\n\t\t}\n\t}\n\t \n\twritel(reg, mfc_regs->e_h264_num_t_layer);\n\n\t \n\treg = readl(mfc_regs->e_h264_options);\n\treg &= ~(0x1 << 25);\n\treg |= ((p_h264->sei_frame_packing & 0x1) << 25);\n\twritel(reg, mfc_regs->e_h264_options);\n\tif (p_h264->sei_frame_packing) {\n\t\treg = 0;\n\t\t \n\t\treg |= ((p_h264->sei_fp_curr_frame_0 & 0x1) << 2);\n\t\t \n\t\treg |= p_h264->sei_fp_arrangement_type & 0x3;\n\t\twritel(reg, mfc_regs->e_h264_frame_packing_sei_info);\n\t}\n\n\tif (p_h264->fmo) {\n\t\tswitch (p_h264->fmo_map_type) {\n\t\tcase V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_INTERLEAVED_SLICES:\n\t\t\tif (p_h264->fmo_slice_grp > 4)\n\t\t\t\tp_h264->fmo_slice_grp = 4;\n\t\t\tfor (i = 0; i < (p_h264->fmo_slice_grp & 0xF); i++)\n\t\t\t\twritel(p_h264->fmo_run_len[i] - 1,\n\t\t\t\t\tmfc_regs->e_h264_fmo_run_length_minus1_0\n\t\t\t\t\t+ i * 4);\n\t\t\tbreak;\n\t\tcase V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_SCATTERED_SLICES:\n\t\t\tif (p_h264->fmo_slice_grp > 4)\n\t\t\t\tp_h264->fmo_slice_grp = 4;\n\t\t\tbreak;\n\t\tcase V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_RASTER_SCAN:\n\t\tcase V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_WIPE_SCAN:\n\t\t\tif (p_h264->fmo_slice_grp > 2)\n\t\t\t\tp_h264->fmo_slice_grp = 2;\n\t\t\twritel(p_h264->fmo_chg_dir & 0x1,\n\t\t\t\tmfc_regs->e_h264_fmo_slice_grp_change_dir);\n\t\t\t \n\t\t\twritel(p_h264->fmo_chg_rate,\n\t\t\tmfc_regs->e_h264_fmo_slice_grp_change_rate_minus1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmfc_err(\"Unsupported map type for FMO: %d\\n\",\n\t\t\t\t\tp_h264->fmo_map_type);\n\t\t\tp_h264->fmo_map_type = 0;\n\t\t\tp_h264->fmo_slice_grp = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\twritel(p_h264->fmo_map_type,\n\t\t\t\tmfc_regs->e_h264_fmo_slice_grp_map_type);\n\t\twritel(p_h264->fmo_slice_grp - 1,\n\t\t\t\tmfc_regs->e_h264_fmo_num_slice_grp_minus1);\n\t} else {\n\t\twritel(0, mfc_regs->e_h264_fmo_num_slice_grp_minus1);\n\t}\n\n\tmfc_debug_leave();\n\n\treturn 0;\n}\n\nstatic int s5p_mfc_set_enc_params_mpeg4(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tstruct s5p_mfc_mpeg4_enc_params *p_mpeg4 = &p->codec.mpeg4;\n\tunsigned int reg = 0;\n\n\tmfc_debug_enter();\n\n\ts5p_mfc_set_enc_params(ctx);\n\n\t \n\treg = readl(mfc_regs->e_gop_config);\n\treg &= ~(0x3 << 16);\n\treg |= ((p->num_b_frame & 0x3) << 16);\n\twritel(reg, mfc_regs->e_gop_config);\n\n\t \n\treg = 0;\n\t \n\treg |= ((p_mpeg4->level & 0xFF) << 8);\n\t \n\treg |= p_mpeg4->profile & 0x3F;\n\twritel(reg, mfc_regs->e_picture_profile);\n\n\t \n\treg = readl(mfc_regs->e_rc_config);\n\t \n\treg &= ~(0x1 << 8);\n\treg |= ((p->rc_mb & 0x1) << 8);\n\twritel(reg, mfc_regs->e_rc_config);\n\n\t \n\treg &= ~(0x3F);\n\treg |= p_mpeg4->rc_frame_qp & 0x3F;\n\twritel(reg, mfc_regs->e_rc_config);\n\n\t \n\treg = 0;\n\t \n\treg |= ((p_mpeg4->rc_max_qp & 0x3F) << 8);\n\t \n\treg |= p_mpeg4->rc_min_qp & 0x3F;\n\twritel(reg, mfc_regs->e_rc_qp_bound);\n\n\t \n\twritel(0x0, mfc_regs->e_fixed_picture_qp);\n\tif (!p->rc_frame && !p->rc_mb) {\n\t\treg = 0;\n\t\treg |= ((p_mpeg4->rc_b_frame_qp & 0x3F) << 16);\n\t\treg |= ((p_mpeg4->rc_p_frame_qp & 0x3F) << 8);\n\t\treg |= p_mpeg4->rc_frame_qp & 0x3F;\n\t\twritel(reg, mfc_regs->e_fixed_picture_qp);\n\t}\n\n\t \n\tif (p->rc_frame && p->rc_framerate_num && p->rc_framerate_denom) {\n\t\treg = 0;\n\t\treg |= ((p->rc_framerate_num & 0xFFFF) << 16);\n\t\treg |= p->rc_framerate_denom & 0xFFFF;\n\t\twritel(reg, mfc_regs->e_rc_frame_rate);\n\t}\n\n\t \n\tif (p->frame_skip_mode ==\n\t\t\tV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\n\t\twritel(p->vbv_size & 0xFFFF, mfc_regs->e_vbv_buffer_size);\n\n\t\tif (p->rc_frame)\n\t\t\twritel(p->vbv_delay, mfc_regs->e_vbv_init_delay);\n\t}\n\n\t \n\twritel(0x0, mfc_regs->e_mpeg4_options);\n\twritel(0x0, mfc_regs->e_mpeg4_hec_period);\n\n\tmfc_debug_leave();\n\n\treturn 0;\n}\n\nstatic int s5p_mfc_set_enc_params_h263(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tstruct s5p_mfc_mpeg4_enc_params *p_h263 = &p->codec.mpeg4;\n\tunsigned int reg = 0;\n\n\tmfc_debug_enter();\n\n\ts5p_mfc_set_enc_params(ctx);\n\n\t \n\treg = 0;\n\t \n\treg |= (0x1 << 4);\n\twritel(reg, mfc_regs->e_picture_profile);\n\n\t \n\treg = readl(mfc_regs->e_rc_config);\n\t \n\treg &= ~(0x1 << 8);\n\treg |= ((p->rc_mb & 0x1) << 8);\n\twritel(reg, mfc_regs->e_rc_config);\n\n\t \n\treg &= ~(0x3F);\n\treg |= p_h263->rc_frame_qp & 0x3F;\n\twritel(reg, mfc_regs->e_rc_config);\n\n\t \n\treg = 0;\n\t \n\treg |= ((p_h263->rc_max_qp & 0x3F) << 8);\n\t \n\treg |= p_h263->rc_min_qp & 0x3F;\n\twritel(reg, mfc_regs->e_rc_qp_bound);\n\n\t \n\twritel(0x0, mfc_regs->e_fixed_picture_qp);\n\tif (!p->rc_frame && !p->rc_mb) {\n\t\treg = 0;\n\t\treg |= ((p_h263->rc_b_frame_qp & 0x3F) << 16);\n\t\treg |= ((p_h263->rc_p_frame_qp & 0x3F) << 8);\n\t\treg |= p_h263->rc_frame_qp & 0x3F;\n\t\twritel(reg, mfc_regs->e_fixed_picture_qp);\n\t}\n\n\t \n\tif (p->rc_frame && p->rc_framerate_num && p->rc_framerate_denom) {\n\t\treg = 0;\n\t\treg |= ((p->rc_framerate_num & 0xFFFF) << 16);\n\t\treg |= p->rc_framerate_denom & 0xFFFF;\n\t\twritel(reg, mfc_regs->e_rc_frame_rate);\n\t}\n\n\t \n\tif (p->frame_skip_mode ==\n\t\t\tV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\n\t\twritel(p->vbv_size & 0xFFFF, mfc_regs->e_vbv_buffer_size);\n\n\t\tif (p->rc_frame)\n\t\t\twritel(p->vbv_delay, mfc_regs->e_vbv_init_delay);\n\t}\n\n\tmfc_debug_leave();\n\n\treturn 0;\n}\n\nstatic int s5p_mfc_set_enc_params_vp8(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tstruct s5p_mfc_vp8_enc_params *p_vp8 = &p->codec.vp8;\n\tunsigned int reg = 0;\n\tunsigned int val = 0;\n\n\tmfc_debug_enter();\n\n\ts5p_mfc_set_enc_params(ctx);\n\n\t \n\treg = readl(mfc_regs->e_gop_config);\n\treg &= ~(0x3 << 16);\n\treg |= ((p->num_b_frame & 0x3) << 16);\n\twritel(reg, mfc_regs->e_gop_config);\n\n\t \n\treg = p_vp8->profile & 0x3;\n\twritel(reg, mfc_regs->e_picture_profile);\n\n\t \n\treg = readl(mfc_regs->e_rc_config);\n\t \n\treg &= ~(0x1 << 8);\n\treg |= ((p->rc_mb & 0x1) << 8);\n\twritel(reg, mfc_regs->e_rc_config);\n\n\t \n\tif (p->rc_frame && p->rc_framerate_num && p->rc_framerate_denom) {\n\t\treg = 0;\n\t\treg |= ((p->rc_framerate_num & 0xFFFF) << 16);\n\t\treg |= p->rc_framerate_denom & 0xFFFF;\n\t\twritel(reg, mfc_regs->e_rc_frame_rate);\n\t}\n\n\t \n\treg &= ~(0x7F);\n\treg |= p_vp8->rc_frame_qp & 0x7F;\n\twritel(reg, mfc_regs->e_rc_config);\n\n\t \n\twritel(0x0, mfc_regs->e_fixed_picture_qp);\n\tif (!p->rc_frame && !p->rc_mb) {\n\t\treg = 0;\n\t\treg |= ((p_vp8->rc_p_frame_qp & 0x7F) << 8);\n\t\treg |= p_vp8->rc_frame_qp & 0x7F;\n\t\twritel(reg, mfc_regs->e_fixed_picture_qp);\n\t}\n\n\t \n\treg = ((p_vp8->rc_max_qp & 0x7F) << 8);\n\t \n\treg |= p_vp8->rc_min_qp & 0x7F;\n\twritel(reg, mfc_regs->e_rc_qp_bound);\n\n\t \n\tif (p->frame_skip_mode ==\n\t\t\tV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\n\t\twritel(p->vbv_size & 0xFFFF, mfc_regs->e_vbv_buffer_size);\n\n\t\tif (p->rc_frame)\n\t\t\twritel(p->vbv_delay, mfc_regs->e_vbv_init_delay);\n\t}\n\n\t \n\treg = 0;\n\treg |= (p_vp8->imd_4x4 & 0x1) << 10;\n\tswitch (p_vp8->num_partitions) {\n\tcase V4L2_CID_MPEG_VIDEO_VPX_1_PARTITION:\n\t\tval = 0;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_2_PARTITIONS:\n\t\tval = 2;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_4_PARTITIONS:\n\t\tval = 4;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VPX_8_PARTITIONS:\n\t\tval = 8;\n\t\tbreak;\n\t}\n\treg |= (val & 0xF) << 3;\n\treg |= (p_vp8->num_ref & 0x2);\n\twritel(reg, mfc_regs->e_vp8_options);\n\n\tmfc_debug_leave();\n\n\treturn 0;\n}\n\nstatic int s5p_mfc_set_enc_params_hevc(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tstruct s5p_mfc_hevc_enc_params *p_hevc = &p->codec.hevc;\n\tunsigned int reg = 0;\n\tint i;\n\n\tmfc_debug_enter();\n\n\ts5p_mfc_set_enc_params(ctx);\n\n\t \n\treg = readl(mfc_regs->e_gop_config);\n\t \n\treg &= ~(0x3 << 16);\n\treg |= (p->num_b_frame << 16);\n\twritel(reg, mfc_regs->e_gop_config);\n\n\t \n\tif ((ctx->img_width == 3840) && (ctx->img_height == 2160)) {\n\t\tp_hevc->level = 51;\n\t\tp_hevc->tier = 0;\n\t \n\t}\n\n\t \n\treg = 0;\n\t \n\treg |= p_hevc->profile & 0x3;\n\t \n\treg &= ~(0xFF << 8);\n\treg |= (p_hevc->level << 8);\n\t \n\treg |= (p_hevc->tier << 16);\n\twritel(reg, mfc_regs->e_picture_profile);\n\n\tswitch (p_hevc->loopfilter) {\n\tcase V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED:\n\t\tp_hevc->loopfilter_disable = 1;\n\t\tbreak;\n\tcase V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_ENABLED:\n\t\tp_hevc->loopfilter_disable = 0;\n\t\tp_hevc->loopfilter_across = 1;\n\t\tbreak;\n\tcase V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY:\n\t\tp_hevc->loopfilter_disable = 0;\n\t\tp_hevc->loopfilter_across = 0;\n\t\tbreak;\n\t}\n\n\t \n\treg = 0;\n\treg |= (p_hevc->max_partition_depth & 0x1);\n\treg |= (p_hevc->num_refs_for_p-1) << 2;\n\treg |= (p_hevc->refreshtype & 0x3) << 3;\n\treg |= (p_hevc->const_intra_period_enable & 0x1) << 5;\n\treg |= (p_hevc->lossless_cu_enable & 0x1) << 6;\n\treg |= (p_hevc->wavefront_enable & 0x1) << 7;\n\treg |= (p_hevc->loopfilter_disable & 0x1) << 8;\n\treg |= (p_hevc->loopfilter_across & 0x1) << 9;\n\treg |= (p_hevc->enable_ltr & 0x1) << 10;\n\treg |= (p_hevc->hier_qp_enable & 0x1) << 11;\n\treg |= (p_hevc->general_pb_enable & 0x1) << 13;\n\treg |= (p_hevc->temporal_id_enable & 0x1) << 14;\n\treg |= (p_hevc->strong_intra_smooth & 0x1) << 15;\n\treg |= (p_hevc->intra_pu_split_disable & 0x1) << 16;\n\treg |= (p_hevc->tmv_prediction_disable & 0x1) << 17;\n\treg |= (p_hevc->max_num_merge_mv & 0x7) << 18;\n\treg |= (p_hevc->encoding_nostartcode_enable & 0x1) << 23;\n\treg |= (p_hevc->prepend_sps_pps_to_idr << 26);\n\n\twritel(reg, mfc_regs->e_hevc_options);\n\t \n\tif (p_hevc->refreshtype) {\n\t\treg = 0;\n\t\treg |= (p_hevc->refreshperiod & 0xFFFF);\n\t\twritel(reg, mfc_regs->e_hevc_refresh_period);\n\t}\n\t \n\tif (!(p_hevc->loopfilter_disable & 0x1)) {\n\t\treg = 0;\n\t\treg |= (p_hevc->lf_beta_offset_div2);\n\t\twritel(reg, mfc_regs->e_hevc_lf_beta_offset_div2);\n\t\treg = 0;\n\t\treg |= (p_hevc->lf_tc_offset_div2);\n\t\twritel(reg, mfc_regs->e_hevc_lf_tc_offset_div2);\n\t}\n\t \n\tif (p_hevc->num_hier_layer) {\n\t\treg = 0;\n\t\treg |= (p_hevc->hier_qp_type & 0x1) << 0x3;\n\t\treg |= p_hevc->num_hier_layer & 0x7;\n\t\twritel(reg, mfc_regs->e_num_t_layer);\n\t\t \n\t\tif (p_hevc->hier_qp_enable) {\n\t\t\tfor (i = 0; i < 7; i++)\n\t\t\t\twritel(p_hevc->hier_qp_layer[i],\n\t\t\t\t\tmfc_regs->e_hier_qp_layer0 + i * 4);\n\t\t}\n\t\tif (p->rc_frame) {\n\t\t\tfor (i = 0; i < 7; i++)\n\t\t\t\twritel(p_hevc->hier_bit_layer[i],\n\t\t\t\t\t\tmfc_regs->e_hier_bit_rate_layer0\n\t\t\t\t\t\t+ i * 4);\n\t\t}\n\t}\n\n\t \n\treg = readl(mfc_regs->e_rc_config);\n\t \n\treg &= ~(0x1 << 8);\n\treg |= (p->rc_mb << 8);\n\twritel(reg, mfc_regs->e_rc_config);\n\t \n\treg &= ~(0xFF);\n\treg |= p_hevc->rc_frame_qp;\n\twritel(reg, mfc_regs->e_rc_config);\n\n\t \n\tif (p->rc_frame) {\n\t\treg = 0;\n\t\treg &= ~(0xFFFF << 16);\n\t\treg |= ((p_hevc->rc_framerate) << 16);\n\t\treg &= ~(0xFFFF);\n\t\treg |= FRAME_DELTA_DEFAULT;\n\t\twritel(reg, mfc_regs->e_rc_frame_rate);\n\t}\n\n\t \n\treg = 0;\n\t \n\treg &= ~(0xFF << 8);\n\treg |= (p_hevc->rc_max_qp << 8);\n\t \n\treg &= ~(0xFF);\n\treg |= p_hevc->rc_min_qp;\n\twritel(reg, mfc_regs->e_rc_qp_bound);\n\n\twritel(0x0, mfc_regs->e_fixed_picture_qp);\n\tif (!p->rc_frame && !p->rc_mb) {\n\t\treg = 0;\n\t\treg &= ~(0xFF << 16);\n\t\treg |= (p_hevc->rc_b_frame_qp << 16);\n\t\treg &= ~(0xFF << 8);\n\t\treg |= (p_hevc->rc_p_frame_qp << 8);\n\t\treg &= ~(0xFF);\n\t\treg |= p_hevc->rc_frame_qp;\n\t\twritel(reg, mfc_regs->e_fixed_picture_qp);\n\t}\n\tmfc_debug_leave();\n\n\treturn 0;\n}\n\n \nstatic int s5p_mfc_init_decode_v6(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tunsigned int reg = 0;\n\tint fmo_aso_ctrl = 0;\n\n\tmfc_debug_enter();\n\tmfc_debug(2, \"InstNo: %d/%d\\n\", ctx->inst_no,\n\t\t\tS5P_FIMV_CH_SEQ_HEADER_V6);\n\tmfc_debug(2, \"BUFs: %08x %08x %08x\\n\",\n\t\t  readl(mfc_regs->d_cpb_buffer_addr),\n\t\t  readl(mfc_regs->d_cpb_buffer_addr),\n\t\t  readl(mfc_regs->d_cpb_buffer_addr));\n\n\t \n\treg |= (fmo_aso_ctrl << S5P_FIMV_D_OPT_FMO_ASO_CTRL_MASK_V6);\n\n\tif (ctx->display_delay_enable) {\n\t\treg |= (0x1 << S5P_FIMV_D_OPT_DDELAY_EN_SHIFT_V6);\n\t\twritel(ctx->display_delay, mfc_regs->d_display_delay);\n\t}\n\n\tif (IS_MFCV7_PLUS(dev) || IS_MFCV6_V2(dev)) {\n\t\twritel(reg, mfc_regs->d_dec_options);\n\t\treg = 0;\n\t}\n\n\t \n\tif (ctx->codec_mode == S5P_MFC_CODEC_MPEG4_DEC) {\n\t\tmfc_debug(2, \"Set loop filter to: %d\\n\",\n\t\t\t\tctx->loop_filter_mpeg4);\n\t\treg |= (ctx->loop_filter_mpeg4 <<\n\t\t\t\tS5P_FIMV_D_OPT_LF_CTRL_SHIFT_V6);\n\t}\n\tif (ctx->dst_fmt->fourcc == V4L2_PIX_FMT_NV12MT_16X16)\n\t\treg |= (0x1 << S5P_FIMV_D_OPT_TILE_MODE_SHIFT_V6);\n\n\tif (IS_MFCV7_PLUS(dev) || IS_MFCV6_V2(dev))\n\t\twritel(reg, mfc_regs->d_init_buffer_options);\n\telse\n\t\twritel(reg, mfc_regs->d_dec_options);\n\n\t \n\tif (ctx->dst_fmt->fourcc == V4L2_PIX_FMT_NV21M)\n\t\twritel(0x1, mfc_regs->pixel_format);\n\telse\n\t\twritel(0x0, mfc_regs->pixel_format);\n\n\n\t \n\twritel(ctx->sei_fp_parse & 0x1, mfc_regs->d_sei_enable);\n\n\twritel(ctx->inst_no, mfc_regs->instance_id);\n\ts5p_mfc_hw_call(dev->mfc_cmds, cmd_host2risc, dev,\n\t\t\tS5P_FIMV_CH_SEQ_HEADER_V6, NULL);\n\n\tmfc_debug_leave();\n\treturn 0;\n}\n\nstatic inline void s5p_mfc_set_flush(struct s5p_mfc_ctx *ctx, int flush)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\n\tif (flush) {\n\t\tdev->curr_ctx = ctx->num;\n\t\twritel(ctx->inst_no, mfc_regs->instance_id);\n\t\ts5p_mfc_hw_call(dev->mfc_cmds, cmd_host2risc, dev,\n\t\t\t\tS5P_FIMV_H2R_CMD_FLUSH_V6, NULL);\n\t}\n}\n\n \nstatic int s5p_mfc_decode_one_frame_v6(struct s5p_mfc_ctx *ctx,\n\t\t\tenum s5p_mfc_decode_arg last_frame)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\n\twritel(ctx->dec_dst_flag, mfc_regs->d_available_dpb_flag_lower);\n\twritel(ctx->slice_interface & 0x1, mfc_regs->d_slice_if_enable);\n\n\twritel(ctx->inst_no, mfc_regs->instance_id);\n\t \n\tswitch (last_frame) {\n\tcase 0:\n\t\ts5p_mfc_hw_call(dev->mfc_cmds, cmd_host2risc, dev,\n\t\t\t\tS5P_FIMV_CH_FRAME_START_V6, NULL);\n\t\tbreak;\n\tcase 1:\n\t\ts5p_mfc_hw_call(dev->mfc_cmds, cmd_host2risc, dev,\n\t\t\t\tS5P_FIMV_CH_LAST_FRAME_V6, NULL);\n\t\tbreak;\n\tdefault:\n\t\tmfc_err(\"Unsupported last frame arg.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmfc_debug(2, \"Decoding a usual frame.\\n\");\n\treturn 0;\n}\n\nstatic int s5p_mfc_init_encode_v6(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\n\tif (ctx->codec_mode == S5P_MFC_CODEC_H264_ENC)\n\t\ts5p_mfc_set_enc_params_h264(ctx);\n\telse if (ctx->codec_mode == S5P_MFC_CODEC_MPEG4_ENC)\n\t\ts5p_mfc_set_enc_params_mpeg4(ctx);\n\telse if (ctx->codec_mode == S5P_MFC_CODEC_H263_ENC)\n\t\ts5p_mfc_set_enc_params_h263(ctx);\n\telse if (ctx->codec_mode == S5P_MFC_CODEC_VP8_ENC)\n\t\ts5p_mfc_set_enc_params_vp8(ctx);\n\telse if (ctx->codec_mode == S5P_FIMV_CODEC_HEVC_ENC)\n\t\ts5p_mfc_set_enc_params_hevc(ctx);\n\telse {\n\t\tmfc_err(\"Unknown codec for encoding (%x).\\n\",\n\t\t\tctx->codec_mode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (IS_MFCV7_PLUS(dev)) {\n\t\twritel(ctx->img_width, mfc_regs->e_source_first_plane_stride);\n\t\twritel(ctx->img_width, mfc_regs->e_source_second_plane_stride);\n\t}\n\n\twritel(ctx->inst_no, mfc_regs->instance_id);\n\ts5p_mfc_hw_call(dev->mfc_cmds, cmd_host2risc, dev,\n\t\t\tS5P_FIMV_CH_SEQ_HEADER_V6, NULL);\n\n\treturn 0;\n}\n\nstatic int s5p_mfc_h264_set_aso_slice_order_v6(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tstruct s5p_mfc_h264_enc_params *p_h264 = &p->codec.h264;\n\tint i;\n\n\tif (p_h264->aso) {\n\t\tfor (i = 0; i < ARRAY_SIZE(p_h264->aso_slice_order); i++) {\n\t\t\twritel(p_h264->aso_slice_order[i],\n\t\t\t\tmfc_regs->e_h264_aso_slice_order_0 + i * 4);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int s5p_mfc_encode_one_frame_v6(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\tint cmd;\n\n\tmfc_debug(2, \"++\\n\");\n\n\t \n\n\tif (ctx->codec_mode == S5P_MFC_CODEC_H264_ENC)\n\t\ts5p_mfc_h264_set_aso_slice_order_v6(ctx);\n\n\ts5p_mfc_set_slice_mode(ctx);\n\n\tif (ctx->state != MFCINST_FINISHING)\n\t\tcmd = S5P_FIMV_CH_FRAME_START_V6;\n\telse\n\t\tcmd = S5P_FIMV_CH_LAST_FRAME_V6;\n\n\twritel(ctx->inst_no, mfc_regs->instance_id);\n\ts5p_mfc_hw_call(dev->mfc_cmds, cmd_host2risc, dev, cmd, NULL);\n\n\tmfc_debug(2, \"--\\n\");\n\n\treturn 0;\n}\n\nstatic inline void s5p_mfc_run_dec_last_frames(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\ts5p_mfc_set_dec_stream_buffer_v6(ctx, 0, 0, 0);\n\tdev->curr_ctx = ctx->num;\n\ts5p_mfc_decode_one_frame_v6(ctx, MFC_DEC_LAST_FRAME);\n}\n\nstatic inline int s5p_mfc_run_dec_frame(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *temp_vb;\n\tint last_frame = 0;\n\n\tif (ctx->state == MFCINST_FINISHING) {\n\t\tlast_frame = MFC_DEC_LAST_FRAME;\n\t\ts5p_mfc_set_dec_stream_buffer_v6(ctx, 0, 0, 0);\n\t\tdev->curr_ctx = ctx->num;\n\t\ts5p_mfc_clean_ctx_int_flags(ctx);\n\t\ts5p_mfc_decode_one_frame_v6(ctx, last_frame);\n\t\treturn 0;\n\t}\n\n\t \n\tif (list_empty(&ctx->src_queue)) {\n\t\tmfc_debug(2, \"No src buffers.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\t \n\ttemp_vb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\n\ttemp_vb->flags |= MFC_BUF_FLAG_USED;\n\ts5p_mfc_set_dec_stream_buffer_v6(ctx,\n\t\tvb2_dma_contig_plane_dma_addr(&temp_vb->b->vb2_buf, 0),\n\t\t\tctx->consumed_stream,\n\t\t\ttemp_vb->b->vb2_buf.planes[0].bytesused);\n\n\tdev->curr_ctx = ctx->num;\n\tif (temp_vb->b->vb2_buf.planes[0].bytesused == 0) {\n\t\tlast_frame = 1;\n\t\tmfc_debug(2, \"Setting ctx->state to FINISHING\\n\");\n\t\tctx->state = MFCINST_FINISHING;\n\t}\n\ts5p_mfc_decode_one_frame_v6(ctx, last_frame);\n\n\treturn 0;\n}\n\nstatic inline int s5p_mfc_run_enc_frame(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *dst_mb;\n\tstruct s5p_mfc_buf *src_mb;\n\tunsigned long src_y_addr, src_c_addr, dst_addr;\n\t \n\tunsigned int dst_size;\n\n\tif (list_empty(&ctx->src_queue) && ctx->state != MFCINST_FINISHING) {\n\t\tmfc_debug(2, \"no src buffers.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (list_empty(&ctx->dst_queue)) {\n\t\tmfc_debug(2, \"no dst buffers.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (list_empty(&ctx->src_queue)) {\n\t\t \n\t\ts5p_mfc_set_enc_frame_buffer_v6(ctx, 0, 0);\n\t\tsrc_mb = NULL;\n\t} else {\n\t\tsrc_mb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\n\t\tsrc_mb->flags |= MFC_BUF_FLAG_USED;\n\t\tif (src_mb->b->vb2_buf.planes[0].bytesused == 0) {\n\t\t\ts5p_mfc_set_enc_frame_buffer_v6(ctx, 0, 0);\n\t\t\tctx->state = MFCINST_FINISHING;\n\t\t} else {\n\t\t\tsrc_y_addr = vb2_dma_contig_plane_dma_addr(&src_mb->b->vb2_buf, 0);\n\t\t\tsrc_c_addr = vb2_dma_contig_plane_dma_addr(&src_mb->b->vb2_buf, 1);\n\n\t\t\tmfc_debug(2, \"enc src y addr: 0x%08lx\\n\", src_y_addr);\n\t\t\tmfc_debug(2, \"enc src c addr: 0x%08lx\\n\", src_c_addr);\n\n\t\t\ts5p_mfc_set_enc_frame_buffer_v6(ctx, src_y_addr, src_c_addr);\n\t\t\tif (src_mb->flags & MFC_BUF_FLAG_EOS)\n\t\t\t\tctx->state = MFCINST_FINISHING;\n\t\t}\n\t}\n\n\tdst_mb = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf, list);\n\tdst_mb->flags |= MFC_BUF_FLAG_USED;\n\tdst_addr = vb2_dma_contig_plane_dma_addr(&dst_mb->b->vb2_buf, 0);\n\tdst_size = vb2_plane_size(&dst_mb->b->vb2_buf, 0);\n\n\ts5p_mfc_set_enc_stream_buffer_v6(ctx, dst_addr, dst_size);\n\n\tdev->curr_ctx = ctx->num;\n\ts5p_mfc_encode_one_frame_v6(ctx);\n\n\treturn 0;\n}\n\nstatic inline void s5p_mfc_run_init_dec(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *temp_vb;\n\n\t \n\tmfc_debug(2, \"Preparing to init decoding.\\n\");\n\ttemp_vb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\n\tmfc_debug(2, \"Header size: %d\\n\", temp_vb->b->vb2_buf.planes[0].bytesused);\n\ts5p_mfc_set_dec_stream_buffer_v6(ctx,\n\t\tvb2_dma_contig_plane_dma_addr(&temp_vb->b->vb2_buf, 0), 0,\n\t\t\ttemp_vb->b->vb2_buf.planes[0].bytesused);\n\tdev->curr_ctx = ctx->num;\n\ts5p_mfc_init_decode_v6(ctx);\n}\n\nstatic inline void s5p_mfc_run_init_enc(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *dst_mb;\n\tunsigned long dst_addr;\n\tunsigned int dst_size;\n\n\tdst_mb = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf, list);\n\tdst_addr = vb2_dma_contig_plane_dma_addr(&dst_mb->b->vb2_buf, 0);\n\tdst_size = vb2_plane_size(&dst_mb->b->vb2_buf, 0);\n\ts5p_mfc_set_enc_stream_buffer_v6(ctx, dst_addr, dst_size);\n\tdev->curr_ctx = ctx->num;\n\ts5p_mfc_init_encode_v6(ctx);\n}\n\nstatic inline int s5p_mfc_run_init_dec_buffers(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tint ret;\n\t \n\n\tif (ctx->capture_state != QUEUE_BUFS_MMAPED) {\n\t\tmfc_err(\"It seems that not all destination buffers were\\n\"\n\t\t\t\"mmapped.MFC requires that all destination are mmapped\\n\"\n\t\t\t\"before starting processing.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tdev->curr_ctx = ctx->num;\n\tret = s5p_mfc_set_dec_frame_buffer_v6(ctx);\n\tif (ret) {\n\t\tmfc_err(\"Failed to alloc frame mem.\\n\");\n\t\tctx->state = MFCINST_ERROR;\n\t}\n\treturn ret;\n}\n\nstatic inline int s5p_mfc_run_init_enc_buffers(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tint ret;\n\n\tdev->curr_ctx = ctx->num;\n\tret = s5p_mfc_set_enc_ref_buffer_v6(ctx);\n\tif (ret) {\n\t\tmfc_err(\"Failed to alloc frame mem.\\n\");\n\t\tctx->state = MFCINST_ERROR;\n\t}\n\treturn ret;\n}\n\n \nstatic void s5p_mfc_try_run_v6(struct s5p_mfc_dev *dev)\n{\n\tstruct s5p_mfc_ctx *ctx;\n\tint new_ctx;\n\tunsigned int ret = 0;\n\n\tmfc_debug(1, \"Try run dev: %p\\n\", dev);\n\n\t \n\tif (test_and_set_bit(0, &dev->hw_lock) != 0) {\n\t\t \n\t\tmfc_debug(1, \"Couldn't lock HW.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tnew_ctx = s5p_mfc_get_new_ctx(dev);\n\tif (new_ctx < 0) {\n\t\t \n\t\tif (test_and_clear_bit(0, &dev->hw_lock) == 0) {\n\t\t\tmfc_err(\"Failed to unlock hardware.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tmfc_debug(1, \"No ctx is scheduled to be run.\\n\");\n\t\treturn;\n\t}\n\n\tmfc_debug(1, \"New context: %d\\n\", new_ctx);\n\tctx = dev->ctx[new_ctx];\n\tmfc_debug(1, \"Setting new context to %p\\n\", ctx);\n\t \n\tmfc_debug(1, \"ctx->dst_queue_cnt=%d ctx->dpb_count=%d ctx->src_queue_cnt=%d\\n\",\n\t\tctx->dst_queue_cnt, ctx->pb_count, ctx->src_queue_cnt);\n\tmfc_debug(1, \"ctx->state=%d\\n\", ctx->state);\n\t \n\n\ts5p_mfc_clock_on();\n\ts5p_mfc_clean_ctx_int_flags(ctx);\n\n\tif (ctx->type == MFCINST_DECODER) {\n\t\tswitch (ctx->state) {\n\t\tcase MFCINST_FINISHING:\n\t\t\ts5p_mfc_run_dec_last_frames(ctx);\n\t\t\tbreak;\n\t\tcase MFCINST_RUNNING:\n\t\t\tret = s5p_mfc_run_dec_frame(ctx);\n\t\t\tbreak;\n\t\tcase MFCINST_INIT:\n\t\t\tret = s5p_mfc_hw_call(dev->mfc_cmds, open_inst_cmd,\n\t\t\t\t\tctx);\n\t\t\tbreak;\n\t\tcase MFCINST_RETURN_INST:\n\t\t\tret = s5p_mfc_hw_call(dev->mfc_cmds, close_inst_cmd,\n\t\t\t\t\tctx);\n\t\t\tbreak;\n\t\tcase MFCINST_GOT_INST:\n\t\t\ts5p_mfc_run_init_dec(ctx);\n\t\t\tbreak;\n\t\tcase MFCINST_HEAD_PARSED:\n\t\t\tret = s5p_mfc_run_init_dec_buffers(ctx);\n\t\t\tbreak;\n\t\tcase MFCINST_FLUSH:\n\t\t\ts5p_mfc_set_flush(ctx, ctx->dpb_flush_flag);\n\t\t\tbreak;\n\t\tcase MFCINST_RES_CHANGE_INIT:\n\t\t\ts5p_mfc_run_dec_last_frames(ctx);\n\t\t\tbreak;\n\t\tcase MFCINST_RES_CHANGE_FLUSH:\n\t\t\ts5p_mfc_run_dec_last_frames(ctx);\n\t\t\tbreak;\n\t\tcase MFCINST_RES_CHANGE_END:\n\t\t\tmfc_debug(2, \"Finished remaining frames after resolution change.\\n\");\n\t\t\tctx->capture_state = QUEUE_FREE;\n\t\t\tmfc_debug(2, \"Will re-init the codec`.\\n\");\n\t\t\ts5p_mfc_run_init_dec(ctx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EAGAIN;\n\t\t}\n\t} else if (ctx->type == MFCINST_ENCODER) {\n\t\tswitch (ctx->state) {\n\t\tcase MFCINST_FINISHING:\n\t\tcase MFCINST_RUNNING:\n\t\t\tret = s5p_mfc_run_enc_frame(ctx);\n\t\t\tbreak;\n\t\tcase MFCINST_INIT:\n\t\t\tret = s5p_mfc_hw_call(dev->mfc_cmds, open_inst_cmd,\n\t\t\t\t\tctx);\n\t\t\tbreak;\n\t\tcase MFCINST_RETURN_INST:\n\t\t\tret = s5p_mfc_hw_call(dev->mfc_cmds, close_inst_cmd,\n\t\t\t\t\tctx);\n\t\t\tbreak;\n\t\tcase MFCINST_GOT_INST:\n\t\t\ts5p_mfc_run_init_enc(ctx);\n\t\t\tbreak;\n\t\tcase MFCINST_HEAD_PRODUCED:\n\t\t\tret = s5p_mfc_run_init_enc_buffers(ctx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EAGAIN;\n\t\t}\n\t} else {\n\t\tmfc_err(\"invalid context type: %d\\n\", ctx->type);\n\t\tret = -EAGAIN;\n\t}\n\n\tif (ret) {\n\t\t \n\t\tif (test_and_clear_bit(0, &dev->hw_lock) == 0)\n\t\t\tmfc_err(\"Failed to unlock hardware.\\n\");\n\n\t\t \n\t\ts5p_mfc_clock_off();\n\t}\n}\n\nstatic void s5p_mfc_clear_int_flags_v6(struct s5p_mfc_dev *dev)\n{\n\tconst struct s5p_mfc_regs *mfc_regs = dev->mfc_regs;\n\twritel(0, mfc_regs->risc2host_command);\n\twritel(0, mfc_regs->risc2host_int);\n}\n\nstatic unsigned int\ns5p_mfc_read_info_v6(struct s5p_mfc_ctx *ctx, unsigned long ofs)\n{\n\tint ret;\n\n\ts5p_mfc_clock_on();\n\tret = readl((void __iomem *)ofs);\n\ts5p_mfc_clock_off();\n\n\treturn ret;\n}\n\nstatic int s5p_mfc_get_dspl_y_adr_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->d_display_first_plane_addr);\n}\n\nstatic int s5p_mfc_get_dec_y_adr_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->d_decoded_first_plane_addr);\n}\n\nstatic int s5p_mfc_get_dspl_status_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->d_display_status);\n}\n\nstatic int s5p_mfc_get_dec_status_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->d_decoded_status);\n}\n\nstatic int s5p_mfc_get_dec_frame_type_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->d_decoded_frame_type) &\n\t\tS5P_FIMV_DECODE_FRAME_MASK_V6;\n}\n\nstatic int s5p_mfc_get_disp_frame_type_v6(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\treturn readl(dev->mfc_regs->d_display_frame_type) &\n\t\tS5P_FIMV_DECODE_FRAME_MASK_V6;\n}\n\nstatic int s5p_mfc_get_consumed_stream_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->d_decoded_nal_size);\n}\n\nstatic int s5p_mfc_get_int_reason_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->risc2host_command) &\n\t\tS5P_FIMV_RISC2HOST_CMD_MASK;\n}\n\nstatic int s5p_mfc_get_int_err_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->error_code);\n}\n\nstatic int s5p_mfc_err_dec_v6(unsigned int err)\n{\n\treturn (err & S5P_FIMV_ERR_DEC_MASK_V6) >> S5P_FIMV_ERR_DEC_SHIFT_V6;\n}\n\nstatic int s5p_mfc_get_img_width_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->d_display_frame_width);\n}\n\nstatic int s5p_mfc_get_img_height_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->d_display_frame_height);\n}\n\nstatic int s5p_mfc_get_dpb_count_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->d_min_num_dpb);\n}\n\nstatic int s5p_mfc_get_mv_count_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->d_min_num_mv);\n}\n\nstatic int s5p_mfc_get_min_scratch_buf_size(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->d_min_scratch_buffer_size);\n}\n\nstatic int s5p_mfc_get_e_min_scratch_buf_size(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->e_min_scratch_buffer_size);\n}\n\nstatic int s5p_mfc_get_inst_no_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->ret_instance_id);\n}\n\nstatic int s5p_mfc_get_enc_dpb_count_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->e_num_dpb);\n}\n\nstatic int s5p_mfc_get_enc_strm_size_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->e_stream_size);\n}\n\nstatic int s5p_mfc_get_enc_slice_type_v6(struct s5p_mfc_dev *dev)\n{\n\treturn readl(dev->mfc_regs->e_slice_type);\n}\n\nstatic unsigned int s5p_mfc_get_pic_type_top_v6(struct s5p_mfc_ctx *ctx)\n{\n\treturn s5p_mfc_read_info_v6(ctx,\n\t\t(__force unsigned long) ctx->dev->mfc_regs->d_ret_picture_tag_top);\n}\n\nstatic unsigned int s5p_mfc_get_pic_type_bot_v6(struct s5p_mfc_ctx *ctx)\n{\n\treturn s5p_mfc_read_info_v6(ctx,\n\t\t(__force unsigned long) ctx->dev->mfc_regs->d_ret_picture_tag_bot);\n}\n\nstatic unsigned int s5p_mfc_get_crop_info_h_v6(struct s5p_mfc_ctx *ctx)\n{\n\treturn s5p_mfc_read_info_v6(ctx,\n\t\t(__force unsigned long) ctx->dev->mfc_regs->d_display_crop_info1);\n}\n\nstatic unsigned int s5p_mfc_get_crop_info_v_v6(struct s5p_mfc_ctx *ctx)\n{\n\treturn s5p_mfc_read_info_v6(ctx,\n\t\t(__force unsigned long) ctx->dev->mfc_regs->d_display_crop_info2);\n}\n\nstatic struct s5p_mfc_regs mfc_regs;\n\n \nconst struct s5p_mfc_regs *s5p_mfc_init_regs_v6_plus(struct s5p_mfc_dev *dev)\n{\n\tmemset(&mfc_regs, 0, sizeof(mfc_regs));\n\n#define S5P_MFC_REG_ADDR(dev, reg) ((dev)->regs_base + (reg))\n#define R(m, r) mfc_regs.m = S5P_MFC_REG_ADDR(dev, r)\n\t \n\tR(risc_on, S5P_FIMV_RISC_ON_V6);\n\tR(risc2host_int, S5P_FIMV_RISC2HOST_INT_V6);\n\tR(host2risc_int, S5P_FIMV_HOST2RISC_INT_V6);\n\tR(risc_base_address, S5P_FIMV_RISC_BASE_ADDRESS_V6);\n\tR(mfc_reset, S5P_FIMV_MFC_RESET_V6);\n\tR(host2risc_command, S5P_FIMV_HOST2RISC_CMD_V6);\n\tR(risc2host_command, S5P_FIMV_RISC2HOST_CMD_V6);\n\tR(firmware_version, S5P_FIMV_FW_VERSION_V6);\n\tR(instance_id, S5P_FIMV_INSTANCE_ID_V6);\n\tR(codec_type, S5P_FIMV_CODEC_TYPE_V6);\n\tR(context_mem_addr, S5P_FIMV_CONTEXT_MEM_ADDR_V6);\n\tR(context_mem_size, S5P_FIMV_CONTEXT_MEM_SIZE_V6);\n\tR(pixel_format, S5P_FIMV_PIXEL_FORMAT_V6);\n\tR(ret_instance_id, S5P_FIMV_RET_INSTANCE_ID_V6);\n\tR(error_code, S5P_FIMV_ERROR_CODE_V6);\n\n\t \n\tR(d_crc_ctrl, S5P_FIMV_D_CRC_CTRL_V6);\n\tR(d_dec_options, S5P_FIMV_D_DEC_OPTIONS_V6);\n\tR(d_display_delay, S5P_FIMV_D_DISPLAY_DELAY_V6);\n\tR(d_sei_enable, S5P_FIMV_D_SEI_ENABLE_V6);\n\tR(d_min_num_dpb, S5P_FIMV_D_MIN_NUM_DPB_V6);\n\tR(d_min_num_mv, S5P_FIMV_D_MIN_NUM_MV_V6);\n\tR(d_mvc_num_views, S5P_FIMV_D_MVC_NUM_VIEWS_V6);\n\tR(d_num_dpb, S5P_FIMV_D_NUM_DPB_V6);\n\tR(d_num_mv, S5P_FIMV_D_NUM_MV_V6);\n\tR(d_init_buffer_options, S5P_FIMV_D_INIT_BUFFER_OPTIONS_V6);\n\tR(d_first_plane_dpb_size, S5P_FIMV_D_LUMA_DPB_SIZE_V6);\n\tR(d_second_plane_dpb_size, S5P_FIMV_D_CHROMA_DPB_SIZE_V6);\n\tR(d_mv_buffer_size, S5P_FIMV_D_MV_BUFFER_SIZE_V6);\n\tR(d_first_plane_dpb, S5P_FIMV_D_LUMA_DPB_V6);\n\tR(d_second_plane_dpb, S5P_FIMV_D_CHROMA_DPB_V6);\n\tR(d_mv_buffer, S5P_FIMV_D_MV_BUFFER_V6);\n\tR(d_scratch_buffer_addr, S5P_FIMV_D_SCRATCH_BUFFER_ADDR_V6);\n\tR(d_scratch_buffer_size, S5P_FIMV_D_SCRATCH_BUFFER_SIZE_V6);\n\tR(d_cpb_buffer_addr, S5P_FIMV_D_CPB_BUFFER_ADDR_V6);\n\tR(d_cpb_buffer_size, S5P_FIMV_D_CPB_BUFFER_SIZE_V6);\n\tR(d_available_dpb_flag_lower, S5P_FIMV_D_AVAILABLE_DPB_FLAG_LOWER_V6);\n\tR(d_cpb_buffer_offset, S5P_FIMV_D_CPB_BUFFER_OFFSET_V6);\n\tR(d_slice_if_enable, S5P_FIMV_D_SLICE_IF_ENABLE_V6);\n\tR(d_stream_data_size, S5P_FIMV_D_STREAM_DATA_SIZE_V6);\n\tR(d_display_frame_width, S5P_FIMV_D_DISPLAY_FRAME_WIDTH_V6);\n\tR(d_display_frame_height, S5P_FIMV_D_DISPLAY_FRAME_HEIGHT_V6);\n\tR(d_display_status, S5P_FIMV_D_DISPLAY_STATUS_V6);\n\tR(d_display_first_plane_addr, S5P_FIMV_D_DISPLAY_LUMA_ADDR_V6);\n\tR(d_display_second_plane_addr, S5P_FIMV_D_DISPLAY_CHROMA_ADDR_V6);\n\tR(d_display_frame_type, S5P_FIMV_D_DISPLAY_FRAME_TYPE_V6);\n\tR(d_display_crop_info1, S5P_FIMV_D_DISPLAY_CROP_INFO1_V6);\n\tR(d_display_crop_info2, S5P_FIMV_D_DISPLAY_CROP_INFO2_V6);\n\tR(d_display_aspect_ratio, S5P_FIMV_D_DISPLAY_ASPECT_RATIO_V6);\n\tR(d_display_extended_ar, S5P_FIMV_D_DISPLAY_EXTENDED_AR_V6);\n\tR(d_decoded_status, S5P_FIMV_D_DECODED_STATUS_V6);\n\tR(d_decoded_first_plane_addr, S5P_FIMV_D_DECODED_LUMA_ADDR_V6);\n\tR(d_decoded_second_plane_addr, S5P_FIMV_D_DECODED_CHROMA_ADDR_V6);\n\tR(d_decoded_frame_type, S5P_FIMV_D_DECODED_FRAME_TYPE_V6);\n\tR(d_decoded_nal_size, S5P_FIMV_D_DECODED_NAL_SIZE_V6);\n\tR(d_ret_picture_tag_top, S5P_FIMV_D_RET_PICTURE_TAG_TOP_V6);\n\tR(d_ret_picture_tag_bot, S5P_FIMV_D_RET_PICTURE_TAG_BOT_V6);\n\tR(d_h264_info, S5P_FIMV_D_H264_INFO_V6);\n\tR(d_mvc_view_id, S5P_FIMV_D_MVC_VIEW_ID_V6);\n\tR(d_frame_pack_sei_avail, S5P_FIMV_D_FRAME_PACK_SEI_AVAIL_V6);\n\n\t \n\tR(e_frame_width, S5P_FIMV_E_FRAME_WIDTH_V6);\n\tR(e_frame_height, S5P_FIMV_E_FRAME_HEIGHT_V6);\n\tR(e_cropped_frame_width, S5P_FIMV_E_CROPPED_FRAME_WIDTH_V6);\n\tR(e_cropped_frame_height, S5P_FIMV_E_CROPPED_FRAME_HEIGHT_V6);\n\tR(e_frame_crop_offset, S5P_FIMV_E_FRAME_CROP_OFFSET_V6);\n\tR(e_enc_options, S5P_FIMV_E_ENC_OPTIONS_V6);\n\tR(e_picture_profile, S5P_FIMV_E_PICTURE_PROFILE_V6);\n\tR(e_vbv_buffer_size, S5P_FIMV_E_VBV_BUFFER_SIZE_V6);\n\tR(e_vbv_init_delay, S5P_FIMV_E_VBV_INIT_DELAY_V6);\n\tR(e_fixed_picture_qp, S5P_FIMV_E_FIXED_PICTURE_QP_V6);\n\tR(e_rc_config, S5P_FIMV_E_RC_CONFIG_V6);\n\tR(e_rc_qp_bound, S5P_FIMV_E_RC_QP_BOUND_V6);\n\tR(e_rc_mode, S5P_FIMV_E_RC_RPARAM_V6);\n\tR(e_mb_rc_config, S5P_FIMV_E_MB_RC_CONFIG_V6);\n\tR(e_padding_ctrl, S5P_FIMV_E_PADDING_CTRL_V6);\n\tR(e_mv_hor_range, S5P_FIMV_E_MV_HOR_RANGE_V6);\n\tR(e_mv_ver_range, S5P_FIMV_E_MV_VER_RANGE_V6);\n\tR(e_num_dpb, S5P_FIMV_E_NUM_DPB_V6);\n\tR(e_luma_dpb, S5P_FIMV_E_LUMA_DPB_V6);\n\tR(e_chroma_dpb, S5P_FIMV_E_CHROMA_DPB_V6);\n\tR(e_me_buffer, S5P_FIMV_E_ME_BUFFER_V6);\n\tR(e_scratch_buffer_addr, S5P_FIMV_E_SCRATCH_BUFFER_ADDR_V6);\n\tR(e_scratch_buffer_size, S5P_FIMV_E_SCRATCH_BUFFER_SIZE_V6);\n\tR(e_tmv_buffer0, S5P_FIMV_E_TMV_BUFFER0_V6);\n\tR(e_tmv_buffer1, S5P_FIMV_E_TMV_BUFFER1_V6);\n\tR(e_source_first_plane_addr, S5P_FIMV_E_SOURCE_LUMA_ADDR_V6);\n\tR(e_source_second_plane_addr, S5P_FIMV_E_SOURCE_CHROMA_ADDR_V6);\n\tR(e_stream_buffer_addr, S5P_FIMV_E_STREAM_BUFFER_ADDR_V6);\n\tR(e_stream_buffer_size, S5P_FIMV_E_STREAM_BUFFER_SIZE_V6);\n\tR(e_roi_buffer_addr, S5P_FIMV_E_ROI_BUFFER_ADDR_V6);\n\tR(e_param_change, S5P_FIMV_E_PARAM_CHANGE_V6);\n\tR(e_ir_size, S5P_FIMV_E_IR_SIZE_V6);\n\tR(e_gop_config, S5P_FIMV_E_GOP_CONFIG_V6);\n\tR(e_mslice_mode, S5P_FIMV_E_MSLICE_MODE_V6);\n\tR(e_mslice_size_mb, S5P_FIMV_E_MSLICE_SIZE_MB_V6);\n\tR(e_mslice_size_bits, S5P_FIMV_E_MSLICE_SIZE_BITS_V6);\n\tR(e_frame_insertion, S5P_FIMV_E_FRAME_INSERTION_V6);\n\tR(e_rc_frame_rate, S5P_FIMV_E_RC_FRAME_RATE_V6);\n\tR(e_rc_bit_rate, S5P_FIMV_E_RC_BIT_RATE_V6);\n\tR(e_rc_roi_ctrl, S5P_FIMV_E_RC_ROI_CTRL_V6);\n\tR(e_picture_tag, S5P_FIMV_E_PICTURE_TAG_V6);\n\tR(e_bit_count_enable, S5P_FIMV_E_BIT_COUNT_ENABLE_V6);\n\tR(e_max_bit_count, S5P_FIMV_E_MAX_BIT_COUNT_V6);\n\tR(e_min_bit_count, S5P_FIMV_E_MIN_BIT_COUNT_V6);\n\tR(e_metadata_buffer_addr, S5P_FIMV_E_METADATA_BUFFER_ADDR_V6);\n\tR(e_metadata_buffer_size, S5P_FIMV_E_METADATA_BUFFER_SIZE_V6);\n\tR(e_encoded_source_first_plane_addr,\n\t\t\tS5P_FIMV_E_ENCODED_SOURCE_LUMA_ADDR_V6);\n\tR(e_encoded_source_second_plane_addr,\n\t\t\tS5P_FIMV_E_ENCODED_SOURCE_CHROMA_ADDR_V6);\n\tR(e_stream_size, S5P_FIMV_E_STREAM_SIZE_V6);\n\tR(e_slice_type, S5P_FIMV_E_SLICE_TYPE_V6);\n\tR(e_picture_count, S5P_FIMV_E_PICTURE_COUNT_V6);\n\tR(e_ret_picture_tag, S5P_FIMV_E_RET_PICTURE_TAG_V6);\n\tR(e_recon_luma_dpb_addr, S5P_FIMV_E_RECON_LUMA_DPB_ADDR_V6);\n\tR(e_recon_chroma_dpb_addr, S5P_FIMV_E_RECON_CHROMA_DPB_ADDR_V6);\n\tR(e_mpeg4_options, S5P_FIMV_E_MPEG4_OPTIONS_V6);\n\tR(e_mpeg4_hec_period, S5P_FIMV_E_MPEG4_HEC_PERIOD_V6);\n\tR(e_aspect_ratio, S5P_FIMV_E_ASPECT_RATIO_V6);\n\tR(e_extended_sar, S5P_FIMV_E_EXTENDED_SAR_V6);\n\tR(e_h264_options, S5P_FIMV_E_H264_OPTIONS_V6);\n\tR(e_h264_lf_alpha_offset, S5P_FIMV_E_H264_LF_ALPHA_OFFSET_V6);\n\tR(e_h264_lf_beta_offset, S5P_FIMV_E_H264_LF_BETA_OFFSET_V6);\n\tR(e_h264_i_period, S5P_FIMV_E_H264_I_PERIOD_V6);\n\tR(e_h264_fmo_slice_grp_map_type,\n\t\t\tS5P_FIMV_E_H264_FMO_SLICE_GRP_MAP_TYPE_V6);\n\tR(e_h264_fmo_num_slice_grp_minus1,\n\t\t\tS5P_FIMV_E_H264_FMO_NUM_SLICE_GRP_MINUS1_V6);\n\tR(e_h264_fmo_slice_grp_change_dir,\n\t\t\tS5P_FIMV_E_H264_FMO_SLICE_GRP_CHANGE_DIR_V6);\n\tR(e_h264_fmo_slice_grp_change_rate_minus1,\n\t\t\tS5P_FIMV_E_H264_FMO_SLICE_GRP_CHANGE_RATE_MINUS1_V6);\n\tR(e_h264_fmo_run_length_minus1_0,\n\t\t\tS5P_FIMV_E_H264_FMO_RUN_LENGTH_MINUS1_0_V6);\n\tR(e_h264_aso_slice_order_0, S5P_FIMV_E_H264_ASO_SLICE_ORDER_0_V6);\n\tR(e_h264_num_t_layer, S5P_FIMV_E_H264_NUM_T_LAYER_V6);\n\tR(e_h264_hierarchical_qp_layer0,\n\t\t\tS5P_FIMV_E_H264_HIERARCHICAL_QP_LAYER0_V6);\n\tR(e_h264_frame_packing_sei_info,\n\t\t\tS5P_FIMV_E_H264_FRAME_PACKING_SEI_INFO_V6);\n\n\tif (!IS_MFCV7_PLUS(dev))\n\t\tgoto done;\n\n\t \n\tR(e_source_first_plane_addr, S5P_FIMV_E_SOURCE_FIRST_ADDR_V7);\n\tR(e_source_second_plane_addr, S5P_FIMV_E_SOURCE_SECOND_ADDR_V7);\n\tR(e_source_third_plane_addr, S5P_FIMV_E_SOURCE_THIRD_ADDR_V7);\n\tR(e_source_first_plane_stride, S5P_FIMV_E_SOURCE_FIRST_STRIDE_V7);\n\tR(e_source_second_plane_stride, S5P_FIMV_E_SOURCE_SECOND_STRIDE_V7);\n\tR(e_source_third_plane_stride, S5P_FIMV_E_SOURCE_THIRD_STRIDE_V7);\n\tR(e_encoded_source_first_plane_addr,\n\t\t\tS5P_FIMV_E_ENCODED_SOURCE_FIRST_ADDR_V7);\n\tR(e_encoded_source_second_plane_addr,\n\t\t\tS5P_FIMV_E_ENCODED_SOURCE_SECOND_ADDR_V7);\n\tR(e_vp8_options, S5P_FIMV_E_VP8_OPTIONS_V7);\n\n\tif (!IS_MFCV8_PLUS(dev))\n\t\tgoto done;\n\n\t \n\tR(d_stream_data_size, S5P_FIMV_D_STREAM_DATA_SIZE_V8);\n\tR(d_cpb_buffer_addr, S5P_FIMV_D_CPB_BUFFER_ADDR_V8);\n\tR(d_cpb_buffer_size, S5P_FIMV_D_CPB_BUFFER_SIZE_V8);\n\tR(d_cpb_buffer_offset, S5P_FIMV_D_CPB_BUFFER_OFFSET_V8);\n\tR(d_first_plane_dpb_size, S5P_FIMV_D_FIRST_PLANE_DPB_SIZE_V8);\n\tR(d_second_plane_dpb_size, S5P_FIMV_D_SECOND_PLANE_DPB_SIZE_V8);\n\tR(d_scratch_buffer_addr, S5P_FIMV_D_SCRATCH_BUFFER_ADDR_V8);\n\tR(d_scratch_buffer_size, S5P_FIMV_D_SCRATCH_BUFFER_SIZE_V8);\n\tR(d_first_plane_dpb_stride_size,\n\t\t\tS5P_FIMV_D_FIRST_PLANE_DPB_STRIDE_SIZE_V8);\n\tR(d_second_plane_dpb_stride_size,\n\t\t\tS5P_FIMV_D_SECOND_PLANE_DPB_STRIDE_SIZE_V8);\n\tR(d_mv_buffer_size, S5P_FIMV_D_MV_BUFFER_SIZE_V8);\n\tR(d_num_mv, S5P_FIMV_D_NUM_MV_V8);\n\tR(d_first_plane_dpb, S5P_FIMV_D_FIRST_PLANE_DPB_V8);\n\tR(d_second_plane_dpb, S5P_FIMV_D_SECOND_PLANE_DPB_V8);\n\tR(d_mv_buffer, S5P_FIMV_D_MV_BUFFER_V8);\n\tR(d_init_buffer_options, S5P_FIMV_D_INIT_BUFFER_OPTIONS_V8);\n\tR(d_available_dpb_flag_lower, S5P_FIMV_D_AVAILABLE_DPB_FLAG_LOWER_V8);\n\tR(d_slice_if_enable, S5P_FIMV_D_SLICE_IF_ENABLE_V8);\n\tR(d_display_first_plane_addr, S5P_FIMV_D_DISPLAY_FIRST_PLANE_ADDR_V8);\n\tR(d_display_second_plane_addr, S5P_FIMV_D_DISPLAY_SECOND_PLANE_ADDR_V8);\n\tR(d_decoded_first_plane_addr, S5P_FIMV_D_DECODED_FIRST_PLANE_ADDR_V8);\n\tR(d_decoded_second_plane_addr, S5P_FIMV_D_DECODED_SECOND_PLANE_ADDR_V8);\n\tR(d_display_status, S5P_FIMV_D_DISPLAY_STATUS_V8);\n\tR(d_decoded_status, S5P_FIMV_D_DECODED_STATUS_V8);\n\tR(d_decoded_frame_type, S5P_FIMV_D_DECODED_FRAME_TYPE_V8);\n\tR(d_display_frame_type, S5P_FIMV_D_DISPLAY_FRAME_TYPE_V8);\n\tR(d_decoded_nal_size, S5P_FIMV_D_DECODED_NAL_SIZE_V8);\n\tR(d_display_frame_width, S5P_FIMV_D_DISPLAY_FRAME_WIDTH_V8);\n\tR(d_display_frame_height, S5P_FIMV_D_DISPLAY_FRAME_HEIGHT_V8);\n\tR(d_frame_pack_sei_avail, S5P_FIMV_D_FRAME_PACK_SEI_AVAIL_V8);\n\tR(d_mvc_num_views, S5P_FIMV_D_MVC_NUM_VIEWS_V8);\n\tR(d_mvc_view_id, S5P_FIMV_D_MVC_VIEW_ID_V8);\n\tR(d_ret_picture_tag_top, S5P_FIMV_D_RET_PICTURE_TAG_TOP_V8);\n\tR(d_ret_picture_tag_bot, S5P_FIMV_D_RET_PICTURE_TAG_BOT_V8);\n\tR(d_display_crop_info1, S5P_FIMV_D_DISPLAY_CROP_INFO1_V8);\n\tR(d_display_crop_info2, S5P_FIMV_D_DISPLAY_CROP_INFO2_V8);\n\tR(d_min_scratch_buffer_size, S5P_FIMV_D_MIN_SCRATCH_BUFFER_SIZE_V8);\n\n\t \n\tR(e_padding_ctrl, S5P_FIMV_E_PADDING_CTRL_V8);\n\tR(e_rc_config, S5P_FIMV_E_RC_CONFIG_V8);\n\tR(e_rc_mode, S5P_FIMV_E_RC_RPARAM_V8);\n\tR(e_mv_hor_range, S5P_FIMV_E_MV_HOR_RANGE_V8);\n\tR(e_mv_ver_range, S5P_FIMV_E_MV_VER_RANGE_V8);\n\tR(e_rc_qp_bound, S5P_FIMV_E_RC_QP_BOUND_V8);\n\tR(e_fixed_picture_qp, S5P_FIMV_E_FIXED_PICTURE_QP_V8);\n\tR(e_vbv_buffer_size, S5P_FIMV_E_VBV_BUFFER_SIZE_V8);\n\tR(e_vbv_init_delay, S5P_FIMV_E_VBV_INIT_DELAY_V8);\n\tR(e_mb_rc_config, S5P_FIMV_E_MB_RC_CONFIG_V8);\n\tR(e_aspect_ratio, S5P_FIMV_E_ASPECT_RATIO_V8);\n\tR(e_extended_sar, S5P_FIMV_E_EXTENDED_SAR_V8);\n\tR(e_h264_options, S5P_FIMV_E_H264_OPTIONS_V8);\n\tR(e_min_scratch_buffer_size, S5P_FIMV_E_MIN_SCRATCH_BUFFER_SIZE_V8);\n\n\tif (!IS_MFCV10(dev))\n\t\tgoto done;\n\n\t \n\n\t \n\tR(d_static_buffer_addr, S5P_FIMV_D_STATIC_BUFFER_ADDR_V10);\n\tR(d_static_buffer_size, S5P_FIMV_D_STATIC_BUFFER_SIZE_V10);\n\n\t \n\tR(e_num_t_layer, S5P_FIMV_E_NUM_T_LAYER_V10);\n\tR(e_hier_qp_layer0, S5P_FIMV_E_HIERARCHICAL_QP_LAYER0_V10);\n\tR(e_hier_bit_rate_layer0, S5P_FIMV_E_HIERARCHICAL_BIT_RATE_LAYER0_V10);\n\tR(e_hevc_options, S5P_FIMV_E_HEVC_OPTIONS_V10);\n\tR(e_hevc_refresh_period, S5P_FIMV_E_HEVC_REFRESH_PERIOD_V10);\n\tR(e_hevc_lf_beta_offset_div2, S5P_FIMV_E_HEVC_LF_BETA_OFFSET_DIV2_V10);\n\tR(e_hevc_lf_tc_offset_div2, S5P_FIMV_E_HEVC_LF_TC_OFFSET_DIV2_V10);\n\tR(e_hevc_nal_control, S5P_FIMV_E_HEVC_NAL_CONTROL_V10);\n\ndone:\n\treturn &mfc_regs;\n#undef S5P_MFC_REG_ADDR\n#undef R\n}\n\n \nstatic struct s5p_mfc_hw_ops s5p_mfc_ops_v6 = {\n\t.alloc_dec_temp_buffers = s5p_mfc_alloc_dec_temp_buffers_v6,\n\t.release_dec_desc_buffer = s5p_mfc_release_dec_desc_buffer_v6,\n\t.alloc_codec_buffers = s5p_mfc_alloc_codec_buffers_v6,\n\t.release_codec_buffers = s5p_mfc_release_codec_buffers_v6,\n\t.alloc_instance_buffer = s5p_mfc_alloc_instance_buffer_v6,\n\t.release_instance_buffer = s5p_mfc_release_instance_buffer_v6,\n\t.alloc_dev_context_buffer =\n\t\ts5p_mfc_alloc_dev_context_buffer_v6,\n\t.release_dev_context_buffer =\n\t\ts5p_mfc_release_dev_context_buffer_v6,\n\t.dec_calc_dpb_size = s5p_mfc_dec_calc_dpb_size_v6,\n\t.enc_calc_src_size = s5p_mfc_enc_calc_src_size_v6,\n\t.set_enc_stream_buffer = s5p_mfc_set_enc_stream_buffer_v6,\n\t.set_enc_frame_buffer = s5p_mfc_set_enc_frame_buffer_v6,\n\t.get_enc_frame_buffer = s5p_mfc_get_enc_frame_buffer_v6,\n\t.try_run = s5p_mfc_try_run_v6,\n\t.clear_int_flags = s5p_mfc_clear_int_flags_v6,\n\t.get_dspl_y_adr = s5p_mfc_get_dspl_y_adr_v6,\n\t.get_dec_y_adr = s5p_mfc_get_dec_y_adr_v6,\n\t.get_dspl_status = s5p_mfc_get_dspl_status_v6,\n\t.get_dec_status = s5p_mfc_get_dec_status_v6,\n\t.get_dec_frame_type = s5p_mfc_get_dec_frame_type_v6,\n\t.get_disp_frame_type = s5p_mfc_get_disp_frame_type_v6,\n\t.get_consumed_stream = s5p_mfc_get_consumed_stream_v6,\n\t.get_int_reason = s5p_mfc_get_int_reason_v6,\n\t.get_int_err = s5p_mfc_get_int_err_v6,\n\t.err_dec = s5p_mfc_err_dec_v6,\n\t.get_img_width = s5p_mfc_get_img_width_v6,\n\t.get_img_height = s5p_mfc_get_img_height_v6,\n\t.get_dpb_count = s5p_mfc_get_dpb_count_v6,\n\t.get_mv_count = s5p_mfc_get_mv_count_v6,\n\t.get_inst_no = s5p_mfc_get_inst_no_v6,\n\t.get_enc_strm_size = s5p_mfc_get_enc_strm_size_v6,\n\t.get_enc_slice_type = s5p_mfc_get_enc_slice_type_v6,\n\t.get_enc_dpb_count = s5p_mfc_get_enc_dpb_count_v6,\n\t.get_pic_type_top = s5p_mfc_get_pic_type_top_v6,\n\t.get_pic_type_bot = s5p_mfc_get_pic_type_bot_v6,\n\t.get_crop_info_h = s5p_mfc_get_crop_info_h_v6,\n\t.get_crop_info_v = s5p_mfc_get_crop_info_v_v6,\n\t.get_min_scratch_buf_size = s5p_mfc_get_min_scratch_buf_size,\n\t.get_e_min_scratch_buf_size = s5p_mfc_get_e_min_scratch_buf_size,\n};\n\nstruct s5p_mfc_hw_ops *s5p_mfc_init_hw_ops_v6(void)\n{\n\treturn &s5p_mfc_ops_v6;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}