{
  "module_name": "s5p_mfc_opr_v5.c",
  "hash_id": "600b7a64d4bcf50adad287b0abaa8c9f2dde165487d9b7a4929dca8612f403cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/samsung/s5p-mfc/s5p_mfc_opr_v5.c",
  "human_readable_source": "\n \n\n#include \"s5p_mfc_common.h\"\n#include \"s5p_mfc_cmd.h\"\n#include \"s5p_mfc_ctrl.h\"\n#include \"s5p_mfc_debug.h\"\n#include \"s5p_mfc_intr.h\"\n#include \"s5p_mfc_pm.h\"\n#include \"s5p_mfc_opr.h\"\n#include \"s5p_mfc_opr_v5.h\"\n#include <asm/cacheflush.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/firmware.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define OFFSETA(x)\t\t(((x) - dev->dma_base[BANK_L_CTX]) >> MFC_OFFSET_SHIFT)\n#define OFFSETB(x)\t\t(((x) - dev->dma_base[BANK_R_CTX]) >> MFC_OFFSET_SHIFT)\n\n \nstatic int s5p_mfc_alloc_dec_temp_buffers_v5(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf_size_v5 *buf_size = dev->variant->buf_size->priv;\n\tint ret;\n\n\tctx->dsc.size = buf_size->dsc;\n\tret =  s5p_mfc_alloc_priv_buf(dev, BANK_L_CTX, &ctx->dsc);\n\tif (ret) {\n\t\tmfc_err(\"Failed to allocate temporary buffer\\n\");\n\t\treturn ret;\n\t}\n\n\tBUG_ON(ctx->dsc.dma & ((1 << MFC_BANK1_ALIGN_ORDER) - 1));\n\tmemset(ctx->dsc.virt, 0, ctx->dsc.size);\n\twmb();\n\treturn 0;\n}\n\n\n \nstatic void s5p_mfc_release_dec_desc_buffer_v5(struct s5p_mfc_ctx *ctx)\n{\n\ts5p_mfc_release_priv_buf(ctx->dev, &ctx->dsc);\n}\n\n \nstatic int s5p_mfc_alloc_codec_buffers_v5(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tunsigned int enc_ref_y_size = 0;\n\tunsigned int enc_ref_c_size = 0;\n\tunsigned int guard_width, guard_height;\n\tint ret;\n\n\tif (ctx->type == MFCINST_DECODER) {\n\t\tmfc_debug(2, \"Luma size:%d Chroma size:%d MV size:%d\\n\",\n\t\t\t  ctx->luma_size, ctx->chroma_size, ctx->mv_size);\n\t\tmfc_debug(2, \"Totals bufs: %d\\n\", ctx->total_dpb_count);\n\t} else if (ctx->type == MFCINST_ENCODER) {\n\t\tenc_ref_y_size = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\n\t\t\t* ALIGN(ctx->img_height, S5P_FIMV_NV12MT_VALIGN);\n\t\tenc_ref_y_size = ALIGN(enc_ref_y_size, S5P_FIMV_NV12MT_SALIGN);\n\n\t\tif (ctx->codec_mode == S5P_MFC_CODEC_H264_ENC) {\n\t\t\tenc_ref_c_size = ALIGN(ctx->img_width,\n\t\t\t\t\t\tS5P_FIMV_NV12MT_HALIGN)\n\t\t\t\t\t\t* ALIGN(ctx->img_height >> 1,\n\t\t\t\t\t\tS5P_FIMV_NV12MT_VALIGN);\n\t\t\tenc_ref_c_size = ALIGN(enc_ref_c_size,\n\t\t\t\t\t\t\tS5P_FIMV_NV12MT_SALIGN);\n\t\t} else {\n\t\t\tguard_width = ALIGN(ctx->img_width + 16,\n\t\t\t\t\t\t\tS5P_FIMV_NV12MT_HALIGN);\n\t\t\tguard_height = ALIGN((ctx->img_height >> 1) + 4,\n\t\t\t\t\t\t\tS5P_FIMV_NV12MT_VALIGN);\n\t\t\tenc_ref_c_size = ALIGN(guard_width * guard_height,\n\t\t\t\t\t       S5P_FIMV_NV12MT_SALIGN);\n\t\t}\n\t\tmfc_debug(2, \"recon luma size: %d chroma size: %d\\n\",\n\t\t\t  enc_ref_y_size, enc_ref_c_size);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\t \n\tswitch (ctx->codec_mode) {\n\tcase S5P_MFC_CODEC_H264_DEC:\n\t\tctx->bank1.size =\n\t\t    ALIGN(S5P_FIMV_DEC_NB_IP_SIZE +\n\t\t\t\t\tS5P_FIMV_DEC_VERT_NB_MV_SIZE,\n\t\t\t\t\tS5P_FIMV_DEC_BUF_ALIGN);\n\t\tctx->bank2.size = ctx->total_dpb_count * ctx->mv_size;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG4_DEC:\n\t\tctx->bank1.size =\n\t\t    ALIGN(S5P_FIMV_DEC_NB_DCAC_SIZE +\n\t\t\t\t     S5P_FIMV_DEC_UPNB_MV_SIZE +\n\t\t\t\t     S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE +\n\t\t\t\t     S5P_FIMV_DEC_STX_PARSER_SIZE +\n\t\t\t\t     S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE,\n\t\t\t\t     S5P_FIMV_DEC_BUF_ALIGN);\n\t\tctx->bank2.size = 0;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_VC1RCV_DEC:\n\tcase S5P_MFC_CODEC_VC1_DEC:\n\t\tctx->bank1.size =\n\t\t    ALIGN(S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE +\n\t\t\t     S5P_FIMV_DEC_UPNB_MV_SIZE +\n\t\t\t     S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE +\n\t\t\t     S5P_FIMV_DEC_NB_DCAC_SIZE +\n\t\t\t     3 * S5P_FIMV_DEC_VC1_BITPLANE_SIZE,\n\t\t\t     S5P_FIMV_DEC_BUF_ALIGN);\n\t\tctx->bank2.size = 0;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG2_DEC:\n\t\tctx->bank1.size = 0;\n\t\tctx->bank2.size = 0;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_H263_DEC:\n\t\tctx->bank1.size =\n\t\t    ALIGN(S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE +\n\t\t\t     S5P_FIMV_DEC_UPNB_MV_SIZE +\n\t\t\t     S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE +\n\t\t\t     S5P_FIMV_DEC_NB_DCAC_SIZE,\n\t\t\t     S5P_FIMV_DEC_BUF_ALIGN);\n\t\tctx->bank2.size = 0;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_H264_ENC:\n\t\tctx->bank1.size = (enc_ref_y_size * 2) +\n\t\t\t\t   S5P_FIMV_ENC_UPMV_SIZE +\n\t\t\t\t   S5P_FIMV_ENC_COLFLG_SIZE +\n\t\t\t\t   S5P_FIMV_ENC_INTRAMD_SIZE +\n\t\t\t\t   S5P_FIMV_ENC_NBORINFO_SIZE;\n\t\tctx->bank2.size = (enc_ref_y_size * 2) +\n\t\t\t\t   (enc_ref_c_size * 4) +\n\t\t\t\t   S5P_FIMV_ENC_INTRAPRED_SIZE;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG4_ENC:\n\t\tctx->bank1.size = (enc_ref_y_size * 2) +\n\t\t\t\t   S5P_FIMV_ENC_UPMV_SIZE +\n\t\t\t\t   S5P_FIMV_ENC_COLFLG_SIZE +\n\t\t\t\t   S5P_FIMV_ENC_ACDCCOEF_SIZE;\n\t\tctx->bank2.size = (enc_ref_y_size * 2) +\n\t\t\t\t   (enc_ref_c_size * 4);\n\t\tbreak;\n\tcase S5P_MFC_CODEC_H263_ENC:\n\t\tctx->bank1.size = (enc_ref_y_size * 2) +\n\t\t\t\t   S5P_FIMV_ENC_UPMV_SIZE +\n\t\t\t\t   S5P_FIMV_ENC_ACDCCOEF_SIZE;\n\t\tctx->bank2.size = (enc_ref_y_size * 2) +\n\t\t\t\t   (enc_ref_c_size * 4);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\tif (ctx->bank1.size > 0) {\n\n\t\tret = s5p_mfc_alloc_priv_buf(dev, BANK_L_CTX, &ctx->bank1);\n\t\tif (ret) {\n\t\t\tmfc_err(\"Failed to allocate Bank1 temporary buffer\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tBUG_ON(ctx->bank1.dma & ((1 << MFC_BANK1_ALIGN_ORDER) - 1));\n\t}\n\t \n\tif (ctx->bank2.size > 0) {\n\t\tret = s5p_mfc_alloc_priv_buf(dev, BANK_R_CTX, &ctx->bank2);\n\t\tif (ret) {\n\t\t\tmfc_err(\"Failed to allocate Bank2 temporary buffer\\n\");\n\t\t\ts5p_mfc_release_priv_buf(ctx->dev, &ctx->bank1);\n\t\t\treturn ret;\n\t\t}\n\t\tBUG_ON(ctx->bank2.dma & ((1 << MFC_BANK2_ALIGN_ORDER) - 1));\n\t}\n\treturn 0;\n}\n\n \nstatic void s5p_mfc_release_codec_buffers_v5(struct s5p_mfc_ctx *ctx)\n{\n\ts5p_mfc_release_priv_buf(ctx->dev, &ctx->bank1);\n\ts5p_mfc_release_priv_buf(ctx->dev, &ctx->bank2);\n}\n\n \nstatic int s5p_mfc_alloc_instance_buffer_v5(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf_size_v5 *buf_size = dev->variant->buf_size->priv;\n\tint ret;\n\n\tif (ctx->codec_mode == S5P_MFC_CODEC_H264_DEC ||\n\t\tctx->codec_mode == S5P_MFC_CODEC_H264_ENC)\n\t\tctx->ctx.size = buf_size->h264_ctx;\n\telse\n\t\tctx->ctx.size = buf_size->non_h264_ctx;\n\n\tret = s5p_mfc_alloc_priv_buf(dev, BANK_L_CTX, &ctx->ctx);\n\tif (ret) {\n\t\tmfc_err(\"Failed to allocate instance buffer\\n\");\n\t\treturn ret;\n\t}\n\tctx->ctx.ofs = OFFSETA(ctx->ctx.dma);\n\n\t \n\tmemset(ctx->ctx.virt, 0, ctx->ctx.size);\n\twmb();\n\n\t \n\tctx->shm.size = buf_size->shm;\n\tret = s5p_mfc_alloc_priv_buf(dev, BANK_L_CTX, &ctx->shm);\n\tif (ret) {\n\t\tmfc_err(\"Failed to allocate shared memory buffer\\n\");\n\t\ts5p_mfc_release_priv_buf(dev, &ctx->ctx);\n\t\treturn ret;\n\t}\n\n\t \n\tctx->shm.ofs = ctx->shm.dma - dev->dma_base[BANK_L_CTX];\n\tBUG_ON(ctx->shm.ofs & ((1 << MFC_BANK1_ALIGN_ORDER) - 1));\n\n\tmemset(ctx->shm.virt, 0, buf_size->shm);\n\twmb();\n\treturn 0;\n}\n\n \nstatic void s5p_mfc_release_instance_buffer_v5(struct s5p_mfc_ctx *ctx)\n{\n\ts5p_mfc_release_priv_buf(ctx->dev, &ctx->ctx);\n\ts5p_mfc_release_priv_buf(ctx->dev, &ctx->shm);\n}\n\nstatic int s5p_mfc_alloc_dev_context_buffer_v5(struct s5p_mfc_dev *dev)\n{\n\t \n\n\treturn 0;\n}\n\nstatic void s5p_mfc_release_dev_context_buffer_v5(struct s5p_mfc_dev *dev)\n{\n\t \n}\n\nstatic void s5p_mfc_write_info_v5(struct s5p_mfc_ctx *ctx, unsigned int data,\n\t\t\tunsigned int ofs)\n{\n\t*(u32 *)(ctx->shm.virt + ofs) = data;\n\twmb();\n}\n\nstatic unsigned int s5p_mfc_read_info_v5(struct s5p_mfc_ctx *ctx,\n\t\t\t\tunsigned long ofs)\n{\n\trmb();\n\treturn *(u32 *)(ctx->shm.virt + ofs);\n}\n\nstatic void s5p_mfc_dec_calc_dpb_size_v5(struct s5p_mfc_ctx *ctx)\n{\n\tunsigned int guard_width, guard_height;\n\n\tctx->buf_width = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN);\n\tctx->buf_height = ALIGN(ctx->img_height, S5P_FIMV_NV12MT_VALIGN);\n\tmfc_debug(2,\n\t\t\"SEQ Done: Movie dimensions %dx%d, buffer dimensions: %dx%d\\n\",\n\t\tctx->img_width,\tctx->img_height, ctx->buf_width,\n\t\tctx->buf_height);\n\n\tif (ctx->codec_mode == S5P_MFC_CODEC_H264_DEC) {\n\t\tctx->luma_size = ALIGN(ctx->buf_width * ctx->buf_height,\n\t\t\t\tS5P_FIMV_DEC_BUF_ALIGN);\n\t\tctx->chroma_size = ALIGN(ctx->buf_width *\n\t\t\t\tALIGN((ctx->img_height >> 1),\n\t\t\t\t\tS5P_FIMV_NV12MT_VALIGN),\n\t\t\t\tS5P_FIMV_DEC_BUF_ALIGN);\n\t\tctx->mv_size = ALIGN(ctx->buf_width *\n\t\t\t\tALIGN((ctx->buf_height >> 2),\n\t\t\t\t\tS5P_FIMV_NV12MT_VALIGN),\n\t\t\t\tS5P_FIMV_DEC_BUF_ALIGN);\n\t} else {\n\t\tguard_width =\n\t\t\tALIGN(ctx->img_width + 24, S5P_FIMV_NV12MT_HALIGN);\n\t\tguard_height =\n\t\t\tALIGN(ctx->img_height + 16, S5P_FIMV_NV12MT_VALIGN);\n\t\tctx->luma_size = ALIGN(guard_width * guard_height,\n\t\t\t\tS5P_FIMV_DEC_BUF_ALIGN);\n\n\t\tguard_width =\n\t\t\tALIGN(ctx->img_width + 16, S5P_FIMV_NV12MT_HALIGN);\n\t\tguard_height =\n\t\t\tALIGN((ctx->img_height >> 1) + 4,\n\t\t\t\t\tS5P_FIMV_NV12MT_VALIGN);\n\t\tctx->chroma_size = ALIGN(guard_width * guard_height,\n\t\t\t\tS5P_FIMV_DEC_BUF_ALIGN);\n\n\t\tctx->mv_size = 0;\n\t}\n}\n\nstatic void s5p_mfc_enc_calc_src_size_v5(struct s5p_mfc_ctx *ctx)\n{\n\tif (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12M) {\n\t\tctx->buf_width = ALIGN(ctx->img_width, S5P_FIMV_NV12M_HALIGN);\n\n\t\tctx->luma_size = ALIGN(ctx->img_width, S5P_FIMV_NV12M_HALIGN)\n\t\t\t* ALIGN(ctx->img_height, S5P_FIMV_NV12M_LVALIGN);\n\t\tctx->chroma_size = ALIGN(ctx->img_width, S5P_FIMV_NV12M_HALIGN)\n\t\t\t* ALIGN((ctx->img_height >> 1), S5P_FIMV_NV12M_CVALIGN);\n\n\t\tctx->luma_size = ALIGN(ctx->luma_size, S5P_FIMV_NV12M_SALIGN);\n\t\tctx->chroma_size =\n\t\t\tALIGN(ctx->chroma_size, S5P_FIMV_NV12M_SALIGN);\n\t} else if (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12MT) {\n\t\tctx->buf_width = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN);\n\n\t\tctx->luma_size = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\n\t\t\t* ALIGN(ctx->img_height, S5P_FIMV_NV12MT_VALIGN);\n\t\tctx->chroma_size =\n\t\t\tALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\n\t\t\t* ALIGN((ctx->img_height >> 1), S5P_FIMV_NV12MT_VALIGN);\n\n\t\tctx->luma_size = ALIGN(ctx->luma_size, S5P_FIMV_NV12MT_SALIGN);\n\t\tctx->chroma_size =\n\t\t\tALIGN(ctx->chroma_size, S5P_FIMV_NV12MT_SALIGN);\n\t}\n}\n\n \nstatic void s5p_mfc_set_dec_desc_buffer(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf_size_v5 *buf_size = dev->variant->buf_size->priv;\n\n\tmfc_write(dev, OFFSETA(ctx->dsc.dma), S5P_FIMV_SI_CH0_DESC_ADR);\n\tmfc_write(dev, buf_size->dsc, S5P_FIMV_SI_CH0_DESC_SIZE);\n}\n\n \nstatic void s5p_mfc_set_shared_buffer(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tmfc_write(dev, ctx->shm.ofs, S5P_FIMV_SI_CH0_HOST_WR_ADR);\n}\n\n \nstatic int s5p_mfc_set_dec_stream_buffer_v5(struct s5p_mfc_ctx *ctx,\n\t\tint buf_addr, unsigned int start_num_byte,\n\t\tunsigned int buf_size)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tmfc_write(dev, OFFSETA(buf_addr), S5P_FIMV_SI_CH0_SB_ST_ADR);\n\tmfc_write(dev, ctx->dec_src_buf_size, S5P_FIMV_SI_CH0_CPB_SIZE);\n\tmfc_write(dev, buf_size, S5P_FIMV_SI_CH0_SB_FRM_SIZE);\n\ts5p_mfc_write_info_v5(ctx, start_num_byte, START_BYTE_NUM);\n\treturn 0;\n}\n\n \nstatic int s5p_mfc_set_dec_frame_buffer_v5(struct s5p_mfc_ctx *ctx)\n{\n\tunsigned int frame_size_lu, i;\n\tunsigned int frame_size_ch, frame_size_mv;\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tunsigned int dpb;\n\tsize_t buf_addr1, buf_addr2;\n\tint buf_size1, buf_size2;\n\n\tbuf_addr1 = ctx->bank1.dma;\n\tbuf_size1 = ctx->bank1.size;\n\tbuf_addr2 = ctx->bank2.dma;\n\tbuf_size2 = ctx->bank2.size;\n\tdpb = mfc_read(dev, S5P_FIMV_SI_CH0_DPB_CONF_CTRL) &\n\t\t\t\t\t\t~S5P_FIMV_DPB_COUNT_MASK;\n\tmfc_write(dev, ctx->total_dpb_count | dpb,\n\t\t\t\t\t\tS5P_FIMV_SI_CH0_DPB_CONF_CTRL);\n\ts5p_mfc_set_shared_buffer(ctx);\n\tswitch (ctx->codec_mode) {\n\tcase S5P_MFC_CODEC_H264_DEC:\n\t\tmfc_write(dev, OFFSETA(buf_addr1),\n\t\t\t\t\t\tS5P_FIMV_H264_VERT_NB_MV_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_VERT_NB_MV_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_VERT_NB_MV_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H264_NB_IP_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_NB_IP_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_NB_IP_SIZE;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG4_DEC:\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_NB_DCAC_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_NB_DCAC_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_NB_DCAC_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_UP_NB_MV_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_UPNB_MV_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_UPNB_MV_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_SA_MV_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_SP_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_STX_PARSER_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_STX_PARSER_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_OT_LINE_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_H263_DEC:\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_OT_LINE_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_UP_NB_MV_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_UPNB_MV_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_UPNB_MV_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_SA_MV_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_NB_DCAC_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_NB_DCAC_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_NB_DCAC_SIZE;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_VC1_DEC:\n\tcase S5P_MFC_CODEC_VC1RCV_DEC:\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_NB_DCAC_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_NB_DCAC_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_NB_DCAC_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_OT_LINE_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_UP_NB_MV_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_UPNB_MV_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_UPNB_MV_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_SA_MV_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_BITPLANE3_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_BITPLANE2_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_BITPLANE1_ADR);\n\t\tbuf_addr1 += S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG2_DEC:\n\t\tbreak;\n\tdefault:\n\t\tmfc_err(\"Unknown codec for decoding (%x)\\n\",\n\t\t\tctx->codec_mode);\n\t\treturn -EINVAL;\n\t}\n\tframe_size_lu = ctx->luma_size;\n\tframe_size_ch = ctx->chroma_size;\n\tframe_size_mv = ctx->mv_size;\n\tmfc_debug(2, \"Frm size: %d ch: %d mv: %d\\n\", frame_size_lu, frame_size_ch,\n\t\t\t\t\t\t\t\tframe_size_mv);\n\tfor (i = 0; i < ctx->total_dpb_count; i++) {\n\t\t \n\t\tmfc_debug(2, \"Luma %d: %zx\\n\", i,\n\t\t\t\t\tctx->dst_bufs[i].cookie.raw.luma);\n\t\tmfc_write(dev, OFFSETB(ctx->dst_bufs[i].cookie.raw.luma),\n\t\t\t\t\t\tS5P_FIMV_DEC_LUMA_ADR + i * 4);\n\t\tmfc_debug(2, \"\\tChroma %d: %zx\\n\", i,\n\t\t\t\t\tctx->dst_bufs[i].cookie.raw.chroma);\n\t\tmfc_write(dev, OFFSETA(ctx->dst_bufs[i].cookie.raw.chroma),\n\t\t\t\t\t       S5P_FIMV_DEC_CHROMA_ADR + i * 4);\n\t\tif (ctx->codec_mode == S5P_MFC_CODEC_H264_DEC) {\n\t\t\tmfc_debug(2, \"\\tBuf2: %zx, size: %d\\n\",\n\t\t\t\t\t\t\tbuf_addr2, buf_size2);\n\t\t\tmfc_write(dev, OFFSETB(buf_addr2),\n\t\t\t\t\t\tS5P_FIMV_H264_MV_ADR + i * 4);\n\t\t\tbuf_addr2 += frame_size_mv;\n\t\t\tbuf_size2 -= frame_size_mv;\n\t\t}\n\t}\n\tmfc_debug(2, \"Buf1: %zu, buf_size1: %d\\n\", buf_addr1, buf_size1);\n\tmfc_debug(2, \"Buf 1/2 size after: %d/%d (frames %d)\\n\",\n\t\t\tbuf_size1,  buf_size2, ctx->total_dpb_count);\n\tif (buf_size1 < 0 || buf_size2 < 0) {\n\t\tmfc_debug(2, \"Not enough memory has been allocated\\n\");\n\t\treturn -ENOMEM;\n\t}\n\ts5p_mfc_write_info_v5(ctx, frame_size_lu, ALLOC_LUMA_DPB_SIZE);\n\ts5p_mfc_write_info_v5(ctx, frame_size_ch, ALLOC_CHROMA_DPB_SIZE);\n\tif (ctx->codec_mode == S5P_MFC_CODEC_H264_DEC)\n\t\ts5p_mfc_write_info_v5(ctx, frame_size_mv, ALLOC_MV_SIZE);\n\tmfc_write(dev, ((S5P_FIMV_CH_INIT_BUFS & S5P_FIMV_CH_MASK)\n\t\t\t\t\t<< S5P_FIMV_CH_SHIFT) | (ctx->inst_no),\n\t\t\t\t\t\tS5P_FIMV_SI_CH0_INST_ID);\n\treturn 0;\n}\n\n \nstatic int s5p_mfc_set_enc_stream_buffer_v5(struct s5p_mfc_ctx *ctx,\n\t\tunsigned long addr, unsigned int size)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tmfc_write(dev, OFFSETA(addr), S5P_FIMV_ENC_SI_CH0_SB_ADR);\n\tmfc_write(dev, size, S5P_FIMV_ENC_SI_CH0_SB_SIZE);\n\treturn 0;\n}\n\nstatic void s5p_mfc_set_enc_frame_buffer_v5(struct s5p_mfc_ctx *ctx,\n\t\tunsigned long y_addr, unsigned long c_addr)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tmfc_write(dev, OFFSETB(y_addr), S5P_FIMV_ENC_SI_CH0_CUR_Y_ADR);\n\tmfc_write(dev, OFFSETB(c_addr), S5P_FIMV_ENC_SI_CH0_CUR_C_ADR);\n}\n\nstatic void s5p_mfc_get_enc_frame_buffer_v5(struct s5p_mfc_ctx *ctx,\n\t\tunsigned long *y_addr, unsigned long *c_addr)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\t*y_addr = dev->dma_base[BANK_R_CTX] +\n\t\t  (mfc_read(dev, S5P_FIMV_ENCODED_Y_ADDR) << MFC_OFFSET_SHIFT);\n\t*c_addr = dev->dma_base[BANK_R_CTX] +\n\t\t  (mfc_read(dev, S5P_FIMV_ENCODED_C_ADDR) << MFC_OFFSET_SHIFT);\n}\n\n \nstatic int s5p_mfc_set_enc_ref_buffer_v5(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tsize_t buf_addr1, buf_addr2;\n\tsize_t buf_size1, buf_size2;\n\tunsigned int enc_ref_y_size, enc_ref_c_size;\n\tunsigned int guard_width, guard_height;\n\tint i;\n\n\tbuf_addr1 = ctx->bank1.dma;\n\tbuf_size1 = ctx->bank1.size;\n\tbuf_addr2 = ctx->bank2.dma;\n\tbuf_size2 = ctx->bank2.size;\n\tenc_ref_y_size = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\n\t\t* ALIGN(ctx->img_height, S5P_FIMV_NV12MT_VALIGN);\n\tenc_ref_y_size = ALIGN(enc_ref_y_size, S5P_FIMV_NV12MT_SALIGN);\n\tif (ctx->codec_mode == S5P_MFC_CODEC_H264_ENC) {\n\t\tenc_ref_c_size = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\n\t\t\t* ALIGN((ctx->img_height >> 1), S5P_FIMV_NV12MT_VALIGN);\n\t\tenc_ref_c_size = ALIGN(enc_ref_c_size, S5P_FIMV_NV12MT_SALIGN);\n\t} else {\n\t\tguard_width = ALIGN(ctx->img_width + 16,\n\t\t\t\t\t\tS5P_FIMV_NV12MT_HALIGN);\n\t\tguard_height = ALIGN((ctx->img_height >> 1) + 4,\n\t\t\t\t\t\tS5P_FIMV_NV12MT_VALIGN);\n\t\tenc_ref_c_size = ALIGN(guard_width * guard_height,\n\t\t\t\t       S5P_FIMV_NV12MT_SALIGN);\n\t}\n\tmfc_debug(2, \"buf_size1: %zu, buf_size2: %zu\\n\", buf_size1, buf_size2);\n\tswitch (ctx->codec_mode) {\n\tcase S5P_MFC_CODEC_H264_ENC:\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tmfc_write(dev, OFFSETA(buf_addr1),\n\t\t\t\tS5P_FIMV_ENC_REF0_LUMA_ADR + (4 * i));\n\t\t\tbuf_addr1 += enc_ref_y_size;\n\t\t\tbuf_size1 -= enc_ref_y_size;\n\n\t\t\tmfc_write(dev, OFFSETB(buf_addr2),\n\t\t\t\tS5P_FIMV_ENC_REF2_LUMA_ADR + (4 * i));\n\t\t\tbuf_addr2 += enc_ref_y_size;\n\t\t\tbuf_size2 -= enc_ref_y_size;\n\t\t}\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tmfc_write(dev, OFFSETB(buf_addr2),\n\t\t\t\tS5P_FIMV_ENC_REF0_CHROMA_ADR + (4 * i));\n\t\t\tbuf_addr2 += enc_ref_c_size;\n\t\t\tbuf_size2 -= enc_ref_c_size;\n\t\t}\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H264_UP_MV_ADR);\n\t\tbuf_addr1 += S5P_FIMV_ENC_UPMV_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_ENC_UPMV_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1),\n\t\t\t\t\tS5P_FIMV_H264_COZERO_FLAG_ADR);\n\t\tbuf_addr1 += S5P_FIMV_ENC_COLFLG_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_ENC_COLFLG_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1),\n\t\t\t\t\tS5P_FIMV_H264_UP_INTRA_MD_ADR);\n\t\tbuf_addr1 += S5P_FIMV_ENC_INTRAMD_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_ENC_INTRAMD_SIZE;\n\t\tmfc_write(dev, OFFSETB(buf_addr2),\n\t\t\t\t\tS5P_FIMV_H264_UP_INTRA_PRED_ADR);\n\t\tbuf_addr2 += S5P_FIMV_ENC_INTRAPRED_SIZE;\n\t\tbuf_size2 -= S5P_FIMV_ENC_INTRAPRED_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1),\n\t\t\t\t\tS5P_FIMV_H264_NBOR_INFO_ADR);\n\t\tbuf_addr1 += S5P_FIMV_ENC_NBORINFO_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_ENC_NBORINFO_SIZE;\n\t\tmfc_debug(2, \"buf_size1: %zu, buf_size2: %zu\\n\",\n\t\t\tbuf_size1, buf_size2);\n\t\tbreak;\n\tcase S5P_MFC_CODEC_MPEG4_ENC:\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tmfc_write(dev, OFFSETA(buf_addr1),\n\t\t\t\tS5P_FIMV_ENC_REF0_LUMA_ADR + (4 * i));\n\t\t\tbuf_addr1 += enc_ref_y_size;\n\t\t\tbuf_size1 -= enc_ref_y_size;\n\t\t\tmfc_write(dev, OFFSETB(buf_addr2),\n\t\t\t\tS5P_FIMV_ENC_REF2_LUMA_ADR + (4 * i));\n\t\t\tbuf_addr2 += enc_ref_y_size;\n\t\t\tbuf_size2 -= enc_ref_y_size;\n\t\t}\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tmfc_write(dev, OFFSETB(buf_addr2),\n\t\t\t\tS5P_FIMV_ENC_REF0_CHROMA_ADR + (4 * i));\n\t\t\tbuf_addr2 += enc_ref_c_size;\n\t\t\tbuf_size2 -= enc_ref_c_size;\n\t\t}\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_UP_MV_ADR);\n\t\tbuf_addr1 += S5P_FIMV_ENC_UPMV_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_ENC_UPMV_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1),\n\t\t\t\t\t\tS5P_FIMV_MPEG4_COZERO_FLAG_ADR);\n\t\tbuf_addr1 += S5P_FIMV_ENC_COLFLG_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_ENC_COLFLG_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1),\n\t\t\t\t\t\tS5P_FIMV_MPEG4_ACDC_COEF_ADR);\n\t\tbuf_addr1 += S5P_FIMV_ENC_ACDCCOEF_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_ENC_ACDCCOEF_SIZE;\n\t\tmfc_debug(2, \"buf_size1: %zu, buf_size2: %zu\\n\",\n\t\t\tbuf_size1, buf_size2);\n\t\tbreak;\n\tcase S5P_MFC_CODEC_H263_ENC:\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tmfc_write(dev, OFFSETA(buf_addr1),\n\t\t\t\tS5P_FIMV_ENC_REF0_LUMA_ADR + (4 * i));\n\t\t\tbuf_addr1 += enc_ref_y_size;\n\t\t\tbuf_size1 -= enc_ref_y_size;\n\t\t\tmfc_write(dev, OFFSETB(buf_addr2),\n\t\t\t\tS5P_FIMV_ENC_REF2_LUMA_ADR + (4 * i));\n\t\t\tbuf_addr2 += enc_ref_y_size;\n\t\t\tbuf_size2 -= enc_ref_y_size;\n\t\t}\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tmfc_write(dev, OFFSETB(buf_addr2),\n\t\t\t\tS5P_FIMV_ENC_REF0_CHROMA_ADR + (4 * i));\n\t\t\tbuf_addr2 += enc_ref_c_size;\n\t\t\tbuf_size2 -= enc_ref_c_size;\n\t\t}\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_UP_MV_ADR);\n\t\tbuf_addr1 += S5P_FIMV_ENC_UPMV_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_ENC_UPMV_SIZE;\n\t\tmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_ACDC_COEF_ADR);\n\t\tbuf_addr1 += S5P_FIMV_ENC_ACDCCOEF_SIZE;\n\t\tbuf_size1 -= S5P_FIMV_ENC_ACDCCOEF_SIZE;\n\t\tmfc_debug(2, \"buf_size1: %zu, buf_size2: %zu\\n\",\n\t\t\tbuf_size1, buf_size2);\n\t\tbreak;\n\tdefault:\n\t\tmfc_err(\"Unknown codec set for encoding: %d\\n\",\n\t\t\tctx->codec_mode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int s5p_mfc_set_enc_params(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tunsigned int reg;\n\tunsigned int shm;\n\n\t \n\tmfc_write(dev, ctx->img_width, S5P_FIMV_ENC_HSIZE_PX);\n\t \n\tmfc_write(dev, ctx->img_height, S5P_FIMV_ENC_VSIZE_PX);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_PIC_TYPE_CTRL);\n\treg |= (1 << 18);\n\treg &= ~(0xFFFF);\n\treg |= p->gop_size;\n\tmfc_write(dev, reg, S5P_FIMV_ENC_PIC_TYPE_CTRL);\n\tmfc_write(dev, 0, S5P_FIMV_ENC_B_RECON_WRITE_ON);\n\t \n\t \n\tmfc_write(dev, p->slice_mode, S5P_FIMV_ENC_MSLICE_CTRL);\n\tif (p->slice_mode == V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB) {\n\t\tmfc_write(dev, p->slice_mb, S5P_FIMV_ENC_MSLICE_MB);\n\t} else if (p->slice_mode == V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES) {\n\t\tmfc_write(dev, p->slice_bit, S5P_FIMV_ENC_MSLICE_BIT);\n\t} else {\n\t\tmfc_write(dev, 0, S5P_FIMV_ENC_MSLICE_MB);\n\t\tmfc_write(dev, 0, S5P_FIMV_ENC_MSLICE_BIT);\n\t}\n\t \n\tmfc_write(dev, p->intra_refresh_mb, S5P_FIMV_ENC_CIR_CTRL);\n\t \n\tif (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12M)\n\t\tmfc_write(dev, 0, S5P_FIMV_ENC_MAP_FOR_CUR);\n\telse if (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12MT)\n\t\tmfc_write(dev, 3, S5P_FIMV_ENC_MAP_FOR_CUR);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_PADDING_CTRL);\n\tif (p->pad) {\n\t\t \n\t\treg |= (1UL << 31);\n\t\t \n\t\treg &= ~(0xFF << 16);\n\t\treg |= (p->pad_cr << 16);\n\t\t \n\t\treg &= ~(0xFF << 8);\n\t\treg |= (p->pad_cb << 8);\n\t\t \n\t\treg &= ~(0xFF);\n\t\treg |= (p->pad_luma);\n\t} else {\n\t\t \n\t\treg = 0;\n\t}\n\tmfc_write(dev, reg, S5P_FIMV_ENC_PADDING_CTRL);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_RC_CONFIG);\n\t \n\treg &= ~(0x1 << 9);\n\treg |= (p->rc_frame << 9);\n\tmfc_write(dev, reg, S5P_FIMV_ENC_RC_CONFIG);\n\t \n\tif (p->rc_frame)\n\t\tmfc_write(dev, p->rc_bitrate,\n\t\t\tS5P_FIMV_ENC_RC_BIT_RATE);\n\telse\n\t\tmfc_write(dev, 0, S5P_FIMV_ENC_RC_BIT_RATE);\n\t \n\tif (p->rc_frame)\n\t\tmfc_write(dev, p->rc_reaction_coeff, S5P_FIMV_ENC_RC_RPARA);\n\tshm = s5p_mfc_read_info_v5(ctx, EXT_ENC_CONTROL);\n\t \n\tshm &= ~(0x1 << 3);\n\tshm |= (p->seq_hdr_mode << 3);\n\t \n\tshm &= ~(0x3 << 1);\n\tshm |= (p->frame_skip_mode << 1);\n\ts5p_mfc_write_info_v5(ctx, shm, EXT_ENC_CONTROL);\n\t \n\ts5p_mfc_write_info_v5(ctx, p->fixed_target_bit, RC_CONTROL_CONFIG);\n\treturn 0;\n}\n\nstatic int s5p_mfc_set_enc_params_h264(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tstruct s5p_mfc_h264_enc_params *p_264 = &p->codec.h264;\n\tunsigned int reg;\n\tunsigned int shm;\n\n\ts5p_mfc_set_enc_params(ctx);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_PIC_TYPE_CTRL);\n\t \n\treg &= ~(0x3 << 16);\n\treg |= (p->num_b_frame << 16);\n\tmfc_write(dev, reg, S5P_FIMV_ENC_PIC_TYPE_CTRL);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_PROFILE);\n\t \n\treg &= ~(0xFF << 8);\n\treg |= (p_264->level << 8);\n\t \n\treg &= ~(0x3F);\n\treg |= p_264->profile;\n\tmfc_write(dev, reg, S5P_FIMV_ENC_PROFILE);\n\t \n\tmfc_write(dev, p_264->interlace, S5P_FIMV_ENC_PIC_STRUCT);\n\t \n\tif (p_264->interlace)\n\t\tmfc_write(dev, ctx->img_height >> 1, S5P_FIMV_ENC_VSIZE_PX);\n\t \n\tmfc_write(dev, p_264->loop_filter_mode, S5P_FIMV_ENC_LF_CTRL);\n\t \n\tif (p_264->loop_filter_alpha < 0) {\n\t\treg = 0x10;\n\t\treg |= (0xFF - p_264->loop_filter_alpha) + 1;\n\t} else {\n\t\treg = 0x00;\n\t\treg |= (p_264->loop_filter_alpha & 0xF);\n\t}\n\tmfc_write(dev, reg, S5P_FIMV_ENC_ALPHA_OFF);\n\t \n\tif (p_264->loop_filter_beta < 0) {\n\t\treg = 0x10;\n\t\treg |= (0xFF - p_264->loop_filter_beta) + 1;\n\t} else {\n\t\treg = 0x00;\n\t\treg |= (p_264->loop_filter_beta & 0xF);\n\t}\n\tmfc_write(dev, reg, S5P_FIMV_ENC_BETA_OFF);\n\t \n\tif (p_264->entropy_mode == V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC)\n\t\tmfc_write(dev, 1, S5P_FIMV_ENC_H264_ENTROPY_MODE);\n\telse\n\t\tmfc_write(dev, 0, S5P_FIMV_ENC_H264_ENTROPY_MODE);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_H264_NUM_OF_REF);\n\t \n\treg &= ~(0x3 << 5);\n\treg |= (p_264->num_ref_pic_4p << 5);\n\t \n\treg &= ~(0x1F);\n\treg |= p_264->max_ref_pic;\n\tmfc_write(dev, reg, S5P_FIMV_ENC_H264_NUM_OF_REF);\n\t \n\tmfc_write(dev, p_264->_8x8_transform, S5P_FIMV_ENC_H264_TRANS_FLAG);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_RC_CONFIG);\n\t \n\treg &= ~(0x1 << 8);\n\treg |= (p->rc_mb << 8);\n\t \n\treg &= ~(0x3F);\n\treg |= p_264->rc_frame_qp;\n\tmfc_write(dev, reg, S5P_FIMV_ENC_RC_CONFIG);\n\t \n\tif (p->rc_frame && p->rc_framerate_denom)\n\t\tmfc_write(dev, p->rc_framerate_num * 1000\n\t\t\t/ p->rc_framerate_denom, S5P_FIMV_ENC_RC_FRAME_RATE);\n\telse\n\t\tmfc_write(dev, 0, S5P_FIMV_ENC_RC_FRAME_RATE);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_RC_QBOUND);\n\t \n\treg &= ~(0x3F << 8);\n\treg |= (p_264->rc_max_qp << 8);\n\t \n\treg &= ~(0x3F);\n\treg |= p_264->rc_min_qp;\n\tmfc_write(dev, reg, S5P_FIMV_ENC_RC_QBOUND);\n\t \n\tif (p->rc_mb) {\n\t\treg = mfc_read(dev, S5P_FIMV_ENC_RC_MB_CTRL);\n\t\t \n\t\treg &= ~(0x1 << 3);\n\t\treg |= (p_264->rc_mb_dark << 3);\n\t\t \n\t\treg &= ~(0x1 << 2);\n\t\treg |= (p_264->rc_mb_smooth << 2);\n\t\t \n\t\treg &= ~(0x1 << 1);\n\t\treg |= (p_264->rc_mb_static << 1);\n\t\t \n\t\treg &= ~(0x1);\n\t\treg |= p_264->rc_mb_activity;\n\t\tmfc_write(dev, reg, S5P_FIMV_ENC_RC_MB_CTRL);\n\t}\n\tif (!p->rc_frame && !p->rc_mb) {\n\t\tshm = s5p_mfc_read_info_v5(ctx, P_B_FRAME_QP);\n\t\tshm &= ~(0xFFF);\n\t\tshm |= ((p_264->rc_b_frame_qp & 0x3F) << 6);\n\t\tshm |= (p_264->rc_p_frame_qp & 0x3F);\n\t\ts5p_mfc_write_info_v5(ctx, shm, P_B_FRAME_QP);\n\t}\n\t \n\tshm = s5p_mfc_read_info_v5(ctx, EXT_ENC_CONTROL);\n\t \n\tshm &= ~(0x1 << 15);\n\tshm |= (p_264->vui_sar << 1);\n\ts5p_mfc_write_info_v5(ctx, shm, EXT_ENC_CONTROL);\n\tif (p_264->vui_sar) {\n\t\t \n\t\tshm = s5p_mfc_read_info_v5(ctx, SAMPLE_ASPECT_RATIO_IDC);\n\t\tshm &= ~(0xFF);\n\t\tshm |= p_264->vui_sar_idc;\n\t\ts5p_mfc_write_info_v5(ctx, shm, SAMPLE_ASPECT_RATIO_IDC);\n\t\tif (p_264->vui_sar_idc == 0xFF) {\n\t\t\t \n\t\t\tshm = s5p_mfc_read_info_v5(ctx, EXTENDED_SAR);\n\t\t\tshm &= ~(0xFFFFFFFF);\n\t\t\tshm |= p_264->vui_ext_sar_width << 16;\n\t\t\tshm |= p_264->vui_ext_sar_height;\n\t\t\ts5p_mfc_write_info_v5(ctx, shm, EXTENDED_SAR);\n\t\t}\n\t}\n\t \n\tshm = s5p_mfc_read_info_v5(ctx, H264_I_PERIOD);\n\t \n\tshm &= ~(0x1 << 16);\n\tshm |= (p_264->open_gop << 16);\n\t \n\tif (p_264->open_gop) {\n\t\tshm &= ~(0xFFFF);\n\t\tshm |= p_264->open_gop_size;\n\t}\n\ts5p_mfc_write_info_v5(ctx, shm, H264_I_PERIOD);\n\t \n\tshm = s5p_mfc_read_info_v5(ctx, EXT_ENC_CONTROL);\n\t \n\tif (p->frame_skip_mode ==\n\t\t\tV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\n\t\tshm &= ~(0xFFFF << 16);\n\t\tshm |= (p_264->cpb_size << 16);\n\t}\n\ts5p_mfc_write_info_v5(ctx, shm, EXT_ENC_CONTROL);\n\treturn 0;\n}\n\nstatic int s5p_mfc_set_enc_params_mpeg4(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tstruct s5p_mfc_mpeg4_enc_params *p_mpeg4 = &p->codec.mpeg4;\n\tunsigned int reg;\n\tunsigned int shm;\n\tunsigned int framerate;\n\n\ts5p_mfc_set_enc_params(ctx);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_PIC_TYPE_CTRL);\n\t \n\treg &= ~(0x3 << 16);\n\treg |= (p->num_b_frame << 16);\n\tmfc_write(dev, reg, S5P_FIMV_ENC_PIC_TYPE_CTRL);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_PROFILE);\n\t \n\treg &= ~(0xFF << 8);\n\treg |= (p_mpeg4->level << 8);\n\t \n\treg &= ~(0x3F);\n\treg |= p_mpeg4->profile;\n\tmfc_write(dev, reg, S5P_FIMV_ENC_PROFILE);\n\t \n\tmfc_write(dev, p_mpeg4->quarter_pixel, S5P_FIMV_ENC_MPEG4_QUART_PXL);\n\t \n\tif (!p->rc_frame) {\n\t\tshm = s5p_mfc_read_info_v5(ctx, P_B_FRAME_QP);\n\t\tshm &= ~(0xFFF);\n\t\tshm |= ((p_mpeg4->rc_b_frame_qp & 0x3F) << 6);\n\t\tshm |= (p_mpeg4->rc_p_frame_qp & 0x3F);\n\t\ts5p_mfc_write_info_v5(ctx, shm, P_B_FRAME_QP);\n\t}\n\t \n\tif (p->rc_frame) {\n\t\tif (p->rc_framerate_denom > 0) {\n\t\t\tframerate = p->rc_framerate_num * 1000 /\n\t\t\t\t\t\tp->rc_framerate_denom;\n\t\t\tmfc_write(dev, framerate,\n\t\t\t\tS5P_FIMV_ENC_RC_FRAME_RATE);\n\t\t\tshm = s5p_mfc_read_info_v5(ctx, RC_VOP_TIMING);\n\t\t\tshm &= ~(0xFFFFFFFF);\n\t\t\tshm |= (1UL << 31);\n\t\t\tshm |= ((p->rc_framerate_num & 0x7FFF) << 16);\n\t\t\tshm |= (p->rc_framerate_denom & 0xFFFF);\n\t\t\ts5p_mfc_write_info_v5(ctx, shm, RC_VOP_TIMING);\n\t\t}\n\t} else {\n\t\tmfc_write(dev, 0, S5P_FIMV_ENC_RC_FRAME_RATE);\n\t}\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_RC_CONFIG);\n\t \n\treg &= ~(0x3F);\n\treg |= p_mpeg4->rc_frame_qp;\n\tmfc_write(dev, reg, S5P_FIMV_ENC_RC_CONFIG);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_RC_QBOUND);\n\t \n\treg &= ~(0x3F << 8);\n\treg |= (p_mpeg4->rc_max_qp << 8);\n\t \n\treg &= ~(0x3F);\n\treg |= p_mpeg4->rc_min_qp;\n\tmfc_write(dev, reg, S5P_FIMV_ENC_RC_QBOUND);\n\t \n\tshm = s5p_mfc_read_info_v5(ctx, EXT_ENC_CONTROL);\n\t \n\tif (p->frame_skip_mode ==\n\t\t\tV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\n\t\tshm &= ~(0xFFFF << 16);\n\t\tshm |= (p->vbv_size << 16);\n\t}\n\ts5p_mfc_write_info_v5(ctx, shm, EXT_ENC_CONTROL);\n\treturn 0;\n}\n\nstatic int s5p_mfc_set_enc_params_h263(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_enc_params *p = &ctx->enc_params;\n\tstruct s5p_mfc_mpeg4_enc_params *p_h263 = &p->codec.mpeg4;\n\tunsigned int reg;\n\tunsigned int shm;\n\n\ts5p_mfc_set_enc_params(ctx);\n\t \n\tif (!p->rc_frame) {\n\t\tshm = s5p_mfc_read_info_v5(ctx, P_B_FRAME_QP);\n\t\tshm &= ~(0xFFF);\n\t\tshm |= (p_h263->rc_p_frame_qp & 0x3F);\n\t\ts5p_mfc_write_info_v5(ctx, shm, P_B_FRAME_QP);\n\t}\n\t \n\tif (p->rc_frame && p->rc_framerate_denom)\n\t\tmfc_write(dev, p->rc_framerate_num * 1000\n\t\t\t/ p->rc_framerate_denom, S5P_FIMV_ENC_RC_FRAME_RATE);\n\telse\n\t\tmfc_write(dev, 0, S5P_FIMV_ENC_RC_FRAME_RATE);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_RC_CONFIG);\n\t \n\treg &= ~(0x3F);\n\treg |= p_h263->rc_frame_qp;\n\tmfc_write(dev, reg, S5P_FIMV_ENC_RC_CONFIG);\n\t \n\treg = mfc_read(dev, S5P_FIMV_ENC_RC_QBOUND);\n\t \n\treg &= ~(0x3F << 8);\n\treg |= (p_h263->rc_max_qp << 8);\n\t \n\treg &= ~(0x3F);\n\treg |= p_h263->rc_min_qp;\n\tmfc_write(dev, reg, S5P_FIMV_ENC_RC_QBOUND);\n\t \n\tshm = s5p_mfc_read_info_v5(ctx, EXT_ENC_CONTROL);\n\t \n\tif (p->frame_skip_mode ==\n\t\t\tV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\n\t\tshm &= ~(0xFFFF << 16);\n\t\tshm |= (p->vbv_size << 16);\n\t}\n\ts5p_mfc_write_info_v5(ctx, shm, EXT_ENC_CONTROL);\n\treturn 0;\n}\n\n \nstatic int s5p_mfc_init_decode_v5(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\ts5p_mfc_set_shared_buffer(ctx);\n\t \n\tif (ctx->codec_mode == S5P_MFC_CODEC_MPEG4_DEC)\n\t\tmfc_write(dev, ctx->loop_filter_mpeg4, S5P_FIMV_ENC_LF_CTRL);\n\telse\n\t\tmfc_write(dev, 0, S5P_FIMV_ENC_LF_CTRL);\n\tmfc_write(dev, ((ctx->slice_interface & S5P_FIMV_SLICE_INT_MASK) <<\n\t\tS5P_FIMV_SLICE_INT_SHIFT) | (ctx->display_delay_enable <<\n\t\tS5P_FIMV_DDELAY_ENA_SHIFT) | ((ctx->display_delay &\n\t\tS5P_FIMV_DDELAY_VAL_MASK) << S5P_FIMV_DDELAY_VAL_SHIFT),\n\t\tS5P_FIMV_SI_CH0_DPB_CONF_CTRL);\n\tmfc_write(dev,\n\t((S5P_FIMV_CH_SEQ_HEADER & S5P_FIMV_CH_MASK) << S5P_FIMV_CH_SHIFT)\n\t\t\t\t| (ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\n\treturn 0;\n}\n\nstatic void s5p_mfc_set_flush(struct s5p_mfc_ctx *ctx, int flush)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tunsigned int dpb;\n\n\tif (flush)\n\t\tdpb = mfc_read(dev, S5P_FIMV_SI_CH0_DPB_CONF_CTRL) | (\n\t\t\tS5P_FIMV_DPB_FLUSH_MASK << S5P_FIMV_DPB_FLUSH_SHIFT);\n\telse\n\t\tdpb = mfc_read(dev, S5P_FIMV_SI_CH0_DPB_CONF_CTRL) &\n\t\t\t~(S5P_FIMV_DPB_FLUSH_MASK << S5P_FIMV_DPB_FLUSH_SHIFT);\n\tmfc_write(dev, dpb, S5P_FIMV_SI_CH0_DPB_CONF_CTRL);\n}\n\n \nstatic int s5p_mfc_decode_one_frame_v5(struct s5p_mfc_ctx *ctx,\n\t\t\t\t\tenum s5p_mfc_decode_arg last_frame)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tmfc_write(dev, ctx->dec_dst_flag, S5P_FIMV_SI_CH0_RELEASE_BUF);\n\ts5p_mfc_set_shared_buffer(ctx);\n\ts5p_mfc_set_flush(ctx, ctx->dpb_flush_flag);\n\t \n\tswitch (last_frame) {\n\tcase MFC_DEC_FRAME:\n\t\tmfc_write(dev, ((S5P_FIMV_CH_FRAME_START & S5P_FIMV_CH_MASK) <<\n\t\tS5P_FIMV_CH_SHIFT) | (ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\n\t\tbreak;\n\tcase MFC_DEC_LAST_FRAME:\n\t\tmfc_write(dev, ((S5P_FIMV_CH_LAST_FRAME & S5P_FIMV_CH_MASK) <<\n\t\tS5P_FIMV_CH_SHIFT) | (ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\n\t\tbreak;\n\tcase MFC_DEC_RES_CHANGE:\n\t\tmfc_write(dev, ((S5P_FIMV_CH_FRAME_START_REALLOC &\n\t\tS5P_FIMV_CH_MASK) << S5P_FIMV_CH_SHIFT) | (ctx->inst_no),\n\t\tS5P_FIMV_SI_CH0_INST_ID);\n\t\tbreak;\n\t}\n\tmfc_debug(2, \"Decoding a usual frame\\n\");\n\treturn 0;\n}\n\nstatic int s5p_mfc_init_encode_v5(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\tif (ctx->codec_mode == S5P_MFC_CODEC_H264_ENC)\n\t\ts5p_mfc_set_enc_params_h264(ctx);\n\telse if (ctx->codec_mode == S5P_MFC_CODEC_MPEG4_ENC)\n\t\ts5p_mfc_set_enc_params_mpeg4(ctx);\n\telse if (ctx->codec_mode == S5P_MFC_CODEC_H263_ENC)\n\t\ts5p_mfc_set_enc_params_h263(ctx);\n\telse {\n\t\tmfc_err(\"Unknown codec for encoding (%x)\\n\",\n\t\t\tctx->codec_mode);\n\t\treturn -EINVAL;\n\t}\n\ts5p_mfc_set_shared_buffer(ctx);\n\tmfc_write(dev, ((S5P_FIMV_CH_SEQ_HEADER << 16) & 0x70000) |\n\t\t(ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\n\treturn 0;\n}\n\n \nstatic int s5p_mfc_encode_one_frame_v5(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tint cmd;\n\t \n\tif (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12M)\n\t\tmfc_write(dev, 0, S5P_FIMV_ENC_MAP_FOR_CUR);\n\telse if (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12MT)\n\t\tmfc_write(dev, 3, S5P_FIMV_ENC_MAP_FOR_CUR);\n\ts5p_mfc_set_shared_buffer(ctx);\n\n\tif (ctx->state == MFCINST_FINISHING)\n\t\tcmd = S5P_FIMV_CH_LAST_FRAME;\n\telse\n\t\tcmd = S5P_FIMV_CH_FRAME_START;\n\tmfc_write(dev, ((cmd & S5P_FIMV_CH_MASK) << S5P_FIMV_CH_SHIFT)\n\t\t\t\t| (ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\n\n\treturn 0;\n}\n\nstatic void s5p_mfc_run_res_change(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\n\ts5p_mfc_set_dec_stream_buffer_v5(ctx, 0, 0, 0);\n\tdev->curr_ctx = ctx->num;\n\ts5p_mfc_decode_one_frame_v5(ctx, MFC_DEC_RES_CHANGE);\n}\n\nstatic int s5p_mfc_run_dec_frame(struct s5p_mfc_ctx *ctx, int last_frame)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *temp_vb;\n\n\tif (ctx->state == MFCINST_FINISHING) {\n\t\tlast_frame = MFC_DEC_LAST_FRAME;\n\t\ts5p_mfc_set_dec_stream_buffer_v5(ctx, 0, 0, 0);\n\t\tdev->curr_ctx = ctx->num;\n\t\ts5p_mfc_decode_one_frame_v5(ctx, last_frame);\n\t\treturn 0;\n\t}\n\n\t \n\tif (list_empty(&ctx->src_queue)) {\n\t\tmfc_debug(2, \"No src buffers\\n\");\n\t\treturn -EAGAIN;\n\t}\n\t \n\ttemp_vb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\n\ttemp_vb->flags |= MFC_BUF_FLAG_USED;\n\ts5p_mfc_set_dec_stream_buffer_v5(ctx,\n\t\tvb2_dma_contig_plane_dma_addr(&temp_vb->b->vb2_buf, 0),\n\t\tctx->consumed_stream, temp_vb->b->vb2_buf.planes[0].bytesused);\n\tdev->curr_ctx = ctx->num;\n\tif (temp_vb->b->vb2_buf.planes[0].bytesused == 0) {\n\t\tlast_frame = MFC_DEC_LAST_FRAME;\n\t\tmfc_debug(2, \"Setting ctx->state to FINISHING\\n\");\n\t\tctx->state = MFCINST_FINISHING;\n\t}\n\ts5p_mfc_decode_one_frame_v5(ctx, last_frame);\n\treturn 0;\n}\n\nstatic int s5p_mfc_run_enc_frame(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *dst_mb;\n\tstruct s5p_mfc_buf *src_mb;\n\tunsigned long src_y_addr, src_c_addr, dst_addr;\n\tunsigned int dst_size;\n\n\tif (list_empty(&ctx->src_queue) && ctx->state != MFCINST_FINISHING) {\n\t\tmfc_debug(2, \"no src buffers\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tif (list_empty(&ctx->dst_queue)) {\n\t\tmfc_debug(2, \"no dst buffers\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tif (list_empty(&ctx->src_queue)) {\n\t\t \n\t\ts5p_mfc_set_enc_frame_buffer_v5(ctx, dev->dma_base[BANK_R_CTX],\n\t\t\t\t\t\tdev->dma_base[BANK_R_CTX]);\n\t\tsrc_mb = NULL;\n\t} else {\n\t\tsrc_mb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf,\n\t\t\t\t\t\t\t\t\tlist);\n\t\tsrc_mb->flags |= MFC_BUF_FLAG_USED;\n\t\tif (src_mb->b->vb2_buf.planes[0].bytesused == 0) {\n\t\t\t \n\t\t\ts5p_mfc_set_enc_frame_buffer_v5(ctx,\n\t\t\t\t\t\tdev->dma_base[BANK_R_CTX],\n\t\t\t\t\t\tdev->dma_base[BANK_R_CTX]);\n\t\t\tctx->state = MFCINST_FINISHING;\n\t\t} else {\n\t\t\tsrc_y_addr = vb2_dma_contig_plane_dma_addr(\n\t\t\t\t\t&src_mb->b->vb2_buf, 0);\n\t\t\tsrc_c_addr = vb2_dma_contig_plane_dma_addr(\n\t\t\t\t\t&src_mb->b->vb2_buf, 1);\n\t\t\ts5p_mfc_set_enc_frame_buffer_v5(ctx, src_y_addr,\n\t\t\t\t\t\t\t\tsrc_c_addr);\n\t\t\tif (src_mb->flags & MFC_BUF_FLAG_EOS)\n\t\t\t\tctx->state = MFCINST_FINISHING;\n\t\t}\n\t}\n\tdst_mb = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf, list);\n\tdst_mb->flags |= MFC_BUF_FLAG_USED;\n\tdst_addr = vb2_dma_contig_plane_dma_addr(&dst_mb->b->vb2_buf, 0);\n\tdst_size = vb2_plane_size(&dst_mb->b->vb2_buf, 0);\n\ts5p_mfc_set_enc_stream_buffer_v5(ctx, dst_addr, dst_size);\n\tdev->curr_ctx = ctx->num;\n\tmfc_debug(2, \"encoding buffer with index=%d state=%d\\n\",\n\t\t  src_mb ? src_mb->b->vb2_buf.index : -1, ctx->state);\n\ts5p_mfc_encode_one_frame_v5(ctx);\n\treturn 0;\n}\n\nstatic void s5p_mfc_run_init_dec(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *temp_vb;\n\n\t \n\tmfc_debug(2, \"Preparing to init decoding\\n\");\n\ttemp_vb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\n\ts5p_mfc_set_dec_desc_buffer(ctx);\n\tmfc_debug(2, \"Header size: %d\\n\",\n\t\t\ttemp_vb->b->vb2_buf.planes[0].bytesused);\n\ts5p_mfc_set_dec_stream_buffer_v5(ctx,\n\t\t\tvb2_dma_contig_plane_dma_addr(&temp_vb->b->vb2_buf, 0),\n\t\t\t0, temp_vb->b->vb2_buf.planes[0].bytesused);\n\tdev->curr_ctx = ctx->num;\n\ts5p_mfc_init_decode_v5(ctx);\n}\n\nstatic void s5p_mfc_run_init_enc(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *dst_mb;\n\tunsigned long dst_addr;\n\tunsigned int dst_size;\n\n\ts5p_mfc_set_enc_ref_buffer_v5(ctx);\n\tdst_mb = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf, list);\n\tdst_addr = vb2_dma_contig_plane_dma_addr(&dst_mb->b->vb2_buf, 0);\n\tdst_size = vb2_plane_size(&dst_mb->b->vb2_buf, 0);\n\ts5p_mfc_set_enc_stream_buffer_v5(ctx, dst_addr, dst_size);\n\tdev->curr_ctx = ctx->num;\n\ts5p_mfc_init_encode_v5(ctx);\n}\n\nstatic int s5p_mfc_run_init_dec_buffers(struct s5p_mfc_ctx *ctx)\n{\n\tstruct s5p_mfc_dev *dev = ctx->dev;\n\tstruct s5p_mfc_buf *temp_vb;\n\tint ret;\n\n\t \n\tif (ctx->capture_state != QUEUE_BUFS_MMAPED) {\n\t\tmfc_err(\"It seems that not all destination buffers were mmapped\\nMFC requires that all destination are mmapped before starting processing\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tif (list_empty(&ctx->src_queue)) {\n\t\tmfc_err(\"Header has been deallocated in the middle of initialization\\n\");\n\t\treturn -EIO;\n\t}\n\ttemp_vb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\n\tmfc_debug(2, \"Header size: %d\\n\",\n\t\t\ttemp_vb->b->vb2_buf.planes[0].bytesused);\n\ts5p_mfc_set_dec_stream_buffer_v5(ctx,\n\t\t\tvb2_dma_contig_plane_dma_addr(&temp_vb->b->vb2_buf, 0),\n\t\t\t0, temp_vb->b->vb2_buf.planes[0].bytesused);\n\tdev->curr_ctx = ctx->num;\n\tret = s5p_mfc_set_dec_frame_buffer_v5(ctx);\n\tif (ret) {\n\t\tmfc_err(\"Failed to alloc frame mem\\n\");\n\t\tctx->state = MFCINST_ERROR;\n\t}\n\treturn ret;\n}\n\n \nstatic void s5p_mfc_try_run_v5(struct s5p_mfc_dev *dev)\n{\n\tstruct s5p_mfc_ctx *ctx;\n\tint new_ctx;\n\tunsigned int ret = 0;\n\n\tif (test_bit(0, &dev->enter_suspend)) {\n\t\tmfc_debug(1, \"Entering suspend so do not schedule any jobs\\n\");\n\t\treturn;\n\t}\n\t \n\tif (test_and_set_bit(0, &dev->hw_lock) != 0) {\n\t\t \n\t\tmfc_debug(1, \"Couldn't lock HW\\n\");\n\t\treturn;\n\t}\n\t \n\tnew_ctx = s5p_mfc_get_new_ctx(dev);\n\tif (new_ctx < 0) {\n\t\t \n\t\tif (test_and_clear_bit(0, &dev->hw_lock) == 0) {\n\t\t\tmfc_err(\"Failed to unlock hardware\\n\");\n\t\t\treturn;\n\t\t}\n\t\tmfc_debug(1, \"No ctx is scheduled to be run\\n\");\n\t\treturn;\n\t}\n\tctx = dev->ctx[new_ctx];\n\t \n\t \n\ts5p_mfc_clock_on();\n\ts5p_mfc_clean_ctx_int_flags(ctx);\n\n\tif (ctx->type == MFCINST_DECODER) {\n\t\ts5p_mfc_set_dec_desc_buffer(ctx);\n\t\tswitch (ctx->state) {\n\t\tcase MFCINST_FINISHING:\n\t\t\ts5p_mfc_run_dec_frame(ctx, MFC_DEC_LAST_FRAME);\n\t\t\tbreak;\n\t\tcase MFCINST_RUNNING:\n\t\t\tret = s5p_mfc_run_dec_frame(ctx, MFC_DEC_FRAME);\n\t\t\tbreak;\n\t\tcase MFCINST_INIT:\n\t\t\tret = s5p_mfc_hw_call(dev->mfc_cmds, open_inst_cmd,\n\t\t\t\t\tctx);\n\t\t\tbreak;\n\t\tcase MFCINST_RETURN_INST:\n\t\t\tret = s5p_mfc_hw_call(dev->mfc_cmds, close_inst_cmd,\n\t\t\t\t\tctx);\n\t\t\tbreak;\n\t\tcase MFCINST_GOT_INST:\n\t\t\ts5p_mfc_run_init_dec(ctx);\n\t\t\tbreak;\n\t\tcase MFCINST_HEAD_PARSED:\n\t\t\tret = s5p_mfc_run_init_dec_buffers(ctx);\n\t\t\tmfc_debug(1, \"head parsed\\n\");\n\t\t\tbreak;\n\t\tcase MFCINST_RES_CHANGE_INIT:\n\t\t\ts5p_mfc_run_res_change(ctx);\n\t\t\tbreak;\n\t\tcase MFCINST_RES_CHANGE_FLUSH:\n\t\t\ts5p_mfc_run_dec_frame(ctx, MFC_DEC_FRAME);\n\t\t\tbreak;\n\t\tcase MFCINST_RES_CHANGE_END:\n\t\t\tmfc_debug(2, \"Finished remaining frames after resolution change\\n\");\n\t\t\tctx->capture_state = QUEUE_FREE;\n\t\t\tmfc_debug(2, \"Will re-init the codec\\n\");\n\t\t\ts5p_mfc_run_init_dec(ctx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EAGAIN;\n\t\t}\n\t} else if (ctx->type == MFCINST_ENCODER) {\n\t\tswitch (ctx->state) {\n\t\tcase MFCINST_FINISHING:\n\t\tcase MFCINST_RUNNING:\n\t\t\tret = s5p_mfc_run_enc_frame(ctx);\n\t\t\tbreak;\n\t\tcase MFCINST_INIT:\n\t\t\tret = s5p_mfc_hw_call(dev->mfc_cmds, open_inst_cmd,\n\t\t\t\t\tctx);\n\t\t\tbreak;\n\t\tcase MFCINST_RETURN_INST:\n\t\t\tret = s5p_mfc_hw_call(dev->mfc_cmds, close_inst_cmd,\n\t\t\t\t\tctx);\n\t\t\tbreak;\n\t\tcase MFCINST_GOT_INST:\n\t\t\ts5p_mfc_run_init_enc(ctx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EAGAIN;\n\t\t}\n\t} else {\n\t\tmfc_err(\"Invalid context type: %d\\n\", ctx->type);\n\t\tret = -EAGAIN;\n\t}\n\n\tif (ret) {\n\t\t \n\t\tif (test_and_clear_bit(0, &dev->hw_lock) == 0)\n\t\t\tmfc_err(\"Failed to unlock hardware\\n\");\n\n\t\t \n\t\ts5p_mfc_clock_off();\n\t}\n}\n\nstatic void s5p_mfc_clear_int_flags_v5(struct s5p_mfc_dev *dev)\n{\n\tmfc_write(dev, 0, S5P_FIMV_RISC_HOST_INT);\n\tmfc_write(dev, 0, S5P_FIMV_RISC2HOST_CMD);\n\tmfc_write(dev, 0xffff, S5P_FIMV_SI_RTN_CHID);\n}\n\nstatic int s5p_mfc_get_dspl_y_adr_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_SI_DISPLAY_Y_ADR) << MFC_OFFSET_SHIFT;\n}\n\nstatic int s5p_mfc_get_dec_y_adr_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_SI_DECODE_Y_ADR) << MFC_OFFSET_SHIFT;\n}\n\nstatic int s5p_mfc_get_dspl_status_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_SI_DISPLAY_STATUS);\n}\n\nstatic int s5p_mfc_get_dec_status_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_SI_DECODE_STATUS);\n}\n\nstatic int s5p_mfc_get_dec_frame_type_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_DECODE_FRAME_TYPE) &\n\t\tS5P_FIMV_DECODE_FRAME_MASK;\n}\n\nstatic int s5p_mfc_get_disp_frame_type_v5(struct s5p_mfc_ctx *ctx)\n{\n\treturn (s5p_mfc_read_info_v5(ctx, DISP_PIC_FRAME_TYPE) >>\n\t\t\tS5P_FIMV_SHARED_DISP_FRAME_TYPE_SHIFT) &\n\t\t\tS5P_FIMV_DECODE_FRAME_MASK;\n}\n\nstatic int s5p_mfc_get_consumed_stream_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_SI_CONSUMED_BYTES);\n}\n\nstatic int s5p_mfc_get_int_reason_v5(struct s5p_mfc_dev *dev)\n{\n\tint reason;\n\treason = mfc_read(dev, S5P_FIMV_RISC2HOST_CMD) &\n\t\tS5P_FIMV_RISC2HOST_CMD_MASK;\n\tswitch (reason) {\n\tcase S5P_FIMV_R2H_CMD_OPEN_INSTANCE_RET:\n\t\treason = S5P_MFC_R2H_CMD_OPEN_INSTANCE_RET;\n\t\tbreak;\n\tcase S5P_FIMV_R2H_CMD_CLOSE_INSTANCE_RET:\n\t\treason = S5P_MFC_R2H_CMD_CLOSE_INSTANCE_RET;\n\t\tbreak;\n\tcase S5P_FIMV_R2H_CMD_SEQ_DONE_RET:\n\t\treason = S5P_MFC_R2H_CMD_SEQ_DONE_RET;\n\t\tbreak;\n\tcase S5P_FIMV_R2H_CMD_FRAME_DONE_RET:\n\t\treason = S5P_MFC_R2H_CMD_FRAME_DONE_RET;\n\t\tbreak;\n\tcase S5P_FIMV_R2H_CMD_SLICE_DONE_RET:\n\t\treason = S5P_MFC_R2H_CMD_SLICE_DONE_RET;\n\t\tbreak;\n\tcase S5P_FIMV_R2H_CMD_SYS_INIT_RET:\n\t\treason = S5P_MFC_R2H_CMD_SYS_INIT_RET;\n\t\tbreak;\n\tcase S5P_FIMV_R2H_CMD_FW_STATUS_RET:\n\t\treason = S5P_MFC_R2H_CMD_FW_STATUS_RET;\n\t\tbreak;\n\tcase S5P_FIMV_R2H_CMD_SLEEP_RET:\n\t\treason = S5P_MFC_R2H_CMD_SLEEP_RET;\n\t\tbreak;\n\tcase S5P_FIMV_R2H_CMD_WAKEUP_RET:\n\t\treason = S5P_MFC_R2H_CMD_WAKEUP_RET;\n\t\tbreak;\n\tcase S5P_FIMV_R2H_CMD_INIT_BUFFERS_RET:\n\t\treason = S5P_MFC_R2H_CMD_INIT_BUFFERS_RET;\n\t\tbreak;\n\tcase S5P_FIMV_R2H_CMD_ENC_COMPLETE_RET:\n\t\treason = S5P_MFC_R2H_CMD_COMPLETE_SEQ_RET;\n\t\tbreak;\n\tcase S5P_FIMV_R2H_CMD_ERR_RET:\n\t\treason = S5P_MFC_R2H_CMD_ERR_RET;\n\t\tbreak;\n\tdefault:\n\t\treason = S5P_MFC_R2H_CMD_EMPTY;\n\t}\n\treturn reason;\n}\n\nstatic int s5p_mfc_get_int_err_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_RISC2HOST_ARG2);\n}\n\nstatic int s5p_mfc_err_dec_v5(unsigned int err)\n{\n\treturn (err & S5P_FIMV_ERR_DEC_MASK) >> S5P_FIMV_ERR_DEC_SHIFT;\n}\n\nstatic int s5p_mfc_get_img_width_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_SI_HRESOL);\n}\n\nstatic int s5p_mfc_get_img_height_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_SI_VRESOL);\n}\n\nstatic int s5p_mfc_get_dpb_count_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_SI_BUF_NUMBER);\n}\n\nstatic int s5p_mfc_get_mv_count_v5(struct s5p_mfc_dev *dev)\n{\n\t \n\treturn -1;\n}\n\nstatic int s5p_mfc_get_inst_no_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_RISC2HOST_ARG1);\n}\n\nstatic int s5p_mfc_get_enc_strm_size_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_ENC_SI_STRM_SIZE);\n}\n\nstatic int s5p_mfc_get_enc_slice_type_v5(struct s5p_mfc_dev *dev)\n{\n\treturn mfc_read(dev, S5P_FIMV_ENC_SI_SLICE_TYPE);\n}\n\nstatic int s5p_mfc_get_enc_dpb_count_v5(struct s5p_mfc_dev *dev)\n{\n\treturn -1;\n}\n\nstatic unsigned int s5p_mfc_get_pic_type_top_v5(struct s5p_mfc_ctx *ctx)\n{\n\treturn s5p_mfc_read_info_v5(ctx, PIC_TIME_TOP);\n}\n\nstatic unsigned int s5p_mfc_get_pic_type_bot_v5(struct s5p_mfc_ctx *ctx)\n{\n\treturn s5p_mfc_read_info_v5(ctx, PIC_TIME_BOT);\n}\n\nstatic unsigned int s5p_mfc_get_crop_info_h_v5(struct s5p_mfc_ctx *ctx)\n{\n\treturn s5p_mfc_read_info_v5(ctx, CROP_INFO_H);\n}\n\nstatic unsigned int s5p_mfc_get_crop_info_v_v5(struct s5p_mfc_ctx *ctx)\n{\n\treturn s5p_mfc_read_info_v5(ctx, CROP_INFO_V);\n}\n\n \nstatic struct s5p_mfc_hw_ops s5p_mfc_ops_v5 = {\n\t.alloc_dec_temp_buffers = s5p_mfc_alloc_dec_temp_buffers_v5,\n\t.release_dec_desc_buffer = s5p_mfc_release_dec_desc_buffer_v5,\n\t.alloc_codec_buffers = s5p_mfc_alloc_codec_buffers_v5,\n\t.release_codec_buffers = s5p_mfc_release_codec_buffers_v5,\n\t.alloc_instance_buffer = s5p_mfc_alloc_instance_buffer_v5,\n\t.release_instance_buffer = s5p_mfc_release_instance_buffer_v5,\n\t.alloc_dev_context_buffer = s5p_mfc_alloc_dev_context_buffer_v5,\n\t.release_dev_context_buffer = s5p_mfc_release_dev_context_buffer_v5,\n\t.dec_calc_dpb_size = s5p_mfc_dec_calc_dpb_size_v5,\n\t.enc_calc_src_size = s5p_mfc_enc_calc_src_size_v5,\n\t.set_enc_stream_buffer = s5p_mfc_set_enc_stream_buffer_v5,\n\t.set_enc_frame_buffer = s5p_mfc_set_enc_frame_buffer_v5,\n\t.get_enc_frame_buffer = s5p_mfc_get_enc_frame_buffer_v5,\n\t.try_run = s5p_mfc_try_run_v5,\n\t.clear_int_flags = s5p_mfc_clear_int_flags_v5,\n\t.get_dspl_y_adr = s5p_mfc_get_dspl_y_adr_v5,\n\t.get_dec_y_adr = s5p_mfc_get_dec_y_adr_v5,\n\t.get_dspl_status = s5p_mfc_get_dspl_status_v5,\n\t.get_dec_status = s5p_mfc_get_dec_status_v5,\n\t.get_dec_frame_type = s5p_mfc_get_dec_frame_type_v5,\n\t.get_disp_frame_type = s5p_mfc_get_disp_frame_type_v5,\n\t.get_consumed_stream = s5p_mfc_get_consumed_stream_v5,\n\t.get_int_reason = s5p_mfc_get_int_reason_v5,\n\t.get_int_err = s5p_mfc_get_int_err_v5,\n\t.err_dec = s5p_mfc_err_dec_v5,\n\t.get_img_width = s5p_mfc_get_img_width_v5,\n\t.get_img_height = s5p_mfc_get_img_height_v5,\n\t.get_dpb_count = s5p_mfc_get_dpb_count_v5,\n\t.get_mv_count = s5p_mfc_get_mv_count_v5,\n\t.get_inst_no = s5p_mfc_get_inst_no_v5,\n\t.get_enc_strm_size = s5p_mfc_get_enc_strm_size_v5,\n\t.get_enc_slice_type = s5p_mfc_get_enc_slice_type_v5,\n\t.get_enc_dpb_count = s5p_mfc_get_enc_dpb_count_v5,\n\t.get_pic_type_top = s5p_mfc_get_pic_type_top_v5,\n\t.get_pic_type_bot = s5p_mfc_get_pic_type_bot_v5,\n\t.get_crop_info_h = s5p_mfc_get_crop_info_h_v5,\n\t.get_crop_info_v = s5p_mfc_get_crop_info_v_v5,\n};\n\nstruct s5p_mfc_hw_ops *s5p_mfc_init_hw_ops_v5(void)\n{\n\treturn &s5p_mfc_ops_v5;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}