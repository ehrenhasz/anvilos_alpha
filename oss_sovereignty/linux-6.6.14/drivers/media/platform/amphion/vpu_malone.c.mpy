{
  "module_name": "vpu_malone.c",
  "hash_id": "c05ea014aa20190ebdd5e1f6c30dffa4ca8a0e14b6283f4a8cedd4239ed33e96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/amphion/vpu_malone.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interconnect.h>\n#include <linux/ioctl.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/rational.h>\n#include <linux/time64.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n#include <linux/videodev2.h>\n#include \"vpu.h\"\n#include \"vpu_rpc.h\"\n#include \"vpu_defs.h\"\n#include \"vpu_helpers.h\"\n#include \"vpu_v4l2.h\"\n#include \"vpu_cmds.h\"\n#include \"vpu_imx8q.h\"\n#include \"vpu_malone.h\"\n\n#define CMD_SIZE\t\t\t25600\n#define MSG_SIZE\t\t\t25600\n#define CODEC_SIZE\t\t\t0x1000\n#define JPEG_SIZE\t\t\t0x1000\n#define SEQ_SIZE\t\t\t0x1000\n#define GOP_SIZE\t\t\t0x1000\n#define PIC_SIZE\t\t\t0x1000\n#define QMETER_SIZE\t\t\t0x1000\n#define DBGLOG_SIZE\t\t\t0x10000\n#define DEBUG_SIZE\t\t\t0x80000\n#define ENG_SIZE\t\t\t0x1000\n#define MALONE_SKIPPED_FRAME_ID\t\t0x555\n\n#define MALONE_ALIGN_MBI\t\t0x800\n#define MALONE_DCP_CHUNK_BIT\t\t16\n#define MALONE_DCP_SIZE_MAX\t\t0x3000000\n#define MALONE_DCP_SIZE_MIN\t\t0x100000\n#define MALONE_DCP_FIXED_MB_ALLOC\t250\n\n#define CONFIG_SET(val, cfg, pos, mask)\t\t\\\n\t\t(*(cfg) |= (((val) << (pos)) & (mask)))\n\n#define STREAM_CONFIG_FORMAT_SET(x, y)\t\tCONFIG_SET(x, y, 0, 0x0000000F)\n#define STREAM_CONFIG_STRBUFIDX_SET(x, y)\tCONFIG_SET(x, y, 8, 0x00000300)\n#define STREAM_CONFIG_NOSEQ_SET(x, y)\t\tCONFIG_SET(x, y, 10, 0x00000400)\n#define STREAM_CONFIG_DEBLOCK_SET(x, y)\t\tCONFIG_SET(x, y, 11, 0x00000800)\n#define STREAM_CONFIG_DERING_SET(x, y)\t\tCONFIG_SET(x, y, 12, 0x00001000)\n#define STREAM_CONFIG_IBWAIT_SET(x, y)\t\tCONFIG_SET(x, y, 13, 0x00002000)\n#define STREAM_CONFIG_FBC_SET(x, y)\t\tCONFIG_SET(x, y, 14, 0x00004000)\n#define STREAM_CONFIG_PLAY_MODE_SET(x, y)\tCONFIG_SET(x, y, 16, 0x00030000)\n#define STREAM_CONFIG_ENABLE_DCP_SET(x, y)\tCONFIG_SET(x, y, 20, 0x00100000)\n#define STREAM_CONFIG_NUM_STR_BUF_SET(x, y)\tCONFIG_SET(x, y, 21, 0x00600000)\n#define STREAM_CONFIG_MALONE_USAGE_SET(x, y)\tCONFIG_SET(x, y, 23, 0x01800000)\n#define STREAM_CONFIG_MULTI_VID_SET(x, y)\tCONFIG_SET(x, y, 25, 0x02000000)\n#define STREAM_CONFIG_OBFUSC_EN_SET(x, y)\tCONFIG_SET(x, y, 26, 0x04000000)\n#define STREAM_CONFIG_RC4_EN_SET(x, y)\t\tCONFIG_SET(x, y, 27, 0x08000000)\n#define STREAM_CONFIG_MCX_SET(x, y)\t\tCONFIG_SET(x, y, 28, 0x10000000)\n#define STREAM_CONFIG_PES_SET(x, y)\t\tCONFIG_SET(x, y, 29, 0x20000000)\n#define STREAM_CONFIG_NUM_DBE_SET(x, y)\t\tCONFIG_SET(x, y, 30, 0x40000000)\n#define STREAM_CONFIG_FS_CTRL_MODE_SET(x, y)\tCONFIG_SET(x, y, 31, 0x80000000)\n\n#define MALONE_DEC_FMT_RV_MASK\t\t\tBIT(21)\n\nenum vpu_malone_stream_input_mode {\n\tINVALID_MODE = 0,\n\tFRAME_LVL,\n\tNON_FRAME_LVL\n};\n\nenum vpu_malone_format {\n\tMALONE_FMT_NULL = 0x0,\n\tMALONE_FMT_AVC  = 0x1,\n\tMALONE_FMT_MP2  = 0x2,\n\tMALONE_FMT_VC1  = 0x3,\n\tMALONE_FMT_AVS  = 0x4,\n\tMALONE_FMT_ASP  = 0x5,\n\tMALONE_FMT_JPG  = 0x6,\n\tMALONE_FMT_RV   = 0x7,\n\tMALONE_FMT_VP6  = 0x8,\n\tMALONE_FMT_SPK  = 0x9,\n\tMALONE_FMT_VP8  = 0xA,\n\tMALONE_FMT_HEVC = 0xB,\n\tMALONE_FMT_LAST = MALONE_FMT_HEVC\n};\n\nenum {\n\tVID_API_CMD_NULL              = 0x00,\n\tVID_API_CMD_PARSE_NEXT_SEQ    = 0x01,\n\tVID_API_CMD_PARSE_NEXT_I      = 0x02,\n\tVID_API_CMD_PARSE_NEXT_IP     = 0x03,\n\tVID_API_CMD_PARSE_NEXT_ANY    = 0x04,\n\tVID_API_CMD_DEC_PIC           = 0x05,\n\tVID_API_CMD_UPDATE_ES_WR_PTR  = 0x06,\n\tVID_API_CMD_UPDATE_ES_RD_PTR  = 0x07,\n\tVID_API_CMD_UPDATE_UDATA      = 0x08,\n\tVID_API_CMD_GET_FSINFO        = 0x09,\n\tVID_API_CMD_SKIP_PIC          = 0x0a,\n\tVID_API_CMD_DEC_CHUNK         = 0x0b,\n\tVID_API_CMD_START             = 0x10,\n\tVID_API_CMD_STOP              = 0x11,\n\tVID_API_CMD_ABORT             = 0x12,\n\tVID_API_CMD_RST_BUF           = 0x13,\n\tVID_API_CMD_FS_RELEASE        = 0x15,\n\tVID_API_CMD_MEM_REGION_ATTACH = 0x16,\n\tVID_API_CMD_MEM_REGION_DETACH = 0x17,\n\tVID_API_CMD_MVC_VIEW_SELECT   = 0x18,\n\tVID_API_CMD_FS_ALLOC          = 0x19,\n\tVID_API_CMD_DBG_GET_STATUS    = 0x1C,\n\tVID_API_CMD_DBG_START_LOG     = 0x1D,\n\tVID_API_CMD_DBG_STOP_LOG      = 0x1E,\n\tVID_API_CMD_DBG_DUMP_LOG      = 0x1F,\n\tVID_API_CMD_YUV_READY         = 0x20,\n\tVID_API_CMD_TS                = 0x21,\n\n\tVID_API_CMD_FIRM_RESET        = 0x40,\n\n\tVID_API_CMD_SNAPSHOT          = 0xAA,\n\tVID_API_CMD_ROLL_SNAPSHOT     = 0xAB,\n\tVID_API_CMD_LOCK_SCHEDULER    = 0xAC,\n\tVID_API_CMD_UNLOCK_SCHEDULER  = 0xAD,\n\tVID_API_CMD_CQ_FIFO_DUMP      = 0xAE,\n\tVID_API_CMD_DBG_FIFO_DUMP     = 0xAF,\n\tVID_API_CMD_SVC_ILP           = 0xBB,\n\tVID_API_CMD_FW_STATUS         = 0xF0,\n\tVID_API_CMD_INVALID           = 0xFF\n};\n\nenum {\n\tVID_API_EVENT_NULL\t\t\t= 0x00,\n\tVID_API_EVENT_RESET_DONE\t\t= 0x01,\n\tVID_API_EVENT_SEQ_HDR_FOUND\t\t= 0x02,\n\tVID_API_EVENT_PIC_HDR_FOUND\t\t= 0x03,\n\tVID_API_EVENT_PIC_DECODED\t\t= 0x04,\n\tVID_API_EVENT_FIFO_LOW\t\t\t= 0x05,\n\tVID_API_EVENT_FIFO_HIGH\t\t\t= 0x06,\n\tVID_API_EVENT_FIFO_EMPTY\t\t= 0x07,\n\tVID_API_EVENT_FIFO_FULL\t\t\t= 0x08,\n\tVID_API_EVENT_BS_ERROR\t\t\t= 0x09,\n\tVID_API_EVENT_UDATA_FIFO_UPTD\t\t= 0x0A,\n\tVID_API_EVENT_RES_CHANGE\t\t= 0x0B,\n\tVID_API_EVENT_FIFO_OVF\t\t\t= 0x0C,\n\tVID_API_EVENT_CHUNK_DECODED\t\t= 0x0D,\n\tVID_API_EVENT_REQ_FRAME_BUFF\t\t= 0x10,\n\tVID_API_EVENT_FRAME_BUFF_RDY\t\t= 0x11,\n\tVID_API_EVENT_REL_FRAME_BUFF\t\t= 0x12,\n\tVID_API_EVENT_STR_BUF_RST\t\t= 0x13,\n\tVID_API_EVENT_RET_PING\t\t\t= 0x14,\n\tVID_API_EVENT_QMETER\t\t\t= 0x15,\n\tVID_API_EVENT_STR_FMT_CHANGE\t\t= 0x16,\n\tVID_API_EVENT_FIRMWARE_XCPT\t\t= 0x17,\n\tVID_API_EVENT_START_DONE\t\t= 0x18,\n\tVID_API_EVENT_STOPPED\t\t\t= 0x19,\n\tVID_API_EVENT_ABORT_DONE\t\t= 0x1A,\n\tVID_API_EVENT_FINISHED\t\t\t= 0x1B,\n\tVID_API_EVENT_DBG_STAT_UPDATE\t\t= 0x1C,\n\tVID_API_EVENT_DBG_LOG_STARTED\t\t= 0x1D,\n\tVID_API_EVENT_DBG_LOG_STOPPED\t\t= 0x1E,\n\tVID_API_EVENT_DBG_LOG_UPDATED\t\t= 0x1F,\n\tVID_API_EVENT_DBG_MSG_DEC\t\t= 0x20,\n\tVID_API_EVENT_DEC_SC_ERR\t\t= 0x21,\n\tVID_API_EVENT_CQ_FIFO_DUMP\t\t= 0x22,\n\tVID_API_EVENT_DBG_FIFO_DUMP\t\t= 0x23,\n\tVID_API_EVENT_DEC_CHECK_RES\t\t= 0x24,\n\tVID_API_EVENT_DEC_CFG_INFO\t\t= 0x25,\n\tVID_API_EVENT_UNSUPPORTED_STREAM\t= 0x26,\n\tVID_API_EVENT_PIC_SKIPPED\t\t= 0x27,\n\tVID_API_EVENT_STR_SUSPENDED\t\t= 0x30,\n\tVID_API_EVENT_SNAPSHOT_DONE\t\t= 0x40,\n\tVID_API_EVENT_FW_STATUS                 = 0xF0,\n\tVID_API_EVENT_INVALID\t\t\t= 0xFF\n};\n\nstruct vpu_malone_buffer_desc {\n\tstruct vpu_rpc_buffer_desc buffer;\n\tu32 low;\n\tu32 high;\n};\n\nstruct vpu_malone_str_buffer {\n\tu32 wptr;\n\tu32 rptr;\n\tu32 start;\n\tu32 end;\n\tu32 lwm;\n};\n\nstruct vpu_malone_picth_info {\n\tu32 frame_pitch;\n};\n\nstruct vpu_malone_table_desc {\n\tu32 array_base;\n\tu32 size;\n};\n\nstruct vpu_malone_dbglog_desc {\n\tu32 addr;\n\tu32 size;\n\tu32 level;\n\tu32 reserved;\n};\n\nstruct vpu_malone_frame_buffer {\n\tu32 addr;\n\tu32 size;\n};\n\nstruct vpu_malone_udata {\n\tu32 base;\n\tu32 total_size;\n\tu32 slot_size;\n};\n\nstruct vpu_malone_buffer_info {\n\tu32 stream_input_mode;\n\tu32 stream_pic_input_count;\n\tu32 stream_pic_parsed_count;\n\tu32 stream_buffer_threshold;\n\tu32 stream_pic_end_flag;\n};\n\nstruct vpu_malone_encrypt_info {\n\tu32 rec4key[8];\n\tu32 obfusc;\n};\n\nstruct malone_iface {\n\tu32 exec_base_addr;\n\tu32 exec_area_size;\n\tstruct vpu_malone_buffer_desc cmd_buffer_desc;\n\tstruct vpu_malone_buffer_desc msg_buffer_desc;\n\tu32 cmd_int_enable[VID_API_NUM_STREAMS];\n\tstruct vpu_malone_picth_info stream_pitch_info[VID_API_NUM_STREAMS];\n\tu32 stream_config[VID_API_NUM_STREAMS];\n\tstruct vpu_malone_table_desc codec_param_tab_desc;\n\tstruct vpu_malone_table_desc jpeg_param_tab_desc;\n\tu32 stream_buffer_desc[VID_API_NUM_STREAMS][VID_API_MAX_BUF_PER_STR];\n\tstruct vpu_malone_table_desc seq_info_tab_desc;\n\tstruct vpu_malone_table_desc pic_info_tab_desc;\n\tstruct vpu_malone_table_desc gop_info_tab_desc;\n\tstruct vpu_malone_table_desc qmeter_info_tab_desc;\n\tu32 stream_error[VID_API_NUM_STREAMS];\n\tu32 fw_version;\n\tu32 fw_offset;\n\tu32 max_streams;\n\tstruct vpu_malone_dbglog_desc dbglog_desc;\n\tstruct vpu_rpc_buffer_desc api_cmd_buffer_desc[VID_API_NUM_STREAMS];\n\tstruct vpu_malone_udata udata_buffer[VID_API_NUM_STREAMS];\n\tstruct vpu_malone_buffer_desc debug_buffer_desc;\n\tstruct vpu_malone_buffer_desc eng_access_buff_desc[VID_API_NUM_STREAMS];\n\tu32 encrypt_info[VID_API_NUM_STREAMS];\n\tstruct vpu_rpc_system_config system_cfg;\n\tu32 api_version;\n\tstruct vpu_malone_buffer_info stream_buff_info[VID_API_NUM_STREAMS];\n};\n\nstruct malone_jpg_params {\n\tu32 rotation_angle;\n\tu32 horiz_scale_factor;\n\tu32 vert_scale_factor;\n\tu32 rotation_mode;\n\tu32 rgb_mode;\n\tu32 chunk_mode;  \n\tu32 last_chunk;  \n\tu32 chunk_rows;  \n\tu32 num_bytes;\n\tu32 jpg_crop_x;\n\tu32 jpg_crop_y;\n\tu32 jpg_crop_width;\n\tu32 jpg_crop_height;\n\tu32 jpg_mjpeg_mode;\n\tu32 jpg_mjpeg_interlaced;\n};\n\nstruct malone_codec_params {\n\tu32 disp_imm;\n\tu32 fourcc;\n\tu32 codec_version;\n\tu32 frame_rate;\n\tu32 dbglog_enable;\n\tu32 bsdma_lwm;\n\tu32 bbd_coring;\n\tu32 bbd_s_thr_row;\n\tu32 bbd_p_thr_row;\n\tu32 bbd_s_thr_logo_row;\n\tu32 bbd_p_thr_logo_row;\n\tu32 bbd_s_thr_col;\n\tu32 bbd_p_thr_col;\n\tu32 bbd_chr_thr_row;\n\tu32 bbd_chr_thr_col;\n\tu32 bbd_uv_mid_level;\n\tu32 bbd_excl_win_mb_left;\n\tu32 bbd_excl_win_mb_right;\n};\n\nstruct malone_padding_scode {\n\tu32 scode_type;\n\tu32 pixelformat;\n\tu32 data[2];\n};\n\nstruct malone_fmt_mapping {\n\tu32 pixelformat;\n\tenum vpu_malone_format malone_format;\n\tu32 is_disabled;\n};\n\nstruct malone_scode_t {\n\tstruct vpu_inst *inst;\n\tstruct vb2_buffer *vb;\n\tu32 wptr;\n\tu32 need_data;\n};\n\nstruct malone_scode_handler {\n\tu32 pixelformat;\n\tint (*insert_scode_seq)(struct malone_scode_t *scode);\n\tint (*insert_scode_pic)(struct malone_scode_t *scode);\n};\n\nstruct vpu_dec_ctrl {\n\tstruct malone_codec_params *codec_param;\n\tstruct malone_jpg_params *jpg;\n\tvoid *seq_mem;\n\tvoid *pic_mem;\n\tvoid *gop_mem;\n\tvoid *qmeter_mem;\n\tvoid *dbglog_mem;\n\tstruct vpu_malone_str_buffer __iomem *str_buf[VID_API_NUM_STREAMS];\n\tu32 buf_addr[VID_API_NUM_STREAMS];\n};\n\nu32 vpu_malone_get_data_size(void)\n{\n\treturn sizeof(struct vpu_dec_ctrl);\n}\n\nvoid vpu_malone_init_rpc(struct vpu_shared_addr *shared,\n\t\t\t struct vpu_buffer *rpc, dma_addr_t boot_addr)\n{\n\tstruct malone_iface *iface;\n\tstruct vpu_dec_ctrl *hc;\n\tunsigned long base_phy_addr;\n\tunsigned long phy_addr;\n\tunsigned long offset;\n\tunsigned int i;\n\n\tif (rpc->phys < boot_addr)\n\t\treturn;\n\n\tiface = rpc->virt;\n\tbase_phy_addr = rpc->phys - boot_addr;\n\thc = shared->priv;\n\n\tshared->iface = iface;\n\tshared->boot_addr = boot_addr;\n\n\tiface->exec_base_addr = base_phy_addr;\n\tiface->exec_area_size = rpc->length;\n\n\toffset = sizeof(struct malone_iface);\n\tphy_addr = base_phy_addr + offset;\n\n\tshared->cmd_desc = &iface->cmd_buffer_desc.buffer;\n\tshared->cmd_mem_vir = rpc->virt + offset;\n\tiface->cmd_buffer_desc.buffer.start =\n\tiface->cmd_buffer_desc.buffer.rptr =\n\tiface->cmd_buffer_desc.buffer.wptr = phy_addr;\n\tiface->cmd_buffer_desc.buffer.end = iface->cmd_buffer_desc.buffer.start + CMD_SIZE;\n\toffset += CMD_SIZE;\n\tphy_addr = base_phy_addr + offset;\n\n\tshared->msg_desc = &iface->msg_buffer_desc.buffer;\n\tshared->msg_mem_vir = rpc->virt + offset;\n\tiface->msg_buffer_desc.buffer.start =\n\tiface->msg_buffer_desc.buffer.wptr =\n\tiface->msg_buffer_desc.buffer.rptr = phy_addr;\n\tiface->msg_buffer_desc.buffer.end = iface->msg_buffer_desc.buffer.start + MSG_SIZE;\n\toffset += MSG_SIZE;\n\tphy_addr = base_phy_addr + offset;\n\n\tiface->codec_param_tab_desc.array_base = phy_addr;\n\thc->codec_param = rpc->virt + offset;\n\toffset += CODEC_SIZE;\n\tphy_addr = base_phy_addr + offset;\n\n\tiface->jpeg_param_tab_desc.array_base = phy_addr;\n\thc->jpg = rpc->virt + offset;\n\toffset += JPEG_SIZE;\n\tphy_addr = base_phy_addr + offset;\n\n\tiface->seq_info_tab_desc.array_base = phy_addr;\n\thc->seq_mem = rpc->virt + offset;\n\toffset += SEQ_SIZE;\n\tphy_addr = base_phy_addr + offset;\n\n\tiface->pic_info_tab_desc.array_base = phy_addr;\n\thc->pic_mem = rpc->virt + offset;\n\toffset += PIC_SIZE;\n\tphy_addr = base_phy_addr + offset;\n\n\tiface->gop_info_tab_desc.array_base = phy_addr;\n\thc->gop_mem = rpc->virt + offset;\n\toffset += GOP_SIZE;\n\tphy_addr = base_phy_addr + offset;\n\n\tiface->qmeter_info_tab_desc.array_base = phy_addr;\n\thc->qmeter_mem = rpc->virt + offset;\n\toffset += QMETER_SIZE;\n\tphy_addr = base_phy_addr + offset;\n\n\tiface->dbglog_desc.addr = phy_addr;\n\tiface->dbglog_desc.size = DBGLOG_SIZE;\n\thc->dbglog_mem = rpc->virt + offset;\n\toffset += DBGLOG_SIZE;\n\tphy_addr = base_phy_addr + offset;\n\n\tfor (i = 0; i < VID_API_NUM_STREAMS; i++) {\n\t\tiface->eng_access_buff_desc[i].buffer.start =\n\t\tiface->eng_access_buff_desc[i].buffer.wptr =\n\t\tiface->eng_access_buff_desc[i].buffer.rptr = phy_addr;\n\t\tiface->eng_access_buff_desc[i].buffer.end =\n\t\t\tiface->eng_access_buff_desc[i].buffer.start + ENG_SIZE;\n\t\toffset += ENG_SIZE;\n\t\tphy_addr = base_phy_addr + offset;\n\t}\n\n\tfor (i = 0; i < VID_API_NUM_STREAMS; i++) {\n\t\tiface->encrypt_info[i] = phy_addr;\n\t\toffset += sizeof(struct vpu_malone_encrypt_info);\n\t\tphy_addr = base_phy_addr + offset;\n\t}\n\n\trpc->bytesused = offset;\n}\n\nvoid vpu_malone_set_log_buf(struct vpu_shared_addr *shared,\n\t\t\t    struct vpu_buffer *log)\n{\n\tstruct malone_iface *iface = shared->iface;\n\n\tiface->debug_buffer_desc.buffer.start =\n\tiface->debug_buffer_desc.buffer.wptr =\n\tiface->debug_buffer_desc.buffer.rptr = log->phys - shared->boot_addr;\n\tiface->debug_buffer_desc.buffer.end = iface->debug_buffer_desc.buffer.start + log->length;\n}\n\nstatic u32 get_str_buffer_offset(u32 instance)\n{\n\treturn DEC_MFD_XREG_SLV_BASE + MFD_MCX + MFD_MCX_OFF * instance;\n}\n\nvoid vpu_malone_set_system_cfg(struct vpu_shared_addr *shared,\n\t\t\t       u32 regs_base, void __iomem *regs, u32 core_id)\n{\n\tstruct malone_iface *iface = shared->iface;\n\tstruct vpu_rpc_system_config *config = &iface->system_cfg;\n\tstruct vpu_dec_ctrl *hc = shared->priv;\n\tint i;\n\n\tvpu_imx8q_set_system_cfg_common(config, regs_base, core_id);\n\tfor (i = 0; i < VID_API_NUM_STREAMS; i++) {\n\t\tu32 offset = get_str_buffer_offset(i);\n\n\t\thc->buf_addr[i] = regs_base + offset;\n\t\thc->str_buf[i] = regs + offset;\n\t}\n}\n\nu32 vpu_malone_get_version(struct vpu_shared_addr *shared)\n{\n\tstruct malone_iface *iface = shared->iface;\n\n\tvpu_malone_enable_format(V4L2_PIX_FMT_RV30, iface->fw_version & MALONE_DEC_FMT_RV_MASK);\n\tvpu_malone_enable_format(V4L2_PIX_FMT_RV40, iface->fw_version & MALONE_DEC_FMT_RV_MASK);\n\n\treturn iface->fw_version;\n}\n\nint vpu_malone_get_stream_buffer_size(struct vpu_shared_addr *shared)\n{\n\treturn 0xc00000;\n}\n\nint vpu_malone_config_stream_buffer(struct vpu_shared_addr *shared,\n\t\t\t\t    u32 instance,\n\t\t\t\t    struct vpu_buffer *buf)\n{\n\tstruct malone_iface *iface = shared->iface;\n\tstruct vpu_dec_ctrl *hc = shared->priv;\n\tstruct vpu_malone_str_buffer __iomem *str_buf = hc->str_buf[instance];\n\n\twritel(buf->phys, &str_buf->start);\n\twritel(buf->phys, &str_buf->rptr);\n\twritel(buf->phys, &str_buf->wptr);\n\twritel(buf->phys + buf->length, &str_buf->end);\n\twritel(0x1, &str_buf->lwm);\n\n\tiface->stream_buffer_desc[instance][0] = hc->buf_addr[instance];\n\n\treturn 0;\n}\n\nint vpu_malone_get_stream_buffer_desc(struct vpu_shared_addr *shared,\n\t\t\t\t      u32 instance,\n\t\t\t\t      struct vpu_rpc_buffer_desc *desc)\n{\n\tstruct vpu_dec_ctrl *hc = shared->priv;\n\tstruct vpu_malone_str_buffer __iomem *str_buf = hc->str_buf[instance];\n\n\tif (desc) {\n\t\tdesc->wptr = readl(&str_buf->wptr);\n\t\tdesc->rptr = readl(&str_buf->rptr);\n\t\tdesc->start = readl(&str_buf->start);\n\t\tdesc->end = readl(&str_buf->end);\n\t}\n\n\treturn 0;\n}\n\nstatic void vpu_malone_update_wptr(struct vpu_malone_str_buffer __iomem *str_buf, u32 wptr)\n{\n\t \n\tmb();\n\twritel(wptr, &str_buf->wptr);\n}\n\nstatic void vpu_malone_update_rptr(struct vpu_malone_str_buffer __iomem *str_buf, u32 rptr)\n{\n\t \n\tmb();\n\twritel(rptr, &str_buf->rptr);\n}\n\nint vpu_malone_update_stream_buffer(struct vpu_shared_addr *shared,\n\t\t\t\t    u32 instance, u32 ptr, bool write)\n{\n\tstruct vpu_dec_ctrl *hc = shared->priv;\n\tstruct vpu_malone_str_buffer __iomem *str_buf = hc->str_buf[instance];\n\n\tif (write)\n\t\tvpu_malone_update_wptr(str_buf, ptr);\n\telse\n\t\tvpu_malone_update_rptr(str_buf, ptr);\n\n\treturn 0;\n}\n\nstatic struct malone_fmt_mapping fmt_mappings[] = {\n\t{V4L2_PIX_FMT_H264,        MALONE_FMT_AVC},\n\t{V4L2_PIX_FMT_H264_MVC,    MALONE_FMT_AVC},\n\t{V4L2_PIX_FMT_HEVC,        MALONE_FMT_HEVC},\n\t{V4L2_PIX_FMT_VC1_ANNEX_G, MALONE_FMT_VC1},\n\t{V4L2_PIX_FMT_VC1_ANNEX_L, MALONE_FMT_VC1},\n\t{V4L2_PIX_FMT_MPEG2,       MALONE_FMT_MP2},\n\t{V4L2_PIX_FMT_MPEG4,       MALONE_FMT_ASP},\n\t{V4L2_PIX_FMT_XVID,        MALONE_FMT_ASP},\n\t{V4L2_PIX_FMT_H263,        MALONE_FMT_ASP},\n\t{V4L2_PIX_FMT_JPEG,        MALONE_FMT_JPG},\n\t{V4L2_PIX_FMT_VP8,         MALONE_FMT_VP8},\n\t{V4L2_PIX_FMT_SPK,         MALONE_FMT_SPK},\n\t{V4L2_PIX_FMT_RV30,        MALONE_FMT_RV},\n\t{V4L2_PIX_FMT_RV40,        MALONE_FMT_RV},\n};\n\nvoid vpu_malone_enable_format(u32 pixelformat, int enable)\n{\n\tu32 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fmt_mappings); i++) {\n\t\tif (pixelformat == fmt_mappings[i].pixelformat) {\n\t\t\tfmt_mappings[i].is_disabled = enable ? 0 : 1;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic enum vpu_malone_format vpu_malone_format_remap(u32 pixelformat)\n{\n\tu32 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fmt_mappings); i++) {\n\t\tif (fmt_mappings[i].is_disabled)\n\t\t\tcontinue;\n\t\tif (pixelformat == fmt_mappings[i].pixelformat)\n\t\t\treturn fmt_mappings[i].malone_format;\n\t}\n\n\treturn MALONE_FMT_NULL;\n}\n\nbool vpu_malone_check_fmt(enum vpu_core_type type, u32 pixelfmt)\n{\n\tif (!vpu_imx8q_check_fmt(type, pixelfmt))\n\t\treturn false;\n\n\tif (pixelfmt == V4L2_PIX_FMT_NV12_8L128 || pixelfmt == V4L2_PIX_FMT_NV12_10BE_8L128 ||\n\t    pixelfmt == V4L2_PIX_FMT_NV12M_8L128 || pixelfmt == V4L2_PIX_FMT_NV12M_10BE_8L128)\n\t\treturn true;\n\tif (vpu_malone_format_remap(pixelfmt) == MALONE_FMT_NULL)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void vpu_malone_set_stream_cfg(struct vpu_shared_addr *shared,\n\t\t\t\t      u32 instance,\n\t\t\t\t      enum vpu_malone_format malone_format)\n{\n\tstruct malone_iface *iface = shared->iface;\n\tu32 *curr_str_cfg = &iface->stream_config[instance];\n\n\t*curr_str_cfg = 0;\n\tSTREAM_CONFIG_FORMAT_SET(malone_format, curr_str_cfg);\n\tSTREAM_CONFIG_STRBUFIDX_SET(0, curr_str_cfg);\n\tSTREAM_CONFIG_NOSEQ_SET(0, curr_str_cfg);\n\tSTREAM_CONFIG_DEBLOCK_SET(0, curr_str_cfg);\n\tSTREAM_CONFIG_DERING_SET(0, curr_str_cfg);\n\tSTREAM_CONFIG_PLAY_MODE_SET(0x3, curr_str_cfg);\n\tSTREAM_CONFIG_FS_CTRL_MODE_SET(0x1, curr_str_cfg);\n\tSTREAM_CONFIG_ENABLE_DCP_SET(1, curr_str_cfg);\n\tSTREAM_CONFIG_NUM_STR_BUF_SET(1, curr_str_cfg);\n\tSTREAM_CONFIG_MALONE_USAGE_SET(1, curr_str_cfg);\n\tSTREAM_CONFIG_MULTI_VID_SET(0, curr_str_cfg);\n\tSTREAM_CONFIG_OBFUSC_EN_SET(0, curr_str_cfg);\n\tSTREAM_CONFIG_RC4_EN_SET(0, curr_str_cfg);\n\tSTREAM_CONFIG_MCX_SET(1, curr_str_cfg);\n\tSTREAM_CONFIG_PES_SET(0, curr_str_cfg);\n\tSTREAM_CONFIG_NUM_DBE_SET(1, curr_str_cfg);\n}\n\nstatic int vpu_malone_set_params(struct vpu_shared_addr *shared,\n\t\t\t\t u32 instance,\n\t\t\t\t struct vpu_decode_params *params)\n{\n\tstruct malone_iface *iface = shared->iface;\n\tstruct vpu_dec_ctrl *hc = shared->priv;\n\tenum vpu_malone_format malone_format;\n\n\tmalone_format = vpu_malone_format_remap(params->codec_format);\n\tif (WARN_ON(malone_format == MALONE_FMT_NULL))\n\t\treturn -EINVAL;\n\tiface->udata_buffer[instance].base = params->udata.base;\n\tiface->udata_buffer[instance].slot_size = params->udata.size;\n\n\tvpu_malone_set_stream_cfg(shared, instance, malone_format);\n\n\tif (malone_format == MALONE_FMT_JPG) {\n\t\t\n\t\thc->jpg[instance].jpg_mjpeg_mode = 1;\n\t\t\n\t\thc->jpg[instance].jpg_mjpeg_interlaced = 0;\n\t}\n\n\thc->codec_param[instance].disp_imm = params->display_delay_enable ? 1 : 0;\n\tif (malone_format != MALONE_FMT_AVC)\n\t\thc->codec_param[instance].disp_imm = 0;\n\thc->codec_param[instance].dbglog_enable = 0;\n\tiface->dbglog_desc.level = 0;\n\n\tif (params->b_non_frame)\n\t\tiface->stream_buff_info[instance].stream_input_mode = NON_FRAME_LVL;\n\telse\n\t\tiface->stream_buff_info[instance].stream_input_mode = FRAME_LVL;\n\tiface->stream_buff_info[instance].stream_buffer_threshold = 0;\n\tiface->stream_buff_info[instance].stream_pic_input_count = 0;\n\n\treturn 0;\n}\n\nstatic bool vpu_malone_is_non_frame_mode(struct vpu_shared_addr *shared, u32 instance)\n{\n\tstruct malone_iface *iface = shared->iface;\n\n\tif (iface->stream_buff_info[instance].stream_input_mode == NON_FRAME_LVL)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int vpu_malone_update_params(struct vpu_shared_addr *shared,\n\t\t\t\t    u32 instance,\n\t\t\t\t    struct vpu_decode_params *params)\n{\n\tstruct malone_iface *iface = shared->iface;\n\n\tif (params->end_flag)\n\t\tiface->stream_buff_info[instance].stream_pic_end_flag = params->end_flag;\n\tparams->end_flag = 0;\n\n\treturn 0;\n}\n\nint vpu_malone_set_decode_params(struct vpu_shared_addr *shared,\n\t\t\t\t u32 instance,\n\t\t\t\t struct vpu_decode_params *params,\n\t\t\t\t u32 update)\n{\n\tif (!params)\n\t\treturn -EINVAL;\n\n\tif (!update)\n\t\treturn vpu_malone_set_params(shared, instance, params);\n\telse\n\t\treturn vpu_malone_update_params(shared, instance, params);\n}\n\nstatic struct vpu_pair malone_cmds[] = {\n\t{VPU_CMD_ID_NOOP, VID_API_CMD_NULL},\n\t{VPU_CMD_ID_START, VID_API_CMD_START},\n\t{VPU_CMD_ID_STOP, VID_API_CMD_STOP},\n\t{VPU_CMD_ID_ABORT, VID_API_CMD_ABORT},\n\t{VPU_CMD_ID_RST_BUF, VID_API_CMD_RST_BUF},\n\t{VPU_CMD_ID_SNAPSHOT, VID_API_CMD_SNAPSHOT},\n\t{VPU_CMD_ID_FIRM_RESET, VID_API_CMD_FIRM_RESET},\n\t{VPU_CMD_ID_FS_ALLOC, VID_API_CMD_FS_ALLOC},\n\t{VPU_CMD_ID_FS_RELEASE, VID_API_CMD_FS_RELEASE},\n\t{VPU_CMD_ID_TIMESTAMP, VID_API_CMD_TS},\n\t{VPU_CMD_ID_DEBUG, VID_API_CMD_FW_STATUS},\n};\n\nstatic struct vpu_pair malone_msgs[] = {\n\t{VPU_MSG_ID_RESET_DONE, VID_API_EVENT_RESET_DONE},\n\t{VPU_MSG_ID_START_DONE, VID_API_EVENT_START_DONE},\n\t{VPU_MSG_ID_STOP_DONE, VID_API_EVENT_STOPPED},\n\t{VPU_MSG_ID_ABORT_DONE, VID_API_EVENT_ABORT_DONE},\n\t{VPU_MSG_ID_BUF_RST, VID_API_EVENT_STR_BUF_RST},\n\t{VPU_MSG_ID_PIC_EOS, VID_API_EVENT_FINISHED},\n\t{VPU_MSG_ID_SEQ_HDR_FOUND, VID_API_EVENT_SEQ_HDR_FOUND},\n\t{VPU_MSG_ID_RES_CHANGE, VID_API_EVENT_RES_CHANGE},\n\t{VPU_MSG_ID_PIC_HDR_FOUND, VID_API_EVENT_PIC_HDR_FOUND},\n\t{VPU_MSG_ID_PIC_DECODED, VID_API_EVENT_PIC_DECODED},\n\t{VPU_MSG_ID_DEC_DONE, VID_API_EVENT_FRAME_BUFF_RDY},\n\t{VPU_MSG_ID_FRAME_REQ, VID_API_EVENT_REQ_FRAME_BUFF},\n\t{VPU_MSG_ID_FRAME_RELEASE, VID_API_EVENT_REL_FRAME_BUFF},\n\t{VPU_MSG_ID_FIFO_LOW, VID_API_EVENT_FIFO_LOW},\n\t{VPU_MSG_ID_BS_ERROR, VID_API_EVENT_BS_ERROR},\n\t{VPU_MSG_ID_UNSUPPORTED, VID_API_EVENT_UNSUPPORTED_STREAM},\n\t{VPU_MSG_ID_FIRMWARE_XCPT, VID_API_EVENT_FIRMWARE_XCPT},\n\t{VPU_MSG_ID_PIC_SKIPPED, VID_API_EVENT_PIC_SKIPPED},\n\t{VPU_MSG_ID_DBG_MSG, VID_API_EVENT_DBG_MSG_DEC},\n};\n\nstatic void vpu_malone_pack_fs_alloc(struct vpu_rpc_event *pkt,\n\t\t\t\t     struct vpu_fs_info *fs)\n{\n\tconst u32 fs_type[] = {\n\t\t[MEM_RES_FRAME] = 0,\n\t\t[MEM_RES_MBI] = 1,\n\t\t[MEM_RES_DCP] = 2,\n\t};\n\n\tpkt->hdr.num = 7;\n\tpkt->data[0] = fs->id | (fs->tag << 24);\n\tpkt->data[1] = fs->luma_addr;\n\tif (fs->type == MEM_RES_FRAME) {\n\t\t \n\t\tif (fs->luma_addr == fs->chroma_addr)\n\t\t\tfs->chroma_addr = fs->luma_addr + fs->luma_size;\n\t\tpkt->data[2] = fs->luma_addr + fs->luma_size / 2;\n\t\tpkt->data[3] = fs->chroma_addr;\n\t\tpkt->data[4] = fs->chroma_addr + fs->chromau_size / 2;\n\t\tpkt->data[5] = fs->bytesperline;\n\t} else {\n\t\tpkt->data[2] = fs->luma_size;\n\t\tpkt->data[3] = 0;\n\t\tpkt->data[4] = 0;\n\t\tpkt->data[5] = 0;\n\t}\n\tpkt->data[6] = fs_type[fs->type];\n}\n\nstatic void vpu_malone_pack_fs_release(struct vpu_rpc_event *pkt,\n\t\t\t\t       struct vpu_fs_info *fs)\n{\n\tpkt->hdr.num = 1;\n\tpkt->data[0] = fs->id | (fs->tag << 24);\n}\n\nstatic void vpu_malone_pack_timestamp(struct vpu_rpc_event *pkt,\n\t\t\t\t      struct vpu_ts_info *info)\n{\n\tstruct timespec64 ts = ns_to_timespec64(info->timestamp);\n\n\tpkt->hdr.num = 3;\n\n\tpkt->data[0] = ts.tv_sec;\n\tpkt->data[1] = ts.tv_nsec;\n\tpkt->data[2] = info->size;\n}\n\nint vpu_malone_pack_cmd(struct vpu_rpc_event *pkt, u32 index, u32 id, void *data)\n{\n\tint ret;\n\n\tret = vpu_find_dst_by_src(malone_cmds, ARRAY_SIZE(malone_cmds), id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpkt->hdr.id = ret;\n\tpkt->hdr.num = 0;\n\tpkt->hdr.index = index;\n\n\tswitch (id) {\n\tcase VPU_CMD_ID_FS_ALLOC:\n\t\tvpu_malone_pack_fs_alloc(pkt, data);\n\t\tbreak;\n\tcase VPU_CMD_ID_FS_RELEASE:\n\t\tvpu_malone_pack_fs_release(pkt, data);\n\t\tbreak;\n\tcase VPU_CMD_ID_TIMESTAMP:\n\t\tvpu_malone_pack_timestamp(pkt, data);\n\t\tbreak;\n\t}\n\n\tpkt->hdr.index = index;\n\treturn 0;\n}\n\nint vpu_malone_convert_msg_id(u32 id)\n{\n\treturn vpu_find_src_by_dst(malone_msgs, ARRAY_SIZE(malone_msgs), id);\n}\n\nstatic void vpu_malone_fill_planes(struct vpu_dec_codec_info *info)\n{\n\tu32 interlaced = info->progressive ? 0 : 1;\n\n\tinfo->bytesperline[0] = 0;\n\tinfo->sizeimage[0] = vpu_helper_get_plane_size(info->pixfmt,\n\t\t\t\t\t\t       info->decoded_width,\n\t\t\t\t\t\t       info->decoded_height,\n\t\t\t\t\t\t       0,\n\t\t\t\t\t\t       info->stride,\n\t\t\t\t\t\t       interlaced,\n\t\t\t\t\t\t       &info->bytesperline[0]);\n\tinfo->bytesperline[1] = 0;\n\tinfo->sizeimage[1] = vpu_helper_get_plane_size(info->pixfmt,\n\t\t\t\t\t\t       info->decoded_width,\n\t\t\t\t\t\t       info->decoded_height,\n\t\t\t\t\t\t       1,\n\t\t\t\t\t\t       info->stride,\n\t\t\t\t\t\t       interlaced,\n\t\t\t\t\t\t       &info->bytesperline[1]);\n}\n\nstatic void vpu_malone_init_seq_hdr(struct vpu_dec_codec_info *info)\n{\n\tu32 chunks = info->num_dfe_area >> MALONE_DCP_CHUNK_BIT;\n\n\tvpu_malone_fill_planes(info);\n\n\tinfo->mbi_size = (info->sizeimage[0] + info->sizeimage[1]) >> 2;\n\tinfo->mbi_size = ALIGN(info->mbi_size, MALONE_ALIGN_MBI);\n\n\tinfo->dcp_size = MALONE_DCP_SIZE_MAX;\n\tif (chunks) {\n\t\tu32 mb_num;\n\t\tu32 mb_w;\n\t\tu32 mb_h;\n\n\t\tmb_w = DIV_ROUND_UP(info->decoded_width, 16);\n\t\tmb_h = DIV_ROUND_UP(info->decoded_height, 16);\n\t\tmb_num = mb_w * mb_h;\n\t\tinfo->dcp_size = mb_num * MALONE_DCP_FIXED_MB_ALLOC * chunks;\n\t\tinfo->dcp_size = clamp_t(u32, info->dcp_size,\n\t\t\t\t\t MALONE_DCP_SIZE_MIN, MALONE_DCP_SIZE_MAX);\n\t}\n}\n\nstatic void vpu_malone_unpack_seq_hdr(struct vpu_rpc_event *pkt,\n\t\t\t\t      struct vpu_dec_codec_info *info)\n{\n\tinfo->num_ref_frms = pkt->data[0];\n\tinfo->num_dpb_frms = pkt->data[1];\n\tinfo->num_dfe_area = pkt->data[2];\n\tinfo->progressive = pkt->data[3];\n\tinfo->width = pkt->data[5];\n\tinfo->height = pkt->data[4];\n\tinfo->decoded_width = pkt->data[12];\n\tinfo->decoded_height = pkt->data[11];\n\tinfo->frame_rate.numerator = 1000;\n\tinfo->frame_rate.denominator = pkt->data[8];\n\tinfo->dsp_asp_ratio = pkt->data[9];\n\tinfo->level_idc = pkt->data[10];\n\tinfo->bit_depth_luma = pkt->data[13];\n\tinfo->bit_depth_chroma = pkt->data[14];\n\tinfo->chroma_fmt = pkt->data[15];\n\tinfo->color_primaries = vpu_color_cvrt_primaries_i2v(pkt->data[16]);\n\tinfo->transfer_chars = vpu_color_cvrt_transfers_i2v(pkt->data[17]);\n\tinfo->matrix_coeffs = vpu_color_cvrt_matrix_i2v(pkt->data[18]);\n\tinfo->full_range = vpu_color_cvrt_full_range_i2v(pkt->data[19]);\n\tinfo->vui_present = pkt->data[20];\n\tinfo->mvc_num_views = pkt->data[21];\n\tinfo->offset_x = pkt->data[23];\n\tinfo->offset_y = pkt->data[25];\n\tinfo->tag = pkt->data[27];\n\tif (info->bit_depth_luma > 8)\n\t\tinfo->pixfmt = V4L2_PIX_FMT_NV12M_10BE_8L128;\n\telse\n\t\tinfo->pixfmt = V4L2_PIX_FMT_NV12M_8L128;\n\tif (info->frame_rate.numerator && info->frame_rate.denominator) {\n\t\tunsigned long n, d;\n\n\t\trational_best_approximation(info->frame_rate.numerator,\n\t\t\t\t\t    info->frame_rate.denominator,\n\t\t\t\t\t    info->frame_rate.numerator,\n\t\t\t\t\t    info->frame_rate.denominator,\n\t\t\t\t\t    &n, &d);\n\t\tinfo->frame_rate.numerator = n;\n\t\tinfo->frame_rate.denominator = d;\n\t}\n\tvpu_malone_init_seq_hdr(info);\n}\n\nstatic void vpu_malone_unpack_pic_info(struct vpu_rpc_event *pkt,\n\t\t\t\t       struct vpu_dec_pic_info *info)\n{\n\tinfo->id = pkt->data[7];\n\tinfo->luma = pkt->data[0];\n\tinfo->start = pkt->data[10];\n\tinfo->end = pkt->data[12];\n\tinfo->pic_size = pkt->data[11];\n\tinfo->stride = pkt->data[5];\n\tinfo->consumed_count = pkt->data[13];\n\tif (info->id == MALONE_SKIPPED_FRAME_ID)\n\t\tinfo->skipped = 1;\n\telse\n\t\tinfo->skipped = 0;\n}\n\nstatic void vpu_malone_unpack_req_frame(struct vpu_rpc_event *pkt,\n\t\t\t\t\tstruct vpu_fs_info *info)\n{\n\tinfo->type = pkt->data[1];\n}\n\nstatic void vpu_malone_unpack_rel_frame(struct vpu_rpc_event *pkt,\n\t\t\t\t\tstruct vpu_fs_info *info)\n{\n\tinfo->id = pkt->data[0];\n\tinfo->type = pkt->data[1];\n\tinfo->not_displayed = pkt->data[2];\n}\n\nstatic void vpu_malone_unpack_buff_rdy(struct vpu_rpc_event *pkt,\n\t\t\t\t       struct vpu_dec_pic_info *info)\n{\n\tstruct timespec64 ts = { pkt->data[9], pkt->data[10] };\n\n\tinfo->id = pkt->data[0];\n\tinfo->luma = pkt->data[1];\n\tinfo->stride = pkt->data[3];\n\tif (info->id == MALONE_SKIPPED_FRAME_ID)\n\t\tinfo->skipped = 1;\n\telse\n\t\tinfo->skipped = 0;\n\n\tinfo->timestamp = timespec64_to_ns(&ts);\n}\n\nint vpu_malone_unpack_msg_data(struct vpu_rpc_event *pkt, void *data)\n{\n\tif (!pkt || !data)\n\t\treturn -EINVAL;\n\n\tswitch (pkt->hdr.id) {\n\tcase VID_API_EVENT_SEQ_HDR_FOUND:\n\t\tvpu_malone_unpack_seq_hdr(pkt, data);\n\t\tbreak;\n\tcase VID_API_EVENT_PIC_DECODED:\n\t\tvpu_malone_unpack_pic_info(pkt, data);\n\t\tbreak;\n\tcase VID_API_EVENT_REQ_FRAME_BUFF:\n\t\tvpu_malone_unpack_req_frame(pkt, data);\n\t\tbreak;\n\tcase VID_API_EVENT_REL_FRAME_BUFF:\n\t\tvpu_malone_unpack_rel_frame(pkt, data);\n\t\tbreak;\n\tcase VID_API_EVENT_FRAME_BUFF_RDY:\n\t\tvpu_malone_unpack_buff_rdy(pkt, data);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct malone_padding_scode padding_scodes[] = {\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_H264,        {0x0B010000, 0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_H264_MVC,    {0x0B010000, 0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_HEVC,        {0x4A010000, 0x20}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_VC1_ANNEX_G, {0x0a010000, 0x0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_VC1_ANNEX_L, {0x0a010000, 0x0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_MPEG2,       {0xCC010000, 0x0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_MPEG4,       {0xb1010000, 0x0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_XVID,        {0xb1010000, 0x0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_H263,        {0xb1010000, 0x0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_VP8,         {0x34010000, 0x0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_SPK,         {0x34010000, 0x0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_RV30,        {0x34010000, 0x0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_RV40,        {0x34010000, 0x0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_JPEG,        {0xefff0000, 0x0}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_H264,        {0x0B010000, 0}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_H264_MVC,    {0x0B010000, 0}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_HEVC,        {0x4A010000, 0x20}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_VC1_ANNEX_G, {0x0a010000, 0x0}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_VC1_ANNEX_L, {0x0a010000, 0x0}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_MPEG2,       {0xb7010000, 0x0}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_MPEG4,       {0xb1010000, 0x0}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_XVID,        {0xb1010000, 0x0}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_H263,        {0xb1010000, 0x0}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_VP8,         {0x34010000, 0x0}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_SPK,         {0x34010000, 0x0}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_RV30,        {0x34010000, 0x0}},\n\t{SCODE_PADDING_ABORT,    V4L2_PIX_FMT_RV40,        {0x34010000, 0x0}},\n\t{SCODE_PADDING_EOS,      V4L2_PIX_FMT_JPEG,        {0x0, 0x0}},\n\t{SCODE_PADDING_BUFFLUSH, V4L2_PIX_FMT_H264,        {0x15010000, 0x0}},\n\t{SCODE_PADDING_BUFFLUSH, V4L2_PIX_FMT_H264_MVC,    {0x15010000, 0x0}},\n};\n\nstatic const struct malone_padding_scode padding_scode_dft = {0x0, 0x0};\n\nstatic const struct malone_padding_scode *get_padding_scode(u32 type, u32 fmt)\n{\n\tconst struct malone_padding_scode *s;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(padding_scodes); i++) {\n\t\ts = &padding_scodes[i];\n\n\t\tif (s->scode_type == type && s->pixelformat == fmt)\n\t\t\treturn s;\n\t}\n\n\tif (type != SCODE_PADDING_BUFFLUSH)\n\t\treturn &padding_scode_dft;\n\n\treturn NULL;\n}\n\nstatic int vpu_malone_add_padding_scode(struct vpu_buffer *stream_buffer,\n\t\t\t\t\tstruct vpu_malone_str_buffer __iomem *str_buf,\n\t\t\t\t\tu32 pixelformat, u32 scode_type)\n{\n\tu32 wptr;\n\tint size;\n\tint total_size = 0;\n\tconst struct malone_padding_scode *ps;\n\tconst u32 padding_size = 4096;\n\tint ret;\n\n\tps = get_padding_scode(scode_type, pixelformat);\n\tif (!ps)\n\t\treturn -EINVAL;\n\n\twptr = readl(&str_buf->wptr);\n\tif (wptr < stream_buffer->phys || wptr > stream_buffer->phys + stream_buffer->length)\n\t\treturn -EINVAL;\n\tif (wptr == stream_buffer->phys + stream_buffer->length)\n\t\twptr = stream_buffer->phys;\n\tsize = ALIGN(wptr, 4) - wptr;\n\tif (size)\n\t\tvpu_helper_memset_stream_buffer(stream_buffer, &wptr, 0, size);\n\ttotal_size += size;\n\n\tsize = sizeof(ps->data);\n\tret = vpu_helper_copy_to_stream_buffer(stream_buffer, &wptr, size, (void *)ps->data);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\ttotal_size += size;\n\n\tsize = padding_size - sizeof(ps->data);\n\tvpu_helper_memset_stream_buffer(stream_buffer, &wptr, 0, size);\n\ttotal_size += size;\n\n\tvpu_malone_update_wptr(str_buf, wptr);\n\treturn total_size;\n}\n\nint vpu_malone_add_scode(struct vpu_shared_addr *shared,\n\t\t\t u32 instance,\n\t\t\t struct vpu_buffer *stream_buffer,\n\t\t\t u32 pixelformat,\n\t\t\t u32 scode_type)\n{\n\tstruct vpu_dec_ctrl *hc = shared->priv;\n\tstruct vpu_malone_str_buffer __iomem *str_buf = hc->str_buf[instance];\n\tint ret = -EINVAL;\n\n\tswitch (scode_type) {\n\tcase SCODE_PADDING_EOS:\n\tcase SCODE_PADDING_ABORT:\n\tcase SCODE_PADDING_BUFFLUSH:\n\t\tret = vpu_malone_add_padding_scode(stream_buffer, str_buf, pixelformat, scode_type);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n#define MALONE_PAYLOAD_HEADER_SIZE\t\t16\n#define MALONE_CODEC_VERSION_ID\t\t\t0x1\n#define MALONE_CODEC_ID_VC1_SIMPLE\t\t0x10\n#define MALONE_CODEC_ID_VC1_MAIN\t\t0x11\n#define MALONE_CODEC_ID_ARV8\t\t\t0x28\n#define MALONE_CODEC_ID_ARV9\t\t\t0x29\n#define MALONE_CODEC_ID_VP6\t\t\t0x36\n#define MALONE_CODEC_ID_VP8\t\t\t0x36\n#define MALONE_CODEC_ID_DIVX3\t\t\t0x38\n#define MALONE_CODEC_ID_SPK\t\t\t0x39\n\n#define MALONE_VP8_IVF_SEQ_HEADER_LEN\t\t32\n#define MALONE_VP8_IVF_FRAME_HEADER_LEN\t\t8\n\n#define MALONE_VC1_RCV_CODEC_V1_VERSION\t\t0x85\n#define MALONE_VC1_RCV_CODEC_V2_VERSION\t\t0xC5\n#define MALONE_VC1_RCV_NUM_FRAMES\t\t0xFF\n#define MALONE_VC1_RCV_SEQ_EXT_DATA_SIZE\t4\n#define MALONE_VC1_RCV_SEQ_HEADER_LEN\t\t20\n#define MALONE_VC1_RCV_PIC_HEADER_LEN\t\t4\n#define MALONE_VC1_NAL_HEADER_LEN\t\t4\n#define MALONE_VC1_CONTAIN_NAL(data)\t\t(((data) & 0x00FFFFFF) == 0x00010000)\n\nstatic void set_payload_hdr(u8 *dst, u32 scd_type, u32 codec_id,\n\t\t\t    u32 buffer_size, u32 width, u32 height)\n{\n\tunsigned int payload_size;\n\t \n\tpayload_size = buffer_size + 12;\n\n\tdst[0] = 0x00;\n\tdst[1] = 0x00;\n\tdst[2] = 0x01;\n\tdst[3] = scd_type;\n\n\t \n\tdst[4] = ((payload_size >> 16) & 0xff);\n\tdst[5] = ((payload_size >> 8) & 0xff);\n\tdst[6] = 0x4e;\n\tdst[7] = ((payload_size >> 0) & 0xff);\n\n\t \n\tdst[8] = codec_id;\n\tdst[9] = MALONE_CODEC_VERSION_ID;\n\n\t \n\tdst[10] = ((width >> 8) & 0xff);\n\tdst[11] = ((width >> 0) & 0xff);\n\tdst[12] = 0x58;\n\n\t \n\tdst[13] = ((height >> 8) & 0xff);\n\tdst[14] = ((height >> 0) & 0xff);\n\tdst[15] = 0x50;\n}\n\nstatic void set_vp8_ivf_seqhdr(u8 *dst, u32 width, u32 height)\n{\n\t \n\tdst[0] = 0x44;\n\tdst[1] = 0x4b;\n\tdst[2] = 0x49;\n\tdst[3] = 0x46;\n\t \n\tdst[4] = 0x00;\n\tdst[5] = 0x00;\n\t \n\tdst[6] = MALONE_VP8_IVF_SEQ_HEADER_LEN;\n\tdst[7] = MALONE_VP8_IVF_SEQ_HEADER_LEN >> 8;\n\t \n\tdst[8] = 0x56;\n\tdst[9] = 0x50;\n\tdst[10] = 0x38;\n\tdst[11] = 0x30;\n\t \n\tdst[12] = width;\n\tdst[13] = width >> 8;\n\t \n\tdst[14] = height;\n\tdst[15] = height >> 8;\n\t \n\tdst[16] = 0xe8;\n\tdst[17] = 0x03;\n\tdst[18] = 0x00;\n\tdst[19] = 0x00;\n\t \n\tdst[20] = 0x01;\n\tdst[21] = 0x00;\n\tdst[22] = 0x00;\n\tdst[23] = 0x00;\n\t \n\tdst[24] = 0xdf;\n\tdst[25] = 0xf9;\n\tdst[26] = 0x09;\n\tdst[27] = 0x00;\n\t \n}\n\nstatic void set_vp8_ivf_pichdr(u8 *dst, u32 frame_size)\n{\n\t \n}\n\nstatic void set_vc1_rcv_seqhdr(u8 *dst, u8 *src, u32 width, u32 height)\n{\n\tu32 frames = MALONE_VC1_RCV_NUM_FRAMES;\n\tu32 ext_data_size = MALONE_VC1_RCV_SEQ_EXT_DATA_SIZE;\n\n\t \n\tdst[0] = frames;\n\tdst[1] = frames >> 8;\n\tdst[2] = frames >> 16;\n\n\t \n\tdst[3] = MALONE_VC1_RCV_CODEC_V1_VERSION;\n\n\t \n\tdst[4] = ext_data_size;\n\tdst[5] = ext_data_size >> 8;\n\tdst[6] = ext_data_size >> 16;\n\tdst[7] = ext_data_size >> 24;\n\t \n\tdst[8] = src[0];\n\tdst[9] = src[1];\n\tdst[10] = src[2];\n\tdst[11] = src[3];\n\n\t \n\tdst[12] = height;\n\tdst[13] = (height >> 8) & 0xff;\n\tdst[14] = (height >> 16) & 0xff;\n\tdst[15] = (height >> 24) & 0xff;\n\t \n\tdst[16] = width;\n\tdst[17] = (width >> 8) & 0xff;\n\tdst[18] = (width >> 16) & 0xff;\n\tdst[19] = (width >> 24) & 0xff;\n}\n\nstatic void set_vc1_rcv_pichdr(u8 *dst, u32 buffer_size)\n{\n\tdst[0] = buffer_size;\n\tdst[1] = buffer_size >> 8;\n\tdst[2] = buffer_size >> 16;\n\tdst[3] = buffer_size >> 24;\n}\n\nstatic void create_vc1_nal_pichdr(u8 *dst)\n{\n\t \n\tdst[0] = 0x0;\n\tdst[1] = 0x0;\n\tdst[2] = 0x01;\n\tdst[3] = 0x0D;\n}\n\nstatic int vpu_malone_insert_scode_seq(struct malone_scode_t *scode, u32 codec_id, u32 ext_size)\n{\n\tu8 hdr[MALONE_PAYLOAD_HEADER_SIZE];\n\tint ret;\n\n\tset_payload_hdr(hdr,\n\t\t\tSCODE_SEQUENCE,\n\t\t\tcodec_id,\n\t\t\text_size,\n\t\t\tscode->inst->out_format.width,\n\t\t\tscode->inst->out_format.height);\n\tret = vpu_helper_copy_to_stream_buffer(&scode->inst->stream_buffer,\n\t\t\t\t\t       &scode->wptr,\n\t\t\t\t\t       sizeof(hdr),\n\t\t\t\t\t       hdr);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sizeof(hdr);\n}\n\nstatic int vpu_malone_insert_scode_pic(struct malone_scode_t *scode, u32 codec_id, u32 ext_size)\n{\n\tu8 hdr[MALONE_PAYLOAD_HEADER_SIZE];\n\tint ret;\n\n\tset_payload_hdr(hdr,\n\t\t\tSCODE_PICTURE,\n\t\t\tcodec_id,\n\t\t\text_size + vb2_get_plane_payload(scode->vb, 0),\n\t\t\tscode->inst->out_format.width,\n\t\t\tscode->inst->out_format.height);\n\tret = vpu_helper_copy_to_stream_buffer(&scode->inst->stream_buffer,\n\t\t\t\t\t       &scode->wptr,\n\t\t\t\t\t       sizeof(hdr),\n\t\t\t\t\t       hdr);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sizeof(hdr);\n}\n\nstatic int vpu_malone_insert_scode_vc1_g_seq(struct malone_scode_t *scode)\n{\n\tif (!scode->inst->total_input_count)\n\t\treturn 0;\n\tif (vpu_vb_is_codecconfig(to_vb2_v4l2_buffer(scode->vb)))\n\t\tscode->need_data = 0;\n\treturn 0;\n}\n\nstatic int vpu_malone_insert_scode_vc1_g_pic(struct malone_scode_t *scode)\n{\n\tstruct vb2_v4l2_buffer *vbuf;\n\tu8 nal_hdr[MALONE_VC1_NAL_HEADER_LEN];\n\tu32 *data = NULL;\n\tint ret;\n\n\tvbuf = to_vb2_v4l2_buffer(scode->vb);\n\tdata = vb2_plane_vaddr(scode->vb, 0);\n\n\tif (scode->inst->total_input_count == 0 || vpu_vb_is_codecconfig(vbuf))\n\t\treturn 0;\n\tif (MALONE_VC1_CONTAIN_NAL(*data))\n\t\treturn 0;\n\n\tcreate_vc1_nal_pichdr(nal_hdr);\n\tret = vpu_helper_copy_to_stream_buffer(&scode->inst->stream_buffer,\n\t\t\t\t\t       &scode->wptr,\n\t\t\t\t\t       sizeof(nal_hdr),\n\t\t\t\t\t       nal_hdr);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn sizeof(nal_hdr);\n}\n\nstatic int vpu_malone_insert_scode_vc1_l_seq(struct malone_scode_t *scode)\n{\n\tint ret;\n\tint size = 0;\n\tu8 rcv_seqhdr[MALONE_VC1_RCV_SEQ_HEADER_LEN];\n\n\tif (vpu_vb_is_codecconfig(to_vb2_v4l2_buffer(scode->vb)))\n\t\tscode->need_data = 0;\n\tif (scode->inst->total_input_count)\n\t\treturn 0;\n\tscode->need_data = 0;\n\n\tret = vpu_malone_insert_scode_seq(scode, MALONE_CODEC_ID_VC1_SIMPLE, sizeof(rcv_seqhdr));\n\tif (ret < 0)\n\t\treturn ret;\n\tsize = ret;\n\n\tset_vc1_rcv_seqhdr(rcv_seqhdr,\n\t\t\t   vb2_plane_vaddr(scode->vb, 0),\n\t\t\t   scode->inst->out_format.width,\n\t\t\t   scode->inst->out_format.height);\n\tret = vpu_helper_copy_to_stream_buffer(&scode->inst->stream_buffer,\n\t\t\t\t\t       &scode->wptr,\n\t\t\t\t\t       sizeof(rcv_seqhdr),\n\t\t\t\t\t       rcv_seqhdr);\n\n\tif (ret < 0)\n\t\treturn ret;\n\tsize += sizeof(rcv_seqhdr);\n\treturn size;\n}\n\nstatic int vpu_malone_insert_scode_vc1_l_pic(struct malone_scode_t *scode)\n{\n\tint ret;\n\tint size = 0;\n\tu8 rcv_pichdr[MALONE_VC1_RCV_PIC_HEADER_LEN];\n\n\tret = vpu_malone_insert_scode_pic(scode, MALONE_CODEC_ID_VC1_SIMPLE,\n\t\t\t\t\t  sizeof(rcv_pichdr));\n\tif (ret < 0)\n\t\treturn ret;\n\tsize = ret;\n\n\tset_vc1_rcv_pichdr(rcv_pichdr, vb2_get_plane_payload(scode->vb, 0));\n\tret = vpu_helper_copy_to_stream_buffer(&scode->inst->stream_buffer,\n\t\t\t\t\t       &scode->wptr,\n\t\t\t\t\t       sizeof(rcv_pichdr),\n\t\t\t\t\t       rcv_pichdr);\n\tif (ret < 0)\n\t\treturn ret;\n\tsize += sizeof(rcv_pichdr);\n\treturn size;\n}\n\nstatic int vpu_malone_insert_scode_vp8_seq(struct malone_scode_t *scode)\n{\n\tint ret;\n\tint size = 0;\n\tu8 ivf_hdr[MALONE_VP8_IVF_SEQ_HEADER_LEN];\n\n\tret = vpu_malone_insert_scode_seq(scode, MALONE_CODEC_ID_VP8, sizeof(ivf_hdr));\n\tif (ret < 0)\n\t\treturn ret;\n\tsize = ret;\n\n\tset_vp8_ivf_seqhdr(ivf_hdr,\n\t\t\t   scode->inst->out_format.width,\n\t\t\t   scode->inst->out_format.height);\n\tret = vpu_helper_copy_to_stream_buffer(&scode->inst->stream_buffer,\n\t\t\t\t\t       &scode->wptr,\n\t\t\t\t\t       sizeof(ivf_hdr),\n\t\t\t\t\t       ivf_hdr);\n\tif (ret < 0)\n\t\treturn ret;\n\tsize += sizeof(ivf_hdr);\n\n\treturn size;\n}\n\nstatic int vpu_malone_insert_scode_vp8_pic(struct malone_scode_t *scode)\n{\n\tint ret;\n\tint size = 0;\n\tu8 ivf_hdr[MALONE_VP8_IVF_FRAME_HEADER_LEN] = {0};\n\n\tret = vpu_malone_insert_scode_pic(scode, MALONE_CODEC_ID_VP8, sizeof(ivf_hdr));\n\tif (ret < 0)\n\t\treturn ret;\n\tsize = ret;\n\n\tset_vp8_ivf_pichdr(ivf_hdr, vb2_get_plane_payload(scode->vb, 0));\n\tret = vpu_helper_copy_to_stream_buffer(&scode->inst->stream_buffer,\n\t\t\t\t\t       &scode->wptr,\n\t\t\t\t\t       sizeof(ivf_hdr),\n\t\t\t\t\t       ivf_hdr);\n\tif (ret < 0)\n\t\treturn ret;\n\tsize += sizeof(ivf_hdr);\n\n\treturn size;\n}\n\nstatic int vpu_malone_insert_scode_spk_seq(struct malone_scode_t *scode)\n{\n\treturn vpu_malone_insert_scode_seq(scode, MALONE_CODEC_ID_SPK, 0);\n}\n\nstatic int vpu_malone_insert_scode_spk_pic(struct malone_scode_t *scode)\n{\n\treturn vpu_malone_insert_scode_pic(scode, MALONE_CODEC_ID_SPK, 0);\n}\n\nstatic const struct malone_scode_handler scode_handlers[] = {\n\t{\n\t\t \n\t\t.pixelformat = V4L2_PIX_FMT_VC1_ANNEX_L,\n\t\t.insert_scode_seq = vpu_malone_insert_scode_vc1_l_seq,\n\t\t.insert_scode_pic = vpu_malone_insert_scode_vc1_l_pic,\n\t},\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_VC1_ANNEX_G,\n\t\t.insert_scode_seq = vpu_malone_insert_scode_vc1_g_seq,\n\t\t.insert_scode_pic = vpu_malone_insert_scode_vc1_g_pic,\n\t},\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_VP8,\n\t\t.insert_scode_seq = vpu_malone_insert_scode_vp8_seq,\n\t\t.insert_scode_pic = vpu_malone_insert_scode_vp8_pic,\n\t},\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_SPK,\n\t\t.insert_scode_seq = vpu_malone_insert_scode_spk_seq,\n\t\t.insert_scode_pic = vpu_malone_insert_scode_spk_pic,\n\t},\n};\n\nstatic const struct malone_scode_handler *get_scode_handler(u32 pixelformat)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(scode_handlers); i++) {\n\t\tif (scode_handlers[i].pixelformat == pixelformat)\n\t\t\treturn &scode_handlers[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int vpu_malone_insert_scode(struct malone_scode_t *scode, u32 type)\n{\n\tconst struct malone_scode_handler *handler;\n\tint ret = 0;\n\n\tif (!scode || !scode->inst || !scode->vb)\n\t\treturn 0;\n\n\tscode->need_data = 1;\n\thandler = get_scode_handler(scode->inst->out_format.pixfmt);\n\tif (!handler)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase SCODE_SEQUENCE:\n\t\tif (handler->insert_scode_seq)\n\t\t\tret = handler->insert_scode_seq(scode);\n\t\tbreak;\n\tcase SCODE_PICTURE:\n\t\tif (handler->insert_scode_pic)\n\t\t\tret = handler->insert_scode_pic(scode);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int vpu_malone_input_frame_data(struct vpu_malone_str_buffer __iomem *str_buf,\n\t\t\t\t       struct vpu_inst *inst, struct vb2_buffer *vb,\n\t\t\t\t       u32 disp_imm)\n{\n\tstruct malone_scode_t scode;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tu32 wptr = readl(&str_buf->wptr);\n\tint size = 0;\n\tint ret = 0;\n\n\t \n\tscode.inst = inst;\n\tscode.vb = vb;\n\tscode.wptr = wptr;\n\tscode.need_data = 1;\n\tif (vbuf->sequence == 0 || vpu_vb_is_codecconfig(vbuf))\n\t\tret = vpu_malone_insert_scode(&scode, SCODE_SEQUENCE);\n\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\tsize += ret;\n\twptr = scode.wptr;\n\tif (!scode.need_data) {\n\t\tvpu_malone_update_wptr(str_buf, wptr);\n\t\treturn size;\n\t}\n\n\tret = vpu_malone_insert_scode(&scode, SCODE_PICTURE);\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\tsize += ret;\n\twptr = scode.wptr;\n\n\tret = vpu_helper_copy_to_stream_buffer(&inst->stream_buffer,\n\t\t\t\t\t       &wptr,\n\t\t\t\t\t       vb2_get_plane_payload(vb, 0),\n\t\t\t\t\t       vb2_plane_vaddr(vb, 0));\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\tsize += vb2_get_plane_payload(vb, 0);\n\n\tvpu_malone_update_wptr(str_buf, wptr);\n\n\tif (disp_imm && !vpu_vb_is_codecconfig(vbuf)) {\n\t\tret = vpu_malone_add_scode(inst->core->iface,\n\t\t\t\t\t   inst->id,\n\t\t\t\t\t   &inst->stream_buffer,\n\t\t\t\t\t   inst->out_format.pixfmt,\n\t\t\t\t\t   SCODE_PADDING_BUFFLUSH);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize += ret;\n\t}\n\n\treturn size;\n}\n\nstatic int vpu_malone_input_stream_data(struct vpu_malone_str_buffer __iomem *str_buf,\n\t\t\t\t\tstruct vpu_inst *inst, struct vb2_buffer *vb)\n{\n\tu32 wptr = readl(&str_buf->wptr);\n\tint ret = 0;\n\n\tret = vpu_helper_copy_to_stream_buffer(&inst->stream_buffer,\n\t\t\t\t\t       &wptr,\n\t\t\t\t\t       vb2_get_plane_payload(vb, 0),\n\t\t\t\t\t       vb2_plane_vaddr(vb, 0));\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\n\tvpu_malone_update_wptr(str_buf, wptr);\n\n\treturn ret;\n}\n\nstatic int vpu_malone_input_ts(struct vpu_inst *inst, s64  timestamp, u32 size)\n{\n\tstruct vpu_ts_info info;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.timestamp = timestamp;\n\tinfo.size = size;\n\n\treturn vpu_session_fill_timestamp(inst, &info);\n}\n\nint vpu_malone_input_frame(struct vpu_shared_addr *shared,\n\t\t\t   struct vpu_inst *inst, struct vb2_buffer *vb)\n{\n\tstruct vpu_dec_ctrl *hc = shared->priv;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct vpu_malone_str_buffer __iomem *str_buf = hc->str_buf[inst->id];\n\tu32 disp_imm = hc->codec_param[inst->id].disp_imm;\n\tu32 size;\n\tint ret;\n\n\tif (vpu_malone_is_non_frame_mode(shared, inst->id))\n\t\tret = vpu_malone_input_stream_data(str_buf, inst, vb);\n\telse\n\t\tret = vpu_malone_input_frame_data(str_buf, inst, vb, disp_imm);\n\tif (ret < 0)\n\t\treturn ret;\n\tsize = ret;\n\n\t \n\tvbuf = to_vb2_v4l2_buffer(vb);\n\tif (vpu_vb_is_codecconfig(vbuf)) {\n\t\tinst->extra_size += size;\n\t\treturn 0;\n\t}\n\tif (inst->extra_size) {\n\t\tsize += inst->extra_size;\n\t\tinst->extra_size = 0;\n\t}\n\n\tret = vpu_malone_input_ts(inst, vb->timestamp, size);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic bool vpu_malone_check_ready(struct vpu_shared_addr *shared, u32 instance)\n{\n\tstruct malone_iface *iface = shared->iface;\n\tstruct vpu_rpc_buffer_desc *desc = &iface->api_cmd_buffer_desc[instance];\n\tu32 size = desc->end - desc->start;\n\tu32 rptr = desc->rptr;\n\tu32 wptr = desc->wptr;\n\tu32 used;\n\n\tif (!size)\n\t\treturn true;\n\n\tused = (wptr + size - rptr) % size;\n\tif (used < (size / 2))\n\t\treturn true;\n\n\treturn false;\n}\n\nbool vpu_malone_is_ready(struct vpu_shared_addr *shared, u32 instance)\n{\n\tu32 cnt = 0;\n\n\twhile (!vpu_malone_check_ready(shared, instance)) {\n\t\tif (cnt > 30)\n\t\t\treturn false;\n\t\tmdelay(1);\n\t\tcnt++;\n\t}\n\treturn true;\n}\n\nint vpu_malone_pre_cmd(struct vpu_shared_addr *shared, u32 instance)\n{\n\tif (!vpu_malone_is_ready(shared, instance))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint vpu_malone_post_cmd(struct vpu_shared_addr *shared, u32 instance)\n{\n\tstruct malone_iface *iface = shared->iface;\n\tstruct vpu_rpc_buffer_desc *desc = &iface->api_cmd_buffer_desc[instance];\n\n\tdesc->wptr++;\n\tif (desc->wptr == desc->end)\n\t\tdesc->wptr = desc->start;\n\n\treturn 0;\n}\n\nint vpu_malone_init_instance(struct vpu_shared_addr *shared, u32 instance)\n{\n\tstruct malone_iface *iface = shared->iface;\n\tstruct vpu_rpc_buffer_desc *desc = &iface->api_cmd_buffer_desc[instance];\n\n\tdesc->wptr = desc->rptr;\n\tif (desc->wptr == desc->end)\n\t\tdesc->wptr = desc->start;\n\n\treturn 0;\n}\n\nu32 vpu_malone_get_max_instance_count(struct vpu_shared_addr *shared)\n{\n\tstruct malone_iface *iface = shared->iface;\n\n\treturn iface->max_streams;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}