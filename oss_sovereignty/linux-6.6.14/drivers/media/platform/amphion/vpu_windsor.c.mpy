{
  "module_name": "vpu_windsor.c",
  "hash_id": "5d4499c2171c384b5e82f3d4db4856bed4a7019dd4d28fc0302b384e192bea23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/amphion/vpu_windsor.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interconnect.h>\n#include <linux/ioctl.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/time64.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n#include \"vpu.h\"\n#include \"vpu_rpc.h\"\n#include \"vpu_defs.h\"\n#include \"vpu_helpers.h\"\n#include \"vpu_cmds.h\"\n#include \"vpu_v4l2.h\"\n#include \"vpu_imx8q.h\"\n#include \"vpu_windsor.h\"\n\n#define CMD_SIZE\t\t\t\t2560\n#define MSG_SIZE\t\t\t\t25600\n#define WINDSOR_USER_DATA_WORDS\t\t\t16\n#define WINDSOR_MAX_SRC_FRAMES\t\t\t0x6\n#define WINDSOR_MAX_REF_FRAMES\t\t\t0x3\n#define WINDSOR_BITRATE_UNIT\t\t\t1024\n#define WINDSOR_H264_EXTENDED_SAR\t\t255\n\nenum {\n\tGTB_ENC_CMD_NOOP        = 0x0,\n\tGTB_ENC_CMD_STREAM_START,\n\tGTB_ENC_CMD_FRAME_ENCODE,\n\tGTB_ENC_CMD_FRAME_SKIP,\n\tGTB_ENC_CMD_STREAM_STOP,\n\tGTB_ENC_CMD_PARAMETER_UPD,\n\tGTB_ENC_CMD_TERMINATE,\n\tGTB_ENC_CMD_SNAPSHOT,\n\tGTB_ENC_CMD_ROLL_SNAPSHOT,\n\tGTB_ENC_CMD_LOCK_SCHEDULER,\n\tGTB_ENC_CMD_UNLOCK_SCHEDULER,\n\tGTB_ENC_CMD_CONFIGURE_CODEC,\n\tGTB_ENC_CMD_DEAD_MARK,\n\tGTB_ENC_CMD_FIRM_RESET,\n\tGTB_ENC_CMD_FW_STATUS,\n\tGTB_ENC_CMD_RESERVED\n};\n\nenum {\n\tVID_API_EVENT_UNDEFINED = 0x0,\n\tVID_API_ENC_EVENT_RESET_DONE = 0x1,\n\tVID_API_ENC_EVENT_START_DONE,\n\tVID_API_ENC_EVENT_STOP_DONE,\n\tVID_API_ENC_EVENT_TERMINATE_DONE,\n\tVID_API_ENC_EVENT_FRAME_INPUT_DONE,\n\tVID_API_ENC_EVENT_FRAME_DONE,\n\tVID_API_ENC_EVENT_FRAME_RELEASE,\n\tVID_API_ENC_EVENT_PARA_UPD_DONE,\n\tVID_API_ENC_EVENT_MEM_REQUEST,\n\tVID_API_ENC_EVENT_FIRMWARE_XCPT,\n\tVID_API_ENC_EVENT_RESERVED\n};\n\nenum {\n\tMEDIAIP_ENC_PIC_TYPE_B_FRAME = 0,\n\tMEDIAIP_ENC_PIC_TYPE_P_FRAME,\n\tMEDIAIP_ENC_PIC_TYPE_I_FRAME,\n\tMEDIAIP_ENC_PIC_TYPE_IDR_FRAME,\n\tMEDIAIP_ENC_PIC_TYPE_BI_FRAME\n};\n\nstruct windsor_iface {\n\tu32 exec_base_addr;\n\tu32 exec_area_size;\n\tstruct vpu_rpc_buffer_desc cmd_buffer_desc;\n\tstruct vpu_rpc_buffer_desc msg_buffer_desc;\n\tu32 cmd_int_enable[VID_API_NUM_STREAMS];\n\tu32 fw_version;\n\tu32 mvd_fw_offset;\n\tu32 max_streams;\n\tu32 ctrl_iface[VID_API_NUM_STREAMS];\n\tstruct vpu_rpc_system_config system_config;\n\tu32 api_version;\n\tstruct vpu_rpc_buffer_desc log_buffer_desc;\n};\n\nstruct windsor_ctrl_iface {\n\tu32 enc_yuv_buffer_desc;\n\tu32 enc_stream_buffer_desc;\n\tu32 enc_expert_mode_param;\n\tu32 enc_param;\n\tu32 enc_mem_pool;\n\tu32 enc_encoding_status;\n\tu32 enc_dsa_status;\n};\n\nstruct vpu_enc_yuv_desc {\n\tu32 frame_id;\n\tu32 luma_base;\n\tu32 chroma_base;\n\tu32 param_idx;\n\tu32 key_frame;\n};\n\nstruct vpu_enc_calib_params {\n\tu32 use_ame;\n\n\tu32 cme_mvx_max;\n\tu32 cme_mvy_max;\n\tu32 ame_prefresh_y0;\n\tu32 ame_prefresh_y1;\n\tu32 fme_min_sad;\n\tu32 cme_min_sad;\n\n\tu32 fme_pred_int_weight;\n\tu32 fme_pred_hp_weight;\n\tu32 fme_pred_qp_weight;\n\tu32 fme_cost_weight;\n\tu32 fme_act_thold;\n\tu32 fme_sad_thold;\n\tu32 fme_zero_sad_thold;\n\n\tu32 fme_lrg_mvx_lmt;\n\tu32 fme_lrg_mvy_lmt;\n\tu32 fme_force_mode;\n\tu32 fme_force4mvcost;\n\tu32 fme_force2mvcost;\n\n\tu32 h264_inter_thrd;\n\n\tu32 i16x16_mode_cost;\n\tu32 i4x4_mode_lambda;\n\tu32 i8x8_mode_lambda;\n\n\tu32 inter_mod_mult;\n\tu32 inter_sel_mult;\n\tu32 inter_bid_cost;\n\tu32 inter_bwd_cost;\n\tu32 inter_4mv_cost;\n\ts32 one_mv_i16_cost;\n\ts32 one_mv_i4x4_cost;\n\ts32 one_mv_i8x8_cost;\n\ts32 two_mv_i16_cost;\n\ts32 two_mv_i4x4_cost;\n\ts32 two_mv_i8x8_cost;\n\ts32 four_mv_i16_cost;\n\ts32 four_mv_i4x4_cost;\n\ts32 four_mv_i8x8_cost;\n\n\tu32 intra_pred_enab;\n\tu32 intra_chr_pred;\n\tu32 intra16_pred;\n\tu32 intra4x4_pred;\n\tu32 intra8x8_pred;\n\n\tu32 cb_base;\n\tu32 cb_size;\n\tu32 cb_head_room;\n\n\tu32 mem_page_width;\n\tu32 mem_page_height;\n\tu32 mem_total_size;\n\tu32 mem_chunk_phys_addr;\n\tu32 mem_chunk_virt_addr;\n\tu32 mem_chunk_size;\n\tu32 mem_y_stride;\n\tu32 mem_uv_stride;\n\n\tu32 split_wr_enab;\n\tu32 split_wr_req_size;\n\tu32 split_rd_enab;\n\tu32 split_rd_req_size;\n};\n\nstruct vpu_enc_config_params {\n\tu32 param_change;\n\tu32 start_frame;\n\tu32 end_frame;\n\tu32 userdata_enable;\n\tu32 userdata_id[4];\n\tu32 userdata_message[WINDSOR_USER_DATA_WORDS];\n\tu32 userdata_length;\n\tu32 h264_profile_idc;\n\tu32 h264_level_idc;\n\tu32 h264_au_delimiter;\n\tu32 h264_seq_end_code;\n\tu32 h264_recovery_points;\n\tu32 h264_vui_parameters;\n\tu32 h264_aspect_ratio_present;\n\tu32 h264_aspect_ratio_sar_width;\n\tu32 h264_aspect_ratio_sar_height;\n\tu32 h264_overscan_present;\n\tu32 h264_video_type_present;\n\tu32 h264_video_format;\n\tu32 h264_video_full_range;\n\tu32 h264_video_colour_descriptor;\n\tu32 h264_video_colour_primaries;\n\tu32 h264_video_transfer_char;\n\tu32 h264_video_matrix_coeff;\n\tu32 h264_chroma_loc_info_present;\n\tu32 h264_chroma_loc_type_top;\n\tu32 h264_chroma_loc_type_bot;\n\tu32 h264_timing_info_present;\n\tu32 h264_buffering_period_present;\n\tu32 h264_low_delay_hrd_flag;\n\tu32 aspect_ratio;\n\tu32 test_mode;                  \n\tu32 dsa_test_mode;              \n\tu32 fme_test_mode;              \n\tu32 cbr_row_mode;               \n\tu32 windsor_mode;               \n\tu32 encode_mode;                \n\tu32 frame_width;                \n\tu32 frame_height;               \n\tu32 enc_frame_width;            \n\tu32 enc_frame_height;           \n\tu32 frame_rate_num;\n\tu32 frame_rate_den;\n\tu32 vi_field_source;\n\tu32 vi_frame_width;\n\tu32 vi_frame_height;\n\tu32 crop_frame_width;\n\tu32 crop_frame_height;\n\tu32 crop_x_start_posn;\n\tu32 crop_y_start_posn;\n\tu32 mode422;\n\tu32 mode_yuy2;\n\tu32 dsa_luma_en;\n\tu32 dsa_chroma_en;\n\tu32 dsa_ext_hfilt_en;\n\tu32 dsa_di_en;\n\tu32 dsa_di_top_ref;\n\tu32 dsa_vertf_disable;\n\tu32 dsa_disable_pwb;\n\tu32 dsa_hor_phase;\n\tu32 dsa_ver_phase;\n\tu32 dsa_iac_enable;\n\tu32 iac_sc_threshold;\n\tu32 iac_vm_threshold;\n\tu32 iac_skip_mode;\n\tu32 iac_grp_width;\n\tu32 iac_grp_height;\n\tu32 rate_control_mode;\n\tu32 rate_control_resolution;\n\tu32 buffer_size;\n\tu32 buffer_level_init;\n\tu32 buffer_I_bit_budget;\n\tu32 top_field_first;\n\tu32 intra_lum_qoffset;\n\tu32 intra_chr_qoffset;\n\tu32 inter_lum_qoffset;\n\tu32 inter_chr_qoffset;\n\tu32 use_def_scaling_mtx;\n\tu32 inter_8x8_enab;\n\tu32 inter_4x4_enab;\n\tu32 fme_enable_qpel;\n\tu32 fme_enable_hpel;\n\tu32 fme_nozeromv;\n\tu32 fme_predmv_en;\n\tu32 fme_pred_2mv4mv;\n\tu32 fme_smallsadthresh;\n\tu32 ame_en_lmvc;\n\tu32 ame_x_mult;\n\tu32 cme_enable_4mv;\n\tu32 cme_enable_1mv;\n\tu32 hme_enable_16x8mv;\n\tu32 hme_enable_8x16mv;\n\tu32 cme_mv_weight;\n\tu32 cme_mv_cost;\n\tu32 ame_mult_mv;\n\tu32 ame_shift_mv;\n\tu32 hme_forceto1mv_en;\n\tu32 hme_2mv_cost;\n\tu32 hme_pred_mode;\n\tu32 hme_sc_rnge;\n\tu32 hme_sw_rnge;\n\tu32 output_format;\n\tu32 timestamp_enab;\n\tu32 initial_pts_enab;\n\tu32 initial_pts;\n};\n\nstruct vpu_enc_static_params {\n\tu32 param_change;\n\tu32 gop_length;\n\tu32 rate_control_bitrate;\n\tu32 rate_control_bitrate_min;\n\tu32 rate_control_bitrate_max;\n\tu32 rate_control_content_models;\n\tu32 rate_control_iframe_maxsize;\n\tu32 rate_control_qp_init;\n\tu32 rate_control_islice_qp;\n\tu32 rate_control_pslice_qp;\n\tu32 rate_control_bslice_qp;\n\tu32 adaptive_quantization;\n\tu32 aq_variance;\n\tu32 cost_optimization;\n\tu32 fdlp_mode;\n\tu32 enable_isegbframes;\n\tu32 enable_adaptive_keyratio;\n\tu32 keyratio_imin;\n\tu32 keyratio_imax;\n\tu32 keyratio_pmin;\n\tu32 keyratio_pmax;\n\tu32 keyratio_bmin;\n\tu32 keyratio_bmax;\n\ts32 keyratio_istep;\n\ts32 keyratio_pstep;\n\ts32 keyratio_bstep;\n\tu32 enable_paff;\n\tu32 enable_b_frame_ref;\n\tu32 enable_adaptive_gop;\n\tu32 enable_closed_gop;\n\tu32 open_gop_refresh_freq;\n\tu32 enable_adaptive_sc;\n\tu32 enable_fade_detection;\n\ts32 fade_detection_threshold;\n\tu32 enable_repeat_b;\n\tu32 enable_low_delay_b;\n};\n\nstruct vpu_enc_dynamic_params {\n\tu32 param_change;\n\tu32 rows_per_slice;\n\tu32 mbaff_enable;\n\tu32 dbf_enable;\n\tu32 field_source;\n\tu32 gop_b_length;\n\tu32 mb_group_size;\n\tu32 cbr_rows_per_group;\n\tu32 skip_enable;\n\tu32 pts_bits_0_to_31;\n\tu32 pts_bit_32;\n\tu32 rm_expsv_cff;\n\tu32 const_ipred;\n\ts32 chr_qp_offset;\n\tu32 intra_mb_qp_offset;\n\tu32 h264_cabac_init_method;\n\tu32 h264_cabac_init_idc;\n\tu32 h264_cabac_enable;\n\ts32 alpha_c0_offset_div2;\n\ts32 beta_offset_div2;\n\tu32 intra_prefresh_y0;\n\tu32 intra_prefresh_y1;\n\tu32 dbg_dump_rec_src;\n};\n\nstruct vpu_enc_expert_mode_param {\n\tstruct vpu_enc_calib_params calib_param;\n\tstruct vpu_enc_config_params config_param;\n\tstruct vpu_enc_static_params static_param;\n\tstruct vpu_enc_dynamic_params dynamic_param;\n};\n\nenum MEDIAIP_ENC_FMT {\n\tMEDIAIP_ENC_FMT_H264 = 0,\n\tMEDIAIP_ENC_FMT_VC1,\n\tMEDIAIP_ENC_FMT_MPEG2,\n\tMEDIAIP_ENC_FMT_MPEG4SP,\n\tMEDIAIP_ENC_FMT_H263,\n\tMEDIAIP_ENC_FMT_MPEG1,\n\tMEDIAIP_ENC_FMT_SHORT_HEADER,\n\tMEDIAIP_ENC_FMT_NULL\n};\n\nenum MEDIAIP_ENC_PROFILE {\n\tMEDIAIP_ENC_PROF_MPEG2_SP = 0,\n\tMEDIAIP_ENC_PROF_MPEG2_MP,\n\tMEDIAIP_ENC_PROF_MPEG2_HP,\n\tMEDIAIP_ENC_PROF_H264_BP,\n\tMEDIAIP_ENC_PROF_H264_MP,\n\tMEDIAIP_ENC_PROF_H264_HP,\n\tMEDIAIP_ENC_PROF_MPEG4_SP,\n\tMEDIAIP_ENC_PROF_MPEG4_ASP,\n\tMEDIAIP_ENC_PROF_VC1_SP,\n\tMEDIAIP_ENC_PROF_VC1_MP,\n\tMEDIAIP_ENC_PROF_VC1_AP\n};\n\nenum MEDIAIP_ENC_BITRATE_MODE {\n\tMEDIAIP_ENC_BITRATE_MODE_VBR          = 0x00000001,\n\tMEDIAIP_ENC_BITRATE_MODE_CBR          = 0x00000002,\n\tMEDIAIP_ENC_BITRATE_MODE_CONSTANT_QP  = 0x00000004\n};\n\nstruct vpu_enc_memory_resource {\n\tu32 phys;\n\tu32 virt;\n\tu32 size;\n};\n\nstruct vpu_enc_param {\n\tenum MEDIAIP_ENC_FMT codec_mode;\n\tenum MEDIAIP_ENC_PROFILE profile;\n\tu32 level;\n\n\tstruct vpu_enc_memory_resource enc_mem_desc;\n\n\tu32 frame_rate;\n\tu32 src_stride;\n\tu32 src_width;\n\tu32 src_height;\n\tu32 src_offset_x;\n\tu32 src_offset_y;\n\tu32 src_crop_width;\n\tu32 src_crop_height;\n\tu32 out_width;\n\tu32 out_height;\n\tu32 iframe_interval;\n\tu32 bframes;\n\tu32 low_latency_mode;\n\n\tenum MEDIAIP_ENC_BITRATE_MODE  bitrate_mode;\n\tu32 target_bitrate;\n\tu32 max_bitrate;\n\tu32 min_bitrate;\n\tu32 init_slice_qp;\n};\n\nstruct vpu_enc_mem_pool {\n\tstruct vpu_enc_memory_resource enc_frames[WINDSOR_MAX_SRC_FRAMES];\n\tstruct vpu_enc_memory_resource ref_frames[WINDSOR_MAX_REF_FRAMES];\n\tstruct vpu_enc_memory_resource act_frame;\n};\n\nstruct vpu_enc_encoding_status {\n\tu32   frame_id;\n\tu32   error_flag;   \n\tu32   mb_y;\n\tu32   mb_x;\n\tu32   reserved[12];\n\n};\n\nstruct vpu_enc_dsa_status {\n\tu32   frame_id;\n\tu32   dsa_cyle;\n\tu32   mb_y;\n\tu32   mb_x;\n\tu32   reserved[4];\n};\n\nstruct vpu_enc_ctrl {\n\tstruct vpu_enc_yuv_desc *yuv_desc;\n\tstruct vpu_rpc_buffer_desc *stream_desc;\n\tstruct vpu_enc_expert_mode_param *expert;\n\tstruct vpu_enc_param *param;\n\tstruct vpu_enc_mem_pool *pool;\n\tstruct vpu_enc_encoding_status *status;\n\tstruct vpu_enc_dsa_status *dsa;\n};\n\nstruct vpu_enc_host_ctrls {\n\tstruct vpu_enc_ctrl ctrls[VID_API_NUM_STREAMS];\n};\n\nstruct windsor_pic_info {\n\tu32 frame_id;\n\tu32 pic_encod_done;\n\tu32 pic_type;\n\tu32 skipped_frame;\n\tu32 error_flag;\n\tu32 psnr;\n\tu32 flush_done;\n\tu32 mb_y;\n\tu32 mb_x;\n\tu32 frame_size;\n\tu32 frame_enc_ttl_cycles;\n\tu32 frame_enc_ttl_frm_cycles;\n\tu32 frame_enc_ttl_slc_cycles;\n\tu32 frame_enc_ttl_enc_cycles;\n\tu32 frame_enc_ttl_hme_cycles;\n\tu32 frame_enc_ttl_dsa_cycles;\n\tu32 frame_enc_fw_cycles;\n\tu32 frame_crc;\n\tu32 num_interrupts_1;\n\tu32 num_interrupts_2;\n\tu32 poc;\n\tu32 ref_info;\n\tu32 pic_num;\n\tu32 pic_activity;\n\tu32 scene_change;\n\tu32 mb_stats;\n\tu32 enc_cache_count0;\n\tu32 enc_cache_count1;\n\tu32 mtl_wr_strb_cnt;\n\tu32 mtl_rd_strb_cnt;\n\tu32 str_buff_wptr;\n\tu32 diagnosticEvents;\n\tu32 proc_iacc_tot_rd_cnt;\n\tu32 proc_dacc_tot_rd_cnt;\n\tu32 proc_dacc_tot_wr_cnt;\n\tu32 proc_dacc_reg_rd_cnt;\n\tu32 proc_dacc_reg_wr_cnt;\n\tu32 proc_dacc_rng_rd_cnt;\n\tu32 proc_dacc_rng_wr_cnt;\n\ts32 tv_s;\n\tu32 tv_ns;\n};\n\nu32 vpu_windsor_get_data_size(void)\n{\n\treturn sizeof(struct vpu_enc_host_ctrls);\n}\n\nstatic struct vpu_enc_yuv_desc *get_yuv_desc(struct vpu_shared_addr *shared,\n\t\t\t\t\t     u32 instance)\n{\n\tstruct vpu_enc_host_ctrls *hcs = shared->priv;\n\n\treturn hcs->ctrls[instance].yuv_desc;\n}\n\nstatic struct vpu_enc_mem_pool *get_mem_pool(struct vpu_shared_addr *shared,\n\t\t\t\t\t     u32 instance)\n{\n\tstruct vpu_enc_host_ctrls *hcs = shared->priv;\n\n\treturn hcs->ctrls[instance].pool;\n}\n\nstatic struct vpu_rpc_buffer_desc *get_stream_buf_desc(struct vpu_shared_addr *shared,\n\t\t\t\t\t\t       u32 instance)\n{\n\tstruct vpu_enc_host_ctrls *hcs = shared->priv;\n\n\treturn hcs->ctrls[instance].stream_desc;\n}\n\nstatic struct vpu_enc_expert_mode_param *get_expert_param(struct vpu_shared_addr *shared,\n\t\t\t\t\t\t\t  u32 instance)\n{\n\tstruct vpu_enc_host_ctrls *hcs = shared->priv;\n\n\treturn hcs->ctrls[instance].expert;\n}\n\nstatic struct vpu_enc_param *get_enc_param(struct vpu_shared_addr *shared, u32 instance)\n{\n\tstruct vpu_enc_host_ctrls *hcs = shared->priv;\n\n\treturn hcs->ctrls[instance].param;\n}\n\nstatic u32 get_ptr(u32 ptr)\n{\n\treturn (ptr | 0x80000000);\n}\n\nvoid vpu_windsor_init_rpc(struct vpu_shared_addr *shared,\n\t\t\t  struct vpu_buffer *rpc, dma_addr_t boot_addr)\n{\n\tunsigned long base_phy_addr;\n\tunsigned long phy_addr;\n\tunsigned long offset;\n\tstruct windsor_iface *iface;\n\tstruct windsor_ctrl_iface *ctrl;\n\tstruct vpu_enc_host_ctrls *hcs;\n\tunsigned int i;\n\n\tif (rpc->phys < boot_addr)\n\t\treturn;\n\n\tbase_phy_addr = rpc->phys - boot_addr;\n\tiface = rpc->virt;\n\tshared->iface = iface;\n\tshared->boot_addr = boot_addr;\n\thcs = shared->priv;\n\n\tiface->exec_base_addr = base_phy_addr;\n\tiface->exec_area_size = rpc->length;\n\n\toffset = sizeof(struct windsor_iface);\n\tphy_addr = base_phy_addr + offset;\n\tshared->cmd_desc = &iface->cmd_buffer_desc;\n\tshared->cmd_mem_vir = rpc->virt + offset;\n\tiface->cmd_buffer_desc.start =\n\tiface->cmd_buffer_desc.rptr =\n\tiface->cmd_buffer_desc.wptr = phy_addr;\n\tiface->cmd_buffer_desc.end = iface->cmd_buffer_desc.start + CMD_SIZE;\n\n\toffset += CMD_SIZE;\n\tphy_addr = base_phy_addr + offset;\n\tshared->msg_desc = &iface->msg_buffer_desc;\n\tshared->msg_mem_vir = rpc->virt + offset;\n\tiface->msg_buffer_desc.start =\n\tiface->msg_buffer_desc.wptr =\n\tiface->msg_buffer_desc.rptr = phy_addr;\n\tiface->msg_buffer_desc.end = iface->msg_buffer_desc.start + MSG_SIZE;\n\n\toffset += MSG_SIZE;\n\tfor (i = 0; i < ARRAY_SIZE(iface->ctrl_iface); i++) {\n\t\tiface->ctrl_iface[i] = base_phy_addr + offset;\n\t\toffset += sizeof(struct windsor_ctrl_iface);\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(iface->ctrl_iface); i++) {\n\t\tctrl = rpc->virt + (iface->ctrl_iface[i] - base_phy_addr);\n\n\t\tctrl->enc_yuv_buffer_desc = base_phy_addr + offset;\n\t\thcs->ctrls[i].yuv_desc = rpc->virt + offset;\n\t\toffset += sizeof(struct vpu_enc_yuv_desc);\n\n\t\tctrl->enc_stream_buffer_desc = base_phy_addr + offset;\n\t\thcs->ctrls[i].stream_desc = rpc->virt + offset;\n\t\toffset += sizeof(struct vpu_rpc_buffer_desc);\n\n\t\tctrl->enc_expert_mode_param = base_phy_addr + offset;\n\t\thcs->ctrls[i].expert = rpc->virt + offset;\n\t\toffset += sizeof(struct vpu_enc_expert_mode_param);\n\n\t\tctrl->enc_param = base_phy_addr + offset;\n\t\thcs->ctrls[i].param = rpc->virt + offset;\n\t\toffset += sizeof(struct vpu_enc_param);\n\n\t\tctrl->enc_mem_pool = base_phy_addr + offset;\n\t\thcs->ctrls[i].pool = rpc->virt + offset;\n\t\toffset += sizeof(struct vpu_enc_mem_pool);\n\n\t\tctrl->enc_encoding_status = base_phy_addr + offset;\n\t\thcs->ctrls[i].status = rpc->virt + offset;\n\t\toffset += sizeof(struct vpu_enc_encoding_status);\n\n\t\tctrl->enc_dsa_status = base_phy_addr + offset;\n\t\thcs->ctrls[i].dsa = rpc->virt + offset;\n\t\toffset += sizeof(struct vpu_enc_dsa_status);\n\t}\n\n\trpc->bytesused = offset;\n}\n\nvoid vpu_windsor_set_log_buf(struct vpu_shared_addr *shared, struct vpu_buffer *log)\n{\n\tstruct windsor_iface *iface = shared->iface;\n\n\tiface->log_buffer_desc.start =\n\tiface->log_buffer_desc.wptr =\n\tiface->log_buffer_desc.rptr = log->phys - shared->boot_addr;\n\tiface->log_buffer_desc.end = iface->log_buffer_desc.start + log->length;\n}\n\nvoid vpu_windsor_set_system_cfg(struct vpu_shared_addr *shared,\n\t\t\t\tu32 regs_base, void __iomem *regs, u32 core_id)\n{\n\tstruct windsor_iface *iface = shared->iface;\n\tstruct vpu_rpc_system_config *config = &iface->system_config;\n\n\tvpu_imx8q_set_system_cfg_common(config, regs_base, core_id);\n}\n\nint vpu_windsor_get_stream_buffer_size(struct vpu_shared_addr *shared)\n{\n\treturn 0x300000;\n}\n\nstatic struct vpu_pair windsor_cmds[] = {\n\t{VPU_CMD_ID_NOOP, GTB_ENC_CMD_NOOP},\n\t{VPU_CMD_ID_CONFIGURE_CODEC, GTB_ENC_CMD_CONFIGURE_CODEC},\n\t{VPU_CMD_ID_START, GTB_ENC_CMD_STREAM_START},\n\t{VPU_CMD_ID_STOP, GTB_ENC_CMD_STREAM_STOP},\n\t{VPU_CMD_ID_FRAME_ENCODE, GTB_ENC_CMD_FRAME_ENCODE},\n\t{VPU_CMD_ID_SNAPSHOT, GTB_ENC_CMD_SNAPSHOT},\n\t{VPU_CMD_ID_FIRM_RESET, GTB_ENC_CMD_FIRM_RESET},\n\t{VPU_CMD_ID_UPDATE_PARAMETER, GTB_ENC_CMD_PARAMETER_UPD},\n\t{VPU_CMD_ID_DEBUG, GTB_ENC_CMD_FW_STATUS}\n};\n\nstatic struct vpu_pair windsor_msgs[] = {\n\t{VPU_MSG_ID_RESET_DONE, VID_API_ENC_EVENT_RESET_DONE},\n\t{VPU_MSG_ID_START_DONE, VID_API_ENC_EVENT_START_DONE},\n\t{VPU_MSG_ID_STOP_DONE, VID_API_ENC_EVENT_STOP_DONE},\n\t{VPU_MSG_ID_FRAME_INPUT_DONE, VID_API_ENC_EVENT_FRAME_INPUT_DONE},\n\t{VPU_MSG_ID_ENC_DONE, VID_API_ENC_EVENT_FRAME_DONE},\n\t{VPU_MSG_ID_FRAME_RELEASE, VID_API_ENC_EVENT_FRAME_RELEASE},\n\t{VPU_MSG_ID_MEM_REQUEST, VID_API_ENC_EVENT_MEM_REQUEST},\n\t{VPU_MSG_ID_PARAM_UPD_DONE, VID_API_ENC_EVENT_PARA_UPD_DONE},\n\t{VPU_MSG_ID_FIRMWARE_XCPT, VID_API_ENC_EVENT_FIRMWARE_XCPT},\n};\n\nint vpu_windsor_pack_cmd(struct vpu_rpc_event *pkt, u32 index, u32 id, void *data)\n{\n\tint ret;\n\n\tret = vpu_find_dst_by_src(windsor_cmds, ARRAY_SIZE(windsor_cmds), id);\n\tif (ret < 0)\n\t\treturn ret;\n\tpkt->hdr.id = ret;\n\tpkt->hdr.num = 0;\n\tpkt->hdr.index = index;\n\tif (id == VPU_CMD_ID_FRAME_ENCODE) {\n\t\ts64 timestamp = *(s64 *)data;\n\t\tstruct timespec64 ts = ns_to_timespec64(timestamp);\n\n\t\tpkt->hdr.num = 2;\n\t\tpkt->data[0] = ts.tv_sec;\n\t\tpkt->data[1] = ts.tv_nsec;\n\t}\n\n\treturn 0;\n}\n\nint vpu_windsor_convert_msg_id(u32 id)\n{\n\treturn vpu_find_src_by_dst(windsor_msgs, ARRAY_SIZE(windsor_msgs), id);\n}\n\nstatic void vpu_windsor_unpack_pic_info(struct vpu_rpc_event *pkt, void *data)\n{\n\tstruct vpu_enc_pic_info *info = data;\n\tstruct windsor_pic_info *windsor = (struct windsor_pic_info *)pkt->data;\n\tstruct timespec64 ts = { windsor->tv_s, windsor->tv_ns };\n\n\tinfo->frame_id = windsor->frame_id;\n\tswitch (windsor->pic_type) {\n\tcase MEDIAIP_ENC_PIC_TYPE_I_FRAME:\n\tcase MEDIAIP_ENC_PIC_TYPE_IDR_FRAME:\n\t\tinfo->pic_type = V4L2_BUF_FLAG_KEYFRAME;\n\t\tbreak;\n\tcase MEDIAIP_ENC_PIC_TYPE_P_FRAME:\n\t\tinfo->pic_type = V4L2_BUF_FLAG_PFRAME;\n\t\tbreak;\n\tcase MEDIAIP_ENC_PIC_TYPE_B_FRAME:\n\t\tinfo->pic_type = V4L2_BUF_FLAG_BFRAME;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tinfo->skipped_frame = windsor->skipped_frame;\n\tinfo->error_flag = windsor->error_flag;\n\tinfo->psnr = windsor->psnr;\n\tinfo->frame_size = windsor->frame_size;\n\tinfo->wptr = get_ptr(windsor->str_buff_wptr);\n\tinfo->crc = windsor->frame_crc;\n\tinfo->timestamp = timespec64_to_ns(&ts);\n}\n\nstatic void vpu_windsor_unpack_mem_req(struct vpu_rpc_event *pkt, void *data)\n{\n\tstruct vpu_pkt_mem_req_data *req_data = data;\n\n\treq_data->enc_frame_size = pkt->data[0];\n\treq_data->enc_frame_num = pkt->data[1];\n\treq_data->ref_frame_size = pkt->data[2];\n\treq_data->ref_frame_num = pkt->data[3];\n\treq_data->act_buf_size = pkt->data[4];\n\treq_data->act_buf_num = 1;\n}\n\nint vpu_windsor_unpack_msg_data(struct vpu_rpc_event *pkt, void *data)\n{\n\tif (!pkt || !data)\n\t\treturn -EINVAL;\n\n\tswitch (pkt->hdr.id) {\n\tcase VID_API_ENC_EVENT_FRAME_DONE:\n\t\tvpu_windsor_unpack_pic_info(pkt, data);\n\t\tbreak;\n\tcase VID_API_ENC_EVENT_MEM_REQUEST:\n\t\tvpu_windsor_unpack_mem_req(pkt, data);\n\t\tbreak;\n\tcase VID_API_ENC_EVENT_FRAME_RELEASE:\n\t\t*(u32 *)data = pkt->data[0];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int vpu_windsor_fill_yuv_frame(struct vpu_shared_addr *shared,\n\t\t\t\t      u32 instance,\n\t\t\t\t      struct vb2_buffer *vb)\n{\n\tstruct vpu_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vpu_format *out_fmt;\n\tstruct vpu_enc_yuv_desc *desc;\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tif (instance >= VID_API_NUM_STREAMS)\n\t\treturn -EINVAL;\n\n\tdesc = get_yuv_desc(shared, instance);\n\tout_fmt = vpu_get_format(inst, vb->type);\n\n\tvbuf = to_vb2_v4l2_buffer(vb);\n\tdesc->frame_id = vbuf->sequence;\n\tif (vbuf->flags & V4L2_BUF_FLAG_KEYFRAME)\n\t\tdesc->key_frame = 1;\n\telse\n\t\tdesc->key_frame = 0;\n\tdesc->luma_base = vpu_get_vb_phy_addr(vb, 0);\n\tif (vb->num_planes > 1)\n\t\tdesc->chroma_base = vpu_get_vb_phy_addr(vb, 1);\n\telse\n\t\tdesc->chroma_base = desc->luma_base + out_fmt->sizeimage[0];\n\n\treturn 0;\n}\n\nint vpu_windsor_input_frame(struct vpu_shared_addr *shared,\n\t\t\t    struct vpu_inst *inst, struct vb2_buffer *vb)\n{\n\tvpu_windsor_fill_yuv_frame(shared, inst->id, vb);\n\treturn vpu_session_encode_frame(inst, vb->timestamp);\n}\n\nint vpu_windsor_config_memory_resource(struct vpu_shared_addr *shared,\n\t\t\t\t       u32 instance,\n\t\t\t\t       u32 type,\n\t\t\t\t       u32 index,\n\t\t\t\t       struct vpu_buffer *buf)\n{\n\tstruct vpu_enc_mem_pool *pool;\n\tstruct vpu_enc_memory_resource *res;\n\n\tif (instance >= VID_API_NUM_STREAMS)\n\t\treturn -EINVAL;\n\n\tpool = get_mem_pool(shared, instance);\n\n\tswitch (type) {\n\tcase MEM_RES_ENC:\n\t\tif (index >= ARRAY_SIZE(pool->enc_frames))\n\t\t\treturn -EINVAL;\n\t\tres = &pool->enc_frames[index];\n\t\tbreak;\n\tcase MEM_RES_REF:\n\t\tif (index >= ARRAY_SIZE(pool->ref_frames))\n\t\t\treturn -EINVAL;\n\t\tres = &pool->ref_frames[index];\n\t\tbreak;\n\tcase MEM_RES_ACT:\n\t\tif (index)\n\t\t\treturn -EINVAL;\n\t\tres = &pool->act_frame;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tres->phys = buf->phys;\n\tres->virt = buf->phys - shared->boot_addr;\n\tres->size = buf->length;\n\n\treturn 0;\n}\n\nint vpu_windsor_config_stream_buffer(struct vpu_shared_addr *shared,\n\t\t\t\t     u32 instance,\n\t\t\t\t     struct vpu_buffer *buf)\n{\n\tstruct vpu_rpc_buffer_desc *desc;\n\tstruct vpu_enc_expert_mode_param *expert;\n\n\tdesc = get_stream_buf_desc(shared, instance);\n\texpert = get_expert_param(shared, instance);\n\n\tdesc->start = buf->phys;\n\tdesc->wptr = buf->phys;\n\tdesc->rptr = buf->phys;\n\tdesc->end = buf->phys + buf->length;\n\n\texpert->calib_param.mem_chunk_phys_addr = 0;\n\texpert->calib_param.mem_chunk_virt_addr = 0;\n\texpert->calib_param.mem_chunk_size = 0;\n\texpert->calib_param.cb_base = buf->phys;\n\texpert->calib_param.cb_size = buf->length;\n\n\treturn 0;\n}\n\nint vpu_windsor_update_stream_buffer(struct vpu_shared_addr *shared,\n\t\t\t\t     u32 instance, u32 ptr, bool write)\n{\n\tstruct vpu_rpc_buffer_desc *desc;\n\n\tdesc = get_stream_buf_desc(shared, instance);\n\n\t \n\tmb();\n\tif (write)\n\t\tdesc->wptr = ptr;\n\telse\n\t\tdesc->rptr = ptr;\n\n\treturn 0;\n}\n\nint vpu_windsor_get_stream_buffer_desc(struct vpu_shared_addr *shared,\n\t\t\t\t       u32 instance, struct vpu_rpc_buffer_desc *desc)\n{\n\tstruct vpu_rpc_buffer_desc *rpc_desc;\n\n\trpc_desc = get_stream_buf_desc(shared, instance);\n\tif (desc) {\n\t\tdesc->wptr = get_ptr(rpc_desc->wptr);\n\t\tdesc->rptr = get_ptr(rpc_desc->rptr);\n\t\tdesc->start = get_ptr(rpc_desc->start);\n\t\tdesc->end = get_ptr(rpc_desc->end);\n\t}\n\n\treturn 0;\n}\n\nu32 vpu_windsor_get_version(struct vpu_shared_addr *shared)\n{\n\tstruct windsor_iface *iface = shared->iface;\n\n\treturn iface->fw_version;\n}\n\nstatic int vpu_windsor_set_frame_rate(struct vpu_enc_expert_mode_param *expert,\n\t\t\t\t      struct vpu_encode_params *params)\n{\n\texpert->config_param.frame_rate_num = params->frame_rate.numerator;\n\texpert->config_param.frame_rate_den = params->frame_rate.denominator;\n\n\treturn 0;\n}\n\nstatic int vpu_windsor_set_format(struct vpu_enc_param *param, u32 pixelformat)\n{\n\tswitch (pixelformat) {\n\tcase V4L2_PIX_FMT_H264:\n\t\tparam->codec_mode = MEDIAIP_ENC_FMT_H264;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vpu_windsor_set_profile(struct vpu_enc_param *param, u32 profile)\n{\n\tswitch (profile) {\n\tcase V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:\n\t\tparam->profile = MEDIAIP_ENC_PROF_H264_BP;\n\t\tbreak;\n\tcase V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:\n\t\tparam->profile = MEDIAIP_ENC_PROF_H264_MP;\n\t\tbreak;\n\tcase V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:\n\t\tparam->profile = MEDIAIP_ENC_PROF_H264_HP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const u32 h264_level[] = {\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_1_0] = 10,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_1B]  = 14,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_1_1] = 11,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_1_2] = 12,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_1_3] = 13,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_2_0] = 20,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_2_1] = 21,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_2_2] = 22,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_3_0] = 30,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_3_1] = 31,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_3_2] = 32,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_4_0] = 40,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_4_1] = 41,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_4_2] = 42,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_5_0] = 50,\n\t[V4L2_MPEG_VIDEO_H264_LEVEL_5_1] = 51\n};\n\nstatic int vpu_windsor_set_level(struct vpu_enc_param *param, u32 level)\n{\n\tif (level >= ARRAY_SIZE(h264_level))\n\t\treturn -EINVAL;\n\n\tparam->level = h264_level[level];\n\n\treturn 0;\n}\n\nstatic int vpu_windsor_set_size(struct vpu_enc_param *windsor,\n\t\t\t\tstruct vpu_encode_params *params)\n{\n\twindsor->src_stride = params->src_stride;\n\twindsor->src_width = params->src_width;\n\twindsor->src_height = params->src_height;\n\twindsor->src_offset_x = params->crop.left;\n\twindsor->src_offset_y = params->crop.top;\n\twindsor->src_crop_width = params->crop.width;\n\twindsor->src_crop_height = params->crop.height;\n\twindsor->out_width = params->out_width;\n\twindsor->out_height = params->out_height;\n\n\treturn 0;\n}\n\nstatic int vpu_windsor_set_gop(struct vpu_enc_param *param, u32 gop)\n{\n\tparam->iframe_interval = gop;\n\n\treturn 0;\n}\n\nstatic int vpu_windsor_set_bframes(struct vpu_enc_param *param, u32 bframes)\n{\n\tif (bframes) {\n\t\tparam->low_latency_mode = 0;\n\t\tparam->bframes = bframes;\n\t} else {\n\t\tparam->low_latency_mode = 1;\n\t\tparam->bframes = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int vpu_windsor_set_bitrate_mode(struct vpu_enc_param *param, u32 rc_enable, u32 mode)\n{\n\tif (!rc_enable)\n\t\tparam->bitrate_mode = MEDIAIP_ENC_BITRATE_MODE_CONSTANT_QP;\n\telse if (mode == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR)\n\t\tparam->bitrate_mode = MEDIAIP_ENC_BITRATE_MODE_VBR;\n\telse\n\t\tparam->bitrate_mode = MEDIAIP_ENC_BITRATE_MODE_CBR;\n\n\treturn 0;\n}\n\nstatic u32 vpu_windsor_bitrate(u32 bitrate)\n{\n\treturn DIV_ROUND_CLOSEST(bitrate, WINDSOR_BITRATE_UNIT);\n}\n\nstatic int vpu_windsor_set_bitrate(struct vpu_enc_param *windsor,\n\t\t\t\t   struct vpu_encode_params *params)\n{\n\twindsor->target_bitrate = vpu_windsor_bitrate(params->bitrate);\n\twindsor->min_bitrate = vpu_windsor_bitrate(params->bitrate_min);\n\twindsor->max_bitrate = vpu_windsor_bitrate(params->bitrate_max);\n\n\treturn 0;\n}\n\nstatic int vpu_windsor_set_qp(struct vpu_enc_expert_mode_param *expert,\n\t\t\t      struct vpu_encode_params *params)\n{\n\texpert->static_param.rate_control_islice_qp = params->i_frame_qp;\n\texpert->static_param.rate_control_pslice_qp = params->p_frame_qp;\n\texpert->static_param.rate_control_bslice_qp = params->b_frame_qp;\n\n\treturn 0;\n}\n\nstatic int vpu_windsor_set_sar(struct vpu_enc_expert_mode_param *expert,\n\t\t\t       struct vpu_encode_params *params)\n{\n\texpert->config_param.h264_aspect_ratio_present = params->sar.enable;\n\tif (params->sar.idc == V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_EXTENDED)\n\t\texpert->config_param.aspect_ratio = WINDSOR_H264_EXTENDED_SAR;\n\telse\n\t\texpert->config_param.aspect_ratio = params->sar.idc;\n\texpert->config_param.h264_aspect_ratio_sar_width = params->sar.width;\n\texpert->config_param.h264_aspect_ratio_sar_height = params->sar.height;\n\n\treturn 0;\n}\n\nstatic int vpu_windsor_set_color(struct vpu_enc_expert_mode_param *expert,\n\t\t\t\t struct vpu_encode_params *params)\n{\n\texpert->config_param.h264_video_type_present = 1;\n\texpert->config_param.h264_video_format = 5;\n\texpert->config_param.h264_video_colour_descriptor = 1;\n\texpert->config_param.h264_video_colour_primaries =\n\t\tvpu_color_cvrt_primaries_v2i(params->color.primaries);\n\texpert->config_param.h264_video_transfer_char =\n\t\tvpu_color_cvrt_transfers_v2i(params->color.transfer);\n\texpert->config_param.h264_video_matrix_coeff =\n\t\tvpu_color_cvrt_matrix_v2i(params->color.matrix);\n\texpert->config_param.h264_video_full_range =\n\t\tvpu_color_cvrt_full_range_v2i(params->color.full_range);\n\treturn 0;\n}\n\nstatic int vpu_windsor_update_bitrate(struct vpu_shared_addr *shared,\n\t\t\t\t      u32 instance, struct vpu_encode_params *params)\n{\n\tstruct vpu_enc_param *windsor;\n\tstruct vpu_enc_expert_mode_param *expert;\n\n\twindsor = get_enc_param(shared, instance);\n\texpert = get_expert_param(shared, instance);\n\n\tif (windsor->bitrate_mode != MEDIAIP_ENC_BITRATE_MODE_CBR)\n\t\treturn 0;\n\tif (!params->rc_enable)\n\t\treturn 0;\n\tif (vpu_windsor_bitrate(params->bitrate) == windsor->target_bitrate)\n\t\treturn 0;\n\n\tvpu_windsor_set_bitrate(windsor, params);\n\texpert->static_param.rate_control_bitrate = windsor->target_bitrate;\n\texpert->static_param.rate_control_bitrate_min = windsor->min_bitrate;\n\texpert->static_param.rate_control_bitrate_max = windsor->max_bitrate;\n\n\treturn 0;\n}\n\nstatic int vpu_windsor_set_params(struct vpu_shared_addr *shared,\n\t\t\t\t  u32 instance, struct vpu_encode_params *params)\n{\n\tstruct vpu_enc_param *windsor;\n\tint ret;\n\n\twindsor = get_enc_param(shared, instance);\n\n\tif (params->input_format != V4L2_PIX_FMT_NV12 &&\n\t    params->input_format != V4L2_PIX_FMT_NV12M)\n\t\treturn -EINVAL;\n\n\tret = vpu_windsor_set_format(windsor, params->codec_format);\n\tif (ret)\n\t\treturn ret;\n\tvpu_windsor_set_profile(windsor, params->profile);\n\tvpu_windsor_set_level(windsor, params->level);\n\tvpu_windsor_set_size(windsor, params);\n\tvpu_windsor_set_gop(windsor, params->gop_length);\n\tvpu_windsor_set_bframes(windsor, params->bframes);\n\tvpu_windsor_set_bitrate_mode(windsor, params->rc_enable, params->rc_mode);\n\tvpu_windsor_set_bitrate(windsor, params);\n\twindsor->init_slice_qp = params->i_frame_qp;\n\n\tif (!params->frame_rate.numerator)\n\t\treturn -EINVAL;\n\twindsor->frame_rate = params->frame_rate.denominator / params->frame_rate.numerator;\n\n\treturn 0;\n}\n\nstatic int vpu_windsor_update_params(struct vpu_shared_addr *shared,\n\t\t\t\t     u32 instance, struct vpu_encode_params *params)\n{\n\tstruct vpu_enc_expert_mode_param *expert;\n\n\texpert = get_expert_param(shared, instance);\n\n\tvpu_windsor_set_frame_rate(expert, params);\n\tvpu_windsor_set_qp(expert, params);\n\tvpu_windsor_set_sar(expert, params);\n\tvpu_windsor_set_color(expert, params);\n\tvpu_windsor_update_bitrate(shared, instance, params);\n\t \n\n\treturn 0;\n}\n\nint vpu_windsor_set_encode_params(struct vpu_shared_addr *shared,\n\t\t\t\t  u32 instance, struct vpu_encode_params *params, u32 update)\n{\n\tif (!params)\n\t\treturn -EINVAL;\n\n\tif (!update)\n\t\treturn vpu_windsor_set_params(shared, instance, params);\n\telse\n\t\treturn vpu_windsor_update_params(shared, instance, params);\n}\n\nu32 vpu_windsor_get_max_instance_count(struct vpu_shared_addr *shared)\n{\n\tstruct windsor_iface *iface = shared->iface;\n\n\treturn iface->max_streams;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}