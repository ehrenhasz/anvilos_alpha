{
  "module_name": "vpu_drv.c",
  "hash_id": "d74703284119b733dfd22b478b06452220dd4d9bd68f0854cdd4ae7728b89847",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/amphion/vpu_drv.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interconnect.h>\n#include <linux/ioctl.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/dma-map-ops.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pm_runtime.h>\n#include <linux/videodev2.h>\n#include <linux/of_reserved_mem.h>\n#include <media/v4l2-device.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-ioctl.h>\n#include <linux/debugfs.h>\n#include \"vpu.h\"\n#include \"vpu_imx8q.h\"\n\nbool debug;\nmodule_param(debug, bool, 0644);\n\nvoid vpu_writel(struct vpu_dev *vpu, u32 reg, u32 val)\n{\n\twritel(val, vpu->base + reg);\n}\n\nu32 vpu_readl(struct vpu_dev *vpu, u32 reg)\n{\n\treturn readl(vpu->base + reg);\n}\n\nstatic void vpu_dev_get(struct vpu_dev *vpu)\n{\n\tif (atomic_inc_return(&vpu->ref_vpu) == 1 && vpu->res->setup)\n\t\tvpu->res->setup(vpu);\n}\n\nstatic void vpu_dev_put(struct vpu_dev *vpu)\n{\n\tatomic_dec(&vpu->ref_vpu);\n}\n\nstatic void vpu_enc_get(struct vpu_dev *vpu)\n{\n\tif (atomic_inc_return(&vpu->ref_enc) == 1 && vpu->res->setup_encoder)\n\t\tvpu->res->setup_encoder(vpu);\n}\n\nstatic void vpu_enc_put(struct vpu_dev *vpu)\n{\n\tatomic_dec(&vpu->ref_enc);\n}\n\nstatic void vpu_dec_get(struct vpu_dev *vpu)\n{\n\tif (atomic_inc_return(&vpu->ref_dec) == 1 && vpu->res->setup_decoder)\n\t\tvpu->res->setup_decoder(vpu);\n}\n\nstatic void vpu_dec_put(struct vpu_dev *vpu)\n{\n\tatomic_dec(&vpu->ref_dec);\n}\n\nstatic int vpu_init_media_device(struct vpu_dev *vpu)\n{\n\tvpu->mdev.dev = vpu->dev;\n\tstrscpy(vpu->mdev.model, \"amphion-vpu\", sizeof(vpu->mdev.model));\n\tstrscpy(vpu->mdev.bus_info, \"platform: amphion-vpu\", sizeof(vpu->mdev.bus_info));\n\tmedia_device_init(&vpu->mdev);\n\tvpu->v4l2_dev.mdev = &vpu->mdev;\n\n\treturn 0;\n}\n\nstatic int vpu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct vpu_dev *vpu;\n\tint ret;\n\n\tdev_dbg(dev, \"probe\\n\");\n\tvpu = devm_kzalloc(dev, sizeof(*vpu), GFP_KERNEL);\n\tif (!vpu)\n\t\treturn -ENOMEM;\n\n\tvpu->pdev = pdev;\n\tvpu->dev = dev;\n\tmutex_init(&vpu->lock);\n\tINIT_LIST_HEAD(&vpu->cores);\n\tplatform_set_drvdata(pdev, vpu);\n\tatomic_set(&vpu->ref_vpu, 0);\n\tatomic_set(&vpu->ref_enc, 0);\n\tatomic_set(&vpu->ref_dec, 0);\n\tvpu->get_vpu = vpu_dev_get;\n\tvpu->put_vpu = vpu_dev_put;\n\tvpu->get_enc = vpu_enc_get;\n\tvpu->put_enc = vpu_enc_put;\n\tvpu->get_dec = vpu_dec_get;\n\tvpu->put_dec = vpu_dec_put;\n\n\tvpu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(vpu->base))\n\t\treturn PTR_ERR(vpu->base);\n\n\tvpu->res = of_device_get_match_data(dev);\n\tif (!vpu->res)\n\t\treturn -ENODEV;\n\n\tpm_runtime_enable(dev);\n\n\tret = v4l2_device_register(dev, &vpu->v4l2_dev);\n\tif (ret)\n\t\tgoto err_vpu_deinit;\n\n\tvpu_init_media_device(vpu);\n\tvpu->encoder.type = VPU_CORE_TYPE_ENC;\n\tvpu->encoder.function = MEDIA_ENT_F_PROC_VIDEO_ENCODER;\n\tvpu->decoder.type = VPU_CORE_TYPE_DEC;\n\tvpu->decoder.function = MEDIA_ENT_F_PROC_VIDEO_DECODER;\n\tret = vpu_add_func(vpu, &vpu->decoder);\n\tif (ret)\n\t\tgoto err_add_decoder;\n\tret = vpu_add_func(vpu, &vpu->encoder);\n\tif (ret)\n\t\tgoto err_add_encoder;\n\tret = media_device_register(&vpu->mdev);\n\tif (ret)\n\t\tgoto err_vpu_media;\n\tvpu->debugfs = debugfs_create_dir(\"amphion_vpu\", NULL);\n\n\tof_platform_populate(dev->of_node, NULL, NULL, dev);\n\n\treturn 0;\n\nerr_vpu_media:\n\tvpu_remove_func(&vpu->encoder);\nerr_add_encoder:\n\tvpu_remove_func(&vpu->decoder);\nerr_add_decoder:\n\tmedia_device_cleanup(&vpu->mdev);\n\tv4l2_device_unregister(&vpu->v4l2_dev);\nerr_vpu_deinit:\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic void vpu_remove(struct platform_device *pdev)\n{\n\tstruct vpu_dev *vpu = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\tdebugfs_remove_recursive(vpu->debugfs);\n\tvpu->debugfs = NULL;\n\n\tpm_runtime_disable(dev);\n\n\tmedia_device_unregister(&vpu->mdev);\n\tvpu_remove_func(&vpu->decoder);\n\tvpu_remove_func(&vpu->encoder);\n\tmedia_device_cleanup(&vpu->mdev);\n\tv4l2_device_unregister(&vpu->v4l2_dev);\n\tmutex_destroy(&vpu->lock);\n}\n\nstatic int __maybe_unused vpu_runtime_resume(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int __maybe_unused vpu_runtime_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int __maybe_unused vpu_resume(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int __maybe_unused vpu_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops vpu_pm_ops = {\n\tSET_RUNTIME_PM_OPS(vpu_runtime_suspend, vpu_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(vpu_suspend, vpu_resume)\n};\n\nstatic struct vpu_resources imx8qxp_res = {\n\t.plat_type = IMX8QXP,\n\t.mreg_base = 0x40000000,\n\t.setup = vpu_imx8q_setup,\n\t.setup_encoder = vpu_imx8q_setup_enc,\n\t.setup_decoder = vpu_imx8q_setup_dec,\n\t.reset = vpu_imx8q_reset\n};\n\nstatic struct vpu_resources imx8qm_res = {\n\t.plat_type = IMX8QM,\n\t.mreg_base = 0x40000000,\n\t.setup = vpu_imx8q_setup,\n\t.setup_encoder = vpu_imx8q_setup_enc,\n\t.setup_decoder = vpu_imx8q_setup_dec,\n\t.reset = vpu_imx8q_reset\n};\n\nstatic const struct of_device_id vpu_dt_match[] = {\n\t{ .compatible = \"nxp,imx8qxp-vpu\", .data = &imx8qxp_res },\n\t{ .compatible = \"nxp,imx8qm-vpu\", .data = &imx8qm_res },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, vpu_dt_match);\n\nstatic struct platform_driver amphion_vpu_driver = {\n\t.probe = vpu_probe,\n\t.remove_new = vpu_remove,\n\t.driver = {\n\t\t.name = \"amphion-vpu\",\n\t\t.of_match_table = vpu_dt_match,\n\t\t.pm = &vpu_pm_ops,\n\t},\n};\n\nstatic int __init vpu_driver_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&amphion_vpu_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vpu_core_driver_init();\n\tif (ret)\n\t\tplatform_driver_unregister(&amphion_vpu_driver);\n\n\treturn ret;\n}\n\nstatic void __exit vpu_driver_exit(void)\n{\n\tvpu_core_driver_exit();\n\tplatform_driver_unregister(&amphion_vpu_driver);\n}\nmodule_init(vpu_driver_init);\nmodule_exit(vpu_driver_exit);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"Linux VPU driver for Freescale i.MX8Q\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}