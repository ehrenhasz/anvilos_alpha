{
  "module_name": "vpu_imx8q.c",
  "hash_id": "21e4866cd35cfa8ba38b94e3899b73e14366227619a7e317447af898c5b106f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/amphion/vpu_imx8q.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/ioctl.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include \"vpu.h\"\n#include \"vpu_core.h\"\n#include \"vpu_imx8q.h\"\n#include \"vpu_rpc.h\"\n\n#define IMX8Q_CSR_CM0Px_ADDR_OFFSET\t\t\t0x00000000\n#define IMX8Q_CSR_CM0Px_CPUWAIT\t\t\t\t0x00000004\n\n#ifdef CONFIG_IMX_SCU\n#include <linux/firmware/imx/ipc.h>\n#include <linux/firmware/imx/svc/misc.h>\n\n#define VPU_DISABLE_BITS\t\t\t0x7\n#define VPU_IMX_DECODER_FUSE_OFFSET\t\t14\n#define VPU_ENCODER_MASK\t\t\t0x1\n#define VPU_DECODER_MASK\t\t\t0x3UL\n#define VPU_DECODER_H264_MASK\t\t\t0x2UL\n#define VPU_DECODER_HEVC_MASK\t\t\t0x1UL\n\nstatic u32 imx8q_fuse;\n\nstruct vpu_sc_msg_misc {\n\tstruct imx_sc_rpc_msg hdr;\n\tu32 word;\n} __packed;\n#endif\n\nint vpu_imx8q_setup_dec(struct vpu_dev *vpu)\n{\n\tconst off_t offset = DEC_MFD_XREG_SLV_BASE + MFD_BLK_CTRL;\n\n\tvpu_writel(vpu, offset + MFD_BLK_CTRL_MFD_SYS_CLOCK_ENABLE_SET, 0x1f);\n\tvpu_writel(vpu, offset + MFD_BLK_CTRL_MFD_SYS_RESET_SET, 0xffffffff);\n\n\treturn 0;\n}\n\nint vpu_imx8q_setup_enc(struct vpu_dev *vpu)\n{\n\treturn 0;\n}\n\nint vpu_imx8q_setup(struct vpu_dev *vpu)\n{\n\tconst off_t offset = SCB_XREG_SLV_BASE + SCB_SCB_BLK_CTRL;\n\n\tvpu_readl(vpu, offset + 0x108);\n\n\tvpu_writel(vpu, offset + SCB_BLK_CTRL_SCB_CLK_ENABLE_SET, 0x1);\n\tvpu_writel(vpu, offset + 0x190, 0xffffffff);\n\tvpu_writel(vpu, offset + SCB_BLK_CTRL_XMEM_RESET_SET, 0xffffffff);\n\tvpu_writel(vpu, offset + SCB_BLK_CTRL_SCB_CLK_ENABLE_SET, 0xE);\n\tvpu_writel(vpu, offset + SCB_BLK_CTRL_CACHE_RESET_SET, 0x7);\n\tvpu_writel(vpu, XMEM_CONTROL, 0x102);\n\n\tvpu_readl(vpu, offset + 0x108);\n\n\treturn 0;\n}\n\nstatic int vpu_imx8q_reset_enc(struct vpu_dev *vpu)\n{\n\treturn 0;\n}\n\nstatic int vpu_imx8q_reset_dec(struct vpu_dev *vpu)\n{\n\tconst off_t offset = DEC_MFD_XREG_SLV_BASE + MFD_BLK_CTRL;\n\n\tvpu_writel(vpu, offset + MFD_BLK_CTRL_MFD_SYS_RESET_CLR, 0xffffffff);\n\n\treturn 0;\n}\n\nint vpu_imx8q_reset(struct vpu_dev *vpu)\n{\n\tconst off_t offset = SCB_XREG_SLV_BASE + SCB_SCB_BLK_CTRL;\n\n\tvpu_writel(vpu, offset + SCB_BLK_CTRL_CACHE_RESET_CLR, 0x7);\n\tvpu_imx8q_reset_enc(vpu);\n\tvpu_imx8q_reset_dec(vpu);\n\n\treturn 0;\n}\n\nint vpu_imx8q_set_system_cfg_common(struct vpu_rpc_system_config *config, u32 regs, u32 core_id)\n{\n\tif (!config)\n\t\treturn -EINVAL;\n\n\tswitch (core_id) {\n\tcase 0:\n\t\tconfig->malone_base_addr[0] = regs + DEC_MFD_XREG_SLV_BASE;\n\t\tconfig->num_malones = 1;\n\t\tconfig->num_windsors = 0;\n\t\tbreak;\n\tcase 1:\n\t\tconfig->windsor_base_addr[0] = regs + ENC_MFD_XREG_SLV_0_BASE;\n\t\tconfig->num_windsors = 1;\n\t\tconfig->num_malones = 0;\n\t\tbreak;\n\tcase 2:\n\t\tconfig->windsor_base_addr[0] = regs + ENC_MFD_XREG_SLV_1_BASE;\n\t\tconfig->num_windsors = 1;\n\t\tconfig->num_malones = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (config->num_windsors) {\n\t\tconfig->windsor_irq_pin[0x0][0x0] = WINDSOR_PAL_IRQ_PIN_L;\n\t\tconfig->windsor_irq_pin[0x0][0x1] = WINDSOR_PAL_IRQ_PIN_H;\n\t}\n\n\tconfig->malone_base_addr[0x1] = 0x0;\n\tconfig->hif_offset[0x0] = MFD_HIF;\n\tconfig->hif_offset[0x1] = 0x0;\n\n\tconfig->dpv_base_addr = 0x0;\n\tconfig->dpv_irq_pin = 0x0;\n\tconfig->pixif_base_addr = regs + DEC_MFD_XREG_SLV_BASE + MFD_PIX_IF;\n\tconfig->cache_base_addr[0] = regs + MC_CACHE_0_BASE;\n\tconfig->cache_base_addr[1] = regs + MC_CACHE_1_BASE;\n\n\treturn 0;\n}\n\nint vpu_imx8q_boot_core(struct vpu_core *core)\n{\n\tcsr_writel(core, IMX8Q_CSR_CM0Px_ADDR_OFFSET, core->fw.phys);\n\tcsr_writel(core, IMX8Q_CSR_CM0Px_CPUWAIT, 0);\n\treturn 0;\n}\n\nint vpu_imx8q_get_power_state(struct vpu_core *core)\n{\n\tif (csr_readl(core, IMX8Q_CSR_CM0Px_CPUWAIT) == 1)\n\t\treturn 0;\n\treturn 1;\n}\n\nint vpu_imx8q_on_firmware_loaded(struct vpu_core *core)\n{\n\tu8 *p;\n\n\tp = core->fw.virt;\n\tp[16] = core->vpu->res->plat_type;\n\tp[17] = core->id;\n\tp[18] = 1;\n\n\treturn 0;\n}\n\nint vpu_imx8q_check_memory_region(dma_addr_t base, dma_addr_t addr, u32 size)\n{\n\tconst struct vpu_rpc_region_t imx8q_regions[] = {\n\t\t{0x00000000, 0x08000000, VPU_CORE_MEMORY_CACHED},\n\t\t{0x08000000, 0x10000000, VPU_CORE_MEMORY_UNCACHED},\n\t\t{0x10000000, 0x20000000, VPU_CORE_MEMORY_CACHED},\n\t\t{0x20000000, 0x40000000, VPU_CORE_MEMORY_UNCACHED}\n\t};\n\tint i;\n\n\tif (addr < base)\n\t\treturn VPU_CORE_MEMORY_INVALID;\n\n\taddr -= base;\n\tfor (i = 0; i < ARRAY_SIZE(imx8q_regions); i++) {\n\t\tconst struct vpu_rpc_region_t *region = &imx8q_regions[i];\n\n\t\tif (addr >= region->start && addr + size < region->end)\n\t\t\treturn region->type;\n\t}\n\n\treturn VPU_CORE_MEMORY_INVALID;\n}\n\n#ifdef CONFIG_IMX_SCU\nstatic u32 vpu_imx8q_get_fuse(void)\n{\n\tstatic u32 fuse_got;\n\tstruct imx_sc_ipc *ipc;\n\tstruct vpu_sc_msg_misc msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tint ret;\n\n\tif (fuse_got)\n\t\treturn imx8q_fuse;\n\n\tret = imx_scu_get_handle(&ipc);\n\tif (ret) {\n\t\tpr_err(\"error: get sct handle fail: %d\\n\", ret);\n\t\treturn 0;\n\t}\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_MISC;\n\thdr->func = IMX_SC_MISC_FUNC_OTP_FUSE_READ;\n\thdr->size = 2;\n\n\tmsg.word = VPU_DISABLE_BITS;\n\n\tret = imx_scu_call_rpc(ipc, &msg, true);\n\tif (ret)\n\t\treturn 0;\n\n\timx8q_fuse = msg.word;\n\tfuse_got = 1;\n\treturn imx8q_fuse;\n}\n\nbool vpu_imx8q_check_codec(enum vpu_core_type type)\n{\n\tu32 fuse = vpu_imx8q_get_fuse();\n\n\tif (type == VPU_CORE_TYPE_ENC) {\n\t\tif (fuse & VPU_ENCODER_MASK)\n\t\t\treturn false;\n\t} else if (type == VPU_CORE_TYPE_DEC) {\n\t\tfuse >>= VPU_IMX_DECODER_FUSE_OFFSET;\n\t\tfuse &= VPU_DECODER_MASK;\n\n\t\tif (fuse == VPU_DECODER_MASK)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool vpu_imx8q_check_fmt(enum vpu_core_type type, u32 pixelfmt)\n{\n\tu32 fuse = vpu_imx8q_get_fuse();\n\n\tif (type == VPU_CORE_TYPE_DEC) {\n\t\tfuse >>= VPU_IMX_DECODER_FUSE_OFFSET;\n\t\tfuse &= VPU_DECODER_MASK;\n\n\t\tif (fuse == VPU_DECODER_HEVC_MASK && pixelfmt == V4L2_PIX_FMT_HEVC)\n\t\t\treturn false;\n\t\tif (fuse == VPU_DECODER_H264_MASK && pixelfmt == V4L2_PIX_FMT_H264)\n\t\t\treturn false;\n\t\tif (fuse == VPU_DECODER_MASK)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n#else\nbool vpu_imx8q_check_codec(enum vpu_core_type type)\n{\n\treturn true;\n}\n\nbool vpu_imx8q_check_fmt(enum vpu_core_type type, u32 pixelfmt)\n{\n\treturn true;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}