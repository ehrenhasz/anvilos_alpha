{
  "module_name": "vpu_helpers.c",
  "hash_id": "890a357e1bdf8dad3db6ab66dc40368e4c0b94c4627560d657227310f0112558",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/amphion/vpu_helpers.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interconnect.h>\n#include <linux/ioctl.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include \"vpu.h\"\n#include \"vpu_defs.h\"\n#include \"vpu_core.h\"\n#include \"vpu_rpc.h\"\n#include \"vpu_helpers.h\"\n\nint vpu_helper_find_in_array_u8(const u8 *array, u32 size, u32 x)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (array[i] == x)\n\t\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\nbool vpu_helper_check_type(struct vpu_inst *inst, u32 type)\n{\n\tconst struct vpu_format *pfmt;\n\n\tfor (pfmt = inst->formats; pfmt->pixfmt; pfmt++) {\n\t\tif (!vpu_iface_check_format(inst, pfmt->pixfmt))\n\t\t\tcontinue;\n\t\tif (pfmt->type == type)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nconst struct vpu_format *vpu_helper_find_format(struct vpu_inst *inst, u32 type, u32 pixelfmt)\n{\n\tconst struct vpu_format *pfmt;\n\n\tif (!inst || !inst->formats)\n\t\treturn NULL;\n\n\tif (!vpu_iface_check_format(inst, pixelfmt))\n\t\treturn NULL;\n\n\tfor (pfmt = inst->formats; pfmt->pixfmt; pfmt++) {\n\t\tif (pfmt->pixfmt == pixelfmt && (!type || type == pfmt->type))\n\t\t\treturn pfmt;\n\t}\n\n\treturn NULL;\n}\n\nconst struct vpu_format *vpu_helper_find_sibling(struct vpu_inst *inst, u32 type, u32 pixelfmt)\n{\n\tconst struct vpu_format *fmt;\n\tconst struct vpu_format *sibling;\n\n\tfmt = vpu_helper_find_format(inst, type, pixelfmt);\n\tif (!fmt || !fmt->sibling)\n\t\treturn NULL;\n\n\tsibling = vpu_helper_find_format(inst, type, fmt->sibling);\n\tif (!sibling || sibling->sibling != fmt->pixfmt ||\n\t    sibling->comp_planes != fmt->comp_planes)\n\t\treturn NULL;\n\n\treturn sibling;\n}\n\nbool vpu_helper_match_format(struct vpu_inst *inst, u32 type, u32 fmta, u32 fmtb)\n{\n\tconst struct vpu_format *sibling;\n\n\tif (fmta == fmtb)\n\t\treturn true;\n\n\tsibling = vpu_helper_find_sibling(inst, type, fmta);\n\tif (sibling && sibling->pixfmt == fmtb)\n\t\treturn true;\n\treturn false;\n}\n\nconst struct vpu_format *vpu_helper_enum_format(struct vpu_inst *inst, u32 type, int index)\n{\n\tconst struct vpu_format *pfmt;\n\tint i = 0;\n\n\tif (!inst || !inst->formats)\n\t\treturn NULL;\n\n\tfor (pfmt = inst->formats; pfmt->pixfmt; pfmt++) {\n\t\tif (!vpu_iface_check_format(inst, pfmt->pixfmt))\n\t\t\tcontinue;\n\n\t\tif (pfmt->type == type) {\n\t\t\tif (index == i)\n\t\t\t\treturn pfmt;\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nu32 vpu_helper_valid_frame_width(struct vpu_inst *inst, u32 width)\n{\n\tconst struct vpu_core_resources *res;\n\n\tif (!inst)\n\t\treturn width;\n\n\tres = vpu_get_resource(inst);\n\tif (!res)\n\t\treturn width;\n\tif (res->max_width)\n\t\twidth = clamp(width, res->min_width, res->max_width);\n\tif (res->step_width)\n\t\twidth = ALIGN(width, res->step_width);\n\n\treturn width;\n}\n\nu32 vpu_helper_valid_frame_height(struct vpu_inst *inst, u32 height)\n{\n\tconst struct vpu_core_resources *res;\n\n\tif (!inst)\n\t\treturn height;\n\n\tres = vpu_get_resource(inst);\n\tif (!res)\n\t\treturn height;\n\tif (res->max_height)\n\t\theight = clamp(height, res->min_height, res->max_height);\n\tif (res->step_height)\n\t\theight = ALIGN(height, res->step_height);\n\n\treturn height;\n}\n\nstatic u32 get_nv12_plane_size(u32 width, u32 height, int plane_no,\n\t\t\t       u32 stride, u32 interlaced, u32 *pbl)\n{\n\tu32 bytesperline;\n\tu32 size = 0;\n\n\tbytesperline = width;\n\tif (pbl)\n\t\tbytesperline = max(bytesperline, *pbl);\n\tbytesperline = ALIGN(bytesperline, stride);\n\theight = ALIGN(height, 2);\n\tif (plane_no == 0)\n\t\tsize = bytesperline * height;\n\telse if (plane_no == 1)\n\t\tsize = bytesperline * height >> 1;\n\tif (pbl)\n\t\t*pbl = bytesperline;\n\n\treturn size;\n}\n\nstatic u32 get_tiled_8l128_plane_size(u32 fmt, u32 width, u32 height, int plane_no,\n\t\t\t\t      u32 stride, u32 interlaced, u32 *pbl)\n{\n\tu32 ws = 3;\n\tu32 hs = 7;\n\tu32 bitdepth = 8;\n\tu32 bytesperline;\n\tu32 size = 0;\n\n\tif (interlaced)\n\t\ths++;\n\tif (fmt == V4L2_PIX_FMT_NV12M_10BE_8L128 || fmt == V4L2_PIX_FMT_NV12_10BE_8L128)\n\t\tbitdepth = 10;\n\tbytesperline = DIV_ROUND_UP(width * bitdepth, BITS_PER_BYTE);\n\tif (pbl)\n\t\tbytesperline = max(bytesperline, *pbl);\n\tbytesperline = ALIGN(bytesperline, 1 << ws);\n\tbytesperline = ALIGN(bytesperline, stride);\n\theight = ALIGN(height, 1 << hs);\n\tif (plane_no == 0)\n\t\tsize = bytesperline * height;\n\telse if (plane_no == 1)\n\t\tsize = (bytesperline * ALIGN(height, 1 << (hs + 1))) >> 1;\n\tif (pbl)\n\t\t*pbl = bytesperline;\n\n\treturn size;\n}\n\nstatic u32 get_default_plane_size(u32 width, u32 height, int plane_no,\n\t\t\t\t  u32 stride, u32 interlaced, u32 *pbl)\n{\n\tu32 bytesperline;\n\tu32 size = 0;\n\n\tbytesperline = width;\n\tif (pbl)\n\t\tbytesperline = max(bytesperline, *pbl);\n\tbytesperline = ALIGN(bytesperline, stride);\n\tif (plane_no == 0)\n\t\tsize = bytesperline * height;\n\tif (pbl)\n\t\t*pbl = bytesperline;\n\n\treturn size;\n}\n\nu32 vpu_helper_get_plane_size(u32 fmt, u32 w, u32 h, int plane_no,\n\t\t\t      u32 stride, u32 interlaced, u32 *pbl)\n{\n\tswitch (fmt) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV12M:\n\t\treturn get_nv12_plane_size(w, h, plane_no, stride, interlaced, pbl);\n\tcase V4L2_PIX_FMT_NV12_8L128:\n\tcase V4L2_PIX_FMT_NV12M_8L128:\n\tcase V4L2_PIX_FMT_NV12_10BE_8L128:\n\tcase V4L2_PIX_FMT_NV12M_10BE_8L128:\n\t\treturn get_tiled_8l128_plane_size(fmt, w, h, plane_no, stride, interlaced, pbl);\n\tdefault:\n\t\treturn get_default_plane_size(w, h, plane_no, stride, interlaced, pbl);\n\t}\n}\n\nint vpu_helper_copy_from_stream_buffer(struct vpu_buffer *stream_buffer,\n\t\t\t\t       u32 *rptr, u32 size, void *dst)\n{\n\tu32 offset;\n\tu32 start;\n\tu32 end;\n\tvoid *virt;\n\n\tif (!stream_buffer || !rptr || !dst)\n\t\treturn -EINVAL;\n\n\tif (!size)\n\t\treturn 0;\n\n\toffset = *rptr;\n\tstart = stream_buffer->phys;\n\tend = start + stream_buffer->length;\n\tvirt = stream_buffer->virt;\n\n\tif (offset < start || offset > end)\n\t\treturn -EINVAL;\n\n\tif (offset + size <= end) {\n\t\tmemcpy(dst, virt + (offset - start), size);\n\t} else {\n\t\tmemcpy(dst, virt + (offset - start), end - offset);\n\t\tmemcpy(dst + end - offset, virt, size + offset - end);\n\t}\n\n\t*rptr = vpu_helper_step_walk(stream_buffer, offset, size);\n\n\treturn 0;\n}\n\nint vpu_helper_copy_to_stream_buffer(struct vpu_buffer *stream_buffer,\n\t\t\t\t     u32 *wptr, u32 size, void *src)\n{\n\tu32 offset;\n\tu32 start;\n\tu32 end;\n\tvoid *virt;\n\n\tif (!stream_buffer || !wptr || !src)\n\t\treturn -EINVAL;\n\n\tif (!size)\n\t\treturn 0;\n\n\toffset = *wptr;\n\tstart = stream_buffer->phys;\n\tend = start + stream_buffer->length;\n\tvirt = stream_buffer->virt;\n\tif (offset < start || offset > end)\n\t\treturn -EINVAL;\n\n\tif (offset + size <= end) {\n\t\tmemcpy(virt + (offset - start), src, size);\n\t} else {\n\t\tmemcpy(virt + (offset - start), src, end - offset);\n\t\tmemcpy(virt, src + end - offset, size + offset - end);\n\t}\n\n\t*wptr = vpu_helper_step_walk(stream_buffer, offset, size);\n\n\treturn 0;\n}\n\nint vpu_helper_memset_stream_buffer(struct vpu_buffer *stream_buffer,\n\t\t\t\t    u32 *wptr, u8 val, u32 size)\n{\n\tu32 offset;\n\tu32 start;\n\tu32 end;\n\tvoid *virt;\n\n\tif (!stream_buffer || !wptr)\n\t\treturn -EINVAL;\n\n\tif (!size)\n\t\treturn 0;\n\n\toffset = *wptr;\n\tstart = stream_buffer->phys;\n\tend = start + stream_buffer->length;\n\tvirt = stream_buffer->virt;\n\tif (offset < start || offset > end)\n\t\treturn -EINVAL;\n\n\tif (offset + size <= end) {\n\t\tmemset(virt + (offset - start), val, size);\n\t} else {\n\t\tmemset(virt + (offset - start), val, end - offset);\n\t\tmemset(virt, val, size + offset - end);\n\t}\n\n\toffset += size;\n\tif (offset >= end)\n\t\toffset -= stream_buffer->length;\n\n\t*wptr = offset;\n\n\treturn 0;\n}\n\nu32 vpu_helper_get_free_space(struct vpu_inst *inst)\n{\n\tstruct vpu_rpc_buffer_desc desc;\n\n\tif (vpu_iface_get_stream_buffer_desc(inst, &desc))\n\t\treturn 0;\n\n\tif (desc.rptr > desc.wptr)\n\t\treturn desc.rptr - desc.wptr;\n\telse if (desc.rptr < desc.wptr)\n\t\treturn (desc.end - desc.start + desc.rptr - desc.wptr);\n\telse\n\t\treturn desc.end - desc.start;\n}\n\nu32 vpu_helper_get_used_space(struct vpu_inst *inst)\n{\n\tstruct vpu_rpc_buffer_desc desc;\n\n\tif (vpu_iface_get_stream_buffer_desc(inst, &desc))\n\t\treturn 0;\n\n\tif (desc.wptr > desc.rptr)\n\t\treturn desc.wptr - desc.rptr;\n\telse if (desc.wptr < desc.rptr)\n\t\treturn (desc.end - desc.start + desc.wptr - desc.rptr);\n\telse\n\t\treturn 0;\n}\n\nint vpu_helper_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vpu_inst *inst = ctrl_to_inst(ctrl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:\n\t\tctrl->val = inst->min_buffer_cap;\n\t\tbreak;\n\tcase V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:\n\t\tctrl->val = inst->min_buffer_out;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint vpu_helper_find_startcode(struct vpu_buffer *stream_buffer,\n\t\t\t      u32 pixelformat, u32 offset, u32 bytesused)\n{\n\tu32 start_code;\n\tint start_code_size;\n\tu32 val = 0;\n\tint i;\n\tint ret = -EINVAL;\n\n\tif (!stream_buffer || !stream_buffer->virt)\n\t\treturn -EINVAL;\n\n\tswitch (pixelformat) {\n\tcase V4L2_PIX_FMT_H264:\n\t\tstart_code_size = 4;\n\t\tstart_code = 0x00000001;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < bytesused; i++) {\n\t\tval = (val << 8) | vpu_helper_read_byte(stream_buffer, offset + i);\n\t\tif (i < start_code_size - 1)\n\t\t\tcontinue;\n\t\tif (val == start_code) {\n\t\t\tret = i + 1 - start_code_size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint vpu_find_dst_by_src(struct vpu_pair *pairs, u32 cnt, u32 src)\n{\n\tu32 i;\n\n\tif (!pairs || !cnt)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (pairs[i].src == src)\n\t\t\treturn pairs[i].dst;\n\t}\n\n\treturn -EINVAL;\n}\n\nint vpu_find_src_by_dst(struct vpu_pair *pairs, u32 cnt, u32 dst)\n{\n\tu32 i;\n\n\tif (!pairs || !cnt)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (pairs[i].dst == dst)\n\t\t\treturn pairs[i].src;\n\t}\n\n\treturn -EINVAL;\n}\n\nconst char *vpu_id_name(u32 id)\n{\n\tswitch (id) {\n\tcase VPU_CMD_ID_NOOP: return \"noop\";\n\tcase VPU_CMD_ID_CONFIGURE_CODEC: return \"configure codec\";\n\tcase VPU_CMD_ID_START: return \"start\";\n\tcase VPU_CMD_ID_STOP: return \"stop\";\n\tcase VPU_CMD_ID_ABORT: return \"abort\";\n\tcase VPU_CMD_ID_RST_BUF: return \"reset buf\";\n\tcase VPU_CMD_ID_SNAPSHOT: return \"snapshot\";\n\tcase VPU_CMD_ID_FIRM_RESET: return \"reset firmware\";\n\tcase VPU_CMD_ID_UPDATE_PARAMETER: return \"update parameter\";\n\tcase VPU_CMD_ID_FRAME_ENCODE: return \"encode frame\";\n\tcase VPU_CMD_ID_SKIP: return \"skip\";\n\tcase VPU_CMD_ID_FS_ALLOC: return \"alloc fb\";\n\tcase VPU_CMD_ID_FS_RELEASE: return \"release fb\";\n\tcase VPU_CMD_ID_TIMESTAMP: return \"timestamp\";\n\tcase VPU_CMD_ID_DEBUG: return \"debug\";\n\tcase VPU_MSG_ID_RESET_DONE: return \"reset done\";\n\tcase VPU_MSG_ID_START_DONE: return \"start done\";\n\tcase VPU_MSG_ID_STOP_DONE: return \"stop done\";\n\tcase VPU_MSG_ID_ABORT_DONE: return \"abort done\";\n\tcase VPU_MSG_ID_BUF_RST: return \"buf reset done\";\n\tcase VPU_MSG_ID_MEM_REQUEST: return \"mem request\";\n\tcase VPU_MSG_ID_PARAM_UPD_DONE: return \"param upd done\";\n\tcase VPU_MSG_ID_FRAME_INPUT_DONE: return \"frame input done\";\n\tcase VPU_MSG_ID_ENC_DONE: return \"encode done\";\n\tcase VPU_MSG_ID_DEC_DONE: return \"frame display\";\n\tcase VPU_MSG_ID_FRAME_REQ: return \"fb request\";\n\tcase VPU_MSG_ID_FRAME_RELEASE: return \"fb release\";\n\tcase VPU_MSG_ID_SEQ_HDR_FOUND: return \"seq hdr found\";\n\tcase VPU_MSG_ID_RES_CHANGE: return \"resolution change\";\n\tcase VPU_MSG_ID_PIC_HDR_FOUND: return \"pic hdr found\";\n\tcase VPU_MSG_ID_PIC_DECODED: return \"picture decoded\";\n\tcase VPU_MSG_ID_PIC_EOS: return \"eos\";\n\tcase VPU_MSG_ID_FIFO_LOW: return \"fifo low\";\n\tcase VPU_MSG_ID_BS_ERROR: return \"bs error\";\n\tcase VPU_MSG_ID_UNSUPPORTED: return \"unsupported\";\n\tcase VPU_MSG_ID_FIRMWARE_XCPT: return \"exception\";\n\tcase VPU_MSG_ID_PIC_SKIPPED: return \"skipped\";\n\tcase VPU_MSG_ID_DBG_MSG: return \"debug msg\";\n\t}\n\treturn \"<unknown>\";\n}\n\nconst char *vpu_codec_state_name(enum vpu_codec_state state)\n{\n\tswitch (state) {\n\tcase VPU_CODEC_STATE_DEINIT: return \"initialization\";\n\tcase VPU_CODEC_STATE_CONFIGURED: return \"configured\";\n\tcase VPU_CODEC_STATE_START: return \"start\";\n\tcase VPU_CODEC_STATE_STARTED: return \"started\";\n\tcase VPU_CODEC_STATE_ACTIVE: return \"active\";\n\tcase VPU_CODEC_STATE_SEEK: return \"seek\";\n\tcase VPU_CODEC_STATE_STOP: return \"stop\";\n\tcase VPU_CODEC_STATE_DRAIN: return \"drain\";\n\tcase VPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE: return \"resolution change\";\n\t}\n\treturn \"<unknown>\";\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}