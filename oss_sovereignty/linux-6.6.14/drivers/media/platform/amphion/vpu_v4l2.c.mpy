{
  "module_name": "vpu_v4l2.c",
  "hash_id": "4738ceba0b0db035e7a0b714461775788aaac9e6c34071944f751d44154c7c80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/amphion/vpu_v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interconnect.h>\n#include <linux/ioctl.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-vmalloc.h>\n#include \"vpu.h\"\n#include \"vpu_core.h\"\n#include \"vpu_v4l2.h\"\n#include \"vpu_msgs.h\"\n#include \"vpu_helpers.h\"\n\nvoid vpu_inst_lock(struct vpu_inst *inst)\n{\n\tmutex_lock(&inst->lock);\n}\n\nvoid vpu_inst_unlock(struct vpu_inst *inst)\n{\n\tmutex_unlock(&inst->lock);\n}\n\ndma_addr_t vpu_get_vb_phy_addr(struct vb2_buffer *vb, u32 plane_no)\n{\n\tif (plane_no >= vb->num_planes)\n\t\treturn 0;\n\treturn vb2_dma_contig_plane_dma_addr(vb, plane_no) +\n\t\t\tvb->planes[plane_no].data_offset;\n}\n\nunsigned int vpu_get_vb_length(struct vb2_buffer *vb, u32 plane_no)\n{\n\tif (plane_no >= vb->num_planes)\n\t\treturn 0;\n\treturn vb2_plane_size(vb, plane_no) - vb->planes[plane_no].data_offset;\n}\n\nvoid vpu_set_buffer_state(struct vb2_v4l2_buffer *vbuf, unsigned int state)\n{\n\tstruct vpu_vb2_buffer *vpu_buf = to_vpu_vb2_buffer(vbuf);\n\n\tvpu_buf->state = state;\n}\n\nunsigned int vpu_get_buffer_state(struct vb2_v4l2_buffer *vbuf)\n{\n\tstruct vpu_vb2_buffer *vpu_buf = to_vpu_vb2_buffer(vbuf);\n\n\treturn vpu_buf->state;\n}\n\nvoid vpu_v4l2_set_error(struct vpu_inst *inst)\n{\n\tvpu_inst_lock(inst);\n\tdev_err(inst->dev, \"some error occurs in codec\\n\");\n\tif (inst->fh.m2m_ctx) {\n\t\tvb2_queue_error(v4l2_m2m_get_src_vq(inst->fh.m2m_ctx));\n\t\tvb2_queue_error(v4l2_m2m_get_dst_vq(inst->fh.m2m_ctx));\n\t}\n\tvpu_inst_unlock(inst);\n}\n\nint vpu_notify_eos(struct vpu_inst *inst)\n{\n\tstatic const struct v4l2_event ev = {\n\t\t.id = 0,\n\t\t.type = V4L2_EVENT_EOS\n\t};\n\n\tvpu_trace(inst->dev, \"[%d]\\n\", inst->id);\n\tv4l2_event_queue_fh(&inst->fh, &ev);\n\n\treturn 0;\n}\n\nint vpu_notify_source_change(struct vpu_inst *inst)\n{\n\tstatic const struct v4l2_event ev = {\n\t\t.id = 0,\n\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION\n\t};\n\n\tvpu_trace(inst->dev, \"[%d]\\n\", inst->id);\n\tv4l2_event_queue_fh(&inst->fh, &ev);\n\treturn 0;\n}\n\nint vpu_set_last_buffer_dequeued(struct vpu_inst *inst, bool eos)\n{\n\tstruct vb2_queue *q;\n\n\tif (!inst || !inst->fh.m2m_ctx)\n\t\treturn -EINVAL;\n\n\tq = v4l2_m2m_get_dst_vq(inst->fh.m2m_ctx);\n\tif (!list_empty(&q->done_list))\n\t\treturn -EINVAL;\n\n\tif (q->last_buffer_dequeued)\n\t\treturn 0;\n\tvpu_trace(inst->dev, \"last buffer dequeued\\n\");\n\tq->last_buffer_dequeued = true;\n\twake_up(&q->done_wq);\n\tif (eos)\n\t\tvpu_notify_eos(inst);\n\treturn 0;\n}\n\nbool vpu_is_source_empty(struct vpu_inst *inst)\n{\n\tstruct v4l2_m2m_buffer *buf = NULL;\n\n\tif (!inst->fh.m2m_ctx)\n\t\treturn true;\n\tv4l2_m2m_for_each_src_buf(inst->fh.m2m_ctx, buf) {\n\t\tif (vpu_get_buffer_state(&buf->vb) == VPU_BUF_STATE_IDLE)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int vpu_init_format(struct vpu_inst *inst, struct vpu_format *fmt)\n{\n\tconst struct vpu_format *info;\n\n\tinfo = vpu_helper_find_format(inst, fmt->type, fmt->pixfmt);\n\tif (!info) {\n\t\tinfo = vpu_helper_enum_format(inst, fmt->type, 0);\n\t\tif (!info)\n\t\t\treturn -EINVAL;\n\t}\n\tmemcpy(fmt, info, sizeof(*fmt));\n\n\treturn 0;\n}\n\nstatic int vpu_calc_fmt_bytesperline(struct v4l2_format *f, struct vpu_format *fmt)\n{\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tint i;\n\n\tif (fmt->flags & V4L2_FMT_FLAG_COMPRESSED) {\n\t\tfor (i = 0; i < fmt->comp_planes; i++)\n\t\t\tfmt->bytesperline[i] = 0;\n\t\treturn 0;\n\t}\n\tif (pixmp->num_planes == fmt->comp_planes) {\n\t\tfor (i = 0; i < fmt->comp_planes; i++)\n\t\t\tfmt->bytesperline[i] = pixmp->plane_fmt[i].bytesperline;\n\t\treturn 0;\n\t}\n\tif (pixmp->num_planes > 1)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < fmt->comp_planes; i++)\n\t\tfmt->bytesperline[i] = pixmp->plane_fmt[0].bytesperline;\n\n\treturn 0;\n}\n\nstatic int vpu_calc_fmt_sizeimage(struct vpu_inst *inst, struct vpu_format *fmt)\n{\n\tu32 stride = 1;\n\tint i;\n\n\tif (!(fmt->flags & V4L2_FMT_FLAG_COMPRESSED)) {\n\t\tconst struct vpu_core_resources *res = vpu_get_resource(inst);\n\n\t\tif (res)\n\t\t\tstride = res->stride;\n\t}\n\n\tfor (i = 0; i < fmt->comp_planes; i++) {\n\t\tfmt->sizeimage[i] = vpu_helper_get_plane_size(fmt->pixfmt,\n\t\t\t\t\t\t\t      fmt->width,\n\t\t\t\t\t\t\t      fmt->height,\n\t\t\t\t\t\t\t      i,\n\t\t\t\t\t\t\t      stride,\n\t\t\t\t\t\t\t      fmt->field != V4L2_FIELD_NONE ? 1 : 0,\n\t\t\t\t\t\t\t      &fmt->bytesperline[i]);\n\t\tfmt->sizeimage[i] = max_t(u32, fmt->sizeimage[i], PAGE_SIZE);\n\t\tif (fmt->flags & V4L2_FMT_FLAG_COMPRESSED) {\n\t\t\tfmt->sizeimage[i] = clamp_val(fmt->sizeimage[i], SZ_128K, SZ_8M);\n\t\t\tfmt->bytesperline[i] = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nu32 vpu_get_fmt_plane_size(struct vpu_format *fmt, u32 plane_no)\n{\n\tu32 size;\n\tint i;\n\n\tif (plane_no >= fmt->mem_planes)\n\t\treturn 0;\n\n\tif (fmt->comp_planes == fmt->mem_planes)\n\t\treturn fmt->sizeimage[plane_no];\n\tif (plane_no < fmt->mem_planes - 1)\n\t\treturn fmt->sizeimage[plane_no];\n\n\tsize = fmt->sizeimage[plane_no];\n\tfor (i = fmt->mem_planes; i < fmt->comp_planes; i++)\n\t\tsize += fmt->sizeimage[i];\n\n\treturn size;\n}\n\nint vpu_try_fmt_common(struct vpu_inst *inst, struct v4l2_format *f, struct vpu_format *fmt)\n{\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tint i;\n\tint ret;\n\n\tfmt->pixfmt = pixmp->pixelformat;\n\tfmt->type = f->type;\n\tret = vpu_init_format(inst, fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmt->width = pixmp->width;\n\tfmt->height = pixmp->height;\n\tif (fmt->width)\n\t\tfmt->width = vpu_helper_valid_frame_width(inst, fmt->width);\n\tif (fmt->height)\n\t\tfmt->height = vpu_helper_valid_frame_height(inst, fmt->height);\n\tfmt->field = pixmp->field == V4L2_FIELD_ANY ? V4L2_FIELD_NONE : pixmp->field;\n\tvpu_calc_fmt_bytesperline(f, fmt);\n\tvpu_calc_fmt_sizeimage(inst, fmt);\n\tif ((fmt->flags & V4L2_FMT_FLAG_COMPRESSED) && pixmp->plane_fmt[0].sizeimage)\n\t\tfmt->sizeimage[0] = clamp_val(pixmp->plane_fmt[0].sizeimage, SZ_128K, SZ_8M);\n\n\tpixmp->pixelformat = fmt->pixfmt;\n\tpixmp->width = fmt->width;\n\tpixmp->height = fmt->height;\n\tpixmp->flags = fmt->flags;\n\tpixmp->num_planes = fmt->mem_planes;\n\tpixmp->field = fmt->field;\n\tmemset(pixmp->reserved, 0, sizeof(pixmp->reserved));\n\tfor (i = 0; i < pixmp->num_planes; i++) {\n\t\tpixmp->plane_fmt[i].bytesperline = fmt->bytesperline[i];\n\t\tpixmp->plane_fmt[i].sizeimage = vpu_get_fmt_plane_size(fmt, i);\n\t\tmemset(pixmp->plane_fmt[i].reserved, 0, sizeof(pixmp->plane_fmt[i].reserved));\n\t}\n\n\treturn 0;\n}\n\nstatic bool vpu_check_ready(struct vpu_inst *inst, u32 type)\n{\n\tif (!inst)\n\t\treturn false;\n\tif (inst->state == VPU_CODEC_STATE_DEINIT || inst->id < 0)\n\t\treturn false;\n\tif (!inst->ops->check_ready)\n\t\treturn true;\n\treturn call_vop(inst, check_ready, type);\n}\n\nint vpu_process_output_buffer(struct vpu_inst *inst)\n{\n\tstruct v4l2_m2m_buffer *buf = NULL;\n\tstruct vb2_v4l2_buffer *vbuf = NULL;\n\n\tif (!inst || !inst->fh.m2m_ctx)\n\t\treturn -EINVAL;\n\n\tif (!vpu_check_ready(inst, inst->out_format.type))\n\t\treturn -EINVAL;\n\n\tv4l2_m2m_for_each_src_buf(inst->fh.m2m_ctx, buf) {\n\t\tvbuf = &buf->vb;\n\t\tif (vpu_get_buffer_state(vbuf) == VPU_BUF_STATE_IDLE)\n\t\t\tbreak;\n\t\tvbuf = NULL;\n\t}\n\n\tif (!vbuf)\n\t\treturn -EINVAL;\n\n\tdev_dbg(inst->dev, \"[%d]frame id = %d / %d\\n\",\n\t\tinst->id, vbuf->sequence, inst->sequence);\n\treturn call_vop(inst, process_output, &vbuf->vb2_buf);\n}\n\nint vpu_process_capture_buffer(struct vpu_inst *inst)\n{\n\tstruct v4l2_m2m_buffer *buf = NULL;\n\tstruct vb2_v4l2_buffer *vbuf = NULL;\n\n\tif (!inst || !inst->fh.m2m_ctx)\n\t\treturn -EINVAL;\n\n\tif (!vpu_check_ready(inst, inst->cap_format.type))\n\t\treturn -EINVAL;\n\n\tv4l2_m2m_for_each_dst_buf(inst->fh.m2m_ctx, buf) {\n\t\tvbuf = &buf->vb;\n\t\tif (vpu_get_buffer_state(vbuf) == VPU_BUF_STATE_IDLE)\n\t\t\tbreak;\n\t\tvbuf = NULL;\n\t}\n\tif (!vbuf)\n\t\treturn -EINVAL;\n\n\treturn call_vop(inst, process_capture, &vbuf->vb2_buf);\n}\n\nstruct vb2_v4l2_buffer *vpu_next_src_buf(struct vpu_inst *inst)\n{\n\tstruct vb2_v4l2_buffer *src_buf = NULL;\n\n\tif (!inst->fh.m2m_ctx)\n\t\treturn NULL;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(inst->fh.m2m_ctx);\n\tif (!src_buf || vpu_get_buffer_state(src_buf) == VPU_BUF_STATE_IDLE)\n\t\treturn NULL;\n\n\twhile (vpu_vb_is_codecconfig(src_buf)) {\n\t\tv4l2_m2m_src_buf_remove(inst->fh.m2m_ctx);\n\t\tvpu_set_buffer_state(src_buf, VPU_BUF_STATE_IDLE);\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\n\t\tsrc_buf = v4l2_m2m_next_src_buf(inst->fh.m2m_ctx);\n\t\tif (!src_buf || vpu_get_buffer_state(src_buf) == VPU_BUF_STATE_IDLE)\n\t\t\treturn NULL;\n\t}\n\n\treturn src_buf;\n}\n\nvoid vpu_skip_frame(struct vpu_inst *inst, int count)\n{\n\tstruct vb2_v4l2_buffer *src_buf;\n\tenum vb2_buffer_state state;\n\tint i = 0;\n\n\tif (count <= 0 || !inst->fh.m2m_ctx)\n\t\treturn;\n\n\twhile (i < count) {\n\t\tsrc_buf = v4l2_m2m_src_buf_remove(inst->fh.m2m_ctx);\n\t\tif (!src_buf || vpu_get_buffer_state(src_buf) == VPU_BUF_STATE_IDLE)\n\t\t\treturn;\n\t\tif (vpu_get_buffer_state(src_buf) == VPU_BUF_STATE_DECODED)\n\t\t\tstate = VB2_BUF_STATE_DONE;\n\t\telse\n\t\t\tstate = VB2_BUF_STATE_ERROR;\n\t\ti++;\n\t\tvpu_set_buffer_state(src_buf, VPU_BUF_STATE_IDLE);\n\t\tv4l2_m2m_buf_done(src_buf, state);\n\t}\n}\n\nstruct vb2_v4l2_buffer *vpu_find_buf_by_sequence(struct vpu_inst *inst, u32 type, u32 sequence)\n{\n\tstruct v4l2_m2m_buffer *buf = NULL;\n\tstruct vb2_v4l2_buffer *vbuf = NULL;\n\n\tif (!inst || !inst->fh.m2m_ctx)\n\t\treturn NULL;\n\n\tif (V4L2_TYPE_IS_OUTPUT(type)) {\n\t\tv4l2_m2m_for_each_src_buf(inst->fh.m2m_ctx, buf) {\n\t\t\tvbuf = &buf->vb;\n\t\t\tif (vbuf->sequence == sequence)\n\t\t\t\tbreak;\n\t\t\tvbuf = NULL;\n\t\t}\n\t} else {\n\t\tv4l2_m2m_for_each_dst_buf(inst->fh.m2m_ctx, buf) {\n\t\t\tvbuf = &buf->vb;\n\t\t\tif (vbuf->sequence == sequence)\n\t\t\t\tbreak;\n\t\t\tvbuf = NULL;\n\t\t}\n\t}\n\n\treturn vbuf;\n}\n\nstruct vb2_v4l2_buffer *vpu_find_buf_by_idx(struct vpu_inst *inst, u32 type, u32 idx)\n{\n\tstruct v4l2_m2m_buffer *buf = NULL;\n\tstruct vb2_v4l2_buffer *vbuf = NULL;\n\n\tif (!inst || !inst->fh.m2m_ctx)\n\t\treturn NULL;\n\n\tif (V4L2_TYPE_IS_OUTPUT(type)) {\n\t\tv4l2_m2m_for_each_src_buf(inst->fh.m2m_ctx, buf) {\n\t\t\tvbuf = &buf->vb;\n\t\t\tif (vbuf->vb2_buf.index == idx)\n\t\t\t\tbreak;\n\t\t\tvbuf = NULL;\n\t\t}\n\t} else {\n\t\tv4l2_m2m_for_each_dst_buf(inst->fh.m2m_ctx, buf) {\n\t\t\tvbuf = &buf->vb;\n\t\t\tif (vbuf->vb2_buf.index == idx)\n\t\t\t\tbreak;\n\t\t\tvbuf = NULL;\n\t\t}\n\t}\n\n\treturn vbuf;\n}\n\nint vpu_get_num_buffers(struct vpu_inst *inst, u32 type)\n{\n\tstruct vb2_queue *q;\n\n\tif (!inst || !inst->fh.m2m_ctx)\n\t\treturn -EINVAL;\n\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\tq = v4l2_m2m_get_src_vq(inst->fh.m2m_ctx);\n\telse\n\t\tq = v4l2_m2m_get_dst_vq(inst->fh.m2m_ctx);\n\n\treturn q->num_buffers;\n}\n\nstatic void vpu_m2m_device_run(void *priv)\n{\n}\n\nstatic void vpu_m2m_job_abort(void *priv)\n{\n\tstruct vpu_inst *inst = priv;\n\tstruct v4l2_m2m_ctx *m2m_ctx = inst->fh.m2m_ctx;\n\n\tv4l2_m2m_job_finish(m2m_ctx->m2m_dev, m2m_ctx);\n}\n\nstatic const struct v4l2_m2m_ops vpu_m2m_ops = {\n\t.device_run = vpu_m2m_device_run,\n\t.job_abort = vpu_m2m_job_abort\n};\n\nstatic int vpu_vb2_queue_setup(struct vb2_queue *vq,\n\t\t\t       unsigned int *buf_count,\n\t\t\t       unsigned int *plane_count,\n\t\t\t       unsigned int psize[],\n\t\t\t       struct device *allocators[])\n{\n\tstruct vpu_inst *inst = vb2_get_drv_priv(vq);\n\tstruct vpu_format *cur_fmt;\n\tint i;\n\n\tcur_fmt = vpu_get_format(inst, vq->type);\n\n\tif (*plane_count) {\n\t\tif (*plane_count != cur_fmt->mem_planes)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < cur_fmt->mem_planes; i++) {\n\t\t\tif (psize[i] < vpu_get_fmt_plane_size(cur_fmt, i))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\t*buf_count = max_t(unsigned int, *buf_count, inst->min_buffer_out);\n\telse\n\t\t*buf_count = max_t(unsigned int, *buf_count, inst->min_buffer_cap);\n\t*plane_count = cur_fmt->mem_planes;\n\tfor (i = 0; i < cur_fmt->mem_planes; i++)\n\t\tpsize[i] = vpu_get_fmt_plane_size(cur_fmt, i);\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type) && inst->state == VPU_CODEC_STATE_SEEK) {\n\t\tvpu_trace(inst->dev, \"reinit when VIDIOC_REQBUFS(OUTPUT, 0)\\n\");\n\t\tcall_void_vop(inst, release);\n\t}\n\n\treturn 0;\n}\n\nstatic int vpu_vb2_buf_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvpu_set_buffer_state(vbuf, VPU_BUF_STATE_IDLE);\n\treturn 0;\n}\n\nstatic int vpu_vb2_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int vpu_vb2_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vpu_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vpu_format *cur_fmt;\n\tu32 i;\n\n\tcur_fmt = vpu_get_format(inst, vb->type);\n\tfor (i = 0; i < cur_fmt->mem_planes; i++) {\n\t\tif (vpu_get_vb_length(vb, i) < vpu_get_fmt_plane_size(cur_fmt, i)) {\n\t\t\tdev_dbg(inst->dev, \"[%d] %s buf[%d] is invalid\\n\",\n\t\t\t\tinst->id, vpu_type_name(vb->type), vb->index);\n\t\t\tvpu_set_buffer_state(vbuf, VPU_BUF_STATE_ERROR);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void vpu_vb2_buf_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vpu_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_queue *q = vb->vb2_queue;\n\n\tif (vbuf->flags & V4L2_BUF_FLAG_LAST)\n\t\tvpu_notify_eos(inst);\n\n\tif (list_empty(&q->done_list))\n\t\tcall_void_vop(inst, on_queue_empty, q->type);\n}\n\nvoid vpu_vb2_buffers_return(struct vpu_inst *inst, unsigned int type, enum vb2_buffer_state state)\n{\n\tstruct vb2_v4l2_buffer *buf;\n\n\tif (V4L2_TYPE_IS_OUTPUT(type)) {\n\t\twhile ((buf = v4l2_m2m_src_buf_remove(inst->fh.m2m_ctx))) {\n\t\t\tvpu_set_buffer_state(buf, VPU_BUF_STATE_IDLE);\n\t\t\tv4l2_m2m_buf_done(buf, state);\n\t\t}\n\t} else {\n\t\twhile ((buf = v4l2_m2m_dst_buf_remove(inst->fh.m2m_ctx))) {\n\t\t\tvpu_set_buffer_state(buf, VPU_BUF_STATE_IDLE);\n\t\t\tv4l2_m2m_buf_done(buf, state);\n\t\t}\n\t}\n}\n\nstatic int vpu_vb2_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct vpu_inst *inst = vb2_get_drv_priv(q);\n\tstruct vpu_format *fmt = vpu_get_format(inst, q->type);\n\tint ret;\n\n\tvpu_inst_unlock(inst);\n\tret = vpu_inst_register(inst);\n\tvpu_inst_lock(inst);\n\tif (ret) {\n\t\tvpu_vb2_buffers_return(inst, q->type, VB2_BUF_STATE_QUEUED);\n\t\treturn ret;\n\t}\n\n\tvpu_trace(inst->dev, \"[%d] %s %c%c%c%c %dx%d %u(%u) %u(%u) %u(%u) %d\\n\",\n\t\t  inst->id, vpu_type_name(q->type),\n\t\t  fmt->pixfmt,\n\t\t  fmt->pixfmt >> 8,\n\t\t  fmt->pixfmt >> 16,\n\t\t  fmt->pixfmt >> 24,\n\t\t  fmt->width, fmt->height,\n\t\t  fmt->sizeimage[0], fmt->bytesperline[0],\n\t\t  fmt->sizeimage[1], fmt->bytesperline[1],\n\t\t  fmt->sizeimage[2], fmt->bytesperline[2],\n\t\t  q->num_buffers);\n\tvb2_clear_last_buffer_dequeued(q);\n\tret = call_vop(inst, start, q->type);\n\tif (ret)\n\t\tvpu_vb2_buffers_return(inst, q->type, VB2_BUF_STATE_QUEUED);\n\n\treturn ret;\n}\n\nstatic void vpu_vb2_stop_streaming(struct vb2_queue *q)\n{\n\tstruct vpu_inst *inst = vb2_get_drv_priv(q);\n\n\tvpu_trace(inst->dev, \"[%d] %s\\n\", inst->id, vpu_type_name(q->type));\n\n\tcall_void_vop(inst, stop, q->type);\n\tvpu_vb2_buffers_return(inst, q->type, VB2_BUF_STATE_ERROR);\n\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\tinst->sequence = 0;\n}\n\nstatic void vpu_vb2_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vpu_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\n\tif (V4L2_TYPE_IS_OUTPUT(vb->type))\n\t\tvbuf->sequence = inst->sequence++;\n\n\tv4l2_m2m_buf_queue(inst->fh.m2m_ctx, vbuf);\n\tvpu_process_output_buffer(inst);\n\tvpu_process_capture_buffer(inst);\n}\n\nstatic const struct vb2_ops vpu_vb2_ops = {\n\t.queue_setup        = vpu_vb2_queue_setup,\n\t.buf_init           = vpu_vb2_buf_init,\n\t.buf_out_validate   = vpu_vb2_buf_out_validate,\n\t.buf_prepare        = vpu_vb2_buf_prepare,\n\t.buf_finish         = vpu_vb2_buf_finish,\n\t.start_streaming    = vpu_vb2_start_streaming,\n\t.stop_streaming     = vpu_vb2_stop_streaming,\n\t.buf_queue          = vpu_vb2_buf_queue,\n\t.wait_prepare       = vb2_ops_wait_prepare,\n\t.wait_finish        = vb2_ops_wait_finish,\n};\n\nstatic int vpu_m2m_queue_init(void *priv, struct vb2_queue *src_vq, struct vb2_queue *dst_vq)\n{\n\tstruct vpu_inst *inst = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tinst->out_format.type = src_vq->type;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->ops = &vpu_vb2_ops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tif (inst->type == VPU_CORE_TYPE_DEC && inst->use_stream_buffer)\n\t\tsrc_vq->mem_ops = &vb2_vmalloc_memops;\n\tsrc_vq->drv_priv = inst;\n\tsrc_vq->buf_struct_size = sizeof(struct vpu_vb2_buffer);\n\tsrc_vq->min_buffers_needed = 1;\n\tsrc_vq->dev = inst->vpu->dev;\n\tsrc_vq->lock = &inst->lock;\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tinst->cap_format.type = dst_vq->type;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->ops = &vpu_vb2_ops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tif (inst->type == VPU_CORE_TYPE_ENC && inst->use_stream_buffer)\n\t\tdst_vq->mem_ops = &vb2_vmalloc_memops;\n\tdst_vq->drv_priv = inst;\n\tdst_vq->buf_struct_size = sizeof(struct vpu_vb2_buffer);\n\tdst_vq->min_buffers_needed = 1;\n\tdst_vq->dev = inst->vpu->dev;\n\tdst_vq->lock = &inst->lock;\n\tret = vb2_queue_init(dst_vq);\n\tif (ret) {\n\t\tvb2_queue_release(src_vq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vpu_v4l2_release(struct vpu_inst *inst)\n{\n\tvpu_trace(inst->vpu->dev, \"%p\\n\", inst);\n\n\tvpu_release_core(inst->core);\n\tput_device(inst->dev);\n\n\tif (inst->workqueue) {\n\t\tcancel_work_sync(&inst->msg_work);\n\t\tdestroy_workqueue(inst->workqueue);\n\t\tinst->workqueue = NULL;\n\t}\n\n\tv4l2_ctrl_handler_free(&inst->ctrl_handler);\n\tmutex_destroy(&inst->lock);\n\tv4l2_fh_del(&inst->fh);\n\tv4l2_fh_exit(&inst->fh);\n\n\tcall_void_vop(inst, cleanup);\n\n\treturn 0;\n}\n\nint vpu_v4l2_open(struct file *file, struct vpu_inst *inst)\n{\n\tstruct vpu_dev *vpu = video_drvdata(file);\n\tstruct vpu_func *func;\n\tint ret = 0;\n\n\tif (!inst || !inst->ops)\n\t\treturn -EINVAL;\n\n\tif (inst->type == VPU_CORE_TYPE_ENC)\n\t\tfunc = &vpu->encoder;\n\telse\n\t\tfunc = &vpu->decoder;\n\n\tatomic_set(&inst->ref_count, 0);\n\tvpu_inst_get(inst);\n\tinst->vpu = vpu;\n\tinst->core = vpu_request_core(vpu, inst->type);\n\tif (inst->core)\n\t\tinst->dev = get_device(inst->core->dev);\n\tmutex_init(&inst->lock);\n\tINIT_LIST_HEAD(&inst->cmd_q);\n\tinst->id = VPU_INST_NULL_ID;\n\tinst->release = vpu_v4l2_release;\n\tinst->pid = current->pid;\n\tinst->tgid = current->tgid;\n\tinst->min_buffer_cap = 2;\n\tinst->min_buffer_out = 2;\n\tv4l2_fh_init(&inst->fh, func->vfd);\n\tv4l2_fh_add(&inst->fh);\n\n\tret = call_vop(inst, ctrl_init);\n\tif (ret)\n\t\tgoto error;\n\n\tinst->fh.m2m_ctx = v4l2_m2m_ctx_init(func->m2m_dev, inst, vpu_m2m_queue_init);\n\tif (IS_ERR(inst->fh.m2m_ctx)) {\n\t\tdev_err(vpu->dev, \"v4l2_m2m_ctx_init fail\\n\");\n\t\tret = PTR_ERR(inst->fh.m2m_ctx);\n\t\tgoto error;\n\t}\n\n\tinst->fh.ctrl_handler = &inst->ctrl_handler;\n\tfile->private_data = &inst->fh;\n\tinst->state = VPU_CODEC_STATE_DEINIT;\n\tinst->workqueue = alloc_ordered_workqueue(\"vpu_inst\", WQ_MEM_RECLAIM);\n\tif (inst->workqueue) {\n\t\tINIT_WORK(&inst->msg_work, vpu_inst_run_work);\n\t\tret = kfifo_init(&inst->msg_fifo,\n\t\t\t\t inst->msg_buffer,\n\t\t\t\t rounddown_pow_of_two(sizeof(inst->msg_buffer)));\n\t\tif (ret) {\n\t\t\tdestroy_workqueue(inst->workqueue);\n\t\t\tinst->workqueue = NULL;\n\t\t}\n\t}\n\tvpu_trace(vpu->dev, \"tgid = %d, pid = %d, type = %s, inst = %p\\n\",\n\t\t  inst->tgid, inst->pid, vpu_core_type_desc(inst->type), inst);\n\n\treturn 0;\nerror:\n\tvpu_inst_put(inst);\n\treturn ret;\n}\n\nint vpu_v4l2_close(struct file *file)\n{\n\tstruct vpu_dev *vpu = video_drvdata(file);\n\tstruct vpu_inst *inst = to_inst(file);\n\n\tvpu_trace(vpu->dev, \"tgid = %d, pid = %d, inst = %p\\n\", inst->tgid, inst->pid, inst);\n\n\tvpu_inst_lock(inst);\n\tif (inst->fh.m2m_ctx) {\n\t\tv4l2_m2m_ctx_release(inst->fh.m2m_ctx);\n\t\tinst->fh.m2m_ctx = NULL;\n\t}\n\tcall_void_vop(inst, release);\n\tvpu_inst_unlock(inst);\n\n\tvpu_inst_unregister(inst);\n\tvpu_inst_put(inst);\n\n\treturn 0;\n}\n\nint vpu_add_func(struct vpu_dev *vpu, struct vpu_func *func)\n{\n\tstruct video_device *vfd;\n\tint ret;\n\n\tif (!vpu || !func)\n\t\treturn -EINVAL;\n\n\tif (func->vfd)\n\t\treturn 0;\n\n\tfunc->m2m_dev = v4l2_m2m_init(&vpu_m2m_ops);\n\tif (IS_ERR(func->m2m_dev)) {\n\t\tdev_err(vpu->dev, \"v4l2_m2m_init fail\\n\");\n\t\tfunc->vfd = NULL;\n\t\treturn PTR_ERR(func->m2m_dev);\n\t}\n\n\tvfd = video_device_alloc();\n\tif (!vfd) {\n\t\tv4l2_m2m_release(func->m2m_dev);\n\t\tdev_err(vpu->dev, \"alloc vpu decoder video device fail\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tvfd->release = video_device_release;\n\tvfd->vfl_dir = VFL_DIR_M2M;\n\tvfd->v4l2_dev = &vpu->v4l2_dev;\n\tvfd->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;\n\tif (func->type == VPU_CORE_TYPE_ENC) {\n\t\tstrscpy(vfd->name, \"amphion-vpu-encoder\", sizeof(vfd->name));\n\t\tvfd->fops = venc_get_fops();\n\t\tvfd->ioctl_ops = venc_get_ioctl_ops();\n\t} else {\n\t\tstrscpy(vfd->name, \"amphion-vpu-decoder\", sizeof(vfd->name));\n\t\tvfd->fops = vdec_get_fops();\n\t\tvfd->ioctl_ops = vdec_get_ioctl_ops();\n\t}\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tvideo_device_release(vfd);\n\t\tv4l2_m2m_release(func->m2m_dev);\n\t\treturn ret;\n\t}\n\tvideo_set_drvdata(vfd, vpu);\n\tfunc->vfd = vfd;\n\n\tret = v4l2_m2m_register_media_controller(func->m2m_dev, func->vfd, func->function);\n\tif (ret) {\n\t\tv4l2_m2m_release(func->m2m_dev);\n\t\tfunc->m2m_dev = NULL;\n\t\tvideo_unregister_device(func->vfd);\n\t\tfunc->vfd = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid vpu_remove_func(struct vpu_func *func)\n{\n\tif (!func)\n\t\treturn;\n\n\tif (func->m2m_dev) {\n\t\tv4l2_m2m_unregister_media_controller(func->m2m_dev);\n\t\tv4l2_m2m_release(func->m2m_dev);\n\t\tfunc->m2m_dev = NULL;\n\t}\n\tif (func->vfd) {\n\t\tvideo_unregister_device(func->vfd);\n\t\tfunc->vfd = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}