{
  "module_name": "venc.c",
  "hash_id": "6c305b81ac05097cc5158f30bbc2ada5cb269956b46bb20dedaf5ee36552fdfb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/amphion/venc.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interconnect.h>\n#include <linux/ioctl.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/videodev2.h>\n#include <linux/ktime.h>\n#include <linux/rational.h>\n#include <linux/vmalloc.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-vmalloc.h>\n#include \"vpu.h\"\n#include \"vpu_defs.h\"\n#include \"vpu_core.h\"\n#include \"vpu_helpers.h\"\n#include \"vpu_v4l2.h\"\n#include \"vpu_cmds.h\"\n#include \"vpu_rpc.h\"\n\n#define VENC_OUTPUT_ENABLE\tBIT(0)\n#define VENC_CAPTURE_ENABLE\tBIT(1)\n#define VENC_ENABLE_MASK\t(VENC_OUTPUT_ENABLE | VENC_CAPTURE_ENABLE)\n#define VENC_MAX_BUF_CNT\t8\n#define VENC_MIN_BUFFER_OUT\t6\n#define VENC_MIN_BUFFER_CAP\t6\n\nstruct venc_t {\n\tstruct vpu_encode_params params;\n\tu32 request_key_frame;\n\tu32 input_ready;\n\tu32 cpb_size;\n\tbool bitrate_change;\n\n\tstruct vpu_buffer enc[VENC_MAX_BUF_CNT];\n\tstruct vpu_buffer ref[VENC_MAX_BUF_CNT];\n\tstruct vpu_buffer act[VENC_MAX_BUF_CNT];\n\tstruct list_head frames;\n\tu32 frame_count;\n\tu32 encode_count;\n\tu32 ready_count;\n\tu32 enable;\n\tu32 stopped;\n\n\tu32 skipped_count;\n\tu32 skipped_bytes;\n\n\twait_queue_head_t wq;\n};\n\nstruct venc_frame_t {\n\tstruct list_head list;\n\tstruct vpu_enc_pic_info info;\n\tu32 bytesused;\n\ts64 timestamp;\n};\n\nstatic const struct vpu_format venc_formats[] = {\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_NV12M,\n\t\t.mem_planes = 2,\n\t\t.comp_planes = 2,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.sibling = V4L2_PIX_FMT_NV12,\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_NV12,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 2,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.sibling = V4L2_PIX_FMT_NV12M,\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_H264,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{0, 0, 0, 0},\n};\n\nstatic int venc_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, \"amphion-vpu\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"amphion vpu encoder\", sizeof(cap->card));\n\tstrscpy(cap->bus_info, \"platform: amphion-vpu\", sizeof(cap->bus_info));\n\n\treturn 0;\n}\n\nstatic int venc_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tconst struct vpu_format *fmt;\n\n\tmemset(f->reserved, 0, sizeof(f->reserved));\n\tfmt = vpu_helper_enum_format(inst, f->type, f->index);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = fmt->pixfmt;\n\tf->flags = fmt->flags;\n\n\treturn 0;\n}\n\nstatic int venc_enum_framesizes(struct file *file, void *fh, struct v4l2_frmsizeenum *fsize)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tconst struct vpu_core_resources *res;\n\n\tif (!fsize || fsize->index)\n\t\treturn -EINVAL;\n\n\tif (!vpu_helper_find_format(inst, 0, fsize->pixel_format))\n\t\treturn -EINVAL;\n\n\tres = vpu_get_resource(inst);\n\tif (!res)\n\t\treturn -EINVAL;\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise.max_width = res->max_width;\n\tfsize->stepwise.max_height = res->max_height;\n\tfsize->stepwise.min_width = res->min_width;\n\tfsize->stepwise.min_height = res->min_height;\n\tfsize->stepwise.step_width = res->step_width;\n\tfsize->stepwise.step_height = res->step_height;\n\n\treturn 0;\n}\n\nstatic int venc_enum_frameintervals(struct file *file, void *fh, struct v4l2_frmivalenum *fival)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tconst struct vpu_core_resources *res;\n\n\tif (!fival || fival->index)\n\t\treturn -EINVAL;\n\n\tif (!vpu_helper_find_format(inst, 0, fival->pixel_format))\n\t\treturn -EINVAL;\n\n\tif (!fival->width || !fival->height)\n\t\treturn -EINVAL;\n\n\tres = vpu_get_resource(inst);\n\tif (!res)\n\t\treturn -EINVAL;\n\tif (fival->width < res->min_width || fival->width > res->max_width ||\n\t    fival->height < res->min_height || fival->height > res->max_height)\n\t\treturn -EINVAL;\n\n\tfival->type = V4L2_FRMIVAL_TYPE_CONTINUOUS;\n\tfival->stepwise.min.numerator = 1;\n\tfival->stepwise.min.denominator = USHRT_MAX;\n\tfival->stepwise.max.numerator = USHRT_MAX;\n\tfival->stepwise.max.denominator = 1;\n\tfival->stepwise.step.numerator = 1;\n\tfival->stepwise.step.denominator = 1;\n\n\treturn 0;\n}\n\nstatic int venc_g_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tstruct venc_t *venc = inst->priv;\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tstruct vpu_format *cur_fmt;\n\tint i;\n\n\tcur_fmt = vpu_get_format(inst, f->type);\n\n\tpixmp->pixelformat = cur_fmt->pixfmt;\n\tpixmp->num_planes = cur_fmt->mem_planes;\n\tpixmp->width = cur_fmt->width;\n\tpixmp->height = cur_fmt->height;\n\tpixmp->field = cur_fmt->field;\n\tpixmp->flags = cur_fmt->flags;\n\tfor (i = 0; i < pixmp->num_planes; i++) {\n\t\tpixmp->plane_fmt[i].bytesperline = cur_fmt->bytesperline[i];\n\t\tpixmp->plane_fmt[i].sizeimage = vpu_get_fmt_plane_size(cur_fmt, i);\n\t}\n\n\tf->fmt.pix_mp.colorspace = venc->params.color.primaries;\n\tf->fmt.pix_mp.xfer_func = venc->params.color.transfer;\n\tf->fmt.pix_mp.ycbcr_enc = venc->params.color.matrix;\n\tf->fmt.pix_mp.quantization = venc->params.color.full_range;\n\n\treturn 0;\n}\n\nstatic int venc_try_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tstruct vpu_format fmt;\n\n\tvpu_try_fmt_common(inst, f, &fmt);\n\n\treturn 0;\n}\n\nstatic int venc_s_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tstruct vpu_format fmt;\n\tstruct vpu_format *cur_fmt;\n\tstruct vb2_queue *q;\n\tstruct venc_t *venc = inst->priv;\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\n\tq = v4l2_m2m_get_vq(inst->fh.m2m_ctx, f->type);\n\tif (!q)\n\t\treturn -EINVAL;\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\tif (vpu_try_fmt_common(inst, f, &fmt))\n\t\treturn -EINVAL;\n\n\tcur_fmt = vpu_get_format(inst, f->type);\n\n\tmemcpy(cur_fmt, &fmt, sizeof(*cur_fmt));\n\n\tif (V4L2_TYPE_IS_OUTPUT(f->type)) {\n\t\tvenc->params.input_format = cur_fmt->pixfmt;\n\t\tvenc->params.src_stride = cur_fmt->bytesperline[0];\n\t\tvenc->params.src_width = cur_fmt->width;\n\t\tvenc->params.src_height = cur_fmt->height;\n\t\tvenc->params.crop.left = 0;\n\t\tvenc->params.crop.top = 0;\n\t\tvenc->params.crop.width = cur_fmt->width;\n\t\tvenc->params.crop.height = cur_fmt->height;\n\t} else {\n\t\tvenc->params.codec_format = cur_fmt->pixfmt;\n\t\tvenc->params.out_width = cur_fmt->width;\n\t\tvenc->params.out_height = cur_fmt->height;\n\t}\n\n\tif (V4L2_TYPE_IS_OUTPUT(f->type)) {\n\t\tvenc->params.color.primaries = pix_mp->colorspace;\n\t\tvenc->params.color.transfer = pix_mp->xfer_func;\n\t\tvenc->params.color.matrix = pix_mp->ycbcr_enc;\n\t\tvenc->params.color.full_range = pix_mp->quantization;\n\t}\n\n\tpix_mp->colorspace = venc->params.color.primaries;\n\tpix_mp->xfer_func = venc->params.color.transfer;\n\tpix_mp->ycbcr_enc = venc->params.color.matrix;\n\tpix_mp->quantization = venc->params.color.full_range;\n\n\treturn 0;\n}\n\nstatic int venc_g_parm(struct file *file, void *fh, struct v4l2_streamparm *parm)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tstruct venc_t *venc = inst->priv;\n\tstruct v4l2_fract *timeperframe;\n\n\tif (!parm)\n\t\treturn -EINVAL;\n\n\tif (!V4L2_TYPE_IS_OUTPUT(parm->type))\n\t\treturn -EINVAL;\n\n\tif (!vpu_helper_check_type(inst, parm->type))\n\t\treturn -EINVAL;\n\n\ttimeperframe = &parm->parm.capture.timeperframe;\n\tparm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\tparm->parm.capture.readbuffers = 0;\n\ttimeperframe->numerator = venc->params.frame_rate.numerator;\n\ttimeperframe->denominator = venc->params.frame_rate.denominator;\n\n\treturn 0;\n}\n\nstatic int venc_s_parm(struct file *file, void *fh, struct v4l2_streamparm *parm)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tstruct venc_t *venc = inst->priv;\n\tstruct v4l2_fract *timeperframe;\n\tunsigned long n, d;\n\n\tif (!parm)\n\t\treturn -EINVAL;\n\n\tif (!V4L2_TYPE_IS_OUTPUT(parm->type))\n\t\treturn -EINVAL;\n\n\tif (!vpu_helper_check_type(inst, parm->type))\n\t\treturn -EINVAL;\n\n\ttimeperframe = &parm->parm.capture.timeperframe;\n\tif (!timeperframe->numerator)\n\t\ttimeperframe->numerator = venc->params.frame_rate.numerator;\n\tif (!timeperframe->denominator)\n\t\ttimeperframe->denominator = venc->params.frame_rate.denominator;\n\n\tvenc->params.frame_rate.numerator = timeperframe->numerator;\n\tvenc->params.frame_rate.denominator = timeperframe->denominator;\n\n\trational_best_approximation(venc->params.frame_rate.numerator,\n\t\t\t\t    venc->params.frame_rate.denominator,\n\t\t\t\t    venc->params.frame_rate.numerator,\n\t\t\t\t    venc->params.frame_rate.denominator,\n\t\t\t\t    &n, &d);\n\tvenc->params.frame_rate.numerator = n;\n\tvenc->params.frame_rate.denominator = d;\n\n\tparm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\tmemset(parm->parm.capture.reserved, 0, sizeof(parm->parm.capture.reserved));\n\n\treturn 0;\n}\n\nstatic int venc_g_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tstruct venc_t *venc = inst->priv;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT && s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = inst->out_format.width;\n\t\ts->r.height = inst->out_format.height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\ts->r = venc->params.crop;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int venc_valid_crop(struct venc_t *venc, const struct vpu_core_resources *res)\n{\n\tstruct v4l2_rect *rect = NULL;\n\tu32 min_width;\n\tu32 min_height;\n\tu32 src_width;\n\tu32 src_height;\n\n\trect = &venc->params.crop;\n\tmin_width = res->min_width;\n\tmin_height = res->min_height;\n\tsrc_width = venc->params.src_width;\n\tsrc_height = venc->params.src_height;\n\n\tif (rect->width == 0 || rect->height == 0)\n\t\treturn -EINVAL;\n\tif (rect->left > src_width - min_width || rect->top > src_height - min_height)\n\t\treturn -EINVAL;\n\n\trect->width = min(rect->width, src_width - rect->left);\n\trect->width = max_t(u32, rect->width, min_width);\n\n\trect->height = min(rect->height, src_height - rect->top);\n\trect->height = max_t(u32, rect->height, min_height);\n\n\treturn 0;\n}\n\nstatic int venc_s_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tconst struct vpu_core_resources *res;\n\tstruct venc_t *venc = inst->priv;\n\n\tres = vpu_get_resource(inst);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT && s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn -EINVAL;\n\tif (s->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tvenc->params.crop.left = ALIGN(s->r.left, res->step_width);\n\tvenc->params.crop.top = ALIGN(s->r.top, res->step_height);\n\tvenc->params.crop.width = ALIGN(s->r.width, res->step_width);\n\tvenc->params.crop.height = ALIGN(s->r.height, res->step_height);\n\tif (venc_valid_crop(venc, res)) {\n\t\tvenc->params.crop.left = 0;\n\t\tvenc->params.crop.top = 0;\n\t\tvenc->params.crop.width = venc->params.src_width;\n\t\tvenc->params.crop.height = venc->params.src_height;\n\t}\n\n\tinst->crop = venc->params.crop;\n\n\treturn 0;\n}\n\nstatic int venc_drain(struct vpu_inst *inst)\n{\n\tstruct venc_t *venc = inst->priv;\n\tint ret;\n\n\tif (!inst->fh.m2m_ctx)\n\t\treturn 0;\n\n\tif (inst->state != VPU_CODEC_STATE_DRAIN)\n\t\treturn 0;\n\n\tif (!vpu_is_source_empty(inst))\n\t\treturn 0;\n\n\tif (!venc->input_ready)\n\t\treturn 0;\n\n\tvenc->input_ready = false;\n\tvpu_trace(inst->dev, \"[%d]\\n\", inst->id);\n\tret = vpu_session_stop(inst);\n\tif (ret)\n\t\treturn ret;\n\tinst->state = VPU_CODEC_STATE_STOP;\n\twake_up_all(&venc->wq);\n\n\treturn 0;\n}\n\nstatic int venc_request_eos(struct vpu_inst *inst)\n{\n\tinst->state = VPU_CODEC_STATE_DRAIN;\n\tvenc_drain(inst);\n\n\treturn 0;\n}\n\nstatic int venc_encoder_cmd(struct file *file, void *fh, struct v4l2_encoder_cmd *cmd)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tint ret;\n\n\tret = v4l2_m2m_ioctl_try_encoder_cmd(file, fh, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tvpu_inst_lock(inst);\n\tif (cmd->cmd == V4L2_ENC_CMD_STOP) {\n\t\tif (inst->state == VPU_CODEC_STATE_DEINIT)\n\t\t\tvpu_set_last_buffer_dequeued(inst, true);\n\t\telse\n\t\t\tvenc_request_eos(inst);\n\t}\n\tvpu_inst_unlock(inst);\n\n\treturn 0;\n}\n\nstatic int venc_subscribe_event(struct v4l2_fh *fh, const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_EOS:\n\t\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_ioctl_ops venc_ioctl_ops = {\n\t.vidioc_querycap               = venc_querycap,\n\t.vidioc_enum_fmt_vid_cap       = venc_enum_fmt,\n\t.vidioc_enum_fmt_vid_out       = venc_enum_fmt,\n\t.vidioc_enum_framesizes        = venc_enum_framesizes,\n\t.vidioc_enum_frameintervals    = venc_enum_frameintervals,\n\t.vidioc_g_fmt_vid_cap_mplane   = venc_g_fmt,\n\t.vidioc_g_fmt_vid_out_mplane   = venc_g_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane = venc_try_fmt,\n\t.vidioc_try_fmt_vid_out_mplane = venc_try_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane   = venc_s_fmt,\n\t.vidioc_s_fmt_vid_out_mplane   = venc_s_fmt,\n\t.vidioc_g_parm                 = venc_g_parm,\n\t.vidioc_s_parm                 = venc_s_parm,\n\t.vidioc_g_selection            = venc_g_selection,\n\t.vidioc_s_selection            = venc_s_selection,\n\t.vidioc_try_encoder_cmd        = v4l2_m2m_ioctl_try_encoder_cmd,\n\t.vidioc_encoder_cmd            = venc_encoder_cmd,\n\t.vidioc_subscribe_event        = venc_subscribe_event,\n\t.vidioc_unsubscribe_event      = v4l2_event_unsubscribe,\n\t.vidioc_reqbufs                = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf               = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_create_bufs\t       = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t       = v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_qbuf                   = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_expbuf                 = v4l2_m2m_ioctl_expbuf,\n\t.vidioc_dqbuf                  = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_streamon               = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff              = v4l2_m2m_ioctl_streamoff,\n};\n\nstatic int venc_op_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vpu_inst *inst = ctrl_to_inst(ctrl);\n\tstruct venc_t *venc = inst->priv;\n\tint ret = 0;\n\n\tvpu_inst_lock(inst);\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MPEG_VIDEO_H264_PROFILE:\n\t\tvenc->params.profile = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_LEVEL:\n\t\tvenc->params.level = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:\n\t\tvenc->params.rc_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\n\t\tvenc->params.rc_mode = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE:\n\t\tif (ctrl->val != venc->params.bitrate)\n\t\t\tvenc->bitrate_change = true;\n\t\tvenc->params.bitrate = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:\n\t\tvenc->params.bitrate_max = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\n\t\tvenc->params.gop_length = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_B_FRAMES:\n\t\tvenc->params.bframes = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP:\n\t\tvenc->params.i_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP:\n\t\tvenc->params.p_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP:\n\t\tvenc->params.b_frame_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME:\n\t\tvenc->request_key_frame = 1;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE:\n\t\tvenc->cpb_size = ctrl->val * 1024;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE:\n\t\tvenc->params.sar.enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:\n\t\tvenc->params.sar.idc = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH:\n\t\tvenc->params.sar.width = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT:\n\t\tvenc->params.sar.height = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEADER_MODE:\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tvpu_inst_unlock(inst);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops venc_ctrl_ops = {\n\t.s_ctrl = venc_op_s_ctrl,\n\t.g_volatile_ctrl = vpu_helper_g_volatile_ctrl,\n};\n\nstatic int venc_ctrl_init(struct vpu_inst *inst)\n{\n\tstruct v4l2_ctrl *ctrl;\n\tint ret;\n\n\tret = v4l2_ctrl_handler_init(&inst->ctrl_handler, 20);\n\tif (ret)\n\t\treturn ret;\n\n\tv4l2_ctrl_new_std_menu(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_H264_PROFILE,\n\t\t\t       V4L2_MPEG_VIDEO_H264_PROFILE_HIGH,\n\t\t\t       ~((1 << V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE) |\n\t\t\t\t (1 << V4L2_MPEG_VIDEO_H264_PROFILE_MAIN) |\n\t\t\t\t (1 << V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)),\n\t\t\t       V4L2_MPEG_VIDEO_H264_PROFILE_HIGH);\n\n\tv4l2_ctrl_new_std_menu(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_H264_LEVEL,\n\t\t\t       V4L2_MPEG_VIDEO_H264_LEVEL_5_1,\n\t\t\t       0x0,\n\t\t\t       V4L2_MPEG_VIDEO_H264_LEVEL_4_0);\n\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE, 0, 1, 1, 1);\n\n\tv4l2_ctrl_new_std_menu(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_BITRATE_MODE,\n\t\t\t       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR,\n\t\t\t       ~((1 << V4L2_MPEG_VIDEO_BITRATE_MODE_VBR) |\n\t\t\t\t (1 << V4L2_MPEG_VIDEO_BITRATE_MODE_CBR)),\n\t\t\t       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR);\n\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_BITRATE,\n\t\t\t  BITRATE_MIN,\n\t\t\t  BITRATE_MAX,\n\t\t\t  BITRATE_STEP,\n\t\t\t  BITRATE_DEFAULT);\n\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_BITRATE_PEAK,\n\t\t\t  BITRATE_MIN, BITRATE_MAX,\n\t\t\t  BITRATE_STEP,\n\t\t\t  BITRATE_DEFAULT_PEAK);\n\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_GOP_SIZE, 1, 8000, 1, 30);\n\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_B_FRAMES, 0, 4, 1, 0);\n\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP, 1, 51, 1, 26);\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP, 1, 51, 1, 28);\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP, 1, 51, 1, 30);\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME, 0, 0, 0, 0);\n\tctrl = v4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t\t V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 2);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\tctrl = v4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t\t V4L2_CID_MIN_BUFFERS_FOR_OUTPUT, 1, 32, 1, 2);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE, 64, 10240, 1, 1024);\n\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE, 0, 1, 1, 1);\n\tv4l2_ctrl_new_std_menu(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC,\n\t\t\t       V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_EXTENDED,\n\t\t\t       0x0,\n\t\t\t       V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1);\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH,\n\t\t\t  0, USHRT_MAX, 1, 1);\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT,\n\t\t\t  0, USHRT_MAX, 1, 1);\n\tv4l2_ctrl_new_std_menu(&inst->ctrl_handler, &venc_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_HEADER_MODE,\n\t\t\t       V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME,\n\t\t\t       ~(1 << V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME),\n\t\t\t       V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME);\n\n\tif (inst->ctrl_handler.error) {\n\t\tret = inst->ctrl_handler.error;\n\t\tv4l2_ctrl_handler_free(&inst->ctrl_handler);\n\t\treturn ret;\n\t}\n\n\tret = v4l2_ctrl_handler_setup(&inst->ctrl_handler);\n\tif (ret) {\n\t\tdev_err(inst->dev, \"[%d] setup ctrls fail, ret = %d\\n\", inst->id, ret);\n\t\tv4l2_ctrl_handler_free(&inst->ctrl_handler);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool venc_check_ready(struct vpu_inst *inst, unsigned int type)\n{\n\tstruct venc_t *venc = inst->priv;\n\n\tif (V4L2_TYPE_IS_OUTPUT(type)) {\n\t\tif (vpu_helper_get_free_space(inst) < venc->cpb_size)\n\t\t\treturn false;\n\t\treturn venc->input_ready;\n\t}\n\n\tif (list_empty(&venc->frames))\n\t\treturn false;\n\treturn true;\n}\n\nstatic u32 venc_get_enable_mask(u32 type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn VENC_OUTPUT_ENABLE;\n\telse\n\t\treturn VENC_CAPTURE_ENABLE;\n}\n\nstatic void venc_set_enable(struct venc_t *venc, u32 type, int enable)\n{\n\tu32 mask = venc_get_enable_mask(type);\n\n\tif (enable)\n\t\tvenc->enable |= mask;\n\telse\n\t\tvenc->enable &= ~mask;\n}\n\nstatic u32 venc_get_enable(struct venc_t *venc, u32 type)\n{\n\treturn venc->enable & venc_get_enable_mask(type);\n}\n\nstatic void venc_input_done(struct vpu_inst *inst)\n{\n\tstruct venc_t *venc = inst->priv;\n\n\tvpu_inst_lock(inst);\n\tvenc->input_ready = true;\n\tvpu_process_output_buffer(inst);\n\tif (inst->state == VPU_CODEC_STATE_DRAIN)\n\t\tvenc_drain(inst);\n\tvpu_inst_unlock(inst);\n}\n\n \nstatic int venc_precheck_encoded_frame(struct vpu_inst *inst, struct venc_frame_t *frame)\n{\n\tstruct venc_t *venc;\n\tint skipped;\n\n\tif (!frame || !frame->bytesused)\n\t\treturn -EINVAL;\n\n\tvenc = inst->priv;\n\tskipped = vpu_helper_find_startcode(&inst->stream_buffer,\n\t\t\t\t\t    inst->cap_format.pixfmt,\n\t\t\t\t\t    frame->info.wptr - inst->stream_buffer.phys,\n\t\t\t\t\t    frame->bytesused);\n\tif (skipped > 0) {\n\t\tframe->bytesused -= skipped;\n\t\tframe->info.wptr = vpu_helper_step_walk(&inst->stream_buffer,\n\t\t\t\t\t\t\tframe->info.wptr, skipped);\n\t\tvenc->skipped_bytes += skipped;\n\t\tvenc->skipped_count++;\n\t}\n\n\treturn 0;\n}\n\nstatic int venc_get_one_encoded_frame(struct vpu_inst *inst,\n\t\t\t\t      struct venc_frame_t *frame,\n\t\t\t\t      struct vb2_v4l2_buffer *vbuf)\n{\n\tstruct venc_t *venc = inst->priv;\n\tstruct vb2_v4l2_buffer *src_buf;\n\n\tif (!vbuf)\n\t\treturn -EAGAIN;\n\n\tsrc_buf = vpu_find_buf_by_sequence(inst, inst->out_format.type, frame->info.frame_id);\n\tif (src_buf) {\n\t\tv4l2_m2m_buf_copy_metadata(src_buf, vbuf, true);\n\t\tvpu_set_buffer_state(src_buf, VPU_BUF_STATE_IDLE);\n\t\tv4l2_m2m_src_buf_remove_by_buf(inst->fh.m2m_ctx, src_buf);\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\t} else {\n\t\tvbuf->vb2_buf.timestamp = frame->info.timestamp;\n\t}\n\tif (!venc_get_enable(inst->priv, vbuf->vb2_buf.type)) {\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t\treturn 0;\n\t}\n\tif (frame->bytesused > vbuf->vb2_buf.planes[0].length) {\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t\treturn -ENOMEM;\n\t}\n\n\tvenc_precheck_encoded_frame(inst, frame);\n\n\tif (frame->bytesused) {\n\t\tu32 rptr = frame->info.wptr;\n\t\tvoid *dst = vb2_plane_vaddr(&vbuf->vb2_buf, 0);\n\n\t\tvpu_helper_copy_from_stream_buffer(&inst->stream_buffer,\n\t\t\t\t\t\t   &rptr, frame->bytesused, dst);\n\t\tvpu_iface_update_stream_buffer(inst, rptr, 0);\n\t}\n\tvb2_set_plane_payload(&vbuf->vb2_buf, 0, frame->bytesused);\n\tvbuf->sequence = frame->info.frame_id;\n\tvbuf->field = inst->cap_format.field;\n\tvbuf->flags |= frame->info.pic_type;\n\tvpu_set_buffer_state(vbuf, VPU_BUF_STATE_IDLE);\n\tdev_dbg(inst->dev, \"[%d][OUTPUT TS]%32lld\\n\", inst->id, vbuf->vb2_buf.timestamp);\n\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);\n\tvenc->ready_count++;\n\n\tif (vbuf->flags & V4L2_BUF_FLAG_KEYFRAME)\n\t\tdev_dbg(inst->dev, \"[%d][%d]key frame\\n\", inst->id, frame->info.frame_id);\n\n\treturn 0;\n}\n\nstatic int venc_get_encoded_frames(struct vpu_inst *inst)\n{\n\tstruct venc_t *venc;\n\tstruct venc_frame_t *frame;\n\tstruct venc_frame_t *tmp;\n\n\tif (!inst->fh.m2m_ctx)\n\t\treturn 0;\n\tvenc = inst->priv;\n\tlist_for_each_entry_safe(frame, tmp, &venc->frames, list) {\n\t\tif (venc_get_one_encoded_frame(inst, frame,\n\t\t\t\t\t       v4l2_m2m_dst_buf_remove(inst->fh.m2m_ctx)))\n\t\t\tbreak;\n\t\tlist_del_init(&frame->list);\n\t\tvfree(frame);\n\t}\n\n\treturn 0;\n}\n\nstatic int venc_frame_encoded(struct vpu_inst *inst, void *arg)\n{\n\tstruct vpu_enc_pic_info *info = arg;\n\tstruct venc_frame_t *frame;\n\tstruct venc_t *venc;\n\tint ret = 0;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\tvenc = inst->priv;\n\tframe = vzalloc(sizeof(*frame));\n\tif (!frame)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&frame->info, info, sizeof(frame->info));\n\tframe->bytesused = info->frame_size;\n\n\tvpu_inst_lock(inst);\n\tlist_add_tail(&frame->list, &venc->frames);\n\tvenc->encode_count++;\n\tvenc_get_encoded_frames(inst);\n\tvpu_inst_unlock(inst);\n\n\treturn ret;\n}\n\nstatic void venc_set_last_buffer_dequeued(struct vpu_inst *inst)\n{\n\tstruct venc_t *venc = inst->priv;\n\n\tif (venc->stopped && list_empty(&venc->frames))\n\t\tvpu_set_last_buffer_dequeued(inst, true);\n}\n\nstatic void venc_stop_done(struct vpu_inst *inst)\n{\n\tstruct venc_t *venc = inst->priv;\n\n\tvpu_inst_lock(inst);\n\tvenc->stopped = true;\n\tvenc_set_last_buffer_dequeued(inst);\n\tvpu_inst_unlock(inst);\n\n\twake_up_all(&venc->wq);\n}\n\nstatic void venc_event_notify(struct vpu_inst *inst, u32 event, void *data)\n{\n}\n\nstatic void venc_release(struct vpu_inst *inst)\n{\n}\n\nstatic void venc_cleanup(struct vpu_inst *inst)\n{\n\tstruct venc_t *venc;\n\n\tif (!inst)\n\t\treturn;\n\n\tvenc = inst->priv;\n\tvfree(venc);\n\tinst->priv = NULL;\n\tvfree(inst);\n}\n\nstatic int venc_start_session(struct vpu_inst *inst, u32 type)\n{\n\tstruct venc_t *venc = inst->priv;\n\tint stream_buffer_size;\n\tint ret;\n\n\tvenc_set_enable(venc, type, 1);\n\tif ((venc->enable & VENC_ENABLE_MASK) != VENC_ENABLE_MASK)\n\t\treturn 0;\n\n\tvpu_iface_init_instance(inst);\n\tstream_buffer_size = vpu_iface_get_stream_buffer_size(inst->core);\n\tif (stream_buffer_size > 0) {\n\t\tinst->stream_buffer.length = max_t(u32, stream_buffer_size, venc->cpb_size * 3);\n\t\tret = vpu_alloc_dma(inst->core, &inst->stream_buffer);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tinst->use_stream_buffer = true;\n\t\tvpu_iface_config_stream_buffer(inst, &inst->stream_buffer);\n\t}\n\n\tret = vpu_iface_set_encode_params(inst, &venc->params, 0);\n\tif (ret)\n\t\tgoto error;\n\tret = vpu_session_configure_codec(inst);\n\tif (ret)\n\t\tgoto error;\n\n\tinst->state = VPU_CODEC_STATE_CONFIGURED;\n\t \n\n\t \n\tret = vpu_iface_set_encode_params(inst, &venc->params, 1);\n\tif (ret)\n\t\tgoto error;\n\n\tret = vpu_session_start(inst);\n\tif (ret)\n\t\tgoto error;\n\tinst->state = VPU_CODEC_STATE_STARTED;\n\n\tvenc->bitrate_change = false;\n\tvenc->input_ready = true;\n\tvenc->frame_count = 0;\n\tvenc->encode_count = 0;\n\tvenc->ready_count = 0;\n\tvenc->stopped = false;\n\tvpu_process_output_buffer(inst);\n\tif (venc->frame_count == 0)\n\t\tdev_err(inst->dev, \"[%d] there is no input when starting\\n\", inst->id);\n\n\treturn 0;\nerror:\n\tvenc_set_enable(venc, type, 0);\n\tinst->state = VPU_CODEC_STATE_DEINIT;\n\n\tvpu_free_dma(&inst->stream_buffer);\n\treturn ret;\n}\n\nstatic void venc_cleanup_mem_resource(struct vpu_inst *inst)\n{\n\tstruct venc_t *venc;\n\tu32 i;\n\n\tvenc = inst->priv;\n\n\tfor (i = 0; i < ARRAY_SIZE(venc->enc); i++)\n\t\tvpu_free_dma(&venc->enc[i]);\n\tfor (i = 0; i < ARRAY_SIZE(venc->ref); i++)\n\t\tvpu_free_dma(&venc->ref[i]);\n}\n\nstatic void venc_request_mem_resource(struct vpu_inst *inst,\n\t\t\t\t      u32 enc_frame_size,\n\t\t\t\t      u32 enc_frame_num,\n\t\t\t\t      u32 ref_frame_size,\n\t\t\t\t      u32 ref_frame_num,\n\t\t\t\t      u32 act_frame_size,\n\t\t\t\t      u32 act_frame_num)\n{\n\tstruct venc_t *venc;\n\tu32 i;\n\tint ret;\n\n\tvenc = inst->priv;\n\tif (enc_frame_num > ARRAY_SIZE(venc->enc)) {\n\t\tdev_err(inst->dev, \"[%d] enc num(%d) is out of range\\n\", inst->id, enc_frame_num);\n\t\treturn;\n\t}\n\tif (ref_frame_num > ARRAY_SIZE(venc->ref)) {\n\t\tdev_err(inst->dev, \"[%d] ref num(%d) is out of range\\n\", inst->id, ref_frame_num);\n\t\treturn;\n\t}\n\tif (act_frame_num > ARRAY_SIZE(venc->act)) {\n\t\tdev_err(inst->dev, \"[%d] act num(%d) is out of range\\n\", inst->id, act_frame_num);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < enc_frame_num; i++) {\n\t\tvenc->enc[i].length = enc_frame_size;\n\t\tret = vpu_alloc_dma(inst->core, &venc->enc[i]);\n\t\tif (ret) {\n\t\t\tvenc_cleanup_mem_resource(inst);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < ref_frame_num; i++) {\n\t\tvenc->ref[i].length = ref_frame_size;\n\t\tret = vpu_alloc_dma(inst->core, &venc->ref[i]);\n\t\tif (ret) {\n\t\t\tvenc_cleanup_mem_resource(inst);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (act_frame_num != 1 || act_frame_size > inst->act.length) {\n\t\tvenc_cleanup_mem_resource(inst);\n\t\treturn;\n\t}\n\tvenc->act[0].length = act_frame_size;\n\tvenc->act[0].phys = inst->act.phys;\n\tvenc->act[0].virt = inst->act.virt;\n\n\tfor (i = 0; i < enc_frame_num; i++)\n\t\tvpu_iface_config_memory_resource(inst, MEM_RES_ENC, i, &venc->enc[i]);\n\tfor (i = 0; i < ref_frame_num; i++)\n\t\tvpu_iface_config_memory_resource(inst, MEM_RES_REF, i, &venc->ref[i]);\n\tfor (i = 0; i < act_frame_num; i++)\n\t\tvpu_iface_config_memory_resource(inst, MEM_RES_ACT, i, &venc->act[i]);\n}\n\nstatic void venc_cleanup_frames(struct venc_t *venc)\n{\n\tstruct venc_frame_t *frame;\n\tstruct venc_frame_t *tmp;\n\n\tlist_for_each_entry_safe(frame, tmp, &venc->frames, list) {\n\t\tlist_del_init(&frame->list);\n\t\tvfree(frame);\n\t}\n}\n\nstatic int venc_stop_session(struct vpu_inst *inst, u32 type)\n{\n\tstruct venc_t *venc = inst->priv;\n\n\tvenc_set_enable(venc, type, 0);\n\tif (venc->enable & VENC_ENABLE_MASK)\n\t\treturn 0;\n\n\tif (inst->state == VPU_CODEC_STATE_DEINIT)\n\t\treturn 0;\n\n\tif (inst->state != VPU_CODEC_STATE_STOP)\n\t\tvenc_request_eos(inst);\n\n\tcall_void_vop(inst, wait_prepare);\n\tif (!wait_event_timeout(venc->wq, venc->stopped, VPU_TIMEOUT)) {\n\t\tset_bit(inst->id, &inst->core->hang_mask);\n\t\tvpu_session_debug(inst);\n\t}\n\tcall_void_vop(inst, wait_finish);\n\n\tinst->state = VPU_CODEC_STATE_DEINIT;\n\tvenc_cleanup_frames(inst->priv);\n\tvpu_free_dma(&inst->stream_buffer);\n\tvenc_cleanup_mem_resource(inst);\n\n\treturn 0;\n}\n\nstatic int venc_process_output(struct vpu_inst *inst, struct vb2_buffer *vb)\n{\n\tstruct venc_t *venc = inst->priv;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tu32 flags;\n\n\tif (inst->state == VPU_CODEC_STATE_DEINIT)\n\t\treturn -EINVAL;\n\n\tvbuf = to_vb2_v4l2_buffer(vb);\n\tif (inst->state == VPU_CODEC_STATE_STARTED)\n\t\tinst->state = VPU_CODEC_STATE_ACTIVE;\n\n\tflags = vbuf->flags;\n\tif (venc->request_key_frame) {\n\t\tvbuf->flags |= V4L2_BUF_FLAG_KEYFRAME;\n\t\tvenc->request_key_frame = 0;\n\t}\n\tif (venc->bitrate_change) {\n\t\tvpu_session_update_parameters(inst, &venc->params);\n\t\tvenc->bitrate_change = false;\n\t}\n\tdev_dbg(inst->dev, \"[%d][INPUT  TS]%32lld\\n\", inst->id, vb->timestamp);\n\tvpu_iface_input_frame(inst, vb);\n\tvbuf->flags = flags;\n\tvenc->input_ready = false;\n\tvenc->frame_count++;\n\tvpu_set_buffer_state(vbuf, VPU_BUF_STATE_INUSE);\n\n\treturn 0;\n}\n\nstatic int venc_process_capture(struct vpu_inst *inst, struct vb2_buffer *vb)\n{\n\tstruct venc_t *venc;\n\tstruct venc_frame_t *frame = NULL;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tint ret;\n\n\tvenc = inst->priv;\n\tif (list_empty(&venc->frames))\n\t\treturn -EINVAL;\n\n\tframe = list_first_entry(&venc->frames, struct venc_frame_t, list);\n\tvbuf = to_vb2_v4l2_buffer(vb);\n\tv4l2_m2m_dst_buf_remove_by_buf(inst->fh.m2m_ctx, vbuf);\n\tret = venc_get_one_encoded_frame(inst, frame, vbuf);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_del_init(&frame->list);\n\tvfree(frame);\n\treturn 0;\n}\n\nstatic void venc_on_queue_empty(struct vpu_inst *inst, u32 type)\n{\n\tstruct venc_t *venc = inst->priv;\n\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn;\n\n\tif (venc->stopped)\n\t\tvenc_set_last_buffer_dequeued(inst);\n}\n\nstatic int venc_get_debug_info(struct vpu_inst *inst, char *str, u32 size, u32 i)\n{\n\tstruct venc_t *venc = inst->priv;\n\tint num = -1;\n\n\tswitch (i) {\n\tcase 0:\n\t\tnum = scnprintf(str, size, \"profile = %d\\n\", venc->params.profile);\n\t\tbreak;\n\tcase 1:\n\t\tnum = scnprintf(str, size, \"level = %d\\n\", venc->params.level);\n\t\tbreak;\n\tcase 2:\n\t\tnum = scnprintf(str, size, \"fps = %d/%d\\n\",\n\t\t\t\tvenc->params.frame_rate.numerator,\n\t\t\t\tvenc->params.frame_rate.denominator);\n\t\tbreak;\n\tcase 3:\n\t\tnum = scnprintf(str, size, \"%d x %d -> %d x %d\\n\",\n\t\t\t\tvenc->params.src_width,\n\t\t\t\tvenc->params.src_height,\n\t\t\t\tvenc->params.out_width,\n\t\t\t\tvenc->params.out_height);\n\t\tbreak;\n\tcase 4:\n\t\tnum = scnprintf(str, size, \"(%d, %d)  %d x %d\\n\",\n\t\t\t\tvenc->params.crop.left,\n\t\t\t\tvenc->params.crop.top,\n\t\t\t\tvenc->params.crop.width,\n\t\t\t\tvenc->params.crop.height);\n\t\tbreak;\n\tcase 5:\n\t\tnum = scnprintf(str, size,\n\t\t\t\t\"enable = 0x%x, input = %d, encode = %d, ready = %d, stopped = %d\\n\",\n\t\t\t\tvenc->enable,\n\t\t\t\tvenc->frame_count, venc->encode_count,\n\t\t\t\tvenc->ready_count,\n\t\t\t\tvenc->stopped);\n\t\tbreak;\n\tcase 6:\n\t\tnum = scnprintf(str, size, \"gop = %d\\n\", venc->params.gop_length);\n\t\tbreak;\n\tcase 7:\n\t\tnum = scnprintf(str, size, \"bframes = %d\\n\", venc->params.bframes);\n\t\tbreak;\n\tcase 8:\n\t\tnum = scnprintf(str, size, \"rc: %s, mode = %d, bitrate = %d(%d), qp = %d\\n\",\n\t\t\t\tvenc->params.rc_enable ? \"enable\" : \"disable\",\n\t\t\t\tvenc->params.rc_mode,\n\t\t\t\tvenc->params.bitrate,\n\t\t\t\tvenc->params.bitrate_max,\n\t\t\t\tvenc->params.i_frame_qp);\n\t\tbreak;\n\tcase 9:\n\t\tnum = scnprintf(str, size, \"sar: enable = %d, idc = %d, %d x %d\\n\",\n\t\t\t\tvenc->params.sar.enable,\n\t\t\t\tvenc->params.sar.idc,\n\t\t\t\tvenc->params.sar.width,\n\t\t\t\tvenc->params.sar.height);\n\n\t\tbreak;\n\tcase 10:\n\t\tnum = scnprintf(str, size,\n\t\t\t\t\"colorspace: primaries = %d, transfer = %d, matrix = %d, full_range = %d\\n\",\n\t\t\t\tvenc->params.color.primaries,\n\t\t\t\tvenc->params.color.transfer,\n\t\t\t\tvenc->params.color.matrix,\n\t\t\t\tvenc->params.color.full_range);\n\t\tbreak;\n\tcase 11:\n\t\tnum = scnprintf(str, size, \"skipped: count = %d, bytes = %d\\n\",\n\t\t\t\tvenc->skipped_count, venc->skipped_bytes);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn num;\n}\n\nstatic struct vpu_inst_ops venc_inst_ops = {\n\t.ctrl_init = venc_ctrl_init,\n\t.check_ready = venc_check_ready,\n\t.input_done = venc_input_done,\n\t.get_one_frame = venc_frame_encoded,\n\t.stop_done = venc_stop_done,\n\t.event_notify = venc_event_notify,\n\t.release = venc_release,\n\t.cleanup = venc_cleanup,\n\t.start = venc_start_session,\n\t.mem_request = venc_request_mem_resource,\n\t.stop = venc_stop_session,\n\t.process_output = venc_process_output,\n\t.process_capture = venc_process_capture,\n\t.on_queue_empty = venc_on_queue_empty,\n\t.get_debug_info = venc_get_debug_info,\n\t.wait_prepare = vpu_inst_unlock,\n\t.wait_finish = vpu_inst_lock,\n};\n\nstatic void venc_init(struct file *file)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tstruct venc_t *venc;\n\tstruct v4l2_format f;\n\tstruct v4l2_streamparm parm;\n\n\tvenc = inst->priv;\n\tvenc->params.qp_min = 1;\n\tvenc->params.qp_max = 51;\n\tvenc->params.qp_min_i = 1;\n\tvenc->params.qp_max_i = 51;\n\tvenc->params.bitrate_min = BITRATE_MIN;\n\n\tmemset(&f, 0, sizeof(f));\n\tf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tf.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;\n\tf.fmt.pix_mp.width = 1280;\n\tf.fmt.pix_mp.height = 720;\n\tf.fmt.pix_mp.field = V4L2_FIELD_NONE;\n\tvenc_s_fmt(file, &inst->fh, &f);\n\n\tmemset(&f, 0, sizeof(f));\n\tf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tf.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H264;\n\tf.fmt.pix_mp.width = 1280;\n\tf.fmt.pix_mp.height = 720;\n\tf.fmt.pix_mp.field = V4L2_FIELD_NONE;\n\tvenc_s_fmt(file, &inst->fh, &f);\n\n\tmemset(&parm, 0, sizeof(parm));\n\tparm.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tparm.parm.capture.timeperframe.numerator = 1;\n\tparm.parm.capture.timeperframe.denominator = 30;\n\tvenc_s_parm(file, &inst->fh, &parm);\n}\n\nstatic int venc_open(struct file *file)\n{\n\tstruct vpu_inst *inst;\n\tstruct venc_t *venc;\n\tint ret;\n\n\tinst = vzalloc(sizeof(*inst));\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tvenc = vzalloc(sizeof(*venc));\n\tif (!venc) {\n\t\tvfree(inst);\n\t\treturn -ENOMEM;\n\t}\n\n\tinst->ops = &venc_inst_ops;\n\tinst->formats = venc_formats;\n\tinst->type = VPU_CORE_TYPE_ENC;\n\tinst->priv = venc;\n\tINIT_LIST_HEAD(&venc->frames);\n\tinit_waitqueue_head(&venc->wq);\n\n\tret = vpu_v4l2_open(file, inst);\n\tif (ret)\n\t\treturn ret;\n\n\tinst->min_buffer_out = VENC_MIN_BUFFER_OUT;\n\tinst->min_buffer_cap = VENC_MIN_BUFFER_CAP;\n\tvenc_init(file);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations venc_fops = {\n\t.owner = THIS_MODULE,\n\t.open = venc_open,\n\t.release = vpu_v4l2_close,\n\t.unlocked_ioctl = video_ioctl2,\n\t.poll = v4l2_m2m_fop_poll,\n\t.mmap = v4l2_m2m_fop_mmap,\n};\n\nconst struct v4l2_ioctl_ops *venc_get_ioctl_ops(void)\n{\n\treturn &venc_ioctl_ops;\n}\n\nconst struct v4l2_file_operations *venc_get_fops(void)\n{\n\treturn &venc_fops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}