{
  "module_name": "vdec.c",
  "hash_id": "9ee7e9006f91d785a73a01a02c519c27025e97d5a3ef7f00ae4a8fc48623bf11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/amphion/vdec.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interconnect.h>\n#include <linux/ioctl.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-vmalloc.h>\n#include \"vpu.h\"\n#include \"vpu_defs.h\"\n#include \"vpu_core.h\"\n#include \"vpu_helpers.h\"\n#include \"vpu_v4l2.h\"\n#include \"vpu_cmds.h\"\n#include \"vpu_rpc.h\"\n\n#define VDEC_MIN_BUFFER_CAP\t\t8\n#define VDEC_MIN_BUFFER_OUT\t\t8\n\nstruct vdec_fs_info {\n\tchar name[8];\n\tu32 type;\n\tu32 max_count;\n\tu32 req_count;\n\tu32 count;\n\tu32 index;\n\tu32 size;\n\tstruct vpu_buffer buffer[32];\n\tu32 tag;\n};\n\nstruct vdec_t {\n\tu32 seq_hdr_found;\n\tstruct vpu_buffer udata;\n\tstruct vpu_decode_params params;\n\tstruct vpu_dec_codec_info codec_info;\n\tenum vpu_codec_state state;\n\n\tstruct vpu_vb2_buffer *slots[VB2_MAX_FRAME];\n\tu32 req_frame_count;\n\tstruct vdec_fs_info mbi;\n\tstruct vdec_fs_info dcp;\n\tu32 seq_tag;\n\n\tbool reset_codec;\n\tbool fixed_fmt;\n\tu32 decoded_frame_count;\n\tu32 display_frame_count;\n\tu32 sequence;\n\tu32 eos_received;\n\tbool is_source_changed;\n\tu32 source_change;\n\tu32 drain;\n\tbool aborting;\n};\n\nstatic const struct vpu_format vdec_formats[] = {\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_NV12M_8L128,\n\t\t.mem_planes = 2,\n\t\t.comp_planes = 2,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t\t.sibling = V4L2_PIX_FMT_NV12_8L128,\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_NV12_8L128,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 2,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t\t.sibling = V4L2_PIX_FMT_NV12M_8L128,\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_NV12M_10BE_8L128,\n\t\t.mem_planes = 2,\n\t\t.comp_planes = 2,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t\t.sibling = V4L2_PIX_FMT_NV12_10BE_8L128,\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_NV12_10BE_8L128,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 2,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t\t.sibling = V4L2_PIX_FMT_NV12M_10BE_8L128\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_H264,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION | V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_H264_MVC,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION | V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_HEVC,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION | V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_VC1_ANNEX_G,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION | V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_VC1_ANNEX_L,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_MPEG2,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION | V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_MPEG4,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION | V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_XVID,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION | V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_VP8,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION | V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_H263,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION | V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_SPK,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION | V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_RV30,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION | V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{\n\t\t.pixfmt = V4L2_PIX_FMT_RV40,\n\t\t.mem_planes = 1,\n\t\t.comp_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION | V4L2_FMT_FLAG_COMPRESSED\n\t},\n\t{0, 0, 0, 0},\n};\n\nstatic int vdec_op_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct vpu_inst *inst = ctrl_to_inst(ctrl);\n\tstruct vdec_t *vdec = inst->priv;\n\tint ret = 0;\n\n\tvpu_inst_lock(inst);\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY_ENABLE:\n\t\tvdec->params.display_delay_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY:\n\t\tvdec->params.display_delay = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tvpu_inst_unlock(inst);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops vdec_ctrl_ops = {\n\t.s_ctrl = vdec_op_s_ctrl,\n\t.g_volatile_ctrl = vpu_helper_g_volatile_ctrl,\n};\n\nstatic int vdec_ctrl_init(struct vpu_inst *inst)\n{\n\tstruct v4l2_ctrl *ctrl;\n\tint ret;\n\n\tret = v4l2_ctrl_handler_init(&inst->ctrl_handler, 20);\n\tif (ret)\n\t\treturn ret;\n\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &vdec_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY,\n\t\t\t  0, 0, 1, 0);\n\n\tv4l2_ctrl_new_std(&inst->ctrl_handler, &vdec_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY_ENABLE,\n\t\t\t  0, 1, 1, 0);\n\n\tctrl = v4l2_ctrl_new_std(&inst->ctrl_handler, &vdec_ctrl_ops,\n\t\t\t\t V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 2);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\tctrl = v4l2_ctrl_new_std(&inst->ctrl_handler, &vdec_ctrl_ops,\n\t\t\t\t V4L2_CID_MIN_BUFFERS_FOR_OUTPUT, 1, 32, 1, 2);\n\tif (ctrl)\n\t\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\n\tif (inst->ctrl_handler.error) {\n\t\tret = inst->ctrl_handler.error;\n\t\tv4l2_ctrl_handler_free(&inst->ctrl_handler);\n\t\treturn ret;\n\t}\n\n\tret = v4l2_ctrl_handler_setup(&inst->ctrl_handler);\n\tif (ret) {\n\t\tdev_err(inst->dev, \"[%d] setup ctrls fail, ret = %d\\n\", inst->id, ret);\n\t\tv4l2_ctrl_handler_free(&inst->ctrl_handler);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void vdec_handle_resolution_change(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct vb2_queue *q;\n\n\tif (!inst->fh.m2m_ctx)\n\t\treturn;\n\n\tif (inst->state != VPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE)\n\t\treturn;\n\tif (!vdec->source_change)\n\t\treturn;\n\n\tq = v4l2_m2m_get_dst_vq(inst->fh.m2m_ctx);\n\tif (!list_empty(&q->done_list))\n\t\treturn;\n\n\tvdec->source_change--;\n\tvpu_notify_source_change(inst);\n\tvpu_set_last_buffer_dequeued(inst, false);\n}\n\nstatic int vdec_update_state(struct vpu_inst *inst, enum vpu_codec_state state, u32 force)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tenum vpu_codec_state pre_state = inst->state;\n\n\tif (state == VPU_CODEC_STATE_SEEK) {\n\t\tif (inst->state == VPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE)\n\t\t\tvdec->state = inst->state;\n\t\telse\n\t\t\tvdec->state = VPU_CODEC_STATE_ACTIVE;\n\t}\n\tif (inst->state != VPU_CODEC_STATE_SEEK || force)\n\t\tinst->state = state;\n\telse if (state == VPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE)\n\t\tvdec->state = VPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE;\n\n\tif (inst->state != pre_state)\n\t\tvpu_trace(inst->dev, \"[%d] %s -> %s\\n\", inst->id,\n\t\t\t  vpu_codec_state_name(pre_state), vpu_codec_state_name(inst->state));\n\n\tif (inst->state == VPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE)\n\t\tvdec_handle_resolution_change(inst);\n\n\treturn 0;\n}\n\nstatic void vdec_set_last_buffer_dequeued(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tif (inst->state == VPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE)\n\t\treturn;\n\n\tif (vdec->eos_received) {\n\t\tif (!vpu_set_last_buffer_dequeued(inst, true)) {\n\t\t\tvdec->eos_received--;\n\t\t\tvdec_update_state(inst, VPU_CODEC_STATE_DRAIN, 0);\n\t\t}\n\t}\n}\n\nstatic int vdec_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, \"amphion-vpu\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"amphion vpu decoder\", sizeof(cap->card));\n\tstrscpy(cap->bus_info, \"platform: amphion-vpu\", sizeof(cap->bus_info));\n\n\treturn 0;\n}\n\nstatic int vdec_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tstruct vdec_t *vdec = inst->priv;\n\tconst struct vpu_format *fmt;\n\tint ret = -EINVAL;\n\n\tvpu_inst_lock(inst);\n\tif (V4L2_TYPE_IS_CAPTURE(f->type) && vdec->fixed_fmt) {\n\t\tfmt = vpu_get_format(inst, f->type);\n\t\tif (f->index == 1)\n\t\t\tfmt = vpu_helper_find_sibling(inst, f->type, fmt->pixfmt);\n\t\tif (f->index > 1)\n\t\t\tfmt = NULL;\n\t} else {\n\t\tfmt = vpu_helper_enum_format(inst, f->type, f->index);\n\t}\n\tif (!fmt)\n\t\tgoto exit;\n\n\tmemset(f->reserved, 0, sizeof(f->reserved));\n\tf->pixelformat = fmt->pixfmt;\n\tf->flags = fmt->flags;\n\tret = 0;\nexit:\n\tvpu_inst_unlock(inst);\n\treturn ret;\n}\n\nstatic int vdec_g_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tstruct vpu_format *cur_fmt;\n\tint i;\n\n\tvpu_inst_lock(inst);\n\tcur_fmt = vpu_get_format(inst, f->type);\n\n\tpixmp->pixelformat = cur_fmt->pixfmt;\n\tpixmp->num_planes = cur_fmt->mem_planes;\n\tpixmp->width = cur_fmt->width;\n\tpixmp->height = cur_fmt->height;\n\tpixmp->field = cur_fmt->field;\n\tpixmp->flags = cur_fmt->flags;\n\tfor (i = 0; i < pixmp->num_planes; i++) {\n\t\tpixmp->plane_fmt[i].bytesperline = cur_fmt->bytesperline[i];\n\t\tpixmp->plane_fmt[i].sizeimage = vpu_get_fmt_plane_size(cur_fmt, i);\n\t}\n\n\tf->fmt.pix_mp.colorspace = vdec->codec_info.color_primaries;\n\tf->fmt.pix_mp.xfer_func = vdec->codec_info.transfer_chars;\n\tf->fmt.pix_mp.ycbcr_enc = vdec->codec_info.matrix_coeffs;\n\tf->fmt.pix_mp.quantization = vdec->codec_info.full_range;\n\tvpu_inst_unlock(inst);\n\n\treturn 0;\n}\n\nstatic int vdec_try_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct vpu_format fmt;\n\n\tvpu_inst_lock(inst);\n\tif (V4L2_TYPE_IS_CAPTURE(f->type) && vdec->fixed_fmt) {\n\t\tstruct vpu_format *cap_fmt = vpu_get_format(inst, f->type);\n\n\t\tif (!vpu_helper_match_format(inst, cap_fmt->type, cap_fmt->pixfmt,\n\t\t\t\t\t     f->fmt.pix_mp.pixelformat))\n\t\t\tf->fmt.pix_mp.pixelformat = cap_fmt->pixfmt;\n\t}\n\n\tvpu_try_fmt_common(inst, f, &fmt);\n\n\tif (vdec->fixed_fmt) {\n\t\tf->fmt.pix_mp.colorspace = vdec->codec_info.color_primaries;\n\t\tf->fmt.pix_mp.xfer_func = vdec->codec_info.transfer_chars;\n\t\tf->fmt.pix_mp.ycbcr_enc = vdec->codec_info.matrix_coeffs;\n\t\tf->fmt.pix_mp.quantization = vdec->codec_info.full_range;\n\t} else {\n\t\tf->fmt.pix_mp.colorspace = V4L2_COLORSPACE_DEFAULT;\n\t\tf->fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\t\tf->fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\t\tf->fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT;\n\t}\n\tvpu_inst_unlock(inst);\n\n\treturn 0;\n}\n\nstatic int vdec_s_fmt_common(struct vpu_inst *inst, struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tstruct vpu_format fmt;\n\tstruct vpu_format *cur_fmt;\n\tstruct vb2_queue *q;\n\tstruct vdec_t *vdec = inst->priv;\n\tint i;\n\n\tif (!inst->fh.m2m_ctx)\n\t\treturn -EINVAL;\n\n\tq = v4l2_m2m_get_vq(inst->fh.m2m_ctx, f->type);\n\tif (!q)\n\t\treturn -EINVAL;\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\tif (vpu_try_fmt_common(inst, f, &fmt))\n\t\treturn -EINVAL;\n\n\tcur_fmt = vpu_get_format(inst, f->type);\n\tif (V4L2_TYPE_IS_OUTPUT(f->type) && inst->state != VPU_CODEC_STATE_DEINIT) {\n\t\tif (cur_fmt->pixfmt != fmt.pixfmt) {\n\t\t\tvdec->reset_codec = true;\n\t\t\tvdec->fixed_fmt = false;\n\t\t}\n\t}\n\tif (V4L2_TYPE_IS_OUTPUT(f->type) || !vdec->fixed_fmt) {\n\t\tmemcpy(cur_fmt, &fmt, sizeof(*cur_fmt));\n\t} else {\n\t\tif (vpu_helper_match_format(inst, f->type, cur_fmt->pixfmt, pixmp->pixelformat)) {\n\t\t\tcur_fmt->pixfmt = fmt.pixfmt;\n\t\t\tcur_fmt->mem_planes = fmt.mem_planes;\n\t\t}\n\t\tpixmp->pixelformat = cur_fmt->pixfmt;\n\t\tpixmp->num_planes = cur_fmt->mem_planes;\n\t\tpixmp->width = cur_fmt->width;\n\t\tpixmp->height = cur_fmt->height;\n\t\tfor (i = 0; i < pixmp->num_planes; i++) {\n\t\t\tpixmp->plane_fmt[i].bytesperline = cur_fmt->bytesperline[i];\n\t\t\tpixmp->plane_fmt[i].sizeimage = vpu_get_fmt_plane_size(cur_fmt, i);\n\t\t}\n\t\tpixmp->field = cur_fmt->field;\n\t}\n\n\tif (!vdec->fixed_fmt) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(f->type)) {\n\t\t\tvdec->params.codec_format = cur_fmt->pixfmt;\n\t\t\tvdec->codec_info.color_primaries = f->fmt.pix_mp.colorspace;\n\t\t\tvdec->codec_info.transfer_chars = f->fmt.pix_mp.xfer_func;\n\t\t\tvdec->codec_info.matrix_coeffs = f->fmt.pix_mp.ycbcr_enc;\n\t\t\tvdec->codec_info.full_range = f->fmt.pix_mp.quantization;\n\t\t} else {\n\t\t\tvdec->params.output_format = cur_fmt->pixfmt;\n\t\t\tinst->crop.left = 0;\n\t\t\tinst->crop.top = 0;\n\t\t\tinst->crop.width = cur_fmt->width;\n\t\t\tinst->crop.height = cur_fmt->height;\n\t\t}\n\t}\n\n\tvpu_trace(inst->dev, \"[%d] %c%c%c%c %dx%d\\n\", inst->id,\n\t\t  f->fmt.pix_mp.pixelformat,\n\t\t  f->fmt.pix_mp.pixelformat >> 8,\n\t\t  f->fmt.pix_mp.pixelformat >> 16,\n\t\t  f->fmt.pix_mp.pixelformat >> 24,\n\t\t  f->fmt.pix_mp.width,\n\t\t  f->fmt.pix_mp.height);\n\n\treturn 0;\n}\n\nstatic int vdec_s_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tstruct vdec_t *vdec = inst->priv;\n\tint ret = 0;\n\n\tvpu_inst_lock(inst);\n\tret = vdec_s_fmt_common(inst, f);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (V4L2_TYPE_IS_OUTPUT(f->type) && !vdec->fixed_fmt) {\n\t\tstruct v4l2_format fc;\n\n\t\tmemset(&fc, 0, sizeof(fc));\n\t\tfc.type = inst->cap_format.type;\n\t\tfc.fmt.pix_mp.pixelformat = inst->cap_format.pixfmt;\n\t\tfc.fmt.pix_mp.width = pixmp->width;\n\t\tfc.fmt.pix_mp.height = pixmp->height;\n\t\tvdec_s_fmt_common(inst, &fc);\n\t}\n\n\tf->fmt.pix_mp.colorspace = vdec->codec_info.color_primaries;\n\tf->fmt.pix_mp.xfer_func = vdec->codec_info.transfer_chars;\n\tf->fmt.pix_mp.ycbcr_enc = vdec->codec_info.matrix_coeffs;\n\tf->fmt.pix_mp.quantization = vdec->codec_info.full_range;\n\nexit:\n\tvpu_inst_unlock(inst);\n\treturn ret;\n}\n\nstatic int vdec_g_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE && s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_PADDED:\n\t\ts->r = inst->crop;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = inst->cap_format.width;\n\t\ts->r.height = inst->cap_format.height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vdec_drain(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tif (!inst->fh.m2m_ctx)\n\t\treturn 0;\n\n\tif (!vdec->drain)\n\t\treturn 0;\n\n\tif (!vpu_is_source_empty(inst))\n\t\treturn 0;\n\n\tif (!vdec->params.frame_count) {\n\t\tvpu_set_last_buffer_dequeued(inst, true);\n\t\treturn 0;\n\t}\n\n\tvpu_iface_add_scode(inst, SCODE_PADDING_EOS);\n\tvdec->params.end_flag = 1;\n\tvpu_iface_set_decode_params(inst, &vdec->params, 1);\n\tvdec->drain = 0;\n\tvpu_trace(inst->dev, \"[%d] frame_count = %d\\n\", inst->id, vdec->params.frame_count);\n\n\treturn 0;\n}\n\nstatic int vdec_cmd_start(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tswitch (inst->state) {\n\tcase VPU_CODEC_STATE_STARTED:\n\tcase VPU_CODEC_STATE_DRAIN:\n\tcase VPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE:\n\t\tvdec_update_state(inst, VPU_CODEC_STATE_ACTIVE, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tvpu_process_capture_buffer(inst);\n\tif (vdec->eos_received)\n\t\tvdec_set_last_buffer_dequeued(inst);\n\treturn 0;\n}\n\nstatic int vdec_cmd_stop(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tvpu_trace(inst->dev, \"[%d]\\n\", inst->id);\n\n\tif (inst->state == VPU_CODEC_STATE_DEINIT) {\n\t\tvpu_set_last_buffer_dequeued(inst, true);\n\t} else {\n\t\tvdec->drain = 1;\n\t\tvdec_drain(inst);\n\t}\n\n\treturn 0;\n}\n\nstatic int vdec_decoder_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *cmd)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tint ret;\n\n\tret = v4l2_m2m_ioctl_try_decoder_cmd(file, fh, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tvpu_inst_lock(inst);\n\tswitch (cmd->cmd) {\n\tcase V4L2_DEC_CMD_START:\n\t\tvdec_cmd_start(inst);\n\t\tbreak;\n\tcase V4L2_DEC_CMD_STOP:\n\t\tvdec_cmd_stop(inst);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tvpu_inst_unlock(inst);\n\n\treturn 0;\n}\n\nstatic int vdec_subscribe_event(struct v4l2_fh *fh, const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_EOS:\n\t\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subscribe(fh, sub);\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops vdec_ioctl_ops = {\n\t.vidioc_querycap               = vdec_querycap,\n\t.vidioc_enum_fmt_vid_cap       = vdec_enum_fmt,\n\t.vidioc_enum_fmt_vid_out       = vdec_enum_fmt,\n\t.vidioc_g_fmt_vid_cap_mplane   = vdec_g_fmt,\n\t.vidioc_g_fmt_vid_out_mplane   = vdec_g_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane = vdec_try_fmt,\n\t.vidioc_try_fmt_vid_out_mplane = vdec_try_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane   = vdec_s_fmt,\n\t.vidioc_s_fmt_vid_out_mplane   = vdec_s_fmt,\n\t.vidioc_g_selection            = vdec_g_selection,\n\t.vidioc_try_decoder_cmd        = v4l2_m2m_ioctl_try_decoder_cmd,\n\t.vidioc_decoder_cmd            = vdec_decoder_cmd,\n\t.vidioc_subscribe_event        = vdec_subscribe_event,\n\t.vidioc_unsubscribe_event      = v4l2_event_unsubscribe,\n\t.vidioc_reqbufs                = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_create_bufs\t       = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t       = v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_querybuf               = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf                   = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_expbuf                 = v4l2_m2m_ioctl_expbuf,\n\t.vidioc_dqbuf                  = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_streamon               = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff              = v4l2_m2m_ioctl_streamoff,\n};\n\nstatic bool vdec_check_ready(struct vpu_inst *inst, unsigned int type)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn true;\n\n\tif (vdec->req_frame_count)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct vb2_v4l2_buffer *vdec_get_src_buffer(struct vpu_inst *inst, u32 count)\n{\n\tif (count > 1)\n\t\tvpu_skip_frame(inst, count - 1);\n\n\treturn vpu_next_src_buf(inst);\n}\n\nstatic int vdec_frame_decoded(struct vpu_inst *inst, void *arg)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct vpu_dec_pic_info *info = arg;\n\tstruct vpu_vb2_buffer *vpu_buf;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct vb2_v4l2_buffer *src_buf;\n\tint ret = 0;\n\n\tif (!info || info->id >= ARRAY_SIZE(vdec->slots))\n\t\treturn -EINVAL;\n\n\tvpu_inst_lock(inst);\n\tvpu_buf = vdec->slots[info->id];\n\tif (!vpu_buf) {\n\t\tdev_err(inst->dev, \"[%d] decoded invalid frame[%d]\\n\", inst->id, info->id);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\tvbuf = &vpu_buf->m2m_buf.vb;\n\tsrc_buf = vdec_get_src_buffer(inst, info->consumed_count);\n\tif (src_buf) {\n\t\tv4l2_m2m_buf_copy_metadata(src_buf, vbuf, true);\n\t\tif (info->consumed_count) {\n\t\t\tv4l2_m2m_src_buf_remove(inst->fh.m2m_ctx);\n\t\t\tvpu_set_buffer_state(src_buf, VPU_BUF_STATE_IDLE);\n\t\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\t\t} else {\n\t\t\tvpu_set_buffer_state(src_buf, VPU_BUF_STATE_DECODED);\n\t\t}\n\t}\n\tif (vpu_get_buffer_state(vbuf) == VPU_BUF_STATE_DECODED)\n\t\tdev_info(inst->dev, \"[%d] buf[%d] has been decoded\\n\", inst->id, info->id);\n\tvpu_set_buffer_state(vbuf, VPU_BUF_STATE_DECODED);\n\tvdec->decoded_frame_count++;\n\tif (vdec->params.display_delay_enable) {\n\t\tstruct vpu_format *cur_fmt;\n\n\t\tcur_fmt = vpu_get_format(inst, inst->cap_format.type);\n\t\tvpu_set_buffer_state(vbuf, VPU_BUF_STATE_READY);\n\t\tfor (int i = 0; i < vbuf->vb2_buf.num_planes; i++)\n\t\t\tvb2_set_plane_payload(&vbuf->vb2_buf,\n\t\t\t\t\t      i, vpu_get_fmt_plane_size(cur_fmt, i));\n\t\tvbuf->field = cur_fmt->field;\n\t\tvbuf->sequence = vdec->sequence++;\n\t\tdev_dbg(inst->dev, \"[%d][OUTPUT TS]%32lld\\n\", inst->id, vbuf->vb2_buf.timestamp);\n\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);\n\t\tvdec->display_frame_count++;\n\t}\nexit:\n\tvpu_inst_unlock(inst);\n\n\treturn ret;\n}\n\nstatic struct vpu_vb2_buffer *vdec_find_buffer(struct vpu_inst *inst, u32 luma)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vdec->slots); i++) {\n\t\tif (!vdec->slots[i])\n\t\t\tcontinue;\n\t\tif (luma == vdec->slots[i]->luma)\n\t\t\treturn vdec->slots[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic void vdec_buf_done(struct vpu_inst *inst, struct vpu_frame_info *frame)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct vpu_format *cur_fmt;\n\tstruct vpu_vb2_buffer *vpu_buf;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tint i;\n\n\tif (!frame)\n\t\treturn;\n\n\tvpu_inst_lock(inst);\n\tif (!vdec->params.display_delay_enable)\n\t\tvdec->sequence++;\n\tvpu_buf = vdec_find_buffer(inst, frame->luma);\n\tvpu_inst_unlock(inst);\n\tif (!vpu_buf) {\n\t\tdev_err(inst->dev, \"[%d] can't find buffer, id = %d, addr = 0x%x\\n\",\n\t\t\tinst->id, frame->id, frame->luma);\n\t\treturn;\n\t}\n\tif (frame->skipped) {\n\t\tdev_dbg(inst->dev, \"[%d] frame skip\\n\", inst->id);\n\t\treturn;\n\t}\n\n\tcur_fmt = vpu_get_format(inst, inst->cap_format.type);\n\tvbuf = &vpu_buf->m2m_buf.vb;\n\tif (vbuf->vb2_buf.index != frame->id)\n\t\tdev_err(inst->dev, \"[%d] buffer id(%d, %d) dismatch\\n\",\n\t\t\tinst->id, vbuf->vb2_buf.index, frame->id);\n\n\tif (vpu_get_buffer_state(vbuf) == VPU_BUF_STATE_READY && vdec->params.display_delay_enable)\n\t\treturn;\n\n\tif (vpu_get_buffer_state(vbuf) != VPU_BUF_STATE_DECODED)\n\t\tdev_err(inst->dev, \"[%d] buffer(%d) ready without decoded\\n\", inst->id, frame->id);\n\n\tvpu_set_buffer_state(vbuf, VPU_BUF_STATE_READY);\n\tfor (i = 0; i < vbuf->vb2_buf.num_planes; i++)\n\t\tvb2_set_plane_payload(&vbuf->vb2_buf, i, vpu_get_fmt_plane_size(cur_fmt, i));\n\tvbuf->field = cur_fmt->field;\n\tvbuf->sequence = vdec->sequence;\n\tdev_dbg(inst->dev, \"[%d][OUTPUT TS]%32lld\\n\", inst->id, vbuf->vb2_buf.timestamp);\n\n\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);\n\tvpu_inst_lock(inst);\n\tvdec->display_frame_count++;\n\tvpu_inst_unlock(inst);\n\tdev_dbg(inst->dev, \"[%d] decoded : %d, display : %d, sequence : %d\\n\",\n\t\tinst->id, vdec->decoded_frame_count, vdec->display_frame_count, vdec->sequence);\n}\n\nstatic void vdec_stop_done(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tvpu_inst_lock(inst);\n\tvdec_update_state(inst, VPU_CODEC_STATE_DEINIT, 0);\n\tvdec->seq_hdr_found = 0;\n\tvdec->req_frame_count = 0;\n\tvdec->reset_codec = false;\n\tvdec->fixed_fmt = false;\n\tvdec->params.end_flag = 0;\n\tvdec->drain = 0;\n\tvdec->params.frame_count = 0;\n\tvdec->decoded_frame_count = 0;\n\tvdec->display_frame_count = 0;\n\tvdec->sequence = 0;\n\tvdec->eos_received = 0;\n\tvdec->is_source_changed = false;\n\tvdec->source_change = 0;\n\tinst->total_input_count = 0;\n\tvpu_inst_unlock(inst);\n}\n\nstatic bool vdec_check_source_change(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tconst struct vpu_format *sibling;\n\n\tif (!inst->fh.m2m_ctx)\n\t\treturn false;\n\n\tif (vdec->reset_codec)\n\t\treturn false;\n\n\tsibling = vpu_helper_find_sibling(inst, inst->cap_format.type, inst->cap_format.pixfmt);\n\tif (sibling && vdec->codec_info.pixfmt == sibling->pixfmt)\n\t\tvdec->codec_info.pixfmt = inst->cap_format.pixfmt;\n\n\tif (!vb2_is_streaming(v4l2_m2m_get_dst_vq(inst->fh.m2m_ctx)))\n\t\treturn true;\n\tif (inst->cap_format.pixfmt != vdec->codec_info.pixfmt)\n\t\treturn true;\n\tif (inst->cap_format.width != vdec->codec_info.decoded_width)\n\t\treturn true;\n\tif (inst->cap_format.height != vdec->codec_info.decoded_height)\n\t\treturn true;\n\tif (vpu_get_num_buffers(inst, inst->cap_format.type) < inst->min_buffer_cap)\n\t\treturn true;\n\tif (inst->crop.left != vdec->codec_info.offset_x)\n\t\treturn true;\n\tif (inst->crop.top != vdec->codec_info.offset_y)\n\t\treturn true;\n\tif (inst->crop.width != vdec->codec_info.width)\n\t\treturn true;\n\tif (inst->crop.height != vdec->codec_info.height)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void vdec_init_fmt(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct v4l2_format f;\n\n\tmemset(&f, 0, sizeof(f));\n\tf.type = inst->cap_format.type;\n\tf.fmt.pix_mp.pixelformat = vdec->codec_info.pixfmt;\n\tf.fmt.pix_mp.width = vdec->codec_info.decoded_width;\n\tf.fmt.pix_mp.height = vdec->codec_info.decoded_height;\n\tif (vdec->codec_info.progressive)\n\t\tf.fmt.pix_mp.field = V4L2_FIELD_NONE;\n\telse\n\t\tf.fmt.pix_mp.field = V4L2_FIELD_SEQ_TB;\n\tvpu_try_fmt_common(inst, &f, &inst->cap_format);\n\n\tinst->out_format.width = vdec->codec_info.width;\n\tinst->out_format.height = vdec->codec_info.height;\n}\n\nstatic void vdec_init_crop(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tinst->crop.left = vdec->codec_info.offset_x;\n\tinst->crop.top = vdec->codec_info.offset_y;\n\tinst->crop.width = vdec->codec_info.width;\n\tinst->crop.height = vdec->codec_info.height;\n}\n\nstatic void vdec_init_mbi(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tvdec->mbi.size = vdec->codec_info.mbi_size;\n\tvdec->mbi.max_count = ARRAY_SIZE(vdec->mbi.buffer);\n\tscnprintf(vdec->mbi.name, sizeof(vdec->mbi.name), \"mbi\");\n\tvdec->mbi.type = MEM_RES_MBI;\n\tvdec->mbi.tag = vdec->seq_tag;\n}\n\nstatic void vdec_init_dcp(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tvdec->dcp.size = vdec->codec_info.dcp_size;\n\tvdec->dcp.max_count = ARRAY_SIZE(vdec->dcp.buffer);\n\tscnprintf(vdec->dcp.name, sizeof(vdec->dcp.name), \"dcp\");\n\tvdec->dcp.type = MEM_RES_DCP;\n\tvdec->dcp.tag = vdec->seq_tag;\n}\n\nstatic void vdec_request_one_fs(struct vdec_fs_info *fs)\n{\n\tfs->req_count++;\n\tif (fs->req_count > fs->max_count)\n\t\tfs->req_count = fs->max_count;\n}\n\nstatic int vdec_alloc_fs_buffer(struct vpu_inst *inst, struct vdec_fs_info *fs)\n{\n\tstruct vpu_buffer *buffer;\n\n\tif (!fs->size)\n\t\treturn -EINVAL;\n\n\tif (fs->count >= fs->req_count)\n\t\treturn -EINVAL;\n\n\tbuffer = &fs->buffer[fs->count];\n\tif (buffer->virt && buffer->length >= fs->size)\n\t\treturn 0;\n\n\tvpu_free_dma(buffer);\n\tbuffer->length = fs->size;\n\treturn vpu_alloc_dma(inst->core, buffer);\n}\n\nstatic void vdec_alloc_fs(struct vpu_inst *inst, struct vdec_fs_info *fs)\n{\n\tint ret;\n\n\twhile (fs->count < fs->req_count) {\n\t\tret = vdec_alloc_fs_buffer(inst, fs);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tfs->count++;\n\t}\n}\n\nstatic void vdec_clear_fs(struct vdec_fs_info *fs)\n{\n\tu32 i;\n\n\tif (!fs)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(fs->buffer); i++)\n\t\tvpu_free_dma(&fs->buffer[i]);\n\tmemset(fs, 0, sizeof(*fs));\n}\n\nstatic int vdec_response_fs(struct vpu_inst *inst, struct vdec_fs_info *fs)\n{\n\tstruct vpu_fs_info info;\n\tint ret;\n\n\tif (fs->index >= fs->count)\n\t\treturn 0;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = fs->index;\n\tinfo.type = fs->type;\n\tinfo.tag = fs->tag;\n\tinfo.luma_addr = fs->buffer[fs->index].phys;\n\tinfo.luma_size = fs->buffer[fs->index].length;\n\tret = vpu_session_alloc_fs(inst, &info);\n\tif (ret)\n\t\treturn ret;\n\n\tfs->index++;\n\treturn 0;\n}\n\nstatic int vdec_response_frame_abnormal(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct vpu_fs_info info;\n\tint ret;\n\n\tif (!vdec->req_frame_count)\n\t\treturn 0;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.type = MEM_RES_FRAME;\n\tinfo.tag = vdec->seq_tag + 0xf0;\n\tret = vpu_session_alloc_fs(inst, &info);\n\tif (ret)\n\t\treturn ret;\n\tvdec->req_frame_count--;\n\n\treturn 0;\n}\n\nstatic int vdec_response_frame(struct vpu_inst *inst, struct vb2_v4l2_buffer *vbuf)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct vpu_vb2_buffer *vpu_buf;\n\tstruct vpu_fs_info info;\n\tint ret;\n\n\tif (inst->state != VPU_CODEC_STATE_ACTIVE)\n\t\treturn -EINVAL;\n\n\tif (vdec->aborting)\n\t\treturn -EINVAL;\n\n\tif (!vdec->req_frame_count)\n\t\treturn -EINVAL;\n\n\tif (!vbuf)\n\t\treturn -EINVAL;\n\n\tif (vdec->slots[vbuf->vb2_buf.index]) {\n\t\tdev_err(inst->dev, \"[%d] repeat alloc fs %d\\n\",\n\t\t\tinst->id, vbuf->vb2_buf.index);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(inst->dev, \"[%d] state = %s, alloc fs %d, tag = 0x%x\\n\",\n\t\tinst->id, vpu_codec_state_name(inst->state), vbuf->vb2_buf.index, vdec->seq_tag);\n\tvpu_buf = to_vpu_vb2_buffer(vbuf);\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = vbuf->vb2_buf.index;\n\tinfo.type = MEM_RES_FRAME;\n\tinfo.tag = vdec->seq_tag;\n\tinfo.luma_addr = vpu_get_vb_phy_addr(&vbuf->vb2_buf, 0);\n\tinfo.luma_size = inst->cap_format.sizeimage[0];\n\tif (vbuf->vb2_buf.num_planes > 1)\n\t\tinfo.chroma_addr = vpu_get_vb_phy_addr(&vbuf->vb2_buf, 1);\n\telse\n\t\tinfo.chroma_addr = info.luma_addr + info.luma_size;\n\tinfo.chromau_size = inst->cap_format.sizeimage[1];\n\tinfo.bytesperline = inst->cap_format.bytesperline[0];\n\tret = vpu_session_alloc_fs(inst, &info);\n\tif (ret)\n\t\treturn ret;\n\n\tvpu_buf->tag = info.tag;\n\tvpu_buf->luma = info.luma_addr;\n\tvpu_buf->chroma_u = info.chroma_addr;\n\tvpu_buf->chroma_v = 0;\n\tvpu_set_buffer_state(vbuf, VPU_BUF_STATE_INUSE);\n\tvdec->slots[info.id] = vpu_buf;\n\tvdec->req_frame_count--;\n\n\treturn 0;\n}\n\nstatic void vdec_response_fs_request(struct vpu_inst *inst, bool force)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tint i;\n\tint ret;\n\n\tif (force) {\n\t\tfor (i = vdec->req_frame_count; i > 0; i--)\n\t\t\tvdec_response_frame_abnormal(inst);\n\t\treturn;\n\t}\n\n\tfor (i = vdec->req_frame_count; i > 0; i--) {\n\t\tret = vpu_process_capture_buffer(inst);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (vdec->eos_received)\n\t\t\tbreak;\n\t}\n\n\tfor (i = vdec->mbi.index; i < vdec->mbi.count; i++) {\n\t\tif (vdec_response_fs(inst, &vdec->mbi))\n\t\t\tbreak;\n\t\tif (vdec->eos_received)\n\t\t\tbreak;\n\t}\n\tfor (i = vdec->dcp.index; i < vdec->dcp.count; i++) {\n\t\tif (vdec_response_fs(inst, &vdec->dcp))\n\t\t\tbreak;\n\t\tif (vdec->eos_received)\n\t\t\tbreak;\n\t}\n}\n\nstatic void vdec_response_fs_release(struct vpu_inst *inst, u32 id, u32 tag)\n{\n\tstruct vpu_fs_info info;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = id;\n\tinfo.tag = tag;\n\tvpu_session_release_fs(inst, &info);\n}\n\nstatic void vdec_recycle_buffer(struct vpu_inst *inst, struct vb2_v4l2_buffer *vbuf)\n{\n\tif (!inst->fh.m2m_ctx)\n\t\treturn;\n\tif (vbuf->vb2_buf.state != VB2_BUF_STATE_ACTIVE)\n\t\treturn;\n\tif (vpu_find_buf_by_idx(inst, vbuf->vb2_buf.type, vbuf->vb2_buf.index))\n\t\treturn;\n\tv4l2_m2m_buf_queue(inst->fh.m2m_ctx, vbuf);\n}\n\nstatic void vdec_clear_slots(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct vpu_vb2_buffer *vpu_buf;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vdec->slots); i++) {\n\t\tif (!vdec->slots[i])\n\t\t\tcontinue;\n\n\t\tvpu_buf = vdec->slots[i];\n\t\tvbuf = &vpu_buf->m2m_buf.vb;\n\n\t\tvpu_trace(inst->dev, \"clear slot %d\\n\", i);\n\t\tvdec_response_fs_release(inst, i, vpu_buf->tag);\n\t\tvdec_recycle_buffer(inst, vbuf);\n\t\tvdec->slots[i]->state = VPU_BUF_STATE_IDLE;\n\t\tvdec->slots[i] = NULL;\n\t}\n}\n\nstatic void vdec_event_seq_hdr(struct vpu_inst *inst, struct vpu_dec_codec_info *hdr)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tvpu_inst_lock(inst);\n\tmemcpy(&vdec->codec_info, hdr, sizeof(vdec->codec_info));\n\n\tvpu_trace(inst->dev, \"[%d] %d x %d, crop : (%d, %d) %d x %d, %d, %d\\n\",\n\t\t  inst->id,\n\t\t  vdec->codec_info.decoded_width,\n\t\t  vdec->codec_info.decoded_height,\n\t\t  vdec->codec_info.offset_x,\n\t\t  vdec->codec_info.offset_y,\n\t\t  vdec->codec_info.width,\n\t\t  vdec->codec_info.height,\n\t\t  hdr->num_ref_frms,\n\t\t  hdr->num_dpb_frms);\n\tinst->min_buffer_cap = hdr->num_ref_frms + hdr->num_dpb_frms;\n\tvdec->is_source_changed = vdec_check_source_change(inst);\n\tvdec_init_fmt(inst);\n\tvdec_init_crop(inst);\n\tvdec_init_mbi(inst);\n\tvdec_init_dcp(inst);\n\tif (!vdec->seq_hdr_found) {\n\t\tvdec->seq_tag = vdec->codec_info.tag;\n\t\tif (vdec->is_source_changed) {\n\t\t\tvdec_update_state(inst, VPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE, 0);\n\t\t\tvdec->source_change++;\n\t\t\tvdec_handle_resolution_change(inst);\n\t\t\tvdec->is_source_changed = false;\n\t\t}\n\t}\n\tif (vdec->seq_tag != vdec->codec_info.tag) {\n\t\tvdec_response_fs_request(inst, true);\n\t\tvpu_trace(inst->dev, \"[%d] seq tag change: %d -> %d\\n\",\n\t\t\t  inst->id, vdec->seq_tag, vdec->codec_info.tag);\n\t}\n\tvdec->seq_hdr_found++;\n\tvdec->fixed_fmt = true;\n\tvpu_inst_unlock(inst);\n}\n\nstatic void vdec_event_resolution_change(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tvpu_trace(inst->dev, \"[%d]\\n\", inst->id);\n\tvpu_inst_lock(inst);\n\tvdec->seq_tag = vdec->codec_info.tag;\n\tvdec_clear_fs(&vdec->mbi);\n\tvdec_clear_fs(&vdec->dcp);\n\tvdec_clear_slots(inst);\n\tvdec_init_mbi(inst);\n\tvdec_init_dcp(inst);\n\tif (vdec->is_source_changed) {\n\t\tvdec_update_state(inst, VPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE, 0);\n\t\tvdec->source_change++;\n\t\tvdec_handle_resolution_change(inst);\n\t\tvdec->is_source_changed = false;\n\t}\n\tvpu_inst_unlock(inst);\n}\n\nstatic void vdec_event_req_fs(struct vpu_inst *inst, struct vpu_fs_info *fs)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tif (!fs)\n\t\treturn;\n\n\tvpu_inst_lock(inst);\n\n\tswitch (fs->type) {\n\tcase MEM_RES_FRAME:\n\t\tvdec->req_frame_count++;\n\t\tbreak;\n\tcase MEM_RES_MBI:\n\t\tvdec_request_one_fs(&vdec->mbi);\n\t\tbreak;\n\tcase MEM_RES_DCP:\n\t\tvdec_request_one_fs(&vdec->dcp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tvdec_alloc_fs(inst, &vdec->mbi);\n\tvdec_alloc_fs(inst, &vdec->dcp);\n\n\tvdec_response_fs_request(inst, false);\n\n\tvpu_inst_unlock(inst);\n}\n\nstatic void vdec_evnet_rel_fs(struct vpu_inst *inst, struct vpu_fs_info *fs)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct vpu_vb2_buffer *vpu_buf;\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tif (!fs || fs->id >= ARRAY_SIZE(vdec->slots))\n\t\treturn;\n\tif (fs->type != MEM_RES_FRAME)\n\t\treturn;\n\n\tif (fs->id >= vpu_get_num_buffers(inst, inst->cap_format.type)) {\n\t\tdev_err(inst->dev, \"[%d] invalid fs(%d) to release\\n\", inst->id, fs->id);\n\t\treturn;\n\t}\n\n\tvpu_inst_lock(inst);\n\tvpu_buf = vdec->slots[fs->id];\n\tvdec->slots[fs->id] = NULL;\n\n\tif (!vpu_buf) {\n\t\tdev_dbg(inst->dev, \"[%d] fs[%d] has bee released\\n\", inst->id, fs->id);\n\t\tgoto exit;\n\t}\n\n\tvbuf = &vpu_buf->m2m_buf.vb;\n\tif (vpu_get_buffer_state(vbuf) == VPU_BUF_STATE_DECODED) {\n\t\tdev_dbg(inst->dev, \"[%d] frame skip\\n\", inst->id);\n\t\tvdec->sequence++;\n\t}\n\n\tvdec_response_fs_release(inst, fs->id, vpu_buf->tag);\n\tif (vpu_get_buffer_state(vbuf) != VPU_BUF_STATE_READY)\n\t\tvdec_recycle_buffer(inst, vbuf);\n\n\tvpu_set_buffer_state(vbuf, VPU_BUF_STATE_IDLE);\n\tvpu_process_capture_buffer(inst);\n\nexit:\n\tvpu_inst_unlock(inst);\n}\n\nstatic void vdec_event_eos(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tvpu_trace(inst->dev, \"[%d] input : %d, decoded : %d, display : %d, sequence : %d\\n\",\n\t\t  inst->id,\n\t\t  vdec->params.frame_count,\n\t\t  vdec->decoded_frame_count,\n\t\t  vdec->display_frame_count,\n\t\t  vdec->sequence);\n\tvpu_inst_lock(inst);\n\tvdec->eos_received++;\n\tvdec->fixed_fmt = false;\n\tinst->min_buffer_cap = VDEC_MIN_BUFFER_CAP;\n\tvdec_set_last_buffer_dequeued(inst);\n\tvpu_inst_unlock(inst);\n}\n\nstatic void vdec_event_notify(struct vpu_inst *inst, u32 event, void *data)\n{\n\tswitch (event) {\n\tcase VPU_MSG_ID_SEQ_HDR_FOUND:\n\t\tvdec_event_seq_hdr(inst, data);\n\t\tbreak;\n\tcase VPU_MSG_ID_RES_CHANGE:\n\t\tvdec_event_resolution_change(inst);\n\t\tbreak;\n\tcase VPU_MSG_ID_FRAME_REQ:\n\t\tvdec_event_req_fs(inst, data);\n\t\tbreak;\n\tcase VPU_MSG_ID_FRAME_RELEASE:\n\t\tvdec_evnet_rel_fs(inst, data);\n\t\tbreak;\n\tcase VPU_MSG_ID_PIC_EOS:\n\t\tvdec_event_eos(inst);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int vdec_process_output(struct vpu_inst *inst, struct vb2_buffer *vb)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct vpu_rpc_buffer_desc desc;\n\tu32 free_space;\n\tint ret;\n\n\tvbuf = to_vb2_v4l2_buffer(vb);\n\tdev_dbg(inst->dev, \"[%d] dec output [%d] %d : %ld\\n\",\n\t\tinst->id, vbuf->sequence, vb->index, vb2_get_plane_payload(vb, 0));\n\n\tif (inst->state == VPU_CODEC_STATE_DEINIT)\n\t\treturn -EINVAL;\n\tif (vdec->reset_codec)\n\t\treturn -EINVAL;\n\n\tif (inst->state == VPU_CODEC_STATE_STARTED)\n\t\tvdec_update_state(inst, VPU_CODEC_STATE_ACTIVE, 0);\n\n\tret = vpu_iface_get_stream_buffer_desc(inst, &desc);\n\tif (ret)\n\t\treturn ret;\n\n\tfree_space = vpu_helper_get_free_space(inst);\n\tif (free_space < vb2_get_plane_payload(vb, 0) + 0x40000)\n\t\treturn -ENOMEM;\n\n\tvpu_set_buffer_state(vbuf, VPU_BUF_STATE_INUSE);\n\tret = vpu_iface_input_frame(inst, vb);\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(inst->dev, \"[%d][INPUT  TS]%32lld\\n\", inst->id, vb->timestamp);\n\tvdec->params.frame_count++;\n\n\tif (vdec->drain)\n\t\tvdec_drain(inst);\n\n\treturn 0;\n}\n\nstatic int vdec_process_capture(struct vpu_inst *inst, struct vb2_buffer *vb)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tint ret;\n\n\tif (inst->state == VPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE)\n\t\treturn -EINVAL;\n\tif (vdec->reset_codec)\n\t\treturn -EINVAL;\n\n\tret = vdec_response_frame(inst, vbuf);\n\tif (ret)\n\t\treturn ret;\n\tv4l2_m2m_dst_buf_remove_by_buf(inst->fh.m2m_ctx, vbuf);\n\treturn 0;\n}\n\nstatic void vdec_on_queue_empty(struct vpu_inst *inst, u32 type)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn;\n\n\tvdec_handle_resolution_change(inst);\n\tif (vdec->eos_received)\n\t\tvdec_set_last_buffer_dequeued(inst);\n}\n\nstatic void vdec_abort(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tstruct vpu_rpc_buffer_desc desc;\n\tint ret;\n\n\tvpu_trace(inst->dev, \"[%d] state = %s\\n\", inst->id, vpu_codec_state_name(inst->state));\n\n\tvdec->aborting = true;\n\tvpu_iface_add_scode(inst, SCODE_PADDING_ABORT);\n\tvdec->params.end_flag = 1;\n\tvpu_iface_set_decode_params(inst, &vdec->params, 1);\n\n\tvpu_session_abort(inst);\n\n\tret = vpu_iface_get_stream_buffer_desc(inst, &desc);\n\tif (!ret)\n\t\tvpu_iface_update_stream_buffer(inst, desc.rptr, 1);\n\n\tvpu_session_rst_buf(inst);\n\tvpu_trace(inst->dev, \"[%d] input : %d, decoded : %d, display : %d, sequence : %d\\n\",\n\t\t  inst->id,\n\t\t  vdec->params.frame_count,\n\t\t  vdec->decoded_frame_count,\n\t\t  vdec->display_frame_count,\n\t\t  vdec->sequence);\n\tif (!vdec->seq_hdr_found)\n\t\tvdec->reset_codec = true;\n\tvdec->params.end_flag = 0;\n\tvdec->drain = 0;\n\tvdec->params.frame_count = 0;\n\tvdec->decoded_frame_count = 0;\n\tvdec->display_frame_count = 0;\n\tvdec->sequence = 0;\n\tvdec->aborting = false;\n\tinst->extra_size = 0;\n}\n\nstatic void vdec_stop(struct vpu_inst *inst, bool free)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tvdec_clear_slots(inst);\n\tif (inst->state != VPU_CODEC_STATE_DEINIT)\n\t\tvpu_session_stop(inst);\n\tvdec_clear_fs(&vdec->mbi);\n\tvdec_clear_fs(&vdec->dcp);\n\tif (free) {\n\t\tvpu_free_dma(&vdec->udata);\n\t\tvpu_free_dma(&inst->stream_buffer);\n\t}\n\tvdec_update_state(inst, VPU_CODEC_STATE_DEINIT, 1);\n\tvdec->reset_codec = false;\n}\n\nstatic void vdec_release(struct vpu_inst *inst)\n{\n\tif (inst->id != VPU_INST_NULL_ID)\n\t\tvpu_trace(inst->dev, \"[%d]\\n\", inst->id);\n\tvdec_stop(inst, true);\n}\n\nstatic void vdec_cleanup(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec;\n\n\tif (!inst)\n\t\treturn;\n\n\tvdec = inst->priv;\n\tvfree(vdec);\n\tinst->priv = NULL;\n\tvfree(inst);\n}\n\nstatic void vdec_init_params(struct vdec_t *vdec)\n{\n\tvdec->params.frame_count = 0;\n\tvdec->params.end_flag = 0;\n}\n\nstatic int vdec_start(struct vpu_inst *inst)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tint stream_buffer_size;\n\tint ret;\n\n\tif (inst->state != VPU_CODEC_STATE_DEINIT)\n\t\treturn 0;\n\n\tvpu_trace(inst->dev, \"[%d]\\n\", inst->id);\n\tif (!vdec->udata.virt) {\n\t\tvdec->udata.length = 0x1000;\n\t\tret = vpu_alloc_dma(inst->core, &vdec->udata);\n\t\tif (ret) {\n\t\t\tdev_err(inst->dev, \"[%d] alloc udata fail\\n\", inst->id);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (!inst->stream_buffer.virt) {\n\t\tstream_buffer_size = vpu_iface_get_stream_buffer_size(inst->core);\n\t\tif (stream_buffer_size > 0) {\n\t\t\tinst->stream_buffer.length = stream_buffer_size;\n\t\t\tret = vpu_alloc_dma(inst->core, &inst->stream_buffer);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(inst->dev, \"[%d] alloc stream buffer fail\\n\", inst->id);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tinst->use_stream_buffer = true;\n\t\t}\n\t}\n\n\tif (inst->use_stream_buffer)\n\t\tvpu_iface_config_stream_buffer(inst, &inst->stream_buffer);\n\tvpu_iface_init_instance(inst);\n\tvdec->params.udata.base = vdec->udata.phys;\n\tvdec->params.udata.size = vdec->udata.length;\n\tret = vpu_iface_set_decode_params(inst, &vdec->params, 0);\n\tif (ret) {\n\t\tdev_err(inst->dev, \"[%d] set decode params fail\\n\", inst->id);\n\t\tgoto error;\n\t}\n\n\tvdec_init_params(vdec);\n\tret = vpu_session_start(inst);\n\tif (ret) {\n\t\tdev_err(inst->dev, \"[%d] start fail\\n\", inst->id);\n\t\tgoto error;\n\t}\n\n\tvdec_update_state(inst, VPU_CODEC_STATE_STARTED, 0);\n\n\treturn 0;\nerror:\n\tvpu_free_dma(&vdec->udata);\n\tvpu_free_dma(&inst->stream_buffer);\n\treturn ret;\n}\n\nstatic int vdec_start_session(struct vpu_inst *inst, u32 type)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tint ret = 0;\n\n\tif (V4L2_TYPE_IS_OUTPUT(type)) {\n\t\tif (vdec->reset_codec)\n\t\t\tvdec_stop(inst, false);\n\t\tif (inst->state == VPU_CODEC_STATE_DEINIT) {\n\t\t\tret = vdec_start(inst);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (V4L2_TYPE_IS_OUTPUT(type)) {\n\t\tvdec_update_state(inst, vdec->state, 1);\n\t\tvdec->eos_received = 0;\n\t\tvpu_process_output_buffer(inst);\n\t} else {\n\t\tvdec_cmd_start(inst);\n\t}\n\tif (inst->state == VPU_CODEC_STATE_ACTIVE)\n\t\tvdec_response_fs_request(inst, false);\n\n\treturn ret;\n}\n\nstatic int vdec_stop_session(struct vpu_inst *inst, u32 type)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\n\tif (inst->state == VPU_CODEC_STATE_DEINIT)\n\t\treturn 0;\n\n\tif (V4L2_TYPE_IS_OUTPUT(type)) {\n\t\tvdec_update_state(inst, VPU_CODEC_STATE_SEEK, 0);\n\t\tvdec->drain = 0;\n\t} else {\n\t\tif (inst->state != VPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE) {\n\t\t\tvdec_abort(inst);\n\t\t\tvdec->eos_received = 0;\n\t\t}\n\t\tvdec_clear_slots(inst);\n\t}\n\n\treturn 0;\n}\n\nstatic int vdec_get_debug_info(struct vpu_inst *inst, char *str, u32 size, u32 i)\n{\n\tstruct vdec_t *vdec = inst->priv;\n\tint num = -1;\n\n\tswitch (i) {\n\tcase 0:\n\t\tnum = scnprintf(str, size,\n\t\t\t\t\"req_frame_count = %d\\ninterlaced = %d\\n\",\n\t\t\t\tvdec->req_frame_count,\n\t\t\t\tvdec->codec_info.progressive ? 0 : 1);\n\t\tbreak;\n\tcase 1:\n\t\tnum = scnprintf(str, size,\n\t\t\t\t\"mbi: size = 0x%x request = %d, alloc = %d, response = %d\\n\",\n\t\t\t\tvdec->mbi.size,\n\t\t\t\tvdec->mbi.req_count,\n\t\t\t\tvdec->mbi.count,\n\t\t\t\tvdec->mbi.index);\n\t\tbreak;\n\tcase 2:\n\t\tnum = scnprintf(str, size,\n\t\t\t\t\"dcp: size = 0x%x request = %d, alloc = %d, response = %d\\n\",\n\t\t\t\tvdec->dcp.size,\n\t\t\t\tvdec->dcp.req_count,\n\t\t\t\tvdec->dcp.count,\n\t\t\t\tvdec->dcp.index);\n\t\tbreak;\n\tcase 3:\n\t\tnum = scnprintf(str, size, \"input_frame_count = %d\\n\", vdec->params.frame_count);\n\t\tbreak;\n\tcase 4:\n\t\tnum = scnprintf(str, size, \"decoded_frame_count = %d\\n\", vdec->decoded_frame_count);\n\t\tbreak;\n\tcase 5:\n\t\tnum = scnprintf(str, size, \"display_frame_count = %d\\n\", vdec->display_frame_count);\n\t\tbreak;\n\tcase 6:\n\t\tnum = scnprintf(str, size, \"sequence = %d\\n\", vdec->sequence);\n\t\tbreak;\n\tcase 7:\n\t\tnum = scnprintf(str, size, \"drain = %d, eos = %d, source_change = %d\\n\",\n\t\t\t\tvdec->drain, vdec->eos_received, vdec->source_change);\n\t\tbreak;\n\tcase 8:\n\t\tnum = scnprintf(str, size, \"fps = %d/%d\\n\",\n\t\t\t\tvdec->codec_info.frame_rate.numerator,\n\t\t\t\tvdec->codec_info.frame_rate.denominator);\n\t\tbreak;\n\tcase 9:\n\t\tnum = scnprintf(str, size, \"colorspace: %d, %d, %d, %d (%d)\\n\",\n\t\t\t\tvdec->codec_info.color_primaries,\n\t\t\t\tvdec->codec_info.transfer_chars,\n\t\t\t\tvdec->codec_info.matrix_coeffs,\n\t\t\t\tvdec->codec_info.full_range,\n\t\t\t\tvdec->codec_info.vui_present);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn num;\n}\n\nstatic struct vpu_inst_ops vdec_inst_ops = {\n\t.ctrl_init = vdec_ctrl_init,\n\t.check_ready = vdec_check_ready,\n\t.buf_done = vdec_buf_done,\n\t.get_one_frame = vdec_frame_decoded,\n\t.stop_done = vdec_stop_done,\n\t.event_notify = vdec_event_notify,\n\t.release = vdec_release,\n\t.cleanup = vdec_cleanup,\n\t.start = vdec_start_session,\n\t.stop = vdec_stop_session,\n\t.process_output = vdec_process_output,\n\t.process_capture = vdec_process_capture,\n\t.on_queue_empty = vdec_on_queue_empty,\n\t.get_debug_info = vdec_get_debug_info,\n\t.wait_prepare = vpu_inst_unlock,\n\t.wait_finish = vpu_inst_lock,\n};\n\nstatic void vdec_init(struct file *file)\n{\n\tstruct vpu_inst *inst = to_inst(file);\n\tstruct v4l2_format f;\n\n\tmemset(&f, 0, sizeof(f));\n\tf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tf.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H264;\n\tf.fmt.pix_mp.width = 1280;\n\tf.fmt.pix_mp.height = 720;\n\tf.fmt.pix_mp.field = V4L2_FIELD_NONE;\n\tvdec_s_fmt(file, &inst->fh, &f);\n\n\tmemset(&f, 0, sizeof(f));\n\tf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tf.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M_8L128;\n\tf.fmt.pix_mp.width = 1280;\n\tf.fmt.pix_mp.height = 720;\n\tf.fmt.pix_mp.field = V4L2_FIELD_NONE;\n\tvdec_s_fmt(file, &inst->fh, &f);\n}\n\nstatic int vdec_open(struct file *file)\n{\n\tstruct vpu_inst *inst;\n\tstruct vdec_t *vdec;\n\tint ret;\n\n\tinst = vzalloc(sizeof(*inst));\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tvdec = vzalloc(sizeof(*vdec));\n\tif (!vdec) {\n\t\tvfree(inst);\n\t\treturn -ENOMEM;\n\t}\n\n\tinst->ops = &vdec_inst_ops;\n\tinst->formats = vdec_formats;\n\tinst->type = VPU_CORE_TYPE_DEC;\n\tinst->priv = vdec;\n\n\tret = vpu_v4l2_open(file, inst);\n\tif (ret)\n\t\treturn ret;\n\n\tvdec->fixed_fmt = false;\n\tvdec->state = VPU_CODEC_STATE_ACTIVE;\n\tinst->min_buffer_cap = VDEC_MIN_BUFFER_CAP;\n\tinst->min_buffer_out = VDEC_MIN_BUFFER_OUT;\n\tvdec_init(file);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations vdec_fops = {\n\t.owner = THIS_MODULE,\n\t.open = vdec_open,\n\t.release = vpu_v4l2_close,\n\t.unlocked_ioctl = video_ioctl2,\n\t.poll = v4l2_m2m_fop_poll,\n\t.mmap = v4l2_m2m_fop_mmap,\n};\n\nconst struct v4l2_ioctl_ops *vdec_get_ioctl_ops(void)\n{\n\treturn &vdec_ioctl_ops;\n}\n\nconst struct v4l2_file_operations *vdec_get_fops(void)\n{\n\treturn &vdec_fops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}