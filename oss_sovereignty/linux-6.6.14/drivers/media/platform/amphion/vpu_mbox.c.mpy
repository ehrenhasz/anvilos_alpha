{
  "module_name": "vpu_mbox.c",
  "hash_id": "b3958f67158ae5b9143be54d38fea502961bf385ac149623bd43a2fe1647643a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/amphion/vpu_mbox.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interconnect.h>\n#include <linux/ioctl.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include \"vpu.h\"\n#include \"vpu_mbox.h\"\n#include \"vpu_msgs.h\"\n\nstatic void vpu_mbox_rx_callback(struct mbox_client *cl, void *msg)\n{\n\tstruct vpu_mbox *rx = container_of(cl, struct vpu_mbox, cl);\n\tstruct vpu_core *core = container_of(rx, struct vpu_core, rx);\n\n\tvpu_isr(core, *(u32 *)msg);\n}\n\nstatic int vpu_mbox_request_channel(struct device *dev, struct vpu_mbox *mbox)\n{\n\tstruct mbox_chan *ch;\n\tstruct mbox_client *cl;\n\n\tif (!dev || !mbox)\n\t\treturn -EINVAL;\n\tif (mbox->ch)\n\t\treturn 0;\n\n\tcl = &mbox->cl;\n\tcl->dev = dev;\n\tif (mbox->block) {\n\t\tcl->tx_block = true;\n\t\tcl->tx_tout = 1000;\n\t} else {\n\t\tcl->tx_block = false;\n\t}\n\tcl->knows_txdone = false;\n\tcl->rx_callback = vpu_mbox_rx_callback;\n\n\tch = mbox_request_channel_byname(cl, mbox->name);\n\tif (IS_ERR(ch))\n\t\treturn dev_err_probe(dev, PTR_ERR(ch),\n\t\t\t\t     \"Failed to request mbox chan %s\\n\",\n\t\t\t\t     mbox->name);\n\n\tmbox->ch = ch;\n\treturn 0;\n}\n\nint vpu_mbox_init(struct vpu_core *core)\n{\n\tscnprintf(core->tx_type.name, sizeof(core->tx_type.name) - 1, \"tx0\");\n\tcore->tx_type.block = true;\n\n\tscnprintf(core->tx_data.name, sizeof(core->tx_data.name) - 1, \"tx1\");\n\tcore->tx_data.block = false;\n\n\tscnprintf(core->rx.name, sizeof(core->rx.name) - 1, \"rx\");\n\tcore->rx.block = true;\n\n\treturn 0;\n}\n\nint vpu_mbox_request(struct vpu_core *core)\n{\n\tint ret;\n\n\tret = vpu_mbox_request_channel(core->dev, &core->tx_type);\n\tif (ret)\n\t\tgoto error;\n\tret = vpu_mbox_request_channel(core->dev, &core->tx_data);\n\tif (ret)\n\t\tgoto error;\n\tret = vpu_mbox_request_channel(core->dev, &core->rx);\n\tif (ret)\n\t\tgoto error;\n\n\tdev_dbg(core->dev, \"%s request mbox\\n\", vpu_core_type_desc(core->type));\n\treturn 0;\nerror:\n\tvpu_mbox_free(core);\n\treturn ret;\n}\n\nvoid vpu_mbox_free(struct vpu_core *core)\n{\n\tmbox_free_channel(core->tx_type.ch);\n\tmbox_free_channel(core->tx_data.ch);\n\tmbox_free_channel(core->rx.ch);\n\tcore->tx_type.ch = NULL;\n\tcore->tx_data.ch = NULL;\n\tcore->rx.ch = NULL;\n\tdev_dbg(core->dev, \"%s free mbox\\n\", vpu_core_type_desc(core->type));\n}\n\nvoid vpu_mbox_send_type(struct vpu_core *core, u32 type)\n{\n\tmbox_send_message(core->tx_type.ch, &type);\n}\n\nvoid vpu_mbox_send_msg(struct vpu_core *core, u32 type, u32 data)\n{\n\tmbox_send_message(core->tx_data.ch, &data);\n\tmbox_send_message(core->tx_type.ch, &type);\n}\n\nvoid vpu_mbox_enable_rx(struct vpu_dev *dev)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}