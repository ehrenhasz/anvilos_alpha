{
  "module_name": "vpu.h",
  "hash_id": "3ed1f73ea29b90293bf9a4baafb1c273a6baa7544817d81e73786fb2881022bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/amphion/vpu.h",
  "human_readable_source": " \n \n\n#ifndef _AMPHION_VPU_H\n#define _AMPHION_VPU_H\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-mem2mem.h>\n#include <linux/mailbox_client.h>\n#include <linux/mailbox_controller.h>\n#include <linux/kfifo.h>\n\n#define VPU_TIMEOUT_WAKEUP\tmsecs_to_jiffies(200)\n#define VPU_TIMEOUT\t\tmsecs_to_jiffies(1000)\n#define VPU_INST_NULL_ID\t(-1L)\n#define VPU_MSG_BUFFER_SIZE\t(8192)\n\nenum imx_plat_type {\n\tIMX8QXP = 0,\n\tIMX8QM  = 1,\n\tIMX8DM,\n\tIMX8DX,\n\tPLAT_TYPE_RESERVED\n};\n\nenum vpu_core_type {\n\tVPU_CORE_TYPE_ENC = 0,\n\tVPU_CORE_TYPE_DEC = 0x10,\n};\n\nstruct vpu_dev;\nstruct vpu_resources {\n\tenum imx_plat_type plat_type;\n\tu32 mreg_base;\n\tint (*setup)(struct vpu_dev *vpu);\n\tint (*setup_encoder)(struct vpu_dev *vpu);\n\tint (*setup_decoder)(struct vpu_dev *vpu);\n\tint (*reset)(struct vpu_dev *vpu);\n};\n\nstruct vpu_buffer {\n\tvoid *virt;\n\tdma_addr_t phys;\n\tu32 length;\n\tu32 bytesused;\n\tstruct device *dev;\n};\n\nstruct vpu_func {\n\tstruct video_device *vfd;\n\tstruct v4l2_m2m_dev *m2m_dev;\n\tenum vpu_core_type type;\n\tint function;\n};\n\nstruct vpu_dev {\n\tvoid __iomem *base;\n\tstruct platform_device *pdev;\n\tstruct device *dev;\n\tstruct mutex lock;  \n\tconst struct vpu_resources *res;\n\tstruct list_head cores;\n\n\tstruct v4l2_device v4l2_dev;\n\tstruct vpu_func encoder;\n\tstruct vpu_func decoder;\n\tstruct media_device mdev;\n\n\tstruct delayed_work watchdog_work;\n\tvoid (*get_vpu)(struct vpu_dev *vpu);\n\tvoid (*put_vpu)(struct vpu_dev *vpu);\n\tvoid (*get_enc)(struct vpu_dev *vpu);\n\tvoid (*put_enc)(struct vpu_dev *vpu);\n\tvoid (*get_dec)(struct vpu_dev *vpu);\n\tvoid (*put_dec)(struct vpu_dev *vpu);\n\tatomic_t ref_vpu;\n\tatomic_t ref_enc;\n\tatomic_t ref_dec;\n\n\tstruct dentry *debugfs;\n};\n\nstruct vpu_format {\n\tu32 pixfmt;\n\tu32 mem_planes;\n\tu32 comp_planes;\n\tu32 type;\n\tu32 flags;\n\tu32 width;\n\tu32 height;\n\tu32 sizeimage[VIDEO_MAX_PLANES];\n\tu32 bytesperline[VIDEO_MAX_PLANES];\n\tu32 field;\n\tu32 sibling;\n};\n\nstruct vpu_core_resources {\n\tenum vpu_core_type type;\n\tconst char *fwname;\n\tu32 stride;\n\tu32 max_width;\n\tu32 min_width;\n\tu32 step_width;\n\tu32 max_height;\n\tu32 min_height;\n\tu32 step_height;\n\tu32 rpc_size;\n\tu32 fwlog_size;\n\tu32 act_size;\n};\n\nstruct vpu_mbox {\n\tchar name[20];\n\tstruct mbox_client cl;\n\tstruct mbox_chan *ch;\n\tbool block;\n};\n\nenum vpu_core_state {\n\tVPU_CORE_DEINIT = 0,\n\tVPU_CORE_ACTIVE,\n\tVPU_CORE_HANG\n};\n\nstruct vpu_core {\n\tvoid __iomem *base;\n\tstruct platform_device *pdev;\n\tstruct device *dev;\n\tstruct device *parent;\n\tstruct device *pd;\n\tstruct device_link *pd_link;\n\tstruct mutex lock;      \n\tstruct mutex cmd_lock;  \n\tstruct list_head list;\n\tenum vpu_core_type type;\n\tint id;\n\tconst struct vpu_core_resources *res;\n\tunsigned long instance_mask;\n\tu32 supported_instance_count;\n\tunsigned long hang_mask;\n\tu32 request_count;\n\tstruct list_head instances;\n\tenum vpu_core_state state;\n\tu32 fw_version;\n\n\tstruct vpu_buffer fw;\n\tstruct vpu_buffer rpc;\n\tstruct vpu_buffer log;\n\tstruct vpu_buffer act;\n\n\tstruct vpu_mbox tx_type;\n\tstruct vpu_mbox tx_data;\n\tstruct vpu_mbox rx;\n\tunsigned long cmd_seq;\n\n\twait_queue_head_t ack_wq;\n\tstruct completion cmp;\n\tstruct workqueue_struct *workqueue;\n\tstruct work_struct msg_work;\n\tstruct delayed_work msg_delayed_work;\n\tstruct kfifo msg_fifo;\n\tvoid *msg_buffer;\n\tunsigned int msg_buffer_size;\n\n\tstruct vpu_dev *vpu;\n\tvoid *iface;\n\n\tstruct dentry *debugfs;\n\tstruct dentry *debugfs_fwlog;\n};\n\nenum vpu_codec_state {\n\tVPU_CODEC_STATE_DEINIT = 1,\n\tVPU_CODEC_STATE_CONFIGURED,\n\tVPU_CODEC_STATE_START,\n\tVPU_CODEC_STATE_STARTED,\n\tVPU_CODEC_STATE_ACTIVE,\n\tVPU_CODEC_STATE_SEEK,\n\tVPU_CODEC_STATE_STOP,\n\tVPU_CODEC_STATE_DRAIN,\n\tVPU_CODEC_STATE_DYAMIC_RESOLUTION_CHANGE,\n};\n\nstruct vpu_frame_info {\n\tu32 type;\n\tu32 id;\n\tu32 sequence;\n\tu32 luma;\n\tu32 chroma_u;\n\tu32 chroma_v;\n\tu32 data_offset;\n\tu32 flags;\n\tu32 skipped;\n\ts64 timestamp;\n};\n\nstruct vpu_inst;\nstruct vpu_inst_ops {\n\tint (*ctrl_init)(struct vpu_inst *inst);\n\tint (*start)(struct vpu_inst *inst, u32 type);\n\tint (*stop)(struct vpu_inst *inst, u32 type);\n\tint (*abort)(struct vpu_inst *inst);\n\tbool (*check_ready)(struct vpu_inst *inst, unsigned int type);\n\tvoid (*buf_done)(struct vpu_inst *inst, struct vpu_frame_info *frame);\n\tvoid (*event_notify)(struct vpu_inst *inst, u32 event, void *data);\n\tvoid (*release)(struct vpu_inst *inst);\n\tvoid (*cleanup)(struct vpu_inst *inst);\n\tvoid (*mem_request)(struct vpu_inst *inst,\n\t\t\t    u32 enc_frame_size,\n\t\t\t    u32 enc_frame_num,\n\t\t\t    u32 ref_frame_size,\n\t\t\t    u32 ref_frame_num,\n\t\t\t    u32 act_frame_size,\n\t\t\t    u32 act_frame_num);\n\tvoid (*input_done)(struct vpu_inst *inst);\n\tvoid (*stop_done)(struct vpu_inst *inst);\n\tint (*process_output)(struct vpu_inst *inst, struct vb2_buffer *vb);\n\tint (*process_capture)(struct vpu_inst *inst, struct vb2_buffer *vb);\n\tint (*get_one_frame)(struct vpu_inst *inst, void *info);\n\tvoid (*on_queue_empty)(struct vpu_inst *inst, u32 type);\n\tint (*get_debug_info)(struct vpu_inst *inst, char *str, u32 size, u32 i);\n\tvoid (*wait_prepare)(struct vpu_inst *inst);\n\tvoid (*wait_finish)(struct vpu_inst *inst);\n};\n\nstruct vpu_inst {\n\tstruct list_head list;\n\tstruct mutex lock;  \n\tstruct vpu_dev *vpu;\n\tstruct vpu_core *core;\n\tstruct device *dev;\n\tint id;\n\n\tstruct v4l2_fh fh;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tatomic_t ref_count;\n\tint (*release)(struct vpu_inst *inst);\n\n\tenum vpu_codec_state state;\n\tenum vpu_core_type type;\n\n\tstruct workqueue_struct *workqueue;\n\tstruct work_struct msg_work;\n\tstruct kfifo msg_fifo;\n\tu8 msg_buffer[VPU_MSG_BUFFER_SIZE];\n\n\tstruct vpu_buffer stream_buffer;\n\tbool use_stream_buffer;\n\tstruct vpu_buffer act;\n\n\tstruct list_head cmd_q;\n\tvoid *pending;\n\n\tstruct vpu_inst_ops *ops;\n\tconst struct vpu_format *formats;\n\tstruct vpu_format out_format;\n\tstruct vpu_format cap_format;\n\tu32 min_buffer_cap;\n\tu32 min_buffer_out;\n\tu32 total_input_count;\n\n\tstruct v4l2_rect crop;\n\tu32 colorspace;\n\tu8 ycbcr_enc;\n\tu8 quantization;\n\tu8 xfer_func;\n\tu32 sequence;\n\tu32 extra_size;\n\n\tu32 flows[16];\n\tu32 flow_idx;\n\n\tpid_t pid;\n\tpid_t tgid;\n\tstruct dentry *debugfs;\n\n\tvoid *priv;\n};\n\n#define call_vop(inst, op, args...)\t\t\t\t\t\\\n\t((inst)->ops->op ? (inst)->ops->op(inst, ##args) : 0)\t\t\\\n\n#define call_void_vop(inst, op, args...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((inst)->ops->op)\t\t\t\t\t\\\n\t\t\t(inst)->ops->op(inst, ##args);\t\t\t\t\\\n\t} while (0)\n\nenum {\n\tVPU_BUF_STATE_IDLE = 0,\n\tVPU_BUF_STATE_INUSE,\n\tVPU_BUF_STATE_DECODED,\n\tVPU_BUF_STATE_READY,\n\tVPU_BUF_STATE_SKIP,\n\tVPU_BUF_STATE_ERROR\n};\n\nstruct vpu_vb2_buffer {\n\tstruct v4l2_m2m_buffer m2m_buf;\n\tdma_addr_t luma;\n\tdma_addr_t chroma_u;\n\tdma_addr_t chroma_v;\n\tunsigned int state;\n\tu32 tag;\n};\n\nvoid vpu_writel(struct vpu_dev *vpu, u32 reg, u32 val);\nu32 vpu_readl(struct vpu_dev *vpu, u32 reg);\n\nstatic inline struct vpu_vb2_buffer *to_vpu_vb2_buffer(struct vb2_v4l2_buffer *vbuf)\n{\n\tstruct v4l2_m2m_buffer *m2m_buf = container_of(vbuf, struct v4l2_m2m_buffer, vb);\n\n\treturn container_of(m2m_buf, struct vpu_vb2_buffer, m2m_buf);\n}\n\nstatic inline const char *vpu_core_type_desc(enum vpu_core_type type)\n{\n\treturn type == VPU_CORE_TYPE_ENC ? \"encoder\" : \"decoder\";\n}\n\nstatic inline struct vpu_inst *to_inst(struct file *filp)\n{\n\treturn container_of(filp->private_data, struct vpu_inst, fh);\n}\n\n#define ctrl_to_inst(ctrl)\t\\\n\tcontainer_of((ctrl)->handler, struct vpu_inst, ctrl_handler)\n\nconst struct v4l2_ioctl_ops *venc_get_ioctl_ops(void);\nconst struct v4l2_file_operations *venc_get_fops(void);\nconst struct v4l2_ioctl_ops *vdec_get_ioctl_ops(void);\nconst struct v4l2_file_operations *vdec_get_fops(void);\n\nint vpu_add_func(struct vpu_dev *vpu, struct vpu_func *func);\nvoid vpu_remove_func(struct vpu_func *func);\n\nstruct vpu_inst *vpu_inst_get(struct vpu_inst *inst);\nvoid vpu_inst_put(struct vpu_inst *inst);\nstruct vpu_core *vpu_request_core(struct vpu_dev *vpu, enum vpu_core_type type);\nvoid vpu_release_core(struct vpu_core *core);\nint vpu_inst_register(struct vpu_inst *inst);\nint vpu_inst_unregister(struct vpu_inst *inst);\nconst struct vpu_core_resources *vpu_get_resource(struct vpu_inst *inst);\n\nint vpu_inst_create_dbgfs_file(struct vpu_inst *inst);\nint vpu_inst_remove_dbgfs_file(struct vpu_inst *inst);\nint vpu_core_create_dbgfs_file(struct vpu_core *core);\nint vpu_core_remove_dbgfs_file(struct vpu_core *core);\nvoid vpu_inst_record_flow(struct vpu_inst *inst, u32 flow);\n\nint vpu_core_driver_init(void);\nvoid vpu_core_driver_exit(void);\n\nconst char *vpu_id_name(u32 id);\nconst char *vpu_codec_state_name(enum vpu_codec_state state);\n\nextern bool debug;\n#define vpu_trace(dev, fmt, arg...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (debug)\t\t\t\t\t\t\\\n\t\t\tdev_info(dev, \"%s: \" fmt, __func__, ## arg);\t\\\n\t} while (0)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}