{
  "module_name": "vpu_msgs.c",
  "hash_id": "e87205e5ca15f28b605cac649c5e1db500364c2e3c6522343e8fc2c3d41f9d87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/amphion/vpu_msgs.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interconnect.h>\n#include <linux/ioctl.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include \"vpu.h\"\n#include \"vpu_core.h\"\n#include \"vpu_rpc.h\"\n#include \"vpu_mbox.h\"\n#include \"vpu_defs.h\"\n#include \"vpu_cmds.h\"\n#include \"vpu_msgs.h\"\n#include \"vpu_v4l2.h\"\n\n#define VPU_PKT_HEADER_LENGTH\t\t3\n\nstruct vpu_msg_handler {\n\tu32 id;\n\tvoid (*done)(struct vpu_inst *inst, struct vpu_rpc_event *pkt);\n\tu32 is_str;\n};\n\nstatic void vpu_session_handle_start_done(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tvpu_trace(inst->dev, \"[%d]\\n\", inst->id);\n}\n\nstatic void vpu_session_handle_mem_request(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tstruct vpu_pkt_mem_req_data req_data = { 0 };\n\n\tvpu_iface_unpack_msg_data(inst->core, pkt, (void *)&req_data);\n\tvpu_trace(inst->dev, \"[%d] %d:%d %d:%d %d:%d\\n\",\n\t\t  inst->id,\n\t\t  req_data.enc_frame_size,\n\t\t  req_data.enc_frame_num,\n\t\t  req_data.ref_frame_size,\n\t\t  req_data.ref_frame_num,\n\t\t  req_data.act_buf_size,\n\t\t  req_data.act_buf_num);\n\tvpu_inst_lock(inst);\n\tcall_void_vop(inst, mem_request,\n\t\t      req_data.enc_frame_size,\n\t\t      req_data.enc_frame_num,\n\t\t      req_data.ref_frame_size,\n\t\t      req_data.ref_frame_num,\n\t\t      req_data.act_buf_size,\n\t\t      req_data.act_buf_num);\n\tvpu_inst_unlock(inst);\n}\n\nstatic void vpu_session_handle_stop_done(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tvpu_trace(inst->dev, \"[%d]\\n\", inst->id);\n\n\tcall_void_vop(inst, stop_done);\n}\n\nstatic void vpu_session_handle_seq_hdr(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tstruct vpu_dec_codec_info info;\n\tconst struct vpu_core_resources *res;\n\n\tmemset(&info, 0, sizeof(info));\n\tres = vpu_get_resource(inst);\n\tinfo.stride = res ? res->stride : 1;\n\tvpu_iface_unpack_msg_data(inst->core, pkt, (void *)&info);\n\tcall_void_vop(inst, event_notify, VPU_MSG_ID_SEQ_HDR_FOUND, &info);\n}\n\nstatic void vpu_session_handle_resolution_change(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tcall_void_vop(inst, event_notify, VPU_MSG_ID_RES_CHANGE, NULL);\n}\n\nstatic void vpu_session_handle_enc_frame_done(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tstruct vpu_enc_pic_info info = { 0 };\n\n\tvpu_iface_unpack_msg_data(inst->core, pkt, (void *)&info);\n\tdev_dbg(inst->dev, \"[%d] frame id = %d, wptr = 0x%x, size = %d\\n\",\n\t\tinst->id, info.frame_id, info.wptr, info.frame_size);\n\tcall_void_vop(inst, get_one_frame, &info);\n}\n\nstatic void vpu_session_handle_frame_request(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tstruct vpu_fs_info fs = { 0 };\n\n\tvpu_iface_unpack_msg_data(inst->core, pkt, &fs);\n\tcall_void_vop(inst, event_notify, VPU_MSG_ID_FRAME_REQ, &fs);\n}\n\nstatic void vpu_session_handle_frame_release(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tif (inst->core->type == VPU_CORE_TYPE_ENC) {\n\t\tstruct vpu_frame_info info;\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tvpu_iface_unpack_msg_data(inst->core, pkt, (void *)&info.sequence);\n\t\tdev_dbg(inst->dev, \"[%d] %d\\n\", inst->id, info.sequence);\n\t\tinfo.type = inst->out_format.type;\n\t\tcall_void_vop(inst, buf_done, &info);\n\t} else if (inst->core->type == VPU_CORE_TYPE_DEC) {\n\t\tstruct vpu_fs_info fs = { 0 };\n\n\t\tvpu_iface_unpack_msg_data(inst->core, pkt, &fs);\n\t\tcall_void_vop(inst, event_notify, VPU_MSG_ID_FRAME_RELEASE, &fs);\n\t}\n}\n\nstatic void vpu_session_handle_input_done(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tdev_dbg(inst->dev, \"[%d]\\n\", inst->id);\n\tcall_void_vop(inst, input_done);\n}\n\nstatic void vpu_session_handle_pic_decoded(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tstruct vpu_dec_pic_info info = { 0 };\n\n\tvpu_iface_unpack_msg_data(inst->core, pkt, (void *)&info);\n\tcall_void_vop(inst, get_one_frame, &info);\n}\n\nstatic void vpu_session_handle_pic_done(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tstruct vpu_dec_pic_info info = { 0 };\n\tstruct vpu_frame_info frame;\n\n\tmemset(&frame, 0, sizeof(frame));\n\tvpu_iface_unpack_msg_data(inst->core, pkt, (void *)&info);\n\tif (inst->core->type == VPU_CORE_TYPE_DEC)\n\t\tframe.type = inst->cap_format.type;\n\tframe.id = info.id;\n\tframe.luma = info.luma;\n\tframe.skipped = info.skipped;\n\tframe.timestamp = info.timestamp;\n\n\tcall_void_vop(inst, buf_done, &frame);\n}\n\nstatic void vpu_session_handle_eos(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tcall_void_vop(inst, event_notify, VPU_MSG_ID_PIC_EOS, NULL);\n}\n\nstatic void vpu_session_handle_error(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tchar *str = (char *)pkt->data;\n\n\tif (*str)\n\t\tdev_err(inst->dev, \"instance %d firmware error : %s\\n\", inst->id, str);\n\telse\n\t\tdev_err(inst->dev, \"instance %d is unsupported stream\\n\", inst->id);\n\tcall_void_vop(inst, event_notify, VPU_MSG_ID_UNSUPPORTED, NULL);\n\tvpu_v4l2_set_error(inst);\n}\n\nstatic void vpu_session_handle_firmware_xcpt(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tchar *str = (char *)pkt->data;\n\n\tdev_err(inst->dev, \"%s firmware xcpt: %s\\n\",\n\t\tvpu_core_type_desc(inst->core->type), str);\n\tcall_void_vop(inst, event_notify, VPU_MSG_ID_FIRMWARE_XCPT, NULL);\n\tset_bit(inst->id, &inst->core->hang_mask);\n\tvpu_v4l2_set_error(inst);\n}\n\nstatic void vpu_session_handle_pic_skipped(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tvpu_inst_lock(inst);\n\tvpu_skip_frame(inst, 1);\n\tvpu_inst_unlock(inst);\n}\n\nstatic void vpu_session_handle_dbg_msg(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tchar *str = (char *)pkt->data;\n\n\tif (*str)\n\t\tdev_info(inst->dev, \"instance %d firmware dbg msg : %s\\n\", inst->id, str);\n}\n\nstatic void vpu_terminate_string_msg(struct vpu_rpc_event *pkt)\n{\n\tif (pkt->hdr.num == ARRAY_SIZE(pkt->data))\n\t\tpkt->hdr.num--;\n\tpkt->data[pkt->hdr.num] = 0;\n}\n\nstatic struct vpu_msg_handler handlers[] = {\n\t{VPU_MSG_ID_START_DONE, vpu_session_handle_start_done},\n\t{VPU_MSG_ID_STOP_DONE, vpu_session_handle_stop_done},\n\t{VPU_MSG_ID_MEM_REQUEST, vpu_session_handle_mem_request},\n\t{VPU_MSG_ID_SEQ_HDR_FOUND, vpu_session_handle_seq_hdr},\n\t{VPU_MSG_ID_RES_CHANGE, vpu_session_handle_resolution_change},\n\t{VPU_MSG_ID_FRAME_INPUT_DONE, vpu_session_handle_input_done},\n\t{VPU_MSG_ID_FRAME_REQ, vpu_session_handle_frame_request},\n\t{VPU_MSG_ID_FRAME_RELEASE, vpu_session_handle_frame_release},\n\t{VPU_MSG_ID_ENC_DONE, vpu_session_handle_enc_frame_done},\n\t{VPU_MSG_ID_PIC_DECODED, vpu_session_handle_pic_decoded},\n\t{VPU_MSG_ID_DEC_DONE, vpu_session_handle_pic_done},\n\t{VPU_MSG_ID_PIC_EOS, vpu_session_handle_eos},\n\t{VPU_MSG_ID_UNSUPPORTED, vpu_session_handle_error, true},\n\t{VPU_MSG_ID_FIRMWARE_XCPT, vpu_session_handle_firmware_xcpt, true},\n\t{VPU_MSG_ID_PIC_SKIPPED, vpu_session_handle_pic_skipped},\n\t{VPU_MSG_ID_DBG_MSG, vpu_session_handle_dbg_msg, true},\n};\n\nstatic int vpu_session_handle_msg(struct vpu_inst *inst, struct vpu_rpc_event *msg)\n{\n\tint ret;\n\tu32 msg_id;\n\tstruct vpu_msg_handler *handler = NULL;\n\tunsigned int i;\n\n\tret = vpu_iface_convert_msg_id(inst->core, msg->hdr.id);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmsg_id = ret;\n\tdev_dbg(inst->dev, \"[%d] receive event(%s)\\n\", inst->id, vpu_id_name(msg_id));\n\n\tfor (i = 0; i < ARRAY_SIZE(handlers); i++) {\n\t\tif (handlers[i].id == msg_id) {\n\t\t\thandler = &handlers[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (handler) {\n\t\tif (handler->is_str)\n\t\t\tvpu_terminate_string_msg(msg);\n\t\tif (handler->done)\n\t\t\thandler->done(inst, msg);\n\t}\n\n\tvpu_response_cmd(inst, msg_id, 1);\n\n\treturn 0;\n}\n\nstatic bool vpu_inst_receive_msg(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tunsigned long bytes = sizeof(struct vpu_rpc_event_header);\n\tu32 ret;\n\n\tmemset(pkt, 0, sizeof(*pkt));\n\tif (kfifo_len(&inst->msg_fifo) < bytes)\n\t\treturn false;\n\n\tret = kfifo_out(&inst->msg_fifo, pkt, bytes);\n\tif (ret != bytes)\n\t\treturn false;\n\n\tif (pkt->hdr.num > 0) {\n\t\tbytes = pkt->hdr.num * sizeof(u32);\n\t\tret = kfifo_out(&inst->msg_fifo, pkt->data, bytes);\n\t\tif (ret != bytes)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid vpu_inst_run_work(struct work_struct *work)\n{\n\tstruct vpu_inst *inst = container_of(work, struct vpu_inst, msg_work);\n\tstruct vpu_rpc_event pkt;\n\n\twhile (vpu_inst_receive_msg(inst, &pkt))\n\t\tvpu_session_handle_msg(inst, &pkt);\n}\n\nstatic void vpu_inst_handle_msg(struct vpu_inst *inst, struct vpu_rpc_event *pkt)\n{\n\tunsigned long bytes;\n\tu32 id = pkt->hdr.id;\n\tint ret;\n\n\tif (!inst->workqueue)\n\t\treturn;\n\n\tbytes = sizeof(pkt->hdr) + pkt->hdr.num * sizeof(u32);\n\tret = kfifo_in(&inst->msg_fifo, pkt, bytes);\n\tif (ret != bytes)\n\t\tdev_err(inst->dev, \"[%d:%d]overflow: %d\\n\", inst->core->id, inst->id, id);\n\tqueue_work(inst->workqueue, &inst->msg_work);\n}\n\nstatic int vpu_handle_msg(struct vpu_core *core)\n{\n\tstruct vpu_rpc_event pkt;\n\tstruct vpu_inst *inst;\n\tint ret;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\twhile (!vpu_iface_receive_msg(core, &pkt)) {\n\t\tdev_dbg(core->dev, \"event index = %d, id = %d, num = %d\\n\",\n\t\t\tpkt.hdr.index, pkt.hdr.id, pkt.hdr.num);\n\n\t\tret = vpu_iface_convert_msg_id(core, pkt.hdr.id);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tinst = vpu_core_find_instance(core, pkt.hdr.index);\n\t\tif (inst) {\n\t\t\tvpu_response_cmd(inst, ret, 0);\n\t\t\tmutex_lock(&core->cmd_lock);\n\t\t\tvpu_inst_record_flow(inst, ret);\n\t\t\tmutex_unlock(&core->cmd_lock);\n\n\t\t\tvpu_inst_handle_msg(inst, &pkt);\n\t\t\tvpu_inst_put(inst);\n\t\t}\n\t\tmemset(&pkt, 0, sizeof(pkt));\n\t}\n\n\treturn 0;\n}\n\nstatic int vpu_isr_thread(struct vpu_core *core, u32 irq_code)\n{\n\tdev_dbg(core->dev, \"irq code = 0x%x\\n\", irq_code);\n\tswitch (irq_code) {\n\tcase VPU_IRQ_CODE_SYNC:\n\t\tvpu_mbox_send_msg(core, PRC_BUF_OFFSET, core->rpc.phys - core->fw.phys);\n\t\tvpu_mbox_send_msg(core, BOOT_ADDRESS, core->fw.phys);\n\t\tvpu_mbox_send_msg(core, INIT_DONE, 2);\n\t\tbreak;\n\tcase VPU_IRQ_CODE_BOOT_DONE:\n\t\tbreak;\n\tcase VPU_IRQ_CODE_SNAPSHOT_DONE:\n\t\tbreak;\n\tdefault:\n\t\tvpu_handle_msg(core);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void vpu_core_run_msg_work(struct vpu_core *core)\n{\n\tconst unsigned int SIZE = sizeof(u32);\n\n\twhile (kfifo_len(&core->msg_fifo) >= SIZE) {\n\t\tu32 data = 0;\n\n\t\tif (kfifo_out(&core->msg_fifo, &data, SIZE) == SIZE)\n\t\t\tvpu_isr_thread(core, data);\n\t}\n}\n\nvoid vpu_msg_run_work(struct work_struct *work)\n{\n\tstruct vpu_core *core = container_of(work, struct vpu_core, msg_work);\n\tunsigned long delay = msecs_to_jiffies(10);\n\n\tvpu_core_run_msg_work(core);\n\tqueue_delayed_work(core->workqueue, &core->msg_delayed_work, delay);\n}\n\nvoid vpu_msg_delayed_work(struct work_struct *work)\n{\n\tstruct vpu_core *core;\n\tstruct delayed_work *dwork;\n\tunsigned long bytes = sizeof(u32);\n\tu32 i;\n\n\tif (!work)\n\t\treturn;\n\n\tdwork = to_delayed_work(work);\n\tcore = container_of(dwork, struct vpu_core, msg_delayed_work);\n\tif (kfifo_len(&core->msg_fifo) >= bytes)\n\t\tvpu_core_run_msg_work(core);\n\n\tbytes = sizeof(struct vpu_rpc_event_header);\n\tfor (i = 0; i < core->supported_instance_count; i++) {\n\t\tstruct vpu_inst *inst = vpu_core_find_instance(core, i);\n\n\t\tif (!inst)\n\t\t\tcontinue;\n\n\t\tif (inst->workqueue && kfifo_len(&inst->msg_fifo) >= bytes)\n\t\t\tqueue_work(inst->workqueue, &inst->msg_work);\n\n\t\tvpu_inst_put(inst);\n\t}\n}\n\nint vpu_isr(struct vpu_core *core, u32 irq)\n{\n\tswitch (irq) {\n\tcase VPU_IRQ_CODE_SYNC:\n\t\tbreak;\n\tcase VPU_IRQ_CODE_BOOT_DONE:\n\t\tcomplete(&core->cmp);\n\t\tbreak;\n\tcase VPU_IRQ_CODE_SNAPSHOT_DONE:\n\t\tcomplete(&core->cmp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (kfifo_in(&core->msg_fifo, &irq, sizeof(irq)) != sizeof(irq))\n\t\tdev_err(core->dev, \"[%d]overflow: %d\\n\", core->id, irq);\n\tqueue_work(core->workqueue, &core->msg_work);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}