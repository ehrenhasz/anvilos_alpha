{
  "module_name": "atmel-isi.c",
  "hash_id": "ac07f454336ceb04f1f64d33db3726a08d4ad97c3f2d74d29841aae33b6fe412",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/atmel/atmel-isi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#include <linux/videodev2.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fwnode.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/v4l2-image-sizes.h>\n\n#include \"atmel-isi.h\"\n\n#define MAX_SUPPORT_WIDTH\t\t2048U\n#define MAX_SUPPORT_HEIGHT\t\t2048U\n#define MIN_FRAME_RATE\t\t\t15\n#define FRAME_INTERVAL_MILLI_SEC\t(1000 / MIN_FRAME_RATE)\n\n \nstruct fbd {\n\t \n\tu32 fb_address;\n\t \n\tu32 dma_ctrl;\n\t \n\tu32 next_fbd_address;\n};\n\nstatic void set_dma_ctrl(struct fbd *fb_desc, u32 ctrl)\n{\n\tfb_desc->dma_ctrl = ctrl;\n}\n\nstruct isi_dma_desc {\n\tstruct list_head list;\n\tstruct fbd *p_fbd;\n\tdma_addr_t fbd_phys;\n};\n\n \nstruct frame_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct isi_dma_desc *p_dma_desc;\n\tstruct list_head list;\n};\n\nstruct isi_graph_entity {\n\tstruct device_node *node;\n\n\tstruct v4l2_subdev *subdev;\n};\n\n \nstruct isi_format {\n\tu32\tfourcc;\n\tu32\tmbus_code;\n\tu8\tbpp;\n\tu32\tswap;\n};\n\n\nstruct atmel_isi {\n\t \n\tspinlock_t\t\t\tirqlock;\n\tstruct device\t\t\t*dev;\n\tvoid __iomem\t\t\t*regs;\n\n\tint\t\t\t\tsequence;\n\n\t \n\tstruct fbd\t\t\t*p_fb_descriptors;\n\tdma_addr_t\t\t\tfb_descriptors_phys;\n\tstruct\t\t\t\tlist_head dma_desc_head;\n\tstruct isi_dma_desc\t\tdma_desc[VIDEO_MAX_FRAME];\n\tbool\t\t\t\tenable_preview_path;\n\n\tstruct completion\t\tcomplete;\n\t \n\tstruct clk\t\t\t*pclk;\n\tunsigned int\t\t\tirq;\n\n\tstruct isi_platform_data\tpdata;\n\tu16\t\t\t\twidth_flags;\t \n\n\tstruct list_head\t\tvideo_buffer_list;\n\tstruct frame_buffer\t\t*active;\n\n\tstruct v4l2_device\t\tv4l2_dev;\n\tstruct video_device\t\t*vdev;\n\tstruct v4l2_async_notifier\tnotifier;\n\tstruct isi_graph_entity\t\tentity;\n\tstruct v4l2_format\t\tfmt;\n\n\tconst struct isi_format\t\t**user_formats;\n\tunsigned int\t\t\tnum_user_formats;\n\tconst struct isi_format\t\t*current_fmt;\n\n\tstruct mutex\t\t\tlock;\n\tstruct vb2_queue\t\tqueue;\n};\n\n#define notifier_to_isi(n) container_of(n, struct atmel_isi, notifier)\n\nstatic void isi_writel(struct atmel_isi *isi, u32 reg, u32 val)\n{\n\twritel(val, isi->regs + reg);\n}\nstatic u32 isi_readl(struct atmel_isi *isi, u32 reg)\n{\n\treturn readl(isi->regs + reg);\n}\n\nstatic void configure_geometry(struct atmel_isi *isi)\n{\n\tu32 cfg2, psize;\n\tu32 fourcc = isi->current_fmt->fourcc;\n\n\tisi->enable_preview_path = fourcc == V4L2_PIX_FMT_RGB565 ||\n\t\t\t\t   fourcc == V4L2_PIX_FMT_RGB32 ||\n\t\t\t\t   fourcc == V4L2_PIX_FMT_Y16;\n\n\t \n\tcfg2 = isi->current_fmt->swap;\n\n\tisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\n\t \n\tcfg2 |= ((isi->fmt.fmt.pix.width - 1) << ISI_CFG2_IM_HSIZE_OFFSET) &\n\t\t\tISI_CFG2_IM_HSIZE_MASK;\n\t \n\tcfg2 |= ((isi->fmt.fmt.pix.height - 1) << ISI_CFG2_IM_VSIZE_OFFSET)\n\t\t\t& ISI_CFG2_IM_VSIZE_MASK;\n\tisi_writel(isi, ISI_CFG2, cfg2);\n\n\t \n\tpsize = ((isi->fmt.fmt.pix.width - 1) << ISI_PSIZE_PREV_HSIZE_OFFSET) &\n\t\tISI_PSIZE_PREV_HSIZE_MASK;\n\tpsize |= ((isi->fmt.fmt.pix.height - 1) << ISI_PSIZE_PREV_VSIZE_OFFSET) &\n\t\tISI_PSIZE_PREV_VSIZE_MASK;\n\tisi_writel(isi, ISI_PSIZE, psize);\n\tisi_writel(isi, ISI_PDECF, ISI_PDECF_NO_SAMPLING);\n}\n\nstatic irqreturn_t atmel_isi_handle_streaming(struct atmel_isi *isi)\n{\n\tif (isi->active) {\n\t\tstruct vb2_v4l2_buffer *vbuf = &isi->active->vb;\n\t\tstruct frame_buffer *buf = isi->active;\n\n\t\tlist_del_init(&buf->list);\n\t\tvbuf->vb2_buf.timestamp = ktime_get_ns();\n\t\tvbuf->sequence = isi->sequence++;\n\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tvb2_buffer_done(&vbuf->vb2_buf, VB2_BUF_STATE_DONE);\n\t}\n\n\tif (list_empty(&isi->video_buffer_list)) {\n\t\tisi->active = NULL;\n\t} else {\n\t\t \n\t\tisi->active = list_entry(isi->video_buffer_list.next,\n\t\t\t\t\tstruct frame_buffer, list);\n\t\tif (!isi->enable_preview_path) {\n\t\t\tisi_writel(isi, ISI_DMA_C_DSCR,\n\t\t\t\t(u32)isi->active->p_dma_desc->fbd_phys);\n\t\t\tisi_writel(isi, ISI_DMA_C_CTRL,\n\t\t\t\tISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\n\t\t\tisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_C_CH);\n\t\t} else {\n\t\t\tisi_writel(isi, ISI_DMA_P_DSCR,\n\t\t\t\t(u32)isi->active->p_dma_desc->fbd_phys);\n\t\t\tisi_writel(isi, ISI_DMA_P_CTRL,\n\t\t\t\tISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\n\t\t\tisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_P_CH);\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t isi_interrupt(int irq, void *dev_id)\n{\n\tstruct atmel_isi *isi = dev_id;\n\tu32 status, mask, pending;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tspin_lock(&isi->irqlock);\n\n\tstatus = isi_readl(isi, ISI_STATUS);\n\tmask = isi_readl(isi, ISI_INTMASK);\n\tpending = status & mask;\n\n\tif (pending & ISI_CTRL_SRST) {\n\t\tcomplete(&isi->complete);\n\t\tisi_writel(isi, ISI_INTDIS, ISI_CTRL_SRST);\n\t\tret = IRQ_HANDLED;\n\t} else if (pending & ISI_CTRL_DIS) {\n\t\tcomplete(&isi->complete);\n\t\tisi_writel(isi, ISI_INTDIS, ISI_CTRL_DIS);\n\t\tret = IRQ_HANDLED;\n\t} else {\n\t\tif (likely(pending & ISI_SR_CXFR_DONE) ||\n\t\t\t\tlikely(pending & ISI_SR_PXFR_DONE))\n\t\t\tret = atmel_isi_handle_streaming(isi);\n\t}\n\n\tspin_unlock(&isi->irqlock);\n\treturn ret;\n}\n\n#define\tWAIT_ISI_RESET\t\t1\n#define\tWAIT_ISI_DISABLE\t0\nstatic int atmel_isi_wait_status(struct atmel_isi *isi, int wait_reset)\n{\n\tunsigned long timeout;\n\t \n\tinit_completion(&isi->complete);\n\n\tif (wait_reset) {\n\t\tisi_writel(isi, ISI_INTEN, ISI_CTRL_SRST);\n\t\tisi_writel(isi, ISI_CTRL, ISI_CTRL_SRST);\n\t} else {\n\t\tisi_writel(isi, ISI_INTEN, ISI_CTRL_DIS);\n\t\tisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\n\t}\n\n\ttimeout = wait_for_completion_timeout(&isi->complete,\n\t\t\tmsecs_to_jiffies(500));\n\tif (timeout == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n \nstatic int queue_setup(struct vb2_queue *vq,\n\t\t\t\tunsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct atmel_isi *isi = vb2_get_drv_priv(vq);\n\tunsigned long size;\n\n\tsize = isi->fmt.fmt.pix.sizeimage;\n\n\t \n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\tisi->active = NULL;\n\n\tdev_dbg(isi->dev, \"%s, count=%d, size=%ld\\n\", __func__,\n\t\t*nbuffers, size);\n\n\treturn 0;\n}\n\nstatic int buffer_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct frame_buffer *buf = container_of(vbuf, struct frame_buffer, vb);\n\n\tbuf->p_dma_desc = NULL;\n\tINIT_LIST_HEAD(&buf->list);\n\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct frame_buffer *buf = container_of(vbuf, struct frame_buffer, vb);\n\tstruct atmel_isi *isi = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long size;\n\tstruct isi_dma_desc *desc;\n\n\tsize = isi->fmt.fmt.pix.sizeimage;\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdev_err(isi->dev, \"%s data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t\t__func__, vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, size);\n\n\tif (!buf->p_dma_desc) {\n\t\tif (list_empty(&isi->dma_desc_head)) {\n\t\t\tdev_err(isi->dev, \"Not enough dma descriptors.\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\t \n\t\t\tdesc = list_entry(isi->dma_desc_head.next,\n\t\t\t\t\t\tstruct isi_dma_desc, list);\n\t\t\t \n\t\t\tlist_del_init(&desc->list);\n\n\t\t\t \n\t\t\tdesc->p_fbd->fb_address =\n\t\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, 0);\n\t\t\tdesc->p_fbd->next_fbd_address = 0;\n\t\t\tset_dma_ctrl(desc->p_fbd, ISI_DMA_CTRL_WB);\n\n\t\t\tbuf->p_dma_desc = desc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void buffer_cleanup(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct atmel_isi *isi = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct frame_buffer *buf = container_of(vbuf, struct frame_buffer, vb);\n\n\t \n\tif (buf->p_dma_desc)\n\t\tlist_add(&buf->p_dma_desc->list, &isi->dma_desc_head);\n}\n\nstatic void start_dma(struct atmel_isi *isi, struct frame_buffer *buffer)\n{\n\tu32 ctrl, cfg1;\n\n\tcfg1 = isi_readl(isi, ISI_CFG1);\n\t \n\tisi_writel(isi, ISI_INTEN,\n\t\t\tISI_SR_CXFR_DONE | ISI_SR_PXFR_DONE);\n\n\t \n\tif (!isi->enable_preview_path) {\n\t\tif (isi_readl(isi, ISI_STATUS) & ISI_CTRL_CDC) {\n\t\t\tdev_err(isi->dev, \"Already in frame handling.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tisi_writel(isi, ISI_DMA_C_DSCR,\n\t\t\t\t(u32)buffer->p_dma_desc->fbd_phys);\n\t\tisi_writel(isi, ISI_DMA_C_CTRL,\n\t\t\t\tISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\n\t\tisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_C_CH);\n\t} else {\n\t\tisi_writel(isi, ISI_DMA_P_DSCR,\n\t\t\t\t(u32)buffer->p_dma_desc->fbd_phys);\n\t\tisi_writel(isi, ISI_DMA_P_CTRL,\n\t\t\t\tISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\n\t\tisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_P_CH);\n\t}\n\n\tcfg1 &= ~ISI_CFG1_FRATE_DIV_MASK;\n\t \n\tcfg1 |= isi->pdata.frate | ISI_CFG1_DISCR;\n\n\t \n\tctrl = ISI_CTRL_EN;\n\n\tif (!isi->enable_preview_path)\n\t\tctrl |= ISI_CTRL_CDC;\n\n\tisi_writel(isi, ISI_CTRL, ctrl);\n\tisi_writel(isi, ISI_CFG1, cfg1);\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct atmel_isi *isi = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct frame_buffer *buf = container_of(vbuf, struct frame_buffer, vb);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&isi->irqlock, flags);\n\tlist_add_tail(&buf->list, &isi->video_buffer_list);\n\n\tif (!isi->active) {\n\t\tisi->active = buf;\n\t\tif (vb2_is_streaming(vb->vb2_queue))\n\t\t\tstart_dma(isi, buf);\n\t}\n\tspin_unlock_irqrestore(&isi->irqlock, flags);\n}\n\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct atmel_isi *isi = vb2_get_drv_priv(vq);\n\tstruct frame_buffer *buf, *node;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(isi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = v4l2_subdev_call(isi->entity.subdev, video, s_stream, 1);\n\tif (ret && ret != -ENOIOCTLCMD) {\n\t\tdev_err(isi->dev, \"stream on failed in subdev\\n\");\n\t\tgoto err_start_stream;\n\t}\n\n\t \n\tret = atmel_isi_wait_status(isi, WAIT_ISI_RESET);\n\tif (ret < 0) {\n\t\tdev_err(isi->dev, \"Reset ISI timed out\\n\");\n\t\tgoto err_reset;\n\t}\n\t \n\tisi_writel(isi, ISI_INTDIS, (u32)~0UL);\n\n\tisi->sequence = 0;\n\tconfigure_geometry(isi);\n\n\tspin_lock_irq(&isi->irqlock);\n\t \n\tisi_readl(isi, ISI_STATUS);\n\n\tstart_dma(isi, isi->active);\n\tspin_unlock_irq(&isi->irqlock);\n\n\treturn 0;\n\nerr_reset:\n\tv4l2_subdev_call(isi->entity.subdev, video, s_stream, 0);\n\nerr_start_stream:\n\tpm_runtime_put(isi->dev);\n\n\tspin_lock_irq(&isi->irqlock);\n\tisi->active = NULL;\n\t \n\tlist_for_each_entry_safe(buf, node, &isi->video_buffer_list, list) {\n\t\tlist_del_init(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t}\n\tspin_unlock_irq(&isi->irqlock);\n\n\treturn ret;\n}\n\n \nstatic void stop_streaming(struct vb2_queue *vq)\n{\n\tstruct atmel_isi *isi = vb2_get_drv_priv(vq);\n\tstruct frame_buffer *buf, *node;\n\tint ret = 0;\n\tunsigned long timeout;\n\n\t \n\tret = v4l2_subdev_call(isi->entity.subdev, video, s_stream, 0);\n\tif (ret && ret != -ENOIOCTLCMD)\n\t\tdev_err(isi->dev, \"stream off failed in subdev\\n\");\n\n\tspin_lock_irq(&isi->irqlock);\n\tisi->active = NULL;\n\t \n\tlist_for_each_entry_safe(buf, node, &isi->video_buffer_list, list) {\n\t\tlist_del_init(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irq(&isi->irqlock);\n\n\tif (!isi->enable_preview_path) {\n\t\ttimeout = jiffies + (FRAME_INTERVAL_MILLI_SEC * HZ) / 1000;\n\t\t \n\t\twhile ((isi_readl(isi, ISI_STATUS) & ISI_CTRL_CDC) &&\n\t\t\t\ttime_before(jiffies, timeout))\n\t\t\tmsleep(1);\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\tdev_err(isi->dev,\n\t\t\t\t\"Timeout waiting for finishing codec request\\n\");\n\t}\n\n\t \n\tisi_writel(isi, ISI_INTDIS,\n\t\t\tISI_SR_CXFR_DONE | ISI_SR_PXFR_DONE);\n\n\t \n\tret = atmel_isi_wait_status(isi, WAIT_ISI_DISABLE);\n\tif (ret < 0)\n\t\tdev_err(isi->dev, \"Disable ISI timed out\\n\");\n\n\tpm_runtime_put(isi->dev);\n}\n\nstatic const struct vb2_ops isi_video_qops = {\n\t.queue_setup\t\t= queue_setup,\n\t.buf_init\t\t= buffer_init,\n\t.buf_prepare\t\t= buffer_prepare,\n\t.buf_cleanup\t\t= buffer_cleanup,\n\t.buf_queue\t\t= buffer_queue,\n\t.start_streaming\t= start_streaming,\n\t.stop_streaming\t\t= stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic int isi_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *fmt)\n{\n\tstruct atmel_isi *isi = video_drvdata(file);\n\n\t*fmt = isi->fmt;\n\n\treturn 0;\n}\n\nstatic const struct isi_format *find_format_by_fourcc(struct atmel_isi *isi,\n\t\t\t\t\t\t      unsigned int fourcc)\n{\n\tunsigned int num_formats = isi->num_user_formats;\n\tconst struct isi_format *fmt;\n\tunsigned int i;\n\n\tfor (i = 0; i < num_formats; i++) {\n\t\tfmt = isi->user_formats[i];\n\t\tif (fmt->fourcc == fourcc)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nstatic void isi_try_fse(struct atmel_isi *isi, const struct isi_format *isi_fmt,\n\t\t\tstruct v4l2_subdev_state *sd_state)\n{\n\tint ret;\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.code = isi_fmt->mbus_code,\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\n\tret = v4l2_subdev_call(isi->entity.subdev, pad, enum_frame_size,\n\t\t\t       sd_state, &fse);\n\t \n\tif (ret) {\n\t\tsd_state->pads->try_crop.width = MAX_SUPPORT_WIDTH;\n\t\tsd_state->pads->try_crop.height = MAX_SUPPORT_HEIGHT;\n\t} else {\n\t\tsd_state->pads->try_crop.width = fse.max_width;\n\t\tsd_state->pads->try_crop.height = fse.max_height;\n\t}\n}\n\nstatic int isi_try_fmt(struct atmel_isi *isi, struct v4l2_format *f,\n\t\t       const struct isi_format **current_fmt)\n{\n\tconst struct isi_format *isi_fmt;\n\tstruct v4l2_pix_format *pixfmt = &f->fmt.pix;\n\tstruct v4l2_subdev_pad_config pad_cfg = {};\n\tstruct v4l2_subdev_state pad_state = {\n\t\t.pads = &pad_cfg,\n\t};\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_TRY,\n\t};\n\tint ret;\n\n\tisi_fmt = find_format_by_fourcc(isi, pixfmt->pixelformat);\n\tif (!isi_fmt) {\n\t\tisi_fmt = isi->user_formats[isi->num_user_formats - 1];\n\t\tpixfmt->pixelformat = isi_fmt->fourcc;\n\t}\n\n\t \n\tpixfmt->width = clamp(pixfmt->width, 0U, MAX_SUPPORT_WIDTH);\n\tpixfmt->height = clamp(pixfmt->height, 0U, MAX_SUPPORT_HEIGHT);\n\n\tv4l2_fill_mbus_format(&format.format, pixfmt, isi_fmt->mbus_code);\n\n\tisi_try_fse(isi, isi_fmt, &pad_state);\n\n\tret = v4l2_subdev_call(isi->entity.subdev, pad, set_fmt,\n\t\t\t       &pad_state, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_fill_pix_format(pixfmt, &format.format);\n\n\tpixfmt->field = V4L2_FIELD_NONE;\n\tpixfmt->bytesperline = pixfmt->width * isi_fmt->bpp;\n\tpixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height;\n\n\tif (current_fmt)\n\t\t*current_fmt = isi_fmt;\n\n\treturn 0;\n}\n\nstatic int isi_set_fmt(struct atmel_isi *isi, struct v4l2_format *f)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tconst struct isi_format *current_fmt;\n\tint ret;\n\n\tret = isi_try_fmt(isi, f, &current_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tv4l2_fill_mbus_format(&format.format, &f->fmt.pix,\n\t\t\t      current_fmt->mbus_code);\n\tret = v4l2_subdev_call(isi->entity.subdev, pad,\n\t\t\t       set_fmt, NULL, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tisi->fmt = *f;\n\tisi->current_fmt = current_fmt;\n\n\treturn 0;\n}\n\nstatic int isi_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct atmel_isi *isi = video_drvdata(file);\n\n\tif (vb2_is_streaming(&isi->queue))\n\t\treturn -EBUSY;\n\n\treturn isi_set_fmt(isi, f);\n}\n\nstatic int isi_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct atmel_isi *isi = video_drvdata(file);\n\n\treturn isi_try_fmt(isi, f, NULL);\n}\n\nstatic int isi_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tstruct atmel_isi *isi = video_drvdata(file);\n\n\tif (f->index >= isi->num_user_formats)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = isi->user_formats[f->index]->fourcc;\n\treturn 0;\n}\n\nstatic int isi_querycap(struct file *file, void *priv,\n\t\t\tstruct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, \"atmel-isi\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"Atmel Image Sensor Interface\", sizeof(cap->card));\n\tstrscpy(cap->bus_info, \"platform:isi\", sizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic int isi_enum_input(struct file *file, void *priv,\n\t\t\t   struct v4l2_input *i)\n{\n\tif (i->index != 0)\n\t\treturn -EINVAL;\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\tstrscpy(i->name, \"Camera\", sizeof(i->name));\n\treturn 0;\n}\n\nstatic int isi_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int isi_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tif (i > 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int isi_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct atmel_isi *isi = video_drvdata(file);\n\n\treturn v4l2_g_parm_cap(video_devdata(file), isi->entity.subdev, a);\n}\n\nstatic int isi_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct atmel_isi *isi = video_drvdata(file);\n\n\treturn v4l2_s_parm_cap(video_devdata(file), isi->entity.subdev, a);\n}\n\nstatic int isi_enum_framesizes(struct file *file, void *fh,\n\t\t\t       struct v4l2_frmsizeenum *fsize)\n{\n\tstruct atmel_isi *isi = video_drvdata(file);\n\tconst struct isi_format *isi_fmt;\n\tstruct v4l2_subdev_frame_size_enum fse = {\n\t\t.index = fsize->index,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tisi_fmt = find_format_by_fourcc(isi, fsize->pixel_format);\n\tif (!isi_fmt)\n\t\treturn -EINVAL;\n\n\tfse.code = isi_fmt->mbus_code;\n\n\tret = v4l2_subdev_call(isi->entity.subdev, pad, enum_frame_size,\n\t\t\t       NULL, &fse);\n\tif (ret)\n\t\treturn ret;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = fse.max_width;\n\tfsize->discrete.height = fse.max_height;\n\n\treturn 0;\n}\n\nstatic int isi_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_frmivalenum *fival)\n{\n\tstruct atmel_isi *isi = video_drvdata(file);\n\tconst struct isi_format *isi_fmt;\n\tstruct v4l2_subdev_frame_interval_enum fie = {\n\t\t.index = fival->index,\n\t\t.width = fival->width,\n\t\t.height = fival->height,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tint ret;\n\n\tisi_fmt = find_format_by_fourcc(isi, fival->pixel_format);\n\tif (!isi_fmt)\n\t\treturn -EINVAL;\n\n\tfie.code = isi_fmt->mbus_code;\n\n\tret = v4l2_subdev_call(isi->entity.subdev, pad,\n\t\t\t       enum_frame_interval, NULL, &fie);\n\tif (ret)\n\t\treturn ret;\n\n\tfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tfival->discrete = fie.interval;\n\n\treturn 0;\n}\n\nstatic int isi_camera_set_bus_param(struct atmel_isi *isi)\n{\n\tu32 cfg1 = 0;\n\tint ret;\n\n\t \n\tif (isi->pdata.hsync_act_low)\n\t\tcfg1 |= ISI_CFG1_HSYNC_POL_ACTIVE_LOW;\n\tif (isi->pdata.vsync_act_low)\n\t\tcfg1 |= ISI_CFG1_VSYNC_POL_ACTIVE_LOW;\n\tif (isi->pdata.pclk_act_falling)\n\t\tcfg1 |= ISI_CFG1_PIXCLK_POL_ACTIVE_FALLING;\n\tif (isi->pdata.has_emb_sync)\n\t\tcfg1 |= ISI_CFG1_EMB_SYNC;\n\tif (isi->pdata.full_mode)\n\t\tcfg1 |= ISI_CFG1_FULL_MODE;\n\n\tcfg1 |= ISI_CFG1_THMASK_BEATS_16;\n\n\t \n\tret = pm_runtime_resume_and_get(isi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\n\tisi_writel(isi, ISI_CFG1, cfg1);\n\n\tpm_runtime_put(isi->dev);\n\n\treturn 0;\n}\n\n \nstatic int atmel_isi_parse_dt(struct atmel_isi *isi,\n\t\t\tstruct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct v4l2_fwnode_endpoint ep = { .bus_type = 0 };\n\tint err;\n\n\t \n\tisi->pdata.full_mode = 1;\n\tisi->pdata.frate = ISI_CFG1_FRATE_CAPTURE_ALL;\n\n\tnp = of_graph_get_next_endpoint(np, NULL);\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"Could not find the endpoint\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = v4l2_fwnode_endpoint_parse(of_fwnode_handle(np), &ep);\n\tof_node_put(np);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Could not parse the endpoint\\n\");\n\t\treturn err;\n\t}\n\n\tswitch (ep.bus.parallel.bus_width) {\n\tcase 8:\n\t\tisi->pdata.data_width_flags = ISI_DATAWIDTH_8;\n\t\tbreak;\n\tcase 10:\n\t\tisi->pdata.data_width_flags =\n\t\t\t\tISI_DATAWIDTH_8 | ISI_DATAWIDTH_10;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unsupported bus width: %d\\n\",\n\t\t\t\tep.bus.parallel.bus_width);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ep.bus.parallel.flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\n\t\tisi->pdata.hsync_act_low = true;\n\tif (ep.bus.parallel.flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\n\t\tisi->pdata.vsync_act_low = true;\n\tif (ep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\n\t\tisi->pdata.pclk_act_falling = true;\n\n\tif (ep.bus_type == V4L2_MBUS_BT656)\n\t\tisi->pdata.has_emb_sync = true;\n\n\treturn 0;\n}\n\nstatic int isi_open(struct file *file)\n{\n\tstruct atmel_isi *isi = video_drvdata(file);\n\tstruct v4l2_subdev *sd = isi->entity.subdev;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&isi->lock))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_fh_open(file);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tif (!v4l2_fh_is_singular_file(file))\n\t\tgoto fh_rel;\n\n\tret = v4l2_subdev_call(sd, core, s_power, 1);\n\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\tgoto fh_rel;\n\n\tret = isi_set_fmt(isi, &isi->fmt);\n\tif (ret)\n\t\tv4l2_subdev_call(sd, core, s_power, 0);\nfh_rel:\n\tif (ret)\n\t\tv4l2_fh_release(file);\nunlock:\n\tmutex_unlock(&isi->lock);\n\treturn ret;\n}\n\nstatic int isi_release(struct file *file)\n{\n\tstruct atmel_isi *isi = video_drvdata(file);\n\tstruct v4l2_subdev *sd = isi->entity.subdev;\n\tbool fh_singular;\n\tint ret;\n\n\tmutex_lock(&isi->lock);\n\n\tfh_singular = v4l2_fh_is_singular_file(file);\n\n\tret = _vb2_fop_release(file, NULL);\n\n\tif (fh_singular)\n\t\tv4l2_subdev_call(sd, core, s_power, 0);\n\n\tmutex_unlock(&isi->lock);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ioctl_ops isi_ioctl_ops = {\n\t.vidioc_querycap\t\t= isi_querycap,\n\n\t.vidioc_try_fmt_vid_cap\t\t= isi_try_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= isi_g_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= isi_s_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_cap\t= isi_enum_fmt_vid_cap,\n\n\t.vidioc_enum_input\t\t= isi_enum_input,\n\t.vidioc_g_input\t\t\t= isi_g_input,\n\t.vidioc_s_input\t\t\t= isi_s_input,\n\n\t.vidioc_g_parm\t\t\t= isi_g_parm,\n\t.vidioc_s_parm\t\t\t= isi_s_parm,\n\t.vidioc_enum_framesizes\t\t= isi_enum_framesizes,\n\t.vidioc_enum_frameintervals\t= isi_enum_frameintervals,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\n\t.vidioc_log_status\t\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nstatic const struct v4l2_file_operations isi_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.open\t\t= isi_open,\n\t.release\t= isi_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.read\t\t= vb2_fop_read,\n};\n\nstatic int isi_set_default_fmt(struct atmel_isi *isi)\n{\n\tstruct v4l2_format f = {\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t\t.fmt.pix = {\n\t\t\t.width\t\t= VGA_WIDTH,\n\t\t\t.height\t\t= VGA_HEIGHT,\n\t\t\t.field\t\t= V4L2_FIELD_NONE,\n\t\t\t.pixelformat\t= isi->user_formats[0]->fourcc,\n\t\t},\n\t};\n\tint ret;\n\n\tret = isi_try_fmt(isi, &f, NULL);\n\tif (ret)\n\t\treturn ret;\n\tisi->current_fmt = isi->user_formats[0];\n\tisi->fmt = f;\n\treturn 0;\n}\n\nstatic const struct isi_format isi_formats[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.mbus_code = MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.bpp = 2,\n\t\t.swap = ISI_CFG2_YCC_SWAP_DEFAULT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.mbus_code = MEDIA_BUS_FMT_YVYU8_2X8,\n\t\t.bpp = 2,\n\t\t.swap = ISI_CFG2_YCC_SWAP_MODE_1,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.mbus_code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.bpp = 2,\n\t\t.swap = ISI_CFG2_YCC_SWAP_MODE_2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.mbus_code = MEDIA_BUS_FMT_VYUY8_2X8,\n\t\t.bpp = 2,\n\t\t.swap = ISI_CFG2_YCC_SWAP_MODE_3,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_RGB565,\n\t\t.mbus_code = MEDIA_BUS_FMT_YUYV8_2X8,\n\t\t.bpp = 2,\n\t\t.swap = ISI_CFG2_YCC_SWAP_MODE_2,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_RGB565,\n\t\t.mbus_code = MEDIA_BUS_FMT_YVYU8_2X8,\n\t\t.bpp = 2,\n\t\t.swap = ISI_CFG2_YCC_SWAP_MODE_3,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_RGB565,\n\t\t.mbus_code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t.bpp = 2,\n\t\t.swap = ISI_CFG2_YCC_SWAP_DEFAULT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_RGB565,\n\t\t.mbus_code = MEDIA_BUS_FMT_VYUY8_2X8,\n\t\t.bpp = 2,\n\t\t.swap = ISI_CFG2_YCC_SWAP_MODE_1,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_GREY,\n\t\t.mbus_code = MEDIA_BUS_FMT_Y10_1X10,\n\t\t.bpp = 1,\n\t\t.swap = ISI_CFG2_GS_MODE_2_PIXEL | ISI_CFG2_GRAYSCALE,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_Y16,\n\t\t.mbus_code = MEDIA_BUS_FMT_Y10_1X10,\n\t\t.bpp = 2,\n\t\t.swap = ISI_CFG2_GS_MODE_2_PIXEL | ISI_CFG2_GRAYSCALE,\n\t},\n};\n\nstatic int isi_formats_init(struct atmel_isi *isi)\n{\n\tconst struct isi_format *isi_fmts[ARRAY_SIZE(isi_formats)];\n\tunsigned int num_fmts = 0, i, j;\n\tstruct v4l2_subdev *subdev = isi->entity.subdev;\n\tstruct v4l2_subdev_mbus_code_enum mbus_code = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\n\twhile (!v4l2_subdev_call(subdev, pad, enum_mbus_code,\n\t\t\t\t NULL, &mbus_code)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(isi_formats); i++) {\n\t\t\tif (isi_formats[i].mbus_code != mbus_code.code)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tfor (j = 0; j < num_fmts; j++)\n\t\t\t\tif (isi_fmts[j]->fourcc == isi_formats[i].fourcc)\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\tif (j == num_fmts)\n\t\t\t\t \n\t\t\t\tisi_fmts[num_fmts++] = isi_formats + i;\n\t\t}\n\t\tmbus_code.index++;\n\t}\n\n\tif (!num_fmts)\n\t\treturn -ENXIO;\n\n\tisi->num_user_formats = num_fmts;\n\tisi->user_formats = devm_kcalloc(isi->dev,\n\t\t\t\t\t num_fmts, sizeof(struct isi_format *),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!isi->user_formats)\n\t\treturn -ENOMEM;\n\n\tmemcpy(isi->user_formats, isi_fmts,\n\t       num_fmts * sizeof(struct isi_format *));\n\tisi->current_fmt = isi->user_formats[0];\n\n\treturn 0;\n}\n\nstatic int isi_graph_notify_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct atmel_isi *isi = notifier_to_isi(notifier);\n\tint ret;\n\n\tisi->vdev->ctrl_handler = isi->entity.subdev->ctrl_handler;\n\tret = isi_formats_init(isi);\n\tif (ret) {\n\t\tdev_err(isi->dev, \"No supported mediabus format found\\n\");\n\t\treturn ret;\n\t}\n\tret = isi_camera_set_bus_param(isi);\n\tif (ret) {\n\t\tdev_err(isi->dev, \"Can't wake up device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = isi_set_default_fmt(isi);\n\tif (ret) {\n\t\tdev_err(isi->dev, \"Could not set default format\\n\");\n\t\treturn ret;\n\t}\n\n\tret = video_register_device(isi->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(isi->dev, \"Failed to register video device\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(isi->dev, \"Device registered as %s\\n\",\n\t\tvideo_device_node_name(isi->vdev));\n\treturn 0;\n}\n\nstatic void isi_graph_notify_unbind(struct v4l2_async_notifier *notifier,\n\t\t\t\t     struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_async_connection *asd)\n{\n\tstruct atmel_isi *isi = notifier_to_isi(notifier);\n\n\tdev_dbg(isi->dev, \"Removing %s\\n\", video_device_node_name(isi->vdev));\n\n\t \n\tvideo_unregister_device(isi->vdev);\n}\n\nstatic int isi_graph_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t   struct v4l2_subdev *subdev,\n\t\t\t\t   struct v4l2_async_connection *asd)\n{\n\tstruct atmel_isi *isi = notifier_to_isi(notifier);\n\n\tdev_dbg(isi->dev, \"subdev %s bound\\n\", subdev->name);\n\n\tisi->entity.subdev = subdev;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_async_notifier_operations isi_graph_notify_ops = {\n\t.bound = isi_graph_notify_bound,\n\t.unbind = isi_graph_notify_unbind,\n\t.complete = isi_graph_notify_complete,\n};\n\nstatic int isi_graph_init(struct atmel_isi *isi)\n{\n\tstruct v4l2_async_connection *asd;\n\tstruct device_node *ep;\n\tint ret;\n\n\tep = of_graph_get_next_endpoint(isi->dev->of_node, NULL);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tv4l2_async_nf_init(&isi->notifier, &isi->v4l2_dev);\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&isi->notifier,\n\t\t\t\t\t      of_fwnode_handle(ep),\n\t\t\t\t\t      struct v4l2_async_connection);\n\tof_node_put(ep);\n\n\tif (IS_ERR(asd))\n\t\treturn PTR_ERR(asd);\n\n\tisi->notifier.ops = &isi_graph_notify_ops;\n\n\tret = v4l2_async_nf_register(&isi->notifier);\n\tif (ret < 0) {\n\t\tdev_err(isi->dev, \"Notifier registration failed\\n\");\n\t\tv4l2_async_nf_cleanup(&isi->notifier);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int atmel_isi_probe(struct platform_device *pdev)\n{\n\tint irq;\n\tstruct atmel_isi *isi;\n\tstruct vb2_queue *q;\n\tint ret, i;\n\n\tisi = devm_kzalloc(&pdev->dev, sizeof(struct atmel_isi), GFP_KERNEL);\n\tif (!isi)\n\t\treturn -ENOMEM;\n\n\tisi->pclk = devm_clk_get(&pdev->dev, \"isi_clk\");\n\tif (IS_ERR(isi->pclk))\n\t\treturn PTR_ERR(isi->pclk);\n\n\tret = atmel_isi_parse_dt(isi, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tisi->active = NULL;\n\tisi->dev = &pdev->dev;\n\tmutex_init(&isi->lock);\n\tspin_lock_init(&isi->irqlock);\n\tINIT_LIST_HEAD(&isi->video_buffer_list);\n\tINIT_LIST_HEAD(&isi->dma_desc_head);\n\n\tq = &isi->queue;\n\n\t \n\tret = v4l2_device_register(&pdev->dev, &isi->v4l2_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tisi->vdev = video_device_alloc();\n\tif (!isi->vdev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_vdev_alloc;\n\t}\n\n\t \n\tisi->vdev->fops = &isi_fops;\n\tisi->vdev->v4l2_dev = &isi->v4l2_dev;\n\tisi->vdev->queue = &isi->queue;\n\tstrscpy(isi->vdev->name, KBUILD_MODNAME, sizeof(isi->vdev->name));\n\tisi->vdev->release = video_device_release;\n\tisi->vdev->ioctl_ops = &isi_ioctl_ops;\n\tisi->vdev->lock = &isi->lock;\n\tisi->vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\n\t\tV4L2_CAP_READWRITE;\n\tvideo_set_drvdata(isi->vdev, isi);\n\n\t \n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;\n\tq->lock = &isi->lock;\n\tq->drv_priv = isi;\n\tq->buf_struct_size = sizeof(struct frame_buffer);\n\tq->ops = &isi_video_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = 2;\n\tq->dev = &pdev->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to initialize VB2 queue\\n\");\n\t\tgoto err_vb2_queue;\n\t}\n\tisi->p_fb_descriptors = dma_alloc_coherent(&pdev->dev,\n\t\t\t\tsizeof(struct fbd) * VIDEO_MAX_FRAME,\n\t\t\t\t&isi->fb_descriptors_phys,\n\t\t\t\tGFP_KERNEL);\n\tif (!isi->p_fb_descriptors) {\n\t\tdev_err(&pdev->dev, \"Can't allocate descriptors!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_dma_alloc;\n\t}\n\n\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\tisi->dma_desc[i].p_fbd = isi->p_fb_descriptors + i;\n\t\tisi->dma_desc[i].fbd_phys = isi->fb_descriptors_phys +\n\t\t\t\t\ti * sizeof(struct fbd);\n\t\tlist_add(&isi->dma_desc[i].list, &isi->dma_desc_head);\n\t}\n\n\tisi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(isi->regs)) {\n\t\tret = PTR_ERR(isi->regs);\n\t\tgoto err_ioremap;\n\t}\n\n\tif (isi->pdata.data_width_flags & ISI_DATAWIDTH_8)\n\t\tisi->width_flags = 1 << 7;\n\tif (isi->pdata.data_width_flags & ISI_DATAWIDTH_10)\n\t\tisi->width_flags |= 1 << 9;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_req_irq;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, isi_interrupt, 0, \"isi\", isi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to request irq %d\\n\", irq);\n\t\tgoto err_req_irq;\n\t}\n\tisi->irq = irq;\n\n\tret = isi_graph_init(isi);\n\tif (ret < 0)\n\t\tgoto err_req_irq;\n\n\tpm_suspend_ignore_children(&pdev->dev, true);\n\tpm_runtime_enable(&pdev->dev);\n\tplatform_set_drvdata(pdev, isi);\n\treturn 0;\n\nerr_req_irq:\nerr_ioremap:\n\tdma_free_coherent(&pdev->dev,\n\t\t\tsizeof(struct fbd) * VIDEO_MAX_FRAME,\n\t\t\tisi->p_fb_descriptors,\n\t\t\tisi->fb_descriptors_phys);\nerr_dma_alloc:\nerr_vb2_queue:\n\tvideo_device_release(isi->vdev);\nerr_vdev_alloc:\n\tv4l2_device_unregister(&isi->v4l2_dev);\n\n\treturn ret;\n}\n\nstatic void atmel_isi_remove(struct platform_device *pdev)\n{\n\tstruct atmel_isi *isi = platform_get_drvdata(pdev);\n\n\tdma_free_coherent(&pdev->dev,\n\t\t\tsizeof(struct fbd) * VIDEO_MAX_FRAME,\n\t\t\tisi->p_fb_descriptors,\n\t\t\tisi->fb_descriptors_phys);\n\tpm_runtime_disable(&pdev->dev);\n\tv4l2_async_nf_unregister(&isi->notifier);\n\tv4l2_async_nf_cleanup(&isi->notifier);\n\tv4l2_device_unregister(&isi->v4l2_dev);\n}\n\n#ifdef CONFIG_PM\nstatic int atmel_isi_runtime_suspend(struct device *dev)\n{\n\tstruct atmel_isi *isi = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(isi->pclk);\n\n\treturn 0;\n}\nstatic int atmel_isi_runtime_resume(struct device *dev)\n{\n\tstruct atmel_isi *isi = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(isi->pclk);\n}\n#endif  \n\nstatic const struct dev_pm_ops atmel_isi_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(atmel_isi_runtime_suspend,\n\t\t\t\tatmel_isi_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id atmel_isi_of_match[] = {\n\t{ .compatible = \"atmel,at91sam9g45-isi\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, atmel_isi_of_match);\n\nstatic struct platform_driver atmel_isi_driver = {\n\t.driver\t\t= {\n\t\t.name = \"atmel_isi\",\n\t\t.of_match_table = of_match_ptr(atmel_isi_of_match),\n\t\t.pm\t= &atmel_isi_dev_pm_ops,\n\t},\n\t.probe\t\t= atmel_isi_probe,\n\t.remove_new\t= atmel_isi_remove,\n};\n\nmodule_platform_driver(atmel_isi_driver);\n\nMODULE_AUTHOR(\"Josh Wu <josh.wu@atmel.com>\");\nMODULE_DESCRIPTION(\"The V4L2 driver for Atmel Linux\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}