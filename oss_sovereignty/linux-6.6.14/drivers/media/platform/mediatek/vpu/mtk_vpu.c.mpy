{
  "module_name": "mtk_vpu.c",
  "hash_id": "f372ee686270af800192c4fc1c1b15a85c84215524363c4798c97c1bbb992105",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vpu/mtk_vpu.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/iommu.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/sizes.h>\n#include <linux/dma-mapping.h>\n\n#include \"mtk_vpu.h\"\n\n \n\n#define INIT_TIMEOUT_MS\t\t2000U\n#define IPI_TIMEOUT_MS\t\t2000U\n#define VPU_IDLE_TIMEOUT_MS\t1000U\n#define VPU_FW_VER_LEN\t\t16\n\n \n#define VPU_PTCM_SIZE\t\t(96 * SZ_1K)\n#define VPU_DTCM_SIZE\t\t(32 * SZ_1K)\n \n#define VPU_DTCM_OFFSET\t\t0x18000UL\n \n#define VPU_EXT_P_SIZE\t\tSZ_1M\n#define VPU_EXT_D_SIZE\t\tSZ_4M\n \n#define VPU_P_FW_SIZE\t\t(VPU_PTCM_SIZE + VPU_EXT_P_SIZE)\n#define VPU_D_FW_SIZE\t\t(VPU_DTCM_SIZE + VPU_EXT_D_SIZE)\n \n#define SHARE_BUF_SIZE\t\t48\n\n \n#define VPU_P_FW\t\t\"vpu_p.bin\"\n#define VPU_D_FW\t\t\"vpu_d.bin\"\n#define VPU_P_FW_NEW\t\t\"mediatek/mt8173/vpu_p.bin\"\n#define VPU_D_FW_NEW\t\t\"mediatek/mt8173/vpu_d.bin\"\n\n#define VPU_RESET\t\t0x0\n#define VPU_TCM_CFG\t\t0x0008\n#define VPU_PMEM_EXT0_ADDR\t0x000C\n#define VPU_PMEM_EXT1_ADDR\t0x0010\n#define VPU_TO_HOST\t\t0x001C\n#define VPU_DMEM_EXT0_ADDR\t0x0014\n#define VPU_DMEM_EXT1_ADDR\t0x0018\n#define HOST_TO_VPU\t\t0x0024\n#define VPU_IDLE_REG\t\t0x002C\n#define VPU_INT_STATUS\t\t0x0034\n#define VPU_PC_REG\t\t0x0060\n#define VPU_SP_REG\t\t0x0064\n#define VPU_RA_REG\t\t0x0068\n#define VPU_WDT_REG\t\t0x0084\n\n \n#define VPU_IPC_INT\t\tBIT(8)\n \n#define VPU_IDLE_STATE\t\tBIT(23)\n\n \nenum vpu_fw_type {\n\tP_FW,\n\tD_FW,\n};\n\n \nstruct vpu_mem {\n\tvoid *va;\n\tdma_addr_t pa;\n};\n\n \nstruct vpu_regs {\n\tvoid __iomem *tcm;\n\tvoid __iomem *cfg;\n\tint irq;\n};\n\n \nstruct vpu_wdt_handler {\n\tvoid (*reset_func)(void *);\n\tvoid *priv;\n};\n\n \nstruct vpu_wdt {\n\tstruct vpu_wdt_handler handler[VPU_RST_MAX];\n\tstruct work_struct ws;\n\tstruct workqueue_struct *wq;\n};\n\n \nstruct vpu_run {\n\tu32 signaled;\n\tchar fw_ver[VPU_FW_VER_LEN];\n\tunsigned int\tdec_capability;\n\tunsigned int\tenc_capability;\n\twait_queue_head_t wq;\n};\n\n \nstruct vpu_ipi_desc {\n\tipi_handler_t handler;\n\tconst char *name;\n\tvoid *priv;\n};\n\n \nstruct share_obj {\n\ts32 id;\n\tu32 len;\n\tunsigned char share_buf[SHARE_BUF_SIZE];\n};\n\n \nstruct mtk_vpu {\n\tstruct vpu_mem extmem[2];\n\tstruct vpu_regs reg;\n\tstruct vpu_run run;\n\tstruct vpu_wdt wdt;\n\tstruct vpu_ipi_desc ipi_desc[IPI_MAX];\n\tstruct share_obj __iomem *recv_buf;\n\tstruct share_obj __iomem *send_buf;\n\tstruct device *dev;\n\tstruct clk *clk;\n\tbool fw_loaded;\n\tbool enable_4GB;\n\tstruct mutex vpu_mutex;  \n\tu32 wdt_refcnt;\n\twait_queue_head_t ack_wq;\n\tbool ipi_id_ack[IPI_MAX];\n};\n\nstatic inline void vpu_cfg_writel(struct mtk_vpu *vpu, u32 val, u32 offset)\n{\n\twritel(val, vpu->reg.cfg + offset);\n}\n\nstatic inline u32 vpu_cfg_readl(struct mtk_vpu *vpu, u32 offset)\n{\n\treturn readl(vpu->reg.cfg + offset);\n}\n\nstatic inline bool vpu_running(struct mtk_vpu *vpu)\n{\n\treturn vpu_cfg_readl(vpu, VPU_RESET) & BIT(0);\n}\n\nstatic void vpu_clock_disable(struct mtk_vpu *vpu)\n{\n\t \n\tmutex_lock(&vpu->vpu_mutex);\n\tif (!--vpu->wdt_refcnt)\n\t\tvpu_cfg_writel(vpu,\n\t\t\t       vpu_cfg_readl(vpu, VPU_WDT_REG) & ~(1L << 31),\n\t\t\t       VPU_WDT_REG);\n\tmutex_unlock(&vpu->vpu_mutex);\n\n\tclk_disable(vpu->clk);\n}\n\nstatic int vpu_clock_enable(struct mtk_vpu *vpu)\n{\n\tint ret;\n\n\tret = clk_enable(vpu->clk);\n\tif (ret)\n\t\treturn ret;\n\t \n\tmutex_lock(&vpu->vpu_mutex);\n\tif (!vpu->wdt_refcnt++)\n\t\tvpu_cfg_writel(vpu,\n\t\t\t       vpu_cfg_readl(vpu, VPU_WDT_REG) | (1L << 31),\n\t\t\t       VPU_WDT_REG);\n\tmutex_unlock(&vpu->vpu_mutex);\n\n\treturn ret;\n}\n\nstatic void vpu_dump_status(struct mtk_vpu *vpu)\n{\n\tdev_info(vpu->dev,\n\t\t \"vpu: run %x, pc = 0x%x, ra = 0x%x, sp = 0x%x, idle = 0x%x\\n\"\n\t\t \"vpu: int %x, hv = 0x%x, vh = 0x%x, wdt = 0x%x\\n\",\n\t\t vpu_running(vpu), vpu_cfg_readl(vpu, VPU_PC_REG),\n\t\t vpu_cfg_readl(vpu, VPU_RA_REG), vpu_cfg_readl(vpu, VPU_SP_REG),\n\t\t vpu_cfg_readl(vpu, VPU_IDLE_REG),\n\t\t vpu_cfg_readl(vpu, VPU_INT_STATUS),\n\t\t vpu_cfg_readl(vpu, HOST_TO_VPU),\n\t\t vpu_cfg_readl(vpu, VPU_TO_HOST),\n\t\t vpu_cfg_readl(vpu, VPU_WDT_REG));\n}\n\nint vpu_ipi_register(struct platform_device *pdev,\n\t\t     enum ipi_id id, ipi_handler_t handler,\n\t\t     const char *name, void *priv)\n{\n\tstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\n\tstruct vpu_ipi_desc *ipi_desc;\n\n\tif (!vpu) {\n\t\tdev_err(&pdev->dev, \"vpu device in not ready\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tif (id < IPI_MAX && handler) {\n\t\tipi_desc = vpu->ipi_desc;\n\t\tipi_desc[id].name = name;\n\t\tipi_desc[id].handler = handler;\n\t\tipi_desc[id].priv = priv;\n\t\treturn 0;\n\t}\n\n\tdev_err(&pdev->dev, \"register vpu ipi id %d with invalid arguments\\n\",\n\t\tid);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(vpu_ipi_register);\n\nint vpu_ipi_send(struct platform_device *pdev,\n\t\t enum ipi_id id, void *buf,\n\t\t unsigned int len)\n{\n\tstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\n\tstruct share_obj __iomem *send_obj = vpu->send_buf;\n\tunsigned long timeout;\n\tint ret = 0;\n\n\tif (id <= IPI_VPU_INIT || id >= IPI_MAX ||\n\t    len > sizeof(send_obj->share_buf) || !buf) {\n\t\tdev_err(vpu->dev, \"failed to send ipi message\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = vpu_clock_enable(vpu);\n\tif (ret) {\n\t\tdev_err(vpu->dev, \"failed to enable vpu clock\\n\");\n\t\treturn ret;\n\t}\n\tif (!vpu_running(vpu)) {\n\t\tdev_err(vpu->dev, \"vpu_ipi_send: VPU is not running\\n\");\n\t\tret = -EINVAL;\n\t\tgoto clock_disable;\n\t}\n\n\tmutex_lock(&vpu->vpu_mutex);\n\n\t  \n\ttimeout = jiffies + msecs_to_jiffies(IPI_TIMEOUT_MS);\n\tdo {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(vpu->dev, \"vpu_ipi_send: IPI timeout!\\n\");\n\t\t\tret = -EIO;\n\t\t\tvpu_dump_status(vpu);\n\t\t\tgoto mut_unlock;\n\t\t}\n\t} while (vpu_cfg_readl(vpu, HOST_TO_VPU));\n\n\tmemcpy_toio(send_obj->share_buf, buf, len);\n\twritel(len, &send_obj->len);\n\twritel(id, &send_obj->id);\n\n\tvpu->ipi_id_ack[id] = false;\n\t \n\tvpu_cfg_writel(vpu, 0x1, HOST_TO_VPU);\n\n\tmutex_unlock(&vpu->vpu_mutex);\n\n\t \n\ttimeout = msecs_to_jiffies(IPI_TIMEOUT_MS);\n\tret = wait_event_timeout(vpu->ack_wq, vpu->ipi_id_ack[id], timeout);\n\tvpu->ipi_id_ack[id] = false;\n\tif (ret == 0) {\n\t\tdev_err(vpu->dev, \"vpu ipi %d ack time out !\\n\", id);\n\t\tret = -EIO;\n\t\tvpu_dump_status(vpu);\n\t\tgoto clock_disable;\n\t}\n\tvpu_clock_disable(vpu);\n\n\treturn 0;\n\nmut_unlock:\n\tmutex_unlock(&vpu->vpu_mutex);\nclock_disable:\n\tvpu_clock_disable(vpu);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vpu_ipi_send);\n\nstatic void vpu_wdt_reset_func(struct work_struct *ws)\n{\n\tstruct vpu_wdt *wdt = container_of(ws, struct vpu_wdt, ws);\n\tstruct mtk_vpu *vpu = container_of(wdt, struct mtk_vpu, wdt);\n\tstruct vpu_wdt_handler *handler = wdt->handler;\n\tint index, ret;\n\n\tdev_info(vpu->dev, \"vpu reset\\n\");\n\tret = vpu_clock_enable(vpu);\n\tif (ret) {\n\t\tdev_err(vpu->dev, \"[VPU] wdt enables clock failed %d\\n\", ret);\n\t\treturn;\n\t}\n\tmutex_lock(&vpu->vpu_mutex);\n\tvpu_cfg_writel(vpu, 0x0, VPU_RESET);\n\tvpu->fw_loaded = false;\n\tmutex_unlock(&vpu->vpu_mutex);\n\tvpu_clock_disable(vpu);\n\n\tfor (index = 0; index < VPU_RST_MAX; index++) {\n\t\tif (handler[index].reset_func) {\n\t\t\thandler[index].reset_func(handler[index].priv);\n\t\t\tdev_dbg(vpu->dev, \"wdt handler func %d\\n\", index);\n\t\t}\n\t}\n}\n\nint vpu_wdt_reg_handler(struct platform_device *pdev,\n\t\t\tvoid wdt_reset(void *),\n\t\t\tvoid *priv, enum rst_id id)\n{\n\tstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\n\tstruct vpu_wdt_handler *handler;\n\n\tif (!vpu) {\n\t\tdev_err(&pdev->dev, \"vpu device in not ready\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\thandler = vpu->wdt.handler;\n\n\tif (id < VPU_RST_MAX && wdt_reset) {\n\t\tdev_dbg(vpu->dev, \"wdt register id %d\\n\", id);\n\t\tmutex_lock(&vpu->vpu_mutex);\n\t\thandler[id].reset_func = wdt_reset;\n\t\thandler[id].priv = priv;\n\t\tmutex_unlock(&vpu->vpu_mutex);\n\t\treturn 0;\n\t}\n\n\tdev_err(vpu->dev, \"register vpu wdt handler failed\\n\");\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(vpu_wdt_reg_handler);\n\nunsigned int vpu_get_vdec_hw_capa(struct platform_device *pdev)\n{\n\tstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\n\n\treturn vpu->run.dec_capability;\n}\nEXPORT_SYMBOL_GPL(vpu_get_vdec_hw_capa);\n\nunsigned int vpu_get_venc_hw_capa(struct platform_device *pdev)\n{\n\tstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\n\n\treturn vpu->run.enc_capability;\n}\nEXPORT_SYMBOL_GPL(vpu_get_venc_hw_capa);\n\nvoid *vpu_mapping_dm_addr(struct platform_device *pdev,\n\t\t\t  u32 dtcm_dmem_addr)\n{\n\tstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\n\n\tif (!dtcm_dmem_addr ||\n\t    (dtcm_dmem_addr > (VPU_DTCM_SIZE + VPU_EXT_D_SIZE))) {\n\t\tdev_err(vpu->dev, \"invalid virtual data memory address\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (dtcm_dmem_addr < VPU_DTCM_SIZE)\n\t\treturn (__force void *)(dtcm_dmem_addr + vpu->reg.tcm +\n\t\t\t\t\tVPU_DTCM_OFFSET);\n\n\treturn vpu->extmem[D_FW].va + (dtcm_dmem_addr - VPU_DTCM_SIZE);\n}\nEXPORT_SYMBOL_GPL(vpu_mapping_dm_addr);\n\nstruct platform_device *vpu_get_plat_device(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *vpu_node;\n\tstruct platform_device *vpu_pdev;\n\n\tvpu_node = of_parse_phandle(dev->of_node, \"mediatek,vpu\", 0);\n\tif (!vpu_node) {\n\t\tdev_err(dev, \"can't get vpu node\\n\");\n\t\treturn NULL;\n\t}\n\n\tvpu_pdev = of_find_device_by_node(vpu_node);\n\tof_node_put(vpu_node);\n\tif (WARN_ON(!vpu_pdev)) {\n\t\tdev_err(dev, \"vpu pdev failed\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn vpu_pdev;\n}\nEXPORT_SYMBOL_GPL(vpu_get_plat_device);\n\n \nstatic int load_requested_vpu(struct mtk_vpu *vpu,\n\t\t\t      u8 fw_type)\n{\n\tsize_t tcm_size = fw_type ? VPU_DTCM_SIZE : VPU_PTCM_SIZE;\n\tsize_t fw_size = fw_type ? VPU_D_FW_SIZE : VPU_P_FW_SIZE;\n\tchar *fw_name = fw_type ? VPU_D_FW : VPU_P_FW;\n\tchar *fw_new_name = fw_type ? VPU_D_FW_NEW : VPU_P_FW_NEW;\n\tconst struct firmware *vpu_fw;\n\tsize_t dl_size = 0;\n\tsize_t extra_fw_size = 0;\n\tvoid *dest;\n\tint ret;\n\n\tret = request_firmware(&vpu_fw, fw_new_name, vpu->dev);\n\tif (ret < 0) {\n\t\tdev_info(vpu->dev, \"Failed to load %s, %d, retry\\n\",\n\t\t\t fw_new_name, ret);\n\n\t\tret = request_firmware(&vpu_fw, fw_name, vpu->dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(vpu->dev, \"Failed to load %s, %d\\n\", fw_name,\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tdl_size = vpu_fw->size;\n\tif (dl_size > fw_size) {\n\t\tdev_err(vpu->dev, \"fw %s size %zu is abnormal\\n\", fw_name,\n\t\t\tdl_size);\n\t\trelease_firmware(vpu_fw);\n\t\treturn  -EFBIG;\n\t}\n\tdev_dbg(vpu->dev, \"Downloaded fw %s size: %zu.\\n\",\n\t\tfw_name,\n\t\tdl_size);\n\t \n\tvpu_cfg_writel(vpu, 0x0, VPU_RESET);\n\n\t \n\tif (dl_size > tcm_size) {\n\t\tdev_dbg(vpu->dev, \"fw size %zu > limited fw size %zu\\n\",\n\t\t\tdl_size, tcm_size);\n\t\textra_fw_size = dl_size - tcm_size;\n\t\tdev_dbg(vpu->dev, \"extra_fw_size %zu\\n\", extra_fw_size);\n\t\tdl_size = tcm_size;\n\t}\n\tdest = (__force void *)vpu->reg.tcm;\n\tif (fw_type == D_FW)\n\t\tdest += VPU_DTCM_OFFSET;\n\tmemcpy(dest, vpu_fw->data, dl_size);\n\t \n\tif (extra_fw_size > 0) {\n\t\tdest = vpu->extmem[fw_type].va;\n\t\tdev_dbg(vpu->dev, \"download extended memory type %x\\n\",\n\t\t\tfw_type);\n\t\tmemcpy(dest, vpu_fw->data + tcm_size, extra_fw_size);\n\t}\n\n\trelease_firmware(vpu_fw);\n\n\treturn 0;\n}\n\nint vpu_load_firmware(struct platform_device *pdev)\n{\n\tstruct mtk_vpu *vpu;\n\tstruct device *dev;\n\tstruct vpu_run *run;\n\tint ret;\n\n\tif (!pdev) {\n\t\tpr_err(\"VPU platform device is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = &pdev->dev;\n\n\tvpu = platform_get_drvdata(pdev);\n\trun = &vpu->run;\n\n\tmutex_lock(&vpu->vpu_mutex);\n\tif (vpu->fw_loaded) {\n\t\tmutex_unlock(&vpu->vpu_mutex);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&vpu->vpu_mutex);\n\n\tret = vpu_clock_enable(vpu);\n\tif (ret) {\n\t\tdev_err(dev, \"enable clock failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&vpu->vpu_mutex);\n\n\trun->signaled = false;\n\tdev_dbg(vpu->dev, \"firmware request\\n\");\n\t \n\tret = load_requested_vpu(vpu, P_FW);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to request %s, %d\\n\", VPU_P_FW, ret);\n\t\tgoto OUT_LOAD_FW;\n\t}\n\n\t \n\tret = load_requested_vpu(vpu, D_FW);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to request %s, %d\\n\", VPU_D_FW, ret);\n\t\tgoto OUT_LOAD_FW;\n\t}\n\n\tvpu->fw_loaded = true;\n\t \n\tvpu_cfg_writel(vpu, 0x1, VPU_RESET);\n\n\tret = wait_event_interruptible_timeout(run->wq,\n\t\t\t\t\t       run->signaled,\n\t\t\t\t\t       msecs_to_jiffies(INIT_TIMEOUT_MS)\n\t\t\t\t\t       );\n\tif (ret == 0) {\n\t\tret = -ETIME;\n\t\tdev_err(dev, \"wait vpu initialization timeout!\\n\");\n\t\tgoto OUT_LOAD_FW;\n\t} else if (-ERESTARTSYS == ret) {\n\t\tdev_err(dev, \"wait vpu interrupted by a signal!\\n\");\n\t\tgoto OUT_LOAD_FW;\n\t}\n\n\tret = 0;\n\tdev_info(dev, \"vpu is ready. Fw version %s\\n\", run->fw_ver);\n\nOUT_LOAD_FW:\n\tmutex_unlock(&vpu->vpu_mutex);\n\tvpu_clock_disable(vpu);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(vpu_load_firmware);\n\nstatic void vpu_init_ipi_handler(const void *data, unsigned int len, void *priv)\n{\n\tstruct mtk_vpu *vpu = priv;\n\tconst struct vpu_run *run = data;\n\n\tvpu->run.signaled = run->signaled;\n\tstrscpy(vpu->run.fw_ver, run->fw_ver, sizeof(vpu->run.fw_ver));\n\tvpu->run.dec_capability = run->dec_capability;\n\tvpu->run.enc_capability = run->enc_capability;\n\twake_up_interruptible(&vpu->run.wq);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic ssize_t vpu_debug_read(struct file *file, char __user *user_buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar buf[256];\n\tunsigned int len;\n\tunsigned int running, pc, vpu_to_host, host_to_vpu, wdt, idle, ra, sp;\n\tint ret;\n\tstruct device *dev = file->private_data;\n\tstruct mtk_vpu *vpu = dev_get_drvdata(dev);\n\n\tret = vpu_clock_enable(vpu);\n\tif (ret) {\n\t\tdev_err(vpu->dev, \"[VPU] enable clock failed %d\\n\", ret);\n\t\treturn 0;\n\t}\n\n\t \n\trunning = vpu_running(vpu);\n\tpc = vpu_cfg_readl(vpu, VPU_PC_REG);\n\twdt = vpu_cfg_readl(vpu, VPU_WDT_REG);\n\thost_to_vpu = vpu_cfg_readl(vpu, HOST_TO_VPU);\n\tvpu_to_host = vpu_cfg_readl(vpu, VPU_TO_HOST);\n\tra = vpu_cfg_readl(vpu, VPU_RA_REG);\n\tsp = vpu_cfg_readl(vpu, VPU_SP_REG);\n\tidle = vpu_cfg_readl(vpu, VPU_IDLE_REG);\n\n\tvpu_clock_disable(vpu);\n\n\tif (running) {\n\t\tlen = snprintf(buf, sizeof(buf), \"VPU is running\\n\\n\"\n\t\t\"FW Version: %s\\n\"\n\t\t\"PC: 0x%x\\n\"\n\t\t\"WDT: 0x%x\\n\"\n\t\t\"Host to VPU: 0x%x\\n\"\n\t\t\"VPU to Host: 0x%x\\n\"\n\t\t\"SP: 0x%x\\n\"\n\t\t\"RA: 0x%x\\n\"\n\t\t\"idle: 0x%x\\n\",\n\t\tvpu->run.fw_ver, pc, wdt,\n\t\thost_to_vpu, vpu_to_host, sp, ra, idle);\n\t} else {\n\t\tlen = snprintf(buf, sizeof(buf), \"VPU not running\\n\");\n\t}\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations vpu_debug_fops = {\n\t.open = simple_open,\n\t.read = vpu_debug_read,\n};\n#endif  \n\nstatic void vpu_free_ext_mem(struct mtk_vpu *vpu, u8 fw_type)\n{\n\tstruct device *dev = vpu->dev;\n\tsize_t fw_ext_size = fw_type ? VPU_EXT_D_SIZE : VPU_EXT_P_SIZE;\n\n\tdma_free_coherent(dev, fw_ext_size, vpu->extmem[fw_type].va,\n\t\t\t  vpu->extmem[fw_type].pa);\n}\n\nstatic int vpu_alloc_ext_mem(struct mtk_vpu *vpu, u32 fw_type)\n{\n\tstruct device *dev = vpu->dev;\n\tsize_t fw_ext_size = fw_type ? VPU_EXT_D_SIZE : VPU_EXT_P_SIZE;\n\tu32 vpu_ext_mem0 = fw_type ? VPU_DMEM_EXT0_ADDR : VPU_PMEM_EXT0_ADDR;\n\tu32 vpu_ext_mem1 = fw_type ? VPU_DMEM_EXT1_ADDR : VPU_PMEM_EXT1_ADDR;\n\tu32 offset_4gb = vpu->enable_4GB ? 0x40000000 : 0;\n\n\tvpu->extmem[fw_type].va = dma_alloc_coherent(dev,\n\t\t\t\t\t       fw_ext_size,\n\t\t\t\t\t       &vpu->extmem[fw_type].pa,\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!vpu->extmem[fw_type].va) {\n\t\tdev_err(dev, \"Failed to allocate the extended program memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tvpu_cfg_writel(vpu, 0x1, vpu_ext_mem0);\n\tvpu_cfg_writel(vpu, (vpu->extmem[fw_type].pa & 0xFFFFF000) + offset_4gb,\n\t\t       vpu_ext_mem1);\n\n\tdev_info(dev, \"%s extend memory phy=0x%llx virt=0x%p\\n\",\n\t\t fw_type ? \"Data\" : \"Program\",\n\t\t (unsigned long long)vpu->extmem[fw_type].pa,\n\t\t vpu->extmem[fw_type].va);\n\n\treturn 0;\n}\n\nstatic void vpu_ipi_handler(struct mtk_vpu *vpu)\n{\n\tstruct share_obj __iomem *rcv_obj = vpu->recv_buf;\n\tstruct vpu_ipi_desc *ipi_desc = vpu->ipi_desc;\n\tunsigned char data[SHARE_BUF_SIZE];\n\ts32 id = readl(&rcv_obj->id);\n\n\tmemcpy_fromio(data, rcv_obj->share_buf, sizeof(data));\n\tif (id < IPI_MAX && ipi_desc[id].handler) {\n\t\tipi_desc[id].handler(data, readl(&rcv_obj->len),\n\t\t\t\t     ipi_desc[id].priv);\n\t\tif (id > IPI_VPU_INIT) {\n\t\t\tvpu->ipi_id_ack[id] = true;\n\t\t\twake_up(&vpu->ack_wq);\n\t\t}\n\t} else {\n\t\tdev_err(vpu->dev, \"No such ipi id = %d\\n\", id);\n\t}\n}\n\nstatic int vpu_ipi_init(struct mtk_vpu *vpu)\n{\n\t \n\tvpu_cfg_writel(vpu, 0x0, VPU_TO_HOST);\n\n\t \n\tvpu->recv_buf = vpu->reg.tcm + VPU_DTCM_OFFSET;\n\tvpu->send_buf = vpu->recv_buf + 1;\n\tmemset_io(vpu->recv_buf, 0, sizeof(struct share_obj));\n\tmemset_io(vpu->send_buf, 0, sizeof(struct share_obj));\n\n\treturn 0;\n}\n\nstatic irqreturn_t vpu_irq_handler(int irq, void *priv)\n{\n\tstruct mtk_vpu *vpu = priv;\n\tu32 vpu_to_host;\n\tint ret;\n\n\t \n\tret = clk_enable(vpu->clk);\n\tif (ret) {\n\t\tdev_err(vpu->dev, \"[VPU] enable clock failed %d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\tvpu_to_host = vpu_cfg_readl(vpu, VPU_TO_HOST);\n\tif (vpu_to_host & VPU_IPC_INT) {\n\t\tvpu_ipi_handler(vpu);\n\t} else {\n\t\tdev_err(vpu->dev, \"vpu watchdog timeout! 0x%x\", vpu_to_host);\n\t\tqueue_work(vpu->wdt.wq, &vpu->wdt.ws);\n\t}\n\n\t \n\tvpu_cfg_writel(vpu, 0x0, VPU_TO_HOST);\n\tclk_disable(vpu->clk);\n\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic struct dentry *vpu_debugfs;\n#endif\nstatic int mtk_vpu_probe(struct platform_device *pdev)\n{\n\tstruct mtk_vpu *vpu;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tdev_dbg(&pdev->dev, \"initialization\\n\");\n\n\tdev = &pdev->dev;\n\tvpu = devm_kzalloc(dev, sizeof(*vpu), GFP_KERNEL);\n\tif (!vpu)\n\t\treturn -ENOMEM;\n\n\tvpu->dev = &pdev->dev;\n\tvpu->reg.tcm = devm_platform_ioremap_resource_byname(pdev, \"tcm\");\n\tif (IS_ERR((__force void *)vpu->reg.tcm))\n\t\treturn PTR_ERR((__force void *)vpu->reg.tcm);\n\n\tvpu->reg.cfg = devm_platform_ioremap_resource_byname(pdev, \"cfg_reg\");\n\tif (IS_ERR((__force void *)vpu->reg.cfg))\n\t\treturn PTR_ERR((__force void *)vpu->reg.cfg);\n\n\t \n\tvpu->clk = devm_clk_get(dev, \"main\");\n\tif (IS_ERR(vpu->clk)) {\n\t\tdev_err(dev, \"get vpu clock failed\\n\");\n\t\treturn PTR_ERR(vpu->clk);\n\t}\n\n\tplatform_set_drvdata(pdev, vpu);\n\n\tret = clk_prepare(vpu->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"prepare vpu clock failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tvpu->wdt.wq = create_singlethread_workqueue(\"vpu_wdt\");\n\tif (!vpu->wdt.wq) {\n\t\tdev_err(dev, \"initialize wdt workqueue failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clk_unprepare;\n\t}\n\tINIT_WORK(&vpu->wdt.ws, vpu_wdt_reset_func);\n\tmutex_init(&vpu->vpu_mutex);\n\n\tret = vpu_clock_enable(vpu);\n\tif (ret) {\n\t\tdev_err(dev, \"enable vpu clock failed\\n\");\n\t\tgoto workqueue_destroy;\n\t}\n\n\tdev_dbg(dev, \"vpu ipi init\\n\");\n\tret = vpu_ipi_init(vpu);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init ipi\\n\");\n\t\tgoto disable_vpu_clk;\n\t}\n\n\t \n\tret = vpu_ipi_register(pdev, IPI_VPU_INIT, vpu_init_ipi_handler,\n\t\t\t       \"vpu_init\", vpu);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register IPI_VPU_INIT\\n\");\n\t\tgoto vpu_mutex_destroy;\n\t}\n\n#ifdef CONFIG_DEBUG_FS\n\tvpu_debugfs = debugfs_create_file(\"mtk_vpu\", S_IRUGO, NULL, (void *)dev,\n\t\t\t\t\t  &vpu_debug_fops);\n#endif\n\n\t \n\tvpu_cfg_writel(vpu, 0x2, VPU_TCM_CFG);\n\n\tvpu->enable_4GB = !!(totalram_pages() > (SZ_2G >> PAGE_SHIFT));\n\tdev_info(dev, \"4GB mode %u\\n\", vpu->enable_4GB);\n\n\tif (vpu->enable_4GB) {\n\t\tret = of_reserved_mem_device_init(dev);\n\t\tif (ret)\n\t\t\tdev_info(dev, \"init reserved memory failed\\n\");\n\t\t\t \n\t}\n\n\tret = vpu_alloc_ext_mem(vpu, D_FW);\n\tif (ret) {\n\t\tdev_err(dev, \"Allocate DM failed\\n\");\n\t\tgoto remove_debugfs;\n\t}\n\n\tret = vpu_alloc_ext_mem(vpu, P_FW);\n\tif (ret) {\n\t\tdev_err(dev, \"Allocate PM failed\\n\");\n\t\tgoto free_d_mem;\n\t}\n\n\tinit_waitqueue_head(&vpu->run.wq);\n\tinit_waitqueue_head(&vpu->ack_wq);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto free_p_mem;\n\tvpu->reg.irq = ret;\n\tret = devm_request_irq(dev, vpu->reg.irq, vpu_irq_handler, 0,\n\t\t\t       pdev->name, vpu);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\tgoto free_p_mem;\n\t}\n\n\tvpu_clock_disable(vpu);\n\tdev_dbg(dev, \"initialization completed\\n\");\n\n\treturn 0;\n\nfree_p_mem:\n\tvpu_free_ext_mem(vpu, P_FW);\nfree_d_mem:\n\tvpu_free_ext_mem(vpu, D_FW);\nremove_debugfs:\n\tof_reserved_mem_device_release(dev);\n#ifdef CONFIG_DEBUG_FS\n\tdebugfs_remove(vpu_debugfs);\n#endif\n\tmemset(vpu->ipi_desc, 0, sizeof(struct vpu_ipi_desc) * IPI_MAX);\nvpu_mutex_destroy:\n\tmutex_destroy(&vpu->vpu_mutex);\ndisable_vpu_clk:\n\tvpu_clock_disable(vpu);\nworkqueue_destroy:\n\tdestroy_workqueue(vpu->wdt.wq);\nclk_unprepare:\n\tclk_unprepare(vpu->clk);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id mtk_vpu_match[] = {\n\t{\n\t\t.compatible = \"mediatek,mt8173-vpu\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_vpu_match);\n\nstatic void mtk_vpu_remove(struct platform_device *pdev)\n{\n\tstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\n\n#ifdef CONFIG_DEBUG_FS\n\tdebugfs_remove(vpu_debugfs);\n#endif\n\tif (vpu->wdt.wq)\n\t\tdestroy_workqueue(vpu->wdt.wq);\n\tvpu_free_ext_mem(vpu, P_FW);\n\tvpu_free_ext_mem(vpu, D_FW);\n\tmutex_destroy(&vpu->vpu_mutex);\n\tclk_unprepare(vpu->clk);\n}\n\nstatic int mtk_vpu_suspend(struct device *dev)\n{\n\tstruct mtk_vpu *vpu = dev_get_drvdata(dev);\n\tunsigned long timeout;\n\tint ret;\n\n\tret = vpu_clock_enable(vpu);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable vpu clock\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!vpu_running(vpu)) {\n\t\tvpu_clock_disable(vpu);\n\t\tclk_unprepare(vpu->clk);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&vpu->vpu_mutex);\n\t \n\tvpu_cfg_writel(vpu, vpu_cfg_readl(vpu, VPU_INT_STATUS) | VPU_IDLE_STATE,\n\t\t       VPU_INT_STATUS);\n\t \n\ttimeout = jiffies + msecs_to_jiffies(VPU_IDLE_TIMEOUT_MS);\n\tdo {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(dev, \"vpu idle timeout\\n\");\n\t\t\tmutex_unlock(&vpu->vpu_mutex);\n\t\t\tvpu_clock_disable(vpu);\n\t\t\treturn -EIO;\n\t\t}\n\t} while (!vpu_cfg_readl(vpu, VPU_IDLE_REG));\n\n\tmutex_unlock(&vpu->vpu_mutex);\n\tvpu_clock_disable(vpu);\n\tclk_unprepare(vpu->clk);\n\n\treturn 0;\n}\n\nstatic int mtk_vpu_resume(struct device *dev)\n{\n\tstruct mtk_vpu *vpu = dev_get_drvdata(dev);\n\tint ret;\n\n\tclk_prepare(vpu->clk);\n\tret = vpu_clock_enable(vpu);\n\tif (ret) {\n\t\tclk_unprepare(vpu->clk);\n\t\tdev_err(dev, \"failed to enable vpu clock\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&vpu->vpu_mutex);\n\t \n\tvpu_cfg_writel(vpu,\n\t\t       vpu_cfg_readl(vpu, VPU_INT_STATUS) & ~(VPU_IDLE_STATE),\n\t\t       VPU_INT_STATUS);\n\tmutex_unlock(&vpu->vpu_mutex);\n\tvpu_clock_disable(vpu);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mtk_vpu_pm = {\n\t.suspend = mtk_vpu_suspend,\n\t.resume = mtk_vpu_resume,\n};\n\nstatic struct platform_driver mtk_vpu_driver = {\n\t.probe\t= mtk_vpu_probe,\n\t.remove_new = mtk_vpu_remove,\n\t.driver\t= {\n\t\t.name\t= \"mtk_vpu\",\n\t\t.pm = &mtk_vpu_pm,\n\t\t.of_match_table = mtk_vpu_match,\n\t},\n};\n\nmodule_platform_driver(mtk_vpu_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Mediatek Video Processor Unit driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}