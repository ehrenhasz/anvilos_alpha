{
  "module_name": "mtk_mdp_m2m.c",
  "hash_id": "8a8b7da51a6ca970db240499d4af7b2179234fe1be439758931f4b89c6f4e9af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/mdp/mtk_mdp_m2m.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"mtk_mdp_core.h\"\n#include \"mtk_mdp_m2m.h\"\n#include \"mtk_mdp_regs.h\"\n#include \"mtk_vpu.h\"\n\n\n \nstruct mtk_mdp_pix_limit {\n\tu16 org_w;\n\tu16 org_h;\n\tu16 target_rot_dis_w;\n\tu16 target_rot_dis_h;\n\tu16 target_rot_en_w;\n\tu16 target_rot_en_h;\n};\n\nstatic struct mtk_mdp_pix_align mtk_mdp_size_align = {\n\t.org_w\t\t\t= 16,\n\t.org_h\t\t\t= 16,\n\t.target_w\t\t= 2,\n\t.target_h\t\t= 2,\n};\n\nstatic const struct mtk_mdp_fmt mtk_mdp_formats[] = {\n\t{\n\t\t.pixelformat\t= V4L2_PIX_FMT_MT21C,\n\t\t.depth\t\t= { 8, 4 },\n\t\t.row_depth\t= { 8, 8 },\n\t\t.num_planes\t= 2,\n\t\t.num_comp\t= 2,\n\t\t.align\t\t= &mtk_mdp_size_align,\n\t\t.flags\t\t= MTK_MDP_FMT_FLAG_OUTPUT,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_NV12M,\n\t\t.depth\t\t= { 8, 4 },\n\t\t.row_depth\t= { 8, 8 },\n\t\t.num_planes\t= 2,\n\t\t.num_comp\t= 2,\n\t\t.flags\t\t= MTK_MDP_FMT_FLAG_OUTPUT |\n\t\t\t\t  MTK_MDP_FMT_FLAG_CAPTURE,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YUV420M,\n\t\t.depth\t\t= { 8, 2, 2 },\n\t\t.row_depth\t= { 8, 4, 4 },\n\t\t.num_planes\t= 3,\n\t\t.num_comp\t= 3,\n\t\t.flags\t\t= MTK_MDP_FMT_FLAG_OUTPUT |\n\t\t\t\t  MTK_MDP_FMT_FLAG_CAPTURE,\n\t}, {\n\t\t.pixelformat\t= V4L2_PIX_FMT_YVU420,\n\t\t.depth\t\t= { 12 },\n\t\t.row_depth\t= { 8 },\n\t\t.num_planes\t= 1,\n\t\t.num_comp\t= 3,\n\t\t.flags\t\t= MTK_MDP_FMT_FLAG_OUTPUT |\n\t\t\t\t  MTK_MDP_FMT_FLAG_CAPTURE,\n\t}\n};\n\nstatic struct mtk_mdp_pix_limit mtk_mdp_size_max = {\n\t.target_rot_dis_w\t= 4096,\n\t.target_rot_dis_h\t= 4096,\n\t.target_rot_en_w\t= 4096,\n\t.target_rot_en_h\t= 4096,\n};\n\nstatic struct mtk_mdp_pix_limit mtk_mdp_size_min = {\n\t.org_w\t\t\t= 16,\n\t.org_h\t\t\t= 16,\n\t.target_rot_dis_w\t= 16,\n\t.target_rot_dis_h\t= 16,\n\t.target_rot_en_w\t= 16,\n\t.target_rot_en_h\t= 16,\n};\n\n \nstatic struct mtk_mdp_pix_align mtk_mdp_rs_align = {\n\t.org_w\t\t\t= 2,\n\t.org_h\t\t\t= 2,\n\t.target_w\t\t= 2,\n\t.target_h\t\t= 2,\n};\n\nstatic struct mtk_mdp_variant mtk_mdp_default_variant = {\n\t.pix_max\t\t= &mtk_mdp_size_max,\n\t.pix_min\t\t= &mtk_mdp_size_min,\n\t.pix_align\t\t= &mtk_mdp_rs_align,\n\t.h_scale_up_max\t\t= 32,\n\t.v_scale_up_max\t\t= 32,\n\t.h_scale_down_max\t= 32,\n\t.v_scale_down_max\t= 128,\n};\n\nstatic const struct mtk_mdp_fmt *mtk_mdp_find_fmt(u32 pixelformat, u32 type)\n{\n\tu32 i, flag;\n\n\tflag = V4L2_TYPE_IS_OUTPUT(type) ? MTK_MDP_FMT_FLAG_OUTPUT :\n\t\t\t\t\t   MTK_MDP_FMT_FLAG_CAPTURE;\n\n\tfor (i = 0; i < ARRAY_SIZE(mtk_mdp_formats); ++i) {\n\t\tif (!(mtk_mdp_formats[i].flags & flag))\n\t\t\tcontinue;\n\t\tif (mtk_mdp_formats[i].pixelformat == pixelformat)\n\t\t\treturn &mtk_mdp_formats[i];\n\t}\n\treturn NULL;\n}\n\nstatic const struct mtk_mdp_fmt *mtk_mdp_find_fmt_by_index(u32 index, u32 type)\n{\n\tu32 i, flag, num = 0;\n\n\tflag = V4L2_TYPE_IS_OUTPUT(type) ? MTK_MDP_FMT_FLAG_OUTPUT :\n\t\t\t\t\t   MTK_MDP_FMT_FLAG_CAPTURE;\n\n\tfor (i = 0; i < ARRAY_SIZE(mtk_mdp_formats); ++i) {\n\t\tif (!(mtk_mdp_formats[i].flags & flag))\n\t\t\tcontinue;\n\t\tif (index == num)\n\t\t\treturn &mtk_mdp_formats[i];\n\t\tnum++;\n\t}\n\treturn NULL;\n}\n\nstatic void mtk_mdp_bound_align_image(u32 *w, unsigned int wmin,\n\t\t\t\t      unsigned int wmax, unsigned int align_w,\n\t\t\t\t      u32 *h, unsigned int hmin,\n\t\t\t\t      unsigned int hmax, unsigned int align_h)\n{\n\tint org_w, org_h, step_w, step_h;\n\tint walign, halign;\n\n\torg_w = *w;\n\torg_h = *h;\n\twalign = ffs(align_w) - 1;\n\thalign = ffs(align_h) - 1;\n\tv4l_bound_align_image(w, wmin, wmax, walign, h, hmin, hmax, halign, 0);\n\n\tstep_w = 1 << walign;\n\tstep_h = 1 << halign;\n\tif (*w < org_w && (*w + step_w) <= wmax)\n\t\t*w += step_w;\n\tif (*h < org_h && (*h + step_h) <= hmax)\n\t\t*h += step_h;\n}\n\nstatic const struct mtk_mdp_fmt *mtk_mdp_try_fmt_mplane(struct mtk_mdp_ctx *ctx,\n\t\t\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\n\tstruct mtk_mdp_variant *variant = mdp->variant;\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tconst struct mtk_mdp_fmt *fmt;\n\tu32 max_w, max_h, align_w, align_h;\n\tu32 min_w, min_h, org_w, org_h;\n\tint i;\n\n\tfmt = mtk_mdp_find_fmt(pix_mp->pixelformat, f->type);\n\tif (!fmt)\n\t\tfmt = mtk_mdp_find_fmt_by_index(0, f->type);\n\tif (!fmt) {\n\t\tdev_dbg(&ctx->mdp_dev->pdev->dev,\n\t\t\t\"pixelformat format 0x%X invalid\\n\",\n\t\t\tpix_mp->pixelformat);\n\t\treturn NULL;\n\t}\n\n\tpix_mp->field = V4L2_FIELD_NONE;\n\tpix_mp->pixelformat = fmt->pixelformat;\n\tif (V4L2_TYPE_IS_CAPTURE(f->type)) {\n\t\tpix_mp->colorspace = ctx->colorspace;\n\t\tpix_mp->xfer_func = ctx->xfer_func;\n\t\tpix_mp->ycbcr_enc = ctx->ycbcr_enc;\n\t\tpix_mp->quantization = ctx->quant;\n\t}\n\n\tmax_w = variant->pix_max->target_rot_dis_w;\n\tmax_h = variant->pix_max->target_rot_dis_h;\n\n\tif (fmt->align == NULL) {\n\t\t \n\t\talign_w = variant->pix_align->org_w;\n\t\talign_h = variant->pix_align->org_h;\n\t} else {\n\t\talign_w = fmt->align->org_w;\n\t\talign_h = fmt->align->org_h;\n\t}\n\n\tif (V4L2_TYPE_IS_OUTPUT(f->type)) {\n\t\tmin_w = variant->pix_min->org_w;\n\t\tmin_h = variant->pix_min->org_h;\n\t} else {\n\t\tmin_w = variant->pix_min->target_rot_dis_w;\n\t\tmin_h = variant->pix_min->target_rot_dis_h;\n\t}\n\n\tmtk_mdp_dbg(2, \"[%d] type:%d, wxh:%ux%u, align:%ux%u, max:%ux%u\",\n\t\t    ctx->id, f->type, pix_mp->width, pix_mp->height,\n\t\t    align_w, align_h, max_w, max_h);\n\t \n\torg_w = pix_mp->width;\n\torg_h = pix_mp->height;\n\n\tmtk_mdp_bound_align_image(&pix_mp->width, min_w, max_w, align_w,\n\t\t\t\t  &pix_mp->height, min_h, max_h, align_h);\n\n\tif (org_w != pix_mp->width || org_h != pix_mp->height)\n\t\tmtk_mdp_dbg(1, \"[%d] size change:%ux%u to %ux%u\", ctx->id,\n\t\t\t    org_w, org_h, pix_mp->width, pix_mp->height);\n\tpix_mp->num_planes = fmt->num_planes;\n\n\tfor (i = 0; i < pix_mp->num_planes; ++i) {\n\t\tint bpl = (pix_mp->width * fmt->row_depth[i]) / 8;\n\t\tint sizeimage = (pix_mp->width * pix_mp->height *\n\t\t\tfmt->depth[i]) / 8;\n\n\t\tpix_mp->plane_fmt[i].bytesperline = bpl;\n\t\tif (pix_mp->plane_fmt[i].sizeimage < sizeimage)\n\t\t\tpix_mp->plane_fmt[i].sizeimage = sizeimage;\n\t\tmtk_mdp_dbg(2, \"[%d] p%d, bpl:%d, sizeimage:%u (%u)\", ctx->id,\n\t\t\t    i, bpl, pix_mp->plane_fmt[i].sizeimage, sizeimage);\n\t}\n\n\treturn fmt;\n}\n\nstatic struct mtk_mdp_frame *mtk_mdp_ctx_get_frame(struct mtk_mdp_ctx *ctx,\n\t\t\t\t\t    enum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn &ctx->s_frame;\n\treturn &ctx->d_frame;\n}\n\nstatic void mtk_mdp_check_crop_change(u32 new_w, u32 new_h, u32 *w, u32 *h)\n{\n\tif (new_w != *w || new_h != *h) {\n\t\tmtk_mdp_dbg(1, \"size change:%dx%d to %dx%d\",\n\t\t\t    *w, *h, new_w, new_h);\n\n\t\t*w = new_w;\n\t\t*h = new_h;\n\t}\n}\n\nstatic int mtk_mdp_try_crop(struct mtk_mdp_ctx *ctx, u32 type,\n\t\t\t    struct v4l2_rect *r)\n{\n\tstruct mtk_mdp_frame *frame;\n\tstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\n\tstruct mtk_mdp_variant *variant = mdp->variant;\n\tu32 align_w, align_h, new_w, new_h;\n\tu32 min_w, min_h, max_w, max_h;\n\n\tif (r->top < 0 || r->left < 0) {\n\t\tdev_err(&ctx->mdp_dev->pdev->dev,\n\t\t\t\"doesn't support negative values for top & left\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_mdp_dbg(2, \"[%d] type:%d, set wxh:%dx%d\", ctx->id, type,\n\t\t    r->width, r->height);\n\n\tframe = mtk_mdp_ctx_get_frame(ctx, type);\n\tmax_w = frame->width;\n\tmax_h = frame->height;\n\tnew_w = r->width;\n\tnew_h = r->height;\n\n\tif (V4L2_TYPE_IS_OUTPUT(type)) {\n\t\talign_w = 1;\n\t\talign_h = 1;\n\t\tmin_w = 64;\n\t\tmin_h = 32;\n\t} else {\n\t\talign_w = variant->pix_align->target_w;\n\t\talign_h = variant->pix_align->target_h;\n\t\tif (ctx->ctrls.rotate->val == 90 ||\n\t\t    ctx->ctrls.rotate->val == 270) {\n\t\t\tmax_w = frame->height;\n\t\t\tmax_h = frame->width;\n\t\t\tmin_w = variant->pix_min->target_rot_en_w;\n\t\t\tmin_h = variant->pix_min->target_rot_en_h;\n\t\t\tnew_w = r->height;\n\t\t\tnew_h = r->width;\n\t\t} else {\n\t\t\tmin_w = variant->pix_min->target_rot_dis_w;\n\t\t\tmin_h = variant->pix_min->target_rot_dis_h;\n\t\t}\n\t}\n\n\tmtk_mdp_dbg(2, \"[%d] align:%dx%d, min:%dx%d, new:%dx%d\", ctx->id,\n\t\t    align_w, align_h, min_w, min_h, new_w, new_h);\n\n\tmtk_mdp_bound_align_image(&new_w, min_w, max_w, align_w,\n\t\t\t\t  &new_h, min_h, max_h, align_h);\n\n\tif (V4L2_TYPE_IS_CAPTURE(type) &&\n\t    (ctx->ctrls.rotate->val == 90 || ctx->ctrls.rotate->val == 270))\n\t\tmtk_mdp_check_crop_change(new_h, new_w,\n\t\t\t\t\t  &r->width, &r->height);\n\telse\n\t\tmtk_mdp_check_crop_change(new_w, new_h,\n\t\t\t\t\t  &r->width, &r->height);\n\n\t \n\t \n\tif (r->left + new_w > max_w)\n\t\tr->left = max_w - new_w;\n\tif (r->top + new_h > max_h)\n\t\tr->top = max_h - new_h;\n\n\tif (r->left & 1)\n\t\tr->left -= 1;\n\n\tmtk_mdp_dbg(2, \"[%d] crop l,t,w,h:%d,%d,%d,%d, max:%dx%d\", ctx->id,\n\t\t    r->left, r->top, r->width,\n\t\t    r->height, max_w, max_h);\n\treturn 0;\n}\n\nstatic inline struct mtk_mdp_ctx *fh_to_ctx(struct v4l2_fh *fh)\n{\n\treturn container_of(fh, struct mtk_mdp_ctx, fh);\n}\n\nstatic inline struct mtk_mdp_ctx *ctrl_to_ctx(struct v4l2_ctrl *ctrl)\n{\n\treturn container_of(ctrl->handler, struct mtk_mdp_ctx, ctrl_handler);\n}\n\nvoid mtk_mdp_ctx_state_lock_set(struct mtk_mdp_ctx *ctx, u32 state)\n{\n\tmutex_lock(&ctx->slock);\n\tctx->state |= state;\n\tmutex_unlock(&ctx->slock);\n}\n\nstatic bool mtk_mdp_ctx_state_is_set(struct mtk_mdp_ctx *ctx, u32 mask)\n{\n\tbool ret;\n\n\tmutex_lock(&ctx->slock);\n\tret = (ctx->state & mask) == mask;\n\tmutex_unlock(&ctx->slock);\n\treturn ret;\n}\n\nstatic void mtk_mdp_set_frame_size(struct mtk_mdp_frame *frame, int width,\n\t\t\t\t   int height)\n{\n\tframe->width = width;\n\tframe->height = height;\n\tframe->crop.width = width;\n\tframe->crop.height = height;\n\tframe->crop.left = 0;\n\tframe->crop.top = 0;\n}\n\nstatic int mtk_mdp_m2m_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct mtk_mdp_ctx *ctx = q->drv_priv;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(&ctx->mdp_dev->pdev->dev);\n\tif (ret < 0)\n\t\tmtk_mdp_dbg(1, \"[%d] pm_runtime_resume_and_get failed:%d\",\n\t\t\t    ctx->id, ret);\n\n\treturn ret;\n}\n\nstatic void *mtk_mdp_m2m_buf_remove(struct mtk_mdp_ctx *ctx,\n\t\t\t\t    enum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\telse\n\t\treturn v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\n}\n\nstatic void mtk_mdp_m2m_stop_streaming(struct vb2_queue *q)\n{\n\tstruct mtk_mdp_ctx *ctx = q->drv_priv;\n\tstruct vb2_buffer *vb;\n\n\tvb = mtk_mdp_m2m_buf_remove(ctx, q->type);\n\twhile (vb != NULL) {\n\t\tv4l2_m2m_buf_done(to_vb2_v4l2_buffer(vb), VB2_BUF_STATE_ERROR);\n\t\tvb = mtk_mdp_m2m_buf_remove(ctx, q->type);\n\t}\n\n\tpm_runtime_put(&ctx->mdp_dev->pdev->dev);\n}\n\n \nstatic void mtk_mdp_prepare_addr(struct mtk_mdp_ctx *ctx,\n\t\t\t\t struct vb2_buffer *vb,\n\t\t\t\t struct mtk_mdp_frame *frame,\n\t\t\t\t struct mtk_mdp_addr *addr)\n{\n\tu32 pix_size, planes, i;\n\n\tpix_size = frame->width * frame->height;\n\tplanes = min_t(u32, frame->fmt->num_planes, ARRAY_SIZE(addr->addr));\n\tfor (i = 0; i < planes; i++)\n\t\taddr->addr[i] = vb2_dma_contig_plane_dma_addr(vb, i);\n\n\tif (planes == 1) {\n\t\tif (frame->fmt->pixelformat == V4L2_PIX_FMT_YVU420) {\n\t\t\taddr->addr[1] = (dma_addr_t)(addr->addr[0] + pix_size);\n\t\t\taddr->addr[2] = (dma_addr_t)(addr->addr[1] +\n\t\t\t\t\t(pix_size >> 2));\n\t\t} else {\n\t\t\tdev_err(&ctx->mdp_dev->pdev->dev,\n\t\t\t\t\"Invalid pixelformat:0x%x\\n\",\n\t\t\t\tframe->fmt->pixelformat);\n\t\t}\n\t}\n\tmtk_mdp_dbg(3, \"[%d] planes:%d, size:%d, addr:%p,%p,%p\",\n\t\t    ctx->id, planes, pix_size, (void *)addr->addr[0],\n\t\t    (void *)addr->addr[1], (void *)addr->addr[2]);\n}\n\nstatic void mtk_mdp_m2m_get_bufs(struct mtk_mdp_ctx *ctx)\n{\n\tstruct mtk_mdp_frame *s_frame, *d_frame;\n\tstruct vb2_v4l2_buffer *src_vbuf, *dst_vbuf;\n\n\ts_frame = &ctx->s_frame;\n\td_frame = &ctx->d_frame;\n\n\tsrc_vbuf = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\n\tmtk_mdp_prepare_addr(ctx, &src_vbuf->vb2_buf, s_frame, &s_frame->addr);\n\n\tdst_vbuf = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\n\tmtk_mdp_prepare_addr(ctx, &dst_vbuf->vb2_buf, d_frame, &d_frame->addr);\n\n\tdst_vbuf->vb2_buf.timestamp = src_vbuf->vb2_buf.timestamp;\n}\n\nstatic void mtk_mdp_process_done(void *priv, int vb_state)\n{\n\tstruct mtk_mdp_dev *mdp = priv;\n\tstruct mtk_mdp_ctx *ctx;\n\tstruct vb2_v4l2_buffer *src_vbuf, *dst_vbuf;\n\n\tctx = v4l2_m2m_get_curr_priv(mdp->m2m_dev);\n\tif (!ctx)\n\t\treturn;\n\n\tsrc_vbuf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\tdst_vbuf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\n\n\tdst_vbuf->vb2_buf.timestamp = src_vbuf->vb2_buf.timestamp;\n\tdst_vbuf->timecode = src_vbuf->timecode;\n\tdst_vbuf->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst_vbuf->flags |= src_vbuf->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\tv4l2_m2m_buf_done(src_vbuf, vb_state);\n\tv4l2_m2m_buf_done(dst_vbuf, vb_state);\n\tv4l2_m2m_job_finish(ctx->mdp_dev->m2m_dev, ctx->m2m_ctx);\n}\n\nstatic void mtk_mdp_m2m_worker(struct work_struct *work)\n{\n\tstruct mtk_mdp_ctx *ctx =\n\t\t\t\tcontainer_of(work, struct mtk_mdp_ctx, work);\n\tstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\n\tenum vb2_buffer_state buf_state = VB2_BUF_STATE_ERROR;\n\tint ret;\n\n\tif (mtk_mdp_ctx_state_is_set(ctx, MTK_MDP_CTX_ERROR)) {\n\t\tdev_err(&mdp->pdev->dev, \"ctx is in error state\");\n\t\tgoto worker_end;\n\t}\n\n\tmtk_mdp_m2m_get_bufs(ctx);\n\n\tmtk_mdp_hw_set_input_addr(ctx, &ctx->s_frame.addr);\n\tmtk_mdp_hw_set_output_addr(ctx, &ctx->d_frame.addr);\n\n\tmtk_mdp_hw_set_in_size(ctx);\n\tmtk_mdp_hw_set_in_image_format(ctx);\n\n\tmtk_mdp_hw_set_out_size(ctx);\n\tmtk_mdp_hw_set_out_image_format(ctx);\n\n\tmtk_mdp_hw_set_rotation(ctx);\n\tmtk_mdp_hw_set_global_alpha(ctx);\n\n\tret = mtk_mdp_vpu_process(&ctx->vpu);\n\tif (ret) {\n\t\tdev_err(&mdp->pdev->dev, \"processing failed: %d\", ret);\n\t\tgoto worker_end;\n\t}\n\n\tbuf_state = VB2_BUF_STATE_DONE;\n\nworker_end:\n\tmtk_mdp_process_done(mdp, buf_state);\n}\n\nstatic void mtk_mdp_m2m_device_run(void *priv)\n{\n\tstruct mtk_mdp_ctx *ctx = priv;\n\n\tqueue_work(ctx->mdp_dev->job_wq, &ctx->work);\n}\n\nstatic int mtk_mdp_m2m_queue_setup(struct vb2_queue *vq,\n\t\t\tunsigned int *num_buffers, unsigned int *num_planes,\n\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct mtk_mdp_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct mtk_mdp_frame *frame;\n\tint i;\n\n\tframe = mtk_mdp_ctx_get_frame(ctx, vq->type);\n\t*num_planes = frame->fmt->num_planes;\n\tfor (i = 0; i < frame->fmt->num_planes; i++)\n\t\tsizes[i] = frame->payload[i];\n\tmtk_mdp_dbg(2, \"[%d] type:%d, planes:%d, buffers:%d, size:%u,%u\",\n\t\t    ctx->id, vq->type, *num_planes, *num_buffers,\n\t\t    sizes[0], sizes[1]);\n\treturn 0;\n}\n\nstatic int mtk_mdp_m2m_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct mtk_mdp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct mtk_mdp_frame *frame;\n\tint i;\n\n\tframe = mtk_mdp_ctx_get_frame(ctx, vb->vb2_queue->type);\n\n\tif (!V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\n\t\tfor (i = 0; i < frame->fmt->num_planes; i++)\n\t\t\tvb2_set_plane_payload(vb, i, frame->payload[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_mdp_m2m_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct mtk_mdp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->m2m_ctx, to_vb2_v4l2_buffer(vb));\n}\n\nstatic const struct vb2_ops mtk_mdp_m2m_qops = {\n\t.queue_setup\t = mtk_mdp_m2m_queue_setup,\n\t.buf_prepare\t = mtk_mdp_m2m_buf_prepare,\n\t.buf_queue\t = mtk_mdp_m2m_buf_queue,\n\t.stop_streaming\t = mtk_mdp_m2m_stop_streaming,\n\t.start_streaming = mtk_mdp_m2m_start_streaming,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n};\n\nstatic int mtk_mdp_m2m_querycap(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\n\tstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\n\n\tstrscpy(cap->driver, MTK_MDP_MODULE_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, mdp->pdev->name, sizeof(cap->card));\n\tstrscpy(cap->bus_info, \"platform:mt8173\", sizeof(cap->bus_info));\n\n\treturn 0;\n}\n\nstatic int mtk_mdp_enum_fmt(struct v4l2_fmtdesc *f, u32 type)\n{\n\tconst struct mtk_mdp_fmt *fmt;\n\n\tfmt = mtk_mdp_find_fmt_by_index(f->index, type);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = fmt->pixelformat;\n\n\treturn 0;\n}\n\nstatic int mtk_mdp_m2m_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\treturn mtk_mdp_enum_fmt(f, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n}\n\nstatic int mtk_mdp_m2m_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\treturn mtk_mdp_enum_fmt(f, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n}\n\nstatic int mtk_mdp_m2m_g_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\n\tstruct mtk_mdp_frame *frame;\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tint i;\n\n\tmtk_mdp_dbg(2, \"[%d] type:%d\", ctx->id, f->type);\n\n\tframe = mtk_mdp_ctx_get_frame(ctx, f->type);\n\tpix_mp = &f->fmt.pix_mp;\n\n\tpix_mp->width = frame->width;\n\tpix_mp->height = frame->height;\n\tpix_mp->field = V4L2_FIELD_NONE;\n\tpix_mp->pixelformat = frame->fmt->pixelformat;\n\tpix_mp->num_planes = frame->fmt->num_planes;\n\tpix_mp->colorspace = ctx->colorspace;\n\tpix_mp->xfer_func = ctx->xfer_func;\n\tpix_mp->ycbcr_enc = ctx->ycbcr_enc;\n\tpix_mp->quantization = ctx->quant;\n\tmtk_mdp_dbg(2, \"[%d] wxh:%dx%d\", ctx->id,\n\t\t    pix_mp->width, pix_mp->height);\n\n\tfor (i = 0; i < pix_mp->num_planes; ++i) {\n\t\tpix_mp->plane_fmt[i].bytesperline = (frame->width *\n\t\t\tframe->fmt->row_depth[i]) / 8;\n\t\tpix_mp->plane_fmt[i].sizeimage = (frame->width *\n\t\t\tframe->height * frame->fmt->depth[i]) / 8;\n\n\t\tmtk_mdp_dbg(2, \"[%d] p%d, bpl:%d, sizeimage:%d\", ctx->id, i,\n\t\t\t    pix_mp->plane_fmt[i].bytesperline,\n\t\t\t    pix_mp->plane_fmt[i].sizeimage);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_mdp_m2m_try_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_format *f)\n{\n\tstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\n\n\tif (!mtk_mdp_try_fmt_mplane(ctx, f))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int mtk_mdp_m2m_s_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\n\tstruct vb2_queue *vq;\n\tstruct mtk_mdp_frame *frame;\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tconst struct mtk_mdp_fmt *fmt;\n\tint i;\n\n\tmtk_mdp_dbg(2, \"[%d] type:%d\", ctx->id, f->type);\n\n\tframe = mtk_mdp_ctx_get_frame(ctx, f->type);\n\tfmt = mtk_mdp_try_fmt_mplane(ctx, f);\n\tif (!fmt) {\n\t\tmtk_mdp_err(\"[%d] try_fmt failed, type:%d\", ctx->id, f->type);\n\t\treturn -EINVAL;\n\t}\n\tframe->fmt = fmt;\n\n\tvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\n\tif (vb2_is_streaming(vq)) {\n\t\tdev_info(&ctx->mdp_dev->pdev->dev, \"queue %d busy\", f->type);\n\t\treturn -EBUSY;\n\t}\n\n\tpix_mp = &f->fmt.pix_mp;\n\tfor (i = 0; i < frame->fmt->num_planes; i++) {\n\t\tframe->payload[i] = pix_mp->plane_fmt[i].sizeimage;\n\t\tframe->pitch[i] = pix_mp->plane_fmt[i].bytesperline;\n\t}\n\n\tmtk_mdp_set_frame_size(frame, pix_mp->width, pix_mp->height);\n\tif (V4L2_TYPE_IS_OUTPUT(f->type)) {\n\t\tctx->colorspace = pix_mp->colorspace;\n\t\tctx->xfer_func = pix_mp->xfer_func;\n\t\tctx->ycbcr_enc = pix_mp->ycbcr_enc;\n\t\tctx->quant = pix_mp->quantization;\n\t}\n\n\tmtk_mdp_dbg(2, \"[%d] type:%d, frame:%dx%d\", ctx->id, f->type,\n\t\t    frame->width, frame->height);\n\n\treturn 0;\n}\n\nstatic int mtk_mdp_m2m_reqbufs(struct file *file, void *fh,\n\t\t\t       struct v4l2_requestbuffers *reqbufs)\n{\n\tstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\n\n\treturn v4l2_m2m_reqbufs(file, ctx->m2m_ctx, reqbufs);\n}\n\nstatic int mtk_mdp_m2m_streamon(struct file *file, void *fh,\n\t\t\t\tenum v4l2_buf_type type)\n{\n\tstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\n\tint ret;\n\n\tif (!mtk_mdp_ctx_state_is_set(ctx, MTK_MDP_VPU_INIT)) {\n\t\tret = mtk_mdp_vpu_init(&ctx->vpu);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&ctx->mdp_dev->pdev->dev,\n\t\t\t\t\"vpu init failed %d\\n\",\n\t\t\t\tret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmtk_mdp_ctx_state_lock_set(ctx, MTK_MDP_VPU_INIT);\n\t}\n\n\treturn v4l2_m2m_streamon(file, ctx->m2m_ctx, type);\n}\n\nstatic inline bool mtk_mdp_is_target_compose(u32 target)\n{\n\tif (target == V4L2_SEL_TGT_COMPOSE_DEFAULT\n\t    || target == V4L2_SEL_TGT_COMPOSE_BOUNDS\n\t    || target == V4L2_SEL_TGT_COMPOSE)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool mtk_mdp_is_target_crop(u32 target)\n{\n\tif (target == V4L2_SEL_TGT_CROP_DEFAULT\n\t    || target == V4L2_SEL_TGT_CROP_BOUNDS\n\t    || target == V4L2_SEL_TGT_CROP)\n\t\treturn true;\n\treturn false;\n}\n\nstatic int mtk_mdp_m2m_g_selection(struct file *file, void *fh,\n\t\t\t\t       struct v4l2_selection *s)\n{\n\tstruct mtk_mdp_frame *frame;\n\tstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\n\tbool valid = false;\n\n\tif (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tif (mtk_mdp_is_target_compose(s->target))\n\t\t\tvalid = true;\n\t} else if (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tif (mtk_mdp_is_target_crop(s->target))\n\t\t\tvalid = true;\n\t}\n\tif (!valid) {\n\t\tmtk_mdp_dbg(1, \"[%d] invalid type:%d,%u\", ctx->id, s->type,\n\t\t\t    s->target);\n\t\treturn -EINVAL;\n\t}\n\n\tframe = mtk_mdp_ctx_get_frame(ctx, s->type);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = frame->width;\n\t\ts->r.height = frame->height;\n\t\treturn 0;\n\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_CROP:\n\t\ts->r.left = frame->crop.left;\n\t\ts->r.top = frame->crop.top;\n\t\ts->r.width = frame->crop.width;\n\t\ts->r.height = frame->crop.height;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mtk_mdp_check_scaler_ratio(struct mtk_mdp_variant *var, int src_w,\n\t\t\t\t      int src_h, int dst_w, int dst_h, int rot)\n{\n\tint tmp_w, tmp_h;\n\n\tif (rot == 90 || rot == 270) {\n\t\ttmp_w = dst_h;\n\t\ttmp_h = dst_w;\n\t} else {\n\t\ttmp_w = dst_w;\n\t\ttmp_h = dst_h;\n\t}\n\n\tif ((src_w / tmp_w) > var->h_scale_down_max ||\n\t    (src_h / tmp_h) > var->v_scale_down_max ||\n\t    (tmp_w / src_w) > var->h_scale_up_max ||\n\t    (tmp_h / src_h) > var->v_scale_up_max)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int mtk_mdp_m2m_s_selection(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_selection *s)\n{\n\tstruct mtk_mdp_frame *frame;\n\tstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\n\tstruct v4l2_rect new_r;\n\tstruct mtk_mdp_variant *variant = ctx->mdp_dev->variant;\n\tint ret;\n\tbool valid = false;\n\n\tif (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tif (s->target == V4L2_SEL_TGT_COMPOSE)\n\t\t\tvalid = true;\n\t} else if (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tif (s->target == V4L2_SEL_TGT_CROP)\n\t\t\tvalid = true;\n\t}\n\tif (!valid) {\n\t\tmtk_mdp_dbg(1, \"[%d] invalid type:%d,%u\", ctx->id, s->type,\n\t\t\t    s->target);\n\t\treturn -EINVAL;\n\t}\n\n\tnew_r = s->r;\n\tret = mtk_mdp_try_crop(ctx, s->type, &new_r);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mtk_mdp_is_target_crop(s->target))\n\t\tframe = &ctx->s_frame;\n\telse\n\t\tframe = &ctx->d_frame;\n\n\t \n\tif (V4L2_TYPE_IS_OUTPUT(s->type))\n\t\tret = mtk_mdp_check_scaler_ratio(variant, new_r.width,\n\t\t\tnew_r.height, ctx->d_frame.crop.width,\n\t\t\tctx->d_frame.crop.height,\n\t\t\tctx->ctrls.rotate->val);\n\telse\n\t\tret = mtk_mdp_check_scaler_ratio(variant,\n\t\t\tctx->s_frame.crop.width,\n\t\t\tctx->s_frame.crop.height, new_r.width,\n\t\t\tnew_r.height, ctx->ctrls.rotate->val);\n\n\tif (ret) {\n\t\tdev_info(&ctx->mdp_dev->pdev->dev,\n\t\t\t\"Out of scaler range\");\n\t\treturn -EINVAL;\n\t}\n\n\ts->r = new_r;\n\tframe->crop = new_r;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops mtk_mdp_m2m_ioctl_ops = {\n\t.vidioc_querycap\t\t= mtk_mdp_m2m_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= mtk_mdp_m2m_enum_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_out\t= mtk_mdp_m2m_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_cap_mplane\t= mtk_mdp_m2m_g_fmt_mplane,\n\t.vidioc_g_fmt_vid_out_mplane\t= mtk_mdp_m2m_g_fmt_mplane,\n\t.vidioc_try_fmt_vid_cap_mplane\t= mtk_mdp_m2m_try_fmt_mplane,\n\t.vidioc_try_fmt_vid_out_mplane\t= mtk_mdp_m2m_try_fmt_mplane,\n\t.vidioc_s_fmt_vid_cap_mplane\t= mtk_mdp_m2m_s_fmt_mplane,\n\t.vidioc_s_fmt_vid_out_mplane\t= mtk_mdp_m2m_s_fmt_mplane,\n\t.vidioc_reqbufs\t\t\t= mtk_mdp_m2m_reqbufs,\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_streamon\t\t= mtk_mdp_m2m_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\t.vidioc_g_selection\t\t= mtk_mdp_m2m_g_selection,\n\t.vidioc_s_selection\t\t= mtk_mdp_m2m_s_selection\n};\n\nstatic int mtk_mdp_m2m_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t\t  struct vb2_queue *dst_vq)\n{\n\tstruct mtk_mdp_ctx *ctx = priv;\n\tint ret;\n\n\tmemset(src_vq, 0, sizeof(*src_vq));\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->ops = &mtk_mdp_m2m_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->dev = &ctx->mdp_dev->pdev->dev;\n\tsrc_vq->lock = &ctx->mdp_dev->lock;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(dst_vq, 0, sizeof(*dst_vq));\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->ops = &mtk_mdp_m2m_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->dev = &ctx->mdp_dev->pdev->dev;\n\tdst_vq->lock = &ctx->mdp_dev->lock;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int mtk_mdp_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mtk_mdp_ctx *ctx = ctrl_to_ctx(ctrl);\n\tstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\n\tstruct mtk_mdp_variant *variant = mdp->variant;\n\tint ret = 0;\n\n\tif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\n\t\treturn 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tctx->hflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tctx->vflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_ROTATE:\n\t\tret = mtk_mdp_check_scaler_ratio(variant,\n\t\t\t\tctx->s_frame.crop.width,\n\t\t\t\tctx->s_frame.crop.height,\n\t\t\t\tctx->d_frame.crop.width,\n\t\t\t\tctx->d_frame.crop.height,\n\t\t\t\tctx->ctrls.rotate->val);\n\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\tctx->rotation = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_ALPHA_COMPONENT:\n\t\tctx->d_frame.alpha = ctrl->val;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops mtk_mdp_ctrl_ops = {\n\t.s_ctrl = mtk_mdp_s_ctrl,\n};\n\nstatic int mtk_mdp_ctrls_create(struct mtk_mdp_ctx *ctx)\n{\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, MTK_MDP_MAX_CTRL_NUM);\n\n\tctx->ctrls.rotate = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t&mtk_mdp_ctrl_ops, V4L2_CID_ROTATE, 0, 270, 90, 0);\n\tctx->ctrls.hflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t\t\t     &mtk_mdp_ctrl_ops,\n\t\t\t\t\t     V4L2_CID_HFLIP,\n\t\t\t\t\t     0, 1, 1, 0);\n\tctx->ctrls.vflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t\t\t     &mtk_mdp_ctrl_ops,\n\t\t\t\t\t     V4L2_CID_VFLIP,\n\t\t\t\t\t     0, 1, 1, 0);\n\tctx->ctrls.global_alpha = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t\t\t\t    &mtk_mdp_ctrl_ops,\n\t\t\t\t\t\t    V4L2_CID_ALPHA_COMPONENT,\n\t\t\t\t\t\t    0, 255, 1, 0);\n\tctx->ctrls_rdy = ctx->ctrl_handler.error == 0;\n\n\tif (ctx->ctrl_handler.error) {\n\t\tint err = ctx->ctrl_handler.error;\n\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\t\tdev_err(&ctx->mdp_dev->pdev->dev,\n\t\t\t\"Failed to create control handlers\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_mdp_set_default_params(struct mtk_mdp_ctx *ctx)\n{\n\tstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\n\tstruct mtk_mdp_frame *frame;\n\n\tframe = mtk_mdp_ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\tframe->fmt = mtk_mdp_find_fmt_by_index(0,\n\t\t\t\t\tV4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\tframe->width = mdp->variant->pix_min->org_w;\n\tframe->height = mdp->variant->pix_min->org_h;\n\tframe->payload[0] = frame->width * frame->height;\n\tframe->payload[1] = frame->payload[0] / 2;\n\n\tframe = mtk_mdp_ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tframe->fmt = mtk_mdp_find_fmt_by_index(0,\n\t\t\t\t\tV4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tframe->width = mdp->variant->pix_min->target_rot_dis_w;\n\tframe->height = mdp->variant->pix_min->target_rot_dis_h;\n\tframe->payload[0] = frame->width * frame->height;\n\tframe->payload[1] = frame->payload[0] / 2;\n\n}\n\nstatic int mtk_mdp_m2m_open(struct file *file)\n{\n\tstruct mtk_mdp_dev *mdp = video_drvdata(file);\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct mtk_mdp_ctx *ctx = NULL;\n\tint ret;\n\tstruct v4l2_format default_format;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (mutex_lock_interruptible(&mdp->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto err_lock;\n\t}\n\n\tmutex_init(&ctx->slock);\n\tctx->id = mdp->id_counter++;\n\tv4l2_fh_init(&ctx->fh, vfd);\n\tfile->private_data = &ctx->fh;\n\tret = mtk_mdp_ctrls_create(ctx);\n\tif (ret)\n\t\tgoto error_ctrls;\n\n\t \n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\tv4l2_fh_add(&ctx->fh);\n\tINIT_LIST_HEAD(&ctx->list);\n\n\tctx->mdp_dev = mdp;\n\tmtk_mdp_set_default_params(ctx);\n\n\tINIT_WORK(&ctx->work, mtk_mdp_m2m_worker);\n\tctx->m2m_ctx = v4l2_m2m_ctx_init(mdp->m2m_dev, ctx,\n\t\t\t\t\t mtk_mdp_m2m_queue_init);\n\tif (IS_ERR(ctx->m2m_ctx)) {\n\t\tdev_err(&mdp->pdev->dev, \"Failed to initialize m2m context\");\n\t\tret = PTR_ERR(ctx->m2m_ctx);\n\t\tgoto error_m2m_ctx;\n\t}\n\tctx->fh.m2m_ctx = ctx->m2m_ctx;\n\tif (mdp->ctx_num++ == 0) {\n\t\tret = vpu_load_firmware(mdp->vpu_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&mdp->pdev->dev,\n\t\t\t\t\"vpu_load_firmware failed %d\\n\", ret);\n\t\t\tgoto err_load_vpu;\n\t\t}\n\n\t\tret = mtk_mdp_vpu_register(mdp->pdev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&mdp->pdev->dev,\n\t\t\t\t\"mdp_vpu register failed %d\\n\", ret);\n\t\t\tgoto err_load_vpu;\n\t\t}\n\t}\n\n\tlist_add(&ctx->list, &mdp->ctx_list);\n\tmutex_unlock(&mdp->lock);\n\n\t \n\tmemset(&default_format, 0, sizeof(default_format));\n\tdefault_format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tdefault_format.fmt.pix_mp.width = 32;\n\tdefault_format.fmt.pix_mp.height = 32;\n\tdefault_format.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_YUV420M;\n\tmtk_mdp_m2m_s_fmt_mplane(file, &ctx->fh, &default_format);\n\tdefault_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tmtk_mdp_m2m_s_fmt_mplane(file, &ctx->fh, &default_format);\n\n\tmtk_mdp_dbg(0, \"%s [%d]\", dev_name(&mdp->pdev->dev), ctx->id);\n\n\treturn 0;\n\nerr_load_vpu:\n\tmdp->ctx_num--;\n\tv4l2_m2m_ctx_release(ctx->m2m_ctx);\nerror_m2m_ctx:\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\nerror_ctrls:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tmutex_unlock(&mdp->lock);\nerr_lock:\n\tkfree(ctx);\n\n\treturn ret;\n}\n\nstatic int mtk_mdp_m2m_release(struct file *file)\n{\n\tstruct mtk_mdp_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\n\n\tflush_workqueue(mdp->job_wq);\n\tmutex_lock(&mdp->lock);\n\tv4l2_m2m_ctx_release(ctx->m2m_ctx);\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tmtk_mdp_vpu_deinit(&ctx->vpu);\n\tmdp->ctx_num--;\n\tlist_del_init(&ctx->list);\n\n\tmtk_mdp_dbg(0, \"%s [%d]\", dev_name(&mdp->pdev->dev), ctx->id);\n\n\tmutex_unlock(&mdp->lock);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations mtk_mdp_m2m_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= mtk_mdp_m2m_open,\n\t.release\t= mtk_mdp_m2m_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct v4l2_m2m_ops mtk_mdp_m2m_ops = {\n\t.device_run\t= mtk_mdp_m2m_device_run,\n};\n\nint mtk_mdp_register_m2m_device(struct mtk_mdp_dev *mdp)\n{\n\tstruct device *dev = &mdp->pdev->dev;\n\tint ret;\n\n\tmdp->variant = &mtk_mdp_default_variant;\n\tmdp->vdev = video_device_alloc();\n\tif (!mdp->vdev) {\n\t\tdev_err(dev, \"failed to allocate video device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_video_alloc;\n\t}\n\tmdp->vdev->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;\n\tmdp->vdev->fops = &mtk_mdp_m2m_fops;\n\tmdp->vdev->ioctl_ops = &mtk_mdp_m2m_ioctl_ops;\n\tmdp->vdev->release = video_device_release;\n\tmdp->vdev->lock = &mdp->lock;\n\tmdp->vdev->vfl_dir = VFL_DIR_M2M;\n\tmdp->vdev->v4l2_dev = &mdp->v4l2_dev;\n\tsnprintf(mdp->vdev->name, sizeof(mdp->vdev->name), \"%s:m2m\",\n\t\t MTK_MDP_MODULE_NAME);\n\tvideo_set_drvdata(mdp->vdev, mdp);\n\n\tmdp->m2m_dev = v4l2_m2m_init(&mtk_mdp_m2m_ops);\n\tif (IS_ERR(mdp->m2m_dev)) {\n\t\tdev_err(dev, \"failed to initialize v4l2-m2m device\\n\");\n\t\tret = PTR_ERR(mdp->m2m_dev);\n\t\tgoto err_m2m_init;\n\t}\n\n\tret = video_register_device(mdp->vdev, VFL_TYPE_VIDEO, 2);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register video device\\n\");\n\t\tgoto err_vdev_register;\n\t}\n\n\tv4l2_info(&mdp->v4l2_dev, \"driver registered as /dev/video%d\",\n\t\t  mdp->vdev->num);\n\treturn 0;\n\nerr_vdev_register:\n\tv4l2_m2m_release(mdp->m2m_dev);\nerr_m2m_init:\n\tvideo_device_release(mdp->vdev);\nerr_video_alloc:\n\n\treturn ret;\n}\n\nvoid mtk_mdp_unregister_m2m_device(struct mtk_mdp_dev *mdp)\n{\n\tvideo_unregister_device(mdp->vdev);\n\tv4l2_m2m_release(mdp->m2m_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}