{
  "module_name": "mtk_jpeg_core.c",
  "hash_id": "2b16f9c541c3054b61d1fcd24af85da62f740984d4545c372c20eb06407e5e94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/jpeg/mtk_jpeg_core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-core.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"mtk_jpeg_enc_hw.h\"\n#include \"mtk_jpeg_dec_hw.h\"\n#include \"mtk_jpeg_core.h\"\n#include \"mtk_jpeg_dec_parse.h\"\n\nstatic struct mtk_jpeg_fmt mtk_jpeg_enc_formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_JPEG,\n\t\t.colplanes\t= 1,\n\t\t.flags\t\t= MTK_JPEG_FMT_FLAG_CAPTURE,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12M,\n\t\t.hw_format\t= JPEG_ENC_YUV_FORMAT_NV12,\n\t\t.h_sample\t= {4, 4},\n\t\t.v_sample\t= {4, 2},\n\t\t.colplanes\t= 2,\n\t\t.h_align\t= 4,\n\t\t.v_align\t= 4,\n\t\t.flags\t\t= MTK_JPEG_FMT_FLAG_OUTPUT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV21M,\n\t\t.hw_format\t= JEPG_ENC_YUV_FORMAT_NV21,\n\t\t.h_sample\t= {4, 4},\n\t\t.v_sample\t= {4, 2},\n\t\t.colplanes\t= 2,\n\t\t.h_align\t= 4,\n\t\t.v_align\t= 4,\n\t\t.flags\t\t= MTK_JPEG_FMT_FLAG_OUTPUT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.hw_format\t= JPEG_ENC_YUV_FORMAT_YUYV,\n\t\t.h_sample\t= {8},\n\t\t.v_sample\t= {4},\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 5,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MTK_JPEG_FMT_FLAG_OUTPUT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YVYU,\n\t\t.hw_format\t= JPEG_ENC_YUV_FORMAT_YVYU,\n\t\t.h_sample\t= {8},\n\t\t.v_sample\t= {4},\n\t\t.colplanes\t= 1,\n\t\t.h_align\t= 5,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MTK_JPEG_FMT_FLAG_OUTPUT,\n\t},\n};\n\nstatic struct mtk_jpeg_fmt mtk_jpeg_dec_formats[] = {\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_JPEG,\n\t\t.colplanes\t= 1,\n\t\t.flags\t\t= MTK_JPEG_FMT_FLAG_OUTPUT,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV420M,\n\t\t.h_sample\t= {4, 2, 2},\n\t\t.v_sample\t= {4, 2, 2},\n\t\t.colplanes\t= 3,\n\t\t.h_align\t= 5,\n\t\t.v_align\t= 4,\n\t\t.flags\t\t= MTK_JPEG_FMT_FLAG_CAPTURE,\n\t},\n\t{\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV422M,\n\t\t.h_sample\t= {4, 2, 2},\n\t\t.v_sample\t= {4, 4, 4},\n\t\t.colplanes\t= 3,\n\t\t.h_align\t= 5,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MTK_JPEG_FMT_FLAG_CAPTURE,\n\t},\n};\n\n#define MTK_JPEG_ENC_NUM_FORMATS ARRAY_SIZE(mtk_jpeg_enc_formats)\n#define MTK_JPEG_DEC_NUM_FORMATS ARRAY_SIZE(mtk_jpeg_dec_formats)\n#define MTK_JPEG_MAX_RETRY_TIME 5000\n\nenum {\n\tMTK_JPEG_BUF_FLAGS_INIT\t\t\t= 0,\n\tMTK_JPEG_BUF_FLAGS_LAST_FRAME\t\t= 1,\n};\n\nstatic int debug;\nmodule_param(debug, int, 0644);\n\nstatic inline struct mtk_jpeg_ctx *ctrl_to_ctx(struct v4l2_ctrl *ctrl)\n{\n\treturn container_of(ctrl->handler, struct mtk_jpeg_ctx, ctrl_hdl);\n}\n\nstatic inline struct mtk_jpeg_ctx *mtk_jpeg_fh_to_ctx(struct v4l2_fh *fh)\n{\n\treturn container_of(fh, struct mtk_jpeg_ctx, fh);\n}\n\nstatic inline struct mtk_jpeg_src_buf *mtk_jpeg_vb2_to_srcbuf(\n\t\t\t\t\t\t\tstruct vb2_buffer *vb)\n{\n\treturn container_of(to_vb2_v4l2_buffer(vb), struct mtk_jpeg_src_buf, b);\n}\n\nstatic int mtk_jpeg_querycap(struct file *file, void *priv,\n\t\t\t     struct v4l2_capability *cap)\n{\n\tstruct mtk_jpeg_dev *jpeg = video_drvdata(file);\n\n\tstrscpy(cap->driver, jpeg->variant->dev_name, sizeof(cap->driver));\n\tstrscpy(cap->card, jpeg->variant->dev_name, sizeof(cap->card));\n\n\treturn 0;\n}\n\nstatic int vidioc_jpeg_enc_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mtk_jpeg_ctx *ctx = ctrl_to_ctx(ctrl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_JPEG_RESTART_INTERVAL:\n\t\tctx->restart_interval = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\tctx->enc_quality = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_JPEG_ACTIVE_MARKER:\n\t\tctx->enable_exif = ctrl->val & V4L2_JPEG_ACTIVE_MARKER_APP1;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops mtk_jpeg_enc_ctrl_ops = {\n\t.s_ctrl = vidioc_jpeg_enc_s_ctrl,\n};\n\nstatic int mtk_jpeg_enc_ctrls_setup(struct mtk_jpeg_ctx *ctx)\n{\n\tconst struct v4l2_ctrl_ops *ops = &mtk_jpeg_enc_ctrl_ops;\n\tstruct v4l2_ctrl_handler *handler = &ctx->ctrl_hdl;\n\n\tv4l2_ctrl_handler_init(handler, 3);\n\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_JPEG_RESTART_INTERVAL, 0, 100,\n\t\t\t  1, 0);\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_JPEG_COMPRESSION_QUALITY, 48,\n\t\t\t  100, 1, 90);\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_JPEG_ACTIVE_MARKER, 0,\n\t\t\t  V4L2_JPEG_ACTIVE_MARKER_APP1, 0, 0);\n\n\tif (handler->error) {\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\n\t\treturn handler->error;\n\t}\n\n\tv4l2_ctrl_handler_setup(&ctx->ctrl_hdl);\n\n\treturn 0;\n}\n\nstatic int mtk_jpeg_enum_fmt(struct mtk_jpeg_fmt *mtk_jpeg_formats, int n,\n\t\t\t     struct v4l2_fmtdesc *f, u32 type)\n{\n\tint i, num = 0;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tif (mtk_jpeg_formats[i].flags & type) {\n\t\t\tif (num == f->index)\n\t\t\t\tbreak;\n\t\t\t++num;\n\t\t}\n\t}\n\n\tif (i >= n)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = mtk_jpeg_formats[i].fourcc;\n\n\treturn 0;\n}\n\nstatic int mtk_jpeg_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_fmtdesc *f)\n{\n\tstruct mtk_jpeg_ctx *ctx = mtk_jpeg_fh_to_ctx(priv);\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\n\treturn mtk_jpeg_enum_fmt(jpeg->variant->formats,\n\t\t\t\t jpeg->variant->num_formats, f,\n\t\t\t\t MTK_JPEG_FMT_FLAG_CAPTURE);\n}\n\nstatic int mtk_jpeg_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_fmtdesc *f)\n{\n\tstruct mtk_jpeg_ctx *ctx = mtk_jpeg_fh_to_ctx(priv);\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\n\treturn mtk_jpeg_enum_fmt(jpeg->variant->formats,\n\t\t\t\t jpeg->variant->num_formats, f,\n\t\t\t\t MTK_JPEG_FMT_FLAG_OUTPUT);\n}\n\nstatic struct mtk_jpeg_q_data *mtk_jpeg_get_q_data(struct mtk_jpeg_ctx *ctx,\n\t\t\t\t\t\t   enum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn &ctx->out_q;\n\treturn &ctx->cap_q;\n}\n\nstatic struct mtk_jpeg_fmt *\nmtk_jpeg_find_format(struct mtk_jpeg_fmt *mtk_jpeg_formats, int num_formats,\n\t\t     u32 pixelformat, unsigned int fmt_type)\n{\n\tunsigned int k;\n\tstruct mtk_jpeg_fmt *fmt;\n\n\tfor (k = 0; k < num_formats; k++) {\n\t\tfmt = &mtk_jpeg_formats[k];\n\n\t\tif (fmt->fourcc == pixelformat && fmt->flags & fmt_type)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nstatic int mtk_jpeg_try_fmt_mplane(struct v4l2_pix_format_mplane *pix_mp,\n\t\t\t\t   struct mtk_jpeg_fmt *fmt)\n{\n\tint i;\n\n\tpix_mp->field = V4L2_FIELD_NONE;\n\n\tpix_mp->num_planes = fmt->colplanes;\n\tpix_mp->pixelformat = fmt->fourcc;\n\n\tif (fmt->fourcc == V4L2_PIX_FMT_JPEG) {\n\t\tstruct v4l2_plane_pix_format *pfmt = &pix_mp->plane_fmt[0];\n\n\t\tpix_mp->height = clamp(pix_mp->height, MTK_JPEG_MIN_HEIGHT,\n\t\t\t\t       MTK_JPEG_MAX_HEIGHT);\n\t\tpix_mp->width = clamp(pix_mp->width, MTK_JPEG_MIN_WIDTH,\n\t\t\t\t      MTK_JPEG_MAX_WIDTH);\n\n\t\tpfmt->bytesperline = 0;\n\t\t \n\t\tpfmt->sizeimage = round_up(pfmt->sizeimage, 128);\n\t\tif (pfmt->sizeimage == 0)\n\t\t\tpfmt->sizeimage = MTK_JPEG_DEFAULT_SIZEIMAGE;\n\t\treturn 0;\n\t}\n\n\t \n\tpix_mp->height = clamp(round_up(pix_mp->height, fmt->v_align),\n\t\t\t       MTK_JPEG_MIN_HEIGHT, MTK_JPEG_MAX_HEIGHT);\n\tpix_mp->width = clamp(round_up(pix_mp->width, fmt->h_align),\n\t\t\t      MTK_JPEG_MIN_WIDTH, MTK_JPEG_MAX_WIDTH);\n\n\tfor (i = 0; i < fmt->colplanes; i++) {\n\t\tstruct v4l2_plane_pix_format *pfmt = &pix_mp->plane_fmt[i];\n\t\tu32 stride = pix_mp->width * fmt->h_sample[i] / 4;\n\t\tu32 h = pix_mp->height * fmt->v_sample[i] / 4;\n\n\t\tpfmt->bytesperline = stride;\n\t\tpfmt->sizeimage = stride * h;\n\t}\n\treturn 0;\n}\n\nstatic int mtk_jpeg_g_fmt_vid_mplane(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct mtk_jpeg_q_data *q_data = NULL;\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tstruct mtk_jpeg_ctx *ctx = mtk_jpeg_fh_to_ctx(priv);\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tint i;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = mtk_jpeg_get_q_data(ctx, f->type);\n\n\tpix_mp->width = q_data->pix_mp.width;\n\tpix_mp->height = q_data->pix_mp.height;\n\tpix_mp->field = V4L2_FIELD_NONE;\n\tpix_mp->pixelformat = q_data->fmt->fourcc;\n\tpix_mp->num_planes = q_data->fmt->colplanes;\n\tpix_mp->colorspace = q_data->pix_mp.colorspace;\n\tpix_mp->ycbcr_enc = q_data->pix_mp.ycbcr_enc;\n\tpix_mp->xfer_func = q_data->pix_mp.xfer_func;\n\tpix_mp->quantization = q_data->pix_mp.quantization;\n\n\tv4l2_dbg(1, debug, &jpeg->v4l2_dev, \"(%d) g_fmt:%c%c%c%c wxh:%ux%u\\n\",\n\t\t f->type,\n\t\t (pix_mp->pixelformat & 0xff),\n\t\t (pix_mp->pixelformat >>  8 & 0xff),\n\t\t (pix_mp->pixelformat >> 16 & 0xff),\n\t\t (pix_mp->pixelformat >> 24 & 0xff),\n\t\t pix_mp->width, pix_mp->height);\n\n\tfor (i = 0; i < pix_mp->num_planes; i++) {\n\t\tstruct v4l2_plane_pix_format *pfmt = &pix_mp->plane_fmt[i];\n\n\t\tpfmt->bytesperline = q_data->pix_mp.plane_fmt[i].bytesperline;\n\t\tpfmt->sizeimage = q_data->pix_mp.plane_fmt[i].sizeimage;\n\n\t\tv4l2_dbg(1, debug, &jpeg->v4l2_dev,\n\t\t\t \"plane[%d] bpl=%u, size=%u\\n\",\n\t\t\t i,\n\t\t\t pfmt->bytesperline,\n\t\t\t pfmt->sizeimage);\n\t}\n\treturn 0;\n}\n\nstatic int mtk_jpeg_try_fmt_vid_cap_mplane(struct file *file, void *priv,\n\t\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct mtk_jpeg_ctx *ctx = mtk_jpeg_fh_to_ctx(priv);\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tstruct mtk_jpeg_fmt *fmt;\n\n\tfmt = mtk_jpeg_find_format(jpeg->variant->formats,\n\t\t\t\t   jpeg->variant->num_formats,\n\t\t\t\t   f->fmt.pix_mp.pixelformat,\n\t\t\t\t   MTK_JPEG_FMT_FLAG_CAPTURE);\n\tif (!fmt)\n\t\tfmt = ctx->cap_q.fmt;\n\n\tv4l2_dbg(2, debug, &ctx->jpeg->v4l2_dev, \"(%d) try_fmt:%c%c%c%c\\n\",\n\t\t f->type,\n\t\t (fmt->fourcc & 0xff),\n\t\t (fmt->fourcc >>  8 & 0xff),\n\t\t (fmt->fourcc >> 16 & 0xff),\n\t\t (fmt->fourcc >> 24 & 0xff));\n\n\tif (ctx->state != MTK_JPEG_INIT) {\n\t\tmtk_jpeg_g_fmt_vid_mplane(file, priv, f);\n\t\treturn 0;\n\t}\n\n\treturn mtk_jpeg_try_fmt_mplane(&f->fmt.pix_mp, fmt);\n}\n\nstatic int mtk_jpeg_try_fmt_vid_out_mplane(struct file *file, void *priv,\n\t\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct mtk_jpeg_ctx *ctx = mtk_jpeg_fh_to_ctx(priv);\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tstruct mtk_jpeg_fmt *fmt;\n\n\tfmt = mtk_jpeg_find_format(jpeg->variant->formats,\n\t\t\t\t   jpeg->variant->num_formats,\n\t\t\t\t   f->fmt.pix_mp.pixelformat,\n\t\t\t\t   MTK_JPEG_FMT_FLAG_OUTPUT);\n\tif (!fmt)\n\t\tfmt = ctx->out_q.fmt;\n\n\tv4l2_dbg(2, debug, &ctx->jpeg->v4l2_dev, \"(%d) try_fmt:%c%c%c%c\\n\",\n\t\t f->type,\n\t\t (fmt->fourcc & 0xff),\n\t\t (fmt->fourcc >>  8 & 0xff),\n\t\t (fmt->fourcc >> 16 & 0xff),\n\t\t (fmt->fourcc >> 24 & 0xff));\n\n\tif (ctx->state != MTK_JPEG_INIT) {\n\t\tmtk_jpeg_g_fmt_vid_mplane(file, priv, f);\n\t\treturn 0;\n\t}\n\n\treturn mtk_jpeg_try_fmt_mplane(&f->fmt.pix_mp, fmt);\n}\n\nstatic int mtk_jpeg_s_fmt_mplane(struct mtk_jpeg_ctx *ctx,\n\t\t\t\t struct v4l2_format *f, unsigned int fmt_type)\n{\n\tstruct vb2_queue *vq;\n\tstruct mtk_jpeg_q_data *q_data = NULL;\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tint i;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = mtk_jpeg_get_q_data(ctx, f->type);\n\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"queue busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tq_data->fmt = mtk_jpeg_find_format(jpeg->variant->formats,\n\t\t\t\t\t   jpeg->variant->num_formats,\n\t\t\t\t\t   pix_mp->pixelformat, fmt_type);\n\tq_data->pix_mp.width = pix_mp->width;\n\tq_data->pix_mp.height = pix_mp->height;\n\tq_data->enc_crop_rect.width = pix_mp->width;\n\tq_data->enc_crop_rect.height = pix_mp->height;\n\tq_data->pix_mp.colorspace = V4L2_COLORSPACE_SRGB;\n\tq_data->pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_601;\n\tq_data->pix_mp.xfer_func = V4L2_XFER_FUNC_SRGB;\n\tq_data->pix_mp.quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\n\tv4l2_dbg(1, debug, &jpeg->v4l2_dev, \"(%d) s_fmt:%c%c%c%c wxh:%ux%u\\n\",\n\t\t f->type,\n\t\t (q_data->fmt->fourcc & 0xff),\n\t\t (q_data->fmt->fourcc >>  8 & 0xff),\n\t\t (q_data->fmt->fourcc >> 16 & 0xff),\n\t\t (q_data->fmt->fourcc >> 24 & 0xff),\n\t\t q_data->pix_mp.width, q_data->pix_mp.height);\n\n\tfor (i = 0; i < q_data->fmt->colplanes; i++) {\n\t\tq_data->pix_mp.plane_fmt[i].bytesperline =\n\t\t\t\t\tpix_mp->plane_fmt[i].bytesperline;\n\t\tq_data->pix_mp.plane_fmt[i].sizeimage =\n\t\t\t\t\tpix_mp->plane_fmt[i].sizeimage;\n\n\t\tv4l2_dbg(1, debug, &jpeg->v4l2_dev,\n\t\t\t \"plane[%d] bpl=%u, size=%u\\n\",\n\t\t\t i, q_data->pix_mp.plane_fmt[i].bytesperline,\n\t\t\t q_data->pix_mp.plane_fmt[i].sizeimage);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_jpeg_s_fmt_vid_out_mplane(struct file *file, void *priv,\n\t\t\t\t\t struct v4l2_format *f)\n{\n\tint ret;\n\n\tret = mtk_jpeg_try_fmt_vid_out_mplane(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mtk_jpeg_s_fmt_mplane(mtk_jpeg_fh_to_ctx(priv), f,\n\t\t\t\t     MTK_JPEG_FMT_FLAG_OUTPUT);\n}\n\nstatic int mtk_jpeg_s_fmt_vid_cap_mplane(struct file *file, void *priv,\n\t\t\t\t\t struct v4l2_format *f)\n{\n\tint ret;\n\n\tret = mtk_jpeg_try_fmt_vid_cap_mplane(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mtk_jpeg_s_fmt_mplane(mtk_jpeg_fh_to_ctx(priv), f,\n\t\t\t\t     MTK_JPEG_FMT_FLAG_CAPTURE);\n}\n\nstatic void mtk_jpeg_queue_src_chg_event(struct mtk_jpeg_ctx *ctx)\n{\n\tstatic const struct v4l2_event ev_src_ch = {\n\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t.u.src_change.changes =\n\t\tV4L2_EVENT_SRC_CH_RESOLUTION,\n\t};\n\n\tv4l2_event_queue_fh(&ctx->fh, &ev_src_ch);\n}\n\nstatic int mtk_jpeg_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t    const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subscribe(fh, sub);\n\t}\n\n\treturn v4l2_ctrl_subscribe_event(fh, sub);\n}\n\nstatic int mtk_jpeg_enc_g_selection(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_selection *s)\n{\n\tstruct mtk_jpeg_ctx *ctx = mtk_jpeg_fh_to_ctx(priv);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\ts->r = ctx->out_q.enc_crop_rect;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\t\ts->r.width = ctx->out_q.pix_mp.width;\n\t\ts->r.height = ctx->out_q.pix_mp.height;\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int mtk_jpeg_dec_g_selection(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_selection *s)\n{\n\tstruct mtk_jpeg_ctx *ctx = mtk_jpeg_fh_to_ctx(priv);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\ts->r.width = ctx->out_q.pix_mp.width;\n\t\ts->r.height = ctx->out_q.pix_mp.height;\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\tcase V4L2_SEL_TGT_COMPOSE_PADDED:\n\t\ts->r.width = ctx->cap_q.pix_mp.width;\n\t\ts->r.height = ctx->cap_q.pix_mp.height;\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int mtk_jpeg_enc_s_selection(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_selection *s)\n{\n\tstruct mtk_jpeg_ctx *ctx = mtk_jpeg_fh_to_ctx(priv);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = min(s->r.width, ctx->out_q.pix_mp.width);\n\t\ts->r.height = min(s->r.height, ctx->out_q.pix_mp.height);\n\t\tctx->out_q.enc_crop_rect = s->r;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_jpeg_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\n{\n\tstruct v4l2_fh *fh = file->private_data;\n\tstruct mtk_jpeg_ctx *ctx = mtk_jpeg_fh_to_ctx(priv);\n\tstruct vb2_queue *vq;\n\tstruct vb2_buffer *vb;\n\tstruct mtk_jpeg_src_buf *jpeg_src_buf;\n\n\tif (buf->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tgoto end;\n\n\tvq = v4l2_m2m_get_vq(fh->m2m_ctx, buf->type);\n\tif (buf->index >= vq->num_buffers) {\n\t\tdev_err(ctx->jpeg->dev, \"buffer index out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvb = vq->bufs[buf->index];\n\tjpeg_src_buf = mtk_jpeg_vb2_to_srcbuf(vb);\n\tjpeg_src_buf->bs_size = buf->m.planes[0].bytesused;\n\nend:\n\treturn v4l2_m2m_qbuf(file, fh->m2m_ctx, buf);\n}\n\nstatic const struct v4l2_ioctl_ops mtk_jpeg_enc_ioctl_ops = {\n\t.vidioc_querycap                = mtk_jpeg_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= mtk_jpeg_enum_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_out\t= mtk_jpeg_enum_fmt_vid_out,\n\t.vidioc_try_fmt_vid_cap_mplane\t= mtk_jpeg_try_fmt_vid_cap_mplane,\n\t.vidioc_try_fmt_vid_out_mplane\t= mtk_jpeg_try_fmt_vid_out_mplane,\n\t.vidioc_g_fmt_vid_cap_mplane    = mtk_jpeg_g_fmt_vid_mplane,\n\t.vidioc_g_fmt_vid_out_mplane    = mtk_jpeg_g_fmt_vid_mplane,\n\t.vidioc_s_fmt_vid_cap_mplane    = mtk_jpeg_s_fmt_vid_cap_mplane,\n\t.vidioc_s_fmt_vid_out_mplane    = mtk_jpeg_s_fmt_vid_out_mplane,\n\t.vidioc_qbuf                    = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_subscribe_event         = mtk_jpeg_subscribe_event,\n\t.vidioc_g_selection\t\t= mtk_jpeg_enc_g_selection,\n\t.vidioc_s_selection\t\t= mtk_jpeg_enc_s_selection,\n\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_reqbufs                 = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf                = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_dqbuf                   = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_expbuf                  = v4l2_m2m_ioctl_expbuf,\n\t.vidioc_streamon                = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff               = v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n\n\t.vidioc_encoder_cmd\t\t= v4l2_m2m_ioctl_encoder_cmd,\n\t.vidioc_try_encoder_cmd\t\t= v4l2_m2m_ioctl_try_encoder_cmd,\n};\n\nstatic const struct v4l2_ioctl_ops mtk_jpeg_dec_ioctl_ops = {\n\t.vidioc_querycap                = mtk_jpeg_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= mtk_jpeg_enum_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_out\t= mtk_jpeg_enum_fmt_vid_out,\n\t.vidioc_try_fmt_vid_cap_mplane\t= mtk_jpeg_try_fmt_vid_cap_mplane,\n\t.vidioc_try_fmt_vid_out_mplane\t= mtk_jpeg_try_fmt_vid_out_mplane,\n\t.vidioc_g_fmt_vid_cap_mplane    = mtk_jpeg_g_fmt_vid_mplane,\n\t.vidioc_g_fmt_vid_out_mplane    = mtk_jpeg_g_fmt_vid_mplane,\n\t.vidioc_s_fmt_vid_cap_mplane    = mtk_jpeg_s_fmt_vid_cap_mplane,\n\t.vidioc_s_fmt_vid_out_mplane    = mtk_jpeg_s_fmt_vid_out_mplane,\n\t.vidioc_qbuf                    = mtk_jpeg_qbuf,\n\t.vidioc_subscribe_event         = mtk_jpeg_subscribe_event,\n\t.vidioc_g_selection\t\t= mtk_jpeg_dec_g_selection,\n\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_reqbufs                 = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf                = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_dqbuf                   = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_expbuf                  = v4l2_m2m_ioctl_expbuf,\n\t.vidioc_streamon                = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff               = v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n\n\t.vidioc_decoder_cmd = v4l2_m2m_ioctl_decoder_cmd,\n\t.vidioc_try_decoder_cmd = v4l2_m2m_ioctl_try_decoder_cmd,\n};\n\nstatic int mtk_jpeg_queue_setup(struct vb2_queue *q,\n\t\t\t\tunsigned int *num_buffers,\n\t\t\t\tunsigned int *num_planes,\n\t\t\t\tunsigned int sizes[],\n\t\t\t\tstruct device *alloc_ctxs[])\n{\n\tstruct mtk_jpeg_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct mtk_jpeg_q_data *q_data = NULL;\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tint i;\n\n\tv4l2_dbg(1, debug, &jpeg->v4l2_dev, \"(%d) buf_req count=%u\\n\",\n\t\t q->type, *num_buffers);\n\n\tq_data = mtk_jpeg_get_q_data(ctx, q->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tif (*num_planes) {\n\t\tfor (i = 0; i < *num_planes; i++)\n\t\t\tif (sizes[i] < q_data->pix_mp.plane_fmt[i].sizeimage)\n\t\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t*num_planes = q_data->fmt->colplanes;\n\tfor (i = 0; i < q_data->fmt->colplanes; i++) {\n\t\tsizes[i] =  q_data->pix_mp.plane_fmt[i].sizeimage;\n\t\tv4l2_dbg(1, debug, &jpeg->v4l2_dev, \"sizeimage[%d]=%u\\n\",\n\t\t\t i, sizes[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_jpeg_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct mtk_jpeg_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct mtk_jpeg_q_data *q_data = NULL;\n\tstruct v4l2_plane_pix_format plane_fmt = {};\n\tint i;\n\n\tq_data = mtk_jpeg_get_q_data(ctx, vb->vb2_queue->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < q_data->fmt->colplanes; i++) {\n\t\tplane_fmt = q_data->pix_mp.plane_fmt[i];\n\t\tif (ctx->enable_exif &&\n\t\t    q_data->fmt->fourcc == V4L2_PIX_FMT_JPEG)\n\t\t\tvb2_set_plane_payload(vb, i, plane_fmt.sizeimage +\n\t\t\t\t\t      MTK_JPEG_MAX_EXIF_SIZE);\n\t\telse\n\t\t\tvb2_set_plane_payload(vb, i,  plane_fmt.sizeimage);\n\t}\n\n\treturn 0;\n}\n\nstatic bool mtk_jpeg_check_resolution_change(struct mtk_jpeg_ctx *ctx,\n\t\t\t\t\t     struct mtk_jpeg_dec_param *param)\n{\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tstruct mtk_jpeg_q_data *q_data;\n\n\tq_data = &ctx->out_q;\n\tif (q_data->pix_mp.width != param->pic_w ||\n\t    q_data->pix_mp.height != param->pic_h) {\n\t\tv4l2_dbg(1, debug, &jpeg->v4l2_dev, \"Picture size change\\n\");\n\t\treturn true;\n\t}\n\n\tq_data = &ctx->cap_q;\n\tif (q_data->fmt !=\n\t    mtk_jpeg_find_format(jpeg->variant->formats,\n\t\t\t\t jpeg->variant->num_formats, param->dst_fourcc,\n\t\t\t\t MTK_JPEG_FMT_FLAG_CAPTURE)) {\n\t\tv4l2_dbg(1, debug, &jpeg->v4l2_dev, \"format change\\n\");\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void mtk_jpeg_set_queue_data(struct mtk_jpeg_ctx *ctx,\n\t\t\t\t    struct mtk_jpeg_dec_param *param)\n{\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tstruct mtk_jpeg_q_data *q_data;\n\tint i;\n\n\tq_data = &ctx->out_q;\n\tq_data->pix_mp.width = param->pic_w;\n\tq_data->pix_mp.height = param->pic_h;\n\n\tq_data = &ctx->cap_q;\n\tq_data->pix_mp.width = param->dec_w;\n\tq_data->pix_mp.height = param->dec_h;\n\tq_data->fmt = mtk_jpeg_find_format(jpeg->variant->formats,\n\t\t\t\t\t   jpeg->variant->num_formats,\n\t\t\t\t\t   param->dst_fourcc,\n\t\t\t\t\t   MTK_JPEG_FMT_FLAG_CAPTURE);\n\n\tfor (i = 0; i < q_data->fmt->colplanes; i++) {\n\t\tq_data->pix_mp.plane_fmt[i].bytesperline = param->mem_stride[i];\n\t\tq_data->pix_mp.plane_fmt[i].sizeimage = param->comp_size[i];\n\t}\n\n\tv4l2_dbg(1, debug, &jpeg->v4l2_dev,\n\t\t \"set_parse cap:%c%c%c%c pic(%u, %u), buf(%u, %u)\\n\",\n\t\t (param->dst_fourcc & 0xff),\n\t\t (param->dst_fourcc >>  8 & 0xff),\n\t\t (param->dst_fourcc >> 16 & 0xff),\n\t\t (param->dst_fourcc >> 24 & 0xff),\n\t\t param->pic_w, param->pic_h,\n\t\t param->dec_w, param->dec_h);\n}\n\nstatic void mtk_jpeg_enc_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct mtk_jpeg_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\n\tv4l2_dbg(2, debug, &jpeg->v4l2_dev, \"(%d) buf_q id=%d, vb=%p\\n\",\n\t\t vb->vb2_queue->type, vb->index, vb);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, to_vb2_v4l2_buffer(vb));\n}\n\nstatic void mtk_jpeg_dec_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct mtk_jpeg_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct mtk_jpeg_dec_param *param;\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tstruct mtk_jpeg_src_buf *jpeg_src_buf;\n\tbool header_valid;\n\n\tv4l2_dbg(2, debug, &jpeg->v4l2_dev, \"(%d) buf_q id=%d, vb=%p\\n\",\n\t\t vb->vb2_queue->type, vb->index, vb);\n\n\tif (vb->vb2_queue->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tgoto end;\n\n\tjpeg_src_buf = mtk_jpeg_vb2_to_srcbuf(vb);\n\tparam = &jpeg_src_buf->dec_param;\n\tmemset(param, 0, sizeof(*param));\n\n\theader_valid = mtk_jpeg_parse(param, (u8 *)vb2_plane_vaddr(vb, 0),\n\t\t\t\t      vb2_get_plane_payload(vb, 0));\n\tif (!header_valid) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"Header invalid.\\n\");\n\t\tvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\n\t\treturn;\n\t}\n\n\tif (ctx->state == MTK_JPEG_INIT) {\n\t\tstruct vb2_queue *dst_vq = v4l2_m2m_get_vq(\n\t\t\tctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\n\t\tmtk_jpeg_queue_src_chg_event(ctx);\n\t\tmtk_jpeg_set_queue_data(ctx, param);\n\t\tctx->state = vb2_is_streaming(dst_vq) ?\n\t\t\t\tMTK_JPEG_SOURCE_CHANGE : MTK_JPEG_RUNNING;\n\t}\nend:\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, to_vb2_v4l2_buffer(vb));\n}\n\nstatic struct vb2_v4l2_buffer *mtk_jpeg_buf_remove(struct mtk_jpeg_ctx *ctx,\n\t\t\t\t enum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\telse\n\t\treturn v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n}\n\nstatic void mtk_jpeg_enc_stop_streaming(struct vb2_queue *q)\n{\n\tstruct mtk_jpeg_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vb;\n\n\twhile ((vb = mtk_jpeg_buf_remove(ctx, q->type)))\n\t\tv4l2_m2m_buf_done(vb, VB2_BUF_STATE_ERROR);\n}\n\nstatic void mtk_jpeg_dec_stop_streaming(struct vb2_queue *q)\n{\n\tstruct mtk_jpeg_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vb;\n\n\t \n\tif (ctx->state == MTK_JPEG_SOURCE_CHANGE &&\n\t    V4L2_TYPE_IS_CAPTURE(q->type)) {\n\t\tstruct mtk_jpeg_src_buf *src_buf;\n\n\t\tvb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\t\tsrc_buf = mtk_jpeg_vb2_to_srcbuf(&vb->vb2_buf);\n\t\tmtk_jpeg_set_queue_data(ctx, &src_buf->dec_param);\n\t\tctx->state = MTK_JPEG_RUNNING;\n\t} else if (V4L2_TYPE_IS_OUTPUT(q->type)) {\n\t\tctx->state = MTK_JPEG_INIT;\n\t}\n\n\twhile ((vb = mtk_jpeg_buf_remove(ctx, q->type)))\n\t\tv4l2_m2m_buf_done(vb, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct vb2_ops mtk_jpeg_dec_qops = {\n\t.queue_setup        = mtk_jpeg_queue_setup,\n\t.buf_prepare        = mtk_jpeg_buf_prepare,\n\t.buf_queue          = mtk_jpeg_dec_buf_queue,\n\t.wait_prepare       = vb2_ops_wait_prepare,\n\t.wait_finish        = vb2_ops_wait_finish,\n\t.stop_streaming     = mtk_jpeg_dec_stop_streaming,\n};\n\nstatic const struct vb2_ops mtk_jpeg_enc_qops = {\n\t.queue_setup        = mtk_jpeg_queue_setup,\n\t.buf_prepare        = mtk_jpeg_buf_prepare,\n\t.buf_queue          = mtk_jpeg_enc_buf_queue,\n\t.wait_prepare       = vb2_ops_wait_prepare,\n\t.wait_finish        = vb2_ops_wait_finish,\n\t.stop_streaming     = mtk_jpeg_enc_stop_streaming,\n};\n\nstatic void mtk_jpeg_set_dec_src(struct mtk_jpeg_ctx *ctx,\n\t\t\t\t struct vb2_buffer *src_buf,\n\t\t\t\t struct mtk_jpeg_bs *bs)\n{\n\tbs->str_addr = vb2_dma_contig_plane_dma_addr(src_buf, 0);\n\tbs->end_addr = bs->str_addr +\n\t\t       round_up(vb2_get_plane_payload(src_buf, 0), 16);\n\tbs->size = round_up(vb2_plane_size(src_buf, 0), 128);\n}\n\nstatic int mtk_jpeg_set_dec_dst(struct mtk_jpeg_ctx *ctx,\n\t\t\t\tstruct mtk_jpeg_dec_param *param,\n\t\t\t\tstruct vb2_buffer *dst_buf,\n\t\t\t\tstruct mtk_jpeg_fb *fb)\n{\n\tint i;\n\n\tif (param->comp_num != dst_buf->num_planes) {\n\t\tdev_err(ctx->jpeg->dev, \"plane number mismatch (%u != %u)\\n\",\n\t\t\tparam->comp_num, dst_buf->num_planes);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < dst_buf->num_planes; i++) {\n\t\tif (vb2_plane_size(dst_buf, i) < param->comp_size[i]) {\n\t\t\tdev_err(ctx->jpeg->dev,\n\t\t\t\t\"buffer size is underflow (%lu < %u)\\n\",\n\t\t\t\tvb2_plane_size(dst_buf, 0),\n\t\t\t\tparam->comp_size[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfb->plane_addr[i] = vb2_dma_contig_plane_dma_addr(dst_buf, i);\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_jpeg_enc_device_run(void *priv)\n{\n\tstruct mtk_jpeg_ctx *ctx = priv;\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tenum vb2_buffer_state buf_state = VB2_BUF_STATE_ERROR;\n\tunsigned long flags;\n\tint ret;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\tret = pm_runtime_resume_and_get(jpeg->dev);\n\tif (ret < 0)\n\t\tgoto enc_end;\n\n\tschedule_delayed_work(&jpeg->job_timeout_work,\n\t\t\tmsecs_to_jiffies(MTK_JPEG_HW_TIMEOUT_MSEC));\n\n\tspin_lock_irqsave(&jpeg->hw_lock, flags);\n\n\t \n\tmtk_jpeg_enc_reset(jpeg->reg_base);\n\n\tmtk_jpeg_set_enc_src(ctx, jpeg->reg_base, &src_buf->vb2_buf);\n\tmtk_jpeg_set_enc_dst(ctx, jpeg->reg_base, &dst_buf->vb2_buf);\n\tmtk_jpeg_set_enc_params(ctx, jpeg->reg_base);\n\tmtk_jpeg_enc_start(jpeg->reg_base);\n\tspin_unlock_irqrestore(&jpeg->hw_lock, flags);\n\treturn;\n\nenc_end:\n\tv4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_buf_done(src_buf, buf_state);\n\tv4l2_m2m_buf_done(dst_buf, buf_state);\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic void mtk_jpeg_multicore_enc_device_run(void *priv)\n{\n\tstruct mtk_jpeg_ctx *ctx = priv;\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\n\tqueue_work(jpeg->workqueue, &ctx->jpeg_work);\n}\n\nstatic void mtk_jpeg_multicore_dec_device_run(void *priv)\n{\n\tstruct mtk_jpeg_ctx *ctx = priv;\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\n\tqueue_work(jpeg->workqueue, &ctx->jpeg_work);\n}\n\nstatic void mtk_jpeg_dec_device_run(void *priv)\n{\n\tstruct mtk_jpeg_ctx *ctx = priv;\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tenum vb2_buffer_state buf_state = VB2_BUF_STATE_ERROR;\n\tunsigned long flags;\n\tstruct mtk_jpeg_src_buf *jpeg_src_buf;\n\tstruct mtk_jpeg_bs bs;\n\tstruct mtk_jpeg_fb fb;\n\tint ret;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tjpeg_src_buf = mtk_jpeg_vb2_to_srcbuf(&src_buf->vb2_buf);\n\n\tif (mtk_jpeg_check_resolution_change(ctx, &jpeg_src_buf->dec_param)) {\n\t\tmtk_jpeg_queue_src_chg_event(ctx);\n\t\tctx->state = MTK_JPEG_SOURCE_CHANGE;\n\t\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n\t\treturn;\n\t}\n\n\tret = pm_runtime_resume_and_get(jpeg->dev);\n\tif (ret < 0)\n\t\tgoto dec_end;\n\n\tschedule_delayed_work(&jpeg->job_timeout_work,\n\t\t\t      msecs_to_jiffies(MTK_JPEG_HW_TIMEOUT_MSEC));\n\n\tmtk_jpeg_set_dec_src(ctx, &src_buf->vb2_buf, &bs);\n\tif (mtk_jpeg_set_dec_dst(ctx, &jpeg_src_buf->dec_param, &dst_buf->vb2_buf, &fb))\n\t\tgoto dec_end;\n\n\tspin_lock_irqsave(&jpeg->hw_lock, flags);\n\tmtk_jpeg_dec_reset(jpeg->reg_base);\n\tmtk_jpeg_dec_set_config(jpeg->reg_base,\n\t\t\t\t&jpeg_src_buf->dec_param,\n\t\t\t\tjpeg_src_buf->bs_size,\n\t\t\t\t&bs,\n\t\t\t\t&fb);\n\tmtk_jpeg_dec_start(jpeg->reg_base);\n\tspin_unlock_irqrestore(&jpeg->hw_lock, flags);\n\treturn;\n\ndec_end:\n\tv4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_buf_done(src_buf, buf_state);\n\tv4l2_m2m_buf_done(dst_buf, buf_state);\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic int mtk_jpeg_dec_job_ready(void *priv)\n{\n\tstruct mtk_jpeg_ctx *ctx = priv;\n\n\treturn (ctx->state == MTK_JPEG_RUNNING) ? 1 : 0;\n}\n\nstatic const struct v4l2_m2m_ops mtk_jpeg_enc_m2m_ops = {\n\t.device_run = mtk_jpeg_enc_device_run,\n};\n\nstatic const struct v4l2_m2m_ops mtk_jpeg_multicore_enc_m2m_ops = {\n\t.device_run = mtk_jpeg_multicore_enc_device_run,\n};\n\nstatic const struct v4l2_m2m_ops mtk_jpeg_multicore_dec_m2m_ops = {\n\t.device_run = mtk_jpeg_multicore_dec_device_run,\n};\n\nstatic const struct v4l2_m2m_ops mtk_jpeg_dec_m2m_ops = {\n\t.device_run = mtk_jpeg_dec_device_run,\n\t.job_ready  = mtk_jpeg_dec_job_ready,\n};\n\nstatic int mtk_jpeg_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t       struct vb2_queue *dst_vq)\n{\n\tstruct mtk_jpeg_ctx *ctx = priv;\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_DMABUF | VB2_MMAP;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct mtk_jpeg_src_buf);\n\tsrc_vq->ops = jpeg->variant->qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->jpeg->lock;\n\tsrc_vq->dev = ctx->jpeg->dev;\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_DMABUF | VB2_MMAP;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops = jpeg->variant->qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->jpeg->lock;\n\tdst_vq->dev = ctx->jpeg->dev;\n\tret = vb2_queue_init(dst_vq);\n\n\treturn ret;\n}\n\nstatic void mtk_jpeg_clk_on(struct mtk_jpeg_dev *jpeg)\n{\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(jpeg->variant->num_clks,\n\t\t\t\t      jpeg->variant->clks);\n\tif (ret)\n\t\tdev_err(jpeg->dev, \"Failed to open jpeg clk: %d\\n\", ret);\n}\n\nstatic void mtk_jpeg_clk_off(struct mtk_jpeg_dev *jpeg)\n{\n\tclk_bulk_disable_unprepare(jpeg->variant->num_clks,\n\t\t\t\t   jpeg->variant->clks);\n}\n\nstatic void mtk_jpeg_set_default_params(struct mtk_jpeg_ctx *ctx)\n{\n\tstruct mtk_jpeg_q_data *q = &ctx->out_q;\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\n\tctx->fh.ctrl_handler = &ctx->ctrl_hdl;\n\tq->pix_mp.colorspace = V4L2_COLORSPACE_SRGB;\n\tq->pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_601;\n\tq->pix_mp.quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\tq->pix_mp.xfer_func = V4L2_XFER_FUNC_SRGB;\n\n\tq->fmt = mtk_jpeg_find_format(jpeg->variant->formats,\n\t\t\t\t      jpeg->variant->num_formats,\n\t\t\t\t      jpeg->variant->out_q_default_fourcc,\n\t\t\t\t      MTK_JPEG_FMT_FLAG_OUTPUT);\n\tq->pix_mp.width = MTK_JPEG_MIN_WIDTH;\n\tq->pix_mp.height = MTK_JPEG_MIN_HEIGHT;\n\tmtk_jpeg_try_fmt_mplane(&q->pix_mp, q->fmt);\n\n\tq = &ctx->cap_q;\n\tq->fmt = mtk_jpeg_find_format(jpeg->variant->formats,\n\t\t\t\t      jpeg->variant->num_formats,\n\t\t\t\t      jpeg->variant->cap_q_default_fourcc,\n\t\t\t\t      MTK_JPEG_FMT_FLAG_CAPTURE);\n\tq->pix_mp.colorspace = V4L2_COLORSPACE_SRGB;\n\tq->pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_601;\n\tq->pix_mp.quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\tq->pix_mp.xfer_func = V4L2_XFER_FUNC_SRGB;\n\tq->pix_mp.width = MTK_JPEG_MIN_WIDTH;\n\tq->pix_mp.height = MTK_JPEG_MIN_HEIGHT;\n\n\tmtk_jpeg_try_fmt_mplane(&q->pix_mp, q->fmt);\n}\n\nstatic int mtk_jpeg_open(struct file *file)\n{\n\tstruct mtk_jpeg_dev *jpeg = video_drvdata(file);\n\tstruct video_device *vfd = video_devdata(file);\n\tstruct mtk_jpeg_ctx *ctx;\n\tint ret = 0;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (mutex_lock_interruptible(&jpeg->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free;\n\t}\n\n\tINIT_WORK(&ctx->jpeg_work, jpeg->variant->jpeg_worker);\n\tINIT_LIST_HEAD(&ctx->dst_done_queue);\n\tspin_lock_init(&ctx->done_queue_lock);\n\tv4l2_fh_init(&ctx->fh, vfd);\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\tctx->jpeg = jpeg;\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(jpeg->m2m_dev, ctx,\n\t\t\t\t\t    mtk_jpeg_queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto error;\n\t}\n\n\tif (jpeg->variant->cap_q_default_fourcc == V4L2_PIX_FMT_JPEG) {\n\t\tret = mtk_jpeg_enc_ctrls_setup(ctx);\n\t\tif (ret) {\n\t\t\tv4l2_err(&jpeg->v4l2_dev, \"Failed to setup jpeg enc controls\\n\");\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tv4l2_ctrl_handler_init(&ctx->ctrl_hdl, 0);\n\t}\n\n\tmtk_jpeg_set_default_params(ctx);\n\tmutex_unlock(&jpeg->lock);\n\treturn 0;\n\nerror:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tmutex_unlock(&jpeg->lock);\nfree:\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic int mtk_jpeg_release(struct file *file)\n{\n\tstruct mtk_jpeg_dev *jpeg = video_drvdata(file);\n\tstruct mtk_jpeg_ctx *ctx = mtk_jpeg_fh_to_ctx(file->private_data);\n\n\tmutex_lock(&jpeg->lock);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\tmutex_unlock(&jpeg->lock);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations mtk_jpeg_fops = {\n\t.owner          = THIS_MODULE,\n\t.open           = mtk_jpeg_open,\n\t.release        = mtk_jpeg_release,\n\t.poll           = v4l2_m2m_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap           = v4l2_m2m_fop_mmap,\n};\n\nstatic void mtk_jpeg_job_timeout_work(struct work_struct *work)\n{\n\tstruct mtk_jpeg_dev *jpeg = container_of(work, struct mtk_jpeg_dev,\n\t\t\t\t\t\t job_timeout_work.work);\n\tstruct mtk_jpeg_ctx *ctx;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\n\tctx = v4l2_m2m_get_curr_priv(jpeg->m2m_dev);\n\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tjpeg->variant->hw_reset(jpeg->reg_base);\n\n\tpm_runtime_put(jpeg->dev);\n\n\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\n\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic int mtk_jpeg_single_core_init(struct platform_device *pdev,\n\t\t\t\t     struct mtk_jpeg_dev *jpeg_dev)\n{\n\tstruct mtk_jpeg_dev *jpeg = jpeg_dev;\n\tint jpeg_irq, ret;\n\n\tINIT_DELAYED_WORK(&jpeg->job_timeout_work,\n\t\t\t  mtk_jpeg_job_timeout_work);\n\n\tjpeg->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(jpeg->reg_base)) {\n\t\tret = PTR_ERR(jpeg->reg_base);\n\t\treturn ret;\n\t}\n\n\tjpeg_irq = platform_get_irq(pdev, 0);\n\tif (jpeg_irq < 0)\n\t\treturn jpeg_irq;\n\n\tret = devm_request_irq(&pdev->dev,\n\t\t\t       jpeg_irq,\n\t\t\t       jpeg->variant->irq_handler,\n\t\t\t       0,\n\t\t\t       pdev->name, jpeg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request jpeg_irq %d (%d)\\n\",\n\t\t\tjpeg_irq, ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_clk_bulk_get(jpeg->dev,\n\t\t\t\tjpeg->variant->num_clks,\n\t\t\t\tjpeg->variant->clks);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to init clk\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_jpeg_probe(struct platform_device *pdev)\n{\n\tstruct mtk_jpeg_dev *jpeg;\n\tstruct device_node *child;\n\tint num_child = 0;\n\tint ret;\n\n\tjpeg = devm_kzalloc(&pdev->dev, sizeof(*jpeg), GFP_KERNEL);\n\tif (!jpeg)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&jpeg->lock);\n\tspin_lock_init(&jpeg->hw_lock);\n\tjpeg->dev = &pdev->dev;\n\tjpeg->variant = of_device_get_match_data(jpeg->dev);\n\n\tplatform_set_drvdata(pdev, jpeg);\n\n\tret = devm_of_platform_populate(&pdev->dev);\n\tif (ret) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"Master of platform populate failed.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!jpeg->variant->multi_core) {\n\t\tret = mtk_jpeg_single_core_init(pdev, jpeg);\n\t\tif (ret) {\n\t\t\tv4l2_err(&jpeg->v4l2_dev, \"mtk_jpeg_single_core_init failed.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tinit_waitqueue_head(&jpeg->hw_wq);\n\n\t\tfor_each_child_of_node(pdev->dev.of_node, child)\n\t\t\tnum_child++;\n\n\t\tatomic_set(&jpeg->hw_rdy, num_child);\n\t\tatomic_set(&jpeg->hw_index, 0);\n\n\t\tjpeg->workqueue = alloc_ordered_workqueue(MTK_JPEG_NAME,\n\t\t\t\t\t\t\t  WQ_MEM_RECLAIM\n\t\t\t\t\t\t\t  | WQ_FREEZABLE);\n\t\tif (!jpeg->workqueue)\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = v4l2_device_register(&pdev->dev, &jpeg->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register v4l2 device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tjpeg->m2m_dev = v4l2_m2m_init(jpeg->variant->m2m_ops);\n\n\tif (IS_ERR(jpeg->m2m_dev)) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(jpeg->m2m_dev);\n\t\tgoto err_m2m_init;\n\t}\n\n\tjpeg->vdev = video_device_alloc();\n\tif (!jpeg->vdev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_vfd_jpeg_alloc;\n\t}\n\tsnprintf(jpeg->vdev->name, sizeof(jpeg->vdev->name),\n\t\t \"%s\", jpeg->variant->dev_name);\n\tjpeg->vdev->fops = &mtk_jpeg_fops;\n\tjpeg->vdev->ioctl_ops = jpeg->variant->ioctl_ops;\n\tjpeg->vdev->minor = -1;\n\tjpeg->vdev->release = video_device_release;\n\tjpeg->vdev->lock = &jpeg->lock;\n\tjpeg->vdev->v4l2_dev = &jpeg->v4l2_dev;\n\tjpeg->vdev->vfl_dir = VFL_DIR_M2M;\n\tjpeg->vdev->device_caps = V4L2_CAP_STREAMING |\n\t\t\t\t  V4L2_CAP_VIDEO_M2M_MPLANE;\n\n\tret = video_register_device(jpeg->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto err_vfd_jpeg_register;\n\t}\n\n\tvideo_set_drvdata(jpeg->vdev, jpeg);\n\tv4l2_info(&jpeg->v4l2_dev,\n\t\t  \"%s device registered as /dev/video%d (%d,%d)\\n\",\n\t\t  jpeg->variant->dev_name, jpeg->vdev->num,\n\t\t  VIDEO_MAJOR, jpeg->vdev->minor);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n\nerr_vfd_jpeg_register:\n\tvideo_device_release(jpeg->vdev);\n\nerr_vfd_jpeg_alloc:\n\tv4l2_m2m_release(jpeg->m2m_dev);\n\nerr_m2m_init:\n\tv4l2_device_unregister(&jpeg->v4l2_dev);\n\n\treturn ret;\n}\n\nstatic void mtk_jpeg_remove(struct platform_device *pdev)\n{\n\tstruct mtk_jpeg_dev *jpeg = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tvideo_unregister_device(jpeg->vdev);\n\tv4l2_m2m_release(jpeg->m2m_dev);\n\tv4l2_device_unregister(&jpeg->v4l2_dev);\n}\n\nstatic __maybe_unused int mtk_jpeg_pm_suspend(struct device *dev)\n{\n\tstruct mtk_jpeg_dev *jpeg = dev_get_drvdata(dev);\n\n\tmtk_jpeg_clk_off(jpeg);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int mtk_jpeg_pm_resume(struct device *dev)\n{\n\tstruct mtk_jpeg_dev *jpeg = dev_get_drvdata(dev);\n\n\tmtk_jpeg_clk_on(jpeg);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int mtk_jpeg_suspend(struct device *dev)\n{\n\tstruct mtk_jpeg_dev *jpeg = dev_get_drvdata(dev);\n\n\tv4l2_m2m_suspend(jpeg->m2m_dev);\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic __maybe_unused int mtk_jpeg_resume(struct device *dev)\n{\n\tstruct mtk_jpeg_dev *jpeg = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_m2m_resume(jpeg->m2m_dev);\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops mtk_jpeg_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(mtk_jpeg_suspend, mtk_jpeg_resume)\n\tSET_RUNTIME_PM_OPS(mtk_jpeg_pm_suspend, mtk_jpeg_pm_resume, NULL)\n};\n\nstatic int mtk_jpegenc_get_hw(struct mtk_jpeg_ctx *ctx)\n{\n\tstruct mtk_jpegenc_comp_dev *comp_jpeg;\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tunsigned long flags;\n\tint hw_id = -1;\n\tint i;\n\n\tspin_lock_irqsave(&jpeg->hw_lock, flags);\n\tfor (i = 0; i < MTK_JPEGENC_HW_MAX; i++) {\n\t\tcomp_jpeg = jpeg->enc_hw_dev[i];\n\t\tif (comp_jpeg->hw_state == MTK_JPEG_HW_IDLE) {\n\t\t\thw_id = i;\n\t\t\tcomp_jpeg->hw_state = MTK_JPEG_HW_BUSY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&jpeg->hw_lock, flags);\n\n\treturn hw_id;\n}\n\nstatic int mtk_jpegenc_set_hw_param(struct mtk_jpeg_ctx *ctx,\n\t\t\t\t    int hw_id,\n\t\t\t\t    struct vb2_v4l2_buffer *src_buf,\n\t\t\t\t    struct vb2_v4l2_buffer *dst_buf)\n{\n\tstruct mtk_jpegenc_comp_dev *jpeg = ctx->jpeg->enc_hw_dev[hw_id];\n\n\tjpeg->hw_param.curr_ctx = ctx;\n\tjpeg->hw_param.src_buffer = src_buf;\n\tjpeg->hw_param.dst_buffer = dst_buf;\n\n\treturn 0;\n}\n\nstatic int mtk_jpegenc_put_hw(struct mtk_jpeg_dev *jpeg, int hw_id)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&jpeg->hw_lock, flags);\n\tjpeg->enc_hw_dev[hw_id]->hw_state = MTK_JPEG_HW_IDLE;\n\tspin_unlock_irqrestore(&jpeg->hw_lock, flags);\n\n\treturn 0;\n}\n\nstatic int mtk_jpegdec_get_hw(struct mtk_jpeg_ctx *ctx)\n{\n\tstruct mtk_jpegdec_comp_dev *comp_jpeg;\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tunsigned long flags;\n\tint hw_id = -1;\n\tint i;\n\n\tspin_lock_irqsave(&jpeg->hw_lock, flags);\n\tfor (i = 0; i < MTK_JPEGDEC_HW_MAX; i++) {\n\t\tcomp_jpeg = jpeg->dec_hw_dev[i];\n\t\tif (comp_jpeg->hw_state == MTK_JPEG_HW_IDLE) {\n\t\t\thw_id = i;\n\t\t\tcomp_jpeg->hw_state = MTK_JPEG_HW_BUSY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&jpeg->hw_lock, flags);\n\n\treturn hw_id;\n}\n\nstatic int mtk_jpegdec_put_hw(struct mtk_jpeg_dev *jpeg, int hw_id)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&jpeg->hw_lock, flags);\n\tjpeg->dec_hw_dev[hw_id]->hw_state =\n\t\tMTK_JPEG_HW_IDLE;\n\tspin_unlock_irqrestore(&jpeg->hw_lock, flags);\n\n\treturn 0;\n}\n\nstatic int mtk_jpegdec_set_hw_param(struct mtk_jpeg_ctx *ctx,\n\t\t\t\t    int hw_id,\n\t\t\t\t    struct vb2_v4l2_buffer *src_buf,\n\t\t\t\t    struct vb2_v4l2_buffer *dst_buf)\n{\n\tstruct mtk_jpegdec_comp_dev *jpeg =\n\t\tctx->jpeg->dec_hw_dev[hw_id];\n\n\tjpeg->hw_param.curr_ctx = ctx;\n\tjpeg->hw_param.src_buffer = src_buf;\n\tjpeg->hw_param.dst_buffer = dst_buf;\n\n\treturn 0;\n}\n\nstatic irqreturn_t mtk_jpeg_enc_done(struct mtk_jpeg_dev *jpeg)\n{\n\tstruct mtk_jpeg_ctx *ctx;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tenum vb2_buffer_state buf_state = VB2_BUF_STATE_ERROR;\n\tu32 result_size;\n\n\tctx = v4l2_m2m_get_curr_priv(jpeg->m2m_dev);\n\tif (!ctx) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"Context is NULL\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tresult_size = mtk_jpeg_enc_get_file_size(jpeg->reg_base);\n\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, result_size);\n\n\tbuf_state = VB2_BUF_STATE_DONE;\n\n\tv4l2_m2m_buf_done(src_buf, buf_state);\n\tv4l2_m2m_buf_done(dst_buf, buf_state);\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n\tpm_runtime_put(ctx->jpeg->dev);\n\treturn IRQ_HANDLED;\n}\n\nstatic void mtk_jpegenc_worker(struct work_struct *work)\n{\n\tstruct mtk_jpegenc_comp_dev *comp_jpeg[MTK_JPEGENC_HW_MAX];\n\tenum vb2_buffer_state buf_state = VB2_BUF_STATE_ERROR;\n\tstruct mtk_jpeg_src_buf *jpeg_dst_buf;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tint ret, i, hw_id = 0;\n\tunsigned long flags;\n\n\tstruct mtk_jpeg_ctx *ctx = container_of(work,\n\t\tstruct mtk_jpeg_ctx,\n\t\tjpeg_work);\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\n\tfor (i = 0; i < MTK_JPEGENC_HW_MAX; i++)\n\t\tcomp_jpeg[i] = jpeg->enc_hw_dev[i];\n\ti = 0;\n\nretry_select:\n\thw_id = mtk_jpegenc_get_hw(ctx);\n\tif (hw_id < 0) {\n\t\tret = wait_event_interruptible(jpeg->hw_wq,\n\t\t\t\t\t       atomic_read(&jpeg->hw_rdy) > 0);\n\t\tif (ret != 0 || (i++ > MTK_JPEG_MAX_RETRY_TIME)) {\n\t\t\tdev_err(jpeg->dev, \"%s : %d, all HW are busy\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n\t\t\treturn;\n\t\t}\n\n\t\tgoto retry_select;\n\t}\n\n\tatomic_dec(&jpeg->hw_rdy);\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tif (!src_buf)\n\t\tgoto getbuf_fail;\n\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tif (!dst_buf)\n\t\tgoto getbuf_fail;\n\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, true);\n\n\tmtk_jpegenc_set_hw_param(ctx, hw_id, src_buf, dst_buf);\n\tret = pm_runtime_get_sync(comp_jpeg[hw_id]->dev);\n\tif (ret < 0) {\n\t\tdev_err(jpeg->dev, \"%s : %d, pm_runtime_get_sync fail !!!\\n\",\n\t\t\t__func__, __LINE__);\n\t\tgoto enc_end;\n\t}\n\n\tret = clk_prepare_enable(comp_jpeg[hw_id]->venc_clk.clks->clk);\n\tif (ret) {\n\t\tdev_err(jpeg->dev, \"%s : %d, jpegenc clk_prepare_enable fail\\n\",\n\t\t\t__func__, __LINE__);\n\t\tgoto enc_end;\n\t}\n\n\tv4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tschedule_delayed_work(&comp_jpeg[hw_id]->job_timeout_work,\n\t\t\t      msecs_to_jiffies(MTK_JPEG_HW_TIMEOUT_MSEC));\n\n\tspin_lock_irqsave(&comp_jpeg[hw_id]->hw_lock, flags);\n\tjpeg_dst_buf = mtk_jpeg_vb2_to_srcbuf(&dst_buf->vb2_buf);\n\tjpeg_dst_buf->curr_ctx = ctx;\n\tjpeg_dst_buf->frame_num = ctx->total_frame_num;\n\tctx->total_frame_num++;\n\tmtk_jpeg_enc_reset(comp_jpeg[hw_id]->reg_base);\n\tmtk_jpeg_set_enc_dst(ctx,\n\t\t\t     comp_jpeg[hw_id]->reg_base,\n\t\t\t     &dst_buf->vb2_buf);\n\tmtk_jpeg_set_enc_src(ctx,\n\t\t\t     comp_jpeg[hw_id]->reg_base,\n\t\t\t     &src_buf->vb2_buf);\n\tmtk_jpeg_set_enc_params(ctx, comp_jpeg[hw_id]->reg_base);\n\tmtk_jpeg_enc_start(comp_jpeg[hw_id]->reg_base);\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n\tspin_unlock_irqrestore(&comp_jpeg[hw_id]->hw_lock, flags);\n\n\treturn;\n\nenc_end:\n\tv4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_buf_done(src_buf, buf_state);\n\tv4l2_m2m_buf_done(dst_buf, buf_state);\ngetbuf_fail:\n\tatomic_inc(&jpeg->hw_rdy);\n\tmtk_jpegenc_put_hw(jpeg, hw_id);\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic void mtk_jpegdec_worker(struct work_struct *work)\n{\n\tstruct mtk_jpeg_ctx *ctx = container_of(work, struct mtk_jpeg_ctx,\n\t\tjpeg_work);\n\tstruct mtk_jpegdec_comp_dev *comp_jpeg[MTK_JPEGDEC_HW_MAX];\n\tenum vb2_buffer_state buf_state = VB2_BUF_STATE_ERROR;\n\tstruct mtk_jpeg_src_buf *jpeg_src_buf, *jpeg_dst_buf;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct mtk_jpeg_dev *jpeg = ctx->jpeg;\n\tint ret, i, hw_id = 0;\n\tstruct mtk_jpeg_bs bs;\n\tstruct mtk_jpeg_fb fb;\n\tunsigned long flags;\n\n\tfor (i = 0; i < MTK_JPEGDEC_HW_MAX; i++)\n\t\tcomp_jpeg[i] = jpeg->dec_hw_dev[i];\n\ti = 0;\n\nretry_select:\n\thw_id = mtk_jpegdec_get_hw(ctx);\n\tif (hw_id < 0) {\n\t\tret = wait_event_interruptible_timeout(jpeg->hw_wq,\n\t\t\t\t\t\t       atomic_read(&jpeg->hw_rdy) > 0,\n\t\t\t\t\t\t       MTK_JPEG_HW_TIMEOUT_MSEC);\n\t\tif (ret != 0 || (i++ > MTK_JPEG_MAX_RETRY_TIME)) {\n\t\t\tdev_err(jpeg->dev, \"%s : %d, all HW are busy\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n\t\t\treturn;\n\t\t}\n\n\t\tgoto retry_select;\n\t}\n\n\tatomic_dec(&jpeg->hw_rdy);\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tif (!src_buf)\n\t\tgoto getbuf_fail;\n\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tif (!dst_buf)\n\t\tgoto getbuf_fail;\n\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, true);\n\tjpeg_src_buf = mtk_jpeg_vb2_to_srcbuf(&src_buf->vb2_buf);\n\tjpeg_dst_buf = mtk_jpeg_vb2_to_srcbuf(&dst_buf->vb2_buf);\n\n\tif (mtk_jpeg_check_resolution_change(ctx,\n\t\t\t\t\t     &jpeg_src_buf->dec_param)) {\n\t\tmtk_jpeg_queue_src_chg_event(ctx);\n\t\tctx->state = MTK_JPEG_SOURCE_CHANGE;\n\t\tgoto getbuf_fail;\n\t}\n\n\tjpeg_src_buf->curr_ctx = ctx;\n\tjpeg_src_buf->frame_num = ctx->total_frame_num;\n\tjpeg_dst_buf->curr_ctx = ctx;\n\tjpeg_dst_buf->frame_num = ctx->total_frame_num;\n\n\tmtk_jpegdec_set_hw_param(ctx, hw_id, src_buf, dst_buf);\n\tret = pm_runtime_get_sync(comp_jpeg[hw_id]->dev);\n\tif (ret < 0) {\n\t\tdev_err(jpeg->dev, \"%s : %d, pm_runtime_get_sync fail !!!\\n\",\n\t\t\t__func__, __LINE__);\n\t\tgoto dec_end;\n\t}\n\n\tret = clk_prepare_enable(comp_jpeg[hw_id]->jdec_clk.clks->clk);\n\tif (ret) {\n\t\tdev_err(jpeg->dev, \"%s : %d, jpegdec clk_prepare_enable fail\\n\",\n\t\t\t__func__, __LINE__);\n\t\tgoto clk_end;\n\t}\n\n\tv4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tschedule_delayed_work(&comp_jpeg[hw_id]->job_timeout_work,\n\t\t\t      msecs_to_jiffies(MTK_JPEG_HW_TIMEOUT_MSEC));\n\n\tmtk_jpeg_set_dec_src(ctx, &src_buf->vb2_buf, &bs);\n\tif (mtk_jpeg_set_dec_dst(ctx,\n\t\t\t\t &jpeg_src_buf->dec_param,\n\t\t\t\t &dst_buf->vb2_buf, &fb)) {\n\t\tdev_err(jpeg->dev, \"%s : %d, mtk_jpeg_set_dec_dst fail\\n\",\n\t\t\t__func__, __LINE__);\n\t\tgoto setdst_end;\n\t}\n\n\tspin_lock_irqsave(&comp_jpeg[hw_id]->hw_lock, flags);\n\tctx->total_frame_num++;\n\tmtk_jpeg_dec_reset(comp_jpeg[hw_id]->reg_base);\n\tmtk_jpeg_dec_set_config(comp_jpeg[hw_id]->reg_base,\n\t\t\t\t&jpeg_src_buf->dec_param,\n\t\t\t\tjpeg_src_buf->bs_size,\n\t\t\t\t&bs,\n\t\t\t\t&fb);\n\tmtk_jpeg_dec_start(comp_jpeg[hw_id]->reg_base);\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n\tspin_unlock_irqrestore(&comp_jpeg[hw_id]->hw_lock, flags);\n\n\treturn;\n\nsetdst_end:\n\tclk_disable_unprepare(comp_jpeg[hw_id]->jdec_clk.clks->clk);\nclk_end:\n\tpm_runtime_put(comp_jpeg[hw_id]->dev);\ndec_end:\n\tv4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_buf_done(src_buf, buf_state);\n\tv4l2_m2m_buf_done(dst_buf, buf_state);\ngetbuf_fail:\n\tatomic_inc(&jpeg->hw_rdy);\n\tmtk_jpegdec_put_hw(jpeg, hw_id);\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic irqreturn_t mtk_jpeg_enc_irq(int irq, void *priv)\n{\n\tstruct mtk_jpeg_dev *jpeg = priv;\n\tu32 irq_status;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tcancel_delayed_work(&jpeg->job_timeout_work);\n\n\tirq_status = readl(jpeg->reg_base + JPEG_ENC_INT_STS) &\n\t\t     JPEG_ENC_INT_STATUS_MASK_ALLIRQ;\n\tif (irq_status)\n\t\twritel(0, jpeg->reg_base + JPEG_ENC_INT_STS);\n\n\tif (!(irq_status & JPEG_ENC_INT_STATUS_DONE))\n\t\treturn ret;\n\n\tret = mtk_jpeg_enc_done(jpeg);\n\treturn ret;\n}\n\nstatic irqreturn_t mtk_jpeg_dec_irq(int irq, void *priv)\n{\n\tstruct mtk_jpeg_dev *jpeg = priv;\n\tstruct mtk_jpeg_ctx *ctx;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct mtk_jpeg_src_buf *jpeg_src_buf;\n\tenum vb2_buffer_state buf_state = VB2_BUF_STATE_ERROR;\n\tu32\tdec_irq_ret;\n\tu32 dec_ret;\n\tint i;\n\n\tcancel_delayed_work(&jpeg->job_timeout_work);\n\n\tdec_ret = mtk_jpeg_dec_get_int_status(jpeg->reg_base);\n\tdec_irq_ret = mtk_jpeg_dec_enum_result(dec_ret);\n\tctx = v4l2_m2m_get_curr_priv(jpeg->m2m_dev);\n\tif (!ctx) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"Context is NULL\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tjpeg_src_buf = mtk_jpeg_vb2_to_srcbuf(&src_buf->vb2_buf);\n\n\tif (dec_irq_ret >= MTK_JPEG_DEC_RESULT_UNDERFLOW)\n\t\tmtk_jpeg_dec_reset(jpeg->reg_base);\n\n\tif (dec_irq_ret != MTK_JPEG_DEC_RESULT_EOF_DONE) {\n\t\tdev_err(jpeg->dev, \"decode failed\\n\");\n\t\tgoto dec_end;\n\t}\n\n\tfor (i = 0; i < dst_buf->vb2_buf.num_planes; i++)\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, i,\n\t\t\t\t      jpeg_src_buf->dec_param.comp_size[i]);\n\n\tbuf_state = VB2_BUF_STATE_DONE;\n\ndec_end:\n\tv4l2_m2m_buf_done(src_buf, buf_state);\n\tv4l2_m2m_buf_done(dst_buf, buf_state);\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n\tpm_runtime_put(ctx->jpeg->dev);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct clk_bulk_data mtk_jpeg_clocks[] = {\n\t{ .id = \"jpgenc\" },\n};\n\nstatic struct clk_bulk_data mt8173_jpeg_dec_clocks[] = {\n\t{ .id = \"jpgdec-smi\" },\n\t{ .id = \"jpgdec\" },\n};\n\nstatic const struct mtk_jpeg_variant mt8173_jpeg_drvdata = {\n\t.clks = mt8173_jpeg_dec_clocks,\n\t.num_clks = ARRAY_SIZE(mt8173_jpeg_dec_clocks),\n\t.formats = mtk_jpeg_dec_formats,\n\t.num_formats = MTK_JPEG_DEC_NUM_FORMATS,\n\t.qops = &mtk_jpeg_dec_qops,\n\t.irq_handler = mtk_jpeg_dec_irq,\n\t.hw_reset = mtk_jpeg_dec_reset,\n\t.m2m_ops = &mtk_jpeg_dec_m2m_ops,\n\t.dev_name = \"mtk-jpeg-dec\",\n\t.ioctl_ops = &mtk_jpeg_dec_ioctl_ops,\n\t.out_q_default_fourcc = V4L2_PIX_FMT_JPEG,\n\t.cap_q_default_fourcc = V4L2_PIX_FMT_YUV420M,\n};\n\nstatic const struct mtk_jpeg_variant mtk_jpeg_drvdata = {\n\t.clks = mtk_jpeg_clocks,\n\t.num_clks = ARRAY_SIZE(mtk_jpeg_clocks),\n\t.formats = mtk_jpeg_enc_formats,\n\t.num_formats = MTK_JPEG_ENC_NUM_FORMATS,\n\t.qops = &mtk_jpeg_enc_qops,\n\t.irq_handler = mtk_jpeg_enc_irq,\n\t.hw_reset = mtk_jpeg_enc_reset,\n\t.m2m_ops = &mtk_jpeg_enc_m2m_ops,\n\t.dev_name = \"mtk-jpeg-enc\",\n\t.ioctl_ops = &mtk_jpeg_enc_ioctl_ops,\n\t.out_q_default_fourcc = V4L2_PIX_FMT_YUYV,\n\t.cap_q_default_fourcc = V4L2_PIX_FMT_JPEG,\n\t.multi_core = false,\n};\n\nstatic struct mtk_jpeg_variant mtk8195_jpegenc_drvdata = {\n\t.formats = mtk_jpeg_enc_formats,\n\t.num_formats = MTK_JPEG_ENC_NUM_FORMATS,\n\t.qops = &mtk_jpeg_enc_qops,\n\t.m2m_ops = &mtk_jpeg_multicore_enc_m2m_ops,\n\t.dev_name = \"mtk-jpeg-enc\",\n\t.ioctl_ops = &mtk_jpeg_enc_ioctl_ops,\n\t.out_q_default_fourcc = V4L2_PIX_FMT_YUYV,\n\t.cap_q_default_fourcc = V4L2_PIX_FMT_JPEG,\n\t.multi_core = true,\n\t.jpeg_worker = mtk_jpegenc_worker,\n};\n\nstatic const struct mtk_jpeg_variant mtk8195_jpegdec_drvdata = {\n\t.formats = mtk_jpeg_dec_formats,\n\t.num_formats = MTK_JPEG_DEC_NUM_FORMATS,\n\t.qops = &mtk_jpeg_dec_qops,\n\t.m2m_ops = &mtk_jpeg_multicore_dec_m2m_ops,\n\t.dev_name = \"mtk-jpeg-dec\",\n\t.ioctl_ops = &mtk_jpeg_dec_ioctl_ops,\n\t.out_q_default_fourcc = V4L2_PIX_FMT_JPEG,\n\t.cap_q_default_fourcc = V4L2_PIX_FMT_YUV420M,\n\t.multi_core = true,\n\t.jpeg_worker = mtk_jpegdec_worker,\n};\n\nstatic const struct of_device_id mtk_jpeg_match[] = {\n\t{\n\t\t.compatible = \"mediatek,mt8173-jpgdec\",\n\t\t.data = &mt8173_jpeg_drvdata,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt2701-jpgdec\",\n\t\t.data = &mt8173_jpeg_drvdata,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mtk-jpgenc\",\n\t\t.data = &mtk_jpeg_drvdata,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8195-jpgenc\",\n\t\t.data = &mtk8195_jpegenc_drvdata,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8195-jpgdec\",\n\t\t.data = &mtk8195_jpegdec_drvdata,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, mtk_jpeg_match);\n\nstatic struct platform_driver mtk_jpeg_driver = {\n\t.probe = mtk_jpeg_probe,\n\t.remove_new = mtk_jpeg_remove,\n\t.driver = {\n\t\t.name           = MTK_JPEG_NAME,\n\t\t.of_match_table = mtk_jpeg_match,\n\t\t.pm             = &mtk_jpeg_pm_ops,\n\t},\n};\n\nmodule_platform_driver(mtk_jpeg_driver);\n\nMODULE_DESCRIPTION(\"MediaTek JPEG codec driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}