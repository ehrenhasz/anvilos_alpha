{
  "module_name": "mtk_jpeg_dec_hw.c",
  "hash_id": "306bd6a230528b467c7c25f387135daf2bf31d2a9e4afe3a0aa526d0268a1ba4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_hw.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <media/media-device.h>\n#include <media/videobuf2-core.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n\n#include \"mtk_jpeg_core.h\"\n#include \"mtk_jpeg_dec_hw.h\"\n\n#define MTK_JPEG_DUNUM_MASK(val)\t(((val) - 1) & 0x3)\n\nenum mtk_jpeg_color {\n\tMTK_JPEG_COLOR_420\t\t= 0x00221111,\n\tMTK_JPEG_COLOR_422\t\t= 0x00211111,\n\tMTK_JPEG_COLOR_444\t\t= 0x00111111,\n\tMTK_JPEG_COLOR_422V\t\t= 0x00121111,\n\tMTK_JPEG_COLOR_422X2\t\t= 0x00412121,\n\tMTK_JPEG_COLOR_422VX2\t\t= 0x00222121,\n\tMTK_JPEG_COLOR_400\t\t= 0x00110000\n};\n\nstatic const struct of_device_id mtk_jpegdec_hw_ids[] = {\n\t{\n\t\t.compatible = \"mediatek,mt8195-jpgdec-hw\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_jpegdec_hw_ids);\n\nstatic inline int mtk_jpeg_verify_align(u32 val, int align, u32 reg)\n{\n\tif (val & (align - 1)) {\n\t\tpr_err(\"mtk-jpeg: write reg %x without %d align\\n\", reg, align);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_jpeg_decide_format(struct mtk_jpeg_dec_param *param)\n{\n\tparam->src_color = (param->sampling_w[0] << 20) |\n\t\t\t   (param->sampling_h[0] << 16) |\n\t\t\t   (param->sampling_w[1] << 12) |\n\t\t\t   (param->sampling_h[1] << 8) |\n\t\t\t   (param->sampling_w[2] << 4) |\n\t\t\t   (param->sampling_h[2]);\n\n\tparam->uv_brz_w = 0;\n\tswitch (param->src_color) {\n\tcase MTK_JPEG_COLOR_444:\n\t\tparam->uv_brz_w = 1;\n\t\tparam->dst_fourcc = V4L2_PIX_FMT_YUV422M;\n\t\tbreak;\n\tcase MTK_JPEG_COLOR_422X2:\n\tcase MTK_JPEG_COLOR_422:\n\t\tparam->dst_fourcc = V4L2_PIX_FMT_YUV422M;\n\t\tbreak;\n\tcase MTK_JPEG_COLOR_422V:\n\tcase MTK_JPEG_COLOR_422VX2:\n\t\tparam->uv_brz_w = 1;\n\t\tparam->dst_fourcc = V4L2_PIX_FMT_YUV420M;\n\t\tbreak;\n\tcase MTK_JPEG_COLOR_420:\n\t\tparam->dst_fourcc = V4L2_PIX_FMT_YUV420M;\n\t\tbreak;\n\tcase MTK_JPEG_COLOR_400:\n\t\tparam->dst_fourcc = V4L2_PIX_FMT_GREY;\n\t\tbreak;\n\tdefault:\n\t\tparam->dst_fourcc = 0;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_jpeg_calc_mcu(struct mtk_jpeg_dec_param *param)\n{\n\tu32 factor_w, factor_h;\n\tu32 i, comp, blk;\n\n\tfactor_w = 2 + param->sampling_w[0];\n\tfactor_h = 2 + param->sampling_h[0];\n\tparam->mcu_w = (param->pic_w + (1 << factor_w) - 1) >> factor_w;\n\tparam->mcu_h = (param->pic_h + (1 << factor_h) - 1) >> factor_h;\n\tparam->total_mcu = param->mcu_w * param->mcu_h;\n\tparam->unit_num = ((param->pic_w + 7) >> 3) * ((param->pic_h + 7) >> 3);\n\tparam->blk_num = 0;\n\tfor (i = 0; i < MTK_JPEG_COMP_MAX; i++) {\n\t\tparam->blk_comp[i] = 0;\n\t\tif (i >= param->comp_num)\n\t\t\tcontinue;\n\t\tparam->blk_comp[i] = param->sampling_w[i] *\n\t\t\t\t     param->sampling_h[i];\n\t\tparam->blk_num += param->blk_comp[i];\n\t}\n\n\tparam->membership = 0;\n\tfor (i = 0, blk = 0, comp = 0; i < MTK_JPEG_BLOCK_MAX; i++) {\n\t\tif (i < param->blk_num && comp < param->comp_num) {\n\t\t\tu32 tmp;\n\n\t\t\ttmp = (0x04 + (comp & 0x3));\n\t\t\tparam->membership |= tmp << (i * 3);\n\t\t\tif (++blk == param->blk_comp[comp]) {\n\t\t\t\tcomp++;\n\t\t\t\tblk = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tparam->membership |=  7 << (i * 3);\n\t\t}\n\t}\n}\n\nstatic void mtk_jpeg_calc_dma_group(struct mtk_jpeg_dec_param *param)\n{\n\tu32 factor_mcu = 3;\n\n\tif (param->src_color == MTK_JPEG_COLOR_444 &&\n\t    param->dst_fourcc == V4L2_PIX_FMT_YUV422M)\n\t\tfactor_mcu = 4;\n\telse if (param->src_color == MTK_JPEG_COLOR_422V &&\n\t\t param->dst_fourcc == V4L2_PIX_FMT_YUV420M)\n\t\tfactor_mcu = 4;\n\telse if (param->src_color == MTK_JPEG_COLOR_422X2 &&\n\t\t param->dst_fourcc == V4L2_PIX_FMT_YUV422M)\n\t\tfactor_mcu = 2;\n\telse if (param->src_color == MTK_JPEG_COLOR_400 ||\n\t\t (param->src_color & 0x0FFFF) == 0)\n\t\tfactor_mcu = 4;\n\n\tparam->dma_mcu = 1 << factor_mcu;\n\tparam->dma_group = param->mcu_w / param->dma_mcu;\n\tparam->dma_last_mcu = param->mcu_w % param->dma_mcu;\n\tif (param->dma_last_mcu)\n\t\tparam->dma_group++;\n\telse\n\t\tparam->dma_last_mcu = param->dma_mcu;\n}\n\nstatic int mtk_jpeg_calc_dst_size(struct mtk_jpeg_dec_param *param)\n{\n\tu32 i, padding_w;\n\tu32 ds_row_h[3];\n\tu32 brz_w[3];\n\n\tbrz_w[0] = 0;\n\tbrz_w[1] = param->uv_brz_w;\n\tbrz_w[2] = brz_w[1];\n\n\tfor (i = 0; i < param->comp_num; i++) {\n\t\tif (brz_w[i] > 3)\n\t\t\treturn -1;\n\n\t\tpadding_w = param->mcu_w * MTK_JPEG_DCTSIZE *\n\t\t\t\tparam->sampling_w[i];\n\t\t \n\t\tparam->comp_w[i] = padding_w >> brz_w[i];\n\t\tparam->comp_w[i] = round_up(param->comp_w[i],\n\t\t\t\t\t    MTK_JPEG_DCTSIZE);\n\t\tparam->img_stride[i] = i ? round_up(param->comp_w[i], 16)\n\t\t\t\t\t: round_up(param->comp_w[i], 32);\n\t\tds_row_h[i] = (MTK_JPEG_DCTSIZE * param->sampling_h[i]);\n\t}\n\tparam->dec_w = param->img_stride[0];\n\tparam->dec_h = ds_row_h[0] * param->mcu_h;\n\n\tfor (i = 0; i < MTK_JPEG_COMP_MAX; i++) {\n\t\t \n\t\tparam->mem_stride[i] = param->img_stride[i];\n\t\tparam->comp_size[i] = param->mem_stride[i] * ds_row_h[i] *\n\t\t\t\t      param->mcu_h;\n\t}\n\n\tparam->y_size = param->comp_size[0];\n\tparam->uv_size = param->comp_size[1];\n\tparam->dec_size = param->y_size + (param->uv_size << 1);\n\n\treturn 0;\n}\n\nint mtk_jpeg_dec_fill_param(struct mtk_jpeg_dec_param *param)\n{\n\tif (mtk_jpeg_decide_format(param))\n\t\treturn -1;\n\n\tmtk_jpeg_calc_mcu(param);\n\tmtk_jpeg_calc_dma_group(param);\n\tif (mtk_jpeg_calc_dst_size(param))\n\t\treturn -2;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_jpeg_dec_fill_param);\n\nu32 mtk_jpeg_dec_get_int_status(void __iomem *base)\n{\n\tu32 ret;\n\n\tret = readl(base + JPGDEC_REG_INTERRUPT_STATUS) & BIT_INQST_MASK_ALLIRQ;\n\tif (ret)\n\t\twritel(ret, base + JPGDEC_REG_INTERRUPT_STATUS);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mtk_jpeg_dec_get_int_status);\n\nu32 mtk_jpeg_dec_enum_result(u32 irq_result)\n{\n\tif (irq_result & BIT_INQST_MASK_EOF)\n\t\treturn MTK_JPEG_DEC_RESULT_EOF_DONE;\n\tif (irq_result & BIT_INQST_MASK_PAUSE)\n\t\treturn MTK_JPEG_DEC_RESULT_PAUSE;\n\tif (irq_result & BIT_INQST_MASK_UNDERFLOW)\n\t\treturn MTK_JPEG_DEC_RESULT_UNDERFLOW;\n\tif (irq_result & BIT_INQST_MASK_OVERFLOW)\n\t\treturn MTK_JPEG_DEC_RESULT_OVERFLOW;\n\tif (irq_result & BIT_INQST_MASK_ERROR_BS)\n\t\treturn MTK_JPEG_DEC_RESULT_ERROR_BS;\n\n\treturn MTK_JPEG_DEC_RESULT_ERROR_UNKNOWN;\n}\nEXPORT_SYMBOL_GPL(mtk_jpeg_dec_enum_result);\n\nvoid mtk_jpeg_dec_start(void __iomem *base)\n{\n\twritel(0, base + JPGDEC_REG_TRIG);\n}\nEXPORT_SYMBOL_GPL(mtk_jpeg_dec_start);\n\nstatic void mtk_jpeg_dec_soft_reset(void __iomem *base)\n{\n\twritel(0x0000FFFF, base + JPGDEC_REG_INTERRUPT_STATUS);\n\twritel(0x00, base + JPGDEC_REG_RESET);\n\twritel(0x01, base + JPGDEC_REG_RESET);\n}\n\nstatic void mtk_jpeg_dec_hard_reset(void __iomem *base)\n{\n\twritel(0x00, base + JPGDEC_REG_RESET);\n\twritel(0x10, base + JPGDEC_REG_RESET);\n}\n\nvoid mtk_jpeg_dec_reset(void __iomem *base)\n{\n\tmtk_jpeg_dec_soft_reset(base);\n\tmtk_jpeg_dec_hard_reset(base);\n}\nEXPORT_SYMBOL_GPL(mtk_jpeg_dec_reset);\n\nstatic void mtk_jpeg_dec_set_brz_factor(void __iomem *base, u8 yscale_w,\n\t\t\t\t\tu8 yscale_h, u8 uvscale_w, u8 uvscale_h)\n{\n\tu32 val;\n\n\tval = (uvscale_h << 12) | (uvscale_w << 8) |\n\t      (yscale_h << 4) | yscale_w;\n\twritel(val, base + JPGDEC_REG_BRZ_FACTOR);\n}\n\nstatic void mtk_jpeg_dec_set_dst_bank0(void __iomem *base, u32 addr_y,\n\t\t\t\t       u32 addr_u, u32 addr_v)\n{\n\tmtk_jpeg_verify_align(addr_y, 16, JPGDEC_REG_DEST_ADDR0_Y);\n\twritel(addr_y, base + JPGDEC_REG_DEST_ADDR0_Y);\n\tmtk_jpeg_verify_align(addr_u, 16, JPGDEC_REG_DEST_ADDR0_U);\n\twritel(addr_u, base + JPGDEC_REG_DEST_ADDR0_U);\n\tmtk_jpeg_verify_align(addr_v, 16, JPGDEC_REG_DEST_ADDR0_V);\n\twritel(addr_v, base + JPGDEC_REG_DEST_ADDR0_V);\n}\n\nstatic void mtk_jpeg_dec_set_dst_bank1(void __iomem *base, u32 addr_y,\n\t\t\t\t       u32 addr_u, u32 addr_v)\n{\n\twritel(addr_y, base + JPGDEC_REG_DEST_ADDR1_Y);\n\twritel(addr_u, base + JPGDEC_REG_DEST_ADDR1_U);\n\twritel(addr_v, base + JPGDEC_REG_DEST_ADDR1_V);\n}\n\nstatic void mtk_jpeg_dec_set_mem_stride(void __iomem *base, u32 stride_y,\n\t\t\t\t\tu32 stride_uv)\n{\n\twritel((stride_y & 0xFFFF), base + JPGDEC_REG_STRIDE_Y);\n\twritel((stride_uv & 0xFFFF), base + JPGDEC_REG_STRIDE_UV);\n}\n\nstatic void mtk_jpeg_dec_set_img_stride(void __iomem *base, u32 stride_y,\n\t\t\t\t\tu32 stride_uv)\n{\n\twritel((stride_y & 0xFFFF), base + JPGDEC_REG_IMG_STRIDE_Y);\n\twritel((stride_uv & 0xFFFF), base + JPGDEC_REG_IMG_STRIDE_UV);\n}\n\nstatic void mtk_jpeg_dec_set_pause_mcu_idx(void __iomem *base, u32 idx)\n{\n\twritel(idx & 0x0003FFFFFF, base + JPGDEC_REG_PAUSE_MCU_NUM);\n}\n\nstatic void mtk_jpeg_dec_set_dec_mode(void __iomem *base, u32 mode)\n{\n\twritel(mode & 0x03, base + JPGDEC_REG_OPERATION_MODE);\n}\n\nstatic void mtk_jpeg_dec_set_bs_write_ptr(void __iomem *base, u32 ptr)\n{\n\tmtk_jpeg_verify_align(ptr, 16, JPGDEC_REG_FILE_BRP);\n\twritel(ptr, base + JPGDEC_REG_FILE_BRP);\n}\n\nstatic void mtk_jpeg_dec_set_bs_info(void __iomem *base, u32 addr, u32 size,\n\t\t\t\t     u32 bitstream_size)\n{\n\tmtk_jpeg_verify_align(addr, 16, JPGDEC_REG_FILE_ADDR);\n\tmtk_jpeg_verify_align(size, 128, JPGDEC_REG_FILE_TOTAL_SIZE);\n\twritel(addr, base + JPGDEC_REG_FILE_ADDR);\n\twritel(size, base + JPGDEC_REG_FILE_TOTAL_SIZE);\n\twritel(bitstream_size, base + JPGDEC_REG_BIT_STREAM_SIZE);\n}\n\nstatic void mtk_jpeg_dec_set_comp_id(void __iomem *base, u32 id_y, u32 id_u,\n\t\t\t\t     u32 id_v)\n{\n\tu32 val;\n\n\tval = ((id_y & 0x00FF) << 24) | ((id_u & 0x00FF) << 16) |\n\t      ((id_v & 0x00FF) << 8);\n\twritel(val, base + JPGDEC_REG_COMP_ID);\n}\n\nstatic void mtk_jpeg_dec_set_total_mcu(void __iomem *base, u32 num)\n{\n\twritel(num - 1, base + JPGDEC_REG_TOTAL_MCU_NUM);\n}\n\nstatic void mtk_jpeg_dec_set_comp0_du(void __iomem *base, u32 num)\n{\n\twritel(num - 1, base + JPGDEC_REG_COMP0_DATA_UNIT_NUM);\n}\n\nstatic void mtk_jpeg_dec_set_du_membership(void __iomem *base, u32 member,\n\t\t\t\t\t   u32 gmc, u32 isgray)\n{\n\tif (isgray)\n\t\tmember = 0x3FFFFFFC;\n\tmember |= (isgray << 31) | (gmc << 30);\n\twritel(member, base + JPGDEC_REG_DU_CTRL);\n}\n\nstatic void mtk_jpeg_dec_set_q_table(void __iomem *base, u32 id0, u32 id1,\n\t\t\t\t     u32 id2)\n{\n\tu32 val;\n\n\tval = ((id0 & 0x0f) << 8) | ((id1 & 0x0f) << 4) | ((id2 & 0x0f) << 0);\n\twritel(val, base + JPGDEC_REG_QT_ID);\n}\n\nstatic void mtk_jpeg_dec_set_dma_group(void __iomem *base, u32 mcu_group,\n\t\t\t\t       u32 group_num, u32 last_mcu)\n{\n\tu32 val;\n\n\tval = (((mcu_group - 1) & 0x00FF) << 16) |\n\t      (((group_num - 1) & 0x007F) << 8) |\n\t      ((last_mcu - 1) & 0x00FF);\n\twritel(val, base + JPGDEC_REG_WDMA_CTRL);\n}\n\nstatic void mtk_jpeg_dec_set_sampling_factor(void __iomem *base, u32 comp_num,\n\t\t\t\t\t     u32 y_w, u32 y_h, u32 u_w,\n\t\t\t\t\t     u32 u_h, u32 v_w, u32 v_h)\n{\n\tu32 val;\n\tu32 y_wh = (MTK_JPEG_DUNUM_MASK(y_w) << 2) | MTK_JPEG_DUNUM_MASK(y_h);\n\tu32 u_wh = (MTK_JPEG_DUNUM_MASK(u_w) << 2) | MTK_JPEG_DUNUM_MASK(u_h);\n\tu32 v_wh = (MTK_JPEG_DUNUM_MASK(v_w) << 2) | MTK_JPEG_DUNUM_MASK(v_h);\n\n\tif (comp_num == 1)\n\t\tval = 0;\n\telse\n\t\tval = (y_wh << 8) | (u_wh << 4) | v_wh;\n\twritel(val, base + JPGDEC_REG_DU_NUM);\n}\n\nvoid mtk_jpeg_dec_set_config(void __iomem *base,\n\t\t\t     struct mtk_jpeg_dec_param *cfg,\n\t\t\t     u32 bitstream_size,\n\t\t\t     struct mtk_jpeg_bs *bs,\n\t\t\t     struct mtk_jpeg_fb *fb)\n{\n\tmtk_jpeg_dec_set_brz_factor(base, 0, 0, cfg->uv_brz_w, 0);\n\tmtk_jpeg_dec_set_dec_mode(base, 0);\n\tmtk_jpeg_dec_set_comp0_du(base, cfg->unit_num);\n\tmtk_jpeg_dec_set_total_mcu(base, cfg->total_mcu);\n\tmtk_jpeg_dec_set_bs_info(base, bs->str_addr, bs->size, bitstream_size);\n\tmtk_jpeg_dec_set_bs_write_ptr(base, bs->end_addr);\n\tmtk_jpeg_dec_set_du_membership(base, cfg->membership, 1,\n\t\t\t\t       (cfg->comp_num == 1) ? 1 : 0);\n\tmtk_jpeg_dec_set_comp_id(base, cfg->comp_id[0], cfg->comp_id[1],\n\t\t\t\t cfg->comp_id[2]);\n\tmtk_jpeg_dec_set_q_table(base, cfg->qtbl_num[0],\n\t\t\t\t cfg->qtbl_num[1], cfg->qtbl_num[2]);\n\tmtk_jpeg_dec_set_sampling_factor(base, cfg->comp_num,\n\t\t\t\t\t cfg->sampling_w[0],\n\t\t\t\t\t cfg->sampling_h[0],\n\t\t\t\t\t cfg->sampling_w[1],\n\t\t\t\t\t cfg->sampling_h[1],\n\t\t\t\t\t cfg->sampling_w[2],\n\t\t\t\t\t cfg->sampling_h[2]);\n\tmtk_jpeg_dec_set_mem_stride(base, cfg->mem_stride[0],\n\t\t\t\t    cfg->mem_stride[1]);\n\tmtk_jpeg_dec_set_img_stride(base, cfg->img_stride[0],\n\t\t\t\t    cfg->img_stride[1]);\n\tmtk_jpeg_dec_set_dst_bank0(base, fb->plane_addr[0],\n\t\t\t\t   fb->plane_addr[1], fb->plane_addr[2]);\n\tmtk_jpeg_dec_set_dst_bank1(base, 0, 0, 0);\n\tmtk_jpeg_dec_set_dma_group(base, cfg->dma_mcu, cfg->dma_group,\n\t\t\t\t   cfg->dma_last_mcu);\n\tmtk_jpeg_dec_set_pause_mcu_idx(base, cfg->total_mcu);\n}\nEXPORT_SYMBOL_GPL(mtk_jpeg_dec_set_config);\n\nstatic void mtk_jpegdec_put_buf(struct mtk_jpegdec_comp_dev *jpeg)\n{\n\tstruct mtk_jpeg_src_buf *dst_done_buf, *tmp_dst_done_buf;\n\tstruct vb2_v4l2_buffer *dst_buffer;\n\tstruct list_head *temp_entry;\n\tstruct list_head *pos = NULL;\n\tstruct mtk_jpeg_ctx *ctx;\n\tunsigned long flags;\n\n\tctx = jpeg->hw_param.curr_ctx;\n\tif (unlikely(!ctx)) {\n\t\tdev_err(jpeg->dev, \"comp_jpeg ctx fail !!!\\n\");\n\t\treturn;\n\t}\n\n\tdst_buffer = jpeg->hw_param.dst_buffer;\n\tif (!dst_buffer) {\n\t\tdev_err(jpeg->dev, \"comp_jpeg dst_buffer fail !!!\\n\");\n\t\treturn;\n\t}\n\n\tdst_done_buf = container_of(dst_buffer, struct mtk_jpeg_src_buf, b);\n\n\tspin_lock_irqsave(&ctx->done_queue_lock, flags);\n\tlist_add_tail(&dst_done_buf->list, &ctx->dst_done_queue);\n\twhile (!list_empty(&ctx->dst_done_queue) &&\n\t       (pos != &ctx->dst_done_queue)) {\n\t\tlist_for_each_prev_safe(pos, temp_entry, &ctx->dst_done_queue) {\n\t\t\ttmp_dst_done_buf = list_entry(pos,\n\t\t\t\t\t\t      struct mtk_jpeg_src_buf,\n\t\t\t\t\t\t      list);\n\t\t\tif (tmp_dst_done_buf->frame_num ==\n\t\t\t\tctx->last_done_frame_num) {\n\t\t\t\tlist_del(&tmp_dst_done_buf->list);\n\t\t\t\tv4l2_m2m_buf_done(&tmp_dst_done_buf->b,\n\t\t\t\t\t\t  VB2_BUF_STATE_DONE);\n\t\t\t\tctx->last_done_frame_num++;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ctx->done_queue_lock, flags);\n}\n\nstatic void mtk_jpegdec_timeout_work(struct work_struct *work)\n{\n\tenum vb2_buffer_state buf_state = VB2_BUF_STATE_ERROR;\n\tstruct mtk_jpegdec_comp_dev *cjpeg =\n\t\tcontainer_of(work, struct mtk_jpegdec_comp_dev,\n\t\t\t     job_timeout_work.work);\n\tstruct mtk_jpeg_dev *master_jpeg = cjpeg->master_dev;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\n\tsrc_buf = cjpeg->hw_param.src_buffer;\n\tdst_buf = cjpeg->hw_param.dst_buffer;\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, true);\n\n\tmtk_jpeg_dec_reset(cjpeg->reg_base);\n\tclk_disable_unprepare(cjpeg->jdec_clk.clks->clk);\n\tpm_runtime_put(cjpeg->dev);\n\tcjpeg->hw_state = MTK_JPEG_HW_IDLE;\n\tatomic_inc(&master_jpeg->hw_rdy);\n\twake_up(&master_jpeg->hw_wq);\n\tv4l2_m2m_buf_done(src_buf, buf_state);\n\tmtk_jpegdec_put_buf(cjpeg);\n}\n\nstatic irqreturn_t mtk_jpegdec_hw_irq_handler(int irq, void *priv)\n{\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct mtk_jpeg_src_buf *jpeg_src_buf;\n\tenum vb2_buffer_state buf_state;\n\tstruct mtk_jpeg_ctx *ctx;\n\tu32 dec_irq_ret;\n\tu32 irq_status;\n\tint i;\n\n\tstruct mtk_jpegdec_comp_dev *jpeg = priv;\n\tstruct mtk_jpeg_dev *master_jpeg = jpeg->master_dev;\n\n\tcancel_delayed_work(&jpeg->job_timeout_work);\n\n\tctx = jpeg->hw_param.curr_ctx;\n\tsrc_buf = jpeg->hw_param.src_buffer;\n\tdst_buf = jpeg->hw_param.dst_buffer;\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, true);\n\n\tirq_status = mtk_jpeg_dec_get_int_status(jpeg->reg_base);\n\tdec_irq_ret = mtk_jpeg_dec_enum_result(irq_status);\n\tif (dec_irq_ret >= MTK_JPEG_DEC_RESULT_UNDERFLOW)\n\t\tmtk_jpeg_dec_reset(jpeg->reg_base);\n\n\tif (dec_irq_ret != MTK_JPEG_DEC_RESULT_EOF_DONE)\n\t\tdev_warn(jpeg->dev, \"Jpg Dec occurs unknown Err.\");\n\n\tjpeg_src_buf =\n\t\tcontainer_of(src_buf, struct mtk_jpeg_src_buf, b);\n\n\tfor (i = 0; i < dst_buf->vb2_buf.num_planes; i++)\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, i,\n\t\t\t\t      jpeg_src_buf->dec_param.comp_size[i]);\n\n\tbuf_state = VB2_BUF_STATE_DONE;\n\tv4l2_m2m_buf_done(src_buf, buf_state);\n\tmtk_jpegdec_put_buf(jpeg);\n\tpm_runtime_put(ctx->jpeg->dev);\n\tclk_disable_unprepare(jpeg->jdec_clk.clks->clk);\n\n\tjpeg->hw_state = MTK_JPEG_HW_IDLE;\n\twake_up(&master_jpeg->hw_wq);\n\tatomic_inc(&master_jpeg->hw_rdy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mtk_jpegdec_hw_init_irq(struct mtk_jpegdec_comp_dev *dev)\n{\n\tstruct platform_device *pdev = dev->plat_dev;\n\tint ret;\n\n\tdev->jpegdec_irq = platform_get_irq(pdev, 0);\n\tif (dev->jpegdec_irq < 0)\n\t\treturn dev->jpegdec_irq;\n\n\tret = devm_request_irq(&pdev->dev,\n\t\t\t       dev->jpegdec_irq,\n\t\t\t       mtk_jpegdec_hw_irq_handler,\n\t\t\t       0,\n\t\t\t       pdev->name, dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to devm_request_irq %d (%d)\",\n\t\t\tdev->jpegdec_irq, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_jpegdec_destroy_workqueue(void *data)\n{\n\tdestroy_workqueue(data);\n}\n\nstatic int mtk_jpegdec_hw_probe(struct platform_device *pdev)\n{\n\tstruct mtk_jpegdec_clk *jpegdec_clk;\n\tstruct mtk_jpeg_dev *master_dev;\n\tstruct mtk_jpegdec_comp_dev *dev;\n\tint ret, i;\n\n\tstruct device *decs = &pdev->dev;\n\n\tif (!decs->parent)\n\t\treturn -EPROBE_DEFER;\n\n\tmaster_dev = dev_get_drvdata(decs->parent);\n\tif (!master_dev)\n\t\treturn -EPROBE_DEFER;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->plat_dev = pdev;\n\tdev->dev = &pdev->dev;\n\n\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       mtk_jpegdec_destroy_workqueue,\n\t\t\t\t       master_dev->workqueue);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_init(&dev->hw_lock);\n\tdev->hw_state = MTK_JPEG_HW_IDLE;\n\n\tINIT_DELAYED_WORK(&dev->job_timeout_work,\n\t\t\t  mtk_jpegdec_timeout_work);\n\n\tjpegdec_clk = &dev->jdec_clk;\n\n\tjpegdec_clk->clk_num = devm_clk_bulk_get_all(&pdev->dev,\n\t\t\t\t\t\t     &jpegdec_clk->clks);\n\tif (jpegdec_clk->clk_num < 0)\n\t\treturn dev_err_probe(&pdev->dev,\n\t\t\t\t      jpegdec_clk->clk_num,\n\t\t\t\t      \"Failed to get jpegdec clock count.\\n\");\n\n\tdev->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->reg_base))\n\t\treturn PTR_ERR(dev->reg_base);\n\n\tret = mtk_jpegdec_hw_init_irq(dev);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"Failed to register JPEGDEC irq handler.\\n\");\n\n\ti = atomic_add_return(1, &master_dev->hw_index) - 1;\n\tmaster_dev->dec_hw_dev[i] = dev;\n\tmaster_dev->reg_decbase[i] = dev->reg_base;\n\tdev->master_dev = master_dev;\n\n\tplatform_set_drvdata(pdev, dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mtk_jpegdec_hw_driver = {\n\t.probe = mtk_jpegdec_hw_probe,\n\t.driver = {\n\t\t.name = \"mtk-jpegdec-hw\",\n\t\t.of_match_table = mtk_jpegdec_hw_ids,\n\t},\n};\n\nmodule_platform_driver(mtk_jpegdec_hw_driver);\n\nMODULE_DESCRIPTION(\"MediaTek JPEG decode HW driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}