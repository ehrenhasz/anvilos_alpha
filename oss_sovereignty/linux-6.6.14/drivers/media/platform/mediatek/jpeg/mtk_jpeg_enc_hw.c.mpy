{
  "module_name": "mtk_jpeg_enc_hw.c",
  "hash_id": "335188a493d583ac25c271a0ddaedfb32d79621fe8020c6b618a63bace0097d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/jpeg/mtk_jpeg_enc_hw.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <media/media-device.h>\n#include <media/videobuf2-core.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n\n#include \"mtk_jpeg_core.h\"\n#include \"mtk_jpeg_enc_hw.h\"\n\nstatic const struct mtk_jpeg_enc_qlt mtk_jpeg_enc_quality[] = {\n\t{.quality_param = 34, .hardware_value = JPEG_ENC_QUALITY_Q34},\n\t{.quality_param = 39, .hardware_value = JPEG_ENC_QUALITY_Q39},\n\t{.quality_param = 48, .hardware_value = JPEG_ENC_QUALITY_Q48},\n\t{.quality_param = 60, .hardware_value = JPEG_ENC_QUALITY_Q60},\n\t{.quality_param = 64, .hardware_value = JPEG_ENC_QUALITY_Q64},\n\t{.quality_param = 68, .hardware_value = JPEG_ENC_QUALITY_Q68},\n\t{.quality_param = 74, .hardware_value = JPEG_ENC_QUALITY_Q74},\n\t{.quality_param = 80, .hardware_value = JPEG_ENC_QUALITY_Q80},\n\t{.quality_param = 82, .hardware_value = JPEG_ENC_QUALITY_Q82},\n\t{.quality_param = 84, .hardware_value = JPEG_ENC_QUALITY_Q84},\n\t{.quality_param = 87, .hardware_value = JPEG_ENC_QUALITY_Q87},\n\t{.quality_param = 90, .hardware_value = JPEG_ENC_QUALITY_Q90},\n\t{.quality_param = 92, .hardware_value = JPEG_ENC_QUALITY_Q92},\n\t{.quality_param = 95, .hardware_value = JPEG_ENC_QUALITY_Q95},\n\t{.quality_param = 97, .hardware_value = JPEG_ENC_QUALITY_Q97},\n};\n\nstatic const struct of_device_id mtk_jpegenc_drv_ids[] = {\n\t{\n\t\t.compatible = \"mediatek,mt8195-jpgenc-hw\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_jpegenc_drv_ids);\n\nvoid mtk_jpeg_enc_reset(void __iomem *base)\n{\n\twritel(0, base + JPEG_ENC_RSTB);\n\twritel(JPEG_ENC_RESET_BIT, base + JPEG_ENC_RSTB);\n\twritel(0, base + JPEG_ENC_CODEC_SEL);\n}\nEXPORT_SYMBOL_GPL(mtk_jpeg_enc_reset);\n\nu32 mtk_jpeg_enc_get_file_size(void __iomem *base)\n{\n\treturn readl(base + JPEG_ENC_DMA_ADDR0) -\n\t       readl(base + JPEG_ENC_DST_ADDR0);\n}\nEXPORT_SYMBOL_GPL(mtk_jpeg_enc_get_file_size);\n\nvoid mtk_jpeg_enc_start(void __iomem *base)\n{\n\tu32 value;\n\n\tvalue = readl(base + JPEG_ENC_CTRL);\n\tvalue |= JPEG_ENC_CTRL_INT_EN_BIT | JPEG_ENC_CTRL_ENABLE_BIT;\n\twritel(value, base + JPEG_ENC_CTRL);\n}\nEXPORT_SYMBOL_GPL(mtk_jpeg_enc_start);\n\nvoid mtk_jpeg_set_enc_src(struct mtk_jpeg_ctx *ctx,  void __iomem *base,\n\t\t\t  struct vb2_buffer *src_buf)\n{\n\tint i;\n\tdma_addr_t dma_addr;\n\n\tfor (i = 0; i < src_buf->num_planes; i++) {\n\t\tdma_addr = vb2_dma_contig_plane_dma_addr(src_buf, i) +\n\t\t\t   src_buf->planes[i].data_offset;\n\t\tif (!i)\n\t\t\twritel(dma_addr, base + JPEG_ENC_SRC_LUMA_ADDR);\n\t\telse\n\t\t\twritel(dma_addr, base + JPEG_ENC_SRC_CHROMA_ADDR);\n\t}\n}\nEXPORT_SYMBOL_GPL(mtk_jpeg_set_enc_src);\n\nvoid mtk_jpeg_set_enc_dst(struct mtk_jpeg_ctx *ctx, void __iomem *base,\n\t\t\t  struct vb2_buffer *dst_buf)\n{\n\tdma_addr_t dma_addr;\n\tsize_t size;\n\tu32 dma_addr_offset;\n\tu32 dma_addr_offsetmask;\n\n\tdma_addr = vb2_dma_contig_plane_dma_addr(dst_buf, 0);\n\tdma_addr_offset = ctx->enable_exif ? MTK_JPEG_MAX_EXIF_SIZE : 0;\n\tdma_addr_offsetmask = dma_addr & JPEG_ENC_DST_ADDR_OFFSET_MASK;\n\tsize = vb2_plane_size(dst_buf, 0);\n\n\twritel(dma_addr_offset & ~0xf, base + JPEG_ENC_OFFSET_ADDR);\n\twritel(dma_addr_offsetmask & 0xf, base + JPEG_ENC_BYTE_OFFSET_MASK);\n\twritel(dma_addr & ~0xf, base + JPEG_ENC_DST_ADDR0);\n\twritel((dma_addr + size) & ~0xf, base + JPEG_ENC_STALL_ADDR0);\n}\nEXPORT_SYMBOL_GPL(mtk_jpeg_set_enc_dst);\n\nvoid mtk_jpeg_set_enc_params(struct mtk_jpeg_ctx *ctx,  void __iomem *base)\n{\n\tu32 value;\n\tu32 width = ctx->out_q.enc_crop_rect.width;\n\tu32 height = ctx->out_q.enc_crop_rect.height;\n\tu32 enc_format = ctx->out_q.fmt->fourcc;\n\tu32 bytesperline = ctx->out_q.pix_mp.plane_fmt[0].bytesperline;\n\tu32 blk_num;\n\tu32 img_stride;\n\tu32 mem_stride;\n\tu32 i, enc_quality;\n\tu32 nr_enc_quality = ARRAY_SIZE(mtk_jpeg_enc_quality);\n\n\tvalue = width << 16 | height;\n\twritel(value, base + JPEG_ENC_IMG_SIZE);\n\n\tif (enc_format == V4L2_PIX_FMT_NV12M ||\n\t    enc_format == V4L2_PIX_FMT_NV21M)\n\t     \n\t\tblk_num = DIV_ROUND_UP(width, 16) *\n\t\t\t  DIV_ROUND_UP(height, 16) * 6 - 1;\n\telse\n\t\tblk_num = DIV_ROUND_UP(width, 16) *\n\t\t\t  DIV_ROUND_UP(height, 8) * 4 - 1;\n\twritel(blk_num, base + JPEG_ENC_BLK_NUM);\n\n\tif (enc_format == V4L2_PIX_FMT_NV12M ||\n\t    enc_format == V4L2_PIX_FMT_NV21M) {\n\t\t \n\t\timg_stride = round_up(width, 16);\n\t\tmem_stride = bytesperline;\n\t} else {\n\t\t \n\t\timg_stride = round_up(width * 2, 32);\n\t\tmem_stride = img_stride;\n\t}\n\twritel(img_stride, base + JPEG_ENC_IMG_STRIDE);\n\twritel(mem_stride, base + JPEG_ENC_STRIDE);\n\n\tenc_quality = mtk_jpeg_enc_quality[nr_enc_quality - 1].hardware_value;\n\tfor (i = 0; i < nr_enc_quality; i++) {\n\t\tif (ctx->enc_quality <= mtk_jpeg_enc_quality[i].quality_param) {\n\t\t\tenc_quality = mtk_jpeg_enc_quality[i].hardware_value;\n\t\t\tbreak;\n\t\t}\n\t}\n\twritel(enc_quality, base + JPEG_ENC_QUALITY);\n\n\tvalue = readl(base + JPEG_ENC_CTRL);\n\tvalue &= ~JPEG_ENC_CTRL_YUV_FORMAT_MASK;\n\tvalue |= (ctx->out_q.fmt->hw_format & 3) << 3;\n\tif (ctx->enable_exif)\n\t\tvalue |= JPEG_ENC_CTRL_FILE_FORMAT_BIT;\n\telse\n\t\tvalue &= ~JPEG_ENC_CTRL_FILE_FORMAT_BIT;\n\tif (ctx->restart_interval)\n\t\tvalue |= JPEG_ENC_CTRL_RESTART_EN_BIT;\n\telse\n\t\tvalue &= ~JPEG_ENC_CTRL_RESTART_EN_BIT;\n\twritel(value, base + JPEG_ENC_CTRL);\n\n\twritel(ctx->restart_interval, base + JPEG_ENC_RST_MCU_NUM);\n}\nEXPORT_SYMBOL_GPL(mtk_jpeg_set_enc_params);\n\nstatic void mtk_jpegenc_put_buf(struct mtk_jpegenc_comp_dev *jpeg)\n{\n\tstruct mtk_jpeg_ctx *ctx;\n\tstruct vb2_v4l2_buffer *dst_buffer;\n\tstruct list_head *temp_entry;\n\tstruct list_head *pos = NULL;\n\tstruct mtk_jpeg_src_buf *dst_done_buf, *tmp_dst_done_buf;\n\tunsigned long flags;\n\n\tctx = jpeg->hw_param.curr_ctx;\n\tif (!ctx) {\n\t\tdev_err(jpeg->dev, \"comp_jpeg ctx fail !!!\\n\");\n\t\treturn;\n\t}\n\n\tdst_buffer = jpeg->hw_param.dst_buffer;\n\tif (!dst_buffer) {\n\t\tdev_err(jpeg->dev, \"comp_jpeg dst_buffer fail !!!\\n\");\n\t\treturn;\n\t}\n\n\tdst_done_buf = container_of(dst_buffer,\n\t\t\t\t    struct mtk_jpeg_src_buf, b);\n\n\tspin_lock_irqsave(&ctx->done_queue_lock, flags);\n\tlist_add_tail(&dst_done_buf->list, &ctx->dst_done_queue);\n\twhile (!list_empty(&ctx->dst_done_queue) &&\n\t       (pos != &ctx->dst_done_queue)) {\n\t\tlist_for_each_prev_safe(pos, temp_entry, &ctx->dst_done_queue) {\n\t\t\ttmp_dst_done_buf = list_entry(pos,\n\t\t\t\t\t\t      struct mtk_jpeg_src_buf,\n\t\t\t\t\t\t      list);\n\t\t\tif (tmp_dst_done_buf->frame_num ==\n\t\t\t\tctx->last_done_frame_num) {\n\t\t\t\tlist_del(&tmp_dst_done_buf->list);\n\t\t\t\tv4l2_m2m_buf_done(&tmp_dst_done_buf->b,\n\t\t\t\t\t\t  VB2_BUF_STATE_DONE);\n\t\t\t\tctx->last_done_frame_num++;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ctx->done_queue_lock, flags);\n}\n\nstatic void mtk_jpegenc_timeout_work(struct work_struct *work)\n{\n\tstruct delayed_work *dly_work = to_delayed_work(work);\n\tstruct mtk_jpegenc_comp_dev *cjpeg =\n\t\tcontainer_of(dly_work,\n\t\t\t     struct mtk_jpegenc_comp_dev,\n\t\t\t     job_timeout_work);\n\tstruct mtk_jpeg_dev *master_jpeg = cjpeg->master_dev;\n\tenum vb2_buffer_state buf_state = VB2_BUF_STATE_ERROR;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\n\tsrc_buf = cjpeg->hw_param.src_buffer;\n\tdst_buf = cjpeg->hw_param.dst_buffer;\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, true);\n\n\tmtk_jpeg_enc_reset(cjpeg->reg_base);\n\tclk_disable_unprepare(cjpeg->venc_clk.clks->clk);\n\tpm_runtime_put(cjpeg->dev);\n\tcjpeg->hw_state = MTK_JPEG_HW_IDLE;\n\tatomic_inc(&master_jpeg->hw_rdy);\n\twake_up(&master_jpeg->hw_wq);\n\tv4l2_m2m_buf_done(src_buf, buf_state);\n\tmtk_jpegenc_put_buf(cjpeg);\n}\n\nstatic irqreturn_t mtk_jpegenc_hw_irq_handler(int irq, void *priv)\n{\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tenum vb2_buffer_state buf_state;\n\tstruct mtk_jpeg_ctx *ctx;\n\tu32 result_size;\n\tu32 irq_status;\n\n\tstruct mtk_jpegenc_comp_dev *jpeg = priv;\n\tstruct mtk_jpeg_dev *master_jpeg = jpeg->master_dev;\n\n\tcancel_delayed_work(&jpeg->job_timeout_work);\n\n\tctx = jpeg->hw_param.curr_ctx;\n\tsrc_buf = jpeg->hw_param.src_buffer;\n\tdst_buf = jpeg->hw_param.dst_buffer;\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, true);\n\n\tirq_status = readl(jpeg->reg_base + JPEG_ENC_INT_STS) &\n\t\tJPEG_ENC_INT_STATUS_MASK_ALLIRQ;\n\tif (irq_status)\n\t\twritel(0, jpeg->reg_base + JPEG_ENC_INT_STS);\n\tif (!(irq_status & JPEG_ENC_INT_STATUS_DONE))\n\t\tdev_warn(jpeg->dev, \"Jpg Enc occurs unknown Err.\");\n\n\tresult_size = mtk_jpeg_enc_get_file_size(jpeg->reg_base);\n\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, result_size);\n\tbuf_state = VB2_BUF_STATE_DONE;\n\tv4l2_m2m_buf_done(src_buf, buf_state);\n\tmtk_jpegenc_put_buf(jpeg);\n\tpm_runtime_put(ctx->jpeg->dev);\n\tclk_disable_unprepare(jpeg->venc_clk.clks->clk);\n\n\tjpeg->hw_state = MTK_JPEG_HW_IDLE;\n\twake_up(&master_jpeg->hw_wq);\n\tatomic_inc(&master_jpeg->hw_rdy);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mtk_jpegenc_hw_init_irq(struct mtk_jpegenc_comp_dev *dev)\n{\n\tstruct platform_device *pdev = dev->plat_dev;\n\tint ret;\n\n\tdev->jpegenc_irq = platform_get_irq(pdev, 0);\n\tif (dev->jpegenc_irq < 0)\n\t\treturn dev->jpegenc_irq;\n\n\tret = devm_request_irq(&pdev->dev,\n\t\t\t       dev->jpegenc_irq,\n\t\t\t       mtk_jpegenc_hw_irq_handler,\n\t\t\t       0,\n\t\t\t       pdev->name, dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to devm_request_irq %d (%d)\",\n\t\t\tdev->jpegenc_irq, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_jpegenc_hw_probe(struct platform_device *pdev)\n{\n\tstruct mtk_jpegenc_clk *jpegenc_clk;\n\tstruct mtk_jpeg_dev *master_dev;\n\tstruct mtk_jpegenc_comp_dev *dev;\n\tint ret, i;\n\n\tstruct device *decs = &pdev->dev;\n\n\tif (!decs->parent)\n\t\treturn -EPROBE_DEFER;\n\n\tmaster_dev = dev_get_drvdata(decs->parent);\n\tif (!master_dev)\n\t\treturn -EPROBE_DEFER;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->plat_dev = pdev;\n\tdev->dev = &pdev->dev;\n\n\tspin_lock_init(&dev->hw_lock);\n\tdev->hw_state = MTK_JPEG_HW_IDLE;\n\n\tINIT_DELAYED_WORK(&dev->job_timeout_work,\n\t\t\t  mtk_jpegenc_timeout_work);\n\n\tjpegenc_clk = &dev->venc_clk;\n\n\tjpegenc_clk->clk_num = devm_clk_bulk_get_all(&pdev->dev,\n\t\t\t\t\t\t     &jpegenc_clk->clks);\n\tif (jpegenc_clk->clk_num < 0)\n\t\treturn dev_err_probe(&pdev->dev, jpegenc_clk->clk_num,\n\t\t\t\t     \"Failed to get jpegenc clock count\\n\");\n\n\tdev->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->reg_base))\n\t\treturn PTR_ERR(dev->reg_base);\n\n\tret = mtk_jpegenc_hw_init_irq(dev);\n\tif (ret)\n\t\treturn ret;\n\n\ti = atomic_add_return(1, &master_dev->hw_index) - 1;\n\tmaster_dev->enc_hw_dev[i] = dev;\n\tmaster_dev->reg_encbase[i] = dev->reg_base;\n\tdev->master_dev = master_dev;\n\n\tplatform_set_drvdata(pdev, dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mtk_jpegenc_hw_driver = {\n\t.probe = mtk_jpegenc_hw_probe,\n\t.driver = {\n\t\t.name = \"mtk-jpegenc-hw\",\n\t\t.of_match_table = mtk_jpegenc_drv_ids,\n\t},\n};\n\nmodule_platform_driver(mtk_jpegenc_hw_driver);\n\nMODULE_DESCRIPTION(\"MediaTek JPEG encode HW driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}