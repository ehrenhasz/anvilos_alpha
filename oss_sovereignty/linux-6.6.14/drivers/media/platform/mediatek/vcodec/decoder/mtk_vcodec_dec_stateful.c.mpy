{
  "module_name": "mtk_vcodec_dec_stateful.c",
  "hash_id": "08f3d6b27f0d4ea897480bbd156f91d57da4db9e287d5576b292a132fae9410c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/mtk_vcodec_dec_stateful.c",
  "human_readable_source": "\n\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"mtk_vcodec_dec.h\"\n#include \"mtk_vcodec_dec_pm.h\"\n#include \"vdec_drv_if.h\"\n\nstatic struct mtk_video_fmt mtk_video_formats[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_H264,\n\t\t.type = MTK_FMT_DEC,\n\t\t.num_planes = 1,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t\t.frmsize = { MTK_VDEC_MIN_W, MTK_VDEC_MAX_W, 16,\n\t\t\t     MTK_VDEC_MIN_H, MTK_VDEC_MAX_H, 16 },\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_VP8,\n\t\t.type = MTK_FMT_DEC,\n\t\t.num_planes = 1,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t\t.frmsize = { MTK_VDEC_MIN_W, MTK_VDEC_MAX_W, 16,\n\t\t\t     MTK_VDEC_MIN_H, MTK_VDEC_MAX_H, 16 },\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_VP9,\n\t\t.type = MTK_FMT_DEC,\n\t\t.num_planes = 1,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t\t.frmsize = { MTK_VDEC_MIN_W, MTK_VDEC_MAX_W, 16,\n\t\t\t     MTK_VDEC_MIN_H, MTK_VDEC_MAX_H, 16 },\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_MT21C,\n\t\t.type = MTK_FMT_FRAME,\n\t\t.num_planes = 2,\n\t},\n};\n\nstatic const unsigned int num_supported_formats =\n\tARRAY_SIZE(mtk_video_formats);\n\n#define DEFAULT_OUT_FMT_IDX 0\n#define DEFAULT_CAP_FMT_IDX 3\n\n \nstatic struct vb2_buffer *get_display_buffer(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct vdec_fb *disp_frame_buffer = NULL;\n\tstruct mtk_video_dec_buf *dstbuf;\n\tstruct vb2_v4l2_buffer *vb;\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d]\", ctx->id);\n\tif (vdec_if_get_param(ctx, GET_PARAM_DISP_FRAME_BUFFER,\n\t\t\t      &disp_frame_buffer)) {\n\t\tmtk_v4l2_vdec_err(ctx, \"[%d]Cannot get param : GET_PARAM_DISP_FRAME_BUFFER\",\n\t\t\t\t  ctx->id);\n\t\treturn NULL;\n\t}\n\n\tif (!disp_frame_buffer) {\n\t\tmtk_v4l2_vdec_dbg(3, ctx, \"No display frame buffer\");\n\t\treturn NULL;\n\t}\n\n\tdstbuf = container_of(disp_frame_buffer, struct mtk_video_dec_buf,\n\t\t\t      frame_buffer);\n\tvb = &dstbuf->m2m_buf.vb;\n\tmutex_lock(&ctx->lock);\n\tif (dstbuf->used) {\n\t\tmtk_v4l2_vdec_dbg(2, ctx, \"[%d]status=%x queue id=%d to done_list %d\",\n\t\t\t\t  ctx->id, disp_frame_buffer->status,\n\t\t\t\t  vb->vb2_buf.index, dstbuf->queued_in_vb2);\n\n\t\tv4l2_m2m_buf_done(vb, VB2_BUF_STATE_DONE);\n\t\tctx->decoded_frame_cnt++;\n\t}\n\tmutex_unlock(&ctx->lock);\n\treturn &vb->vb2_buf;\n}\n\n \nstatic struct vb2_buffer *get_free_buffer(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct mtk_video_dec_buf *dstbuf;\n\tstruct vdec_fb *free_frame_buffer = NULL;\n\tstruct vb2_v4l2_buffer *vb;\n\n\tif (vdec_if_get_param(ctx, GET_PARAM_FREE_FRAME_BUFFER,\n\t\t\t      &free_frame_buffer)) {\n\t\tmtk_v4l2_vdec_err(ctx, \"[%d] Error!! Cannot get param\", ctx->id);\n\t\treturn NULL;\n\t}\n\tif (!free_frame_buffer) {\n\t\tmtk_v4l2_vdec_dbg(3, ctx, \" No free frame buffer\");\n\t\treturn NULL;\n\t}\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d] tmp_frame_addr = 0x%p\", ctx->id,\n\t\t\t  free_frame_buffer);\n\n\tdstbuf = container_of(free_frame_buffer, struct mtk_video_dec_buf,\n\t\t\t      frame_buffer);\n\tvb = &dstbuf->m2m_buf.vb;\n\n\tmutex_lock(&ctx->lock);\n\tif (dstbuf->used) {\n\t\tif (dstbuf->queued_in_vb2 && dstbuf->queued_in_v4l2 &&\n\t\t    free_frame_buffer->status == FB_ST_FREE) {\n\t\t\t \n\t\t\tmtk_v4l2_vdec_dbg(2, ctx, \"[%d]status=%x queue id=%d to rdy_queue %d\",\n\t\t\t\t\t  ctx->id, free_frame_buffer->status,\n\t\t\t\t\t  vb->vb2_buf.index, dstbuf->queued_in_vb2);\n\t\t\tv4l2_m2m_buf_queue(ctx->m2m_ctx, vb);\n\t\t} else if (!dstbuf->queued_in_vb2 && dstbuf->queued_in_v4l2) {\n\t\t\t \n\t\t\tmtk_v4l2_vdec_dbg(2, ctx,\n\t\t\t\t\t  \"[%d]status=%x queue id=%d to rdy_queue\",\n\t\t\t\t\t  ctx->id, free_frame_buffer->status,\n\t\t\t\t\t  vb->vb2_buf.index);\n\t\t\tv4l2_m2m_buf_queue(ctx->m2m_ctx, vb);\n\t\t\tdstbuf->queued_in_vb2 = true;\n\t\t} else {\n\t\t\t \n\t\t\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d]status=%x err queue id=%d %d %d\",\n\t\t\t\t\t  ctx->id, free_frame_buffer->status,\n\t\t\t\t\t  vb->vb2_buf.index, dstbuf->queued_in_vb2,\n\t\t\t\t\t  dstbuf->queued_in_v4l2);\n\t\t}\n\t\tdstbuf->used = false;\n\t}\n\tmutex_unlock(&ctx->lock);\n\treturn &vb->vb2_buf;\n}\n\nstatic void clean_display_buffer(struct mtk_vcodec_dec_ctx *ctx)\n{\n\twhile (get_display_buffer(ctx))\n\t\t;\n}\n\nstatic void clean_free_buffer(struct mtk_vcodec_dec_ctx *ctx)\n{\n\twhile (get_free_buffer(ctx))\n\t\t;\n}\n\nstatic void mtk_vdec_queue_res_chg_event(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstatic const struct v4l2_event ev_src_ch = {\n\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n\t};\n\n\tmtk_v4l2_vdec_dbg(1, ctx, \"[%d]\", ctx->id);\n\tv4l2_event_queue_fh(&ctx->fh, &ev_src_ch);\n}\n\nstatic int mtk_vdec_flush_decoder(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tbool res_chg;\n\tint ret;\n\n\tret = vdec_if_decode(ctx, NULL, NULL, &res_chg);\n\tif (ret)\n\t\tmtk_v4l2_vdec_err(ctx, \"DecodeFinal failed, ret=%d\", ret);\n\n\tclean_display_buffer(ctx);\n\tclean_free_buffer(ctx);\n\n\treturn 0;\n}\n\nstatic void mtk_vdec_update_fmt(struct mtk_vcodec_dec_ctx *ctx,\n\t\t\t\tunsigned int pixelformat)\n{\n\tconst struct mtk_video_fmt *fmt;\n\tstruct mtk_q_data *dst_q_data;\n\tunsigned int k;\n\n\tdst_q_data = &ctx->q_data[MTK_Q_DATA_DST];\n\tfor (k = 0; k < num_supported_formats; k++) {\n\t\tfmt = &mtk_video_formats[k];\n\t\tif (fmt->fourcc == pixelformat) {\n\t\t\tmtk_v4l2_vdec_dbg(1, ctx, \"Update cap fourcc(%d -> %d)\",\n\t\t\t\t\t  dst_q_data->fmt->fourcc, pixelformat);\n\t\t\tdst_q_data->fmt = fmt;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmtk_v4l2_vdec_err(ctx, \"Cannot get fourcc(%d), using init value\", pixelformat);\n}\n\nstatic int mtk_vdec_pic_info_update(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tunsigned int dpbsize = 0;\n\tint ret;\n\n\tif (vdec_if_get_param(ctx, GET_PARAM_PIC_INFO,\n\t\t\t      &ctx->last_decoded_picinfo)) {\n\t\tmtk_v4l2_vdec_err(ctx, \"[%d]Error!! Cannot get param : GET_PARAM_PICTURE_INFO ERR\",\n\t\t\t\t  ctx->id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->last_decoded_picinfo.pic_w == 0 ||\n\t    ctx->last_decoded_picinfo.pic_h == 0 ||\n\t    ctx->last_decoded_picinfo.buf_w == 0 ||\n\t    ctx->last_decoded_picinfo.buf_h == 0) {\n\t\tmtk_v4l2_vdec_err(ctx, \"Cannot get correct pic info\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->last_decoded_picinfo.cap_fourcc != ctx->picinfo.cap_fourcc &&\n\t    ctx->picinfo.cap_fourcc != 0)\n\t\tmtk_vdec_update_fmt(ctx, ctx->picinfo.cap_fourcc);\n\n\tif (ctx->last_decoded_picinfo.pic_w == ctx->picinfo.pic_w ||\n\t    ctx->last_decoded_picinfo.pic_h == ctx->picinfo.pic_h)\n\t\treturn 0;\n\n\tmtk_v4l2_vdec_dbg(1, ctx, \"[%d]-> new(%d,%d), old(%d,%d), real(%d,%d)\", ctx->id,\n\t\t\t  ctx->last_decoded_picinfo.pic_w,\n\t\t\t  ctx->last_decoded_picinfo.pic_h, ctx->picinfo.pic_w,\n\t\t\t  ctx->picinfo.pic_h, ctx->last_decoded_picinfo.buf_w,\n\t\t\t  ctx->last_decoded_picinfo.buf_h);\n\n\tret = vdec_if_get_param(ctx, GET_PARAM_DPB_SIZE, &dpbsize);\n\tif (dpbsize == 0)\n\t\tmtk_v4l2_vdec_err(ctx, \"Incorrect dpb size, ret=%d\", ret);\n\n\tctx->dpb_size = dpbsize;\n\n\treturn ret;\n}\n\nstatic void mtk_vdec_worker(struct work_struct *work)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx =\n\t\tcontainer_of(work, struct mtk_vcodec_dec_ctx, decode_work);\n\tstruct mtk_vcodec_dec_dev *dev = ctx->dev;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct mtk_vcodec_mem buf;\n\tstruct vdec_fb *pfb;\n\tbool res_chg = false;\n\tint ret;\n\tstruct mtk_video_dec_buf *dst_buf_info, *src_buf_info;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\n\tif (!src_buf) {\n\t\tv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\n\t\tmtk_v4l2_vdec_dbg(1, ctx, \"[%d] src_buf empty!!\", ctx->id);\n\t\treturn;\n\t}\n\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\n\tif (!dst_buf) {\n\t\tv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\n\t\tmtk_v4l2_vdec_dbg(1, ctx, \"[%d] dst_buf empty!!\", ctx->id);\n\t\treturn;\n\t}\n\n\tdst_buf_info =\n\t\tcontainer_of(dst_buf, struct mtk_video_dec_buf, m2m_buf.vb);\n\n\tpfb = &dst_buf_info->frame_buffer;\n\tpfb->base_y.va = vb2_plane_vaddr(&dst_buf->vb2_buf, 0);\n\tpfb->base_y.dma_addr =\n\t\tvb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\tpfb->base_y.size = ctx->picinfo.fb_sz[0];\n\n\tpfb->base_c.va = vb2_plane_vaddr(&dst_buf->vb2_buf, 1);\n\tpfb->base_c.dma_addr =\n\t\tvb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 1);\n\tpfb->base_c.size = ctx->picinfo.fb_sz[1];\n\tpfb->status = 0;\n\tmtk_v4l2_vdec_dbg(3, ctx, \"===>[%d] vdec_if_decode() ===>\", ctx->id);\n\n\tmtk_v4l2_vdec_dbg(3, ctx,\n\t\t\t  \"id=%d Framebuf  pfb=%p VA=%p Y_DMA=%pad C_DMA=%pad Size=%zx\",\n\t\t\t  dst_buf->vb2_buf.index, pfb, pfb->base_y.va,\n\t\t\t  &pfb->base_y.dma_addr, &pfb->base_c.dma_addr, pfb->base_y.size);\n\n\tif (src_buf == &ctx->empty_flush_buf.vb) {\n\t\tmtk_v4l2_vdec_dbg(1, ctx, \"Got empty flush input buffer.\");\n\t\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\n\t\t \n\t\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\n\t\tmutex_lock(&ctx->lock);\n\t\tdst_buf_info->used = false;\n\t\tmutex_unlock(&ctx->lock);\n\n\t\tvdec_if_decode(ctx, NULL, NULL, &res_chg);\n\t\tclean_display_buffer(ctx);\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, 0);\n\t\tif (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 2)\n\t\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 1, 0);\n\t\tdst_buf->flags |= V4L2_BUF_FLAG_LAST;\n\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);\n\t\tclean_free_buffer(ctx);\n\t\tv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\n\t\treturn;\n\t}\n\n\tsrc_buf_info =\n\t\tcontainer_of(src_buf, struct mtk_video_dec_buf, m2m_buf.vb);\n\n\tbuf.va = vb2_plane_vaddr(&src_buf->vb2_buf, 0);\n\tbuf.dma_addr = vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\n\tbuf.size = (size_t)src_buf->vb2_buf.planes[0].bytesused;\n\tif (!buf.va) {\n\t\tv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\n\t\tmtk_v4l2_vdec_err(ctx, \"[%d] id=%d src_addr is NULL!!\", ctx->id,\n\t\t\t\t  src_buf->vb2_buf.index);\n\t\treturn;\n\t}\n\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d] Bitstream VA=%p DMA=%pad Size=%zx vb=%p\",\n\t\t\t  ctx->id, buf.va, &buf.dma_addr, buf.size, src_buf);\n\tdst_buf->vb2_buf.timestamp = src_buf->vb2_buf.timestamp;\n\tdst_buf->timecode = src_buf->timecode;\n\tmutex_lock(&ctx->lock);\n\tdst_buf_info->used = true;\n\tmutex_unlock(&ctx->lock);\n\tsrc_buf_info->used = true;\n\n\tret = vdec_if_decode(ctx, &buf, pfb, &res_chg);\n\n\tif (ret) {\n\t\tmtk_v4l2_vdec_err(ctx,\n\t\t\t\t  \"[%d] decode src[%d] sz=0x%zx pts=%llu dst[%d] ret=%d res_chg=%d\",\n\t\t\t\t  ctx->id, src_buf->vb2_buf.index, buf.size,\n\t\t\t\t  src_buf->vb2_buf.timestamp, dst_buf->vb2_buf.index, ret, res_chg);\n\t\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\t\tif (ret == -EIO) {\n\t\t\tmutex_lock(&ctx->lock);\n\t\t\tsrc_buf_info->error = true;\n\t\t\tmutex_unlock(&ctx->lock);\n\t\t}\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\n\t} else if (!res_chg) {\n\t\t \n\t\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\t}\n\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\n\tclean_display_buffer(ctx);\n\tclean_free_buffer(ctx);\n\n\tif (!ret && res_chg) {\n\t\tmtk_vdec_pic_info_update(ctx);\n\t\t \n\t\tmtk_vdec_flush_decoder(ctx);\n\t\t \n\t\tmtk_vdec_queue_res_chg_event(ctx);\n\t}\n\tv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\n}\n\nstatic void vb2ops_vdec_stateful_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *src_buf;\n\tstruct mtk_vcodec_mem src_mem;\n\tbool res_chg = false;\n\tint ret;\n\tunsigned int dpbsize = 1, i;\n\tstruct mtk_vcodec_dec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vb2_v4l2;\n\tstruct mtk_q_data *dst_q_data;\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d] (%d) id=%d, vb=%p\", ctx->id,\n\t\t\t  vb->vb2_queue->type, vb->index, vb);\n\t \n\tif (vb->vb2_queue->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tstruct mtk_video_dec_buf *buf;\n\n\t\tvb2_v4l2 = to_vb2_v4l2_buffer(vb);\n\t\tbuf = container_of(vb2_v4l2, struct mtk_video_dec_buf,\n\t\t\t\t   m2m_buf.vb);\n\t\tmutex_lock(&ctx->lock);\n\t\tif (!buf->used) {\n\t\t\tv4l2_m2m_buf_queue(ctx->m2m_ctx, vb2_v4l2);\n\t\t\tbuf->queued_in_vb2 = true;\n\t\t\tbuf->queued_in_v4l2 = true;\n\t\t} else {\n\t\t\tbuf->queued_in_vb2 = false;\n\t\t\tbuf->queued_in_v4l2 = true;\n\t\t}\n\t\tmutex_unlock(&ctx->lock);\n\t\treturn;\n\t}\n\n\tv4l2_m2m_buf_queue(ctx->m2m_ctx, to_vb2_v4l2_buffer(vb));\n\n\tif (ctx->state != MTK_STATE_INIT) {\n\t\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d] already init driver %d\", ctx->id, ctx->state);\n\t\treturn;\n\t}\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\n\tif (!src_buf) {\n\t\tmtk_v4l2_vdec_err(ctx, \"No src buffer\");\n\t\treturn;\n\t}\n\n\tif (src_buf == &ctx->empty_flush_buf.vb) {\n\t\t \n\t\tmtk_v4l2_vdec_err(ctx, \"Invalid flush buffer.\");\n\t\tv4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\t\treturn;\n\t}\n\n\tsrc_mem.va = vb2_plane_vaddr(&src_buf->vb2_buf, 0);\n\tsrc_mem.dma_addr = vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\n\tsrc_mem.size = (size_t)src_buf->vb2_buf.planes[0].bytesused;\n\tmtk_v4l2_vdec_dbg(2, ctx, \"[%d] buf id=%d va=%p dma=%pad size=%zx\", ctx->id,\n\t\t\t  src_buf->vb2_buf.index, src_mem.va, &src_mem.dma_addr, src_mem.size);\n\n\tret = vdec_if_decode(ctx, &src_mem, NULL, &res_chg);\n\tif (ret || !res_chg) {\n\t\t \n\n\t\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\t\tif (ret == -EIO) {\n\t\t\tmtk_v4l2_vdec_err(ctx, \"[%d] Unrecoverable error in vdec_if_decode.\",\n\t\t\t\t\t  ctx->id);\n\t\t\tctx->state = MTK_STATE_ABORT;\n\t\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\n\t\t} else {\n\t\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\t\t}\n\t\tmtk_v4l2_vdec_dbg(ret ? 0 : 1, ctx,\n\t\t\t\t  \"[%d] decode() src_buf=%d, size=%zu, fail=%d, res_chg=%d\",\n\t\t\t\t  ctx->id, src_buf->vb2_buf.index, src_mem.size, ret, res_chg);\n\t\treturn;\n\t}\n\n\tif (vdec_if_get_param(ctx, GET_PARAM_PIC_INFO, &ctx->picinfo)) {\n\t\tmtk_v4l2_vdec_err(ctx, \"[%d]Error!! Cannot get param : GET_PARAM_PICTURE_INFO ERR\",\n\t\t\t\t  ctx->id);\n\t\treturn;\n\t}\n\n\tctx->last_decoded_picinfo = ctx->picinfo;\n\tdst_q_data = &ctx->q_data[MTK_Q_DATA_DST];\n\tfor (i = 0; i < dst_q_data->fmt->num_planes; i++) {\n\t\tdst_q_data->sizeimage[i] = ctx->picinfo.fb_sz[i];\n\t\tdst_q_data->bytesperline[i] = ctx->picinfo.buf_w;\n\t}\n\n\tmtk_v4l2_vdec_dbg(2, ctx, \"[%d] init OK wxh=%dx%d pic wxh=%dx%d sz[0]=0x%x sz[1]=0x%x\",\n\t\t\t  ctx->id, ctx->picinfo.buf_w, ctx->picinfo.buf_h, ctx->picinfo.pic_w,\n\t\t\t  ctx->picinfo.pic_h, dst_q_data->sizeimage[0], dst_q_data->sizeimage[1]);\n\n\tret = vdec_if_get_param(ctx, GET_PARAM_DPB_SIZE, &dpbsize);\n\tif (dpbsize == 0)\n\t\tmtk_v4l2_vdec_err(ctx, \"[%d] GET_PARAM_DPB_SIZE fail=%d\", ctx->id, ret);\n\n\tctx->dpb_size = dpbsize;\n\tctx->state = MTK_STATE_HEADER;\n\tmtk_v4l2_vdec_dbg(1, ctx, \"[%d] dpbsize=%d\", ctx->id, ctx->dpb_size);\n\n\tmtk_vdec_queue_res_chg_event(ctx);\n}\n\nstatic int mtk_vdec_g_v_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = ctrl_to_dec_ctx(ctrl);\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:\n\t\tif (ctx->state >= MTK_STATE_HEADER) {\n\t\t\tctrl->val = ctx->dpb_size;\n\t\t} else {\n\t\t\tmtk_v4l2_vdec_dbg(0, ctx, \"Seqinfo not ready\");\n\t\t\tctrl->val = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops mtk_vcodec_dec_ctrl_ops = {\n\t.g_volatile_ctrl = mtk_vdec_g_v_ctrl,\n};\n\nstatic int mtk_vcodec_dec_ctrls_setup(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct v4l2_ctrl *ctrl;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_hdl, 1);\n\n\tctrl = v4l2_ctrl_new_std(&ctx->ctrl_hdl, &mtk_vcodec_dec_ctrl_ops,\n\t\t\t\t V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 0, 32, 1, 1);\n\tctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\n\tv4l2_ctrl_new_std_menu(&ctx->ctrl_hdl, &mtk_vcodec_dec_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_VP9_PROFILE,\n\t\t\t       V4L2_MPEG_VIDEO_VP9_PROFILE_0, 0,\n\t\t\t       V4L2_MPEG_VIDEO_VP9_PROFILE_0);\n\t \n\tv4l2_ctrl_new_std_menu(&ctx->ctrl_hdl, &mtk_vcodec_dec_ctrl_ops,\n\t\t\t       V4L2_CID_MPEG_VIDEO_H264_PROFILE, V4L2_MPEG_VIDEO_H264_PROFILE_HIGH,\n\t\t\t       BIT(V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE) |\n\t\t\t       BIT(V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED),\n\t\t\t       V4L2_MPEG_VIDEO_H264_PROFILE_MAIN);\n\n\tif (ctx->ctrl_hdl.error) {\n\t\tmtk_v4l2_vdec_err(ctx, \"Adding control failed %d\", ctx->ctrl_hdl.error);\n\t\treturn ctx->ctrl_hdl.error;\n\t}\n\n\tv4l2_ctrl_handler_setup(&ctx->ctrl_hdl);\n\treturn 0;\n}\n\nstatic void mtk_init_vdec_params(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tunsigned int i;\n\n\tif (!(ctx->dev->dec_capability & VCODEC_CAPABILITY_4K_DISABLED)) {\n\t\tfor (i = 0; i < num_supported_formats; i++) {\n\t\t\tif (mtk_video_formats[i].type != MTK_FMT_DEC)\n\t\t\t\tcontinue;\n\n\t\t\tmtk_video_formats[i].frmsize.max_width =\n\t\t\t\tVCODEC_DEC_4K_CODED_WIDTH;\n\t\t\tmtk_video_formats[i].frmsize.max_height =\n\t\t\t\tVCODEC_DEC_4K_CODED_HEIGHT;\n\t\t}\n\t}\n}\n\nstatic struct vb2_ops mtk_vdec_frame_vb2_ops = {\n\t.queue_setup = vb2ops_vdec_queue_setup,\n\t.buf_prepare = vb2ops_vdec_buf_prepare,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = vb2ops_vdec_start_streaming,\n\n\t.buf_queue = vb2ops_vdec_stateful_buf_queue,\n\t.buf_init = vb2ops_vdec_buf_init,\n\t.buf_finish = vb2ops_vdec_buf_finish,\n\t.stop_streaming = vb2ops_vdec_stop_streaming,\n};\n\nconst struct mtk_vcodec_dec_pdata mtk_vdec_8173_pdata = {\n\t.init_vdec_params = mtk_init_vdec_params,\n\t.ctrls_setup = mtk_vcodec_dec_ctrls_setup,\n\t.vdec_vb2_ops = &mtk_vdec_frame_vb2_ops,\n\t.vdec_formats = mtk_video_formats,\n\t.num_formats = &num_supported_formats,\n\t.default_out_fmt = &mtk_video_formats[DEFAULT_OUT_FMT_IDX],\n\t.default_cap_fmt = &mtk_video_formats[DEFAULT_CAP_FMT_IDX],\n\t.worker = mtk_vdec_worker,\n\t.flush_decoder = mtk_vdec_flush_decoder,\n\t.is_subdev_supported = false,\n\t.hw_arch = MTK_VDEC_PURE_SINGLE_CORE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}