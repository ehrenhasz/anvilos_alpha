{
  "module_name": "vdec_vp8_if.c",
  "hash_id": "951eaa2b4c599681818ef75ba5ac8c973e40ecfa3ec1d79a774559158a7e3af7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_vp8_if.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"../vdec_drv_if.h\"\n#include \"../mtk_vcodec_dec.h\"\n#include \"../../common/mtk_vcodec_intr.h\"\n#include \"../vdec_vpu_if.h\"\n#include \"../vdec_drv_base.h\"\n\n \n#define VP8_DPB_SIZE\t\t\t4\n\n \n#define VP8_WORKING_BUF_SZ\t\t(45 * 4096)\n\n \n#define VP8_SEGID_DRAM_ADDR\t\t0x3c\n#define VP8_HW_VLD_ADDR\t\t\t0x93C\n#define VP8_HW_VLD_VALUE\t\t0x940\n#define VP8_BSASET\t\t\t0x100\n#define VP8_BSDSET\t\t\t0x104\n#define VP8_RW_CKEN_SET\t\t\t0x0\n#define VP8_RW_DCM_CON\t\t\t0x18\n#define VP8_WO_VLD_SRST\t\t\t0x108\n#define VP8_RW_MISC_SYS_SEL\t\t0x84\n#define VP8_RW_MISC_SPEC_CON\t\t0xC8\n#define VP8_WO_VLD_SRST\t\t\t0x108\n#define VP8_RW_VP8_CTRL\t\t\t0xA4\n#define VP8_RW_MISC_DCM_CON\t\t0xEC\n#define VP8_RW_MISC_SRST\t\t0xF4\n#define VP8_RW_MISC_FUNC_CON\t\t0xCC\n\n#define VP8_MAX_FRM_BUF_NUM\t\t5\n#define VP8_MAX_FRM_BUF_NODE_NUM\t(VP8_MAX_FRM_BUF_NUM * 2)\n\n \n#define VP8_HW_SEGMENT_DATA_SZ\t\t272\n#define VP8_HW_SEGMENT_UINT\t\t4\n\n#define VP8_DEC_TABLE_PROC_LOOP\t\t96\n#define VP8_DEC_TABLE_UNIT\t\t3\n#define VP8_DEC_TABLE_SZ\t\t300\n#define VP8_DEC_TABLE_OFFSET\t\t2\n#define VP8_DEC_TABLE_RW_UNIT\t\t4\n\n \nstruct vdec_vp8_dec_info {\n\tuint64_t working_buf_dma;\n\tuint64_t prev_y_dma;\n\tuint64_t cur_y_fb_dma;\n\tuint64_t cur_c_fb_dma;\n\tuint64_t bs_dma;\n\tuint32_t bs_sz;\n\tuint32_t resolution_changed;\n\tuint32_t show_frame;\n\tuint32_t wait_key_frame;\n};\n\n \nstruct vdec_vp8_vsi {\n\tstruct vdec_vp8_dec_info dec;\n\tstruct vdec_pic_info pic;\n\tuint32_t dec_table[VP8_DEC_TABLE_SZ];\n\tuint32_t segment_buf[VP8_HW_SEGMENT_DATA_SZ][VP8_HW_SEGMENT_UINT];\n\tuint32_t load_data;\n};\n\n \nstruct vdec_vp8_hw_reg_base {\n\tvoid __iomem *misc;\n\tvoid __iomem *ld;\n\tvoid __iomem *top;\n\tvoid __iomem *cm;\n\tvoid __iomem *hwd;\n\tvoid __iomem *hwb;\n};\n\n \nstruct vdec_vp8_vpu_inst {\n\twait_queue_head_t wq_hd;\n\tint signaled;\n\tint failure;\n\tuint32_t inst_addr;\n};\n\n \n\n \nstruct vdec_vp8_inst {\n\tstruct vdec_fb *cur_fb;\n\tstruct vdec_fb_node dec_fb[VP8_MAX_FRM_BUF_NODE_NUM];\n\tstruct list_head available_fb_node_list;\n\tstruct list_head fb_use_list;\n\tstruct list_head fb_free_list;\n\tstruct list_head fb_disp_list;\n\tstruct mtk_vcodec_mem working_buf;\n\tstruct vdec_vp8_hw_reg_base reg_base;\n\tunsigned int frm_cnt;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct vdec_vpu_inst vpu;\n\tstruct vdec_vp8_vsi *vsi;\n};\n\nstatic void get_hw_reg_base(struct vdec_vp8_inst *inst)\n{\n\tvoid __iomem **reg_base = inst->ctx->dev->reg_base;\n\n\tinst->reg_base.top = mtk_vcodec_get_reg_addr(reg_base, VDEC_TOP);\n\tinst->reg_base.cm = mtk_vcodec_get_reg_addr(reg_base, VDEC_CM);\n\tinst->reg_base.hwd = mtk_vcodec_get_reg_addr(reg_base, VDEC_HWD);\n\tinst->reg_base.misc = mtk_vcodec_get_reg_addr(reg_base, VDEC_MISC);\n\tinst->reg_base.ld = mtk_vcodec_get_reg_addr(reg_base, VDEC_LD);\n\tinst->reg_base.hwb = mtk_vcodec_get_reg_addr(reg_base, VDEC_HWB);\n}\n\nstatic void write_hw_segmentation_data(struct vdec_vp8_inst *inst)\n{\n\tint i, j;\n\tu32 seg_id_addr;\n\tu32 val;\n\tvoid __iomem *cm = inst->reg_base.cm;\n\tstruct vdec_vp8_vsi *vsi = inst->vsi;\n\n\tseg_id_addr = readl(inst->reg_base.top + VP8_SEGID_DRAM_ADDR) >> 4;\n\n\tfor (i = 0; i < ARRAY_SIZE(vsi->segment_buf); i++) {\n\t\tfor (j = ARRAY_SIZE(vsi->segment_buf[i]) - 1; j >= 0; j--) {\n\t\t\tval = (1 << 16) + ((seg_id_addr + i) << 2) + j;\n\t\t\twritel(val, cm + VP8_HW_VLD_ADDR);\n\n\t\t\tval = vsi->segment_buf[i][j];\n\t\t\twritel(val, cm + VP8_HW_VLD_VALUE);\n\t\t}\n\t}\n}\n\nstatic void read_hw_segmentation_data(struct vdec_vp8_inst *inst)\n{\n\tint i, j;\n\tu32 seg_id_addr;\n\tu32 val;\n\tvoid __iomem *cm = inst->reg_base.cm;\n\tstruct vdec_vp8_vsi *vsi = inst->vsi;\n\n\tseg_id_addr = readl(inst->reg_base.top + VP8_SEGID_DRAM_ADDR) >> 4;\n\n\tfor (i = 0; i < ARRAY_SIZE(vsi->segment_buf); i++) {\n\t\tfor (j = ARRAY_SIZE(vsi->segment_buf[i]) - 1; j >= 0; j--) {\n\t\t\tval = ((seg_id_addr + i) << 2) + j;\n\t\t\twritel(val, cm + VP8_HW_VLD_ADDR);\n\n\t\t\tval = readl(cm + VP8_HW_VLD_VALUE);\n\t\t\tvsi->segment_buf[i][j] = val;\n\t\t}\n\t}\n}\n\n \nstatic void enable_hw_rw_function(struct vdec_vp8_inst *inst)\n{\n\tu32 val = 0;\n\tvoid __iomem *misc = inst->reg_base.misc;\n\tvoid __iomem *ld = inst->reg_base.ld;\n\tvoid __iomem *hwb = inst->reg_base.hwb;\n\tvoid __iomem *hwd = inst->reg_base.hwd;\n\n\tmtk_vcodec_write_vdecsys(inst->ctx, VP8_RW_CKEN_SET, 0x1);\n\twritel(0x101, ld + VP8_WO_VLD_SRST);\n\twritel(0x101, hwb + VP8_WO_VLD_SRST);\n\n\tmtk_vcodec_write_vdecsys(inst->ctx, 0, 0x1);\n\tval = readl(misc + VP8_RW_MISC_SRST);\n\twritel((val & 0xFFFFFFFE), misc + VP8_RW_MISC_SRST);\n\n\twritel(0x1, misc + VP8_RW_MISC_SYS_SEL);\n\twritel(0x17F, misc + VP8_RW_MISC_SPEC_CON);\n\twritel(0x71201100, misc + VP8_RW_MISC_FUNC_CON);\n\twritel(0x0, ld + VP8_WO_VLD_SRST);\n\twritel(0x0, hwb + VP8_WO_VLD_SRST);\n\tmtk_vcodec_write_vdecsys(inst->ctx, VP8_RW_DCM_CON, 0x1);\n\twritel(0x1, misc + VP8_RW_MISC_DCM_CON);\n\twritel(0x1, hwd + VP8_RW_VP8_CTRL);\n}\n\nstatic void store_dec_table(struct vdec_vp8_inst *inst)\n{\n\tint i, j;\n\tu32 addr = 0, val = 0;\n\tvoid __iomem *hwd = inst->reg_base.hwd;\n\tu32 *p = &inst->vsi->dec_table[VP8_DEC_TABLE_OFFSET];\n\n\tfor (i = 0; i < VP8_DEC_TABLE_PROC_LOOP; i++) {\n\t\twritel(addr, hwd + VP8_BSASET);\n\t\tfor (j = 0; j < VP8_DEC_TABLE_UNIT ; j++) {\n\t\t\tval = *p++;\n\t\t\twritel(val, hwd + VP8_BSDSET);\n\t\t}\n\t\taddr += VP8_DEC_TABLE_RW_UNIT;\n\t}\n}\n\nstatic void load_dec_table(struct vdec_vp8_inst *inst)\n{\n\tint i;\n\tu32 addr = 0;\n\tu32 *p = &inst->vsi->dec_table[VP8_DEC_TABLE_OFFSET];\n\tvoid __iomem *hwd = inst->reg_base.hwd;\n\n\tfor (i = 0; i < VP8_DEC_TABLE_PROC_LOOP; i++) {\n\t\twritel(addr, hwd + VP8_BSASET);\n\t\t \n\t\t*p++ = readl(hwd + VP8_BSDSET);\n\t\t*p++ = readl(hwd + VP8_BSDSET);\n\t\t*p++ = readl(hwd + VP8_BSDSET) & 0xFFFFFF;\n\t\taddr += VP8_DEC_TABLE_RW_UNIT;\n\t}\n}\n\nstatic void get_pic_info(struct vdec_vp8_inst *inst, struct vdec_pic_info *pic)\n{\n\t*pic = inst->vsi->pic;\n\n\tmtk_vdec_debug(inst->ctx, \"pic(%d, %d), buf(%d, %d)\",\n\t\t       pic->pic_w, pic->pic_h, pic->buf_w, pic->buf_h);\n\tmtk_vdec_debug(inst->ctx, \"fb size: Y(%d), C(%d)\",\n\t\t       pic->fb_sz[0], pic->fb_sz[1]);\n}\n\nstatic void vp8_dec_finish(struct vdec_vp8_inst *inst)\n{\n\tstruct vdec_fb_node *node;\n\tuint64_t prev_y_dma = inst->vsi->dec.prev_y_dma;\n\n\tmtk_vdec_debug(inst->ctx, \"prev fb base dma=%llx\", prev_y_dma);\n\n\t \n\tif (prev_y_dma != 0) {\n\t\tlist_for_each_entry(node, &inst->fb_use_list, list) {\n\t\t\tstruct vdec_fb *fb = (struct vdec_fb *)node->fb;\n\n\t\t\tif (prev_y_dma == (uint64_t)fb->base_y.dma_addr) {\n\t\t\t\tlist_move_tail(&node->list,\n\t\t\t\t\t       &inst->fb_free_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tnode = list_first_entry(&inst->available_fb_node_list,\n\t\t\t\tstruct vdec_fb_node, list);\n\tnode->fb = inst->cur_fb;\n\tlist_move_tail(&node->list, &inst->fb_use_list);\n\n\t \n\tif (inst->vsi->dec.show_frame) {\n\t\tnode = list_first_entry(&inst->available_fb_node_list,\n\t\t\t\t\tstruct vdec_fb_node, list);\n\t\tnode->fb = inst->cur_fb;\n\t\tlist_move_tail(&node->list, &inst->fb_disp_list);\n\t}\n}\n\nstatic void move_fb_list_use_to_free(struct vdec_vp8_inst *inst)\n{\n\tstruct vdec_fb_node *node, *tmp;\n\n\tlist_for_each_entry_safe(node, tmp, &inst->fb_use_list, list)\n\t\tlist_move_tail(&node->list, &inst->fb_free_list);\n}\n\nstatic void init_list(struct vdec_vp8_inst *inst)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&inst->available_fb_node_list);\n\tINIT_LIST_HEAD(&inst->fb_use_list);\n\tINIT_LIST_HEAD(&inst->fb_free_list);\n\tINIT_LIST_HEAD(&inst->fb_disp_list);\n\n\tfor (i = 0; i < ARRAY_SIZE(inst->dec_fb); i++) {\n\t\tINIT_LIST_HEAD(&inst->dec_fb[i].list);\n\t\tinst->dec_fb[i].fb = NULL;\n\t\tlist_add_tail(&inst->dec_fb[i].list,\n\t\t\t      &inst->available_fb_node_list);\n\t}\n}\n\nstatic void add_fb_to_free_list(struct vdec_vp8_inst *inst, void *fb)\n{\n\tstruct vdec_fb_node *node;\n\n\tif (fb) {\n\t\tnode = list_first_entry(&inst->available_fb_node_list,\n\t\t\t\t\tstruct vdec_fb_node, list);\n\t\tnode->fb = fb;\n\t\tlist_move_tail(&node->list, &inst->fb_free_list);\n\t}\n}\n\nstatic int alloc_working_buf(struct vdec_vp8_inst *inst)\n{\n\tint err;\n\tstruct mtk_vcodec_mem *mem = &inst->working_buf;\n\n\tmem->size = VP8_WORKING_BUF_SZ;\n\terr = mtk_vcodec_mem_alloc(inst->ctx, mem);\n\tif (err) {\n\t\tmtk_vdec_err(inst->ctx, \"Cannot allocate working buffer\");\n\t\treturn err;\n\t}\n\n\tinst->vsi->dec.working_buf_dma = (uint64_t)mem->dma_addr;\n\treturn 0;\n}\n\nstatic void free_working_buf(struct vdec_vp8_inst *inst)\n{\n\tstruct mtk_vcodec_mem *mem = &inst->working_buf;\n\n\tif (mem->va)\n\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\n\tinst->vsi->dec.working_buf_dma = 0;\n}\n\nstatic int vdec_vp8_init(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct vdec_vp8_inst *inst;\n\tint err;\n\n\tinst = kzalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn  -ENOMEM;\n\n\tinst->ctx = ctx;\n\n\tinst->vpu.id = IPI_VDEC_VP8;\n\tinst->vpu.ctx = ctx;\n\n\terr = vpu_dec_init(&inst->vpu);\n\tif (err) {\n\t\tmtk_vdec_err(ctx, \"vdec_vp8 init err=%d\", err);\n\t\tgoto error_free_inst;\n\t}\n\n\tinst->vsi = (struct vdec_vp8_vsi *)inst->vpu.vsi;\n\tinit_list(inst);\n\terr = alloc_working_buf(inst);\n\tif (err)\n\t\tgoto error_deinit;\n\n\tget_hw_reg_base(inst);\n\tmtk_vdec_debug(ctx, \"VP8 Instance >> %p\", inst);\n\n\tctx->drv_handle = inst;\n\treturn 0;\n\nerror_deinit:\n\tvpu_dec_deinit(&inst->vpu);\nerror_free_inst:\n\tkfree(inst);\n\treturn err;\n}\n\nstatic int vdec_vp8_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t   struct vdec_fb *fb, bool *res_chg)\n{\n\tstruct vdec_vp8_inst *inst = (struct vdec_vp8_inst *)h_vdec;\n\tstruct vdec_vp8_dec_info *dec = &inst->vsi->dec;\n\tstruct vdec_vpu_inst *vpu = &inst->vpu;\n\tunsigned char *bs_va;\n\tunsigned int data;\n\tint err = 0;\n\tuint64_t y_fb_dma;\n\tuint64_t c_fb_dma;\n\n\t \n\tif (bs == NULL) {\n\t\tmove_fb_list_use_to_free(inst);\n\t\treturn vpu_dec_reset(vpu);\n\t}\n\n\ty_fb_dma = fb ? (u64)fb->base_y.dma_addr : 0;\n\tc_fb_dma = fb ? (u64)fb->base_c.dma_addr : 0;\n\n\tmtk_vdec_debug(inst->ctx, \"+ [%d] FB y_dma=%llx c_dma=%llx fb=%p\",\n\t\t       inst->frm_cnt, y_fb_dma, c_fb_dma, fb);\n\n\tinst->cur_fb = fb;\n\tdec->bs_dma = (unsigned long)bs->dma_addr;\n\tdec->bs_sz = bs->size;\n\tdec->cur_y_fb_dma = y_fb_dma;\n\tdec->cur_c_fb_dma = c_fb_dma;\n\n\tmtk_vdec_debug(inst->ctx, \"\\n + FRAME[%d] +\\n\", inst->frm_cnt);\n\n\twrite_hw_segmentation_data(inst);\n\tenable_hw_rw_function(inst);\n\tstore_dec_table(inst);\n\n\tbs_va = (unsigned char *)bs->va;\n\n\t \n\tdata = (*(bs_va + 9) << 24) | (*(bs_va + 8) << 16) |\n\t       (*(bs_va + 7) << 8) | *(bs_va + 6);\n\terr = vpu_dec_start(vpu, &data, 1);\n\tif (err) {\n\t\tadd_fb_to_free_list(inst, fb);\n\t\tif (dec->wait_key_frame) {\n\t\t\tmtk_vdec_debug(inst->ctx, \"wait key frame !\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tgoto error;\n\t}\n\n\tif (dec->resolution_changed) {\n\t\tmtk_vdec_debug(inst->ctx, \"- resolution_changed -\");\n\t\t*res_chg = true;\n\t\tadd_fb_to_free_list(inst, fb);\n\t\treturn 0;\n\t}\n\n\t \n\tmtk_vcodec_wait_for_done_ctx(inst->ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t     WAIT_INTR_TIMEOUT_MS, 0);\n\n\tif (inst->vsi->load_data)\n\t\tload_dec_table(inst);\n\n\tvp8_dec_finish(inst);\n\tread_hw_segmentation_data(inst);\n\n\terr = vpu_dec_end(vpu);\n\tif (err)\n\t\tgoto error;\n\n\tmtk_vdec_debug(inst->ctx, \"\\n - FRAME[%d] - show=%d\\n\", inst->frm_cnt, dec->show_frame);\n\tinst->frm_cnt++;\n\t*res_chg = false;\n\treturn 0;\n\nerror:\n\tmtk_vdec_err(inst->ctx, \"\\n - FRAME[%d] - err=%d\\n\", inst->frm_cnt, err);\n\treturn err;\n}\n\nstatic void get_disp_fb(struct vdec_vp8_inst *inst, struct vdec_fb **out_fb)\n{\n\tstruct vdec_fb_node *node;\n\tstruct vdec_fb *fb;\n\n\tnode = list_first_entry_or_null(&inst->fb_disp_list,\n\t\t\t\t\tstruct vdec_fb_node, list);\n\tif (node) {\n\t\tlist_move_tail(&node->list, &inst->available_fb_node_list);\n\t\tfb = (struct vdec_fb *)node->fb;\n\t\tfb->status |= FB_ST_DISPLAY;\n\t\tmtk_vdec_debug(inst->ctx, \"[FB] get disp fb %p st=%d\", node->fb, fb->status);\n\t} else {\n\t\tfb = NULL;\n\t\tmtk_vdec_debug(inst->ctx, \"[FB] there is no disp fb\");\n\t}\n\n\t*out_fb = fb;\n}\n\nstatic void get_free_fb(struct vdec_vp8_inst *inst, struct vdec_fb **out_fb)\n{\n\tstruct vdec_fb_node *node;\n\tstruct vdec_fb *fb;\n\n\tnode = list_first_entry_or_null(&inst->fb_free_list,\n\t\t\t\t\tstruct vdec_fb_node, list);\n\tif (node) {\n\t\tlist_move_tail(&node->list, &inst->available_fb_node_list);\n\t\tfb = (struct vdec_fb *)node->fb;\n\t\tfb->status |= FB_ST_FREE;\n\t\tmtk_vdec_debug(inst->ctx, \"[FB] get free fb %p st=%d\", node->fb, fb->status);\n\t} else {\n\t\tfb = NULL;\n\t\tmtk_vdec_debug(inst->ctx, \"[FB] there is no free fb\");\n\t}\n\n\t*out_fb = fb;\n}\n\nstatic void get_crop_info(struct vdec_vp8_inst *inst, struct v4l2_rect *cr)\n{\n\tcr->left = 0;\n\tcr->top = 0;\n\tcr->width = inst->vsi->pic.pic_w;\n\tcr->height = inst->vsi->pic.pic_h;\n\tmtk_vdec_debug(inst->ctx, \"get crop info l=%d, t=%d, w=%d, h=%d\",\n\t\t       cr->left, cr->top, cr->width, cr->height);\n}\n\nstatic int vdec_vp8_get_param(void *h_vdec, enum vdec_get_param_type type,\n\t\t\t      void *out)\n{\n\tstruct vdec_vp8_inst *inst = (struct vdec_vp8_inst *)h_vdec;\n\n\tswitch (type) {\n\tcase GET_PARAM_DISP_FRAME_BUFFER:\n\t\tget_disp_fb(inst, out);\n\t\tbreak;\n\n\tcase GET_PARAM_FREE_FRAME_BUFFER:\n\t\tget_free_fb(inst, out);\n\t\tbreak;\n\n\tcase GET_PARAM_PIC_INFO:\n\t\tget_pic_info(inst, out);\n\t\tbreak;\n\n\tcase GET_PARAM_CROP_INFO:\n\t\tget_crop_info(inst, out);\n\t\tbreak;\n\n\tcase GET_PARAM_DPB_SIZE:\n\t\t*((unsigned int *)out) = VP8_DPB_SIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tmtk_vdec_err(inst->ctx, \"invalid get parameter type=%d\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void vdec_vp8_deinit(void *h_vdec)\n{\n\tstruct vdec_vp8_inst *inst = (struct vdec_vp8_inst *)h_vdec;\n\n\tvpu_dec_deinit(&inst->vpu);\n\tfree_working_buf(inst);\n\tkfree(inst);\n}\n\nconst struct vdec_common_if vdec_vp8_if = {\n\t.init\t\t= vdec_vp8_init,\n\t.decode\t\t= vdec_vp8_decode,\n\t.get_param\t= vdec_vp8_get_param,\n\t.deinit\t\t= vdec_vp8_deinit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}