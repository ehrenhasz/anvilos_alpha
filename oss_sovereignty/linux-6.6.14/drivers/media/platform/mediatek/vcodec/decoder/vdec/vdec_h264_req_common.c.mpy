{
  "module_name": "vdec_h264_req_common.c",
  "hash_id": "ad4f93bf9719fff90e4bff091778e29671807c39aa024fa1aa3c60e970c34a80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_h264_req_common.c",
  "human_readable_source": "\n \n\n#include \"vdec_h264_req_common.h\"\n\n \n#define GET_MTK_VDEC_FLAG(cond, flag) \\\n\t{ dst_param->cond = ((src_param->flags & flag) ? (1) : (0)); }\n#define GET_MTK_VDEC_PARAM(param) \\\n\t{ dst_param->param = src_param->param; }\n\nvoid mtk_vdec_h264_get_ref_list(u8 *ref_list,\n\t\t\t\tconst struct v4l2_h264_reference *v4l2_ref_list,\n\t\t\t\tint num_valid)\n{\n\tu32 i;\n\n\t \n\n\tfor (i = 0; i < num_valid; i++)\n\t\tref_list[i] = v4l2_ref_list[i].index;\n\n\t \n\tmemset(&ref_list[num_valid], 0x20, 32 - num_valid);\n}\n\nvoid *mtk_vdec_h264_get_ctrl_ptr(struct mtk_vcodec_dec_ctx *ctx, int id)\n{\n\tstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(&ctx->ctrl_hdl, id);\n\n\tif (!ctrl)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn ctrl->p_cur.p;\n}\n\nvoid mtk_vdec_h264_fill_dpb_info(struct mtk_vcodec_dec_ctx *ctx,\n\t\t\t\t struct slice_api_h264_decode_param *decode_params,\n\t\t\t\t struct mtk_h264_dpb_info *h264_dpb_info)\n{\n\tconst struct slice_h264_dpb_entry *dpb;\n\tstruct vb2_queue *vq;\n\tstruct vb2_buffer *vb;\n\tstruct vb2_v4l2_buffer *vb2_v4l2;\n\tint index;\n\n\tvq = v4l2_m2m_get_vq(ctx->m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\n\tfor (index = 0; index < V4L2_H264_NUM_DPB_ENTRIES; index++) {\n\t\tdpb = &decode_params->dpb[index];\n\t\tif (!(dpb->flags & V4L2_H264_DPB_ENTRY_FLAG_ACTIVE)) {\n\t\t\th264_dpb_info[index].reference_flag = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvb = vb2_find_buffer(vq, dpb->reference_ts);\n\t\tif (!vb) {\n\t\t\tdev_err(&ctx->dev->plat_dev->dev,\n\t\t\t\t\"Reference invalid: dpb_index(%d) reference_ts(%lld)\",\n\t\t\t\tindex, dpb->reference_ts);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!(dpb->flags & V4L2_H264_DPB_ENTRY_FLAG_LONG_TERM))\n\t\t\th264_dpb_info[index].reference_flag = 1;\n\t\telse\n\t\t\th264_dpb_info[index].reference_flag = 2;\n\n\t\tvb2_v4l2 = container_of(vb, struct vb2_v4l2_buffer, vb2_buf);\n\t\th264_dpb_info[index].field = vb2_v4l2->field;\n\n\t\th264_dpb_info[index].y_dma_addr =\n\t\t\tvb2_dma_contig_plane_dma_addr(vb, 0);\n\t\tif (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 2)\n\t\t\th264_dpb_info[index].c_dma_addr =\n\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, 1);\n\t\telse\n\t\t\th264_dpb_info[index].c_dma_addr =\n\t\t\t\th264_dpb_info[index].y_dma_addr +\n\t\t\t\tctx->picinfo.fb_sz[0];\n\t}\n}\n\nvoid mtk_vdec_h264_copy_sps_params(struct mtk_h264_sps_param *dst_param,\n\t\t\t\t   const struct v4l2_ctrl_h264_sps *src_param)\n{\n\tGET_MTK_VDEC_PARAM(chroma_format_idc);\n\tGET_MTK_VDEC_PARAM(bit_depth_luma_minus8);\n\tGET_MTK_VDEC_PARAM(bit_depth_chroma_minus8);\n\tGET_MTK_VDEC_PARAM(log2_max_frame_num_minus4);\n\tGET_MTK_VDEC_PARAM(pic_order_cnt_type);\n\tGET_MTK_VDEC_PARAM(log2_max_pic_order_cnt_lsb_minus4);\n\tGET_MTK_VDEC_PARAM(max_num_ref_frames);\n\tGET_MTK_VDEC_PARAM(pic_width_in_mbs_minus1);\n\tGET_MTK_VDEC_PARAM(pic_height_in_map_units_minus1);\n\n\tGET_MTK_VDEC_FLAG(separate_colour_plane_flag,\n\t\t\t  V4L2_H264_SPS_FLAG_SEPARATE_COLOUR_PLANE);\n\tGET_MTK_VDEC_FLAG(qpprime_y_zero_transform_bypass_flag,\n\t\t\t  V4L2_H264_SPS_FLAG_QPPRIME_Y_ZERO_TRANSFORM_BYPASS);\n\tGET_MTK_VDEC_FLAG(delta_pic_order_always_zero_flag,\n\t\t\t  V4L2_H264_SPS_FLAG_DELTA_PIC_ORDER_ALWAYS_ZERO);\n\tGET_MTK_VDEC_FLAG(frame_mbs_only_flag,\n\t\t\t  V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY);\n\tGET_MTK_VDEC_FLAG(mb_adaptive_frame_field_flag,\n\t\t\t  V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD);\n\tGET_MTK_VDEC_FLAG(direct_8x8_inference_flag,\n\t\t\t  V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE);\n}\n\nvoid mtk_vdec_h264_copy_pps_params(struct mtk_h264_pps_param *dst_param,\n\t\t\t\t   const struct v4l2_ctrl_h264_pps *src_param)\n{\n\tGET_MTK_VDEC_PARAM(num_ref_idx_l0_default_active_minus1);\n\tGET_MTK_VDEC_PARAM(num_ref_idx_l1_default_active_minus1);\n\tGET_MTK_VDEC_PARAM(weighted_bipred_idc);\n\tGET_MTK_VDEC_PARAM(pic_init_qp_minus26);\n\tGET_MTK_VDEC_PARAM(chroma_qp_index_offset);\n\tGET_MTK_VDEC_PARAM(second_chroma_qp_index_offset);\n\n\tGET_MTK_VDEC_FLAG(entropy_coding_mode_flag,\n\t\t\t  V4L2_H264_PPS_FLAG_ENTROPY_CODING_MODE);\n\tGET_MTK_VDEC_FLAG(pic_order_present_flag,\n\t\t\t  V4L2_H264_PPS_FLAG_BOTTOM_FIELD_PIC_ORDER_IN_FRAME_PRESENT);\n\tGET_MTK_VDEC_FLAG(weighted_pred_flag,\n\t\t\t  V4L2_H264_PPS_FLAG_WEIGHTED_PRED);\n\tGET_MTK_VDEC_FLAG(deblocking_filter_control_present_flag,\n\t\t\t  V4L2_H264_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT);\n\tGET_MTK_VDEC_FLAG(constrained_intra_pred_flag,\n\t\t\t  V4L2_H264_PPS_FLAG_CONSTRAINED_INTRA_PRED);\n\tGET_MTK_VDEC_FLAG(redundant_pic_cnt_present_flag,\n\t\t\t  V4L2_H264_PPS_FLAG_REDUNDANT_PIC_CNT_PRESENT);\n\tGET_MTK_VDEC_FLAG(transform_8x8_mode_flag,\n\t\t\t  V4L2_H264_PPS_FLAG_TRANSFORM_8X8_MODE);\n\tGET_MTK_VDEC_FLAG(scaling_matrix_present_flag,\n\t\t\t  V4L2_H264_PPS_FLAG_SCALING_MATRIX_PRESENT);\n}\n\nvoid mtk_vdec_h264_copy_slice_hd_params(struct mtk_h264_slice_hd_param *dst_param,\n\t\t\t\t\tconst struct v4l2_ctrl_h264_slice_params *src_param,\n\t\t\t\t\tconst struct v4l2_ctrl_h264_decode_params *dec_param)\n{\n\tint temp;\n\n\tGET_MTK_VDEC_PARAM(first_mb_in_slice);\n\tGET_MTK_VDEC_PARAM(slice_type);\n\tGET_MTK_VDEC_PARAM(cabac_init_idc);\n\tGET_MTK_VDEC_PARAM(slice_qp_delta);\n\tGET_MTK_VDEC_PARAM(disable_deblocking_filter_idc);\n\tGET_MTK_VDEC_PARAM(slice_alpha_c0_offset_div2);\n\tGET_MTK_VDEC_PARAM(slice_beta_offset_div2);\n\tGET_MTK_VDEC_PARAM(num_ref_idx_l0_active_minus1);\n\tGET_MTK_VDEC_PARAM(num_ref_idx_l1_active_minus1);\n\n\tdst_param->frame_num = dec_param->frame_num;\n\tdst_param->pic_order_cnt_lsb = dec_param->pic_order_cnt_lsb;\n\n\tdst_param->delta_pic_order_cnt_bottom =\n\t\tdec_param->delta_pic_order_cnt_bottom;\n\tdst_param->delta_pic_order_cnt0 =\n\t\tdec_param->delta_pic_order_cnt0;\n\tdst_param->delta_pic_order_cnt1 =\n\t\tdec_param->delta_pic_order_cnt1;\n\n\ttemp = dec_param->flags & V4L2_H264_DECODE_PARAM_FLAG_FIELD_PIC;\n\tdst_param->field_pic_flag = temp ? 1 : 0;\n\n\ttemp = dec_param->flags & V4L2_H264_DECODE_PARAM_FLAG_BOTTOM_FIELD;\n\tdst_param->bottom_field_flag = temp ? 1 : 0;\n\n\tGET_MTK_VDEC_FLAG(direct_spatial_mv_pred_flag,\n\t\t\t  V4L2_H264_SLICE_FLAG_DIRECT_SPATIAL_MV_PRED);\n}\n\nvoid mtk_vdec_h264_copy_scaling_matrix(struct slice_api_h264_scaling_matrix *dst_matrix,\n\t\t\t\t       const struct v4l2_ctrl_h264_scaling_matrix *src_matrix)\n{\n\tmemcpy(dst_matrix->scaling_list_4x4, src_matrix->scaling_list_4x4,\n\t       sizeof(dst_matrix->scaling_list_4x4));\n\n\tmemcpy(dst_matrix->scaling_list_8x8, src_matrix->scaling_list_8x8,\n\t       sizeof(dst_matrix->scaling_list_8x8));\n}\n\nvoid\nmtk_vdec_h264_copy_decode_params(struct slice_api_h264_decode_param *dst_params,\n\t\t\t\t const struct v4l2_ctrl_h264_decode_params *src_params,\n\t\t\t\t const struct v4l2_h264_dpb_entry dpb[V4L2_H264_NUM_DPB_ENTRIES])\n{\n\tstruct slice_h264_dpb_entry *dst_entry;\n\tconst struct v4l2_h264_dpb_entry *src_entry;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dst_params->dpb); i++) {\n\t\tdst_entry = &dst_params->dpb[i];\n\t\tsrc_entry = &dpb[i];\n\n\t\tdst_entry->reference_ts = src_entry->reference_ts;\n\t\tdst_entry->frame_num = src_entry->frame_num;\n\t\tdst_entry->pic_num = src_entry->pic_num;\n\t\tdst_entry->top_field_order_cnt = src_entry->top_field_order_cnt;\n\t\tdst_entry->bottom_field_order_cnt =\n\t\t\tsrc_entry->bottom_field_order_cnt;\n\t\tdst_entry->flags = src_entry->flags;\n\t}\n\n\t \n\tdst_params->num_slices = 0;\n\tdst_params->nal_ref_idc = src_params->nal_ref_idc;\n\tdst_params->top_field_order_cnt = src_params->top_field_order_cnt;\n\tdst_params->bottom_field_order_cnt = src_params->bottom_field_order_cnt;\n\tdst_params->flags = src_params->flags;\n}\n\nstatic bool mtk_vdec_h264_dpb_entry_match(const struct v4l2_h264_dpb_entry *a,\n\t\t\t\t\t  const struct v4l2_h264_dpb_entry *b)\n{\n\treturn a->top_field_order_cnt == b->top_field_order_cnt &&\n\t       a->bottom_field_order_cnt == b->bottom_field_order_cnt;\n}\n\n \nvoid mtk_vdec_h264_update_dpb(const struct v4l2_ctrl_h264_decode_params *dec_param,\n\t\t\t      struct v4l2_h264_dpb_entry *dpb)\n{\n\tDECLARE_BITMAP(new, ARRAY_SIZE(dec_param->dpb)) = { 0, };\n\tDECLARE_BITMAP(in_use, ARRAY_SIZE(dec_param->dpb)) = { 0, };\n\tDECLARE_BITMAP(used, ARRAY_SIZE(dec_param->dpb)) = { 0, };\n\tunsigned int i, j;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dec_param->dpb); i++) {\n\t\tif (dpb[i].flags & V4L2_H264_DPB_ENTRY_FLAG_ACTIVE)\n\t\t\tset_bit(i, in_use);\n\t\tdpb[i].flags &= ~V4L2_H264_DPB_ENTRY_FLAG_ACTIVE;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dec_param->dpb); i++) {\n\t\tconst struct v4l2_h264_dpb_entry *ndpb = &dec_param->dpb[i];\n\n\t\tif (!(ndpb->flags & V4L2_H264_DPB_ENTRY_FLAG_ACTIVE))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor_each_set_bit(j, in_use, ARRAY_SIZE(dec_param->dpb)) {\n\t\t\tstruct v4l2_h264_dpb_entry *cdpb;\n\n\t\t\tcdpb = &dpb[j];\n\t\t\tif (!mtk_vdec_h264_dpb_entry_match(cdpb, ndpb))\n\t\t\t\tcontinue;\n\n\t\t\t*cdpb = *ndpb;\n\t\t\tset_bit(j, used);\n\t\t\t \n\t\t\tclear_bit(j, in_use);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j == ARRAY_SIZE(dec_param->dpb))\n\t\t\tset_bit(i, new);\n\t}\n\n\t \n\tfor_each_set_bit(i, new, ARRAY_SIZE(dec_param->dpb)) {\n\t\tconst struct v4l2_h264_dpb_entry *ndpb = &dec_param->dpb[i];\n\t\tstruct v4l2_h264_dpb_entry *cdpb;\n\n\t\t \n\t\tj = find_first_zero_bit(used, ARRAY_SIZE(dec_param->dpb));\n\t\tif (WARN_ON(j >= ARRAY_SIZE(dec_param->dpb)))\n\t\t\treturn;\n\n\t\tcdpb = &dpb[j];\n\t\t*cdpb = *ndpb;\n\t\tset_bit(j, used);\n\t}\n}\n\nunsigned int mtk_vdec_h264_get_mv_buf_size(unsigned int width, unsigned int height)\n{\n\tint unit_size = (width / MB_UNIT_LEN) * (height / MB_UNIT_LEN) + 8;\n\n\treturn HW_MB_STORE_SZ * unit_size;\n}\n\nint mtk_vdec_h264_find_start_code(unsigned char *data, unsigned int data_sz)\n{\n\tif (data_sz > 3 && data[0] == 0 && data[1] == 0 && data[2] == 1)\n\t\treturn 3;\n\n\tif (data_sz > 4 && data[0] == 0 && data[1] == 0 && data[2] == 0 &&\n\t    data[3] == 1)\n\t\treturn 4;\n\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}