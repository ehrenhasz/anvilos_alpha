{
  "module_name": "vdec_h264_if.c",
  "hash_id": "3fed0c011cfe95858095adfae21f7341d447907f138e2b37a11de1b4e4f31232",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_h264_if.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"../vdec_drv_if.h\"\n#include \"../mtk_vcodec_dec.h\"\n#include \"../../common/mtk_vcodec_intr.h\"\n#include \"../vdec_vpu_if.h\"\n#include \"../vdec_drv_base.h\"\n\n#define NAL_NON_IDR_SLICE\t\t\t0x01\n#define NAL_IDR_SLICE\t\t\t\t0x05\n#define NAL_H264_PPS\t\t\t\t0x08\n#define NAL_TYPE(value)\t\t\t\t((value) & 0x1F)\n\n#define BUF_PREDICTION_SZ\t\t\t(32 * 1024)\n\n#define MB_UNIT_LEN\t\t\t\t16\n\n \n#define HW_MB_STORE_SZ\t\t\t\t64\n\n#define H264_MAX_FB_NUM\t\t\t\t17\n#define HDR_PARSING_BUF_SZ\t\t\t1024\n\n#define DEC_ERR_RET(ret)\t\t\t((ret) >> 16)\n#define H264_ERR_NOT_VALID\t\t\t3\n\n \nstruct h264_fb {\n\tuint64_t vdec_fb_va;\n\tuint64_t y_fb_dma;\n\tuint64_t c_fb_dma;\n\tint32_t poc;\n\tuint32_t reserved;\n};\n\n \nstruct h264_ring_fb_list {\n\tstruct h264_fb fb_list[H264_MAX_FB_NUM];\n\tunsigned int read_idx;\n\tunsigned int write_idx;\n\tunsigned int count;\n\tunsigned int reserved;\n};\n\n \nstruct vdec_h264_dec_info {\n\tuint32_t dpb_sz;\n\tuint32_t resolution_changed;\n\tuint32_t realloc_mv_buf;\n\tuint32_t reserved;\n\tuint64_t bs_dma;\n\tuint64_t y_fb_dma;\n\tuint64_t c_fb_dma;\n\tuint64_t vdec_fb_va;\n};\n\n \nstruct vdec_h264_vsi {\n\tunsigned char hdr_buf[HDR_PARSING_BUF_SZ];\n\tuint64_t pred_buf_dma;\n\tuint64_t mv_buf_dma[H264_MAX_FB_NUM];\n\tstruct h264_ring_fb_list list_free;\n\tstruct h264_ring_fb_list list_disp;\n\tstruct vdec_h264_dec_info dec;\n\tstruct vdec_pic_info pic;\n\tstruct v4l2_rect crop;\n};\n\n \nstruct vdec_h264_inst {\n\tunsigned int num_nalu;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct mtk_vcodec_mem pred_buf;\n\tstruct mtk_vcodec_mem mv_buf[H264_MAX_FB_NUM];\n\tstruct vdec_vpu_inst vpu;\n\tstruct vdec_h264_vsi *vsi;\n};\n\nstatic unsigned int get_mv_buf_size(unsigned int width, unsigned int height)\n{\n\treturn HW_MB_STORE_SZ * (width/MB_UNIT_LEN) * (height/MB_UNIT_LEN);\n}\n\nstatic int allocate_predication_buf(struct vdec_h264_inst *inst)\n{\n\tint err = 0;\n\n\tinst->pred_buf.size = BUF_PREDICTION_SZ;\n\terr = mtk_vcodec_mem_alloc(inst->ctx, &inst->pred_buf);\n\tif (err) {\n\t\tmtk_vdec_err(inst->ctx, \"failed to allocate ppl buf\");\n\t\treturn err;\n\t}\n\n\tinst->vsi->pred_buf_dma = inst->pred_buf.dma_addr;\n\treturn 0;\n}\n\nstatic void free_predication_buf(struct vdec_h264_inst *inst)\n{\n\tstruct mtk_vcodec_mem *mem = NULL;\n\n\tinst->vsi->pred_buf_dma = 0;\n\tmem = &inst->pred_buf;\n\tif (mem->va)\n\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n}\n\nstatic int alloc_mv_buf(struct vdec_h264_inst *inst, struct vdec_pic_info *pic)\n{\n\tint i;\n\tint err;\n\tstruct mtk_vcodec_mem *mem = NULL;\n\tunsigned int buf_sz = get_mv_buf_size(pic->buf_w, pic->buf_h);\n\n\tfor (i = 0; i < H264_MAX_FB_NUM; i++) {\n\t\tmem = &inst->mv_buf[i];\n\t\tif (mem->va)\n\t\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\t\tmem->size = buf_sz;\n\t\terr = mtk_vcodec_mem_alloc(inst->ctx, mem);\n\t\tif (err) {\n\t\t\tmtk_vdec_err(inst->ctx, \"failed to allocate mv buf\");\n\t\t\treturn err;\n\t\t}\n\t\tinst->vsi->mv_buf_dma[i] = mem->dma_addr;\n\t}\n\n\treturn 0;\n}\n\nstatic void free_mv_buf(struct vdec_h264_inst *inst)\n{\n\tint i;\n\tstruct mtk_vcodec_mem *mem = NULL;\n\n\tfor (i = 0; i < H264_MAX_FB_NUM; i++) {\n\t\tinst->vsi->mv_buf_dma[i] = 0;\n\t\tmem = &inst->mv_buf[i];\n\t\tif (mem->va)\n\t\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\t}\n}\n\nstatic int check_list_validity(struct vdec_h264_inst *inst, bool disp_list)\n{\n\tstruct h264_ring_fb_list *list;\n\n\tlist = disp_list ? &inst->vsi->list_disp : &inst->vsi->list_free;\n\n\tif (list->count > H264_MAX_FB_NUM ||\n\t    list->read_idx >= H264_MAX_FB_NUM ||\n\t    list->write_idx >= H264_MAX_FB_NUM) {\n\t\tmtk_vdec_err(inst->ctx, \"%s list err: cnt=%d r_idx=%d w_idx=%d\",\n\t\t\t     disp_list ? \"disp\" : \"free\", list->count,\n\t\t\t     list->read_idx, list->write_idx);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void put_fb_to_free(struct vdec_h264_inst *inst, struct vdec_fb *fb)\n{\n\tstruct h264_ring_fb_list *list;\n\n\tif (fb) {\n\t\tif (check_list_validity(inst, false))\n\t\t\treturn;\n\n\t\tlist = &inst->vsi->list_free;\n\t\tif (list->count == H264_MAX_FB_NUM) {\n\t\t\tmtk_vdec_err(inst->ctx, \"[FB] put fb free_list full\");\n\t\t\treturn;\n\t\t}\n\n\t\tmtk_vdec_debug(inst->ctx, \"[FB] put fb into free_list @(%p, %llx)\",\n\t\t\t       fb->base_y.va, (u64)fb->base_y.dma_addr);\n\n\t\tlist->fb_list[list->write_idx].vdec_fb_va = (u64)(uintptr_t)fb;\n\t\tlist->write_idx = (list->write_idx == H264_MAX_FB_NUM - 1) ?\n\t\t\t\t  0 : list->write_idx + 1;\n\t\tlist->count++;\n\t}\n}\n\nstatic void get_pic_info(struct vdec_h264_inst *inst,\n\t\t\t struct vdec_pic_info *pic)\n{\n\t*pic = inst->vsi->pic;\n\tmtk_vdec_debug(inst->ctx, \"pic(%d, %d), buf(%d, %d)\",\n\t\t       pic->pic_w, pic->pic_h, pic->buf_w, pic->buf_h);\n\tmtk_vdec_debug(inst->ctx, \"fb size: Y(%d), C(%d)\", pic->fb_sz[0], pic->fb_sz[1]);\n}\n\nstatic void get_crop_info(struct vdec_h264_inst *inst, struct v4l2_rect *cr)\n{\n\tcr->left = inst->vsi->crop.left;\n\tcr->top = inst->vsi->crop.top;\n\tcr->width = inst->vsi->crop.width;\n\tcr->height = inst->vsi->crop.height;\n\n\tmtk_vdec_debug(inst->ctx, \"l=%d, t=%d, w=%d, h=%d\", cr->left, cr->top,\n\t\t       cr->width, cr->height);\n}\n\nstatic void get_dpb_size(struct vdec_h264_inst *inst, unsigned int *dpb_sz)\n{\n\t*dpb_sz = inst->vsi->dec.dpb_sz;\n\tmtk_vdec_debug(inst->ctx, \"sz=%d\", *dpb_sz);\n}\n\nstatic int vdec_h264_init(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct vdec_h264_inst *inst = NULL;\n\tint err;\n\n\tinst = kzalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tinst->ctx = ctx;\n\n\tinst->vpu.id = IPI_VDEC_H264;\n\tinst->vpu.ctx = ctx;\n\n\terr = vpu_dec_init(&inst->vpu);\n\tif (err) {\n\t\tmtk_vdec_err(ctx, \"vdec_h264 init err=%d\", err);\n\t\tgoto error_free_inst;\n\t}\n\n\tinst->vsi = (struct vdec_h264_vsi *)inst->vpu.vsi;\n\terr = allocate_predication_buf(inst);\n\tif (err)\n\t\tgoto error_deinit;\n\n\tmtk_vdec_debug(ctx, \"H264 Instance >> %p\", inst);\n\n\tctx->drv_handle = inst;\n\treturn 0;\n\nerror_deinit:\n\tvpu_dec_deinit(&inst->vpu);\n\nerror_free_inst:\n\tkfree(inst);\n\treturn err;\n}\n\nstatic void vdec_h264_deinit(void *h_vdec)\n{\n\tstruct vdec_h264_inst *inst = (struct vdec_h264_inst *)h_vdec;\n\n\tvpu_dec_deinit(&inst->vpu);\n\tfree_predication_buf(inst);\n\tfree_mv_buf(inst);\n\n\tkfree(inst);\n}\n\nstatic int find_start_code(unsigned char *data, unsigned int data_sz)\n{\n\tif (data_sz > 3 && data[0] == 0 && data[1] == 0 && data[2] == 1)\n\t\treturn 3;\n\n\tif (data_sz > 4 && data[0] == 0 && data[1] == 0 && data[2] == 0 &&\n\t    data[3] == 1)\n\t\treturn 4;\n\n\treturn -1;\n}\n\nstatic int vdec_h264_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t    struct vdec_fb *fb, bool *res_chg)\n{\n\tstruct vdec_h264_inst *inst = (struct vdec_h264_inst *)h_vdec;\n\tstruct vdec_vpu_inst *vpu = &inst->vpu;\n\tint nal_start_idx = 0;\n\tint err = 0;\n\tunsigned int nal_start;\n\tunsigned int nal_type;\n\tunsigned char *buf;\n\tunsigned int buf_sz;\n\tunsigned int data[2];\n\tuint64_t vdec_fb_va = (u64)(uintptr_t)fb;\n\tuint64_t y_fb_dma = fb ? (u64)fb->base_y.dma_addr : 0;\n\tuint64_t c_fb_dma = fb ? (u64)fb->base_c.dma_addr : 0;\n\n\tmtk_vdec_debug(inst->ctx, \"+ [%d] FB y_dma=%llx c_dma=%llx va=%p\",\n\t\t       ++inst->num_nalu, y_fb_dma, c_fb_dma, fb);\n\n\t \n\tif (bs == NULL)\n\t\treturn vpu_dec_reset(vpu);\n\n\tbuf = (unsigned char *)bs->va;\n\tbuf_sz = bs->size;\n\tnal_start_idx = find_start_code(buf, buf_sz);\n\tif (nal_start_idx < 0) {\n\t\tmtk_vdec_err(inst->ctx, \"invalid nal start code\");\n\t\terr = -EIO;\n\t\tgoto err_free_fb_out;\n\t}\n\n\tnal_start = buf[nal_start_idx];\n\tnal_type = NAL_TYPE(buf[nal_start_idx]);\n\tmtk_vdec_debug(inst->ctx, \"\\n + NALU[%d] type %d +\\n\", inst->num_nalu,\n\t\t       nal_type);\n\n\tif (nal_type == NAL_H264_PPS) {\n\t\tbuf_sz -= nal_start_idx;\n\t\tif (buf_sz > HDR_PARSING_BUF_SZ) {\n\t\t\terr = -EILSEQ;\n\t\t\tgoto err_free_fb_out;\n\t\t}\n\t\tmemcpy(inst->vsi->hdr_buf, buf + nal_start_idx, buf_sz);\n\t}\n\n\tinst->vsi->dec.bs_dma = (uint64_t)bs->dma_addr;\n\tinst->vsi->dec.y_fb_dma = y_fb_dma;\n\tinst->vsi->dec.c_fb_dma = c_fb_dma;\n\tinst->vsi->dec.vdec_fb_va = vdec_fb_va;\n\n\tdata[0] = buf_sz;\n\tdata[1] = nal_start;\n\terr = vpu_dec_start(vpu, data, 2);\n\tif (err) {\n\t\tif (err > 0 && (DEC_ERR_RET(err) == H264_ERR_NOT_VALID)) {\n\t\t\tmtk_vdec_err(inst->ctx, \"- error bitstream - err = %d -\", err);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_free_fb_out;\n\t}\n\n\t*res_chg = inst->vsi->dec.resolution_changed;\n\tif (*res_chg) {\n\t\tstruct vdec_pic_info pic;\n\n\t\tmtk_vdec_debug(inst->ctx, \"- resolution changed -\");\n\t\tget_pic_info(inst, &pic);\n\n\t\tif (inst->vsi->dec.realloc_mv_buf) {\n\t\t\terr = alloc_mv_buf(inst, &pic);\n\t\t\tif (err)\n\t\t\t\tgoto err_free_fb_out;\n\t\t}\n\t}\n\n\tif (nal_type == NAL_NON_IDR_SLICE || nal_type == NAL_IDR_SLICE) {\n\t\t \n\t\terr = mtk_vcodec_wait_for_done_ctx(inst->ctx,\n\t\t\t\t\t\t   MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t\t   WAIT_INTR_TIMEOUT_MS, 0);\n\t\tif (err)\n\t\t\tgoto err_free_fb_out;\n\n\t\tvpu_dec_end(vpu);\n\t}\n\n\tmtk_vdec_debug(inst->ctx, \"\\n - NALU[%d] type=%d -\\n\", inst->num_nalu, nal_type);\n\treturn 0;\n\nerr_free_fb_out:\n\tput_fb_to_free(inst, fb);\n\tmtk_vdec_err(inst->ctx, \"\\n - NALU[%d] err=%d -\\n\", inst->num_nalu, err);\n\treturn err;\n}\n\nstatic void vdec_h264_get_fb(struct vdec_h264_inst *inst,\n\t\t\t     struct h264_ring_fb_list *list,\n\t\t\t     bool disp_list, struct vdec_fb **out_fb)\n{\n\tstruct vdec_fb *fb;\n\n\tif (check_list_validity(inst, disp_list))\n\t\treturn;\n\n\tif (list->count == 0) {\n\t\tmtk_vdec_debug(inst->ctx, \"[FB] there is no %s fb\", disp_list ? \"disp\" : \"free\");\n\t\t*out_fb = NULL;\n\t\treturn;\n\t}\n\n\tfb = (struct vdec_fb *)\n\t\t(uintptr_t)list->fb_list[list->read_idx].vdec_fb_va;\n\tfb->status |= (disp_list ? FB_ST_DISPLAY : FB_ST_FREE);\n\n\t*out_fb = fb;\n\tmtk_vdec_debug(inst->ctx, \"[FB] get %s fb st=%d poc=%d %llx\",\n\t\t       disp_list ? \"disp\" : \"free\",\n\t\t       fb->status, list->fb_list[list->read_idx].poc,\n\t\t       list->fb_list[list->read_idx].vdec_fb_va);\n\n\tlist->read_idx = (list->read_idx == H264_MAX_FB_NUM - 1) ?\n\t\t\t 0 : list->read_idx + 1;\n\tlist->count--;\n}\n\nstatic int vdec_h264_get_param(void *h_vdec, enum vdec_get_param_type type,\n\t\t\t       void *out)\n{\n\tstruct vdec_h264_inst *inst = (struct vdec_h264_inst *)h_vdec;\n\n\tswitch (type) {\n\tcase GET_PARAM_DISP_FRAME_BUFFER:\n\t\tvdec_h264_get_fb(inst, &inst->vsi->list_disp, true, out);\n\t\tbreak;\n\n\tcase GET_PARAM_FREE_FRAME_BUFFER:\n\t\tvdec_h264_get_fb(inst, &inst->vsi->list_free, false, out);\n\t\tbreak;\n\n\tcase GET_PARAM_PIC_INFO:\n\t\tget_pic_info(inst, out);\n\t\tbreak;\n\n\tcase GET_PARAM_DPB_SIZE:\n\t\tget_dpb_size(inst, out);\n\t\tbreak;\n\n\tcase GET_PARAM_CROP_INFO:\n\t\tget_crop_info(inst, out);\n\t\tbreak;\n\n\tdefault:\n\t\tmtk_vdec_err(inst->ctx, \"invalid get parameter type=%d\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nconst struct vdec_common_if vdec_h264_if = {\n\t.init\t\t= vdec_h264_init,\n\t.decode\t\t= vdec_h264_decode,\n\t.get_param\t= vdec_h264_get_param,\n\t.deinit\t\t= vdec_h264_deinit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}