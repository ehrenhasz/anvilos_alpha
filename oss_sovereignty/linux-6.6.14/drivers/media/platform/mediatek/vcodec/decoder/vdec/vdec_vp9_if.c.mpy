{
  "module_name": "vdec_vp9_if.c",
  "hash_id": "250f0a7645539aacfc3e9bb9fa49075f6f6d9b288ce9a7e4a436ee3badb4ca77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_vp9_if.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/delay.h>\n#include <linux/time.h>\n\n#include \"../../common/mtk_vcodec_intr.h\"\n#include \"../vdec_drv_base.h\"\n#include \"../vdec_vpu_if.h\"\n\n#define VP9_SUPER_FRAME_BS_SZ 64\n#define MAX_VP9_DPB_SIZE\t9\n\n#define REFS_PER_FRAME 3\n#define MAX_NUM_REF_FRAMES 8\n#define VP9_MAX_FRM_BUF_NUM 9\n#define VP9_MAX_FRM_BUF_NODE_NUM (VP9_MAX_FRM_BUF_NUM * 2)\n#define VP9_SEG_ID_SZ 0x12000\n\n \nstruct vp9_dram_buf {\n\tunsigned long va;\n\tunsigned long pa;\n\tunsigned int sz;\n\tunsigned int padding;\n};\n\n \nstruct vp9_fb_info {\n\tstruct vdec_fb *fb;\n\tunsigned int reserved[32];\n};\n\n \nstruct vp9_ref_cnt_buf {\n\tstruct vp9_fb_info buf;\n\tunsigned int ref_cnt;\n};\n\n \nstruct vp9_ref_buf {\n\tstruct vp9_fb_info *buf;\n\tunsigned int idx;\n\tunsigned int reserved[6];\n};\n\n \nstruct vp9_sf_ref_fb {\n\tstruct vdec_fb fb;\n\tint used;\n\tint padding;\n};\n\n \nstruct vdec_vp9_vsi {\n\tunsigned char sf_bs_buf[VP9_SUPER_FRAME_BS_SZ];\n\tstruct vp9_sf_ref_fb sf_ref_fb[VP9_MAX_FRM_BUF_NUM-1];\n\tint sf_next_ref_fb_idx;\n\tunsigned int sf_frm_cnt;\n\tunsigned int sf_frm_offset[VP9_MAX_FRM_BUF_NUM-1];\n\tunsigned int sf_frm_sz[VP9_MAX_FRM_BUF_NUM-1];\n\tunsigned int sf_frm_idx;\n\tunsigned int sf_init;\n\tstruct vdec_fb fb;\n\tstruct mtk_vcodec_mem bs;\n\tstruct vdec_fb cur_fb;\n\tunsigned int pic_w;\n\tunsigned int pic_h;\n\tunsigned int buf_w;\n\tunsigned int buf_h;\n\tunsigned int buf_sz_y_bs;\n\tunsigned int buf_sz_c_bs;\n\tunsigned int buf_len_sz_y;\n\tunsigned int buf_len_sz_c;\n\tunsigned int profile;\n\tunsigned int show_frame;\n\tunsigned int show_existing_frame;\n\tunsigned int frm_to_show_idx;\n\tunsigned int refresh_frm_flags;\n\tunsigned int resolution_changed;\n\n\tstruct vp9_ref_cnt_buf frm_bufs[VP9_MAX_FRM_BUF_NUM];\n\tint ref_frm_map[MAX_NUM_REF_FRAMES];\n\tunsigned int new_fb_idx;\n\tunsigned int frm_num;\n\tstruct vp9_dram_buf mv_buf;\n\n\tstruct vp9_ref_buf frm_refs[REFS_PER_FRAME];\n\tstruct vp9_dram_buf seg_id_buf;\n\n};\n\n \nstruct vdec_vp9_inst {\n\tstruct mtk_vcodec_mem mv_buf;\n\tstruct mtk_vcodec_mem seg_id_buf;\n\n\tstruct vdec_fb_node dec_fb[VP9_MAX_FRM_BUF_NODE_NUM];\n\tstruct list_head available_fb_node_list;\n\tstruct list_head fb_use_list;\n\tstruct list_head fb_free_list;\n\tstruct list_head fb_disp_list;\n\tstruct vdec_fb *cur_fb;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct vdec_vpu_inst vpu;\n\tstruct vdec_vp9_vsi *vsi;\n\tunsigned int total_frm_cnt;\n\tstruct mtk_vcodec_mem mem;\n};\n\nstatic bool vp9_is_sf_ref_fb(struct vdec_vp9_inst *inst, struct vdec_fb *fb)\n{\n\tint i;\n\tstruct vdec_vp9_vsi *vsi = inst->vsi;\n\n\tfor (i = 0; i < ARRAY_SIZE(vsi->sf_ref_fb); i++) {\n\t\tif (fb == &vsi->sf_ref_fb[i].fb)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic struct vdec_fb *vp9_rm_from_fb_use_list(struct vdec_vp9_inst\n\t\t\t\t\t*inst, void *addr)\n{\n\tstruct vdec_fb *fb = NULL;\n\tstruct vdec_fb_node *node;\n\n\tlist_for_each_entry(node, &inst->fb_use_list, list) {\n\t\tfb = (struct vdec_fb *)node->fb;\n\t\tif (fb->base_y.va == addr) {\n\t\t\tlist_move_tail(&node->list,\n\t\t\t\t       &inst->available_fb_node_list);\n\t\t\treturn fb;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void vp9_add_to_fb_free_list(struct vdec_vp9_inst *inst,\n\t\t\t     struct vdec_fb *fb)\n{\n\tstruct vdec_fb_node *node;\n\n\tif (fb) {\n\t\tnode = list_first_entry_or_null(&inst->available_fb_node_list,\n\t\t\t\t\tstruct vdec_fb_node, list);\n\n\t\tif (node) {\n\t\t\tnode->fb = fb;\n\t\t\tlist_move_tail(&node->list, &inst->fb_free_list);\n\t\t}\n\t} else {\n\t\tmtk_vdec_debug(inst->ctx, \"No free fb node\");\n\t}\n}\n\nstatic void vp9_free_sf_ref_fb(struct vdec_fb *fb)\n{\n\tstruct vp9_sf_ref_fb *sf_ref_fb =\n\t\tcontainer_of(fb, struct vp9_sf_ref_fb, fb);\n\n\tsf_ref_fb->used = 0;\n}\n\nstatic void vp9_ref_cnt_fb(struct vdec_vp9_inst *inst, int *idx,\n\t\t\t   int new_idx)\n{\n\tstruct vdec_vp9_vsi *vsi = inst->vsi;\n\tint ref_idx = *idx;\n\n\tif (ref_idx >= 0 && vsi->frm_bufs[ref_idx].ref_cnt > 0) {\n\t\tvsi->frm_bufs[ref_idx].ref_cnt--;\n\n\t\tif (vsi->frm_bufs[ref_idx].ref_cnt == 0) {\n\t\t\tif (!vp9_is_sf_ref_fb(inst,\n\t\t\t\t\t      vsi->frm_bufs[ref_idx].buf.fb)) {\n\t\t\t\tstruct vdec_fb *fb;\n\n\t\t\t\tfb = vp9_rm_from_fb_use_list(inst,\n\t\t\t\t     vsi->frm_bufs[ref_idx].buf.fb->base_y.va);\n\t\t\t\tvp9_add_to_fb_free_list(inst, fb);\n\t\t\t} else\n\t\t\t\tvp9_free_sf_ref_fb(\n\t\t\t\t\tvsi->frm_bufs[ref_idx].buf.fb);\n\t\t}\n\t}\n\n\t*idx = new_idx;\n\tvsi->frm_bufs[new_idx].ref_cnt++;\n}\n\nstatic void vp9_free_all_sf_ref_fb(struct vdec_vp9_inst *inst)\n{\n\tint i;\n\tstruct vdec_vp9_vsi *vsi = inst->vsi;\n\n\tfor (i = 0; i < ARRAY_SIZE(vsi->sf_ref_fb); i++) {\n\t\tif (vsi->sf_ref_fb[i].fb.base_y.va) {\n\t\t\tmtk_vcodec_mem_free(inst->ctx,\n\t\t\t\t&vsi->sf_ref_fb[i].fb.base_y);\n\t\t\tmtk_vcodec_mem_free(inst->ctx,\n\t\t\t\t&vsi->sf_ref_fb[i].fb.base_c);\n\t\t\tvsi->sf_ref_fb[i].used = 0;\n\t\t}\n\t}\n}\n\n \nstatic int vp9_get_sf_ref_fb(struct vdec_vp9_inst *inst)\n{\n\tint idx;\n\tstruct mtk_vcodec_mem *mem_basy_y;\n\tstruct mtk_vcodec_mem *mem_basy_c;\n\tstruct vdec_vp9_vsi *vsi = inst->vsi;\n\n\tfor (idx = 0;\n\t\tidx < ARRAY_SIZE(vsi->sf_ref_fb);\n\t\tidx++) {\n\t\tif (vsi->sf_ref_fb[idx].fb.base_y.va &&\n\t\t    vsi->sf_ref_fb[idx].used == 0) {\n\t\t\treturn idx;\n\t\t}\n\t}\n\n\tfor (idx = 0;\n\t\tidx < ARRAY_SIZE(vsi->sf_ref_fb);\n\t\tidx++) {\n\t\tif (vsi->sf_ref_fb[idx].fb.base_y.va == NULL)\n\t\t\tbreak;\n\t}\n\n\tif (idx == ARRAY_SIZE(vsi->sf_ref_fb)) {\n\t\tmtk_vdec_err(inst->ctx, \"List Full\");\n\t\treturn -1;\n\t}\n\n\tmem_basy_y = &vsi->sf_ref_fb[idx].fb.base_y;\n\tmem_basy_y->size = vsi->buf_sz_y_bs +\n\t\tvsi->buf_len_sz_y;\n\n\tif (mtk_vcodec_mem_alloc(inst->ctx, mem_basy_y)) {\n\t\tmtk_vdec_err(inst->ctx, \"Cannot allocate sf_ref_buf y_buf\");\n\t\treturn -1;\n\t}\n\n\tmem_basy_c = &vsi->sf_ref_fb[idx].fb.base_c;\n\tmem_basy_c->size = vsi->buf_sz_c_bs +\n\t\tvsi->buf_len_sz_c;\n\n\tif (mtk_vcodec_mem_alloc(inst->ctx, mem_basy_c)) {\n\t\tmtk_vdec_err(inst->ctx, \"Cannot allocate sf_ref_fb c_buf\");\n\t\treturn -1;\n\t}\n\tvsi->sf_ref_fb[idx].used = 0;\n\n\treturn idx;\n}\n\nstatic bool vp9_alloc_work_buf(struct vdec_vp9_inst *inst)\n{\n\tstruct vdec_vp9_vsi *vsi = inst->vsi;\n\tint result;\n\tstruct mtk_vcodec_mem *mem;\n\n\tunsigned int max_pic_w;\n\tunsigned int max_pic_h;\n\n\n\tif (!(inst->ctx->dev->dec_capability &\n\t\tVCODEC_CAPABILITY_4K_DISABLED)) {\n\t\tmax_pic_w = VCODEC_DEC_4K_CODED_WIDTH;\n\t\tmax_pic_h = VCODEC_DEC_4K_CODED_HEIGHT;\n\t} else {\n\t\tmax_pic_w = MTK_VDEC_MAX_W;\n\t\tmax_pic_h = MTK_VDEC_MAX_H;\n\t}\n\n\tif ((vsi->pic_w > max_pic_w) ||\n\t\t(vsi->pic_h > max_pic_h)) {\n\t\tmtk_vdec_err(inst->ctx, \"Invalid w/h %d/%d\", vsi->pic_w, vsi->pic_h);\n\t\treturn false;\n\t}\n\n\tmtk_vdec_debug(inst->ctx, \"BUF CHG(%d): w/h/sb_w/sb_h=%d/%d/%d/%d\",\n\t\t       vsi->resolution_changed, vsi->pic_w,\n\t\t       vsi->pic_h, vsi->buf_w, vsi->buf_h);\n\n\tmem = &inst->mv_buf;\n\tif (mem->va)\n\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\n\tmem->size = ((vsi->buf_w / 64) *\n\t\t    (vsi->buf_h / 64) + 2) * 36 * 16;\n\tresult = mtk_vcodec_mem_alloc(inst->ctx, mem);\n\tif (result) {\n\t\tmem->size = 0;\n\t\tmtk_vdec_err(inst->ctx, \"Cannot allocate mv_buf\");\n\t\treturn false;\n\t}\n\t \n\tvsi->mv_buf.va = (unsigned long)mem->va;\n\tvsi->mv_buf.pa = (unsigned long)mem->dma_addr;\n\tvsi->mv_buf.sz = (unsigned int)mem->size;\n\n\n\tmem = &inst->seg_id_buf;\n\tif (mem->va)\n\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\n\tmem->size = VP9_SEG_ID_SZ;\n\tresult = mtk_vcodec_mem_alloc(inst->ctx, mem);\n\tif (result) {\n\t\tmem->size = 0;\n\t\tmtk_vdec_err(inst->ctx, \"Cannot allocate seg_id_buf\");\n\t\treturn false;\n\t}\n\t \n\tvsi->seg_id_buf.va = (unsigned long)mem->va;\n\tvsi->seg_id_buf.pa = (unsigned long)mem->dma_addr;\n\tvsi->seg_id_buf.sz = (unsigned int)mem->size;\n\n\n\tvp9_free_all_sf_ref_fb(inst);\n\tvsi->sf_next_ref_fb_idx = vp9_get_sf_ref_fb(inst);\n\n\treturn true;\n}\n\nstatic bool vp9_add_to_fb_disp_list(struct vdec_vp9_inst *inst,\n\t\t\t     struct vdec_fb *fb)\n{\n\tstruct vdec_fb_node *node;\n\n\tif (!fb) {\n\t\tmtk_vdec_err(inst->ctx, \"fb == NULL\");\n\t\treturn false;\n\t}\n\n\tnode = list_first_entry_or_null(&inst->available_fb_node_list,\n\t\t\t\t\tstruct vdec_fb_node, list);\n\tif (node) {\n\t\tnode->fb = fb;\n\t\tlist_move_tail(&node->list, &inst->fb_disp_list);\n\t} else {\n\t\tmtk_vdec_err(inst->ctx, \"No available fb node\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic void vp9_swap_frm_bufs(struct vdec_vp9_inst *inst)\n{\n\tstruct vdec_vp9_vsi *vsi = inst->vsi;\n\tstruct vp9_fb_info *frm_to_show;\n\tint ref_index = 0, mask;\n\n\tfor (mask = vsi->refresh_frm_flags; mask; mask >>= 1) {\n\t\tif (mask & 1)\n\t\t\tvp9_ref_cnt_fb(inst, &vsi->ref_frm_map[ref_index],\n\t\t\t\t       vsi->new_fb_idx);\n\t\t++ref_index;\n\t}\n\n\tfrm_to_show = &vsi->frm_bufs[vsi->new_fb_idx].buf;\n\tvsi->frm_bufs[vsi->new_fb_idx].ref_cnt--;\n\n\tif (frm_to_show->fb != inst->cur_fb) {\n\t\t \n\t\tif ((frm_to_show->fb != NULL) &&\n\t\t\t(inst->cur_fb->base_y.size >=\n\t\t\tfrm_to_show->fb->base_y.size) &&\n\t\t\t(inst->cur_fb->base_c.size >=\n\t\t\tfrm_to_show->fb->base_c.size)) {\n\t\t\tmemcpy((void *)inst->cur_fb->base_y.va,\n\t\t\t\t(void *)frm_to_show->fb->base_y.va,\n\t\t\t\tfrm_to_show->fb->base_y.size);\n\t\t\tmemcpy((void *)inst->cur_fb->base_c.va,\n\t\t\t\t(void *)frm_to_show->fb->base_c.va,\n\t\t\t\tfrm_to_show->fb->base_c.size);\n\t\t} else {\n\t\t\t \n\t\t\tif (frm_to_show->fb != NULL)\n\t\t\t\tmtk_vdec_err(inst->ctx,\n\t\t\t\t\t     \"base_y.size=%zu, frm_to_show: base_y.size=%zu\",\n\t\t\t\t\t     inst->cur_fb->base_y.size,\n\t\t\t\t\t     frm_to_show->fb->base_y.size);\n\t\t}\n\t\tif (!vp9_is_sf_ref_fb(inst, inst->cur_fb)) {\n\t\t\tif (vsi->show_frame & BIT(0))\n\t\t\t\tvp9_add_to_fb_disp_list(inst, inst->cur_fb);\n\t\t}\n\t} else {\n\t\tif (!vp9_is_sf_ref_fb(inst, inst->cur_fb)) {\n\t\t\tif (vsi->show_frame & BIT(0))\n\t\t\t\tvp9_add_to_fb_disp_list(inst, frm_to_show->fb);\n\t\t}\n\t}\n\n\t \n\tif (vsi->frm_bufs[vsi->new_fb_idx].ref_cnt == 0) {\n\t\tif (!vp9_is_sf_ref_fb(\n\t\t\tinst, vsi->frm_bufs[vsi->new_fb_idx].buf.fb)) {\n\t\t\tstruct vdec_fb *fb;\n\n\t\t\tfb = vp9_rm_from_fb_use_list(inst,\n\t\t\tvsi->frm_bufs[vsi->new_fb_idx].buf.fb->base_y.va);\n\n\t\t\tvp9_add_to_fb_free_list(inst, fb);\n\t\t} else {\n\t\t\tvp9_free_sf_ref_fb(\n\t\t\t\tvsi->frm_bufs[vsi->new_fb_idx].buf.fb);\n\t\t}\n\t}\n\n\t \n\tif (vsi->sf_frm_cnt > 0 && vsi->sf_frm_idx != vsi->sf_frm_cnt - 1)\n\t\tvsi->sf_next_ref_fb_idx = vp9_get_sf_ref_fb(inst);\n}\n\nstatic bool vp9_wait_dec_end(struct vdec_vp9_inst *inst)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = inst->ctx;\n\n\tmtk_vcodec_wait_for_done_ctx(inst->ctx,\n\t\t\tMTK_INST_IRQ_RECEIVED,\n\t\t\tWAIT_INTR_TIMEOUT_MS, 0);\n\n\tif (ctx->irq_status & MTK_VDEC_IRQ_STATUS_DEC_SUCCESS)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic struct vdec_vp9_inst *vp9_alloc_inst(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tint result;\n\tstruct mtk_vcodec_mem mem;\n\tstruct vdec_vp9_inst *inst;\n\n\tmemset(&mem, 0, sizeof(mem));\n\tmem.size = sizeof(struct vdec_vp9_inst);\n\tresult = mtk_vcodec_mem_alloc(ctx, &mem);\n\tif (result)\n\t\treturn NULL;\n\n\tinst = mem.va;\n\tinst->mem = mem;\n\n\treturn inst;\n}\n\nstatic void vp9_free_inst(struct vdec_vp9_inst *inst)\n{\n\tstruct mtk_vcodec_mem mem;\n\n\tmem = inst->mem;\n\tif (mem.va)\n\t\tmtk_vcodec_mem_free(inst->ctx, &mem);\n}\n\nstatic bool vp9_decode_end_proc(struct vdec_vp9_inst *inst)\n{\n\tstruct vdec_vp9_vsi *vsi = inst->vsi;\n\tbool ret = false;\n\n\tif (!vsi->show_existing_frame) {\n\t\tret = vp9_wait_dec_end(inst);\n\t\tif (!ret) {\n\t\t\tmtk_vdec_err(inst->ctx, \"Decode failed, Decode Timeout @[%d]\",\n\t\t\t\t     vsi->frm_num);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (vpu_dec_end(&inst->vpu)) {\n\t\t\tmtk_vdec_err(inst->ctx, \"vp9_dec_vpu_end failed\");\n\t\t\treturn false;\n\t\t}\n\t\tmtk_vdec_debug(inst->ctx, \"Decode Ok @%d (%d/%d)\", vsi->frm_num,\n\t\t\t       vsi->pic_w, vsi->pic_h);\n\t} else {\n\t\tmtk_vdec_debug(inst->ctx, \"Decode Ok @%d (show_existing_frame)\", vsi->frm_num);\n\t}\n\n\tvp9_swap_frm_bufs(inst);\n\tvsi->frm_num++;\n\treturn true;\n}\n\nstatic bool vp9_is_last_sub_frm(struct vdec_vp9_inst *inst)\n{\n\tstruct vdec_vp9_vsi *vsi = inst->vsi;\n\n\tif (vsi->sf_frm_cnt <= 0 || vsi->sf_frm_idx == vsi->sf_frm_cnt)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct vdec_fb *vp9_rm_from_fb_disp_list(struct vdec_vp9_inst *inst)\n{\n\tstruct vdec_fb_node *node;\n\tstruct vdec_fb *fb = NULL;\n\n\tnode = list_first_entry_or_null(&inst->fb_disp_list,\n\t\t\t\t\tstruct vdec_fb_node, list);\n\tif (node) {\n\t\tfb = (struct vdec_fb *)node->fb;\n\t\tfb->status |= FB_ST_DISPLAY;\n\t\tlist_move_tail(&node->list, &inst->available_fb_node_list);\n\t\tmtk_vdec_debug(inst->ctx, \"[FB] get disp fb %p st=%d\", node->fb, fb->status);\n\t} else\n\t\tmtk_vdec_debug(inst->ctx, \"[FB] there is no disp fb\");\n\n\treturn fb;\n}\n\nstatic bool vp9_add_to_fb_use_list(struct vdec_vp9_inst *inst,\n\t\t\t    struct vdec_fb *fb)\n{\n\tstruct vdec_fb_node *node;\n\n\tif (!fb) {\n\t\tmtk_vdec_debug(inst->ctx, \"fb == NULL\");\n\t\treturn false;\n\t}\n\n\tnode = list_first_entry_or_null(&inst->available_fb_node_list,\n\t\t\t\t\tstruct vdec_fb_node, list);\n\tif (node) {\n\t\tnode->fb = fb;\n\t\tlist_move_tail(&node->list, &inst->fb_use_list);\n\t} else {\n\t\tmtk_vdec_err(inst->ctx, \"No free fb node\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void vp9_reset(struct vdec_vp9_inst *inst)\n{\n\tstruct vdec_fb_node *node, *tmp;\n\n\tlist_for_each_entry_safe(node, tmp, &inst->fb_use_list, list)\n\t\tlist_move_tail(&node->list, &inst->fb_free_list);\n\n\tvp9_free_all_sf_ref_fb(inst);\n\tinst->vsi->sf_next_ref_fb_idx = vp9_get_sf_ref_fb(inst);\n\n\tif (vpu_dec_reset(&inst->vpu))\n\t\tmtk_vdec_err(inst->ctx, \"vp9_dec_vpu_reset failed\");\n\n\t \n\tinst->vsi->mv_buf.va = (unsigned long)inst->mv_buf.va;\n\tinst->vsi->mv_buf.pa = (unsigned long)inst->mv_buf.dma_addr;\n\tinst->vsi->mv_buf.sz = (unsigned long)inst->mv_buf.size;\n\n\t \n\tinst->vsi->seg_id_buf.va = (unsigned long)inst->seg_id_buf.va;\n\tinst->vsi->seg_id_buf.pa = (unsigned long)inst->seg_id_buf.dma_addr;\n\tinst->vsi->seg_id_buf.sz = (unsigned long)inst->seg_id_buf.size;\n\n}\n\nstatic void init_all_fb_lists(struct vdec_vp9_inst *inst)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&inst->available_fb_node_list);\n\tINIT_LIST_HEAD(&inst->fb_use_list);\n\tINIT_LIST_HEAD(&inst->fb_free_list);\n\tINIT_LIST_HEAD(&inst->fb_disp_list);\n\n\tfor (i = 0; i < ARRAY_SIZE(inst->dec_fb); i++) {\n\t\tINIT_LIST_HEAD(&inst->dec_fb[i].list);\n\t\tinst->dec_fb[i].fb = NULL;\n\t\tlist_add_tail(&inst->dec_fb[i].list,\n\t\t\t      &inst->available_fb_node_list);\n\t}\n}\n\nstatic void get_pic_info(struct vdec_vp9_inst *inst, struct vdec_pic_info *pic)\n{\n\tpic->fb_sz[0] = inst->vsi->buf_sz_y_bs + inst->vsi->buf_len_sz_y;\n\tpic->fb_sz[1] = inst->vsi->buf_sz_c_bs + inst->vsi->buf_len_sz_c;\n\n\tpic->pic_w = inst->vsi->pic_w;\n\tpic->pic_h = inst->vsi->pic_h;\n\tpic->buf_w = inst->vsi->buf_w;\n\tpic->buf_h = inst->vsi->buf_h;\n\n\tmtk_vdec_debug(inst->ctx, \"pic(%d, %d), buf(%d, %d)\",\n\t\t       pic->pic_w, pic->pic_h, pic->buf_w, pic->buf_h);\n\tmtk_vdec_debug(inst->ctx, \"fb size: Y(%d), C(%d)\", pic->fb_sz[0], pic->fb_sz[1]);\n}\n\nstatic void get_disp_fb(struct vdec_vp9_inst *inst, struct vdec_fb **out_fb)\n{\n\n\t*out_fb = vp9_rm_from_fb_disp_list(inst);\n\tif (*out_fb)\n\t\t(*out_fb)->status |= FB_ST_DISPLAY;\n}\n\nstatic void get_free_fb(struct vdec_vp9_inst *inst, struct vdec_fb **out_fb)\n{\n\tstruct vdec_fb_node *node;\n\tstruct vdec_fb *fb = NULL;\n\n\tnode = list_first_entry_or_null(&inst->fb_free_list,\n\t\t\t\t\tstruct vdec_fb_node, list);\n\tif (node) {\n\t\tlist_move_tail(&node->list, &inst->available_fb_node_list);\n\t\tfb = (struct vdec_fb *)node->fb;\n\t\tfb->status |= FB_ST_FREE;\n\t\tmtk_vdec_debug(inst->ctx, \"[FB] get free fb %p st=%d\", node->fb, fb->status);\n\t} else {\n\t\tmtk_vdec_debug(inst->ctx, \"[FB] there is no free fb\");\n\t}\n\n\t*out_fb = fb;\n}\n\nstatic int validate_vsi_array_indexes(struct vdec_vp9_inst *inst,\n\t\tstruct vdec_vp9_vsi *vsi) {\n\tif (vsi->sf_frm_idx >= VP9_MAX_FRM_BUF_NUM - 1) {\n\t\tmtk_vdec_err(inst->ctx, \"Invalid vsi->sf_frm_idx=%u.\", vsi->sf_frm_idx);\n\t\treturn -EIO;\n\t}\n\tif (vsi->frm_to_show_idx >= VP9_MAX_FRM_BUF_NUM) {\n\t\tmtk_vdec_err(inst->ctx, \"Invalid vsi->frm_to_show_idx=%u.\", vsi->frm_to_show_idx);\n\t\treturn -EIO;\n\t}\n\tif (vsi->new_fb_idx >= VP9_MAX_FRM_BUF_NUM) {\n\t\tmtk_vdec_err(inst->ctx, \"Invalid vsi->new_fb_idx=%u.\", vsi->new_fb_idx);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void vdec_vp9_deinit(void *h_vdec)\n{\n\tstruct vdec_vp9_inst *inst = (struct vdec_vp9_inst *)h_vdec;\n\tstruct mtk_vcodec_mem *mem;\n\tint ret = 0;\n\n\tret = vpu_dec_deinit(&inst->vpu);\n\tif (ret)\n\t\tmtk_vdec_err(inst->ctx, \"vpu_dec_deinit failed\");\n\n\tmem = &inst->mv_buf;\n\tif (mem->va)\n\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\n\tmem = &inst->seg_id_buf;\n\tif (mem->va)\n\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\n\tvp9_free_all_sf_ref_fb(inst);\n\tvp9_free_inst(inst);\n}\n\nstatic int vdec_vp9_init(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct vdec_vp9_inst *inst;\n\n\tinst = vp9_alloc_inst(ctx);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tinst->total_frm_cnt = 0;\n\tinst->ctx = ctx;\n\n\tinst->vpu.id = IPI_VDEC_VP9;\n\tinst->vpu.ctx = ctx;\n\n\tif (vpu_dec_init(&inst->vpu)) {\n\t\tmtk_vdec_err(inst->ctx, \"vp9_dec_vpu_init failed\");\n\t\tgoto err_deinit_inst;\n\t}\n\n\tinst->vsi = (struct vdec_vp9_vsi *)inst->vpu.vsi;\n\n\tinst->vsi->show_frame |= BIT(3);\n\n\tinit_all_fb_lists(inst);\n\n\tctx->drv_handle = inst;\n\treturn 0;\n\nerr_deinit_inst:\n\tvp9_free_inst(inst);\n\n\treturn -EINVAL;\n}\n\nstatic int vdec_vp9_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t   struct vdec_fb *fb, bool *res_chg)\n{\n\tint ret = 0;\n\tstruct vdec_vp9_inst *inst = (struct vdec_vp9_inst *)h_vdec;\n\tstruct vdec_vp9_vsi *vsi = inst->vsi;\n\tu32 data[3];\n\tint i;\n\n\t*res_chg = false;\n\n\tif ((bs == NULL) && (fb == NULL)) {\n\t\tmtk_vdec_debug(inst->ctx, \"[EOS]\");\n\t\tvp9_reset(inst);\n\t\treturn ret;\n\t}\n\n\tif (bs == NULL) {\n\t\tmtk_vdec_err(inst->ctx, \"bs == NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_vdec_debug(inst->ctx, \"Input BS Size = %zu\", bs->size);\n\n\twhile (1) {\n\t\tstruct vdec_fb *cur_fb = NULL;\n\n\t\tdata[0] = *((unsigned int *)bs->va);\n\t\tdata[1] = *((unsigned int *)(bs->va + 4));\n\t\tdata[2] = *((unsigned int *)(bs->va + 8));\n\n\t\tvsi->bs = *bs;\n\n\t\tif (fb)\n\t\t\tvsi->fb = *fb;\n\n\t\tif (!vsi->sf_init) {\n\t\t\tunsigned int sf_bs_sz;\n\t\t\tunsigned int sf_bs_off;\n\t\t\tunsigned char *sf_bs_src;\n\t\t\tunsigned char *sf_bs_dst;\n\n\t\t\tsf_bs_sz = bs->size > VP9_SUPER_FRAME_BS_SZ ?\n\t\t\t\t\tVP9_SUPER_FRAME_BS_SZ : bs->size;\n\t\t\tsf_bs_off = VP9_SUPER_FRAME_BS_SZ - sf_bs_sz;\n\t\t\tsf_bs_src = bs->va + bs->size - sf_bs_sz;\n\t\t\tsf_bs_dst = vsi->sf_bs_buf + sf_bs_off;\n\t\t\tmemcpy(sf_bs_dst, sf_bs_src, sf_bs_sz);\n\t\t} else {\n\t\t\tif ((vsi->sf_frm_cnt > 0) &&\n\t\t\t\t(vsi->sf_frm_idx < vsi->sf_frm_cnt)) {\n\t\t\t\tunsigned int idx = vsi->sf_frm_idx;\n\n\t\t\t\tmemcpy((void *)bs->va,\n\t\t\t\t\t(void *)(bs->va +\n\t\t\t\t\tvsi->sf_frm_offset[idx]),\n\t\t\t\t\tvsi->sf_frm_sz[idx]);\n\t\t\t}\n\t\t}\n\n\t\tif (!(vsi->show_frame & BIT(4)))\n\t\t\tmemset(inst->seg_id_buf.va, 0, inst->seg_id_buf.size);\n\n\t\tret = vpu_dec_start(&inst->vpu, data, 3);\n\t\tif (ret) {\n\t\t\tmtk_vdec_err(inst->ctx, \"vpu_dec_start failed\");\n\t\t\tgoto DECODE_ERROR;\n\t\t}\n\n\t\tif (vsi->show_frame & BIT(1)) {\n\t\t\tmemset(inst->seg_id_buf.va, 0, inst->seg_id_buf.size);\n\n\t\t\tif (vsi->show_frame & BIT(2)) {\n\t\t\t\tret = vpu_dec_start(&inst->vpu, NULL, 0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmtk_vdec_err(inst->ctx, \"vpu trig decoder failed\");\n\t\t\t\t\tgoto DECODE_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tret = validate_vsi_array_indexes(inst, vsi);\n\t\tif (ret) {\n\t\t\tmtk_vdec_err(inst->ctx, \"Invalid values from VPU.\");\n\t\t\tgoto DECODE_ERROR;\n\t\t}\n\n\t\tif (vsi->resolution_changed) {\n\t\t\tif (!vp9_alloc_work_buf(inst)) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto DECODE_ERROR;\n\t\t\t}\n\t\t}\n\n\t\tif (vsi->sf_frm_cnt > 0) {\n\t\t\tcur_fb = &vsi->sf_ref_fb[vsi->sf_next_ref_fb_idx].fb;\n\n\t\t\tif (vsi->sf_frm_idx < vsi->sf_frm_cnt)\n\t\t\t\tinst->cur_fb = cur_fb;\n\t\t\telse\n\t\t\t\tinst->cur_fb = fb;\n\t\t} else {\n\t\t\tinst->cur_fb = fb;\n\t\t}\n\n\t\tvsi->frm_bufs[vsi->new_fb_idx].buf.fb = inst->cur_fb;\n\t\tif (!vp9_is_sf_ref_fb(inst, inst->cur_fb))\n\t\t\tvp9_add_to_fb_use_list(inst, inst->cur_fb);\n\n\t\tmtk_vdec_debug(inst->ctx, \"[#pic %d]\", vsi->frm_num);\n\n\t\tif (vsi->show_existing_frame)\n\t\t\tmtk_vdec_debug(inst->ctx,\n\t\t\t\t       \"drv->new_fb_idx=%d, drv->frm_to_show_idx=%d\",\n\t\t\t\t       vsi->new_fb_idx, vsi->frm_to_show_idx);\n\n\t\tif (vsi->show_existing_frame && (vsi->frm_to_show_idx <\n\t\t\t\t\tVP9_MAX_FRM_BUF_NUM)) {\n\t\t\tmtk_vdec_debug(inst->ctx,\n\t\t\t\t       \"Skip Decode drv->new_fb_idx=%d, drv->frm_to_show_idx=%d\",\n\t\t\t\t       vsi->new_fb_idx, vsi->frm_to_show_idx);\n\n\t\t\tvp9_ref_cnt_fb(inst, &vsi->new_fb_idx,\n\t\t\t\t\tvsi->frm_to_show_idx);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(vsi->frm_refs); i++) {\n\t\t\tunsigned int idx = vsi->frm_refs[i].idx;\n\n\t\t\tvsi->frm_refs[i].buf = &vsi->frm_bufs[idx].buf;\n\t\t}\n\n\t\tif (vsi->resolution_changed) {\n\t\t\t*res_chg = true;\n\t\t\tmtk_vdec_debug(inst->ctx, \"VDEC_ST_RESOLUTION_CHANGED\");\n\n\t\t\tret = 0;\n\t\t\tgoto DECODE_ERROR;\n\t\t}\n\n\t\tif (!vp9_decode_end_proc(inst)) {\n\t\t\tmtk_vdec_err(inst->ctx, \"vp9_decode_end_proc\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto DECODE_ERROR;\n\t\t}\n\n\t\tif (vp9_is_last_sub_frm(inst))\n\t\t\tbreak;\n\n\t}\n\tinst->total_frm_cnt++;\n\nDECODE_ERROR:\n\tif (ret < 0)\n\t\tvp9_add_to_fb_free_list(inst, fb);\n\n\treturn ret;\n}\n\nstatic void get_crop_info(struct vdec_vp9_inst *inst, struct v4l2_rect *cr)\n{\n\tcr->left = 0;\n\tcr->top = 0;\n\tcr->width = inst->vsi->pic_w;\n\tcr->height = inst->vsi->pic_h;\n\tmtk_vdec_debug(inst->ctx, \"get crop info l=%d, t=%d, w=%d, h=%d\\n\",\n\t\t       cr->left, cr->top, cr->width, cr->height);\n}\n\nstatic int vdec_vp9_get_param(void *h_vdec, enum vdec_get_param_type type,\n\t\t\t      void *out)\n{\n\tstruct vdec_vp9_inst *inst = (struct vdec_vp9_inst *)h_vdec;\n\tint ret = 0;\n\n\tswitch (type) {\n\tcase GET_PARAM_DISP_FRAME_BUFFER:\n\t\tget_disp_fb(inst, out);\n\t\tbreak;\n\tcase GET_PARAM_FREE_FRAME_BUFFER:\n\t\tget_free_fb(inst, out);\n\t\tbreak;\n\tcase GET_PARAM_PIC_INFO:\n\t\tget_pic_info(inst, out);\n\t\tbreak;\n\tcase GET_PARAM_DPB_SIZE:\n\t\t*((unsigned int *)out) = MAX_VP9_DPB_SIZE;\n\t\tbreak;\n\tcase GET_PARAM_CROP_INFO:\n\t\tget_crop_info(inst, out);\n\t\tbreak;\n\tdefault:\n\t\tmtk_vdec_err(inst->ctx, \"not supported param type %d\", type);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nconst struct vdec_common_if vdec_vp9_if = {\n\t.init\t\t= vdec_vp9_init,\n\t.decode\t\t= vdec_vp9_decode,\n\t.get_param\t= vdec_vp9_get_param,\n\t.deinit\t\t= vdec_vp9_deinit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}