{
  "module_name": "vdec_vp9_req_lat_if.c",
  "hash_id": "0700856a289f71fc6cf44e58c20ee2f7b19d1c6a6315c625062d30503135efa6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_vp9_req_lat_if.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/v4l2-vp9.h>\n\n#include \"../mtk_vcodec_dec.h\"\n#include \"../../common/mtk_vcodec_intr.h\"\n#include \"../vdec_drv_base.h\"\n#include \"../vdec_drv_if.h\"\n#include \"../vdec_vpu_if.h\"\n\n \n#define VP9_RESET_FRAME_CONTEXT_NONE0 0\n#define VP9_RESET_FRAME_CONTEXT_NONE1 1\n#define VP9_RESET_FRAME_CONTEXT_SPEC 2\n#define VP9_RESET_FRAME_CONTEXT_ALL 3\n\n#define VP9_TILE_BUF_SIZE 4096\n#define VP9_PROB_BUF_SIZE 2560\n#define VP9_COUNTS_BUF_SIZE 16384\n\n#define HDR_FLAG(x) (!!((hdr)->flags & V4L2_VP9_FRAME_FLAG_##x))\n#define LF_FLAG(x) (!!((lf)->flags & V4L2_VP9_LOOP_FILTER_FLAG_##x))\n#define SEG_FLAG(x) (!!((seg)->flags & V4L2_VP9_SEGMENTATION_FLAG_##x))\n#define VP9_BAND_6(band) ((band) == 0 ? 3 : 6)\n\n \nstruct vdec_vp9_slice_frame_ctx {\n\tstruct {\n\t\tu8 probs[6][3];\n\t\tu8 padding[2];\n\t} coef_probs[4][2][2][6];\n\n\tu8 y_mode_prob[4][16];\n\tu8 switch_interp_prob[4][16];\n\tu8 seg[32];   \n\tu8 comp_inter_prob[16];\n\tu8 comp_ref_prob[16];\n\tu8 single_ref_prob[5][2];\n\tu8 single_ref_prob_padding[6];\n\n\tu8 joint[3];\n\tu8 joint_padding[13];\n\tstruct {\n\t\tu8 sign;\n\t\tu8 classes[10];\n\t\tu8 padding[5];\n\t} sign_classes[2];\n\tstruct {\n\t\tu8 class0[1];\n\t\tu8 bits[10];\n\t\tu8 padding[5];\n\t} class0_bits[2];\n\tstruct {\n\t\tu8 class0_fp[2][3];\n\t\tu8 fp[3];\n\t\tu8 class0_hp;\n\t\tu8 hp;\n\t\tu8 padding[5];\n\t} class0_fp_hp[2];\n\n\tu8 uv_mode_prob[10][16];\n\tu8 uv_mode_prob_padding[2][16];\n\n\tu8 partition_prob[16][4];\n\n\tu8 inter_mode_probs[7][4];\n\tu8 skip_probs[4];\n\n\tu8 tx_p8x8[2][4];\n\tu8 tx_p16x16[2][4];\n\tu8 tx_p32x32[2][4];\n\tu8 intra_inter_prob[8];\n};\n\n \nstruct vdec_vp9_slice_frame_counts {\n\tunion {\n\t\tstruct {\n\t\t\tu32 band_0[3];\n\t\t\tu32 padding0[1];\n\t\t\tu32 band_1_5[5][6];\n\t\t\tu32 padding1[2];\n\t\t} eob_branch[4][2][2];\n\t\tu32 eob_branch_space[256 * 4];\n\t};\n\n\tstruct {\n\t\tu32 band_0[3][4];\n\t\tu32 band_1_5[5][6][4];\n\t} coef_probs[4][2][2];\n\n\tu32 intra_inter[4][2];\n\tu32 comp_inter[5][2];\n\tu32 comp_inter_padding[2];\n\tu32 comp_ref[5][2];\n\tu32 comp_ref_padding[2];\n\tu32 single_ref[5][2][2];\n\tu32 inter_mode[7][4];\n\tu32 y_mode[4][12];\n\tu32 uv_mode[10][10];\n\tu32 partition[16][4];\n\tu32 switchable_interp[4][4];\n\n\tu32 tx_p8x8[2][2];\n\tu32 tx_p16x16[2][4];\n\tu32 tx_p32x32[2][4];\n\n\tu32 skip[3][4];\n\n\tu32 joint[4];\n\n\tstruct {\n\t\tu32 sign[2];\n\t\tu32 class0[2];\n\t\tu32 classes[12];\n\t\tu32 bits[10][2];\n\t\tu32 padding[4];\n\t\tu32 class0_fp[2][4];\n\t\tu32 fp[4];\n\t\tu32 class0_hp[2];\n\t\tu32 hp[2];\n\t} mvcomp[2];\n\n\tu32 reserved[126][4];\n};\n\n \nstruct vdec_vp9_slice_counts_map {\n\tu32 skip[3][2];\n\tu32 y_mode[4][10];\n\tu32 filter[4][3];\n\tu32 sign[2][2];\n\tu32 classes[2][11];\n\tu32 class0[2][2];\n\tu32 bits[2][10][2];\n\tu32 class0_fp[2][2][4];\n\tu32 fp[2][4];\n\tu32 class0_hp[2][2];\n\tu32 hp[2][2];\n};\n\n \nstruct vdec_vp9_slice_uncompressed_header {\n\tu8 profile;\n\tu8 last_frame_type;\n\tu8 frame_type;\n\n\tu8 last_show_frame;\n\tu8 show_frame;\n\tu8 error_resilient_mode;\n\n\tu8 bit_depth;\n\tu8 padding0[1];\n\tu16 last_frame_width;\n\tu16 last_frame_height;\n\tu16 frame_width;\n\tu16 frame_height;\n\n\tu8 intra_only;\n\tu8 reset_frame_context;\n\tu8 ref_frame_sign_bias[4];\n\tu8 allow_high_precision_mv;\n\tu8 interpolation_filter;\n\n\tu8 refresh_frame_context;\n\tu8 frame_parallel_decoding_mode;\n\tu8 frame_context_idx;\n\n\t \n\tu8 loop_filter_level;\n\tu8 loop_filter_sharpness;\n\tu8 loop_filter_delta_enabled;\n\ts8 loop_filter_ref_deltas[4];\n\ts8 loop_filter_mode_deltas[2];\n\n\t \n\tu8 base_q_idx;\n\ts8 delta_q_y_dc;\n\ts8 delta_q_uv_dc;\n\ts8 delta_q_uv_ac;\n\n\t \n\tu8 segmentation_enabled;\n\tu8 segmentation_update_map;\n\tu8 segmentation_tree_probs[7];\n\tu8 padding1[1];\n\tu8 segmentation_temporal_udpate;\n\tu8 segmentation_pred_prob[3];\n\tu8 segmentation_update_data;\n\tu8 segmentation_abs_or_delta_update;\n\tu8 feature_enabled[8];\n\ts16 feature_value[8][4];\n\n\t \n\tu8 tile_cols_log2;\n\tu8 tile_rows_log2;\n\tu8 padding2[2];\n\n\tu16 uncompressed_header_size;\n\tu16 header_size_in_bytes;\n\n\t \n\tu32 dequant[8][4];\n};\n\n \nstruct vdec_vp9_slice_compressed_header {\n\tu8 tx_mode;\n\tu8 ref_mode;\n\tu8 comp_fixed_ref;\n\tu8 comp_var_ref[2];\n\tu8 padding[3];\n};\n\n \nstruct vdec_vp9_slice_tiles {\n\tu32 size[4][64];\n\tu32 mi_rows[4];\n\tu32 mi_cols[64];\n\tu8 actual_rows;\n\tu8 padding[7];\n};\n\n \nstruct vdec_vp9_slice_reference {\n\tu16 frame_width;\n\tu16 frame_height;\n\tu8 bit_depth;\n\tu8 subsampling_x;\n\tu8 subsampling_y;\n\tu8 padding;\n};\n\n \nstruct vdec_vp9_slice_frame {\n\tstruct vdec_vp9_slice_uncompressed_header uh;\n\tstruct vdec_vp9_slice_compressed_header ch;\n\tstruct vdec_vp9_slice_tiles tiles;\n\tstruct vdec_vp9_slice_reference ref[3];\n};\n\n \nstruct vdec_vp9_slice_init_vsi {\n\tunsigned int architecture;\n\tunsigned int reserved;\n\tu64 core_vsi;\n\t \n\tu64 default_frame_ctx;\n};\n\n \nstruct vdec_vp9_slice_mem {\n\tunion {\n\t\tu64 buf;\n\t\tdma_addr_t dma_addr;\n\t};\n\tunion {\n\t\tsize_t size;\n\t\tdma_addr_t dma_addr_end;\n\t\tu64 padding;\n\t};\n};\n\n \nstruct vdec_vp9_slice_bs {\n\tstruct vdec_vp9_slice_mem buf;\n\tstruct vdec_vp9_slice_mem frame;\n};\n\n \nstruct vdec_vp9_slice_fb {\n\tstruct vdec_vp9_slice_mem y;\n\tstruct vdec_vp9_slice_mem c;\n};\n\n \nstruct vdec_vp9_slice_state {\n\tint err;\n\tunsigned int full;\n\tunsigned int timeout;\n\tunsigned int perf;\n\n\tunsigned int crc[12];\n};\n\n \nstruct vdec_vp9_slice_vsi {\n\t \n\tstruct vdec_vp9_slice_bs bs;\n\t \n\tstruct vdec_vp9_slice_fb fb;\n\tstruct vdec_vp9_slice_fb ref[3];\n\n\tstruct vdec_vp9_slice_mem mv[2];\n\tstruct vdec_vp9_slice_mem seg[2];\n\tstruct vdec_vp9_slice_mem tile;\n\tstruct vdec_vp9_slice_mem prob;\n\tstruct vdec_vp9_slice_mem counts;\n\n\t \n\tstruct vdec_vp9_slice_mem ube;\n\tstruct vdec_vp9_slice_mem trans;\n\tstruct vdec_vp9_slice_mem err_map;\n\tstruct vdec_vp9_slice_mem row_info;\n\n\t \n\tstruct vdec_vp9_slice_frame frame;\n\n\tstruct vdec_vp9_slice_state state;\n};\n\n \nstruct vdec_vp9_slice_pfc {\n\tstruct vdec_vp9_slice_vsi vsi;\n\n\tu64 ref_idx[3];\n\n\tint seq;\n\n\t \n\tstruct vdec_vp9_slice_state state[2];\n};\n\n \nenum vdec_vp9_slice_resolution_level {\n\tVP9_RES_NONE,\n\tVP9_RES_FHD,\n\tVP9_RES_4K,\n\tVP9_RES_8K,\n};\n\n \nstruct vdec_vp9_slice_ref {\n\tunsigned int width;\n\tunsigned int height;\n};\n\n \nstruct vdec_vp9_slice_instance {\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct vdec_vpu_inst vpu;\n\n\tint seq;\n\n\tenum vdec_vp9_slice_resolution_level level;\n\n\t \n\tunsigned int width;\n\tunsigned int height;\n\n\t \n\tunsigned int frame_type;\n\tunsigned int irq;\n\n\tunsigned int show_frame;\n\n\t \n\tstruct vdec_vp9_slice_ref dpb[VB2_MAX_FRAME];\n\n\t \n\tstruct mtk_vcodec_mem mv[2];\n\tstruct mtk_vcodec_mem seg[2];\n\tstruct mtk_vcodec_mem tile;\n\tstruct mtk_vcodec_mem prob;\n\tstruct mtk_vcodec_mem counts;\n\n\t \n\tstruct vdec_vp9_slice_frame_ctx frame_ctx[4];\n\t \n\tstruct v4l2_vp9_frame_context frame_ctx_helper;\n\tunsigned char dirty[4];\n\n\t \n\tunion {\n\t\tstruct vdec_vp9_slice_init_vsi *init_vsi;\n\t\tstruct vdec_vp9_slice_vsi *vsi;\n\t};\n\tstruct vdec_vp9_slice_vsi *core_vsi;\n\n\tstruct vdec_vp9_slice_pfc sc_pfc;\n\tstruct vdec_vp9_slice_counts_map counts_map;\n\tstruct v4l2_vp9_frame_symbol_counts counts_helper;\n};\n\n \nstatic struct vdec_vp9_slice_frame_ctx *vdec_vp9_slice_default_frame_ctx;\nstatic DEFINE_MUTEX(vdec_vp9_slice_frame_ctx_lock);\n\nstatic int vdec_vp9_slice_core_decode(struct vdec_lat_buf *lat_buf);\n\nstatic int vdec_vp9_slice_init_default_frame_ctx(struct vdec_vp9_slice_instance *instance)\n{\n\tstruct vdec_vp9_slice_frame_ctx *remote_frame_ctx;\n\tstruct vdec_vp9_slice_frame_ctx *frame_ctx;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct vdec_vp9_slice_init_vsi *vsi;\n\tint ret = 0;\n\n\tctx = instance->ctx;\n\tvsi = instance->vpu.vsi;\n\tif (!ctx || !vsi)\n\t\treturn -EINVAL;\n\n\tremote_frame_ctx = mtk_vcodec_fw_map_dm_addr(ctx->dev->fw_handler,\n\t\t\t\t\t\t     (u32)vsi->default_frame_ctx);\n\tif (!remote_frame_ctx) {\n\t\tmtk_vdec_err(ctx, \"failed to map default frame ctx\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&vdec_vp9_slice_frame_ctx_lock);\n\tif (vdec_vp9_slice_default_frame_ctx)\n\t\tgoto out;\n\n\tframe_ctx = kmemdup(remote_frame_ctx, sizeof(*frame_ctx), GFP_KERNEL);\n\tif (!frame_ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tvdec_vp9_slice_default_frame_ctx = frame_ctx;\n\nout:\n\tmutex_unlock(&vdec_vp9_slice_frame_ctx_lock);\n\n\treturn ret;\n}\n\nstatic int vdec_vp9_slice_alloc_working_buffer(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t\t       struct vdec_vp9_slice_vsi *vsi)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = instance->ctx;\n\tenum vdec_vp9_slice_resolution_level level;\n\t \n\tunsigned int max_sb_w;\n\tunsigned int max_sb_h;\n\tunsigned int max_w;\n\tunsigned int max_h;\n\tunsigned int w;\n\tunsigned int h;\n\tsize_t size;\n\tint ret;\n\tint i;\n\n\tw = vsi->frame.uh.frame_width;\n\th = vsi->frame.uh.frame_height;\n\n\tif (w > VCODEC_DEC_4K_CODED_WIDTH ||\n\t    h > VCODEC_DEC_4K_CODED_HEIGHT) {\n\t\treturn -EINVAL;\n\t} else if (w > MTK_VDEC_MAX_W || h > MTK_VDEC_MAX_H) {\n\t\t \n\t\tlevel = VP9_RES_4K;\n\t\tmax_w = VCODEC_DEC_4K_CODED_WIDTH;\n\t\tmax_h = VCODEC_DEC_4K_CODED_HEIGHT;\n\t} else {\n\t\t \n\t\tlevel = VP9_RES_FHD;\n\t\tmax_w = MTK_VDEC_MAX_W;\n\t\tmax_h = MTK_VDEC_MAX_H;\n\t}\n\n\tif (level == instance->level)\n\t\treturn 0;\n\n\tmtk_vdec_debug(ctx, \"resolution level changed, from %u to %u, %ux%u\",\n\t\t       instance->level, level, w, h);\n\n\tmax_sb_w = DIV_ROUND_UP(max_w, 64);\n\tmax_sb_h = DIV_ROUND_UP(max_h, 64);\n\tret = -ENOMEM;\n\n\t \n\n\tsize = (max_sb_w * max_sb_h + 2) * 576;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (instance->mv[i].va)\n\t\t\tmtk_vcodec_mem_free(ctx, &instance->mv[i]);\n\t\tinstance->mv[i].size = size;\n\t\tif (mtk_vcodec_mem_alloc(ctx, &instance->mv[i]))\n\t\t\tgoto err;\n\t}\n\n\tsize = (max_sb_w * max_sb_h * 32) + 256;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (instance->seg[i].va)\n\t\t\tmtk_vcodec_mem_free(ctx, &instance->seg[i]);\n\t\tinstance->seg[i].size = size;\n\t\tif (mtk_vcodec_mem_alloc(ctx, &instance->seg[i]))\n\t\t\tgoto err;\n\t}\n\n\tif (!instance->tile.va) {\n\t\tinstance->tile.size = VP9_TILE_BUF_SIZE;\n\t\tif (mtk_vcodec_mem_alloc(ctx, &instance->tile))\n\t\t\tgoto err;\n\t}\n\n\tif (!instance->prob.va) {\n\t\tinstance->prob.size = VP9_PROB_BUF_SIZE;\n\t\tif (mtk_vcodec_mem_alloc(ctx, &instance->prob))\n\t\t\tgoto err;\n\t}\n\n\tif (!instance->counts.va) {\n\t\tinstance->counts.size = VP9_COUNTS_BUF_SIZE;\n\t\tif (mtk_vcodec_mem_alloc(ctx, &instance->counts))\n\t\t\tgoto err;\n\t}\n\n\tinstance->level = level;\n\treturn 0;\n\nerr:\n\tinstance->level = VP9_RES_NONE;\n\treturn ret;\n}\n\nstatic void vdec_vp9_slice_free_working_buffer(struct vdec_vp9_slice_instance *instance)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = instance->ctx;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(instance->mv); i++) {\n\t\tif (instance->mv[i].va)\n\t\t\tmtk_vcodec_mem_free(ctx, &instance->mv[i]);\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(instance->seg); i++) {\n\t\tif (instance->seg[i].va)\n\t\t\tmtk_vcodec_mem_free(ctx, &instance->seg[i]);\n\t}\n\tif (instance->tile.va)\n\t\tmtk_vcodec_mem_free(ctx, &instance->tile);\n\tif (instance->prob.va)\n\t\tmtk_vcodec_mem_free(ctx, &instance->prob);\n\tif (instance->counts.va)\n\t\tmtk_vcodec_mem_free(ctx, &instance->counts);\n\n\tinstance->level = VP9_RES_NONE;\n}\n\nstatic void vdec_vp9_slice_vsi_from_remote(struct vdec_vp9_slice_vsi *vsi,\n\t\t\t\t\t   struct vdec_vp9_slice_vsi *remote_vsi,\n\t\t\t\t\t   int skip)\n{\n\tstruct vdec_vp9_slice_frame *rf;\n\tstruct vdec_vp9_slice_frame *f;\n\n\t \n\tif (!skip) {\n\t\trf = &remote_vsi->frame;\n\t\tf = &vsi->frame;\n\t\tmemcpy(&f->ch, &rf->ch, sizeof(f->ch));\n\t\tmemcpy(&f->uh.dequant, &rf->uh.dequant, sizeof(f->uh.dequant));\n\t\tmemcpy(&vsi->trans, &remote_vsi->trans, sizeof(vsi->trans));\n\t}\n\n\tmemcpy(&vsi->state, &remote_vsi->state, sizeof(vsi->state));\n}\n\nstatic void vdec_vp9_slice_vsi_to_remote(struct vdec_vp9_slice_vsi *vsi,\n\t\t\t\t\t struct vdec_vp9_slice_vsi *remote_vsi)\n{\n\tmemcpy(remote_vsi, vsi, sizeof(*vsi));\n}\n\nstatic int vdec_vp9_slice_tile_offset(int idx, int mi_num, int tile_log2)\n{\n\tint sbs = (mi_num + 7) >> 3;\n\tint offset = ((idx * sbs) >> tile_log2) << 3;\n\n\treturn min(offset, mi_num);\n}\n\nstatic\nint vdec_vp9_slice_setup_single_from_src_to_dst(struct vdec_vp9_slice_instance *instance)\n{\n\tstruct vb2_v4l2_buffer *src;\n\tstruct vb2_v4l2_buffer *dst;\n\n\tsrc = v4l2_m2m_next_src_buf(instance->ctx->m2m_ctx);\n\tif (!src)\n\t\treturn -EINVAL;\n\n\tdst = v4l2_m2m_next_dst_buf(instance->ctx->m2m_ctx);\n\tif (!dst)\n\t\treturn -EINVAL;\n\n\tv4l2_m2m_buf_copy_metadata(src, dst, true);\n\n\treturn 0;\n}\n\nstatic int vdec_vp9_slice_setup_lat_from_src_buf(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t\t\t struct vdec_lat_buf *lat_buf)\n{\n\tstruct vb2_v4l2_buffer *src;\n\tstruct vb2_v4l2_buffer *dst;\n\n\tsrc = v4l2_m2m_next_src_buf(instance->ctx->m2m_ctx);\n\tif (!src)\n\t\treturn -EINVAL;\n\n\tlat_buf->src_buf_req = src->vb2_buf.req_obj.req;\n\n\tdst = &lat_buf->ts_info;\n\tv4l2_m2m_buf_copy_metadata(src, dst, true);\n\treturn 0;\n}\n\nstatic void vdec_vp9_slice_setup_hdr(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t     struct vdec_vp9_slice_uncompressed_header *uh,\n\t\t\t\t     struct v4l2_ctrl_vp9_frame *hdr)\n{\n\tint i;\n\n\tuh->profile = hdr->profile;\n\tuh->last_frame_type = instance->frame_type;\n\tuh->frame_type = !HDR_FLAG(KEY_FRAME);\n\tuh->last_show_frame = instance->show_frame;\n\tuh->show_frame = HDR_FLAG(SHOW_FRAME);\n\tuh->error_resilient_mode = HDR_FLAG(ERROR_RESILIENT);\n\tuh->bit_depth = hdr->bit_depth;\n\tuh->last_frame_width = instance->width;\n\tuh->last_frame_height = instance->height;\n\tuh->frame_width = hdr->frame_width_minus_1 + 1;\n\tuh->frame_height = hdr->frame_height_minus_1 + 1;\n\tuh->intra_only = HDR_FLAG(INTRA_ONLY);\n\t \n\tswitch (hdr->reset_frame_context) {\n\tcase V4L2_VP9_RESET_FRAME_CTX_NONE:\n\t\tuh->reset_frame_context = VP9_RESET_FRAME_CONTEXT_NONE0;\n\t\tbreak;\n\tcase V4L2_VP9_RESET_FRAME_CTX_SPEC:\n\t\tuh->reset_frame_context = VP9_RESET_FRAME_CONTEXT_SPEC;\n\t\tbreak;\n\tcase V4L2_VP9_RESET_FRAME_CTX_ALL:\n\t\tuh->reset_frame_context = VP9_RESET_FRAME_CONTEXT_ALL;\n\t\tbreak;\n\tdefault:\n\t\tuh->reset_frame_context = VP9_RESET_FRAME_CONTEXT_NONE0;\n\t\tbreak;\n\t}\n\t \n\tuh->ref_frame_sign_bias[0] = 0;\n\tfor (i = 0; i < 3; i++)\n\t\tuh->ref_frame_sign_bias[i + 1] =\n\t\t\t!!(hdr->ref_frame_sign_bias & (1 << i));\n\tuh->allow_high_precision_mv = HDR_FLAG(ALLOW_HIGH_PREC_MV);\n\tuh->interpolation_filter = hdr->interpolation_filter;\n\tuh->refresh_frame_context = HDR_FLAG(REFRESH_FRAME_CTX);\n\tuh->frame_parallel_decoding_mode = HDR_FLAG(PARALLEL_DEC_MODE);\n\tuh->frame_context_idx = hdr->frame_context_idx;\n\n\t \n\tuh->tile_cols_log2 = hdr->tile_cols_log2;\n\tuh->tile_rows_log2 = hdr->tile_rows_log2;\n\n\tuh->uncompressed_header_size = hdr->uncompressed_header_size;\n\tuh->header_size_in_bytes = hdr->compressed_header_size;\n}\n\nstatic void vdec_vp9_slice_setup_frame_ctx(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t\t   struct vdec_vp9_slice_uncompressed_header *uh,\n\t\t\t\t\t   struct v4l2_ctrl_vp9_frame *hdr)\n{\n\tint error_resilient_mode;\n\tint reset_frame_context;\n\tint key_frame;\n\tint intra_only;\n\tint i;\n\n\tkey_frame = HDR_FLAG(KEY_FRAME);\n\tintra_only = HDR_FLAG(INTRA_ONLY);\n\terror_resilient_mode = HDR_FLAG(ERROR_RESILIENT);\n\treset_frame_context = uh->reset_frame_context;\n\n\t \n\tif (key_frame || intra_only || error_resilient_mode) {\n\t\t \n\t\tif (key_frame || error_resilient_mode ||\n\t\t    reset_frame_context == 3) {\n\t\t\t \n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tinstance->dirty[i] = 0;\n\t\t} else if (reset_frame_context == 2) {\n\t\t\tinstance->dirty[uh->frame_context_idx] = 0;\n\t\t}\n\t\tuh->frame_context_idx = 0;\n\t}\n}\n\nstatic void vdec_vp9_slice_setup_loop_filter(struct vdec_vp9_slice_uncompressed_header *uh,\n\t\t\t\t\t     struct v4l2_vp9_loop_filter *lf)\n{\n\tint i;\n\n\tuh->loop_filter_level = lf->level;\n\tuh->loop_filter_sharpness = lf->sharpness;\n\tuh->loop_filter_delta_enabled = LF_FLAG(DELTA_ENABLED);\n\tfor (i = 0; i < 4; i++)\n\t\tuh->loop_filter_ref_deltas[i] = lf->ref_deltas[i];\n\tfor (i = 0; i < 2; i++)\n\t\tuh->loop_filter_mode_deltas[i] = lf->mode_deltas[i];\n}\n\nstatic void vdec_vp9_slice_setup_quantization(struct vdec_vp9_slice_uncompressed_header *uh,\n\t\t\t\t\t      struct v4l2_vp9_quantization *quant)\n{\n\tuh->base_q_idx = quant->base_q_idx;\n\tuh->delta_q_y_dc = quant->delta_q_y_dc;\n\tuh->delta_q_uv_dc = quant->delta_q_uv_dc;\n\tuh->delta_q_uv_ac = quant->delta_q_uv_ac;\n}\n\nstatic void vdec_vp9_slice_setup_segmentation(struct vdec_vp9_slice_uncompressed_header *uh,\n\t\t\t\t\t      struct v4l2_vp9_segmentation *seg)\n{\n\tint i;\n\tint j;\n\n\tuh->segmentation_enabled = SEG_FLAG(ENABLED);\n\tuh->segmentation_update_map = SEG_FLAG(UPDATE_MAP);\n\tfor (i = 0; i < 7; i++)\n\t\tuh->segmentation_tree_probs[i] = seg->tree_probs[i];\n\tuh->segmentation_temporal_udpate = SEG_FLAG(TEMPORAL_UPDATE);\n\tfor (i = 0; i < 3; i++)\n\t\tuh->segmentation_pred_prob[i] = seg->pred_probs[i];\n\tuh->segmentation_update_data = SEG_FLAG(UPDATE_DATA);\n\tuh->segmentation_abs_or_delta_update = SEG_FLAG(ABS_OR_DELTA_UPDATE);\n\tfor (i = 0; i < 8; i++) {\n\t\tuh->feature_enabled[i] = seg->feature_enabled[i];\n\t\tfor (j = 0; j < 4; j++)\n\t\t\tuh->feature_value[i][j] = seg->feature_data[i][j];\n\t}\n}\n\nstatic int vdec_vp9_slice_setup_tile(struct vdec_vp9_slice_vsi *vsi,\n\t\t\t\t     struct v4l2_ctrl_vp9_frame *hdr)\n{\n\tunsigned int rows_log2;\n\tunsigned int cols_log2;\n\tunsigned int rows;\n\tunsigned int cols;\n\tunsigned int mi_rows;\n\tunsigned int mi_cols;\n\tstruct vdec_vp9_slice_tiles *tiles;\n\tint offset;\n\tint start;\n\tint end;\n\tint i;\n\n\trows_log2 = hdr->tile_rows_log2;\n\tcols_log2 = hdr->tile_cols_log2;\n\trows = 1 << rows_log2;\n\tcols = 1 << cols_log2;\n\ttiles = &vsi->frame.tiles;\n\ttiles->actual_rows = 0;\n\n\tif (rows > 4 || cols > 64)\n\t\treturn -EINVAL;\n\n\t \n\tmi_rows = (hdr->frame_height_minus_1 + 1 + 7) >> 3;\n\tmi_cols = (hdr->frame_width_minus_1 + 1 + 7) >> 3;\n\n\tfor (i = 0; i < rows; i++) {\n\t\tstart = vdec_vp9_slice_tile_offset(i, mi_rows, rows_log2);\n\t\tend = vdec_vp9_slice_tile_offset(i + 1, mi_rows, rows_log2);\n\t\toffset = end - start;\n\t\ttiles->mi_rows[i] = (offset + 7) >> 3;\n\t\tif (tiles->mi_rows[i])\n\t\t\ttiles->actual_rows++;\n\t}\n\n\tfor (i = 0; i < cols; i++) {\n\t\tstart = vdec_vp9_slice_tile_offset(i, mi_cols, cols_log2);\n\t\tend = vdec_vp9_slice_tile_offset(i + 1, mi_cols, cols_log2);\n\t\toffset = end - start;\n\t\ttiles->mi_cols[i] = (offset + 7) >> 3;\n\t}\n\n\treturn 0;\n}\n\nstatic void vdec_vp9_slice_setup_state(struct vdec_vp9_slice_vsi *vsi)\n{\n\tmemset(&vsi->state, 0, sizeof(vsi->state));\n}\n\nstatic void vdec_vp9_slice_setup_ref_idx(struct vdec_vp9_slice_pfc *pfc,\n\t\t\t\t\t struct v4l2_ctrl_vp9_frame *hdr)\n{\n\tpfc->ref_idx[0] = hdr->last_frame_ts;\n\tpfc->ref_idx[1] = hdr->golden_frame_ts;\n\tpfc->ref_idx[2] = hdr->alt_frame_ts;\n}\n\nstatic int vdec_vp9_slice_setup_pfc(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t    struct vdec_vp9_slice_pfc *pfc)\n{\n\tstruct v4l2_ctrl_vp9_frame *hdr;\n\tstruct vdec_vp9_slice_uncompressed_header *uh;\n\tstruct v4l2_ctrl *hdr_ctrl;\n\tstruct vdec_vp9_slice_vsi *vsi;\n\tint ret;\n\n\t \n\thdr_ctrl = v4l2_ctrl_find(&instance->ctx->ctrl_hdl, V4L2_CID_STATELESS_VP9_FRAME);\n\tif (!hdr_ctrl || !hdr_ctrl->p_cur.p)\n\t\treturn -EINVAL;\n\n\thdr = hdr_ctrl->p_cur.p;\n\tvsi = &pfc->vsi;\n\tuh = &vsi->frame.uh;\n\n\t \n\tvdec_vp9_slice_setup_hdr(instance, uh, hdr);\n\tvdec_vp9_slice_setup_frame_ctx(instance, uh, hdr);\n\tvdec_vp9_slice_setup_loop_filter(uh, &hdr->lf);\n\tvdec_vp9_slice_setup_quantization(uh, &hdr->quant);\n\tvdec_vp9_slice_setup_segmentation(uh, &hdr->seg);\n\tret = vdec_vp9_slice_setup_tile(vsi, hdr);\n\tif (ret)\n\t\treturn ret;\n\tvdec_vp9_slice_setup_state(vsi);\n\n\t \n\tvdec_vp9_slice_setup_ref_idx(pfc, hdr);\n\n\tpfc->seq = instance->seq;\n\tinstance->seq++;\n\n\treturn 0;\n}\n\nstatic int vdec_vp9_slice_setup_lat_buffer(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t\t   struct vdec_vp9_slice_vsi *vsi,\n\t\t\t\t\t   struct mtk_vcodec_mem *bs,\n\t\t\t\t\t   struct vdec_lat_buf *lat_buf)\n{\n\tint i;\n\n\tvsi->bs.buf.dma_addr = bs->dma_addr;\n\tvsi->bs.buf.size = bs->size;\n\tvsi->bs.frame.dma_addr = bs->dma_addr;\n\tvsi->bs.frame.size = bs->size;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tvsi->mv[i].dma_addr = instance->mv[i].dma_addr;\n\t\tvsi->mv[i].size = instance->mv[i].size;\n\t}\n\tfor (i = 0; i < 2; i++) {\n\t\tvsi->seg[i].dma_addr = instance->seg[i].dma_addr;\n\t\tvsi->seg[i].size = instance->seg[i].size;\n\t}\n\tvsi->tile.dma_addr = instance->tile.dma_addr;\n\tvsi->tile.size = instance->tile.size;\n\tvsi->prob.dma_addr = instance->prob.dma_addr;\n\tvsi->prob.size = instance->prob.size;\n\tvsi->counts.dma_addr = instance->counts.dma_addr;\n\tvsi->counts.size = instance->counts.size;\n\n\tvsi->ube.dma_addr = lat_buf->ctx->msg_queue.wdma_addr.dma_addr;\n\tvsi->ube.size = lat_buf->ctx->msg_queue.wdma_addr.size;\n\tvsi->trans.dma_addr = lat_buf->ctx->msg_queue.wdma_wptr_addr;\n\t \n\tvsi->trans.dma_addr_end = lat_buf->ctx->msg_queue.wdma_rptr_addr;\n\tvsi->err_map.dma_addr = lat_buf->wdma_err_addr.dma_addr;\n\tvsi->err_map.size = lat_buf->wdma_err_addr.size;\n\n\tvsi->row_info.buf = 0;\n\tvsi->row_info.size = 0;\n\n\treturn 0;\n}\n\nstatic int vdec_vp9_slice_setup_prob_buffer(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t\t    struct vdec_vp9_slice_vsi *vsi)\n{\n\tstruct vdec_vp9_slice_frame_ctx *frame_ctx;\n\tstruct vdec_vp9_slice_uncompressed_header *uh;\n\n\tuh = &vsi->frame.uh;\n\n\tmtk_vdec_debug(instance->ctx, \"ctx dirty %u idx %d\\n\",\n\t\t       instance->dirty[uh->frame_context_idx],\n\t\t       uh->frame_context_idx);\n\n\tif (instance->dirty[uh->frame_context_idx])\n\t\tframe_ctx = &instance->frame_ctx[uh->frame_context_idx];\n\telse\n\t\tframe_ctx = vdec_vp9_slice_default_frame_ctx;\n\tmemcpy(instance->prob.va, frame_ctx, sizeof(*frame_ctx));\n\n\treturn 0;\n}\n\nstatic void vdec_vp9_slice_setup_seg_buffer(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t\t    struct vdec_vp9_slice_vsi *vsi,\n\t\t\t\t\t    struct mtk_vcodec_mem *buf)\n{\n\tstruct vdec_vp9_slice_uncompressed_header *uh;\n\n\t \n\tuh = &vsi->frame.uh;\n\tif (uh->frame_type == 0 ||\n\t    uh->intra_only ||\n\t    uh->error_resilient_mode ||\n\t    uh->frame_width != instance->width ||\n\t    uh->frame_height != instance->height) {\n\t\tmtk_vdec_debug(instance->ctx, \"reset seg\\n\");\n\t\tmemset(buf->va, 0, buf->size);\n\t}\n}\n\n \nstatic int vdec_vp9_slice_setup_tile_buffer(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t\t    struct vdec_vp9_slice_vsi *vsi,\n\t\t\t\t\t    struct mtk_vcodec_mem *bs)\n{\n\tstruct vdec_vp9_slice_uncompressed_header *uh;\n\tunsigned int rows_log2;\n\tunsigned int cols_log2;\n\tunsigned int rows;\n\tunsigned int cols;\n\tunsigned int mi_row;\n\tunsigned int mi_col;\n\tunsigned int offset;\n\tunsigned int pa;\n\tunsigned int size;\n\tstruct vdec_vp9_slice_tiles *tiles;\n\tunsigned char *pos;\n\tunsigned char *end;\n\tunsigned char *va;\n\tunsigned int *tb;\n\tint i;\n\tint j;\n\n\tuh = &vsi->frame.uh;\n\trows_log2 = uh->tile_rows_log2;\n\tcols_log2 = uh->tile_cols_log2;\n\trows = 1 << rows_log2;\n\tcols = 1 << cols_log2;\n\n\tif (rows > 4 || cols > 64) {\n\t\tmtk_vdec_err(instance->ctx, \"tile_rows %u tile_cols %u\\n\", rows, cols);\n\t\treturn -EINVAL;\n\t}\n\n\toffset = uh->uncompressed_header_size +\n\t\tuh->header_size_in_bytes;\n\tif (bs->size <= offset) {\n\t\tmtk_vdec_err(instance->ctx, \"bs size %zu tile offset %u\\n\", bs->size, offset);\n\t\treturn -EINVAL;\n\t}\n\n\ttiles = &vsi->frame.tiles;\n\t \n\n\tva = (unsigned char *)bs->va;\n\tpos = va + offset;\n\tend = va + bs->size;\n\t \n\tpa = (unsigned int)bs->dma_addr + offset;\n\ttb = instance->tile.va;\n\tfor (i = 0; i < rows; i++) {\n\t\tfor (j = 0; j < cols; j++) {\n\t\t\tif (i == rows - 1 &&\n\t\t\t    j == cols - 1) {\n\t\t\t\tsize = (unsigned int)(end - pos);\n\t\t\t} else {\n\t\t\t\tif (end - pos < 4)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tsize = (pos[0] << 24) | (pos[1] << 16) |\n\t\t\t\t\t(pos[2] << 8) | pos[3];\n\t\t\t\tpos += 4;\n\t\t\t\tpa += 4;\n\t\t\t\toffset += 4;\n\t\t\t\tif (end - pos < size)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ttiles->size[i][j] = size;\n\t\t\tif (tiles->mi_rows[i]) {\n\t\t\t\t*tb++ = (size << 3) + ((offset << 3) & 0x7f);\n\t\t\t\t*tb++ = pa & ~0xf;\n\t\t\t\t*tb++ = (pa << 3) & 0x7f;\n\t\t\t\tmi_row = (tiles->mi_rows[i] - 1) & 0x1ff;\n\t\t\t\tmi_col = (tiles->mi_cols[j] - 1) & 0x3f;\n\t\t\t\t*tb++ = (mi_row << 6) + mi_col;\n\t\t\t}\n\t\t\tpos += size;\n\t\t\tpa += size;\n\t\t\toffset += size;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vdec_vp9_slice_setup_lat(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t    struct mtk_vcodec_mem *bs,\n\t\t\t\t    struct vdec_lat_buf *lat_buf,\n\t\t\t\t    struct vdec_vp9_slice_pfc *pfc)\n{\n\tstruct vdec_vp9_slice_vsi *vsi = &pfc->vsi;\n\tint ret;\n\n\tret = vdec_vp9_slice_setup_lat_from_src_buf(instance, lat_buf);\n\tif (ret)\n\t\tgoto err;\n\n\tret = vdec_vp9_slice_setup_pfc(instance, pfc);\n\tif (ret)\n\t\tgoto err;\n\n\tret = vdec_vp9_slice_alloc_working_buffer(instance, vsi);\n\tif (ret)\n\t\tgoto err;\n\n\tret = vdec_vp9_slice_setup_lat_buffer(instance, vsi, bs, lat_buf);\n\tif (ret)\n\t\tgoto err;\n\n\tvdec_vp9_slice_setup_seg_buffer(instance, vsi, &instance->seg[0]);\n\n\t \n\n\tret = vdec_vp9_slice_setup_prob_buffer(instance, vsi);\n\tif (ret)\n\t\tgoto err;\n\n\tret = vdec_vp9_slice_setup_tile_buffer(instance, vsi, bs);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic\nvoid vdec_vp9_slice_map_counts_eob_coef(unsigned int i, unsigned int j, unsigned int k,\n\t\t\t\t\tstruct vdec_vp9_slice_frame_counts *counts,\n\t\t\t\t\tstruct v4l2_vp9_frame_symbol_counts *counts_helper)\n{\n\tu32 l = 0, m;\n\n\t \n\tfor (m = 0; m < 3; m++) {\n\t\tcounts_helper->coeff[i][j][k][l][m] =\n\t\t\t(u32 (*)[3]) & counts->coef_probs[i][j][k].band_0[m];\n\t\tcounts_helper->eob[i][j][k][l][m][0] =\n\t\t\t&counts->eob_branch[i][j][k].band_0[m];\n\t\tcounts_helper->eob[i][j][k][l][m][1] =\n\t\t\t&counts->coef_probs[i][j][k].band_0[m][3];\n\t}\n\n\tfor (l = 1; l < 6; l++) {\n\t\tfor (m = 0; m < 6; m++) {\n\t\t\tcounts_helper->coeff[i][j][k][l][m] =\n\t\t\t\t(u32 (*)[3]) & counts->coef_probs[i][j][k].band_1_5[l - 1][m];\n\t\t\tcounts_helper->eob[i][j][k][l][m][0] =\n\t\t\t\t&counts->eob_branch[i][j][k].band_1_5[l - 1][m];\n\t\t\tcounts_helper->eob[i][j][k][l][m][1] =\n\t\t\t\t&counts->coef_probs[i][j][k].band_1_5[l - 1][m][3];\n\t\t}\n\t}\n}\n\nstatic void vdec_vp9_slice_counts_map_helper(struct vdec_vp9_slice_counts_map *counts_map,\n\t\t\t\t\t     struct vdec_vp9_slice_frame_counts *counts,\n\t\t\t\t\t     struct v4l2_vp9_frame_symbol_counts *counts_helper)\n{\n\tint i, j, k;\n\n\tcounts_helper->partition = &counts->partition;\n\tcounts_helper->intra_inter = &counts->intra_inter;\n\tcounts_helper->tx32p = &counts->tx_p32x32;\n\tcounts_helper->tx16p = &counts->tx_p16x16;\n\tcounts_helper->tx8p = &counts->tx_p8x8;\n\tcounts_helper->uv_mode = &counts->uv_mode;\n\n\tcounts_helper->comp = &counts->comp_inter;\n\tcounts_helper->comp_ref = &counts->comp_ref;\n\tcounts_helper->single_ref = &counts->single_ref;\n\tcounts_helper->mv_mode = &counts->inter_mode;\n\tcounts_helper->mv_joint = &counts->joint;\n\n\tfor (i = 0; i < ARRAY_SIZE(counts_map->skip); i++)\n\t\tmemcpy(counts_map->skip[i], counts->skip[i],\n\t\t       sizeof(counts_map->skip[0]));\n\tcounts_helper->skip = &counts_map->skip;\n\n\tfor (i = 0; i < ARRAY_SIZE(counts_map->y_mode); i++)\n\t\tmemcpy(counts_map->y_mode[i], counts->y_mode[i],\n\t\t       sizeof(counts_map->y_mode[0]));\n\tcounts_helper->y_mode = &counts_map->y_mode;\n\n\tfor (i = 0; i < ARRAY_SIZE(counts_map->filter); i++)\n\t\tmemcpy(counts_map->filter[i], counts->switchable_interp[i],\n\t\t       sizeof(counts_map->filter[0]));\n\tcounts_helper->filter = &counts_map->filter;\n\n\tfor (i = 0; i < ARRAY_SIZE(counts_map->sign); i++)\n\t\tmemcpy(counts_map->sign[i], counts->mvcomp[i].sign,\n\t\t       sizeof(counts_map->sign[0]));\n\tcounts_helper->sign = &counts_map->sign;\n\n\tfor (i = 0; i < ARRAY_SIZE(counts_map->classes); i++)\n\t\tmemcpy(counts_map->classes[i], counts->mvcomp[i].classes,\n\t\t       sizeof(counts_map->classes[0]));\n\tcounts_helper->classes = &counts_map->classes;\n\n\tfor (i = 0; i < ARRAY_SIZE(counts_map->class0); i++)\n\t\tmemcpy(counts_map->class0[i], counts->mvcomp[i].class0,\n\t\t       sizeof(counts_map->class0[0]));\n\tcounts_helper->class0 = &counts_map->class0;\n\n\tfor (i = 0; i < ARRAY_SIZE(counts_map->bits); i++)\n\t\tfor (j = 0; j < ARRAY_SIZE(counts_map->bits[0]); j++)\n\t\t\tmemcpy(counts_map->bits[i][j], counts->mvcomp[i].bits[j],\n\t\t\t       sizeof(counts_map->bits[0][0]));\n\tcounts_helper->bits = &counts_map->bits;\n\n\tfor (i = 0; i < ARRAY_SIZE(counts_map->class0_fp); i++)\n\t\tfor (j = 0; j < ARRAY_SIZE(counts_map->class0_fp[0]); j++)\n\t\t\tmemcpy(counts_map->class0_fp[i][j], counts->mvcomp[i].class0_fp[j],\n\t\t\t       sizeof(counts_map->class0_fp[0][0]));\n\tcounts_helper->class0_fp = &counts_map->class0_fp;\n\n\tfor (i = 0; i < ARRAY_SIZE(counts_map->fp); i++)\n\t\tmemcpy(counts_map->fp[i], counts->mvcomp[i].fp,\n\t\t       sizeof(counts_map->fp[0]));\n\tcounts_helper->fp = &counts_map->fp;\n\n\tfor (i = 0; i < ARRAY_SIZE(counts_map->class0_hp); i++)\n\t\tmemcpy(counts_map->class0_hp[i], counts->mvcomp[i].class0_hp,\n\t\t       sizeof(counts_map->class0_hp[0]));\n\tcounts_helper->class0_hp = &counts_map->class0_hp;\n\n\tfor (i = 0; i < ARRAY_SIZE(counts_map->hp); i++)\n\t\tmemcpy(counts_map->hp[i], counts->mvcomp[i].hp, sizeof(counts_map->hp[0]));\n\n\tcounts_helper->hp = &counts_map->hp;\n\n\tfor (i = 0; i < 4; i++)\n\t\tfor (j = 0; j < 2; j++)\n\t\t\tfor (k = 0; k < 2; k++)\n\t\t\t\tvdec_vp9_slice_map_counts_eob_coef(i, j, k, counts, counts_helper);\n}\n\nstatic void vdec_vp9_slice_map_to_coef(unsigned int i, unsigned int j, unsigned int k,\n\t\t\t\t       struct vdec_vp9_slice_frame_ctx *frame_ctx,\n\t\t\t\t       struct v4l2_vp9_frame_context *frame_ctx_helper)\n{\n\tu32 l, m;\n\n\tfor (l = 0; l < ARRAY_SIZE(frame_ctx_helper->coef[0][0][0]); l++) {\n\t\tfor (m = 0; m < VP9_BAND_6(l); m++) {\n\t\t\tmemcpy(frame_ctx_helper->coef[i][j][k][l][m],\n\t\t\t       frame_ctx->coef_probs[i][j][k][l].probs[m],\n\t\t\t       sizeof(frame_ctx_helper->coef[i][j][k][l][0]));\n\t\t}\n\t}\n}\n\nstatic void vdec_vp9_slice_map_from_coef(unsigned int i, unsigned int j, unsigned int k,\n\t\t\t\t\t struct vdec_vp9_slice_frame_ctx *frame_ctx,\n\t\t\t\t\t struct v4l2_vp9_frame_context *frame_ctx_helper)\n{\n\tu32 l, m;\n\n\tfor (l = 0; l < ARRAY_SIZE(frame_ctx_helper->coef[0][0][0]); l++) {\n\t\tfor (m = 0; m < VP9_BAND_6(l); m++) {\n\t\t\tmemcpy(frame_ctx->coef_probs[i][j][k][l].probs[m],\n\t\t\t       frame_ctx_helper->coef[i][j][k][l][m],\n\t\t\t       sizeof(frame_ctx_helper->coef[i][j][k][l][0]));\n\t\t}\n\t}\n}\n\nstatic\nvoid vdec_vp9_slice_framectx_map_helper(bool frame_is_intra,\n\t\t\t\t\tstruct vdec_vp9_slice_frame_ctx *pre_frame_ctx,\n\t\t\t\t\tstruct vdec_vp9_slice_frame_ctx *frame_ctx,\n\t\t\t\t\tstruct v4l2_vp9_frame_context *frame_ctx_helper)\n{\n\tstruct v4l2_vp9_frame_mv_context *mv = &frame_ctx_helper->mv;\n\tu32 i, j, k;\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->coef); i++)\n\t\tfor (j = 0; j < ARRAY_SIZE(frame_ctx_helper->coef[0]); j++)\n\t\t\tfor (k = 0; k < ARRAY_SIZE(frame_ctx_helper->coef[0][0]); k++)\n\t\t\t\tvdec_vp9_slice_map_to_coef(i, j, k, pre_frame_ctx,\n\t\t\t\t\t\t\t   frame_ctx_helper);\n\n\t \n\tif (!frame_is_intra)\n\t\tframe_ctx = pre_frame_ctx;\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->tx8); i++)\n\t\tmemcpy(frame_ctx_helper->tx8[i], frame_ctx->tx_p8x8[i],\n\t\t       sizeof(frame_ctx_helper->tx8[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->tx16); i++)\n\t\tmemcpy(frame_ctx_helper->tx16[i], frame_ctx->tx_p16x16[i],\n\t\t       sizeof(frame_ctx_helper->tx16[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->tx32); i++)\n\t\tmemcpy(frame_ctx_helper->tx32[i], frame_ctx->tx_p32x32[i],\n\t\t       sizeof(frame_ctx_helper->tx32[0]));\n\n\tmemcpy(frame_ctx_helper->skip, frame_ctx->skip_probs, sizeof(frame_ctx_helper->skip));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->inter_mode); i++)\n\t\tmemcpy(frame_ctx_helper->inter_mode[i], frame_ctx->inter_mode_probs[i],\n\t\t       sizeof(frame_ctx_helper->inter_mode[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->interp_filter); i++)\n\t\tmemcpy(frame_ctx_helper->interp_filter[i], frame_ctx->switch_interp_prob[i],\n\t\t       sizeof(frame_ctx_helper->interp_filter[0]));\n\n\tmemcpy(frame_ctx_helper->is_inter, frame_ctx->intra_inter_prob,\n\t       sizeof(frame_ctx_helper->is_inter));\n\n\tmemcpy(frame_ctx_helper->comp_mode, frame_ctx->comp_inter_prob,\n\t       sizeof(frame_ctx_helper->comp_mode));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->single_ref); i++)\n\t\tmemcpy(frame_ctx_helper->single_ref[i], frame_ctx->single_ref_prob[i],\n\t\t       sizeof(frame_ctx_helper->single_ref[0]));\n\n\tmemcpy(frame_ctx_helper->comp_ref, frame_ctx->comp_ref_prob,\n\t       sizeof(frame_ctx_helper->comp_ref));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->y_mode); i++)\n\t\tmemcpy(frame_ctx_helper->y_mode[i], frame_ctx->y_mode_prob[i],\n\t\t       sizeof(frame_ctx_helper->y_mode[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->uv_mode); i++)\n\t\tmemcpy(frame_ctx_helper->uv_mode[i], frame_ctx->uv_mode_prob[i],\n\t\t       sizeof(frame_ctx_helper->uv_mode[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->partition); i++)\n\t\tmemcpy(frame_ctx_helper->partition[i], frame_ctx->partition_prob[i],\n\t\t       sizeof(frame_ctx_helper->partition[0]));\n\n\tmemcpy(mv->joint, frame_ctx->joint, sizeof(mv->joint));\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->sign); i++)\n\t\tmv->sign[i] = frame_ctx->sign_classes[i].sign;\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->classes); i++)\n\t\tmemcpy(mv->classes[i], frame_ctx->sign_classes[i].classes,\n\t\t       sizeof(mv->classes[i]));\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->class0_bit); i++)\n\t\tmv->class0_bit[i] = frame_ctx->class0_bits[i].class0[0];\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->bits); i++)\n\t\tmemcpy(mv->bits[i], frame_ctx->class0_bits[i].bits, sizeof(mv->bits[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->class0_fr); i++)\n\t\tfor (j = 0; j < ARRAY_SIZE(mv->class0_fr[0]); j++)\n\t\t\tmemcpy(mv->class0_fr[i][j], frame_ctx->class0_fp_hp[i].class0_fp[j],\n\t\t\t       sizeof(mv->class0_fr[0][0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->fr); i++)\n\t\tmemcpy(mv->fr[i], frame_ctx->class0_fp_hp[i].fp, sizeof(mv->fr[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->class0_hp); i++)\n\t\tmv->class0_hp[i] = frame_ctx->class0_fp_hp[i].class0_hp;\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->hp); i++)\n\t\tmv->hp[i] = frame_ctx->class0_fp_hp[i].hp;\n}\n\nstatic void vdec_vp9_slice_helper_map_framectx(struct v4l2_vp9_frame_context *frame_ctx_helper,\n\t\t\t\t\t       struct vdec_vp9_slice_frame_ctx *frame_ctx)\n{\n\tstruct v4l2_vp9_frame_mv_context *mv = &frame_ctx_helper->mv;\n\tu32 i, j, k;\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->tx8); i++)\n\t\tmemcpy(frame_ctx->tx_p8x8[i], frame_ctx_helper->tx8[i],\n\t\t       sizeof(frame_ctx_helper->tx8[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->tx16); i++)\n\t\tmemcpy(frame_ctx->tx_p16x16[i], frame_ctx_helper->tx16[i],\n\t\t       sizeof(frame_ctx_helper->tx16[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->tx32); i++)\n\t\tmemcpy(frame_ctx->tx_p32x32[i], frame_ctx_helper->tx32[i],\n\t\t       sizeof(frame_ctx_helper->tx32[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->coef); i++)\n\t\tfor (j = 0; j < ARRAY_SIZE(frame_ctx_helper->coef[0]); j++)\n\t\t\tfor (k = 0; k < ARRAY_SIZE(frame_ctx_helper->coef[0][0]); k++)\n\t\t\t\tvdec_vp9_slice_map_from_coef(i, j, k, frame_ctx,\n\t\t\t\t\t\t\t     frame_ctx_helper);\n\n\tmemcpy(frame_ctx->skip_probs, frame_ctx_helper->skip, sizeof(frame_ctx_helper->skip));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->inter_mode); i++)\n\t\tmemcpy(frame_ctx->inter_mode_probs[i], frame_ctx_helper->inter_mode[i],\n\t\t       sizeof(frame_ctx_helper->inter_mode[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->interp_filter); i++)\n\t\tmemcpy(frame_ctx->switch_interp_prob[i], frame_ctx_helper->interp_filter[i],\n\t\t       sizeof(frame_ctx_helper->interp_filter[0]));\n\n\tmemcpy(frame_ctx->intra_inter_prob, frame_ctx_helper->is_inter,\n\t       sizeof(frame_ctx_helper->is_inter));\n\n\tmemcpy(frame_ctx->comp_inter_prob, frame_ctx_helper->comp_mode,\n\t       sizeof(frame_ctx_helper->comp_mode));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->single_ref); i++)\n\t\tmemcpy(frame_ctx->single_ref_prob[i], frame_ctx_helper->single_ref[i],\n\t\t       sizeof(frame_ctx_helper->single_ref[0]));\n\n\tmemcpy(frame_ctx->comp_ref_prob, frame_ctx_helper->comp_ref,\n\t       sizeof(frame_ctx_helper->comp_ref));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->y_mode); i++)\n\t\tmemcpy(frame_ctx->y_mode_prob[i], frame_ctx_helper->y_mode[i],\n\t\t       sizeof(frame_ctx_helper->y_mode[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->uv_mode); i++)\n\t\tmemcpy(frame_ctx->uv_mode_prob[i], frame_ctx_helper->uv_mode[i],\n\t\t       sizeof(frame_ctx_helper->uv_mode[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(frame_ctx_helper->partition); i++)\n\t\tmemcpy(frame_ctx->partition_prob[i], frame_ctx_helper->partition[i],\n\t\t       sizeof(frame_ctx_helper->partition[0]));\n\n\tmemcpy(frame_ctx->joint, mv->joint, sizeof(mv->joint));\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->sign); i++)\n\t\tframe_ctx->sign_classes[i].sign = mv->sign[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->classes); i++)\n\t\tmemcpy(frame_ctx->sign_classes[i].classes, mv->classes[i],\n\t\t       sizeof(mv->classes[i]));\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->class0_bit); i++)\n\t\tframe_ctx->class0_bits[i].class0[0] = mv->class0_bit[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->bits); i++)\n\t\tmemcpy(frame_ctx->class0_bits[i].bits, mv->bits[i], sizeof(mv->bits[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->class0_fr); i++)\n\t\tfor (j = 0; j < ARRAY_SIZE(mv->class0_fr[0]); j++)\n\t\t\tmemcpy(frame_ctx->class0_fp_hp[i].class0_fp[j], mv->class0_fr[i][j],\n\t\t\t       sizeof(mv->class0_fr[0][0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->fr); i++)\n\t\tmemcpy(frame_ctx->class0_fp_hp[i].fp, mv->fr[i], sizeof(mv->fr[0]));\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->class0_hp); i++)\n\t\tframe_ctx->class0_fp_hp[i].class0_hp = mv->class0_hp[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(mv->hp); i++)\n\t\tframe_ctx->class0_fp_hp[i].hp = mv->hp[i];\n}\n\nstatic int vdec_vp9_slice_update_prob(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t      struct vdec_vp9_slice_vsi *vsi)\n{\n\tstruct vdec_vp9_slice_frame_ctx *pre_frame_ctx;\n\tstruct v4l2_vp9_frame_context *pre_frame_ctx_helper;\n\tstruct vdec_vp9_slice_frame_ctx *frame_ctx;\n\tstruct vdec_vp9_slice_frame_counts *counts;\n\tstruct v4l2_vp9_frame_symbol_counts *counts_helper;\n\tstruct vdec_vp9_slice_uncompressed_header *uh;\n\tbool frame_is_intra;\n\tbool use_128;\n\n\tuh = &vsi->frame.uh;\n\tpre_frame_ctx = &instance->frame_ctx[uh->frame_context_idx];\n\tpre_frame_ctx_helper = &instance->frame_ctx_helper;\n\tframe_ctx = (struct vdec_vp9_slice_frame_ctx *)instance->prob.va;\n\tcounts = (struct vdec_vp9_slice_frame_counts *)instance->counts.va;\n\tcounts_helper = &instance->counts_helper;\n\n\tif (!uh->refresh_frame_context)\n\t\treturn 0;\n\n\tif (!uh->frame_parallel_decoding_mode) {\n\t\tvdec_vp9_slice_counts_map_helper(&instance->counts_map, counts, counts_helper);\n\n\t\tframe_is_intra = !vsi->frame.uh.frame_type || vsi->frame.uh.intra_only;\n\t\t \n\t\tif (!instance->dirty[uh->frame_context_idx])\n\t\t\tvdec_vp9_slice_framectx_map_helper(frame_is_intra,\n\t\t\t\t\t\t\t   vdec_vp9_slice_default_frame_ctx,\n\t\t\t\t\t\t\t   frame_ctx,\n\t\t\t\t\t\t\t   pre_frame_ctx_helper);\n\t\telse\n\t\t\tvdec_vp9_slice_framectx_map_helper(frame_is_intra,\n\t\t\t\t\t\t\t   pre_frame_ctx,\n\t\t\t\t\t\t\t   frame_ctx,\n\t\t\t\t\t\t\t   pre_frame_ctx_helper);\n\n\t\tuse_128 = !frame_is_intra && !vsi->frame.uh.last_frame_type;\n\t\tv4l2_vp9_adapt_coef_probs(pre_frame_ctx_helper,\n\t\t\t\t\t  counts_helper,\n\t\t\t\t\t  use_128,\n\t\t\t\t\t  frame_is_intra);\n\t\tif (!frame_is_intra)\n\t\t\tv4l2_vp9_adapt_noncoef_probs(pre_frame_ctx_helper,\n\t\t\t\t\t\t     counts_helper,\n\t\t\t\t\t\t     V4L2_VP9_REFERENCE_MODE_SINGLE_REFERENCE,\n\t\t\t\t\t\t     vsi->frame.uh.interpolation_filter,\n\t\t\t\t\t\t     vsi->frame.ch.tx_mode,\n\t\t\t\t\t\t     vsi->frame.uh.allow_high_precision_mv ?\n\t\t\t\t\t\t     V4L2_VP9_FRAME_FLAG_ALLOW_HIGH_PREC_MV : 0);\n\t\tvdec_vp9_slice_helper_map_framectx(pre_frame_ctx_helper, pre_frame_ctx);\n\t} else {\n\t\tmemcpy(pre_frame_ctx, frame_ctx, sizeof(*frame_ctx));\n\t}\n\n\tinstance->dirty[uh->frame_context_idx] = 1;\n\n\treturn 0;\n}\n\nstatic int vdec_vp9_slice_update_single(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t\tstruct vdec_vp9_slice_pfc *pfc)\n{\n\tstruct vdec_vp9_slice_vsi *vsi;\n\n\tvsi = &pfc->vsi;\n\tmemcpy(&pfc->state[0], &vsi->state, sizeof(vsi->state));\n\n\tmtk_vdec_debug(instance->ctx, \"Frame %u Y_CRC %08x %08x %08x %08x\\n\",\n\t\t       pfc->seq, vsi->state.crc[0], vsi->state.crc[1],\n\t\t       vsi->state.crc[2], vsi->state.crc[3]);\n\tmtk_vdec_debug(instance->ctx, \"Frame %u C_CRC %08x %08x %08x %08x\\n\",\n\t\t       pfc->seq, vsi->state.crc[4], vsi->state.crc[5],\n\t\t       vsi->state.crc[6], vsi->state.crc[7]);\n\n\tvdec_vp9_slice_update_prob(instance, vsi);\n\n\tinstance->width = vsi->frame.uh.frame_width;\n\tinstance->height = vsi->frame.uh.frame_height;\n\tinstance->frame_type = vsi->frame.uh.frame_type;\n\tinstance->show_frame = vsi->frame.uh.show_frame;\n\n\treturn 0;\n}\n\nstatic int vdec_vp9_slice_update_lat(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t     struct vdec_lat_buf *lat_buf,\n\t\t\t\t     struct vdec_vp9_slice_pfc *pfc)\n{\n\tstruct vdec_vp9_slice_vsi *vsi;\n\n\tvsi = &pfc->vsi;\n\tmemcpy(&pfc->state[0], &vsi->state, sizeof(vsi->state));\n\n\tmtk_vdec_debug(instance->ctx, \"Frame %u LAT CRC 0x%08x %lx %lx\\n\",\n\t\t       pfc->seq, vsi->state.crc[0],\n\t\t       (unsigned long)vsi->trans.dma_addr,\n\t\t       (unsigned long)vsi->trans.dma_addr_end);\n\n\t \n\tif (vsi->state.full) {\n\t\t \n\t\tif (vsi->trans.dma_addr_end - vsi->trans.dma_addr ==\n\t\t\tvsi->ube.size)\n\t\t\treturn -ENOMEM;\n\t\treturn -EAGAIN;\n\t}\n\n\tvdec_vp9_slice_update_prob(instance, vsi);\n\n\tinstance->width = vsi->frame.uh.frame_width;\n\tinstance->height = vsi->frame.uh.frame_height;\n\tinstance->frame_type = vsi->frame.uh.frame_type;\n\tinstance->show_frame = vsi->frame.uh.show_frame;\n\n\treturn 0;\n}\n\nstatic int vdec_vp9_slice_setup_core_to_dst_buf(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t\t\tstruct vdec_lat_buf *lat_buf)\n{\n\tstruct vb2_v4l2_buffer *dst;\n\n\tdst = v4l2_m2m_next_dst_buf(instance->ctx->m2m_ctx);\n\tif (!dst)\n\t\treturn -EINVAL;\n\n\tv4l2_m2m_buf_copy_metadata(&lat_buf->ts_info, dst, true);\n\treturn 0;\n}\n\nstatic int vdec_vp9_slice_setup_core_buffer(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t\t    struct vdec_vp9_slice_pfc *pfc,\n\t\t\t\t\t    struct vdec_vp9_slice_vsi *vsi,\n\t\t\t\t\t    struct vdec_fb *fb,\n\t\t\t\t\t    struct vdec_lat_buf *lat_buf)\n{\n\tstruct vb2_buffer *vb;\n\tstruct vb2_queue *vq;\n\tstruct vdec_vp9_slice_reference *ref;\n\tint plane;\n\tint size;\n\tint w;\n\tint h;\n\tint i;\n\n\tplane = instance->ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes;\n\tw = vsi->frame.uh.frame_width;\n\th = vsi->frame.uh.frame_height;\n\tsize = ALIGN(w, 64) * ALIGN(h, 64);\n\n\t \n\tvsi->fb.y.dma_addr = fb->base_y.dma_addr;\n\tif (plane == 1)\n\t\tvsi->fb.c.dma_addr = fb->base_y.dma_addr + size;\n\telse\n\t\tvsi->fb.c.dma_addr = fb->base_c.dma_addr;\n\n\t \n\tvq = v4l2_m2m_get_vq(instance->ctx->m2m_ctx,\n\t\t\t     V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\t \n\tvb = &v4l2_m2m_next_dst_buf(instance->ctx->m2m_ctx)->vb2_buf;\n\tif (!vb)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < vq->num_buffers; i++) {\n\t\tif (vb == vq->bufs[i]) {\n\t\t\tinstance->dpb[i].width = w;\n\t\t\tinstance->dpb[i].height = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tref = &vsi->frame.ref[i];\n\t\tvb = vb2_find_buffer(vq, pfc->ref_idx[i]);\n\t\tif (!vb) {\n\t\t\tref->frame_width = w;\n\t\t\tref->frame_height = h;\n\t\t\tmemset(&vsi->ref[i], 0, sizeof(vsi->ref[i]));\n\t\t} else {\n\t\t\tint idx = vb->index;\n\n\t\t\tref->frame_width = instance->dpb[idx].width;\n\t\t\tref->frame_height = instance->dpb[idx].height;\n\t\t\tvsi->ref[i].y.dma_addr =\n\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, 0);\n\t\t\tif (plane == 1)\n\t\t\t\tvsi->ref[i].c.dma_addr =\n\t\t\t\t\tvsi->ref[i].y.dma_addr + size;\n\t\t\telse\n\t\t\t\tvsi->ref[i].c.dma_addr =\n\t\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, 1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void vdec_vp9_slice_setup_single_buffer(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t\t       struct vdec_vp9_slice_pfc *pfc,\n\t\t\t\t\t       struct vdec_vp9_slice_vsi *vsi,\n\t\t\t\t\t       struct mtk_vcodec_mem *bs,\n\t\t\t\t\t       struct vdec_fb *fb)\n{\n\tint i;\n\n\tvsi->bs.buf.dma_addr = bs->dma_addr;\n\tvsi->bs.buf.size = bs->size;\n\tvsi->bs.frame.dma_addr = bs->dma_addr;\n\tvsi->bs.frame.size = bs->size;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tvsi->mv[i].dma_addr = instance->mv[i].dma_addr;\n\t\tvsi->mv[i].size = instance->mv[i].size;\n\t}\n\tfor (i = 0; i < 2; i++) {\n\t\tvsi->seg[i].dma_addr = instance->seg[i].dma_addr;\n\t\tvsi->seg[i].size = instance->seg[i].size;\n\t}\n\tvsi->tile.dma_addr = instance->tile.dma_addr;\n\tvsi->tile.size = instance->tile.size;\n\tvsi->prob.dma_addr = instance->prob.dma_addr;\n\tvsi->prob.size = instance->prob.size;\n\tvsi->counts.dma_addr = instance->counts.dma_addr;\n\tvsi->counts.size = instance->counts.size;\n\n\tvsi->row_info.buf = 0;\n\tvsi->row_info.size = 0;\n\n\tvdec_vp9_slice_setup_core_buffer(instance, pfc, vsi, fb, NULL);\n}\n\nstatic int vdec_vp9_slice_setup_core(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t     struct vdec_fb *fb,\n\t\t\t\t     struct vdec_lat_buf *lat_buf,\n\t\t\t\t     struct vdec_vp9_slice_pfc *pfc)\n{\n\tstruct vdec_vp9_slice_vsi *vsi = &pfc->vsi;\n\tint ret;\n\n\tvdec_vp9_slice_setup_state(vsi);\n\n\tret = vdec_vp9_slice_setup_core_to_dst_buf(instance, lat_buf);\n\tif (ret)\n\t\tgoto err;\n\n\tret = vdec_vp9_slice_setup_core_buffer(instance, pfc, vsi, fb, lat_buf);\n\tif (ret)\n\t\tgoto err;\n\n\tvdec_vp9_slice_setup_seg_buffer(instance, vsi, &instance->seg[1]);\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic int vdec_vp9_slice_setup_single(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t       struct mtk_vcodec_mem *bs,\n\t\t\t\t       struct vdec_fb *fb,\n\t\t\t\t       struct vdec_vp9_slice_pfc *pfc)\n{\n\tstruct vdec_vp9_slice_vsi *vsi = &pfc->vsi;\n\tint ret;\n\n\tret = vdec_vp9_slice_setup_single_from_src_to_dst(instance);\n\tif (ret)\n\t\tgoto err;\n\n\tret = vdec_vp9_slice_setup_pfc(instance, pfc);\n\tif (ret)\n\t\tgoto err;\n\n\tret = vdec_vp9_slice_alloc_working_buffer(instance, vsi);\n\tif (ret)\n\t\tgoto err;\n\n\tvdec_vp9_slice_setup_single_buffer(instance, pfc, vsi, bs, fb);\n\tvdec_vp9_slice_setup_seg_buffer(instance, vsi, &instance->seg[0]);\n\n\tret = vdec_vp9_slice_setup_prob_buffer(instance, vsi);\n\tif (ret)\n\t\tgoto err;\n\n\tret = vdec_vp9_slice_setup_tile_buffer(instance, vsi, bs);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic int vdec_vp9_slice_update_core(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t      struct vdec_lat_buf *lat_buf,\n\t\t\t\t      struct vdec_vp9_slice_pfc *pfc)\n{\n\tstruct vdec_vp9_slice_vsi *vsi;\n\n\tvsi = &pfc->vsi;\n\tmemcpy(&pfc->state[1], &vsi->state, sizeof(vsi->state));\n\n\tmtk_vdec_debug(instance->ctx, \"Frame %u Y_CRC %08x %08x %08x %08x\\n\",\n\t\t       pfc->seq, vsi->state.crc[0], vsi->state.crc[1],\n\t\t       vsi->state.crc[2], vsi->state.crc[3]);\n\tmtk_vdec_debug(instance->ctx, \"Frame %u C_CRC %08x %08x %08x %08x\\n\",\n\t\t       pfc->seq, vsi->state.crc[4], vsi->state.crc[5],\n\t\t       vsi->state.crc[6], vsi->state.crc[7]);\n\n\treturn 0;\n}\n\nstatic int vdec_vp9_slice_init(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct vdec_vp9_slice_instance *instance;\n\tstruct vdec_vp9_slice_init_vsi *vsi;\n\tint ret;\n\n\tinstance = kzalloc(sizeof(*instance), GFP_KERNEL);\n\tif (!instance)\n\t\treturn -ENOMEM;\n\n\tinstance->ctx = ctx;\n\tinstance->vpu.id = SCP_IPI_VDEC_LAT;\n\tinstance->vpu.core_id = SCP_IPI_VDEC_CORE;\n\tinstance->vpu.ctx = ctx;\n\tinstance->vpu.codec_type = ctx->current_codec;\n\n\tret = vpu_dec_init(&instance->vpu);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"failed to init vpu dec, ret %d\\n\", ret);\n\t\tgoto error_vpu_init;\n\t}\n\n\t \n\n\tvsi = instance->vpu.vsi;\n\tif (!vsi) {\n\t\tmtk_vdec_err(ctx, \"failed to get VP9 vsi\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_vsi;\n\t}\n\tinstance->init_vsi = vsi;\n\tinstance->core_vsi = mtk_vcodec_fw_map_dm_addr(ctx->dev->fw_handler,\n\t\t\t\t\t\t       (u32)vsi->core_vsi);\n\tif (!instance->core_vsi) {\n\t\tmtk_vdec_err(ctx, \"failed to get VP9 core vsi\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_vsi;\n\t}\n\n\tinstance->irq = 1;\n\n\tret = vdec_vp9_slice_init_default_frame_ctx(instance);\n\tif (ret)\n\t\tgoto error_default_frame_ctx;\n\n\tctx->drv_handle = instance;\n\n\treturn 0;\n\nerror_default_frame_ctx:\nerror_vsi:\n\tvpu_dec_deinit(&instance->vpu);\nerror_vpu_init:\n\tkfree(instance);\n\treturn ret;\n}\n\nstatic void vdec_vp9_slice_deinit(void *h_vdec)\n{\n\tstruct vdec_vp9_slice_instance *instance = h_vdec;\n\n\tif (!instance)\n\t\treturn;\n\n\tvpu_dec_deinit(&instance->vpu);\n\tvdec_vp9_slice_free_working_buffer(instance);\n\tvdec_msg_queue_deinit(&instance->ctx->msg_queue, instance->ctx);\n\tkfree(instance);\n}\n\nstatic int vdec_vp9_slice_flush(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\tstruct vdec_fb *fb, bool *res_chg)\n{\n\tstruct vdec_vp9_slice_instance *instance = h_vdec;\n\n\tmtk_vdec_debug(instance->ctx, \"flush ...\\n\");\n\tif (instance->ctx->dev->vdec_pdata->hw_arch != MTK_VDEC_PURE_SINGLE_CORE)\n\t\tvdec_msg_queue_wait_lat_buf_full(&instance->ctx->msg_queue);\n\treturn vpu_dec_reset(&instance->vpu);\n}\n\nstatic void vdec_vp9_slice_get_pic_info(struct vdec_vp9_slice_instance *instance)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = instance->ctx;\n\tunsigned int data[3];\n\n\tmtk_vdec_debug(instance->ctx, \"w %u h %u\\n\", ctx->picinfo.pic_w, ctx->picinfo.pic_h);\n\n\tdata[0] = ctx->picinfo.pic_w;\n\tdata[1] = ctx->picinfo.pic_h;\n\tdata[2] = ctx->capture_fourcc;\n\tvpu_dec_get_param(&instance->vpu, data, 3, GET_PARAM_PIC_INFO);\n\n\tctx->picinfo.buf_w = ALIGN(ctx->picinfo.pic_w, 64);\n\tctx->picinfo.buf_h = ALIGN(ctx->picinfo.pic_h, 64);\n\tctx->picinfo.fb_sz[0] = instance->vpu.fb_sz[0];\n\tctx->picinfo.fb_sz[1] = instance->vpu.fb_sz[1];\n}\n\nstatic void vdec_vp9_slice_get_dpb_size(struct vdec_vp9_slice_instance *instance,\n\t\t\t\t\tunsigned int *dpb_sz)\n{\n\t \n\t*dpb_sz = 9;\n}\n\nstatic int vdec_vp9_slice_get_param(void *h_vdec, enum vdec_get_param_type type, void *out)\n{\n\tstruct vdec_vp9_slice_instance *instance = h_vdec;\n\n\tswitch (type) {\n\tcase GET_PARAM_PIC_INFO:\n\t\tvdec_vp9_slice_get_pic_info(instance);\n\t\tbreak;\n\tcase GET_PARAM_DPB_SIZE:\n\t\tvdec_vp9_slice_get_dpb_size(instance, out);\n\t\tbreak;\n\tcase GET_PARAM_CROP_INFO:\n\t\tmtk_vdec_debug(instance->ctx, \"No need to get vp9 crop information.\");\n\t\tbreak;\n\tdefault:\n\t\tmtk_vdec_err(instance->ctx, \"invalid get parameter type=%d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vdec_vp9_slice_single_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t\tstruct vdec_fb *fb, bool *res_chg)\n{\n\tstruct vdec_vp9_slice_instance *instance = h_vdec;\n\tstruct vdec_vp9_slice_pfc *pfc = &instance->sc_pfc;\n\tstruct vdec_vp9_slice_vsi *vsi;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tint ret;\n\n\tif (!instance || !instance->ctx)\n\t\treturn -EINVAL;\n\tctx = instance->ctx;\n\n\t \n\tif (!bs)\n\t\treturn vdec_vp9_slice_flush(h_vdec, bs, fb, res_chg);\n\n\tfb = ctx->dev->vdec_pdata->get_cap_buffer(ctx);\n\tif (!fb)\n\t\treturn -EBUSY;\n\n\tvsi = &pfc->vsi;\n\n\tret = vdec_vp9_slice_setup_single(instance, bs, fb, pfc);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"Failed to setup VP9 single ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tvdec_vp9_slice_vsi_to_remote(vsi, instance->vsi);\n\n\tret = vpu_dec_start(&instance->vpu, NULL, 0);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"Failed to dec VP9 ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mtk_vcodec_wait_for_done_ctx(ctx,\tMTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t   WAIT_INTR_TIMEOUT_MS, MTK_VDEC_CORE);\n\t \n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"VP9 decode timeout %d\\n\", ret);\n\t\tWRITE_ONCE(instance->vsi->state.timeout, 1);\n\t}\n\n\tvpu_dec_end(&instance->vpu);\n\n\tvdec_vp9_slice_vsi_from_remote(vsi, instance->vsi, 0);\n\tret = vdec_vp9_slice_update_single(instance, pfc);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"VP9 decode error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinstance->ctx->decoded_frame_cnt++;\n\treturn 0;\n}\n\nstatic int vdec_vp9_slice_lat_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t     struct vdec_fb *fb, bool *res_chg)\n{\n\tstruct vdec_vp9_slice_instance *instance = h_vdec;\n\tstruct vdec_lat_buf *lat_buf;\n\tstruct vdec_vp9_slice_pfc *pfc;\n\tstruct vdec_vp9_slice_vsi *vsi;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tint ret;\n\n\tif (!instance || !instance->ctx)\n\t\treturn -EINVAL;\n\tctx = instance->ctx;\n\n\t \n\tif (vdec_msg_queue_init(&ctx->msg_queue, ctx,\n\t\t\t\tvdec_vp9_slice_core_decode,\n\t\t\t\tsizeof(*pfc)))\n\t\treturn -ENOMEM;\n\n\t \n\tif (!bs)\n\t\treturn vdec_vp9_slice_flush(h_vdec, bs, fb, res_chg);\n\n\tlat_buf = vdec_msg_queue_dqbuf(&instance->ctx->msg_queue.lat_ctx);\n\tif (!lat_buf) {\n\t\tmtk_vdec_debug(ctx, \"Failed to get VP9 lat buf\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tpfc = (struct vdec_vp9_slice_pfc *)lat_buf->private_data;\n\tif (!pfc) {\n\t\tret = -EINVAL;\n\t\tgoto err_free_fb_out;\n\t}\n\tvsi = &pfc->vsi;\n\n\tret = vdec_vp9_slice_setup_lat(instance, bs, lat_buf, pfc);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"Failed to setup VP9 lat ret %d\\n\", ret);\n\t\tgoto err_free_fb_out;\n\t}\n\tvdec_vp9_slice_vsi_to_remote(vsi, instance->vsi);\n\n\tret = vpu_dec_start(&instance->vpu, NULL, 0);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"Failed to dec VP9 ret %d\\n\", ret);\n\t\tgoto err_free_fb_out;\n\t}\n\n\tif (instance->irq) {\n\t\tret = mtk_vcodec_wait_for_done_ctx(ctx,\tMTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t\t   WAIT_INTR_TIMEOUT_MS, MTK_VDEC_LAT0);\n\t\t \n\t\tif (ret) {\n\t\t\tmtk_vdec_err(ctx, \"VP9 decode timeout %d pic %d\\n\", ret, pfc->seq);\n\t\t\tWRITE_ONCE(instance->vsi->state.timeout, 1);\n\t\t}\n\t\tvpu_dec_end(&instance->vpu);\n\t}\n\n\tvdec_vp9_slice_vsi_from_remote(vsi, instance->vsi, 0);\n\tret = vdec_vp9_slice_update_lat(instance, lat_buf, pfc);\n\n\t \n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"VP9 decode error: %d\\n\", ret);\n\t\tgoto err_free_fb_out;\n\t}\n\n\tmtk_vdec_debug(ctx, \"lat dma addr: 0x%lx 0x%lx\\n\",\n\t\t       (unsigned long)pfc->vsi.trans.dma_addr,\n\t\t       (unsigned long)pfc->vsi.trans.dma_addr_end);\n\n\tvdec_msg_queue_update_ube_wptr(&ctx->msg_queue,\n\t\t\t\t       vsi->trans.dma_addr_end +\n\t\t\t\t       ctx->msg_queue.wdma_addr.dma_addr);\n\tvdec_msg_queue_qbuf(&ctx->msg_queue.core_ctx, lat_buf);\n\n\treturn 0;\nerr_free_fb_out:\n\tvdec_msg_queue_qbuf(&ctx->msg_queue.lat_ctx, lat_buf);\n\treturn ret;\n}\n\nstatic int vdec_vp9_slice_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t struct vdec_fb *fb, bool *res_chg)\n{\n\tstruct vdec_vp9_slice_instance *instance = h_vdec;\n\tint ret;\n\n\tif (instance->ctx->dev->vdec_pdata->hw_arch == MTK_VDEC_PURE_SINGLE_CORE)\n\t\tret = vdec_vp9_slice_single_decode(h_vdec, bs, fb, res_chg);\n\telse\n\t\tret = vdec_vp9_slice_lat_decode(h_vdec, bs, fb, res_chg);\n\n\treturn ret;\n}\n\nstatic int vdec_vp9_slice_core_decode(struct vdec_lat_buf *lat_buf)\n{\n\tstruct vdec_vp9_slice_instance *instance;\n\tstruct vdec_vp9_slice_pfc *pfc;\n\tstruct mtk_vcodec_dec_ctx *ctx = NULL;\n\tstruct vdec_fb *fb = NULL;\n\tint ret = -EINVAL;\n\n\tif (!lat_buf)\n\t\tgoto err;\n\n\tpfc = lat_buf->private_data;\n\tctx = lat_buf->ctx;\n\tif (!pfc || !ctx)\n\t\tgoto err;\n\n\tinstance = ctx->drv_handle;\n\tif (!instance)\n\t\tgoto err;\n\n\tfb = ctx->dev->vdec_pdata->get_cap_buffer(ctx);\n\tif (!fb) {\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tret = vdec_vp9_slice_setup_core(instance, fb, lat_buf, pfc);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"vdec_vp9_slice_setup_core\\n\");\n\t\tgoto err;\n\t}\n\tvdec_vp9_slice_vsi_to_remote(&pfc->vsi, instance->core_vsi);\n\n\tret = vpu_dec_core(&instance->vpu);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"vpu_dec_core\\n\");\n\t\tgoto err;\n\t}\n\n\tif (instance->irq) {\n\t\tret = mtk_vcodec_wait_for_done_ctx(ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t\t   WAIT_INTR_TIMEOUT_MS, MTK_VDEC_CORE);\n\t\t \n\t\tif (ret) {\n\t\t\tmtk_vdec_err(ctx, \"VP9 core timeout pic %d\\n\", pfc->seq);\n\t\t\tWRITE_ONCE(instance->core_vsi->state.timeout, 1);\n\t\t}\n\t\tvpu_dec_core_end(&instance->vpu);\n\t}\n\n\tvdec_vp9_slice_vsi_from_remote(&pfc->vsi, instance->core_vsi, 1);\n\tret = vdec_vp9_slice_update_core(instance, lat_buf, pfc);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"vdec_vp9_slice_update_core\\n\");\n\t\tgoto err;\n\t}\n\n\tpfc->vsi.trans.dma_addr_end += ctx->msg_queue.wdma_addr.dma_addr;\n\tmtk_vdec_debug(ctx, \"core dma_addr_end 0x%lx\\n\",\n\t\t       (unsigned long)pfc->vsi.trans.dma_addr_end);\n\tvdec_msg_queue_update_ube_rptr(&ctx->msg_queue, pfc->vsi.trans.dma_addr_end);\n\tctx->dev->vdec_pdata->cap_to_disp(ctx, 0, lat_buf->src_buf_req);\n\n\treturn 0;\n\nerr:\n\tif (ctx && pfc) {\n\t\t \n\t\tvdec_msg_queue_update_ube_rptr(&ctx->msg_queue, pfc->vsi.trans.dma_addr_end);\n\n\t\tif (fb)\n\t\t\tctx->dev->vdec_pdata->cap_to_disp(ctx, 1, lat_buf->src_buf_req);\n\t}\n\treturn ret;\n}\n\nconst struct vdec_common_if vdec_vp9_slice_lat_if = {\n\t.init\t\t= vdec_vp9_slice_init,\n\t.decode\t\t= vdec_vp9_slice_decode,\n\t.get_param\t= vdec_vp9_slice_get_param,\n\t.deinit\t\t= vdec_vp9_slice_deinit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}