{
  "module_name": "vdec_h264_req_if.c",
  "hash_id": "742cca01a44828b70c3e32299f15e749b802c7a7219d8fb9c70177441b3d6296",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_h264_req_if.c",
  "human_readable_source": "\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-h264.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"../mtk_vcodec_dec.h\"\n#include \"../../common/mtk_vcodec_intr.h\"\n#include \"../vdec_drv_base.h\"\n#include \"../vdec_drv_if.h\"\n#include \"../vdec_vpu_if.h\"\n#include \"vdec_h264_req_common.h\"\n\n \nstruct mtk_h264_dec_slice_param {\n\tstruct mtk_h264_sps_param\t\t\tsps;\n\tstruct mtk_h264_pps_param\t\t\tpps;\n\tstruct slice_api_h264_scaling_matrix\t\tscaling_matrix;\n\tstruct slice_api_h264_decode_param\t\tdecode_params;\n\tstruct mtk_h264_dpb_info h264_dpb_info[16];\n};\n\n \nstruct vdec_h264_dec_info {\n\tu32 dpb_sz;\n\tu32 resolution_changed;\n\tu32 realloc_mv_buf;\n\tu32 cap_num_planes;\n\tu64 bs_dma;\n\tu64 y_fb_dma;\n\tu64 c_fb_dma;\n\tu64 vdec_fb_va;\n};\n\n \nstruct vdec_h264_vsi {\n\tu64 pred_buf_dma;\n\tu64 mv_buf_dma[H264_MAX_MV_NUM];\n\tstruct vdec_h264_dec_info dec;\n\tstruct vdec_pic_info pic;\n\tstruct v4l2_rect crop;\n\tstruct mtk_h264_dec_slice_param h264_slice_params;\n};\n\n \nstruct vdec_h264_slice_inst {\n\tunsigned int num_nalu;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct mtk_vcodec_mem pred_buf;\n\tstruct mtk_vcodec_mem mv_buf[H264_MAX_MV_NUM];\n\tstruct vdec_vpu_inst vpu;\n\tstruct vdec_h264_vsi vsi_ctx;\n\tstruct mtk_h264_dec_slice_param h264_slice_param;\n\n\tstruct v4l2_h264_dpb_entry dpb[16];\n};\n\nstatic int get_vdec_decode_parameters(struct vdec_h264_slice_inst *inst)\n{\n\tconst struct v4l2_ctrl_h264_decode_params *dec_params;\n\tconst struct v4l2_ctrl_h264_sps *sps;\n\tconst struct v4l2_ctrl_h264_pps *pps;\n\tconst struct v4l2_ctrl_h264_scaling_matrix *scaling_matrix;\n\tstruct mtk_h264_dec_slice_param *slice_param = &inst->h264_slice_param;\n\tstruct v4l2_h264_reflist_builder reflist_builder;\n\tstruct v4l2_h264_reference v4l2_p0_reflist[V4L2_H264_REF_LIST_LEN];\n\tstruct v4l2_h264_reference v4l2_b0_reflist[V4L2_H264_REF_LIST_LEN];\n\tstruct v4l2_h264_reference v4l2_b1_reflist[V4L2_H264_REF_LIST_LEN];\n\tu8 *p0_reflist = slice_param->decode_params.ref_pic_list_p0;\n\tu8 *b0_reflist = slice_param->decode_params.ref_pic_list_b0;\n\tu8 *b1_reflist = slice_param->decode_params.ref_pic_list_b1;\n\n\tdec_params =\n\t\tmtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_DECODE_PARAMS);\n\tif (IS_ERR(dec_params))\n\t\treturn PTR_ERR(dec_params);\n\n\tsps = mtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_SPS);\n\tif (IS_ERR(sps))\n\t\treturn PTR_ERR(sps);\n\n\tpps = mtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_PPS);\n\tif (IS_ERR(pps))\n\t\treturn PTR_ERR(pps);\n\n\tscaling_matrix =\n\t\tmtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_SCALING_MATRIX);\n\tif (IS_ERR(scaling_matrix))\n\t\treturn PTR_ERR(scaling_matrix);\n\n\tmtk_vdec_h264_update_dpb(dec_params, inst->dpb);\n\n\tmtk_vdec_h264_copy_sps_params(&slice_param->sps, sps);\n\tmtk_vdec_h264_copy_pps_params(&slice_param->pps, pps);\n\tmtk_vdec_h264_copy_scaling_matrix(&slice_param->scaling_matrix, scaling_matrix);\n\tmtk_vdec_h264_copy_decode_params(&slice_param->decode_params,\n\t\t\t\t\t dec_params, inst->dpb);\n\tmtk_vdec_h264_fill_dpb_info(inst->ctx, &slice_param->decode_params,\n\t\t\t\t    slice_param->h264_dpb_info);\n\n\t \n\tv4l2_h264_init_reflist_builder(&reflist_builder, dec_params, sps,\n\t\t\t\t       inst->dpb);\n\tv4l2_h264_build_p_ref_list(&reflist_builder, v4l2_p0_reflist);\n\tv4l2_h264_build_b_ref_lists(&reflist_builder, v4l2_b0_reflist,\n\t\t\t\t    v4l2_b1_reflist);\n\n\t \n\tmtk_vdec_h264_get_ref_list(p0_reflist, v4l2_p0_reflist, reflist_builder.num_valid);\n\tmtk_vdec_h264_get_ref_list(b0_reflist, v4l2_b0_reflist, reflist_builder.num_valid);\n\tmtk_vdec_h264_get_ref_list(b1_reflist, v4l2_b1_reflist, reflist_builder.num_valid);\n\n\tmemcpy(&inst->vsi_ctx.h264_slice_params, slice_param,\n\t       sizeof(inst->vsi_ctx.h264_slice_params));\n\n\treturn 0;\n}\n\nstatic int allocate_predication_buf(struct vdec_h264_slice_inst *inst)\n{\n\tint err;\n\n\tinst->pred_buf.size = BUF_PREDICTION_SZ;\n\terr = mtk_vcodec_mem_alloc(inst->ctx, &inst->pred_buf);\n\tif (err) {\n\t\tmtk_vdec_err(inst->ctx, \"failed to allocate ppl buf\");\n\t\treturn err;\n\t}\n\n\tinst->vsi_ctx.pred_buf_dma = inst->pred_buf.dma_addr;\n\treturn 0;\n}\n\nstatic void free_predication_buf(struct vdec_h264_slice_inst *inst)\n{\n\tstruct mtk_vcodec_mem *mem = &inst->pred_buf;\n\n\tinst->vsi_ctx.pred_buf_dma = 0;\n\tif (mem->va)\n\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n}\n\nstatic int alloc_mv_buf(struct vdec_h264_slice_inst *inst,\n\t\t\tstruct vdec_pic_info *pic)\n{\n\tint i;\n\tint err;\n\tstruct mtk_vcodec_mem *mem = NULL;\n\tunsigned int buf_sz = mtk_vdec_h264_get_mv_buf_size(pic->buf_w, pic->buf_h);\n\n\tmtk_v4l2_vdec_dbg(3, inst->ctx, \"size = 0x%x\", buf_sz);\n\tfor (i = 0; i < H264_MAX_MV_NUM; i++) {\n\t\tmem = &inst->mv_buf[i];\n\t\tif (mem->va)\n\t\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\t\tmem->size = buf_sz;\n\t\terr = mtk_vcodec_mem_alloc(inst->ctx, mem);\n\t\tif (err) {\n\t\t\tmtk_vdec_err(inst->ctx, \"failed to allocate mv buf\");\n\t\t\treturn err;\n\t\t}\n\t\tinst->vsi_ctx.mv_buf_dma[i] = mem->dma_addr;\n\t}\n\n\treturn 0;\n}\n\nstatic void free_mv_buf(struct vdec_h264_slice_inst *inst)\n{\n\tint i;\n\tstruct mtk_vcodec_mem *mem;\n\n\tfor (i = 0; i < H264_MAX_MV_NUM; i++) {\n\t\tinst->vsi_ctx.mv_buf_dma[i] = 0;\n\t\tmem = &inst->mv_buf[i];\n\t\tif (mem->va)\n\t\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\t}\n}\n\nstatic void get_pic_info(struct vdec_h264_slice_inst *inst,\n\t\t\t struct vdec_pic_info *pic)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = inst->ctx;\n\n\tctx->picinfo.buf_w = ALIGN(ctx->picinfo.pic_w, VCODEC_DEC_ALIGNED_64);\n\tctx->picinfo.buf_h = ALIGN(ctx->picinfo.pic_h, VCODEC_DEC_ALIGNED_64);\n\tctx->picinfo.fb_sz[0] = ctx->picinfo.buf_w * ctx->picinfo.buf_h;\n\tctx->picinfo.fb_sz[1] = ctx->picinfo.fb_sz[0] >> 1;\n\tinst->vsi_ctx.dec.cap_num_planes =\n\t\tctx->q_data[MTK_Q_DATA_DST].fmt->num_planes;\n\n\t*pic = ctx->picinfo;\n\tmtk_vdec_debug(inst->ctx, \"pic(%d, %d), buf(%d, %d)\",\n\t\t       ctx->picinfo.pic_w, ctx->picinfo.pic_h,\n\t\t       ctx->picinfo.buf_w, ctx->picinfo.buf_h);\n\tmtk_vdec_debug(inst->ctx, \"Y/C(%d, %d)\", ctx->picinfo.fb_sz[0],\n\t\t       ctx->picinfo.fb_sz[1]);\n\n\tif (ctx->last_decoded_picinfo.pic_w != ctx->picinfo.pic_w ||\n\t    ctx->last_decoded_picinfo.pic_h != ctx->picinfo.pic_h) {\n\t\tinst->vsi_ctx.dec.resolution_changed = true;\n\t\tif (ctx->last_decoded_picinfo.buf_w != ctx->picinfo.buf_w ||\n\t\t    ctx->last_decoded_picinfo.buf_h != ctx->picinfo.buf_h)\n\t\t\tinst->vsi_ctx.dec.realloc_mv_buf = true;\n\n\t\tmtk_v4l2_vdec_dbg(1, inst->ctx, \"ResChg: (%d %d) : old(%d, %d) -> new(%d, %d)\",\n\t\t\t\t  inst->vsi_ctx.dec.resolution_changed,\n\t\t\t\t  inst->vsi_ctx.dec.realloc_mv_buf,\n\t\t\t\t  ctx->last_decoded_picinfo.pic_w,\n\t\t\t\t  ctx->last_decoded_picinfo.pic_h,\n\t\t\t\t  ctx->picinfo.pic_w, ctx->picinfo.pic_h);\n\t}\n}\n\nstatic void get_crop_info(struct vdec_h264_slice_inst *inst, struct v4l2_rect *cr)\n{\n\tcr->left = inst->vsi_ctx.crop.left;\n\tcr->top = inst->vsi_ctx.crop.top;\n\tcr->width = inst->vsi_ctx.crop.width;\n\tcr->height = inst->vsi_ctx.crop.height;\n\n\tmtk_vdec_debug(inst->ctx, \"l=%d, t=%d, w=%d, h=%d\",\n\t\t       cr->left, cr->top, cr->width, cr->height);\n}\n\nstatic void get_dpb_size(struct vdec_h264_slice_inst *inst, unsigned int *dpb_sz)\n{\n\t*dpb_sz = inst->vsi_ctx.dec.dpb_sz;\n\tmtk_vdec_debug(inst->ctx, \"sz=%d\", *dpb_sz);\n}\n\nstatic int vdec_h264_slice_init(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct vdec_h264_slice_inst *inst;\n\tint err;\n\n\tinst = kzalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tinst->ctx = ctx;\n\n\tinst->vpu.id = SCP_IPI_VDEC_H264;\n\tinst->vpu.ctx = ctx;\n\n\terr = vpu_dec_init(&inst->vpu);\n\tif (err) {\n\t\tmtk_vdec_err(ctx, \"vdec_h264 init err=%d\", err);\n\t\tgoto error_free_inst;\n\t}\n\n\tmemcpy(&inst->vsi_ctx, inst->vpu.vsi, sizeof(inst->vsi_ctx));\n\tinst->vsi_ctx.dec.resolution_changed = true;\n\tinst->vsi_ctx.dec.realloc_mv_buf = true;\n\n\terr = allocate_predication_buf(inst);\n\tif (err)\n\t\tgoto error_deinit;\n\n\tmtk_vdec_debug(ctx, \"struct size = %zu,%zu,%zu,%zu\\n\",\n\t\t       sizeof(struct mtk_h264_sps_param),\n\t\t       sizeof(struct mtk_h264_pps_param),\n\t\t       sizeof(struct mtk_h264_dec_slice_param),\n\t\t       sizeof(struct mtk_h264_dpb_info));\n\n\tmtk_vdec_debug(ctx, \"H264 Instance >> %p\", inst);\n\n\tctx->drv_handle = inst;\n\treturn 0;\n\nerror_deinit:\n\tvpu_dec_deinit(&inst->vpu);\n\nerror_free_inst:\n\tkfree(inst);\n\treturn err;\n}\n\nstatic void vdec_h264_slice_deinit(void *h_vdec)\n{\n\tstruct vdec_h264_slice_inst *inst = h_vdec;\n\n\tvpu_dec_deinit(&inst->vpu);\n\tfree_predication_buf(inst);\n\tfree_mv_buf(inst);\n\n\tkfree(inst);\n}\n\nstatic int vdec_h264_slice_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t  struct vdec_fb *unused, bool *res_chg)\n{\n\tstruct vdec_h264_slice_inst *inst = h_vdec;\n\tconst struct v4l2_ctrl_h264_decode_params *dec_params =\n\t\tmtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_DECODE_PARAMS);\n\tstruct vdec_vpu_inst *vpu = &inst->vpu;\n\tstruct mtk_video_dec_buf *src_buf_info;\n\tstruct mtk_video_dec_buf *dst_buf_info;\n\tstruct vdec_fb *fb;\n\tu32 data[2];\n\tu64 y_fb_dma;\n\tu64 c_fb_dma;\n\tint err;\n\n\tinst->num_nalu++;\n\t \n\tif (!bs)\n\t\treturn vpu_dec_reset(vpu);\n\n\tfb = inst->ctx->dev->vdec_pdata->get_cap_buffer(inst->ctx);\n\tsrc_buf_info = container_of(bs, struct mtk_video_dec_buf, bs_buffer);\n\tdst_buf_info = container_of(fb, struct mtk_video_dec_buf, frame_buffer);\n\n\ty_fb_dma = fb ? (u64)fb->base_y.dma_addr : 0;\n\tc_fb_dma = fb ? (u64)fb->base_c.dma_addr : 0;\n\n\tmtk_vdec_debug(inst->ctx, \"+ [%d] FB y_dma=%llx c_dma=%llx va=%p\",\n\t\t       inst->num_nalu, y_fb_dma, c_fb_dma, fb);\n\n\tinst->vsi_ctx.dec.bs_dma = (uint64_t)bs->dma_addr;\n\tinst->vsi_ctx.dec.y_fb_dma = y_fb_dma;\n\tinst->vsi_ctx.dec.c_fb_dma = c_fb_dma;\n\tinst->vsi_ctx.dec.vdec_fb_va = (u64)(uintptr_t)fb;\n\n\tv4l2_m2m_buf_copy_metadata(&src_buf_info->m2m_buf.vb,\n\t\t\t\t   &dst_buf_info->m2m_buf.vb, true);\n\terr = get_vdec_decode_parameters(inst);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\tdata[0] = bs->size;\n\t \n\tdata[1] = (dec_params->nal_ref_idc << 5) |\n\t\t  ((dec_params->flags & V4L2_H264_DECODE_PARAM_FLAG_IDR_PIC)\n\t\t\t? 0x5 : 0x1);\n\n\t*res_chg = inst->vsi_ctx.dec.resolution_changed;\n\tif (*res_chg) {\n\t\tmtk_vdec_debug(inst->ctx, \"- resolution changed -\");\n\t\tif (inst->vsi_ctx.dec.realloc_mv_buf) {\n\t\t\terr = alloc_mv_buf(inst, &inst->ctx->picinfo);\n\t\t\tinst->vsi_ctx.dec.realloc_mv_buf = false;\n\t\t\tif (err)\n\t\t\t\tgoto err_free_fb_out;\n\t\t}\n\t\t*res_chg = false;\n\t}\n\n\tmemcpy(inst->vpu.vsi, &inst->vsi_ctx, sizeof(inst->vsi_ctx));\n\terr = vpu_dec_start(vpu, data, 2);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\t \n\terr = mtk_vcodec_wait_for_done_ctx(inst->ctx,\n\t\t\t\t\t   MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t   WAIT_INTR_TIMEOUT_MS, 0);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\tvpu_dec_end(vpu);\n\n\tmemcpy(&inst->vsi_ctx, inst->vpu.vsi, sizeof(inst->vsi_ctx));\n\tmtk_vdec_debug(inst->ctx, \"\\n - NALU[%d]\", inst->num_nalu);\n\treturn 0;\n\nerr_free_fb_out:\n\tmtk_vdec_err(inst->ctx, \"\\n - NALU[%d] err=%d -\\n\", inst->num_nalu, err);\n\treturn err;\n}\n\nstatic int vdec_h264_slice_get_param(void *h_vdec, enum vdec_get_param_type type, void *out)\n{\n\tstruct vdec_h264_slice_inst *inst = h_vdec;\n\n\tswitch (type) {\n\tcase GET_PARAM_PIC_INFO:\n\t\tget_pic_info(inst, out);\n\t\tbreak;\n\n\tcase GET_PARAM_DPB_SIZE:\n\t\tget_dpb_size(inst, out);\n\t\tbreak;\n\n\tcase GET_PARAM_CROP_INFO:\n\t\tget_crop_info(inst, out);\n\t\tbreak;\n\n\tdefault:\n\t\tmtk_vdec_err(inst->ctx, \"invalid get parameter type=%d\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nconst struct vdec_common_if vdec_h264_slice_if = {\n\t.init\t\t= vdec_h264_slice_init,\n\t.decode\t\t= vdec_h264_slice_decode,\n\t.get_param\t= vdec_h264_slice_get_param,\n\t.deinit\t\t= vdec_h264_slice_deinit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}