{
  "module_name": "vdec_vp8_req_if.c",
  "hash_id": "6696df6179cec93574917a3e02ad33b53f9b5ba40ccfc083663e77b53c9ee5ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_vp8_req_if.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n#include <uapi/linux/v4l2-controls.h>\n\n#include \"../mtk_vcodec_dec.h\"\n#include \"../../common/mtk_vcodec_intr.h\"\n#include \"../vdec_drv_base.h\"\n#include \"../vdec_drv_if.h\"\n#include \"../vdec_vpu_if.h\"\n\n \n#define VP8_DPB_SIZE 4\n\n \n#define VP8_SEG_ID_SZ   SZ_256K\n#define VP8_PP_WRAPY_SZ SZ_64K\n#define VP8_PP_WRAPC_SZ SZ_64K\n#define VP8_VLD_PRED_SZ SZ_64K\n\n \nstruct vdec_vp8_slice_info {\n\tu64 vld_wrapper_dma;\n\tu64 seg_id_buf_dma;\n\tu64 wrap_y_dma;\n\tu64 wrap_c_dma;\n\tu64 cur_y_fb_dma;\n\tu64 cur_c_fb_dma;\n\tu64 bs_dma;\n\tu32 bs_sz;\n\tu32 resolution_changed;\n\tu32 frame_header_type;\n\tu32 crc[8];\n\tu32 reserved;\n};\n\n \nstruct vdec_vp8_slice_dpb_info {\n\tdma_addr_t y_dma_addr;\n\tdma_addr_t c_dma_addr;\n\tint reference_flag;\n\tint reserved;\n};\n\n \nstruct vdec_vp8_slice_vsi {\n\tstruct vdec_vp8_slice_info dec;\n\tstruct vdec_pic_info pic;\n\tstruct vdec_vp8_slice_dpb_info vp8_dpb_info[3];\n};\n\n \nstruct vdec_vp8_slice_inst {\n\tstruct mtk_vcodec_mem seg_id_buf;\n\tstruct mtk_vcodec_mem wrap_y_buf;\n\tstruct mtk_vcodec_mem wrap_c_buf;\n\tstruct mtk_vcodec_mem vld_wrapper_buf;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct vdec_vpu_inst vpu;\n\tstruct vdec_vp8_slice_vsi *vsi;\n};\n\nstatic void *vdec_vp8_slice_get_ctrl_ptr(struct mtk_vcodec_dec_ctx *ctx, int id)\n{\n\tstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(&ctx->ctrl_hdl, id);\n\n\tif (!ctrl)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn ctrl->p_cur.p;\n}\n\nstatic void vdec_vp8_slice_get_pic_info(struct vdec_vp8_slice_inst *inst)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = inst->ctx;\n\tunsigned int data[3];\n\n\tdata[0] = ctx->picinfo.pic_w;\n\tdata[1] = ctx->picinfo.pic_h;\n\tdata[2] = ctx->capture_fourcc;\n\tvpu_dec_get_param(&inst->vpu, data, 3, GET_PARAM_PIC_INFO);\n\n\tctx->picinfo.buf_w = ALIGN(ctx->picinfo.pic_w, 64);\n\tctx->picinfo.buf_h = ALIGN(ctx->picinfo.pic_h, 64);\n\tctx->picinfo.fb_sz[0] = inst->vpu.fb_sz[0];\n\tctx->picinfo.fb_sz[1] = inst->vpu.fb_sz[1];\n\n\tinst->vsi->pic.pic_w = ctx->picinfo.pic_w;\n\tinst->vsi->pic.pic_h = ctx->picinfo.pic_h;\n\tinst->vsi->pic.buf_w = ctx->picinfo.buf_w;\n\tinst->vsi->pic.buf_h = ctx->picinfo.buf_h;\n\tinst->vsi->pic.fb_sz[0] = ctx->picinfo.fb_sz[0];\n\tinst->vsi->pic.fb_sz[1] = ctx->picinfo.fb_sz[1];\n\tmtk_vdec_debug(inst->ctx, \"pic(%d, %d), buf(%d, %d)\",\n\t\t       ctx->picinfo.pic_w, ctx->picinfo.pic_h,\n\t\t       ctx->picinfo.buf_w, ctx->picinfo.buf_h);\n\tmtk_vdec_debug(inst->ctx, \"fb size: Y(%d), C(%d)\",\n\t\t       ctx->picinfo.fb_sz[0], ctx->picinfo.fb_sz[1]);\n}\n\nstatic int vdec_vp8_slice_alloc_working_buf(struct vdec_vp8_slice_inst *inst)\n{\n\tint err;\n\tstruct mtk_vcodec_mem *mem;\n\n\tmem = &inst->seg_id_buf;\n\tmem->size = VP8_SEG_ID_SZ;\n\terr = mtk_vcodec_mem_alloc(inst->ctx, mem);\n\tif (err) {\n\t\tmtk_vdec_err(inst->ctx, \"Cannot allocate working buffer\");\n\t\treturn err;\n\t}\n\tinst->vsi->dec.seg_id_buf_dma = (u64)mem->dma_addr;\n\n\tmem = &inst->wrap_y_buf;\n\tmem->size = VP8_PP_WRAPY_SZ;\n\terr = mtk_vcodec_mem_alloc(inst->ctx, mem);\n\tif (err) {\n\t\tmtk_vdec_err(inst->ctx, \"cannot allocate WRAP Y buffer\");\n\t\treturn err;\n\t}\n\tinst->vsi->dec.wrap_y_dma = (u64)mem->dma_addr;\n\n\tmem = &inst->wrap_c_buf;\n\tmem->size = VP8_PP_WRAPC_SZ;\n\terr = mtk_vcodec_mem_alloc(inst->ctx, mem);\n\tif (err) {\n\t\tmtk_vdec_err(inst->ctx, \"cannot allocate WRAP C buffer\");\n\t\treturn err;\n\t}\n\tinst->vsi->dec.wrap_c_dma = (u64)mem->dma_addr;\n\n\tmem = &inst->vld_wrapper_buf;\n\tmem->size = VP8_VLD_PRED_SZ;\n\terr = mtk_vcodec_mem_alloc(inst->ctx, mem);\n\tif (err) {\n\t\tmtk_vdec_err(inst->ctx, \"cannot allocate vld wrapper buffer\");\n\t\treturn err;\n\t}\n\tinst->vsi->dec.vld_wrapper_dma = (u64)mem->dma_addr;\n\n\treturn 0;\n}\n\nstatic void vdec_vp8_slice_free_working_buf(struct vdec_vp8_slice_inst *inst)\n{\n\tstruct mtk_vcodec_mem *mem;\n\n\tmem = &inst->seg_id_buf;\n\tif (mem->va)\n\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\tinst->vsi->dec.seg_id_buf_dma = 0;\n\n\tmem = &inst->wrap_y_buf;\n\tif (mem->va)\n\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\tinst->vsi->dec.wrap_y_dma = 0;\n\n\tmem = &inst->wrap_c_buf;\n\tif (mem->va)\n\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\tinst->vsi->dec.wrap_c_dma = 0;\n\n\tmem = &inst->vld_wrapper_buf;\n\tif (mem->va)\n\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\tinst->vsi->dec.vld_wrapper_dma = 0;\n}\n\nstatic u64 vdec_vp8_slice_get_ref_by_ts(const struct v4l2_ctrl_vp8_frame *frame_header,\n\t\t\t\t\tint index)\n{\n\tswitch (index) {\n\tcase 0:\n\t\treturn frame_header->last_frame_ts;\n\tcase 1:\n\t\treturn frame_header->golden_frame_ts;\n\tcase 2:\n\t\treturn frame_header->alt_frame_ts;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\nstatic int vdec_vp8_slice_get_decode_parameters(struct vdec_vp8_slice_inst *inst)\n{\n\tconst struct v4l2_ctrl_vp8_frame *frame_header;\n\tstruct mtk_vcodec_dec_ctx *ctx = inst->ctx;\n\tstruct vb2_queue *vq;\n\tstruct vb2_buffer *vb;\n\tu64 referenct_ts;\n\tint index;\n\n\tframe_header = vdec_vp8_slice_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_VP8_FRAME);\n\tif (IS_ERR(frame_header))\n\t\treturn PTR_ERR(frame_header);\n\n\tvq = v4l2_m2m_get_vq(ctx->m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tfor (index = 0; index < 3; index++) {\n\t\treferenct_ts = vdec_vp8_slice_get_ref_by_ts(frame_header, index);\n\t\tvb = vb2_find_buffer(vq, referenct_ts);\n\t\tif (!vb) {\n\t\t\tif (!V4L2_VP8_FRAME_IS_KEY_FRAME(frame_header))\n\t\t\t\tmtk_vdec_err(inst->ctx, \"reference invalid: index(%d) ts(%lld)\",\n\t\t\t\t\t     index, referenct_ts);\n\t\t\tinst->vsi->vp8_dpb_info[index].reference_flag = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tinst->vsi->vp8_dpb_info[index].reference_flag = 1;\n\n\t\tinst->vsi->vp8_dpb_info[index].y_dma_addr =\n\t\t\tvb2_dma_contig_plane_dma_addr(vb, 0);\n\t\tif (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 2)\n\t\t\tinst->vsi->vp8_dpb_info[index].c_dma_addr =\n\t\t\t\tvb2_dma_contig_plane_dma_addr(vb, 1);\n\t\telse\n\t\t\tinst->vsi->vp8_dpb_info[index].c_dma_addr =\n\t\t\t\tinst->vsi->vp8_dpb_info[index].y_dma_addr +\n\t\t\t\tctx->picinfo.fb_sz[0];\n\t}\n\n\tinst->vsi->dec.frame_header_type = frame_header->flags >> 1;\n\n\treturn 0;\n}\n\nstatic int vdec_vp8_slice_init(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct vdec_vp8_slice_inst *inst;\n\tint err;\n\n\tinst = kzalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tinst->ctx = ctx;\n\n\tinst->vpu.id = SCP_IPI_VDEC_LAT;\n\tinst->vpu.core_id = SCP_IPI_VDEC_CORE;\n\tinst->vpu.ctx = ctx;\n\tinst->vpu.codec_type = ctx->current_codec;\n\tinst->vpu.capture_type = ctx->capture_fourcc;\n\n\terr = vpu_dec_init(&inst->vpu);\n\tif (err) {\n\t\tmtk_vdec_err(ctx, \"vdec_vp8 init err=%d\", err);\n\t\tgoto error_free_inst;\n\t}\n\n\tinst->vsi = inst->vpu.vsi;\n\terr = vdec_vp8_slice_alloc_working_buf(inst);\n\tif (err)\n\t\tgoto error_deinit;\n\n\tmtk_vdec_debug(ctx, \"vp8 struct size = %d vsi: %d\\n\",\n\t\t       (int)sizeof(struct v4l2_ctrl_vp8_frame),\n\t\t       (int)sizeof(struct vdec_vp8_slice_vsi));\n\tmtk_vdec_debug(ctx, \"vp8:%p, codec_type = 0x%x vsi: 0x%p\",\n\t\t       inst, inst->vpu.codec_type, inst->vpu.vsi);\n\n\tctx->drv_handle = inst;\n\treturn 0;\n\nerror_deinit:\n\tvpu_dec_deinit(&inst->vpu);\nerror_free_inst:\n\tkfree(inst);\n\treturn err;\n}\n\nstatic int vdec_vp8_slice_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t struct vdec_fb *fb, bool *res_chg)\n{\n\tstruct vdec_vp8_slice_inst *inst = h_vdec;\n\tstruct vdec_vpu_inst *vpu = &inst->vpu;\n\tstruct mtk_video_dec_buf *src_buf_info, *dst_buf_info;\n\tunsigned int data;\n\tu64 y_fb_dma, c_fb_dma;\n\tint err, timeout;\n\n\t \n\t*res_chg = false;\n\n\t \n\tif (!bs)\n\t\treturn vpu_dec_reset(vpu);\n\n\tsrc_buf_info = container_of(bs, struct mtk_video_dec_buf, bs_buffer);\n\n\tfb = inst->ctx->dev->vdec_pdata->get_cap_buffer(inst->ctx);\n\tdst_buf_info = container_of(fb, struct mtk_video_dec_buf, frame_buffer);\n\n\ty_fb_dma = fb ? (u64)fb->base_y.dma_addr : 0;\n\tif (inst->ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 1)\n\t\tc_fb_dma = y_fb_dma +\n\t\t\tinst->ctx->picinfo.buf_w * inst->ctx->picinfo.buf_h;\n\telse\n\t\tc_fb_dma = fb ? (u64)fb->base_c.dma_addr : 0;\n\n\tinst->vsi->dec.bs_dma = (u64)bs->dma_addr;\n\tinst->vsi->dec.bs_sz = bs->size;\n\tinst->vsi->dec.cur_y_fb_dma = y_fb_dma;\n\tinst->vsi->dec.cur_c_fb_dma = c_fb_dma;\n\n\tmtk_vdec_debug(inst->ctx, \"frame[%d] bs(%zu 0x%llx) y/c(0x%llx 0x%llx)\",\n\t\t       inst->ctx->decoded_frame_cnt,\n\t\t       bs->size, (u64)bs->dma_addr,\n\t\t       y_fb_dma, c_fb_dma);\n\n\tv4l2_m2m_buf_copy_metadata(&src_buf_info->m2m_buf.vb,\n\t\t\t\t   &dst_buf_info->m2m_buf.vb, true);\n\n\terr = vdec_vp8_slice_get_decode_parameters(inst);\n\tif (err)\n\t\tgoto error;\n\n\terr = vpu_dec_start(vpu, &data, 1);\n\tif (err) {\n\t\tmtk_vdec_debug(inst->ctx, \"vp8 dec start err!\");\n\t\tgoto error;\n\t}\n\n\tif (inst->vsi->dec.resolution_changed) {\n\t\tmtk_vdec_debug(inst->ctx, \"- resolution_changed -\");\n\t\t*res_chg = true;\n\t\treturn 0;\n\t}\n\n\t \n\ttimeout = mtk_vcodec_wait_for_done_ctx(inst->ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t       50, MTK_VDEC_CORE);\n\n\terr = vpu_dec_end(vpu);\n\tif (err || timeout)\n\t\tmtk_vdec_debug(inst->ctx, \"vp8 dec error timeout:%d err: %d pic_%d\",\n\t\t\t       timeout, err, inst->ctx->decoded_frame_cnt);\n\n\tmtk_vdec_debug(inst->ctx, \"pic[%d] crc: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\",\n\t\t       inst->ctx->decoded_frame_cnt,\n\t\t       inst->vsi->dec.crc[0], inst->vsi->dec.crc[1],\n\t\t       inst->vsi->dec.crc[2], inst->vsi->dec.crc[3],\n\t\t       inst->vsi->dec.crc[4], inst->vsi->dec.crc[5],\n\t\t       inst->vsi->dec.crc[6], inst->vsi->dec.crc[7]);\n\n\tinst->ctx->decoded_frame_cnt++;\nerror:\n\treturn err;\n}\n\nstatic int vdec_vp8_slice_get_param(void *h_vdec, enum vdec_get_param_type type, void *out)\n{\n\tstruct vdec_vp8_slice_inst *inst = h_vdec;\n\n\tswitch (type) {\n\tcase GET_PARAM_PIC_INFO:\n\t\tvdec_vp8_slice_get_pic_info(inst);\n\t\tbreak;\n\tcase GET_PARAM_CROP_INFO:\n\t\tmtk_vdec_debug(inst->ctx, \"No need to get vp8 crop information.\");\n\t\tbreak;\n\tcase GET_PARAM_DPB_SIZE:\n\t\t*((unsigned int *)out) = VP8_DPB_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tmtk_vdec_err(inst->ctx, \"invalid get parameter type=%d\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void vdec_vp8_slice_deinit(void *h_vdec)\n{\n\tstruct vdec_vp8_slice_inst *inst = h_vdec;\n\n\tvpu_dec_deinit(&inst->vpu);\n\tvdec_vp8_slice_free_working_buf(inst);\n\tkfree(inst);\n}\n\nconst struct vdec_common_if vdec_vp8_slice_if = {\n\t.init\t\t= vdec_vp8_slice_init,\n\t.decode\t\t= vdec_vp8_slice_decode,\n\t.get_param\t= vdec_vp8_slice_get_param,\n\t.deinit\t\t= vdec_vp8_slice_deinit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}