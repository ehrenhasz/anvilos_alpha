{
  "module_name": "mtk_vcodec_dec_drv.c",
  "hash_id": "8046390376f7b3803cc91ca7a92d3e1d8899dfc31822ceb8288ca65da973a8ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/mtk_vcodec_dec_drv.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/v4l2-device.h>\n\n#include \"mtk_vcodec_dec.h\"\n#include \"mtk_vcodec_dec_hw.h\"\n#include \"mtk_vcodec_dec_pm.h\"\n#include \"../common/mtk_vcodec_intr.h\"\n\nstatic int mtk_vcodec_get_hw_count(struct mtk_vcodec_dec_ctx *ctx, struct mtk_vcodec_dec_dev *dev)\n{\n\tswitch (dev->vdec_pdata->hw_arch) {\n\tcase MTK_VDEC_PURE_SINGLE_CORE:\n\t\treturn MTK_VDEC_ONE_CORE;\n\tcase MTK_VDEC_LAT_SINGLE_CORE:\n\t\treturn MTK_VDEC_ONE_LAT_ONE_CORE;\n\tdefault:\n\t\tmtk_v4l2_vdec_err(ctx, \"hw arch %d not supported\", dev->vdec_pdata->hw_arch);\n\t\treturn MTK_VDEC_NO_HW;\n\t}\n}\n\nstatic bool mtk_vcodec_is_hw_active(struct mtk_vcodec_dec_dev *dev)\n{\n\tu32 cg_status;\n\n\tif (dev->vdecsys_regmap)\n\t\treturn !regmap_test_bits(dev->vdecsys_regmap, VDEC_HW_ACTIVE_ADDR,\n\t\t\t\t\t VDEC_HW_ACTIVE_MASK);\n\n\tcg_status = readl(dev->reg_base[VDEC_SYS] + VDEC_HW_ACTIVE_ADDR);\n\treturn !FIELD_GET(VDEC_HW_ACTIVE_MASK, cg_status);\n}\n\nstatic irqreturn_t mtk_vcodec_dec_irq_handler(int irq, void *priv)\n{\n\tstruct mtk_vcodec_dec_dev *dev = priv;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tunsigned int dec_done_status = 0;\n\tvoid __iomem *vdec_misc_addr = dev->reg_base[VDEC_MISC] +\n\t\t\t\t\tVDEC_IRQ_CFG_REG;\n\n\tctx = mtk_vcodec_get_curr_ctx(dev, MTK_VDEC_CORE);\n\n\tif (!mtk_vcodec_is_hw_active(dev)) {\n\t\tmtk_v4l2_vdec_err(ctx, \"DEC ISR, VDEC active is not 0x0\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdec_done_status = readl(vdec_misc_addr);\n\tctx->irq_status = dec_done_status;\n\tif ((dec_done_status & MTK_VDEC_IRQ_STATUS_DEC_SUCCESS) !=\n\t\tMTK_VDEC_IRQ_STATUS_DEC_SUCCESS)\n\t\treturn IRQ_HANDLED;\n\n\t \n\twritel((readl(vdec_misc_addr) | VDEC_IRQ_CFG),\n\t\tdev->reg_base[VDEC_MISC] + VDEC_IRQ_CFG_REG);\n\twritel((readl(vdec_misc_addr) & ~VDEC_IRQ_CLR),\n\t\tdev->reg_base[VDEC_MISC] + VDEC_IRQ_CFG_REG);\n\n\twake_up_dec_ctx(ctx, MTK_INST_IRQ_RECEIVED, 0);\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"wake up ctx %d, dec_done_status=%x\", ctx->id, dec_done_status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mtk_vcodec_get_reg_bases(struct mtk_vcodec_dec_dev *dev)\n{\n\tstruct platform_device *pdev = dev->plat_dev;\n\tint reg_num, i;\n\tstruct resource *res;\n\tbool has_vdecsys_reg;\n\tint num_max_vdec_regs;\n\tstatic const char * const mtk_dec_reg_names[] = {\n\t\t\"misc\",\n\t\t\"ld\",\n\t\t\"top\",\n\t\t\"cm\",\n\t\t\"ad\",\n\t\t\"av\",\n\t\t\"pp\",\n\t\t\"hwd\",\n\t\t\"hwq\",\n\t\t\"hwb\",\n\t\t\"hwg\"\n\t};\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"misc\");\n\tif (res)\n\t\thas_vdecsys_reg = false;\n\telse\n\t\thas_vdecsys_reg = true;\n\n\tnum_max_vdec_regs = has_vdecsys_reg ? NUM_MAX_VDEC_REG_BASE :\n\t\t\t\t\t      ARRAY_SIZE(mtk_dec_reg_names);\n\n\t \n\treg_num = of_property_count_elems_of_size(pdev->dev.of_node, \"reg\",\n\t\t\t\t\t\t  sizeof(u32) * 4);\n\tif (reg_num <= 0 || reg_num > num_max_vdec_regs) {\n\t\tdev_err(&pdev->dev, \"Invalid register property size: %d\\n\", reg_num);\n\t\treturn -EINVAL;\n\t}\n\n\tif (has_vdecsys_reg) {\n\t\tfor (i = 0; i < reg_num; i++) {\n\t\t\tdev->reg_base[i] = devm_platform_ioremap_resource(pdev, i);\n\t\t\tif (IS_ERR(dev->reg_base[i]))\n\t\t\t\treturn PTR_ERR(dev->reg_base[i]);\n\n\t\t\tdev_dbg(&pdev->dev, \"reg[%d] base=%p\", i, dev->reg_base[i]);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < reg_num; i++) {\n\t\t\tdev->reg_base[i+1] = devm_platform_ioremap_resource_byname(pdev, mtk_dec_reg_names[i]);\n\t\t\tif (IS_ERR(dev->reg_base[i+1]))\n\t\t\t\treturn PTR_ERR(dev->reg_base[i+1]);\n\n\t\t\tdev_dbg(&pdev->dev, \"reg[%d] base=%p\", i + 1, dev->reg_base[i + 1]);\n\t\t}\n\n\t\tdev->vdecsys_regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t\t      \"mediatek,vdecsys\");\n\t\tif (IS_ERR(dev->vdecsys_regmap)) {\n\t\t\tdev_err(&pdev->dev, \"Missing mediatek,vdecsys property\");\n\t\t\treturn PTR_ERR(dev->vdecsys_regmap);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_vcodec_init_dec_resources(struct mtk_vcodec_dec_dev *dev)\n{\n\tstruct platform_device *pdev = dev->plat_dev;\n\tint ret;\n\n\tret = mtk_vcodec_get_reg_bases(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dev->vdec_pdata->is_subdev_supported)\n\t\treturn 0;\n\n\tdev->dec_irq = platform_get_irq(pdev, 0);\n\tif (dev->dec_irq < 0)\n\t\treturn dev->dec_irq;\n\n\tirq_set_status_flags(dev->dec_irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(&pdev->dev, dev->dec_irq,\n\t\t\t       mtk_vcodec_dec_irq_handler, 0, pdev->name, dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to install dev->dec_irq %d (%d)\",\n\t\t\tdev->dec_irq, ret);\n\t\treturn ret;\n\t}\n\n\tret = mtk_vcodec_init_dec_clk(pdev, &dev->pm);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get mt vcodec clock source\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\treturn 0;\n}\n\nstatic int fops_vcodec_open(struct file *file)\n{\n\tstruct mtk_vcodec_dec_dev *dev = video_drvdata(file);\n\tstruct mtk_vcodec_dec_ctx *ctx = NULL;\n\tint ret = 0, i, hw_count;\n\tstruct vb2_queue *src_vq;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&dev->dev_mutex);\n\tctx->id = dev->id_counter++;\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\tINIT_LIST_HEAD(&ctx->list);\n\tctx->dev = dev;\n\tif (ctx->dev->vdec_pdata->is_subdev_supported) {\n\t\thw_count = mtk_vcodec_get_hw_count(ctx, dev);\n\t\tif (!hw_count || !dev->subdev_prob_done) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_ctrls_setup;\n\t\t}\n\n\t\tret = dev->subdev_prob_done(dev);\n\t\tif (ret)\n\t\t\tgoto err_ctrls_setup;\n\n\t\tfor (i = 0; i < hw_count; i++)\n\t\t\tinit_waitqueue_head(&ctx->queue[i]);\n\t} else {\n\t\tinit_waitqueue_head(&ctx->queue[0]);\n\t}\n\tmutex_init(&ctx->lock);\n\n\tctx->type = MTK_INST_DECODER;\n\tret = dev->vdec_pdata->ctrls_setup(ctx);\n\tif (ret) {\n\t\tmtk_v4l2_vdec_err(ctx, \"Failed to setup mt vcodec controls\");\n\t\tgoto err_ctrls_setup;\n\t}\n\tctx->m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev_dec, ctx,\n\t\t&mtk_vcodec_dec_queue_init);\n\tif (IS_ERR((__force void *)ctx->m2m_ctx)) {\n\t\tret = PTR_ERR((__force void *)ctx->m2m_ctx);\n\t\tmtk_v4l2_vdec_err(ctx, \"Failed to v4l2_m2m_ctx_init() (%d)\", ret);\n\t\tgoto err_m2m_ctx_init;\n\t}\n\tsrc_vq = v4l2_m2m_get_vq(ctx->m2m_ctx,\n\t\t\t\tV4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\tctx->empty_flush_buf.vb.vb2_buf.vb2_queue = src_vq;\n\tmtk_vcodec_dec_set_default_params(ctx);\n\n\tif (v4l2_fh_is_singular(&ctx->fh)) {\n\t\t \n\t\tret = mtk_vcodec_fw_load_firmware(dev->fw_handler);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tmtk_v4l2_vdec_err(ctx, \"failed to load firmware!\");\n\t\t\tgoto err_load_fw;\n\t\t}\n\n\t\tdev->dec_capability =\n\t\t\tmtk_vcodec_fw_get_vdec_capa(dev->fw_handler);\n\n\t\tmtk_v4l2_vdec_dbg(0, ctx, \"decoder capability %x\", dev->dec_capability);\n\t}\n\n\tctx->dev->vdec_pdata->init_vdec_params(ctx);\n\n\tlist_add(&ctx->list, &dev->ctx_list);\n\tmtk_vcodec_dbgfs_create(ctx);\n\n\tmutex_unlock(&dev->dev_mutex);\n\tmtk_v4l2_vdec_dbg(0, ctx, \"%s decoder [%d]\", dev_name(&dev->plat_dev->dev), ctx->id);\n\treturn ret;\n\n\t \nerr_load_fw:\n\tv4l2_m2m_ctx_release(ctx->m2m_ctx);\nerr_m2m_ctx_init:\n\tv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\nerr_ctrls_setup:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn ret;\n}\n\nstatic int fops_vcodec_release(struct file *file)\n{\n\tstruct mtk_vcodec_dec_dev *dev = video_drvdata(file);\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(file->private_data);\n\n\tmtk_v4l2_vdec_dbg(0, ctx, \"[%d] decoder\", ctx->id);\n\tmutex_lock(&dev->dev_mutex);\n\n\t \n\tv4l2_m2m_ctx_release(ctx->m2m_ctx);\n\tmtk_vcodec_dec_release(ctx);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\n\n\tmtk_vcodec_dbgfs_remove(dev, ctx->id);\n\tlist_del_init(&ctx->list);\n\tkfree(ctx);\n\tmutex_unlock(&dev->dev_mutex);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations mtk_vcodec_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= fops_vcodec_open,\n\t.release\t= fops_vcodec_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic int mtk_vcodec_probe(struct platform_device *pdev)\n{\n\tstruct mtk_vcodec_dec_dev *dev;\n\tstruct video_device *vfd_dec;\n\tphandle rproc_phandle;\n\tenum mtk_vcodec_fw_type fw_type;\n\tint i, ret;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&dev->ctx_list);\n\tdev->plat_dev = pdev;\n\n\tdev->vdec_pdata = of_device_get_match_data(&pdev->dev);\n\tif (!of_property_read_u32(pdev->dev.of_node, \"mediatek,vpu\",\n\t\t\t\t  &rproc_phandle)) {\n\t\tfw_type = VPU;\n\t} else if (!of_property_read_u32(pdev->dev.of_node, \"mediatek,scp\",\n\t\t\t\t\t &rproc_phandle)) {\n\t\tfw_type = SCP;\n\t} else {\n\t\tdev_dbg(&pdev->dev, \"Could not get vdec IPI device\");\n\t\treturn -ENODEV;\n\t}\n\tdma_set_max_seg_size(&pdev->dev, UINT_MAX);\n\n\tdev->fw_handler = mtk_vcodec_fw_select(dev, fw_type, DECODER);\n\tif (IS_ERR(dev->fw_handler))\n\t\treturn PTR_ERR(dev->fw_handler);\n\n\tret = mtk_vcodec_init_dec_resources(dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to init dec resources\");\n\t\tgoto err_dec_pm;\n\t}\n\n\tif (IS_VDEC_LAT_ARCH(dev->vdec_pdata->hw_arch)) {\n\t\tdev->core_workqueue =\n\t\t\talloc_ordered_workqueue(\"core-decoder\",\n\t\t\t\t\t\tWQ_MEM_RECLAIM | WQ_FREEZABLE);\n\t\tif (!dev->core_workqueue) {\n\t\t\tdev_dbg(&pdev->dev, \"Failed to create core workqueue\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_res;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MTK_VDEC_HW_MAX; i++)\n\t\tmutex_init(&dev->dec_mutex[i]);\n\tmutex_init(&dev->dev_mutex);\n\tspin_lock_init(&dev->irqlock);\n\n\tsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name), \"%s\",\n\t\t\"[/MTK_V4L2_VDEC]\");\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"v4l2_device_register err=%d\", ret);\n\t\tgoto err_core_workq;\n\t}\n\n\tvfd_dec = video_device_alloc();\n\tif (!vfd_dec) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate video device\");\n\t\tret = -ENOMEM;\n\t\tgoto err_dec_alloc;\n\t}\n\tvfd_dec->fops\t\t= &mtk_vcodec_fops;\n\tvfd_dec->ioctl_ops\t= &mtk_vdec_ioctl_ops;\n\tvfd_dec->release\t= video_device_release;\n\tvfd_dec->lock\t\t= &dev->dev_mutex;\n\tvfd_dec->v4l2_dev\t= &dev->v4l2_dev;\n\tvfd_dec->vfl_dir\t= VFL_DIR_M2M;\n\tvfd_dec->device_caps\t= V4L2_CAP_VIDEO_M2M_MPLANE |\n\t\t\tV4L2_CAP_STREAMING;\n\n\tsnprintf(vfd_dec->name, sizeof(vfd_dec->name), \"%s\",\n\t\tMTK_VCODEC_DEC_NAME);\n\tvideo_set_drvdata(vfd_dec, dev);\n\tdev->vfd_dec = vfd_dec;\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev->m2m_dev_dec = v4l2_m2m_init(&mtk_vdec_m2m_ops);\n\tif (IS_ERR((__force void *)dev->m2m_dev_dec)) {\n\t\tdev_err(&pdev->dev, \"Failed to init mem2mem dec device\");\n\t\tret = PTR_ERR((__force void *)dev->m2m_dev_dec);\n\t\tgoto err_dec_alloc;\n\t}\n\n\tdev->decode_workqueue =\n\t\talloc_ordered_workqueue(MTK_VCODEC_DEC_NAME,\n\t\t\tWQ_MEM_RECLAIM | WQ_FREEZABLE);\n\tif (!dev->decode_workqueue) {\n\t\tdev_err(&pdev->dev, \"Failed to create decode workqueue\");\n\t\tret = -EINVAL;\n\t\tgoto err_event_workq;\n\t}\n\n\tif (dev->vdec_pdata->is_subdev_supported) {\n\t\tret = of_platform_populate(pdev->dev.of_node, NULL, NULL,\n\t\t\t\t\t   &pdev->dev);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Main device of_platform_populate failed.\");\n\t\t\tgoto err_reg_cont;\n\t\t}\n\t} else {\n\t\tset_bit(MTK_VDEC_CORE, dev->subdev_bitmap);\n\t}\n\n\tatomic_set(&dev->dec_active_cnt, 0);\n\tmemset(dev->vdec_racing_info, 0, sizeof(dev->vdec_racing_info));\n\tmutex_init(&dev->dec_racing_info_mutex);\n\n\tret = video_register_device(vfd_dec, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register video device\");\n\t\tgoto err_reg_cont;\n\t}\n\n\tif (dev->vdec_pdata->uses_stateless_api) {\n\t\tv4l2_disable_ioctl(vfd_dec, VIDIOC_DECODER_CMD);\n\t\tv4l2_disable_ioctl(vfd_dec, VIDIOC_TRY_DECODER_CMD);\n\n\t\tdev->mdev_dec.dev = &pdev->dev;\n\t\tstrscpy(dev->mdev_dec.model, MTK_VCODEC_DEC_NAME,\n\t\t\tsizeof(dev->mdev_dec.model));\n\n\t\tmedia_device_init(&dev->mdev_dec);\n\t\tdev->mdev_dec.ops = &mtk_vcodec_media_ops;\n\t\tdev->v4l2_dev.mdev = &dev->mdev_dec;\n\n\t\tret = v4l2_m2m_register_media_controller(dev->m2m_dev_dec, dev->vfd_dec,\n\t\t\t\t\t\t\t MEDIA_ENT_F_PROC_VIDEO_DECODER);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Failed to register media controller\");\n\t\t\tgoto err_dec_mem_init;\n\t\t}\n\n\t\tret = media_device_register(&dev->mdev_dec);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Failed to register media device\");\n\t\t\tgoto err_media_reg;\n\t\t}\n\n\t\tdev_dbg(&pdev->dev, \"media registered as /dev/media%d\", vfd_dec->minor);\n\t}\n\n\tmtk_vcodec_dbgfs_init(dev, false);\n\tdev_dbg(&pdev->dev, \"decoder registered as /dev/video%d\", vfd_dec->minor);\n\n\treturn 0;\n\nerr_media_reg:\n\tv4l2_m2m_unregister_media_controller(dev->m2m_dev_dec);\nerr_dec_mem_init:\n\tvideo_unregister_device(vfd_dec);\nerr_reg_cont:\n\tif (dev->vdec_pdata->uses_stateless_api)\n\t\tmedia_device_cleanup(&dev->mdev_dec);\n\tdestroy_workqueue(dev->decode_workqueue);\nerr_event_workq:\n\tv4l2_m2m_release(dev->m2m_dev_dec);\nerr_dec_alloc:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nerr_core_workq:\n\tif (IS_VDEC_LAT_ARCH(dev->vdec_pdata->hw_arch))\n\t\tdestroy_workqueue(dev->core_workqueue);\nerr_res:\n\tif (!dev->vdec_pdata->is_subdev_supported)\n\t\tpm_runtime_disable(dev->pm.dev);\nerr_dec_pm:\n\tmtk_vcodec_fw_release(dev->fw_handler);\n\treturn ret;\n}\n\nstatic const struct of_device_id mtk_vcodec_match[] = {\n\t{\n\t\t.compatible = \"mediatek,mt8173-vcodec-dec\",\n\t\t.data = &mtk_vdec_8173_pdata,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8183-vcodec-dec\",\n\t\t.data = &mtk_vdec_8183_pdata,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8192-vcodec-dec\",\n\t\t.data = &mtk_lat_sig_core_pdata,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8186-vcodec-dec\",\n\t\t.data = &mtk_vdec_single_core_pdata,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8195-vcodec-dec\",\n\t\t.data = &mtk_lat_sig_core_pdata,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8188-vcodec-dec\",\n\t\t.data = &mtk_lat_sig_core_pdata,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, mtk_vcodec_match);\n\nstatic void mtk_vcodec_dec_remove(struct platform_device *pdev)\n{\n\tstruct mtk_vcodec_dec_dev *dev = platform_get_drvdata(pdev);\n\n\tdestroy_workqueue(dev->decode_workqueue);\n\n\tif (media_devnode_is_registered(dev->mdev_dec.devnode)) {\n\t\tmedia_device_unregister(&dev->mdev_dec);\n\t\tv4l2_m2m_unregister_media_controller(dev->m2m_dev_dec);\n\t\tmedia_device_cleanup(&dev->mdev_dec);\n\t}\n\n\tif (dev->m2m_dev_dec)\n\t\tv4l2_m2m_release(dev->m2m_dev_dec);\n\n\tif (dev->vfd_dec)\n\t\tvideo_unregister_device(dev->vfd_dec);\n\n\tmtk_vcodec_dbgfs_deinit(&dev->dbgfs);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tif (!dev->vdec_pdata->is_subdev_supported)\n\t\tpm_runtime_disable(dev->pm.dev);\n\tmtk_vcodec_fw_release(dev->fw_handler);\n}\n\nstatic struct platform_driver mtk_vcodec_dec_driver = {\n\t.probe\t= mtk_vcodec_probe,\n\t.remove_new = mtk_vcodec_dec_remove,\n\t.driver\t= {\n\t\t.name\t= MTK_VCODEC_DEC_NAME,\n\t\t.of_match_table = mtk_vcodec_match,\n\t},\n};\n\nmodule_platform_driver(mtk_vcodec_dec_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Mediatek video codec V4L2 decoder driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}