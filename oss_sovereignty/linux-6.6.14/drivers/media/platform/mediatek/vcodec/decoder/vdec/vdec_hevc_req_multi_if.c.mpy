{
  "module_name": "vdec_hevc_req_multi_if.c",
  "hash_id": "a483b3ddf410eda98b801859346cfd7146965dc3f2df828974d9df0ed1d9aaaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_hevc_req_multi_if.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"../mtk_vcodec_dec.h\"\n#include \"../../common/mtk_vcodec_intr.h\"\n#include \"../vdec_drv_base.h\"\n#include \"../vdec_drv_if.h\"\n#include \"../vdec_vpu_if.h\"\n\n \n#define VDEC_HEVC_WRAP_SZ (532 * SZ_1K)\n\n#define HEVC_MAX_MV_NUM 32\n\n \n#define GET_HEVC_VDEC_FLAG(cond, flag) \\\n\t{ dst_param->cond = ((src_param->flags & (flag)) ? (1) : (0)); }\n#define GET_HEVC_VDEC_PARAM(param) \\\n\t{ dst_param->param = src_param->param; }\n\n \nenum vdec_hevc_core_dec_err_type {\n\tTRANS_BUFFER_FULL = 1,\n\tSLICE_HEADER_FULL,\n};\n\n \nstruct mtk_hevc_dpb_info {\n\tdma_addr_t y_dma_addr;\n\tdma_addr_t c_dma_addr;\n\tint reference_flag;\n\tint field;\n};\n\n \nstruct mtk_hevc_sps_param {\n\tunsigned char video_parameter_set_id;\n\tunsigned char seq_parameter_set_id;\n\tunsigned short pic_width_in_luma_samples;\n\tunsigned short pic_height_in_luma_samples;\n\tunsigned char bit_depth_luma_minus8;\n\tunsigned char bit_depth_chroma_minus8;\n\tunsigned char log2_max_pic_order_cnt_lsb_minus4;\n\tunsigned char sps_max_dec_pic_buffering_minus1;\n\tunsigned char sps_max_num_reorder_pics;\n\tunsigned char sps_max_latency_increase_plus1;\n\tunsigned char log2_min_luma_coding_block_size_minus3;\n\tunsigned char log2_diff_max_min_luma_coding_block_size;\n\tunsigned char log2_min_luma_transform_block_size_minus2;\n\tunsigned char log2_diff_max_min_luma_transform_block_size;\n\tunsigned char max_transform_hierarchy_depth_inter;\n\tunsigned char max_transform_hierarchy_depth_intra;\n\tunsigned char pcm_sample_bit_depth_luma_minus1;\n\tunsigned char pcm_sample_bit_depth_chroma_minus1;\n\tunsigned char log2_min_pcm_luma_coding_block_size_minus3;\n\tunsigned char log2_diff_max_min_pcm_luma_coding_block_size;\n\tunsigned char num_short_term_ref_pic_sets;\n\tunsigned char num_long_term_ref_pics_sps;\n\tunsigned char chroma_format_idc;\n\tunsigned char sps_max_sub_layers_minus1;\n\tunsigned char separate_colour_plane;\n\tunsigned char scaling_list_enabled;\n\tunsigned char amp_enabled;\n\tunsigned char sample_adaptive_offset;\n\tunsigned char pcm_enabled;\n\tunsigned char pcm_loop_filter_disabled;\n\tunsigned char long_term_ref_pics_enabled;\n\tunsigned char sps_temporal_mvp_enabled;\n\tunsigned char strong_intra_smoothing_enabled;\n\tunsigned char reserved[5];\n};\n\n \nstruct mtk_hevc_pps_param {\n\tunsigned char pic_parameter_set_id;\n\tunsigned char num_extra_slice_header_bits;\n\tunsigned char num_ref_idx_l0_default_active_minus1;\n\tunsigned char num_ref_idx_l1_default_active_minus1;\n\tchar init_qp_minus26;\n\tunsigned char diff_cu_qp_delta_depth;\n\tchar pps_cb_qp_offset;\n\tchar pps_cr_qp_offset;\n\tunsigned char num_tile_columns_minus1;\n\tunsigned char num_tile_rows_minus1;\n\tunsigned char column_width_minus1[20];\n\tunsigned char row_height_minus1[22];\n\tchar pps_beta_offset_div2;\n\tchar pps_tc_offset_div2;\n\tunsigned char log2_parallel_merge_level_minus2;\n\tchar dependent_slice_segment_enabled;\n\tchar output_flag_present;\n\tchar sign_data_hiding_enabled;\n\tchar cabac_init_present;\n\tchar constrained_intra_pred;\n\tchar transform_skip_enabled;\n\tchar cu_qp_delta_enabled;\n\tchar pps_slice_chroma_qp_offsets_present;\n\tchar weighted_pred;\n\tchar weighted_bipred;\n\tchar transquant_bypass_enabled;\n\tchar pps_flag_tiles_enabled;\n\tchar entropy_coding_sync_enabled;\n\tchar loop_filter_across_tiles_enabled;\n\tchar pps_loop_filter_across_slices_enabled;\n\tchar deblocking_filter_override_enabled;\n\tchar pps_disable_deflocking_filter;\n\tchar lists_modification_present;\n\tchar slice_segment_header_extersion_present;\n\tchar deblocking_filter_control_present;\n\tchar uniform_spacing;\n\tchar reserved[6];\n};\n\n \nstruct mtk_hevc_slice_header_param {\n\tunsigned int\tslice_type;\n\tunsigned int\tnum_active_ref_layer_pics;\n\tint\t\tslice_qp;\n\tint\t\tslice_qp_delta_cb;\n\tint\t\tslice_qp_delta_cr;\n\tint\t\tnum_ref_idx[3];\n\tunsigned int\tcol_ref_idx;\n\tunsigned int\tfive_minus_max_num_merge_cand;\n\tint\t\tslice_deblocking_filter_beta_offset_div2;\n\tint\t\tslice_deblocking_filter_tc_offset_div2;\n\tunsigned char\tsao_enable_flag;\n\tunsigned char\tsao_enable_flag_chroma;\n\tunsigned char\tcabac_init_flag;\n\tunsigned char\tslice_tmvp_flags_present;\n\tunsigned char\tcol_from_l0_flag;\n\tunsigned char\tmvd_l1_zero_flag;\n\tunsigned char\tslice_loop_filter_across_slices_enabled_flag;\n\tunsigned char\tdeblocking_filter_disable_flag;\n\tunsigned int\tslice_reg0;\n\tunsigned int\tslice_reg1;\n\tunsigned int\tslice_reg2;\n\tunsigned int\tnum_rps_curr_temp_list;\n\tunsigned int\tref_list_mode;\n\tint\t\tstr_num_delta_pocs;\n\tint\t\tstr_num_negtive_pos_pics;\n\tint\t\tnum_long_term;\n\tint\t\tnum_long_term_sps;\n\tunsigned int\tmax_cu_width;\n\tunsigned int\tmax_cu_height;\n\tunsigned int\tnum_entry_point_offsets;\n\tunsigned int    last_lcu_x_in_tile[17];\n\tunsigned int    last_lcu_y_in_tile[17];\n\tunsigned char   nal_unit_type;\n};\n\n \nstruct slice_api_hevc_scaling_matrix {\n\tunsigned char scaling_list_4x4[6][16];\n\tunsigned char scaling_list_8x8[6][64];\n\tunsigned char scaling_list_16x16[6][64];\n\tunsigned char scaling_list_32x32[2][64];\n\tunsigned char scaling_list_dc_coef_16x16[6];\n\tunsigned char scaling_list_dc_coef_32x32[2];\n};\n\n \nstruct slice_hevc_dpb_entry {\n\tu64 timestamp;\n\tunsigned char flags;\n\tunsigned char field_pic;\n\tint pic_order_cnt_val;\n};\n\n \nstruct slice_api_hevc_decode_param {\n\tstruct slice_hevc_dpb_entry dpb[V4L2_HEVC_DPB_ENTRIES_NUM_MAX];\n\tint pic_order_cnt_val;\n\tunsigned short short_term_ref_pic_set_size;\n\tunsigned short long_term_ref_pic_set_size;\n\tunsigned char num_active_dpb_entries;\n\tunsigned char num_poc_st_curr_before;\n\tunsigned char num_poc_st_curr_after;\n\tunsigned char num_poc_lt_curr;\n\tunsigned char poc_st_curr_before[V4L2_HEVC_DPB_ENTRIES_NUM_MAX];\n\tunsigned char poc_st_curr_after[V4L2_HEVC_DPB_ENTRIES_NUM_MAX];\n\tunsigned char poc_lt_curr[V4L2_HEVC_DPB_ENTRIES_NUM_MAX];\n\tunsigned char num_delta_pocs_of_ref_rps_idx;\n\tint flags;\n};\n\n \nstruct hevc_fb {\n\tu64 vdec_fb_va;\n\tu64 y_fb_dma;\n\tu64 c_fb_dma;\n\ts32 poc;\n\tu32 reserved;\n};\n\n \nstruct vdec_hevc_slice_lat_dec_param {\n\tstruct mtk_hevc_sps_param sps;\n\tstruct mtk_hevc_pps_param pps;\n\tstruct mtk_hevc_slice_header_param slice_header;\n\tstruct slice_api_hevc_scaling_matrix scaling_matrix;\n\tstruct slice_api_hevc_decode_param decode_params;\n\tstruct mtk_hevc_dpb_info hevc_dpb_info[V4L2_HEVC_DPB_ENTRIES_NUM_MAX];\n};\n\n \nstruct vdec_hevc_slice_info {\n\tu64 wdma_end_addr_offset;\n\tu64 timeout;\n\tu64 vdec_fb_va;\n\tu32 crc[8];\n};\n\n \nstruct vdec_hevc_slice_mem {\n\tunion {\n\t\tu64 buf;\n\t\tdma_addr_t dma_addr;\n\t};\n\tunion {\n\t\tsize_t size;\n\t\tdma_addr_t dma_addr_end;\n\t\tu64 padding;\n\t};\n};\n\n \nstruct vdec_hevc_slice_fb {\n\tstruct vdec_hevc_slice_mem y;\n\tstruct vdec_hevc_slice_mem c;\n};\n\n \nstruct vdec_hevc_slice_vsi {\n\t \n\tstruct vdec_hevc_slice_mem bs;\n\n\tstruct vdec_hevc_slice_mem ube;\n\tstruct vdec_hevc_slice_mem trans;\n\tstruct vdec_hevc_slice_mem err_map;\n\tstruct vdec_hevc_slice_mem slice_bc;\n\tstruct vdec_hevc_slice_mem wrap;\n\n\tstruct vdec_hevc_slice_fb fb;\n\tstruct vdec_hevc_slice_mem mv_buf_dma[HEVC_MAX_MV_NUM];\n\tstruct vdec_hevc_slice_info dec;\n\tstruct vdec_hevc_slice_lat_dec_param hevc_slice_params;\n};\n\n \nstruct vdec_hevc_slice_share_info {\n\tstruct v4l2_ctrl_hevc_sps sps;\n\tstruct v4l2_ctrl_hevc_decode_params dec_params;\n\tstruct vdec_hevc_slice_lat_dec_param hevc_slice_params;\n\tstruct vdec_hevc_slice_mem trans;\n};\n\n \nstruct vdec_hevc_slice_inst {\n\tunsigned int slice_dec_num;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct mtk_vcodec_mem mv_buf[HEVC_MAX_MV_NUM];\n\tstruct vdec_vpu_inst vpu;\n\tstruct vdec_hevc_slice_vsi *vsi;\n\tstruct vdec_hevc_slice_vsi *vsi_core;\n\tstruct mtk_vcodec_mem wrap_addr;\n\n\tstruct vdec_hevc_slice_lat_dec_param hevc_slice_param;\n\n\tunsigned int resolution_changed;\n\tunsigned int realloc_mv_buf;\n\tunsigned int cap_num_planes;\n};\n\nstatic unsigned int vdec_hevc_get_mv_buf_size(unsigned int width, unsigned int height)\n{\n\tconst unsigned int unit_size = (width / 16) * (height / 16) + 8;\n\n\treturn 64 * unit_size;\n}\n\nstatic void *vdec_hevc_get_ctrl_ptr(struct mtk_vcodec_dec_ctx *ctx, int id)\n{\n\tstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(&ctx->ctrl_hdl, id);\n\n\tif (!ctrl)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn ctrl->p_cur.p;\n}\n\nstatic void vdec_hevc_fill_dpb_info(struct mtk_vcodec_dec_ctx *ctx,\n\t\t\t\t    struct slice_api_hevc_decode_param *decode_params,\n\t\t\t\t    struct mtk_hevc_dpb_info *hevc_dpb_info)\n{\n\tconst struct slice_hevc_dpb_entry *dpb;\n\tstruct vb2_queue *vq;\n\tstruct vb2_buffer *vb;\n\tint index;\n\n\tvq = v4l2_m2m_get_vq(ctx->m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tfor (index = 0; index < V4L2_HEVC_DPB_ENTRIES_NUM_MAX; index++) {\n\t\tdpb = &decode_params->dpb[index];\n\t\tif (index >= decode_params->num_active_dpb_entries)\n\t\t\tcontinue;\n\n\t\tvb = vb2_find_buffer(vq, dpb->timestamp);\n\t\tif (!vb) {\n\t\t\tdev_err(&ctx->dev->plat_dev->dev,\n\t\t\t\t\"Reference invalid: dpb_index(%d) timestamp(%lld)\",\n\t\t\t\tindex, dpb->timestamp);\n\t\t\tcontinue;\n\t\t}\n\n\t\thevc_dpb_info[index].field = dpb->field_pic;\n\n\t\thevc_dpb_info[index].y_dma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\t\tif (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 2)\n\t\t\thevc_dpb_info[index].c_dma_addr = vb2_dma_contig_plane_dma_addr(vb, 1);\n\t\telse\n\t\t\thevc_dpb_info[index].c_dma_addr =\n\t\t\t\thevc_dpb_info[index].y_dma_addr + ctx->picinfo.fb_sz[0];\n\t}\n}\n\nstatic void vdec_hevc_copy_sps_params(struct mtk_hevc_sps_param *dst_param,\n\t\t\t\t      const struct v4l2_ctrl_hevc_sps *src_param)\n{\n\tGET_HEVC_VDEC_PARAM(video_parameter_set_id);\n\tGET_HEVC_VDEC_PARAM(seq_parameter_set_id);\n\tGET_HEVC_VDEC_PARAM(pic_width_in_luma_samples);\n\tGET_HEVC_VDEC_PARAM(pic_height_in_luma_samples);\n\tGET_HEVC_VDEC_PARAM(bit_depth_luma_minus8);\n\tGET_HEVC_VDEC_PARAM(bit_depth_chroma_minus8);\n\tGET_HEVC_VDEC_PARAM(log2_max_pic_order_cnt_lsb_minus4);\n\tGET_HEVC_VDEC_PARAM(sps_max_dec_pic_buffering_minus1);\n\tGET_HEVC_VDEC_PARAM(sps_max_num_reorder_pics);\n\tGET_HEVC_VDEC_PARAM(sps_max_latency_increase_plus1);\n\tGET_HEVC_VDEC_PARAM(log2_min_luma_coding_block_size_minus3);\n\tGET_HEVC_VDEC_PARAM(log2_diff_max_min_luma_coding_block_size);\n\tGET_HEVC_VDEC_PARAM(log2_min_luma_transform_block_size_minus2);\n\tGET_HEVC_VDEC_PARAM(log2_diff_max_min_luma_transform_block_size);\n\tGET_HEVC_VDEC_PARAM(max_transform_hierarchy_depth_inter);\n\tGET_HEVC_VDEC_PARAM(max_transform_hierarchy_depth_intra);\n\tGET_HEVC_VDEC_PARAM(pcm_sample_bit_depth_luma_minus1);\n\tGET_HEVC_VDEC_PARAM(pcm_sample_bit_depth_chroma_minus1);\n\tGET_HEVC_VDEC_PARAM(log2_min_pcm_luma_coding_block_size_minus3);\n\tGET_HEVC_VDEC_PARAM(log2_diff_max_min_pcm_luma_coding_block_size);\n\tGET_HEVC_VDEC_PARAM(num_short_term_ref_pic_sets);\n\tGET_HEVC_VDEC_PARAM(num_long_term_ref_pics_sps);\n\tGET_HEVC_VDEC_PARAM(chroma_format_idc);\n\tGET_HEVC_VDEC_PARAM(sps_max_sub_layers_minus1);\n\n\tGET_HEVC_VDEC_FLAG(separate_colour_plane,\n\t\t\t   V4L2_HEVC_SPS_FLAG_SEPARATE_COLOUR_PLANE);\n\tGET_HEVC_VDEC_FLAG(scaling_list_enabled,\n\t\t\t   V4L2_HEVC_SPS_FLAG_SCALING_LIST_ENABLED);\n\tGET_HEVC_VDEC_FLAG(amp_enabled,\n\t\t\t   V4L2_HEVC_SPS_FLAG_AMP_ENABLED);\n\tGET_HEVC_VDEC_FLAG(sample_adaptive_offset,\n\t\t\t   V4L2_HEVC_SPS_FLAG_SAMPLE_ADAPTIVE_OFFSET);\n\tGET_HEVC_VDEC_FLAG(pcm_enabled,\n\t\t\t   V4L2_HEVC_SPS_FLAG_PCM_ENABLED);\n\tGET_HEVC_VDEC_FLAG(pcm_loop_filter_disabled,\n\t\t\t   V4L2_HEVC_SPS_FLAG_PCM_LOOP_FILTER_DISABLED);\n\tGET_HEVC_VDEC_FLAG(long_term_ref_pics_enabled,\n\t\t\t   V4L2_HEVC_SPS_FLAG_LONG_TERM_REF_PICS_PRESENT);\n\tGET_HEVC_VDEC_FLAG(sps_temporal_mvp_enabled,\n\t\t\t   V4L2_HEVC_SPS_FLAG_SPS_TEMPORAL_MVP_ENABLED);\n\tGET_HEVC_VDEC_FLAG(strong_intra_smoothing_enabled,\n\t\t\t   V4L2_HEVC_SPS_FLAG_STRONG_INTRA_SMOOTHING_ENABLED);\n}\n\nstatic void vdec_hevc_copy_pps_params(struct mtk_hevc_pps_param *dst_param,\n\t\t\t\t      const struct v4l2_ctrl_hevc_pps *src_param)\n{\n\tint i;\n\n\tGET_HEVC_VDEC_PARAM(pic_parameter_set_id);\n\tGET_HEVC_VDEC_PARAM(num_extra_slice_header_bits);\n\tGET_HEVC_VDEC_PARAM(num_ref_idx_l0_default_active_minus1);\n\tGET_HEVC_VDEC_PARAM(num_ref_idx_l1_default_active_minus1);\n\tGET_HEVC_VDEC_PARAM(init_qp_minus26);\n\tGET_HEVC_VDEC_PARAM(diff_cu_qp_delta_depth);\n\tGET_HEVC_VDEC_PARAM(pps_cb_qp_offset);\n\tGET_HEVC_VDEC_PARAM(pps_cr_qp_offset);\n\tGET_HEVC_VDEC_PARAM(num_tile_columns_minus1);\n\tGET_HEVC_VDEC_PARAM(num_tile_rows_minus1);\n\tGET_HEVC_VDEC_PARAM(init_qp_minus26);\n\tGET_HEVC_VDEC_PARAM(diff_cu_qp_delta_depth);\n\tGET_HEVC_VDEC_PARAM(pic_parameter_set_id);\n\tGET_HEVC_VDEC_PARAM(num_extra_slice_header_bits);\n\tGET_HEVC_VDEC_PARAM(num_ref_idx_l0_default_active_minus1);\n\tGET_HEVC_VDEC_PARAM(num_ref_idx_l1_default_active_minus1);\n\tGET_HEVC_VDEC_PARAM(pps_beta_offset_div2);\n\tGET_HEVC_VDEC_PARAM(pps_tc_offset_div2);\n\tGET_HEVC_VDEC_PARAM(log2_parallel_merge_level_minus2);\n\n\tfor (i = 0; i < ARRAY_SIZE(src_param->column_width_minus1); i++)\n\t\tGET_HEVC_VDEC_PARAM(column_width_minus1[i]);\n\tfor (i = 0; i < ARRAY_SIZE(src_param->row_height_minus1); i++)\n\t\tGET_HEVC_VDEC_PARAM(row_height_minus1[i]);\n\n\tGET_HEVC_VDEC_FLAG(dependent_slice_segment_enabled,\n\t\t\t   V4L2_HEVC_PPS_FLAG_DEPENDENT_SLICE_SEGMENT_ENABLED);\n\tGET_HEVC_VDEC_FLAG(output_flag_present,\n\t\t\t   V4L2_HEVC_PPS_FLAG_OUTPUT_FLAG_PRESENT);\n\tGET_HEVC_VDEC_FLAG(sign_data_hiding_enabled,\n\t\t\t   V4L2_HEVC_PPS_FLAG_SIGN_DATA_HIDING_ENABLED);\n\tGET_HEVC_VDEC_FLAG(cabac_init_present,\n\t\t\t   V4L2_HEVC_PPS_FLAG_CABAC_INIT_PRESENT);\n\tGET_HEVC_VDEC_FLAG(constrained_intra_pred,\n\t\t\t   V4L2_HEVC_PPS_FLAG_CONSTRAINED_INTRA_PRED);\n\tGET_HEVC_VDEC_FLAG(transform_skip_enabled,\n\t\t\t   V4L2_HEVC_PPS_FLAG_TRANSFORM_SKIP_ENABLED);\n\tGET_HEVC_VDEC_FLAG(cu_qp_delta_enabled,\n\t\t\t   V4L2_HEVC_PPS_FLAG_CU_QP_DELTA_ENABLED);\n\tGET_HEVC_VDEC_FLAG(pps_slice_chroma_qp_offsets_present,\n\t\t\t   V4L2_HEVC_PPS_FLAG_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT);\n\tGET_HEVC_VDEC_FLAG(weighted_pred,\n\t\t\t   V4L2_HEVC_PPS_FLAG_WEIGHTED_PRED);\n\tGET_HEVC_VDEC_FLAG(weighted_bipred,\n\t\t\t   V4L2_HEVC_PPS_FLAG_WEIGHTED_BIPRED);\n\tGET_HEVC_VDEC_FLAG(transquant_bypass_enabled,\n\t\t\t   V4L2_HEVC_PPS_FLAG_TRANSQUANT_BYPASS_ENABLED);\n\tGET_HEVC_VDEC_FLAG(pps_flag_tiles_enabled,\n\t\t\t   V4L2_HEVC_PPS_FLAG_TILES_ENABLED);\n\tGET_HEVC_VDEC_FLAG(entropy_coding_sync_enabled,\n\t\t\t   V4L2_HEVC_PPS_FLAG_ENTROPY_CODING_SYNC_ENABLED);\n\tGET_HEVC_VDEC_FLAG(loop_filter_across_tiles_enabled,\n\t\t\t   V4L2_HEVC_PPS_FLAG_LOOP_FILTER_ACROSS_TILES_ENABLED);\n\tGET_HEVC_VDEC_FLAG(pps_loop_filter_across_slices_enabled,\n\t\t\t   V4L2_HEVC_PPS_FLAG_PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED);\n\tGET_HEVC_VDEC_FLAG(deblocking_filter_override_enabled,\n\t\t\t   V4L2_HEVC_PPS_FLAG_DEBLOCKING_FILTER_OVERRIDE_ENABLED);\n\tGET_HEVC_VDEC_FLAG(pps_disable_deflocking_filter,\n\t\t\t   V4L2_HEVC_PPS_FLAG_PPS_DISABLE_DEBLOCKING_FILTER);\n\tGET_HEVC_VDEC_FLAG(lists_modification_present,\n\t\t\t   V4L2_HEVC_PPS_FLAG_LISTS_MODIFICATION_PRESENT);\n\tGET_HEVC_VDEC_FLAG(slice_segment_header_extersion_present,\n\t\t\t   V4L2_HEVC_PPS_FLAG_SLICE_SEGMENT_HEADER_EXTENSION_PRESENT);\n\tGET_HEVC_VDEC_FLAG(deblocking_filter_control_present,\n\t\t\t   V4L2_HEVC_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT);\n\tGET_HEVC_VDEC_FLAG(uniform_spacing,\n\t\t\t   V4L2_HEVC_PPS_FLAG_UNIFORM_SPACING);\n}\n\nstatic void vdec_hevc_copy_scaling_matrix(struct slice_api_hevc_scaling_matrix *dst_matrix,\n\t\t\t\t\t  const struct v4l2_ctrl_hevc_scaling_matrix *src_matrix)\n{\n\tmemcpy(dst_matrix, src_matrix, sizeof(*src_matrix));\n}\n\nstatic void\nvdec_hevc_copy_decode_params(struct slice_api_hevc_decode_param *dst_param,\n\t\t\t     const struct v4l2_ctrl_hevc_decode_params *src_param,\n\t\t\t     const struct v4l2_hevc_dpb_entry dpb[V4L2_HEVC_DPB_ENTRIES_NUM_MAX])\n{\n\tstruct slice_hevc_dpb_entry *dst_entry;\n\tconst struct v4l2_hevc_dpb_entry *src_entry;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dst_param->dpb); i++) {\n\t\tdst_entry = &dst_param->dpb[i];\n\t\tsrc_entry = &dpb[i];\n\n\t\tdst_entry->timestamp = src_entry->timestamp;\n\t\tdst_entry->flags = src_entry->flags;\n\t\tdst_entry->field_pic = src_entry->field_pic;\n\t\tdst_entry->pic_order_cnt_val = src_entry->pic_order_cnt_val;\n\n\t\tGET_HEVC_VDEC_PARAM(poc_st_curr_before[i]);\n\t\tGET_HEVC_VDEC_PARAM(poc_st_curr_after[i]);\n\t\tGET_HEVC_VDEC_PARAM(poc_lt_curr[i]);\n\t}\n\n\tGET_HEVC_VDEC_PARAM(pic_order_cnt_val);\n\tGET_HEVC_VDEC_PARAM(short_term_ref_pic_set_size);\n\tGET_HEVC_VDEC_PARAM(long_term_ref_pic_set_size);\n\tGET_HEVC_VDEC_PARAM(num_active_dpb_entries);\n\tGET_HEVC_VDEC_PARAM(num_poc_st_curr_before);\n\tGET_HEVC_VDEC_PARAM(num_poc_st_curr_after);\n\tGET_HEVC_VDEC_PARAM(num_delta_pocs_of_ref_rps_idx);\n\tGET_HEVC_VDEC_PARAM(num_poc_lt_curr);\n\tGET_HEVC_VDEC_PARAM(flags);\n}\n\nstatic int vdec_hevc_slice_fill_decode_parameters(struct vdec_hevc_slice_inst *inst,\n\t\t\t\t\t\t  struct vdec_hevc_slice_share_info *share_info)\n{\n\tstruct vdec_hevc_slice_lat_dec_param *slice_param = &inst->vsi->hevc_slice_params;\n\tconst struct v4l2_ctrl_hevc_decode_params *dec_params;\n\tconst struct v4l2_ctrl_hevc_scaling_matrix *src_matrix;\n\tconst struct v4l2_ctrl_hevc_sps *sps;\n\tconst struct v4l2_ctrl_hevc_pps *pps;\n\n\tdec_params =\n\t\tvdec_hevc_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_HEVC_DECODE_PARAMS);\n\tif (IS_ERR(dec_params))\n\t\treturn PTR_ERR(dec_params);\n\n\tsrc_matrix =\n\t\tvdec_hevc_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_HEVC_SCALING_MATRIX);\n\tif (IS_ERR(src_matrix))\n\t\treturn PTR_ERR(src_matrix);\n\n\tsps = vdec_hevc_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_HEVC_SPS);\n\tif (IS_ERR(sps))\n\t\treturn PTR_ERR(sps);\n\n\tpps = vdec_hevc_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_HEVC_PPS);\n\tif (IS_ERR(pps))\n\t\treturn PTR_ERR(pps);\n\n\tvdec_hevc_copy_sps_params(&slice_param->sps, sps);\n\tvdec_hevc_copy_pps_params(&slice_param->pps, pps);\n\tvdec_hevc_copy_scaling_matrix(&slice_param->scaling_matrix, src_matrix);\n\n\tmemcpy(&share_info->sps, sps, sizeof(*sps));\n\tmemcpy(&share_info->dec_params, dec_params, sizeof(*dec_params));\n\n\tslice_param->decode_params.num_poc_st_curr_before = dec_params->num_poc_st_curr_before;\n\tslice_param->decode_params.num_poc_st_curr_after = dec_params->num_poc_st_curr_after;\n\tslice_param->decode_params.num_poc_lt_curr = dec_params->num_poc_lt_curr;\n\tslice_param->decode_params.num_delta_pocs_of_ref_rps_idx =\n\t\tdec_params->num_delta_pocs_of_ref_rps_idx;\n\n\treturn 0;\n}\n\nstatic void vdec_hevc_slice_fill_decode_reflist(struct vdec_hevc_slice_inst *inst,\n\t\t\t\t\t\tstruct vdec_hevc_slice_lat_dec_param *slice_param,\n\t\t\t\t\t\tstruct vdec_hevc_slice_share_info *share_info)\n{\n\tstruct v4l2_ctrl_hevc_decode_params *dec_params = &share_info->dec_params;\n\n\tvdec_hevc_copy_decode_params(&slice_param->decode_params, dec_params,\n\t\t\t\t     share_info->dec_params.dpb);\n\n\tvdec_hevc_fill_dpb_info(inst->ctx, &slice_param->decode_params,\n\t\t\t\tslice_param->hevc_dpb_info);\n}\n\nstatic int vdec_hevc_slice_alloc_mv_buf(struct vdec_hevc_slice_inst *inst,\n\t\t\t\t\tstruct vdec_pic_info *pic)\n{\n\tunsigned int buf_sz = vdec_hevc_get_mv_buf_size(pic->buf_w, pic->buf_h);\n\tstruct mtk_vcodec_mem *mem;\n\tint i, err;\n\n\tmtk_v4l2_vdec_dbg(3, inst->ctx, \"allocate mv buffer size = 0x%x\", buf_sz);\n\tfor (i = 0; i < HEVC_MAX_MV_NUM; i++) {\n\t\tmem = &inst->mv_buf[i];\n\t\tif (mem->va)\n\t\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\t\tmem->size = buf_sz;\n\t\terr = mtk_vcodec_mem_alloc(inst->ctx, mem);\n\t\tif (err) {\n\t\t\tmtk_vdec_err(inst->ctx, \"failed to allocate mv buf\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void vdec_hevc_slice_free_mv_buf(struct vdec_hevc_slice_inst *inst)\n{\n\tint i;\n\tstruct mtk_vcodec_mem *mem;\n\n\tfor (i = 0; i < HEVC_MAX_MV_NUM; i++) {\n\t\tmem = &inst->mv_buf[i];\n\t\tif (mem->va)\n\t\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\t}\n}\n\nstatic void vdec_hevc_slice_get_pic_info(struct vdec_hevc_slice_inst *inst)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = inst->ctx;\n\tu32 data[3];\n\n\tdata[0] = ctx->picinfo.pic_w;\n\tdata[1] = ctx->picinfo.pic_h;\n\tdata[2] = ctx->capture_fourcc;\n\tvpu_dec_get_param(&inst->vpu, data, 3, GET_PARAM_PIC_INFO);\n\n\tctx->picinfo.buf_w = ALIGN(ctx->picinfo.pic_w, VCODEC_DEC_ALIGNED_64);\n\tctx->picinfo.buf_h = ALIGN(ctx->picinfo.pic_h, VCODEC_DEC_ALIGNED_64);\n\tctx->picinfo.fb_sz[0] = inst->vpu.fb_sz[0];\n\tctx->picinfo.fb_sz[1] = inst->vpu.fb_sz[1];\n\tinst->cap_num_planes =\n\t\tctx->q_data[MTK_Q_DATA_DST].fmt->num_planes;\n\n\tmtk_vdec_debug(ctx, \"pic(%d, %d), buf(%d, %d)\",\n\t\t       ctx->picinfo.pic_w, ctx->picinfo.pic_h,\n\t\t       ctx->picinfo.buf_w, ctx->picinfo.buf_h);\n\tmtk_vdec_debug(ctx, \"Y/C(%d, %d)\", ctx->picinfo.fb_sz[0],\n\t\t       ctx->picinfo.fb_sz[1]);\n\n\tif (ctx->last_decoded_picinfo.pic_w != ctx->picinfo.pic_w ||\n\t    ctx->last_decoded_picinfo.pic_h != ctx->picinfo.pic_h) {\n\t\tinst->resolution_changed = true;\n\t\tif (ctx->last_decoded_picinfo.buf_w != ctx->picinfo.buf_w ||\n\t\t    ctx->last_decoded_picinfo.buf_h != ctx->picinfo.buf_h)\n\t\t\tinst->realloc_mv_buf = true;\n\n\t\tmtk_v4l2_vdec_dbg(1, inst->ctx, \"resChg: (%d %d) : old(%d, %d) -> new(%d, %d)\",\n\t\t\t\t  inst->resolution_changed,\n\t\t\t\t  inst->realloc_mv_buf,\n\t\t\t\t  ctx->last_decoded_picinfo.pic_w,\n\t\t\t\t  ctx->last_decoded_picinfo.pic_h,\n\t\t\t\t  ctx->picinfo.pic_w, ctx->picinfo.pic_h);\n\t}\n}\n\nstatic void vdec_hevc_slice_get_crop_info(struct vdec_hevc_slice_inst *inst,\n\t\t\t\t\t  struct v4l2_rect *cr)\n{\n\tcr->left = 0;\n\tcr->top = 0;\n\tcr->width = inst->ctx->picinfo.pic_w;\n\tcr->height = inst->ctx->picinfo.pic_h;\n\n\tmtk_vdec_debug(inst->ctx, \"l=%d, t=%d, w=%d, h=%d\",\n\t\t       cr->left, cr->top, cr->width, cr->height);\n}\n\nstatic int vdec_hevc_slice_setup_lat_buffer(struct vdec_hevc_slice_inst *inst,\n\t\t\t\t\t    struct mtk_vcodec_mem *bs,\n\t\t\t\t\t    struct vdec_lat_buf *lat_buf,\n\t\t\t\t\t    bool *res_chg)\n{\n\tstruct mtk_vcodec_mem *mem;\n\tstruct mtk_video_dec_buf *src_buf_info;\n\tstruct vdec_hevc_slice_share_info *share_info;\n\tint i, err;\n\n\tinst->vsi->bs.dma_addr = (u64)bs->dma_addr;\n\tinst->vsi->bs.size = bs->size;\n\n\tsrc_buf_info = container_of(bs, struct mtk_video_dec_buf, bs_buffer);\n\tlat_buf->src_buf_req = src_buf_info->m2m_buf.vb.vb2_buf.req_obj.req;\n\tv4l2_m2m_buf_copy_metadata(&src_buf_info->m2m_buf.vb, &lat_buf->ts_info, true);\n\n\t*res_chg = inst->resolution_changed;\n\tif (inst->resolution_changed) {\n\t\tmtk_vdec_debug(inst->ctx, \"- resolution changed -\");\n\t\tif (inst->realloc_mv_buf) {\n\t\t\terr = vdec_hevc_slice_alloc_mv_buf(inst, &inst->ctx->picinfo);\n\t\t\tinst->realloc_mv_buf = false;\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tinst->resolution_changed = false;\n\t}\n\n\tfor (i = 0; i < HEVC_MAX_MV_NUM; i++) {\n\t\tmem = &inst->mv_buf[i];\n\t\tinst->vsi->mv_buf_dma[i].dma_addr = mem->dma_addr;\n\t\tinst->vsi->mv_buf_dma[i].size = mem->size;\n\t}\n\n\tinst->vsi->ube.dma_addr = lat_buf->ctx->msg_queue.wdma_addr.dma_addr;\n\tinst->vsi->ube.size = lat_buf->ctx->msg_queue.wdma_addr.size;\n\n\tinst->vsi->err_map.dma_addr = lat_buf->wdma_err_addr.dma_addr;\n\tinst->vsi->err_map.size = lat_buf->wdma_err_addr.size;\n\n\tinst->vsi->slice_bc.dma_addr = lat_buf->slice_bc_addr.dma_addr;\n\tinst->vsi->slice_bc.size = lat_buf->slice_bc_addr.size;\n\n\tinst->vsi->trans.dma_addr_end = inst->ctx->msg_queue.wdma_rptr_addr;\n\tinst->vsi->trans.dma_addr = inst->ctx->msg_queue.wdma_wptr_addr;\n\n\tshare_info = lat_buf->private_data;\n\tshare_info->trans.dma_addr = inst->vsi->trans.dma_addr;\n\tshare_info->trans.dma_addr_end = inst->vsi->trans.dma_addr_end;\n\n\tmtk_vdec_debug(inst->ctx, \"lat: ube addr/size(0x%llx 0x%llx) err:0x%llx\",\n\t\t       inst->vsi->ube.buf,\n\t\t       inst->vsi->ube.padding,\n\t\t       inst->vsi->err_map.buf);\n\n\tmtk_vdec_debug(inst->ctx, \"slice addr/size(0x%llx 0x%llx) trans start/end((0x%llx 0x%llx))\",\n\t\t       inst->vsi->slice_bc.buf,\n\t\t       inst->vsi->slice_bc.padding,\n\t\t       inst->vsi->trans.buf,\n\t\t       inst->vsi->trans.padding);\n\n\treturn 0;\n}\n\nstatic int vdec_hevc_slice_setup_core_buffer(struct vdec_hevc_slice_inst *inst,\n\t\t\t\t\t     struct vdec_hevc_slice_share_info *share_info,\n\t\t\t\t\t     struct vdec_lat_buf *lat_buf)\n{\n\tstruct mtk_vcodec_mem *mem;\n\tstruct mtk_vcodec_dec_ctx *ctx = inst->ctx;\n\tstruct vb2_v4l2_buffer *vb2_v4l2;\n\tstruct vdec_fb *fb;\n\tu64 y_fb_dma, c_fb_dma;\n\tint i;\n\n\tfb = ctx->dev->vdec_pdata->get_cap_buffer(ctx);\n\tif (!fb) {\n\t\tmtk_vdec_err(inst->ctx, \"fb buffer is NULL\");\n\t\treturn -EBUSY;\n\t}\n\n\ty_fb_dma = (u64)fb->base_y.dma_addr;\n\tif (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 1)\n\t\tc_fb_dma =\n\t\t\ty_fb_dma + inst->ctx->picinfo.buf_w * inst->ctx->picinfo.buf_h;\n\telse\n\t\tc_fb_dma = (u64)fb->base_c.dma_addr;\n\n\tmtk_vdec_debug(inst->ctx, \"[hevc-core] y/c addr = 0x%llx 0x%llx\", y_fb_dma, c_fb_dma);\n\n\tinst->vsi_core->fb.y.dma_addr = y_fb_dma;\n\tinst->vsi_core->fb.y.size = ctx->picinfo.fb_sz[0];\n\tinst->vsi_core->fb.c.dma_addr = c_fb_dma;\n\tinst->vsi_core->fb.y.size = ctx->picinfo.fb_sz[1];\n\n\tinst->vsi_core->dec.vdec_fb_va = (unsigned long)fb;\n\n\tinst->vsi_core->ube.dma_addr = lat_buf->ctx->msg_queue.wdma_addr.dma_addr;\n\tinst->vsi_core->ube.size = lat_buf->ctx->msg_queue.wdma_addr.size;\n\n\tinst->vsi_core->err_map.dma_addr = lat_buf->wdma_err_addr.dma_addr;\n\tinst->vsi_core->err_map.size = lat_buf->wdma_err_addr.size;\n\n\tinst->vsi_core->slice_bc.dma_addr = lat_buf->slice_bc_addr.dma_addr;\n\tinst->vsi_core->slice_bc.size = lat_buf->slice_bc_addr.size;\n\n\tinst->vsi_core->trans.dma_addr = share_info->trans.dma_addr;\n\tinst->vsi_core->trans.dma_addr_end = share_info->trans.dma_addr_end;\n\n\tinst->vsi_core->wrap.dma_addr = inst->wrap_addr.dma_addr;\n\tinst->vsi_core->wrap.size = inst->wrap_addr.size;\n\n\tfor (i = 0; i < HEVC_MAX_MV_NUM; i++) {\n\t\tmem = &inst->mv_buf[i];\n\t\tinst->vsi_core->mv_buf_dma[i].dma_addr = mem->dma_addr;\n\t\tinst->vsi_core->mv_buf_dma[i].size = mem->size;\n\t}\n\n\tvb2_v4l2 = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\n\tv4l2_m2m_buf_copy_metadata(&lat_buf->ts_info, vb2_v4l2, true);\n\n\treturn 0;\n}\n\nstatic int vdec_hevc_slice_init(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct vdec_hevc_slice_inst *inst;\n\tint err, vsi_size;\n\n\tinst = kzalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tinst->ctx = ctx;\n\n\tinst->vpu.id = SCP_IPI_VDEC_LAT;\n\tinst->vpu.core_id = SCP_IPI_VDEC_CORE;\n\tinst->vpu.ctx = ctx;\n\tinst->vpu.codec_type = ctx->current_codec;\n\tinst->vpu.capture_type = ctx->capture_fourcc;\n\n\tctx->drv_handle = inst;\n\terr = vpu_dec_init(&inst->vpu);\n\tif (err) {\n\t\tmtk_vdec_err(ctx, \"vdec_hevc init err=%d\", err);\n\t\tgoto error_free_inst;\n\t}\n\n\tvsi_size = round_up(sizeof(struct vdec_hevc_slice_vsi), VCODEC_DEC_ALIGNED_64);\n\tinst->vsi = inst->vpu.vsi;\n\tinst->vsi_core =\n\t\t(struct vdec_hevc_slice_vsi *)(((char *)inst->vpu.vsi) + vsi_size);\n\n\tinst->resolution_changed = true;\n\tinst->realloc_mv_buf = true;\n\n\tinst->wrap_addr.size = VDEC_HEVC_WRAP_SZ;\n\terr = mtk_vcodec_mem_alloc(ctx, &inst->wrap_addr);\n\tif (err)\n\t\tgoto error_free_inst;\n\n\tmtk_vdec_debug(ctx, \"lat struct size = %d,%d,%d,%d vsi: %d\\n\",\n\t\t       (int)sizeof(struct mtk_hevc_sps_param),\n\t\t       (int)sizeof(struct mtk_hevc_pps_param),\n\t\t       (int)sizeof(struct vdec_hevc_slice_lat_dec_param),\n\t\t       (int)sizeof(struct mtk_hevc_dpb_info),\n\t\t\t vsi_size);\n\tmtk_vdec_debug(ctx, \"lat hevc instance >> %p, codec_type = 0x%x\",\n\t\t       inst, inst->vpu.codec_type);\n\n\treturn 0;\nerror_free_inst:\n\tkfree(inst);\n\treturn err;\n}\n\nstatic void vdec_hevc_slice_deinit(void *h_vdec)\n{\n\tstruct vdec_hevc_slice_inst *inst = h_vdec;\n\tstruct mtk_vcodec_mem *mem;\n\n\tvpu_dec_deinit(&inst->vpu);\n\tvdec_hevc_slice_free_mv_buf(inst);\n\n\tmem = &inst->wrap_addr;\n\tif (mem->va)\n\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\n\tvdec_msg_queue_deinit(&inst->ctx->msg_queue, inst->ctx);\n\tkfree(inst);\n}\n\nstatic int vdec_hevc_slice_core_decode(struct vdec_lat_buf *lat_buf)\n{\n\tint err, timeout;\n\tstruct mtk_vcodec_dec_ctx *ctx = lat_buf->ctx;\n\tstruct vdec_hevc_slice_inst *inst = ctx->drv_handle;\n\tstruct vdec_hevc_slice_share_info *share_info = lat_buf->private_data;\n\tstruct vdec_vpu_inst *vpu = &inst->vpu;\n\n\tmtk_vdec_debug(ctx, \"[hevc-core] vdec_hevc core decode\");\n\tmemcpy(&inst->vsi_core->hevc_slice_params, &share_info->hevc_slice_params,\n\t       sizeof(share_info->hevc_slice_params));\n\n\terr = vdec_hevc_slice_setup_core_buffer(inst, share_info, lat_buf);\n\tif (err)\n\t\tgoto vdec_dec_end;\n\n\tvdec_hevc_slice_fill_decode_reflist(inst, &inst->vsi_core->hevc_slice_params,\n\t\t\t\t\t    share_info);\n\terr = vpu_dec_core(vpu);\n\tif (err) {\n\t\tmtk_vdec_err(ctx, \"core decode err=%d\", err);\n\t\tgoto vdec_dec_end;\n\t}\n\n\t \n\ttimeout = mtk_vcodec_wait_for_done_ctx(inst->ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t       WAIT_INTR_TIMEOUT_MS, MTK_VDEC_CORE);\n\tif (timeout)\n\t\tmtk_vdec_err(ctx, \"core decode timeout: pic_%d\", ctx->decoded_frame_cnt);\n\tinst->vsi_core->dec.timeout = !!timeout;\n\n\tvpu_dec_core_end(vpu);\n\tmtk_vdec_debug(ctx, \"pic[%d] crc: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\",\n\t\t       ctx->decoded_frame_cnt,\n\t\t       inst->vsi_core->dec.crc[0], inst->vsi_core->dec.crc[1],\n\t\t       inst->vsi_core->dec.crc[2], inst->vsi_core->dec.crc[3],\n\t\t       inst->vsi_core->dec.crc[4], inst->vsi_core->dec.crc[5],\n\t\t       inst->vsi_core->dec.crc[6], inst->vsi_core->dec.crc[7]);\n\nvdec_dec_end:\n\tvdec_msg_queue_update_ube_rptr(&lat_buf->ctx->msg_queue, share_info->trans.dma_addr_end);\n\tctx->dev->vdec_pdata->cap_to_disp(ctx, !!err, lat_buf->src_buf_req);\n\tmtk_vdec_debug(ctx, \"core decode done err=%d\", err);\n\tctx->decoded_frame_cnt++;\n\treturn 0;\n}\n\nstatic int vdec_hevc_slice_lat_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t      struct vdec_fb *fb, bool *res_chg)\n{\n\tstruct vdec_hevc_slice_inst *inst = h_vdec;\n\tstruct vdec_vpu_inst *vpu = &inst->vpu;\n\tint err, timeout = 0;\n\tunsigned int data[2];\n\tstruct vdec_lat_buf *lat_buf;\n\tstruct vdec_hevc_slice_share_info *share_info;\n\n\tif (vdec_msg_queue_init(&inst->ctx->msg_queue, inst->ctx,\n\t\t\t\tvdec_hevc_slice_core_decode,\n\t\t\t\tsizeof(*share_info)))\n\t\treturn -ENOMEM;\n\n\t \n\tif (!bs) {\n\t\tvdec_msg_queue_wait_lat_buf_full(&inst->ctx->msg_queue);\n\t\treturn vpu_dec_reset(vpu);\n\t}\n\n\tlat_buf = vdec_msg_queue_dqbuf(&inst->ctx->msg_queue.lat_ctx);\n\tif (!lat_buf) {\n\t\tmtk_vdec_debug(inst->ctx, \"failed to get lat buffer\");\n\t\treturn -EAGAIN;\n\t}\n\n\tshare_info = lat_buf->private_data;\n\terr = vdec_hevc_slice_fill_decode_parameters(inst, share_info);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\terr = vdec_hevc_slice_setup_lat_buffer(inst, bs, lat_buf, res_chg);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\terr = vpu_dec_start(vpu, data, 2);\n\tif (err) {\n\t\tmtk_vdec_debug(inst->ctx, \"lat decode err: %d\", err);\n\t\tgoto err_free_fb_out;\n\t}\n\n\tif (IS_VDEC_INNER_RACING(inst->ctx->dev->dec_capability)) {\n\t\tmemcpy(&share_info->hevc_slice_params, &inst->vsi->hevc_slice_params,\n\t\t       sizeof(share_info->hevc_slice_params));\n\t\tvdec_msg_queue_qbuf(&inst->ctx->msg_queue.core_ctx, lat_buf);\n\t}\n\n\t \n\ttimeout = mtk_vcodec_wait_for_done_ctx(inst->ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t       WAIT_INTR_TIMEOUT_MS, MTK_VDEC_LAT0);\n\tif (timeout)\n\t\tmtk_vdec_err(inst->ctx, \"lat decode timeout: pic_%d\", inst->slice_dec_num);\n\tinst->vsi->dec.timeout = !!timeout;\n\n\terr = vpu_dec_end(vpu);\n\tif (err == SLICE_HEADER_FULL || err == TRANS_BUFFER_FULL) {\n\t\tif (!IS_VDEC_INNER_RACING(inst->ctx->dev->dec_capability))\n\t\t\tvdec_msg_queue_qbuf(&inst->ctx->msg_queue.lat_ctx, lat_buf);\n\t\tinst->slice_dec_num++;\n\t\tmtk_vdec_err(inst->ctx, \"lat dec fail: pic_%d err:%d\", inst->slice_dec_num, err);\n\t\treturn -EINVAL;\n\t}\n\n\tshare_info->trans.dma_addr_end = inst->ctx->msg_queue.wdma_addr.dma_addr +\n\t\tinst->vsi->dec.wdma_end_addr_offset;\n\tvdec_msg_queue_update_ube_wptr(&lat_buf->ctx->msg_queue, share_info->trans.dma_addr_end);\n\n\tif (!IS_VDEC_INNER_RACING(inst->ctx->dev->dec_capability)) {\n\t\tmemcpy(&share_info->hevc_slice_params, &inst->vsi->hevc_slice_params,\n\t\t       sizeof(share_info->hevc_slice_params));\n\t\tvdec_msg_queue_qbuf(&inst->ctx->msg_queue.core_ctx, lat_buf);\n\t}\n\tmtk_vdec_debug(inst->ctx, \"dec num: %d lat crc: 0x%x 0x%x 0x%x\", inst->slice_dec_num,\n\t\t       inst->vsi->dec.crc[0], inst->vsi->dec.crc[1], inst->vsi->dec.crc[2]);\n\n\tinst->slice_dec_num++;\n\treturn 0;\nerr_free_fb_out:\n\tvdec_msg_queue_qbuf(&inst->ctx->msg_queue.lat_ctx, lat_buf);\n\tmtk_vdec_err(inst->ctx, \"slice dec number: %d err: %d\", inst->slice_dec_num, err);\n\treturn err;\n}\n\nstatic int vdec_hevc_slice_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t  struct vdec_fb *unused, bool *res_chg)\n{\n\tstruct vdec_hevc_slice_inst *inst = h_vdec;\n\n\tif (!h_vdec || inst->ctx->dev->vdec_pdata->hw_arch == MTK_VDEC_PURE_SINGLE_CORE)\n\t\treturn -EINVAL;\n\n\treturn vdec_hevc_slice_lat_decode(h_vdec, bs, unused, res_chg);\n}\n\nstatic int vdec_hevc_slice_get_param(void *h_vdec, enum vdec_get_param_type type,\n\t\t\t\t     void *out)\n{\n\tstruct vdec_hevc_slice_inst *inst = h_vdec;\n\n\tswitch (type) {\n\tcase GET_PARAM_PIC_INFO:\n\t\tvdec_hevc_slice_get_pic_info(inst);\n\t\tbreak;\n\tcase GET_PARAM_DPB_SIZE:\n\t\t*(unsigned int *)out = 6;\n\t\tbreak;\n\tcase GET_PARAM_CROP_INFO:\n\t\tvdec_hevc_slice_get_crop_info(inst, out);\n\t\tbreak;\n\tdefault:\n\t\tmtk_vdec_err(inst->ctx, \"invalid get parameter type=%d\", type);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nconst struct vdec_common_if vdec_hevc_slice_multi_if = {\n\t.init\t\t= vdec_hevc_slice_init,\n\t.decode\t\t= vdec_hevc_slice_decode,\n\t.get_param\t= vdec_hevc_slice_get_param,\n\t.deinit\t\t= vdec_hevc_slice_deinit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}