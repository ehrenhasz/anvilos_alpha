{
  "module_name": "mtk_vcodec_dec.c",
  "hash_id": "94e017ccbd5660f078c95ef8340f722ba31a51da4224fcb9398999aa383c1fbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/mtk_vcodec_dec.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"mtk_vcodec_dec_drv.h\"\n#include \"mtk_vcodec_dec.h\"\n#include \"vdec_drv_if.h\"\n#include \"mtk_vcodec_dec_pm.h\"\n\n#define DFT_CFG_WIDTH\tMTK_VDEC_MIN_W\n#define DFT_CFG_HEIGHT\tMTK_VDEC_MIN_H\n\nstatic const struct mtk_video_fmt *\nmtk_vdec_find_format(struct v4l2_format *f,\n\t\t     const struct mtk_vcodec_dec_pdata *dec_pdata)\n{\n\tconst struct mtk_video_fmt *fmt;\n\tunsigned int k;\n\n\tfor (k = 0; k < *dec_pdata->num_formats; k++) {\n\t\tfmt = &dec_pdata->vdec_formats[k];\n\t\tif (fmt->fourcc == f->fmt.pix_mp.pixelformat)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool mtk_vdec_get_cap_fmt(struct mtk_vcodec_dec_ctx *ctx, int format_index)\n{\n\tconst struct mtk_vcodec_dec_pdata *dec_pdata = ctx->dev->vdec_pdata;\n\tconst struct mtk_video_fmt *fmt;\n\tstruct mtk_q_data *q_data;\n\tint num_frame_count = 0, i;\n\tbool ret = false;\n\n\tfmt = &dec_pdata->vdec_formats[format_index];\n\tfor (i = 0; i < *dec_pdata->num_formats; i++) {\n\t\tif (dec_pdata->vdec_formats[i].type != MTK_FMT_FRAME)\n\t\t\tcontinue;\n\n\t\tnum_frame_count++;\n\t}\n\n\tif (num_frame_count == 1 || (!ctx->is_10bit_bitstream && fmt->fourcc == V4L2_PIX_FMT_MM21))\n\t\treturn true;\n\n\tq_data = &ctx->q_data[MTK_Q_DATA_SRC];\n\tswitch (q_data->fmt->fourcc) {\n\tcase V4L2_PIX_FMT_H264_SLICE:\n\t\tif (ctx->is_10bit_bitstream && fmt->fourcc == V4L2_PIX_FMT_MT2110R)\n\t\t\tret = true;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VP9_FRAME:\n\tcase V4L2_PIX_FMT_AV1_FRAME:\n\tcase V4L2_PIX_FMT_HEVC_SLICE:\n\t\tif (ctx->is_10bit_bitstream && fmt->fourcc == V4L2_PIX_FMT_MT2110T)\n\t\t\tret = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic struct mtk_q_data *mtk_vdec_get_q_data(struct mtk_vcodec_dec_ctx *ctx,\n\t\t\t\t\t      enum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn &ctx->q_data[MTK_Q_DATA_SRC];\n\n\treturn &ctx->q_data[MTK_Q_DATA_DST];\n}\n\nstatic int vidioc_try_decoder_cmd(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_decoder_cmd *cmd)\n{\n\treturn v4l2_m2m_ioctl_try_decoder_cmd(file, priv, cmd);\n}\n\n\nstatic int vidioc_decoder_cmd(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_decoder_cmd *cmd)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\tstruct vb2_queue *src_vq, *dst_vq;\n\tint ret;\n\n\tret = vidioc_try_decoder_cmd(file, priv, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tmtk_v4l2_vdec_dbg(1, ctx, \"decoder cmd=%u\", cmd->cmd);\n\tdst_vq = v4l2_m2m_get_vq(ctx->m2m_ctx,\n\t\t\t\tV4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tswitch (cmd->cmd) {\n\tcase V4L2_DEC_CMD_STOP:\n\t\tsrc_vq = v4l2_m2m_get_vq(ctx->m2m_ctx,\n\t\t\t\tV4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\t\tif (!vb2_is_streaming(src_vq)) {\n\t\t\tmtk_v4l2_vdec_dbg(1, ctx, \"Output stream is off. No need to flush.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (!vb2_is_streaming(dst_vq)) {\n\t\t\tmtk_v4l2_vdec_dbg(1, ctx, \"Capture stream is off. No need to flush.\");\n\t\t\treturn 0;\n\t\t}\n\t\tv4l2_m2m_buf_queue(ctx->m2m_ctx, &ctx->empty_flush_buf.vb);\n\t\tv4l2_m2m_try_schedule(ctx->m2m_ctx);\n\t\tbreak;\n\n\tcase V4L2_DEC_CMD_START:\n\t\tvb2_clear_last_buffer_dequeued(dst_vq);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid mtk_vdec_unlock(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tmutex_unlock(&ctx->dev->dec_mutex[ctx->hw_id]);\n}\n\nvoid mtk_vdec_lock(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tmutex_lock(&ctx->dev->dec_mutex[ctx->hw_id]);\n}\n\nvoid mtk_vcodec_dec_release(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tvdec_if_deinit(ctx);\n\tctx->state = MTK_STATE_FREE;\n}\n\nvoid mtk_vcodec_dec_set_default_params(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct mtk_q_data *q_data;\n\n\tctx->m2m_ctx->q_lock = &ctx->dev->dev_mutex;\n\tctx->fh.m2m_ctx = ctx->m2m_ctx;\n\tctx->fh.ctrl_handler = &ctx->ctrl_hdl;\n\tINIT_WORK(&ctx->decode_work, ctx->dev->vdec_pdata->worker);\n\tctx->colorspace = V4L2_COLORSPACE_REC709;\n\tctx->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tctx->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tctx->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\n\tq_data = &ctx->q_data[MTK_Q_DATA_SRC];\n\tmemset(q_data, 0, sizeof(struct mtk_q_data));\n\tq_data->visible_width = DFT_CFG_WIDTH;\n\tq_data->visible_height = DFT_CFG_HEIGHT;\n\tq_data->fmt = ctx->dev->vdec_pdata->default_out_fmt;\n\tq_data->field = V4L2_FIELD_NONE;\n\n\tq_data->sizeimage[0] = DFT_CFG_WIDTH * DFT_CFG_HEIGHT;\n\tq_data->bytesperline[0] = 0;\n\n\tq_data = &ctx->q_data[MTK_Q_DATA_DST];\n\tmemset(q_data, 0, sizeof(struct mtk_q_data));\n\tq_data->visible_width = DFT_CFG_WIDTH;\n\tq_data->visible_height = DFT_CFG_HEIGHT;\n\tq_data->coded_width = DFT_CFG_WIDTH;\n\tq_data->coded_height = DFT_CFG_HEIGHT;\n\tq_data->fmt = ctx->dev->vdec_pdata->default_cap_fmt;\n\tq_data->field = V4L2_FIELD_NONE;\n\n\tq_data->sizeimage[0] = q_data->coded_width * q_data->coded_height;\n\tq_data->bytesperline[0] = q_data->coded_width;\n\tq_data->sizeimage[1] = q_data->sizeimage[0] / 2;\n\tq_data->bytesperline[1] = q_data->coded_width;\n}\n\nstatic int vidioc_vdec_qbuf(struct file *file, void *priv,\n\t\t\t    struct v4l2_buffer *buf)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\n\tif (ctx->state == MTK_STATE_ABORT) {\n\t\tmtk_v4l2_vdec_err(ctx, \"[%d] Call on QBUF after unrecoverable error\", ctx->id);\n\t\treturn -EIO;\n\t}\n\n\treturn v4l2_m2m_qbuf(file, ctx->m2m_ctx, buf);\n}\n\nstatic int vidioc_vdec_dqbuf(struct file *file, void *priv,\n\t\t\t     struct v4l2_buffer *buf)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\n\tif (ctx->state == MTK_STATE_ABORT) {\n\t\tmtk_v4l2_vdec_err(ctx, \"[%d] Call on DQBUF after unrecoverable error\", ctx->id);\n\t\treturn -EIO;\n\t}\n\n\treturn v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);\n}\n\nstatic int mtk_vcodec_dec_get_chip_name(void *priv)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\tstruct device *dev = &ctx->dev->plat_dev->dev;\n\n\tif (of_device_is_compatible(dev->of_node, \"mediatek,mt8173-vcodec-dec\"))\n\t\treturn 8173;\n\telse if (of_device_is_compatible(dev->of_node, \"mediatek,mt8183-vcodec-dec\"))\n\t\treturn 8183;\n\telse if (of_device_is_compatible(dev->of_node, \"mediatek,mt8192-vcodec-dec\"))\n\t\treturn 8192;\n\telse if (of_device_is_compatible(dev->of_node, \"mediatek,mt8195-vcodec-dec\"))\n\t\treturn 8195;\n\telse if (of_device_is_compatible(dev->of_node, \"mediatek,mt8186-vcodec-dec\"))\n\t\treturn 8186;\n\telse if (of_device_is_compatible(dev->of_node, \"mediatek,mt8188-vcodec-dec\"))\n\t\treturn 8188;\n\telse\n\t\treturn 8173;\n}\n\nstatic int vidioc_vdec_querycap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\tstruct device *dev = &ctx->dev->plat_dev->dev;\n\tint platform_name = mtk_vcodec_dec_get_chip_name(priv);\n\n\tstrscpy(cap->driver, dev->driver->name, sizeof(cap->driver));\n\tsnprintf(cap->card, sizeof(cap->card), \"MT%d video decoder\", platform_name);\n\n\treturn 0;\n}\n\nstatic int vidioc_vdec_subscribe_evt(struct v4l2_fh *fh,\n\t\t\t\t     const struct v4l2_event_subscription *sub)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(fh);\n\n\tif (ctx->dev->vdec_pdata->uses_stateless_api)\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_EOS:\n\t\treturn v4l2_event_subscribe(fh, sub, 2, NULL);\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subscribe(fh, sub);\n\tdefault:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\t}\n}\n\nstatic int vidioc_try_fmt(struct mtk_vcodec_dec_ctx *ctx, struct v4l2_format *f,\n\t\t\t  const struct mtk_video_fmt *fmt)\n{\n\tstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\n\tconst struct v4l2_frmsize_stepwise *frmsize;\n\n\tpix_fmt_mp->field = V4L2_FIELD_NONE;\n\n\t \n\tif (V4L2_TYPE_IS_OUTPUT(f->type))\n\t\tfrmsize = &fmt->frmsize;\n\telse\n\t\tfrmsize = &ctx->q_data[MTK_Q_DATA_SRC].fmt->frmsize;\n\n\tpix_fmt_mp->width = clamp(pix_fmt_mp->width, MTK_VDEC_MIN_W, frmsize->max_width);\n\tpix_fmt_mp->height = clamp(pix_fmt_mp->height, MTK_VDEC_MIN_H, frmsize->max_height);\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tpix_fmt_mp->num_planes = 1;\n\t\tpix_fmt_mp->plane_fmt[0].bytesperline = 0;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tint tmp_w, tmp_h;\n\n\t\t \n\t\ttmp_w = pix_fmt_mp->width;\n\t\ttmp_h = pix_fmt_mp->height;\n\t\tv4l_bound_align_image(&pix_fmt_mp->width, MTK_VDEC_MIN_W, frmsize->max_width, 6,\n\t\t\t\t      &pix_fmt_mp->height, MTK_VDEC_MIN_H, frmsize->max_height, 6,\n\t\t\t\t      9);\n\n\t\tif (pix_fmt_mp->width < tmp_w &&\n\t\t    (pix_fmt_mp->width + 64) <= frmsize->max_width)\n\t\t\tpix_fmt_mp->width += 64;\n\t\tif (pix_fmt_mp->height < tmp_h &&\n\t\t    (pix_fmt_mp->height + 64) <= frmsize->max_height)\n\t\t\tpix_fmt_mp->height += 64;\n\n\t\tmtk_v4l2_vdec_dbg(0, ctx,\n\t\t\t\t  \"before resize wxh=%dx%d, after resize wxh=%dx%d, sizeimage=%d\",\n\t\t\t\t  tmp_w, tmp_h, pix_fmt_mp->width, pix_fmt_mp->height,\n\t\t\t\t  pix_fmt_mp->width * pix_fmt_mp->height);\n\n\t\tpix_fmt_mp->num_planes = fmt->num_planes;\n\t\tpix_fmt_mp->plane_fmt[0].sizeimage =\n\t\t\t\tpix_fmt_mp->width * pix_fmt_mp->height;\n\t\tpix_fmt_mp->plane_fmt[0].bytesperline = pix_fmt_mp->width;\n\n\t\tif (pix_fmt_mp->num_planes == 2) {\n\t\t\tpix_fmt_mp->plane_fmt[1].sizeimage =\n\t\t\t\t(pix_fmt_mp->width * pix_fmt_mp->height) / 2;\n\t\t\tpix_fmt_mp->plane_fmt[1].bytesperline =\n\t\t\t\tpix_fmt_mp->width;\n\t\t}\n\t}\n\n\tpix_fmt_mp->flags = 0;\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap_mplane(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tconst struct mtk_video_fmt *fmt;\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\tconst struct mtk_vcodec_dec_pdata *dec_pdata = ctx->dev->vdec_pdata;\n\n\tfmt = mtk_vdec_find_format(f, dec_pdata);\n\tif (!fmt) {\n\t\tf->fmt.pix.pixelformat =\n\t\t\tctx->q_data[MTK_Q_DATA_DST].fmt->fourcc;\n\t\tfmt = mtk_vdec_find_format(f, dec_pdata);\n\t}\n\n\treturn vidioc_try_fmt(ctx, f, fmt);\n}\n\nstatic int vidioc_try_fmt_vid_out_mplane(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\n\tconst struct mtk_video_fmt *fmt;\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\tconst struct mtk_vcodec_dec_pdata *dec_pdata = ctx->dev->vdec_pdata;\n\n\tfmt = mtk_vdec_find_format(f, dec_pdata);\n\tif (!fmt) {\n\t\tf->fmt.pix.pixelformat =\n\t\t\tctx->q_data[MTK_Q_DATA_SRC].fmt->fourcc;\n\t\tfmt = mtk_vdec_find_format(f, dec_pdata);\n\t}\n\n\tif (pix_fmt_mp->plane_fmt[0].sizeimage == 0) {\n\t\tmtk_v4l2_vdec_err(ctx, \"sizeimage of output format must be given\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn vidioc_try_fmt(ctx, f, fmt);\n}\n\nstatic int vidioc_vdec_g_selection(struct file *file, void *priv,\n\t\t\tstruct v4l2_selection *s)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\tstruct mtk_q_data *q_data;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tq_data = &ctx->q_data[MTK_Q_DATA_DST];\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = ctx->picinfo.pic_w;\n\t\ts->r.height = ctx->picinfo.pic_h;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = ctx->picinfo.buf_w;\n\t\ts->r.height = ctx->picinfo.buf_h;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (vdec_if_get_param(ctx, GET_PARAM_CROP_INFO, &(s->r))) {\n\t\t\t \n\t\t\ts->r.left = 0;\n\t\t\ts->r.top = 0;\n\t\t\ts->r.width = q_data->visible_width;\n\t\t\ts->r.height = q_data->visible_height;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->state < MTK_STATE_HEADER) {\n\t\t \n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = q_data->visible_width;\n\t\ts->r.height = q_data->visible_height;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_vdec_s_selection(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_selection *s)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = ctx->picinfo.pic_w;\n\t\ts->r.height = ctx->picinfo.pic_h;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_vdec_s_fmt(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tstruct mtk_q_data *q_data;\n\tint ret = 0;\n\tconst struct mtk_video_fmt *fmt;\n\tconst struct mtk_vcodec_dec_pdata *dec_pdata = ctx->dev->vdec_pdata;\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d]\", ctx->id);\n\n\tq_data = mtk_vdec_get_q_data(ctx, f->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tpix_mp = &f->fmt.pix_mp;\n\t \n\tif (!dec_pdata->uses_stateless_api &&\n\t    f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&\n\t    vb2_is_busy(&ctx->m2m_ctx->out_q_ctx.q)) {\n\t\tmtk_v4l2_vdec_err(ctx, \"out_q_ctx buffers already requested\");\n\t\tret = -EBUSY;\n\t}\n\n\t \n\tif ((f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) &&\n\t    vb2_is_busy(&ctx->m2m_ctx->cap_q_ctx.q)) {\n\t\tmtk_v4l2_vdec_err(ctx, \"cap_q_ctx buffers already requested\");\n\t\tret = -EBUSY;\n\t}\n\n\tfmt = mtk_vdec_find_format(f, dec_pdata);\n\tif (fmt == NULL) {\n\t\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\t\tf->fmt.pix.pixelformat =\n\t\t\t\tdec_pdata->default_out_fmt->fourcc;\n\t\t\tfmt = mtk_vdec_find_format(f, dec_pdata);\n\t\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\t\tf->fmt.pix.pixelformat =\n\t\t\t\tdec_pdata->default_cap_fmt->fourcc;\n\t\t\tfmt = mtk_vdec_find_format(f, dec_pdata);\n\t\t}\n\t}\n\tif (fmt == NULL)\n\t\treturn -EINVAL;\n\n\tq_data->fmt = fmt;\n\tvidioc_try_fmt(ctx, f, q_data->fmt);\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tq_data->sizeimage[0] = pix_mp->plane_fmt[0].sizeimage;\n\t\tq_data->coded_width = pix_mp->width;\n\t\tq_data->coded_height = pix_mp->height;\n\n\t\tctx->colorspace = pix_mp->colorspace;\n\t\tctx->ycbcr_enc = pix_mp->ycbcr_enc;\n\t\tctx->quantization = pix_mp->quantization;\n\t\tctx->xfer_func = pix_mp->xfer_func;\n\n\t\tctx->current_codec = fmt->fourcc;\n\t\tif (ctx->state == MTK_STATE_FREE) {\n\t\t\tret = vdec_if_init(ctx, q_data->fmt->fourcc);\n\t\t\tif (ret) {\n\t\t\t\tmtk_v4l2_vdec_err(ctx, \"[%d]: vdec_if_init() fail ret=%d\",\n\t\t\t\t\t\t  ctx->id, ret);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tctx->state = MTK_STATE_INIT;\n\t\t}\n\t} else {\n\t\tctx->capture_fourcc = fmt->fourcc;\n\t}\n\n\t \n\tif (dec_pdata->uses_stateless_api) {\n\t\tctx->picinfo.pic_w = pix_mp->width;\n\t\tctx->picinfo.pic_h = pix_mp->height;\n\n\t\t \n\t\tret = vdec_if_get_param(ctx, GET_PARAM_PIC_INFO, &ctx->picinfo);\n\t\tif (ret) {\n\t\t\tmtk_v4l2_vdec_err(ctx, \"[%d]Error!! Get GET_PARAM_PICTURE_INFO Fail\",\n\t\t\t\t\t  ctx->id);\n\t\t}\n\n\t\tctx->last_decoded_picinfo = ctx->picinfo;\n\n\t\tif (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 1) {\n\t\t\tctx->q_data[MTK_Q_DATA_DST].sizeimage[0] =\n\t\t\t\tctx->picinfo.fb_sz[0] +\n\t\t\t\tctx->picinfo.fb_sz[1];\n\t\t\tctx->q_data[MTK_Q_DATA_DST].bytesperline[0] =\n\t\t\t\tctx->picinfo.buf_w;\n\t\t} else {\n\t\t\tctx->q_data[MTK_Q_DATA_DST].sizeimage[0] =\n\t\t\t\tctx->picinfo.fb_sz[0];\n\t\t\tctx->q_data[MTK_Q_DATA_DST].bytesperline[0] =\n\t\t\t\tctx->picinfo.buf_w;\n\t\t\tctx->q_data[MTK_Q_DATA_DST].sizeimage[1] =\n\t\t\t\tctx->picinfo.fb_sz[1];\n\t\t\tctx->q_data[MTK_Q_DATA_DST].bytesperline[1] =\n\t\t\t\tctx->picinfo.buf_w;\n\t\t}\n\n\t\tctx->q_data[MTK_Q_DATA_DST].coded_width = ctx->picinfo.buf_w;\n\t\tctx->q_data[MTK_Q_DATA_DST].coded_height = ctx->picinfo.buf_h;\n\t\tmtk_v4l2_vdec_dbg(2, ctx,\n\t\t\t\t  \"[%d] init() plane:%d wxh=%dx%d pic wxh=%dx%d sz=0x%x_0x%x\",\n\t\t\t\t  ctx->id, pix_mp->num_planes,\n\t\t\t\t  ctx->picinfo.buf_w, ctx->picinfo.buf_h,\n\t\t\t\t  ctx->picinfo.pic_w, ctx->picinfo.pic_h,\n\t\t\t\t  ctx->q_data[MTK_Q_DATA_DST].sizeimage[0],\n\t\t\t\t  ctx->q_data[MTK_Q_DATA_DST].sizeimage[1]);\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_enum_framesizes(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frmsizeenum *fsize)\n{\n\tint i = 0;\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\tconst struct mtk_vcodec_dec_pdata *dec_pdata = ctx->dev->vdec_pdata;\n\n\tif (fsize->index != 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < *dec_pdata->num_formats; i++) {\n\t\tif (fsize->pixel_format != dec_pdata->vdec_formats[i].fourcc)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!dec_pdata->vdec_formats[i].frmsize.max_width)\n\t\t\treturn -ENOTTY;\n\n\t\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\t\tfsize->stepwise = dec_pdata->vdec_formats[i].frmsize;\n\n\t\tmtk_v4l2_vdec_dbg(1, ctx, \"%x, %d %d %d %d %d %d\",\n\t\t\t\t  ctx->dev->dec_capability, fsize->stepwise.min_width,\n\t\t\t\t  fsize->stepwise.max_width, fsize->stepwise.step_width,\n\t\t\t\t  fsize->stepwise.min_height, fsize->stepwise.max_height,\n\t\t\t\t  fsize->stepwise.step_height);\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int vidioc_enum_fmt(struct v4l2_fmtdesc *f, void *priv,\n\t\t\t   bool output_queue)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\tconst struct mtk_vcodec_dec_pdata *dec_pdata = ctx->dev->vdec_pdata;\n\tconst struct mtk_video_fmt *fmt;\n\tint i, j = 0;\n\n\tfor (i = 0; i < *dec_pdata->num_formats; i++) {\n\t\tif (output_queue &&\n\t\t    dec_pdata->vdec_formats[i].type != MTK_FMT_DEC)\n\t\t\tcontinue;\n\t\tif (!output_queue &&\n\t\t    dec_pdata->vdec_formats[i].type != MTK_FMT_FRAME)\n\t\t\tcontinue;\n\n\t\tif (!output_queue && !mtk_vdec_get_cap_fmt(ctx, i))\n\t\t\tcontinue;\n\n\t\tif (j == f->index)\n\t\t\tbreak;\n\t\t++j;\n\t}\n\n\tif (i == *dec_pdata->num_formats)\n\t\treturn -EINVAL;\n\n\tfmt = &dec_pdata->vdec_formats[i];\n\tf->pixelformat = fmt->fourcc;\n\tf->flags = fmt->flags;\n\n\treturn 0;\n}\n\nstatic int vidioc_vdec_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\treturn vidioc_enum_fmt(f, priv, false);\n}\n\nstatic int vidioc_vdec_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\treturn vidioc_enum_fmt(f, priv, true);\n}\n\nstatic int vidioc_vdec_g_fmt(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = fh_to_dec_ctx(priv);\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tstruct vb2_queue *vq;\n\tstruct mtk_q_data *q_data;\n\n\tvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\n\tif (!vq) {\n\t\tmtk_v4l2_vdec_err(ctx, \"no vb2 queue for type=%d\", f->type);\n\t\treturn -EINVAL;\n\t}\n\n\tq_data = mtk_vdec_get_q_data(ctx, f->type);\n\n\tpix_mp->field = V4L2_FIELD_NONE;\n\tpix_mp->colorspace = ctx->colorspace;\n\tpix_mp->ycbcr_enc = ctx->ycbcr_enc;\n\tpix_mp->quantization = ctx->quantization;\n\tpix_mp->xfer_func = ctx->xfer_func;\n\n\tif ((f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) &&\n\t    (ctx->state >= MTK_STATE_HEADER)) {\n\t\t \n\t\tq_data->sizeimage[0] = ctx->picinfo.fb_sz[0];\n\t\tq_data->sizeimage[1] = ctx->picinfo.fb_sz[1];\n\t\tq_data->bytesperline[0] = ctx->last_decoded_picinfo.buf_w;\n\t\tq_data->bytesperline[1] = ctx->last_decoded_picinfo.buf_w;\n\t\tq_data->coded_width = ctx->picinfo.buf_w;\n\t\tq_data->coded_height = ctx->picinfo.buf_h;\n\t\tctx->last_decoded_picinfo.cap_fourcc = q_data->fmt->fourcc;\n\n\t\t \n\t\tpix_mp->width = q_data->coded_width;\n\t\tpix_mp->height = q_data->coded_height;\n\n\t\t \n\t\tpix_mp->num_planes = q_data->fmt->num_planes;\n\t\tpix_mp->pixelformat = q_data->fmt->fourcc;\n\t\tpix_mp->plane_fmt[0].bytesperline = q_data->bytesperline[0];\n\t\tpix_mp->plane_fmt[0].sizeimage = q_data->sizeimage[0];\n\t\tpix_mp->plane_fmt[1].bytesperline = q_data->bytesperline[1];\n\t\tpix_mp->plane_fmt[1].sizeimage = q_data->sizeimage[1];\n\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\t \n\t\tpix_mp->width = q_data->visible_width;\n\t\tpix_mp->height = q_data->visible_height;\n\t\tpix_mp->plane_fmt[0].bytesperline = q_data->bytesperline[0];\n\t\tpix_mp->plane_fmt[0].sizeimage = q_data->sizeimage[0];\n\t\tpix_mp->pixelformat = q_data->fmt->fourcc;\n\t\tpix_mp->num_planes = q_data->fmt->num_planes;\n\t} else {\n\t\tpix_mp->width = q_data->coded_width;\n\t\tpix_mp->height = q_data->coded_height;\n\t\tpix_mp->num_planes = q_data->fmt->num_planes;\n\t\tpix_mp->pixelformat = q_data->fmt->fourcc;\n\t\tpix_mp->plane_fmt[0].bytesperline = q_data->bytesperline[0];\n\t\tpix_mp->plane_fmt[0].sizeimage = q_data->sizeimage[0];\n\t\tpix_mp->plane_fmt[1].bytesperline = q_data->bytesperline[1];\n\t\tpix_mp->plane_fmt[1].sizeimage = q_data->sizeimage[1];\n\n\t\tmtk_v4l2_vdec_dbg(1, ctx, \"[%d] type=%d state=%d Format information not ready!\",\n\t\t\t\t  ctx->id, f->type, ctx->state);\n\t}\n\n\treturn 0;\n}\n\nint vb2ops_vdec_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\n\t\t\t    unsigned int *nplanes, unsigned int sizes[],\n\t\t\t    struct device *alloc_devs[])\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct mtk_q_data *q_data;\n\tunsigned int i;\n\n\tq_data = mtk_vdec_get_q_data(ctx, vq->type);\n\n\tif (q_data == NULL) {\n\t\tmtk_v4l2_vdec_err(ctx, \"vq->type=%d err\\n\", vq->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (*nplanes) {\n\t\tif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\t\tif (*nplanes != q_data->fmt->num_planes)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (*nplanes != 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < *nplanes; i++) {\n\t\t\tif (sizes[i] < q_data->sizeimage[i])\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\t\t*nplanes = q_data->fmt->num_planes;\n\t\telse\n\t\t\t*nplanes = 1;\n\n\t\tfor (i = 0; i < *nplanes; i++)\n\t\t\tsizes[i] = q_data->sizeimage[i];\n\t}\n\n\tmtk_v4l2_vdec_dbg(1, ctx,\n\t\t\t  \"[%d]\\t type = %d, get %d plane(s), %d buffer(s) of size 0x%x 0x%x \",\n\t\t\t  ctx->id, vq->type, *nplanes, *nbuffers, sizes[0], sizes[1]);\n\n\treturn 0;\n}\n\nint vb2ops_vdec_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct mtk_q_data *q_data;\n\tint i;\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d] (%d) id=%d\",\n\t\t\t  ctx->id, vb->vb2_queue->type, vb->index);\n\n\tq_data = mtk_vdec_get_q_data(ctx, vb->vb2_queue->type);\n\n\tfor (i = 0; i < q_data->fmt->num_planes; i++) {\n\t\tif (vb2_plane_size(vb, i) < q_data->sizeimage[i]) {\n\t\t\tmtk_v4l2_vdec_err(ctx, \"data will not fit into plane %d (%lu < %d)\",\n\t\t\t\t\t  i, vb2_plane_size(vb, i), q_data->sizeimage[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!V4L2_TYPE_IS_OUTPUT(vb->type))\n\t\t\tvb2_set_plane_payload(vb, i, q_data->sizeimage[i]);\n\t}\n\n\treturn 0;\n}\n\nvoid vb2ops_vdec_buf_finish(struct vb2_buffer *vb)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vb2_v4l2;\n\tstruct mtk_video_dec_buf *buf;\n\tbool buf_error;\n\n\tvb2_v4l2 = container_of(vb, struct vb2_v4l2_buffer, vb2_buf);\n\tbuf = container_of(vb2_v4l2, struct mtk_video_dec_buf, m2m_buf.vb);\n\tmutex_lock(&ctx->lock);\n\tif (vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tbuf->queued_in_v4l2 = false;\n\t\tbuf->queued_in_vb2 = false;\n\t}\n\tbuf_error = buf->error;\n\tmutex_unlock(&ctx->lock);\n\n\tif (buf_error) {\n\t\tmtk_v4l2_vdec_err(ctx, \"Unrecoverable error on buffer.\");\n\t\tctx->state = MTK_STATE_ABORT;\n\t}\n}\n\nint vb2ops_vdec_buf_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vb2_v4l2 = container_of(vb,\n\t\t\t\t\tstruct vb2_v4l2_buffer, vb2_buf);\n\tstruct mtk_video_dec_buf *buf = container_of(vb2_v4l2,\n\t\t\t\t\tstruct mtk_video_dec_buf, m2m_buf.vb);\n\n\tif (vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tbuf->used = false;\n\t\tbuf->queued_in_v4l2 = false;\n\t}\n\n\treturn 0;\n}\n\nint vb2ops_vdec_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = vb2_get_drv_priv(q);\n\n\tif (ctx->state == MTK_STATE_FLUSH)\n\t\tctx->state = MTK_STATE_HEADER;\n\n\treturn 0;\n}\n\nvoid vb2ops_vdec_stop_streaming(struct vb2_queue *q)\n{\n\tstruct vb2_v4l2_buffer *src_buf = NULL, *dst_buf = NULL;\n\tstruct mtk_vcodec_dec_ctx *ctx = vb2_get_drv_priv(q);\n\tint ret;\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d] (%d) state=(%x) ctx->decoded_frame_cnt=%d\",\n\t\t\t  ctx->id, q->type, ctx->state, ctx->decoded_frame_cnt);\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\twhile ((src_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx))) {\n\t\t\tif (src_buf != &ctx->empty_flush_buf.vb) {\n\t\t\t\tstruct media_request *req =\n\t\t\t\t\tsrc_buf->vb2_buf.req_obj.req;\n\t\t\t\tv4l2_m2m_buf_done(src_buf,\n\t\t\t\t\t\tVB2_BUF_STATE_ERROR);\n\t\t\t\tif (req)\n\t\t\t\t\tv4l2_ctrl_request_complete(req, &ctx->ctrl_hdl);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ctx->state >= MTK_STATE_HEADER) {\n\n\t\t \n\t\tctx->picinfo = ctx->last_decoded_picinfo;\n\n\t\tmtk_v4l2_vdec_dbg(2, ctx,\n\t\t\t\t  \"[%d]-> new(%d,%d), old(%d,%d), real(%d,%d)\",\n\t\t\t\t  ctx->id, ctx->last_decoded_picinfo.pic_w,\n\t\t\t\t  ctx->last_decoded_picinfo.pic_h,\n\t\t\t\t  ctx->picinfo.pic_w, ctx->picinfo.pic_h,\n\t\t\t\t  ctx->last_decoded_picinfo.buf_w,\n\t\t\t\t  ctx->last_decoded_picinfo.buf_h);\n\n\t\tret = ctx->dev->vdec_pdata->flush_decoder(ctx);\n\t\tif (ret)\n\t\t\tmtk_v4l2_vdec_err(ctx, \"DecodeFinal failed, ret=%d\", ret);\n\t}\n\tctx->state = MTK_STATE_FLUSH;\n\n\twhile ((dst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx))) {\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, 0);\n\t\tif (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 2)\n\t\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 1, 0);\n\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\n\t}\n\n}\n\nstatic void m2mops_vdec_device_run(void *priv)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = priv;\n\tstruct mtk_vcodec_dec_dev *dev = ctx->dev;\n\n\tqueue_work(dev->decode_workqueue, &ctx->decode_work);\n}\n\nstatic int m2mops_vdec_job_ready(void *m2m_priv)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = m2m_priv;\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d]\", ctx->id);\n\n\tif (ctx->state == MTK_STATE_ABORT)\n\t\treturn 0;\n\n\tif ((ctx->last_decoded_picinfo.pic_w != ctx->picinfo.pic_w) ||\n\t    (ctx->last_decoded_picinfo.pic_h != ctx->picinfo.pic_h))\n\t\treturn 0;\n\n\tif (ctx->state != MTK_STATE_HEADER)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void m2mops_vdec_job_abort(void *priv)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = priv;\n\n\tctx->state = MTK_STATE_ABORT;\n}\n\nconst struct v4l2_m2m_ops mtk_vdec_m2m_ops = {\n\t.device_run\t= m2mops_vdec_device_run,\n\t.job_ready\t= m2mops_vdec_job_ready,\n\t.job_abort\t= m2mops_vdec_job_abort,\n};\n\nconst struct v4l2_ioctl_ops mtk_vdec_ioctl_ops = {\n\t.vidioc_streamon\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t= v4l2_m2m_ioctl_streamoff,\n\t.vidioc_reqbufs\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_expbuf\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_qbuf\t\t= vidioc_vdec_qbuf,\n\t.vidioc_dqbuf\t\t= vidioc_vdec_dqbuf,\n\n\t.vidioc_try_fmt_vid_cap_mplane\t= vidioc_try_fmt_vid_cap_mplane,\n\t.vidioc_try_fmt_vid_out_mplane\t= vidioc_try_fmt_vid_out_mplane,\n\n\t.vidioc_s_fmt_vid_cap_mplane\t= vidioc_vdec_s_fmt,\n\t.vidioc_s_fmt_vid_out_mplane\t= vidioc_vdec_s_fmt,\n\t.vidioc_g_fmt_vid_cap_mplane\t= vidioc_vdec_g_fmt,\n\t.vidioc_g_fmt_vid_out_mplane\t= vidioc_vdec_g_fmt,\n\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\n\t.vidioc_enum_fmt_vid_cap\t= vidioc_vdec_enum_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_out\t= vidioc_vdec_enum_fmt_vid_out,\n\t.vidioc_enum_framesizes\t= vidioc_enum_framesizes,\n\n\t.vidioc_querycap\t\t= vidioc_vdec_querycap,\n\t.vidioc_subscribe_event\t\t= vidioc_vdec_subscribe_evt,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n\t.vidioc_g_selection             = vidioc_vdec_g_selection,\n\t.vidioc_s_selection             = vidioc_vdec_s_selection,\n\n\t.vidioc_decoder_cmd = vidioc_decoder_cmd,\n\t.vidioc_try_decoder_cmd = vidioc_try_decoder_cmd,\n};\n\nint mtk_vcodec_dec_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t   struct vb2_queue *dst_vq)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = priv;\n\tint ret = 0;\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d]\", ctx->id);\n\n\tsrc_vq->type\t\t= V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes\t= VB2_DMABUF | VB2_MMAP;\n\tsrc_vq->drv_priv\t= ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct mtk_video_dec_buf);\n\tsrc_vq->ops\t\t= ctx->dev->vdec_pdata->vdec_vb2_ops;\n\tsrc_vq->mem_ops\t\t= &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock\t\t= &ctx->dev->dev_mutex;\n\tsrc_vq->dev             = &ctx->dev->plat_dev->dev;\n\tsrc_vq->allow_cache_hints = 1;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret) {\n\t\tmtk_v4l2_vdec_err(ctx, \"Failed to initialize videobuf2 queue(output)\");\n\t\treturn ret;\n\t}\n\tdst_vq->type\t\t= V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes\t= VB2_DMABUF | VB2_MMAP;\n\tdst_vq->drv_priv\t= ctx;\n\tdst_vq->buf_struct_size = sizeof(struct mtk_video_dec_buf);\n\tdst_vq->ops\t\t= ctx->dev->vdec_pdata->vdec_vb2_ops;\n\tdst_vq->mem_ops\t\t= &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock\t\t= &ctx->dev->dev_mutex;\n\tdst_vq->dev             = &ctx->dev->plat_dev->dev;\n\tdst_vq->allow_cache_hints = 1;\n\n\tret = vb2_queue_init(dst_vq);\n\tif (ret)\n\t\tmtk_v4l2_vdec_err(ctx, \"Failed to initialize videobuf2 queue(capture)\");\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}