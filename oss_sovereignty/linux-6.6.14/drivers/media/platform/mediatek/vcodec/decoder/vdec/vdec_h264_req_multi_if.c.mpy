{
  "module_name": "vdec_h264_req_multi_if.c",
  "hash_id": "3542c4318c482f5b44b0a8e477179e6b9c39b0397629d462044ed057207ae738",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_h264_req_multi_if.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <media/v4l2-h264.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"../mtk_vcodec_dec.h\"\n#include \"../../common/mtk_vcodec_intr.h\"\n#include \"../vdec_drv_base.h\"\n#include \"../vdec_drv_if.h\"\n#include \"../vdec_vpu_if.h\"\n#include \"vdec_h264_req_common.h\"\n\n \nenum vdec_h264_core_dec_err_type {\n\tTRANS_BUFFER_FULL = 1,\n\tSLICE_HEADER_FULL,\n};\n\n \nstruct vdec_h264_slice_lat_dec_param {\n\tstruct mtk_h264_sps_param sps;\n\tstruct mtk_h264_pps_param pps;\n\tstruct mtk_h264_slice_hd_param slice_header;\n\tstruct slice_api_h264_scaling_matrix scaling_matrix;\n\tstruct slice_api_h264_decode_param decode_params;\n\tstruct mtk_h264_dpb_info h264_dpb_info[V4L2_H264_NUM_DPB_ENTRIES];\n};\n\n \nstruct vdec_h264_slice_info {\n\tu16 nal_info;\n\tu16 timeout;\n\tu32 bs_buf_size;\n\tu64 bs_buf_addr;\n\tu64 y_fb_dma;\n\tu64 c_fb_dma;\n\tu64 vdec_fb_va;\n\tu32 crc[8];\n};\n\n \nstruct vdec_h264_slice_vsi {\n\t \n\tu64 wdma_err_addr;\n\tu64 wdma_start_addr;\n\tu64 wdma_end_addr;\n\tu64 slice_bc_start_addr;\n\tu64 slice_bc_end_addr;\n\tu64 row_info_start_addr;\n\tu64 row_info_end_addr;\n\tu64 trans_start;\n\tu64 trans_end;\n\tu64 wdma_end_addr_offset;\n\n\tu64 mv_buf_dma[H264_MAX_MV_NUM];\n\tstruct vdec_h264_slice_info dec;\n\tstruct vdec_h264_slice_lat_dec_param h264_slice_params;\n};\n\n \nstruct vdec_h264_slice_share_info {\n\tstruct v4l2_ctrl_h264_sps sps;\n\tstruct v4l2_ctrl_h264_decode_params dec_params;\n\tstruct vdec_h264_slice_lat_dec_param h264_slice_params;\n\tu64 trans_start;\n\tu64 trans_end;\n\tu16 nal_info;\n};\n\n \nstruct vdec_h264_slice_inst {\n\tunsigned int slice_dec_num;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct mtk_vcodec_mem pred_buf;\n\tstruct mtk_vcodec_mem mv_buf[H264_MAX_MV_NUM];\n\tstruct vdec_vpu_inst vpu;\n\tstruct vdec_h264_slice_vsi *vsi;\n\tstruct vdec_h264_slice_vsi *vsi_core;\n\n\tstruct vdec_h264_slice_vsi vsi_ctx;\n\tstruct vdec_h264_slice_lat_dec_param h264_slice_param;\n\n\tunsigned int resolution_changed;\n\tunsigned int realloc_mv_buf;\n\tunsigned int cap_num_planes;\n\n\tstruct v4l2_h264_dpb_entry dpb[16];\n\tbool is_field_bitstream;\n};\n\nstatic int vdec_h264_slice_fill_decode_parameters(struct vdec_h264_slice_inst *inst,\n\t\t\t\t\t\t  struct vdec_h264_slice_share_info *share_info)\n{\n\tstruct vdec_h264_slice_lat_dec_param *slice_param = &inst->vsi->h264_slice_params;\n\tconst struct v4l2_ctrl_h264_decode_params *dec_params;\n\tconst struct v4l2_ctrl_h264_scaling_matrix *src_matrix;\n\tconst struct v4l2_ctrl_h264_sps *sps;\n\tconst struct v4l2_ctrl_h264_pps *pps;\n\n\tdec_params =\n\t\tmtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_DECODE_PARAMS);\n\tif (IS_ERR(dec_params))\n\t\treturn PTR_ERR(dec_params);\n\n\tsrc_matrix =\n\t\tmtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_SCALING_MATRIX);\n\tif (IS_ERR(src_matrix))\n\t\treturn PTR_ERR(src_matrix);\n\n\tsps = mtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_SPS);\n\tif (IS_ERR(sps))\n\t\treturn PTR_ERR(sps);\n\n\tpps = mtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_PPS);\n\tif (IS_ERR(pps))\n\t\treturn PTR_ERR(pps);\n\n\tif (dec_params->flags & V4L2_H264_DECODE_PARAM_FLAG_FIELD_PIC) {\n\t\tmtk_vdec_err(inst->ctx, \"No support for H.264 field decoding.\");\n\t\tinst->is_field_bitstream = true;\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_vdec_h264_copy_sps_params(&slice_param->sps, sps);\n\tmtk_vdec_h264_copy_pps_params(&slice_param->pps, pps);\n\tmtk_vdec_h264_copy_scaling_matrix(&slice_param->scaling_matrix, src_matrix);\n\n\tmemcpy(&share_info->sps, sps, sizeof(*sps));\n\tmemcpy(&share_info->dec_params, dec_params, sizeof(*dec_params));\n\n\treturn 0;\n}\n\nstatic int get_vdec_sig_decode_parameters(struct vdec_h264_slice_inst *inst)\n{\n\tconst struct v4l2_ctrl_h264_decode_params *dec_params;\n\tconst struct v4l2_ctrl_h264_sps *sps;\n\tconst struct v4l2_ctrl_h264_pps *pps;\n\tconst struct v4l2_ctrl_h264_scaling_matrix *scaling_matrix;\n\tstruct vdec_h264_slice_lat_dec_param *slice_param = &inst->h264_slice_param;\n\tstruct v4l2_h264_reflist_builder reflist_builder;\n\tstruct v4l2_h264_reference v4l2_p0_reflist[V4L2_H264_REF_LIST_LEN];\n\tstruct v4l2_h264_reference v4l2_b0_reflist[V4L2_H264_REF_LIST_LEN];\n\tstruct v4l2_h264_reference v4l2_b1_reflist[V4L2_H264_REF_LIST_LEN];\n\tu8 *p0_reflist = slice_param->decode_params.ref_pic_list_p0;\n\tu8 *b0_reflist = slice_param->decode_params.ref_pic_list_b0;\n\tu8 *b1_reflist = slice_param->decode_params.ref_pic_list_b1;\n\n\tdec_params =\n\t\tmtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_DECODE_PARAMS);\n\tif (IS_ERR(dec_params))\n\t\treturn PTR_ERR(dec_params);\n\n\tsps = mtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_SPS);\n\tif (IS_ERR(sps))\n\t\treturn PTR_ERR(sps);\n\n\tpps = mtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_PPS);\n\tif (IS_ERR(pps))\n\t\treturn PTR_ERR(pps);\n\n\tscaling_matrix =\n\t\tmtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_SCALING_MATRIX);\n\tif (IS_ERR(scaling_matrix))\n\t\treturn PTR_ERR(scaling_matrix);\n\n\tmtk_vdec_h264_update_dpb(dec_params, inst->dpb);\n\n\tmtk_vdec_h264_copy_sps_params(&slice_param->sps, sps);\n\tmtk_vdec_h264_copy_pps_params(&slice_param->pps, pps);\n\tmtk_vdec_h264_copy_scaling_matrix(&slice_param->scaling_matrix, scaling_matrix);\n\n\tmtk_vdec_h264_copy_decode_params(&slice_param->decode_params, dec_params, inst->dpb);\n\tmtk_vdec_h264_fill_dpb_info(inst->ctx, &slice_param->decode_params,\n\t\t\t\t    slice_param->h264_dpb_info);\n\n\t \n\tv4l2_h264_init_reflist_builder(&reflist_builder, dec_params, sps, inst->dpb);\n\tv4l2_h264_build_p_ref_list(&reflist_builder, v4l2_p0_reflist);\n\tv4l2_h264_build_b_ref_lists(&reflist_builder, v4l2_b0_reflist, v4l2_b1_reflist);\n\n\t \n\tmtk_vdec_h264_get_ref_list(p0_reflist, v4l2_p0_reflist, reflist_builder.num_valid);\n\tmtk_vdec_h264_get_ref_list(b0_reflist, v4l2_b0_reflist, reflist_builder.num_valid);\n\tmtk_vdec_h264_get_ref_list(b1_reflist, v4l2_b1_reflist, reflist_builder.num_valid);\n\n\tmemcpy(&inst->vsi_ctx.h264_slice_params, slice_param,\n\t       sizeof(inst->vsi_ctx.h264_slice_params));\n\n\treturn 0;\n}\n\nstatic void vdec_h264_slice_fill_decode_reflist(struct vdec_h264_slice_inst *inst,\n\t\t\t\t\t\tstruct vdec_h264_slice_lat_dec_param *slice_param,\n\t\t\t\t\t\tstruct vdec_h264_slice_share_info *share_info)\n{\n\tstruct v4l2_ctrl_h264_decode_params *dec_params = &share_info->dec_params;\n\tstruct v4l2_ctrl_h264_sps *sps = &share_info->sps;\n\tstruct v4l2_h264_reflist_builder reflist_builder;\n\tstruct v4l2_h264_reference v4l2_p0_reflist[V4L2_H264_REF_LIST_LEN];\n\tstruct v4l2_h264_reference v4l2_b0_reflist[V4L2_H264_REF_LIST_LEN];\n\tstruct v4l2_h264_reference v4l2_b1_reflist[V4L2_H264_REF_LIST_LEN];\n\tu8 *p0_reflist = slice_param->decode_params.ref_pic_list_p0;\n\tu8 *b0_reflist = slice_param->decode_params.ref_pic_list_b0;\n\tu8 *b1_reflist = slice_param->decode_params.ref_pic_list_b1;\n\n\tmtk_vdec_h264_update_dpb(dec_params, inst->dpb);\n\n\tmtk_vdec_h264_copy_decode_params(&slice_param->decode_params, dec_params,\n\t\t\t\t\t inst->dpb);\n\tmtk_vdec_h264_fill_dpb_info(inst->ctx, &slice_param->decode_params,\n\t\t\t\t    slice_param->h264_dpb_info);\n\n\tmtk_v4l2_vdec_dbg(3, inst->ctx, \"cur poc = %d\\n\", dec_params->bottom_field_order_cnt);\n\t \n\tv4l2_h264_init_reflist_builder(&reflist_builder, dec_params, sps,\n\t\t\t\t       inst->dpb);\n\tv4l2_h264_build_p_ref_list(&reflist_builder, v4l2_p0_reflist);\n\tv4l2_h264_build_b_ref_lists(&reflist_builder, v4l2_b0_reflist, v4l2_b1_reflist);\n\n\t \n\tmtk_vdec_h264_get_ref_list(p0_reflist, v4l2_p0_reflist, reflist_builder.num_valid);\n\tmtk_vdec_h264_get_ref_list(b0_reflist, v4l2_b0_reflist, reflist_builder.num_valid);\n\tmtk_vdec_h264_get_ref_list(b1_reflist, v4l2_b1_reflist, reflist_builder.num_valid);\n}\n\nstatic int vdec_h264_slice_alloc_mv_buf(struct vdec_h264_slice_inst *inst,\n\t\t\t\t\tstruct vdec_pic_info *pic)\n{\n\tunsigned int buf_sz = mtk_vdec_h264_get_mv_buf_size(pic->buf_w, pic->buf_h);\n\tstruct mtk_vcodec_mem *mem;\n\tint i, err;\n\n\tmtk_v4l2_vdec_dbg(3, inst->ctx, \"size = 0x%x\", buf_sz);\n\tfor (i = 0; i < H264_MAX_MV_NUM; i++) {\n\t\tmem = &inst->mv_buf[i];\n\t\tif (mem->va)\n\t\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\t\tmem->size = buf_sz;\n\t\terr = mtk_vcodec_mem_alloc(inst->ctx, mem);\n\t\tif (err) {\n\t\t\tmtk_vdec_err(inst->ctx, \"failed to allocate mv buf\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void vdec_h264_slice_free_mv_buf(struct vdec_h264_slice_inst *inst)\n{\n\tint i;\n\tstruct mtk_vcodec_mem *mem;\n\n\tfor (i = 0; i < H264_MAX_MV_NUM; i++) {\n\t\tmem = &inst->mv_buf[i];\n\t\tif (mem->va)\n\t\t\tmtk_vcodec_mem_free(inst->ctx, mem);\n\t}\n}\n\nstatic void vdec_h264_slice_get_pic_info(struct vdec_h264_slice_inst *inst)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = inst->ctx;\n\tu32 data[3];\n\n\tdata[0] = ctx->picinfo.pic_w;\n\tdata[1] = ctx->picinfo.pic_h;\n\tdata[2] = ctx->capture_fourcc;\n\tvpu_dec_get_param(&inst->vpu, data, 3, GET_PARAM_PIC_INFO);\n\n\tctx->picinfo.buf_w = ALIGN(ctx->picinfo.pic_w, VCODEC_DEC_ALIGNED_64);\n\tctx->picinfo.buf_h = ALIGN(ctx->picinfo.pic_h, VCODEC_DEC_ALIGNED_64);\n\tctx->picinfo.fb_sz[0] = inst->vpu.fb_sz[0];\n\tctx->picinfo.fb_sz[1] = inst->vpu.fb_sz[1];\n\tinst->cap_num_planes =\n\t\tctx->q_data[MTK_Q_DATA_DST].fmt->num_planes;\n\n\tmtk_vdec_debug(ctx, \"pic(%d, %d), buf(%d, %d)\",\n\t\t       ctx->picinfo.pic_w, ctx->picinfo.pic_h,\n\t\t       ctx->picinfo.buf_w, ctx->picinfo.buf_h);\n\tmtk_vdec_debug(ctx, \"Y/C(%d, %d)\", ctx->picinfo.fb_sz[0],\n\t\t       ctx->picinfo.fb_sz[1]);\n\n\tif (ctx->last_decoded_picinfo.pic_w != ctx->picinfo.pic_w ||\n\t    ctx->last_decoded_picinfo.pic_h != ctx->picinfo.pic_h) {\n\t\tinst->resolution_changed = true;\n\t\tif (ctx->last_decoded_picinfo.buf_w != ctx->picinfo.buf_w ||\n\t\t    ctx->last_decoded_picinfo.buf_h != ctx->picinfo.buf_h)\n\t\t\tinst->realloc_mv_buf = true;\n\n\t\tmtk_v4l2_vdec_dbg(1, inst->ctx, \"resChg: (%d %d) : old(%d, %d) -> new(%d, %d)\",\n\t\t\t\t  inst->resolution_changed,\n\t\t\t\t  inst->realloc_mv_buf,\n\t\t\t\t  ctx->last_decoded_picinfo.pic_w,\n\t\t\t\t  ctx->last_decoded_picinfo.pic_h,\n\t\t\t\t  ctx->picinfo.pic_w, ctx->picinfo.pic_h);\n\t}\n}\n\nstatic void vdec_h264_slice_get_crop_info(struct vdec_h264_slice_inst *inst,\n\t\t\t\t\t  struct v4l2_rect *cr)\n{\n\tcr->left = 0;\n\tcr->top = 0;\n\tcr->width = inst->ctx->picinfo.pic_w;\n\tcr->height = inst->ctx->picinfo.pic_h;\n\n\tmtk_vdec_debug(inst->ctx, \"l=%d, t=%d, w=%d, h=%d\",\n\t\t       cr->left, cr->top, cr->width, cr->height);\n}\n\nstatic int vdec_h264_slice_init(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct vdec_h264_slice_inst *inst;\n\tint err, vsi_size;\n\n\tinst = kzalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tinst->ctx = ctx;\n\n\tinst->vpu.id = SCP_IPI_VDEC_LAT;\n\tinst->vpu.core_id = SCP_IPI_VDEC_CORE;\n\tinst->vpu.ctx = ctx;\n\tinst->vpu.codec_type = ctx->current_codec;\n\tinst->vpu.capture_type = ctx->capture_fourcc;\n\n\terr = vpu_dec_init(&inst->vpu);\n\tif (err) {\n\t\tmtk_vdec_err(ctx, \"vdec_h264 init err=%d\", err);\n\t\tgoto error_free_inst;\n\t}\n\n\tvsi_size = round_up(sizeof(struct vdec_h264_slice_vsi), VCODEC_DEC_ALIGNED_64);\n\tinst->vsi = inst->vpu.vsi;\n\tinst->vsi_core =\n\t\t(struct vdec_h264_slice_vsi *)(((char *)inst->vpu.vsi) + vsi_size);\n\tinst->resolution_changed = true;\n\tinst->realloc_mv_buf = true;\n\n\tmtk_vdec_debug(ctx, \"lat struct size = %d,%d,%d,%d vsi: %d\\n\",\n\t\t       (int)sizeof(struct mtk_h264_sps_param),\n\t\t       (int)sizeof(struct mtk_h264_pps_param),\n\t\t       (int)sizeof(struct vdec_h264_slice_lat_dec_param),\n\t\t       (int)sizeof(struct mtk_h264_dpb_info),\n\t\t       vsi_size);\n\tmtk_vdec_debug(ctx, \"lat H264 instance >> %p, codec_type = 0x%x\",\n\t\t       inst, inst->vpu.codec_type);\n\n\tctx->drv_handle = inst;\n\treturn 0;\n\nerror_free_inst:\n\tkfree(inst);\n\treturn err;\n}\n\nstatic void vdec_h264_slice_deinit(void *h_vdec)\n{\n\tstruct vdec_h264_slice_inst *inst = h_vdec;\n\n\tvpu_dec_deinit(&inst->vpu);\n\tvdec_h264_slice_free_mv_buf(inst);\n\tvdec_msg_queue_deinit(&inst->ctx->msg_queue, inst->ctx);\n\n\tkfree(inst);\n}\n\nstatic int vdec_h264_slice_core_decode(struct vdec_lat_buf *lat_buf)\n{\n\tstruct vdec_fb *fb;\n\tu64 vdec_fb_va;\n\tu64 y_fb_dma, c_fb_dma;\n\tint err, timeout, i;\n\tstruct mtk_vcodec_dec_ctx *ctx = lat_buf->ctx;\n\tstruct vdec_h264_slice_inst *inst = ctx->drv_handle;\n\tstruct vb2_v4l2_buffer *vb2_v4l2;\n\tstruct vdec_h264_slice_share_info *share_info = lat_buf->private_data;\n\tstruct mtk_vcodec_mem *mem;\n\tstruct vdec_vpu_inst *vpu = &inst->vpu;\n\n\tmtk_vdec_debug(ctx, \"[h264-core] vdec_h264 core decode\");\n\tmemcpy(&inst->vsi_core->h264_slice_params, &share_info->h264_slice_params,\n\t       sizeof(share_info->h264_slice_params));\n\n\tfb = ctx->dev->vdec_pdata->get_cap_buffer(ctx);\n\tif (!fb) {\n\t\terr = -EBUSY;\n\t\tmtk_vdec_err(ctx, \"fb buffer is NULL\");\n\t\tgoto vdec_dec_end;\n\t}\n\n\tvdec_fb_va = (unsigned long)fb;\n\ty_fb_dma = (u64)fb->base_y.dma_addr;\n\tif (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 1)\n\t\tc_fb_dma =\n\t\t\ty_fb_dma + inst->ctx->picinfo.buf_w * inst->ctx->picinfo.buf_h;\n\telse\n\t\tc_fb_dma = (u64)fb->base_c.dma_addr;\n\n\tmtk_vdec_debug(ctx, \"[h264-core] y/c addr = 0x%llx 0x%llx\", y_fb_dma, c_fb_dma);\n\n\tinst->vsi_core->dec.y_fb_dma = y_fb_dma;\n\tinst->vsi_core->dec.c_fb_dma = c_fb_dma;\n\tinst->vsi_core->dec.vdec_fb_va = vdec_fb_va;\n\tinst->vsi_core->dec.nal_info = share_info->nal_info;\n\tinst->vsi_core->wdma_start_addr =\n\t\tlat_buf->ctx->msg_queue.wdma_addr.dma_addr;\n\tinst->vsi_core->wdma_end_addr =\n\t\tlat_buf->ctx->msg_queue.wdma_addr.dma_addr +\n\t\tlat_buf->ctx->msg_queue.wdma_addr.size;\n\tinst->vsi_core->wdma_err_addr = lat_buf->wdma_err_addr.dma_addr;\n\tinst->vsi_core->slice_bc_start_addr = lat_buf->slice_bc_addr.dma_addr;\n\tinst->vsi_core->slice_bc_end_addr = lat_buf->slice_bc_addr.dma_addr +\n\t\tlat_buf->slice_bc_addr.size;\n\tinst->vsi_core->trans_start = share_info->trans_start;\n\tinst->vsi_core->trans_end = share_info->trans_end;\n\tfor (i = 0; i < H264_MAX_MV_NUM; i++) {\n\t\tmem = &inst->mv_buf[i];\n\t\tinst->vsi_core->mv_buf_dma[i] = mem->dma_addr;\n\t}\n\n\tvb2_v4l2 = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\n\tv4l2_m2m_buf_copy_metadata(&lat_buf->ts_info, vb2_v4l2, true);\n\n\tvdec_h264_slice_fill_decode_reflist(inst, &inst->vsi_core->h264_slice_params,\n\t\t\t\t\t    share_info);\n\n\terr = vpu_dec_core(vpu);\n\tif (err) {\n\t\tmtk_vdec_err(ctx, \"core decode err=%d\", err);\n\t\tgoto vdec_dec_end;\n\t}\n\n\t \n\ttimeout = mtk_vcodec_wait_for_done_ctx(inst->ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t       WAIT_INTR_TIMEOUT_MS, MTK_VDEC_CORE);\n\tif (timeout)\n\t\tmtk_vdec_err(ctx, \"core decode timeout: pic_%d\", ctx->decoded_frame_cnt);\n\tinst->vsi_core->dec.timeout = !!timeout;\n\n\tvpu_dec_core_end(vpu);\n\tmtk_vdec_debug(ctx, \"pic[%d] crc: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\",\n\t\t       ctx->decoded_frame_cnt,\n\t\t       inst->vsi_core->dec.crc[0], inst->vsi_core->dec.crc[1],\n\t\t       inst->vsi_core->dec.crc[2], inst->vsi_core->dec.crc[3],\n\t\t       inst->vsi_core->dec.crc[4], inst->vsi_core->dec.crc[5],\n\t\t       inst->vsi_core->dec.crc[6], inst->vsi_core->dec.crc[7]);\n\nvdec_dec_end:\n\tvdec_msg_queue_update_ube_rptr(&lat_buf->ctx->msg_queue, share_info->trans_end);\n\tctx->dev->vdec_pdata->cap_to_disp(ctx, !!err, lat_buf->src_buf_req);\n\tmtk_vdec_debug(ctx, \"core decode done err=%d\", err);\n\tctx->decoded_frame_cnt++;\n\treturn 0;\n}\n\nstatic void vdec_h264_insert_startcode(struct mtk_vcodec_dec_dev *vcodec_dev, unsigned char *buf,\n\t\t\t\t       size_t *bs_size, struct mtk_h264_pps_param *pps)\n{\n\tstruct device *dev = &vcodec_dev->plat_dev->dev;\n\n\t \n\tif (pps->entropy_coding_mode_flag || *bs_size > 20 ||\n\t    !(of_device_is_compatible(dev->of_node, \"mediatek,mt8192-vcodec-dec\") ||\n\t    of_device_is_compatible(dev->of_node, \"mediatek,mt8195-vcodec-dec\")))\n\t\treturn;\n\n\tbuf[*bs_size] = 0;\n\tbuf[*bs_size + 1] = 0;\n\tbuf[*bs_size + 2] = 1;\n\tbuf[*bs_size + 3] = 0xff;\n\t(*bs_size) += 4;\n}\n\nstatic int vdec_h264_slice_lat_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t      struct vdec_fb *fb, bool *res_chg)\n{\n\tstruct vdec_h264_slice_inst *inst = h_vdec;\n\tstruct vdec_vpu_inst *vpu = &inst->vpu;\n\tstruct mtk_video_dec_buf *src_buf_info;\n\tint nal_start_idx, err, timeout = 0, i;\n\tunsigned int data[2];\n\tstruct vdec_lat_buf *lat_buf;\n\tstruct vdec_h264_slice_share_info *share_info;\n\tunsigned char *buf;\n\tstruct mtk_vcodec_mem *mem;\n\n\tif (vdec_msg_queue_init(&inst->ctx->msg_queue, inst->ctx,\n\t\t\t\tvdec_h264_slice_core_decode,\n\t\t\t\tsizeof(*share_info)))\n\t\treturn -ENOMEM;\n\n\t \n\tif (!bs) {\n\t\tvdec_msg_queue_wait_lat_buf_full(&inst->ctx->msg_queue);\n\t\treturn vpu_dec_reset(vpu);\n\t}\n\n\tif (inst->is_field_bitstream)\n\t\treturn -EINVAL;\n\n\tlat_buf = vdec_msg_queue_dqbuf(&inst->ctx->msg_queue.lat_ctx);\n\tif (!lat_buf) {\n\t\tmtk_vdec_debug(inst->ctx, \"failed to get lat buffer\");\n\t\treturn -EAGAIN;\n\t}\n\tshare_info = lat_buf->private_data;\n\tsrc_buf_info = container_of(bs, struct mtk_video_dec_buf, bs_buffer);\n\n\tbuf = (unsigned char *)bs->va;\n\tnal_start_idx = mtk_vdec_h264_find_start_code(buf, bs->size);\n\tif (nal_start_idx < 0) {\n\t\terr = -EINVAL;\n\t\tgoto err_free_fb_out;\n\t}\n\n\tinst->vsi->dec.nal_info = buf[nal_start_idx];\n\tlat_buf->src_buf_req = src_buf_info->m2m_buf.vb.vb2_buf.req_obj.req;\n\tv4l2_m2m_buf_copy_metadata(&src_buf_info->m2m_buf.vb, &lat_buf->ts_info, true);\n\n\terr = vdec_h264_slice_fill_decode_parameters(inst, share_info);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\tvdec_h264_insert_startcode(inst->ctx->dev, buf, &bs->size,\n\t\t\t\t   &share_info->h264_slice_params.pps);\n\n\tinst->vsi->dec.bs_buf_addr = (uint64_t)bs->dma_addr;\n\tinst->vsi->dec.bs_buf_size = bs->size;\n\n\t*res_chg = inst->resolution_changed;\n\tif (inst->resolution_changed) {\n\t\tmtk_vdec_debug(inst->ctx, \"- resolution changed -\");\n\t\tif (inst->realloc_mv_buf) {\n\t\t\terr = vdec_h264_slice_alloc_mv_buf(inst, &inst->ctx->picinfo);\n\t\t\tinst->realloc_mv_buf = false;\n\t\t\tif (err)\n\t\t\t\tgoto err_free_fb_out;\n\t\t}\n\t\tinst->resolution_changed = false;\n\t}\n\tfor (i = 0; i < H264_MAX_MV_NUM; i++) {\n\t\tmem = &inst->mv_buf[i];\n\t\tinst->vsi->mv_buf_dma[i] = mem->dma_addr;\n\t}\n\tinst->vsi->wdma_start_addr = lat_buf->ctx->msg_queue.wdma_addr.dma_addr;\n\tinst->vsi->wdma_end_addr = lat_buf->ctx->msg_queue.wdma_addr.dma_addr +\n\t\tlat_buf->ctx->msg_queue.wdma_addr.size;\n\tinst->vsi->wdma_err_addr = lat_buf->wdma_err_addr.dma_addr;\n\tinst->vsi->slice_bc_start_addr = lat_buf->slice_bc_addr.dma_addr;\n\tinst->vsi->slice_bc_end_addr = lat_buf->slice_bc_addr.dma_addr +\n\t\tlat_buf->slice_bc_addr.size;\n\n\tinst->vsi->trans_end = inst->ctx->msg_queue.wdma_rptr_addr;\n\tinst->vsi->trans_start = inst->ctx->msg_queue.wdma_wptr_addr;\n\tmtk_vdec_debug(inst->ctx, \"lat:trans(0x%llx 0x%llx) err:0x%llx\",\n\t\t       inst->vsi->wdma_start_addr,\n\t\t       inst->vsi->wdma_end_addr,\n\t\t       inst->vsi->wdma_err_addr);\n\n\tmtk_vdec_debug(inst->ctx, \"slice(0x%llx 0x%llx) rprt((0x%llx 0x%llx))\",\n\t\t       inst->vsi->slice_bc_start_addr,\n\t\t       inst->vsi->slice_bc_end_addr,\n\t\t       inst->vsi->trans_start,\n\t\t       inst->vsi->trans_end);\n\terr = vpu_dec_start(vpu, data, 2);\n\tif (err) {\n\t\tmtk_vdec_debug(inst->ctx, \"lat decode err: %d\", err);\n\t\tgoto err_free_fb_out;\n\t}\n\n\tshare_info->trans_end = inst->ctx->msg_queue.wdma_addr.dma_addr +\n\t\tinst->vsi->wdma_end_addr_offset;\n\tshare_info->trans_start = inst->ctx->msg_queue.wdma_wptr_addr;\n\tshare_info->nal_info = inst->vsi->dec.nal_info;\n\n\tif (IS_VDEC_INNER_RACING(inst->ctx->dev->dec_capability)) {\n\t\tmemcpy(&share_info->h264_slice_params, &inst->vsi->h264_slice_params,\n\t\t       sizeof(share_info->h264_slice_params));\n\t\tvdec_msg_queue_qbuf(&inst->ctx->msg_queue.core_ctx, lat_buf);\n\t}\n\n\t \n\ttimeout = mtk_vcodec_wait_for_done_ctx(inst->ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t       WAIT_INTR_TIMEOUT_MS, MTK_VDEC_LAT0);\n\tif (timeout)\n\t\tmtk_vdec_err(inst->ctx, \"lat decode timeout: pic_%d\", inst->slice_dec_num);\n\tinst->vsi->dec.timeout = !!timeout;\n\n\terr = vpu_dec_end(vpu);\n\tif (err == SLICE_HEADER_FULL || err == TRANS_BUFFER_FULL) {\n\t\tif (!IS_VDEC_INNER_RACING(inst->ctx->dev->dec_capability))\n\t\t\tvdec_msg_queue_qbuf(&inst->ctx->msg_queue.lat_ctx, lat_buf);\n\t\tinst->slice_dec_num++;\n\t\tmtk_vdec_err(inst->ctx, \"lat dec fail: pic_%d err:%d\", inst->slice_dec_num, err);\n\t\treturn -EINVAL;\n\t}\n\n\tshare_info->trans_end = inst->ctx->msg_queue.wdma_addr.dma_addr +\n\t\tinst->vsi->wdma_end_addr_offset;\n\tvdec_msg_queue_update_ube_wptr(&lat_buf->ctx->msg_queue, share_info->trans_end);\n\n\tif (!IS_VDEC_INNER_RACING(inst->ctx->dev->dec_capability)) {\n\t\tmemcpy(&share_info->h264_slice_params, &inst->vsi->h264_slice_params,\n\t\t       sizeof(share_info->h264_slice_params));\n\t\tvdec_msg_queue_qbuf(&inst->ctx->msg_queue.core_ctx, lat_buf);\n\t}\n\tmtk_vdec_debug(inst->ctx, \"dec num: %d lat crc: 0x%x 0x%x 0x%x\", inst->slice_dec_num,\n\t\t       inst->vsi->dec.crc[0], inst->vsi->dec.crc[1], inst->vsi->dec.crc[2]);\n\n\tinst->slice_dec_num++;\n\treturn 0;\nerr_free_fb_out:\n\tvdec_msg_queue_qbuf(&inst->ctx->msg_queue.lat_ctx, lat_buf);\n\tmtk_vdec_err(inst->ctx, \"slice dec number: %d err: %d\", inst->slice_dec_num, err);\n\treturn err;\n}\n\nstatic int vdec_h264_slice_single_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t\t struct vdec_fb *unused, bool *res_chg)\n{\n\tstruct vdec_h264_slice_inst *inst = h_vdec;\n\tstruct vdec_vpu_inst *vpu = &inst->vpu;\n\tstruct mtk_video_dec_buf *src_buf_info, *dst_buf_info;\n\tstruct vdec_fb *fb;\n\tunsigned char *buf;\n\tunsigned int data[2], i;\n\tu64 y_fb_dma, c_fb_dma;\n\tstruct mtk_vcodec_mem *mem;\n\tint err, nal_start_idx;\n\n\t \n\tif (!bs)\n\t\treturn vpu_dec_reset(vpu);\n\n\tfb = inst->ctx->dev->vdec_pdata->get_cap_buffer(inst->ctx);\n\tsrc_buf_info = container_of(bs, struct mtk_video_dec_buf, bs_buffer);\n\tdst_buf_info = container_of(fb, struct mtk_video_dec_buf, frame_buffer);\n\n\ty_fb_dma = fb ? (u64)fb->base_y.dma_addr : 0;\n\tc_fb_dma = fb ? (u64)fb->base_c.dma_addr : 0;\n\tmtk_vdec_debug(inst->ctx, \"[h264-dec] [%d] y_dma=%llx c_dma=%llx\",\n\t\t       inst->ctx->decoded_frame_cnt, y_fb_dma, c_fb_dma);\n\n\tinst->vsi_ctx.dec.bs_buf_addr = (u64)bs->dma_addr;\n\tinst->vsi_ctx.dec.bs_buf_size = bs->size;\n\tinst->vsi_ctx.dec.y_fb_dma = y_fb_dma;\n\tinst->vsi_ctx.dec.c_fb_dma = c_fb_dma;\n\tinst->vsi_ctx.dec.vdec_fb_va = (u64)(uintptr_t)fb;\n\n\tv4l2_m2m_buf_copy_metadata(&src_buf_info->m2m_buf.vb,\n\t\t\t\t   &dst_buf_info->m2m_buf.vb, true);\n\terr = get_vdec_sig_decode_parameters(inst);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\tbuf = (unsigned char *)bs->va;\n\tnal_start_idx = mtk_vdec_h264_find_start_code(buf, bs->size);\n\tif (nal_start_idx < 0) {\n\t\terr = -EINVAL;\n\t\tgoto err_free_fb_out;\n\t}\n\tinst->vsi_ctx.dec.nal_info = buf[nal_start_idx];\n\n\t*res_chg = inst->resolution_changed;\n\tif (inst->resolution_changed) {\n\t\tmtk_vdec_debug(inst->ctx, \"- resolution changed -\");\n\t\tif (inst->realloc_mv_buf) {\n\t\t\terr = vdec_h264_slice_alloc_mv_buf(inst, &inst->ctx->picinfo);\n\t\t\tinst->realloc_mv_buf = false;\n\t\t\tif (err)\n\t\t\t\tgoto err_free_fb_out;\n\t\t}\n\t\tinst->resolution_changed = false;\n\n\t\tfor (i = 0; i < H264_MAX_MV_NUM; i++) {\n\t\t\tmem = &inst->mv_buf[i];\n\t\t\tinst->vsi_ctx.mv_buf_dma[i] = mem->dma_addr;\n\t\t}\n\t}\n\n\tmemcpy(inst->vpu.vsi, &inst->vsi_ctx, sizeof(inst->vsi_ctx));\n\terr = vpu_dec_start(vpu, data, 2);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\t \n\terr = mtk_vcodec_wait_for_done_ctx(inst->ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t   WAIT_INTR_TIMEOUT_MS, MTK_VDEC_CORE);\n\tif (err)\n\t\tmtk_vdec_err(inst->ctx, \"decode timeout: pic_%d\", inst->ctx->decoded_frame_cnt);\n\n\tinst->vsi->dec.timeout = !!err;\n\terr = vpu_dec_end(vpu);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\tmemcpy(&inst->vsi_ctx, inst->vpu.vsi, sizeof(inst->vsi_ctx));\n\tmtk_vdec_debug(inst->ctx, \"pic[%d] crc: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\",\n\t\t       inst->ctx->decoded_frame_cnt,\n\t\t       inst->vsi_ctx.dec.crc[0], inst->vsi_ctx.dec.crc[1],\n\t\t       inst->vsi_ctx.dec.crc[2], inst->vsi_ctx.dec.crc[3],\n\t\t       inst->vsi_ctx.dec.crc[4], inst->vsi_ctx.dec.crc[5],\n\t\t       inst->vsi_ctx.dec.crc[6], inst->vsi_ctx.dec.crc[7]);\n\n\tinst->ctx->decoded_frame_cnt++;\n\treturn 0;\n\nerr_free_fb_out:\n\tmtk_vdec_err(inst->ctx, \"dec frame number: %d err: %d\", inst->ctx->decoded_frame_cnt, err);\n\treturn err;\n}\n\nstatic int vdec_h264_slice_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t  struct vdec_fb *unused, bool *res_chg)\n{\n\tstruct vdec_h264_slice_inst *inst = h_vdec;\n\tint ret;\n\n\tif (!h_vdec)\n\t\treturn -EINVAL;\n\n\tif (inst->ctx->dev->vdec_pdata->hw_arch == MTK_VDEC_PURE_SINGLE_CORE)\n\t\tret = vdec_h264_slice_single_decode(h_vdec, bs, unused, res_chg);\n\telse\n\t\tret = vdec_h264_slice_lat_decode(h_vdec, bs, unused, res_chg);\n\n\treturn ret;\n}\n\nstatic int vdec_h264_slice_get_param(void *h_vdec, enum vdec_get_param_type type,\n\t\t\t\t     void *out)\n{\n\tstruct vdec_h264_slice_inst *inst = h_vdec;\n\n\tswitch (type) {\n\tcase GET_PARAM_PIC_INFO:\n\t\tvdec_h264_slice_get_pic_info(inst);\n\t\tbreak;\n\tcase GET_PARAM_DPB_SIZE:\n\t\t*(unsigned int *)out = 6;\n\t\tbreak;\n\tcase GET_PARAM_CROP_INFO:\n\t\tvdec_h264_slice_get_crop_info(inst, out);\n\t\tbreak;\n\tdefault:\n\t\tmtk_vdec_err(inst->ctx, \"invalid get parameter type=%d\", type);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nconst struct vdec_common_if vdec_h264_slice_multi_if = {\n\t.init\t\t= vdec_h264_slice_init,\n\t.decode\t\t= vdec_h264_slice_decode,\n\t.get_param\t= vdec_h264_slice_get_param,\n\t.deinit\t\t= vdec_h264_slice_deinit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}