{
  "module_name": "mtk_vcodec_dec_hw.c",
  "hash_id": "24ebb4e6900b10c2688297d0d23a5ee6a98fb9f276a6a5bc3f9fdfe33c573ab9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/mtk_vcodec_dec_hw.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include \"mtk_vcodec_dec.h\"\n#include \"mtk_vcodec_dec_hw.h\"\n#include \"mtk_vcodec_dec_pm.h\"\n#include \"../common/mtk_vcodec_intr.h\"\n\nstatic const struct of_device_id mtk_vdec_hw_match[] = {\n\t{\n\t\t.compatible = \"mediatek,mtk-vcodec-lat\",\n\t\t.data = (void *)MTK_VDEC_LAT0,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mtk-vcodec-core\",\n\t\t.data = (void *)MTK_VDEC_CORE,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mtk-vcodec-lat-soc\",\n\t\t.data = (void *)MTK_VDEC_LAT_SOC,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_vdec_hw_match);\n\nstatic int mtk_vdec_hw_prob_done(struct mtk_vcodec_dec_dev *vdec_dev)\n{\n\tstruct platform_device *pdev = vdec_dev->plat_dev;\n\tstruct device_node *subdev_node;\n\tenum mtk_vdec_hw_id hw_idx;\n\tconst struct of_device_id *of_id;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mtk_vdec_hw_match); i++) {\n\t\tof_id = &mtk_vdec_hw_match[i];\n\t\tsubdev_node = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t\t      of_id->compatible);\n\t\tif (!subdev_node)\n\t\t\tcontinue;\n\n\t\tof_node_put(subdev_node);\n\n\t\thw_idx = (enum mtk_vdec_hw_id)(uintptr_t)of_id->data;\n\t\tif (!test_bit(hw_idx, vdec_dev->subdev_bitmap)) {\n\t\t\tdev_err(&pdev->dev, \"vdec %d is not ready\", hw_idx);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t mtk_vdec_hw_irq_handler(int irq, void *priv)\n{\n\tstruct mtk_vdec_hw_dev *dev = priv;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tu32 cg_status;\n\tunsigned int dec_done_status;\n\tvoid __iomem *vdec_misc_addr = dev->reg_base[VDEC_HW_MISC] +\n\t\t\t\t\tVDEC_IRQ_CFG_REG;\n\n\tctx = mtk_vcodec_get_curr_ctx(dev->main_dev, dev->hw_idx);\n\n\t \n\tcg_status = readl(dev->reg_base[VDEC_HW_SYS] + VDEC_HW_ACTIVE_ADDR);\n\tif (cg_status & VDEC_HW_ACTIVE_MASK) {\n\t\tmtk_v4l2_vdec_err(ctx, \"vdec active is not 0x0 (0x%08x)\", cg_status);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdec_done_status = readl(vdec_misc_addr);\n\tif ((dec_done_status & MTK_VDEC_IRQ_STATUS_DEC_SUCCESS) !=\n\t    MTK_VDEC_IRQ_STATUS_DEC_SUCCESS)\n\t\treturn IRQ_HANDLED;\n\n\t \n\twritel(dec_done_status | VDEC_IRQ_CFG, vdec_misc_addr);\n\twritel(dec_done_status & ~VDEC_IRQ_CLR, vdec_misc_addr);\n\n\twake_up_dec_ctx(ctx, MTK_INST_IRQ_RECEIVED, dev->hw_idx);\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"wake up ctx %d, dec_done_status=%x\",\n\t\t\t  ctx->id, dec_done_status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mtk_vdec_hw_init_irq(struct mtk_vdec_hw_dev *dev)\n{\n\tstruct platform_device *pdev = dev->plat_dev;\n\tint ret;\n\n\tdev->dec_irq = platform_get_irq(pdev, 0);\n\tif (dev->dec_irq < 0)\n\t\treturn dev->dec_irq;\n\n\tirq_set_status_flags(dev->dec_irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(&pdev->dev, dev->dec_irq,\n\t\t\t       mtk_vdec_hw_irq_handler, 0, pdev->name, dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to install dev->dec_irq %d (%d)\",\n\t\t\tdev->dec_irq, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_vdec_hw_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_vdec_hw_dev *subdev_dev;\n\tstruct mtk_vcodec_dec_dev *main_dev;\n\tconst struct of_device_id *of_id;\n\tint hw_idx;\n\tint ret;\n\n\tif (!dev->parent) {\n\t\tdev_err(dev, \"no parent for hardware devices.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmain_dev = dev_get_drvdata(dev->parent);\n\tif (!main_dev) {\n\t\tdev_err(dev, \"failed to get parent driver data\");\n\t\treturn -EINVAL;\n\t}\n\n\tsubdev_dev = devm_kzalloc(dev, sizeof(*subdev_dev), GFP_KERNEL);\n\tif (!subdev_dev)\n\t\treturn -ENOMEM;\n\n\tsubdev_dev->plat_dev = pdev;\n\tret = mtk_vcodec_init_dec_clk(pdev, &subdev_dev->pm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_pm_runtime_enable(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tof_id = of_match_device(mtk_vdec_hw_match, dev);\n\tif (!of_id) {\n\t\tdev_err(dev, \"Can't get vdec subdev id.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thw_idx = (enum mtk_vdec_hw_id)(uintptr_t)of_id->data;\n\tif (hw_idx >= MTK_VDEC_HW_MAX) {\n\t\tdev_err(dev, \"Hardware index %d not correct.\\n\", hw_idx);\n\t\treturn -EINVAL;\n\t}\n\n\tmain_dev->subdev_dev[hw_idx] = subdev_dev;\n\tsubdev_dev->hw_idx = hw_idx;\n\tsubdev_dev->main_dev = main_dev;\n\tsubdev_dev->reg_base[VDEC_HW_SYS] = main_dev->reg_base[VDEC_HW_SYS];\n\tset_bit(subdev_dev->hw_idx, main_dev->subdev_bitmap);\n\n\tif (IS_SUPPORT_VDEC_HW_IRQ(hw_idx)) {\n\t\tret = mtk_vdec_hw_init_irq(subdev_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsubdev_dev->reg_base[VDEC_HW_MISC] =\n\t\tdevm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR((__force void *)subdev_dev->reg_base[VDEC_HW_MISC])) {\n\t\tret = PTR_ERR((__force void *)subdev_dev->reg_base[VDEC_HW_MISC]);\n\t\treturn ret;\n\t}\n\n\tif (!main_dev->subdev_prob_done)\n\t\tmain_dev->subdev_prob_done = mtk_vdec_hw_prob_done;\n\n\tplatform_set_drvdata(pdev, subdev_dev);\n\treturn 0;\n}\n\nstatic struct platform_driver mtk_vdec_driver = {\n\t.probe\t= mtk_vdec_hw_probe,\n\t.driver\t= {\n\t\t.name\t= \"mtk-vdec-comp\",\n\t\t.of_match_table = mtk_vdec_hw_match,\n\t},\n};\nmodule_platform_driver(mtk_vdec_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Mediatek video decoder hardware driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}