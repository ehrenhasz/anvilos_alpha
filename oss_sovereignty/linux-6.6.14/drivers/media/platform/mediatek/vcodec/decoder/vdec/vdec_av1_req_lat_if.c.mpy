{
  "module_name": "vdec_av1_req_lat_if.c",
  "hash_id": "2422aaa9735b2e6546a48d4764d034a2cfc4632a51e147448c3de5be100cdf88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_av1_req_lat_if.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"../mtk_vcodec_dec.h\"\n#include \"../../common/mtk_vcodec_intr.h\"\n#include \"../vdec_drv_base.h\"\n#include \"../vdec_drv_if.h\"\n#include \"../vdec_vpu_if.h\"\n\n#define AV1_MAX_FRAME_BUF_COUNT\t\t(V4L2_AV1_TOTAL_REFS_PER_FRAME + 1)\n#define AV1_TILE_BUF_SIZE\t\t64\n#define AV1_SCALE_SUBPEL_BITS\t\t10\n#define AV1_REF_SCALE_SHIFT\t\t14\n#define AV1_REF_NO_SCALE\t\tBIT(AV1_REF_SCALE_SHIFT)\n#define AV1_REF_INVALID_SCALE\t\t-1\n#define AV1_CDF_TABLE_BUFFER_SIZE\t16384\n#define AV1_PRIMARY_REF_NONE\t\t7\n\n#define AV1_INVALID_IDX\t\t\t-1\n\n#define AV1_DIV_ROUND_UP_POW2(value, n)\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\ttypeof(n) _n  = n;\t\t\t\t\\\n\ttypeof(value) _value = value;\t\t\t\\\n\t(_value + (BIT(_n) >> 1)) >> _n;\t\t\\\n})\n\n#define AV1_DIV_ROUND_UP_POW2_SIGNED(value, n)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(n) _n_  = n;\t\t\t\t\t\t\\\n\ttypeof(value) _value_ = value;\t\t\t\t\t\\\n\t(((_value_) < 0) ? -AV1_DIV_ROUND_UP_POW2(-(_value_), (_n_))\t\\\n\t\t: AV1_DIV_ROUND_UP_POW2((_value_), (_n_)));\t\t\\\n})\n\n#define BIT_FLAG(x, bit)\t\t(!!((x)->flags & (bit)))\n#define SEGMENTATION_FLAG(x, name)\t(!!((x)->flags & V4L2_AV1_SEGMENTATION_FLAG_##name))\n#define QUANT_FLAG(x, name)\t\t(!!((x)->flags & V4L2_AV1_QUANTIZATION_FLAG_##name))\n#define SEQUENCE_FLAG(x, name)\t\t(!!((x)->flags & V4L2_AV1_SEQUENCE_FLAG_##name))\n#define FH_FLAG(x, name)\t\t(!!((x)->flags & V4L2_AV1_FRAME_FLAG_##name))\n\n#define MINQ 0\n#define MAXQ 255\n\n#define DIV_LUT_PREC_BITS 14\n#define DIV_LUT_BITS 8\n#define DIV_LUT_NUM BIT(DIV_LUT_BITS)\n#define WARP_PARAM_REDUCE_BITS 6\n#define WARPEDMODEL_PREC_BITS 16\n\n#define SEG_LVL_ALT_Q 0\n#define SECONDARY_FILTER_STRENGTH_NUM_BITS 2\n\nstatic const short div_lut[DIV_LUT_NUM + 1] = {\n\t16384, 16320, 16257, 16194, 16132, 16070, 16009, 15948, 15888, 15828, 15768,\n\t15709, 15650, 15592, 15534, 15477, 15420, 15364, 15308, 15252, 15197, 15142,\n\t15087, 15033, 14980, 14926, 14873, 14821, 14769, 14717, 14665, 14614, 14564,\n\t14513, 14463, 14413, 14364, 14315, 14266, 14218, 14170, 14122, 14075, 14028,\n\t13981, 13935, 13888, 13843, 13797, 13752, 13707, 13662, 13618, 13574, 13530,\n\t13487, 13443, 13400, 13358, 13315, 13273, 13231, 13190, 13148, 13107, 13066,\n\t13026, 12985, 12945, 12906, 12866, 12827, 12788, 12749, 12710, 12672, 12633,\n\t12596, 12558, 12520, 12483, 12446, 12409, 12373, 12336, 12300, 12264, 12228,\n\t12193, 12157, 12122, 12087, 12053, 12018, 11984, 11950, 11916, 11882, 11848,\n\t11815, 11782, 11749, 11716, 11683, 11651, 11619, 11586, 11555, 11523, 11491,\n\t11460, 11429, 11398, 11367, 11336, 11305, 11275, 11245, 11215, 11185, 11155,\n\t11125, 11096, 11067, 11038, 11009, 10980, 10951, 10923, 10894, 10866, 10838,\n\t10810, 10782, 10755, 10727, 10700, 10673, 10645, 10618, 10592, 10565, 10538,\n\t10512, 10486, 10460, 10434, 10408, 10382, 10356, 10331, 10305, 10280, 10255,\n\t10230, 10205, 10180, 10156, 10131, 10107, 10082, 10058, 10034, 10010, 9986,\n\t9963,  9939,  9916,  9892,  9869,  9846,  9823,  9800,  9777,  9754,  9732,\n\t9709,  9687,  9664,  9642,  9620,  9598,  9576,  9554,  9533,  9511,  9489,\n\t9468,  9447,  9425,  9404,  9383,  9362,  9341,  9321,  9300,  9279,  9259,\n\t9239,  9218,  9198,  9178,  9158,  9138,  9118,  9098,  9079,  9059,  9039,\n\t9020,  9001,  8981,  8962,  8943,  8924,  8905,  8886,  8867,  8849,  8830,\n\t8812,  8793,  8775,  8756,  8738,  8720,  8702,  8684,  8666,  8648,  8630,\n\t8613,  8595,  8577,  8560,  8542,  8525,  8508,  8490,  8473,  8456,  8439,\n\t8422,  8405,  8389,  8372,  8355,  8339,  8322,  8306,  8289,  8273,  8257,\n\t8240,  8224,  8208,  8192,\n};\n\n \nstruct vdec_av1_slice_init_vsi {\n\tu32 architecture;\n\tu32 reserved;\n\tu64 core_vsi;\n\tu64 cdf_table_addr;\n\tu32 cdf_table_size;\n\tu64 iq_table_addr;\n\tu32 iq_table_size;\n\tu32 vsi_size;\n};\n\n \nstruct vdec_av1_slice_mem {\n\tunion {\n\t\tu64 buf;\n\t\tdma_addr_t dma_addr;\n\t};\n\tunion {\n\t\tsize_t size;\n\t\tdma_addr_t dma_addr_end;\n\t\tu64 padding;\n\t};\n};\n\n \nstruct vdec_av1_slice_state {\n\tint err;\n\tu32 full;\n\tu32 timeout;\n\tu32 perf;\n\tu32 crc[16];\n\tu32 out_size;\n};\n\n \nenum vdec_av1_slice_resolution_level {\n\tAV1_RES_NONE,\n\tAV1_RES_FHD,\n\tAV1_RES_4K,\n\tAV1_RES_8K,\n};\n\n \nenum vdec_av1_slice_frame_type {\n\tAV1_KEY_FRAME = 0,\n\tAV1_INTER_FRAME,\n\tAV1_INTRA_ONLY_FRAME,\n\tAV1_SWITCH_FRAME,\n\tAV1_FRAME_TYPES,\n};\n\n \nenum vdec_av1_slice_reference_mode {\n\tAV1_SINGLE_REFERENCE = 0,\n\tAV1_COMPOUND_REFERENCE,\n\tAV1_REFERENCE_MODE_SELECT,\n\tAV1_REFERENCE_MODES,\n};\n\n \nstruct vdec_av1_slice_tile_group {\n\tu32 num_tiles;\n\tu32 tile_size[V4L2_AV1_MAX_TILE_COUNT];\n\tu32 tile_start_offset[V4L2_AV1_MAX_TILE_COUNT];\n};\n\n \nstruct vdec_av1_slice_scale_factors {\n\tu8 is_scaled;\n\tint x_scale;\n\tint y_scale;\n\tint x_step;\n\tint y_step;\n};\n\n \nstruct vdec_av1_slice_frame_refs {\n\tint ref_fb_idx;\n\tint ref_map_idx;\n\tstruct vdec_av1_slice_scale_factors scale_factors;\n};\n\n \nstruct vdec_av1_slice_gm {\n\tint wmtype;\n\tint wmmat[8];\n\tshort alpha;\n\tshort beta;\n\tshort gamma;\n\tshort delta;\n\tchar invalid;\n};\n\n \nstruct vdec_av1_slice_sm {\n\tu8 skip_mode_allowed;\n\tu8 skip_mode_present;\n\tint skip_mode_frame[2];\n};\n\n \nstruct vdec_av1_slice_seg {\n\tu8 segmentation_enabled;\n\tu8 segmentation_update_map;\n\tu8 segmentation_temporal_update;\n\tu8 segmentation_update_data;\n\tint feature_data[V4L2_AV1_MAX_SEGMENTS][V4L2_AV1_SEG_LVL_MAX];\n\tu16 feature_enabled_mask[V4L2_AV1_MAX_SEGMENTS];\n\tint segid_preskip;\n\tint last_active_segid;\n};\n\n \nstruct vdec_av1_slice_delta_q_lf {\n\tu8 delta_q_present;\n\tu8 delta_q_res;\n\tu8 delta_lf_present;\n\tu8 delta_lf_res;\n\tu8 delta_lf_multi;\n};\n\n \nstruct vdec_av1_slice_quantization {\n\tint base_q_idx;\n\tint qindex[V4L2_AV1_MAX_SEGMENTS];\n\tint delta_qydc;\n\tint delta_qudc;\n\tint delta_quac;\n\tint delta_qvdc;\n\tint delta_qvac;\n\tu8 using_qmatrix;\n\tu8 qm_y;\n\tu8 qm_u;\n\tu8 qm_v;\n};\n\n \nstruct vdec_av1_slice_lr {\n\tu8 use_lr;\n\tu8 use_chroma_lr;\n\tu8 frame_restoration_type[V4L2_AV1_NUM_PLANES_MAX];\n\tu32 loop_restoration_size[V4L2_AV1_NUM_PLANES_MAX];\n};\n\n \nstruct vdec_av1_slice_loop_filter {\n\tu8 loop_filter_level[4];\n\tint loop_filter_ref_deltas[V4L2_AV1_TOTAL_REFS_PER_FRAME];\n\tint loop_filter_mode_deltas[2];\n\tu8 loop_filter_sharpness;\n\tu8 loop_filter_delta_enabled;\n};\n\n \nstruct vdec_av1_slice_cdef {\n\tu8 cdef_damping;\n\tu8 cdef_y_strength[8];\n\tu8 cdef_uv_strength[8];\n\tu8 cdef_bits;\n};\n\n \nstruct vdec_av1_slice_mfmv {\n\tu32 mfmv_valid_ref[3];\n\tu32 mfmv_dir[3];\n\tint mfmv_ref_to_cur[3];\n\tint mfmv_ref_frame_idx[3];\n\tint mfmv_count;\n};\n\n \nstruct vdec_av1_slice_tile {\n\tu8 tile_cols;\n\tu8 tile_rows;\n\tint mi_col_starts[V4L2_AV1_MAX_TILE_COLS + 1];\n\tint mi_row_starts[V4L2_AV1_MAX_TILE_ROWS + 1];\n\tu8 context_update_tile_id;\n\tu8 uniform_tile_spacing_flag;\n};\n\n \nstruct vdec_av1_slice_uncompressed_header {\n\tu8 use_ref_frame_mvs;\n\tint order_hint;\n\tstruct vdec_av1_slice_gm gm[V4L2_AV1_TOTAL_REFS_PER_FRAME];\n\tu32 upscaled_width;\n\tu32 frame_width;\n\tu32 frame_height;\n\tu8 reduced_tx_set;\n\tu8 tx_mode;\n\tu8 uniform_tile_spacing_flag;\n\tu8 interpolation_filter;\n\tu8 allow_warped_motion;\n\tu8 is_motion_mode_switchable;\n\tu8 reference_mode;\n\tu8 allow_high_precision_mv;\n\tu8 allow_intra_bc;\n\tu8 force_integer_mv;\n\tu8 allow_screen_content_tools;\n\tu8 error_resilient_mode;\n\tu8 frame_type;\n\tu8 primary_ref_frame;\n\tu8 disable_frame_end_update_cdf;\n\tu32 disable_cdf_update;\n\tstruct vdec_av1_slice_sm skip_mode;\n\tstruct vdec_av1_slice_seg seg;\n\tstruct vdec_av1_slice_delta_q_lf delta_q_lf;\n\tstruct vdec_av1_slice_quantization quant;\n\tstruct vdec_av1_slice_lr lr;\n\tu32 superres_denom;\n\tstruct vdec_av1_slice_loop_filter loop_filter;\n\tstruct vdec_av1_slice_cdef cdef;\n\tstruct vdec_av1_slice_mfmv mfmv;\n\tstruct vdec_av1_slice_tile tile;\n\tu8 frame_is_intra;\n\tu8 loss_less_array[V4L2_AV1_MAX_SEGMENTS];\n\tu8 coded_loss_less;\n\tu32 mi_rows;\n\tu32 mi_cols;\n};\n\n \nstruct vdec_av1_slice_seq_header {\n\tu8 bitdepth;\n\tu8 enable_superres;\n\tu8 enable_filter_intra;\n\tu8 enable_intra_edge_filter;\n\tu8 enable_interintra_compound;\n\tu8 enable_masked_compound;\n\tu8 enable_dual_filter;\n\tu8 enable_jnt_comp;\n\tu8 mono_chrome;\n\tu8 enable_order_hint;\n\tu8 order_hint_bits;\n\tu8 use_128x128_superblock;\n\tu8 subsampling_x;\n\tu8 subsampling_y;\n\tu32 max_frame_width;\n\tu32 max_frame_height;\n};\n\n \nstruct vdec_av1_slice_frame {\n\tstruct vdec_av1_slice_uncompressed_header uh;\n\tstruct vdec_av1_slice_seq_header seq;\n\tu8 large_scale_tile;\n\tu64 cur_ts;\n\tint prev_fb_idx;\n\tu8 ref_frame_sign_bias[V4L2_AV1_TOTAL_REFS_PER_FRAME];\n\tu32 order_hints[V4L2_AV1_REFS_PER_FRAME];\n\tu32 ref_frame_valid[V4L2_AV1_REFS_PER_FRAME];\n\tint ref_frame_map[V4L2_AV1_TOTAL_REFS_PER_FRAME];\n\tstruct vdec_av1_slice_frame_refs frame_refs[V4L2_AV1_REFS_PER_FRAME];\n};\n\n \nstruct vdec_av1_slice_work_buffer {\n\tstruct vdec_av1_slice_mem mv_addr;\n\tstruct vdec_av1_slice_mem cdf_addr;\n\tstruct vdec_av1_slice_mem segid_addr;\n};\n\n \nstruct vdec_av1_slice_frame_info {\n\tu8 frame_type;\n\tu8 frame_is_intra;\n\tint order_hint;\n\tu32 order_hints[V4L2_AV1_REFS_PER_FRAME];\n\tu32 upscaled_width;\n\tu32 pic_pitch;\n\tu32 frame_width;\n\tu32 frame_height;\n\tu32 mi_rows;\n\tu32 mi_cols;\n\tint ref_count;\n};\n\n \nstruct vdec_av1_slice_slot {\n\tstruct vdec_av1_slice_frame_info frame_info[AV1_MAX_FRAME_BUF_COUNT];\n\tu64 timestamp[AV1_MAX_FRAME_BUF_COUNT];\n};\n\n \nstruct vdec_av1_slice_fb {\n\tstruct vdec_av1_slice_mem y;\n\tstruct vdec_av1_slice_mem c;\n};\n\n \nstruct vdec_av1_slice_vsi {\n\t \n\tstruct vdec_av1_slice_mem bs;\n\tstruct vdec_av1_slice_work_buffer work_buffer[AV1_MAX_FRAME_BUF_COUNT];\n\tstruct vdec_av1_slice_mem cdf_table;\n\tstruct vdec_av1_slice_mem cdf_tmp;\n\t \n\tstruct vdec_av1_slice_mem rd_mv;\n\tstruct vdec_av1_slice_mem ube;\n\tstruct vdec_av1_slice_mem trans;\n\tstruct vdec_av1_slice_mem err_map;\n\tstruct vdec_av1_slice_mem row_info;\n\t \n\tstruct vdec_av1_slice_fb fb;\n\tstruct vdec_av1_slice_fb ref[V4L2_AV1_REFS_PER_FRAME];\n\tstruct vdec_av1_slice_mem iq_table;\n\t \n\tstruct vdec_av1_slice_mem tile;\n\tstruct vdec_av1_slice_slot slots;\n\ts8 slot_id;\n\tstruct vdec_av1_slice_frame frame;\n\tstruct vdec_av1_slice_state state;\n\tu32 cur_lst_tile_id;\n};\n\n \nstruct vdec_av1_slice_pfc {\n\tstruct vdec_av1_slice_vsi vsi;\n\tu64 ref_idx[V4L2_AV1_REFS_PER_FRAME];\n\tint seq;\n};\n\n \nstruct vdec_av1_slice_instance {\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct vdec_vpu_inst vpu;\n\n\tstruct mtk_vcodec_mem iq_table;\n\tstruct mtk_vcodec_mem cdf_table;\n\n\tstruct mtk_vcodec_mem mv[AV1_MAX_FRAME_BUF_COUNT];\n\tstruct mtk_vcodec_mem cdf[AV1_MAX_FRAME_BUF_COUNT];\n\tstruct mtk_vcodec_mem seg[AV1_MAX_FRAME_BUF_COUNT];\n\tstruct mtk_vcodec_mem cdf_temp;\n\tstruct mtk_vcodec_mem tile;\n\tstruct vdec_av1_slice_slot slots;\n\tstruct vdec_av1_slice_tile_group tile_group;\n\n\t \n\tenum vdec_av1_slice_resolution_level level;\n\tu32 width;\n\tu32 height;\n\n\tu32 frame_type;\n\tu32 irq_enabled;\n\tu32 inneracing_mode;\n\n\t \n\tunion {\n\t\tstruct vdec_av1_slice_init_vsi *init_vsi;\n\t\tstruct vdec_av1_slice_vsi *vsi;\n\t};\n\tstruct vdec_av1_slice_vsi *core_vsi;\n\tint seq;\n};\n\nstatic int vdec_av1_slice_core_decode(struct vdec_lat_buf *lat_buf);\n\nstatic inline int vdec_av1_slice_get_msb(u32 n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\treturn 31 ^ __builtin_clz(n);\n}\n\nstatic inline bool vdec_av1_slice_need_scale(u32 ref_width, u32 ref_height,\n\t\t\t\t\t     u32 this_width, u32 this_height)\n{\n\treturn ((this_width << 1) >= ref_width) &&\n\t\t((this_height << 1) >= ref_height) &&\n\t\t(this_width <= (ref_width << 4)) &&\n\t\t(this_height <= (ref_height << 4));\n}\n\nstatic void *vdec_av1_get_ctrl_ptr(struct mtk_vcodec_dec_ctx *ctx, int id)\n{\n\tstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(&ctx->ctrl_hdl, id);\n\n\tif (!ctrl)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn ctrl->p_cur.p;\n}\n\nstatic int vdec_av1_slice_init_cdf_table(struct vdec_av1_slice_instance *instance)\n{\n\tu8 *remote_cdf_table;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct vdec_av1_slice_init_vsi *vsi;\n\tint ret;\n\n\tctx = instance->ctx;\n\tvsi = instance->vpu.vsi;\n\tremote_cdf_table = mtk_vcodec_fw_map_dm_addr(ctx->dev->fw_handler,\n\t\t\t\t\t\t     (u32)vsi->cdf_table_addr);\n\tif (IS_ERR(remote_cdf_table)) {\n\t\tmtk_vdec_err(ctx, \"failed to map cdf table\\n\");\n\t\treturn PTR_ERR(remote_cdf_table);\n\t}\n\n\tmtk_vdec_debug(ctx, \"map cdf table to 0x%p\\n\", remote_cdf_table);\n\n\tif (instance->cdf_table.va)\n\t\tmtk_vcodec_mem_free(ctx, &instance->cdf_table);\n\tinstance->cdf_table.size = vsi->cdf_table_size;\n\n\tret = mtk_vcodec_mem_alloc(ctx, &instance->cdf_table);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(instance->cdf_table.va, remote_cdf_table, vsi->cdf_table_size);\n\n\treturn 0;\n}\n\nstatic int vdec_av1_slice_init_iq_table(struct vdec_av1_slice_instance *instance)\n{\n\tu8 *remote_iq_table;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct vdec_av1_slice_init_vsi *vsi;\n\tint ret;\n\n\tctx = instance->ctx;\n\tvsi = instance->vpu.vsi;\n\tremote_iq_table = mtk_vcodec_fw_map_dm_addr(ctx->dev->fw_handler,\n\t\t\t\t\t\t    (u32)vsi->iq_table_addr);\n\tif (IS_ERR(remote_iq_table)) {\n\t\tmtk_vdec_err(ctx, \"failed to map iq table\\n\");\n\t\treturn PTR_ERR(remote_iq_table);\n\t}\n\n\tmtk_vdec_debug(ctx, \"map iq table to 0x%p\\n\", remote_iq_table);\n\n\tif (instance->iq_table.va)\n\t\tmtk_vcodec_mem_free(ctx, &instance->iq_table);\n\tinstance->iq_table.size = vsi->iq_table_size;\n\n\tret = mtk_vcodec_mem_alloc(ctx, &instance->iq_table);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(instance->iq_table.va, remote_iq_table, vsi->iq_table_size);\n\n\treturn 0;\n}\n\nstatic int vdec_av1_slice_get_new_slot(struct vdec_av1_slice_vsi *vsi)\n{\n\tstruct vdec_av1_slice_slot *slots = &vsi->slots;\n\tint new_slot_idx = AV1_INVALID_IDX;\n\tint i;\n\n\tfor (i = 0; i < AV1_MAX_FRAME_BUF_COUNT; i++) {\n\t\tif (slots->frame_info[i].ref_count == 0) {\n\t\t\tnew_slot_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (new_slot_idx != AV1_INVALID_IDX) {\n\t\tslots->frame_info[new_slot_idx].ref_count++;\n\t\tslots->timestamp[new_slot_idx] = vsi->frame.cur_ts;\n\t}\n\n\treturn new_slot_idx;\n}\n\nstatic inline void vdec_av1_slice_clear_fb(struct vdec_av1_slice_frame_info *frame_info)\n{\n\tmemset((void *)frame_info, 0, sizeof(struct vdec_av1_slice_frame_info));\n}\n\nstatic void vdec_av1_slice_decrease_ref_count(struct vdec_av1_slice_slot *slots, int fb_idx)\n{\n\tstruct vdec_av1_slice_frame_info *frame_info = slots->frame_info;\n\n\tframe_info[fb_idx].ref_count--;\n\tif (frame_info[fb_idx].ref_count < 0) {\n\t\tframe_info[fb_idx].ref_count = 0;\n\t\tpr_err(MTK_DBG_V4L2_STR \"av1_error: %s() fb_idx %d decrease ref_count error\\n\",\n\t\t       __func__, fb_idx);\n\t}\n\n\tvdec_av1_slice_clear_fb(&frame_info[fb_idx]);\n}\n\nstatic void vdec_av1_slice_cleanup_slots(struct vdec_av1_slice_slot *slots,\n\t\t\t\t\t struct vdec_av1_slice_frame *frame,\n\t\t\t\t\t struct v4l2_ctrl_av1_frame *ctrl_fh)\n{\n\tint slot_id, ref_id;\n\n\tfor (ref_id = 0; ref_id < V4L2_AV1_TOTAL_REFS_PER_FRAME; ref_id++)\n\t\tframe->ref_frame_map[ref_id] = AV1_INVALID_IDX;\n\n\tfor (slot_id = 0; slot_id < AV1_MAX_FRAME_BUF_COUNT; slot_id++) {\n\t\tu64 timestamp = slots->timestamp[slot_id];\n\t\tbool ref_used = false;\n\n\t\t \n\t\tif (slots->frame_info[slot_id].ref_count == 0)\n\t\t\tcontinue;\n\n\t\tfor (ref_id = 0; ref_id < V4L2_AV1_TOTAL_REFS_PER_FRAME; ref_id++) {\n\t\t\tif (ctrl_fh->reference_frame_ts[ref_id] == timestamp) {\n\t\t\t\tframe->ref_frame_map[ref_id] = slot_id;\n\t\t\t\tref_used = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!ref_used)\n\t\t\tvdec_av1_slice_decrease_ref_count(slots, slot_id);\n\t}\n}\n\nstatic void vdec_av1_slice_setup_slot(struct vdec_av1_slice_instance *instance,\n\t\t\t\t      struct vdec_av1_slice_vsi *vsi,\n\t\t\t\t      struct v4l2_ctrl_av1_frame *ctrl_fh)\n{\n\tstruct vdec_av1_slice_frame_info *cur_frame_info;\n\tstruct vdec_av1_slice_uncompressed_header *uh = &vsi->frame.uh;\n\tint ref_id;\n\n\tmemcpy(&vsi->slots, &instance->slots, sizeof(instance->slots));\n\tvdec_av1_slice_cleanup_slots(&vsi->slots, &vsi->frame, ctrl_fh);\n\tvsi->slot_id = vdec_av1_slice_get_new_slot(vsi);\n\n\tif (vsi->slot_id == AV1_INVALID_IDX) {\n\t\tmtk_v4l2_vdec_err(instance->ctx, \"warning:av1 get invalid index slot\\n\");\n\t\tvsi->slot_id = 0;\n\t}\n\tcur_frame_info = &vsi->slots.frame_info[vsi->slot_id];\n\tcur_frame_info->frame_type = uh->frame_type;\n\tcur_frame_info->frame_is_intra = ((uh->frame_type == AV1_INTRA_ONLY_FRAME) ||\n\t\t\t\t\t  (uh->frame_type == AV1_KEY_FRAME));\n\tcur_frame_info->order_hint = uh->order_hint;\n\tcur_frame_info->upscaled_width = uh->upscaled_width;\n\tcur_frame_info->pic_pitch = 0;\n\tcur_frame_info->frame_width = uh->frame_width;\n\tcur_frame_info->frame_height = uh->frame_height;\n\tcur_frame_info->mi_cols = ((uh->frame_width + 7) >> 3) << 1;\n\tcur_frame_info->mi_rows = ((uh->frame_height + 7) >> 3) << 1;\n\n\t \n\tfor (ref_id = 0; ref_id < V4L2_AV1_TOTAL_REFS_PER_FRAME; ref_id++) {\n\t\tu64 timestamp = vsi->slots.timestamp[vsi->slot_id];\n\n\t\tif (ctrl_fh->reference_frame_ts[ref_id] == timestamp)\n\t\t\tvsi->frame.ref_frame_map[ref_id] = vsi->slot_id;\n\t}\n}\n\nstatic int vdec_av1_slice_alloc_working_buffer(struct vdec_av1_slice_instance *instance,\n\t\t\t\t\t       struct vdec_av1_slice_vsi *vsi)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = instance->ctx;\n\tenum vdec_av1_slice_resolution_level level;\n\tu32 max_sb_w, max_sb_h, max_w, max_h, w, h;\n\tint i, ret;\n\n\tw = vsi->frame.uh.frame_width;\n\th = vsi->frame.uh.frame_height;\n\n\tif (w > VCODEC_DEC_4K_CODED_WIDTH || h > VCODEC_DEC_4K_CODED_HEIGHT)\n\t\t \n\t\treturn -EINVAL;\n\n\tif (w > MTK_VDEC_MAX_W || h > MTK_VDEC_MAX_H) {\n\t\t \n\t\tlevel = AV1_RES_4K;\n\t\tmax_w = VCODEC_DEC_4K_CODED_WIDTH;\n\t\tmax_h = VCODEC_DEC_4K_CODED_HEIGHT;\n\t} else {\n\t\t \n\t\tlevel = AV1_RES_FHD;\n\t\tmax_w = MTK_VDEC_MAX_W;\n\t\tmax_h = MTK_VDEC_MAX_H;\n\t}\n\n\tif (level == instance->level)\n\t\treturn 0;\n\n\tmtk_vdec_debug(ctx, \"resolution level changed from %u to %u, %ux%u\",\n\t\t       instance->level, level, w, h);\n\n\tmax_sb_w = DIV_ROUND_UP(max_w, 128);\n\tmax_sb_h = DIV_ROUND_UP(max_h, 128);\n\n\tfor (i = 0; i < AV1_MAX_FRAME_BUF_COUNT; i++) {\n\t\tif (instance->mv[i].va)\n\t\t\tmtk_vcodec_mem_free(ctx, &instance->mv[i]);\n\t\tinstance->mv[i].size = max_sb_w * max_sb_h * SZ_1K;\n\t\tret = mtk_vcodec_mem_alloc(ctx, &instance->mv[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (instance->seg[i].va)\n\t\t\tmtk_vcodec_mem_free(ctx, &instance->seg[i]);\n\t\tinstance->seg[i].size = max_sb_w * max_sb_h * 512;\n\t\tret = mtk_vcodec_mem_alloc(ctx, &instance->seg[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (instance->cdf[i].va)\n\t\t\tmtk_vcodec_mem_free(ctx, &instance->cdf[i]);\n\t\tinstance->cdf[i].size = AV1_CDF_TABLE_BUFFER_SIZE;\n\t\tret = mtk_vcodec_mem_alloc(ctx, &instance->cdf[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (!instance->cdf_temp.va) {\n\t\tinstance->cdf_temp.size = (SZ_1K * 16 * 100);\n\t\tret = mtk_vcodec_mem_alloc(ctx, &instance->cdf_temp);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tvsi->cdf_tmp.buf = instance->cdf_temp.dma_addr;\n\t\tvsi->cdf_tmp.size = instance->cdf_temp.size;\n\t}\n\n\tif (instance->tile.va)\n\t\tmtk_vcodec_mem_free(ctx, &instance->tile);\n\n\tinstance->tile.size = AV1_TILE_BUF_SIZE * V4L2_AV1_MAX_TILE_COUNT;\n\tret = mtk_vcodec_mem_alloc(ctx, &instance->tile);\n\tif (ret)\n\t\tgoto err;\n\n\tinstance->level = level;\n\treturn 0;\n\nerr:\n\tinstance->level = AV1_RES_NONE;\n\treturn ret;\n}\n\nstatic void vdec_av1_slice_free_working_buffer(struct vdec_av1_slice_instance *instance)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = instance->ctx;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(instance->mv); i++)\n\t\tmtk_vcodec_mem_free(ctx, &instance->mv[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(instance->seg); i++)\n\t\tmtk_vcodec_mem_free(ctx, &instance->seg[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(instance->cdf); i++)\n\t\tmtk_vcodec_mem_free(ctx, &instance->cdf[i]);\n\n\tmtk_vcodec_mem_free(ctx, &instance->tile);\n\tmtk_vcodec_mem_free(ctx, &instance->cdf_temp);\n\tmtk_vcodec_mem_free(ctx, &instance->cdf_table);\n\tmtk_vcodec_mem_free(ctx, &instance->iq_table);\n\n\tinstance->level = AV1_RES_NONE;\n}\n\nstatic inline void vdec_av1_slice_vsi_from_remote(struct vdec_av1_slice_vsi *vsi,\n\t\t\t\t\t\t  struct vdec_av1_slice_vsi *remote_vsi)\n{\n\tmemcpy(&vsi->trans, &remote_vsi->trans, sizeof(vsi->trans));\n\tmemcpy(&vsi->state, &remote_vsi->state, sizeof(vsi->state));\n}\n\nstatic inline void vdec_av1_slice_vsi_to_remote(struct vdec_av1_slice_vsi *vsi,\n\t\t\t\t\t\tstruct vdec_av1_slice_vsi *remote_vsi)\n{\n\tmemcpy(remote_vsi, vsi, sizeof(*vsi));\n}\n\nstatic int vdec_av1_slice_setup_lat_from_src_buf(struct vdec_av1_slice_instance *instance,\n\t\t\t\t\t\t struct vdec_av1_slice_vsi *vsi,\n\t\t\t\t\t\t struct vdec_lat_buf *lat_buf)\n{\n\tstruct vb2_v4l2_buffer *src;\n\tstruct vb2_v4l2_buffer *dst;\n\n\tsrc = v4l2_m2m_next_src_buf(instance->ctx->m2m_ctx);\n\tif (!src)\n\t\treturn -EINVAL;\n\n\tlat_buf->src_buf_req = src->vb2_buf.req_obj.req;\n\tdst = &lat_buf->ts_info;\n\tv4l2_m2m_buf_copy_metadata(src, dst, true);\n\tvsi->frame.cur_ts = dst->vb2_buf.timestamp;\n\n\treturn 0;\n}\n\nstatic short vdec_av1_slice_resolve_divisor_32(u32 D, short *shift)\n{\n\tint f;\n\tint e;\n\n\t*shift = vdec_av1_slice_get_msb(D);\n\t \n\te = D - ((u32)1 << *shift);\n\t \n\tif (*shift > DIV_LUT_BITS)\n\t\tf = AV1_DIV_ROUND_UP_POW2(e, *shift - DIV_LUT_BITS);\n\telse\n\t\tf = e << (DIV_LUT_BITS - *shift);\n\tif (f > DIV_LUT_NUM)\n\t\treturn -1;\n\t*shift += DIV_LUT_PREC_BITS;\n\t \n\treturn div_lut[f];\n}\n\nstatic void vdec_av1_slice_get_shear_params(struct vdec_av1_slice_gm *gm_params)\n{\n\tconst int *mat = gm_params->wmmat;\n\tshort shift;\n\tshort y;\n\tlong long gv, dv;\n\n\tif (gm_params->wmmat[2] <= 0)\n\t\treturn;\n\n\tgm_params->alpha = clamp_val(mat[2] - (1 << WARPEDMODEL_PREC_BITS), S16_MIN, S16_MAX);\n\tgm_params->beta = clamp_val(mat[3], S16_MIN, S16_MAX);\n\n\ty = vdec_av1_slice_resolve_divisor_32(abs(mat[2]), &shift) * (mat[2] < 0 ? -1 : 1);\n\n\tgv = ((long long)mat[4] * (1 << WARPEDMODEL_PREC_BITS)) * y;\n\tgm_params->gamma = clamp_val((int)AV1_DIV_ROUND_UP_POW2_SIGNED(gv, shift),\n\t\t\t\t     S16_MIN, S16_MAX);\n\n\tdv = ((long long)mat[3] * mat[4]) * y;\n\tgm_params->delta = clamp_val(mat[5] - (int)AV1_DIV_ROUND_UP_POW2_SIGNED(dv, shift) -\n\t\t\t\t     (1 << WARPEDMODEL_PREC_BITS), S16_MIN, S16_MAX);\n\n\tgm_params->alpha = AV1_DIV_ROUND_UP_POW2_SIGNED(gm_params->alpha, WARP_PARAM_REDUCE_BITS) *\n\t\t\t\t\t\t\t(1 << WARP_PARAM_REDUCE_BITS);\n\tgm_params->beta = AV1_DIV_ROUND_UP_POW2_SIGNED(gm_params->beta, WARP_PARAM_REDUCE_BITS) *\n\t\t\t\t\t\t       (1 << WARP_PARAM_REDUCE_BITS);\n\tgm_params->gamma = AV1_DIV_ROUND_UP_POW2_SIGNED(gm_params->gamma, WARP_PARAM_REDUCE_BITS) *\n\t\t\t\t\t\t\t(1 << WARP_PARAM_REDUCE_BITS);\n\tgm_params->delta = AV1_DIV_ROUND_UP_POW2_SIGNED(gm_params->delta, WARP_PARAM_REDUCE_BITS) *\n\t\t\t\t\t\t\t(1 << WARP_PARAM_REDUCE_BITS);\n}\n\nstatic void vdec_av1_slice_setup_gm(struct vdec_av1_slice_gm *gm,\n\t\t\t\t    struct v4l2_av1_global_motion *ctrl_gm)\n{\n\tu32 i, j;\n\n\tfor (i = 0; i < V4L2_AV1_TOTAL_REFS_PER_FRAME; i++) {\n\t\tgm[i].wmtype = ctrl_gm->type[i];\n\t\tfor (j = 0; j < 6; j++)\n\t\t\tgm[i].wmmat[j] = ctrl_gm->params[i][j];\n\n\t\tgm[i].invalid = !!(ctrl_gm->invalid & BIT(i));\n\t\tgm[i].alpha = 0;\n\t\tgm[i].beta = 0;\n\t\tgm[i].gamma = 0;\n\t\tgm[i].delta = 0;\n\t\tif (gm[i].wmtype <= V4L2_AV1_WARP_MODEL_AFFINE)\n\t\t\tvdec_av1_slice_get_shear_params(&gm[i]);\n\t}\n}\n\nstatic void vdec_av1_slice_setup_seg(struct vdec_av1_slice_seg *seg,\n\t\t\t\t     struct v4l2_av1_segmentation *ctrl_seg)\n{\n\tu32 i, j;\n\n\tseg->segmentation_enabled = SEGMENTATION_FLAG(ctrl_seg, ENABLED);\n\tseg->segmentation_update_map = SEGMENTATION_FLAG(ctrl_seg, UPDATE_MAP);\n\tseg->segmentation_temporal_update = SEGMENTATION_FLAG(ctrl_seg, TEMPORAL_UPDATE);\n\tseg->segmentation_update_data = SEGMENTATION_FLAG(ctrl_seg, UPDATE_DATA);\n\tseg->segid_preskip = SEGMENTATION_FLAG(ctrl_seg, SEG_ID_PRE_SKIP);\n\tseg->last_active_segid = ctrl_seg->last_active_seg_id;\n\n\tfor (i = 0; i < V4L2_AV1_MAX_SEGMENTS; i++) {\n\t\tseg->feature_enabled_mask[i] = ctrl_seg->feature_enabled[i];\n\t\tfor (j = 0; j < V4L2_AV1_SEG_LVL_MAX; j++)\n\t\t\tseg->feature_data[i][j] = ctrl_seg->feature_data[i][j];\n\t}\n}\n\nstatic void vdec_av1_slice_setup_quant(struct vdec_av1_slice_quantization *quant,\n\t\t\t\t       struct v4l2_av1_quantization *ctrl_quant)\n{\n\tquant->base_q_idx = ctrl_quant->base_q_idx;\n\tquant->delta_qydc = ctrl_quant->delta_q_y_dc;\n\tquant->delta_qudc = ctrl_quant->delta_q_u_dc;\n\tquant->delta_quac = ctrl_quant->delta_q_u_ac;\n\tquant->delta_qvdc = ctrl_quant->delta_q_v_dc;\n\tquant->delta_qvac = ctrl_quant->delta_q_v_ac;\n\tquant->qm_y = ctrl_quant->qm_y;\n\tquant->qm_u = ctrl_quant->qm_u;\n\tquant->qm_v = ctrl_quant->qm_v;\n\tquant->using_qmatrix = QUANT_FLAG(ctrl_quant, USING_QMATRIX);\n}\n\nstatic int vdec_av1_slice_get_qindex(struct vdec_av1_slice_uncompressed_header *uh,\n\t\t\t\t     int segmentation_id)\n{\n\tstruct vdec_av1_slice_seg *seg = &uh->seg;\n\tstruct vdec_av1_slice_quantization *quant = &uh->quant;\n\tint data = 0, qindex = 0;\n\n\tif (seg->segmentation_enabled &&\n\t    (seg->feature_enabled_mask[segmentation_id] & BIT(SEG_LVL_ALT_Q))) {\n\t\tdata = seg->feature_data[segmentation_id][SEG_LVL_ALT_Q];\n\t\tqindex = quant->base_q_idx + data;\n\t\treturn clamp_val(qindex, 0, MAXQ);\n\t}\n\n\treturn quant->base_q_idx;\n}\n\nstatic void vdec_av1_slice_setup_lr(struct vdec_av1_slice_lr *lr,\n\t\t\t\t    struct v4l2_av1_loop_restoration  *ctrl_lr)\n{\n\tint i;\n\n\tlr->use_lr = 0;\n\tlr->use_chroma_lr = 0;\n\tfor (i = 0; i < V4L2_AV1_NUM_PLANES_MAX; i++) {\n\t\tlr->frame_restoration_type[i] = ctrl_lr->frame_restoration_type[i];\n\t\tlr->loop_restoration_size[i] = ctrl_lr->loop_restoration_size[i];\n\t\tif (lr->frame_restoration_type[i]) {\n\t\t\tlr->use_lr = 1;\n\t\t\tif (i > 0)\n\t\t\t\tlr->use_chroma_lr = 1;\n\t\t}\n\t}\n}\n\nstatic void vdec_av1_slice_setup_lf(struct vdec_av1_slice_loop_filter *lf,\n\t\t\t\t    struct v4l2_av1_loop_filter *ctrl_lf)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lf->loop_filter_level); i++)\n\t\tlf->loop_filter_level[i] = ctrl_lf->level[i];\n\n\tfor (i = 0; i < V4L2_AV1_TOTAL_REFS_PER_FRAME; i++)\n\t\tlf->loop_filter_ref_deltas[i] = ctrl_lf->ref_deltas[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(lf->loop_filter_mode_deltas); i++)\n\t\tlf->loop_filter_mode_deltas[i] = ctrl_lf->mode_deltas[i];\n\n\tlf->loop_filter_sharpness = ctrl_lf->sharpness;\n\tlf->loop_filter_delta_enabled =\n\t\t   BIT_FLAG(ctrl_lf, V4L2_AV1_LOOP_FILTER_FLAG_DELTA_ENABLED);\n}\n\nstatic void vdec_av1_slice_setup_cdef(struct vdec_av1_slice_cdef *cdef,\n\t\t\t\t      struct v4l2_av1_cdef *ctrl_cdef)\n{\n\tint i;\n\n\tcdef->cdef_damping = ctrl_cdef->damping_minus_3 + 3;\n\tcdef->cdef_bits = ctrl_cdef->bits;\n\n\tfor (i = 0; i < V4L2_AV1_CDEF_MAX; i++) {\n\t\tif (ctrl_cdef->y_sec_strength[i] == 4)\n\t\t\tctrl_cdef->y_sec_strength[i] -= 1;\n\n\t\tif (ctrl_cdef->uv_sec_strength[i] == 4)\n\t\t\tctrl_cdef->uv_sec_strength[i] -= 1;\n\n\t\tcdef->cdef_y_strength[i] =\n\t\t\tctrl_cdef->y_pri_strength[i] << SECONDARY_FILTER_STRENGTH_NUM_BITS |\n\t\t\tctrl_cdef->y_sec_strength[i];\n\t\tcdef->cdef_uv_strength[i] =\n\t\t\tctrl_cdef->uv_pri_strength[i] << SECONDARY_FILTER_STRENGTH_NUM_BITS |\n\t\t\tctrl_cdef->uv_sec_strength[i];\n\t}\n}\n\nstatic void vdec_av1_slice_setup_seq(struct vdec_av1_slice_seq_header *seq,\n\t\t\t\t     struct v4l2_ctrl_av1_sequence *ctrl_seq)\n{\n\tseq->bitdepth = ctrl_seq->bit_depth;\n\tseq->max_frame_width = ctrl_seq->max_frame_width_minus_1 + 1;\n\tseq->max_frame_height = ctrl_seq->max_frame_height_minus_1 + 1;\n\tseq->enable_superres = SEQUENCE_FLAG(ctrl_seq, ENABLE_SUPERRES);\n\tseq->enable_filter_intra = SEQUENCE_FLAG(ctrl_seq, ENABLE_FILTER_INTRA);\n\tseq->enable_intra_edge_filter = SEQUENCE_FLAG(ctrl_seq, ENABLE_INTRA_EDGE_FILTER);\n\tseq->enable_interintra_compound = SEQUENCE_FLAG(ctrl_seq, ENABLE_INTERINTRA_COMPOUND);\n\tseq->enable_masked_compound = SEQUENCE_FLAG(ctrl_seq, ENABLE_MASKED_COMPOUND);\n\tseq->enable_dual_filter = SEQUENCE_FLAG(ctrl_seq, ENABLE_DUAL_FILTER);\n\tseq->enable_jnt_comp = SEQUENCE_FLAG(ctrl_seq, ENABLE_JNT_COMP);\n\tseq->mono_chrome = SEQUENCE_FLAG(ctrl_seq, MONO_CHROME);\n\tseq->enable_order_hint = SEQUENCE_FLAG(ctrl_seq, ENABLE_ORDER_HINT);\n\tseq->order_hint_bits = ctrl_seq->order_hint_bits;\n\tseq->use_128x128_superblock = SEQUENCE_FLAG(ctrl_seq, USE_128X128_SUPERBLOCK);\n\tseq->subsampling_x = SEQUENCE_FLAG(ctrl_seq, SUBSAMPLING_X);\n\tseq->subsampling_y = SEQUENCE_FLAG(ctrl_seq, SUBSAMPLING_Y);\n}\n\nstatic void vdec_av1_slice_setup_tile(struct vdec_av1_slice_frame *frame,\n\t\t\t\t      struct v4l2_av1_tile_info *ctrl_tile)\n{\n\tstruct vdec_av1_slice_seq_header *seq = &frame->seq;\n\tstruct vdec_av1_slice_tile *tile = &frame->uh.tile;\n\tu32 mib_size_log2 = seq->use_128x128_superblock ? 5 : 4;\n\tint i;\n\n\ttile->tile_cols = ctrl_tile->tile_cols;\n\ttile->tile_rows = ctrl_tile->tile_rows;\n\ttile->context_update_tile_id = ctrl_tile->context_update_tile_id;\n\ttile->uniform_tile_spacing_flag =\n\t\tBIT_FLAG(ctrl_tile, V4L2_AV1_TILE_INFO_FLAG_UNIFORM_TILE_SPACING);\n\n\tfor (i = 0; i < tile->tile_cols + 1; i++)\n\t\ttile->mi_col_starts[i] =\n\t\t\tALIGN(ctrl_tile->mi_col_starts[i], BIT(mib_size_log2)) >> mib_size_log2;\n\n\tfor (i = 0; i < tile->tile_rows + 1; i++)\n\t\ttile->mi_row_starts[i] =\n\t\t\tALIGN(ctrl_tile->mi_row_starts[i], BIT(mib_size_log2)) >> mib_size_log2;\n}\n\nstatic void vdec_av1_slice_setup_uh(struct vdec_av1_slice_instance *instance,\n\t\t\t\t    struct vdec_av1_slice_frame *frame,\n\t\t\t\t    struct v4l2_ctrl_av1_frame *ctrl_fh)\n{\n\tstruct vdec_av1_slice_uncompressed_header *uh = &frame->uh;\n\tint i;\n\n\tuh->use_ref_frame_mvs = FH_FLAG(ctrl_fh, USE_REF_FRAME_MVS);\n\tuh->order_hint = ctrl_fh->order_hint;\n\tvdec_av1_slice_setup_gm(uh->gm, &ctrl_fh->global_motion);\n\tuh->upscaled_width = ctrl_fh->upscaled_width;\n\tuh->frame_width = ctrl_fh->frame_width_minus_1 + 1;\n\tuh->frame_height = ctrl_fh->frame_height_minus_1 + 1;\n\tuh->mi_cols = ((uh->frame_width + 7) >> 3) << 1;\n\tuh->mi_rows = ((uh->frame_height + 7) >> 3) << 1;\n\tuh->reduced_tx_set = FH_FLAG(ctrl_fh, REDUCED_TX_SET);\n\tuh->tx_mode = ctrl_fh->tx_mode;\n\tuh->uniform_tile_spacing_flag =\n\t\tBIT_FLAG(&ctrl_fh->tile_info, V4L2_AV1_TILE_INFO_FLAG_UNIFORM_TILE_SPACING);\n\tuh->interpolation_filter = ctrl_fh->interpolation_filter;\n\tuh->allow_warped_motion = FH_FLAG(ctrl_fh, ALLOW_WARPED_MOTION);\n\tuh->is_motion_mode_switchable = FH_FLAG(ctrl_fh, IS_MOTION_MODE_SWITCHABLE);\n\tuh->frame_type = ctrl_fh->frame_type;\n\tuh->frame_is_intra = (uh->frame_type == V4L2_AV1_INTRA_ONLY_FRAME ||\n\t\t\t      uh->frame_type == V4L2_AV1_KEY_FRAME);\n\n\tif (!uh->frame_is_intra && FH_FLAG(ctrl_fh, REFERENCE_SELECT))\n\t\tuh->reference_mode = AV1_REFERENCE_MODE_SELECT;\n\telse\n\t\tuh->reference_mode = AV1_SINGLE_REFERENCE;\n\n\tuh->allow_high_precision_mv = FH_FLAG(ctrl_fh, ALLOW_HIGH_PRECISION_MV);\n\tuh->allow_intra_bc = FH_FLAG(ctrl_fh, ALLOW_INTRABC);\n\tuh->force_integer_mv = FH_FLAG(ctrl_fh, FORCE_INTEGER_MV);\n\tuh->allow_screen_content_tools = FH_FLAG(ctrl_fh, ALLOW_SCREEN_CONTENT_TOOLS);\n\tuh->error_resilient_mode = FH_FLAG(ctrl_fh, ERROR_RESILIENT_MODE);\n\tuh->primary_ref_frame = ctrl_fh->primary_ref_frame;\n\tuh->disable_frame_end_update_cdf =\n\t\t\tFH_FLAG(ctrl_fh, DISABLE_FRAME_END_UPDATE_CDF);\n\tuh->disable_cdf_update = FH_FLAG(ctrl_fh, DISABLE_CDF_UPDATE);\n\tuh->skip_mode.skip_mode_present = FH_FLAG(ctrl_fh, SKIP_MODE_PRESENT);\n\tuh->skip_mode.skip_mode_frame[0] =\n\t\tctrl_fh->skip_mode_frame[0] - V4L2_AV1_REF_LAST_FRAME;\n\tuh->skip_mode.skip_mode_frame[1] =\n\t\tctrl_fh->skip_mode_frame[1] - V4L2_AV1_REF_LAST_FRAME;\n\tuh->skip_mode.skip_mode_allowed = ctrl_fh->skip_mode_frame[0] ? 1 : 0;\n\n\tvdec_av1_slice_setup_seg(&uh->seg, &ctrl_fh->segmentation);\n\tuh->delta_q_lf.delta_q_present = QUANT_FLAG(&ctrl_fh->quantization, DELTA_Q_PRESENT);\n\tuh->delta_q_lf.delta_q_res = 1 << ctrl_fh->quantization.delta_q_res;\n\tuh->delta_q_lf.delta_lf_present =\n\t\tBIT_FLAG(&ctrl_fh->loop_filter, V4L2_AV1_LOOP_FILTER_FLAG_DELTA_LF_PRESENT);\n\tuh->delta_q_lf.delta_lf_res = ctrl_fh->loop_filter.delta_lf_res;\n\tuh->delta_q_lf.delta_lf_multi =\n\t\tBIT_FLAG(&ctrl_fh->loop_filter, V4L2_AV1_LOOP_FILTER_FLAG_DELTA_LF_MULTI);\n\tvdec_av1_slice_setup_quant(&uh->quant, &ctrl_fh->quantization);\n\n\tuh->coded_loss_less = 1;\n\tfor (i = 0; i < V4L2_AV1_MAX_SEGMENTS; i++) {\n\t\tuh->quant.qindex[i] = vdec_av1_slice_get_qindex(uh, i);\n\t\tuh->loss_less_array[i] =\n\t\t\t(uh->quant.qindex[i] == 0 && uh->quant.delta_qydc == 0 &&\n\t\t\tuh->quant.delta_quac == 0 && uh->quant.delta_qudc == 0 &&\n\t\t\tuh->quant.delta_qvac == 0 && uh->quant.delta_qvdc == 0);\n\n\t\tif (!uh->loss_less_array[i])\n\t\t\tuh->coded_loss_less = 0;\n\t}\n\n\tvdec_av1_slice_setup_lr(&uh->lr, &ctrl_fh->loop_restoration);\n\tuh->superres_denom = ctrl_fh->superres_denom;\n\tvdec_av1_slice_setup_lf(&uh->loop_filter, &ctrl_fh->loop_filter);\n\tvdec_av1_slice_setup_cdef(&uh->cdef, &ctrl_fh->cdef);\n\tvdec_av1_slice_setup_tile(frame, &ctrl_fh->tile_info);\n}\n\nstatic int vdec_av1_slice_setup_tile_group(struct vdec_av1_slice_instance *instance,\n\t\t\t\t\t   struct vdec_av1_slice_vsi *vsi)\n{\n\tstruct v4l2_ctrl_av1_tile_group_entry *ctrl_tge;\n\tstruct vdec_av1_slice_tile_group *tile_group = &instance->tile_group;\n\tstruct vdec_av1_slice_uncompressed_header *uh = &vsi->frame.uh;\n\tstruct vdec_av1_slice_tile *tile = &uh->tile;\n\tstruct v4l2_ctrl *ctrl;\n\tu32 tge_size;\n\tint i;\n\n\tctrl = v4l2_ctrl_find(&instance->ctx->ctrl_hdl, V4L2_CID_STATELESS_AV1_TILE_GROUP_ENTRY);\n\tif (!ctrl)\n\t\treturn -EINVAL;\n\n\ttge_size = ctrl->elems;\n\tctrl_tge = (struct v4l2_ctrl_av1_tile_group_entry *)ctrl->p_cur.p;\n\n\ttile_group->num_tiles = tile->tile_cols * tile->tile_rows;\n\n\tif (tile_group->num_tiles != tge_size ||\n\t    tile_group->num_tiles > V4L2_AV1_MAX_TILE_COUNT) {\n\t\tmtk_vdec_err(instance->ctx, \"invalid tge_size %d, tile_num:%d\\n\",\n\t\t\t     tge_size, tile_group->num_tiles);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < tge_size; i++) {\n\t\tif (i != ctrl_tge[i].tile_row * vsi->frame.uh.tile.tile_cols +\n\t\t    ctrl_tge[i].tile_col) {\n\t\t\tmtk_vdec_err(instance->ctx, \"invalid tge info %d, %d %d %d\\n\",\n\t\t\t\t     i, ctrl_tge[i].tile_row, ctrl_tge[i].tile_col,\n\t\t\t\t     vsi->frame.uh.tile.tile_rows);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttile_group->tile_size[i] = ctrl_tge[i].tile_size;\n\t\ttile_group->tile_start_offset[i] = ctrl_tge[i].tile_offset;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void vdec_av1_slice_setup_state(struct vdec_av1_slice_vsi *vsi)\n{\n\tmemset(&vsi->state, 0, sizeof(vsi->state));\n}\n\nstatic void vdec_av1_slice_setup_scale_factors(struct vdec_av1_slice_frame_refs *frame_ref,\n\t\t\t\t\t       struct vdec_av1_slice_frame_info *ref_frame_info,\n\t\t\t\t\t       struct vdec_av1_slice_uncompressed_header *uh)\n{\n\tstruct vdec_av1_slice_scale_factors *scale_factors = &frame_ref->scale_factors;\n\tu32 ref_upscaled_width = ref_frame_info->upscaled_width;\n\tu32 ref_frame_height = ref_frame_info->frame_height;\n\tu32 frame_width = uh->frame_width;\n\tu32 frame_height = uh->frame_height;\n\n\tif (!vdec_av1_slice_need_scale(ref_upscaled_width, ref_frame_height,\n\t\t\t\t       frame_width, frame_height)) {\n\t\tscale_factors->x_scale = -1;\n\t\tscale_factors->y_scale = -1;\n\t\tscale_factors->is_scaled = 0;\n\t\treturn;\n\t}\n\n\tscale_factors->x_scale =\n\t\t((ref_upscaled_width << AV1_REF_SCALE_SHIFT) + (frame_width >> 1)) / frame_width;\n\tscale_factors->y_scale =\n\t\t((ref_frame_height << AV1_REF_SCALE_SHIFT) + (frame_height >> 1)) / frame_height;\n\tscale_factors->is_scaled =\n\t\t(scale_factors->x_scale != AV1_REF_INVALID_SCALE) &&\n\t\t(scale_factors->y_scale != AV1_REF_INVALID_SCALE) &&\n\t\t(scale_factors->x_scale != AV1_REF_NO_SCALE ||\n\t\t scale_factors->y_scale != AV1_REF_NO_SCALE);\n\tscale_factors->x_step =\n\t\tAV1_DIV_ROUND_UP_POW2(scale_factors->x_scale,\n\t\t\t\t      AV1_REF_SCALE_SHIFT - AV1_SCALE_SUBPEL_BITS);\n\tscale_factors->y_step =\n\t\tAV1_DIV_ROUND_UP_POW2(scale_factors->y_scale,\n\t\t\t\t      AV1_REF_SCALE_SHIFT - AV1_SCALE_SUBPEL_BITS);\n}\n\nstatic unsigned char vdec_av1_slice_get_sign_bias(int a,\n\t\t\t\t\t\t  int b,\n\t\t\t\t\t\t  u8 enable_order_hint,\n\t\t\t\t\t\t  u8 order_hint_bits)\n{\n\tint diff = 0;\n\tint m = 0;\n\tunsigned char result = 0;\n\n\tif (!enable_order_hint)\n\t\treturn 0;\n\n\tdiff = a - b;\n\tm = 1 << (order_hint_bits - 1);\n\tdiff = (diff & (m - 1)) - (diff & m);\n\n\tif (diff > 0)\n\t\tresult = 1;\n\n\treturn result;\n}\n\nstatic void vdec_av1_slice_setup_ref(struct vdec_av1_slice_pfc *pfc,\n\t\t\t\t     struct v4l2_ctrl_av1_frame *ctrl_fh)\n{\n\tstruct vdec_av1_slice_vsi *vsi = &pfc->vsi;\n\tstruct vdec_av1_slice_frame *frame = &vsi->frame;\n\tstruct vdec_av1_slice_slot *slots = &vsi->slots;\n\tstruct vdec_av1_slice_uncompressed_header *uh = &frame->uh;\n\tstruct vdec_av1_slice_seq_header *seq = &frame->seq;\n\tstruct vdec_av1_slice_frame_info *cur_frame_info =\n\t\t&slots->frame_info[vsi->slot_id];\n\tstruct vdec_av1_slice_frame_info *frame_info;\n\tint i, slot_id;\n\n\tif (uh->frame_is_intra)\n\t\treturn;\n\n\tfor (i = 0; i < V4L2_AV1_REFS_PER_FRAME; i++) {\n\t\tint ref_idx = ctrl_fh->ref_frame_idx[i];\n\n\t\tpfc->ref_idx[i] = ctrl_fh->reference_frame_ts[ref_idx];\n\t\tslot_id = frame->ref_frame_map[ref_idx];\n\t\tframe_info = &slots->frame_info[slot_id];\n\t\tif (slot_id == AV1_INVALID_IDX) {\n\t\t\tpr_err(MTK_DBG_V4L2_STR \"cannot match reference[%d] 0x%llx\\n\", i,\n\t\t\t       ctrl_fh->reference_frame_ts[ref_idx]);\n\t\t\tframe->order_hints[i] = 0;\n\t\t\tframe->ref_frame_valid[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tframe->frame_refs[i].ref_fb_idx = slot_id;\n\t\tvdec_av1_slice_setup_scale_factors(&frame->frame_refs[i],\n\t\t\t\t\t\t   frame_info, uh);\n\t\tif (!seq->enable_order_hint)\n\t\t\tframe->ref_frame_sign_bias[i + 1] = 0;\n\t\telse\n\t\t\tframe->ref_frame_sign_bias[i + 1] =\n\t\t\t\tvdec_av1_slice_get_sign_bias(frame_info->order_hint,\n\t\t\t\t\t\t\t     uh->order_hint,\n\t\t\t\t\t\t\t     seq->enable_order_hint,\n\t\t\t\t\t\t\t     seq->order_hint_bits);\n\n\t\tframe->order_hints[i] = ctrl_fh->order_hints[i + 1];\n\t\tcur_frame_info->order_hints[i] = frame->order_hints[i];\n\t\tframe->ref_frame_valid[i] = 1;\n\t}\n}\n\nstatic void vdec_av1_slice_get_previous(struct vdec_av1_slice_vsi *vsi)\n{\n\tstruct vdec_av1_slice_frame *frame = &vsi->frame;\n\n\tif (frame->uh.primary_ref_frame == AV1_PRIMARY_REF_NONE)\n\t\tframe->prev_fb_idx = AV1_INVALID_IDX;\n\telse\n\t\tframe->prev_fb_idx = frame->frame_refs[frame->uh.primary_ref_frame].ref_fb_idx;\n}\n\nstatic inline void vdec_av1_slice_setup_operating_mode(struct vdec_av1_slice_instance *instance,\n\t\t\t\t\t\t       struct vdec_av1_slice_frame *frame)\n{\n\tframe->large_scale_tile = 0;\n}\n\nstatic int vdec_av1_slice_setup_pfc(struct vdec_av1_slice_instance *instance,\n\t\t\t\t    struct vdec_av1_slice_pfc *pfc)\n{\n\tstruct v4l2_ctrl_av1_frame *ctrl_fh;\n\tstruct v4l2_ctrl_av1_sequence *ctrl_seq;\n\tstruct vdec_av1_slice_vsi *vsi = &pfc->vsi;\n\tint ret = 0;\n\n\t \n\tctrl_fh = (struct v4l2_ctrl_av1_frame *)\n\t\t  vdec_av1_get_ctrl_ptr(instance->ctx,\n\t\t\t\t\tV4L2_CID_STATELESS_AV1_FRAME);\n\tif (IS_ERR(ctrl_fh))\n\t\treturn PTR_ERR(ctrl_fh);\n\n\tctrl_seq = (struct v4l2_ctrl_av1_sequence *)\n\t\t   vdec_av1_get_ctrl_ptr(instance->ctx,\n\t\t\t\t\t V4L2_CID_STATELESS_AV1_SEQUENCE);\n\tif (IS_ERR(ctrl_seq))\n\t\treturn PTR_ERR(ctrl_seq);\n\n\t \n\tvdec_av1_slice_setup_seq(&vsi->frame.seq, ctrl_seq);\n\tvdec_av1_slice_setup_uh(instance, &vsi->frame, ctrl_fh);\n\tvdec_av1_slice_setup_operating_mode(instance, &vsi->frame);\n\n\tvdec_av1_slice_setup_state(vsi);\n\tvdec_av1_slice_setup_slot(instance, vsi, ctrl_fh);\n\tvdec_av1_slice_setup_ref(pfc, ctrl_fh);\n\tvdec_av1_slice_get_previous(vsi);\n\n\tpfc->seq = instance->seq;\n\tinstance->seq++;\n\n\treturn ret;\n}\n\nstatic void vdec_av1_slice_setup_lat_buffer(struct vdec_av1_slice_instance *instance,\n\t\t\t\t\t    struct vdec_av1_slice_vsi *vsi,\n\t\t\t\t\t    struct mtk_vcodec_mem *bs,\n\t\t\t\t\t    struct vdec_lat_buf *lat_buf)\n{\n\tstruct vdec_av1_slice_work_buffer *work_buffer;\n\tint i;\n\n\tvsi->bs.dma_addr = bs->dma_addr;\n\tvsi->bs.size = bs->size;\n\n\tvsi->ube.dma_addr = lat_buf->ctx->msg_queue.wdma_addr.dma_addr;\n\tvsi->ube.size = lat_buf->ctx->msg_queue.wdma_addr.size;\n\tvsi->trans.dma_addr = lat_buf->ctx->msg_queue.wdma_wptr_addr;\n\t \n\tvsi->trans.dma_addr_end = lat_buf->ctx->msg_queue.wdma_rptr_addr;\n\tvsi->err_map.dma_addr = lat_buf->wdma_err_addr.dma_addr;\n\tvsi->err_map.size = lat_buf->wdma_err_addr.size;\n\tvsi->rd_mv.dma_addr = lat_buf->rd_mv_addr.dma_addr;\n\tvsi->rd_mv.size = lat_buf->rd_mv_addr.size;\n\n\tvsi->row_info.buf = 0;\n\tvsi->row_info.size = 0;\n\n\twork_buffer = vsi->work_buffer;\n\n\tfor (i = 0; i < AV1_MAX_FRAME_BUF_COUNT; i++) {\n\t\twork_buffer[i].mv_addr.buf = instance->mv[i].dma_addr;\n\t\twork_buffer[i].mv_addr.size = instance->mv[i].size;\n\t\twork_buffer[i].segid_addr.buf = instance->seg[i].dma_addr;\n\t\twork_buffer[i].segid_addr.size = instance->seg[i].size;\n\t\twork_buffer[i].cdf_addr.buf = instance->cdf[i].dma_addr;\n\t\twork_buffer[i].cdf_addr.size = instance->cdf[i].size;\n\t}\n\n\tvsi->cdf_tmp.buf = instance->cdf_temp.dma_addr;\n\tvsi->cdf_tmp.size = instance->cdf_temp.size;\n\n\tvsi->tile.buf = instance->tile.dma_addr;\n\tvsi->tile.size = instance->tile.size;\n\tmemcpy(lat_buf->tile_addr.va, instance->tile.va, 64 * instance->tile_group.num_tiles);\n\n\tvsi->cdf_table.buf = instance->cdf_table.dma_addr;\n\tvsi->cdf_table.size = instance->cdf_table.size;\n\tvsi->iq_table.buf = instance->iq_table.dma_addr;\n\tvsi->iq_table.size = instance->iq_table.size;\n}\n\nstatic void vdec_av1_slice_setup_seg_buffer(struct vdec_av1_slice_instance *instance,\n\t\t\t\t\t    struct vdec_av1_slice_vsi *vsi)\n{\n\tstruct vdec_av1_slice_uncompressed_header *uh = &vsi->frame.uh;\n\tstruct mtk_vcodec_mem *buf;\n\n\t \n\tif (uh->primary_ref_frame == AV1_PRIMARY_REF_NONE || !uh->seg.segmentation_enabled) {\n\t\tmtk_vdec_debug(instance->ctx, \"reset seg %d\\n\", vsi->slot_id);\n\t\tif (vsi->slot_id != AV1_INVALID_IDX) {\n\t\t\tbuf = &instance->seg[vsi->slot_id];\n\t\t\tmemset(buf->va, 0, buf->size);\n\t\t}\n\t}\n}\n\nstatic void vdec_av1_slice_setup_tile_buffer(struct vdec_av1_slice_instance *instance,\n\t\t\t\t\t     struct vdec_av1_slice_vsi *vsi,\n\t\t\t\t\t     struct mtk_vcodec_mem *bs)\n{\n\tstruct vdec_av1_slice_tile_group *tile_group = &instance->tile_group;\n\tstruct vdec_av1_slice_uncompressed_header *uh = &vsi->frame.uh;\n\tstruct vdec_av1_slice_tile *tile = &uh->tile;\n\tu32 tile_num, tile_row, tile_col;\n\tu32 allow_update_cdf = 0;\n\tu32 sb_boundary_x_m1 = 0, sb_boundary_y_m1 = 0;\n\tint tile_info_base;\n\tu64 tile_buf_pa;\n\tu32 *tile_info_buf = instance->tile.va;\n\tu64 pa = (u64)bs->dma_addr;\n\n\tif (uh->disable_cdf_update == 0)\n\t\tallow_update_cdf = 1;\n\n\tfor (tile_num = 0; tile_num < tile_group->num_tiles; tile_num++) {\n\t\t \n\t\ttile_info_base = (AV1_TILE_BUF_SIZE * tile_num) >> 2;\n\t\ttile_row = tile_num / tile->tile_cols;\n\t\ttile_col = tile_num % tile->tile_cols;\n\t\ttile_info_buf[tile_info_base + 0] = (tile_group->tile_size[tile_num] << 3);\n\t\ttile_buf_pa = pa + tile_group->tile_start_offset[tile_num];\n\n\t\t \n\t\ttile_info_buf[tile_info_base + 1] = (tile_buf_pa & 0xFFFFFFF0ull) |\n\t\t\t((tile_buf_pa & 0xF00000000ull) >> 32);\n\t\ttile_info_buf[tile_info_base + 2] = (tile_buf_pa & 0xFull) << 3;\n\n\t\tsb_boundary_x_m1 =\n\t\t\t(tile->mi_col_starts[tile_col + 1] - tile->mi_col_starts[tile_col] - 1) &\n\t\t\t0x3f;\n\t\tsb_boundary_y_m1 =\n\t\t\t(tile->mi_row_starts[tile_row + 1] - tile->mi_row_starts[tile_row] - 1) &\n\t\t\t0x1ff;\n\n\t\ttile_info_buf[tile_info_base + 3] = (sb_boundary_y_m1 << 7) | sb_boundary_x_m1;\n\t\ttile_info_buf[tile_info_base + 4] = ((allow_update_cdf << 18) | (1 << 16));\n\n\t\tif (tile_num == tile->context_update_tile_id &&\n\t\t    uh->disable_frame_end_update_cdf == 0)\n\t\t\ttile_info_buf[tile_info_base + 4] |= (1 << 17);\n\n\t\tmtk_vdec_debug(instance->ctx, \"// tile buf %d pos(%dx%d) offset 0x%x\\n\",\n\t\t\t       tile_num, tile_row, tile_col, tile_info_base);\n\t\tmtk_vdec_debug(instance->ctx, \"// %08x %08x %08x %08x\\n\",\n\t\t\t       tile_info_buf[tile_info_base + 0],\n\t\t\t       tile_info_buf[tile_info_base + 1],\n\t\t\t       tile_info_buf[tile_info_base + 2],\n\t\t\t       tile_info_buf[tile_info_base + 3]);\n\t\tmtk_vdec_debug(instance->ctx, \"// %08x %08x %08x %08x\\n\",\n\t\t\t       tile_info_buf[tile_info_base + 4],\n\t\t\t       tile_info_buf[tile_info_base + 5],\n\t\t\t       tile_info_buf[tile_info_base + 6],\n\t\t\t       tile_info_buf[tile_info_base + 7]);\n\t}\n}\n\nstatic int vdec_av1_slice_setup_lat(struct vdec_av1_slice_instance *instance,\n\t\t\t\t    struct mtk_vcodec_mem *bs,\n\t\t\t\t    struct vdec_lat_buf *lat_buf,\n\t\t\t\t    struct vdec_av1_slice_pfc *pfc)\n{\n\tstruct vdec_av1_slice_vsi *vsi = &pfc->vsi;\n\tint ret;\n\n\tret = vdec_av1_slice_setup_lat_from_src_buf(instance, vsi, lat_buf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vdec_av1_slice_setup_pfc(instance, pfc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vdec_av1_slice_setup_tile_group(instance, vsi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vdec_av1_slice_alloc_working_buffer(instance, vsi);\n\tif (ret)\n\t\treturn ret;\n\n\tvdec_av1_slice_setup_seg_buffer(instance, vsi);\n\tvdec_av1_slice_setup_tile_buffer(instance, vsi, bs);\n\tvdec_av1_slice_setup_lat_buffer(instance, vsi, bs, lat_buf);\n\n\treturn 0;\n}\n\nstatic int vdec_av1_slice_update_lat(struct vdec_av1_slice_instance *instance,\n\t\t\t\t     struct vdec_lat_buf *lat_buf,\n\t\t\t\t     struct vdec_av1_slice_pfc *pfc)\n{\n\tstruct vdec_av1_slice_vsi *vsi;\n\n\tvsi = &pfc->vsi;\n\tmtk_vdec_debug(instance->ctx, \"frame %u LAT CRC 0x%08x, output size is %d\\n\",\n\t\t       pfc->seq, vsi->state.crc[0], vsi->state.out_size);\n\n\t \n\tif (vsi->state.full) {\n\t\t \n\t\tif (vsi->trans.dma_addr_end - vsi->trans.dma_addr == vsi->ube.size)\n\t\t\treturn -ENOMEM;\n\t\treturn -EAGAIN;\n\t}\n\n\tinstance->width = vsi->frame.uh.upscaled_width;\n\tinstance->height = vsi->frame.uh.frame_height;\n\tinstance->frame_type = vsi->frame.uh.frame_type;\n\n\treturn 0;\n}\n\nstatic int vdec_av1_slice_setup_core_to_dst_buf(struct vdec_av1_slice_instance *instance,\n\t\t\t\t\t\tstruct vdec_lat_buf *lat_buf)\n{\n\tstruct vb2_v4l2_buffer *dst;\n\n\tdst = v4l2_m2m_next_dst_buf(instance->ctx->m2m_ctx);\n\tif (!dst)\n\t\treturn -EINVAL;\n\n\tv4l2_m2m_buf_copy_metadata(&lat_buf->ts_info, dst, true);\n\n\treturn 0;\n}\n\nstatic int vdec_av1_slice_setup_core_buffer(struct vdec_av1_slice_instance *instance,\n\t\t\t\t\t    struct vdec_av1_slice_pfc *pfc,\n\t\t\t\t\t    struct vdec_av1_slice_vsi *vsi,\n\t\t\t\t\t    struct vdec_fb *fb,\n\t\t\t\t\t    struct vdec_lat_buf *lat_buf)\n{\n\tstruct vb2_buffer *vb;\n\tstruct vb2_queue *vq;\n\tint w, h, plane, size;\n\tint i;\n\n\tplane = instance->ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes;\n\tw = vsi->frame.uh.upscaled_width;\n\th = vsi->frame.uh.frame_height;\n\tsize = ALIGN(w, VCODEC_DEC_ALIGNED_64) * ALIGN(h, VCODEC_DEC_ALIGNED_64);\n\n\t \n\tvsi->fb.y.dma_addr = fb->base_y.dma_addr;\n\tif (plane == 1)\n\t\tvsi->fb.c.dma_addr = fb->base_y.dma_addr + size;\n\telse\n\t\tvsi->fb.c.dma_addr = fb->base_c.dma_addr;\n\n\t \n\tvq = v4l2_m2m_get_vq(instance->ctx->m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\t \n\tvb = &v4l2_m2m_next_dst_buf(instance->ctx->m2m_ctx)->vb2_buf;\n\tif (!vb)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < V4L2_AV1_REFS_PER_FRAME; i++) {\n\t\tstruct vdec_av1_slice_fb *vref = &vsi->ref[i];\n\n\t\tvb = vb2_find_buffer(vq, pfc->ref_idx[i]);\n\t\tif (!vb) {\n\t\t\tmemset(vref, 0, sizeof(*vref));\n\t\t\tcontinue;\n\t\t}\n\n\t\tvref->y.dma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\t\tif (plane == 1)\n\t\t\tvref->c.dma_addr = vref->y.dma_addr + size;\n\t\telse\n\t\t\tvref->c.dma_addr = vb2_dma_contig_plane_dma_addr(vb, 1);\n\t}\n\tvsi->tile.dma_addr = lat_buf->tile_addr.dma_addr;\n\tvsi->tile.size = lat_buf->tile_addr.size;\n\n\treturn 0;\n}\n\nstatic int vdec_av1_slice_setup_core(struct vdec_av1_slice_instance *instance,\n\t\t\t\t     struct vdec_fb *fb,\n\t\t\t\t     struct vdec_lat_buf *lat_buf,\n\t\t\t\t     struct vdec_av1_slice_pfc *pfc)\n{\n\tstruct vdec_av1_slice_vsi *vsi = &pfc->vsi;\n\tint ret;\n\n\tret = vdec_av1_slice_setup_core_to_dst_buf(instance, lat_buf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vdec_av1_slice_setup_core_buffer(instance, pfc, vsi, fb, lat_buf);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int vdec_av1_slice_update_core(struct vdec_av1_slice_instance *instance,\n\t\t\t\t      struct vdec_lat_buf *lat_buf,\n\t\t\t\t      struct vdec_av1_slice_pfc *pfc)\n{\n\tstruct vdec_av1_slice_vsi *vsi = instance->core_vsi;\n\n\tmtk_vdec_debug(instance->ctx, \"frame %u Y_CRC %08x %08x %08x %08x\\n\",\n\t\t       pfc->seq, vsi->state.crc[0], vsi->state.crc[1],\n\t\t       vsi->state.crc[2], vsi->state.crc[3]);\n\tmtk_vdec_debug(instance->ctx, \"frame %u C_CRC %08x %08x %08x %08x\\n\",\n\t\t       pfc->seq, vsi->state.crc[8], vsi->state.crc[9],\n\t\t       vsi->state.crc[10], vsi->state.crc[11]);\n\n\treturn 0;\n}\n\nstatic int vdec_av1_slice_init(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct vdec_av1_slice_instance *instance;\n\tstruct vdec_av1_slice_init_vsi *vsi;\n\tint ret;\n\n\tinstance = kzalloc(sizeof(*instance), GFP_KERNEL);\n\tif (!instance)\n\t\treturn -ENOMEM;\n\n\tinstance->ctx = ctx;\n\tinstance->vpu.id = SCP_IPI_VDEC_LAT;\n\tinstance->vpu.core_id = SCP_IPI_VDEC_CORE;\n\tinstance->vpu.ctx = ctx;\n\tinstance->vpu.codec_type = ctx->current_codec;\n\n\tret = vpu_dec_init(&instance->vpu);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"failed to init vpu dec, ret %d\\n\", ret);\n\t\tgoto error_vpu_init;\n\t}\n\n\t \n\tvsi = instance->vpu.vsi;\n\tif (!vsi) {\n\t\tmtk_vdec_err(ctx, \"failed to get AV1 vsi\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_vsi;\n\t}\n\tinstance->init_vsi = vsi;\n\tinstance->core_vsi = mtk_vcodec_fw_map_dm_addr(ctx->dev->fw_handler, (u32)vsi->core_vsi);\n\n\tif (!instance->core_vsi) {\n\t\tmtk_vdec_err(ctx, \"failed to get AV1 core vsi\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_vsi;\n\t}\n\n\tif (vsi->vsi_size != sizeof(struct vdec_av1_slice_vsi))\n\t\tmtk_vdec_err(ctx, \"remote vsi size 0x%x mismatch! expected: 0x%zx\\n\",\n\t\t\t     vsi->vsi_size, sizeof(struct vdec_av1_slice_vsi));\n\n\tinstance->irq_enabled = 1;\n\tinstance->inneracing_mode = IS_VDEC_INNER_RACING(instance->ctx->dev->dec_capability);\n\n\tmtk_vdec_debug(ctx, \"vsi 0x%p core_vsi 0x%llx 0x%p, inneracing_mode %d\\n\",\n\t\t       vsi, vsi->core_vsi, instance->core_vsi, instance->inneracing_mode);\n\n\tret = vdec_av1_slice_init_cdf_table(instance);\n\tif (ret)\n\t\tgoto error_vsi;\n\n\tret = vdec_av1_slice_init_iq_table(instance);\n\tif (ret)\n\t\tgoto error_vsi;\n\n\tctx->drv_handle = instance;\n\n\treturn 0;\nerror_vsi:\n\tvpu_dec_deinit(&instance->vpu);\nerror_vpu_init:\n\tkfree(instance);\n\n\treturn ret;\n}\n\nstatic void vdec_av1_slice_deinit(void *h_vdec)\n{\n\tstruct vdec_av1_slice_instance *instance = h_vdec;\n\n\tif (!instance)\n\t\treturn;\n\tmtk_vdec_debug(instance->ctx, \"h_vdec 0x%p\\n\", h_vdec);\n\tvpu_dec_deinit(&instance->vpu);\n\tvdec_av1_slice_free_working_buffer(instance);\n\tvdec_msg_queue_deinit(&instance->ctx->msg_queue, instance->ctx);\n\tkfree(instance);\n}\n\nstatic int vdec_av1_slice_flush(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\tstruct vdec_fb *fb, bool *res_chg)\n{\n\tstruct vdec_av1_slice_instance *instance = h_vdec;\n\tint i;\n\n\tmtk_vdec_debug(instance->ctx, \"flush ...\\n\");\n\n\tvdec_msg_queue_wait_lat_buf_full(&instance->ctx->msg_queue);\n\n\tfor (i = 0; i < AV1_MAX_FRAME_BUF_COUNT; i++)\n\t\tvdec_av1_slice_clear_fb(&instance->slots.frame_info[i]);\n\n\treturn vpu_dec_reset(&instance->vpu);\n}\n\nstatic void vdec_av1_slice_get_pic_info(struct vdec_av1_slice_instance *instance)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = instance->ctx;\n\tu32 data[3];\n\n\tmtk_vdec_debug(ctx, \"w %u h %u\\n\", ctx->picinfo.pic_w, ctx->picinfo.pic_h);\n\n\tdata[0] = ctx->picinfo.pic_w;\n\tdata[1] = ctx->picinfo.pic_h;\n\tdata[2] = ctx->capture_fourcc;\n\tvpu_dec_get_param(&instance->vpu, data, 3, GET_PARAM_PIC_INFO);\n\n\tctx->picinfo.buf_w = ALIGN(ctx->picinfo.pic_w, VCODEC_DEC_ALIGNED_64);\n\tctx->picinfo.buf_h = ALIGN(ctx->picinfo.pic_h, VCODEC_DEC_ALIGNED_64);\n\tctx->picinfo.fb_sz[0] = instance->vpu.fb_sz[0];\n\tctx->picinfo.fb_sz[1] = instance->vpu.fb_sz[1];\n}\n\nstatic inline void vdec_av1_slice_get_dpb_size(struct vdec_av1_slice_instance *instance,\n\t\t\t\t\t       u32 *dpb_sz)\n{\n\t \n\t*dpb_sz = V4L2_AV1_TOTAL_REFS_PER_FRAME + 1;\n}\n\nstatic void vdec_av1_slice_get_crop_info(struct vdec_av1_slice_instance *instance,\n\t\t\t\t\t struct v4l2_rect *cr)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = instance->ctx;\n\n\tcr->left = 0;\n\tcr->top = 0;\n\tcr->width = ctx->picinfo.pic_w;\n\tcr->height = ctx->picinfo.pic_h;\n\n\tmtk_vdec_debug(ctx, \"l=%d, t=%d, w=%d, h=%d\\n\",\n\t\t       cr->left, cr->top, cr->width, cr->height);\n}\n\nstatic int vdec_av1_slice_get_param(void *h_vdec, enum vdec_get_param_type type, void *out)\n{\n\tstruct vdec_av1_slice_instance *instance = h_vdec;\n\n\tswitch (type) {\n\tcase GET_PARAM_PIC_INFO:\n\t\tvdec_av1_slice_get_pic_info(instance);\n\t\tbreak;\n\tcase GET_PARAM_DPB_SIZE:\n\t\tvdec_av1_slice_get_dpb_size(instance, out);\n\t\tbreak;\n\tcase GET_PARAM_CROP_INFO:\n\t\tvdec_av1_slice_get_crop_info(instance, out);\n\t\tbreak;\n\tdefault:\n\t\tmtk_vdec_err(instance->ctx, \"invalid get parameter type=%d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vdec_av1_slice_lat_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t     struct vdec_fb *fb, bool *res_chg)\n{\n\tstruct vdec_av1_slice_instance *instance = h_vdec;\n\tstruct vdec_lat_buf *lat_buf;\n\tstruct vdec_av1_slice_pfc *pfc;\n\tstruct vdec_av1_slice_vsi *vsi;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tint ret;\n\n\tif (!instance || !instance->ctx)\n\t\treturn -EINVAL;\n\n\tctx = instance->ctx;\n\t \n\tif (vdec_msg_queue_init(&ctx->msg_queue, ctx,\n\t\t\t\tvdec_av1_slice_core_decode, sizeof(*pfc))) {\n\t\tmtk_vdec_err(ctx, \"failed to init AV1 msg queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (!bs)\n\t\treturn vdec_av1_slice_flush(h_vdec, bs, fb, res_chg);\n\n\tlat_buf = vdec_msg_queue_dqbuf(&ctx->msg_queue.lat_ctx);\n\tif (!lat_buf) {\n\t\tmtk_vdec_err(ctx, \"failed to get AV1 lat buf\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tpfc = (struct vdec_av1_slice_pfc *)lat_buf->private_data;\n\tif (!pfc) {\n\t\tret = -EINVAL;\n\t\tgoto err_free_fb_out;\n\t}\n\tvsi = &pfc->vsi;\n\n\tret = vdec_av1_slice_setup_lat(instance, bs, lat_buf, pfc);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"failed to setup AV1 lat ret %d\\n\", ret);\n\t\tgoto err_free_fb_out;\n\t}\n\n\tvdec_av1_slice_vsi_to_remote(vsi, instance->vsi);\n\tret = vpu_dec_start(&instance->vpu, NULL, 0);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"failed to dec AV1 ret %d\\n\", ret);\n\t\tgoto err_free_fb_out;\n\t}\n\tif (instance->inneracing_mode)\n\t\tvdec_msg_queue_qbuf(&ctx->msg_queue.core_ctx, lat_buf);\n\n\tif (instance->irq_enabled) {\n\t\tret = mtk_vcodec_wait_for_done_ctx(ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t\t   WAIT_INTR_TIMEOUT_MS,\n\t\t\t\t\t\t   MTK_VDEC_LAT0);\n\t\t \n\t\tif (ret) {\n\t\t\tmtk_vdec_err(ctx, \"AV1 Frame %d decode timeout %d\\n\", pfc->seq, ret);\n\t\t\tWRITE_ONCE(instance->vsi->state.timeout, 1);\n\t\t}\n\t\tvpu_dec_end(&instance->vpu);\n\t}\n\n\tvdec_av1_slice_vsi_from_remote(vsi, instance->vsi);\n\tret = vdec_av1_slice_update_lat(instance, lat_buf, pfc);\n\n\t \n\tif (ret == -EAGAIN) {\n\t\tmtk_vdec_err(ctx, \"AV1 Frame %d trans full\\n\", pfc->seq);\n\t\tif (!instance->inneracing_mode)\n\t\t\tvdec_msg_queue_qbuf(&ctx->msg_queue.lat_ctx, lat_buf);\n\t\treturn 0;\n\t}\n\n\t \n\tif (ret == -ENOMEM || vsi->state.timeout) {\n\t\tmtk_vdec_err(ctx, \"AV1 Frame %d insufficient buffer or timeout\\n\", pfc->seq);\n\t\tif (!instance->inneracing_mode)\n\t\t\tvdec_msg_queue_qbuf(&ctx->msg_queue.lat_ctx, lat_buf);\n\t\treturn -EBUSY;\n\t}\n\tvsi->trans.dma_addr_end += ctx->msg_queue.wdma_addr.dma_addr;\n\tmtk_vdec_debug(ctx, \"lat dma 1 0x%pad 0x%pad\\n\",\n\t\t       &pfc->vsi.trans.dma_addr, &pfc->vsi.trans.dma_addr_end);\n\n\tvdec_msg_queue_update_ube_wptr(&ctx->msg_queue, vsi->trans.dma_addr_end);\n\n\tif (!instance->inneracing_mode)\n\t\tvdec_msg_queue_qbuf(&ctx->msg_queue.core_ctx, lat_buf);\n\tmemcpy(&instance->slots, &vsi->slots, sizeof(instance->slots));\n\n\treturn 0;\n\nerr_free_fb_out:\n\tvdec_msg_queue_qbuf(&ctx->msg_queue.lat_ctx, lat_buf);\n\n\tif (pfc)\n\t\tmtk_vdec_err(ctx, \"slice dec number: %d err: %d\", pfc->seq, ret);\n\n\treturn ret;\n}\n\nstatic int vdec_av1_slice_core_decode(struct vdec_lat_buf *lat_buf)\n{\n\tstruct vdec_av1_slice_instance *instance;\n\tstruct vdec_av1_slice_pfc *pfc;\n\tstruct mtk_vcodec_dec_ctx *ctx = NULL;\n\tstruct vdec_fb *fb = NULL;\n\tint ret = -EINVAL;\n\n\tif (!lat_buf)\n\t\treturn -EINVAL;\n\n\tpfc = lat_buf->private_data;\n\tctx = lat_buf->ctx;\n\tif (!pfc || !ctx)\n\t\treturn -EINVAL;\n\n\tinstance = ctx->drv_handle;\n\tif (!instance)\n\t\tgoto err;\n\n\tfb = ctx->dev->vdec_pdata->get_cap_buffer(ctx);\n\tif (!fb) {\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tret = vdec_av1_slice_setup_core(instance, fb, lat_buf, pfc);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"vdec_av1_slice_setup_core\\n\");\n\t\tgoto err;\n\t}\n\tvdec_av1_slice_vsi_to_remote(&pfc->vsi, instance->core_vsi);\n\tret = vpu_dec_core(&instance->vpu);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"vpu_dec_core\\n\");\n\t\tgoto err;\n\t}\n\n\tif (instance->irq_enabled) {\n\t\tret = mtk_vcodec_wait_for_done_ctx(ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t\t   WAIT_INTR_TIMEOUT_MS,\n\t\t\t\t\t\t   MTK_VDEC_CORE);\n\t\t \n\t\tif (ret) {\n\t\t\tmtk_vdec_err(ctx, \"AV1 frame %d core timeout\\n\", pfc->seq);\n\t\t\tWRITE_ONCE(instance->vsi->state.timeout, 1);\n\t\t}\n\t\tvpu_dec_core_end(&instance->vpu);\n\t}\n\n\tret = vdec_av1_slice_update_core(instance, lat_buf, pfc);\n\tif (ret) {\n\t\tmtk_vdec_err(ctx, \"vdec_av1_slice_update_core\\n\");\n\t\tgoto err;\n\t}\n\n\tmtk_vdec_debug(ctx, \"core dma_addr_end 0x%pad\\n\",\n\t\t       &instance->core_vsi->trans.dma_addr_end);\n\tvdec_msg_queue_update_ube_rptr(&ctx->msg_queue, instance->core_vsi->trans.dma_addr_end);\n\n\tctx->dev->vdec_pdata->cap_to_disp(ctx, 0, lat_buf->src_buf_req);\n\n\treturn 0;\n\nerr:\n\t \n\tvdec_msg_queue_update_ube_rptr(&ctx->msg_queue, pfc->vsi.trans.dma_addr_end);\n\n\tif (fb)\n\t\tctx->dev->vdec_pdata->cap_to_disp(ctx, 1, lat_buf->src_buf_req);\n\n\treturn ret;\n}\n\nconst struct vdec_common_if vdec_av1_slice_lat_if = {\n\t.init\t\t= vdec_av1_slice_init,\n\t.decode\t\t= vdec_av1_slice_lat_decode,\n\t.get_param\t= vdec_av1_slice_get_param,\n\t.deinit\t\t= vdec_av1_slice_deinit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}