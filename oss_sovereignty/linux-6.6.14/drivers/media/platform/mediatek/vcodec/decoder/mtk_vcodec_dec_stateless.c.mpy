{
  "module_name": "mtk_vcodec_dec_stateless.c",
  "hash_id": "365bfb457b33d60d3ccc9be4b28d3099b2152742a00af6dcf11b8da9baf928a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/decoder/mtk_vcodec_dec_stateless.c",
  "human_readable_source": "\n\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <linux/module.h>\n\n#include \"mtk_vcodec_dec.h\"\n#include \"mtk_vcodec_dec_pm.h\"\n#include \"vdec_drv_if.h\"\n\n \nstruct mtk_stateless_control {\n\tstruct v4l2_ctrl_config cfg;\n\tint codec_type;\n};\n\nstatic const struct mtk_stateless_control mtk_stateless_controls[] = {\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_H264_SPS,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_H264_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_H264_PPS,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_H264_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_H264_SCALING_MATRIX,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_H264_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_H264_DECODE_PARAMS,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_H264_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_MPEG_VIDEO_H264_PROFILE,\n\t\t\t.def = V4L2_MPEG_VIDEO_H264_PROFILE_MAIN,\n\t\t\t.max = V4L2_MPEG_VIDEO_H264_PROFILE_HIGH,\n\t\t\t.menu_skip_mask =\n\t\t\t\tBIT(V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE) |\n\t\t\t\tBIT(V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED),\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_H264_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_H264_DECODE_MODE,\n\t\t\t.min = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,\n\t\t\t.def = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,\n\t\t\t.max = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_H264_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_H264_START_CODE,\n\t\t\t.min = V4L2_STATELESS_H264_START_CODE_ANNEX_B,\n\t\t\t.def = V4L2_STATELESS_H264_START_CODE_ANNEX_B,\n\t\t\t.max = V4L2_STATELESS_H264_START_CODE_ANNEX_B,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_H264_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_VP8_FRAME,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_VP8_FRAME,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_MPEG_VIDEO_VP8_PROFILE,\n\t\t\t.min = V4L2_MPEG_VIDEO_VP8_PROFILE_0,\n\t\t\t.def = V4L2_MPEG_VIDEO_VP8_PROFILE_0,\n\t\t\t.max = V4L2_MPEG_VIDEO_VP8_PROFILE_3,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_VP8_FRAME,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_VP9_FRAME,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_VP9_FRAME,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_MPEG_VIDEO_VP9_PROFILE,\n\t\t\t.min = V4L2_MPEG_VIDEO_VP9_PROFILE_0,\n\t\t\t.def = V4L2_MPEG_VIDEO_VP9_PROFILE_0,\n\t\t\t.max = V4L2_MPEG_VIDEO_VP9_PROFILE_3,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_VP9_FRAME,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_SPS,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_HEVC_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_PPS,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_HEVC_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_SCALING_MATRIX,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_HEVC_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_DECODE_PARAMS,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_HEVC_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_PROFILE,\n\t\t\t.def = V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN,\n\t\t\t.max = V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10,\n\t\t\t.menu_skip_mask =\n\t\t\t\tBIT(V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE),\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_HEVC_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_DECODE_MODE,\n\t\t\t.min = V4L2_STATELESS_HEVC_DECODE_MODE_FRAME_BASED,\n\t\t\t.def = V4L2_STATELESS_HEVC_DECODE_MODE_FRAME_BASED,\n\t\t\t.max = V4L2_STATELESS_HEVC_DECODE_MODE_FRAME_BASED,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_HEVC_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_START_CODE,\n\t\t\t.min = V4L2_STATELESS_HEVC_START_CODE_ANNEX_B,\n\t\t\t.def = V4L2_STATELESS_HEVC_START_CODE_ANNEX_B,\n\t\t\t.max = V4L2_STATELESS_HEVC_START_CODE_ANNEX_B,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_HEVC_SLICE,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_AV1_SEQUENCE,\n\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_AV1_FRAME,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_AV1_FRAME,\n\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_AV1_FRAME,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_AV1_TILE_GROUP_ENTRY,\n\t\t\t.dims = { V4L2_AV1_MAX_TILE_COUNT },\n\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_AV1_FRAME,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_MPEG_VIDEO_AV1_PROFILE,\n\t\t\t.min = V4L2_MPEG_VIDEO_AV1_PROFILE_MAIN,\n\t\t\t.def = V4L2_MPEG_VIDEO_AV1_PROFILE_MAIN,\n\t\t\t.max = V4L2_MPEG_VIDEO_AV1_PROFILE_MAIN,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_AV1_FRAME,\n\t},\n\t{\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_MPEG_VIDEO_AV1_LEVEL,\n\t\t\t.min = V4L2_MPEG_VIDEO_AV1_LEVEL_2_0,\n\t\t\t.def = V4L2_MPEG_VIDEO_AV1_LEVEL_4_0,\n\t\t\t.max = V4L2_MPEG_VIDEO_AV1_LEVEL_5_1,\n\t\t},\n\t\t.codec_type = V4L2_PIX_FMT_AV1_FRAME,\n\t},\n};\n\n#define NUM_CTRLS ARRAY_SIZE(mtk_stateless_controls)\n\nstatic struct mtk_video_fmt mtk_video_formats[9];\n\nstatic struct mtk_video_fmt default_out_format;\nstatic struct mtk_video_fmt default_cap_format;\nstatic unsigned int num_formats;\n\nstatic const struct v4l2_frmsize_stepwise stepwise_fhd = {\n\t.min_width = MTK_VDEC_MIN_W,\n\t.max_width = MTK_VDEC_MAX_W,\n\t.step_width = 16,\n\t.min_height = MTK_VDEC_MIN_H,\n\t.max_height = MTK_VDEC_MAX_H,\n\t.step_height = 16\n};\n\nstatic void mtk_vdec_stateless_cap_to_disp(struct mtk_vcodec_dec_ctx *ctx, int error,\n\t\t\t\t\t   struct media_request *src_buf_req)\n{\n\tstruct vb2_v4l2_buffer *vb2_dst;\n\tenum vb2_buffer_state state;\n\n\tif (error)\n\t\tstate = VB2_BUF_STATE_ERROR;\n\telse\n\t\tstate = VB2_BUF_STATE_DONE;\n\n\tvb2_dst = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\n\tif (vb2_dst) {\n\t\tv4l2_m2m_buf_done(vb2_dst, state);\n\t\tmtk_v4l2_vdec_dbg(2, ctx, \"free frame buffer id:%d to done list\",\n\t\t\t\t  vb2_dst->vb2_buf.index);\n\t} else {\n\t\tmtk_v4l2_vdec_err(ctx, \"dst buffer is NULL\");\n\t}\n\n\tif (src_buf_req)\n\t\tv4l2_ctrl_request_complete(src_buf_req, &ctx->ctrl_hdl);\n}\n\nstatic struct vdec_fb *vdec_get_cap_buffer(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct mtk_video_dec_buf *framebuf;\n\tstruct vb2_v4l2_buffer *vb2_v4l2;\n\tstruct vb2_buffer *dst_buf;\n\tstruct vdec_fb *pfb;\n\n\tvb2_v4l2 = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\n\tif (!vb2_v4l2) {\n\t\tmtk_v4l2_vdec_dbg(1, ctx, \"[%d] dst_buf empty!!\", ctx->id);\n\t\treturn NULL;\n\t}\n\n\tdst_buf = &vb2_v4l2->vb2_buf;\n\tframebuf = container_of(vb2_v4l2, struct mtk_video_dec_buf, m2m_buf.vb);\n\n\tpfb = &framebuf->frame_buffer;\n\tpfb->base_y.va = vb2_plane_vaddr(dst_buf, 0);\n\tpfb->base_y.dma_addr = vb2_dma_contig_plane_dma_addr(dst_buf, 0);\n\tpfb->base_y.size = ctx->q_data[MTK_Q_DATA_DST].sizeimage[0];\n\n\tif (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 2) {\n\t\tpfb->base_c.va = vb2_plane_vaddr(dst_buf, 1);\n\t\tpfb->base_c.dma_addr =\n\t\t\tvb2_dma_contig_plane_dma_addr(dst_buf, 1);\n\t\tpfb->base_c.size = ctx->q_data[MTK_Q_DATA_DST].sizeimage[1];\n\t}\n\tmtk_v4l2_vdec_dbg(1, ctx,\n\t\t\t  \"id=%d Framebuf pfb=%p VA=%p Y/C_DMA=%pad_%pad Sz=%zx frame_count = %d\",\n\t\t\t  dst_buf->index, pfb, pfb->base_y.va, &pfb->base_y.dma_addr,\n\t\t\t  &pfb->base_c.dma_addr, pfb->base_y.size, ctx->decoded_frame_cnt);\n\n\treturn pfb;\n}\n\nstatic void vb2ops_vdec_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &ctx->ctrl_hdl);\n}\n\nstatic void mtk_vdec_worker(struct work_struct *work)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx =\n\t\tcontainer_of(work, struct mtk_vcodec_dec_ctx, decode_work);\n\tstruct mtk_vcodec_dec_dev *dev = ctx->dev;\n\tstruct vb2_v4l2_buffer *vb2_v4l2_src;\n\tstruct vb2_buffer *vb2_src;\n\tstruct mtk_vcodec_mem *bs_src;\n\tstruct mtk_video_dec_buf *dec_buf_src;\n\tstruct media_request *src_buf_req;\n\tenum vb2_buffer_state state;\n\tbool res_chg = false;\n\tint ret;\n\n\tvb2_v4l2_src = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\n\tif (!vb2_v4l2_src) {\n\t\tv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\n\t\tmtk_v4l2_vdec_dbg(1, ctx, \"[%d] no available source buffer\", ctx->id);\n\t\treturn;\n\t}\n\n\tvb2_src = &vb2_v4l2_src->vb2_buf;\n\tdec_buf_src = container_of(vb2_v4l2_src, struct mtk_video_dec_buf,\n\t\t\t\t   m2m_buf.vb);\n\tbs_src = &dec_buf_src->bs_buffer;\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d] (%d) id=%d, vb=%p\", ctx->id,\n\t\t\t  vb2_src->vb2_queue->type, vb2_src->index, vb2_src);\n\n\tbs_src->va = vb2_plane_vaddr(vb2_src, 0);\n\tbs_src->dma_addr = vb2_dma_contig_plane_dma_addr(vb2_src, 0);\n\tbs_src->size = (size_t)vb2_src->planes[0].bytesused;\n\tif (!bs_src->va) {\n\t\tv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\n\t\tmtk_v4l2_vdec_err(ctx, \"[%d] id=%d source buffer is NULL\", ctx->id,\n\t\t\t\t  vb2_src->index);\n\t\treturn;\n\t}\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d] Bitstream VA=%p DMA=%pad Size=%zx vb=%p\",\n\t\t\t  ctx->id, bs_src->va, &bs_src->dma_addr, bs_src->size, vb2_src);\n\t \n\tsrc_buf_req = vb2_src->req_obj.req;\n\tif (src_buf_req)\n\t\tv4l2_ctrl_request_setup(src_buf_req, &ctx->ctrl_hdl);\n\telse\n\t\tmtk_v4l2_vdec_err(ctx, \"vb2 buffer media request is NULL\");\n\n\tret = vdec_if_decode(ctx, bs_src, NULL, &res_chg);\n\tif (ret && ret != -EAGAIN) {\n\t\tmtk_v4l2_vdec_err(ctx,\n\t\t\t\t  \"[%d] decode src_buf[%d] sz=0x%zx pts=%llu ret=%d res_chg=%d\",\n\t\t\t\t  ctx->id, vb2_src->index, bs_src->size,\n\t\t\t\t  vb2_src->timestamp, ret, res_chg);\n\t\tif (ret == -EIO) {\n\t\t\tmutex_lock(&ctx->lock);\n\t\t\tdec_buf_src->error = true;\n\t\t\tmutex_unlock(&ctx->lock);\n\t\t}\n\t}\n\n\tstate = ret ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE;\n\tif (!IS_VDEC_LAT_ARCH(dev->vdec_pdata->hw_arch) ||\n\t    ctx->current_codec == V4L2_PIX_FMT_VP8_FRAME) {\n\t\tv4l2_m2m_buf_done_and_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx, state);\n\t\tif (src_buf_req)\n\t\t\tv4l2_ctrl_request_complete(src_buf_req, &ctx->ctrl_hdl);\n\t} else {\n\t\tif (ret != -EAGAIN) {\n\t\t\tv4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\t\t\tv4l2_m2m_buf_done(vb2_v4l2_src, state);\n\t\t}\n\t\tv4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);\n\t}\n}\n\nstatic void vb2ops_vdec_stateless_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vb2_v4l2 = to_vb2_v4l2_buffer(vb);\n\n\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d] (%d) id=%d, vb=%p\", ctx->id, vb->vb2_queue->type,\n\t\t\t  vb->index, vb);\n\n\tmutex_lock(&ctx->lock);\n\tv4l2_m2m_buf_queue(ctx->m2m_ctx, vb2_v4l2);\n\tmutex_unlock(&ctx->lock);\n\tif (vb->vb2_queue->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn;\n\n\t \n\tif (ctx->state == MTK_STATE_INIT) {\n\t\tctx->state = MTK_STATE_HEADER;\n\t\tmtk_v4l2_vdec_dbg(1, ctx, \"Init driver from init to header.\");\n\t} else {\n\t\tmtk_v4l2_vdec_dbg(3, ctx, \"[%d] already init driver %d\", ctx->id, ctx->state);\n\t}\n}\n\nstatic int mtk_vdec_flush_decoder(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tbool res_chg;\n\n\treturn vdec_if_decode(ctx, NULL, NULL, &res_chg);\n}\n\nstatic int mtk_vcodec_get_pic_info(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct mtk_q_data *q_data;\n\tint ret = 0;\n\n\tq_data = &ctx->q_data[MTK_Q_DATA_DST];\n\tif (q_data->fmt->num_planes == 1) {\n\t\tmtk_v4l2_vdec_err(ctx, \"[%d]Error!! 10bit mode not support one plane\", ctx->id);\n\t\treturn -EINVAL;\n\t}\n\n\tctx->capture_fourcc = q_data->fmt->fourcc;\n\tret = vdec_if_get_param(ctx, GET_PARAM_PIC_INFO, &ctx->picinfo);\n\tif (ret) {\n\t\tmtk_v4l2_vdec_err(ctx, \"[%d]Error!! Get GET_PARAM_PICTURE_INFO Fail\", ctx->id);\n\t\treturn ret;\n\t}\n\n\tctx->last_decoded_picinfo = ctx->picinfo;\n\n\tq_data->sizeimage[0] = ctx->picinfo.fb_sz[0];\n\tq_data->bytesperline[0] = ctx->picinfo.buf_w * 5 / 4;\n\n\tq_data->sizeimage[1] = ctx->picinfo.fb_sz[1];\n\tq_data->bytesperline[1] = ctx->picinfo.buf_w * 5 / 4;\n\n\tq_data->coded_width = ctx->picinfo.buf_w;\n\tq_data->coded_height = ctx->picinfo.buf_h;\n\tmtk_v4l2_vdec_dbg(1, ctx, \"[%d] wxh=%dx%d pic wxh=%dx%d sz[0]=0x%x sz[1]=0x%x\",\n\t\t\t  ctx->id, ctx->picinfo.buf_w, ctx->picinfo.buf_h,\n\t\t\t  ctx->picinfo.pic_w, ctx->picinfo.pic_h,\n\t\t\t  q_data->sizeimage[0], q_data->sizeimage[1]);\n\n\treturn ret;\n}\n\nstatic int mtk_vdec_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mtk_vcodec_dec_ctx *ctx = ctrl_to_dec_ctx(ctrl);\n\tstruct v4l2_ctrl_h264_sps *h264;\n\tstruct v4l2_ctrl_hevc_sps *h265;\n\tstruct v4l2_ctrl_vp9_frame *frame;\n\tstruct v4l2_ctrl_av1_sequence *seq;\n\tstruct v4l2_ctrl *hdr_ctrl;\n\tconst struct mtk_vcodec_dec_pdata *dec_pdata = ctx->dev->vdec_pdata;\n\tconst struct mtk_video_fmt *fmt;\n\tint i = 0, ret = 0;\n\n\thdr_ctrl = ctrl;\n\tif (!hdr_ctrl || !hdr_ctrl->p_new.p)\n\t\treturn -EINVAL;\n\n\tswitch (hdr_ctrl->id) {\n\tcase V4L2_CID_STATELESS_H264_SPS:\n\t\th264 = (struct v4l2_ctrl_h264_sps *)hdr_ctrl->p_new.p;\n\n\t\tif (h264->bit_depth_chroma_minus8 == 2 && h264->bit_depth_luma_minus8 == 2) {\n\t\t\tctx->is_10bit_bitstream = true;\n\t\t} else if (h264->bit_depth_chroma_minus8 != 0 &&\n\t\t\t   h264->bit_depth_luma_minus8 != 0) {\n\t\t\tmtk_v4l2_vdec_err(ctx, \"H264: chroma_minus8:%d, luma_minus8:%d\",\n\t\t\t\t\t  h264->bit_depth_chroma_minus8,\n\t\t\t\t\t  h264->bit_depth_luma_minus8);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_STATELESS_HEVC_SPS:\n\t\th265 = (struct v4l2_ctrl_hevc_sps *)hdr_ctrl->p_new.p;\n\n\t\tif (h265->bit_depth_chroma_minus8 == 2 && h265->bit_depth_luma_minus8 == 2) {\n\t\t\tctx->is_10bit_bitstream = true;\n\t\t} else if (h265->bit_depth_chroma_minus8 != 0 &&\n\t\t\t   h265->bit_depth_luma_minus8 != 0) {\n\t\t\tmtk_v4l2_vdec_err(ctx, \"HEVC: chroma_minus8:%d, luma_minus8:%d\",\n\t\t\t\t\t  h265->bit_depth_chroma_minus8,\n\t\t\t\t\t  h265->bit_depth_luma_minus8);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_STATELESS_VP9_FRAME:\n\t\tframe = (struct v4l2_ctrl_vp9_frame *)hdr_ctrl->p_new.p;\n\n\t\tif (frame->bit_depth == 10) {\n\t\t\tctx->is_10bit_bitstream = true;\n\t\t} else if (frame->bit_depth != 8) {\n\t\t\tmtk_v4l2_vdec_err(ctx, \"VP9: bit_depth:%d\", frame->bit_depth);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_STATELESS_AV1_SEQUENCE:\n\t\tseq = (struct v4l2_ctrl_av1_sequence *)hdr_ctrl->p_new.p;\n\n\t\tif (seq->bit_depth == 10) {\n\t\t\tctx->is_10bit_bitstream = true;\n\t\t} else if (seq->bit_depth != 8) {\n\t\t\tmtk_v4l2_vdec_err(ctx, \"AV1: bit_depth:%d\", seq->bit_depth);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tmtk_v4l2_vdec_dbg(3, ctx, \"Not supported to set ctrl id: 0x%x\\n\", hdr_ctrl->id);\n\t\treturn ret;\n\t}\n\n\tif (!ctx->is_10bit_bitstream)\n\t\treturn ret;\n\n\tfor (i = 0; i < *dec_pdata->num_formats; i++) {\n\t\tfmt = &dec_pdata->vdec_formats[i];\n\t\tif (fmt->fourcc == V4L2_PIX_FMT_MT2110R &&\n\t\t    hdr_ctrl->id == V4L2_CID_STATELESS_H264_SPS) {\n\t\t\tctx->q_data[MTK_Q_DATA_DST].fmt = fmt;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fmt->fourcc == V4L2_PIX_FMT_MT2110T &&\n\t\t    (hdr_ctrl->id == V4L2_CID_STATELESS_HEVC_SPS ||\n\t\t    hdr_ctrl->id == V4L2_CID_STATELESS_VP9_FRAME ||\n\t\t    hdr_ctrl->id == V4L2_CID_STATELESS_AV1_SEQUENCE)) {\n\t\t\tctx->q_data[MTK_Q_DATA_DST].fmt = fmt;\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = mtk_vcodec_get_pic_info(ctx);\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops mtk_vcodec_dec_ctrl_ops = {\n\t.s_ctrl = mtk_vdec_s_ctrl,\n};\n\nstatic int mtk_vcodec_dec_ctrls_setup(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tunsigned int i;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_hdl, NUM_CTRLS);\n\tif (ctx->ctrl_hdl.error) {\n\t\tmtk_v4l2_vdec_err(ctx, \"v4l2_ctrl_handler_init failed\\n\");\n\t\treturn ctx->ctrl_hdl.error;\n\t}\n\n\tfor (i = 0; i < NUM_CTRLS; i++) {\n\t\tstruct v4l2_ctrl_config cfg = mtk_stateless_controls[i].cfg;\n\t\tcfg.ops = &mtk_vcodec_dec_ctrl_ops;\n\t\tv4l2_ctrl_new_custom(&ctx->ctrl_hdl, &cfg, NULL);\n\t\tif (ctx->ctrl_hdl.error) {\n\t\t\tmtk_v4l2_vdec_err(ctx, \"Adding control %d failed %d\", i,\n\t\t\t\t\t  ctx->ctrl_hdl.error);\n\t\t\treturn ctx->ctrl_hdl.error;\n\t\t}\n\t}\n\n\tv4l2_ctrl_handler_setup(&ctx->ctrl_hdl);\n\n\treturn 0;\n}\n\nstatic int fops_media_request_validate(struct media_request *mreq)\n{\n\tconst unsigned int buffer_cnt = vb2_request_buffer_cnt(mreq);\n\n\tswitch (buffer_cnt) {\n\tcase 1:\n\t\t \n\t\tbreak;\n\tcase 0:\n\t\tpr_debug(MTK_DBG_VCODEC_STR \"No buffer provided with the request.\");\n\t\treturn -ENOENT;\n\tdefault:\n\t\tpr_debug(MTK_DBG_VCODEC_STR \"Too many buffers (%d) provided with the request.\",\n\t\t\t buffer_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\treturn vb2_request_validate(mreq);\n}\n\nconst struct media_device_ops mtk_vcodec_media_ops = {\n\t.req_validate\t= fops_media_request_validate,\n\t.req_queue\t= v4l2_m2m_request_queue,\n};\n\nstatic void mtk_vcodec_add_formats(unsigned int fourcc,\n\t\t\t\t   struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct mtk_vcodec_dec_dev *dev = ctx->dev;\n\tconst struct mtk_vcodec_dec_pdata *pdata = dev->vdec_pdata;\n\tint count_formats = *pdata->num_formats;\n\n\tswitch (fourcc) {\n\tcase V4L2_PIX_FMT_H264_SLICE:\n\tcase V4L2_PIX_FMT_VP8_FRAME:\n\tcase V4L2_PIX_FMT_VP9_FRAME:\n\tcase V4L2_PIX_FMT_HEVC_SLICE:\n\tcase V4L2_PIX_FMT_AV1_FRAME:\n\t\tmtk_video_formats[count_formats].fourcc = fourcc;\n\t\tmtk_video_formats[count_formats].type = MTK_FMT_DEC;\n\t\tmtk_video_formats[count_formats].num_planes = 1;\n\t\tmtk_video_formats[count_formats].frmsize = stepwise_fhd;\n\n\t\tif (!(ctx->dev->dec_capability & VCODEC_CAPABILITY_4K_DISABLED) &&\n\t\t    fourcc != V4L2_PIX_FMT_VP8_FRAME) {\n\t\t\tmtk_video_formats[count_formats].frmsize.max_width =\n\t\t\t\tVCODEC_DEC_4K_CODED_WIDTH;\n\t\t\tmtk_video_formats[count_formats].frmsize.max_height =\n\t\t\t\tVCODEC_DEC_4K_CODED_HEIGHT;\n\t\t}\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MM21:\n\tcase V4L2_PIX_FMT_MT21C:\n\tcase V4L2_PIX_FMT_MT2110T:\n\tcase V4L2_PIX_FMT_MT2110R:\n\t\tmtk_video_formats[count_formats].fourcc = fourcc;\n\t\tmtk_video_formats[count_formats].type = MTK_FMT_FRAME;\n\t\tmtk_video_formats[count_formats].num_planes = 2;\n\t\tbreak;\n\tdefault:\n\t\tmtk_v4l2_vdec_err(ctx, \"Can not add unsupported format type\");\n\t\treturn;\n\t}\n\n\tnum_formats++;\n\tmtk_v4l2_vdec_dbg(3, ctx, \"num_formats: %d dec_capability: 0x%x\",\n\t\t\t  count_formats, ctx->dev->dec_capability);\n}\n\nstatic void mtk_vcodec_get_supported_formats(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tint cap_format_count = 0, out_format_count = 0;\n\n\tif (num_formats)\n\t\treturn;\n\n\tif (ctx->dev->dec_capability & MTK_VDEC_FORMAT_MT21C) {\n\t\tmtk_vcodec_add_formats(V4L2_PIX_FMT_MT21C, ctx);\n\t\tcap_format_count++;\n\t}\n\tif (ctx->dev->dec_capability & MTK_VDEC_IS_SUPPORT_10BIT) {\n\t\tmtk_vcodec_add_formats(V4L2_PIX_FMT_MT2110T, ctx);\n\t\tcap_format_count++;\n\t\tmtk_vcodec_add_formats(V4L2_PIX_FMT_MT2110R, ctx);\n\t\tcap_format_count++;\n\t}\n\tif (ctx->dev->dec_capability & MTK_VDEC_FORMAT_MM21) {\n\t\tmtk_vcodec_add_formats(V4L2_PIX_FMT_MM21, ctx);\n\t\tcap_format_count++;\n\t}\n\tif (ctx->dev->dec_capability & MTK_VDEC_FORMAT_H264_SLICE) {\n\t\tmtk_vcodec_add_formats(V4L2_PIX_FMT_H264_SLICE, ctx);\n\t\tout_format_count++;\n\t}\n\tif (ctx->dev->dec_capability & MTK_VDEC_FORMAT_VP8_FRAME) {\n\t\tmtk_vcodec_add_formats(V4L2_PIX_FMT_VP8_FRAME, ctx);\n\t\tout_format_count++;\n\t}\n\tif (ctx->dev->dec_capability & MTK_VDEC_FORMAT_VP9_FRAME) {\n\t\tmtk_vcodec_add_formats(V4L2_PIX_FMT_VP9_FRAME, ctx);\n\t\tout_format_count++;\n\t}\n\tif (ctx->dev->dec_capability & MTK_VDEC_FORMAT_HEVC_FRAME) {\n\t\tmtk_vcodec_add_formats(V4L2_PIX_FMT_HEVC_SLICE, ctx);\n\t\tout_format_count++;\n\t}\n\tif (ctx->dev->dec_capability & MTK_VDEC_FORMAT_AV1_FRAME) {\n\t\tmtk_vcodec_add_formats(V4L2_PIX_FMT_AV1_FRAME, ctx);\n\t\tout_format_count++;\n\t}\n\n\tif (cap_format_count)\n\t\tdefault_cap_format = mtk_video_formats[cap_format_count - 1];\n\tif (out_format_count)\n\t\tdefault_out_format =\n\t\t\tmtk_video_formats[cap_format_count + out_format_count - 1];\n}\n\nstatic void mtk_init_vdec_params(struct mtk_vcodec_dec_ctx *ctx)\n{\n\tstruct vb2_queue *src_vq;\n\n\tsrc_vq = v4l2_m2m_get_vq(ctx->m2m_ctx,\n\t\t\t\t V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\n\tif (!ctx->dev->vdec_pdata->is_subdev_supported)\n\t\tctx->dev->dec_capability |=\n\t\t\tMTK_VDEC_FORMAT_H264_SLICE | MTK_VDEC_FORMAT_MM21;\n\tmtk_vcodec_get_supported_formats(ctx);\n\n\t \n\tsrc_vq->supports_requests = true;\n\tsrc_vq->requires_requests = true;\n}\n\nstatic int vb2ops_vdec_out_buf_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\treturn 0;\n}\n\nstatic struct vb2_ops mtk_vdec_request_vb2_ops = {\n\t.queue_setup\t= vb2ops_vdec_queue_setup,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n\t.start_streaming\t= vb2ops_vdec_start_streaming,\n\t.stop_streaming\t= vb2ops_vdec_stop_streaming,\n\n\t.buf_queue\t= vb2ops_vdec_stateless_buf_queue,\n\t.buf_out_validate = vb2ops_vdec_out_buf_validate,\n\t.buf_init\t= vb2ops_vdec_buf_init,\n\t.buf_prepare\t= vb2ops_vdec_buf_prepare,\n\t.buf_finish\t= vb2ops_vdec_buf_finish,\n\t.buf_request_complete = vb2ops_vdec_buf_request_complete,\n};\n\nconst struct mtk_vcodec_dec_pdata mtk_vdec_8183_pdata = {\n\t.init_vdec_params = mtk_init_vdec_params,\n\t.ctrls_setup = mtk_vcodec_dec_ctrls_setup,\n\t.vdec_vb2_ops = &mtk_vdec_request_vb2_ops,\n\t.vdec_formats = mtk_video_formats,\n\t.num_formats = &num_formats,\n\t.default_out_fmt = &default_out_format,\n\t.default_cap_fmt = &default_cap_format,\n\t.uses_stateless_api = true,\n\t.worker = mtk_vdec_worker,\n\t.flush_decoder = mtk_vdec_flush_decoder,\n\t.cap_to_disp = mtk_vdec_stateless_cap_to_disp,\n\t.get_cap_buffer = vdec_get_cap_buffer,\n\t.is_subdev_supported = false,\n\t.hw_arch = MTK_VDEC_PURE_SINGLE_CORE,\n};\n\n \nconst struct mtk_vcodec_dec_pdata mtk_lat_sig_core_pdata = {\n\t.init_vdec_params = mtk_init_vdec_params,\n\t.ctrls_setup = mtk_vcodec_dec_ctrls_setup,\n\t.vdec_vb2_ops = &mtk_vdec_request_vb2_ops,\n\t.vdec_formats = mtk_video_formats,\n\t.num_formats = &num_formats,\n\t.default_out_fmt = &default_out_format,\n\t.default_cap_fmt = &default_cap_format,\n\t.uses_stateless_api = true,\n\t.worker = mtk_vdec_worker,\n\t.flush_decoder = mtk_vdec_flush_decoder,\n\t.cap_to_disp = mtk_vdec_stateless_cap_to_disp,\n\t.get_cap_buffer = vdec_get_cap_buffer,\n\t.is_subdev_supported = true,\n\t.hw_arch = MTK_VDEC_LAT_SINGLE_CORE,\n};\n\nconst struct mtk_vcodec_dec_pdata mtk_vdec_single_core_pdata = {\n\t.init_vdec_params = mtk_init_vdec_params,\n\t.ctrls_setup = mtk_vcodec_dec_ctrls_setup,\n\t.vdec_vb2_ops = &mtk_vdec_request_vb2_ops,\n\t.vdec_formats = mtk_video_formats,\n\t.num_formats = &num_formats,\n\t.default_out_fmt = &default_out_format,\n\t.default_cap_fmt = &default_cap_format,\n\t.uses_stateless_api = true,\n\t.worker = mtk_vdec_worker,\n\t.flush_decoder = mtk_vdec_flush_decoder,\n\t.cap_to_disp = mtk_vdec_stateless_cap_to_disp,\n\t.get_cap_buffer = vdec_get_cap_buffer,\n\t.is_subdev_supported = true,\n\t.hw_arch = MTK_VDEC_PURE_SINGLE_CORE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}