{
  "module_name": "mtk_vcodec_fw_vpu.c",
  "hash_id": "5d4cbf7caeb3d46cb4201b88df5a6560f4a4ef695a8caf7596f42c46997968b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/common/mtk_vcodec_fw_vpu.c",
  "human_readable_source": "\n\n#include \"../decoder/mtk_vcodec_dec_drv.h\"\n#include \"../encoder/mtk_vcodec_enc_drv.h\"\n#include \"mtk_vcodec_fw_priv.h\"\n\nstatic int mtk_vcodec_vpu_load_firmware(struct mtk_vcodec_fw *fw)\n{\n\treturn vpu_load_firmware(fw->pdev);\n}\n\nstatic unsigned int mtk_vcodec_vpu_get_vdec_capa(struct mtk_vcodec_fw *fw)\n{\n\treturn vpu_get_vdec_hw_capa(fw->pdev);\n}\n\nstatic unsigned int mtk_vcodec_vpu_get_venc_capa(struct mtk_vcodec_fw *fw)\n{\n\treturn vpu_get_venc_hw_capa(fw->pdev);\n}\n\nstatic void *mtk_vcodec_vpu_map_dm_addr(struct mtk_vcodec_fw *fw,\n\t\t\t\t\tu32 dtcm_dmem_addr)\n{\n\treturn vpu_mapping_dm_addr(fw->pdev, dtcm_dmem_addr);\n}\n\nstatic int mtk_vcodec_vpu_set_ipi_register(struct mtk_vcodec_fw *fw, int id,\n\t\t\t\t\t   mtk_vcodec_ipi_handler handler,\n\t\t\t\t\t   const char *name, void *priv)\n{\n\t \n\tipi_handler_t handler_const = (ipi_handler_t)handler;\n\n\treturn vpu_ipi_register(fw->pdev, id, handler_const, name, priv);\n}\n\nstatic int mtk_vcodec_vpu_ipi_send(struct mtk_vcodec_fw *fw, int id, void *buf,\n\t\t\t\t   unsigned int len, unsigned int wait)\n{\n\treturn vpu_ipi_send(fw->pdev, id, buf, len);\n}\n\nstatic void mtk_vcodec_vpu_release(struct mtk_vcodec_fw *fw)\n{\n\tput_device(&fw->pdev->dev);\n}\n\nstatic void mtk_vcodec_vpu_reset_dec_handler(void *priv)\n{\n\tstruct mtk_vcodec_dec_dev *dev = priv;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\n\tdev_err(&dev->plat_dev->dev, \"Watchdog timeout!!\");\n\n\tmutex_lock(&dev->dev_mutex);\n\tlist_for_each_entry(ctx, &dev->ctx_list, list) {\n\t\tctx->state = MTK_STATE_ABORT;\n\t\tmtk_v4l2_vdec_dbg(0, ctx, \"[%d] Change to state MTK_STATE_ABORT\", ctx->id);\n\t}\n\tmutex_unlock(&dev->dev_mutex);\n}\n\nstatic void mtk_vcodec_vpu_reset_enc_handler(void *priv)\n{\n\tstruct mtk_vcodec_enc_dev *dev = priv;\n\tstruct mtk_vcodec_enc_ctx *ctx;\n\n\tdev_err(&dev->plat_dev->dev, \"Watchdog timeout!!\");\n\n\tmutex_lock(&dev->dev_mutex);\n\tlist_for_each_entry(ctx, &dev->ctx_list, list) {\n\t\tctx->state = MTK_STATE_ABORT;\n\t\tmtk_v4l2_vdec_dbg(0, ctx, \"[%d] Change to state MTK_STATE_ABORT\", ctx->id);\n\t}\n\tmutex_unlock(&dev->dev_mutex);\n}\n\nstatic const struct mtk_vcodec_fw_ops mtk_vcodec_vpu_msg = {\n\t.load_firmware = mtk_vcodec_vpu_load_firmware,\n\t.get_vdec_capa = mtk_vcodec_vpu_get_vdec_capa,\n\t.get_venc_capa = mtk_vcodec_vpu_get_venc_capa,\n\t.map_dm_addr = mtk_vcodec_vpu_map_dm_addr,\n\t.ipi_register = mtk_vcodec_vpu_set_ipi_register,\n\t.ipi_send = mtk_vcodec_vpu_ipi_send,\n\t.release = mtk_vcodec_vpu_release,\n};\n\nstruct mtk_vcodec_fw *mtk_vcodec_fw_vpu_init(void *priv, enum mtk_vcodec_fw_use fw_use)\n{\n\tstruct platform_device *fw_pdev;\n\tstruct platform_device *plat_dev;\n\tstruct mtk_vcodec_fw *fw;\n\tenum rst_id rst_id;\n\n\tif (fw_use == ENCODER) {\n\t\tstruct mtk_vcodec_enc_dev *enc_dev = priv;\n\n\t\tplat_dev = enc_dev->plat_dev;\n\t\trst_id = VPU_RST_ENC;\n\t} else if (fw_use == DECODER) {\n\t\tstruct mtk_vcodec_dec_dev *dec_dev = priv;\n\n\t\tplat_dev = dec_dev->plat_dev;\n\t\trst_id = VPU_RST_DEC;\n\t} else {\n\t\tpr_err(\"Invalid fw_use %d (use a resonable fw id here)\\n\", fw_use);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfw_pdev = vpu_get_plat_device(plat_dev);\n\tif (!fw_pdev) {\n\t\tdev_err(&plat_dev->dev, \"firmware device is not ready\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (fw_use == DECODER)\n\t\tvpu_wdt_reg_handler(fw_pdev, mtk_vcodec_vpu_reset_dec_handler, priv, rst_id);\n\telse\n\t\tvpu_wdt_reg_handler(fw_pdev, mtk_vcodec_vpu_reset_enc_handler, priv, rst_id);\n\n\tfw = devm_kzalloc(&plat_dev->dev, sizeof(*fw), GFP_KERNEL);\n\tif (!fw)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfw->type = VPU;\n\tfw->ops = &mtk_vcodec_vpu_msg;\n\tfw->pdev = fw_pdev;\n\tfw->fw_use = fw_use;\n\n\treturn fw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}