{
  "module_name": "mtk_vcodec_fw_scp.c",
  "hash_id": "c0719f073af029cbdf08f8d7509094a934d517a5043cc00c19555cc9434fd8f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/common/mtk_vcodec_fw_scp.c",
  "human_readable_source": "\n\n#include \"../decoder/mtk_vcodec_dec_drv.h\"\n#include \"../encoder/mtk_vcodec_enc_drv.h\"\n#include \"mtk_vcodec_fw_priv.h\"\n\nstatic int mtk_vcodec_scp_load_firmware(struct mtk_vcodec_fw *fw)\n{\n\treturn rproc_boot(scp_get_rproc(fw->scp));\n}\n\nstatic unsigned int mtk_vcodec_scp_get_vdec_capa(struct mtk_vcodec_fw *fw)\n{\n\treturn scp_get_vdec_hw_capa(fw->scp);\n}\n\nstatic unsigned int mtk_vcodec_scp_get_venc_capa(struct mtk_vcodec_fw *fw)\n{\n\treturn scp_get_venc_hw_capa(fw->scp);\n}\n\nstatic void *mtk_vcodec_vpu_scp_dm_addr(struct mtk_vcodec_fw *fw,\n\t\t\t\t\tu32 dtcm_dmem_addr)\n{\n\treturn scp_mapping_dm_addr(fw->scp, dtcm_dmem_addr);\n}\n\nstatic int mtk_vcodec_scp_set_ipi_register(struct mtk_vcodec_fw *fw, int id,\n\t\t\t\t\t   mtk_vcodec_ipi_handler handler,\n\t\t\t\t\t   const char *name, void *priv)\n{\n\treturn scp_ipi_register(fw->scp, id, handler, priv);\n}\n\nstatic int mtk_vcodec_scp_ipi_send(struct mtk_vcodec_fw *fw, int id, void *buf,\n\t\t\t\t   unsigned int len, unsigned int wait)\n{\n\treturn scp_ipi_send(fw->scp, id, buf, len, wait);\n}\n\nstatic void mtk_vcodec_scp_release(struct mtk_vcodec_fw *fw)\n{\n\tscp_put(fw->scp);\n}\n\nstatic const struct mtk_vcodec_fw_ops mtk_vcodec_rproc_msg = {\n\t.load_firmware = mtk_vcodec_scp_load_firmware,\n\t.get_vdec_capa = mtk_vcodec_scp_get_vdec_capa,\n\t.get_venc_capa = mtk_vcodec_scp_get_venc_capa,\n\t.map_dm_addr = mtk_vcodec_vpu_scp_dm_addr,\n\t.ipi_register = mtk_vcodec_scp_set_ipi_register,\n\t.ipi_send = mtk_vcodec_scp_ipi_send,\n\t.release = mtk_vcodec_scp_release,\n};\n\nstruct mtk_vcodec_fw *mtk_vcodec_fw_scp_init(void *priv, enum mtk_vcodec_fw_use fw_use)\n{\n\tstruct mtk_vcodec_fw *fw;\n\tstruct platform_device *plat_dev;\n\tstruct mtk_scp *scp;\n\n\tif (fw_use == ENCODER) {\n\t\tstruct mtk_vcodec_enc_dev *enc_dev = priv;\n\n\t\tplat_dev = enc_dev->plat_dev;\n\t} else if (fw_use == DECODER) {\n\t\tstruct mtk_vcodec_dec_dev *dec_dev = priv;\n\n\t\tplat_dev = dec_dev->plat_dev;\n\t} else {\n\t\tpr_err(\"Invalid fw_use %d (use a resonable fw id here)\\n\", fw_use);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tscp = scp_get(plat_dev);\n\tif (!scp) {\n\t\tdev_err(&plat_dev->dev, \"could not get vdec scp handle\");\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tfw = devm_kzalloc(&plat_dev->dev, sizeof(*fw), GFP_KERNEL);\n\tfw->type = SCP;\n\tfw->ops = &mtk_vcodec_rproc_msg;\n\tfw->scp = scp;\n\n\treturn fw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}