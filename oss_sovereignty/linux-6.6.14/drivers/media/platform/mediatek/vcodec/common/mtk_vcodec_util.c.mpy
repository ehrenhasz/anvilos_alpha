{
  "module_name": "mtk_vcodec_util.c",
  "hash_id": "c5cf83d72d69825275bfe7d55b6205ba1b02000ccca64ebd4557ea7c01ff7bbc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/common/mtk_vcodec_util.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#include \"../decoder/mtk_vcodec_dec_drv.h\"\n#include \"../encoder/mtk_vcodec_enc_drv.h\"\n#include \"../decoder/mtk_vcodec_dec_hw.h\"\n\n#if defined(CONFIG_DEBUG_FS)\nint mtk_vcodec_dbg;\nEXPORT_SYMBOL(mtk_vcodec_dbg);\n\nint mtk_v4l2_dbg_level;\nEXPORT_SYMBOL(mtk_v4l2_dbg_level);\n#endif\n\nvoid __iomem *mtk_vcodec_get_reg_addr(void __iomem **reg_base, unsigned int reg_idx)\n{\n\tif (reg_idx >= NUM_MAX_VCODEC_REG_BASE) {\n\t\tpr_err(MTK_DBG_V4L2_STR \"Invalid arguments, reg_idx=%d\", reg_idx);\n\t\treturn NULL;\n\t}\n\treturn reg_base[reg_idx];\n}\nEXPORT_SYMBOL(mtk_vcodec_get_reg_addr);\n\nint mtk_vcodec_write_vdecsys(struct mtk_vcodec_dec_ctx *ctx, unsigned int reg,\n\t\t\t     unsigned int val)\n{\n\tstruct mtk_vcodec_dec_dev *dev = ctx->dev;\n\n\tif (dev->vdecsys_regmap)\n\t\treturn regmap_write(dev->vdecsys_regmap, reg, val);\n\n\twritel(val, dev->reg_base[VDEC_SYS] + reg);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mtk_vcodec_write_vdecsys);\n\nint mtk_vcodec_mem_alloc(void *priv, struct mtk_vcodec_mem *mem)\n{\n\tenum mtk_instance_type inst_type = *((unsigned int *)priv);\n\tstruct platform_device *plat_dev;\n\tunsigned long size = mem->size;\n\tint id;\n\n\tif (inst_type == MTK_INST_ENCODER) {\n\t\tstruct mtk_vcodec_enc_ctx *enc_ctx = priv;\n\n\t\tplat_dev = enc_ctx->dev->plat_dev;\n\t\tid = enc_ctx->id;\n\t} else {\n\t\tstruct mtk_vcodec_dec_ctx *dec_ctx = priv;\n\n\t\tplat_dev = dec_ctx->dev->plat_dev;\n\t\tid = dec_ctx->id;\n\t}\n\n\tmem->va = dma_alloc_coherent(&plat_dev->dev, size, &mem->dma_addr, GFP_KERNEL);\n\tif (!mem->va) {\n\t\tmtk_v4l2_err(plat_dev, \"%s dma_alloc size=%ld failed!\",\n\t\t\t     dev_name(&plat_dev->dev), size);\n\t\treturn -ENOMEM;\n\t}\n\n\tmtk_v4l2_debug(plat_dev, 3, \"[%d] - va = %p dma = 0x%lx size = 0x%lx\", id, mem->va,\n\t\t       (unsigned long)mem->dma_addr, size);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mtk_vcodec_mem_alloc);\n\nvoid mtk_vcodec_mem_free(void *priv, struct mtk_vcodec_mem *mem)\n{\n\tenum mtk_instance_type inst_type = *((unsigned int *)priv);\n\tstruct platform_device *plat_dev;\n\tunsigned long size = mem->size;\n\tint id;\n\n\tif (inst_type == MTK_INST_ENCODER) {\n\t\tstruct mtk_vcodec_enc_ctx *enc_ctx = priv;\n\n\t\tplat_dev = enc_ctx->dev->plat_dev;\n\t\tid = enc_ctx->id;\n\t} else {\n\t\tstruct mtk_vcodec_dec_ctx *dec_ctx = priv;\n\n\t\tplat_dev = dec_ctx->dev->plat_dev;\n\t\tid = dec_ctx->id;\n\t}\n\n\tif (!mem->va) {\n\t\tmtk_v4l2_err(plat_dev, \"%s dma_free size=%ld failed!\",\n\t\t\t     dev_name(&plat_dev->dev), size);\n\t\treturn;\n\t}\n\n\tmtk_v4l2_debug(plat_dev, 3, \"[%d] - va = %p dma = 0x%lx size = 0x%lx\", id, mem->va,\n\t\t       (unsigned long)mem->dma_addr, size);\n\n\tdma_free_coherent(&plat_dev->dev, size, mem->va, mem->dma_addr);\n\tmem->va = NULL;\n\tmem->dma_addr = 0;\n\tmem->size = 0;\n}\nEXPORT_SYMBOL(mtk_vcodec_mem_free);\n\nvoid *mtk_vcodec_get_hw_dev(struct mtk_vcodec_dec_dev *dev, int hw_idx)\n{\n\tif (hw_idx >= MTK_VDEC_HW_MAX || hw_idx < 0 || !dev->subdev_dev[hw_idx]) {\n\t\tdev_err(&dev->plat_dev->dev, \"hw idx is out of range:%d\", hw_idx);\n\t\treturn NULL;\n\t}\n\n\treturn dev->subdev_dev[hw_idx];\n}\nEXPORT_SYMBOL(mtk_vcodec_get_hw_dev);\n\nvoid mtk_vcodec_set_curr_ctx(struct mtk_vcodec_dec_dev *vdec_dev,\n\t\t\t     struct mtk_vcodec_dec_ctx *ctx, int hw_idx)\n{\n\tunsigned long flags;\n\tstruct mtk_vdec_hw_dev *subdev_dev;\n\n\tspin_lock_irqsave(&vdec_dev->irqlock, flags);\n\tif (vdec_dev->vdec_pdata->is_subdev_supported) {\n\t\tsubdev_dev = mtk_vcodec_get_hw_dev(vdec_dev, hw_idx);\n\t\tif (!subdev_dev) {\n\t\t\tdev_err(&vdec_dev->plat_dev->dev, \"Failed to get hw dev\");\n\t\t\tspin_unlock_irqrestore(&vdec_dev->irqlock, flags);\n\t\t\treturn;\n\t\t}\n\t\tsubdev_dev->curr_ctx = ctx;\n\t} else {\n\t\tvdec_dev->curr_ctx = ctx;\n\t}\n\tspin_unlock_irqrestore(&vdec_dev->irqlock, flags);\n}\nEXPORT_SYMBOL(mtk_vcodec_set_curr_ctx);\n\nstruct mtk_vcodec_dec_ctx *mtk_vcodec_get_curr_ctx(struct mtk_vcodec_dec_dev *vdec_dev,\n\t\t\t\t\t\t   unsigned int hw_idx)\n{\n\tunsigned long flags;\n\tstruct mtk_vcodec_dec_ctx *ctx;\n\tstruct mtk_vdec_hw_dev *subdev_dev;\n\n\tspin_lock_irqsave(&vdec_dev->irqlock, flags);\n\tif (vdec_dev->vdec_pdata->is_subdev_supported) {\n\t\tsubdev_dev = mtk_vcodec_get_hw_dev(vdec_dev, hw_idx);\n\t\tif (!subdev_dev) {\n\t\t\tdev_err(&vdec_dev->plat_dev->dev, \"Failed to get hw dev\");\n\t\t\tspin_unlock_irqrestore(&vdec_dev->irqlock, flags);\n\t\t\treturn NULL;\n\t\t}\n\t\tctx = subdev_dev->curr_ctx;\n\t} else {\n\t\tctx = vdec_dev->curr_ctx;\n\t}\n\tspin_unlock_irqrestore(&vdec_dev->irqlock, flags);\n\treturn ctx;\n}\nEXPORT_SYMBOL(mtk_vcodec_get_curr_ctx);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Mediatek video codec driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}