{
  "module_name": "venc_h264_if.c",
  "hash_id": "abc1eaf2b0fd39ee69f14879265714f080fb5090e647e35c9fcc68cad5a9b69f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/encoder/venc/venc_h264_if.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#include \"../mtk_vcodec_enc_drv.h\"\n#include \"../../common/mtk_vcodec_intr.h\"\n#include \"../mtk_vcodec_enc.h\"\n#include \"../mtk_vcodec_enc_pm.h\"\n#include \"../venc_drv_base.h\"\n#include \"../venc_ipi_msg.h\"\n#include \"../venc_vpu_if.h\"\n\nstatic const char h264_filler_marker[] = {0x0, 0x0, 0x0, 0x1, 0xc};\n\n#define H264_FILLER_MARKER_SIZE ARRAY_SIZE(h264_filler_marker)\n#define VENC_PIC_BITSTREAM_BYTE_CNT 0x0098\n\n \nenum venc_h264_frame_type {\n\tVENC_H264_IDR_FRM,\n\tVENC_H264_I_FRM,\n\tVENC_H264_P_FRM,\n\tVENC_H264_B_FRM,\n};\n\n \nenum venc_h264_vpu_work_buf {\n\tVENC_H264_VPU_WORK_BUF_RC_INFO,\n\tVENC_H264_VPU_WORK_BUF_RC_CODE,\n\tVENC_H264_VPU_WORK_BUF_REC_LUMA,\n\tVENC_H264_VPU_WORK_BUF_REC_CHROMA,\n\tVENC_H264_VPU_WORK_BUF_REF_LUMA,\n\tVENC_H264_VPU_WORK_BUF_REF_CHROMA,\n\tVENC_H264_VPU_WORK_BUF_MV_INFO_1,\n\tVENC_H264_VPU_WORK_BUF_MV_INFO_2,\n\tVENC_H264_VPU_WORK_BUF_SKIP_FRAME,\n\tVENC_H264_VPU_WORK_BUF_MAX,\n};\n\n \nenum venc_h264_bs_mode {\n\tH264_BS_MODE_SPS,\n\tH264_BS_MODE_PPS,\n\tH264_BS_MODE_FRAME,\n};\n\n \nstruct venc_h264_vpu_config {\n\tu32 input_fourcc;\n\tu32 bitrate;\n\tu32 pic_w;\n\tu32 pic_h;\n\tu32 buf_w;\n\tu32 buf_h;\n\tu32 gop_size;\n\tu32 intra_period;\n\tu32 framerate;\n\tu32 profile;\n\tu32 level;\n\tu32 wfd;\n};\n\n \nstruct venc_h264_vpu_buf {\n\tu32 iova;\n\tu32 vpua;\n\tu32 size;\n};\n\n \nstruct venc_h264_vsi {\n\tstruct venc_h264_vpu_config config;\n\tstruct venc_h264_vpu_buf work_bufs[VENC_H264_VPU_WORK_BUF_MAX];\n};\n\n \nstruct venc_h264_vpu_config_ext {\n\tu32 input_fourcc;\n\tu32 bitrate;\n\tu32 pic_w;\n\tu32 pic_h;\n\tu32 buf_w;\n\tu32 buf_h;\n\tu32 gop_size;\n\tu32 intra_period;\n\tu32 framerate;\n\tu32 profile;\n\tu32 level;\n\tu32 wfd;\n\tu32 max_qp;\n\tu32 min_qp;\n\tu32 reserved[8];\n};\n\n \nstruct venc_h264_vpu_buf_34 {\n\tu64 iova;\n\tu32 vpua;\n\tu32 size;\n};\n\n \nstruct venc_h264_vsi_34 {\n\tstruct venc_h264_vpu_config_ext config;\n\tstruct venc_h264_vpu_buf_34 work_bufs[VENC_H264_VPU_WORK_BUF_MAX];\n};\n\n \nstruct venc_h264_inst {\n\tvoid __iomem *hw_base;\n\tstruct mtk_vcodec_mem work_bufs[VENC_H264_VPU_WORK_BUF_MAX];\n\tstruct mtk_vcodec_mem pps_buf;\n\tbool work_buf_allocated;\n\tunsigned int frm_cnt;\n\tunsigned int skip_frm_cnt;\n\tunsigned int prepend_hdr;\n\tstruct venc_vpu_inst vpu_inst;\n\tstruct venc_h264_vsi *vsi;\n\tstruct venc_h264_vsi_34 *vsi_34;\n\tstruct mtk_vcodec_enc_ctx *ctx;\n};\n\nstatic inline u32 h264_read_reg(struct venc_h264_inst *inst, u32 addr)\n{\n\treturn readl(inst->hw_base + addr);\n}\n\nstatic unsigned int h264_get_profile(struct venc_h264_inst *inst,\n\t\t\t\t     unsigned int profile)\n{\n\tswitch (profile) {\n\tcase V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:\n\t\treturn 66;\n\tcase V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:\n\t\treturn 77;\n\tcase V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:\n\t\treturn 100;\n\tcase V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE:\n\t\tmtk_venc_err(inst->ctx, \"unsupported CONSTRAINED_BASELINE\");\n\t\treturn 0;\n\tcase V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED:\n\t\tmtk_venc_err(inst->ctx, \"unsupported EXTENDED\");\n\t\treturn 0;\n\tdefault:\n\t\tmtk_venc_debug(inst->ctx, \"unsupported profile %d\", profile);\n\t\treturn 100;\n\t}\n}\n\nstatic unsigned int h264_get_level(struct venc_h264_inst *inst,\n\t\t\t\t   unsigned int level)\n{\n\tswitch (level) {\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1B:\n\t\tmtk_venc_err(inst->ctx, \"unsupported 1B\");\n\t\treturn 0;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_0:\n\t\treturn 10;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_1:\n\t\treturn 11;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_2:\n\t\treturn 12;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_3:\n\t\treturn 13;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_2_0:\n\t\treturn 20;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_2_1:\n\t\treturn 21;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_2_2:\n\t\treturn 22;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_3_0:\n\t\treturn 30;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_3_1:\n\t\treturn 31;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_3_2:\n\t\treturn 32;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_4_0:\n\t\treturn 40;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_4_1:\n\t\treturn 41;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_4_2:\n\t\treturn 42;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_5_0:\n\t\treturn 50;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_5_1:\n\t\treturn 51;\n\tdefault:\n\t\tmtk_venc_debug(inst->ctx, \"unsupported level %d\", level);\n\t\treturn 31;\n\t}\n}\n\nstatic void h264_enc_free_work_buf(struct venc_h264_inst *inst)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < VENC_H264_VPU_WORK_BUF_MAX; i++) {\n\t\tif (i != VENC_H264_VPU_WORK_BUF_SKIP_FRAME)\n\t\t\tmtk_vcodec_mem_free(inst->ctx, &inst->work_bufs[i]);\n\t}\n\n\tmtk_vcodec_mem_free(inst->ctx, &inst->pps_buf);\n}\n\nstatic int h264_enc_alloc_work_buf(struct venc_h264_inst *inst, bool is_34bit)\n{\n\tstruct venc_h264_vpu_buf *wb = NULL;\n\tstruct venc_h264_vpu_buf_34 *wb_34 = NULL;\n\tint i;\n\tu32 vpua, wb_size;\n\tint ret = 0;\n\n\tif (is_34bit)\n\t\twb_34 = inst->vsi_34->work_bufs;\n\telse\n\t\twb = inst->vsi->work_bufs;\n\n\tfor (i = 0; i < VENC_H264_VPU_WORK_BUF_MAX; i++) {\n\t\t \n\t\tif (is_34bit) {\n\t\t\tinst->work_bufs[i].size = wb_34[i].size;\n\t\t\tvpua = wb_34[i].vpua;\n\t\t\twb_size = wb_34[i].size;\n\t\t} else {\n\t\t\tinst->work_bufs[i].size = wb[i].size;\n\t\t\tvpua = wb[i].vpua;\n\t\t\twb_size = wb[i].size;\n\t\t}\n\n\t\tif (i == VENC_H264_VPU_WORK_BUF_SKIP_FRAME) {\n\t\t\tstruct mtk_vcodec_fw *handler;\n\n\t\t\thandler = inst->vpu_inst.ctx->dev->fw_handler;\n\t\t\tinst->work_bufs[i].va =\n\t\t\t\tmtk_vcodec_fw_map_dm_addr(handler, vpua);\n\t\t\tinst->work_bufs[i].dma_addr = 0;\n\t\t} else {\n\t\t\tret = mtk_vcodec_mem_alloc(inst->ctx,\n\t\t\t\t\t\t   &inst->work_bufs[i]);\n\t\t\tif (ret) {\n\t\t\t\tmtk_venc_err(inst->ctx, \"cannot allocate buf %d\", i);\n\t\t\t\tgoto err_alloc;\n\t\t\t}\n\t\t\t \n\t\t\tif (i == VENC_H264_VPU_WORK_BUF_RC_CODE) {\n\t\t\t\tstruct mtk_vcodec_fw *handler;\n\t\t\t\tvoid *tmp_va;\n\n\t\t\t\thandler = inst->vpu_inst.ctx->dev->fw_handler;\n\t\t\t\ttmp_va = mtk_vcodec_fw_map_dm_addr(handler,\n\t\t\t\t\t\t\t\t   vpua);\n\t\t\t\tmemcpy(inst->work_bufs[i].va, tmp_va, wb_size);\n\t\t\t}\n\t\t}\n\t\tif (is_34bit)\n\t\t\twb_34[i].iova = inst->work_bufs[i].dma_addr;\n\t\telse\n\t\t\twb[i].iova = inst->work_bufs[i].dma_addr;\n\n\t\tmtk_venc_debug(inst->ctx, \"work_buf[%d] va=0x%p iova=%pad size=%zu\",\n\t\t\t       i, inst->work_bufs[i].va,\n\t\t\t       &inst->work_bufs[i].dma_addr,\n\t\t\t       inst->work_bufs[i].size);\n\t}\n\n\t \n\tinst->pps_buf.size = 128;\n\tret = mtk_vcodec_mem_alloc(inst->ctx, &inst->pps_buf);\n\tif (ret) {\n\t\tmtk_venc_err(inst->ctx, \"cannot allocate pps_buf\");\n\t\tgoto err_alloc;\n\t}\n\n\treturn ret;\n\nerr_alloc:\n\th264_enc_free_work_buf(inst);\n\n\treturn ret;\n}\n\nstatic unsigned int h264_enc_wait_venc_done(struct venc_h264_inst *inst)\n{\n\tunsigned int irq_status = 0;\n\tstruct mtk_vcodec_enc_ctx *ctx = (struct mtk_vcodec_enc_ctx *)inst->ctx;\n\n\tif (!mtk_vcodec_wait_for_done_ctx(ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t  WAIT_INTR_TIMEOUT_MS, 0)) {\n\t\tirq_status = ctx->irq_status;\n\t\tmtk_venc_debug(ctx, \"irq_status %x <-\", irq_status);\n\t}\n\treturn irq_status;\n}\n\nstatic int h264_frame_type(unsigned int frm_cnt, unsigned int gop_size,\n\t\t\t   unsigned int intra_period)\n{\n\tif ((gop_size != 0 && (frm_cnt % gop_size) == 0) ||\n\t    (frm_cnt == 0 && gop_size == 0)) {\n\t\t \n\t\treturn VENC_H264_IDR_FRM;\n\t} else if ((intra_period != 0 && (frm_cnt % intra_period) == 0) ||\n\t\t   (frm_cnt == 0 && intra_period == 0)) {\n\t\t \n\t\treturn VENC_H264_I_FRM;\n\t} else {\n\t\treturn VENC_H264_P_FRM;   \n\t}\n}\n\nstatic int h264_encode_sps(struct venc_h264_inst *inst,\n\t\t\t   struct mtk_vcodec_mem *bs_buf,\n\t\t\t   unsigned int *bs_size)\n{\n\tint ret = 0;\n\tunsigned int irq_status;\n\n\tret = vpu_enc_encode(&inst->vpu_inst, H264_BS_MODE_SPS, NULL, bs_buf, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tirq_status = h264_enc_wait_venc_done(inst);\n\tif (irq_status != MTK_VENC_IRQ_STATUS_SPS) {\n\t\tmtk_venc_err(inst->ctx, \"expect irq status %d\", MTK_VENC_IRQ_STATUS_SPS);\n\t\treturn -EINVAL;\n\t}\n\n\t*bs_size = h264_read_reg(inst, VENC_PIC_BITSTREAM_BYTE_CNT);\n\tmtk_venc_debug(inst->ctx, \"bs size %d <-\", *bs_size);\n\n\treturn ret;\n}\n\nstatic int h264_encode_pps(struct venc_h264_inst *inst,\n\t\t\t   struct mtk_vcodec_mem *bs_buf,\n\t\t\t   unsigned int *bs_size)\n{\n\tint ret = 0;\n\tunsigned int irq_status;\n\n\tret = vpu_enc_encode(&inst->vpu_inst, H264_BS_MODE_PPS, NULL, bs_buf, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tirq_status = h264_enc_wait_venc_done(inst);\n\tif (irq_status != MTK_VENC_IRQ_STATUS_PPS) {\n\t\tmtk_venc_err(inst->ctx, \"expect irq status %d\", MTK_VENC_IRQ_STATUS_PPS);\n\t\treturn -EINVAL;\n\t}\n\n\t*bs_size = h264_read_reg(inst, VENC_PIC_BITSTREAM_BYTE_CNT);\n\tmtk_venc_debug(inst->ctx, \"bs size %d <-\", *bs_size);\n\n\treturn ret;\n}\n\nstatic int h264_encode_header(struct venc_h264_inst *inst,\n\t\t\t      struct mtk_vcodec_mem *bs_buf,\n\t\t\t      unsigned int *bs_size)\n{\n\tint ret = 0;\n\tunsigned int bs_size_sps;\n\tunsigned int bs_size_pps;\n\n\tret = h264_encode_sps(inst, bs_buf, &bs_size_sps);\n\tif (ret)\n\t\treturn ret;\n\n\tret = h264_encode_pps(inst, &inst->pps_buf, &bs_size_pps);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(bs_buf->va + bs_size_sps, inst->pps_buf.va, bs_size_pps);\n\t*bs_size = bs_size_sps + bs_size_pps;\n\n\treturn ret;\n}\n\nstatic int h264_encode_frame(struct venc_h264_inst *inst,\n\t\t\t     struct venc_frm_buf *frm_buf,\n\t\t\t     struct mtk_vcodec_mem *bs_buf,\n\t\t\t     unsigned int *bs_size)\n{\n\tint ret = 0;\n\tunsigned int gop_size;\n\tunsigned int intra_period;\n\tunsigned int irq_status;\n\tstruct venc_frame_info frame_info;\n\tstruct mtk_vcodec_enc_ctx *ctx = inst->ctx;\n\n\tmtk_venc_debug(ctx, \"frm_cnt = %d\\n \", inst->frm_cnt);\n\n\tif (MTK_ENC_IOVA_IS_34BIT(ctx)) {\n\t\tgop_size = inst->vsi_34->config.gop_size;\n\t\tintra_period = inst->vsi_34->config.intra_period;\n\t} else {\n\t\tgop_size = inst->vsi->config.gop_size;\n\t\tintra_period = inst->vsi->config.intra_period;\n\t}\n\tframe_info.frm_count = inst->frm_cnt;\n\tframe_info.skip_frm_count = inst->skip_frm_cnt;\n\tframe_info.frm_type = h264_frame_type(inst->frm_cnt, gop_size,\n\t\t\t\t\t      intra_period);\n\tmtk_venc_debug(ctx, \"frm_count = %d,skip_frm_count =%d,frm_type=%d.\\n\",\n\t\t       frame_info.frm_count, frame_info.skip_frm_count,\n\t\t       frame_info.frm_type);\n\n\tret = vpu_enc_encode(&inst->vpu_inst, H264_BS_MODE_FRAME,\n\t\t\t     frm_buf, bs_buf, &frame_info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (inst->vpu_inst.state == VEN_IPI_MSG_ENC_STATE_SKIP) {\n\t\t*bs_size = inst->vpu_inst.bs_size;\n\t\tmemcpy(bs_buf->va,\n\t\t       inst->work_bufs[VENC_H264_VPU_WORK_BUF_SKIP_FRAME].va,\n\t\t       *bs_size);\n\t\t++inst->frm_cnt;\n\t\t++inst->skip_frm_cnt;\n\t\treturn 0;\n\t}\n\n\tirq_status = h264_enc_wait_venc_done(inst);\n\tif (irq_status != MTK_VENC_IRQ_STATUS_FRM) {\n\t\tmtk_venc_err(ctx, \"irq_status=%d failed\", irq_status);\n\t\treturn -EIO;\n\t}\n\n\t*bs_size = h264_read_reg(inst, VENC_PIC_BITSTREAM_BYTE_CNT);\n\n\t++inst->frm_cnt;\n\tmtk_venc_debug(ctx, \"frm %d bs_size %d key_frm %d <-\",\n\t\t       inst->frm_cnt, *bs_size, inst->vpu_inst.is_key_frm);\n\n\treturn 0;\n}\n\nstatic void h264_encode_filler(struct venc_h264_inst *inst, void *buf,\n\t\t\t       int size)\n{\n\tunsigned char *p = buf;\n\n\tif (size < H264_FILLER_MARKER_SIZE) {\n\t\tmtk_venc_err(inst->ctx, \"filler size too small %d\", size);\n\t\treturn;\n\t}\n\n\tmemcpy(p, h264_filler_marker, ARRAY_SIZE(h264_filler_marker));\n\tsize -= H264_FILLER_MARKER_SIZE;\n\tp += H264_FILLER_MARKER_SIZE;\n\tmemset(p, 0xff, size);\n}\n\nstatic int h264_enc_init(struct mtk_vcodec_enc_ctx *ctx)\n{\n\tconst bool is_ext = MTK_ENC_CTX_IS_EXT(ctx);\n\tint ret = 0;\n\tstruct venc_h264_inst *inst;\n\n\tinst = kzalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tinst->ctx = ctx;\n\tinst->vpu_inst.ctx = ctx;\n\tinst->vpu_inst.id = is_ext ? SCP_IPI_VENC_H264 : IPI_VENC_H264;\n\tinst->hw_base = mtk_vcodec_get_reg_addr(inst->ctx->dev->reg_base, VENC_SYS);\n\n\tret = vpu_enc_init(&inst->vpu_inst);\n\n\tif (MTK_ENC_IOVA_IS_34BIT(ctx))\n\t\tinst->vsi_34 = (struct venc_h264_vsi_34 *)inst->vpu_inst.vsi;\n\telse\n\t\tinst->vsi = (struct venc_h264_vsi *)inst->vpu_inst.vsi;\n\n\tif (ret)\n\t\tkfree(inst);\n\telse\n\t\tctx->drv_handle = inst;\n\n\treturn ret;\n}\n\nstatic int h264_enc_encode(void *handle,\n\t\t\t   enum venc_start_opt opt,\n\t\t\t   struct venc_frm_buf *frm_buf,\n\t\t\t   struct mtk_vcodec_mem *bs_buf,\n\t\t\t   struct venc_done_result *result)\n{\n\tint ret = 0;\n\tstruct venc_h264_inst *inst = (struct venc_h264_inst *)handle;\n\tstruct mtk_vcodec_enc_ctx *ctx = inst->ctx;\n\n\tmtk_venc_debug(ctx, \"opt %d ->\", opt);\n\n\tenable_irq(ctx->dev->enc_irq);\n\n\tswitch (opt) {\n\tcase VENC_START_OPT_ENCODE_SEQUENCE_HEADER: {\n\t\tunsigned int bs_size_hdr;\n\n\t\tret = h264_encode_header(inst, bs_buf, &bs_size_hdr);\n\t\tif (ret)\n\t\t\tgoto encode_err;\n\n\t\tresult->bs_size = bs_size_hdr;\n\t\tresult->is_key_frm = false;\n\t\tbreak;\n\t}\n\n\tcase VENC_START_OPT_ENCODE_FRAME: {\n\t\tint hdr_sz;\n\t\tint hdr_sz_ext;\n\t\tint filler_sz = 0;\n\t\tconst int bs_alignment = 128;\n\t\tstruct mtk_vcodec_mem tmp_bs_buf;\n\t\tunsigned int bs_size_hdr;\n\t\tunsigned int bs_size_frm;\n\n\t\tif (!inst->prepend_hdr) {\n\t\t\tret = h264_encode_frame(inst, frm_buf, bs_buf,\n\t\t\t\t\t\t&result->bs_size);\n\t\t\tif (ret)\n\t\t\t\tgoto encode_err;\n\t\t\tresult->is_key_frm = inst->vpu_inst.is_key_frm;\n\t\t\tbreak;\n\t\t}\n\n\t\tmtk_venc_debug(ctx, \"h264_encode_frame prepend SPS/PPS\");\n\n\t\tret = h264_encode_header(inst, bs_buf, &bs_size_hdr);\n\t\tif (ret)\n\t\t\tgoto encode_err;\n\n\t\thdr_sz = bs_size_hdr;\n\t\thdr_sz_ext = (hdr_sz & (bs_alignment - 1));\n\t\tif (hdr_sz_ext) {\n\t\t\tfiller_sz = bs_alignment - hdr_sz_ext;\n\t\t\tif (hdr_sz_ext + H264_FILLER_MARKER_SIZE > bs_alignment)\n\t\t\t\tfiller_sz += bs_alignment;\n\t\t\th264_encode_filler(inst, bs_buf->va + hdr_sz,\n\t\t\t\t\t   filler_sz);\n\t\t}\n\n\t\ttmp_bs_buf.va = bs_buf->va + hdr_sz + filler_sz;\n\t\ttmp_bs_buf.dma_addr = bs_buf->dma_addr + hdr_sz + filler_sz;\n\t\ttmp_bs_buf.size = bs_buf->size - (hdr_sz + filler_sz);\n\n\t\tret = h264_encode_frame(inst, frm_buf, &tmp_bs_buf,\n\t\t\t\t\t&bs_size_frm);\n\t\tif (ret)\n\t\t\tgoto encode_err;\n\n\t\tresult->bs_size = hdr_sz + filler_sz + bs_size_frm;\n\n\t\tmtk_venc_debug(ctx, \"hdr %d filler %d frame %d bs %d\",\n\t\t\t       hdr_sz, filler_sz, bs_size_frm, result->bs_size);\n\n\t\tinst->prepend_hdr = 0;\n\t\tresult->is_key_frm = inst->vpu_inst.is_key_frm;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tmtk_venc_err(ctx, \"venc_start_opt %d not supported\", opt);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nencode_err:\n\n\tdisable_irq(ctx->dev->enc_irq);\n\tmtk_venc_debug(ctx, \"opt %d <-\", opt);\n\n\treturn ret;\n}\n\nstatic void h264_enc_set_vsi_configs(struct venc_h264_inst *inst,\n\t\t\t\t     struct venc_enc_param *enc_prm)\n{\n\tinst->vsi->config.input_fourcc = enc_prm->input_yuv_fmt;\n\tinst->vsi->config.bitrate = enc_prm->bitrate;\n\tinst->vsi->config.pic_w = enc_prm->width;\n\tinst->vsi->config.pic_h = enc_prm->height;\n\tinst->vsi->config.buf_w = enc_prm->buf_width;\n\tinst->vsi->config.buf_h = enc_prm->buf_height;\n\tinst->vsi->config.gop_size = enc_prm->gop_size;\n\tinst->vsi->config.framerate = enc_prm->frm_rate;\n\tinst->vsi->config.intra_period = enc_prm->intra_period;\n\tinst->vsi->config.profile =\n\t\th264_get_profile(inst, enc_prm->h264_profile);\n\tinst->vsi->config.level =\n\t\th264_get_level(inst, enc_prm->h264_level);\n\tinst->vsi->config.wfd = 0;\n}\n\nstatic void h264_enc_set_vsi_34_configs(struct venc_h264_inst *inst,\n\t\t\t\t\tstruct venc_enc_param *enc_prm)\n{\n\tinst->vsi_34->config.input_fourcc = enc_prm->input_yuv_fmt;\n\tinst->vsi_34->config.bitrate = enc_prm->bitrate;\n\tinst->vsi_34->config.pic_w = enc_prm->width;\n\tinst->vsi_34->config.pic_h = enc_prm->height;\n\tinst->vsi_34->config.buf_w = enc_prm->buf_width;\n\tinst->vsi_34->config.buf_h = enc_prm->buf_height;\n\tinst->vsi_34->config.gop_size = enc_prm->gop_size;\n\tinst->vsi_34->config.framerate = enc_prm->frm_rate;\n\tinst->vsi_34->config.intra_period = enc_prm->intra_period;\n\tinst->vsi_34->config.profile =\n\t\th264_get_profile(inst, enc_prm->h264_profile);\n\tinst->vsi_34->config.level =\n\t\th264_get_level(inst, enc_prm->h264_level);\n\tinst->vsi_34->config.wfd = 0;\n}\n\nstatic int h264_enc_set_param(void *handle,\n\t\t\t      enum venc_set_param_type type,\n\t\t\t      struct venc_enc_param *enc_prm)\n{\n\tint ret = 0;\n\tstruct venc_h264_inst *inst = (struct venc_h264_inst *)handle;\n\tstruct mtk_vcodec_enc_ctx *ctx = inst->ctx;\n\tconst bool is_34bit = MTK_ENC_IOVA_IS_34BIT(ctx);\n\n\tmtk_venc_debug(ctx, \"->type=%d\", type);\n\n\tswitch (type) {\n\tcase VENC_SET_PARAM_ENC:\n\t\tif (is_34bit)\n\t\t\th264_enc_set_vsi_34_configs(inst, enc_prm);\n\t\telse\n\t\t\th264_enc_set_vsi_configs(inst, enc_prm);\n\t\tret = vpu_enc_set_param(&inst->vpu_inst, type, enc_prm);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (inst->work_buf_allocated) {\n\t\t\th264_enc_free_work_buf(inst);\n\t\t\tinst->work_buf_allocated = false;\n\t\t}\n\t\tret = h264_enc_alloc_work_buf(inst, is_34bit);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tinst->work_buf_allocated = true;\n\t\tbreak;\n\n\tcase VENC_SET_PARAM_PREPEND_HEADER:\n\t\tinst->prepend_hdr = 1;\n\t\tmtk_venc_debug(ctx, \"set prepend header mode\");\n\t\tbreak;\n\tcase VENC_SET_PARAM_FORCE_INTRA:\n\tcase VENC_SET_PARAM_GOP_SIZE:\n\tcase VENC_SET_PARAM_INTRA_PERIOD:\n\t\tinst->frm_cnt = 0;\n\t\tinst->skip_frm_cnt = 0;\n\t\tfallthrough;\n\tdefault:\n\t\tret = vpu_enc_set_param(&inst->vpu_inst, type, enc_prm);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int h264_enc_deinit(void *handle)\n{\n\tint ret = 0;\n\tstruct venc_h264_inst *inst = (struct venc_h264_inst *)handle;\n\n\tret = vpu_enc_deinit(&inst->vpu_inst);\n\n\tif (inst->work_buf_allocated)\n\t\th264_enc_free_work_buf(inst);\n\n\tkfree(inst);\n\n\treturn ret;\n}\n\nconst struct venc_common_if venc_h264_if = {\n\t.init = h264_enc_init,\n\t.encode = h264_enc_encode,\n\t.set_param = h264_enc_set_param,\n\t.deinit = h264_enc_deinit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}