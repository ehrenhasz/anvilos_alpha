{
  "module_name": "mtk_vcodec_enc.c",
  "hash_id": "653040663e3a1ff676f7536e0664acefc7e17159ec1a7b30c2ca2369af67d25e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/encoder/mtk_vcodec_enc.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n#include <linux/pm_runtime.h>\n\n#include \"mtk_vcodec_enc.h\"\n#include \"venc_drv_if.h\"\n\n#define MTK_VENC_MIN_W\t160U\n#define MTK_VENC_MIN_H\t128U\n#define MTK_VENC_HD_MAX_W\t1920U\n#define MTK_VENC_HD_MAX_H\t1088U\n#define MTK_VENC_4K_MAX_W\t3840U\n#define MTK_VENC_4K_MAX_H\t2176U\n\n#define DFT_CFG_WIDTH\tMTK_VENC_MIN_W\n#define DFT_CFG_HEIGHT\tMTK_VENC_MIN_H\n#define MTK_MAX_CTRLS_HINT\t20\n\n#define MTK_DEFAULT_FRAMERATE_NUM 1001\n#define MTK_DEFAULT_FRAMERATE_DENOM 30000\n#define MTK_VENC_4K_CAPABILITY_ENABLE BIT(0)\n\nstatic void mtk_venc_worker(struct work_struct *work);\n\nstatic const struct v4l2_frmsize_stepwise mtk_venc_hd_framesizes = {\n\tMTK_VENC_MIN_W, MTK_VENC_HD_MAX_W, 16,\n\tMTK_VENC_MIN_H, MTK_VENC_HD_MAX_H, 16,\n};\n\nstatic const struct v4l2_frmsize_stepwise mtk_venc_4k_framesizes = {\n\tMTK_VENC_MIN_W, MTK_VENC_4K_MAX_W, 16,\n\tMTK_VENC_MIN_H, MTK_VENC_4K_MAX_H, 16,\n};\n\nstatic int vidioc_venc_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = ctrl_to_enc_ctx(ctrl);\n\tstruct mtk_enc_params *p = &ctx->enc_params;\n\tint ret = 0;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_BITRATE_MODE val= %d\", ctrl->val);\n\t\tif (ctrl->val != V4L2_MPEG_VIDEO_BITRATE_MODE_CBR) {\n\t\t\tmtk_v4l2_venc_err(ctx, \"Unsupported bitrate mode =%d\", ctrl->val);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE:\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_BITRATE val = %d\", ctrl->val);\n\t\tp->bitrate = ctrl->val;\n\t\tctx->param_change |= MTK_ENCODE_PARAM_BITRATE;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_B_FRAMES:\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_B_FRAMES val = %d\", ctrl->val);\n\t\tp->num_b_frame = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE val = %d\",\n\t\t\t\t  ctrl->val);\n\t\tp->rc_frame = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_MAX_QP:\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_H264_MAX_QP val = %d\", ctrl->val);\n\t\tp->h264_max_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEADER_MODE:\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_HEADER_MODE val = %d\", ctrl->val);\n\t\tp->seq_hdr_mode = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE:\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE val = %d\", ctrl->val);\n\t\tp->rc_mb = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_PROFILE:\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_H264_PROFILE val = %d\", ctrl->val);\n\t\tp->h264_profile = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_LEVEL:\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_H264_LEVEL val = %d\", ctrl->val);\n\t\tp->h264_level = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_I_PERIOD:\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_H264_I_PERIOD val = %d\", ctrl->val);\n\t\tp->intra_period = ctrl->val;\n\t\tctx->param_change |= MTK_ENCODE_PARAM_INTRA_PERIOD;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_GOP_SIZE val = %d\", ctrl->val);\n\t\tp->gop_size = ctrl->val;\n\t\tctx->param_change |= MTK_ENCODE_PARAM_GOP_SIZE;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VP8_PROFILE:\n\t\t \n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_VP8_PROFILE val = %d\", ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME:\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME\");\n\t\tp->force_intra = 1;\n\t\tctx->param_change |= MTK_ENCODE_PARAM_FORCE_INTRA;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops mtk_vcodec_enc_ctrl_ops = {\n\t.s_ctrl = vidioc_venc_s_ctrl,\n};\n\nstatic int vidioc_enum_fmt(struct v4l2_fmtdesc *f,\n\t\t\t   const struct mtk_video_fmt *formats,\n\t\t\t   size_t num_formats)\n{\n\tif (f->index >= num_formats)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[f->index].fourcc;\n\n\treturn 0;\n}\n\nstatic const struct mtk_video_fmt *\nmtk_venc_find_format(u32 fourcc, const struct mtk_vcodec_enc_pdata *pdata)\n{\n\tconst struct mtk_video_fmt *fmt;\n\tunsigned int k;\n\n\tfor (k = 0; k < pdata->num_capture_formats; k++) {\n\t\tfmt = &pdata->capture_formats[k];\n\t\tif (fmt->fourcc == fourcc)\n\t\t\treturn fmt;\n\t}\n\n\tfor (k = 0; k < pdata->num_output_formats; k++) {\n\t\tfmt = &pdata->output_formats[k];\n\t\tif (fmt->fourcc == fourcc)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nstatic int vidioc_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tconst struct mtk_video_fmt *fmt;\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(fh);\n\n\tif (fsize->index != 0)\n\t\treturn -EINVAL;\n\n\tfmt = mtk_venc_find_format(fsize->pixel_format,\n\t\t\t\t   ctx->dev->venc_pdata);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\n\tif (ctx->dev->enc_capability & MTK_VENC_4K_CAPABILITY_ENABLE)\n\t\tfsize->stepwise = mtk_venc_4k_framesizes;\n\telse\n\t\tfsize->stepwise = mtk_venc_hd_framesizes;\n\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tconst struct mtk_vcodec_enc_pdata *pdata =\n\t\tfh_to_enc_ctx(priv)->dev->venc_pdata;\n\n\treturn vidioc_enum_fmt(f, pdata->capture_formats,\n\t\t\t       pdata->num_capture_formats);\n}\n\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tconst struct mtk_vcodec_enc_pdata *pdata =\n\t\tfh_to_enc_ctx(priv)->dev->venc_pdata;\n\n\treturn vidioc_enum_fmt(f, pdata->output_formats,\n\t\t\t       pdata->num_output_formats);\n}\n\nstatic int mtk_vcodec_enc_get_chip_name(void *priv)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\tstruct device *dev = &ctx->dev->plat_dev->dev;\n\n\tif (of_device_is_compatible(dev->of_node, \"mediatek,mt8173-vcodec-enc\"))\n\t\treturn 8173;\n\telse if (of_device_is_compatible(dev->of_node, \"mediatek,mt8183-vcodec-enc\"))\n\t\treturn 8183;\n\telse if (of_device_is_compatible(dev->of_node, \"mediatek,mt8192-vcodec-enc\"))\n\t\treturn 8192;\n\telse if (of_device_is_compatible(dev->of_node, \"mediatek,mt8195-vcodec-enc\"))\n\t\treturn 8195;\n\telse if (of_device_is_compatible(dev->of_node, \"mediatek,mt8188-vcodec-enc\"))\n\t\treturn 8188;\n\telse\n\t\treturn 8173;\n}\n\nstatic int vidioc_venc_querycap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\tstruct device *dev = &ctx->dev->plat_dev->dev;\n\tint platform_name = mtk_vcodec_enc_get_chip_name(priv);\n\n\tstrscpy(cap->driver, dev->driver->name, sizeof(cap->driver));\n\tsnprintf(cap->card, sizeof(cap->card), \"MT%d video encoder\", platform_name);\n\n\treturn 0;\n}\n\nstatic int vidioc_venc_s_parm(struct file *file, void *priv,\n\t\t\t      struct v4l2_streamparm *a)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\tstruct v4l2_fract *timeperframe = &a->parm.output.timeperframe;\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn -EINVAL;\n\n\tif (timeperframe->numerator == 0 || timeperframe->denominator == 0) {\n\t\ttimeperframe->numerator = MTK_DEFAULT_FRAMERATE_NUM;\n\t\ttimeperframe->denominator = MTK_DEFAULT_FRAMERATE_DENOM;\n\t}\n\n\tctx->enc_params.framerate_num = timeperframe->denominator;\n\tctx->enc_params.framerate_denom = timeperframe->numerator;\n\tctx->param_change |= MTK_ENCODE_PARAM_FRAMERATE;\n\n\ta->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\n\n\treturn 0;\n}\n\nstatic int vidioc_venc_g_parm(struct file *file, void *priv,\n\t\t\t      struct v4l2_streamparm *a)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn -EINVAL;\n\n\ta->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\n\ta->parm.output.timeperframe.denominator =\n\t\t\tctx->enc_params.framerate_num;\n\ta->parm.output.timeperframe.numerator =\n\t\t\tctx->enc_params.framerate_denom;\n\n\treturn 0;\n}\n\nstatic struct mtk_q_data *mtk_venc_get_q_data(struct mtk_vcodec_enc_ctx *ctx,\n\t\t\t\t\t      enum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn &ctx->q_data[MTK_Q_DATA_SRC];\n\n\treturn &ctx->q_data[MTK_Q_DATA_DST];\n}\n\nstatic void vidioc_try_fmt_cap(struct v4l2_format *f)\n{\n\tf->fmt.pix_mp.field = V4L2_FIELD_NONE;\n\tf->fmt.pix_mp.num_planes = 1;\n\tf->fmt.pix_mp.plane_fmt[0].bytesperline = 0;\n\tf->fmt.pix_mp.flags = 0;\n}\n\n \nstatic int vidioc_try_fmt_out(struct mtk_vcodec_enc_ctx *ctx, struct v4l2_format *f,\n\t\t\t      const struct mtk_video_fmt *fmt)\n{\n\tstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\n\tint tmp_w, tmp_h;\n\tunsigned int max_width, max_height;\n\n\tpix_fmt_mp->field = V4L2_FIELD_NONE;\n\n\tif (ctx->dev->enc_capability & MTK_VENC_4K_CAPABILITY_ENABLE) {\n\t\tmax_width = MTK_VENC_4K_MAX_W;\n\t\tmax_height = MTK_VENC_4K_MAX_H;\n\t} else {\n\t\tmax_width = MTK_VENC_HD_MAX_W;\n\t\tmax_height = MTK_VENC_HD_MAX_H;\n\t}\n\n\tpix_fmt_mp->height = clamp(pix_fmt_mp->height, MTK_VENC_MIN_H, max_height);\n\tpix_fmt_mp->width = clamp(pix_fmt_mp->width, MTK_VENC_MIN_W, max_width);\n\n\t \n\ttmp_w = pix_fmt_mp->width;\n\ttmp_h = pix_fmt_mp->height;\n\tv4l_bound_align_image(&pix_fmt_mp->width,\n\t\t\t      MTK_VENC_MIN_W,\n\t\t\t      max_width, 4,\n\t\t\t      &pix_fmt_mp->height,\n\t\t\t      MTK_VENC_MIN_H,\n\t\t\t      max_height, 5, 6);\n\n\tif (pix_fmt_mp->width < tmp_w && (pix_fmt_mp->width + 16) <= max_width)\n\t\tpix_fmt_mp->width += 16;\n\tif (pix_fmt_mp->height < tmp_h && (pix_fmt_mp->height + 32) <= max_height)\n\t\tpix_fmt_mp->height += 32;\n\n\tmtk_v4l2_venc_dbg(0, ctx,\n\t\t\t  \"before resize wxh=%dx%d, after resize wxh=%dx%d, sizeimage=%d %d\",\n\t\t\t  tmp_w, tmp_h, pix_fmt_mp->width,\n\t\t\t  pix_fmt_mp->height,\n\t\t\t  pix_fmt_mp->plane_fmt[0].sizeimage,\n\t\t\t  pix_fmt_mp->plane_fmt[1].sizeimage);\n\n\tpix_fmt_mp->num_planes = fmt->num_planes;\n\tpix_fmt_mp->plane_fmt[0].sizeimage =\n\t\t\tpix_fmt_mp->width * pix_fmt_mp->height +\n\t\t\t((ALIGN(pix_fmt_mp->width, 16) * 2) * 16);\n\tpix_fmt_mp->plane_fmt[0].bytesperline = pix_fmt_mp->width;\n\n\tif (pix_fmt_mp->num_planes == 2) {\n\t\tpix_fmt_mp->plane_fmt[1].sizeimage =\n\t\t\t(pix_fmt_mp->width * pix_fmt_mp->height) / 2 +\n\t\t\t(ALIGN(pix_fmt_mp->width, 16) * 16);\n\t\tpix_fmt_mp->plane_fmt[2].sizeimage = 0;\n\t\tpix_fmt_mp->plane_fmt[1].bytesperline =\n\t\t\t\t\t\tpix_fmt_mp->width;\n\t\tpix_fmt_mp->plane_fmt[2].bytesperline = 0;\n\t} else if (pix_fmt_mp->num_planes == 3) {\n\t\tpix_fmt_mp->plane_fmt[1].sizeimage =\n\t\tpix_fmt_mp->plane_fmt[2].sizeimage =\n\t\t\t(pix_fmt_mp->width * pix_fmt_mp->height) / 4 +\n\t\t\t((ALIGN(pix_fmt_mp->width, 16) / 2) * 16);\n\t\tpix_fmt_mp->plane_fmt[1].bytesperline =\n\t\t\tpix_fmt_mp->plane_fmt[2].bytesperline =\n\t\t\tpix_fmt_mp->width / 2;\n\t}\n\n\tpix_fmt_mp->flags = 0;\n\n\treturn 0;\n}\n\nstatic void mtk_venc_set_param(struct mtk_vcodec_enc_ctx *ctx,\n\t\t\t       struct venc_enc_param *param)\n{\n\tstruct mtk_q_data *q_data_src = &ctx->q_data[MTK_Q_DATA_SRC];\n\tstruct mtk_enc_params *enc_params = &ctx->enc_params;\n\n\tswitch (q_data_src->fmt->fourcc) {\n\tcase V4L2_PIX_FMT_YUV420M:\n\t\tparam->input_yuv_fmt = VENC_YUV_FORMAT_I420;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YVU420M:\n\t\tparam->input_yuv_fmt = VENC_YUV_FORMAT_YV12;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12M:\n\t\tparam->input_yuv_fmt = VENC_YUV_FORMAT_NV12;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV21M:\n\t\tparam->input_yuv_fmt = VENC_YUV_FORMAT_NV21;\n\t\tbreak;\n\tdefault:\n\t\tmtk_v4l2_venc_err(ctx, \"Unsupported fourcc =%d\", q_data_src->fmt->fourcc);\n\t\tbreak;\n\t}\n\tparam->h264_profile = enc_params->h264_profile;\n\tparam->h264_level = enc_params->h264_level;\n\n\t \n\tparam->width = q_data_src->visible_width;\n\tparam->height = q_data_src->visible_height;\n\t \n\tparam->buf_width = q_data_src->coded_width;\n\tparam->buf_height = q_data_src->coded_height;\n\tparam->frm_rate = enc_params->framerate_num /\n\t\t\tenc_params->framerate_denom;\n\tparam->intra_period = enc_params->intra_period;\n\tparam->gop_size = enc_params->gop_size;\n\tparam->bitrate = enc_params->bitrate;\n\n\tmtk_v4l2_venc_dbg(0, ctx,\n\t\t\t  \"fmt 0x%x, P/L %d/%d w/h %d/%d buf %d/%d fps/bps %d/%d gop %d i_per %d\",\n\t\t\t  param->input_yuv_fmt, param->h264_profile,\n\t\t\t  param->h264_level, param->width, param->height,\n\t\t\t  param->buf_width, param->buf_height,\n\t\t\t  param->frm_rate, param->bitrate,\n\t\t\t  param->gop_size, param->intra_period);\n}\n\nstatic int vidioc_venc_s_fmt_cap(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\tconst struct mtk_vcodec_enc_pdata *pdata = ctx->dev->venc_pdata;\n\tstruct vb2_queue *vq;\n\tstruct mtk_q_data *q_data = mtk_venc_get_q_data(ctx, f->type);\n\tint i, ret;\n\tconst struct mtk_video_fmt *fmt;\n\n\tvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\n\tif (!vq) {\n\t\tmtk_v4l2_venc_err(ctx, \"fail to get vq\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vb2_is_busy(vq)) {\n\t\tmtk_v4l2_venc_err(ctx, \"queue busy\");\n\t\treturn -EBUSY;\n\t}\n\n\tfmt = mtk_venc_find_format(f->fmt.pix.pixelformat, pdata);\n\tif (!fmt) {\n\t\tfmt = &ctx->dev->venc_pdata->capture_formats[0];\n\t\tf->fmt.pix.pixelformat = fmt->fourcc;\n\t}\n\n\tq_data->fmt = fmt;\n\tvidioc_try_fmt_cap(f);\n\n\tq_data->coded_width = f->fmt.pix_mp.width;\n\tq_data->coded_height = f->fmt.pix_mp.height;\n\tq_data->field = f->fmt.pix_mp.field;\n\n\tfor (i = 0; i < f->fmt.pix_mp.num_planes; i++) {\n\t\tstruct v4l2_plane_pix_format\t*plane_fmt;\n\n\t\tplane_fmt = &f->fmt.pix_mp.plane_fmt[i];\n\t\tq_data->bytesperline[i]\t= plane_fmt->bytesperline;\n\t\tq_data->sizeimage[i] = plane_fmt->sizeimage;\n\t}\n\n\tif (ctx->state == MTK_STATE_FREE) {\n\t\tret = venc_if_init(ctx, q_data->fmt->fourcc);\n\t\tif (ret) {\n\t\t\tmtk_v4l2_venc_err(ctx, \"venc_if_init failed=%d, codec type=%x\",\n\t\t\t\t\t  ret, q_data->fmt->fourcc);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tctx->state = MTK_STATE_INIT;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_venc_s_fmt_out(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\tconst struct mtk_vcodec_enc_pdata *pdata = ctx->dev->venc_pdata;\n\tstruct vb2_queue *vq;\n\tstruct mtk_q_data *q_data = mtk_venc_get_q_data(ctx, f->type);\n\tint ret, i;\n\tconst struct mtk_video_fmt *fmt;\n\n\tvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\n\tif (!vq) {\n\t\tmtk_v4l2_venc_err(ctx, \"fail to get vq\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vb2_is_busy(vq)) {\n\t\tmtk_v4l2_venc_err(ctx, \"queue busy\");\n\t\treturn -EBUSY;\n\t}\n\n\tfmt = mtk_venc_find_format(f->fmt.pix.pixelformat, pdata);\n\tif (!fmt) {\n\t\tfmt = &ctx->dev->venc_pdata->output_formats[0];\n\t\tf->fmt.pix.pixelformat = fmt->fourcc;\n\t}\n\n\tret = vidioc_try_fmt_out(ctx, f, fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tq_data->fmt = fmt;\n\tq_data->visible_width = f->fmt.pix_mp.width;\n\tq_data->visible_height = f->fmt.pix_mp.height;\n\tq_data->coded_width = f->fmt.pix_mp.width;\n\tq_data->coded_height = f->fmt.pix_mp.height;\n\n\tq_data->field = f->fmt.pix_mp.field;\n\tctx->colorspace = f->fmt.pix_mp.colorspace;\n\tctx->ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;\n\tctx->quantization = f->fmt.pix_mp.quantization;\n\tctx->xfer_func = f->fmt.pix_mp.xfer_func;\n\n\tfor (i = 0; i < f->fmt.pix_mp.num_planes; i++) {\n\t\tstruct v4l2_plane_pix_format *plane_fmt;\n\n\t\tplane_fmt = &f->fmt.pix_mp.plane_fmt[i];\n\t\tq_data->bytesperline[i] = plane_fmt->bytesperline;\n\t\tq_data->sizeimage[i] = plane_fmt->sizeimage;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_venc_g_fmt(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\tstruct vb2_queue *vq;\n\tstruct mtk_q_data *q_data = mtk_venc_get_q_data(ctx, f->type);\n\tint i;\n\n\tvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\n\tpix->width = q_data->coded_width;\n\tpix->height = q_data->coded_height;\n\tpix->pixelformat = q_data->fmt->fourcc;\n\tpix->field = q_data->field;\n\tpix->num_planes = q_data->fmt->num_planes;\n\tfor (i = 0; i < pix->num_planes; i++) {\n\t\tpix->plane_fmt[i].bytesperline = q_data->bytesperline[i];\n\t\tpix->plane_fmt[i].sizeimage = q_data->sizeimage[i];\n\t}\n\n\tpix->flags = 0;\n\tpix->colorspace = ctx->colorspace;\n\tpix->ycbcr_enc = ctx->ycbcr_enc;\n\tpix->quantization = ctx->quantization;\n\tpix->xfer_func = ctx->xfer_func;\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap_mplane(struct file *file, void *priv,\n\t\t\t\t\t struct v4l2_format *f)\n{\n\tconst struct mtk_video_fmt *fmt;\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\tconst struct mtk_vcodec_enc_pdata *pdata = ctx->dev->venc_pdata;\n\n\tfmt = mtk_venc_find_format(f->fmt.pix.pixelformat, pdata);\n\tif (!fmt) {\n\t\tfmt = &ctx->dev->venc_pdata->capture_formats[0];\n\t\tf->fmt.pix.pixelformat = fmt->fourcc;\n\t}\n\tf->fmt.pix_mp.colorspace = ctx->colorspace;\n\tf->fmt.pix_mp.ycbcr_enc = ctx->ycbcr_enc;\n\tf->fmt.pix_mp.quantization = ctx->quantization;\n\tf->fmt.pix_mp.xfer_func = ctx->xfer_func;\n\n\tvidioc_try_fmt_cap(f);\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_out_mplane(struct file *file, void *priv,\n\t\t\t\t\t struct v4l2_format *f)\n{\n\tconst struct mtk_video_fmt *fmt;\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\tconst struct mtk_vcodec_enc_pdata *pdata = ctx->dev->venc_pdata;\n\n\tfmt = mtk_venc_find_format(f->fmt.pix.pixelformat, pdata);\n\tif (!fmt) {\n\t\tfmt = &ctx->dev->venc_pdata->output_formats[0];\n\t\tf->fmt.pix.pixelformat = fmt->fourcc;\n\t}\n\tif (!f->fmt.pix_mp.colorspace) {\n\t\tf->fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709;\n\t\tf->fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\t\tf->fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT;\n\t\tf->fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\t}\n\n\treturn vidioc_try_fmt_out(ctx, f, fmt);\n}\n\nstatic int vidioc_venc_g_selection(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_selection *s)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\tstruct mtk_q_data *q_data = mtk_venc_get_q_data(ctx, s->type);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\ts->r.top = 0;\n\t\ts->r.left = 0;\n\t\ts->r.width = q_data->coded_width;\n\t\ts->r.height = q_data->coded_height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\ts->r.top = 0;\n\t\ts->r.left = 0;\n\t\ts->r.width = q_data->visible_width;\n\t\ts->r.height = q_data->visible_height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_venc_s_selection(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_selection *s)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\tstruct mtk_q_data *q_data = mtk_venc_get_q_data(ctx, s->type);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\t \n\t\ts->r.top = 0;\n\t\ts->r.left = 0;\n\t\ts->r.width = min(s->r.width, q_data->coded_width);\n\t\ts->r.height = min(s->r.height, q_data->coded_height);\n\t\tq_data->visible_width = s->r.width;\n\t\tq_data->visible_height = s->r.height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_venc_qbuf(struct file *file, void *priv,\n\t\t\t    struct v4l2_buffer *buf)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\n\tif (ctx->state == MTK_STATE_ABORT) {\n\t\tmtk_v4l2_venc_err(ctx, \"[%d] Call on QBUF after unrecoverable error\",\n\t\t\t\t  ctx->id);\n\t\treturn -EIO;\n\t}\n\n\treturn v4l2_m2m_qbuf(file, ctx->m2m_ctx, buf);\n}\n\nstatic int vidioc_venc_dqbuf(struct file *file, void *priv,\n\t\t\t     struct v4l2_buffer *buf)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\tint ret;\n\n\tif (ctx->state == MTK_STATE_ABORT) {\n\t\tmtk_v4l2_venc_err(ctx, \"[%d] Call on QBUF after unrecoverable error\",\n\t\t\t\t  ctx->id);\n\t\treturn -EIO;\n\t}\n\n\tret = v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!V4L2_TYPE_IS_OUTPUT(buf->type) &&\n\t    buf->flags & V4L2_BUF_FLAG_LAST &&\n\t    buf->m.planes[0].bytesused == 0 &&\n\t    ctx->is_flushing) {\n\t\t \n\t\tctx->is_flushing = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_encoder_cmd(struct file *file, void *priv,\n\t\t\t      struct v4l2_encoder_cmd *cmd)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(priv);\n\tstruct vb2_queue *src_vq, *dst_vq;\n\tint ret;\n\n\tif (ctx->state == MTK_STATE_ABORT) {\n\t\tmtk_v4l2_venc_err(ctx, \"[%d] Call to CMD after unrecoverable error\",\n\t\t\t\t  ctx->id);\n\t\treturn -EIO;\n\t}\n\n\tret = v4l2_m2m_ioctl_try_encoder_cmd(file, priv, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ctx->is_flushing)\n\t\treturn -EBUSY;\n\n\tmtk_v4l2_venc_dbg(1, ctx, \"encoder cmd=%u\", cmd->cmd);\n\n\tdst_vq = v4l2_m2m_get_vq(ctx->m2m_ctx,\n\t\t\t\t V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tswitch (cmd->cmd) {\n\tcase V4L2_ENC_CMD_STOP:\n\t\tsrc_vq = v4l2_m2m_get_vq(ctx->m2m_ctx,\n\t\t\t\t\t V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\t\tif (!vb2_is_streaming(src_vq)) {\n\t\t\tmtk_v4l2_venc_dbg(1, ctx, \"Output stream is off. No need to flush.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (!vb2_is_streaming(dst_vq)) {\n\t\t\tmtk_v4l2_venc_dbg(1, ctx, \"Capture stream is off. No need to flush.\");\n\t\t\treturn 0;\n\t\t}\n\t\tctx->is_flushing = true;\n\t\tv4l2_m2m_buf_queue(ctx->m2m_ctx, &ctx->empty_flush_buf.vb);\n\t\tv4l2_m2m_try_schedule(ctx->m2m_ctx);\n\t\tbreak;\n\n\tcase V4L2_ENC_CMD_START:\n\t\tvb2_clear_last_buffer_dequeued(dst_vq);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nconst struct v4l2_ioctl_ops mtk_venc_ioctl_ops = {\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vidioc_venc_qbuf,\n\t.vidioc_dqbuf\t\t\t= vidioc_venc_dqbuf,\n\n\t.vidioc_querycap\t\t= vidioc_venc_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= vidioc_enum_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_out\t= vidioc_enum_fmt_vid_out,\n\t.vidioc_enum_framesizes\t\t= vidioc_enum_framesizes,\n\n\t.vidioc_try_fmt_vid_cap_mplane\t= vidioc_try_fmt_vid_cap_mplane,\n\t.vidioc_try_fmt_vid_out_mplane\t= vidioc_try_fmt_vid_out_mplane,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n\n\t.vidioc_s_parm\t\t\t= vidioc_venc_s_parm,\n\t.vidioc_g_parm\t\t\t= vidioc_venc_g_parm,\n\t.vidioc_s_fmt_vid_cap_mplane\t= vidioc_venc_s_fmt_cap,\n\t.vidioc_s_fmt_vid_out_mplane\t= vidioc_venc_s_fmt_out,\n\n\t.vidioc_g_fmt_vid_cap_mplane\t= vidioc_venc_g_fmt,\n\t.vidioc_g_fmt_vid_out_mplane\t= vidioc_venc_g_fmt,\n\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= v4l2_m2m_ioctl_prepare_buf,\n\n\t.vidioc_g_selection\t\t= vidioc_venc_g_selection,\n\t.vidioc_s_selection\t\t= vidioc_venc_s_selection,\n\n\t.vidioc_encoder_cmd\t\t= vidioc_encoder_cmd,\n\t.vidioc_try_encoder_cmd\t\t= v4l2_m2m_ioctl_try_encoder_cmd,\n};\n\nstatic int vb2ops_venc_queue_setup(struct vb2_queue *vq,\n\t\t\t\t   unsigned int *nbuffers,\n\t\t\t\t   unsigned int *nplanes,\n\t\t\t\t   unsigned int sizes[],\n\t\t\t\t   struct device *alloc_devs[])\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct mtk_q_data *q_data = mtk_venc_get_q_data(ctx, vq->type);\n\tunsigned int i;\n\n\tif (q_data == NULL)\n\t\treturn -EINVAL;\n\n\tif (*nplanes) {\n\t\tif (*nplanes != q_data->fmt->num_planes)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < *nplanes; i++)\n\t\t\tif (sizes[i] < q_data->sizeimage[i])\n\t\t\t\treturn -EINVAL;\n\t} else {\n\t\t*nplanes = q_data->fmt->num_planes;\n\t\tfor (i = 0; i < *nplanes; i++)\n\t\t\tsizes[i] = q_data->sizeimage[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int vb2ops_venc_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct mtk_q_data *q_data = mtk_venc_get_q_data(ctx, vb->vb2_queue->type);\n\tint i;\n\n\tfor (i = 0; i < q_data->fmt->num_planes; i++) {\n\t\tif (vb2_plane_size(vb, i) < q_data->sizeimage[i]) {\n\t\t\tmtk_v4l2_venc_err(ctx, \"data will not fit into plane %d (%lu < %d)\",\n\t\t\t\t\t  i, vb2_plane_size(vb, i), q_data->sizeimage[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void vb2ops_venc_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vb2_v4l2 =\n\t\t\tcontainer_of(vb, struct vb2_v4l2_buffer, vb2_buf);\n\n\tstruct mtk_video_enc_buf *mtk_buf =\n\t\t\tcontainer_of(vb2_v4l2, struct mtk_video_enc_buf,\n\t\t\t\t     m2m_buf.vb);\n\n\tif ((vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) &&\n\t    (ctx->param_change != MTK_ENCODE_PARAM_NONE)) {\n\t\tmtk_v4l2_venc_dbg(1, ctx, \"[%d] Before id=%d encode parameter change %x\",\n\t\t\t\t  ctx->id, vb2_v4l2->vb2_buf.index, ctx->param_change);\n\t\tmtk_buf->param_change = ctx->param_change;\n\t\tmtk_buf->enc_params = ctx->enc_params;\n\t\tctx->param_change = MTK_ENCODE_PARAM_NONE;\n\t}\n\n\tv4l2_m2m_buf_queue(ctx->m2m_ctx, to_vb2_v4l2_buffer(vb));\n}\n\nstatic int vb2ops_venc_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct venc_enc_param param;\n\tint ret, pm_ret;\n\tint i;\n\n\t \n\tif ((ctx->state == MTK_STATE_ABORT) || (ctx->state == MTK_STATE_FREE)) {\n\t\tret = -EIO;\n\t\tgoto err_start_stream;\n\t}\n\n\t \n\tif (V4L2_TYPE_IS_OUTPUT(q->type)) {\n\t\tif (!vb2_start_streaming_called(&ctx->m2m_ctx->cap_q_ctx.q))\n\t\t\treturn 0;\n\t} else {\n\t\tif (!vb2_start_streaming_called(&ctx->m2m_ctx->out_q_ctx.q))\n\t\t\treturn 0;\n\t}\n\n\tret = pm_runtime_resume_and_get(&ctx->dev->plat_dev->dev);\n\tif (ret < 0) {\n\t\tmtk_v4l2_venc_err(ctx, \"pm_runtime_resume_and_get fail %d\", ret);\n\t\tgoto err_start_stream;\n\t}\n\n\tmtk_venc_set_param(ctx, &param);\n\tret = venc_if_set_param(ctx, VENC_SET_PARAM_ENC, &param);\n\tif (ret) {\n\t\tmtk_v4l2_venc_err(ctx, \"venc_if_set_param failed=%d\", ret);\n\t\tctx->state = MTK_STATE_ABORT;\n\t\tgoto err_set_param;\n\t}\n\tctx->param_change = MTK_ENCODE_PARAM_NONE;\n\n\tif ((ctx->q_data[MTK_Q_DATA_DST].fmt->fourcc == V4L2_PIX_FMT_H264) &&\n\t    (ctx->enc_params.seq_hdr_mode !=\n\t\t\t\tV4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE)) {\n\t\tret = venc_if_set_param(ctx,\n\t\t\t\t\tVENC_SET_PARAM_PREPEND_HEADER,\n\t\t\t\t\tNULL);\n\t\tif (ret) {\n\t\t\tmtk_v4l2_venc_err(ctx, \"venc_if_set_param failed=%d\", ret);\n\t\t\tctx->state = MTK_STATE_ABORT;\n\t\t\tgoto err_set_param;\n\t\t}\n\t\tctx->state = MTK_STATE_HEADER;\n\t}\n\n\treturn 0;\n\nerr_set_param:\n\tpm_ret = pm_runtime_put(&ctx->dev->plat_dev->dev);\n\tif (pm_ret < 0)\n\t\tmtk_v4l2_venc_err(ctx, \"pm_runtime_put fail %d\", pm_ret);\n\nerr_start_stream:\n\tfor (i = 0; i < q->num_buffers; ++i) {\n\t\tstruct vb2_buffer *buf = vb2_get_buffer(q, i);\n\n\t\t \n\t\tif (buf && buf->state == VB2_BUF_STATE_ACTIVE) {\n\t\t\tmtk_v4l2_venc_dbg(0, ctx, \"[%d] id=%d, type=%d, %d->VB2_BUF_STATE_QUEUED\",\n\t\t\t\t\t  ctx->id, i, q->type, (int)buf->state);\n\t\t\tv4l2_m2m_buf_done(to_vb2_v4l2_buffer(buf),\n\t\t\t\t\t  VB2_BUF_STATE_QUEUED);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void vb2ops_venc_stop_streaming(struct vb2_queue *q)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tint ret;\n\n\tmtk_v4l2_venc_dbg(2, ctx, \"[%d]-> type=%d\", ctx->id, q->type);\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\twhile ((dst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx))) {\n\t\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, 0);\n\t\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\n\t\t}\n\t\t \n\t\tif (ctx->is_flushing) {\n\t\t\tstruct v4l2_m2m_buffer *b, *n;\n\n\t\t\tmtk_v4l2_venc_dbg(1, ctx, \"STREAMOFF called while flushing\");\n\t\t\t \n\t\t\tv4l2_m2m_for_each_src_buf_safe(ctx->m2m_ctx, b, n) {\n\t\t\t\tif (b == &ctx->empty_flush_buf) {\n\t\t\t\t\tv4l2_m2m_src_buf_remove_by_buf(ctx->m2m_ctx, &b->vb);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->is_flushing = false;\n\t\t}\n\t} else {\n\t\twhile ((src_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx))) {\n\t\t\tif (src_buf != &ctx->empty_flush_buf.vb)\n\t\t\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\n\t\t}\n\t\tif (ctx->is_flushing) {\n\t\t\t \n\t\t\tv4l2_m2m_buf_queue(ctx->m2m_ctx,\n\t\t\t\t\t   &ctx->empty_flush_buf.vb);\n\t\t}\n\t}\n\n\tif ((q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\n\t     vb2_is_streaming(&ctx->m2m_ctx->out_q_ctx.q)) ||\n\t    (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&\n\t     vb2_is_streaming(&ctx->m2m_ctx->cap_q_ctx.q))) {\n\t\tmtk_v4l2_venc_dbg(1, ctx, \"[%d]-> q type %d out=%d cap=%d\",\n\t\t\t\t  ctx->id, q->type,\n\t\t\t\t  vb2_is_streaming(&ctx->m2m_ctx->out_q_ctx.q),\n\t\t\t\t  vb2_is_streaming(&ctx->m2m_ctx->cap_q_ctx.q));\n\t\treturn;\n\t}\n\n\t \n\tret = venc_if_deinit(ctx);\n\tif (ret)\n\t\tmtk_v4l2_venc_err(ctx, \"venc_if_deinit failed=%d\", ret);\n\n\tret = pm_runtime_put(&ctx->dev->plat_dev->dev);\n\tif (ret < 0)\n\t\tmtk_v4l2_venc_err(ctx, \"pm_runtime_put fail %d\", ret);\n\n\tctx->state = MTK_STATE_FREE;\n}\n\nstatic int vb2ops_venc_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\treturn 0;\n}\n\nstatic const struct vb2_ops mtk_venc_vb2_ops = {\n\t.queue_setup\t\t= vb2ops_venc_queue_setup,\n\t.buf_out_validate\t= vb2ops_venc_buf_out_validate,\n\t.buf_prepare\t\t= vb2ops_venc_buf_prepare,\n\t.buf_queue\t\t= vb2ops_venc_buf_queue,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.start_streaming\t= vb2ops_venc_start_streaming,\n\t.stop_streaming\t\t= vb2ops_venc_stop_streaming,\n};\n\nstatic int mtk_venc_encode_header(void *priv)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = priv;\n\tint ret;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct mtk_vcodec_mem bs_buf;\n\tstruct venc_done_result enc_result;\n\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\n\tif (!dst_buf) {\n\t\tmtk_v4l2_venc_dbg(1, ctx, \"No dst buffer\");\n\t\treturn -EINVAL;\n\t}\n\n\tbs_buf.va = vb2_plane_vaddr(&dst_buf->vb2_buf, 0);\n\tbs_buf.dma_addr = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\tbs_buf.size = (size_t)dst_buf->vb2_buf.planes[0].length;\n\n\tmtk_v4l2_venc_dbg(1, ctx,\n\t\t\t  \"[%d] buf id=%d va=0x%p dma_addr=0x%llx size=%zu\",\n\t\t\t  ctx->id, dst_buf->vb2_buf.index, bs_buf.va,\n\t\t\t  (u64)bs_buf.dma_addr, bs_buf.size);\n\n\tret = venc_if_encode(ctx,\n\t\t\tVENC_START_OPT_ENCODE_SEQUENCE_HEADER,\n\t\t\tNULL, &bs_buf, &enc_result);\n\n\tif (ret) {\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, 0);\n\t\tctx->state = MTK_STATE_ABORT;\n\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\n\t\tmtk_v4l2_venc_err(ctx, \"venc_if_encode failed=%d\", ret);\n\t\treturn -EINVAL;\n\t}\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\n\tif (src_buf) {\n\t\tdst_buf->vb2_buf.timestamp = src_buf->vb2_buf.timestamp;\n\t\tdst_buf->timecode = src_buf->timecode;\n\t} else {\n\t\tmtk_v4l2_venc_err(ctx, \"No timestamp for the header buffer.\");\n\t}\n\n\tctx->state = MTK_STATE_HEADER;\n\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, enc_result.bs_size);\n\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);\n\n\treturn 0;\n}\n\nstatic int mtk_venc_param_change(struct mtk_vcodec_enc_ctx *ctx)\n{\n\tstruct venc_enc_param enc_prm;\n\tstruct vb2_v4l2_buffer *vb2_v4l2 = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\n\tstruct mtk_video_enc_buf *mtk_buf;\n\tint ret = 0;\n\n\t \n\tif (vb2_v4l2 == &ctx->empty_flush_buf.vb)\n\t\treturn 0;\n\n\tmtk_buf = container_of(vb2_v4l2, struct mtk_video_enc_buf, m2m_buf.vb);\n\n\tmemset(&enc_prm, 0, sizeof(enc_prm));\n\tif (mtk_buf->param_change == MTK_ENCODE_PARAM_NONE)\n\t\treturn 0;\n\n\tif (mtk_buf->param_change & MTK_ENCODE_PARAM_BITRATE) {\n\t\tenc_prm.bitrate = mtk_buf->enc_params.bitrate;\n\t\tmtk_v4l2_venc_dbg(1, ctx, \"[%d] id=%d, change param br=%d\",\n\t\t\t\t  ctx->id, vb2_v4l2->vb2_buf.index, enc_prm.bitrate);\n\t\tret |= venc_if_set_param(ctx,\n\t\t\t\t\t VENC_SET_PARAM_ADJUST_BITRATE,\n\t\t\t\t\t &enc_prm);\n\t}\n\tif (!ret && mtk_buf->param_change & MTK_ENCODE_PARAM_FRAMERATE) {\n\t\tenc_prm.frm_rate = mtk_buf->enc_params.framerate_num /\n\t\t\t\t   mtk_buf->enc_params.framerate_denom;\n\t\tmtk_v4l2_venc_dbg(1, ctx, \"[%d] id=%d, change param fr=%d\",\n\t\t\t\t  ctx->id, vb2_v4l2->vb2_buf.index, enc_prm.frm_rate);\n\t\tret |= venc_if_set_param(ctx,\n\t\t\t\t\t VENC_SET_PARAM_ADJUST_FRAMERATE,\n\t\t\t\t\t &enc_prm);\n\t}\n\tif (!ret && mtk_buf->param_change & MTK_ENCODE_PARAM_GOP_SIZE) {\n\t\tenc_prm.gop_size = mtk_buf->enc_params.gop_size;\n\t\tmtk_v4l2_venc_dbg(1, ctx, \"change param intra period=%d\", enc_prm.gop_size);\n\t\tret |= venc_if_set_param(ctx,\n\t\t\t\t\t VENC_SET_PARAM_GOP_SIZE,\n\t\t\t\t\t &enc_prm);\n\t}\n\tif (!ret && mtk_buf->param_change & MTK_ENCODE_PARAM_FORCE_INTRA) {\n\t\tmtk_v4l2_venc_dbg(1, ctx, \"[%d] id=%d, change param force I=%d\",\n\t\t\t\t  ctx->id, vb2_v4l2->vb2_buf.index,\n\t\t\t\t  mtk_buf->enc_params.force_intra);\n\t\tif (mtk_buf->enc_params.force_intra)\n\t\t\tret |= venc_if_set_param(ctx,\n\t\t\t\t\t\t VENC_SET_PARAM_FORCE_INTRA,\n\t\t\t\t\t\t NULL);\n\t}\n\n\tmtk_buf->param_change = MTK_ENCODE_PARAM_NONE;\n\n\tif (ret) {\n\t\tctx->state = MTK_STATE_ABORT;\n\t\tmtk_v4l2_venc_err(ctx, \"venc_if_set_param %d failed=%d\",\n\t\t\t\t  mtk_buf->param_change, ret);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void mtk_venc_worker(struct work_struct *work)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = container_of(work, struct mtk_vcodec_enc_ctx,\n\t\t\t\t    encode_work);\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct venc_frm_buf frm_buf;\n\tstruct mtk_vcodec_mem bs_buf;\n\tstruct venc_done_result enc_result;\n\tint ret, i;\n\n\t \n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\n\tif (!dst_buf) {\n\t\tv4l2_m2m_job_finish(ctx->dev->m2m_dev_enc, ctx->m2m_ctx);\n\t\treturn;\n\t}\n\n\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\n\t \n\tif (src_buf == &ctx->empty_flush_buf.vb) {\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, 0);\n\t\tdst_buf->flags |= V4L2_BUF_FLAG_LAST;\n\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_job_finish(ctx->dev->m2m_dev_enc, ctx->m2m_ctx);\n\t\treturn;\n\t}\n\n\tmemset(&frm_buf, 0, sizeof(frm_buf));\n\tfor (i = 0; i < src_buf->vb2_buf.num_planes ; i++) {\n\t\tfrm_buf.fb_addr[i].dma_addr =\n\t\t\t\tvb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, i);\n\t\tfrm_buf.fb_addr[i].size =\n\t\t\t\t(size_t)src_buf->vb2_buf.planes[i].length;\n\t}\n\tbs_buf.va = vb2_plane_vaddr(&dst_buf->vb2_buf, 0);\n\tbs_buf.dma_addr = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\tbs_buf.size = (size_t)dst_buf->vb2_buf.planes[0].length;\n\n\tmtk_v4l2_venc_dbg(2, ctx,\n\t\t\t  \"Framebuf PA=%llx Size=0x%zx;PA=0x%llx Size=0x%zx;PA=0x%llx Size=%zu\",\n\t\t\t  (u64)frm_buf.fb_addr[0].dma_addr, frm_buf.fb_addr[0].size,\n\t\t\t  (u64)frm_buf.fb_addr[1].dma_addr, frm_buf.fb_addr[1].size,\n\t\t\t  (u64)frm_buf.fb_addr[2].dma_addr, frm_buf.fb_addr[2].size);\n\n\tret = venc_if_encode(ctx, VENC_START_OPT_ENCODE_FRAME,\n\t\t\t     &frm_buf, &bs_buf, &enc_result);\n\n\tdst_buf->vb2_buf.timestamp = src_buf->vb2_buf.timestamp;\n\tdst_buf->timecode = src_buf->timecode;\n\n\tif (enc_result.is_key_frm)\n\t\tdst_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;\n\n\tif (ret) {\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, 0);\n\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\n\t\tmtk_v4l2_venc_err(ctx, \"venc_if_encode failed=%d\", ret);\n\t} else {\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, enc_result.bs_size);\n\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);\n\t\tmtk_v4l2_venc_dbg(2, ctx, \"venc_if_encode bs size=%d\",\n\t\t\t\t  enc_result.bs_size);\n\t}\n\n\tv4l2_m2m_job_finish(ctx->dev->m2m_dev_enc, ctx->m2m_ctx);\n\n\tmtk_v4l2_venc_dbg(1, ctx, \"<=== src_buf[%d] dst_buf[%d] venc_if_encode ret=%d Size=%u===>\",\n\t\t\t  src_buf->vb2_buf.index, dst_buf->vb2_buf.index, ret, enc_result.bs_size);\n}\n\nstatic void m2mops_venc_device_run(void *priv)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = priv;\n\n\tif ((ctx->q_data[MTK_Q_DATA_DST].fmt->fourcc == V4L2_PIX_FMT_H264) &&\n\t    (ctx->state != MTK_STATE_HEADER)) {\n\t\t \n\t\tmtk_venc_encode_header(ctx);\n\t\tqueue_work(ctx->dev->encode_workqueue, &ctx->encode_work);\n\t\treturn;\n\t}\n\n\tmtk_venc_param_change(ctx);\n\tqueue_work(ctx->dev->encode_workqueue, &ctx->encode_work);\n}\n\nstatic int m2mops_venc_job_ready(void *m2m_priv)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = m2m_priv;\n\n\tif (ctx->state == MTK_STATE_ABORT || ctx->state == MTK_STATE_FREE) {\n\t\tmtk_v4l2_venc_dbg(3, ctx, \"[%d]Not ready: state=0x%x.\", ctx->id, ctx->state);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void m2mops_venc_job_abort(void *priv)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = priv;\n\n\tctx->state = MTK_STATE_ABORT;\n}\n\nconst struct v4l2_m2m_ops mtk_venc_m2m_ops = {\n\t.device_run\t= m2mops_venc_device_run,\n\t.job_ready\t= m2mops_venc_job_ready,\n\t.job_abort\t= m2mops_venc_job_abort,\n};\n\nvoid mtk_vcodec_enc_set_default_params(struct mtk_vcodec_enc_ctx *ctx)\n{\n\tstruct mtk_q_data *q_data;\n\n\tctx->m2m_ctx->q_lock = &ctx->q_mutex;\n\tctx->fh.m2m_ctx = ctx->m2m_ctx;\n\tctx->fh.ctrl_handler = &ctx->ctrl_hdl;\n\tINIT_WORK(&ctx->encode_work, mtk_venc_worker);\n\n\tctx->colorspace = V4L2_COLORSPACE_REC709;\n\tctx->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tctx->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tctx->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\n\tq_data = &ctx->q_data[MTK_Q_DATA_SRC];\n\tmemset(q_data, 0, sizeof(struct mtk_q_data));\n\tq_data->visible_width = DFT_CFG_WIDTH;\n\tq_data->visible_height = DFT_CFG_HEIGHT;\n\tq_data->coded_width = DFT_CFG_WIDTH;\n\tq_data->coded_height = DFT_CFG_HEIGHT;\n\tq_data->field = V4L2_FIELD_NONE;\n\n\tq_data->fmt = &ctx->dev->venc_pdata->output_formats[0];\n\n\tv4l_bound_align_image(&q_data->coded_width,\n\t\t\t\tMTK_VENC_MIN_W,\n\t\t\t\tMTK_VENC_HD_MAX_W, 4,\n\t\t\t\t&q_data->coded_height,\n\t\t\t\tMTK_VENC_MIN_H,\n\t\t\t\tMTK_VENC_HD_MAX_H, 5, 6);\n\n\tif (q_data->coded_width < DFT_CFG_WIDTH &&\n\t\t(q_data->coded_width + 16) <= MTK_VENC_HD_MAX_W)\n\t\tq_data->coded_width += 16;\n\tif (q_data->coded_height < DFT_CFG_HEIGHT &&\n\t\t(q_data->coded_height + 32) <= MTK_VENC_HD_MAX_H)\n\t\tq_data->coded_height += 32;\n\n\tq_data->sizeimage[0] =\n\t\tq_data->coded_width * q_data->coded_height+\n\t\t((ALIGN(q_data->coded_width, 16) * 2) * 16);\n\tq_data->bytesperline[0] = q_data->coded_width;\n\tq_data->sizeimage[1] =\n\t\t(q_data->coded_width * q_data->coded_height) / 2 +\n\t\t(ALIGN(q_data->coded_width, 16) * 16);\n\tq_data->bytesperline[1] = q_data->coded_width;\n\n\tq_data = &ctx->q_data[MTK_Q_DATA_DST];\n\tmemset(q_data, 0, sizeof(struct mtk_q_data));\n\tq_data->coded_width = DFT_CFG_WIDTH;\n\tq_data->coded_height = DFT_CFG_HEIGHT;\n\tq_data->fmt = &ctx->dev->venc_pdata->capture_formats[0];\n\tq_data->field = V4L2_FIELD_NONE;\n\tctx->q_data[MTK_Q_DATA_DST].sizeimage[0] =\n\t\tDFT_CFG_WIDTH * DFT_CFG_HEIGHT;\n\tctx->q_data[MTK_Q_DATA_DST].bytesperline[0] = 0;\n\n\tctx->enc_params.framerate_num = MTK_DEFAULT_FRAMERATE_NUM;\n\tctx->enc_params.framerate_denom = MTK_DEFAULT_FRAMERATE_DENOM;\n}\n\nint mtk_vcodec_enc_ctrls_setup(struct mtk_vcodec_enc_ctx *ctx)\n{\n\tconst struct v4l2_ctrl_ops *ops = &mtk_vcodec_enc_ctrl_ops;\n\tstruct v4l2_ctrl_handler *handler = &ctx->ctrl_hdl;\n\tu8 h264_max_level;\n\n\tif (ctx->dev->enc_capability & MTK_VENC_4K_CAPABILITY_ENABLE)\n\t\th264_max_level = V4L2_MPEG_VIDEO_H264_LEVEL_5_1;\n\telse\n\t\th264_max_level = V4L2_MPEG_VIDEO_H264_LEVEL_4_2;\n\n\tv4l2_ctrl_handler_init(handler, MTK_MAX_CTRLS_HINT);\n\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_MIN_BUFFERS_FOR_OUTPUT,\n\t\t\t  1, 1, 1, 1);\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_BITRATE,\n\t\t\t  ctx->dev->venc_pdata->min_bitrate,\n\t\t\t  ctx->dev->venc_pdata->max_bitrate, 1, 4000000);\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_B_FRAMES,\n\t\t\t0, 2, 1, 0);\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE,\n\t\t\t0, 1, 1, 1);\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_H264_MAX_QP,\n\t\t\t0, 51, 1, 51);\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_H264_I_PERIOD,\n\t\t\t0, 65535, 1, 0);\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_GOP_SIZE,\n\t\t\t0, 65535, 1, 0);\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE,\n\t\t\t0, 1, 1, 0);\n\tv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME,\n\t\t\t0, 0, 0, 0);\n\tv4l2_ctrl_new_std_menu(handler, ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_HEADER_MODE,\n\t\t\tV4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME,\n\t\t\t0, V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE);\n\tv4l2_ctrl_new_std_menu(handler, ops, V4L2_CID_MPEG_VIDEO_H264_PROFILE,\n\t\t\tV4L2_MPEG_VIDEO_H264_PROFILE_HIGH,\n\t\t\t~((1 << V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE) |\n\t\t\t  (1 << V4L2_MPEG_VIDEO_H264_PROFILE_MAIN) |\n\t\t\t  (1 << V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)),\n\t\t\tV4L2_MPEG_VIDEO_H264_PROFILE_HIGH);\n\tv4l2_ctrl_new_std_menu(handler, ops, V4L2_CID_MPEG_VIDEO_H264_LEVEL,\n\t\t\t       h264_max_level,\n\t\t\t       0, V4L2_MPEG_VIDEO_H264_LEVEL_4_0);\n\tv4l2_ctrl_new_std_menu(handler, ops, V4L2_CID_MPEG_VIDEO_VP8_PROFILE,\n\t\t\t       V4L2_MPEG_VIDEO_VP8_PROFILE_0, 0, V4L2_MPEG_VIDEO_VP8_PROFILE_0);\n\tv4l2_ctrl_new_std_menu(handler, ops, V4L2_CID_MPEG_VIDEO_BITRATE_MODE,\n\t\t\t       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR,\n\t\t\t       ~(1 << V4L2_MPEG_VIDEO_BITRATE_MODE_CBR),\n\t\t\t       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR);\n\n\n\tif (handler->error) {\n\t\tmtk_v4l2_venc_err(ctx, \"Init control handler fail %d\", handler->error);\n\t\treturn handler->error;\n\t}\n\n\tv4l2_ctrl_handler_setup(&ctx->ctrl_hdl);\n\n\treturn 0;\n}\n\nint mtk_vcodec_enc_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx = priv;\n\tint ret;\n\n\t \n\tsrc_vq->type\t\t= V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes\t= VB2_DMABUF | VB2_MMAP | VB2_USERPTR;\n\tsrc_vq->drv_priv\t= ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct mtk_video_enc_buf);\n\tsrc_vq->ops\t\t= &mtk_venc_vb2_ops;\n\tsrc_vq->mem_ops\t\t= &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock\t\t= &ctx->q_mutex;\n\tsrc_vq->dev\t\t= &ctx->dev->plat_dev->dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type\t\t= V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes\t= VB2_DMABUF | VB2_MMAP | VB2_USERPTR;\n\tdst_vq->drv_priv\t= ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops\t\t= &mtk_venc_vb2_ops;\n\tdst_vq->mem_ops\t\t= &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock\t\t= &ctx->q_mutex;\n\tdst_vq->dev\t\t= &ctx->dev->plat_dev->dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nint mtk_venc_unlock(struct mtk_vcodec_enc_ctx *ctx)\n{\n\tstruct mtk_vcodec_enc_dev *dev = ctx->dev;\n\n\tmutex_unlock(&dev->enc_mutex);\n\treturn 0;\n}\n\nint mtk_venc_lock(struct mtk_vcodec_enc_ctx *ctx)\n{\n\tstruct mtk_vcodec_enc_dev *dev = ctx->dev;\n\n\tmutex_lock(&dev->enc_mutex);\n\treturn 0;\n}\n\nvoid mtk_vcodec_enc_release(struct mtk_vcodec_enc_ctx *ctx)\n{\n\tint ret = venc_if_deinit(ctx);\n\n\tif (ret)\n\t\tmtk_v4l2_venc_err(ctx, \"venc_if_deinit failed=%d\", ret);\n\n\tctx->state = MTK_STATE_FREE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}