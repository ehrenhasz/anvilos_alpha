{
  "module_name": "venc_vpu_if.c",
  "hash_id": "bdd67a682be8dd270b326f8dceaf4dc7b0fed757d5aa003198ebb603e53150eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/encoder/venc_vpu_if.c",
  "human_readable_source": "\n \n\n#include \"mtk_vcodec_enc_drv.h\"\n#include \"venc_ipi_msg.h\"\n#include \"venc_vpu_if.h\"\n\nstatic void handle_enc_init_msg(struct venc_vpu_inst *vpu, const void *data)\n{\n\tconst struct venc_vpu_ipi_msg_init *msg = data;\n\n\tvpu->inst_addr = msg->vpu_inst_addr;\n\tvpu->vsi = mtk_vcodec_fw_map_dm_addr(vpu->ctx->dev->fw_handler,\n\t\t\t\t\t     msg->vpu_inst_addr);\n\n\t \n\tif (mtk_vcodec_fw_get_type(vpu->ctx->dev->fw_handler) == VPU)\n\t\treturn;\n\n\t \n\tmtk_venc_debug(vpu->ctx, \"firmware version: 0x%x\\n\", msg->venc_abi_version);\n\tswitch (msg->venc_abi_version) {\n\tcase 1:\n\t\tbreak;\n\tdefault:\n\t\tmtk_venc_err(vpu->ctx, \"unhandled firmware version 0x%x\\n\",\n\t\t\t     msg->venc_abi_version);\n\t\tvpu->failure = 1;\n\t\tbreak;\n\t}\n}\n\nstatic void handle_enc_encode_msg(struct venc_vpu_inst *vpu, const void *data)\n{\n\tconst struct venc_vpu_ipi_msg_enc *msg = data;\n\n\tvpu->state = msg->state;\n\tvpu->bs_size = msg->bs_size;\n\tvpu->is_key_frm = msg->is_key_frm;\n}\n\nstatic bool vpu_enc_check_ap_inst(struct mtk_vcodec_enc_dev *enc_dev, struct venc_vpu_inst *vpu)\n{\n\tstruct mtk_vcodec_enc_ctx *ctx;\n\tint ret = false;\n\n\tlist_for_each_entry(ctx, &enc_dev->ctx_list, list) {\n\t\tif (!IS_ERR_OR_NULL(ctx) && ctx->vpu_inst == vpu) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void vpu_enc_ipi_handler(void *data, unsigned int len, void *priv)\n{\n\tstruct mtk_vcodec_enc_dev *enc_dev;\n\tconst struct venc_vpu_ipi_msg_common *msg = data;\n\tstruct venc_vpu_inst *vpu;\n\n\tenc_dev = (struct mtk_vcodec_enc_dev *)priv;\n\tvpu = (struct venc_vpu_inst *)(unsigned long)msg->venc_inst;\n\tif (!priv || !vpu) {\n\t\tpr_err(MTK_DBG_V4L2_STR \"venc_inst is NULL, did the SCP hang or crash?\");\n\t\treturn;\n\t}\n\n\tmtk_venc_debug(vpu->ctx, \"msg_id %x inst %p status %d\", msg->msg_id, vpu, msg->status);\n\tif (!vpu_enc_check_ap_inst(enc_dev, vpu) || msg->msg_id < VPU_IPIMSG_ENC_INIT_DONE ||\n\t    msg->msg_id > VPU_IPIMSG_ENC_DEINIT_DONE) {\n\t\tmtk_v4l2_venc_err(vpu->ctx, \"venc msg id not correctly => 0x%x\", msg->msg_id);\n\t\tvpu->failure = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tvpu->failure = (msg->status != VENC_IPI_MSG_STATUS_OK);\n\tif (vpu->failure) {\n\t\tmtk_venc_err(vpu->ctx, \"vpu enc status failure %d\", vpu->failure);\n\t\tgoto error;\n\t}\n\n\tswitch (msg->msg_id) {\n\tcase VPU_IPIMSG_ENC_INIT_DONE:\n\t\thandle_enc_init_msg(vpu, data);\n\t\tbreak;\n\tcase VPU_IPIMSG_ENC_SET_PARAM_DONE:\n\t\tbreak;\n\tcase VPU_IPIMSG_ENC_ENCODE_DONE:\n\t\thandle_enc_encode_msg(vpu, data);\n\t\tbreak;\n\tcase VPU_IPIMSG_ENC_DEINIT_DONE:\n\t\tbreak;\n\tdefault:\n\t\tmtk_venc_err(vpu->ctx, \"unknown msg id %x\", msg->msg_id);\n\t\tbreak;\n\t}\n\nerror:\n\tvpu->signaled = 1;\n}\n\nstatic int vpu_enc_send_msg(struct venc_vpu_inst *vpu, void *msg,\n\t\t\t    int len)\n{\n\tint status;\n\n\tif (!vpu->ctx->dev->fw_handler) {\n\t\tmtk_venc_err(vpu->ctx, \"inst dev is NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = mtk_vcodec_fw_ipi_send(vpu->ctx->dev->fw_handler, vpu->id, msg,\n\t\t\t\t\tlen, 2000);\n\tif (status) {\n\t\tmtk_venc_err(vpu->ctx, \"vpu_ipi_send msg_id %x len %d fail %d\",\n\t\t\t     *(uint32_t *)msg, len, status);\n\t\treturn -EINVAL;\n\t}\n\tif (vpu->failure)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint vpu_enc_init(struct venc_vpu_inst *vpu)\n{\n\tint status;\n\tstruct venc_ap_ipi_msg_init out;\n\n\tinit_waitqueue_head(&vpu->wq_hd);\n\tvpu->signaled = 0;\n\tvpu->failure = 0;\n\tvpu->ctx->vpu_inst = vpu;\n\n\tstatus = mtk_vcodec_fw_ipi_register(vpu->ctx->dev->fw_handler, vpu->id,\n\t\t\t\t\t    vpu_enc_ipi_handler, \"venc\",\n\t\t\t\t\t    vpu->ctx->dev);\n\n\tif (status) {\n\t\tmtk_venc_err(vpu->ctx, \"vpu_ipi_register fail %d\", status);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&out, 0, sizeof(out));\n\tout.msg_id = AP_IPIMSG_ENC_INIT;\n\tout.venc_inst = (unsigned long)vpu;\n\tif (vpu_enc_send_msg(vpu, &out, sizeof(out))) {\n\t\tmtk_venc_err(vpu->ctx, \"AP_IPIMSG_ENC_INIT fail\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR_OR_NULL(vpu->vsi)) {\n\t\tmtk_venc_err(vpu->ctx, \"invalid venc vsi\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int venc_enc_param_crop_right(struct venc_vpu_inst *vpu,\n\t\t\t\t\t      struct venc_enc_param *enc_prm)\n{\n\tunsigned int img_crop_right = enc_prm->buf_width - enc_prm->width;\n\n\treturn img_crop_right % 16;\n}\n\nstatic unsigned int venc_enc_param_crop_bottom(struct venc_enc_param *enc_prm)\n{\n\treturn round_up(enc_prm->height, 16) - enc_prm->height;\n}\n\nstatic unsigned int venc_enc_param_num_mb(struct venc_enc_param *enc_prm)\n{\n\treturn DIV_ROUND_UP(enc_prm->width, 16) *\n\t       DIV_ROUND_UP(enc_prm->height, 16);\n}\n\nint vpu_enc_set_param(struct venc_vpu_inst *vpu,\n\t\t      enum venc_set_param_type id,\n\t\t      struct venc_enc_param *enc_param)\n{\n\tconst bool is_ext = MTK_ENC_CTX_IS_EXT(vpu->ctx);\n\tsize_t msg_size = is_ext ?\n\t\tsizeof(struct venc_ap_ipi_msg_set_param_ext) :\n\t\tsizeof(struct venc_ap_ipi_msg_set_param);\n\tstruct venc_ap_ipi_msg_set_param_ext out;\n\n\tmtk_venc_debug(vpu->ctx, \"id %d ->\", id);\n\n\tmemset(&out, 0, sizeof(out));\n\tout.base.msg_id = AP_IPIMSG_ENC_SET_PARAM;\n\tout.base.vpu_inst_addr = vpu->inst_addr;\n\tout.base.param_id = id;\n\tswitch (id) {\n\tcase VENC_SET_PARAM_ENC:\n\t\tif (is_ext) {\n\t\t\tout.base.data_item = 3;\n\t\t\tout.base.data[0] =\n\t\t\t\tvenc_enc_param_crop_right(vpu, enc_param);\n\t\t\tout.base.data[1] =\n\t\t\t\tvenc_enc_param_crop_bottom(enc_param);\n\t\t\tout.base.data[2] = venc_enc_param_num_mb(enc_param);\n\t\t} else {\n\t\t\tout.base.data_item = 0;\n\t\t}\n\t\tbreak;\n\tcase VENC_SET_PARAM_FORCE_INTRA:\n\t\tout.base.data_item = 0;\n\t\tbreak;\n\tcase VENC_SET_PARAM_ADJUST_BITRATE:\n\t\tout.base.data_item = 1;\n\t\tout.base.data[0] = enc_param->bitrate;\n\t\tbreak;\n\tcase VENC_SET_PARAM_ADJUST_FRAMERATE:\n\t\tout.base.data_item = 1;\n\t\tout.base.data[0] = enc_param->frm_rate;\n\t\tbreak;\n\tcase VENC_SET_PARAM_GOP_SIZE:\n\t\tout.base.data_item = 1;\n\t\tout.base.data[0] = enc_param->gop_size;\n\t\tbreak;\n\tcase VENC_SET_PARAM_INTRA_PERIOD:\n\t\tout.base.data_item = 1;\n\t\tout.base.data[0] = enc_param->intra_period;\n\t\tbreak;\n\tcase VENC_SET_PARAM_SKIP_FRAME:\n\t\tout.base.data_item = 0;\n\t\tbreak;\n\tdefault:\n\t\tmtk_venc_err(vpu->ctx, \"id %d not supported\", id);\n\t\treturn -EINVAL;\n\t}\n\tif (vpu_enc_send_msg(vpu, &out, msg_size)) {\n\t\tmtk_venc_err(vpu->ctx, \"AP_IPIMSG_ENC_SET_PARAM %d fail\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_venc_debug(vpu->ctx, \"id %d <-\", id);\n\n\treturn 0;\n}\n\nstatic int vpu_enc_encode_32bits(struct venc_vpu_inst *vpu,\n\t\t\t\t unsigned int bs_mode,\n\t\t\t\t struct venc_frm_buf *frm_buf,\n\t\t\t\t struct mtk_vcodec_mem *bs_buf,\n\t\t\t\t struct venc_frame_info *frame_info)\n{\n\tconst bool is_ext = MTK_ENC_CTX_IS_EXT(vpu->ctx);\n\tsize_t msg_size = is_ext ?\n\t\tsizeof(struct venc_ap_ipi_msg_enc_ext) :\n\t\tsizeof(struct venc_ap_ipi_msg_enc);\n\tstruct venc_ap_ipi_msg_enc_ext out;\n\n\tmtk_venc_debug(vpu->ctx, \"bs_mode %d ->\", bs_mode);\n\n\tmemset(&out, 0, sizeof(out));\n\tout.base.msg_id = AP_IPIMSG_ENC_ENCODE;\n\tout.base.vpu_inst_addr = vpu->inst_addr;\n\tout.base.bs_mode = bs_mode;\n\tif (frm_buf) {\n\t\tif ((frm_buf->fb_addr[0].dma_addr % 16 == 0) &&\n\t\t    (frm_buf->fb_addr[1].dma_addr % 16 == 0) &&\n\t\t    (frm_buf->fb_addr[2].dma_addr % 16 == 0)) {\n\t\t\tout.base.input_addr[0] = frm_buf->fb_addr[0].dma_addr;\n\t\t\tout.base.input_addr[1] = frm_buf->fb_addr[1].dma_addr;\n\t\t\tout.base.input_addr[2] = frm_buf->fb_addr[2].dma_addr;\n\t\t} else {\n\t\t\tmtk_venc_err(vpu->ctx, \"dma_addr not align to 16\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (bs_buf) {\n\t\tout.base.bs_addr = bs_buf->dma_addr;\n\t\tout.base.bs_size = bs_buf->size;\n\t}\n\tif (is_ext && frame_info) {\n\t\tout.data_item = 3;\n\t\tout.data[0] = frame_info->frm_count;\n\t\tout.data[1] = frame_info->skip_frm_count;\n\t\tout.data[2] = frame_info->frm_type;\n\t}\n\tif (vpu_enc_send_msg(vpu, &out, msg_size)) {\n\t\tmtk_venc_err(vpu->ctx, \"AP_IPIMSG_ENC_ENCODE %d fail\", bs_mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vpu_enc_encode_34bits(struct venc_vpu_inst *vpu,\n\t\t\t\t unsigned int bs_mode,\n\t\t\t\t struct venc_frm_buf *frm_buf,\n\t\t\t\t struct mtk_vcodec_mem *bs_buf,\n\t\t\t\t struct venc_frame_info *frame_info)\n{\n\tstruct venc_ap_ipi_msg_enc_ext_34 out;\n\tsize_t msg_size = sizeof(struct venc_ap_ipi_msg_enc_ext_34);\n\n\tmtk_venc_debug(vpu->ctx, \"bs_mode %d ->\", bs_mode);\n\n\tmemset(&out, 0, sizeof(out));\n\tout.msg_id = AP_IPIMSG_ENC_ENCODE;\n\tout.vpu_inst_addr = vpu->inst_addr;\n\tout.bs_mode = bs_mode;\n\n\tif (frm_buf) {\n\t\tif ((frm_buf->fb_addr[0].dma_addr % 16 == 0) &&\n\t\t    (frm_buf->fb_addr[1].dma_addr % 16 == 0) &&\n\t\t    (frm_buf->fb_addr[2].dma_addr % 16 == 0)) {\n\t\t\tout.input_addr[0] = frm_buf->fb_addr[0].dma_addr;\n\t\t\tout.input_addr[1] = frm_buf->fb_addr[1].dma_addr;\n\t\t\tout.input_addr[2] = frm_buf->fb_addr[2].dma_addr;\n\t\t} else {\n\t\t\tmtk_venc_err(vpu->ctx, \"dma_addr not align to 16\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (bs_buf) {\n\t\tout.bs_addr = bs_buf->dma_addr;\n\t\tout.bs_size = bs_buf->size;\n\t}\n\tif (frame_info) {\n\t\tout.data_item = 3;\n\t\tout.data[0] = frame_info->frm_count;\n\t\tout.data[1] = frame_info->skip_frm_count;\n\t\tout.data[2] = frame_info->frm_type;\n\t}\n\tif (vpu_enc_send_msg(vpu, &out, msg_size)) {\n\t\tmtk_venc_err(vpu->ctx, \"AP_IPIMSG_ENC_ENCODE %d fail\", bs_mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint vpu_enc_encode(struct venc_vpu_inst *vpu, unsigned int bs_mode,\n\t\t   struct venc_frm_buf *frm_buf,\n\t\t   struct mtk_vcodec_mem *bs_buf,\n\t\t   struct venc_frame_info *frame_info)\n{\n\tint ret;\n\n\tif (MTK_ENC_IOVA_IS_34BIT(vpu->ctx))\n\t\tret = vpu_enc_encode_34bits(vpu, bs_mode,\n\t\t\t\t\t    frm_buf, bs_buf, frame_info);\n\telse\n\t\tret = vpu_enc_encode_32bits(vpu, bs_mode,\n\t\t\t\t\t    frm_buf, bs_buf, frame_info);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmtk_venc_debug(vpu->ctx, \"bs_mode %d state %d size %d key_frm %d <-\",\n\t\t       bs_mode, vpu->state, vpu->bs_size, vpu->is_key_frm);\n\n\treturn 0;\n}\n\nint vpu_enc_deinit(struct venc_vpu_inst *vpu)\n{\n\tstruct venc_ap_ipi_msg_deinit out;\n\n\tmemset(&out, 0, sizeof(out));\n\tout.msg_id = AP_IPIMSG_ENC_DEINIT;\n\tout.vpu_inst_addr = vpu->inst_addr;\n\tif (vpu_enc_send_msg(vpu, &out, sizeof(out))) {\n\t\tmtk_venc_err(vpu->ctx, \"AP_IPIMSG_ENC_DEINIT fail\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}