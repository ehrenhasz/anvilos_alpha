{
  "module_name": "mtk_vcodec_enc_drv.c",
  "hash_id": "264480fd85fdf93a51c3c29f32885459d79d56138e27768f9de98555d0b6b32d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/encoder/mtk_vcodec_enc_drv.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"mtk_vcodec_enc.h\"\n#include \"mtk_vcodec_enc_pm.h\"\n#include \"../common/mtk_vcodec_intr.h\"\n\nstatic const struct mtk_video_fmt mtk_video_formats_output[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV12M,\n\t\t.type = MTK_FMT_FRAME,\n\t\t.num_planes = 2,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV21M,\n\t\t.type = MTK_FMT_FRAME,\n\t\t.num_planes = 2,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_YUV420M,\n\t\t.type = MTK_FMT_FRAME,\n\t\t.num_planes = 3,\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_YVU420M,\n\t\t.type = MTK_FMT_FRAME,\n\t\t.num_planes = 3,\n\t},\n};\n\nstatic const struct mtk_video_fmt mtk_video_formats_capture_h264[] =  {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_H264,\n\t\t.type = MTK_FMT_ENC,\n\t\t.num_planes = 1,\n\t},\n};\n\nstatic const struct mtk_video_fmt mtk_video_formats_capture_vp8[] =  {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_VP8,\n\t\t.type = MTK_FMT_ENC,\n\t\t.num_planes = 1,\n\t},\n};\n\nstatic void clean_irq_status(unsigned int irq_status, void __iomem *addr)\n{\n\tif (irq_status & MTK_VENC_IRQ_STATUS_PAUSE)\n\t\twritel(MTK_VENC_IRQ_STATUS_PAUSE, addr);\n\n\tif (irq_status & MTK_VENC_IRQ_STATUS_SWITCH)\n\t\twritel(MTK_VENC_IRQ_STATUS_SWITCH, addr);\n\n\tif (irq_status & MTK_VENC_IRQ_STATUS_DRAM)\n\t\twritel(MTK_VENC_IRQ_STATUS_DRAM, addr);\n\n\tif (irq_status & MTK_VENC_IRQ_STATUS_SPS)\n\t\twritel(MTK_VENC_IRQ_STATUS_SPS, addr);\n\n\tif (irq_status & MTK_VENC_IRQ_STATUS_PPS)\n\t\twritel(MTK_VENC_IRQ_STATUS_PPS, addr);\n\n\tif (irq_status & MTK_VENC_IRQ_STATUS_FRM)\n\t\twritel(MTK_VENC_IRQ_STATUS_FRM, addr);\n\n}\nstatic irqreturn_t mtk_vcodec_enc_irq_handler(int irq, void *priv)\n{\n\tstruct mtk_vcodec_enc_dev *dev = priv;\n\tstruct mtk_vcodec_enc_ctx *ctx;\n\tunsigned long flags;\n\tvoid __iomem *addr;\n\tint core_id;\n\n\tspin_lock_irqsave(&dev->irqlock, flags);\n\tctx = dev->curr_ctx;\n\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\n\tcore_id = dev->venc_pdata->core_id;\n\tif (core_id < 0 || core_id >= NUM_MAX_VCODEC_REG_BASE) {\n\t\tmtk_v4l2_venc_err(ctx, \"Invalid core id: %d, ctx id: %d\", core_id, ctx->id);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tmtk_v4l2_venc_dbg(1, ctx, \"id: %d, core id: %d\", ctx->id, core_id);\n\n\taddr = dev->reg_base[core_id] + MTK_VENC_IRQ_ACK_OFFSET;\n\n\tctx->irq_status = readl(dev->reg_base[core_id] +\n\t\t\t\t(MTK_VENC_IRQ_STATUS_OFFSET));\n\n\tclean_irq_status(ctx->irq_status, addr);\n\n\twake_up_enc_ctx(ctx, MTK_INST_IRQ_RECEIVED, 0);\n\treturn IRQ_HANDLED;\n}\n\nstatic int fops_vcodec_open(struct file *file)\n{\n\tstruct mtk_vcodec_enc_dev *dev = video_drvdata(file);\n\tstruct mtk_vcodec_enc_ctx *ctx = NULL;\n\tint ret = 0;\n\tstruct vb2_queue *src_vq;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&dev->dev_mutex);\n\t \n\tctx->id = dev->id_counter++;\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\tINIT_LIST_HEAD(&ctx->list);\n\tctx->dev = dev;\n\tinit_waitqueue_head(&ctx->queue[0]);\n\tmutex_init(&ctx->q_mutex);\n\n\tctx->type = MTK_INST_ENCODER;\n\tret = mtk_vcodec_enc_ctrls_setup(ctx);\n\tif (ret) {\n\t\tmtk_v4l2_venc_err(ctx, \"Failed to setup controls() (%d)\", ret);\n\t\tgoto err_ctrls_setup;\n\t}\n\tctx->m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev_enc, ctx,\n\t\t\t\t\t &mtk_vcodec_enc_queue_init);\n\tif (IS_ERR((__force void *)ctx->m2m_ctx)) {\n\t\tret = PTR_ERR((__force void *)ctx->m2m_ctx);\n\t\tmtk_v4l2_venc_err(ctx, \"Failed to v4l2_m2m_ctx_init() (%d)\", ret);\n\t\tgoto err_m2m_ctx_init;\n\t}\n\tsrc_vq = v4l2_m2m_get_vq(ctx->m2m_ctx,\n\t\t\t\t V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\tctx->empty_flush_buf.vb.vb2_buf.vb2_queue = src_vq;\n\tmtk_vcodec_enc_set_default_params(ctx);\n\n\tif (v4l2_fh_is_singular(&ctx->fh)) {\n\t\t \n\t\tret = mtk_vcodec_fw_load_firmware(dev->fw_handler);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tmtk_v4l2_venc_err(ctx, \"vpu_load_firmware failed!\");\n\t\t\tgoto err_load_fw;\n\t\t}\n\n\t\tdev->enc_capability =\n\t\t\tmtk_vcodec_fw_get_venc_capa(dev->fw_handler);\n\t\tmtk_v4l2_venc_dbg(0, ctx, \"encoder capability %x\", dev->enc_capability);\n\t}\n\n\tmtk_v4l2_venc_dbg(2, ctx, \"Create instance [%d]@%p m2m_ctx=%p \",\n\t\t\t  ctx->id, ctx, ctx->m2m_ctx);\n\n\tlist_add(&ctx->list, &dev->ctx_list);\n\n\tmutex_unlock(&dev->dev_mutex);\n\tmtk_v4l2_venc_dbg(0, ctx, \"%s encoder [%d]\", dev_name(&dev->plat_dev->dev),\n\t\t\t  ctx->id);\n\treturn ret;\n\n\t \nerr_load_fw:\n\tv4l2_m2m_ctx_release(ctx->m2m_ctx);\nerr_m2m_ctx_init:\n\tv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\nerr_ctrls_setup:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\tmutex_unlock(&dev->dev_mutex);\n\n\treturn ret;\n}\n\nstatic int fops_vcodec_release(struct file *file)\n{\n\tstruct mtk_vcodec_enc_dev *dev = video_drvdata(file);\n\tstruct mtk_vcodec_enc_ctx *ctx = fh_to_enc_ctx(file->private_data);\n\n\tmtk_v4l2_venc_dbg(1, ctx, \"[%d] encoder\", ctx->id);\n\tmutex_lock(&dev->dev_mutex);\n\n\tv4l2_m2m_ctx_release(ctx->m2m_ctx);\n\tmtk_vcodec_enc_release(ctx);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\n\n\tlist_del_init(&ctx->list);\n\tkfree(ctx);\n\tmutex_unlock(&dev->dev_mutex);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations mtk_vcodec_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= fops_vcodec_open,\n\t.release\t= fops_vcodec_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic int mtk_vcodec_probe(struct platform_device *pdev)\n{\n\tstruct mtk_vcodec_enc_dev *dev;\n\tstruct video_device *vfd_enc;\n\tphandle rproc_phandle;\n\tenum mtk_vcodec_fw_type fw_type;\n\tint ret;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&dev->ctx_list);\n\tdev->plat_dev = pdev;\n\n\tif (!of_property_read_u32(pdev->dev.of_node, \"mediatek,vpu\",\n\t\t\t\t  &rproc_phandle)) {\n\t\tfw_type = VPU;\n\t} else if (!of_property_read_u32(pdev->dev.of_node, \"mediatek,scp\",\n\t\t\t\t\t &rproc_phandle)) {\n\t\tfw_type = SCP;\n\t} else {\n\t\tdev_err(&pdev->dev, \"[MTK VCODEC] Could not get venc IPI device\");\n\t\treturn -ENODEV;\n\t}\n\tdma_set_max_seg_size(&pdev->dev, UINT_MAX);\n\n\tdev->fw_handler = mtk_vcodec_fw_select(dev, fw_type, ENCODER);\n\tif (IS_ERR(dev->fw_handler))\n\t\treturn PTR_ERR(dev->fw_handler);\n\n\tdev->venc_pdata = of_device_get_match_data(&pdev->dev);\n\tret = mtk_vcodec_init_enc_clk(dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"[MTK VCODEC] Failed to get mtk vcodec clock source!\");\n\t\tgoto err_enc_pm;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tdev->reg_base[dev->venc_pdata->core_id] =\n\t\tdevm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->reg_base[dev->venc_pdata->core_id])) {\n\t\tret = PTR_ERR(dev->reg_base[dev->venc_pdata->core_id]);\n\t\tgoto err_res;\n\t}\n\n\tdev->enc_irq = platform_get_irq(pdev, 0);\n\tif (dev->enc_irq < 0) {\n\t\tret = dev->enc_irq;\n\t\tgoto err_res;\n\t}\n\n\tirq_set_status_flags(dev->enc_irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(&pdev->dev, dev->enc_irq,\n\t\t\t       mtk_vcodec_enc_irq_handler,\n\t\t\t       0, pdev->name, dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"[MTK VCODEC] Failed to install dev->enc_irq %d (%d) core_id (%d)\",\n\t\t\tdev->enc_irq, ret, dev->venc_pdata->core_id);\n\t\tret = -EINVAL;\n\t\tgoto err_res;\n\t}\n\n\tmutex_init(&dev->enc_mutex);\n\tmutex_init(&dev->dev_mutex);\n\tspin_lock_init(&dev->irqlock);\n\n\tsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name), \"%s\",\n\t\t \"[MTK_V4L2_VENC]\");\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"[MTK VCODEC] v4l2_device_register err=%d\", ret);\n\t\tgoto err_res;\n\t}\n\n\t \n\tvfd_enc = video_device_alloc();\n\tif (!vfd_enc) {\n\t\tdev_err(&pdev->dev, \"[MTK VCODEC] Failed to allocate video device\");\n\t\tret = -ENOMEM;\n\t\tgoto err_enc_alloc;\n\t}\n\tvfd_enc->fops           = &mtk_vcodec_fops;\n\tvfd_enc->ioctl_ops      = &mtk_venc_ioctl_ops;\n\tvfd_enc->release        = video_device_release;\n\tvfd_enc->lock           = &dev->dev_mutex;\n\tvfd_enc->v4l2_dev       = &dev->v4l2_dev;\n\tvfd_enc->vfl_dir        = VFL_DIR_M2M;\n\tvfd_enc->device_caps\t= V4L2_CAP_VIDEO_M2M_MPLANE |\n\t\t\t\t\tV4L2_CAP_STREAMING;\n\n\tsnprintf(vfd_enc->name, sizeof(vfd_enc->name), \"%s\",\n\t\t MTK_VCODEC_ENC_NAME);\n\tvideo_set_drvdata(vfd_enc, dev);\n\tdev->vfd_enc = vfd_enc;\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev->m2m_dev_enc = v4l2_m2m_init(&mtk_venc_m2m_ops);\n\tif (IS_ERR((__force void *)dev->m2m_dev_enc)) {\n\t\tdev_err(&pdev->dev, \"[MTK VCODEC] Failed to init mem2mem enc device\");\n\t\tret = PTR_ERR((__force void *)dev->m2m_dev_enc);\n\t\tgoto err_enc_mem_init;\n\t}\n\n\tdev->encode_workqueue =\n\t\t\talloc_ordered_workqueue(MTK_VCODEC_ENC_NAME,\n\t\t\t\t\t\tWQ_MEM_RECLAIM |\n\t\t\t\t\t\tWQ_FREEZABLE);\n\tif (!dev->encode_workqueue) {\n\t\tdev_err(&pdev->dev, \"[MTK VCODEC] Failed to create encode workqueue\");\n\t\tret = -EINVAL;\n\t\tgoto err_event_workq;\n\t}\n\n\tret = video_register_device(vfd_enc, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"[MTK VCODEC] Failed to register video device\");\n\t\tgoto err_enc_reg;\n\t}\n\n\tmtk_vcodec_dbgfs_init(dev, true);\n\tdev_dbg(&pdev->dev,  \"[MTK VCODEC] encoder %d registered as /dev/video%d\",\n\t\tdev->venc_pdata->core_id, vfd_enc->num);\n\n\treturn 0;\n\nerr_enc_reg:\n\tdestroy_workqueue(dev->encode_workqueue);\nerr_event_workq:\n\tv4l2_m2m_release(dev->m2m_dev_enc);\nerr_enc_mem_init:\n\tvideo_unregister_device(vfd_enc);\nerr_enc_alloc:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nerr_res:\n\tpm_runtime_disable(dev->pm.dev);\nerr_enc_pm:\n\tmtk_vcodec_fw_release(dev->fw_handler);\n\treturn ret;\n}\n\nstatic const struct mtk_vcodec_enc_pdata mt8173_avc_pdata = {\n\t.capture_formats = mtk_video_formats_capture_h264,\n\t.num_capture_formats = ARRAY_SIZE(mtk_video_formats_capture_h264),\n\t.output_formats = mtk_video_formats_output,\n\t.num_output_formats = ARRAY_SIZE(mtk_video_formats_output),\n\t.min_bitrate = 64,\n\t.max_bitrate = 60000000,\n\t.core_id = VENC_SYS,\n};\n\nstatic const struct mtk_vcodec_enc_pdata mt8173_vp8_pdata = {\n\t.capture_formats = mtk_video_formats_capture_vp8,\n\t.num_capture_formats = ARRAY_SIZE(mtk_video_formats_capture_vp8),\n\t.output_formats = mtk_video_formats_output,\n\t.num_output_formats = ARRAY_SIZE(mtk_video_formats_output),\n\t.min_bitrate = 64,\n\t.max_bitrate = 9000000,\n\t.core_id = VENC_LT_SYS,\n};\n\nstatic const struct mtk_vcodec_enc_pdata mt8183_pdata = {\n\t.uses_ext = true,\n\t.capture_formats = mtk_video_formats_capture_h264,\n\t.num_capture_formats = ARRAY_SIZE(mtk_video_formats_capture_h264),\n\t.output_formats = mtk_video_formats_output,\n\t.num_output_formats = ARRAY_SIZE(mtk_video_formats_output),\n\t.min_bitrate = 64,\n\t.max_bitrate = 40000000,\n\t.core_id = VENC_SYS,\n};\n\nstatic const struct mtk_vcodec_enc_pdata mt8188_pdata = {\n\t.uses_ext = true,\n\t.capture_formats = mtk_video_formats_capture_h264,\n\t.num_capture_formats = ARRAY_SIZE(mtk_video_formats_capture_h264),\n\t.output_formats = mtk_video_formats_output,\n\t.num_output_formats = ARRAY_SIZE(mtk_video_formats_output),\n\t.min_bitrate = 64,\n\t.max_bitrate = 50000000,\n\t.core_id = VENC_SYS,\n\t.uses_34bit = true,\n};\n\nstatic const struct mtk_vcodec_enc_pdata mt8192_pdata = {\n\t.uses_ext = true,\n\t.capture_formats = mtk_video_formats_capture_h264,\n\t.num_capture_formats = ARRAY_SIZE(mtk_video_formats_capture_h264),\n\t.output_formats = mtk_video_formats_output,\n\t.num_output_formats = ARRAY_SIZE(mtk_video_formats_output),\n\t.min_bitrate = 64,\n\t.max_bitrate = 100000000,\n\t.core_id = VENC_SYS,\n};\n\nstatic const struct mtk_vcodec_enc_pdata mt8195_pdata = {\n\t.uses_ext = true,\n\t.capture_formats = mtk_video_formats_capture_h264,\n\t.num_capture_formats = ARRAY_SIZE(mtk_video_formats_capture_h264),\n\t.output_formats = mtk_video_formats_output,\n\t.num_output_formats = ARRAY_SIZE(mtk_video_formats_output),\n\t.min_bitrate = 64,\n\t.max_bitrate = 100000000,\n\t.core_id = VENC_SYS,\n};\n\nstatic const struct of_device_id mtk_vcodec_enc_match[] = {\n\t{.compatible = \"mediatek,mt8173-vcodec-enc\",\n\t\t\t.data = &mt8173_avc_pdata},\n\t{.compatible = \"mediatek,mt8173-vcodec-enc-vp8\",\n\t\t\t.data = &mt8173_vp8_pdata},\n\t{.compatible = \"mediatek,mt8183-vcodec-enc\", .data = &mt8183_pdata},\n\t{.compatible = \"mediatek,mt8188-vcodec-enc\", .data = &mt8188_pdata},\n\t{.compatible = \"mediatek,mt8192-vcodec-enc\", .data = &mt8192_pdata},\n\t{.compatible = \"mediatek,mt8195-vcodec-enc\", .data = &mt8195_pdata},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_vcodec_enc_match);\n\nstatic void mtk_vcodec_enc_remove(struct platform_device *pdev)\n{\n\tstruct mtk_vcodec_enc_dev *dev = platform_get_drvdata(pdev);\n\n\tdestroy_workqueue(dev->encode_workqueue);\n\tif (dev->m2m_dev_enc)\n\t\tv4l2_m2m_release(dev->m2m_dev_enc);\n\n\tif (dev->vfd_enc)\n\t\tvideo_unregister_device(dev->vfd_enc);\n\n\tmtk_vcodec_dbgfs_deinit(&dev->dbgfs);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tpm_runtime_disable(dev->pm.dev);\n\tmtk_vcodec_fw_release(dev->fw_handler);\n}\n\nstatic struct platform_driver mtk_vcodec_enc_driver = {\n\t.probe\t= mtk_vcodec_probe,\n\t.remove_new = mtk_vcodec_enc_remove,\n\t.driver\t= {\n\t\t.name\t= MTK_VCODEC_ENC_NAME,\n\t\t.of_match_table = mtk_vcodec_enc_match,\n\t},\n};\n\nmodule_platform_driver(mtk_vcodec_enc_driver);\n\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Mediatek video codec V4L2 encoder driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}