{
  "module_name": "venc_vp8_if.c",
  "hash_id": "1e06d74d1bf43cab15d2b77219fd02e071192cd5948627565cacebb4ce265122",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/encoder/venc/venc_vp8_if.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#include \"../mtk_vcodec_enc_drv.h\"\n#include \"../../common/mtk_vcodec_intr.h\"\n#include \"../mtk_vcodec_enc.h\"\n#include \"../mtk_vcodec_enc_pm.h\"\n#include \"../venc_drv_base.h\"\n#include \"../venc_ipi_msg.h\"\n#include \"../venc_vpu_if.h\"\n\n#define VENC_BITSTREAM_FRAME_SIZE 0x0098\n#define VENC_BITSTREAM_HEADER_LEN 0x00e8\n\n \n#define MAX_AC_TAG_SIZE 10\n\n \nenum venc_vp8_vpu_work_buf {\n\tVENC_VP8_VPU_WORK_BUF_LUMA,\n\tVENC_VP8_VPU_WORK_BUF_LUMA2,\n\tVENC_VP8_VPU_WORK_BUF_LUMA3,\n\tVENC_VP8_VPU_WORK_BUF_CHROMA,\n\tVENC_VP8_VPU_WORK_BUF_CHROMA2,\n\tVENC_VP8_VPU_WORK_BUF_CHROMA3,\n\tVENC_VP8_VPU_WORK_BUF_MV_INFO,\n\tVENC_VP8_VPU_WORK_BUF_BS_HEADER,\n\tVENC_VP8_VPU_WORK_BUF_PROB_BUF,\n\tVENC_VP8_VPU_WORK_BUF_RC_INFO,\n\tVENC_VP8_VPU_WORK_BUF_RC_CODE,\n\tVENC_VP8_VPU_WORK_BUF_RC_CODE2,\n\tVENC_VP8_VPU_WORK_BUF_RC_CODE3,\n\tVENC_VP8_VPU_WORK_BUF_MAX,\n};\n\n \nstruct venc_vp8_vpu_config {\n\tu32 input_fourcc;\n\tu32 bitrate;\n\tu32 pic_w;\n\tu32 pic_h;\n\tu32 buf_w;\n\tu32 buf_h;\n\tu32 gop_size;\n\tu32 framerate;\n\tu32 ts_mode;\n};\n\n \nstruct venc_vp8_vpu_buf {\n\tu32 iova;\n\tu32 vpua;\n\tu32 size;\n};\n\n \nstruct venc_vp8_vsi {\n\tstruct venc_vp8_vpu_config config;\n\tstruct venc_vp8_vpu_buf work_bufs[VENC_VP8_VPU_WORK_BUF_MAX];\n};\n\n \nstruct venc_vp8_inst {\n\tvoid __iomem *hw_base;\n\tstruct mtk_vcodec_mem work_bufs[VENC_VP8_VPU_WORK_BUF_MAX];\n\tbool work_buf_allocated;\n\tunsigned int frm_cnt;\n\tunsigned int ts_mode;\n\tstruct venc_vpu_inst vpu_inst;\n\tstruct venc_vp8_vsi *vsi;\n\tstruct mtk_vcodec_enc_ctx *ctx;\n};\n\nstatic inline u32 vp8_enc_read_reg(struct venc_vp8_inst *inst, u32 addr)\n{\n\treturn readl(inst->hw_base + addr);\n}\n\nstatic void vp8_enc_free_work_buf(struct venc_vp8_inst *inst)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < VENC_VP8_VPU_WORK_BUF_MAX; i++) {\n\t\tif (inst->work_bufs[i].size == 0)\n\t\t\tcontinue;\n\t\tmtk_vcodec_mem_free(inst->ctx, &inst->work_bufs[i]);\n\t}\n}\n\nstatic int vp8_enc_alloc_work_buf(struct venc_vp8_inst *inst)\n{\n\tint i;\n\tint ret = 0;\n\tstruct venc_vp8_vpu_buf *wb = inst->vsi->work_bufs;\n\n\tfor (i = 0; i < VENC_VP8_VPU_WORK_BUF_MAX; i++) {\n\t\tif (wb[i].size == 0)\n\t\t\tcontinue;\n\t\t \n\t\tinst->work_bufs[i].size = wb[i].size;\n\t\tret = mtk_vcodec_mem_alloc(inst->ctx, &inst->work_bufs[i]);\n\t\tif (ret) {\n\t\t\tmtk_venc_err(inst->ctx, \"cannot alloc work_bufs[%d]\", i);\n\t\t\tgoto err_alloc;\n\t\t}\n\t\t \n\t\tif (i == VENC_VP8_VPU_WORK_BUF_RC_CODE ||\n\t\t    i == VENC_VP8_VPU_WORK_BUF_RC_CODE2 ||\n\t\t    i == VENC_VP8_VPU_WORK_BUF_RC_CODE3) {\n\t\t\tstruct mtk_vcodec_fw *handler;\n\t\t\tvoid *tmp_va;\n\n\t\t\thandler = inst->vpu_inst.ctx->dev->fw_handler;\n\t\t\ttmp_va = mtk_vcodec_fw_map_dm_addr(handler,\n\t\t\t\t\t\t\t   wb[i].vpua);\n\t\t\tmemcpy(inst->work_bufs[i].va, tmp_va, wb[i].size);\n\t\t}\n\t\twb[i].iova = inst->work_bufs[i].dma_addr;\n\n\t\tmtk_venc_debug(inst->ctx, \"work_bufs[%d] va=0x%p,iova=%pad,size=%zu\",\n\t\t\t       i, inst->work_bufs[i].va,\n\t\t\t       &inst->work_bufs[i].dma_addr,\n\t\t\t       inst->work_bufs[i].size);\n\t}\n\n\treturn ret;\n\nerr_alloc:\n\tvp8_enc_free_work_buf(inst);\n\n\treturn ret;\n}\n\nstatic unsigned int vp8_enc_wait_venc_done(struct venc_vp8_inst *inst)\n{\n\tunsigned int irq_status = 0;\n\tstruct mtk_vcodec_enc_ctx *ctx = (struct mtk_vcodec_enc_ctx *)inst->ctx;\n\n\tif (!mtk_vcodec_wait_for_done_ctx(ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t  WAIT_INTR_TIMEOUT_MS, 0)) {\n\t\tirq_status = ctx->irq_status;\n\t\tmtk_venc_debug(ctx, \"isr return %x\", irq_status);\n\t}\n\treturn irq_status;\n}\n\n \nstatic int vp8_enc_compose_one_frame(struct venc_vp8_inst *inst,\n\t\t\t\t     struct mtk_vcodec_mem *bs_buf,\n\t\t\t\t     unsigned int *bs_size)\n{\n\tunsigned int not_key;\n\tu32 bs_frm_size;\n\tu32 bs_hdr_len;\n\tunsigned int ac_tag_size;\n\tu8 ac_tag[MAX_AC_TAG_SIZE];\n\tu32 tag;\n\n\tbs_frm_size = vp8_enc_read_reg(inst, VENC_BITSTREAM_FRAME_SIZE);\n\tbs_hdr_len = vp8_enc_read_reg(inst, VENC_BITSTREAM_HEADER_LEN);\n\n\t \n\tnot_key = !inst->vpu_inst.is_key_frm;\n\ttag = (bs_hdr_len << 5) | 0x10 | not_key;\n\tac_tag[0] = tag & 0xff;\n\tac_tag[1] = (tag >> 8) & 0xff;\n\tac_tag[2] = (tag >> 16) & 0xff;\n\n\t \n\tif (not_key == 0) {\n\t\tac_tag_size = MAX_AC_TAG_SIZE;\n\t\tac_tag[3] = 0x9d;\n\t\tac_tag[4] = 0x01;\n\t\tac_tag[5] = 0x2a;\n\t\tac_tag[6] = inst->vsi->config.pic_w;\n\t\tac_tag[7] = inst->vsi->config.pic_w >> 8;\n\t\tac_tag[8] = inst->vsi->config.pic_h;\n\t\tac_tag[9] = inst->vsi->config.pic_h >> 8;\n\t} else {\n\t\tac_tag_size = 3;\n\t}\n\n\tif (bs_buf->size < bs_hdr_len + bs_frm_size + ac_tag_size) {\n\t\tmtk_venc_err(inst->ctx, \"bitstream buf size is too small(%zu)\", bs_buf->size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemmove(bs_buf->va + bs_hdr_len + ac_tag_size,\n\t\tbs_buf->va, bs_frm_size);\n\tmemcpy(bs_buf->va + ac_tag_size,\n\t       inst->work_bufs[VENC_VP8_VPU_WORK_BUF_BS_HEADER].va,\n\t       bs_hdr_len);\n\tmemcpy(bs_buf->va, ac_tag, ac_tag_size);\n\t*bs_size = bs_frm_size + bs_hdr_len + ac_tag_size;\n\n\treturn 0;\n}\n\nstatic int vp8_enc_encode_frame(struct venc_vp8_inst *inst,\n\t\t\t\tstruct venc_frm_buf *frm_buf,\n\t\t\t\tstruct mtk_vcodec_mem *bs_buf,\n\t\t\t\tunsigned int *bs_size)\n{\n\tint ret = 0;\n\tunsigned int irq_status;\n\n\tmtk_venc_debug(inst->ctx, \"->frm_cnt=%d\", inst->frm_cnt);\n\n\tret = vpu_enc_encode(&inst->vpu_inst, 0, frm_buf, bs_buf, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tirq_status = vp8_enc_wait_venc_done(inst);\n\tif (irq_status != MTK_VENC_IRQ_STATUS_FRM) {\n\t\tmtk_venc_err(inst->ctx, \"irq_status=%d failed\", irq_status);\n\t\treturn -EIO;\n\t}\n\n\tif (vp8_enc_compose_one_frame(inst, bs_buf, bs_size)) {\n\t\tmtk_venc_err(inst->ctx, \"vp8_enc_compose_one_frame failed\");\n\t\treturn -EINVAL;\n\t}\n\n\tinst->frm_cnt++;\n\tmtk_venc_debug(inst->ctx, \"<-size=%d key_frm=%d\", *bs_size, inst->vpu_inst.is_key_frm);\n\n\treturn ret;\n}\n\nstatic int vp8_enc_init(struct mtk_vcodec_enc_ctx *ctx)\n{\n\tint ret = 0;\n\tstruct venc_vp8_inst *inst;\n\n\tinst = kzalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tinst->ctx = ctx;\n\tinst->vpu_inst.ctx = ctx;\n\tinst->vpu_inst.id = IPI_VENC_VP8;\n\tinst->hw_base = mtk_vcodec_get_reg_addr(inst->ctx->dev->reg_base, VENC_LT_SYS);\n\n\tret = vpu_enc_init(&inst->vpu_inst);\n\n\tinst->vsi = (struct venc_vp8_vsi *)inst->vpu_inst.vsi;\n\n\tif (ret)\n\t\tkfree(inst);\n\telse\n\t\tctx->drv_handle = inst;\n\n\treturn ret;\n}\n\nstatic int vp8_enc_encode(void *handle,\n\t\t\t  enum venc_start_opt opt,\n\t\t\t  struct venc_frm_buf *frm_buf,\n\t\t\t  struct mtk_vcodec_mem *bs_buf,\n\t\t\t  struct venc_done_result *result)\n{\n\tint ret = 0;\n\tstruct venc_vp8_inst *inst = (struct venc_vp8_inst *)handle;\n\tstruct mtk_vcodec_enc_ctx *ctx = inst->ctx;\n\n\tenable_irq(ctx->dev->enc_irq);\n\n\tswitch (opt) {\n\tcase VENC_START_OPT_ENCODE_FRAME:\n\t\tret = vp8_enc_encode_frame(inst, frm_buf, bs_buf,\n\t\t\t\t\t   &result->bs_size);\n\t\tif (ret)\n\t\t\tgoto encode_err;\n\t\tresult->is_key_frm = inst->vpu_inst.is_key_frm;\n\t\tbreak;\n\n\tdefault:\n\t\tmtk_venc_err(ctx, \"opt not support:%d\", opt);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nencode_err:\n\n\tdisable_irq(ctx->dev->enc_irq);\n\treturn ret;\n}\n\nstatic int vp8_enc_set_param(void *handle,\n\t\t\t     enum venc_set_param_type type,\n\t\t\t     struct venc_enc_param *enc_prm)\n{\n\tint ret = 0;\n\tstruct venc_vp8_inst *inst = (struct venc_vp8_inst *)handle;\n\n\tmtk_venc_debug(inst->ctx, \"->type=%d\", type);\n\n\tswitch (type) {\n\tcase VENC_SET_PARAM_ENC:\n\t\tinst->vsi->config.input_fourcc = enc_prm->input_yuv_fmt;\n\t\tinst->vsi->config.bitrate = enc_prm->bitrate;\n\t\tinst->vsi->config.pic_w = enc_prm->width;\n\t\tinst->vsi->config.pic_h = enc_prm->height;\n\t\tinst->vsi->config.buf_w = enc_prm->buf_width;\n\t\tinst->vsi->config.buf_h = enc_prm->buf_height;\n\t\tinst->vsi->config.gop_size = enc_prm->gop_size;\n\t\tinst->vsi->config.framerate = enc_prm->frm_rate;\n\t\tinst->vsi->config.ts_mode = inst->ts_mode;\n\t\tret = vpu_enc_set_param(&inst->vpu_inst, type, enc_prm);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (inst->work_buf_allocated) {\n\t\t\tvp8_enc_free_work_buf(inst);\n\t\t\tinst->work_buf_allocated = false;\n\t\t}\n\t\tret = vp8_enc_alloc_work_buf(inst);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tinst->work_buf_allocated = true;\n\t\tbreak;\n\n\t \n\tcase VENC_SET_PARAM_TS_MODE:\n\t\tinst->ts_mode = 1;\n\t\tmtk_venc_debug(inst->ctx, \"set ts_mode\");\n\t\tbreak;\n\n\tdefault:\n\t\tret = vpu_enc_set_param(&inst->vpu_inst, type, enc_prm);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int vp8_enc_deinit(void *handle)\n{\n\tint ret = 0;\n\tstruct venc_vp8_inst *inst = (struct venc_vp8_inst *)handle;\n\n\tret = vpu_enc_deinit(&inst->vpu_inst);\n\n\tif (inst->work_buf_allocated)\n\t\tvp8_enc_free_work_buf(inst);\n\n\tkfree(inst);\n\treturn ret;\n}\n\nconst struct venc_common_if venc_vp8_if = {\n\t.init = vp8_enc_init,\n\t.encode = vp8_enc_encode,\n\t.set_param = vp8_enc_set_param,\n\t.deinit = vp8_enc_deinit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}