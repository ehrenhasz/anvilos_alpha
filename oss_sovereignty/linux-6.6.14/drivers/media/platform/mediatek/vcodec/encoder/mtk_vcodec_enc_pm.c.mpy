{
  "module_name": "mtk_vcodec_enc_pm.c",
  "hash_id": "08634c646e07a706fbc3cd755e2cea3345901e38cd70e9dad9d2b8b6095cd4cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/encoder/mtk_vcodec_enc_pm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n\n#include \"mtk_vcodec_enc_drv.h\"\n#include \"mtk_vcodec_enc_pm.h\"\n\nint mtk_vcodec_init_enc_clk(struct mtk_vcodec_enc_dev *mtkdev)\n{\n\tstruct platform_device *pdev;\n\tstruct mtk_vcodec_pm *pm;\n\tstruct mtk_vcodec_clk *enc_clk;\n\tstruct mtk_vcodec_clk_info *clk_info;\n\tint ret, i;\n\n\tpdev = mtkdev->plat_dev;\n\tpm = &mtkdev->pm;\n\tmemset(pm, 0, sizeof(struct mtk_vcodec_pm));\n\tpm->dev = &pdev->dev;\n\tenc_clk = &pm->venc_clk;\n\n\tenc_clk->clk_num = of_property_count_strings(pdev->dev.of_node,\n\t\t\"clock-names\");\n\tif (enc_clk->clk_num > 0) {\n\t\tenc_clk->clk_info = devm_kcalloc(&pdev->dev,\n\t\t\tenc_clk->clk_num, sizeof(*clk_info),\n\t\t\tGFP_KERNEL);\n\t\tif (!enc_clk->clk_info)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tdev_err(pm->dev, \"[MTK VCODEC] Failed to get venc clock count\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < enc_clk->clk_num; i++) {\n\t\tclk_info = &enc_clk->clk_info[i];\n\t\tret = of_property_read_string_index(pdev->dev.of_node,\n\t\t\t\"clock-names\", i, &clk_info->clk_name);\n\t\tif (ret) {\n\t\t\tdev_err(pm->dev, \"[MTK VCODEC] venc failed to get clk name %d\", i);\n\t\t\treturn ret;\n\t\t}\n\t\tclk_info->vcodec_clk = devm_clk_get(&pdev->dev,\n\t\t\tclk_info->clk_name);\n\t\tif (IS_ERR(clk_info->vcodec_clk)) {\n\t\t\tdev_err(pm->dev, \"[MTK VCODEC] venc devm_clk_get (%d)%s fail\", i,\n\t\t\t\tclk_info->clk_name);\n\t\t\treturn PTR_ERR(clk_info->vcodec_clk);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid mtk_vcodec_enc_clock_on(struct mtk_vcodec_pm *pm)\n{\n\tstruct mtk_vcodec_clk *enc_clk = &pm->venc_clk;\n\tint ret, i = 0;\n\n\tfor (i = 0; i < enc_clk->clk_num; i++) {\n\t\tret = clk_prepare_enable(enc_clk->clk_info[i].vcodec_clk);\n\t\tif (ret) {\n\t\t\tdev_err(pm->dev, \"[MTK VCODEC] venc clk_prepare_enable %d %s fail %d\", i,\n\t\t\t\tenc_clk->clk_info[i].clk_name, ret);\n\t\t\tgoto clkerr;\n\t\t}\n\t}\n\n\treturn;\n\nclkerr:\n\tfor (i -= 1; i >= 0; i--)\n\t\tclk_disable_unprepare(enc_clk->clk_info[i].vcodec_clk);\n}\n\nvoid mtk_vcodec_enc_clock_off(struct mtk_vcodec_pm *pm)\n{\n\tstruct mtk_vcodec_clk *enc_clk = &pm->venc_clk;\n\tint i = 0;\n\n\tfor (i = enc_clk->clk_num - 1; i >= 0; i--)\n\t\tclk_disable_unprepare(enc_clk->clk_info[i].vcodec_clk);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}