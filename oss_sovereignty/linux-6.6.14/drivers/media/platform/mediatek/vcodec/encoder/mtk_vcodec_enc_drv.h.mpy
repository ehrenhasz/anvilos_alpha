{
  "module_name": "mtk_vcodec_enc_drv.h",
  "hash_id": "a569ff1f32ef7abd3f5e62f5d99706719840962bdaede731567dcdfb1ea1fe3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/vcodec/encoder/mtk_vcodec_enc_drv.h",
  "human_readable_source": " \n \n\n#ifndef _MTK_VCODEC_ENC_DRV_H_\n#define _MTK_VCODEC_ENC_DRV_H_\n\n#include \"../common/mtk_vcodec_cmn_drv.h\"\n#include \"../common/mtk_vcodec_dbgfs.h\"\n#include \"../common/mtk_vcodec_fw_priv.h\"\n#include \"../common/mtk_vcodec_util.h\"\n\n#define MTK_VCODEC_ENC_NAME\t\"mtk-vcodec-enc\"\n\n#define MTK_ENC_CTX_IS_EXT(ctx) ((ctx)->dev->venc_pdata->uses_ext)\n#define MTK_ENC_IOVA_IS_34BIT(ctx) ((ctx)->dev->venc_pdata->uses_34bit)\n\n \nstruct mtk_vcodec_enc_pdata {\n\tbool uses_ext;\n\tu64 min_bitrate;\n\tu64 max_bitrate;\n\tconst struct mtk_video_fmt *capture_formats;\n\tsize_t num_capture_formats;\n\tconst struct mtk_video_fmt *output_formats;\n\tsize_t num_output_formats;\n\tu8 core_id;\n\tbool uses_34bit;\n};\n\n \nenum mtk_encode_param {\n\tMTK_ENCODE_PARAM_NONE = 0,\n\tMTK_ENCODE_PARAM_BITRATE = (1 << 0),\n\tMTK_ENCODE_PARAM_FRAMERATE = (1 << 1),\n\tMTK_ENCODE_PARAM_INTRA_PERIOD = (1 << 2),\n\tMTK_ENCODE_PARAM_FORCE_INTRA = (1 << 3),\n\tMTK_ENCODE_PARAM_GOP_SIZE = (1 << 4),\n};\n\n \nstruct mtk_enc_params {\n\tunsigned int\tbitrate;\n\tunsigned int\tnum_b_frame;\n\tunsigned int\trc_frame;\n\tunsigned int\trc_mb;\n\tunsigned int\tseq_hdr_mode;\n\tunsigned int\tintra_period;\n\tunsigned int\tgop_size;\n\tunsigned int\tframerate_num;\n\tunsigned int\tframerate_denom;\n\tunsigned int\th264_max_qp;\n\tunsigned int\th264_profile;\n\tunsigned int\th264_level;\n\tunsigned int\tforce_intra;\n};\n\n \nstruct mtk_vcodec_enc_ctx {\n\tenum mtk_instance_type type;\n\tstruct mtk_vcodec_enc_dev *dev;\n\tstruct list_head list;\n\n\tstruct v4l2_fh fh;\n\tstruct v4l2_m2m_ctx *m2m_ctx;\n\tstruct mtk_q_data q_data[2];\n\tint id;\n\tenum mtk_instance_state state;\n\tenum mtk_encode_param param_change;\n\tstruct mtk_enc_params enc_params;\n\n\tconst struct venc_common_if *enc_if;\n\tvoid *drv_handle;\n\n\tint int_cond[MTK_VDEC_HW_MAX];\n\tint int_type[MTK_VDEC_HW_MAX];\n\twait_queue_head_t queue[MTK_VDEC_HW_MAX];\n\tunsigned int irq_status;\n\n\tstruct v4l2_ctrl_handler ctrl_hdl;\n\tstruct work_struct encode_work;\n\tstruct v4l2_m2m_buffer empty_flush_buf;\n\tbool is_flushing;\n\n\tenum v4l2_colorspace colorspace;\n\tenum v4l2_ycbcr_encoding ycbcr_enc;\n\tenum v4l2_quantization quantization;\n\tenum v4l2_xfer_func xfer_func;\n\n\tstruct mutex q_mutex;\n\tvoid *vpu_inst;\n};\n\n \nstruct mtk_vcodec_enc_dev {\n\tstruct v4l2_device v4l2_dev;\n\tstruct video_device *vfd_enc;\n\n\tstruct v4l2_m2m_dev *m2m_dev_enc;\n\tstruct platform_device *plat_dev;\n\tstruct list_head ctx_list;\n\tstruct mtk_vcodec_enc_ctx *curr_ctx;\n\n\tvoid __iomem *reg_base[NUM_MAX_VCODEC_REG_BASE];\n\tconst struct mtk_vcodec_enc_pdata *venc_pdata;\n\n\tstruct mtk_vcodec_fw *fw_handler;\n\tu64 id_counter;\n\n\t \n\tstruct mutex enc_mutex;\n\tstruct mutex dev_mutex;\n\tstruct workqueue_struct *encode_workqueue;\n\n\tint enc_irq;\n\tspinlock_t irqlock;\n\n\tstruct mtk_vcodec_pm pm;\n\tunsigned int enc_capability;\n\tstruct mtk_vcodec_dbgfs dbgfs;\n};\n\nstatic inline struct mtk_vcodec_enc_ctx *fh_to_enc_ctx(struct v4l2_fh *fh)\n{\n\treturn container_of(fh, struct mtk_vcodec_enc_ctx, fh);\n}\n\nstatic inline struct mtk_vcodec_enc_ctx *ctrl_to_enc_ctx(struct v4l2_ctrl *ctrl)\n{\n\treturn container_of(ctrl->handler, struct mtk_vcodec_enc_ctx, ctrl_hdl);\n}\n\n \nstatic inline void\nwake_up_enc_ctx(struct mtk_vcodec_enc_ctx *ctx, unsigned int reason, unsigned int hw_id)\n{\n\tctx->int_cond[hw_id] = 1;\n\tctx->int_type[hw_id] = reason;\n\twake_up_interruptible(&ctx->queue[hw_id]);\n}\n\n#define mtk_venc_err(ctx, fmt, args...)                               \\\n\tmtk_vcodec_err((ctx)->id, (ctx)->dev->plat_dev, fmt, ##args)\n\n#define mtk_venc_debug(ctx, fmt, args...)                              \\\n\tmtk_vcodec_debug((ctx)->id, (ctx)->dev->plat_dev, fmt, ##args)\n\n#define mtk_v4l2_venc_err(ctx, fmt, args...) mtk_v4l2_err((ctx)->dev->plat_dev, fmt, ##args)\n\n#define mtk_v4l2_venc_dbg(level, ctx, fmt, args...)             \\\n\tmtk_v4l2_debug((ctx)->dev->plat_dev, level, fmt, ##args)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}