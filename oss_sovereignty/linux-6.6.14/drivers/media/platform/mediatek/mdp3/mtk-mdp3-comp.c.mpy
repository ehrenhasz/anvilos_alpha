{
  "module_name": "mtk-mdp3-comp.c",
  "hash_id": "3cd74cd6a343b5516d13f311ca9715a438c9e3cc556a737aa16676e8520fa671",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/mdp3/mtk-mdp3-comp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n#include <linux/pm_runtime.h>\n#include \"mtk-mdp3-cfg.h\"\n#include \"mtk-mdp3-comp.h\"\n#include \"mtk-mdp3-core.h\"\n#include \"mtk-mdp3-regs.h\"\n\n#include \"mdp_reg_rdma.h\"\n#include \"mdp_reg_ccorr.h\"\n#include \"mdp_reg_rsz.h\"\n#include \"mdp_reg_wrot.h\"\n#include \"mdp_reg_wdma.h\"\n\nstatic u32 mdp_comp_alias_id[MDP_COMP_TYPE_COUNT];\nstatic int p_id;\n\nstatic inline const struct mdp_platform_config *\n__get_plat_cfg(const struct mdp_comp_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn NULL;\n\n\treturn ctx->comp->mdp_dev->mdp_data->mdp_cfg;\n}\n\nstatic s64 get_comp_flag(const struct mdp_comp_ctx *ctx)\n{\n\tconst struct mdp_platform_config *mdp_cfg = __get_plat_cfg(ctx);\n\tu32 rdma0, rsz1;\n\n\trdma0 = mdp_cfg_get_id_inner(ctx->comp->mdp_dev, MDP_COMP_RDMA0);\n\trsz1 = mdp_cfg_get_id_inner(ctx->comp->mdp_dev, MDP_COMP_RSZ1);\n\tif (!rdma0 || !rsz1)\n\t\treturn MDP_COMP_NONE;\n\n\tif (mdp_cfg && mdp_cfg->rdma_rsz1_sram_sharing)\n\t\tif (ctx->comp->inner_id == rdma0)\n\t\t\treturn BIT(rdma0) | BIT(rsz1);\n\n\treturn BIT(ctx->comp->inner_id);\n}\n\nstatic int init_rdma(struct mdp_comp_ctx *ctx, struct mdp_cmdq_cmd *cmd)\n{\n\tconst struct mdp_platform_config *mdp_cfg = __get_plat_cfg(ctx);\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\ts32 rdma0;\n\n\trdma0 = mdp_cfg_get_id_inner(ctx->comp->mdp_dev, MDP_COMP_RDMA0);\n\tif (!rdma0)\n\t\treturn -EINVAL;\n\n\tif (mdp_cfg && mdp_cfg->rdma_support_10bit) {\n\t\tstruct mdp_comp *prz1 = ctx->comp->mdp_dev->comp[MDP_COMP_RSZ1];\n\n\t\t \n\t\tif (ctx->comp->inner_id == rdma0 && prz1)\n\t\t\tMM_REG_WRITE(cmd, subsys_id, prz1->reg_base, PRZ_ENABLE,\n\t\t\t\t     0x0, BIT(0));\n\t}\n\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_RESET, BIT(0), BIT(0));\n\tMM_REG_POLL(cmd, subsys_id, base, MDP_RDMA_MON_STA_1, BIT(8), BIT(8));\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_RESET, 0x0, BIT(0));\n\treturn 0;\n}\n\nstatic int config_rdma_frame(struct mdp_comp_ctx *ctx,\n\t\t\t     struct mdp_cmdq_cmd *cmd,\n\t\t\t     const struct v4l2_rect *compose)\n{\n\tconst struct mdp_platform_config *mdp_cfg = __get_plat_cfg(ctx);\n\tu32 colorformat = ctx->input->buffer.format.colorformat;\n\tbool block10bit = MDP_COLOR_IS_10BIT_PACKED(colorformat);\n\tbool en_ufo = MDP_COLOR_IS_UFP(colorformat);\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\tu32 reg = 0;\n\n\tif (mdp_cfg && mdp_cfg->rdma_support_10bit) {\n\t\tif (block10bit)\n\t\t\tMM_REG_WRITE(cmd, subsys_id, base,\n\t\t\t\t     MDP_RDMA_RESV_DUMMY_0, 0x7, 0x7);\n\t\telse\n\t\t\tMM_REG_WRITE(cmd, subsys_id, base,\n\t\t\t\t     MDP_RDMA_RESV_DUMMY_0, 0x0, 0x7);\n\t}\n\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_GMCIF_CON,\n\t\t     (7 <<  4) + \n\t\t     (1 << 16),  \n\t\t     0x00030071);\n\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.src_ctrl);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_CON, reg,\n\t\t     0x03C8FE0F);\n\n\tif (mdp_cfg)\n\t\tif (mdp_cfg->rdma_support_10bit && en_ufo) {\n\t\t\t \n\t\t\tif (CFG_CHECK(MT8183, p_id))\n\t\t\t\treg = CFG_COMP(MT8183, ctx->param, rdma.ufo_dec_y);\n\t\t\tMM_REG_WRITE(cmd, subsys_id,\n\t\t\t\t     base, MDP_RDMA_UFO_DEC_LENGTH_BASE_Y,\n\t\t\t\t     reg, 0xFFFFFFFF);\n\t\t\tif (CFG_CHECK(MT8183, p_id))\n\t\t\t\treg = CFG_COMP(MT8183, ctx->param, rdma.ufo_dec_c);\n\t\t\tMM_REG_WRITE(cmd, subsys_id,\n\t\t\t\t     base, MDP_RDMA_UFO_DEC_LENGTH_BASE_C,\n\t\t\t\t     reg, 0xFFFFFFFF);\n\t\t\t \n\t\t\tif (block10bit) {\n\t\t\t\tif (CFG_CHECK(MT8183, p_id))\n\t\t\t\t\treg = CFG_COMP(MT8183, ctx->param, rdma.mf_bkgd_in_pxl);\n\t\t\t\tMM_REG_WRITE(cmd, subsys_id,\n\t\t\t\t\t     base, MDP_RDMA_MF_BKGD_SIZE_IN_PXL,\n\t\t\t\t\t     reg, 0x001FFFFF);\n\t\t\t}\n\t\t}\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.control);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_CON, reg,\n\t\t     0x1110);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.iova[0]);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_BASE_0, reg,\n\t\t     0xFFFFFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.iova[1]);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_BASE_1, reg,\n\t\t     0xFFFFFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.iova[2]);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_BASE_2, reg,\n\t\t     0xFFFFFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.iova_end[0]);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_END_0,\n\t\t     reg, 0xFFFFFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.iova_end[1]);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_END_1,\n\t\t     reg, 0xFFFFFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.iova_end[2]);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_END_2,\n\t\t     reg, 0xFFFFFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.mf_bkgd);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_MF_BKGD_SIZE_IN_BYTE,\n\t\t     reg, 0x001FFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.sf_bkgd);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SF_BKGD_SIZE_IN_BYTE,\n\t\t     reg, 0x001FFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.transform);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_TRANSFORM_0,\n\t\t     reg, 0x0F110000);\n\n\treturn 0;\n}\n\nstatic int config_rdma_subfrm(struct mdp_comp_ctx *ctx,\n\t\t\t      struct mdp_cmdq_cmd *cmd, u32 index)\n{\n\tconst struct mdp_platform_config *mdp_cfg = __get_plat_cfg(ctx);\n\tu32 colorformat = ctx->input->buffer.format.colorformat;\n\tbool block10bit = MDP_COLOR_IS_10BIT_PACKED(colorformat);\n\tbool en_ufo = MDP_COLOR_IS_UFP(colorformat);\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\tu32 csf_l = 0, csf_r = 0;\n\tu32 reg = 0;\n\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_EN, BIT(0), BIT(0));\n\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.subfrms[index].offset[0]);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_0,\n\t\t     reg, 0xFFFFFFFF);\n\n\t \n\tif (mdp_cfg) {\n\t\tif (mdp_cfg->rdma_support_10bit && block10bit && en_ufo) {\n\t\t\tif (CFG_CHECK(MT8183, p_id))\n\t\t\t\treg = CFG_COMP(MT8183, ctx->param, rdma.subfrms[index].offset_0_p);\n\t\t\tMM_REG_WRITE(cmd, subsys_id, base,\n\t\t\t\t     MDP_RDMA_SRC_OFFSET_0_P,\n\t\t\t\t     reg, 0xFFFFFFFF);\n\t\t}\n\t}\n\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.subfrms[index].offset[1]);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_1,\n\t\t     reg, 0xFFFFFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.subfrms[index].offset[2]);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_2,\n\t\t     reg, 0xFFFFFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.subfrms[index].src);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_MF_SRC_SIZE, reg,\n\t\t     0x1FFF1FFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.subfrms[index].clip);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_MF_CLIP_SIZE,\n\t\t     reg, 0x1FFF1FFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rdma.subfrms[index].clip_ofst);\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_MF_OFFSET_1,\n\t\t     reg, 0x003F001F);\n\n\tif (CFG_CHECK(MT8183, p_id)) {\n\t\tcsf_l = CFG_COMP(MT8183, ctx->param, subfrms[index].in.left);\n\t\tcsf_r = CFG_COMP(MT8183, ctx->param, subfrms[index].in.right);\n\t}\n\tif (mdp_cfg && mdp_cfg->rdma_upsample_repeat_only)\n\t\tif ((csf_r - csf_l + 1) > 320)\n\t\t\tMM_REG_WRITE(cmd, subsys_id, base,\n\t\t\t\t     MDP_RDMA_RESV_DUMMY_0, BIT(2), BIT(2));\n\n\treturn 0;\n}\n\nstatic int wait_rdma_event(struct mdp_comp_ctx *ctx, struct mdp_cmdq_cmd *cmd)\n{\n\tstruct device *dev = &ctx->comp->mdp_dev->pdev->dev;\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\n\tif (ctx->comp->alias_id == 0)\n\t\tMM_REG_WAIT(cmd, ctx->comp->gce_event[MDP_GCE_EVENT_EOF]);\n\telse\n\t\tdev_err(dev, \"Do not support RDMA1_DONE event\\n\");\n\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_EN, 0x0, BIT(0));\n\treturn 0;\n}\n\nstatic const struct mdp_comp_ops rdma_ops = {\n\t.get_comp_flag = get_comp_flag,\n\t.init_comp = init_rdma,\n\t.config_frame = config_rdma_frame,\n\t.config_subfrm = config_rdma_subfrm,\n\t.wait_comp_event = wait_rdma_event,\n};\n\nstatic int init_rsz(struct mdp_comp_ctx *ctx, struct mdp_cmdq_cmd *cmd)\n{\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_ENABLE, 0x10000, BIT(16));\n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_ENABLE, 0x0, BIT(16));\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_ENABLE, BIT(0), BIT(0));\n\treturn 0;\n}\n\nstatic int config_rsz_frame(struct mdp_comp_ctx *ctx,\n\t\t\t    struct mdp_cmdq_cmd *cmd,\n\t\t\t    const struct v4l2_rect *compose)\n{\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\tbool bypass = FALSE;\n\tu32 reg = 0;\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\tbypass = CFG_COMP(MT8183, ctx->param, frame.bypass);\n\n\tif (bypass) {\n\t\t \n\t\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_ENABLE, 0x0, BIT(0));\n\t\treturn 0;\n\t}\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rsz.control1);\n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_1, reg,\n\t\t     0x03FFFDF3);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rsz.control2);\n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_2, reg,\n\t\t     0x0FFFC290);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rsz.coeff_step_x);\n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_HORIZONTAL_COEFF_STEP,\n\t\t     reg, 0x007FFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rsz.coeff_step_y);\n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_VERTICAL_COEFF_STEP,\n\t\t     reg, 0x007FFFFF);\n\treturn 0;\n}\n\nstatic int config_rsz_subfrm(struct mdp_comp_ctx *ctx,\n\t\t\t     struct mdp_cmdq_cmd *cmd, u32 index)\n{\n\tconst struct mdp_platform_config *mdp_cfg = __get_plat_cfg(ctx);\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\tu32 csf_l = 0, csf_r = 0;\n\tu32 reg = 0;\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rsz.subfrms[index].control2);\n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_2, reg,\n\t\t     0x00003800);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rsz.subfrms[index].src);\n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_INPUT_IMAGE, reg,\n\t\t     0xFFFFFFFF);\n\n\tif (CFG_CHECK(MT8183, p_id)) {\n\t\tcsf_l = CFG_COMP(MT8183, ctx->param, subfrms[index].in.left);\n\t\tcsf_r = CFG_COMP(MT8183, ctx->param, subfrms[index].in.right);\n\t}\n\tif (mdp_cfg && mdp_cfg->rsz_disable_dcm_small_sample)\n\t\tif ((csf_r - csf_l + 1) <= 16)\n\t\t\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_1,\n\t\t\t\t     BIT(27), BIT(27));\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, subfrms[index].luma.left);\n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_LUMA_HORIZONTAL_INTEGER_OFFSET,\n\t\t     reg, 0xFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, subfrms[index].luma.left_subpix);\n\tMM_REG_WRITE(cmd, subsys_id,\n\t\t     base, PRZ_LUMA_HORIZONTAL_SUBPIXEL_OFFSET,\n\t\t     reg, 0x1FFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, subfrms[index].luma.top);\n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_LUMA_VERTICAL_INTEGER_OFFSET,\n\t\t     reg, 0xFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, subfrms[index].luma.top_subpix);\n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_LUMA_VERTICAL_SUBPIXEL_OFFSET,\n\t\t     reg, 0x1FFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, subfrms[index].chroma.left);\n\tMM_REG_WRITE(cmd, subsys_id,\n\t\t     base, PRZ_CHROMA_HORIZONTAL_INTEGER_OFFSET,\n\t\t     reg, 0xFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, subfrms[index].chroma.left_subpix);\n\tMM_REG_WRITE(cmd, subsys_id,\n\t\t     base, PRZ_CHROMA_HORIZONTAL_SUBPIXEL_OFFSET,\n\t\t     reg, 0x1FFFFF);\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, rsz.subfrms[index].clip);\n\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_OUTPUT_IMAGE, reg,\n\t\t     0xFFFFFFFF);\n\n\treturn 0;\n}\n\nstatic int advance_rsz_subfrm(struct mdp_comp_ctx *ctx,\n\t\t\t      struct mdp_cmdq_cmd *cmd, u32 index)\n{\n\tconst struct mdp_platform_config *mdp_cfg = __get_plat_cfg(ctx);\n\n\tif (mdp_cfg && mdp_cfg->rsz_disable_dcm_small_sample) {\n\t\tphys_addr_t base = ctx->comp->reg_base;\n\t\tu8 subsys_id = ctx->comp->subsys_id;\n\t\tu32 csf_l = 0, csf_r = 0;\n\n\t\tif (CFG_CHECK(MT8183, p_id)) {\n\t\t\tcsf_l = CFG_COMP(MT8183, ctx->param, subfrms[index].in.left);\n\t\t\tcsf_r = CFG_COMP(MT8183, ctx->param, subfrms[index].in.right);\n\t\t}\n\n\t\tif ((csf_r - csf_l + 1) <= 16)\n\t\t\tMM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_1, 0x0,\n\t\t\t\t     BIT(27));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mdp_comp_ops rsz_ops = {\n\t.get_comp_flag = get_comp_flag,\n\t.init_comp = init_rsz,\n\t.config_frame = config_rsz_frame,\n\t.config_subfrm = config_rsz_subfrm,\n\t.advance_subfrm = advance_rsz_subfrm,\n};\n\nstatic int init_wrot(struct mdp_comp_ctx *ctx, struct mdp_cmdq_cmd *cmd)\n{\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_SOFT_RST, BIT(0), BIT(0));\n\tMM_REG_POLL(cmd, subsys_id, base, VIDO_SOFT_RST_STAT, BIT(0), BIT(0));\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_SOFT_RST, 0x0, BIT(0));\n\tMM_REG_POLL(cmd, subsys_id, base, VIDO_SOFT_RST_STAT, 0x0, BIT(0));\n\treturn 0;\n}\n\nstatic int config_wrot_frame(struct mdp_comp_ctx *ctx,\n\t\t\t     struct mdp_cmdq_cmd *cmd,\n\t\t\t     const struct v4l2_rect *compose)\n{\n\tconst struct mdp_platform_config *mdp_cfg = __get_plat_cfg(ctx);\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\tu32 reg = 0;\n\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.iova[0]);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR, reg,\n\t\t     0xFFFFFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.iova[1]);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR_C, reg,\n\t\t     0xFFFFFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.iova[2]);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR_V, reg,\n\t\t     0xFFFFFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.control);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_CTRL, reg,\n\t\t     0xF131510F);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.stride[0]);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE, reg,\n\t\t     0x0000FFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.stride[1]);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE_C, reg,\n\t\t     0xFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.stride[2]);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE_V, reg,\n\t\t     0xFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.mat_ctrl);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_MAT_CTRL, reg, 0xF3);\n\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_DITHER, 0xFF000000,\n\t\t     0xFF000000);\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_RSV_1, BIT(31), BIT(31));\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.fifo_test);\n\tif (reg != 0)\n\t\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_FIFO_TEST,\n\t\t\t     reg, 0xFFF);\n\t \n\tif (mdp_cfg && mdp_cfg->wrot_filter_constraint) {\n\t\tif (CFG_CHECK(MT8183, p_id))\n\t\t\treg = CFG_COMP(MT8183, ctx->param, wrot.filter);\n\t\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE,\n\t\t\t     reg, 0x77);\n\t}\n\n\treturn 0;\n}\n\nstatic int config_wrot_subfrm(struct mdp_comp_ctx *ctx,\n\t\t\t      struct mdp_cmdq_cmd *cmd, u32 index)\n{\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\tu32 reg = 0;\n\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.subfrms[index].offset[0]);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR,\n\t\t     reg, 0x0FFFFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.subfrms[index].offset[1]);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR_C,\n\t\t     reg, 0x0FFFFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.subfrms[index].offset[2]);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR_V,\n\t\t     reg, 0x0FFFFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.subfrms[index].src);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_IN_SIZE, reg,\n\t\t     0x1FFF1FFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.subfrms[index].clip);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_TAR_SIZE, reg,\n\t\t     0x1FFF1FFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.subfrms[index].clip_ofst);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_CROP_OFST, reg,\n\t\t     0x1FFF1FFF);\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wrot.subfrms[index].main_buf);\n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE,\n\t\t     reg, 0x1FFF7F00);\n\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_ROT_EN, BIT(0), BIT(0));\n\n\treturn 0;\n}\n\nstatic int wait_wrot_event(struct mdp_comp_ctx *ctx, struct mdp_cmdq_cmd *cmd)\n{\n\tconst struct mdp_platform_config *mdp_cfg = __get_plat_cfg(ctx);\n\tstruct device *dev = &ctx->comp->mdp_dev->pdev->dev;\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\n\tif (ctx->comp->alias_id == 0)\n\t\tMM_REG_WAIT(cmd, ctx->comp->gce_event[MDP_GCE_EVENT_EOF]);\n\telse\n\t\tdev_err(dev, \"Do not support WROT1_DONE event\\n\");\n\n\tif (mdp_cfg && mdp_cfg->wrot_filter_constraint)\n\t\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE, 0x0,\n\t\t\t     0x77);\n\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, VIDO_ROT_EN, 0x0, BIT(0));\n\n\treturn 0;\n}\n\nstatic const struct mdp_comp_ops wrot_ops = {\n\t.get_comp_flag = get_comp_flag,\n\t.init_comp = init_wrot,\n\t.config_frame = config_wrot_frame,\n\t.config_subfrm = config_wrot_subfrm,\n\t.wait_comp_event = wait_wrot_event,\n};\n\nstatic int init_wdma(struct mdp_comp_ctx *ctx, struct mdp_cmdq_cmd *cmd)\n{\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_RST, BIT(0), BIT(0));\n\tMM_REG_POLL(cmd, subsys_id, base, WDMA_FLOW_CTRL_DBG, BIT(0), BIT(0));\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_RST, 0x0, BIT(0));\n\treturn 0;\n}\n\nstatic int config_wdma_frame(struct mdp_comp_ctx *ctx,\n\t\t\t     struct mdp_cmdq_cmd *cmd,\n\t\t\t     const struct v4l2_rect *compose)\n{\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\tu32 reg = 0;\n\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_BUF_CON2, 0x10101050,\n\t\t     0xFFFFFFFF);\n\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wdma.wdma_cfg);\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_CFG, reg,\n\t\t     0x0F01B8F0);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wdma.iova[0]);\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_ADDR, reg,\n\t\t     0xFFFFFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wdma.iova[1]);\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_U_ADDR, reg,\n\t\t     0xFFFFFFFF);\n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wdma.iova[2]);\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_V_ADDR, reg,\n\t\t     0xFFFFFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wdma.w_in_byte);\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_W_IN_BYTE,\n\t\t     reg, 0x0000FFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wdma.uv_stride);\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_UV_PITCH,\n\t\t     reg, 0x0000FFFF);\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_ALPHA, 0x800000FF,\n\t\t     0x800000FF);\n\n\treturn 0;\n}\n\nstatic int config_wdma_subfrm(struct mdp_comp_ctx *ctx,\n\t\t\t      struct mdp_cmdq_cmd *cmd, u32 index)\n{\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\tu32 reg = 0;\n\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wdma.subfrms[index].offset[0]);\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_ADDR_OFFSET,\n\t\t     reg, 0x0FFFFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wdma.subfrms[index].offset[1]);\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_U_ADDR_OFFSET,\n\t\t     reg, 0x0FFFFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wdma.subfrms[index].offset[2]);\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_V_ADDR_OFFSET,\n\t\t     reg, 0x0FFFFFFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wdma.subfrms[index].src);\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_SRC_SIZE, reg,\n\t\t     0x3FFF3FFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wdma.subfrms[index].clip);\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_CLIP_SIZE, reg,\n\t\t     0x3FFF3FFF);\n\t \n\tif (CFG_CHECK(MT8183, p_id))\n\t\treg = CFG_COMP(MT8183, ctx->param, wdma.subfrms[index].clip_ofst);\n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_CLIP_COORD, reg,\n\t\t     0x3FFF3FFF);\n\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_EN, BIT(0), BIT(0));\n\n\treturn 0;\n}\n\nstatic int wait_wdma_event(struct mdp_comp_ctx *ctx, struct mdp_cmdq_cmd *cmd)\n{\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\n\tMM_REG_WAIT(cmd, ctx->comp->gce_event[MDP_GCE_EVENT_EOF]);\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, WDMA_EN, 0x0, BIT(0));\n\treturn 0;\n}\n\nstatic const struct mdp_comp_ops wdma_ops = {\n\t.get_comp_flag = get_comp_flag,\n\t.init_comp = init_wdma,\n\t.config_frame = config_wdma_frame,\n\t.config_subfrm = config_wdma_subfrm,\n\t.wait_comp_event = wait_wdma_event,\n};\n\nstatic int init_ccorr(struct mdp_comp_ctx *ctx, struct mdp_cmdq_cmd *cmd)\n{\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_CCORR_EN, BIT(0), BIT(0));\n\t \n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_CCORR_CFG, BIT(0), BIT(0));\n\treturn 0;\n}\n\nstatic int config_ccorr_subfrm(struct mdp_comp_ctx *ctx,\n\t\t\t       struct mdp_cmdq_cmd *cmd, u32 index)\n{\n\tphys_addr_t base = ctx->comp->reg_base;\n\tu8 subsys_id = ctx->comp->subsys_id;\n\tu32 csf_l = 0, csf_r = 0;\n\tu32 csf_t = 0, csf_b = 0;\n\tu32 hsize, vsize;\n\n\tif (CFG_CHECK(MT8183, p_id)) {\n\t\tcsf_l = CFG_COMP(MT8183, ctx->param, subfrms[index].in.left);\n\t\tcsf_r = CFG_COMP(MT8183, ctx->param, subfrms[index].in.right);\n\t\tcsf_t = CFG_COMP(MT8183, ctx->param, subfrms[index].in.top);\n\t\tcsf_b = CFG_COMP(MT8183, ctx->param, subfrms[index].in.bottom);\n\t}\n\n\thsize = csf_r - csf_l + 1;\n\tvsize = csf_b - csf_t + 1;\n\tMM_REG_WRITE(cmd, subsys_id, base, MDP_CCORR_SIZE,\n\t\t     (hsize << 16) + (vsize <<  0), 0x1FFF1FFF);\n\treturn 0;\n}\n\nstatic const struct mdp_comp_ops ccorr_ops = {\n\t.get_comp_flag = get_comp_flag,\n\t.init_comp = init_ccorr,\n\t.config_subfrm = config_ccorr_subfrm,\n};\n\nstatic const struct mdp_comp_ops *mdp_comp_ops[MDP_COMP_TYPE_COUNT] = {\n\t[MDP_COMP_TYPE_RDMA] =\t\t&rdma_ops,\n\t[MDP_COMP_TYPE_RSZ] =\t\t&rsz_ops,\n\t[MDP_COMP_TYPE_WROT] =\t\t&wrot_ops,\n\t[MDP_COMP_TYPE_WDMA] =\t\t&wdma_ops,\n\t[MDP_COMP_TYPE_CCORR] =\t\t&ccorr_ops,\n};\n\nstatic const struct of_device_id mdp_comp_dt_ids[] __maybe_unused = {\n\t{\n\t\t.compatible = \"mediatek,mt8183-mdp3-rdma\",\n\t\t.data = (void *)MDP_COMP_TYPE_RDMA,\n\t}, {\n\t\t.compatible = \"mediatek,mt8183-mdp3-ccorr\",\n\t\t.data = (void *)MDP_COMP_TYPE_CCORR,\n\t}, {\n\t\t.compatible = \"mediatek,mt8183-mdp3-rsz\",\n\t\t.data = (void *)MDP_COMP_TYPE_RSZ,\n\t}, {\n\t\t.compatible = \"mediatek,mt8183-mdp3-wrot\",\n\t\t.data = (void *)MDP_COMP_TYPE_WROT,\n\t}, {\n\t\t.compatible = \"mediatek,mt8183-mdp3-wdma\",\n\t\t.data = (void *)MDP_COMP_TYPE_WDMA,\n\t},\n\t{}\n};\n\nstatic inline bool is_dma_capable(const enum mdp_comp_type type)\n{\n\treturn (type == MDP_COMP_TYPE_RDMA ||\n\t\ttype == MDP_COMP_TYPE_WROT ||\n\t\ttype == MDP_COMP_TYPE_WDMA);\n}\n\nstatic inline bool is_bypass_gce_event(const enum mdp_comp_type type)\n{\n\t \n\treturn (type == MDP_COMP_TYPE_PATH);\n}\n\nstatic int mdp_comp_get_id(struct mdp_dev *mdp, enum mdp_comp_type type, u32 alias_id)\n{\n\tint i;\n\n\tfor (i = 0; i < mdp->mdp_data->comp_data_len; i++)\n\t\tif (mdp->mdp_data->comp_data[i].match.type == type &&\n\t\t    mdp->mdp_data->comp_data[i].match.alias_id == alias_id)\n\t\t\treturn i;\n\treturn -ENODEV;\n}\n\nint mdp_comp_clock_on(struct device *dev, struct mdp_comp *comp)\n{\n\tint i, ret;\n\n\t \n\tif (comp->comp_dev && is_dma_capable(comp->type)) {\n\t\tret = pm_runtime_resume_and_get(comp->comp_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to get power, err %d. type:%d id:%d\\n\",\n\t\t\t\tret, comp->type, comp->inner_id);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < comp->clk_num; i++) {\n\t\tif (IS_ERR_OR_NULL(comp->clks[i]))\n\t\t\tcontinue;\n\t\tret = clk_prepare_enable(comp->clks[i]);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to enable clk %d. type:%d id:%d\\n\",\n\t\t\t\ti, comp->type, comp->inner_id);\n\t\t\tgoto err_revert;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_revert:\n\twhile (--i >= 0) {\n\t\tif (IS_ERR_OR_NULL(comp->clks[i]))\n\t\t\tcontinue;\n\t\tclk_disable_unprepare(comp->clks[i]);\n\t}\n\tif (comp->comp_dev && is_dma_capable(comp->type))\n\t\tpm_runtime_put_sync(comp->comp_dev);\n\n\treturn ret;\n}\n\nvoid mdp_comp_clock_off(struct device *dev, struct mdp_comp *comp)\n{\n\tint i;\n\n\tfor (i = 0; i < comp->clk_num; i++) {\n\t\tif (IS_ERR_OR_NULL(comp->clks[i]))\n\t\t\tcontinue;\n\t\tclk_disable_unprepare(comp->clks[i]);\n\t}\n\n\tif (comp->comp_dev && is_dma_capable(comp->type))\n\t\tpm_runtime_put(comp->comp_dev);\n}\n\nint mdp_comp_clocks_on(struct device *dev, struct mdp_comp *comps, int num)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = mdp_comp_clock_on(dev, &comps[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid mdp_comp_clocks_off(struct device *dev, struct mdp_comp *comps, int num)\n{\n\tint i;\n\n\tfor (i = 0; i < num; i++)\n\t\tmdp_comp_clock_off(dev, &comps[i]);\n}\n\nstatic int mdp_get_subsys_id(struct mdp_dev *mdp, struct device *dev,\n\t\t\t     struct device_node *node, struct mdp_comp *comp)\n{\n\tstruct platform_device *comp_pdev;\n\tstruct cmdq_client_reg  cmdq_reg;\n\tint ret = 0;\n\tint index = 0;\n\n\tif (!dev || !node || !comp)\n\t\treturn -EINVAL;\n\n\tcomp_pdev = of_find_device_by_node(node);\n\n\tif (!comp_pdev) {\n\t\tdev_err(dev, \"get comp_pdev fail! comp public id=%d, inner id=%d, type=%d\\n\",\n\t\t\tcomp->public_id, comp->inner_id, comp->type);\n\t\treturn -ENODEV;\n\t}\n\n\tindex = mdp->mdp_data->comp_data[comp->public_id].info.dts_reg_ofst;\n\tret = cmdq_dev_get_client_reg(&comp_pdev->dev, &cmdq_reg, index);\n\tif (ret != 0) {\n\t\tdev_err(&comp_pdev->dev, \"cmdq_dev_get_subsys fail!\\n\");\n\t\tput_device(&comp_pdev->dev);\n\t\treturn -EINVAL;\n\t}\n\n\tcomp->subsys_id = cmdq_reg.subsys;\n\tdev_dbg(&comp_pdev->dev, \"subsys id=%d\\n\", cmdq_reg.subsys);\n\tput_device(&comp_pdev->dev);\n\n\treturn 0;\n}\n\nstatic void __mdp_comp_init(struct mdp_dev *mdp, struct device_node *node,\n\t\t\t    struct mdp_comp *comp)\n{\n\tstruct resource res;\n\tphys_addr_t base;\n\tint index;\n\n\tindex = mdp->mdp_data->comp_data[comp->public_id].info.dts_reg_ofst;\n\tif (of_address_to_resource(node, index, &res) < 0)\n\t\tbase = 0L;\n\telse\n\t\tbase = res.start;\n\n\tcomp->mdp_dev = mdp;\n\tcomp->regs = of_iomap(node, 0);\n\tcomp->reg_base = base;\n}\n\nstatic int mdp_comp_init(struct mdp_dev *mdp, struct device_node *node,\n\t\t\t struct mdp_comp *comp, enum mtk_mdp_comp_id id)\n{\n\tstruct device *dev = &mdp->pdev->dev;\n\tstruct platform_device *pdev_c;\n\tint clk_ofst;\n\tint i;\n\ts32 event;\n\n\tif (id < 0 || id >= MDP_MAX_COMP_COUNT) {\n\t\tdev_err(dev, \"Invalid component id %d\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tpdev_c = of_find_device_by_node(node);\n\tif (!pdev_c) {\n\t\tdev_warn(dev, \"can't find platform device of node:%s\\n\",\n\t\t\t node->name);\n\t\treturn -ENODEV;\n\t}\n\n\tcomp->comp_dev = &pdev_c->dev;\n\tcomp->public_id = id;\n\tcomp->type = mdp->mdp_data->comp_data[id].match.type;\n\tcomp->inner_id = mdp->mdp_data->comp_data[id].match.inner_id;\n\tcomp->alias_id = mdp->mdp_data->comp_data[id].match.alias_id;\n\tcomp->ops = mdp_comp_ops[comp->type];\n\t__mdp_comp_init(mdp, node, comp);\n\n\tcomp->clk_num = mdp->mdp_data->comp_data[id].info.clk_num;\n\tcomp->clks = devm_kzalloc(dev, sizeof(struct clk *) * comp->clk_num,\n\t\t\t\t  GFP_KERNEL);\n\tif (!comp->clks)\n\t\treturn -ENOMEM;\n\n\tclk_ofst = mdp->mdp_data->comp_data[id].info.clk_ofst;\n\n\tfor (i = 0; i < comp->clk_num; i++) {\n\t\tcomp->clks[i] = of_clk_get(node, i + clk_ofst);\n\t\tif (IS_ERR(comp->clks[i]))\n\t\t\tbreak;\n\t}\n\n\tmdp_get_subsys_id(mdp, dev, node, comp);\n\n\t \n\tif (is_bypass_gce_event(comp->type) ||\n\t    of_property_read_u32_index(node, \"mediatek,gce-events\",\n\t\t\t\t       MDP_GCE_EVENT_SOF, &event))\n\t\tevent = MDP_GCE_NO_EVENT;\n\n\tcomp->gce_event[MDP_GCE_EVENT_SOF] = event;\n\n\t \n\tif (is_dma_capable(comp->type)) {\n\t\tif (of_property_read_u32_index(node, \"mediatek,gce-events\",\n\t\t\t\t\t       MDP_GCE_EVENT_EOF, &event)) {\n\t\t\tdev_err(dev, \"Component id %d has no EOF\\n\", id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tevent = MDP_GCE_NO_EVENT;\n\t}\n\n\tcomp->gce_event[MDP_GCE_EVENT_EOF] = event;\n\n\treturn 0;\n}\n\nstatic void mdp_comp_deinit(struct mdp_comp *comp)\n{\n\tif (!comp)\n\t\treturn;\n\n\tif (comp->comp_dev && comp->clks) {\n\t\tdevm_kfree(&comp->mdp_dev->pdev->dev, comp->clks);\n\t\tcomp->clks = NULL;\n\t}\n\n\tif (comp->regs)\n\t\tiounmap(comp->regs);\n}\n\nstatic struct mdp_comp *mdp_comp_create(struct mdp_dev *mdp,\n\t\t\t\t\tstruct device_node *node,\n\t\t\t\t\tenum mtk_mdp_comp_id id)\n{\n\tstruct device *dev = &mdp->pdev->dev;\n\tstruct mdp_comp *comp;\n\tint ret;\n\n\tif (mdp->comp[id])\n\t\treturn ERR_PTR(-EEXIST);\n\n\tcomp = devm_kzalloc(dev, sizeof(*comp), GFP_KERNEL);\n\tif (!comp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = mdp_comp_init(mdp, node, comp, id);\n\tif (ret) {\n\t\tdevm_kfree(dev, comp);\n\t\treturn ERR_PTR(ret);\n\t}\n\tmdp->comp[id] = comp;\n\tmdp->comp[id]->mdp_dev = mdp;\n\n\tdev_dbg(dev, \"%s type:%d alias:%d public id:%d inner id:%d base:%#x regs:%p\\n\",\n\t\tdev->of_node->name, comp->type, comp->alias_id, id, comp->inner_id,\n\t\t(u32)comp->reg_base, comp->regs);\n\treturn comp;\n}\n\nstatic int mdp_comp_sub_create(struct mdp_dev *mdp)\n{\n\tstruct device *dev = &mdp->pdev->dev;\n\tstruct device_node *node, *parent;\n\tint ret = 0;\n\n\tparent = dev->of_node->parent;\n\n\tfor_each_child_of_node(parent, node) {\n\t\tconst struct of_device_id *of_id;\n\t\tenum mdp_comp_type type;\n\t\tint id, alias_id;\n\t\tstruct mdp_comp *comp;\n\n\t\tof_id = of_match_node(mdp->mdp_data->mdp_sub_comp_dt_ids, node);\n\t\tif (!of_id)\n\t\t\tcontinue;\n\t\tif (!of_device_is_available(node)) {\n\t\t\tdev_dbg(dev, \"Skipping disabled sub comp. %pOF\\n\",\n\t\t\t\tnode);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttype = (enum mdp_comp_type)(uintptr_t)of_id->data;\n\t\talias_id = mdp_comp_alias_id[type];\n\t\tid = mdp_comp_get_id(mdp, type, alias_id);\n\t\tif (id < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Fail to get sub comp. id: type %d alias %d\\n\",\n\t\t\t\ttype, alias_id);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_node;\n\t\t}\n\t\tmdp_comp_alias_id[type]++;\n\n\t\tcomp = mdp_comp_create(mdp, node, id);\n\t\tif (IS_ERR(comp)) {\n\t\t\tret = PTR_ERR(comp);\n\t\t\tgoto err_free_node;\n\t\t}\n\t}\n\treturn ret;\n\nerr_free_node:\n\tof_node_put(node);\n\treturn ret;\n}\n\nvoid mdp_comp_destroy(struct mdp_dev *mdp)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mdp->comp); i++) {\n\t\tif (mdp->comp[i]) {\n\t\t\tif (is_dma_capable(mdp->comp[i]->type))\n\t\t\t\tpm_runtime_disable(mdp->comp[i]->comp_dev);\n\t\t\tmdp_comp_deinit(mdp->comp[i]);\n\t\t\tdevm_kfree(mdp->comp[i]->comp_dev, mdp->comp[i]);\n\t\t\tmdp->comp[i] = NULL;\n\t\t}\n\t}\n}\n\nint mdp_comp_config(struct mdp_dev *mdp)\n{\n\tstruct device *dev = &mdp->pdev->dev;\n\tstruct device_node *node, *parent;\n\tint ret;\n\n\tmemset(mdp_comp_alias_id, 0, sizeof(mdp_comp_alias_id));\n\tp_id = mdp->mdp_data->mdp_plat_id;\n\n\tparent = dev->of_node->parent;\n\t \n\tfor_each_child_of_node(parent, node) {\n\t\tconst struct of_device_id *of_id;\n\t\tenum mdp_comp_type type;\n\t\tint id, alias_id;\n\t\tstruct mdp_comp *comp;\n\n\t\tof_id = of_match_node(mdp_comp_dt_ids, node);\n\t\tif (!of_id)\n\t\t\tcontinue;\n\n\t\tif (!of_device_is_available(node)) {\n\t\t\tdev_dbg(dev, \"Skipping disabled component %pOF\\n\",\n\t\t\t\tnode);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttype = (enum mdp_comp_type)(uintptr_t)of_id->data;\n\t\talias_id = mdp_comp_alias_id[type];\n\t\tid = mdp_comp_get_id(mdp, type, alias_id);\n\t\tif (id < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Fail to get component id: type %d alias %d\\n\",\n\t\t\t\ttype, alias_id);\n\t\t\tcontinue;\n\t\t}\n\t\tmdp_comp_alias_id[type]++;\n\n\t\tcomp = mdp_comp_create(mdp, node, id);\n\t\tif (IS_ERR(comp)) {\n\t\t\tret = PTR_ERR(comp);\n\t\t\tgoto err_init_comps;\n\t\t}\n\n\t\t \n\t\tif (!is_dma_capable(comp->type))\n\t\t\tcontinue;\n\t\tpm_runtime_enable(comp->comp_dev);\n\t}\n\n\tret = mdp_comp_sub_create(mdp);\n\tif (ret)\n\t\tgoto err_init_comps;\n\n\treturn 0;\n\nerr_init_comps:\n\tmdp_comp_destroy(mdp);\n\treturn ret;\n}\n\nint mdp_comp_ctx_config(struct mdp_dev *mdp, struct mdp_comp_ctx *ctx,\n\t\t\tconst struct img_compparam *param,\n\t\t\tconst struct img_ipi_frameparam *frame)\n{\n\tstruct device *dev = &mdp->pdev->dev;\n\tenum mtk_mdp_comp_id public_id = MDP_COMP_NONE;\n\tu32 arg;\n\tint i, idx;\n\n\tif (!param) {\n\t\tdev_err(dev, \"Invalid component param\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\targ = CFG_COMP(MT8183, param, type);\n\telse\n\t\treturn -EINVAL;\n\tpublic_id = mdp_cfg_get_id_public(mdp, arg);\n\tif (public_id < 0) {\n\t\tdev_err(dev, \"Invalid component id %d\", public_id);\n\t\treturn -EINVAL;\n\t}\n\n\tctx->comp = mdp->comp[public_id];\n\tif (!ctx->comp) {\n\t\tdev_err(dev, \"Uninit component inner id %d\", arg);\n\t\treturn -EINVAL;\n\t}\n\n\tctx->param = param;\n\tif (CFG_CHECK(MT8183, p_id))\n\t\targ = CFG_COMP(MT8183, param, input);\n\telse\n\t\treturn -EINVAL;\n\tctx->input = &frame->inputs[arg];\n\tif (CFG_CHECK(MT8183, p_id))\n\t\tidx = CFG_COMP(MT8183, param, num_outputs);\n\telse\n\t\treturn -EINVAL;\n\tfor (i = 0; i < idx; i++) {\n\t\tif (CFG_CHECK(MT8183, p_id))\n\t\t\targ = CFG_COMP(MT8183, param, outputs[i]);\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tctx->outputs[i] = &frame->outputs[arg];\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}