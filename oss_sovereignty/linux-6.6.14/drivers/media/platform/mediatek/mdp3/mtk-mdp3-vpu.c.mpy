{
  "module_name": "mtk-mdp3-vpu.c",
  "hash_id": "a878ce1977944b45d67923ec4a869aa545d23a3a9093fef40d36c7b5859b3370",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/mdp3/mtk-mdp3-vpu.c",
  "human_readable_source": "\n \n\n#include <linux/remoteproc.h>\n#include <linux/remoteproc/mtk_scp.h>\n#include \"mtk-mdp3-vpu.h\"\n#include \"mtk-mdp3-core.h\"\n\n#define MDP_VPU_MESSAGE_TIMEOUT 500U\n\nstatic inline struct mdp_dev *vpu_to_mdp(struct mdp_vpu_dev *vpu)\n{\n\treturn container_of(vpu, struct mdp_dev, vpu);\n}\n\nstatic int mdp_vpu_shared_mem_alloc(struct mdp_vpu_dev *vpu)\n{\n\tstruct device *dev;\n\n\tif (IS_ERR_OR_NULL(vpu))\n\t\tgoto err_return;\n\n\tdev = scp_get_device(vpu->scp);\n\n\tif (!vpu->param) {\n\t\tvpu->param = dma_alloc_wc(dev, vpu->param_size,\n\t\t\t\t\t  &vpu->param_addr, GFP_KERNEL);\n\t\tif (!vpu->param)\n\t\t\tgoto err_return;\n\t}\n\n\tif (!vpu->work) {\n\t\tvpu->work = dma_alloc_wc(dev, vpu->work_size,\n\t\t\t\t\t &vpu->work_addr, GFP_KERNEL);\n\t\tif (!vpu->work)\n\t\t\tgoto err_free_param;\n\t}\n\n\tif (!vpu->config) {\n\t\tvpu->config = dma_alloc_wc(dev, vpu->config_size,\n\t\t\t\t\t   &vpu->config_addr, GFP_KERNEL);\n\t\tif (!vpu->config)\n\t\t\tgoto err_free_work;\n\t}\n\n\treturn 0;\n\nerr_free_work:\n\tdma_free_wc(dev, vpu->work_size, vpu->work, vpu->work_addr);\n\tvpu->work = NULL;\nerr_free_param:\n\tdma_free_wc(dev, vpu->param_size, vpu->param, vpu->param_addr);\n\tvpu->param = NULL;\nerr_return:\n\treturn -ENOMEM;\n}\n\nvoid mdp_vpu_shared_mem_free(struct mdp_vpu_dev *vpu)\n{\n\tstruct device *dev;\n\n\tif (IS_ERR_OR_NULL(vpu))\n\t\treturn;\n\n\tdev = scp_get_device(vpu->scp);\n\n\tif (vpu->param && vpu->param_addr)\n\t\tdma_free_wc(dev, vpu->param_size, vpu->param, vpu->param_addr);\n\n\tif (vpu->work && vpu->work_addr)\n\t\tdma_free_wc(dev, vpu->work_size, vpu->work, vpu->work_addr);\n\n\tif (vpu->config && vpu->config_addr)\n\t\tdma_free_wc(dev, vpu->config_size, vpu->config, vpu->config_addr);\n}\n\nstatic void mdp_vpu_ipi_handle_init_ack(void *data, unsigned int len,\n\t\t\t\t\tvoid *priv)\n{\n\tstruct mdp_ipi_init_msg *msg = (struct mdp_ipi_init_msg *)data;\n\tstruct mdp_vpu_dev *vpu =\n\t\t(struct mdp_vpu_dev *)(unsigned long)msg->drv_data;\n\n\tif (!vpu->work_size)\n\t\tvpu->work_size = msg->work_size;\n\n\tvpu->status = msg->status;\n\tcomplete(&vpu->ipi_acked);\n}\n\nstatic void mdp_vpu_ipi_handle_deinit_ack(void *data, unsigned int len,\n\t\t\t\t\t  void *priv)\n{\n\tstruct mdp_ipi_deinit_msg *msg = (struct mdp_ipi_deinit_msg *)data;\n\tstruct mdp_vpu_dev *vpu =\n\t\t(struct mdp_vpu_dev *)(unsigned long)msg->drv_data;\n\n\tvpu->status = msg->status;\n\tcomplete(&vpu->ipi_acked);\n}\n\nstatic void mdp_vpu_ipi_handle_frame_ack(void *data, unsigned int len,\n\t\t\t\t\t void *priv)\n{\n\tstruct img_sw_addr *addr = (struct img_sw_addr *)data;\n\tstruct img_ipi_frameparam *param =\n\t\t(struct img_ipi_frameparam *)(unsigned long)addr->va;\n\tstruct mdp_vpu_dev *vpu =\n\t\t(struct mdp_vpu_dev *)(unsigned long)param->drv_data;\n\n\tif (param->state) {\n\t\tstruct mdp_dev *mdp = vpu_to_mdp(vpu);\n\n\t\tdev_err(&mdp->pdev->dev, \"VPU MDP failure:%d\\n\", param->state);\n\t}\n\tvpu->status = param->state;\n\tcomplete(&vpu->ipi_acked);\n}\n\nint mdp_vpu_register(struct mdp_dev *mdp)\n{\n\tint err;\n\tstruct mtk_scp *scp = mdp->scp;\n\tstruct device *dev = &mdp->pdev->dev;\n\n\terr = scp_ipi_register(scp, SCP_IPI_MDP_INIT,\n\t\t\t       mdp_vpu_ipi_handle_init_ack, NULL);\n\tif (err) {\n\t\tdev_err(dev, \"scp_ipi_register failed %d\\n\", err);\n\t\tgoto err_ipi_init;\n\t}\n\terr = scp_ipi_register(scp, SCP_IPI_MDP_DEINIT,\n\t\t\t       mdp_vpu_ipi_handle_deinit_ack, NULL);\n\tif (err) {\n\t\tdev_err(dev, \"scp_ipi_register failed %d\\n\", err);\n\t\tgoto err_ipi_deinit;\n\t}\n\terr = scp_ipi_register(scp, SCP_IPI_MDP_FRAME,\n\t\t\t       mdp_vpu_ipi_handle_frame_ack, NULL);\n\tif (err) {\n\t\tdev_err(dev, \"scp_ipi_register failed %d\\n\", err);\n\t\tgoto err_ipi_frame;\n\t}\n\treturn 0;\n\nerr_ipi_frame:\n\tscp_ipi_unregister(scp, SCP_IPI_MDP_DEINIT);\nerr_ipi_deinit:\n\tscp_ipi_unregister(scp, SCP_IPI_MDP_INIT);\nerr_ipi_init:\n\n\treturn err;\n}\n\nvoid mdp_vpu_unregister(struct mdp_dev *mdp)\n{\n\tscp_ipi_unregister(mdp->scp, SCP_IPI_MDP_INIT);\n\tscp_ipi_unregister(mdp->scp, SCP_IPI_MDP_DEINIT);\n\tscp_ipi_unregister(mdp->scp, SCP_IPI_MDP_FRAME);\n}\n\nstatic int mdp_vpu_sendmsg(struct mdp_vpu_dev *vpu, enum scp_ipi_id id,\n\t\t\t   void *buf, unsigned int len)\n{\n\tstruct mdp_dev *mdp = vpu_to_mdp(vpu);\n\tunsigned int t = MDP_VPU_MESSAGE_TIMEOUT;\n\tint ret;\n\n\tif (!vpu->scp) {\n\t\tdev_dbg(&mdp->pdev->dev, \"vpu scp is NULL\");\n\t\treturn -EINVAL;\n\t}\n\tret = scp_ipi_send(vpu->scp, id, buf, len, 2000);\n\n\tif (ret) {\n\t\tdev_err(&mdp->pdev->dev, \"scp_ipi_send failed %d\\n\", ret);\n\t\treturn -EPERM;\n\t}\n\tret = wait_for_completion_timeout(&vpu->ipi_acked,\n\t\t\t\t\t  msecs_to_jiffies(t));\n\tif (!ret)\n\t\tret = -ETIME;\n\telse if (vpu->status)\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\n\treturn ret;\n}\n\nint mdp_vpu_dev_init(struct mdp_vpu_dev *vpu, struct mtk_scp *scp,\n\t\t     struct mutex *lock)\n{\n\tstruct mdp_ipi_init_msg msg = {\n\t\t.drv_data = (unsigned long)vpu,\n\t};\n\tstruct mdp_dev *mdp = vpu_to_mdp(vpu);\n\tint err;\n\n\tinit_completion(&vpu->ipi_acked);\n\tvpu->scp = scp;\n\tvpu->lock = lock;\n\tvpu->work_size = 0;\n\terr = mdp_vpu_sendmsg(vpu, SCP_IPI_MDP_INIT, &msg, sizeof(msg));\n\tif (err)\n\t\tgoto err_work_size;\n\t \n\n\tmutex_lock(vpu->lock);\n\tvpu->work_size = ALIGN(vpu->work_size, 64);\n\tvpu->param_size = ALIGN(sizeof(struct img_ipi_frameparam), 64);\n\tvpu->config_size = ALIGN(sizeof(struct img_config), 64);\n\terr = mdp_vpu_shared_mem_alloc(vpu);\n\tmutex_unlock(vpu->lock);\n\tif (err) {\n\t\tdev_err(&mdp->pdev->dev, \"VPU memory alloc fail!\");\n\t\tgoto err_mem_alloc;\n\t}\n\n\tdev_dbg(&mdp->pdev->dev,\n\t\t\"VPU param:%pK pa:%pad sz:%zx, work:%pK pa:%pad sz:%zx, config:%pK pa:%pad sz:%zx\",\n\t\tvpu->param, &vpu->param_addr, vpu->param_size,\n\t\tvpu->work, &vpu->work_addr, vpu->work_size,\n\t\tvpu->config, &vpu->config_addr, vpu->config_size);\n\n\tmsg.work_addr = vpu->work_addr;\n\tmsg.work_size = vpu->work_size;\n\terr = mdp_vpu_sendmsg(vpu, SCP_IPI_MDP_INIT, &msg, sizeof(msg));\n\tif (err)\n\t\tgoto err_work_size;\n\n\treturn 0;\n\nerr_work_size:\n\tswitch (vpu->status) {\n\tcase -MDP_IPI_EBUSY:\n\t\terr = -EBUSY;\n\t\tbreak;\n\tcase -MDP_IPI_ENOMEM:\n\t\terr = -ENOSPC;\t \n\t\tbreak;\n\t}\n\treturn err;\nerr_mem_alloc:\n\treturn err;\n}\n\nint mdp_vpu_dev_deinit(struct mdp_vpu_dev *vpu)\n{\n\tstruct mdp_ipi_deinit_msg msg = {\n\t\t.drv_data = (unsigned long)vpu,\n\t\t.work_addr = vpu->work_addr,\n\t};\n\n\treturn mdp_vpu_sendmsg(vpu, SCP_IPI_MDP_DEINIT, &msg, sizeof(msg));\n}\n\nint mdp_vpu_process(struct mdp_vpu_dev *vpu, struct img_ipi_frameparam *param)\n{\n\tstruct mdp_dev *mdp = vpu_to_mdp(vpu);\n\tstruct img_sw_addr addr;\n\n\tmutex_lock(vpu->lock);\n\tif (mdp_vpu_shared_mem_alloc(vpu)) {\n\t\tdev_err(&mdp->pdev->dev, \"VPU memory alloc fail!\");\n\t\tmutex_unlock(vpu->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(vpu->param, 0, vpu->param_size);\n\tmemset(vpu->work, 0, vpu->work_size);\n\tmemset(vpu->config, 0, vpu->config_size);\n\n\tparam->self_data.va = (unsigned long)vpu->work;\n\tparam->self_data.pa = vpu->work_addr;\n\tparam->config_data.va = (unsigned long)vpu->config;\n\tparam->config_data.pa = vpu->config_addr;\n\tparam->drv_data = (unsigned long)vpu;\n\tmemcpy(vpu->param, param, sizeof(*param));\n\n\taddr.pa = vpu->param_addr;\n\taddr.va = (unsigned long)vpu->param;\n\tmutex_unlock(vpu->lock);\n\treturn mdp_vpu_sendmsg(vpu, SCP_IPI_MDP_FRAME, &addr, sizeof(addr));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}