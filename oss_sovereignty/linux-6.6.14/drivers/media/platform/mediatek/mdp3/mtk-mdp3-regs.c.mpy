{
  "module_name": "mtk-mdp3-regs.c",
  "hash_id": "89dbd1c6cf0d15b6594dba482d00dcc03180c0603aa792477952977fb038d131",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/mdp3/mtk-mdp3-regs.c",
  "human_readable_source": "\n \n\n#include <linux/math64.h>\n#include <media/v4l2-common.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n#include \"mtk-mdp3-core.h\"\n#include \"mtk-mdp3-regs.h\"\n#include \"mtk-mdp3-m2m.h\"\n\nstatic const struct mdp_format *mdp_find_fmt(const struct mtk_mdp_driver_data *mdp_data,\n\t\t\t\t\t     u32 pixelformat, u32 type)\n{\n\tu32 i, flag;\n\n\tflag = V4L2_TYPE_IS_OUTPUT(type) ? MDP_FMT_FLAG_OUTPUT :\n\t\t\t\t\tMDP_FMT_FLAG_CAPTURE;\n\tfor (i = 0; i < mdp_data->format_len; ++i) {\n\t\tif (!(mdp_data->format[i].flags & flag))\n\t\t\tcontinue;\n\t\tif (mdp_data->format[i].pixelformat == pixelformat)\n\t\t\treturn &mdp_data->format[i];\n\t}\n\treturn NULL;\n}\n\nstatic const struct mdp_format *mdp_find_fmt_by_index(const struct mtk_mdp_driver_data *mdp_data,\n\t\t\t\t\t\t      u32 index, u32 type)\n{\n\tu32 i, flag, num = 0;\n\n\tflag = V4L2_TYPE_IS_OUTPUT(type) ? MDP_FMT_FLAG_OUTPUT :\n\t\t\t\t\tMDP_FMT_FLAG_CAPTURE;\n\tfor (i = 0; i < mdp_data->format_len; ++i) {\n\t\tif (!(mdp_data->format[i].flags & flag))\n\t\t\tcontinue;\n\t\tif (index == num)\n\t\t\treturn &mdp_data->format[i];\n\t\tnum++;\n\t}\n\treturn NULL;\n}\n\nenum mdp_ycbcr_profile mdp_map_ycbcr_prof_mplane(struct v4l2_format *f,\n\t\t\t\t\t\t u32 mdp_color)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\n\tif (MDP_COLOR_IS_RGB(mdp_color))\n\t\treturn MDP_YCBCR_PROFILE_FULL_BT601;\n\n\tswitch (pix_mp->colorspace) {\n\tcase V4L2_COLORSPACE_JPEG:\n\t\treturn MDP_YCBCR_PROFILE_JPEG;\n\tcase V4L2_COLORSPACE_REC709:\n\tcase V4L2_COLORSPACE_DCI_P3:\n\t\tif (pix_mp->quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\treturn MDP_YCBCR_PROFILE_FULL_BT709;\n\t\treturn MDP_YCBCR_PROFILE_BT709;\n\tcase V4L2_COLORSPACE_BT2020:\n\t\tif (pix_mp->quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\treturn MDP_YCBCR_PROFILE_FULL_BT2020;\n\t\treturn MDP_YCBCR_PROFILE_BT2020;\n\tdefault:\n\t\tif (pix_mp->quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\treturn MDP_YCBCR_PROFILE_FULL_BT601;\n\t\treturn MDP_YCBCR_PROFILE_BT601;\n\t}\n}\n\nstatic void mdp_bound_align_image(u32 *w, u32 *h,\n\t\t\t\t  struct v4l2_frmsize_stepwise *s,\n\t\t\t\t  unsigned int salign)\n{\n\tunsigned int org_w, org_h;\n\n\torg_w = *w;\n\torg_h = *h;\n\tv4l_bound_align_image(w, s->min_width, s->max_width, s->step_width,\n\t\t\t      h, s->min_height, s->max_height, s->step_height,\n\t\t\t      salign);\n\n\ts->min_width = org_w;\n\ts->min_height = org_h;\n\tv4l2_apply_frmsize_constraints(w, h, s);\n}\n\nstatic int mdp_clamp_align(s32 *x, int min, int max, unsigned int align)\n{\n\tunsigned int mask;\n\n\tif (min < 0 || max < 0)\n\t\treturn -ERANGE;\n\n\t \n\tmask = ~((1 << align) - 1);\n\n\tmin = 0 ? 0 : ((min + ~mask) & mask);\n\tmax = max & mask;\n\tif ((unsigned int)min > (unsigned int)max)\n\t\treturn -ERANGE;\n\n\t \n\t*x = clamp(*x, min, max);\n\n\t \n\tif (align)\n\t\t*x = (*x + (1 << (align - 1))) & mask;\n\treturn 0;\n}\n\nint mdp_enum_fmt_mplane(struct mdp_dev *mdp, struct v4l2_fmtdesc *f)\n{\n\tconst struct mdp_format *fmt;\n\n\tfmt = mdp_find_fmt_by_index(mdp->mdp_data, f->index, f->type);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = fmt->pixelformat;\n\treturn 0;\n}\n\nconst struct mdp_format *mdp_try_fmt_mplane(struct mdp_dev *mdp,\n\t\t\t\t\t    struct v4l2_format *f,\n\t\t\t\t\t    struct mdp_frameparam *param,\n\t\t\t\t\t    u32 ctx_id)\n{\n\tstruct device *dev = &param->ctx->mdp_dev->pdev->dev;\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tconst struct mdp_format *fmt;\n\tconst struct mdp_pix_limit *pix_limit;\n\tstruct v4l2_frmsize_stepwise s;\n\tu32 org_w, org_h;\n\tunsigned int i;\n\n\tfmt = mdp_find_fmt(mdp->mdp_data, pix_mp->pixelformat, f->type);\n\tif (!fmt) {\n\t\tfmt = mdp_find_fmt_by_index(mdp->mdp_data, 0, f->type);\n\t\tif (!fmt) {\n\t\t\tdev_dbg(dev, \"%d: pixelformat %c%c%c%c invalid\", ctx_id,\n\t\t\t\t(pix_mp->pixelformat & 0xff),\n\t\t\t\t(pix_mp->pixelformat >>  8) & 0xff,\n\t\t\t\t(pix_mp->pixelformat >> 16) & 0xff,\n\t\t\t\t(pix_mp->pixelformat >> 24) & 0xff);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tpix_mp->field = V4L2_FIELD_NONE;\n\tpix_mp->flags = 0;\n\tpix_mp->pixelformat = fmt->pixelformat;\n\tif (V4L2_TYPE_IS_CAPTURE(f->type)) {\n\t\tpix_mp->colorspace = param->colorspace;\n\t\tpix_mp->xfer_func = param->xfer_func;\n\t\tpix_mp->ycbcr_enc = param->ycbcr_enc;\n\t\tpix_mp->quantization = param->quant;\n\t}\n\n\tpix_limit = V4L2_TYPE_IS_OUTPUT(f->type) ? &param->limit->out_limit :\n\t\t\t\t\t\t&param->limit->cap_limit;\n\ts.min_width = pix_limit->wmin;\n\ts.max_width = pix_limit->wmax;\n\ts.step_width = fmt->walign;\n\ts.min_height = pix_limit->hmin;\n\ts.max_height = pix_limit->hmax;\n\ts.step_height = fmt->halign;\n\torg_w = pix_mp->width;\n\torg_h = pix_mp->height;\n\n\tmdp_bound_align_image(&pix_mp->width, &pix_mp->height, &s, fmt->salign);\n\tif (org_w != pix_mp->width || org_h != pix_mp->height)\n\t\tdev_dbg(dev, \"%d: size change: %ux%u to %ux%u\", ctx_id,\n\t\t\torg_w, org_h, pix_mp->width, pix_mp->height);\n\n\tif (pix_mp->num_planes && pix_mp->num_planes != fmt->num_planes)\n\t\tdev_dbg(dev, \"%d num of planes change: %u to %u\", ctx_id,\n\t\t\tpix_mp->num_planes, fmt->num_planes);\n\tpix_mp->num_planes = fmt->num_planes;\n\n\tfor (i = 0; i < pix_mp->num_planes; ++i) {\n\t\tu32 min_bpl = (pix_mp->width * fmt->row_depth[i]) >> 3;\n\t\tu32 max_bpl = (pix_limit->wmax * fmt->row_depth[i]) >> 3;\n\t\tu32 bpl = pix_mp->plane_fmt[i].bytesperline;\n\t\tu32 min_si, max_si;\n\t\tu32 si = pix_mp->plane_fmt[i].sizeimage;\n\t\tu64 di;\n\n\t\tbpl = clamp(bpl, min_bpl, max_bpl);\n\t\tpix_mp->plane_fmt[i].bytesperline = bpl;\n\n\t\tdi = (u64)bpl * pix_mp->height * fmt->depth[i];\n\t\tmin_si = (u32)div_u64(di, fmt->row_depth[i]);\n\t\tdi = (u64)bpl * s.max_height * fmt->depth[i];\n\t\tmax_si = (u32)div_u64(di, fmt->row_depth[i]);\n\n\t\tsi = clamp(si, min_si, max_si);\n\t\tpix_mp->plane_fmt[i].sizeimage = si;\n\n\t\tdev_dbg(dev, \"%d: p%u, bpl:%u [%u, %u], sizeimage:%u [%u, %u]\",\n\t\t\tctx_id, i, bpl, min_bpl, max_bpl, si, min_si, max_si);\n\t}\n\n\treturn fmt;\n}\n\nstatic int mdp_clamp_start(s32 *x, int min, int max, unsigned int align,\n\t\t\t   u32 flags)\n{\n\tif (flags & V4L2_SEL_FLAG_GE)\n\t\tmax = *x;\n\tif (flags & V4L2_SEL_FLAG_LE)\n\t\tmin = *x;\n\treturn mdp_clamp_align(x, min, max, align);\n}\n\nstatic int mdp_clamp_end(s32 *x, int min, int max, unsigned int align,\n\t\t\t u32 flags)\n{\n\tif (flags & V4L2_SEL_FLAG_GE)\n\t\tmin = *x;\n\tif (flags & V4L2_SEL_FLAG_LE)\n\t\tmax = *x;\n\treturn mdp_clamp_align(x, min, max, align);\n}\n\nint mdp_try_crop(struct mdp_m2m_ctx *ctx, struct v4l2_rect *r,\n\t\t const struct v4l2_selection *s, struct mdp_frame *frame)\n{\n\tstruct device *dev = &ctx->mdp_dev->pdev->dev;\n\ts32 left, top, right, bottom;\n\tu32 framew, frameh, walign, halign;\n\tint ret;\n\n\tdev_dbg(dev, \"%d target:%d, set:(%d,%d) %ux%u\", ctx->id,\n\t\ts->target, s->r.left, s->r.top, s->r.width, s->r.height);\n\n\tleft = s->r.left;\n\ttop = s->r.top;\n\tright = s->r.left + s->r.width;\n\tbottom = s->r.top + s->r.height;\n\tframew = frame->format.fmt.pix_mp.width;\n\tframeh = frame->format.fmt.pix_mp.height;\n\n\tif (mdp_target_is_crop(s->target)) {\n\t\twalign = 1;\n\t\thalign = 1;\n\t} else {\n\t\twalign = frame->mdp_fmt->walign;\n\t\thalign = frame->mdp_fmt->halign;\n\t}\n\n\tdev_dbg(dev, \"%d align:%u,%u, bound:%ux%u\", ctx->id,\n\t\twalign, halign, framew, frameh);\n\n\tret = mdp_clamp_start(&left, 0, right, walign, s->flags);\n\tif (ret)\n\t\treturn ret;\n\tret = mdp_clamp_start(&top, 0, bottom, halign, s->flags);\n\tif (ret)\n\t\treturn ret;\n\tret = mdp_clamp_end(&right, left, framew, walign, s->flags);\n\tif (ret)\n\t\treturn ret;\n\tret = mdp_clamp_end(&bottom, top, frameh, halign, s->flags);\n\tif (ret)\n\t\treturn ret;\n\n\tr->left = left;\n\tr->top = top;\n\tr->width = right - left;\n\tr->height = bottom - top;\n\n\tdev_dbg(dev, \"%d crop:(%d,%d) %ux%u\", ctx->id,\n\t\tr->left, r->top, r->width, r->height);\n\treturn 0;\n}\n\nint mdp_check_scaling_ratio(const struct v4l2_rect *crop,\n\t\t\t    const struct v4l2_rect *compose, s32 rotation,\n\tconst struct mdp_limit *limit)\n{\n\tu32 crop_w, crop_h, comp_w, comp_h;\n\n\tcrop_w = crop->width;\n\tcrop_h = crop->height;\n\tif (90 == rotation || 270 == rotation) {\n\t\tcomp_w = compose->height;\n\t\tcomp_h = compose->width;\n\t} else {\n\t\tcomp_w = compose->width;\n\t\tcomp_h = compose->height;\n\t}\n\n\tif ((crop_w / comp_w) > limit->h_scale_down_max ||\n\t    (crop_h / comp_h) > limit->v_scale_down_max ||\n\t    (comp_w / crop_w) > limit->h_scale_up_max ||\n\t    (comp_h / crop_h) > limit->v_scale_up_max)\n\t\treturn -ERANGE;\n\treturn 0;\n}\n\n \nstatic u32 mdp_fmt_get_stride(const struct mdp_format *fmt,\n\t\t\t      u32 bytesperline, unsigned int plane)\n{\n\tenum mdp_color c = fmt->mdp_color;\n\tu32 stride;\n\n\tstride = (bytesperline * MDP_COLOR_BITS_PER_PIXEL(c))\n\t\t/ fmt->row_depth[0];\n\tif (plane == 0)\n\t\treturn stride;\n\tif (plane < MDP_COLOR_GET_PLANE_COUNT(c)) {\n\t\tif (MDP_COLOR_IS_BLOCK_MODE(c))\n\t\t\tstride = stride / 2;\n\t\treturn stride;\n\t}\n\treturn 0;\n}\n\n \nstatic u32 mdp_fmt_get_stride_contig(const struct mdp_format *fmt,\n\t\t\t\t     u32 pix_stride, unsigned int plane)\n{\n\tenum mdp_color c = fmt->mdp_color;\n\tu32 stride = pix_stride;\n\n\tif (plane == 0)\n\t\treturn stride;\n\tif (plane < MDP_COLOR_GET_PLANE_COUNT(c)) {\n\t\tstride = stride >> MDP_COLOR_GET_H_SUBSAMPLE(c);\n\t\tif (MDP_COLOR_IS_UV_COPLANE(c) && !MDP_COLOR_IS_BLOCK_MODE(c))\n\t\t\tstride = stride * 2;\n\t\treturn stride;\n\t}\n\treturn 0;\n}\n\n \nstatic u32 mdp_fmt_get_plane_size(const struct mdp_format *fmt,\n\t\t\t\t  u32 stride, u32 height, unsigned int plane)\n{\n\tenum mdp_color c = fmt->mdp_color;\n\tu32 bytesperline;\n\n\tbytesperline = (stride * fmt->row_depth[0])\n\t\t/ MDP_COLOR_BITS_PER_PIXEL(c);\n\tif (plane == 0)\n\t\treturn bytesperline * height;\n\tif (plane < MDP_COLOR_GET_PLANE_COUNT(c)) {\n\t\theight = height >> MDP_COLOR_GET_V_SUBSAMPLE(c);\n\t\tif (MDP_COLOR_IS_BLOCK_MODE(c))\n\t\t\tbytesperline = bytesperline * 2;\n\t\treturn bytesperline * height;\n\t}\n\treturn 0;\n}\n\nstatic void mdp_prepare_buffer(struct img_image_buffer *b,\n\t\t\t       struct mdp_frame *frame, struct vb2_buffer *vb)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &frame->format.fmt.pix_mp;\n\tunsigned int i;\n\n\tb->format.colorformat = frame->mdp_fmt->mdp_color;\n\tb->format.ycbcr_prof = frame->ycbcr_prof;\n\tfor (i = 0; i < pix_mp->num_planes; ++i) {\n\t\tu32 stride = mdp_fmt_get_stride(frame->mdp_fmt,\n\t\t\tpix_mp->plane_fmt[i].bytesperline, i);\n\n\t\tb->format.plane_fmt[i].stride = stride;\n\t\tb->format.plane_fmt[i].size =\n\t\t\tmdp_fmt_get_plane_size(frame->mdp_fmt, stride,\n\t\t\t\t\t       pix_mp->height, i);\n\t\tb->iova[i] = vb2_dma_contig_plane_dma_addr(vb, i);\n\t}\n\tfor (; i < MDP_COLOR_GET_PLANE_COUNT(b->format.colorformat); ++i) {\n\t\tu32 stride = mdp_fmt_get_stride_contig(frame->mdp_fmt,\n\t\t\tb->format.plane_fmt[0].stride, i);\n\n\t\tb->format.plane_fmt[i].stride = stride;\n\t\tb->format.plane_fmt[i].size =\n\t\t\tmdp_fmt_get_plane_size(frame->mdp_fmt, stride,\n\t\t\t\t\t       pix_mp->height, i);\n\t\tb->iova[i] = b->iova[i - 1] + b->format.plane_fmt[i - 1].size;\n\t}\n\tb->usage = frame->usage;\n}\n\nvoid mdp_set_src_config(struct img_input *in,\n\t\t\tstruct mdp_frame *frame, struct vb2_buffer *vb)\n{\n\tin->buffer.format.width = frame->format.fmt.pix_mp.width;\n\tin->buffer.format.height = frame->format.fmt.pix_mp.height;\n\tmdp_prepare_buffer(&in->buffer, frame, vb);\n}\n\nstatic u32 mdp_to_fixed(u32 *r, struct v4l2_fract *f)\n{\n\tu32 q;\n\n\tif (f->denominator == 0) {\n\t\t*r = 0;\n\t\treturn 0;\n\t}\n\n\tq = f->numerator / f->denominator;\n\t*r = div_u64(((u64)f->numerator - q * f->denominator) <<\n\t\t     IMG_SUBPIXEL_SHIFT, f->denominator);\n\treturn q;\n}\n\nstatic void mdp_set_src_crop(struct img_crop *c, struct mdp_crop *crop)\n{\n\tc->left = crop->c.left\n\t\t+ mdp_to_fixed(&c->left_subpix, &crop->left_subpix);\n\tc->top = crop->c.top\n\t\t+ mdp_to_fixed(&c->top_subpix, &crop->top_subpix);\n\tc->width = crop->c.width\n\t\t+ mdp_to_fixed(&c->width_subpix, &crop->width_subpix);\n\tc->height = crop->c.height\n\t\t+ mdp_to_fixed(&c->height_subpix, &crop->height_subpix);\n}\n\nstatic void mdp_set_orientation(struct img_output *out,\n\t\t\t\ts32 rotation, bool hflip, bool vflip)\n{\n\tu8 flip = 0;\n\n\tif (hflip)\n\t\tflip ^= 1;\n\tif (vflip) {\n\t\t \n\t\trotation += 180;\n\t\tflip ^= 1;\n\t}\n\n\tout->rotation = rotation % 360;\n\tif (flip != 0)\n\t\tout->flags |= IMG_CTRL_FLAG_HFLIP;\n\telse\n\t\tout->flags &= ~IMG_CTRL_FLAG_HFLIP;\n}\n\nvoid mdp_set_dst_config(struct img_output *out,\n\t\t\tstruct mdp_frame *frame, struct vb2_buffer *vb)\n{\n\tout->buffer.format.width = frame->compose.width;\n\tout->buffer.format.height = frame->compose.height;\n\tmdp_prepare_buffer(&out->buffer, frame, vb);\n\tmdp_set_src_crop(&out->crop, &frame->crop);\n\tmdp_set_orientation(out, frame->rotation, frame->hflip, frame->vflip);\n}\n\nint mdp_frameparam_init(struct mdp_dev *mdp, struct mdp_frameparam *param)\n{\n\tstruct mdp_frame *frame;\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&param->list);\n\tparam->limit = mdp->mdp_data->def_limit;\n\tparam->type = MDP_STREAM_TYPE_BITBLT;\n\n\tframe = &param->output;\n\tframe->format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tframe->mdp_fmt = mdp_try_fmt_mplane(mdp, &frame->format, param, 0);\n\tframe->ycbcr_prof =\n\t\tmdp_map_ycbcr_prof_mplane(&frame->format,\n\t\t\t\t\t  frame->mdp_fmt->mdp_color);\n\tframe->usage = MDP_BUFFER_USAGE_HW_READ;\n\n\tparam->num_captures = 1;\n\tframe = &param->captures[0];\n\tframe->format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tframe->mdp_fmt = mdp_try_fmt_mplane(mdp, &frame->format, param, 0);\n\tframe->ycbcr_prof =\n\t\tmdp_map_ycbcr_prof_mplane(&frame->format,\n\t\t\t\t\t  frame->mdp_fmt->mdp_color);\n\tframe->usage = MDP_BUFFER_USAGE_MDP;\n\tframe->crop.c.width = param->output.format.fmt.pix_mp.width;\n\tframe->crop.c.height = param->output.format.fmt.pix_mp.height;\n\tframe->compose.width = frame->format.fmt.pix_mp.width;\n\tframe->compose.height = frame->format.fmt.pix_mp.height;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}