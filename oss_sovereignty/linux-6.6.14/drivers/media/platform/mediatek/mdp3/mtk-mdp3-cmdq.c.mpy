{
  "module_name": "mtk-mdp3-cmdq.c",
  "hash_id": "f332c085aedf5ea807ad53035cce420cb87aa7e1828626e5808ee6cf6352ccfa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/mdp3/mtk-mdp3-cmdq.c",
  "human_readable_source": "\n \n\n#include <linux/mailbox_controller.h>\n#include <linux/platform_device.h>\n#include \"mtk-mdp3-cmdq.h\"\n#include \"mtk-mdp3-comp.h\"\n#include \"mtk-mdp3-core.h\"\n#include \"mtk-mdp3-m2m.h\"\n#include \"mtk-img-ipi.h\"\n\n#define MDP_PATH_MAX_COMPS\tIMG_MAX_COMPONENTS\n\nstruct mdp_path {\n\tstruct mdp_dev\t\t*mdp_dev;\n\tstruct mdp_comp_ctx\tcomps[MDP_PATH_MAX_COMPS];\n\tu32\t\t\tnum_comps;\n\tconst struct img_config\t*config;\n\tconst struct img_ipi_frameparam *param;\n\tconst struct v4l2_rect\t*composes[IMG_MAX_HW_OUTPUTS];\n\tstruct v4l2_rect\tbounds[IMG_MAX_HW_OUTPUTS];\n};\n\n#define has_op(ctx, op) \\\n\t((ctx)->comp->ops && (ctx)->comp->ops->op)\n #define call_op(ctx, op, ...) \\\n\t(has_op(ctx, op) ? (ctx)->comp->ops->op(ctx, ##__VA_ARGS__) : 0)\n\nstatic bool is_output_disabled(int p_id, const struct img_compparam *param, u32 count)\n{\n\tu32 num = 0;\n\tbool dis_output = false;\n\tbool dis_tile = false;\n\n\tif (CFG_CHECK(MT8183, p_id)) {\n\t\tnum = CFG_COMP(MT8183, param, num_subfrms);\n\t\tdis_output = CFG_COMP(MT8183, param, frame.output_disable);\n\t\tdis_tile = CFG_COMP(MT8183, param, frame.output_disable);\n\t}\n\n\treturn (count < num) ? (dis_output || dis_tile) : true;\n}\n\nstatic int mdp_path_subfrm_require(const struct mdp_path *path,\n\t\t\t\t   struct mdp_cmdq_cmd *cmd,\n\t\t\t\t   s32 *mutex_id, u32 count)\n{\n\tconst int p_id = path->mdp_dev->mdp_data->mdp_plat_id;\n\tconst struct mdp_comp_ctx *ctx;\n\tconst struct mtk_mdp_driver_data *data = path->mdp_dev->mdp_data;\n\tstruct device *dev = &path->mdp_dev->pdev->dev;\n\tstruct mtk_mutex **mutex = path->mdp_dev->mdp_mutex;\n\tint id, index;\n\tu32 num_comp = 0;\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\tnum_comp = CFG_GET(MT8183, path->config, num_components);\n\n\t \n\tswitch (path->comps[0].comp->public_id) {\n\tcase MDP_COMP_RDMA0:\n\t\tindex = MDP_PIPE_RDMA0;\n\t\tbreak;\n\tcase MDP_COMP_ISP_IMGI:\n\t\tindex = MDP_PIPE_IMGI;\n\t\tbreak;\n\tcase MDP_COMP_WPEI:\n\t\tindex = MDP_PIPE_WPEI;\n\t\tbreak;\n\tcase MDP_COMP_WPEI2:\n\t\tindex = MDP_PIPE_WPEI2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unknown pipeline and no mutex is assigned\");\n\t\treturn -EINVAL;\n\t}\n\t*mutex_id = data->pipe_info[index].mutex_id;\n\n\t \n\tfor (index = 0; index < num_comp; index++) {\n\t\tctx = &path->comps[index];\n\t\tif (is_output_disabled(p_id, ctx->param, count))\n\t\t\tcontinue;\n\t\tid = ctx->comp->public_id;\n\t\tmtk_mutex_write_mod(mutex[*mutex_id],\n\t\t\t\t    data->mdp_mutex_table_idx[id], false);\n\t}\n\n\tmtk_mutex_write_sof(mutex[*mutex_id],\n\t\t\t    MUTEX_SOF_IDX_SINGLE_MODE);\n\n\treturn 0;\n}\n\nstatic int mdp_path_subfrm_run(const struct mdp_path *path,\n\t\t\t       struct mdp_cmdq_cmd *cmd,\n\t\t\t       s32 *mutex_id, u32 count)\n{\n\tconst int p_id = path->mdp_dev->mdp_data->mdp_plat_id;\n\tconst struct mdp_comp_ctx *ctx;\n\tstruct device *dev = &path->mdp_dev->pdev->dev;\n\tstruct mtk_mutex **mutex = path->mdp_dev->mdp_mutex;\n\tint index;\n\tu32 num_comp = 0;\n\ts32 event;\n\n\tif (-1 == *mutex_id) {\n\t\tdev_err(dev, \"Incorrect mutex id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\tnum_comp = CFG_GET(MT8183, path->config, num_components);\n\n\t \n\t \n\tfor (index = 0; index < num_comp; index++) {\n\t\tctx = &path->comps[index];\n\t\tif (is_output_disabled(p_id, ctx->param, count))\n\t\t\tcontinue;\n\t\tevent = ctx->comp->gce_event[MDP_GCE_EVENT_SOF];\n\t\tif (event != MDP_GCE_NO_EVENT)\n\t\t\tMM_REG_CLEAR(cmd, event);\n\t}\n\n\t \n\tmtk_mutex_enable_by_cmdq(mutex[*mutex_id], (void *)&cmd->pkt);\n\n\t \n\tfor (index = 0; index < num_comp; index++) {\n\t\tctx = &path->comps[index];\n\t\tif (is_output_disabled(p_id, ctx->param, count))\n\t\t\tcontinue;\n\t\tevent = ctx->comp->gce_event[MDP_GCE_EVENT_SOF];\n\t\tif (event != MDP_GCE_NO_EVENT)\n\t\t\tMM_REG_WAIT(cmd, event);\n\t}\n\n\treturn 0;\n}\n\nstatic int mdp_path_ctx_init(struct mdp_dev *mdp, struct mdp_path *path)\n{\n\tconst int p_id = mdp->mdp_data->mdp_plat_id;\n\tvoid *param = NULL;\n\tint index, ret;\n\tu32 num_comp = 0;\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\tnum_comp = CFG_GET(MT8183, path->config, num_components);\n\n\tif (num_comp < 1)\n\t\treturn -EINVAL;\n\n\tfor (index = 0; index < num_comp; index++) {\n\t\tif (CFG_CHECK(MT8183, p_id))\n\t\t\tparam = (void *)CFG_ADDR(MT8183, path->config, components[index]);\n\t\tret = mdp_comp_ctx_config(mdp, &path->comps[index],\n\t\t\t\t\t  param, path->param);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mdp_path_config_subfrm(struct mdp_cmdq_cmd *cmd,\n\t\t\t\t  struct mdp_path *path, u32 count)\n{\n\tconst int p_id = path->mdp_dev->mdp_data->mdp_plat_id;\n\tconst struct img_mmsys_ctrl *ctrl = NULL;\n\tconst struct img_mux *set;\n\tstruct mdp_comp_ctx *ctx;\n\ts32 mutex_id;\n\tint index, ret;\n\tu32 num_comp = 0;\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\tnum_comp = CFG_GET(MT8183, path->config, num_components);\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\tctrl = CFG_ADDR(MT8183, path->config, ctrls[count]);\n\n\t \n\tret = mdp_path_subfrm_require(path, cmd, &mutex_id, count);\n\tif (ret)\n\t\treturn ret;\n\t \n\tfor (index = 0; index < ctrl->num_sets; index++) {\n\t\tset = &ctrl->sets[index];\n\t\tcmdq_pkt_write_mask(&cmd->pkt, set->subsys_id, set->reg,\n\t\t\t\t    set->value, 0xFFFFFFFF);\n\t}\n\t \n\tfor (index = (num_comp - 1); index >= 0; index--) {\n\t\tctx = &path->comps[index];\n\t\tif (is_output_disabled(p_id, ctx->param, count))\n\t\t\tcontinue;\n\t\tret = call_op(ctx, config_subfrm, cmd, count);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\t \n\tret = mdp_path_subfrm_run(path, cmd, &mutex_id, count);\n\tif (ret)\n\t\treturn ret;\n\t \n\tfor (index = 0; index < num_comp; index++) {\n\t\tctx = &path->comps[index];\n\t\tif (is_output_disabled(p_id, ctx->param, count))\n\t\t\tcontinue;\n\t\tret = call_op(ctx, wait_comp_event, cmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\t \n\tfor (index = 0; index < num_comp; index++) {\n\t\tctx = &path->comps[index];\n\t\tret = call_op(ctx, advance_subfrm, cmd, count);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\t \n\tfor (index = 0; index < ctrl->num_sets; index++) {\n\t\tset = &ctrl->sets[index];\n\t\tcmdq_pkt_write_mask(&cmd->pkt, set->subsys_id, set->reg,\n\t\t\t\t    0, 0xFFFFFFFF);\n\t}\n\n\treturn 0;\n}\n\nstatic int mdp_path_config(struct mdp_dev *mdp, struct mdp_cmdq_cmd *cmd,\n\t\t\t   struct mdp_path *path)\n{\n\tconst int p_id = mdp->mdp_data->mdp_plat_id;\n\tstruct mdp_comp_ctx *ctx;\n\tint index, count, ret;\n\tu32 num_comp = 0;\n\tu32 num_sub = 0;\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\tnum_comp = CFG_GET(MT8183, path->config, num_components);\n\n\tif (CFG_CHECK(MT8183, p_id))\n\t\tnum_sub = CFG_GET(MT8183, path->config, num_subfrms);\n\n\t \n\t \n\tfor (index = 0; index < num_comp; index++) {\n\t\tctx = &path->comps[index];\n\t\tret = call_op(ctx, init_comp, cmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\t \n\tfor (index = 0; index < num_comp; index++) {\n\t\tconst struct v4l2_rect *compose;\n\t\tu32 out = 0;\n\n\t\tctx = &path->comps[index];\n\t\tif (CFG_CHECK(MT8183, p_id))\n\t\t\tout = CFG_COMP(MT8183, ctx->param, outputs[0]);\n\n\t\tcompose = path->composes[out];\n\t\tret = call_op(ctx, config_frame, cmd, compose);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (count = 0; count < num_sub; count++) {\n\t\tret = mdp_path_config_subfrm(cmd, path, count);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\t \n\tfor (index = 0; index < num_comp; index++) {\n\t\tctx = &path->comps[index];\n\t\tret = call_op(ctx, post_process, cmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int mdp_cmdq_pkt_create(struct cmdq_client *client, struct cmdq_pkt *pkt,\n\t\t\t       size_t size)\n{\n\tstruct device *dev;\n\tdma_addr_t dma_addr;\n\n\tpkt->va_base = kzalloc(size, GFP_KERNEL);\n\tif (!pkt->va_base)\n\t\treturn -ENOMEM;\n\n\tpkt->buf_size = size;\n\tpkt->cl = (void *)client;\n\n\tdev = client->chan->mbox->dev;\n\tdma_addr = dma_map_single(dev, pkt->va_base, pkt->buf_size,\n\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, dma_addr)) {\n\t\tdev_err(dev, \"dma map failed, size=%u\\n\", (u32)(u64)size);\n\t\tkfree(pkt->va_base);\n\t\treturn -ENOMEM;\n\t}\n\n\tpkt->pa_base = dma_addr;\n\n\treturn 0;\n}\n\nstatic void mdp_cmdq_pkt_destroy(struct cmdq_pkt *pkt)\n{\n\tstruct cmdq_client *client = (struct cmdq_client *)pkt->cl;\n\n\tdma_unmap_single(client->chan->mbox->dev, pkt->pa_base, pkt->buf_size,\n\t\t\t DMA_TO_DEVICE);\n\tkfree(pkt->va_base);\n\tpkt->va_base = NULL;\n}\n\nstatic void mdp_auto_release_work(struct work_struct *work)\n{\n\tstruct mdp_cmdq_cmd *cmd;\n\tstruct mdp_dev *mdp;\n\tint id;\n\n\tcmd = container_of(work, struct mdp_cmdq_cmd, auto_release_work);\n\tmdp = cmd->mdp;\n\n\tid = mdp->mdp_data->pipe_info[MDP_PIPE_RDMA0].mutex_id;\n\tmtk_mutex_unprepare(mdp->mdp_mutex[id]);\n\tmdp_comp_clocks_off(&mdp->pdev->dev, cmd->comps,\n\t\t\t    cmd->num_comps);\n\n\tatomic_dec(&mdp->job_count);\n\twake_up(&mdp->callback_wq);\n\n\tmdp_cmdq_pkt_destroy(&cmd->pkt);\n\tkfree(cmd->comps);\n\tcmd->comps = NULL;\n\tkfree(cmd);\n\tcmd = NULL;\n}\n\nstatic void mdp_handle_cmdq_callback(struct mbox_client *cl, void *mssg)\n{\n\tstruct mdp_cmdq_cmd *cmd;\n\tstruct cmdq_cb_data *data;\n\tstruct mdp_dev *mdp;\n\tstruct device *dev;\n\tint id;\n\n\tif (!mssg) {\n\t\tpr_info(\"%s:no callback data\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdata = (struct cmdq_cb_data *)mssg;\n\tcmd = container_of(data->pkt, struct mdp_cmdq_cmd, pkt);\n\tmdp = cmd->mdp;\n\tdev = &mdp->pdev->dev;\n\n\tif (cmd->mdp_ctx)\n\t\tmdp_m2m_job_finish(cmd->mdp_ctx);\n\n\tif (cmd->user_cmdq_cb) {\n\t\tstruct cmdq_cb_data user_cb_data;\n\n\t\tuser_cb_data.sta = data->sta;\n\t\tuser_cb_data.pkt = data->pkt;\n\t\tcmd->user_cmdq_cb(user_cb_data);\n\t}\n\n\tINIT_WORK(&cmd->auto_release_work, mdp_auto_release_work);\n\tif (!queue_work(mdp->clock_wq, &cmd->auto_release_work)) {\n\t\tdev_err(dev, \"%s:queue_work fail!\\n\", __func__);\n\t\tid = mdp->mdp_data->pipe_info[MDP_PIPE_RDMA0].mutex_id;\n\t\tmtk_mutex_unprepare(mdp->mdp_mutex[id]);\n\t\tmdp_comp_clocks_off(&mdp->pdev->dev, cmd->comps,\n\t\t\t\t    cmd->num_comps);\n\n\t\tatomic_dec(&mdp->job_count);\n\t\twake_up(&mdp->callback_wq);\n\n\t\tmdp_cmdq_pkt_destroy(&cmd->pkt);\n\t\tkfree(cmd->comps);\n\t\tcmd->comps = NULL;\n\t\tkfree(cmd);\n\t\tcmd = NULL;\n\t}\n}\n\nint mdp_cmdq_send(struct mdp_dev *mdp, struct mdp_cmdq_param *param)\n{\n\tstruct mdp_path *path = NULL;\n\tstruct mdp_cmdq_cmd *cmd = NULL;\n\tstruct mdp_comp *comps = NULL;\n\tstruct device *dev = &mdp->pdev->dev;\n\tconst int p_id = mdp->mdp_data->mdp_plat_id;\n\tint i, ret;\n\tu32 num_comp = 0;\n\n\tatomic_inc(&mdp->job_count);\n\tif (atomic_read(&mdp->suspended)) {\n\t\tatomic_dec(&mdp->job_count);\n\t\treturn -ECANCELED;\n\t}\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto err_cancel_job;\n\t}\n\n\tret = mdp_cmdq_pkt_create(mdp->cmdq_clt, &cmd->pkt, SZ_16K);\n\tif (ret)\n\t\tgoto err_free_cmd;\n\n\tif (CFG_CHECK(MT8183, p_id)) {\n\t\tnum_comp = CFG_GET(MT8183, param->config, num_components);\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err_destroy_pkt;\n\t}\n\tcomps = kcalloc(num_comp, sizeof(*comps), GFP_KERNEL);\n\tif (!comps) {\n\t\tret = -ENOMEM;\n\t\tgoto err_destroy_pkt;\n\t}\n\n\tpath = kzalloc(sizeof(*path), GFP_KERNEL);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_comps;\n\t}\n\n\ti = mdp->mdp_data->pipe_info[MDP_PIPE_RDMA0].mutex_id;\n\tret = mtk_mutex_prepare(mdp->mdp_mutex[i]);\n\tif (ret) {\n\t\tdev_err(dev, \"Fail to enable mutex clk\\n\");\n\t\tgoto err_free_path;\n\t}\n\n\tpath->mdp_dev = mdp;\n\tpath->config = param->config;\n\tpath->param = param->param;\n\tfor (i = 0; i < param->param->num_outputs; i++) {\n\t\tpath->bounds[i].left = 0;\n\t\tpath->bounds[i].top = 0;\n\t\tpath->bounds[i].width =\n\t\t\tparam->param->outputs[i].buffer.format.width;\n\t\tpath->bounds[i].height =\n\t\t\tparam->param->outputs[i].buffer.format.height;\n\t\tpath->composes[i] = param->composes[i] ?\n\t\t\tparam->composes[i] : &path->bounds[i];\n\t}\n\tret = mdp_path_ctx_init(mdp, path);\n\tif (ret) {\n\t\tdev_err(dev, \"mdp_path_ctx_init error\\n\");\n\t\tgoto err_free_path;\n\t}\n\n\tret = mdp_path_config(mdp, cmd, path);\n\tif (ret) {\n\t\tdev_err(dev, \"mdp_path_config error\\n\");\n\t\tgoto err_free_path;\n\t}\n\tcmdq_pkt_finalize(&cmd->pkt);\n\n\tfor (i = 0; i < num_comp; i++)\n\t\tmemcpy(&comps[i], path->comps[i].comp,\n\t\t       sizeof(struct mdp_comp));\n\n\tmdp->cmdq_clt->client.rx_callback = mdp_handle_cmdq_callback;\n\tcmd->mdp = mdp;\n\tcmd->user_cmdq_cb = param->cmdq_cb;\n\tcmd->user_cb_data = param->cb_data;\n\tcmd->comps = comps;\n\tcmd->num_comps = num_comp;\n\tcmd->mdp_ctx = param->mdp_ctx;\n\n\tret = mdp_comp_clocks_on(&mdp->pdev->dev, cmd->comps, cmd->num_comps);\n\tif (ret)\n\t\tgoto err_free_path;\n\n\tdma_sync_single_for_device(mdp->cmdq_clt->chan->mbox->dev,\n\t\t\t\t   cmd->pkt.pa_base, cmd->pkt.cmd_buf_size,\n\t\t\t\t   DMA_TO_DEVICE);\n\tret = mbox_send_message(mdp->cmdq_clt->chan, &cmd->pkt);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"mbox send message fail %d!\\n\", ret);\n\t\tgoto err_clock_off;\n\t}\n\tmbox_client_txdone(mdp->cmdq_clt->chan, 0);\n\n\tkfree(path);\n\treturn 0;\n\nerr_clock_off:\n\tmdp_comp_clocks_off(&mdp->pdev->dev, cmd->comps,\n\t\t\t    cmd->num_comps);\nerr_free_path:\n\ti = mdp->mdp_data->pipe_info[MDP_PIPE_RDMA0].mutex_id;\n\tmtk_mutex_unprepare(mdp->mdp_mutex[i]);\n\tkfree(path);\nerr_free_comps:\n\tkfree(comps);\nerr_destroy_pkt:\n\tmdp_cmdq_pkt_destroy(&cmd->pkt);\nerr_free_cmd:\n\tkfree(cmd);\nerr_cancel_job:\n\tatomic_dec(&mdp->job_count);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mdp_cmdq_send);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}