{
  "module_name": "mtk-mdp3-m2m.c",
  "hash_id": "016b27d8425fb6373748c49b1f1434c808267d8e85c37b104e1b18f531ca6b1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/mediatek/mdp3/mtk-mdp3-m2m.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-dma-contig.h>\n#include \"mtk-mdp3-m2m.h\"\n\nstatic inline struct mdp_m2m_ctx *fh_to_ctx(struct v4l2_fh *fh)\n{\n\treturn container_of(fh, struct mdp_m2m_ctx, fh);\n}\n\nstatic inline struct mdp_m2m_ctx *ctrl_to_ctx(struct v4l2_ctrl *ctrl)\n{\n\treturn container_of(ctrl->handler, struct mdp_m2m_ctx, ctrl_handler);\n}\n\nstatic inline struct mdp_frame *ctx_get_frame(struct mdp_m2m_ctx *ctx,\n\t\t\t\t\t      enum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn &ctx->curr_param.output;\n\telse\n\t\treturn &ctx->curr_param.captures[0];\n}\n\nstatic inline void mdp_m2m_ctx_set_state(struct mdp_m2m_ctx *ctx, u32 state)\n{\n\tatomic_or(state, &ctx->curr_param.state);\n}\n\nstatic inline bool mdp_m2m_ctx_is_state_set(struct mdp_m2m_ctx *ctx, u32 mask)\n{\n\treturn ((atomic_read(&ctx->curr_param.state) & mask) == mask);\n}\n\nstatic void mdp_m2m_process_done(void *priv, int vb_state)\n{\n\tstruct mdp_m2m_ctx *ctx = priv;\n\tstruct vb2_v4l2_buffer *src_vbuf, *dst_vbuf;\n\n\tsrc_vbuf = (struct vb2_v4l2_buffer *)\n\t\t\tv4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\tdst_vbuf = (struct vb2_v4l2_buffer *)\n\t\t\tv4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\n\tctx->curr_param.frame_no = ctx->frame_count[MDP_M2M_SRC];\n\tsrc_vbuf->sequence = ctx->frame_count[MDP_M2M_SRC]++;\n\tdst_vbuf->sequence = ctx->frame_count[MDP_M2M_DST]++;\n\tv4l2_m2m_buf_copy_metadata(src_vbuf, dst_vbuf, true);\n\n\tv4l2_m2m_buf_done(src_vbuf, vb_state);\n\tv4l2_m2m_buf_done(dst_vbuf, vb_state);\n\tv4l2_m2m_job_finish(ctx->mdp_dev->m2m_dev, ctx->m2m_ctx);\n}\n\nstatic void mdp_m2m_device_run(void *priv)\n{\n\tstruct mdp_m2m_ctx *ctx = priv;\n\tstruct mdp_frame *frame;\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\tstruct img_ipi_frameparam param = {};\n\tstruct mdp_cmdq_param task = {};\n\tenum vb2_buffer_state vb_state = VB2_BUF_STATE_ERROR;\n\tint ret;\n\n\tif (mdp_m2m_ctx_is_state_set(ctx, MDP_M2M_CTX_ERROR)) {\n\t\tdev_err(&ctx->mdp_dev->pdev->dev,\n\t\t\t\"mdp_m2m_ctx is in error state\\n\");\n\t\tgoto worker_end;\n\t}\n\n\tparam.frame_no = ctx->curr_param.frame_no;\n\tparam.type = ctx->curr_param.type;\n\tparam.num_inputs = 1;\n\tparam.num_outputs = 1;\n\n\tframe = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\tsrc_vb = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\n\tmdp_set_src_config(&param.inputs[0], frame, &src_vb->vb2_buf);\n\n\tframe = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tdst_vb = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\n\tmdp_set_dst_config(&param.outputs[0], frame, &dst_vb->vb2_buf);\n\n\tret = mdp_vpu_process(&ctx->mdp_dev->vpu, &param);\n\tif (ret) {\n\t\tdev_err(&ctx->mdp_dev->pdev->dev,\n\t\t\t\"VPU MDP process failed: %d\\n\", ret);\n\t\tgoto worker_end;\n\t}\n\n\ttask.config = ctx->mdp_dev->vpu.config;\n\ttask.param = &param;\n\ttask.composes[0] = &frame->compose;\n\ttask.cmdq_cb = NULL;\n\ttask.cb_data = NULL;\n\ttask.mdp_ctx = ctx;\n\n\tret = mdp_cmdq_send(ctx->mdp_dev, &task);\n\tif (ret) {\n\t\tdev_err(&ctx->mdp_dev->pdev->dev,\n\t\t\t\"CMDQ sendtask failed: %d\\n\", ret);\n\t\tgoto worker_end;\n\t}\n\n\treturn;\n\nworker_end:\n\tmdp_m2m_process_done(ctx, vb_state);\n}\n\nstatic int mdp_m2m_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct mdp_m2m_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct mdp_frame *capture;\n\tstruct vb2_queue *vq;\n\tint ret;\n\tbool out_streaming, cap_streaming;\n\n\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\tctx->frame_count[MDP_M2M_SRC] = 0;\n\n\tif (V4L2_TYPE_IS_CAPTURE(q->type))\n\t\tctx->frame_count[MDP_M2M_DST] = 0;\n\n\tcapture = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tvq = v4l2_m2m_get_src_vq(ctx->m2m_ctx);\n\tout_streaming = vb2_is_streaming(vq);\n\tvq = v4l2_m2m_get_dst_vq(ctx->m2m_ctx);\n\tcap_streaming = vb2_is_streaming(vq);\n\n\t \n\tif ((V4L2_TYPE_IS_OUTPUT(q->type) && cap_streaming) ||\n\t    (V4L2_TYPE_IS_CAPTURE(q->type) && out_streaming)) {\n\t\tret = mdp_check_scaling_ratio(&capture->crop.c,\n\t\t\t\t\t      &capture->compose,\n\t\t\t\t\t      capture->rotation,\n\t\t\t\t\t      ctx->curr_param.limit);\n\t\tif (ret) {\n\t\t\tdev_err(&ctx->mdp_dev->pdev->dev,\n\t\t\t\t\"Out of scaling range\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!mdp_m2m_ctx_is_state_set(ctx, MDP_VPU_INIT)) {\n\t\tret = mdp_vpu_get_locked(ctx->mdp_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&ctx->mdp_dev->pdev->dev,\n\t\t\t\t\"VPU init failed %d\\n\", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmdp_m2m_ctx_set_state(ctx, MDP_VPU_INIT);\n\t}\n\n\treturn 0;\n}\n\nstatic struct vb2_v4l2_buffer *mdp_m2m_buf_remove(struct mdp_m2m_ctx *ctx,\n\t\t\t\t\t\t  unsigned int type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn (struct vb2_v4l2_buffer *)\n\t\t\tv4l2_m2m_src_buf_remove(ctx->m2m_ctx);\n\telse\n\t\treturn (struct vb2_v4l2_buffer *)\n\t\t\tv4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\n}\n\nstatic void mdp_m2m_stop_streaming(struct vb2_queue *q)\n{\n\tstruct mdp_m2m_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vb;\n\n\tvb = mdp_m2m_buf_remove(ctx, q->type);\n\twhile (vb) {\n\t\tv4l2_m2m_buf_done(vb, VB2_BUF_STATE_ERROR);\n\t\tvb = mdp_m2m_buf_remove(ctx, q->type);\n\t}\n}\n\nstatic int mdp_m2m_queue_setup(struct vb2_queue *q,\n\t\t\t       unsigned int *num_buffers,\n\t\t\t       unsigned int *num_planes, unsigned int sizes[],\n\t\t\t       struct device *alloc_devs[])\n{\n\tstruct mdp_m2m_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tu32 i;\n\n\tpix_mp = &ctx_get_frame(ctx, q->type)->format.fmt.pix_mp;\n\n\t \n\tif (*num_planes) {\n\t\tif (*num_planes != pix_mp->num_planes)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < pix_mp->num_planes; ++i)\n\t\t\tif (sizes[i] < pix_mp->plane_fmt[i].sizeimage)\n\t\t\t\treturn -EINVAL;\n\t} else { \n\t\t*num_planes = pix_mp->num_planes;\n\t\tfor (i = 0; i < pix_mp->num_planes; ++i)\n\t\t\tsizes[i] = pix_mp->plane_fmt[i].sizeimage;\n\t}\n\n\treturn 0;\n}\n\nstatic int mdp_m2m_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct mdp_m2m_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tstruct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);\n\tu32 i;\n\n\tv4l2_buf->field = V4L2_FIELD_NONE;\n\n\tif (V4L2_TYPE_IS_CAPTURE(vb->type)) {\n\t\tpix_mp = &ctx_get_frame(ctx, vb->type)->format.fmt.pix_mp;\n\t\tfor (i = 0; i < pix_mp->num_planes; ++i) {\n\t\t\tvb2_set_plane_payload(vb, i,\n\t\t\t\t\t      pix_mp->plane_fmt[i].sizeimage);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int mdp_m2m_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);\n\n\tv4l2_buf->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic void mdp_m2m_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct mdp_m2m_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);\n\n\tv4l2_buf->field = V4L2_FIELD_NONE;\n\n\tv4l2_m2m_buf_queue(ctx->m2m_ctx, to_vb2_v4l2_buffer(vb));\n}\n\nstatic const struct vb2_ops mdp_m2m_qops = {\n\t.queue_setup\t= mdp_m2m_queue_setup,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n\t.buf_prepare\t= mdp_m2m_buf_prepare,\n\t.start_streaming = mdp_m2m_start_streaming,\n\t.stop_streaming\t= mdp_m2m_stop_streaming,\n\t.buf_queue\t= mdp_m2m_buf_queue,\n\t.buf_out_validate = mdp_m2m_buf_out_validate,\n};\n\nstatic int mdp_m2m_querycap(struct file *file, void *fh,\n\t\t\t    struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, MDP_MODULE_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, MDP_DEVICE_NAME, sizeof(cap->card));\n\n\treturn 0;\n}\n\nstatic int mdp_m2m_enum_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tstruct mdp_m2m_ctx *ctx = fh_to_ctx(fh);\n\n\treturn mdp_enum_fmt_mplane(ctx->mdp_dev, f);\n}\n\nstatic int mdp_m2m_g_fmt_mplane(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct mdp_m2m_ctx *ctx = fh_to_ctx(fh);\n\tstruct mdp_frame *frame;\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\n\tframe = ctx_get_frame(ctx, f->type);\n\t*f = frame->format;\n\tpix_mp = &f->fmt.pix_mp;\n\tpix_mp->colorspace = ctx->curr_param.colorspace;\n\tpix_mp->xfer_func = ctx->curr_param.xfer_func;\n\tpix_mp->ycbcr_enc = ctx->curr_param.ycbcr_enc;\n\tpix_mp->quantization = ctx->curr_param.quant;\n\n\treturn 0;\n}\n\nstatic int mdp_m2m_s_fmt_mplane(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct mdp_m2m_ctx *ctx = fh_to_ctx(fh);\n\tstruct mdp_frame *frame = ctx_get_frame(ctx, f->type);\n\tstruct mdp_frame *capture;\n\tconst struct mdp_format *fmt;\n\tstruct vb2_queue *vq;\n\n\tfmt = mdp_try_fmt_mplane(ctx->mdp_dev, f, &ctx->curr_param, ctx->id);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\tframe->format = *f;\n\tframe->mdp_fmt = fmt;\n\tframe->ycbcr_prof = mdp_map_ycbcr_prof_mplane(f, fmt->mdp_color);\n\tframe->usage = V4L2_TYPE_IS_OUTPUT(f->type) ?\n\t\tMDP_BUFFER_USAGE_HW_READ : MDP_BUFFER_USAGE_MDP;\n\n\tcapture = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (V4L2_TYPE_IS_OUTPUT(f->type)) {\n\t\tcapture->crop.c.left = 0;\n\t\tcapture->crop.c.top = 0;\n\t\tcapture->crop.c.width = f->fmt.pix_mp.width;\n\t\tcapture->crop.c.height = f->fmt.pix_mp.height;\n\t\tctx->curr_param.colorspace = f->fmt.pix_mp.colorspace;\n\t\tctx->curr_param.ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;\n\t\tctx->curr_param.quant = f->fmt.pix_mp.quantization;\n\t\tctx->curr_param.xfer_func = f->fmt.pix_mp.xfer_func;\n\t} else {\n\t\tcapture->compose.left = 0;\n\t\tcapture->compose.top = 0;\n\t\tcapture->compose.width = f->fmt.pix_mp.width;\n\t\tcapture->compose.height = f->fmt.pix_mp.height;\n\t}\n\n\treturn 0;\n}\n\nstatic int mdp_m2m_try_fmt_mplane(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct mdp_m2m_ctx *ctx = fh_to_ctx(fh);\n\n\tif (!mdp_try_fmt_mplane(ctx->mdp_dev, f, &ctx->curr_param, ctx->id))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int mdp_m2m_g_selection(struct file *file, void *fh,\n\t\t\t       struct v4l2_selection *s)\n{\n\tstruct mdp_m2m_ctx *ctx = fh_to_ctx(fh);\n\tstruct mdp_frame *frame;\n\tbool valid = false;\n\n\tif (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tvalid = mdp_target_is_crop(s->target);\n\telse if (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tvalid = mdp_target_is_compose(s->target);\n\n\tif (!valid)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tframe = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\t\ts->r = frame->crop.c;\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tframe = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\t\ts->r = frame->compose;\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tframe = ctx_get_frame(ctx, s->type);\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = frame->format.fmt.pix_mp.width;\n\t\ts->r.height = frame->format.fmt.pix_mp.height;\n\t\treturn 0;\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tframe = ctx_get_frame(ctx, s->type);\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = frame->format.fmt.pix_mp.width;\n\t\ts->r.height = frame->format.fmt.pix_mp.height;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int mdp_m2m_s_selection(struct file *file, void *fh,\n\t\t\t       struct v4l2_selection *s)\n{\n\tstruct mdp_m2m_ctx *ctx = fh_to_ctx(fh);\n\tstruct mdp_frame *frame = ctx_get_frame(ctx, s->type);\n\tstruct mdp_frame *capture;\n\tstruct v4l2_rect r;\n\tstruct device *dev = &ctx->mdp_dev->pdev->dev;\n\tbool valid = false;\n\tint ret;\n\n\tif (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tvalid = (s->target == V4L2_SEL_TGT_CROP);\n\telse if (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tvalid = (s->target == V4L2_SEL_TGT_COMPOSE);\n\n\tif (!valid) {\n\t\tdev_dbg(dev, \"[%s:%d] invalid type:%u target:%u\", __func__,\n\t\t\tctx->id, s->type, s->target);\n\t\treturn -EINVAL;\n\t}\n\n\tret = mdp_try_crop(ctx, &r, s, frame);\n\tif (ret)\n\t\treturn ret;\n\tcapture = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\n\tif (mdp_target_is_crop(s->target))\n\t\tcapture->crop.c = r;\n\telse\n\t\tcapture->compose = r;\n\n\ts->r = r;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops mdp_m2m_ioctl_ops = {\n\t.vidioc_querycap\t\t= mdp_m2m_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= mdp_m2m_enum_fmt_mplane,\n\t.vidioc_enum_fmt_vid_out\t= mdp_m2m_enum_fmt_mplane,\n\t.vidioc_g_fmt_vid_cap_mplane\t= mdp_m2m_g_fmt_mplane,\n\t.vidioc_g_fmt_vid_out_mplane\t= mdp_m2m_g_fmt_mplane,\n\t.vidioc_s_fmt_vid_cap_mplane\t= mdp_m2m_s_fmt_mplane,\n\t.vidioc_s_fmt_vid_out_mplane\t= mdp_m2m_s_fmt_mplane,\n\t.vidioc_try_fmt_vid_cap_mplane\t= mdp_m2m_try_fmt_mplane,\n\t.vidioc_try_fmt_vid_out_mplane\t= mdp_m2m_try_fmt_mplane,\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\t.vidioc_g_selection\t\t= mdp_m2m_g_selection,\n\t.vidioc_s_selection\t\t= mdp_m2m_s_selection,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nstatic int mdp_m2m_queue_init(void *priv,\n\t\t\t      struct vb2_queue *src_vq,\n\t\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct mdp_m2m_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->ops = &mdp_m2m_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->dev = &ctx->mdp_dev->pdev->dev;\n\tsrc_vq->lock = &ctx->ctx_lock;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->ops = &mdp_m2m_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->dev = &ctx->mdp_dev->pdev->dev;\n\tdst_vq->lock = &ctx->ctx_lock;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int mdp_m2m_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mdp_m2m_ctx *ctx = ctrl_to_ctx(ctrl);\n\tstruct mdp_frame *capture;\n\n\tcapture = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tcapture->hflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tcapture->vflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_ROTATE:\n\t\tcapture->rotation = ctrl->val;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops mdp_m2m_ctrl_ops = {\n\t.s_ctrl\t= mdp_m2m_s_ctrl,\n};\n\nstatic int mdp_m2m_ctrls_create(struct mdp_m2m_ctx *ctx)\n{\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, MDP_MAX_CTRLS);\n\tctx->ctrls.hflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t\t\t     &mdp_m2m_ctrl_ops, V4L2_CID_HFLIP,\n\t\t\t\t\t     0, 1, 1, 0);\n\tctx->ctrls.vflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t\t\t     &mdp_m2m_ctrl_ops, V4L2_CID_VFLIP,\n\t\t\t\t\t     0, 1, 1, 0);\n\tctx->ctrls.rotate = v4l2_ctrl_new_std(&ctx->ctrl_handler,\n\t\t\t\t\t      &mdp_m2m_ctrl_ops,\n\t\t\t\t\t      V4L2_CID_ROTATE, 0, 270, 90, 0);\n\n\tif (ctx->ctrl_handler.error) {\n\t\tint err = ctx->ctrl_handler.error;\n\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\t\tdev_err(&ctx->mdp_dev->pdev->dev,\n\t\t\t\"Failed to register controls\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int mdp_m2m_open(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct mdp_dev *mdp = video_get_drvdata(vdev);\n\tstruct mdp_m2m_ctx *ctx;\n\tstruct device *dev = &mdp->pdev->dev;\n\tint ret;\n\tstruct v4l2_format default_format = {};\n\tconst struct mdp_limit *limit = mdp->mdp_data->def_limit;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (mutex_lock_interruptible(&mdp->m2m_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto err_free_ctx;\n\t}\n\n\tret = ida_alloc(&mdp->mdp_ida, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_unlock_mutex;\n\tctx->id = ret;\n\n\tctx->mdp_dev = mdp;\n\n\tv4l2_fh_init(&ctx->fh, vdev);\n\tfile->private_data = &ctx->fh;\n\tret = mdp_m2m_ctrls_create(ctx);\n\tif (ret)\n\t\tgoto err_exit_fh;\n\n\t \n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\tv4l2_fh_add(&ctx->fh);\n\n\tmutex_init(&ctx->ctx_lock);\n\tctx->m2m_ctx = v4l2_m2m_ctx_init(mdp->m2m_dev, ctx, mdp_m2m_queue_init);\n\tif (IS_ERR(ctx->m2m_ctx)) {\n\t\tdev_err(dev, \"Failed to initialize m2m context\\n\");\n\t\tret = PTR_ERR(ctx->m2m_ctx);\n\t\tgoto err_release_handler;\n\t}\n\tctx->fh.m2m_ctx = ctx->m2m_ctx;\n\n\tctx->curr_param.ctx = ctx;\n\tret = mdp_frameparam_init(mdp, &ctx->curr_param);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize mdp parameter\\n\");\n\t\tgoto err_release_m2m_ctx;\n\t}\n\n\tmutex_unlock(&mdp->m2m_lock);\n\n\t \n\tdefault_format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tdefault_format.fmt.pix_mp.width = limit->out_limit.wmin;\n\tdefault_format.fmt.pix_mp.height = limit->out_limit.hmin;\n\tdefault_format.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_YUV420M;\n\tmdp_m2m_s_fmt_mplane(file, &ctx->fh, &default_format);\n\tdefault_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tmdp_m2m_s_fmt_mplane(file, &ctx->fh, &default_format);\n\n\tdev_dbg(dev, \"%s:[%d]\", __func__, ctx->id);\n\n\treturn 0;\n\nerr_release_m2m_ctx:\n\tv4l2_m2m_ctx_release(ctx->m2m_ctx);\nerr_release_handler:\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tv4l2_fh_del(&ctx->fh);\nerr_exit_fh:\n\tv4l2_fh_exit(&ctx->fh);\n\tida_free(&mdp->mdp_ida, ctx->id);\nerr_unlock_mutex:\n\tmutex_unlock(&mdp->m2m_lock);\nerr_free_ctx:\n\tkfree(ctx);\n\n\treturn ret;\n}\n\nstatic int mdp_m2m_release(struct file *file)\n{\n\tstruct mdp_m2m_ctx *ctx = fh_to_ctx(file->private_data);\n\tstruct mdp_dev *mdp = video_drvdata(file);\n\tstruct device *dev = &mdp->pdev->dev;\n\n\tmutex_lock(&mdp->m2m_lock);\n\tv4l2_m2m_ctx_release(ctx->m2m_ctx);\n\tif (mdp_m2m_ctx_is_state_set(ctx, MDP_VPU_INIT))\n\t\tmdp_vpu_put_locked(mdp);\n\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tida_free(&mdp->mdp_ida, ctx->id);\n\tmutex_unlock(&mdp->m2m_lock);\n\n\tdev_dbg(dev, \"%s:[%d]\", __func__, ctx->id);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations mdp_m2m_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n\t.open\t\t= mdp_m2m_open,\n\t.release\t= mdp_m2m_release,\n};\n\nstatic const struct v4l2_m2m_ops mdp_m2m_ops = {\n\t.device_run\t= mdp_m2m_device_run,\n};\n\nint mdp_m2m_device_register(struct mdp_dev *mdp)\n{\n\tstruct device *dev = &mdp->pdev->dev;\n\tint ret = 0;\n\n\tmdp->m2m_vdev = video_device_alloc();\n\tif (!mdp->m2m_vdev) {\n\t\tdev_err(dev, \"Failed to allocate video device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_video_alloc;\n\t}\n\tmdp->m2m_vdev->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE |\n\t\tV4L2_CAP_STREAMING;\n\tmdp->m2m_vdev->fops = &mdp_m2m_fops;\n\tmdp->m2m_vdev->ioctl_ops = &mdp_m2m_ioctl_ops;\n\tmdp->m2m_vdev->release = mdp_video_device_release;\n\tmdp->m2m_vdev->lock = &mdp->m2m_lock;\n\tmdp->m2m_vdev->vfl_dir = VFL_DIR_M2M;\n\tmdp->m2m_vdev->v4l2_dev = &mdp->v4l2_dev;\n\tsnprintf(mdp->m2m_vdev->name, sizeof(mdp->m2m_vdev->name), \"%s:m2m\",\n\t\t MDP_MODULE_NAME);\n\tvideo_set_drvdata(mdp->m2m_vdev, mdp);\n\n\tmdp->m2m_dev = v4l2_m2m_init(&mdp_m2m_ops);\n\tif (IS_ERR(mdp->m2m_dev)) {\n\t\tdev_err(dev, \"Failed to initialize v4l2-m2m device\\n\");\n\t\tret = PTR_ERR(mdp->m2m_dev);\n\t\tgoto err_m2m_init;\n\t}\n\n\tret = video_register_device(mdp->m2m_vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register video device\\n\");\n\t\tgoto err_video_register;\n\t}\n\n\tv4l2_info(&mdp->v4l2_dev, \"Driver registered as /dev/video%d\",\n\t\t  mdp->m2m_vdev->num);\n\treturn 0;\n\nerr_video_register:\n\tv4l2_m2m_release(mdp->m2m_dev);\nerr_m2m_init:\n\tvideo_device_release(mdp->m2m_vdev);\nerr_video_alloc:\n\n\treturn ret;\n}\n\nvoid mdp_m2m_device_unregister(struct mdp_dev *mdp)\n{\n\tvideo_unregister_device(mdp->m2m_vdev);\n}\n\nvoid mdp_m2m_job_finish(struct mdp_m2m_ctx *ctx)\n{\n\tenum vb2_buffer_state vb_state = VB2_BUF_STATE_DONE;\n\n\tmdp_m2m_process_done(ctx, vb_state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}