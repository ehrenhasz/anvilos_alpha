{
  "module_name": "camss-csiphy-2ph-1-0.c",
  "hash_id": "b4a6cce0dea2952d8f69ddc9dc59d05b8d22bd532037335d8c6a935680be1dd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/camss/camss-csiphy-2ph-1-0.c",
  "human_readable_source": "\n \n\n#include \"camss-csiphy.h\"\n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n\n#define CAMSS_CSI_PHY_LNn_CFG2(n)\t\t(0x004 + 0x40 * (n))\n#define CAMSS_CSI_PHY_LNn_CFG3(n)\t\t(0x008 + 0x40 * (n))\n#define\t\tCAMSS_CSI_PHY_LN_CLK\t\t1\n#define CAMSS_CSI_PHY_GLBL_RESET\t\t0x140\n#define CAMSS_CSI_PHY_GLBL_PWR_CFG\t\t0x144\n#define CAMSS_CSI_PHY_GLBL_IRQ_CMD\t\t0x164\n#define CAMSS_CSI_PHY_HW_VERSION\t\t0x188\n#define CAMSS_CSI_PHY_INTERRUPT_STATUSn(n)\t(0x18c + 0x4 * (n))\n#define CAMSS_CSI_PHY_INTERRUPT_MASKn(n)\t(0x1ac + 0x4 * (n))\n#define CAMSS_CSI_PHY_INTERRUPT_CLEARn(n)\t(0x1cc + 0x4 * (n))\n#define CAMSS_CSI_PHY_GLBL_T_INIT_CFG0\t\t0x1ec\n#define CAMSS_CSI_PHY_T_WAKEUP_CFG0\t\t0x1f4\n\nstatic u8 csiphy_get_lane_mask(struct csiphy_lanes_cfg *lane_cfg)\n{\n\tu8 lane_mask;\n\tint i;\n\n\tlane_mask = 1 << CAMSS_CSI_PHY_LN_CLK;\n\n\tfor (i = 0; i < lane_cfg->num_data; i++)\n\t\tlane_mask |= 1 << lane_cfg->data[i].pos;\n\n\treturn lane_mask;\n}\n\nstatic void csiphy_hw_version_read(struct csiphy_device *csiphy,\n\t\t\t\t   struct device *dev)\n{\n\tu8 hw_version = readl_relaxed(csiphy->base +\n\t\t\t\t      CAMSS_CSI_PHY_HW_VERSION);\n\n\tdev_dbg(dev, \"CSIPHY HW Version = 0x%02x\\n\", hw_version);\n}\n\n \nstatic void csiphy_reset(struct csiphy_device *csiphy)\n{\n\twritel_relaxed(0x1, csiphy->base + CAMSS_CSI_PHY_GLBL_RESET);\n\tusleep_range(5000, 8000);\n\twritel_relaxed(0x0, csiphy->base + CAMSS_CSI_PHY_GLBL_RESET);\n}\n\n \nstatic u8 csiphy_settle_cnt_calc(s64 link_freq, u32 timer_clk_rate)\n{\n\tu32 ui;  \n\tu32 timer_period;  \n\tu32 t_hs_prepare_max;  \n\tu32 t_hs_prepare_zero_min;  \n\tu32 t_hs_settle;  \n\tu8 settle_cnt;\n\n\tif (link_freq <= 0)\n\t\treturn 0;\n\n\tui = div_u64(1000000000000LL, link_freq);\n\tui /= 2;\n\tt_hs_prepare_max = 85000 + 6 * ui;\n\tt_hs_prepare_zero_min = 145000 + 10 * ui;\n\tt_hs_settle = (t_hs_prepare_max + t_hs_prepare_zero_min) / 2;\n\n\ttimer_period = div_u64(1000000000000LL, timer_clk_rate);\n\tsettle_cnt = t_hs_settle / timer_period - 1;\n\n\treturn settle_cnt;\n}\n\nstatic void csiphy_lanes_enable(struct csiphy_device *csiphy,\n\t\t\t\tstruct csiphy_config *cfg,\n\t\t\t\ts64 link_freq, u8 lane_mask)\n{\n\tstruct csiphy_lanes_cfg *c = &cfg->csi2->lane_cfg;\n\tu8 settle_cnt;\n\tu8 val, l = 0;\n\tint i = 0;\n\n\tsettle_cnt = csiphy_settle_cnt_calc(link_freq, csiphy->timer_clk_rate);\n\n\twritel_relaxed(0x1, csiphy->base +\n\t\t       CAMSS_CSI_PHY_GLBL_T_INIT_CFG0);\n\twritel_relaxed(0x1, csiphy->base +\n\t\t       CAMSS_CSI_PHY_T_WAKEUP_CFG0);\n\n\tval = 0x1;\n\tval |= lane_mask << 1;\n\twritel_relaxed(val, csiphy->base + CAMSS_CSI_PHY_GLBL_PWR_CFG);\n\n\tval = cfg->combo_mode << 4;\n\twritel_relaxed(val, csiphy->base + CAMSS_CSI_PHY_GLBL_RESET);\n\n\tfor (i = 0; i <= c->num_data; i++) {\n\t\tif (i == c->num_data)\n\t\t\tl = CAMSS_CSI_PHY_LN_CLK;\n\t\telse\n\t\t\tl = c->data[i].pos;\n\n\t\twritel_relaxed(0x10, csiphy->base +\n\t\t\t       CAMSS_CSI_PHY_LNn_CFG2(l));\n\t\twritel_relaxed(settle_cnt, csiphy->base +\n\t\t\t       CAMSS_CSI_PHY_LNn_CFG3(l));\n\t\twritel_relaxed(0x3f, csiphy->base +\n\t\t\t       CAMSS_CSI_PHY_INTERRUPT_MASKn(l));\n\t\twritel_relaxed(0x3f, csiphy->base +\n\t\t\t       CAMSS_CSI_PHY_INTERRUPT_CLEARn(l));\n\t}\n}\n\nstatic void csiphy_lanes_disable(struct csiphy_device *csiphy,\n\t\t\t\t struct csiphy_config *cfg)\n{\n\tstruct csiphy_lanes_cfg *c = &cfg->csi2->lane_cfg;\n\tu8 l = 0;\n\tint i = 0;\n\n\tfor (i = 0; i <= c->num_data; i++) {\n\t\tif (i == c->num_data)\n\t\t\tl = CAMSS_CSI_PHY_LN_CLK;\n\t\telse\n\t\t\tl = c->data[i].pos;\n\n\t\twritel_relaxed(0x0, csiphy->base +\n\t\t\t       CAMSS_CSI_PHY_LNn_CFG2(l));\n\t}\n\n\twritel_relaxed(0x0, csiphy->base + CAMSS_CSI_PHY_GLBL_PWR_CFG);\n}\n\n \nstatic irqreturn_t csiphy_isr(int irq, void *dev)\n{\n\tstruct csiphy_device *csiphy = dev;\n\tu8 i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tu8 val = readl_relaxed(csiphy->base +\n\t\t\t\t       CAMSS_CSI_PHY_INTERRUPT_STATUSn(i));\n\t\twritel_relaxed(val, csiphy->base +\n\t\t\t       CAMSS_CSI_PHY_INTERRUPT_CLEARn(i));\n\t\twritel_relaxed(0x1, csiphy->base + CAMSS_CSI_PHY_GLBL_IRQ_CMD);\n\t\twritel_relaxed(0x0, csiphy->base + CAMSS_CSI_PHY_GLBL_IRQ_CMD);\n\t\twritel_relaxed(0x0, csiphy->base +\n\t\t\t       CAMSS_CSI_PHY_INTERRUPT_CLEARn(i));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nconst struct csiphy_hw_ops csiphy_ops_2ph_1_0 = {\n\t.get_lane_mask = csiphy_get_lane_mask,\n\t.hw_version_read = csiphy_hw_version_read,\n\t.reset = csiphy_reset,\n\t.lanes_enable = csiphy_lanes_enable,\n\t.lanes_disable = csiphy_lanes_disable,\n\t.isr = csiphy_isr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}