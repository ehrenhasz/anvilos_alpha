{
  "module_name": "camss-vfe.c",
  "hash_id": "cd0b240b94b0a77bbc8125c8e2f6815e3cc67d0fcf95dbb9200564f0692a3710",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/camss/camss-vfe.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/iommu.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spinlock_types.h>\n#include <linux/spinlock.h>\n#include <media/media-entity.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-subdev.h>\n\n#include \"camss-vfe.h\"\n#include \"camss.h\"\n\n#define MSM_VFE_NAME \"msm_vfe\"\n\n \n#define VFE_RESET_TIMEOUT_MS 50\n\n#define SCALER_RATIO_MAX 16\n\nstruct vfe_format {\n\tu32 code;\n\tu8 bpp;\n};\n\nstatic const struct vfe_format formats_rdi_8x16[] = {\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_SBGGR8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SGBRG8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SRGGB8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SBGGR12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SGBRG12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SRGGB12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_Y10_1X10, 10 },\n};\n\nstatic const struct vfe_format formats_pix_8x16[] = {\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, 8 },\n};\n\nstatic const struct vfe_format formats_rdi_8x96[] = {\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_SBGGR8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SGBRG8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SRGGB8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE, 16 },\n\t{ MEDIA_BUS_FMT_SBGGR12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SGBRG12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SRGGB12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SBGGR14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_SGBRG14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_SGRBG14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_SRGGB14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_Y10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_Y10_2X8_PADHI_LE, 16 },\n};\n\nstatic const struct vfe_format formats_pix_8x96[] = {\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, 8 },\n};\n\nstatic const struct vfe_format formats_rdi_845[] = {\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_SBGGR8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SGBRG8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SRGGB8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE, 16 },\n\t{ MEDIA_BUS_FMT_SBGGR12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SGBRG12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SRGGB12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SBGGR14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_SGBRG14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_SGRBG14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_SRGGB14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_Y8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_Y10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_Y10_2X8_PADHI_LE, 16 },\n};\n\n \nstatic u8 vfe_get_bpp(const struct vfe_format *formats,\n\t\t      unsigned int nformats, u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < nformats; i++)\n\t\tif (code == formats[i].code)\n\t\t\treturn formats[i].bpp;\n\n\tWARN(1, \"Unknown format\\n\");\n\n\treturn formats[0].bpp;\n}\n\nstatic u32 vfe_find_code(u32 *code, unsigned int n_code,\n\t\t\t unsigned int index, u32 req_code)\n{\n\tint i;\n\n\tif (!req_code && (index >= n_code))\n\t\treturn 0;\n\n\tfor (i = 0; i < n_code; i++)\n\t\tif (req_code) {\n\t\t\tif (req_code == code[i])\n\t\t\t\treturn req_code;\n\t\t} else {\n\t\t\tif (i == index)\n\t\t\t\treturn code[i];\n\t\t}\n\n\treturn code[0];\n}\n\nstatic u32 vfe_src_pad_code(struct vfe_line *line, u32 sink_code,\n\t\t\t    unsigned int index, u32 src_req_code)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\n\tif (vfe->camss->version == CAMSS_8x16)\n\t\tswitch (sink_code) {\n\t\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\t{\n\t\t\tu32 src_code[] = {\n\t\t\t\tMEDIA_BUS_FMT_YUYV8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_YUYV8_1_5X8,\n\t\t\t};\n\n\t\t\treturn vfe_find_code(src_code, ARRAY_SIZE(src_code),\n\t\t\t\t\t     index, src_req_code);\n\t\t}\n\t\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\t\t{\n\t\t\tu32 src_code[] = {\n\t\t\t\tMEDIA_BUS_FMT_YVYU8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_YVYU8_1_5X8,\n\t\t\t};\n\n\t\t\treturn vfe_find_code(src_code, ARRAY_SIZE(src_code),\n\t\t\t\t\t     index, src_req_code);\n\t\t}\n\t\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\t{\n\t\t\tu32 src_code[] = {\n\t\t\t\tMEDIA_BUS_FMT_UYVY8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_UYVY8_1_5X8,\n\t\t\t};\n\n\t\t\treturn vfe_find_code(src_code, ARRAY_SIZE(src_code),\n\t\t\t\t\t     index, src_req_code);\n\t\t}\n\t\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\t\t{\n\t\t\tu32 src_code[] = {\n\t\t\t\tMEDIA_BUS_FMT_VYUY8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_VYUY8_1_5X8,\n\t\t\t};\n\n\t\t\treturn vfe_find_code(src_code, ARRAY_SIZE(src_code),\n\t\t\t\t\t     index, src_req_code);\n\t\t}\n\t\tdefault:\n\t\t\tif (index > 0)\n\t\t\t\treturn 0;\n\n\t\t\treturn sink_code;\n\t\t}\n\telse if (vfe->camss->version == CAMSS_8x96 ||\n\t\t vfe->camss->version == CAMSS_660 ||\n\t\t vfe->camss->version == CAMSS_845 ||\n\t\t vfe->camss->version == CAMSS_8250)\n\t\tswitch (sink_code) {\n\t\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\t{\n\t\t\tu32 src_code[] = {\n\t\t\t\tMEDIA_BUS_FMT_YUYV8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_YVYU8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_UYVY8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_VYUY8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_YUYV8_1_5X8,\n\t\t\t};\n\n\t\t\treturn vfe_find_code(src_code, ARRAY_SIZE(src_code),\n\t\t\t\t\t     index, src_req_code);\n\t\t}\n\t\tcase MEDIA_BUS_FMT_YVYU8_2X8:\n\t\t{\n\t\t\tu32 src_code[] = {\n\t\t\t\tMEDIA_BUS_FMT_YVYU8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_YUYV8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_UYVY8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_VYUY8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_YVYU8_1_5X8,\n\t\t\t};\n\n\t\t\treturn vfe_find_code(src_code, ARRAY_SIZE(src_code),\n\t\t\t\t\t     index, src_req_code);\n\t\t}\n\t\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\t{\n\t\t\tu32 src_code[] = {\n\t\t\t\tMEDIA_BUS_FMT_UYVY8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_YUYV8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_YVYU8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_VYUY8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_UYVY8_1_5X8,\n\t\t\t};\n\n\t\t\treturn vfe_find_code(src_code, ARRAY_SIZE(src_code),\n\t\t\t\t\t     index, src_req_code);\n\t\t}\n\t\tcase MEDIA_BUS_FMT_VYUY8_2X8:\n\t\t{\n\t\t\tu32 src_code[] = {\n\t\t\t\tMEDIA_BUS_FMT_VYUY8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_YUYV8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_YVYU8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_UYVY8_2X8,\n\t\t\t\tMEDIA_BUS_FMT_VYUY8_1_5X8,\n\t\t\t};\n\n\t\t\treturn vfe_find_code(src_code, ARRAY_SIZE(src_code),\n\t\t\t\t\t     index, src_req_code);\n\t\t}\n\t\tdefault:\n\t\t\tif (index > 0)\n\t\t\t\treturn 0;\n\n\t\t\treturn sink_code;\n\t\t}\n\telse\n\t\treturn 0;\n}\n\nint vfe_reset(struct vfe_device *vfe)\n{\n\tunsigned long time;\n\n\treinit_completion(&vfe->reset_complete);\n\n\tvfe->ops->global_reset(vfe);\n\n\ttime = wait_for_completion_timeout(&vfe->reset_complete,\n\t\tmsecs_to_jiffies(VFE_RESET_TIMEOUT_MS));\n\tif (!time) {\n\t\tdev_err(vfe->camss->dev, \"VFE reset timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void vfe_init_outputs(struct vfe_device *vfe)\n{\n\tint i;\n\n\tfor (i = 0; i < vfe->line_num; i++) {\n\t\tstruct vfe_output *output = &vfe->line[i].output;\n\n\t\toutput->state = VFE_OUTPUT_OFF;\n\t\toutput->buf[0] = NULL;\n\t\toutput->buf[1] = NULL;\n\t\tINIT_LIST_HEAD(&output->pending_bufs);\n\t}\n}\n\nstatic void vfe_reset_output_maps(struct vfe_device *vfe)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vfe->wm_output_map); i++)\n\t\tvfe->wm_output_map[i] = VFE_LINE_NONE;\n}\n\nint vfe_reserve_wm(struct vfe_device *vfe, enum vfe_line_id line_id)\n{\n\tint ret = -EBUSY;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vfe->wm_output_map); i++) {\n\t\tif (vfe->wm_output_map[i] == VFE_LINE_NONE) {\n\t\t\tvfe->wm_output_map[i] = line_id;\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint vfe_release_wm(struct vfe_device *vfe, u8 wm)\n{\n\tif (wm >= ARRAY_SIZE(vfe->wm_output_map))\n\t\treturn -EINVAL;\n\n\tvfe->wm_output_map[wm] = VFE_LINE_NONE;\n\n\treturn 0;\n}\n\nstruct camss_buffer *vfe_buf_get_pending(struct vfe_output *output)\n{\n\tstruct camss_buffer *buffer = NULL;\n\n\tif (!list_empty(&output->pending_bufs)) {\n\t\tbuffer = list_first_entry(&output->pending_bufs,\n\t\t\t\t\t  struct camss_buffer,\n\t\t\t\t\t  queue);\n\t\tlist_del(&buffer->queue);\n\t}\n\n\treturn buffer;\n}\n\nvoid vfe_buf_add_pending(struct vfe_output *output,\n\t\t\t struct camss_buffer *buffer)\n{\n\tINIT_LIST_HEAD(&buffer->queue);\n\tlist_add_tail(&buffer->queue, &output->pending_bufs);\n}\n\n \nstatic void vfe_buf_flush_pending(struct vfe_output *output,\n\t\t\t\t  enum vb2_buffer_state state)\n{\n\tstruct camss_buffer *buf;\n\tstruct camss_buffer *t;\n\n\tlist_for_each_entry_safe(buf, t, &output->pending_bufs, queue) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t\tlist_del(&buf->queue);\n\t}\n}\n\nint vfe_put_output(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output = &line->output;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\tfor (i = 0; i < output->wm_num; i++)\n\t\tvfe_release_wm(vfe, output->wm_idx[i]);\n\n\toutput->state = VFE_OUTPUT_OFF;\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\treturn 0;\n}\n\n \nvoid vfe_isr_comp_done(struct vfe_device *vfe, u8 comp)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vfe->wm_output_map); i++)\n\t\tif (vfe->wm_output_map[i] == VFE_LINE_PIX) {\n\t\t\tvfe->isr_ops.wm_done(vfe, i);\n\t\t\tbreak;\n\t\t}\n}\n\nvoid vfe_isr_reset_ack(struct vfe_device *vfe)\n{\n\tcomplete(&vfe->reset_complete);\n}\n\n \nstatic int vfe_set_clock_rates(struct vfe_device *vfe)\n{\n\tstruct device *dev = vfe->camss->dev;\n\tu64 pixel_clock[VFE_LINE_NUM_MAX];\n\tint i, j;\n\tint ret;\n\n\tfor (i = VFE_LINE_RDI0; i < vfe->line_num; i++) {\n\t\tret = camss_get_pixel_clock(&vfe->line[i].subdev.entity,\n\t\t\t\t\t    &pixel_clock[i]);\n\t\tif (ret)\n\t\t\tpixel_clock[i] = 0;\n\t}\n\n\tfor (i = 0; i < vfe->nclocks; i++) {\n\t\tstruct camss_clock *clock = &vfe->clock[i];\n\n\t\tif (!strcmp(clock->name, \"vfe0\") ||\n\t\t    !strcmp(clock->name, \"vfe1\") ||\n\t\t    !strcmp(clock->name, \"vfe_lite\")) {\n\t\t\tu64 min_rate = 0;\n\t\t\tlong rate;\n\n\t\t\tfor (j = VFE_LINE_RDI0; j < vfe->line_num; j++) {\n\t\t\t\tu32 tmp;\n\t\t\t\tu8 bpp;\n\n\t\t\t\tif (j == VFE_LINE_PIX) {\n\t\t\t\t\ttmp = pixel_clock[j];\n\t\t\t\t} else {\n\t\t\t\t\tstruct vfe_line *l = &vfe->line[j];\n\n\t\t\t\t\tbpp = vfe_get_bpp(l->formats,\n\t\t\t\t\t\tl->nformats,\n\t\t\t\t\t\tl->fmt[MSM_VFE_PAD_SINK].code);\n\t\t\t\t\ttmp = pixel_clock[j] * bpp / 64;\n\t\t\t\t}\n\n\t\t\t\tif (min_rate < tmp)\n\t\t\t\t\tmin_rate = tmp;\n\t\t\t}\n\n\t\t\tcamss_add_clock_margin(&min_rate);\n\n\t\t\tfor (j = 0; j < clock->nfreqs; j++)\n\t\t\t\tif (min_rate < clock->freq[j])\n\t\t\t\t\tbreak;\n\n\t\t\tif (j == clock->nfreqs) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Pixel clock is too high for VFE\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\tif (min_rate == 0)\n\t\t\t\tj = clock->nfreqs - 1;\n\n\t\t\trate = clk_round_rate(clock->clk, clock->freq[j]);\n\t\t\tif (rate < 0) {\n\t\t\t\tdev_err(dev, \"clk round rate failed: %ld\\n\",\n\t\t\t\t\trate);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tret = clk_set_rate(clock->clk, rate);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"clk set rate failed: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vfe_check_clock_rates(struct vfe_device *vfe)\n{\n\tu64 pixel_clock[VFE_LINE_NUM_MAX];\n\tint i, j;\n\tint ret;\n\n\tfor (i = VFE_LINE_RDI0; i < vfe->line_num; i++) {\n\t\tret = camss_get_pixel_clock(&vfe->line[i].subdev.entity,\n\t\t\t\t\t    &pixel_clock[i]);\n\t\tif (ret)\n\t\t\tpixel_clock[i] = 0;\n\t}\n\n\tfor (i = 0; i < vfe->nclocks; i++) {\n\t\tstruct camss_clock *clock = &vfe->clock[i];\n\n\t\tif (!strcmp(clock->name, \"vfe0\") ||\n\t\t    !strcmp(clock->name, \"vfe1\") ||\n\t\t    !strcmp(clock->name, \"vfe_lite\")) {\n\t\t\tu64 min_rate = 0;\n\t\t\tunsigned long rate;\n\n\t\t\tfor (j = VFE_LINE_RDI0; j < vfe->line_num; j++) {\n\t\t\t\tu32 tmp;\n\t\t\t\tu8 bpp;\n\n\t\t\t\tif (j == VFE_LINE_PIX) {\n\t\t\t\t\ttmp = pixel_clock[j];\n\t\t\t\t} else {\n\t\t\t\t\tstruct vfe_line *l = &vfe->line[j];\n\n\t\t\t\t\tbpp = vfe_get_bpp(l->formats,\n\t\t\t\t\t\tl->nformats,\n\t\t\t\t\t\tl->fmt[MSM_VFE_PAD_SINK].code);\n\t\t\t\t\ttmp = pixel_clock[j] * bpp / 64;\n\t\t\t\t}\n\n\t\t\t\tif (min_rate < tmp)\n\t\t\t\t\tmin_rate = tmp;\n\t\t\t}\n\n\t\t\tcamss_add_clock_margin(&min_rate);\n\n\t\t\trate = clk_get_rate(clock->clk);\n\t\t\tif (rate < min_rate)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint vfe_get(struct vfe_device *vfe)\n{\n\tint ret;\n\n\tmutex_lock(&vfe->power_lock);\n\n\tif (vfe->power_count == 0) {\n\t\tret = vfe->ops->pm_domain_on(vfe);\n\t\tif (ret < 0)\n\t\t\tgoto error_pm_domain;\n\n\t\tret = pm_runtime_resume_and_get(vfe->camss->dev);\n\t\tif (ret < 0)\n\t\t\tgoto error_domain_off;\n\n\t\tret = vfe_set_clock_rates(vfe);\n\t\tif (ret < 0)\n\t\t\tgoto error_pm_runtime_get;\n\n\t\tret = camss_enable_clocks(vfe->nclocks, vfe->clock,\n\t\t\t\t\t  vfe->camss->dev);\n\t\tif (ret < 0)\n\t\t\tgoto error_pm_runtime_get;\n\n\t\tret = vfe_reset(vfe);\n\t\tif (ret < 0)\n\t\t\tgoto error_reset;\n\n\t\tvfe_reset_output_maps(vfe);\n\n\t\tvfe_init_outputs(vfe);\n\n\t\tvfe->ops->hw_version(vfe);\n\t} else {\n\t\tret = vfe_check_clock_rates(vfe);\n\t\tif (ret < 0)\n\t\t\tgoto error_pm_domain;\n\t}\n\tvfe->power_count++;\n\n\tmutex_unlock(&vfe->power_lock);\n\n\treturn 0;\n\nerror_reset:\n\tcamss_disable_clocks(vfe->nclocks, vfe->clock);\n\nerror_pm_runtime_get:\n\tpm_runtime_put_sync(vfe->camss->dev);\nerror_domain_off:\n\tvfe->ops->pm_domain_off(vfe);\n\nerror_pm_domain:\n\tmutex_unlock(&vfe->power_lock);\n\n\treturn ret;\n}\n\n \nvoid vfe_put(struct vfe_device *vfe)\n{\n\tmutex_lock(&vfe->power_lock);\n\n\tif (vfe->power_count == 0) {\n\t\tdev_err(vfe->camss->dev, \"vfe power off on power_count == 0\\n\");\n\t\tgoto exit;\n\t} else if (vfe->power_count == 1) {\n\t\tif (vfe->was_streaming) {\n\t\t\tvfe->was_streaming = 0;\n\t\t\tvfe->ops->vfe_halt(vfe);\n\t\t}\n\t\tcamss_disable_clocks(vfe->nclocks, vfe->clock);\n\t\tpm_runtime_put_sync(vfe->camss->dev);\n\t\tvfe->ops->pm_domain_off(vfe);\n\t}\n\n\tvfe->power_count--;\n\nexit:\n\tmutex_unlock(&vfe->power_lock);\n}\n\n \nint vfe_flush_buffers(struct camss_video *vid,\n\t\t      enum vb2_buffer_state state)\n{\n\tstruct vfe_line *line = container_of(vid, struct vfe_line, video_out);\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output;\n\tunsigned long flags;\n\n\toutput = &line->output;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\tvfe_buf_flush_pending(output, state);\n\n\tif (output->buf[0])\n\t\tvb2_buffer_done(&output->buf[0]->vb.vb2_buf, state);\n\n\tif (output->buf[1])\n\t\tvb2_buffer_done(&output->buf[1]->vb.vb2_buf, state);\n\n\tif (output->last_buffer) {\n\t\tvb2_buffer_done(&output->last_buffer->vb.vb2_buf, state);\n\t\toutput->last_buffer = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int vfe_set_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct vfe_line *line = v4l2_get_subdevdata(sd);\n\tstruct vfe_device *vfe = to_vfe(line);\n\tint ret;\n\n\tif (on) {\n\t\tret = vfe_get(vfe);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tvfe_put(vfe);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vfe_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct vfe_line *line = v4l2_get_subdevdata(sd);\n\tstruct vfe_device *vfe = to_vfe(line);\n\tint ret;\n\n\tif (enable) {\n\t\tline->output.state = VFE_OUTPUT_RESERVED;\n\t\tret = vfe->ops->vfe_enable(line);\n\t\tif (ret < 0)\n\t\t\tdev_err(vfe->camss->dev,\n\t\t\t\t\"Failed to enable vfe outputs\\n\");\n\t} else {\n\t\tret = vfe->ops->vfe_disable(line);\n\t\tif (ret < 0)\n\t\t\tdev_err(vfe->camss->dev,\n\t\t\t\t\"Failed to disable vfe outputs\\n\");\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct v4l2_mbus_framefmt *\n__vfe_get_format(struct vfe_line *line,\n\t\t struct v4l2_subdev_state *sd_state,\n\t\t unsigned int pad,\n\t\t enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&line->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\n\treturn &line->fmt[pad];\n}\n\n \nstatic struct v4l2_rect *\n__vfe_get_compose(struct vfe_line *line,\n\t\t  struct v4l2_subdev_state *sd_state,\n\t\t  enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_compose(&line->subdev, sd_state,\n\t\t\t\t\t\t   MSM_VFE_PAD_SINK);\n\n\treturn &line->compose;\n}\n\n \nstatic struct v4l2_rect *\n__vfe_get_crop(struct vfe_line *line,\n\t       struct v4l2_subdev_state *sd_state,\n\t       enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_crop(&line->subdev, sd_state,\n\t\t\t\t\t\tMSM_VFE_PAD_SRC);\n\n\treturn &line->crop;\n}\n\n \nstatic void vfe_try_format(struct vfe_line *line,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   unsigned int pad,\n\t\t\t   struct v4l2_mbus_framefmt *fmt,\n\t\t\t   enum v4l2_subdev_format_whence which)\n{\n\tunsigned int i;\n\tu32 code;\n\n\tswitch (pad) {\n\tcase MSM_VFE_PAD_SINK:\n\t\t \n\n\t\tfor (i = 0; i < line->nformats; i++)\n\t\t\tif (fmt->code == line->formats[i].code)\n\t\t\t\tbreak;\n\n\t\t \n\t\tif (i >= line->nformats)\n\t\t\tfmt->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\n\t\tfmt->width = clamp_t(u32, fmt->width, 1, 8191);\n\t\tfmt->height = clamp_t(u32, fmt->height, 1, 8191);\n\n\t\tfmt->field = V4L2_FIELD_NONE;\n\t\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\n\t\tbreak;\n\n\tcase MSM_VFE_PAD_SRC:\n\t\t \n\t\tcode = fmt->code;\n\n\t\t*fmt = *__vfe_get_format(line, sd_state, MSM_VFE_PAD_SINK,\n\t\t\t\t\t which);\n\n\t\tfmt->code = vfe_src_pad_code(line, fmt->code, 0, code);\n\n\t\tif (line->id == VFE_LINE_PIX) {\n\t\t\tstruct v4l2_rect *rect;\n\n\t\t\trect = __vfe_get_crop(line, sd_state, which);\n\n\t\t\tfmt->width = rect->width;\n\t\t\tfmt->height = rect->height;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n}\n\n \nstatic void vfe_try_compose(struct vfe_line *line,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_rect *rect,\n\t\t\t    enum v4l2_subdev_format_whence which)\n{\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\tfmt = __vfe_get_format(line, sd_state, MSM_VFE_PAD_SINK, which);\n\n\tif (rect->width > fmt->width)\n\t\trect->width = fmt->width;\n\n\tif (rect->height > fmt->height)\n\t\trect->height = fmt->height;\n\n\tif (fmt->width > rect->width * SCALER_RATIO_MAX)\n\t\trect->width = (fmt->width + SCALER_RATIO_MAX - 1) /\n\t\t\t\t\t\t\tSCALER_RATIO_MAX;\n\n\trect->width &= ~0x1;\n\n\tif (fmt->height > rect->height * SCALER_RATIO_MAX)\n\t\trect->height = (fmt->height + SCALER_RATIO_MAX - 1) /\n\t\t\t\t\t\t\tSCALER_RATIO_MAX;\n\n\tif (rect->width < 16)\n\t\trect->width = 16;\n\n\tif (rect->height < 4)\n\t\trect->height = 4;\n}\n\n \nstatic void vfe_try_crop(struct vfe_line *line,\n\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t struct v4l2_rect *rect,\n\t\t\t enum v4l2_subdev_format_whence which)\n{\n\tstruct v4l2_rect *compose;\n\n\tcompose = __vfe_get_compose(line, sd_state, which);\n\n\tif (rect->width > compose->width)\n\t\trect->width = compose->width;\n\n\tif (rect->width + rect->left > compose->width)\n\t\trect->left = compose->width - rect->width;\n\n\tif (rect->height > compose->height)\n\t\trect->height = compose->height;\n\n\tif (rect->height + rect->top > compose->height)\n\t\trect->top = compose->height - rect->height;\n\n\t \n\trect->left += (rect->width & 0xf) >> 1;\n\trect->width &= ~0xf;\n\n\tif (rect->width < 16) {\n\t\trect->left = 0;\n\t\trect->width = 16;\n\t}\n\n\tif (rect->height < 4) {\n\t\trect->top = 0;\n\t\trect->height = 4;\n\t}\n}\n\n \nstatic int vfe_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct vfe_line *line = v4l2_get_subdevdata(sd);\n\n\tif (code->pad == MSM_VFE_PAD_SINK) {\n\t\tif (code->index >= line->nformats)\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = line->formats[code->index].code;\n\t} else {\n\t\tstruct v4l2_mbus_framefmt *sink_fmt;\n\n\t\tsink_fmt = __vfe_get_format(line, sd_state, MSM_VFE_PAD_SINK,\n\t\t\t\t\t    code->which);\n\n\t\tcode->code = vfe_src_pad_code(line, sink_fmt->code,\n\t\t\t\t\t      code->index, 0);\n\t\tif (!code->code)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vfe_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct vfe_line *line = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tvfe_try_format(line, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tvfe_try_format(line, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int vfe_get_format(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct vfe_line *line = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __vfe_get_format(line, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\n\treturn 0;\n}\n\nstatic int vfe_set_selection(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_selection *sel);\n\n \nstatic int vfe_set_format(struct v4l2_subdev *sd,\n\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t  struct v4l2_subdev_format *fmt)\n{\n\tstruct vfe_line *line = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __vfe_get_format(line, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tvfe_try_format(line, sd_state, fmt->pad, &fmt->format, fmt->which);\n\t*format = fmt->format;\n\n\tif (fmt->pad == MSM_VFE_PAD_SINK) {\n\t\tstruct v4l2_subdev_selection sel = { 0 };\n\t\tint ret;\n\n\t\t \n\t\tformat = __vfe_get_format(line, sd_state, MSM_VFE_PAD_SRC,\n\t\t\t\t\t  fmt->which);\n\n\t\t*format = fmt->format;\n\t\tvfe_try_format(line, sd_state, MSM_VFE_PAD_SRC, format,\n\t\t\t       fmt->which);\n\n\t\tif (line->id != VFE_LINE_PIX)\n\t\t\treturn 0;\n\n\t\t \n\t\tsel.which = fmt->which;\n\t\tsel.pad = MSM_VFE_PAD_SINK;\n\t\tsel.target = V4L2_SEL_TGT_COMPOSE;\n\t\tsel.r.width = fmt->format.width;\n\t\tsel.r.height = fmt->format.height;\n\t\tret = vfe_set_selection(sd, sd_state, &sel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int vfe_get_selection(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct vfe_line *line = v4l2_get_subdevdata(sd);\n\tstruct v4l2_subdev_format fmt = { 0 };\n\tstruct v4l2_rect *rect;\n\tint ret;\n\n\tif (line->id != VFE_LINE_PIX)\n\t\treturn -EINVAL;\n\n\tif (sel->pad == MSM_VFE_PAD_SINK)\n\t\tswitch (sel->target) {\n\t\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\t\tfmt.pad = sel->pad;\n\t\t\tfmt.which = sel->which;\n\t\t\tret = vfe_get_format(sd, sd_state, &fmt);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tsel->r.left = 0;\n\t\t\tsel->r.top = 0;\n\t\t\tsel->r.width = fmt.format.width;\n\t\t\tsel->r.height = fmt.format.height;\n\t\t\tbreak;\n\t\tcase V4L2_SEL_TGT_COMPOSE:\n\t\t\trect = __vfe_get_compose(line, sd_state, sel->which);\n\t\t\tif (rect == NULL)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsel->r = *rect;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\telse if (sel->pad == MSM_VFE_PAD_SRC)\n\t\tswitch (sel->target) {\n\t\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\t\trect = __vfe_get_compose(line, sd_state, sel->which);\n\t\t\tif (rect == NULL)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsel->r.left = rect->left;\n\t\t\tsel->r.top = rect->top;\n\t\t\tsel->r.width = rect->width;\n\t\t\tsel->r.height = rect->height;\n\t\t\tbreak;\n\t\tcase V4L2_SEL_TGT_CROP:\n\t\t\trect = __vfe_get_crop(line, sd_state, sel->which);\n\t\t\tif (rect == NULL)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsel->r = *rect;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\treturn 0;\n}\n\n \nstatic int vfe_set_selection(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_selection *sel)\n{\n\tstruct vfe_line *line = v4l2_get_subdevdata(sd);\n\tstruct v4l2_rect *rect;\n\tint ret;\n\n\tif (line->id != VFE_LINE_PIX)\n\t\treturn -EINVAL;\n\n\tif (sel->target == V4L2_SEL_TGT_COMPOSE &&\n\t\tsel->pad == MSM_VFE_PAD_SINK) {\n\t\tstruct v4l2_subdev_selection crop = { 0 };\n\n\t\trect = __vfe_get_compose(line, sd_state, sel->which);\n\t\tif (rect == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tvfe_try_compose(line, sd_state, &sel->r, sel->which);\n\t\t*rect = sel->r;\n\n\t\t \n\t\tcrop.which = sel->which;\n\t\tcrop.pad = MSM_VFE_PAD_SRC;\n\t\tcrop.target = V4L2_SEL_TGT_CROP;\n\t\tcrop.r = *rect;\n\t\tret = vfe_set_selection(sd, sd_state, &crop);\n\t} else if (sel->target == V4L2_SEL_TGT_CROP &&\n\t\tsel->pad == MSM_VFE_PAD_SRC) {\n\t\tstruct v4l2_subdev_format fmt = { 0 };\n\n\t\trect = __vfe_get_crop(line, sd_state, sel->which);\n\t\tif (rect == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tvfe_try_crop(line, sd_state, &sel->r, sel->which);\n\t\t*rect = sel->r;\n\n\t\t \n\t\tfmt.which = sel->which;\n\t\tfmt.pad = MSM_VFE_PAD_SRC;\n\t\tret = vfe_get_format(sd, sd_state, &fmt);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfmt.format.width = rect->width;\n\t\tfmt.format.height = rect->height;\n\t\tret = vfe_set_format(sd, sd_state, &fmt);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int vfe_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.pad = MSM_VFE_PAD_SINK,\n\t\t.which = fh ? V4L2_SUBDEV_FORMAT_TRY :\n\t\t\t      V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.format = {\n\t\t\t.code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t\t.width = 1920,\n\t\t\t.height = 1080\n\t\t}\n\t};\n\n\treturn vfe_set_format(sd, fh ? fh->state : NULL, &format);\n}\n\n \nint msm_vfe_subdev_init(struct camss *camss, struct vfe_device *vfe,\n\t\t\tconst struct resources *res, u8 id)\n{\n\tstruct device *dev = camss->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint i, j;\n\tint ret;\n\n\tswitch (camss->version) {\n\tcase CAMSS_8x16:\n\t\tvfe->ops = &vfe_ops_4_1;\n\t\tbreak;\n\tcase CAMSS_8x96:\n\t\tvfe->ops = &vfe_ops_4_7;\n\t\tbreak;\n\tcase CAMSS_660:\n\t\tvfe->ops = &vfe_ops_4_8;\n\t\tbreak;\n\tcase CAMSS_845:\n\t\tvfe->ops = &vfe_ops_170;\n\t\tbreak;\n\tcase CAMSS_8250:\n\t\tvfe->ops = &vfe_ops_480;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tvfe->ops->subdev_init(dev, vfe);\n\n\t \n\n\tvfe->base = devm_platform_ioremap_resource_byname(pdev, res->reg[0]);\n\tif (IS_ERR(vfe->base)) {\n\t\tdev_err(dev, \"could not map memory\\n\");\n\t\treturn PTR_ERR(vfe->base);\n\t}\n\n\t \n\n\tret = platform_get_irq_byname(pdev, res->interrupt[0]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvfe->irq = ret;\n\tsnprintf(vfe->irq_name, sizeof(vfe->irq_name), \"%s_%s%d\",\n\t\t dev_name(dev), MSM_VFE_NAME, id);\n\tret = devm_request_irq(dev, vfe->irq, vfe->ops->isr,\n\t\t\t       IRQF_TRIGGER_RISING, vfe->irq_name, vfe);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"request_irq failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\tvfe->nclocks = 0;\n\twhile (res->clock[vfe->nclocks])\n\t\tvfe->nclocks++;\n\n\tvfe->clock = devm_kcalloc(dev, vfe->nclocks, sizeof(*vfe->clock),\n\t\t\t\t  GFP_KERNEL);\n\tif (!vfe->clock)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < vfe->nclocks; i++) {\n\t\tstruct camss_clock *clock = &vfe->clock[i];\n\n\t\tclock->clk = devm_clk_get(dev, res->clock[i]);\n\t\tif (IS_ERR(clock->clk))\n\t\t\treturn PTR_ERR(clock->clk);\n\n\t\tclock->name = res->clock[i];\n\n\t\tclock->nfreqs = 0;\n\t\twhile (res->clock_rate[i][clock->nfreqs])\n\t\t\tclock->nfreqs++;\n\n\t\tif (!clock->nfreqs) {\n\t\t\tclock->freq = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tclock->freq = devm_kcalloc(dev,\n\t\t\t\t\t   clock->nfreqs,\n\t\t\t\t\t   sizeof(*clock->freq),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!clock->freq)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (j = 0; j < clock->nfreqs; j++)\n\t\t\tclock->freq[j] = res->clock_rate[i][j];\n\t}\n\n\tmutex_init(&vfe->power_lock);\n\tvfe->power_count = 0;\n\n\tmutex_init(&vfe->stream_lock);\n\tvfe->stream_count = 0;\n\n\tspin_lock_init(&vfe->output_lock);\n\n\tvfe->camss = camss;\n\tvfe->id = id;\n\tvfe->reg_update = 0;\n\n\tfor (i = VFE_LINE_RDI0; i < vfe->line_num; i++) {\n\t\tstruct vfe_line *l = &vfe->line[i];\n\n\t\tl->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\t\tl->video_out.camss = camss;\n\t\tl->id = i;\n\t\tinit_completion(&l->output.sof);\n\t\tinit_completion(&l->output.reg_update);\n\n\t\tif (camss->version == CAMSS_8x16) {\n\t\t\tif (i == VFE_LINE_PIX) {\n\t\t\t\tl->formats = formats_pix_8x16;\n\t\t\t\tl->nformats = ARRAY_SIZE(formats_pix_8x16);\n\t\t\t} else {\n\t\t\t\tl->formats = formats_rdi_8x16;\n\t\t\t\tl->nformats = ARRAY_SIZE(formats_rdi_8x16);\n\t\t\t}\n\t\t} else if (camss->version == CAMSS_8x96 ||\n\t\t\t   camss->version == CAMSS_660) {\n\t\t\tif (i == VFE_LINE_PIX) {\n\t\t\t\tl->formats = formats_pix_8x96;\n\t\t\t\tl->nformats = ARRAY_SIZE(formats_pix_8x96);\n\t\t\t} else {\n\t\t\t\tl->formats = formats_rdi_8x96;\n\t\t\t\tl->nformats = ARRAY_SIZE(formats_rdi_8x96);\n\t\t\t}\n\t\t} else if (camss->version == CAMSS_845 ||\n\t\t\t   camss->version == CAMSS_8250) {\n\t\t\tl->formats = formats_rdi_845;\n\t\t\tl->nformats = ARRAY_SIZE(formats_rdi_845);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tinit_completion(&vfe->reset_complete);\n\tinit_completion(&vfe->halt_complete);\n\n\treturn 0;\n}\n\n \nstatic int vfe_link_setup(struct media_entity *entity,\n\t\t\t  const struct media_pad *local,\n\t\t\t  const struct media_pad *remote, u32 flags)\n{\n\tif (flags & MEDIA_LNK_FL_ENABLED)\n\t\tif (media_pad_remote_pad_first(local))\n\t\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops vfe_core_ops = {\n\t.s_power = vfe_set_power,\n};\n\nstatic const struct v4l2_subdev_video_ops vfe_video_ops = {\n\t.s_stream = vfe_set_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops vfe_pad_ops = {\n\t.enum_mbus_code = vfe_enum_mbus_code,\n\t.enum_frame_size = vfe_enum_frame_size,\n\t.get_fmt = vfe_get_format,\n\t.set_fmt = vfe_set_format,\n\t.get_selection = vfe_get_selection,\n\t.set_selection = vfe_set_selection,\n};\n\nstatic const struct v4l2_subdev_ops vfe_v4l2_ops = {\n\t.core = &vfe_core_ops,\n\t.video = &vfe_video_ops,\n\t.pad = &vfe_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops vfe_v4l2_internal_ops = {\n\t.open = vfe_init_formats,\n};\n\nstatic const struct media_entity_operations vfe_media_ops = {\n\t.link_setup = vfe_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \nint msm_vfe_register_entities(struct vfe_device *vfe,\n\t\t\t      struct v4l2_device *v4l2_dev)\n{\n\tstruct device *dev = vfe->camss->dev;\n\tstruct v4l2_subdev *sd;\n\tstruct media_pad *pads;\n\tstruct camss_video *video_out;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < vfe->line_num; i++) {\n\t\tchar name[32];\n\n\t\tsd = &vfe->line[i].subdev;\n\t\tpads = vfe->line[i].pads;\n\t\tvideo_out = &vfe->line[i].video_out;\n\n\t\tv4l2_subdev_init(sd, &vfe_v4l2_ops);\n\t\tsd->internal_ops = &vfe_v4l2_internal_ops;\n\t\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\t\tif (i == VFE_LINE_PIX)\n\t\t\tsnprintf(sd->name, ARRAY_SIZE(sd->name), \"%s%d_%s\",\n\t\t\t\t MSM_VFE_NAME, vfe->id, \"pix\");\n\t\telse\n\t\t\tsnprintf(sd->name, ARRAY_SIZE(sd->name), \"%s%d_%s%d\",\n\t\t\t\t MSM_VFE_NAME, vfe->id, \"rdi\", i);\n\n\t\tv4l2_set_subdevdata(sd, &vfe->line[i]);\n\n\t\tret = vfe_init_formats(sd, NULL);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to init format: %d\\n\", ret);\n\t\t\tgoto error_init;\n\t\t}\n\n\t\tpads[MSM_VFE_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\t\tpads[MSM_VFE_PAD_SRC].flags = MEDIA_PAD_FL_SOURCE;\n\n\t\tsd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;\n\t\tsd->entity.ops = &vfe_media_ops;\n\t\tret = media_entity_pads_init(&sd->entity, MSM_VFE_PADS_NUM,\n\t\t\t\t\t     pads);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to init media entity: %d\\n\", ret);\n\t\t\tgoto error_init;\n\t\t}\n\n\t\tret = v4l2_device_register_subdev(v4l2_dev, sd);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to register subdev: %d\\n\", ret);\n\t\t\tgoto error_reg_subdev;\n\t\t}\n\n\t\tvideo_out->ops = &vfe->video_ops;\n\t\tif (vfe->camss->version == CAMSS_845 ||\n\t\t    vfe->camss->version == CAMSS_8250)\n\t\t\tvideo_out->bpl_alignment = 16;\n\t\telse\n\t\t\tvideo_out->bpl_alignment = 8;\n\t\tvideo_out->line_based = 0;\n\t\tif (i == VFE_LINE_PIX) {\n\t\t\tvideo_out->bpl_alignment = 16;\n\t\t\tvideo_out->line_based = 1;\n\t\t}\n\t\tsnprintf(name, ARRAY_SIZE(name), \"%s%d_%s%d\",\n\t\t\t MSM_VFE_NAME, vfe->id, \"video\", i);\n\t\tret = msm_video_register(video_out, v4l2_dev, name,\n\t\t\t\t\t i == VFE_LINE_PIX ? 1 : 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to register video node: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto error_reg_video;\n\t\t}\n\n\t\tret = media_create_pad_link(\n\t\t\t\t&sd->entity, MSM_VFE_PAD_SRC,\n\t\t\t\t&video_out->vdev.entity, 0,\n\t\t\t\tMEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to link %s->%s entities: %d\\n\",\n\t\t\t\tsd->entity.name, video_out->vdev.entity.name,\n\t\t\t\tret);\n\t\t\tgoto error_link;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_link:\n\tmsm_video_unregister(video_out);\n\nerror_reg_video:\n\tv4l2_device_unregister_subdev(sd);\n\nerror_reg_subdev:\n\tmedia_entity_cleanup(&sd->entity);\n\nerror_init:\n\tfor (i--; i >= 0; i--) {\n\t\tsd = &vfe->line[i].subdev;\n\t\tvideo_out = &vfe->line[i].video_out;\n\n\t\tmsm_video_unregister(video_out);\n\t\tv4l2_device_unregister_subdev(sd);\n\t\tmedia_entity_cleanup(&sd->entity);\n\t}\n\n\treturn ret;\n}\n\n \nvoid msm_vfe_unregister_entities(struct vfe_device *vfe)\n{\n\tint i;\n\n\tmutex_destroy(&vfe->power_lock);\n\tmutex_destroy(&vfe->stream_lock);\n\n\tfor (i = 0; i < vfe->line_num; i++) {\n\t\tstruct v4l2_subdev *sd = &vfe->line[i].subdev;\n\t\tstruct camss_video *video_out = &vfe->line[i].video_out;\n\n\t\tmsm_video_unregister(video_out);\n\t\tv4l2_device_unregister_subdev(sd);\n\t\tmedia_entity_cleanup(&sd->entity);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}