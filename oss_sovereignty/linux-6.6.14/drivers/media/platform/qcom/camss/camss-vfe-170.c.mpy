{
  "module_name": "camss-vfe-170.c",
  "hash_id": "a7686d502aea5993d9803444618b555771b43ab2094139a345040d34d4d861b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/camss/camss-vfe-170.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n\n#include \"camss.h\"\n#include \"camss-vfe.h\"\n\n#define VFE_HW_VERSION\t\t\t\t(0x000)\n\n#define VFE_GLOBAL_RESET_CMD\t\t\t(0x018)\n#define\t\tGLOBAL_RESET_CMD_CORE\t\tBIT(0)\n#define\t\tGLOBAL_RESET_CMD_CAMIF\t\tBIT(1)\n#define\t\tGLOBAL_RESET_CMD_BUS\t\tBIT(2)\n#define\t\tGLOBAL_RESET_CMD_BUS_BDG\tBIT(3)\n#define\t\tGLOBAL_RESET_CMD_REGISTER\tBIT(4)\n#define\t\tGLOBAL_RESET_CMD_PM\t\tBIT(5)\n#define\t\tGLOBAL_RESET_CMD_BUS_MISR\tBIT(6)\n#define\t\tGLOBAL_RESET_CMD_TESTGEN\tBIT(7)\n#define\t\tGLOBAL_RESET_CMD_DSP\t\tBIT(8)\n#define\t\tGLOBAL_RESET_CMD_IDLE_CGC\tBIT(9)\n#define\t\tGLOBAL_RESET_CMD_RDI0\t\tBIT(10)\n#define\t\tGLOBAL_RESET_CMD_RDI1\t\tBIT(11)\n#define\t\tGLOBAL_RESET_CMD_RDI2\t\tBIT(12)\n#define\t\tGLOBAL_RESET_CMD_RDI3\t\tBIT(13)\n#define\t\tGLOBAL_RESET_CMD_VFE_DOMAIN\tBIT(30)\n#define\t\tGLOBAL_RESET_CMD_RESET_BYPASS\tBIT(31)\n\n#define VFE_CORE_CFG\t\t\t\t(0x050)\n#define\t\tCFG_PIXEL_PATTERN_YCBYCR\t(0x4)\n#define\t\tCFG_PIXEL_PATTERN_YCRYCB\t(0x5)\n#define\t\tCFG_PIXEL_PATTERN_CBYCRY\t(0x6)\n#define\t\tCFG_PIXEL_PATTERN_CRYCBY\t(0x7)\n#define\t\tCFG_COMPOSITE_REG_UPDATE_EN\tBIT(4)\n\n#define VFE_IRQ_CMD\t\t\t\t(0x058)\n#define\t\tCMD_GLOBAL_CLEAR\t\tBIT(0)\n\n#define VFE_IRQ_MASK_0\t\t\t\t\t(0x05c)\n#define\t\tMASK_0_CAMIF_SOF\t\t\tBIT(0)\n#define\t\tMASK_0_CAMIF_EOF\t\t\tBIT(1)\n#define\t\tMASK_0_RDI_REG_UPDATE(n)\t\tBIT((n) + 5)\n#define\t\tMASK_0_IMAGE_MASTER_n_PING_PONG(n)\tBIT((n) + 8)\n#define\t\tMASK_0_IMAGE_COMPOSITE_DONE_n(n)\tBIT((n) + 25)\n#define\t\tMASK_0_RESET_ACK\t\t\tBIT(31)\n\n#define VFE_IRQ_MASK_1\t\t\t\t\t(0x060)\n#define\t\tMASK_1_CAMIF_ERROR\t\t\tBIT(0)\n#define\t\tMASK_1_VIOLATION\t\t\tBIT(7)\n#define\t\tMASK_1_BUS_BDG_HALT_ACK\t\t\tBIT(8)\n#define\t\tMASK_1_IMAGE_MASTER_n_BUS_OVERFLOW(n)\tBIT((n) + 9)\n#define\t\tMASK_1_RDI_SOF(n)\t\t\tBIT((n) + 29)\n\n#define VFE_IRQ_CLEAR_0\t\t\t\t\t(0x064)\n#define VFE_IRQ_CLEAR_1\t\t\t\t\t(0x068)\n\n#define VFE_IRQ_STATUS_0\t\t\t\t(0x06c)\n#define\t\tSTATUS_0_CAMIF_SOF\t\t\tBIT(0)\n#define\t\tSTATUS_0_RDI_REG_UPDATE(n)\t\tBIT((n) + 5)\n#define\t\tSTATUS_0_IMAGE_MASTER_PING_PONG(n)\tBIT((n) + 8)\n#define\t\tSTATUS_0_IMAGE_COMPOSITE_DONE(n)\tBIT((n) + 25)\n#define\t\tSTATUS_0_RESET_ACK\t\t\tBIT(31)\n\n#define VFE_IRQ_STATUS_1\t\t\t\t(0x070)\n#define\t\tSTATUS_1_VIOLATION\t\t\tBIT(7)\n#define\t\tSTATUS_1_BUS_BDG_HALT_ACK\t\tBIT(8)\n#define\t\tSTATUS_1_RDI_SOF(n)\t\t\tBIT((n) + 27)\n\n#define VFE_VIOLATION_STATUS\t\t\t(0x07c)\n\n#define VFE_CAMIF_CMD\t\t\t\t(0x478)\n#define\t\tCMD_CLEAR_CAMIF_STATUS\t\tBIT(2)\n\n#define VFE_CAMIF_CFG\t\t\t\t(0x47c)\n#define\t\tCFG_VSYNC_SYNC_EDGE\t\t(0)\n#define\t\t\tVSYNC_ACTIVE_HIGH\t(0)\n#define\t\t\tVSYNC_ACTIVE_LOW\t(1)\n#define\t\tCFG_HSYNC_SYNC_EDGE\t\t(1)\n#define\t\t\tHSYNC_ACTIVE_HIGH\t(0)\n#define\t\t\tHSYNC_ACTIVE_LOW\t(1)\n#define\t\tCFG_VFE_SUBSAMPLE_ENABLE\tBIT(4)\n#define\t\tCFG_BUS_SUBSAMPLE_ENABLE\tBIT(5)\n#define\t\tCFG_VFE_OUTPUT_EN\t\tBIT(6)\n#define\t\tCFG_BUS_OUTPUT_EN\t\tBIT(7)\n#define\t\tCFG_BINNING_EN\t\t\tBIT(9)\n#define\t\tCFG_FRAME_BASED_EN\t\tBIT(10)\n#define\t\tCFG_RAW_CROP_EN\t\t\tBIT(22)\n\n#define VFE_REG_UPDATE_CMD\t\t\t(0x4ac)\n#define\t\tREG_UPDATE_RDI(n)\t\tBIT(1 + (n))\n\n#define VFE_BUS_IRQ_MASK(n)\t\t(0x2044 + (n) * 4)\n#define VFE_BUS_IRQ_CLEAR(n)\t\t(0x2050 + (n) * 4)\n#define VFE_BUS_IRQ_STATUS(n)\t\t(0x205c + (n) * 4)\n#define\t\tSTATUS0_COMP_RESET_DONE\t\tBIT(0)\n#define\t\tSTATUS0_COMP_REG_UPDATE0_DONE\tBIT(1)\n#define\t\tSTATUS0_COMP_REG_UPDATE1_DONE\tBIT(2)\n#define\t\tSTATUS0_COMP_REG_UPDATE2_DONE\tBIT(3)\n#define\t\tSTATUS0_COMP_REG_UPDATE3_DONE\tBIT(4)\n#define\t\tSTATUS0_COMP_REG_UPDATE_DONE(n)\tBIT((n) + 1)\n#define\t\tSTATUS0_COMP0_BUF_DONE\t\tBIT(5)\n#define\t\tSTATUS0_COMP1_BUF_DONE\t\tBIT(6)\n#define\t\tSTATUS0_COMP2_BUF_DONE\t\tBIT(7)\n#define\t\tSTATUS0_COMP3_BUF_DONE\t\tBIT(8)\n#define\t\tSTATUS0_COMP4_BUF_DONE\t\tBIT(9)\n#define\t\tSTATUS0_COMP5_BUF_DONE\t\tBIT(10)\n#define\t\tSTATUS0_COMP_BUF_DONE(n)\tBIT((n) + 5)\n#define\t\tSTATUS0_COMP_ERROR\t\tBIT(11)\n#define\t\tSTATUS0_COMP_OVERWRITE\t\tBIT(12)\n#define\t\tSTATUS0_OVERFLOW\t\tBIT(13)\n#define\t\tSTATUS0_VIOLATION\t\tBIT(14)\n \n#define\t\tSTATUS1_WM_CLIENT_BUF_DONE(n)\t\tBIT(n)\n#define\t\tSTATUS1_EARLY_DONE\t\t\tBIT(24)\n#define\t\tSTATUS2_DUAL_COMP0_BUF_DONE\t\tBIT(0)\n#define\t\tSTATUS2_DUAL_COMP1_BUF_DONE\t\tBIT(1)\n#define\t\tSTATUS2_DUAL_COMP2_BUF_DONE\t\tBIT(2)\n#define\t\tSTATUS2_DUAL_COMP3_BUF_DONE\t\tBIT(3)\n#define\t\tSTATUS2_DUAL_COMP4_BUF_DONE\t\tBIT(4)\n#define\t\tSTATUS2_DUAL_COMP5_BUF_DONE\t\tBIT(5)\n#define\t\tSTATUS2_DUAL_COMP_BUF_DONE(n)\t\tBIT(n)\n#define\t\tSTATUS2_DUAL_COMP_ERROR\t\t\tBIT(6)\n#define\t\tSTATUS2_DUAL_COMP_OVERWRITE\t\tBIT(7)\n\n#define VFE_BUS_IRQ_CLEAR_GLOBAL\t\t(0x2068)\n\n#define VFE_BUS_WM_DEBUG_STATUS_CFG\t\t(0x226c)\n#define\t\tDEBUG_STATUS_CFG_STATUS0(n)\tBIT(n)\n#define\t\tDEBUG_STATUS_CFG_STATUS1(n)\tBIT(8 + (n))\n\n#define VFE_BUS_WM_ADDR_SYNC_FRAME_HEADER\t(0x2080)\n\n#define VFE_BUS_WM_ADDR_SYNC_NO_SYNC\t\t(0x2084)\n#define\t\tBUS_VER2_MAX_CLIENTS (24)\n#define\t\tWM_ADDR_NO_SYNC_DEFAULT_VAL \\\n\t\t\t\t((1 << BUS_VER2_MAX_CLIENTS) - 1)\n\n#define VFE_BUS_WM_CGC_OVERRIDE\t\t\t(0x200c)\n#define\t\tWM_CGC_OVERRIDE_ALL\t\t(0xFFFFF)\n\n#define VFE_BUS_WM_TEST_BUS_CTRL\t\t(0x211c)\n\n#define VFE_BUS_WM_STATUS0(n)\t\t\t(0x2200 + (n) * 0x100)\n#define VFE_BUS_WM_STATUS1(n)\t\t\t(0x2204 + (n) * 0x100)\n#define VFE_BUS_WM_CFG(n)\t\t\t(0x2208 + (n) * 0x100)\n#define\t\tWM_CFG_EN\t\t\t(0)\n#define\t\tWM_CFG_MODE\t\t\t(1)\n#define\t\t\tMODE_QCOM_PLAIN\t(0)\n#define\t\t\tMODE_MIPI_RAW\t(1)\n#define\t\tWM_CFG_VIRTUALFRAME\t\t(2)\n#define VFE_BUS_WM_HEADER_ADDR(n)\t\t(0x220c + (n) * 0x100)\n#define VFE_BUS_WM_HEADER_CFG(n)\t\t(0x2210 + (n) * 0x100)\n#define VFE_BUS_WM_IMAGE_ADDR(n)\t\t(0x2214 + (n) * 0x100)\n#define VFE_BUS_WM_IMAGE_ADDR_OFFSET(n)\t\t(0x2218 + (n) * 0x100)\n#define VFE_BUS_WM_BUFFER_WIDTH_CFG(n)\t\t(0x221c + (n) * 0x100)\n#define\t\tWM_BUFFER_DEFAULT_WIDTH\t\t(0xFF01)\n\n#define VFE_BUS_WM_BUFFER_HEIGHT_CFG(n)\t\t(0x2220 + (n) * 0x100)\n#define VFE_BUS_WM_PACKER_CFG(n)\t\t(0x2224 + (n) * 0x100)\n\n#define VFE_BUS_WM_STRIDE(n)\t\t\t(0x2228 + (n) * 0x100)\n#define\t\tWM_STRIDE_DEFAULT_STRIDE\t(0xFF01)\n\n#define VFE_BUS_WM_IRQ_SUBSAMPLE_PERIOD(n)\t(0x2248 + (n) * 0x100)\n#define VFE_BUS_WM_IRQ_SUBSAMPLE_PATTERN(n)\t(0x224c + (n) * 0x100)\n#define VFE_BUS_WM_FRAMEDROP_PERIOD(n)\t\t(0x2250 + (n) * 0x100)\n#define VFE_BUS_WM_FRAMEDROP_PATTERN(n)\t\t(0x2254 + (n) * 0x100)\n#define VFE_BUS_WM_FRAME_INC(n)\t\t\t(0x2258 + (n) * 0x100)\n#define VFE_BUS_WM_BURST_LIMIT(n)\t\t(0x225c + (n) * 0x100)\n\nstatic u32 vfe_hw_version(struct vfe_device *vfe)\n{\n\tu32 hw_version = readl_relaxed(vfe->base + VFE_HW_VERSION);\n\n\tu32 gen = (hw_version >> 28) & 0xF;\n\tu32 rev = (hw_version >> 16) & 0xFFF;\n\tu32 step = hw_version & 0xFFFF;\n\n\tdev_dbg(vfe->camss->dev, \"VFE HW Version = %u.%u.%u\\n\",\n\t\tgen, rev, step);\n\n\treturn hw_version;\n}\n\nstatic inline void vfe_reg_set(struct vfe_device *vfe, u32 reg, u32 set_bits)\n{\n\tu32 bits = readl_relaxed(vfe->base + reg);\n\n\twritel_relaxed(bits | set_bits, vfe->base + reg);\n}\n\nstatic void vfe_global_reset(struct vfe_device *vfe)\n{\n\tu32 reset_bits = GLOBAL_RESET_CMD_CORE\t\t|\n\t\t\t GLOBAL_RESET_CMD_CAMIF\t\t|\n\t\t\t GLOBAL_RESET_CMD_BUS\t\t|\n\t\t\t GLOBAL_RESET_CMD_BUS_BDG\t|\n\t\t\t GLOBAL_RESET_CMD_REGISTER\t|\n\t\t\t GLOBAL_RESET_CMD_TESTGEN\t|\n\t\t\t GLOBAL_RESET_CMD_DSP\t\t|\n\t\t\t GLOBAL_RESET_CMD_IDLE_CGC\t|\n\t\t\t GLOBAL_RESET_CMD_RDI0\t\t|\n\t\t\t GLOBAL_RESET_CMD_RDI1\t\t|\n\t\t\t GLOBAL_RESET_CMD_RDI2;\n\n\twritel_relaxed(BIT(31), vfe->base + VFE_IRQ_MASK_0);\n\n\t \n\twmb();\n\n\twritel_relaxed(reset_bits, vfe->base + VFE_GLOBAL_RESET_CMD);\n}\n\nstatic void vfe_wm_start(struct vfe_device *vfe, u8 wm, struct vfe_line *line)\n{\n\tu32 val;\n\n\t \n\tval = DEBUG_STATUS_CFG_STATUS0(1) |\n\t      DEBUG_STATUS_CFG_STATUS0(7);\n\twritel_relaxed(val, vfe->base + VFE_BUS_WM_DEBUG_STATUS_CFG);\n\n\t \n\twritel_relaxed(0, vfe->base + VFE_BUS_WM_ADDR_SYNC_FRAME_HEADER);\n\n\t \n\tval = WM_CGC_OVERRIDE_ALL;\n\twritel_relaxed(val, vfe->base + VFE_BUS_WM_CGC_OVERRIDE);\n\n\twritel_relaxed(0x0, vfe->base + VFE_BUS_WM_TEST_BUS_CTRL);\n\n\t \n\tval = WM_ADDR_NO_SYNC_DEFAULT_VAL;\n\twritel_relaxed(val, vfe->base + VFE_BUS_WM_ADDR_SYNC_NO_SYNC);\n\n\twritel_relaxed(0xf, vfe->base + VFE_BUS_WM_BURST_LIMIT(wm));\n\n\tval = WM_BUFFER_DEFAULT_WIDTH;\n\twritel_relaxed(val, vfe->base + VFE_BUS_WM_BUFFER_WIDTH_CFG(wm));\n\n\tval = 0;\n\twritel_relaxed(val, vfe->base + VFE_BUS_WM_BUFFER_HEIGHT_CFG(wm));\n\n\tval = 0;\n\twritel_relaxed(val, vfe->base + VFE_BUS_WM_PACKER_CFG(wm)); \n\n\t \n\tval = WM_STRIDE_DEFAULT_STRIDE;\n\twritel_relaxed(val, vfe->base + VFE_BUS_WM_STRIDE(wm));\n\n\t \n\tval = 1 << WM_CFG_EN |\n\t      MODE_MIPI_RAW << WM_CFG_MODE;\n\twritel_relaxed(val, vfe->base + VFE_BUS_WM_CFG(wm));\n}\n\nstatic void vfe_wm_stop(struct vfe_device *vfe, u8 wm)\n{\n\t \n\twritel_relaxed(0, vfe->base + VFE_BUS_WM_CFG(wm));\n}\n\nstatic void vfe_wm_update(struct vfe_device *vfe, u8 wm, u32 addr,\n\t\t\t  struct vfe_line *line)\n{\n\tstruct v4l2_pix_format_mplane *pix =\n\t\t&line->video_out.active_fmt.fmt.pix_mp;\n\tu32 stride = pix->plane_fmt[0].bytesperline;\n\n\twritel_relaxed(addr, vfe->base + VFE_BUS_WM_IMAGE_ADDR(wm));\n\twritel_relaxed(stride * pix->height, vfe->base + VFE_BUS_WM_FRAME_INC(wm));\n}\n\nstatic void vfe_reg_update(struct vfe_device *vfe, enum vfe_line_id line_id)\n{\n\tvfe->reg_update |= REG_UPDATE_RDI(line_id);\n\n\t \n\twmb();\n\n\twritel_relaxed(vfe->reg_update, vfe->base + VFE_REG_UPDATE_CMD);\n\n\t \n\twmb();\n}\n\nstatic inline void vfe_reg_update_clear(struct vfe_device *vfe,\n\t\t\t\t\tenum vfe_line_id line_id)\n{\n\tvfe->reg_update &= ~REG_UPDATE_RDI(line_id);\n}\n\nstatic void vfe_enable_irq_common(struct vfe_device *vfe)\n{\n\tvfe_reg_set(vfe, VFE_IRQ_MASK_0, ~0u);\n\tvfe_reg_set(vfe, VFE_IRQ_MASK_1, ~0u);\n\n\twritel_relaxed(~0u, vfe->base + VFE_BUS_IRQ_MASK(0));\n\twritel_relaxed(~0u, vfe->base + VFE_BUS_IRQ_MASK(1));\n\twritel_relaxed(~0u, vfe->base + VFE_BUS_IRQ_MASK(2));\n}\n\nstatic void vfe_isr_halt_ack(struct vfe_device *vfe)\n{\n\tcomplete(&vfe->halt_complete);\n}\n\nstatic void vfe_isr_read(struct vfe_device *vfe, u32 *status0, u32 *status1)\n{\n\t*status0 = readl_relaxed(vfe->base + VFE_IRQ_STATUS_0);\n\t*status1 = readl_relaxed(vfe->base + VFE_IRQ_STATUS_1);\n\n\twritel_relaxed(*status0, vfe->base + VFE_IRQ_CLEAR_0);\n\twritel_relaxed(*status1, vfe->base + VFE_IRQ_CLEAR_1);\n\n\t \n\twmb();\n\twritel_relaxed(CMD_GLOBAL_CLEAR, vfe->base + VFE_IRQ_CMD);\n}\n\nstatic void vfe_violation_read(struct vfe_device *vfe)\n{\n\tu32 violation = readl_relaxed(vfe->base + VFE_VIOLATION_STATUS);\n\n\tpr_err_ratelimited(\"VFE: violation = 0x%08x\\n\", violation);\n}\n\n \nstatic irqreturn_t vfe_isr(int irq, void *dev)\n{\n\tstruct vfe_device *vfe = dev;\n\tu32 status0, status1, vfe_bus_status[3];\n\tint i, wm;\n\n\tstatus0 = readl_relaxed(vfe->base + VFE_IRQ_STATUS_0);\n\tstatus1 = readl_relaxed(vfe->base + VFE_IRQ_STATUS_1);\n\n\twritel_relaxed(status0, vfe->base + VFE_IRQ_CLEAR_0);\n\twritel_relaxed(status1, vfe->base + VFE_IRQ_CLEAR_1);\n\n\tfor (i = VFE_LINE_RDI0; i <= VFE_LINE_RDI2; i++) {\n\t\tvfe_bus_status[i] = readl_relaxed(vfe->base + VFE_BUS_IRQ_STATUS(i));\n\t\twritel_relaxed(vfe_bus_status[i], vfe->base + VFE_BUS_IRQ_CLEAR(i));\n\t}\n\n\t \n\twmb();\n\n\twritel_relaxed(CMD_GLOBAL_CLEAR, vfe->base + VFE_IRQ_CMD);\n\twritel_relaxed(1, vfe->base + VFE_BUS_IRQ_CLEAR_GLOBAL);\n\n\tif (status0 & STATUS_0_RESET_ACK)\n\t\tvfe->isr_ops.reset_ack(vfe);\n\n\tfor (i = VFE_LINE_RDI0; i <= VFE_LINE_RDI2; i++)\n\t\tif (status0 & STATUS_0_RDI_REG_UPDATE(i))\n\t\t\tvfe->isr_ops.reg_update(vfe, i);\n\n\tfor (i = VFE_LINE_RDI0; i <= VFE_LINE_RDI2; i++)\n\t\tif (status0 & STATUS_1_RDI_SOF(i))\n\t\t\tvfe->isr_ops.sof(vfe, i);\n\n\tfor (i = 0; i < MSM_VFE_COMPOSITE_IRQ_NUM; i++)\n\t\tif (vfe_bus_status[0] & STATUS0_COMP_BUF_DONE(i))\n\t\t\tvfe->isr_ops.comp_done(vfe, i);\n\n\tfor (wm = 0; wm < MSM_VFE_IMAGE_MASTERS_NUM; wm++)\n\t\tif (status0 & BIT(9))\n\t\t\tif (vfe_bus_status[1] & STATUS1_WM_CLIENT_BUF_DONE(wm))\n\t\t\t\tvfe->isr_ops.wm_done(vfe, wm);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int vfe_halt(struct vfe_device *vfe)\n{\n\t \n\treturn 0;\n}\n\nstatic int vfe_get_output(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output;\n\tunsigned long flags;\n\tint wm_idx;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\toutput = &line->output;\n\tif (output->state > VFE_OUTPUT_RESERVED) {\n\t\tdev_err(vfe->camss->dev, \"Output is running\\n\");\n\t\tgoto error;\n\t}\n\n\toutput->wm_num = 1;\n\n\twm_idx = vfe_reserve_wm(vfe, line->id);\n\tif (wm_idx < 0) {\n\t\tdev_err(vfe->camss->dev, \"Can not reserve wm\\n\");\n\t\tgoto error_get_wm;\n\t}\n\toutput->wm_idx[0] = wm_idx;\n\n\toutput->drop_update_idx = 0;\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\treturn 0;\n\nerror_get_wm:\n\tvfe_release_wm(vfe, output->wm_idx[0]);\n\toutput->state = VFE_OUTPUT_OFF;\nerror:\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\treturn -EINVAL;\n}\n\nstatic int vfe_enable_output(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output = &line->output;\n\tconst struct vfe_hw_ops *ops = vfe->ops;\n\tstruct media_entity *sensor;\n\tunsigned long flags;\n\tunsigned int frame_skip = 0;\n\tunsigned int i;\n\n\tsensor = camss_find_sensor(&line->subdev.entity);\n\tif (sensor) {\n\t\tstruct v4l2_subdev *subdev = media_entity_to_v4l2_subdev(sensor);\n\n\t\tv4l2_subdev_call(subdev, sensor, g_skip_frames, &frame_skip);\n\t\t \n\t\tif (frame_skip > VFE_FRAME_DROP_VAL - 1)\n\t\t\tframe_skip = VFE_FRAME_DROP_VAL - 1;\n\t}\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\tops->reg_update_clear(vfe, line->id);\n\n\tif (output->state > VFE_OUTPUT_RESERVED) {\n\t\tdev_err(vfe->camss->dev, \"Output is not in reserved state %d\\n\",\n\t\t\toutput->state);\n\t\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(output->gen2.active_num);\n\n\toutput->state = VFE_OUTPUT_ON;\n\n\toutput->sequence = 0;\n\toutput->wait_reg_update = 0;\n\treinit_completion(&output->reg_update);\n\n\tvfe_wm_start(vfe, output->wm_idx[0], line);\n\n\tfor (i = 0; i < 2; i++) {\n\t\toutput->buf[i] = vfe_buf_get_pending(output);\n\t\tif (!output->buf[i])\n\t\t\tbreak;\n\t\toutput->gen2.active_num++;\n\t\tvfe_wm_update(vfe, output->wm_idx[0], output->buf[i]->addr[0], line);\n\t}\n\n\tops->reg_update(vfe, line->id);\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\treturn 0;\n}\n\nstatic void vfe_disable_output(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output = &line->output;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\tfor (i = 0; i < output->wm_num; i++)\n\t\tvfe_wm_stop(vfe, output->wm_idx[i]);\n\toutput->gen2.active_num = 0;\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\tvfe_reset(vfe);\n}\n\n \nstatic int vfe_enable(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tint ret;\n\n\tmutex_lock(&vfe->stream_lock);\n\n\tif (!vfe->stream_count)\n\t\tvfe_enable_irq_common(vfe);\n\n\tvfe->stream_count++;\n\n\tmutex_unlock(&vfe->stream_lock);\n\n\tret = vfe_get_output(line);\n\tif (ret < 0)\n\t\tgoto error_get_output;\n\n\tret = vfe_enable_output(line);\n\tif (ret < 0)\n\t\tgoto error_enable_output;\n\n\tvfe->was_streaming = 1;\n\n\treturn 0;\n\nerror_enable_output:\n\tvfe_put_output(line);\n\nerror_get_output:\n\tmutex_lock(&vfe->stream_lock);\n\n\tvfe->stream_count--;\n\n\tmutex_unlock(&vfe->stream_lock);\n\n\treturn ret;\n}\n\n \nstatic int vfe_disable(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\n\tvfe_disable_output(line);\n\n\tvfe_put_output(line);\n\n\tmutex_lock(&vfe->stream_lock);\n\n\tvfe->stream_count--;\n\n\tmutex_unlock(&vfe->stream_lock);\n\n\treturn 0;\n}\n\n \nstatic void vfe_isr_sof(struct vfe_device *vfe, enum vfe_line_id line_id)\n{\n\t \n}\n\n \nstatic void vfe_isr_reg_update(struct vfe_device *vfe, enum vfe_line_id line_id)\n{\n\tstruct vfe_output *output;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\tvfe->ops->reg_update_clear(vfe, line_id);\n\n\toutput = &vfe->line[line_id].output;\n\n\tif (output->wait_reg_update) {\n\t\toutput->wait_reg_update = 0;\n\t\tcomplete(&output->reg_update);\n\t}\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n}\n\n \nstatic void vfe_isr_wm_done(struct vfe_device *vfe, u8 wm)\n{\n\tstruct vfe_line *line = &vfe->line[vfe->wm_output_map[wm]];\n\tstruct camss_buffer *ready_buf;\n\tstruct vfe_output *output;\n\tunsigned long flags;\n\tu32 index;\n\tu64 ts = ktime_get_ns();\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\tif (vfe->wm_output_map[wm] == VFE_LINE_NONE) {\n\t\tdev_err_ratelimited(vfe->camss->dev,\n\t\t\t\t    \"Received wm done for unmapped index\\n\");\n\t\tgoto out_unlock;\n\t}\n\toutput = &vfe->line[vfe->wm_output_map[wm]].output;\n\n\tready_buf = output->buf[0];\n\tif (!ready_buf) {\n\t\tdev_err_ratelimited(vfe->camss->dev,\n\t\t\t\t    \"Missing ready buf %d!\\n\", output->state);\n\t\tgoto out_unlock;\n\t}\n\n\tready_buf->vb.vb2_buf.timestamp = ts;\n\tready_buf->vb.sequence = output->sequence++;\n\n\tindex = 0;\n\toutput->buf[0] = output->buf[1];\n\tif (output->buf[0])\n\t\tindex = 1;\n\n\toutput->buf[index] = vfe_buf_get_pending(output);\n\n\tif (output->buf[index])\n\t\tvfe_wm_update(vfe, output->wm_idx[0], output->buf[index]->addr[0], line);\n\telse\n\t\toutput->gen2.active_num--;\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\tvb2_buffer_done(&ready_buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\n\treturn;\n\nout_unlock:\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n}\n\n \nstatic void vfe_pm_domain_off(struct vfe_device *vfe)\n{\n\tstruct camss *camss = vfe->camss;\n\n\tif (vfe->id >= camss->vfe_num)\n\t\treturn;\n\n\tdevice_link_del(camss->genpd_link[vfe->id]);\n}\n\n \nstatic int vfe_pm_domain_on(struct vfe_device *vfe)\n{\n\tstruct camss *camss = vfe->camss;\n\tenum vfe_line_id id = vfe->id;\n\n\tif (id >= camss->vfe_num)\n\t\treturn 0;\n\n\tcamss->genpd_link[id] = device_link_add(camss->dev, camss->genpd[id],\n\t\t\t\t\t\tDL_FLAG_STATELESS |\n\t\t\t\t\t\tDL_FLAG_PM_RUNTIME |\n\t\t\t\t\t\tDL_FLAG_RPM_ACTIVE);\n\tif (!camss->genpd_link[id])\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int vfe_queue_buffer(struct camss_video *vid,\n\t\t\t    struct camss_buffer *buf)\n{\n\tstruct vfe_line *line = container_of(vid, struct vfe_line, video_out);\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output;\n\tunsigned long flags;\n\n\toutput = &line->output;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\tif (output->state == VFE_OUTPUT_ON && output->gen2.active_num < 2) {\n\t\toutput->buf[output->gen2.active_num++] = buf;\n\t\tvfe_wm_update(vfe, output->wm_idx[0], buf->addr[0], line);\n\t} else {\n\t\tvfe_buf_add_pending(output, buf);\n\t}\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct vfe_isr_ops vfe_isr_ops_170 = {\n\t.reset_ack = vfe_isr_reset_ack,\n\t.halt_ack = vfe_isr_halt_ack,\n\t.reg_update = vfe_isr_reg_update,\n\t.sof = vfe_isr_sof,\n\t.comp_done = vfe_isr_comp_done,\n\t.wm_done = vfe_isr_wm_done,\n};\n\nstatic const struct camss_video_ops vfe_video_ops_170 = {\n\t.queue_buffer = vfe_queue_buffer,\n\t.flush_buffers = vfe_flush_buffers,\n};\n\nstatic void vfe_subdev_init(struct device *dev, struct vfe_device *vfe)\n{\n\tvfe->isr_ops = vfe_isr_ops_170;\n\tvfe->video_ops = vfe_video_ops_170;\n\n\tvfe->line_num = VFE_LINE_NUM_GEN2;\n}\n\nconst struct vfe_hw_ops vfe_ops_170 = {\n\t.global_reset = vfe_global_reset,\n\t.hw_version = vfe_hw_version,\n\t.isr_read = vfe_isr_read,\n\t.isr = vfe_isr,\n\t.pm_domain_off = vfe_pm_domain_off,\n\t.pm_domain_on = vfe_pm_domain_on,\n\t.reg_update_clear = vfe_reg_update_clear,\n\t.reg_update = vfe_reg_update,\n\t.subdev_init = vfe_subdev_init,\n\t.vfe_disable = vfe_disable,\n\t.vfe_enable = vfe_enable,\n\t.vfe_halt = vfe_halt,\n\t.violation_read = vfe_violation_read,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}