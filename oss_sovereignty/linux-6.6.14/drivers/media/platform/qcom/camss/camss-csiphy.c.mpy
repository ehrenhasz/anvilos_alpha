{
  "module_name": "camss-csiphy.c",
  "hash_id": "df510fbef34cad9fb6a3cec6ce694e8e6ff134ae855548c612f346375c784f49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/camss/camss-csiphy.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <media/media-entity.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-subdev.h>\n\n#include \"camss-csiphy.h\"\n#include \"camss.h\"\n\n#define MSM_CSIPHY_NAME \"msm_csiphy\"\n\nstruct csiphy_format {\n\tu32 code;\n\tu8 bpp;\n};\n\nstatic const struct csiphy_format csiphy_formats_8x16[] = {\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_SBGGR8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SGBRG8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SRGGB8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SBGGR12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SGBRG12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SRGGB12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_Y10_1X10, 10 },\n};\n\nstatic const struct csiphy_format csiphy_formats_8x96[] = {\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_SBGGR8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SGBRG8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SRGGB8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SBGGR12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SGBRG12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SRGGB12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SBGGR14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_SGBRG14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_SGRBG14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_SRGGB14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_Y10_1X10, 10 },\n};\n\nstatic const struct csiphy_format csiphy_formats_sdm845[] = {\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, 8 },\n\t{ MEDIA_BUS_FMT_SBGGR8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SGBRG8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SRGGB8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, 10 },\n\t{ MEDIA_BUS_FMT_SBGGR12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SGBRG12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SRGGB12_1X12, 12 },\n\t{ MEDIA_BUS_FMT_SBGGR14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_SGBRG14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_SGRBG14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_SRGGB14_1X14, 14 },\n\t{ MEDIA_BUS_FMT_Y8_1X8, 8 },\n\t{ MEDIA_BUS_FMT_Y10_1X10, 10 },\n};\n\n \nstatic u8 csiphy_get_bpp(const struct csiphy_format *formats,\n\t\t\t unsigned int nformats, u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < nformats; i++)\n\t\tif (code == formats[i].code)\n\t\t\treturn formats[i].bpp;\n\n\tWARN(1, \"Unknown format\\n\");\n\n\treturn formats[0].bpp;\n}\n\n \nstatic int csiphy_set_clock_rates(struct csiphy_device *csiphy)\n{\n\tstruct device *dev = csiphy->camss->dev;\n\ts64 link_freq;\n\tint i, j;\n\tint ret;\n\n\tu8 bpp = csiphy_get_bpp(csiphy->formats, csiphy->nformats,\n\t\t\t\tcsiphy->fmt[MSM_CSIPHY_PAD_SINK].code);\n\tu8 num_lanes = csiphy->cfg.csi2->lane_cfg.num_data;\n\n\tlink_freq = camss_get_link_freq(&csiphy->subdev.entity, bpp, num_lanes);\n\tif (link_freq < 0)\n\t\tlink_freq  = 0;\n\n\tfor (i = 0; i < csiphy->nclocks; i++) {\n\t\tstruct camss_clock *clock = &csiphy->clock[i];\n\n\t\tif (csiphy->rate_set[i]) {\n\t\t\tu64 min_rate = link_freq / 4;\n\t\t\tlong round_rate;\n\n\t\t\tcamss_add_clock_margin(&min_rate);\n\n\t\t\tfor (j = 0; j < clock->nfreqs; j++)\n\t\t\t\tif (min_rate < clock->freq[j])\n\t\t\t\t\tbreak;\n\n\t\t\tif (j == clock->nfreqs) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Pixel clock is too high for CSIPHY\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\tif (min_rate == 0)\n\t\t\t\tj = clock->nfreqs - 1;\n\n\t\t\tround_rate = clk_round_rate(clock->clk, clock->freq[j]);\n\t\t\tif (round_rate < 0) {\n\t\t\t\tdev_err(dev, \"clk round rate failed: %ld\\n\",\n\t\t\t\t\tround_rate);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tcsiphy->timer_clk_rate = round_rate;\n\n\t\t\tret = clk_set_rate(clock->clk, csiphy->timer_clk_rate);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"clk set rate failed: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int csiphy_set_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct csiphy_device *csiphy = v4l2_get_subdevdata(sd);\n\tstruct device *dev = csiphy->camss->dev;\n\n\tif (on) {\n\t\tint ret;\n\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = csiphy_set_clock_rates(csiphy);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_sync(dev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = camss_enable_clocks(csiphy->nclocks, csiphy->clock, dev);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_sync(dev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tenable_irq(csiphy->irq);\n\n\t\tcsiphy->ops->reset(csiphy);\n\n\t\tcsiphy->ops->hw_version_read(csiphy, dev);\n\t} else {\n\t\tdisable_irq(csiphy->irq);\n\n\t\tcamss_disable_clocks(csiphy->nclocks, csiphy->clock);\n\n\t\tpm_runtime_put_sync(dev);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int csiphy_stream_on(struct csiphy_device *csiphy)\n{\n\tstruct csiphy_config *cfg = &csiphy->cfg;\n\ts64 link_freq;\n\tu8 lane_mask = csiphy->ops->get_lane_mask(&cfg->csi2->lane_cfg);\n\tu8 bpp = csiphy_get_bpp(csiphy->formats, csiphy->nformats,\n\t\t\t\tcsiphy->fmt[MSM_CSIPHY_PAD_SINK].code);\n\tu8 num_lanes = csiphy->cfg.csi2->lane_cfg.num_data;\n\tu8 val;\n\n\tlink_freq = camss_get_link_freq(&csiphy->subdev.entity, bpp, num_lanes);\n\n\tif (link_freq < 0) {\n\t\tdev_err(csiphy->camss->dev,\n\t\t\t\"Cannot get CSI2 transmitter's link frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (csiphy->base_clk_mux) {\n\t\tval = readl_relaxed(csiphy->base_clk_mux);\n\t\tif (cfg->combo_mode && (lane_mask & 0x18) == 0x18) {\n\t\t\tval &= ~0xf0;\n\t\t\tval |= cfg->csid_id << 4;\n\t\t} else {\n\t\t\tval &= ~0xf;\n\t\t\tval |= cfg->csid_id;\n\t\t}\n\t\twritel_relaxed(val, csiphy->base_clk_mux);\n\n\t\t \n\t\twmb();\n\t}\n\n\tcsiphy->ops->lanes_enable(csiphy, cfg, link_freq, lane_mask);\n\n\treturn 0;\n}\n\n \nstatic void csiphy_stream_off(struct csiphy_device *csiphy)\n{\n\tcsiphy->ops->lanes_disable(csiphy, &csiphy->cfg);\n}\n\n\n \nstatic int csiphy_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct csiphy_device *csiphy = v4l2_get_subdevdata(sd);\n\tint ret = 0;\n\n\tif (enable)\n\t\tret = csiphy_stream_on(csiphy);\n\telse\n\t\tcsiphy_stream_off(csiphy);\n\n\treturn ret;\n}\n\n \nstatic struct v4l2_mbus_framefmt *\n__csiphy_get_format(struct csiphy_device *csiphy,\n\t\t    struct v4l2_subdev_state *sd_state,\n\t\t    unsigned int pad,\n\t\t    enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&csiphy->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\n\treturn &csiphy->fmt[pad];\n}\n\n \nstatic void csiphy_try_format(struct csiphy_device *csiphy,\n\t\t\t      struct v4l2_subdev_state *sd_state,\n\t\t\t      unsigned int pad,\n\t\t\t      struct v4l2_mbus_framefmt *fmt,\n\t\t\t      enum v4l2_subdev_format_whence which)\n{\n\tunsigned int i;\n\n\tswitch (pad) {\n\tcase MSM_CSIPHY_PAD_SINK:\n\t\t \n\n\t\tfor (i = 0; i < csiphy->nformats; i++)\n\t\t\tif (fmt->code == csiphy->formats[i].code)\n\t\t\t\tbreak;\n\n\t\t \n\t\tif (i >= csiphy->nformats)\n\t\t\tfmt->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\n\t\tfmt->width = clamp_t(u32, fmt->width, 1, 8191);\n\t\tfmt->height = clamp_t(u32, fmt->height, 1, 8191);\n\n\t\tfmt->field = V4L2_FIELD_NONE;\n\t\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\n\t\tbreak;\n\n\tcase MSM_CSIPHY_PAD_SRC:\n\t\t \n\n\t\t*fmt = *__csiphy_get_format(csiphy, sd_state,\n\t\t\t\t\t    MSM_CSID_PAD_SINK,\n\t\t\t\t\t    which);\n\n\t\tbreak;\n\t}\n}\n\n \nstatic int csiphy_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct csiphy_device *csiphy = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tif (code->pad == MSM_CSIPHY_PAD_SINK) {\n\t\tif (code->index >= csiphy->nformats)\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = csiphy->formats[code->index].code;\n\t} else {\n\t\tif (code->index > 0)\n\t\t\treturn -EINVAL;\n\n\t\tformat = __csiphy_get_format(csiphy, sd_state,\n\t\t\t\t\t     MSM_CSIPHY_PAD_SINK,\n\t\t\t\t\t     code->which);\n\n\t\tcode->code = format->code;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int csiphy_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t  struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct csiphy_device *csiphy = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tcsiphy_try_format(csiphy, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tcsiphy_try_format(csiphy, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int csiphy_get_format(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_format *fmt)\n{\n\tstruct csiphy_device *csiphy = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __csiphy_get_format(csiphy, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\n\treturn 0;\n}\n\n \nstatic int csiphy_set_format(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_format *fmt)\n{\n\tstruct csiphy_device *csiphy = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __csiphy_get_format(csiphy, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tcsiphy_try_format(csiphy, sd_state, fmt->pad, &fmt->format,\n\t\t\t  fmt->which);\n\t*format = fmt->format;\n\n\t \n\tif (fmt->pad == MSM_CSIPHY_PAD_SINK) {\n\t\tformat = __csiphy_get_format(csiphy, sd_state,\n\t\t\t\t\t     MSM_CSIPHY_PAD_SRC,\n\t\t\t\t\t     fmt->which);\n\n\t\t*format = fmt->format;\n\t\tcsiphy_try_format(csiphy, sd_state, MSM_CSIPHY_PAD_SRC,\n\t\t\t\t  format,\n\t\t\t\t  fmt->which);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int csiphy_init_formats(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.pad = MSM_CSIPHY_PAD_SINK,\n\t\t.which = fh ? V4L2_SUBDEV_FORMAT_TRY :\n\t\t\t      V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.format = {\n\t\t\t.code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t\t.width = 1920,\n\t\t\t.height = 1080\n\t\t}\n\t};\n\n\treturn csiphy_set_format(sd, fh ? fh->state : NULL, &format);\n}\n\n \nint msm_csiphy_subdev_init(struct camss *camss,\n\t\t\t   struct csiphy_device *csiphy,\n\t\t\t   const struct resources *res, u8 id)\n{\n\tstruct device *dev = camss->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint i, j;\n\tint ret;\n\n\tcsiphy->camss = camss;\n\tcsiphy->id = id;\n\tcsiphy->cfg.combo_mode = 0;\n\n\tif (camss->version == CAMSS_8x16) {\n\t\tcsiphy->ops = &csiphy_ops_2ph_1_0;\n\t\tcsiphy->formats = csiphy_formats_8x16;\n\t\tcsiphy->nformats = ARRAY_SIZE(csiphy_formats_8x16);\n\t} else if (camss->version == CAMSS_8x96 ||\n\t\t   camss->version == CAMSS_660) {\n\t\tcsiphy->ops = &csiphy_ops_3ph_1_0;\n\t\tcsiphy->formats = csiphy_formats_8x96;\n\t\tcsiphy->nformats = ARRAY_SIZE(csiphy_formats_8x96);\n\t} else if (camss->version == CAMSS_845 ||\n\t\t   camss->version == CAMSS_8250) {\n\t\tcsiphy->ops = &csiphy_ops_3ph_1_0;\n\t\tcsiphy->formats = csiphy_formats_sdm845;\n\t\tcsiphy->nformats = ARRAY_SIZE(csiphy_formats_sdm845);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tcsiphy->base = devm_platform_ioremap_resource_byname(pdev, res->reg[0]);\n\tif (IS_ERR(csiphy->base))\n\t\treturn PTR_ERR(csiphy->base);\n\n\tif (camss->version == CAMSS_8x16 ||\n\t    camss->version == CAMSS_8x96) {\n\t\tcsiphy->base_clk_mux =\n\t\t\tdevm_platform_ioremap_resource_byname(pdev, res->reg[1]);\n\t\tif (IS_ERR(csiphy->base_clk_mux))\n\t\t\treturn PTR_ERR(csiphy->base_clk_mux);\n\t} else {\n\t\tcsiphy->base_clk_mux = NULL;\n\t}\n\n\t \n\n\tret = platform_get_irq_byname(pdev, res->interrupt[0]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcsiphy->irq = ret;\n\tsnprintf(csiphy->irq_name, sizeof(csiphy->irq_name), \"%s_%s%d\",\n\t\t dev_name(dev), MSM_CSIPHY_NAME, csiphy->id);\n\n\tret = devm_request_irq(dev, csiphy->irq, csiphy->ops->isr,\n\t\t\t       IRQF_TRIGGER_RISING | IRQF_NO_AUTOEN,\n\t\t\t       csiphy->irq_name, csiphy);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"request_irq failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\tcsiphy->nclocks = 0;\n\twhile (res->clock[csiphy->nclocks])\n\t\tcsiphy->nclocks++;\n\n\tcsiphy->clock = devm_kcalloc(dev,\n\t\t\t\t     csiphy->nclocks, sizeof(*csiphy->clock),\n\t\t\t\t     GFP_KERNEL);\n\tif (!csiphy->clock)\n\t\treturn -ENOMEM;\n\n\tcsiphy->rate_set = devm_kcalloc(dev,\n\t\t\t\t\tcsiphy->nclocks,\n\t\t\t\t\tsizeof(*csiphy->rate_set),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!csiphy->rate_set)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < csiphy->nclocks; i++) {\n\t\tstruct camss_clock *clock = &csiphy->clock[i];\n\n\t\tclock->clk = devm_clk_get(dev, res->clock[i]);\n\t\tif (IS_ERR(clock->clk))\n\t\t\treturn PTR_ERR(clock->clk);\n\n\t\tclock->name = res->clock[i];\n\n\t\tclock->nfreqs = 0;\n\t\twhile (res->clock_rate[i][clock->nfreqs])\n\t\t\tclock->nfreqs++;\n\n\t\tif (!clock->nfreqs) {\n\t\t\tclock->freq = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tclock->freq = devm_kcalloc(dev,\n\t\t\t\t\t   clock->nfreqs,\n\t\t\t\t\t   sizeof(*clock->freq),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!clock->freq)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (j = 0; j < clock->nfreqs; j++)\n\t\t\tclock->freq[j] = res->clock_rate[i][j];\n\n\t\tif (!strcmp(clock->name, \"csiphy0_timer\") ||\n\t\t    !strcmp(clock->name, \"csiphy1_timer\") ||\n\t\t    !strcmp(clock->name, \"csiphy2_timer\") ||\n\t\t    !strcmp(clock->name, \"csiphy3_timer\") ||\n\t\t    !strcmp(clock->name, \"csiphy4_timer\") ||\n\t\t    !strcmp(clock->name, \"csiphy5_timer\"))\n\t\t\tcsiphy->rate_set[i] = true;\n\n\t\tif (camss->version == CAMSS_660 &&\n\t\t    (!strcmp(clock->name, \"csi0_phy\") ||\n\t\t     !strcmp(clock->name, \"csi1_phy\") ||\n\t\t     !strcmp(clock->name, \"csi2_phy\")))\n\t\t\tcsiphy->rate_set[i] = true;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int csiphy_link_setup(struct media_entity *entity,\n\t\t\t     const struct media_pad *local,\n\t\t\t     const struct media_pad *remote, u32 flags)\n{\n\tif ((local->flags & MEDIA_PAD_FL_SOURCE) &&\n\t    (flags & MEDIA_LNK_FL_ENABLED)) {\n\t\tstruct v4l2_subdev *sd;\n\t\tstruct csiphy_device *csiphy;\n\t\tstruct csid_device *csid;\n\n\t\tif (media_pad_remote_pad_first(local))\n\t\t\treturn -EBUSY;\n\n\t\tsd = media_entity_to_v4l2_subdev(entity);\n\t\tcsiphy = v4l2_get_subdevdata(sd);\n\n\t\tsd = media_entity_to_v4l2_subdev(remote->entity);\n\t\tcsid = v4l2_get_subdevdata(sd);\n\n\t\tcsiphy->cfg.csid_id = csid->id;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops csiphy_core_ops = {\n\t.s_power = csiphy_set_power,\n};\n\nstatic const struct v4l2_subdev_video_ops csiphy_video_ops = {\n\t.s_stream = csiphy_set_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops csiphy_pad_ops = {\n\t.enum_mbus_code = csiphy_enum_mbus_code,\n\t.enum_frame_size = csiphy_enum_frame_size,\n\t.get_fmt = csiphy_get_format,\n\t.set_fmt = csiphy_set_format,\n};\n\nstatic const struct v4l2_subdev_ops csiphy_v4l2_ops = {\n\t.core = &csiphy_core_ops,\n\t.video = &csiphy_video_ops,\n\t.pad = &csiphy_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops csiphy_v4l2_internal_ops = {\n\t.open = csiphy_init_formats,\n};\n\nstatic const struct media_entity_operations csiphy_media_ops = {\n\t.link_setup = csiphy_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \nint msm_csiphy_register_entity(struct csiphy_device *csiphy,\n\t\t\t       struct v4l2_device *v4l2_dev)\n{\n\tstruct v4l2_subdev *sd = &csiphy->subdev;\n\tstruct media_pad *pads = csiphy->pads;\n\tstruct device *dev = csiphy->camss->dev;\n\tint ret;\n\n\tv4l2_subdev_init(sd, &csiphy_v4l2_ops);\n\tsd->internal_ops = &csiphy_v4l2_internal_ops;\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsnprintf(sd->name, ARRAY_SIZE(sd->name), \"%s%d\",\n\t\t MSM_CSIPHY_NAME, csiphy->id);\n\tv4l2_set_subdevdata(sd, csiphy);\n\n\tret = csiphy_init_formats(sd, NULL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to init format: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpads[MSM_CSIPHY_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tpads[MSM_CSIPHY_PAD_SRC].flags = MEDIA_PAD_FL_SOURCE;\n\n\tsd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;\n\tsd->entity.ops = &csiphy_media_ops;\n\tret = media_entity_pads_init(&sd->entity, MSM_CSIPHY_PADS_NUM, pads);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to init media entity: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = v4l2_device_register_subdev(v4l2_dev, sd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register subdev: %d\\n\", ret);\n\t\tmedia_entity_cleanup(&sd->entity);\n\t}\n\n\treturn ret;\n}\n\n \nvoid msm_csiphy_unregister_entity(struct csiphy_device *csiphy)\n{\n\tv4l2_device_unregister_subdev(&csiphy->subdev);\n\tmedia_entity_cleanup(&csiphy->subdev.entity);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}