{
  "module_name": "camss-vfe-gen1.c",
  "hash_id": "e6ad2512427ecd5daf27a0cf93d0da051a40d9bb18ae7a8e9354a3e6fc5795da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/camss/camss-vfe-gen1.c",
  "human_readable_source": "\n \n\n#include \"camss.h\"\n#include \"camss-vfe.h\"\n#include \"camss-vfe-gen1.h\"\n\n \n#define VFE_FRAME_DROP_UPDATES 2\n#define VFE_NEXT_SOF_MS 500\n\nint vfe_gen1_halt(struct vfe_device *vfe)\n{\n\tunsigned long time;\n\n\treinit_completion(&vfe->halt_complete);\n\n\tvfe->ops_gen1->halt_request(vfe);\n\n\ttime = wait_for_completion_timeout(&vfe->halt_complete,\n\t\t\t\t\t   msecs_to_jiffies(VFE_HALT_TIMEOUT_MS));\n\tif (!time) {\n\t\tdev_err(vfe->camss->dev, \"VFE halt timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int vfe_disable_output(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output = &line->output;\n\tconst struct vfe_hw_ops *ops = vfe->ops;\n\tunsigned long flags;\n\tunsigned long time;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\toutput->gen1.wait_sof = 1;\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\ttime = wait_for_completion_timeout(&output->sof, msecs_to_jiffies(VFE_NEXT_SOF_MS));\n\tif (!time)\n\t\tdev_err(vfe->camss->dev, \"VFE sof timeout\\n\");\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\tfor (i = 0; i < output->wm_num; i++)\n\t\tvfe->ops_gen1->wm_enable(vfe, output->wm_idx[i], 0);\n\n\tops->reg_update(vfe, line->id);\n\toutput->wait_reg_update = 1;\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\ttime = wait_for_completion_timeout(&output->reg_update, msecs_to_jiffies(VFE_NEXT_SOF_MS));\n\tif (!time)\n\t\tdev_err(vfe->camss->dev, \"VFE reg update timeout\\n\");\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\tif (line->id != VFE_LINE_PIX) {\n\t\tvfe->ops_gen1->wm_frame_based(vfe, output->wm_idx[0], 0);\n\t\tvfe->ops_gen1->bus_disconnect_wm_from_rdi(vfe, output->wm_idx[0], line->id);\n\t\tvfe->ops_gen1->enable_irq_wm_line(vfe, output->wm_idx[0], line->id, 0);\n\t\tvfe->ops_gen1->set_cgc_override(vfe, output->wm_idx[0], 0);\n\t\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\t} else {\n\t\tfor (i = 0; i < output->wm_num; i++) {\n\t\t\tvfe->ops_gen1->wm_line_based(vfe, output->wm_idx[i], NULL, i, 0);\n\t\t\tvfe->ops_gen1->set_cgc_override(vfe, output->wm_idx[i], 0);\n\t\t}\n\n\t\tvfe->ops_gen1->enable_irq_pix_line(vfe, 0, line->id, 0);\n\t\tvfe->ops_gen1->set_module_cfg(vfe, 0);\n\t\tvfe->ops_gen1->set_realign_cfg(vfe, line, 0);\n\t\tvfe->ops_gen1->set_xbar_cfg(vfe, output, 0);\n\t\tvfe->ops_gen1->set_camif_cmd(vfe, 0);\n\n\t\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\t\tvfe->ops_gen1->camif_wait_for_stop(vfe, vfe->camss->dev);\n\t}\n\n\treturn 0;\n}\n\n \nint vfe_gen1_disable(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\n\tvfe_disable_output(line);\n\n\tvfe_put_output(line);\n\n\tmutex_lock(&vfe->stream_lock);\n\n\tif (vfe->stream_count == 1)\n\t\tvfe->ops_gen1->bus_enable_wr_if(vfe, 0);\n\n\tvfe->stream_count--;\n\n\tmutex_unlock(&vfe->stream_lock);\n\n\treturn 0;\n}\n\nstatic void vfe_output_init_addrs(struct vfe_device *vfe,\n\t\t\t\t  struct vfe_output *output, u8 sync,\n\t\t\t\t  struct vfe_line *line)\n{\n\tu32 ping_addr;\n\tu32 pong_addr;\n\tunsigned int i;\n\n\toutput->gen1.active_buf = 0;\n\n\tfor (i = 0; i < output->wm_num; i++) {\n\t\tif (output->buf[0])\n\t\t\tping_addr = output->buf[0]->addr[i];\n\t\telse\n\t\t\tping_addr = 0;\n\n\t\tif (output->buf[1])\n\t\t\tpong_addr = output->buf[1]->addr[i];\n\t\telse\n\t\t\tpong_addr = ping_addr;\n\n\t\tvfe->ops_gen1->wm_set_ping_addr(vfe, output->wm_idx[i], ping_addr);\n\t\tvfe->ops_gen1->wm_set_pong_addr(vfe, output->wm_idx[i], pong_addr);\n\t\tif (sync)\n\t\t\tvfe->ops_gen1->bus_reload_wm(vfe, output->wm_idx[i]);\n\t}\n}\n\nstatic void vfe_output_frame_drop(struct vfe_device *vfe,\n\t\t\t\t  struct vfe_output *output,\n\t\t\t\t  u32 drop_pattern)\n{\n\tu8 drop_period;\n\tunsigned int i;\n\n\t \n\toutput->drop_update_idx++;\n\toutput->drop_update_idx %= VFE_FRAME_DROP_UPDATES;\n\tdrop_period = VFE_FRAME_DROP_VAL + output->drop_update_idx;\n\n\tfor (i = 0; i < output->wm_num; i++) {\n\t\tvfe->ops_gen1->wm_set_framedrop_period(vfe, output->wm_idx[i], drop_period);\n\t\tvfe->ops_gen1->wm_set_framedrop_pattern(vfe, output->wm_idx[i], drop_pattern);\n\t}\n\n\tvfe->ops->reg_update(vfe, container_of(output, struct vfe_line, output)->id);\n}\n\nstatic int vfe_enable_output(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output = &line->output;\n\tconst struct vfe_hw_ops *ops = vfe->ops;\n\tstruct media_entity *sensor;\n\tunsigned long flags;\n\tunsigned int frame_skip = 0;\n\tunsigned int i;\n\tu16 ub_size;\n\n\tub_size = vfe->ops_gen1->get_ub_size(vfe->id);\n\tif (!ub_size)\n\t\treturn -EINVAL;\n\n\tsensor = camss_find_sensor(&line->subdev.entity);\n\tif (sensor) {\n\t\tstruct v4l2_subdev *subdev = media_entity_to_v4l2_subdev(sensor);\n\n\t\tv4l2_subdev_call(subdev, sensor, g_skip_frames, &frame_skip);\n\t\t \n\t\tif (frame_skip > VFE_FRAME_DROP_VAL - 1)\n\t\t\tframe_skip = VFE_FRAME_DROP_VAL - 1;\n\t}\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\tops->reg_update_clear(vfe, line->id);\n\n\tif (output->state > VFE_OUTPUT_RESERVED) {\n\t\tdev_err(vfe->camss->dev, \"Output is not in reserved state %d\\n\", output->state);\n\t\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\toutput->state = VFE_OUTPUT_IDLE;\n\n\toutput->buf[0] = vfe_buf_get_pending(output);\n\toutput->buf[1] = vfe_buf_get_pending(output);\n\n\tif (!output->buf[0] && output->buf[1]) {\n\t\toutput->buf[0] = output->buf[1];\n\t\toutput->buf[1] = NULL;\n\t}\n\n\tif (output->buf[0])\n\t\toutput->state = VFE_OUTPUT_SINGLE;\n\n\tif (output->buf[1])\n\t\toutput->state = VFE_OUTPUT_CONTINUOUS;\n\n\tswitch (output->state) {\n\tcase VFE_OUTPUT_SINGLE:\n\t\tvfe_output_frame_drop(vfe, output, 1 << frame_skip);\n\t\tbreak;\n\tcase VFE_OUTPUT_CONTINUOUS:\n\t\tvfe_output_frame_drop(vfe, output, 3 << frame_skip);\n\t\tbreak;\n\tdefault:\n\t\tvfe_output_frame_drop(vfe, output, 0);\n\t\tbreak;\n\t}\n\n\toutput->sequence = 0;\n\toutput->gen1.wait_sof = 0;\n\toutput->wait_reg_update = 0;\n\treinit_completion(&output->sof);\n\treinit_completion(&output->reg_update);\n\n\tvfe_output_init_addrs(vfe, output, 0, line);\n\n\tif (line->id != VFE_LINE_PIX) {\n\t\tvfe->ops_gen1->set_cgc_override(vfe, output->wm_idx[0], 1);\n\t\tvfe->ops_gen1->enable_irq_wm_line(vfe, output->wm_idx[0], line->id, 1);\n\t\tvfe->ops_gen1->bus_connect_wm_to_rdi(vfe, output->wm_idx[0], line->id);\n\t\tvfe->ops_gen1->wm_set_subsample(vfe, output->wm_idx[0]);\n\t\tvfe->ops_gen1->set_rdi_cid(vfe, line->id, 0);\n\t\tvfe->ops_gen1->wm_set_ub_cfg(vfe, output->wm_idx[0],\n\t\t\t\t\t    (ub_size + 1) * output->wm_idx[0], ub_size);\n\t\tvfe->ops_gen1->wm_frame_based(vfe, output->wm_idx[0], 1);\n\t\tvfe->ops_gen1->wm_enable(vfe, output->wm_idx[0], 1);\n\t\tvfe->ops_gen1->bus_reload_wm(vfe, output->wm_idx[0]);\n\t} else {\n\t\tub_size /= output->wm_num;\n\t\tfor (i = 0; i < output->wm_num; i++) {\n\t\t\tvfe->ops_gen1->set_cgc_override(vfe, output->wm_idx[i], 1);\n\t\t\tvfe->ops_gen1->wm_set_subsample(vfe, output->wm_idx[i]);\n\t\t\tvfe->ops_gen1->wm_set_ub_cfg(vfe, output->wm_idx[i],\n\t\t\t\t\t\t     (ub_size + 1) * output->wm_idx[i], ub_size);\n\t\t\tvfe->ops_gen1->wm_line_based(vfe, output->wm_idx[i],\n\t\t\t\t\t\t     &line->video_out.active_fmt.fmt.pix_mp, i, 1);\n\t\t\tvfe->ops_gen1->wm_enable(vfe, output->wm_idx[i], 1);\n\t\t\tvfe->ops_gen1->bus_reload_wm(vfe, output->wm_idx[i]);\n\t\t}\n\t\tvfe->ops_gen1->enable_irq_pix_line(vfe, 0, line->id, 1);\n\t\tvfe->ops_gen1->set_module_cfg(vfe, 1);\n\t\tvfe->ops_gen1->set_camif_cfg(vfe, line);\n\t\tvfe->ops_gen1->set_realign_cfg(vfe, line, 1);\n\t\tvfe->ops_gen1->set_xbar_cfg(vfe, output, 1);\n\t\tvfe->ops_gen1->set_demux_cfg(vfe, line);\n\t\tvfe->ops_gen1->set_scale_cfg(vfe, line);\n\t\tvfe->ops_gen1->set_crop_cfg(vfe, line);\n\t\tvfe->ops_gen1->set_clamp_cfg(vfe);\n\t\tvfe->ops_gen1->set_camif_cmd(vfe, 1);\n\t}\n\n\tops->reg_update(vfe, line->id);\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\treturn 0;\n}\n\nstatic int vfe_get_output(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output;\n\tstruct v4l2_format *f = &line->video_out.active_fmt;\n\tunsigned long flags;\n\tint i;\n\tint wm_idx;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\toutput = &line->output;\n\tif (output->state > VFE_OUTPUT_RESERVED) {\n\t\tdev_err(vfe->camss->dev, \"Output is running\\n\");\n\t\tgoto error;\n\t}\n\toutput->state = VFE_OUTPUT_RESERVED;\n\n\toutput->gen1.active_buf = 0;\n\n\tswitch (f->fmt.pix_mp.pixelformat) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\t\toutput->wm_num = 2;\n\t\tbreak;\n\tdefault:\n\t\toutput->wm_num = 1;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < output->wm_num; i++) {\n\t\twm_idx = vfe_reserve_wm(vfe, line->id);\n\t\tif (wm_idx < 0) {\n\t\t\tdev_err(vfe->camss->dev, \"Can not reserve wm\\n\");\n\t\t\tgoto error_get_wm;\n\t\t}\n\t\toutput->wm_idx[i] = wm_idx;\n\t}\n\n\toutput->drop_update_idx = 0;\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\treturn 0;\n\nerror_get_wm:\n\tfor (i--; i >= 0; i--)\n\t\tvfe_release_wm(vfe, output->wm_idx[i]);\n\toutput->state = VFE_OUTPUT_OFF;\nerror:\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\treturn -EINVAL;\n}\n\nint vfe_gen1_enable(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tint ret;\n\n\tmutex_lock(&vfe->stream_lock);\n\n\tif (!vfe->stream_count) {\n\t\tvfe->ops_gen1->enable_irq_common(vfe);\n\t\tvfe->ops_gen1->bus_enable_wr_if(vfe, 1);\n\t\tvfe->ops_gen1->set_qos(vfe);\n\t\tvfe->ops_gen1->set_ds(vfe);\n\t}\n\n\tvfe->stream_count++;\n\n\tmutex_unlock(&vfe->stream_lock);\n\n\tret = vfe_get_output(line);\n\tif (ret < 0)\n\t\tgoto error_get_output;\n\n\tret = vfe_enable_output(line);\n\tif (ret < 0)\n\t\tgoto error_enable_output;\n\n\tvfe->was_streaming = 1;\n\n\treturn 0;\n\nerror_enable_output:\n\tvfe_put_output(line);\n\nerror_get_output:\n\tmutex_lock(&vfe->stream_lock);\n\n\tif (vfe->stream_count == 1)\n\t\tvfe->ops_gen1->bus_enable_wr_if(vfe, 0);\n\n\tvfe->stream_count--;\n\n\tmutex_unlock(&vfe->stream_lock);\n\n\treturn ret;\n}\n\nstatic void vfe_output_update_ping_addr(struct vfe_device *vfe,\n\t\t\t\t\tstruct vfe_output *output, u8 sync,\n\t\t\t\t\tstruct vfe_line *line)\n{\n\tu32 addr;\n\tunsigned int i;\n\n\tfor (i = 0; i < output->wm_num; i++) {\n\t\tif (output->buf[0])\n\t\t\taddr = output->buf[0]->addr[i];\n\t\telse\n\t\t\taddr = 0;\n\n\t\tvfe->ops_gen1->wm_set_ping_addr(vfe, output->wm_idx[i], addr);\n\t\tif (sync)\n\t\t\tvfe->ops_gen1->bus_reload_wm(vfe, output->wm_idx[i]);\n\t}\n}\n\nstatic void vfe_output_update_pong_addr(struct vfe_device *vfe,\n\t\t\t\t\tstruct vfe_output *output, u8 sync,\n\t\t\t\t\tstruct vfe_line *line)\n{\n\tu32 addr;\n\tunsigned int i;\n\n\tfor (i = 0; i < output->wm_num; i++) {\n\t\tif (output->buf[1])\n\t\t\taddr = output->buf[1]->addr[i];\n\t\telse\n\t\t\taddr = 0;\n\n\t\tvfe->ops_gen1->wm_set_pong_addr(vfe, output->wm_idx[i], addr);\n\t\tif (sync)\n\t\t\tvfe->ops_gen1->bus_reload_wm(vfe, output->wm_idx[i]);\n\t}\n}\n\nstatic void vfe_buf_update_wm_on_next(struct vfe_device *vfe,\n\t\t\t\t      struct vfe_output *output)\n{\n\tswitch (output->state) {\n\tcase VFE_OUTPUT_CONTINUOUS:\n\t\tvfe_output_frame_drop(vfe, output, 3);\n\t\tbreak;\n\tcase VFE_OUTPUT_SINGLE:\n\tdefault:\n\t\tdev_err_ratelimited(vfe->camss->dev,\n\t\t\t\t    \"Next buf in wrong state! %d\\n\",\n\t\t\t\t    output->state);\n\t\tbreak;\n\t}\n}\n\nstatic void vfe_buf_update_wm_on_last(struct vfe_device *vfe,\n\t\t\t\t      struct vfe_output *output)\n{\n\tswitch (output->state) {\n\tcase VFE_OUTPUT_CONTINUOUS:\n\t\toutput->state = VFE_OUTPUT_SINGLE;\n\t\tvfe_output_frame_drop(vfe, output, 1);\n\t\tbreak;\n\tcase VFE_OUTPUT_SINGLE:\n\t\toutput->state = VFE_OUTPUT_STOPPING;\n\t\tvfe_output_frame_drop(vfe, output, 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err_ratelimited(vfe->camss->dev,\n\t\t\t\t    \"Last buff in wrong state! %d\\n\",\n\t\t\t\t    output->state);\n\t\tbreak;\n\t}\n}\n\nstatic void vfe_buf_update_wm_on_new(struct vfe_device *vfe,\n\t\t\t\t     struct vfe_output *output,\n\t\t\t\t     struct camss_buffer *new_buf,\n\t\t\t\t     struct vfe_line *line)\n{\n\tint inactive_idx;\n\n\tswitch (output->state) {\n\tcase VFE_OUTPUT_SINGLE:\n\t\tinactive_idx = !output->gen1.active_buf;\n\n\t\tif (!output->buf[inactive_idx]) {\n\t\t\toutput->buf[inactive_idx] = new_buf;\n\n\t\t\tif (inactive_idx)\n\t\t\t\tvfe_output_update_pong_addr(vfe, output, 0, line);\n\t\t\telse\n\t\t\t\tvfe_output_update_ping_addr(vfe, output, 0, line);\n\n\t\t\tvfe_output_frame_drop(vfe, output, 3);\n\t\t\toutput->state = VFE_OUTPUT_CONTINUOUS;\n\t\t} else {\n\t\t\tvfe_buf_add_pending(output, new_buf);\n\t\t\tdev_err_ratelimited(vfe->camss->dev,\n\t\t\t\t\t    \"Inactive buffer is busy\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase VFE_OUTPUT_IDLE:\n\t\tif (!output->buf[0]) {\n\t\t\toutput->buf[0] = new_buf;\n\n\t\t\tvfe_output_init_addrs(vfe, output, 1, line);\n\t\t\tvfe_output_frame_drop(vfe, output, 1);\n\n\t\t\toutput->state = VFE_OUTPUT_SINGLE;\n\t\t} else {\n\t\t\tvfe_buf_add_pending(output, new_buf);\n\t\t\tdev_err_ratelimited(vfe->camss->dev,\n\t\t\t\t\t    \"Output idle with buffer set!\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase VFE_OUTPUT_CONTINUOUS:\n\tdefault:\n\t\tvfe_buf_add_pending(output, new_buf);\n\t\tbreak;\n\t}\n}\n\n \nstatic void vfe_isr_halt_ack(struct vfe_device *vfe)\n{\n\tcomplete(&vfe->halt_complete);\n\tvfe->ops_gen1->halt_clear(vfe);\n}\n\n \nstatic void vfe_isr_sof(struct vfe_device *vfe, enum vfe_line_id line_id)\n{\n\tstruct vfe_output *output;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\toutput = &vfe->line[line_id].output;\n\tif (output->gen1.wait_sof) {\n\t\toutput->gen1.wait_sof = 0;\n\t\tcomplete(&output->sof);\n\t}\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n}\n\n \nstatic void vfe_isr_reg_update(struct vfe_device *vfe, enum vfe_line_id line_id)\n{\n\tstruct vfe_output *output;\n\tstruct vfe_line *line = &vfe->line[line_id];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\tvfe->ops->reg_update_clear(vfe, line_id);\n\n\toutput = &line->output;\n\n\tif (output->wait_reg_update) {\n\t\toutput->wait_reg_update = 0;\n\t\tcomplete(&output->reg_update);\n\t\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\t\treturn;\n\t}\n\n\tif (output->state == VFE_OUTPUT_STOPPING) {\n\t\t \n\t\tif (output->last_buffer) {\n\t\t\tvb2_buffer_done(&output->last_buffer->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_DONE);\n\t\t\toutput->last_buffer = NULL;\n\t\t}\n\t\toutput->state = VFE_OUTPUT_IDLE;\n\n\t\t \n\t\t \n\n\t\toutput->buf[0] = vfe_buf_get_pending(output);\n\t\toutput->buf[1] = vfe_buf_get_pending(output);\n\n\t\tif (!output->buf[0] && output->buf[1]) {\n\t\t\toutput->buf[0] = output->buf[1];\n\t\t\toutput->buf[1] = NULL;\n\t\t}\n\n\t\tif (output->buf[0])\n\t\t\toutput->state = VFE_OUTPUT_SINGLE;\n\n\t\tif (output->buf[1])\n\t\t\toutput->state = VFE_OUTPUT_CONTINUOUS;\n\n\t\tswitch (output->state) {\n\t\tcase VFE_OUTPUT_SINGLE:\n\t\t\tvfe_output_frame_drop(vfe, output, 2);\n\t\t\tbreak;\n\t\tcase VFE_OUTPUT_CONTINUOUS:\n\t\t\tvfe_output_frame_drop(vfe, output, 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvfe_output_frame_drop(vfe, output, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tvfe_output_init_addrs(vfe, output, 1, &vfe->line[line_id]);\n\t}\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n}\n\n \nstatic void vfe_isr_wm_done(struct vfe_device *vfe, u8 wm)\n{\n\tstruct camss_buffer *ready_buf;\n\tstruct vfe_output *output;\n\tdma_addr_t *new_addr;\n\tunsigned long flags;\n\tu32 active_index;\n\tu64 ts = ktime_get_ns();\n\tunsigned int i;\n\n\tactive_index = vfe->ops_gen1->wm_get_ping_pong_status(vfe, wm);\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\tif (vfe->wm_output_map[wm] == VFE_LINE_NONE) {\n\t\tdev_err_ratelimited(vfe->camss->dev,\n\t\t\t\t    \"Received wm done for unmapped index\\n\");\n\t\tgoto out_unlock;\n\t}\n\toutput = &vfe->line[vfe->wm_output_map[wm]].output;\n\n\tif (output->gen1.active_buf == active_index && 0) {\n\t\tdev_err_ratelimited(vfe->camss->dev,\n\t\t\t\t    \"Active buffer mismatch!\\n\");\n\t\tgoto out_unlock;\n\t}\n\toutput->gen1.active_buf = active_index;\n\n\tready_buf = output->buf[!active_index];\n\tif (!ready_buf) {\n\t\tdev_err_ratelimited(vfe->camss->dev,\n\t\t\t\t    \"Missing ready buf %d %d!\\n\",\n\t\t\t\t    !active_index, output->state);\n\t\tgoto out_unlock;\n\t}\n\n\tready_buf->vb.vb2_buf.timestamp = ts;\n\tready_buf->vb.sequence = output->sequence++;\n\n\t \n\toutput->buf[!active_index] = vfe_buf_get_pending(output);\n\tif (!output->buf[!active_index]) {\n\t\t \n\t\tnew_addr = ready_buf->addr;\n\t\tvfe_buf_update_wm_on_last(vfe, output);\n\t} else {\n\t\tnew_addr = output->buf[!active_index]->addr;\n\t\tvfe_buf_update_wm_on_next(vfe, output);\n\t}\n\n\tif (active_index)\n\t\tfor (i = 0; i < output->wm_num; i++)\n\t\t\tvfe->ops_gen1->wm_set_ping_addr(vfe, output->wm_idx[i], new_addr[i]);\n\telse\n\t\tfor (i = 0; i < output->wm_num; i++)\n\t\t\tvfe->ops_gen1->wm_set_pong_addr(vfe, output->wm_idx[i], new_addr[i]);\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\tif (output->state == VFE_OUTPUT_STOPPING)\n\t\toutput->last_buffer = ready_buf;\n\telse\n\t\tvb2_buffer_done(&ready_buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\n\treturn;\n\nout_unlock:\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n}\n\n \nstatic int vfe_queue_buffer(struct camss_video *vid, struct camss_buffer *buf)\n{\n\tstruct vfe_line *line = container_of(vid, struct vfe_line, video_out);\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output;\n\tunsigned long flags;\n\n\toutput = &line->output;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\tvfe_buf_update_wm_on_new(vfe, output, buf, line);\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\treturn 0;\n}\n\n#define CALC_WORD(width, M, N) (((width) * (M) + (N) - 1) / (N))\n\nint vfe_word_per_line(u32 format, u32 width)\n{\n\tint val = 0;\n\n\tswitch (format) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\t\tval = CALC_WORD(width, 1, 8);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_YVYU:\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_VYUY:\n\t\tval = CALC_WORD(width, 2, 8);\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nconst struct vfe_isr_ops vfe_isr_ops_gen1 = {\n\t.reset_ack = vfe_isr_reset_ack,\n\t.halt_ack = vfe_isr_halt_ack,\n\t.reg_update = vfe_isr_reg_update,\n\t.sof = vfe_isr_sof,\n\t.comp_done = vfe_isr_comp_done,\n\t.wm_done = vfe_isr_wm_done,\n};\n\nconst struct camss_video_ops vfe_video_ops_gen1 = {\n\t.queue_buffer = vfe_queue_buffer,\n\t.flush_buffers = vfe_flush_buffers,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}