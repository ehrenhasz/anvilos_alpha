{
  "module_name": "camss-vfe-480.c",
  "hash_id": "bf479b307504560ff000b460e718be20c35df167cc5882e5cf00a993933a54df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/camss/camss-vfe-480.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n\n#include \"camss.h\"\n#include \"camss-vfe.h\"\n\n \n#define IS_LITE\t\t(vfe->id >= 2 ? 1 : 0)\n\n#define VFE_HW_VERSION\t\t\t(0x00)\n\n#define VFE_GLOBAL_RESET_CMD\t\t(IS_LITE ? 0x0c : 0x1c)\n#define\t    GLOBAL_RESET_HW_AND_REG\t(IS_LITE ? BIT(1) : BIT(0))\n\n#define VFE_REG_UPDATE_CMD\t\t(IS_LITE ? 0x20 : 0x34)\nstatic inline int reg_update_rdi(struct vfe_device *vfe, int n)\n{\n\treturn IS_LITE ? BIT(n) : BIT(1 + (n));\n}\n\n#define\t    REG_UPDATE_RDI\t\treg_update_rdi\n#define VFE_IRQ_CMD\t\t\t(IS_LITE ? 0x24 : 0x38)\n#define     IRQ_CMD_GLOBAL_CLEAR\tBIT(0)\n\n#define VFE_IRQ_MASK(n)\t\t\t((IS_LITE ? 0x28 : 0x3c) + (n) * 4)\n#define\t    IRQ_MASK_0_RESET_ACK\t(IS_LITE ? BIT(17) : BIT(0))\n#define\t    IRQ_MASK_0_BUS_TOP_IRQ\t(IS_LITE ? BIT(4) : BIT(7))\n#define VFE_IRQ_CLEAR(n)\t\t((IS_LITE ? 0x34 : 0x48) + (n) * 4)\n#define VFE_IRQ_STATUS(n)\t\t((IS_LITE ? 0x40 : 0x54) + (n) * 4)\n\n#define BUS_REG_BASE\t\t\t(IS_LITE ? 0x1a00 : 0xaa00)\n\n#define VFE_BUS_WM_CGC_OVERRIDE\t\t(BUS_REG_BASE + 0x08)\n#define\t\tWM_CGC_OVERRIDE_ALL\t(0x3FFFFFF)\n\n#define VFE_BUS_WM_TEST_BUS_CTRL\t(BUS_REG_BASE + 0xdc)\n\n#define VFE_BUS_IRQ_MASK(n)\t\t(BUS_REG_BASE + 0x18 + (n) * 4)\nstatic inline int bus_irq_mask_0_rdi_rup(struct vfe_device *vfe, int n)\n{\n\treturn IS_LITE ? BIT(n) : BIT(3 + (n));\n}\n\n#define     BUS_IRQ_MASK_0_RDI_RUP\tbus_irq_mask_0_rdi_rup\nstatic inline int bus_irq_mask_0_comp_done(struct vfe_device *vfe, int n)\n{\n\treturn IS_LITE ? BIT(4 + (n)) : BIT(6 + (n));\n}\n\n#define     BUS_IRQ_MASK_0_COMP_DONE\tbus_irq_mask_0_comp_done\n#define VFE_BUS_IRQ_CLEAR(n)\t\t(BUS_REG_BASE + 0x20 + (n) * 4)\n#define VFE_BUS_IRQ_STATUS(n)\t\t(BUS_REG_BASE + 0x28 + (n) * 4)\n#define VFE_BUS_IRQ_CLEAR_GLOBAL\t(BUS_REG_BASE + 0x30)\n\n#define VFE_BUS_WM_CFG(n)\t\t(BUS_REG_BASE + 0x200 + (n) * 0x100)\n#define\t\tWM_CFG_EN\t\t\t(0)\n#define\t\tWM_CFG_MODE\t\t\t(16)\n#define\t\t\tMODE_QCOM_PLAIN\t(0)\n#define\t\t\tMODE_MIPI_RAW\t(1)\n#define VFE_BUS_WM_IMAGE_ADDR(n)\t(BUS_REG_BASE + 0x204 + (n) * 0x100)\n#define VFE_BUS_WM_FRAME_INCR(n)\t(BUS_REG_BASE + 0x208 + (n) * 0x100)\n#define VFE_BUS_WM_IMAGE_CFG_0(n)\t(BUS_REG_BASE + 0x20c + (n) * 0x100)\n#define\t\tWM_IMAGE_CFG_0_DEFAULT_WIDTH\t(0xFFFF)\n#define VFE_BUS_WM_IMAGE_CFG_1(n)\t(BUS_REG_BASE + 0x210 + (n) * 0x100)\n#define VFE_BUS_WM_IMAGE_CFG_2(n)\t(BUS_REG_BASE + 0x214 + (n) * 0x100)\n#define VFE_BUS_WM_PACKER_CFG(n)\t(BUS_REG_BASE + 0x218 + (n) * 0x100)\n#define VFE_BUS_WM_HEADER_ADDR(n)\t(BUS_REG_BASE + 0x220 + (n) * 0x100)\n#define VFE_BUS_WM_HEADER_INCR(n)\t(BUS_REG_BASE + 0x224 + (n) * 0x100)\n#define VFE_BUS_WM_HEADER_CFG(n)\t(BUS_REG_BASE + 0x228 + (n) * 0x100)\n\n#define VFE_BUS_WM_IRQ_SUBSAMPLE_PERIOD(n)\t(BUS_REG_BASE + 0x230 + (n) * 0x100)\n#define VFE_BUS_WM_IRQ_SUBSAMPLE_PATTERN(n)\t(BUS_REG_BASE + 0x234 + (n) * 0x100)\n#define VFE_BUS_WM_FRAMEDROP_PERIOD(n)\t\t(BUS_REG_BASE + 0x238 + (n) * 0x100)\n#define VFE_BUS_WM_FRAMEDROP_PATTERN(n)\t\t(BUS_REG_BASE + 0x23c + (n) * 0x100)\n\n#define VFE_BUS_WM_SYSTEM_CACHE_CFG(n)\t(BUS_REG_BASE + 0x260 + (n) * 0x100)\n#define VFE_BUS_WM_BURST_LIMIT(n)\t(BUS_REG_BASE + 0x264 + (n) * 0x100)\n\n \n#define RDI_WM(n)\t\t\t((IS_LITE ? 0 : 23) + (n))\n#define RDI_COMP_GROUP(n)\t\t((IS_LITE ? 0 : 11) + (n))\n\n#define MAX_VFE_OUTPUT_LINES\t4\n\nstatic u32 vfe_hw_version(struct vfe_device *vfe)\n{\n\tu32 hw_version = readl_relaxed(vfe->base + VFE_HW_VERSION);\n\n\tu32 gen = (hw_version >> 28) & 0xF;\n\tu32 rev = (hw_version >> 16) & 0xFFF;\n\tu32 step = hw_version & 0xFFFF;\n\n\tdev_dbg(vfe->camss->dev, \"VFE HW Version = %u.%u.%u\\n\", gen, rev, step);\n\n\treturn hw_version;\n}\n\nstatic void vfe_global_reset(struct vfe_device *vfe)\n{\n\twritel_relaxed(IRQ_MASK_0_RESET_ACK, vfe->base + VFE_IRQ_MASK(0));\n\twritel_relaxed(GLOBAL_RESET_HW_AND_REG, vfe->base + VFE_GLOBAL_RESET_CMD);\n}\n\nstatic void vfe_wm_start(struct vfe_device *vfe, u8 wm, struct vfe_line *line)\n{\n\tstruct v4l2_pix_format_mplane *pix =\n\t\t&line->video_out.active_fmt.fmt.pix_mp;\n\n\twm = RDI_WM(wm);  \n\n\t \n\twritel_relaxed(WM_CGC_OVERRIDE_ALL, vfe->base + VFE_BUS_WM_CGC_OVERRIDE);\n\n\twritel_relaxed(0x0, vfe->base + VFE_BUS_WM_TEST_BUS_CTRL);\n\n\twritel_relaxed(pix->plane_fmt[0].bytesperline * pix->height,\n\t\t       vfe->base + VFE_BUS_WM_FRAME_INCR(wm));\n\twritel_relaxed(0xf, vfe->base + VFE_BUS_WM_BURST_LIMIT(wm));\n\twritel_relaxed(WM_IMAGE_CFG_0_DEFAULT_WIDTH,\n\t\t       vfe->base + VFE_BUS_WM_IMAGE_CFG_0(wm));\n\twritel_relaxed(pix->plane_fmt[0].bytesperline,\n\t\t       vfe->base + VFE_BUS_WM_IMAGE_CFG_2(wm));\n\twritel_relaxed(0, vfe->base + VFE_BUS_WM_PACKER_CFG(wm));\n\n\t \n\twritel_relaxed(0, vfe->base + VFE_BUS_WM_FRAMEDROP_PERIOD(wm));\n\twritel_relaxed(1, vfe->base + VFE_BUS_WM_FRAMEDROP_PATTERN(wm));\n\twritel_relaxed(0, vfe->base + VFE_BUS_WM_IRQ_SUBSAMPLE_PERIOD(wm));\n\twritel_relaxed(1, vfe->base + VFE_BUS_WM_IRQ_SUBSAMPLE_PATTERN(wm));\n\n\twritel_relaxed(1 << WM_CFG_EN | MODE_MIPI_RAW << WM_CFG_MODE,\n\t\t       vfe->base + VFE_BUS_WM_CFG(wm));\n}\n\nstatic void vfe_wm_stop(struct vfe_device *vfe, u8 wm)\n{\n\twm = RDI_WM(wm);  \n\twritel_relaxed(0, vfe->base + VFE_BUS_WM_CFG(wm));\n}\n\nstatic void vfe_wm_update(struct vfe_device *vfe, u8 wm, u32 addr,\n\t\t\t  struct vfe_line *line)\n{\n\twm = RDI_WM(wm);  \n\twritel_relaxed(addr, vfe->base + VFE_BUS_WM_IMAGE_ADDR(wm));\n}\n\nstatic void vfe_reg_update(struct vfe_device *vfe, enum vfe_line_id line_id)\n{\n\tvfe->reg_update |= REG_UPDATE_RDI(vfe, line_id);\n\twritel_relaxed(vfe->reg_update, vfe->base + VFE_REG_UPDATE_CMD);\n}\n\nstatic inline void vfe_reg_update_clear(struct vfe_device *vfe,\n\t\t\t\t\tenum vfe_line_id line_id)\n{\n\tvfe->reg_update &= ~REG_UPDATE_RDI(vfe, line_id);\n}\n\nstatic void vfe_enable_irq_common(struct vfe_device *vfe)\n{\n\t \n\twritel_relaxed(IRQ_MASK_0_RESET_ACK | IRQ_MASK_0_BUS_TOP_IRQ,\n\t\t       vfe->base + VFE_IRQ_MASK(0));\n}\n\nstatic void vfe_enable_lines_irq(struct vfe_device *vfe)\n{\n\tint i;\n\tu32 bus_irq_mask = 0;\n\n\tfor (i = 0; i < MAX_VFE_OUTPUT_LINES; i++) {\n\t\t \n\t\tif (vfe->line[i].output.state == VFE_OUTPUT_RESERVED ||\n\t\t    vfe->line[i].output.state == VFE_OUTPUT_ON) {\n\t\t\tbus_irq_mask |= BUS_IRQ_MASK_0_RDI_RUP(vfe, i)\n\t\t\t\t\t| BUS_IRQ_MASK_0_COMP_DONE(vfe, RDI_COMP_GROUP(i));\n\t\t\t}\n\t}\n\n\twritel_relaxed(bus_irq_mask, vfe->base + VFE_BUS_IRQ_MASK(0));\n}\n\nstatic void vfe_isr_reg_update(struct vfe_device *vfe, enum vfe_line_id line_id);\nstatic void vfe_isr_wm_done(struct vfe_device *vfe, u8 wm);\n\n \nstatic irqreturn_t vfe_isr(int irq, void *dev)\n{\n\tstruct vfe_device *vfe = dev;\n\tu32 status;\n\tint i;\n\n\tstatus = readl_relaxed(vfe->base + VFE_IRQ_STATUS(0));\n\twritel_relaxed(status, vfe->base + VFE_IRQ_CLEAR(0));\n\twritel_relaxed(IRQ_CMD_GLOBAL_CLEAR, vfe->base + VFE_IRQ_CMD);\n\n\tif (status & IRQ_MASK_0_RESET_ACK)\n\t\tvfe_isr_reset_ack(vfe);\n\n\tif (status & IRQ_MASK_0_BUS_TOP_IRQ) {\n\t\tu32 status = readl_relaxed(vfe->base + VFE_BUS_IRQ_STATUS(0));\n\n\t\twritel_relaxed(status, vfe->base + VFE_BUS_IRQ_CLEAR(0));\n\t\twritel_relaxed(1, vfe->base + VFE_BUS_IRQ_CLEAR_GLOBAL);\n\n\t\t \n\t\tfor (i = 0; i < MSM_VFE_IMAGE_MASTERS_NUM; i++) {\n\t\t\tif (status & BUS_IRQ_MASK_0_RDI_RUP(vfe, i))\n\t\t\t\tvfe_isr_reg_update(vfe, i);\n\n\t\t\tif (status & BUS_IRQ_MASK_0_COMP_DONE(vfe, RDI_COMP_GROUP(i)))\n\t\t\t\tvfe_isr_wm_done(vfe, i);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int vfe_halt(struct vfe_device *vfe)\n{\n\t \n\treturn 0;\n}\n\nstatic int vfe_get_output(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\toutput = &line->output;\n\tif (output->state > VFE_OUTPUT_RESERVED) {\n\t\tdev_err(vfe->camss->dev, \"Output is running\\n\");\n\t\tgoto error;\n\t}\n\n\toutput->wm_num = 1;\n\n\t \n\toutput->wm_idx[0] = line->id;\n\tvfe->wm_output_map[line->id] = line->id;\n\n\toutput->drop_update_idx = 0;\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\treturn 0;\n\nerror:\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\toutput->state = VFE_OUTPUT_OFF;\n\n\treturn -EINVAL;\n}\n\nstatic int vfe_enable_output(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output = &line->output;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\tvfe_reg_update_clear(vfe, line->id);\n\n\tif (output->state > VFE_OUTPUT_RESERVED) {\n\t\tdev_err(vfe->camss->dev, \"Output is not in reserved state %d\\n\",\n\t\t\toutput->state);\n\t\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(output->gen2.active_num);\n\n\toutput->state = VFE_OUTPUT_ON;\n\n\toutput->sequence = 0;\n\toutput->wait_reg_update = 0;\n\treinit_completion(&output->reg_update);\n\n\tvfe_wm_start(vfe, output->wm_idx[0], line);\n\n\tfor (i = 0; i < 2; i++) {\n\t\toutput->buf[i] = vfe_buf_get_pending(output);\n\t\tif (!output->buf[i])\n\t\t\tbreak;\n\t\toutput->gen2.active_num++;\n\t\tvfe_wm_update(vfe, output->wm_idx[0], output->buf[i]->addr[0], line);\n\t}\n\n\tvfe_reg_update(vfe, line->id);\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\treturn 0;\n}\n\nstatic void vfe_disable_output(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output = &line->output;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\tfor (i = 0; i < output->wm_num; i++)\n\t\tvfe_wm_stop(vfe, output->wm_idx[i]);\n\toutput->gen2.active_num = 0;\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\tvfe_reset(vfe);\n}\n\n \nstatic int vfe_enable(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\tint ret;\n\n\tmutex_lock(&vfe->stream_lock);\n\n\tif (!vfe->stream_count)\n\t\tvfe_enable_irq_common(vfe);\n\n\tvfe->stream_count++;\n\n\tvfe_enable_lines_irq(vfe);\n\n\tmutex_unlock(&vfe->stream_lock);\n\n\tret = vfe_get_output(line);\n\tif (ret < 0)\n\t\tgoto error_get_output;\n\n\tret = vfe_enable_output(line);\n\tif (ret < 0)\n\t\tgoto error_enable_output;\n\n\tvfe->was_streaming = 1;\n\n\treturn 0;\n\nerror_enable_output:\n\tvfe_put_output(line);\n\nerror_get_output:\n\tmutex_lock(&vfe->stream_lock);\n\n\tvfe->stream_count--;\n\n\tmutex_unlock(&vfe->stream_lock);\n\n\treturn ret;\n}\n\n \nstatic int vfe_disable(struct vfe_line *line)\n{\n\tstruct vfe_device *vfe = to_vfe(line);\n\n\tvfe_disable_output(line);\n\n\tvfe_put_output(line);\n\n\tmutex_lock(&vfe->stream_lock);\n\n\tvfe->stream_count--;\n\n\tmutex_unlock(&vfe->stream_lock);\n\n\treturn 0;\n}\n\n \nstatic void vfe_isr_reg_update(struct vfe_device *vfe, enum vfe_line_id line_id)\n{\n\tstruct vfe_output *output;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\tvfe_reg_update_clear(vfe, line_id);\n\n\toutput = &vfe->line[line_id].output;\n\n\tif (output->wait_reg_update) {\n\t\toutput->wait_reg_update = 0;\n\t\tcomplete(&output->reg_update);\n\t}\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n}\n\n \nstatic void vfe_isr_wm_done(struct vfe_device *vfe, u8 wm)\n{\n\tstruct vfe_line *line = &vfe->line[vfe->wm_output_map[wm]];\n\tstruct camss_buffer *ready_buf;\n\tstruct vfe_output *output;\n\tunsigned long flags;\n\tu32 index;\n\tu64 ts = ktime_get_ns();\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\tif (vfe->wm_output_map[wm] == VFE_LINE_NONE) {\n\t\tdev_err_ratelimited(vfe->camss->dev,\n\t\t\t\t    \"Received wm done for unmapped index\\n\");\n\t\tgoto out_unlock;\n\t}\n\toutput = &vfe->line[vfe->wm_output_map[wm]].output;\n\n\tready_buf = output->buf[0];\n\tif (!ready_buf) {\n\t\tdev_err_ratelimited(vfe->camss->dev,\n\t\t\t\t    \"Missing ready buf %d!\\n\", output->state);\n\t\tgoto out_unlock;\n\t}\n\n\tready_buf->vb.vb2_buf.timestamp = ts;\n\tready_buf->vb.sequence = output->sequence++;\n\n\tindex = 0;\n\toutput->buf[0] = output->buf[1];\n\tif (output->buf[0])\n\t\tindex = 1;\n\n\toutput->buf[index] = vfe_buf_get_pending(output);\n\n\tif (output->buf[index])\n\t\tvfe_wm_update(vfe, output->wm_idx[0], output->buf[index]->addr[0], line);\n\telse\n\t\toutput->gen2.active_num--;\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\tvb2_buffer_done(&ready_buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\n\treturn;\n\nout_unlock:\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n}\n\n \nstatic void vfe_pm_domain_off(struct vfe_device *vfe)\n{\n\tstruct camss *camss = vfe->camss;\n\n\tif (vfe->id >= camss->vfe_num)\n\t\treturn;\n\n\tdevice_link_del(camss->genpd_link[vfe->id]);\n}\n\n \nstatic int vfe_pm_domain_on(struct vfe_device *vfe)\n{\n\tstruct camss *camss = vfe->camss;\n\tenum vfe_line_id id = vfe->id;\n\n\tif (id >= camss->vfe_num)\n\t\treturn 0;\n\n\tcamss->genpd_link[id] = device_link_add(camss->dev, camss->genpd[id],\n\t\t\t\t\t\tDL_FLAG_STATELESS |\n\t\t\t\t\t\tDL_FLAG_PM_RUNTIME |\n\t\t\t\t\t\tDL_FLAG_RPM_ACTIVE);\n\tif (!camss->genpd_link[id])\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int vfe_queue_buffer(struct camss_video *vid,\n\t\t\t    struct camss_buffer *buf)\n{\n\tstruct vfe_line *line = container_of(vid, struct vfe_line, video_out);\n\tstruct vfe_device *vfe = to_vfe(line);\n\tstruct vfe_output *output;\n\tunsigned long flags;\n\n\toutput = &line->output;\n\n\tspin_lock_irqsave(&vfe->output_lock, flags);\n\n\tif (output->state == VFE_OUTPUT_ON && output->gen2.active_num < 2) {\n\t\toutput->buf[output->gen2.active_num++] = buf;\n\t\tvfe_wm_update(vfe, output->wm_idx[0], buf->addr[0], line);\n\t} else {\n\t\tvfe_buf_add_pending(output, buf);\n\t}\n\n\tspin_unlock_irqrestore(&vfe->output_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct camss_video_ops vfe_video_ops_480 = {\n\t.queue_buffer = vfe_queue_buffer,\n\t.flush_buffers = vfe_flush_buffers,\n};\n\nstatic void vfe_subdev_init(struct device *dev, struct vfe_device *vfe)\n{\n\tvfe->video_ops = vfe_video_ops_480;\n\tvfe->line_num = MAX_VFE_OUTPUT_LINES;\n}\n\nconst struct vfe_hw_ops vfe_ops_480 = {\n\t.global_reset = vfe_global_reset,\n\t.hw_version = vfe_hw_version,\n\t.isr = vfe_isr,\n\t.pm_domain_off = vfe_pm_domain_off,\n\t.pm_domain_on = vfe_pm_domain_on,\n\t.subdev_init = vfe_subdev_init,\n\t.vfe_disable = vfe_disable,\n\t.vfe_enable = vfe_enable,\n\t.vfe_halt = vfe_halt,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}