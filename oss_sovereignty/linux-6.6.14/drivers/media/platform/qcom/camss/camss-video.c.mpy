{
  "module_name": "camss-video.c",
  "hash_id": "f7456e9c6d66777fd6100c8edeb21427031add598abe0a568665bcdd5fdc7752",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/camss/camss-video.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <media/media-entity.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mc.h>\n#include <media/videobuf2-dma-sg.h>\n\n#include \"camss-video.h\"\n#include \"camss.h\"\n\n#define CAMSS_FRAME_MIN_WIDTH\t\t1\n#define CAMSS_FRAME_MAX_WIDTH\t\t8191\n#define CAMSS_FRAME_MIN_HEIGHT\t\t1\n#define CAMSS_FRAME_MAX_HEIGHT_RDI\t8191\n#define CAMSS_FRAME_MAX_HEIGHT_PIX\t4096\n\nstruct fract {\n\tu8 numerator;\n\tu8 denominator;\n};\n\n \nstruct camss_format_info {\n\tu32 code;\n\tu32 pixelformat;\n\tu8 planes;\n\tstruct fract hsub[3];\n\tstruct fract vsub[3];\n\tunsigned int bpp[3];\n};\n\nstatic const struct camss_format_info formats_rdi_8x16[] = {\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_PIX_FMT_UYVY, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, V4L2_PIX_FMT_VYUY, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_PIX_FMT_YUYV, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, V4L2_PIX_FMT_YVYU, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_PIX_FMT_SBGGR8, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_SGBRG8_1X8, V4L2_PIX_FMT_SGBRG8, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, V4L2_PIX_FMT_SGRBG8, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_SRGGB8_1X8, V4L2_PIX_FMT_SRGGB8, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_PIX_FMT_SBGGR10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, V4L2_PIX_FMT_SGBRG10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, V4L2_PIX_FMT_SGRBG10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, V4L2_PIX_FMT_SRGGB10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_SBGGR12_1X12, V4L2_PIX_FMT_SBGGR12P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 12 } },\n\t{ MEDIA_BUS_FMT_SGBRG12_1X12, V4L2_PIX_FMT_SGBRG12P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 12 } },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, V4L2_PIX_FMT_SGRBG12P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 12 } },\n\t{ MEDIA_BUS_FMT_SRGGB12_1X12, V4L2_PIX_FMT_SRGGB12P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 12 } },\n\t{ MEDIA_BUS_FMT_Y10_1X10, V4L2_PIX_FMT_Y10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n};\n\nstatic const struct camss_format_info formats_rdi_8x96[] = {\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_PIX_FMT_UYVY, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, V4L2_PIX_FMT_VYUY, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_PIX_FMT_YUYV, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, V4L2_PIX_FMT_YVYU, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_PIX_FMT_SBGGR8, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_SGBRG8_1X8, V4L2_PIX_FMT_SGBRG8, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, V4L2_PIX_FMT_SGRBG8, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_SRGGB8_1X8, V4L2_PIX_FMT_SRGGB8, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_PIX_FMT_SBGGR10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, V4L2_PIX_FMT_SGBRG10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, V4L2_PIX_FMT_SGRBG10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, V4L2_PIX_FMT_SRGGB10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE, V4L2_PIX_FMT_SBGGR10, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_SBGGR12_1X12, V4L2_PIX_FMT_SBGGR12P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 12 } },\n\t{ MEDIA_BUS_FMT_SGBRG12_1X12, V4L2_PIX_FMT_SGBRG12P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 12 } },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, V4L2_PIX_FMT_SGRBG12P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 12 } },\n\t{ MEDIA_BUS_FMT_SRGGB12_1X12, V4L2_PIX_FMT_SRGGB12P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 12 } },\n\t{ MEDIA_BUS_FMT_SBGGR14_1X14, V4L2_PIX_FMT_SBGGR14P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 14 } },\n\t{ MEDIA_BUS_FMT_SGBRG14_1X14, V4L2_PIX_FMT_SGBRG14P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 14 } },\n\t{ MEDIA_BUS_FMT_SGRBG14_1X14, V4L2_PIX_FMT_SGRBG14P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 14 } },\n\t{ MEDIA_BUS_FMT_SRGGB14_1X14, V4L2_PIX_FMT_SRGGB14P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 14 } },\n\t{ MEDIA_BUS_FMT_Y10_1X10, V4L2_PIX_FMT_Y10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_Y10_2X8_PADHI_LE, V4L2_PIX_FMT_Y10, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n};\n\nstatic const struct camss_format_info formats_rdi_845[] = {\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_PIX_FMT_UYVY, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, V4L2_PIX_FMT_VYUY, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_PIX_FMT_YUYV, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, V4L2_PIX_FMT_YVYU, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_PIX_FMT_SBGGR8, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_SGBRG8_1X8, V4L2_PIX_FMT_SGBRG8, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_SGRBG8_1X8, V4L2_PIX_FMT_SGRBG8, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_SRGGB8_1X8, V4L2_PIX_FMT_SRGGB8, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_PIX_FMT_SBGGR10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_SGBRG10_1X10, V4L2_PIX_FMT_SGBRG10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_SGRBG10_1X10, V4L2_PIX_FMT_SGRBG10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_SRGGB10_1X10, V4L2_PIX_FMT_SRGGB10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE, V4L2_PIX_FMT_SBGGR10, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_SBGGR12_1X12, V4L2_PIX_FMT_SBGGR12P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 12 } },\n\t{ MEDIA_BUS_FMT_SGBRG12_1X12, V4L2_PIX_FMT_SGBRG12P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 12 } },\n\t{ MEDIA_BUS_FMT_SGRBG12_1X12, V4L2_PIX_FMT_SGRBG12P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 12 } },\n\t{ MEDIA_BUS_FMT_SRGGB12_1X12, V4L2_PIX_FMT_SRGGB12P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 12 } },\n\t{ MEDIA_BUS_FMT_SBGGR14_1X14, V4L2_PIX_FMT_SBGGR14P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 14 } },\n\t{ MEDIA_BUS_FMT_SGBRG14_1X14, V4L2_PIX_FMT_SGBRG14P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 14 } },\n\t{ MEDIA_BUS_FMT_SGRBG14_1X14, V4L2_PIX_FMT_SGRBG14P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 14 } },\n\t{ MEDIA_BUS_FMT_SRGGB14_1X14, V4L2_PIX_FMT_SRGGB14P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 14 } },\n\t{ MEDIA_BUS_FMT_Y8_1X8, V4L2_PIX_FMT_GREY, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_Y10_1X10, V4L2_PIX_FMT_Y10P, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 10 } },\n\t{ MEDIA_BUS_FMT_Y10_2X8_PADHI_LE, V4L2_PIX_FMT_Y10, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n};\n\nstatic const struct camss_format_info formats_pix_8x16[] = {\n\t{ MEDIA_BUS_FMT_YUYV8_1_5X8, V4L2_PIX_FMT_NV12, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YVYU8_1_5X8, V4L2_PIX_FMT_NV12, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_UYVY8_1_5X8, V4L2_PIX_FMT_NV12, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_VYUY8_1_5X8, V4L2_PIX_FMT_NV12, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YUYV8_1_5X8, V4L2_PIX_FMT_NV21, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YVYU8_1_5X8, V4L2_PIX_FMT_NV21, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_UYVY8_1_5X8, V4L2_PIX_FMT_NV21, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_VYUY8_1_5X8, V4L2_PIX_FMT_NV21, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_PIX_FMT_NV16, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, V4L2_PIX_FMT_NV16, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_PIX_FMT_NV16, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, V4L2_PIX_FMT_NV16, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_PIX_FMT_NV61, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, V4L2_PIX_FMT_NV61, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_PIX_FMT_NV61, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, V4L2_PIX_FMT_NV61, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n};\n\nstatic const struct camss_format_info formats_pix_8x96[] = {\n\t{ MEDIA_BUS_FMT_YUYV8_1_5X8, V4L2_PIX_FMT_NV12, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YVYU8_1_5X8, V4L2_PIX_FMT_NV12, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_UYVY8_1_5X8, V4L2_PIX_FMT_NV12, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_VYUY8_1_5X8, V4L2_PIX_FMT_NV12, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YUYV8_1_5X8, V4L2_PIX_FMT_NV21, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YVYU8_1_5X8, V4L2_PIX_FMT_NV21, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_UYVY8_1_5X8, V4L2_PIX_FMT_NV21, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_VYUY8_1_5X8, V4L2_PIX_FMT_NV21, 1,\n\t  { { 1, 1 } }, { { 2, 3 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_PIX_FMT_NV16, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, V4L2_PIX_FMT_NV16, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_PIX_FMT_NV16, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, V4L2_PIX_FMT_NV16, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_PIX_FMT_NV61, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, V4L2_PIX_FMT_NV61, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_PIX_FMT_NV61, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, V4L2_PIX_FMT_NV61, 1,\n\t  { { 1, 1 } }, { { 1, 2 } }, { 8 } },\n\t{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_PIX_FMT_UYVY, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_VYUY8_2X8, V4L2_PIX_FMT_VYUY, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_PIX_FMT_YUYV, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n\t{ MEDIA_BUS_FMT_YVYU8_2X8, V4L2_PIX_FMT_YVYU, 1,\n\t  { { 1, 1 } }, { { 1, 1 } }, { 16 } },\n};\n\n \n\nstatic int video_find_format(u32 code, u32 pixelformat,\n\t\t\t     const struct camss_format_info *formats,\n\t\t\t     unsigned int nformats)\n{\n\tint i;\n\n\tfor (i = 0; i < nformats; i++) {\n\t\tif (formats[i].code == code &&\n\t\t    formats[i].pixelformat == pixelformat)\n\t\t\treturn i;\n\t}\n\n\tfor (i = 0; i < nformats; i++)\n\t\tif (formats[i].code == code)\n\t\t\treturn i;\n\n\tWARN_ON(1);\n\n\treturn -EINVAL;\n}\n\n \nstatic int video_mbus_to_pix_mp(const struct v4l2_mbus_framefmt *mbus,\n\t\t\t\tstruct v4l2_pix_format_mplane *pix,\n\t\t\t\tconst struct camss_format_info *f,\n\t\t\t\tunsigned int alignment)\n{\n\tunsigned int i;\n\tu32 bytesperline;\n\n\tmemset(pix, 0, sizeof(*pix));\n\tv4l2_fill_pix_format_mplane(pix, mbus);\n\tpix->pixelformat = f->pixelformat;\n\tpix->num_planes = f->planes;\n\tfor (i = 0; i < pix->num_planes; i++) {\n\t\tbytesperline = pix->width / f->hsub[i].numerator *\n\t\t\tf->hsub[i].denominator * f->bpp[i] / 8;\n\t\tbytesperline = ALIGN(bytesperline, alignment);\n\t\tpix->plane_fmt[i].bytesperline = bytesperline;\n\t\tpix->plane_fmt[i].sizeimage = pix->height /\n\t\t\t\tf->vsub[i].numerator * f->vsub[i].denominator *\n\t\t\t\tbytesperline;\n\t}\n\n\treturn 0;\n}\n\nstatic struct v4l2_subdev *video_remote_subdev(struct camss_video *video,\n\t\t\t\t\t       u32 *pad)\n{\n\tstruct media_pad *remote;\n\n\tremote = media_pad_remote_pad_first(&video->pad);\n\n\tif (!remote || !is_media_entity_v4l2_subdev(remote->entity))\n\t\treturn NULL;\n\n\tif (pad)\n\t\t*pad = remote->index;\n\n\treturn media_entity_to_v4l2_subdev(remote->entity);\n}\n\nstatic int video_get_subdev_format(struct camss_video *video,\n\t\t\t\t   struct v4l2_format *format)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tstruct v4l2_subdev *subdev;\n\tu32 pad;\n\tint ret;\n\n\tsubdev = video_remote_subdev(video, &pad);\n\tif (subdev == NULL)\n\t\treturn -EPIPE;\n\n\tfmt.pad = pad;\n\n\tret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = video_find_format(fmt.format.code,\n\t\t\t\tformat->fmt.pix_mp.pixelformat,\n\t\t\t\tvideo->formats, video->nformats);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tformat->type = video->type;\n\n\treturn video_mbus_to_pix_mp(&fmt.format, &format->fmt.pix_mp,\n\t\t\t\t    &video->formats[ret], video->bpl_alignment);\n}\n\n \n\nstatic int video_queue_setup(struct vb2_queue *q,\n\tunsigned int *num_buffers, unsigned int *num_planes,\n\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct camss_video *video = vb2_get_drv_priv(q);\n\tconst struct v4l2_pix_format_mplane *format =\n\t\t\t\t\t\t&video->active_fmt.fmt.pix_mp;\n\tunsigned int i;\n\n\tif (*num_planes) {\n\t\tif (*num_planes != format->num_planes)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < *num_planes; i++)\n\t\t\tif (sizes[i] < format->plane_fmt[i].sizeimage)\n\t\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\t*num_planes = format->num_planes;\n\n\tfor (i = 0; i < *num_planes; i++)\n\t\tsizes[i] = format->plane_fmt[i].sizeimage;\n\n\treturn 0;\n}\n\nstatic int video_buf_init(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct camss_video *video = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct camss_buffer *buffer = container_of(vbuf, struct camss_buffer,\n\t\t\t\t\t\t   vb);\n\tconst struct v4l2_pix_format_mplane *format =\n\t\t\t\t\t\t&video->active_fmt.fmt.pix_mp;\n\tstruct sg_table *sgt;\n\tunsigned int i;\n\n\tfor (i = 0; i < format->num_planes; i++) {\n\t\tsgt = vb2_dma_sg_plane_desc(vb, i);\n\t\tif (!sgt)\n\t\t\treturn -EFAULT;\n\n\t\tbuffer->addr[i] = sg_dma_address(sgt->sgl);\n\t}\n\n\tif (format->pixelformat == V4L2_PIX_FMT_NV12 ||\n\t\t\tformat->pixelformat == V4L2_PIX_FMT_NV21 ||\n\t\t\tformat->pixelformat == V4L2_PIX_FMT_NV16 ||\n\t\t\tformat->pixelformat == V4L2_PIX_FMT_NV61)\n\t\tbuffer->addr[1] = buffer->addr[0] +\n\t\t\t\tformat->plane_fmt[0].bytesperline *\n\t\t\t\tformat->height;\n\n\treturn 0;\n}\n\nstatic int video_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct camss_video *video = vb2_get_drv_priv(vb->vb2_queue);\n\tconst struct v4l2_pix_format_mplane *format =\n\t\t\t\t\t\t&video->active_fmt.fmt.pix_mp;\n\tunsigned int i;\n\n\tfor (i = 0; i < format->num_planes; i++) {\n\t\tif (format->plane_fmt[i].sizeimage > vb2_plane_size(vb, i))\n\t\t\treturn -EINVAL;\n\n\t\tvb2_set_plane_payload(vb, i, format->plane_fmt[i].sizeimage);\n\t}\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic void video_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct camss_video *video = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct camss_buffer *buffer = container_of(vbuf, struct camss_buffer,\n\t\t\t\t\t\t   vb);\n\n\tvideo->ops->queue_buffer(video, buffer);\n}\n\nstatic int video_check_format(struct camss_video *video)\n{\n\tstruct v4l2_pix_format_mplane *pix = &video->active_fmt.fmt.pix_mp;\n\tstruct v4l2_format format;\n\tstruct v4l2_pix_format_mplane *sd_pix = &format.fmt.pix_mp;\n\tint ret;\n\n\tsd_pix->pixelformat = pix->pixelformat;\n\tret = video_get_subdev_format(video, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pix->pixelformat != sd_pix->pixelformat ||\n\t    pix->height != sd_pix->height ||\n\t    pix->width != sd_pix->width ||\n\t    pix->num_planes != sd_pix->num_planes ||\n\t    pix->field != format.fmt.pix_mp.field)\n\t\treturn -EPIPE;\n\n\treturn 0;\n}\n\nstatic int video_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct camss_video *video = vb2_get_drv_priv(q);\n\tstruct video_device *vdev = &video->vdev;\n\tstruct media_entity *entity;\n\tstruct media_pad *pad;\n\tstruct v4l2_subdev *subdev;\n\tint ret;\n\n\tret = video_device_pipeline_alloc_start(vdev);\n\tif (ret < 0) {\n\t\tdev_err(video->camss->dev, \"Failed to start media pipeline: %d\\n\", ret);\n\t\tgoto flush_buffers;\n\t}\n\n\tret = video_check_format(video);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tentity = &vdev->entity;\n\twhile (1) {\n\t\tpad = &entity->pads[0];\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tbreak;\n\n\t\tpad = media_pad_remote_pad_first(pad);\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tbreak;\n\n\t\tentity = pad->entity;\n\t\tsubdev = media_entity_to_v4l2_subdev(entity);\n\n\t\tret = v4l2_subdev_call(subdev, video, s_stream, 1);\n\t\tif (ret < 0 && ret != -ENOIOCTLCMD)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tvideo_device_pipeline_stop(vdev);\n\nflush_buffers:\n\tvideo->ops->flush_buffers(video, VB2_BUF_STATE_QUEUED);\n\n\treturn ret;\n}\n\nstatic void video_stop_streaming(struct vb2_queue *q)\n{\n\tstruct camss_video *video = vb2_get_drv_priv(q);\n\tstruct video_device *vdev = &video->vdev;\n\tstruct media_entity *entity;\n\tstruct media_pad *pad;\n\tstruct v4l2_subdev *subdev;\n\tint ret;\n\n\tentity = &vdev->entity;\n\twhile (1) {\n\t\tpad = &entity->pads[0];\n\t\tif (!(pad->flags & MEDIA_PAD_FL_SINK))\n\t\t\tbreak;\n\n\t\tpad = media_pad_remote_pad_first(pad);\n\t\tif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\n\t\t\tbreak;\n\n\t\tentity = pad->entity;\n\t\tsubdev = media_entity_to_v4l2_subdev(entity);\n\n\t\tret = v4l2_subdev_call(subdev, video, s_stream, 0);\n\n\t\tif (entity->use_count > 1) {\n\t\t\t \n\t\t\tdev_dbg(video->camss->dev, \"Video pipeline still used, don't stop streaming.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tdev_err(video->camss->dev, \"Video pipeline stop failed: %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvideo_device_pipeline_stop(vdev);\n\n\tvideo->ops->flush_buffers(video, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct vb2_ops msm_video_vb2_q_ops = {\n\t.queue_setup     = video_queue_setup,\n\t.wait_prepare    = vb2_ops_wait_prepare,\n\t.wait_finish     = vb2_ops_wait_finish,\n\t.buf_init        = video_buf_init,\n\t.buf_prepare     = video_buf_prepare,\n\t.buf_queue       = video_buf_queue,\n\t.start_streaming = video_start_streaming,\n\t.stop_streaming  = video_stop_streaming,\n};\n\n \n\nstatic int video_querycap(struct file *file, void *fh,\n\t\t\t  struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, \"qcom-camss\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"Qualcomm Camera Subsystem\", sizeof(cap->card));\n\n\treturn 0;\n}\n\nstatic int video_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tstruct camss_video *video = video_drvdata(file);\n\tint i, j, k;\n\tu32 mcode = f->mbus_code;\n\n\tif (f->type != video->type)\n\t\treturn -EINVAL;\n\n\tif (f->index >= video->nformats)\n\t\treturn -EINVAL;\n\n\t \n\tk = -1;\n\tfor (i = 0; i < video->nformats; i++) {\n\t\tif (mcode != 0 && video->formats[i].code != mcode)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (mcode != 0 && video->formats[j].code != mcode)\n\t\t\t\tcontinue;\n\t\t\tif (video->formats[i].pixelformat ==\n\t\t\t\t\tvideo->formats[j].pixelformat)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j == i)\n\t\t\tk++;\n\n\t\tif (k == f->index)\n\t\t\tbreak;\n\t}\n\n\tif (k == -1 || k < f->index)\n\t\t \n\t\treturn -EINVAL;\n\n\tf->pixelformat = video->formats[i].pixelformat;\n\n\treturn 0;\n}\n\nstatic int video_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t struct v4l2_frmsizeenum *fsize)\n{\n\tstruct camss_video *video = video_drvdata(file);\n\tint i;\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < video->nformats; i++) {\n\t\tif (video->formats[i].pixelformat == fsize->pixel_format)\n\t\t\tbreak;\n\t}\n\n\tif (i == video->nformats)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\tfsize->stepwise.min_width = CAMSS_FRAME_MIN_WIDTH;\n\tfsize->stepwise.max_width = CAMSS_FRAME_MAX_WIDTH;\n\tfsize->stepwise.min_height = CAMSS_FRAME_MIN_HEIGHT;\n\tfsize->stepwise.max_height = (video->line_based) ?\n\t\tCAMSS_FRAME_MAX_HEIGHT_PIX : CAMSS_FRAME_MAX_HEIGHT_RDI;\n\tfsize->stepwise.step_width = 1;\n\tfsize->stepwise.step_height = 1;\n\n\treturn 0;\n}\n\nstatic int video_g_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct camss_video *video = video_drvdata(file);\n\n\t*f = video->active_fmt;\n\n\treturn 0;\n}\n\nstatic int __video_try_fmt(struct camss_video *video, struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp;\n\tconst struct camss_format_info *fi;\n\tstruct v4l2_plane_pix_format *p;\n\tu32 bytesperline[3] = { 0 };\n\tu32 sizeimage[3] = { 0 };\n\tu32 width, height;\n\tu32 bpl, lines;\n\tint i, j;\n\n\tpix_mp = &f->fmt.pix_mp;\n\n\tif (video->line_based)\n\t\tfor (i = 0; i < pix_mp->num_planes && i < 3; i++) {\n\t\t\tp = &pix_mp->plane_fmt[i];\n\t\t\tbytesperline[i] = clamp_t(u32, p->bytesperline,\n\t\t\t\t\t\t  1, 65528);\n\t\t\tsizeimage[i] = clamp_t(u32, p->sizeimage,\n\t\t\t\t\t       bytesperline[i],\n\t\t\t\t\t       bytesperline[i] * CAMSS_FRAME_MAX_HEIGHT_PIX);\n\t\t}\n\n\tfor (j = 0; j < video->nformats; j++)\n\t\tif (pix_mp->pixelformat == video->formats[j].pixelformat)\n\t\t\tbreak;\n\n\tif (j == video->nformats)\n\t\tj = 0;  \n\n\tfi = &video->formats[j];\n\twidth = pix_mp->width;\n\theight = pix_mp->height;\n\n\tmemset(pix_mp, 0, sizeof(*pix_mp));\n\n\tpix_mp->pixelformat = fi->pixelformat;\n\tpix_mp->width = clamp_t(u32, width, 1, CAMSS_FRAME_MAX_WIDTH);\n\tpix_mp->height = clamp_t(u32, height, 1, CAMSS_FRAME_MAX_HEIGHT_RDI);\n\tpix_mp->num_planes = fi->planes;\n\tfor (i = 0; i < pix_mp->num_planes; i++) {\n\t\tbpl = pix_mp->width / fi->hsub[i].numerator *\n\t\t\tfi->hsub[i].denominator * fi->bpp[i] / 8;\n\t\tbpl = ALIGN(bpl, video->bpl_alignment);\n\t\tpix_mp->plane_fmt[i].bytesperline = bpl;\n\t\tpix_mp->plane_fmt[i].sizeimage = pix_mp->height /\n\t\t\tfi->vsub[i].numerator * fi->vsub[i].denominator * bpl;\n\t}\n\n\tpix_mp->field = V4L2_FIELD_NONE;\n\tpix_mp->colorspace = V4L2_COLORSPACE_SRGB;\n\tpix_mp->flags = 0;\n\tpix_mp->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(pix_mp->colorspace);\n\tpix_mp->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true,\n\t\t\t\t\tpix_mp->colorspace, pix_mp->ycbcr_enc);\n\tpix_mp->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(pix_mp->colorspace);\n\n\tif (video->line_based)\n\t\tfor (i = 0; i < pix_mp->num_planes; i++) {\n\t\t\tp = &pix_mp->plane_fmt[i];\n\t\t\tp->bytesperline = clamp_t(u32, p->bytesperline,\n\t\t\t\t\t\t  1, 65528);\n\t\t\tp->sizeimage = clamp_t(u32, p->sizeimage,\n\t\t\t\t\t       p->bytesperline,\n\t\t\t\t\t       p->bytesperline * CAMSS_FRAME_MAX_HEIGHT_PIX);\n\t\t\tlines = p->sizeimage / p->bytesperline;\n\n\t\t\tif (p->bytesperline < bytesperline[i])\n\t\t\t\tp->bytesperline = ALIGN(bytesperline[i], 8);\n\n\t\t\tif (p->sizeimage < p->bytesperline * lines)\n\t\t\t\tp->sizeimage = p->bytesperline * lines;\n\n\t\t\tif (p->sizeimage < sizeimage[i])\n\t\t\t\tp->sizeimage = sizeimage[i];\n\t\t}\n\n\treturn 0;\n}\n\nstatic int video_try_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct camss_video *video = video_drvdata(file);\n\n\treturn __video_try_fmt(video, f);\n}\n\nstatic int video_s_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct camss_video *video = video_drvdata(file);\n\tint ret;\n\n\tif (vb2_is_busy(&video->vb2_q))\n\t\treturn -EBUSY;\n\n\tret = __video_try_fmt(video, f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvideo->active_fmt = *f;\n\n\treturn 0;\n}\n\nstatic int video_enum_input(struct file *file, void *fh,\n\t\t\t    struct v4l2_input *input)\n{\n\tif (input->index > 0)\n\t\treturn -EINVAL;\n\n\tstrscpy(input->name, \"camera\", sizeof(input->name));\n\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\n\treturn 0;\n}\n\nstatic int video_g_input(struct file *file, void *fh, unsigned int *input)\n{\n\t*input = 0;\n\n\treturn 0;\n}\n\nstatic int video_s_input(struct file *file, void *fh, unsigned int input)\n{\n\treturn input == 0 ? 0 : -EINVAL;\n}\n\nstatic const struct v4l2_ioctl_ops msm_vid_ioctl_ops = {\n\t.vidioc_querycap\t\t= video_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= video_enum_fmt,\n\t.vidioc_enum_framesizes\t\t= video_enum_framesizes,\n\t.vidioc_g_fmt_vid_cap_mplane\t= video_g_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane\t= video_s_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane\t= video_try_fmt,\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\t.vidioc_enum_input\t\t= video_enum_input,\n\t.vidioc_g_input\t\t\t= video_g_input,\n\t.vidioc_s_input\t\t\t= video_s_input,\n};\n\n \n\nstatic int video_open(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct camss_video *video = video_drvdata(file);\n\tstruct v4l2_fh *vfh;\n\tint ret;\n\n\tmutex_lock(&video->lock);\n\n\tvfh = kzalloc(sizeof(*vfh), GFP_KERNEL);\n\tif (vfh == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error_alloc;\n\t}\n\n\tv4l2_fh_init(vfh, vdev);\n\tv4l2_fh_add(vfh);\n\n\tfile->private_data = vfh;\n\n\tret = v4l2_pipeline_pm_get(&vdev->entity);\n\tif (ret < 0) {\n\t\tdev_err(video->camss->dev, \"Failed to power up pipeline: %d\\n\",\n\t\t\tret);\n\t\tgoto error_pm_use;\n\t}\n\n\tmutex_unlock(&video->lock);\n\n\treturn 0;\n\nerror_pm_use:\n\tv4l2_fh_release(file);\n\nerror_alloc:\n\tmutex_unlock(&video->lock);\n\n\treturn ret;\n}\n\nstatic int video_release(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tvb2_fop_release(file);\n\n\tv4l2_pipeline_pm_put(&vdev->entity);\n\n\tfile->private_data = NULL;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations msm_vid_fops = {\n\t.owner          = THIS_MODULE,\n\t.unlocked_ioctl = video_ioctl2,\n\t.open           = video_open,\n\t.release        = video_release,\n\t.poll           = vb2_fop_poll,\n\t.mmap\t\t= vb2_fop_mmap,\n\t.read\t\t= vb2_fop_read,\n};\n\n \n\nstatic void msm_video_release(struct video_device *vdev)\n{\n\tstruct camss_video *video = video_get_drvdata(vdev);\n\n\tmedia_entity_cleanup(&vdev->entity);\n\n\tmutex_destroy(&video->q_lock);\n\tmutex_destroy(&video->lock);\n\n\tif (atomic_dec_and_test(&video->camss->ref_count))\n\t\tcamss_delete(video->camss);\n}\n\n \nstatic int msm_video_init_format(struct camss_video *video)\n{\n\tint ret;\n\tstruct v4l2_format format = {\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t\t.fmt.pix_mp = {\n\t\t\t.width = 1920,\n\t\t\t.height = 1080,\n\t\t\t.pixelformat = video->formats[0].pixelformat,\n\t\t},\n\t};\n\n\tret = __video_try_fmt(video, &format);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvideo->active_fmt = format;\n\n\treturn 0;\n}\n\n \n\nint msm_video_register(struct camss_video *video, struct v4l2_device *v4l2_dev,\n\t\t       const char *name, int is_pix)\n{\n\tstruct media_pad *pad = &video->pad;\n\tstruct video_device *vdev;\n\tstruct vb2_queue *q;\n\tint ret;\n\n\tvdev = &video->vdev;\n\n\tmutex_init(&video->q_lock);\n\n\tq = &video->vb2_q;\n\tq->drv_priv = video;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->ops = &msm_video_vb2_q_ops;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tq->io_modes = VB2_DMABUF | VB2_MMAP | VB2_READ;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->buf_struct_size = sizeof(struct camss_buffer);\n\tq->dev = video->camss->dev;\n\tq->lock = &video->q_lock;\n\tret = vb2_queue_init(q);\n\tif (ret < 0) {\n\t\tdev_err(v4l2_dev->dev, \"Failed to init vb2 queue: %d\\n\", ret);\n\t\tgoto error_vb2_init;\n\t}\n\n\tpad->flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&vdev->entity, 1, pad);\n\tif (ret < 0) {\n\t\tdev_err(v4l2_dev->dev, \"Failed to init video entity: %d\\n\",\n\t\t\tret);\n\t\tgoto error_vb2_init;\n\t}\n\n\tmutex_init(&video->lock);\n\n\tif (video->camss->version == CAMSS_8x16) {\n\t\tif (is_pix) {\n\t\t\tvideo->formats = formats_pix_8x16;\n\t\t\tvideo->nformats = ARRAY_SIZE(formats_pix_8x16);\n\t\t} else {\n\t\t\tvideo->formats = formats_rdi_8x16;\n\t\t\tvideo->nformats = ARRAY_SIZE(formats_rdi_8x16);\n\t\t}\n\t} else if (video->camss->version == CAMSS_8x96 ||\n\t\t   video->camss->version == CAMSS_660) {\n\t\tif (is_pix) {\n\t\t\tvideo->formats = formats_pix_8x96;\n\t\t\tvideo->nformats = ARRAY_SIZE(formats_pix_8x96);\n\t\t} else {\n\t\t\tvideo->formats = formats_rdi_8x96;\n\t\t\tvideo->nformats = ARRAY_SIZE(formats_rdi_8x96);\n\t\t}\n\t}  else if (video->camss->version == CAMSS_845 ||\n\t\t    video->camss->version == CAMSS_8250) {\n\t\tvideo->formats = formats_rdi_845;\n\t\tvideo->nformats = ARRAY_SIZE(formats_rdi_845);\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto error_video_register;\n\t}\n\n\tret = msm_video_init_format(video);\n\tif (ret < 0) {\n\t\tdev_err(v4l2_dev->dev, \"Failed to init format: %d\\n\", ret);\n\t\tgoto error_video_register;\n\t}\n\n\tvdev->fops = &msm_vid_fops;\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING\n\t\t\t  | V4L2_CAP_READWRITE | V4L2_CAP_IO_MC;\n\tvdev->ioctl_ops = &msm_vid_ioctl_ops;\n\tvdev->release = msm_video_release;\n\tvdev->v4l2_dev = v4l2_dev;\n\tvdev->vfl_dir = VFL_DIR_RX;\n\tvdev->queue = &video->vb2_q;\n\tvdev->lock = &video->lock;\n\tstrscpy(vdev->name, name, sizeof(vdev->name));\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0) {\n\t\tdev_err(v4l2_dev->dev, \"Failed to register video device: %d\\n\",\n\t\t\tret);\n\t\tgoto error_video_register;\n\t}\n\n\tvideo_set_drvdata(vdev, video);\n\tatomic_inc(&video->camss->ref_count);\n\n\treturn 0;\n\nerror_video_register:\n\tmedia_entity_cleanup(&vdev->entity);\n\tmutex_destroy(&video->lock);\nerror_vb2_init:\n\tmutex_destroy(&video->q_lock);\n\n\treturn ret;\n}\n\nvoid msm_video_unregister(struct camss_video *video)\n{\n\tatomic_inc(&video->camss->ref_count);\n\tvb2_video_unregister_device(&video->vdev);\n\tatomic_dec(&video->camss->ref_count);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}