{
  "module_name": "camss-csid.c",
  "hash_id": "ebc27d78d7749e6fab8585dcb376f7ce772ade34c1da7c8ffdf7b31213a1941b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/camss/camss-csid.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <media/media-entity.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-subdev.h>\n\n#include \"camss-csid.h\"\n#include \"camss-csid-gen1.h\"\n#include \"camss.h\"\n\n \n#define VFE_480_CSID_OFFSET 0x1200\n#define VFE_480_LITE_CSID_OFFSET 0x200\n\n#define MSM_CSID_NAME \"msm_csid\"\n\nconst char * const csid_testgen_modes[] = {\n\t\"Disabled\",\n\t\"Incrementing\",\n\t\"Alternating 0x55/0xAA\",\n\t\"All Zeros 0x00\",\n\t\"All Ones 0xFF\",\n\t\"Pseudo-random Data\",\n\t\"User Specified\",\n\t\"Complex pattern\",\n\t\"Color box\",\n\t\"Color bars\",\n\tNULL\n};\n\nu32 csid_find_code(u32 *codes, unsigned int ncodes,\n\t\t   unsigned int match_format_idx, u32 match_code)\n{\n\tint i;\n\n\tif (!match_code && (match_format_idx >= ncodes))\n\t\treturn 0;\n\n\tfor (i = 0; i < ncodes; i++)\n\t\tif (match_code) {\n\t\t\tif (codes[i] == match_code)\n\t\t\t\treturn match_code;\n\t\t} else {\n\t\t\tif (i == match_format_idx)\n\t\t\t\treturn codes[i];\n\t\t}\n\n\treturn codes[0];\n}\n\nconst struct csid_format *csid_get_fmt_entry(const struct csid_format *formats,\n\t\t\t\t\t     unsigned int nformats,\n\t\t\t\t\t     u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < nformats; i++)\n\t\tif (code == formats[i].code)\n\t\t\treturn &formats[i];\n\n\tWARN(1, \"Unknown format\\n\");\n\n\treturn &formats[0];\n}\n\n \nstatic int csid_set_clock_rates(struct csid_device *csid)\n{\n\tstruct device *dev = csid->camss->dev;\n\tconst struct csid_format *fmt;\n\ts64 link_freq;\n\tint i, j;\n\tint ret;\n\n\tfmt = csid_get_fmt_entry(csid->formats, csid->nformats,\n\t\t\t\t csid->fmt[MSM_CSIPHY_PAD_SINK].code);\n\tlink_freq = camss_get_link_freq(&csid->subdev.entity, fmt->bpp,\n\t\t\t\t\tcsid->phy.lane_cnt);\n\tif (link_freq < 0)\n\t\tlink_freq = 0;\n\n\tfor (i = 0; i < csid->nclocks; i++) {\n\t\tstruct camss_clock *clock = &csid->clock[i];\n\n\t\tif (!strcmp(clock->name, \"csi0\") ||\n\t\t    !strcmp(clock->name, \"csi1\") ||\n\t\t    !strcmp(clock->name, \"csi2\") ||\n\t\t    !strcmp(clock->name, \"csi3\")) {\n\t\t\tu64 min_rate = link_freq / 4;\n\t\t\tlong rate;\n\n\t\t\tcamss_add_clock_margin(&min_rate);\n\n\t\t\tfor (j = 0; j < clock->nfreqs; j++)\n\t\t\t\tif (min_rate < clock->freq[j])\n\t\t\t\t\tbreak;\n\n\t\t\tif (j == clock->nfreqs) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Pixel clock is too high for CSID\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\tif (min_rate == 0)\n\t\t\t\tj = clock->nfreqs - 1;\n\n\t\t\trate = clk_round_rate(clock->clk, clock->freq[j]);\n\t\t\tif (rate < 0) {\n\t\t\t\tdev_err(dev, \"clk round rate failed: %ld\\n\",\n\t\t\t\t\trate);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tret = clk_set_rate(clock->clk, rate);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"clk set rate failed: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else if (clock->nfreqs) {\n\t\t\tclk_set_rate(clock->clk, clock->freq[0]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int csid_set_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct csid_device *csid = v4l2_get_subdevdata(sd);\n\tstruct camss *camss = csid->camss;\n\tstruct device *dev = camss->dev;\n\tstruct vfe_device *vfe = &camss->vfe[csid->id];\n\tu32 version = camss->version;\n\tint ret = 0;\n\n\tif (on) {\n\t\tif (version == CAMSS_8250 || version == CAMSS_845) {\n\t\t\tret = vfe_get(vfe);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regulator_bulk_enable(csid->num_supplies,\n\t\t\t\t\t    csid->supplies);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_sync(dev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = csid_set_clock_rates(csid);\n\t\tif (ret < 0) {\n\t\t\tregulator_bulk_disable(csid->num_supplies,\n\t\t\t\t\t       csid->supplies);\n\t\t\tpm_runtime_put_sync(dev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = camss_enable_clocks(csid->nclocks, csid->clock, dev);\n\t\tif (ret < 0) {\n\t\t\tregulator_bulk_disable(csid->num_supplies,\n\t\t\t\t\t       csid->supplies);\n\t\t\tpm_runtime_put_sync(dev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tcsid->phy.need_vc_update = true;\n\n\t\tenable_irq(csid->irq);\n\n\t\tret = csid->ops->reset(csid);\n\t\tif (ret < 0) {\n\t\t\tdisable_irq(csid->irq);\n\t\t\tcamss_disable_clocks(csid->nclocks, csid->clock);\n\t\t\tregulator_bulk_disable(csid->num_supplies,\n\t\t\t\t\t       csid->supplies);\n\t\t\tpm_runtime_put_sync(dev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tcsid->ops->hw_version(csid);\n\t} else {\n\t\tdisable_irq(csid->irq);\n\t\tcamss_disable_clocks(csid->nclocks, csid->clock);\n\t\tregulator_bulk_disable(csid->num_supplies,\n\t\t\t\t       csid->supplies);\n\t\tpm_runtime_put_sync(dev);\n\t\tif (version == CAMSS_8250 || version == CAMSS_845)\n\t\t\tvfe_put(vfe);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int csid_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct csid_device *csid = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tif (enable) {\n\t\tret = v4l2_ctrl_handler_setup(&csid->ctrls);\n\t\tif (ret < 0) {\n\t\t\tdev_err(csid->camss->dev,\n\t\t\t\t\"could not sync v4l2 controls: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!csid->testgen.enabled &&\n\t\t    !media_pad_remote_pad_first(&csid->pads[MSM_CSID_PAD_SINK]))\n\t\t\treturn -ENOLINK;\n\t}\n\n\tif (csid->phy.need_vc_update) {\n\t\tcsid->ops->configure_stream(csid, enable);\n\t\tcsid->phy.need_vc_update = false;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct v4l2_mbus_framefmt *\n__csid_get_format(struct csid_device *csid,\n\t\t  struct v4l2_subdev_state *sd_state,\n\t\t  unsigned int pad,\n\t\t  enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&csid->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\n\treturn &csid->fmt[pad];\n}\n\n \nstatic void csid_try_format(struct csid_device *csid,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    unsigned int pad,\n\t\t\t    struct v4l2_mbus_framefmt *fmt,\n\t\t\t    enum v4l2_subdev_format_whence which)\n{\n\tunsigned int i;\n\n\tswitch (pad) {\n\tcase MSM_CSID_PAD_SINK:\n\t\t \n\n\t\tfor (i = 0; i < csid->nformats; i++)\n\t\t\tif (fmt->code == csid->formats[i].code)\n\t\t\t\tbreak;\n\n\t\t \n\t\tif (i >= csid->nformats)\n\t\t\tfmt->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\n\t\tfmt->width = clamp_t(u32, fmt->width, 1, 8191);\n\t\tfmt->height = clamp_t(u32, fmt->height, 1, 8191);\n\n\t\tfmt->field = V4L2_FIELD_NONE;\n\t\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\n\t\tbreak;\n\n\tcase MSM_CSID_PAD_SRC:\n\t\tif (csid->testgen_mode->cur.val == 0) {\n\t\t\t \n\t\t\t \n\t\t\tu32 code = fmt->code;\n\n\t\t\t*fmt = *__csid_get_format(csid, sd_state,\n\t\t\t\t\t\t      MSM_CSID_PAD_SINK, which);\n\t\t\tfmt->code = csid->ops->src_pad_code(csid, fmt->code, 0, code);\n\t\t} else {\n\t\t\t \n\t\t\t \n\n\t\t\tfor (i = 0; i < csid->nformats; i++)\n\t\t\t\tif (csid->formats[i].code == fmt->code)\n\t\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (i >= csid->nformats)\n\t\t\t\tfmt->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\n\t\t\tfmt->width = clamp_t(u32, fmt->width, 1, 8191);\n\t\t\tfmt->height = clamp_t(u32, fmt->height, 1, 8191);\n\n\t\t\tfmt->field = V4L2_FIELD_NONE;\n\t\t}\n\t\tbreak;\n\t}\n\n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n}\n\n \nstatic int csid_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t       struct v4l2_subdev_state *sd_state,\n\t\t\t       struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct csid_device *csid = v4l2_get_subdevdata(sd);\n\n\tif (code->pad == MSM_CSID_PAD_SINK) {\n\t\tif (code->index >= csid->nformats)\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = csid->formats[code->index].code;\n\t} else {\n\t\tif (csid->testgen_mode->cur.val == 0) {\n\t\t\tstruct v4l2_mbus_framefmt *sink_fmt;\n\n\t\t\tsink_fmt = __csid_get_format(csid, sd_state,\n\t\t\t\t\t\t     MSM_CSID_PAD_SINK,\n\t\t\t\t\t\t     code->which);\n\n\t\t\tcode->code = csid->ops->src_pad_code(csid, sink_fmt->code,\n\t\t\t\t\t\t       code->index, 0);\n\t\t\tif (!code->code)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (code->index >= csid->nformats)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcode->code = csid->formats[code->index].code;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int csid_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct csid_device *csid = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tcsid_try_format(csid, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tcsid_try_format(csid, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int csid_get_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct csid_device *csid = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __csid_get_format(csid, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\n\treturn 0;\n}\n\n \nstatic int csid_set_format(struct v4l2_subdev *sd,\n\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t   struct v4l2_subdev_format *fmt)\n{\n\tstruct csid_device *csid = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tint i;\n\n\tformat = __csid_get_format(csid, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tcsid_try_format(csid, sd_state, fmt->pad, &fmt->format, fmt->which);\n\t*format = fmt->format;\n\n\t \n\tif (fmt->pad == MSM_CSID_PAD_SINK) {\n\t\tfor (i = MSM_CSID_PAD_FIRST_SRC; i < MSM_CSID_PADS_NUM; ++i) {\n\t\t\tformat = __csid_get_format(csid, sd_state, i, fmt->which);\n\n\t\t\t*format = fmt->format;\n\t\t\tcsid_try_format(csid, sd_state, i, format, fmt->which);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int csid_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.pad = MSM_CSID_PAD_SINK,\n\t\t.which = fh ? V4L2_SUBDEV_FORMAT_TRY :\n\t\t\t      V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.format = {\n\t\t\t.code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t\t.width = 1920,\n\t\t\t.height = 1080\n\t\t}\n\t};\n\n\treturn csid_set_format(sd, fh ? fh->state : NULL, &format);\n}\n\n \nstatic int csid_set_test_pattern(struct csid_device *csid, s32 value)\n{\n\tstruct csid_testgen_config *tg = &csid->testgen;\n\n\t \n\tif (value && media_pad_remote_pad_first(&csid->pads[MSM_CSID_PAD_SINK]))\n\t\treturn -EBUSY;\n\n\ttg->enabled = !!value;\n\n\treturn csid->ops->configure_testgen_pattern(csid, value);\n}\n\n \nstatic int csid_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct csid_device *csid = container_of(ctrl->handler,\n\t\t\t\t\t\tstruct csid_device, ctrls);\n\tint ret = -EINVAL;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_TEST_PATTERN:\n\t\tret = csid_set_test_pattern(csid, ctrl->val);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops csid_ctrl_ops = {\n\t.s_ctrl = csid_s_ctrl,\n};\n\n \nint msm_csid_subdev_init(struct camss *camss, struct csid_device *csid,\n\t\t\t const struct resources *res, u8 id)\n{\n\tstruct device *dev = camss->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint i, j;\n\tint ret;\n\n\tcsid->camss = camss;\n\tcsid->id = id;\n\n\tif (camss->version == CAMSS_8x16) {\n\t\tcsid->ops = &csid_ops_4_1;\n\t} else if (camss->version == CAMSS_8x96 ||\n\t\t   camss->version == CAMSS_660) {\n\t\tcsid->ops = &csid_ops_4_7;\n\t} else if (camss->version == CAMSS_845 ||\n\t\t   camss->version == CAMSS_8250) {\n\t\tcsid->ops = &csid_ops_gen2;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tcsid->ops->subdev_init(csid);\n\n\t \n\n\tif (camss->version == CAMSS_8250) {\n\t\t \n\t\tif (id >= 2)  \n\t\t\tcsid->base = camss->vfe[id].base + VFE_480_LITE_CSID_OFFSET;\n\t\telse\n\t\t\tcsid->base = camss->vfe[id].base + VFE_480_CSID_OFFSET;\n\t} else {\n\t\tcsid->base = devm_platform_ioremap_resource_byname(pdev, res->reg[0]);\n\t\tif (IS_ERR(csid->base))\n\t\t\treturn PTR_ERR(csid->base);\n\t}\n\n\t \n\n\tret = platform_get_irq_byname(pdev, res->interrupt[0]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcsid->irq = ret;\n\tsnprintf(csid->irq_name, sizeof(csid->irq_name), \"%s_%s%d\",\n\t\t dev_name(dev), MSM_CSID_NAME, csid->id);\n\tret = devm_request_irq(dev, csid->irq, csid->ops->isr,\n\t\t\t       IRQF_TRIGGER_RISING | IRQF_NO_AUTOEN,\n\t\t\t       csid->irq_name, csid);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"request_irq failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\tcsid->nclocks = 0;\n\twhile (res->clock[csid->nclocks])\n\t\tcsid->nclocks++;\n\n\tcsid->clock = devm_kcalloc(dev, csid->nclocks, sizeof(*csid->clock),\n\t\t\t\t    GFP_KERNEL);\n\tif (!csid->clock)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < csid->nclocks; i++) {\n\t\tstruct camss_clock *clock = &csid->clock[i];\n\n\t\tclock->clk = devm_clk_get(dev, res->clock[i]);\n\t\tif (IS_ERR(clock->clk))\n\t\t\treturn PTR_ERR(clock->clk);\n\n\t\tclock->name = res->clock[i];\n\n\t\tclock->nfreqs = 0;\n\t\twhile (res->clock_rate[i][clock->nfreqs])\n\t\t\tclock->nfreqs++;\n\n\t\tif (!clock->nfreqs) {\n\t\t\tclock->freq = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tclock->freq = devm_kcalloc(dev,\n\t\t\t\t\t   clock->nfreqs,\n\t\t\t\t\t   sizeof(*clock->freq),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!clock->freq)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (j = 0; j < clock->nfreqs; j++)\n\t\t\tclock->freq[j] = res->clock_rate[i][j];\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(res->regulators); i++) {\n\t\tif (res->regulators[i])\n\t\t\tcsid->num_supplies++;\n\t}\n\n\tif (csid->num_supplies) {\n\t\tcsid->supplies = devm_kmalloc_array(camss->dev,\n\t\t\t\t\t\t    csid->num_supplies,\n\t\t\t\t\t\t    sizeof(*csid->supplies),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!csid->supplies)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < csid->num_supplies; i++)\n\t\tcsid->supplies[i].supply = res->regulators[i];\n\n\tret = devm_regulator_bulk_get(camss->dev, csid->num_supplies,\n\t\t\t\t      csid->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tinit_completion(&csid->reset_complete);\n\n\treturn 0;\n}\n\n \nvoid msm_csid_get_csid_id(struct media_entity *entity, u8 *id)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct csid_device *csid = v4l2_get_subdevdata(sd);\n\n\t*id = csid->id;\n}\n\n \nstatic u32 csid_get_lane_assign(struct csiphy_lanes_cfg *lane_cfg)\n{\n\tu32 lane_assign = 0;\n\tint i;\n\n\tfor (i = 0; i < lane_cfg->num_data; i++)\n\t\tlane_assign |= lane_cfg->data[i].pos << (i * 4);\n\n\treturn lane_assign;\n}\n\n \nstatic int csid_link_setup(struct media_entity *entity,\n\t\t\t   const struct media_pad *local,\n\t\t\t   const struct media_pad *remote, u32 flags)\n{\n\tif (flags & MEDIA_LNK_FL_ENABLED)\n\t\tif (media_pad_remote_pad_first(local))\n\t\t\treturn -EBUSY;\n\n\tif ((local->flags & MEDIA_PAD_FL_SINK) &&\n\t    (flags & MEDIA_LNK_FL_ENABLED)) {\n\t\tstruct v4l2_subdev *sd;\n\t\tstruct csid_device *csid;\n\t\tstruct csiphy_device *csiphy;\n\t\tstruct csiphy_lanes_cfg *lane_cfg;\n\n\t\tsd = media_entity_to_v4l2_subdev(entity);\n\t\tcsid = v4l2_get_subdevdata(sd);\n\n\t\t \n\t\t \n\t\tif (csid->testgen_mode->cur.val != 0)\n\t\t\treturn -EBUSY;\n\n\t\tsd = media_entity_to_v4l2_subdev(remote->entity);\n\t\tcsiphy = v4l2_get_subdevdata(sd);\n\n\t\t \n\t\t \n\t\tif (!csiphy->cfg.csi2)\n\t\t\treturn -EPERM;\n\n\t\tcsid->phy.csiphy_id = csiphy->id;\n\n\t\tlane_cfg = &csiphy->cfg.csi2->lane_cfg;\n\t\tcsid->phy.lane_cnt = lane_cfg->num_data;\n\t\tcsid->phy.lane_assign = csid_get_lane_assign(lane_cfg);\n\t}\n\t \n\tif (local->flags & MEDIA_PAD_FL_SOURCE) {\n\t\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\t\tstruct csid_device *csid = v4l2_get_subdevdata(sd);\n\t\tstruct device *dev = csid->camss->dev;\n\n\t\tif (flags & MEDIA_LNK_FL_ENABLED)\n\t\t\tcsid->phy.en_vc |= BIT(local->index - 1);\n\t\telse\n\t\t\tcsid->phy.en_vc &= ~BIT(local->index - 1);\n\n\t\tcsid->phy.need_vc_update = true;\n\n\t\tdev_dbg(dev, \"%s: Enabled CSID virtual channels mask 0x%x\\n\",\n\t\t\t__func__, csid->phy.en_vc);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops csid_core_ops = {\n\t.s_power = csid_set_power,\n\t.subscribe_event = v4l2_ctrl_subdev_subscribe_event,\n\t.unsubscribe_event = v4l2_event_subdev_unsubscribe,\n};\n\nstatic const struct v4l2_subdev_video_ops csid_video_ops = {\n\t.s_stream = csid_set_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops csid_pad_ops = {\n\t.enum_mbus_code = csid_enum_mbus_code,\n\t.enum_frame_size = csid_enum_frame_size,\n\t.get_fmt = csid_get_format,\n\t.set_fmt = csid_set_format,\n};\n\nstatic const struct v4l2_subdev_ops csid_v4l2_ops = {\n\t.core = &csid_core_ops,\n\t.video = &csid_video_ops,\n\t.pad = &csid_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops csid_v4l2_internal_ops = {\n\t.open = csid_init_formats,\n};\n\nstatic const struct media_entity_operations csid_media_ops = {\n\t.link_setup = csid_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \nint msm_csid_register_entity(struct csid_device *csid,\n\t\t\t     struct v4l2_device *v4l2_dev)\n{\n\tstruct v4l2_subdev *sd = &csid->subdev;\n\tstruct media_pad *pads = csid->pads;\n\tstruct device *dev = csid->camss->dev;\n\tint i;\n\tint ret;\n\n\tv4l2_subdev_init(sd, &csid_v4l2_ops);\n\tsd->internal_ops = &csid_v4l2_internal_ops;\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |\n\t\t     V4L2_SUBDEV_FL_HAS_EVENTS;\n\tsnprintf(sd->name, ARRAY_SIZE(sd->name), \"%s%d\",\n\t\t MSM_CSID_NAME, csid->id);\n\tv4l2_set_subdevdata(sd, csid);\n\n\tret = v4l2_ctrl_handler_init(&csid->ctrls, 1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to init ctrl handler: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcsid->testgen_mode = v4l2_ctrl_new_std_menu_items(&csid->ctrls,\n\t\t\t\t&csid_ctrl_ops, V4L2_CID_TEST_PATTERN,\n\t\t\t\tcsid->testgen.nmodes, 0, 0,\n\t\t\t\tcsid->testgen.modes);\n\n\tif (csid->ctrls.error) {\n\t\tdev_err(dev, \"Failed to init ctrl: %d\\n\", csid->ctrls.error);\n\t\tret = csid->ctrls.error;\n\t\tgoto free_ctrl;\n\t}\n\n\tcsid->subdev.ctrl_handler = &csid->ctrls;\n\n\tret = csid_init_formats(sd, NULL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to init format: %d\\n\", ret);\n\t\tgoto free_ctrl;\n\t}\n\n\tpads[MSM_CSID_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tfor (i = MSM_CSID_PAD_FIRST_SRC; i < MSM_CSID_PADS_NUM; ++i)\n\t\tpads[i].flags = MEDIA_PAD_FL_SOURCE;\n\n\tsd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;\n\tsd->entity.ops = &csid_media_ops;\n\tret = media_entity_pads_init(&sd->entity, MSM_CSID_PADS_NUM, pads);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to init media entity: %d\\n\", ret);\n\t\tgoto free_ctrl;\n\t}\n\n\tret = v4l2_device_register_subdev(v4l2_dev, sd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register subdev: %d\\n\", ret);\n\t\tgoto media_cleanup;\n\t}\n\n\treturn 0;\n\nmedia_cleanup:\n\tmedia_entity_cleanup(&sd->entity);\nfree_ctrl:\n\tv4l2_ctrl_handler_free(&csid->ctrls);\n\n\treturn ret;\n}\n\n \nvoid msm_csid_unregister_entity(struct csid_device *csid)\n{\n\tv4l2_device_unregister_subdev(&csid->subdev);\n\tmedia_entity_cleanup(&csid->subdev.entity);\n\tv4l2_ctrl_handler_free(&csid->ctrls);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}