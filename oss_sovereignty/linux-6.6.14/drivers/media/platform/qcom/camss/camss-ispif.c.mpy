{
  "module_name": "camss-ispif.c",
  "hash_id": "3f03a08b50cd642953b87791717385d245109661ceff6ca41c71fca30d9e33aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/camss/camss-ispif.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <media/media-entity.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-subdev.h>\n\n#include \"camss-ispif.h\"\n#include \"camss.h\"\n\n#define MSM_ISPIF_NAME \"msm_ispif\"\n\n#define ISPIF_RST_CMD_0\t\t\t0x008\n#define ISPIF_RST_CMD_1\t\t\t0x00c\n#define ISPIF_RST_CMD_0_STROBED_RST_EN\t\t(1 << 0)\n#define ISPIF_RST_CMD_0_MISC_LOGIC_RST\t\t(1 << 1)\n#define ISPIF_RST_CMD_0_SW_REG_RST\t\t(1 << 2)\n#define ISPIF_RST_CMD_0_PIX_INTF_0_CSID_RST\t(1 << 3)\n#define ISPIF_RST_CMD_0_PIX_INTF_0_VFE_RST\t(1 << 4)\n#define ISPIF_RST_CMD_0_PIX_INTF_1_CSID_RST\t(1 << 5)\n#define ISPIF_RST_CMD_0_PIX_INTF_1_VFE_RST\t(1 << 6)\n#define ISPIF_RST_CMD_0_RDI_INTF_0_CSID_RST\t(1 << 7)\n#define ISPIF_RST_CMD_0_RDI_INTF_0_VFE_RST\t(1 << 8)\n#define ISPIF_RST_CMD_0_RDI_INTF_1_CSID_RST\t(1 << 9)\n#define ISPIF_RST_CMD_0_RDI_INTF_1_VFE_RST\t(1 << 10)\n#define ISPIF_RST_CMD_0_RDI_INTF_2_CSID_RST\t(1 << 11)\n#define ISPIF_RST_CMD_0_RDI_INTF_2_VFE_RST\t(1 << 12)\n#define ISPIF_RST_CMD_0_PIX_OUTPUT_0_MISR_RST\t(1 << 16)\n#define ISPIF_RST_CMD_0_RDI_OUTPUT_0_MISR_RST\t(1 << 17)\n#define ISPIF_RST_CMD_0_RDI_OUTPUT_1_MISR_RST\t(1 << 18)\n#define ISPIF_RST_CMD_0_RDI_OUTPUT_2_MISR_RST\t(1 << 19)\n#define ISPIF_IRQ_GLOBAL_CLEAR_CMD\t0x01c\n#define ISPIF_VFE_m_CTRL_0(m)\t\t(0x200 + 0x200 * (m))\n#define ISPIF_VFE_m_CTRL_0_PIX0_LINE_BUF_EN\t(1 << 6)\n#define ISPIF_VFE_m_IRQ_MASK_0(m)\t(0x208 + 0x200 * (m))\n#define ISPIF_VFE_m_IRQ_MASK_0_PIX0_ENABLE\t0x00001249\n#define ISPIF_VFE_m_IRQ_MASK_0_PIX0_MASK\t0x00001fff\n#define ISPIF_VFE_m_IRQ_MASK_0_RDI0_ENABLE\t0x02492000\n#define ISPIF_VFE_m_IRQ_MASK_0_RDI0_MASK\t0x03ffe000\n#define ISPIF_VFE_m_IRQ_MASK_1(m)\t(0x20c + 0x200 * (m))\n#define ISPIF_VFE_m_IRQ_MASK_1_PIX1_ENABLE\t0x00001249\n#define ISPIF_VFE_m_IRQ_MASK_1_PIX1_MASK\t0x00001fff\n#define ISPIF_VFE_m_IRQ_MASK_1_RDI1_ENABLE\t0x02492000\n#define ISPIF_VFE_m_IRQ_MASK_1_RDI1_MASK\t0x03ffe000\n#define ISPIF_VFE_m_IRQ_MASK_2(m)\t(0x210 + 0x200 * (m))\n#define ISPIF_VFE_m_IRQ_MASK_2_RDI2_ENABLE\t0x00001249\n#define ISPIF_VFE_m_IRQ_MASK_2_RDI2_MASK\t0x00001fff\n#define ISPIF_VFE_m_IRQ_STATUS_0(m)\t(0x21c + 0x200 * (m))\n#define ISPIF_VFE_m_IRQ_STATUS_0_PIX0_OVERFLOW\t(1 << 12)\n#define ISPIF_VFE_m_IRQ_STATUS_0_RDI0_OVERFLOW\t(1 << 25)\n#define ISPIF_VFE_m_IRQ_STATUS_1(m)\t(0x220 + 0x200 * (m))\n#define ISPIF_VFE_m_IRQ_STATUS_1_PIX1_OVERFLOW\t(1 << 12)\n#define ISPIF_VFE_m_IRQ_STATUS_1_RDI1_OVERFLOW\t(1 << 25)\n#define ISPIF_VFE_m_IRQ_STATUS_2(m)\t(0x224 + 0x200 * (m))\n#define ISPIF_VFE_m_IRQ_STATUS_2_RDI2_OVERFLOW\t(1 << 12)\n#define ISPIF_VFE_m_IRQ_CLEAR_0(m)\t(0x230 + 0x200 * (m))\n#define ISPIF_VFE_m_IRQ_CLEAR_1(m)\t(0x234 + 0x200 * (m))\n#define ISPIF_VFE_m_IRQ_CLEAR_2(m)\t(0x238 + 0x200 * (m))\n#define ISPIF_VFE_m_INTF_INPUT_SEL(m)\t(0x244 + 0x200 * (m))\n#define ISPIF_VFE_m_INTF_CMD_0(m)\t(0x248 + 0x200 * (m))\n#define ISPIF_VFE_m_INTF_CMD_1(m)\t(0x24c + 0x200 * (m))\n#define ISPIF_VFE_m_PIX_INTF_n_CID_MASK(m, n)\t\\\n\t\t\t\t\t(0x254 + 0x200 * (m) + 0x4 * (n))\n#define ISPIF_VFE_m_RDI_INTF_n_CID_MASK(m, n)\t\\\n\t\t\t\t\t(0x264 + 0x200 * (m) + 0x4 * (n))\n \n#define ISPIF_VFE_m_RDI_INTF_n_PACK_CFG_0(m, n)\t\\\n\t\t\t\t\t(0x270 + 0x200 * (m) + 0x4 * (n))\n#define ISPIF_VFE_m_RDI_INTF_n_PACK_CFG_1(m, n)\t\\\n\t\t\t\t\t(0x27c + 0x200 * (m) + 0x4 * (n))\n#define ISPIF_VFE_m_RDI_INTF_n_PACK_CFG_0_CID_c_PLAIN(c)\t\\\n\t\t\t\t\t(1 << ((cid % 8) * 4))\n#define ISPIF_VFE_m_PIX_INTF_n_STATUS(m, n)\t\\\n\t\t\t\t\t(0x2c0 + 0x200 * (m) + 0x4 * (n))\n#define ISPIF_VFE_m_RDI_INTF_n_STATUS(m, n)\t\\\n\t\t\t\t\t(0x2d0 + 0x200 * (m) + 0x4 * (n))\n\n#define CSI_PIX_CLK_MUX_SEL\t\t0x000\n#define CSI_RDI_CLK_MUX_SEL\t\t0x008\n\n#define ISPIF_TIMEOUT_SLEEP_US\t\t1000\n#define ISPIF_TIMEOUT_ALL_US\t\t1000000\n#define ISPIF_RESET_TIMEOUT_MS\t\t500\n\nenum ispif_intf_cmd {\n\tCMD_DISABLE_FRAME_BOUNDARY = 0x0,\n\tCMD_ENABLE_FRAME_BOUNDARY = 0x1,\n\tCMD_DISABLE_IMMEDIATELY = 0x2,\n\tCMD_ALL_DISABLE_IMMEDIATELY = 0xaaaaaaaa,\n\tCMD_ALL_NO_CHANGE = 0xffffffff,\n};\n\nstatic const u32 ispif_formats_8x16[] = {\n\tMEDIA_BUS_FMT_UYVY8_2X8,\n\tMEDIA_BUS_FMT_VYUY8_2X8,\n\tMEDIA_BUS_FMT_YUYV8_2X8,\n\tMEDIA_BUS_FMT_YVYU8_2X8,\n\tMEDIA_BUS_FMT_SBGGR8_1X8,\n\tMEDIA_BUS_FMT_SGBRG8_1X8,\n\tMEDIA_BUS_FMT_SGRBG8_1X8,\n\tMEDIA_BUS_FMT_SRGGB8_1X8,\n\tMEDIA_BUS_FMT_SBGGR10_1X10,\n\tMEDIA_BUS_FMT_SGBRG10_1X10,\n\tMEDIA_BUS_FMT_SGRBG10_1X10,\n\tMEDIA_BUS_FMT_SRGGB10_1X10,\n\tMEDIA_BUS_FMT_SBGGR12_1X12,\n\tMEDIA_BUS_FMT_SGBRG12_1X12,\n\tMEDIA_BUS_FMT_SGRBG12_1X12,\n\tMEDIA_BUS_FMT_SRGGB12_1X12,\n\tMEDIA_BUS_FMT_Y10_1X10,\n};\n\nstatic const u32 ispif_formats_8x96[] = {\n\tMEDIA_BUS_FMT_UYVY8_2X8,\n\tMEDIA_BUS_FMT_VYUY8_2X8,\n\tMEDIA_BUS_FMT_YUYV8_2X8,\n\tMEDIA_BUS_FMT_YVYU8_2X8,\n\tMEDIA_BUS_FMT_SBGGR8_1X8,\n\tMEDIA_BUS_FMT_SGBRG8_1X8,\n\tMEDIA_BUS_FMT_SGRBG8_1X8,\n\tMEDIA_BUS_FMT_SRGGB8_1X8,\n\tMEDIA_BUS_FMT_SBGGR10_1X10,\n\tMEDIA_BUS_FMT_SGBRG10_1X10,\n\tMEDIA_BUS_FMT_SGRBG10_1X10,\n\tMEDIA_BUS_FMT_SRGGB10_1X10,\n\tMEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE,\n\tMEDIA_BUS_FMT_SBGGR12_1X12,\n\tMEDIA_BUS_FMT_SGBRG12_1X12,\n\tMEDIA_BUS_FMT_SGRBG12_1X12,\n\tMEDIA_BUS_FMT_SRGGB12_1X12,\n\tMEDIA_BUS_FMT_SBGGR14_1X14,\n\tMEDIA_BUS_FMT_SGBRG14_1X14,\n\tMEDIA_BUS_FMT_SGRBG14_1X14,\n\tMEDIA_BUS_FMT_SRGGB14_1X14,\n\tMEDIA_BUS_FMT_Y10_1X10,\n\tMEDIA_BUS_FMT_Y10_2X8_PADHI_LE,\n};\n\n \nstatic irqreturn_t ispif_isr_8x96(int irq, void *dev)\n{\n\tstruct ispif_device *ispif = dev;\n\tstruct camss *camss = ispif->camss;\n\tu32 value0, value1, value2, value3, value4, value5;\n\n\tvalue0 = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_STATUS_0(0));\n\tvalue1 = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_STATUS_1(0));\n\tvalue2 = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_STATUS_2(0));\n\tvalue3 = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_STATUS_0(1));\n\tvalue4 = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_STATUS_1(1));\n\tvalue5 = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_STATUS_2(1));\n\n\twritel_relaxed(value0, ispif->base + ISPIF_VFE_m_IRQ_CLEAR_0(0));\n\twritel_relaxed(value1, ispif->base + ISPIF_VFE_m_IRQ_CLEAR_1(0));\n\twritel_relaxed(value2, ispif->base + ISPIF_VFE_m_IRQ_CLEAR_2(0));\n\twritel_relaxed(value3, ispif->base + ISPIF_VFE_m_IRQ_CLEAR_0(1));\n\twritel_relaxed(value4, ispif->base + ISPIF_VFE_m_IRQ_CLEAR_1(1));\n\twritel_relaxed(value5, ispif->base + ISPIF_VFE_m_IRQ_CLEAR_2(1));\n\n\twritel(0x1, ispif->base + ISPIF_IRQ_GLOBAL_CLEAR_CMD);\n\n\tif ((value0 >> 27) & 0x1)\n\t\tcomplete(&ispif->reset_complete[0]);\n\n\tif ((value3 >> 27) & 0x1)\n\t\tcomplete(&ispif->reset_complete[1]);\n\n\tif (unlikely(value0 & ISPIF_VFE_m_IRQ_STATUS_0_PIX0_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE0 pix0 overflow\\n\");\n\n\tif (unlikely(value0 & ISPIF_VFE_m_IRQ_STATUS_0_RDI0_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE0 rdi0 overflow\\n\");\n\n\tif (unlikely(value1 & ISPIF_VFE_m_IRQ_STATUS_1_PIX1_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE0 pix1 overflow\\n\");\n\n\tif (unlikely(value1 & ISPIF_VFE_m_IRQ_STATUS_1_RDI1_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE0 rdi1 overflow\\n\");\n\n\tif (unlikely(value2 & ISPIF_VFE_m_IRQ_STATUS_2_RDI2_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE0 rdi2 overflow\\n\");\n\n\tif (unlikely(value3 & ISPIF_VFE_m_IRQ_STATUS_0_PIX0_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE1 pix0 overflow\\n\");\n\n\tif (unlikely(value3 & ISPIF_VFE_m_IRQ_STATUS_0_RDI0_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE1 rdi0 overflow\\n\");\n\n\tif (unlikely(value4 & ISPIF_VFE_m_IRQ_STATUS_1_PIX1_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE1 pix1 overflow\\n\");\n\n\tif (unlikely(value4 & ISPIF_VFE_m_IRQ_STATUS_1_RDI1_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE1 rdi1 overflow\\n\");\n\n\tif (unlikely(value5 & ISPIF_VFE_m_IRQ_STATUS_2_RDI2_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE1 rdi2 overflow\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ispif_isr_8x16(int irq, void *dev)\n{\n\tstruct ispif_device *ispif = dev;\n\tstruct camss *camss = ispif->camss;\n\tu32 value0, value1, value2;\n\n\tvalue0 = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_STATUS_0(0));\n\tvalue1 = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_STATUS_1(0));\n\tvalue2 = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_STATUS_2(0));\n\n\twritel_relaxed(value0, ispif->base + ISPIF_VFE_m_IRQ_CLEAR_0(0));\n\twritel_relaxed(value1, ispif->base + ISPIF_VFE_m_IRQ_CLEAR_1(0));\n\twritel_relaxed(value2, ispif->base + ISPIF_VFE_m_IRQ_CLEAR_2(0));\n\n\twritel(0x1, ispif->base + ISPIF_IRQ_GLOBAL_CLEAR_CMD);\n\n\tif ((value0 >> 27) & 0x1)\n\t\tcomplete(&ispif->reset_complete[0]);\n\n\tif (unlikely(value0 & ISPIF_VFE_m_IRQ_STATUS_0_PIX0_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE0 pix0 overflow\\n\");\n\n\tif (unlikely(value0 & ISPIF_VFE_m_IRQ_STATUS_0_RDI0_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE0 rdi0 overflow\\n\");\n\n\tif (unlikely(value1 & ISPIF_VFE_m_IRQ_STATUS_1_PIX1_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE0 pix1 overflow\\n\");\n\n\tif (unlikely(value1 & ISPIF_VFE_m_IRQ_STATUS_1_RDI1_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE0 rdi1 overflow\\n\");\n\n\tif (unlikely(value2 & ISPIF_VFE_m_IRQ_STATUS_2_RDI2_OVERFLOW))\n\t\tdev_err_ratelimited(camss->dev, \"VFE0 rdi2 overflow\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ispif_vfe_reset(struct ispif_device *ispif, u8 vfe_id)\n{\n\tstruct camss *camss = ispif->camss;\n\n\tunsigned long time;\n\tu32 val;\n\n\tif (vfe_id > (camss->vfe_num - 1)) {\n\t\tdev_err(camss->dev,\n\t\t\t\"Error: asked reset for invalid VFE%d\\n\", vfe_id);\n\t\treturn -ENOENT;\n\t}\n\n\treinit_completion(&ispif->reset_complete[vfe_id]);\n\n\tval = ISPIF_RST_CMD_0_STROBED_RST_EN |\n\t\tISPIF_RST_CMD_0_MISC_LOGIC_RST |\n\t\tISPIF_RST_CMD_0_SW_REG_RST |\n\t\tISPIF_RST_CMD_0_PIX_INTF_0_CSID_RST |\n\t\tISPIF_RST_CMD_0_PIX_INTF_0_VFE_RST |\n\t\tISPIF_RST_CMD_0_PIX_INTF_1_CSID_RST |\n\t\tISPIF_RST_CMD_0_PIX_INTF_1_VFE_RST |\n\t\tISPIF_RST_CMD_0_RDI_INTF_0_CSID_RST |\n\t\tISPIF_RST_CMD_0_RDI_INTF_0_VFE_RST |\n\t\tISPIF_RST_CMD_0_RDI_INTF_1_CSID_RST |\n\t\tISPIF_RST_CMD_0_RDI_INTF_1_VFE_RST |\n\t\tISPIF_RST_CMD_0_RDI_INTF_2_CSID_RST |\n\t\tISPIF_RST_CMD_0_RDI_INTF_2_VFE_RST |\n\t\tISPIF_RST_CMD_0_PIX_OUTPUT_0_MISR_RST |\n\t\tISPIF_RST_CMD_0_RDI_OUTPUT_0_MISR_RST |\n\t\tISPIF_RST_CMD_0_RDI_OUTPUT_1_MISR_RST |\n\t\tISPIF_RST_CMD_0_RDI_OUTPUT_2_MISR_RST;\n\n\tif (vfe_id == 1)\n\t\twritel_relaxed(val, ispif->base + ISPIF_RST_CMD_1);\n\telse\n\t\twritel_relaxed(val, ispif->base + ISPIF_RST_CMD_0);\n\n\ttime = wait_for_completion_timeout(&ispif->reset_complete[vfe_id],\n\t\tmsecs_to_jiffies(ISPIF_RESET_TIMEOUT_MS));\n\tif (!time) {\n\t\tdev_err(camss->dev,\n\t\t\t\"ISPIF for VFE%d reset timeout\\n\", vfe_id);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ispif_reset(struct ispif_device *ispif, u8 vfe_id)\n{\n\tstruct camss *camss = ispif->camss;\n\tint ret;\n\n\tret = camss_pm_domain_on(camss, PM_DOMAIN_VFE0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = camss_pm_domain_on(camss, PM_DOMAIN_VFE1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = camss_enable_clocks(ispif->nclocks_for_reset,\n\t\t\t\t  ispif->clock_for_reset,\n\t\t\t\t  camss->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ispif_vfe_reset(ispif, vfe_id);\n\tif (ret)\n\t\tdev_dbg(camss->dev, \"ISPIF Reset failed\\n\");\n\n\tcamss_disable_clocks(ispif->nclocks_for_reset, ispif->clock_for_reset);\n\n\tcamss_pm_domain_off(camss, PM_DOMAIN_VFE0);\n\tcamss_pm_domain_off(camss, PM_DOMAIN_VFE1);\n\n\treturn ret;\n}\n\n \nstatic int ispif_set_power(struct v4l2_subdev *sd, int on)\n{\n\tstruct ispif_line *line = v4l2_get_subdevdata(sd);\n\tstruct ispif_device *ispif = line->ispif;\n\tstruct device *dev = ispif->camss->dev;\n\tint ret = 0;\n\n\tmutex_lock(&ispif->power_lock);\n\n\tif (on) {\n\t\tif (ispif->power_count) {\n\t\t\t \n\t\t\tispif->power_count++;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tret = camss_enable_clocks(ispif->nclocks, ispif->clock, dev);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_sync(dev);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = ispif_reset(ispif, line->vfe_id);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_sync(dev);\n\t\t\tcamss_disable_clocks(ispif->nclocks, ispif->clock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tispif->intf_cmd[line->vfe_id].cmd_0 = CMD_ALL_NO_CHANGE;\n\t\tispif->intf_cmd[line->vfe_id].cmd_1 = CMD_ALL_NO_CHANGE;\n\n\t\tispif->power_count++;\n\t} else {\n\t\tif (ispif->power_count == 0) {\n\t\t\tdev_err(dev, \"ispif power off on power_count == 0\\n\");\n\t\t\tgoto exit;\n\t\t} else if (ispif->power_count == 1) {\n\t\t\tcamss_disable_clocks(ispif->nclocks, ispif->clock);\n\t\t\tpm_runtime_put_sync(dev);\n\t\t}\n\n\t\tispif->power_count--;\n\t}\n\nexit:\n\tmutex_unlock(&ispif->power_lock);\n\n\treturn ret;\n}\n\n \nstatic void ispif_select_clk_mux(struct ispif_device *ispif,\n\t\t\t\t enum ispif_intf intf, u8 csid,\n\t\t\t\t u8 vfe, u8 enable)\n{\n\tu32 val;\n\n\tswitch (intf) {\n\tcase PIX0:\n\t\tval = readl_relaxed(ispif->base_clk_mux + CSI_PIX_CLK_MUX_SEL);\n\t\tval &= ~(0xf << (vfe * 8));\n\t\tif (enable)\n\t\t\tval |= (csid << (vfe * 8));\n\t\twritel_relaxed(val, ispif->base_clk_mux + CSI_PIX_CLK_MUX_SEL);\n\t\tbreak;\n\n\tcase RDI0:\n\t\tval = readl_relaxed(ispif->base_clk_mux + CSI_RDI_CLK_MUX_SEL);\n\t\tval &= ~(0xf << (vfe * 12));\n\t\tif (enable)\n\t\t\tval |= (csid << (vfe * 12));\n\t\twritel_relaxed(val, ispif->base_clk_mux + CSI_RDI_CLK_MUX_SEL);\n\t\tbreak;\n\n\tcase PIX1:\n\t\tval = readl_relaxed(ispif->base_clk_mux + CSI_PIX_CLK_MUX_SEL);\n\t\tval &= ~(0xf << (4 + (vfe * 8)));\n\t\tif (enable)\n\t\t\tval |= (csid << (4 + (vfe * 8)));\n\t\twritel_relaxed(val, ispif->base_clk_mux + CSI_PIX_CLK_MUX_SEL);\n\t\tbreak;\n\n\tcase RDI1:\n\t\tval = readl_relaxed(ispif->base_clk_mux + CSI_RDI_CLK_MUX_SEL);\n\t\tval &= ~(0xf << (4 + (vfe * 12)));\n\t\tif (enable)\n\t\t\tval |= (csid << (4 + (vfe * 12)));\n\t\twritel_relaxed(val, ispif->base_clk_mux + CSI_RDI_CLK_MUX_SEL);\n\t\tbreak;\n\n\tcase RDI2:\n\t\tval = readl_relaxed(ispif->base_clk_mux + CSI_RDI_CLK_MUX_SEL);\n\t\tval &= ~(0xf << (8 + (vfe * 12)));\n\t\tif (enable)\n\t\t\tval |= (csid << (8 + (vfe * 12)));\n\t\twritel_relaxed(val, ispif->base_clk_mux + CSI_RDI_CLK_MUX_SEL);\n\t\tbreak;\n\t}\n\n\tmb();\n}\n\n \nstatic int ispif_validate_intf_status(struct ispif_device *ispif,\n\t\t\t\t      enum ispif_intf intf, u8 vfe)\n{\n\tint ret = 0;\n\tu32 val = 0;\n\n\tswitch (intf) {\n\tcase PIX0:\n\t\tval = readl_relaxed(ispif->base +\n\t\t\tISPIF_VFE_m_PIX_INTF_n_STATUS(vfe, 0));\n\t\tbreak;\n\tcase RDI0:\n\t\tval = readl_relaxed(ispif->base +\n\t\t\tISPIF_VFE_m_RDI_INTF_n_STATUS(vfe, 0));\n\t\tbreak;\n\tcase PIX1:\n\t\tval = readl_relaxed(ispif->base +\n\t\t\tISPIF_VFE_m_PIX_INTF_n_STATUS(vfe, 1));\n\t\tbreak;\n\tcase RDI1:\n\t\tval = readl_relaxed(ispif->base +\n\t\t\tISPIF_VFE_m_RDI_INTF_n_STATUS(vfe, 1));\n\t\tbreak;\n\tcase RDI2:\n\t\tval = readl_relaxed(ispif->base +\n\t\t\tISPIF_VFE_m_RDI_INTF_n_STATUS(vfe, 2));\n\t\tbreak;\n\t}\n\n\tif ((val & 0xf) != 0xf) {\n\t\tdev_err(ispif->camss->dev, \"%s: ispif is busy: 0x%x\\n\",\n\t\t\t__func__, val);\n\t\tret = -EBUSY;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ispif_wait_for_stop(struct ispif_device *ispif,\n\t\t\t       enum ispif_intf intf, u8 vfe)\n{\n\tu32 addr = 0;\n\tu32 stop_flag = 0;\n\tint ret;\n\n\tswitch (intf) {\n\tcase PIX0:\n\t\taddr = ISPIF_VFE_m_PIX_INTF_n_STATUS(vfe, 0);\n\t\tbreak;\n\tcase RDI0:\n\t\taddr = ISPIF_VFE_m_RDI_INTF_n_STATUS(vfe, 0);\n\t\tbreak;\n\tcase PIX1:\n\t\taddr = ISPIF_VFE_m_PIX_INTF_n_STATUS(vfe, 1);\n\t\tbreak;\n\tcase RDI1:\n\t\taddr = ISPIF_VFE_m_RDI_INTF_n_STATUS(vfe, 1);\n\t\tbreak;\n\tcase RDI2:\n\t\taddr = ISPIF_VFE_m_RDI_INTF_n_STATUS(vfe, 2);\n\t\tbreak;\n\t}\n\n\tret = readl_poll_timeout(ispif->base + addr,\n\t\t\t\t stop_flag,\n\t\t\t\t (stop_flag & 0xf) == 0xf,\n\t\t\t\t ISPIF_TIMEOUT_SLEEP_US,\n\t\t\t\t ISPIF_TIMEOUT_ALL_US);\n\tif (ret < 0)\n\t\tdev_err(ispif->camss->dev, \"%s: ispif stop timeout\\n\",\n\t\t\t__func__);\n\n\treturn ret;\n}\n\n \nstatic void ispif_select_csid(struct ispif_device *ispif, enum ispif_intf intf,\n\t\t\t      u8 csid, u8 vfe, u8 enable)\n{\n\tu32 val;\n\n\tval = readl_relaxed(ispif->base + ISPIF_VFE_m_INTF_INPUT_SEL(vfe));\n\tswitch (intf) {\n\tcase PIX0:\n\t\tval &= ~(BIT(1) | BIT(0));\n\t\tif (enable)\n\t\t\tval |= csid;\n\t\tbreak;\n\tcase RDI0:\n\t\tval &= ~(BIT(5) | BIT(4));\n\t\tif (enable)\n\t\t\tval |= (csid << 4);\n\t\tbreak;\n\tcase PIX1:\n\t\tval &= ~(BIT(9) | BIT(8));\n\t\tif (enable)\n\t\t\tval |= (csid << 8);\n\t\tbreak;\n\tcase RDI1:\n\t\tval &= ~(BIT(13) | BIT(12));\n\t\tif (enable)\n\t\t\tval |= (csid << 12);\n\t\tbreak;\n\tcase RDI2:\n\t\tval &= ~(BIT(21) | BIT(20));\n\t\tif (enable)\n\t\t\tval |= (csid << 20);\n\t\tbreak;\n\t}\n\n\twritel(val, ispif->base + ISPIF_VFE_m_INTF_INPUT_SEL(vfe));\n}\n\n \nstatic void ispif_select_cid(struct ispif_device *ispif, enum ispif_intf intf,\n\t\t\t     u8 cid, u8 vfe, u8 enable)\n{\n\tu32 cid_mask = 1 << cid;\n\tu32 addr = 0;\n\tu32 val;\n\n\tswitch (intf) {\n\tcase PIX0:\n\t\taddr = ISPIF_VFE_m_PIX_INTF_n_CID_MASK(vfe, 0);\n\t\tbreak;\n\tcase RDI0:\n\t\taddr = ISPIF_VFE_m_RDI_INTF_n_CID_MASK(vfe, 0);\n\t\tbreak;\n\tcase PIX1:\n\t\taddr = ISPIF_VFE_m_PIX_INTF_n_CID_MASK(vfe, 1);\n\t\tbreak;\n\tcase RDI1:\n\t\taddr = ISPIF_VFE_m_RDI_INTF_n_CID_MASK(vfe, 1);\n\t\tbreak;\n\tcase RDI2:\n\t\taddr = ISPIF_VFE_m_RDI_INTF_n_CID_MASK(vfe, 2);\n\t\tbreak;\n\t}\n\n\tval = readl_relaxed(ispif->base + addr);\n\tif (enable)\n\t\tval |= cid_mask;\n\telse\n\t\tval &= ~cid_mask;\n\n\twritel(val, ispif->base + addr);\n}\n\n \nstatic void ispif_config_irq(struct ispif_device *ispif, enum ispif_intf intf,\n\t\t\t     u8 vfe, u8 enable)\n{\n\tu32 val;\n\n\tswitch (intf) {\n\tcase PIX0:\n\t\tval = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_MASK_0(vfe));\n\t\tval &= ~ISPIF_VFE_m_IRQ_MASK_0_PIX0_MASK;\n\t\tif (enable)\n\t\t\tval |= ISPIF_VFE_m_IRQ_MASK_0_PIX0_ENABLE;\n\t\twritel_relaxed(val, ispif->base + ISPIF_VFE_m_IRQ_MASK_0(vfe));\n\t\twritel_relaxed(ISPIF_VFE_m_IRQ_MASK_0_PIX0_ENABLE,\n\t\t\t       ispif->base + ISPIF_VFE_m_IRQ_CLEAR_0(vfe));\n\t\tbreak;\n\tcase RDI0:\n\t\tval = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_MASK_0(vfe));\n\t\tval &= ~ISPIF_VFE_m_IRQ_MASK_0_RDI0_MASK;\n\t\tif (enable)\n\t\t\tval |= ISPIF_VFE_m_IRQ_MASK_0_RDI0_ENABLE;\n\t\twritel_relaxed(val, ispif->base + ISPIF_VFE_m_IRQ_MASK_0(vfe));\n\t\twritel_relaxed(ISPIF_VFE_m_IRQ_MASK_0_RDI0_ENABLE,\n\t\t\t       ispif->base + ISPIF_VFE_m_IRQ_CLEAR_0(vfe));\n\t\tbreak;\n\tcase PIX1:\n\t\tval = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_MASK_1(vfe));\n\t\tval &= ~ISPIF_VFE_m_IRQ_MASK_1_PIX1_MASK;\n\t\tif (enable)\n\t\t\tval |= ISPIF_VFE_m_IRQ_MASK_1_PIX1_ENABLE;\n\t\twritel_relaxed(val, ispif->base + ISPIF_VFE_m_IRQ_MASK_1(vfe));\n\t\twritel_relaxed(ISPIF_VFE_m_IRQ_MASK_1_PIX1_ENABLE,\n\t\t\t       ispif->base + ISPIF_VFE_m_IRQ_CLEAR_1(vfe));\n\t\tbreak;\n\tcase RDI1:\n\t\tval = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_MASK_1(vfe));\n\t\tval &= ~ISPIF_VFE_m_IRQ_MASK_1_RDI1_MASK;\n\t\tif (enable)\n\t\t\tval |= ISPIF_VFE_m_IRQ_MASK_1_RDI1_ENABLE;\n\t\twritel_relaxed(val, ispif->base + ISPIF_VFE_m_IRQ_MASK_1(vfe));\n\t\twritel_relaxed(ISPIF_VFE_m_IRQ_MASK_1_RDI1_ENABLE,\n\t\t\t       ispif->base + ISPIF_VFE_m_IRQ_CLEAR_1(vfe));\n\t\tbreak;\n\tcase RDI2:\n\t\tval = readl_relaxed(ispif->base + ISPIF_VFE_m_IRQ_MASK_2(vfe));\n\t\tval &= ~ISPIF_VFE_m_IRQ_MASK_2_RDI2_MASK;\n\t\tif (enable)\n\t\t\tval |= ISPIF_VFE_m_IRQ_MASK_2_RDI2_ENABLE;\n\t\twritel_relaxed(val, ispif->base + ISPIF_VFE_m_IRQ_MASK_2(vfe));\n\t\twritel_relaxed(ISPIF_VFE_m_IRQ_MASK_2_RDI2_ENABLE,\n\t\t\t       ispif->base + ISPIF_VFE_m_IRQ_CLEAR_2(vfe));\n\t\tbreak;\n\t}\n\n\twritel(0x1, ispif->base + ISPIF_IRQ_GLOBAL_CLEAR_CMD);\n}\n\n \nstatic void ispif_config_pack(struct ispif_device *ispif, u32 code,\n\t\t\t      enum ispif_intf intf, u8 cid, u8 vfe, u8 enable)\n{\n\tu32 addr, val;\n\n\tif (code != MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE &&\n\t    code != MEDIA_BUS_FMT_Y10_2X8_PADHI_LE)\n\t\treturn;\n\n\tswitch (intf) {\n\tcase RDI0:\n\t\tif (cid < 8)\n\t\t\taddr = ISPIF_VFE_m_RDI_INTF_n_PACK_CFG_0(vfe, 0);\n\t\telse\n\t\t\taddr = ISPIF_VFE_m_RDI_INTF_n_PACK_CFG_1(vfe, 0);\n\t\tbreak;\n\tcase RDI1:\n\t\tif (cid < 8)\n\t\t\taddr = ISPIF_VFE_m_RDI_INTF_n_PACK_CFG_0(vfe, 1);\n\t\telse\n\t\t\taddr = ISPIF_VFE_m_RDI_INTF_n_PACK_CFG_1(vfe, 1);\n\t\tbreak;\n\tcase RDI2:\n\t\tif (cid < 8)\n\t\t\taddr = ISPIF_VFE_m_RDI_INTF_n_PACK_CFG_0(vfe, 2);\n\t\telse\n\t\t\taddr = ISPIF_VFE_m_RDI_INTF_n_PACK_CFG_1(vfe, 2);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (enable)\n\t\tval = ISPIF_VFE_m_RDI_INTF_n_PACK_CFG_0_CID_c_PLAIN(cid);\n\telse\n\t\tval = 0;\n\n\twritel_relaxed(val, ispif->base + addr);\n}\n\n \nstatic void ispif_set_intf_cmd(struct ispif_device *ispif, u8 cmd,\n\t\t\t       enum ispif_intf intf, u8 vfe, u8 vc)\n{\n\tu32 *val;\n\n\tif (intf == RDI2) {\n\t\tval = &ispif->intf_cmd[vfe].cmd_1;\n\t\t*val &= ~(0x3 << (vc * 2 + 8));\n\t\t*val |= (cmd << (vc * 2 + 8));\n\t\twmb();\n\t\twritel_relaxed(*val, ispif->base + ISPIF_VFE_m_INTF_CMD_1(vfe));\n\t\twmb();\n\t} else {\n\t\tval = &ispif->intf_cmd[vfe].cmd_0;\n\t\t*val &= ~(0x3 << (vc * 2 + intf * 8));\n\t\t*val |= (cmd << (vc * 2 + intf * 8));\n\t\twmb();\n\t\twritel_relaxed(*val, ispif->base + ISPIF_VFE_m_INTF_CMD_0(vfe));\n\t\twmb();\n\t}\n}\n\n \nstatic int ispif_set_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct ispif_line *line = v4l2_get_subdevdata(sd);\n\tstruct ispif_device *ispif = line->ispif;\n\tstruct camss *camss = ispif->camss;\n\tenum ispif_intf intf = line->interface;\n\tu8 csid = line->csid_id;\n\tu8 vfe = line->vfe_id;\n\tu8 vc = 0;  \n\tu8 cid = vc * 4;  \n\tint ret;\n\n\tif (enable) {\n\t\tif (!media_pad_remote_pad_first(&line->pads[MSM_ISPIF_PAD_SINK]))\n\t\t\treturn -ENOLINK;\n\n\t\t \n\n\t\tmutex_lock(&ispif->config_lock);\n\t\tispif_select_clk_mux(ispif, intf, csid, vfe, 1);\n\n\t\tret = ispif_validate_intf_status(ispif, intf, vfe);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&ispif->config_lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\tispif_select_csid(ispif, intf, csid, vfe, 1);\n\t\tispif_select_cid(ispif, intf, cid, vfe, 1);\n\t\tispif_config_irq(ispif, intf, vfe, 1);\n\t\tif (camss->version == CAMSS_8x96 ||\n\t\t    camss->version == CAMSS_660)\n\t\t\tispif_config_pack(ispif,\n\t\t\t\t\t  line->fmt[MSM_ISPIF_PAD_SINK].code,\n\t\t\t\t\t  intf, cid, vfe, 1);\n\t\tispif_set_intf_cmd(ispif, CMD_ENABLE_FRAME_BOUNDARY,\n\t\t\t\t   intf, vfe, vc);\n\t} else {\n\t\tmutex_lock(&ispif->config_lock);\n\t\tispif_set_intf_cmd(ispif, CMD_DISABLE_FRAME_BOUNDARY,\n\t\t\t\t   intf, vfe, vc);\n\t\tmutex_unlock(&ispif->config_lock);\n\n\t\tret = ispif_wait_for_stop(ispif, intf, vfe);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&ispif->config_lock);\n\t\tif (camss->version == CAMSS_8x96 ||\n\t\t    camss->version == CAMSS_660)\n\t\t\tispif_config_pack(ispif,\n\t\t\t\t\t  line->fmt[MSM_ISPIF_PAD_SINK].code,\n\t\t\t\t\t  intf, cid, vfe, 0);\n\t\tispif_config_irq(ispif, intf, vfe, 0);\n\t\tispif_select_cid(ispif, intf, cid, vfe, 0);\n\t\tispif_select_csid(ispif, intf, csid, vfe, 0);\n\t\tispif_select_clk_mux(ispif, intf, csid, vfe, 0);\n\t}\n\n\tmutex_unlock(&ispif->config_lock);\n\n\treturn 0;\n}\n\n \nstatic struct v4l2_mbus_framefmt *\n__ispif_get_format(struct ispif_line *line,\n\t\t   struct v4l2_subdev_state *sd_state,\n\t\t   unsigned int pad,\n\t\t   enum v4l2_subdev_format_whence which)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_TRY)\n\t\treturn v4l2_subdev_get_try_format(&line->subdev, sd_state,\n\t\t\t\t\t\t  pad);\n\n\treturn &line->fmt[pad];\n}\n\n \nstatic void ispif_try_format(struct ispif_line *line,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     unsigned int pad,\n\t\t\t     struct v4l2_mbus_framefmt *fmt,\n\t\t\t     enum v4l2_subdev_format_whence which)\n{\n\tunsigned int i;\n\n\tswitch (pad) {\n\tcase MSM_ISPIF_PAD_SINK:\n\t\t \n\n\t\tfor (i = 0; i < line->nformats; i++)\n\t\t\tif (fmt->code == line->formats[i])\n\t\t\t\tbreak;\n\n\t\t \n\t\tif (i >= line->nformats)\n\t\t\tfmt->code = MEDIA_BUS_FMT_UYVY8_2X8;\n\n\t\tfmt->width = clamp_t(u32, fmt->width, 1, 8191);\n\t\tfmt->height = clamp_t(u32, fmt->height, 1, 8191);\n\n\t\tfmt->field = V4L2_FIELD_NONE;\n\t\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\n\t\tbreak;\n\n\tcase MSM_ISPIF_PAD_SRC:\n\t\t \n\n\t\t*fmt = *__ispif_get_format(line, sd_state, MSM_ISPIF_PAD_SINK,\n\t\t\t\t\t   which);\n\n\t\tbreak;\n\t}\n\n\tfmt->colorspace = V4L2_COLORSPACE_SRGB;\n}\n\n \nstatic int ispif_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *sd_state,\n\t\t\t\tstruct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct ispif_line *line = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tif (code->pad == MSM_ISPIF_PAD_SINK) {\n\t\tif (code->index >= line->nformats)\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = line->formats[code->index];\n\t} else {\n\t\tif (code->index > 0)\n\t\t\treturn -EINVAL;\n\n\t\tformat = __ispif_get_format(line, sd_state,\n\t\t\t\t\t    MSM_ISPIF_PAD_SINK,\n\t\t\t\t\t    code->which);\n\n\t\tcode->code = format->code;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ispif_enum_frame_size(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *sd_state,\n\t\t\t\t struct v4l2_subdev_frame_size_enum *fse)\n{\n\tstruct ispif_line *line = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt format;\n\n\tif (fse->index != 0)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = 1;\n\tformat.height = 1;\n\tispif_try_format(line, sd_state, fse->pad, &format, fse->which);\n\tfse->min_width = format.width;\n\tfse->min_height = format.height;\n\n\tif (format.code != fse->code)\n\t\treturn -EINVAL;\n\n\tformat.code = fse->code;\n\tformat.width = -1;\n\tformat.height = -1;\n\tispif_try_format(line, sd_state, fse->pad, &format, fse->which);\n\tfse->max_width = format.width;\n\tfse->max_height = format.height;\n\n\treturn 0;\n}\n\n \nstatic int ispif_get_format(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct ispif_line *line = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __ispif_get_format(line, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tfmt->format = *format;\n\n\treturn 0;\n}\n\n \nstatic int ispif_set_format(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct ispif_line *line = v4l2_get_subdevdata(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\n\tformat = __ispif_get_format(line, sd_state, fmt->pad, fmt->which);\n\tif (format == NULL)\n\t\treturn -EINVAL;\n\n\tispif_try_format(line, sd_state, fmt->pad, &fmt->format, fmt->which);\n\t*format = fmt->format;\n\n\t \n\tif (fmt->pad == MSM_ISPIF_PAD_SINK) {\n\t\tformat = __ispif_get_format(line, sd_state, MSM_ISPIF_PAD_SRC,\n\t\t\t\t\t    fmt->which);\n\n\t\t*format = fmt->format;\n\t\tispif_try_format(line, sd_state, MSM_ISPIF_PAD_SRC, format,\n\t\t\t\t fmt->which);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ispif_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\n{\n\tstruct v4l2_subdev_format format = {\n\t\t.pad = MSM_ISPIF_PAD_SINK,\n\t\t.which = fh ? V4L2_SUBDEV_FORMAT_TRY :\n\t\t\t      V4L2_SUBDEV_FORMAT_ACTIVE,\n\t\t.format = {\n\t\t\t.code = MEDIA_BUS_FMT_UYVY8_2X8,\n\t\t\t.width = 1920,\n\t\t\t.height = 1080\n\t\t}\n\t};\n\n\treturn ispif_set_format(sd, fh ? fh->state : NULL, &format);\n}\n\n \nint msm_ispif_subdev_init(struct camss *camss,\n\t\t\t  const struct resources_ispif *res)\n{\n\tstruct device *dev = camss->dev;\n\tstruct ispif_device *ispif = camss->ispif;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint i;\n\tint ret;\n\n\tif (!camss->ispif)\n\t\treturn 0;\n\n\tispif->camss = camss;\n\n\t \n\tif (camss->version == CAMSS_8x16)\n\t\tispif->line_num = 2;\n\telse if (camss->version == CAMSS_8x96 ||\n\t\t camss->version == CAMSS_660)\n\t\tispif->line_num = 4;\n\telse\n\t\treturn -EINVAL;\n\n\tispif->line = devm_kcalloc(dev, ispif->line_num,\n\t\t\t\t   sizeof(*ispif->line), GFP_KERNEL);\n\tif (!ispif->line)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ispif->line_num; i++) {\n\t\tispif->line[i].ispif = ispif;\n\t\tispif->line[i].id = i;\n\n\t\tif (camss->version == CAMSS_8x16) {\n\t\t\tispif->line[i].formats = ispif_formats_8x16;\n\t\t\tispif->line[i].nformats =\n\t\t\t\t\tARRAY_SIZE(ispif_formats_8x16);\n\t\t} else if (camss->version == CAMSS_8x96 ||\n\t\t\t   camss->version == CAMSS_660) {\n\t\t\tispif->line[i].formats = ispif_formats_8x96;\n\t\t\tispif->line[i].nformats =\n\t\t\t\t\tARRAY_SIZE(ispif_formats_8x96);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\n\tispif->base = devm_platform_ioremap_resource_byname(pdev, res->reg[0]);\n\tif (IS_ERR(ispif->base))\n\t\treturn PTR_ERR(ispif->base);\n\n\tispif->base_clk_mux = devm_platform_ioremap_resource_byname(pdev, res->reg[1]);\n\tif (IS_ERR(ispif->base_clk_mux))\n\t\treturn PTR_ERR(ispif->base_clk_mux);\n\n\t \n\n\tret = platform_get_irq_byname(pdev, res->interrupt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tispif->irq = ret;\n\tsnprintf(ispif->irq_name, sizeof(ispif->irq_name), \"%s_%s\",\n\t\t dev_name(dev), MSM_ISPIF_NAME);\n\tif (camss->version == CAMSS_8x16)\n\t\tret = devm_request_irq(dev, ispif->irq, ispif_isr_8x16,\n\t\t\t       IRQF_TRIGGER_RISING, ispif->irq_name, ispif);\n\telse if (camss->version == CAMSS_8x96 ||\n\t\t camss->version == CAMSS_660)\n\t\tret = devm_request_irq(dev, ispif->irq, ispif_isr_8x96,\n\t\t\t       IRQF_TRIGGER_RISING, ispif->irq_name, ispif);\n\telse\n\t\tret = -EINVAL;\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"request_irq failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\tispif->nclocks = 0;\n\twhile (res->clock[ispif->nclocks])\n\t\tispif->nclocks++;\n\n\tispif->clock = devm_kcalloc(dev,\n\t\t\t\t    ispif->nclocks, sizeof(*ispif->clock),\n\t\t\t\t    GFP_KERNEL);\n\tif (!ispif->clock)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ispif->nclocks; i++) {\n\t\tstruct camss_clock *clock = &ispif->clock[i];\n\n\t\tclock->clk = devm_clk_get(dev, res->clock[i]);\n\t\tif (IS_ERR(clock->clk))\n\t\t\treturn PTR_ERR(clock->clk);\n\n\t\tclock->freq = NULL;\n\t\tclock->nfreqs = 0;\n\t}\n\n\tispif->nclocks_for_reset = 0;\n\twhile (res->clock_for_reset[ispif->nclocks_for_reset])\n\t\tispif->nclocks_for_reset++;\n\n\tispif->clock_for_reset = devm_kcalloc(dev,\n\t\t\t\t\t      ispif->nclocks_for_reset,\n\t\t\t\t\t      sizeof(*ispif->clock_for_reset),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!ispif->clock_for_reset)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ispif->nclocks_for_reset; i++) {\n\t\tstruct camss_clock *clock = &ispif->clock_for_reset[i];\n\n\t\tclock->clk = devm_clk_get(dev, res->clock_for_reset[i]);\n\t\tif (IS_ERR(clock->clk))\n\t\t\treturn PTR_ERR(clock->clk);\n\n\t\tclock->freq = NULL;\n\t\tclock->nfreqs = 0;\n\t}\n\n\tmutex_init(&ispif->power_lock);\n\tispif->power_count = 0;\n\n\tmutex_init(&ispif->config_lock);\n\n\tfor (i = 0; i < MSM_ISPIF_VFE_NUM; i++)\n\t\tinit_completion(&ispif->reset_complete[i]);\n\n\treturn 0;\n}\n\n \nstatic enum ispif_intf ispif_get_intf(enum vfe_line_id line_id)\n{\n\tswitch (line_id) {\n\tcase (VFE_LINE_RDI0):\n\t\treturn RDI0;\n\tcase (VFE_LINE_RDI1):\n\t\treturn RDI1;\n\tcase (VFE_LINE_RDI2):\n\t\treturn RDI2;\n\tcase (VFE_LINE_PIX):\n\t\treturn PIX0;\n\tdefault:\n\t\treturn RDI0;\n\t}\n}\n\n \nstatic void ispif_get_vfe_id(struct media_entity *entity, u8 *id)\n{\n\tstruct v4l2_subdev *sd;\n\tstruct vfe_line *line;\n\tstruct vfe_device *vfe;\n\n\tsd = media_entity_to_v4l2_subdev(entity);\n\tline = v4l2_get_subdevdata(sd);\n\tvfe = to_vfe(line);\n\n\t*id = vfe->id;\n}\n\n \nstatic void ispif_get_vfe_line_id(struct media_entity *entity,\n\t\t\t\t  enum vfe_line_id *id)\n{\n\tstruct v4l2_subdev *sd;\n\tstruct vfe_line *line;\n\n\tsd = media_entity_to_v4l2_subdev(entity);\n\tline = v4l2_get_subdevdata(sd);\n\n\t*id = line->id;\n}\n\n \nstatic int ispif_link_setup(struct media_entity *entity,\n\t\t\t    const struct media_pad *local,\n\t\t\t    const struct media_pad *remote, u32 flags)\n{\n\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\tif (media_pad_remote_pad_first(local))\n\t\t\treturn -EBUSY;\n\n\t\tif (local->flags & MEDIA_PAD_FL_SINK) {\n\t\t\tstruct v4l2_subdev *sd;\n\t\t\tstruct ispif_line *line;\n\n\t\t\tsd = media_entity_to_v4l2_subdev(entity);\n\t\t\tline = v4l2_get_subdevdata(sd);\n\n\t\t\tmsm_csid_get_csid_id(remote->entity, &line->csid_id);\n\t\t} else {  \n\t\t\tstruct v4l2_subdev *sd;\n\t\t\tstruct ispif_line *line;\n\t\t\tenum vfe_line_id id;\n\n\t\t\tsd = media_entity_to_v4l2_subdev(entity);\n\t\t\tline = v4l2_get_subdevdata(sd);\n\n\t\t\tispif_get_vfe_id(remote->entity, &line->vfe_id);\n\t\t\tispif_get_vfe_line_id(remote->entity, &id);\n\t\t\tline->interface = ispif_get_intf(id);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops ispif_core_ops = {\n\t.s_power = ispif_set_power,\n};\n\nstatic const struct v4l2_subdev_video_ops ispif_video_ops = {\n\t.s_stream = ispif_set_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops ispif_pad_ops = {\n\t.enum_mbus_code = ispif_enum_mbus_code,\n\t.enum_frame_size = ispif_enum_frame_size,\n\t.get_fmt = ispif_get_format,\n\t.set_fmt = ispif_set_format,\n};\n\nstatic const struct v4l2_subdev_ops ispif_v4l2_ops = {\n\t.core = &ispif_core_ops,\n\t.video = &ispif_video_ops,\n\t.pad = &ispif_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops ispif_v4l2_internal_ops = {\n\t.open = ispif_init_formats,\n};\n\nstatic const struct media_entity_operations ispif_media_ops = {\n\t.link_setup = ispif_link_setup,\n\t.link_validate = v4l2_subdev_link_validate,\n};\n\n \nint msm_ispif_register_entities(struct ispif_device *ispif,\n\t\t\t\tstruct v4l2_device *v4l2_dev)\n{\n\tstruct camss *camss;\n\tint ret;\n\tint i;\n\n\tif (!ispif)\n\t\treturn 0;\n\n\tcamss = ispif->camss;\n\n\tfor (i = 0; i < ispif->line_num; i++) {\n\t\tstruct v4l2_subdev *sd = &ispif->line[i].subdev;\n\t\tstruct media_pad *pads = ispif->line[i].pads;\n\n\t\tv4l2_subdev_init(sd, &ispif_v4l2_ops);\n\t\tsd->internal_ops = &ispif_v4l2_internal_ops;\n\t\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\t\tsnprintf(sd->name, ARRAY_SIZE(sd->name), \"%s%d\",\n\t\t\t MSM_ISPIF_NAME, i);\n\t\tv4l2_set_subdevdata(sd, &ispif->line[i]);\n\n\t\tret = ispif_init_formats(sd, NULL);\n\t\tif (ret < 0) {\n\t\t\tdev_err(camss->dev, \"Failed to init format: %d\\n\", ret);\n\t\t\tgoto error;\n\t\t}\n\n\t\tpads[MSM_ISPIF_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\t\tpads[MSM_ISPIF_PAD_SRC].flags = MEDIA_PAD_FL_SOURCE;\n\n\t\tsd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;\n\t\tsd->entity.ops = &ispif_media_ops;\n\t\tret = media_entity_pads_init(&sd->entity, MSM_ISPIF_PADS_NUM,\n\t\t\t\t\t     pads);\n\t\tif (ret < 0) {\n\t\t\tdev_err(camss->dev, \"Failed to init media entity: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = v4l2_device_register_subdev(v4l2_dev, sd);\n\t\tif (ret < 0) {\n\t\t\tdev_err(camss->dev, \"Failed to register subdev: %d\\n\",\n\t\t\t\tret);\n\t\t\tmedia_entity_cleanup(&sd->entity);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i--; i >= 0; i--) {\n\t\tstruct v4l2_subdev *sd = &ispif->line[i].subdev;\n\n\t\tv4l2_device_unregister_subdev(sd);\n\t\tmedia_entity_cleanup(&sd->entity);\n\t}\n\n\treturn ret;\n}\n\n \nvoid msm_ispif_unregister_entities(struct ispif_device *ispif)\n{\n\tint i;\n\n\tif (!ispif)\n\t\treturn;\n\n\tmutex_destroy(&ispif->power_lock);\n\tmutex_destroy(&ispif->config_lock);\n\n\tfor (i = 0; i < ispif->line_num; i++) {\n\t\tstruct v4l2_subdev *sd = &ispif->line[i].subdev;\n\n\t\tv4l2_device_unregister_subdev(sd);\n\t\tmedia_entity_cleanup(&sd->entity);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}