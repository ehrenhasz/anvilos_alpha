{
  "module_name": "camss.h",
  "hash_id": "918a64101ac54f0af585295f667abfcb86210b0eeca8f8326bff8a1e3da346b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/camss/camss.h",
  "human_readable_source": " \n \n#ifndef QC_MSM_CAMSS_H\n#define QC_MSM_CAMSS_H\n\n#include <linux/device.h>\n#include <linux/types.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-subdev.h>\n#include <media/media-device.h>\n#include <media/media-entity.h>\n\n#include \"camss-csid.h\"\n#include \"camss-csiphy.h\"\n#include \"camss-ispif.h\"\n#include \"camss-vfe.h\"\n\n#define to_camss(ptr_module)\t\\\n\tcontainer_of(ptr_module, struct camss, ptr_module)\n\n#define to_device(ptr_module)\t\\\n\t(to_camss(ptr_module)->dev)\n\n#define module_pointer(ptr_module, index)\t\\\n\t((const struct ptr_module##_device (*)[]) &(ptr_module[-(index)]))\n\n#define to_camss_index(ptr_module, index)\t\\\n\tcontainer_of(module_pointer(ptr_module, index),\t\\\n\t\t     struct camss, ptr_module)\n\n#define to_device_index(ptr_module, index)\t\\\n\t(to_camss_index(ptr_module, index)->dev)\n\n#define CAMSS_RES_MAX 17\n\nstruct resources {\n\tchar *regulators[CAMSS_RES_MAX];\n\tchar *clock[CAMSS_RES_MAX];\n\tu32 clock_rate[CAMSS_RES_MAX][CAMSS_RES_MAX];\n\tchar *reg[CAMSS_RES_MAX];\n\tchar *interrupt[CAMSS_RES_MAX];\n};\n\nstruct resources_ispif {\n\tchar *clock[CAMSS_RES_MAX];\n\tchar *clock_for_reset[CAMSS_RES_MAX];\n\tchar *reg[CAMSS_RES_MAX];\n\tchar *interrupt;\n};\n\nstruct icc_bw_tbl {\n\tu32 avg;\n\tu32 peak;\n};\n\nstruct resources_icc {\n\tchar *name;\n\tstruct icc_bw_tbl icc_bw_tbl;\n};\n\nenum pm_domain {\n\tPM_DOMAIN_VFE0 = 0,\n\tPM_DOMAIN_VFE1 = 1,\n\tPM_DOMAIN_VFELITE = 2,\t\t \n};\n\nenum camss_version {\n\tCAMSS_8x16,\n\tCAMSS_8x96,\n\tCAMSS_660,\n\tCAMSS_845,\n\tCAMSS_8250,\n};\n\nenum icc_count {\n\tICC_DEFAULT_COUNT = 0,\n\tICC_SM8250_COUNT = 4,\n};\n\nstruct camss {\n\tenum camss_version version;\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_async_notifier notifier;\n\tstruct media_device media_dev;\n\tstruct device *dev;\n\tint csiphy_num;\n\tstruct csiphy_device *csiphy;\n\tint csid_num;\n\tstruct csid_device *csid;\n\tstruct ispif_device *ispif;\n\tint vfe_num;\n\tint vfe_lite_num;\n\tstruct vfe_device *vfe;\n\tatomic_t ref_count;\n\tint genpd_num;\n\tstruct device **genpd;\n\tstruct device_link **genpd_link;\n\tstruct icc_path *icc_path[ICC_SM8250_COUNT];\n\tstruct icc_bw_tbl icc_bw_tbl[ICC_SM8250_COUNT];\n};\n\nstruct camss_camera_interface {\n\tu8 csiphy_id;\n\tstruct csiphy_csi2_cfg csi2;\n};\n\nstruct camss_async_subdev {\n\tstruct v4l2_async_connection asd;  \n\tstruct camss_camera_interface interface;\n};\n\nstruct camss_clock {\n\tstruct clk *clk;\n\tconst char *name;\n\tu32 *freq;\n\tu32 nfreqs;\n};\n\nvoid camss_add_clock_margin(u64 *rate);\nint camss_enable_clocks(int nclocks, struct camss_clock *clock,\n\t\t\tstruct device *dev);\nvoid camss_disable_clocks(int nclocks, struct camss_clock *clock);\nstruct media_entity *camss_find_sensor(struct media_entity *entity);\ns64 camss_get_link_freq(struct media_entity *entity, unsigned int bpp,\n\t\t\tunsigned int lanes);\nint camss_get_pixel_clock(struct media_entity *entity, u64 *pixel_clock);\nint camss_pm_domain_on(struct camss *camss, int id);\nvoid camss_pm_domain_off(struct camss *camss, int id);\nvoid camss_delete(struct camss *camss);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}