{
  "module_name": "venc.c",
  "hash_id": "c0dc10f5244e68d6ed221023846af15cf88b082ef24a9320032c2d3cd8fd3fac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/venus/venc.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ctrls.h>\n\n#include \"hfi_venus_io.h\"\n#include \"hfi_parser.h\"\n#include \"core.h\"\n#include \"helpers.h\"\n#include \"venc.h\"\n#include \"pm_helpers.h\"\n\n#define NUM_B_FRAMES_MAX\t4\n\n \nstatic const struct venus_format venc_formats[] = {\n\t[VENUS_FMT_NV12] = {\n\t\t.pixfmt = V4L2_PIX_FMT_NV12,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t},\n\t[VENUS_FMT_H264] = {\n\t\t.pixfmt = V4L2_PIX_FMT_H264,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t},\n\t[VENUS_FMT_VP8] = {\n\t\t.pixfmt = V4L2_PIX_FMT_VP8,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t},\n\t[VENUS_FMT_HEVC] = {\n\t\t.pixfmt = V4L2_PIX_FMT_HEVC,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t},\n\t[VENUS_FMT_MPEG4] = {\n\t\t.pixfmt = V4L2_PIX_FMT_MPEG4,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t},\n\t[VENUS_FMT_H263] = {\n\t\t.pixfmt = V4L2_PIX_FMT_H263,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t},\n};\n\nstatic const struct venus_format *\nfind_format(struct venus_inst *inst, u32 pixfmt, u32 type)\n{\n\tconst struct venus_format *fmt = venc_formats;\n\tunsigned int size = ARRAY_SIZE(venc_formats);\n\tunsigned int i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (fmt[i].pixfmt == pixfmt)\n\t\t\tbreak;\n\t}\n\n\tif (i == size || fmt[i].type != type)\n\t\treturn NULL;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\n\t    !venus_helper_check_codec(inst, fmt[i].pixfmt))\n\t\treturn NULL;\n\n\treturn &fmt[i];\n}\n\nstatic const struct venus_format *\nfind_format_by_index(struct venus_inst *inst, unsigned int index, u32 type)\n{\n\tconst struct venus_format *fmt = venc_formats;\n\tunsigned int size = ARRAY_SIZE(venc_formats);\n\tunsigned int i, k = 0;\n\n\tif (index > size)\n\t\treturn NULL;\n\n\tfor (i = 0; i < size; i++) {\n\t\tbool valid;\n\n\t\tif (fmt[i].type != type)\n\t\t\tcontinue;\n\t\tvalid = type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE ||\n\t\t\tvenus_helper_check_codec(inst, fmt[i].pixfmt);\n\t\tif (k == index && valid)\n\t\t\tbreak;\n\t\tif (valid)\n\t\t\tk++;\n\t}\n\n\tif (i == size)\n\t\treturn NULL;\n\n\treturn &fmt[i];\n}\n\nstatic int venc_v4l2_to_hfi(int id, int value)\n{\n\tswitch (id) {\n\tcase V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:\n\t\tswitch (value) {\n\t\tcase V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC:\n\t\tdefault:\n\t\t\treturn HFI_H264_ENTROPY_CAVLC;\n\t\tcase V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC:\n\t\t\treturn HFI_H264_ENTROPY_CABAC;\n\t\t}\n\tcase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE:\n\t\tswitch (value) {\n\t\tcase V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED:\n\t\tdefault:\n\t\t\treturn HFI_H264_DB_MODE_ALL_BOUNDARY;\n\t\tcase V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED:\n\t\t\treturn HFI_H264_DB_MODE_DISABLE;\n\t\tcase V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY:\n\t\t\treturn HFI_H264_DB_MODE_SKIP_SLICE_BOUNDARY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvenc_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, \"qcom-venus\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"Qualcomm Venus video encoder\", sizeof(cap->card));\n\tstrscpy(cap->bus_info, \"platform:qcom-venus\", sizeof(cap->bus_info));\n\n\treturn 0;\n}\n\nstatic int venc_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\tconst struct venus_format *fmt;\n\n\tfmt = find_format_by_index(inst, f->index, f->type);\n\n\tmemset(f->reserved, 0, sizeof(f->reserved));\n\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = fmt->pixfmt;\n\n\treturn 0;\n}\n\nstatic const struct venus_format *\nvenc_try_fmt_common(struct venus_inst *inst, struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tstruct v4l2_plane_pix_format *pfmt = pixmp->plane_fmt;\n\tconst struct venus_format *fmt;\n\tu32 sizeimage;\n\n\tmemset(pfmt[0].reserved, 0, sizeof(pfmt[0].reserved));\n\tmemset(pixmp->reserved, 0, sizeof(pixmp->reserved));\n\n\tfmt = find_format(inst, pixmp->pixelformat, f->type);\n\tif (!fmt) {\n\t\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\t\tpixmp->pixelformat = V4L2_PIX_FMT_H264;\n\t\telse if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\t\tpixmp->pixelformat = V4L2_PIX_FMT_NV12;\n\t\telse\n\t\t\treturn NULL;\n\t\tfmt = find_format(inst, pixmp->pixelformat, f->type);\n\t\tif (!fmt)\n\t\t\treturn NULL;\n\t}\n\n\tpixmp->width = clamp(pixmp->width, frame_width_min(inst),\n\t\t\t     frame_width_max(inst));\n\tpixmp->height = clamp(pixmp->height, frame_height_min(inst),\n\t\t\t      frame_height_max(inst));\n\n\tpixmp->width = ALIGN(pixmp->width, 128);\n\tpixmp->height = ALIGN(pixmp->height, 32);\n\n\tpixmp->width = ALIGN(pixmp->width, 2);\n\tpixmp->height = ALIGN(pixmp->height, 2);\n\n\tif (pixmp->field == V4L2_FIELD_ANY)\n\t\tpixmp->field = V4L2_FIELD_NONE;\n\tpixmp->num_planes = fmt->num_planes;\n\tpixmp->flags = 0;\n\n\tsizeimage = venus_helper_get_framesz(pixmp->pixelformat,\n\t\t\t\t\t     pixmp->width,\n\t\t\t\t\t     pixmp->height);\n\tpfmt[0].sizeimage = max(ALIGN(pfmt[0].sizeimage, SZ_4K), sizeimage);\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tpfmt[0].bytesperline = ALIGN(pixmp->width, 128);\n\telse\n\t\tpfmt[0].bytesperline = 0;\n\n\treturn fmt;\n}\n\nstatic int venc_try_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\n\tvenc_try_fmt_common(inst, f);\n\n\treturn 0;\n}\n\nstatic int venc_s_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tstruct v4l2_pix_format_mplane orig_pixmp;\n\tconst struct venus_format *fmt;\n\tstruct v4l2_format format;\n\tu32 pixfmt_out = 0, pixfmt_cap = 0;\n\tstruct vb2_queue *q;\n\n\tq = v4l2_m2m_get_vq(inst->m2m_ctx, f->type);\n\tif (!q)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\torig_pixmp = *pixmp;\n\n\tfmt = venc_try_fmt_common(inst, f);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tpixfmt_out = pixmp->pixelformat;\n\t\tpixfmt_cap = inst->fmt_cap->pixfmt;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tpixfmt_cap = pixmp->pixelformat;\n\t\tpixfmt_out = inst->fmt_out->pixfmt;\n\t}\n\n\tmemset(&format, 0, sizeof(format));\n\n\tformat.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tformat.fmt.pix_mp.pixelformat = pixfmt_out;\n\tformat.fmt.pix_mp.width = orig_pixmp.width;\n\tformat.fmt.pix_mp.height = orig_pixmp.height;\n\tvenc_try_fmt_common(inst, &format);\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tinst->out_width = format.fmt.pix_mp.width;\n\t\tinst->out_height = format.fmt.pix_mp.height;\n\t\tinst->colorspace = pixmp->colorspace;\n\t\tinst->ycbcr_enc = pixmp->ycbcr_enc;\n\t\tinst->quantization = pixmp->quantization;\n\t\tinst->xfer_func = pixmp->xfer_func;\n\t}\n\n\tmemset(&format, 0, sizeof(format));\n\n\tformat.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tformat.fmt.pix_mp.pixelformat = pixfmt_cap;\n\tformat.fmt.pix_mp.width = orig_pixmp.width;\n\tformat.fmt.pix_mp.height = orig_pixmp.height;\n\tvenc_try_fmt_common(inst, &format);\n\n\tinst->width = format.fmt.pix_mp.width;\n\tinst->height = format.fmt.pix_mp.height;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tinst->fmt_out = fmt;\n\telse if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tinst->fmt_cap = fmt;\n\t\tinst->output_buf_size = pixmp->plane_fmt[0].sizeimage;\n\t}\n\n\treturn 0;\n}\n\nstatic int venc_g_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tstruct venus_inst *inst = to_inst(file);\n\tconst struct venus_format *fmt;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tfmt = inst->fmt_cap;\n\telse if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tfmt = inst->fmt_out;\n\telse\n\t\treturn -EINVAL;\n\n\tpixmp->pixelformat = fmt->pixfmt;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tpixmp->width = inst->width;\n\t\tpixmp->height = inst->height;\n\t\tpixmp->colorspace = inst->colorspace;\n\t\tpixmp->ycbcr_enc = inst->ycbcr_enc;\n\t\tpixmp->quantization = inst->quantization;\n\t\tpixmp->xfer_func = inst->xfer_func;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tpixmp->width = inst->out_width;\n\t\tpixmp->height = inst->out_height;\n\t}\n\n\tvenc_try_fmt_common(inst, f);\n\n\treturn 0;\n}\n\nstatic int\nvenc_g_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\ts->r.width = inst->out_width;\n\t\ts->r.height = inst->out_height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\ts->r.width = inst->width;\n\t\ts->r.height = inst->height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ts->r.top = 0;\n\ts->r.left = 0;\n\n\treturn 0;\n}\n\nstatic int\nvenc_s_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tif (s->r.width > inst->out_width ||\n\t    s->r.height > inst->out_height)\n\t\treturn -EINVAL;\n\n\ts->r.width = ALIGN(s->r.width, 2);\n\ts->r.height = ALIGN(s->r.height, 2);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\ts->r.top = 0;\n\t\ts->r.left = 0;\n\t\tinst->width = s->r.width;\n\t\tinst->height = s->r.height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int venc_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\tstruct v4l2_outputparm *out = &a->parm.output;\n\tstruct v4l2_fract *timeperframe = &out->timeperframe;\n\tu64 us_per_frame, fps;\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\n\t    a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn -EINVAL;\n\n\tmemset(out->reserved, 0, sizeof(out->reserved));\n\n\tif (!timeperframe->denominator)\n\t\ttimeperframe->denominator = inst->timeperframe.denominator;\n\tif (!timeperframe->numerator)\n\t\ttimeperframe->numerator = inst->timeperframe.numerator;\n\n\tout->capability = V4L2_CAP_TIMEPERFRAME;\n\n\tus_per_frame = timeperframe->numerator * (u64)USEC_PER_SEC;\n\tdo_div(us_per_frame, timeperframe->denominator);\n\n\tif (!us_per_frame)\n\t\treturn -EINVAL;\n\n\tfps = (u64)USEC_PER_SEC;\n\tdo_div(fps, us_per_frame);\n\n\tinst->timeperframe = *timeperframe;\n\tinst->fps = fps;\n\n\treturn 0;\n}\n\nstatic int venc_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\n\t    a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn -EINVAL;\n\n\ta->parm.output.capability |= V4L2_CAP_TIMEPERFRAME;\n\ta->parm.output.timeperframe = inst->timeperframe;\n\n\treturn 0;\n}\n\nstatic int venc_enum_framesizes(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_frmsizeenum *fsize)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\tconst struct venus_format *fmt;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\n\tfmt = find_format(inst, fsize->pixel_format,\n\t\t\t  V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (!fmt) {\n\t\tfmt = find_format(inst, fsize->pixel_format,\n\t\t\t\t  V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\t\tif (!fmt)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\n\tfsize->stepwise.min_width = frame_width_min(inst);\n\tfsize->stepwise.max_width = frame_width_max(inst);\n\tfsize->stepwise.step_width = frame_width_step(inst);\n\tfsize->stepwise.min_height = frame_height_min(inst);\n\tfsize->stepwise.max_height = frame_height_max(inst);\n\tfsize->stepwise.step_height = frame_height_step(inst);\n\n\treturn 0;\n}\n\nstatic int venc_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_frmivalenum *fival)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\tconst struct venus_format *fmt;\n\tunsigned int framerate_factor = 1;\n\n\tfival->type = V4L2_FRMIVAL_TYPE_STEPWISE;\n\n\tfmt = find_format(inst, fival->pixel_format,\n\t\t\t  V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (!fmt) {\n\t\tfmt = find_format(inst, fival->pixel_format,\n\t\t\t\t  V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\t\tif (!fmt)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (fival->index)\n\t\treturn -EINVAL;\n\n\tif (!fival->width || !fival->height)\n\t\treturn -EINVAL;\n\n\tif (fival->width > frame_width_max(inst) ||\n\t    fival->width < frame_width_min(inst) ||\n\t    fival->height > frame_height_max(inst) ||\n\t    fival->height < frame_height_min(inst))\n\t\treturn -EINVAL;\n\n\tif (IS_V1(inst->core)) {\n\t\t \n\t\tframerate_factor = (1 << 16);\n\t}\n\n\tfival->stepwise.min.numerator = 1;\n\tfival->stepwise.min.denominator = frate_max(inst) / framerate_factor;\n\tfival->stepwise.max.numerator = 1;\n\tfival->stepwise.max.denominator = frate_min(inst) / framerate_factor;\n\tfival->stepwise.step.numerator = 1;\n\tfival->stepwise.step.denominator = frate_max(inst) / framerate_factor;\n\n\treturn 0;\n}\n\nstatic int venc_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\tconst struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_EOS:\n\t\treturn v4l2_event_subscribe(fh, sub, 2, NULL);\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nvenc_encoder_cmd(struct file *file, void *fh, struct v4l2_encoder_cmd *cmd)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\tstruct hfi_frame_data fdata = {0};\n\tint ret = 0;\n\n\tret = v4l2_m2m_ioctl_try_encoder_cmd(file, fh, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inst->lock);\n\n\tif (cmd->cmd == V4L2_ENC_CMD_STOP &&\n\t    inst->enc_state == VENUS_ENC_STATE_ENCODING) {\n\t\t \n\t\tif (!(inst->streamon_out && inst->streamon_cap))\n\t\t\tgoto unlock;\n\n\t\tfdata.buffer_type = HFI_BUFFER_INPUT;\n\t\tfdata.flags |= HFI_BUFFERFLAG_EOS;\n\t\tfdata.device_addr = 0xdeadb000;\n\n\t\tret = hfi_session_process_buf(inst, &fdata);\n\n\t\tinst->enc_state = VENUS_ENC_STATE_DRAIN;\n\t} else if (cmd->cmd == V4L2_ENC_CMD_START) {\n\t\tif (inst->enc_state == VENUS_ENC_STATE_DRAIN) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (inst->enc_state == VENUS_ENC_STATE_STOPPED) {\n\t\t\tvb2_clear_last_buffer_dequeued(&inst->fh.m2m_ctx->cap_q_ctx.q);\n\t\t\tinst->enc_state = VENUS_ENC_STATE_ENCODING;\n\t\t}\n\t}\n\nunlock:\n\tmutex_unlock(&inst->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_ioctl_ops venc_ioctl_ops = {\n\t.vidioc_querycap = venc_querycap,\n\t.vidioc_enum_fmt_vid_cap = venc_enum_fmt,\n\t.vidioc_enum_fmt_vid_out = venc_enum_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane = venc_s_fmt,\n\t.vidioc_s_fmt_vid_out_mplane = venc_s_fmt,\n\t.vidioc_g_fmt_vid_cap_mplane = venc_g_fmt,\n\t.vidioc_g_fmt_vid_out_mplane = venc_g_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane = venc_try_fmt,\n\t.vidioc_try_fmt_vid_out_mplane = venc_try_fmt,\n\t.vidioc_g_selection = venc_g_selection,\n\t.vidioc_s_selection = venc_s_selection,\n\t.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,\n\t.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_streamon = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,\n\t.vidioc_s_parm = venc_s_parm,\n\t.vidioc_g_parm = venc_g_parm,\n\t.vidioc_enum_framesizes = venc_enum_framesizes,\n\t.vidioc_enum_frameintervals = venc_enum_frameintervals,\n\t.vidioc_subscribe_event = venc_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_try_encoder_cmd = v4l2_m2m_ioctl_try_encoder_cmd,\n\t.vidioc_encoder_cmd = venc_encoder_cmd,\n};\n\nstatic int venc_pm_get(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct device *dev = core->dev_enc;\n\tint ret;\n\n\tmutex_lock(&core->pm_lock);\n\tret = pm_runtime_resume_and_get(dev);\n\tmutex_unlock(&core->pm_lock);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int venc_pm_put(struct venus_inst *inst, bool autosuspend)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct device *dev = core->dev_enc;\n\tint ret;\n\n\tmutex_lock(&core->pm_lock);\n\n\tif (autosuspend)\n\t\tret = pm_runtime_put_autosuspend(dev);\n\telse\n\t\tret = pm_runtime_put_sync(dev);\n\n\tmutex_unlock(&core->pm_lock);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int venc_pm_get_put(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct device *dev = core->dev_enc;\n\tint ret = 0;\n\n\tmutex_lock(&core->pm_lock);\n\n\tif (pm_runtime_suspended(dev)) {\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tret = pm_runtime_put_autosuspend(dev);\n\t}\n\nerror:\n\tmutex_unlock(&core->pm_lock);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic void venc_pm_touch(struct venus_inst *inst)\n{\n\tpm_runtime_mark_last_busy(inst->core->dev_enc);\n}\n\nstatic int venc_set_properties(struct venus_inst *inst)\n{\n\tstruct venc_controls *ctr = &inst->controls.enc;\n\tstruct hfi_intra_period intra_period;\n\tstruct hfi_framerate frate;\n\tstruct hfi_bitrate brate;\n\tstruct hfi_idr_period idrp;\n\tstruct hfi_quantization quant;\n\tstruct hfi_quantization_range quant_range;\n\tstruct hfi_quantization_range_v2 quant_range_v2;\n\tstruct hfi_enable en;\n\tstruct hfi_ltr_mode ltr_mode;\n\tstruct hfi_intra_refresh intra_refresh = {};\n\tu32 ptype, rate_control, bitrate;\n\tu32 profile, level;\n\tint ret;\n\n\tret = venus_helper_set_work_mode(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tptype = HFI_PROPERTY_CONFIG_FRAME_RATE;\n\tfrate.buffer_type = HFI_BUFFER_OUTPUT;\n\tfrate.framerate = inst->fps * (1 << 16);\n\n\tret = hfi_session_set_property(inst, ptype, &frate);\n\tif (ret)\n\t\treturn ret;\n\n\tif (inst->fmt_cap->pixfmt == V4L2_PIX_FMT_H264) {\n\t\tstruct hfi_h264_vui_timing_info info;\n\t\tstruct hfi_h264_entropy_control entropy;\n\t\tstruct hfi_h264_db_control deblock;\n\t\tstruct hfi_h264_8x8_transform h264_transform;\n\n\t\tptype = HFI_PROPERTY_PARAM_VENC_H264_VUI_TIMING_INFO;\n\t\tinfo.enable = 1;\n\t\tinfo.fixed_framerate = 1;\n\t\tinfo.time_scale = NSEC_PER_SEC;\n\n\t\tret = hfi_session_set_property(inst, ptype, &info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tptype = HFI_PROPERTY_PARAM_VENC_H264_ENTROPY_CONTROL;\n\t\tentropy.entropy_mode = venc_v4l2_to_hfi(\n\t\t\t\t\t  V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE,\n\t\t\t\t\t  ctr->h264_entropy_mode);\n\t\tentropy.cabac_model = HFI_H264_CABAC_MODEL_0;\n\n\t\tret = hfi_session_set_property(inst, ptype, &entropy);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tptype = HFI_PROPERTY_PARAM_VENC_H264_DEBLOCK_CONTROL;\n\t\tdeblock.mode = venc_v4l2_to_hfi(\n\t\t\t\t      V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE,\n\t\t\t\t      ctr->h264_loop_filter_mode);\n\t\tdeblock.slice_alpha_offset = ctr->h264_loop_filter_alpha;\n\t\tdeblock.slice_beta_offset = ctr->h264_loop_filter_beta;\n\n\t\tret = hfi_session_set_property(inst, ptype, &deblock);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tptype = HFI_PROPERTY_PARAM_VENC_H264_TRANSFORM_8X8;\n\t\th264_transform.enable_type = 0;\n\t\tif (ctr->profile.h264 == V4L2_MPEG_VIDEO_H264_PROFILE_HIGH ||\n\t\t    ctr->profile.h264 == V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_HIGH)\n\t\t\th264_transform.enable_type = ctr->h264_8x8_transform;\n\n\t\tret = hfi_session_set_property(inst, ptype, &h264_transform);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t}\n\n\tif (inst->fmt_cap->pixfmt == V4L2_PIX_FMT_H264 ||\n\t    inst->fmt_cap->pixfmt == V4L2_PIX_FMT_HEVC) {\n\t\t \n\t\tptype = HFI_PROPERTY_CONFIG_VENC_IDR_PERIOD;\n\t\tidrp.idr_period = 0;\n\t\tret = hfi_session_set_property(inst, ptype, &idrp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (inst->fmt_cap->pixfmt == V4L2_PIX_FMT_HEVC &&\n\t    ctr->profile.hevc == V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10) {\n\t\tstruct hfi_hdr10_pq_sei hdr10;\n\t\tunsigned int c;\n\n\t\tptype = HFI_PROPERTY_PARAM_VENC_HDR10_PQ_SEI;\n\n\t\tfor (c = 0; c < 3; c++) {\n\t\t\thdr10.mastering.display_primaries_x[c] =\n\t\t\t\tctr->mastering.display_primaries_x[c];\n\t\t\thdr10.mastering.display_primaries_y[c] =\n\t\t\t\tctr->mastering.display_primaries_y[c];\n\t\t}\n\n\t\thdr10.mastering.white_point_x = ctr->mastering.white_point_x;\n\t\thdr10.mastering.white_point_y = ctr->mastering.white_point_y;\n\t\thdr10.mastering.max_display_mastering_luminance =\n\t\t\tctr->mastering.max_display_mastering_luminance;\n\t\thdr10.mastering.min_display_mastering_luminance =\n\t\t\tctr->mastering.min_display_mastering_luminance;\n\n\t\thdr10.cll.max_content_light = ctr->cll.max_content_light_level;\n\t\thdr10.cll.max_pic_average_light =\n\t\t\tctr->cll.max_pic_average_light_level;\n\n\t\tret = hfi_session_set_property(inst, ptype, &hdr10);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ctr->num_b_frames) {\n\t\tu32 max_num_b_frames = NUM_B_FRAMES_MAX;\n\n\t\tptype = HFI_PROPERTY_PARAM_VENC_MAX_NUM_B_FRAMES;\n\t\tret = hfi_session_set_property(inst, ptype, &max_num_b_frames);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tptype = HFI_PROPERTY_CONFIG_VENC_INTRA_PERIOD;\n\tintra_period.pframes = ctr->num_p_frames;\n\tintra_period.bframes = ctr->num_b_frames;\n\n\tret = hfi_session_set_property(inst, ptype, &intra_period);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ctr->rc_enable)\n\t\trate_control = HFI_RATE_CONTROL_OFF;\n\telse if (ctr->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR)\n\t\trate_control = ctr->frame_skip_mode ? HFI_RATE_CONTROL_VBR_VFR :\n\t\t\t\t\t\t      HFI_RATE_CONTROL_VBR_CFR;\n\telse if (ctr->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR)\n\t\trate_control = ctr->frame_skip_mode ? HFI_RATE_CONTROL_CBR_VFR :\n\t\t\t\t\t\t      HFI_RATE_CONTROL_CBR_CFR;\n\telse if (ctr->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CQ)\n\t\trate_control = HFI_RATE_CONTROL_CQ;\n\n\tptype = HFI_PROPERTY_PARAM_VENC_RATE_CONTROL;\n\tret = hfi_session_set_property(inst, ptype, &rate_control);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rate_control == HFI_RATE_CONTROL_CQ && ctr->const_quality) {\n\t\tstruct hfi_heic_frame_quality quality = {};\n\n\t\tptype = HFI_PROPERTY_CONFIG_HEIC_FRAME_QUALITY;\n\t\tquality.frame_quality = ctr->const_quality;\n\t\tret = hfi_session_set_property(inst, ptype, &quality);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!ctr->bitrate)\n\t\tbitrate = 64000;\n\telse\n\t\tbitrate = ctr->bitrate;\n\n\tptype = HFI_PROPERTY_CONFIG_VENC_TARGET_BITRATE;\n\tbrate.bitrate = bitrate;\n\tbrate.layer_id = 0;\n\n\tret = hfi_session_set_property(inst, ptype, &brate);\n\tif (ret)\n\t\treturn ret;\n\n\tif (inst->fmt_cap->pixfmt == V4L2_PIX_FMT_H264 ||\n\t    inst->fmt_cap->pixfmt == V4L2_PIX_FMT_HEVC) {\n\t\tptype = HFI_PROPERTY_CONFIG_VENC_SYNC_FRAME_SEQUENCE_HEADER;\n\t\tif (ctr->header_mode == V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE)\n\t\t\ten.enable = 0;\n\t\telse\n\t\t\ten.enable = 1;\n\n\t\tret = hfi_session_set_property(inst, ptype, &en);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!ctr->bitrate_peak)\n\t\tbitrate *= 2;\n\telse\n\t\tbitrate = ctr->bitrate_peak;\n\n\tptype = HFI_PROPERTY_CONFIG_VENC_MAX_BITRATE;\n\tbrate.bitrate = bitrate;\n\tbrate.layer_id = 0;\n\n\tret = hfi_session_set_property(inst, ptype, &brate);\n\tif (ret)\n\t\treturn ret;\n\n\tptype = HFI_PROPERTY_PARAM_VENC_SESSION_QP;\n\tif (inst->fmt_cap->pixfmt == V4L2_PIX_FMT_HEVC) {\n\t\tquant.qp_i = ctr->hevc_i_qp;\n\t\tquant.qp_p = ctr->hevc_p_qp;\n\t\tquant.qp_b = ctr->hevc_b_qp;\n\t} else {\n\t\tquant.qp_i = ctr->h264_i_qp;\n\t\tquant.qp_p = ctr->h264_p_qp;\n\t\tquant.qp_b = ctr->h264_b_qp;\n\t}\n\tquant.layer_id = 0;\n\tret = hfi_session_set_property(inst, ptype, &quant);\n\tif (ret)\n\t\treturn ret;\n\n\tif (inst->core->res->hfi_version == HFI_VERSION_4XX ||\n\t    inst->core->res->hfi_version == HFI_VERSION_6XX) {\n\t\tptype = HFI_PROPERTY_PARAM_VENC_SESSION_QP_RANGE_V2;\n\n\t\tif (inst->fmt_cap->pixfmt == V4L2_PIX_FMT_HEVC) {\n\t\t\tquant_range_v2.min_qp.qp_packed = ctr->hevc_min_qp;\n\t\t\tquant_range_v2.max_qp.qp_packed = ctr->hevc_max_qp;\n\t\t} else if (inst->fmt_cap->pixfmt == V4L2_PIX_FMT_VP8) {\n\t\t\tquant_range_v2.min_qp.qp_packed = ctr->vp8_min_qp;\n\t\t\tquant_range_v2.max_qp.qp_packed = ctr->vp8_max_qp;\n\t\t} else {\n\t\t\tquant_range_v2.min_qp.qp_packed = ctr->h264_min_qp;\n\t\t\tquant_range_v2.max_qp.qp_packed = ctr->h264_max_qp;\n\t\t}\n\n\t\tret = hfi_session_set_property(inst, ptype, &quant_range_v2);\n\t} else {\n\t\tptype = HFI_PROPERTY_PARAM_VENC_SESSION_QP_RANGE;\n\n\t\tif (inst->fmt_cap->pixfmt == V4L2_PIX_FMT_HEVC) {\n\t\t\tquant_range.min_qp = ctr->hevc_min_qp;\n\t\t\tquant_range.max_qp = ctr->hevc_max_qp;\n\t\t} else if (inst->fmt_cap->pixfmt == V4L2_PIX_FMT_VP8) {\n\t\t\tquant_range.min_qp = ctr->vp8_min_qp;\n\t\t\tquant_range.max_qp = ctr->vp8_max_qp;\n\t\t} else {\n\t\t\tquant_range.min_qp = ctr->h264_min_qp;\n\t\t\tquant_range.max_qp = ctr->h264_max_qp;\n\t\t}\n\n\t\tquant_range.layer_id = 0;\n\t\tret = hfi_session_set_property(inst, ptype, &quant_range);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tptype = HFI_PROPERTY_PARAM_VENC_LTRMODE;\n\tltr_mode.ltr_count = ctr->ltr_count;\n\tltr_mode.ltr_mode = HFI_LTR_MODE_MANUAL;\n\tltr_mode.trust_mode = 1;\n\tret = hfi_session_set_property(inst, ptype, &ltr_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (inst->hfi_codec) {\n\tcase HFI_VIDEO_CODEC_H264:\n\t\tprofile = ctr->profile.h264;\n\t\tlevel = ctr->level.h264;\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_MPEG4:\n\t\tprofile = ctr->profile.mpeg4;\n\t\tlevel = ctr->level.mpeg4;\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_VP8:\n\t\tprofile = ctr->profile.vp8;\n\t\tlevel = 0;\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_VP9:\n\t\tprofile = ctr->profile.vp9;\n\t\tlevel = ctr->level.vp9;\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_HEVC:\n\t\tprofile = ctr->profile.hevc;\n\t\tlevel = ctr->level.hevc;\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_MPEG2:\n\tdefault:\n\t\tprofile = 0;\n\t\tlevel = 0;\n\t\tbreak;\n\t}\n\n\tret = venus_helper_set_profile_level(inst, profile, level);\n\tif (ret)\n\t\treturn ret;\n\n\tif (inst->fmt_cap->pixfmt == V4L2_PIX_FMT_H264 ||\n\t    inst->fmt_cap->pixfmt == V4L2_PIX_FMT_HEVC) {\n\t\tstruct hfi_enable en = {};\n\n\t\tptype = HFI_PROPERTY_PARAM_VENC_H264_GENERATE_AUDNAL;\n\n\t\tif (ctr->aud_enable)\n\t\t\ten.enable = 1;\n\n\t\tret = hfi_session_set_property(inst, ptype, &en);\n\t}\n\n\tif ((inst->fmt_cap->pixfmt == V4L2_PIX_FMT_H264 ||\n\t     inst->fmt_cap->pixfmt == V4L2_PIX_FMT_HEVC) &&\n\t    (rate_control == HFI_RATE_CONTROL_CBR_VFR ||\n\t     rate_control == HFI_RATE_CONTROL_CBR_CFR)) {\n\t\tintra_refresh.mode = HFI_INTRA_REFRESH_NONE;\n\t\tintra_refresh.cir_mbs = 0;\n\n\t\tif (ctr->intra_refresh_period) {\n\t\t\tu32 mbs;\n\n\t\t\tmbs = ALIGN(inst->width, 16) * ALIGN(inst->height, 16);\n\t\t\tmbs /= 16 * 16;\n\t\t\tif (mbs % ctr->intra_refresh_period)\n\t\t\t\tmbs++;\n\t\t\tmbs /= ctr->intra_refresh_period;\n\n\t\t\tintra_refresh.cir_mbs = mbs;\n\t\t\tif (ctr->intra_refresh_type ==\n\t\t\t    V4L2_CID_MPEG_VIDEO_INTRA_REFRESH_PERIOD_TYPE_CYCLIC)\n\t\t\t\tintra_refresh.mode = HFI_INTRA_REFRESH_CYCLIC;\n\t\t\telse\n\t\t\t\tintra_refresh.mode = HFI_INTRA_REFRESH_RANDOM;\n\t\t}\n\n\t\tptype = HFI_PROPERTY_PARAM_VENC_INTRA_REFRESH;\n\n\t\tret = hfi_session_set_property(inst, ptype, &intra_refresh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int venc_init_session(struct venus_inst *inst)\n{\n\tint ret;\n\n\tret = venus_helper_session_init(inst);\n\tif (ret == -EALREADY)\n\t\treturn 0;\n\telse if (ret)\n\t\treturn ret;\n\n\tret = venus_helper_set_stride(inst, inst->out_width,\n\t\t\t\t      inst->out_height);\n\tif (ret)\n\t\tgoto deinit;\n\n\tret = venus_helper_set_input_resolution(inst, inst->width,\n\t\t\t\t\t\tinst->height);\n\tif (ret)\n\t\tgoto deinit;\n\n\tret = venus_helper_set_output_resolution(inst, inst->width,\n\t\t\t\t\t\t inst->height,\n\t\t\t\t\t\t HFI_BUFFER_OUTPUT);\n\tif (ret)\n\t\tgoto deinit;\n\n\tret = venus_helper_set_color_format(inst, inst->fmt_out->pixfmt);\n\tif (ret)\n\t\tgoto deinit;\n\n\tret = venc_set_properties(inst);\n\tif (ret)\n\t\tgoto deinit;\n\n\treturn 0;\ndeinit:\n\thfi_session_deinit(inst);\n\treturn ret;\n}\n\nstatic int venc_out_num_buffers(struct venus_inst *inst, unsigned int *num)\n{\n\tstruct hfi_buffer_requirements bufreq;\n\tint ret;\n\n\tret = venus_helper_get_bufreq(inst, HFI_BUFFER_INPUT, &bufreq);\n\tif (ret)\n\t\treturn ret;\n\n\t*num = bufreq.count_actual;\n\n\treturn 0;\n}\n\nstatic int venc_queue_setup(struct vb2_queue *q,\n\t\t\t    unsigned int *num_buffers, unsigned int *num_planes,\n\t\t\t    unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(q);\n\tstruct venus_core *core = inst->core;\n\tunsigned int num, min = 4;\n\tint ret;\n\n\tif (*num_planes) {\n\t\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&\n\t\t    *num_planes != inst->fmt_out->num_planes)\n\t\t\treturn -EINVAL;\n\n\t\tif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\n\t\t    *num_planes != inst->fmt_cap->num_planes)\n\t\t\treturn -EINVAL;\n\n\t\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&\n\t\t    sizes[0] < inst->input_buf_size)\n\t\t\treturn -EINVAL;\n\n\t\tif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\n\t\t    sizes[0] < inst->output_buf_size)\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\tif (test_bit(0, &core->sys_error)) {\n\t\tif (inst->nonblock)\n\t\t\treturn -EAGAIN;\n\n\t\tret = wait_event_interruptible(core->sys_err_done,\n\t\t\t\t\t       !test_bit(0, &core->sys_error));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = venc_pm_get(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inst->lock);\n\tret = venc_init_session(inst);\n\tmutex_unlock(&inst->lock);\n\n\tif (ret)\n\t\tgoto put_power;\n\n\tret = venc_pm_put(inst, false);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (q->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\t*num_planes = inst->fmt_out->num_planes;\n\n\t\tret = venc_out_num_buffers(inst, &num);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnum = max(num, min);\n\t\t*num_buffers = max(*num_buffers, num);\n\t\tinst->num_input_bufs = *num_buffers;\n\n\t\tsizes[0] = venus_helper_get_framesz(inst->fmt_out->pixfmt,\n\t\t\t\t\t\t    inst->out_width,\n\t\t\t\t\t\t    inst->out_height);\n\t\tinst->input_buf_size = sizes[0];\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\t*num_planes = inst->fmt_cap->num_planes;\n\t\t*num_buffers = max(*num_buffers, min);\n\t\tinst->num_output_bufs = *num_buffers;\n\t\tsizes[0] = venus_helper_get_framesz(inst->fmt_cap->pixfmt,\n\t\t\t\t\t\t    inst->width,\n\t\t\t\t\t\t    inst->height);\n\t\tsizes[0] = max(sizes[0], inst->output_buf_size);\n\t\tinst->output_buf_size = sizes[0];\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\nput_power:\n\tvenc_pm_put(inst, false);\n\treturn ret;\n}\n\nstatic int venc_buf_init(struct vb2_buffer *vb)\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\n\tinst->buf_count++;\n\n\treturn venus_helper_vb2_buf_init(vb);\n}\n\nstatic void venc_release_session(struct venus_inst *inst)\n{\n\tint ret;\n\n\tvenc_pm_get(inst);\n\n\tmutex_lock(&inst->lock);\n\n\tret = hfi_session_deinit(inst);\n\tif (ret || inst->session_error)\n\t\thfi_session_abort(inst);\n\n\tmutex_unlock(&inst->lock);\n\n\tvenus_pm_load_scale(inst);\n\tINIT_LIST_HEAD(&inst->registeredbufs);\n\tvenus_pm_release_core(inst);\n\n\tvenc_pm_put(inst, false);\n}\n\nstatic void venc_buf_cleanup(struct vb2_buffer *vb)\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct venus_buffer *buf = to_venus_buffer(vbuf);\n\n\tmutex_lock(&inst->lock);\n\tif (vb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tif (!list_empty(&inst->registeredbufs))\n\t\t\tlist_del_init(&buf->reg_list);\n\tmutex_unlock(&inst->lock);\n\n\tinst->buf_count--;\n\tif (!inst->buf_count)\n\t\tvenc_release_session(inst);\n}\n\nstatic int venc_verify_conf(struct venus_inst *inst)\n{\n\tenum hfi_version ver = inst->core->res->hfi_version;\n\tstruct hfi_buffer_requirements bufreq;\n\tint ret;\n\n\tif (!inst->num_input_bufs || !inst->num_output_bufs)\n\t\treturn -EINVAL;\n\n\tret = venus_helper_get_bufreq(inst, HFI_BUFFER_OUTPUT, &bufreq);\n\tif (ret)\n\t\treturn ret;\n\n\tif (inst->num_output_bufs < bufreq.count_actual ||\n\t    inst->num_output_bufs < hfi_bufreq_get_count_min(&bufreq, ver))\n\t\treturn -EINVAL;\n\n\tret = venus_helper_get_bufreq(inst, HFI_BUFFER_INPUT, &bufreq);\n\tif (ret)\n\t\treturn ret;\n\n\tif (inst->num_input_bufs < bufreq.count_actual ||\n\t    inst->num_input_bufs < hfi_bufreq_get_count_min(&bufreq, ver))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int venc_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(q);\n\tint ret;\n\n\tmutex_lock(&inst->lock);\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tinst->streamon_out = 1;\n\telse\n\t\tinst->streamon_cap = 1;\n\n\tif (!(inst->streamon_out & inst->streamon_cap)) {\n\t\tmutex_unlock(&inst->lock);\n\t\treturn 0;\n\t}\n\n\tvenus_helper_init_instance(inst);\n\n\tinst->sequence_cap = 0;\n\tinst->sequence_out = 0;\n\n\tret = venc_pm_get(inst);\n\tif (ret)\n\t\tgoto error;\n\n\tret = venus_pm_acquire_core(inst);\n\tif (ret)\n\t\tgoto put_power;\n\n\tret = venc_pm_put(inst, true);\n\tif (ret)\n\t\tgoto error;\n\n\tret = venc_set_properties(inst);\n\tif (ret)\n\t\tgoto error;\n\n\tret = venc_verify_conf(inst);\n\tif (ret)\n\t\tgoto error;\n\n\tret = venus_helper_set_num_bufs(inst, inst->num_input_bufs,\n\t\t\t\t\tinst->num_output_bufs, 0);\n\tif (ret)\n\t\tgoto error;\n\n\tret = venus_helper_vb2_start_streaming(inst);\n\tif (ret)\n\t\tgoto error;\n\n\tinst->enc_state = VENUS_ENC_STATE_ENCODING;\n\n\tmutex_unlock(&inst->lock);\n\n\treturn 0;\n\nput_power:\n\tvenc_pm_put(inst, false);\nerror:\n\tvenus_helper_buffers_done(inst, q->type, VB2_BUF_STATE_QUEUED);\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tinst->streamon_out = 0;\n\telse\n\t\tinst->streamon_cap = 0;\n\tmutex_unlock(&inst->lock);\n\treturn ret;\n}\n\nstatic void venc_vb2_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvenc_pm_get_put(inst);\n\n\tmutex_lock(&inst->lock);\n\n\tif (inst->enc_state == VENUS_ENC_STATE_STOPPED) {\n\t\tvbuf->sequence = inst->sequence_cap++;\n\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tvb2_set_plane_payload(vb, 0, 0);\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);\n\t\tmutex_unlock(&inst->lock);\n\t\treturn;\n\t}\n\n\tvenus_helper_vb2_buf_queue(vb);\n\tmutex_unlock(&inst->lock);\n}\n\nstatic const struct vb2_ops venc_vb2_ops = {\n\t.queue_setup = venc_queue_setup,\n\t.buf_init = venc_buf_init,\n\t.buf_cleanup = venc_buf_cleanup,\n\t.buf_prepare = venus_helper_vb2_buf_prepare,\n\t.start_streaming = venc_start_streaming,\n\t.stop_streaming = venus_helper_vb2_stop_streaming,\n\t.buf_queue = venc_vb2_buf_queue,\n};\n\nstatic void venc_buf_done(struct venus_inst *inst, unsigned int buf_type,\n\t\t\t  u32 tag, u32 bytesused, u32 data_offset, u32 flags,\n\t\t\t  u32 hfi_flags, u64 timestamp_us)\n{\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct vb2_buffer *vb;\n\tunsigned int type;\n\n\tvenc_pm_touch(inst);\n\n\tif (buf_type == HFI_BUFFER_INPUT)\n\t\ttype = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\telse\n\t\ttype = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\n\tvbuf = venus_helper_find_buf(inst, type, tag);\n\tif (!vbuf)\n\t\treturn;\n\n\tvbuf->flags = flags;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tvb = &vbuf->vb2_buf;\n\t\tvb2_set_plane_payload(vb, 0, bytesused + data_offset);\n\t\tvb->planes[0].data_offset = data_offset;\n\t\tvb->timestamp = timestamp_us * NSEC_PER_USEC;\n\t\tvbuf->sequence = inst->sequence_cap++;\n\t\tif ((vbuf->flags & V4L2_BUF_FLAG_LAST) &&\n\t\t    inst->enc_state == VENUS_ENC_STATE_DRAIN) {\n\t\t\tinst->enc_state = VENUS_ENC_STATE_STOPPED;\n\t\t}\n\t} else {\n\t\tvbuf->sequence = inst->sequence_out++;\n\t}\n\n\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);\n}\n\nstatic void venc_event_notify(struct venus_inst *inst, u32 event,\n\t\t\t      struct hfi_event_data *data)\n{\n\tstruct device *dev = inst->core->dev_enc;\n\n\tvenc_pm_touch(inst);\n\n\tif (event == EVT_SESSION_ERROR) {\n\t\tinst->session_error = true;\n\t\tvenus_helper_vb2_queue_error(inst);\n\t\tdev_err(dev, \"enc: event session error %x\\n\", inst->error);\n\t}\n}\n\nstatic const struct hfi_inst_ops venc_hfi_ops = {\n\t.buf_done = venc_buf_done,\n\t.event_notify = venc_event_notify,\n};\n\nstatic const struct v4l2_m2m_ops venc_m2m_ops = {\n\t.device_run = venus_helper_m2m_device_run,\n\t.job_abort = venus_helper_m2m_job_abort,\n};\n\nstatic int m2m_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t  struct vb2_queue *dst_vq)\n{\n\tstruct venus_inst *inst = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->ops = &venc_vb2_ops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->drv_priv = inst;\n\tsrc_vq->buf_struct_size = sizeof(struct venus_buffer);\n\tsrc_vq->allow_zero_bytesused = 1;\n\tsrc_vq->min_buffers_needed = 1;\n\tsrc_vq->dev = inst->core->dev;\n\tsrc_vq->lock = &inst->ctx_q_lock;\n\tif (inst->core->res->hfi_version == HFI_VERSION_1XX)\n\t\tsrc_vq->bidirectional = 1;\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->ops = &venc_vb2_ops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->drv_priv = inst;\n\tdst_vq->buf_struct_size = sizeof(struct venus_buffer);\n\tdst_vq->allow_zero_bytesused = 1;\n\tdst_vq->min_buffers_needed = 1;\n\tdst_vq->dev = inst->core->dev;\n\tdst_vq->lock = &inst->ctx_q_lock;\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic void venc_inst_init(struct venus_inst *inst)\n{\n\tinst->fmt_cap = &venc_formats[VENUS_FMT_H264];\n\tinst->fmt_out = &venc_formats[VENUS_FMT_NV12];\n\tinst->width = 1280;\n\tinst->height = ALIGN(720, 32);\n\tinst->out_width = 1280;\n\tinst->out_height = 720;\n\tinst->fps = 15;\n\tinst->timeperframe.numerator = 1;\n\tinst->timeperframe.denominator = 15;\n\tinst->hfi_codec = HFI_VIDEO_CODEC_H264;\n}\n\nstatic int venc_open(struct file *file)\n{\n\tstruct venus_core *core = video_drvdata(file);\n\tstruct venus_inst *inst;\n\tint ret;\n\n\tinst = kzalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&inst->dpbbufs);\n\tINIT_LIST_HEAD(&inst->registeredbufs);\n\tINIT_LIST_HEAD(&inst->internalbufs);\n\tINIT_LIST_HEAD(&inst->list);\n\tmutex_init(&inst->lock);\n\tmutex_init(&inst->ctx_q_lock);\n\n\tinst->core = core;\n\tinst->session_type = VIDC_SESSION_TYPE_ENC;\n\tinst->clk_data.core_id = VIDC_CORE_ID_DEFAULT;\n\tinst->core_acquired = false;\n\tinst->nonblock = file->f_flags & O_NONBLOCK;\n\n\tif (inst->enc_state == VENUS_ENC_STATE_DEINIT)\n\t\tinst->enc_state = VENUS_ENC_STATE_INIT;\n\n\tvenus_helper_init_instance(inst);\n\n\tret = venc_ctrl_init(inst);\n\tif (ret)\n\t\tgoto err_free;\n\n\tret = hfi_session_create(inst, &venc_hfi_ops);\n\tif (ret)\n\t\tgoto err_ctrl_deinit;\n\n\tvenc_inst_init(inst);\n\n\t \n\tinst->m2m_dev = v4l2_m2m_init(&venc_m2m_ops);\n\tif (IS_ERR(inst->m2m_dev)) {\n\t\tret = PTR_ERR(inst->m2m_dev);\n\t\tgoto err_session_destroy;\n\t}\n\n\tinst->m2m_ctx = v4l2_m2m_ctx_init(inst->m2m_dev, inst, m2m_queue_init);\n\tif (IS_ERR(inst->m2m_ctx)) {\n\t\tret = PTR_ERR(inst->m2m_ctx);\n\t\tgoto err_m2m_release;\n\t}\n\n\tv4l2_fh_init(&inst->fh, core->vdev_enc);\n\n\tinst->fh.ctrl_handler = &inst->ctrl_handler;\n\tv4l2_fh_add(&inst->fh);\n\tinst->fh.m2m_ctx = inst->m2m_ctx;\n\tfile->private_data = &inst->fh;\n\n\treturn 0;\n\nerr_m2m_release:\n\tv4l2_m2m_release(inst->m2m_dev);\nerr_session_destroy:\n\thfi_session_destroy(inst);\nerr_ctrl_deinit:\n\tvenc_ctrl_deinit(inst);\nerr_free:\n\tkfree(inst);\n\treturn ret;\n}\n\nstatic int venc_close(struct file *file)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\n\tvenc_pm_get(inst);\n\n\tv4l2_m2m_ctx_release(inst->m2m_ctx);\n\tv4l2_m2m_release(inst->m2m_dev);\n\tvenc_ctrl_deinit(inst);\n\thfi_session_destroy(inst);\n\tmutex_destroy(&inst->lock);\n\tmutex_destroy(&inst->ctx_q_lock);\n\tv4l2_fh_del(&inst->fh);\n\tv4l2_fh_exit(&inst->fh);\n\n\tinst->enc_state = VENUS_ENC_STATE_DEINIT;\n\n\tvenc_pm_put(inst, false);\n\n\tkfree(inst);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations venc_fops = {\n\t.owner = THIS_MODULE,\n\t.open = venc_open,\n\t.release = venc_close,\n\t.unlocked_ioctl = video_ioctl2,\n\t.poll = v4l2_m2m_fop_poll,\n\t.mmap = v4l2_m2m_fop_mmap,\n};\n\nstatic int venc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct video_device *vdev;\n\tstruct venus_core *core;\n\tint ret;\n\n\tif (!dev->parent)\n\t\treturn -EPROBE_DEFER;\n\n\tcore = dev_get_drvdata(dev->parent);\n\tif (!core)\n\t\treturn -EPROBE_DEFER;\n\n\tplatform_set_drvdata(pdev, core);\n\n\tif (core->pm_ops->venc_get) {\n\t\tret = core->pm_ops->venc_get(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tvdev = video_device_alloc();\n\tif (!vdev)\n\t\treturn -ENOMEM;\n\n\tstrscpy(vdev->name, \"qcom-venus-encoder\", sizeof(vdev->name));\n\tvdev->release = video_device_release;\n\tvdev->fops = &venc_fops;\n\tvdev->ioctl_ops = &venc_ioctl_ops;\n\tvdev->vfl_dir = VFL_DIR_M2M;\n\tvdev->v4l2_dev = &core->v4l2_dev;\n\tvdev->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret)\n\t\tgoto err_vdev_release;\n\n\tcore->vdev_enc = vdev;\n\tcore->dev_enc = dev;\n\n\tvideo_set_drvdata(vdev, core);\n\tpm_runtime_set_autosuspend_delay(dev, 2000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nerr_vdev_release:\n\tvideo_device_release(vdev);\n\treturn ret;\n}\n\nstatic void venc_remove(struct platform_device *pdev)\n{\n\tstruct venus_core *core = dev_get_drvdata(pdev->dev.parent);\n\n\tvideo_unregister_device(core->vdev_enc);\n\tpm_runtime_disable(core->dev_enc);\n\n\tif (core->pm_ops->venc_put)\n\t\tcore->pm_ops->venc_put(core->dev_enc);\n}\n\nstatic __maybe_unused int venc_runtime_suspend(struct device *dev)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\tconst struct venus_pm_ops *pm_ops = core->pm_ops;\n\tint ret = 0;\n\n\tif (pm_ops->venc_power)\n\t\tret = pm_ops->venc_power(dev, POWER_OFF);\n\n\treturn ret;\n}\n\nstatic __maybe_unused int venc_runtime_resume(struct device *dev)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\tconst struct venus_pm_ops *pm_ops = core->pm_ops;\n\tint ret = 0;\n\n\tif (pm_ops->venc_power)\n\t\tret = pm_ops->venc_power(dev, POWER_ON);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops venc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(venc_runtime_suspend, venc_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id venc_dt_match[] = {\n\t{ .compatible = \"venus-encoder\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, venc_dt_match);\n\nstatic struct platform_driver qcom_venus_enc_driver = {\n\t.probe = venc_probe,\n\t.remove_new = venc_remove,\n\t.driver = {\n\t\t.name = \"qcom-venus-encoder\",\n\t\t.of_match_table = venc_dt_match,\n\t\t.pm = &venc_pm_ops,\n\t},\n};\nmodule_platform_driver(qcom_venus_enc_driver);\n\nMODULE_ALIAS(\"platform:qcom-venus-encoder\");\nMODULE_DESCRIPTION(\"Qualcomm Venus video encoder driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}