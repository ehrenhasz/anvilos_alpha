{
  "module_name": "vdec.c",
  "hash_id": "f91843ed589db471e60795907263aa1ea6b2d951d5730e9f3042aa7f1d0fecf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/venus/vdec.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"hfi_venus_io.h\"\n#include \"hfi_parser.h\"\n#include \"core.h\"\n#include \"helpers.h\"\n#include \"vdec.h\"\n#include \"pm_helpers.h\"\n\n \nstatic const struct venus_format vdec_formats[] = {\n\t[VENUS_FMT_NV12] = {\n\t\t.pixfmt = V4L2_PIX_FMT_NV12,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t},\n\t[VENUS_FMT_QC08C] = {\n\t\t.pixfmt = V4L2_PIX_FMT_QC08C,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t},\n\t[VENUS_FMT_QC10C] = {\n\t\t.pixfmt = V4L2_PIX_FMT_QC10C,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t},\n\t[VENUS_FMT_P010] = {\n\t\t.pixfmt = V4L2_PIX_FMT_P010,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t},\n\t[VENUS_FMT_H264] = {\n\t\t.pixfmt = V4L2_PIX_FMT_H264,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t[VENUS_FMT_VP8] = {\n\t\t.pixfmt = V4L2_PIX_FMT_VP8,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t[VENUS_FMT_VP9] = {\n\t\t.pixfmt = V4L2_PIX_FMT_VP9,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t[VENUS_FMT_HEVC] = {\n\t\t.pixfmt = V4L2_PIX_FMT_HEVC,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t[VENUS_FMT_VC1_ANNEX_G] = {\n\t\t.pixfmt = V4L2_PIX_FMT_VC1_ANNEX_G,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t[VENUS_FMT_VC1_ANNEX_L] = {\n\t\t.pixfmt = V4L2_PIX_FMT_VC1_ANNEX_L,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t[VENUS_FMT_MPEG4] = {\n\t\t.pixfmt = V4L2_PIX_FMT_MPEG4,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t[VENUS_FMT_MPEG2] = {\n\t\t.pixfmt = V4L2_PIX_FMT_MPEG2,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t[VENUS_FMT_H263] = {\n\t\t.pixfmt = V4L2_PIX_FMT_H263,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\t[VENUS_FMT_XVID] = {\n\t\t.pixfmt = V4L2_PIX_FMT_XVID,\n\t\t.num_planes = 1,\n\t\t.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t.flags = V4L2_FMT_FLAG_DYN_RESOLUTION,\n\t},\n\n};\n\nstatic const struct venus_format *\nfind_format(struct venus_inst *inst, u32 pixfmt, u32 type)\n{\n\tconst struct venus_format *fmt = vdec_formats;\n\tunsigned int size = ARRAY_SIZE(vdec_formats);\n\tunsigned int i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (fmt[i].pixfmt == pixfmt)\n\t\t\tbreak;\n\t}\n\n\tif (i == size || fmt[i].type != type)\n\t\treturn NULL;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&\n\t    !venus_helper_check_codec(inst, fmt[i].pixfmt))\n\t\treturn NULL;\n\n\tif (V4L2_TYPE_IS_CAPTURE(type) &&\n\t    !venus_helper_check_format(inst, fmt[i].pixfmt))\n\t\treturn NULL;\n\n\tif (V4L2_TYPE_IS_CAPTURE(type) && fmt[i].pixfmt == V4L2_PIX_FMT_QC10C &&\n\t    !(inst->bit_depth == VIDC_BITDEPTH_10))\n\t\treturn NULL;\n\n\treturn &fmt[i];\n}\n\nstatic const struct venus_format *\nfind_format_by_index(struct venus_inst *inst, unsigned int index, u32 type)\n{\n\tconst struct venus_format *fmt = vdec_formats;\n\tunsigned int size = ARRAY_SIZE(vdec_formats);\n\tunsigned int i, k = 0;\n\n\tif (index > size)\n\t\treturn NULL;\n\n\tfor (i = 0; i < size; i++) {\n\t\tbool valid;\n\n\t\tif (fmt[i].type != type)\n\t\t\tcontinue;\n\n\t\tif (V4L2_TYPE_IS_OUTPUT(type)) {\n\t\t\tvalid = venus_helper_check_codec(inst, fmt[i].pixfmt);\n\t\t} else if (V4L2_TYPE_IS_CAPTURE(type)) {\n\t\t\tvalid = venus_helper_check_format(inst, fmt[i].pixfmt);\n\n\t\t\tif (fmt[i].pixfmt == V4L2_PIX_FMT_QC10C &&\n\t\t\t    !(inst->bit_depth == VIDC_BITDEPTH_10))\n\t\t\t\tvalid = false;\n\t\t}\n\n\t\tif (k == index && valid)\n\t\t\tbreak;\n\t\tif (valid)\n\t\t\tk++;\n\t}\n\n\tif (i == size)\n\t\treturn NULL;\n\n\treturn &fmt[i];\n}\n\nstatic const struct venus_format *\nvdec_try_fmt_common(struct venus_inst *inst, struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tstruct v4l2_plane_pix_format *pfmt = pixmp->plane_fmt;\n\tconst struct venus_format *fmt;\n\tu32 szimage;\n\n\tmemset(pfmt[0].reserved, 0, sizeof(pfmt[0].reserved));\n\tmemset(pixmp->reserved, 0, sizeof(pixmp->reserved));\n\n\tfmt = find_format(inst, pixmp->pixelformat, f->type);\n\tif (!fmt) {\n\t\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\t\tpixmp->pixelformat = V4L2_PIX_FMT_NV12;\n\t\telse if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\t\tpixmp->pixelformat = V4L2_PIX_FMT_H264;\n\t\telse\n\t\t\treturn NULL;\n\t\tfmt = find_format(inst, pixmp->pixelformat, f->type);\n\t\tif (!fmt)\n\t\t\treturn NULL;\n\t}\n\n\tpixmp->width = clamp(pixmp->width, frame_width_min(inst),\n\t\t\t     frame_width_max(inst));\n\tpixmp->height = clamp(pixmp->height, frame_height_min(inst),\n\t\t\t      frame_height_max(inst));\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tpixmp->height = ALIGN(pixmp->height, 32);\n\n\tif (pixmp->field == V4L2_FIELD_ANY)\n\t\tpixmp->field = V4L2_FIELD_NONE;\n\tpixmp->num_planes = fmt->num_planes;\n\tpixmp->flags = 0;\n\n\tszimage = venus_helper_get_framesz(pixmp->pixelformat, pixmp->width,\n\t\t\t\t\t   pixmp->height);\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tunsigned int stride = pixmp->width;\n\n\t\tif (pixmp->pixelformat == V4L2_PIX_FMT_P010)\n\t\t\tstride *= 2;\n\n\t\tpfmt[0].sizeimage = szimage;\n\t\tpfmt[0].bytesperline = ALIGN(stride, 128);\n\t} else {\n\t\tpfmt[0].sizeimage = clamp_t(u32, pfmt[0].sizeimage, 0, SZ_8M);\n\t\tpfmt[0].sizeimage = max(pfmt[0].sizeimage, szimage);\n\t\tpfmt[0].bytesperline = 0;\n\t}\n\n\treturn fmt;\n}\n\nstatic int vdec_try_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\n\tvdec_try_fmt_common(inst, f);\n\n\treturn 0;\n}\n\nstatic int vdec_check_src_change(struct venus_inst *inst)\n{\n\tint ret;\n\n\tif (inst->subscriptions & V4L2_EVENT_SOURCE_CHANGE &&\n\t    inst->codec_state == VENUS_DEC_STATE_INIT &&\n\t    !inst->reconfig)\n\t\treturn -EINVAL;\n\n\tif (inst->subscriptions & V4L2_EVENT_SOURCE_CHANGE)\n\t\treturn 0;\n\n\t \n\n\tif (inst->codec_state != VENUS_DEC_STATE_INIT)\n\t\tgoto done;\n\n\tret = wait_event_timeout(inst->reconf_wait, inst->reconfig,\n\t\t\t\t msecs_to_jiffies(100));\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\tif (!(inst->codec_state == VENUS_DEC_STATE_CAPTURE_SETUP) ||\n\t    !inst->reconfig)\n\t\tdev_dbg(inst->core->dev, VDBGH \"wrong state\\n\");\n\ndone:\n\treturn 0;\n}\n\nstatic int vdec_g_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\tconst struct venus_format *fmt = NULL;\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tint ret;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tfmt = inst->fmt_cap;\n\telse if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tfmt = inst->fmt_out;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tret = vdec_check_src_change(inst);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpixmp->pixelformat = fmt->pixfmt;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tpixmp->width = inst->width;\n\t\tpixmp->height = inst->height;\n\t\tpixmp->colorspace = inst->colorspace;\n\t\tpixmp->ycbcr_enc = inst->ycbcr_enc;\n\t\tpixmp->quantization = inst->quantization;\n\t\tpixmp->xfer_func = inst->xfer_func;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tpixmp->width = inst->out_width;\n\t\tpixmp->height = inst->out_height;\n\t}\n\n\tvdec_try_fmt_common(inst, f);\n\n\treturn 0;\n}\n\nstatic int vdec_s_fmt(struct file *file, void *fh, struct v4l2_format *f)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\tstruct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;\n\tstruct v4l2_pix_format_mplane orig_pixmp;\n\tconst struct venus_format *fmt;\n\tstruct v4l2_format format;\n\tu32 pixfmt_out = 0, pixfmt_cap = 0;\n\tstruct vb2_queue *q;\n\n\tq = v4l2_m2m_get_vq(inst->m2m_ctx, f->type);\n\tif (!q)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\torig_pixmp = *pixmp;\n\n\tfmt = vdec_try_fmt_common(inst, f);\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tpixfmt_out = pixmp->pixelformat;\n\t\tpixfmt_cap = inst->fmt_cap->pixfmt;\n\t} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tpixfmt_cap = pixmp->pixelformat;\n\t\tpixfmt_out = inst->fmt_out->pixfmt;\n\t}\n\n\tmemset(&format, 0, sizeof(format));\n\n\tformat.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tformat.fmt.pix_mp.pixelformat = pixfmt_out;\n\tformat.fmt.pix_mp.width = orig_pixmp.width;\n\tformat.fmt.pix_mp.height = orig_pixmp.height;\n\tvdec_try_fmt_common(inst, &format);\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tinst->out_width = format.fmt.pix_mp.width;\n\t\tinst->out_height = format.fmt.pix_mp.height;\n\t\tinst->colorspace = pixmp->colorspace;\n\t\tinst->ycbcr_enc = pixmp->ycbcr_enc;\n\t\tinst->quantization = pixmp->quantization;\n\t\tinst->xfer_func = pixmp->xfer_func;\n\t\tinst->input_buf_size = pixmp->plane_fmt[0].sizeimage;\n\t}\n\n\tmemset(&format, 0, sizeof(format));\n\n\tformat.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tformat.fmt.pix_mp.pixelformat = pixfmt_cap;\n\tformat.fmt.pix_mp.width = orig_pixmp.width;\n\tformat.fmt.pix_mp.height = orig_pixmp.height;\n\tvdec_try_fmt_common(inst, &format);\n\n\tinst->width = format.fmt.pix_mp.width;\n\tinst->height = format.fmt.pix_mp.height;\n\tinst->crop.top = 0;\n\tinst->crop.left = 0;\n\tinst->crop.width = inst->width;\n\tinst->crop.height = inst->height;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tinst->fmt_out = fmt;\n\telse if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tinst->fmt_cap = fmt;\n\t\tinst->output2_buf_size =\n\t\t\tvenus_helper_get_framesz(pixfmt_cap, orig_pixmp.width, orig_pixmp.height);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvdec_g_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\ts->r.top = 0;\n\ts->r.left = 0;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\ts->r.width = inst->out_width;\n\t\ts->r.height = inst->out_height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\tcase V4L2_SEL_TGT_COMPOSE_PADDED:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\ts->r.width = inst->width;\n\t\ts->r.height = inst->height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\ts->r = inst->crop;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvdec_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, \"qcom-venus\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"Qualcomm Venus video decoder\", sizeof(cap->card));\n\tstrscpy(cap->bus_info, \"platform:qcom-venus\", sizeof(cap->bus_info));\n\n\treturn 0;\n}\n\nstatic int vdec_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\tconst struct venus_format *fmt;\n\n\tmemset(f->reserved, 0, sizeof(f->reserved));\n\n\tfmt = find_format_by_index(inst, f->index, f->type);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = fmt->pixfmt;\n\tf->flags = fmt->flags;\n\n\treturn 0;\n}\n\nstatic int vdec_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\tstruct v4l2_captureparm *cap = &a->parm.capture;\n\tstruct v4l2_fract *timeperframe = &cap->timeperframe;\n\tu64 us_per_frame, fps;\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\n\t    a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn -EINVAL;\n\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\tif (!timeperframe->denominator)\n\t\ttimeperframe->denominator = inst->timeperframe.denominator;\n\tif (!timeperframe->numerator)\n\t\ttimeperframe->numerator = inst->timeperframe.numerator;\n\tcap->readbuffers = 0;\n\tcap->extendedmode = 0;\n\tcap->capability = V4L2_CAP_TIMEPERFRAME;\n\tus_per_frame = timeperframe->numerator * (u64)USEC_PER_SEC;\n\tdo_div(us_per_frame, timeperframe->denominator);\n\n\tif (!us_per_frame)\n\t\treturn -EINVAL;\n\n\tfps = (u64)USEC_PER_SEC;\n\tdo_div(fps, us_per_frame);\n\n\tinst->fps = fps;\n\tinst->timeperframe = *timeperframe;\n\n\treturn 0;\n}\n\nstatic int vdec_enum_framesizes(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_frmsizeenum *fsize)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\tconst struct venus_format *fmt;\n\n\tfmt = find_format(inst, fsize->pixel_format,\n\t\t\t  V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (!fmt) {\n\t\tfmt = find_format(inst, fsize->pixel_format,\n\t\t\t\t  V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\t\tif (!fmt)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\n\tfsize->stepwise.min_width = frame_width_min(inst);\n\tfsize->stepwise.max_width = frame_width_max(inst);\n\tfsize->stepwise.step_width = frame_width_step(inst);\n\tfsize->stepwise.min_height = frame_height_min(inst);\n\tfsize->stepwise.max_height = frame_height_max(inst);\n\tfsize->stepwise.step_height = frame_height_step(inst);\n\n\treturn 0;\n}\n\nstatic int vdec_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\tconst struct v4l2_event_subscription *sub)\n{\n\tstruct venus_inst *inst = container_of(fh, struct venus_inst, fh);\n\tint ret;\n\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_EOS:\n\t\treturn v4l2_event_subscribe(fh, sub, 2, NULL);\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\tret = v4l2_src_change_event_subscribe(fh, sub);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tinst->subscriptions |= V4L2_EVENT_SOURCE_CHANGE;\n\t\treturn 0;\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nvdec_decoder_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *cmd)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\tstruct vb2_queue *dst_vq;\n\tstruct hfi_frame_data fdata = {0};\n\tint ret;\n\n\tret = v4l2_m2m_ioctl_try_decoder_cmd(file, fh, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inst->lock);\n\n\tif (cmd->cmd == V4L2_DEC_CMD_STOP) {\n\t\t \n\t\tif (!(inst->streamon_out && inst->streamon_cap))\n\t\t\tgoto unlock;\n\n\t\tfdata.buffer_type = HFI_BUFFER_INPUT;\n\t\tfdata.flags |= HFI_BUFFERFLAG_EOS;\n\t\tif (IS_V6(inst->core) && is_fw_rev_or_older(inst->core, 1, 0, 87))\n\t\t\tfdata.device_addr = 0;\n\t\telse\n\t\t\tfdata.device_addr = 0xdeadb000;\n\n\t\tret = hfi_session_process_buf(inst, &fdata);\n\n\t\tif (!ret && inst->codec_state == VENUS_DEC_STATE_DECODING) {\n\t\t\tinst->codec_state = VENUS_DEC_STATE_DRAIN;\n\t\t\tinst->drain_active = true;\n\t\t}\n\t} else if (cmd->cmd == V4L2_DEC_CMD_START &&\n\t\t   inst->codec_state == VENUS_DEC_STATE_STOPPED) {\n\t\tdst_vq = v4l2_m2m_get_vq(inst->fh.m2m_ctx,\n\t\t\t\t\t V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\t\tvb2_clear_last_buffer_dequeued(dst_vq);\n\n\t\tinst->codec_state = VENUS_DEC_STATE_DECODING;\n\t}\n\nunlock:\n\tmutex_unlock(&inst->lock);\n\treturn ret;\n}\n\nstatic const struct v4l2_ioctl_ops vdec_ioctl_ops = {\n\t.vidioc_querycap = vdec_querycap,\n\t.vidioc_enum_fmt_vid_cap = vdec_enum_fmt,\n\t.vidioc_enum_fmt_vid_out = vdec_enum_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane = vdec_s_fmt,\n\t.vidioc_s_fmt_vid_out_mplane = vdec_s_fmt,\n\t.vidioc_g_fmt_vid_cap_mplane = vdec_g_fmt,\n\t.vidioc_g_fmt_vid_out_mplane = vdec_g_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane = vdec_try_fmt,\n\t.vidioc_try_fmt_vid_out_mplane = vdec_try_fmt,\n\t.vidioc_g_selection = vdec_g_selection,\n\t.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,\n\t.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_streamon = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,\n\t.vidioc_s_parm = vdec_s_parm,\n\t.vidioc_enum_framesizes = vdec_enum_framesizes,\n\t.vidioc_subscribe_event = vdec_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_try_decoder_cmd = v4l2_m2m_ioctl_try_decoder_cmd,\n\t.vidioc_decoder_cmd = vdec_decoder_cmd,\n};\n\nstatic int vdec_pm_get(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct device *dev = core->dev_dec;\n\tint ret;\n\n\tmutex_lock(&core->pm_lock);\n\tret = pm_runtime_resume_and_get(dev);\n\tmutex_unlock(&core->pm_lock);\n\n\treturn ret;\n}\n\nstatic int vdec_pm_put(struct venus_inst *inst, bool autosuspend)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct device *dev = core->dev_dec;\n\tint ret;\n\n\tmutex_lock(&core->pm_lock);\n\n\tif (autosuspend)\n\t\tret = pm_runtime_put_autosuspend(dev);\n\telse\n\t\tret = pm_runtime_put_sync(dev);\n\n\tmutex_unlock(&core->pm_lock);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int vdec_pm_get_put(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct device *dev = core->dev_dec;\n\tint ret = 0;\n\n\tmutex_lock(&core->pm_lock);\n\n\tif (pm_runtime_suspended(dev)) {\n\t\tret = pm_runtime_resume_and_get(dev);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tret = pm_runtime_put_autosuspend(dev);\n\t}\n\nerror:\n\tmutex_unlock(&core->pm_lock);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic void vdec_pm_touch(struct venus_inst *inst)\n{\n\tpm_runtime_mark_last_busy(inst->core->dev_dec);\n}\n\nstatic int vdec_set_properties(struct venus_inst *inst)\n{\n\tstruct vdec_controls *ctr = &inst->controls.dec;\n\tstruct hfi_enable en = { .enable = 1 };\n\tu32 ptype, decode_order, conceal;\n\tint ret;\n\n\tif (ctr->post_loop_deb_mode) {\n\t\tptype = HFI_PROPERTY_CONFIG_VDEC_POST_LOOP_DEBLOCKER;\n\t\tret = hfi_session_set_property(inst, ptype, &en);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ctr->display_delay_enable && ctr->display_delay == 0) {\n\t\tptype = HFI_PROPERTY_PARAM_VDEC_OUTPUT_ORDER;\n\t\tdecode_order = HFI_OUTPUT_ORDER_DECODE;\n\t\tret = hfi_session_set_property(inst, ptype, &decode_order);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (is_fw_rev_or_newer(inst->core, 5, 4, 51)) {\n\t\tptype = HFI_PROPERTY_PARAM_VDEC_ENABLE_SUFFICIENT_SEQCHANGE_EVENT;\n\t\tret = hfi_session_set_property(inst, ptype, &en);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tptype = HFI_PROPERTY_PARAM_VDEC_CONCEAL_COLOR;\n\tconceal = ctr->conceal_color & 0xffff;\n\tconceal |= ((ctr->conceal_color >> 16) & 0xffff) << 10;\n\tconceal |= ((ctr->conceal_color >> 32) & 0xffff) << 20;\n\n\tret = hfi_session_set_property(inst, ptype, &conceal);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int vdec_set_work_route(struct venus_inst *inst)\n{\n\tu32 ptype = HFI_PROPERTY_PARAM_WORK_ROUTE;\n\tstruct hfi_video_work_route wr;\n\n\tif (!(IS_IRIS2(inst->core) || IS_IRIS2_1(inst->core)))\n\t\treturn 0;\n\n\twr.video_work_route = inst->core->res->num_vpp_pipes;\n\n\treturn hfi_session_set_property(inst, ptype, &wr);\n}\n\n#define is_ubwc_fmt(fmt) (!!((fmt) & HFI_COLOR_FORMAT_UBWC_BASE))\n#define is_10bit_ubwc_fmt(fmt) (!!((fmt) & HFI_COLOR_FORMAT_10_BIT_BASE & \\\n\t\t\t\t HFI_COLOR_FORMAT_UBWC_BASE))\n\n\nstatic int vdec_output_conf(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct hfi_enable en = { .enable = 1 };\n\tstruct hfi_buffer_requirements bufreq;\n\tu32 width = inst->width;\n\tu32 height = inst->height;\n\tu32 out_fmt, out2_fmt;\n\tbool ubwc = false;\n\tu32 ptype;\n\tint ret;\n\n\tret = venus_helper_set_work_mode(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tif (core->res->hfi_version == HFI_VERSION_1XX) {\n\t\tptype = HFI_PROPERTY_PARAM_VDEC_CONTINUE_DATA_TRANSFER;\n\t\tret = hfi_session_set_property(inst, ptype, &en);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (width > 1920 && height > ALIGN(1080, 32))\n\t\tubwc = true;\n\n\t \n\tif (IS_V4(core) || IS_V6(core))\n\t\tubwc = true;\n\n\tret = venus_helper_get_out_fmts(inst, inst->fmt_cap->pixfmt, &out_fmt,\n\t\t\t\t\t&out2_fmt, ubwc);\n\tif (ret)\n\t\treturn ret;\n\n\tinst->output_buf_size =\n\t\t\tvenus_helper_get_framesz_raw(out_fmt, width, height);\n\tinst->output2_buf_size =\n\t\t\tvenus_helper_get_framesz_raw(out2_fmt, width, height);\n\n\tif (is_ubwc_fmt(out_fmt)) {\n\t\tinst->opb_buftype = HFI_BUFFER_OUTPUT2;\n\t\tinst->opb_fmt = out2_fmt;\n\t\tinst->dpb_buftype = HFI_BUFFER_OUTPUT;\n\t\tinst->dpb_fmt = out_fmt;\n\t} else if (is_ubwc_fmt(out2_fmt) || is_10bit_ubwc_fmt(out_fmt)) {\n\t\tinst->opb_buftype = HFI_BUFFER_OUTPUT;\n\t\tinst->opb_fmt = out_fmt;\n\t\tinst->dpb_buftype = HFI_BUFFER_OUTPUT2;\n\t\tinst->dpb_fmt = out2_fmt;\n\t} else {\n\t\tinst->opb_buftype = HFI_BUFFER_OUTPUT;\n\t\tinst->opb_fmt = out_fmt;\n\t\tinst->dpb_buftype = 0;\n\t\tinst->dpb_fmt = 0;\n\t}\n\n\tret = venus_helper_set_raw_format(inst, inst->opb_fmt,\n\t\t\t\t\t  inst->opb_buftype);\n\tif (ret)\n\t\treturn ret;\n\n\tret = venus_helper_set_format_constraints(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tif (inst->dpb_fmt) {\n\t\tret = venus_helper_set_multistream(inst, false, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = venus_helper_set_raw_format(inst, inst->dpb_fmt,\n\t\t\t\t\t\t  inst->dpb_buftype);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = venus_helper_set_output_resolution(inst, width, height,\n\t\t\t\t\t\t\t HFI_BUFFER_OUTPUT2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (IS_V3(core) || IS_V4(core) || IS_V6(core)) {\n\t\tret = venus_helper_get_bufreq(inst, HFI_BUFFER_OUTPUT, &bufreq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (bufreq.size > inst->output_buf_size)\n\t\t\treturn -EINVAL;\n\n\t\tif (inst->dpb_fmt) {\n\t\t\tret = venus_helper_get_bufreq(inst, HFI_BUFFER_OUTPUT2,\n\t\t\t\t\t\t      &bufreq);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (bufreq.size > inst->output2_buf_size)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (inst->output2_buf_size) {\n\t\t\tret = venus_helper_set_bufsize(inst,\n\t\t\t\t\t\t       inst->output2_buf_size,\n\t\t\t\t\t\t       HFI_BUFFER_OUTPUT2);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (inst->output_buf_size) {\n\t\t\tret = venus_helper_set_bufsize(inst,\n\t\t\t\t\t\t       inst->output_buf_size,\n\t\t\t\t\t\t       HFI_BUFFER_OUTPUT);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = venus_helper_set_dyn_bufmode(inst);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int vdec_session_init(struct venus_inst *inst)\n{\n\tint ret;\n\n\tret = venus_helper_session_init(inst);\n\tif (ret == -EALREADY)\n\t\treturn 0;\n\telse if (ret)\n\t\treturn ret;\n\n\tret = venus_helper_set_input_resolution(inst, frame_width_min(inst),\n\t\t\t\t\t\tframe_height_min(inst));\n\tif (ret)\n\t\tgoto deinit;\n\n\treturn 0;\ndeinit:\n\thfi_session_deinit(inst);\n\treturn ret;\n}\n\nstatic int vdec_num_buffers(struct venus_inst *inst, unsigned int *in_num,\n\t\t\t    unsigned int *out_num)\n{\n\tenum hfi_version ver = inst->core->res->hfi_version;\n\tstruct hfi_buffer_requirements bufreq;\n\tint ret;\n\n\t*in_num = *out_num = 0;\n\n\tret = venus_helper_get_bufreq(inst, HFI_BUFFER_INPUT, &bufreq);\n\tif (ret)\n\t\treturn ret;\n\n\t*in_num = hfi_bufreq_get_count_min(&bufreq, ver);\n\n\tret = venus_helper_get_bufreq(inst, HFI_BUFFER_OUTPUT, &bufreq);\n\tif (ret)\n\t\treturn ret;\n\n\t*out_num = hfi_bufreq_get_count_min(&bufreq, ver);\n\n\treturn 0;\n}\n\nstatic int vdec_queue_setup(struct vb2_queue *q,\n\t\t\t    unsigned int *num_buffers, unsigned int *num_planes,\n\t\t\t    unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(q);\n\tstruct venus_core *core = inst->core;\n\tunsigned int in_num, out_num;\n\tint ret = 0;\n\n\tif (*num_planes) {\n\t\tunsigned int output_buf_size = venus_helper_get_opb_size(inst);\n\n\t\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&\n\t\t    *num_planes != inst->fmt_out->num_planes)\n\t\t\treturn -EINVAL;\n\n\t\tif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\n\t\t    *num_planes != inst->fmt_cap->num_planes)\n\t\t\treturn -EINVAL;\n\n\t\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&\n\t\t    sizes[0] < inst->input_buf_size)\n\t\t\treturn -EINVAL;\n\n\t\tif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\n\t\t    sizes[0] < output_buf_size)\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\tif (test_bit(0, &core->sys_error)) {\n\t\tif (inst->nonblock)\n\t\t\treturn -EAGAIN;\n\n\t\tret = wait_event_interruptible(core->sys_err_done,\n\t\t\t\t\t       !test_bit(0, &core->sys_error));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = vdec_pm_get(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vdec_session_init(inst);\n\tif (ret)\n\t\tgoto put_power;\n\n\tret = vdec_num_buffers(inst, &in_num, &out_num);\n\tif (ret)\n\t\tgoto put_power;\n\n\tret = vdec_pm_put(inst, false);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (q->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\t*num_planes = inst->fmt_out->num_planes;\n\t\tsizes[0] = venus_helper_get_framesz(inst->fmt_out->pixfmt,\n\t\t\t\t\t\t    inst->out_width,\n\t\t\t\t\t\t    inst->out_height);\n\t\tsizes[0] = max(sizes[0], inst->input_buf_size);\n\t\tinst->input_buf_size = sizes[0];\n\t\t*num_buffers = max(*num_buffers, in_num);\n\t\tinst->num_input_bufs = *num_buffers;\n\t\tinst->num_output_bufs = out_num;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\t*num_planes = inst->fmt_cap->num_planes;\n\t\tsizes[0] = venus_helper_get_framesz(inst->fmt_cap->pixfmt,\n\t\t\t\t\t\t    inst->width,\n\t\t\t\t\t\t    inst->height);\n\t\tinst->output_buf_size = sizes[0];\n\t\t*num_buffers = max(*num_buffers, out_num);\n\t\tinst->num_output_bufs = *num_buffers;\n\n\t\tmutex_lock(&inst->lock);\n\t\tif (inst->codec_state == VENUS_DEC_STATE_CAPTURE_SETUP)\n\t\t\tinst->codec_state = VENUS_DEC_STATE_STOPPED;\n\t\tmutex_unlock(&inst->lock);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n\nput_power:\n\tvdec_pm_put(inst, false);\n\treturn ret;\n}\n\nstatic int vdec_verify_conf(struct venus_inst *inst)\n{\n\tenum hfi_version ver = inst->core->res->hfi_version;\n\tstruct hfi_buffer_requirements bufreq;\n\tint ret;\n\n\tif (!inst->num_input_bufs || !inst->num_output_bufs)\n\t\treturn -EINVAL;\n\n\tret = venus_helper_get_bufreq(inst, HFI_BUFFER_OUTPUT, &bufreq);\n\tif (ret)\n\t\treturn ret;\n\n\tif (inst->num_output_bufs < bufreq.count_actual ||\n\t    inst->num_output_bufs < hfi_bufreq_get_count_min(&bufreq, ver))\n\t\treturn -EINVAL;\n\n\tret = venus_helper_get_bufreq(inst, HFI_BUFFER_INPUT, &bufreq);\n\tif (ret)\n\t\treturn ret;\n\n\tif (inst->num_input_bufs < hfi_bufreq_get_count_min(&bufreq, ver))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int vdec_start_capture(struct venus_inst *inst)\n{\n\tint ret;\n\n\tif (!inst->streamon_out)\n\t\treturn 0;\n\n\tif (inst->codec_state == VENUS_DEC_STATE_DECODING) {\n\t\tif (inst->reconfig)\n\t\t\tgoto reconfigure;\n\n\t\tvenus_helper_queue_dpb_bufs(inst);\n\t\tvenus_helper_process_initial_cap_bufs(inst);\n\t\tinst->streamon_cap = 1;\n\t\treturn 0;\n\t}\n\n\tif (inst->codec_state != VENUS_DEC_STATE_STOPPED)\n\t\treturn 0;\n\nreconfigure:\n\tret = vdec_output_conf(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = venus_helper_set_num_bufs(inst, inst->num_input_bufs,\n\t\t\t\t\tVB2_MAX_FRAME, VB2_MAX_FRAME);\n\tif (ret)\n\t\treturn ret;\n\n\tret = venus_helper_intbufs_realloc(inst);\n\tif (ret)\n\t\tgoto err;\n\n\tvenus_pm_load_scale(inst);\n\n\tinst->next_buf_last = false;\n\n\tret = venus_helper_alloc_dpb_bufs(inst);\n\tif (ret)\n\t\tgoto err;\n\n\tret = hfi_session_continue(inst);\n\tif (ret)\n\t\tgoto free_dpb_bufs;\n\n\tret = venus_helper_queue_dpb_bufs(inst);\n\tif (ret)\n\t\tgoto free_dpb_bufs;\n\n\tret = venus_helper_process_initial_cap_bufs(inst);\n\tif (ret)\n\t\tgoto free_dpb_bufs;\n\n\tinst->codec_state = VENUS_DEC_STATE_DECODING;\n\n\tif (inst->drain_active)\n\t\tinst->codec_state = VENUS_DEC_STATE_DRAIN;\n\n\tinst->streamon_cap = 1;\n\tinst->sequence_cap = 0;\n\tinst->reconfig = false;\n\tinst->drain_active = false;\n\n\treturn 0;\n\nfree_dpb_bufs:\n\tvenus_helper_free_dpb_bufs(inst);\nerr:\n\treturn ret;\n}\n\nstatic int vdec_start_output(struct venus_inst *inst)\n{\n\tint ret;\n\n\tif (inst->codec_state == VENUS_DEC_STATE_SEEK) {\n\t\tret = venus_helper_process_initial_out_bufs(inst);\n\t\tif (inst->next_buf_last)\n\t\t\tinst->codec_state = VENUS_DEC_STATE_DRC;\n\t\telse\n\t\t\tinst->codec_state = VENUS_DEC_STATE_DECODING;\n\t\tgoto done;\n\t}\n\n\tif (inst->codec_state == VENUS_DEC_STATE_INIT ||\n\t    inst->codec_state == VENUS_DEC_STATE_CAPTURE_SETUP) {\n\t\tret = venus_helper_process_initial_out_bufs(inst);\n\t\tgoto done;\n\t}\n\n\tif (inst->codec_state != VENUS_DEC_STATE_DEINIT)\n\t\treturn -EINVAL;\n\n\tvenus_helper_init_instance(inst);\n\tinst->sequence_out = 0;\n\tinst->reconfig = false;\n\tinst->next_buf_last = false;\n\n\tret = vdec_set_properties(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vdec_set_work_route(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vdec_output_conf(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vdec_verify_conf(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = venus_helper_set_num_bufs(inst, inst->num_input_bufs,\n\t\t\t\t\tVB2_MAX_FRAME, VB2_MAX_FRAME);\n\tif (ret)\n\t\treturn ret;\n\n\tret = venus_helper_vb2_start_streaming(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = venus_helper_process_initial_out_bufs(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tinst->codec_state = VENUS_DEC_STATE_INIT;\n\ndone:\n\tinst->streamon_out = 1;\n\treturn ret;\n}\n\nstatic int vdec_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(q);\n\tint ret;\n\n\tmutex_lock(&inst->lock);\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tret = vdec_start_capture(inst);\n\t} else {\n\t\tret = vdec_pm_get(inst);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tret = venus_pm_acquire_core(inst);\n\t\tif (ret)\n\t\t\tgoto put_power;\n\n\t\tret = vdec_pm_put(inst, true);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tret = vdec_start_output(inst);\n\t}\n\n\tif (ret)\n\t\tgoto error;\n\n\tmutex_unlock(&inst->lock);\n\treturn 0;\n\nput_power:\n\tvdec_pm_put(inst, false);\nerror:\n\tvenus_helper_buffers_done(inst, q->type, VB2_BUF_STATE_QUEUED);\n\tmutex_unlock(&inst->lock);\n\treturn ret;\n}\n\nstatic void vdec_cancel_dst_buffers(struct venus_inst *inst)\n{\n\tstruct vb2_v4l2_buffer *buf;\n\n\twhile ((buf = v4l2_m2m_dst_buf_remove(inst->m2m_ctx)))\n\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);\n}\n\nstatic int vdec_stop_capture(struct venus_inst *inst)\n{\n\tint ret = 0;\n\n\tswitch (inst->codec_state) {\n\tcase VENUS_DEC_STATE_DECODING:\n\t\tret = hfi_session_flush(inst, HFI_FLUSH_ALL, true);\n\t\tfallthrough;\n\tcase VENUS_DEC_STATE_DRAIN:\n\t\tinst->codec_state = VENUS_DEC_STATE_STOPPED;\n\t\tinst->drain_active = false;\n\t\tfallthrough;\n\tcase VENUS_DEC_STATE_SEEK:\n\t\tvdec_cancel_dst_buffers(inst);\n\t\tbreak;\n\tcase VENUS_DEC_STATE_DRC:\n\t\tret = hfi_session_flush(inst, HFI_FLUSH_OUTPUT, true);\n\t\tinst->codec_state = VENUS_DEC_STATE_CAPTURE_SETUP;\n\t\tvenus_helper_free_dpb_bufs(inst);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int vdec_stop_output(struct venus_inst *inst)\n{\n\tint ret = 0;\n\n\tswitch (inst->codec_state) {\n\tcase VENUS_DEC_STATE_DECODING:\n\tcase VENUS_DEC_STATE_DRAIN:\n\tcase VENUS_DEC_STATE_STOPPED:\n\tcase VENUS_DEC_STATE_DRC:\n\t\tret = hfi_session_flush(inst, HFI_FLUSH_ALL, true);\n\t\tinst->codec_state = VENUS_DEC_STATE_SEEK;\n\t\tbreak;\n\tcase VENUS_DEC_STATE_INIT:\n\tcase VENUS_DEC_STATE_CAPTURE_SETUP:\n\t\tret = hfi_session_flush(inst, HFI_FLUSH_INPUT, true);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void vdec_stop_streaming(struct vb2_queue *q)\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(q);\n\tint ret = -EINVAL;\n\n\tvdec_pm_get_put(inst);\n\n\tmutex_lock(&inst->lock);\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tret = vdec_stop_capture(inst);\n\telse\n\t\tret = vdec_stop_output(inst);\n\n\tvenus_helper_buffers_done(inst, q->type, VB2_BUF_STATE_ERROR);\n\n\tinst->session_error = 0;\n\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tinst->streamon_out = 0;\n\telse\n\t\tinst->streamon_cap = 0;\n\nunlock:\n\tmutex_unlock(&inst->lock);\n}\n\nstatic void vdec_session_release(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tint ret, abort = 0;\n\n\tvdec_pm_get(inst);\n\n\tmutex_lock(&inst->lock);\n\tinst->codec_state = VENUS_DEC_STATE_DEINIT;\n\n\tret = hfi_session_stop(inst);\n\tabort = (ret && ret != -EINVAL) ? 1 : 0;\n\tret = hfi_session_unload_res(inst);\n\tabort = (ret && ret != -EINVAL) ? 1 : 0;\n\tret = venus_helper_unregister_bufs(inst);\n\tabort = (ret && ret != -EINVAL) ? 1 : 0;\n\tret = venus_helper_intbufs_free(inst);\n\tabort = (ret && ret != -EINVAL) ? 1 : 0;\n\tret = hfi_session_deinit(inst);\n\tabort = (ret && ret != -EINVAL) ? 1 : 0;\n\n\tif (inst->session_error || test_bit(0, &core->sys_error))\n\t\tabort = 1;\n\n\tif (abort)\n\t\thfi_session_abort(inst);\n\n\tvenus_helper_free_dpb_bufs(inst);\n\tvenus_pm_load_scale(inst);\n\tINIT_LIST_HEAD(&inst->registeredbufs);\n\tmutex_unlock(&inst->lock);\n\n\tvenus_pm_release_core(inst);\n\tvdec_pm_put(inst, false);\n}\n\nstatic int vdec_buf_init(struct vb2_buffer *vb)\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\n\tinst->buf_count++;\n\n\treturn venus_helper_vb2_buf_init(vb);\n}\n\nstatic void vdec_buf_cleanup(struct vb2_buffer *vb)\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct venus_buffer *buf = to_venus_buffer(vbuf);\n\n\tmutex_lock(&inst->lock);\n\tif (vb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tif (!list_empty(&inst->registeredbufs))\n\t\t\tlist_del_init(&buf->reg_list);\n\tmutex_unlock(&inst->lock);\n\n\tinst->buf_count--;\n\tif (!inst->buf_count)\n\t\tvdec_session_release(inst);\n}\n\nstatic void vdec_vb2_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstatic const struct v4l2_event eos = { .type = V4L2_EVENT_EOS };\n\n\tvdec_pm_get_put(inst);\n\n\tmutex_lock(&inst->lock);\n\n\tif (inst->next_buf_last && V4L2_TYPE_IS_CAPTURE(vb->vb2_queue->type) &&\n\t    inst->codec_state == VENUS_DEC_STATE_DRC) {\n\t\tvbuf->flags |= V4L2_BUF_FLAG_LAST;\n\t\tvbuf->sequence = inst->sequence_cap++;\n\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tvb2_set_plane_payload(vb, 0, 0);\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);\n\t\tv4l2_event_queue_fh(&inst->fh, &eos);\n\t\tinst->next_buf_last = false;\n\t\tmutex_unlock(&inst->lock);\n\t\treturn;\n\t}\n\n\tvenus_helper_vb2_buf_queue(vb);\n\tmutex_unlock(&inst->lock);\n}\n\nstatic const struct vb2_ops vdec_vb2_ops = {\n\t.queue_setup = vdec_queue_setup,\n\t.buf_init = vdec_buf_init,\n\t.buf_cleanup = vdec_buf_cleanup,\n\t.buf_prepare = venus_helper_vb2_buf_prepare,\n\t.start_streaming = vdec_start_streaming,\n\t.stop_streaming = vdec_stop_streaming,\n\t.buf_queue = vdec_vb2_buf_queue,\n};\n\nstatic void vdec_buf_done(struct venus_inst *inst, unsigned int buf_type,\n\t\t\t  u32 tag, u32 bytesused, u32 data_offset, u32 flags,\n\t\t\t  u32 hfi_flags, u64 timestamp_us)\n{\n\tenum vb2_buffer_state state = VB2_BUF_STATE_DONE;\n\tstruct vb2_v4l2_buffer *vbuf;\n\tstruct vb2_buffer *vb;\n\tunsigned int type;\n\n\tvdec_pm_touch(inst);\n\n\tif (buf_type == HFI_BUFFER_INPUT)\n\t\ttype = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\telse\n\t\ttype = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\n\tvbuf = venus_helper_find_buf(inst, type, tag);\n\tif (!vbuf) {\n\t\tvenus_helper_change_dpb_owner(inst, vbuf, type, buf_type, tag);\n\t\treturn;\n\t}\n\n\tvbuf->flags = flags;\n\tvbuf->field = V4L2_FIELD_NONE;\n\tvb = &vbuf->vb2_buf;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tvb2_set_plane_payload(vb, 0, bytesused);\n\t\tvb->planes[0].data_offset = data_offset;\n\t\tvb->timestamp = timestamp_us * NSEC_PER_USEC;\n\t\tvbuf->sequence = inst->sequence_cap++;\n\n\t\tif (vbuf->flags & V4L2_BUF_FLAG_LAST) {\n\t\t\tconst struct v4l2_event ev = { .type = V4L2_EVENT_EOS };\n\n\t\t\tv4l2_event_queue_fh(&inst->fh, &ev);\n\n\t\t\tif (inst->codec_state == VENUS_DEC_STATE_DRAIN) {\n\t\t\t\tinst->drain_active = false;\n\t\t\t\tinst->codec_state = VENUS_DEC_STATE_STOPPED;\n\t\t\t}\n\t\t}\n\n\t\tif (!bytesused)\n\t\t\tstate = VB2_BUF_STATE_ERROR;\n\t} else {\n\t\tvbuf->sequence = inst->sequence_out++;\n\t}\n\n\tvenus_helper_get_ts_metadata(inst, timestamp_us, vbuf);\n\n\tif (hfi_flags & HFI_BUFFERFLAG_READONLY)\n\t\tvenus_helper_acquire_buf_ref(vbuf);\n\n\tif (hfi_flags & HFI_BUFFERFLAG_DATACORRUPT)\n\t\tstate = VB2_BUF_STATE_ERROR;\n\n\tif (hfi_flags & HFI_BUFFERFLAG_DROP_FRAME) {\n\t\tstate = VB2_BUF_STATE_ERROR;\n\t\tvb2_set_plane_payload(vb, 0, 0);\n\t\tvb->timestamp = 0;\n\t}\n\n\tv4l2_m2m_buf_done(vbuf, state);\n}\n\nstatic void vdec_event_change(struct venus_inst *inst,\n\t\t\t      struct hfi_event_data *ev_data, bool sufficient)\n{\n\tstatic const struct v4l2_event ev = {\n\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION };\n\tstruct device *dev = inst->core->dev_dec;\n\tstruct v4l2_format format = {};\n\n\tmutex_lock(&inst->lock);\n\n\tformat.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tformat.fmt.pix_mp.pixelformat = inst->fmt_cap->pixfmt;\n\tformat.fmt.pix_mp.width = ev_data->width;\n\tformat.fmt.pix_mp.height = ev_data->height;\n\n\tvdec_try_fmt_common(inst, &format);\n\n\tinst->width = format.fmt.pix_mp.width;\n\tinst->height = format.fmt.pix_mp.height;\n\t \n\tif (ev_data->input_crop.width > 0 && ev_data->input_crop.height > 0) {\n\t\tinst->crop.left = ev_data->input_crop.left;\n\t\tinst->crop.top = ev_data->input_crop.top;\n\t\tinst->crop.width = ev_data->input_crop.width;\n\t\tinst->crop.height = ev_data->input_crop.height;\n\t} else {\n\t\tinst->crop.left = 0;\n\t\tinst->crop.top = 0;\n\t\tinst->crop.width = ev_data->width;\n\t\tinst->crop.height = ev_data->height;\n\t}\n\n\tinst->fw_min_cnt = ev_data->buf_count;\n\t \n\tif (inst->hfi_codec == HFI_VIDEO_CODEC_VP9)\n\t\tinst->fw_min_cnt = 11;\n\n\tinst->out_width = ev_data->width;\n\tinst->out_height = ev_data->height;\n\n\tif (inst->bit_depth != ev_data->bit_depth) {\n\t\tinst->bit_depth = ev_data->bit_depth;\n\t\tif (inst->bit_depth == VIDC_BITDEPTH_10)\n\t\t\tinst->fmt_cap = &vdec_formats[VENUS_FMT_P010];\n\t\telse\n\t\t\tinst->fmt_cap = &vdec_formats[VENUS_FMT_NV12];\n\t}\n\n\tif (inst->pic_struct != ev_data->pic_struct)\n\t\tinst->pic_struct = ev_data->pic_struct;\n\n\tdev_dbg(dev, VDBGM \"event %s sufficient resources (%ux%u)\\n\",\n\t\tsufficient ? \"\" : \"not\", ev_data->width, ev_data->height);\n\n\tswitch (inst->codec_state) {\n\tcase VENUS_DEC_STATE_INIT:\n\t\tinst->codec_state = VENUS_DEC_STATE_CAPTURE_SETUP;\n\t\tbreak;\n\tcase VENUS_DEC_STATE_DECODING:\n\tcase VENUS_DEC_STATE_DRAIN:\n\t\tinst->codec_state = VENUS_DEC_STATE_DRC;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\n\tif (inst->codec_state == VENUS_DEC_STATE_DRC) {\n\t\tint ret;\n\n\t\tinst->next_buf_last = true;\n\n\t\tret = hfi_session_flush(inst, HFI_FLUSH_OUTPUT, false);\n\t\tif (ret)\n\t\t\tdev_dbg(dev, VDBGH \"flush output error %d\\n\", ret);\n\t}\n\n\tinst->next_buf_last = true;\n\tinst->reconfig = true;\n\tv4l2_event_queue_fh(&inst->fh, &ev);\n\twake_up(&inst->reconf_wait);\n\n\tmutex_unlock(&inst->lock);\n}\n\nstatic void vdec_event_notify(struct venus_inst *inst, u32 event,\n\t\t\t      struct hfi_event_data *data)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct device *dev = core->dev_dec;\n\n\tvdec_pm_touch(inst);\n\n\tswitch (event) {\n\tcase EVT_SESSION_ERROR:\n\t\tinst->session_error = true;\n\t\tvenus_helper_vb2_queue_error(inst);\n\t\tdev_err(dev, \"dec: event session error %x\\n\", inst->error);\n\t\tbreak;\n\tcase EVT_SYS_EVENT_CHANGE:\n\t\tswitch (data->event_type) {\n\t\tcase HFI_EVENT_DATA_SEQUENCE_CHANGED_SUFFICIENT_BUF_RESOURCES:\n\t\t\tvdec_event_change(inst, data, true);\n\t\t\tbreak;\n\t\tcase HFI_EVENT_DATA_SEQUENCE_CHANGED_INSUFFICIENT_BUF_RESOURCES:\n\t\t\tvdec_event_change(inst, data, false);\n\t\t\tbreak;\n\t\tcase HFI_EVENT_RELEASE_BUFFER_REFERENCE:\n\t\t\tvenus_helper_release_buf_ref(inst, data->tag);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void vdec_flush_done(struct venus_inst *inst)\n{\n\tdev_dbg(inst->core->dev_dec, VDBGH \"flush done\\n\");\n}\n\nstatic const struct hfi_inst_ops vdec_hfi_ops = {\n\t.buf_done = vdec_buf_done,\n\t.event_notify = vdec_event_notify,\n\t.flush_done = vdec_flush_done,\n};\n\nstatic void vdec_inst_init(struct venus_inst *inst)\n{\n\tinst->hfi_codec = HFI_VIDEO_CODEC_H264;\n\tinst->fmt_out = &vdec_formats[VENUS_FMT_H264];\n\tinst->fmt_cap = &vdec_formats[VENUS_FMT_NV12];\n\tinst->width = frame_width_min(inst);\n\tinst->height = ALIGN(frame_height_min(inst), 32);\n\tinst->crop.left = 0;\n\tinst->crop.top = 0;\n\tinst->crop.width = inst->width;\n\tinst->crop.height = inst->height;\n\tinst->fw_min_cnt = 8;\n\tinst->out_width = frame_width_min(inst);\n\tinst->out_height = frame_height_min(inst);\n\tinst->fps = 30;\n\tinst->timeperframe.numerator = 1;\n\tinst->timeperframe.denominator = 30;\n\tinst->opb_buftype = HFI_BUFFER_OUTPUT;\n}\n\nstatic void vdec_m2m_device_run(void *priv)\n{\n}\n\nstatic const struct v4l2_m2m_ops vdec_m2m_ops = {\n\t.device_run = vdec_m2m_device_run,\n\t.job_abort = venus_helper_m2m_job_abort,\n};\n\nstatic int m2m_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t  struct vb2_queue *dst_vq)\n{\n\tstruct venus_inst *inst = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->ops = &vdec_vb2_ops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->drv_priv = inst;\n\tsrc_vq->buf_struct_size = sizeof(struct venus_buffer);\n\tsrc_vq->allow_zero_bytesused = 1;\n\tsrc_vq->min_buffers_needed = 0;\n\tsrc_vq->dev = inst->core->dev;\n\tsrc_vq->lock = &inst->ctx_q_lock;\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->ops = &vdec_vb2_ops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->drv_priv = inst;\n\tdst_vq->buf_struct_size = sizeof(struct venus_buffer);\n\tdst_vq->allow_zero_bytesused = 1;\n\tdst_vq->min_buffers_needed = 0;\n\tdst_vq->dev = inst->core->dev;\n\tdst_vq->lock = &inst->ctx_q_lock;\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int vdec_open(struct file *file)\n{\n\tstruct venus_core *core = video_drvdata(file);\n\tstruct venus_inst *inst;\n\tint ret;\n\n\tinst = kzalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&inst->dpbbufs);\n\tINIT_LIST_HEAD(&inst->registeredbufs);\n\tINIT_LIST_HEAD(&inst->internalbufs);\n\tINIT_LIST_HEAD(&inst->list);\n\tmutex_init(&inst->lock);\n\tmutex_init(&inst->ctx_q_lock);\n\n\tinst->core = core;\n\tinst->session_type = VIDC_SESSION_TYPE_DEC;\n\tinst->num_output_bufs = 1;\n\tinst->codec_state = VENUS_DEC_STATE_DEINIT;\n\tinst->buf_count = 0;\n\tinst->clk_data.core_id = VIDC_CORE_ID_DEFAULT;\n\tinst->core_acquired = false;\n\tinst->bit_depth = VIDC_BITDEPTH_8;\n\tinst->pic_struct = HFI_INTERLACE_FRAME_PROGRESSIVE;\n\tinit_waitqueue_head(&inst->reconf_wait);\n\tinst->nonblock = file->f_flags & O_NONBLOCK;\n\n\tvenus_helper_init_instance(inst);\n\n\tret = vdec_ctrl_init(inst);\n\tif (ret)\n\t\tgoto err_free;\n\n\tret = hfi_session_create(inst, &vdec_hfi_ops);\n\tif (ret)\n\t\tgoto err_ctrl_deinit;\n\n\tvdec_inst_init(inst);\n\n\tida_init(&inst->dpb_ids);\n\n\t \n\tinst->m2m_dev = v4l2_m2m_init(&vdec_m2m_ops);\n\tif (IS_ERR(inst->m2m_dev)) {\n\t\tret = PTR_ERR(inst->m2m_dev);\n\t\tgoto err_session_destroy;\n\t}\n\n\tinst->m2m_ctx = v4l2_m2m_ctx_init(inst->m2m_dev, inst, m2m_queue_init);\n\tif (IS_ERR(inst->m2m_ctx)) {\n\t\tret = PTR_ERR(inst->m2m_ctx);\n\t\tgoto err_m2m_release;\n\t}\n\n\tv4l2_fh_init(&inst->fh, core->vdev_dec);\n\n\tinst->fh.ctrl_handler = &inst->ctrl_handler;\n\tv4l2_fh_add(&inst->fh);\n\tinst->fh.m2m_ctx = inst->m2m_ctx;\n\tfile->private_data = &inst->fh;\n\n\treturn 0;\n\nerr_m2m_release:\n\tv4l2_m2m_release(inst->m2m_dev);\nerr_session_destroy:\n\thfi_session_destroy(inst);\nerr_ctrl_deinit:\n\tvdec_ctrl_deinit(inst);\nerr_free:\n\tkfree(inst);\n\treturn ret;\n}\n\nstatic int vdec_close(struct file *file)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\n\tvdec_pm_get(inst);\n\n\tv4l2_m2m_ctx_release(inst->m2m_ctx);\n\tv4l2_m2m_release(inst->m2m_dev);\n\tvdec_ctrl_deinit(inst);\n\tida_destroy(&inst->dpb_ids);\n\thfi_session_destroy(inst);\n\tmutex_destroy(&inst->lock);\n\tmutex_destroy(&inst->ctx_q_lock);\n\tv4l2_fh_del(&inst->fh);\n\tv4l2_fh_exit(&inst->fh);\n\n\tvdec_pm_put(inst, false);\n\n\tkfree(inst);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations vdec_fops = {\n\t.owner = THIS_MODULE,\n\t.open = vdec_open,\n\t.release = vdec_close,\n\t.unlocked_ioctl = video_ioctl2,\n\t.poll = v4l2_m2m_fop_poll,\n\t.mmap = v4l2_m2m_fop_mmap,\n};\n\nstatic int vdec_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct video_device *vdev;\n\tstruct venus_core *core;\n\tint ret;\n\n\tif (!dev->parent)\n\t\treturn -EPROBE_DEFER;\n\n\tcore = dev_get_drvdata(dev->parent);\n\tif (!core)\n\t\treturn -EPROBE_DEFER;\n\n\tplatform_set_drvdata(pdev, core);\n\n\tif (core->pm_ops->vdec_get) {\n\t\tret = core->pm_ops->vdec_get(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tvdev = video_device_alloc();\n\tif (!vdev)\n\t\treturn -ENOMEM;\n\n\tstrscpy(vdev->name, \"qcom-venus-decoder\", sizeof(vdev->name));\n\tvdev->release = video_device_release;\n\tvdev->fops = &vdec_fops;\n\tvdev->ioctl_ops = &vdec_ioctl_ops;\n\tvdev->vfl_dir = VFL_DIR_M2M;\n\tvdev->v4l2_dev = &core->v4l2_dev;\n\tvdev->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret)\n\t\tgoto err_vdev_release;\n\n\tcore->vdev_dec = vdev;\n\tcore->dev_dec = dev;\n\n\tvideo_set_drvdata(vdev, core);\n\tpm_runtime_set_autosuspend_delay(dev, 2000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nerr_vdev_release:\n\tvideo_device_release(vdev);\n\treturn ret;\n}\n\nstatic void vdec_remove(struct platform_device *pdev)\n{\n\tstruct venus_core *core = dev_get_drvdata(pdev->dev.parent);\n\n\tvideo_unregister_device(core->vdev_dec);\n\tpm_runtime_disable(core->dev_dec);\n\n\tif (core->pm_ops->vdec_put)\n\t\tcore->pm_ops->vdec_put(core->dev_dec);\n}\n\nstatic __maybe_unused int vdec_runtime_suspend(struct device *dev)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\tconst struct venus_pm_ops *pm_ops = core->pm_ops;\n\tint ret = 0;\n\n\tif (pm_ops->vdec_power)\n\t\tret = pm_ops->vdec_power(dev, POWER_OFF);\n\n\treturn ret;\n}\n\nstatic __maybe_unused int vdec_runtime_resume(struct device *dev)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\tconst struct venus_pm_ops *pm_ops = core->pm_ops;\n\tint ret = 0;\n\n\tif (pm_ops->vdec_power)\n\t\tret = pm_ops->vdec_power(dev, POWER_ON);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops vdec_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(vdec_runtime_suspend, vdec_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id vdec_dt_match[] = {\n\t{ .compatible = \"venus-decoder\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, vdec_dt_match);\n\nstatic struct platform_driver qcom_venus_dec_driver = {\n\t.probe = vdec_probe,\n\t.remove_new = vdec_remove,\n\t.driver = {\n\t\t.name = \"qcom-venus-decoder\",\n\t\t.of_match_table = vdec_dt_match,\n\t\t.pm = &vdec_pm_ops,\n\t},\n};\nmodule_platform_driver(qcom_venus_dec_driver);\n\nMODULE_ALIAS(\"platform:qcom-venus-decoder\");\nMODULE_DESCRIPTION(\"Qualcomm Venus video decoder driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}