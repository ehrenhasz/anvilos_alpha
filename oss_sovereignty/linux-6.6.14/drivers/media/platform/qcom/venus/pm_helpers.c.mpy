{
  "module_name": "pm_helpers.c",
  "hash_id": "a6a8b2c0458ee5341cd5e6459f2143de4708fab7cd968fa7779ba98963f0b283",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/venus/pm_helpers.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/interconnect.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_opp.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/types.h>\n#include <media/v4l2-mem2mem.h>\n\n#include \"core.h\"\n#include \"hfi_parser.h\"\n#include \"hfi_venus_io.h\"\n#include \"pm_helpers.h\"\n#include \"hfi_platform.h\"\n\nstatic bool legacy_binding;\n\nstatic int core_clks_get(struct venus_core *core)\n{\n\tconst struct venus_resources *res = core->res;\n\tstruct device *dev = core->dev;\n\tunsigned int i;\n\n\tfor (i = 0; i < res->clks_num; i++) {\n\t\tcore->clks[i] = devm_clk_get(dev, res->clks[i]);\n\t\tif (IS_ERR(core->clks[i]))\n\t\t\treturn PTR_ERR(core->clks[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int core_clks_enable(struct venus_core *core)\n{\n\tconst struct venus_resources *res = core->res;\n\tconst struct freq_tbl *freq_tbl = core->res->freq_tbl;\n\tunsigned int freq_tbl_size = core->res->freq_tbl_size;\n\tunsigned long freq;\n\tunsigned int i;\n\tint ret;\n\n\tif (!freq_tbl)\n\t\treturn -EINVAL;\n\n\tfreq = freq_tbl[freq_tbl_size - 1].freq;\n\n\tfor (i = 0; i < res->clks_num; i++) {\n\t\tif (IS_V6(core)) {\n\t\t\tret = clk_set_rate(core->clks[i], freq);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tret = clk_prepare_enable(core->clks[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\twhile (i--)\n\t\tclk_disable_unprepare(core->clks[i]);\n\n\treturn ret;\n}\n\nstatic void core_clks_disable(struct venus_core *core)\n{\n\tconst struct venus_resources *res = core->res;\n\tunsigned int i = res->clks_num;\n\n\twhile (i--)\n\t\tclk_disable_unprepare(core->clks[i]);\n}\n\nstatic int core_clks_set_rate(struct venus_core *core, unsigned long freq)\n{\n\tint ret;\n\n\tret = dev_pm_opp_set_rate(core->dev, freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_set_rate(core->vcodec0_clks[0], freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_set_rate(core->vcodec1_clks[0], freq);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int vcodec_clks_get(struct venus_core *core, struct device *dev,\n\t\t\t   struct clk **clks, const char * const *id)\n{\n\tconst struct venus_resources *res = core->res;\n\tunsigned int i;\n\n\tfor (i = 0; i < res->vcodec_clks_num; i++) {\n\t\tif (!id[i])\n\t\t\tcontinue;\n\t\tclks[i] = devm_clk_get(dev, id[i]);\n\t\tif (IS_ERR(clks[i]))\n\t\t\treturn PTR_ERR(clks[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int vcodec_clks_enable(struct venus_core *core, struct clk **clks)\n{\n\tconst struct venus_resources *res = core->res;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < res->vcodec_clks_num; i++) {\n\t\tret = clk_prepare_enable(clks[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\twhile (i--)\n\t\tclk_disable_unprepare(clks[i]);\n\n\treturn ret;\n}\n\nstatic void vcodec_clks_disable(struct venus_core *core, struct clk **clks)\n{\n\tconst struct venus_resources *res = core->res;\n\tunsigned int i = res->vcodec_clks_num;\n\n\twhile (i--)\n\t\tclk_disable_unprepare(clks[i]);\n}\n\nstatic u32 load_per_instance(struct venus_inst *inst)\n{\n\tu32 mbs;\n\n\tif (!inst || !(inst->state >= INST_INIT && inst->state < INST_STOP))\n\t\treturn 0;\n\n\tmbs = (ALIGN(inst->width, 16) / 16) * (ALIGN(inst->height, 16) / 16);\n\n\treturn mbs * inst->fps;\n}\n\nstatic u32 load_per_type(struct venus_core *core, u32 session_type)\n{\n\tstruct venus_inst *inst = NULL;\n\tu32 mbs_per_sec = 0;\n\n\tlist_for_each_entry(inst, &core->instances, list) {\n\t\tif (inst->session_type != session_type)\n\t\t\tcontinue;\n\n\t\tmbs_per_sec += load_per_instance(inst);\n\t}\n\n\treturn mbs_per_sec;\n}\n\nstatic void mbs_to_bw(struct venus_inst *inst, u32 mbs, u32 *avg, u32 *peak)\n{\n\tconst struct venus_resources *res = inst->core->res;\n\tconst struct bw_tbl *bw_tbl;\n\tunsigned int num_rows, i;\n\n\t*avg = 0;\n\t*peak = 0;\n\n\tif (mbs == 0)\n\t\treturn;\n\n\tif (inst->session_type == VIDC_SESSION_TYPE_ENC) {\n\t\tnum_rows = res->bw_tbl_enc_size;\n\t\tbw_tbl = res->bw_tbl_enc;\n\t} else if (inst->session_type == VIDC_SESSION_TYPE_DEC) {\n\t\tnum_rows = res->bw_tbl_dec_size;\n\t\tbw_tbl = res->bw_tbl_dec;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (!bw_tbl || num_rows == 0)\n\t\treturn;\n\n\tfor (i = 0; i < num_rows; i++) {\n\t\tif (i != 0 && mbs > bw_tbl[i].mbs_per_sec)\n\t\t\tbreak;\n\n\t\tif (inst->dpb_fmt & HFI_COLOR_FORMAT_10_BIT_BASE) {\n\t\t\t*avg = bw_tbl[i].avg_10bit;\n\t\t\t*peak = bw_tbl[i].peak_10bit;\n\t\t} else {\n\t\t\t*avg = bw_tbl[i].avg;\n\t\t\t*peak = bw_tbl[i].peak;\n\t\t}\n\t}\n}\n\nstatic int load_scale_bw(struct venus_core *core)\n{\n\tstruct venus_inst *inst = NULL;\n\tu32 mbs_per_sec, avg, peak, total_avg = 0, total_peak = 0;\n\n\tlist_for_each_entry(inst, &core->instances, list) {\n\t\tmbs_per_sec = load_per_instance(inst);\n\t\tmbs_to_bw(inst, mbs_per_sec, &avg, &peak);\n\t\ttotal_avg += avg;\n\t\ttotal_peak += peak;\n\t}\n\n\t \n\n\tif (!total_avg && !total_peak)\n\t\ttotal_avg = kbps_to_icc(1000);\n\n\tdev_dbg(core->dev, VDBGL \"total: avg_bw: %u, peak_bw: %u\\n\",\n\t\ttotal_avg, total_peak);\n\n\treturn icc_set_bw(core->video_path, total_avg, total_peak);\n}\n\nstatic int load_scale_v1(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tconst struct freq_tbl *table = core->res->freq_tbl;\n\tunsigned int num_rows = core->res->freq_tbl_size;\n\tunsigned long freq = table[0].freq;\n\tstruct device *dev = core->dev;\n\tu32 mbs_per_sec;\n\tunsigned int i;\n\tint ret = 0;\n\n\tmutex_lock(&core->lock);\n\tmbs_per_sec = load_per_type(core, VIDC_SESSION_TYPE_ENC) +\n\t\t      load_per_type(core, VIDC_SESSION_TYPE_DEC);\n\n\tif (mbs_per_sec > core->res->max_load)\n\t\tdev_warn(dev, \"HW is overloaded, needed: %d max: %d\\n\",\n\t\t\t mbs_per_sec, core->res->max_load);\n\n\tif (!mbs_per_sec && num_rows > 1) {\n\t\tfreq = table[num_rows - 1].freq;\n\t\tgoto set_freq;\n\t}\n\n\tfor (i = 0; i < num_rows; i++) {\n\t\tif (mbs_per_sec > table[i].load)\n\t\t\tbreak;\n\t\tfreq = table[i].freq;\n\t}\n\nset_freq:\n\n\tret = core_clks_set_rate(core, freq);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set clock rate %lu (%d)\\n\",\n\t\t\tfreq, ret);\n\t\tgoto exit;\n\t}\n\n\tret = load_scale_bw(core);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set bandwidth (%d)\\n\",\n\t\t\tret);\n\t\tgoto exit;\n\t}\n\nexit:\n\tmutex_unlock(&core->lock);\n\treturn ret;\n}\n\nstatic int core_get_v1(struct venus_core *core)\n{\n\tint ret;\n\n\tret = core_clks_get(core);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_pm_opp_set_clkname(core->dev, \"core\");\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void core_put_v1(struct venus_core *core)\n{\n}\n\nstatic int core_power_v1(struct venus_core *core, int on)\n{\n\tint ret = 0;\n\n\tif (on == POWER_ON)\n\t\tret = core_clks_enable(core);\n\telse\n\t\tcore_clks_disable(core);\n\n\treturn ret;\n}\n\nstatic const struct venus_pm_ops pm_ops_v1 = {\n\t.core_get = core_get_v1,\n\t.core_put = core_put_v1,\n\t.core_power = core_power_v1,\n\t.load_scale = load_scale_v1,\n};\n\nstatic void\nvcodec_control_v3(struct venus_core *core, u32 session_type, bool enable)\n{\n\tvoid __iomem *ctrl;\n\n\tif (session_type == VIDC_SESSION_TYPE_DEC)\n\t\tctrl = core->wrapper_base + WRAPPER_VDEC_VCODEC_POWER_CONTROL;\n\telse\n\t\tctrl = core->wrapper_base + WRAPPER_VENC_VCODEC_POWER_CONTROL;\n\n\tif (enable)\n\t\twritel(0, ctrl);\n\telse\n\t\twritel(1, ctrl);\n}\n\nstatic int vdec_get_v3(struct device *dev)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\n\treturn vcodec_clks_get(core, dev, core->vcodec0_clks,\n\t\t\t       core->res->vcodec0_clks);\n}\n\nstatic int vdec_power_v3(struct device *dev, int on)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tvcodec_control_v3(core, VIDC_SESSION_TYPE_DEC, true);\n\n\tif (on == POWER_ON)\n\t\tret = vcodec_clks_enable(core, core->vcodec0_clks);\n\telse\n\t\tvcodec_clks_disable(core, core->vcodec0_clks);\n\n\tvcodec_control_v3(core, VIDC_SESSION_TYPE_DEC, false);\n\n\treturn ret;\n}\n\nstatic int venc_get_v3(struct device *dev)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\n\treturn vcodec_clks_get(core, dev, core->vcodec1_clks,\n\t\t\t       core->res->vcodec1_clks);\n}\n\nstatic int venc_power_v3(struct device *dev, int on)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tvcodec_control_v3(core, VIDC_SESSION_TYPE_ENC, true);\n\n\tif (on == POWER_ON)\n\t\tret = vcodec_clks_enable(core, core->vcodec1_clks);\n\telse\n\t\tvcodec_clks_disable(core, core->vcodec1_clks);\n\n\tvcodec_control_v3(core, VIDC_SESSION_TYPE_ENC, false);\n\n\treturn ret;\n}\n\nstatic const struct venus_pm_ops pm_ops_v3 = {\n\t.core_get = core_get_v1,\n\t.core_put = core_put_v1,\n\t.core_power = core_power_v1,\n\t.vdec_get = vdec_get_v3,\n\t.vdec_power = vdec_power_v3,\n\t.venc_get = venc_get_v3,\n\t.venc_power = venc_power_v3,\n\t.load_scale = load_scale_v1,\n};\n\nstatic int vcodec_control_v4(struct venus_core *core, u32 coreid, bool enable)\n{\n\tvoid __iomem *ctrl, *stat;\n\tu32 val;\n\tint ret;\n\n\tif (IS_V6(core)) {\n\t\tctrl = core->wrapper_base + WRAPPER_CORE_POWER_CONTROL_V6;\n\t\tstat = core->wrapper_base + WRAPPER_CORE_POWER_STATUS_V6;\n\t} else if (coreid == VIDC_CORE_ID_1) {\n\t\tctrl = core->wrapper_base + WRAPPER_VCODEC0_MMCC_POWER_CONTROL;\n\t\tstat = core->wrapper_base + WRAPPER_VCODEC0_MMCC_POWER_STATUS;\n\t} else {\n\t\tctrl = core->wrapper_base + WRAPPER_VCODEC1_MMCC_POWER_CONTROL;\n\t\tstat = core->wrapper_base + WRAPPER_VCODEC1_MMCC_POWER_STATUS;\n\t}\n\n\tif (enable) {\n\t\twritel(0, ctrl);\n\n\t\tret = readl_poll_timeout(stat, val, val & BIT(1), 1, 100);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\twritel(1, ctrl);\n\n\t\tret = readl_poll_timeout(stat, val, !(val & BIT(1)), 1, 100);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int poweroff_coreid(struct venus_core *core, unsigned int coreid_mask)\n{\n\tint ret;\n\n\tif (coreid_mask & VIDC_CORE_ID_1) {\n\t\tret = vcodec_control_v4(core, VIDC_CORE_ID_1, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvcodec_clks_disable(core, core->vcodec0_clks);\n\n\t\tret = vcodec_control_v4(core, VIDC_CORE_ID_1, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = pm_runtime_put_sync(core->pmdomains[1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (coreid_mask & VIDC_CORE_ID_2) {\n\t\tret = vcodec_control_v4(core, VIDC_CORE_ID_2, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvcodec_clks_disable(core, core->vcodec1_clks);\n\n\t\tret = vcodec_control_v4(core, VIDC_CORE_ID_2, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = pm_runtime_put_sync(core->pmdomains[2]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int poweron_coreid(struct venus_core *core, unsigned int coreid_mask)\n{\n\tint ret;\n\n\tif (coreid_mask & VIDC_CORE_ID_1) {\n\t\tret = pm_runtime_get_sync(core->pmdomains[1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = vcodec_control_v4(core, VIDC_CORE_ID_1, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = vcodec_clks_enable(core, core->vcodec0_clks);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = vcodec_control_v4(core, VIDC_CORE_ID_1, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (coreid_mask & VIDC_CORE_ID_2) {\n\t\tret = pm_runtime_get_sync(core->pmdomains[2]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = vcodec_control_v4(core, VIDC_CORE_ID_2, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = vcodec_clks_enable(core, core->vcodec1_clks);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = vcodec_control_v4(core, VIDC_CORE_ID_2, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int power_save_mode_enable(struct venus_inst *inst,\n\t\t\t\t\t bool enable)\n{\n\tstruct venc_controls *enc_ctr = &inst->controls.enc;\n\tconst u32 ptype = HFI_PROPERTY_CONFIG_VENC_PERF_MODE;\n\tu32 venc_mode;\n\tint ret = 0;\n\n\tif (inst->session_type != VIDC_SESSION_TYPE_ENC)\n\t\treturn 0;\n\n\tif (enc_ctr->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CQ)\n\t\tenable = false;\n\n\tvenc_mode = enable ? HFI_VENC_PERFMODE_POWER_SAVE :\n\t\tHFI_VENC_PERFMODE_MAX_QUALITY;\n\n\tret = hfi_session_set_property(inst, ptype, &venc_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tinst->flags = enable ? inst->flags | VENUS_LOW_POWER :\n\t\tinst->flags & ~VENUS_LOW_POWER;\n\n\treturn ret;\n}\n\nstatic int move_core_to_power_save_mode(struct venus_core *core,\n\t\t\t\t\tu32 core_id)\n{\n\tstruct venus_inst *inst = NULL;\n\n\tmutex_lock(&core->lock);\n\tlist_for_each_entry(inst, &core->instances, list) {\n\t\tif (inst->clk_data.core_id == core_id &&\n\t\t    inst->session_type == VIDC_SESSION_TYPE_ENC)\n\t\t\tpower_save_mode_enable(inst, true);\n\t}\n\tmutex_unlock(&core->lock);\n\treturn 0;\n}\n\nstatic void\nmin_loaded_core(struct venus_inst *inst, u32 *min_coreid, u32 *min_load, bool low_power)\n{\n\tu32 mbs_per_sec, load, core1_load = 0, core2_load = 0;\n\tu32 cores_max = core_num_max(inst);\n\tstruct venus_core *core = inst->core;\n\tstruct venus_inst *inst_pos;\n\tunsigned long vpp_freq;\n\tu32 coreid;\n\n\tmutex_lock(&core->lock);\n\n\tlist_for_each_entry(inst_pos, &core->instances, list) {\n\t\tif (inst_pos == inst)\n\t\t\tcontinue;\n\n\t\tif (inst_pos->state != INST_START)\n\t\t\tcontinue;\n\n\t\tif (inst->session_type == VIDC_SESSION_TYPE_DEC)\n\t\t\tvpp_freq = inst_pos->clk_data.vpp_freq;\n\t\telse if (inst->session_type == VIDC_SESSION_TYPE_ENC)\n\t\t\tvpp_freq = low_power ? inst_pos->clk_data.low_power_freq :\n\t\t\t\tinst_pos->clk_data.vpp_freq;\n\t\telse\n\t\t\tcontinue;\n\n\t\tcoreid = inst_pos->clk_data.core_id;\n\n\t\tmbs_per_sec = load_per_instance(inst_pos);\n\t\tload = mbs_per_sec * vpp_freq;\n\n\t\tif ((coreid & VIDC_CORE_ID_3) == VIDC_CORE_ID_3) {\n\t\t\tcore1_load += load / 2;\n\t\t\tcore2_load += load / 2;\n\t\t} else if (coreid & VIDC_CORE_ID_1) {\n\t\t\tcore1_load += load;\n\t\t} else if (coreid & VIDC_CORE_ID_2) {\n\t\t\tcore2_load += load;\n\t\t}\n\t}\n\n\t*min_coreid = core1_load <= core2_load ?\n\t\t\tVIDC_CORE_ID_1 : VIDC_CORE_ID_2;\n\t*min_load = min(core1_load, core2_load);\n\n\tif (cores_max < VIDC_CORE_ID_2 || core->res->vcodec_num < 2) {\n\t\t*min_coreid = VIDC_CORE_ID_1;\n\t\t*min_load = core1_load;\n\t}\n\n\tmutex_unlock(&core->lock);\n}\n\nstatic int decide_core(struct venus_inst *inst)\n{\n\tconst u32 ptype = HFI_PROPERTY_CONFIG_VIDEOCORES_USAGE;\n\tstruct venus_core *core = inst->core;\n\tu32 min_coreid, min_load, cur_inst_load;\n\tu32 min_lp_coreid, min_lp_load, cur_inst_lp_load;\n\tstruct hfi_videocores_usage_type cu;\n\tunsigned long max_freq;\n\tint ret = 0;\n\n\tif (legacy_binding) {\n\t\tif (inst->session_type == VIDC_SESSION_TYPE_DEC)\n\t\t\tcu.video_core_enable_mask = VIDC_CORE_ID_1;\n\t\telse\n\t\t\tcu.video_core_enable_mask = VIDC_CORE_ID_2;\n\n\t\tgoto done;\n\t}\n\n\tif (inst->clk_data.core_id != VIDC_CORE_ID_DEFAULT)\n\t\treturn 0;\n\n\tcur_inst_load = load_per_instance(inst);\n\tcur_inst_load *= inst->clk_data.vpp_freq;\n\t \n\n\tcur_inst_lp_load = load_per_instance(inst);\n\tcur_inst_lp_load *= inst->clk_data.low_power_freq;\n\t \n\n\tmax_freq = core->res->freq_tbl[0].freq;\n\n\tmin_loaded_core(inst, &min_coreid, &min_load, false);\n\tmin_loaded_core(inst, &min_lp_coreid, &min_lp_load, true);\n\n\tif (cur_inst_load + min_load <= max_freq) {\n\t\tinst->clk_data.core_id = min_coreid;\n\t\tcu.video_core_enable_mask = min_coreid;\n\t} else if (cur_inst_lp_load + min_load <= max_freq) {\n\t\t \n\t\tinst->clk_data.core_id = min_coreid;\n\t\tcu.video_core_enable_mask = min_coreid;\n\t\tpower_save_mode_enable(inst, true);\n\t} else if (cur_inst_lp_load + min_lp_load <= max_freq) {\n\t\t \n\t\tinst->clk_data.core_id = min_lp_coreid;\n\t\tcu.video_core_enable_mask = min_lp_coreid;\n\t\tmove_core_to_power_save_mode(core, min_lp_coreid);\n\t} else {\n\t\tdev_warn(core->dev, \"HW can't support this load\");\n\t\treturn -EINVAL;\n\t}\n\ndone:\n\tret = hfi_session_set_property(inst, ptype, &cu);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int acquire_core(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tunsigned int coreid_mask = 0;\n\n\tif (inst->core_acquired)\n\t\treturn 0;\n\n\tinst->core_acquired = true;\n\n\tif (inst->clk_data.core_id & VIDC_CORE_ID_1) {\n\t\tif (core->core0_usage_count++)\n\t\t\treturn 0;\n\n\t\tcoreid_mask = VIDC_CORE_ID_1;\n\t}\n\n\tif (inst->clk_data.core_id & VIDC_CORE_ID_2) {\n\t\tif (core->core1_usage_count++)\n\t\t\treturn 0;\n\n\t\tcoreid_mask |= VIDC_CORE_ID_2;\n\t}\n\n\treturn poweron_coreid(core, coreid_mask);\n}\n\nstatic int release_core(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tunsigned int coreid_mask = 0;\n\tint ret;\n\n\tif (!inst->core_acquired)\n\t\treturn 0;\n\n\tif (inst->clk_data.core_id & VIDC_CORE_ID_1) {\n\t\tif (--core->core0_usage_count)\n\t\t\tgoto done;\n\n\t\tcoreid_mask = VIDC_CORE_ID_1;\n\t}\n\n\tif (inst->clk_data.core_id & VIDC_CORE_ID_2) {\n\t\tif (--core->core1_usage_count)\n\t\t\tgoto done;\n\n\t\tcoreid_mask |= VIDC_CORE_ID_2;\n\t}\n\n\tret = poweroff_coreid(core, coreid_mask);\n\tif (ret)\n\t\treturn ret;\n\ndone:\n\tinst->clk_data.core_id = VIDC_CORE_ID_DEFAULT;\n\tinst->core_acquired = false;\n\treturn 0;\n}\n\nstatic int coreid_power_v4(struct venus_inst *inst, int on)\n{\n\tstruct venus_core *core = inst->core;\n\tint ret;\n\n\tif (legacy_binding)\n\t\treturn 0;\n\n\tif (on == POWER_ON) {\n\t\tret = decide_core(inst);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&core->lock);\n\t\tret = acquire_core(inst);\n\t\tmutex_unlock(&core->lock);\n\t} else {\n\t\tmutex_lock(&core->lock);\n\t\tret = release_core(inst);\n\t\tmutex_unlock(&core->lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int vdec_get_v4(struct device *dev)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\n\tif (!legacy_binding)\n\t\treturn 0;\n\n\treturn vcodec_clks_get(core, dev, core->vcodec0_clks,\n\t\t\t       core->res->vcodec0_clks);\n}\n\nstatic void vdec_put_v4(struct device *dev)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\tif (!legacy_binding)\n\t\treturn;\n\n\tfor (i = 0; i < core->res->vcodec_clks_num; i++)\n\t\tcore->vcodec0_clks[i] = NULL;\n}\n\nstatic int vdec_power_v4(struct device *dev, int on)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!legacy_binding)\n\t\treturn 0;\n\n\tret = vcodec_control_v4(core, VIDC_CORE_ID_1, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (on == POWER_ON)\n\t\tret = vcodec_clks_enable(core, core->vcodec0_clks);\n\telse\n\t\tvcodec_clks_disable(core, core->vcodec0_clks);\n\n\tvcodec_control_v4(core, VIDC_CORE_ID_1, false);\n\n\treturn ret;\n}\n\nstatic int venc_get_v4(struct device *dev)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\n\tif (!legacy_binding)\n\t\treturn 0;\n\n\treturn vcodec_clks_get(core, dev, core->vcodec1_clks,\n\t\t\t       core->res->vcodec1_clks);\n}\n\nstatic void venc_put_v4(struct device *dev)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\tif (!legacy_binding)\n\t\treturn;\n\n\tfor (i = 0; i < core->res->vcodec_clks_num; i++)\n\t\tcore->vcodec1_clks[i] = NULL;\n}\n\nstatic int venc_power_v4(struct device *dev, int on)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!legacy_binding)\n\t\treturn 0;\n\n\tret = vcodec_control_v4(core, VIDC_CORE_ID_2, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (on == POWER_ON)\n\t\tret = vcodec_clks_enable(core, core->vcodec1_clks);\n\telse\n\t\tvcodec_clks_disable(core, core->vcodec1_clks);\n\n\tvcodec_control_v4(core, VIDC_CORE_ID_2, false);\n\n\treturn ret;\n}\n\nstatic int vcodec_domains_get(struct venus_core *core)\n{\n\tint ret;\n\tstruct device **opp_virt_dev;\n\tstruct device *dev = core->dev;\n\tconst struct venus_resources *res = core->res;\n\tstruct device *pd;\n\tunsigned int i;\n\n\tif (!res->vcodec_pmdomains_num)\n\t\tgoto skip_pmdomains;\n\n\tfor (i = 0; i < res->vcodec_pmdomains_num; i++) {\n\t\tpd = dev_pm_domain_attach_by_name(dev,\n\t\t\t\t\t\t  res->vcodec_pmdomains[i]);\n\t\tif (IS_ERR_OR_NULL(pd))\n\t\t\treturn PTR_ERR(pd) ? : -ENODATA;\n\t\tcore->pmdomains[i] = pd;\n\t}\n\nskip_pmdomains:\n\tif (!core->res->opp_pmdomain)\n\t\treturn 0;\n\n\t \n\tret = devm_pm_opp_attach_genpd(dev, res->opp_pmdomain, &opp_virt_dev);\n\tif (ret)\n\t\tgoto opp_attach_err;\n\n\tcore->opp_pmdomain = *opp_virt_dev;\n\tcore->opp_dl_venus = device_link_add(dev, core->opp_pmdomain,\n\t\t\t\t\t     DL_FLAG_RPM_ACTIVE |\n\t\t\t\t\t     DL_FLAG_PM_RUNTIME |\n\t\t\t\t\t     DL_FLAG_STATELESS);\n\tif (!core->opp_dl_venus) {\n\t\tret = -ENODEV;\n\t\tgoto opp_attach_err;\n\t}\n\n\treturn 0;\n\nopp_attach_err:\n\tfor (i = 0; i < res->vcodec_pmdomains_num; i++) {\n\t\tif (IS_ERR_OR_NULL(core->pmdomains[i]))\n\t\t\tcontinue;\n\t\tdev_pm_domain_detach(core->pmdomains[i], true);\n\t}\n\n\treturn ret;\n}\n\nstatic void vcodec_domains_put(struct venus_core *core)\n{\n\tconst struct venus_resources *res = core->res;\n\tunsigned int i;\n\n\tif (!res->vcodec_pmdomains_num)\n\t\tgoto skip_pmdomains;\n\n\tfor (i = 0; i < res->vcodec_pmdomains_num; i++) {\n\t\tif (IS_ERR_OR_NULL(core->pmdomains[i]))\n\t\t\tcontinue;\n\t\tdev_pm_domain_detach(core->pmdomains[i], true);\n\t}\n\nskip_pmdomains:\n\tif (!core->has_opp_table)\n\t\treturn;\n\n\tif (core->opp_dl_venus)\n\t\tdevice_link_del(core->opp_dl_venus);\n}\n\nstatic int core_resets_reset(struct venus_core *core)\n{\n\tconst struct venus_resources *res = core->res;\n\tunsigned int i;\n\tint ret;\n\n\tif (!res->resets_num)\n\t\treturn 0;\n\n\tfor (i = 0; i < res->resets_num; i++) {\n\t\tret = reset_control_assert(core->resets[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tusleep_range(150, 250);\n\t\tret = reset_control_deassert(core->resets[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\nerr:\n\treturn ret;\n}\n\nstatic int core_resets_get(struct venus_core *core)\n{\n\tstruct device *dev = core->dev;\n\tconst struct venus_resources *res = core->res;\n\tunsigned int i;\n\tint ret;\n\n\tif (!res->resets_num)\n\t\treturn 0;\n\n\tfor (i = 0; i < res->resets_num; i++) {\n\t\tcore->resets[i] =\n\t\t\tdevm_reset_control_get_exclusive(dev, res->resets[i]);\n\t\tif (IS_ERR(core->resets[i])) {\n\t\t\tret = PTR_ERR(core->resets[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int core_get_v4(struct venus_core *core)\n{\n\tstruct device *dev = core->dev;\n\tconst struct venus_resources *res = core->res;\n\tint ret;\n\n\tret = core_clks_get(core);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!res->vcodec_pmdomains_num)\n\t\tlegacy_binding = true;\n\n\tdev_info(dev, \"%s legacy binding\\n\", legacy_binding ? \"\" : \"non\");\n\n\tret = vcodec_clks_get(core, dev, core->vcodec0_clks, res->vcodec0_clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vcodec_clks_get(core, dev, core->vcodec1_clks, res->vcodec1_clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = core_resets_get(core);\n\tif (ret)\n\t\treturn ret;\n\n\tif (legacy_binding)\n\t\treturn 0;\n\n\tret = devm_pm_opp_set_clkname(dev, \"core\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = vcodec_domains_get(core);\n\tif (ret)\n\t\treturn ret;\n\n\tif (core->res->opp_pmdomain) {\n\t\tret = devm_pm_opp_of_add_table(dev);\n\t\tif (!ret) {\n\t\t\tcore->has_opp_table = true;\n\t\t} else if (ret != -ENODEV) {\n\t\t\tdev_err(dev, \"invalid OPP table in device tree\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void core_put_v4(struct venus_core *core)\n{\n\tif (legacy_binding)\n\t\treturn;\n\n\tvcodec_domains_put(core);\n}\n\nstatic int core_power_v4(struct venus_core *core, int on)\n{\n\tstruct device *dev = core->dev;\n\tstruct device *pmctrl = core->pmdomains[0];\n\tint ret = 0;\n\n\tif (on == POWER_ON) {\n\t\tif (pmctrl) {\n\t\t\tret = pm_runtime_resume_and_get(pmctrl);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = core_resets_reset(core);\n\t\tif (ret) {\n\t\t\tif (pmctrl)\n\t\t\t\tpm_runtime_put_sync(pmctrl);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = core_clks_enable(core);\n\t\tif (ret < 0 && pmctrl)\n\t\t\tpm_runtime_put_sync(pmctrl);\n\t} else {\n\t\t \n\t\tif (core->opp_pmdomain)\n\t\t\tdev_pm_opp_set_rate(dev, 0);\n\n\t\tcore_clks_disable(core);\n\n\t\tret = core_resets_reset(core);\n\n\t\tif (pmctrl)\n\t\t\tpm_runtime_put_sync(pmctrl);\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned long calculate_inst_freq(struct venus_inst *inst,\n\t\t\t\t\t unsigned long filled_len)\n{\n\tunsigned long vpp_freq_per_mb = 0, vpp_freq = 0, vsp_freq = 0;\n\tu32 fps = (u32)inst->fps;\n\tu32 mbs_per_sec;\n\n\tmbs_per_sec = load_per_instance(inst);\n\n\tif (inst->state != INST_START)\n\t\treturn 0;\n\n\tif (inst->session_type == VIDC_SESSION_TYPE_ENC) {\n\t\tvpp_freq_per_mb = inst->flags & VENUS_LOW_POWER ?\n\t\t\tinst->clk_data.low_power_freq :\n\t\t\tinst->clk_data.vpp_freq;\n\n\t\tvpp_freq = mbs_per_sec * vpp_freq_per_mb;\n\t} else {\n\t\tvpp_freq = mbs_per_sec * inst->clk_data.vpp_freq;\n\t}\n\n\t \n\tvpp_freq += vpp_freq / 20;\n\tvsp_freq = mbs_per_sec * inst->clk_data.vsp_freq;\n\n\t \n\tif (inst->session_type == VIDC_SESSION_TYPE_ENC)\n\t\tvsp_freq += (inst->controls.enc.bitrate * 10) / 7;\n\telse\n\t\tvsp_freq += ((fps * filled_len * 8) * 10) / 7;\n\n\treturn max(vpp_freq, vsp_freq);\n}\n\nstatic int load_scale_v4(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tconst struct freq_tbl *table = core->res->freq_tbl;\n\tunsigned int num_rows = core->res->freq_tbl_size;\n\tstruct device *dev = core->dev;\n\tunsigned long freq = 0, freq_core1 = 0, freq_core2 = 0;\n\tunsigned long filled_len = 0;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < inst->num_input_bufs; i++)\n\t\tfilled_len = max(filled_len, inst->payloads[i]);\n\n\tif (inst->session_type == VIDC_SESSION_TYPE_DEC && !filled_len)\n\t\treturn ret;\n\n\tfreq = calculate_inst_freq(inst, filled_len);\n\tinst->clk_data.freq = freq;\n\n\tmutex_lock(&core->lock);\n\tlist_for_each_entry(inst, &core->instances, list) {\n\t\tif (inst->clk_data.core_id == VIDC_CORE_ID_1) {\n\t\t\tfreq_core1 += inst->clk_data.freq;\n\t\t} else if (inst->clk_data.core_id == VIDC_CORE_ID_2) {\n\t\t\tfreq_core2 += inst->clk_data.freq;\n\t\t} else if (inst->clk_data.core_id == VIDC_CORE_ID_3) {\n\t\t\tfreq_core1 += inst->clk_data.freq;\n\t\t\tfreq_core2 += inst->clk_data.freq;\n\t\t}\n\t}\n\n\tfreq = max(freq_core1, freq_core2);\n\n\tif (freq > table[0].freq) {\n\t\tdev_dbg(dev, VDBGL \"requested clock rate: %lu scaling clock rate : %lu\\n\",\n\t\t\tfreq, table[0].freq);\n\n\t\tfreq = table[0].freq;\n\t\tgoto set_freq;\n\t}\n\n\tfor (i = num_rows - 1 ; i >= 0; i--) {\n\t\tif (freq <= table[i].freq) {\n\t\t\tfreq = table[i].freq;\n\t\t\tbreak;\n\t\t}\n\t}\n\nset_freq:\n\n\tret = core_clks_set_rate(core, freq);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set clock rate %lu (%d)\\n\",\n\t\t\tfreq, ret);\n\t\tgoto exit;\n\t}\n\n\tret = load_scale_bw(core);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set bandwidth (%d)\\n\",\n\t\t\tret);\n\t\tgoto exit;\n\t}\n\nexit:\n\tmutex_unlock(&core->lock);\n\treturn ret;\n}\n\nstatic const struct venus_pm_ops pm_ops_v4 = {\n\t.core_get = core_get_v4,\n\t.core_put = core_put_v4,\n\t.core_power = core_power_v4,\n\t.vdec_get = vdec_get_v4,\n\t.vdec_put = vdec_put_v4,\n\t.vdec_power = vdec_power_v4,\n\t.venc_get = venc_get_v4,\n\t.venc_put = venc_put_v4,\n\t.venc_power = venc_power_v4,\n\t.coreid_power = coreid_power_v4,\n\t.load_scale = load_scale_v4,\n};\n\nconst struct venus_pm_ops *venus_pm_get(enum hfi_version version)\n{\n\tswitch (version) {\n\tcase HFI_VERSION_1XX:\n\tdefault:\n\t\treturn &pm_ops_v1;\n\tcase HFI_VERSION_3XX:\n\t\treturn &pm_ops_v3;\n\tcase HFI_VERSION_4XX:\n\tcase HFI_VERSION_6XX:\n\t\treturn &pm_ops_v4;\n\t}\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}