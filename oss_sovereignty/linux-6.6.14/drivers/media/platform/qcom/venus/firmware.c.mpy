{
  "module_name": "firmware.c",
  "hash_id": "11ca8eddfbc5bb4abe2eb35c3ccf97fb88c5cedbb413af1a17c1a6c899645805",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/venus/firmware.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/iommu.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/of_device.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n#include <linux/sizes.h>\n#include <linux/soc/qcom/mdt_loader.h>\n\n#include \"core.h\"\n#include \"firmware.h\"\n#include \"hfi_venus_io.h\"\n\n#define VENUS_PAS_ID\t\t\t9\n#define VENUS_FW_MEM_SIZE\t\t(6 * SZ_1M)\n#define VENUS_FW_START_ADDR\t\t0x0\n\nstatic void venus_reset_cpu(struct venus_core *core)\n{\n\tu32 fw_size = core->fw.mapped_mem_size;\n\tvoid __iomem *wrapper_base;\n\n\tif (IS_IRIS2_1(core))\n\t\twrapper_base = core->wrapper_tz_base;\n\telse\n\t\twrapper_base = core->wrapper_base;\n\n\twritel(0, wrapper_base + WRAPPER_FW_START_ADDR);\n\twritel(fw_size, wrapper_base + WRAPPER_FW_END_ADDR);\n\twritel(0, wrapper_base + WRAPPER_CPA_START_ADDR);\n\twritel(fw_size, wrapper_base + WRAPPER_CPA_END_ADDR);\n\twritel(fw_size, wrapper_base + WRAPPER_NONPIX_START_ADDR);\n\twritel(fw_size, wrapper_base + WRAPPER_NONPIX_END_ADDR);\n\n\tif (IS_IRIS2_1(core)) {\n\t\t \n\t\twritel(0, wrapper_base + WRAPPER_TZ_XTSS_SW_RESET);\n\t} else {\n\t\twritel(0x0, wrapper_base + WRAPPER_CPU_CGC_DIS);\n\t\twritel(0x0, wrapper_base + WRAPPER_CPU_CLOCK_CONFIG);\n\n\t\t \n\t\twritel(0, wrapper_base + WRAPPER_A9SS_SW_RESET);\n\t}\n}\n\nint venus_set_hw_state(struct venus_core *core, bool resume)\n{\n\tint ret;\n\n\tif (core->use_tz) {\n\t\tret = qcom_scm_set_remote_state(resume, 0);\n\t\tif (resume && ret == -EINVAL)\n\t\t\tret = 0;\n\t\treturn ret;\n\t}\n\n\tif (resume) {\n\t\tvenus_reset_cpu(core);\n\t} else {\n\t\tif (IS_IRIS2_1(core))\n\t\t\twritel(WRAPPER_XTSS_SW_RESET_BIT,\n\t\t\t       core->wrapper_tz_base + WRAPPER_TZ_XTSS_SW_RESET);\n\t\telse\n\t\t\twritel(WRAPPER_A9SS_SW_RESET_BIT,\n\t\t\t       core->wrapper_base + WRAPPER_A9SS_SW_RESET);\n\t}\n\n\treturn 0;\n}\n\nstatic int venus_load_fw(struct venus_core *core, const char *fwname,\n\t\t\t phys_addr_t *mem_phys, size_t *mem_size)\n{\n\tconst struct firmware *mdt;\n\tstruct reserved_mem *rmem;\n\tstruct device_node *node;\n\tstruct device *dev;\n\tssize_t fw_size;\n\tvoid *mem_va;\n\tint ret;\n\n\t*mem_phys = 0;\n\t*mem_size = 0;\n\n\tdev = core->dev;\n\tnode = of_parse_phandle(dev->of_node, \"memory-region\", 0);\n\tif (!node) {\n\t\tdev_err(dev, \"no memory-region specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trmem = of_reserved_mem_lookup(node);\n\tof_node_put(node);\n\tif (!rmem) {\n\t\tdev_err(dev, \"failed to lookup reserved memory-region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = request_firmware(&mdt, fwname, dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfw_size = qcom_mdt_get_size(mdt);\n\tif (fw_size < 0) {\n\t\tret = fw_size;\n\t\tgoto err_release_fw;\n\t}\n\n\t*mem_phys = rmem->base;\n\t*mem_size = rmem->size;\n\n\tif (*mem_size < fw_size || fw_size > VENUS_FW_MEM_SIZE) {\n\t\tret = -EINVAL;\n\t\tgoto err_release_fw;\n\t}\n\n\tmem_va = memremap(*mem_phys, *mem_size, MEMREMAP_WC);\n\tif (!mem_va) {\n\t\tdev_err(dev, \"unable to map memory region %pa size %#zx\\n\", mem_phys, *mem_size);\n\t\tret = -ENOMEM;\n\t\tgoto err_release_fw;\n\t}\n\n\tif (core->use_tz)\n\t\tret = qcom_mdt_load(dev, mdt, fwname, VENUS_PAS_ID,\n\t\t\t\t    mem_va, *mem_phys, *mem_size, NULL);\n\telse\n\t\tret = qcom_mdt_load_no_init(dev, mdt, fwname, VENUS_PAS_ID,\n\t\t\t\t\t    mem_va, *mem_phys, *mem_size, NULL);\n\n\tmemunmap(mem_va);\nerr_release_fw:\n\trelease_firmware(mdt);\n\treturn ret;\n}\n\nstatic int venus_boot_no_tz(struct venus_core *core, phys_addr_t mem_phys,\n\t\t\t    size_t mem_size)\n{\n\tstruct iommu_domain *iommu;\n\tstruct device *dev;\n\tint ret;\n\n\tdev = core->fw.dev;\n\tif (!dev)\n\t\treturn -EPROBE_DEFER;\n\n\tiommu = core->fw.iommu_domain;\n\tcore->fw.mapped_mem_size = mem_size;\n\n\tret = iommu_map(iommu, VENUS_FW_START_ADDR, mem_phys, mem_size,\n\t\t\tIOMMU_READ | IOMMU_WRITE | IOMMU_PRIV, GFP_KERNEL);\n\tif (ret) {\n\t\tdev_err(dev, \"could not map video firmware region\\n\");\n\t\treturn ret;\n\t}\n\n\tvenus_reset_cpu(core);\n\n\treturn 0;\n}\n\nstatic int venus_shutdown_no_tz(struct venus_core *core)\n{\n\tconst size_t mapped = core->fw.mapped_mem_size;\n\tstruct iommu_domain *iommu;\n\tsize_t unmapped;\n\tu32 reg;\n\tstruct device *dev = core->fw.dev;\n\tvoid __iomem *wrapper_base = core->wrapper_base;\n\tvoid __iomem *wrapper_tz_base = core->wrapper_tz_base;\n\n\tif (IS_IRIS2_1(core)) {\n\t\t \n\t\treg = readl(wrapper_tz_base + WRAPPER_TZ_XTSS_SW_RESET);\n\t\treg |= WRAPPER_XTSS_SW_RESET_BIT;\n\t\twritel(reg, wrapper_tz_base + WRAPPER_TZ_XTSS_SW_RESET);\n\t} else {\n\t\t \n\t\treg = readl(wrapper_base + WRAPPER_A9SS_SW_RESET);\n\t\treg |= WRAPPER_A9SS_SW_RESET_BIT;\n\t\twritel(reg, wrapper_base + WRAPPER_A9SS_SW_RESET);\n\t}\n\n\tiommu = core->fw.iommu_domain;\n\n\tif (core->fw.mapped_mem_size && iommu) {\n\t\tunmapped = iommu_unmap(iommu, VENUS_FW_START_ADDR, mapped);\n\n\t\tif (unmapped != mapped)\n\t\t\tdev_err(dev, \"failed to unmap firmware\\n\");\n\t\telse\n\t\t\tcore->fw.mapped_mem_size = 0;\n\t}\n\n\treturn 0;\n}\n\nint venus_boot(struct venus_core *core)\n{\n\tstruct device *dev = core->dev;\n\tconst struct venus_resources *res = core->res;\n\tconst char *fwpath = NULL;\n\tphys_addr_t mem_phys;\n\tsize_t mem_size;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_QCOM_MDT_LOADER) ||\n\t    (core->use_tz && !qcom_scm_is_available()))\n\t\treturn -EPROBE_DEFER;\n\n\tret = of_property_read_string_index(dev->of_node, \"firmware-name\", 0,\n\t\t\t\t\t    &fwpath);\n\tif (ret)\n\t\tfwpath = core->res->fwname;\n\n\tret = venus_load_fw(core, fwpath, &mem_phys, &mem_size);\n\tif (ret) {\n\t\tdev_err(dev, \"fail to load video firmware\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcore->fw.mem_size = mem_size;\n\tcore->fw.mem_phys = mem_phys;\n\n\tif (core->use_tz)\n\t\tret = qcom_scm_pas_auth_and_reset(VENUS_PAS_ID);\n\telse\n\t\tret = venus_boot_no_tz(core, mem_phys, mem_size);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (core->use_tz && res->cp_size) {\n\t\t \n\t\tret = qcom_scm_mem_protect_video_var(res->cp_start,\n\t\t\t\t\t\t     res->cp_size,\n\t\t\t\t\t\t     res->cp_nonpixel_start,\n\t\t\t\t\t\t     res->cp_nonpixel_size);\n\t\tif (ret) {\n\t\t\tqcom_scm_pas_shutdown(VENUS_PAS_ID);\n\t\t\tdev_err(dev, \"set virtual address ranges fail (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint venus_shutdown(struct venus_core *core)\n{\n\tint ret;\n\n\tif (core->use_tz)\n\t\tret = qcom_scm_pas_shutdown(VENUS_PAS_ID);\n\telse\n\t\tret = venus_shutdown_no_tz(core);\n\n\treturn ret;\n}\n\nint venus_firmware_init(struct venus_core *core)\n{\n\tstruct platform_device_info info;\n\tstruct iommu_domain *iommu_dom;\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tint ret;\n\n\tnp = of_get_child_by_name(core->dev->of_node, \"video-firmware\");\n\tif (!np) {\n\t\tcore->use_tz = true;\n\t\treturn 0;\n\t}\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.fwnode = &np->fwnode;\n\tinfo.parent = core->dev;\n\tinfo.name = np->name;\n\tinfo.dma_mask = DMA_BIT_MASK(32);\n\n\tpdev = platform_device_register_full(&info);\n\tif (IS_ERR(pdev)) {\n\t\tof_node_put(np);\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\tpdev->dev.of_node = np;\n\n\tret = of_dma_configure(&pdev->dev, np, true);\n\tif (ret) {\n\t\tdev_err(core->dev, \"dma configure fail\\n\");\n\t\tgoto err_unregister;\n\t}\n\n\tcore->fw.dev = &pdev->dev;\n\n\tiommu_dom = iommu_domain_alloc(&platform_bus_type);\n\tif (!iommu_dom) {\n\t\tdev_err(core->fw.dev, \"Failed to allocate iommu domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_unregister;\n\t}\n\n\tret = iommu_attach_device(iommu_dom, core->fw.dev);\n\tif (ret) {\n\t\tdev_err(core->fw.dev, \"could not attach device\\n\");\n\t\tgoto err_iommu_free;\n\t}\n\n\tcore->fw.iommu_domain = iommu_dom;\n\n\tof_node_put(np);\n\n\treturn 0;\n\nerr_iommu_free:\n\tiommu_domain_free(iommu_dom);\nerr_unregister:\n\tplatform_device_unregister(pdev);\n\tof_node_put(np);\n\treturn ret;\n}\n\nvoid venus_firmware_deinit(struct venus_core *core)\n{\n\tstruct iommu_domain *iommu;\n\n\tif (!core->fw.dev)\n\t\treturn;\n\n\tiommu = core->fw.iommu_domain;\n\n\tiommu_detach_device(iommu, core->fw.dev);\n\n\tif (core->fw.iommu_domain) {\n\t\tiommu_domain_free(iommu);\n\t\tcore->fw.iommu_domain = NULL;\n\t}\n\n\tplatform_device_unregister(to_platform_device(core->fw.dev));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}