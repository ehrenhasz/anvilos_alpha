{
  "module_name": "hfi.c",
  "hash_id": "ff022ff8fe05c4719e805a188e5735a29462e96700f85242d181f687b0add3e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/venus/hfi.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/completion.h>\n#include <linux/platform_device.h>\n#include <linux/videodev2.h>\n\n#include \"core.h\"\n#include \"hfi.h\"\n#include \"hfi_cmds.h\"\n#include \"hfi_venus.h\"\n\n#define TIMEOUT\t\tmsecs_to_jiffies(1000)\n\nstatic u32 to_codec_type(u32 pixfmt)\n{\n\tswitch (pixfmt) {\n\tcase V4L2_PIX_FMT_H264:\n\tcase V4L2_PIX_FMT_H264_NO_SC:\n\t\treturn HFI_VIDEO_CODEC_H264;\n\tcase V4L2_PIX_FMT_H263:\n\t\treturn HFI_VIDEO_CODEC_H263;\n\tcase V4L2_PIX_FMT_MPEG1:\n\t\treturn HFI_VIDEO_CODEC_MPEG1;\n\tcase V4L2_PIX_FMT_MPEG2:\n\t\treturn HFI_VIDEO_CODEC_MPEG2;\n\tcase V4L2_PIX_FMT_MPEG4:\n\t\treturn HFI_VIDEO_CODEC_MPEG4;\n\tcase V4L2_PIX_FMT_VC1_ANNEX_G:\n\tcase V4L2_PIX_FMT_VC1_ANNEX_L:\n\t\treturn HFI_VIDEO_CODEC_VC1;\n\tcase V4L2_PIX_FMT_VP8:\n\t\treturn HFI_VIDEO_CODEC_VP8;\n\tcase V4L2_PIX_FMT_VP9:\n\t\treturn HFI_VIDEO_CODEC_VP9;\n\tcase V4L2_PIX_FMT_XVID:\n\t\treturn HFI_VIDEO_CODEC_DIVX;\n\tcase V4L2_PIX_FMT_HEVC:\n\t\treturn HFI_VIDEO_CODEC_HEVC;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint hfi_core_init(struct venus_core *core)\n{\n\tint ret = 0;\n\n\tmutex_lock(&core->lock);\n\n\tif (core->state >= CORE_INIT)\n\t\tgoto unlock;\n\n\treinit_completion(&core->done);\n\n\tret = core->ops->core_init(core);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = wait_for_completion_timeout(&core->done, TIMEOUT);\n\tif (!ret) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto unlock;\n\t}\n\n\tret = 0;\n\n\tif (core->error != HFI_ERR_NONE) {\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tcore->state = CORE_INIT;\nunlock:\n\tmutex_unlock(&core->lock);\n\treturn ret;\n}\n\nint hfi_core_deinit(struct venus_core *core, bool blocking)\n{\n\tint ret = 0, empty;\n\n\tmutex_lock(&core->lock);\n\n\tif (core->state == CORE_UNINIT)\n\t\tgoto unlock;\n\n\tempty = list_empty(&core->instances);\n\n\tif (!empty && !blocking) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (!empty) {\n\t\tmutex_unlock(&core->lock);\n\t\twait_var_event(&core->insts_count,\n\t\t\t       !atomic_read(&core->insts_count));\n\t\tmutex_lock(&core->lock);\n\t}\n\n\tif (!core->ops)\n\t\tgoto unlock;\n\n\tret = core->ops->core_deinit(core);\n\n\tif (!ret)\n\t\tcore->state = CORE_UNINIT;\n\nunlock:\n\tmutex_unlock(&core->lock);\n\treturn ret;\n}\n\nint hfi_core_suspend(struct venus_core *core)\n{\n\tif (core->state != CORE_INIT)\n\t\treturn 0;\n\n\treturn core->ops->suspend(core);\n}\n\nint hfi_core_resume(struct venus_core *core, bool force)\n{\n\tif (!force && core->state != CORE_INIT)\n\t\treturn 0;\n\n\treturn core->ops->resume(core);\n}\n\nint hfi_core_trigger_ssr(struct venus_core *core, u32 type)\n{\n\treturn core->ops->core_trigger_ssr(core, type);\n}\n\nint hfi_core_ping(struct venus_core *core)\n{\n\tint ret;\n\n\tmutex_lock(&core->lock);\n\n\tret = core->ops->core_ping(core, 0xbeef);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = wait_for_completion_timeout(&core->done, TIMEOUT);\n\tif (!ret) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto unlock;\n\t}\n\tret = 0;\n\tif (core->error != HFI_ERR_NONE)\n\t\tret = -ENODEV;\nunlock:\n\tmutex_unlock(&core->lock);\n\treturn ret;\n}\n\nstatic int wait_session_msg(struct venus_inst *inst)\n{\n\tint ret;\n\n\tret = wait_for_completion_timeout(&inst->done, TIMEOUT);\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\tif (inst->error != HFI_ERR_NONE)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint hfi_session_create(struct venus_inst *inst, const struct hfi_inst_ops *ops)\n{\n\tstruct venus_core *core = inst->core;\n\tbool max;\n\tint ret;\n\n\tif (!ops)\n\t\treturn -EINVAL;\n\n\tinst->state = INST_UNINIT;\n\tinit_completion(&inst->done);\n\tinst->ops = ops;\n\n\tmutex_lock(&core->lock);\n\n\tif (test_bit(0, &inst->core->sys_error)) {\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tmax = atomic_add_unless(&core->insts_count, 1,\n\t\t\t\tcore->max_sessions_supported);\n\tif (!max) {\n\t\tret = -EAGAIN;\n\t} else {\n\t\tlist_add_tail(&inst->list, &core->instances);\n\t\tret = 0;\n\t}\n\nunlock:\n\tmutex_unlock(&core->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hfi_session_create);\n\nint hfi_session_init(struct venus_inst *inst, u32 pixfmt)\n{\n\tstruct venus_core *core = inst->core;\n\tconst struct hfi_ops *ops = core->ops;\n\tint ret;\n\n\t \n\tmutex_lock(&core->lock);\n\tif (!core->ops || test_bit(0, &inst->core->sys_error)) {\n\t\tmutex_unlock(&core->lock);\n\t\treturn -EIO;\n\t}\n\tmutex_unlock(&core->lock);\n\n\tif (inst->state != INST_UNINIT)\n\t\treturn -EALREADY;\n\n\tinst->hfi_codec = to_codec_type(pixfmt);\n\treinit_completion(&inst->done);\n\n\tret = ops->session_init(inst, inst->session_type, inst->hfi_codec);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_session_msg(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tinst->state = INST_INIT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hfi_session_init);\n\nvoid hfi_session_destroy(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\n\tmutex_lock(&core->lock);\n\tlist_del_init(&inst->list);\n\tif (atomic_dec_and_test(&core->insts_count))\n\t\twake_up_var(&core->insts_count);\n\tmutex_unlock(&core->lock);\n}\nEXPORT_SYMBOL_GPL(hfi_session_destroy);\n\nint hfi_session_deinit(struct venus_inst *inst)\n{\n\tconst struct hfi_ops *ops = inst->core->ops;\n\tint ret;\n\n\tif (inst->state == INST_UNINIT)\n\t\treturn 0;\n\n\tif (inst->state < INST_INIT)\n\t\treturn -EINVAL;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\tgoto done;\n\n\treinit_completion(&inst->done);\n\n\tret = ops->session_end(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_session_msg(inst);\n\tif (ret)\n\t\treturn ret;\n\ndone:\n\tinst->state = INST_UNINIT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hfi_session_deinit);\n\nint hfi_session_start(struct venus_inst *inst)\n{\n\tconst struct hfi_ops *ops = inst->core->ops;\n\tint ret;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\treturn -EIO;\n\n\tif (inst->state != INST_LOAD_RESOURCES)\n\t\treturn -EINVAL;\n\n\treinit_completion(&inst->done);\n\n\tret = ops->session_start(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_session_msg(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tinst->state = INST_START;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hfi_session_start);\n\nint hfi_session_stop(struct venus_inst *inst)\n{\n\tconst struct hfi_ops *ops = inst->core->ops;\n\tint ret;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\treturn -EIO;\n\n\tif (inst->state != INST_START)\n\t\treturn -EINVAL;\n\n\treinit_completion(&inst->done);\n\n\tret = ops->session_stop(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_session_msg(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tinst->state = INST_STOP;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hfi_session_stop);\n\nint hfi_session_continue(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\treturn -EIO;\n\n\tif (core->res->hfi_version == HFI_VERSION_1XX)\n\t\treturn 0;\n\n\treturn core->ops->session_continue(inst);\n}\nEXPORT_SYMBOL_GPL(hfi_session_continue);\n\nint hfi_session_abort(struct venus_inst *inst)\n{\n\tconst struct hfi_ops *ops = inst->core->ops;\n\tint ret;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\treturn -EIO;\n\n\treinit_completion(&inst->done);\n\n\tret = ops->session_abort(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_session_msg(inst);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hfi_session_abort);\n\nint hfi_session_load_res(struct venus_inst *inst)\n{\n\tconst struct hfi_ops *ops = inst->core->ops;\n\tint ret;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\treturn -EIO;\n\n\tif (inst->state != INST_INIT)\n\t\treturn -EINVAL;\n\n\treinit_completion(&inst->done);\n\n\tret = ops->session_load_res(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_session_msg(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tinst->state = INST_LOAD_RESOURCES;\n\n\treturn 0;\n}\n\nint hfi_session_unload_res(struct venus_inst *inst)\n{\n\tconst struct hfi_ops *ops = inst->core->ops;\n\tint ret;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\treturn -EIO;\n\n\tif (inst->state != INST_STOP)\n\t\treturn -EINVAL;\n\n\treinit_completion(&inst->done);\n\n\tret = ops->session_release_res(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_session_msg(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tinst->state = INST_RELEASE_RESOURCES;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hfi_session_unload_res);\n\nint hfi_session_flush(struct venus_inst *inst, u32 type, bool block)\n{\n\tconst struct hfi_ops *ops = inst->core->ops;\n\tint ret;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\treturn -EIO;\n\n\treinit_completion(&inst->done);\n\n\tret = ops->session_flush(inst, type);\n\tif (ret)\n\t\treturn ret;\n\n\tif (block) {\n\t\tret = wait_session_msg(inst);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hfi_session_flush);\n\nint hfi_session_set_buffers(struct venus_inst *inst, struct hfi_buffer_desc *bd)\n{\n\tconst struct hfi_ops *ops = inst->core->ops;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\treturn -EIO;\n\n\treturn ops->session_set_buffers(inst, bd);\n}\n\nint hfi_session_unset_buffers(struct venus_inst *inst,\n\t\t\t      struct hfi_buffer_desc *bd)\n{\n\tconst struct hfi_ops *ops = inst->core->ops;\n\tint ret;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\treturn -EIO;\n\n\treinit_completion(&inst->done);\n\n\tret = ops->session_unset_buffers(inst, bd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!bd->response_required)\n\t\treturn 0;\n\n\tret = wait_session_msg(inst);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint hfi_session_get_property(struct venus_inst *inst, u32 ptype,\n\t\t\t     union hfi_get_property *hprop)\n{\n\tconst struct hfi_ops *ops = inst->core->ops;\n\tint ret;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\treturn -EIO;\n\n\tif (inst->state < INST_INIT || inst->state >= INST_STOP)\n\t\treturn -EINVAL;\n\n\treinit_completion(&inst->done);\n\n\tret = ops->session_get_property(inst, ptype);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_session_msg(inst);\n\tif (ret)\n\t\treturn ret;\n\n\t*hprop = inst->hprop;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hfi_session_get_property);\n\nint hfi_session_set_property(struct venus_inst *inst, u32 ptype, void *pdata)\n{\n\tconst struct hfi_ops *ops = inst->core->ops;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\treturn -EIO;\n\n\tif (inst->state < INST_INIT || inst->state >= INST_STOP)\n\t\treturn -EINVAL;\n\n\treturn ops->session_set_property(inst, ptype, pdata);\n}\nEXPORT_SYMBOL_GPL(hfi_session_set_property);\n\nint hfi_session_process_buf(struct venus_inst *inst, struct hfi_frame_data *fd)\n{\n\tconst struct hfi_ops *ops = inst->core->ops;\n\n\tif (test_bit(0, &inst->core->sys_error))\n\t\treturn -EIO;\n\n\tif (fd->buffer_type == HFI_BUFFER_INPUT)\n\t\treturn ops->session_etb(inst, fd);\n\telse if (fd->buffer_type == HFI_BUFFER_OUTPUT ||\n\t\t fd->buffer_type == HFI_BUFFER_OUTPUT2)\n\t\treturn ops->session_ftb(inst, fd);\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(hfi_session_process_buf);\n\nirqreturn_t hfi_isr_thread(int irq, void *dev_id)\n{\n\tstruct venus_core *core = dev_id;\n\n\treturn core->ops->isr_thread(core);\n}\n\nirqreturn_t hfi_isr(int irq, void *dev)\n{\n\tstruct venus_core *core = dev;\n\n\treturn core->ops->isr(core);\n}\n\nint hfi_create(struct venus_core *core, const struct hfi_core_ops *ops)\n{\n\tif (!ops)\n\t\treturn -EINVAL;\n\n\tatomic_set(&core->insts_count, 0);\n\tcore->core_ops = ops;\n\tcore->state = CORE_UNINIT;\n\tinit_completion(&core->done);\n\tpkt_set_version(core->res->hfi_version);\n\n\treturn venus_hfi_create(core);\n}\n\nvoid hfi_destroy(struct venus_core *core)\n{\n\tvenus_hfi_destroy(core);\n}\n\nvoid hfi_reinit(struct venus_core *core)\n{\n\tvenus_hfi_queues_reinit(core);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}