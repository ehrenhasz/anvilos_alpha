{
  "module_name": "hfi_venus.c",
  "hash_id": "6e7c0f456a59188cd114f8ee5a549ed79cda9e823bafbb89fa585832bf70b55f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/venus/hfi_venus.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#include \"core.h\"\n#include \"hfi_cmds.h\"\n#include \"hfi_msgs.h\"\n#include \"hfi_venus.h\"\n#include \"hfi_venus_io.h\"\n#include \"firmware.h\"\n\n#define HFI_MASK_QHDR_TX_TYPE\t\t0xff000000\n#define HFI_MASK_QHDR_RX_TYPE\t\t0x00ff0000\n#define HFI_MASK_QHDR_PRI_TYPE\t\t0x0000ff00\n#define HFI_MASK_QHDR_ID_TYPE\t\t0x000000ff\n\n#define HFI_HOST_TO_CTRL_CMD_Q\t\t0\n#define HFI_CTRL_TO_HOST_MSG_Q\t\t1\n#define HFI_CTRL_TO_HOST_DBG_Q\t\t2\n#define HFI_MASK_QHDR_STATUS\t\t0x000000ff\n\n#define IFACEQ_NUM\t\t\t3\n#define IFACEQ_CMD_IDX\t\t\t0\n#define IFACEQ_MSG_IDX\t\t\t1\n#define IFACEQ_DBG_IDX\t\t\t2\n#define IFACEQ_MAX_BUF_COUNT\t\t50\n#define IFACEQ_MAX_PARALLEL_CLNTS\t16\n#define IFACEQ_DFLT_QHDR\t\t0x01010000\n\n#define POLL_INTERVAL_US\t\t50\n\n#define IFACEQ_MAX_PKT_SIZE\t\t1024\n#define IFACEQ_MED_PKT_SIZE\t\t768\n#define IFACEQ_MIN_PKT_SIZE\t\t8\n#define IFACEQ_VAR_SMALL_PKT_SIZE\t100\n#define IFACEQ_VAR_LARGE_PKT_SIZE\t512\n#define IFACEQ_VAR_HUGE_PKT_SIZE\t(1024 * 12)\n\nstruct hfi_queue_table_header {\n\tu32 version;\n\tu32 size;\n\tu32 qhdr0_offset;\n\tu32 qhdr_size;\n\tu32 num_q;\n\tu32 num_active_q;\n};\n\nstruct hfi_queue_header {\n\tu32 status;\n\tu32 start_addr;\n\tu32 type;\n\tu32 q_size;\n\tu32 pkt_size;\n\tu32 pkt_drop_cnt;\n\tu32 rx_wm;\n\tu32 tx_wm;\n\tu32 rx_req;\n\tu32 tx_req;\n\tu32 rx_irq_status;\n\tu32 tx_irq_status;\n\tu32 read_idx;\n\tu32 write_idx;\n};\n\n#define IFACEQ_TABLE_SIZE\t\\\n\t(sizeof(struct hfi_queue_table_header) +\t\\\n\t sizeof(struct hfi_queue_header) * IFACEQ_NUM)\n\n#define IFACEQ_QUEUE_SIZE\t(IFACEQ_MAX_PKT_SIZE *\t\\\n\tIFACEQ_MAX_BUF_COUNT * IFACEQ_MAX_PARALLEL_CLNTS)\n\n#define IFACEQ_GET_QHDR_START_ADDR(ptr, i)\t\\\n\t(void *)(((ptr) + sizeof(struct hfi_queue_table_header)) +\t\\\n\t\t((i) * sizeof(struct hfi_queue_header)))\n\n#define QDSS_SIZE\t\tSZ_4K\n#define SFR_SIZE\t\tSZ_4K\n#define QUEUE_SIZE\t\t\\\n\t(IFACEQ_TABLE_SIZE + (IFACEQ_QUEUE_SIZE * IFACEQ_NUM))\n\n#define ALIGNED_QDSS_SIZE\tALIGN(QDSS_SIZE, SZ_4K)\n#define ALIGNED_SFR_SIZE\tALIGN(SFR_SIZE, SZ_4K)\n#define ALIGNED_QUEUE_SIZE\tALIGN(QUEUE_SIZE, SZ_4K)\n#define SHARED_QSIZE\t\tALIGN(ALIGNED_SFR_SIZE + ALIGNED_QUEUE_SIZE + \\\n\t\t\t\t      ALIGNED_QDSS_SIZE, SZ_1M)\n\nstruct mem_desc {\n\tdma_addr_t da;\t \n\tvoid *kva;\t \n\tu32 size;\n\tunsigned long attrs;\n};\n\nstruct iface_queue {\n\tstruct hfi_queue_header *qhdr;\n\tstruct mem_desc qmem;\n};\n\nenum venus_state {\n\tVENUS_STATE_DEINIT = 1,\n\tVENUS_STATE_INIT,\n};\n\nstruct venus_hfi_device {\n\tstruct venus_core *core;\n\tu32 irq_status;\n\tu32 last_packet_type;\n\tbool power_enabled;\n\tbool suspended;\n\tenum venus_state state;\n\t \n\tstruct mutex lock;\n\tstruct completion pwr_collapse_prep;\n\tstruct completion release_resource;\n\tstruct mem_desc ifaceq_table;\n\tstruct mem_desc sfr;\n\tstruct iface_queue queues[IFACEQ_NUM];\n\tu8 pkt_buf[IFACEQ_VAR_HUGE_PKT_SIZE];\n\tu8 dbg_buf[IFACEQ_VAR_HUGE_PKT_SIZE];\n};\n\nstatic bool venus_pkt_debug;\nint venus_fw_debug = HFI_DEBUG_MSG_ERROR | HFI_DEBUG_MSG_FATAL;\nstatic bool venus_fw_low_power_mode = true;\nstatic int venus_hw_rsp_timeout = 1000;\nstatic bool venus_fw_coverage;\n\nstatic void venus_set_state(struct venus_hfi_device *hdev,\n\t\t\t    enum venus_state state)\n{\n\tmutex_lock(&hdev->lock);\n\thdev->state = state;\n\tmutex_unlock(&hdev->lock);\n}\n\nstatic bool venus_is_valid_state(struct venus_hfi_device *hdev)\n{\n\treturn hdev->state != VENUS_STATE_DEINIT;\n}\n\nstatic void venus_dump_packet(struct venus_hfi_device *hdev, const void *packet)\n{\n\tsize_t pkt_size = *(u32 *)packet;\n\n\tif (!venus_pkt_debug)\n\t\treturn;\n\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 16, 1, packet,\n\t\t       pkt_size, true);\n}\n\nstatic int venus_write_queue(struct venus_hfi_device *hdev,\n\t\t\t     struct iface_queue *queue,\n\t\t\t     void *packet, u32 *rx_req)\n{\n\tstruct hfi_queue_header *qhdr;\n\tu32 dwords, new_wr_idx;\n\tu32 empty_space, rd_idx, wr_idx, qsize;\n\tu32 *wr_ptr;\n\n\tif (!queue->qmem.kva)\n\t\treturn -EINVAL;\n\n\tqhdr = queue->qhdr;\n\tif (!qhdr)\n\t\treturn -EINVAL;\n\n\tvenus_dump_packet(hdev, packet);\n\n\tdwords = (*(u32 *)packet) >> 2;\n\tif (!dwords)\n\t\treturn -EINVAL;\n\n\trd_idx = qhdr->read_idx;\n\twr_idx = qhdr->write_idx;\n\tqsize = qhdr->q_size;\n\t \n\trmb();\n\n\tif (wr_idx >= rd_idx)\n\t\tempty_space = qsize - (wr_idx - rd_idx);\n\telse\n\t\tempty_space = rd_idx - wr_idx;\n\n\tif (empty_space <= dwords) {\n\t\tqhdr->tx_req = 1;\n\t\t \n\t\twmb();\n\t\treturn -ENOSPC;\n\t}\n\n\tqhdr->tx_req = 0;\n\t \n\twmb();\n\n\tnew_wr_idx = wr_idx + dwords;\n\twr_ptr = (u32 *)(queue->qmem.kva + (wr_idx << 2));\n\n\tif (wr_ptr < (u32 *)queue->qmem.kva ||\n\t    wr_ptr > (u32 *)(queue->qmem.kva + queue->qmem.size - sizeof(*wr_ptr)))\n\t\treturn -EINVAL;\n\n\tif (new_wr_idx < qsize) {\n\t\tmemcpy(wr_ptr, packet, dwords << 2);\n\t} else {\n\t\tsize_t len;\n\n\t\tnew_wr_idx -= qsize;\n\t\tlen = (dwords - new_wr_idx) << 2;\n\t\tmemcpy(wr_ptr, packet, len);\n\t\tmemcpy(queue->qmem.kva, packet + len, new_wr_idx << 2);\n\t}\n\n\t \n\twmb();\n\n\tqhdr->write_idx = new_wr_idx;\n\t*rx_req = qhdr->rx_req ? 1 : 0;\n\n\t \n\tmb();\n\n\treturn 0;\n}\n\nstatic int venus_read_queue(struct venus_hfi_device *hdev,\n\t\t\t    struct iface_queue *queue, void *pkt, u32 *tx_req)\n{\n\tstruct hfi_queue_header *qhdr;\n\tu32 dwords, new_rd_idx;\n\tu32 rd_idx, wr_idx, type, qsize;\n\tu32 *rd_ptr;\n\tu32 recv_request = 0;\n\tint ret = 0;\n\n\tif (!queue->qmem.kva)\n\t\treturn -EINVAL;\n\n\tqhdr = queue->qhdr;\n\tif (!qhdr)\n\t\treturn -EINVAL;\n\n\ttype = qhdr->type;\n\trd_idx = qhdr->read_idx;\n\twr_idx = qhdr->write_idx;\n\tqsize = qhdr->q_size;\n\n\t \n\trmb();\n\n\t \n\tif (type & HFI_CTRL_TO_HOST_MSG_Q)\n\t\trecv_request = 1;\n\n\tif (rd_idx == wr_idx) {\n\t\tqhdr->rx_req = recv_request;\n\t\t*tx_req = 0;\n\t\t \n\t\twmb();\n\t\treturn -ENODATA;\n\t}\n\n\trd_ptr = (u32 *)(queue->qmem.kva + (rd_idx << 2));\n\n\tif (rd_ptr < (u32 *)queue->qmem.kva ||\n\t    rd_ptr > (u32 *)(queue->qmem.kva + queue->qmem.size - sizeof(*rd_ptr)))\n\t\treturn -EINVAL;\n\n\tdwords = *rd_ptr >> 2;\n\tif (!dwords)\n\t\treturn -EINVAL;\n\n\tnew_rd_idx = rd_idx + dwords;\n\tif (((dwords << 2) <= IFACEQ_VAR_HUGE_PKT_SIZE) && rd_idx <= qsize) {\n\t\tif (new_rd_idx < qsize) {\n\t\t\tmemcpy(pkt, rd_ptr, dwords << 2);\n\t\t} else {\n\t\t\tsize_t len;\n\n\t\t\tnew_rd_idx -= qsize;\n\t\t\tlen = (dwords - new_rd_idx) << 2;\n\t\t\tmemcpy(pkt, rd_ptr, len);\n\t\t\tmemcpy(pkt + len, queue->qmem.kva, new_rd_idx << 2);\n\t\t}\n\t} else {\n\t\t \n\t\tnew_rd_idx = qhdr->write_idx;\n\t\tret = -EBADMSG;\n\t}\n\n\t \n\trmb();\n\n\tqhdr->read_idx = new_rd_idx;\n\t \n\twmb();\n\n\trd_idx = qhdr->read_idx;\n\twr_idx = qhdr->write_idx;\n\t \n\trmb();\n\n\tif (rd_idx != wr_idx)\n\t\tqhdr->rx_req = 0;\n\telse\n\t\tqhdr->rx_req = recv_request;\n\n\t*tx_req = qhdr->tx_req ? 1 : 0;\n\n\t \n\tmb();\n\n\tvenus_dump_packet(hdev, pkt);\n\n\treturn ret;\n}\n\nstatic int venus_alloc(struct venus_hfi_device *hdev, struct mem_desc *desc,\n\t\t       u32 size)\n{\n\tstruct device *dev = hdev->core->dev;\n\n\tdesc->attrs = DMA_ATTR_WRITE_COMBINE;\n\tdesc->size = ALIGN(size, SZ_4K);\n\n\tdesc->kva = dma_alloc_attrs(dev, desc->size, &desc->da, GFP_KERNEL,\n\t\t\t\t    desc->attrs);\n\tif (!desc->kva)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void venus_free(struct venus_hfi_device *hdev, struct mem_desc *mem)\n{\n\tstruct device *dev = hdev->core->dev;\n\n\tdma_free_attrs(dev, mem->size, mem->kva, mem->da, mem->attrs);\n}\n\nstatic void venus_set_registers(struct venus_hfi_device *hdev)\n{\n\tconst struct venus_resources *res = hdev->core->res;\n\tconst struct reg_val *tbl = res->reg_tbl;\n\tunsigned int count = res->reg_tbl_size;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++)\n\t\twritel(tbl[i].value, hdev->core->base + tbl[i].reg);\n}\n\nstatic void venus_soft_int(struct venus_hfi_device *hdev)\n{\n\tvoid __iomem *cpu_ic_base = hdev->core->cpu_ic_base;\n\tu32 clear_bit;\n\n\tif (IS_V6(hdev->core))\n\t\tclear_bit = BIT(CPU_IC_SOFTINT_H2A_SHIFT_V6);\n\telse\n\t\tclear_bit = BIT(CPU_IC_SOFTINT_H2A_SHIFT);\n\n\twritel(clear_bit, cpu_ic_base + CPU_IC_SOFTINT);\n}\n\nstatic int venus_iface_cmdq_write_nolock(struct venus_hfi_device *hdev,\n\t\t\t\t\t void *pkt, bool sync)\n{\n\tstruct device *dev = hdev->core->dev;\n\tstruct hfi_pkt_hdr *cmd_packet;\n\tstruct iface_queue *queue;\n\tu32 rx_req;\n\tint ret;\n\n\tif (!venus_is_valid_state(hdev))\n\t\treturn -EINVAL;\n\n\tcmd_packet = (struct hfi_pkt_hdr *)pkt;\n\thdev->last_packet_type = cmd_packet->pkt_type;\n\n\tqueue = &hdev->queues[IFACEQ_CMD_IDX];\n\n\tret = venus_write_queue(hdev, queue, pkt, &rx_req);\n\tif (ret) {\n\t\tdev_err(dev, \"write to iface cmd queue failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (sync) {\n\t\t \n\t\tqueue = &hdev->queues[IFACEQ_MSG_IDX];\n\t\tqueue->qhdr->rx_req = 1;\n\t\t \n\t\twmb();\n\t}\n\n\tif (rx_req)\n\t\tvenus_soft_int(hdev);\n\n\treturn 0;\n}\n\nstatic int venus_iface_cmdq_write(struct venus_hfi_device *hdev, void *pkt, bool sync)\n{\n\tint ret;\n\n\tmutex_lock(&hdev->lock);\n\tret = venus_iface_cmdq_write_nolock(hdev, pkt, sync);\n\tmutex_unlock(&hdev->lock);\n\n\treturn ret;\n}\n\nstatic int venus_hfi_core_set_resource(struct venus_core *core, u32 id,\n\t\t\t\t       u32 size, u32 addr, void *cookie)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(core);\n\tstruct hfi_sys_set_resource_pkt *pkt;\n\tu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\n\tint ret;\n\n\tif (id == VIDC_RESOURCE_NONE)\n\t\treturn 0;\n\n\tpkt = (struct hfi_sys_set_resource_pkt *)packet;\n\n\tret = pkt_sys_set_resource(pkt, id, size, addr, cookie);\n\tif (ret)\n\t\treturn ret;\n\n\tret = venus_iface_cmdq_write(hdev, pkt, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int venus_boot_core(struct venus_hfi_device *hdev)\n{\n\tstruct device *dev = hdev->core->dev;\n\tstatic const unsigned int max_tries = 100;\n\tu32 ctrl_status = 0, mask_val = 0;\n\tunsigned int count = 0;\n\tvoid __iomem *cpu_cs_base = hdev->core->cpu_cs_base;\n\tvoid __iomem *wrapper_base = hdev->core->wrapper_base;\n\tint ret = 0;\n\n\tif (IS_IRIS2(hdev->core) || IS_IRIS2_1(hdev->core)) {\n\t\tmask_val = readl(wrapper_base + WRAPPER_INTR_MASK);\n\t\tmask_val &= ~(WRAPPER_INTR_MASK_A2HWD_BASK_V6 |\n\t\t\t      WRAPPER_INTR_MASK_A2HCPU_MASK);\n\t} else {\n\t\tmask_val = WRAPPER_INTR_MASK_A2HVCODEC_MASK;\n\t}\n\n\twritel(mask_val, wrapper_base + WRAPPER_INTR_MASK);\n\tif (IS_V1(hdev->core))\n\t\twritel(1, cpu_cs_base + CPU_CS_SCIACMDARG3);\n\n\twritel(BIT(VIDC_CTRL_INIT_CTRL_SHIFT), cpu_cs_base + VIDC_CTRL_INIT);\n\twhile (!ctrl_status && count < max_tries) {\n\t\tctrl_status = readl(cpu_cs_base + CPU_CS_SCIACMDARG0);\n\t\tif ((ctrl_status & CPU_CS_SCIACMDARG0_ERROR_STATUS_MASK) == 4) {\n\t\t\tdev_err(dev, \"invalid setting for UC_REGION\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(500, 1000);\n\t\tcount++;\n\t}\n\n\tif (count >= max_tries)\n\t\tret = -ETIMEDOUT;\n\n\tif (IS_IRIS2(hdev->core) || IS_IRIS2_1(hdev->core)) {\n\t\twritel(0x1, cpu_cs_base + CPU_CS_H2XSOFTINTEN_V6);\n\t\twritel(0x0, cpu_cs_base + CPU_CS_X2RPMH_V6);\n\t}\n\n\treturn ret;\n}\n\nstatic u32 venus_hwversion(struct venus_hfi_device *hdev)\n{\n\tstruct device *dev = hdev->core->dev;\n\tvoid __iomem *wrapper_base = hdev->core->wrapper_base;\n\tu32 ver;\n\tu32 major, minor, step;\n\n\tver = readl(wrapper_base + WRAPPER_HW_VERSION);\n\tmajor = ver & WRAPPER_HW_VERSION_MAJOR_VERSION_MASK;\n\tmajor = major >> WRAPPER_HW_VERSION_MAJOR_VERSION_SHIFT;\n\tminor = ver & WRAPPER_HW_VERSION_MINOR_VERSION_MASK;\n\tminor = minor >> WRAPPER_HW_VERSION_MINOR_VERSION_SHIFT;\n\tstep = ver & WRAPPER_HW_VERSION_STEP_VERSION_MASK;\n\n\tdev_dbg(dev, VDBGL \"venus hw version %x.%x.%x\\n\", major, minor, step);\n\n\treturn major;\n}\n\nstatic int venus_run(struct venus_hfi_device *hdev)\n{\n\tstruct device *dev = hdev->core->dev;\n\tvoid __iomem *cpu_cs_base = hdev->core->cpu_cs_base;\n\tint ret;\n\n\t \n\tvenus_set_registers(hdev);\n\n\twritel(hdev->ifaceq_table.da, cpu_cs_base + UC_REGION_ADDR);\n\twritel(SHARED_QSIZE, cpu_cs_base + UC_REGION_SIZE);\n\twritel(hdev->ifaceq_table.da, cpu_cs_base + CPU_CS_SCIACMDARG2);\n\twritel(0x01, cpu_cs_base + CPU_CS_SCIACMDARG1);\n\tif (hdev->sfr.da)\n\t\twritel(hdev->sfr.da, cpu_cs_base + SFR_ADDR);\n\n\tret = venus_boot_core(hdev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to reset venus core\\n\");\n\t\treturn ret;\n\t}\n\n\tvenus_hwversion(hdev);\n\n\treturn 0;\n}\n\nstatic int venus_halt_axi(struct venus_hfi_device *hdev)\n{\n\tvoid __iomem *wrapper_base = hdev->core->wrapper_base;\n\tvoid __iomem *vbif_base = hdev->core->vbif_base;\n\tvoid __iomem *cpu_cs_base = hdev->core->cpu_cs_base;\n\tvoid __iomem *aon_base = hdev->core->aon_base;\n\tstruct device *dev = hdev->core->dev;\n\tu32 val;\n\tu32 mask_val;\n\tint ret;\n\n\tif (IS_IRIS2(hdev->core) || IS_IRIS2_1(hdev->core)) {\n\t\twritel(0x3, cpu_cs_base + CPU_CS_X2RPMH_V6);\n\n\t\tif (IS_IRIS2_1(hdev->core))\n\t\t\tgoto skip_aon_mvp_noc;\n\n\t\twritel(0x1, aon_base + AON_WRAPPER_MVP_NOC_LPI_CONTROL);\n\t\tret = readl_poll_timeout(aon_base + AON_WRAPPER_MVP_NOC_LPI_STATUS,\n\t\t\t\t\t val,\n\t\t\t\t\t val & BIT(0),\n\t\t\t\t\t POLL_INTERVAL_US,\n\t\t\t\t\t VBIF_AXI_HALT_ACK_TIMEOUT_US);\n\t\tif (ret)\n\t\t\treturn -ETIMEDOUT;\n\nskip_aon_mvp_noc:\n\t\tmask_val = (BIT(2) | BIT(1) | BIT(0));\n\t\twritel(mask_val, wrapper_base + WRAPPER_DEBUG_BRIDGE_LPI_CONTROL_V6);\n\n\t\twritel(0x00, wrapper_base + WRAPPER_DEBUG_BRIDGE_LPI_CONTROL_V6);\n\t\tret = readl_poll_timeout(wrapper_base + WRAPPER_DEBUG_BRIDGE_LPI_STATUS_V6,\n\t\t\t\t\t val,\n\t\t\t\t\t val == 0,\n\t\t\t\t\t POLL_INTERVAL_US,\n\t\t\t\t\t VBIF_AXI_HALT_ACK_TIMEOUT_US);\n\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"DBLP Release: lpi_status %x\\n\", val);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (IS_V4(hdev->core)) {\n\t\tval = readl(wrapper_base + WRAPPER_CPU_AXI_HALT);\n\t\tval |= WRAPPER_CPU_AXI_HALT_HALT;\n\t\twritel(val, wrapper_base + WRAPPER_CPU_AXI_HALT);\n\n\t\tret = readl_poll_timeout(wrapper_base + WRAPPER_CPU_AXI_HALT_STATUS,\n\t\t\t\t\t val,\n\t\t\t\t\t val & WRAPPER_CPU_AXI_HALT_STATUS_IDLE,\n\t\t\t\t\t POLL_INTERVAL_US,\n\t\t\t\t\t VBIF_AXI_HALT_ACK_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"AXI bus port halt timeout\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tval = readl(vbif_base + VBIF_AXI_HALT_CTRL0);\n\tval |= VBIF_AXI_HALT_CTRL0_HALT_REQ;\n\twritel(val, vbif_base + VBIF_AXI_HALT_CTRL0);\n\n\t \n\tret = readl_poll_timeout(vbif_base + VBIF_AXI_HALT_CTRL1, val,\n\t\t\t\t val & VBIF_AXI_HALT_CTRL1_HALT_ACK,\n\t\t\t\t POLL_INTERVAL_US,\n\t\t\t\t VBIF_AXI_HALT_ACK_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(dev, \"AXI bus port halt timeout\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int venus_power_off(struct venus_hfi_device *hdev)\n{\n\tint ret;\n\n\tif (!hdev->power_enabled)\n\t\treturn 0;\n\n\tret = venus_set_hw_state_suspend(hdev->core);\n\tif (ret)\n\t\treturn ret;\n\n\tret = venus_halt_axi(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\thdev->power_enabled = false;\n\n\treturn 0;\n}\n\nstatic int venus_power_on(struct venus_hfi_device *hdev)\n{\n\tint ret;\n\n\tif (hdev->power_enabled)\n\t\treturn 0;\n\n\tret = venus_set_hw_state_resume(hdev->core);\n\tif (ret)\n\t\tgoto err;\n\n\tret = venus_run(hdev);\n\tif (ret)\n\t\tgoto err_suspend;\n\n\thdev->power_enabled = true;\n\n\treturn 0;\n\nerr_suspend:\n\tvenus_set_hw_state_suspend(hdev->core);\nerr:\n\thdev->power_enabled = false;\n\treturn ret;\n}\n\nstatic int venus_iface_msgq_read_nolock(struct venus_hfi_device *hdev,\n\t\t\t\t\tvoid *pkt)\n{\n\tstruct iface_queue *queue;\n\tu32 tx_req;\n\tint ret;\n\n\tif (!venus_is_valid_state(hdev))\n\t\treturn -EINVAL;\n\n\tqueue = &hdev->queues[IFACEQ_MSG_IDX];\n\n\tret = venus_read_queue(hdev, queue, pkt, &tx_req);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tx_req)\n\t\tvenus_soft_int(hdev);\n\n\treturn 0;\n}\n\nstatic int venus_iface_msgq_read(struct venus_hfi_device *hdev, void *pkt)\n{\n\tint ret;\n\n\tmutex_lock(&hdev->lock);\n\tret = venus_iface_msgq_read_nolock(hdev, pkt);\n\tmutex_unlock(&hdev->lock);\n\n\treturn ret;\n}\n\nstatic int venus_iface_dbgq_read_nolock(struct venus_hfi_device *hdev,\n\t\t\t\t\tvoid *pkt)\n{\n\tstruct iface_queue *queue;\n\tu32 tx_req;\n\tint ret;\n\n\tret = venus_is_valid_state(hdev);\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\tqueue = &hdev->queues[IFACEQ_DBG_IDX];\n\n\tret = venus_read_queue(hdev, queue, pkt, &tx_req);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tx_req)\n\t\tvenus_soft_int(hdev);\n\n\treturn 0;\n}\n\nstatic int venus_iface_dbgq_read(struct venus_hfi_device *hdev, void *pkt)\n{\n\tint ret;\n\n\tif (!pkt)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hdev->lock);\n\tret = venus_iface_dbgq_read_nolock(hdev, pkt);\n\tmutex_unlock(&hdev->lock);\n\n\treturn ret;\n}\n\nstatic void venus_set_qhdr_defaults(struct hfi_queue_header *qhdr)\n{\n\tqhdr->status = 1;\n\tqhdr->type = IFACEQ_DFLT_QHDR;\n\tqhdr->q_size = IFACEQ_QUEUE_SIZE / 4;\n\tqhdr->pkt_size = 0;\n\tqhdr->rx_wm = 1;\n\tqhdr->tx_wm = 1;\n\tqhdr->rx_req = 1;\n\tqhdr->tx_req = 0;\n\tqhdr->rx_irq_status = 0;\n\tqhdr->tx_irq_status = 0;\n\tqhdr->read_idx = 0;\n\tqhdr->write_idx = 0;\n}\n\nstatic void venus_interface_queues_release(struct venus_hfi_device *hdev)\n{\n\tmutex_lock(&hdev->lock);\n\n\tvenus_free(hdev, &hdev->ifaceq_table);\n\tvenus_free(hdev, &hdev->sfr);\n\n\tmemset(hdev->queues, 0, sizeof(hdev->queues));\n\tmemset(&hdev->ifaceq_table, 0, sizeof(hdev->ifaceq_table));\n\tmemset(&hdev->sfr, 0, sizeof(hdev->sfr));\n\n\tmutex_unlock(&hdev->lock);\n}\n\nstatic int venus_interface_queues_init(struct venus_hfi_device *hdev)\n{\n\tstruct hfi_queue_table_header *tbl_hdr;\n\tstruct iface_queue *queue;\n\tstruct hfi_sfr *sfr;\n\tstruct mem_desc desc = {0};\n\tunsigned int offset;\n\tunsigned int i;\n\tint ret;\n\n\tret = venus_alloc(hdev, &desc, ALIGNED_QUEUE_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\thdev->ifaceq_table = desc;\n\toffset = IFACEQ_TABLE_SIZE;\n\n\tfor (i = 0; i < IFACEQ_NUM; i++) {\n\t\tqueue = &hdev->queues[i];\n\t\tqueue->qmem.da = desc.da + offset;\n\t\tqueue->qmem.kva = desc.kva + offset;\n\t\tqueue->qmem.size = IFACEQ_QUEUE_SIZE;\n\t\toffset += queue->qmem.size;\n\t\tqueue->qhdr =\n\t\t\tIFACEQ_GET_QHDR_START_ADDR(hdev->ifaceq_table.kva, i);\n\n\t\tvenus_set_qhdr_defaults(queue->qhdr);\n\n\t\tqueue->qhdr->start_addr = queue->qmem.da;\n\n\t\tif (i == IFACEQ_CMD_IDX)\n\t\t\tqueue->qhdr->type |= HFI_HOST_TO_CTRL_CMD_Q;\n\t\telse if (i == IFACEQ_MSG_IDX)\n\t\t\tqueue->qhdr->type |= HFI_CTRL_TO_HOST_MSG_Q;\n\t\telse if (i == IFACEQ_DBG_IDX)\n\t\t\tqueue->qhdr->type |= HFI_CTRL_TO_HOST_DBG_Q;\n\t}\n\n\ttbl_hdr = hdev->ifaceq_table.kva;\n\ttbl_hdr->version = 0;\n\ttbl_hdr->size = IFACEQ_TABLE_SIZE;\n\ttbl_hdr->qhdr0_offset = sizeof(struct hfi_queue_table_header);\n\ttbl_hdr->qhdr_size = sizeof(struct hfi_queue_header);\n\ttbl_hdr->num_q = IFACEQ_NUM;\n\ttbl_hdr->num_active_q = IFACEQ_NUM;\n\n\t \n\tqueue = &hdev->queues[IFACEQ_DBG_IDX];\n\tqueue->qhdr->rx_req = 0;\n\n\tret = venus_alloc(hdev, &desc, ALIGNED_SFR_SIZE);\n\tif (ret) {\n\t\thdev->sfr.da = 0;\n\t} else {\n\t\thdev->sfr = desc;\n\t\tsfr = hdev->sfr.kva;\n\t\tsfr->buf_size = ALIGNED_SFR_SIZE;\n\t}\n\n\t \n\twmb();\n\n\treturn 0;\n}\n\nstatic int venus_sys_set_debug(struct venus_hfi_device *hdev, u32 debug)\n{\n\tstruct hfi_sys_set_property_pkt *pkt;\n\tu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\n\n\tpkt = (struct hfi_sys_set_property_pkt *)packet;\n\n\tpkt_sys_debug_config(pkt, HFI_DEBUG_MODE_QUEUE, debug);\n\n\treturn venus_iface_cmdq_write(hdev, pkt, false);\n}\n\nstatic int venus_sys_set_coverage(struct venus_hfi_device *hdev, u32 mode)\n{\n\tstruct hfi_sys_set_property_pkt *pkt;\n\tu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\n\n\tpkt = (struct hfi_sys_set_property_pkt *)packet;\n\n\tpkt_sys_coverage_config(pkt, mode);\n\n\treturn venus_iface_cmdq_write(hdev, pkt, false);\n}\n\nstatic int venus_sys_set_idle_message(struct venus_hfi_device *hdev,\n\t\t\t\t      bool enable)\n{\n\tstruct hfi_sys_set_property_pkt *pkt;\n\tu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\n\n\tif (!enable)\n\t\treturn 0;\n\n\tpkt = (struct hfi_sys_set_property_pkt *)packet;\n\n\tpkt_sys_idle_indicator(pkt, enable);\n\n\treturn venus_iface_cmdq_write(hdev, pkt, false);\n}\n\nstatic int venus_sys_set_power_control(struct venus_hfi_device *hdev,\n\t\t\t\t       bool enable)\n{\n\tstruct hfi_sys_set_property_pkt *pkt;\n\tu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\n\n\tpkt = (struct hfi_sys_set_property_pkt *)packet;\n\n\tpkt_sys_power_control(pkt, enable);\n\n\treturn venus_iface_cmdq_write(hdev, pkt, false);\n}\n\nstatic int venus_sys_set_ubwc_config(struct venus_hfi_device *hdev)\n{\n\tstruct hfi_sys_set_property_pkt *pkt;\n\tu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\n\tconst struct venus_resources *res = hdev->core->res;\n\tint ret;\n\n\tpkt = (struct hfi_sys_set_property_pkt *)packet;\n\n\tpkt_sys_ubwc_config(pkt, res->ubwc_conf);\n\n\tret = venus_iface_cmdq_write(hdev, pkt, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int venus_get_queue_size(struct venus_hfi_device *hdev,\n\t\t\t\tunsigned int index)\n{\n\tstruct hfi_queue_header *qhdr;\n\n\tif (index >= IFACEQ_NUM)\n\t\treturn -EINVAL;\n\n\tqhdr = hdev->queues[index].qhdr;\n\tif (!qhdr)\n\t\treturn -EINVAL;\n\n\treturn abs(qhdr->read_idx - qhdr->write_idx);\n}\n\nstatic int venus_sys_set_default_properties(struct venus_hfi_device *hdev)\n{\n\tstruct device *dev = hdev->core->dev;\n\tconst struct venus_resources *res = hdev->core->res;\n\tint ret;\n\n\tret = venus_sys_set_debug(hdev, venus_fw_debug);\n\tif (ret)\n\t\tdev_warn(dev, \"setting fw debug msg ON failed (%d)\\n\", ret);\n\n\t \n\tif (IS_V1(hdev->core)) {\n\t\tret = venus_sys_set_idle_message(hdev, false);\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"setting idle response ON failed (%d)\\n\", ret);\n\t}\n\n\tret = venus_sys_set_power_control(hdev, venus_fw_low_power_mode);\n\tif (ret)\n\t\tdev_warn(dev, \"setting hw power collapse ON failed (%d)\\n\",\n\t\t\t ret);\n\n\t \n\tif (res->ubwc_conf) {\n\t\tret = venus_sys_set_ubwc_config(hdev);\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"setting ubwc config failed (%d)\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int venus_session_cmd(struct venus_inst *inst, u32 pkt_type, bool sync)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\tstruct hfi_session_pkt pkt;\n\n\tpkt_session_cmd(&pkt, pkt_type, inst);\n\n\treturn venus_iface_cmdq_write(hdev, &pkt, sync);\n}\n\nstatic void venus_flush_debug_queue(struct venus_hfi_device *hdev)\n{\n\tstruct device *dev = hdev->core->dev;\n\tvoid *packet = hdev->dbg_buf;\n\n\twhile (!venus_iface_dbgq_read(hdev, packet)) {\n\t\tstruct hfi_msg_sys_coverage_pkt *pkt = packet;\n\n\t\tif (pkt->hdr.pkt_type != HFI_MSG_SYS_COV) {\n\t\t\tstruct hfi_msg_sys_debug_pkt *pkt = packet;\n\n\t\t\tdev_dbg(dev, VDBGFW \"%s\", pkt->msg_data);\n\t\t}\n\t}\n}\n\nstatic int venus_prepare_power_collapse(struct venus_hfi_device *hdev,\n\t\t\t\t\tbool wait)\n{\n\tunsigned long timeout = msecs_to_jiffies(venus_hw_rsp_timeout);\n\tstruct hfi_sys_pc_prep_pkt pkt;\n\tint ret;\n\n\tinit_completion(&hdev->pwr_collapse_prep);\n\n\tpkt_sys_pc_prep(&pkt);\n\n\tret = venus_iface_cmdq_write(hdev, &pkt, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!wait)\n\t\treturn 0;\n\n\tret = wait_for_completion_timeout(&hdev->pwr_collapse_prep, timeout);\n\tif (!ret) {\n\t\tvenus_flush_debug_queue(hdev);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int venus_are_queues_empty(struct venus_hfi_device *hdev)\n{\n\tint ret1, ret2;\n\n\tret1 = venus_get_queue_size(hdev, IFACEQ_MSG_IDX);\n\tif (ret1 < 0)\n\t\treturn ret1;\n\n\tret2 = venus_get_queue_size(hdev, IFACEQ_CMD_IDX);\n\tif (ret2 < 0)\n\t\treturn ret2;\n\n\tif (!ret1 && !ret2)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void venus_sfr_print(struct venus_hfi_device *hdev)\n{\n\tstruct device *dev = hdev->core->dev;\n\tstruct hfi_sfr *sfr = hdev->sfr.kva;\n\tvoid *p;\n\n\tif (!sfr)\n\t\treturn;\n\n\tp = memchr(sfr->data, '\\0', sfr->buf_size);\n\t \n\tif (!p)\n\t\tsfr->data[sfr->buf_size - 1] = '\\0';\n\n\tdev_err_ratelimited(dev, \"SFR message from FW: %s\\n\", sfr->data);\n}\n\nstatic void venus_process_msg_sys_error(struct venus_hfi_device *hdev,\n\t\t\t\t\tvoid *packet)\n{\n\tstruct hfi_msg_event_notify_pkt *event_pkt = packet;\n\n\tif (event_pkt->event_id != HFI_EVENT_SYS_ERROR)\n\t\treturn;\n\n\tvenus_set_state(hdev, VENUS_STATE_DEINIT);\n\n\tvenus_sfr_print(hdev);\n}\n\nstatic irqreturn_t venus_isr_thread(struct venus_core *core)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(core);\n\tconst struct venus_resources *res;\n\tvoid *pkt;\n\tu32 msg_ret;\n\n\tif (!hdev)\n\t\treturn IRQ_NONE;\n\n\tres = hdev->core->res;\n\tpkt = hdev->pkt_buf;\n\n\n\twhile (!venus_iface_msgq_read(hdev, pkt)) {\n\t\tmsg_ret = hfi_process_msg_packet(core, pkt);\n\t\tswitch (msg_ret) {\n\t\tcase HFI_MSG_EVENT_NOTIFY:\n\t\t\tvenus_process_msg_sys_error(hdev, pkt);\n\t\t\tbreak;\n\t\tcase HFI_MSG_SYS_INIT:\n\t\t\tvenus_hfi_core_set_resource(core, res->vmem_id,\n\t\t\t\t\t\t    res->vmem_size,\n\t\t\t\t\t\t    res->vmem_addr,\n\t\t\t\t\t\t    hdev);\n\t\t\tbreak;\n\t\tcase HFI_MSG_SYS_RELEASE_RESOURCE:\n\t\t\tcomplete(&hdev->release_resource);\n\t\t\tbreak;\n\t\tcase HFI_MSG_SYS_PC_PREP:\n\t\t\tcomplete(&hdev->pwr_collapse_prep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvenus_flush_debug_queue(hdev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t venus_isr(struct venus_core *core)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(core);\n\tu32 status;\n\tvoid __iomem *cpu_cs_base;\n\tvoid __iomem *wrapper_base;\n\n\tif (!hdev)\n\t\treturn IRQ_NONE;\n\n\tcpu_cs_base = hdev->core->cpu_cs_base;\n\twrapper_base = hdev->core->wrapper_base;\n\n\tstatus = readl(wrapper_base + WRAPPER_INTR_STATUS);\n\tif (IS_IRIS2(core) || IS_IRIS2_1(core)) {\n\t\tif (status & WRAPPER_INTR_STATUS_A2H_MASK ||\n\t\t    status & WRAPPER_INTR_STATUS_A2HWD_MASK_V6 ||\n\t\t    status & CPU_CS_SCIACMDARG0_INIT_IDLE_MSG_MASK)\n\t\t\thdev->irq_status = status;\n\t} else {\n\t\tif (status & WRAPPER_INTR_STATUS_A2H_MASK ||\n\t\t    status & WRAPPER_INTR_STATUS_A2HWD_MASK ||\n\t\t    status & CPU_CS_SCIACMDARG0_INIT_IDLE_MSG_MASK)\n\t\t\thdev->irq_status = status;\n\t}\n\twritel(1, cpu_cs_base + CPU_CS_A2HSOFTINTCLR);\n\tif (!(IS_IRIS2(core) || IS_IRIS2_1(core)))\n\t\twritel(status, wrapper_base + WRAPPER_INTR_CLEAR);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic int venus_core_init(struct venus_core *core)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(core);\n\tstruct device *dev = core->dev;\n\tstruct hfi_sys_get_property_pkt version_pkt;\n\tstruct hfi_sys_init_pkt pkt;\n\tint ret;\n\n\tpkt_sys_init(&pkt, HFI_VIDEO_ARCH_OX);\n\n\tvenus_set_state(hdev, VENUS_STATE_INIT);\n\n\tret = venus_iface_cmdq_write(hdev, &pkt, false);\n\tif (ret)\n\t\treturn ret;\n\n\tpkt_sys_image_version(&version_pkt);\n\n\tret = venus_iface_cmdq_write(hdev, &version_pkt, false);\n\tif (ret)\n\t\tdev_warn(dev, \"failed to send image version pkt to fw\\n\");\n\n\tret = venus_sys_set_default_properties(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int venus_core_deinit(struct venus_core *core)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(core);\n\n\tvenus_set_state(hdev, VENUS_STATE_DEINIT);\n\thdev->suspended = true;\n\thdev->power_enabled = false;\n\n\treturn 0;\n}\n\nstatic int venus_core_ping(struct venus_core *core, u32 cookie)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(core);\n\tstruct hfi_sys_ping_pkt pkt;\n\n\tpkt_sys_ping(&pkt, cookie);\n\n\treturn venus_iface_cmdq_write(hdev, &pkt, false);\n}\n\nstatic int venus_core_trigger_ssr(struct venus_core *core, u32 trigger_type)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(core);\n\tstruct hfi_sys_test_ssr_pkt pkt;\n\tint ret;\n\n\tret = pkt_sys_ssr_cmd(&pkt, trigger_type);\n\tif (ret)\n\t\treturn ret;\n\n\treturn venus_iface_cmdq_write(hdev, &pkt, false);\n}\n\nstatic int venus_session_init(struct venus_inst *inst, u32 session_type,\n\t\t\t      u32 codec)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\tstruct hfi_session_init_pkt pkt;\n\tint ret;\n\n\tret = venus_sys_set_debug(hdev, venus_fw_debug);\n\tif (ret)\n\t\tgoto err;\n\n\tret = pkt_session_init(&pkt, inst, session_type, codec);\n\tif (ret)\n\t\tgoto err;\n\n\tret = venus_iface_cmdq_write(hdev, &pkt, true);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tvenus_flush_debug_queue(hdev);\n\treturn ret;\n}\n\nstatic int venus_session_end(struct venus_inst *inst)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\tstruct device *dev = hdev->core->dev;\n\n\tif (venus_fw_coverage) {\n\t\tif (venus_sys_set_coverage(hdev, venus_fw_coverage))\n\t\t\tdev_warn(dev, \"fw coverage msg ON failed\\n\");\n\t}\n\n\treturn venus_session_cmd(inst, HFI_CMD_SYS_SESSION_END, true);\n}\n\nstatic int venus_session_abort(struct venus_inst *inst)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\n\tvenus_flush_debug_queue(hdev);\n\n\treturn venus_session_cmd(inst, HFI_CMD_SYS_SESSION_ABORT, true);\n}\n\nstatic int venus_session_flush(struct venus_inst *inst, u32 flush_mode)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\tstruct hfi_session_flush_pkt pkt;\n\tint ret;\n\n\tret = pkt_session_flush(&pkt, inst, flush_mode);\n\tif (ret)\n\t\treturn ret;\n\n\treturn venus_iface_cmdq_write(hdev, &pkt, true);\n}\n\nstatic int venus_session_start(struct venus_inst *inst)\n{\n\treturn venus_session_cmd(inst, HFI_CMD_SESSION_START, true);\n}\n\nstatic int venus_session_stop(struct venus_inst *inst)\n{\n\treturn venus_session_cmd(inst, HFI_CMD_SESSION_STOP, true);\n}\n\nstatic int venus_session_continue(struct venus_inst *inst)\n{\n\treturn venus_session_cmd(inst, HFI_CMD_SESSION_CONTINUE, false);\n}\n\nstatic int venus_session_etb(struct venus_inst *inst,\n\t\t\t     struct hfi_frame_data *in_frame)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\tu32 session_type = inst->session_type;\n\tint ret;\n\n\tif (session_type == VIDC_SESSION_TYPE_DEC) {\n\t\tstruct hfi_session_empty_buffer_compressed_pkt pkt;\n\n\t\tret = pkt_session_etb_decoder(&pkt, inst, in_frame);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = venus_iface_cmdq_write(hdev, &pkt, false);\n\t} else if (session_type == VIDC_SESSION_TYPE_ENC) {\n\t\tstruct hfi_session_empty_buffer_uncompressed_plane0_pkt pkt;\n\n\t\tret = pkt_session_etb_encoder(&pkt, inst, in_frame);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = venus_iface_cmdq_write(hdev, &pkt, false);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int venus_session_ftb(struct venus_inst *inst,\n\t\t\t     struct hfi_frame_data *out_frame)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\tstruct hfi_session_fill_buffer_pkt pkt;\n\tint ret;\n\n\tret = pkt_session_ftb(&pkt, inst, out_frame);\n\tif (ret)\n\t\treturn ret;\n\n\treturn venus_iface_cmdq_write(hdev, &pkt, false);\n}\n\nstatic int venus_session_set_buffers(struct venus_inst *inst,\n\t\t\t\t     struct hfi_buffer_desc *bd)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\tstruct hfi_session_set_buffers_pkt *pkt;\n\tu8 packet[IFACEQ_VAR_LARGE_PKT_SIZE];\n\tint ret;\n\n\tif (bd->buffer_type == HFI_BUFFER_INPUT)\n\t\treturn 0;\n\n\tpkt = (struct hfi_session_set_buffers_pkt *)packet;\n\n\tret = pkt_session_set_buffers(pkt, inst, bd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn venus_iface_cmdq_write(hdev, pkt, false);\n}\n\nstatic int venus_session_unset_buffers(struct venus_inst *inst,\n\t\t\t\t       struct hfi_buffer_desc *bd)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\tstruct hfi_session_release_buffer_pkt *pkt;\n\tu8 packet[IFACEQ_VAR_LARGE_PKT_SIZE];\n\tint ret;\n\n\tif (bd->buffer_type == HFI_BUFFER_INPUT)\n\t\treturn 0;\n\n\tpkt = (struct hfi_session_release_buffer_pkt *)packet;\n\n\tret = pkt_session_unset_buffers(pkt, inst, bd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn venus_iface_cmdq_write(hdev, pkt, true);\n}\n\nstatic int venus_session_load_res(struct venus_inst *inst)\n{\n\treturn venus_session_cmd(inst, HFI_CMD_SESSION_LOAD_RESOURCES, true);\n}\n\nstatic int venus_session_release_res(struct venus_inst *inst)\n{\n\treturn venus_session_cmd(inst, HFI_CMD_SESSION_RELEASE_RESOURCES, true);\n}\n\nstatic int venus_session_parse_seq_hdr(struct venus_inst *inst, u32 seq_hdr,\n\t\t\t\t       u32 seq_hdr_len)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\tstruct hfi_session_parse_sequence_header_pkt *pkt;\n\tu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\n\tint ret;\n\n\tpkt = (struct hfi_session_parse_sequence_header_pkt *)packet;\n\n\tret = pkt_session_parse_seq_header(pkt, inst, seq_hdr, seq_hdr_len);\n\tif (ret)\n\t\treturn ret;\n\n\tret = venus_iface_cmdq_write(hdev, pkt, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int venus_session_get_seq_hdr(struct venus_inst *inst, u32 seq_hdr,\n\t\t\t\t     u32 seq_hdr_len)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\tstruct hfi_session_get_sequence_header_pkt *pkt;\n\tu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\n\tint ret;\n\n\tpkt = (struct hfi_session_get_sequence_header_pkt *)packet;\n\n\tret = pkt_session_get_seq_hdr(pkt, inst, seq_hdr, seq_hdr_len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn venus_iface_cmdq_write(hdev, pkt, false);\n}\n\nstatic int venus_session_set_property(struct venus_inst *inst, u32 ptype,\n\t\t\t\t      void *pdata)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\tstruct hfi_session_set_property_pkt *pkt;\n\tu8 packet[IFACEQ_VAR_LARGE_PKT_SIZE];\n\tint ret;\n\n\tpkt = (struct hfi_session_set_property_pkt *)packet;\n\n\tret = pkt_session_set_property(pkt, inst, ptype, pdata);\n\tif (ret == -ENOTSUPP)\n\t\treturn 0;\n\tif (ret)\n\t\treturn ret;\n\n\treturn venus_iface_cmdq_write(hdev, pkt, false);\n}\n\nstatic int venus_session_get_property(struct venus_inst *inst, u32 ptype)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\n\tstruct hfi_session_get_property_pkt pkt;\n\tint ret;\n\n\tret = pkt_session_get_property(&pkt, inst, ptype);\n\tif (ret)\n\t\treturn ret;\n\n\treturn venus_iface_cmdq_write(hdev, &pkt, true);\n}\n\nstatic int venus_resume(struct venus_core *core)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(core);\n\tint ret = 0;\n\n\tmutex_lock(&hdev->lock);\n\n\tif (!hdev->suspended)\n\t\tgoto unlock;\n\n\tret = venus_power_on(hdev);\n\nunlock:\n\tif (!ret)\n\t\thdev->suspended = false;\n\n\tmutex_unlock(&hdev->lock);\n\n\treturn ret;\n}\n\nstatic int venus_suspend_1xx(struct venus_core *core)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(core);\n\tstruct device *dev = core->dev;\n\tvoid __iomem *cpu_cs_base = hdev->core->cpu_cs_base;\n\tu32 ctrl_status;\n\tint ret;\n\n\tif (!hdev->power_enabled || hdev->suspended)\n\t\treturn 0;\n\n\tmutex_lock(&hdev->lock);\n\tret = venus_is_valid_state(hdev);\n\tmutex_unlock(&hdev->lock);\n\n\tif (!ret) {\n\t\tdev_err(dev, \"bad state, cannot suspend\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = venus_prepare_power_collapse(hdev, true);\n\tif (ret) {\n\t\tdev_err(dev, \"prepare for power collapse fail (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&hdev->lock);\n\n\tif (hdev->last_packet_type != HFI_CMD_SYS_PC_PREP) {\n\t\tmutex_unlock(&hdev->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tret = venus_are_queues_empty(hdev);\n\tif (ret < 0 || !ret) {\n\t\tmutex_unlock(&hdev->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tctrl_status = readl(cpu_cs_base + CPU_CS_SCIACMDARG0);\n\tif (!(ctrl_status & CPU_CS_SCIACMDARG0_PC_READY)) {\n\t\tmutex_unlock(&hdev->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tret = venus_power_off(hdev);\n\tif (ret) {\n\t\tmutex_unlock(&hdev->lock);\n\t\treturn ret;\n\t}\n\n\thdev->suspended = true;\n\n\tmutex_unlock(&hdev->lock);\n\n\treturn 0;\n}\n\nstatic bool venus_cpu_and_video_core_idle(struct venus_hfi_device *hdev)\n{\n\tvoid __iomem *wrapper_base = hdev->core->wrapper_base;\n\tvoid __iomem *wrapper_tz_base = hdev->core->wrapper_tz_base;\n\tvoid __iomem *cpu_cs_base = hdev->core->cpu_cs_base;\n\tu32 ctrl_status, cpu_status;\n\n\tif (IS_IRIS2(hdev->core) || IS_IRIS2_1(hdev->core))\n\t\tcpu_status = readl(wrapper_tz_base + WRAPPER_TZ_CPU_STATUS_V6);\n\telse\n\t\tcpu_status = readl(wrapper_base + WRAPPER_CPU_STATUS);\n\tctrl_status = readl(cpu_cs_base + CPU_CS_SCIACMDARG0);\n\n\tif (cpu_status & WRAPPER_CPU_STATUS_WFI &&\n\t    ctrl_status & CPU_CS_SCIACMDARG0_INIT_IDLE_MSG_MASK)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool venus_cpu_idle_and_pc_ready(struct venus_hfi_device *hdev)\n{\n\tvoid __iomem *wrapper_base = hdev->core->wrapper_base;\n\tvoid __iomem *wrapper_tz_base = hdev->core->wrapper_tz_base;\n\tvoid __iomem *cpu_cs_base = hdev->core->cpu_cs_base;\n\tu32 ctrl_status, cpu_status;\n\n\tif (IS_IRIS2(hdev->core) || IS_IRIS2_1(hdev->core))\n\t\tcpu_status = readl(wrapper_tz_base + WRAPPER_TZ_CPU_STATUS_V6);\n\telse\n\t\tcpu_status = readl(wrapper_base + WRAPPER_CPU_STATUS);\n\tctrl_status = readl(cpu_cs_base + CPU_CS_SCIACMDARG0);\n\n\tif (cpu_status & WRAPPER_CPU_STATUS_WFI &&\n\t    ctrl_status & CPU_CS_SCIACMDARG0_PC_READY)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int venus_suspend_3xx(struct venus_core *core)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(core);\n\tstruct device *dev = core->dev;\n\tvoid __iomem *cpu_cs_base = hdev->core->cpu_cs_base;\n\tu32 ctrl_status;\n\tbool val;\n\tint ret;\n\n\tif (!hdev->power_enabled || hdev->suspended)\n\t\treturn 0;\n\n\tmutex_lock(&hdev->lock);\n\tret = venus_is_valid_state(hdev);\n\tmutex_unlock(&hdev->lock);\n\n\tif (!ret) {\n\t\tdev_err(dev, \"bad state, cannot suspend\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctrl_status = readl(cpu_cs_base + CPU_CS_SCIACMDARG0);\n\tif (ctrl_status & CPU_CS_SCIACMDARG0_PC_READY)\n\t\tgoto power_off;\n\n\t \n\tret = readx_poll_timeout(venus_cpu_and_video_core_idle, hdev, val, val,\n\t\t\t\t 1500, 100 * 1500);\n\tif (ret) {\n\t\tdev_err(dev, \"wait for cpu and video core idle fail (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = venus_prepare_power_collapse(hdev, false);\n\tif (ret) {\n\t\tdev_err(dev, \"prepare for power collapse fail (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = readx_poll_timeout(venus_cpu_idle_and_pc_ready, hdev, val, val,\n\t\t\t\t 1500, 100 * 1500);\n\tif (ret)\n\t\treturn ret;\n\npower_off:\n\tmutex_lock(&hdev->lock);\n\n\tret = venus_power_off(hdev);\n\tif (ret) {\n\t\tdev_err(dev, \"venus_power_off (%d)\\n\", ret);\n\t\tmutex_unlock(&hdev->lock);\n\t\treturn ret;\n\t}\n\n\thdev->suspended = true;\n\n\tmutex_unlock(&hdev->lock);\n\n\treturn 0;\n}\n\nstatic int venus_suspend(struct venus_core *core)\n{\n\tif (IS_V3(core) || IS_V4(core) || IS_V6(core))\n\t\treturn venus_suspend_3xx(core);\n\n\treturn venus_suspend_1xx(core);\n}\n\nstatic const struct hfi_ops venus_hfi_ops = {\n\t.core_init\t\t\t= venus_core_init,\n\t.core_deinit\t\t\t= venus_core_deinit,\n\t.core_ping\t\t\t= venus_core_ping,\n\t.core_trigger_ssr\t\t= venus_core_trigger_ssr,\n\n\t.session_init\t\t\t= venus_session_init,\n\t.session_end\t\t\t= venus_session_end,\n\t.session_abort\t\t\t= venus_session_abort,\n\t.session_flush\t\t\t= venus_session_flush,\n\t.session_start\t\t\t= venus_session_start,\n\t.session_stop\t\t\t= venus_session_stop,\n\t.session_continue\t\t= venus_session_continue,\n\t.session_etb\t\t\t= venus_session_etb,\n\t.session_ftb\t\t\t= venus_session_ftb,\n\t.session_set_buffers\t\t= venus_session_set_buffers,\n\t.session_unset_buffers\t\t= venus_session_unset_buffers,\n\t.session_load_res\t\t= venus_session_load_res,\n\t.session_release_res\t\t= venus_session_release_res,\n\t.session_parse_seq_hdr\t\t= venus_session_parse_seq_hdr,\n\t.session_get_seq_hdr\t\t= venus_session_get_seq_hdr,\n\t.session_set_property\t\t= venus_session_set_property,\n\t.session_get_property\t\t= venus_session_get_property,\n\n\t.resume\t\t\t\t= venus_resume,\n\t.suspend\t\t\t= venus_suspend,\n\n\t.isr\t\t\t\t= venus_isr,\n\t.isr_thread\t\t\t= venus_isr_thread,\n};\n\nvoid venus_hfi_destroy(struct venus_core *core)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(core);\n\n\tcore->priv = NULL;\n\tvenus_interface_queues_release(hdev);\n\tmutex_destroy(&hdev->lock);\n\tkfree(hdev);\n\tcore->ops = NULL;\n}\n\nint venus_hfi_create(struct venus_core *core)\n{\n\tstruct venus_hfi_device *hdev;\n\tint ret;\n\n\thdev = kzalloc(sizeof(*hdev), GFP_KERNEL);\n\tif (!hdev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&hdev->lock);\n\n\thdev->core = core;\n\thdev->suspended = true;\n\tcore->priv = hdev;\n\tcore->ops = &venus_hfi_ops;\n\n\tret = venus_interface_queues_init(hdev);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\treturn 0;\n\nerr_kfree:\n\tkfree(hdev);\n\tcore->priv = NULL;\n\tcore->ops = NULL;\n\treturn ret;\n}\n\nvoid venus_hfi_queues_reinit(struct venus_core *core)\n{\n\tstruct venus_hfi_device *hdev = to_hfi_priv(core);\n\tstruct hfi_queue_table_header *tbl_hdr;\n\tstruct iface_queue *queue;\n\tstruct hfi_sfr *sfr;\n\tunsigned int i;\n\n\tmutex_lock(&hdev->lock);\n\n\tfor (i = 0; i < IFACEQ_NUM; i++) {\n\t\tqueue = &hdev->queues[i];\n\t\tqueue->qhdr =\n\t\t\tIFACEQ_GET_QHDR_START_ADDR(hdev->ifaceq_table.kva, i);\n\n\t\tvenus_set_qhdr_defaults(queue->qhdr);\n\n\t\tqueue->qhdr->start_addr = queue->qmem.da;\n\n\t\tif (i == IFACEQ_CMD_IDX)\n\t\t\tqueue->qhdr->type |= HFI_HOST_TO_CTRL_CMD_Q;\n\t\telse if (i == IFACEQ_MSG_IDX)\n\t\t\tqueue->qhdr->type |= HFI_CTRL_TO_HOST_MSG_Q;\n\t\telse if (i == IFACEQ_DBG_IDX)\n\t\t\tqueue->qhdr->type |= HFI_CTRL_TO_HOST_DBG_Q;\n\t}\n\n\ttbl_hdr = hdev->ifaceq_table.kva;\n\ttbl_hdr->version = 0;\n\ttbl_hdr->size = IFACEQ_TABLE_SIZE;\n\ttbl_hdr->qhdr0_offset = sizeof(struct hfi_queue_table_header);\n\ttbl_hdr->qhdr_size = sizeof(struct hfi_queue_header);\n\ttbl_hdr->num_q = IFACEQ_NUM;\n\ttbl_hdr->num_active_q = IFACEQ_NUM;\n\n\t \n\tqueue = &hdev->queues[IFACEQ_DBG_IDX];\n\tqueue->qhdr->rx_req = 0;\n\n\tsfr = hdev->sfr.kva;\n\tsfr->buf_size = ALIGNED_SFR_SIZE;\n\n\t \n\twmb();\n\n\tmutex_unlock(&hdev->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}