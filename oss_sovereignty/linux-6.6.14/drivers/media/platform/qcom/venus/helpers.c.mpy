{
  "module_name": "helpers.c",
  "hash_id": "5c0900aa0c4a312055e8586d589804aa19c37813f9ecc01f5d913686d1e8f585",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/venus/helpers.c",
  "human_readable_source": "\n \n#include <linux/idr.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/v4l2-mem2mem.h>\n#include <asm/div64.h>\n\n#include \"core.h\"\n#include \"helpers.h\"\n#include \"hfi_helper.h\"\n#include \"pm_helpers.h\"\n#include \"hfi_platform.h\"\n#include \"hfi_parser.h\"\n\n#define NUM_MBS_720P\t(((ALIGN(1280, 16)) >> 4) * ((ALIGN(736, 16)) >> 4))\n#define NUM_MBS_4K\t(((ALIGN(4096, 16)) >> 4) * ((ALIGN(2304, 16)) >> 4))\n\nenum dpb_buf_owner {\n\tDRIVER,\n\tFIRMWARE,\n};\n\nstruct intbuf {\n\tstruct list_head list;\n\tu32 type;\n\tsize_t size;\n\tvoid *va;\n\tdma_addr_t da;\n\tunsigned long attrs;\n\tenum dpb_buf_owner owned_by;\n\tu32 dpb_out_tag;\n};\n\nbool venus_helper_check_codec(struct venus_inst *inst, u32 v4l2_pixfmt)\n{\n\tstruct venus_core *core = inst->core;\n\tu32 session_type = inst->session_type;\n\tu32 codec;\n\n\tswitch (v4l2_pixfmt) {\n\tcase V4L2_PIX_FMT_H264:\n\t\tcodec = HFI_VIDEO_CODEC_H264;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_H263:\n\t\tcodec = HFI_VIDEO_CODEC_H263;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG1:\n\t\tcodec = HFI_VIDEO_CODEC_MPEG1;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG2:\n\t\tcodec = HFI_VIDEO_CODEC_MPEG2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG4:\n\t\tcodec = HFI_VIDEO_CODEC_MPEG4;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VC1_ANNEX_G:\n\tcase V4L2_PIX_FMT_VC1_ANNEX_L:\n\t\tcodec = HFI_VIDEO_CODEC_VC1;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VP8:\n\t\tcodec = HFI_VIDEO_CODEC_VP8;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_VP9:\n\t\tcodec = HFI_VIDEO_CODEC_VP9;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_XVID:\n\t\tcodec = HFI_VIDEO_CODEC_DIVX;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_HEVC:\n\t\tcodec = HFI_VIDEO_CODEC_HEVC;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (session_type == VIDC_SESSION_TYPE_ENC && core->enc_codecs & codec)\n\t\treturn true;\n\n\tif (session_type == VIDC_SESSION_TYPE_DEC && core->dec_codecs & codec)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(venus_helper_check_codec);\n\nstatic void free_dpb_buf(struct venus_inst *inst, struct intbuf *buf)\n{\n\tida_free(&inst->dpb_ids, buf->dpb_out_tag);\n\n\tlist_del_init(&buf->list);\n\tdma_free_attrs(inst->core->dev, buf->size, buf->va, buf->da,\n\t\t       buf->attrs);\n\tkfree(buf);\n}\n\nint venus_helper_queue_dpb_bufs(struct venus_inst *inst)\n{\n\tstruct intbuf *buf, *next;\n\tunsigned int dpb_size = 0;\n\tint ret = 0;\n\n\tif (inst->dpb_buftype == HFI_BUFFER_OUTPUT)\n\t\tdpb_size = inst->output_buf_size;\n\telse if (inst->dpb_buftype == HFI_BUFFER_OUTPUT2)\n\t\tdpb_size = inst->output2_buf_size;\n\n\tlist_for_each_entry_safe(buf, next, &inst->dpbbufs, list) {\n\t\tstruct hfi_frame_data fdata;\n\n\t\tmemset(&fdata, 0, sizeof(fdata));\n\t\tfdata.alloc_len = buf->size;\n\t\tfdata.device_addr = buf->da;\n\t\tfdata.buffer_type = buf->type;\n\n\t\tif (buf->owned_by == FIRMWARE)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (dpb_size > buf->size) {\n\t\t\tfree_dpb_buf(inst, buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfdata.clnt_data = buf->dpb_out_tag;\n\n\t\tret = hfi_session_process_buf(inst, &fdata);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tbuf->owned_by = FIRMWARE;\n\t}\n\nfail:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(venus_helper_queue_dpb_bufs);\n\nint venus_helper_free_dpb_bufs(struct venus_inst *inst)\n{\n\tstruct intbuf *buf, *n;\n\n\tlist_for_each_entry_safe(buf, n, &inst->dpbbufs, list) {\n\t\tif (buf->owned_by == FIRMWARE)\n\t\t\tcontinue;\n\t\tfree_dpb_buf(inst, buf);\n\t}\n\n\tif (list_empty(&inst->dpbbufs))\n\t\tINIT_LIST_HEAD(&inst->dpbbufs);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(venus_helper_free_dpb_bufs);\n\nint venus_helper_alloc_dpb_bufs(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct device *dev = core->dev;\n\tenum hfi_version ver = core->res->hfi_version;\n\tstruct hfi_buffer_requirements bufreq;\n\tu32 buftype = inst->dpb_buftype;\n\tunsigned int dpb_size = 0;\n\tstruct intbuf *buf;\n\tunsigned int i;\n\tu32 count;\n\tint ret;\n\tint id;\n\n\t \n\tif (!inst->dpb_fmt)\n\t\treturn 0;\n\n\tif (inst->dpb_buftype == HFI_BUFFER_OUTPUT)\n\t\tdpb_size = inst->output_buf_size;\n\telse if (inst->dpb_buftype == HFI_BUFFER_OUTPUT2)\n\t\tdpb_size = inst->output2_buf_size;\n\n\tif (!dpb_size)\n\t\treturn 0;\n\n\tret = venus_helper_get_bufreq(inst, buftype, &bufreq);\n\tif (ret)\n\t\treturn ret;\n\n\tcount = hfi_bufreq_get_count_min(&bufreq, ver);\n\n\tfor (i = 0; i < count; i++) {\n\t\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tbuf->type = buftype;\n\t\tbuf->size = dpb_size;\n\t\tbuf->attrs = DMA_ATTR_WRITE_COMBINE |\n\t\t\t     DMA_ATTR_NO_KERNEL_MAPPING;\n\t\tbuf->va = dma_alloc_attrs(dev, buf->size, &buf->da, GFP_KERNEL,\n\t\t\t\t\t  buf->attrs);\n\t\tif (!buf->va) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tbuf->owned_by = DRIVER;\n\n\t\tid = ida_alloc_min(&inst->dpb_ids, VB2_MAX_FRAME, GFP_KERNEL);\n\t\tif (id < 0) {\n\t\t\tret = id;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tbuf->dpb_out_tag = id;\n\n\t\tlist_add_tail(&buf->list, &inst->dpbbufs);\n\t}\n\n\treturn 0;\n\nfail:\n\tkfree(buf);\n\tvenus_helper_free_dpb_bufs(inst);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(venus_helper_alloc_dpb_bufs);\n\nstatic int intbufs_set_buffer(struct venus_inst *inst, u32 type)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct device *dev = core->dev;\n\tstruct hfi_buffer_requirements bufreq;\n\tstruct hfi_buffer_desc bd;\n\tstruct intbuf *buf;\n\tunsigned int i;\n\tint ret;\n\n\tret = venus_helper_get_bufreq(inst, type, &bufreq);\n\tif (ret)\n\t\treturn 0;\n\n\tif (!bufreq.size)\n\t\treturn 0;\n\n\tfor (i = 0; i < bufreq.count_actual; i++) {\n\t\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tbuf->type = bufreq.type;\n\t\tbuf->size = bufreq.size;\n\t\tbuf->attrs = DMA_ATTR_WRITE_COMBINE |\n\t\t\t     DMA_ATTR_NO_KERNEL_MAPPING;\n\t\tbuf->va = dma_alloc_attrs(dev, buf->size, &buf->da, GFP_KERNEL,\n\t\t\t\t\t  buf->attrs);\n\t\tif (!buf->va) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tmemset(&bd, 0, sizeof(bd));\n\t\tbd.buffer_size = buf->size;\n\t\tbd.buffer_type = buf->type;\n\t\tbd.num_buffers = 1;\n\t\tbd.device_addr = buf->da;\n\n\t\tret = hfi_session_set_buffers(inst, &bd);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"set session buffers failed\\n\");\n\t\t\tgoto dma_free;\n\t\t}\n\n\t\tlist_add_tail(&buf->list, &inst->internalbufs);\n\t}\n\n\treturn 0;\n\ndma_free:\n\tdma_free_attrs(dev, buf->size, buf->va, buf->da, buf->attrs);\nfail:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int intbufs_unset_buffers(struct venus_inst *inst)\n{\n\tstruct hfi_buffer_desc bd = {0};\n\tstruct intbuf *buf, *n;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(buf, n, &inst->internalbufs, list) {\n\t\tbd.buffer_size = buf->size;\n\t\tbd.buffer_type = buf->type;\n\t\tbd.num_buffers = 1;\n\t\tbd.device_addr = buf->da;\n\t\tbd.response_required = true;\n\n\t\tret = hfi_session_unset_buffers(inst, &bd);\n\n\t\tlist_del_init(&buf->list);\n\t\tdma_free_attrs(inst->core->dev, buf->size, buf->va, buf->da,\n\t\t\t       buf->attrs);\n\t\tkfree(buf);\n\t}\n\n\treturn ret;\n}\n\nstatic const unsigned int intbuf_types_1xx[] = {\n\tHFI_BUFFER_INTERNAL_SCRATCH(HFI_VERSION_1XX),\n\tHFI_BUFFER_INTERNAL_SCRATCH_1(HFI_VERSION_1XX),\n\tHFI_BUFFER_INTERNAL_SCRATCH_2(HFI_VERSION_1XX),\n\tHFI_BUFFER_INTERNAL_PERSIST,\n\tHFI_BUFFER_INTERNAL_PERSIST_1,\n};\n\nstatic const unsigned int intbuf_types_4xx[] = {\n\tHFI_BUFFER_INTERNAL_SCRATCH(HFI_VERSION_4XX),\n\tHFI_BUFFER_INTERNAL_SCRATCH_1(HFI_VERSION_4XX),\n\tHFI_BUFFER_INTERNAL_SCRATCH_2(HFI_VERSION_4XX),\n\tHFI_BUFFER_INTERNAL_PERSIST,\n\tHFI_BUFFER_INTERNAL_PERSIST_1,\n};\n\nstatic const unsigned int intbuf_types_6xx[] = {\n\tHFI_BUFFER_INTERNAL_SCRATCH(HFI_VERSION_6XX),\n\tHFI_BUFFER_INTERNAL_SCRATCH_1(HFI_VERSION_6XX),\n\tHFI_BUFFER_INTERNAL_SCRATCH_2(HFI_VERSION_6XX),\n\tHFI_BUFFER_INTERNAL_PERSIST,\n\tHFI_BUFFER_INTERNAL_PERSIST_1,\n};\n\nint venus_helper_intbufs_alloc(struct venus_inst *inst)\n{\n\tconst unsigned int *intbuf;\n\tsize_t arr_sz, i;\n\tint ret;\n\n\tif (IS_V6(inst->core)) {\n\t\tarr_sz = ARRAY_SIZE(intbuf_types_6xx);\n\t\tintbuf = intbuf_types_6xx;\n\t} else if (IS_V4(inst->core)) {\n\t\tarr_sz = ARRAY_SIZE(intbuf_types_4xx);\n\t\tintbuf = intbuf_types_4xx;\n\t} else {\n\t\tarr_sz = ARRAY_SIZE(intbuf_types_1xx);\n\t\tintbuf = intbuf_types_1xx;\n\t}\n\n\tfor (i = 0; i < arr_sz; i++) {\n\t\tret = intbufs_set_buffer(inst, intbuf[i]);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tintbufs_unset_buffers(inst);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(venus_helper_intbufs_alloc);\n\nint venus_helper_intbufs_free(struct venus_inst *inst)\n{\n\treturn intbufs_unset_buffers(inst);\n}\nEXPORT_SYMBOL_GPL(venus_helper_intbufs_free);\n\nint venus_helper_intbufs_realloc(struct venus_inst *inst)\n{\n\tenum hfi_version ver = inst->core->res->hfi_version;\n\tstruct hfi_buffer_desc bd;\n\tstruct intbuf *buf, *n;\n\tint ret;\n\n\tlist_for_each_entry_safe(buf, n, &inst->internalbufs, list) {\n\t\tif (buf->type == HFI_BUFFER_INTERNAL_PERSIST ||\n\t\t    buf->type == HFI_BUFFER_INTERNAL_PERSIST_1)\n\t\t\tcontinue;\n\n\t\tmemset(&bd, 0, sizeof(bd));\n\t\tbd.buffer_size = buf->size;\n\t\tbd.buffer_type = buf->type;\n\t\tbd.num_buffers = 1;\n\t\tbd.device_addr = buf->da;\n\t\tbd.response_required = true;\n\n\t\tret = hfi_session_unset_buffers(inst, &bd);\n\n\t\tdma_free_attrs(inst->core->dev, buf->size, buf->va, buf->da,\n\t\t\t       buf->attrs);\n\n\t\tlist_del_init(&buf->list);\n\t\tkfree(buf);\n\t}\n\n\tret = intbufs_set_buffer(inst, HFI_BUFFER_INTERNAL_SCRATCH(ver));\n\tif (ret)\n\t\tgoto err;\n\n\tret = intbufs_set_buffer(inst, HFI_BUFFER_INTERNAL_SCRATCH_1(ver));\n\tif (ret)\n\t\tgoto err;\n\n\tret = intbufs_set_buffer(inst, HFI_BUFFER_INTERNAL_SCRATCH_2(ver));\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(venus_helper_intbufs_realloc);\n\nstatic void fill_buffer_desc(const struct venus_buffer *buf,\n\t\t\t     struct hfi_buffer_desc *bd, bool response)\n{\n\tmemset(bd, 0, sizeof(*bd));\n\tbd->buffer_type = HFI_BUFFER_OUTPUT;\n\tbd->buffer_size = buf->size;\n\tbd->num_buffers = 1;\n\tbd->device_addr = buf->dma_addr;\n\tbd->response_required = response;\n}\n\nstatic void return_buf_error(struct venus_inst *inst,\n\t\t\t     struct vb2_v4l2_buffer *vbuf)\n{\n\tstruct v4l2_m2m_ctx *m2m_ctx = inst->m2m_ctx;\n\n\tif (vbuf->vb2_buf.type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tv4l2_m2m_src_buf_remove_by_buf(m2m_ctx, vbuf);\n\telse\n\t\tv4l2_m2m_dst_buf_remove_by_buf(m2m_ctx, vbuf);\n\n\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n}\n\nstatic void\nput_ts_metadata(struct venus_inst *inst, struct vb2_v4l2_buffer *vbuf)\n{\n\tstruct vb2_buffer *vb = &vbuf->vb2_buf;\n\tunsigned int i;\n\tint slot = -1;\n\tu64 ts_us = vb->timestamp;\n\n\tfor (i = 0; i < ARRAY_SIZE(inst->tss); i++) {\n\t\tif (!inst->tss[i].used) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (slot == -1) {\n\t\tdev_dbg(inst->core->dev, VDBGL \"no free slot\\n\");\n\t\treturn;\n\t}\n\n\tdo_div(ts_us, NSEC_PER_USEC);\n\n\tinst->tss[slot].used = true;\n\tinst->tss[slot].flags = vbuf->flags;\n\tinst->tss[slot].tc = vbuf->timecode;\n\tinst->tss[slot].ts_us = ts_us;\n\tinst->tss[slot].ts_ns = vb->timestamp;\n}\n\nvoid venus_helper_get_ts_metadata(struct venus_inst *inst, u64 timestamp_us,\n\t\t\t\t  struct vb2_v4l2_buffer *vbuf)\n{\n\tstruct vb2_buffer *vb = &vbuf->vb2_buf;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(inst->tss); ++i) {\n\t\tif (!inst->tss[i].used)\n\t\t\tcontinue;\n\n\t\tif (inst->tss[i].ts_us != timestamp_us)\n\t\t\tcontinue;\n\n\t\tinst->tss[i].used = false;\n\t\tvbuf->flags |= inst->tss[i].flags;\n\t\tvbuf->timecode = inst->tss[i].tc;\n\t\tvb->timestamp = inst->tss[i].ts_ns;\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(venus_helper_get_ts_metadata);\n\nstatic int\nsession_process_buf(struct venus_inst *inst, struct vb2_v4l2_buffer *vbuf)\n{\n\tstruct venus_buffer *buf = to_venus_buffer(vbuf);\n\tstruct vb2_buffer *vb = &vbuf->vb2_buf;\n\tunsigned int type = vb->type;\n\tstruct hfi_frame_data fdata;\n\n\tmemset(&fdata, 0, sizeof(fdata));\n\tfdata.alloc_len = buf->size;\n\tfdata.device_addr = buf->dma_addr;\n\tfdata.timestamp = vb->timestamp;\n\tdo_div(fdata.timestamp, NSEC_PER_USEC);\n\tfdata.flags = 0;\n\tfdata.clnt_data = vbuf->vb2_buf.index;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tfdata.buffer_type = HFI_BUFFER_INPUT;\n\t\tfdata.filled_len = vb2_get_plane_payload(vb, 0);\n\t\tfdata.offset = vb->planes[0].data_offset;\n\n\t\tif (vbuf->flags & V4L2_BUF_FLAG_LAST || !fdata.filled_len)\n\t\t\tfdata.flags |= HFI_BUFFERFLAG_EOS;\n\n\t\tif (inst->session_type == VIDC_SESSION_TYPE_DEC)\n\t\t\tput_ts_metadata(inst, vbuf);\n\n\t\tvenus_pm_load_scale(inst);\n\t} else if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tif (inst->session_type == VIDC_SESSION_TYPE_ENC)\n\t\t\tfdata.buffer_type = HFI_BUFFER_OUTPUT;\n\t\telse\n\t\t\tfdata.buffer_type = inst->opb_buftype;\n\t\tfdata.filled_len = 0;\n\t\tfdata.offset = 0;\n\t}\n\n\treturn hfi_session_process_buf(inst, &fdata);\n}\n\nstatic bool is_dynamic_bufmode(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct hfi_plat_caps *caps;\n\n\t \n\tif (IS_V4(core) || IS_V6(core))\n\t\treturn true;\n\n\tcaps = venus_caps_by_codec(core, inst->hfi_codec, inst->session_type);\n\tif (!caps)\n\t\treturn false;\n\n\treturn caps->cap_bufs_mode_dynamic;\n}\n\nint venus_helper_unregister_bufs(struct venus_inst *inst)\n{\n\tstruct venus_buffer *buf, *n;\n\tstruct hfi_buffer_desc bd;\n\tint ret = 0;\n\n\tif (is_dynamic_bufmode(inst))\n\t\treturn 0;\n\n\tlist_for_each_entry_safe(buf, n, &inst->registeredbufs, reg_list) {\n\t\tfill_buffer_desc(buf, &bd, true);\n\t\tret = hfi_session_unset_buffers(inst, &bd);\n\t\tlist_del_init(&buf->reg_list);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(venus_helper_unregister_bufs);\n\nstatic int session_register_bufs(struct venus_inst *inst)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct device *dev = core->dev;\n\tstruct hfi_buffer_desc bd;\n\tstruct venus_buffer *buf;\n\tint ret = 0;\n\n\tif (is_dynamic_bufmode(inst))\n\t\treturn 0;\n\n\tlist_for_each_entry(buf, &inst->registeredbufs, reg_list) {\n\t\tfill_buffer_desc(buf, &bd, false);\n\t\tret = hfi_session_set_buffers(inst, &bd);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s: set buffer failed\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic u32 to_hfi_raw_fmt(u32 v4l2_fmt)\n{\n\tswitch (v4l2_fmt) {\n\tcase V4L2_PIX_FMT_NV12:\n\t\treturn HFI_COLOR_FORMAT_NV12;\n\tcase V4L2_PIX_FMT_NV21:\n\t\treturn HFI_COLOR_FORMAT_NV21;\n\tcase V4L2_PIX_FMT_QC08C:\n\t\treturn HFI_COLOR_FORMAT_NV12_UBWC;\n\tcase V4L2_PIX_FMT_QC10C:\n\t\treturn HFI_COLOR_FORMAT_YUV420_TP10_UBWC;\n\tcase V4L2_PIX_FMT_P010:\n\t\treturn HFI_COLOR_FORMAT_P010;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int platform_get_bufreq(struct venus_inst *inst, u32 buftype,\n\t\t\t       struct hfi_buffer_requirements *req)\n{\n\tenum hfi_version version = inst->core->res->hfi_version;\n\tconst struct hfi_platform *hfi_plat;\n\tstruct hfi_plat_buffers_params params;\n\tbool is_dec = inst->session_type == VIDC_SESSION_TYPE_DEC;\n\tstruct venc_controls *enc_ctr = &inst->controls.enc;\n\n\thfi_plat = hfi_platform_get(version);\n\n\tif (!hfi_plat || !hfi_plat->bufreq)\n\t\treturn -EINVAL;\n\n\tparams.version = version;\n\tparams.num_vpp_pipes = inst->core->res->num_vpp_pipes;\n\n\tif (is_dec) {\n\t\tparams.width = inst->width;\n\t\tparams.height = inst->height;\n\t\tparams.out_width = inst->out_width;\n\t\tparams.out_height = inst->out_height;\n\t\tparams.codec = inst->fmt_out->pixfmt;\n\t\tparams.hfi_color_fmt = to_hfi_raw_fmt(inst->fmt_cap->pixfmt);\n\t\tparams.dec.max_mbs_per_frame = mbs_per_frame_max(inst);\n\t\tparams.dec.buffer_size_limit = 0;\n\t\tparams.dec.is_secondary_output =\n\t\t\tinst->opb_buftype == HFI_BUFFER_OUTPUT2;\n\t\tif (params.dec.is_secondary_output)\n\t\t\tparams.hfi_dpb_color_fmt = inst->dpb_fmt;\n\t\tparams.dec.is_interlaced =\n\t\t\tinst->pic_struct != HFI_INTERLACE_FRAME_PROGRESSIVE;\n\t} else {\n\t\tparams.width = inst->out_width;\n\t\tparams.height = inst->out_height;\n\t\tparams.codec = inst->fmt_cap->pixfmt;\n\t\tparams.hfi_color_fmt = to_hfi_raw_fmt(inst->fmt_out->pixfmt);\n\t\tparams.enc.work_mode = VIDC_WORK_MODE_2;\n\t\tparams.enc.rc_type = HFI_RATE_CONTROL_OFF;\n\t\tif (enc_ctr->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CQ)\n\t\t\tparams.enc.rc_type = HFI_RATE_CONTROL_CQ;\n\t\tparams.enc.num_b_frames = enc_ctr->num_b_frames;\n\t\tparams.enc.is_tenbit = inst->bit_depth == VIDC_BITDEPTH_10;\n\t}\n\n\treturn hfi_plat->bufreq(&params, inst->session_type, buftype, req);\n}\n\nint venus_helper_get_bufreq(struct venus_inst *inst, u32 type,\n\t\t\t    struct hfi_buffer_requirements *req)\n{\n\tu32 ptype = HFI_PROPERTY_CONFIG_BUFFER_REQUIREMENTS;\n\tenum hfi_version ver = inst->core->res->hfi_version;\n\tunion hfi_get_property hprop;\n\tunsigned int i;\n\tint ret;\n\n\tmemset(req, 0, sizeof(*req));\n\n\tif (type == HFI_BUFFER_OUTPUT || type == HFI_BUFFER_OUTPUT2)\n\t\thfi_bufreq_set_count_min(req, ver, inst->fw_min_cnt);\n\n\tret = platform_get_bufreq(inst, type, req);\n\tif (!ret) {\n\t\tif (type == HFI_BUFFER_OUTPUT || type == HFI_BUFFER_OUTPUT2)\n\t\t\tinst->fw_min_cnt = hfi_bufreq_get_count_min(req, ver);\n\t\treturn 0;\n\t}\n\n\tret = hfi_session_get_property(inst, ptype, &hprop);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EINVAL;\n\n\tfor (i = 0; i < HFI_BUFFER_TYPE_MAX; i++) {\n\t\tif (hprop.bufreq[i].type != type)\n\t\t\tcontinue;\n\n\t\tmemcpy(req, &hprop.bufreq[i], sizeof(*req));\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(venus_helper_get_bufreq);\n\nstruct id_mapping {\n\tu32 hfi_id;\n\tu32 v4l2_id;\n};\n\nstatic const struct id_mapping mpeg4_profiles[] = {\n\t{ HFI_MPEG4_PROFILE_SIMPLE, V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE },\n\t{ HFI_MPEG4_PROFILE_ADVANCEDSIMPLE, V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_SIMPLE },\n};\n\nstatic const struct id_mapping mpeg4_levels[] = {\n\t{ HFI_MPEG4_LEVEL_0, V4L2_MPEG_VIDEO_MPEG4_LEVEL_0 },\n\t{ HFI_MPEG4_LEVEL_0b, V4L2_MPEG_VIDEO_MPEG4_LEVEL_0B },\n\t{ HFI_MPEG4_LEVEL_1, V4L2_MPEG_VIDEO_MPEG4_LEVEL_1 },\n\t{ HFI_MPEG4_LEVEL_2, V4L2_MPEG_VIDEO_MPEG4_LEVEL_2 },\n\t{ HFI_MPEG4_LEVEL_3, V4L2_MPEG_VIDEO_MPEG4_LEVEL_3 },\n\t{ HFI_MPEG4_LEVEL_4, V4L2_MPEG_VIDEO_MPEG4_LEVEL_4 },\n\t{ HFI_MPEG4_LEVEL_5, V4L2_MPEG_VIDEO_MPEG4_LEVEL_5 },\n};\n\nstatic const struct id_mapping mpeg2_profiles[] = {\n\t{ HFI_MPEG2_PROFILE_SIMPLE, V4L2_MPEG_VIDEO_MPEG2_PROFILE_SIMPLE },\n\t{ HFI_MPEG2_PROFILE_MAIN, V4L2_MPEG_VIDEO_MPEG2_PROFILE_MAIN },\n\t{ HFI_MPEG2_PROFILE_SNR, V4L2_MPEG_VIDEO_MPEG2_PROFILE_SNR_SCALABLE },\n\t{ HFI_MPEG2_PROFILE_SPATIAL, V4L2_MPEG_VIDEO_MPEG2_PROFILE_SPATIALLY_SCALABLE },\n\t{ HFI_MPEG2_PROFILE_HIGH, V4L2_MPEG_VIDEO_MPEG2_PROFILE_HIGH },\n};\n\nstatic const struct id_mapping mpeg2_levels[] = {\n\t{ HFI_MPEG2_LEVEL_LL, V4L2_MPEG_VIDEO_MPEG2_LEVEL_LOW },\n\t{ HFI_MPEG2_LEVEL_ML, V4L2_MPEG_VIDEO_MPEG2_LEVEL_MAIN },\n\t{ HFI_MPEG2_LEVEL_H14, V4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH_1440 },\n\t{ HFI_MPEG2_LEVEL_HL, V4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH },\n};\n\nstatic const struct id_mapping h264_profiles[] = {\n\t{ HFI_H264_PROFILE_BASELINE, V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE },\n\t{ HFI_H264_PROFILE_MAIN, V4L2_MPEG_VIDEO_H264_PROFILE_MAIN },\n\t{ HFI_H264_PROFILE_HIGH, V4L2_MPEG_VIDEO_H264_PROFILE_HIGH },\n\t{ HFI_H264_PROFILE_STEREO_HIGH, V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH },\n\t{ HFI_H264_PROFILE_MULTIVIEW_HIGH, V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH },\n\t{ HFI_H264_PROFILE_CONSTRAINED_BASE, V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE },\n\t{ HFI_H264_PROFILE_CONSTRAINED_HIGH, V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_HIGH },\n};\n\nstatic const struct id_mapping h264_levels[] = {\n\t{ HFI_H264_LEVEL_1, V4L2_MPEG_VIDEO_H264_LEVEL_1_0 },\n\t{ HFI_H264_LEVEL_1b, V4L2_MPEG_VIDEO_H264_LEVEL_1B },\n\t{ HFI_H264_LEVEL_11, V4L2_MPEG_VIDEO_H264_LEVEL_1_1 },\n\t{ HFI_H264_LEVEL_12, V4L2_MPEG_VIDEO_H264_LEVEL_1_2 },\n\t{ HFI_H264_LEVEL_13, V4L2_MPEG_VIDEO_H264_LEVEL_1_3 },\n\t{ HFI_H264_LEVEL_2, V4L2_MPEG_VIDEO_H264_LEVEL_2_0 },\n\t{ HFI_H264_LEVEL_21, V4L2_MPEG_VIDEO_H264_LEVEL_2_1 },\n\t{ HFI_H264_LEVEL_22, V4L2_MPEG_VIDEO_H264_LEVEL_2_2 },\n\t{ HFI_H264_LEVEL_3, V4L2_MPEG_VIDEO_H264_LEVEL_3_0 },\n\t{ HFI_H264_LEVEL_31, V4L2_MPEG_VIDEO_H264_LEVEL_3_1 },\n\t{ HFI_H264_LEVEL_32, V4L2_MPEG_VIDEO_H264_LEVEL_3_2 },\n\t{ HFI_H264_LEVEL_4, V4L2_MPEG_VIDEO_H264_LEVEL_4_0 },\n\t{ HFI_H264_LEVEL_41, V4L2_MPEG_VIDEO_H264_LEVEL_4_1 },\n\t{ HFI_H264_LEVEL_42, V4L2_MPEG_VIDEO_H264_LEVEL_4_2 },\n\t{ HFI_H264_LEVEL_5, V4L2_MPEG_VIDEO_H264_LEVEL_5_0 },\n\t{ HFI_H264_LEVEL_51, V4L2_MPEG_VIDEO_H264_LEVEL_5_1 },\n\t{ HFI_H264_LEVEL_52, V4L2_MPEG_VIDEO_H264_LEVEL_5_1 },\n};\n\nstatic const struct id_mapping hevc_profiles[] = {\n\t{ HFI_HEVC_PROFILE_MAIN, V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN },\n\t{ HFI_HEVC_PROFILE_MAIN_STILL_PIC, V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE },\n\t{ HFI_HEVC_PROFILE_MAIN10, V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10 },\n};\n\nstatic const struct id_mapping hevc_levels[] = {\n\t{ HFI_HEVC_LEVEL_1, V4L2_MPEG_VIDEO_HEVC_LEVEL_1 },\n\t{ HFI_HEVC_LEVEL_2, V4L2_MPEG_VIDEO_HEVC_LEVEL_2 },\n\t{ HFI_HEVC_LEVEL_21, V4L2_MPEG_VIDEO_HEVC_LEVEL_2_1 },\n\t{ HFI_HEVC_LEVEL_3, V4L2_MPEG_VIDEO_HEVC_LEVEL_3 },\n\t{ HFI_HEVC_LEVEL_31, V4L2_MPEG_VIDEO_HEVC_LEVEL_3_1 },\n\t{ HFI_HEVC_LEVEL_4, V4L2_MPEG_VIDEO_HEVC_LEVEL_4 },\n\t{ HFI_HEVC_LEVEL_41, V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1 },\n\t{ HFI_HEVC_LEVEL_5, V4L2_MPEG_VIDEO_HEVC_LEVEL_5 },\n\t{ HFI_HEVC_LEVEL_51, V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1 },\n\t{ HFI_HEVC_LEVEL_52, V4L2_MPEG_VIDEO_HEVC_LEVEL_5_2 },\n\t{ HFI_HEVC_LEVEL_6, V4L2_MPEG_VIDEO_HEVC_LEVEL_6 },\n\t{ HFI_HEVC_LEVEL_61, V4L2_MPEG_VIDEO_HEVC_LEVEL_6_1 },\n\t{ HFI_HEVC_LEVEL_62, V4L2_MPEG_VIDEO_HEVC_LEVEL_6_2 },\n};\n\nstatic const struct id_mapping vp8_profiles[] = {\n\t{ HFI_VPX_PROFILE_VERSION_0, V4L2_MPEG_VIDEO_VP8_PROFILE_0 },\n\t{ HFI_VPX_PROFILE_VERSION_1, V4L2_MPEG_VIDEO_VP8_PROFILE_1 },\n\t{ HFI_VPX_PROFILE_VERSION_2, V4L2_MPEG_VIDEO_VP8_PROFILE_2 },\n\t{ HFI_VPX_PROFILE_VERSION_3, V4L2_MPEG_VIDEO_VP8_PROFILE_3 },\n};\n\nstatic const struct id_mapping vp9_profiles[] = {\n\t{ HFI_VP9_PROFILE_P0, V4L2_MPEG_VIDEO_VP9_PROFILE_0 },\n\t{ HFI_VP9_PROFILE_P2_10B, V4L2_MPEG_VIDEO_VP9_PROFILE_2 },\n};\n\nstatic const struct id_mapping vp9_levels[] = {\n\t{ HFI_VP9_LEVEL_1, V4L2_MPEG_VIDEO_VP9_LEVEL_1_0 },\n\t{ HFI_VP9_LEVEL_11, V4L2_MPEG_VIDEO_VP9_LEVEL_1_1 },\n\t{ HFI_VP9_LEVEL_2, V4L2_MPEG_VIDEO_VP9_LEVEL_2_0},\n\t{ HFI_VP9_LEVEL_21, V4L2_MPEG_VIDEO_VP9_LEVEL_2_1 },\n\t{ HFI_VP9_LEVEL_3, V4L2_MPEG_VIDEO_VP9_LEVEL_3_0},\n\t{ HFI_VP9_LEVEL_31, V4L2_MPEG_VIDEO_VP9_LEVEL_3_1 },\n\t{ HFI_VP9_LEVEL_4, V4L2_MPEG_VIDEO_VP9_LEVEL_4_0 },\n\t{ HFI_VP9_LEVEL_41, V4L2_MPEG_VIDEO_VP9_LEVEL_4_1 },\n\t{ HFI_VP9_LEVEL_5, V4L2_MPEG_VIDEO_VP9_LEVEL_5_0 },\n\t{ HFI_VP9_LEVEL_51, V4L2_MPEG_VIDEO_VP9_LEVEL_5_1 },\n\t{ HFI_VP9_LEVEL_6, V4L2_MPEG_VIDEO_VP9_LEVEL_6_0 },\n\t{ HFI_VP9_LEVEL_61, V4L2_MPEG_VIDEO_VP9_LEVEL_6_1 },\n};\n\nstatic u32 find_v4l2_id(u32 hfi_id, const struct id_mapping *array, unsigned int array_sz)\n{\n\tunsigned int i;\n\n\tif (!array || !array_sz)\n\t\treturn 0;\n\n\tfor (i = 0; i < array_sz; i++)\n\t\tif (hfi_id == array[i].hfi_id)\n\t\t\treturn array[i].v4l2_id;\n\n\treturn 0;\n}\n\nstatic u32 find_hfi_id(u32 v4l2_id, const struct id_mapping *array, unsigned int array_sz)\n{\n\tunsigned int i;\n\n\tif (!array || !array_sz)\n\t\treturn 0;\n\n\tfor (i = 0; i < array_sz; i++)\n\t\tif (v4l2_id == array[i].v4l2_id)\n\t\t\treturn array[i].hfi_id;\n\n\treturn 0;\n}\n\nstatic void\nv4l2_id_profile_level(u32 hfi_codec, struct hfi_profile_level *pl, u32 *profile, u32 *level)\n{\n\tu32 hfi_pf = pl->profile;\n\tu32 hfi_lvl = pl->level;\n\n\tswitch (hfi_codec) {\n\tcase HFI_VIDEO_CODEC_H264:\n\t\t*profile = find_v4l2_id(hfi_pf, h264_profiles, ARRAY_SIZE(h264_profiles));\n\t\t*level = find_v4l2_id(hfi_lvl, h264_levels, ARRAY_SIZE(h264_levels));\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_MPEG2:\n\t\t*profile = find_v4l2_id(hfi_pf, mpeg2_profiles, ARRAY_SIZE(mpeg2_profiles));\n\t\t*level = find_v4l2_id(hfi_lvl, mpeg2_levels, ARRAY_SIZE(mpeg2_levels));\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_MPEG4:\n\t\t*profile = find_v4l2_id(hfi_pf, mpeg4_profiles, ARRAY_SIZE(mpeg4_profiles));\n\t\t*level = find_v4l2_id(hfi_lvl, mpeg4_levels, ARRAY_SIZE(mpeg4_levels));\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_VP8:\n\t\t*profile = find_v4l2_id(hfi_pf, vp8_profiles, ARRAY_SIZE(vp8_profiles));\n\t\t*level = 0;\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_VP9:\n\t\t*profile = find_v4l2_id(hfi_pf, vp9_profiles, ARRAY_SIZE(vp9_profiles));\n\t\t*level = find_v4l2_id(hfi_lvl, vp9_levels, ARRAY_SIZE(vp9_levels));\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_HEVC:\n\t\t*profile = find_v4l2_id(hfi_pf, hevc_profiles, ARRAY_SIZE(hevc_profiles));\n\t\t*level = find_v4l2_id(hfi_lvl, hevc_levels, ARRAY_SIZE(hevc_levels));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nhfi_id_profile_level(u32 hfi_codec, u32 v4l2_pf, u32 v4l2_lvl, struct hfi_profile_level *pl)\n{\n\tswitch (hfi_codec) {\n\tcase HFI_VIDEO_CODEC_H264:\n\t\tpl->profile = find_hfi_id(v4l2_pf, h264_profiles, ARRAY_SIZE(h264_profiles));\n\t\tpl->level = find_hfi_id(v4l2_lvl, h264_levels, ARRAY_SIZE(h264_levels));\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_MPEG2:\n\t\tpl->profile = find_hfi_id(v4l2_pf, mpeg2_profiles, ARRAY_SIZE(mpeg2_profiles));\n\t\tpl->level = find_hfi_id(v4l2_lvl, mpeg2_levels, ARRAY_SIZE(mpeg2_levels));\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_MPEG4:\n\t\tpl->profile = find_hfi_id(v4l2_pf, mpeg4_profiles, ARRAY_SIZE(mpeg4_profiles));\n\t\tpl->level = find_hfi_id(v4l2_lvl, mpeg4_levels, ARRAY_SIZE(mpeg4_levels));\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_VP8:\n\t\tpl->profile = find_hfi_id(v4l2_pf, vp8_profiles, ARRAY_SIZE(vp8_profiles));\n\t\tpl->level = 0;\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_VP9:\n\t\tpl->profile = find_hfi_id(v4l2_pf, vp9_profiles, ARRAY_SIZE(vp9_profiles));\n\t\tpl->level = find_hfi_id(v4l2_lvl, vp9_levels, ARRAY_SIZE(vp9_levels));\n\t\tbreak;\n\tcase HFI_VIDEO_CODEC_HEVC:\n\t\tpl->profile = find_hfi_id(v4l2_pf, hevc_profiles, ARRAY_SIZE(hevc_profiles));\n\t\tpl->level = find_hfi_id(v4l2_lvl, hevc_levels, ARRAY_SIZE(hevc_levels));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nint venus_helper_get_profile_level(struct venus_inst *inst, u32 *profile, u32 *level)\n{\n\tconst u32 ptype = HFI_PROPERTY_PARAM_PROFILE_LEVEL_CURRENT;\n\tunion hfi_get_property hprop;\n\tint ret;\n\n\tret = hfi_session_get_property(inst, ptype, &hprop);\n\tif (ret)\n\t\treturn ret;\n\n\tv4l2_id_profile_level(inst->hfi_codec, &hprop.profile_level, profile, level);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(venus_helper_get_profile_level);\n\nint venus_helper_set_profile_level(struct venus_inst *inst, u32 profile, u32 level)\n{\n\tconst u32 ptype = HFI_PROPERTY_PARAM_PROFILE_LEVEL_CURRENT;\n\tstruct hfi_profile_level pl;\n\n\thfi_id_profile_level(inst->hfi_codec, profile, level, &pl);\n\n\treturn hfi_session_set_property(inst, ptype, &pl);\n}\nEXPORT_SYMBOL_GPL(venus_helper_set_profile_level);\n\nstatic u32 get_framesize_raw_nv12(u32 width, u32 height)\n{\n\tu32 y_stride, uv_stride, y_plane;\n\tu32 y_sclines, uv_sclines, uv_plane;\n\tu32 size;\n\n\ty_stride = ALIGN(width, 128);\n\tuv_stride = ALIGN(width, 128);\n\ty_sclines = ALIGN(height, 32);\n\tuv_sclines = ALIGN(((height + 1) >> 1), 16);\n\n\ty_plane = y_stride * y_sclines;\n\tuv_plane = uv_stride * uv_sclines + SZ_4K;\n\tsize = y_plane + uv_plane + SZ_8K;\n\n\treturn ALIGN(size, SZ_4K);\n}\n\nstatic u32 get_framesize_raw_nv12_ubwc(u32 width, u32 height)\n{\n\tu32 y_meta_stride, y_meta_plane;\n\tu32 y_stride, y_plane;\n\tu32 uv_meta_stride, uv_meta_plane;\n\tu32 uv_stride, uv_plane;\n\tu32 extradata = SZ_16K;\n\n\ty_meta_stride = ALIGN(DIV_ROUND_UP(width, 32), 64);\n\ty_meta_plane = y_meta_stride * ALIGN(DIV_ROUND_UP(height, 8), 16);\n\ty_meta_plane = ALIGN(y_meta_plane, SZ_4K);\n\n\ty_stride = ALIGN(width, 128);\n\ty_plane = ALIGN(y_stride * ALIGN(height, 32), SZ_4K);\n\n\tuv_meta_stride = ALIGN(DIV_ROUND_UP(width / 2, 16), 64);\n\tuv_meta_plane = uv_meta_stride * ALIGN(DIV_ROUND_UP(height / 2, 8), 16);\n\tuv_meta_plane = ALIGN(uv_meta_plane, SZ_4K);\n\n\tuv_stride = ALIGN(width, 128);\n\tuv_plane = ALIGN(uv_stride * ALIGN(height / 2, 32), SZ_4K);\n\n\treturn ALIGN(y_meta_plane + y_plane + uv_meta_plane + uv_plane +\n\t\t     max(extradata, y_stride * 48), SZ_4K);\n}\n\nstatic u32 get_framesize_raw_p010(u32 width, u32 height)\n{\n\tu32 y_plane, uv_plane, y_stride, uv_stride, y_sclines, uv_sclines;\n\n\ty_stride = ALIGN(width * 2, 128);\n\tuv_stride = ALIGN(width * 2, 128);\n\ty_sclines = ALIGN(height, 32);\n\tuv_sclines = ALIGN((height + 1) >> 1, 16);\n\ty_plane = y_stride * y_sclines;\n\tuv_plane = uv_stride * uv_sclines;\n\n\treturn ALIGN((y_plane + uv_plane), SZ_4K);\n}\n\nstatic u32 get_framesize_raw_p010_ubwc(u32 width, u32 height)\n{\n\tu32 y_stride, uv_stride, y_sclines, uv_sclines;\n\tu32 y_ubwc_plane, uv_ubwc_plane;\n\tu32 y_meta_stride, y_meta_scanlines;\n\tu32 uv_meta_stride, uv_meta_scanlines;\n\tu32 y_meta_plane, uv_meta_plane;\n\tu32 size;\n\n\ty_stride = ALIGN(width * 2, 256);\n\tuv_stride = ALIGN(width * 2, 256);\n\ty_sclines = ALIGN(height, 16);\n\tuv_sclines = ALIGN((height + 1) >> 1, 16);\n\n\ty_ubwc_plane = ALIGN(y_stride * y_sclines, SZ_4K);\n\tuv_ubwc_plane = ALIGN(uv_stride * uv_sclines, SZ_4K);\n\ty_meta_stride = ALIGN(DIV_ROUND_UP(width, 32), 64);\n\ty_meta_scanlines = ALIGN(DIV_ROUND_UP(height, 4), 16);\n\ty_meta_plane = ALIGN(y_meta_stride * y_meta_scanlines, SZ_4K);\n\tuv_meta_stride = ALIGN(DIV_ROUND_UP((width + 1) >> 1, 16), 64);\n\tuv_meta_scanlines = ALIGN(DIV_ROUND_UP((height + 1) >> 1, 4), 16);\n\tuv_meta_plane = ALIGN(uv_meta_stride * uv_meta_scanlines, SZ_4K);\n\n\tsize = y_ubwc_plane + uv_ubwc_plane + y_meta_plane + uv_meta_plane;\n\n\treturn ALIGN(size, SZ_4K);\n}\n\nstatic u32 get_framesize_raw_yuv420_tp10_ubwc(u32 width, u32 height)\n{\n\tu32 y_stride, uv_stride, y_sclines, uv_sclines;\n\tu32 y_ubwc_plane, uv_ubwc_plane;\n\tu32 y_meta_stride, y_meta_scanlines;\n\tu32 uv_meta_stride, uv_meta_scanlines;\n\tu32 y_meta_plane, uv_meta_plane;\n\tu32 extradata = SZ_16K;\n\tu32 size;\n\n\ty_stride = ALIGN(width * 4 / 3, 256);\n\tuv_stride = ALIGN(width * 4 / 3, 256);\n\ty_sclines = ALIGN(height, 16);\n\tuv_sclines = ALIGN((height + 1) >> 1, 16);\n\n\ty_ubwc_plane = ALIGN(y_stride * y_sclines, SZ_4K);\n\tuv_ubwc_plane = ALIGN(uv_stride * uv_sclines, SZ_4K);\n\ty_meta_stride = ALIGN(DIV_ROUND_UP(width, 48), 64);\n\ty_meta_scanlines = ALIGN(DIV_ROUND_UP(height, 4), 16);\n\ty_meta_plane = ALIGN(y_meta_stride * y_meta_scanlines, SZ_4K);\n\tuv_meta_stride = ALIGN(DIV_ROUND_UP((width + 1) >> 1, 24), 64);\n\tuv_meta_scanlines = ALIGN(DIV_ROUND_UP((height + 1) >> 1, 4), 16);\n\tuv_meta_plane = ALIGN(uv_meta_stride * uv_meta_scanlines, SZ_4K);\n\n\tsize = y_ubwc_plane + uv_ubwc_plane + y_meta_plane + uv_meta_plane;\n\tsize += max(extradata + SZ_8K, y_stride * 48);\n\n\treturn ALIGN(size, SZ_4K);\n}\n\nu32 venus_helper_get_framesz_raw(u32 hfi_fmt, u32 width, u32 height)\n{\n\tswitch (hfi_fmt) {\n\tcase HFI_COLOR_FORMAT_NV12:\n\tcase HFI_COLOR_FORMAT_NV21:\n\t\treturn get_framesize_raw_nv12(width, height);\n\tcase HFI_COLOR_FORMAT_NV12_UBWC:\n\t\treturn get_framesize_raw_nv12_ubwc(width, height);\n\tcase HFI_COLOR_FORMAT_P010:\n\t\treturn get_framesize_raw_p010(width, height);\n\tcase HFI_COLOR_FORMAT_P010_UBWC:\n\t\treturn get_framesize_raw_p010_ubwc(width, height);\n\tcase HFI_COLOR_FORMAT_YUV420_TP10_UBWC:\n\t\treturn get_framesize_raw_yuv420_tp10_ubwc(width, height);\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(venus_helper_get_framesz_raw);\n\nu32 venus_helper_get_framesz(u32 v4l2_fmt, u32 width, u32 height)\n{\n\tu32 hfi_fmt, sz;\n\tbool compressed;\n\n\tswitch (v4l2_fmt) {\n\tcase V4L2_PIX_FMT_MPEG:\n\tcase V4L2_PIX_FMT_H264:\n\tcase V4L2_PIX_FMT_H264_NO_SC:\n\tcase V4L2_PIX_FMT_H264_MVC:\n\tcase V4L2_PIX_FMT_H263:\n\tcase V4L2_PIX_FMT_MPEG1:\n\tcase V4L2_PIX_FMT_MPEG2:\n\tcase V4L2_PIX_FMT_MPEG4:\n\tcase V4L2_PIX_FMT_XVID:\n\tcase V4L2_PIX_FMT_VC1_ANNEX_G:\n\tcase V4L2_PIX_FMT_VC1_ANNEX_L:\n\tcase V4L2_PIX_FMT_VP8:\n\tcase V4L2_PIX_FMT_VP9:\n\tcase V4L2_PIX_FMT_HEVC:\n\t\tcompressed = true;\n\t\tbreak;\n\tdefault:\n\t\tcompressed = false;\n\t\tbreak;\n\t}\n\n\tif (compressed) {\n\t\tsz = ALIGN(height, 32) * ALIGN(width, 32) * 3 / 2 / 2;\n\t\tif (width < 1280 || height < 720)\n\t\t\tsz *= 8;\n\t\treturn ALIGN(sz, SZ_4K);\n\t}\n\n\thfi_fmt = to_hfi_raw_fmt(v4l2_fmt);\n\tif (!hfi_fmt)\n\t\treturn 0;\n\n\treturn venus_helper_get_framesz_raw(hfi_fmt, width, height);\n}\nEXPORT_SYMBOL_GPL(venus_helper_get_framesz);\n\nint venus_helper_set_input_resolution(struct venus_inst *inst,\n\t\t\t\t      unsigned int width, unsigned int height)\n{\n\tu32 ptype = HFI_PROPERTY_PARAM_FRAME_SIZE;\n\tstruct hfi_framesize fs;\n\n\tfs.buffer_type = HFI_BUFFER_INPUT;\n\tfs.width = width;\n\tfs.height = height;\n\n\treturn hfi_session_set_property(inst, ptype, &fs);\n}\nEXPORT_SYMBOL_GPL(venus_helper_set_input_resolution);\n\nint venus_helper_set_output_resolution(struct venus_inst *inst,\n\t\t\t\t       unsigned int width, unsigned int height,\n\t\t\t\t       u32 buftype)\n{\n\tu32 ptype = HFI_PROPERTY_PARAM_FRAME_SIZE;\n\tstruct hfi_framesize fs;\n\n\tfs.buffer_type = buftype;\n\tfs.width = width;\n\tfs.height = height;\n\n\treturn hfi_session_set_property(inst, ptype, &fs);\n}\nEXPORT_SYMBOL_GPL(venus_helper_set_output_resolution);\n\nstatic u32 venus_helper_get_work_mode(struct venus_inst *inst)\n{\n\tu32 mode;\n\tu32 num_mbs;\n\n\tmode = VIDC_WORK_MODE_2;\n\tif (inst->session_type == VIDC_SESSION_TYPE_DEC) {\n\t\tnum_mbs = (ALIGN(inst->height, 16) * ALIGN(inst->width, 16)) / 256;\n\t\tif (inst->hfi_codec == HFI_VIDEO_CODEC_MPEG2 ||\n\t\t    inst->pic_struct != HFI_INTERLACE_FRAME_PROGRESSIVE ||\n\t\t    num_mbs <= NUM_MBS_720P)\n\t\t\tmode = VIDC_WORK_MODE_1;\n\t} else {\n\t\tnum_mbs = (ALIGN(inst->out_height, 16) * ALIGN(inst->out_width, 16)) / 256;\n\t\tif (inst->hfi_codec == HFI_VIDEO_CODEC_VP8 &&\n\t\t    num_mbs <= NUM_MBS_4K)\n\t\t\tmode = VIDC_WORK_MODE_1;\n\t}\n\n\treturn mode;\n}\n\nint venus_helper_set_work_mode(struct venus_inst *inst)\n{\n\tconst u32 ptype = HFI_PROPERTY_PARAM_WORK_MODE;\n\tstruct hfi_video_work_mode wm;\n\tu32 mode;\n\n\tif (!IS_V4(inst->core) && !IS_V6(inst->core))\n\t\treturn 0;\n\n\tmode = venus_helper_get_work_mode(inst);\n\twm.video_work_mode = mode;\n\treturn hfi_session_set_property(inst, ptype, &wm);\n}\nEXPORT_SYMBOL_GPL(venus_helper_set_work_mode);\n\nint venus_helper_set_format_constraints(struct venus_inst *inst)\n{\n\tconst u32 ptype = HFI_PROPERTY_PARAM_UNCOMPRESSED_PLANE_ACTUAL_CONSTRAINTS_INFO;\n\tstruct hfi_uncompressed_plane_actual_constraints_info pconstraint;\n\n\tif (!IS_V6(inst->core))\n\t\treturn 0;\n\n\tif (inst->opb_fmt == HFI_COLOR_FORMAT_NV12_UBWC ||\n\t    inst->opb_fmt == HFI_COLOR_FORMAT_YUV420_TP10_UBWC)\n\t\treturn 0;\n\n\tpconstraint.buffer_type = HFI_BUFFER_OUTPUT2;\n\tpconstraint.num_planes = 2;\n\tpconstraint.plane_format[0].stride_multiples = 128;\n\tpconstraint.plane_format[0].max_stride = 8192;\n\tpconstraint.plane_format[0].min_plane_buffer_height_multiple = 32;\n\tpconstraint.plane_format[0].buffer_alignment = 256;\n\n\tpconstraint.plane_format[1].stride_multiples = 128;\n\tpconstraint.plane_format[1].max_stride = 8192;\n\tpconstraint.plane_format[1].min_plane_buffer_height_multiple = 16;\n\tpconstraint.plane_format[1].buffer_alignment = 256;\n\n\treturn hfi_session_set_property(inst, ptype, &pconstraint);\n}\nEXPORT_SYMBOL_GPL(venus_helper_set_format_constraints);\n\nint venus_helper_set_num_bufs(struct venus_inst *inst, unsigned int input_bufs,\n\t\t\t      unsigned int output_bufs,\n\t\t\t      unsigned int output2_bufs)\n{\n\tu32 ptype = HFI_PROPERTY_PARAM_BUFFER_COUNT_ACTUAL;\n\tstruct hfi_buffer_count_actual buf_count;\n\tint ret;\n\n\tbuf_count.type = HFI_BUFFER_INPUT;\n\tbuf_count.count_actual = input_bufs;\n\n\tret = hfi_session_set_property(inst, ptype, &buf_count);\n\tif (ret)\n\t\treturn ret;\n\n\tbuf_count.type = HFI_BUFFER_OUTPUT;\n\tbuf_count.count_actual = output_bufs;\n\n\tret = hfi_session_set_property(inst, ptype, &buf_count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (output2_bufs) {\n\t\tbuf_count.type = HFI_BUFFER_OUTPUT2;\n\t\tbuf_count.count_actual = output2_bufs;\n\n\t\tret = hfi_session_set_property(inst, ptype, &buf_count);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(venus_helper_set_num_bufs);\n\nint venus_helper_set_raw_format(struct venus_inst *inst, u32 hfi_format,\n\t\t\t\tu32 buftype)\n{\n\tconst u32 ptype = HFI_PROPERTY_PARAM_UNCOMPRESSED_FORMAT_SELECT;\n\tstruct hfi_uncompressed_format_select fmt;\n\n\tfmt.buffer_type = buftype;\n\tfmt.format = hfi_format;\n\n\treturn hfi_session_set_property(inst, ptype, &fmt);\n}\nEXPORT_SYMBOL_GPL(venus_helper_set_raw_format);\n\nint venus_helper_set_color_format(struct venus_inst *inst, u32 pixfmt)\n{\n\tu32 hfi_format, buftype;\n\n\tif (inst->session_type == VIDC_SESSION_TYPE_DEC)\n\t\tbuftype = HFI_BUFFER_OUTPUT;\n\telse if (inst->session_type == VIDC_SESSION_TYPE_ENC)\n\t\tbuftype = HFI_BUFFER_INPUT;\n\telse\n\t\treturn -EINVAL;\n\n\thfi_format = to_hfi_raw_fmt(pixfmt);\n\tif (!hfi_format)\n\t\treturn -EINVAL;\n\n\treturn venus_helper_set_raw_format(inst, hfi_format, buftype);\n}\nEXPORT_SYMBOL_GPL(venus_helper_set_color_format);\n\nint venus_helper_set_multistream(struct venus_inst *inst, bool out_en,\n\t\t\t\t bool out2_en)\n{\n\tstruct hfi_multi_stream multi = {0};\n\tu32 ptype = HFI_PROPERTY_PARAM_VDEC_MULTI_STREAM;\n\tint ret;\n\n\tmulti.buffer_type = HFI_BUFFER_OUTPUT;\n\tmulti.enable = out_en;\n\n\tret = hfi_session_set_property(inst, ptype, &multi);\n\tif (ret)\n\t\treturn ret;\n\n\tmulti.buffer_type = HFI_BUFFER_OUTPUT2;\n\tmulti.enable = out2_en;\n\n\treturn hfi_session_set_property(inst, ptype, &multi);\n}\nEXPORT_SYMBOL_GPL(venus_helper_set_multistream);\n\nint venus_helper_set_dyn_bufmode(struct venus_inst *inst)\n{\n\tconst u32 ptype = HFI_PROPERTY_PARAM_BUFFER_ALLOC_MODE;\n\tstruct hfi_buffer_alloc_mode mode;\n\tint ret;\n\n\tif (!is_dynamic_bufmode(inst))\n\t\treturn 0;\n\n\tmode.type = HFI_BUFFER_OUTPUT;\n\tmode.mode = HFI_BUFFER_MODE_DYNAMIC;\n\n\tret = hfi_session_set_property(inst, ptype, &mode);\n\tif (ret)\n\t\treturn ret;\n\n\tmode.type = HFI_BUFFER_OUTPUT2;\n\n\treturn hfi_session_set_property(inst, ptype, &mode);\n}\nEXPORT_SYMBOL_GPL(venus_helper_set_dyn_bufmode);\n\nint venus_helper_set_bufsize(struct venus_inst *inst, u32 bufsize, u32 buftype)\n{\n\tconst u32 ptype = HFI_PROPERTY_PARAM_BUFFER_SIZE_ACTUAL;\n\tstruct hfi_buffer_size_actual bufsz;\n\n\tbufsz.type = buftype;\n\tbufsz.size = bufsize;\n\n\treturn hfi_session_set_property(inst, ptype, &bufsz);\n}\nEXPORT_SYMBOL_GPL(venus_helper_set_bufsize);\n\nunsigned int venus_helper_get_opb_size(struct venus_inst *inst)\n{\n\t \n\tif (inst->session_type == VIDC_SESSION_TYPE_ENC)\n\t\treturn inst->output_buf_size;\n\n\tif (inst->opb_buftype == HFI_BUFFER_OUTPUT)\n\t\treturn inst->output_buf_size;\n\telse if (inst->opb_buftype == HFI_BUFFER_OUTPUT2)\n\t\treturn inst->output2_buf_size;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(venus_helper_get_opb_size);\n\nstatic void delayed_process_buf_func(struct work_struct *work)\n{\n\tstruct venus_buffer *buf, *n;\n\tstruct venus_inst *inst;\n\tint ret;\n\n\tinst = container_of(work, struct venus_inst, delayed_process_work);\n\n\tmutex_lock(&inst->lock);\n\n\tif (!(inst->streamon_out & inst->streamon_cap))\n\t\tgoto unlock;\n\n\tlist_for_each_entry_safe(buf, n, &inst->delayed_process, ref_list) {\n\t\tif (buf->flags & HFI_BUFFERFLAG_READONLY)\n\t\t\tcontinue;\n\n\t\tret = session_process_buf(inst, &buf->vb);\n\t\tif (ret)\n\t\t\treturn_buf_error(inst, &buf->vb);\n\n\t\tlist_del_init(&buf->ref_list);\n\t}\nunlock:\n\tmutex_unlock(&inst->lock);\n}\n\nvoid venus_helper_release_buf_ref(struct venus_inst *inst, unsigned int idx)\n{\n\tstruct venus_buffer *buf;\n\n\tlist_for_each_entry(buf, &inst->registeredbufs, reg_list) {\n\t\tif (buf->vb.vb2_buf.index == idx) {\n\t\t\tbuf->flags &= ~HFI_BUFFERFLAG_READONLY;\n\t\t\tschedule_work(&inst->delayed_process_work);\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(venus_helper_release_buf_ref);\n\nvoid venus_helper_acquire_buf_ref(struct vb2_v4l2_buffer *vbuf)\n{\n\tstruct venus_buffer *buf = to_venus_buffer(vbuf);\n\n\tbuf->flags |= HFI_BUFFERFLAG_READONLY;\n}\nEXPORT_SYMBOL_GPL(venus_helper_acquire_buf_ref);\n\nstatic int is_buf_refed(struct venus_inst *inst, struct vb2_v4l2_buffer *vbuf)\n{\n\tstruct venus_buffer *buf = to_venus_buffer(vbuf);\n\n\tif (buf->flags & HFI_BUFFERFLAG_READONLY) {\n\t\tlist_add_tail(&buf->ref_list, &inst->delayed_process);\n\t\tschedule_work(&inst->delayed_process_work);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstruct vb2_v4l2_buffer *\nvenus_helper_find_buf(struct venus_inst *inst, unsigned int type, u32 idx)\n{\n\tstruct v4l2_m2m_ctx *m2m_ctx = inst->m2m_ctx;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn v4l2_m2m_src_buf_remove_by_idx(m2m_ctx, idx);\n\telse\n\t\treturn v4l2_m2m_dst_buf_remove_by_idx(m2m_ctx, idx);\n}\nEXPORT_SYMBOL_GPL(venus_helper_find_buf);\n\nvoid venus_helper_change_dpb_owner(struct venus_inst *inst,\n\t\t\t\t   struct vb2_v4l2_buffer *vbuf, unsigned int type,\n\t\t\t\t   unsigned int buf_type, u32 tag)\n{\n\tstruct intbuf *dpb_buf;\n\n\tif (!V4L2_TYPE_IS_CAPTURE(type) ||\n\t    buf_type != inst->dpb_buftype)\n\t\treturn;\n\n\tlist_for_each_entry(dpb_buf, &inst->dpbbufs, list)\n\t\tif (dpb_buf->dpb_out_tag == tag) {\n\t\t\tdpb_buf->owned_by = DRIVER;\n\t\t\tbreak;\n\t\t}\n}\nEXPORT_SYMBOL_GPL(venus_helper_change_dpb_owner);\n\nint venus_helper_vb2_buf_init(struct vb2_buffer *vb)\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct venus_buffer *buf = to_venus_buffer(vbuf);\n\n\tbuf->size = vb2_plane_size(vb, 0);\n\tbuf->dma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\n\tif (vb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tlist_add_tail(&buf->reg_list, &inst->registeredbufs);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(venus_helper_vb2_buf_init);\n\nint venus_helper_vb2_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned int out_buf_size = venus_helper_get_opb_size(inst);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tif (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\n\t\tif (vbuf->field == V4L2_FIELD_ANY)\n\t\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tif (vbuf->field != V4L2_FIELD_NONE) {\n\t\t\tdev_err(inst->core->dev, \"%s field isn't supported\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (vb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\n\t    vb2_plane_size(vb, 0) < out_buf_size)\n\t\treturn -EINVAL;\n\tif (vb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&\n\t    vb2_plane_size(vb, 0) < inst->input_buf_size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(venus_helper_vb2_buf_prepare);\n\nstatic void cache_payload(struct venus_inst *inst, struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tunsigned int idx = vbuf->vb2_buf.index;\n\n\tif (vbuf->vb2_buf.type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tinst->payloads[idx] = vb2_get_plane_payload(vb, 0);\n}\n\nvoid venus_helper_vb2_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct venus_inst *inst = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct v4l2_m2m_ctx *m2m_ctx = inst->m2m_ctx;\n\tint ret;\n\n\tv4l2_m2m_buf_queue(m2m_ctx, vbuf);\n\n\t \n\tif (inst->session_type == VIDC_SESSION_TYPE_DEC &&\n\t    V4L2_TYPE_IS_CAPTURE(vb->vb2_queue->type) &&\n\t    inst->codec_state == VENUS_DEC_STATE_DRC)\n\t\treturn;\n\n\tcache_payload(inst, vb);\n\n\tif (inst->session_type == VIDC_SESSION_TYPE_ENC &&\n\t    !(inst->streamon_out && inst->streamon_cap))\n\t\treturn;\n\n\tif (vb2_start_streaming_called(vb->vb2_queue)) {\n\t\tret = is_buf_refed(inst, vbuf);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tret = session_process_buf(inst, vbuf);\n\t\tif (ret)\n\t\t\treturn_buf_error(inst, vbuf);\n\t}\n}\nEXPORT_SYMBOL_GPL(venus_helper_vb2_buf_queue);\n\nvoid venus_helper_buffers_done(struct venus_inst *inst, unsigned int type,\n\t\t\t       enum vb2_buffer_state state)\n{\n\tstruct vb2_v4l2_buffer *buf;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\twhile ((buf = v4l2_m2m_src_buf_remove(inst->m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buf, state);\n\t} else if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\twhile ((buf = v4l2_m2m_dst_buf_remove(inst->m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buf, state);\n\t}\n}\nEXPORT_SYMBOL_GPL(venus_helper_buffers_done);\n\nvoid venus_helper_vb2_stop_streaming(struct vb2_queue *q)\n{\n\tstruct venus_inst *inst = vb2_get_drv_priv(q);\n\tstruct venus_core *core = inst->core;\n\tint ret;\n\n\tmutex_lock(&inst->lock);\n\n\tif (inst->streamon_out & inst->streamon_cap) {\n\t\tret = hfi_session_stop(inst);\n\t\tret |= hfi_session_unload_res(inst);\n\t\tret |= venus_helper_unregister_bufs(inst);\n\t\tret |= venus_helper_intbufs_free(inst);\n\t\tret |= hfi_session_deinit(inst);\n\n\t\tif (inst->session_error || test_bit(0, &core->sys_error))\n\t\t\tret = -EIO;\n\n\t\tif (ret)\n\t\t\thfi_session_abort(inst);\n\n\t\tvenus_helper_free_dpb_bufs(inst);\n\n\t\tvenus_pm_load_scale(inst);\n\t\tINIT_LIST_HEAD(&inst->registeredbufs);\n\t}\n\n\tvenus_helper_buffers_done(inst, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\n\t\t\t\t  VB2_BUF_STATE_ERROR);\n\tvenus_helper_buffers_done(inst, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,\n\t\t\t\t  VB2_BUF_STATE_ERROR);\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tinst->streamon_out = 0;\n\telse\n\t\tinst->streamon_cap = 0;\n\n\tvenus_pm_release_core(inst);\n\n\tinst->session_error = 0;\n\n\tmutex_unlock(&inst->lock);\n}\nEXPORT_SYMBOL_GPL(venus_helper_vb2_stop_streaming);\n\nvoid venus_helper_vb2_queue_error(struct venus_inst *inst)\n{\n\tstruct v4l2_m2m_ctx *m2m_ctx = inst->m2m_ctx;\n\tstruct vb2_queue *q;\n\n\tq = v4l2_m2m_get_src_vq(m2m_ctx);\n\tvb2_queue_error(q);\n\tq = v4l2_m2m_get_dst_vq(m2m_ctx);\n\tvb2_queue_error(q);\n}\nEXPORT_SYMBOL_GPL(venus_helper_vb2_queue_error);\n\nint venus_helper_process_initial_cap_bufs(struct venus_inst *inst)\n{\n\tstruct v4l2_m2m_ctx *m2m_ctx = inst->m2m_ctx;\n\tstruct v4l2_m2m_buffer *buf, *n;\n\tint ret;\n\n\tv4l2_m2m_for_each_dst_buf_safe(m2m_ctx, buf, n) {\n\t\tret = session_process_buf(inst, &buf->vb);\n\t\tif (ret) {\n\t\t\treturn_buf_error(inst, &buf->vb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(venus_helper_process_initial_cap_bufs);\n\nint venus_helper_process_initial_out_bufs(struct venus_inst *inst)\n{\n\tstruct v4l2_m2m_ctx *m2m_ctx = inst->m2m_ctx;\n\tstruct v4l2_m2m_buffer *buf, *n;\n\tint ret;\n\n\tv4l2_m2m_for_each_src_buf_safe(m2m_ctx, buf, n) {\n\t\tret = session_process_buf(inst, &buf->vb);\n\t\tif (ret) {\n\t\t\treturn_buf_error(inst, &buf->vb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(venus_helper_process_initial_out_bufs);\n\nint venus_helper_vb2_start_streaming(struct venus_inst *inst)\n{\n\tint ret;\n\n\tret = venus_helper_intbufs_alloc(inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = session_register_bufs(inst);\n\tif (ret)\n\t\tgoto err_bufs_free;\n\n\tvenus_pm_load_scale(inst);\n\n\tret = hfi_session_load_res(inst);\n\tif (ret)\n\t\tgoto err_unreg_bufs;\n\n\tret = hfi_session_start(inst);\n\tif (ret)\n\t\tgoto err_unload_res;\n\n\treturn 0;\n\nerr_unload_res:\n\thfi_session_unload_res(inst);\nerr_unreg_bufs:\n\tvenus_helper_unregister_bufs(inst);\nerr_bufs_free:\n\tvenus_helper_intbufs_free(inst);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(venus_helper_vb2_start_streaming);\n\nvoid venus_helper_m2m_device_run(void *priv)\n{\n\tstruct venus_inst *inst = priv;\n\tstruct v4l2_m2m_ctx *m2m_ctx = inst->m2m_ctx;\n\tstruct v4l2_m2m_buffer *buf, *n;\n\tint ret;\n\n\tmutex_lock(&inst->lock);\n\n\tv4l2_m2m_for_each_dst_buf_safe(m2m_ctx, buf, n) {\n\t\tret = session_process_buf(inst, &buf->vb);\n\t\tif (ret)\n\t\t\treturn_buf_error(inst, &buf->vb);\n\t}\n\n\tv4l2_m2m_for_each_src_buf_safe(m2m_ctx, buf, n) {\n\t\tret = session_process_buf(inst, &buf->vb);\n\t\tif (ret)\n\t\t\treturn_buf_error(inst, &buf->vb);\n\t}\n\n\tmutex_unlock(&inst->lock);\n}\nEXPORT_SYMBOL_GPL(venus_helper_m2m_device_run);\n\nvoid venus_helper_m2m_job_abort(void *priv)\n{\n\tstruct venus_inst *inst = priv;\n\n\tv4l2_m2m_job_finish(inst->m2m_dev, inst->m2m_ctx);\n}\nEXPORT_SYMBOL_GPL(venus_helper_m2m_job_abort);\n\nint venus_helper_session_init(struct venus_inst *inst)\n{\n\tenum hfi_version version = inst->core->res->hfi_version;\n\tu32 session_type = inst->session_type;\n\tu32 codec;\n\tint ret;\n\n\tcodec = inst->session_type == VIDC_SESSION_TYPE_DEC ?\n\t\t\tinst->fmt_out->pixfmt : inst->fmt_cap->pixfmt;\n\n\tret = hfi_session_init(inst, codec);\n\tif (ret)\n\t\treturn ret;\n\n\tinst->clk_data.vpp_freq = hfi_platform_get_codec_vpp_freq(version, codec,\n\t\t\t\t\t\t\t\t  session_type);\n\tinst->clk_data.vsp_freq = hfi_platform_get_codec_vsp_freq(version, codec,\n\t\t\t\t\t\t\t\t  session_type);\n\tinst->clk_data.low_power_freq = hfi_platform_get_codec_lp_freq(version, codec,\n\t\t\t\t\t\t\t\t       session_type);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(venus_helper_session_init);\n\nvoid venus_helper_init_instance(struct venus_inst *inst)\n{\n\tif (inst->session_type == VIDC_SESSION_TYPE_DEC) {\n\t\tINIT_LIST_HEAD(&inst->delayed_process);\n\t\tINIT_WORK(&inst->delayed_process_work,\n\t\t\t  delayed_process_buf_func);\n\t}\n}\nEXPORT_SYMBOL_GPL(venus_helper_init_instance);\n\nstatic bool find_fmt_from_caps(struct hfi_plat_caps *caps, u32 buftype, u32 fmt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < caps->num_fmts; i++) {\n\t\tif (caps->fmts[i].buftype == buftype &&\n\t\t    caps->fmts[i].fmt == fmt)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint venus_helper_get_out_fmts(struct venus_inst *inst, u32 v4l2_fmt,\n\t\t\t      u32 *out_fmt, u32 *out2_fmt, bool ubwc)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct hfi_plat_caps *caps;\n\tu32 ubwc_fmt, fmt = to_hfi_raw_fmt(v4l2_fmt);\n\tbool found, found_ubwc;\n\n\t*out_fmt = *out2_fmt = 0;\n\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tcaps = venus_caps_by_codec(core, inst->hfi_codec, inst->session_type);\n\tif (!caps)\n\t\treturn -EINVAL;\n\n\tif (inst->bit_depth == VIDC_BITDEPTH_10 && inst->session_type == VIDC_SESSION_TYPE_DEC) {\n\t\tfound_ubwc = find_fmt_from_caps(caps, HFI_BUFFER_OUTPUT,\n\t\t\t\t\t\tHFI_COLOR_FORMAT_YUV420_TP10_UBWC);\n\t\tfound = find_fmt_from_caps(caps, HFI_BUFFER_OUTPUT2, fmt);\n\t\tif (found_ubwc && found) {\n\t\t\t \n\t\t\t*out_fmt = HFI_COLOR_FORMAT_YUV420_TP10_UBWC;\n\t\t\t*out2_fmt = fmt;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (ubwc) {\n\t\tubwc_fmt = fmt | HFI_COLOR_FORMAT_UBWC_BASE;\n\t\tfound_ubwc = find_fmt_from_caps(caps, HFI_BUFFER_OUTPUT,\n\t\t\t\t\t\tubwc_fmt);\n\t\tfound = find_fmt_from_caps(caps, HFI_BUFFER_OUTPUT2, fmt);\n\n\t\tif (found_ubwc && found) {\n\t\t\t*out_fmt = ubwc_fmt;\n\t\t\t*out2_fmt = fmt;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfound = find_fmt_from_caps(caps, HFI_BUFFER_OUTPUT, fmt);\n\tif (found) {\n\t\t*out_fmt = fmt;\n\t\t*out2_fmt = 0;\n\t\treturn 0;\n\t}\n\n\tfound = find_fmt_from_caps(caps, HFI_BUFFER_OUTPUT2, fmt);\n\tif (found) {\n\t\t*out_fmt = 0;\n\t\t*out2_fmt = fmt;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(venus_helper_get_out_fmts);\n\nbool venus_helper_check_format(struct venus_inst *inst, u32 v4l2_pixfmt)\n{\n\tstruct venus_core *core = inst->core;\n\tu32 fmt = to_hfi_raw_fmt(v4l2_pixfmt);\n\tstruct hfi_plat_caps *caps;\n\tbool found;\n\n\tif (!fmt)\n\t\treturn false;\n\n\tcaps = venus_caps_by_codec(core, inst->hfi_codec, inst->session_type);\n\tif (!caps)\n\t\treturn false;\n\n\tfound = find_fmt_from_caps(caps, HFI_BUFFER_OUTPUT, fmt);\n\tif (found)\n\t\tgoto done;\n\n\tfound = find_fmt_from_caps(caps, HFI_BUFFER_OUTPUT2, fmt);\ndone:\n\treturn found;\n}\nEXPORT_SYMBOL_GPL(venus_helper_check_format);\n\nint venus_helper_set_stride(struct venus_inst *inst,\n\t\t\t    unsigned int width, unsigned int height)\n{\n\tconst u32 ptype = HFI_PROPERTY_PARAM_UNCOMPRESSED_PLANE_ACTUAL_INFO;\n\n\tstruct hfi_uncompressed_plane_actual_info plane_actual_info;\n\n\tplane_actual_info.buffer_type = HFI_BUFFER_INPUT;\n\tplane_actual_info.num_planes = 2;\n\tplane_actual_info.plane_format[0].actual_stride = width;\n\tplane_actual_info.plane_format[0].actual_plane_buffer_height = height;\n\tplane_actual_info.plane_format[1].actual_stride = width;\n\tplane_actual_info.plane_format[1].actual_plane_buffer_height = height / 2;\n\n\treturn hfi_session_set_property(inst, ptype, &plane_actual_info);\n}\nEXPORT_SYMBOL_GPL(venus_helper_set_stride);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}