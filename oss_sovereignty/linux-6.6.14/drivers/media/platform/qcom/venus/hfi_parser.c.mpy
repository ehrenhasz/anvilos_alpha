{
  "module_name": "hfi_parser.c",
  "hash_id": "6c2b5ee7d271441657f84bee4920a56c76729e38a9c6fe146c42f41d131f6694",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/venus/hfi_parser.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/kernel.h>\n\n#include \"core.h\"\n#include \"hfi_helper.h\"\n#include \"hfi_parser.h\"\n\ntypedef void (*func)(struct hfi_plat_caps *cap, const void *data,\n\t\t     unsigned int size);\n\nstatic void init_codecs(struct venus_core *core)\n{\n\tstruct hfi_plat_caps *caps = core->caps, *cap;\n\tunsigned long bit;\n\n\tif (hweight_long(core->dec_codecs) + hweight_long(core->enc_codecs) > MAX_CODEC_NUM)\n\t\treturn;\n\n\tfor_each_set_bit(bit, &core->dec_codecs, MAX_CODEC_NUM) {\n\t\tcap = &caps[core->codecs_count++];\n\t\tcap->codec = BIT(bit);\n\t\tcap->domain = VIDC_SESSION_TYPE_DEC;\n\t\tcap->valid = false;\n\t}\n\n\tfor_each_set_bit(bit, &core->enc_codecs, MAX_CODEC_NUM) {\n\t\tcap = &caps[core->codecs_count++];\n\t\tcap->codec = BIT(bit);\n\t\tcap->domain = VIDC_SESSION_TYPE_ENC;\n\t\tcap->valid = false;\n\t}\n}\n\nstatic void for_each_codec(struct hfi_plat_caps *caps, unsigned int caps_num,\n\t\t\t   u32 codecs, u32 domain, func cb, void *data,\n\t\t\t   unsigned int size)\n{\n\tstruct hfi_plat_caps *cap;\n\tunsigned int i;\n\n\tfor (i = 0; i < caps_num; i++) {\n\t\tcap = &caps[i];\n\t\tif (cap->valid && cap->domain == domain)\n\t\t\tcontinue;\n\t\tif (cap->codec & codecs && cap->domain == domain)\n\t\t\tcb(cap, data, size);\n\t}\n}\n\nstatic void\nfill_buf_mode(struct hfi_plat_caps *cap, const void *data, unsigned int num)\n{\n\tconst u32 *type = data;\n\n\tif (*type == HFI_BUFFER_MODE_DYNAMIC)\n\t\tcap->cap_bufs_mode_dynamic = true;\n}\n\nstatic void\nparse_alloc_mode(struct venus_core *core, u32 codecs, u32 domain, void *data)\n{\n\tstruct hfi_buffer_alloc_mode_supported *mode = data;\n\tu32 num_entries = mode->num_entries;\n\tu32 *type;\n\n\tif (num_entries > MAX_ALLOC_MODE_ENTRIES)\n\t\treturn;\n\n\ttype = mode->data;\n\n\twhile (num_entries--) {\n\t\tif (mode->buffer_type == HFI_BUFFER_OUTPUT ||\n\t\t    mode->buffer_type == HFI_BUFFER_OUTPUT2)\n\t\t\tfor_each_codec(core->caps, ARRAY_SIZE(core->caps),\n\t\t\t\t       codecs, domain, fill_buf_mode, type, 1);\n\n\t\ttype++;\n\t}\n}\n\nstatic void fill_profile_level(struct hfi_plat_caps *cap, const void *data,\n\t\t\t       unsigned int num)\n{\n\tconst struct hfi_profile_level *pl = data;\n\n\tif (cap->num_pl + num >= HFI_MAX_PROFILE_COUNT)\n\t\treturn;\n\n\tmemcpy(&cap->pl[cap->num_pl], pl, num * sizeof(*pl));\n\tcap->num_pl += num;\n}\n\nstatic void\nparse_profile_level(struct venus_core *core, u32 codecs, u32 domain, void *data)\n{\n\tstruct hfi_profile_level_supported *pl = data;\n\tstruct hfi_profile_level *proflevel = pl->profile_level;\n\tstruct hfi_profile_level pl_arr[HFI_MAX_PROFILE_COUNT] = {};\n\n\tif (pl->profile_count > HFI_MAX_PROFILE_COUNT)\n\t\treturn;\n\n\tmemcpy(pl_arr, proflevel, pl->profile_count * sizeof(*proflevel));\n\n\tfor_each_codec(core->caps, ARRAY_SIZE(core->caps), codecs, domain,\n\t\t       fill_profile_level, pl_arr, pl->profile_count);\n}\n\nstatic void\nfill_caps(struct hfi_plat_caps *cap, const void *data, unsigned int num)\n{\n\tconst struct hfi_capability *caps = data;\n\n\tif (cap->num_caps + num >= MAX_CAP_ENTRIES)\n\t\treturn;\n\n\tmemcpy(&cap->caps[cap->num_caps], caps, num * sizeof(*caps));\n\tcap->num_caps += num;\n}\n\nstatic void\nparse_caps(struct venus_core *core, u32 codecs, u32 domain, void *data)\n{\n\tstruct hfi_capabilities *caps = data;\n\tstruct hfi_capability *cap = caps->data;\n\tu32 num_caps = caps->num_capabilities;\n\tstruct hfi_capability caps_arr[MAX_CAP_ENTRIES] = {};\n\n\tif (num_caps > MAX_CAP_ENTRIES)\n\t\treturn;\n\n\tmemcpy(caps_arr, cap, num_caps * sizeof(*cap));\n\n\tfor_each_codec(core->caps, ARRAY_SIZE(core->caps), codecs, domain,\n\t\t       fill_caps, caps_arr, num_caps);\n}\n\nstatic void fill_raw_fmts(struct hfi_plat_caps *cap, const void *fmts,\n\t\t\t  unsigned int num_fmts)\n{\n\tconst struct raw_formats *formats = fmts;\n\n\tif (cap->num_fmts + num_fmts >= MAX_FMT_ENTRIES)\n\t\treturn;\n\n\tmemcpy(&cap->fmts[cap->num_fmts], formats, num_fmts * sizeof(*formats));\n\tcap->num_fmts += num_fmts;\n}\n\nstatic void\nparse_raw_formats(struct venus_core *core, u32 codecs, u32 domain, void *data)\n{\n\tstruct hfi_uncompressed_format_supported *fmt = data;\n\tstruct hfi_uncompressed_plane_info *pinfo = fmt->plane_info;\n\tstruct hfi_uncompressed_plane_constraints *constr;\n\tstruct raw_formats rawfmts[MAX_FMT_ENTRIES] = {};\n\tu32 entries = fmt->format_entries;\n\tunsigned int i = 0;\n\tu32 num_planes;\n\n\twhile (entries) {\n\t\tnum_planes = pinfo->num_planes;\n\n\t\trawfmts[i].fmt = pinfo->format;\n\t\trawfmts[i].buftype = fmt->buffer_type;\n\t\ti++;\n\n\t\tif (i >= MAX_FMT_ENTRIES)\n\t\t\treturn;\n\n\t\tif (pinfo->num_planes > MAX_PLANES)\n\t\t\tbreak;\n\n\t\tpinfo = (void *)pinfo + sizeof(*constr) * num_planes +\n\t\t\t2 * sizeof(u32);\n\t\tentries--;\n\t}\n\n\tfor_each_codec(core->caps, ARRAY_SIZE(core->caps), codecs, domain,\n\t\t       fill_raw_fmts, rawfmts, i);\n}\n\nstatic void parse_codecs(struct venus_core *core, void *data)\n{\n\tstruct hfi_codec_supported *codecs = data;\n\n\tcore->dec_codecs = codecs->dec_codecs;\n\tcore->enc_codecs = codecs->enc_codecs;\n\n\tif (IS_V1(core)) {\n\t\tcore->dec_codecs &= ~HFI_VIDEO_CODEC_HEVC;\n\t\tcore->dec_codecs &= ~HFI_VIDEO_CODEC_SPARK;\n\t\tcore->enc_codecs &= ~HFI_VIDEO_CODEC_HEVC;\n\t}\n}\n\nstatic void parse_max_sessions(struct venus_core *core, const void *data)\n{\n\tconst struct hfi_max_sessions_supported *sessions = data;\n\n\tcore->max_sessions_supported = sessions->max_sessions;\n}\n\nstatic void parse_codecs_mask(u32 *codecs, u32 *domain, void *data)\n{\n\tstruct hfi_codec_mask_supported *mask = data;\n\n\t*codecs = mask->codecs;\n\t*domain = mask->video_domains;\n}\n\nstatic void parser_init(struct venus_inst *inst, u32 *codecs, u32 *domain)\n{\n\tif (!inst || !IS_V1(inst->core))\n\t\treturn;\n\n\t*codecs = inst->hfi_codec;\n\t*domain = inst->session_type;\n}\n\nstatic void parser_fini(struct venus_inst *inst, u32 codecs, u32 domain)\n{\n\tstruct hfi_plat_caps *caps, *cap;\n\tunsigned int i;\n\tu32 dom;\n\n\tif (!inst || !IS_V1(inst->core))\n\t\treturn;\n\n\tcaps = inst->core->caps;\n\tdom = inst->session_type;\n\n\tfor (i = 0; i < MAX_CODEC_NUM; i++) {\n\t\tcap = &caps[i];\n\t\tif (cap->codec & codecs && cap->domain == dom)\n\t\t\tcap->valid = true;\n\t}\n}\n\nstatic int hfi_platform_parser(struct venus_core *core, struct venus_inst *inst)\n{\n\tconst struct hfi_platform *plat;\n\tconst struct hfi_plat_caps *caps = NULL;\n\tu32 enc_codecs, dec_codecs, count = 0;\n\tunsigned int entries;\n\tint ret;\n\n\tplat = hfi_platform_get(core->res->hfi_version);\n\tif (!plat)\n\t\treturn -EINVAL;\n\n\tif (inst)\n\t\treturn 0;\n\n\tret = hfi_platform_get_codecs(core, &enc_codecs, &dec_codecs, &count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (plat->capabilities)\n\t\tcaps = plat->capabilities(&entries);\n\n\tif (!caps || !entries || !count)\n\t\treturn -EINVAL;\n\n\tcore->enc_codecs = enc_codecs;\n\tcore->dec_codecs = dec_codecs;\n\tcore->codecs_count = count;\n\tcore->max_sessions_supported = MAX_SESSIONS;\n\tmemset(core->caps, 0, sizeof(*caps) * MAX_CODEC_NUM);\n\tmemcpy(core->caps, caps, sizeof(*caps) * entries);\n\n\treturn 0;\n}\n\nu32 hfi_parser(struct venus_core *core, struct venus_inst *inst, void *buf,\n\t       u32 size)\n{\n\tunsigned int words_count = size >> 2;\n\tu32 *word = buf, *data, codecs = 0, domain = 0;\n\tint ret;\n\n\tret = hfi_platform_parser(core, inst);\n\tif (!ret)\n\t\treturn HFI_ERR_NONE;\n\n\tif (size % 4)\n\t\treturn HFI_ERR_SYS_INSUFFICIENT_RESOURCES;\n\n\tparser_init(inst, &codecs, &domain);\n\n\tif (core->res->hfi_version > HFI_VERSION_1XX) {\n\t\tcore->codecs_count = 0;\n\t\tmemset(core->caps, 0, sizeof(core->caps));\n\t}\n\n\twhile (words_count) {\n\t\tdata = word + 1;\n\n\t\tswitch (*word) {\n\t\tcase HFI_PROPERTY_PARAM_CODEC_SUPPORTED:\n\t\t\tparse_codecs(core, data);\n\t\t\tinit_codecs(core);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_PARAM_MAX_SESSIONS_SUPPORTED:\n\t\t\tparse_max_sessions(core, data);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_PARAM_CODEC_MASK_SUPPORTED:\n\t\t\tparse_codecs_mask(&codecs, &domain, data);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_PARAM_UNCOMPRESSED_FORMAT_SUPPORTED:\n\t\t\tparse_raw_formats(core, codecs, domain, data);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_PARAM_CAPABILITY_SUPPORTED:\n\t\t\tparse_caps(core, codecs, domain, data);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_PARAM_PROFILE_LEVEL_SUPPORTED:\n\t\t\tparse_profile_level(core, codecs, domain, data);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_PARAM_BUFFER_ALLOC_MODE_SUPPORTED:\n\t\t\tparse_alloc_mode(core, codecs, domain, data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tword++;\n\t\twords_count--;\n\t}\n\n\tif (!core->max_sessions_supported)\n\t\tcore->max_sessions_supported = MAX_SESSIONS;\n\n\tparser_fini(inst, codecs, domain);\n\n\treturn HFI_ERR_NONE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}