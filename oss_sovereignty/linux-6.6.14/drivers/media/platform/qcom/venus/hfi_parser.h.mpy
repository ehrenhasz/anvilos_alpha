{
  "module_name": "hfi_parser.h",
  "hash_id": "6ca9890911f860d34292b689da66c6466de38526ee705ea44a12c650e1ec5fa4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/venus/hfi_parser.h",
  "human_readable_source": " \n \n#ifndef __VENUS_HFI_PARSER_H__\n#define __VENUS_HFI_PARSER_H__\n\n#include \"core.h\"\n\nu32 hfi_parser(struct venus_core *core, struct venus_inst *inst,\n\t       void *buf, u32 size);\n\n#define WHICH_CAP_MIN\t0\n#define WHICH_CAP_MAX\t1\n#define WHICH_CAP_STEP\t2\n\nstatic inline u32 get_cap(struct venus_inst *inst, u32 type, u32 which)\n{\n\tstruct venus_core *core = inst->core;\n\tstruct hfi_capability *cap = NULL;\n\tstruct hfi_plat_caps *caps;\n\tunsigned int i;\n\n\tcaps = venus_caps_by_codec(core, inst->hfi_codec, inst->session_type);\n\tif (!caps)\n\t\treturn 0;\n\n\tfor (i = 0; i < caps->num_caps; i++) {\n\t\tif (caps->caps[i].capability_type == type) {\n\t\t\tcap = &caps->caps[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!cap)\n\t\treturn 0;\n\n\tswitch (which) {\n\tcase WHICH_CAP_MIN:\n\t\treturn cap->min;\n\tcase WHICH_CAP_MAX:\n\t\treturn cap->max;\n\tcase WHICH_CAP_STEP:\n\t\treturn cap->step_size;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline u32 cap_min(struct venus_inst *inst, u32 type)\n{\n\treturn get_cap(inst, type, WHICH_CAP_MIN);\n}\n\nstatic inline u32 cap_max(struct venus_inst *inst, u32 type)\n{\n\treturn get_cap(inst, type, WHICH_CAP_MAX);\n}\n\nstatic inline u32 cap_step(struct venus_inst *inst, u32 type)\n{\n\treturn get_cap(inst, type, WHICH_CAP_STEP);\n}\n\nstatic inline u32 frame_width_min(struct venus_inst *inst)\n{\n\treturn cap_min(inst, HFI_CAPABILITY_FRAME_WIDTH);\n}\n\nstatic inline u32 frame_width_max(struct venus_inst *inst)\n{\n\treturn cap_max(inst, HFI_CAPABILITY_FRAME_WIDTH);\n}\n\nstatic inline u32 frame_width_step(struct venus_inst *inst)\n{\n\treturn cap_step(inst, HFI_CAPABILITY_FRAME_WIDTH);\n}\n\nstatic inline u32 frame_height_min(struct venus_inst *inst)\n{\n\treturn cap_min(inst, HFI_CAPABILITY_FRAME_HEIGHT);\n}\n\nstatic inline u32 frame_height_max(struct venus_inst *inst)\n{\n\treturn cap_max(inst, HFI_CAPABILITY_FRAME_HEIGHT);\n}\n\nstatic inline u32 frame_height_step(struct venus_inst *inst)\n{\n\treturn cap_step(inst, HFI_CAPABILITY_FRAME_HEIGHT);\n}\n\nstatic inline u32 frate_min(struct venus_inst *inst)\n{\n\treturn cap_min(inst, HFI_CAPABILITY_FRAMERATE);\n}\n\nstatic inline u32 frate_max(struct venus_inst *inst)\n{\n\treturn cap_max(inst, HFI_CAPABILITY_FRAMERATE);\n}\n\nstatic inline u32 frate_step(struct venus_inst *inst)\n{\n\treturn cap_step(inst, HFI_CAPABILITY_FRAMERATE);\n}\n\nstatic inline u32 core_num_max(struct venus_inst *inst)\n{\n\treturn cap_max(inst, HFI_CAPABILITY_MAX_VIDEOCORES);\n}\n\nstatic inline u32 mbs_per_frame_max(struct venus_inst *inst)\n{\n\treturn cap_max(inst, HFI_CAPABILITY_MBS_PER_FRAME);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}