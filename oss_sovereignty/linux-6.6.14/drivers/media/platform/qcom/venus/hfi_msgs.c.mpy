{
  "module_name": "hfi_msgs.c",
  "hash_id": "9e00846ac9f277a8d6da3e8ece8009049365dfc13b248e4ffd4e00263cf667e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/venus/hfi_msgs.c",
  "human_readable_source": "\n \n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/smem.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"core.h\"\n#include \"hfi.h\"\n#include \"hfi_helper.h\"\n#include \"hfi_msgs.h\"\n#include \"hfi_parser.h\"\n\n#define SMEM_IMG_VER_TBL\t469\n#define VER_STR_SZ\t\t128\n#define SMEM_IMG_OFFSET_VENUS\t(14 * 128)\n\nstatic void event_seq_changed(struct venus_core *core, struct venus_inst *inst,\n\t\t\t      struct hfi_msg_event_notify_pkt *pkt)\n{\n\tenum hfi_version ver = core->res->hfi_version;\n\tstruct hfi_event_data event = {0};\n\tint num_properties_changed;\n\tstruct hfi_framesize *frame_sz;\n\tstruct hfi_profile_level *profile_level;\n\tstruct hfi_bit_depth *pixel_depth;\n\tstruct hfi_pic_struct *pic_struct;\n\tstruct hfi_colour_space *colour_info;\n\tstruct hfi_buffer_requirements *bufreq;\n\tstruct hfi_extradata_input_crop *crop;\n\tstruct hfi_dpb_counts *dpb_count;\n\tu8 *data_ptr;\n\tu32 ptype;\n\n\tinst->error = HFI_ERR_NONE;\n\n\tswitch (pkt->event_data1) {\n\tcase HFI_EVENT_DATA_SEQUENCE_CHANGED_SUFFICIENT_BUF_RESOURCES:\n\tcase HFI_EVENT_DATA_SEQUENCE_CHANGED_INSUFFICIENT_BUF_RESOURCES:\n\t\tbreak;\n\tdefault:\n\t\tinst->error = HFI_ERR_SESSION_INVALID_PARAMETER;\n\t\tgoto done;\n\t}\n\n\tevent.event_type = pkt->event_data1;\n\n\tnum_properties_changed = pkt->event_data2;\n\tif (!num_properties_changed) {\n\t\tinst->error = HFI_ERR_SESSION_INSUFFICIENT_RESOURCES;\n\t\tgoto done;\n\t}\n\n\tdata_ptr = (u8 *)&pkt->ext_event_data[0];\n\tdo {\n\t\tptype = *((u32 *)data_ptr);\n\t\tswitch (ptype) {\n\t\tcase HFI_PROPERTY_PARAM_FRAME_SIZE:\n\t\t\tdata_ptr += sizeof(u32);\n\t\t\tframe_sz = (struct hfi_framesize *)data_ptr;\n\t\t\tevent.width = frame_sz->width;\n\t\t\tevent.height = frame_sz->height;\n\t\t\tdata_ptr += sizeof(*frame_sz);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_PARAM_PROFILE_LEVEL_CURRENT:\n\t\t\tdata_ptr += sizeof(u32);\n\t\t\tprofile_level = (struct hfi_profile_level *)data_ptr;\n\t\t\tevent.profile = profile_level->profile;\n\t\t\tevent.level = profile_level->level;\n\t\t\tdata_ptr += sizeof(*profile_level);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_PARAM_VDEC_PIXEL_BITDEPTH:\n\t\t\tdata_ptr += sizeof(u32);\n\t\t\tpixel_depth = (struct hfi_bit_depth *)data_ptr;\n\t\t\tevent.bit_depth = pixel_depth->bit_depth;\n\t\t\tdata_ptr += sizeof(*pixel_depth);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_PARAM_VDEC_PIC_STRUCT:\n\t\t\tdata_ptr += sizeof(u32);\n\t\t\tpic_struct = (struct hfi_pic_struct *)data_ptr;\n\t\t\tevent.pic_struct = pic_struct->progressive_only;\n\t\t\tdata_ptr += sizeof(*pic_struct);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_PARAM_VDEC_COLOUR_SPACE:\n\t\t\tdata_ptr += sizeof(u32);\n\t\t\tcolour_info = (struct hfi_colour_space *)data_ptr;\n\t\t\tevent.colour_space = colour_info->colour_space;\n\t\t\tdata_ptr += sizeof(*colour_info);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_CONFIG_VDEC_ENTROPY:\n\t\t\tdata_ptr += sizeof(u32);\n\t\t\tevent.entropy_mode = *(u32 *)data_ptr;\n\t\t\tdata_ptr += sizeof(u32);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_CONFIG_BUFFER_REQUIREMENTS:\n\t\t\tdata_ptr += sizeof(u32);\n\t\t\tbufreq = (struct hfi_buffer_requirements *)data_ptr;\n\t\t\tevent.buf_count = hfi_bufreq_get_count_min(bufreq, ver);\n\t\t\tdata_ptr += sizeof(*bufreq);\n\t\t\tbreak;\n\t\tcase HFI_INDEX_EXTRADATA_INPUT_CROP:\n\t\t\tdata_ptr += sizeof(u32);\n\t\t\tcrop = (struct hfi_extradata_input_crop *)data_ptr;\n\t\t\tevent.input_crop.left = crop->left;\n\t\t\tevent.input_crop.top = crop->top;\n\t\t\tevent.input_crop.width = crop->width;\n\t\t\tevent.input_crop.height = crop->height;\n\t\t\tdata_ptr += sizeof(*crop);\n\t\t\tbreak;\n\t\tcase HFI_PROPERTY_PARAM_VDEC_DPB_COUNTS:\n\t\t\tdata_ptr += sizeof(u32);\n\t\t\tdpb_count = (struct hfi_dpb_counts *)data_ptr;\n\t\t\tevent.buf_count = dpb_count->fw_min_cnt;\n\t\t\tdata_ptr += sizeof(*dpb_count);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tnum_properties_changed--;\n\t} while (num_properties_changed > 0);\n\ndone:\n\tinst->ops->event_notify(inst, EVT_SYS_EVENT_CHANGE, &event);\n}\n\nstatic void event_release_buffer_ref(struct venus_core *core,\n\t\t\t\t     struct venus_inst *inst,\n\t\t\t\t     struct hfi_msg_event_notify_pkt *pkt)\n{\n\tstruct hfi_event_data event = {0};\n\tstruct hfi_msg_event_release_buffer_ref_pkt *data;\n\n\tdata = (struct hfi_msg_event_release_buffer_ref_pkt *)\n\t\tpkt->ext_event_data;\n\n\tevent.event_type = HFI_EVENT_RELEASE_BUFFER_REFERENCE;\n\tevent.packet_buffer = data->packet_buffer;\n\tevent.extradata_buffer = data->extradata_buffer;\n\tevent.tag = data->output_tag;\n\n\tinst->error = HFI_ERR_NONE;\n\tinst->ops->event_notify(inst, EVT_SYS_EVENT_CHANGE, &event);\n}\n\nstatic void event_sys_error(struct venus_core *core, u32 event,\n\t\t\t    struct hfi_msg_event_notify_pkt *pkt)\n{\n\tif (pkt)\n\t\tdev_dbg(core->dev, VDBGH\n\t\t\t\"sys error (session id:%x, data1:%x, data2:%x)\\n\",\n\t\t\tpkt->shdr.session_id, pkt->event_data1,\n\t\t\tpkt->event_data2);\n\n\tcore->core_ops->event_notify(core, event);\n}\n\nstatic void\nevent_session_error(struct venus_core *core, struct venus_inst *inst,\n\t\t    struct hfi_msg_event_notify_pkt *pkt)\n{\n\tstruct device *dev = core->dev;\n\n\tdev_dbg(dev, VDBGH \"session error: event id:%x, session id:%x\\n\",\n\t\tpkt->event_data1, pkt->shdr.session_id);\n\n\tif (!inst)\n\t\treturn;\n\n\tswitch (pkt->event_data1) {\n\t \n\tcase HFI_ERR_SESSION_INVALID_SCALE_FACTOR:\n\tcase HFI_ERR_SESSION_UNSUPPORT_BUFFERTYPE:\n\tcase HFI_ERR_SESSION_UNSUPPORTED_SETTING:\n\tcase HFI_ERR_SESSION_UPSCALE_NOT_SUPPORTED:\n\t\tinst->error = HFI_ERR_NONE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"session error: event id:%x (%x), session id:%x\\n\",\n\t\t\tpkt->event_data1, pkt->event_data2,\n\t\t\tpkt->shdr.session_id);\n\n\t\tinst->error = pkt->event_data1;\n\t\tinst->ops->event_notify(inst, EVT_SESSION_ERROR, NULL);\n\t\tbreak;\n\t}\n}\n\nstatic void hfi_event_notify(struct venus_core *core, struct venus_inst *inst,\n\t\t\t     void *packet)\n{\n\tstruct hfi_msg_event_notify_pkt *pkt = packet;\n\n\tif (!packet)\n\t\treturn;\n\n\tswitch (pkt->event_id) {\n\tcase HFI_EVENT_SYS_ERROR:\n\t\tevent_sys_error(core, EVT_SYS_ERROR, pkt);\n\t\tbreak;\n\tcase HFI_EVENT_SESSION_ERROR:\n\t\tevent_session_error(core, inst, pkt);\n\t\tbreak;\n\tcase HFI_EVENT_SESSION_SEQUENCE_CHANGED:\n\t\tevent_seq_changed(core, inst, pkt);\n\t\tbreak;\n\tcase HFI_EVENT_RELEASE_BUFFER_REFERENCE:\n\t\tevent_release_buffer_ref(core, inst, pkt);\n\t\tbreak;\n\tcase HFI_EVENT_SESSION_PROPERTY_CHANGED:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void hfi_sys_init_done(struct venus_core *core, struct venus_inst *inst,\n\t\t\t      void *packet)\n{\n\tstruct hfi_msg_sys_init_done_pkt *pkt = packet;\n\tint rem_bytes;\n\tu32 error;\n\n\terror = pkt->error_type;\n\tif (error != HFI_ERR_NONE)\n\t\tgoto done;\n\n\tif (!pkt->num_properties) {\n\t\terror = HFI_ERR_SYS_INVALID_PARAMETER;\n\t\tgoto done;\n\t}\n\n\trem_bytes = pkt->hdr.size - sizeof(*pkt);\n\tif (rem_bytes <= 0) {\n\t\t \n\t\terror = HFI_ERR_SYS_INSUFFICIENT_RESOURCES;\n\t\tgoto done;\n\t}\n\n\terror = hfi_parser(core, inst, pkt->data, rem_bytes);\n\ndone:\n\tcore->error = error;\n\tcomplete(&core->done);\n}\n\nstatic void\nsys_get_prop_image_version(struct venus_core *core,\n\t\t\t   struct hfi_msg_sys_property_info_pkt *pkt)\n{\n\tstruct device *dev = core->dev;\n\tu8 *smem_tbl_ptr;\n\tu8 *img_ver;\n\tint req_bytes;\n\tsize_t smem_blk_sz;\n\tint ret;\n\n\treq_bytes = pkt->hdr.size - sizeof(*pkt);\n\n\tif (req_bytes < VER_STR_SZ || !pkt->data[0] || pkt->num_properties > 1)\n\t\t \n\t\treturn;\n\n\timg_ver = pkt->data;\n\tif (!img_ver)\n\t\treturn;\n\n\tret = sscanf(img_ver, \"14:video-firmware.%u.%u-%u\",\n\t\t     &core->venus_ver.major, &core->venus_ver.minor, &core->venus_ver.rev);\n\tif (ret)\n\t\tgoto done;\n\n\tret = sscanf(img_ver, \"14:VIDEO.VPU.%u.%u-%u\",\n\t\t     &core->venus_ver.major, &core->venus_ver.minor, &core->venus_ver.rev);\n\tif (ret)\n\t\tgoto done;\n\n\tret = sscanf(img_ver, \"14:VIDEO.VE.%u.%u-%u\",\n\t\t     &core->venus_ver.major, &core->venus_ver.minor, &core->venus_ver.rev);\n\tif (ret)\n\t\tgoto done;\n\n\tdev_err(dev, VDBGL \"error reading F/W version\\n\");\n\treturn;\n\ndone:\n\tdev_dbg(dev, VDBGL \"F/W version: %s, major %u, minor %u, revision %u\\n\",\n\t\timg_ver, core->venus_ver.major, core->venus_ver.minor, core->venus_ver.rev);\n\n\tsmem_tbl_ptr = qcom_smem_get(QCOM_SMEM_HOST_ANY,\n\t\tSMEM_IMG_VER_TBL, &smem_blk_sz);\n\tif (!IS_ERR(smem_tbl_ptr) && smem_blk_sz >= SMEM_IMG_OFFSET_VENUS + VER_STR_SZ)\n\t\tmemcpy(smem_tbl_ptr + SMEM_IMG_OFFSET_VENUS,\n\t\t       img_ver, VER_STR_SZ);\n}\n\nstatic void hfi_sys_property_info(struct venus_core *core,\n\t\t\t\t  struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_sys_property_info_pkt *pkt = packet;\n\tstruct device *dev = core->dev;\n\n\tif (!pkt->num_properties) {\n\t\tdev_dbg(dev, VDBGL \"no properties\\n\");\n\t\treturn;\n\t}\n\n\tswitch (pkt->property) {\n\tcase HFI_PROPERTY_SYS_IMAGE_VERSION:\n\t\tsys_get_prop_image_version(core, pkt);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, VDBGL \"unknown property data\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void hfi_sys_rel_resource_done(struct venus_core *core,\n\t\t\t\t      struct venus_inst *inst,\n\t\t\t\t      void *packet)\n{\n\tstruct hfi_msg_sys_release_resource_done_pkt *pkt = packet;\n\n\tcore->error = pkt->error_type;\n\tcomplete(&core->done);\n}\n\nstatic void hfi_sys_ping_done(struct venus_core *core, struct venus_inst *inst,\n\t\t\t      void *packet)\n{\n\tstruct hfi_msg_sys_ping_ack_pkt *pkt = packet;\n\n\tcore->error = HFI_ERR_NONE;\n\n\tif (pkt->client_data != 0xbeef)\n\t\tcore->error = HFI_ERR_SYS_FATAL;\n\n\tcomplete(&core->done);\n}\n\nstatic void hfi_sys_idle_done(struct venus_core *core, struct venus_inst *inst,\n\t\t\t      void *packet)\n{\n\tdev_dbg(core->dev, VDBGL \"sys idle\\n\");\n}\n\nstatic void hfi_sys_pc_prepare_done(struct venus_core *core,\n\t\t\t\t    struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_sys_pc_prep_done_pkt *pkt = packet;\n\n\tdev_dbg(core->dev, VDBGL \"pc prepare done (error %x)\\n\",\n\t\tpkt->error_type);\n}\n\nstatic unsigned int\nsession_get_prop_profile_level(struct hfi_msg_session_property_info_pkt *pkt,\n\t\t\t       struct hfi_profile_level *profile_level)\n{\n\tstruct hfi_profile_level *hfi;\n\tu32 req_bytes;\n\n\treq_bytes = pkt->shdr.hdr.size - sizeof(*pkt);\n\n\tif (!req_bytes || req_bytes % sizeof(struct hfi_profile_level))\n\t\t \n\t\treturn HFI_ERR_SESSION_INVALID_PARAMETER;\n\n\thfi = (struct hfi_profile_level *)&pkt->data[0];\n\tprofile_level->profile = hfi->profile;\n\tprofile_level->level = hfi->level;\n\n\treturn HFI_ERR_NONE;\n}\n\nstatic unsigned int\nsession_get_prop_buf_req(struct hfi_msg_session_property_info_pkt *pkt,\n\t\t\t struct hfi_buffer_requirements *bufreq)\n{\n\tstruct hfi_buffer_requirements *buf_req;\n\tu32 req_bytes;\n\tunsigned int idx = 0;\n\n\treq_bytes = pkt->shdr.hdr.size - sizeof(*pkt);\n\n\tif (!req_bytes || req_bytes % sizeof(*buf_req) || !pkt->data[0])\n\t\t \n\t\treturn HFI_ERR_SESSION_INVALID_PARAMETER;\n\n\tbuf_req = (struct hfi_buffer_requirements *)&pkt->data[0];\n\tif (!buf_req)\n\t\treturn HFI_ERR_SESSION_INVALID_PARAMETER;\n\n\twhile (req_bytes) {\n\t\tmemcpy(&bufreq[idx], buf_req, sizeof(*bufreq));\n\t\tidx++;\n\n\t\tif (idx >= HFI_BUFFER_TYPE_MAX)\n\t\t\treturn HFI_ERR_SESSION_INVALID_PARAMETER;\n\n\t\treq_bytes -= sizeof(struct hfi_buffer_requirements);\n\t\tbuf_req++;\n\t}\n\n\treturn HFI_ERR_NONE;\n}\n\nstatic void hfi_session_prop_info(struct venus_core *core,\n\t\t\t\t  struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_session_property_info_pkt *pkt = packet;\n\tstruct device *dev = core->dev;\n\tunion hfi_get_property *hprop = &inst->hprop;\n\tunsigned int error = HFI_ERR_NONE;\n\n\tif (!pkt->num_properties) {\n\t\terror = HFI_ERR_SESSION_INVALID_PARAMETER;\n\t\tdev_err(dev, \"%s: no properties\\n\", __func__);\n\t\tgoto done;\n\t}\n\n\tswitch (pkt->property) {\n\tcase HFI_PROPERTY_CONFIG_BUFFER_REQUIREMENTS:\n\t\tmemset(hprop->bufreq, 0, sizeof(hprop->bufreq));\n\t\terror = session_get_prop_buf_req(pkt, hprop->bufreq);\n\t\tbreak;\n\tcase HFI_PROPERTY_PARAM_PROFILE_LEVEL_CURRENT:\n\t\tmemset(&hprop->profile_level, 0, sizeof(hprop->profile_level));\n\t\terror = session_get_prop_profile_level(pkt,\n\t\t\t\t\t\t       &hprop->profile_level);\n\t\tbreak;\n\tcase HFI_PROPERTY_CONFIG_VDEC_ENTROPY:\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, VDBGM \"unknown property id:%x\\n\", pkt->property);\n\t\treturn;\n\t}\n\ndone:\n\tinst->error = error;\n\tcomplete(&inst->done);\n}\n\nstatic void hfi_session_init_done(struct venus_core *core,\n\t\t\t\t  struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_session_init_done_pkt *pkt = packet;\n\tint rem_bytes;\n\tu32 error;\n\n\terror = pkt->error_type;\n\tif (error != HFI_ERR_NONE)\n\t\tgoto done;\n\n\tif (!IS_V1(core))\n\t\tgoto done;\n\n\trem_bytes = pkt->shdr.hdr.size - sizeof(*pkt);\n\tif (rem_bytes <= 0) {\n\t\terror = HFI_ERR_SESSION_INSUFFICIENT_RESOURCES;\n\t\tgoto done;\n\t}\n\n\terror = hfi_parser(core, inst, pkt->data, rem_bytes);\ndone:\n\tinst->error = error;\n\tcomplete(&inst->done);\n}\n\nstatic void hfi_session_load_res_done(struct venus_core *core,\n\t\t\t\t      struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_session_load_resources_done_pkt *pkt = packet;\n\n\tinst->error = pkt->error_type;\n\tcomplete(&inst->done);\n}\n\nstatic void hfi_session_flush_done(struct venus_core *core,\n\t\t\t\t   struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_session_flush_done_pkt *pkt = packet;\n\n\tinst->error = pkt->error_type;\n\tcomplete(&inst->done);\n\tif (inst->ops->flush_done)\n\t\tinst->ops->flush_done(inst);\n}\n\nstatic void hfi_session_etb_done(struct venus_core *core,\n\t\t\t\t struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_session_empty_buffer_done_pkt *pkt = packet;\n\n\tinst->error = pkt->error_type;\n\tinst->ops->buf_done(inst, HFI_BUFFER_INPUT, pkt->input_tag,\n\t\t\t    pkt->filled_len, pkt->offset, 0, 0, 0);\n}\n\nstatic void hfi_session_ftb_done(struct venus_core *core,\n\t\t\t\t struct venus_inst *inst, void *packet)\n{\n\tu32 session_type = inst->session_type;\n\tu64 timestamp_us = 0;\n\tu32 timestamp_hi = 0, timestamp_lo = 0;\n\tunsigned int error;\n\tu32 flags = 0, hfi_flags = 0, offset = 0, filled_len = 0;\n\tu32 pic_type = 0, buffer_type = 0, output_tag = -1;\n\n\tif (session_type == VIDC_SESSION_TYPE_ENC) {\n\t\tstruct hfi_msg_session_fbd_compressed_pkt *pkt = packet;\n\n\t\ttimestamp_hi = pkt->time_stamp_hi;\n\t\ttimestamp_lo = pkt->time_stamp_lo;\n\t\thfi_flags = pkt->flags;\n\t\toffset = pkt->offset;\n\t\tfilled_len = pkt->filled_len;\n\t\tpic_type = pkt->picture_type;\n\t\toutput_tag = pkt->output_tag;\n\t\tbuffer_type = HFI_BUFFER_OUTPUT;\n\n\t\terror = pkt->error_type;\n\t} else if (session_type == VIDC_SESSION_TYPE_DEC) {\n\t\tstruct hfi_msg_session_fbd_uncompressed_plane0_pkt *pkt =\n\t\t\tpacket;\n\n\t\ttimestamp_hi = pkt->time_stamp_hi;\n\t\ttimestamp_lo = pkt->time_stamp_lo;\n\t\thfi_flags = pkt->flags;\n\t\toffset = pkt->offset;\n\t\tfilled_len = pkt->filled_len;\n\t\tpic_type = pkt->picture_type;\n\t\toutput_tag = pkt->output_tag;\n\n\t\tif (pkt->stream_id == 0)\n\t\t\tbuffer_type = HFI_BUFFER_OUTPUT;\n\t\telse if (pkt->stream_id == 1)\n\t\t\tbuffer_type = HFI_BUFFER_OUTPUT2;\n\n\t\terror = pkt->error_type;\n\t} else {\n\t\terror = HFI_ERR_SESSION_INVALID_PARAMETER;\n\t}\n\n\tif (buffer_type != HFI_BUFFER_OUTPUT &&\n\t    buffer_type != HFI_BUFFER_OUTPUT2)\n\t\tgoto done;\n\n\tif (hfi_flags & HFI_BUFFERFLAG_EOS)\n\t\tflags |= V4L2_BUF_FLAG_LAST;\n\n\tswitch (pic_type) {\n\tcase HFI_PICTURE_IDR:\n\tcase HFI_PICTURE_I:\n\t\tflags |= V4L2_BUF_FLAG_KEYFRAME;\n\t\tbreak;\n\tcase HFI_PICTURE_P:\n\t\tflags |= V4L2_BUF_FLAG_PFRAME;\n\t\tbreak;\n\tcase HFI_PICTURE_B:\n\t\tflags |= V4L2_BUF_FLAG_BFRAME;\n\t\tbreak;\n\tcase HFI_FRAME_NOTCODED:\n\tcase HFI_UNUSED_PICT:\n\tcase HFI_FRAME_YUV:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!(hfi_flags & HFI_BUFFERFLAG_TIMESTAMPINVALID) && filled_len) {\n\t\ttimestamp_us = timestamp_hi;\n\t\ttimestamp_us = (timestamp_us << 32) | timestamp_lo;\n\t}\n\ndone:\n\tinst->error = error;\n\tinst->ops->buf_done(inst, buffer_type, output_tag, filled_len,\n\t\t\t    offset, flags, hfi_flags, timestamp_us);\n}\n\nstatic void hfi_session_start_done(struct venus_core *core,\n\t\t\t\t   struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_session_start_done_pkt *pkt = packet;\n\n\tinst->error = pkt->error_type;\n\tcomplete(&inst->done);\n}\n\nstatic void hfi_session_stop_done(struct venus_core *core,\n\t\t\t\t  struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_session_stop_done_pkt *pkt = packet;\n\n\tinst->error = pkt->error_type;\n\tcomplete(&inst->done);\n}\n\nstatic void hfi_session_rel_res_done(struct venus_core *core,\n\t\t\t\t     struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_session_release_resources_done_pkt *pkt = packet;\n\n\tinst->error = pkt->error_type;\n\tcomplete(&inst->done);\n}\n\nstatic void hfi_session_rel_buf_done(struct venus_core *core,\n\t\t\t\t     struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_session_release_buffers_done_pkt *pkt = packet;\n\n\tinst->error = pkt->error_type;\n\tcomplete(&inst->done);\n}\n\nstatic void hfi_session_end_done(struct venus_core *core,\n\t\t\t\t struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_session_end_done_pkt *pkt = packet;\n\n\tinst->error = pkt->error_type;\n\tcomplete(&inst->done);\n}\n\nstatic void hfi_session_abort_done(struct venus_core *core,\n\t\t\t\t   struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_sys_session_abort_done_pkt *pkt = packet;\n\n\tinst->error = pkt->error_type;\n\tcomplete(&inst->done);\n}\n\nstatic void hfi_session_get_seq_hdr_done(struct venus_core *core,\n\t\t\t\t\t struct venus_inst *inst, void *packet)\n{\n\tstruct hfi_msg_session_get_sequence_hdr_done_pkt *pkt = packet;\n\n\tinst->error = pkt->error_type;\n\tcomplete(&inst->done);\n}\n\nstruct hfi_done_handler {\n\tu32 pkt;\n\tu32 pkt_sz;\n\tu32 pkt_sz2;\n\tvoid (*done)(struct venus_core *, struct venus_inst *, void *);\n\tbool is_sys_pkt;\n};\n\nstatic const struct hfi_done_handler handlers[] = {\n\t{.pkt = HFI_MSG_EVENT_NOTIFY,\n\t .pkt_sz = sizeof(struct hfi_msg_event_notify_pkt),\n\t .done = hfi_event_notify,\n\t},\n\t{.pkt = HFI_MSG_SYS_INIT,\n\t .pkt_sz = sizeof(struct hfi_msg_sys_init_done_pkt),\n\t .done = hfi_sys_init_done,\n\t .is_sys_pkt = true,\n\t},\n\t{.pkt = HFI_MSG_SYS_PROPERTY_INFO,\n\t .pkt_sz = sizeof(struct hfi_msg_sys_property_info_pkt),\n\t .done = hfi_sys_property_info,\n\t .is_sys_pkt = true,\n\t},\n\t{.pkt = HFI_MSG_SYS_RELEASE_RESOURCE,\n\t .pkt_sz = sizeof(struct hfi_msg_sys_release_resource_done_pkt),\n\t .done = hfi_sys_rel_resource_done,\n\t .is_sys_pkt = true,\n\t},\n\t{.pkt = HFI_MSG_SYS_PING_ACK,\n\t .pkt_sz = sizeof(struct hfi_msg_sys_ping_ack_pkt),\n\t .done = hfi_sys_ping_done,\n\t .is_sys_pkt = true,\n\t},\n\t{.pkt = HFI_MSG_SYS_IDLE,\n\t .pkt_sz = sizeof(struct hfi_msg_sys_idle_pkt),\n\t .done = hfi_sys_idle_done,\n\t .is_sys_pkt = true,\n\t},\n\t{.pkt = HFI_MSG_SYS_PC_PREP,\n\t .pkt_sz = sizeof(struct hfi_msg_sys_pc_prep_done_pkt),\n\t .done = hfi_sys_pc_prepare_done,\n\t .is_sys_pkt = true,\n\t},\n\t{.pkt = HFI_MSG_SYS_SESSION_INIT,\n\t .pkt_sz = sizeof(struct hfi_msg_session_init_done_pkt),\n\t .done = hfi_session_init_done,\n\t},\n\t{.pkt = HFI_MSG_SYS_SESSION_END,\n\t .pkt_sz = sizeof(struct hfi_msg_session_end_done_pkt),\n\t .done = hfi_session_end_done,\n\t},\n\t{.pkt = HFI_MSG_SESSION_LOAD_RESOURCES,\n\t .pkt_sz = sizeof(struct hfi_msg_session_load_resources_done_pkt),\n\t .done = hfi_session_load_res_done,\n\t},\n\t{.pkt = HFI_MSG_SESSION_START,\n\t .pkt_sz = sizeof(struct hfi_msg_session_start_done_pkt),\n\t .done = hfi_session_start_done,\n\t},\n\t{.pkt = HFI_MSG_SESSION_STOP,\n\t .pkt_sz = sizeof(struct hfi_msg_session_stop_done_pkt),\n\t .done = hfi_session_stop_done,\n\t},\n\t{.pkt = HFI_MSG_SYS_SESSION_ABORT,\n\t .pkt_sz = sizeof(struct hfi_msg_sys_session_abort_done_pkt),\n\t .done = hfi_session_abort_done,\n\t},\n\t{.pkt = HFI_MSG_SESSION_EMPTY_BUFFER,\n\t .pkt_sz = sizeof(struct hfi_msg_session_empty_buffer_done_pkt),\n\t .done = hfi_session_etb_done,\n\t},\n\t{.pkt = HFI_MSG_SESSION_FILL_BUFFER,\n\t .pkt_sz = sizeof(struct hfi_msg_session_fbd_uncompressed_plane0_pkt),\n\t .pkt_sz2 = sizeof(struct hfi_msg_session_fbd_compressed_pkt),\n\t .done = hfi_session_ftb_done,\n\t},\n\t{.pkt = HFI_MSG_SESSION_FLUSH,\n\t .pkt_sz = sizeof(struct hfi_msg_session_flush_done_pkt),\n\t .done = hfi_session_flush_done,\n\t},\n\t{.pkt = HFI_MSG_SESSION_PROPERTY_INFO,\n\t .pkt_sz = sizeof(struct hfi_msg_session_property_info_pkt),\n\t .done = hfi_session_prop_info,\n\t},\n\t{.pkt = HFI_MSG_SESSION_RELEASE_RESOURCES,\n\t .pkt_sz = sizeof(struct hfi_msg_session_release_resources_done_pkt),\n\t .done = hfi_session_rel_res_done,\n\t},\n\t{.pkt = HFI_MSG_SESSION_GET_SEQUENCE_HEADER,\n\t .pkt_sz = sizeof(struct hfi_msg_session_get_sequence_hdr_done_pkt),\n\t .done = hfi_session_get_seq_hdr_done,\n\t},\n\t{.pkt = HFI_MSG_SESSION_RELEASE_BUFFERS,\n\t .pkt_sz = sizeof(struct hfi_msg_session_release_buffers_done_pkt),\n\t .done = hfi_session_rel_buf_done,\n\t},\n};\n\nvoid hfi_process_watchdog_timeout(struct venus_core *core)\n{\n\tevent_sys_error(core, EVT_SYS_WATCHDOG_TIMEOUT, NULL);\n}\n\nstatic struct venus_inst *to_instance(struct venus_core *core, u32 session_id)\n{\n\tstruct venus_inst *inst;\n\n\tmutex_lock(&core->lock);\n\tlist_for_each_entry(inst, &core->instances, list)\n\t\tif (hash32_ptr(inst) == session_id) {\n\t\t\tmutex_unlock(&core->lock);\n\t\t\treturn inst;\n\t\t}\n\tmutex_unlock(&core->lock);\n\n\treturn NULL;\n}\n\nu32 hfi_process_msg_packet(struct venus_core *core, struct hfi_pkt_hdr *hdr)\n{\n\tconst struct hfi_done_handler *handler;\n\tstruct device *dev = core->dev;\n\tstruct venus_inst *inst;\n\tbool found = false;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(handlers); i++) {\n\t\thandler = &handlers[i];\n\t\tif (handler->pkt != hdr->pkt_type)\n\t\t\tcontinue;\n\t\tfound = true;\n\t\tbreak;\n\t}\n\n\tif (!found)\n\t\treturn hdr->pkt_type;\n\n\tif (hdr->size && hdr->size < handler->pkt_sz &&\n\t    hdr->size < handler->pkt_sz2) {\n\t\tdev_err(dev, \"bad packet size (%d should be %d, pkt type:%x)\\n\",\n\t\t\thdr->size, handler->pkt_sz, hdr->pkt_type);\n\n\t\treturn hdr->pkt_type;\n\t}\n\n\tif (handler->is_sys_pkt) {\n\t\tinst = NULL;\n\t} else {\n\t\tstruct hfi_session_pkt *pkt;\n\n\t\tpkt = (struct hfi_session_pkt *)hdr;\n\t\tinst = to_instance(core, pkt->shdr.session_id);\n\n\t\tif (!inst)\n\t\t\tdev_warn(dev, \"no valid instance(pkt session_id:%x, pkt:%x)\\n\",\n\t\t\t\t pkt->shdr.session_id,\n\t\t\t\t handler ? handler->pkt : 0);\n\n\t\t \n\t\tif (!inst && hdr->pkt_type != HFI_MSG_EVENT_NOTIFY) {\n\t\t\tdev_err(dev, \"got invalid session id:%x\\n\",\n\t\t\t\tpkt->shdr.session_id);\n\t\t\tgoto invalid_session;\n\t\t}\n\t}\n\n\thandler->done(core, inst, hdr);\n\ninvalid_session:\n\treturn hdr->pkt_type;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}