{
  "module_name": "core.c",
  "hash_id": "33ea998ab478bea09ca4b0f871d49c331e8a8649e67f49d1c24b29572754bc81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/venus/core.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/interconnect.h>\n#include <linux/io.h>\n#include <linux/ioctl.h>\n#include <linux/delay.h>\n#include <linux/devcoredump.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pm_runtime.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"core.h\"\n#include \"firmware.h\"\n#include \"pm_helpers.h\"\n#include \"hfi_venus_io.h\"\n\nstatic void venus_coredump(struct venus_core *core)\n{\n\tstruct device *dev;\n\tphys_addr_t mem_phys;\n\tsize_t mem_size;\n\tvoid *mem_va;\n\tvoid *data;\n\n\tdev = core->dev;\n\tmem_phys = core->fw.mem_phys;\n\tmem_size = core->fw.mem_size;\n\n\tmem_va = memremap(mem_phys, mem_size, MEMREMAP_WC);\n\tif (!mem_va)\n\t\treturn;\n\n\tdata = vmalloc(mem_size);\n\tif (!data) {\n\t\tmemunmap(mem_va);\n\t\treturn;\n\t}\n\n\tmemcpy(data, mem_va, mem_size);\n\tmemunmap(mem_va);\n\tdev_coredumpv(dev, data, mem_size, GFP_KERNEL);\n}\n\nstatic void venus_event_notify(struct venus_core *core, u32 event)\n{\n\tstruct venus_inst *inst;\n\n\tswitch (event) {\n\tcase EVT_SYS_WATCHDOG_TIMEOUT:\n\tcase EVT_SYS_ERROR:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tmutex_lock(&core->lock);\n\tset_bit(0, &core->sys_error);\n\tlist_for_each_entry(inst, &core->instances, list)\n\t\tinst->ops->event_notify(inst, EVT_SESSION_ERROR, NULL);\n\tmutex_unlock(&core->lock);\n\n\tdisable_irq_nosync(core->irq);\n\tschedule_delayed_work(&core->work, msecs_to_jiffies(10));\n}\n\nstatic const struct hfi_core_ops venus_core_ops = {\n\t.event_notify = venus_event_notify,\n};\n\n#define RPM_WAIT_FOR_IDLE_MAX_ATTEMPTS 10\n\nstatic void venus_sys_error_handler(struct work_struct *work)\n{\n\tstruct venus_core *core =\n\t\t\tcontainer_of(work, struct venus_core, work.work);\n\tint ret, i, max_attempts = RPM_WAIT_FOR_IDLE_MAX_ATTEMPTS;\n\tconst char *err_msg = \"\";\n\tbool failed = false;\n\n\tret = pm_runtime_get_sync(core->dev);\n\tif (ret < 0) {\n\t\terr_msg = \"resume runtime PM\";\n\t\tmax_attempts = 0;\n\t\tfailed = true;\n\t}\n\n\tcore->ops->core_deinit(core);\n\tcore->state = CORE_UNINIT;\n\n\tfor (i = 0; i < max_attempts; i++) {\n\t\tif (!pm_runtime_active(core->dev_dec) && !pm_runtime_active(core->dev_enc))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\n\tmutex_lock(&core->lock);\n\n\tvenus_shutdown(core);\n\n\tvenus_coredump(core);\n\n\tpm_runtime_put_sync(core->dev);\n\n\tfor (i = 0; i < max_attempts; i++) {\n\t\tif (!core->pmdomains[0] || !pm_runtime_active(core->pmdomains[0]))\n\t\t\tbreak;\n\t\tusleep_range(1000, 1500);\n\t}\n\n\thfi_reinit(core);\n\n\tret = pm_runtime_get_sync(core->dev);\n\tif (ret < 0) {\n\t\terr_msg = \"resume runtime PM\";\n\t\tfailed = true;\n\t}\n\n\tret = venus_boot(core);\n\tif (ret && !failed) {\n\t\terr_msg = \"boot Venus\";\n\t\tfailed = true;\n\t}\n\n\tret = hfi_core_resume(core, true);\n\tif (ret && !failed) {\n\t\terr_msg = \"resume HFI\";\n\t\tfailed = true;\n\t}\n\n\tenable_irq(core->irq);\n\n\tmutex_unlock(&core->lock);\n\n\tret = hfi_core_init(core);\n\tif (ret && !failed) {\n\t\terr_msg = \"init HFI\";\n\t\tfailed = true;\n\t}\n\n\tpm_runtime_put_sync(core->dev);\n\n\tif (failed) {\n\t\tdisable_irq_nosync(core->irq);\n\t\tdev_warn_ratelimited(core->dev,\n\t\t\t\t     \"System error has occurred, recovery failed to %s\\n\",\n\t\t\t\t     err_msg);\n\t\tschedule_delayed_work(&core->work, msecs_to_jiffies(10));\n\t\treturn;\n\t}\n\n\tdev_warn(core->dev, \"system error has occurred (recovered)\\n\");\n\n\tmutex_lock(&core->lock);\n\tclear_bit(0, &core->sys_error);\n\twake_up_all(&core->sys_err_done);\n\tmutex_unlock(&core->lock);\n}\n\nstatic u32 to_v4l2_codec_type(u32 codec)\n{\n\tswitch (codec) {\n\tcase HFI_VIDEO_CODEC_H264:\n\t\treturn V4L2_PIX_FMT_H264;\n\tcase HFI_VIDEO_CODEC_H263:\n\t\treturn V4L2_PIX_FMT_H263;\n\tcase HFI_VIDEO_CODEC_MPEG1:\n\t\treturn V4L2_PIX_FMT_MPEG1;\n\tcase HFI_VIDEO_CODEC_MPEG2:\n\t\treturn V4L2_PIX_FMT_MPEG2;\n\tcase HFI_VIDEO_CODEC_MPEG4:\n\t\treturn V4L2_PIX_FMT_MPEG4;\n\tcase HFI_VIDEO_CODEC_VC1:\n\t\treturn V4L2_PIX_FMT_VC1_ANNEX_G;\n\tcase HFI_VIDEO_CODEC_VP8:\n\t\treturn V4L2_PIX_FMT_VP8;\n\tcase HFI_VIDEO_CODEC_VP9:\n\t\treturn V4L2_PIX_FMT_VP9;\n\tcase HFI_VIDEO_CODEC_DIVX:\n\tcase HFI_VIDEO_CODEC_DIVX_311:\n\t\treturn V4L2_PIX_FMT_XVID;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int venus_enumerate_codecs(struct venus_core *core, u32 type)\n{\n\tconst struct hfi_inst_ops dummy_ops = {};\n\tstruct venus_inst *inst;\n\tu32 codec, codecs;\n\tunsigned int i;\n\tint ret;\n\n\tif (core->res->hfi_version != HFI_VERSION_1XX)\n\t\treturn 0;\n\n\tinst = kzalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&inst->lock);\n\tinst->core = core;\n\tinst->session_type = type;\n\tif (type == VIDC_SESSION_TYPE_DEC)\n\t\tcodecs = core->dec_codecs;\n\telse\n\t\tcodecs = core->enc_codecs;\n\n\tret = hfi_session_create(inst, &dummy_ops);\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = 0; i < MAX_CODEC_NUM; i++) {\n\t\tcodec = (1UL << i) & codecs;\n\t\tif (!codec)\n\t\t\tcontinue;\n\n\t\tret = hfi_session_init(inst, to_v4l2_codec_type(codec));\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tret = hfi_session_deinit(inst);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\ndone:\n\thfi_session_destroy(inst);\nerr:\n\tmutex_destroy(&inst->lock);\n\tkfree(inst);\n\n\treturn ret;\n}\n\nstatic void venus_assign_register_offsets(struct venus_core *core)\n{\n\tif (IS_IRIS2(core) || IS_IRIS2_1(core)) {\n\t\tcore->vbif_base = core->base + VBIF_BASE;\n\t\tcore->cpu_base = core->base + CPU_BASE_V6;\n\t\tcore->cpu_cs_base = core->base + CPU_CS_BASE_V6;\n\t\tcore->cpu_ic_base = core->base + CPU_IC_BASE_V6;\n\t\tcore->wrapper_base = core->base + WRAPPER_BASE_V6;\n\t\tcore->wrapper_tz_base = core->base + WRAPPER_TZ_BASE_V6;\n\t\tcore->aon_base = core->base + AON_BASE_V6;\n\t} else {\n\t\tcore->vbif_base = core->base + VBIF_BASE;\n\t\tcore->cpu_base = core->base + CPU_BASE;\n\t\tcore->cpu_cs_base = core->base + CPU_CS_BASE;\n\t\tcore->cpu_ic_base = core->base + CPU_IC_BASE;\n\t\tcore->wrapper_base = core->base + WRAPPER_BASE;\n\t\tcore->wrapper_tz_base = NULL;\n\t\tcore->aon_base = NULL;\n\t}\n}\n\nstatic irqreturn_t venus_isr_thread(int irq, void *dev_id)\n{\n\tstruct venus_core *core = dev_id;\n\tirqreturn_t ret;\n\n\tret = hfi_isr_thread(irq, dev_id);\n\n\tif (ret == IRQ_HANDLED && venus_fault_inject_ssr())\n\t\thfi_core_trigger_ssr(core, HFI_TEST_SSR_SW_ERR_FATAL);\n\n\treturn ret;\n}\n\nstatic int venus_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct venus_core *core;\n\tint ret;\n\n\tcore = devm_kzalloc(dev, sizeof(*core), GFP_KERNEL);\n\tif (!core)\n\t\treturn -ENOMEM;\n\n\tcore->dev = dev;\n\n\tcore->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(core->base))\n\t\treturn PTR_ERR(core->base);\n\n\tcore->video_path = devm_of_icc_get(dev, \"video-mem\");\n\tif (IS_ERR(core->video_path))\n\t\treturn PTR_ERR(core->video_path);\n\n\tcore->cpucfg_path = devm_of_icc_get(dev, \"cpu-cfg\");\n\tif (IS_ERR(core->cpucfg_path))\n\t\treturn PTR_ERR(core->cpucfg_path);\n\n\tcore->irq = platform_get_irq(pdev, 0);\n\tif (core->irq < 0)\n\t\treturn core->irq;\n\n\tcore->res = of_device_get_match_data(dev);\n\tif (!core->res)\n\t\treturn -ENODEV;\n\n\tmutex_init(&core->pm_lock);\n\n\tcore->pm_ops = venus_pm_get(core->res->hfi_version);\n\tif (!core->pm_ops)\n\t\treturn -ENODEV;\n\n\tif (core->pm_ops->core_get) {\n\t\tret = core->pm_ops->core_get(core);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = dma_set_mask_and_coherent(dev, core->res->dma_mask);\n\tif (ret)\n\t\tgoto err_core_put;\n\n\tdma_set_max_seg_size(dev, UINT_MAX);\n\n\tINIT_LIST_HEAD(&core->instances);\n\tmutex_init(&core->lock);\n\tINIT_DELAYED_WORK(&core->work, venus_sys_error_handler);\n\tinit_waitqueue_head(&core->sys_err_done);\n\n\tret = devm_request_threaded_irq(dev, core->irq, hfi_isr, venus_isr_thread,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"venus\", core);\n\tif (ret)\n\t\tgoto err_core_put;\n\n\tret = hfi_create(core, &venus_core_ops);\n\tif (ret)\n\t\tgoto err_core_put;\n\n\tvenus_assign_register_offsets(core);\n\n\tret = v4l2_device_register(dev, &core->v4l2_dev);\n\tif (ret)\n\t\tgoto err_core_deinit;\n\n\tplatform_set_drvdata(pdev, core);\n\n\tpm_runtime_enable(dev);\n\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0)\n\t\tgoto err_runtime_disable;\n\n\tret = of_platform_populate(dev->of_node, NULL, NULL, dev);\n\tif (ret)\n\t\tgoto err_runtime_disable;\n\n\tret = venus_firmware_init(core);\n\tif (ret)\n\t\tgoto err_of_depopulate;\n\n\tret = venus_boot(core);\n\tif (ret)\n\t\tgoto err_firmware_deinit;\n\n\tret = hfi_core_resume(core, true);\n\tif (ret)\n\t\tgoto err_venus_shutdown;\n\n\tret = hfi_core_init(core);\n\tif (ret)\n\t\tgoto err_venus_shutdown;\n\n\tret = venus_enumerate_codecs(core, VIDC_SESSION_TYPE_DEC);\n\tif (ret)\n\t\tgoto err_venus_shutdown;\n\n\tret = venus_enumerate_codecs(core, VIDC_SESSION_TYPE_ENC);\n\tif (ret)\n\t\tgoto err_venus_shutdown;\n\n\tret = pm_runtime_put_sync(dev);\n\tif (ret) {\n\t\tpm_runtime_get_noresume(dev);\n\t\tgoto err_dev_unregister;\n\t}\n\n\tvenus_dbgfs_init(core);\n\n\treturn 0;\n\nerr_dev_unregister:\n\tv4l2_device_unregister(&core->v4l2_dev);\nerr_venus_shutdown:\n\tvenus_shutdown(core);\nerr_firmware_deinit:\n\tvenus_firmware_deinit(core);\nerr_of_depopulate:\n\tof_platform_depopulate(dev);\nerr_runtime_disable:\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_disable(dev);\n\thfi_destroy(core);\nerr_core_deinit:\n\thfi_core_deinit(core, false);\nerr_core_put:\n\tif (core->pm_ops->core_put)\n\t\tcore->pm_ops->core_put(core);\n\treturn ret;\n}\n\nstatic void venus_remove(struct platform_device *pdev)\n{\n\tstruct venus_core *core = platform_get_drvdata(pdev);\n\tconst struct venus_pm_ops *pm_ops = core->pm_ops;\n\tstruct device *dev = core->dev;\n\tint ret;\n\n\tret = pm_runtime_get_sync(dev);\n\tWARN_ON(ret < 0);\n\n\tret = hfi_core_deinit(core, true);\n\tWARN_ON(ret);\n\n\tvenus_shutdown(core);\n\tof_platform_depopulate(dev);\n\n\tvenus_firmware_deinit(core);\n\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\n\tif (pm_ops->core_put)\n\t\tpm_ops->core_put(core);\n\n\tv4l2_device_unregister(&core->v4l2_dev);\n\n\thfi_destroy(core);\n\n\tmutex_destroy(&core->pm_lock);\n\tmutex_destroy(&core->lock);\n\tvenus_dbgfs_deinit(core);\n}\n\nstatic void venus_core_shutdown(struct platform_device *pdev)\n{\n\tstruct venus_core *core = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(core->dev);\n\tvenus_shutdown(core);\n\tvenus_firmware_deinit(core);\n\tpm_runtime_put_sync(core->dev);\n}\n\nstatic __maybe_unused int venus_runtime_suspend(struct device *dev)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\tconst struct venus_pm_ops *pm_ops = core->pm_ops;\n\tint ret;\n\n\tret = hfi_core_suspend(core);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pm_ops->core_power) {\n\t\tret = pm_ops->core_power(core, POWER_OFF);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = icc_set_bw(core->cpucfg_path, 0, 0);\n\tif (ret)\n\t\tgoto err_cpucfg_path;\n\n\tret = icc_set_bw(core->video_path, 0, 0);\n\tif (ret)\n\t\tgoto err_video_path;\n\n\treturn ret;\n\nerr_video_path:\n\ticc_set_bw(core->cpucfg_path, kbps_to_icc(1000), 0);\nerr_cpucfg_path:\n\tif (pm_ops->core_power)\n\t\tpm_ops->core_power(core, POWER_ON);\n\n\treturn ret;\n}\n\nstatic __maybe_unused int venus_runtime_resume(struct device *dev)\n{\n\tstruct venus_core *core = dev_get_drvdata(dev);\n\tconst struct venus_pm_ops *pm_ops = core->pm_ops;\n\tint ret;\n\n\tret = icc_set_bw(core->video_path, kbps_to_icc(20000), 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = icc_set_bw(core->cpucfg_path, kbps_to_icc(1000), 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pm_ops->core_power) {\n\t\tret = pm_ops->core_power(core, POWER_ON);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn hfi_core_resume(core, false);\n}\n\nstatic const struct dev_pm_ops venus_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(venus_runtime_suspend, venus_runtime_resume, NULL)\n};\n\nstatic const struct freq_tbl msm8916_freq_table[] = {\n\t{ 352800, 228570000 },\t \n\t{ 244800, 160000000 },\t \n\t{ 108000, 100000000 },\t \n};\n\nstatic const struct reg_val msm8916_reg_preset[] = {\n\t{ 0xe0020, 0x05555556 },\n\t{ 0xe0024, 0x05555556 },\n\t{ 0x80124, 0x00000003 },\n};\n\nstatic const struct venus_resources msm8916_res = {\n\t.freq_tbl = msm8916_freq_table,\n\t.freq_tbl_size = ARRAY_SIZE(msm8916_freq_table),\n\t.reg_tbl = msm8916_reg_preset,\n\t.reg_tbl_size = ARRAY_SIZE(msm8916_reg_preset),\n\t.clks = { \"core\", \"iface\", \"bus\", },\n\t.clks_num = 3,\n\t.max_load = 352800,  \n\t.hfi_version = HFI_VERSION_1XX,\n\t.vmem_id = VIDC_RESOURCE_NONE,\n\t.vmem_size = 0,\n\t.vmem_addr = 0,\n\t.dma_mask = 0xddc00000 - 1,\n\t.fwname = \"qcom/venus-1.8/venus.mdt\",\n};\n\nstatic const struct freq_tbl msm8996_freq_table[] = {\n\t{ 1944000, 520000000 },\t \n\t{  972000, 520000000 },\t \n\t{  489600, 346666667 },\t \n\t{  244800, 150000000 },\t \n\t{  108000,  75000000 },\t \n};\n\nstatic const struct reg_val msm8996_reg_preset[] = {\n\t{ 0x80010, 0xffffffff },\n\t{ 0x80018, 0x00001556 },\n\t{ 0x8001C, 0x00001556 },\n};\n\nstatic const struct venus_resources msm8996_res = {\n\t.freq_tbl = msm8996_freq_table,\n\t.freq_tbl_size = ARRAY_SIZE(msm8996_freq_table),\n\t.reg_tbl = msm8996_reg_preset,\n\t.reg_tbl_size = ARRAY_SIZE(msm8996_reg_preset),\n\t.clks = {\"core\", \"iface\", \"bus\", \"mbus\" },\n\t.clks_num = 4,\n\t.vcodec0_clks = { \"core\" },\n\t.vcodec1_clks = { \"core\" },\n\t.vcodec_clks_num = 1,\n\t.max_load = 2563200,\n\t.hfi_version = HFI_VERSION_3XX,\n\t.vmem_id = VIDC_RESOURCE_NONE,\n\t.vmem_size = 0,\n\t.vmem_addr = 0,\n\t.dma_mask = 0xddc00000 - 1,\n\t.fwname = \"qcom/venus-4.2/venus.mdt\",\n};\n\nstatic const struct freq_tbl sdm660_freq_table[] = {\n\t{ 979200, 518400000 },\n\t{ 489600, 441600000 },\n\t{ 432000, 404000000 },\n\t{ 244800, 320000000 },\n\t{ 216000, 269330000 },\n\t{ 108000, 133330000 },\n};\n\nstatic const struct reg_val sdm660_reg_preset[] = {\n\t{ 0x80010, 0x001f001f },\n\t{ 0x80018, 0x00000156 },\n\t{ 0x8001c, 0x00000156 },\n};\n\nstatic const struct bw_tbl sdm660_bw_table_enc[] = {\n\t{  979200,  1044000, 0, 2446336, 0 },\t \n\t{  864000,   887000, 0, 2108416, 0 },\t \n\t{  489600,   666000, 0, 1207296, 0 },\t \n\t{  432000,   578000, 0, 1058816, 0 },\t \n\t{  244800,   346000, 0,  616448, 0 },\t \n\t{  216000,   293000, 0,  534528, 0 },\t \n\t{  108000,   151000, 0,  271360, 0 },\t \n};\n\nstatic const struct bw_tbl sdm660_bw_table_dec[] = {\n\t{  979200,  2365000, 0, 1892000, 0 },\t \n\t{  864000,  1978000, 0, 1554000, 0 },\t \n\t{  489600,  1133000, 0,  895000, 0 },\t \n\t{  432000,   994000, 0,  781000, 0 },\t \n\t{  244800,   580000, 0,  460000, 0 },\t \n\t{  216000,   501000, 0,  301000, 0 },\t \n\t{  108000,   255000, 0,  202000, 0 },\t \n};\n\nstatic const struct venus_resources sdm660_res = {\n\t.freq_tbl = sdm660_freq_table,\n\t.freq_tbl_size = ARRAY_SIZE(sdm660_freq_table),\n\t.reg_tbl = sdm660_reg_preset,\n\t.reg_tbl_size = ARRAY_SIZE(sdm660_reg_preset),\n\t.bw_tbl_enc = sdm660_bw_table_enc,\n\t.bw_tbl_enc_size = ARRAY_SIZE(sdm660_bw_table_enc),\n\t.bw_tbl_dec = sdm660_bw_table_dec,\n\t.bw_tbl_dec_size = ARRAY_SIZE(sdm660_bw_table_dec),\n\t.clks = {\"core\", \"iface\", \"bus\", \"bus_throttle\" },\n\t.clks_num = 4,\n\t.vcodec0_clks = { \"vcodec0_core\" },\n\t.vcodec1_clks = { \"vcodec0_core\" },\n\t.vcodec_clks_num = 1,\n\t.vcodec_num = 1,\n\t.max_load = 1036800,\n\t.hfi_version = HFI_VERSION_3XX,\n\t.vmem_id = VIDC_RESOURCE_NONE,\n\t.vmem_size = 0,\n\t.vmem_addr = 0,\n\t.cp_start = 0,\n\t.cp_size = 0x79000000,\n\t.cp_nonpixel_start = 0x1000000,\n\t.cp_nonpixel_size = 0x28000000,\n\t.dma_mask = 0xd9000000 - 1,\n\t.fwname = \"qcom/venus-4.4/venus.mdt\",\n};\n\nstatic const struct freq_tbl sdm845_freq_table[] = {\n\t{ 3110400, 533000000 },\t \n\t{ 2073600, 444000000 },\t \n\t{ 1944000, 404000000 },\t \n\t{  972000, 330000000 },\t \n\t{  489600, 200000000 },\t \n\t{  244800, 100000000 },\t \n};\n\nstatic const struct bw_tbl sdm845_bw_table_enc[] = {\n\t{ 1944000, 1612000, 0, 2416000, 0 },\t \n\t{  972000,  951000, 0, 1434000, 0 },\t \n\t{  489600,  723000, 0,  973000, 0 },\t \n\t{  244800,  370000, 0,\t495000, 0 },\t \n};\n\nstatic const struct bw_tbl sdm845_bw_table_dec[] = {\n\t{ 2073600, 3929000, 0, 5551000, 0 },\t \n\t{ 1036800, 1987000, 0, 2797000, 0 },\t \n\t{  489600, 1040000, 0, 1298000, 0 },\t \n\t{  244800,  530000, 0,  659000, 0 },\t \n};\n\nstatic const struct venus_resources sdm845_res = {\n\t.freq_tbl = sdm845_freq_table,\n\t.freq_tbl_size = ARRAY_SIZE(sdm845_freq_table),\n\t.bw_tbl_enc = sdm845_bw_table_enc,\n\t.bw_tbl_enc_size = ARRAY_SIZE(sdm845_bw_table_enc),\n\t.bw_tbl_dec = sdm845_bw_table_dec,\n\t.bw_tbl_dec_size = ARRAY_SIZE(sdm845_bw_table_dec),\n\t.clks = {\"core\", \"iface\", \"bus\" },\n\t.clks_num = 3,\n\t.vcodec0_clks = { \"core\", \"bus\" },\n\t.vcodec1_clks = { \"core\", \"bus\" },\n\t.vcodec_clks_num = 2,\n\t.max_load = 3110400,\t \n\t.hfi_version = HFI_VERSION_4XX,\n\t.vpu_version = VPU_VERSION_AR50,\n\t.vmem_id = VIDC_RESOURCE_NONE,\n\t.vmem_size = 0,\n\t.vmem_addr = 0,\n\t.dma_mask = 0xe0000000 - 1,\n\t.fwname = \"qcom/venus-5.2/venus.mdt\",\n};\n\nstatic const struct venus_resources sdm845_res_v2 = {\n\t.freq_tbl = sdm845_freq_table,\n\t.freq_tbl_size = ARRAY_SIZE(sdm845_freq_table),\n\t.bw_tbl_enc = sdm845_bw_table_enc,\n\t.bw_tbl_enc_size = ARRAY_SIZE(sdm845_bw_table_enc),\n\t.bw_tbl_dec = sdm845_bw_table_dec,\n\t.bw_tbl_dec_size = ARRAY_SIZE(sdm845_bw_table_dec),\n\t.clks = {\"core\", \"iface\", \"bus\" },\n\t.clks_num = 3,\n\t.vcodec0_clks = { \"vcodec0_core\", \"vcodec0_bus\" },\n\t.vcodec1_clks = { \"vcodec1_core\", \"vcodec1_bus\" },\n\t.vcodec_clks_num = 2,\n\t.vcodec_pmdomains = { \"venus\", \"vcodec0\", \"vcodec1\" },\n\t.vcodec_pmdomains_num = 3,\n\t.opp_pmdomain = (const char *[]) { \"cx\", NULL },\n\t.vcodec_num = 2,\n\t.max_load = 3110400,\t \n\t.hfi_version = HFI_VERSION_4XX,\n\t.vpu_version = VPU_VERSION_AR50,\n\t.vmem_id = VIDC_RESOURCE_NONE,\n\t.vmem_size = 0,\n\t.vmem_addr = 0,\n\t.dma_mask = 0xe0000000 - 1,\n\t.cp_start = 0,\n\t.cp_size = 0x70800000,\n\t.cp_nonpixel_start = 0x1000000,\n\t.cp_nonpixel_size = 0x24800000,\n\t.fwname = \"qcom/venus-5.2/venus.mdt\",\n};\n\nstatic const struct freq_tbl sc7180_freq_table[] = {\n\t{  0, 500000000 },\n\t{  0, 434000000 },\n\t{  0, 340000000 },\n\t{  0, 270000000 },\n\t{  0, 150000000 },\n};\n\nstatic const struct bw_tbl sc7180_bw_table_enc[] = {\n\t{  972000,  750000, 0, 0, 0 },\t \n\t{  489600,  451000, 0, 0, 0 },\t \n\t{  244800,  234000, 0, 0, 0 },\t \n};\n\nstatic const struct bw_tbl sc7180_bw_table_dec[] = {\n\t{ 1036800, 1386000, 0, 1875000, 0 },\t \n\t{  489600,  865000, 0, 1146000, 0 },\t \n\t{  244800,  530000, 0,  583000, 0 },\t \n};\n\nstatic const struct venus_resources sc7180_res = {\n\t.freq_tbl = sc7180_freq_table,\n\t.freq_tbl_size = ARRAY_SIZE(sc7180_freq_table),\n\t.bw_tbl_enc = sc7180_bw_table_enc,\n\t.bw_tbl_enc_size = ARRAY_SIZE(sc7180_bw_table_enc),\n\t.bw_tbl_dec = sc7180_bw_table_dec,\n\t.bw_tbl_dec_size = ARRAY_SIZE(sc7180_bw_table_dec),\n\t.clks = {\"core\", \"iface\", \"bus\" },\n\t.clks_num = 3,\n\t.vcodec0_clks = { \"vcodec0_core\", \"vcodec0_bus\" },\n\t.vcodec_clks_num = 2,\n\t.vcodec_pmdomains = { \"venus\", \"vcodec0\" },\n\t.vcodec_pmdomains_num = 2,\n\t.opp_pmdomain = (const char *[]) { \"cx\", NULL },\n\t.vcodec_num = 1,\n\t.hfi_version = HFI_VERSION_4XX,\n\t.vpu_version = VPU_VERSION_AR50,\n\t.vmem_id = VIDC_RESOURCE_NONE,\n\t.vmem_size = 0,\n\t.vmem_addr = 0,\n\t.dma_mask = 0xe0000000 - 1,\n\t.cp_start = 0,\n\t.cp_size = 0x70800000,\n\t.cp_nonpixel_start = 0x1000000,\n\t.cp_nonpixel_size = 0x24800000,\n\t.fwname = \"qcom/venus-5.4/venus.mdt\",\n};\n\nstatic const struct freq_tbl sm8250_freq_table[] = {\n\t{ 0, 444000000 },\n\t{ 0, 366000000 },\n\t{ 0, 338000000 },\n\t{ 0, 240000000 },\n};\n\nstatic const struct bw_tbl sm8250_bw_table_enc[] = {\n\t{ 1944000, 1954000, 0, 3711000, 0 },\t \n\t{  972000,  996000, 0, 1905000, 0 },\t \n\t{  489600,  645000, 0,  977000, 0 },\t \n\t{  244800,  332000, 0,\t498000, 0 },\t \n};\n\nstatic const struct bw_tbl sm8250_bw_table_dec[] = {\n\t{ 2073600, 2403000, 0, 4113000, 0 },\t \n\t{ 1036800, 1224000, 0, 2079000, 0 },\t \n\t{  489600,  812000, 0,  998000, 0 },\t \n\t{  244800,  416000, 0,  509000, 0 },\t \n};\n\nstatic const struct reg_val sm8250_reg_preset[] = {\n\t{ 0xb0088, 0 },\n};\n\nstatic const struct venus_resources sm8250_res = {\n\t.freq_tbl = sm8250_freq_table,\n\t.freq_tbl_size = ARRAY_SIZE(sm8250_freq_table),\n\t.reg_tbl = sm8250_reg_preset,\n\t.reg_tbl_size = ARRAY_SIZE(sm8250_reg_preset),\n\t.bw_tbl_enc = sm8250_bw_table_enc,\n\t.bw_tbl_enc_size = ARRAY_SIZE(sm8250_bw_table_enc),\n\t.bw_tbl_dec = sm8250_bw_table_dec,\n\t.bw_tbl_dec_size = ARRAY_SIZE(sm8250_bw_table_dec),\n\t.clks = {\"core\", \"iface\"},\n\t.clks_num = 2,\n\t.resets = { \"bus\", \"core\" },\n\t.resets_num = 2,\n\t.vcodec0_clks = { \"vcodec0_core\" },\n\t.vcodec_clks_num = 1,\n\t.vcodec_pmdomains = { \"venus\", \"vcodec0\" },\n\t.vcodec_pmdomains_num = 2,\n\t.opp_pmdomain = (const char *[]) { \"mx\", NULL },\n\t.vcodec_num = 1,\n\t.max_load = 7833600,\n\t.hfi_version = HFI_VERSION_6XX,\n\t.vpu_version = VPU_VERSION_IRIS2,\n\t.num_vpp_pipes = 4,\n\t.vmem_id = VIDC_RESOURCE_NONE,\n\t.vmem_size = 0,\n\t.vmem_addr = 0,\n\t.dma_mask = 0xe0000000 - 1,\n\t.fwname = \"qcom/vpu-1.0/venus.mbn\",\n};\n\nstatic const struct freq_tbl sc7280_freq_table[] = {\n\t{ 0, 460000000 },\n\t{ 0, 424000000 },\n\t{ 0, 335000000 },\n\t{ 0, 240000000 },\n\t{ 0, 133333333 },\n};\n\nstatic const struct bw_tbl sc7280_bw_table_enc[] = {\n\t{ 1944000, 1896000, 0, 3657000, 0 },\t \n\t{  972000,  968000, 0, 1848000, 0 },\t \n\t{  489600,  618000, 0,  941000, 0 },\t \n\t{  244800,  318000, 0,\t480000, 0 },\t \n};\n\nstatic const struct bw_tbl sc7280_bw_table_dec[] = {\n\t{ 2073600, 2128000, 0, 3831000, 0 },\t \n\t{ 1036800, 1085000, 0, 1937000, 0 },\t \n\t{  489600,  779000, 0,  998000, 0 },\t \n\t{  244800,  400000, 0,  509000, 0 },\t \n};\n\nstatic const struct reg_val sm7280_reg_preset[] = {\n\t{ 0xb0088, 0 },\n};\n\nstatic const struct hfi_ubwc_config sc7280_ubwc_config = {\n\t0, 0, {1, 1, 1, 0, 0, 0}, 8, 32, 14, 0, 0, {0, 0}\n};\n\nstatic const struct venus_resources sc7280_res = {\n\t.freq_tbl = sc7280_freq_table,\n\t.freq_tbl_size = ARRAY_SIZE(sc7280_freq_table),\n\t.reg_tbl = sm7280_reg_preset,\n\t.reg_tbl_size = ARRAY_SIZE(sm7280_reg_preset),\n\t.bw_tbl_enc = sc7280_bw_table_enc,\n\t.bw_tbl_enc_size = ARRAY_SIZE(sc7280_bw_table_enc),\n\t.bw_tbl_dec = sc7280_bw_table_dec,\n\t.bw_tbl_dec_size = ARRAY_SIZE(sc7280_bw_table_dec),\n\t.ubwc_conf = &sc7280_ubwc_config,\n\t.clks = {\"core\", \"bus\", \"iface\"},\n\t.clks_num = 3,\n\t.vcodec0_clks = {\"vcodec_core\", \"vcodec_bus\"},\n\t.vcodec_clks_num = 2,\n\t.vcodec_pmdomains = { \"venus\", \"vcodec0\" },\n\t.vcodec_pmdomains_num = 2,\n\t.opp_pmdomain = (const char *[]) { \"cx\", NULL },\n\t.vcodec_num = 1,\n\t.hfi_version = HFI_VERSION_6XX,\n\t.vpu_version = VPU_VERSION_IRIS2_1,\n\t.num_vpp_pipes = 1,\n\t.vmem_id = VIDC_RESOURCE_NONE,\n\t.vmem_size = 0,\n\t.vmem_addr = 0,\n\t.dma_mask = 0xe0000000 - 1,\n\t.fwname = \"qcom/vpu-2.0/venus.mbn\",\n};\n\nstatic const struct of_device_id venus_dt_match[] = {\n\t{ .compatible = \"qcom,msm8916-venus\", .data = &msm8916_res, },\n\t{ .compatible = \"qcom,msm8996-venus\", .data = &msm8996_res, },\n\t{ .compatible = \"qcom,sdm660-venus\", .data = &sdm660_res, },\n\t{ .compatible = \"qcom,sdm845-venus\", .data = &sdm845_res, },\n\t{ .compatible = \"qcom,sdm845-venus-v2\", .data = &sdm845_res_v2, },\n\t{ .compatible = \"qcom,sc7180-venus\", .data = &sc7180_res, },\n\t{ .compatible = \"qcom,sc7280-venus\", .data = &sc7280_res, },\n\t{ .compatible = \"qcom,sm8250-venus\", .data = &sm8250_res, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, venus_dt_match);\n\nstatic struct platform_driver qcom_venus_driver = {\n\t.probe = venus_probe,\n\t.remove_new = venus_remove,\n\t.driver = {\n\t\t.name = \"qcom-venus\",\n\t\t.of_match_table = venus_dt_match,\n\t\t.pm = &venus_pm_ops,\n\t},\n\t.shutdown = venus_core_shutdown,\n};\nmodule_platform_driver(qcom_venus_driver);\n\nMODULE_ALIAS(\"platform:qcom-venus\");\nMODULE_DESCRIPTION(\"Qualcomm Venus video encoder and decoder driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}