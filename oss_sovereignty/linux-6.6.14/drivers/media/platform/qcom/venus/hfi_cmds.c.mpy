{
  "module_name": "hfi_cmds.c",
  "hash_id": "2b792fdc48d4bc9a27cabd291ec28244f4a4b131c8d52d5971a455ebf771d0e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/qcom/venus/hfi_cmds.c",
  "human_readable_source": "\n \n#include <linux/overflow.h>\n#include <linux/errno.h>\n#include <linux/hash.h>\n\n#include \"hfi_cmds.h\"\n\nstatic enum hfi_version hfi_ver;\n\nvoid pkt_sys_init(struct hfi_sys_init_pkt *pkt, u32 arch_type)\n{\n\tpkt->hdr.size = sizeof(*pkt);\n\tpkt->hdr.pkt_type = HFI_CMD_SYS_INIT;\n\tpkt->arch_type = arch_type;\n}\n\nvoid pkt_sys_pc_prep(struct hfi_sys_pc_prep_pkt *pkt)\n{\n\tpkt->hdr.size = sizeof(*pkt);\n\tpkt->hdr.pkt_type = HFI_CMD_SYS_PC_PREP;\n}\n\nvoid pkt_sys_idle_indicator(struct hfi_sys_set_property_pkt *pkt, u32 enable)\n{\n\tstruct hfi_enable *hfi = (struct hfi_enable *)&pkt->data[1];\n\n\tpkt->hdr.size = struct_size(pkt, data, 1) + sizeof(*hfi);\n\tpkt->hdr.pkt_type = HFI_CMD_SYS_SET_PROPERTY;\n\tpkt->num_properties = 1;\n\tpkt->data[0] = HFI_PROPERTY_SYS_IDLE_INDICATOR;\n\thfi->enable = enable;\n}\n\nvoid pkt_sys_debug_config(struct hfi_sys_set_property_pkt *pkt, u32 mode,\n\t\t\t  u32 config)\n{\n\tstruct hfi_debug_config *hfi;\n\n\tpkt->hdr.size = struct_size(pkt, data, 1) + sizeof(*hfi);\n\tpkt->hdr.pkt_type = HFI_CMD_SYS_SET_PROPERTY;\n\tpkt->num_properties = 1;\n\tpkt->data[0] = HFI_PROPERTY_SYS_DEBUG_CONFIG;\n\thfi = (struct hfi_debug_config *)&pkt->data[1];\n\thfi->config = config;\n\thfi->mode = mode;\n}\n\nvoid pkt_sys_coverage_config(struct hfi_sys_set_property_pkt *pkt, u32 mode)\n{\n\tpkt->hdr.size = struct_size(pkt, data, 2);\n\tpkt->hdr.pkt_type = HFI_CMD_SYS_SET_PROPERTY;\n\tpkt->num_properties = 1;\n\tpkt->data[0] = HFI_PROPERTY_SYS_CONFIG_COVERAGE;\n\tpkt->data[1] = mode;\n}\n\nvoid pkt_sys_ubwc_config(struct hfi_sys_set_property_pkt *pkt, const struct hfi_ubwc_config *hfi)\n{\n\tpkt->hdr.size = struct_size(pkt, data, 1) + sizeof(*hfi);\n\tpkt->hdr.pkt_type = HFI_CMD_SYS_SET_PROPERTY;\n\tpkt->num_properties = 1;\n\tpkt->data[0] = HFI_PROPERTY_SYS_UBWC_CONFIG;\n\tmemcpy(&pkt->data[1], hfi, sizeof(*hfi));\n}\n\nint pkt_sys_set_resource(struct hfi_sys_set_resource_pkt *pkt, u32 id, u32 size,\n\t\t\t u32 addr, void *cookie)\n{\n\tpkt->hdr.size = sizeof(*pkt);\n\tpkt->hdr.pkt_type = HFI_CMD_SYS_SET_RESOURCE;\n\tpkt->resource_handle = hash32_ptr(cookie);\n\n\tswitch (id) {\n\tcase VIDC_RESOURCE_OCMEM:\n\tcase VIDC_RESOURCE_VMEM: {\n\t\tstruct hfi_resource_ocmem *res =\n\t\t\t(struct hfi_resource_ocmem *)&pkt->resource_data[0];\n\n\t\tres->size = size;\n\t\tres->mem = addr;\n\t\tpkt->resource_type = HFI_RESOURCE_OCMEM;\n\t\tpkt->hdr.size += sizeof(*res);\n\t\tbreak;\n\t}\n\tcase VIDC_RESOURCE_NONE:\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint pkt_sys_unset_resource(struct hfi_sys_release_resource_pkt *pkt, u32 id,\n\t\t\t   u32 size, void *cookie)\n{\n\tpkt->hdr.size = sizeof(*pkt);\n\tpkt->hdr.pkt_type = HFI_CMD_SYS_RELEASE_RESOURCE;\n\tpkt->resource_handle = hash32_ptr(cookie);\n\n\tswitch (id) {\n\tcase VIDC_RESOURCE_OCMEM:\n\tcase VIDC_RESOURCE_VMEM:\n\t\tpkt->resource_type = HFI_RESOURCE_OCMEM;\n\t\tbreak;\n\tcase VIDC_RESOURCE_NONE:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nvoid pkt_sys_ping(struct hfi_sys_ping_pkt *pkt, u32 cookie)\n{\n\tpkt->hdr.size = sizeof(*pkt);\n\tpkt->hdr.pkt_type = HFI_CMD_SYS_PING;\n\tpkt->client_data = cookie;\n}\n\nvoid pkt_sys_power_control(struct hfi_sys_set_property_pkt *pkt, u32 enable)\n{\n\tstruct hfi_enable *hfi = (struct hfi_enable *)&pkt->data[1];\n\n\tpkt->hdr.size = struct_size(pkt, data, 1) + sizeof(*hfi);\n\tpkt->hdr.pkt_type = HFI_CMD_SYS_SET_PROPERTY;\n\tpkt->num_properties = 1;\n\tpkt->data[0] = HFI_PROPERTY_SYS_CODEC_POWER_PLANE_CTRL;\n\thfi->enable = enable;\n}\n\nint pkt_sys_ssr_cmd(struct hfi_sys_test_ssr_pkt *pkt, u32 trigger_type)\n{\n\tswitch (trigger_type) {\n\tcase HFI_TEST_SSR_SW_ERR_FATAL:\n\tcase HFI_TEST_SSR_SW_DIV_BY_ZERO:\n\tcase HFI_TEST_SSR_HW_WDOG_IRQ:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpkt->hdr.size = sizeof(*pkt);\n\tpkt->hdr.pkt_type = HFI_CMD_SYS_TEST_SSR;\n\tpkt->trigger_type = trigger_type;\n\n\treturn 0;\n}\n\nvoid pkt_sys_image_version(struct hfi_sys_get_property_pkt *pkt)\n{\n\tpkt->hdr.size = sizeof(*pkt);\n\tpkt->hdr.pkt_type = HFI_CMD_SYS_GET_PROPERTY;\n\tpkt->num_properties = 1;\n\tpkt->data[0] = HFI_PROPERTY_SYS_IMAGE_VERSION;\n}\n\nint pkt_session_init(struct hfi_session_init_pkt *pkt, void *cookie,\n\t\t     u32 session_type, u32 codec)\n{\n\tif (!pkt || !cookie || !codec)\n\t\treturn -EINVAL;\n\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SYS_SESSION_INIT;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->session_domain = session_type;\n\tpkt->session_codec = codec;\n\n\treturn 0;\n}\n\nvoid pkt_session_cmd(struct hfi_session_pkt *pkt, u32 pkt_type, void *cookie)\n{\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = pkt_type;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n}\n\nint pkt_session_set_buffers(struct hfi_session_set_buffers_pkt *pkt,\n\t\t\t    void *cookie, struct hfi_buffer_desc *bd)\n{\n\tunsigned int i;\n\n\tif (!cookie || !pkt || !bd)\n\t\treturn -EINVAL;\n\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_SET_BUFFERS;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->buffer_size = bd->buffer_size;\n\tpkt->min_buffer_size = bd->buffer_size;\n\tpkt->num_buffers = bd->num_buffers;\n\n\tif (bd->buffer_type == HFI_BUFFER_OUTPUT ||\n\t    bd->buffer_type == HFI_BUFFER_OUTPUT2) {\n\t\tstruct hfi_buffer_info *bi;\n\n\t\tpkt->extradata_size = bd->extradata_size;\n\t\tpkt->shdr.hdr.size = sizeof(*pkt) +\n\t\t\tbd->num_buffers * sizeof(*bi);\n\t\tbi = (struct hfi_buffer_info *)pkt->buffer_info;\n\t\tfor (i = 0; i < pkt->num_buffers; i++) {\n\t\t\tbi->buffer_addr = bd->device_addr;\n\t\t\tbi->extradata_addr = bd->extradata_addr;\n\t\t}\n\t} else {\n\t\tpkt->extradata_size = 0;\n\t\tpkt->shdr.hdr.size = struct_size(pkt, buffer_info,\n\t\t\t\t\t\t bd->num_buffers);\n\t\tfor (i = 0; i < pkt->num_buffers; i++)\n\t\t\tpkt->buffer_info[i] = bd->device_addr;\n\t}\n\n\tpkt->buffer_type = bd->buffer_type;\n\n\treturn 0;\n}\n\nint pkt_session_unset_buffers(struct hfi_session_release_buffer_pkt *pkt,\n\t\t\t      void *cookie, struct hfi_buffer_desc *bd)\n{\n\tunsigned int i;\n\n\tif (!cookie || !pkt || !bd)\n\t\treturn -EINVAL;\n\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_RELEASE_BUFFERS;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->buffer_size = bd->buffer_size;\n\tpkt->num_buffers = bd->num_buffers;\n\n\tif (bd->buffer_type == HFI_BUFFER_OUTPUT ||\n\t    bd->buffer_type == HFI_BUFFER_OUTPUT2) {\n\t\tstruct hfi_buffer_info *bi;\n\n\t\tbi = (struct hfi_buffer_info *)pkt->buffer_info;\n\t\tfor (i = 0; i < pkt->num_buffers; i++) {\n\t\t\tbi->buffer_addr = bd->device_addr;\n\t\t\tbi->extradata_addr = bd->extradata_addr;\n\t\t}\n\t\tpkt->shdr.hdr.size =\n\t\t\t\tsizeof(struct hfi_session_set_buffers_pkt) +\n\t\t\t\tbd->num_buffers * sizeof(*bi);\n\t} else {\n\t\tfor (i = 0; i < pkt->num_buffers; i++)\n\t\t\tpkt->buffer_info[i] = bd->device_addr;\n\n\t\tpkt->extradata_size = 0;\n\t\tpkt->shdr.hdr.size =\n\t\t\tstruct_size_t(struct hfi_session_set_buffers_pkt,\n\t\t\t\t      buffer_info, bd->num_buffers);\n\t}\n\n\tpkt->response_req = bd->response_required;\n\tpkt->buffer_type = bd->buffer_type;\n\n\treturn 0;\n}\n\nint pkt_session_etb_decoder(struct hfi_session_empty_buffer_compressed_pkt *pkt,\n\t\t\t    void *cookie, struct hfi_frame_data *in_frame)\n{\n\tif (!cookie)\n\t\treturn -EINVAL;\n\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_EMPTY_BUFFER;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->time_stamp_hi = upper_32_bits(in_frame->timestamp);\n\tpkt->time_stamp_lo = lower_32_bits(in_frame->timestamp);\n\tpkt->flags = in_frame->flags;\n\tpkt->mark_target = in_frame->mark_target;\n\tpkt->mark_data = in_frame->mark_data;\n\tpkt->offset = in_frame->offset;\n\tpkt->alloc_len = in_frame->alloc_len;\n\tpkt->filled_len = in_frame->filled_len;\n\tpkt->input_tag = in_frame->clnt_data;\n\tpkt->packet_buffer = in_frame->device_addr;\n\n\treturn 0;\n}\n\nint pkt_session_etb_encoder(\n\t\tstruct hfi_session_empty_buffer_uncompressed_plane0_pkt *pkt,\n\t\tvoid *cookie, struct hfi_frame_data *in_frame)\n{\n\tif (!cookie || !in_frame->device_addr)\n\t\treturn -EINVAL;\n\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_EMPTY_BUFFER;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->view_id = 0;\n\tpkt->time_stamp_hi = upper_32_bits(in_frame->timestamp);\n\tpkt->time_stamp_lo = lower_32_bits(in_frame->timestamp);\n\tpkt->flags = in_frame->flags;\n\tpkt->mark_target = in_frame->mark_target;\n\tpkt->mark_data = in_frame->mark_data;\n\tpkt->offset = in_frame->offset;\n\tpkt->alloc_len = in_frame->alloc_len;\n\tpkt->filled_len = in_frame->filled_len;\n\tpkt->input_tag = in_frame->clnt_data;\n\tpkt->packet_buffer = in_frame->device_addr;\n\tpkt->extradata_buffer = in_frame->extradata_addr;\n\n\treturn 0;\n}\n\nint pkt_session_ftb(struct hfi_session_fill_buffer_pkt *pkt, void *cookie,\n\t\t    struct hfi_frame_data *out_frame)\n{\n\tif (!cookie || !out_frame || !out_frame->device_addr)\n\t\treturn -EINVAL;\n\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_FILL_BUFFER;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\n\tif (out_frame->buffer_type == HFI_BUFFER_OUTPUT)\n\t\tpkt->stream_id = 0;\n\telse if (out_frame->buffer_type == HFI_BUFFER_OUTPUT2)\n\t\tpkt->stream_id = 1;\n\n\tpkt->output_tag = out_frame->clnt_data;\n\tpkt->packet_buffer = out_frame->device_addr;\n\tpkt->extradata_buffer = out_frame->extradata_addr;\n\tpkt->alloc_len = out_frame->alloc_len;\n\tpkt->filled_len = out_frame->filled_len;\n\tpkt->offset = out_frame->offset;\n\tpkt->data[0] = out_frame->extradata_size;\n\n\treturn 0;\n}\n\nint pkt_session_parse_seq_header(\n\t\tstruct hfi_session_parse_sequence_header_pkt *pkt,\n\t\tvoid *cookie, u32 seq_hdr, u32 seq_hdr_len)\n{\n\tif (!cookie || !seq_hdr || !seq_hdr_len)\n\t\treturn -EINVAL;\n\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_PARSE_SEQUENCE_HEADER;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->header_len = seq_hdr_len;\n\tpkt->packet_buffer = seq_hdr;\n\n\treturn 0;\n}\n\nint pkt_session_get_seq_hdr(struct hfi_session_get_sequence_header_pkt *pkt,\n\t\t\t    void *cookie, u32 seq_hdr, u32 seq_hdr_len)\n{\n\tif (!cookie || !seq_hdr || !seq_hdr_len)\n\t\treturn -EINVAL;\n\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_GET_SEQUENCE_HEADER;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->buffer_len = seq_hdr_len;\n\tpkt->packet_buffer = seq_hdr;\n\n\treturn 0;\n}\n\nint pkt_session_flush(struct hfi_session_flush_pkt *pkt, void *cookie, u32 type)\n{\n\tswitch (type) {\n\tcase HFI_FLUSH_INPUT:\n\tcase HFI_FLUSH_OUTPUT:\n\tcase HFI_FLUSH_OUTPUT2:\n\tcase HFI_FLUSH_ALL:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_FLUSH;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->flush_type = type;\n\n\treturn 0;\n}\n\nstatic int pkt_session_get_property_1x(struct hfi_session_get_property_pkt *pkt,\n\t\t\t\t       void *cookie, u32 ptype)\n{\n\tswitch (ptype) {\n\tcase HFI_PROPERTY_PARAM_PROFILE_LEVEL_CURRENT:\n\tcase HFI_PROPERTY_CONFIG_BUFFER_REQUIREMENTS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_GET_PROPERTY;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->num_properties = 1;\n\tpkt->data[0] = ptype;\n\n\treturn 0;\n}\n\nstatic int pkt_session_set_property_1x(struct hfi_session_set_property_pkt *pkt,\n\t\t\t\t       void *cookie, u32 ptype, void *pdata)\n{\n\tvoid *prop_data;\n\tint ret = 0;\n\n\tif (!pkt || !cookie || !pdata)\n\t\treturn -EINVAL;\n\n\tprop_data = &pkt->data[1];\n\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_SET_PROPERTY;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->num_properties = 1;\n\tpkt->data[0] = ptype;\n\n\tswitch (ptype) {\n\tcase HFI_PROPERTY_CONFIG_FRAME_RATE: {\n\t\tstruct hfi_framerate *in = pdata, *frate = prop_data;\n\n\t\tfrate->buffer_type = in->buffer_type;\n\t\tfrate->framerate = in->framerate;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*frate);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_UNCOMPRESSED_FORMAT_SELECT: {\n\t\tstruct hfi_uncompressed_format_select *in = pdata;\n\t\tstruct hfi_uncompressed_format_select *hfi = prop_data;\n\n\t\thfi->buffer_type = in->buffer_type;\n\t\thfi->format = in->format;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*hfi);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_FRAME_SIZE: {\n\t\tstruct hfi_framesize *in = pdata, *fsize = prop_data;\n\n\t\tfsize->buffer_type = in->buffer_type;\n\t\tfsize->height = in->height;\n\t\tfsize->width = in->width;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*fsize);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_REALTIME: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) * 2;\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_BUFFER_COUNT_ACTUAL: {\n\t\tstruct hfi_buffer_count_actual *in = pdata, *count = prop_data;\n\n\t\tcount->count_actual = in->count_actual;\n\t\tcount->type = in->type;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*count);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_BUFFER_SIZE_ACTUAL: {\n\t\tstruct hfi_buffer_size_actual *in = pdata, *sz = prop_data;\n\n\t\tsz->size = in->size;\n\t\tsz->type = in->type;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*sz);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_BUFFER_DISPLAY_HOLD_COUNT_ACTUAL: {\n\t\tstruct hfi_buffer_display_hold_count_actual *in = pdata;\n\t\tstruct hfi_buffer_display_hold_count_actual *count = prop_data;\n\n\t\tcount->hold_count = in->hold_count;\n\t\tcount->type = in->type;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*count);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_NAL_STREAM_FORMAT_SELECT: {\n\t\tstruct hfi_nal_stream_format_select *in = pdata;\n\t\tstruct hfi_nal_stream_format_select *fmt = prop_data;\n\n\t\tfmt->format = in->format;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*fmt);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_OUTPUT_ORDER: {\n\t\tu32 *in = pdata;\n\n\t\tswitch (*in) {\n\t\tcase HFI_OUTPUT_ORDER_DECODE:\n\t\tcase HFI_OUTPUT_ORDER_DISPLAY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpkt->data[1] = *in;\n\t\tpkt->shdr.hdr.size += sizeof(u32) * 2;\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_PICTURE_TYPE_DECODE: {\n\t\tstruct hfi_enable_picture *in = pdata, *en = prop_data;\n\n\t\ten->picture_type = in->picture_type;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_OUTPUT2_KEEP_ASPECT_RATIO: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_ENABLE_SUFFICIENT_SEQCHANGE_EVENT:\n\tcase HFI_PROPERTY_CONFIG_VDEC_POST_LOOP_DEBLOCKER: {\n\t\tstruct hfi_enable *in = pdata;\n\t\tstruct hfi_enable *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_MULTI_STREAM: {\n\t\tstruct hfi_multi_stream *in = pdata, *multi = prop_data;\n\n\t\tmulti->buffer_type = in->buffer_type;\n\t\tmulti->enable = in->enable;\n\t\tmulti->width = in->width;\n\t\tmulti->height = in->height;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*multi);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_DISPLAY_PICTURE_BUFFER_COUNT: {\n\t\tstruct hfi_display_picture_buffer_count *in = pdata;\n\t\tstruct hfi_display_picture_buffer_count *count = prop_data;\n\n\t\tcount->count = in->count;\n\t\tcount->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*count);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_DIVX_FORMAT: {\n\t\tu32 *in = pdata;\n\n\t\tswitch (*in) {\n\t\tcase HFI_DIVX_FORMAT_4:\n\t\tcase HFI_DIVX_FORMAT_5:\n\t\tcase HFI_DIVX_FORMAT_6:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpkt->data[1] = *in;\n\t\tpkt->shdr.hdr.size += sizeof(u32) * 2;\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VDEC_MB_ERROR_MAP_REPORTING: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_CONTINUE_DATA_TRANSFER: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_THUMBNAIL_MODE: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VENC_SYNC_FRAME_SEQUENCE_HEADER: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VENC_REQUEST_SYNC_FRAME:\n\t\tpkt->shdr.hdr.size += sizeof(u32);\n\t\tbreak;\n\tcase HFI_PROPERTY_PARAM_VENC_MPEG4_SHORT_HEADER:\n\t\tbreak;\n\tcase HFI_PROPERTY_PARAM_VENC_MPEG4_AC_PREDICTION:\n\t\tbreak;\n\tcase HFI_PROPERTY_CONFIG_VENC_TARGET_BITRATE: {\n\t\tstruct hfi_bitrate *in = pdata, *brate = prop_data;\n\n\t\tbrate->bitrate = in->bitrate;\n\t\tbrate->layer_id = in->layer_id;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*brate);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VENC_MAX_BITRATE: {\n\t\tstruct hfi_bitrate *in = pdata, *hfi = prop_data;\n\n\t\thfi->bitrate = in->bitrate;\n\t\thfi->layer_id = in->layer_id;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*hfi);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_PROFILE_LEVEL_CURRENT: {\n\t\tstruct hfi_profile_level *in = pdata, *pl = prop_data;\n\n\t\tpl->level = in->level;\n\t\tpl->profile = in->profile;\n\t\tif (pl->profile <= 0)\n\t\t\t \n\t\t\tpl->profile = HFI_H264_PROFILE_HIGH;\n\n\t\tif (!pl->level)\n\t\t\t \n\t\t\tpl->level = 1;\n\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*pl);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_H264_ENTROPY_CONTROL: {\n\t\tstruct hfi_h264_entropy_control *in = pdata, *hfi = prop_data;\n\n\t\thfi->entropy_mode = in->entropy_mode;\n\t\tif (hfi->entropy_mode == HFI_H264_ENTROPY_CABAC)\n\t\t\thfi->cabac_model = in->cabac_model;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*hfi);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_RATE_CONTROL: {\n\t\tu32 *in = pdata;\n\n\t\tswitch (*in) {\n\t\tcase HFI_RATE_CONTROL_OFF:\n\t\tcase HFI_RATE_CONTROL_CBR_CFR:\n\t\tcase HFI_RATE_CONTROL_CBR_VFR:\n\t\tcase HFI_RATE_CONTROL_VBR_CFR:\n\t\tcase HFI_RATE_CONTROL_VBR_VFR:\n\t\tcase HFI_RATE_CONTROL_CQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpkt->data[1] = *in;\n\t\tpkt->shdr.hdr.size += sizeof(u32) * 2;\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_MPEG4_TIME_RESOLUTION: {\n\t\tstruct hfi_mpeg4_time_resolution *in = pdata, *res = prop_data;\n\n\t\tres->time_increment_resolution = in->time_increment_resolution;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*res);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_MPEG4_HEADER_EXTENSION: {\n\t\tstruct hfi_mpeg4_header_extension *in = pdata, *ext = prop_data;\n\n\t\text->header_extension = in->header_extension;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*ext);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_H264_DEBLOCK_CONTROL: {\n\t\tstruct hfi_h264_db_control *in = pdata, *db = prop_data;\n\n\t\tswitch (in->mode) {\n\t\tcase HFI_H264_DB_MODE_DISABLE:\n\t\tcase HFI_H264_DB_MODE_SKIP_SLICE_BOUNDARY:\n\t\tcase HFI_H264_DB_MODE_ALL_BOUNDARY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdb->mode = in->mode;\n\t\tdb->slice_alpha_offset = in->slice_alpha_offset;\n\t\tdb->slice_beta_offset = in->slice_beta_offset;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*db);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_SESSION_QP: {\n\t\tstruct hfi_quantization *in = pdata, *quant = prop_data;\n\n\t\tquant->qp_i = in->qp_i;\n\t\tquant->qp_p = in->qp_p;\n\t\tquant->qp_b = in->qp_b;\n\t\tquant->layer_id = in->layer_id;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*quant);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_SESSION_QP_RANGE: {\n\t\tstruct hfi_quantization_range *in = pdata, *range = prop_data;\n\t\tu32 min_qp, max_qp;\n\n\t\tmin_qp = in->min_qp;\n\t\tmax_qp = in->max_qp;\n\n\t\t \n\t\tif (min_qp > 0xff || max_qp > 0xff) {\n\t\t\tret = -ERANGE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trange->min_qp = min_qp | min_qp << 8 | min_qp << 16;\n\t\trange->max_qp = max_qp | max_qp << 8 | max_qp << 16;\n\t\trange->layer_id = in->layer_id;\n\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*range);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_VC1_PERF_CFG: {\n\t\tstruct hfi_vc1e_perf_cfg_type *in = pdata, *perf = prop_data;\n\n\t\tmemcpy(perf->search_range_x_subsampled,\n\t\t       in->search_range_x_subsampled,\n\t\t       sizeof(perf->search_range_x_subsampled));\n\t\tmemcpy(perf->search_range_y_subsampled,\n\t\t       in->search_range_y_subsampled,\n\t\t       sizeof(perf->search_range_y_subsampled));\n\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*perf);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_MAX_NUM_B_FRAMES: {\n\t\tstruct hfi_max_num_b_frames *bframes = prop_data;\n\t\tu32 *in = pdata;\n\n\t\tbframes->max_num_b_frames = *in;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*bframes);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VENC_INTRA_PERIOD: {\n\t\tstruct hfi_intra_period *in = pdata, *intra = prop_data;\n\n\t\tintra->pframes = in->pframes;\n\t\tintra->bframes = in->bframes;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*intra);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VENC_IDR_PERIOD: {\n\t\tstruct hfi_idr_period *in = pdata, *idr = prop_data;\n\n\t\tidr->idr_period = in->idr_period;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*idr);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_CONCEAL_COLOR: {\n\t\tstruct hfi_conceal_color *color = prop_data;\n\t\tu32 *in = pdata;\n\n\t\tcolor->conceal_color = *in & 0xff;\n\t\tcolor->conceal_color |= ((*in >> 10) & 0xff) << 8;\n\t\tcolor->conceal_color |= ((*in >> 20) & 0xff) << 16;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*color);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VPE_OPERATIONS: {\n\t\tstruct hfi_operations_type *in = pdata, *ops = prop_data;\n\n\t\tswitch (in->rotation) {\n\t\tcase HFI_ROTATE_NONE:\n\t\tcase HFI_ROTATE_90:\n\t\tcase HFI_ROTATE_180:\n\t\tcase HFI_ROTATE_270:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (in->flip) {\n\t\tcase HFI_FLIP_NONE:\n\t\tcase HFI_FLIP_HORIZONTAL:\n\t\tcase HFI_FLIP_VERTICAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tops->rotation = in->rotation;\n\t\tops->flip = in->flip;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*ops);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_INTRA_REFRESH: {\n\t\tstruct hfi_intra_refresh *in = pdata, *intra = prop_data;\n\n\t\tswitch (in->mode) {\n\t\tcase HFI_INTRA_REFRESH_NONE:\n\t\tcase HFI_INTRA_REFRESH_ADAPTIVE:\n\t\tcase HFI_INTRA_REFRESH_CYCLIC:\n\t\tcase HFI_INTRA_REFRESH_CYCLIC_ADAPTIVE:\n\t\tcase HFI_INTRA_REFRESH_RANDOM:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tintra->mode = in->mode;\n\t\tintra->air_mbs = in->air_mbs;\n\t\tintra->air_ref = in->air_ref;\n\t\tintra->cir_mbs = in->cir_mbs;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*intra);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_MULTI_SLICE_CONTROL: {\n\t\tstruct hfi_multi_slice_control *in = pdata, *multi = prop_data;\n\n\t\tswitch (in->multi_slice) {\n\t\tcase HFI_MULTI_SLICE_OFF:\n\t\tcase HFI_MULTI_SLICE_GOB:\n\t\tcase HFI_MULTI_SLICE_BY_MB_COUNT:\n\t\tcase HFI_MULTI_SLICE_BY_BYTE_COUNT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmulti->multi_slice = in->multi_slice;\n\t\tmulti->slice_size = in->slice_size;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*multi);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_SLICE_DELIVERY_MODE: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_H264_VUI_TIMING_INFO: {\n\t\tstruct hfi_h264_vui_timing_info *in = pdata, *vui = prop_data;\n\n\t\tvui->enable = in->enable;\n\t\tvui->fixed_framerate = in->fixed_framerate;\n\t\tvui->time_scale = in->time_scale;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*vui);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VPE_DEINTERLACE: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_H264_GENERATE_AUDNAL: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_BUFFER_ALLOC_MODE: {\n\t\tstruct hfi_buffer_alloc_mode *in = pdata, *mode = prop_data;\n\n\t\tmode->type = in->type;\n\t\tmode->mode = in->mode;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*mode);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_FRAME_ASSEMBLY: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_H264_VUI_BITSTREAM_RESTRC: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_PRESERVE_TEXT_QUALITY: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_SCS_THRESHOLD: {\n\t\tstruct hfi_scs_threshold *thres = prop_data;\n\t\tu32 *in = pdata;\n\n\t\tthres->threshold_value = *in;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*thres);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_MVC_BUFFER_LAYOUT: {\n\t\tstruct hfi_mvc_buffer_layout_descp_type *in = pdata;\n\t\tstruct hfi_mvc_buffer_layout_descp_type *mvc = prop_data;\n\n\t\tswitch (in->layout_type) {\n\t\tcase HFI_MVC_BUFFER_LAYOUT_TOP_BOTTOM:\n\t\tcase HFI_MVC_BUFFER_LAYOUT_SEQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmvc->layout_type = in->layout_type;\n\t\tmvc->bright_view_first = in->bright_view_first;\n\t\tmvc->ngap = in->ngap;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*mvc);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_LTRMODE: {\n\t\tstruct hfi_ltr_mode *in = pdata, *ltr = prop_data;\n\n\t\tswitch (in->ltr_mode) {\n\t\tcase HFI_LTR_MODE_DISABLE:\n\t\tcase HFI_LTR_MODE_MANUAL:\n\t\tcase HFI_LTR_MODE_PERIODIC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tltr->ltr_mode = in->ltr_mode;\n\t\tltr->ltr_count = in->ltr_count;\n\t\tltr->trust_mode = in->trust_mode;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*ltr);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VENC_USELTRFRAME: {\n\t\tstruct hfi_ltr_use *in = pdata, *ltr_use = prop_data;\n\n\t\tltr_use->frames = in->frames;\n\t\tltr_use->ref_ltr = in->ref_ltr;\n\t\tltr_use->use_constrnt = in->use_constrnt;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*ltr_use);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VENC_MARKLTRFRAME: {\n\t\tstruct hfi_ltr_mark *in = pdata, *ltr_mark = prop_data;\n\n\t\tltr_mark->mark_frame = in->mark_frame;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*ltr_mark);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_HIER_P_MAX_NUM_ENH_LAYER: {\n\t\tu32 *in = pdata;\n\n\t\tpkt->data[1] = *in;\n\t\tpkt->shdr.hdr.size += sizeof(u32) * 2;\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VENC_HIER_P_ENH_LAYER: {\n\t\tu32 *in = pdata;\n\n\t\tpkt->data[1] = *in;\n\t\tpkt->shdr.hdr.size += sizeof(u32) * 2;\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_DISABLE_RC_TIMESTAMP: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_INITIAL_QP: {\n\t\tstruct hfi_initial_quantization *in = pdata, *quant = prop_data;\n\n\t\tquant->init_qp_enable = in->init_qp_enable;\n\t\tquant->qp_i = in->qp_i;\n\t\tquant->qp_p = in->qp_p;\n\t\tquant->qp_b = in->qp_b;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*quant);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VPE_COLOR_SPACE_CONVERSION: {\n\t\tstruct hfi_vpe_color_space_conversion *in = pdata;\n\t\tstruct hfi_vpe_color_space_conversion *csc = prop_data;\n\n\t\tmemcpy(csc->csc_matrix, in->csc_matrix,\n\t\t       sizeof(csc->csc_matrix));\n\t\tmemcpy(csc->csc_bias, in->csc_bias, sizeof(csc->csc_bias));\n\t\tmemcpy(csc->csc_limit, in->csc_limit, sizeof(csc->csc_limit));\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*csc);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_VPX_ERROR_RESILIENCE_MODE: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_H264_NAL_SVC_EXT: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VENC_PERF_MODE: {\n\t\tu32 *in = pdata;\n\n\t\tpkt->data[1] = *in;\n\t\tpkt->shdr.hdr.size += sizeof(u32) * 2;\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_HIER_B_MAX_NUM_ENH_LAYER: {\n\t\tu32 *in = pdata;\n\n\t\tpkt->data[1] = *in;\n\t\tpkt->shdr.hdr.size += sizeof(u32) * 2;\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_NONCP_OUTPUT2: {\n\t\tstruct hfi_enable *in = pdata, *en = prop_data;\n\n\t\ten->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_HIER_P_HYBRID_MODE: {\n\t\tstruct hfi_hybrid_hierp *in = pdata, *hierp = prop_data;\n\n\t\thierp->layers = in->layers;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*hierp);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_UNCOMPRESSED_PLANE_ACTUAL_INFO: {\n\t\tstruct hfi_uncompressed_plane_actual_info *in = pdata;\n\t\tstruct hfi_uncompressed_plane_actual_info *info = prop_data;\n\n\t\tinfo->buffer_type = in->buffer_type;\n\t\tinfo->num_planes = in->num_planes;\n\t\tinfo->plane_format[0] = in->plane_format[0];\n\t\tif (in->num_planes > 1)\n\t\t\tinfo->plane_format[1] = in->plane_format[1];\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*info);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_HDR10_PQ_SEI:\n\t\treturn -ENOTSUPP;\n\n\t \n\tcase HFI_PROPERTY_CONFIG_BUFFER_REQUIREMENTS:\n\tcase HFI_PROPERTY_CONFIG_PRIORITY:\n\tcase HFI_PROPERTY_CONFIG_BATCH_INFO:\n\tcase HFI_PROPERTY_SYS_IDLE_INDICATOR:\n\tcase HFI_PROPERTY_PARAM_UNCOMPRESSED_FORMAT_SUPPORTED:\n\tcase HFI_PROPERTY_PARAM_INTERLACE_FORMAT_SUPPORTED:\n\tcase HFI_PROPERTY_PARAM_CHROMA_SITE:\n\tcase HFI_PROPERTY_PARAM_PROPERTIES_SUPPORTED:\n\tcase HFI_PROPERTY_PARAM_PROFILE_LEVEL_SUPPORTED:\n\tcase HFI_PROPERTY_PARAM_CAPABILITY_SUPPORTED:\n\tcase HFI_PROPERTY_PARAM_NAL_STREAM_FORMAT_SUPPORTED:\n\tcase HFI_PROPERTY_PARAM_MULTI_VIEW_FORMAT:\n\tcase HFI_PROPERTY_PARAM_MAX_SEQUENCE_HEADER_SIZE:\n\tcase HFI_PROPERTY_PARAM_CODEC_SUPPORTED:\n\tcase HFI_PROPERTY_PARAM_VDEC_MULTI_VIEW_SELECT:\n\tcase HFI_PROPERTY_PARAM_VDEC_MB_QUANTIZATION:\n\tcase HFI_PROPERTY_PARAM_VDEC_NUM_CONCEALED_MB:\n\tcase HFI_PROPERTY_PARAM_VDEC_H264_ENTROPY_SWITCHING:\n\tcase HFI_PROPERTY_PARAM_VENC_MULTI_SLICE_INFO:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int\npkt_session_get_property_3xx(struct hfi_session_get_property_pkt *pkt,\n\t\t\t     void *cookie, u32 ptype)\n{\n\tint ret = 0;\n\n\tif (!pkt || !cookie)\n\t\treturn -EINVAL;\n\n\tpkt->shdr.hdr.size = sizeof(struct hfi_session_get_property_pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_GET_PROPERTY;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->num_properties = 1;\n\n\tswitch (ptype) {\n\tcase HFI_PROPERTY_CONFIG_VDEC_ENTROPY:\n\t\tpkt->data[0] = HFI_PROPERTY_CONFIG_VDEC_ENTROPY;\n\t\tbreak;\n\tdefault:\n\t\tret = pkt_session_get_property_1x(pkt, cookie, ptype);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int\npkt_session_set_property_3xx(struct hfi_session_set_property_pkt *pkt,\n\t\t\t     void *cookie, u32 ptype, void *pdata)\n{\n\tvoid *prop_data;\n\tint ret = 0;\n\n\tif (!pkt || !cookie || !pdata)\n\t\treturn -EINVAL;\n\n\tprop_data = &pkt->data[1];\n\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_SET_PROPERTY;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->num_properties = 1;\n\tpkt->data[0] = ptype;\n\n\t \n\tswitch (ptype) {\n\tcase HFI_PROPERTY_PARAM_VDEC_MULTI_STREAM: {\n\t\tstruct hfi_multi_stream *in = pdata;\n\t\tstruct hfi_multi_stream_3x *multi = prop_data;\n\n\t\tmulti->buffer_type = in->buffer_type;\n\t\tmulti->enable = in->enable;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*multi);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_INTRA_REFRESH: {\n\t\tstruct hfi_intra_refresh *in = pdata;\n\t\tstruct hfi_intra_refresh_3x *intra = prop_data;\n\n\t\tswitch (in->mode) {\n\t\tcase HFI_INTRA_REFRESH_NONE:\n\t\tcase HFI_INTRA_REFRESH_ADAPTIVE:\n\t\tcase HFI_INTRA_REFRESH_CYCLIC:\n\t\tcase HFI_INTRA_REFRESH_CYCLIC_ADAPTIVE:\n\t\tcase HFI_INTRA_REFRESH_RANDOM:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tintra->mode = in->mode;\n\t\tintra->mbs = in->cir_mbs;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*intra);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_CONTINUE_DATA_TRANSFER:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tret = pkt_session_set_property_1x(pkt, cookie, ptype, pdata);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int\npkt_session_set_property_4xx(struct hfi_session_set_property_pkt *pkt,\n\t\t\t     void *cookie, u32 ptype, void *pdata)\n{\n\tvoid *prop_data;\n\n\tif (!pkt || !cookie || !pdata)\n\t\treturn -EINVAL;\n\n\tprop_data = &pkt->data[1];\n\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_SET_PROPERTY;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->num_properties = 1;\n\tpkt->data[0] = ptype;\n\n\t \n\tswitch (ptype) {\n\tcase HFI_PROPERTY_PARAM_BUFFER_COUNT_ACTUAL: {\n\t\tstruct hfi_buffer_count_actual *in = pdata;\n\t\tstruct hfi_buffer_count_actual_4xx *count = prop_data;\n\n\t\tcount->count_actual = in->count_actual;\n\t\tcount->type = in->type;\n\t\tcount->count_min_host = in->count_actual;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*count);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_WORK_MODE: {\n\t\tstruct hfi_video_work_mode *in = pdata, *wm = prop_data;\n\n\t\twm->video_work_mode = in->video_work_mode;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*wm);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VIDEOCORES_USAGE: {\n\t\tstruct hfi_videocores_usage_type *in = pdata, *cu = prop_data;\n\n\t\tcu->video_core_enable_mask = in->video_core_enable_mask;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*cu);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_HDR10_PQ_SEI: {\n\t\tstruct hfi_hdr10_pq_sei *in = pdata, *hdr10 = prop_data;\n\n\t\tmemcpy(hdr10, in, sizeof(*hdr10));\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*hdr10);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VDEC_CONCEAL_COLOR: {\n\t\tstruct hfi_conceal_color_v4 *color = prop_data;\n\t\tu32 *in = pdata;\n\n\t\tcolor->conceal_color_8bit = *in & 0xff;\n\t\tcolor->conceal_color_8bit |= ((*in >> 10) & 0xff) << 8;\n\t\tcolor->conceal_color_8bit |= ((*in >> 20) & 0xff) << 16;\n\t\tcolor->conceal_color_10bit = *in;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*color);\n\t\tbreak;\n\t}\n\n\tcase HFI_PROPERTY_PARAM_VENC_H264_TRANSFORM_8X8: {\n\t\tstruct hfi_h264_8x8_transform *in = pdata, *tm = prop_data;\n\n\t\ttm->enable_type = in->enable_type;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*tm);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_VENC_SESSION_QP_RANGE_V2: {\n\t\tstruct hfi_quantization_range_v2 *in = pdata, *range = prop_data;\n\t\tu32 min_qp, max_qp;\n\n\t\tmin_qp = in->min_qp.qp_packed;\n\t\tmax_qp = in->max_qp.qp_packed;\n\n\t\t \n\t\tif (min_qp > 0xff || max_qp > 0xff)\n\t\t\treturn -ERANGE;\n\n\t\trange->min_qp.layer_id = 0xFF;\n\t\trange->max_qp.layer_id = 0xFF;\n\t\trange->min_qp.qp_packed = (min_qp & 0xFF) | ((min_qp & 0xFF) << 8) |\n\t\t\t((min_qp & 0xFF) << 16);\n\t\trange->max_qp.qp_packed = (max_qp & 0xFF) | ((max_qp & 0xFF) << 8) |\n\t\t\t((max_qp & 0xFF) << 16);\n\t\trange->min_qp.enable = 7;\n\t\trange->max_qp.enable = 7;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*range);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_VENC_MAX_BITRATE:\n\tcase HFI_PROPERTY_CONFIG_VDEC_POST_LOOP_DEBLOCKER:\n\tcase HFI_PROPERTY_PARAM_BUFFER_ALLOC_MODE:\n\tcase HFI_PROPERTY_PARAM_VENC_SESSION_QP:\n\tcase HFI_PROPERTY_PARAM_VENC_SESSION_QP_RANGE:\n\t\t \n\t\treturn -ENOTSUPP;\n\tdefault:\n\t\treturn pkt_session_set_property_3xx(pkt, cookie, ptype, pdata);\n\t}\n\n\treturn 0;\n}\n\nstatic int\npkt_session_set_property_6xx(struct hfi_session_set_property_pkt *pkt,\n\t\t\t     void *cookie, u32 ptype, void *pdata)\n{\n\tvoid *prop_data;\n\n\tif (!pkt || !cookie || !pdata)\n\t\treturn -EINVAL;\n\n\tprop_data = &pkt->data[1];\n\n\tpkt->shdr.hdr.size = sizeof(*pkt);\n\tpkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_SET_PROPERTY;\n\tpkt->shdr.session_id = hash32_ptr(cookie);\n\tpkt->num_properties = 1;\n\tpkt->data[0] = ptype;\n\n\tswitch (ptype) {\n\tcase HFI_PROPERTY_PARAM_UNCOMPRESSED_PLANE_ACTUAL_CONSTRAINTS_INFO: {\n\t\tstruct hfi_uncompressed_plane_actual_constraints_info *in = pdata;\n\t\tstruct hfi_uncompressed_plane_actual_constraints_info *info = prop_data;\n\n\t\tinfo->buffer_type = in->buffer_type;\n\t\tinfo->num_planes = in->num_planes;\n\t\tinfo->plane_format[0] = in->plane_format[0];\n\t\tif (in->num_planes > 1)\n\t\t\tinfo->plane_format[1] = in->plane_format[1];\n\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*info);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_CONFIG_HEIC_FRAME_QUALITY: {\n\t\tstruct hfi_heic_frame_quality *in = pdata, *cq = prop_data;\n\n\t\tcq->frame_quality = in->frame_quality;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*cq);\n\t\tbreak;\n\t}\n\tcase HFI_PROPERTY_PARAM_WORK_ROUTE: {\n\t\tstruct hfi_video_work_route *in = pdata, *wr = prop_data;\n\n\t\twr->video_work_route = in->video_work_route;\n\t\tpkt->shdr.hdr.size += sizeof(u32) + sizeof(*wr);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn pkt_session_set_property_4xx(pkt, cookie, ptype, pdata);\n\t}\n\n\treturn 0;\n}\n\nint pkt_session_get_property(struct hfi_session_get_property_pkt *pkt,\n\t\t\t     void *cookie, u32 ptype)\n{\n\tif (hfi_ver == HFI_VERSION_1XX)\n\t\treturn pkt_session_get_property_1x(pkt, cookie, ptype);\n\n\treturn pkt_session_get_property_3xx(pkt, cookie, ptype);\n}\n\nint pkt_session_set_property(struct hfi_session_set_property_pkt *pkt,\n\t\t\t     void *cookie, u32 ptype, void *pdata)\n{\n\tif (hfi_ver == HFI_VERSION_1XX)\n\t\treturn pkt_session_set_property_1x(pkt, cookie, ptype, pdata);\n\n\tif (hfi_ver == HFI_VERSION_3XX)\n\t\treturn pkt_session_set_property_3xx(pkt, cookie, ptype, pdata);\n\n\tif (hfi_ver == HFI_VERSION_4XX)\n\t\treturn pkt_session_set_property_4xx(pkt, cookie, ptype, pdata);\n\n\treturn pkt_session_set_property_6xx(pkt, cookie, ptype, pdata);\n}\n\nvoid pkt_set_version(enum hfi_version version)\n{\n\thfi_ver = version;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}