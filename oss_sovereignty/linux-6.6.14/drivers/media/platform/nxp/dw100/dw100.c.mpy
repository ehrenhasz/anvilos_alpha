{
  "module_name": "dw100.c",
  "hash_id": "7d84ffee6482add12f779d0d264fa39fa50c6ec651c2b8944c50e6a5c11cc075",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/dw100/dw100.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include <uapi/linux/dw100.h>\n\n#include \"dw100_regs.h\"\n\n#define DRV_NAME \"dw100\"\n\n#define DW100_MIN_W\t\t176u\n#define DW100_MIN_H\t\t144u\n#define DW100_MAX_W\t\t4096u\n#define DW100_MAX_H\t\t3072u\n#define DW100_ALIGN_W\t\t3\n#define DW100_ALIGN_H\t\t3\n\n#define DW100_BLOCK_SIZE\t16\n\n#define DW100_DEF_W\t\t640u\n#define DW100_DEF_H\t\t480u\n#define DW100_DEF_LUT_W\t\t(DIV_ROUND_UP(DW100_DEF_W, DW100_BLOCK_SIZE) + 1)\n#define DW100_DEF_LUT_H\t\t(DIV_ROUND_UP(DW100_DEF_H, DW100_BLOCK_SIZE) + 1)\n\n \n#define DW100_MAX_CTRLS\t\t\t1\n#define DW100_CTRL_DEWARPING_MAP\t0\n\nenum {\n\tDW100_QUEUE_SRC = 0,\n\tDW100_QUEUE_DST = 1,\n};\n\nenum {\n\tDW100_FMT_CAPTURE = BIT(0),\n\tDW100_FMT_OUTPUT = BIT(1),\n};\n\nstruct dw100_device {\n\tstruct platform_device\t\t*pdev;\n\tstruct v4l2_m2m_dev\t\t*m2m_dev;\n\tstruct v4l2_device\t\tv4l2_dev;\n\tstruct video_device\t\tvfd;\n\tstruct media_device\t\tmdev;\n\t \n\tstruct mutex\t\t\tvfd_mutex;\n\tvoid __iomem\t\t\t*mmio;\n\tstruct clk_bulk_data\t\t*clks;\n\tint\t\t\t\tnum_clks;\n\tstruct dentry\t\t\t*debugfs_root;\n};\n\nstruct dw100_q_data {\n\tstruct v4l2_pix_format_mplane\tpix_fmt;\n\tunsigned int\t\t\tsequence;\n\tconst struct dw100_fmt\t\t*fmt;\n\tstruct v4l2_rect\t\tcrop;\n};\n\nstruct dw100_ctx {\n\tstruct v4l2_fh\t\t\tfh;\n\tstruct dw100_device\t\t*dw_dev;\n\tstruct v4l2_ctrl_handler\thdl;\n\tstruct v4l2_ctrl\t\t*ctrls[DW100_MAX_CTRLS];\n\t \n\tstruct mutex\t\t\tvq_mutex;\n\n\t \n\tunsigned int\t\t\t*map;\n\tdma_addr_t\t\t\tmap_dma;\n\tsize_t\t\t\t\tmap_size;\n\tunsigned int\t\t\tmap_width;\n\tunsigned int\t\t\tmap_height;\n\tbool\t\t\t\tuser_map_is_set;\n\n\t \n\tstruct dw100_q_data\t\tq_data[2];\n};\n\nstatic const struct v4l2_frmsize_stepwise dw100_frmsize_stepwise = {\n\t.min_width = DW100_MIN_W,\n\t.min_height = DW100_MIN_H,\n\t.max_width = DW100_MAX_W,\n\t.max_height = DW100_MAX_H,\n\t.step_width = 1UL << DW100_ALIGN_W,\n\t.step_height = 1UL << DW100_ALIGN_H,\n};\n\nstatic const struct dw100_fmt {\n\tu32 fourcc;\n\tu32 types;\n\tu32 reg_format;\n\tbool reg_swap_uv;\n} formats[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV16,\n\t\t.types = DW100_FMT_OUTPUT | DW100_FMT_CAPTURE,\n\t\t.reg_format = DW100_DEWARP_CTRL_FORMAT_YUV422_SP,\n\t\t.reg_swap_uv = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV16M,\n\t\t.types = DW100_FMT_OUTPUT | DW100_FMT_CAPTURE,\n\t\t.reg_format = DW100_DEWARP_CTRL_FORMAT_YUV422_SP,\n\t\t.reg_swap_uv = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV61,\n\t\t.types = DW100_FMT_CAPTURE,\n\t\t.reg_format = DW100_DEWARP_CTRL_FORMAT_YUV422_SP,\n\t\t.reg_swap_uv = true,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV61M,\n\t\t.types = DW100_FMT_CAPTURE,\n\t\t.reg_format = DW100_DEWARP_CTRL_FORMAT_YUV422_SP,\n\t\t.reg_swap_uv = true,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.types = DW100_FMT_OUTPUT | DW100_FMT_CAPTURE,\n\t\t.reg_format = DW100_DEWARP_CTRL_FORMAT_YUV422_PACKED,\n\t\t.reg_swap_uv = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_UYVY,\n\t\t.types = DW100_FMT_OUTPUT | DW100_FMT_CAPTURE,\n\t\t.reg_format = DW100_DEWARP_CTRL_FORMAT_YUV422_PACKED,\n\t\t.reg_swap_uv = true,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV12,\n\t\t.types = DW100_FMT_OUTPUT | DW100_FMT_CAPTURE,\n\t\t.reg_format = DW100_DEWARP_CTRL_FORMAT_YUV420_SP,\n\t\t.reg_swap_uv = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV12M,\n\t\t.types = DW100_FMT_OUTPUT | DW100_FMT_CAPTURE,\n\t\t.reg_format = DW100_DEWARP_CTRL_FORMAT_YUV420_SP,\n\t\t.reg_swap_uv = false,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV21,\n\t\t.types = DW100_FMT_CAPTURE,\n\t\t.reg_format = DW100_DEWARP_CTRL_FORMAT_YUV420_SP,\n\t\t.reg_swap_uv = true,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV21M,\n\t\t.types = DW100_FMT_CAPTURE,\n\t\t.reg_format = DW100_DEWARP_CTRL_FORMAT_YUV420_SP,\n\t\t.reg_swap_uv = true,\n\t},\n};\n\nstatic inline int to_dw100_fmt_type(enum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn DW100_FMT_OUTPUT;\n\telse\n\t\treturn DW100_FMT_CAPTURE;\n}\n\nstatic const struct dw100_fmt *dw100_find_pixel_format(u32 pixel_format,\n\t\t\t\t\t\t       int fmt_type)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\tconst struct dw100_fmt *fmt = &formats[i];\n\n\t\tif (fmt->fourcc == pixel_format && fmt->types & fmt_type)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct dw100_fmt *dw100_find_format(struct v4l2_format *f)\n{\n\treturn dw100_find_pixel_format(f->fmt.pix_mp.pixelformat,\n\t\t\t\t       to_dw100_fmt_type(f->type));\n}\n\nstatic inline u32 dw100_read(struct dw100_device *dw_dev, u32 reg)\n{\n\treturn readl(dw_dev->mmio + reg);\n}\n\nstatic inline void dw100_write(struct dw100_device *dw_dev, u32 reg, u32 val)\n{\n\twritel(val, dw_dev->mmio + reg);\n}\n\nstatic inline int dw100_dump_regs(struct seq_file *m)\n{\n\tstruct dw100_device *dw_dev = m->private;\n#define __DECLARE_REG(x) { #x, x }\n\tunsigned int i;\n\tstatic const struct reg_desc {\n\t\tconst char * const name;\n\t\tunsigned int addr;\n\t} dw100_regs[] = {\n\t\t__DECLARE_REG(DW100_DEWARP_ID),\n\t\t__DECLARE_REG(DW100_DEWARP_CTRL),\n\t\t__DECLARE_REG(DW100_MAP_LUT_ADDR),\n\t\t__DECLARE_REG(DW100_MAP_LUT_SIZE),\n\t\t__DECLARE_REG(DW100_MAP_LUT_ADDR2),\n\t\t__DECLARE_REG(DW100_MAP_LUT_SIZE2),\n\t\t__DECLARE_REG(DW100_SRC_IMG_Y_BASE),\n\t\t__DECLARE_REG(DW100_SRC_IMG_UV_BASE),\n\t\t__DECLARE_REG(DW100_SRC_IMG_SIZE),\n\t\t__DECLARE_REG(DW100_SRC_IMG_STRIDE),\n\t\t__DECLARE_REG(DW100_DST_IMG_Y_BASE),\n\t\t__DECLARE_REG(DW100_DST_IMG_UV_BASE),\n\t\t__DECLARE_REG(DW100_DST_IMG_SIZE),\n\t\t__DECLARE_REG(DW100_DST_IMG_STRIDE),\n\t\t__DECLARE_REG(DW100_DST_IMG_Y_SIZE1),\n\t\t__DECLARE_REG(DW100_DST_IMG_UV_SIZE1),\n\t\t__DECLARE_REG(DW100_SRC_IMG_Y_BASE2),\n\t\t__DECLARE_REG(DW100_SRC_IMG_UV_BASE2),\n\t\t__DECLARE_REG(DW100_SRC_IMG_SIZE2),\n\t\t__DECLARE_REG(DW100_SRC_IMG_STRIDE2),\n\t\t__DECLARE_REG(DW100_DST_IMG_Y_BASE2),\n\t\t__DECLARE_REG(DW100_DST_IMG_UV_BASE2),\n\t\t__DECLARE_REG(DW100_DST_IMG_SIZE2),\n\t\t__DECLARE_REG(DW100_DST_IMG_STRIDE2),\n\t\t__DECLARE_REG(DW100_DST_IMG_Y_SIZE2),\n\t\t__DECLARE_REG(DW100_DST_IMG_UV_SIZE2),\n\t\t__DECLARE_REG(DW100_SWAP_CONTROL),\n\t\t__DECLARE_REG(DW100_VERTICAL_SPLIT_LINE),\n\t\t__DECLARE_REG(DW100_HORIZON_SPLIT_LINE),\n\t\t__DECLARE_REG(DW100_SCALE_FACTOR),\n\t\t__DECLARE_REG(DW100_ROI_START),\n\t\t__DECLARE_REG(DW100_BOUNDARY_PIXEL),\n\t\t__DECLARE_REG(DW100_INTERRUPT_STATUS),\n\t\t__DECLARE_REG(DW100_BUS_CTRL),\n\t\t__DECLARE_REG(DW100_BUS_CTRL1),\n\t\t__DECLARE_REG(DW100_BUS_TIME_OUT_CYCLE),\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(dw100_regs); i++)\n\t\tseq_printf(m, \"%s: %#x\\n\", dw100_regs[i].name,\n\t\t\t   dw100_read(dw_dev, dw100_regs[i].addr));\n\n\treturn 0;\n}\n\nstatic inline struct dw100_ctx *dw100_file2ctx(struct file *file)\n{\n\treturn container_of(file->private_data, struct dw100_ctx, fh);\n}\n\nstatic struct dw100_q_data *dw100_get_q_data(struct dw100_ctx *ctx,\n\t\t\t\t\t     enum v4l2_buf_type type)\n{\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn &ctx->q_data[DW100_QUEUE_SRC];\n\telse\n\t\treturn &ctx->q_data[DW100_QUEUE_DST];\n}\n\nstatic u32 dw100_get_n_vertices_from_length(u32 length)\n{\n\treturn DIV_ROUND_UP(length, DW100_BLOCK_SIZE) + 1;\n}\n\nstatic u16 dw100_map_convert_to_uq12_4(u32 a)\n{\n\treturn (u16)((a & 0xfff) << 4);\n}\n\nstatic u32 dw100_map_format_coordinates(u16 xq, u16 yq)\n{\n\treturn (u32)((yq << 16) | xq);\n}\n\nstatic u32 *dw100_get_user_map(struct dw100_ctx *ctx)\n{\n\tstruct v4l2_ctrl *ctrl = ctx->ctrls[DW100_CTRL_DEWARPING_MAP];\n\n\treturn ctrl->p_cur.p_u32;\n}\n\n \nstatic int dw100_create_mapping(struct dw100_ctx *ctx)\n{\n\tu32 *user_map;\n\n\tif (ctx->map)\n\t\tdma_free_coherent(&ctx->dw_dev->pdev->dev, ctx->map_size,\n\t\t\t\t  ctx->map, ctx->map_dma);\n\n\tctx->map = dma_alloc_coherent(&ctx->dw_dev->pdev->dev, ctx->map_size,\n\t\t\t\t      &ctx->map_dma, GFP_KERNEL);\n\n\tif (!ctx->map)\n\t\treturn -ENOMEM;\n\n\tuser_map = dw100_get_user_map(ctx);\n\tmemcpy(ctx->map, user_map, ctx->map_size);\n\n\tdev_dbg(&ctx->dw_dev->pdev->dev,\n\t\t\"%ux%u %s mapping created (d:%pad-c:%p) for stream %ux%u->%ux%u\\n\",\n\t\tctx->map_width, ctx->map_height,\n\t\tctx->user_map_is_set ? \"user\" : \"identity\",\n\t\t&ctx->map_dma, ctx->map,\n\t\tctx->q_data[DW100_QUEUE_SRC].pix_fmt.width,\n\t\tctx->q_data[DW100_QUEUE_DST].pix_fmt.height,\n\t\tctx->q_data[DW100_QUEUE_SRC].pix_fmt.width,\n\t\tctx->q_data[DW100_QUEUE_DST].pix_fmt.height);\n\n\treturn 0;\n}\n\nstatic void dw100_destroy_mapping(struct dw100_ctx *ctx)\n{\n\tif (ctx->map) {\n\t\tdma_free_coherent(&ctx->dw_dev->pdev->dev, ctx->map_size,\n\t\t\t\t  ctx->map, ctx->map_dma);\n\t\tctx->map = NULL;\n\t}\n}\n\nstatic int dw100_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct dw100_ctx *ctx =\n\t\tcontainer_of(ctrl->handler, struct dw100_ctx, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_DW100_DEWARPING_16x16_VERTEX_MAP:\n\t\tctx->user_map_is_set = true;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops dw100_ctrl_ops = {\n\t.s_ctrl = dw100_s_ctrl,\n};\n\n \nstatic void dw100_ctrl_dewarping_map_init(const struct v4l2_ctrl *ctrl,\n\t\t\t\t\t  u32 from_idx,\n\t\t\t\t\t  union v4l2_ctrl_ptr ptr)\n{\n\tstruct dw100_ctx *ctx =\n\t\tcontainer_of(ctrl->handler, struct dw100_ctx, hdl);\n\n\tu32 sw, sh, mw, mh, idx;\n\tu16 qx, qy, qdx, qdy, qsh, qsw;\n\tu32 *map = ctrl->p_cur.p_u32;\n\n\tsw = ctx->q_data[DW100_QUEUE_SRC].pix_fmt.width;\n\tsh = ctx->q_data[DW100_QUEUE_SRC].pix_fmt.height;\n\n\tmw = ctrl->dims[0];\n\tmh = ctrl->dims[1];\n\n\tqsw = dw100_map_convert_to_uq12_4(sw);\n\tqsh = dw100_map_convert_to_uq12_4(sh);\n\tqdx = qsw / (mw - 1);\n\tqdy = qsh / (mh - 1);\n\n\tctx->map_width = mw;\n\tctx->map_height = mh;\n\tctx->map_size = mh * mw * sizeof(u32);\n\n\tfor (idx = from_idx; idx < ctrl->elems; idx++) {\n\t\tqy = min_t(u32, (idx / mw) * qdy, qsh);\n\t\tqx = min_t(u32, (idx % mw) * qdx, qsw);\n\t\tmap[idx] = dw100_map_format_coordinates(qx, qy);\n\t}\n\n\tctx->user_map_is_set = false;\n}\n\nstatic const struct v4l2_ctrl_type_ops dw100_ctrl_type_ops = {\n\t.init = dw100_ctrl_dewarping_map_init,\n\t.validate = v4l2_ctrl_type_op_validate,\n\t.log = v4l2_ctrl_type_op_log,\n\t.equal = v4l2_ctrl_type_op_equal,\n};\n\nstatic const struct v4l2_ctrl_config controls[] = {\n\t[DW100_CTRL_DEWARPING_MAP] = {\n\t\t.ops = &dw100_ctrl_ops,\n\t\t.type_ops = &dw100_ctrl_type_ops,\n\t\t.id = V4L2_CID_DW100_DEWARPING_16x16_VERTEX_MAP,\n\t\t.name = \"Dewarping Vertex Map\",\n\t\t.type = V4L2_CTRL_TYPE_U32,\n\t\t.min = 0x00000000,\n\t\t.max = 0xffffffff,\n\t\t.step = 1,\n\t\t.def = 0,\n\t\t.dims = { DW100_DEF_LUT_W, DW100_DEF_LUT_H },\n\t},\n};\n\nstatic int dw100_queue_setup(struct vb2_queue *vq,\n\t\t\t     unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t     unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct dw100_ctx *ctx = vb2_get_drv_priv(vq);\n\tconst struct v4l2_pix_format_mplane *format;\n\tunsigned int i;\n\n\tformat = &dw100_get_q_data(ctx, vq->type)->pix_fmt;\n\n\tif (*nplanes) {\n\t\tif (*nplanes != format->num_planes)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < *nplanes; ++i) {\n\t\t\tif (sizes[i] < format->plane_fmt[i].sizeimage)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t*nplanes = format->num_planes;\n\n\tfor (i = 0; i < format->num_planes; ++i)\n\t\tsizes[i] = format->plane_fmt[i].sizeimage;\n\n\treturn 0;\n}\n\nstatic int dw100_buf_prepare(struct vb2_buffer *vb)\n{\n\tunsigned int i;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct dw100_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct dw100_device *dw_dev = ctx->dw_dev;\n\tconst struct v4l2_pix_format_mplane *pix_fmt =\n\t\t&dw100_get_q_data(ctx, vb->vb2_queue->type)->pix_fmt;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\n\t\tif (vbuf->field != V4L2_FIELD_NONE) {\n\t\t\tdev_dbg(&dw_dev->pdev->dev, \"%x field isn't supported\\n\",\n\t\t\t\tvbuf->field);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pix_fmt->num_planes; i++) {\n\t\tunsigned long size = pix_fmt->plane_fmt[i].sizeimage;\n\n\t\tif (vb2_plane_size(vb, i) < size) {\n\t\t\tdev_dbg(&dw_dev->pdev->dev,\n\t\t\t\t\"User buffer too small (%lu < %lu)\\n\",\n\t\t\t\tvb2_plane_size(vb, i), size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvb2_set_plane_payload(vb, i, size);\n\t}\n\n\treturn 0;\n}\n\nstatic void dw100_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct dw100_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic void dw100_return_all_buffers(struct vb2_queue *q,\n\t\t\t\t     enum vb2_buffer_state state)\n{\n\tstruct dw100_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tfor (;;) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (!vbuf)\n\t\t\treturn;\n\t\tv4l2_m2m_buf_done(vbuf, state);\n\t}\n}\n\nstatic int dw100_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct dw100_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct dw100_q_data *q_data = dw100_get_q_data(ctx, q->type);\n\tint ret;\n\n\tq_data->sequence = 0;\n\n\tret = dw100_create_mapping(ctx);\n\tif (ret)\n\t\tgoto err;\n\n\tret = pm_runtime_resume_and_get(&ctx->dw_dev->pdev->dev);\n\tif (ret) {\n\t\tdw100_destroy_mapping(ctx);\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdw100_return_all_buffers(q, VB2_BUF_STATE_QUEUED);\n\treturn ret;\n}\n\nstatic void dw100_stop_streaming(struct vb2_queue *q)\n{\n\tstruct dw100_ctx *ctx = vb2_get_drv_priv(q);\n\n\tdw100_return_all_buffers(q, VB2_BUF_STATE_ERROR);\n\n\tpm_runtime_put_sync(&ctx->dw_dev->pdev->dev);\n\n\tdw100_destroy_mapping(ctx);\n}\n\nstatic const struct vb2_ops dw100_qops = {\n\t.queue_setup\t = dw100_queue_setup,\n\t.buf_prepare\t = dw100_buf_prepare,\n\t.buf_queue\t = dw100_buf_queue,\n\t.start_streaming = dw100_start_streaming,\n\t.stop_streaming  = dw100_stop_streaming,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n};\n\nstatic int dw100_m2m_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t\tstruct vb2_queue *dst_vq)\n{\n\tstruct dw100_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->ops = &dw100_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->vq_mutex;\n\tsrc_vq->dev = ctx->dw_dev->v4l2_dev.dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops = &dw100_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->vq_mutex;\n\tdst_vq->dev = ctx->dw_dev->v4l2_dev.dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int dw100_open(struct file *file)\n{\n\tstruct dw100_device *dw_dev = video_drvdata(file);\n\tstruct dw100_ctx *ctx;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2_pix_format_mplane *pix_fmt;\n\tint ret, i;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ctx->vq_mutex);\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tctx->dw_dev = dw_dev;\n\n\tctx->q_data[DW100_QUEUE_SRC].fmt = &formats[0];\n\n\tpix_fmt = &ctx->q_data[DW100_QUEUE_SRC].pix_fmt;\n\tpix_fmt->field = V4L2_FIELD_NONE;\n\tpix_fmt->colorspace = V4L2_COLORSPACE_REC709;\n\tpix_fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(pix_fmt->colorspace);\n\tpix_fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(pix_fmt->colorspace);\n\tpix_fmt->quantization =\n\t\tV4L2_MAP_QUANTIZATION_DEFAULT(false, pix_fmt->colorspace,\n\t\t\t\t\t      pix_fmt->ycbcr_enc);\n\n\tv4l2_fill_pixfmt_mp(pix_fmt, formats[0].fourcc, DW100_DEF_W, DW100_DEF_H);\n\n\tctx->q_data[DW100_QUEUE_SRC].crop.top = 0;\n\tctx->q_data[DW100_QUEUE_SRC].crop.left = 0;\n\tctx->q_data[DW100_QUEUE_SRC].crop.width = DW100_DEF_W;\n\tctx->q_data[DW100_QUEUE_SRC].crop.height = DW100_DEF_H;\n\n\tctx->q_data[DW100_QUEUE_DST] = ctx->q_data[DW100_QUEUE_SRC];\n\n\thdl = &ctx->hdl;\n\tv4l2_ctrl_handler_init(hdl, ARRAY_SIZE(controls));\n\tfor (i = 0; i < ARRAY_SIZE(controls); i++) {\n\t\tctx->ctrls[i] = v4l2_ctrl_new_custom(hdl, &controls[i], NULL);\n\t\tif (hdl->error) {\n\t\t\tdev_err(&ctx->dw_dev->pdev->dev,\n\t\t\t\t\"Adding control (%d) failed\\n\", i);\n\t\t\tret = hdl->error;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tctx->fh.ctrl_handler = hdl;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dw_dev->m2m_dev,\n\t\t\t\t\t    ctx, &dw100_m2m_queue_init);\n\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto err;\n\t}\n\n\tv4l2_fh_add(&ctx->fh);\n\n\treturn 0;\n\nerr:\n\tv4l2_ctrl_handler_free(hdl);\n\tv4l2_fh_exit(&ctx->fh);\n\tmutex_destroy(&ctx->vq_mutex);\n\tkfree(ctx);\n\n\treturn ret;\n}\n\nstatic int dw100_release(struct file *file)\n{\n\tstruct dw100_ctx *ctx = dw100_file2ctx(file);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_ctrl_handler_free(&ctx->hdl);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tmutex_destroy(&ctx->vq_mutex);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations dw100_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= dw100_open,\n\t.release\t= dw100_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic int dw100_querycap(struct file *file, void *priv,\n\t\t\t  struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, DRV_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, \"DW100 dewarper\", sizeof(cap->card));\n\n\treturn 0;\n}\n\nstatic int dw100_enum_fmt_vid(struct file *file, void *priv,\n\t\t\t      struct v4l2_fmtdesc *f)\n{\n\tint i, num = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\tif (formats[i].types & to_dw100_fmt_type(f->type)) {\n\t\t\tif (num == f->index) {\n\t\t\t\tf->pixelformat = formats[i].fourcc;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t++num;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int dw100_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t struct v4l2_frmsizeenum *fsize)\n{\n\tconst struct dw100_fmt *fmt;\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\n\tfmt = dw100_find_pixel_format(fsize->pixel_format,\n\t\t\t\t      DW100_FMT_OUTPUT | DW100_FMT_CAPTURE);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise = dw100_frmsize_stepwise;\n\n\treturn 0;\n}\n\nstatic int dw100_g_fmt_vid(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct dw100_ctx *ctx = dw100_file2ctx(file);\n\tstruct vb2_queue *vq;\n\tstruct dw100_q_data *q_data;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = dw100_get_q_data(ctx, f->type);\n\n\tf->fmt.pix_mp = q_data->pix_fmt;\n\n\treturn 0;\n}\n\nstatic int dw100_try_fmt(struct file *file, struct v4l2_format *f)\n{\n\tstruct dw100_ctx *ctx = dw100_file2ctx(file);\n\tstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\n\tconst struct dw100_fmt *fmt;\n\n\tfmt = dw100_find_format(f);\n\tif (!fmt) {\n\t\tfmt = &formats[0];\n\t\tpix->pixelformat = fmt->fourcc;\n\t}\n\n\tv4l2_apply_frmsize_constraints(&pix->width, &pix->height,\n\t\t\t\t       &dw100_frmsize_stepwise);\n\n\tv4l2_fill_pixfmt_mp(pix, fmt->fourcc, pix->width, pix->height);\n\n\tpix->field = V4L2_FIELD_NONE;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tif (pix->colorspace == V4L2_COLORSPACE_DEFAULT)\n\t\t\tpix->colorspace = V4L2_COLORSPACE_REC709;\n\t\tif (pix->xfer_func == V4L2_XFER_FUNC_DEFAULT)\n\t\t\tpix->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(pix->colorspace);\n\t\tif (pix->ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT)\n\t\t\tpix->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(pix->colorspace);\n\t\tif (pix->quantization == V4L2_QUANTIZATION_DEFAULT)\n\t\t\tpix->quantization =\n\t\t\t\tV4L2_MAP_QUANTIZATION_DEFAULT(false,\n\t\t\t\t\t\t\t      pix->colorspace,\n\t\t\t\t\t\t\t      pix->ycbcr_enc);\n\t} else {\n\t\t \n\t\tconst struct dw100_q_data *q_data =\n\t\t\tdw100_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\n\t\tpix->colorspace = q_data->pix_fmt.colorspace;\n\t\tpix->xfer_func = q_data->pix_fmt.xfer_func;\n\t\tpix->ycbcr_enc = q_data->pix_fmt.ycbcr_enc;\n\t\tpix->quantization = q_data->pix_fmt.quantization;\n\t}\n\n\treturn 0;\n}\n\nstatic int dw100_s_fmt(struct dw100_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct dw100_q_data *q_data;\n\tstruct vb2_queue *vq;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = dw100_get_q_data(ctx, f->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(vq)) {\n\t\tdev_dbg(&ctx->dw_dev->pdev->dev, \"%s queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tq_data->fmt = dw100_find_format(f);\n\tq_data->pix_fmt = f->fmt.pix_mp;\n\tq_data->crop.top = 0;\n\tq_data->crop.left = 0;\n\tq_data->crop.width = f->fmt.pix_mp.width;\n\tq_data->crop.height = f->fmt.pix_mp.height;\n\n\t \n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tstruct dw100_q_data *dst_q_data =\n\t\t\tdw100_get_q_data(ctx,\n\t\t\t\t\t V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\n\t\tdst_q_data->pix_fmt.colorspace = q_data->pix_fmt.colorspace;\n\t\tdst_q_data->pix_fmt.ycbcr_enc = q_data->pix_fmt.ycbcr_enc;\n\t\tdst_q_data->pix_fmt.quantization = q_data->pix_fmt.quantization;\n\t\tdst_q_data->pix_fmt.xfer_func = q_data->pix_fmt.xfer_func;\n\t}\n\n\tdev_dbg(&ctx->dw_dev->pdev->dev,\n\t\t\"Setting format for type %u, wxh: %ux%u, fmt: %p4cc\\n\",\n\t\tf->type, q_data->pix_fmt.width, q_data->pix_fmt.height,\n\t\t&q_data->pix_fmt.pixelformat);\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\n\t\tint ret;\n\t\tu32 dims[V4L2_CTRL_MAX_DIMS] = {};\n\t\tstruct v4l2_ctrl *ctrl = ctx->ctrls[DW100_CTRL_DEWARPING_MAP];\n\n\t\tdims[0] = dw100_get_n_vertices_from_length(q_data->pix_fmt.width);\n\t\tdims[1] = dw100_get_n_vertices_from_length(q_data->pix_fmt.height);\n\n\t\tret = v4l2_ctrl_modify_dimensions(ctrl, dims);\n\n\t\tif (ret) {\n\t\t\tdev_err(&ctx->dw_dev->pdev->dev,\n\t\t\t\t\"Modifying LUT dimensions failed with error %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dw100_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_format *f)\n{\n\tif (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn -EINVAL;\n\n\treturn dw100_try_fmt(file, f);\n}\n\nstatic int dw100_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct dw100_ctx *ctx = dw100_file2ctx(file);\n\tint ret;\n\n\tret = dw100_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dw100_s_fmt(ctx, f);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int dw100_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t struct v4l2_format *f)\n{\n\tif (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn -EINVAL;\n\n\treturn dw100_try_fmt(file, f);\n}\n\nstatic int dw100_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct dw100_ctx *ctx = dw100_file2ctx(file);\n\tint ret;\n\n\tret = dw100_try_fmt_vid_out(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dw100_s_fmt(ctx, f);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int dw100_g_selection(struct file *file, void *fh,\n\t\t\t     struct v4l2_selection *sel)\n{\n\tstruct dw100_ctx *ctx = dw100_file2ctx(file);\n\tstruct dw100_q_data *src_q_data;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tsrc_q_data = dw100_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = src_q_data->pix_fmt.width;\n\t\tsel->r.height = src_q_data->pix_fmt.height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r.top = src_q_data->crop.top;\n\t\tsel->r.left = src_q_data->crop.left;\n\t\tsel->r.width = src_q_data->crop.width;\n\t\tsel->r.height = src_q_data->crop.height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dw100_s_selection(struct file *file, void *fh,\n\t\t\t     struct v4l2_selection *sel)\n{\n\tstruct dw100_ctx *ctx = dw100_file2ctx(file);\n\tstruct dw100_q_data *src_q_data;\n\tu32 qscalex, qscaley, qscale;\n\tint x, y, w, h;\n\tunsigned int wframe, hframe;\n\n\tif (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tsrc_q_data = dw100_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\n\tdev_dbg(&ctx->dw_dev->pdev->dev,\n\t\t\">>> Buffer Type: %u Target: %u Rect: %ux%u@%d.%d\\n\",\n\t\tsel->type, sel->target,\n\t\tsel->r.width, sel->r.height, sel->r.left, sel->r.top);\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\twframe = src_q_data->pix_fmt.width;\n\t\thframe = src_q_data->pix_fmt.height;\n\n\t\tsel->r.top = clamp_t(int, sel->r.top, 0, hframe - DW100_MIN_H);\n\t\tsel->r.left = clamp_t(int, sel->r.left, 0, wframe - DW100_MIN_W);\n\t\tsel->r.height =\n\t\t\tclamp(sel->r.height, DW100_MIN_H, hframe - sel->r.top);\n\t\tsel->r.width =\n\t\t\tclamp(sel->r.width, DW100_MIN_W, wframe - sel->r.left);\n\n\t\t \n\t\tqscalex = (sel->r.width << 16) / wframe;\n\t\tqscaley = (sel->r.height << 16) / hframe;\n\t\ty = sel->r.top;\n\t\tx = sel->r.left;\n\t\tif (qscalex == qscaley) {\n\t\t\tqscale = qscalex;\n\t\t} else {\n\t\t\tswitch (sel->flags) {\n\t\t\tcase 0:\n\t\t\t\tqscale = (qscalex + qscaley) / 2;\n\t\t\t\tbreak;\n\t\t\tcase V4L2_SEL_FLAG_GE:\n\t\t\t\tqscale = max(qscaley, qscalex);\n\t\t\t\tbreak;\n\t\t\tcase V4L2_SEL_FLAG_LE:\n\t\t\t\tqscale = min(qscaley, qscalex);\n\t\t\t\tbreak;\n\t\t\tcase V4L2_SEL_FLAG_LE | V4L2_SEL_FLAG_GE:\n\t\t\t\treturn -ERANGE;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tw = (u32)((((u64)wframe << 16) * qscale) >> 32);\n\t\th = (u32)((((u64)hframe << 16) * qscale) >> 32);\n\t\tx = x + (sel->r.width  - w) / 2;\n\t\ty = y + (sel->r.height  - h) / 2;\n\t\tx = min(wframe - w, (unsigned int)max(0, x));\n\t\ty = min(hframe - h, (unsigned int)max(0, y));\n\n\t\tsel->r.top = y;\n\t\tsel->r.left = x;\n\t\tsel->r.width = w;\n\t\tsel->r.height = h;\n\n\t\tsrc_q_data->crop.top = sel->r.top;\n\t\tsrc_q_data->crop.left = sel->r.left;\n\t\tsrc_q_data->crop.width = sel->r.width;\n\t\tsrc_q_data->crop.height = sel->r.height;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&ctx->dw_dev->pdev->dev,\n\t\t\"<<< Buffer Type: %u Target: %u Rect: %ux%u@%d.%d\\n\",\n\t\tsel->type, sel->target,\n\t\tsel->r.width, sel->r.height, sel->r.left, sel->r.top);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops dw100_ioctl_ops = {\n\t.vidioc_querycap\t\t= dw100_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= dw100_enum_fmt_vid,\n\t.vidioc_enum_framesizes\t\t= dw100_enum_framesizes,\n\t.vidioc_g_fmt_vid_cap_mplane\t= dw100_g_fmt_vid,\n\t.vidioc_try_fmt_vid_cap_mplane\t= dw100_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap_mplane\t= dw100_s_fmt_vid_cap,\n\n\t.vidioc_enum_fmt_vid_out\t= dw100_enum_fmt_vid,\n\t.vidioc_g_fmt_vid_out_mplane\t= dw100_g_fmt_vid,\n\t.vidioc_try_fmt_vid_out_mplane\t= dw100_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out_mplane\t= dw100_s_fmt_vid_out,\n\n\t.vidioc_g_selection\t\t= dw100_g_selection,\n\t.vidioc_s_selection\t\t= dw100_s_selection,\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nstatic void dw100_job_finish(struct dw100_device *dw_dev, bool with_error)\n{\n\tstruct dw100_ctx *curr_ctx;\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\tenum vb2_buffer_state buf_state;\n\n\tcurr_ctx = v4l2_m2m_get_curr_priv(dw_dev->m2m_dev);\n\n\tif (!curr_ctx) {\n\t\tdev_err(&dw_dev->pdev->dev,\n\t\t\t\"Instance released before the end of transaction\\n\");\n\t\treturn;\n\t}\n\n\tsrc_vb = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\n\tdst_vb = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\n\n\tif (likely(!with_error))\n\t\tbuf_state = VB2_BUF_STATE_DONE;\n\telse\n\t\tbuf_state = VB2_BUF_STATE_ERROR;\n\n\tv4l2_m2m_buf_done(src_vb, buf_state);\n\tv4l2_m2m_buf_done(dst_vb, buf_state);\n\n\tdev_dbg(&dw_dev->pdev->dev, \"Finishing transaction with%s error(s)\\n\",\n\t\twith_error ? \"\" : \"out\");\n\n\tv4l2_m2m_job_finish(dw_dev->m2m_dev, curr_ctx->fh.m2m_ctx);\n}\n\nstatic void dw100_hw_reset(struct dw100_device *dw_dev)\n{\n\tu32 val;\n\n\tval = dw100_read(dw_dev, DW100_DEWARP_CTRL);\n\tval |= DW100_DEWARP_CTRL_ENABLE;\n\tval |= DW100_DEWARP_CTRL_SOFT_RESET;\n\tdw100_write(dw_dev, DW100_DEWARP_CTRL, val);\n\tval &= ~DW100_DEWARP_CTRL_SOFT_RESET;\n\tdw100_write(dw_dev, DW100_DEWARP_CTRL, val);\n}\n\nstatic void _dw100_hw_set_master_bus_enable(struct dw100_device *dw_dev,\n\t\t\t\t\t    unsigned int enable)\n{\n\tu32 val;\n\n\tdev_dbg(&dw_dev->pdev->dev, \"%sable master bus\\n\",\n\t\tenable ? \"En\" : \"Dis\");\n\n\tval = dw100_read(dw_dev, DW100_BUS_CTRL);\n\n\tif (enable)\n\t\tval |= DW100_BUS_CTRL_AXI_MASTER_ENABLE;\n\telse\n\t\tval &= ~DW100_BUS_CTRL_AXI_MASTER_ENABLE;\n\n\tdw100_write(dw_dev, DW100_BUS_CTRL, val);\n}\n\nstatic void dw100_hw_master_bus_enable(struct dw100_device *dw_dev)\n{\n\t_dw100_hw_set_master_bus_enable(dw_dev, 1);\n}\n\nstatic void dw100_hw_master_bus_disable(struct dw100_device *dw_dev)\n{\n\t_dw100_hw_set_master_bus_enable(dw_dev, 0);\n}\n\nstatic void dw100_hw_dewarp_start(struct dw100_device *dw_dev)\n{\n\tu32 val;\n\n\tval = dw100_read(dw_dev, DW100_DEWARP_CTRL);\n\n\tdev_dbg(&dw_dev->pdev->dev, \"Starting Hardware CTRL:0x%08x\\n\", val);\n\tdw100_write(dw_dev, DW100_DEWARP_CTRL, val | DW100_DEWARP_CTRL_START);\n\tdw100_write(dw_dev, DW100_DEWARP_CTRL, val);\n}\n\nstatic void dw100_hw_init_ctrl(struct dw100_device *dw_dev)\n{\n\tu32 val;\n\t \n\n\tval = DW100_DEWARP_CTRL_ENABLE\n\t     \n\t    | DW100_DEWARP_CTRL_PREFETCH_THRESHOLD(32);\n\n\t \n\tval |= DW100_DEWARP_CTRL_PREFETCH_MODE_CALCULATION;\n\n\tdw100_write(dw_dev, DW100_DEWARP_CTRL, val);\n}\n\nstatic void dw100_hw_set_pixel_boundary(struct dw100_device *dw_dev)\n{\n\tu32 val;\n\n\tval = DW100_BOUNDARY_PIXEL_V(128)\n\t\t| DW100_BOUNDARY_PIXEL_U(128)\n\t\t| DW100_BOUNDARY_PIXEL_Y(0);\n\n\tdw100_write(dw_dev, DW100_BOUNDARY_PIXEL, val);\n}\n\nstatic void dw100_hw_set_scale(struct dw100_device *dw_dev, u8 scale)\n{\n\tdev_dbg(&dw_dev->pdev->dev, \"Setting scale factor to %u\\n\", scale);\n\n\tdw100_write(dw_dev, DW100_SCALE_FACTOR, scale);\n}\n\nstatic void dw100_hw_set_roi(struct dw100_device *dw_dev, u32 x, u32 y)\n{\n\tu32 val;\n\n\tdev_dbg(&dw_dev->pdev->dev, \"Setting ROI region to %u.%u\\n\", x, y);\n\n\tval = DW100_ROI_START_X(x) | DW100_ROI_START_Y(y);\n\n\tdw100_write(dw_dev, DW100_ROI_START, val);\n}\n\nstatic void dw100_hw_set_src_crop(struct dw100_device *dw_dev,\n\t\t\t\t  const struct dw100_q_data *src_q_data,\n\t\t\t\t  const struct dw100_q_data *dst_q_data)\n{\n\tconst struct v4l2_rect *rect = &src_q_data->crop;\n\tu32 src_scale, qscale, left_scale, top_scale;\n\n\t \n\tsrc_scale = (rect->width << 7) / src_q_data->pix_fmt.width;\n\tdw100_hw_set_scale(dw_dev, src_scale);\n\n\tqscale = (dst_q_data->pix_fmt.width << 7)  / src_q_data->pix_fmt.width;\n\n\tleft_scale = ((rect->left << 7) * qscale) >> 14;\n\ttop_scale = ((rect->top << 7) * qscale) >> 14;\n\n\tdw100_hw_set_roi(dw_dev, left_scale, top_scale);\n}\n\nstatic void dw100_hw_set_source(struct dw100_device *dw_dev,\n\t\t\t\tconst struct dw100_q_data *q_data,\n\t\t\t\tstruct vb2_buffer *buffer)\n{\n\tu32 width, height, stride, fourcc, val;\n\tconst struct dw100_fmt *fmt = q_data->fmt;\n\tdma_addr_t addr_y = vb2_dma_contig_plane_dma_addr(buffer, 0);\n\tdma_addr_t addr_uv;\n\n\twidth =  q_data->pix_fmt.width;\n\theight = q_data->pix_fmt.height;\n\tstride = q_data->pix_fmt.plane_fmt[0].bytesperline;\n\tfourcc = q_data->fmt->fourcc;\n\n\tif (q_data->pix_fmt.num_planes == 2)\n\t\taddr_uv = vb2_dma_contig_plane_dma_addr(buffer, 1);\n\telse\n\t\taddr_uv = addr_y + (stride * height);\n\n\tdev_dbg(&dw_dev->pdev->dev,\n\t\t\"Set HW source registers for %ux%u - stride %u, pixfmt: %p4cc, dma:%pad\\n\",\n\t\twidth, height, stride, &fourcc, &addr_y);\n\n\t \n\tval = dw100_read(dw_dev, DW100_DEWARP_CTRL);\n\n\tval &= ~DW100_DEWARP_CTRL_INPUT_FORMAT_MASK;\n\tval |= DW100_DEWARP_CTRL_INPUT_FORMAT(fmt->reg_format);\n\n\tdw100_write(dw_dev, DW100_DEWARP_CTRL, val);\n\n\t \n\tval = dw100_read(dw_dev, DW100_SWAP_CONTROL);\n\n\tval &= ~DW100_SWAP_CONTROL_SRC_MASK;\n\t \n\tif (fmt->reg_swap_uv &&\n\t    fmt->reg_format == DW100_DEWARP_CTRL_FORMAT_YUV422_PACKED)\n\t\tval |= DW100_SWAP_CONTROL_SRC(DW100_SWAP_CONTROL_Y\n\t\t\t\t\t      (DW100_SWAP_CONTROL_BYTE));\n\n\tdw100_write(dw_dev, DW100_SWAP_CONTROL, val);\n\n\t \n\tdw100_write(dw_dev, DW100_SRC_IMG_SIZE,\n\t\t    DW100_IMG_SIZE_WIDTH(width) | DW100_IMG_SIZE_HEIGHT(height));\n\n\tdw100_write(dw_dev,  DW100_SRC_IMG_STRIDE, stride);\n\n\t \n\tdw100_write(dw_dev, DW100_SRC_IMG_Y_BASE, DW100_IMG_Y_BASE(addr_y));\n\tdw100_write(dw_dev, DW100_SRC_IMG_UV_BASE, DW100_IMG_UV_BASE(addr_uv));\n}\n\nstatic void dw100_hw_set_destination(struct dw100_device *dw_dev,\n\t\t\t\t     const struct dw100_q_data *q_data,\n\t\t\t\t     const struct dw100_fmt *ifmt,\n\t\t\t\t     struct vb2_buffer *buffer)\n{\n\tu32 width, height, stride, fourcc, val, size_y, size_uv;\n\tconst struct dw100_fmt *fmt = q_data->fmt;\n\tdma_addr_t addr_y, addr_uv;\n\n\twidth =  q_data->pix_fmt.width;\n\theight = q_data->pix_fmt.height;\n\tstride = q_data->pix_fmt.plane_fmt[0].bytesperline;\n\tfourcc = fmt->fourcc;\n\n\taddr_y = vb2_dma_contig_plane_dma_addr(buffer, 0);\n\tsize_y = q_data->pix_fmt.plane_fmt[0].sizeimage;\n\n\tif (q_data->pix_fmt.num_planes == 2) {\n\t\taddr_uv = vb2_dma_contig_plane_dma_addr(buffer, 1);\n\t\tsize_uv = q_data->pix_fmt.plane_fmt[1].sizeimage;\n\t} else {\n\t\taddr_uv = addr_y + ALIGN(stride * height, 16);\n\t\tsize_uv = size_y;\n\t\tif (fmt->reg_format == DW100_DEWARP_CTRL_FORMAT_YUV420_SP)\n\t\t\tsize_uv /= 2;\n\t}\n\n\tdev_dbg(&dw_dev->pdev->dev,\n\t\t\"Set HW source registers for %ux%u - stride %u, pixfmt: %p4cc, dma:%pad\\n\",\n\t\twidth, height, stride, &fourcc, &addr_y);\n\n\t \n\tval = dw100_read(dw_dev, DW100_DEWARP_CTRL);\n\n\tval &= ~DW100_DEWARP_CTRL_OUTPUT_FORMAT_MASK;\n\tval |= DW100_DEWARP_CTRL_OUTPUT_FORMAT(fmt->reg_format);\n\n\tdw100_write(dw_dev, DW100_DEWARP_CTRL, val);\n\n\t \n\tval = dw100_read(dw_dev, DW100_SWAP_CONTROL);\n\n\tval &= ~DW100_SWAP_CONTROL_DST_MASK;\n\n\t \n\tif (fmt->reg_swap_uv ^\n\t    (ifmt->reg_swap_uv && ifmt->reg_format !=\n\t     DW100_DEWARP_CTRL_FORMAT_YUV422_PACKED)) {\n\t\tif (fmt->reg_format == DW100_DEWARP_CTRL_FORMAT_YUV422_PACKED)\n\t\t\tval |= DW100_SWAP_CONTROL_DST(DW100_SWAP_CONTROL_Y\n\t\t\t\t\t\t      (DW100_SWAP_CONTROL_BYTE));\n\t\telse\n\t\t\tval |= DW100_SWAP_CONTROL_DST(DW100_SWAP_CONTROL_UV\n\t\t\t\t\t\t      (DW100_SWAP_CONTROL_BYTE));\n\t}\n\n\tdw100_write(dw_dev, DW100_SWAP_CONTROL, val);\n\n\t \n\tdw100_write(dw_dev, DW100_DST_IMG_SIZE,\n\t\t    DW100_IMG_SIZE_WIDTH(width) | DW100_IMG_SIZE_HEIGHT(height));\n\tdw100_write(dw_dev, DW100_DST_IMG_STRIDE, stride);\n\tdw100_write(dw_dev, DW100_DST_IMG_Y_BASE, DW100_IMG_Y_BASE(addr_y));\n\tdw100_write(dw_dev, DW100_DST_IMG_UV_BASE, DW100_IMG_UV_BASE(addr_uv));\n\tdw100_write(dw_dev, DW100_DST_IMG_Y_SIZE1, DW100_DST_IMG_Y_SIZE(size_y));\n\tdw100_write(dw_dev, DW100_DST_IMG_UV_SIZE1,\n\t\t    DW100_DST_IMG_UV_SIZE(size_uv));\n}\n\nstatic void dw100_hw_set_mapping(struct dw100_device *dw_dev, dma_addr_t addr,\n\t\t\t\t u32 width, u32 height)\n{\n\tdev_dbg(&dw_dev->pdev->dev,\n\t\t\"Set HW mapping registers for %ux%u addr:%pad\",\n\t\twidth, height, &addr);\n\n\tdw100_write(dw_dev, DW100_MAP_LUT_ADDR, DW100_MAP_LUT_ADDR_ADDR(addr));\n\tdw100_write(dw_dev, DW100_MAP_LUT_SIZE, DW100_MAP_LUT_SIZE_WIDTH(width)\n\t\t    | DW100_MAP_LUT_SIZE_HEIGHT(height));\n}\n\nstatic void dw100_hw_clear_irq(struct dw100_device *dw_dev, unsigned int irq)\n{\n\tdw100_write(dw_dev, DW100_INTERRUPT_STATUS,\n\t\t    DW100_INTERRUPT_STATUS_INT_CLEAR(irq));\n}\n\nstatic void dw100_hw_enable_irq(struct dw100_device *dw_dev)\n{\n\tdw100_write(dw_dev, DW100_INTERRUPT_STATUS,\n\t\t    DW100_INTERRUPT_STATUS_INT_ENABLE_MASK);\n}\n\nstatic void dw100_hw_disable_irq(struct dw100_device *dw_dev)\n{\n\tdw100_write(dw_dev, DW100_INTERRUPT_STATUS, 0);\n}\n\nstatic u32 dw_hw_get_pending_irqs(struct dw100_device *dw_dev)\n{\n\tu32 val;\n\n\tval = dw100_read(dw_dev, DW100_INTERRUPT_STATUS);\n\n\treturn DW100_INTERRUPT_STATUS_INT_STATUS(val);\n}\n\nstatic irqreturn_t dw100_irq_handler(int irq, void *dev_id)\n{\n\tstruct dw100_device *dw_dev = dev_id;\n\tu32 pending_irqs, err_irqs, frame_done_irq;\n\tbool with_error = true;\n\n\tpending_irqs = dw_hw_get_pending_irqs(dw_dev);\n\tframe_done_irq = pending_irqs & DW100_INTERRUPT_STATUS_INT_FRAME_DONE;\n\terr_irqs = DW100_INTERRUPT_STATUS_INT_ERR_STATUS(pending_irqs);\n\n\tif (frame_done_irq) {\n\t\tdev_dbg(&dw_dev->pdev->dev, \"Frame done interrupt\\n\");\n\t\twith_error = false;\n\t\terr_irqs &= ~DW100_INTERRUPT_STATUS_INT_ERR_STATUS\n\t\t\t(DW100_INTERRUPT_STATUS_INT_ERR_FRAME_DONE);\n\t}\n\n\tif (err_irqs)\n\t\tdev_err(&dw_dev->pdev->dev, \"Interrupt error: %#x\\n\", err_irqs);\n\n\tdw100_hw_disable_irq(dw_dev);\n\tdw100_hw_master_bus_disable(dw_dev);\n\tdw100_hw_clear_irq(dw_dev, pending_irqs |\n\t\t\t   DW100_INTERRUPT_STATUS_INT_ERR_TIME_OUT);\n\n\tdw100_job_finish(dw_dev, with_error);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void dw100_start(struct dw100_ctx *ctx, struct vb2_v4l2_buffer *in_vb,\n\t\t\tstruct vb2_v4l2_buffer *out_vb)\n{\n\tstruct dw100_device *dw_dev = ctx->dw_dev;\n\n\tout_vb->sequence =\n\t\tdw100_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)->sequence++;\n\tin_vb->sequence =\n\t\tdw100_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)->sequence++;\n\n\tdev_dbg(&ctx->dw_dev->pdev->dev,\n\t\t\"Starting queues %p->%p, sequence %u->%u\\n\",\n\t\tv4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\tV4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE),\n\t\tv4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\tV4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE),\n\t\tin_vb->sequence, out_vb->sequence);\n\n\tv4l2_m2m_buf_copy_metadata(in_vb, out_vb, true);\n\n\t \n\tdw100_hw_master_bus_disable(dw_dev);\n\tdw100_hw_init_ctrl(dw_dev);\n\tdw100_hw_set_pixel_boundary(dw_dev);\n\tdw100_hw_set_src_crop(dw_dev, &ctx->q_data[DW100_QUEUE_SRC],\n\t\t\t      &ctx->q_data[DW100_QUEUE_DST]);\n\tdw100_hw_set_source(dw_dev, &ctx->q_data[DW100_QUEUE_SRC],\n\t\t\t    &in_vb->vb2_buf);\n\tdw100_hw_set_destination(dw_dev, &ctx->q_data[DW100_QUEUE_DST],\n\t\t\t\t ctx->q_data[DW100_QUEUE_SRC].fmt,\n\t\t\t\t &out_vb->vb2_buf);\n\tdw100_hw_set_mapping(dw_dev, ctx->map_dma,\n\t\t\t     ctx->map_width, ctx->map_height);\n\tdw100_hw_enable_irq(dw_dev);\n\tdw100_hw_dewarp_start(dw_dev);\n\n\t \n\tdw100_hw_master_bus_enable(dw_dev);\n}\n\nstatic void dw100_device_run(void *priv)\n{\n\tstruct dw100_ctx *ctx = priv;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\tdw100_start(ctx, src_buf, dst_buf);\n}\n\nstatic const struct v4l2_m2m_ops dw100_m2m_ops = {\n\t.device_run\t= dw100_device_run,\n};\n\nstatic struct video_device *dw100_init_video_device(struct dw100_device *dw_dev)\n{\n\tstruct video_device *vfd = &dw_dev->vfd;\n\n\tvfd->vfl_dir = VFL_DIR_M2M;\n\tvfd->fops = &dw100_fops;\n\tvfd->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;\n\tvfd->ioctl_ops = &dw100_ioctl_ops;\n\tvfd->minor = -1;\n\tvfd->release = video_device_release_empty;\n\tvfd->v4l2_dev = &dw_dev->v4l2_dev;\n\tvfd->lock = &dw_dev->vfd_mutex;\n\n\tstrscpy(vfd->name, DRV_NAME, sizeof(vfd->name));\n\tmutex_init(vfd->lock);\n\tvideo_set_drvdata(vfd, dw_dev);\n\n\treturn vfd;\n}\n\nstatic int dw100_dump_regs_show(struct seq_file *m, void *private)\n{\n\tstruct dw100_device *dw_dev = m->private;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(&dw_dev->pdev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dw100_dump_regs(m);\n\n\tpm_runtime_put_sync(&dw_dev->pdev->dev);\n\n\treturn ret;\n}\nDEFINE_SHOW_ATTRIBUTE(dw100_dump_regs);\n\nstatic void dw100_debugfs_init(struct dw100_device *dw_dev)\n{\n\tdw_dev->debugfs_root =\n\t\tdebugfs_create_dir(dev_name(&dw_dev->pdev->dev), NULL);\n\n\tdebugfs_create_file(\"dump_regs\", 0600, dw_dev->debugfs_root, dw_dev,\n\t\t\t    &dw100_dump_regs_fops);\n}\n\nstatic void dw100_debugfs_exit(struct dw100_device *dw_dev)\n{\n\tdebugfs_remove_recursive(dw_dev->debugfs_root);\n}\n\nstatic int dw100_probe(struct platform_device *pdev)\n{\n\tstruct dw100_device *dw_dev;\n\tstruct video_device *vfd;\n\tint ret, irq;\n\n\tdw_dev = devm_kzalloc(&pdev->dev, sizeof(*dw_dev), GFP_KERNEL);\n\tif (!dw_dev)\n\t\treturn -ENOMEM;\n\tdw_dev->pdev = pdev;\n\n\tret = devm_clk_bulk_get_all(&pdev->dev, &dw_dev->clks);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Unable to get clocks: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdw_dev->num_clks = ret;\n\n\tdw_dev->mmio = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(dw_dev->mmio))\n\t\treturn PTR_ERR(dw_dev->mmio);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tplatform_set_drvdata(pdev, dw_dev);\n\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Unable to resume the device: %d\\n\", ret);\n\t\tgoto err_pm;\n\t}\n\n\tpm_runtime_put_sync(&pdev->dev);\n\n\tret = devm_request_irq(&pdev->dev, irq, dw100_irq_handler, IRQF_ONESHOT,\n\t\t\t       dev_name(&pdev->dev), dw_dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq: %d\\n\", ret);\n\t\tgoto err_pm;\n\t}\n\n\tret = v4l2_device_register(&pdev->dev, &dw_dev->v4l2_dev);\n\tif (ret)\n\t\tgoto err_pm;\n\n\tvfd = dw100_init_video_device(dw_dev);\n\n\tdw_dev->m2m_dev = v4l2_m2m_init(&dw100_m2m_ops);\n\tif (IS_ERR(dw_dev->m2m_dev)) {\n\t\tdev_err(&pdev->dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(dw_dev->m2m_dev);\n\t\tgoto err_v4l2;\n\t}\n\n\tdw_dev->mdev.dev = &pdev->dev;\n\tstrscpy(dw_dev->mdev.model, \"dw100\", sizeof(dw_dev->mdev.model));\n\tmedia_device_init(&dw_dev->mdev);\n\tdw_dev->v4l2_dev.mdev = &dw_dev->mdev;\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register video device\\n\");\n\t\tgoto err_m2m;\n\t}\n\n\tret = v4l2_m2m_register_media_controller(dw_dev->m2m_dev, vfd,\n\t\t\t\t\t\t MEDIA_ENT_F_PROC_VIDEO_SCALER);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to init mem2mem media controller\\n\");\n\t\tgoto error_v4l2;\n\t}\n\n\tret = media_device_register(&dw_dev->mdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register mem2mem media device\\n\");\n\t\tgoto error_m2m_mc;\n\t}\n\n\tdw100_debugfs_init(dw_dev);\n\n\tdev_info(&pdev->dev,\n\t\t \"dw100 v4l2 m2m registered as /dev/video%u\\n\", vfd->num);\n\n\treturn 0;\n\nerror_m2m_mc:\n\tv4l2_m2m_unregister_media_controller(dw_dev->m2m_dev);\nerror_v4l2:\n\tvideo_unregister_device(vfd);\nerr_m2m:\n\tmedia_device_cleanup(&dw_dev->mdev);\n\tv4l2_m2m_release(dw_dev->m2m_dev);\nerr_v4l2:\n\tv4l2_device_unregister(&dw_dev->v4l2_dev);\nerr_pm:\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void dw100_remove(struct platform_device *pdev)\n{\n\tstruct dw100_device *dw_dev = platform_get_drvdata(pdev);\n\n\tdw100_debugfs_exit(dw_dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tmedia_device_unregister(&dw_dev->mdev);\n\tv4l2_m2m_unregister_media_controller(dw_dev->m2m_dev);\n\tmedia_device_cleanup(&dw_dev->mdev);\n\n\tvideo_unregister_device(&dw_dev->vfd);\n\tmutex_destroy(dw_dev->vfd.lock);\n\tv4l2_m2m_release(dw_dev->m2m_dev);\n\tv4l2_device_unregister(&dw_dev->v4l2_dev);\n}\n\nstatic int __maybe_unused dw100_runtime_suspend(struct device *dev)\n{\n\tstruct dw100_device *dw_dev = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(dw_dev->num_clks, dw_dev->clks);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dw100_runtime_resume(struct device *dev)\n{\n\tint ret;\n\tstruct dw100_device *dw_dev = dev_get_drvdata(dev);\n\n\tret = clk_bulk_prepare_enable(dw_dev->num_clks, dw_dev->clks);\n\n\tif (ret)\n\t\treturn ret;\n\n\tdw100_hw_reset(dw_dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dw100_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(dw100_runtime_suspend,\n\t\t\t   dw100_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id dw100_dt_ids[] = {\n\t{ .compatible = \"nxp,imx8mp-dw100\", .data = NULL },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, dw100_dt_ids);\n\nstatic struct platform_driver dw100_driver = {\n\t.probe\t\t= dw100_probe,\n\t.remove_new\t= dw100_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.pm = &dw100_pm,\n\t\t.of_match_table = dw100_dt_ids,\n\t},\n};\n\nmodule_platform_driver(dw100_driver);\n\nMODULE_DESCRIPTION(\"DW100 Hardware dewarper\");\nMODULE_AUTHOR(\"Xavier Roumegue <Xavier.Roumegue@oss.nxp.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}