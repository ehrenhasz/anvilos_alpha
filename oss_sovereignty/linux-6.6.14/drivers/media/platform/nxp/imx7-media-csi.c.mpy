{
  "module_name": "imx7-media-csi.c",
  "hash_id": "f942f878947ecfcfbe455ac3f74bb03b2d95969afc31f9df4b1443e7be5bd3b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/imx7-media-csi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/math.h>\n#include <linux/mfd/syscon.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-dma-contig.h>\n\n#define IMX7_CSI_PAD_SINK\t\t0\n#define IMX7_CSI_PAD_SRC\t\t1\n#define IMX7_CSI_PADS_NUM\t\t2\n\n \n#define BIT_SWAP16_EN\t\t\tBIT(31)\n#define BIT_EXT_VSYNC\t\t\tBIT(30)\n#define BIT_EOF_INT_EN\t\t\tBIT(29)\n#define BIT_PRP_IF_EN\t\t\tBIT(28)\n#define BIT_CCIR_MODE\t\t\tBIT(27)\n#define BIT_COF_INT_EN\t\t\tBIT(26)\n#define BIT_SF_OR_INTEN\t\t\tBIT(25)\n#define BIT_RF_OR_INTEN\t\t\tBIT(24)\n#define BIT_SFF_DMA_DONE_INTEN\t\tBIT(22)\n#define BIT_STATFF_INTEN\t\tBIT(21)\n#define BIT_FB2_DMA_DONE_INTEN\t\tBIT(20)\n#define BIT_FB1_DMA_DONE_INTEN\t\tBIT(19)\n#define BIT_RXFF_INTEN\t\t\tBIT(18)\n#define BIT_SOF_POL\t\t\tBIT(17)\n#define BIT_SOF_INTEN\t\t\tBIT(16)\n#define BIT_MCLKDIV(n)\t\t\t((n) << 12)\n#define BIT_MCLKDIV_MASK\t\t(0xf << 12)\n#define BIT_HSYNC_POL\t\t\tBIT(11)\n#define BIT_CCIR_EN\t\t\tBIT(10)\n#define BIT_MCLKEN\t\t\tBIT(9)\n#define BIT_FCC\t\t\t\tBIT(8)\n#define BIT_PACK_DIR\t\t\tBIT(7)\n#define BIT_CLR_STATFIFO\t\tBIT(6)\n#define BIT_CLR_RXFIFO\t\t\tBIT(5)\n#define BIT_GCLK_MODE\t\t\tBIT(4)\n#define BIT_INV_DATA\t\t\tBIT(3)\n#define BIT_INV_PCLK\t\t\tBIT(2)\n#define BIT_REDGE\t\t\tBIT(1)\n#define BIT_PIXEL_BIT\t\t\tBIT(0)\n\n \n#define BIT_DMA_BURST_TYPE_RFF_INCR4\t(1 << 30)\n#define BIT_DMA_BURST_TYPE_RFF_INCR8\t(2 << 30)\n#define BIT_DMA_BURST_TYPE_RFF_INCR16\t(3 << 30)\n#define BIT_DMA_BURST_TYPE_RFF_MASK\t(3 << 30)\n\n \n#define BIT_FRMCNT(n)\t\t\t((n) << 16)\n#define BIT_FRMCNT_MASK\t\t\t(0xffff << 16)\n#define BIT_FRMCNT_RST\t\t\tBIT(15)\n#define BIT_DMA_REFLASH_RFF\t\tBIT(14)\n#define BIT_DMA_REFLASH_SFF\t\tBIT(13)\n#define BIT_DMA_REQ_EN_RFF\t\tBIT(12)\n#define BIT_DMA_REQ_EN_SFF\t\tBIT(11)\n#define BIT_STATFF_LEVEL(n)\t\t((n) << 8)\n#define BIT_STATFF_LEVEL_MASK\t\t(0x7 << 8)\n#define BIT_HRESP_ERR_EN\t\tBIT(7)\n#define BIT_RXFF_LEVEL(n)\t\t((n) << 4)\n#define BIT_RXFF_LEVEL_MASK\t\t(0x7 << 4)\n#define BIT_TWO_8BIT_SENSOR\t\tBIT(3)\n#define BIT_ZERO_PACK_EN\t\tBIT(2)\n#define BIT_ECC_INT_EN\t\t\tBIT(1)\n#define BIT_ECC_AUTO_EN\t\t\tBIT(0)\n\n \n#define BIT_ADDR_CH_ERR_INT\t\tBIT(28)\n#define BIT_FIELD0_INT\t\t\tBIT(27)\n#define BIT_FIELD1_INT\t\t\tBIT(26)\n#define BIT_SFF_OR_INT\t\t\tBIT(25)\n#define BIT_RFF_OR_INT\t\t\tBIT(24)\n#define BIT_DMA_TSF_DONE_SFF\t\tBIT(22)\n#define BIT_STATFF_INT\t\t\tBIT(21)\n#define BIT_DMA_TSF_DONE_FB2\t\tBIT(20)\n#define BIT_DMA_TSF_DONE_FB1\t\tBIT(19)\n#define BIT_RXFF_INT\t\t\tBIT(18)\n#define BIT_EOF_INT\t\t\tBIT(17)\n#define BIT_SOF_INT\t\t\tBIT(16)\n#define BIT_F2_INT\t\t\tBIT(15)\n#define BIT_F1_INT\t\t\tBIT(14)\n#define BIT_COF_INT\t\t\tBIT(13)\n#define BIT_HRESP_ERR_INT\t\tBIT(7)\n#define BIT_ECC_INT\t\t\tBIT(1)\n#define BIT_DRDY\t\t\tBIT(0)\n\n \n#define BIT_IMAGE_WIDTH(n)\t\t((n) << 16)\n#define BIT_IMAGE_HEIGHT(n)\t\t(n)\n\n \n#define BIT_CSI_HW_ENABLE\t\tBIT(31)\n#define BIT_MIPI_DATA_FORMAT_RAW8\t(0x2a << 25)\n#define BIT_MIPI_DATA_FORMAT_RAW10\t(0x2b << 25)\n#define BIT_MIPI_DATA_FORMAT_RAW12\t(0x2c << 25)\n#define BIT_MIPI_DATA_FORMAT_RAW14\t(0x2d << 25)\n#define BIT_MIPI_DATA_FORMAT_YUV422_8B\t(0x1e << 25)\n#define BIT_MIPI_DATA_FORMAT_MASK\t(0x3f << 25)\n#define BIT_DATA_FROM_MIPI\t\tBIT(22)\n#define BIT_MIPI_YU_SWAP\t\tBIT(21)\n#define BIT_MIPI_DOUBLE_CMPNT\t\tBIT(20)\n#define BIT_MASK_OPTION_FIRST_FRAME\t(0 << 18)\n#define BIT_MASK_OPTION_CSI_EN\t\t(1 << 18)\n#define BIT_MASK_OPTION_SECOND_FRAME\t(2 << 18)\n#define BIT_MASK_OPTION_ON_DATA\t\t(3 << 18)\n#define BIT_BASEADDR_CHG_ERR_EN\t\tBIT(9)\n#define BIT_BASEADDR_SWITCH_SEL\t\tBIT(5)\n#define BIT_BASEADDR_SWITCH_EN\t\tBIT(4)\n#define BIT_PARALLEL24_EN\t\tBIT(3)\n#define BIT_DEINTERLACE_EN\t\tBIT(2)\n#define BIT_TVDECODER_IN_EN\t\tBIT(1)\n#define BIT_NTSC_EN\t\t\tBIT(0)\n\n#define CSI_MCLK_VF\t\t\t1\n#define CSI_MCLK_ENC\t\t\t2\n#define CSI_MCLK_RAW\t\t\t4\n#define CSI_MCLK_I2C\t\t\t8\n\n#define CSI_CSICR1\t\t\t0x00\n#define CSI_CSICR2\t\t\t0x04\n#define CSI_CSICR3\t\t\t0x08\n#define CSI_STATFIFO\t\t\t0x0c\n#define CSI_CSIRXFIFO\t\t\t0x10\n#define CSI_CSIRXCNT\t\t\t0x14\n#define CSI_CSISR\t\t\t0x18\n\n#define CSI_CSIDBG\t\t\t0x1c\n#define CSI_CSIDMASA_STATFIFO\t\t0x20\n#define CSI_CSIDMATS_STATFIFO\t\t0x24\n#define CSI_CSIDMASA_FB1\t\t0x28\n#define CSI_CSIDMASA_FB2\t\t0x2c\n#define CSI_CSIFBUF_PARA\t\t0x30\n#define CSI_CSIIMAG_PARA\t\t0x34\n\n#define CSI_CSICR18\t\t\t0x48\n#define CSI_CSICR19\t\t\t0x4c\n\n#define IMX7_CSI_VIDEO_NAME\t\t\"imx-capture\"\n \n#define IMX7_CSI_VIDEO_MEM_LIMIT\tSZ_512M\n#define IMX7_CSI_VIDEO_EOF_TIMEOUT\t2000\n\n#define IMX7_CSI_DEF_MBUS_CODE\t\tMEDIA_BUS_FMT_UYVY8_2X8\n#define IMX7_CSI_DEF_PIX_FORMAT\t\tV4L2_PIX_FMT_UYVY\n#define IMX7_CSI_DEF_PIX_WIDTH\t\t640\n#define IMX7_CSI_DEF_PIX_HEIGHT\t\t480\n\nenum imx_csi_model {\n\tIMX7_CSI_IMX7 = 0,\n\tIMX7_CSI_IMX8MQ,\n};\n\nstruct imx7_csi_pixfmt {\n\t \n\tu32     fourcc;\n\t \n\tconst u32 *codes;\n\tint     bpp;      \n\tbool\tyuv;\n};\n\nstruct imx7_csi_vb2_buffer {\n\tstruct vb2_v4l2_buffer vbuf;\n\tstruct list_head list;\n};\n\nstatic inline struct imx7_csi_vb2_buffer *\nto_imx7_csi_vb2_buffer(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\treturn container_of(vbuf, struct imx7_csi_vb2_buffer, vbuf);\n}\n\nstruct imx7_csi_dma_buf {\n\tvoid *virt;\n\tdma_addr_t dma_addr;\n\tunsigned long len;\n};\n\nstruct imx7_csi {\n\tstruct device *dev;\n\n\t \n\tvoid __iomem *regbase;\n\tint irq;\n\tstruct clk *mclk;\n\n\tspinlock_t irqlock;  \n\n\t \n\tstruct media_device mdev;\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_async_notifier notifier;\n\tstruct media_pipeline pipe;\n\n\tstruct v4l2_subdev *src_sd;\n\tbool is_csi2;\n\n\t \n\tstruct v4l2_subdev sd;\n\tstruct media_pad pad[IMX7_CSI_PADS_NUM];\n\n\t \n\tstruct video_device *vdev;\t\t \n\tstruct media_pad vdev_pad;\t\t \n\n\tstruct v4l2_pix_format vdev_fmt;\t \n\tconst struct imx7_csi_pixfmt *vdev_cc;\n\tstruct v4l2_rect vdev_compose;\t\t \n\n\tstruct mutex vdev_mutex;\t\t \n\n\tstruct vb2_queue q;\t\t\t \n\tstruct list_head ready_q;\t\t \n\tspinlock_t q_lock;\t\t\t \n\n\t \n\tstruct imx7_csi_vb2_buffer *active_vb2_buf[2];\n\tstruct imx7_csi_dma_buf underrun_buf;\n\n\tbool is_streaming;\n\tint buf_num;\n\tu32 frame_sequence;\n\n\tbool last_eof;\n\tstruct completion last_eof_completion;\n\n\tenum imx_csi_model model;\n};\n\nstatic struct imx7_csi *\nimx7_csi_notifier_to_dev(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct imx7_csi, notifier);\n}\n\n \n\nstatic u32 imx7_csi_reg_read(struct imx7_csi *csi, unsigned int offset)\n{\n\treturn readl(csi->regbase + offset);\n}\n\nstatic void imx7_csi_reg_write(struct imx7_csi *csi, unsigned int value,\n\t\t\t       unsigned int offset)\n{\n\twritel(value, csi->regbase + offset);\n}\n\nstatic u32 imx7_csi_irq_clear(struct imx7_csi *csi)\n{\n\tu32 isr;\n\n\tisr = imx7_csi_reg_read(csi, CSI_CSISR);\n\timx7_csi_reg_write(csi, isr, CSI_CSISR);\n\n\treturn isr;\n}\n\nstatic void imx7_csi_init_default(struct imx7_csi *csi)\n{\n\timx7_csi_reg_write(csi, BIT_SOF_POL | BIT_REDGE | BIT_GCLK_MODE |\n\t\t\t   BIT_HSYNC_POL | BIT_FCC | BIT_MCLKDIV(1) |\n\t\t\t   BIT_MCLKEN, CSI_CSICR1);\n\timx7_csi_reg_write(csi, 0, CSI_CSICR2);\n\timx7_csi_reg_write(csi, BIT_FRMCNT_RST, CSI_CSICR3);\n\n\timx7_csi_reg_write(csi, BIT_IMAGE_WIDTH(IMX7_CSI_DEF_PIX_WIDTH) |\n\t\t\t   BIT_IMAGE_HEIGHT(IMX7_CSI_DEF_PIX_HEIGHT),\n\t\t\t   CSI_CSIIMAG_PARA);\n\n\timx7_csi_reg_write(csi, BIT_DMA_REFLASH_RFF, CSI_CSICR3);\n}\n\nstatic void imx7_csi_hw_enable_irq(struct imx7_csi *csi)\n{\n\tu32 cr1 = imx7_csi_reg_read(csi, CSI_CSICR1);\n\n\tcr1 |= BIT_RFF_OR_INT;\n\tcr1 |= BIT_FB1_DMA_DONE_INTEN;\n\tcr1 |= BIT_FB2_DMA_DONE_INTEN;\n\n\timx7_csi_reg_write(csi, cr1, CSI_CSICR1);\n}\n\nstatic void imx7_csi_hw_disable_irq(struct imx7_csi *csi)\n{\n\tu32 cr1 = imx7_csi_reg_read(csi, CSI_CSICR1);\n\n\tcr1 &= ~BIT_RFF_OR_INT;\n\tcr1 &= ~BIT_FB1_DMA_DONE_INTEN;\n\tcr1 &= ~BIT_FB2_DMA_DONE_INTEN;\n\n\timx7_csi_reg_write(csi, cr1, CSI_CSICR1);\n}\n\nstatic void imx7_csi_hw_enable(struct imx7_csi *csi)\n{\n\tu32 cr = imx7_csi_reg_read(csi, CSI_CSICR18);\n\n\tcr |= BIT_CSI_HW_ENABLE;\n\n\timx7_csi_reg_write(csi, cr, CSI_CSICR18);\n}\n\nstatic void imx7_csi_hw_disable(struct imx7_csi *csi)\n{\n\tu32 cr = imx7_csi_reg_read(csi, CSI_CSICR18);\n\n\tcr &= ~BIT_CSI_HW_ENABLE;\n\n\timx7_csi_reg_write(csi, cr, CSI_CSICR18);\n}\n\nstatic void imx7_csi_dma_reflash(struct imx7_csi *csi)\n{\n\tu32 cr3;\n\n\tcr3 = imx7_csi_reg_read(csi, CSI_CSICR3);\n\tcr3 |= BIT_DMA_REFLASH_RFF;\n\timx7_csi_reg_write(csi, cr3, CSI_CSICR3);\n}\n\nstatic void imx7_csi_rx_fifo_clear(struct imx7_csi *csi)\n{\n\tu32 cr1 = imx7_csi_reg_read(csi, CSI_CSICR1) & ~BIT_FCC;\n\n\timx7_csi_reg_write(csi, cr1, CSI_CSICR1);\n\timx7_csi_reg_write(csi, cr1 | BIT_CLR_RXFIFO, CSI_CSICR1);\n\timx7_csi_reg_write(csi, cr1 | BIT_FCC, CSI_CSICR1);\n}\n\nstatic void imx7_csi_dmareq_rff_enable(struct imx7_csi *csi)\n{\n\tu32 cr3 = imx7_csi_reg_read(csi, CSI_CSICR3);\n\n\tcr3 |= BIT_DMA_REQ_EN_RFF;\n\tcr3 |= BIT_HRESP_ERR_EN;\n\tcr3 &= ~BIT_RXFF_LEVEL_MASK;\n\tcr3 |= BIT_RXFF_LEVEL(2);\n\n\timx7_csi_reg_write(csi, cr3, CSI_CSICR3);\n}\n\nstatic void imx7_csi_dmareq_rff_disable(struct imx7_csi *csi)\n{\n\tu32 cr3 = imx7_csi_reg_read(csi, CSI_CSICR3);\n\n\tcr3 &= ~BIT_DMA_REQ_EN_RFF;\n\tcr3 &= ~BIT_HRESP_ERR_EN;\n\timx7_csi_reg_write(csi, cr3, CSI_CSICR3);\n}\n\nstatic void imx7_csi_update_buf(struct imx7_csi *csi, dma_addr_t dma_addr,\n\t\t\t\tint buf_num)\n{\n\tif (buf_num == 1)\n\t\timx7_csi_reg_write(csi, dma_addr, CSI_CSIDMASA_FB2);\n\telse\n\t\timx7_csi_reg_write(csi, dma_addr, CSI_CSIDMASA_FB1);\n}\n\nstatic struct imx7_csi_vb2_buffer *imx7_csi_video_next_buf(struct imx7_csi *csi);\n\nstatic void imx7_csi_setup_vb2_buf(struct imx7_csi *csi)\n{\n\tstruct imx7_csi_vb2_buffer *buf;\n\tstruct vb2_buffer *vb2_buf;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tdma_addr_t dma_addr;\n\n\t\tbuf = imx7_csi_video_next_buf(csi);\n\t\tif (buf) {\n\t\t\tcsi->active_vb2_buf[i] = buf;\n\t\t\tvb2_buf = &buf->vbuf.vb2_buf;\n\t\t\tdma_addr = vb2_dma_contig_plane_dma_addr(vb2_buf, 0);\n\t\t} else {\n\t\t\tcsi->active_vb2_buf[i] = NULL;\n\t\t\tdma_addr = csi->underrun_buf.dma_addr;\n\t\t}\n\n\t\timx7_csi_update_buf(csi, dma_addr, i);\n\t}\n}\n\nstatic void imx7_csi_dma_unsetup_vb2_buf(struct imx7_csi *csi,\n\t\t\t\t\t enum vb2_buffer_state return_status)\n{\n\tstruct imx7_csi_vb2_buffer *buf;\n\tint i;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tbuf = csi->active_vb2_buf[i];\n\t\tif (buf) {\n\t\t\tstruct vb2_buffer *vb = &buf->vbuf.vb2_buf;\n\n\t\t\tvb->timestamp = ktime_get_ns();\n\t\t\tvb2_buffer_done(vb, return_status);\n\t\t\tcsi->active_vb2_buf[i] = NULL;\n\t\t}\n\t}\n}\n\nstatic void imx7_csi_free_dma_buf(struct imx7_csi *csi,\n\t\t\t\t  struct imx7_csi_dma_buf *buf)\n{\n\tif (buf->virt)\n\t\tdma_free_coherent(csi->dev, buf->len, buf->virt, buf->dma_addr);\n\n\tbuf->virt = NULL;\n\tbuf->dma_addr = 0;\n}\n\nstatic int imx7_csi_alloc_dma_buf(struct imx7_csi *csi,\n\t\t\t\t  struct imx7_csi_dma_buf *buf, int size)\n{\n\timx7_csi_free_dma_buf(csi, buf);\n\n\tbuf->len = PAGE_ALIGN(size);\n\tbuf->virt = dma_alloc_coherent(csi->dev, buf->len, &buf->dma_addr,\n\t\t\t\t       GFP_DMA | GFP_KERNEL);\n\tif (!buf->virt)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int imx7_csi_dma_setup(struct imx7_csi *csi)\n{\n\tint ret;\n\n\tret = imx7_csi_alloc_dma_buf(csi, &csi->underrun_buf,\n\t\t\t\t     csi->vdev_fmt.sizeimage);\n\tif (ret < 0) {\n\t\tv4l2_warn(&csi->sd, \"consider increasing the CMA area\\n\");\n\t\treturn ret;\n\t}\n\n\tcsi->frame_sequence = 0;\n\tcsi->last_eof = false;\n\tinit_completion(&csi->last_eof_completion);\n\n\timx7_csi_setup_vb2_buf(csi);\n\n\treturn 0;\n}\n\nstatic void imx7_csi_dma_cleanup(struct imx7_csi *csi,\n\t\t\t\t enum vb2_buffer_state return_status)\n{\n\timx7_csi_dma_unsetup_vb2_buf(csi, return_status);\n\timx7_csi_free_dma_buf(csi, &csi->underrun_buf);\n}\n\nstatic void imx7_csi_dma_stop(struct imx7_csi *csi)\n{\n\tunsigned long timeout_jiffies;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tspin_lock_irqsave(&csi->irqlock, flags);\n\tcsi->last_eof = true;\n\tspin_unlock_irqrestore(&csi->irqlock, flags);\n\n\t \n\ttimeout_jiffies = msecs_to_jiffies(IMX7_CSI_VIDEO_EOF_TIMEOUT);\n\tret = wait_for_completion_timeout(&csi->last_eof_completion,\n\t\t\t\t\t  timeout_jiffies);\n\tif (ret == 0)\n\t\tv4l2_warn(&csi->sd, \"wait last EOF timeout\\n\");\n\n\timx7_csi_hw_disable_irq(csi);\n}\n\nstatic void imx7_csi_configure(struct imx7_csi *csi,\n\t\t\t       struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_pix_format *out_pix = &csi->vdev_fmt;\n\tint width = out_pix->width;\n\tu32 stride = 0;\n\tu32 cr3 = BIT_FRMCNT_RST;\n\tu32 cr1, cr18;\n\n\tcr18 = imx7_csi_reg_read(csi, CSI_CSICR18);\n\n\tcr18 &= ~(BIT_CSI_HW_ENABLE | BIT_MIPI_DATA_FORMAT_MASK |\n\t\t  BIT_DATA_FROM_MIPI | BIT_MIPI_DOUBLE_CMPNT |\n\t\t  BIT_BASEADDR_CHG_ERR_EN | BIT_BASEADDR_SWITCH_SEL |\n\t\t  BIT_BASEADDR_SWITCH_EN | BIT_DEINTERLACE_EN);\n\n\tif (out_pix->field == V4L2_FIELD_INTERLACED) {\n\t\tcr18 |= BIT_DEINTERLACE_EN;\n\t\tstride = out_pix->width;\n\t}\n\n\tif (!csi->is_csi2) {\n\t\tcr1 = BIT_SOF_POL | BIT_REDGE | BIT_GCLK_MODE | BIT_HSYNC_POL\n\t\t    | BIT_FCC | BIT_MCLKDIV(1) | BIT_MCLKEN;\n\n\t\tcr18 |= BIT_BASEADDR_SWITCH_EN | BIT_BASEADDR_SWITCH_SEL |\n\t\t\tBIT_BASEADDR_CHG_ERR_EN;\n\n\t\tif (out_pix->pixelformat == V4L2_PIX_FMT_UYVY ||\n\t\t    out_pix->pixelformat == V4L2_PIX_FMT_YUYV)\n\t\t\twidth *= 2;\n\t} else {\n\t\tconst struct v4l2_mbus_framefmt *sink_fmt;\n\n\t\tsink_fmt = v4l2_subdev_get_pad_format(&csi->sd, sd_state,\n\t\t\t\t\t\t      IMX7_CSI_PAD_SINK);\n\n\t\tcr1 = BIT_SOF_POL | BIT_REDGE | BIT_HSYNC_POL | BIT_FCC\n\t\t    | BIT_MCLKDIV(1) | BIT_MCLKEN;\n\n\t\tcr18 |= BIT_DATA_FROM_MIPI;\n\n\t\tswitch (sink_fmt->code) {\n\t\tcase MEDIA_BUS_FMT_Y8_1X8:\n\t\tcase MEDIA_BUS_FMT_SBGGR8_1X8:\n\t\tcase MEDIA_BUS_FMT_SGBRG8_1X8:\n\t\tcase MEDIA_BUS_FMT_SGRBG8_1X8:\n\t\tcase MEDIA_BUS_FMT_SRGGB8_1X8:\n\t\t\tcr18 |= BIT_MIPI_DATA_FORMAT_RAW8;\n\t\t\tbreak;\n\t\tcase MEDIA_BUS_FMT_Y10_1X10:\n\t\tcase MEDIA_BUS_FMT_SBGGR10_1X10:\n\t\tcase MEDIA_BUS_FMT_SGBRG10_1X10:\n\t\tcase MEDIA_BUS_FMT_SGRBG10_1X10:\n\t\tcase MEDIA_BUS_FMT_SRGGB10_1X10:\n\t\t\tcr3 |= BIT_TWO_8BIT_SENSOR;\n\t\t\tcr18 |= BIT_MIPI_DATA_FORMAT_RAW10;\n\t\t\tbreak;\n\t\tcase MEDIA_BUS_FMT_Y12_1X12:\n\t\tcase MEDIA_BUS_FMT_SBGGR12_1X12:\n\t\tcase MEDIA_BUS_FMT_SGBRG12_1X12:\n\t\tcase MEDIA_BUS_FMT_SGRBG12_1X12:\n\t\tcase MEDIA_BUS_FMT_SRGGB12_1X12:\n\t\t\tcr3 |= BIT_TWO_8BIT_SENSOR;\n\t\t\tcr18 |= BIT_MIPI_DATA_FORMAT_RAW12;\n\t\t\tbreak;\n\t\tcase MEDIA_BUS_FMT_Y14_1X14:\n\t\tcase MEDIA_BUS_FMT_SBGGR14_1X14:\n\t\tcase MEDIA_BUS_FMT_SGBRG14_1X14:\n\t\tcase MEDIA_BUS_FMT_SGRBG14_1X14:\n\t\tcase MEDIA_BUS_FMT_SRGGB14_1X14:\n\t\t\tcr3 |= BIT_TWO_8BIT_SENSOR;\n\t\t\tcr18 |= BIT_MIPI_DATA_FORMAT_RAW14;\n\t\t\tbreak;\n\n\t\t \n\t\tcase MEDIA_BUS_FMT_UYVY8_2X8:\n\t\tcase MEDIA_BUS_FMT_YUYV8_2X8:\n\t\t\tcr18 |= BIT_MIPI_DATA_FORMAT_YUV422_8B;\n\t\t\tbreak;\n\t\tcase MEDIA_BUS_FMT_UYVY8_1X16:\n\t\tcase MEDIA_BUS_FMT_YUYV8_1X16:\n\t\t\tcr3 |= BIT_TWO_8BIT_SENSOR;\n\t\t\tcr18 |= BIT_MIPI_DATA_FORMAT_YUV422_8B |\n\t\t\t\tBIT_MIPI_DOUBLE_CMPNT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\timx7_csi_reg_write(csi, cr1, CSI_CSICR1);\n\timx7_csi_reg_write(csi, BIT_DMA_BURST_TYPE_RFF_INCR16, CSI_CSICR2);\n\timx7_csi_reg_write(csi, cr3, CSI_CSICR3);\n\timx7_csi_reg_write(csi, cr18, CSI_CSICR18);\n\n\timx7_csi_reg_write(csi, (width * out_pix->height) >> 2, CSI_CSIRXCNT);\n\timx7_csi_reg_write(csi, BIT_IMAGE_WIDTH(width) |\n\t\t\t   BIT_IMAGE_HEIGHT(out_pix->height),\n\t\t\t   CSI_CSIIMAG_PARA);\n\timx7_csi_reg_write(csi, stride, CSI_CSIFBUF_PARA);\n}\n\nstatic int imx7_csi_init(struct imx7_csi *csi,\n\t\t\t struct v4l2_subdev_state *sd_state)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(csi->mclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\timx7_csi_configure(csi, sd_state);\n\n\tret = imx7_csi_dma_setup(csi);\n\tif (ret < 0) {\n\t\tclk_disable_unprepare(csi->mclk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void imx7_csi_deinit(struct imx7_csi *csi,\n\t\t\t    enum vb2_buffer_state return_status)\n{\n\timx7_csi_dma_cleanup(csi, return_status);\n\timx7_csi_init_default(csi);\n\timx7_csi_dmareq_rff_disable(csi);\n\tclk_disable_unprepare(csi->mclk);\n}\n\nstatic void imx7_csi_baseaddr_switch_on_second_frame(struct imx7_csi *csi)\n{\n\tu32 cr18 = imx7_csi_reg_read(csi, CSI_CSICR18);\n\n\tcr18 |= BIT_BASEADDR_SWITCH_EN | BIT_BASEADDR_SWITCH_SEL |\n\t\tBIT_BASEADDR_CHG_ERR_EN;\n\tcr18 |= BIT_MASK_OPTION_SECOND_FRAME;\n\timx7_csi_reg_write(csi, cr18, CSI_CSICR18);\n}\n\nstatic void imx7_csi_enable(struct imx7_csi *csi)\n{\n\t \n\timx7_csi_rx_fifo_clear(csi);\n\timx7_csi_dma_reflash(csi);\n\n\tusleep_range(2000, 3000);\n\n\t \n\timx7_csi_irq_clear(csi);\n\timx7_csi_hw_enable_irq(csi);\n\n\t \n\timx7_csi_dmareq_rff_enable(csi);\n\timx7_csi_hw_enable(csi);\n\n\tif (csi->model == IMX7_CSI_IMX8MQ)\n\t\timx7_csi_baseaddr_switch_on_second_frame(csi);\n}\n\nstatic void imx7_csi_disable(struct imx7_csi *csi)\n{\n\timx7_csi_dma_stop(csi);\n\n\timx7_csi_dmareq_rff_disable(csi);\n\n\timx7_csi_hw_disable_irq(csi);\n\n\timx7_csi_hw_disable(csi);\n}\n\n \n\nstatic void imx7_csi_error_recovery(struct imx7_csi *csi)\n{\n\timx7_csi_hw_disable(csi);\n\n\timx7_csi_rx_fifo_clear(csi);\n\n\timx7_csi_dma_reflash(csi);\n\n\timx7_csi_hw_enable(csi);\n}\n\nstatic void imx7_csi_vb2_buf_done(struct imx7_csi *csi)\n{\n\tstruct imx7_csi_vb2_buffer *done, *next;\n\tstruct vb2_buffer *vb;\n\tdma_addr_t dma_addr;\n\n\tdone = csi->active_vb2_buf[csi->buf_num];\n\tif (done) {\n\t\tdone->vbuf.field = csi->vdev_fmt.field;\n\t\tdone->vbuf.sequence = csi->frame_sequence;\n\t\tvb = &done->vbuf.vb2_buf;\n\t\tvb->timestamp = ktime_get_ns();\n\t\tvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\n\t}\n\tcsi->frame_sequence++;\n\n\t \n\tnext = imx7_csi_video_next_buf(csi);\n\tif (next) {\n\t\tdma_addr = vb2_dma_contig_plane_dma_addr(&next->vbuf.vb2_buf, 0);\n\t\tcsi->active_vb2_buf[csi->buf_num] = next;\n\t} else {\n\t\tdma_addr = csi->underrun_buf.dma_addr;\n\t\tcsi->active_vb2_buf[csi->buf_num] = NULL;\n\t}\n\n\timx7_csi_update_buf(csi, dma_addr, csi->buf_num);\n}\n\nstatic irqreturn_t imx7_csi_irq_handler(int irq, void *data)\n{\n\tstruct imx7_csi *csi =  data;\n\tu32 status;\n\n\tspin_lock(&csi->irqlock);\n\n\tstatus = imx7_csi_irq_clear(csi);\n\n\tif (status & BIT_RFF_OR_INT) {\n\t\tdev_warn(csi->dev, \"Rx fifo overflow\\n\");\n\t\timx7_csi_error_recovery(csi);\n\t}\n\n\tif (status & BIT_HRESP_ERR_INT) {\n\t\tdev_warn(csi->dev, \"Hresponse error detected\\n\");\n\t\timx7_csi_error_recovery(csi);\n\t}\n\n\tif (status & BIT_ADDR_CH_ERR_INT) {\n\t\timx7_csi_hw_disable(csi);\n\n\t\timx7_csi_dma_reflash(csi);\n\n\t\timx7_csi_hw_enable(csi);\n\t}\n\n\tif ((status & BIT_DMA_TSF_DONE_FB1) &&\n\t    (status & BIT_DMA_TSF_DONE_FB2)) {\n\t\t \n\t} else if (status & BIT_DMA_TSF_DONE_FB1) {\n\t\tcsi->buf_num = 0;\n\t} else if (status & BIT_DMA_TSF_DONE_FB2) {\n\t\tcsi->buf_num = 1;\n\t}\n\n\tif ((status & BIT_DMA_TSF_DONE_FB1) ||\n\t    (status & BIT_DMA_TSF_DONE_FB2)) {\n\t\timx7_csi_vb2_buf_done(csi);\n\n\t\tif (csi->last_eof) {\n\t\t\tcomplete(&csi->last_eof_completion);\n\t\t\tcsi->last_eof = false;\n\t\t}\n\t}\n\n\tspin_unlock(&csi->irqlock);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\n#define IMX_BUS_FMTS(fmt...) (const u32[]) {fmt, 0}\n\n \nstatic const struct imx7_csi_pixfmt pixel_formats[] = {\n\t \n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_UYVY,\n\t\t.codes  = IMX_BUS_FMTS(\n\t\t\tMEDIA_BUS_FMT_UYVY8_2X8,\n\t\t\tMEDIA_BUS_FMT_UYVY8_1X16\n\t\t),\n\t\t.yuv\t= true,\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_YUYV,\n\t\t.codes  = IMX_BUS_FMTS(\n\t\t\tMEDIA_BUS_FMT_YUYV8_2X8,\n\t\t\tMEDIA_BUS_FMT_YUYV8_1X16\n\t\t),\n\t\t.yuv\t= true,\n\t\t.bpp    = 16,\n\t},\n\t \n\t{\n\t\t.fourcc = V4L2_PIX_FMT_SBGGR8,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SBGGR8_1X8),\n\t\t.bpp    = 8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGBRG8,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SGBRG8_1X8),\n\t\t.bpp    = 8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGRBG8,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SGRBG8_1X8),\n\t\t.bpp    = 8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SRGGB8,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SRGGB8_1X8),\n\t\t.bpp    = 8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SBGGR10,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SBGGR10_1X10),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGBRG10,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SGBRG10_1X10),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGRBG10,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SGRBG10_1X10),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SRGGB10,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SRGGB10_1X10),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SBGGR12,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SBGGR12_1X12),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGBRG12,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SGBRG12_1X12),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGRBG12,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SGRBG12_1X12),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SRGGB12,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SRGGB12_1X12),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SBGGR14,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SBGGR14_1X14),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGBRG14,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SGBRG14_1X14),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SGRBG14,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SGRBG14_1X14),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_SRGGB14,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_SRGGB14_1X14),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_GREY,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_Y8_1X8),\n\t\t.bpp    = 8,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_Y10,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_Y10_1X10),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_Y12,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_Y12_1X12),\n\t\t.bpp    = 16,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_Y14,\n\t\t.codes  = IMX_BUS_FMTS(MEDIA_BUS_FMT_Y14_1X14),\n\t\t.bpp    = 16,\n\t},\n};\n\n \nstatic const struct imx7_csi_pixfmt *imx7_csi_find_pixel_format(u32 fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pixel_formats); i++) {\n\t\tconst struct imx7_csi_pixfmt *fmt = &pixel_formats[i];\n\n\t\tif (fmt->fourcc == fourcc)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic const struct imx7_csi_pixfmt *imx7_csi_find_mbus_format(u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pixel_formats); i++) {\n\t\tconst struct imx7_csi_pixfmt *fmt = &pixel_formats[i];\n\t\tunsigned int j;\n\n\t\tif (!fmt->codes)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; fmt->codes[j]; j++) {\n\t\t\tif (code == fmt->codes[j])\n\t\t\t\treturn fmt;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int imx7_csi_enum_mbus_formats(u32 *code, u32 index)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pixel_formats); i++) {\n\t\tconst struct imx7_csi_pixfmt *fmt = &pixel_formats[i];\n\t\tunsigned int j;\n\n\t\tif (!fmt->codes)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; fmt->codes[j]; j++) {\n\t\t\tif (index == 0) {\n\t\t\t\t*code = fmt->codes[j];\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tindex--;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \n\nstatic int imx7_csi_video_querycap(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct imx7_csi *csi = video_drvdata(file);\n\n\tstrscpy(cap->driver, IMX7_CSI_VIDEO_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, IMX7_CSI_VIDEO_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:%s\", dev_name(csi->dev));\n\n\treturn 0;\n}\n\nstatic int imx7_csi_video_enum_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tunsigned int index = f->index;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pixel_formats); i++) {\n\t\tconst struct imx7_csi_pixfmt *fmt = &pixel_formats[i];\n\n\t\t \n\t\tif (f->mbus_code) {\n\t\t\tunsigned int j;\n\n\t\t\tif (!fmt->codes)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; fmt->codes[j]; j++) {\n\t\t\t\tif (f->mbus_code == fmt->codes[j])\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!fmt->codes[j])\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (index == 0) {\n\t\t\tf->pixelformat = fmt->fourcc;\n\t\t\treturn 0;\n\t\t}\n\n\t\tindex--;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int imx7_csi_video_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tconst struct imx7_csi_pixfmt *cc;\n\tu32 walign;\n\n\tif (fsize->index > 0)\n\t\treturn -EINVAL;\n\n\tcc = imx7_csi_find_pixel_format(fsize->pixel_format);\n\tif (!cc)\n\t\treturn -EINVAL;\n\n\t \n\twalign = 8 * 8 / cc->bpp;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\tfsize->stepwise.min_width = walign;\n\tfsize->stepwise.max_width = round_down(65535U, walign);\n\tfsize->stepwise.min_height = 1;\n\tfsize->stepwise.max_height = 65535;\n\tfsize->stepwise.step_width = walign;\n\tfsize->stepwise.step_height = 1;\n\n\treturn 0;\n}\n\nstatic int imx7_csi_video_g_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct imx7_csi *csi = video_drvdata(file);\n\n\tf->fmt.pix = csi->vdev_fmt;\n\n\treturn 0;\n}\n\nstatic const struct imx7_csi_pixfmt *\n__imx7_csi_video_try_fmt(struct v4l2_pix_format *pixfmt,\n\t\t\t struct v4l2_rect *compose)\n{\n\tconst struct imx7_csi_pixfmt *cc;\n\tu32 walign;\n\n\tif (compose) {\n\t\tcompose->width = pixfmt->width;\n\t\tcompose->height = pixfmt->height;\n\t}\n\n\t \n\tcc = imx7_csi_find_pixel_format(pixfmt->pixelformat);\n\tif (!cc) {\n\t\tpixfmt->pixelformat = IMX7_CSI_DEF_PIX_FORMAT;\n\t\tcc = imx7_csi_find_pixel_format(pixfmt->pixelformat);\n\t}\n\n\t \n\twalign = 8 * 8 / cc->bpp;\n\tpixfmt->width = clamp(round_up(pixfmt->width, walign), walign,\n\t\t\t      round_down(65535U, walign));\n\tpixfmt->height = clamp(pixfmt->height, 1U, 65535U);\n\n\tpixfmt->bytesperline = pixfmt->width * cc->bpp / 8;\n\tpixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height;\n\tpixfmt->field = V4L2_FIELD_NONE;\n\n\treturn cc;\n}\n\nstatic int imx7_csi_video_try_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t\t  struct v4l2_format *f)\n{\n\t__imx7_csi_video_try_fmt(&f->fmt.pix, NULL);\n\treturn 0;\n}\n\nstatic int imx7_csi_video_s_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct imx7_csi *csi = video_drvdata(file);\n\tconst struct imx7_csi_pixfmt *cc;\n\n\tif (vb2_is_busy(&csi->q)) {\n\t\tdev_err(csi->dev, \"%s queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tcc = __imx7_csi_video_try_fmt(&f->fmt.pix, &csi->vdev_compose);\n\n\tcsi->vdev_cc = cc;\n\tcsi->vdev_fmt = f->fmt.pix;\n\n\treturn 0;\n}\n\nstatic int imx7_csi_video_g_selection(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_selection *s)\n{\n\tstruct imx7_csi *csi = video_drvdata(file);\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\t \n\t\ts->r = csi->vdev_compose;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_PADDED:\n\t\t \n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = csi->vdev_fmt.width;\n\t\ts->r.height = csi->vdev_fmt.height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops imx7_csi_video_ioctl_ops = {\n\t.vidioc_querycap\t\t= imx7_csi_video_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= imx7_csi_video_enum_fmt_vid_cap,\n\t.vidioc_enum_framesizes\t\t= imx7_csi_video_enum_framesizes,\n\n\t.vidioc_g_fmt_vid_cap\t\t= imx7_csi_video_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= imx7_csi_video_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= imx7_csi_video_s_fmt_vid_cap,\n\n\t.vidioc_g_selection\t\t= imx7_csi_video_g_selection,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n};\n\n \n\nstatic int imx7_csi_video_queue_setup(struct vb2_queue *vq,\n\t\t\t\t      unsigned int *nbuffers,\n\t\t\t\t      unsigned int *nplanes,\n\t\t\t\t      unsigned int sizes[],\n\t\t\t\t      struct device *alloc_devs[])\n{\n\tstruct imx7_csi *csi = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format *pix = &csi->vdev_fmt;\n\tunsigned int count = *nbuffers;\n\n\tif (vq->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (*nplanes) {\n\t\tif (*nplanes != 1 || sizes[0] < pix->sizeimage)\n\t\t\treturn -EINVAL;\n\t\tcount += vq->num_buffers;\n\t}\n\n\tcount = min_t(__u32, IMX7_CSI_VIDEO_MEM_LIMIT / pix->sizeimage, count);\n\n\tif (*nplanes)\n\t\t*nbuffers = (count < vq->num_buffers) ? 0 :\n\t\t\tcount - vq->num_buffers;\n\telse\n\t\t*nbuffers = count;\n\n\t*nplanes = 1;\n\tsizes[0] = pix->sizeimage;\n\n\treturn 0;\n}\n\nstatic int imx7_csi_video_buf_init(struct vb2_buffer *vb)\n{\n\tstruct imx7_csi_vb2_buffer *buf = to_imx7_csi_vb2_buffer(vb);\n\n\tINIT_LIST_HEAD(&buf->list);\n\n\treturn 0;\n}\n\nstatic int imx7_csi_video_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct imx7_csi *csi = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct v4l2_pix_format *pix = &csi->vdev_fmt;\n\n\tif (vb2_plane_size(vb, 0) < pix->sizeimage) {\n\t\tdev_err(csi->dev,\n\t\t\t\"data will not fit into plane (%lu < %lu)\\n\",\n\t\t\tvb2_plane_size(vb, 0), (long)pix->sizeimage);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, pix->sizeimage);\n\n\treturn 0;\n}\n\nstatic bool imx7_csi_fast_track_buffer(struct imx7_csi *csi,\n\t\t\t\t       struct imx7_csi_vb2_buffer *buf)\n{\n\tunsigned long flags;\n\tdma_addr_t dma_addr;\n\tint buf_num;\n\tu32 isr;\n\n\tif (!csi->is_streaming)\n\t\treturn false;\n\n\tdma_addr = vb2_dma_contig_plane_dma_addr(&buf->vbuf.vb2_buf, 0);\n\n\t \n\n\tspin_lock_irqsave(&csi->irqlock, flags);\n\n\tbuf_num = csi->buf_num;\n\tif (csi->active_vb2_buf[buf_num]) {\n\t\tspin_unlock_irqrestore(&csi->irqlock, flags);\n\t\treturn false;\n\t}\n\n\timx7_csi_update_buf(csi, dma_addr, buf_num);\n\n\tisr = imx7_csi_reg_read(csi, CSI_CSISR);\n\tif (isr & (buf_num ? BIT_DMA_TSF_DONE_FB1 : BIT_DMA_TSF_DONE_FB2)) {\n\t\t \n\t\tspin_unlock_irqrestore(&csi->irqlock, flags);\n\t\treturn false;\n\t}\n\n\tcsi->active_vb2_buf[buf_num] = buf;\n\n\tspin_unlock_irqrestore(&csi->irqlock, flags);\n\treturn true;\n}\n\nstatic void imx7_csi_video_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct imx7_csi *csi = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct imx7_csi_vb2_buffer *buf = to_imx7_csi_vb2_buffer(vb);\n\tunsigned long flags;\n\n\tif (imx7_csi_fast_track_buffer(csi, buf))\n\t\treturn;\n\n\tspin_lock_irqsave(&csi->q_lock, flags);\n\n\tlist_add_tail(&buf->list, &csi->ready_q);\n\n\tspin_unlock_irqrestore(&csi->q_lock, flags);\n}\n\nstatic int imx7_csi_video_validate_fmt(struct imx7_csi *csi)\n{\n\tstruct v4l2_subdev_format fmt_src = {\n\t\t.pad = IMX7_CSI_PAD_SRC,\n\t\t.which = V4L2_SUBDEV_FORMAT_ACTIVE,\n\t};\n\tconst struct imx7_csi_pixfmt *cc;\n\tint ret;\n\n\t \n\tret = v4l2_subdev_call_state_active(&csi->sd, pad, get_fmt, &fmt_src);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (csi->vdev_compose.width != fmt_src.format.width ||\n\t    csi->vdev_compose.height != fmt_src.format.height)\n\t\treturn -EPIPE;\n\n\t \n\tcc = imx7_csi_find_mbus_format(fmt_src.format.code);\n\tif (!cc || csi->vdev_cc->yuv != cc->yuv)\n\t\treturn -EPIPE;\n\n\treturn 0;\n}\n\nstatic int imx7_csi_video_start_streaming(struct vb2_queue *vq,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct imx7_csi *csi = vb2_get_drv_priv(vq);\n\tstruct imx7_csi_vb2_buffer *buf, *tmp;\n\tunsigned long flags;\n\tint ret;\n\n\tret = imx7_csi_video_validate_fmt(csi);\n\tif (ret) {\n\t\tdev_err(csi->dev, \"capture format not valid\\n\");\n\t\tgoto err_buffers;\n\t}\n\n\tmutex_lock(&csi->mdev.graph_mutex);\n\n\tret = __video_device_pipeline_start(csi->vdev, &csi->pipe);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tret = v4l2_subdev_call(&csi->sd, video, s_stream, 1);\n\tif (ret)\n\t\tgoto err_stop;\n\n\tmutex_unlock(&csi->mdev.graph_mutex);\n\n\treturn 0;\n\nerr_stop:\n\t__video_device_pipeline_stop(csi->vdev);\nerr_unlock:\n\tmutex_unlock(&csi->mdev.graph_mutex);\n\tdev_err(csi->dev, \"pipeline start failed with %d\\n\", ret);\nerr_buffers:\n\tspin_lock_irqsave(&csi->q_lock, flags);\n\tlist_for_each_entry_safe(buf, tmp, &csi->ready_q, list) {\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vbuf.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t}\n\tspin_unlock_irqrestore(&csi->q_lock, flags);\n\treturn ret;\n}\n\nstatic void imx7_csi_video_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct imx7_csi *csi = vb2_get_drv_priv(vq);\n\tstruct imx7_csi_vb2_buffer *frame;\n\tstruct imx7_csi_vb2_buffer *tmp;\n\tunsigned long flags;\n\n\tmutex_lock(&csi->mdev.graph_mutex);\n\tv4l2_subdev_call(&csi->sd, video, s_stream, 0);\n\t__video_device_pipeline_stop(csi->vdev);\n\tmutex_unlock(&csi->mdev.graph_mutex);\n\n\t \n\tspin_lock_irqsave(&csi->q_lock, flags);\n\tlist_for_each_entry_safe(frame, tmp, &csi->ready_q, list) {\n\t\tlist_del(&frame->list);\n\t\tvb2_buffer_done(&frame->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&csi->q_lock, flags);\n}\n\nstatic const struct vb2_ops imx7_csi_video_qops = {\n\t.queue_setup\t = imx7_csi_video_queue_setup,\n\t.buf_init        = imx7_csi_video_buf_init,\n\t.buf_prepare\t = imx7_csi_video_buf_prepare,\n\t.buf_queue\t = imx7_csi_video_buf_queue,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n\t.start_streaming = imx7_csi_video_start_streaming,\n\t.stop_streaming  = imx7_csi_video_stop_streaming,\n};\n\n \n\nstatic int imx7_csi_video_open(struct file *file)\n{\n\tstruct imx7_csi *csi = video_drvdata(file);\n\tint ret;\n\n\tif (mutex_lock_interruptible(&csi->vdev_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tret = v4l2_fh_open(file);\n\tif (ret) {\n\t\tdev_err(csi->dev, \"v4l2_fh_open failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = v4l2_pipeline_pm_get(&csi->vdev->entity);\n\tif (ret)\n\t\tv4l2_fh_release(file);\n\nout:\n\tmutex_unlock(&csi->vdev_mutex);\n\treturn ret;\n}\n\nstatic int imx7_csi_video_release(struct file *file)\n{\n\tstruct imx7_csi *csi = video_drvdata(file);\n\tstruct vb2_queue *vq = &csi->q;\n\n\tmutex_lock(&csi->vdev_mutex);\n\n\tif (file->private_data == vq->owner) {\n\t\tvb2_queue_release(vq);\n\t\tvq->owner = NULL;\n\t}\n\n\tv4l2_pipeline_pm_put(&csi->vdev->entity);\n\n\tv4l2_fh_release(file);\n\tmutex_unlock(&csi->vdev_mutex);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations imx7_csi_video_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= imx7_csi_video_open,\n\t.release\t= imx7_csi_video_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= vb2_fop_mmap,\n};\n\n \n\nstatic struct imx7_csi_vb2_buffer *imx7_csi_video_next_buf(struct imx7_csi *csi)\n{\n\tstruct imx7_csi_vb2_buffer *buf = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&csi->q_lock, flags);\n\n\t \n\tif (!list_empty(&csi->ready_q)) {\n\t\tbuf = list_entry(csi->ready_q.next, struct imx7_csi_vb2_buffer,\n\t\t\t\t list);\n\t\tlist_del(&buf->list);\n\t}\n\n\tspin_unlock_irqrestore(&csi->q_lock, flags);\n\n\treturn buf;\n}\n\nstatic void imx7_csi_video_init_format(struct imx7_csi *csi)\n{\n\tstruct v4l2_pix_format *pixfmt = &csi->vdev_fmt;\n\n\tpixfmt->width = IMX7_CSI_DEF_PIX_WIDTH;\n\tpixfmt->height = IMX7_CSI_DEF_PIX_HEIGHT;\n\n\tcsi->vdev_cc = __imx7_csi_video_try_fmt(pixfmt, &csi->vdev_compose);\n}\n\nstatic int imx7_csi_video_register(struct imx7_csi *csi)\n{\n\tstruct v4l2_subdev *sd = &csi->sd;\n\tstruct v4l2_device *v4l2_dev = sd->v4l2_dev;\n\tstruct video_device *vdev = csi->vdev;\n\tint ret;\n\n\tvdev->v4l2_dev = v4l2_dev;\n\n\t \n\timx7_csi_video_init_format(csi);\n\n\t \n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(csi->dev, \"Failed to register video device\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(csi->dev, \"Registered %s as /dev/%s\\n\", vdev->name,\n\t\t video_device_node_name(vdev));\n\n\t \n\tret = media_create_pad_link(&sd->entity, IMX7_CSI_PAD_SRC,\n\t\t\t\t    &vdev->entity, 0, MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\tif (ret) {\n\t\tdev_err(csi->dev, \"failed to create link to device node\\n\");\n\t\tvideo_unregister_device(vdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void imx7_csi_video_unregister(struct imx7_csi *csi)\n{\n\tmedia_entity_cleanup(&csi->vdev->entity);\n\tvideo_unregister_device(csi->vdev);\n}\n\nstatic int imx7_csi_video_init(struct imx7_csi *csi)\n{\n\tstruct video_device *vdev;\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tmutex_init(&csi->vdev_mutex);\n\tINIT_LIST_HEAD(&csi->ready_q);\n\tspin_lock_init(&csi->q_lock);\n\n\t \n\tvdev = video_device_alloc();\n\tif (!vdev)\n\t\treturn -ENOMEM;\n\n\tvdev->fops = &imx7_csi_video_fops;\n\tvdev->ioctl_ops = &imx7_csi_video_ioctl_ops;\n\tvdev->minor = -1;\n\tvdev->release = video_device_release;\n\tvdev->vfl_dir = VFL_DIR_RX;\n\tvdev->tvnorms = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM;\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING\n\t\t\t | V4L2_CAP_IO_MC;\n\tvdev->lock = &csi->vdev_mutex;\n\tvdev->queue = &csi->q;\n\n\tsnprintf(vdev->name, sizeof(vdev->name), \"%s capture\", csi->sd.name);\n\n\tvideo_set_drvdata(vdev, csi);\n\tcsi->vdev = vdev;\n\n\t \n\tcsi->vdev_pad.flags = MEDIA_PAD_FL_SINK;\n\tret = media_entity_pads_init(&vdev->entity, 1, &csi->vdev_pad);\n\tif (ret) {\n\t\tvideo_device_release(vdev);\n\t\treturn ret;\n\t}\n\n\t \n\tvq = &csi->q;\n\tvq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tvq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tvq->drv_priv = csi;\n\tvq->buf_struct_size = sizeof(struct imx7_csi_vb2_buffer);\n\tvq->ops = &imx7_csi_video_qops;\n\tvq->mem_ops = &vb2_dma_contig_memops;\n\tvq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tvq->lock = &csi->vdev_mutex;\n\tvq->min_buffers_needed = 2;\n\tvq->dev = csi->dev;\n\n\tret = vb2_queue_init(vq);\n\tif (ret) {\n\t\tdev_err(csi->dev, \"vb2_queue_init failed\\n\");\n\t\tvideo_device_release(vdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int imx7_csi_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct imx7_csi *csi = v4l2_get_subdevdata(sd);\n\tstruct v4l2_subdev_state *sd_state;\n\tint ret = 0;\n\n\tsd_state = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tif (enable) {\n\t\tret = imx7_csi_init(csi, sd_state);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\n\t\tret = v4l2_subdev_call(csi->src_sd, video, s_stream, 1);\n\t\tif (ret < 0) {\n\t\t\timx7_csi_deinit(csi, VB2_BUF_STATE_QUEUED);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\timx7_csi_enable(csi);\n\t} else {\n\t\timx7_csi_disable(csi);\n\n\t\tv4l2_subdev_call(csi->src_sd, video, s_stream, 0);\n\n\t\timx7_csi_deinit(csi, VB2_BUF_STATE_ERROR);\n\t}\n\n\tcsi->is_streaming = !!enable;\n\nout_unlock:\n\tv4l2_subdev_unlock_state(sd_state);\n\n\treturn ret;\n}\n\nstatic int imx7_csi_init_cfg(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state)\n{\n\tconst struct imx7_csi_pixfmt *cc;\n\tint i;\n\n\tcc = imx7_csi_find_mbus_format(IMX7_CSI_DEF_MBUS_CODE);\n\n\tfor (i = 0; i < IMX7_CSI_PADS_NUM; i++) {\n\t\tstruct v4l2_mbus_framefmt *mf =\n\t\t\tv4l2_subdev_get_pad_format(sd, sd_state, i);\n\n\t\tmf->code = IMX7_CSI_DEF_MBUS_CODE;\n\t\tmf->width = IMX7_CSI_DEF_PIX_WIDTH;\n\t\tmf->height = IMX7_CSI_DEF_PIX_HEIGHT;\n\t\tmf->field = V4L2_FIELD_NONE;\n\n\t\tmf->colorspace = V4L2_COLORSPACE_SRGB;\n\t\tmf->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(mf->colorspace);\n\t\tmf->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(mf->colorspace);\n\t\tmf->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(!cc->yuv,\n\t\t\t\t\tmf->colorspace, mf->ycbcr_enc);\n\t}\n\n\treturn 0;\n}\n\nstatic int imx7_csi_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct v4l2_mbus_framefmt *in_fmt;\n\tint ret = 0;\n\n\tin_fmt = v4l2_subdev_get_pad_format(sd, sd_state, IMX7_CSI_PAD_SINK);\n\n\tswitch (code->pad) {\n\tcase IMX7_CSI_PAD_SINK:\n\t\tret = imx7_csi_enum_mbus_formats(&code->code, code->index);\n\t\tbreak;\n\n\tcase IMX7_CSI_PAD_SRC:\n\t\tif (code->index != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tcode->code = in_fmt->code;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void imx7_csi_try_colorimetry(struct v4l2_mbus_framefmt *tryfmt)\n{\n\tconst struct imx7_csi_pixfmt *cc;\n\tbool is_rgb = false;\n\n\tcc = imx7_csi_find_mbus_format(tryfmt->code);\n\tif (cc && !cc->yuv)\n\t\tis_rgb = true;\n\n\tswitch (tryfmt->colorspace) {\n\tcase V4L2_COLORSPACE_SMPTE170M:\n\tcase V4L2_COLORSPACE_REC709:\n\tcase V4L2_COLORSPACE_JPEG:\n\tcase V4L2_COLORSPACE_SRGB:\n\tcase V4L2_COLORSPACE_BT2020:\n\tcase V4L2_COLORSPACE_OPRGB:\n\tcase V4L2_COLORSPACE_DCI_P3:\n\tcase V4L2_COLORSPACE_RAW:\n\t\tbreak;\n\tdefault:\n\t\ttryfmt->colorspace = V4L2_COLORSPACE_SRGB;\n\t\tbreak;\n\t}\n\n\tif (tryfmt->xfer_func == V4L2_XFER_FUNC_DEFAULT)\n\t\ttryfmt->xfer_func =\n\t\t\tV4L2_MAP_XFER_FUNC_DEFAULT(tryfmt->colorspace);\n\n\tif (tryfmt->ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT)\n\t\ttryfmt->ycbcr_enc =\n\t\t\tV4L2_MAP_YCBCR_ENC_DEFAULT(tryfmt->colorspace);\n\n\tif (tryfmt->quantization == V4L2_QUANTIZATION_DEFAULT)\n\t\ttryfmt->quantization =\n\t\t\tV4L2_MAP_QUANTIZATION_DEFAULT(is_rgb,\n\t\t\t\t\t\t      tryfmt->colorspace,\n\t\t\t\t\t\t      tryfmt->ycbcr_enc);\n}\n\nstatic void imx7_csi_try_fmt(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_format *sdformat,\n\t\t\t     const struct imx7_csi_pixfmt **cc)\n{\n\tconst struct imx7_csi_pixfmt *in_cc;\n\tstruct v4l2_mbus_framefmt *in_fmt;\n\tu32 code;\n\n\tin_fmt = v4l2_subdev_get_pad_format(sd, sd_state, IMX7_CSI_PAD_SINK);\n\n\tswitch (sdformat->pad) {\n\tcase IMX7_CSI_PAD_SRC:\n\t\tin_cc = imx7_csi_find_mbus_format(in_fmt->code);\n\n\t\tsdformat->format.width = in_fmt->width;\n\t\tsdformat->format.height = in_fmt->height;\n\t\tsdformat->format.code = in_fmt->code;\n\t\tsdformat->format.field = in_fmt->field;\n\t\t*cc = in_cc;\n\n\t\tsdformat->format.colorspace = in_fmt->colorspace;\n\t\tsdformat->format.xfer_func = in_fmt->xfer_func;\n\t\tsdformat->format.quantization = in_fmt->quantization;\n\t\tsdformat->format.ycbcr_enc = in_fmt->ycbcr_enc;\n\t\tbreak;\n\n\tcase IMX7_CSI_PAD_SINK:\n\t\t*cc = imx7_csi_find_mbus_format(sdformat->format.code);\n\t\tif (!*cc) {\n\t\t\tcode = IMX7_CSI_DEF_MBUS_CODE;\n\t\t\t*cc = imx7_csi_find_mbus_format(code);\n\t\t\tsdformat->format.code = code;\n\t\t}\n\n\t\tif (sdformat->format.field != V4L2_FIELD_INTERLACED)\n\t\t\tsdformat->format.field = V4L2_FIELD_NONE;\n\t\tbreak;\n\t}\n\n\timx7_csi_try_colorimetry(&sdformat->format);\n}\n\nstatic int imx7_csi_set_fmt(struct v4l2_subdev *sd,\n\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t    struct v4l2_subdev_format *sdformat)\n{\n\tstruct imx7_csi *csi = v4l2_get_subdevdata(sd);\n\tconst struct imx7_csi_pixfmt *outcc;\n\tstruct v4l2_mbus_framefmt *outfmt;\n\tconst struct imx7_csi_pixfmt *cc;\n\tstruct v4l2_mbus_framefmt *fmt;\n\tstruct v4l2_subdev_format format;\n\n\tif (csi->is_streaming)\n\t\treturn -EBUSY;\n\n\timx7_csi_try_fmt(sd, sd_state, sdformat, &cc);\n\n\tfmt = v4l2_subdev_get_pad_format(sd, sd_state, sdformat->pad);\n\n\t*fmt = sdformat->format;\n\n\tif (sdformat->pad == IMX7_CSI_PAD_SINK) {\n\t\t \n\t\tformat.pad = IMX7_CSI_PAD_SRC;\n\t\tformat.which = sdformat->which;\n\t\tformat.format = sdformat->format;\n\t\timx7_csi_try_fmt(sd, sd_state, &format, &outcc);\n\n\t\toutfmt = v4l2_subdev_get_pad_format(sd, sd_state,\n\t\t\t\t\t\t    IMX7_CSI_PAD_SRC);\n\t\t*outfmt = format.format;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx7_csi_pad_link_validate(struct v4l2_subdev *sd,\n\t\t\t\t      struct media_link *link,\n\t\t\t\t      struct v4l2_subdev_format *source_fmt,\n\t\t\t\t      struct v4l2_subdev_format *sink_fmt)\n{\n\tstruct imx7_csi *csi = v4l2_get_subdevdata(sd);\n\tstruct media_pad *pad = NULL;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tret = v4l2_subdev_link_validate_default(sd, link, source_fmt, sink_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (csi->src_sd->entity.function) {\n\tcase MEDIA_ENT_F_VID_IF_BRIDGE:\n\t\t \n\t\tcsi->is_csi2 = true;\n\t\tbreak;\n\n\tcase MEDIA_ENT_F_VID_MUX:\n\t\t \n\t\tfor (i = 0; i < csi->src_sd->entity.num_pads; i++) {\n\t\t\tstruct media_pad *spad = &csi->src_sd->entity.pads[i];\n\n\t\t\tif (!(spad->flags & MEDIA_PAD_FL_SINK))\n\t\t\t\tcontinue;\n\n\t\t\tpad = media_pad_remote_pad_first(spad);\n\t\t\tif (pad)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!pad)\n\t\t\treturn -ENODEV;\n\n\t\tcsi->is_csi2 = pad->entity->function == MEDIA_ENT_F_VID_IF_BRIDGE;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tcsi->is_csi2 = false;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx7_csi_registered(struct v4l2_subdev *sd)\n{\n\tstruct imx7_csi *csi = v4l2_get_subdevdata(sd);\n\tint ret;\n\n\tret = imx7_csi_video_init(csi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx7_csi_video_register(csi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_device_register_subdev_nodes(&csi->v4l2_dev);\n\tif (ret)\n\t\tgoto err_unreg;\n\n\tret = media_device_register(&csi->mdev);\n\tif (ret)\n\t\tgoto err_unreg;\n\n\treturn 0;\n\nerr_unreg:\n\timx7_csi_video_unregister(csi);\n\treturn ret;\n}\n\nstatic void imx7_csi_unregistered(struct v4l2_subdev *sd)\n{\n\tstruct imx7_csi *csi = v4l2_get_subdevdata(sd);\n\n\timx7_csi_video_unregister(csi);\n}\n\nstatic const struct v4l2_subdev_video_ops imx7_csi_video_ops = {\n\t.s_stream\t= imx7_csi_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops imx7_csi_pad_ops = {\n\t.init_cfg\t= imx7_csi_init_cfg,\n\t.enum_mbus_code\t= imx7_csi_enum_mbus_code,\n\t.get_fmt\t= v4l2_subdev_get_fmt,\n\t.set_fmt\t= imx7_csi_set_fmt,\n\t.link_validate\t= imx7_csi_pad_link_validate,\n};\n\nstatic const struct v4l2_subdev_ops imx7_csi_subdev_ops = {\n\t.video\t\t= &imx7_csi_video_ops,\n\t.pad\t\t= &imx7_csi_pad_ops,\n};\n\nstatic const struct v4l2_subdev_internal_ops imx7_csi_internal_ops = {\n\t.registered\t= imx7_csi_registered,\n\t.unregistered\t= imx7_csi_unregistered,\n};\n\n \n\nstatic const struct media_entity_operations imx7_csi_entity_ops = {\n\t.link_validate\t= v4l2_subdev_link_validate,\n\t.get_fwnode_pad = v4l2_subdev_get_fwnode_pad_1_to_1,\n};\n\n \n\nstatic int imx7_csi_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_async_connection *asd)\n{\n\tstruct imx7_csi *csi = imx7_csi_notifier_to_dev(notifier);\n\tstruct media_pad *sink = &csi->sd.entity.pads[IMX7_CSI_PAD_SINK];\n\n\tcsi->src_sd = sd;\n\n\treturn v4l2_create_fwnode_links_to_pad(sd, sink, MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t       MEDIA_LNK_FL_IMMUTABLE);\n}\n\nstatic int imx7_csi_notify_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct imx7_csi *csi = imx7_csi_notifier_to_dev(notifier);\n\n\treturn v4l2_device_register_subdev_nodes(&csi->v4l2_dev);\n}\n\nstatic const struct v4l2_async_notifier_operations imx7_csi_notify_ops = {\n\t.bound = imx7_csi_notify_bound,\n\t.complete = imx7_csi_notify_complete,\n};\n\nstatic int imx7_csi_async_register(struct imx7_csi *csi)\n{\n\tstruct v4l2_async_connection *asd;\n\tstruct fwnode_handle *ep;\n\tint ret;\n\n\tv4l2_async_nf_init(&csi->notifier, &csi->v4l2_dev);\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(csi->dev), 0, 0,\n\t\t\t\t\t     FWNODE_GRAPH_ENDPOINT_NEXT);\n\tif (!ep) {\n\t\tret = dev_err_probe(csi->dev, -ENOTCONN,\n\t\t\t\t    \"Failed to get remote endpoint\\n\");\n\t\tgoto error;\n\t}\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&csi->notifier, ep,\n\t\t\t\t\t      struct v4l2_async_connection);\n\n\tfwnode_handle_put(ep);\n\n\tif (IS_ERR(asd)) {\n\t\tret = dev_err_probe(csi->dev, PTR_ERR(asd),\n\t\t\t\t    \"Failed to add remote subdev to notifier\\n\");\n\t\tgoto error;\n\t}\n\n\tcsi->notifier.ops = &imx7_csi_notify_ops;\n\n\tret = v4l2_async_nf_register(&csi->notifier);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tv4l2_async_nf_cleanup(&csi->notifier);\n\treturn ret;\n}\n\nstatic void imx7_csi_media_cleanup(struct imx7_csi *csi)\n{\n\tv4l2_device_unregister(&csi->v4l2_dev);\n\tmedia_device_unregister(&csi->mdev);\n\tv4l2_subdev_cleanup(&csi->sd);\n\tmedia_device_cleanup(&csi->mdev);\n}\n\nstatic const struct media_device_ops imx7_csi_media_ops = {\n\t.link_notify = v4l2_pipeline_link_notify,\n};\n\nstatic int imx7_csi_media_dev_init(struct imx7_csi *csi)\n{\n\tint ret;\n\n\tstrscpy(csi->mdev.model, \"imx-media\", sizeof(csi->mdev.model));\n\tcsi->mdev.ops = &imx7_csi_media_ops;\n\tcsi->mdev.dev = csi->dev;\n\n\tcsi->v4l2_dev.mdev = &csi->mdev;\n\tstrscpy(csi->v4l2_dev.name, \"imx-media\",\n\t\tsizeof(csi->v4l2_dev.name));\n\tsnprintf(csi->mdev.bus_info, sizeof(csi->mdev.bus_info),\n\t\t \"platform:%s\", dev_name(csi->mdev.dev));\n\n\tmedia_device_init(&csi->mdev);\n\n\tret = v4l2_device_register(csi->dev, &csi->v4l2_dev);\n\tif (ret < 0) {\n\t\tv4l2_err(&csi->v4l2_dev,\n\t\t\t \"Failed to register v4l2_device: %d\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tmedia_device_cleanup(&csi->mdev);\n\n\treturn ret;\n}\n\nstatic int imx7_csi_media_init(struct imx7_csi *csi)\n{\n\tunsigned int i;\n\tint ret;\n\n\t \n\tret = imx7_csi_media_dev_init(csi);\n\tif (ret)\n\t\treturn ret;\n\n\tv4l2_subdev_init(&csi->sd, &imx7_csi_subdev_ops);\n\tv4l2_set_subdevdata(&csi->sd, csi);\n\tcsi->sd.internal_ops = &imx7_csi_internal_ops;\n\tcsi->sd.entity.ops = &imx7_csi_entity_ops;\n\tcsi->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tcsi->sd.dev = csi->dev;\n\tcsi->sd.owner = THIS_MODULE;\n\tcsi->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsnprintf(csi->sd.name, sizeof(csi->sd.name), \"csi\");\n\n\tfor (i = 0; i < IMX7_CSI_PADS_NUM; i++)\n\t\tcsi->pad[i].flags = (i == IMX7_CSI_PAD_SINK) ?\n\t\t\tMEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&csi->sd.entity, IMX7_CSI_PADS_NUM,\n\t\t\t\t     csi->pad);\n\tif (ret)\n\t\tgoto error;\n\n\tret = v4l2_subdev_init_finalize(&csi->sd);\n\tif (ret)\n\t\tgoto error;\n\n\tret = v4l2_device_register_subdev(&csi->v4l2_dev, &csi->sd);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\timx7_csi_media_cleanup(csi);\n\treturn ret;\n}\n\nstatic int imx7_csi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct imx7_csi *csi;\n\tint ret;\n\n\tcsi = devm_kzalloc(&pdev->dev, sizeof(*csi), GFP_KERNEL);\n\tif (!csi)\n\t\treturn -ENOMEM;\n\n\tcsi->dev = dev;\n\tplatform_set_drvdata(pdev, csi);\n\n\tspin_lock_init(&csi->irqlock);\n\n\t \n\tcsi->mclk = devm_clk_get(&pdev->dev, \"mclk\");\n\tif (IS_ERR(csi->mclk)) {\n\t\tret = PTR_ERR(csi->mclk);\n\t\tdev_err(dev, \"Failed to get mclk: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tcsi->irq = platform_get_irq(pdev, 0);\n\tif (csi->irq < 0)\n\t\treturn csi->irq;\n\n\tcsi->regbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(csi->regbase))\n\t\treturn PTR_ERR(csi->regbase);\n\n\tcsi->model = (enum imx_csi_model)(uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\tret = devm_request_irq(dev, csi->irq, imx7_csi_irq_handler, 0, \"csi\",\n\t\t\t       (void *)csi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Request CSI IRQ failed.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = imx7_csi_media_init(csi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx7_csi_async_register(csi);\n\tif (ret)\n\t\tgoto err_media_cleanup;\n\n\treturn 0;\n\nerr_media_cleanup:\n\timx7_csi_media_cleanup(csi);\n\n\treturn ret;\n}\n\nstatic void imx7_csi_remove(struct platform_device *pdev)\n{\n\tstruct imx7_csi *csi = platform_get_drvdata(pdev);\n\n\timx7_csi_media_cleanup(csi);\n\n\tv4l2_async_nf_unregister(&csi->notifier);\n\tv4l2_async_nf_cleanup(&csi->notifier);\n\tv4l2_async_unregister_subdev(&csi->sd);\n}\n\nstatic const struct of_device_id imx7_csi_of_match[] = {\n\t{ .compatible = \"fsl,imx8mq-csi\", .data = (void *)IMX7_CSI_IMX8MQ },\n\t{ .compatible = \"fsl,imx7-csi\", .data = (void *)IMX7_CSI_IMX7 },\n\t{ .compatible = \"fsl,imx6ul-csi\", .data = (void *)IMX7_CSI_IMX7 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, imx7_csi_of_match);\n\nstatic struct platform_driver imx7_csi_driver = {\n\t.probe = imx7_csi_probe,\n\t.remove_new = imx7_csi_remove,\n\t.driver = {\n\t\t.of_match_table = imx7_csi_of_match,\n\t\t.name = \"imx7-csi\",\n\t},\n};\nmodule_platform_driver(imx7_csi_driver);\n\nMODULE_DESCRIPTION(\"i.MX7 CSI subdev driver\");\nMODULE_AUTHOR(\"Rui Miguel Silva <rui.silva@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:imx7-csi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}