{
  "module_name": "mx2_emmaprp.c",
  "hash_id": "b1192c0491d83760f18bb85b9f24cb5ad5e7985d20df6246d7e30bc1c39e30ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/mx2_emmaprp.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n\n#include <linux/platform_device.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-dma-contig.h>\n#include <linux/sizes.h>\n\n#define EMMAPRP_MODULE_NAME \"mem2mem-emmaprp\"\n\nMODULE_DESCRIPTION(\"Mem-to-mem device which supports eMMa-PrP present in mx2 SoCs\");\nMODULE_AUTHOR(\"Javier Martin <javier.martin@vista-silicon.com\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.0.1\");\n\nstatic bool debug;\nmodule_param(debug, bool, 0644);\n\n#define MIN_W 32\n#define MIN_H 32\n#define MAX_W 2040\n#define MAX_H 2046\n\n#define S_ALIGN\t\t1  \n#define W_ALIGN_YUV420\t3  \n#define W_ALIGN_OTHERS\t2  \n#define H_ALIGN\t\t1  \n\n \n#define MEM2MEM_CAPTURE\t(1 << 0)\n#define MEM2MEM_OUTPUT\t(1 << 1)\n\n#define MEM2MEM_NAME\t\t\"m2m-emmaprp\"\n\n \n#define MEM2MEM_VID_MEM_LIMIT\tSZ_16M\n\n#define dprintk(dev, fmt, arg...) \\\n\tv4l2_dbg(1, debug, &dev->v4l2_dev, \"%s: \" fmt, __func__, ## arg)\n\n \n#define PRP_CNTL                        0x00\n#define PRP_INTR_CNTL                   0x04\n#define PRP_INTRSTATUS                  0x08\n#define PRP_SOURCE_Y_PTR                0x0c\n#define PRP_SOURCE_CB_PTR               0x10\n#define PRP_SOURCE_CR_PTR               0x14\n#define PRP_DEST_RGB1_PTR               0x18\n#define PRP_DEST_RGB2_PTR               0x1c\n#define PRP_DEST_Y_PTR                  0x20\n#define PRP_DEST_CB_PTR                 0x24\n#define PRP_DEST_CR_PTR                 0x28\n#define PRP_SRC_FRAME_SIZE              0x2c\n#define PRP_DEST_CH1_LINE_STRIDE        0x30\n#define PRP_SRC_PIXEL_FORMAT_CNTL       0x34\n#define PRP_CH1_PIXEL_FORMAT_CNTL       0x38\n#define PRP_CH1_OUT_IMAGE_SIZE          0x3c\n#define PRP_CH2_OUT_IMAGE_SIZE          0x40\n#define PRP_SRC_LINE_STRIDE             0x44\n#define PRP_CSC_COEF_012                0x48\n#define PRP_CSC_COEF_345                0x4c\n#define PRP_CSC_COEF_678                0x50\n#define PRP_CH1_RZ_HORI_COEF1           0x54\n#define PRP_CH1_RZ_HORI_COEF2           0x58\n#define PRP_CH1_RZ_HORI_VALID           0x5c\n#define PRP_CH1_RZ_VERT_COEF1           0x60\n#define PRP_CH1_RZ_VERT_COEF2           0x64\n#define PRP_CH1_RZ_VERT_VALID           0x68\n#define PRP_CH2_RZ_HORI_COEF1           0x6c\n#define PRP_CH2_RZ_HORI_COEF2           0x70\n#define PRP_CH2_RZ_HORI_VALID           0x74\n#define PRP_CH2_RZ_VERT_COEF1           0x78\n#define PRP_CH2_RZ_VERT_COEF2           0x7c\n#define PRP_CH2_RZ_VERT_VALID           0x80\n\n#define PRP_CNTL_CH1EN          (1 << 0)\n#define PRP_CNTL_CH2EN          (1 << 1)\n#define PRP_CNTL_CSIEN          (1 << 2)\n#define PRP_CNTL_DATA_IN_YUV420 (0 << 3)\n#define PRP_CNTL_DATA_IN_YUV422 (1 << 3)\n#define PRP_CNTL_DATA_IN_RGB16  (2 << 3)\n#define PRP_CNTL_DATA_IN_RGB32  (3 << 3)\n#define PRP_CNTL_CH1_OUT_RGB8   (0 << 5)\n#define PRP_CNTL_CH1_OUT_RGB16  (1 << 5)\n#define PRP_CNTL_CH1_OUT_RGB32  (2 << 5)\n#define PRP_CNTL_CH1_OUT_YUV422 (3 << 5)\n#define PRP_CNTL_CH2_OUT_YUV420 (0 << 7)\n#define PRP_CNTL_CH2_OUT_YUV422 (1 << 7)\n#define PRP_CNTL_CH2_OUT_YUV444 (2 << 7)\n#define PRP_CNTL_CH1_LEN        (1 << 9)\n#define PRP_CNTL_CH2_LEN        (1 << 10)\n#define PRP_CNTL_SKIP_FRAME     (1 << 11)\n#define PRP_CNTL_SWRST          (1 << 12)\n#define PRP_CNTL_CLKEN          (1 << 13)\n#define PRP_CNTL_WEN            (1 << 14)\n#define PRP_CNTL_CH1BYP         (1 << 15)\n#define PRP_CNTL_IN_TSKIP(x)    ((x) << 16)\n#define PRP_CNTL_CH1_TSKIP(x)   ((x) << 19)\n#define PRP_CNTL_CH2_TSKIP(x)   ((x) << 22)\n#define PRP_CNTL_INPUT_FIFO_LEVEL(x)    ((x) << 25)\n#define PRP_CNTL_RZ_FIFO_LEVEL(x)       ((x) << 27)\n#define PRP_CNTL_CH2B1EN        (1 << 29)\n#define PRP_CNTL_CH2B2EN        (1 << 30)\n#define PRP_CNTL_CH2FEN         (1UL << 31)\n\n#define PRP_SIZE_HEIGHT(x)\t(x)\n#define PRP_SIZE_WIDTH(x)\t((x) << 16)\n\n \n#define PRP_INTR_RDERR          (1 << 0)\n#define PRP_INTR_CH1WERR        (1 << 1)\n#define PRP_INTR_CH2WERR        (1 << 2)\n#define PRP_INTR_CH1FC          (1 << 3)\n#define PRP_INTR_CH2FC          (1 << 5)\n#define PRP_INTR_LBOVF          (1 << 7)\n#define PRP_INTR_CH2OVF         (1 << 8)\n\n#define PRP_INTR_ST_RDERR\t(1 << 0)\n#define PRP_INTR_ST_CH1WERR\t(1 << 1)\n#define PRP_INTR_ST_CH2WERR\t(1 << 2)\n#define PRP_INTR_ST_CH2B2CI\t(1 << 3)\n#define PRP_INTR_ST_CH2B1CI\t(1 << 4)\n#define PRP_INTR_ST_CH1B2CI\t(1 << 5)\n#define PRP_INTR_ST_CH1B1CI\t(1 << 6)\n#define PRP_INTR_ST_LBOVF\t(1 << 7)\n#define PRP_INTR_ST_CH2OVF\t(1 << 8)\n\nstruct emmaprp_fmt {\n\tu32\tfourcc;\n\t \n\tu32\ttypes;\n};\n\nstatic struct emmaprp_fmt formats[] = {\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_YUV420,\n\t\t.types\t= MEM2MEM_CAPTURE,\n\t},\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_YUYV,\n\t\t.types\t= MEM2MEM_OUTPUT,\n\t},\n};\n\n \nstruct emmaprp_q_data {\n\tunsigned int\t\twidth;\n\tunsigned int\t\theight;\n\tunsigned int\t\tsizeimage;\n\tstruct emmaprp_fmt\t*fmt;\n};\n\nenum {\n\tV4L2_M2M_SRC = 0,\n\tV4L2_M2M_DST = 1,\n};\n\n#define NUM_FORMATS ARRAY_SIZE(formats)\n\nstatic struct emmaprp_fmt *find_format(struct v4l2_format *f)\n{\n\tstruct emmaprp_fmt *fmt;\n\tunsigned int k;\n\n\tfor (k = 0; k < NUM_FORMATS; k++) {\n\t\tfmt = &formats[k];\n\t\tif (fmt->fourcc == f->fmt.pix.pixelformat)\n\t\t\tbreak;\n\t}\n\n\tif (k == NUM_FORMATS)\n\t\treturn NULL;\n\n\treturn &formats[k];\n}\n\nstruct emmaprp_dev {\n\tstruct v4l2_device\tv4l2_dev;\n\tstruct video_device\t*vfd;\n\n\tstruct mutex\t\tdev_mutex;\n\tspinlock_t\t\tirqlock;\n\n\tvoid __iomem\t\t*base_emma;\n\tstruct clk\t\t*clk_emma_ahb, *clk_emma_ipg;\n\n\tstruct v4l2_m2m_dev\t*m2m_dev;\n};\n\nstruct emmaprp_ctx {\n\tstruct v4l2_fh\t\tfh;\n\tstruct emmaprp_dev\t*dev;\n\t \n\tint\t\t\taborting;\n\tstruct emmaprp_q_data\tq_data[2];\n};\n\nstatic struct emmaprp_q_data *get_q_data(struct emmaprp_ctx *ctx,\n\t\t\t\t\t enum v4l2_buf_type type)\n{\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\treturn &(ctx->q_data[V4L2_M2M_SRC]);\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn &(ctx->q_data[V4L2_M2M_DST]);\n\tdefault:\n\t\tBUG();\n\t}\n\treturn NULL;\n}\n\n \nstatic void emmaprp_job_abort(void *priv)\n{\n\tstruct emmaprp_ctx *ctx = priv;\n\tstruct emmaprp_dev *pcdev = ctx->dev;\n\n\tctx->aborting = 1;\n\n\tdprintk(pcdev, \"Aborting task\\n\");\n\n\tv4l2_m2m_job_finish(pcdev->m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic inline void emmaprp_dump_regs(struct emmaprp_dev *pcdev)\n{\n\tdprintk(pcdev,\n\t\t\"eMMa-PrP Registers:\\n\"\n\t\t\"  SOURCE_Y_PTR = 0x%08X\\n\"\n\t\t\"  SRC_FRAME_SIZE = 0x%08X\\n\"\n\t\t\"  DEST_Y_PTR = 0x%08X\\n\"\n\t\t\"  DEST_CR_PTR = 0x%08X\\n\"\n\t\t\"  DEST_CB_PTR = 0x%08X\\n\"\n\t\t\"  CH2_OUT_IMAGE_SIZE = 0x%08X\\n\"\n\t\t\"  CNTL = 0x%08X\\n\",\n\t\treadl(pcdev->base_emma + PRP_SOURCE_Y_PTR),\n\t\treadl(pcdev->base_emma + PRP_SRC_FRAME_SIZE),\n\t\treadl(pcdev->base_emma + PRP_DEST_Y_PTR),\n\t\treadl(pcdev->base_emma + PRP_DEST_CR_PTR),\n\t\treadl(pcdev->base_emma + PRP_DEST_CB_PTR),\n\t\treadl(pcdev->base_emma + PRP_CH2_OUT_IMAGE_SIZE),\n\t\treadl(pcdev->base_emma + PRP_CNTL));\n}\n\nstatic void emmaprp_device_run(void *priv)\n{\n\tstruct emmaprp_ctx *ctx = priv;\n\tstruct emmaprp_q_data *s_q_data, *d_q_data;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct emmaprp_dev *pcdev = ctx->dev;\n\tunsigned int s_width, s_height;\n\tunsigned int d_width, d_height;\n\tunsigned int d_size;\n\tdma_addr_t p_in, p_out;\n\tu32 tmp;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\ts_q_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\ts_width\t= s_q_data->width;\n\ts_height = s_q_data->height;\n\n\td_q_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\td_width = d_q_data->width;\n\td_height = d_q_data->height;\n\td_size = d_width * d_height;\n\n\tp_in = vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\n\tp_out = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\tif (!p_in || !p_out) {\n\t\tv4l2_err(&pcdev->v4l2_dev,\n\t\t\t \"Acquiring kernel pointers to buffers failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\twritel(p_in, pcdev->base_emma + PRP_SOURCE_Y_PTR);\n\twritel(PRP_SIZE_WIDTH(s_width) | PRP_SIZE_HEIGHT(s_height),\n\t       pcdev->base_emma + PRP_SRC_FRAME_SIZE);\n\n\t \n\twritel(p_out, pcdev->base_emma + PRP_DEST_Y_PTR);\n\twritel(p_out + d_size, pcdev->base_emma + PRP_DEST_CB_PTR);\n\twritel(p_out + d_size + (d_size >> 2),\n\t       pcdev->base_emma + PRP_DEST_CR_PTR);\n\twritel(PRP_SIZE_WIDTH(d_width) | PRP_SIZE_HEIGHT(d_height),\n\t       pcdev->base_emma + PRP_CH2_OUT_IMAGE_SIZE);\n\n\t \n\ttmp = readl(pcdev->base_emma + PRP_INTR_CNTL);\n\twritel(tmp | PRP_INTR_RDERR |\n\t\tPRP_INTR_CH2WERR |\n\t\tPRP_INTR_CH2FC,\n\t\tpcdev->base_emma + PRP_INTR_CNTL);\n\n\temmaprp_dump_regs(pcdev);\n\n\t \n\ttmp = readl(pcdev->base_emma + PRP_CNTL);\n\twritel(tmp | PRP_CNTL_CH2_OUT_YUV420 |\n\t\tPRP_CNTL_DATA_IN_YUV422 |\n\t\tPRP_CNTL_CH2EN,\n\t\tpcdev->base_emma + PRP_CNTL);\n}\n\nstatic irqreturn_t emmaprp_irq(int irq_emma, void *data)\n{\n\tstruct emmaprp_dev *pcdev = data;\n\tstruct emmaprp_ctx *curr_ctx;\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\tunsigned long flags;\n\tu32 irqst;\n\n\t \n\tirqst = readl(pcdev->base_emma + PRP_INTRSTATUS);\n\twritel(irqst, pcdev->base_emma + PRP_INTRSTATUS);\n\tdprintk(pcdev, \"irqst = 0x%08x\\n\", irqst);\n\n\tcurr_ctx = v4l2_m2m_get_curr_priv(pcdev->m2m_dev);\n\tif (curr_ctx == NULL) {\n\t\tpr_err(\"Instance released before the end of transaction\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!curr_ctx->aborting) {\n\t\tif ((irqst & PRP_INTR_ST_RDERR) ||\n\t\t(irqst & PRP_INTR_ST_CH2WERR)) {\n\t\t\tpr_err(\"PrP bus error occurred, this transfer is probably corrupted\\n\");\n\t\t\twritel(PRP_CNTL_SWRST, pcdev->base_emma + PRP_CNTL);\n\t\t} else if (irqst & PRP_INTR_ST_CH2B1CI) {  \n\t\t\tsrc_vb = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\n\t\t\tdst_vb = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\n\n\t\t\tdst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;\n\t\t\tdst_vb->flags &=\n\t\t\t\t~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\t\t\tdst_vb->flags |=\n\t\t\t\tsrc_vb->flags\n\t\t\t\t& V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\t\t\tdst_vb->timecode = src_vb->timecode;\n\n\t\t\tspin_lock_irqsave(&pcdev->irqlock, flags);\n\t\t\tv4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_DONE);\n\t\t\tv4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_DONE);\n\t\t\tspin_unlock_irqrestore(&pcdev->irqlock, flags);\n\t\t}\n\t}\n\n\tv4l2_m2m_job_finish(pcdev->m2m_dev, curr_ctx->fh.m2m_ctx);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, MEM2MEM_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, MEM2MEM_NAME, sizeof(cap->card));\n\treturn 0;\n}\n\nstatic int enum_fmt(struct v4l2_fmtdesc *f, u32 type)\n{\n\tint i, num;\n\tstruct emmaprp_fmt *fmt;\n\n\tnum = 0;\n\n\tfor (i = 0; i < NUM_FORMATS; ++i) {\n\t\tif (formats[i].types & type) {\n\t\t\t \n\t\t\tif (num == f->index)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\t++num;\n\t\t}\n\t}\n\n\tif (i < NUM_FORMATS) {\n\t\t \n\t\tfmt = &formats[i];\n\t\tf->pixelformat = fmt->fourcc;\n\t\treturn 0;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn enum_fmt(f, MEM2MEM_CAPTURE);\n}\n\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn enum_fmt(f, MEM2MEM_OUTPUT);\n}\n\nstatic int vidioc_g_fmt(struct emmaprp_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct emmaprp_q_data *q_data;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, f->type);\n\n\tf->fmt.pix.width\t= q_data->width;\n\tf->fmt.pix.height\t= q_data->height;\n\tf->fmt.pix.field\t= V4L2_FIELD_NONE;\n\tf->fmt.pix.pixelformat\t= q_data->fmt->fourcc;\n\tif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_YUV420)\n\t\tf->fmt.pix.bytesperline = q_data->width * 3 / 2;\n\telse  \n\t\tf->fmt.pix.bytesperline = q_data->width * 2;\n\tf->fmt.pix.sizeimage\t= q_data->sizeimage;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\treturn vidioc_g_fmt(priv, f);\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\treturn vidioc_g_fmt(priv, f);\n}\n\nstatic int vidioc_try_fmt(struct v4l2_format *f)\n{\n\tenum v4l2_field field;\n\n\n\tif (!find_format(f))\n\t\treturn -EINVAL;\n\n\tfield = f->fmt.pix.field;\n\tif (field == V4L2_FIELD_ANY)\n\t\tfield = V4L2_FIELD_NONE;\n\telse if (V4L2_FIELD_NONE != field)\n\t\treturn -EINVAL;\n\n\t \n\tf->fmt.pix.field = field;\n\n\tif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_YUV420) {\n\t\tv4l_bound_align_image(&f->fmt.pix.width, MIN_W, MAX_W,\n\t\t\t\t      W_ALIGN_YUV420, &f->fmt.pix.height,\n\t\t\t\t      MIN_H, MAX_H, H_ALIGN, S_ALIGN);\n\t\tf->fmt.pix.bytesperline = f->fmt.pix.width * 3 / 2;\n\t} else {\n\t\tv4l_bound_align_image(&f->fmt.pix.width, MIN_W, MAX_W,\n\t\t\t\t      W_ALIGN_OTHERS, &f->fmt.pix.height,\n\t\t\t\t      MIN_H, MAX_H, H_ALIGN, S_ALIGN);\n\t\tf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\n\t}\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct emmaprp_fmt *fmt;\n\tstruct emmaprp_ctx *ctx = priv;\n\n\tfmt = find_format(f);\n\tif (!fmt || !(fmt->types & MEM2MEM_CAPTURE)) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"Fourcc format (0x%08x) invalid.\\n\",\n\t\t\t f->fmt.pix.pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\treturn vidioc_try_fmt(f);\n}\n\nstatic int vidioc_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct emmaprp_fmt *fmt;\n\tstruct emmaprp_ctx *ctx = priv;\n\n\tfmt = find_format(f);\n\tif (!fmt || !(fmt->types & MEM2MEM_OUTPUT)) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"Fourcc format (0x%08x) invalid.\\n\",\n\t\t\t f->fmt.pix.pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\treturn vidioc_try_fmt(f);\n}\n\nstatic int vidioc_s_fmt(struct emmaprp_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct emmaprp_q_data *q_data;\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, f->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"%s queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tret = vidioc_try_fmt(f);\n\tif (ret)\n\t\treturn ret;\n\n\tq_data->fmt\t\t= find_format(f);\n\tq_data->width\t\t= f->fmt.pix.width;\n\tq_data->height\t\t= f->fmt.pix.height;\n\tif (q_data->fmt->fourcc == V4L2_PIX_FMT_YUV420)\n\t\tq_data->sizeimage = q_data->width * q_data->height * 3 / 2;\n\telse  \n\t\tq_data->sizeimage = q_data->width * q_data->height * 2;\n\n\tdprintk(ctx->dev,\n\t\t\"Setting format for type %d, wxh: %dx%d, fmt: %d\\n\",\n\t\tf->type, q_data->width, q_data->height, q_data->fmt->fourcc);\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tint ret;\n\n\tret = vidioc_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vidioc_s_fmt(priv, f);\n}\n\nstatic int vidioc_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tint ret;\n\n\tret = vidioc_try_fmt_vid_out(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vidioc_s_fmt(priv, f);\n}\n\nstatic const struct v4l2_ioctl_ops emmaprp_ioctl_ops = {\n\t.vidioc_querycap\t= vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t= vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t= vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t= vidioc_s_fmt_vid_cap,\n\n\t.vidioc_enum_fmt_vid_out = vidioc_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out\t= vidioc_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t= vidioc_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t= vidioc_s_fmt_vid_out,\n\n\t.vidioc_reqbufs\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_expbuf\t\t= v4l2_m2m_ioctl_expbuf,\n\t.vidioc_streamon\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t= v4l2_m2m_ioctl_streamoff,\n};\n\n\n \nstatic int emmaprp_queue_setup(struct vb2_queue *vq,\n\t\t\t\tunsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct emmaprp_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct emmaprp_q_data *q_data;\n\tunsigned int size, count = *nbuffers;\n\n\tq_data = get_q_data(ctx, vq->type);\n\n\tif (q_data->fmt->fourcc == V4L2_PIX_FMT_YUV420)\n\t\tsize = q_data->width * q_data->height * 3 / 2;\n\telse\n\t\tsize = q_data->width * q_data->height * 2;\n\n\twhile (size * count > MEM2MEM_VID_MEM_LIMIT)\n\t\t(count)--;\n\n\t*nplanes = 1;\n\t*nbuffers = count;\n\tsizes[0] = size;\n\n\tdprintk(ctx->dev, \"get %d buffer(s) of size %d each.\\n\", count, size);\n\n\treturn 0;\n}\n\nstatic int emmaprp_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct emmaprp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct emmaprp_q_data *q_data;\n\n\tdprintk(ctx->dev, \"type: %d\\n\", vb->vb2_queue->type);\n\n\tq_data = get_q_data(ctx, vb->vb2_queue->type);\n\n\tif (vb2_plane_size(vb, 0) < q_data->sizeimage) {\n\t\tdprintk(ctx->dev,\n\t\t\t\"%s data will not fit into plane(%lu < %lu)\\n\",\n\t\t\t__func__, vb2_plane_size(vb, 0),\n\t\t\t(long)q_data->sizeimage);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, q_data->sizeimage);\n\n\treturn 0;\n}\n\nstatic void emmaprp_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct emmaprp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic const struct vb2_ops emmaprp_qops = {\n\t.queue_setup\t = emmaprp_queue_setup,\n\t.buf_prepare\t = emmaprp_buf_prepare,\n\t.buf_queue\t = emmaprp_buf_queue,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n};\n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct emmaprp_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->ops = &emmaprp_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->dev = ctx->dev->v4l2_dev.dev;\n\tsrc_vq->lock = &ctx->dev->dev_mutex;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops = &emmaprp_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->dev = ctx->dev->v4l2_dev.dev;\n\tdst_vq->lock = &ctx->dev->dev_mutex;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\n \nstatic int emmaprp_open(struct file *file)\n{\n\tstruct emmaprp_dev *pcdev = video_drvdata(file);\n\tstruct emmaprp_ctx *ctx;\n\n\tctx = kzalloc(sizeof *ctx, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tctx->dev = pcdev;\n\n\tif (mutex_lock_interruptible(&pcdev->dev_mutex)) {\n\t\tkfree(ctx);\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(pcdev->m2m_dev, ctx, &queue_init);\n\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tint ret = PTR_ERR(ctx->fh.m2m_ctx);\n\n\t\tmutex_unlock(&pcdev->dev_mutex);\n\t\tkfree(ctx);\n\t\treturn ret;\n\t}\n\n\tclk_prepare_enable(pcdev->clk_emma_ipg);\n\tclk_prepare_enable(pcdev->clk_emma_ahb);\n\tctx->q_data[V4L2_M2M_SRC].fmt = &formats[1];\n\tctx->q_data[V4L2_M2M_DST].fmt = &formats[0];\n\tv4l2_fh_add(&ctx->fh);\n\tmutex_unlock(&pcdev->dev_mutex);\n\n\tdprintk(pcdev, \"Created instance %p, m2m_ctx: %p\\n\", ctx, ctx->fh.m2m_ctx);\n\n\treturn 0;\n}\n\nstatic int emmaprp_release(struct file *file)\n{\n\tstruct emmaprp_dev *pcdev = video_drvdata(file);\n\tstruct emmaprp_ctx *ctx = file->private_data;\n\n\tdprintk(pcdev, \"Releasing instance %p\\n\", ctx);\n\n\tmutex_lock(&pcdev->dev_mutex);\n\tclk_disable_unprepare(pcdev->clk_emma_ahb);\n\tclk_disable_unprepare(pcdev->clk_emma_ipg);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tmutex_unlock(&pcdev->dev_mutex);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations emmaprp_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= emmaprp_open,\n\t.release\t= emmaprp_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct video_device emmaprp_videodev = {\n\t.name\t\t= MEM2MEM_NAME,\n\t.fops\t\t= &emmaprp_fops,\n\t.ioctl_ops\t= &emmaprp_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= video_device_release,\n\t.vfl_dir\t= VFL_DIR_M2M,\n\t.device_caps\t= V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING,\n};\n\nstatic const struct v4l2_m2m_ops m2m_ops = {\n\t.device_run\t= emmaprp_device_run,\n\t.job_abort\t= emmaprp_job_abort,\n};\n\nstatic int emmaprp_probe(struct platform_device *pdev)\n{\n\tstruct emmaprp_dev *pcdev;\n\tstruct video_device *vfd;\n\tint irq, ret;\n\n\tpcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);\n\tif (!pcdev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&pcdev->irqlock);\n\n\tpcdev->clk_emma_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(pcdev->clk_emma_ipg)) {\n\t\treturn PTR_ERR(pcdev->clk_emma_ipg);\n\t}\n\n\tpcdev->clk_emma_ahb = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(pcdev->clk_emma_ahb))\n\t\treturn PTR_ERR(pcdev->clk_emma_ahb);\n\n\tpcdev->base_emma = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pcdev->base_emma))\n\t\treturn PTR_ERR(pcdev->base_emma);\n\n\tret = v4l2_device_register(&pdev->dev, &pcdev->v4l2_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&pcdev->dev_mutex);\n\n\tvfd = video_device_alloc();\n\tif (!vfd) {\n\t\tv4l2_err(&pcdev->v4l2_dev, \"Failed to allocate video device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto unreg_dev;\n\t}\n\n\t*vfd = emmaprp_videodev;\n\tvfd->lock = &pcdev->dev_mutex;\n\tvfd->v4l2_dev = &pcdev->v4l2_dev;\n\n\tvideo_set_drvdata(vfd, pcdev);\n\tpcdev->vfd = vfd;\n\tv4l2_info(&pcdev->v4l2_dev, EMMAPRP_MODULE_NAME\n\t\t  \" Device registered as /dev/video%d\\n\", vfd->num);\n\n\tplatform_set_drvdata(pdev, pcdev);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto rel_vdev;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, emmaprp_irq, 0,\n\t\t\t       dev_name(&pdev->dev), pcdev);\n\tif (ret)\n\t\tgoto rel_vdev;\n\n\tpcdev->m2m_dev = v4l2_m2m_init(&m2m_ops);\n\tif (IS_ERR(pcdev->m2m_dev)) {\n\t\tv4l2_err(&pcdev->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(pcdev->m2m_dev);\n\t\tgoto rel_vdev;\n\t}\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&pcdev->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto rel_m2m;\n\t}\n\n\treturn 0;\n\n\nrel_m2m:\n\tv4l2_m2m_release(pcdev->m2m_dev);\nrel_vdev:\n\tvideo_device_release(vfd);\nunreg_dev:\n\tv4l2_device_unregister(&pcdev->v4l2_dev);\n\n\tmutex_destroy(&pcdev->dev_mutex);\n\n\treturn ret;\n}\n\nstatic void emmaprp_remove(struct platform_device *pdev)\n{\n\tstruct emmaprp_dev *pcdev = platform_get_drvdata(pdev);\n\n\tv4l2_info(&pcdev->v4l2_dev, \"Removing \" EMMAPRP_MODULE_NAME);\n\n\tvideo_unregister_device(pcdev->vfd);\n\tv4l2_m2m_release(pcdev->m2m_dev);\n\tv4l2_device_unregister(&pcdev->v4l2_dev);\n\tmutex_destroy(&pcdev->dev_mutex);\n}\n\nstatic struct platform_driver emmaprp_pdrv = {\n\t.probe\t\t= emmaprp_probe,\n\t.remove_new\t= emmaprp_remove,\n\t.driver\t\t= {\n\t\t.name\t= MEM2MEM_NAME,\n\t},\n};\nmodule_platform_driver(emmaprp_pdrv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}