{
  "module_name": "imx-pxp.c",
  "hash_id": "05887bbf34d03650c649195881884adeb2a574cea03a7b110dadeb39d80206c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/imx-pxp.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <media/media-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"imx-pxp.h\"\n\nstatic unsigned int debug;\nmodule_param(debug, uint, 0644);\nMODULE_PARM_DESC(debug, \"activates debug info\");\n\n#define MIN_W 8\n#define MIN_H 8\n#define MAX_W 4096\n#define MAX_H 4096\n#define ALIGN_W 3  \n#define ALIGN_H 3\n\n \n#define MEM2MEM_CAPTURE\t(1 << 0)\n#define MEM2MEM_OUTPUT\t(1 << 1)\n\n#define MEM2MEM_NAME\t\t\"pxp\"\n\n \n#define MEM2MEM_HFLIP\t(1 << 0)\n#define MEM2MEM_VFLIP\t(1 << 1)\n\n#define PXP_VERSION_MAJOR(version) \\\n\tFIELD_GET(BM_PXP_VERSION_MAJOR, version)\n#define PXP_VERSION_MINOR(version) \\\n\tFIELD_GET(BM_PXP_VERSION_MINOR, version)\n\n#define dprintk(dev, fmt, arg...) \\\n\tv4l2_dbg(1, debug, &dev->v4l2_dev, \"%s: \" fmt, __func__, ## arg)\n\nstruct pxp_fmt {\n\tu32\tfourcc;\n\tint\tdepth;\n\t \n\tu32\ttypes;\n};\n\nstatic struct pxp_fmt formats[] = {\n\t{\n\t\t.fourcc\t= V4L2_PIX_FMT_XBGR32,\n\t\t.depth\t= 32,\n\t\t \n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_ABGR32,\n\t\t.depth\t= 32,\n\t\t \n\t\t.types\t= MEM2MEM_CAPTURE,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_BGR24,\n\t\t.depth\t= 24,\n\t\t.types\t= MEM2MEM_CAPTURE,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB565,\n\t\t.depth\t= 16,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc\t= V4L2_PIX_FMT_RGB555,\n\t\t.depth\t= 16,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_RGB444,\n\t\t.depth\t= 16,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_VUYA32,\n\t\t.depth\t= 32,\n\t\t.types\t= MEM2MEM_CAPTURE,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_VUYX32,\n\t\t.depth\t= 32,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_UYVY,\n\t\t.depth\t= 16,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.depth\t= 16,\n\t\t \n\t\t.types\t= MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_VYUY,\n\t\t.depth\t= 16,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YVYU,\n\t\t.depth\t= 16,\n\t\t.types\t= MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_GREY,\n\t\t.depth\t= 8,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_Y4,\n\t\t.depth\t= 4,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV16,\n\t\t.depth\t= 16,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV12,\n\t\t.depth\t= 12,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV21,\n\t\t.depth\t= 12,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_NV61,\n\t\t.depth\t= 16,\n\t\t.types\t= MEM2MEM_CAPTURE | MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUV422P,\n\t\t.depth\t= 16,\n\t\t.types\t= MEM2MEM_OUTPUT,\n\t}, {\n\t\t.fourcc = V4L2_PIX_FMT_YUV420,\n\t\t.depth\t= 12,\n\t\t.types\t= MEM2MEM_OUTPUT,\n\t},\n};\n\n#define NUM_FORMATS ARRAY_SIZE(formats)\n\n \nstruct pxp_q_data {\n\tunsigned int\t\twidth;\n\tunsigned int\t\theight;\n\tunsigned int\t\tbytesperline;\n\tunsigned int\t\tsizeimage;\n\tunsigned int\t\tsequence;\n\tstruct pxp_fmt\t\t*fmt;\n\tenum v4l2_ycbcr_encoding ycbcr_enc;\n\tenum v4l2_quantization\tquant;\n};\n\nenum {\n\tV4L2_M2M_SRC = 0,\n\tV4L2_M2M_DST = 1,\n};\n\nstatic const struct regmap_config pxp_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = HW_PXP_VERSION,\n};\n\nstatic struct pxp_fmt *find_format(unsigned int pixelformat)\n{\n\tstruct pxp_fmt *fmt;\n\tunsigned int k;\n\n\tfor (k = 0; k < NUM_FORMATS; k++) {\n\t\tfmt = &formats[k];\n\t\tif (fmt->fourcc == pixelformat)\n\t\t\tbreak;\n\t}\n\n\tif (k == NUM_FORMATS)\n\t\treturn NULL;\n\n\treturn &formats[k];\n}\n\nstruct pxp_ctx;\n\nstruct pxp_pdata {\n\tu32 (*data_path_ctrl0)(struct pxp_ctx *ctx);\n};\n\nstruct pxp_dev {\n\tstruct v4l2_device\tv4l2_dev;\n\tstruct video_device\tvfd;\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_device\tmdev;\n#endif\n\n\tstruct clk\t\t*clk;\n\tstruct regmap\t\t*regmap;\n\n\tconst struct pxp_pdata\t*pdata;\n\n\tatomic_t\t\tnum_inst;\n\tstruct mutex\t\tdev_mutex;\n\tspinlock_t\t\tirqlock;\n\n\tstruct v4l2_m2m_dev\t*m2m_dev;\n};\n\nstruct pxp_ctx {\n\tstruct v4l2_fh\t\tfh;\n\tstruct pxp_dev\t*dev;\n\n\tstruct v4l2_ctrl_handler hdl;\n\n\t \n\tint\t\t\taborting;\n\n\t \n\tint\t\t\tmode;\n\tu8\t\t\talpha_component;\n\tu8\t\t\trotation;\n\n\tenum v4l2_colorspace\tcolorspace;\n\tenum v4l2_xfer_func\txfer_func;\n\n\t \n\tstruct pxp_q_data   q_data[2];\n};\n\nstatic inline struct pxp_ctx *file2ctx(struct file *file)\n{\n\treturn container_of(file->private_data, struct pxp_ctx, fh);\n}\n\nstatic struct pxp_q_data *get_q_data(struct pxp_ctx *ctx,\n\t\t\t\t\t enum v4l2_buf_type type)\n{\n\tif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn &ctx->q_data[V4L2_M2M_SRC];\n\telse\n\t\treturn &ctx->q_data[V4L2_M2M_DST];\n}\n\nstatic inline u32 pxp_read(struct pxp_dev *dev, u32 reg)\n{\n\tu32 value;\n\n\tregmap_read(dev->regmap, reg, &value);\n\n\treturn value;\n}\n\nstatic inline void pxp_write(struct pxp_dev *dev, u32 reg, u32 value)\n{\n\tregmap_write(dev->regmap, reg, value);\n}\n\nstatic u32 pxp_v4l2_pix_fmt_to_ps_format(u32 v4l2_pix_fmt)\n{\n\tswitch (v4l2_pix_fmt) {\n\tcase V4L2_PIX_FMT_XBGR32:  return BV_PXP_PS_CTRL_FORMAT__RGB888;\n\tcase V4L2_PIX_FMT_RGB555:  return BV_PXP_PS_CTRL_FORMAT__RGB555;\n\tcase V4L2_PIX_FMT_RGB444:  return BV_PXP_PS_CTRL_FORMAT__RGB444;\n\tcase V4L2_PIX_FMT_RGB565:  return BV_PXP_PS_CTRL_FORMAT__RGB565;\n\tcase V4L2_PIX_FMT_VUYX32:  return BV_PXP_PS_CTRL_FORMAT__YUV1P444;\n\tcase V4L2_PIX_FMT_UYVY:    return BV_PXP_PS_CTRL_FORMAT__UYVY1P422;\n\tcase V4L2_PIX_FMT_YUYV:    return BM_PXP_PS_CTRL_WB_SWAP |\n\t\t\t\t\t  BV_PXP_PS_CTRL_FORMAT__UYVY1P422;\n\tcase V4L2_PIX_FMT_VYUY:    return BV_PXP_PS_CTRL_FORMAT__VYUY1P422;\n\tcase V4L2_PIX_FMT_YVYU:    return BM_PXP_PS_CTRL_WB_SWAP |\n\t\t\t\t\t  BV_PXP_PS_CTRL_FORMAT__VYUY1P422;\n\tcase V4L2_PIX_FMT_GREY:    return BV_PXP_PS_CTRL_FORMAT__Y8;\n\tdefault:\n\tcase V4L2_PIX_FMT_Y4:      return BV_PXP_PS_CTRL_FORMAT__Y4;\n\tcase V4L2_PIX_FMT_NV16:    return BV_PXP_PS_CTRL_FORMAT__YUV2P422;\n\tcase V4L2_PIX_FMT_NV12:    return BV_PXP_PS_CTRL_FORMAT__YUV2P420;\n\tcase V4L2_PIX_FMT_NV21:    return BV_PXP_PS_CTRL_FORMAT__YVU2P420;\n\tcase V4L2_PIX_FMT_NV61:    return BV_PXP_PS_CTRL_FORMAT__YVU2P422;\n\tcase V4L2_PIX_FMT_YUV422P: return BV_PXP_PS_CTRL_FORMAT__YUV422;\n\tcase V4L2_PIX_FMT_YUV420:  return BV_PXP_PS_CTRL_FORMAT__YUV420;\n\t}\n}\n\nstatic u32 pxp_v4l2_pix_fmt_to_out_format(u32 v4l2_pix_fmt)\n{\n\tswitch (v4l2_pix_fmt) {\n\tcase V4L2_PIX_FMT_XBGR32:   return BV_PXP_OUT_CTRL_FORMAT__RGB888;\n\tcase V4L2_PIX_FMT_ABGR32:   return BV_PXP_OUT_CTRL_FORMAT__ARGB8888;\n\tcase V4L2_PIX_FMT_BGR24:    return BV_PXP_OUT_CTRL_FORMAT__RGB888P;\n\t \n\tcase V4L2_PIX_FMT_RGB555:   return BV_PXP_OUT_CTRL_FORMAT__RGB555;\n\tcase V4L2_PIX_FMT_RGB444:   return BV_PXP_OUT_CTRL_FORMAT__RGB444;\n\tcase V4L2_PIX_FMT_RGB565:   return BV_PXP_OUT_CTRL_FORMAT__RGB565;\n\tcase V4L2_PIX_FMT_VUYA32:\n\tcase V4L2_PIX_FMT_VUYX32:   return BV_PXP_OUT_CTRL_FORMAT__YUV1P444;\n\tcase V4L2_PIX_FMT_UYVY:     return BV_PXP_OUT_CTRL_FORMAT__UYVY1P422;\n\tcase V4L2_PIX_FMT_VYUY:     return BV_PXP_OUT_CTRL_FORMAT__VYUY1P422;\n\tcase V4L2_PIX_FMT_GREY:     return BV_PXP_OUT_CTRL_FORMAT__Y8;\n\tdefault:\n\tcase V4L2_PIX_FMT_Y4:       return BV_PXP_OUT_CTRL_FORMAT__Y4;\n\tcase V4L2_PIX_FMT_NV16:     return BV_PXP_OUT_CTRL_FORMAT__YUV2P422;\n\tcase V4L2_PIX_FMT_NV12:     return BV_PXP_OUT_CTRL_FORMAT__YUV2P420;\n\tcase V4L2_PIX_FMT_NV61:     return BV_PXP_OUT_CTRL_FORMAT__YVU2P422;\n\tcase V4L2_PIX_FMT_NV21:     return BV_PXP_OUT_CTRL_FORMAT__YVU2P420;\n\t}\n}\n\nstatic bool pxp_v4l2_pix_fmt_is_yuv(u32 v4l2_pix_fmt)\n{\n\tswitch (v4l2_pix_fmt) {\n\tcase V4L2_PIX_FMT_VUYA32:\n\tcase V4L2_PIX_FMT_VUYX32:\n\tcase V4L2_PIX_FMT_UYVY:\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_VYUY:\n\tcase V4L2_PIX_FMT_YVYU:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV61:\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YUV422P:\n\tcase V4L2_PIX_FMT_GREY:\n\tcase V4L2_PIX_FMT_Y4:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void pxp_setup_csc(struct pxp_ctx *ctx)\n{\n\tstruct pxp_dev *dev = ctx->dev;\n\tenum v4l2_ycbcr_encoding ycbcr_enc;\n\tenum v4l2_quantization quantization;\n\n\tif (pxp_v4l2_pix_fmt_is_yuv(ctx->q_data[V4L2_M2M_SRC].fmt->fourcc) &&\n\t    !pxp_v4l2_pix_fmt_is_yuv(ctx->q_data[V4L2_M2M_DST].fmt->fourcc)) {\n\t\t \n\t\tstatic const u32 csc1_coef_bt601_lim[3] = {\n\t\t\tBM_PXP_CSC1_COEF0_YCBCR_MODE |\n\t\t\tBF_PXP_CSC1_COEF0_C0(0x12a) |\t \n\t\t\tBF_PXP_CSC1_COEF0_UV_OFFSET(-128) |\n\t\t\tBF_PXP_CSC1_COEF0_Y_OFFSET(-16),\n\t\t\tBF_PXP_CSC1_COEF1_C1(0x198) |\t \n\t\t\tBF_PXP_CSC1_COEF1_C4(0x204),\t \n\t\t\tBF_PXP_CSC1_COEF2_C2(0x730) |\t \n\t\t\tBF_PXP_CSC1_COEF2_C3(0x79c),\t \n\t\t};\n\t\t \n\t\tstatic const u32 csc1_coef_bt601_full[3] = {\n\t\t\tBM_PXP_CSC1_COEF0_YCBCR_MODE |\n\t\t\tBF_PXP_CSC1_COEF0_C0(0x100) |\t \n\t\t\tBF_PXP_CSC1_COEF0_UV_OFFSET(-128) |\n\t\t\tBF_PXP_CSC1_COEF0_Y_OFFSET(0),\n\t\t\tBF_PXP_CSC1_COEF1_C1(0x166) |\t \n\t\t\tBF_PXP_CSC1_COEF1_C4(0x1c5),\t \n\t\t\tBF_PXP_CSC1_COEF2_C2(0x74a) |\t \n\t\t\tBF_PXP_CSC1_COEF2_C3(0x7a8),\t \n\t\t};\n\t\t \n\t\tstatic const u32 csc1_coef_rec709_lim[3] = {\n\t\t\tBM_PXP_CSC1_COEF0_YCBCR_MODE |\n\t\t\tBF_PXP_CSC1_COEF0_C0(0x12a) |\t \n\t\t\tBF_PXP_CSC1_COEF0_UV_OFFSET(-128) |\n\t\t\tBF_PXP_CSC1_COEF0_Y_OFFSET(-16),\n\t\t\tBF_PXP_CSC1_COEF1_C1(0x1ca) |\t \n\t\t\tBF_PXP_CSC1_COEF1_C4(0x21c),\t \n\t\t\tBF_PXP_CSC1_COEF2_C2(0x778) |\t \n\t\t\tBF_PXP_CSC1_COEF2_C3(0x7ca),\t \n\t\t};\n\t\t \n\t\tstatic const u32 csc1_coef_rec709_full[3] = {\n\t\t\tBM_PXP_CSC1_COEF0_YCBCR_MODE |\n\t\t\tBF_PXP_CSC1_COEF0_C0(0x100) |\t \n\t\t\tBF_PXP_CSC1_COEF0_UV_OFFSET(-128) |\n\t\t\tBF_PXP_CSC1_COEF0_Y_OFFSET(0),\n\t\t\tBF_PXP_CSC1_COEF1_C1(0x193) |\t \n\t\t\tBF_PXP_CSC1_COEF1_C4(0x1db),\t \n\t\t\tBF_PXP_CSC1_COEF2_C2(0x789) |\t \n\t\t\tBF_PXP_CSC1_COEF2_C3(0x7d1),\t \n\t\t};\n\t\t \n\t\tstatic const u32 csc1_coef_bt2020_lim[3] = {\n\t\t\tBM_PXP_CSC1_COEF0_YCBCR_MODE |\n\t\t\tBF_PXP_CSC1_COEF0_C0(0x12a) |\t \n\t\t\tBF_PXP_CSC1_COEF0_UV_OFFSET(-128) |\n\t\t\tBF_PXP_CSC1_COEF0_Y_OFFSET(-16),\n\t\t\tBF_PXP_CSC1_COEF1_C1(0x1ad) |\t \n\t\t\tBF_PXP_CSC1_COEF1_C4(0x224),\t \n\t\t\tBF_PXP_CSC1_COEF2_C2(0x75a) |\t \n\t\t\tBF_PXP_CSC1_COEF2_C3(0x7d1),\t \n\t\t};\n\t\t \n\t\tstatic const u32 csc1_coef_bt2020_full[3] = {\n\t\t\tBM_PXP_CSC1_COEF0_YCBCR_MODE |\n\t\t\tBF_PXP_CSC1_COEF0_C0(0x100) |\t \n\t\t\tBF_PXP_CSC1_COEF0_UV_OFFSET(-128) |\n\t\t\tBF_PXP_CSC1_COEF0_Y_OFFSET(0),\n\t\t\tBF_PXP_CSC1_COEF1_C1(0x179) |\t \n\t\t\tBF_PXP_CSC1_COEF1_C4(0x1e1),\t \n\t\t\tBF_PXP_CSC1_COEF2_C2(0x76e) |\t \n\t\t\tBF_PXP_CSC1_COEF2_C3(0x7d6),\t \n\t\t};\n\t\t \n\t\tstatic const u32 csc1_coef_smpte240m_lim[3] = {\n\t\t\tBM_PXP_CSC1_COEF0_YCBCR_MODE |\n\t\t\tBF_PXP_CSC1_COEF0_C0(0x12a) |\t \n\t\t\tBF_PXP_CSC1_COEF0_UV_OFFSET(-128) |\n\t\t\tBF_PXP_CSC1_COEF0_Y_OFFSET(-16),\n\t\t\tBF_PXP_CSC1_COEF1_C1(0x1cb) |\t \n\t\t\tBF_PXP_CSC1_COEF1_C4(0x214),\t \n\t\t\tBF_PXP_CSC1_COEF2_C2(0x776) |\t \n\t\t\tBF_PXP_CSC1_COEF2_C3(0x7bf),\t \n\t\t};\n\t\t \n\t\tstatic const u32 csc1_coef_smpte240m_full[3] = {\n\t\t\tBM_PXP_CSC1_COEF0_YCBCR_MODE |\n\t\t\tBF_PXP_CSC1_COEF0_C0(0x100) |\t \n\t\t\tBF_PXP_CSC1_COEF0_UV_OFFSET(-128) |\n\t\t\tBF_PXP_CSC1_COEF0_Y_OFFSET(0),\n\t\t\tBF_PXP_CSC1_COEF1_C1(0x193) |\t \n\t\t\tBF_PXP_CSC1_COEF1_C4(0x1d3),\t \n\t\t\tBF_PXP_CSC1_COEF2_C2(0x786) |\t \n\t\t\tBF_PXP_CSC1_COEF2_C3(0x7c7),\t \n\t\t};\n\t\tconst u32 *csc1_coef;\n\n\t\tycbcr_enc = ctx->q_data[V4L2_M2M_SRC].ycbcr_enc;\n\t\tquantization = ctx->q_data[V4L2_M2M_SRC].quant;\n\n\t\tif (ycbcr_enc == V4L2_YCBCR_ENC_601) {\n\t\t\tif (quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\t\tcsc1_coef = csc1_coef_bt601_full;\n\t\t\telse\n\t\t\t\tcsc1_coef = csc1_coef_bt601_lim;\n\t\t} else if (ycbcr_enc == V4L2_YCBCR_ENC_709) {\n\t\t\tif (quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\t\tcsc1_coef = csc1_coef_rec709_full;\n\t\t\telse\n\t\t\t\tcsc1_coef = csc1_coef_rec709_lim;\n\t\t} else if (ycbcr_enc == V4L2_YCBCR_ENC_BT2020) {\n\t\t\tif (quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\t\tcsc1_coef = csc1_coef_bt2020_full;\n\t\t\telse\n\t\t\t\tcsc1_coef = csc1_coef_bt2020_lim;\n\t\t} else {\n\t\t\tif (quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\t\tcsc1_coef = csc1_coef_smpte240m_full;\n\t\t\telse\n\t\t\t\tcsc1_coef = csc1_coef_smpte240m_lim;\n\t\t}\n\n\t\tpxp_write(dev, HW_PXP_CSC1_COEF0, csc1_coef[0]);\n\t\tpxp_write(dev, HW_PXP_CSC1_COEF1, csc1_coef[1]);\n\t\tpxp_write(dev, HW_PXP_CSC1_COEF2, csc1_coef[2]);\n\t} else {\n\t\tpxp_write(dev, HW_PXP_CSC1_COEF0, BM_PXP_CSC1_COEF0_BYPASS);\n\t}\n\n\tif (!pxp_v4l2_pix_fmt_is_yuv(ctx->q_data[V4L2_M2M_SRC].fmt->fourcc) &&\n\t    pxp_v4l2_pix_fmt_is_yuv(ctx->q_data[V4L2_M2M_DST].fmt->fourcc)) {\n\t\t \n\t\tstatic const u32 csc2_coef_bt601_lim[6] = {\n\t\t\tBF_PXP_CSC2_COEF0_A2(0x081) |\t \n\t\t\tBF_PXP_CSC2_COEF0_A1(0x041),\t \n\t\t\tBF_PXP_CSC2_COEF1_B1(0x7db) |\t \n\t\t\tBF_PXP_CSC2_COEF1_A3(0x019),\t \n\t\t\tBF_PXP_CSC2_COEF2_B3(0x070) |\t \n\t\t\tBF_PXP_CSC2_COEF2_B2(0x7b6),\t \n\t\t\tBF_PXP_CSC2_COEF3_C2(0x7a2) |\t \n\t\t\tBF_PXP_CSC2_COEF3_C1(0x070),\t \n\t\t\tBF_PXP_CSC2_COEF4_D1(16) |\n\t\t\tBF_PXP_CSC2_COEF4_C3(0x7ee),\t \n\t\t\tBF_PXP_CSC2_COEF5_D3(128) |\n\t\t\tBF_PXP_CSC2_COEF5_D2(128),\n\t\t};\n\t\t \n\t\tstatic const u32 csc2_coef_bt601_full[6] = {\n\t\t\tBF_PXP_CSC2_COEF0_A2(0x096) |\t \n\t\t\tBF_PXP_CSC2_COEF0_A1(0x04c),\t \n\t\t\tBF_PXP_CSC2_COEF1_B1(0x7d5) |\t \n\t\t\tBF_PXP_CSC2_COEF1_A3(0x01d),\t \n\t\t\tBF_PXP_CSC2_COEF2_B3(0x080) |\t \n\t\t\tBF_PXP_CSC2_COEF2_B2(0x7ac),\t \n\t\t\tBF_PXP_CSC2_COEF3_C2(0x795) |\t \n\t\t\tBF_PXP_CSC2_COEF3_C1(0x080),\t \n\t\t\tBF_PXP_CSC2_COEF4_D1(0) |\n\t\t\tBF_PXP_CSC2_COEF4_C3(0x7ec),\t \n\t\t\tBF_PXP_CSC2_COEF5_D3(128) |\n\t\t\tBF_PXP_CSC2_COEF5_D2(128),\n\t\t};\n\t\t \n\t\tstatic const u32 csc2_coef_rec709_lim[6] = {\n\t\t\tBF_PXP_CSC2_COEF0_A2(0x09d) |\t \n\t\t\tBF_PXP_CSC2_COEF0_A1(0x02e),\t \n\t\t\tBF_PXP_CSC2_COEF1_B1(0x7e7) |\t \n\t\t\tBF_PXP_CSC2_COEF1_A3(0x00f),\t \n\t\t\tBF_PXP_CSC2_COEF2_B3(0x070) |\t \n\t\t\tBF_PXP_CSC2_COEF2_B2(0x7aa),\t \n\t\t\tBF_PXP_CSC2_COEF3_C2(0x79a) |\t \n\t\t\tBF_PXP_CSC2_COEF3_C1(0x070),\t \n\t\t\tBF_PXP_CSC2_COEF4_D1(16) |\n\t\t\tBF_PXP_CSC2_COEF4_C3(0x7f6),\t \n\t\t\tBF_PXP_CSC2_COEF5_D3(128) |\n\t\t\tBF_PXP_CSC2_COEF5_D2(128),\n\t\t};\n\t\t \n\t\tstatic const u32 csc2_coef_rec709_full[6] = {\n\t\t\tBF_PXP_CSC2_COEF0_A2(0x0b7) |\t \n\t\t\tBF_PXP_CSC2_COEF0_A1(0x036),\t \n\t\t\tBF_PXP_CSC2_COEF1_B1(0x7e3) |\t \n\t\t\tBF_PXP_CSC2_COEF1_A3(0x012),\t \n\t\t\tBF_PXP_CSC2_COEF2_B3(0x080) |\t \n\t\t\tBF_PXP_CSC2_COEF2_B2(0x79e),\t \n\t\t\tBF_PXP_CSC2_COEF3_C2(0x78c) |\t \n\t\t\tBF_PXP_CSC2_COEF3_C1(0x080),\t \n\t\t\tBF_PXP_CSC2_COEF4_D1(0) |\n\t\t\tBF_PXP_CSC2_COEF4_C3(0x7f5),\t \n\t\t\tBF_PXP_CSC2_COEF5_D3(128) |\n\t\t\tBF_PXP_CSC2_COEF5_D2(128),\n\t\t};\n\t\t \n\t\tstatic const u32 csc2_coef_bt2020_lim[6] = {\n\t\t\tBF_PXP_CSC2_COEF0_A2(0x095) |\t \n\t\t\tBF_PXP_CSC2_COEF0_A1(0x039),\t \n\t\t\tBF_PXP_CSC2_COEF1_B1(0x7e1) |\t \n\t\t\tBF_PXP_CSC2_COEF1_A3(0x00d),\t \n\t\t\tBF_PXP_CSC2_COEF2_B3(0x070) |\t \n\t\t\tBF_PXP_CSC2_COEF2_B2(0x7af),\t \n\t\t\tBF_PXP_CSC2_COEF3_C2(0x799) |\t \n\t\t\tBF_PXP_CSC2_COEF3_C1(0x070),\t \n\t\t\tBF_PXP_CSC2_COEF4_D1(16) |\n\t\t\tBF_PXP_CSC2_COEF4_C3(0x7f7),\t \n\t\t\tBF_PXP_CSC2_COEF5_D3(128) |\n\t\t\tBF_PXP_CSC2_COEF5_D2(128),\n\t\t};\n\t\t \n\t\tstatic const u32 csc2_coef_bt2020_full[6] = {\n\t\t\tBF_PXP_CSC2_COEF0_A2(0x0ad) |\t \n\t\t\tBF_PXP_CSC2_COEF0_A1(0x043),\t \n\t\t\tBF_PXP_CSC2_COEF1_B1(0x7dd) |\t \n\t\t\tBF_PXP_CSC2_COEF1_A3(0x00f),\t \n\t\t\tBF_PXP_CSC2_COEF2_B3(0x080) |\t \n\t\t\tBF_PXP_CSC2_COEF2_B2(0x7a4),\t \n\t\t\tBF_PXP_CSC2_COEF3_C2(0x78b) |\t \n\t\t\tBF_PXP_CSC2_COEF3_C1(0x080),\t \n\t\t\tBF_PXP_CSC2_COEF4_D1(0) |\n\t\t\tBF_PXP_CSC2_COEF4_C3(0x7f6),\t \n\t\t\tBF_PXP_CSC2_COEF5_D3(128) |\n\t\t\tBF_PXP_CSC2_COEF5_D2(128),\n\t\t};\n\t\t \n\t\tstatic const u32 csc2_coef_smpte240m_lim[6] = {\n\t\t\tBF_PXP_CSC2_COEF0_A2(0x09a) |\t \n\t\t\tBF_PXP_CSC2_COEF0_A1(0x02e),\t \n\t\t\tBF_PXP_CSC2_COEF1_B1(0x7e6) |\t \n\t\t\tBF_PXP_CSC2_COEF1_A3(0x013),\t \n\t\t\tBF_PXP_CSC2_COEF2_B3(0x070) |\t \n\t\t\tBF_PXP_CSC2_COEF2_B2(0x7aa),\t \n\t\t\tBF_PXP_CSC2_COEF3_C2(0x79c) |\t \n\t\t\tBF_PXP_CSC2_COEF3_C1(0x070),\t \n\t\t\tBF_PXP_CSC2_COEF4_D1(16) |\n\t\t\tBF_PXP_CSC2_COEF4_C3(0x7f4),\t \n\t\t\tBF_PXP_CSC2_COEF5_D3(128) |\n\t\t\tBF_PXP_CSC2_COEF5_D2(128),\n\t\t};\n\t\t \n\t\tstatic const u32 csc2_coef_smpte240m_full[6] = {\n\t\t\tBF_PXP_CSC2_COEF0_A2(0x0b3) |\t \n\t\t\tBF_PXP_CSC2_COEF0_A1(0x036),\t \n\t\t\tBF_PXP_CSC2_COEF1_B1(0x7e3) |\t \n\t\t\tBF_PXP_CSC2_COEF1_A3(0x016),\t \n\t\t\tBF_PXP_CSC2_COEF2_B3(0x080) |\t \n\t\t\tBF_PXP_CSC2_COEF2_B2(0x79e),\t \n\t\t\tBF_PXP_CSC2_COEF3_C2(0x78f) |\t \n\t\t\tBF_PXP_CSC2_COEF3_C1(0x080),\t \n\t\t\tBF_PXP_CSC2_COEF4_D1(0) |\n\t\t\tBF_PXP_CSC2_COEF4_C3(0x7f2),\t \n\t\t\tBF_PXP_CSC2_COEF5_D3(128) |\n\t\t\tBF_PXP_CSC2_COEF5_D2(128),\n\t\t};\n\t\tconst u32 *csc2_coef;\n\t\tu32 csc2_ctrl;\n\n\t\tycbcr_enc = ctx->q_data[V4L2_M2M_DST].ycbcr_enc;\n\t\tquantization = ctx->q_data[V4L2_M2M_DST].quant;\n\n\t\tif (ycbcr_enc == V4L2_YCBCR_ENC_601) {\n\t\t\tif (quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\t\tcsc2_coef = csc2_coef_bt601_full;\n\t\t\telse\n\t\t\t\tcsc2_coef = csc2_coef_bt601_lim;\n\t\t} else if (ycbcr_enc == V4L2_YCBCR_ENC_709) {\n\t\t\tif (quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\t\tcsc2_coef = csc2_coef_rec709_full;\n\t\t\telse\n\t\t\t\tcsc2_coef = csc2_coef_rec709_lim;\n\t\t} else if (ycbcr_enc == V4L2_YCBCR_ENC_BT2020) {\n\t\t\tif (quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\t\tcsc2_coef = csc2_coef_bt2020_full;\n\t\t\telse\n\t\t\t\tcsc2_coef = csc2_coef_bt2020_lim;\n\t\t} else {\n\t\t\tif (quantization == V4L2_QUANTIZATION_FULL_RANGE)\n\t\t\t\tcsc2_coef = csc2_coef_smpte240m_full;\n\t\t\telse\n\t\t\t\tcsc2_coef = csc2_coef_smpte240m_lim;\n\t\t}\n\t\tif (quantization == V4L2_QUANTIZATION_FULL_RANGE) {\n\t\t\tcsc2_ctrl = BV_PXP_CSC2_CTRL_CSC_MODE__RGB2YUV <<\n\t\t\t\t    BP_PXP_CSC2_CTRL_CSC_MODE;\n\t\t} else {\n\t\t\tcsc2_ctrl = BV_PXP_CSC2_CTRL_CSC_MODE__RGB2YCbCr <<\n\t\t\t\t    BP_PXP_CSC2_CTRL_CSC_MODE;\n\t\t}\n\n\t\tpxp_write(dev, HW_PXP_CSC2_CTRL, csc2_ctrl);\n\t\tpxp_write(dev, HW_PXP_CSC2_COEF0, csc2_coef[0]);\n\t\tpxp_write(dev, HW_PXP_CSC2_COEF1, csc2_coef[1]);\n\t\tpxp_write(dev, HW_PXP_CSC2_COEF2, csc2_coef[2]);\n\t\tpxp_write(dev, HW_PXP_CSC2_COEF3, csc2_coef[3]);\n\t\tpxp_write(dev, HW_PXP_CSC2_COEF4, csc2_coef[4]);\n\t\tpxp_write(dev, HW_PXP_CSC2_COEF5, csc2_coef[5]);\n\t} else {\n\t\tpxp_write(dev, HW_PXP_CSC2_CTRL, BM_PXP_CSC2_CTRL_BYPASS);\n\t}\n}\n\nstatic u32 pxp_imx6ull_data_path_ctrl0(struct pxp_ctx *ctx)\n{\n\tu32 ctrl0;\n\n\tctrl0 = 0;\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX15_SEL(3);\n\t \n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX14_SEL(1);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX13_SEL(3);\n\t \n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX12_SEL(0);\n\t \n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX11_SEL(1);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX10_SEL(3);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX9_SEL(3);\n\t \n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX8_SEL(0);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX7_SEL(3);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX6_SEL(3);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX5_SEL(3);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX4_SEL(3);\n\t \n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX3_SEL(0);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX2_SEL(3);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX1_SEL(3);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX0_SEL(3);\n\n\treturn ctrl0;\n}\n\nstatic u32 pxp_imx7d_data_path_ctrl0(struct pxp_ctx *ctx)\n{\n\tu32 ctrl0;\n\n\tctrl0 = 0;\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX15_SEL(3);\n\t \n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX14_SEL(0);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX13_SEL(3);\n\t \n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX12_SEL(1);\n\t \n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX11_SEL(1);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX10_SEL(3);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX9_SEL(3);\n\t \n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX8_SEL(0);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX7_SEL(3);\n\t \n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX6_SEL(1);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX5_SEL(3);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX4_SEL(3);\n\t \n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX3_SEL(0);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX2_SEL(3);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX1_SEL(3);\n\tctrl0 |= BF_PXP_DATA_PATH_CTRL0_MUX0_SEL(3);\n\n\treturn ctrl0;\n}\n\nstatic void pxp_set_data_path(struct pxp_ctx *ctx)\n{\n\tstruct pxp_dev *dev = ctx->dev;\n\tu32 ctrl0;\n\tu32 ctrl1;\n\n\tctrl0 = dev->pdata->data_path_ctrl0(ctx);\n\n\tctrl1 = 0;\n\tctrl1 |= BF_PXP_DATA_PATH_CTRL1_MUX17_SEL(3);\n\tctrl1 |= BF_PXP_DATA_PATH_CTRL1_MUX16_SEL(3);\n\n\tpxp_write(dev, HW_PXP_DATA_PATH_CTRL0, ctrl0);\n\tpxp_write(dev, HW_PXP_DATA_PATH_CTRL1, ctrl1);\n}\n\nstatic int pxp_start(struct pxp_ctx *ctx, struct vb2_v4l2_buffer *in_vb,\n\t\t     struct vb2_v4l2_buffer *out_vb)\n{\n\tstruct pxp_dev *dev = ctx->dev;\n\tstruct pxp_q_data *q_data;\n\tu32 src_width, src_height, src_stride, src_fourcc;\n\tu32 dst_width, dst_height, dst_stride, dst_fourcc;\n\tdma_addr_t p_in, p_out;\n\tu32 ctrl, out_ctrl, out_buf, out_buf2, out_pitch, out_lrc, out_ps_ulc;\n\tu32 out_ps_lrc;\n\tu32 ps_ctrl, ps_buf, ps_ubuf, ps_vbuf, ps_pitch, ps_scale, ps_offset;\n\tu32 as_ulc, as_lrc;\n\tu32 y_size;\n\tu32 decx, decy, xscale, yscale;\n\n\tq_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\n\tsrc_width = ctx->q_data[V4L2_M2M_SRC].width;\n\tdst_width = ctx->q_data[V4L2_M2M_DST].width;\n\tsrc_height = ctx->q_data[V4L2_M2M_SRC].height;\n\tdst_height = ctx->q_data[V4L2_M2M_DST].height;\n\tsrc_stride = ctx->q_data[V4L2_M2M_SRC].bytesperline;\n\tdst_stride = ctx->q_data[V4L2_M2M_DST].bytesperline;\n\tsrc_fourcc = ctx->q_data[V4L2_M2M_SRC].fmt->fourcc;\n\tdst_fourcc = ctx->q_data[V4L2_M2M_DST].fmt->fourcc;\n\n\tp_in = vb2_dma_contig_plane_dma_addr(&in_vb->vb2_buf, 0);\n\tp_out = vb2_dma_contig_plane_dma_addr(&out_vb->vb2_buf, 0);\n\n\tif (!p_in || !p_out) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Acquiring DMA addresses of buffers failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tout_vb->sequence =\n\t\tget_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE)->sequence++;\n\tin_vb->sequence = q_data->sequence++;\n\tout_vb->vb2_buf.timestamp = in_vb->vb2_buf.timestamp;\n\n\tif (in_vb->flags & V4L2_BUF_FLAG_TIMECODE)\n\t\tout_vb->timecode = in_vb->timecode;\n\tout_vb->field = in_vb->field;\n\tout_vb->flags = in_vb->flags &\n\t\t(V4L2_BUF_FLAG_TIMECODE |\n\t\t V4L2_BUF_FLAG_KEYFRAME |\n\t\t V4L2_BUF_FLAG_PFRAME |\n\t\t V4L2_BUF_FLAG_BFRAME |\n\t\t V4L2_BUF_FLAG_TSTAMP_SRC_MASK);\n\n\t \n\tctrl = BF_PXP_CTRL_VFLIP0(!!(ctx->mode & MEM2MEM_VFLIP)) |\n\t       BF_PXP_CTRL_HFLIP0(!!(ctx->mode & MEM2MEM_HFLIP)) |\n\t       BF_PXP_CTRL_ROTATE0(ctx->rotation);\n\t \n\tout_ctrl = BF_PXP_OUT_CTRL_ALPHA(ctx->alpha_component) |\n\t\t   BF_PXP_OUT_CTRL_ALPHA_OUTPUT(1) |\n\t\t   pxp_v4l2_pix_fmt_to_out_format(dst_fourcc);\n\tout_buf = p_out;\n\n\tif (ctx->rotation == BV_PXP_CTRL_ROTATE0__ROT_90 ||\n\t    ctx->rotation == BV_PXP_CTRL_ROTATE0__ROT_270)\n\t\tswap(dst_width, dst_height);\n\n\tswitch (dst_fourcc) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\t\tout_buf2 = out_buf + dst_stride * dst_height;\n\t\tbreak;\n\tdefault:\n\t\tout_buf2 = 0;\n\t}\n\n\tout_pitch = BF_PXP_OUT_PITCH_PITCH(dst_stride);\n\tout_lrc = BF_PXP_OUT_LRC_X(dst_width - 1) |\n\t\t  BF_PXP_OUT_LRC_Y(dst_height - 1);\n\t \n\tout_ps_ulc = BF_PXP_OUT_PS_ULC_X(0) | BF_PXP_OUT_PS_ULC_Y(0);\n\tout_ps_lrc = BF_PXP_OUT_PS_LRC_X(dst_width - 1) |\n\t\t     BF_PXP_OUT_PS_LRC_Y(dst_height - 1);\n\t \n\tas_ulc = BF_PXP_OUT_AS_ULC_X(1) | BF_PXP_OUT_AS_ULC_Y(1);\n\tas_lrc = BF_PXP_OUT_AS_LRC_X(0) | BF_PXP_OUT_AS_LRC_Y(0);\n\n\tdecx = (src_width <= dst_width) ? 0 : ilog2(src_width / dst_width);\n\tdecy = (src_height <= dst_height) ? 0 : ilog2(src_height / dst_height);\n\tps_ctrl = BF_PXP_PS_CTRL_DECX(decx) | BF_PXP_PS_CTRL_DECY(decy) |\n\t\t  pxp_v4l2_pix_fmt_to_ps_format(src_fourcc);\n\tps_buf = p_in;\n\ty_size = src_stride * src_height;\n\tswitch (src_fourcc) {\n\tcase V4L2_PIX_FMT_YUV420:\n\t\tps_ubuf = ps_buf + y_size;\n\t\tps_vbuf = ps_ubuf + y_size / 4;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\tps_ubuf = ps_buf + y_size;\n\t\tps_vbuf = ps_ubuf + y_size / 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\t\tps_ubuf = ps_buf + y_size;\n\t\tps_vbuf = 0;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_GREY:\n\tcase V4L2_PIX_FMT_Y4:\n\t\tps_ubuf = 0;\n\t\t \n\t\tps_vbuf = 0x8080;\n\t\tbreak;\n\tdefault:\n\t\tps_ubuf = 0;\n\t\tps_vbuf = 0;\n\t\tbreak;\n\t}\n\tps_pitch = BF_PXP_PS_PITCH_PITCH(src_stride);\n\tif (decx) {\n\t\txscale = (src_width >> decx) * 0x1000 / dst_width;\n\t} else {\n\t\tswitch (src_fourcc) {\n\t\tcase V4L2_PIX_FMT_UYVY:\n\t\tcase V4L2_PIX_FMT_YUYV:\n\t\tcase V4L2_PIX_FMT_VYUY:\n\t\tcase V4L2_PIX_FMT_YVYU:\n\t\tcase V4L2_PIX_FMT_NV16:\n\t\tcase V4L2_PIX_FMT_NV12:\n\t\tcase V4L2_PIX_FMT_NV21:\n\t\tcase V4L2_PIX_FMT_NV61:\n\t\tcase V4L2_PIX_FMT_YUV422P:\n\t\tcase V4L2_PIX_FMT_YUV420:\n\t\t\t \n\t\t\txscale = (src_width - 2) * 0x1000 / (dst_width - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txscale = (src_width - 1) * 0x1000 / (dst_width - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (decy)\n\t\tyscale = (src_height >> decy) * 0x1000 / dst_height;\n\telse\n\t\tyscale = (src_height - 1) * 0x1000 / (dst_height - 1);\n\tps_scale = BF_PXP_PS_SCALE_YSCALE(yscale) |\n\t\t   BF_PXP_PS_SCALE_XSCALE(xscale);\n\tps_offset = BF_PXP_PS_OFFSET_YOFFSET(0) | BF_PXP_PS_OFFSET_XOFFSET(0);\n\n\tpxp_write(dev, HW_PXP_CTRL, ctrl);\n\t \n\tpxp_write(dev, HW_PXP_OUT_CTRL, out_ctrl);\n\tpxp_write(dev, HW_PXP_OUT_BUF, out_buf);\n\tpxp_write(dev, HW_PXP_OUT_BUF2, out_buf2);\n\tpxp_write(dev, HW_PXP_OUT_PITCH, out_pitch);\n\tpxp_write(dev, HW_PXP_OUT_LRC, out_lrc);\n\tpxp_write(dev, HW_PXP_OUT_PS_ULC, out_ps_ulc);\n\tpxp_write(dev, HW_PXP_OUT_PS_LRC, out_ps_lrc);\n\tpxp_write(dev, HW_PXP_OUT_AS_ULC, as_ulc);\n\tpxp_write(dev, HW_PXP_OUT_AS_LRC, as_lrc);\n\tpxp_write(dev, HW_PXP_PS_CTRL, ps_ctrl);\n\tpxp_write(dev, HW_PXP_PS_BUF, ps_buf);\n\tpxp_write(dev, HW_PXP_PS_UBUF, ps_ubuf);\n\tpxp_write(dev, HW_PXP_PS_VBUF, ps_vbuf);\n\tpxp_write(dev, HW_PXP_PS_PITCH, ps_pitch);\n\tpxp_write(dev, HW_PXP_PS_BACKGROUND_0, 0x00ffffff);\n\tpxp_write(dev, HW_PXP_PS_SCALE, ps_scale);\n\tpxp_write(dev, HW_PXP_PS_OFFSET, ps_offset);\n\t \n\tpxp_write(dev, HW_PXP_PS_CLRKEYLOW_0, 0x00ffffff);\n\tpxp_write(dev, HW_PXP_PS_CLRKEYHIGH_0, 0x00000000);\n\n\t \n\tpxp_write(dev, HW_PXP_AS_CLRKEYLOW_0, 0x00ffffff);\n\tpxp_write(dev, HW_PXP_AS_CLRKEYHIGH_0, 0x00000000);\n\n\t \n\tpxp_setup_csc(ctx);\n\n\t \n\tpxp_write(dev, HW_PXP_LUT_CTRL, BM_PXP_LUT_CTRL_BYPASS);\n\n\tpxp_set_data_path(ctx);\n\n\tpxp_write(dev, HW_PXP_IRQ_MASK, 0xffff);\n\n\t \n\tpxp_write(dev, HW_PXP_CTRL_SET, BM_PXP_CTRL_IRQ_ENABLE);\n\tpxp_write(dev, HW_PXP_CTRL_SET,\n\t\t  BM_PXP_CTRL_ENABLE | BM_PXP_CTRL_ENABLE_CSC2 |\n\t\t  BM_PXP_CTRL_ENABLE_ROTATE0 | BM_PXP_CTRL_ENABLE_PS_AS_OUT);\n\n\treturn 0;\n}\n\nstatic void pxp_job_finish(struct pxp_dev *dev)\n{\n\tstruct pxp_ctx *curr_ctx;\n\tstruct vb2_v4l2_buffer *src_vb, *dst_vb;\n\tunsigned long flags;\n\n\tcurr_ctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);\n\n\tif (curr_ctx == NULL) {\n\t\tpr_err(\"Instance released before the end of transaction\\n\");\n\t\treturn;\n\t}\n\n\tsrc_vb = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\n\tdst_vb = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\n\n\tspin_lock_irqsave(&dev->irqlock, flags);\n\tv4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_DONE);\n\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\n\tdprintk(curr_ctx->dev, \"Finishing transaction\\n\");\n\tv4l2_m2m_job_finish(dev->m2m_dev, curr_ctx->fh.m2m_ctx);\n}\n\n \nstatic void pxp_device_run(void *priv)\n{\n\tstruct pxp_ctx *ctx = priv;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\tpxp_start(ctx, src_buf, dst_buf);\n}\n\nstatic int pxp_job_ready(void *priv)\n{\n\tstruct pxp_ctx *ctx = priv;\n\n\tif (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) < 1 ||\n\t    v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) < 1) {\n\t\tdprintk(ctx->dev, \"Not enough buffers available\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void pxp_job_abort(void *priv)\n{\n\tstruct pxp_ctx *ctx = priv;\n\n\t \n\tctx->aborting = 1;\n}\n\n \nstatic irqreturn_t pxp_irq_handler(int irq, void *dev_id)\n{\n\tstruct pxp_dev *dev = dev_id;\n\tu32 stat;\n\n\tstat = pxp_read(dev, HW_PXP_STAT);\n\n\tif (stat & BM_PXP_STAT_IRQ0) {\n\t\t \n\t\tif (stat & ~(BM_PXP_STAT_BLOCKX | BM_PXP_STAT_BLOCKY |\n\t\t\t     BM_PXP_STAT_IRQ0))\n\t\t\tdprintk(dev, \"%s: stat = 0x%08x\\n\", __func__, stat);\n\t\tpxp_write(dev, HW_PXP_STAT_CLR, BM_PXP_STAT_IRQ0);\n\n\t\tpxp_job_finish(dev);\n\t} else {\n\t\tu32 irq = pxp_read(dev, HW_PXP_IRQ);\n\n\t\tdprintk(dev, \"%s: stat = 0x%08x\\n\", __func__, stat);\n\t\tdprintk(dev, \"%s: irq = 0x%08x\\n\", __func__, irq);\n\n\t\tpxp_write(dev, HW_PXP_IRQ_CLR, irq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int pxp_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, MEM2MEM_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, MEM2MEM_NAME, sizeof(cap->card));\n\treturn 0;\n}\n\nstatic int pxp_enum_fmt(struct v4l2_fmtdesc *f, u32 type)\n{\n\tint i, num;\n\tstruct pxp_fmt *fmt;\n\n\tnum = 0;\n\n\tfor (i = 0; i < NUM_FORMATS; ++i) {\n\t\tif (formats[i].types & type) {\n\t\t\t \n\t\t\tif (num == f->index)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\t++num;\n\t\t}\n\t}\n\n\tif (i < NUM_FORMATS) {\n\t\t \n\t\tfmt = &formats[i];\n\t\tf->pixelformat = fmt->fourcc;\n\t\treturn 0;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\nstatic int pxp_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\treturn pxp_enum_fmt(f, MEM2MEM_CAPTURE);\n}\n\nstatic int pxp_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\treturn pxp_enum_fmt(f, MEM2MEM_OUTPUT);\n}\n\nstatic int pxp_g_fmt(struct pxp_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct pxp_q_data *q_data;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, f->type);\n\n\tf->fmt.pix.width\t= q_data->width;\n\tf->fmt.pix.height\t= q_data->height;\n\tf->fmt.pix.field\t= V4L2_FIELD_NONE;\n\tf->fmt.pix.pixelformat\t= q_data->fmt->fourcc;\n\tf->fmt.pix.bytesperline\t= q_data->bytesperline;\n\tf->fmt.pix.sizeimage\t= q_data->sizeimage;\n\tf->fmt.pix.colorspace\t= ctx->colorspace;\n\tf->fmt.pix.xfer_func\t= ctx->xfer_func;\n\tf->fmt.pix.ycbcr_enc\t= q_data->ycbcr_enc;\n\tf->fmt.pix.quantization\t= q_data->quant;\n\n\treturn 0;\n}\n\nstatic int pxp_g_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\treturn pxp_g_fmt(file2ctx(file), f);\n}\n\nstatic int pxp_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\treturn pxp_g_fmt(file2ctx(file), f);\n}\n\nstatic inline u32 pxp_bytesperline(struct pxp_fmt *fmt, u32 width)\n{\n\tswitch (fmt->fourcc) {\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV21:\n\tcase V4L2_PIX_FMT_YUV422P:\n\tcase V4L2_PIX_FMT_NV16:\n\tcase V4L2_PIX_FMT_NV61:\n\t\treturn width;\n\tdefault:\n\t\treturn (width * fmt->depth) >> 3;\n\t}\n}\n\nstatic inline u32 pxp_sizeimage(struct pxp_fmt *fmt, u32 width, u32 height)\n{\n\treturn (fmt->depth * width * height) >> 3;\n}\n\nstatic int pxp_try_fmt(struct v4l2_format *f, struct pxp_fmt *fmt)\n{\n\tv4l_bound_align_image(&f->fmt.pix.width, MIN_W, MAX_W, ALIGN_W,\n\t\t\t      &f->fmt.pix.height, MIN_H, MAX_H, ALIGN_H, 0);\n\n\tf->fmt.pix.bytesperline = pxp_bytesperline(fmt, f->fmt.pix.width);\n\tf->fmt.pix.sizeimage = pxp_sizeimage(fmt, f->fmt.pix.width,\n\t\t\t\t\t     f->fmt.pix.height);\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic void\npxp_fixup_colorimetry_cap(struct pxp_ctx *ctx, u32 dst_fourcc,\n\t\t\t  enum v4l2_ycbcr_encoding *ycbcr_enc,\n\t\t\t  enum v4l2_quantization *quantization)\n{\n\tbool dst_is_yuv = pxp_v4l2_pix_fmt_is_yuv(dst_fourcc);\n\n\tif (pxp_v4l2_pix_fmt_is_yuv(ctx->q_data[V4L2_M2M_SRC].fmt->fourcc) ==\n\t    dst_is_yuv) {\n\t\t \n\t\t*ycbcr_enc = ctx->q_data[V4L2_M2M_SRC].ycbcr_enc;\n\t\t*quantization = ctx->q_data[V4L2_M2M_SRC].quant;\n\t} else {\n\t\t*ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(ctx->colorspace);\n\t\t*quantization = V4L2_MAP_QUANTIZATION_DEFAULT(!dst_is_yuv,\n\t\t\t\t\t\t\t      ctx->colorspace,\n\t\t\t\t\t\t\t      *ycbcr_enc);\n\t}\n}\n\nstatic int pxp_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct pxp_fmt *fmt;\n\tstruct pxp_ctx *ctx = file2ctx(file);\n\n\tfmt = find_format(f->fmt.pix.pixelformat);\n\tif (!fmt) {\n\t\tf->fmt.pix.pixelformat = formats[0].fourcc;\n\t\tfmt = find_format(f->fmt.pix.pixelformat);\n\t}\n\tif (!(fmt->types & MEM2MEM_CAPTURE)) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"Fourcc format (0x%08x) invalid.\\n\",\n\t\t\t f->fmt.pix.pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\tf->fmt.pix.colorspace = ctx->colorspace;\n\tf->fmt.pix.xfer_func = ctx->xfer_func;\n\n\tpxp_fixup_colorimetry_cap(ctx, fmt->fourcc,\n\t\t\t\t  &f->fmt.pix.ycbcr_enc,\n\t\t\t\t  &f->fmt.pix.quantization);\n\n\treturn pxp_try_fmt(f, fmt);\n}\n\nstatic int pxp_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct pxp_fmt *fmt;\n\tstruct pxp_ctx *ctx = file2ctx(file);\n\n\tfmt = find_format(f->fmt.pix.pixelformat);\n\tif (!fmt) {\n\t\tf->fmt.pix.pixelformat = formats[0].fourcc;\n\t\tfmt = find_format(f->fmt.pix.pixelformat);\n\t}\n\tif (!(fmt->types & MEM2MEM_OUTPUT)) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"Fourcc format (0x%08x) invalid.\\n\",\n\t\t\t f->fmt.pix.pixelformat);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!f->fmt.pix.colorspace)\n\t\tf->fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\n\n\treturn pxp_try_fmt(f, fmt);\n}\n\nstatic int pxp_s_fmt(struct pxp_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct pxp_q_data *q_data;\n\tstruct vb2_queue *vq;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, f->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"%s queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tq_data->fmt\t\t= find_format(f->fmt.pix.pixelformat);\n\tq_data->width\t\t= f->fmt.pix.width;\n\tq_data->height\t\t= f->fmt.pix.height;\n\tq_data->bytesperline\t= f->fmt.pix.bytesperline;\n\tq_data->sizeimage\t= f->fmt.pix.sizeimage;\n\n\tdprintk(ctx->dev,\n\t\t\"Setting format for type %d, wxh: %dx%d, fmt: %d\\n\",\n\t\tf->type, q_data->width, q_data->height, q_data->fmt->fourcc);\n\n\treturn 0;\n}\n\nstatic int pxp_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct pxp_ctx *ctx = file2ctx(file);\n\tint ret;\n\n\tret = pxp_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pxp_s_fmt(file2ctx(file), f);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->q_data[V4L2_M2M_DST].ycbcr_enc = f->fmt.pix.ycbcr_enc;\n\tctx->q_data[V4L2_M2M_DST].quant = f->fmt.pix.quantization;\n\n\treturn 0;\n}\n\nstatic int pxp_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t     struct v4l2_format *f)\n{\n\tstruct pxp_ctx *ctx = file2ctx(file);\n\tint ret;\n\n\tret = pxp_try_fmt_vid_out(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pxp_s_fmt(file2ctx(file), f);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->colorspace = f->fmt.pix.colorspace;\n\tctx->xfer_func = f->fmt.pix.xfer_func;\n\tctx->q_data[V4L2_M2M_SRC].ycbcr_enc = f->fmt.pix.ycbcr_enc;\n\tctx->q_data[V4L2_M2M_SRC].quant = f->fmt.pix.quantization;\n\n\tpxp_fixup_colorimetry_cap(ctx, ctx->q_data[V4L2_M2M_DST].fmt->fourcc,\n\t\t\t\t  &ctx->q_data[V4L2_M2M_DST].ycbcr_enc,\n\t\t\t\t  &ctx->q_data[V4L2_M2M_DST].quant);\n\n\treturn 0;\n}\n\nstatic int pxp_enum_framesizes(struct file *file, void *fh,\n\t\t\t       struct v4l2_frmsizeenum *fsize)\n{\n\tif (fsize->index > 0)\n\t\treturn -EINVAL;\n\n\tif (!find_format(fsize->pixel_format))\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise.min_width = MIN_W;\n\tfsize->stepwise.max_width = MAX_W;\n\tfsize->stepwise.step_width = 1 << ALIGN_W;\n\tfsize->stepwise.min_height = MIN_H;\n\tfsize->stepwise.max_height = MAX_H;\n\tfsize->stepwise.step_height = 1 << ALIGN_H;\n\n\treturn 0;\n}\n\nstatic u8 pxp_degrees_to_rot_mode(u32 degrees)\n{\n\tswitch (degrees) {\n\tcase 90:\n\t\treturn BV_PXP_CTRL_ROTATE0__ROT_90;\n\tcase 180:\n\t\treturn BV_PXP_CTRL_ROTATE0__ROT_180;\n\tcase 270:\n\t\treturn BV_PXP_CTRL_ROTATE0__ROT_270;\n\tcase 0:\n\tdefault:\n\t\treturn BV_PXP_CTRL_ROTATE0__ROT_0;\n\t}\n}\n\nstatic int pxp_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct pxp_ctx *ctx =\n\t\tcontainer_of(ctrl->handler, struct pxp_ctx, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tif (ctrl->val)\n\t\t\tctx->mode |= MEM2MEM_HFLIP;\n\t\telse\n\t\t\tctx->mode &= ~MEM2MEM_HFLIP;\n\t\tbreak;\n\n\tcase V4L2_CID_VFLIP:\n\t\tif (ctrl->val)\n\t\t\tctx->mode |= MEM2MEM_VFLIP;\n\t\telse\n\t\t\tctx->mode &= ~MEM2MEM_VFLIP;\n\t\tbreak;\n\n\tcase V4L2_CID_ROTATE:\n\t\tctx->rotation = pxp_degrees_to_rot_mode(ctrl->val);\n\t\tbreak;\n\n\tcase V4L2_CID_ALPHA_COMPONENT:\n\t\tctx->alpha_component = ctrl->val;\n\t\tbreak;\n\n\tdefault:\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"Invalid control\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops pxp_ctrl_ops = {\n\t.s_ctrl = pxp_s_ctrl,\n};\n\nstatic const struct v4l2_ioctl_ops pxp_ioctl_ops = {\n\t.vidioc_querycap\t= pxp_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = pxp_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t= pxp_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t= pxp_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t= pxp_s_fmt_vid_cap,\n\n\t.vidioc_enum_fmt_vid_out = pxp_enum_fmt_vid_out,\n\t.vidioc_g_fmt_vid_out\t= pxp_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out\t= pxp_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t= pxp_s_fmt_vid_out,\n\n\t.vidioc_enum_framesizes\t= pxp_enum_framesizes,\n\n\t.vidioc_reqbufs\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf\t\t= v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_streamon\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n \nstatic int pxp_queue_setup(struct vb2_queue *vq,\n\t\t\t   unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct pxp_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct pxp_q_data *q_data;\n\tunsigned int size, count = *nbuffers;\n\n\tq_data = get_q_data(ctx, vq->type);\n\n\tsize = q_data->sizeimage;\n\n\t*nbuffers = count;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\tdprintk(ctx->dev, \"get %d buffer(s) of size %d each.\\n\", count, size);\n\n\treturn 0;\n}\n\nstatic int pxp_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct pxp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct pxp_dev *dev = ctx->dev;\n\tstruct pxp_q_data *q_data;\n\n\tdprintk(ctx->dev, \"type: %d\\n\", vb->vb2_queue->type);\n\n\tq_data = get_q_data(ctx, vb->vb2_queue->type);\n\tif (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\n\t\tif (vbuf->field == V4L2_FIELD_ANY)\n\t\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tif (vbuf->field != V4L2_FIELD_NONE) {\n\t\t\tdprintk(dev, \"%s field isn't supported\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (vb2_plane_size(vb, 0) < q_data->sizeimage) {\n\t\tdprintk(dev, \"%s data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t__func__, vb2_plane_size(vb, 0),\n\t\t\t(long)q_data->sizeimage);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, q_data->sizeimage);\n\n\treturn 0;\n}\n\nstatic void pxp_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct pxp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int pxp_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct pxp_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct pxp_q_data *q_data = get_q_data(ctx, q->type);\n\n\tq_data->sequence = 0;\n\treturn 0;\n}\n\nstatic void pxp_stop_streaming(struct vb2_queue *q)\n{\n\tstruct pxp_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf;\n\tunsigned long flags;\n\n\tfor (;;) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (vbuf == NULL)\n\t\t\treturn;\n\t\tspin_lock_irqsave(&ctx->dev->irqlock, flags);\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t\tspin_unlock_irqrestore(&ctx->dev->irqlock, flags);\n\t}\n}\n\nstatic const struct vb2_ops pxp_qops = {\n\t.queue_setup\t = pxp_queue_setup,\n\t.buf_prepare\t = pxp_buf_prepare,\n\t.buf_queue\t = pxp_buf_queue,\n\t.start_streaming = pxp_start_streaming,\n\t.stop_streaming  = pxp_stop_streaming,\n\t.wait_prepare\t = vb2_ops_wait_prepare,\n\t.wait_finish\t = vb2_ops_wait_finish,\n};\n\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t      struct vb2_queue *dst_vq)\n{\n\tstruct pxp_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->ops = &pxp_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->dev->dev_mutex;\n\tsrc_vq->dev = ctx->dev->v4l2_dev.dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops = &pxp_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->dev->dev_mutex;\n\tdst_vq->dev = ctx->dev->v4l2_dev.dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\n \nstatic int pxp_open(struct file *file)\n{\n\tstruct pxp_dev *dev = video_drvdata(file);\n\tstruct pxp_ctx *ctx = NULL;\n\tstruct v4l2_ctrl_handler *hdl;\n\tint rc = 0;\n\n\tif (mutex_lock_interruptible(&dev->dev_mutex))\n\t\treturn -ERESTARTSYS;\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto open_unlock;\n\t}\n\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tctx->dev = dev;\n\thdl = &ctx->hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tv4l2_ctrl_new_std(hdl, &pxp_ctrl_ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &pxp_ctrl_ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &pxp_ctrl_ops, V4L2_CID_ROTATE, 0, 270, 90, 0);\n\tv4l2_ctrl_new_std(hdl, &pxp_ctrl_ops, V4L2_CID_ALPHA_COMPONENT,\n\t\t\t  0, 255, 1, 255);\n\tif (hdl->error) {\n\t\trc = hdl->error;\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tkfree(ctx);\n\t\tgoto open_unlock;\n\t}\n\tctx->fh.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_setup(hdl);\n\n\tctx->q_data[V4L2_M2M_SRC].fmt = &formats[0];\n\tctx->q_data[V4L2_M2M_SRC].width = 640;\n\tctx->q_data[V4L2_M2M_SRC].height = 480;\n\tctx->q_data[V4L2_M2M_SRC].bytesperline =\n\t\tpxp_bytesperline(&formats[0], 640);\n\tctx->q_data[V4L2_M2M_SRC].sizeimage =\n\t\tpxp_sizeimage(&formats[0], 640, 480);\n\tctx->q_data[V4L2_M2M_DST] = ctx->q_data[V4L2_M2M_SRC];\n\tctx->colorspace = V4L2_COLORSPACE_REC709;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx, &queue_init);\n\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\trc = PTR_ERR(ctx->fh.m2m_ctx);\n\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tv4l2_fh_exit(&ctx->fh);\n\t\tkfree(ctx);\n\t\tgoto open_unlock;\n\t}\n\n\tv4l2_fh_add(&ctx->fh);\n\tatomic_inc(&dev->num_inst);\n\n\tdprintk(dev, \"Created instance: %p, m2m_ctx: %p\\n\",\n\t\tctx, ctx->fh.m2m_ctx);\n\nopen_unlock:\n\tmutex_unlock(&dev->dev_mutex);\n\treturn rc;\n}\n\nstatic int pxp_release(struct file *file)\n{\n\tstruct pxp_dev *dev = video_drvdata(file);\n\tstruct pxp_ctx *ctx = file2ctx(file);\n\n\tdprintk(dev, \"Releasing instance %p\\n\", ctx);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_ctrl_handler_free(&ctx->hdl);\n\tmutex_lock(&dev->dev_mutex);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tmutex_unlock(&dev->dev_mutex);\n\tkfree(ctx);\n\n\tatomic_dec(&dev->num_inst);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations pxp_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= pxp_open,\n\t.release\t= pxp_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct video_device pxp_videodev = {\n\t.name\t\t= MEM2MEM_NAME,\n\t.vfl_dir\t= VFL_DIR_M2M,\n\t.fops\t\t= &pxp_fops,\n\t.device_caps\t= V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING,\n\t.ioctl_ops\t= &pxp_ioctl_ops,\n\t.minor\t\t= -1,\n\t.release\t= video_device_release_empty,\n};\n\nstatic const struct v4l2_m2m_ops m2m_ops = {\n\t.device_run\t= pxp_device_run,\n\t.job_ready\t= pxp_job_ready,\n\t.job_abort\t= pxp_job_abort,\n};\n\nstatic int pxp_soft_reset(struct pxp_dev *dev)\n{\n\tint ret;\n\tu32 val;\n\n\tpxp_write(dev, HW_PXP_CTRL_CLR, BM_PXP_CTRL_SFTRST);\n\tpxp_write(dev, HW_PXP_CTRL_CLR, BM_PXP_CTRL_CLKGATE);\n\n\tpxp_write(dev, HW_PXP_CTRL_SET, BM_PXP_CTRL_SFTRST);\n\n\tret = regmap_read_poll_timeout(dev->regmap, HW_PXP_CTRL, val,\n\t\t\t\t       val & BM_PXP_CTRL_CLKGATE, 0, 100);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpxp_write(dev, HW_PXP_CTRL_CLR, BM_PXP_CTRL_SFTRST);\n\tpxp_write(dev, HW_PXP_CTRL_CLR, BM_PXP_CTRL_CLKGATE);\n\n\treturn 0;\n}\n\nstatic int pxp_probe(struct platform_device *pdev)\n{\n\tstruct pxp_dev *dev;\n\tstruct video_device *vfd;\n\tu32 hw_version;\n\tint irq;\n\tint ret;\n\tvoid __iomem *mmio;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->pdata = of_device_get_match_data(&pdev->dev);\n\n\tdev->clk = devm_clk_get(&pdev->dev, \"axi\");\n\tif (IS_ERR(dev->clk)) {\n\t\tret = PTR_ERR(dev->clk);\n\t\tdev_err(&pdev->dev, \"Failed to get clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mmio))\n\t\treturn PTR_ERR(mmio);\n\tdev->regmap = devm_regmap_init_mmio(&pdev->dev, mmio,\n\t\t\t\t\t    &pxp_regmap_config);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tspin_lock_init(&dev->irqlock);\n\n\tret = devm_request_irq(&pdev->dev, irq, pxp_irq_handler, 0,\n\t\t\t       dev_name(&pdev->dev), dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(dev->clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pxp_soft_reset(dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"PXP reset timeout: %d\\n\", ret);\n\t\tgoto err_clk;\n\t}\n\n\thw_version = pxp_read(dev, HW_PXP_VERSION);\n\tdev_dbg(&pdev->dev, \"PXP Version %u.%u\\n\",\n\t\tPXP_VERSION_MAJOR(hw_version), PXP_VERSION_MINOR(hw_version));\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret)\n\t\tgoto err_clk;\n\n\tatomic_set(&dev->num_inst, 0);\n\tmutex_init(&dev->dev_mutex);\n\n\tdev->vfd = pxp_videodev;\n\tvfd = &dev->vfd;\n\tvfd->lock = &dev->dev_mutex;\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\n\tvideo_set_drvdata(vfd, dev);\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s\", pxp_videodev.name);\n\tv4l2_info(&dev->v4l2_dev,\n\t\t\t\"Device registered as /dev/video%d\\n\", vfd->num);\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev->m2m_dev = v4l2_m2m_init(&m2m_ops);\n\tif (IS_ERR(dev->m2m_dev)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(dev->m2m_dev);\n\t\tgoto err_v4l2;\n\t}\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto err_m2m;\n\t}\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tdev->mdev.dev = &pdev->dev;\n\tstrscpy(dev->mdev.model, MEM2MEM_NAME, sizeof(dev->mdev.model));\n\tmedia_device_init(&dev->mdev);\n\tdev->v4l2_dev.mdev = &dev->mdev;\n\n\tret = v4l2_m2m_register_media_controller(dev->m2m_dev, vfd,\n\t\t\t\t\t\t MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize media device\\n\");\n\t\tgoto err_vfd;\n\t}\n\n\tret = media_device_register(&dev->mdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register media device\\n\");\n\t\tgoto err_m2m_mc;\n\t}\n#endif\n\n\treturn 0;\n\n#ifdef CONFIG_MEDIA_CONTROLLER\nerr_m2m_mc:\n\tv4l2_m2m_unregister_media_controller(dev->m2m_dev);\nerr_vfd:\n\tvideo_unregister_device(vfd);\n#endif\nerr_m2m:\n\tv4l2_m2m_release(dev->m2m_dev);\nerr_v4l2:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nerr_clk:\n\tclk_disable_unprepare(dev->clk);\n\n\treturn ret;\n}\n\nstatic void pxp_remove(struct platform_device *pdev)\n{\n\tstruct pxp_dev *dev = platform_get_drvdata(pdev);\n\n\tpxp_write(dev, HW_PXP_CTRL_SET, BM_PXP_CTRL_CLKGATE);\n\tpxp_write(dev, HW_PXP_CTRL_SET, BM_PXP_CTRL_SFTRST);\n\n\tclk_disable_unprepare(dev->clk);\n\n\tv4l2_info(&dev->v4l2_dev, \"Removing \" MEM2MEM_NAME);\n\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tmedia_device_unregister(&dev->mdev);\n\tv4l2_m2m_unregister_media_controller(dev->m2m_dev);\n#endif\n\tvideo_unregister_device(&dev->vfd);\n\tv4l2_m2m_release(dev->m2m_dev);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n}\n\nstatic const struct pxp_pdata pxp_imx6ull_pdata = {\n\t.data_path_ctrl0 = pxp_imx6ull_data_path_ctrl0,\n};\n\nstatic const struct pxp_pdata pxp_imx7d_pdata = {\n\t.data_path_ctrl0 = pxp_imx7d_data_path_ctrl0,\n};\n\nstatic const struct of_device_id pxp_dt_ids[] = {\n\t{ .compatible = \"fsl,imx6ull-pxp\", .data = &pxp_imx6ull_pdata },\n\t{ .compatible = \"fsl,imx7d-pxp\", .data = &pxp_imx7d_pdata },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pxp_dt_ids);\n\nstatic struct platform_driver pxp_driver = {\n\t.probe\t\t= pxp_probe,\n\t.remove_new\t= pxp_remove,\n\t.driver\t\t= {\n\t\t.name\t= MEM2MEM_NAME,\n\t\t.of_match_table = pxp_dt_ids,\n\t},\n};\n\nmodule_platform_driver(pxp_driver);\n\nMODULE_DESCRIPTION(\"i.MX PXP mem2mem scaler/CSC/rotator\");\nMODULE_AUTHOR(\"Philipp Zabel <kernel@pengutronix.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}