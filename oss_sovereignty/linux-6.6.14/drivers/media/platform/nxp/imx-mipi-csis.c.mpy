{
  "module_name": "imx-mipi-csis.c",
  "hash_id": "31667292ebf1f6488ec82cbe0ab18007da7cf255c1f27873c27b3d3e71fcaff5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/imx-mipi-csis.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n\n#define CSIS_DRIVER_NAME\t\t\t\"imx-mipi-csis\"\n\n#define CSIS_PAD_SINK\t\t\t\t0\n#define CSIS_PAD_SOURCE\t\t\t\t1\n#define CSIS_PADS_NUM\t\t\t\t2\n\n#define MIPI_CSIS_DEF_PIX_WIDTH\t\t\t640\n#define MIPI_CSIS_DEF_PIX_HEIGHT\t\t480\n\n \n\n \n#define MIPI_CSIS_VERSION\t\t\t0x00\n#define MIPI_CSIS_VERSION_IMX7D\t\t\t0x03030505\n#define MIPI_CSIS_VERSION_IMX8MP\t\t0x03060301\n\n \n#define MIPI_CSIS_CMN_CTRL\t\t\t0x04\n#define MIPI_CSIS_CMN_CTRL_UPDATE_SHADOW\tBIT(16)\n#define MIPI_CSIS_CMN_CTRL_INTER_MODE\t\tBIT(10)\n#define MIPI_CSIS_CMN_CTRL_UPDATE_SHADOW_CTRL\tBIT(2)\n#define MIPI_CSIS_CMN_CTRL_RESET\t\tBIT(1)\n#define MIPI_CSIS_CMN_CTRL_ENABLE\t\tBIT(0)\n\n#define MIPI_CSIS_CMN_CTRL_LANE_NR_OFFSET\t8\n#define MIPI_CSIS_CMN_CTRL_LANE_NR_MASK\t\t(3 << 8)\n\n \n#define MIPI_CSIS_CLK_CTRL\t\t\t0x08\n#define MIPI_CSIS_CLK_CTRL_CLKGATE_TRAIL_CH3(x)\t((x) << 28)\n#define MIPI_CSIS_CLK_CTRL_CLKGATE_TRAIL_CH2(x)\t((x) << 24)\n#define MIPI_CSIS_CLK_CTRL_CLKGATE_TRAIL_CH1(x)\t((x) << 20)\n#define MIPI_CSIS_CLK_CTRL_CLKGATE_TRAIL_CH0(x)\t((x) << 16)\n#define MIPI_CSIS_CLK_CTRL_CLKGATE_EN_MSK\t(0xf << 4)\n#define MIPI_CSIS_CLK_CTRL_WCLK_SRC\t\tBIT(0)\n\n \n#define MIPI_CSIS_INT_MSK\t\t\t0x10\n#define MIPI_CSIS_INT_MSK_EVEN_BEFORE\t\tBIT(31)\n#define MIPI_CSIS_INT_MSK_EVEN_AFTER\t\tBIT(30)\n#define MIPI_CSIS_INT_MSK_ODD_BEFORE\t\tBIT(29)\n#define MIPI_CSIS_INT_MSK_ODD_AFTER\t\tBIT(28)\n#define MIPI_CSIS_INT_MSK_FRAME_START\t\tBIT(24)\n#define MIPI_CSIS_INT_MSK_FRAME_END\t\tBIT(20)\n#define MIPI_CSIS_INT_MSK_ERR_SOT_HS\t\tBIT(16)\n#define MIPI_CSIS_INT_MSK_ERR_LOST_FS\t\tBIT(12)\n#define MIPI_CSIS_INT_MSK_ERR_LOST_FE\t\tBIT(8)\n#define MIPI_CSIS_INT_MSK_ERR_OVER\t\tBIT(4)\n#define MIPI_CSIS_INT_MSK_ERR_WRONG_CFG\t\tBIT(3)\n#define MIPI_CSIS_INT_MSK_ERR_ECC\t\tBIT(2)\n#define MIPI_CSIS_INT_MSK_ERR_CRC\t\tBIT(1)\n#define MIPI_CSIS_INT_MSK_ERR_UNKNOWN\t\tBIT(0)\n\n \n#define MIPI_CSIS_INT_SRC\t\t\t0x14\n#define MIPI_CSIS_INT_SRC_EVEN_BEFORE\t\tBIT(31)\n#define MIPI_CSIS_INT_SRC_EVEN_AFTER\t\tBIT(30)\n#define MIPI_CSIS_INT_SRC_EVEN\t\t\tBIT(30)\n#define MIPI_CSIS_INT_SRC_ODD_BEFORE\t\tBIT(29)\n#define MIPI_CSIS_INT_SRC_ODD_AFTER\t\tBIT(28)\n#define MIPI_CSIS_INT_SRC_ODD\t\t\t(0x3 << 28)\n#define MIPI_CSIS_INT_SRC_NON_IMAGE_DATA\t(0xf << 28)\n#define MIPI_CSIS_INT_SRC_FRAME_START\t\tBIT(24)\n#define MIPI_CSIS_INT_SRC_FRAME_END\t\tBIT(20)\n#define MIPI_CSIS_INT_SRC_ERR_SOT_HS\t\tBIT(16)\n#define MIPI_CSIS_INT_SRC_ERR_LOST_FS\t\tBIT(12)\n#define MIPI_CSIS_INT_SRC_ERR_LOST_FE\t\tBIT(8)\n#define MIPI_CSIS_INT_SRC_ERR_OVER\t\tBIT(4)\n#define MIPI_CSIS_INT_SRC_ERR_WRONG_CFG\t\tBIT(3)\n#define MIPI_CSIS_INT_SRC_ERR_ECC\t\tBIT(2)\n#define MIPI_CSIS_INT_SRC_ERR_CRC\t\tBIT(1)\n#define MIPI_CSIS_INT_SRC_ERR_UNKNOWN\t\tBIT(0)\n#define MIPI_CSIS_INT_SRC_ERRORS\t\t0xfffff\n\n \n#define MIPI_CSIS_DPHY_STATUS\t\t\t0x20\n#define MIPI_CSIS_DPHY_STATUS_ULPS_DAT\t\tBIT(8)\n#define MIPI_CSIS_DPHY_STATUS_STOPSTATE_DAT\tBIT(4)\n#define MIPI_CSIS_DPHY_STATUS_ULPS_CLK\t\tBIT(1)\n#define MIPI_CSIS_DPHY_STATUS_STOPSTATE_CLK\tBIT(0)\n\n \n#define MIPI_CSIS_DPHY_CMN_CTRL\t\t\t0x24\n#define MIPI_CSIS_DPHY_CMN_CTRL_HSSETTLE(n)\t((n) << 24)\n#define MIPI_CSIS_DPHY_CMN_CTRL_HSSETTLE_MASK\tGENMASK(31, 24)\n#define MIPI_CSIS_DPHY_CMN_CTRL_CLKSETTLE(n)\t((n) << 22)\n#define MIPI_CSIS_DPHY_CMN_CTRL_CLKSETTLE_MASK\tGENMASK(23, 22)\n#define MIPI_CSIS_DPHY_CMN_CTRL_DPDN_SWAP_CLK\tBIT(6)\n#define MIPI_CSIS_DPHY_CMN_CTRL_DPDN_SWAP_DAT\tBIT(5)\n#define MIPI_CSIS_DPHY_CMN_CTRL_ENABLE_DAT\tBIT(1)\n#define MIPI_CSIS_DPHY_CMN_CTRL_ENABLE_CLK\tBIT(0)\n#define MIPI_CSIS_DPHY_CMN_CTRL_ENABLE\t\t(0x1f << 0)\n\n \n#define MIPI_CSIS_DPHY_BCTRL_L\t\t\t0x30\n#define MIPI_CSIS_DPHY_BCTRL_L_USER_DATA_PATTERN_LOW(n)\t\t(((n) & 3U) << 30)\n#define MIPI_CSIS_DPHY_BCTRL_L_BIAS_REF_VOLT_715MV\t\t(0 << 28)\n#define MIPI_CSIS_DPHY_BCTRL_L_BIAS_REF_VOLT_724MV\t\t(1 << 28)\n#define MIPI_CSIS_DPHY_BCTRL_L_BIAS_REF_VOLT_733MV\t\t(2 << 28)\n#define MIPI_CSIS_DPHY_BCTRL_L_BIAS_REF_VOLT_706MV\t\t(3 << 28)\n#define MIPI_CSIS_DPHY_BCTRL_L_BGR_CHOPPER_FREQ_3MHZ\t\t(0 << 27)\n#define MIPI_CSIS_DPHY_BCTRL_L_BGR_CHOPPER_FREQ_1_5MHZ\t\t(1 << 27)\n#define MIPI_CSIS_DPHY_BCTRL_L_VREG12_EXTPWR_EN_CTL\t\tBIT(26)\n#define MIPI_CSIS_DPHY_BCTRL_L_REG_12P_LVL_CTL_1_2V\t\t(0 << 24)\n#define MIPI_CSIS_DPHY_BCTRL_L_REG_12P_LVL_CTL_1_23V\t\t(1 << 24)\n#define MIPI_CSIS_DPHY_BCTRL_L_REG_12P_LVL_CTL_1_17V\t\t(2 << 24)\n#define MIPI_CSIS_DPHY_BCTRL_L_REG_12P_LVL_CTL_1_26V\t\t(3 << 24)\n#define MIPI_CSIS_DPHY_BCTRL_L_REG_1P2_LVL_SEL\t\t\tBIT(23)\n#define MIPI_CSIS_DPHY_BCTRL_L_LP_RX_HYS_LVL_80MV\t\t(0 << 21)\n#define MIPI_CSIS_DPHY_BCTRL_L_LP_RX_HYS_LVL_100MV\t\t(1 << 21)\n#define MIPI_CSIS_DPHY_BCTRL_L_LP_RX_HYS_LVL_120MV\t\t(2 << 21)\n#define MIPI_CSIS_DPHY_BCTRL_L_LP_RX_HYS_LVL_140MV\t\t(3 << 21)\n#define MIPI_CSIS_DPHY_BCTRL_L_VREF_SRC_SEL\t\t\tBIT(20)\n#define MIPI_CSIS_DPHY_BCTRL_L_LP_RX_VREF_LVL_715MV\t\t(0 << 18)\n#define MIPI_CSIS_DPHY_BCTRL_L_LP_RX_VREF_LVL_743MV\t\t(1 << 18)\n#define MIPI_CSIS_DPHY_BCTRL_L_LP_RX_VREF_LVL_650MV\t\t(2 << 18)\n#define MIPI_CSIS_DPHY_BCTRL_L_LP_RX_VREF_LVL_682MV\t\t(3 << 18)\n#define MIPI_CSIS_DPHY_BCTRL_L_LP_RX_PULSE_REJECT\t\tBIT(17)\n#define MIPI_CSIS_DPHY_BCTRL_L_MSTRCLK_LP_SLEW_RATE_DOWN_0\t(0 << 15)\n#define MIPI_CSIS_DPHY_BCTRL_L_MSTRCLK_LP_SLEW_RATE_DOWN_15P\t(1 << 15)\n#define MIPI_CSIS_DPHY_BCTRL_L_MSTRCLK_LP_SLEW_RATE_DOWN_30P\t(3 << 15)\n#define MIPI_CSIS_DPHY_BCTRL_L_MSTRCLK_LP_SLEW_RATE_UP\t\tBIT(14)\n#define MIPI_CSIS_DPHY_BCTRL_L_LP_CD_HYS_60MV\t\t\t(0 << 13)\n#define MIPI_CSIS_DPHY_BCTRL_L_LP_CD_HYS_70MV\t\t\t(1 << 13)\n#define MIPI_CSIS_DPHY_BCTRL_L_BGR_CHOPPER_EN\t\t\tBIT(12)\n#define MIPI_CSIS_DPHY_BCTRL_L_ERRCONTENTION_LP_EN\t\tBIT(11)\n#define MIPI_CSIS_DPHY_BCTRL_L_TXTRIGGER_CLK_EN\t\t\tBIT(10)\n#define MIPI_CSIS_DPHY_BCTRL_L_B_DPHYCTRL(n)\t\t\t(((n) * 25 / 1000000) << 0)\n\n \n#define MIPI_CSIS_DPHY_BCTRL_H\t\t\t0x34\n \n#define MIPI_CSIS_DPHY_SCTRL_L\t\t\t0x38\n \n#define MIPI_CSIS_DPHY_SCTRL_H\t\t\t0x3c\n\n \n#define MIPI_CSIS_ISP_CONFIG_CH(n)\t\t(0x40 + (n) * 0x10)\n#define MIPI_CSIS_ISPCFG_MEM_FULL_GAP_MSK\t(0xff << 24)\n#define MIPI_CSIS_ISPCFG_MEM_FULL_GAP(x)\t((x) << 24)\n#define MIPI_CSIS_ISPCFG_PIXEL_MODE_SINGLE\t(0 << 12)\n#define MIPI_CSIS_ISPCFG_PIXEL_MODE_DUAL\t(1 << 12)\n#define MIPI_CSIS_ISPCFG_PIXEL_MODE_QUAD\t(2 << 12)\t \n#define MIPI_CSIS_ISPCFG_PIXEL_MASK\t\t(3 << 12)\n#define MIPI_CSIS_ISPCFG_ALIGN_32BIT\t\tBIT(11)\n#define MIPI_CSIS_ISPCFG_FMT(fmt)\t\t((fmt) << 2)\n#define MIPI_CSIS_ISPCFG_FMT_MASK\t\t(0x3f << 2)\n\n \n#define MIPI_CSIS_ISP_RESOL_CH(n)\t\t(0x44 + (n) * 0x10)\n#define CSIS_MAX_PIX_WIDTH\t\t\t0xffff\n#define CSIS_MAX_PIX_HEIGHT\t\t\t0xffff\n\n \n#define MIPI_CSIS_ISP_SYNC_CH(n)\t\t(0x48 + (n) * 0x10)\n#define MIPI_CSIS_ISP_SYNC_HSYNC_LINTV_OFFSET\t18\n#define MIPI_CSIS_ISP_SYNC_VSYNC_SINTV_OFFSET\t12\n#define MIPI_CSIS_ISP_SYNC_VSYNC_EINTV_OFFSET\t0\n\n \n#define MIPI_CSIS_SDW_CONFIG_CH(n)\t\t(0x80 + (n) * 0x10)\n#define MIPI_CSIS_SDW_RESOL_CH(n)\t\t(0x84 + (n) * 0x10)\n#define MIPI_CSIS_SDW_SYNC_CH(n)\t\t(0x88 + (n) * 0x10)\n\n \n#define MIPI_CSIS_DBG_CTRL\t\t\t0xc0\n#define MIPI_CSIS_DBG_INTR_MSK\t\t\t0xc4\n#define MIPI_CSIS_DBG_INTR_MSK_DT_NOT_SUPPORT\tBIT(25)\n#define MIPI_CSIS_DBG_INTR_MSK_DT_IGNORE\tBIT(24)\n#define MIPI_CSIS_DBG_INTR_MSK_ERR_FRAME_SIZE\tBIT(20)\n#define MIPI_CSIS_DBG_INTR_MSK_TRUNCATED_FRAME\tBIT(16)\n#define MIPI_CSIS_DBG_INTR_MSK_EARLY_FE\t\tBIT(12)\n#define MIPI_CSIS_DBG_INTR_MSK_EARLY_FS\t\tBIT(8)\n#define MIPI_CSIS_DBG_INTR_MSK_CAM_VSYNC_FALL\tBIT(4)\n#define MIPI_CSIS_DBG_INTR_MSK_CAM_VSYNC_RISE\tBIT(0)\n#define MIPI_CSIS_DBG_INTR_SRC\t\t\t0xc8\n#define MIPI_CSIS_DBG_INTR_SRC_DT_NOT_SUPPORT\tBIT(25)\n#define MIPI_CSIS_DBG_INTR_SRC_DT_IGNORE\tBIT(24)\n#define MIPI_CSIS_DBG_INTR_SRC_ERR_FRAME_SIZE\tBIT(20)\n#define MIPI_CSIS_DBG_INTR_SRC_TRUNCATED_FRAME\tBIT(16)\n#define MIPI_CSIS_DBG_INTR_SRC_EARLY_FE\t\tBIT(12)\n#define MIPI_CSIS_DBG_INTR_SRC_EARLY_FS\t\tBIT(8)\n#define MIPI_CSIS_DBG_INTR_SRC_CAM_VSYNC_FALL\tBIT(4)\n#define MIPI_CSIS_DBG_INTR_SRC_CAM_VSYNC_RISE\tBIT(0)\n\n#define MIPI_CSIS_FRAME_COUNTER_CH(n)\t\t(0x0100 + (n) * 4)\n\n \n#define MIPI_CSIS_PKTDATA_ODD\t\t\t0x2000\n#define MIPI_CSIS_PKTDATA_EVEN\t\t\t0x3000\n#define MIPI_CSIS_PKTDATA_SIZE\t\t\tSZ_4K\n\n#define DEFAULT_SCLK_CSIS_FREQ\t\t\t166000000UL\n\n \n#define MIPI_CSI2_DATA_TYPE_YUV420_8\t\t0x18\n#define MIPI_CSI2_DATA_TYPE_YUV420_10\t\t0x19\n#define MIPI_CSI2_DATA_TYPE_LE_YUV420_8\t\t0x1a\n#define MIPI_CSI2_DATA_TYPE_CS_YUV420_8\t\t0x1c\n#define MIPI_CSI2_DATA_TYPE_CS_YUV420_10\t0x1d\n#define MIPI_CSI2_DATA_TYPE_YUV422_8\t\t0x1e\n#define MIPI_CSI2_DATA_TYPE_YUV422_10\t\t0x1f\n#define MIPI_CSI2_DATA_TYPE_RGB565\t\t0x22\n#define MIPI_CSI2_DATA_TYPE_RGB666\t\t0x23\n#define MIPI_CSI2_DATA_TYPE_RGB888\t\t0x24\n#define MIPI_CSI2_DATA_TYPE_RAW6\t\t0x28\n#define MIPI_CSI2_DATA_TYPE_RAW7\t\t0x29\n#define MIPI_CSI2_DATA_TYPE_RAW8\t\t0x2a\n#define MIPI_CSI2_DATA_TYPE_RAW10\t\t0x2b\n#define MIPI_CSI2_DATA_TYPE_RAW12\t\t0x2c\n#define MIPI_CSI2_DATA_TYPE_RAW14\t\t0x2d\n#define MIPI_CSI2_DATA_TYPE_USER(x)\t\t(0x30 + (x))\n\nstruct mipi_csis_event {\n\tbool debug;\n\tu32 mask;\n\tconst char * const name;\n\tunsigned int counter;\n};\n\nstatic const struct mipi_csis_event mipi_csis_events[] = {\n\t \n\t{ false, MIPI_CSIS_INT_SRC_ERR_SOT_HS,\t\t\"SOT Error\" },\n\t{ false, MIPI_CSIS_INT_SRC_ERR_LOST_FS,\t\t\"Lost Frame Start Error\" },\n\t{ false, MIPI_CSIS_INT_SRC_ERR_LOST_FE,\t\t\"Lost Frame End Error\" },\n\t{ false, MIPI_CSIS_INT_SRC_ERR_OVER,\t\t\"FIFO Overflow Error\" },\n\t{ false, MIPI_CSIS_INT_SRC_ERR_WRONG_CFG,\t\"Wrong Configuration Error\" },\n\t{ false, MIPI_CSIS_INT_SRC_ERR_ECC,\t\t\"ECC Error\" },\n\t{ false, MIPI_CSIS_INT_SRC_ERR_CRC,\t\t\"CRC Error\" },\n\t{ false, MIPI_CSIS_INT_SRC_ERR_UNKNOWN,\t\t\"Unknown Error\" },\n\t{ true, MIPI_CSIS_DBG_INTR_SRC_DT_NOT_SUPPORT,\t\"Data Type Not Supported\" },\n\t{ true, MIPI_CSIS_DBG_INTR_SRC_DT_IGNORE,\t\"Data Type Ignored\" },\n\t{ true, MIPI_CSIS_DBG_INTR_SRC_ERR_FRAME_SIZE,\t\"Frame Size Error\" },\n\t{ true, MIPI_CSIS_DBG_INTR_SRC_TRUNCATED_FRAME,\t\"Truncated Frame\" },\n\t{ true, MIPI_CSIS_DBG_INTR_SRC_EARLY_FE,\t\"Early Frame End\" },\n\t{ true, MIPI_CSIS_DBG_INTR_SRC_EARLY_FS,\t\"Early Frame Start\" },\n\t \n\t{ false, MIPI_CSIS_INT_SRC_EVEN_BEFORE,\t\t\"Non-image data before even frame\" },\n\t{ false, MIPI_CSIS_INT_SRC_EVEN_AFTER,\t\t\"Non-image data after even frame\" },\n\t{ false, MIPI_CSIS_INT_SRC_ODD_BEFORE,\t\t\"Non-image data before odd frame\" },\n\t{ false, MIPI_CSIS_INT_SRC_ODD_AFTER,\t\t\"Non-image data after odd frame\" },\n\t \n\t{ false, MIPI_CSIS_INT_SRC_FRAME_START,\t\t\"Frame Start\" },\n\t{ false, MIPI_CSIS_INT_SRC_FRAME_END,\t\t\"Frame End\" },\n\t{ true, MIPI_CSIS_DBG_INTR_SRC_CAM_VSYNC_FALL,\t\"VSYNC Falling Edge\" },\n\t{ true, MIPI_CSIS_DBG_INTR_SRC_CAM_VSYNC_RISE,\t\"VSYNC Rising Edge\" },\n};\n\n#define MIPI_CSIS_NUM_EVENTS ARRAY_SIZE(mipi_csis_events)\n\nenum mipi_csis_clk {\n\tMIPI_CSIS_CLK_PCLK,\n\tMIPI_CSIS_CLK_WRAP,\n\tMIPI_CSIS_CLK_PHY,\n\tMIPI_CSIS_CLK_AXI,\n};\n\nstatic const char * const mipi_csis_clk_id[] = {\n\t\"pclk\",\n\t\"wrap\",\n\t\"phy\",\n\t\"axi\",\n};\n\nenum mipi_csis_version {\n\tMIPI_CSIS_V3_3,\n\tMIPI_CSIS_V3_6_3,\n};\n\nstruct mipi_csis_info {\n\tenum mipi_csis_version version;\n\tunsigned int num_clocks;\n};\n\nstruct mipi_csis_device {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct clk_bulk_data *clks;\n\tstruct reset_control *mrst;\n\tstruct regulator *mipi_phy_regulator;\n\tconst struct mipi_csis_info *info;\n\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pads[CSIS_PADS_NUM];\n\tstruct v4l2_async_notifier notifier;\n\tstruct v4l2_subdev *src_sd;\n\n\tstruct v4l2_mbus_config_mipi_csi2 bus;\n\tu32 clk_frequency;\n\tu32 hs_settle;\n\tu32 clk_settle;\n\n\tspinlock_t slock;\t \n\tstruct mipi_csis_event events[MIPI_CSIS_NUM_EVENTS];\n\tstruct dentry *debugfs_root;\n\tstruct {\n\t\tbool enable;\n\t\tu32 hs_settle;\n\t\tu32 clk_settle;\n\t} debug;\n};\n\n \n\nstruct csis_pix_format {\n\tu32 code;\n\tu32 output;\n\tu32 data_type;\n\tu8 width;\n};\n\nstatic const struct csis_pix_format mipi_csis_formats[] = {\n\t \n\t{\n\t\t.code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.output = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_YUV422_8,\n\t\t.width = 16,\n\t},\n\t \n\t{\n\t\t.code = MEDIA_BUS_FMT_RGB565_1X16,\n\t\t.output = MEDIA_BUS_FMT_RGB565_1X16,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RGB565,\n\t\t.width = 16,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_BGR888_1X24,\n\t\t.output = MEDIA_BUS_FMT_RGB888_1X24,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RGB888,\n\t\t.width = 24,\n\t},\n\t \n\t{\n\t\t.code = MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.output = MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW8,\n\t\t.width = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.output = MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW8,\n\t\t.width = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.output = MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW8,\n\t\t.width = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.output = MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW8,\n\t\t.width = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_Y8_1X8,\n\t\t.output = MEDIA_BUS_FMT_Y8_1X8,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW8,\n\t\t.width = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.output = MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW10,\n\t\t.width = 10,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.output = MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW10,\n\t\t.width = 10,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.output = MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW10,\n\t\t.width = 10,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.output = MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW10,\n\t\t.width = 10,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_Y10_1X10,\n\t\t.output = MEDIA_BUS_FMT_Y10_1X10,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW10,\n\t\t.width = 10,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.output = MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW12,\n\t\t.width = 12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.output = MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW12,\n\t\t.width = 12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.output = MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW12,\n\t\t.width = 12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.output = MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW12,\n\t\t.width = 12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_Y12_1X12,\n\t\t.output = MEDIA_BUS_FMT_Y12_1X12,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW12,\n\t\t.width = 12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SBGGR14_1X14,\n\t\t.output = MEDIA_BUS_FMT_SBGGR14_1X14,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW14,\n\t\t.width = 14,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGBRG14_1X14,\n\t\t.output = MEDIA_BUS_FMT_SGBRG14_1X14,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW14,\n\t\t.width = 14,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG14_1X14,\n\t\t.output = MEDIA_BUS_FMT_SGRBG14_1X14,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW14,\n\t\t.width = 14,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SRGGB14_1X14,\n\t\t.output = MEDIA_BUS_FMT_SRGGB14_1X14,\n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW14,\n\t\t.width = 14,\n\t},\n\t \n\t{\n\t\t.code = MEDIA_BUS_FMT_JPEG_1X8,\n\t\t.output = MEDIA_BUS_FMT_JPEG_1X8,\n\t\t \n\t\t.data_type = MIPI_CSI2_DATA_TYPE_RAW8,\n\t\t.width = 8,\n\t}\n};\n\nstatic const struct csis_pix_format *find_csis_format(u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mipi_csis_formats); i++)\n\t\tif (code == mipi_csis_formats[i].code)\n\t\t\treturn &mipi_csis_formats[i];\n\treturn NULL;\n}\n\n \n\nstatic inline u32 mipi_csis_read(struct mipi_csis_device *csis, u32 reg)\n{\n\treturn readl(csis->regs + reg);\n}\n\nstatic inline void mipi_csis_write(struct mipi_csis_device *csis, u32 reg,\n\t\t\t\t   u32 val)\n{\n\twritel(val, csis->regs + reg);\n}\n\nstatic void mipi_csis_enable_interrupts(struct mipi_csis_device *csis, bool on)\n{\n\tmipi_csis_write(csis, MIPI_CSIS_INT_MSK, on ? 0xffffffff : 0);\n\tmipi_csis_write(csis, MIPI_CSIS_DBG_INTR_MSK, on ? 0xffffffff : 0);\n}\n\nstatic void mipi_csis_sw_reset(struct mipi_csis_device *csis)\n{\n\tu32 val = mipi_csis_read(csis, MIPI_CSIS_CMN_CTRL);\n\n\tmipi_csis_write(csis, MIPI_CSIS_CMN_CTRL,\n\t\t\tval | MIPI_CSIS_CMN_CTRL_RESET);\n\tusleep_range(10, 20);\n}\n\nstatic void mipi_csis_system_enable(struct mipi_csis_device *csis, int on)\n{\n\tu32 val, mask;\n\n\tval = mipi_csis_read(csis, MIPI_CSIS_CMN_CTRL);\n\tif (on)\n\t\tval |= MIPI_CSIS_CMN_CTRL_ENABLE;\n\telse\n\t\tval &= ~MIPI_CSIS_CMN_CTRL_ENABLE;\n\tmipi_csis_write(csis, MIPI_CSIS_CMN_CTRL, val);\n\n\tval = mipi_csis_read(csis, MIPI_CSIS_DPHY_CMN_CTRL);\n\tval &= ~MIPI_CSIS_DPHY_CMN_CTRL_ENABLE;\n\tif (on) {\n\t\tmask = (1 << (csis->bus.num_data_lanes + 1)) - 1;\n\t\tval |= (mask & MIPI_CSIS_DPHY_CMN_CTRL_ENABLE);\n\t}\n\tmipi_csis_write(csis, MIPI_CSIS_DPHY_CMN_CTRL, val);\n}\n\nstatic void __mipi_csis_set_format(struct mipi_csis_device *csis,\n\t\t\t\t   const struct v4l2_mbus_framefmt *format,\n\t\t\t\t   const struct csis_pix_format *csis_fmt)\n{\n\tu32 val;\n\n\t \n\tval = mipi_csis_read(csis, MIPI_CSIS_ISP_CONFIG_CH(0));\n\tval &= ~(MIPI_CSIS_ISPCFG_ALIGN_32BIT | MIPI_CSIS_ISPCFG_FMT_MASK\n\t\t| MIPI_CSIS_ISPCFG_PIXEL_MASK);\n\n\t \n\tif (csis_fmt->data_type == MIPI_CSI2_DATA_TYPE_YUV422_8)\n\t\tval |= MIPI_CSIS_ISPCFG_PIXEL_MODE_DUAL;\n\n\tval |= MIPI_CSIS_ISPCFG_FMT(csis_fmt->data_type);\n\tmipi_csis_write(csis, MIPI_CSIS_ISP_CONFIG_CH(0), val);\n\n\t \n\tval = format->width | (format->height << 16);\n\tmipi_csis_write(csis, MIPI_CSIS_ISP_RESOL_CH(0), val);\n}\n\nstatic int mipi_csis_calculate_params(struct mipi_csis_device *csis,\n\t\t\t\t      const struct csis_pix_format *csis_fmt)\n{\n\ts64 link_freq;\n\tu32 lane_rate;\n\n\t \n\tlink_freq = v4l2_get_link_freq(csis->src_sd->ctrl_handler,\n\t\t\t\t       csis_fmt->width,\n\t\t\t\t       csis->bus.num_data_lanes * 2);\n\tif (link_freq < 0) {\n\t\tdev_err(csis->dev, \"Unable to obtain link frequency: %d\\n\",\n\t\t\t(int)link_freq);\n\t\treturn link_freq;\n\t}\n\n\tlane_rate = link_freq * 2;\n\n\tif (lane_rate < 80000000 || lane_rate > 1500000000) {\n\t\tdev_dbg(csis->dev, \"Out-of-bound lane rate %u\\n\", lane_rate);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcsis->hs_settle = (lane_rate - 5000000) / 45000000;\n\tcsis->clk_settle = 0;\n\n\tdev_dbg(csis->dev, \"lane rate %u, Tclk_settle %u, Ths_settle %u\\n\",\n\t\tlane_rate, csis->clk_settle, csis->hs_settle);\n\n\tif (csis->debug.hs_settle < 0xff) {\n\t\tdev_dbg(csis->dev, \"overriding Ths_settle with %u\\n\",\n\t\t\tcsis->debug.hs_settle);\n\t\tcsis->hs_settle = csis->debug.hs_settle;\n\t}\n\n\tif (csis->debug.clk_settle < 4) {\n\t\tdev_dbg(csis->dev, \"overriding Tclk_settle with %u\\n\",\n\t\t\tcsis->debug.clk_settle);\n\t\tcsis->clk_settle = csis->debug.clk_settle;\n\t}\n\n\treturn 0;\n}\n\nstatic void mipi_csis_set_params(struct mipi_csis_device *csis,\n\t\t\t\t const struct v4l2_mbus_framefmt *format,\n\t\t\t\t const struct csis_pix_format *csis_fmt)\n{\n\tint lanes = csis->bus.num_data_lanes;\n\tu32 val;\n\n\tval = mipi_csis_read(csis, MIPI_CSIS_CMN_CTRL);\n\tval &= ~MIPI_CSIS_CMN_CTRL_LANE_NR_MASK;\n\tval |= (lanes - 1) << MIPI_CSIS_CMN_CTRL_LANE_NR_OFFSET;\n\tif (csis->info->version == MIPI_CSIS_V3_3)\n\t\tval |= MIPI_CSIS_CMN_CTRL_INTER_MODE;\n\tmipi_csis_write(csis, MIPI_CSIS_CMN_CTRL, val);\n\n\t__mipi_csis_set_format(csis, format, csis_fmt);\n\n\tmipi_csis_write(csis, MIPI_CSIS_DPHY_CMN_CTRL,\n\t\t\tMIPI_CSIS_DPHY_CMN_CTRL_HSSETTLE(csis->hs_settle) |\n\t\t\tMIPI_CSIS_DPHY_CMN_CTRL_CLKSETTLE(csis->clk_settle));\n\n\tval = (0 << MIPI_CSIS_ISP_SYNC_HSYNC_LINTV_OFFSET)\n\t    | (0 << MIPI_CSIS_ISP_SYNC_VSYNC_SINTV_OFFSET)\n\t    | (0 << MIPI_CSIS_ISP_SYNC_VSYNC_EINTV_OFFSET);\n\tmipi_csis_write(csis, MIPI_CSIS_ISP_SYNC_CH(0), val);\n\n\tval = mipi_csis_read(csis, MIPI_CSIS_CLK_CTRL);\n\tval |= MIPI_CSIS_CLK_CTRL_WCLK_SRC;\n\tval |= MIPI_CSIS_CLK_CTRL_CLKGATE_TRAIL_CH0(15);\n\tval &= ~MIPI_CSIS_CLK_CTRL_CLKGATE_EN_MSK;\n\tmipi_csis_write(csis, MIPI_CSIS_CLK_CTRL, val);\n\n\tmipi_csis_write(csis, MIPI_CSIS_DPHY_BCTRL_L,\n\t\t\tMIPI_CSIS_DPHY_BCTRL_L_BIAS_REF_VOLT_715MV |\n\t\t\tMIPI_CSIS_DPHY_BCTRL_L_BGR_CHOPPER_FREQ_3MHZ |\n\t\t\tMIPI_CSIS_DPHY_BCTRL_L_REG_12P_LVL_CTL_1_2V |\n\t\t\tMIPI_CSIS_DPHY_BCTRL_L_LP_RX_HYS_LVL_80MV |\n\t\t\tMIPI_CSIS_DPHY_BCTRL_L_LP_RX_VREF_LVL_715MV |\n\t\t\tMIPI_CSIS_DPHY_BCTRL_L_LP_CD_HYS_60MV |\n\t\t\tMIPI_CSIS_DPHY_BCTRL_L_B_DPHYCTRL(20000000));\n\tmipi_csis_write(csis, MIPI_CSIS_DPHY_BCTRL_H, 0);\n\n\t \n\tval = mipi_csis_read(csis, MIPI_CSIS_CMN_CTRL);\n\tmipi_csis_write(csis, MIPI_CSIS_CMN_CTRL,\n\t\t\tval | MIPI_CSIS_CMN_CTRL_UPDATE_SHADOW |\n\t\t\tMIPI_CSIS_CMN_CTRL_UPDATE_SHADOW_CTRL);\n}\n\nstatic int mipi_csis_clk_enable(struct mipi_csis_device *csis)\n{\n\treturn clk_bulk_prepare_enable(csis->info->num_clocks, csis->clks);\n}\n\nstatic void mipi_csis_clk_disable(struct mipi_csis_device *csis)\n{\n\tclk_bulk_disable_unprepare(csis->info->num_clocks, csis->clks);\n}\n\nstatic int mipi_csis_clk_get(struct mipi_csis_device *csis)\n{\n\tunsigned int i;\n\tint ret;\n\n\tcsis->clks = devm_kcalloc(csis->dev, csis->info->num_clocks,\n\t\t\t\t  sizeof(*csis->clks), GFP_KERNEL);\n\n\tif (!csis->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < csis->info->num_clocks; i++)\n\t\tcsis->clks[i].id = mipi_csis_clk_id[i];\n\n\tret = devm_clk_bulk_get(csis->dev, csis->info->num_clocks,\n\t\t\t\tcsis->clks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = clk_set_rate(csis->clks[MIPI_CSIS_CLK_WRAP].clk,\n\t\t\t   csis->clk_frequency);\n\tif (ret < 0)\n\t\tdev_err(csis->dev, \"set rate=%d failed: %d\\n\",\n\t\t\tcsis->clk_frequency, ret);\n\n\treturn ret;\n}\n\nstatic void mipi_csis_start_stream(struct mipi_csis_device *csis,\n\t\t\t\t   const struct v4l2_mbus_framefmt *format,\n\t\t\t\t   const struct csis_pix_format *csis_fmt)\n{\n\tmipi_csis_sw_reset(csis);\n\tmipi_csis_set_params(csis, format, csis_fmt);\n\tmipi_csis_system_enable(csis, true);\n\tmipi_csis_enable_interrupts(csis, true);\n}\n\nstatic void mipi_csis_stop_stream(struct mipi_csis_device *csis)\n{\n\tmipi_csis_enable_interrupts(csis, false);\n\tmipi_csis_system_enable(csis, false);\n}\n\nstatic irqreturn_t mipi_csis_irq_handler(int irq, void *dev_id)\n{\n\tstruct mipi_csis_device *csis = dev_id;\n\tunsigned long flags;\n\tunsigned int i;\n\tu32 status;\n\tu32 dbg_status;\n\n\tstatus = mipi_csis_read(csis, MIPI_CSIS_INT_SRC);\n\tdbg_status = mipi_csis_read(csis, MIPI_CSIS_DBG_INTR_SRC);\n\n\tspin_lock_irqsave(&csis->slock, flags);\n\n\t \n\tif ((status & MIPI_CSIS_INT_SRC_ERRORS) || csis->debug.enable) {\n\t\tfor (i = 0; i < MIPI_CSIS_NUM_EVENTS; i++) {\n\t\t\tstruct mipi_csis_event *event = &csis->events[i];\n\n\t\t\tif ((!event->debug && (status & event->mask)) ||\n\t\t\t    (event->debug && (dbg_status & event->mask)))\n\t\t\t\tevent->counter++;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&csis->slock, flags);\n\n\tmipi_csis_write(csis, MIPI_CSIS_INT_SRC, status);\n\tmipi_csis_write(csis, MIPI_CSIS_DBG_INTR_SRC, dbg_status);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int mipi_csis_phy_enable(struct mipi_csis_device *csis)\n{\n\tif (csis->info->version != MIPI_CSIS_V3_3)\n\t\treturn 0;\n\n\treturn regulator_enable(csis->mipi_phy_regulator);\n}\n\nstatic int mipi_csis_phy_disable(struct mipi_csis_device *csis)\n{\n\tif (csis->info->version != MIPI_CSIS_V3_3)\n\t\treturn 0;\n\n\treturn regulator_disable(csis->mipi_phy_regulator);\n}\n\nstatic void mipi_csis_phy_reset(struct mipi_csis_device *csis)\n{\n\tif (csis->info->version != MIPI_CSIS_V3_3)\n\t\treturn;\n\n\treset_control_assert(csis->mrst);\n\tmsleep(20);\n\treset_control_deassert(csis->mrst);\n}\n\nstatic int mipi_csis_phy_init(struct mipi_csis_device *csis)\n{\n\tif (csis->info->version != MIPI_CSIS_V3_3)\n\t\treturn 0;\n\n\t \n\tcsis->mrst = devm_reset_control_get_exclusive(csis->dev, NULL);\n\tif (IS_ERR(csis->mrst))\n\t\treturn PTR_ERR(csis->mrst);\n\n\tcsis->mipi_phy_regulator = devm_regulator_get(csis->dev, \"phy\");\n\tif (IS_ERR(csis->mipi_phy_regulator))\n\t\treturn PTR_ERR(csis->mipi_phy_regulator);\n\n\treturn regulator_set_voltage(csis->mipi_phy_regulator, 1000000,\n\t\t\t\t     1000000);\n}\n\n \n\nstatic void mipi_csis_clear_counters(struct mipi_csis_device *csis)\n{\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&csis->slock, flags);\n\tfor (i = 0; i < MIPI_CSIS_NUM_EVENTS; i++)\n\t\tcsis->events[i].counter = 0;\n\tspin_unlock_irqrestore(&csis->slock, flags);\n}\n\nstatic void mipi_csis_log_counters(struct mipi_csis_device *csis, bool non_errors)\n{\n\tunsigned int num_events = non_errors ? MIPI_CSIS_NUM_EVENTS\n\t\t\t\t: MIPI_CSIS_NUM_EVENTS - 8;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&csis->slock, flags);\n\n\tfor (i = 0; i < num_events; ++i) {\n\t\tif (csis->events[i].counter > 0 || csis->debug.enable)\n\t\t\tdev_info(csis->dev, \"%s events: %d\\n\",\n\t\t\t\t csis->events[i].name,\n\t\t\t\t csis->events[i].counter);\n\t}\n\tspin_unlock_irqrestore(&csis->slock, flags);\n}\n\nstatic int mipi_csis_dump_regs(struct mipi_csis_device *csis)\n{\n\tstatic const struct {\n\t\tu32 offset;\n\t\tconst char * const name;\n\t} registers[] = {\n\t\t{ MIPI_CSIS_CMN_CTRL, \"CMN_CTRL\" },\n\t\t{ MIPI_CSIS_CLK_CTRL, \"CLK_CTRL\" },\n\t\t{ MIPI_CSIS_INT_MSK, \"INT_MSK\" },\n\t\t{ MIPI_CSIS_DPHY_STATUS, \"DPHY_STATUS\" },\n\t\t{ MIPI_CSIS_DPHY_CMN_CTRL, \"DPHY_CMN_CTRL\" },\n\t\t{ MIPI_CSIS_DPHY_SCTRL_L, \"DPHY_SCTRL_L\" },\n\t\t{ MIPI_CSIS_DPHY_SCTRL_H, \"DPHY_SCTRL_H\" },\n\t\t{ MIPI_CSIS_ISP_CONFIG_CH(0), \"ISP_CONFIG_CH0\" },\n\t\t{ MIPI_CSIS_ISP_RESOL_CH(0), \"ISP_RESOL_CH0\" },\n\t\t{ MIPI_CSIS_SDW_CONFIG_CH(0), \"SDW_CONFIG_CH0\" },\n\t\t{ MIPI_CSIS_SDW_RESOL_CH(0), \"SDW_RESOL_CH0\" },\n\t\t{ MIPI_CSIS_DBG_CTRL, \"DBG_CTRL\" },\n\t\t{ MIPI_CSIS_FRAME_COUNTER_CH(0), \"FRAME_COUNTER_CH0\" },\n\t};\n\n\tunsigned int i;\n\tu32 cfg;\n\n\tif (!pm_runtime_get_if_in_use(csis->dev))\n\t\treturn 0;\n\n\tdev_info(csis->dev, \"--- REGISTERS ---\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(registers); i++) {\n\t\tcfg = mipi_csis_read(csis, registers[i].offset);\n\t\tdev_info(csis->dev, \"%14s: 0x%08x\\n\", registers[i].name, cfg);\n\t}\n\n\tpm_runtime_put(csis->dev);\n\n\treturn 0;\n}\n\nstatic int mipi_csis_dump_regs_show(struct seq_file *m, void *private)\n{\n\tstruct mipi_csis_device *csis = m->private;\n\n\treturn mipi_csis_dump_regs(csis);\n}\nDEFINE_SHOW_ATTRIBUTE(mipi_csis_dump_regs);\n\nstatic void mipi_csis_debugfs_init(struct mipi_csis_device *csis)\n{\n\tcsis->debug.hs_settle = UINT_MAX;\n\tcsis->debug.clk_settle = UINT_MAX;\n\n\tcsis->debugfs_root = debugfs_create_dir(dev_name(csis->dev), NULL);\n\n\tdebugfs_create_bool(\"debug_enable\", 0600, csis->debugfs_root,\n\t\t\t    &csis->debug.enable);\n\tdebugfs_create_file(\"dump_regs\", 0600, csis->debugfs_root, csis,\n\t\t\t    &mipi_csis_dump_regs_fops);\n\tdebugfs_create_u32(\"tclk_settle\", 0600, csis->debugfs_root,\n\t\t\t   &csis->debug.clk_settle);\n\tdebugfs_create_u32(\"ths_settle\", 0600, csis->debugfs_root,\n\t\t\t   &csis->debug.hs_settle);\n}\n\nstatic void mipi_csis_debugfs_exit(struct mipi_csis_device *csis)\n{\n\tdebugfs_remove_recursive(csis->debugfs_root);\n}\n\n \n\nstatic struct mipi_csis_device *sd_to_mipi_csis_device(struct v4l2_subdev *sdev)\n{\n\treturn container_of(sdev, struct mipi_csis_device, sd);\n}\n\nstatic int mipi_csis_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct mipi_csis_device *csis = sd_to_mipi_csis_device(sd);\n\tconst struct v4l2_mbus_framefmt *format;\n\tconst struct csis_pix_format *csis_fmt;\n\tstruct v4l2_subdev_state *state;\n\tint ret;\n\n\tif (!enable) {\n\t\tv4l2_subdev_call(csis->src_sd, video, s_stream, 0);\n\n\t\tmipi_csis_stop_stream(csis);\n\t\tif (csis->debug.enable)\n\t\t\tmipi_csis_log_counters(csis, true);\n\n\t\tpm_runtime_put(csis->dev);\n\n\t\treturn 0;\n\t}\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tformat = v4l2_subdev_get_pad_format(sd, state, CSIS_PAD_SINK);\n\tcsis_fmt = find_csis_format(format->code);\n\n\tret = mipi_csis_calculate_params(csis, csis_fmt);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\tmipi_csis_clear_counters(csis);\n\n\tret = pm_runtime_resume_and_get(csis->dev);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\tmipi_csis_start_stream(csis, format, csis_fmt);\n\n\tret = v4l2_subdev_call(csis->src_sd, video, s_stream, 1);\n\tif (ret < 0)\n\t\tgoto err_stop;\n\n\tmipi_csis_log_counters(csis, true);\n\n\tv4l2_subdev_unlock_state(state);\n\n\treturn 0;\n\nerr_stop:\n\tmipi_csis_stop_stream(csis);\n\tpm_runtime_put(csis->dev);\nerr_unlock:\n\tv4l2_subdev_unlock_state(state);\n\n\treturn ret;\n}\n\nstatic int mipi_csis_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state,\n\t\t\t\t    struct v4l2_subdev_mbus_code_enum *code)\n{\n\t \n\tif (code->pad == CSIS_PAD_SOURCE) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tif (code->index > 0)\n\t\t\treturn -EINVAL;\n\n\t\tfmt = v4l2_subdev_get_pad_format(sd, sd_state, code->pad);\n\t\tcode->code = fmt->code;\n\t\treturn 0;\n\t}\n\n\tif (code->pad != CSIS_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tif (code->index >= ARRAY_SIZE(mipi_csis_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = mipi_csis_formats[code->index].code;\n\n\treturn 0;\n}\n\nstatic int mipi_csis_set_fmt(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_subdev_state *sd_state,\n\t\t\t     struct v4l2_subdev_format *sdformat)\n{\n\tstruct csis_pix_format const *csis_fmt;\n\tstruct v4l2_mbus_framefmt *fmt;\n\tunsigned int align;\n\n\t \n\tif (sdformat->pad == CSIS_PAD_SOURCE)\n\t\treturn v4l2_subdev_get_fmt(sd, sd_state, sdformat);\n\n\tif (sdformat->pad != CSIS_PAD_SINK)\n\t\treturn -EINVAL;\n\n\t \n\tcsis_fmt = find_csis_format(sdformat->format.code);\n\tif (!csis_fmt)\n\t\tcsis_fmt = &mipi_csis_formats[0];\n\n\tswitch (csis_fmt->width % 8) {\n\tcase 0:\n\t\talign = 0;\n\t\tbreak;\n\tcase 4:\n\t\talign = 1;\n\t\tbreak;\n\tcase 2:\n\tcase 6:\n\t\talign = 2;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\talign = 3;\n\t\tbreak;\n\t}\n\n\tv4l_bound_align_image(&sdformat->format.width, 1,\n\t\t\t      CSIS_MAX_PIX_WIDTH, align,\n\t\t\t      &sdformat->format.height, 1,\n\t\t\t      CSIS_MAX_PIX_HEIGHT, 0, 0);\n\n\tfmt = v4l2_subdev_get_pad_format(sd, sd_state, sdformat->pad);\n\n\tfmt->code = csis_fmt->code;\n\tfmt->width = sdformat->format.width;\n\tfmt->height = sdformat->format.height;\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->colorspace = sdformat->format.colorspace;\n\tfmt->quantization = sdformat->format.quantization;\n\tfmt->xfer_func = sdformat->format.xfer_func;\n\tfmt->ycbcr_enc = sdformat->format.ycbcr_enc;\n\n\tsdformat->format = *fmt;\n\n\t \n\tfmt = v4l2_subdev_get_pad_format(sd, sd_state, CSIS_PAD_SOURCE);\n\t*fmt = sdformat->format;\n\n\t \n\tfmt->code = csis_fmt->output;\n\n\treturn 0;\n}\n\nstatic int mipi_csis_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,\n\t\t\t\t    struct v4l2_mbus_frame_desc *fd)\n{\n\tstruct v4l2_mbus_frame_desc_entry *entry = &fd->entry[0];\n\tconst struct csis_pix_format *csis_fmt;\n\tconst struct v4l2_mbus_framefmt *fmt;\n\tstruct v4l2_subdev_state *state;\n\n\tif (pad != CSIS_PAD_SOURCE)\n\t\treturn -EINVAL;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\tfmt = v4l2_subdev_get_pad_format(sd, state, CSIS_PAD_SOURCE);\n\tcsis_fmt = find_csis_format(fmt->code);\n\tv4l2_subdev_unlock_state(state);\n\n\tif (!csis_fmt)\n\t\treturn -EPIPE;\n\n\tfd->type = V4L2_MBUS_FRAME_DESC_TYPE_PARALLEL;\n\tfd->num_entries = 1;\n\n\tmemset(entry, 0, sizeof(*entry));\n\n\tentry->flags = 0;\n\tentry->pixelcode = csis_fmt->code;\n\tentry->bus.csi2.vc = 0;\n\tentry->bus.csi2.dt = csis_fmt->data_type;\n\n\treturn 0;\n}\n\nstatic int mipi_csis_init_cfg(struct v4l2_subdev *sd,\n\t\t\t      struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_subdev_format fmt = {\n\t\t.pad = CSIS_PAD_SINK,\n\t};\n\n\tfmt.format.code = mipi_csis_formats[0].code;\n\tfmt.format.width = MIPI_CSIS_DEF_PIX_WIDTH;\n\tfmt.format.height = MIPI_CSIS_DEF_PIX_HEIGHT;\n\n\tfmt.format.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tfmt.format.xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt.format.colorspace);\n\tfmt.format.ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt.format.colorspace);\n\tfmt.format.quantization =\n\t\tV4L2_MAP_QUANTIZATION_DEFAULT(false, fmt.format.colorspace,\n\t\t\t\t\t      fmt.format.ycbcr_enc);\n\n\treturn mipi_csis_set_fmt(sd, sd_state, &fmt);\n}\n\nstatic int mipi_csis_log_status(struct v4l2_subdev *sd)\n{\n\tstruct mipi_csis_device *csis = sd_to_mipi_csis_device(sd);\n\n\tmipi_csis_log_counters(csis, true);\n\tif (csis->debug.enable)\n\t\tmipi_csis_dump_regs(csis);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_core_ops mipi_csis_core_ops = {\n\t.log_status\t= mipi_csis_log_status,\n};\n\nstatic const struct v4l2_subdev_video_ops mipi_csis_video_ops = {\n\t.s_stream\t= mipi_csis_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops mipi_csis_pad_ops = {\n\t.init_cfg\t\t= mipi_csis_init_cfg,\n\t.enum_mbus_code\t\t= mipi_csis_enum_mbus_code,\n\t.get_fmt\t\t= v4l2_subdev_get_fmt,\n\t.set_fmt\t\t= mipi_csis_set_fmt,\n\t.get_frame_desc\t\t= mipi_csis_get_frame_desc,\n};\n\nstatic const struct v4l2_subdev_ops mipi_csis_subdev_ops = {\n\t.core\t= &mipi_csis_core_ops,\n\t.video\t= &mipi_csis_video_ops,\n\t.pad\t= &mipi_csis_pad_ops,\n};\n\n \n\nstatic int mipi_csis_link_setup(struct media_entity *entity,\n\t\t\t\tconst struct media_pad *local_pad,\n\t\t\t\tconst struct media_pad *remote_pad, u32 flags)\n{\n\tstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\n\tstruct mipi_csis_device *csis = sd_to_mipi_csis_device(sd);\n\tstruct v4l2_subdev *remote_sd;\n\n\tdev_dbg(csis->dev, \"link setup %s -> %s\", remote_pad->entity->name,\n\t\tlocal_pad->entity->name);\n\n\t \n\tif (!(local_pad->flags & MEDIA_PAD_FL_SINK))\n\t\treturn 0;\n\n\tremote_sd = media_entity_to_v4l2_subdev(remote_pad->entity);\n\n\tif (flags & MEDIA_LNK_FL_ENABLED) {\n\t\tif (csis->src_sd)\n\t\t\treturn -EBUSY;\n\n\t\tcsis->src_sd = remote_sd;\n\t} else {\n\t\tcsis->src_sd = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct media_entity_operations mipi_csis_entity_ops = {\n\t.link_setup\t= mipi_csis_link_setup,\n\t.link_validate\t= v4l2_subdev_link_validate,\n\t.get_fwnode_pad = v4l2_subdev_get_fwnode_pad_1_to_1,\n};\n\n \n\nstatic struct mipi_csis_device *\nmipi_notifier_to_csis_state(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct mipi_csis_device, notifier);\n}\n\nstatic int mipi_csis_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t  struct v4l2_subdev *sd,\n\t\t\t\t  struct v4l2_async_connection *asd)\n{\n\tstruct mipi_csis_device *csis = mipi_notifier_to_csis_state(notifier);\n\tstruct media_pad *sink = &csis->sd.entity.pads[CSIS_PAD_SINK];\n\n\treturn v4l2_create_fwnode_links_to_pad(sd, sink, 0);\n}\n\nstatic const struct v4l2_async_notifier_operations mipi_csis_notify_ops = {\n\t.bound = mipi_csis_notify_bound,\n};\n\nstatic int mipi_csis_async_register(struct mipi_csis_device *csis)\n{\n\tstruct v4l2_fwnode_endpoint vep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tstruct v4l2_async_connection *asd;\n\tstruct fwnode_handle *ep;\n\tunsigned int i;\n\tint ret;\n\n\tv4l2_async_subdev_nf_init(&csis->notifier, &csis->sd);\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(csis->dev), 0, 0,\n\t\t\t\t\t     FWNODE_GRAPH_ENDPOINT_NEXT);\n\tif (!ep)\n\t\treturn -ENOTCONN;\n\n\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\tif (ret)\n\t\tgoto err_parse;\n\n\tfor (i = 0; i < vep.bus.mipi_csi2.num_data_lanes; ++i) {\n\t\tif (vep.bus.mipi_csi2.data_lanes[i] != i + 1) {\n\t\t\tdev_err(csis->dev,\n\t\t\t\t\"data lanes reordering is not supported\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_parse;\n\t\t}\n\t}\n\n\tcsis->bus = vep.bus.mipi_csi2;\n\n\tdev_dbg(csis->dev, \"data lanes: %d\\n\", csis->bus.num_data_lanes);\n\tdev_dbg(csis->dev, \"flags: 0x%08x\\n\", csis->bus.flags);\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&csis->notifier, ep,\n\t\t\t\t\t      struct v4l2_async_connection);\n\tif (IS_ERR(asd)) {\n\t\tret = PTR_ERR(asd);\n\t\tgoto err_parse;\n\t}\n\n\tfwnode_handle_put(ep);\n\n\tcsis->notifier.ops = &mipi_csis_notify_ops;\n\n\tret = v4l2_async_nf_register(&csis->notifier);\n\tif (ret)\n\t\treturn ret;\n\n\treturn v4l2_async_register_subdev(&csis->sd);\n\nerr_parse:\n\tfwnode_handle_put(ep);\n\n\treturn ret;\n}\n\n \n\nstatic int __maybe_unused mipi_csis_runtime_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct mipi_csis_device *csis = sd_to_mipi_csis_device(sd);\n\tint ret;\n\n\tret = mipi_csis_phy_disable(csis);\n\tif (ret)\n\t\treturn -EAGAIN;\n\n\tmipi_csis_clk_disable(csis);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mipi_csis_runtime_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct mipi_csis_device *csis = sd_to_mipi_csis_device(sd);\n\tint ret;\n\n\tret = mipi_csis_phy_enable(csis);\n\tif (ret)\n\t\treturn -EAGAIN;\n\n\tret = mipi_csis_clk_enable(csis);\n\tif (ret) {\n\t\tmipi_csis_phy_disable(csis);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mipi_csis_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mipi_csis_runtime_suspend, mipi_csis_runtime_resume,\n\t\t\t   NULL)\n};\n\n \n\nstatic int mipi_csis_subdev_init(struct mipi_csis_device *csis)\n{\n\tstruct v4l2_subdev *sd = &csis->sd;\n\tint ret;\n\n\tv4l2_subdev_init(sd, &mipi_csis_subdev_ops);\n\tsd->owner = THIS_MODULE;\n\tsnprintf(sd->name, sizeof(sd->name), \"csis-%s\",\n\t\t dev_name(csis->dev));\n\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsd->ctrl_handler = NULL;\n\n\tsd->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tsd->entity.ops = &mipi_csis_entity_ops;\n\n\tsd->dev = csis->dev;\n\n\tcsis->pads[CSIS_PAD_SINK].flags = MEDIA_PAD_FL_SINK\n\t\t\t\t\t | MEDIA_PAD_FL_MUST_CONNECT;\n\tcsis->pads[CSIS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE\n\t\t\t\t\t   | MEDIA_PAD_FL_MUST_CONNECT;\n\tret = media_entity_pads_init(&sd->entity, CSIS_PADS_NUM, csis->pads);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_subdev_init_finalize(sd);\n\tif (ret) {\n\t\tmedia_entity_cleanup(&sd->entity);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mipi_csis_parse_dt(struct mipi_csis_device *csis)\n{\n\tstruct device_node *node = csis->dev->of_node;\n\n\tif (of_property_read_u32(node, \"clock-frequency\",\n\t\t\t\t &csis->clk_frequency))\n\t\tcsis->clk_frequency = DEFAULT_SCLK_CSIS_FREQ;\n\n\treturn 0;\n}\n\nstatic int mipi_csis_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mipi_csis_device *csis;\n\tint irq;\n\tint ret;\n\n\tcsis = devm_kzalloc(dev, sizeof(*csis), GFP_KERNEL);\n\tif (!csis)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&csis->slock);\n\n\tcsis->dev = dev;\n\tcsis->info = of_device_get_match_data(dev);\n\n\tmemcpy(csis->events, mipi_csis_events, sizeof(csis->events));\n\n\t \n\tret = mipi_csis_parse_dt(csis);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to parse device tree: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcsis->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(csis->regs))\n\t\treturn PTR_ERR(csis->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = mipi_csis_phy_init(csis);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mipi_csis_clk_get(csis);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmipi_csis_phy_reset(csis);\n\n\t \n\tret = devm_request_irq(dev, irq, mipi_csis_irq_handler, 0,\n\t\t\t       dev_name(dev), csis);\n\tif (ret) {\n\t\tdev_err(dev, \"Interrupt request failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = mipi_csis_subdev_init(csis);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, &csis->sd);\n\n\tret = mipi_csis_async_register(csis);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"async register failed: %d\\n\", ret);\n\t\tgoto err_cleanup;\n\t}\n\n\t \n\tmipi_csis_debugfs_init(csis);\n\n\t \n\tpm_runtime_enable(dev);\n\tif (!pm_runtime_enabled(dev)) {\n\t\tret = mipi_csis_runtime_resume(dev);\n\t\tif (ret < 0)\n\t\t\tgoto err_unregister_all;\n\t}\n\n\tdev_info(dev, \"lanes: %d, freq: %u\\n\",\n\t\t csis->bus.num_data_lanes, csis->clk_frequency);\n\n\treturn 0;\n\nerr_unregister_all:\n\tmipi_csis_debugfs_exit(csis);\nerr_cleanup:\n\tv4l2_subdev_cleanup(&csis->sd);\n\tmedia_entity_cleanup(&csis->sd.entity);\n\tv4l2_async_nf_unregister(&csis->notifier);\n\tv4l2_async_nf_cleanup(&csis->notifier);\n\tv4l2_async_unregister_subdev(&csis->sd);\n\n\treturn ret;\n}\n\nstatic void mipi_csis_remove(struct platform_device *pdev)\n{\n\tstruct v4l2_subdev *sd = platform_get_drvdata(pdev);\n\tstruct mipi_csis_device *csis = sd_to_mipi_csis_device(sd);\n\n\tmipi_csis_debugfs_exit(csis);\n\tv4l2_async_nf_unregister(&csis->notifier);\n\tv4l2_async_nf_cleanup(&csis->notifier);\n\tv4l2_async_unregister_subdev(&csis->sd);\n\n\tif (!pm_runtime_enabled(&pdev->dev))\n\t\tmipi_csis_runtime_suspend(&pdev->dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tv4l2_subdev_cleanup(&csis->sd);\n\tmedia_entity_cleanup(&csis->sd.entity);\n\tpm_runtime_set_suspended(&pdev->dev);\n}\n\nstatic const struct of_device_id mipi_csis_of_match[] = {\n\t{\n\t\t.compatible = \"fsl,imx7-mipi-csi2\",\n\t\t.data = &(const struct mipi_csis_info){\n\t\t\t.version = MIPI_CSIS_V3_3,\n\t\t\t.num_clocks = 3,\n\t\t},\n\t}, {\n\t\t.compatible = \"fsl,imx8mm-mipi-csi2\",\n\t\t.data = &(const struct mipi_csis_info){\n\t\t\t.version = MIPI_CSIS_V3_6_3,\n\t\t\t.num_clocks = 4,\n\t\t},\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, mipi_csis_of_match);\n\nstatic struct platform_driver mipi_csis_driver = {\n\t.probe\t\t= mipi_csis_probe,\n\t.remove_new\t= mipi_csis_remove,\n\t.driver\t\t= {\n\t\t.of_match_table = mipi_csis_of_match,\n\t\t.name\t\t= CSIS_DRIVER_NAME,\n\t\t.pm\t\t= &mipi_csis_pm_ops,\n\t},\n};\n\nmodule_platform_driver(mipi_csis_driver);\n\nMODULE_DESCRIPTION(\"i.MX7 & i.MX8 MIPI CSI-2 receiver driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:imx-mipi-csi2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}