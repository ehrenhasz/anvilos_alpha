{
  "module_name": "imx8mq-mipi-csi2.c",
  "hash_id": "1c62f053593130f836eba430ce0bf39e1eea572bb2aa6da0fb5426bd0998063e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/imx8mq-mipi-csi2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/interconnect.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fwnode.h>\n#include <media/v4l2-mc.h>\n#include <media/v4l2-subdev.h>\n\n#define MIPI_CSI2_DRIVER_NAME\t\t\t\"imx8mq-mipi-csi2\"\n#define MIPI_CSI2_SUBDEV_NAME\t\t\tMIPI_CSI2_DRIVER_NAME\n\n#define MIPI_CSI2_PAD_SINK\t\t\t0\n#define MIPI_CSI2_PAD_SOURCE\t\t\t1\n#define MIPI_CSI2_PADS_NUM\t\t\t2\n\n#define MIPI_CSI2_DEF_PIX_WIDTH\t\t\t640\n#define MIPI_CSI2_DEF_PIX_HEIGHT\t\t480\n\n \n\n \n#define CSI2RX_CFG_NUM_LANES\t\t\t0x100\n#define CSI2RX_CFG_DISABLE_DATA_LANES\t\t0x104\n#define CSI2RX_BIT_ERR\t\t\t\t0x108\n#define CSI2RX_IRQ_STATUS\t\t\t0x10c\n#define CSI2RX_IRQ_MASK\t\t\t\t0x110\n#define CSI2RX_IRQ_MASK_ALL\t\t\t0x1ff\n#define CSI2RX_IRQ_MASK_ULPS_STATUS_CHANGE\t0x8\n#define CSI2RX_ULPS_STATUS\t\t\t0x114\n#define CSI2RX_PPI_ERRSOT_HS\t\t\t0x118\n#define CSI2RX_PPI_ERRSOTSYNC_HS\t\t0x11c\n#define CSI2RX_PPI_ERRESC\t\t\t0x120\n#define CSI2RX_PPI_ERRSYNCESC\t\t\t0x124\n#define CSI2RX_PPI_ERRCONTROL\t\t\t0x128\n#define CSI2RX_CFG_DISABLE_PAYLOAD_0\t\t0x12c\n#define CSI2RX_CFG_VID_VC_IGNORE\t\t0x180\n#define CSI2RX_CFG_VID_VC\t\t\t0x184\n#define CSI2RX_CFG_VID_P_FIFO_SEND_LEVEL\t0x188\n#define CSI2RX_CFG_DISABLE_PAYLOAD_1\t\t0x130\n\nenum {\n\tST_POWERED\t= 1,\n\tST_STREAMING\t= 2,\n\tST_SUSPENDED\t= 4,\n};\n\nenum imx8mq_mipi_csi_clk {\n\tCSI2_CLK_CORE,\n\tCSI2_CLK_ESC,\n\tCSI2_CLK_UI,\n\tCSI2_NUM_CLKS,\n};\n\nstatic const char * const imx8mq_mipi_csi_clk_id[CSI2_NUM_CLKS] = {\n\t[CSI2_CLK_CORE] = \"core\",\n\t[CSI2_CLK_ESC] = \"esc\",\n\t[CSI2_CLK_UI] = \"ui\",\n};\n\n#define CSI2_NUM_CLKS\tARRAY_SIZE(imx8mq_mipi_csi_clk_id)\n\n#define\tGPR_CSI2_1_RX_ENABLE\t\tBIT(13)\n#define\tGPR_CSI2_1_VID_INTFC_ENB\tBIT(12)\n#define\tGPR_CSI2_1_HSEL\t\t\tBIT(10)\n#define\tGPR_CSI2_1_CONT_CLK_MODE\tBIT(8)\n#define\tGPR_CSI2_1_S_PRG_RXHS_SETTLE(x)\t(((x) & 0x3f) << 2)\n\n \n#define CSI2RX_SEND_LEVEL\t\t\t64\n\nstruct csi_state {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct clk_bulk_data clks[CSI2_NUM_CLKS];\n\tstruct reset_control *rst;\n\tstruct regulator *mipi_phy_regulator;\n\n\tstruct v4l2_subdev sd;\n\tstruct media_pad pads[MIPI_CSI2_PADS_NUM];\n\tstruct v4l2_async_notifier notifier;\n\tstruct v4l2_subdev *src_sd;\n\n\tstruct v4l2_mbus_config_mipi_csi2 bus;\n\n\tstruct mutex lock;  \n\tu32 state;\n\n\tstruct regmap *phy_gpr;\n\tu8 phy_gpr_reg;\n\n\tstruct icc_path\t\t\t*icc_path;\n\ts32\t\t\t\ticc_path_bw;\n};\n\n \n\nstruct csi2_pix_format {\n\tu32 code;\n\tu8 width;\n};\n\nstatic const struct csi2_pix_format imx8mq_mipi_csi_formats[] = {\n\t \n\t{\n\t\t.code = MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.width = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.width = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.width = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.width = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_Y8_1X8,\n\t\t.width = 8,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.width = 10,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.width = 10,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.width = 10,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.width = 10,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_Y10_1X10,\n\t\t.width = 10,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.width = 12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.width = 12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.width = 12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.width = 12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_Y12_1X12,\n\t\t.width = 12,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SBGGR14_1X14,\n\t\t.width = 14,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGBRG14_1X14,\n\t\t.width = 14,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SGRBG14_1X14,\n\t\t.width = 14,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_SRGGB14_1X14,\n\t\t.width = 14,\n\t},\n\t \n\t{\n\t\t.code = MEDIA_BUS_FMT_YUYV8_1X16,\n\t\t.width = 16,\n\t}, {\n\t\t.code = MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.width = 16,\n\t}\n};\n\nstatic const struct csi2_pix_format *find_csi2_format(u32 code)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx8mq_mipi_csi_formats); i++)\n\t\tif (code == imx8mq_mipi_csi_formats[i].code)\n\t\t\treturn &imx8mq_mipi_csi_formats[i];\n\treturn NULL;\n}\n\n \n\nstatic inline void imx8mq_mipi_csi_write(struct csi_state *state, u32 reg, u32 val)\n{\n\twritel(val, state->regs + reg);\n}\n\nstatic int imx8mq_mipi_csi_sw_reset(struct csi_state *state)\n{\n\tint ret;\n\n\t \n\tret = reset_control_assert(state->rst);\n\tif (ret < 0) {\n\t\tdev_err(state->dev, \"Failed to assert resets: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void imx8mq_mipi_csi_set_params(struct csi_state *state)\n{\n\tint lanes = state->bus.num_data_lanes;\n\n\timx8mq_mipi_csi_write(state, CSI2RX_CFG_NUM_LANES, lanes - 1);\n\timx8mq_mipi_csi_write(state, CSI2RX_CFG_DISABLE_DATA_LANES,\n\t\t\t      (0xf << lanes) & 0xf);\n\timx8mq_mipi_csi_write(state, CSI2RX_IRQ_MASK, CSI2RX_IRQ_MASK_ALL);\n\t \n\timx8mq_mipi_csi_write(state, CSI2RX_CFG_VID_VC_IGNORE, 1);\n\timx8mq_mipi_csi_write(state, CSI2RX_CFG_VID_P_FIFO_SEND_LEVEL,\n\t\t\t      CSI2RX_SEND_LEVEL);\n}\n\nstatic int imx8mq_mipi_csi_clk_enable(struct csi_state *state)\n{\n\treturn clk_bulk_prepare_enable(CSI2_NUM_CLKS, state->clks);\n}\n\nstatic void imx8mq_mipi_csi_clk_disable(struct csi_state *state)\n{\n\tclk_bulk_disable_unprepare(CSI2_NUM_CLKS, state->clks);\n}\n\nstatic int imx8mq_mipi_csi_clk_get(struct csi_state *state)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < CSI2_NUM_CLKS; i++)\n\t\tstate->clks[i].id = imx8mq_mipi_csi_clk_id[i];\n\n\treturn devm_clk_bulk_get(state->dev, CSI2_NUM_CLKS, state->clks);\n}\n\nstatic int imx8mq_mipi_csi_calc_hs_settle(struct csi_state *state,\n\t\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t\t  u32 *hs_settle)\n{\n\ts64 link_freq;\n\tu32 lane_rate;\n\tunsigned long esc_clk_rate;\n\tu32 min_ths_settle, max_ths_settle, ths_settle_ns, esc_clk_period_ns;\n\tconst struct v4l2_mbus_framefmt *fmt;\n\tconst struct csi2_pix_format *csi2_fmt;\n\n\t \n\n\tfmt = v4l2_subdev_get_pad_format(&state->sd, sd_state, MIPI_CSI2_PAD_SINK);\n\tcsi2_fmt = find_csi2_format(fmt->code);\n\n\tlink_freq = v4l2_get_link_freq(state->src_sd->ctrl_handler,\n\t\t\t\t       csi2_fmt->width,\n\t\t\t\t       state->bus.num_data_lanes * 2);\n\tif (link_freq < 0) {\n\t\tdev_err(state->dev, \"Unable to obtain link frequency: %d\\n\",\n\t\t\t(int)link_freq);\n\t\treturn link_freq;\n\t}\n\n\tlane_rate = link_freq * 2;\n\tif (lane_rate < 80000000 || lane_rate > 1500000000) {\n\t\tdev_dbg(state->dev, \"Out-of-bound lane rate %u\\n\", lane_rate);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tesc_clk_rate = clk_get_rate(state->clks[CSI2_CLK_ESC].clk);\n\tif (!esc_clk_rate) {\n\t\tdev_err(state->dev, \"Could not get esc clock rate.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(state->dev, \"esc clk rate: %lu\\n\", esc_clk_rate);\n\tesc_clk_period_ns = 1000000000 / esc_clk_rate;\n\n\tmin_ths_settle = 85 + 6 * 1000000 / (lane_rate / 1000);\n\tmax_ths_settle = 140 + 10 * 1000000 / (lane_rate / 1000);\n\tths_settle_ns = (min_ths_settle + max_ths_settle) / 2;\n\n\t*hs_settle = ths_settle_ns / esc_clk_period_ns - 1;\n\n\tdev_dbg(state->dev, \"lane rate %u Ths_settle %u hs_settle %u\\n\",\n\t\tlane_rate, ths_settle_ns, *hs_settle);\n\n\treturn 0;\n}\n\nstatic int imx8mq_mipi_csi_start_stream(struct csi_state *state,\n\t\t\t\t\tstruct v4l2_subdev_state *sd_state)\n{\n\tint ret;\n\tu32 hs_settle = 0;\n\n\tret = imx8mq_mipi_csi_sw_reset(state);\n\tif (ret)\n\t\treturn ret;\n\n\timx8mq_mipi_csi_set_params(state);\n\tret = imx8mq_mipi_csi_calc_hs_settle(state, sd_state, &hs_settle);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(state->phy_gpr,\n\t\t\t   state->phy_gpr_reg,\n\t\t\t   0x3fff,\n\t\t\t   GPR_CSI2_1_RX_ENABLE |\n\t\t\t   GPR_CSI2_1_VID_INTFC_ENB |\n\t\t\t   GPR_CSI2_1_HSEL |\n\t\t\t   GPR_CSI2_1_CONT_CLK_MODE |\n\t\t\t   GPR_CSI2_1_S_PRG_RXHS_SETTLE(hs_settle));\n\n\treturn 0;\n}\n\nstatic void imx8mq_mipi_csi_stop_stream(struct csi_state *state)\n{\n\timx8mq_mipi_csi_write(state, CSI2RX_CFG_DISABLE_DATA_LANES, 0xf);\n}\n\n \n\nstatic struct csi_state *mipi_sd_to_csi2_state(struct v4l2_subdev *sdev)\n{\n\treturn container_of(sdev, struct csi_state, sd);\n}\n\nstatic int imx8mq_mipi_csi_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct csi_state *state = mipi_sd_to_csi2_state(sd);\n\tstruct v4l2_subdev_state *sd_state;\n\tint ret = 0;\n\n\tif (enable) {\n\t\tret = pm_runtime_resume_and_get(state->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&state->lock);\n\n\tif (enable) {\n\t\tif (state->state & ST_SUSPENDED) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tsd_state = v4l2_subdev_lock_and_get_active_state(sd);\n\t\tret = imx8mq_mipi_csi_start_stream(state, sd_state);\n\t\tv4l2_subdev_unlock_state(sd_state);\n\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\n\t\tret = v4l2_subdev_call(state->src_sd, video, s_stream, 1);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\n\t\tstate->state |= ST_STREAMING;\n\t} else {\n\t\tv4l2_subdev_call(state->src_sd, video, s_stream, 0);\n\t\timx8mq_mipi_csi_stop_stream(state);\n\t\tstate->state &= ~ST_STREAMING;\n\t}\n\nunlock:\n\tmutex_unlock(&state->lock);\n\n\tif (!enable || ret < 0)\n\t\tpm_runtime_put(state->dev);\n\n\treturn ret;\n}\n\nstatic int imx8mq_mipi_csi_init_cfg(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *sd_state)\n{\n\tstruct v4l2_mbus_framefmt *fmt_sink;\n\tstruct v4l2_mbus_framefmt *fmt_source;\n\n\tfmt_sink = v4l2_subdev_get_pad_format(sd, sd_state, MIPI_CSI2_PAD_SINK);\n\tfmt_source = v4l2_subdev_get_pad_format(sd, sd_state, MIPI_CSI2_PAD_SOURCE);\n\n\tfmt_sink->code = MEDIA_BUS_FMT_SGBRG10_1X10;\n\tfmt_sink->width = MIPI_CSI2_DEF_PIX_WIDTH;\n\tfmt_sink->height = MIPI_CSI2_DEF_PIX_HEIGHT;\n\tfmt_sink->field = V4L2_FIELD_NONE;\n\n\tfmt_sink->colorspace = V4L2_COLORSPACE_RAW;\n\tfmt_sink->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt_sink->colorspace);\n\tfmt_sink->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt_sink->colorspace);\n\tfmt_sink->quantization =\n\t\tV4L2_MAP_QUANTIZATION_DEFAULT(false, fmt_sink->colorspace,\n\t\t\t\t\t      fmt_sink->ycbcr_enc);\n\n\t*fmt_source = *fmt_sink;\n\n\treturn 0;\n}\n\nstatic int imx8mq_mipi_csi_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t\t  struct v4l2_subdev_state *sd_state,\n\t\t\t\t\t  struct v4l2_subdev_mbus_code_enum *code)\n{\n\t \n\tif (code->pad == MIPI_CSI2_PAD_SOURCE) {\n\t\tstruct v4l2_mbus_framefmt *fmt;\n\n\t\tif (code->index > 0)\n\t\t\treturn -EINVAL;\n\n\t\tfmt = v4l2_subdev_get_pad_format(sd, sd_state, code->pad);\n\t\tcode->code = fmt->code;\n\t\treturn 0;\n\t}\n\n\tif (code->pad != MIPI_CSI2_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tif (code->index >= ARRAY_SIZE(imx8mq_mipi_csi_formats))\n\t\treturn -EINVAL;\n\n\tcode->code = imx8mq_mipi_csi_formats[code->index].code;\n\n\treturn 0;\n}\n\nstatic int imx8mq_mipi_csi_set_fmt(struct v4l2_subdev *sd,\n\t\t\t\t   struct v4l2_subdev_state *sd_state,\n\t\t\t\t   struct v4l2_subdev_format *sdformat)\n{\n\tconst struct csi2_pix_format *csi2_fmt;\n\tstruct v4l2_mbus_framefmt *fmt;\n\n\t \n\tif (sdformat->pad == MIPI_CSI2_PAD_SOURCE)\n\t\treturn v4l2_subdev_get_fmt(sd, sd_state, sdformat);\n\n\tif (sdformat->pad != MIPI_CSI2_PAD_SINK)\n\t\treturn -EINVAL;\n\n\tcsi2_fmt = find_csi2_format(sdformat->format.code);\n\tif (!csi2_fmt)\n\t\tcsi2_fmt = &imx8mq_mipi_csi_formats[0];\n\n\tfmt = v4l2_subdev_get_pad_format(sd, sd_state, sdformat->pad);\n\n\tfmt->code = csi2_fmt->code;\n\tfmt->width = sdformat->format.width;\n\tfmt->height = sdformat->format.height;\n\n\tsdformat->format = *fmt;\n\n\t \n\tfmt = v4l2_subdev_get_pad_format(sd, sd_state, MIPI_CSI2_PAD_SOURCE);\n\t*fmt = sdformat->format;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_video_ops imx8mq_mipi_csi_video_ops = {\n\t.s_stream\t= imx8mq_mipi_csi_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops imx8mq_mipi_csi_pad_ops = {\n\t.init_cfg\t\t= imx8mq_mipi_csi_init_cfg,\n\t.enum_mbus_code\t\t= imx8mq_mipi_csi_enum_mbus_code,\n\t.get_fmt\t\t= v4l2_subdev_get_fmt,\n\t.set_fmt\t\t= imx8mq_mipi_csi_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops imx8mq_mipi_csi_subdev_ops = {\n\t.video\t= &imx8mq_mipi_csi_video_ops,\n\t.pad\t= &imx8mq_mipi_csi_pad_ops,\n};\n\n \n\nstatic const struct media_entity_operations imx8mq_mipi_csi_entity_ops = {\n\t.link_validate\t= v4l2_subdev_link_validate,\n\t.get_fwnode_pad = v4l2_subdev_get_fwnode_pad_1_to_1,\n};\n\n \n\nstatic struct csi_state *\nmipi_notifier_to_csi2_state(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct csi_state, notifier);\n}\n\nstatic int imx8mq_mipi_csi_notify_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t\tstruct v4l2_subdev *sd,\n\t\t\t\t\tstruct v4l2_async_connection *asd)\n{\n\tstruct csi_state *state = mipi_notifier_to_csi2_state(notifier);\n\tstruct media_pad *sink = &state->sd.entity.pads[MIPI_CSI2_PAD_SINK];\n\n\tstate->src_sd = sd;\n\n\treturn v4l2_create_fwnode_links_to_pad(sd, sink, MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t       MEDIA_LNK_FL_IMMUTABLE);\n}\n\nstatic const struct v4l2_async_notifier_operations imx8mq_mipi_csi_notify_ops = {\n\t.bound = imx8mq_mipi_csi_notify_bound,\n};\n\nstatic int imx8mq_mipi_csi_async_register(struct csi_state *state)\n{\n\tstruct v4l2_fwnode_endpoint vep = {\n\t\t.bus_type = V4L2_MBUS_CSI2_DPHY,\n\t};\n\tstruct v4l2_async_connection *asd;\n\tstruct fwnode_handle *ep;\n\tunsigned int i;\n\tint ret;\n\n\tv4l2_async_subdev_nf_init(&state->notifier, &state->sd);\n\n\tep = fwnode_graph_get_endpoint_by_id(dev_fwnode(state->dev), 0, 0,\n\t\t\t\t\t     FWNODE_GRAPH_ENDPOINT_NEXT);\n\tif (!ep)\n\t\treturn -ENOTCONN;\n\n\tret = v4l2_fwnode_endpoint_parse(ep, &vep);\n\tif (ret)\n\t\tgoto err_parse;\n\n\tfor (i = 0; i < vep.bus.mipi_csi2.num_data_lanes; ++i) {\n\t\tif (vep.bus.mipi_csi2.data_lanes[i] != i + 1) {\n\t\t\tdev_err(state->dev,\n\t\t\t\t\"data lanes reordering is not supported\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_parse;\n\t\t}\n\t}\n\n\tstate->bus = vep.bus.mipi_csi2;\n\n\tdev_dbg(state->dev, \"data lanes: %d flags: 0x%08x\\n\",\n\t\tstate->bus.num_data_lanes,\n\t\tstate->bus.flags);\n\n\tasd = v4l2_async_nf_add_fwnode_remote(&state->notifier, ep,\n\t\t\t\t\t      struct v4l2_async_connection);\n\tif (IS_ERR(asd)) {\n\t\tret = PTR_ERR(asd);\n\t\tgoto err_parse;\n\t}\n\n\tfwnode_handle_put(ep);\n\n\tstate->notifier.ops = &imx8mq_mipi_csi_notify_ops;\n\n\tret = v4l2_async_nf_register(&state->notifier);\n\tif (ret)\n\t\treturn ret;\n\n\treturn v4l2_async_register_subdev(&state->sd);\n\nerr_parse:\n\tfwnode_handle_put(ep);\n\n\treturn ret;\n}\n\n \n\nstatic void imx8mq_mipi_csi_pm_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct csi_state *state = mipi_sd_to_csi2_state(sd);\n\n\tmutex_lock(&state->lock);\n\n\tif (state->state & ST_POWERED) {\n\t\timx8mq_mipi_csi_stop_stream(state);\n\t\timx8mq_mipi_csi_clk_disable(state);\n\t\tstate->state &= ~ST_POWERED;\n\t}\n\n\tmutex_unlock(&state->lock);\n}\n\nstatic int imx8mq_mipi_csi_pm_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct csi_state *state = mipi_sd_to_csi2_state(sd);\n\tstruct v4l2_subdev_state *sd_state;\n\tint ret = 0;\n\n\tmutex_lock(&state->lock);\n\n\tif (!(state->state & ST_POWERED)) {\n\t\tstate->state |= ST_POWERED;\n\t\tret = imx8mq_mipi_csi_clk_enable(state);\n\t}\n\tif (state->state & ST_STREAMING) {\n\t\tsd_state = v4l2_subdev_lock_and_get_active_state(sd);\n\t\tret = imx8mq_mipi_csi_start_stream(state, sd_state);\n\t\tv4l2_subdev_unlock_state(sd_state);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tstate->state &= ~ST_SUSPENDED;\n\nunlock:\n\tmutex_unlock(&state->lock);\n\n\treturn ret ? -EAGAIN : 0;\n}\n\nstatic int __maybe_unused imx8mq_mipi_csi_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct csi_state *state = mipi_sd_to_csi2_state(sd);\n\n\timx8mq_mipi_csi_pm_suspend(dev);\n\n\tstate->state |= ST_SUSPENDED;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx8mq_mipi_csi_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct csi_state *state = mipi_sd_to_csi2_state(sd);\n\n\tif (!(state->state & ST_SUSPENDED))\n\t\treturn 0;\n\n\treturn imx8mq_mipi_csi_pm_resume(dev);\n}\n\nstatic int __maybe_unused imx8mq_mipi_csi_runtime_suspend(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct csi_state *state = mipi_sd_to_csi2_state(sd);\n\tint ret;\n\n\timx8mq_mipi_csi_pm_suspend(dev);\n\n\tret = icc_set_bw(state->icc_path, 0, 0);\n\tif (ret)\n\t\tdev_err(dev, \"icc_set_bw failed with %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused imx8mq_mipi_csi_runtime_resume(struct device *dev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(dev);\n\tstruct csi_state *state = mipi_sd_to_csi2_state(sd);\n\tint ret;\n\n\tret = icc_set_bw(state->icc_path, 0, state->icc_path_bw);\n\tif (ret) {\n\t\tdev_err(dev, \"icc_set_bw failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn imx8mq_mipi_csi_pm_resume(dev);\n}\n\nstatic const struct dev_pm_ops imx8mq_mipi_csi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(imx8mq_mipi_csi_runtime_suspend,\n\t\t\t   imx8mq_mipi_csi_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(imx8mq_mipi_csi_suspend, imx8mq_mipi_csi_resume)\n};\n\n \n\nstatic int imx8mq_mipi_csi_subdev_init(struct csi_state *state)\n{\n\tstruct v4l2_subdev *sd = &state->sd;\n\tint ret;\n\n\tv4l2_subdev_init(sd, &imx8mq_mipi_csi_subdev_ops);\n\tsd->owner = THIS_MODULE;\n\tsnprintf(sd->name, sizeof(sd->name), \"%s %s\",\n\t\t MIPI_CSI2_SUBDEV_NAME, dev_name(state->dev));\n\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\n\tsd->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;\n\tsd->entity.ops = &imx8mq_mipi_csi_entity_ops;\n\n\tsd->dev = state->dev;\n\n\tstate->pads[MIPI_CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK\n\t\t\t\t\t | MEDIA_PAD_FL_MUST_CONNECT;\n\tstate->pads[MIPI_CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE\n\t\t\t\t\t   | MEDIA_PAD_FL_MUST_CONNECT;\n\tret = media_entity_pads_init(&sd->entity, MIPI_CSI2_PADS_NUM,\n\t\t\t\t     state->pads);\n\tif (ret)\n\t\treturn ret;\n\n\tret = v4l2_subdev_init_finalize(sd);\n\tif (ret) {\n\t\tmedia_entity_cleanup(&sd->entity);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void imx8mq_mipi_csi_release_icc(struct platform_device *pdev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(&pdev->dev);\n\tstruct csi_state *state = mipi_sd_to_csi2_state(sd);\n\n\ticc_put(state->icc_path);\n}\n\nstatic int imx8mq_mipi_csi_init_icc(struct platform_device *pdev)\n{\n\tstruct v4l2_subdev *sd = dev_get_drvdata(&pdev->dev);\n\tstruct csi_state *state = mipi_sd_to_csi2_state(sd);\n\n\t \n\tstate->icc_path = of_icc_get(&pdev->dev, \"dram\");\n\tif (IS_ERR_OR_NULL(state->icc_path))\n\t\treturn PTR_ERR_OR_ZERO(state->icc_path);\n\n\tstate->icc_path_bw = MBps_to_icc(700);\n\n\treturn 0;\n}\n\nstatic int imx8mq_mipi_csi_parse_dt(struct csi_state *state)\n{\n\tstruct device *dev = state->dev;\n\tstruct device_node *np = state->dev->of_node;\n\tstruct device_node *node;\n\tphandle ph;\n\tu32 out_val[2];\n\tint ret = 0;\n\n\tstate->rst = devm_reset_control_array_get_exclusive(dev);\n\tif (IS_ERR(state->rst)) {\n\t\tdev_err(dev, \"Failed to get reset: %pe\\n\", state->rst);\n\t\treturn PTR_ERR(state->rst);\n\t}\n\n\tret = of_property_read_u32_array(np, \"fsl,mipi-phy-gpr\", out_val,\n\t\t\t\t\t ARRAY_SIZE(out_val));\n\tif (ret) {\n\t\tdev_err(dev, \"no fsl,mipi-phy-gpr property found: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tph = *out_val;\n\n\tnode = of_find_node_by_phandle(ph);\n\tif (!node) {\n\t\tdev_err(dev, \"Error finding node by phandle\\n\");\n\t\treturn -ENODEV;\n\t}\n\tstate->phy_gpr = syscon_node_to_regmap(node);\n\tof_node_put(node);\n\tif (IS_ERR(state->phy_gpr)) {\n\t\tdev_err(dev, \"failed to get gpr regmap: %pe\\n\", state->phy_gpr);\n\t\treturn PTR_ERR(state->phy_gpr);\n\t}\n\n\tstate->phy_gpr_reg = out_val[1];\n\tdev_dbg(dev, \"phy gpr register set to 0x%x\\n\", state->phy_gpr_reg);\n\n\treturn ret;\n}\n\nstatic int imx8mq_mipi_csi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct csi_state *state;\n\tint ret;\n\n\tstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->dev = dev;\n\n\tret = imx8mq_mipi_csi_parse_dt(state);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to parse device tree: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tstate->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(state->regs))\n\t\treturn PTR_ERR(state->regs);\n\n\tret = imx8mq_mipi_csi_clk_get(state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, &state->sd);\n\n\tmutex_init(&state->lock);\n\n\tret = imx8mq_mipi_csi_subdev_init(state);\n\tif (ret < 0)\n\t\tgoto mutex;\n\n\tret = imx8mq_mipi_csi_init_icc(pdev);\n\tif (ret)\n\t\tgoto mutex;\n\n\t \n\tpm_runtime_enable(dev);\n\tif (!pm_runtime_enabled(dev)) {\n\t\tret = imx8mq_mipi_csi_runtime_resume(dev);\n\t\tif (ret < 0)\n\t\t\tgoto icc;\n\t}\n\n\tret = imx8mq_mipi_csi_async_register(state);\n\tif (ret < 0)\n\t\tgoto cleanup;\n\n\treturn 0;\n\ncleanup:\n\tpm_runtime_disable(&pdev->dev);\n\timx8mq_mipi_csi_runtime_suspend(&pdev->dev);\n\n\tmedia_entity_cleanup(&state->sd.entity);\n\tv4l2_subdev_cleanup(&state->sd);\n\tv4l2_async_nf_unregister(&state->notifier);\n\tv4l2_async_nf_cleanup(&state->notifier);\n\tv4l2_async_unregister_subdev(&state->sd);\nicc:\n\timx8mq_mipi_csi_release_icc(pdev);\nmutex:\n\tmutex_destroy(&state->lock);\n\n\treturn ret;\n}\n\nstatic void imx8mq_mipi_csi_remove(struct platform_device *pdev)\n{\n\tstruct v4l2_subdev *sd = platform_get_drvdata(pdev);\n\tstruct csi_state *state = mipi_sd_to_csi2_state(sd);\n\n\tv4l2_async_nf_unregister(&state->notifier);\n\tv4l2_async_nf_cleanup(&state->notifier);\n\tv4l2_async_unregister_subdev(&state->sd);\n\n\tpm_runtime_disable(&pdev->dev);\n\timx8mq_mipi_csi_runtime_suspend(&pdev->dev);\n\tmedia_entity_cleanup(&state->sd.entity);\n\tv4l2_subdev_cleanup(&state->sd);\n\tmutex_destroy(&state->lock);\n\tpm_runtime_set_suspended(&pdev->dev);\n\timx8mq_mipi_csi_release_icc(pdev);\n}\n\nstatic const struct of_device_id imx8mq_mipi_csi_of_match[] = {\n\t{ .compatible = \"fsl,imx8mq-mipi-csi2\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, imx8mq_mipi_csi_of_match);\n\nstatic struct platform_driver imx8mq_mipi_csi_driver = {\n\t.probe\t\t= imx8mq_mipi_csi_probe,\n\t.remove_new\t= imx8mq_mipi_csi_remove,\n\t.driver\t\t= {\n\t\t.of_match_table = imx8mq_mipi_csi_of_match,\n\t\t.name\t\t= MIPI_CSI2_DRIVER_NAME,\n\t\t.pm\t\t= &imx8mq_mipi_csi_pm_ops,\n\t},\n};\n\nmodule_platform_driver(imx8mq_mipi_csi_driver);\n\nMODULE_DESCRIPTION(\"i.MX8MQ MIPI CSI-2 receiver driver\");\nMODULE_AUTHOR(\"Martin Kepplinger <martin.kepplinger@puri.sm>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:imx8mq-mipi-csi2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}