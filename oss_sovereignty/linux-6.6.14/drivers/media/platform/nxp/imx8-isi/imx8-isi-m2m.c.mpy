{
  "module_name": "imx8-isi-m2m.c",
  "hash_id": "6ba8be35eac841faa9fb0dc91a9730a734b5bc2f1ec13bd3576ca1b3e7f5f403",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/imx8-isi/imx8-isi-m2m.c",
  "human_readable_source": "\n \n\n#include <linux/container_of.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/limits.h>\n#include <linux/minmax.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n\n#include <media/media-entity.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-core.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"imx8-isi-core.h\"\n\nstruct mxc_isi_m2m_buffer {\n\tstruct v4l2_m2m_buffer buf;\n\tdma_addr_t dma_addrs[3];\n};\n\nstruct mxc_isi_m2m_ctx_queue_data {\n\tstruct v4l2_pix_format_mplane format;\n\tconst struct mxc_isi_format_info *info;\n\tu32 sequence;\n};\n\nstruct mxc_isi_m2m_ctx {\n\tstruct v4l2_fh fh;\n\tstruct mxc_isi_m2m *m2m;\n\n\t \n\tstruct mutex vb2_lock;\n\n\tstruct {\n\t\tstruct mxc_isi_m2m_ctx_queue_data out;\n\t\tstruct mxc_isi_m2m_ctx_queue_data cap;\n\t} queues;\n\n\tstruct {\n\t\tstruct v4l2_ctrl_handler handler;\n\t\tunsigned int alpha;\n\t\tbool hflip;\n\t\tbool vflip;\n\t} ctrls;\n\n\tbool chained;\n};\n\nstatic inline struct mxc_isi_m2m_buffer *\nto_isi_m2m_buffer(struct vb2_v4l2_buffer *buf)\n{\n\treturn container_of(buf, struct mxc_isi_m2m_buffer, buf.vb);\n}\n\nstatic inline struct mxc_isi_m2m_ctx *to_isi_m2m_ctx(struct v4l2_fh *fh)\n{\n\treturn container_of(fh, struct mxc_isi_m2m_ctx, fh);\n}\n\nstatic inline struct mxc_isi_m2m_ctx_queue_data *\nmxc_isi_m2m_ctx_qdata(struct mxc_isi_m2m_ctx *ctx, enum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn &ctx->queues.out;\n\telse\n\t\treturn &ctx->queues.cap;\n}\n\n \n\nstatic void mxc_isi_m2m_frame_write_done(struct mxc_isi_pipe *pipe, u32 status)\n{\n\tstruct mxc_isi_m2m *m2m = &pipe->isi->m2m;\n\tstruct vb2_v4l2_buffer *src_vbuf, *dst_vbuf;\n\tstruct mxc_isi_m2m_ctx *ctx;\n\n\tctx = v4l2_m2m_get_curr_priv(m2m->m2m_dev);\n\tif (!ctx) {\n\t\tdev_err(m2m->isi->dev,\n\t\t\t\"Instance released before the end of transaction\\n\");\n\t\treturn;\n\t}\n\n\tsrc_vbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst_vbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tv4l2_m2m_buf_copy_metadata(src_vbuf, dst_vbuf, false);\n\n\tsrc_vbuf->sequence = ctx->queues.out.sequence++;\n\tdst_vbuf->sequence = ctx->queues.cap.sequence++;\n\n\tv4l2_m2m_buf_done(src_vbuf, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst_vbuf, VB2_BUF_STATE_DONE);\n\n\tv4l2_m2m_job_finish(m2m->m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic void mxc_isi_m2m_device_run(void *priv)\n{\n\tstruct mxc_isi_m2m_ctx *ctx = priv;\n\tstruct mxc_isi_m2m *m2m = ctx->m2m;\n\tstruct vb2_v4l2_buffer *src_vbuf, *dst_vbuf;\n\tstruct mxc_isi_m2m_buffer *src_buf, *dst_buf;\n\n\tmxc_isi_channel_disable(m2m->pipe);\n\n\tmutex_lock(&m2m->lock);\n\n\t \n\tif (m2m->last_ctx != ctx) {\n\t\tconst struct v4l2_area in_size = {\n\t\t\t.width = ctx->queues.out.format.width,\n\t\t\t.height = ctx->queues.out.format.height,\n\t\t};\n\t\tconst struct v4l2_area scale = {\n\t\t\t.width = ctx->queues.cap.format.width,\n\t\t\t.height = ctx->queues.cap.format.height,\n\t\t};\n\t\tconst struct v4l2_rect crop = {\n\t\t\t.width = ctx->queues.cap.format.width,\n\t\t\t.height = ctx->queues.cap.format.height,\n\t\t};\n\n\t\tmxc_isi_channel_config(m2m->pipe, MXC_ISI_INPUT_MEM,\n\t\t\t\t       &in_size, &scale, &crop,\n\t\t\t\t       ctx->queues.out.info->encoding,\n\t\t\t\t       ctx->queues.cap.info->encoding);\n\t\tmxc_isi_channel_set_input_format(m2m->pipe,\n\t\t\t\t\t\t ctx->queues.out.info,\n\t\t\t\t\t\t &ctx->queues.out.format);\n\t\tmxc_isi_channel_set_output_format(m2m->pipe,\n\t\t\t\t\t\t  ctx->queues.cap.info,\n\t\t\t\t\t\t  &ctx->queues.cap.format);\n\n\t\tm2m->last_ctx = ctx;\n\t}\n\n\tmutex_unlock(&m2m->lock);\n\n\tmutex_lock(ctx->ctrls.handler.lock);\n\tmxc_isi_channel_set_alpha(m2m->pipe, ctx->ctrls.alpha);\n\tmxc_isi_channel_set_flip(m2m->pipe, ctx->ctrls.hflip, ctx->ctrls.vflip);\n\tmutex_unlock(ctx->ctrls.handler.lock);\n\n\tsrc_vbuf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_vbuf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\tsrc_buf = to_isi_m2m_buffer(src_vbuf);\n\tdst_buf = to_isi_m2m_buffer(dst_vbuf);\n\n\tmxc_isi_channel_set_inbuf(m2m->pipe, src_buf->dma_addrs[0]);\n\tmxc_isi_channel_set_outbuf(m2m->pipe, dst_buf->dma_addrs, MXC_ISI_BUF1);\n\tmxc_isi_channel_set_outbuf(m2m->pipe, dst_buf->dma_addrs, MXC_ISI_BUF2);\n\n\tmxc_isi_channel_enable(m2m->pipe);\n\n\tmxc_isi_channel_m2m_start(m2m->pipe);\n}\n\nstatic const struct v4l2_m2m_ops mxc_isi_m2m_ops = {\n\t.device_run = mxc_isi_m2m_device_run,\n};\n\n \n\nstatic int mxc_isi_m2m_vb2_queue_setup(struct vb2_queue *q,\n\t\t\t\t       unsigned int *num_buffers,\n\t\t\t\t       unsigned int *num_planes,\n\t\t\t\t       unsigned int sizes[],\n\t\t\t\t       struct device *alloc_devs[])\n{\n\tstruct mxc_isi_m2m_ctx *ctx = vb2_get_drv_priv(q);\n\tconst struct mxc_isi_m2m_ctx_queue_data *qdata =\n\t\tmxc_isi_m2m_ctx_qdata(ctx, q->type);\n\n\treturn mxc_isi_video_queue_setup(&qdata->format, qdata->info,\n\t\t\t\t\t num_buffers, num_planes, sizes);\n}\n\nstatic int mxc_isi_m2m_vb2_buffer_init(struct vb2_buffer *vb2)\n{\n\tstruct vb2_queue *vq = vb2->vb2_queue;\n\tstruct mxc_isi_m2m_buffer *buf = to_isi_m2m_buffer(to_vb2_v4l2_buffer(vb2));\n\tstruct mxc_isi_m2m_ctx *ctx = vb2_get_drv_priv(vb2->vb2_queue);\n\tconst struct mxc_isi_m2m_ctx_queue_data *qdata =\n\t\tmxc_isi_m2m_ctx_qdata(ctx, vq->type);\n\n\tmxc_isi_video_buffer_init(vb2, buf->dma_addrs, qdata->info,\n\t\t\t\t  &qdata->format);\n\n\treturn 0;\n}\n\nstatic int mxc_isi_m2m_vb2_buffer_prepare(struct vb2_buffer *vb2)\n{\n\tstruct vb2_queue *vq = vb2->vb2_queue;\n\tstruct mxc_isi_m2m_ctx *ctx = vb2_get_drv_priv(vq);\n\tconst struct mxc_isi_m2m_ctx_queue_data *qdata =\n\t\tmxc_isi_m2m_ctx_qdata(ctx, vq->type);\n\n\treturn mxc_isi_video_buffer_prepare(ctx->m2m->isi, vb2, qdata->info,\n\t\t\t\t\t    &qdata->format);\n}\n\nstatic void mxc_isi_m2m_vb2_buffer_queue(struct vb2_buffer *vb2)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2);\n\tstruct mxc_isi_m2m_ctx *ctx = vb2_get_drv_priv(vb2->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int mxc_isi_m2m_vb2_start_streaming(struct vb2_queue *q,\n\t\t\t\t\t   unsigned int count)\n{\n\tstruct mxc_isi_m2m_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct mxc_isi_m2m_ctx_queue_data *qdata =\n\t\tmxc_isi_m2m_ctx_qdata(ctx, q->type);\n\n\tqdata->sequence = 0;\n\n\treturn 0;\n}\n\nstatic void mxc_isi_m2m_vb2_stop_streaming(struct vb2_queue *q)\n{\n\tstruct mxc_isi_m2m_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tfor (;;) {\n\t\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (!vbuf)\n\t\t\tbreak;\n\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic const struct vb2_ops mxc_isi_m2m_vb2_qops = {\n\t.queue_setup\t\t= mxc_isi_m2m_vb2_queue_setup,\n\t.buf_init\t\t= mxc_isi_m2m_vb2_buffer_init,\n\t.buf_prepare\t\t= mxc_isi_m2m_vb2_buffer_prepare,\n\t.buf_queue\t\t= mxc_isi_m2m_vb2_buffer_queue,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.start_streaming\t= mxc_isi_m2m_vb2_start_streaming,\n\t.stop_streaming\t\t= mxc_isi_m2m_vb2_stop_streaming,\n};\n\nstatic int mxc_isi_m2m_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t\t  struct vb2_queue *dst_vq)\n{\n\tstruct mxc_isi_m2m_ctx *ctx = priv;\n\tstruct mxc_isi_m2m *m2m = ctx->m2m;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct mxc_isi_m2m_buffer);\n\tsrc_vq->ops = &mxc_isi_m2m_vb2_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->vb2_lock;\n\tsrc_vq->dev = m2m->isi->dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct mxc_isi_m2m_buffer);\n\tdst_vq->ops = &mxc_isi_m2m_vb2_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->vb2_lock;\n\tdst_vq->dev = m2m->isi->dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\n \n\nstatic inline struct mxc_isi_m2m_ctx *\nctrl_to_mxc_isi_m2m_ctx(struct v4l2_ctrl *ctrl)\n{\n\treturn container_of(ctrl->handler, struct mxc_isi_m2m_ctx, ctrls.handler);\n}\n\nstatic int mxc_isi_m2m_ctx_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mxc_isi_m2m_ctx *ctx = ctrl_to_mxc_isi_m2m_ctx(ctrl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tctx->ctrls.hflip = ctrl->val;\n\t\tbreak;\n\n\tcase V4L2_CID_VFLIP:\n\t\tctx->ctrls.vflip = ctrl->val;\n\t\tbreak;\n\n\tcase V4L2_CID_ALPHA_COMPONENT:\n\t\tctx->ctrls.alpha = ctrl->val;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops mxc_isi_m2m_ctx_ctrl_ops = {\n\t.s_ctrl = mxc_isi_m2m_ctx_s_ctrl,\n};\n\nstatic int mxc_isi_m2m_ctx_ctrls_create(struct mxc_isi_m2m_ctx *ctx)\n{\n\tstruct v4l2_ctrl_handler *handler = &ctx->ctrls.handler;\n\tint ret;\n\n\tv4l2_ctrl_handler_init(handler, 3);\n\n\tv4l2_ctrl_new_std(handler, &mxc_isi_m2m_ctx_ctrl_ops,\n\t\t\t  V4L2_CID_ALPHA_COMPONENT, 0, 255, 1, 0);\n\tv4l2_ctrl_new_std(handler, &mxc_isi_m2m_ctx_ctrl_ops,\n\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(handler, &mxc_isi_m2m_ctx_ctrl_ops,\n\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tif (handler->error) {\n\t\tret = handler->error;\n\t\tv4l2_ctrl_handler_free(handler);\n\t\treturn ret;\n\t}\n\n\tctx->fh.ctrl_handler = handler;\n\n\treturn 0;\n}\n\nstatic void mxc_isi_m2m_ctx_ctrls_delete(struct mxc_isi_m2m_ctx *ctx)\n{\n\tv4l2_ctrl_handler_free(&ctx->ctrls.handler);\n}\n\n \n\nstatic int mxc_isi_m2m_querycap(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, MXC_ISI_DRIVER_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, MXC_ISI_M2M, sizeof(cap->card));\n\tcap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE;\n\tcap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\n\n\treturn 0;\n}\n\nstatic int mxc_isi_m2m_enum_fmt_vid(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_fmtdesc *f)\n{\n\tconst enum mxc_isi_video_type type =\n\t\tf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE ?\n\t\tMXC_ISI_VIDEO_M2M_OUT : MXC_ISI_VIDEO_M2M_CAP;\n\tconst struct mxc_isi_format_info *info;\n\n\tinfo = mxc_isi_format_enum(f->index, type);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = info->fourcc;\n\tf->flags |= V4L2_FMT_FLAG_CSC_COLORSPACE | V4L2_FMT_FLAG_CSC_YCBCR_ENC\n\t\t |  V4L2_FMT_FLAG_CSC_QUANTIZATION | V4L2_FMT_FLAG_CSC_XFER_FUNC;\n\n\treturn 0;\n}\n\nstatic const struct mxc_isi_format_info *\n__mxc_isi_m2m_try_fmt_vid(struct mxc_isi_m2m_ctx *ctx,\n\t\t\t  struct v4l2_pix_format_mplane *pix,\n\t\t\t  const enum mxc_isi_video_type type)\n{\n\tif (type == MXC_ISI_VIDEO_M2M_CAP) {\n\t\t \n\t\tpix->width = min(pix->width, ctx->queues.out.format.width);\n\t\tpix->height = min(pix->height, ctx->queues.out.format.height);\n\t}\n\n\treturn mxc_isi_format_try(ctx->m2m->pipe, pix, type);\n}\n\nstatic int mxc_isi_m2m_try_fmt_vid(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tconst enum mxc_isi_video_type type =\n\t\tf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE ?\n\t\tMXC_ISI_VIDEO_M2M_OUT : MXC_ISI_VIDEO_M2M_CAP;\n\tstruct mxc_isi_m2m_ctx *ctx = to_isi_m2m_ctx(fh);\n\n\t__mxc_isi_m2m_try_fmt_vid(ctx, &f->fmt.pix_mp, type);\n\n\treturn 0;\n}\n\nstatic int mxc_isi_m2m_g_fmt_vid(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct mxc_isi_m2m_ctx *ctx = to_isi_m2m_ctx(fh);\n\tconst struct mxc_isi_m2m_ctx_queue_data *qdata =\n\t\tmxc_isi_m2m_ctx_qdata(ctx, f->type);\n\n\tf->fmt.pix_mp = qdata->format;\n\n\treturn 0;\n}\n\nstatic int mxc_isi_m2m_s_fmt_vid(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tconst enum mxc_isi_video_type type =\n\t\tf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE ?\n\t\tMXC_ISI_VIDEO_M2M_OUT : MXC_ISI_VIDEO_M2M_CAP;\n\tstruct mxc_isi_m2m_ctx *ctx = to_isi_m2m_ctx(fh);\n\tstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\n\tconst struct mxc_isi_format_info *info;\n\tstruct vb2_queue *vq;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\tinfo = __mxc_isi_m2m_try_fmt_vid(ctx, pix, type);\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\n\t\tctx->queues.out.format = *pix;\n\t\tctx->queues.out.info = info;\n\t}\n\n\t \n\tctx->queues.cap.format = *pix;\n\tctx->queues.cap.info = info;\n\n\treturn 0;\n}\n\nstatic int mxc_isi_m2m_streamon(struct file *file, void *fh,\n\t\t\t\tenum v4l2_buf_type type)\n{\n\tstruct mxc_isi_m2m_ctx *ctx = to_isi_m2m_ctx(fh);\n\tconst struct v4l2_pix_format_mplane *out_pix = &ctx->queues.out.format;\n\tconst struct v4l2_pix_format_mplane *cap_pix = &ctx->queues.cap.format;\n\tconst struct mxc_isi_format_info *cap_info = ctx->queues.cap.info;\n\tconst struct mxc_isi_format_info *out_info = ctx->queues.out.info;\n\tstruct mxc_isi_m2m *m2m = ctx->m2m;\n\tbool bypass;\n\n\tint ret;\n\n\tmutex_lock(&m2m->lock);\n\n\tif (m2m->usage_count == INT_MAX) {\n\t\tret = -EOVERFLOW;\n\t\tgoto unlock;\n\t}\n\n\tbypass = cap_pix->width == out_pix->width &&\n\t\t cap_pix->height == out_pix->height &&\n\t\t cap_info->encoding == out_info->encoding;\n\n\t \n\tif (m2m->usage_count == 0) {\n\t\tret = mxc_isi_channel_acquire(m2m->pipe,\n\t\t\t\t\t      &mxc_isi_m2m_frame_write_done,\n\t\t\t\t\t      bypass);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tmxc_isi_channel_get(m2m->pipe);\n\t}\n\n\tm2m->usage_count++;\n\n\t \n\tif (!ctx->chained && out_pix->width > MXC_ISI_MAX_WIDTH_UNCHAINED) {\n\t\tret = mxc_isi_channel_chain(m2m->pipe, bypass);\n\t\tif (ret)\n\t\t\tgoto deinit;\n\n\t\tm2m->chained_count++;\n\t\tctx->chained = true;\n\t}\n\n\t \n\tmutex_unlock(&m2m->lock);\n\tret = v4l2_m2m_ioctl_streamon(file, fh, type);\n\tif (ret) {\n\t\t \n\t\tmutex_lock(&m2m->lock);\n\t\tgoto unchain;\n\t}\n\n\treturn 0;\n\nunchain:\n\tif (ctx->chained && --m2m->chained_count == 0)\n\t\tmxc_isi_channel_unchain(m2m->pipe);\n\tctx->chained = false;\n\ndeinit:\n\tif (--m2m->usage_count == 0) {\n\t\tmxc_isi_channel_put(m2m->pipe);\n\t\tmxc_isi_channel_release(m2m->pipe);\n\t}\n\nunlock:\n\tmutex_unlock(&m2m->lock);\n\treturn ret;\n}\n\nstatic int mxc_isi_m2m_streamoff(struct file *file, void *fh,\n\t\t\t\t enum v4l2_buf_type type)\n{\n\tstruct mxc_isi_m2m_ctx *ctx = to_isi_m2m_ctx(fh);\n\tstruct mxc_isi_m2m *m2m = ctx->m2m;\n\n\tv4l2_m2m_ioctl_streamoff(file, fh, type);\n\n\tmutex_lock(&m2m->lock);\n\n\t \n\tif (m2m->last_ctx == ctx)\n\t\tm2m->last_ctx = NULL;\n\n\t \n\tif (ctx->chained && --m2m->chained_count == 0)\n\t\tmxc_isi_channel_unchain(m2m->pipe);\n\tctx->chained = false;\n\n\t \n\tif (--m2m->usage_count == 0) {\n\t\tmxc_isi_channel_disable(m2m->pipe);\n\t\tmxc_isi_channel_put(m2m->pipe);\n\t\tmxc_isi_channel_release(m2m->pipe);\n\t}\n\n\tWARN_ON(m2m->usage_count < 0);\n\n\tmutex_unlock(&m2m->lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops mxc_isi_m2m_ioctl_ops = {\n\t.vidioc_querycap\t\t= mxc_isi_m2m_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= mxc_isi_m2m_enum_fmt_vid,\n\t.vidioc_enum_fmt_vid_out\t= mxc_isi_m2m_enum_fmt_vid,\n\t.vidioc_g_fmt_vid_cap_mplane\t= mxc_isi_m2m_g_fmt_vid,\n\t.vidioc_g_fmt_vid_out_mplane\t= mxc_isi_m2m_g_fmt_vid,\n\t.vidioc_s_fmt_vid_cap_mplane\t= mxc_isi_m2m_s_fmt_vid,\n\t.vidioc_s_fmt_vid_out_mplane\t= mxc_isi_m2m_s_fmt_vid,\n\t.vidioc_try_fmt_vid_cap_mplane\t= mxc_isi_m2m_try_fmt_vid,\n\t.vidioc_try_fmt_vid_out_mplane\t= mxc_isi_m2m_try_fmt_vid,\n\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\t.vidioc_prepare_buf\t\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\n\t.vidioc_streamon\t\t= mxc_isi_m2m_streamon,\n\t.vidioc_streamoff\t\t= mxc_isi_m2m_streamoff,\n\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\n \n\nstatic void mxc_isi_m2m_init_format(struct mxc_isi_m2m_ctx *ctx,\n\t\t\t\t    struct mxc_isi_m2m_ctx_queue_data *qdata,\n\t\t\t\t    enum mxc_isi_video_type type)\n{\n\tqdata->format.width = MXC_ISI_DEF_WIDTH;\n\tqdata->format.height = MXC_ISI_DEF_HEIGHT;\n\tqdata->format.pixelformat = MXC_ISI_DEF_PIXEL_FORMAT;\n\n\tqdata->info = mxc_isi_format_try(ctx->m2m->pipe, &qdata->format, type);\n}\n\nstatic int mxc_isi_m2m_open(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct mxc_isi_m2m *m2m = video_drvdata(file);\n\tstruct mxc_isi_m2m_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->m2m = m2m;\n\tmutex_init(&ctx->vb2_lock);\n\n\tv4l2_fh_init(&ctx->fh, vdev);\n\tfile->private_data = &ctx->fh;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(m2m->m2m_dev, ctx,\n\t\t\t\t\t    &mxc_isi_m2m_queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tctx->fh.m2m_ctx = NULL;\n\t\tgoto err_fh;\n\t}\n\n\tmxc_isi_m2m_init_format(ctx, &ctx->queues.out, MXC_ISI_VIDEO_M2M_OUT);\n\tmxc_isi_m2m_init_format(ctx, &ctx->queues.cap, MXC_ISI_VIDEO_M2M_CAP);\n\n\tret = mxc_isi_m2m_ctx_ctrls_create(ctx);\n\tif (ret)\n\t\tgoto err_ctx;\n\n\tret = pm_runtime_resume_and_get(m2m->isi->dev);\n\tif (ret)\n\t\tgoto err_ctrls;\n\n\tv4l2_fh_add(&ctx->fh);\n\n\treturn 0;\n\nerr_ctrls:\n\tmxc_isi_m2m_ctx_ctrls_delete(ctx);\nerr_ctx:\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\nerr_fh:\n\tv4l2_fh_exit(&ctx->fh);\n\tmutex_destroy(&ctx->vb2_lock);\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic int mxc_isi_m2m_release(struct file *file)\n{\n\tstruct mxc_isi_m2m *m2m = video_drvdata(file);\n\tstruct mxc_isi_m2m_ctx *ctx = to_isi_m2m_ctx(file->private_data);\n\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tmxc_isi_m2m_ctx_ctrls_delete(ctx);\n\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\n\tmutex_destroy(&ctx->vb2_lock);\n\tkfree(ctx);\n\n\tpm_runtime_put(m2m->isi->dev);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations mxc_isi_m2m_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= mxc_isi_m2m_open,\n\t.release\t= mxc_isi_m2m_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\n \n\nint mxc_isi_m2m_register(struct mxc_isi_dev *isi, struct v4l2_device *v4l2_dev)\n{\n\tstruct mxc_isi_m2m *m2m = &isi->m2m;\n\tstruct video_device *vdev = &m2m->vdev;\n\tstruct media_link *link;\n\tint ret;\n\n\tm2m->isi = isi;\n\tm2m->pipe = &isi->pipes[0];\n\n\tmutex_init(&m2m->lock);\n\n\t \n\tsnprintf(vdev->name, sizeof(vdev->name), \"mxc_isi.m2m\");\n\n\tvdev->fops\t= &mxc_isi_m2m_fops;\n\tvdev->ioctl_ops\t= &mxc_isi_m2m_ioctl_ops;\n\tvdev->v4l2_dev\t= v4l2_dev;\n\tvdev->minor\t= -1;\n\tvdev->release\t= video_device_release_empty;\n\tvdev->vfl_dir\t= VFL_DIR_M2M;\n\n\tvdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE;\n\tvideo_set_drvdata(vdev, m2m);\n\n\t \n\tm2m->m2m_dev = v4l2_m2m_init(&mxc_isi_m2m_ops);\n\tif (IS_ERR(m2m->m2m_dev)) {\n\t\tdev_err(isi->dev, \"failed to initialize m2m device\\n\");\n\t\tret = PTR_ERR(m2m->m2m_dev);\n\t\tgoto err_mutex;\n\t}\n\n\t \n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0) {\n\t\tdev_err(isi->dev, \"failed to register m2m device\\n\");\n\t\tgoto err_m2m;\n\t}\n\n\t \n\tm2m->pad.flags = MEDIA_PAD_FL_SOURCE;\n\tvdev->entity.name = \"mxc_isi.output\";\n\tvdev->entity.function = MEDIA_ENT_F_IO_V4L;\n\tret = media_entity_pads_init(&vdev->entity, 1, &m2m->pad);\n\tif (ret)\n\t\tgoto err_video;\n\n\tret = media_device_register_entity(v4l2_dev->mdev, &vdev->entity);\n\tif (ret)\n\t\tgoto err_entity_cleanup;\n\n\tret = media_create_pad_link(&vdev->entity, 0,\n\t\t\t\t    &m2m->isi->crossbar.sd.entity,\n\t\t\t\t    m2m->isi->crossbar.num_sinks - 1,\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\tif (ret)\n\t\tgoto err_entity_unreg;\n\n\tm2m->intf = media_devnode_create(v4l2_dev->mdev, MEDIA_INTF_T_V4L_VIDEO,\n\t\t\t\t\t 0, VIDEO_MAJOR, vdev->minor);\n\tif (!m2m->intf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_entity_unreg;\n\t}\n\n\tlink = media_create_intf_link(&vdev->entity, &m2m->intf->intf,\n\t\t\t\t      MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t      MEDIA_LNK_FL_ENABLED);\n\tif (!link) {\n\t\tret = -ENOMEM;\n\t\tgoto err_devnode;\n\t}\n\n\tlink = media_create_intf_link(&m2m->pipe->video.vdev.entity,\n\t\t\t\t      &m2m->intf->intf,\n\t\t\t\t      MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t      MEDIA_LNK_FL_ENABLED);\n\tif (!link) {\n\t\tret = -ENOMEM;\n\t\tgoto err_devnode;\n\t}\n\n\treturn 0;\n\nerr_devnode:\n\tmedia_devnode_remove(m2m->intf);\nerr_entity_unreg:\n\tmedia_device_unregister_entity(&vdev->entity);\nerr_entity_cleanup:\n\tmedia_entity_cleanup(&vdev->entity);\nerr_video:\n\tvideo_unregister_device(vdev);\nerr_m2m:\n\tv4l2_m2m_release(m2m->m2m_dev);\nerr_mutex:\n\tmutex_destroy(&m2m->lock);\n\treturn ret;\n}\n\nint mxc_isi_m2m_unregister(struct mxc_isi_dev *isi)\n{\n\tstruct mxc_isi_m2m *m2m = &isi->m2m;\n\tstruct video_device *vdev = &m2m->vdev;\n\n\tvideo_unregister_device(vdev);\n\n\tv4l2_m2m_release(m2m->m2m_dev);\n\tmedia_devnode_remove(m2m->intf);\n\tmedia_entity_cleanup(&vdev->entity);\n\tmutex_destroy(&m2m->lock);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}