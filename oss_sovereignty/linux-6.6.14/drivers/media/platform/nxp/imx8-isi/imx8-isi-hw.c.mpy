{
  "module_name": "imx8-isi-hw.c",
  "hash_id": "f6c5a4a91628902eecc68b9079988a6324a71f454bf017e27c017e7f872a3e7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/imx8-isi/imx8-isi-hw.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/types.h>\n\n#include \"imx8-isi-core.h\"\n#include \"imx8-isi-regs.h\"\n\n#define\tISI_DOWNSCALE_THRESHOLD\t\t0x4000\n\nstatic inline u32 mxc_isi_read(struct mxc_isi_pipe *pipe, u32 reg)\n{\n\treturn readl(pipe->regs + reg);\n}\n\nstatic inline void mxc_isi_write(struct mxc_isi_pipe *pipe, u32 reg, u32 val)\n{\n\twritel(val, pipe->regs + reg);\n}\n\n \n\nvoid mxc_isi_channel_set_inbuf(struct mxc_isi_pipe *pipe, dma_addr_t dma_addr)\n{\n\tmxc_isi_write(pipe, CHNL_IN_BUF_ADDR, lower_32_bits(dma_addr));\n\tif (pipe->isi->pdata->has_36bit_dma)\n\t\tmxc_isi_write(pipe, CHNL_IN_BUF_XTND_ADDR,\n\t\t\t      upper_32_bits(dma_addr));\n}\n\nvoid mxc_isi_channel_set_outbuf(struct mxc_isi_pipe *pipe,\n\t\t\t\tconst dma_addr_t dma_addrs[3],\n\t\t\t\tenum mxc_isi_buf_id buf_id)\n{\n\tint val;\n\n\tval = mxc_isi_read(pipe, CHNL_OUT_BUF_CTRL);\n\n\tif (buf_id == MXC_ISI_BUF1) {\n\t\tmxc_isi_write(pipe, CHNL_OUT_BUF1_ADDR_Y,\n\t\t\t      lower_32_bits(dma_addrs[0]));\n\t\tmxc_isi_write(pipe, CHNL_OUT_BUF1_ADDR_U,\n\t\t\t      lower_32_bits(dma_addrs[1]));\n\t\tmxc_isi_write(pipe, CHNL_OUT_BUF1_ADDR_V,\n\t\t\t      lower_32_bits(dma_addrs[2]));\n\t\tif (pipe->isi->pdata->has_36bit_dma) {\n\t\t\tmxc_isi_write(pipe, CHNL_Y_BUF1_XTND_ADDR,\n\t\t\t\t      upper_32_bits(dma_addrs[0]));\n\t\t\tmxc_isi_write(pipe, CHNL_U_BUF1_XTND_ADDR,\n\t\t\t\t      upper_32_bits(dma_addrs[1]));\n\t\t\tmxc_isi_write(pipe, CHNL_V_BUF1_XTND_ADDR,\n\t\t\t\t      upper_32_bits(dma_addrs[2]));\n\t\t}\n\t\tval ^= CHNL_OUT_BUF_CTRL_LOAD_BUF1_ADDR;\n\t} else  {\n\t\tmxc_isi_write(pipe, CHNL_OUT_BUF2_ADDR_Y,\n\t\t\t      lower_32_bits(dma_addrs[0]));\n\t\tmxc_isi_write(pipe, CHNL_OUT_BUF2_ADDR_U,\n\t\t\t      lower_32_bits(dma_addrs[1]));\n\t\tmxc_isi_write(pipe, CHNL_OUT_BUF2_ADDR_V,\n\t\t\t      lower_32_bits(dma_addrs[2]));\n\t\tif (pipe->isi->pdata->has_36bit_dma) {\n\t\t\tmxc_isi_write(pipe, CHNL_Y_BUF2_XTND_ADDR,\n\t\t\t\t      upper_32_bits(dma_addrs[0]));\n\t\t\tmxc_isi_write(pipe, CHNL_U_BUF2_XTND_ADDR,\n\t\t\t\t      upper_32_bits(dma_addrs[1]));\n\t\t\tmxc_isi_write(pipe, CHNL_V_BUF2_XTND_ADDR,\n\t\t\t\t      upper_32_bits(dma_addrs[2]));\n\t\t}\n\t\tval ^= CHNL_OUT_BUF_CTRL_LOAD_BUF2_ADDR;\n\t}\n\n\tmxc_isi_write(pipe, CHNL_OUT_BUF_CTRL, val);\n}\n\nvoid mxc_isi_channel_m2m_start(struct mxc_isi_pipe *pipe)\n{\n\tu32 val;\n\n\tval = mxc_isi_read(pipe, CHNL_MEM_RD_CTRL);\n\tval &= ~CHNL_MEM_RD_CTRL_READ_MEM;\n\tmxc_isi_write(pipe, CHNL_MEM_RD_CTRL, val);\n\n\tfsleep(300);\n\n\tval |= CHNL_MEM_RD_CTRL_READ_MEM;\n\tmxc_isi_write(pipe, CHNL_MEM_RD_CTRL, val);\n}\n\n \n\nstatic u32 mxc_isi_channel_scaling_ratio(unsigned int from, unsigned int to,\n\t\t\t\t\t u32 *dec)\n{\n\tunsigned int ratio = from / to;\n\n\tif (ratio < 2)\n\t\t*dec = 1;\n\telse if (ratio < 4)\n\t\t*dec = 2;\n\telse if (ratio < 8)\n\t\t*dec = 4;\n\telse\n\t\t*dec = 8;\n\n\treturn min_t(u32, from * 0x1000 / (to * *dec), ISI_DOWNSCALE_THRESHOLD);\n}\n\nstatic void mxc_isi_channel_set_scaling(struct mxc_isi_pipe *pipe,\n\t\t\t\t\tenum mxc_isi_encoding encoding,\n\t\t\t\t\tconst struct v4l2_area *in_size,\n\t\t\t\t\tconst struct v4l2_area *out_size,\n\t\t\t\t\tbool *bypass)\n{\n\tu32 xscale, yscale;\n\tu32 decx, decy;\n\tu32 val;\n\n\tdev_dbg(pipe->isi->dev, \"input %ux%u, output %ux%u\\n\",\n\t\tin_size->width, in_size->height,\n\t\tout_size->width, out_size->height);\n\n\txscale = mxc_isi_channel_scaling_ratio(in_size->width, out_size->width,\n\t\t\t\t\t       &decx);\n\tyscale = mxc_isi_channel_scaling_ratio(in_size->height, out_size->height,\n\t\t\t\t\t       &decy);\n\n\tval = mxc_isi_read(pipe, CHNL_IMG_CTRL);\n\tval &= ~(CHNL_IMG_CTRL_DEC_X_MASK | CHNL_IMG_CTRL_DEC_Y_MASK |\n\t\t CHNL_IMG_CTRL_YCBCR_MODE);\n\n\tval |= CHNL_IMG_CTRL_DEC_X(ilog2(decx))\n\t    |  CHNL_IMG_CTRL_DEC_Y(ilog2(decy));\n\n\t \n\tif (encoding == MXC_ISI_ENC_YUV)\n\t\tval |= CHNL_IMG_CTRL_YCBCR_MODE;\n\n\tmxc_isi_write(pipe, CHNL_IMG_CTRL, val);\n\n\tmxc_isi_write(pipe, CHNL_SCALE_FACTOR,\n\t\t      CHNL_SCALE_FACTOR_Y_SCALE(yscale) |\n\t\t      CHNL_SCALE_FACTOR_X_SCALE(xscale));\n\n\tmxc_isi_write(pipe, CHNL_SCALE_OFFSET, 0);\n\n\tmxc_isi_write(pipe, CHNL_SCL_IMG_CFG,\n\t\t      CHNL_SCL_IMG_CFG_HEIGHT(out_size->height) |\n\t\t      CHNL_SCL_IMG_CFG_WIDTH(out_size->width));\n\n\t*bypass = in_size->height == out_size->height &&\n\t\t  in_size->width == out_size->width;\n}\n\nstatic void mxc_isi_channel_set_crop(struct mxc_isi_pipe *pipe,\n\t\t\t\t     const struct v4l2_area *src,\n\t\t\t\t     const struct v4l2_rect *dst)\n{\n\tu32 val, val0, val1;\n\n\tval = mxc_isi_read(pipe, CHNL_IMG_CTRL);\n\tval &= ~CHNL_IMG_CTRL_CROP_EN;\n\n\tif (src->height == dst->height && src->width == dst->width) {\n\t\tmxc_isi_write(pipe, CHNL_IMG_CTRL, val);\n\t\treturn;\n\t}\n\n\tval |= CHNL_IMG_CTRL_CROP_EN;\n\tval0 = CHNL_CROP_ULC_X(dst->left) | CHNL_CROP_ULC_Y(dst->top);\n\tval1 = CHNL_CROP_LRC_X(dst->width) | CHNL_CROP_LRC_Y(dst->height);\n\n\tmxc_isi_write(pipe, CHNL_CROP_ULC, val0);\n\tmxc_isi_write(pipe, CHNL_CROP_LRC, val1 + val0);\n\tmxc_isi_write(pipe, CHNL_IMG_CTRL, val);\n}\n\n \nstatic const u32 mxc_isi_yuv2rgb_coeffs[6] = {\n\t \n\t0x0000012a, 0x012a0198, 0x0730079c,\n\t0x0204012a, 0x01f00000, 0x01800180\n};\n\nstatic const u32 mxc_isi_rgb2yuv_coeffs[6] = {\n\t \n\t0x00810041, 0x07db0019, 0x007007b6,\n\t0x07a20070, 0x001007ee, 0x00800080\n};\n\nstatic void mxc_isi_channel_set_csc(struct mxc_isi_pipe *pipe,\n\t\t\t\t    enum mxc_isi_encoding in_encoding,\n\t\t\t\t    enum mxc_isi_encoding out_encoding,\n\t\t\t\t    bool *bypass)\n{\n\tstatic const char * const encodings[] = {\n\t\t[MXC_ISI_ENC_RAW] = \"RAW\",\n\t\t[MXC_ISI_ENC_RGB] = \"RGB\",\n\t\t[MXC_ISI_ENC_YUV] = \"YUV\",\n\t};\n\tconst u32 *coeffs;\n\tbool cscen = true;\n\tu32 val;\n\n\tval = mxc_isi_read(pipe, CHNL_IMG_CTRL);\n\tval &= ~(CHNL_IMG_CTRL_CSC_BYPASS | CHNL_IMG_CTRL_CSC_MODE_MASK);\n\n\tif (in_encoding == MXC_ISI_ENC_YUV &&\n\t    out_encoding == MXC_ISI_ENC_RGB) {\n\t\t \n\t\tcoeffs = mxc_isi_yuv2rgb_coeffs;\n\t\t \n\t\tval |= CHNL_IMG_CTRL_CSC_MODE(CHNL_IMG_CTRL_CSC_MODE_YCBCR2RGB);\n\t} else if (in_encoding == MXC_ISI_ENC_RGB &&\n\t\t   out_encoding == MXC_ISI_ENC_YUV) {\n\t\t \n\t\tcoeffs = mxc_isi_rgb2yuv_coeffs;\n\t\tval |= CHNL_IMG_CTRL_CSC_MODE(CHNL_IMG_CTRL_CSC_MODE_RGB2YCBCR);\n\t} else {\n\t\t \n\t\tcscen = false;\n\t\tval |= CHNL_IMG_CTRL_CSC_BYPASS;\n\t}\n\n\tdev_dbg(pipe->isi->dev, \"CSC: %s -> %s\\n\",\n\t\tencodings[in_encoding], encodings[out_encoding]);\n\n\tif (cscen) {\n\t\tmxc_isi_write(pipe, CHNL_CSC_COEFF0, coeffs[0]);\n\t\tmxc_isi_write(pipe, CHNL_CSC_COEFF1, coeffs[1]);\n\t\tmxc_isi_write(pipe, CHNL_CSC_COEFF2, coeffs[2]);\n\t\tmxc_isi_write(pipe, CHNL_CSC_COEFF3, coeffs[3]);\n\t\tmxc_isi_write(pipe, CHNL_CSC_COEFF4, coeffs[4]);\n\t\tmxc_isi_write(pipe, CHNL_CSC_COEFF5, coeffs[5]);\n\t}\n\n\tmxc_isi_write(pipe, CHNL_IMG_CTRL, val);\n\n\t*bypass = !cscen;\n}\n\nvoid mxc_isi_channel_set_alpha(struct mxc_isi_pipe *pipe, u8 alpha)\n{\n\tu32 val;\n\n\tval = mxc_isi_read(pipe, CHNL_IMG_CTRL);\n\tval &= ~CHNL_IMG_CTRL_GBL_ALPHA_VAL_MASK;\n\tval |= CHNL_IMG_CTRL_GBL_ALPHA_VAL(alpha) |\n\t       CHNL_IMG_CTRL_GBL_ALPHA_EN;\n\tmxc_isi_write(pipe, CHNL_IMG_CTRL, val);\n}\n\nvoid mxc_isi_channel_set_flip(struct mxc_isi_pipe *pipe, bool hflip, bool vflip)\n{\n\tu32 val;\n\n\tval = mxc_isi_read(pipe, CHNL_IMG_CTRL);\n\tval &= ~(CHNL_IMG_CTRL_VFLIP_EN | CHNL_IMG_CTRL_HFLIP_EN);\n\n\tif (vflip)\n\t\tval |= CHNL_IMG_CTRL_VFLIP_EN;\n\tif (hflip)\n\t\tval |= CHNL_IMG_CTRL_HFLIP_EN;\n\n\tmxc_isi_write(pipe, CHNL_IMG_CTRL, val);\n}\n\nstatic void mxc_isi_channel_set_panic_threshold(struct mxc_isi_pipe *pipe)\n{\n\tconst struct mxc_isi_set_thd *set_thd = pipe->isi->pdata->set_thd;\n\tu32 val;\n\n\tval = mxc_isi_read(pipe, CHNL_OUT_BUF_CTRL);\n\n\tval &= ~(set_thd->panic_set_thd_y.mask);\n\tval |= set_thd->panic_set_thd_y.threshold << set_thd->panic_set_thd_y.offset;\n\n\tval &= ~(set_thd->panic_set_thd_u.mask);\n\tval |= set_thd->panic_set_thd_u.threshold << set_thd->panic_set_thd_u.offset;\n\n\tval &= ~(set_thd->panic_set_thd_v.mask);\n\tval |= set_thd->panic_set_thd_v.threshold << set_thd->panic_set_thd_v.offset;\n\n\tmxc_isi_write(pipe, CHNL_OUT_BUF_CTRL, val);\n}\n\nstatic void mxc_isi_channel_set_control(struct mxc_isi_pipe *pipe,\n\t\t\t\t\tenum mxc_isi_input_id input,\n\t\t\t\t\tbool bypass)\n{\n\tu32 val;\n\n\tmutex_lock(&pipe->lock);\n\n\tval = mxc_isi_read(pipe, CHNL_CTRL);\n\tval &= ~(CHNL_CTRL_CHNL_BYPASS | CHNL_CTRL_CHAIN_BUF_MASK |\n\t\t CHNL_CTRL_BLANK_PXL_MASK | CHNL_CTRL_SRC_TYPE_MASK |\n\t\t CHNL_CTRL_MIPI_VC_ID_MASK | CHNL_CTRL_SRC_INPUT_MASK);\n\n\t \n\tif (bypass)\n\t\tval |= CHNL_CTRL_CHNL_BYPASS;\n\n\t \n\tif (pipe->chained)\n\t\tval |= CHNL_CTRL_CHAIN_BUF(CHNL_CTRL_CHAIN_BUF_2_CHAIN);\n\n\tval |= CHNL_CTRL_BLANK_PXL(0xff);\n\n\t \n\tif (input == MXC_ISI_INPUT_MEM) {\n\t\t \n\t\tval |= CHNL_CTRL_SRC_TYPE(CHNL_CTRL_SRC_TYPE_MEMORY);\n\t\tval |= CHNL_CTRL_SRC_INPUT(pipe->isi->pdata->num_ports);\n\t} else {\n\t\tval |= CHNL_CTRL_SRC_TYPE(CHNL_CTRL_SRC_TYPE_DEVICE);\n\t\tval |= CHNL_CTRL_SRC_INPUT(input);\n\t\tval |= CHNL_CTRL_MIPI_VC_ID(0);  \n\t}\n\n\tmxc_isi_write(pipe, CHNL_CTRL, val);\n\n\tmutex_unlock(&pipe->lock);\n}\n\nvoid mxc_isi_channel_config(struct mxc_isi_pipe *pipe,\n\t\t\t    enum mxc_isi_input_id input,\n\t\t\t    const struct v4l2_area *in_size,\n\t\t\t    const struct v4l2_area *scale,\n\t\t\t    const struct v4l2_rect *crop,\n\t\t\t    enum mxc_isi_encoding in_encoding,\n\t\t\t    enum mxc_isi_encoding out_encoding)\n{\n\tbool csc_bypass;\n\tbool scaler_bypass;\n\n\t \n\tmxc_isi_write(pipe, CHNL_IMG_CFG,\n\t\t      CHNL_IMG_CFG_HEIGHT(in_size->height) |\n\t\t      CHNL_IMG_CFG_WIDTH(in_size->width));\n\n\t \n\tmxc_isi_channel_set_scaling(pipe, in_encoding, in_size, scale,\n\t\t\t\t    &scaler_bypass);\n\tmxc_isi_channel_set_crop(pipe, scale, crop);\n\n\t \n\tmxc_isi_channel_set_csc(pipe, in_encoding, out_encoding, &csc_bypass);\n\n\t \n\tmxc_isi_channel_set_panic_threshold(pipe);\n\n\t \n\tmxc_isi_channel_set_control(pipe, input, csc_bypass && scaler_bypass);\n}\n\nvoid mxc_isi_channel_set_input_format(struct mxc_isi_pipe *pipe,\n\t\t\t\t      const struct mxc_isi_format_info *info,\n\t\t\t\t      const struct v4l2_pix_format_mplane *format)\n{\n\tunsigned int bpl = format->plane_fmt[0].bytesperline;\n\n\tmxc_isi_write(pipe, CHNL_MEM_RD_CTRL,\n\t\t      CHNL_MEM_RD_CTRL_IMG_TYPE(info->isi_in_format));\n\tmxc_isi_write(pipe, CHNL_IN_BUF_PITCH,\n\t\t      CHNL_IN_BUF_PITCH_LINE_PITCH(bpl));\n}\n\nvoid mxc_isi_channel_set_output_format(struct mxc_isi_pipe *pipe,\n\t\t\t\t       const struct mxc_isi_format_info *info,\n\t\t\t\t       struct v4l2_pix_format_mplane *format)\n{\n\tu32 val;\n\n\t \n\tdev_dbg(pipe->isi->dev, \"output format %p4cc\", &format->pixelformat);\n\n\tval = mxc_isi_read(pipe, CHNL_IMG_CTRL);\n\tval &= ~CHNL_IMG_CTRL_FORMAT_MASK;\n\tval |= CHNL_IMG_CTRL_FORMAT(info->isi_out_format);\n\tmxc_isi_write(pipe, CHNL_IMG_CTRL, val);\n\n\t \n\tmxc_isi_write(pipe, CHNL_OUT_BUF_PITCH,\n\t\t      format->plane_fmt[0].bytesperline);\n}\n\n \n\nu32 mxc_isi_channel_irq_status(struct mxc_isi_pipe *pipe, bool clear)\n{\n\tu32 status;\n\n\tstatus = mxc_isi_read(pipe, CHNL_STS);\n\tif (clear)\n\t\tmxc_isi_write(pipe, CHNL_STS, status);\n\n\treturn status;\n}\n\nvoid mxc_isi_channel_irq_clear(struct mxc_isi_pipe *pipe)\n{\n\tmxc_isi_write(pipe, CHNL_STS, 0xffffffff);\n}\n\nstatic void mxc_isi_channel_irq_enable(struct mxc_isi_pipe *pipe)\n{\n\tconst struct mxc_isi_ier_reg *ier_reg = pipe->isi->pdata->ier_reg;\n\tu32 val;\n\n\tval = CHNL_IER_FRM_RCVD_EN |\n\t\tCHNL_IER_AXI_WR_ERR_U_EN |\n\t\tCHNL_IER_AXI_WR_ERR_V_EN |\n\t\tCHNL_IER_AXI_WR_ERR_Y_EN;\n\n\t \n\tval |= ier_reg->oflw_y_buf_en.mask |\n\t       ier_reg->oflw_u_buf_en.mask |\n\t       ier_reg->oflw_v_buf_en.mask;\n\n\t \n\tval |= ier_reg->excs_oflw_y_buf_en.mask |\n\t       ier_reg->excs_oflw_u_buf_en.mask |\n\t       ier_reg->excs_oflw_v_buf_en.mask;\n\n\t \n\tval |= ier_reg->panic_y_buf_en.mask |\n\t       ier_reg->panic_u_buf_en.mask |\n\t       ier_reg->panic_v_buf_en.mask;\n\n\tmxc_isi_channel_irq_clear(pipe);\n\tmxc_isi_write(pipe, CHNL_IER, val);\n}\n\nstatic void mxc_isi_channel_irq_disable(struct mxc_isi_pipe *pipe)\n{\n\tmxc_isi_write(pipe, CHNL_IER, 0);\n}\n\n \n\nstatic void mxc_isi_channel_sw_reset(struct mxc_isi_pipe *pipe, bool enable_clk)\n{\n\tmxc_isi_write(pipe, CHNL_CTRL, CHNL_CTRL_SW_RST);\n\tmdelay(5);\n\tmxc_isi_write(pipe, CHNL_CTRL, enable_clk ? CHNL_CTRL_CLK_EN : 0);\n}\n\nstatic void __mxc_isi_channel_get(struct mxc_isi_pipe *pipe)\n{\n\tif (!pipe->use_count++)\n\t\tmxc_isi_channel_sw_reset(pipe, true);\n}\n\nvoid mxc_isi_channel_get(struct mxc_isi_pipe *pipe)\n{\n\tmutex_lock(&pipe->lock);\n\t__mxc_isi_channel_get(pipe);\n\tmutex_unlock(&pipe->lock);\n}\n\nstatic void __mxc_isi_channel_put(struct mxc_isi_pipe *pipe)\n{\n\tif (!--pipe->use_count)\n\t\tmxc_isi_channel_sw_reset(pipe, false);\n}\n\nvoid mxc_isi_channel_put(struct mxc_isi_pipe *pipe)\n{\n\tmutex_lock(&pipe->lock);\n\t__mxc_isi_channel_put(pipe);\n\tmutex_unlock(&pipe->lock);\n}\n\nvoid mxc_isi_channel_enable(struct mxc_isi_pipe *pipe)\n{\n\tu32 val;\n\n\tmxc_isi_channel_irq_enable(pipe);\n\n\tmutex_lock(&pipe->lock);\n\n\tval = mxc_isi_read(pipe, CHNL_CTRL);\n\tval |= CHNL_CTRL_CHNL_EN;\n\tmxc_isi_write(pipe, CHNL_CTRL, val);\n\n\tmutex_unlock(&pipe->lock);\n}\n\nvoid mxc_isi_channel_disable(struct mxc_isi_pipe *pipe)\n{\n\tu32 val;\n\n\tmxc_isi_channel_irq_disable(pipe);\n\n\tmutex_lock(&pipe->lock);\n\n\tval = mxc_isi_read(pipe, CHNL_CTRL);\n\tval &= ~CHNL_CTRL_CHNL_EN;\n\tmxc_isi_write(pipe, CHNL_CTRL, val);\n\n\tmutex_unlock(&pipe->lock);\n}\n\n \nint mxc_isi_channel_acquire(struct mxc_isi_pipe *pipe,\n\t\t\t    mxc_isi_pipe_irq_t irq_handler, bool bypass)\n{\n\tu8 resources;\n\tint ret = 0;\n\n\tmutex_lock(&pipe->lock);\n\n\tif (pipe->irq_handler) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\t \n\tresources = MXC_ISI_CHANNEL_RES_OUTPUT_BUF\n\t\t  | (!bypass ? MXC_ISI_CHANNEL_RES_LINE_BUF : 0);\n\tif ((pipe->available_res & resources) != resources) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\t \n\tpipe->acquired_res = resources;\n\tpipe->available_res &= ~resources;\n\tpipe->irq_handler = irq_handler;\n\nunlock:\n\tmutex_unlock(&pipe->lock);\n\n\treturn ret;\n}\n\nvoid mxc_isi_channel_release(struct mxc_isi_pipe *pipe)\n{\n\tmutex_lock(&pipe->lock);\n\n\tpipe->irq_handler = NULL;\n\tpipe->available_res |= pipe->acquired_res;\n\tpipe->acquired_res = 0;\n\n\tmutex_unlock(&pipe->lock);\n}\n\n \nint mxc_isi_channel_chain(struct mxc_isi_pipe *pipe, bool bypass)\n{\n\t \n\tconst u8 resources = MXC_ISI_CHANNEL_RES_OUTPUT_BUF\n\t\t\t   | MXC_ISI_CHANNEL_RES_LINE_BUF;\n\tstruct mxc_isi_pipe *chained_pipe = pipe + 1;\n\tint ret = 0;\n\n\t \n\tif (WARN_ON(pipe->id == pipe->isi->pdata->num_channels - 1))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chained_pipe->lock);\n\n\t \n\tif (WARN_ON(pipe->chained || chained_pipe->chained_res)) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif ((chained_pipe->available_res & resources) != resources) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tpipe->chained = true;\n\tchained_pipe->chained_res |= resources;\n\tchained_pipe->available_res &= ~resources;\n\n\t__mxc_isi_channel_get(chained_pipe);\n\nunlock:\n\tmutex_unlock(&chained_pipe->lock);\n\n\treturn ret;\n}\n\nvoid mxc_isi_channel_unchain(struct mxc_isi_pipe *pipe)\n{\n\tstruct mxc_isi_pipe *chained_pipe = pipe + 1;\n\n\tif (!pipe->chained)\n\t\treturn;\n\n\tpipe->chained = false;\n\n\tmutex_lock(&chained_pipe->lock);\n\n\tchained_pipe->available_res |= chained_pipe->chained_res;\n\tchained_pipe->chained_res = 0;\n\n\t__mxc_isi_channel_put(chained_pipe);\n\n\tmutex_unlock(&chained_pipe->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}