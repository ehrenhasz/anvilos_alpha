{
  "module_name": "imx8-isi-core.c",
  "hash_id": "143aef89a21c7ec641f4b5ff455847ca397886917b2872da43b2eb12e8bbdc0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/imx8-isi/imx8-isi-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include <media/media-device.h>\n#include <media/v4l2-async.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-mc.h>\n\n#include \"imx8-isi-core.h\"\n\n \n\nstruct mxc_isi_async_subdev {\n\tstruct v4l2_async_connection asd;\n\tunsigned int port;\n};\n\nstatic inline struct mxc_isi_async_subdev *\nasd_to_mxc_isi_async_subdev(struct v4l2_async_connection *asd)\n{\n\treturn container_of(asd, struct mxc_isi_async_subdev, asd);\n};\n\nstatic inline struct mxc_isi_dev *\nnotifier_to_mxc_isi_dev(struct v4l2_async_notifier *n)\n{\n\treturn container_of(n, struct mxc_isi_dev, notifier);\n};\n\nstatic int mxc_isi_async_notifier_bound(struct v4l2_async_notifier *notifier,\n\t\t\t\t\tstruct v4l2_subdev *sd,\n\t\t\t\t\tstruct v4l2_async_connection *asc)\n{\n\tconst unsigned int link_flags = MEDIA_LNK_FL_IMMUTABLE\n\t\t\t\t      | MEDIA_LNK_FL_ENABLED;\n\tstruct mxc_isi_dev *isi = notifier_to_mxc_isi_dev(notifier);\n\tstruct mxc_isi_async_subdev *masd = asd_to_mxc_isi_async_subdev(asc);\n\tstruct media_pad *pad = &isi->crossbar.pads[masd->port];\n\tstruct device_link *link;\n\n\tdev_dbg(isi->dev, \"Bound subdev %s to crossbar input %u\\n\", sd->name,\n\t\tmasd->port);\n\n\t \n\tlink = device_link_add(isi->dev, sd->dev, DL_FLAG_STATELESS);\n\tif (!link) {\n\t\tdev_err(isi->dev,\n\t\t\t\"Failed to create device link to source %s\\n\", sd->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn v4l2_create_fwnode_links_to_pad(sd, pad, link_flags);\n}\n\nstatic int mxc_isi_async_notifier_complete(struct v4l2_async_notifier *notifier)\n{\n\tstruct mxc_isi_dev *isi = notifier_to_mxc_isi_dev(notifier);\n\tint ret;\n\n\tdev_dbg(isi->dev, \"All subdevs bound\\n\");\n\n\tret = v4l2_device_register_subdev_nodes(&isi->v4l2_dev);\n\tif (ret < 0) {\n\t\tdev_err(isi->dev,\n\t\t\t\"Failed to register subdev nodes: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn media_device_register(&isi->media_dev);\n}\n\nstatic const struct v4l2_async_notifier_operations mxc_isi_async_notifier_ops = {\n\t.bound = mxc_isi_async_notifier_bound,\n\t.complete = mxc_isi_async_notifier_complete,\n};\n\nstatic int mxc_isi_pipe_register(struct mxc_isi_pipe *pipe)\n{\n\tint ret;\n\n\tret = v4l2_device_register_subdev(&pipe->isi->v4l2_dev, &pipe->sd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mxc_isi_video_register(pipe, &pipe->isi->v4l2_dev);\n}\n\nstatic void mxc_isi_pipe_unregister(struct mxc_isi_pipe *pipe)\n{\n\tmxc_isi_video_unregister(pipe);\n}\n\nstatic int mxc_isi_v4l2_init(struct mxc_isi_dev *isi)\n{\n\tstruct fwnode_handle *node = dev_fwnode(isi->dev);\n\tstruct media_device *media_dev = &isi->media_dev;\n\tstruct v4l2_device *v4l2_dev = &isi->v4l2_dev;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tstrscpy(media_dev->model, \"FSL Capture Media Device\",\n\t\tsizeof(media_dev->model));\n\tmedia_dev->dev = isi->dev;\n\n\tmedia_device_init(media_dev);\n\n\t \n\tv4l2_dev->mdev = media_dev;\n\tstrscpy(v4l2_dev->name, \"mx8-img-md\", sizeof(v4l2_dev->name));\n\n\tret = v4l2_device_register(isi->dev, v4l2_dev);\n\tif (ret < 0) {\n\t\tdev_err(isi->dev,\n\t\t\t\"Failed to register V4L2 device: %d\\n\", ret);\n\t\tgoto err_media;\n\t}\n\n\t \n\tret = mxc_isi_crossbar_register(&isi->crossbar);\n\tif (ret < 0) {\n\t\tdev_err(isi->dev, \"Failed to register crossbar: %d\\n\", ret);\n\t\tgoto err_v4l2;\n\t}\n\n\t \n\tfor (i = 0; i < isi->pdata->num_channels; ++i) {\n\t\tstruct mxc_isi_pipe *pipe = &isi->pipes[i];\n\n\t\tret = mxc_isi_pipe_register(pipe);\n\t\tif (ret < 0) {\n\t\t\tdev_err(isi->dev, \"Failed to register pipe%u: %d\\n\", i,\n\t\t\t\tret);\n\t\t\tgoto err_v4l2;\n\t\t}\n\n\t\tret = media_create_pad_link(&isi->crossbar.sd.entity,\n\t\t\t\t\t    isi->crossbar.num_sinks + i,\n\t\t\t\t\t    &pipe->sd.entity,\n\t\t\t\t\t    MXC_ISI_PIPE_PAD_SINK,\n\t\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\t\tif (ret < 0)\n\t\t\tgoto err_v4l2;\n\t}\n\n\t \n\tret = mxc_isi_m2m_register(isi, v4l2_dev);\n\tif (ret < 0) {\n\t\tdev_err(isi->dev, \"Failed to register M2M device: %d\\n\", ret);\n\t\tgoto err_v4l2;\n\t}\n\n\t \n\tv4l2_async_nf_init(&isi->notifier, v4l2_dev);\n\tisi->notifier.ops = &mxc_isi_async_notifier_ops;\n\n\tfor (i = 0; i < isi->pdata->num_ports; ++i) {\n\t\tstruct mxc_isi_async_subdev *masd;\n\t\tstruct fwnode_handle *ep;\n\n\t\tep = fwnode_graph_get_endpoint_by_id(node, i, 0,\n\t\t\t\t\t\t     FWNODE_GRAPH_ENDPOINT_NEXT);\n\n\t\tif (!ep)\n\t\t\tcontinue;\n\n\t\tmasd = v4l2_async_nf_add_fwnode_remote(&isi->notifier, ep,\n\t\t\t\t\t\t       struct mxc_isi_async_subdev);\n\t\tfwnode_handle_put(ep);\n\n\t\tif (IS_ERR(masd)) {\n\t\t\tret = PTR_ERR(masd);\n\t\t\tgoto err_m2m;\n\t\t}\n\n\t\tmasd->port = i;\n\t}\n\n\tret = v4l2_async_nf_register(&isi->notifier);\n\tif (ret < 0) {\n\t\tdev_err(isi->dev,\n\t\t\t\"Failed to register async notifier: %d\\n\", ret);\n\t\tgoto err_m2m;\n\t}\n\n\treturn 0;\n\nerr_m2m:\n\tmxc_isi_m2m_unregister(isi);\n\tv4l2_async_nf_cleanup(&isi->notifier);\nerr_v4l2:\n\tv4l2_device_unregister(v4l2_dev);\nerr_media:\n\tmedia_device_cleanup(media_dev);\n\treturn ret;\n}\n\nstatic void mxc_isi_v4l2_cleanup(struct mxc_isi_dev *isi)\n{\n\tunsigned int i;\n\n\tv4l2_async_nf_unregister(&isi->notifier);\n\tv4l2_async_nf_cleanup(&isi->notifier);\n\n\tv4l2_device_unregister(&isi->v4l2_dev);\n\tmedia_device_unregister(&isi->media_dev);\n\n\tmxc_isi_m2m_unregister(isi);\n\n\tfor (i = 0; i < isi->pdata->num_channels; ++i)\n\t\tmxc_isi_pipe_unregister(&isi->pipes[i]);\n\n\tmxc_isi_crossbar_unregister(&isi->crossbar);\n\n\tmedia_device_cleanup(&isi->media_dev);\n}\n\n \n\n \n\n \nstatic const struct mxc_isi_ier_reg mxc_imx8_isi_ier_v1 = {\n\t.oflw_y_buf_en = { .offset = 19, .mask = 0x80000  },\n\t.oflw_u_buf_en = { .offset = 21, .mask = 0x200000 },\n\t.oflw_v_buf_en = { .offset = 23, .mask = 0x800000 },\n\n\t.panic_y_buf_en = {.offset = 20, .mask = 0x100000  },\n\t.panic_u_buf_en = {.offset = 22, .mask = 0x400000  },\n\t.panic_v_buf_en = {.offset = 24, .mask = 0x1000000 },\n};\n\n \nstatic const struct mxc_isi_ier_reg mxc_imx8_isi_ier_v2 = {\n\t.oflw_y_buf_en = { .offset = 18, .mask = 0x40000  },\n\t.oflw_u_buf_en = { .offset = 20, .mask = 0x100000 },\n\t.oflw_v_buf_en = { .offset = 22, .mask = 0x400000 },\n\n\t.panic_y_buf_en = {.offset = 19, .mask = 0x80000  },\n\t.panic_u_buf_en = {.offset = 21, .mask = 0x200000 },\n\t.panic_v_buf_en = {.offset = 23, .mask = 0x800000 },\n};\n\n \nstatic const struct mxc_isi_set_thd mxc_imx8_isi_thd_v1 = {\n\t.panic_set_thd_y = { .mask = 0x0000f, .offset = 0,  .threshold = 0x7 },\n\t.panic_set_thd_u = { .mask = 0x00f00, .offset = 8,  .threshold = 0x7 },\n\t.panic_set_thd_v = { .mask = 0xf0000, .offset = 16, .threshold = 0x7 },\n};\n\nstatic const struct clk_bulk_data mxc_imx8mn_clks[] = {\n\t{ .id = \"axi\" },\n\t{ .id = \"apb\" },\n};\n\nstatic const struct mxc_isi_plat_data mxc_imx8mn_data = {\n\t.model\t\t\t= MXC_ISI_IMX8MN,\n\t.num_ports\t\t= 1,\n\t.num_channels\t\t= 1,\n\t.reg_offset\t\t= 0,\n\t.ier_reg\t\t= &mxc_imx8_isi_ier_v1,\n\t.set_thd\t\t= &mxc_imx8_isi_thd_v1,\n\t.clks\t\t\t= mxc_imx8mn_clks,\n\t.num_clks\t\t= ARRAY_SIZE(mxc_imx8mn_clks),\n\t.buf_active_reverse\t= false,\n\t.gasket_ops\t\t= &mxc_imx8_gasket_ops,\n\t.has_36bit_dma\t\t= false,\n};\n\nstatic const struct mxc_isi_plat_data mxc_imx8mp_data = {\n\t.model\t\t\t= MXC_ISI_IMX8MP,\n\t.num_ports\t\t= 2,\n\t.num_channels\t\t= 2,\n\t.reg_offset\t\t= 0x2000,\n\t.ier_reg\t\t= &mxc_imx8_isi_ier_v2,\n\t.set_thd\t\t= &mxc_imx8_isi_thd_v1,\n\t.clks\t\t\t= mxc_imx8mn_clks,\n\t.num_clks\t\t= ARRAY_SIZE(mxc_imx8mn_clks),\n\t.buf_active_reverse\t= true,\n\t.gasket_ops\t\t= &mxc_imx8_gasket_ops,\n\t.has_36bit_dma\t\t= true,\n};\n\nstatic const struct mxc_isi_plat_data mxc_imx93_data = {\n\t.model\t\t\t= MXC_ISI_IMX93,\n\t.num_ports\t\t= 1,\n\t.num_channels\t\t= 1,\n\t.reg_offset\t\t= 0,\n\t.ier_reg\t\t= &mxc_imx8_isi_ier_v2,\n\t.set_thd\t\t= &mxc_imx8_isi_thd_v1,\n\t.clks\t\t\t= mxc_imx8mn_clks,\n\t.num_clks\t\t= ARRAY_SIZE(mxc_imx8mn_clks),\n\t.buf_active_reverse\t= true,\n\t.gasket_ops\t\t= &mxc_imx93_gasket_ops,\n\t.has_36bit_dma\t\t= false,\n};\n\n \n\nstatic int mxc_isi_pm_suspend(struct device *dev)\n{\n\tstruct mxc_isi_dev *isi = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\tfor (i = 0; i < isi->pdata->num_channels; ++i) {\n\t\tstruct mxc_isi_pipe *pipe = &isi->pipes[i];\n\n\t\tmxc_isi_video_suspend(pipe);\n\t}\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int mxc_isi_pm_resume(struct device *dev)\n{\n\tstruct mxc_isi_dev *isi = dev_get_drvdata(dev);\n\tunsigned int i;\n\tint err = 0;\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < isi->pdata->num_channels; ++i) {\n\t\tstruct mxc_isi_pipe *pipe = &isi->pipes[i];\n\n\t\tret = mxc_isi_video_resume(pipe);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to resume pipeline %u (%d)\\n\", i,\n\t\t\t\tret);\n\t\t\t \n\t\t\terr = ret;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int mxc_isi_runtime_suspend(struct device *dev)\n{\n\tstruct mxc_isi_dev *isi = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(isi->pdata->num_clks, isi->clks);\n\n\treturn 0;\n}\n\nstatic int mxc_isi_runtime_resume(struct device *dev)\n{\n\tstruct mxc_isi_dev *isi = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(isi->pdata->num_clks, isi->clks);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable clocks (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mxc_isi_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(mxc_isi_pm_suspend, mxc_isi_pm_resume)\n\tRUNTIME_PM_OPS(mxc_isi_runtime_suspend, mxc_isi_runtime_resume, NULL)\n};\n\n \n\nstatic int mxc_isi_clk_get(struct mxc_isi_dev *isi)\n{\n\tunsigned int size = isi->pdata->num_clks\n\t\t\t  * sizeof(*isi->clks);\n\tint ret;\n\n\tisi->clks = devm_kmalloc(isi->dev, size, GFP_KERNEL);\n\tif (!isi->clks)\n\t\treturn -ENOMEM;\n\n\tmemcpy(isi->clks, isi->pdata->clks, size);\n\n\tret = devm_clk_bulk_get(isi->dev, isi->pdata->num_clks,\n\t\t\t\tisi->clks);\n\tif (ret < 0) {\n\t\tdev_err(isi->dev, \"Failed to acquire clocks: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxc_isi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mxc_isi_dev *isi;\n\tunsigned int dma_size;\n\tunsigned int i;\n\tint ret = 0;\n\n\tisi = devm_kzalloc(dev, sizeof(*isi), GFP_KERNEL);\n\tif (!isi)\n\t\treturn -ENOMEM;\n\n\tisi->dev = dev;\n\tplatform_set_drvdata(pdev, isi);\n\n\tisi->pdata = of_device_get_match_data(dev);\n\n\tisi->pipes = kcalloc(isi->pdata->num_channels, sizeof(isi->pipes[0]),\n\t\t\t     GFP_KERNEL);\n\tif (!isi->pipes)\n\t\treturn -ENOMEM;\n\n\tret = mxc_isi_clk_get(isi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to get clocks\\n\");\n\t\treturn ret;\n\t}\n\n\tisi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(isi->regs)) {\n\t\tdev_err(dev, \"Failed to get ISI register map\\n\");\n\t\treturn PTR_ERR(isi->regs);\n\t}\n\n\tif (isi->pdata->gasket_ops) {\n\t\tisi->gasket = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t      \"fsl,blk-ctrl\");\n\t\tif (IS_ERR(isi->gasket)) {\n\t\t\tret = PTR_ERR(isi->gasket);\n\t\t\tdev_err(dev, \"failed to get gasket: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdma_size = isi->pdata->has_36bit_dma ? 36 : 32;\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(dma_size));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set DMA mask\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\tret = mxc_isi_crossbar_init(isi);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize crossbar: %d\\n\", ret);\n\t\tgoto err_pm;\n\t}\n\n\tfor (i = 0; i < isi->pdata->num_channels; ++i) {\n\t\tret = mxc_isi_pipe_init(isi, i);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to initialize pipe%u: %d\\n\", i,\n\t\t\t\tret);\n\t\t\tgoto err_xbar;\n\t\t}\n\t}\n\n\tret = mxc_isi_v4l2_init(isi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to initialize V4L2: %d\\n\", ret);\n\t\tgoto err_xbar;\n\t}\n\n\tmxc_isi_debug_init(isi);\n\n\treturn 0;\n\nerr_xbar:\n\tmxc_isi_crossbar_cleanup(&isi->crossbar);\nerr_pm:\n\tpm_runtime_disable(isi->dev);\n\treturn ret;\n}\n\nstatic int mxc_isi_remove(struct platform_device *pdev)\n{\n\tstruct mxc_isi_dev *isi = platform_get_drvdata(pdev);\n\tunsigned int i;\n\n\tmxc_isi_debug_cleanup(isi);\n\n\tfor (i = 0; i < isi->pdata->num_channels; ++i) {\n\t\tstruct mxc_isi_pipe *pipe = &isi->pipes[i];\n\n\t\tmxc_isi_pipe_cleanup(pipe);\n\t}\n\n\tmxc_isi_crossbar_cleanup(&isi->crossbar);\n\tmxc_isi_v4l2_cleanup(isi);\n\n\tpm_runtime_disable(isi->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mxc_isi_of_match[] = {\n\t{ .compatible = \"fsl,imx8mn-isi\", .data = &mxc_imx8mn_data },\n\t{ .compatible = \"fsl,imx8mp-isi\", .data = &mxc_imx8mp_data },\n\t{ .compatible = \"fsl,imx93-isi\", .data = &mxc_imx93_data },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, mxc_isi_of_match);\n\nstatic struct platform_driver mxc_isi_driver = {\n\t.probe\t\t= mxc_isi_probe,\n\t.remove\t\t= mxc_isi_remove,\n\t.driver = {\n\t\t.of_match_table = mxc_isi_of_match,\n\t\t.name\t\t= MXC_ISI_DRIVER_NAME,\n\t\t.pm\t\t= pm_ptr(&mxc_isi_pm_ops),\n\t}\n};\nmodule_platform_driver(mxc_isi_driver);\n\nMODULE_ALIAS(\"ISI\");\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"IMX8 Image Sensing Interface driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}