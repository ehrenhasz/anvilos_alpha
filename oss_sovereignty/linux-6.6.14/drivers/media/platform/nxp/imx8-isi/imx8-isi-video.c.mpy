{
  "module_name": "imx8-isi-video.c",
  "hash_id": "231a698489d4f45fcacaa942b5909f54d9545fd244c1b569a3aea2e1da6313ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/imx8-isi/imx8-isi-video.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/minmax.h>\n#include <linux/pm_runtime.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n\n#include <media/media-entity.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-core.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"imx8-isi-core.h\"\n#include \"imx8-isi-regs.h\"\n\n \nstatic const struct mxc_isi_format_info mxc_isi_formats[] = {\n\t \n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUV8_1X24,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP | MXC_ISI_VIDEO_M2M_OUT\n\t\t\t\t| MXC_ISI_VIDEO_M2M_CAP,\n\t\t.isi_in_format\t= CHNL_MEM_RD_CTRL_IMG_TYPE_YUV422_1P8P,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_YUV422_1P8P,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_YUV,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUV8_1X24,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUVA32,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP | MXC_ISI_VIDEO_M2M_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_YUV444_1P8,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 32 },\n\t\t.encoding\t= MXC_ISI_ENC_YUV,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUV8_1X24,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP | MXC_ISI_VIDEO_M2M_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_YUV420_2P8P,\n\t\t.color_planes\t= 2,\n\t\t.mem_planes\t= 1,\n\t\t.depth\t\t= { 8, 16 },\n\t\t.hsub\t\t= 2,\n\t\t.vsub\t\t= 2,\n\t\t.encoding\t= MXC_ISI_ENC_YUV,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUV8_1X24,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12M,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP | MXC_ISI_VIDEO_M2M_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_YUV420_2P8P,\n\t\t.mem_planes\t= 2,\n\t\t.color_planes\t= 2,\n\t\t.depth\t\t= { 8, 16 },\n\t\t.hsub\t\t= 2,\n\t\t.vsub\t\t= 2,\n\t\t.encoding\t= MXC_ISI_ENC_YUV,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUV8_1X24,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV16,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP | MXC_ISI_VIDEO_M2M_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_YUV422_2P8P,\n\t\t.color_planes\t= 2,\n\t\t.mem_planes\t= 1,\n\t\t.depth\t\t= { 8, 16 },\n\t\t.hsub\t\t= 2,\n\t\t.vsub\t\t= 1,\n\t\t.encoding\t= MXC_ISI_ENC_YUV,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUV8_1X24,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV16M,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP | MXC_ISI_VIDEO_M2M_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_YUV422_2P8P,\n\t\t.mem_planes\t= 2,\n\t\t.color_planes\t= 2,\n\t\t.depth\t\t= { 8, 16 },\n\t\t.hsub\t\t= 2,\n\t\t.vsub\t\t= 1,\n\t\t.encoding\t= MXC_ISI_ENC_YUV,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUV8_1X24,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV444M,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP | MXC_ISI_VIDEO_M2M_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_YUV444_3P8P,\n\t\t.mem_planes\t= 3,\n\t\t.color_planes\t= 3,\n\t\t.depth\t\t= { 8, 8, 8 },\n\t\t.hsub\t\t= 1,\n\t\t.vsub\t\t= 1,\n\t\t.encoding\t= MXC_ISI_ENC_YUV,\n\t},\n\t \n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB888_1X24,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB565,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP | MXC_ISI_VIDEO_M2M_OUT\n\t\t\t\t| MXC_ISI_VIDEO_M2M_CAP,\n\t\t.isi_in_format\t= CHNL_MEM_RD_CTRL_IMG_TYPE_RGB565,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RGB565,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RGB,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB888_1X24,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_RGB24,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP | MXC_ISI_VIDEO_M2M_OUT\n\t\t\t\t| MXC_ISI_VIDEO_M2M_CAP,\n\t\t.isi_in_format\t= CHNL_MEM_RD_CTRL_IMG_TYPE_BGR8P,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_BGR888P,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 24 },\n\t\t.encoding\t= MXC_ISI_ENC_RGB,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB888_1X24,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_BGR24,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP | MXC_ISI_VIDEO_M2M_OUT\n\t\t\t\t| MXC_ISI_VIDEO_M2M_CAP,\n\t\t.isi_in_format\t= CHNL_MEM_RD_CTRL_IMG_TYPE_RGB8P,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RGB888P,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 24 },\n\t\t.encoding\t= MXC_ISI_ENC_RGB,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB888_1X24,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_XBGR32,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP | MXC_ISI_VIDEO_M2M_OUT\n\t\t\t\t| MXC_ISI_VIDEO_M2M_CAP,\n\t\t.isi_in_format\t= CHNL_MEM_RD_CTRL_IMG_TYPE_XBGR8,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_XRGB888,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 32 },\n\t\t.encoding\t= MXC_ISI_ENC_RGB,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB888_1X24,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_ABGR32,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP | MXC_ISI_VIDEO_M2M_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_ARGB8888,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 32 },\n\t\t.encoding\t= MXC_ISI_ENC_RGB,\n\t},\n\t \n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_Y8_1X8,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_GREY,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW8,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 8 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_Y10_1X10,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_Y10,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_Y12_1X12,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_Y12,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_Y14_1X14,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_Y14,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR8,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW8,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 8 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG8,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW8,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 8 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG8,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW8,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 8 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB8,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW8,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 8 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR10,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG10,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG10,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB10,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR12,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG12,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG12,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB12,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR14_1X14,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SBGGR14,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG14_1X14,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGBRG14,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG14_1X14,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SGRBG14,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB14_1X14,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_SRGGB14,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW16,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 16 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t},\n\t \n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_JPEG_1X8,\n\t\t.fourcc\t\t= V4L2_PIX_FMT_MJPEG,\n\t\t.type\t\t= MXC_ISI_VIDEO_CAP,\n\t\t.isi_out_format\t= CHNL_IMG_CTRL_FORMAT_RAW8,\n\t\t.mem_planes\t= 1,\n\t\t.color_planes\t= 1,\n\t\t.depth\t\t= { 8 },\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}\n};\n\nconst struct mxc_isi_format_info *\nmxc_isi_format_by_fourcc(u32 fourcc, enum mxc_isi_video_type type)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mxc_isi_formats); i++) {\n\t\tconst struct mxc_isi_format_info *fmt = &mxc_isi_formats[i];\n\n\t\tif (fmt->fourcc == fourcc && fmt->type & type)\n\t\t\treturn fmt;\n\t}\n\n\treturn NULL;\n}\n\nconst struct mxc_isi_format_info *\nmxc_isi_format_enum(unsigned int index, enum mxc_isi_video_type type)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mxc_isi_formats); i++) {\n\t\tconst struct mxc_isi_format_info *fmt = &mxc_isi_formats[i];\n\n\t\tif (!(fmt->type & type))\n\t\t\tcontinue;\n\n\t\tif (!index)\n\t\t\treturn fmt;\n\n\t\tindex--;\n\t}\n\n\treturn NULL;\n}\n\nconst struct mxc_isi_format_info *\nmxc_isi_format_try(struct mxc_isi_pipe *pipe, struct v4l2_pix_format_mplane *pix,\n\t\t   enum mxc_isi_video_type type)\n{\n\tconst struct mxc_isi_format_info *fmt;\n\tunsigned int max_width;\n\tunsigned int i;\n\n\tmax_width = pipe->id == pipe->isi->pdata->num_channels - 1\n\t\t  ? MXC_ISI_MAX_WIDTH_UNCHAINED\n\t\t  : MXC_ISI_MAX_WIDTH_CHAINED;\n\n\tfmt = mxc_isi_format_by_fourcc(pix->pixelformat, type);\n\tif (!fmt)\n\t\tfmt = &mxc_isi_formats[0];\n\n\tpix->width = clamp(pix->width, MXC_ISI_MIN_WIDTH, max_width);\n\tpix->height = clamp(pix->height, MXC_ISI_MIN_HEIGHT, MXC_ISI_MAX_HEIGHT);\n\tpix->pixelformat = fmt->fourcc;\n\tpix->field = V4L2_FIELD_NONE;\n\n\tif (pix->colorspace == V4L2_COLORSPACE_DEFAULT) {\n\t\tpix->colorspace = MXC_ISI_DEF_COLOR_SPACE;\n\t\tpix->ycbcr_enc = MXC_ISI_DEF_YCBCR_ENC;\n\t\tpix->quantization = MXC_ISI_DEF_QUANTIZATION;\n\t\tpix->xfer_func = MXC_ISI_DEF_XFER_FUNC;\n\t}\n\n\tif (pix->ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT)\n\t\tpix->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(pix->colorspace);\n\tif (pix->quantization == V4L2_QUANTIZATION_DEFAULT) {\n\t\tbool is_rgb = fmt->encoding == MXC_ISI_ENC_RGB;\n\n\t\tpix->quantization =\n\t\t\tV4L2_MAP_QUANTIZATION_DEFAULT(is_rgb, pix->colorspace,\n\t\t\t\t\t\t      pix->ycbcr_enc);\n\t}\n\tif (pix->xfer_func == V4L2_XFER_FUNC_DEFAULT)\n\t\tpix->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(pix->colorspace);\n\n\tpix->num_planes = fmt->mem_planes;\n\n\tfor (i = 0; i < fmt->color_planes; ++i) {\n\t\tstruct v4l2_plane_pix_format *plane = &pix->plane_fmt[i];\n\t\tunsigned int bpl;\n\n\t\t \n\t\tif (i == 0)\n\t\t\tbpl = clamp(plane->bytesperline,\n\t\t\t\t    pix->width * fmt->depth[0] / 8,\n\t\t\t\t    65535U);\n\t\telse\n\t\t\tbpl = pix->plane_fmt[0].bytesperline;\n\n\t\tplane->bytesperline = bpl;\n\n\t\tplane->sizeimage = plane->bytesperline * pix->height;\n\t\tif (i >= 1)\n\t\t\tplane->sizeimage /= fmt->vsub;\n\t}\n\n\t \n\tif (fmt->color_planes != fmt->mem_planes) {\n\t\tfor (i = 1; i < fmt->color_planes; ++i) {\n\t\t\tstruct v4l2_plane_pix_format *plane = &pix->plane_fmt[i];\n\n\t\t\tpix->plane_fmt[0].sizeimage += plane->sizeimage;\n\t\t\tplane->bytesperline = 0;\n\t\t\tplane->sizeimage = 0;\n\t\t}\n\t}\n\n\treturn fmt;\n}\n\n \n\nstatic void mxc_isi_video_frame_write_done(struct mxc_isi_pipe *pipe,\n\t\t\t\t\t   u32 status)\n{\n\tstruct mxc_isi_video *video = &pipe->video;\n\tstruct device *dev = pipe->isi->dev;\n\tstruct mxc_isi_buffer *next_buf;\n\tstruct mxc_isi_buffer *buf;\n\tenum mxc_isi_buf_id buf_id;\n\n\tspin_lock(&video->buf_lock);\n\n\t \n\n\t \n\tbuf_id = pipe->isi->pdata->buf_active_reverse\n\t       ? (status & CHNL_STS_BUF1_ACTIVE ? MXC_ISI_BUF2 : MXC_ISI_BUF1)\n\t       : (status & CHNL_STS_BUF1_ACTIVE ? MXC_ISI_BUF1 : MXC_ISI_BUF2);\n\n\tbuf = list_first_entry_or_null(&video->out_active,\n\t\t\t\t       struct mxc_isi_buffer, list);\n\n\t \n\tif (!buf) {\n\t\tdev_warn(dev, \"trying to access empty active list\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tif (buf->id != buf_id) {\n\t\tdev_dbg(dev, \"buffer ID mismatch (expected %u, got %u), skipping\\n\",\n\t\t\tbuf->id, buf_id);\n\n\t\t \n\t\tvideo->frame_count += 2;\n\t\tgoto done;\n\t}\n\n\t \n\tnext_buf = list_first_entry_or_null(&video->out_pending,\n\t\t\t\t\t    struct mxc_isi_buffer, list);\n\tif (!next_buf) {\n\t\tnext_buf = list_first_entry_or_null(&video->out_discard,\n\t\t\t\t\t\t    struct mxc_isi_buffer, list);\n\n\t\t \n\t\tif (!next_buf) {\n\t\t\tdev_warn(dev, \"trying to access empty discard list\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tmxc_isi_channel_set_outbuf(pipe, next_buf->dma_addrs, buf_id);\n\tnext_buf->id = buf_id;\n\n\t \n\tstatus = mxc_isi_channel_irq_status(pipe, false);\n\tif (status & CHNL_STS_FRM_STRD) {\n\t\tdev_dbg(dev, \"raced with frame end interrupt\\n\");\n\t\tvideo->frame_count += 2;\n\t\tgoto done;\n\t}\n\n\t \n\tlist_move_tail(&next_buf->list, &video->out_active);\n\n\tif (!buf->discard) {\n\t\tlist_del_init(&buf->list);\n\t\tbuf->v4l2_buf.sequence = video->frame_count;\n\t\tbuf->v4l2_buf.vb2_buf.timestamp = ktime_get_ns();\n\t\tvb2_buffer_done(&buf->v4l2_buf.vb2_buf, VB2_BUF_STATE_DONE);\n\t} else {\n\t\tlist_move_tail(&buf->list, &video->out_discard);\n\t}\n\n\tvideo->frame_count++;\n\ndone:\n\tspin_unlock(&video->buf_lock);\n}\n\nstatic void mxc_isi_video_free_discard_buffers(struct mxc_isi_video *video)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < video->pix.num_planes; i++) {\n\t\tstruct mxc_isi_dma_buffer *buf = &video->discard_buffer[i];\n\n\t\tif (!buf->addr)\n\t\t\tcontinue;\n\n\t\tdma_free_coherent(video->pipe->isi->dev, buf->size, buf->addr,\n\t\t\t\t  buf->dma);\n\t\tbuf->addr = NULL;\n\t}\n}\n\nstatic int mxc_isi_video_alloc_discard_buffers(struct mxc_isi_video *video)\n{\n\tunsigned int i, j;\n\n\t \n\tfor (i = 0; i < video->pix.num_planes; i++) {\n\t\tstruct mxc_isi_dma_buffer *buf = &video->discard_buffer[i];\n\n\t\tbuf->size = PAGE_ALIGN(video->pix.plane_fmt[i].sizeimage);\n\t\tbuf->addr = dma_alloc_coherent(video->pipe->isi->dev, buf->size,\n\t\t\t\t\t       &buf->dma, GFP_DMA | GFP_KERNEL);\n\t\tif (!buf->addr) {\n\t\t\tmxc_isi_video_free_discard_buffers(video);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdev_dbg(video->pipe->isi->dev,\n\t\t\t\"discard buffer plane %u: %zu bytes @%pad (CPU address %p)\\n\",\n\t\t\ti, buf->size, &buf->dma, buf->addr);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(video->buf_discard); ++i) {\n\t\tstruct mxc_isi_buffer *buf = &video->buf_discard[i];\n\n\t\tbuf->discard = true;\n\n\t\tfor (j = 0; j < video->pix.num_planes; ++j)\n\t\t\tbuf->dma_addrs[j] = video->discard_buffer[j].dma;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxc_isi_video_validate_format(struct mxc_isi_video *video)\n{\n\tconst struct v4l2_mbus_framefmt *format;\n\tconst struct mxc_isi_format_info *info;\n\tstruct v4l2_subdev_state *state;\n\tstruct v4l2_subdev *sd = &video->pipe->sd;\n\tint ret = 0;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tinfo = mxc_isi_format_by_fourcc(video->pix.pixelformat,\n\t\t\t\t\tMXC_ISI_VIDEO_CAP);\n\tformat = v4l2_subdev_get_try_format(sd, state, MXC_ISI_PIPE_PAD_SOURCE);\n\n\tif (format->code != info->mbus_code ||\n\t    format->width != video->pix.width ||\n\t    format->height != video->pix.height) {\n\t\tdev_dbg(video->pipe->isi->dev,\n\t\t\t\"%s: configuration mismatch, 0x%04x/%ux%u != 0x%04x/%ux%u\\n\",\n\t\t\t__func__, format->code, format->width, format->height,\n\t\t\tinfo->mbus_code, video->pix.width, video->pix.height);\n\t\tret = -EINVAL;\n\t}\n\n\tv4l2_subdev_unlock_state(state);\n\n\treturn ret;\n}\n\nstatic void mxc_isi_video_return_buffers(struct mxc_isi_video *video,\n\t\t\t\t\t enum vb2_buffer_state state)\n{\n\tstruct mxc_isi_buffer *buf;\n\n\tspin_lock_irq(&video->buf_lock);\n\n\twhile (!list_empty(&video->out_active)) {\n\t\tbuf = list_first_entry(&video->out_active,\n\t\t\t\t       struct mxc_isi_buffer, list);\n\t\tlist_del_init(&buf->list);\n\t\tif (buf->discard)\n\t\t\tcontinue;\n\n\t\tvb2_buffer_done(&buf->v4l2_buf.vb2_buf, state);\n\t}\n\n\twhile (!list_empty(&video->out_pending)) {\n\t\tbuf = list_first_entry(&video->out_pending,\n\t\t\t\t       struct mxc_isi_buffer, list);\n\t\tlist_del_init(&buf->list);\n\t\tvb2_buffer_done(&buf->v4l2_buf.vb2_buf, state);\n\t}\n\n\twhile (!list_empty(&video->out_discard)) {\n\t\tbuf = list_first_entry(&video->out_discard,\n\t\t\t\t       struct mxc_isi_buffer, list);\n\t\tlist_del_init(&buf->list);\n\t}\n\n\tINIT_LIST_HEAD(&video->out_active);\n\tINIT_LIST_HEAD(&video->out_pending);\n\tINIT_LIST_HEAD(&video->out_discard);\n\n\tspin_unlock_irq(&video->buf_lock);\n}\n\nstatic void mxc_isi_video_queue_first_buffers(struct mxc_isi_video *video)\n{\n\tunsigned int discard;\n\tunsigned int i;\n\n\tlockdep_assert_held(&video->buf_lock);\n\n\t \n\n\t \n\tdiscard = list_empty(&video->out_pending) ? 2\n\t\t: list_is_singular(&video->out_pending) ? 1\n\t\t: 0;\n\n\tfor (i = 0; i < 2; ++i) {\n\t\tenum mxc_isi_buf_id buf_id = i == 0 ? MXC_ISI_BUF1\n\t\t\t\t\t   : MXC_ISI_BUF2;\n\t\tstruct mxc_isi_buffer *buf;\n\t\tstruct list_head *list;\n\n\t\tlist = i < discard ? &video->out_discard : &video->out_pending;\n\t\tbuf = list_first_entry(list, struct mxc_isi_buffer, list);\n\n\t\tmxc_isi_channel_set_outbuf(video->pipe, buf->dma_addrs, buf_id);\n\t\tbuf->id = buf_id;\n\t\tlist_move_tail(&buf->list, &video->out_active);\n\t}\n}\n\nstatic inline struct mxc_isi_buffer *to_isi_buffer(struct vb2_v4l2_buffer *v4l2_buf)\n{\n\treturn container_of(v4l2_buf, struct mxc_isi_buffer, v4l2_buf);\n}\n\nint mxc_isi_video_queue_setup(const struct v4l2_pix_format_mplane *format,\n\t\t\t      const struct mxc_isi_format_info *info,\n\t\t\t      unsigned int *num_buffers,\n\t\t\t      unsigned int *num_planes, unsigned int sizes[])\n{\n\tunsigned int i;\n\n\tif (*num_planes) {\n\t\tif (*num_planes != info->mem_planes)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < info->mem_planes; ++i) {\n\t\t\tif (sizes[i] < format->plane_fmt[i].sizeimage)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t*num_planes = info->mem_planes;\n\n\tfor (i = 0; i < info->mem_planes; ++i)\n\t\tsizes[i] = format->plane_fmt[i].sizeimage;\n\n\treturn 0;\n}\n\nvoid mxc_isi_video_buffer_init(struct vb2_buffer *vb2, dma_addr_t dma_addrs[3],\n\t\t\t       const struct mxc_isi_format_info *info,\n\t\t\t       const struct v4l2_pix_format_mplane *pix)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < info->mem_planes; ++i)\n\t\tdma_addrs[i] = vb2_dma_contig_plane_dma_addr(vb2, i);\n\n\t \n\tif (info->color_planes != info->mem_planes) {\n\t\tunsigned int size = pix->plane_fmt[0].bytesperline * pix->height;\n\n\t\tfor (i = 1; i < info->color_planes; ++i) {\n\t\t\tunsigned int vsub = i > 1 ? info->vsub : 1;\n\n\t\t\tdma_addrs[i] = dma_addrs[i - 1] + size / vsub;\n\t\t}\n\t}\n}\n\nint mxc_isi_video_buffer_prepare(struct mxc_isi_dev *isi, struct vb2_buffer *vb2,\n\t\t\t\t const struct mxc_isi_format_info *info,\n\t\t\t\t const struct v4l2_pix_format_mplane *pix)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < info->mem_planes; i++) {\n\t\tunsigned long size = pix->plane_fmt[i].sizeimage;\n\n\t\tif (vb2_plane_size(vb2, i) < size) {\n\t\t\tdev_err(isi->dev, \"User buffer too small (%ld < %ld)\\n\",\n\t\t\t\tvb2_plane_size(vb2, i), size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvb2_set_plane_payload(vb2, i, size);\n\t}\n\n\treturn 0;\n}\n\nstatic int mxc_isi_vb2_queue_setup(struct vb2_queue *q,\n\t\t\t\t   unsigned int *num_buffers,\n\t\t\t\t   unsigned int *num_planes,\n\t\t\t\t   unsigned int sizes[],\n\t\t\t\t   struct device *alloc_devs[])\n{\n\tstruct mxc_isi_video *video = vb2_get_drv_priv(q);\n\n\treturn mxc_isi_video_queue_setup(&video->pix, video->fmtinfo,\n\t\t\t\t\t num_buffers, num_planes, sizes);\n}\n\nstatic int mxc_isi_vb2_buffer_init(struct vb2_buffer *vb2)\n{\n\tstruct mxc_isi_buffer *buf = to_isi_buffer(to_vb2_v4l2_buffer(vb2));\n\tstruct mxc_isi_video *video = vb2_get_drv_priv(vb2->vb2_queue);\n\n\tmxc_isi_video_buffer_init(vb2, buf->dma_addrs, video->fmtinfo,\n\t\t\t\t  &video->pix);\n\n\treturn 0;\n}\n\nstatic int mxc_isi_vb2_buffer_prepare(struct vb2_buffer *vb2)\n{\n\tstruct mxc_isi_video *video = vb2_get_drv_priv(vb2->vb2_queue);\n\n\treturn mxc_isi_video_buffer_prepare(video->pipe->isi, vb2,\n\t\t\t\t\t    video->fmtinfo, &video->pix);\n}\n\nstatic void mxc_isi_vb2_buffer_queue(struct vb2_buffer *vb2)\n{\n\tstruct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb2);\n\tstruct mxc_isi_buffer *buf = to_isi_buffer(v4l2_buf);\n\tstruct mxc_isi_video *video = vb2_get_drv_priv(vb2->vb2_queue);\n\n\tspin_lock_irq(&video->buf_lock);\n\tlist_add_tail(&buf->list, &video->out_pending);\n\tspin_unlock_irq(&video->buf_lock);\n}\n\nstatic void mxc_isi_video_init_channel(struct mxc_isi_video *video)\n{\n\tstruct mxc_isi_pipe *pipe = video->pipe;\n\n\tmxc_isi_channel_get(pipe);\n\n\tmutex_lock(video->ctrls.handler.lock);\n\tmxc_isi_channel_set_alpha(pipe, video->ctrls.alpha);\n\tmxc_isi_channel_set_flip(pipe, video->ctrls.hflip, video->ctrls.vflip);\n\tmutex_unlock(video->ctrls.handler.lock);\n\n\tmxc_isi_channel_set_output_format(pipe, video->fmtinfo, &video->pix);\n}\n\nstatic int mxc_isi_vb2_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct mxc_isi_video *video = vb2_get_drv_priv(q);\n\tunsigned int i;\n\tint ret;\n\n\t \n\tmxc_isi_video_init_channel(video);\n\n\tspin_lock_irq(&video->buf_lock);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(video->buf_discard); ++i) {\n\t\tstruct mxc_isi_buffer *buf = &video->buf_discard[i];\n\n\t\tlist_add_tail(&buf->list, &video->out_discard);\n\t}\n\n\t \n\tmxc_isi_video_queue_first_buffers(video);\n\n\t \n\tvideo->frame_count = 0;\n\n\tspin_unlock_irq(&video->buf_lock);\n\n\tret = mxc_isi_pipe_enable(video->pipe);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tmxc_isi_channel_put(video->pipe);\n\tmxc_isi_video_return_buffers(video, VB2_BUF_STATE_QUEUED);\n\treturn ret;\n}\n\nstatic void mxc_isi_vb2_stop_streaming(struct vb2_queue *q)\n{\n\tstruct mxc_isi_video *video = vb2_get_drv_priv(q);\n\n\tmxc_isi_pipe_disable(video->pipe);\n\tmxc_isi_channel_put(video->pipe);\n\n\tmxc_isi_video_return_buffers(video, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct vb2_ops mxc_isi_vb2_qops = {\n\t.queue_setup\t\t= mxc_isi_vb2_queue_setup,\n\t.buf_init\t\t= mxc_isi_vb2_buffer_init,\n\t.buf_prepare\t\t= mxc_isi_vb2_buffer_prepare,\n\t.buf_queue\t\t= mxc_isi_vb2_buffer_queue,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.start_streaming\t= mxc_isi_vb2_start_streaming,\n\t.stop_streaming\t\t= mxc_isi_vb2_stop_streaming,\n};\n\n \n\nstatic inline struct mxc_isi_video *ctrl_to_isi_video(struct v4l2_ctrl *ctrl)\n{\n\treturn container_of(ctrl->handler, struct mxc_isi_video, ctrls.handler);\n}\n\nstatic int mxc_isi_video_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mxc_isi_video *video = ctrl_to_isi_video(ctrl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_ALPHA_COMPONENT:\n\t\tvideo->ctrls.alpha = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tvideo->ctrls.vflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_HFLIP:\n\t\tvideo->ctrls.hflip = ctrl->val;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops mxc_isi_video_ctrl_ops = {\n\t.s_ctrl = mxc_isi_video_s_ctrl,\n};\n\nstatic int mxc_isi_video_ctrls_create(struct mxc_isi_video *video)\n{\n\tstruct v4l2_ctrl_handler *handler = &video->ctrls.handler;\n\tint ret;\n\n\tv4l2_ctrl_handler_init(handler, 3);\n\n\tv4l2_ctrl_new_std(handler, &mxc_isi_video_ctrl_ops,\n\t\t\t  V4L2_CID_ALPHA_COMPONENT, 0, 255, 1, 0);\n\n\tv4l2_ctrl_new_std(handler, &mxc_isi_video_ctrl_ops,\n\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std(handler, &mxc_isi_video_ctrl_ops,\n\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\n\tif (handler->error) {\n\t\tret = handler->error;\n\t\tv4l2_ctrl_handler_free(handler);\n\t\treturn ret;\n\t}\n\n\tvideo->vdev.ctrl_handler = handler;\n\n\treturn 0;\n}\n\nstatic void mxc_isi_video_ctrls_delete(struct mxc_isi_video *video)\n{\n\tv4l2_ctrl_handler_free(&video->ctrls.handler);\n}\n\n \n\nstatic int mxc_isi_video_querycap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, MXC_ISI_DRIVER_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, MXC_ISI_CAPTURE, sizeof(cap->card));\n\n\treturn 0;\n}\n\nstatic int mxc_isi_video_enum_fmt(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_fmtdesc *f)\n{\n\tconst struct mxc_isi_format_info *fmt;\n\tunsigned int index = f->index;\n\tunsigned int i;\n\n\tif (f->mbus_code) {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(mxc_isi_formats); i++) {\n\t\t\tfmt = &mxc_isi_formats[i];\n\t\t\tif (fmt->mbus_code != f->mbus_code)\n\t\t\t\tcontinue;\n\n\t\t\tif (index == 0)\n\t\t\t\tbreak;\n\n\t\t\tindex--;\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(mxc_isi_formats))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tif (f->index >= ARRAY_SIZE(mxc_isi_formats))\n\t\t\treturn -EINVAL;\n\n\t\tfmt = &mxc_isi_formats[f->index];\n\t}\n\n\tf->pixelformat = fmt->fourcc;\n\tf->flags |= V4L2_FMT_FLAG_CSC_COLORSPACE | V4L2_FMT_FLAG_CSC_YCBCR_ENC\n\t\t |  V4L2_FMT_FLAG_CSC_QUANTIZATION | V4L2_FMT_FLAG_CSC_XFER_FUNC;\n\n\treturn 0;\n}\n\nstatic int mxc_isi_video_g_fmt(struct file *file, void *fh,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct mxc_isi_video *video = video_drvdata(file);\n\n\tf->fmt.pix_mp = video->pix;\n\n\treturn 0;\n}\n\nstatic int mxc_isi_video_try_fmt(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct mxc_isi_video *video = video_drvdata(file);\n\n\tmxc_isi_format_try(video->pipe, &f->fmt.pix_mp, MXC_ISI_VIDEO_CAP);\n\treturn 0;\n}\n\nstatic int mxc_isi_video_s_fmt(struct file *file, void *priv,\n\t\t\t       struct v4l2_format *f)\n{\n\tstruct mxc_isi_video *video = video_drvdata(file);\n\tstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\n\n\tif (vb2_is_busy(&video->vb2_q))\n\t\treturn -EBUSY;\n\n\tvideo->fmtinfo = mxc_isi_format_try(video->pipe, pix, MXC_ISI_VIDEO_CAP);\n\tvideo->pix = *pix;\n\n\treturn 0;\n}\n\nstatic int mxc_isi_video_streamon(struct file *file, void *priv,\n\t\t\t\t  enum v4l2_buf_type type)\n{\n\tstruct mxc_isi_video *video = video_drvdata(file);\n\tstruct media_device *mdev = &video->pipe->isi->media_dev;\n\tstruct media_pipeline *pipe;\n\tint ret;\n\n\tif (vb2_queue_is_busy(&video->vb2_q, file))\n\t\treturn -EBUSY;\n\n\t \n\tmutex_lock(&mdev->graph_mutex);\n\n\tret = mxc_isi_pipe_acquire(video->pipe, &mxc_isi_video_frame_write_done);\n\tif (ret) {\n\t\tmutex_unlock(&mdev->graph_mutex);\n\t\treturn ret;\n\t}\n\n\tpipe = media_entity_pipeline(&video->vdev.entity) ? : &video->pipe->pipe;\n\n\tret = __video_device_pipeline_start(&video->vdev, pipe);\n\tif (ret) {\n\t\tmutex_unlock(&mdev->graph_mutex);\n\t\tgoto err_release;\n\t}\n\n\tmutex_unlock(&mdev->graph_mutex);\n\n\t \n\tret = mxc_isi_video_validate_format(video);\n\tif (ret)\n\t\tgoto err_stop;\n\n\t \n\tret = mxc_isi_video_alloc_discard_buffers(video);\n\tif (ret)\n\t\tgoto err_stop;\n\n\tret = vb2_streamon(&video->vb2_q, type);\n\tif (ret)\n\t\tgoto err_free;\n\n\tvideo->is_streaming = true;\n\n\treturn 0;\n\nerr_free:\n\tmxc_isi_video_free_discard_buffers(video);\nerr_stop:\n\tvideo_device_pipeline_stop(&video->vdev);\nerr_release:\n\tmxc_isi_pipe_release(video->pipe);\n\treturn ret;\n}\n\nstatic void mxc_isi_video_cleanup_streaming(struct mxc_isi_video *video)\n{\n\tlockdep_assert_held(&video->lock);\n\n\tif (!video->is_streaming)\n\t\treturn;\n\n\tmxc_isi_video_free_discard_buffers(video);\n\tvideo_device_pipeline_stop(&video->vdev);\n\tmxc_isi_pipe_release(video->pipe);\n\n\tvideo->is_streaming = false;\n}\n\nstatic int mxc_isi_video_streamoff(struct file *file, void *priv,\n\t\t\t\t   enum v4l2_buf_type type)\n{\n\tstruct mxc_isi_video *video = video_drvdata(file);\n\tint ret;\n\n\tret = vb2_ioctl_streamoff(file, priv, type);\n\tif (ret)\n\t\treturn ret;\n\n\tmxc_isi_video_cleanup_streaming(video);\n\n\treturn 0;\n}\n\nstatic int mxc_isi_video_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t\t struct v4l2_frmsizeenum *fsize)\n{\n\tstruct mxc_isi_video *video = video_drvdata(file);\n\tconst struct mxc_isi_format_info *info;\n\tunsigned int max_width;\n\tunsigned int h_align;\n\tunsigned int v_align;\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\n\tinfo = mxc_isi_format_by_fourcc(fsize->pixel_format, MXC_ISI_VIDEO_CAP);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\th_align = max_t(unsigned int, info->hsub, 1);\n\tv_align = max_t(unsigned int, info->vsub, 1);\n\n\tmax_width = video->pipe->id == video->pipe->isi->pdata->num_channels - 1\n\t\t  ? MXC_ISI_MAX_WIDTH_UNCHAINED\n\t\t  : MXC_ISI_MAX_WIDTH_CHAINED;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise.min_width = ALIGN(MXC_ISI_MIN_WIDTH, h_align);\n\tfsize->stepwise.min_height = ALIGN(MXC_ISI_MIN_HEIGHT, v_align);\n\tfsize->stepwise.max_width = ALIGN_DOWN(max_width, h_align);\n\tfsize->stepwise.max_height = ALIGN_DOWN(MXC_ISI_MAX_HEIGHT, v_align);\n\tfsize->stepwise.step_width = h_align;\n\tfsize->stepwise.step_height = v_align;\n\n\t \n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops mxc_isi_video_ioctl_ops = {\n\t.vidioc_querycap\t\t= mxc_isi_video_querycap,\n\n\t.vidioc_enum_fmt_vid_cap\t= mxc_isi_video_enum_fmt,\n\t.vidioc_try_fmt_vid_cap_mplane\t= mxc_isi_video_try_fmt,\n\t.vidioc_s_fmt_vid_cap_mplane\t= mxc_isi_video_s_fmt,\n\t.vidioc_g_fmt_vid_cap_mplane\t= mxc_isi_video_g_fmt,\n\n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t\t= vb2_ioctl_expbuf,\n\t.vidioc_prepare_buf\t\t= vb2_ioctl_prepare_buf,\n\t.vidioc_create_bufs\t\t= vb2_ioctl_create_bufs,\n\n\t.vidioc_streamon\t\t= mxc_isi_video_streamon,\n\t.vidioc_streamoff\t\t= mxc_isi_video_streamoff,\n\n\t.vidioc_enum_framesizes\t\t= mxc_isi_video_enum_framesizes,\n\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\n \n\nstatic int mxc_isi_video_open(struct file *file)\n{\n\tstruct mxc_isi_video *video = video_drvdata(file);\n\tint ret;\n\n\tret = v4l2_fh_open(file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(video->pipe->isi->dev);\n\tif (ret) {\n\t\tv4l2_fh_release(file);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxc_isi_video_release(struct file *file)\n{\n\tstruct mxc_isi_video *video = video_drvdata(file);\n\tint ret;\n\n\tret = vb2_fop_release(file);\n\tif (ret)\n\t\tdev_err(video->pipe->isi->dev, \"%s fail\\n\", __func__);\n\n\tmutex_lock(&video->lock);\n\tmxc_isi_video_cleanup_streaming(video);\n\tmutex_unlock(&video->lock);\n\n\tpm_runtime_put(video->pipe->isi->dev);\n\treturn ret;\n}\n\nstatic const struct v4l2_file_operations mxc_isi_video_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= mxc_isi_video_open,\n\t.release\t= mxc_isi_video_release,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= vb2_fop_mmap,\n};\n\n \n\nvoid mxc_isi_video_suspend(struct mxc_isi_pipe *pipe)\n{\n\tstruct mxc_isi_video *video = &pipe->video;\n\n\tif (!video->is_streaming)\n\t\treturn;\n\n\tmxc_isi_pipe_disable(pipe);\n\tmxc_isi_channel_put(pipe);\n\n\tspin_lock_irq(&video->buf_lock);\n\n\t \n\twhile (!list_empty(&video->out_active)) {\n\t\tstruct mxc_isi_buffer *buf =\n\t\t\tlist_last_entry(&video->out_active,\n\t\t\t\t\tstruct mxc_isi_buffer, list);\n\n\t\tif (buf->discard)\n\t\t\tlist_move(&buf->list, &video->out_discard);\n\t\telse\n\t\t\tlist_move(&buf->list, &video->out_pending);\n\t}\n\n\tspin_unlock_irq(&video->buf_lock);\n}\n\nint mxc_isi_video_resume(struct mxc_isi_pipe *pipe)\n{\n\tstruct mxc_isi_video *video = &pipe->video;\n\n\tif (!video->is_streaming)\n\t\treturn 0;\n\n\tmxc_isi_video_init_channel(video);\n\n\tspin_lock_irq(&video->buf_lock);\n\tmxc_isi_video_queue_first_buffers(video);\n\tspin_unlock_irq(&video->buf_lock);\n\n\treturn mxc_isi_pipe_enable(pipe);\n}\n\n \n\nint mxc_isi_video_register(struct mxc_isi_pipe *pipe,\n\t\t\t   struct v4l2_device *v4l2_dev)\n{\n\tstruct mxc_isi_video *video = &pipe->video;\n\tstruct v4l2_pix_format_mplane *pix = &video->pix;\n\tstruct video_device *vdev = &video->vdev;\n\tstruct vb2_queue *q = &video->vb2_q;\n\tint ret = -ENOMEM;\n\n\tvideo->pipe = pipe;\n\n\tmutex_init(&video->lock);\n\tspin_lock_init(&video->buf_lock);\n\n\tpix->width = MXC_ISI_DEF_WIDTH;\n\tpix->height = MXC_ISI_DEF_HEIGHT;\n\tpix->pixelformat = MXC_ISI_DEF_PIXEL_FORMAT;\n\tpix->colorspace = MXC_ISI_DEF_COLOR_SPACE;\n\tpix->ycbcr_enc = MXC_ISI_DEF_YCBCR_ENC;\n\tpix->quantization = MXC_ISI_DEF_QUANTIZATION;\n\tpix->xfer_func = MXC_ISI_DEF_XFER_FUNC;\n\tvideo->fmtinfo = mxc_isi_format_try(video->pipe, pix, MXC_ISI_VIDEO_CAP);\n\n\tmemset(vdev, 0, sizeof(*vdev));\n\tsnprintf(vdev->name, sizeof(vdev->name), \"mxc_isi.%d.capture\", pipe->id);\n\n\tvdev->fops\t= &mxc_isi_video_fops;\n\tvdev->ioctl_ops\t= &mxc_isi_video_ioctl_ops;\n\tvdev->v4l2_dev\t= v4l2_dev;\n\tvdev->minor\t= -1;\n\tvdev->release\t= video_device_release_empty;\n\tvdev->queue\t= q;\n\tvdev->lock\t= &video->lock;\n\n\tvdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE_MPLANE\n\t\t\t  | V4L2_CAP_IO_MC;\n\tvideo_set_drvdata(vdev, video);\n\n\tINIT_LIST_HEAD(&video->out_pending);\n\tINIT_LIST_HEAD(&video->out_active);\n\tINIT_LIST_HEAD(&video->out_discard);\n\n\tmemset(q, 0, sizeof(*q));\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tq->drv_priv = video;\n\tq->ops = &mxc_isi_vb2_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->buf_struct_size = sizeof(struct mxc_isi_buffer);\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->min_buffers_needed = 2;\n\tq->lock = &video->lock;\n\tq->dev = pipe->isi->dev;\n\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\tgoto err_free_ctx;\n\n\tvideo->pad.flags = MEDIA_PAD_FL_SINK;\n\tvdev->entity.function = MEDIA_ENT_F_PROC_VIDEO_SCALER;\n\tret = media_entity_pads_init(&vdev->entity, 1, &video->pad);\n\tif (ret)\n\t\tgoto err_free_ctx;\n\n\tret = mxc_isi_video_ctrls_create(video);\n\tif (ret)\n\t\tgoto err_me_cleanup;\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret)\n\t\tgoto err_ctrl_free;\n\n\tret = media_create_pad_link(&pipe->sd.entity,\n\t\t\t\t    MXC_ISI_PIPE_PAD_SOURCE,\n\t\t\t\t    &vdev->entity, 0,\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\tif (ret)\n\t\tgoto err_video_unreg;\n\n\treturn 0;\n\nerr_video_unreg:\n\tvideo_unregister_device(vdev);\nerr_ctrl_free:\n\tmxc_isi_video_ctrls_delete(video);\nerr_me_cleanup:\n\tmedia_entity_cleanup(&vdev->entity);\nerr_free_ctx:\n\treturn ret;\n}\n\nvoid mxc_isi_video_unregister(struct mxc_isi_pipe *pipe)\n{\n\tstruct mxc_isi_video *video = &pipe->video;\n\tstruct video_device *vdev = &video->vdev;\n\n\tmutex_lock(&video->lock);\n\n\tif (video_is_registered(vdev)) {\n\t\tvideo_unregister_device(vdev);\n\t\tmxc_isi_video_ctrls_delete(video);\n\t\tmedia_entity_cleanup(&vdev->entity);\n\t}\n\n\tmutex_unlock(&video->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}