{
  "module_name": "imx8-isi-crossbar.c",
  "hash_id": "ff31269f7f0fc8cb360de06cec9023fdbd86171c699b20e8213613482ac68e2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/imx8-isi/imx8-isi-crossbar.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/minmax.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include <media/media-entity.h>\n#include <media/v4l2-subdev.h>\n\n#include \"imx8-isi-core.h\"\n\nstatic inline struct mxc_isi_crossbar *to_isi_crossbar(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct mxc_isi_crossbar, sd);\n}\n\nstatic int mxc_isi_crossbar_gasket_enable(struct mxc_isi_crossbar *xbar,\n\t\t\t\t\t  struct v4l2_subdev_state *state,\n\t\t\t\t\t  struct v4l2_subdev *remote_sd,\n\t\t\t\t\t  u32 remote_pad, unsigned int port)\n{\n\tstruct mxc_isi_dev *isi = xbar->isi;\n\tconst struct mxc_gasket_ops *gasket_ops = isi->pdata->gasket_ops;\n\tconst struct v4l2_mbus_framefmt *fmt;\n\tstruct v4l2_mbus_frame_desc fd;\n\tint ret;\n\n\tif (!gasket_ops)\n\t\treturn 0;\n\n\t \n\n\tret = v4l2_subdev_call(remote_sd, pad, get_frame_desc, remote_pad, &fd);\n\tif (ret) {\n\t\tdev_err(isi->dev,\n\t\t\t\"failed to get frame descriptor from '%s':%u: %d\\n\",\n\t\t\tremote_sd->name, remote_pad, ret);\n\t\treturn ret;\n\t}\n\n\tif (fd.num_entries != 1) {\n\t\tdev_err(isi->dev, \"invalid frame descriptor for '%s':%u\\n\",\n\t\t\tremote_sd->name, remote_pad);\n\t\treturn -EINVAL;\n\t}\n\n\tfmt = v4l2_subdev_state_get_stream_format(state, port, 0);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\tgasket_ops->enable(isi, &fd, fmt, port);\n\treturn 0;\n}\n\nstatic void mxc_isi_crossbar_gasket_disable(struct mxc_isi_crossbar *xbar,\n\t\t\t\t\t    unsigned int port)\n{\n\tstruct mxc_isi_dev *isi = xbar->isi;\n\tconst struct mxc_gasket_ops *gasket_ops = isi->pdata->gasket_ops;\n\n\tif (!gasket_ops)\n\t\treturn;\n\n\tgasket_ops->disable(isi, port);\n}\n\n \n\nstatic const struct v4l2_mbus_framefmt mxc_isi_crossbar_default_format = {\n\t.code = MXC_ISI_DEF_MBUS_CODE_SINK,\n\t.width = MXC_ISI_DEF_WIDTH,\n\t.height = MXC_ISI_DEF_HEIGHT,\n\t.field = V4L2_FIELD_NONE,\n\t.colorspace = MXC_ISI_DEF_COLOR_SPACE,\n\t.ycbcr_enc = MXC_ISI_DEF_YCBCR_ENC,\n\t.quantization = MXC_ISI_DEF_QUANTIZATION,\n\t.xfer_func = MXC_ISI_DEF_XFER_FUNC,\n};\n\nstatic int __mxc_isi_crossbar_set_routing(struct v4l2_subdev *sd,\n\t\t\t\t\t  struct v4l2_subdev_state *state,\n\t\t\t\t\t  struct v4l2_subdev_krouting *routing)\n{\n\tstruct mxc_isi_crossbar *xbar = to_isi_crossbar(sd);\n\tstruct v4l2_subdev_route *route;\n\tint ret;\n\n\tret = v4l2_subdev_routing_validate(sd, routing,\n\t\t\t\t\t   V4L2_SUBDEV_ROUTING_NO_N_TO_1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor_each_active_route(&state->routing, route) {\n\t\tif (route->sink_pad == xbar->num_sinks - 1 &&\n\t\t    route->source_pad != xbar->num_sinks) {\n\t\t\tdev_dbg(xbar->isi->dev,\n\t\t\t\t\"invalid route from memory input (%u) to pipe %u\\n\",\n\t\t\t\troute->sink_pad,\n\t\t\t\troute->source_pad - xbar->num_sinks);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn v4l2_subdev_set_routing_with_fmt(sd, state, routing,\n\t\t\t\t\t\t&mxc_isi_crossbar_default_format);\n}\n\nstatic struct v4l2_subdev *\nmxc_isi_crossbar_xlate_streams(struct mxc_isi_crossbar *xbar,\n\t\t\t       struct v4l2_subdev_state *state,\n\t\t\t       u32 source_pad, u64 source_streams,\n\t\t\t       u32 *__sink_pad, u64 *__sink_streams,\n\t\t\t       u32 *remote_pad)\n{\n\tstruct v4l2_subdev_route *route;\n\tstruct v4l2_subdev *sd;\n\tstruct media_pad *pad;\n\tu64 sink_streams = 0;\n\tint sink_pad = -1;\n\n\t \n\tfor_each_active_route(&state->routing, route) {\n\t\tif (route->source_pad != source_pad ||\n\t\t    !(source_streams & BIT(route->source_stream)))\n\t\t\tcontinue;\n\n\t\tsink_streams |= BIT(route->sink_stream);\n\t\tsink_pad = route->sink_pad;\n\t}\n\n\tif (sink_pad < 0) {\n\t\tdev_dbg(xbar->isi->dev,\n\t\t\t\"no stream connected to pipeline %u\\n\",\n\t\t\tsource_pad - xbar->num_sinks);\n\t\treturn ERR_PTR(-EPIPE);\n\t}\n\n\tpad = media_pad_remote_pad_first(&xbar->pads[sink_pad]);\n\tsd = media_entity_to_v4l2_subdev(pad->entity);\n\n\tif (!sd) {\n\t\tdev_dbg(xbar->isi->dev,\n\t\t\t\"no entity connected to crossbar input %u\\n\",\n\t\t\tsink_pad);\n\t\treturn ERR_PTR(-EPIPE);\n\t}\n\n\t*__sink_pad = sink_pad;\n\t*__sink_streams = sink_streams;\n\t*remote_pad = pad->index;\n\n\treturn sd;\n}\n\nstatic int mxc_isi_crossbar_init_cfg(struct v4l2_subdev *sd,\n\t\t\t\t     struct v4l2_subdev_state *state)\n{\n\tstruct mxc_isi_crossbar *xbar = to_isi_crossbar(sd);\n\tstruct v4l2_subdev_krouting routing = { };\n\tstruct v4l2_subdev_route *routes;\n\tunsigned int i;\n\tint ret;\n\n\t \n\troutes = kcalloc(xbar->num_sources, sizeof(*routes), GFP_KERNEL);\n\tif (!routes)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < xbar->num_sources; ++i) {\n\t\tstruct v4l2_subdev_route *route = &routes[i];\n\n\t\troute->sink_pad = i;\n\t\troute->source_pad = i + xbar->num_sinks;\n\t\troute->flags = V4L2_SUBDEV_ROUTE_FL_ACTIVE;\n\t}\n\n\trouting.num_routes = xbar->num_sources;\n\trouting.routes = routes;\n\n\tret = __mxc_isi_crossbar_set_routing(sd, state, &routing);\n\n\tkfree(routes);\n\n\treturn ret;\n}\n\nstatic int mxc_isi_crossbar_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t\t   struct v4l2_subdev_state *state,\n\t\t\t\t\t   struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstruct mxc_isi_crossbar *xbar = to_isi_crossbar(sd);\n\tconst struct mxc_isi_bus_format_info *info;\n\n\tif (code->pad >= xbar->num_sinks) {\n\t\tconst struct v4l2_mbus_framefmt *format;\n\n\t\t \n\t\tif (code->index > 0)\n\t\t\treturn -EINVAL;\n\n\t\tformat = v4l2_subdev_state_get_opposite_stream_format(state,\n\t\t\t\t\t\t\t\t      code->pad,\n\t\t\t\t\t\t\t\t      code->stream);\n\t\tif (!format)\n\t\t\treturn -EINVAL;\n\n\t\tcode->code = format->code;\n\n\t\treturn 0;\n\t}\n\n\tinfo = mxc_isi_bus_format_by_index(code->index, MXC_ISI_PIPE_PAD_SINK);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tcode->code = info->mbus_code;\n\n\treturn 0;\n}\n\nstatic int mxc_isi_crossbar_set_fmt(struct v4l2_subdev *sd,\n\t\t\t\t    struct v4l2_subdev_state *state,\n\t\t\t\t    struct v4l2_subdev_format *fmt)\n{\n\tstruct mxc_isi_crossbar *xbar = to_isi_crossbar(sd);\n\tstruct v4l2_mbus_framefmt *sink_fmt;\n\tstruct v4l2_subdev_route *route;\n\n\tif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE &&\n\t    media_pad_is_streaming(&xbar->pads[fmt->pad]))\n\t\treturn -EBUSY;\n\n\t \n\tif (fmt->pad >= xbar->num_sinks)\n\t\treturn v4l2_subdev_get_fmt(sd, state, fmt);\n\n\t \n\tif (!mxc_isi_bus_format_by_code(fmt->format.code, MXC_ISI_PIPE_PAD_SINK))\n\t\tfmt->format.code = MXC_ISI_DEF_MBUS_CODE_SINK;\n\n\tfmt->format.width = clamp_t(unsigned int, fmt->format.width,\n\t\t\t\t    MXC_ISI_MIN_WIDTH, MXC_ISI_MAX_WIDTH_CHAINED);\n\tfmt->format.height = clamp_t(unsigned int, fmt->format.height,\n\t\t\t\t     MXC_ISI_MIN_HEIGHT, MXC_ISI_MAX_HEIGHT);\n\tfmt->format.field = V4L2_FIELD_NONE;\n\n\t \n\tsink_fmt = v4l2_subdev_state_get_stream_format(state, fmt->pad,\n\t\t\t\t\t\t       fmt->stream);\n\tif (!sink_fmt)\n\t\treturn -EINVAL;\n\n\t*sink_fmt = fmt->format;\n\n\t \n\tfor_each_active_route(&state->routing, route) {\n\t\tstruct v4l2_mbus_framefmt *source_fmt;\n\n\t\tif (route->sink_pad != fmt->pad ||\n\t\t    route->sink_stream != fmt->stream)\n\t\t\tcontinue;\n\n\t\tsource_fmt = v4l2_subdev_state_get_stream_format(state, route->source_pad,\n\t\t\t\t\t\t\t\t route->source_stream);\n\t\tif (!source_fmt)\n\t\t\treturn -EINVAL;\n\n\t\t*source_fmt = fmt->format;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxc_isi_crossbar_set_routing(struct v4l2_subdev *sd,\n\t\t\t\t\tstruct v4l2_subdev_state *state,\n\t\t\t\t\tenum v4l2_subdev_format_whence which,\n\t\t\t\t\tstruct v4l2_subdev_krouting *routing)\n{\n\tif (which == V4L2_SUBDEV_FORMAT_ACTIVE &&\n\t    media_entity_is_streaming(&sd->entity))\n\t\treturn -EBUSY;\n\n\treturn __mxc_isi_crossbar_set_routing(sd, state, routing);\n}\n\nstatic int mxc_isi_crossbar_enable_streams(struct v4l2_subdev *sd,\n\t\t\t\t\t   struct v4l2_subdev_state *state,\n\t\t\t\t\t   u32 pad, u64 streams_mask)\n{\n\tstruct mxc_isi_crossbar *xbar = to_isi_crossbar(sd);\n\tstruct v4l2_subdev *remote_sd;\n\tstruct mxc_isi_input *input;\n\tu64 sink_streams;\n\tu32 sink_pad;\n\tu32 remote_pad;\n\tint ret;\n\n\tremote_sd = mxc_isi_crossbar_xlate_streams(xbar, state, pad, streams_mask,\n\t\t\t\t\t\t   &sink_pad, &sink_streams,\n\t\t\t\t\t\t   &remote_pad);\n\tif (IS_ERR(remote_sd))\n\t\treturn PTR_ERR(remote_sd);\n\n\tinput = &xbar->inputs[sink_pad];\n\n\t \n\tif (!input->enable_count) {\n\t\tret = mxc_isi_crossbar_gasket_enable(xbar, state, remote_sd,\n\t\t\t\t\t\t     remote_pad, sink_pad);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = v4l2_subdev_enable_streams(remote_sd, remote_pad,\n\t\t\t\t\t\t sink_streams);\n\t\tif (ret) {\n\t\t\tdev_err(xbar->isi->dev,\n\t\t\t\t\"failed to %s streams 0x%llx on '%s':%u: %d\\n\",\n\t\t\t\t\"enable\", sink_streams, remote_sd->name,\n\t\t\t\tremote_pad, ret);\n\t\t\tmxc_isi_crossbar_gasket_disable(xbar, sink_pad);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tinput->enable_count++;\n\n\treturn 0;\n}\n\nstatic int mxc_isi_crossbar_disable_streams(struct v4l2_subdev *sd,\n\t\t\t\t\t    struct v4l2_subdev_state *state,\n\t\t\t\t\t    u32 pad, u64 streams_mask)\n{\n\tstruct mxc_isi_crossbar *xbar = to_isi_crossbar(sd);\n\tstruct v4l2_subdev *remote_sd;\n\tstruct mxc_isi_input *input;\n\tu64 sink_streams;\n\tu32 sink_pad;\n\tu32 remote_pad;\n\tint ret = 0;\n\n\tremote_sd = mxc_isi_crossbar_xlate_streams(xbar, state, pad, streams_mask,\n\t\t\t\t\t\t   &sink_pad, &sink_streams,\n\t\t\t\t\t\t   &remote_pad);\n\tif (IS_ERR(remote_sd))\n\t\treturn PTR_ERR(remote_sd);\n\n\tinput = &xbar->inputs[sink_pad];\n\n\tinput->enable_count--;\n\n\tif (!input->enable_count) {\n\t\tret = v4l2_subdev_disable_streams(remote_sd, remote_pad,\n\t\t\t\t\t\t  sink_streams);\n\t\tif (ret)\n\t\t\tdev_err(xbar->isi->dev,\n\t\t\t\t\"failed to %s streams 0x%llx on '%s':%u: %d\\n\",\n\t\t\t\t\"disable\", sink_streams, remote_sd->name,\n\t\t\t\tremote_pad, ret);\n\n\t\tmxc_isi_crossbar_gasket_disable(xbar, sink_pad);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_subdev_pad_ops mxc_isi_crossbar_subdev_pad_ops = {\n\t.init_cfg = mxc_isi_crossbar_init_cfg,\n\t.enum_mbus_code = mxc_isi_crossbar_enum_mbus_code,\n\t.get_fmt = v4l2_subdev_get_fmt,\n\t.set_fmt = mxc_isi_crossbar_set_fmt,\n\t.set_routing = mxc_isi_crossbar_set_routing,\n\t.enable_streams = mxc_isi_crossbar_enable_streams,\n\t.disable_streams = mxc_isi_crossbar_disable_streams,\n};\n\nstatic const struct v4l2_subdev_ops mxc_isi_crossbar_subdev_ops = {\n\t.pad = &mxc_isi_crossbar_subdev_pad_ops,\n};\n\nstatic const struct media_entity_operations mxc_isi_cross_entity_ops = {\n\t.get_fwnode_pad = v4l2_subdev_get_fwnode_pad_1_to_1,\n\t.link_validate\t= v4l2_subdev_link_validate,\n\t.has_pad_interdep = v4l2_subdev_has_pad_interdep,\n};\n\n \n\nint mxc_isi_crossbar_init(struct mxc_isi_dev *isi)\n{\n\tstruct mxc_isi_crossbar *xbar = &isi->crossbar;\n\tstruct v4l2_subdev *sd = &xbar->sd;\n\tunsigned int num_pads;\n\tunsigned int i;\n\tint ret;\n\n\txbar->isi = isi;\n\n\tv4l2_subdev_init(sd, &mxc_isi_crossbar_subdev_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_STREAMS;\n\tstrscpy(sd->name, \"crossbar\", sizeof(sd->name));\n\tsd->dev = isi->dev;\n\n\tsd->entity.function = MEDIA_ENT_F_VID_MUX;\n\tsd->entity.ops = &mxc_isi_cross_entity_ops;\n\n\t \n\txbar->num_sinks = isi->pdata->num_ports + 1;\n\txbar->num_sources = isi->pdata->num_ports;\n\tnum_pads = xbar->num_sinks + xbar->num_sources;\n\n\txbar->pads = kcalloc(num_pads, sizeof(*xbar->pads), GFP_KERNEL);\n\tif (!xbar->pads)\n\t\treturn -ENOMEM;\n\n\txbar->inputs = kcalloc(xbar->num_sinks, sizeof(*xbar->inputs),\n\t\t\t       GFP_KERNEL);\n\tif (!xbar->inputs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tfor (i = 0; i < xbar->num_sinks; ++i)\n\t\txbar->pads[i].flags = MEDIA_PAD_FL_SINK;\n\tfor (i = 0; i < xbar->num_sources; ++i)\n\t\txbar->pads[i + xbar->num_sinks].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&sd->entity, num_pads, xbar->pads);\n\tif (ret)\n\t\tgoto err_free;\n\n\tret = v4l2_subdev_init_finalize(sd);\n\tif (ret < 0)\n\t\tgoto err_entity;\n\n\treturn 0;\n\nerr_entity:\n\tmedia_entity_cleanup(&sd->entity);\nerr_free:\n\tkfree(xbar->pads);\n\tkfree(xbar->inputs);\n\n\treturn ret;\n}\n\nvoid mxc_isi_crossbar_cleanup(struct mxc_isi_crossbar *xbar)\n{\n\tmedia_entity_cleanup(&xbar->sd.entity);\n\tkfree(xbar->pads);\n\tkfree(xbar->inputs);\n}\n\nint mxc_isi_crossbar_register(struct mxc_isi_crossbar *xbar)\n{\n\treturn v4l2_device_register_subdev(&xbar->isi->v4l2_dev, &xbar->sd);\n}\n\nvoid mxc_isi_crossbar_unregister(struct mxc_isi_crossbar *xbar)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}