{
  "module_name": "imx8-isi-pipe.c",
  "hash_id": "670918dc8e44f821ec3fe0f69e16accaec1e279d286d9d4ddb97f130e99f9909",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/imx8-isi/imx8-isi-pipe.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/minmax.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/videodev2.h>\n\n#include <media/media-entity.h>\n#include <media/v4l2-subdev.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"imx8-isi-core.h\"\n#include \"imx8-isi-regs.h\"\n\n \nstatic const struct mxc_isi_bus_format_info mxc_isi_bus_formats[] = {\n\t \n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_UYVY8_1X16,\n\t\t.output\t\t= MEDIA_BUS_FMT_YUV8_1X24,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK),\n\t\t.encoding\t= MXC_ISI_ENC_YUV,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_YUV8_1X24,\n\t\t.output\t\t= MEDIA_BUS_FMT_YUV8_1X24,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_YUV,\n\t},\n\t \n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB565_1X16,\n\t\t.output\t\t= MEDIA_BUS_FMT_RGB888_1X24,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK),\n\t\t.encoding\t= MXC_ISI_ENC_RGB,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_RGB888_1X24,\n\t\t.output\t\t= MEDIA_BUS_FMT_RGB888_1X24,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RGB,\n\t},\n\t \n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_Y8_1X8,\n\t\t.output\t\t= MEDIA_BUS_FMT_Y8_1X8,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_Y10_1X10,\n\t\t.output\t\t= MEDIA_BUS_FMT_Y10_1X10,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_Y12_1X12,\n\t\t.output\t\t= MEDIA_BUS_FMT_Y12_1X12,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_Y14_1X14,\n\t\t.output\t\t= MEDIA_BUS_FMT_Y14_1X14,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.output\t\t= MEDIA_BUS_FMT_SBGGR8_1X8,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.output\t\t= MEDIA_BUS_FMT_SGBRG8_1X8,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.output\t\t= MEDIA_BUS_FMT_SGRBG8_1X8,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.output\t\t= MEDIA_BUS_FMT_SRGGB8_1X8,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.output\t\t= MEDIA_BUS_FMT_SBGGR10_1X10,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.output\t\t= MEDIA_BUS_FMT_SGBRG10_1X10,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.output\t\t= MEDIA_BUS_FMT_SGRBG10_1X10,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.output\t\t= MEDIA_BUS_FMT_SRGGB10_1X10,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.output\t\t= MEDIA_BUS_FMT_SBGGR12_1X12,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.output\t\t= MEDIA_BUS_FMT_SGBRG12_1X12,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.output\t\t= MEDIA_BUS_FMT_SGRBG12_1X12,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.output\t\t= MEDIA_BUS_FMT_SRGGB12_1X12,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SBGGR14_1X14,\n\t\t.output\t\t= MEDIA_BUS_FMT_SBGGR14_1X14,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGBRG14_1X14,\n\t\t.output\t\t= MEDIA_BUS_FMT_SGBRG14_1X14,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SGRBG14_1X14,\n\t\t.output\t\t= MEDIA_BUS_FMT_SGRBG14_1X14,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}, {\n\t\t.mbus_code\t= MEDIA_BUS_FMT_SRGGB14_1X14,\n\t\t.output\t\t= MEDIA_BUS_FMT_SRGGB14_1X14,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t},\n\t \n\t{\n\t\t.mbus_code\t= MEDIA_BUS_FMT_JPEG_1X8,\n\t\t.output\t\t= MEDIA_BUS_FMT_JPEG_1X8,\n\t\t.pads\t\t= BIT(MXC_ISI_PIPE_PAD_SINK)\n\t\t\t\t| BIT(MXC_ISI_PIPE_PAD_SOURCE),\n\t\t.encoding\t= MXC_ISI_ENC_RAW,\n\t}\n};\n\nconst struct mxc_isi_bus_format_info *\nmxc_isi_bus_format_by_code(u32 code, unsigned int pad)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mxc_isi_bus_formats); i++) {\n\t\tconst struct mxc_isi_bus_format_info *info =\n\t\t\t&mxc_isi_bus_formats[i];\n\n\t\tif (info->mbus_code == code && info->pads & BIT(pad))\n\t\t\treturn info;\n\t}\n\n\treturn NULL;\n}\n\nconst struct mxc_isi_bus_format_info *\nmxc_isi_bus_format_by_index(unsigned int index, unsigned int pad)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mxc_isi_bus_formats); i++) {\n\t\tconst struct mxc_isi_bus_format_info *info =\n\t\t\t&mxc_isi_bus_formats[i];\n\n\t\tif (!(info->pads & BIT(pad)))\n\t\t\tcontinue;\n\n\t\tif (!index)\n\t\t\treturn info;\n\n\t\tindex--;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline struct mxc_isi_pipe *to_isi_pipe(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct mxc_isi_pipe, sd);\n}\n\nint mxc_isi_pipe_enable(struct mxc_isi_pipe *pipe)\n{\n\tstruct mxc_isi_crossbar *xbar = &pipe->isi->crossbar;\n\tconst struct mxc_isi_bus_format_info *sink_info;\n\tconst struct mxc_isi_bus_format_info *src_info;\n\tconst struct v4l2_mbus_framefmt *sink_fmt;\n\tconst struct v4l2_mbus_framefmt *src_fmt;\n\tconst struct v4l2_rect *compose;\n\tstruct v4l2_subdev_state *state;\n\tstruct v4l2_subdev *sd = &pipe->sd;\n\tstruct v4l2_area in_size, scale;\n\tstruct v4l2_rect crop;\n\tu32 input;\n\tint ret;\n\n\t \n\tstate = v4l2_subdev_lock_and_get_active_state(&xbar->sd);\n\tret = v4l2_subdev_routing_find_opposite_end(&state->routing,\n\t\t\t\t\t\t    xbar->num_sinks + pipe->id,\n\t\t\t\t\t\t    0, &input, NULL);\n\tv4l2_subdev_unlock_state(state);\n\n\tif (ret)\n\t\treturn -EPIPE;\n\n\t \n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\n\tsink_fmt = v4l2_subdev_get_try_format(sd, state, MXC_ISI_PIPE_PAD_SINK);\n\tsrc_fmt = v4l2_subdev_get_try_format(sd, state, MXC_ISI_PIPE_PAD_SOURCE);\n\tcompose = v4l2_subdev_get_try_compose(sd, state, MXC_ISI_PIPE_PAD_SINK);\n\tcrop = *v4l2_subdev_get_try_crop(sd, state, MXC_ISI_PIPE_PAD_SOURCE);\n\n\tsink_info = mxc_isi_bus_format_by_code(sink_fmt->code,\n\t\t\t\t\t       MXC_ISI_PIPE_PAD_SINK);\n\tsrc_info = mxc_isi_bus_format_by_code(src_fmt->code,\n\t\t\t\t\t      MXC_ISI_PIPE_PAD_SOURCE);\n\n\tin_size.width = sink_fmt->width;\n\tin_size.height = sink_fmt->height;\n\tscale.width = compose->width;\n\tscale.height = compose->height;\n\n\tv4l2_subdev_unlock_state(state);\n\n\t \n\tmxc_isi_channel_config(pipe, input, &in_size, &scale, &crop,\n\t\t\t       sink_info->encoding, src_info->encoding);\n\n\tmxc_isi_channel_enable(pipe);\n\n\t \n\tret = v4l2_subdev_enable_streams(&xbar->sd, xbar->num_sinks + pipe->id,\n\t\t\t\t\t BIT(0));\n\tif (ret) {\n\t\tmxc_isi_channel_disable(pipe);\n\t\tdev_err(pipe->isi->dev, \"Failed to enable pipe %u\\n\",\n\t\t\tpipe->id);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid mxc_isi_pipe_disable(struct mxc_isi_pipe *pipe)\n{\n\tstruct mxc_isi_crossbar *xbar = &pipe->isi->crossbar;\n\tint ret;\n\n\tret = v4l2_subdev_disable_streams(&xbar->sd, xbar->num_sinks + pipe->id,\n\t\t\t\t\t  BIT(0));\n\tif (ret)\n\t\tdev_err(pipe->isi->dev, \"Failed to disable pipe %u\\n\",\n\t\t\tpipe->id);\n\n\tmxc_isi_channel_disable(pipe);\n}\n\n \n\nstatic struct v4l2_mbus_framefmt *\nmxc_isi_pipe_get_pad_format(struct mxc_isi_pipe *pipe,\n\t\t\t    struct v4l2_subdev_state *state,\n\t\t\t    unsigned int pad)\n{\n\treturn v4l2_subdev_get_try_format(&pipe->sd, state, pad);\n}\n\nstatic struct v4l2_rect *\nmxc_isi_pipe_get_pad_crop(struct mxc_isi_pipe *pipe,\n\t\t\t  struct v4l2_subdev_state *state,\n\t\t\t  unsigned int pad)\n{\n\treturn v4l2_subdev_get_try_crop(&pipe->sd, state, pad);\n}\n\nstatic struct v4l2_rect *\nmxc_isi_pipe_get_pad_compose(struct mxc_isi_pipe *pipe,\n\t\t\t     struct v4l2_subdev_state *state,\n\t\t\t     unsigned int pad)\n{\n\treturn v4l2_subdev_get_try_compose(&pipe->sd, state, pad);\n}\n\nstatic int mxc_isi_pipe_init_cfg(struct v4l2_subdev *sd,\n\t\t\t\t struct v4l2_subdev_state *state)\n{\n\tstruct mxc_isi_pipe *pipe = to_isi_pipe(sd);\n\tstruct v4l2_mbus_framefmt *fmt_source;\n\tstruct v4l2_mbus_framefmt *fmt_sink;\n\tstruct v4l2_rect *compose;\n\tstruct v4l2_rect *crop;\n\n\tfmt_sink = mxc_isi_pipe_get_pad_format(pipe, state,\n\t\t\t\t\t       MXC_ISI_PIPE_PAD_SINK);\n\tfmt_source = mxc_isi_pipe_get_pad_format(pipe, state,\n\t\t\t\t\t\t MXC_ISI_PIPE_PAD_SOURCE);\n\n\tfmt_sink->width = MXC_ISI_DEF_WIDTH;\n\tfmt_sink->height = MXC_ISI_DEF_HEIGHT;\n\tfmt_sink->code = MXC_ISI_DEF_MBUS_CODE_SINK;\n\tfmt_sink->field = V4L2_FIELD_NONE;\n\tfmt_sink->colorspace = V4L2_COLORSPACE_JPEG;\n\tfmt_sink->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt_sink->colorspace);\n\tfmt_sink->quantization =\n\t\tV4L2_MAP_QUANTIZATION_DEFAULT(false, fmt_sink->colorspace,\n\t\t\t\t\t      fmt_sink->ycbcr_enc);\n\tfmt_sink->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt_sink->colorspace);\n\n\t*fmt_source = *fmt_sink;\n\tfmt_source->code = MXC_ISI_DEF_MBUS_CODE_SOURCE;\n\n\tcompose = mxc_isi_pipe_get_pad_compose(pipe, state,\n\t\t\t\t\t       MXC_ISI_PIPE_PAD_SINK);\n\tcrop = mxc_isi_pipe_get_pad_crop(pipe, state, MXC_ISI_PIPE_PAD_SOURCE);\n\n\tcompose->left = 0;\n\tcompose->top = 0;\n\tcompose->width = MXC_ISI_DEF_WIDTH;\n\tcompose->height = MXC_ISI_DEF_HEIGHT;\n\n\t*crop = *compose;\n\n\treturn 0;\n}\n\nstatic int mxc_isi_pipe_enum_mbus_code(struct v4l2_subdev *sd,\n\t\t\t\t       struct v4l2_subdev_state *state,\n\t\t\t\t       struct v4l2_subdev_mbus_code_enum *code)\n{\n\tstatic const u32 output_codes[] = {\n\t\tMEDIA_BUS_FMT_YUV8_1X24,\n\t\tMEDIA_BUS_FMT_RGB888_1X24,\n\t};\n\tstruct mxc_isi_pipe *pipe = to_isi_pipe(sd);\n\tconst struct mxc_isi_bus_format_info *info;\n\tunsigned int index;\n\tunsigned int i;\n\n\tif (code->pad == MXC_ISI_PIPE_PAD_SOURCE) {\n\t\tconst struct v4l2_mbus_framefmt *format;\n\n\t\tformat = mxc_isi_pipe_get_pad_format(pipe, state,\n\t\t\t\t\t\t     MXC_ISI_PIPE_PAD_SINK);\n\t\tinfo = mxc_isi_bus_format_by_code(format->code,\n\t\t\t\t\t\t  MXC_ISI_PIPE_PAD_SINK);\n\n\t\tif (info->encoding == MXC_ISI_ENC_RAW) {\n\t\t\t \n\t\t\tif (code->index)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcode->code = info->output;\n\t\t} else {\n\t\t\t \n\t\t\tif (code->index > 1)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcode->code = output_codes[code->index];\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tindex = code->index;\n\n\tfor (i = 0; i < ARRAY_SIZE(mxc_isi_bus_formats); ++i) {\n\t\tinfo = &mxc_isi_bus_formats[i];\n\n\t\tif (!(info->pads & BIT(MXC_ISI_PIPE_PAD_SINK)))\n\t\t\tcontinue;\n\n\t\tif (index == 0) {\n\t\t\tcode->code = info->mbus_code;\n\t\t\treturn 0;\n\t\t}\n\n\t\tindex--;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mxc_isi_pipe_set_fmt(struct v4l2_subdev *sd,\n\t\t\t\tstruct v4l2_subdev_state *state,\n\t\t\t\tstruct v4l2_subdev_format *fmt)\n{\n\tstruct mxc_isi_pipe *pipe = to_isi_pipe(sd);\n\tstruct v4l2_mbus_framefmt *mf = &fmt->format;\n\tconst struct mxc_isi_bus_format_info *info;\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *rect;\n\n\tif (vb2_is_busy(&pipe->video.vb2_q))\n\t\treturn -EBUSY;\n\n\tif (fmt->pad == MXC_ISI_PIPE_PAD_SINK) {\n\t\tunsigned int max_width;\n\n\t\tinfo = mxc_isi_bus_format_by_code(mf->code,\n\t\t\t\t\t\t  MXC_ISI_PIPE_PAD_SINK);\n\t\tif (!info)\n\t\t\tinfo = mxc_isi_bus_format_by_code(MXC_ISI_DEF_MBUS_CODE_SINK,\n\t\t\t\t\t\t\t  MXC_ISI_PIPE_PAD_SINK);\n\n\t\t \n\t\tmax_width = pipe->id == pipe->isi->pdata->num_channels - 1\n\t\t\t  ? MXC_ISI_MAX_WIDTH_UNCHAINED\n\t\t\t  : MXC_ISI_MAX_WIDTH_CHAINED;\n\n\t\tmf->code = info->mbus_code;\n\t\tmf->width = clamp(mf->width, MXC_ISI_MIN_WIDTH, max_width);\n\t\tmf->height = clamp(mf->height, MXC_ISI_MIN_HEIGHT,\n\t\t\t\t   MXC_ISI_MAX_HEIGHT);\n\n\t\t \n\t\trect = mxc_isi_pipe_get_pad_compose(pipe, state,\n\t\t\t\t\t\t    MXC_ISI_PIPE_PAD_SINK);\n\t\trect->width = mf->width;\n\t\trect->height = mf->height;\n\n\t\trect = mxc_isi_pipe_get_pad_crop(pipe, state,\n\t\t\t\t\t\t MXC_ISI_PIPE_PAD_SOURCE);\n\t\trect->left = 0;\n\t\trect->top = 0;\n\t\trect->width = mf->width;\n\t\trect->height = mf->height;\n\n\t\tformat = mxc_isi_pipe_get_pad_format(pipe, state,\n\t\t\t\t\t\t     MXC_ISI_PIPE_PAD_SOURCE);\n\t\tformat->code = info->output;\n\t\tformat->width = mf->width;\n\t\tformat->height = mf->height;\n\t} else {\n\t\t \n\t\tformat = mxc_isi_pipe_get_pad_format(pipe, state,\n\t\t\t\t\t\t     MXC_ISI_PIPE_PAD_SINK);\n\t\tinfo = mxc_isi_bus_format_by_code(format->code,\n\t\t\t\t\t\t  MXC_ISI_PIPE_PAD_SINK);\n\n\t\tif (info->encoding != MXC_ISI_ENC_RAW) {\n\t\t\tif (mf->code != MEDIA_BUS_FMT_YUV8_1X24 &&\n\t\t\t    mf->code != MEDIA_BUS_FMT_RGB888_1X24)\n\t\t\t\tmf->code = info->output;\n\n\t\t\tinfo = mxc_isi_bus_format_by_code(mf->code,\n\t\t\t\t\t\t\t  MXC_ISI_PIPE_PAD_SOURCE);\n\t\t}\n\n\t\tmf->code = info->output;\n\n\t\t \n\t\trect = mxc_isi_pipe_get_pad_crop(pipe, state,\n\t\t\t\t\t\t MXC_ISI_PIPE_PAD_SOURCE);\n\n\t\tmf->width = rect->width;\n\t\tmf->height = rect->height;\n\t}\n\n\tformat = mxc_isi_pipe_get_pad_format(pipe, state, fmt->pad);\n\t*format = *mf;\n\n\tdev_dbg(pipe->isi->dev, \"pad%u: code: 0x%04x, %ux%u\",\n\t\tfmt->pad, mf->code, mf->width, mf->height);\n\n\treturn 0;\n}\n\nstatic int mxc_isi_pipe_get_selection(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_state *state,\n\t\t\t\t      struct v4l2_subdev_selection *sel)\n{\n\tstruct mxc_isi_pipe *pipe = to_isi_pipe(sd);\n\tconst struct v4l2_mbus_framefmt *format;\n\tconst struct v4l2_rect *rect;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tif (sel->pad != MXC_ISI_PIPE_PAD_SINK)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tformat = mxc_isi_pipe_get_pad_format(pipe, state,\n\t\t\t\t\t\t     MXC_ISI_PIPE_PAD_SINK);\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = format->width;\n\t\tsel->r.height = format->height;\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tif (sel->pad != MXC_ISI_PIPE_PAD_SOURCE)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\t \n\t\trect = mxc_isi_pipe_get_pad_compose(pipe, state,\n\t\t\t\t\t\t    MXC_ISI_PIPE_PAD_SINK);\n\t\tsel->r = *rect;\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (sel->pad != MXC_ISI_PIPE_PAD_SOURCE)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\trect = mxc_isi_pipe_get_pad_crop(pipe, state, sel->pad);\n\t\tsel->r = *rect;\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (sel->pad != MXC_ISI_PIPE_PAD_SINK)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\trect = mxc_isi_pipe_get_pad_compose(pipe, state, sel->pad);\n\t\tsel->r = *rect;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxc_isi_pipe_set_selection(struct v4l2_subdev *sd,\n\t\t\t\t      struct v4l2_subdev_state *state,\n\t\t\t\t      struct v4l2_subdev_selection *sel)\n{\n\tstruct mxc_isi_pipe *pipe = to_isi_pipe(sd);\n\tstruct v4l2_mbus_framefmt *format;\n\tstruct v4l2_rect *rect;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (sel->pad != MXC_ISI_PIPE_PAD_SOURCE)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\t \n\t\trect = mxc_isi_pipe_get_pad_compose(pipe, state,\n\t\t\t\t\t\t    MXC_ISI_PIPE_PAD_SINK);\n\t\tsel->r.left = clamp_t(s32, sel->r.left, 0, rect->width - 1);\n\t\tsel->r.top = clamp_t(s32, sel->r.top, 0, rect->height - 1);\n\t\tsel->r.width = clamp(sel->r.width, MXC_ISI_MIN_WIDTH,\n\t\t\t\t     rect->width - sel->r.left);\n\t\tsel->r.height = clamp(sel->r.height, MXC_ISI_MIN_HEIGHT,\n\t\t\t\t      rect->height - sel->r.top);\n\n\t\trect = mxc_isi_pipe_get_pad_crop(pipe, state,\n\t\t\t\t\t\t MXC_ISI_PIPE_PAD_SOURCE);\n\t\t*rect = sel->r;\n\n\t\t \n\t\tformat = mxc_isi_pipe_get_pad_format(pipe, state,\n\t\t\t\t\t\t     MXC_ISI_PIPE_PAD_SOURCE);\n\t\tformat->width = sel->r.width;\n\t\tformat->height = sel->r.height;\n\t\tbreak;\n\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (sel->pad != MXC_ISI_PIPE_PAD_SINK)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tformat = mxc_isi_pipe_get_pad_format(pipe, state,\n\t\t\t\t\t\t     MXC_ISI_PIPE_PAD_SINK);\n\n\t\tsel->r.left = 0;\n\t\tsel->r.top = 0;\n\t\tsel->r.width = clamp(sel->r.width, MXC_ISI_MIN_WIDTH,\n\t\t\t\t     format->width);\n\t\tsel->r.height = clamp(sel->r.height, MXC_ISI_MIN_HEIGHT,\n\t\t\t\t      format->height);\n\n\t\trect = mxc_isi_pipe_get_pad_compose(pipe, state,\n\t\t\t\t\t\t    MXC_ISI_PIPE_PAD_SINK);\n\t\t*rect = sel->r;\n\n\t\t \n\t\trect = mxc_isi_pipe_get_pad_crop(pipe, state,\n\t\t\t\t\t\t MXC_ISI_PIPE_PAD_SOURCE);\n\t\trect->left = 0;\n\t\trect->top = 0;\n\t\trect->width = sel->r.width;\n\t\trect->height = sel->r.height;\n\n\t\tformat = mxc_isi_pipe_get_pad_format(pipe, state,\n\t\t\t\t\t\t     MXC_ISI_PIPE_PAD_SOURCE);\n\t\tformat->width = sel->r.width;\n\t\tformat->height = sel->r.height;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(pipe->isi->dev, \"%s, target %#x: (%d,%d)/%dx%d\", __func__,\n\t\tsel->target, sel->r.left, sel->r.top, sel->r.width,\n\t\tsel->r.height);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_subdev_pad_ops mxc_isi_pipe_subdev_pad_ops = {\n\t.init_cfg = mxc_isi_pipe_init_cfg,\n\t.enum_mbus_code = mxc_isi_pipe_enum_mbus_code,\n\t.get_fmt = v4l2_subdev_get_fmt,\n\t.set_fmt = mxc_isi_pipe_set_fmt,\n\t.get_selection = mxc_isi_pipe_get_selection,\n\t.set_selection = mxc_isi_pipe_set_selection,\n};\n\nstatic const struct v4l2_subdev_ops mxc_isi_pipe_subdev_ops = {\n\t.pad = &mxc_isi_pipe_subdev_pad_ops,\n};\n\n \n\nstatic irqreturn_t mxc_isi_pipe_irq_handler(int irq, void *priv)\n{\n\tstruct mxc_isi_pipe *pipe = priv;\n\tconst struct mxc_isi_ier_reg *ier_reg = pipe->isi->pdata->ier_reg;\n\tu32 status;\n\n\tstatus = mxc_isi_channel_irq_status(pipe, true);\n\n\tif (status & CHNL_STS_FRM_STRD) {\n\t\tif (!WARN_ON(!pipe->irq_handler))\n\t\t\tpipe->irq_handler(pipe, status);\n\t}\n\n\tif (status & (CHNL_STS_AXI_WR_ERR_Y |\n\t\t      CHNL_STS_AXI_WR_ERR_U |\n\t\t      CHNL_STS_AXI_WR_ERR_V))\n\t\tdev_dbg(pipe->isi->dev, \"%s: IRQ AXI Error stat=0x%X\\n\",\n\t\t\t__func__, status);\n\n\tif (status & (ier_reg->panic_y_buf_en.mask |\n\t\t      ier_reg->panic_u_buf_en.mask |\n\t\t      ier_reg->panic_v_buf_en.mask))\n\t\tdev_dbg(pipe->isi->dev, \"%s: IRQ Panic OFLW Error stat=0x%X\\n\",\n\t\t\t__func__, status);\n\n\tif (status & (ier_reg->oflw_y_buf_en.mask |\n\t\t      ier_reg->oflw_u_buf_en.mask |\n\t\t      ier_reg->oflw_v_buf_en.mask))\n\t\tdev_dbg(pipe->isi->dev, \"%s: IRQ OFLW Error stat=0x%X\\n\",\n\t\t\t__func__, status);\n\n\tif (status & (ier_reg->excs_oflw_y_buf_en.mask |\n\t\t      ier_reg->excs_oflw_u_buf_en.mask |\n\t\t      ier_reg->excs_oflw_v_buf_en.mask))\n\t\tdev_dbg(pipe->isi->dev, \"%s: IRQ EXCS OFLW Error stat=0x%X\\n\",\n\t\t\t__func__, status);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic const struct media_entity_operations mxc_isi_pipe_entity_ops = {\n\t.link_validate\t= v4l2_subdev_link_validate,\n};\n\nint mxc_isi_pipe_init(struct mxc_isi_dev *isi, unsigned int id)\n{\n\tstruct mxc_isi_pipe *pipe = &isi->pipes[id];\n\tstruct v4l2_subdev *sd;\n\tint irq;\n\tint ret;\n\n\tpipe->id = id;\n\tpipe->isi = isi;\n\tpipe->regs = isi->regs + id * isi->pdata->reg_offset;\n\n\tmutex_init(&pipe->lock);\n\n\tpipe->available_res = MXC_ISI_CHANNEL_RES_LINE_BUF\n\t\t\t    | MXC_ISI_CHANNEL_RES_OUTPUT_BUF;\n\tpipe->acquired_res = 0;\n\tpipe->chained_res = 0;\n\tpipe->chained = false;\n\n\tsd = &pipe->sd;\n\tv4l2_subdev_init(sd, &mxc_isi_pipe_subdev_ops);\n\tsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\n\tsnprintf(sd->name, sizeof(sd->name), \"mxc_isi.%d\", pipe->id);\n\tsd->dev = isi->dev;\n\n\tsd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;\n\tsd->entity.ops = &mxc_isi_pipe_entity_ops;\n\n\tpipe->pads[MXC_ISI_PIPE_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\n\tpipe->pads[MXC_ISI_PIPE_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\n\n\tret = media_entity_pads_init(&sd->entity, MXC_ISI_PIPE_PADS_NUM,\n\t\t\t\t     pipe->pads);\n\tif (ret)\n\t\tgoto error;\n\n\tret = v4l2_subdev_init_finalize(sd);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tmxc_isi_channel_irq_clear(pipe);\n\n\tirq = platform_get_irq(to_platform_device(isi->dev), id);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto error;\n\t}\n\n\tret = devm_request_irq(isi->dev, irq, mxc_isi_pipe_irq_handler,\n\t\t\t       0, dev_name(isi->dev), pipe);\n\tif (ret < 0) {\n\t\tdev_err(isi->dev, \"failed to request IRQ (%d)\\n\", ret);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tmedia_entity_cleanup(&sd->entity);\n\tmutex_destroy(&pipe->lock);\n\n\treturn ret;\n}\n\nvoid mxc_isi_pipe_cleanup(struct mxc_isi_pipe *pipe)\n{\n\tstruct v4l2_subdev *sd = &pipe->sd;\n\n\tmedia_entity_cleanup(&sd->entity);\n\tmutex_destroy(&pipe->lock);\n}\n\nint mxc_isi_pipe_acquire(struct mxc_isi_pipe *pipe,\n\t\t\t mxc_isi_pipe_irq_t irq_handler)\n{\n\tconst struct mxc_isi_bus_format_info *sink_info;\n\tconst struct mxc_isi_bus_format_info *src_info;\n\tstruct v4l2_mbus_framefmt *sink_fmt;\n\tconst struct v4l2_mbus_framefmt *src_fmt;\n\tstruct v4l2_subdev *sd = &pipe->sd;\n\tstruct v4l2_subdev_state *state;\n\tbool bypass;\n\tint ret;\n\n\tstate = v4l2_subdev_lock_and_get_active_state(sd);\n\tsink_fmt = v4l2_subdev_get_try_format(sd, state, MXC_ISI_PIPE_PAD_SINK);\n\tsrc_fmt = v4l2_subdev_get_try_format(sd, state, MXC_ISI_PIPE_PAD_SOURCE);\n\tv4l2_subdev_unlock_state(state);\n\n\tsink_info = mxc_isi_bus_format_by_code(sink_fmt->code,\n\t\t\t\t\t       MXC_ISI_PIPE_PAD_SINK);\n\tsrc_info = mxc_isi_bus_format_by_code(src_fmt->code,\n\t\t\t\t\t      MXC_ISI_PIPE_PAD_SOURCE);\n\n\tbypass = sink_fmt->width == src_fmt->width &&\n\t\t sink_fmt->height == src_fmt->height &&\n\t\t sink_info->encoding == src_info->encoding;\n\n\tret = mxc_isi_channel_acquire(pipe, irq_handler, bypass);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (sink_fmt->width > MXC_ISI_MAX_WIDTH_UNCHAINED) {\n\t\tret = mxc_isi_channel_chain(pipe, bypass);\n\t\tif (ret)\n\t\t\tmxc_isi_channel_release(pipe);\n\t}\n\n\treturn ret;\n}\n\nvoid mxc_isi_pipe_release(struct mxc_isi_pipe *pipe)\n{\n\tmxc_isi_channel_release(pipe);\n\tmxc_isi_channel_unchain(pipe);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}