{
  "module_name": "mxc-jpeg.c",
  "hash_id": "c5eea1f745ee7cb85372696ef602291823397d693cc7270637ed8918da6b5e0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/imx-jpeg/mxc-jpeg.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/irqreturn.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_domain.h>\n#include <linux/string.h>\n\n#include <media/v4l2-jpeg.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"mxc-jpeg-hw.h\"\n#include \"mxc-jpeg.h\"\n\nstatic const struct mxc_jpeg_fmt mxc_formats[] = {\n\t{\n\t\t.name\t\t= \"JPEG\",\n\t\t.fourcc\t\t= V4L2_PIX_FMT_JPEG,\n\t\t.subsampling\t= -1,\n\t\t.nc\t\t= -1,\n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 1,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_ENC,\n\t},\n\t{\n\t\t.name\t\t= \"BGR\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_BGR24,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t\t.nc\t\t= 3,\n\t\t.depth\t\t= 24,\n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 1,\n\t\t.h_align\t= 3,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 8,\n\t\t.is_rgb\t\t= 1,\n\t},\n\t{\n\t\t.name\t\t= \"BGR 12bit\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_BGR48_12,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t\t.nc\t\t= 3,\n\t\t.depth\t\t= 36,\n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 1,\n\t\t.h_align\t= 3,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 12,\n\t\t.is_rgb\t\t= 1,\n\t},\n\t{\n\t\t.name\t\t= \"ABGR\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_ABGR32,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t\t.nc\t\t= 4,\n\t\t.depth\t\t= 32,\n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 1,\n\t\t.h_align\t= 3,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 8,\n\t\t.is_rgb\t\t= 1,\n\t},\n\t{\n\t\t.name\t\t= \"ABGR 12bit\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_ABGR64_12,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t\t.nc\t\t= 4,\n\t\t.depth\t\t= 48,\n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 1,\n\t\t.h_align\t= 3,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 12,\n\t\t.is_rgb\t\t= 1,\n\t},\n\t{\n\t\t.name\t\t= \"YUV420\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12M,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_420,\n\t\t.nc\t\t= 3,\n\t\t.depth\t\t= 12,  \n\t\t.mem_planes\t= 2,\n\t\t.comp_planes\t= 2,  \n\t\t.h_align\t= 4,\n\t\t.v_align\t= 4,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 8,\n\t},\n\t{\n\t\t.name\t\t= \"YUV420\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_NV12,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_420,\n\t\t.nc\t\t= 3,\n\t\t.depth\t\t= 12,  \n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 2,  \n\t\t.h_align\t= 4,\n\t\t.v_align\t= 4,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 8,\n\t},\n\t{\n\t\t.name\t\t= \"YUV420 12bit\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_P012M,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_420,\n\t\t.nc\t\t= 3,\n\t\t.depth\t\t= 18,  \n\t\t.mem_planes\t= 2,\n\t\t.comp_planes\t= 2,  \n\t\t.h_align\t= 4,\n\t\t.v_align\t= 4,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 12,\n\t},\n\t{\n\t\t.name\t\t= \"YUV420 12bit\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_P012,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_420,\n\t\t.nc\t\t= 3,\n\t\t.depth\t\t= 18,  \n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 2,  \n\t\t.h_align\t= 4,\n\t\t.v_align\t= 4,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 12,\n\t},\n\t{\n\t\t.name\t\t= \"YUV422\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUYV,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\t\t.nc\t\t= 3,\n\t\t.depth\t\t= 16,\n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 1,\n\t\t.h_align\t= 4,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 8,\n\t},\n\t{\n\t\t.name\t\t= \"YUV422 12bit\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_Y212,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_422,\n\t\t.nc\t\t= 3,\n\t\t.depth\t\t= 24,\n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 1,\n\t\t.h_align\t= 4,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 12,\n\t},\n\t{\n\t\t.name\t\t= \"YUV444\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV24,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t\t.nc\t\t= 3,\n\t\t.depth\t\t= 24,\n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 1,\n\t\t.h_align\t= 3,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 8,\n\t},\n\t{\n\t\t.name\t\t= \"YUV444 12bit\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_YUV48_12,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_444,\n\t\t.nc\t\t= 3,\n\t\t.depth\t\t= 36,\n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 1,\n\t\t.h_align\t= 3,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 12,\n\t},\n\t{\n\t\t.name\t\t= \"Gray\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_GREY,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY,\n\t\t.nc\t\t= 1,\n\t\t.depth\t\t= 8,\n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 1,\n\t\t.h_align\t= 3,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 8,\n\t},\n\t{\n\t\t.name\t\t= \"Gray 12bit\",  \n\t\t.fourcc\t\t= V4L2_PIX_FMT_Y012,\n\t\t.subsampling\t= V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY,\n\t\t.nc\t\t= 1,\n\t\t.depth\t\t= 12,\n\t\t.mem_planes\t= 1,\n\t\t.comp_planes\t= 1,\n\t\t.h_align\t= 3,\n\t\t.v_align\t= 3,\n\t\t.flags\t\t= MXC_JPEG_FMT_TYPE_RAW,\n\t\t.precision\t= 12,\n\t},\n};\n\n#define MXC_JPEG_NUM_FORMATS ARRAY_SIZE(mxc_formats)\n\nstatic const int mxc_decode_mode = MXC_JPEG_DECODE;\nstatic const int mxc_encode_mode = MXC_JPEG_ENCODE;\n\nstatic const struct of_device_id mxc_jpeg_match[] = {\n\t{\n\t\t.compatible = \"nxp,imx8qxp-jpgdec\",\n\t\t.data       = &mxc_decode_mode,\n\t},\n\t{\n\t\t.compatible = \"nxp,imx8qxp-jpgenc\",\n\t\t.data       = &mxc_encode_mode,\n\t},\n\t{ },\n};\n\n \nstatic const unsigned char jpeg_soi[] = {\n\t0xFF, 0xD8\n};\n\nstatic const unsigned char jpeg_app0[] = {\n\t0xFF, 0xE0,\n\t0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00,\n\t0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01,\n\t0x00, 0x00\n};\n\nstatic const unsigned char jpeg_app14[] = {\n\t0xFF, 0xEE,\n\t0x00, 0x0E, 0x41, 0x64, 0x6F, 0x62, 0x65,\n\t0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char jpeg_dqt[] = {\n\t0xFF, 0xDB,\n\t0x00, 0x84, 0x00, 0x10, 0x0B, 0x0C, 0x0E,\n\t0x0C, 0x0A, 0x10, 0x0E, 0x0D, 0x0E, 0x12,\n\t0x11, 0x10, 0x13, 0x18, 0x28, 0x1A, 0x18,\n\t0x16, 0x16, 0x18, 0x31, 0x23, 0x25, 0x1D,\n\t0x28, 0x3A, 0x33, 0x3D, 0x3C, 0x39, 0x33,\n\t0x38, 0x37, 0x40, 0x48, 0x5C, 0x4E, 0x40,\n\t0x44, 0x57, 0x45, 0x37, 0x38, 0x50, 0x6D,\n\t0x51, 0x57, 0x5F, 0x62, 0x67, 0x68, 0x67,\n\t0x3E, 0x4D, 0x71, 0x79, 0x70, 0x64, 0x78,\n\t0x5C, 0x65, 0x67, 0x63, 0x01, 0x11, 0x12,\n\t0x12, 0x18, 0x15, 0x18, 0x2F, 0x1A, 0x1A,\n\t0x2F, 0x63, 0x42, 0x38, 0x42, 0x63, 0x63,\n\t0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,\n\t0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,\n\t0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,\n\t0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,\n\t0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,\n\t0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,\n\t0x63, 0x63, 0x63, 0x63, 0x63, 0x63\n};\n\nstatic const unsigned char jpeg_dqt_extseq[] = {\n\t0xFF, 0xDB,\n\t0x01, 0x04,\n\t0x10,\n\t0x00, 0x80, 0x00, 0x58, 0x00, 0x60, 0x00, 0x70,\n\t0x00, 0x60, 0x00, 0x50, 0x00, 0x80, 0x00, 0x70,\n\t0x00, 0x68, 0x00, 0x70, 0x00, 0x90, 0x00, 0x88,\n\t0x00, 0x80, 0x00, 0x98, 0x00, 0xC0, 0x01, 0x40,\n\t0x00, 0xD0, 0x00, 0xC0, 0x00, 0xB0, 0x00, 0xB0,\n\t0x00, 0xC0, 0x01, 0x88, 0x01, 0x18, 0x01, 0x28,\n\t0x00, 0xE8, 0x01, 0x40, 0x01, 0xD0, 0x01, 0x98,\n\t0x01, 0xE8, 0x01, 0xE0, 0x01, 0xC8, 0x01, 0x98,\n\t0x01, 0xC0, 0x01, 0xB8, 0x02, 0x00, 0x02, 0x40,\n\t0x02, 0xE0, 0x02, 0x70, 0x02, 0x00, 0x02, 0x20,\n\t0x02, 0xB8, 0x02, 0x28, 0x01, 0xB8, 0x01, 0xC0,\n\t0x02, 0x80, 0x03, 0x68, 0x02, 0x88, 0x02, 0xB8,\n\t0x02, 0xF8, 0x03, 0x10, 0x03, 0x38, 0x03, 0x40,\n\t0x03, 0x38, 0x01, 0xF0, 0x02, 0x68, 0x03, 0x88,\n\t0x03, 0xC8, 0x03, 0x80, 0x03, 0x20, 0x03, 0xC0,\n\t0x02, 0xE0, 0x03, 0x28, 0x03, 0x38, 0x03, 0x18,\n\t0x11,\n\t0x00, 0x88, 0x00, 0x90, 0x00, 0x90, 0x00, 0xC0,\n\t0x00, 0xA8, 0x00, 0xC0, 0x01, 0x78, 0x00, 0xD0,\n\t0x00, 0xD0, 0x01, 0x78, 0x03, 0x18, 0x02, 0x10,\n\t0x01, 0xC0, 0x02, 0x10, 0x03, 0x18, 0x03, 0x18,\n\t0x03, 0x18, 0x03, 0x18, 0x03, 0x18, 0x03, 0x18,\n\t0x03, 0x18, 0x03, 0x18, 0x03, 0x18, 0x03, 0x18,\n\t0x03, 0x18, 0x03, 0x18, 0x03, 0x18, 0x03, 0x18,\n\t0x03, 0x18, 0x03, 0x18, 0x03, 0x18, 0x03, 0x18,\n\t0x03, 0x18, 0x03, 0x18, 0x03, 0x18, 0x03, 0x18,\n\t0x03, 0x18, 0x03, 0x18, 0x03, 0x18, 0x03, 0x18,\n\t0x03, 0x18, 0x03, 0x18, 0x03, 0x18, 0x03, 0x18,\n\t0x03, 0x18, 0x03, 0x18, 0x03, 0x18, 0x03, 0x18,\n\t0x03, 0x18, 0x03, 0x18, 0x03, 0x18, 0x03, 0x18,\n\t0x03, 0x18, 0x03, 0x18, 0x03, 0x18, 0x03, 0x18,\n\t0x03, 0x18, 0x03, 0x18, 0x03, 0x18, 0x03, 0x18,\n\t0x03, 0x18, 0x03, 0x18, 0x03, 0x18, 0x03, 0x18,\n};\n\nstatic const unsigned char jpeg_sof_maximal[] = {\n\t0xFF, 0xC0,\n\t0x00, 0x14, 0x08, 0x00, 0x40, 0x00, 0x40,\n\t0x04, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01,\n\t0x03, 0x11, 0x01, 0x04, 0x11, 0x01\n};\n\nstatic const unsigned char jpeg_sof_extseq[] = {\n\t0xFF, 0xC1,\n\t0x00, 0x14, 0x08, 0x00, 0x40, 0x00, 0x40,\n\t0x04, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01,\n\t0x03, 0x11, 0x01, 0x04, 0x11, 0x01\n};\n\nstatic const unsigned char jpeg_dht[] = {\n\t0xFF, 0xC4,\n\t0x01, 0xA2, 0x00, 0x00, 0x01, 0x05, 0x01,\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n\t0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n\t0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01,\n\t0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05,\n\t0x04, 0x04, 0x00, 0x00, 0x01, 0x7D, 0x01,\n\t0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,\n\t0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61,\n\t0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91,\n\t0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15,\n\t0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72,\n\t0x82, 0x09, 0x0A, 0x16, 0x17, 0x18, 0x19,\n\t0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A,\n\t0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A,\n\t0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n\t0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n\t0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76,\n\t0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85,\n\t0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93,\n\t0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A,\n\t0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8,\n\t0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,\n\t0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4,\n\t0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2,\n\t0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9,\n\t0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,\n\t0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3,\n\t0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA,\n\t0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01,\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03,\n\t0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,\n\t0x0B, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04,\n\t0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04,\n\t0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02,\n\t0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06,\n\t0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13,\n\t0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,\n\t0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33, 0x52,\n\t0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16,\n\t0x24, 0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18,\n\t0x19, 0x1A, 0x26, 0x27, 0x28, 0x29, 0x2A,\n\t0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43,\n\t0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A,\n\t0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,\n\t0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,\n\t0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85,\n\t0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93,\n\t0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A,\n\t0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8,\n\t0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,\n\t0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4,\n\t0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2,\n\t0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9,\n\t0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,\n\t0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5,\n\t0xF6, 0xF7, 0xF8, 0xF9, 0xFA\n};\n\nstatic const unsigned char jpeg_dht_extseq[] = {\n\t0xFF, 0xC4,\n\t0x02, 0x2a, 0x00, 0x00, 0x01, 0x05, 0x01,\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n\t0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01,\n\t0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n\t0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02,\n\t0x04, 0x03, 0x05, 0x05, 0x02, 0x03, 0x02,\n\t0x00, 0x00, 0xbf, 0x01, 0x02, 0x03, 0x00,\n\t0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41,\n\t0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71,\n\t0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23,\n\t0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,\n\t0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a,\n\t0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26,\n\t0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36,\n\t0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45,\n\t0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54,\n\t0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63,\n\t0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a,\n\t0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,\n\t0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88,\n\t0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,\n\t0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4,\n\t0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2,\n\t0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9,\n\t0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n\t0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5,\n\t0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,\n\t0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,\n\t0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6,\n\t0xf7, 0xf8, 0xf9, 0xfa, 0x0b, 0x0c, 0x0d,\n\t0x0e, 0x1b, 0x1c, 0x1d, 0x1e, 0x2b, 0x2c,\n\t0x2d, 0x2e, 0x3b, 0x3c, 0x3d, 0x3e, 0x4b,\n\t0x4c, 0x4d, 0x4e, 0x5b, 0x5c, 0x5d, 0x5e,\n\t0x6b, 0x6c, 0x6d, 0x6e, 0x7b, 0x7c, 0x7d,\n\t0x7e, 0x8b, 0x8c, 0x8d, 0x8e, 0x9b, 0x9c,\n\t0x9d, 0x9e, 0xab, 0xac, 0xad, 0xae, 0xbb,\n\t0xbc, 0xbd, 0xbe, 0xcb, 0xcc, 0xcd, 0xce,\n\t0xdb, 0xdc, 0xdd, 0xde, 0xeb, 0xec, 0xed,\n\t0xee, 0xfb, 0xfc, 0xfd, 0xfe, 0x01, 0x00,\n\t0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01,\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,\n\t0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,\n\t0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c,\n\t0x0d, 0x0e, 0x0f, 0x11, 0x00, 0x02, 0x01,\n\t0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05,\n\t0x02, 0x03, 0x02, 0x00, 0x00, 0xbf, 0x01,\n\t0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,\n\t0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61,\n\t0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91,\n\t0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15,\n\t0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72,\n\t0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19,\n\t0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a,\n\t0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a,\n\t0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n\t0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n\t0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76,\n\t0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85,\n\t0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93,\n\t0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a,\n\t0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8,\n\t0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,\n\t0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4,\n\t0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,\n\t0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9,\n\t0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,\n\t0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3,\n\t0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa,\n\t0x0b, 0x0c, 0x0d, 0x0e, 0x1b, 0x1c, 0x1d,\n\t0x1e, 0x2b, 0x2c, 0x2d, 0x2e, 0x3b, 0x3c,\n\t0x3d, 0x3e, 0x4b, 0x4c, 0x4d, 0x4e, 0x5b,\n\t0x5c, 0x5d, 0x5e, 0x6b, 0x6c, 0x6d, 0x6e,\n\t0x7b, 0x7c, 0x7d, 0x7e, 0x8b, 0x8c, 0x8d,\n\t0x8e, 0x9b, 0x9c, 0x9d, 0x9e, 0xab, 0xac,\n\t0xad, 0xae, 0xbb, 0xbc, 0xbd, 0xbe, 0xcb,\n\t0xcc, 0xcd, 0xce, 0xdb, 0xdc, 0xdd, 0xde,\n\t0xeb, 0xec, 0xed, 0xee, 0xfb, 0xfc, 0xfd,\n\t0xfe,\n};\n\nstatic const unsigned char jpeg_dri[] = {\n\t0xFF, 0xDD,\n\t0x00, 0x04, 0x00, 0x20\n};\n\nstatic const unsigned char jpeg_sos_maximal[] = {\n\t0xFF, 0xDA,\n\t0x00, 0x0C, 0x04, 0x01, 0x00, 0x02, 0x11, 0x03,\n\t0x11, 0x04, 0x11, 0x00, 0x3F, 0x00\n};\n\nstatic const unsigned char jpeg_image_red[] = {\n\t0xFC, 0x5F, 0xA2, 0xBF, 0xCA, 0x73, 0xFE, 0xFE,\n\t0x02, 0x8A, 0x00, 0x28, 0xA0, 0x02, 0x8A, 0x00,\n\t0x28, 0xA0, 0x02, 0x8A, 0x00, 0x28, 0xA0, 0x02,\n\t0x8A, 0x00, 0x28, 0xA0, 0x02, 0x8A, 0x00, 0x28,\n\t0xA0, 0x02, 0x8A, 0x00, 0x28, 0xA0, 0x02, 0x8A,\n\t0x00, 0x28, 0xA0, 0x02, 0x8A, 0x00, 0x28, 0xA0,\n\t0x02, 0x8A, 0x00, 0x28, 0xA0, 0x02, 0x8A, 0x00,\n\t0x28, 0xA0, 0x02, 0x8A, 0x00, 0x28, 0xA0, 0x02,\n\t0x8A, 0x00, 0x28, 0xA0, 0x02, 0x8A, 0x00, 0x28,\n\t0xA0, 0x02, 0x8A, 0x00, 0x28, 0xA0, 0x02, 0x8A,\n\t0x00, 0x28, 0xA0, 0x02, 0x8A, 0x00\n};\n\nstatic const unsigned char jpeg_eoi[] = {\n\t0xFF, 0xD9\n};\n\nstruct mxc_jpeg_src_buf {\n\t \n\tstruct vb2_v4l2_buffer\tb;\n\tstruct list_head\tlist;\n\n\t \n\tbool\t\t\tdht_needed;\n\tbool\t\t\tjpeg_parse_error;\n\tconst struct mxc_jpeg_fmt\t*fmt;\n\tint\t\t\tw;\n\tint\t\t\th;\n};\n\nstatic inline struct mxc_jpeg_src_buf *vb2_to_mxc_buf(struct vb2_buffer *vb)\n{\n\treturn container_of(to_vb2_v4l2_buffer(vb),\n\t\t\t    struct mxc_jpeg_src_buf, b);\n}\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level (0-3)\");\n\nstatic unsigned int hw_timeout = 2000;\nmodule_param(hw_timeout, int, 0644);\nMODULE_PARM_DESC(hw_timeout, \"MXC JPEG hw timeout, the number of milliseconds\");\n\nstatic void mxc_jpeg_bytesperline(struct mxc_jpeg_q_data *q, u32 precision);\nstatic void mxc_jpeg_sizeimage(struct mxc_jpeg_q_data *q);\n\nstatic void _bswap16(u16 *a)\n{\n\t*a = ((*a & 0x00FF) << 8) | ((*a & 0xFF00) >> 8);\n}\n\nstatic void print_mxc_buf(struct mxc_jpeg_dev *jpeg, struct vb2_buffer *buf,\n\t\t\t  unsigned long len)\n{\n\tunsigned int plane_no;\n\tu32 dma_addr;\n\tvoid *vaddr;\n\tunsigned long payload;\n\n\tif (debug < 3)\n\t\treturn;\n\n\tfor (plane_no = 0; plane_no < buf->num_planes; plane_no++) {\n\t\tpayload = vb2_get_plane_payload(buf, plane_no);\n\t\tif (len == 0)\n\t\t\tlen = payload;\n\t\tdma_addr = vb2_dma_contig_plane_dma_addr(buf, plane_no);\n\t\tvaddr = vb2_plane_vaddr(buf, plane_no);\n\t\tv4l2_dbg(3, debug, &jpeg->v4l2_dev,\n\t\t\t \"plane %d (vaddr=%p dma_addr=%x payload=%ld):\",\n\t\t\t  plane_no, vaddr, dma_addr, payload);\n\t\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t\t       vaddr, len, false);\n\t}\n}\n\nstatic inline struct mxc_jpeg_ctx *mxc_jpeg_fh_to_ctx(struct v4l2_fh *fh)\n{\n\treturn container_of(fh, struct mxc_jpeg_ctx, fh);\n}\n\nstatic int enum_fmt(const struct mxc_jpeg_fmt *mxc_formats, int n,\n\t\t    struct v4l2_fmtdesc *f, u32 type)\n{\n\tint i, num = 0;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tif (mxc_formats[i].flags == type) {\n\t\t\t \n\t\t\tif (num == f->index)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\t++num;\n\t\t}\n\t}\n\n\t \n\tif (i >= n)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = mxc_formats[i].fourcc;\n\n\treturn 0;\n}\n\nstatic const struct mxc_jpeg_fmt *mxc_jpeg_find_format(u32 pixelformat)\n{\n\tunsigned int k;\n\n\tfor (k = 0; k < MXC_JPEG_NUM_FORMATS; k++) {\n\t\tconst struct mxc_jpeg_fmt *fmt = &mxc_formats[k];\n\n\t\tif (fmt->fourcc == pixelformat)\n\t\t\treturn fmt;\n\t}\n\treturn NULL;\n}\n\nstatic enum mxc_jpeg_image_format mxc_jpeg_fourcc_to_imgfmt(u32 fourcc)\n{\n\tswitch (fourcc) {\n\tcase V4L2_PIX_FMT_GREY:\n\tcase V4L2_PIX_FMT_Y012:\n\t\treturn MXC_JPEG_GRAY;\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_Y212:\n\t\treturn MXC_JPEG_YUV422;\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV12M:\n\tcase V4L2_PIX_FMT_P012:\n\tcase V4L2_PIX_FMT_P012M:\n\t\treturn MXC_JPEG_YUV420;\n\tcase V4L2_PIX_FMT_YUV24:\n\tcase V4L2_PIX_FMT_YUV48_12:\n\t\treturn MXC_JPEG_YUV444;\n\tcase V4L2_PIX_FMT_BGR24:\n\tcase V4L2_PIX_FMT_BGR48_12:\n\t\treturn MXC_JPEG_BGR;\n\tcase V4L2_PIX_FMT_ABGR32:\n\tcase V4L2_PIX_FMT_ABGR64_12:\n\t\treturn MXC_JPEG_ABGR;\n\tdefault:\n\t\treturn MXC_JPEG_INVALID;\n\t}\n}\n\nstatic struct mxc_jpeg_q_data *mxc_jpeg_get_q_data(struct mxc_jpeg_ctx *ctx,\n\t\t\t\t\t\t   enum v4l2_buf_type type)\n{\n\tif (V4L2_TYPE_IS_OUTPUT(type))\n\t\treturn &ctx->out_q;\n\treturn &ctx->cap_q;\n}\n\nstatic void mxc_jpeg_addrs(struct mxc_jpeg_desc *desc,\n\t\t\t   struct vb2_buffer *raw_buf,\n\t\t\t   struct vb2_buffer *jpeg_buf, int offset)\n{\n\tint img_fmt = desc->stm_ctrl & STM_CTRL_IMAGE_FORMAT_MASK;\n\tstruct mxc_jpeg_ctx *ctx = vb2_get_drv_priv(raw_buf->vb2_queue);\n\tstruct mxc_jpeg_q_data *q_data;\n\n\tq_data = mxc_jpeg_get_q_data(ctx, raw_buf->type);\n\tdesc->buf_base0 = vb2_dma_contig_plane_dma_addr(raw_buf, 0);\n\tdesc->buf_base1 = 0;\n\tif (img_fmt == STM_CTRL_IMAGE_FORMAT(MXC_JPEG_YUV420)) {\n\t\tif (raw_buf->num_planes == 2)\n\t\t\tdesc->buf_base1 = vb2_dma_contig_plane_dma_addr(raw_buf, 1);\n\t\telse\n\t\t\tdesc->buf_base1 = desc->buf_base0 + q_data->sizeimage[0];\n\t}\n\tdesc->stm_bufbase = vb2_dma_contig_plane_dma_addr(jpeg_buf, 0) +\n\t\toffset;\n}\n\nstatic bool mxc_jpeg_is_extended_sequential(const struct mxc_jpeg_fmt *fmt)\n{\n\tif (!fmt || !(fmt->flags & MXC_JPEG_FMT_TYPE_RAW))\n\t\treturn false;\n\n\tif (fmt->precision > 8)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void notify_eos(struct mxc_jpeg_ctx *ctx)\n{\n\tconst struct v4l2_event ev = {\n\t\t.type = V4L2_EVENT_EOS\n\t};\n\n\tdev_dbg(ctx->mxc_jpeg->dev, \"Notify app event EOS reached\");\n\tv4l2_event_queue_fh(&ctx->fh, &ev);\n}\n\nstatic void notify_src_chg(struct mxc_jpeg_ctx *ctx)\n{\n\tconst struct v4l2_event ev = {\n\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n\t};\n\n\tdev_dbg(ctx->mxc_jpeg->dev, \"Notify app event SRC_CH_RESOLUTION\");\n\tv4l2_event_queue_fh(&ctx->fh, &ev);\n}\n\nstatic int mxc_get_free_slot(struct mxc_jpeg_slot_data *slot_data)\n{\n\tif (!slot_data->used)\n\t\treturn slot_data->slot;\n\treturn -1;\n}\n\nstatic bool mxc_jpeg_alloc_slot_data(struct mxc_jpeg_dev *jpeg)\n{\n\tstruct mxc_jpeg_desc *desc;\n\tstruct mxc_jpeg_desc *cfg_desc;\n\tvoid *cfg_stm;\n\n\tif (jpeg->slot_data.desc)\n\t\tgoto skip_alloc;  \n\n\t \n\tdesc = dma_alloc_coherent(jpeg->dev,\n\t\t\t\t  sizeof(struct mxc_jpeg_desc),\n\t\t\t\t  &jpeg->slot_data.desc_handle,\n\t\t\t\t  GFP_ATOMIC);\n\tif (!desc)\n\t\tgoto err;\n\tjpeg->slot_data.desc = desc;\n\n\t \n\tcfg_desc = dma_alloc_coherent(jpeg->dev,\n\t\t\t\t      sizeof(struct mxc_jpeg_desc),\n\t\t\t\t      &jpeg->slot_data.cfg_desc_handle,\n\t\t\t\t      GFP_ATOMIC);\n\tif (!cfg_desc)\n\t\tgoto err;\n\tjpeg->slot_data.cfg_desc = cfg_desc;\n\n\t \n\tcfg_stm = dma_alloc_coherent(jpeg->dev,\n\t\t\t\t     MXC_JPEG_MAX_CFG_STREAM,\n\t\t\t\t     &jpeg->slot_data.cfg_stream_handle,\n\t\t\t\t     GFP_ATOMIC);\n\tif (!cfg_stm)\n\t\tgoto err;\n\tjpeg->slot_data.cfg_stream_vaddr = cfg_stm;\n\nskip_alloc:\n\tjpeg->slot_data.used = true;\n\n\treturn true;\nerr:\n\tdev_err(jpeg->dev, \"Could not allocate descriptors for slot %d\", jpeg->slot_data.slot);\n\n\treturn false;\n}\n\nstatic void mxc_jpeg_free_slot_data(struct mxc_jpeg_dev *jpeg)\n{\n\t \n\tdma_free_coherent(jpeg->dev, sizeof(struct mxc_jpeg_desc),\n\t\t\t  jpeg->slot_data.desc,\n\t\t\t  jpeg->slot_data.desc_handle);\n\n\t \n\tdma_free_coherent(jpeg->dev, sizeof(struct mxc_jpeg_desc),\n\t\t\t  jpeg->slot_data.cfg_desc,\n\t\t\t  jpeg->slot_data.cfg_desc_handle);\n\n\t \n\tdma_free_coherent(jpeg->dev, MXC_JPEG_MAX_CFG_STREAM,\n\t\t\t  jpeg->slot_data.cfg_stream_vaddr,\n\t\t\t  jpeg->slot_data.cfg_stream_handle);\n\n\tjpeg->slot_data.used = false;\n}\n\nstatic void mxc_jpeg_check_and_set_last_buffer(struct mxc_jpeg_ctx *ctx,\n\t\t\t\t\t       struct vb2_v4l2_buffer *src_buf,\n\t\t\t\t\t       struct vb2_v4l2_buffer *dst_buf)\n{\n\tif (v4l2_m2m_is_last_draining_src_buf(ctx->fh.m2m_ctx, src_buf)) {\n\t\tdst_buf->flags |= V4L2_BUF_FLAG_LAST;\n\t\tv4l2_m2m_mark_stopped(ctx->fh.m2m_ctx);\n\t\tnotify_eos(ctx);\n\t\tctx->header_parsed = false;\n\t}\n}\n\nstatic void mxc_jpeg_job_finish(struct mxc_jpeg_ctx *ctx, enum vb2_buffer_state state, bool reset)\n{\n\tstruct mxc_jpeg_dev *jpeg = ctx->mxc_jpeg;\n\tvoid __iomem *reg = jpeg->base_reg;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tmxc_jpeg_check_and_set_last_buffer(ctx, src_buf, dst_buf);\n\tv4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tv4l2_m2m_buf_done(src_buf, state);\n\tv4l2_m2m_buf_done(dst_buf, state);\n\n\tmxc_jpeg_disable_irq(reg, ctx->slot);\n\tjpeg->slot_data.used = false;\n\tif (reset)\n\t\tmxc_jpeg_sw_reset(reg);\n}\n\nstatic u32 mxc_jpeg_get_plane_size(struct mxc_jpeg_q_data *q_data, u32 plane_no)\n{\n\tconst struct mxc_jpeg_fmt *fmt = q_data->fmt;\n\tu32 size;\n\tint i;\n\n\tif (plane_no >= fmt->mem_planes)\n\t\treturn 0;\n\n\tif (fmt->mem_planes == fmt->comp_planes)\n\t\treturn q_data->sizeimage[plane_no];\n\n\tif (plane_no < fmt->mem_planes - 1)\n\t\treturn q_data->sizeimage[plane_no];\n\n\tsize = q_data->sizeimage[fmt->mem_planes - 1];\n\n\t \n\tif (WARN_ON_ONCE(fmt->comp_planes > ARRAY_SIZE(q_data->sizeimage)))\n\t\treturn size;\n\n\tfor (i = fmt->mem_planes; i < fmt->comp_planes; i++)\n\t\tsize += q_data->sizeimage[i];\n\n\treturn size;\n}\n\nstatic irqreturn_t mxc_jpeg_dec_irq(int irq, void *priv)\n{\n\tstruct mxc_jpeg_dev *jpeg = priv;\n\tstruct mxc_jpeg_ctx *ctx;\n\tvoid __iomem *reg = jpeg->base_reg;\n\tstruct device *dev = jpeg->dev;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct mxc_jpeg_src_buf *jpeg_src_buf;\n\tenum vb2_buffer_state buf_state;\n\tu32 dec_ret, com_status;\n\tunsigned long payload;\n\tstruct mxc_jpeg_q_data *q_data;\n\tenum v4l2_buf_type cap_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tunsigned int slot;\n\n\tspin_lock(&jpeg->hw_lock);\n\n\tcom_status = readl(reg + COM_STATUS);\n\tslot = COM_STATUS_CUR_SLOT(com_status);\n\tdev_dbg(dev, \"Irq %d on slot %d.\\n\", irq, slot);\n\n\tctx = v4l2_m2m_get_curr_priv(jpeg->m2m_dev);\n\tif (WARN_ON(!ctx))\n\t\tgoto job_unlock;\n\n\tif (slot != ctx->slot) {\n\t\t \n\t\tdev_warn(dev, \"IRQ slot %d != context slot %d.\\n\",\n\t\t\t slot, ctx->slot);\n\t\tgoto job_unlock;\n\t}\n\n\tif (!jpeg->slot_data.used)\n\t\tgoto job_unlock;\n\n\tdec_ret = readl(reg + MXC_SLOT_OFFSET(slot, SLOT_STATUS));\n\twritel(dec_ret, reg + MXC_SLOT_OFFSET(slot, SLOT_STATUS));  \n\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tif (!dst_buf || !src_buf) {\n\t\tdev_err(dev, \"No source or destination buffer.\\n\");\n\t\tgoto job_unlock;\n\t}\n\tjpeg_src_buf = vb2_to_mxc_buf(&src_buf->vb2_buf);\n\n\tif (dec_ret & SLOT_STATUS_ENC_CONFIG_ERR) {\n\t\tu32 ret = readl(reg + CAST_STATUS12);\n\n\t\tdev_err(dev, \"Encoder/decoder error, dec_ret = 0x%08x, status=0x%08x\",\n\t\t\tdec_ret, ret);\n\t\tmxc_jpeg_clr_desc(reg, slot);\n\t\tmxc_jpeg_sw_reset(reg);\n\t\tbuf_state = VB2_BUF_STATE_ERROR;\n\t\tgoto buffers_done;\n\t}\n\n\tif (!(dec_ret & SLOT_STATUS_FRMDONE))\n\t\tgoto job_unlock;\n\n\tif (jpeg->mode == MXC_JPEG_ENCODE &&\n\t    ctx->enc_state == MXC_JPEG_ENC_CONF) {\n\t\tq_data = mxc_jpeg_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\t\tctx->enc_state = MXC_JPEG_ENCODING;\n\t\tdev_dbg(dev, \"Encoder config finished. Start encoding...\\n\");\n\t\tmxc_jpeg_enc_set_quality(dev, reg, ctx->jpeg_quality);\n\t\tmxc_jpeg_enc_mode_go(dev, reg, mxc_jpeg_is_extended_sequential(q_data->fmt));\n\t\tgoto job_unlock;\n\t}\n\tif (jpeg->mode == MXC_JPEG_DECODE && jpeg_src_buf->dht_needed) {\n\t\tjpeg_src_buf->dht_needed = false;\n\t\tdev_dbg(dev, \"Decoder DHT cfg finished. Start decoding...\\n\");\n\t\tgoto job_unlock;\n\t}\n\n\tif (jpeg->mode == MXC_JPEG_ENCODE) {\n\t\tpayload = readl(reg + MXC_SLOT_OFFSET(slot, SLOT_BUF_PTR));\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, payload);\n\t\tdev_dbg(dev, \"Encoding finished, payload size: %ld\\n\",\n\t\t\tpayload);\n\t} else {\n\t\tq_data = mxc_jpeg_get_q_data(ctx, cap_type);\n\t\tpayload = mxc_jpeg_get_plane_size(q_data, 0);\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, payload);\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 1, 0);\n\t\tif (q_data->fmt->mem_planes == 2) {\n\t\t\tpayload = mxc_jpeg_get_plane_size(q_data, 1);\n\t\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 1, payload);\n\t\t}\n\t\tdev_dbg(dev, \"Decoding finished, payload size: %ld + %ld\\n\",\n\t\t\tvb2_get_plane_payload(&dst_buf->vb2_buf, 0),\n\t\t\tvb2_get_plane_payload(&dst_buf->vb2_buf, 1));\n\t}\n\n\t \n\tdev_dbg(dev, \"src_buf preview: \");\n\tprint_mxc_buf(jpeg, &src_buf->vb2_buf, 32);\n\tdev_dbg(dev, \"dst_buf preview: \");\n\tprint_mxc_buf(jpeg, &dst_buf->vb2_buf, 32);\n\tbuf_state = VB2_BUF_STATE_DONE;\n\nbuffers_done:\n\tmxc_jpeg_job_finish(ctx, buf_state, false);\n\tspin_unlock(&jpeg->hw_lock);\n\tcancel_delayed_work(&ctx->task_timer);\n\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n\treturn IRQ_HANDLED;\njob_unlock:\n\tspin_unlock(&jpeg->hw_lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int mxc_jpeg_fixup_sof(struct mxc_jpeg_sof *sof,\n\t\t\t      u32 fourcc,\n\t\t\t      u16 w, u16 h)\n{\n\tint sof_length;\n\tconst struct mxc_jpeg_fmt *fmt = mxc_jpeg_find_format(fourcc);\n\n\tif (fmt)\n\t\tsof->precision = fmt->precision;\n\telse\n\t\tsof->precision = 8;  \n\tsof->height = h;\n\t_bswap16(&sof->height);\n\tsof->width = w;\n\t_bswap16(&sof->width);\n\n\tswitch (fourcc) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV12M:\n\tcase V4L2_PIX_FMT_P012:\n\tcase V4L2_PIX_FMT_P012M:\n\t\tsof->components_no = 3;\n\t\tsof->comp[0].v = 0x2;\n\t\tsof->comp[0].h = 0x2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_Y212:\n\t\tsof->components_no = 3;\n\t\tsof->comp[0].v = 0x1;\n\t\tsof->comp[0].h = 0x2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV24:\n\tcase V4L2_PIX_FMT_YUV48_12:\n\tcase V4L2_PIX_FMT_BGR24:\n\tcase V4L2_PIX_FMT_BGR48_12:\n\tdefault:\n\t\tsof->components_no = 3;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_ABGR32:\n\tcase V4L2_PIX_FMT_ABGR64_12:\n\t\tsof->components_no = 4;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_GREY:\n\tcase V4L2_PIX_FMT_Y012:\n\t\tsof->components_no = 1;\n\t\tbreak;\n\t}\n\tsof_length = 8 + 3 * sof->components_no;\n\tsof->length = sof_length;\n\t_bswap16(&sof->length);\n\n\treturn sof_length;  \n}\n\nstatic int mxc_jpeg_fixup_sos(struct mxc_jpeg_sos *sos,\n\t\t\t      u32 fourcc)\n{\n\tint sos_length;\n\tu8 *sof_u8 = (u8 *)sos;\n\n\tswitch (fourcc) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_NV12M:\n\tcase V4L2_PIX_FMT_P012:\n\tcase V4L2_PIX_FMT_P012M:\n\t\tsos->components_no = 3;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\tcase V4L2_PIX_FMT_Y212:\n\t\tsos->components_no = 3;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV24:\n\tcase V4L2_PIX_FMT_YUV48_12:\n\tcase V4L2_PIX_FMT_BGR24:\n\tcase V4L2_PIX_FMT_BGR48_12:\n\tdefault:\n\t\tsos->components_no = 3;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_ABGR32:\n\tcase V4L2_PIX_FMT_ABGR64_12:\n\t\tsos->components_no = 4;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_GREY:\n\tcase V4L2_PIX_FMT_Y012:\n\t\tsos->components_no = 1;\n\t\tbreak;\n\t}\n\tsos_length = 6 + 2 * sos->components_no;\n\tsos->length = sos_length;\n\t_bswap16(&sos->length);\n\n\t \n\tsof_u8[sos_length - 1] = 0x0;\n\tsof_u8[sos_length - 2] = 0x3f;\n\tsof_u8[sos_length - 3] = 0x0;\n\n\treturn sos_length;  \n}\n\nstatic unsigned int mxc_jpeg_setup_cfg_stream(void *cfg_stream_vaddr,\n\t\t\t\t\t      u32 fourcc,\n\t\t\t\t\t      u16 w, u16 h)\n{\n\t \n\tunsigned int offset = 0x80;\n\tu8 *cfg = (u8 *)cfg_stream_vaddr;\n\tstruct mxc_jpeg_sof *sof;\n\tstruct mxc_jpeg_sos *sos;\n\tconst struct mxc_jpeg_fmt *fmt = mxc_jpeg_find_format(fourcc);\n\n\tif (!fmt)\n\t\treturn 0;\n\n\tmemcpy(cfg + offset, jpeg_soi, ARRAY_SIZE(jpeg_soi));\n\toffset += ARRAY_SIZE(jpeg_soi);\n\n\tif (fmt->is_rgb) {\n\t\tmemcpy(cfg + offset, jpeg_app14, sizeof(jpeg_app14));\n\t\toffset += sizeof(jpeg_app14);\n\t} else {\n\t\tmemcpy(cfg + offset, jpeg_app0, sizeof(jpeg_app0));\n\t\toffset += sizeof(jpeg_app0);\n\t}\n\n\tif (mxc_jpeg_is_extended_sequential(fmt)) {\n\t\tmemcpy(cfg + offset, jpeg_dqt_extseq, sizeof(jpeg_dqt_extseq));\n\t\toffset += sizeof(jpeg_dqt_extseq);\n\n\t\tmemcpy(cfg + offset, jpeg_sof_extseq, sizeof(jpeg_sof_extseq));\n\t} else {\n\t\tmemcpy(cfg + offset, jpeg_dqt, sizeof(jpeg_dqt));\n\t\toffset += sizeof(jpeg_dqt);\n\n\t\tmemcpy(cfg + offset, jpeg_sof_maximal, sizeof(jpeg_sof_maximal));\n\t}\n\toffset += 2;  \n\tsof = (struct mxc_jpeg_sof *)(cfg + offset);\n\toffset += mxc_jpeg_fixup_sof(sof, fourcc, w, h);\n\n\tif (mxc_jpeg_is_extended_sequential(fmt)) {\n\t\tmemcpy(cfg + offset, jpeg_dht_extseq, sizeof(jpeg_dht_extseq));\n\t\toffset += sizeof(jpeg_dht_extseq);\n\t} else {\n\t\tmemcpy(cfg + offset, jpeg_dht, sizeof(jpeg_dht));\n\t\toffset += sizeof(jpeg_dht);\n\t}\n\n\tmemcpy(cfg + offset, jpeg_dri, sizeof(jpeg_dri));\n\toffset += sizeof(jpeg_dri);\n\n\tmemcpy(cfg + offset, jpeg_sos_maximal, sizeof(jpeg_sos_maximal));\n\toffset += 2;  \n\tsos = (struct mxc_jpeg_sos *)(cfg + offset);\n\toffset += mxc_jpeg_fixup_sos(sos, fourcc);\n\n\tmemcpy(cfg + offset, jpeg_image_red, sizeof(jpeg_image_red));\n\toffset += sizeof(jpeg_image_red);\n\n\tmemcpy(cfg + offset, jpeg_eoi, sizeof(jpeg_eoi));\n\toffset += sizeof(jpeg_eoi);\n\n\treturn offset;\n}\n\nstatic void mxc_jpeg_config_dec_desc(struct vb2_buffer *out_buf,\n\t\t\t\t     struct mxc_jpeg_ctx *ctx,\n\t\t\t\t     struct vb2_buffer *src_buf,\n\t\t\t\t     struct vb2_buffer *dst_buf)\n{\n\tenum v4l2_buf_type cap_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tstruct mxc_jpeg_q_data *q_data_cap;\n\tenum mxc_jpeg_image_format img_fmt;\n\tstruct mxc_jpeg_dev *jpeg = ctx->mxc_jpeg;\n\tvoid __iomem *reg = jpeg->base_reg;\n\tunsigned int slot = ctx->slot;\n\tstruct mxc_jpeg_desc *desc = jpeg->slot_data.desc;\n\tstruct mxc_jpeg_desc *cfg_desc = jpeg->slot_data.cfg_desc;\n\tdma_addr_t desc_handle = jpeg->slot_data.desc_handle;\n\tdma_addr_t cfg_desc_handle = jpeg->slot_data.cfg_desc_handle;\n\tdma_addr_t cfg_stream_handle = jpeg->slot_data.cfg_stream_handle;\n\tunsigned int *cfg_size = &jpeg->slot_data.cfg_stream_size;\n\tvoid *cfg_stream_vaddr = jpeg->slot_data.cfg_stream_vaddr;\n\tstruct mxc_jpeg_src_buf *jpeg_src_buf;\n\n\tjpeg_src_buf = vb2_to_mxc_buf(src_buf);\n\n\t \n\tdesc->next_descpt_ptr = 0;  \n\tq_data_cap = mxc_jpeg_get_q_data(ctx, cap_type);\n\tdesc->imgsize = q_data_cap->w_adjusted << 16 | q_data_cap->h_adjusted;\n\timg_fmt = mxc_jpeg_fourcc_to_imgfmt(q_data_cap->fmt->fourcc);\n\tdesc->stm_ctrl &= ~STM_CTRL_IMAGE_FORMAT(0xF);  \n\tdesc->stm_ctrl |= STM_CTRL_IMAGE_FORMAT(img_fmt);\n\tdesc->stm_ctrl |= STM_CTRL_BITBUF_PTR_CLR(1);\n\tif (mxc_jpeg_is_extended_sequential(jpeg_src_buf->fmt))\n\t\tdesc->stm_ctrl |= STM_CTRL_PIXEL_PRECISION;\n\telse\n\t\tdesc->stm_ctrl &= ~STM_CTRL_PIXEL_PRECISION;\n\tdesc->line_pitch = q_data_cap->bytesperline[0];\n\tmxc_jpeg_addrs(desc, dst_buf, src_buf, 0);\n\tmxc_jpeg_set_bufsize(desc, ALIGN(vb2_plane_size(src_buf, 0), 1024));\n\tprint_descriptor_info(jpeg->dev, desc);\n\n\tif (!jpeg_src_buf->dht_needed) {\n\t\t \n\t\tmxc_jpeg_set_desc(desc_handle, reg, slot);\n\t\treturn;\n\t}\n\n\t \n\t*cfg_size = mxc_jpeg_setup_cfg_stream(cfg_stream_vaddr,\n\t\t\t\t\t      V4L2_PIX_FMT_YUYV,\n\t\t\t\t\t      MXC_JPEG_MIN_WIDTH,\n\t\t\t\t\t      MXC_JPEG_MIN_HEIGHT);\n\tcfg_desc->next_descpt_ptr = desc_handle | MXC_NXT_DESCPT_EN;\n\tcfg_desc->buf_base0 = vb2_dma_contig_plane_dma_addr(dst_buf, 0);\n\tcfg_desc->buf_base1 = 0;\n\tcfg_desc->imgsize = MXC_JPEG_MIN_WIDTH << 16;\n\tcfg_desc->imgsize |= MXC_JPEG_MIN_HEIGHT;\n\tcfg_desc->line_pitch = MXC_JPEG_MIN_WIDTH * 2;\n\tcfg_desc->stm_ctrl = STM_CTRL_IMAGE_FORMAT(MXC_JPEG_YUV422);\n\tcfg_desc->stm_ctrl |= STM_CTRL_BITBUF_PTR_CLR(1);\n\tcfg_desc->stm_bufbase = cfg_stream_handle;\n\tcfg_desc->stm_bufsize = ALIGN(*cfg_size, 1024);\n\tprint_descriptor_info(jpeg->dev, cfg_desc);\n\n\t \n\tmxc_jpeg_set_desc(cfg_desc_handle, reg, slot);\n}\n\nstatic void mxc_jpeg_config_enc_desc(struct vb2_buffer *out_buf,\n\t\t\t\t     struct mxc_jpeg_ctx *ctx,\n\t\t\t\t     struct vb2_buffer *src_buf,\n\t\t\t\t     struct vb2_buffer *dst_buf)\n{\n\tstruct mxc_jpeg_dev *jpeg = ctx->mxc_jpeg;\n\tvoid __iomem *reg = jpeg->base_reg;\n\tunsigned int slot = ctx->slot;\n\tstruct mxc_jpeg_desc *desc = jpeg->slot_data.desc;\n\tstruct mxc_jpeg_desc *cfg_desc = jpeg->slot_data.cfg_desc;\n\tdma_addr_t desc_handle = jpeg->slot_data.desc_handle;\n\tdma_addr_t cfg_desc_handle = jpeg->slot_data.cfg_desc_handle;\n\tvoid *cfg_stream_vaddr = jpeg->slot_data.cfg_stream_vaddr;\n\tstruct mxc_jpeg_q_data *q_data;\n\tenum mxc_jpeg_image_format img_fmt;\n\tint w, h;\n\n\tq_data = mxc_jpeg_get_q_data(ctx, src_buf->vb2_queue->type);\n\n\tjpeg->slot_data.cfg_stream_size =\n\t\t\tmxc_jpeg_setup_cfg_stream(cfg_stream_vaddr,\n\t\t\t\t\t\t  q_data->fmt->fourcc,\n\t\t\t\t\t\t  q_data->crop.width,\n\t\t\t\t\t\t  q_data->crop.height);\n\n\t \n\tcfg_desc->next_descpt_ptr = desc_handle | MXC_NXT_DESCPT_EN;\n\n\tcfg_desc->buf_base0 = jpeg->slot_data.cfg_stream_handle;\n\tcfg_desc->buf_base1 = 0;\n\tcfg_desc->line_pitch = 0;\n\tcfg_desc->stm_bufbase = 0;  \n\tcfg_desc->stm_bufsize = 0x0;\n\tcfg_desc->imgsize = 0;\n\tcfg_desc->stm_ctrl = STM_CTRL_CONFIG_MOD(1);\n\tcfg_desc->stm_ctrl |= STM_CTRL_BITBUF_PTR_CLR(1);\n\n\tdesc->next_descpt_ptr = 0;  \n\n\t \n\tw = q_data->crop.width;\n\th = q_data->crop.height;\n\tv4l_bound_align_image(&w, w, MXC_JPEG_MAX_WIDTH, q_data->fmt->h_align,\n\t\t\t      &h, h, MXC_JPEG_MAX_HEIGHT, q_data->fmt->v_align, 0);\n\tmxc_jpeg_set_res(desc, w, h);\n\tmxc_jpeg_set_line_pitch(desc, q_data->bytesperline[0]);\n\tmxc_jpeg_set_bufsize(desc, ALIGN(vb2_plane_size(dst_buf, 0), 1024));\n\timg_fmt = mxc_jpeg_fourcc_to_imgfmt(q_data->fmt->fourcc);\n\tif (img_fmt == MXC_JPEG_INVALID)\n\t\tdev_err(jpeg->dev, \"No valid image format detected\\n\");\n\tdesc->stm_ctrl = STM_CTRL_CONFIG_MOD(0) |\n\t\t\t STM_CTRL_IMAGE_FORMAT(img_fmt);\n\tdesc->stm_ctrl |= STM_CTRL_BITBUF_PTR_CLR(1);\n\tif (mxc_jpeg_is_extended_sequential(q_data->fmt))\n\t\tdesc->stm_ctrl |= STM_CTRL_PIXEL_PRECISION;\n\telse\n\t\tdesc->stm_ctrl &= ~STM_CTRL_PIXEL_PRECISION;\n\tmxc_jpeg_addrs(desc, src_buf, dst_buf, 0);\n\tdev_dbg(jpeg->dev, \"cfg_desc:\\n\");\n\tprint_descriptor_info(jpeg->dev, cfg_desc);\n\tdev_dbg(jpeg->dev, \"enc desc:\\n\");\n\tprint_descriptor_info(jpeg->dev, desc);\n\tprint_wrapper_info(jpeg->dev, reg);\n\tprint_cast_status(jpeg->dev, reg, MXC_JPEG_ENCODE);\n\n\t \n\tmxc_jpeg_set_desc(cfg_desc_handle, reg, slot);\n}\n\nstatic const struct mxc_jpeg_fmt *mxc_jpeg_get_sibling_format(const struct mxc_jpeg_fmt *fmt)\n{\n\tint i;\n\n\tfor (i = 0; i < MXC_JPEG_NUM_FORMATS; i++) {\n\t\tif (mxc_formats[i].subsampling == fmt->subsampling &&\n\t\t    mxc_formats[i].nc == fmt->nc &&\n\t\t    mxc_formats[i].precision == fmt->precision &&\n\t\t    mxc_formats[i].is_rgb == fmt->is_rgb &&\n\t\t    mxc_formats[i].fourcc != fmt->fourcc)\n\t\t\treturn &mxc_formats[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic bool mxc_jpeg_compare_format(const struct mxc_jpeg_fmt *fmt1,\n\t\t\t\t    const struct mxc_jpeg_fmt *fmt2)\n{\n\tif (fmt1 == fmt2)\n\t\treturn true;\n\tif (mxc_jpeg_get_sibling_format(fmt1) == fmt2)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void mxc_jpeg_set_last_buffer(struct mxc_jpeg_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *next_dst_buf;\n\n\tnext_dst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tif (!next_dst_buf) {\n\t\tctx->fh.m2m_ctx->is_draining = true;\n\t\tctx->fh.m2m_ctx->next_buf_last = true;\n\t\treturn;\n\t}\n\n\tv4l2_m2m_last_buffer_done(ctx->fh.m2m_ctx, next_dst_buf);\n}\n\nstatic bool mxc_jpeg_source_change(struct mxc_jpeg_ctx *ctx,\n\t\t\t\t   struct mxc_jpeg_src_buf *jpeg_src_buf)\n{\n\tstruct device *dev = ctx->mxc_jpeg->dev;\n\tstruct mxc_jpeg_q_data *q_data_cap;\n\n\tif (!jpeg_src_buf->fmt)\n\t\treturn false;\n\n\tq_data_cap = mxc_jpeg_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tif (mxc_jpeg_compare_format(q_data_cap->fmt, jpeg_src_buf->fmt))\n\t\tjpeg_src_buf->fmt = q_data_cap->fmt;\n\tif (ctx->need_initial_source_change_evt ||\n\t    q_data_cap->fmt != jpeg_src_buf->fmt ||\n\t    q_data_cap->w != jpeg_src_buf->w ||\n\t    q_data_cap->h != jpeg_src_buf->h) {\n\t\tdev_dbg(dev, \"Detected jpeg res=(%dx%d)->(%dx%d), pixfmt=%c%c%c%c\\n\",\n\t\t\tq_data_cap->w, q_data_cap->h,\n\t\t\tjpeg_src_buf->w, jpeg_src_buf->h,\n\t\t\t(jpeg_src_buf->fmt->fourcc & 0xff),\n\t\t\t(jpeg_src_buf->fmt->fourcc >>  8) & 0xff,\n\t\t\t(jpeg_src_buf->fmt->fourcc >> 16) & 0xff,\n\t\t\t(jpeg_src_buf->fmt->fourcc >> 24) & 0xff);\n\n\t\t \n\t\tq_data_cap->w = jpeg_src_buf->w;\n\t\tq_data_cap->h = jpeg_src_buf->h;\n\t\tq_data_cap->fmt = jpeg_src_buf->fmt;\n\t\tq_data_cap->w_adjusted = q_data_cap->w;\n\t\tq_data_cap->h_adjusted = q_data_cap->h;\n\t\tq_data_cap->crop.left = 0;\n\t\tq_data_cap->crop.top = 0;\n\t\tq_data_cap->crop.width = jpeg_src_buf->w;\n\t\tq_data_cap->crop.height = jpeg_src_buf->h;\n\n\t\t \n\t\tv4l_bound_align_image(&q_data_cap->w_adjusted,\n\t\t\t\t      q_data_cap->w_adjusted,   \n\t\t\t\t      MXC_JPEG_MAX_WIDTH,\n\t\t\t\t      q_data_cap->fmt->h_align,\n\t\t\t\t      &q_data_cap->h_adjusted,\n\t\t\t\t      q_data_cap->h_adjusted,  \n\t\t\t\t      MXC_JPEG_MAX_HEIGHT,\n\t\t\t\t      q_data_cap->fmt->v_align,\n\t\t\t\t      0);\n\n\t\t \n\t\tmxc_jpeg_bytesperline(q_data_cap, jpeg_src_buf->fmt->precision);\n\t\tmxc_jpeg_sizeimage(q_data_cap);\n\t\tnotify_src_chg(ctx);\n\t\tctx->source_change = 1;\n\t\tctx->need_initial_source_change_evt = false;\n\t\tif (vb2_is_streaming(v4l2_m2m_get_dst_vq(ctx->fh.m2m_ctx)))\n\t\t\tmxc_jpeg_set_last_buffer(ctx);\n\t}\n\n\treturn ctx->source_change ? true : false;\n}\n\nstatic int mxc_jpeg_job_ready(void *priv)\n{\n\tstruct mxc_jpeg_ctx *ctx = priv;\n\n\treturn ctx->source_change ? 0 : 1;\n}\n\nstatic void mxc_jpeg_device_run_timeout(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct mxc_jpeg_ctx *ctx = container_of(dwork, struct mxc_jpeg_ctx, task_timer);\n\tstruct mxc_jpeg_dev *jpeg = ctx->mxc_jpeg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->mxc_jpeg->hw_lock, flags);\n\tif (ctx->mxc_jpeg->slot_data.used) {\n\t\tdev_warn(jpeg->dev, \"%s timeout, cancel it\\n\",\n\t\t\t ctx->mxc_jpeg->mode == MXC_JPEG_DECODE ? \"decode\" : \"encode\");\n\t\tmxc_jpeg_job_finish(ctx, VB2_BUF_STATE_ERROR, true);\n\t\tv4l2_m2m_job_finish(ctx->mxc_jpeg->m2m_dev, ctx->fh.m2m_ctx);\n\t}\n\tspin_unlock_irqrestore(&ctx->mxc_jpeg->hw_lock, flags);\n}\n\nstatic void mxc_jpeg_device_run(void *priv)\n{\n\tstruct mxc_jpeg_ctx *ctx = priv;\n\tstruct mxc_jpeg_dev *jpeg = ctx->mxc_jpeg;\n\tvoid __iomem *reg = jpeg->base_reg;\n\tstruct device *dev = jpeg->dev;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tunsigned long flags;\n\tstruct mxc_jpeg_q_data *q_data_cap, *q_data_out;\n\tstruct mxc_jpeg_src_buf *jpeg_src_buf;\n\n\tspin_lock_irqsave(&ctx->mxc_jpeg->hw_lock, flags);\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tif (!src_buf || !dst_buf) {\n\t\tdev_err(dev, \"Null src or dst buf\\n\");\n\t\tgoto end;\n\t}\n\n\tq_data_cap = mxc_jpeg_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tif (!q_data_cap)\n\t\tgoto end;\n\tq_data_out = mxc_jpeg_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tif (!q_data_out)\n\t\tgoto end;\n\tsrc_buf->sequence = q_data_out->sequence++;\n\tdst_buf->sequence = q_data_cap->sequence++;\n\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, true);\n\n\tjpeg_src_buf = vb2_to_mxc_buf(&src_buf->vb2_buf);\n\tif (q_data_cap->fmt->mem_planes != dst_buf->vb2_buf.num_planes) {\n\t\tdev_err(dev, \"Capture format %s has %d planes, but capture buffer has %d planes\\n\",\n\t\t\tq_data_cap->fmt->name, q_data_cap->fmt->mem_planes,\n\t\t\tdst_buf->vb2_buf.num_planes);\n\t\tjpeg_src_buf->jpeg_parse_error = true;\n\t}\n\tif (jpeg_src_buf->jpeg_parse_error) {\n\t\tmxc_jpeg_check_and_set_last_buffer(ctx, src_buf, dst_buf);\n\t\tv4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\tv4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\n\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\n\t\tspin_unlock_irqrestore(&ctx->mxc_jpeg->hw_lock, flags);\n\t\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n\n\t\treturn;\n\t}\n\tif (ctx->mxc_jpeg->mode == MXC_JPEG_DECODE) {\n\t\tif (ctx->source_change || mxc_jpeg_source_change(ctx, jpeg_src_buf)) {\n\t\t\tspin_unlock_irqrestore(&ctx->mxc_jpeg->hw_lock, flags);\n\t\t\tv4l2_m2m_job_finish(jpeg->m2m_dev, ctx->fh.m2m_ctx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmxc_jpeg_enable(reg);\n\tmxc_jpeg_set_l_endian(reg, 1);\n\n\tctx->slot = mxc_get_free_slot(&jpeg->slot_data);\n\tif (ctx->slot < 0) {\n\t\tdev_err(dev, \"No more free slots\\n\");\n\t\tgoto end;\n\t}\n\tif (!mxc_jpeg_alloc_slot_data(jpeg)) {\n\t\tdev_err(dev, \"Cannot allocate slot data\\n\");\n\t\tgoto end;\n\t}\n\n\tmxc_jpeg_enable_slot(reg, ctx->slot);\n\tmxc_jpeg_enable_irq(reg, ctx->slot);\n\n\tif (jpeg->mode == MXC_JPEG_ENCODE) {\n\t\tdev_dbg(dev, \"Encoding on slot %d\\n\", ctx->slot);\n\t\tctx->enc_state = MXC_JPEG_ENC_CONF;\n\t\tmxc_jpeg_config_enc_desc(&dst_buf->vb2_buf, ctx,\n\t\t\t\t\t &src_buf->vb2_buf, &dst_buf->vb2_buf);\n\t\t \n\t\tmxc_jpeg_enc_mode_conf(dev, reg,\n\t\t\t\t       mxc_jpeg_is_extended_sequential(q_data_out->fmt));\n\t} else {\n\t\tdev_dbg(dev, \"Decoding on slot %d\\n\", ctx->slot);\n\t\tprint_mxc_buf(jpeg, &src_buf->vb2_buf, 0);\n\t\tmxc_jpeg_config_dec_desc(&dst_buf->vb2_buf, ctx,\n\t\t\t\t\t &src_buf->vb2_buf, &dst_buf->vb2_buf);\n\t\tmxc_jpeg_dec_mode_go(dev, reg);\n\t}\n\tschedule_delayed_work(&ctx->task_timer, msecs_to_jiffies(hw_timeout));\nend:\n\tspin_unlock_irqrestore(&ctx->mxc_jpeg->hw_lock, flags);\n}\n\nstatic int mxc_jpeg_decoder_cmd(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_decoder_cmd *cmd)\n{\n\tstruct v4l2_fh *fh = file->private_data;\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(fh);\n\tunsigned long flags;\n\tint ret;\n\n\tret = v4l2_m2m_ioctl_try_decoder_cmd(file, fh, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!vb2_is_streaming(v4l2_m2m_get_src_vq(fh->m2m_ctx)))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&ctx->mxc_jpeg->hw_lock, flags);\n\tret = v4l2_m2m_ioctl_decoder_cmd(file, priv, cmd);\n\tspin_unlock_irqrestore(&ctx->mxc_jpeg->hw_lock, flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cmd->cmd == V4L2_DEC_CMD_STOP &&\n\t    v4l2_m2m_has_stopped(fh->m2m_ctx)) {\n\t\tnotify_eos(ctx);\n\t\tctx->header_parsed = false;\n\t}\n\n\tif (cmd->cmd == V4L2_DEC_CMD_START &&\n\t    v4l2_m2m_has_stopped(fh->m2m_ctx))\n\t\tvb2_clear_last_buffer_dequeued(&fh->m2m_ctx->cap_q_ctx.q);\n\treturn 0;\n}\n\nstatic int mxc_jpeg_encoder_cmd(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_encoder_cmd *cmd)\n{\n\tstruct v4l2_fh *fh = file->private_data;\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(fh);\n\tunsigned long flags;\n\tint ret;\n\n\tret = v4l2_m2m_ioctl_try_encoder_cmd(file, fh, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!vb2_is_streaming(v4l2_m2m_get_src_vq(fh->m2m_ctx)) ||\n\t    !vb2_is_streaming(v4l2_m2m_get_dst_vq(fh->m2m_ctx)))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&ctx->mxc_jpeg->hw_lock, flags);\n\tret = v4l2_m2m_ioctl_encoder_cmd(file, fh, cmd);\n\tspin_unlock_irqrestore(&ctx->mxc_jpeg->hw_lock, flags);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (cmd->cmd == V4L2_ENC_CMD_STOP &&\n\t    v4l2_m2m_has_stopped(fh->m2m_ctx))\n\t\tnotify_eos(ctx);\n\n\tif (cmd->cmd == V4L2_ENC_CMD_START &&\n\t    v4l2_m2m_has_stopped(fh->m2m_ctx))\n\t\tvb2_clear_last_buffer_dequeued(&fh->m2m_ctx->cap_q_ctx.q);\n\n\treturn 0;\n}\n\nstatic int mxc_jpeg_queue_setup(struct vb2_queue *q,\n\t\t\t\tunsigned int *nbuffers,\n\t\t\t\tunsigned int *nplanes,\n\t\t\t\tunsigned int sizes[],\n\t\t\t\tstruct device *alloc_ctxs[])\n{\n\tstruct mxc_jpeg_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct mxc_jpeg_q_data *q_data = NULL;\n\tint i;\n\n\tq_data = mxc_jpeg_get_q_data(ctx, q->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\t \n\tif (*nplanes) {\n\t\tif (*nplanes != q_data->fmt->mem_planes)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < *nplanes; i++) {\n\t\t\tif (sizes[i] < mxc_jpeg_get_plane_size(q_data, i))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\t*nplanes = q_data->fmt->mem_planes;\n\tfor (i = 0; i < *nplanes; i++)\n\t\tsizes[i] = mxc_jpeg_get_plane_size(q_data, i);\n\n\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\tctx->need_initial_source_change_evt = true;\n\n\treturn 0;\n}\n\nstatic int mxc_jpeg_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct mxc_jpeg_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct mxc_jpeg_q_data *q_data = mxc_jpeg_get_q_data(ctx, q->type);\n\tint ret;\n\n\tv4l2_m2m_update_start_streaming_state(ctx->fh.m2m_ctx, q);\n\n\tif (ctx->mxc_jpeg->mode == MXC_JPEG_DECODE && V4L2_TYPE_IS_CAPTURE(q->type))\n\t\tctx->source_change = 0;\n\tdev_dbg(ctx->mxc_jpeg->dev, \"Start streaming ctx=%p\", ctx);\n\tq_data->sequence = 0;\n\n\tret = pm_runtime_resume_and_get(ctx->mxc_jpeg->dev);\n\tif (ret < 0) {\n\t\tdev_err(ctx->mxc_jpeg->dev, \"Failed to power up jpeg\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void mxc_jpeg_stop_streaming(struct vb2_queue *q)\n{\n\tstruct mxc_jpeg_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tdev_dbg(ctx->mxc_jpeg->dev, \"Stop streaming ctx=%p\", ctx);\n\n\t \n\tfor (;;) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (!vbuf)\n\t\t\tbreak;\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t}\n\n\tv4l2_m2m_update_stop_streaming_state(ctx->fh.m2m_ctx, q);\n\t \n\tif (V4L2_TYPE_IS_CAPTURE(q->type) && ctx->source_change && ctx->fh.m2m_ctx->last_src_buf)\n\t\tctx->fh.m2m_ctx->is_draining = true;\n\n\tif (V4L2_TYPE_IS_OUTPUT(q->type) &&\n\t    v4l2_m2m_has_stopped(ctx->fh.m2m_ctx)) {\n\t\tnotify_eos(ctx);\n\t\tctx->header_parsed = false;\n\t}\n\n\tpm_runtime_put_sync(&ctx->mxc_jpeg->pdev->dev);\n}\n\nstatic int mxc_jpeg_valid_comp_id(struct device *dev,\n\t\t\t\t  struct mxc_jpeg_sof *sof,\n\t\t\t\t  struct mxc_jpeg_sos *sos)\n{\n\tint valid = 1;\n\tint i;\n\n\t \n\tfor (i = 0; i < sof->components_no; i++)\n\t\tif (sof->comp[i].id > MXC_JPEG_MAX_COMPONENTS) {\n\t\t\tvalid = 0;\n\t\t\tdev_err(dev, \"Component %d has invalid ID: %d\",\n\t\t\t\ti, sof->comp[i].id);\n\t\t}\n\tif (!valid)\n\t\t \n\t\tfor (i = 0; i < sof->components_no; i++) {\n\t\t\tdev_warn(dev, \"Component %d ID patched to: %d\",\n\t\t\t\t i, i + 1);\n\t\t\tsof->comp[i].id = i + 1;\n\t\t\tsos->comp[i].id = i + 1;\n\t\t}\n\n\treturn valid;\n}\n\nstatic bool mxc_jpeg_match_image_format(const struct mxc_jpeg_fmt *fmt,\n\t\t\t\t\tconst struct v4l2_jpeg_header *header)\n{\n\tif (fmt->subsampling != header->frame.subsampling ||\n\t    fmt->nc != header->frame.num_components ||\n\t    fmt->precision != header->frame.precision)\n\t\treturn false;\n\n\t \n\tif (header->frame.subsampling == V4L2_JPEG_CHROMA_SUBSAMPLING_444) {\n\t\tu8 is_rgb = header->app14_tf == V4L2_JPEG_APP14_TF_CMYK_RGB ? 1 : 0;\n\n\t\tif (is_rgb != fmt->is_rgb)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic u32 mxc_jpeg_get_image_format(struct device *dev,\n\t\t\t\t     const struct v4l2_jpeg_header *header)\n{\n\tint i;\n\tu32 fourcc = 0;\n\n\tfor (i = 0; i < MXC_JPEG_NUM_FORMATS; i++) {\n\t\tif (mxc_jpeg_match_image_format(&mxc_formats[i], header)) {\n\t\t\tfourcc = mxc_formats[i].fourcc;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fourcc == 0) {\n\t\tdev_err(dev,\n\t\t\t\"Could not identify image format nc=%d, subsampling=%d, precision=%d\\n\",\n\t\t\theader->frame.num_components,\n\t\t\theader->frame.subsampling,\n\t\t\theader->frame.precision);\n\t\treturn fourcc;\n\t}\n\n\treturn fourcc;\n}\n\nstatic void mxc_jpeg_bytesperline(struct mxc_jpeg_q_data *q, u32 precision)\n{\n\t \n\tif (q->fmt->fourcc == V4L2_PIX_FMT_JPEG) {\n\t\t \n\t\tq->bytesperline[0] = 0;\n\t\tq->bytesperline[1] = 0;\n\t} else if (q->fmt->subsampling == V4L2_JPEG_CHROMA_SUBSAMPLING_420) {\n\t\t \n\t\tq->bytesperline[0] = q->w_adjusted * DIV_ROUND_UP(precision, 8);\n\t\tq->bytesperline[1] = q->bytesperline[0];\n\t} else if (q->fmt->subsampling == V4L2_JPEG_CHROMA_SUBSAMPLING_422) {\n\t\tq->bytesperline[0] = q->w_adjusted * DIV_ROUND_UP(precision, 8) * 2;\n\t\tq->bytesperline[1] = 0;\n\t} else if (q->fmt->subsampling == V4L2_JPEG_CHROMA_SUBSAMPLING_444) {\n\t\tq->bytesperline[0] = q->w_adjusted * DIV_ROUND_UP(precision, 8) * q->fmt->nc;\n\t\tq->bytesperline[1] = 0;\n\t} else {\n\t\t \n\t\tq->bytesperline[0] = q->w_adjusted * DIV_ROUND_UP(precision, 8);\n\t\tq->bytesperline[1] = 0;\n\t}\n}\n\nstatic void mxc_jpeg_sizeimage(struct mxc_jpeg_q_data *q)\n{\n\tif (q->fmt->fourcc == V4L2_PIX_FMT_JPEG) {\n\t\t \n\t\tif (!q->sizeimage[0])\n\t\t\tq->sizeimage[0] = 6 * q->w * q->h;\n\t\tq->sizeimage[1] = 0;\n\n\t\tif (q->sizeimage[0] > MXC_JPEG_MAX_SIZEIMAGE)\n\t\t\tq->sizeimage[0] = MXC_JPEG_MAX_SIZEIMAGE;\n\n\t\t \n\t\tq->sizeimage[0] = ALIGN(q->sizeimage[0], 1024);\n\t} else {\n\t\tq->sizeimage[0] = q->bytesperline[0] * q->h_adjusted;\n\t\tq->sizeimage[1] = 0;\n\t\tif (q->fmt->subsampling == V4L2_JPEG_CHROMA_SUBSAMPLING_420)\n\t\t\tq->sizeimage[1] = q->sizeimage[0] / 2;\n\t}\n}\n\nstatic int mxc_jpeg_parse(struct mxc_jpeg_ctx *ctx, struct vb2_buffer *vb)\n{\n\tstruct device *dev = ctx->mxc_jpeg->dev;\n\tstruct mxc_jpeg_q_data *q_data_out;\n\tstruct mxc_jpeg_q_data *q_data_cap;\n\tu32 fourcc;\n\tstruct v4l2_jpeg_header header;\n\tstruct mxc_jpeg_sof *psof = NULL;\n\tstruct mxc_jpeg_sos *psos = NULL;\n\tstruct mxc_jpeg_src_buf *jpeg_src_buf = vb2_to_mxc_buf(vb);\n\tu8 *src_addr = (u8 *)vb2_plane_vaddr(vb, 0);\n\tu32 size = vb2_get_plane_payload(vb, 0);\n\tint ret;\n\n\tmemset(&header, 0, sizeof(header));\n\tret = v4l2_jpeg_parse_header((void *)src_addr, size, &header);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error parsing JPEG stream markers\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tjpeg_src_buf->dht_needed = (header.num_dht == 0);\n\n\tq_data_out = mxc_jpeg_get_q_data(ctx,\n\t\t\t\t\t V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\tif (q_data_out->w == 0 && q_data_out->h == 0) {\n\t\tdev_warn(dev, \"Invalid user resolution 0x0\");\n\t\tdev_warn(dev, \"Keeping resolution from JPEG: %dx%d\",\n\t\t\t header.frame.width, header.frame.height);\n\t} else if (header.frame.width != q_data_out->w ||\n\t\t   header.frame.height != q_data_out->h) {\n\t\tdev_err(dev,\n\t\t\t\"Resolution mismatch: %dx%d (JPEG) versus %dx%d(user)\",\n\t\t\theader.frame.width, header.frame.height,\n\t\t\tq_data_out->w, q_data_out->h);\n\t}\n\tq_data_out->w = header.frame.width;\n\tq_data_out->h = header.frame.height;\n\tif (header.frame.width > MXC_JPEG_MAX_WIDTH ||\n\t    header.frame.height > MXC_JPEG_MAX_HEIGHT) {\n\t\tdev_err(dev, \"JPEG width or height should be <= 8192: %dx%d\\n\",\n\t\t\theader.frame.width, header.frame.height);\n\t\treturn -EINVAL;\n\t}\n\tif (header.frame.width < MXC_JPEG_MIN_WIDTH ||\n\t    header.frame.height < MXC_JPEG_MIN_HEIGHT) {\n\t\tdev_err(dev, \"JPEG width or height should be > 64: %dx%d\\n\",\n\t\t\theader.frame.width, header.frame.height);\n\t\treturn -EINVAL;\n\t}\n\tif (header.frame.num_components > V4L2_JPEG_MAX_COMPONENTS) {\n\t\tdev_err(dev, \"JPEG number of components should be <=%d\",\n\t\t\tV4L2_JPEG_MAX_COMPONENTS);\n\t\treturn -EINVAL;\n\t}\n\t \n\tpsof = (struct mxc_jpeg_sof *)header.sof.start;\n\tpsos = (struct mxc_jpeg_sos *)header.sos.start;\n\tif (!mxc_jpeg_valid_comp_id(dev, psof, psos))\n\t\tdev_warn(dev, \"JPEG component ids should be 0-3 or 1-4\");\n\n\tq_data_cap = mxc_jpeg_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (q_data_cap->fmt && mxc_jpeg_match_image_format(q_data_cap->fmt, &header))\n\t\tfourcc = q_data_cap->fmt->fourcc;\n\telse\n\t\tfourcc = mxc_jpeg_get_image_format(dev, &header);\n\tif (fourcc == 0)\n\t\treturn -EINVAL;\n\n\tjpeg_src_buf->fmt = mxc_jpeg_find_format(fourcc);\n\tjpeg_src_buf->w = header.frame.width;\n\tjpeg_src_buf->h = header.frame.height;\n\tctx->header_parsed = true;\n\n\tif (!v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx))\n\t\tmxc_jpeg_source_change(ctx, jpeg_src_buf);\n\n\treturn 0;\n}\n\nstatic void mxc_jpeg_buf_queue(struct vb2_buffer *vb)\n{\n\tint ret;\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct mxc_jpeg_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct mxc_jpeg_src_buf *jpeg_src_buf;\n\n\tif (V4L2_TYPE_IS_CAPTURE(vb->vb2_queue->type) &&\n\t    vb2_is_streaming(vb->vb2_queue) &&\n\t    v4l2_m2m_dst_buf_is_last(ctx->fh.m2m_ctx)) {\n\t\tstruct mxc_jpeg_q_data *q_data;\n\n\t\tq_data = mxc_jpeg_get_q_data(ctx, vb->vb2_queue->type);\n\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tvbuf->sequence = q_data->sequence++;\n\t\tv4l2_m2m_last_buffer_done(ctx->fh.m2m_ctx, vbuf);\n\t\tnotify_eos(ctx);\n\t\tctx->header_parsed = false;\n\t\treturn;\n\t}\n\n\tif (vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tgoto end;\n\n\t \n\tif (ctx->mxc_jpeg->mode != MXC_JPEG_DECODE)\n\t\tgoto end;\n\n\tjpeg_src_buf = vb2_to_mxc_buf(vb);\n\tjpeg_src_buf->jpeg_parse_error = false;\n\tret = mxc_jpeg_parse(ctx, vb);\n\tif (ret)\n\t\tjpeg_src_buf->jpeg_parse_error = true;\n\nend:\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int mxc_jpeg_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\n\treturn 0;\n}\n\nstatic int mxc_jpeg_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct mxc_jpeg_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct mxc_jpeg_q_data *q_data = NULL;\n\tstruct device *dev = ctx->mxc_jpeg->dev;\n\tunsigned long sizeimage;\n\tint i;\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\n\tq_data = mxc_jpeg_get_q_data(ctx, vb->vb2_queue->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < q_data->fmt->mem_planes; i++) {\n\t\tsizeimage = mxc_jpeg_get_plane_size(q_data, i);\n\t\tif (!ctx->source_change && vb2_plane_size(vb, i) < sizeimage) {\n\t\t\tdev_err(dev, \"plane %d too small (%lu < %lu)\",\n\t\t\t\ti, vb2_plane_size(vb, i), sizeimage);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (V4L2_TYPE_IS_CAPTURE(vb->vb2_queue->type)) {\n\t\tvb2_set_plane_payload(vb, 0, 0);\n\t\tvb2_set_plane_payload(vb, 1, 0);\n\t}\n\treturn 0;\n}\n\nstatic const struct vb2_ops mxc_jpeg_qops = {\n\t.queue_setup\t\t= mxc_jpeg_queue_setup,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n\t.buf_out_validate\t= mxc_jpeg_buf_out_validate,\n\t.buf_prepare\t\t= mxc_jpeg_buf_prepare,\n\t.start_streaming\t= mxc_jpeg_start_streaming,\n\t.stop_streaming\t\t= mxc_jpeg_stop_streaming,\n\t.buf_queue\t\t= mxc_jpeg_buf_queue,\n};\n\nstatic int mxc_jpeg_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t       struct vb2_queue *dst_vq)\n{\n\tstruct mxc_jpeg_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->buf_struct_size = sizeof(struct mxc_jpeg_src_buf);\n\tsrc_vq->ops = &mxc_jpeg_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->mxc_jpeg->lock;\n\tsrc_vq->dev = ctx->mxc_jpeg->dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->ops = &mxc_jpeg_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->mxc_jpeg->lock;\n\tdst_vq->dev = ctx->mxc_jpeg->dev;\n\n\tret = vb2_queue_init(dst_vq);\n\treturn ret;\n}\n\nstatic void mxc_jpeg_set_default_params(struct mxc_jpeg_ctx *ctx)\n{\n\tstruct mxc_jpeg_q_data *out_q = &ctx->out_q;\n\tstruct mxc_jpeg_q_data *cap_q = &ctx->cap_q;\n\tstruct mxc_jpeg_q_data *q[2] = {out_q, cap_q};\n\tint i;\n\n\tif (ctx->mxc_jpeg->mode == MXC_JPEG_ENCODE) {\n\t\tout_q->fmt = mxc_jpeg_find_format(MXC_JPEG_DEFAULT_PFMT);\n\t\tcap_q->fmt = mxc_jpeg_find_format(V4L2_PIX_FMT_JPEG);\n\t} else {\n\t\tout_q->fmt = mxc_jpeg_find_format(V4L2_PIX_FMT_JPEG);\n\t\tcap_q->fmt = mxc_jpeg_find_format(MXC_JPEG_DEFAULT_PFMT);\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tq[i]->w = MXC_JPEG_DEFAULT_WIDTH;\n\t\tq[i]->h = MXC_JPEG_DEFAULT_HEIGHT;\n\t\tq[i]->w_adjusted = MXC_JPEG_DEFAULT_WIDTH;\n\t\tq[i]->h_adjusted = MXC_JPEG_DEFAULT_HEIGHT;\n\t\tq[i]->crop.left = 0;\n\t\tq[i]->crop.top = 0;\n\t\tq[i]->crop.width = MXC_JPEG_DEFAULT_WIDTH;\n\t\tq[i]->crop.height = MXC_JPEG_DEFAULT_HEIGHT;\n\t\tmxc_jpeg_bytesperline(q[i], q[i]->fmt->precision);\n\t\tmxc_jpeg_sizeimage(q[i]);\n\t}\n}\n\nstatic int mxc_jpeg_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct mxc_jpeg_ctx *ctx =\n\t\tcontainer_of(ctrl->handler, struct mxc_jpeg_ctx, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\tctx->jpeg_quality = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ctx->mxc_jpeg->dev, \"Invalid control, id = %d, val = %d\\n\",\n\t\t\tctrl->id, ctrl->val);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops mxc_jpeg_ctrl_ops = {\n\t.s_ctrl = mxc_jpeg_s_ctrl,\n};\n\nstatic void mxc_jpeg_encode_ctrls(struct mxc_jpeg_ctx *ctx)\n{\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &mxc_jpeg_ctrl_ops,\n\t\t\t  V4L2_CID_JPEG_COMPRESSION_QUALITY, 1, 100, 1, 75);\n}\n\nstatic int mxc_jpeg_ctrls_setup(struct mxc_jpeg_ctx *ctx)\n{\n\tint err;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, 2);\n\n\tif (ctx->mxc_jpeg->mode == MXC_JPEG_ENCODE)\n\t\tmxc_jpeg_encode_ctrls(ctx);\n\n\tif (ctx->ctrl_handler.error) {\n\t\terr = ctx->ctrl_handler.error;\n\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\t\treturn err;\n\t}\n\n\terr = v4l2_ctrl_handler_setup(&ctx->ctrl_handler);\n\tif (err)\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\treturn err;\n}\n\nstatic int mxc_jpeg_open(struct file *file)\n{\n\tstruct mxc_jpeg_dev *mxc_jpeg = video_drvdata(file);\n\tstruct video_device *mxc_vfd = video_devdata(file);\n\tstruct device *dev = mxc_jpeg->dev;\n\tstruct mxc_jpeg_ctx *ctx;\n\tint ret = 0;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (mutex_lock_interruptible(&mxc_jpeg->lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free;\n\t}\n\n\tv4l2_fh_init(&ctx->fh, mxc_vfd);\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\tctx->mxc_jpeg = mxc_jpeg;\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(mxc_jpeg->m2m_dev, ctx,\n\t\t\t\t\t    mxc_jpeg_queue_init);\n\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto error;\n\t}\n\n\tret = mxc_jpeg_ctrls_setup(ctx);\n\tif (ret) {\n\t\tdev_err(ctx->mxc_jpeg->dev, \"failed to setup mxc jpeg controls\\n\");\n\t\tgoto err_ctrls_setup;\n\t}\n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\tmxc_jpeg_set_default_params(ctx);\n\tctx->slot = -1;  \n\tINIT_DELAYED_WORK(&ctx->task_timer, mxc_jpeg_device_run_timeout);\n\n\tif (mxc_jpeg->mode == MXC_JPEG_DECODE)\n\t\tdev_dbg(dev, \"Opened JPEG decoder instance %p\\n\", ctx);\n\telse\n\t\tdev_dbg(dev, \"Opened JPEG encoder instance %p\\n\", ctx);\n\tmutex_unlock(&mxc_jpeg->lock);\n\n\treturn 0;\n\nerr_ctrls_setup:\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\nerror:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tmutex_unlock(&mxc_jpeg->lock);\nfree:\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic int mxc_jpeg_querycap(struct file *file, void *priv,\n\t\t\t     struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, MXC_JPEG_NAME \" codec\", sizeof(cap->driver));\n\tstrscpy(cap->card, MXC_JPEG_NAME \" codec\", sizeof(cap->card));\n\tcap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE;\n\tcap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\n\n\treturn 0;\n}\n\nstatic int mxc_jpeg_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_fmtdesc *f)\n{\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(priv);\n\tstruct mxc_jpeg_q_data *q_data = mxc_jpeg_get_q_data(ctx, f->type);\n\n\tif (ctx->mxc_jpeg->mode == MXC_JPEG_ENCODE) {\n\t\treturn enum_fmt(mxc_formats, MXC_JPEG_NUM_FORMATS, f,\n\t\t\tMXC_JPEG_FMT_TYPE_ENC);\n\t} else if (!ctx->header_parsed) {\n\t\treturn enum_fmt(mxc_formats, MXC_JPEG_NUM_FORMATS, f,\n\t\t\tMXC_JPEG_FMT_TYPE_RAW);\n\t} else {\n\t\t \n\t\tint ret = -EINVAL;\n\t\tconst struct mxc_jpeg_fmt *sibling;\n\n\t\tswitch (f->index) {\n\t\tcase 0:\n\t\t\tf->pixelformat = q_data->fmt->fourcc;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tsibling = mxc_jpeg_get_sibling_format(q_data->fmt);\n\t\t\tif (sibling) {\n\t\t\t\tf->pixelformat = sibling->fourcc;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nstatic int mxc_jpeg_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_fmtdesc *f)\n{\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(priv);\n\tu32 type = ctx->mxc_jpeg->mode == MXC_JPEG_DECODE ?  MXC_JPEG_FMT_TYPE_ENC :\n\t\t\t\t\t\t\t     MXC_JPEG_FMT_TYPE_RAW;\n\tint ret;\n\n\tret = enum_fmt(mxc_formats, MXC_JPEG_NUM_FORMATS, f, type);\n\tif (ret)\n\t\treturn ret;\n\tif (ctx->mxc_jpeg->mode == MXC_JPEG_DECODE)\n\t\tf->flags = V4L2_FMT_FLAG_DYN_RESOLUTION;\n\treturn 0;\n}\n\nstatic u32 mxc_jpeg_get_fmt_type(struct mxc_jpeg_ctx *ctx, u32 type)\n{\n\tif (ctx->mxc_jpeg->mode == MXC_JPEG_DECODE)\n\t\treturn V4L2_TYPE_IS_OUTPUT(type) ? MXC_JPEG_FMT_TYPE_ENC : MXC_JPEG_FMT_TYPE_RAW;\n\telse\n\t\treturn V4L2_TYPE_IS_CAPTURE(type) ? MXC_JPEG_FMT_TYPE_ENC : MXC_JPEG_FMT_TYPE_RAW;\n}\n\nstatic u32 mxc_jpeg_get_default_fourcc(struct mxc_jpeg_ctx *ctx, u32 type)\n{\n\tif (ctx->mxc_jpeg->mode == MXC_JPEG_DECODE)\n\t\treturn V4L2_TYPE_IS_OUTPUT(type) ? V4L2_PIX_FMT_JPEG : MXC_JPEG_DEFAULT_PFMT;\n\telse\n\t\treturn V4L2_TYPE_IS_CAPTURE(type) ? V4L2_PIX_FMT_JPEG : MXC_JPEG_DEFAULT_PFMT;\n}\n\nstatic u32 mxc_jpeg_try_fourcc(struct mxc_jpeg_ctx *ctx, u32 fourcc)\n{\n\tconst struct mxc_jpeg_fmt *sibling;\n\tstruct mxc_jpeg_q_data *q_data_cap;\n\n\tif (ctx->mxc_jpeg->mode != MXC_JPEG_DECODE)\n\t\treturn fourcc;\n\tif (!ctx->header_parsed)\n\t\treturn fourcc;\n\n\tq_data_cap = &ctx->cap_q;\n\tif (q_data_cap->fmt->fourcc == fourcc)\n\t\treturn fourcc;\n\n\tsibling = mxc_jpeg_get_sibling_format(q_data_cap->fmt);\n\tif (sibling && sibling->fourcc == fourcc)\n\t\treturn sibling->fourcc;\n\n\treturn q_data_cap->fmt->fourcc;\n}\n\nstatic int mxc_jpeg_try_fmt(struct v4l2_format *f,\n\t\t\t    struct mxc_jpeg_ctx *ctx, struct mxc_jpeg_q_data *q_data)\n{\n\tconst struct mxc_jpeg_fmt *fmt;\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tstruct v4l2_plane_pix_format *pfmt;\n\tu32 fourcc = f->fmt.pix_mp.pixelformat;\n\tu32 w = (pix_mp->width < MXC_JPEG_MAX_WIDTH) ?\n\t\t pix_mp->width : MXC_JPEG_MAX_WIDTH;\n\tu32 h = (pix_mp->height < MXC_JPEG_MAX_HEIGHT) ?\n\t\t pix_mp->height : MXC_JPEG_MAX_HEIGHT;\n\tint i;\n\n\tfmt = mxc_jpeg_find_format(fourcc);\n\tif (!fmt || fmt->flags != mxc_jpeg_get_fmt_type(ctx, f->type)) {\n\t\tdev_warn(ctx->mxc_jpeg->dev, \"Format not supported: %c%c%c%c, use the default.\\n\",\n\t\t\t (fourcc & 0xff),\n\t\t\t (fourcc >>  8) & 0xff,\n\t\t\t (fourcc >> 16) & 0xff,\n\t\t\t (fourcc >> 24) & 0xff);\n\t\tfourcc = mxc_jpeg_get_default_fourcc(ctx, f->type);\n\t\tfmt = mxc_jpeg_find_format(fourcc);\n\t\tif (!fmt)\n\t\t\treturn -EINVAL;\n\t\tf->fmt.pix_mp.pixelformat = fourcc;\n\t}\n\tq_data->fmt = fmt;\n\n\tmemset(pix_mp->reserved, 0, sizeof(pix_mp->reserved));\n\tpix_mp->field = V4L2_FIELD_NONE;\n\tpix_mp->num_planes = fmt->mem_planes;\n\tpix_mp->pixelformat = fmt->fourcc;\n\n\tq_data->w = w;\n\tq_data->h = h;\n\tq_data->w_adjusted = w;\n\tq_data->h_adjusted = h;\n\tv4l_bound_align_image(&q_data->w_adjusted,\n\t\t\t      w,  \n\t\t\t      MXC_JPEG_MAX_WIDTH,\n\t\t\t      fmt->h_align,\n\t\t\t      &q_data->h_adjusted,\n\t\t\t      h,  \n\t\t\t      MXC_JPEG_MAX_HEIGHT,\n\t\t\t      fmt->v_align,\n\t\t\t      0);\n\tfor (i = 0; i < pix_mp->num_planes; i++) {\n\t\tpfmt = &pix_mp->plane_fmt[i];\n\t\tq_data->bytesperline[i] = pfmt->bytesperline;\n\t\tq_data->sizeimage[i] = pfmt->sizeimage;\n\t}\n\n\t \n\tmxc_jpeg_bytesperline(q_data, fmt->precision);\n\tmxc_jpeg_sizeimage(q_data);\n\n\t \n\tfor (i = 0; i < pix_mp->num_planes; i++) {\n\t\tpfmt = &pix_mp->plane_fmt[i];\n\t\tmemset(pfmt->reserved, 0, sizeof(pfmt->reserved));\n\t\tpfmt->bytesperline = q_data->bytesperline[i];\n\t\tpfmt->sizeimage = mxc_jpeg_get_plane_size(q_data, i);\n\t}\n\n\t \n\tpix_mp->colorspace = V4L2_COLORSPACE_SRGB;\n\tpix_mp->ycbcr_enc = V4L2_YCBCR_ENC_601;\n\tpix_mp->xfer_func = V4L2_XFER_FUNC_SRGB;\n\t \n\tpix_mp->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\n\tif (fmt->flags == MXC_JPEG_FMT_TYPE_RAW) {\n\t\tq_data->crop.left = 0;\n\t\tq_data->crop.top = 0;\n\t\tq_data->crop.width = q_data->w;\n\t\tq_data->crop.height = q_data->h;\n\t}\n\n\tpix_mp->width = q_data->w_adjusted;\n\tpix_mp->height = q_data->h_adjusted;\n\n\treturn 0;\n}\n\nstatic int mxc_jpeg_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(priv);\n\tstruct mxc_jpeg_dev *jpeg = ctx->mxc_jpeg;\n\tstruct device *dev = jpeg->dev;\n\tstruct mxc_jpeg_q_data tmp_q;\n\n\tif (!V4L2_TYPE_IS_MULTIPLANAR(f->type)) {\n\t\tdev_err(dev, \"TRY_FMT with Invalid type: %d\\n\", f->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->mxc_jpeg->mode != MXC_JPEG_DECODE && V4L2_TYPE_IS_CAPTURE(f->type))\n\t\tf->fmt.pix_mp.pixelformat = mxc_jpeg_try_fourcc(ctx, f->fmt.pix_mp.pixelformat);\n\n\treturn mxc_jpeg_try_fmt(f, ctx, &tmp_q);\n}\n\nstatic int mxc_jpeg_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(priv);\n\tstruct mxc_jpeg_dev *jpeg = ctx->mxc_jpeg;\n\tstruct device *dev = jpeg->dev;\n\tstruct mxc_jpeg_q_data tmp_q;\n\n\tif (!V4L2_TYPE_IS_MULTIPLANAR(f->type)) {\n\t\tdev_err(dev, \"TRY_FMT with Invalid type: %d\\n\", f->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn mxc_jpeg_try_fmt(f, ctx, &tmp_q);\n}\n\nstatic void mxc_jpeg_s_parsed_fmt(struct mxc_jpeg_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tstruct mxc_jpeg_q_data *q_data_cap;\n\n\tif (ctx->mxc_jpeg->mode != MXC_JPEG_DECODE || !V4L2_TYPE_IS_CAPTURE(f->type))\n\t\treturn;\n\tif (!ctx->header_parsed)\n\t\treturn;\n\n\tq_data_cap = mxc_jpeg_get_q_data(ctx, f->type);\n\tpix_mp->pixelformat = mxc_jpeg_try_fourcc(ctx, pix_mp->pixelformat);\n\tpix_mp->width = q_data_cap->w;\n\tpix_mp->height = q_data_cap->h;\n}\n\nstatic int mxc_jpeg_s_fmt(struct mxc_jpeg_ctx *ctx,\n\t\t\t  struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct mxc_jpeg_dev *jpeg = ctx->mxc_jpeg;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&jpeg->v4l2_dev, \"queue busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tmxc_jpeg_s_parsed_fmt(ctx, f);\n\n\treturn mxc_jpeg_try_fmt(f, ctx, mxc_jpeg_get_q_data(ctx, f->type));\n}\n\nstatic int mxc_jpeg_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\treturn mxc_jpeg_s_fmt(mxc_jpeg_fh_to_ctx(priv), f);\n}\n\nstatic int mxc_jpeg_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tint ret;\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(priv);\n\tstruct vb2_queue *dst_vq;\n\tstruct mxc_jpeg_q_data *q_data_cap;\n\tenum v4l2_buf_type cap_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tstruct v4l2_format fc;\n\n\tret = mxc_jpeg_s_fmt(mxc_jpeg_fh_to_ctx(priv), f);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->mxc_jpeg->mode != MXC_JPEG_DECODE)\n\t\treturn 0;\n\n\tdst_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, cap_type);\n\tif (!dst_vq)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(dst_vq))\n\t\treturn 0;\n\n\tq_data_cap = mxc_jpeg_get_q_data(ctx, cap_type);\n\tif (q_data_cap->w == f->fmt.pix_mp.width && q_data_cap->h == f->fmt.pix_mp.height)\n\t\treturn 0;\n\tmemset(&fc, 0, sizeof(fc));\n\tfc.type = cap_type;\n\tfc.fmt.pix_mp.pixelformat = q_data_cap->fmt->fourcc;\n\tfc.fmt.pix_mp.width = f->fmt.pix_mp.width;\n\tfc.fmt.pix_mp.height = f->fmt.pix_mp.height;\n\n\treturn mxc_jpeg_s_fmt_vid_cap(file, priv, &fc);\n}\n\nstatic int mxc_jpeg_g_fmt_vid(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(priv);\n\tstruct mxc_jpeg_dev *jpeg = ctx->mxc_jpeg;\n\tstruct device *dev = jpeg->dev;\n\tstruct v4l2_pix_format_mplane   *pix_mp = &f->fmt.pix_mp;\n\tstruct mxc_jpeg_q_data *q_data = mxc_jpeg_get_q_data(ctx, f->type);\n\tint i;\n\n\tif (!V4L2_TYPE_IS_MULTIPLANAR(f->type)) {\n\t\tdev_err(dev, \"G_FMT with Invalid type: %d\\n\", f->type);\n\t\treturn -EINVAL;\n\t}\n\n\tpix_mp->pixelformat = q_data->fmt->fourcc;\n\tpix_mp->width = q_data->w;\n\tpix_mp->height = q_data->h;\n\tpix_mp->field = V4L2_FIELD_NONE;\n\tif (q_data->fmt->flags == MXC_JPEG_FMT_TYPE_RAW) {\n\t\tpix_mp->width = q_data->w_adjusted;\n\t\tpix_mp->height = q_data->h_adjusted;\n\t}\n\n\t \n\tpix_mp->colorspace = V4L2_COLORSPACE_SRGB;\n\tpix_mp->ycbcr_enc = V4L2_YCBCR_ENC_601;\n\tpix_mp->xfer_func = V4L2_XFER_FUNC_SRGB;\n\tpix_mp->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\n\tpix_mp->num_planes = q_data->fmt->mem_planes;\n\tfor (i = 0; i < pix_mp->num_planes; i++) {\n\t\tpix_mp->plane_fmt[i].bytesperline = q_data->bytesperline[i];\n\t\tpix_mp->plane_fmt[i].sizeimage = mxc_jpeg_get_plane_size(q_data, i);\n\t}\n\n\treturn 0;\n}\n\nstatic int mxc_jpeg_dec_g_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(fh);\n\tstruct mxc_jpeg_q_data *q_data_cap;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE && s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\treturn -EINVAL;\n\n\tq_data_cap = mxc_jpeg_get_q_data(ctx, s->type);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\ts->r = q_data_cap->crop;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_PADDED:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = q_data_cap->w_adjusted;\n\t\ts->r.height = q_data_cap->h_adjusted;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxc_jpeg_enc_g_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(fh);\n\tstruct mxc_jpeg_q_data *q_data_out;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT && s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn -EINVAL;\n\n\tq_data_out = mxc_jpeg_get_q_data(ctx, s->type);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = q_data_out->w;\n\t\ts->r.height = q_data_out->h;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\ts->r = q_data_out->crop;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxc_jpeg_g_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(fh);\n\n\tif (ctx->mxc_jpeg->mode == MXC_JPEG_DECODE)\n\t\treturn mxc_jpeg_dec_g_selection(file, fh, s);\n\telse\n\t\treturn mxc_jpeg_enc_g_selection(file, fh, s);\n}\n\nstatic int mxc_jpeg_s_selection(struct file *file, void *fh, struct v4l2_selection *s)\n{\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(fh);\n\tstruct mxc_jpeg_q_data *q_data_out;\n\n\tif (ctx->mxc_jpeg->mode != MXC_JPEG_ENCODE)\n\t\treturn -ENOTTY;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT && s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\treturn -EINVAL;\n\tif (s->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\tq_data_out = mxc_jpeg_get_q_data(ctx, s->type);\n\tif (s->r.left || s->r.top)\n\t\treturn -EINVAL;\n\tif (s->r.width > q_data_out->w || s->r.height > q_data_out->h)\n\t\treturn -EINVAL;\n\n\tq_data_out->crop.left = 0;\n\tq_data_out->crop.top = 0;\n\tq_data_out->crop.width = s->r.width;\n\tq_data_out->crop.height = s->r.height;\n\n\treturn 0;\n}\n\nstatic int mxc_jpeg_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t    const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_EOS:\n\t\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\treturn v4l2_src_change_event_subscribe(fh, sub);\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct v4l2_ioctl_ops mxc_jpeg_ioctl_ops = {\n\t.vidioc_querycap\t\t= mxc_jpeg_querycap,\n\t.vidioc_enum_fmt_vid_cap\t= mxc_jpeg_enum_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_out\t= mxc_jpeg_enum_fmt_vid_out,\n\n\t.vidioc_try_fmt_vid_cap_mplane\t= mxc_jpeg_try_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_out_mplane\t= mxc_jpeg_try_fmt_vid_out,\n\n\t.vidioc_s_fmt_vid_cap_mplane\t= mxc_jpeg_s_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_out_mplane\t= mxc_jpeg_s_fmt_vid_out,\n\n\t.vidioc_g_fmt_vid_cap_mplane\t= mxc_jpeg_g_fmt_vid,\n\t.vidioc_g_fmt_vid_out_mplane\t= mxc_jpeg_g_fmt_vid,\n\n\t.vidioc_g_selection\t\t= mxc_jpeg_g_selection,\n\t.vidioc_s_selection\t\t= mxc_jpeg_s_selection,\n\n\t.vidioc_subscribe_event\t\t= mxc_jpeg_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n\n\t.vidioc_try_decoder_cmd\t\t= v4l2_m2m_ioctl_try_decoder_cmd,\n\t.vidioc_decoder_cmd\t\t= mxc_jpeg_decoder_cmd,\n\t.vidioc_try_encoder_cmd\t\t= v4l2_m2m_ioctl_try_encoder_cmd,\n\t.vidioc_encoder_cmd\t\t= mxc_jpeg_encoder_cmd,\n\n\t.vidioc_qbuf\t\t\t= v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= v4l2_m2m_ioctl_dqbuf,\n\n\t.vidioc_create_bufs\t\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t\t= v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_reqbufs\t\t\t= v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= v4l2_m2m_ioctl_querybuf,\n\t.vidioc_expbuf\t\t\t= v4l2_m2m_ioctl_expbuf,\n\t.vidioc_streamon\t\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t\t= v4l2_m2m_ioctl_streamoff,\n};\n\nstatic int mxc_jpeg_release(struct file *file)\n{\n\tstruct mxc_jpeg_dev *mxc_jpeg = video_drvdata(file);\n\tstruct mxc_jpeg_ctx *ctx = mxc_jpeg_fh_to_ctx(file->private_data);\n\tstruct device *dev = mxc_jpeg->dev;\n\n\tmutex_lock(&mxc_jpeg->lock);\n\tif (mxc_jpeg->mode == MXC_JPEG_DECODE)\n\t\tdev_dbg(dev, \"Release JPEG decoder instance on slot %d.\",\n\t\t\tctx->slot);\n\telse\n\t\tdev_dbg(dev, \"Release JPEG encoder instance on slot %d.\",\n\t\t\tctx->slot);\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\tmutex_unlock(&mxc_jpeg->lock);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations mxc_jpeg_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= mxc_jpeg_open,\n\t.release\t= mxc_jpeg_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic const struct v4l2_m2m_ops mxc_jpeg_m2m_ops = {\n\t.job_ready      = mxc_jpeg_job_ready,\n\t.device_run\t= mxc_jpeg_device_run,\n};\n\nstatic void mxc_jpeg_detach_pm_domains(struct mxc_jpeg_dev *jpeg)\n{\n\tint i;\n\n\tfor (i = 0; i < jpeg->num_domains; i++) {\n\t\tif (jpeg->pd_link[i] && !IS_ERR(jpeg->pd_link[i]))\n\t\t\tdevice_link_del(jpeg->pd_link[i]);\n\t\tif (jpeg->pd_dev[i] && !IS_ERR(jpeg->pd_dev[i]))\n\t\t\tdev_pm_domain_detach(jpeg->pd_dev[i], true);\n\t\tjpeg->pd_dev[i] = NULL;\n\t\tjpeg->pd_link[i] = NULL;\n\t}\n}\n\nstatic int mxc_jpeg_attach_pm_domains(struct mxc_jpeg_dev *jpeg)\n{\n\tstruct device *dev = jpeg->dev;\n\tstruct device_node *np = jpeg->pdev->dev.of_node;\n\tint i;\n\tint ret;\n\n\tjpeg->num_domains = of_count_phandle_with_args(np, \"power-domains\",\n\t\t\t\t\t\t       \"#power-domain-cells\");\n\tif (jpeg->num_domains < 0) {\n\t\tdev_err(dev, \"No power domains defined for jpeg node\\n\");\n\t\treturn jpeg->num_domains;\n\t}\n\tif (jpeg->num_domains == 1) {\n\t\t \n\t\tjpeg->num_domains = 0;\n\t\treturn 0;\n\t}\n\n\tjpeg->pd_dev = devm_kmalloc_array(dev, jpeg->num_domains,\n\t\t\t\t\t  sizeof(*jpeg->pd_dev), GFP_KERNEL);\n\tif (!jpeg->pd_dev)\n\t\treturn -ENOMEM;\n\n\tjpeg->pd_link = devm_kmalloc_array(dev, jpeg->num_domains,\n\t\t\t\t\t   sizeof(*jpeg->pd_link), GFP_KERNEL);\n\tif (!jpeg->pd_link)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < jpeg->num_domains; i++) {\n\t\tjpeg->pd_dev[i] = dev_pm_domain_attach_by_id(dev, i);\n\t\tif (IS_ERR(jpeg->pd_dev[i])) {\n\t\t\tret = PTR_ERR(jpeg->pd_dev[i]);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tjpeg->pd_link[i] = device_link_add(dev, jpeg->pd_dev[i],\n\t\t\t\t\t\t   DL_FLAG_STATELESS |\n\t\t\t\t\t\t   DL_FLAG_PM_RUNTIME);\n\t\tif (!jpeg->pd_link[i]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn 0;\nfail:\n\tmxc_jpeg_detach_pm_domains(jpeg);\n\treturn ret;\n}\n\nstatic int mxc_jpeg_probe(struct platform_device *pdev)\n{\n\tstruct mxc_jpeg_dev *jpeg;\n\tstruct device *dev = &pdev->dev;\n\tint dec_irq;\n\tint ret;\n\tint mode;\n\tconst struct of_device_id *of_id;\n\n\tof_id = of_match_node(mxc_jpeg_match, dev->of_node);\n\tif (!of_id)\n\t\treturn -ENODEV;\n\tmode = *(const int *)of_id->data;\n\n\tjpeg = devm_kzalloc(dev, sizeof(struct mxc_jpeg_dev), GFP_KERNEL);\n\tif (!jpeg)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&jpeg->lock);\n\tspin_lock_init(&jpeg->hw_lock);\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"No suitable DMA available.\\n\");\n\t\tgoto err_irq;\n\t}\n\n\tjpeg->base_reg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(jpeg->base_reg))\n\t\treturn PTR_ERR(jpeg->base_reg);\n\n\tret = of_property_read_u32_index(pdev->dev.of_node, \"slot\", 0, &jpeg->slot_data.slot);\n\tif (ret)\n\t\tjpeg->slot_data.slot = 0;\n\tdev_info(&pdev->dev, \"choose slot %d\\n\", jpeg->slot_data.slot);\n\tdec_irq = platform_get_irq(pdev, 0);\n\tif (dec_irq < 0) {\n\t\tret = dec_irq;\n\t\tgoto err_irq;\n\t}\n\tret = devm_request_irq(&pdev->dev, dec_irq, mxc_jpeg_dec_irq,\n\t\t\t       0, pdev->name, jpeg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq %d (%d)\\n\",\n\t\t\tdec_irq, ret);\n\t\tgoto err_irq;\n\t}\n\n\tjpeg->pdev = pdev;\n\tjpeg->dev = dev;\n\tjpeg->mode = mode;\n\n\t \n\tret = devm_clk_bulk_get_all(&pdev->dev, &jpeg->clks);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get clock\\n\");\n\t\tgoto err_clk;\n\t}\n\tjpeg->num_clks = ret;\n\n\tret = mxc_jpeg_attach_pm_domains(jpeg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to attach power domains %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = v4l2_device_register(dev, &jpeg->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register v4l2 device\\n\");\n\t\tgoto err_register;\n\t}\n\tjpeg->m2m_dev = v4l2_m2m_init(&mxc_jpeg_m2m_ops);\n\tif (IS_ERR(jpeg->m2m_dev)) {\n\t\tdev_err(dev, \"failed to register v4l2 device\\n\");\n\t\tret = PTR_ERR(jpeg->m2m_dev);\n\t\tgoto err_m2m;\n\t}\n\n\tjpeg->dec_vdev = video_device_alloc();\n\tif (!jpeg->dec_vdev) {\n\t\tdev_err(dev, \"failed to register v4l2 device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_vdev_alloc;\n\t}\n\tif (mode == MXC_JPEG_ENCODE)\n\t\tsnprintf(jpeg->dec_vdev->name,\n\t\t\t sizeof(jpeg->dec_vdev->name),\n\t\t\t \"%s-enc\", MXC_JPEG_NAME);\n\telse\n\t\tsnprintf(jpeg->dec_vdev->name,\n\t\t\t sizeof(jpeg->dec_vdev->name),\n\t\t\t \"%s-dec\", MXC_JPEG_NAME);\n\n\tjpeg->dec_vdev->fops = &mxc_jpeg_fops;\n\tjpeg->dec_vdev->ioctl_ops = &mxc_jpeg_ioctl_ops;\n\tjpeg->dec_vdev->minor = -1;\n\tjpeg->dec_vdev->release = video_device_release;\n\tjpeg->dec_vdev->lock = &jpeg->lock;  \n\tjpeg->dec_vdev->v4l2_dev = &jpeg->v4l2_dev;\n\tjpeg->dec_vdev->vfl_dir = VFL_DIR_M2M;\n\tjpeg->dec_vdev->device_caps = V4L2_CAP_STREAMING |\n\t\t\t\t\tV4L2_CAP_VIDEO_M2M_MPLANE;\n\tif (mode == MXC_JPEG_ENCODE) {\n\t\tv4l2_disable_ioctl(jpeg->dec_vdev, VIDIOC_DECODER_CMD);\n\t\tv4l2_disable_ioctl(jpeg->dec_vdev, VIDIOC_TRY_DECODER_CMD);\n\t} else {\n\t\tv4l2_disable_ioctl(jpeg->dec_vdev, VIDIOC_ENCODER_CMD);\n\t\tv4l2_disable_ioctl(jpeg->dec_vdev, VIDIOC_TRY_ENCODER_CMD);\n\t}\n\tret = video_register_device(jpeg->dec_vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register video device\\n\");\n\t\tgoto err_vdev_register;\n\t}\n\tvideo_set_drvdata(jpeg->dec_vdev, jpeg);\n\tif (mode == MXC_JPEG_ENCODE)\n\t\tv4l2_info(&jpeg->v4l2_dev,\n\t\t\t  \"encoder device registered as /dev/video%d (%d,%d)\\n\",\n\t\t\t  jpeg->dec_vdev->num, VIDEO_MAJOR,\n\t\t\t  jpeg->dec_vdev->minor);\n\telse\n\t\tv4l2_info(&jpeg->v4l2_dev,\n\t\t\t  \"decoder device registered as /dev/video%d (%d,%d)\\n\",\n\t\t\t  jpeg->dec_vdev->num, VIDEO_MAJOR,\n\t\t\t  jpeg->dec_vdev->minor);\n\n\tplatform_set_drvdata(pdev, jpeg);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nerr_vdev_register:\n\tvideo_device_release(jpeg->dec_vdev);\n\nerr_vdev_alloc:\n\tv4l2_m2m_release(jpeg->m2m_dev);\n\nerr_m2m:\n\tv4l2_device_unregister(&jpeg->v4l2_dev);\n\nerr_register:\n\tmxc_jpeg_detach_pm_domains(jpeg);\n\nerr_irq:\nerr_clk:\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic int mxc_jpeg_runtime_resume(struct device *dev)\n{\n\tstruct mxc_jpeg_dev *jpeg = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(jpeg->num_clks, jpeg->clks);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxc_jpeg_runtime_suspend(struct device *dev)\n{\n\tstruct mxc_jpeg_dev *jpeg = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(jpeg->num_clks, jpeg->clks);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mxc_jpeg_suspend(struct device *dev)\n{\n\tstruct mxc_jpeg_dev *jpeg = dev_get_drvdata(dev);\n\n\tv4l2_m2m_suspend(jpeg->m2m_dev);\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int mxc_jpeg_resume(struct device *dev)\n{\n\tstruct mxc_jpeg_dev *jpeg = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv4l2_m2m_resume(jpeg->m2m_dev);\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops\tmxc_jpeg_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mxc_jpeg_runtime_suspend,\n\t\t\t   mxc_jpeg_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(mxc_jpeg_suspend, mxc_jpeg_resume)\n};\n\nstatic void mxc_jpeg_remove(struct platform_device *pdev)\n{\n\tstruct mxc_jpeg_dev *jpeg = platform_get_drvdata(pdev);\n\n\tmxc_jpeg_free_slot_data(jpeg);\n\n\tpm_runtime_disable(&pdev->dev);\n\tvideo_unregister_device(jpeg->dec_vdev);\n\tv4l2_m2m_release(jpeg->m2m_dev);\n\tv4l2_device_unregister(&jpeg->v4l2_dev);\n\tmxc_jpeg_detach_pm_domains(jpeg);\n}\n\nMODULE_DEVICE_TABLE(of, mxc_jpeg_match);\n\nstatic struct platform_driver mxc_jpeg_driver = {\n\t.probe = mxc_jpeg_probe,\n\t.remove_new = mxc_jpeg_remove,\n\t.driver = {\n\t\t.name = \"mxc-jpeg\",\n\t\t.of_match_table = mxc_jpeg_match,\n\t\t.pm = &mxc_jpeg_pm_ops,\n\t},\n};\nmodule_platform_driver(mxc_jpeg_driver);\n\nMODULE_AUTHOR(\"Zhengyu Shen <zhengyu.shen_1@nxp.com>\");\nMODULE_AUTHOR(\"Mirela Rabulea <mirela.rabulea@nxp.com>\");\nMODULE_DESCRIPTION(\"V4L2 driver for i.MX8 QXP/QM JPEG encoder/decoder\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}