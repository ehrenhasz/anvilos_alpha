{
  "module_name": "mxc-jpeg-hw.c",
  "hash_id": "9271c991554e9e14f5f86612232494a581e45482accbd84775d9b4a92617581a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/nxp/imx-jpeg/mxc-jpeg-hw.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <media/videobuf2-core.h>\n#include \"mxc-jpeg-hw.h\"\n\n#define print_wrapper_reg(dev, base_address, reg_offset)\\\n\t\tinternal_print_wrapper_reg(dev, (base_address), #reg_offset,\\\n\t\t\t\t\t   (reg_offset))\n#define internal_print_wrapper_reg(dev, base_address, reg_name, reg_offset) {\\\n\t\tint val;\\\n\t\tval = readl((base_address) + (reg_offset));\\\n\t\tdev_dbg(dev, \"Wrapper reg %s = 0x%x\\n\", reg_name, val);\\\n}\n\nvoid print_descriptor_info(struct device *dev, struct mxc_jpeg_desc *desc)\n{\n\tdev_dbg(dev, \" MXC JPEG NEXT_DESCPT_PTR 0x%x\\n\",\n\t\tdesc->next_descpt_ptr);\n\tdev_dbg(dev, \" MXC JPEG BUF_BASE0 0x%x\\n\", desc->buf_base0);\n\tdev_dbg(dev, \" MXC JPEG BUF_BASE1 0x%x\\n\", desc->buf_base1);\n\tdev_dbg(dev, \" MXC JPEG LINE_PITCH %d\\n\", desc->line_pitch);\n\tdev_dbg(dev, \" MXC JPEG STM_BUFBASE 0x%x\\n\", desc->stm_bufbase);\n\tdev_dbg(dev, \" MXC JPEG STM_BUFSIZE %d\\n\", desc->stm_bufsize);\n\tdev_dbg(dev, \" MXC JPEG IMGSIZE %x (%d x %d)\\n\", desc->imgsize,\n\t\tdesc->imgsize >> 16, desc->imgsize & 0xFFFF);\n\tdev_dbg(dev, \" MXC JPEG STM_CTRL 0x%x\\n\", desc->stm_ctrl);\n}\n\nvoid print_cast_status(struct device *dev, void __iomem *reg,\n\t\t       unsigned int mode)\n{\n\tdev_dbg(dev, \"CAST IP status regs:\\n\");\n\tprint_wrapper_reg(dev, reg, CAST_STATUS0);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS1);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS2);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS3);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS4);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS5);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS6);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS7);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS8);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS9);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS10);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS11);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS12);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS13);\n\tif (mode == MXC_JPEG_DECODE)\n\t\treturn;\n\tprint_wrapper_reg(dev, reg, CAST_STATUS14);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS15);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS16);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS17);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS18);\n\tprint_wrapper_reg(dev, reg, CAST_STATUS19);\n}\n\nvoid print_wrapper_info(struct device *dev, void __iomem *reg)\n{\n\tdev_dbg(dev, \"Wrapper regs:\\n\");\n\tprint_wrapper_reg(dev, reg, GLB_CTRL);\n\tprint_wrapper_reg(dev, reg, COM_STATUS);\n\tprint_wrapper_reg(dev, reg, BUF_BASE0);\n\tprint_wrapper_reg(dev, reg, BUF_BASE1);\n\tprint_wrapper_reg(dev, reg, LINE_PITCH);\n\tprint_wrapper_reg(dev, reg, STM_BUFBASE);\n\tprint_wrapper_reg(dev, reg, STM_BUFSIZE);\n\tprint_wrapper_reg(dev, reg, IMGSIZE);\n\tprint_wrapper_reg(dev, reg, STM_CTRL);\n}\n\nvoid mxc_jpeg_enable_irq(void __iomem *reg, int slot)\n{\n\twritel(0xFFFFFFFF, reg + MXC_SLOT_OFFSET(slot, SLOT_STATUS));\n\twritel(0xF0C, reg + MXC_SLOT_OFFSET(slot, SLOT_IRQ_EN));\n}\n\nvoid mxc_jpeg_disable_irq(void __iomem *reg, int slot)\n{\n\twritel(0x0, reg + MXC_SLOT_OFFSET(slot, SLOT_IRQ_EN));\n\twritel(0xFFFFFFFF, reg + MXC_SLOT_OFFSET(slot, SLOT_STATUS));\n}\n\nvoid mxc_jpeg_sw_reset(void __iomem *reg)\n{\n\t \n\twritel(GLB_CTRL_SFT_RST, reg + GLB_CTRL);\n}\n\nvoid mxc_jpeg_enc_mode_conf(struct device *dev, void __iomem *reg, u8 extseq)\n{\n\tdev_dbg(dev, \"CAST Encoder CONFIG...\\n\");\n\t \n\tif (extseq)\n\t\twritel(0xb0, reg + CAST_MODE);\n\telse\n\t\twritel(0xa0, reg + CAST_MODE);\n\n\t \n\twritel(0x3ff, reg + CAST_CFG_MODE);\n}\n\nvoid mxc_jpeg_enc_mode_go(struct device *dev, void __iomem *reg, u8 extseq)\n{\n\tdev_dbg(dev, \"CAST Encoder GO...\\n\");\n\t \n\tif (extseq)\n\t\twritel(0x150, reg + CAST_MODE);\n\telse\n\t\twritel(0x140, reg + CAST_MODE);\n}\n\nvoid mxc_jpeg_enc_set_quality(struct device *dev, void __iomem *reg, u8 quality)\n{\n\tdev_dbg(dev, \"CAST Encoder Quality %d...\\n\", quality);\n\n\t \n\twritel(quality, reg + CAST_QUALITY);\n}\n\nvoid mxc_jpeg_dec_mode_go(struct device *dev, void __iomem *reg)\n{\n\tdev_dbg(dev, \"CAST Decoder GO...\\n\");\n\twritel(MXC_DEC_EXIT_IDLE_MODE, reg + CAST_CTRL);\n}\n\nint mxc_jpeg_enable(void __iomem *reg)\n{\n\tu32 regval;\n\n\twritel(GLB_CTRL_JPG_EN, reg + GLB_CTRL);\n\tregval = readl(reg);\n\treturn regval;\n}\n\nvoid mxc_jpeg_enable_slot(void __iomem *reg, int slot)\n{\n\tu32 regval;\n\n\tregval = readl(reg + GLB_CTRL);\n\twritel(GLB_CTRL_SLOT_EN(slot) | regval, reg + GLB_CTRL);\n}\n\nvoid mxc_jpeg_set_l_endian(void __iomem *reg, int le)\n{\n\tu32 regval;\n\n\tregval = readl(reg + GLB_CTRL);\n\tregval &= ~GLB_CTRL_L_ENDIAN(1);  \n\twritel(GLB_CTRL_L_ENDIAN(le) | regval, reg + GLB_CTRL);  \n}\n\nvoid mxc_jpeg_set_bufsize(struct mxc_jpeg_desc *desc,  u32 bufsize)\n{\n\tdesc->stm_bufsize = bufsize;\n}\n\nvoid mxc_jpeg_set_res(struct mxc_jpeg_desc *desc, u16 w, u16 h)\n{\n\tdesc->imgsize = w << 16 | h;\n}\n\nvoid mxc_jpeg_set_line_pitch(struct mxc_jpeg_desc *desc, u32 line_pitch)\n{\n\tdesc->line_pitch = line_pitch;\n}\n\nvoid mxc_jpeg_set_desc(u32 desc, void __iomem *reg, int slot)\n{\n\twritel(desc | MXC_NXT_DESCPT_EN,\n\t       reg + MXC_SLOT_OFFSET(slot, SLOT_NXT_DESCPT_PTR));\n}\n\nvoid mxc_jpeg_clr_desc(void __iomem *reg, int slot)\n{\n\twritel(0, reg + MXC_SLOT_OFFSET(slot, SLOT_NXT_DESCPT_PTR));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}