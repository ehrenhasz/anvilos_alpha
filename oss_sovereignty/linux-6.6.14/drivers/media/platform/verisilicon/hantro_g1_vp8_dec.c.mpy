{
  "module_name": "hantro_g1_vp8_dec.c",
  "hash_id": "8de5414a282c8676e2ce0a906cd8f4a78d77eb622b0443f5b21bca3bf4236bfc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/verisilicon/hantro_g1_vp8_dec.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-mem2mem.h>\n\n#include \"hantro_hw.h\"\n#include \"hantro.h\"\n#include \"hantro_g1_regs.h\"\n\n \nstatic const struct hantro_reg vp8_dec_dct_base[8] = {\n\t{ G1_REG_ADDR_STR, 0, 0xffffffff },\n\t{ G1_REG_ADDR_REF(8), 0, 0xffffffff },\n\t{ G1_REG_ADDR_REF(9), 0, 0xffffffff },\n\t{ G1_REG_ADDR_REF(10), 0, 0xffffffff },\n\t{ G1_REG_ADDR_REF(11), 0, 0xffffffff },\n\t{ G1_REG_ADDR_REF(12), 0, 0xffffffff },\n\t{ G1_REG_ADDR_REF(14), 0, 0xffffffff },\n\t{ G1_REG_ADDR_REF(15), 0, 0xffffffff },\n};\n\n \nstatic const struct hantro_reg vp8_dec_lf_level[4] = {\n\t{ G1_REG_REF_PIC(2), 18, 0x3f },\n\t{ G1_REG_REF_PIC(2), 12, 0x3f },\n\t{ G1_REG_REF_PIC(2), 6, 0x3f },\n\t{ G1_REG_REF_PIC(2), 0, 0x3f },\n};\n\n \nstatic const struct hantro_reg vp8_dec_mb_adj[4] = {\n\t{ G1_REG_REF_PIC(0), 21, 0x7f },\n\t{ G1_REG_REF_PIC(0), 14, 0x7f },\n\t{ G1_REG_REF_PIC(0), 7, 0x7f },\n\t{ G1_REG_REF_PIC(0), 0, 0x7f },\n};\n\n \nstatic const struct hantro_reg vp8_dec_ref_adj[4] = {\n\t{ G1_REG_REF_PIC(1), 21, 0x7f },\n\t{ G1_REG_REF_PIC(1), 14, 0x7f },\n\t{ G1_REG_REF_PIC(1), 7, 0x7f },\n\t{ G1_REG_REF_PIC(1), 0, 0x7f },\n};\n\n \nstatic const struct hantro_reg vp8_dec_quant[4] = {\n\t{ G1_REG_REF_PIC(3), 11, 0x7ff },\n\t{ G1_REG_REF_PIC(3), 0, 0x7ff },\n\t{ G1_REG_BD_REF_PIC(4), 11, 0x7ff },\n\t{ G1_REG_BD_REF_PIC(4), 0, 0x7ff },\n};\n\n \nstatic const struct hantro_reg vp8_dec_quant_delta[5] = {\n\t{ G1_REG_REF_PIC(3), 27, 0x1f },\n\t{ G1_REG_REF_PIC(3), 22, 0x1f },\n\t{ G1_REG_BD_REF_PIC(4), 27, 0x1f },\n\t{ G1_REG_BD_REF_PIC(4), 22, 0x1f },\n\t{ G1_REG_BD_P_REF_PIC, 27, 0x1f },\n};\n\n \nstatic const struct hantro_reg vp8_dec_dct_start_bits[8] = {\n\t{ G1_REG_DEC_CTRL2, 26, 0x3f }, { G1_REG_DEC_CTRL4, 26, 0x3f },\n\t{ G1_REG_DEC_CTRL4, 20, 0x3f }, { G1_REG_DEC_CTRL7, 24, 0x3f },\n\t{ G1_REG_DEC_CTRL7, 18, 0x3f }, { G1_REG_DEC_CTRL7, 12, 0x3f },\n\t{ G1_REG_DEC_CTRL7, 6, 0x3f },  { G1_REG_DEC_CTRL7, 0, 0x3f },\n};\n\n \nstatic const struct hantro_reg vp8_dec_pred_bc_tap[8][4] = {\n\t{\n\t\t{ G1_REG_PRED_FLT, 22, 0x3ff },\n\t\t{ G1_REG_PRED_FLT, 12, 0x3ff },\n\t\t{ G1_REG_PRED_FLT, 2, 0x3ff },\n\t\t{ G1_REG_REF_PIC(4), 22, 0x3ff },\n\t},\n\t{\n\t\t{ G1_REG_REF_PIC(4), 12, 0x3ff },\n\t\t{ G1_REG_REF_PIC(4), 2, 0x3ff },\n\t\t{ G1_REG_REF_PIC(5), 22, 0x3ff },\n\t\t{ G1_REG_REF_PIC(5), 12, 0x3ff },\n\t},\n\t{\n\t\t{ G1_REG_REF_PIC(5), 2, 0x3ff },\n\t\t{ G1_REG_REF_PIC(6), 22, 0x3ff },\n\t\t{ G1_REG_REF_PIC(6), 12, 0x3ff },\n\t\t{ G1_REG_REF_PIC(6), 2, 0x3ff },\n\t},\n\t{\n\t\t{ G1_REG_REF_PIC(7), 22, 0x3ff },\n\t\t{ G1_REG_REF_PIC(7), 12, 0x3ff },\n\t\t{ G1_REG_REF_PIC(7), 2, 0x3ff },\n\t\t{ G1_REG_LT_REF, 22, 0x3ff },\n\t},\n\t{\n\t\t{ G1_REG_LT_REF, 12, 0x3ff },\n\t\t{ G1_REG_LT_REF, 2, 0x3ff },\n\t\t{ G1_REG_VALID_REF, 22, 0x3ff },\n\t\t{ G1_REG_VALID_REF, 12, 0x3ff },\n\t},\n\t{\n\t\t{ G1_REG_VALID_REF, 2, 0x3ff },\n\t\t{ G1_REG_BD_REF_PIC(0), 22, 0x3ff },\n\t\t{ G1_REG_BD_REF_PIC(0), 12, 0x3ff },\n\t\t{ G1_REG_BD_REF_PIC(0), 2, 0x3ff },\n\t},\n\t{\n\t\t{ G1_REG_BD_REF_PIC(1), 22, 0x3ff },\n\t\t{ G1_REG_BD_REF_PIC(1), 12, 0x3ff },\n\t\t{ G1_REG_BD_REF_PIC(1), 2, 0x3ff },\n\t\t{ G1_REG_BD_REF_PIC(2), 22, 0x3ff },\n\t},\n\t{\n\t\t{ G1_REG_BD_REF_PIC(2), 12, 0x3ff },\n\t\t{ G1_REG_BD_REF_PIC(2), 2, 0x3ff },\n\t\t{ G1_REG_BD_REF_PIC(3), 22, 0x3ff },\n\t\t{ G1_REG_BD_REF_PIC(3), 12, 0x3ff },\n\t},\n};\n\n \nstatic void cfg_lf(struct hantro_ctx *ctx,\n\t\t   const struct v4l2_ctrl_vp8_frame *hdr)\n{\n\tconst struct v4l2_vp8_segment *seg = &hdr->segment;\n\tconst struct v4l2_vp8_loop_filter *lf = &hdr->lf;\n\tstruct hantro_dev *vpu = ctx->dev;\n\tunsigned int i;\n\tu32 reg;\n\n\tif (!(seg->flags & V4L2_VP8_SEGMENT_FLAG_ENABLED)) {\n\t\thantro_reg_write(vpu, &vp8_dec_lf_level[0], lf->level);\n\t} else if (seg->flags & V4L2_VP8_SEGMENT_FLAG_DELTA_VALUE_MODE) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tu32 lf_level = clamp(lf->level + seg->lf_update[i],\n\t\t\t\t\t     0, 63);\n\n\t\t\thantro_reg_write(vpu, &vp8_dec_lf_level[i], lf_level);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\thantro_reg_write(vpu, &vp8_dec_lf_level[i],\n\t\t\t\t\t seg->lf_update[i]);\n\t}\n\n\treg = G1_REG_REF_PIC_FILT_SHARPNESS(lf->sharpness_level);\n\tif (lf->flags & V4L2_VP8_LF_FILTER_TYPE_SIMPLE)\n\t\treg |= G1_REG_REF_PIC_FILT_TYPE_E;\n\tvdpu_write_relaxed(vpu, reg, G1_REG_REF_PIC(0));\n\n\tif (lf->flags & V4L2_VP8_LF_ADJ_ENABLE) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\thantro_reg_write(vpu, &vp8_dec_mb_adj[i],\n\t\t\t\t\t lf->mb_mode_delta[i]);\n\t\t\thantro_reg_write(vpu, &vp8_dec_ref_adj[i],\n\t\t\t\t\t lf->ref_frm_delta[i]);\n\t\t}\n\t}\n}\n\n \nstatic void cfg_qp(struct hantro_ctx *ctx,\n\t\t   const struct v4l2_ctrl_vp8_frame *hdr)\n{\n\tconst struct v4l2_vp8_quantization *q = &hdr->quant;\n\tconst struct v4l2_vp8_segment *seg = &hdr->segment;\n\tstruct hantro_dev *vpu = ctx->dev;\n\tunsigned int i;\n\n\tif (!(seg->flags & V4L2_VP8_SEGMENT_FLAG_ENABLED)) {\n\t\thantro_reg_write(vpu, &vp8_dec_quant[0], q->y_ac_qi);\n\t} else if (seg->flags & V4L2_VP8_SEGMENT_FLAG_DELTA_VALUE_MODE) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tu32 quant = clamp(q->y_ac_qi + seg->quant_update[i],\n\t\t\t\t\t  0, 127);\n\n\t\t\thantro_reg_write(vpu, &vp8_dec_quant[i], quant);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\thantro_reg_write(vpu, &vp8_dec_quant[i],\n\t\t\t\t\t seg->quant_update[i]);\n\t}\n\n\thantro_reg_write(vpu, &vp8_dec_quant_delta[0], q->y_dc_delta);\n\thantro_reg_write(vpu, &vp8_dec_quant_delta[1], q->y2_dc_delta);\n\thantro_reg_write(vpu, &vp8_dec_quant_delta[2], q->y2_ac_delta);\n\thantro_reg_write(vpu, &vp8_dec_quant_delta[3], q->uv_dc_delta);\n\thantro_reg_write(vpu, &vp8_dec_quant_delta[4], q->uv_ac_delta);\n}\n\n \nstatic void cfg_parts(struct hantro_ctx *ctx,\n\t\t      const struct v4l2_ctrl_vp8_frame *hdr)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tstruct vb2_v4l2_buffer *vb2_src;\n\tu32 first_part_offset = V4L2_VP8_FRAME_IS_KEY_FRAME(hdr) ? 10 : 3;\n\tu32 mb_size, mb_offset_bytes, mb_offset_bits, mb_start_bits;\n\tu32 dct_size_part_size, dct_part_offset;\n\tstruct hantro_reg reg;\n\tdma_addr_t src_dma;\n\tu32 dct_part_total_len = 0;\n\tu32 count = 0;\n\tunsigned int i;\n\n\tvb2_src = hantro_get_src_buf(ctx);\n\tsrc_dma = vb2_dma_contig_plane_dma_addr(&vb2_src->vb2_buf, 0);\n\n\t \n\tmb_offset_bits = first_part_offset * 8 +\n\t\t\t hdr->first_part_header_bits + 8;\n\tmb_offset_bytes = mb_offset_bits / 8;\n\tmb_start_bits = mb_offset_bits -\n\t\t\t(mb_offset_bytes & (~DEC_8190_ALIGN_MASK)) * 8;\n\tmb_size = hdr->first_part_size -\n\t\t  (mb_offset_bytes - first_part_offset) +\n\t\t  (mb_offset_bytes & DEC_8190_ALIGN_MASK);\n\n\t \n\tvdpu_write_relaxed(vpu, (mb_offset_bytes & (~DEC_8190_ALIGN_MASK))\n\t\t\t\t+ src_dma, G1_REG_ADDR_REF(13));\n\n\t \n\treg.base = G1_REG_DEC_CTRL2;\n\treg.mask = 0x3f;\n\treg.shift = 18;\n\thantro_reg_write(vpu, &reg, mb_start_bits);\n\n\t \n\treg.base = G1_REG_DEC_CTRL6;\n\treg.mask = 0x3fffff;\n\treg.shift = 0;\n\thantro_reg_write(vpu, &reg, mb_size + 1);\n\n\t \n\tdct_size_part_size = (hdr->num_dct_parts - 1) * 3;\n\tdct_part_offset = first_part_offset + hdr->first_part_size;\n\tfor (i = 0; i < hdr->num_dct_parts; i++)\n\t\tdct_part_total_len += hdr->dct_part_sizes[i];\n\tdct_part_total_len += dct_size_part_size;\n\tdct_part_total_len += (dct_part_offset & DEC_8190_ALIGN_MASK);\n\n\t \n\treg.base = G1_REG_DEC_CTRL6;\n\treg.mask = 0xf;\n\treg.shift = 24;\n\thantro_reg_write(vpu, &reg, hdr->num_dct_parts - 1);\n\n\t \n\tvdpu_write_relaxed(vpu,\n\t\t\t   G1_REG_DEC_CTRL3_STREAM_LEN(dct_part_total_len),\n\t\t\t   G1_REG_DEC_CTRL3);\n\n\t \n\tfor (i = 0; i < hdr->num_dct_parts; i++) {\n\t\tu32 byte_offset = dct_part_offset + dct_size_part_size + count;\n\t\tu32 base_addr = byte_offset + src_dma;\n\n\t\thantro_reg_write(vpu, &vp8_dec_dct_base[i],\n\t\t\t\t base_addr & (~DEC_8190_ALIGN_MASK));\n\n\t\thantro_reg_write(vpu, &vp8_dec_dct_start_bits[i],\n\t\t\t\t (byte_offset & DEC_8190_ALIGN_MASK) * 8);\n\n\t\tcount += hdr->dct_part_sizes[i];\n\t}\n}\n\n \nstatic void cfg_tap(struct hantro_ctx *ctx,\n\t\t    const struct v4l2_ctrl_vp8_frame *hdr)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tstruct hantro_reg reg;\n\tu32 val = 0;\n\tint i, j;\n\n\treg.base = G1_REG_BD_REF_PIC(3);\n\treg.mask = 0xf;\n\n\tif ((hdr->version & 0x03) != 0)\n\t\treturn;  \n\n\tfor (i = 0; i < 8; i++) {\n\t\tval = (hantro_vp8_dec_mc_filter[i][0] << 2) |\n\t\t       hantro_vp8_dec_mc_filter[i][5];\n\n\t\tfor (j = 0; j < 4; j++)\n\t\t\thantro_reg_write(vpu, &vp8_dec_pred_bc_tap[i][j],\n\t\t\t\t\t hantro_vp8_dec_mc_filter[i][j + 1]);\n\n\t\tswitch (i) {\n\t\tcase 2:\n\t\t\treg.shift = 8;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\treg.shift = 4;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\treg.shift = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\thantro_reg_write(vpu, &reg, val);\n\t}\n}\n\nstatic void cfg_ref(struct hantro_ctx *ctx,\n\t\t    const struct v4l2_ctrl_vp8_frame *hdr,\n\t\t    struct vb2_v4l2_buffer *vb2_dst)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tdma_addr_t ref;\n\n\n\tref = hantro_get_ref(ctx, hdr->last_frame_ts);\n\tif (!ref) {\n\t\tvpu_debug(0, \"failed to find last frame ts=%llu\\n\",\n\t\t\t  hdr->last_frame_ts);\n\t\tref = vb2_dma_contig_plane_dma_addr(&vb2_dst->vb2_buf, 0);\n\t}\n\tvdpu_write_relaxed(vpu, ref, G1_REG_ADDR_REF(0));\n\n\tref = hantro_get_ref(ctx, hdr->golden_frame_ts);\n\tif (!ref && hdr->golden_frame_ts)\n\t\tvpu_debug(0, \"failed to find golden frame ts=%llu\\n\",\n\t\t\t  hdr->golden_frame_ts);\n\tif (!ref)\n\t\tref = vb2_dma_contig_plane_dma_addr(&vb2_dst->vb2_buf, 0);\n\tif (hdr->flags & V4L2_VP8_FRAME_FLAG_SIGN_BIAS_GOLDEN)\n\t\tref |= G1_REG_ADDR_REF_TOPC_E;\n\tvdpu_write_relaxed(vpu, ref, G1_REG_ADDR_REF(4));\n\n\tref = hantro_get_ref(ctx, hdr->alt_frame_ts);\n\tif (!ref && hdr->alt_frame_ts)\n\t\tvpu_debug(0, \"failed to find alt frame ts=%llu\\n\",\n\t\t\t  hdr->alt_frame_ts);\n\tif (!ref)\n\t\tref = vb2_dma_contig_plane_dma_addr(&vb2_dst->vb2_buf, 0);\n\tif (hdr->flags & V4L2_VP8_FRAME_FLAG_SIGN_BIAS_ALT)\n\t\tref |= G1_REG_ADDR_REF_TOPC_E;\n\tvdpu_write_relaxed(vpu, ref, G1_REG_ADDR_REF(5));\n}\n\nstatic void cfg_buffers(struct hantro_ctx *ctx,\n\t\t\tconst struct v4l2_ctrl_vp8_frame *hdr,\n\t\t\tstruct vb2_v4l2_buffer *vb2_dst)\n{\n\tconst struct v4l2_vp8_segment *seg = &hdr->segment;\n\tstruct hantro_dev *vpu = ctx->dev;\n\tdma_addr_t dst_dma;\n\tu32 reg;\n\n\t \n\tvdpu_write_relaxed(vpu, ctx->vp8_dec.prob_tbl.dma,\n\t\t\t   G1_REG_ADDR_QTABLE);\n\n\t \n\treg = G1_REG_FWD_PIC1_SEGMENT_BASE(ctx->vp8_dec.segment_map.dma);\n\tif (seg->flags & V4L2_VP8_SEGMENT_FLAG_ENABLED) {\n\t\treg |= G1_REG_FWD_PIC1_SEGMENT_E;\n\t\tif (seg->flags & V4L2_VP8_SEGMENT_FLAG_UPDATE_MAP)\n\t\t\treg |= G1_REG_FWD_PIC1_SEGMENT_UPD_E;\n\t}\n\tvdpu_write_relaxed(vpu, reg, G1_REG_FWD_PIC(0));\n\n\tdst_dma = hantro_get_dec_buf_addr(ctx, &vb2_dst->vb2_buf);\n\tvdpu_write_relaxed(vpu, dst_dma, G1_REG_ADDR_DST);\n}\n\nint hantro_g1_vp8_dec_run(struct hantro_ctx *ctx)\n{\n\tconst struct v4l2_ctrl_vp8_frame *hdr;\n\tstruct hantro_dev *vpu = ctx->dev;\n\tstruct vb2_v4l2_buffer *vb2_dst;\n\tsize_t height = ctx->dst_fmt.height;\n\tsize_t width = ctx->dst_fmt.width;\n\tu32 mb_width, mb_height;\n\tu32 reg;\n\n\thantro_start_prepare_run(ctx);\n\n\thdr = hantro_get_ctrl(ctx, V4L2_CID_STATELESS_VP8_FRAME);\n\tif (WARN_ON(!hdr))\n\t\treturn -EINVAL;\n\n\t \n\tif (V4L2_VP8_FRAME_IS_KEY_FRAME(hdr) && ctx->vp8_dec.segment_map.cpu)\n\t\tmemset(ctx->vp8_dec.segment_map.cpu, 0,\n\t\t       ctx->vp8_dec.segment_map.size);\n\n\thantro_vp8_prob_update(ctx, hdr);\n\n\treg = G1_REG_CONFIG_DEC_TIMEOUT_E |\n\t      G1_REG_CONFIG_DEC_STRENDIAN_E |\n\t      G1_REG_CONFIG_DEC_INSWAP32_E |\n\t      G1_REG_CONFIG_DEC_STRSWAP32_E |\n\t      G1_REG_CONFIG_DEC_OUTSWAP32_E |\n\t      G1_REG_CONFIG_DEC_CLK_GATE_E |\n\t      G1_REG_CONFIG_DEC_IN_ENDIAN |\n\t      G1_REG_CONFIG_DEC_OUT_ENDIAN |\n\t      G1_REG_CONFIG_DEC_MAX_BURST(16);\n\tvdpu_write_relaxed(vpu, reg, G1_REG_CONFIG);\n\n\treg = G1_REG_DEC_CTRL0_DEC_MODE(10) |\n\t      G1_REG_DEC_CTRL0_DEC_AXI_AUTO;\n\tif (!V4L2_VP8_FRAME_IS_KEY_FRAME(hdr))\n\t\treg |= G1_REG_DEC_CTRL0_PIC_INTER_E;\n\tif (!(hdr->flags & V4L2_VP8_FRAME_FLAG_MB_NO_SKIP_COEFF))\n\t\treg |= G1_REG_DEC_CTRL0_SKIP_MODE;\n\tif (hdr->lf.level == 0)\n\t\treg |= G1_REG_DEC_CTRL0_FILTERING_DIS;\n\tvdpu_write_relaxed(vpu, reg, G1_REG_DEC_CTRL0);\n\n\t \n\tmb_width = MB_WIDTH(width);\n\tmb_height = MB_HEIGHT(height);\n\treg = G1_REG_DEC_CTRL1_PIC_MB_WIDTH(mb_width) |\n\t      G1_REG_DEC_CTRL1_PIC_MB_HEIGHT_P(mb_height) |\n\t      G1_REG_DEC_CTRL1_PIC_MB_W_EXT(mb_width >> 9) |\n\t      G1_REG_DEC_CTRL1_PIC_MB_H_EXT(mb_height >> 8);\n\tvdpu_write_relaxed(vpu, reg, G1_REG_DEC_CTRL1);\n\n\t \n\treg = G1_REG_DEC_CTRL2_BOOLEAN_RANGE(hdr->coder_state.range)\n\t\t| G1_REG_DEC_CTRL2_BOOLEAN_VALUE(hdr->coder_state.value);\n\tvdpu_write_relaxed(vpu, reg, G1_REG_DEC_CTRL2);\n\n\treg = 0;\n\tif (hdr->version != 3)\n\t\treg |= G1_REG_DEC_CTRL4_VC1_HEIGHT_EXT;\n\tif (hdr->version & 0x3)\n\t\treg |= G1_REG_DEC_CTRL4_BILIN_MC_E;\n\tvdpu_write_relaxed(vpu, reg, G1_REG_DEC_CTRL4);\n\n\tcfg_lf(ctx, hdr);\n\tcfg_qp(ctx, hdr);\n\tcfg_parts(ctx, hdr);\n\tcfg_tap(ctx, hdr);\n\n\tvb2_dst = hantro_get_dst_buf(ctx);\n\tcfg_ref(ctx, hdr, vb2_dst);\n\tcfg_buffers(ctx, hdr, vb2_dst);\n\n\thantro_end_prepare_run(ctx);\n\n\tvdpu_write(vpu, G1_REG_INTERRUPT_DEC_E, G1_REG_INTERRUPT);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}