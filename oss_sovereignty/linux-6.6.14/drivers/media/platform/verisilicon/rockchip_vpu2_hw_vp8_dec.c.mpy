{
  "module_name": "rockchip_vpu2_hw_vp8_dec.c",
  "hash_id": "cc1d5d9cee7cfa07d74489d8b459c6e6cd1b60b4a18cdb2d458f2fe5c054bea7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/verisilicon/rockchip_vpu2_hw_vp8_dec.c",
  "human_readable_source": "\n \n\n#include <media/v4l2-mem2mem.h>\n\n#include \"hantro_hw.h\"\n#include \"hantro.h\"\n#include \"hantro_g1_regs.h\"\n\n#define VDPU_REG_DEC_CTRL0\t\t\t0x0c8\n#define VDPU_REG_STREAM_LEN\t\t\t0x0cc\n#define VDPU_REG_DEC_FORMAT\t\t\t0x0d4\n#define     VDPU_REG_DEC_CTRL0_DEC_MODE(x)\t\t(((x) & 0xf) << 0)\n#define VDPU_REG_DATA_ENDIAN\t\t\t0x0d8\n#define     VDPU_REG_CONFIG_DEC_STRENDIAN_E\t\tBIT(5)\n#define     VDPU_REG_CONFIG_DEC_STRSWAP32_E\t\tBIT(4)\n#define     VDPU_REG_CONFIG_DEC_OUTSWAP32_E\t\tBIT(3)\n#define     VDPU_REG_CONFIG_DEC_INSWAP32_E\t\tBIT(2)\n#define     VDPU_REG_CONFIG_DEC_OUT_ENDIAN\t\tBIT(1)\n#define     VDPU_REG_CONFIG_DEC_IN_ENDIAN\t\tBIT(0)\n#define VDPU_REG_AXI_CTRL\t\t\t0x0e0\n#define     VDPU_REG_CONFIG_DEC_MAX_BURST(x)\t\t(((x) & 0x1f) << 16)\n#define VDPU_REG_EN_FLAGS\t\t\t0x0e4\n#define     VDPU_REG_DEC_CTRL0_PIC_INTER_E\t\tBIT(14)\n#define     VDPU_REG_CONFIG_DEC_TIMEOUT_E\t\tBIT(5)\n#define     VDPU_REG_CONFIG_DEC_CLK_GATE_E\t\tBIT(4)\n#define VDPU_REG_PRED_FLT\t\t\t0x0ec\n#define VDPU_REG_ADDR_QTABLE\t\t\t0x0f4\n#define VDPU_REG_ADDR_DST\t\t\t0x0fc\n#define VDPU_REG_ADDR_STR\t\t\t0x100\n#define VDPU_REG_VP8_PIC_MB_SIZE\t\t0x1e0\n#define VDPU_REG_VP8_DCT_START_BIT\t\t0x1e4\n#define     VDPU_REG_DEC_CTRL4_VC1_HEIGHT_EXT\t\tBIT(13)\n#define     VDPU_REG_DEC_CTRL4_BILIN_MC_E\t\tBIT(12)\n#define VDPU_REG_VP8_CTRL0\t\t\t0x1e8\n#define VDPU_REG_VP8_DATA_VAL\t\t\t0x1f0\n#define VDPU_REG_PRED_FLT7\t\t\t0x1f4\n#define VDPU_REG_PRED_FLT8\t\t\t0x1f8\n#define VDPU_REG_PRED_FLT9\t\t\t0x1fc\n#define VDPU_REG_PRED_FLT10\t\t\t0x200\n#define VDPU_REG_FILTER_LEVEL\t\t\t0x204\n#define VDPU_REG_VP8_QUANTER0\t\t\t0x208\n#define VDPU_REG_VP8_ADDR_REF0\t\t\t0x20c\n#define VDPU_REG_FILTER_MB_ADJ\t\t\t0x210\n#define     VDPU_REG_REF_PIC_FILT_TYPE_E\t\tBIT(31)\n#define     VDPU_REG_REF_PIC_FILT_SHARPNESS(x)\t\t(((x) & 0x7) << 28)\n#define VDPU_REG_FILTER_REF_ADJ\t\t\t0x214\n#define VDPU_REG_VP8_ADDR_REF2_5(i)\t\t(0x218 + ((i) * 0x4))\n#define     VDPU_REG_VP8_GREF_SIGN_BIAS\t\t\tBIT(0)\n#define     VDPU_REG_VP8_AREF_SIGN_BIAS\t\t\tBIT(0)\n#define VDPU_REG_VP8_DCT_BASE(i)\t\t\\\n\t\t(0x230 + ((((i) < 5) ? (i) : ((i) + 1)) * 0x4))\n#define VDPU_REG_VP8_ADDR_CTRL_PART\t\t0x244\n#define VDPU_REG_VP8_SEGMENT_VAL\t\t0x254\n#define     VDPU_REG_FWD_PIC1_SEGMENT_BASE(x)\t\t((x) << 0)\n#define     VDPU_REG_FWD_PIC1_SEGMENT_UPD_E\t\tBIT(1)\n#define     VDPU_REG_FWD_PIC1_SEGMENT_E\t\t\tBIT(0)\n#define VDPU_REG_VP8_DCT_START_BIT2\t\t0x258\n#define VDPU_REG_VP8_QUANTER1\t\t\t0x25c\n#define VDPU_REG_VP8_QUANTER2\t\t\t0x260\n#define VDPU_REG_PRED_FLT1\t\t\t0x264\n#define VDPU_REG_PRED_FLT2\t\t\t0x268\n#define VDPU_REG_PRED_FLT3\t\t\t0x26c\n#define VDPU_REG_PRED_FLT4\t\t\t0x270\n#define VDPU_REG_PRED_FLT5\t\t\t0x274\n#define VDPU_REG_PRED_FLT6\t\t\t0x278\n\nstatic const struct hantro_reg vp8_dec_dct_base[8] = {\n\t{ VDPU_REG_ADDR_STR, 0, 0xffffffff },\n\t{ VDPU_REG_VP8_DCT_BASE(0), 0, 0xffffffff },\n\t{ VDPU_REG_VP8_DCT_BASE(1), 0, 0xffffffff },\n\t{ VDPU_REG_VP8_DCT_BASE(2), 0, 0xffffffff },\n\t{ VDPU_REG_VP8_DCT_BASE(3), 0, 0xffffffff },\n\t{ VDPU_REG_VP8_DCT_BASE(4), 0, 0xffffffff },\n\t{ VDPU_REG_VP8_DCT_BASE(5), 0, 0xffffffff },\n\t{ VDPU_REG_VP8_DCT_BASE(6), 0, 0xffffffff },\n};\n\nstatic const struct hantro_reg vp8_dec_lf_level[4] = {\n\t{ VDPU_REG_FILTER_LEVEL, 18, 0x3f },\n\t{ VDPU_REG_FILTER_LEVEL, 12, 0x3f },\n\t{ VDPU_REG_FILTER_LEVEL, 6, 0x3f },\n\t{ VDPU_REG_FILTER_LEVEL, 0, 0x3f },\n};\n\nstatic const struct hantro_reg vp8_dec_mb_adj[4] = {\n\t{ VDPU_REG_FILTER_MB_ADJ, 21, 0x7f },\n\t{ VDPU_REG_FILTER_MB_ADJ, 14, 0x7f },\n\t{ VDPU_REG_FILTER_MB_ADJ, 7, 0x7f },\n\t{ VDPU_REG_FILTER_MB_ADJ, 0, 0x7f },\n};\n\nstatic const struct hantro_reg vp8_dec_ref_adj[4] = {\n\t{ VDPU_REG_FILTER_REF_ADJ, 21, 0x7f },\n\t{ VDPU_REG_FILTER_REF_ADJ, 14, 0x7f },\n\t{ VDPU_REG_FILTER_REF_ADJ, 7, 0x7f },\n\t{ VDPU_REG_FILTER_REF_ADJ, 0, 0x7f },\n};\n\nstatic const struct hantro_reg vp8_dec_quant[4] = {\n\t{ VDPU_REG_VP8_QUANTER0, 11, 0x7ff },\n\t{ VDPU_REG_VP8_QUANTER0, 0, 0x7ff },\n\t{ VDPU_REG_VP8_QUANTER1, 11, 0x7ff },\n\t{ VDPU_REG_VP8_QUANTER1, 0, 0x7ff },\n};\n\nstatic const struct hantro_reg vp8_dec_quant_delta[5] = {\n\t{ VDPU_REG_VP8_QUANTER0, 27, 0x1f },\n\t{ VDPU_REG_VP8_QUANTER0, 22, 0x1f },\n\t{ VDPU_REG_VP8_QUANTER1, 27, 0x1f },\n\t{ VDPU_REG_VP8_QUANTER1, 22, 0x1f },\n\t{ VDPU_REG_VP8_QUANTER2, 27, 0x1f },\n};\n\nstatic const struct hantro_reg vp8_dec_dct_start_bits[8] = {\n\t{ VDPU_REG_VP8_CTRL0, 26, 0x3f },\n\t{ VDPU_REG_VP8_DCT_START_BIT, 26, 0x3f },\n\t{ VDPU_REG_VP8_DCT_START_BIT, 20, 0x3f },\n\t{ VDPU_REG_VP8_DCT_START_BIT2, 24, 0x3f },\n\t{ VDPU_REG_VP8_DCT_START_BIT2, 18, 0x3f },\n\t{ VDPU_REG_VP8_DCT_START_BIT2, 12, 0x3f },\n\t{ VDPU_REG_VP8_DCT_START_BIT2, 6, 0x3f },\n\t{ VDPU_REG_VP8_DCT_START_BIT2, 0, 0x3f },\n};\n\nstatic const struct hantro_reg vp8_dec_pred_bc_tap[8][6] = {\n\t{\n\t\t{ 0, 0, 0},\n\t\t{ VDPU_REG_PRED_FLT, 22, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT, 12, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT, 2, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT1, 22, 0x3ff },\n\t\t{ 0, 0, 0},\n\t}, {\n\t\t{ 0, 0, 0},\n\t\t{ VDPU_REG_PRED_FLT1, 12, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT1, 2, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT2, 22, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT2, 12, 0x3ff },\n\t\t{ 0, 0, 0},\n\t}, {\n\t\t{ VDPU_REG_PRED_FLT10, 10, 0x3 },\n\t\t{ VDPU_REG_PRED_FLT2, 2, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT3, 22, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT3, 12, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT3, 2, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT10, 8, 0x3},\n\t}, {\n\t\t{ 0, 0, 0},\n\t\t{ VDPU_REG_PRED_FLT4, 22, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT4, 12, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT4, 2, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT5, 22, 0x3ff },\n\t\t{ 0, 0, 0},\n\t}, {\n\t\t{ VDPU_REG_PRED_FLT10, 6, 0x3 },\n\t\t{ VDPU_REG_PRED_FLT5, 12, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT5, 2, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT6, 22, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT6, 12, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT10, 4, 0x3 },\n\t}, {\n\t\t{ 0, 0, 0},\n\t\t{ VDPU_REG_PRED_FLT6, 2, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT7, 22, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT7, 12, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT7, 2, 0x3ff },\n\t\t{ 0, 0, 0},\n\t}, {\n\t\t{ VDPU_REG_PRED_FLT10, 2, 0x3 },\n\t\t{ VDPU_REG_PRED_FLT8, 22, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT8, 12, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT8, 2, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT9, 22, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT10, 0, 0x3 },\n\t}, {\n\t\t{ 0, 0, 0},\n\t\t{ VDPU_REG_PRED_FLT9, 12, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT9, 2, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT10, 22, 0x3ff },\n\t\t{ VDPU_REG_PRED_FLT10, 12, 0x3ff },\n\t\t{ 0, 0, 0},\n\t},\n};\n\nstatic const struct hantro_reg vp8_dec_mb_start_bit = {\n\t.base = VDPU_REG_VP8_CTRL0,\n\t.shift = 18,\n\t.mask = 0x3f\n};\n\nstatic const struct hantro_reg vp8_dec_mb_aligned_data_len = {\n\t.base = VDPU_REG_VP8_DATA_VAL,\n\t.shift = 0,\n\t.mask = 0x3fffff\n};\n\nstatic const struct hantro_reg vp8_dec_num_dct_partitions = {\n\t.base = VDPU_REG_VP8_DATA_VAL,\n\t.shift = 24,\n\t.mask = 0xf\n};\n\nstatic const struct hantro_reg vp8_dec_stream_len = {\n\t.base = VDPU_REG_STREAM_LEN,\n\t.shift = 0,\n\t.mask = 0xffffff\n};\n\nstatic const struct hantro_reg vp8_dec_mb_width = {\n\t.base = VDPU_REG_VP8_PIC_MB_SIZE,\n\t.shift = 23,\n\t.mask = 0x1ff\n};\n\nstatic const struct hantro_reg vp8_dec_mb_height = {\n\t.base = VDPU_REG_VP8_PIC_MB_SIZE,\n\t.shift = 11,\n\t.mask = 0xff\n};\n\nstatic const struct hantro_reg vp8_dec_mb_width_ext = {\n\t.base = VDPU_REG_VP8_PIC_MB_SIZE,\n\t.shift = 3,\n\t.mask = 0x7\n};\n\nstatic const struct hantro_reg vp8_dec_mb_height_ext = {\n\t.base = VDPU_REG_VP8_PIC_MB_SIZE,\n\t.shift = 0,\n\t.mask = 0x7\n};\n\nstatic const struct hantro_reg vp8_dec_bool_range = {\n\t.base = VDPU_REG_VP8_CTRL0,\n\t.shift = 0,\n\t.mask = 0xff\n};\n\nstatic const struct hantro_reg vp8_dec_bool_value = {\n\t.base = VDPU_REG_VP8_CTRL0,\n\t.shift = 8,\n\t.mask = 0xff\n};\n\nstatic const struct hantro_reg vp8_dec_filter_disable = {\n\t.base = VDPU_REG_DEC_CTRL0,\n\t.shift = 8,\n\t.mask = 1\n};\n\nstatic const struct hantro_reg vp8_dec_skip_mode = {\n\t.base = VDPU_REG_DEC_CTRL0,\n\t.shift = 9,\n\t.mask = 1\n};\n\nstatic const struct hantro_reg vp8_dec_start_dec = {\n\t.base = VDPU_REG_EN_FLAGS,\n\t.shift = 0,\n\t.mask = 1\n};\n\nstatic void cfg_lf(struct hantro_ctx *ctx,\n\t\t   const struct v4l2_ctrl_vp8_frame *hdr)\n{\n\tconst struct v4l2_vp8_segment *seg = &hdr->segment;\n\tconst struct v4l2_vp8_loop_filter *lf = &hdr->lf;\n\tstruct hantro_dev *vpu = ctx->dev;\n\tunsigned int i;\n\tu32 reg;\n\n\tif (!(seg->flags & V4L2_VP8_SEGMENT_FLAG_ENABLED)) {\n\t\thantro_reg_write(vpu, &vp8_dec_lf_level[0], lf->level);\n\t} else if (seg->flags & V4L2_VP8_SEGMENT_FLAG_DELTA_VALUE_MODE) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tu32 lf_level = clamp(lf->level + seg->lf_update[i],\n\t\t\t\t\t     0, 63);\n\n\t\t\thantro_reg_write(vpu, &vp8_dec_lf_level[i], lf_level);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\thantro_reg_write(vpu, &vp8_dec_lf_level[i],\n\t\t\t\t\t seg->lf_update[i]);\n\t}\n\n\treg = VDPU_REG_REF_PIC_FILT_SHARPNESS(lf->sharpness_level);\n\tif (lf->flags & V4L2_VP8_LF_FILTER_TYPE_SIMPLE)\n\t\treg |= VDPU_REG_REF_PIC_FILT_TYPE_E;\n\tvdpu_write_relaxed(vpu, reg, VDPU_REG_FILTER_MB_ADJ);\n\n\tif (lf->flags & V4L2_VP8_LF_ADJ_ENABLE) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\thantro_reg_write(vpu, &vp8_dec_mb_adj[i],\n\t\t\t\t\t lf->mb_mode_delta[i]);\n\t\t\thantro_reg_write(vpu, &vp8_dec_ref_adj[i],\n\t\t\t\t\t lf->ref_frm_delta[i]);\n\t\t}\n\t}\n}\n\nstatic void cfg_qp(struct hantro_ctx *ctx,\n\t\t   const struct v4l2_ctrl_vp8_frame *hdr)\n{\n\tconst struct v4l2_vp8_quantization *q = &hdr->quant;\n\tconst struct v4l2_vp8_segment *seg = &hdr->segment;\n\tstruct hantro_dev *vpu = ctx->dev;\n\tunsigned int i;\n\n\tif (!(seg->flags & V4L2_VP8_SEGMENT_FLAG_ENABLED)) {\n\t\thantro_reg_write(vpu, &vp8_dec_quant[0], q->y_ac_qi);\n\t} else if (seg->flags & V4L2_VP8_SEGMENT_FLAG_DELTA_VALUE_MODE) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tu32 quant = clamp(q->y_ac_qi + seg->quant_update[i],\n\t\t\t\t\t  0, 127);\n\n\t\t\thantro_reg_write(vpu, &vp8_dec_quant[i], quant);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\thantro_reg_write(vpu, &vp8_dec_quant[i],\n\t\t\t\t\t seg->quant_update[i]);\n\t}\n\n\thantro_reg_write(vpu, &vp8_dec_quant_delta[0], q->y_dc_delta);\n\thantro_reg_write(vpu, &vp8_dec_quant_delta[1], q->y2_dc_delta);\n\thantro_reg_write(vpu, &vp8_dec_quant_delta[2], q->y2_ac_delta);\n\thantro_reg_write(vpu, &vp8_dec_quant_delta[3], q->uv_dc_delta);\n\thantro_reg_write(vpu, &vp8_dec_quant_delta[4], q->uv_ac_delta);\n}\n\nstatic void cfg_parts(struct hantro_ctx *ctx,\n\t\t      const struct v4l2_ctrl_vp8_frame *hdr)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tstruct vb2_v4l2_buffer *vb2_src;\n\tu32 first_part_offset = V4L2_VP8_FRAME_IS_KEY_FRAME(hdr) ? 10 : 3;\n\tu32 mb_size, mb_offset_bytes, mb_offset_bits, mb_start_bits;\n\tu32 dct_size_part_size, dct_part_offset;\n\tdma_addr_t src_dma;\n\tu32 dct_part_total_len = 0;\n\tu32 count = 0;\n\tunsigned int i;\n\n\tvb2_src = hantro_get_src_buf(ctx);\n\tsrc_dma = vb2_dma_contig_plane_dma_addr(&vb2_src->vb2_buf, 0);\n\n\t \n\tmb_offset_bits = first_part_offset * 8 +\n\t\t\t hdr->first_part_header_bits + 8;\n\tmb_offset_bytes = mb_offset_bits / 8;\n\tmb_start_bits = mb_offset_bits -\n\t\t\t(mb_offset_bytes & (~DEC_8190_ALIGN_MASK)) * 8;\n\tmb_size = hdr->first_part_size -\n\t\t  (mb_offset_bytes - first_part_offset) +\n\t\t  (mb_offset_bytes & DEC_8190_ALIGN_MASK);\n\n\t \n\tvdpu_write_relaxed(vpu, (mb_offset_bytes & (~DEC_8190_ALIGN_MASK)) +\n\t\t\t   src_dma, VDPU_REG_VP8_ADDR_CTRL_PART);\n\thantro_reg_write(vpu, &vp8_dec_mb_start_bit, mb_start_bits);\n\thantro_reg_write(vpu, &vp8_dec_mb_aligned_data_len, mb_size);\n\n\t \n\tdct_size_part_size = (hdr->num_dct_parts - 1) * 3;\n\tdct_part_offset = first_part_offset + hdr->first_part_size;\n\tfor (i = 0; i < hdr->num_dct_parts; i++)\n\t\tdct_part_total_len += hdr->dct_part_sizes[i];\n\tdct_part_total_len += dct_size_part_size;\n\tdct_part_total_len += (dct_part_offset & DEC_8190_ALIGN_MASK);\n\n\t \n\thantro_reg_write(vpu, &vp8_dec_num_dct_partitions,\n\t\t\t hdr->num_dct_parts - 1);\n\n\t \n\thantro_reg_write(vpu, &vp8_dec_stream_len, dct_part_total_len);\n\n\t \n\tfor (i = 0; i < hdr->num_dct_parts; i++) {\n\t\tu32 byte_offset = dct_part_offset + dct_size_part_size + count;\n\t\tu32 base_addr = byte_offset + src_dma;\n\n\t\thantro_reg_write(vpu, &vp8_dec_dct_base[i],\n\t\t\t\t base_addr & (~DEC_8190_ALIGN_MASK));\n\n\t\thantro_reg_write(vpu, &vp8_dec_dct_start_bits[i],\n\t\t\t\t (byte_offset & DEC_8190_ALIGN_MASK) * 8);\n\n\t\tcount += hdr->dct_part_sizes[i];\n\t}\n}\n\n \nstatic void cfg_tap(struct hantro_ctx *ctx,\n\t\t    const struct v4l2_ctrl_vp8_frame *hdr)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tint i, j;\n\n\tif ((hdr->version & 0x03) != 0)\n\t\treturn;  \n\n\tfor (i = 0; i < 8; i++) {\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tif (vp8_dec_pred_bc_tap[i][j].base != 0)\n\t\t\t\thantro_reg_write(vpu,\n\t\t\t\t\t\t &vp8_dec_pred_bc_tap[i][j],\n\t\t\t\t\t\t hantro_vp8_dec_mc_filter[i][j]);\n\t\t}\n\t}\n}\n\nstatic void cfg_ref(struct hantro_ctx *ctx,\n\t\t    const struct v4l2_ctrl_vp8_frame *hdr,\n\t\t    struct vb2_v4l2_buffer *vb2_dst)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tdma_addr_t ref;\n\n\tref = hantro_get_ref(ctx, hdr->last_frame_ts);\n\tif (!ref) {\n\t\tvpu_debug(0, \"failed to find last frame ts=%llu\\n\",\n\t\t\t  hdr->last_frame_ts);\n\t\tref = vb2_dma_contig_plane_dma_addr(&vb2_dst->vb2_buf, 0);\n\t}\n\tvdpu_write_relaxed(vpu, ref, VDPU_REG_VP8_ADDR_REF0);\n\n\tref = hantro_get_ref(ctx, hdr->golden_frame_ts);\n\tif (!ref && hdr->golden_frame_ts)\n\t\tvpu_debug(0, \"failed to find golden frame ts=%llu\\n\",\n\t\t\t  hdr->golden_frame_ts);\n\tif (!ref)\n\t\tref = vb2_dma_contig_plane_dma_addr(&vb2_dst->vb2_buf, 0);\n\tif (hdr->flags & V4L2_VP8_FRAME_FLAG_SIGN_BIAS_GOLDEN)\n\t\tref |= VDPU_REG_VP8_GREF_SIGN_BIAS;\n\tvdpu_write_relaxed(vpu, ref, VDPU_REG_VP8_ADDR_REF2_5(2));\n\n\tref = hantro_get_ref(ctx, hdr->alt_frame_ts);\n\tif (!ref && hdr->alt_frame_ts)\n\t\tvpu_debug(0, \"failed to find alt frame ts=%llu\\n\",\n\t\t\t  hdr->alt_frame_ts);\n\tif (!ref)\n\t\tref = vb2_dma_contig_plane_dma_addr(&vb2_dst->vb2_buf, 0);\n\tif (hdr->flags & V4L2_VP8_FRAME_FLAG_SIGN_BIAS_ALT)\n\t\tref |= VDPU_REG_VP8_AREF_SIGN_BIAS;\n\tvdpu_write_relaxed(vpu, ref, VDPU_REG_VP8_ADDR_REF2_5(3));\n}\n\nstatic void cfg_buffers(struct hantro_ctx *ctx,\n\t\t\tconst struct v4l2_ctrl_vp8_frame *hdr,\n\t\t\tstruct vb2_v4l2_buffer *vb2_dst)\n{\n\tconst struct v4l2_vp8_segment *seg = &hdr->segment;\n\tstruct hantro_dev *vpu = ctx->dev;\n\tdma_addr_t dst_dma;\n\tu32 reg;\n\n\t \n\tvdpu_write_relaxed(vpu, ctx->vp8_dec.prob_tbl.dma,\n\t\t\t   VDPU_REG_ADDR_QTABLE);\n\n\t \n\treg = VDPU_REG_FWD_PIC1_SEGMENT_BASE(ctx->vp8_dec.segment_map.dma);\n\tif (seg->flags & V4L2_VP8_SEGMENT_FLAG_ENABLED) {\n\t\treg |= VDPU_REG_FWD_PIC1_SEGMENT_E;\n\t\tif (seg->flags & V4L2_VP8_SEGMENT_FLAG_UPDATE_MAP)\n\t\t\treg |= VDPU_REG_FWD_PIC1_SEGMENT_UPD_E;\n\t}\n\tvdpu_write_relaxed(vpu, reg, VDPU_REG_VP8_SEGMENT_VAL);\n\n\t \n\tdst_dma = vb2_dma_contig_plane_dma_addr(&vb2_dst->vb2_buf, 0);\n\tvdpu_write_relaxed(vpu, dst_dma, VDPU_REG_ADDR_DST);\n}\n\nint rockchip_vpu2_vp8_dec_run(struct hantro_ctx *ctx)\n{\n\tconst struct v4l2_ctrl_vp8_frame *hdr;\n\tstruct hantro_dev *vpu = ctx->dev;\n\tstruct vb2_v4l2_buffer *vb2_dst;\n\tsize_t height = ctx->dst_fmt.height;\n\tsize_t width = ctx->dst_fmt.width;\n\tu32 mb_width, mb_height;\n\tu32 reg;\n\n\thantro_start_prepare_run(ctx);\n\n\thdr = hantro_get_ctrl(ctx, V4L2_CID_STATELESS_VP8_FRAME);\n\tif (WARN_ON(!hdr))\n\t\treturn -EINVAL;\n\n\t \n\tif (V4L2_VP8_FRAME_IS_KEY_FRAME(hdr) && ctx->vp8_dec.segment_map.cpu)\n\t\tmemset(ctx->vp8_dec.segment_map.cpu, 0,\n\t\t       ctx->vp8_dec.segment_map.size);\n\n\thantro_vp8_prob_update(ctx, hdr);\n\n\t \n\tctx->codec_ops->reset(ctx);\n\n\treg = VDPU_REG_CONFIG_DEC_TIMEOUT_E\n\t\t| VDPU_REG_CONFIG_DEC_CLK_GATE_E;\n\tif (!V4L2_VP8_FRAME_IS_KEY_FRAME(hdr))\n\t\treg |= VDPU_REG_DEC_CTRL0_PIC_INTER_E;\n\tvdpu_write_relaxed(vpu, reg, VDPU_REG_EN_FLAGS);\n\n\treg = VDPU_REG_CONFIG_DEC_STRENDIAN_E\n\t\t| VDPU_REG_CONFIG_DEC_INSWAP32_E\n\t\t| VDPU_REG_CONFIG_DEC_STRSWAP32_E\n\t\t| VDPU_REG_CONFIG_DEC_OUTSWAP32_E\n\t\t| VDPU_REG_CONFIG_DEC_IN_ENDIAN\n\t\t| VDPU_REG_CONFIG_DEC_OUT_ENDIAN;\n\tvdpu_write_relaxed(vpu, reg, VDPU_REG_DATA_ENDIAN);\n\n\treg = VDPU_REG_CONFIG_DEC_MAX_BURST(16);\n\tvdpu_write_relaxed(vpu, reg, VDPU_REG_AXI_CTRL);\n\n\treg = VDPU_REG_DEC_CTRL0_DEC_MODE(10);\n\tvdpu_write_relaxed(vpu, reg, VDPU_REG_DEC_FORMAT);\n\n\tif (!(hdr->flags & V4L2_VP8_FRAME_FLAG_MB_NO_SKIP_COEFF))\n\t\thantro_reg_write(vpu, &vp8_dec_skip_mode, 1);\n\tif (hdr->lf.level == 0)\n\t\thantro_reg_write(vpu, &vp8_dec_filter_disable, 1);\n\n\t \n\tmb_width = MB_WIDTH(width);\n\tmb_height = MB_HEIGHT(height);\n\n\thantro_reg_write(vpu, &vp8_dec_mb_width, mb_width);\n\thantro_reg_write(vpu, &vp8_dec_mb_height, mb_height);\n\thantro_reg_write(vpu, &vp8_dec_mb_width_ext, mb_width >> 9);\n\thantro_reg_write(vpu, &vp8_dec_mb_height_ext, mb_height >> 8);\n\n\t \n\thantro_reg_write(vpu, &vp8_dec_bool_range, hdr->coder_state.range);\n\thantro_reg_write(vpu, &vp8_dec_bool_value, hdr->coder_state.value);\n\n\treg = vdpu_read(vpu, VDPU_REG_VP8_DCT_START_BIT);\n\tif (hdr->version != 3)\n\t\treg |= VDPU_REG_DEC_CTRL4_VC1_HEIGHT_EXT;\n\tif (hdr->version & 0x3)\n\t\treg |= VDPU_REG_DEC_CTRL4_BILIN_MC_E;\n\tvdpu_write_relaxed(vpu, reg, VDPU_REG_VP8_DCT_START_BIT);\n\n\tcfg_lf(ctx, hdr);\n\tcfg_qp(ctx, hdr);\n\tcfg_parts(ctx, hdr);\n\tcfg_tap(ctx, hdr);\n\n\tvb2_dst = hantro_get_dst_buf(ctx);\n\tcfg_ref(ctx, hdr, vb2_dst);\n\tcfg_buffers(ctx, hdr, vb2_dst);\n\n\thantro_end_prepare_run(ctx);\n\n\thantro_reg_write(vpu, &vp8_dec_start_dec, 1);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}