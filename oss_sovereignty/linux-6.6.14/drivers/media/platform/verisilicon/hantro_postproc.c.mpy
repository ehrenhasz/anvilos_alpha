{
  "module_name": "hantro_postproc.c",
  "hash_id": "ae4936b628502caf3c7e1776723bc4fdb80c3a9e446f2b7de52203e483bf10c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/verisilicon/hantro_postproc.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/types.h>\n\n#include \"hantro.h\"\n#include \"hantro_hw.h\"\n#include \"hantro_g1_regs.h\"\n#include \"hantro_g2_regs.h\"\n#include \"hantro_v4l2.h\"\n\n#define HANTRO_PP_REG_WRITE(vpu, reg_name, val) \\\n{ \\\n\thantro_reg_write(vpu, \\\n\t\t\t &hantro_g1_postproc_regs.reg_name, \\\n\t\t\t val); \\\n}\n\n#define HANTRO_PP_REG_WRITE_RELAXED(vpu, reg_name, val) \\\n{ \\\n\thantro_reg_write_relaxed(vpu, \\\n\t\t\t\t &hantro_g1_postproc_regs.reg_name, \\\n\t\t\t\t val); \\\n}\n\n#define VPU_PP_IN_YUYV\t\t\t0x0\n#define VPU_PP_IN_NV12\t\t\t0x1\n#define VPU_PP_IN_YUV420\t\t0x2\n#define VPU_PP_IN_YUV240_TILED\t\t0x5\n#define VPU_PP_OUT_RGB\t\t\t0x0\n#define VPU_PP_OUT_YUYV\t\t\t0x3\n\nstatic const struct hantro_postproc_regs hantro_g1_postproc_regs = {\n\t.pipeline_en = {G1_REG_PP_INTERRUPT, 1, 0x1},\n\t.max_burst = {G1_REG_PP_DEV_CONFIG, 0, 0x1f},\n\t.clk_gate = {G1_REG_PP_DEV_CONFIG, 1, 0x1},\n\t.out_swap32 = {G1_REG_PP_DEV_CONFIG, 5, 0x1},\n\t.out_endian = {G1_REG_PP_DEV_CONFIG, 6, 0x1},\n\t.out_luma_base = {G1_REG_PP_OUT_LUMA_BASE, 0, 0xffffffff},\n\t.input_width = {G1_REG_PP_INPUT_SIZE, 0, 0x1ff},\n\t.input_height = {G1_REG_PP_INPUT_SIZE, 9, 0x1ff},\n\t.output_width = {G1_REG_PP_CONTROL, 4, 0x7ff},\n\t.output_height = {G1_REG_PP_CONTROL, 15, 0x7ff},\n\t.input_fmt = {G1_REG_PP_CONTROL, 29, 0x7},\n\t.output_fmt = {G1_REG_PP_CONTROL, 26, 0x7},\n\t.orig_width = {G1_REG_PP_MASK1_ORIG_WIDTH, 23, 0x1ff},\n\t.display_width = {G1_REG_PP_DISPLAY_WIDTH, 0, 0xfff},\n};\n\nbool hantro_needs_postproc(const struct hantro_ctx *ctx,\n\t\t\t   const struct hantro_fmt *fmt)\n{\n\tif (ctx->is_encoder)\n\t\treturn false;\n\n\tif (ctx->need_postproc)\n\t\treturn true;\n\n\treturn fmt->postprocessed;\n}\n\nstatic void hantro_postproc_g1_enable(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tstruct vb2_v4l2_buffer *dst_buf;\n\tu32 src_pp_fmt, dst_pp_fmt;\n\tdma_addr_t dst_dma;\n\n\t \n\tHANTRO_PP_REG_WRITE(vpu, pipeline_en, 0x1);\n\n\tsrc_pp_fmt = VPU_PP_IN_NV12;\n\n\tswitch (ctx->vpu_dst_fmt->fourcc) {\n\tcase V4L2_PIX_FMT_YUYV:\n\t\tdst_pp_fmt = VPU_PP_OUT_YUYV;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"output format %d not supported by the post-processor, this wasn't expected.\",\n\t\t     ctx->vpu_dst_fmt->fourcc);\n\t\tdst_pp_fmt = 0;\n\t\tbreak;\n\t}\n\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tdst_dma = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\n\tHANTRO_PP_REG_WRITE(vpu, clk_gate, 0x1);\n\tHANTRO_PP_REG_WRITE(vpu, out_endian, 0x1);\n\tHANTRO_PP_REG_WRITE(vpu, out_swap32, 0x1);\n\tHANTRO_PP_REG_WRITE(vpu, max_burst, 16);\n\tHANTRO_PP_REG_WRITE(vpu, out_luma_base, dst_dma);\n\tHANTRO_PP_REG_WRITE(vpu, input_width, MB_WIDTH(ctx->dst_fmt.width));\n\tHANTRO_PP_REG_WRITE(vpu, input_height, MB_HEIGHT(ctx->dst_fmt.height));\n\tHANTRO_PP_REG_WRITE(vpu, input_fmt, src_pp_fmt);\n\tHANTRO_PP_REG_WRITE(vpu, output_fmt, dst_pp_fmt);\n\tHANTRO_PP_REG_WRITE(vpu, output_width, ctx->dst_fmt.width);\n\tHANTRO_PP_REG_WRITE(vpu, output_height, ctx->dst_fmt.height);\n\tHANTRO_PP_REG_WRITE(vpu, orig_width, MB_WIDTH(ctx->dst_fmt.width));\n\tHANTRO_PP_REG_WRITE(vpu, display_width, ctx->dst_fmt.width);\n}\n\nstatic int down_scale_factor(struct hantro_ctx *ctx)\n{\n\tif (ctx->src_fmt.width <= ctx->dst_fmt.width)\n\t\treturn 0;\n\n\treturn DIV_ROUND_CLOSEST(ctx->src_fmt.width, ctx->dst_fmt.width);\n}\n\nstatic void hantro_postproc_g2_enable(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tstruct vb2_v4l2_buffer *dst_buf;\n\tint down_scale = down_scale_factor(ctx);\n\tint out_depth;\n\tsize_t chroma_offset;\n\tdma_addr_t dst_dma;\n\n\tdst_buf = hantro_get_dst_buf(ctx);\n\tdst_dma = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\tchroma_offset = ctx->dst_fmt.plane_fmt[0].bytesperline *\n\t\t\tctx->dst_fmt.height;\n\n\tif (down_scale) {\n\t\thantro_reg_write(vpu, &g2_down_scale_e, 1);\n\t\thantro_reg_write(vpu, &g2_down_scale_y, down_scale >> 2);\n\t\thantro_reg_write(vpu, &g2_down_scale_x, down_scale >> 2);\n\t\thantro_write_addr(vpu, G2_DS_DST, dst_dma);\n\t\thantro_write_addr(vpu, G2_DS_DST_CHR, dst_dma + (chroma_offset >> down_scale));\n\t} else {\n\t\thantro_write_addr(vpu, G2_RS_OUT_LUMA_ADDR, dst_dma);\n\t\thantro_write_addr(vpu, G2_RS_OUT_CHROMA_ADDR, dst_dma + chroma_offset);\n\t}\n\n\tout_depth = hantro_get_format_depth(ctx->dst_fmt.pixelformat);\n\tif (ctx->dev->variant->legacy_regs) {\n\t\tu8 pp_shift = 0;\n\n\t\tif (out_depth > 8)\n\t\t\tpp_shift = 16 - out_depth;\n\n\t\thantro_reg_write(ctx->dev, &g2_rs_out_bit_depth, out_depth);\n\t\thantro_reg_write(ctx->dev, &g2_pp_pix_shift, pp_shift);\n\t} else {\n\t\thantro_reg_write(vpu, &g2_output_8_bits, out_depth > 8 ? 0 : 1);\n\t\thantro_reg_write(vpu, &g2_output_format, out_depth > 8 ? 1 : 0);\n\t}\n\thantro_reg_write(vpu, &g2_out_rs_e, 1);\n}\n\nstatic int hantro_postproc_g2_enum_framesizes(struct hantro_ctx *ctx,\n\t\t\t\t\t      struct v4l2_frmsizeenum *fsize)\n{\n\t \n\tif (fsize->index > 3)\n\t\treturn -EINVAL;\n\n\tif (!ctx->src_fmt.width || !ctx->src_fmt.height)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = ctx->src_fmt.width >> fsize->index;\n\tfsize->discrete.height = ctx->src_fmt.height >> fsize->index;\n\n\treturn 0;\n}\n\nvoid hantro_postproc_free(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tunsigned int i;\n\n\tfor (i = 0; i < VB2_MAX_FRAME; ++i) {\n\t\tstruct hantro_aux_buf *priv = &ctx->postproc.dec_q[i];\n\n\t\tif (priv->cpu) {\n\t\t\tdma_free_attrs(vpu->dev, priv->size, priv->cpu,\n\t\t\t\t       priv->dma, priv->attrs);\n\t\t\tpriv->cpu = NULL;\n\t\t}\n\t}\n}\n\nint hantro_postproc_alloc(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tstruct v4l2_m2m_ctx *m2m_ctx = ctx->fh.m2m_ctx;\n\tstruct vb2_queue *cap_queue = &m2m_ctx->cap_q_ctx.q;\n\tunsigned int num_buffers = cap_queue->num_buffers;\n\tstruct v4l2_pix_format_mplane pix_mp;\n\tconst struct hantro_fmt *fmt;\n\tunsigned int i, buf_size;\n\n\t \n\tfmt = hantro_get_default_fmt(ctx, false, ctx->bit_depth, HANTRO_AUTO_POSTPROC);\n\tif (!fmt)\n\t\treturn -EINVAL;\n\tv4l2_fill_pixfmt_mp(&pix_mp, fmt->fourcc, ctx->src_fmt.width,\n\t\t\t    ctx->src_fmt.height);\n\n\tbuf_size = pix_mp.plane_fmt[0].sizeimage;\n\tif (ctx->vpu_src_fmt->fourcc == V4L2_PIX_FMT_H264_SLICE)\n\t\tbuf_size += hantro_h264_mv_size(pix_mp.width,\n\t\t\t\t\t\tpix_mp.height);\n\telse if (ctx->vpu_src_fmt->fourcc == V4L2_PIX_FMT_VP9_FRAME)\n\t\tbuf_size += hantro_vp9_mv_size(pix_mp.width,\n\t\t\t\t\t       pix_mp.height);\n\telse if (ctx->vpu_src_fmt->fourcc == V4L2_PIX_FMT_HEVC_SLICE)\n\t\tbuf_size += hantro_hevc_mv_size(pix_mp.width,\n\t\t\t\t\t\tpix_mp.height);\n\telse if (ctx->vpu_src_fmt->fourcc == V4L2_PIX_FMT_AV1_FRAME)\n\t\tbuf_size += hantro_av1_mv_size(pix_mp.width,\n\t\t\t\t\t       pix_mp.height);\n\n\tfor (i = 0; i < num_buffers; ++i) {\n\t\tstruct hantro_aux_buf *priv = &ctx->postproc.dec_q[i];\n\n\t\t \n\t\tpriv->attrs = DMA_ATTR_NO_KERNEL_MAPPING;\n\t\tpriv->cpu = dma_alloc_attrs(vpu->dev, buf_size, &priv->dma,\n\t\t\t\t\t    GFP_KERNEL, priv->attrs);\n\t\tif (!priv->cpu)\n\t\t\treturn -ENOMEM;\n\t\tpriv->size = buf_size;\n\t}\n\treturn 0;\n}\n\nstatic void hantro_postproc_g1_disable(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\n\tHANTRO_PP_REG_WRITE(vpu, pipeline_en, 0x0);\n}\n\nstatic void hantro_postproc_g2_disable(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\n\thantro_reg_write(vpu, &g2_out_rs_e, 0);\n}\n\nvoid hantro_postproc_disable(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\n\tif (vpu->variant->postproc_ops && vpu->variant->postproc_ops->disable)\n\t\tvpu->variant->postproc_ops->disable(ctx);\n}\n\nvoid hantro_postproc_enable(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\n\tif (vpu->variant->postproc_ops && vpu->variant->postproc_ops->enable)\n\t\tvpu->variant->postproc_ops->enable(ctx);\n}\n\nint hanto_postproc_enum_framesizes(struct hantro_ctx *ctx,\n\t\t\t\t   struct v4l2_frmsizeenum *fsize)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\n\tif (vpu->variant->postproc_ops && vpu->variant->postproc_ops->enum_framesizes)\n\t\treturn vpu->variant->postproc_ops->enum_framesizes(ctx, fsize);\n\n\treturn -EINVAL;\n}\n\nconst struct hantro_postproc_ops hantro_g1_postproc_ops = {\n\t.enable = hantro_postproc_g1_enable,\n\t.disable = hantro_postproc_g1_disable,\n};\n\nconst struct hantro_postproc_ops hantro_g2_postproc_ops = {\n\t.enable = hantro_postproc_g2_enable,\n\t.disable = hantro_postproc_g2_disable,\n\t.enum_framesizes = hantro_postproc_g2_enum_framesizes,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}