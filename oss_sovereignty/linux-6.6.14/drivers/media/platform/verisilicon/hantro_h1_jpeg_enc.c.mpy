{
  "module_name": "hantro_h1_jpeg_enc.c",
  "hash_id": "21bebe1992baede61610eae2b7408cd5537f3c2142343dd88d6bf635bcea8123",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/verisilicon/hantro_h1_jpeg_enc.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <media/v4l2-mem2mem.h>\n#include \"hantro_jpeg.h\"\n#include \"hantro.h\"\n#include \"hantro_v4l2.h\"\n#include \"hantro_hw.h\"\n#include \"hantro_h1_regs.h\"\n\n#define H1_JPEG_QUANT_TABLE_COUNT 16\n\nstatic void hantro_h1_set_src_img_ctrl(struct hantro_dev *vpu,\n\t\t\t\t       struct hantro_ctx *ctx)\n{\n\tu32 overfill_r, overfill_b;\n\tu32 reg;\n\n\t \n\toverfill_r = ctx->src_fmt.width - ctx->dst_fmt.width;\n\toverfill_b = ctx->src_fmt.height - ctx->dst_fmt.height;\n\n\treg = H1_REG_IN_IMG_CTRL_ROW_LEN(ctx->src_fmt.width)\n\t\t| H1_REG_IN_IMG_CTRL_OVRFLR_D4(overfill_r / 4)\n\t\t| H1_REG_IN_IMG_CTRL_OVRFLB(overfill_b)\n\t\t| H1_REG_IN_IMG_CTRL_FMT(ctx->vpu_src_fmt->enc_fmt);\n\tvepu_write_relaxed(vpu, reg, H1_REG_IN_IMG_CTRL);\n}\n\nstatic void hantro_h1_jpeg_enc_set_buffers(struct hantro_dev *vpu,\n\t\t\t\t\t   struct hantro_ctx *ctx,\n\t\t\t\t\t   struct vb2_buffer *src_buf,\n\t\t\t\t\t   struct vb2_buffer *dst_buf)\n{\n\tstruct v4l2_pix_format_mplane *pix_fmt = &ctx->src_fmt;\n\tdma_addr_t src[3];\n\tu32 size_left;\n\n\tsize_left = vb2_plane_size(dst_buf, 0) - ctx->vpu_dst_fmt->header_size;\n\tif (WARN_ON(vb2_plane_size(dst_buf, 0) < ctx->vpu_dst_fmt->header_size))\n\t\tsize_left = 0;\n\n\tWARN_ON(pix_fmt->num_planes > 3);\n\n\tvepu_write_relaxed(vpu, vb2_dma_contig_plane_dma_addr(dst_buf, 0) +\n\t\t\t\tctx->vpu_dst_fmt->header_size,\n\t\t\t   H1_REG_ADDR_OUTPUT_STREAM);\n\tvepu_write_relaxed(vpu, size_left, H1_REG_STR_BUF_LIMIT);\n\n\tif (pix_fmt->num_planes == 1) {\n\t\tsrc[0] = vb2_dma_contig_plane_dma_addr(src_buf, 0);\n\t\t \n\t\tvepu_write_relaxed(vpu, src[0], H1_REG_ADDR_IN_PLANE_0);\n\t} else if (pix_fmt->num_planes == 2) {\n\t\tsrc[0] = vb2_dma_contig_plane_dma_addr(src_buf, 0);\n\t\tsrc[1] = vb2_dma_contig_plane_dma_addr(src_buf, 1);\n\t\tvepu_write_relaxed(vpu, src[0], H1_REG_ADDR_IN_PLANE_0);\n\t\tvepu_write_relaxed(vpu, src[1], H1_REG_ADDR_IN_PLANE_1);\n\t} else {\n\t\tsrc[0] = vb2_dma_contig_plane_dma_addr(src_buf, 0);\n\t\tsrc[1] = vb2_dma_contig_plane_dma_addr(src_buf, 1);\n\t\tsrc[2] = vb2_dma_contig_plane_dma_addr(src_buf, 2);\n\t\tvepu_write_relaxed(vpu, src[0], H1_REG_ADDR_IN_PLANE_0);\n\t\tvepu_write_relaxed(vpu, src[1], H1_REG_ADDR_IN_PLANE_1);\n\t\tvepu_write_relaxed(vpu, src[2], H1_REG_ADDR_IN_PLANE_2);\n\t}\n}\n\nstatic void\nhantro_h1_jpeg_enc_set_qtable(struct hantro_dev *vpu,\n\t\t\t      unsigned char *luma_qtable,\n\t\t\t      unsigned char *chroma_qtable)\n{\n\tu32 reg, i;\n\t__be32 *luma_qtable_p;\n\t__be32 *chroma_qtable_p;\n\n\tluma_qtable_p = (__be32 *)luma_qtable;\n\tchroma_qtable_p = (__be32 *)chroma_qtable;\n\n\t \n\tfor (i = 0; i < H1_JPEG_QUANT_TABLE_COUNT; i++) {\n\t\treg = get_unaligned_be32(&luma_qtable_p[i]);\n\t\tvepu_write_relaxed(vpu, reg, H1_REG_JPEG_LUMA_QUAT(i));\n\t}\n\n\tfor (i = 0; i < H1_JPEG_QUANT_TABLE_COUNT; i++) {\n\t\treg = get_unaligned_be32(&chroma_qtable_p[i]);\n\t\tvepu_write_relaxed(vpu, reg, H1_REG_JPEG_CHROMA_QUAT(i));\n\t}\n}\n\nint hantro_h1_jpeg_enc_run(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct hantro_jpeg_ctx jpeg_ctx;\n\tu32 reg;\n\n\tsrc_buf = hantro_get_src_buf(ctx);\n\tdst_buf = hantro_get_dst_buf(ctx);\n\n\thantro_start_prepare_run(ctx);\n\n\tmemset(&jpeg_ctx, 0, sizeof(jpeg_ctx));\n\tjpeg_ctx.buffer = vb2_plane_vaddr(&dst_buf->vb2_buf, 0);\n\tjpeg_ctx.width = ctx->dst_fmt.width;\n\tjpeg_ctx.height = ctx->dst_fmt.height;\n\tjpeg_ctx.quality = ctx->jpeg_quality;\n\thantro_jpeg_header_assemble(&jpeg_ctx);\n\n\t \n\tvepu_write_relaxed(vpu, H1_REG_ENC_CTRL_ENC_MODE_JPEG,\n\t\t\t   H1_REG_ENC_CTRL);\n\n\thantro_h1_set_src_img_ctrl(vpu, ctx);\n\thantro_h1_jpeg_enc_set_buffers(vpu, ctx, &src_buf->vb2_buf,\n\t\t\t\t       &dst_buf->vb2_buf);\n\thantro_h1_jpeg_enc_set_qtable(vpu, jpeg_ctx.hw_luma_qtable,\n\t\t\t\t      jpeg_ctx.hw_chroma_qtable);\n\n\treg = H1_REG_AXI_CTRL_OUTPUT_SWAP16\n\t\t| H1_REG_AXI_CTRL_INPUT_SWAP16\n\t\t| H1_REG_AXI_CTRL_BURST_LEN(16)\n\t\t| H1_REG_AXI_CTRL_OUTPUT_SWAP32\n\t\t| H1_REG_AXI_CTRL_INPUT_SWAP32\n\t\t| H1_REG_AXI_CTRL_OUTPUT_SWAP8\n\t\t| H1_REG_AXI_CTRL_INPUT_SWAP8;\n\t \n\tvepu_write(vpu, reg, H1_REG_AXI_CTRL);\n\n\treg = H1_REG_ENC_CTRL_WIDTH(MB_WIDTH(ctx->src_fmt.width))\n\t\t| H1_REG_ENC_CTRL_HEIGHT(MB_HEIGHT(ctx->src_fmt.height))\n\t\t| H1_REG_ENC_CTRL_ENC_MODE_JPEG\n\t\t| H1_REG_ENC_PIC_INTRA\n\t\t| H1_REG_ENC_CTRL_EN_BIT;\n\n\thantro_end_prepare_run(ctx);\n\n\tvepu_write(vpu, reg, H1_REG_ENC_CTRL);\n\n\treturn 0;\n}\n\nvoid hantro_h1_jpeg_enc_done(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tu32 bytesused = vepu_read(vpu, H1_REG_STR_BUF_LIMIT) / 8;\n\tstruct vb2_v4l2_buffer *dst_buf = hantro_get_dst_buf(ctx);\n\n\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0,\n\t\t\t      ctx->vpu_dst_fmt->header_size + bytesused);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}