{
  "module_name": "sunxi_vpu_hw.c",
  "hash_id": "6ce8bb38493547d5ea961942d197863f9ace3a0fdaee23fb8bcfc5b1218ef9ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/verisilicon/sunxi_vpu_hw.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n\n#include \"hantro.h\"\n\nstatic const struct hantro_fmt sunxi_vpu_postproc_fmts[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV12,\n\t\t.codec_mode = HANTRO_MODE_NONE,\n\t\t.postprocessed = true,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = 32,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = 32,\n\t\t},\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_P010,\n\t\t.codec_mode = HANTRO_MODE_NONE,\n\t\t.postprocessed = true,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = 32,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = 32,\n\t\t},\n\t},\n};\n\nstatic const struct hantro_fmt sunxi_vpu_dec_fmts[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV12_4L4,\n\t\t.codec_mode = HANTRO_MODE_NONE,\n\t\t.match_depth = true,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = 32,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = 32,\n\t\t},\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_P010_4L4,\n\t\t.codec_mode = HANTRO_MODE_NONE,\n\t\t.match_depth = true,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = 32,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = 32,\n\t\t},\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_VP9_FRAME,\n\t\t.codec_mode = HANTRO_MODE_VP9_DEC,\n\t\t.max_depth = 2,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = 32,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = 32,\n\t\t},\n\t},\n};\n\nstatic int sunxi_vpu_hw_init(struct hantro_dev *vpu)\n{\n\tclk_set_rate(vpu->clocks[0].clk, 300000000);\n\n\treturn 0;\n}\n\nstatic void sunxi_vpu_reset(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\n\treset_control_reset(vpu->resets);\n}\n\nstatic const struct hantro_codec_ops sunxi_vpu_codec_ops[] = {\n\t[HANTRO_MODE_VP9_DEC] = {\n\t\t.run = hantro_g2_vp9_dec_run,\n\t\t.done = hantro_g2_vp9_dec_done,\n\t\t.reset = sunxi_vpu_reset,\n\t\t.init = hantro_vp9_dec_init,\n\t\t.exit = hantro_vp9_dec_exit,\n\t},\n};\n\nstatic const struct hantro_irq sunxi_irqs[] = {\n\t{ NULL, hantro_g2_irq },\n};\n\nstatic const char * const sunxi_clk_names[] = { \"mod\", \"bus\" };\n\nconst struct hantro_variant sunxi_vpu_variant = {\n\t.dec_fmts = sunxi_vpu_dec_fmts,\n\t.num_dec_fmts = ARRAY_SIZE(sunxi_vpu_dec_fmts),\n\t.postproc_fmts = sunxi_vpu_postproc_fmts,\n\t.num_postproc_fmts = ARRAY_SIZE(sunxi_vpu_postproc_fmts),\n\t.postproc_ops = &hantro_g2_postproc_ops,\n\t.codec = HANTRO_VP9_DECODER,\n\t.codec_ops = sunxi_vpu_codec_ops,\n\t.init = sunxi_vpu_hw_init,\n\t.irqs = sunxi_irqs,\n\t.num_irqs = ARRAY_SIZE(sunxi_irqs),\n\t.clk_names = sunxi_clk_names,\n\t.num_clocks = ARRAY_SIZE(sunxi_clk_names),\n\t.double_buffer = 1,\n\t.legacy_regs = 1,\n\t.late_postproc = 1,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}