{
  "module_name": "hantro_vp9.c",
  "hash_id": "4056c7729c099899a6ebb287f32e7161b8a99397014de2b2bd55e8a0eced1c86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/verisilicon/hantro_vp9.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <media/v4l2-mem2mem.h>\n\n#include \"hantro.h\"\n#include \"hantro_hw.h\"\n#include \"hantro_vp9.h\"\n\n#define POW2(x) (1 << (x))\n\n#define MAX_LOG2_TILE_COLUMNS 6\n#define MAX_NUM_TILE_COLS POW2(MAX_LOG2_TILE_COLUMNS)\n#define MAX_TILE_COLS 20\n#define MAX_TILE_ROWS 22\n\nstatic size_t hantro_vp9_tile_filter_size(unsigned int height)\n{\n\tu32 h, height32, size;\n\n\th = roundup(height, 8);\n\n\theight32 = roundup(h, 64);\n\tsize = 24 * height32 * (MAX_NUM_TILE_COLS - 1);  \n\n\treturn size;\n}\n\nstatic size_t hantro_vp9_bsd_control_size(unsigned int height)\n{\n\tu32 h, height32;\n\n\th = roundup(height, 8);\n\theight32 = roundup(h, 64);\n\n\treturn 16 * (height32 / 4) * (MAX_NUM_TILE_COLS - 1);\n}\n\nstatic size_t hantro_vp9_segment_map_size(unsigned int width, unsigned int height)\n{\n\tu32 w, h;\n\tint num_ctbs;\n\n\tw = roundup(width, 8);\n\th = roundup(height, 8);\n\tnum_ctbs = ((w + 63) / 64) * ((h + 63) / 64);\n\n\treturn num_ctbs * 32;\n}\n\nstatic inline size_t hantro_vp9_prob_tab_size(void)\n{\n\treturn roundup(sizeof(struct hantro_g2_all_probs), 16);\n}\n\nstatic inline size_t hantro_vp9_count_tab_size(void)\n{\n\treturn roundup(sizeof(struct symbol_counts), 16);\n}\n\nstatic inline size_t hantro_vp9_tile_info_size(void)\n{\n\treturn roundup((MAX_TILE_COLS * MAX_TILE_ROWS * 4 * sizeof(u16) + 15 + 16) & ~0xf, 16);\n}\n\nstatic void *get_coeffs_arr(struct symbol_counts *cnts, int i, int j, int k, int l, int m)\n{\n\tif (i == 0)\n\t\treturn &cnts->count_coeffs[j][k][l][m];\n\n\tif (i == 1)\n\t\treturn &cnts->count_coeffs8x8[j][k][l][m];\n\n\tif (i == 2)\n\t\treturn &cnts->count_coeffs16x16[j][k][l][m];\n\n\tif (i == 3)\n\t\treturn &cnts->count_coeffs32x32[j][k][l][m];\n\n\treturn NULL;\n}\n\nstatic void *get_eobs1(struct symbol_counts *cnts, int i, int j, int k, int l, int m)\n{\n\tif (i == 0)\n\t\treturn &cnts->count_coeffs[j][k][l][m][3];\n\n\tif (i == 1)\n\t\treturn &cnts->count_coeffs8x8[j][k][l][m][3];\n\n\tif (i == 2)\n\t\treturn &cnts->count_coeffs16x16[j][k][l][m][3];\n\n\tif (i == 3)\n\t\treturn &cnts->count_coeffs32x32[j][k][l][m][3];\n\n\treturn NULL;\n}\n\n#define INNER_LOOP \\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (m = 0; m < ARRAY_SIZE(vp9_ctx->cnts.coeff[i][0][0][0]); ++m) {\t\\\n\t\t\tvp9_ctx->cnts.coeff[i][j][k][l][m] =\t\t\t\t\\\n\t\t\t\tget_coeffs_arr(cnts, i, j, k, l, m);\t\t\t\\\n\t\t\tvp9_ctx->cnts.eob[i][j][k][l][m][0] =\t\t\t\t\\\n\t\t\t\t&cnts->count_eobs[i][j][k][l][m];\t\t\t\\\n\t\t\tvp9_ctx->cnts.eob[i][j][k][l][m][1] =\t\t\t\t\\\n\t\t\t\tget_eobs1(cnts, i, j, k, l, m);\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic void init_v4l2_vp9_count_tbl(struct hantro_ctx *ctx)\n{\n\tstruct hantro_vp9_dec_hw_ctx *vp9_ctx = &ctx->vp9_dec;\n\tstruct symbol_counts *cnts = vp9_ctx->misc.cpu + vp9_ctx->ctx_counters_offset;\n\tint i, j, k, l, m;\n\n\tvp9_ctx->cnts.partition = &cnts->partition_counts;\n\tvp9_ctx->cnts.skip = &cnts->mbskip_count;\n\tvp9_ctx->cnts.intra_inter = &cnts->intra_inter_count;\n\tvp9_ctx->cnts.tx32p = &cnts->tx32x32_count;\n\t \n\tvp9_ctx->cnts.tx8p = &cnts->tx8x8_count;\n\n\tvp9_ctx->cnts.y_mode = &cnts->sb_ymode_counts;\n\tvp9_ctx->cnts.uv_mode = &cnts->uv_mode_counts;\n\tvp9_ctx->cnts.comp = &cnts->comp_inter_count;\n\tvp9_ctx->cnts.comp_ref = &cnts->comp_ref_count;\n\tvp9_ctx->cnts.single_ref = &cnts->single_ref_count;\n\tvp9_ctx->cnts.filter = &cnts->switchable_interp_counts;\n\tvp9_ctx->cnts.mv_joint = &cnts->mv_counts.joints;\n\tvp9_ctx->cnts.sign = &cnts->mv_counts.sign;\n\tvp9_ctx->cnts.classes = &cnts->mv_counts.classes;\n\tvp9_ctx->cnts.class0 = &cnts->mv_counts.class0;\n\tvp9_ctx->cnts.bits = &cnts->mv_counts.bits;\n\tvp9_ctx->cnts.class0_fp = &cnts->mv_counts.class0_fp;\n\tvp9_ctx->cnts.fp = &cnts->mv_counts.fp;\n\tvp9_ctx->cnts.class0_hp = &cnts->mv_counts.class0_hp;\n\tvp9_ctx->cnts.hp = &cnts->mv_counts.hp;\n\n\tfor (i = 0; i < ARRAY_SIZE(vp9_ctx->cnts.coeff); ++i)\n\t\tfor (j = 0; j < ARRAY_SIZE(vp9_ctx->cnts.coeff[i]); ++j)\n\t\t\tfor (k = 0; k < ARRAY_SIZE(vp9_ctx->cnts.coeff[i][0]); ++k)\n\t\t\t\tfor (l = 0; l < ARRAY_SIZE(vp9_ctx->cnts.coeff[i][0][0]); ++l)\n\t\t\t\t\tINNER_LOOP;\n}\n\nint hantro_vp9_dec_init(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tconst struct hantro_variant *variant = vpu->variant;\n\tstruct hantro_vp9_dec_hw_ctx *vp9_dec = &ctx->vp9_dec;\n\tstruct hantro_aux_buf *tile_edge = &vp9_dec->tile_edge;\n\tstruct hantro_aux_buf *segment_map = &vp9_dec->segment_map;\n\tstruct hantro_aux_buf *misc = &vp9_dec->misc;\n\tu32 i, max_width, max_height, size;\n\n\tif (variant->num_dec_fmts < 1)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < variant->num_dec_fmts; ++i)\n\t\tif (variant->dec_fmts[i].fourcc == V4L2_PIX_FMT_VP9_FRAME)\n\t\t\tbreak;\n\n\tif (i == variant->num_dec_fmts)\n\t\treturn -EINVAL;\n\n\tmax_width = vpu->variant->dec_fmts[i].frmsize.max_width;\n\tmax_height = vpu->variant->dec_fmts[i].frmsize.max_height;\n\n\tsize = hantro_vp9_tile_filter_size(max_height);\n\tvp9_dec->bsd_ctrl_offset = size;\n\tsize += hantro_vp9_bsd_control_size(max_height);\n\n\ttile_edge->cpu = dma_alloc_coherent(vpu->dev, size, &tile_edge->dma, GFP_KERNEL);\n\tif (!tile_edge->cpu)\n\t\treturn -ENOMEM;\n\n\ttile_edge->size = size;\n\tmemset(tile_edge->cpu, 0, size);\n\n\tsize = hantro_vp9_segment_map_size(max_width, max_height);\n\tvp9_dec->segment_map_size = size;\n\tsize *= 2;  \n\n\tsegment_map->cpu = dma_alloc_coherent(vpu->dev, size, &segment_map->dma, GFP_KERNEL);\n\tif (!segment_map->cpu)\n\t\tgoto err_segment_map;\n\n\tsegment_map->size = size;\n\tmemset(segment_map->cpu, 0, size);\n\n\tsize = hantro_vp9_prob_tab_size();\n\tvp9_dec->ctx_counters_offset = size;\n\tsize += hantro_vp9_count_tab_size();\n\tvp9_dec->tile_info_offset = size;\n\tsize += hantro_vp9_tile_info_size();\n\n\tmisc->cpu = dma_alloc_coherent(vpu->dev, size, &misc->dma, GFP_KERNEL);\n\tif (!misc->cpu)\n\t\tgoto err_misc;\n\n\tmisc->size = size;\n\tmemset(misc->cpu, 0, size);\n\n\tinit_v4l2_vp9_count_tbl(ctx);\n\n\treturn 0;\n\nerr_misc:\n\tdma_free_coherent(vpu->dev, segment_map->size, segment_map->cpu, segment_map->dma);\n\nerr_segment_map:\n\tdma_free_coherent(vpu->dev, tile_edge->size, tile_edge->cpu, tile_edge->dma);\n\n\treturn -ENOMEM;\n}\n\nvoid hantro_vp9_dec_exit(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tstruct hantro_vp9_dec_hw_ctx *vp9_dec = &ctx->vp9_dec;\n\tstruct hantro_aux_buf *tile_edge = &vp9_dec->tile_edge;\n\tstruct hantro_aux_buf *segment_map = &vp9_dec->segment_map;\n\tstruct hantro_aux_buf *misc = &vp9_dec->misc;\n\n\tdma_free_coherent(vpu->dev, misc->size, misc->cpu, misc->dma);\n\tdma_free_coherent(vpu->dev, segment_map->size, segment_map->cpu, segment_map->dma);\n\tdma_free_coherent(vpu->dev, tile_edge->size, tile_edge->cpu, tile_edge->dma);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}