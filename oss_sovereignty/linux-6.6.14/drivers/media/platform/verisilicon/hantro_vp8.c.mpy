{
  "module_name": "hantro_vp8.c",
  "hash_id": "24f98f77b2876e3a513447ea8d47675d09a63d0323b56c05dad1d61221b5fb8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/verisilicon/hantro_vp8.c",
  "human_readable_source": "\n \n\n#include \"hantro.h\"\n\n \nstruct vp8_prob_tbl_packed {\n\tu8 prob_mb_skip_false;\n\tu8 prob_intra;\n\tu8 prob_ref_last;\n\tu8 prob_ref_golden;\n\tu8 prob_segment[3];\n\tu8 padding0;\n\n\tu8 prob_luma_16x16_pred_mode[4];\n\tu8 prob_chroma_pred_mode[3];\n\tu8 padding1;\n\n\t \n\tu8 prob_mv_context[2][V4L2_VP8_MV_PROB_CNT];\n\tu8 padding2[2];\n\n\t \n\tu8 prob_coeffs[4][8][3][V4L2_VP8_COEFF_PROB_CNT];\n\tu8 padding3[96];\n};\n\n \nconst u32 hantro_vp8_dec_mc_filter[8][6] = {\n\t{ 0, 0, 128, 0, 0, 0 },\n\t{ 0, -6, 123, 12, -1, 0 },\n\t{ 2, -11, 108, 36, -8, 1 },\n\t{ 0, -9, 93, 50, -6, 0 },\n\t{ 3, -16, 77, 77, -16, 3 },\n\t{ 0, -6, 50, 93, -9, 0 },\n\t{ 1, -8, 36, 108, -11, 2 },\n\t{ 0, -1, 12, 123, -6, 0 }\n};\n\nvoid hantro_vp8_prob_update(struct hantro_ctx *ctx,\n\t\t\t    const struct v4l2_ctrl_vp8_frame *hdr)\n{\n\tconst struct v4l2_vp8_entropy *entropy = &hdr->entropy;\n\tu32 i, j, k;\n\tu8 *dst;\n\n\t \n\tdst = ctx->vp8_dec.prob_tbl.cpu;\n\n\tdst[0] = hdr->prob_skip_false;\n\tdst[1] = hdr->prob_intra;\n\tdst[2] = hdr->prob_last;\n\tdst[3] = hdr->prob_gf;\n\tdst[4] = hdr->segment.segment_probs[0];\n\tdst[5] = hdr->segment.segment_probs[1];\n\tdst[6] = hdr->segment.segment_probs[2];\n\tdst[7] = 0;\n\n\tdst += 8;\n\tdst[0] = entropy->y_mode_probs[0];\n\tdst[1] = entropy->y_mode_probs[1];\n\tdst[2] = entropy->y_mode_probs[2];\n\tdst[3] = entropy->y_mode_probs[3];\n\tdst[4] = entropy->uv_mode_probs[0];\n\tdst[5] = entropy->uv_mode_probs[1];\n\tdst[6] = entropy->uv_mode_probs[2];\n\tdst[7] = 0;  \n\n\t \n\tdst += 8;\n\tdst[0] = entropy->mv_probs[0][0];  \n\tdst[1] = entropy->mv_probs[1][0];\n\tdst[2] = entropy->mv_probs[0][1];  \n\tdst[3] = entropy->mv_probs[1][1];\n\tdst[4] = entropy->mv_probs[0][8 + 9];\n\tdst[5] = entropy->mv_probs[0][9 + 9];\n\tdst[6] = entropy->mv_probs[1][8 + 9];\n\tdst[7] = entropy->mv_probs[1][9 + 9];\n\tdst += 8;\n\tfor (i = 0; i < 2; ++i) {\n\t\tfor (j = 0; j < 8; j += 4) {\n\t\t\tdst[0] = entropy->mv_probs[i][j + 9 + 0];\n\t\t\tdst[1] = entropy->mv_probs[i][j + 9 + 1];\n\t\t\tdst[2] = entropy->mv_probs[i][j + 9 + 2];\n\t\t\tdst[3] = entropy->mv_probs[i][j + 9 + 3];\n\t\t\tdst += 4;\n\t\t}\n\t}\n\tfor (i = 0; i < 2; ++i) {\n\t\tdst[0] = entropy->mv_probs[i][0 + 2];\n\t\tdst[1] = entropy->mv_probs[i][1 + 2];\n\t\tdst[2] = entropy->mv_probs[i][2 + 2];\n\t\tdst[3] = entropy->mv_probs[i][3 + 2];\n\t\tdst[4] = entropy->mv_probs[i][4 + 2];\n\t\tdst[5] = entropy->mv_probs[i][5 + 2];\n\t\tdst[6] = entropy->mv_probs[i][6 + 2];\n\t\tdst[7] = 0;\t \n\t\tdst += 8;\n\t}\n\n\t \n\tdst = ctx->vp8_dec.prob_tbl.cpu;\n\tdst += (8 * 7);\n\tfor (i = 0; i < 4; ++i) {\n\t\tfor (j = 0; j < 8; ++j) {\n\t\t\tfor (k = 0; k < 3; ++k) {\n\t\t\t\tdst[0] = entropy->coeff_probs[i][j][k][0];\n\t\t\t\tdst[1] = entropy->coeff_probs[i][j][k][1];\n\t\t\t\tdst[2] = entropy->coeff_probs[i][j][k][2];\n\t\t\t\tdst[3] = entropy->coeff_probs[i][j][k][3];\n\t\t\t\tdst += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tdst = ctx->vp8_dec.prob_tbl.cpu;\n\tdst += (8 * 55);\n\tfor (i = 0; i < 4; ++i) {\n\t\tfor (j = 0; j < 8; ++j) {\n\t\t\tfor (k = 0; k < 3; ++k) {\n\t\t\t\tdst[0] = entropy->coeff_probs[i][j][k][4];\n\t\t\t\tdst[1] = entropy->coeff_probs[i][j][k][5];\n\t\t\t\tdst[2] = entropy->coeff_probs[i][j][k][6];\n\t\t\t\tdst[3] = entropy->coeff_probs[i][j][k][7];\n\t\t\t\tdst[4] = entropy->coeff_probs[i][j][k][8];\n\t\t\t\tdst[5] = entropy->coeff_probs[i][j][k][9];\n\t\t\t\tdst[6] = entropy->coeff_probs[i][j][k][10];\n\t\t\t\tdst[7] = 0;\t \n\t\t\t\tdst += 8;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint hantro_vp8_dec_init(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tstruct hantro_aux_buf *aux_buf;\n\tunsigned int mb_width, mb_height;\n\tsize_t segment_map_size;\n\tint ret;\n\n\t \n\tmb_width = DIV_ROUND_UP(ctx->dst_fmt.width, 16);\n\tmb_height = DIV_ROUND_UP(ctx->dst_fmt.height, 16);\n\tsegment_map_size = round_up(DIV_ROUND_UP(mb_width * mb_height, 4), 64);\n\n\t \n\taux_buf = &ctx->vp8_dec.segment_map;\n\taux_buf->size = segment_map_size;\n\taux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size,\n\t\t\t\t\t  &aux_buf->dma, GFP_KERNEL);\n\tif (!aux_buf->cpu)\n\t\treturn -ENOMEM;\n\n\t \n\taux_buf = &ctx->vp8_dec.prob_tbl;\n\taux_buf->size = sizeof(struct vp8_prob_tbl_packed);\n\taux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size,\n\t\t\t\t\t  &aux_buf->dma, GFP_KERNEL);\n\tif (!aux_buf->cpu) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_seg_map;\n\t}\n\n\treturn 0;\n\nerr_free_seg_map:\n\tdma_free_coherent(vpu->dev, ctx->vp8_dec.segment_map.size,\n\t\t\t  ctx->vp8_dec.segment_map.cpu,\n\t\t\t  ctx->vp8_dec.segment_map.dma);\n\n\treturn ret;\n}\n\nvoid hantro_vp8_dec_exit(struct hantro_ctx *ctx)\n{\n\tstruct hantro_vp8_dec_hw_ctx *vp8_dec = &ctx->vp8_dec;\n\tstruct hantro_dev *vpu = ctx->dev;\n\n\tdma_free_coherent(vpu->dev, vp8_dec->segment_map.size,\n\t\t\t  vp8_dec->segment_map.cpu, vp8_dec->segment_map.dma);\n\tdma_free_coherent(vpu->dev, vp8_dec->prob_tbl.size,\n\t\t\t  vp8_dec->prob_tbl.cpu, vp8_dec->prob_tbl.dma);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}