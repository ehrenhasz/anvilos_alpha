{
  "module_name": "hantro_drv.c",
  "hash_id": "13be9dafba946bf8792c36870981372ffe9edc9340d447f96c1cef251d4f9ef1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/verisilicon/hantro_drv.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/workqueue.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-core.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"hantro_v4l2.h\"\n#include \"hantro.h\"\n#include \"hantro_hw.h\"\n\n#define DRIVER_NAME \"hantro-vpu\"\n\nint hantro_debug;\nmodule_param_named(debug, hantro_debug, int, 0644);\nMODULE_PARM_DESC(debug,\n\t\t \"Debug level - higher value produces more verbose messages\");\n\nvoid *hantro_get_ctrl(struct hantro_ctx *ctx, u32 id)\n{\n\tstruct v4l2_ctrl *ctrl;\n\n\tctrl = v4l2_ctrl_find(&ctx->ctrl_handler, id);\n\treturn ctrl ? ctrl->p_cur.p : NULL;\n}\n\ndma_addr_t hantro_get_ref(struct hantro_ctx *ctx, u64 ts)\n{\n\tstruct vb2_queue *q = v4l2_m2m_get_dst_vq(ctx->fh.m2m_ctx);\n\tstruct vb2_buffer *buf;\n\n\tbuf = vb2_find_buffer(q, ts);\n\tif (!buf)\n\t\treturn 0;\n\treturn hantro_get_dec_buf_addr(ctx, buf);\n}\n\nstatic const struct v4l2_event hantro_eos_event = {\n\t.type = V4L2_EVENT_EOS\n};\n\nstatic void hantro_job_finish_no_pm(struct hantro_dev *vpu,\n\t\t\t\t    struct hantro_ctx *ctx,\n\t\t\t\t    enum vb2_buffer_state result)\n{\n\tstruct vb2_v4l2_buffer *src, *dst;\n\n\tsrc = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\tif (WARN_ON(!src))\n\t\treturn;\n\tif (WARN_ON(!dst))\n\t\treturn;\n\n\tsrc->sequence = ctx->sequence_out++;\n\tdst->sequence = ctx->sequence_cap++;\n\n\tif (v4l2_m2m_is_last_draining_src_buf(ctx->fh.m2m_ctx, src)) {\n\t\tdst->flags |= V4L2_BUF_FLAG_LAST;\n\t\tv4l2_event_queue_fh(&ctx->fh, &hantro_eos_event);\n\t\tv4l2_m2m_mark_stopped(ctx->fh.m2m_ctx);\n\t}\n\n\tv4l2_m2m_buf_done_and_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx,\n\t\t\t\t\t result);\n}\n\nstatic void hantro_job_finish(struct hantro_dev *vpu,\n\t\t\t      struct hantro_ctx *ctx,\n\t\t\t      enum vb2_buffer_state result)\n{\n\tpm_runtime_mark_last_busy(vpu->dev);\n\tpm_runtime_put_autosuspend(vpu->dev);\n\n\tclk_bulk_disable(vpu->variant->num_clocks, vpu->clocks);\n\n\thantro_job_finish_no_pm(vpu, ctx, result);\n}\n\nvoid hantro_irq_done(struct hantro_dev *vpu,\n\t\t     enum vb2_buffer_state result)\n{\n\tstruct hantro_ctx *ctx =\n\t\tv4l2_m2m_get_curr_priv(vpu->m2m_dev);\n\n\t \n\tif (cancel_delayed_work(&vpu->watchdog_work)) {\n\t\tif (result == VB2_BUF_STATE_DONE && ctx->codec_ops->done)\n\t\t\tctx->codec_ops->done(ctx);\n\t\thantro_job_finish(vpu, ctx, result);\n\t}\n}\n\nvoid hantro_watchdog(struct work_struct *work)\n{\n\tstruct hantro_dev *vpu;\n\tstruct hantro_ctx *ctx;\n\n\tvpu = container_of(to_delayed_work(work),\n\t\t\t   struct hantro_dev, watchdog_work);\n\tctx = v4l2_m2m_get_curr_priv(vpu->m2m_dev);\n\tif (ctx) {\n\t\tvpu_err(\"frame processing timed out!\\n\");\n\t\tif (ctx->codec_ops->reset)\n\t\t\tctx->codec_ops->reset(ctx);\n\t\thantro_job_finish(vpu, ctx, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nvoid hantro_start_prepare_run(struct hantro_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *src_buf;\n\n\tsrc_buf = hantro_get_src_buf(ctx);\n\tv4l2_ctrl_request_setup(src_buf->vb2_buf.req_obj.req,\n\t\t\t\t&ctx->ctrl_handler);\n\n\tif (!ctx->is_encoder && !ctx->dev->variant->late_postproc) {\n\t\tif (hantro_needs_postproc(ctx, ctx->vpu_dst_fmt))\n\t\t\thantro_postproc_enable(ctx);\n\t\telse\n\t\t\thantro_postproc_disable(ctx);\n\t}\n}\n\nvoid hantro_end_prepare_run(struct hantro_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *src_buf;\n\n\tif (!ctx->is_encoder && ctx->dev->variant->late_postproc) {\n\t\tif (hantro_needs_postproc(ctx, ctx->vpu_dst_fmt))\n\t\t\thantro_postproc_enable(ctx);\n\t\telse\n\t\t\thantro_postproc_disable(ctx);\n\t}\n\n\tsrc_buf = hantro_get_src_buf(ctx);\n\tv4l2_ctrl_request_complete(src_buf->vb2_buf.req_obj.req,\n\t\t\t\t   &ctx->ctrl_handler);\n\n\t \n\tschedule_delayed_work(&ctx->dev->watchdog_work,\n\t\t\t      msecs_to_jiffies(2000));\n}\n\nstatic void device_run(void *priv)\n{\n\tstruct hantro_ctx *ctx = priv;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\tint ret;\n\n\tsrc = hantro_get_src_buf(ctx);\n\tdst = hantro_get_dst_buf(ctx);\n\n\tret = pm_runtime_resume_and_get(ctx->dev->dev);\n\tif (ret < 0)\n\t\tgoto err_cancel_job;\n\n\tret = clk_bulk_enable(ctx->dev->variant->num_clocks, ctx->dev->clocks);\n\tif (ret)\n\t\tgoto err_cancel_job;\n\n\tv4l2_m2m_buf_copy_metadata(src, dst, true);\n\n\tif (ctx->codec_ops->run(ctx))\n\t\tgoto err_cancel_job;\n\n\treturn;\n\nerr_cancel_job:\n\thantro_job_finish_no_pm(ctx->dev, ctx, VB2_BUF_STATE_ERROR);\n}\n\nstatic const struct v4l2_m2m_ops vpu_m2m_ops = {\n\t.device_run = device_run,\n};\n\nstatic int\nqueue_init(void *priv, struct vb2_queue *src_vq, struct vb2_queue *dst_vq)\n{\n\tstruct hantro_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->ops = &hantro_queue_ops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\n\t \n\tsrc_vq->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES |\n\t\t\t    DMA_ATTR_NO_KERNEL_MAPPING;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->dev->vpu_mutex;\n\tsrc_vq->dev = ctx->dev->v4l2_dev.dev;\n\tsrc_vq->supports_requests = true;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->bidirectional = true;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;\n\t \n\tif (!ctx->is_encoder)\n\t\tdst_vq->dma_attrs |= DMA_ATTR_NO_KERNEL_MAPPING;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->ops = &hantro_queue_ops;\n\tdst_vq->buf_struct_size = sizeof(struct hantro_decoded_buffer);\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->dev->vpu_mutex;\n\tdst_vq->dev = ctx->dev->v4l2_dev.dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int hantro_try_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tif (ctrl->id == V4L2_CID_STATELESS_H264_SPS) {\n\t\tconst struct v4l2_ctrl_h264_sps *sps = ctrl->p_new.p_h264_sps;\n\n\t\tif (sps->chroma_format_idc > 1)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\tif (sps->bit_depth_luma_minus8 != sps->bit_depth_chroma_minus8)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\tif (sps->bit_depth_luma_minus8 != 0)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t} else if (ctrl->id == V4L2_CID_STATELESS_HEVC_SPS) {\n\t\tconst struct v4l2_ctrl_hevc_sps *sps = ctrl->p_new.p_hevc_sps;\n\n\t\tif (sps->bit_depth_luma_minus8 != 0 && sps->bit_depth_luma_minus8 != 2)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t} else if (ctrl->id == V4L2_CID_STATELESS_VP9_FRAME) {\n\t\tconst struct v4l2_ctrl_vp9_frame *dec_params = ctrl->p_new.p_vp9_frame;\n\n\t\t \n\t\tif (dec_params->profile != 0)\n\t\t\treturn -EINVAL;\n\t} else if (ctrl->id == V4L2_CID_STATELESS_AV1_SEQUENCE) {\n\t\tconst struct v4l2_ctrl_av1_sequence *sequence = ctrl->p_new.p_av1_sequence;\n\n\t\tif (sequence->bit_depth != 8 && sequence->bit_depth != 10)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hantro_jpeg_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct hantro_ctx *ctx;\n\n\tctx = container_of(ctrl->handler,\n\t\t\t   struct hantro_ctx, ctrl_handler);\n\n\tvpu_debug(1, \"s_ctrl: id = %d, val = %d\\n\", ctrl->id, ctrl->val);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\tctx->jpeg_quality = ctrl->val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hantro_vp9_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct hantro_ctx *ctx;\n\n\tctx = container_of(ctrl->handler,\n\t\t\t   struct hantro_ctx, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_STATELESS_VP9_FRAME: {\n\t\tint bit_depth = ctrl->p_new.p_vp9_frame->bit_depth;\n\n\t\tif (ctx->bit_depth == bit_depth)\n\t\t\treturn 0;\n\n\t\treturn hantro_reset_raw_fmt(ctx, bit_depth, HANTRO_AUTO_POSTPROC);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hantro_hevc_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct hantro_ctx *ctx;\n\n\tctx = container_of(ctrl->handler,\n\t\t\t   struct hantro_ctx, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_STATELESS_HEVC_SPS: {\n\t\tconst struct v4l2_ctrl_hevc_sps *sps = ctrl->p_new.p_hevc_sps;\n\t\tint bit_depth = sps->bit_depth_luma_minus8 + 8;\n\n\t\tif (ctx->bit_depth == bit_depth)\n\t\t\treturn 0;\n\n\t\treturn hantro_reset_raw_fmt(ctx, bit_depth, HANTRO_AUTO_POSTPROC);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hantro_av1_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct hantro_ctx *ctx;\n\n\tctx = container_of(ctrl->handler,\n\t\t\t   struct hantro_ctx, ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_STATELESS_AV1_SEQUENCE:\n\t{\n\t\tint bit_depth = ctrl->p_new.p_av1_sequence->bit_depth;\n\t\tbool need_postproc = HANTRO_AUTO_POSTPROC;\n\n\t\tif (ctrl->p_new.p_av1_sequence->flags\n\t\t    & V4L2_AV1_SEQUENCE_FLAG_FILM_GRAIN_PARAMS_PRESENT)\n\t\t\tneed_postproc = HANTRO_FORCE_POSTPROC;\n\n\t\tif (ctx->bit_depth == bit_depth &&\n\t\t    ctx->need_postproc == need_postproc)\n\t\t\treturn 0;\n\n\t\treturn hantro_reset_raw_fmt(ctx, bit_depth, need_postproc);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops hantro_ctrl_ops = {\n\t.try_ctrl = hantro_try_ctrl,\n};\n\nstatic const struct v4l2_ctrl_ops hantro_jpeg_ctrl_ops = {\n\t.s_ctrl = hantro_jpeg_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_ops hantro_vp9_ctrl_ops = {\n\t.s_ctrl = hantro_vp9_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_ops hantro_hevc_ctrl_ops = {\n\t.try_ctrl = hantro_try_ctrl,\n\t.s_ctrl = hantro_hevc_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_ops hantro_av1_ctrl_ops = {\n\t.try_ctrl = hantro_try_ctrl,\n\t.s_ctrl = hantro_av1_s_ctrl,\n};\n\n#define HANTRO_JPEG_ACTIVE_MARKERS\t(V4L2_JPEG_ACTIVE_MARKER_APP0 | \\\n\t\t\t\t\t V4L2_JPEG_ACTIVE_MARKER_COM | \\\n\t\t\t\t\t V4L2_JPEG_ACTIVE_MARKER_DQT | \\\n\t\t\t\t\t V4L2_JPEG_ACTIVE_MARKER_DHT)\n\nstatic const struct hantro_ctrl controls[] = {\n\t{\n\t\t.codec = HANTRO_JPEG_ENCODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_JPEG_COMPRESSION_QUALITY,\n\t\t\t.min = 5,\n\t\t\t.max = 100,\n\t\t\t.step = 1,\n\t\t\t.def = 50,\n\t\t\t.ops = &hantro_jpeg_ctrl_ops,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_JPEG_ENCODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_JPEG_ACTIVE_MARKER,\n\t\t\t.max = HANTRO_JPEG_ACTIVE_MARKERS,\n\t\t\t.def = HANTRO_JPEG_ACTIVE_MARKERS,\n\t\t\t \n\t\t\t.flags = V4L2_CTRL_FLAG_READ_ONLY,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_MPEG2_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_MPEG2_SEQUENCE,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_MPEG2_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_MPEG2_PICTURE,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_MPEG2_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_MPEG2_QUANTISATION,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_VP8_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_VP8_FRAME,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_H264_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_H264_DECODE_PARAMS,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_H264_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_H264_SPS,\n\t\t\t.ops = &hantro_ctrl_ops,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_H264_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_H264_PPS,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_H264_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_H264_SCALING_MATRIX,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_H264_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_H264_DECODE_MODE,\n\t\t\t.min = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,\n\t\t\t.def = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,\n\t\t\t.max = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_H264_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_H264_START_CODE,\n\t\t\t.min = V4L2_STATELESS_H264_START_CODE_ANNEX_B,\n\t\t\t.def = V4L2_STATELESS_H264_START_CODE_ANNEX_B,\n\t\t\t.max = V4L2_STATELESS_H264_START_CODE_ANNEX_B,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_H264_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_MPEG_VIDEO_H264_PROFILE,\n\t\t\t.min = V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE,\n\t\t\t.max = V4L2_MPEG_VIDEO_H264_PROFILE_HIGH,\n\t\t\t.menu_skip_mask =\n\t\t\tBIT(V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED),\n\t\t\t.def = V4L2_MPEG_VIDEO_H264_PROFILE_MAIN,\n\t\t}\n\t}, {\n\t\t.codec = HANTRO_HEVC_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_DECODE_MODE,\n\t\t\t.min = V4L2_STATELESS_HEVC_DECODE_MODE_FRAME_BASED,\n\t\t\t.max = V4L2_STATELESS_HEVC_DECODE_MODE_FRAME_BASED,\n\t\t\t.def = V4L2_STATELESS_HEVC_DECODE_MODE_FRAME_BASED,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_HEVC_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_START_CODE,\n\t\t\t.min = V4L2_STATELESS_HEVC_START_CODE_ANNEX_B,\n\t\t\t.max = V4L2_STATELESS_HEVC_START_CODE_ANNEX_B,\n\t\t\t.def = V4L2_STATELESS_HEVC_START_CODE_ANNEX_B,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_HEVC_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_PROFILE,\n\t\t\t.min = V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN,\n\t\t\t.max = V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10,\n\t\t\t.def = V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_HEVC_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_MPEG_VIDEO_HEVC_LEVEL,\n\t\t\t.min = V4L2_MPEG_VIDEO_HEVC_LEVEL_1,\n\t\t\t.max = V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_HEVC_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_SPS,\n\t\t\t.ops = &hantro_hevc_ctrl_ops,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_HEVC_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_PPS,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_HEVC_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_DECODE_PARAMS,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_HEVC_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_HEVC_SCALING_MATRIX,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_VP9_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_VP9_FRAME,\n\t\t\t.ops = &hantro_vp9_ctrl_ops,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_VP9_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_VP9_COMPRESSED_HDR,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_AV1_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_AV1_FRAME,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_AV1_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_AV1_TILE_GROUP_ENTRY,\n\t\t\t.dims = { V4L2_AV1_MAX_TILE_COUNT },\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_AV1_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_AV1_SEQUENCE,\n\t\t\t.ops = &hantro_av1_ctrl_ops,\n\t\t},\n\t}, {\n\t\t.codec = HANTRO_AV1_DECODER,\n\t\t.cfg = {\n\t\t\t.id = V4L2_CID_STATELESS_AV1_FILM_GRAIN,\n\t\t},\n\t},\n};\n\nstatic int hantro_ctrls_setup(struct hantro_dev *vpu,\n\t\t\t      struct hantro_ctx *ctx,\n\t\t\t      int allowed_codecs)\n{\n\tint i, num_ctrls = ARRAY_SIZE(controls);\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, num_ctrls);\n\n\tfor (i = 0; i < num_ctrls; i++) {\n\t\tif (!(allowed_codecs & controls[i].codec))\n\t\t\tcontinue;\n\n\t\tv4l2_ctrl_new_custom(&ctx->ctrl_handler,\n\t\t\t\t     &controls[i].cfg, NULL);\n\t\tif (ctx->ctrl_handler.error) {\n\t\t\tvpu_err(\"Adding control (%d) failed %d\\n\",\n\t\t\t\tcontrols[i].cfg.id,\n\t\t\t\tctx->ctrl_handler.error);\n\t\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\t\t\treturn ctx->ctrl_handler.error;\n\t\t}\n\t}\n\treturn v4l2_ctrl_handler_setup(&ctx->ctrl_handler);\n}\n\n \n\nstatic int hantro_open(struct file *filp)\n{\n\tstruct hantro_dev *vpu = video_drvdata(filp);\n\tstruct video_device *vdev = video_devdata(filp);\n\tstruct hantro_func *func = hantro_vdev_to_func(vdev);\n\tstruct hantro_ctx *ctx;\n\tint allowed_codecs, ret;\n\n\t \n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = vpu;\n\tif (func->id == MEDIA_ENT_F_PROC_VIDEO_ENCODER) {\n\t\tallowed_codecs = vpu->variant->codec & HANTRO_ENCODERS;\n\t\tctx->is_encoder = true;\n\t} else if (func->id == MEDIA_ENT_F_PROC_VIDEO_DECODER) {\n\t\tallowed_codecs = vpu->variant->codec & HANTRO_DECODERS;\n\t\tctx->is_encoder = false;\n\t} else {\n\t\tret = -ENODEV;\n\t\tgoto err_ctx_free;\n\t}\n\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(vpu->m2m_dev, ctx, queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tgoto err_ctx_free;\n\t}\n\n\tv4l2_fh_init(&ctx->fh, vdev);\n\tfilp->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\thantro_reset_fmts(ctx);\n\n\tret = hantro_ctrls_setup(vpu, ctx, allowed_codecs);\n\tif (ret) {\n\t\tvpu_err(\"Failed to set up controls\\n\");\n\t\tgoto err_fh_free;\n\t}\n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\n\treturn 0;\n\nerr_fh_free:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\nerr_ctx_free:\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic int hantro_release(struct file *filp)\n{\n\tstruct hantro_ctx *ctx =\n\t\tcontainer_of(filp->private_data, struct hantro_ctx, fh);\n\n\t \n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations hantro_fops = {\n\t.owner = THIS_MODULE,\n\t.open = hantro_open,\n\t.release = hantro_release,\n\t.poll = v4l2_m2m_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap = v4l2_m2m_fop_mmap,\n};\n\nstatic const struct of_device_id of_hantro_match[] = {\n#ifdef CONFIG_VIDEO_HANTRO_ROCKCHIP\n\t{ .compatible = \"rockchip,px30-vpu\",   .data = &px30_vpu_variant, },\n\t{ .compatible = \"rockchip,rk3036-vpu\", .data = &rk3036_vpu_variant, },\n\t{ .compatible = \"rockchip,rk3066-vpu\", .data = &rk3066_vpu_variant, },\n\t{ .compatible = \"rockchip,rk3288-vpu\", .data = &rk3288_vpu_variant, },\n\t{ .compatible = \"rockchip,rk3328-vpu\", .data = &rk3328_vpu_variant, },\n\t{ .compatible = \"rockchip,rk3399-vpu\", .data = &rk3399_vpu_variant, },\n\t{ .compatible = \"rockchip,rk3568-vepu\", .data = &rk3568_vepu_variant, },\n\t{ .compatible = \"rockchip,rk3568-vpu\", .data = &rk3568_vpu_variant, },\n\t{ .compatible = \"rockchip,rk3588-av1-vpu\", .data = &rk3588_vpu981_variant, },\n#endif\n#ifdef CONFIG_VIDEO_HANTRO_IMX8M\n\t{ .compatible = \"nxp,imx8mm-vpu-g1\", .data = &imx8mm_vpu_g1_variant, },\n\t{ .compatible = \"nxp,imx8mq-vpu\", .data = &imx8mq_vpu_variant, },\n\t{ .compatible = \"nxp,imx8mq-vpu-g1\", .data = &imx8mq_vpu_g1_variant },\n\t{ .compatible = \"nxp,imx8mq-vpu-g2\", .data = &imx8mq_vpu_g2_variant },\n#endif\n#ifdef CONFIG_VIDEO_HANTRO_SAMA5D4\n\t{ .compatible = \"microchip,sama5d4-vdec\", .data = &sama5d4_vdec_variant, },\n#endif\n#ifdef CONFIG_VIDEO_HANTRO_SUNXI\n\t{ .compatible = \"allwinner,sun50i-h6-vpu-g2\", .data = &sunxi_vpu_variant, },\n#endif\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_hantro_match);\n\nstatic int hantro_register_entity(struct media_device *mdev,\n\t\t\t\t  struct media_entity *entity,\n\t\t\t\t  const char *entity_name,\n\t\t\t\t  struct media_pad *pads, int num_pads,\n\t\t\t\t  int function, struct video_device *vdev)\n{\n\tchar *name;\n\tint ret;\n\n\tentity->obj_type = MEDIA_ENTITY_TYPE_BASE;\n\tif (function == MEDIA_ENT_F_IO_V4L) {\n\t\tentity->info.dev.major = VIDEO_MAJOR;\n\t\tentity->info.dev.minor = vdev->minor;\n\t}\n\n\tname = devm_kasprintf(mdev->dev, GFP_KERNEL, \"%s-%s\", vdev->name,\n\t\t\t      entity_name);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tentity->name = name;\n\tentity->function = function;\n\n\tret = media_entity_pads_init(entity, num_pads, pads);\n\tif (ret)\n\t\treturn ret;\n\n\tret = media_device_register_entity(mdev, entity);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int hantro_attach_func(struct hantro_dev *vpu,\n\t\t\t      struct hantro_func *func)\n{\n\tstruct media_device *mdev = &vpu->mdev;\n\tstruct media_link *link;\n\tint ret;\n\n\t \n\tfunc->source_pad.flags = MEDIA_PAD_FL_SOURCE;\n\tret = hantro_register_entity(mdev, &func->vdev.entity, \"source\",\n\t\t\t\t     &func->source_pad, 1, MEDIA_ENT_F_IO_V4L,\n\t\t\t\t     &func->vdev);\n\tif (ret)\n\t\treturn ret;\n\n\tfunc->proc_pads[0].flags = MEDIA_PAD_FL_SINK;\n\tfunc->proc_pads[1].flags = MEDIA_PAD_FL_SOURCE;\n\tret = hantro_register_entity(mdev, &func->proc, \"proc\",\n\t\t\t\t     func->proc_pads, 2, func->id,\n\t\t\t\t     &func->vdev);\n\tif (ret)\n\t\tgoto err_rel_entity0;\n\n\tfunc->sink_pad.flags = MEDIA_PAD_FL_SINK;\n\tret = hantro_register_entity(mdev, &func->sink, \"sink\",\n\t\t\t\t     &func->sink_pad, 1, MEDIA_ENT_F_IO_V4L,\n\t\t\t\t     &func->vdev);\n\tif (ret)\n\t\tgoto err_rel_entity1;\n\n\t \n\tret = media_create_pad_link(&func->vdev.entity, 0, &func->proc, 0,\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\tif (ret)\n\t\tgoto err_rel_entity2;\n\n\tret = media_create_pad_link(&func->proc, 1, &func->sink, 0,\n\t\t\t\t    MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t    MEDIA_LNK_FL_ENABLED);\n\tif (ret)\n\t\tgoto err_rm_links0;\n\n\t \n\tfunc->intf_devnode = media_devnode_create(mdev, MEDIA_INTF_T_V4L_VIDEO,\n\t\t\t\t\t\t  0, VIDEO_MAJOR,\n\t\t\t\t\t\t  func->vdev.minor);\n\tif (!func->intf_devnode) {\n\t\tret = -ENOMEM;\n\t\tgoto err_rm_links1;\n\t}\n\n\t \n\tlink = media_create_intf_link(&func->vdev.entity,\n\t\t\t\t      &func->intf_devnode->intf,\n\t\t\t\t      MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t      MEDIA_LNK_FL_ENABLED);\n\tif (!link) {\n\t\tret = -ENOMEM;\n\t\tgoto err_rm_devnode;\n\t}\n\n\tlink = media_create_intf_link(&func->sink, &func->intf_devnode->intf,\n\t\t\t\t      MEDIA_LNK_FL_IMMUTABLE |\n\t\t\t\t      MEDIA_LNK_FL_ENABLED);\n\tif (!link) {\n\t\tret = -ENOMEM;\n\t\tgoto err_rm_devnode;\n\t}\n\treturn 0;\n\nerr_rm_devnode:\n\tmedia_devnode_remove(func->intf_devnode);\n\nerr_rm_links1:\n\tmedia_entity_remove_links(&func->sink);\n\nerr_rm_links0:\n\tmedia_entity_remove_links(&func->proc);\n\tmedia_entity_remove_links(&func->vdev.entity);\n\nerr_rel_entity2:\n\tmedia_device_unregister_entity(&func->sink);\n\nerr_rel_entity1:\n\tmedia_device_unregister_entity(&func->proc);\n\nerr_rel_entity0:\n\tmedia_device_unregister_entity(&func->vdev.entity);\n\treturn ret;\n}\n\nstatic void hantro_detach_func(struct hantro_func *func)\n{\n\tmedia_devnode_remove(func->intf_devnode);\n\tmedia_entity_remove_links(&func->sink);\n\tmedia_entity_remove_links(&func->proc);\n\tmedia_entity_remove_links(&func->vdev.entity);\n\tmedia_device_unregister_entity(&func->sink);\n\tmedia_device_unregister_entity(&func->proc);\n\tmedia_device_unregister_entity(&func->vdev.entity);\n}\n\nstatic int hantro_add_func(struct hantro_dev *vpu, unsigned int funcid)\n{\n\tconst struct of_device_id *match;\n\tstruct hantro_func *func;\n\tstruct video_device *vfd;\n\tint ret;\n\n\tmatch = of_match_node(of_hantro_match, vpu->dev->of_node);\n\tfunc = devm_kzalloc(vpu->dev, sizeof(*func), GFP_KERNEL);\n\tif (!func) {\n\t\tv4l2_err(&vpu->v4l2_dev, \"Failed to allocate video device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfunc->id = funcid;\n\n\tvfd = &func->vdev;\n\tvfd->fops = &hantro_fops;\n\tvfd->release = video_device_release_empty;\n\tvfd->lock = &vpu->vpu_mutex;\n\tvfd->v4l2_dev = &vpu->v4l2_dev;\n\tvfd->vfl_dir = VFL_DIR_M2M;\n\tvfd->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE;\n\tvfd->ioctl_ops = &hantro_ioctl_ops;\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s-%s\", match->compatible,\n\t\t funcid == MEDIA_ENT_F_PROC_VIDEO_ENCODER ? \"enc\" : \"dec\");\n\n\tif (funcid == MEDIA_ENT_F_PROC_VIDEO_ENCODER) {\n\t\tvpu->encoder = func;\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_TRY_DECODER_CMD);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_DECODER_CMD);\n\t} else {\n\t\tvpu->decoder = func;\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_TRY_ENCODER_CMD);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_ENCODER_CMD);\n\t}\n\n\tvideo_set_drvdata(vfd, vpu);\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(&vpu->v4l2_dev, \"Failed to register video device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hantro_attach_func(vpu, func);\n\tif (ret) {\n\t\tv4l2_err(&vpu->v4l2_dev,\n\t\t\t \"Failed to attach functionality to the media device\\n\");\n\t\tgoto err_unreg_dev;\n\t}\n\n\tv4l2_info(&vpu->v4l2_dev, \"registered %s as /dev/video%d\\n\", vfd->name,\n\t\t  vfd->num);\n\n\treturn 0;\n\nerr_unreg_dev:\n\tvideo_unregister_device(vfd);\n\treturn ret;\n}\n\nstatic int hantro_add_enc_func(struct hantro_dev *vpu)\n{\n\tif (!vpu->variant->enc_fmts)\n\t\treturn 0;\n\n\treturn hantro_add_func(vpu, MEDIA_ENT_F_PROC_VIDEO_ENCODER);\n}\n\nstatic int hantro_add_dec_func(struct hantro_dev *vpu)\n{\n\tif (!vpu->variant->dec_fmts)\n\t\treturn 0;\n\n\treturn hantro_add_func(vpu, MEDIA_ENT_F_PROC_VIDEO_DECODER);\n}\n\nstatic void hantro_remove_func(struct hantro_dev *vpu,\n\t\t\t       unsigned int funcid)\n{\n\tstruct hantro_func *func;\n\n\tif (funcid == MEDIA_ENT_F_PROC_VIDEO_ENCODER)\n\t\tfunc = vpu->encoder;\n\telse\n\t\tfunc = vpu->decoder;\n\n\tif (!func)\n\t\treturn;\n\n\thantro_detach_func(func);\n\tvideo_unregister_device(&func->vdev);\n}\n\nstatic void hantro_remove_enc_func(struct hantro_dev *vpu)\n{\n\thantro_remove_func(vpu, MEDIA_ENT_F_PROC_VIDEO_ENCODER);\n}\n\nstatic void hantro_remove_dec_func(struct hantro_dev *vpu)\n{\n\thantro_remove_func(vpu, MEDIA_ENT_F_PROC_VIDEO_DECODER);\n}\n\nstatic const struct media_device_ops hantro_m2m_media_ops = {\n\t.req_validate = vb2_request_validate,\n\t.req_queue = v4l2_m2m_request_queue,\n};\n\nstatic int hantro_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct hantro_dev *vpu;\n\tint num_bases;\n\tint i, ret;\n\n\tvpu = devm_kzalloc(&pdev->dev, sizeof(*vpu), GFP_KERNEL);\n\tif (!vpu)\n\t\treturn -ENOMEM;\n\n\tvpu->dev = &pdev->dev;\n\tvpu->pdev = pdev;\n\tmutex_init(&vpu->vpu_mutex);\n\tspin_lock_init(&vpu->irqlock);\n\n\tmatch = of_match_node(of_hantro_match, pdev->dev.of_node);\n\tvpu->variant = match->data;\n\n\t \n\tif (of_device_is_compatible(pdev->dev.of_node, \"nxp,imx8mq-vpu\"))\n\t\tdev_warn(&pdev->dev, \"%s compatible is deprecated\\n\",\n\t\t\t match->compatible);\n\n\tINIT_DELAYED_WORK(&vpu->watchdog_work, hantro_watchdog);\n\n\tvpu->clocks = devm_kcalloc(&pdev->dev, vpu->variant->num_clocks,\n\t\t\t\t   sizeof(*vpu->clocks), GFP_KERNEL);\n\tif (!vpu->clocks)\n\t\treturn -ENOMEM;\n\n\tif (vpu->variant->num_clocks > 1) {\n\t\tfor (i = 0; i < vpu->variant->num_clocks; i++)\n\t\t\tvpu->clocks[i].id = vpu->variant->clk_names[i];\n\n\t\tret = devm_clk_bulk_get(&pdev->dev, vpu->variant->num_clocks,\n\t\t\t\t\tvpu->clocks);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tvpu->clocks[0].clk = devm_clk_get(&pdev->dev, NULL);\n\t\tif (IS_ERR(vpu->clocks[0].clk))\n\t\t\treturn PTR_ERR(vpu->clocks[0].clk);\n\t}\n\n\tvpu->resets = devm_reset_control_array_get_optional_exclusive(&pdev->dev);\n\tif (IS_ERR(vpu->resets))\n\t\treturn PTR_ERR(vpu->resets);\n\n\tnum_bases = vpu->variant->num_regs ?: 1;\n\tvpu->reg_bases = devm_kcalloc(&pdev->dev, num_bases,\n\t\t\t\t      sizeof(*vpu->reg_bases), GFP_KERNEL);\n\tif (!vpu->reg_bases)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_bases; i++) {\n\t\tvpu->reg_bases[i] = vpu->variant->reg_names ?\n\t\t      devm_platform_ioremap_resource_byname(pdev, vpu->variant->reg_names[i]) :\n\t\t      devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(vpu->reg_bases[i]))\n\t\t\treturn PTR_ERR(vpu->reg_bases[i]);\n\t}\n\tvpu->enc_base = vpu->reg_bases[0] + vpu->variant->enc_offset;\n\tvpu->dec_base = vpu->reg_bases[0] + vpu->variant->dec_offset;\n\n\t \n\tret = dma_set_coherent_mask(vpu->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(vpu->dev, \"Could not set DMA coherent mask.\\n\");\n\t\treturn ret;\n\t}\n\tvb2_dma_contig_set_max_seg_size(&pdev->dev, DMA_BIT_MASK(32));\n\n\tfor (i = 0; i < vpu->variant->num_irqs; i++) {\n\t\tconst char *irq_name;\n\t\tint irq;\n\n\t\tif (!vpu->variant->irqs[i].handler)\n\t\t\tcontinue;\n\n\t\tif (vpu->variant->num_irqs > 1) {\n\t\t\tirq_name = vpu->variant->irqs[i].name;\n\t\t\tirq = platform_get_irq_byname(vpu->pdev, irq_name);\n\t\t} else {\n\t\t\t \n\t\t\tirq_name = \"default\";\n\t\t\tirq = platform_get_irq(vpu->pdev, 0);\n\t\t}\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_irq(vpu->dev, irq,\n\t\t\t\t       vpu->variant->irqs[i].handler, 0,\n\t\t\t\t       dev_name(vpu->dev), vpu);\n\t\tif (ret) {\n\t\t\tdev_err(vpu->dev, \"Could not request %s IRQ.\\n\",\n\t\t\t\tirq_name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (vpu->variant->init) {\n\t\tret = vpu->variant->init(vpu);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Failed to init VPU hardware\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpm_runtime_set_autosuspend_delay(vpu->dev, 100);\n\tpm_runtime_use_autosuspend(vpu->dev);\n\tpm_runtime_enable(vpu->dev);\n\n\tret = reset_control_deassert(vpu->resets);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to deassert resets\\n\");\n\t\tgoto err_pm_disable;\n\t}\n\n\tret = clk_bulk_prepare(vpu->variant->num_clocks, vpu->clocks);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to prepare clocks\\n\");\n\t\tgoto err_rst_assert;\n\t}\n\n\tret = v4l2_device_register(&pdev->dev, &vpu->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register v4l2 device\\n\");\n\t\tgoto err_clk_unprepare;\n\t}\n\tplatform_set_drvdata(pdev, vpu);\n\n\tvpu->m2m_dev = v4l2_m2m_init(&vpu_m2m_ops);\n\tif (IS_ERR(vpu->m2m_dev)) {\n\t\tv4l2_err(&vpu->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(vpu->m2m_dev);\n\t\tgoto err_v4l2_unreg;\n\t}\n\n\tvpu->mdev.dev = vpu->dev;\n\tstrscpy(vpu->mdev.model, DRIVER_NAME, sizeof(vpu->mdev.model));\n\tmedia_device_init(&vpu->mdev);\n\tvpu->mdev.ops = &hantro_m2m_media_ops;\n\tvpu->v4l2_dev.mdev = &vpu->mdev;\n\n\tret = hantro_add_enc_func(vpu);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register encoder\\n\");\n\t\tgoto err_m2m_rel;\n\t}\n\n\tret = hantro_add_dec_func(vpu);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register decoder\\n\");\n\t\tgoto err_rm_enc_func;\n\t}\n\n\tret = media_device_register(&vpu->mdev);\n\tif (ret) {\n\t\tv4l2_err(&vpu->v4l2_dev, \"Failed to register mem2mem media device\\n\");\n\t\tgoto err_rm_dec_func;\n\t}\n\n\treturn 0;\n\nerr_rm_dec_func:\n\thantro_remove_dec_func(vpu);\nerr_rm_enc_func:\n\thantro_remove_enc_func(vpu);\nerr_m2m_rel:\n\tmedia_device_cleanup(&vpu->mdev);\n\tv4l2_m2m_release(vpu->m2m_dev);\nerr_v4l2_unreg:\n\tv4l2_device_unregister(&vpu->v4l2_dev);\nerr_clk_unprepare:\n\tclk_bulk_unprepare(vpu->variant->num_clocks, vpu->clocks);\nerr_rst_assert:\n\treset_control_assert(vpu->resets);\nerr_pm_disable:\n\tpm_runtime_dont_use_autosuspend(vpu->dev);\n\tpm_runtime_disable(vpu->dev);\n\treturn ret;\n}\n\nstatic void hantro_remove(struct platform_device *pdev)\n{\n\tstruct hantro_dev *vpu = platform_get_drvdata(pdev);\n\n\tv4l2_info(&vpu->v4l2_dev, \"Removing %s\\n\", pdev->name);\n\n\tmedia_device_unregister(&vpu->mdev);\n\thantro_remove_dec_func(vpu);\n\thantro_remove_enc_func(vpu);\n\tmedia_device_cleanup(&vpu->mdev);\n\tv4l2_m2m_release(vpu->m2m_dev);\n\tv4l2_device_unregister(&vpu->v4l2_dev);\n\tclk_bulk_unprepare(vpu->variant->num_clocks, vpu->clocks);\n\treset_control_assert(vpu->resets);\n\tpm_runtime_dont_use_autosuspend(vpu->dev);\n\tpm_runtime_disable(vpu->dev);\n}\n\n#ifdef CONFIG_PM\nstatic int hantro_runtime_resume(struct device *dev)\n{\n\tstruct hantro_dev *vpu = dev_get_drvdata(dev);\n\n\tif (vpu->variant->runtime_resume)\n\t\treturn vpu->variant->runtime_resume(vpu);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops hantro_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(NULL, hantro_runtime_resume, NULL)\n};\n\nstatic struct platform_driver hantro_driver = {\n\t.probe = hantro_probe,\n\t.remove_new = hantro_remove,\n\t.driver = {\n\t\t   .name = DRIVER_NAME,\n\t\t   .of_match_table = of_hantro_match,\n\t\t   .pm = &hantro_pm_ops,\n\t},\n};\nmodule_platform_driver(hantro_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Alpha Lin <Alpha.Lin@Rock-Chips.com>\");\nMODULE_AUTHOR(\"Tomasz Figa <tfiga@chromium.org>\");\nMODULE_AUTHOR(\"Ezequiel Garcia <ezequiel@collabora.com>\");\nMODULE_DESCRIPTION(\"Hantro VPU codec driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}