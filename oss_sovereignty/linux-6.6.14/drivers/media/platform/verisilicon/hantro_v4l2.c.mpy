{
  "module_name": "hantro_v4l2.c",
  "hash_id": "f006080e6cb467ff12902b77d07676be6ac02b4a4fce64a7348775dac3b25169",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/verisilicon/hantro_v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/videodev2.h>\n#include <linux/workqueue.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-mem2mem.h>\n\n#include \"hantro.h\"\n#include \"hantro_hw.h\"\n#include \"hantro_v4l2.h\"\n\n#define  HANTRO_DEFAULT_BIT_DEPTH 8\n\nstatic int hantro_set_fmt_out(struct hantro_ctx *ctx,\n\t\t\t      struct v4l2_pix_format_mplane *pix_mp,\n\t\t\t      bool need_postproc);\nstatic int hantro_set_fmt_cap(struct hantro_ctx *ctx,\n\t\t\t      struct v4l2_pix_format_mplane *pix_mp);\n\nstatic const struct hantro_fmt *\nhantro_get_formats(const struct hantro_ctx *ctx, unsigned int *num_fmts, bool need_postproc)\n{\n\tconst struct hantro_fmt *formats;\n\n\tif (need_postproc) {\n\t\t*num_fmts = 0;\n\t\treturn NULL;\n\t}\n\n\tif (ctx->is_encoder) {\n\t\tformats = ctx->dev->variant->enc_fmts;\n\t\t*num_fmts = ctx->dev->variant->num_enc_fmts;\n\t} else {\n\t\tformats = ctx->dev->variant->dec_fmts;\n\t\t*num_fmts = ctx->dev->variant->num_dec_fmts;\n\t}\n\n\treturn formats;\n}\n\nstatic const struct hantro_fmt *\nhantro_get_postproc_formats(const struct hantro_ctx *ctx,\n\t\t\t    unsigned int *num_fmts)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\n\tif (ctx->is_encoder || !vpu->variant->postproc_fmts) {\n\t\t*num_fmts = 0;\n\t\treturn NULL;\n\t}\n\n\t*num_fmts = ctx->dev->variant->num_postproc_fmts;\n\treturn ctx->dev->variant->postproc_fmts;\n}\n\nint hantro_get_format_depth(u32 fourcc)\n{\n\tswitch (fourcc) {\n\tcase V4L2_PIX_FMT_P010:\n\tcase V4L2_PIX_FMT_P010_4L4:\n\tcase V4L2_PIX_FMT_NV15_4L4:\n\t\treturn 10;\n\tdefault:\n\t\treturn 8;\n\t}\n}\n\nstatic bool\nhantro_check_depth_match(const struct hantro_fmt *fmt, int bit_depth)\n{\n\tint fmt_depth;\n\n\tif (!fmt->match_depth && !fmt->postprocessed)\n\t\treturn true;\n\n\t \n\tif (!bit_depth)\n\t\tbit_depth = HANTRO_DEFAULT_BIT_DEPTH;\n\n\tfmt_depth = hantro_get_format_depth(fmt->fourcc);\n\n\t \n\tif (!fmt->match_depth)\n\t\treturn fmt_depth <= bit_depth;\n\n\treturn fmt_depth == bit_depth;\n}\n\nstatic const struct hantro_fmt *\nhantro_find_format(const struct hantro_ctx *ctx, u32 fourcc)\n{\n\tconst struct hantro_fmt *formats;\n\tunsigned int i, num_fmts;\n\n\tformats = hantro_get_formats(ctx, &num_fmts, HANTRO_AUTO_POSTPROC);\n\tfor (i = 0; i < num_fmts; i++)\n\t\tif (formats[i].fourcc == fourcc)\n\t\t\treturn &formats[i];\n\n\tformats = hantro_get_postproc_formats(ctx, &num_fmts);\n\tfor (i = 0; i < num_fmts; i++)\n\t\tif (formats[i].fourcc == fourcc)\n\t\t\treturn &formats[i];\n\treturn NULL;\n}\n\nconst struct hantro_fmt *\nhantro_get_default_fmt(const struct hantro_ctx *ctx, bool bitstream,\n\t\t       int bit_depth, bool need_postproc)\n{\n\tconst struct hantro_fmt *formats;\n\tunsigned int i, num_fmts;\n\n\tformats = hantro_get_formats(ctx, &num_fmts, need_postproc);\n\tfor (i = 0; i < num_fmts; i++) {\n\t\tif (bitstream == (formats[i].codec_mode !=\n\t\t\t\t  HANTRO_MODE_NONE) &&\n\t\t    hantro_check_depth_match(&formats[i], bit_depth))\n\t\t\treturn &formats[i];\n\t}\n\n\tformats = hantro_get_postproc_formats(ctx, &num_fmts);\n\tfor (i = 0; i < num_fmts; i++) {\n\t\tif (bitstream == (formats[i].codec_mode !=\n\t\t\t\t  HANTRO_MODE_NONE) &&\n\t\t    hantro_check_depth_match(&formats[i], bit_depth))\n\t\t\treturn &formats[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct hantro_dev *vpu = video_drvdata(file);\n\tstruct video_device *vdev = video_devdata(file);\n\n\tstrscpy(cap->driver, vpu->dev->driver->name, sizeof(cap->driver));\n\tstrscpy(cap->card, vdev->name, sizeof(cap->card));\n\treturn 0;\n}\n\nstatic int vidioc_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tstruct hantro_ctx *ctx = fh_to_ctx(priv);\n\tconst struct hantro_fmt *fmt;\n\n\tfmt = hantro_find_format(ctx, fsize->pixel_format);\n\tif (!fmt) {\n\t\tvpu_debug(0, \"unsupported bitstream format (%08x)\\n\",\n\t\t\t  fsize->pixel_format);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (fmt->codec_mode == HANTRO_MODE_NONE) {\n\t\tif (hantro_needs_postproc(ctx, fmt))\n\t\t\treturn hanto_postproc_enum_framesizes(ctx, fsize);\n\t\telse\n\t\t\treturn -ENOTTY;\n\t} else if (fsize->index != 0) {\n\t\tvpu_debug(0, \"invalid frame size index (expected 0, got %d)\\n\",\n\t\t\t  fsize->index);\n\t\treturn -EINVAL;\n\t}\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\n\tfsize->stepwise = fmt->frmsize;\n\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt(struct file *file, void *priv,\n\t\t\t   struct v4l2_fmtdesc *f, bool capture)\n\n{\n\tstruct hantro_ctx *ctx = fh_to_ctx(priv);\n\tconst struct hantro_fmt *fmt, *formats;\n\tunsigned int num_fmts, i, j = 0;\n\tbool skip_mode_none;\n\n\t \n\tskip_mode_none = capture == ctx->is_encoder;\n\n\tformats = hantro_get_formats(ctx, &num_fmts, HANTRO_AUTO_POSTPROC);\n\tfor (i = 0; i < num_fmts; i++) {\n\t\tbool mode_none = formats[i].codec_mode == HANTRO_MODE_NONE;\n\t\tfmt = &formats[i];\n\n\t\tif (skip_mode_none == mode_none)\n\t\t\tcontinue;\n\t\tif (!hantro_check_depth_match(fmt, ctx->bit_depth))\n\t\t\tcontinue;\n\t\tif (j == f->index) {\n\t\t\tf->pixelformat = fmt->fourcc;\n\t\t\treturn 0;\n\t\t}\n\t\t++j;\n\t}\n\n\t \n\tif (!capture)\n\t\treturn -EINVAL;\n\tformats = hantro_get_postproc_formats(ctx, &num_fmts);\n\tfor (i = 0; i < num_fmts; i++) {\n\t\tfmt = &formats[i];\n\n\t\tif (!hantro_check_depth_match(fmt, ctx->bit_depth))\n\t\t\tcontinue;\n\t\tif (j == f->index) {\n\t\t\tf->pixelformat = fmt->fourcc;\n\t\t\treturn 0;\n\t\t}\n\t\t++j;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn vidioc_enum_fmt(file, priv, f, true);\n}\n\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\treturn vidioc_enum_fmt(file, priv, f, false);\n}\n\nstatic int vidioc_g_fmt_out_mplane(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tstruct hantro_ctx *ctx = fh_to_ctx(priv);\n\n\tvpu_debug(4, \"f->type = %d\\n\", f->type);\n\n\t*pix_mp = ctx->src_fmt;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_cap_mplane(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\n\tstruct hantro_ctx *ctx = fh_to_ctx(priv);\n\n\tvpu_debug(4, \"f->type = %d\\n\", f->type);\n\n\t*pix_mp = ctx->dst_fmt;\n\n\treturn 0;\n}\n\nstatic int hantro_try_fmt(const struct hantro_ctx *ctx,\n\t\t\t  struct v4l2_pix_format_mplane *pix_mp,\n\t\t\t  enum v4l2_buf_type type)\n{\n\tconst struct hantro_fmt *fmt;\n\tconst struct hantro_fmt *vpu_fmt;\n\tbool capture = V4L2_TYPE_IS_CAPTURE(type);\n\tbool coded;\n\n\tcoded = capture == ctx->is_encoder;\n\n\tvpu_debug(4, \"trying format %c%c%c%c\\n\",\n\t\t  (pix_mp->pixelformat & 0x7f),\n\t\t  (pix_mp->pixelformat >> 8) & 0x7f,\n\t\t  (pix_mp->pixelformat >> 16) & 0x7f,\n\t\t  (pix_mp->pixelformat >> 24) & 0x7f);\n\n\tfmt = hantro_find_format(ctx, pix_mp->pixelformat);\n\tif (!fmt) {\n\t\tfmt = hantro_get_default_fmt(ctx, coded, HANTRO_DEFAULT_BIT_DEPTH, HANTRO_AUTO_POSTPROC);\n\t\tpix_mp->pixelformat = fmt->fourcc;\n\t}\n\n\tif (coded) {\n\t\tpix_mp->num_planes = 1;\n\t\tvpu_fmt = fmt;\n\t} else if (ctx->is_encoder) {\n\t\tvpu_fmt = hantro_find_format(ctx, ctx->dst_fmt.pixelformat);\n\t} else {\n\t\t \n\t\tpix_mp->width = ctx->src_fmt.width;\n\t\tpix_mp->height = ctx->src_fmt.height;\n\t\tvpu_fmt = fmt;\n\t}\n\n\tpix_mp->field = V4L2_FIELD_NONE;\n\n\tv4l2_apply_frmsize_constraints(&pix_mp->width, &pix_mp->height,\n\t\t\t\t       &vpu_fmt->frmsize);\n\n\tif (!coded) {\n\t\t \n\t\tv4l2_fill_pixfmt_mp(pix_mp, fmt->fourcc, pix_mp->width,\n\t\t\t\t    pix_mp->height);\n\t\tif (ctx->vpu_src_fmt->fourcc == V4L2_PIX_FMT_H264_SLICE &&\n\t\t    !hantro_needs_postproc(ctx, fmt))\n\t\t\tpix_mp->plane_fmt[0].sizeimage +=\n\t\t\t\thantro_h264_mv_size(pix_mp->width,\n\t\t\t\t\t\t    pix_mp->height);\n\t\telse if (ctx->vpu_src_fmt->fourcc == V4L2_PIX_FMT_VP9_FRAME &&\n\t\t\t !hantro_needs_postproc(ctx, fmt))\n\t\t\tpix_mp->plane_fmt[0].sizeimage +=\n\t\t\t\thantro_vp9_mv_size(pix_mp->width,\n\t\t\t\t\t\t   pix_mp->height);\n\t\telse if (ctx->vpu_src_fmt->fourcc == V4L2_PIX_FMT_HEVC_SLICE &&\n\t\t\t !hantro_needs_postproc(ctx, fmt))\n\t\t\tpix_mp->plane_fmt[0].sizeimage +=\n\t\t\t\thantro_hevc_mv_size(pix_mp->width,\n\t\t\t\t\t\t    pix_mp->height);\n\t\telse if (ctx->vpu_src_fmt->fourcc == V4L2_PIX_FMT_AV1_FRAME &&\n\t\t\t !hantro_needs_postproc(ctx, fmt))\n\t\t\tpix_mp->plane_fmt[0].sizeimage +=\n\t\t\t\thantro_av1_mv_size(pix_mp->width,\n\t\t\t\t\t\t   pix_mp->height);\n\t} else if (!pix_mp->plane_fmt[0].sizeimage) {\n\t\t \n\t\tpix_mp->plane_fmt[0].sizeimage = fmt->header_size +\n\t\t\tpix_mp->width * pix_mp->height * fmt->max_depth;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_cap_mplane(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_format *f)\n{\n\treturn hantro_try_fmt(fh_to_ctx(priv), &f->fmt.pix_mp, f->type);\n}\n\nstatic int vidioc_try_fmt_out_mplane(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_format *f)\n{\n\treturn hantro_try_fmt(fh_to_ctx(priv), &f->fmt.pix_mp, f->type);\n}\n\nstatic void\nhantro_reset_fmt(struct v4l2_pix_format_mplane *fmt,\n\t\t const struct hantro_fmt *vpu_fmt)\n{\n\tmemset(fmt, 0, sizeof(*fmt));\n\n\tfmt->pixelformat = vpu_fmt->fourcc;\n\tfmt->field = V4L2_FIELD_NONE;\n\tfmt->colorspace = V4L2_COLORSPACE_JPEG;\n\tfmt->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tfmt->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tfmt->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n}\n\nstatic void\nhantro_reset_encoded_fmt(struct hantro_ctx *ctx)\n{\n\tconst struct hantro_fmt *vpu_fmt;\n\tstruct v4l2_pix_format_mplane fmt;\n\n\tvpu_fmt = hantro_get_default_fmt(ctx, true, HANTRO_DEFAULT_BIT_DEPTH, HANTRO_AUTO_POSTPROC);\n\tif (!vpu_fmt)\n\t\treturn;\n\n\thantro_reset_fmt(&fmt, vpu_fmt);\n\tfmt.width = vpu_fmt->frmsize.min_width;\n\tfmt.height = vpu_fmt->frmsize.min_height;\n\tif (ctx->is_encoder)\n\t\thantro_set_fmt_cap(ctx, &fmt);\n\telse\n\t\thantro_set_fmt_out(ctx, &fmt, HANTRO_AUTO_POSTPROC);\n}\n\nint\nhantro_reset_raw_fmt(struct hantro_ctx *ctx, int bit_depth, bool need_postproc)\n{\n\tconst struct hantro_fmt *raw_vpu_fmt;\n\tstruct v4l2_pix_format_mplane raw_fmt, *encoded_fmt;\n\tint ret;\n\n\traw_vpu_fmt = hantro_get_default_fmt(ctx, false, bit_depth, need_postproc);\n\tif (!raw_vpu_fmt)\n\t\treturn -EINVAL;\n\n\tif (ctx->is_encoder) {\n\t\tencoded_fmt = &ctx->dst_fmt;\n\t\tctx->vpu_src_fmt = raw_vpu_fmt;\n\t} else {\n\t\tencoded_fmt = &ctx->src_fmt;\n\t}\n\n\thantro_reset_fmt(&raw_fmt, raw_vpu_fmt);\n\traw_fmt.width = encoded_fmt->width;\n\traw_fmt.height = encoded_fmt->height;\n\tif (ctx->is_encoder)\n\t\tret = hantro_set_fmt_out(ctx, &raw_fmt, need_postproc);\n\telse\n\t\tret = hantro_set_fmt_cap(ctx, &raw_fmt);\n\n\tif (!ret) {\n\t\tctx->bit_depth = bit_depth;\n\t\tctx->need_postproc = need_postproc;\n\t}\n\n\treturn ret;\n}\n\nvoid hantro_reset_fmts(struct hantro_ctx *ctx)\n{\n\thantro_reset_encoded_fmt(ctx);\n\thantro_reset_raw_fmt(ctx, HANTRO_DEFAULT_BIT_DEPTH, HANTRO_AUTO_POSTPROC);\n}\n\nstatic void\nhantro_update_requires_request(struct hantro_ctx *ctx, u32 fourcc)\n{\n\tswitch (fourcc) {\n\tcase V4L2_PIX_FMT_JPEG:\n\t\tctx->fh.m2m_ctx->out_q_ctx.q.requires_requests = false;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG2_SLICE:\n\tcase V4L2_PIX_FMT_VP8_FRAME:\n\tcase V4L2_PIX_FMT_H264_SLICE:\n\tcase V4L2_PIX_FMT_HEVC_SLICE:\n\tcase V4L2_PIX_FMT_VP9_FRAME:\n\t\tctx->fh.m2m_ctx->out_q_ctx.q.requires_requests = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nhantro_update_requires_hold_capture_buf(struct hantro_ctx *ctx, u32 fourcc)\n{\n\tstruct vb2_queue *vq;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t     V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\n\tswitch (fourcc) {\n\tcase V4L2_PIX_FMT_JPEG:\n\tcase V4L2_PIX_FMT_MPEG2_SLICE:\n\tcase V4L2_PIX_FMT_VP8_FRAME:\n\tcase V4L2_PIX_FMT_HEVC_SLICE:\n\tcase V4L2_PIX_FMT_VP9_FRAME:\n\t\tvq->subsystem_flags &= ~(VB2_V4L2_FL_SUPPORTS_M2M_HOLD_CAPTURE_BUF);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_H264_SLICE:\n\t\tvq->subsystem_flags |= VB2_V4L2_FL_SUPPORTS_M2M_HOLD_CAPTURE_BUF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int hantro_set_fmt_out(struct hantro_ctx *ctx,\n\t\t\t      struct v4l2_pix_format_mplane *pix_mp,\n\t\t\t      bool need_postproc)\n{\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t     V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\tret = hantro_try_fmt(ctx, pix_mp, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ctx->is_encoder) {\n\t\tstruct vb2_queue *peer_vq;\n\n\t\t \n\t\tif (vb2_is_streaming(vq) || (vb2_is_busy(vq) &&\n\t\t    pix_mp->pixelformat != ctx->src_fmt.pixelformat))\n\t\t\treturn -EBUSY;\n\t\t \n\t\tpeer_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t  V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\t\tif (vb2_is_busy(peer_vq))\n\t\t\treturn -EBUSY;\n\t} else {\n\t\t \n\t\tif (vb2_is_busy(vq))\n\t\t\treturn -EBUSY;\n\t}\n\n\tctx->vpu_src_fmt = hantro_find_format(ctx, pix_mp->pixelformat);\n\tctx->src_fmt = *pix_mp;\n\n\t \n\tif (!ctx->is_encoder)\n\t\thantro_reset_raw_fmt(ctx,\n\t\t\t\t     hantro_get_format_depth(pix_mp->pixelformat),\n\t\t\t\t     need_postproc);\n\n\t \n\tctx->dst_fmt.colorspace = pix_mp->colorspace;\n\tctx->dst_fmt.ycbcr_enc = pix_mp->ycbcr_enc;\n\tctx->dst_fmt.xfer_func = pix_mp->xfer_func;\n\tctx->dst_fmt.quantization = pix_mp->quantization;\n\n\thantro_update_requires_request(ctx, pix_mp->pixelformat);\n\thantro_update_requires_hold_capture_buf(ctx, pix_mp->pixelformat);\n\n\tvpu_debug(0, \"OUTPUT codec mode: %d\\n\", ctx->vpu_src_fmt->codec_mode);\n\tvpu_debug(0, \"fmt - w: %d, h: %d\\n\",\n\t\t  pix_mp->width, pix_mp->height);\n\treturn 0;\n}\n\nstatic int hantro_set_fmt_cap(struct hantro_ctx *ctx,\n\t\t\t      struct v4l2_pix_format_mplane *pix_mp)\n{\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\t \n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t     V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\tif (ctx->is_encoder) {\n\t\tstruct vb2_queue *peer_vq;\n\n\t\t \n\t\tpeer_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t  V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\n\t\tif (vb2_is_busy(peer_vq) &&\n\t\t    (pix_mp->pixelformat != ctx->dst_fmt.pixelformat ||\n\t\t     pix_mp->height != ctx->dst_fmt.height ||\n\t\t     pix_mp->width != ctx->dst_fmt.width))\n\t\t\treturn -EBUSY;\n\t}\n\n\tret = hantro_try_fmt(ctx, pix_mp, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->vpu_dst_fmt = hantro_find_format(ctx, pix_mp->pixelformat);\n\tctx->dst_fmt = *pix_mp;\n\n\t \n\tif (ctx->is_encoder)\n\t\thantro_reset_raw_fmt(ctx, HANTRO_DEFAULT_BIT_DEPTH, HANTRO_AUTO_POSTPROC);\n\n\t \n\tctx->src_fmt.colorspace = pix_mp->colorspace;\n\tctx->src_fmt.ycbcr_enc = pix_mp->ycbcr_enc;\n\tctx->src_fmt.xfer_func = pix_mp->xfer_func;\n\tctx->src_fmt.quantization = pix_mp->quantization;\n\n\tvpu_debug(0, \"CAPTURE codec mode: %d\\n\", ctx->vpu_dst_fmt->codec_mode);\n\tvpu_debug(0, \"fmt - w: %d, h: %d\\n\",\n\t\t  pix_mp->width, pix_mp->height);\n\n\thantro_update_requires_request(ctx, pix_mp->pixelformat);\n\n\treturn 0;\n}\n\nstatic int\nvidioc_s_fmt_out_mplane(struct file *file, void *priv, struct v4l2_format *f)\n{\n\treturn hantro_set_fmt_out(fh_to_ctx(priv), &f->fmt.pix_mp, HANTRO_AUTO_POSTPROC);\n}\n\nstatic int\nvidioc_s_fmt_cap_mplane(struct file *file, void *priv, struct v4l2_format *f)\n{\n\treturn hantro_set_fmt_cap(fh_to_ctx(priv), &f->fmt.pix_mp);\n}\n\nstatic int vidioc_g_selection(struct file *file, void *priv,\n\t\t\t      struct v4l2_selection *sel)\n{\n\tstruct hantro_ctx *ctx = fh_to_ctx(priv);\n\n\t \n\tif (!ctx->is_encoder ||\n\t    sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\tswitch (sel->target) {\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = ctx->src_fmt.width;\n\t\tsel->r.height = ctx->src_fmt.height;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tsel->r.top = 0;\n\t\tsel->r.left = 0;\n\t\tsel->r.width = ctx->dst_fmt.width;\n\t\tsel->r.height = ctx->dst_fmt.height;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_s_selection(struct file *file, void *priv,\n\t\t\t      struct v4l2_selection *sel)\n{\n\tstruct hantro_ctx *ctx = fh_to_ctx(priv);\n\tstruct v4l2_rect *rect = &sel->r;\n\tstruct vb2_queue *vq;\n\n\t \n\tif (!ctx->is_encoder ||\n\t    sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\t \n\tvq = v4l2_m2m_get_src_vq(ctx->fh.m2m_ctx);\n\tif (vb2_is_streaming(vq))\n\t\treturn -EBUSY;\n\n\tif (sel->target != V4L2_SEL_TGT_CROP)\n\t\treturn -EINVAL;\n\n\t \n\tif (rect->left != 0 || rect->top != 0 ||\n\t    round_up(rect->width, MB_DIM) != ctx->src_fmt.width ||\n\t    round_up(rect->height, MB_DIM) != ctx->src_fmt.height) {\n\t\t \n\t\trect->left = 0;\n\t\trect->top = 0;\n\t\trect->width = ctx->src_fmt.width;\n\t\trect->height = ctx->src_fmt.height;\n\t} else {\n\t\t \n\t\trect->width = round_up(rect->width, 4);\n\t}\n\n\tctx->dst_fmt.width = rect->width;\n\tctx->dst_fmt.height = rect->height;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_event hantro_eos_event = {\n\t.type = V4L2_EVENT_EOS\n};\n\nstatic int vidioc_encoder_cmd(struct file *file, void *priv,\n\t\t\t      struct v4l2_encoder_cmd *ec)\n{\n\tstruct hantro_ctx *ctx = fh_to_ctx(priv);\n\tint ret;\n\n\tret = v4l2_m2m_ioctl_try_encoder_cmd(file, priv, ec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!vb2_is_streaming(v4l2_m2m_get_src_vq(ctx->fh.m2m_ctx)) ||\n\t    !vb2_is_streaming(v4l2_m2m_get_dst_vq(ctx->fh.m2m_ctx)))\n\t\treturn 0;\n\n\tret = v4l2_m2m_ioctl_encoder_cmd(file, priv, ec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ec->cmd == V4L2_ENC_CMD_STOP &&\n\t    v4l2_m2m_has_stopped(ctx->fh.m2m_ctx))\n\t\tv4l2_event_queue_fh(&ctx->fh, &hantro_eos_event);\n\n\tif (ec->cmd == V4L2_ENC_CMD_START)\n\t\tvb2_clear_last_buffer_dequeued(&ctx->fh.m2m_ctx->cap_q_ctx.q);\n\n\treturn 0;\n}\n\nconst struct v4l2_ioctl_ops hantro_ioctl_ops = {\n\t.vidioc_querycap = vidioc_querycap,\n\t.vidioc_enum_framesizes = vidioc_enum_framesizes,\n\n\t.vidioc_try_fmt_vid_cap_mplane = vidioc_try_fmt_cap_mplane,\n\t.vidioc_try_fmt_vid_out_mplane = vidioc_try_fmt_out_mplane,\n\t.vidioc_s_fmt_vid_out_mplane = vidioc_s_fmt_out_mplane,\n\t.vidioc_s_fmt_vid_cap_mplane = vidioc_s_fmt_cap_mplane,\n\t.vidioc_g_fmt_vid_out_mplane = vidioc_g_fmt_out_mplane,\n\t.vidioc_g_fmt_vid_cap_mplane = vidioc_g_fmt_cap_mplane,\n\t.vidioc_enum_fmt_vid_out = vidioc_enum_fmt_vid_out,\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\n\t.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\n\t.vidioc_streamon = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_g_selection = vidioc_g_selection,\n\t.vidioc_s_selection = vidioc_s_selection,\n\n\t.vidioc_decoder_cmd = v4l2_m2m_ioctl_stateless_decoder_cmd,\n\t.vidioc_try_decoder_cmd = v4l2_m2m_ioctl_stateless_try_decoder_cmd,\n\n\t.vidioc_try_encoder_cmd = v4l2_m2m_ioctl_try_encoder_cmd,\n\t.vidioc_encoder_cmd = vidioc_encoder_cmd,\n};\n\nstatic int\nhantro_queue_setup(struct vb2_queue *vq, unsigned int *num_buffers,\n\t\t   unsigned int *num_planes, unsigned int sizes[],\n\t\t   struct device *alloc_devs[])\n{\n\tstruct hantro_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format_mplane *pixfmt;\n\tint i;\n\n\tswitch (vq->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tpixfmt = &ctx->dst_fmt;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tpixfmt = &ctx->src_fmt;\n\t\tbreak;\n\tdefault:\n\t\tvpu_err(\"invalid queue type: %d\\n\", vq->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (*num_planes) {\n\t\tif (*num_planes != pixfmt->num_planes)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < pixfmt->num_planes; ++i)\n\t\t\tif (sizes[i] < pixfmt->plane_fmt[i].sizeimage)\n\t\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t*num_planes = pixfmt->num_planes;\n\tfor (i = 0; i < pixfmt->num_planes; ++i)\n\t\tsizes[i] = pixfmt->plane_fmt[i].sizeimage;\n\treturn 0;\n}\n\nstatic int\nhantro_buf_plane_check(struct vb2_buffer *vb,\n\t\t       struct v4l2_pix_format_mplane *pixfmt)\n{\n\tunsigned int sz;\n\tint i;\n\n\tfor (i = 0; i < pixfmt->num_planes; ++i) {\n\t\tsz = pixfmt->plane_fmt[i].sizeimage;\n\t\tvpu_debug(4, \"plane %d size: %ld, sizeimage: %u\\n\",\n\t\t\t  i, vb2_plane_size(vb, i), sz);\n\t\tif (vb2_plane_size(vb, i) < sz) {\n\t\t\tvpu_err(\"plane %d is too small for output\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int hantro_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct hantro_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct v4l2_pix_format_mplane *pix_fmt;\n\tint ret;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\tpix_fmt = &ctx->src_fmt;\n\telse\n\t\tpix_fmt = &ctx->dst_fmt;\n\tret = hantro_buf_plane_check(vb, pix_fmt);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (V4L2_TYPE_IS_CAPTURE(vq->type)) {\n\t\tif (ctx->is_encoder)\n\t\t\tvb2_set_plane_payload(vb, 0, 0);\n\t\telse\n\t\t\tvb2_set_plane_payload(vb, 0, pix_fmt->plane_fmt[0].sizeimage);\n\t}\n\n\treturn 0;\n}\n\nstatic void hantro_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct hantro_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tif (V4L2_TYPE_IS_CAPTURE(vb->vb2_queue->type) &&\n\t    vb2_is_streaming(vb->vb2_queue) &&\n\t    v4l2_m2m_dst_buf_is_last(ctx->fh.m2m_ctx)) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < vb->num_planes; i++)\n\t\t\tvb2_set_plane_payload(vb, i, 0);\n\n\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tvbuf->sequence = ctx->sequence_cap++;\n\n\t\tv4l2_m2m_last_buffer_done(ctx->fh.m2m_ctx, vbuf);\n\t\tv4l2_event_queue_fh(&ctx->fh, &hantro_eos_event);\n\t\treturn;\n\t}\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic bool hantro_vq_is_coded(struct vb2_queue *q)\n{\n\tstruct hantro_ctx *ctx = vb2_get_drv_priv(q);\n\n\treturn ctx->is_encoder != V4L2_TYPE_IS_OUTPUT(q->type);\n}\n\nstatic int hantro_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct hantro_ctx *ctx = vb2_get_drv_priv(q);\n\tint ret = 0;\n\n\tv4l2_m2m_update_start_streaming_state(ctx->fh.m2m_ctx, q);\n\n\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\tctx->sequence_out = 0;\n\telse\n\t\tctx->sequence_cap = 0;\n\n\tif (hantro_vq_is_coded(q)) {\n\t\tenum hantro_codec_mode codec_mode;\n\n\t\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\t\tcodec_mode = ctx->vpu_src_fmt->codec_mode;\n\t\telse\n\t\t\tcodec_mode = ctx->vpu_dst_fmt->codec_mode;\n\n\t\tvpu_debug(4, \"Codec mode = %d\\n\", codec_mode);\n\t\tctx->codec_ops = &ctx->dev->variant->codec_ops[codec_mode];\n\t\tif (ctx->codec_ops->init) {\n\t\t\tret = ctx->codec_ops->init(ctx);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (hantro_needs_postproc(ctx, ctx->vpu_dst_fmt)) {\n\t\t\tret = hantro_postproc_alloc(ctx);\n\t\t\tif (ret)\n\t\t\t\tgoto err_codec_exit;\n\t\t}\n\t}\n\treturn ret;\n\nerr_codec_exit:\n\tif (ctx->codec_ops->exit)\n\t\tctx->codec_ops->exit(ctx);\n\treturn ret;\n}\n\nstatic void\nhantro_return_bufs(struct vb2_queue *q,\n\t\t   struct vb2_v4l2_buffer *(*buf_remove)(struct v4l2_m2m_ctx *))\n{\n\tstruct hantro_ctx *ctx = vb2_get_drv_priv(q);\n\n\tfor (;;) {\n\t\tstruct vb2_v4l2_buffer *vbuf;\n\n\t\tvbuf = buf_remove(ctx->fh.m2m_ctx);\n\t\tif (!vbuf)\n\t\t\tbreak;\n\t\tv4l2_ctrl_request_complete(vbuf->vb2_buf.req_obj.req,\n\t\t\t\t\t   &ctx->ctrl_handler);\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic void hantro_stop_streaming(struct vb2_queue *q)\n{\n\tstruct hantro_ctx *ctx = vb2_get_drv_priv(q);\n\n\tif (hantro_vq_is_coded(q)) {\n\t\thantro_postproc_free(ctx);\n\t\tif (ctx->codec_ops && ctx->codec_ops->exit)\n\t\t\tctx->codec_ops->exit(ctx);\n\t}\n\n\t \n\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\thantro_return_bufs(q, v4l2_m2m_src_buf_remove);\n\telse\n\t\thantro_return_bufs(q, v4l2_m2m_dst_buf_remove);\n\n\tv4l2_m2m_update_stop_streaming_state(ctx->fh.m2m_ctx, q);\n\n\tif (V4L2_TYPE_IS_OUTPUT(q->type) &&\n\t    v4l2_m2m_has_stopped(ctx->fh.m2m_ctx))\n\t\tv4l2_event_queue_fh(&ctx->fh, &hantro_eos_event);\n}\n\nstatic void hantro_buf_request_complete(struct vb2_buffer *vb)\n{\n\tstruct hantro_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_ctrl_request_complete(vb->req_obj.req, &ctx->ctrl_handler);\n}\n\nstatic int hantro_buf_out_validate(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\treturn 0;\n}\n\nconst struct vb2_ops hantro_queue_ops = {\n\t.queue_setup = hantro_queue_setup,\n\t.buf_prepare = hantro_buf_prepare,\n\t.buf_queue = hantro_buf_queue,\n\t.buf_out_validate = hantro_buf_out_validate,\n\t.buf_request_complete = hantro_buf_request_complete,\n\t.start_streaming = hantro_start_streaming,\n\t.stop_streaming = hantro_stop_streaming,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}