{
  "module_name": "imx8m_vpu_hw.c",
  "hash_id": "ed1a03b573d4afa3aa3d5058890c8944d88980c2d1589699766be9917ae61bd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/verisilicon/imx8m_vpu_hw.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n\n#include \"hantro.h\"\n#include \"hantro_jpeg.h\"\n#include \"hantro_g1_regs.h\"\n#include \"hantro_g2_regs.h\"\n\n#define CTRL_SOFT_RESET\t\t0x00\n#define RESET_G1\t\tBIT(1)\n#define RESET_G2\t\tBIT(0)\n\n#define CTRL_CLOCK_ENABLE\t0x04\n#define CLOCK_G1\t\tBIT(1)\n#define CLOCK_G2\t\tBIT(0)\n\n#define CTRL_G1_DEC_FUSE\t0x08\n#define CTRL_G1_PP_FUSE\t\t0x0c\n#define CTRL_G2_DEC_FUSE\t0x10\n\nstatic void imx8m_soft_reset(struct hantro_dev *vpu, u32 reset_bits)\n{\n\tu32 val;\n\n\t \n\tval = readl(vpu->ctrl_base + CTRL_SOFT_RESET);\n\tval &= ~reset_bits;\n\twritel(val, vpu->ctrl_base + CTRL_SOFT_RESET);\n\n\tudelay(2);\n\n\t \n\tval = readl(vpu->ctrl_base + CTRL_SOFT_RESET);\n\tval |= reset_bits;\n\twritel(val, vpu->ctrl_base + CTRL_SOFT_RESET);\n}\n\nstatic void imx8m_clk_enable(struct hantro_dev *vpu, u32 clock_bits)\n{\n\tu32 val;\n\n\tval = readl(vpu->ctrl_base + CTRL_CLOCK_ENABLE);\n\tval |= clock_bits;\n\twritel(val, vpu->ctrl_base + CTRL_CLOCK_ENABLE);\n}\n\nstatic int imx8mq_runtime_resume(struct hantro_dev *vpu)\n{\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(vpu->variant->num_clocks, vpu->clocks);\n\tif (ret) {\n\t\tdev_err(vpu->dev, \"Failed to enable clocks\\n\");\n\t\treturn ret;\n\t}\n\n\timx8m_soft_reset(vpu, RESET_G1 | RESET_G2);\n\timx8m_clk_enable(vpu, CLOCK_G1 | CLOCK_G2);\n\n\t \n\twritel(0xffffffff, vpu->ctrl_base + CTRL_G1_DEC_FUSE);\n\twritel(0xffffffff, vpu->ctrl_base + CTRL_G1_PP_FUSE);\n\twritel(0xffffffff, vpu->ctrl_base + CTRL_G2_DEC_FUSE);\n\n\tclk_bulk_disable_unprepare(vpu->variant->num_clocks, vpu->clocks);\n\n\treturn 0;\n}\n\n \n\nstatic const struct hantro_fmt imx8m_vpu_postproc_fmts[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.codec_mode = HANTRO_MODE_NONE,\n\t\t.postprocessed = true,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = MB_DIM,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = MB_DIM,\n\t\t},\n\t},\n};\n\nstatic const struct hantro_fmt imx8m_vpu_dec_fmts[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV12,\n\t\t.codec_mode = HANTRO_MODE_NONE,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = MB_DIM,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = MB_DIM,\n\t\t},\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_MPEG2_SLICE,\n\t\t.codec_mode = HANTRO_MODE_MPEG2_DEC,\n\t\t.max_depth = 2,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_FHD_WIDTH,\n\t\t\t.step_width = MB_DIM,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_FHD_HEIGHT,\n\t\t\t.step_height = MB_DIM,\n\t\t},\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_VP8_FRAME,\n\t\t.codec_mode = HANTRO_MODE_VP8_DEC,\n\t\t.max_depth = 2,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = MB_DIM,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = MB_DIM,\n\t\t},\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_H264_SLICE,\n\t\t.codec_mode = HANTRO_MODE_H264_DEC,\n\t\t.max_depth = 2,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = MB_DIM,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = MB_DIM,\n\t\t},\n\t},\n};\n\nstatic const struct hantro_fmt imx8m_vpu_g2_postproc_fmts[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV12,\n\t\t.codec_mode = HANTRO_MODE_NONE,\n\t\t.match_depth = true,\n\t\t.postprocessed = true,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = MB_DIM,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = MB_DIM,\n\t\t},\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_P010,\n\t\t.codec_mode = HANTRO_MODE_NONE,\n\t\t.match_depth = true,\n\t\t.postprocessed = true,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = MB_DIM,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = MB_DIM,\n\t\t},\n\t},\n};\n\nstatic const struct hantro_fmt imx8m_vpu_g2_dec_fmts[] = {\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_NV12_4L4,\n\t\t.codec_mode = HANTRO_MODE_NONE,\n\t\t.match_depth = true,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = TILE_MB_DIM,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = TILE_MB_DIM,\n\t\t},\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_P010_4L4,\n\t\t.codec_mode = HANTRO_MODE_NONE,\n\t\t.match_depth = true,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = TILE_MB_DIM,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = TILE_MB_DIM,\n\t\t},\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_HEVC_SLICE,\n\t\t.codec_mode = HANTRO_MODE_HEVC_DEC,\n\t\t.max_depth = 2,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = TILE_MB_DIM,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = TILE_MB_DIM,\n\t\t},\n\t},\n\t{\n\t\t.fourcc = V4L2_PIX_FMT_VP9_FRAME,\n\t\t.codec_mode = HANTRO_MODE_VP9_DEC,\n\t\t.max_depth = 2,\n\t\t.frmsize = {\n\t\t\t.min_width = FMT_MIN_WIDTH,\n\t\t\t.max_width = FMT_UHD_WIDTH,\n\t\t\t.step_width = TILE_MB_DIM,\n\t\t\t.min_height = FMT_MIN_HEIGHT,\n\t\t\t.max_height = FMT_UHD_HEIGHT,\n\t\t\t.step_height = TILE_MB_DIM,\n\t\t},\n\t},\n};\n\nstatic irqreturn_t imx8m_vpu_g1_irq(int irq, void *dev_id)\n{\n\tstruct hantro_dev *vpu = dev_id;\n\tenum vb2_buffer_state state;\n\tu32 status;\n\n\tstatus = vdpu_read(vpu, G1_REG_INTERRUPT);\n\tstate = (status & G1_REG_INTERRUPT_DEC_RDY_INT) ?\n\t\t VB2_BUF_STATE_DONE : VB2_BUF_STATE_ERROR;\n\n\tvdpu_write(vpu, 0, G1_REG_INTERRUPT);\n\tvdpu_write(vpu, G1_REG_CONFIG_DEC_CLK_GATE_E, G1_REG_CONFIG);\n\n\thantro_irq_done(vpu, state);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int imx8mq_vpu_hw_init(struct hantro_dev *vpu)\n{\n\tvpu->ctrl_base = vpu->reg_bases[vpu->variant->num_regs - 1];\n\n\treturn 0;\n}\n\nstatic void imx8m_vpu_g1_reset(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\n\timx8m_soft_reset(vpu, RESET_G1);\n}\n\n \n\nstatic const struct hantro_codec_ops imx8mq_vpu_codec_ops[] = {\n\t[HANTRO_MODE_MPEG2_DEC] = {\n\t\t.run = hantro_g1_mpeg2_dec_run,\n\t\t.reset = imx8m_vpu_g1_reset,\n\t\t.init = hantro_mpeg2_dec_init,\n\t\t.exit = hantro_mpeg2_dec_exit,\n\t},\n\t[HANTRO_MODE_VP8_DEC] = {\n\t\t.run = hantro_g1_vp8_dec_run,\n\t\t.reset = imx8m_vpu_g1_reset,\n\t\t.init = hantro_vp8_dec_init,\n\t\t.exit = hantro_vp8_dec_exit,\n\t},\n\t[HANTRO_MODE_H264_DEC] = {\n\t\t.run = hantro_g1_h264_dec_run,\n\t\t.reset = imx8m_vpu_g1_reset,\n\t\t.init = hantro_h264_dec_init,\n\t\t.exit = hantro_h264_dec_exit,\n\t},\n};\n\nstatic const struct hantro_codec_ops imx8mq_vpu_g1_codec_ops[] = {\n\t[HANTRO_MODE_MPEG2_DEC] = {\n\t\t.run = hantro_g1_mpeg2_dec_run,\n\t\t.init = hantro_mpeg2_dec_init,\n\t\t.exit = hantro_mpeg2_dec_exit,\n\t},\n\t[HANTRO_MODE_VP8_DEC] = {\n\t\t.run = hantro_g1_vp8_dec_run,\n\t\t.init = hantro_vp8_dec_init,\n\t\t.exit = hantro_vp8_dec_exit,\n\t},\n\t[HANTRO_MODE_H264_DEC] = {\n\t\t.run = hantro_g1_h264_dec_run,\n\t\t.init = hantro_h264_dec_init,\n\t\t.exit = hantro_h264_dec_exit,\n\t},\n};\n\nstatic const struct hantro_codec_ops imx8mq_vpu_g2_codec_ops[] = {\n\t[HANTRO_MODE_HEVC_DEC] = {\n\t\t.run = hantro_g2_hevc_dec_run,\n\t\t.init = hantro_hevc_dec_init,\n\t\t.exit = hantro_hevc_dec_exit,\n\t},\n\t[HANTRO_MODE_VP9_DEC] = {\n\t\t.run = hantro_g2_vp9_dec_run,\n\t\t.done = hantro_g2_vp9_dec_done,\n\t\t.init = hantro_vp9_dec_init,\n\t\t.exit = hantro_vp9_dec_exit,\n\t},\n};\n\n \n\nstatic const struct hantro_irq imx8mq_irqs[] = {\n\t{ \"g1\", imx8m_vpu_g1_irq },\n};\n\nstatic const struct hantro_irq imx8mq_g2_irqs[] = {\n\t{ \"g2\", hantro_g2_irq },\n};\n\nstatic const char * const imx8mq_clk_names[] = { \"g1\", \"g2\", \"bus\" };\nstatic const char * const imx8mq_reg_names[] = { \"g1\", \"g2\", \"ctrl\" };\nstatic const char * const imx8mq_g1_clk_names[] = { \"g1\" };\nstatic const char * const imx8mq_g2_clk_names[] = { \"g2\" };\n\nconst struct hantro_variant imx8mq_vpu_variant = {\n\t.dec_fmts = imx8m_vpu_dec_fmts,\n\t.num_dec_fmts = ARRAY_SIZE(imx8m_vpu_dec_fmts),\n\t.postproc_fmts = imx8m_vpu_postproc_fmts,\n\t.num_postproc_fmts = ARRAY_SIZE(imx8m_vpu_postproc_fmts),\n\t.postproc_ops = &hantro_g1_postproc_ops,\n\t.codec = HANTRO_MPEG2_DECODER | HANTRO_VP8_DECODER |\n\t\t HANTRO_H264_DECODER,\n\t.codec_ops = imx8mq_vpu_codec_ops,\n\t.init = imx8mq_vpu_hw_init,\n\t.runtime_resume = imx8mq_runtime_resume,\n\t.irqs = imx8mq_irqs,\n\t.num_irqs = ARRAY_SIZE(imx8mq_irqs),\n\t.clk_names = imx8mq_clk_names,\n\t.num_clocks = ARRAY_SIZE(imx8mq_clk_names),\n\t.reg_names = imx8mq_reg_names,\n\t.num_regs = ARRAY_SIZE(imx8mq_reg_names)\n};\n\nconst struct hantro_variant imx8mq_vpu_g1_variant = {\n\t.dec_fmts = imx8m_vpu_dec_fmts,\n\t.num_dec_fmts = ARRAY_SIZE(imx8m_vpu_dec_fmts),\n\t.postproc_fmts = imx8m_vpu_postproc_fmts,\n\t.num_postproc_fmts = ARRAY_SIZE(imx8m_vpu_postproc_fmts),\n\t.postproc_ops = &hantro_g1_postproc_ops,\n\t.codec = HANTRO_MPEG2_DECODER | HANTRO_VP8_DECODER |\n\t\t HANTRO_H264_DECODER,\n\t.codec_ops = imx8mq_vpu_g1_codec_ops,\n\t.irqs = imx8mq_irqs,\n\t.num_irqs = ARRAY_SIZE(imx8mq_irqs),\n\t.clk_names = imx8mq_g1_clk_names,\n\t.num_clocks = ARRAY_SIZE(imx8mq_g1_clk_names),\n};\n\nconst struct hantro_variant imx8mq_vpu_g2_variant = {\n\t.dec_offset = 0x0,\n\t.dec_fmts = imx8m_vpu_g2_dec_fmts,\n\t.num_dec_fmts = ARRAY_SIZE(imx8m_vpu_g2_dec_fmts),\n\t.postproc_fmts = imx8m_vpu_g2_postproc_fmts,\n\t.num_postproc_fmts = ARRAY_SIZE(imx8m_vpu_g2_postproc_fmts),\n\t.postproc_ops = &hantro_g2_postproc_ops,\n\t.codec = HANTRO_HEVC_DECODER | HANTRO_VP9_DECODER,\n\t.codec_ops = imx8mq_vpu_g2_codec_ops,\n\t.irqs = imx8mq_g2_irqs,\n\t.num_irqs = ARRAY_SIZE(imx8mq_g2_irqs),\n\t.clk_names = imx8mq_g2_clk_names,\n\t.num_clocks = ARRAY_SIZE(imx8mq_g2_clk_names),\n};\n\nconst struct hantro_variant imx8mm_vpu_g1_variant = {\n\t.dec_fmts = imx8m_vpu_dec_fmts,\n\t.num_dec_fmts = ARRAY_SIZE(imx8m_vpu_dec_fmts),\n\t.codec = HANTRO_MPEG2_DECODER | HANTRO_VP8_DECODER |\n\t\t HANTRO_H264_DECODER,\n\t.codec_ops = imx8mq_vpu_g1_codec_ops,\n\t.irqs = imx8mq_irqs,\n\t.num_irqs = ARRAY_SIZE(imx8mq_irqs),\n\t.clk_names = imx8mq_g1_clk_names,\n\t.num_clocks = ARRAY_SIZE(imx8mq_g1_clk_names),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}