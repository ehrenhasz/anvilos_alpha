{
  "module_name": "hantro_g2_hevc_dec.c",
  "hash_id": "4f4ef81e2052b717ad4c52f14a4e02d9c67d83c845c6ffc3774cf4d348b40663",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/verisilicon/hantro_g2_hevc_dec.c",
  "human_readable_source": "\n \n\n#include \"hantro_hw.h\"\n#include \"hantro_g2_regs.h\"\n\n#define G2_ALIGN\t16\n\nstatic size_t hantro_hevc_chroma_offset(struct hantro_ctx *ctx)\n{\n\treturn ctx->dst_fmt.width * ctx->dst_fmt.height * ctx->bit_depth / 8;\n}\n\nstatic size_t hantro_hevc_motion_vectors_offset(struct hantro_ctx *ctx)\n{\n\tsize_t cr_offset = hantro_hevc_chroma_offset(ctx);\n\n\treturn ALIGN((cr_offset * 3) / 2, G2_ALIGN);\n}\n\nstatic void prepare_tile_info_buffer(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tconst struct hantro_hevc_dec_ctrls *ctrls = &ctx->hevc_dec.ctrls;\n\tconst struct v4l2_ctrl_hevc_pps *pps = ctrls->pps;\n\tconst struct v4l2_ctrl_hevc_sps *sps = ctrls->sps;\n\tu16 *p = (u16 *)((u8 *)ctx->hevc_dec.tile_sizes.cpu);\n\tunsigned int num_tile_rows = pps->num_tile_rows_minus1 + 1;\n\tunsigned int num_tile_cols = pps->num_tile_columns_minus1 + 1;\n\tunsigned int pic_width_in_ctbs, pic_height_in_ctbs;\n\tunsigned int max_log2_ctb_size, ctb_size;\n\tbool tiles_enabled, uniform_spacing;\n\tu32 no_chroma = 0;\n\n\ttiles_enabled = !!(pps->flags & V4L2_HEVC_PPS_FLAG_TILES_ENABLED);\n\tuniform_spacing = !!(pps->flags & V4L2_HEVC_PPS_FLAG_UNIFORM_SPACING);\n\n\thantro_reg_write(vpu, &g2_tile_e, tiles_enabled);\n\n\tmax_log2_ctb_size = sps->log2_min_luma_coding_block_size_minus3 + 3 +\n\t\t\t    sps->log2_diff_max_min_luma_coding_block_size;\n\tpic_width_in_ctbs = (sps->pic_width_in_luma_samples +\n\t\t\t    (1 << max_log2_ctb_size) - 1) >> max_log2_ctb_size;\n\tpic_height_in_ctbs = (sps->pic_height_in_luma_samples + (1 << max_log2_ctb_size) - 1)\n\t\t\t     >> max_log2_ctb_size;\n\tctb_size = 1 << max_log2_ctb_size;\n\n\tvpu_debug(1, \"Preparing tile sizes buffer for %dx%d CTBs (CTB size %d)\\n\",\n\t\t  pic_width_in_ctbs, pic_height_in_ctbs, ctb_size);\n\n\tif (tiles_enabled) {\n\t\tunsigned int i, j, h;\n\n\t\tvpu_debug(1, \"Tiles enabled! %dx%d\\n\", num_tile_cols, num_tile_rows);\n\n\t\thantro_reg_write(vpu, &g2_num_tile_rows, num_tile_rows);\n\t\thantro_reg_write(vpu, &g2_num_tile_cols, num_tile_cols);\n\n\t\t \n\t\tif (!uniform_spacing) {\n\t\t\tu32 tmp_w = 0, tmp_h = 0;\n\n\t\t\tfor (i = 0; i < num_tile_rows; i++) {\n\t\t\t\tif (i == num_tile_rows - 1)\n\t\t\t\t\th = pic_height_in_ctbs - tmp_h;\n\t\t\t\telse\n\t\t\t\t\th = pps->row_height_minus1[i] + 1;\n\t\t\t\ttmp_h += h;\n\t\t\t\tif (i == 0 && h == 1 && ctb_size == 16)\n\t\t\t\t\tno_chroma = 1;\n\t\t\t\tfor (j = 0, tmp_w = 0; j < num_tile_cols - 1; j++) {\n\t\t\t\t\ttmp_w += pps->column_width_minus1[j] + 1;\n\t\t\t\t\t*p++ = pps->column_width_minus1[j] + 1;\n\t\t\t\t\t*p++ = h;\n\t\t\t\t\tif (i == 0 && h == 1 && ctb_size == 16)\n\t\t\t\t\t\tno_chroma = 1;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\t*p++ = pic_width_in_ctbs - tmp_w;\n\t\t\t\t*p++ = h;\n\t\t\t}\n\t\t} else {  \n\t\t\tu32 tmp, prev_h, prev_w;\n\n\t\t\tfor (i = 0, prev_h = 0; i < num_tile_rows; i++) {\n\t\t\t\ttmp = (i + 1) * pic_height_in_ctbs / num_tile_rows;\n\t\t\t\th = tmp - prev_h;\n\t\t\t\tprev_h = tmp;\n\t\t\t\tif (i == 0 && h == 1 && ctb_size == 16)\n\t\t\t\t\tno_chroma = 1;\n\t\t\t\tfor (j = 0, prev_w = 0; j < num_tile_cols; j++) {\n\t\t\t\t\ttmp = (j + 1) * pic_width_in_ctbs / num_tile_cols;\n\t\t\t\t\t*p++ = tmp - prev_w;\n\t\t\t\t\t*p++ = h;\n\t\t\t\t\tif (j == 0 &&\n\t\t\t\t\t    (pps->column_width_minus1[0] + 1) == 1 &&\n\t\t\t\t\t    ctb_size == 16)\n\t\t\t\t\t\tno_chroma = 1;\n\t\t\t\t\tprev_w = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\thantro_reg_write(vpu, &g2_num_tile_rows, 1);\n\t\thantro_reg_write(vpu, &g2_num_tile_cols, 1);\n\n\t\t \n\t\tp[0] = pic_width_in_ctbs;\n\t\tp[1] = pic_height_in_ctbs;\n\t}\n\n\tif (no_chroma)\n\t\tvpu_debug(1, \"%s: no chroma!\\n\", __func__);\n}\n\nstatic int compute_header_skip_length(struct hantro_ctx *ctx)\n{\n\tconst struct hantro_hevc_dec_ctrls *ctrls = &ctx->hevc_dec.ctrls;\n\tconst struct v4l2_ctrl_hevc_decode_params *decode_params = ctrls->decode_params;\n\tconst struct v4l2_ctrl_hevc_sps *sps = ctrls->sps;\n\tconst struct v4l2_ctrl_hevc_pps *pps = ctrls->pps;\n\tint skip = 0;\n\n\tif (pps->flags & V4L2_HEVC_PPS_FLAG_OUTPUT_FLAG_PRESENT)\n\t\t \n\t\tskip++;\n\n\tif (sps->flags & V4L2_HEVC_SPS_FLAG_SEPARATE_COLOUR_PLANE)\n\t\t \n\t\tskip += 2;\n\n\tif (!(decode_params->flags & V4L2_HEVC_DECODE_PARAM_FLAG_IDR_PIC)) {\n\t\t \n\t\tskip += sps->log2_max_pic_order_cnt_lsb_minus4 + 4;\n\n\t\t \n\t\tskip++;\n\n\t\tif (decode_params->short_term_ref_pic_set_size)\n\t\t\t \n\t\t\tskip += decode_params->short_term_ref_pic_set_size;\n\t\telse if (sps->num_short_term_ref_pic_sets > 1)\n\t\t\tskip += fls(sps->num_short_term_ref_pic_sets - 1);\n\n\t\tskip += decode_params->long_term_ref_pic_set_size;\n\t}\n\n\treturn skip;\n}\n\nstatic void set_params(struct hantro_ctx *ctx)\n{\n\tconst struct hantro_hevc_dec_ctrls *ctrls = &ctx->hevc_dec.ctrls;\n\tconst struct v4l2_ctrl_hevc_sps *sps = ctrls->sps;\n\tconst struct v4l2_ctrl_hevc_pps *pps = ctrls->pps;\n\tconst struct v4l2_ctrl_hevc_decode_params *decode_params = ctrls->decode_params;\n\tstruct hantro_dev *vpu = ctx->dev;\n\tu32 min_log2_cb_size, max_log2_ctb_size, min_cb_size, max_ctb_size;\n\tu32 pic_width_in_min_cbs, pic_height_in_min_cbs;\n\tu32 pic_width_aligned, pic_height_aligned;\n\tu32 partial_ctb_x, partial_ctb_y;\n\n\thantro_reg_write(vpu, &g2_bit_depth_y_minus8, sps->bit_depth_luma_minus8);\n\thantro_reg_write(vpu, &g2_bit_depth_c_minus8, sps->bit_depth_chroma_minus8);\n\n\thantro_reg_write(vpu, &g2_hdr_skip_length, compute_header_skip_length(ctx));\n\n\tmin_log2_cb_size = sps->log2_min_luma_coding_block_size_minus3 + 3;\n\tmax_log2_ctb_size = min_log2_cb_size + sps->log2_diff_max_min_luma_coding_block_size;\n\n\thantro_reg_write(vpu, &g2_min_cb_size, min_log2_cb_size);\n\thantro_reg_write(vpu, &g2_max_cb_size, max_log2_ctb_size);\n\n\tmin_cb_size = 1 << min_log2_cb_size;\n\tmax_ctb_size = 1 << max_log2_ctb_size;\n\n\tpic_width_in_min_cbs = sps->pic_width_in_luma_samples / min_cb_size;\n\tpic_height_in_min_cbs = sps->pic_height_in_luma_samples / min_cb_size;\n\tpic_width_aligned = ALIGN(sps->pic_width_in_luma_samples, max_ctb_size);\n\tpic_height_aligned = ALIGN(sps->pic_height_in_luma_samples, max_ctb_size);\n\n\tpartial_ctb_x = !!(sps->pic_width_in_luma_samples != pic_width_aligned);\n\tpartial_ctb_y = !!(sps->pic_height_in_luma_samples != pic_height_aligned);\n\n\thantro_reg_write(vpu, &g2_partial_ctb_x, partial_ctb_x);\n\thantro_reg_write(vpu, &g2_partial_ctb_y, partial_ctb_y);\n\n\thantro_reg_write(vpu, &g2_pic_width_in_cbs, pic_width_in_min_cbs);\n\thantro_reg_write(vpu, &g2_pic_height_in_cbs, pic_height_in_min_cbs);\n\n\thantro_reg_write(vpu, &g2_pic_width_4x4,\n\t\t\t (pic_width_in_min_cbs * min_cb_size) / 4);\n\thantro_reg_write(vpu, &g2_pic_height_4x4,\n\t\t\t (pic_height_in_min_cbs * min_cb_size) / 4);\n\n\thantro_reg_write(vpu, &hevc_max_inter_hierdepth,\n\t\t\t sps->max_transform_hierarchy_depth_inter);\n\thantro_reg_write(vpu, &hevc_max_intra_hierdepth,\n\t\t\t sps->max_transform_hierarchy_depth_intra);\n\thantro_reg_write(vpu, &hevc_min_trb_size,\n\t\t\t sps->log2_min_luma_transform_block_size_minus2 + 2);\n\thantro_reg_write(vpu, &hevc_max_trb_size,\n\t\t\t sps->log2_min_luma_transform_block_size_minus2 + 2 +\n\t\t\t sps->log2_diff_max_min_luma_transform_block_size);\n\n\thantro_reg_write(vpu, &g2_tempor_mvp_e,\n\t\t\t !!(sps->flags & V4L2_HEVC_SPS_FLAG_SPS_TEMPORAL_MVP_ENABLED) &&\n\t\t\t !(decode_params->flags & V4L2_HEVC_DECODE_PARAM_FLAG_IDR_PIC));\n\thantro_reg_write(vpu, &g2_strong_smooth_e,\n\t\t\t !!(sps->flags & V4L2_HEVC_SPS_FLAG_STRONG_INTRA_SMOOTHING_ENABLED));\n\thantro_reg_write(vpu, &g2_asym_pred_e,\n\t\t\t !!(sps->flags & V4L2_HEVC_SPS_FLAG_AMP_ENABLED));\n\thantro_reg_write(vpu, &g2_sao_e,\n\t\t\t !!(sps->flags & V4L2_HEVC_SPS_FLAG_SAMPLE_ADAPTIVE_OFFSET));\n\thantro_reg_write(vpu, &g2_sign_data_hide,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_SIGN_DATA_HIDING_ENABLED));\n\n\tif (pps->flags & V4L2_HEVC_PPS_FLAG_CU_QP_DELTA_ENABLED) {\n\t\thantro_reg_write(vpu, &g2_cu_qpd_e, 1);\n\t\thantro_reg_write(vpu, &g2_max_cu_qpd_depth, pps->diff_cu_qp_delta_depth);\n\t} else {\n\t\thantro_reg_write(vpu, &g2_cu_qpd_e, 0);\n\t\thantro_reg_write(vpu, &g2_max_cu_qpd_depth, 0);\n\t}\n\n\thantro_reg_write(vpu, &g2_cb_qp_offset, pps->pps_cb_qp_offset);\n\thantro_reg_write(vpu, &g2_cr_qp_offset, pps->pps_cr_qp_offset);\n\n\thantro_reg_write(vpu, &g2_filt_offset_beta, pps->pps_beta_offset_div2);\n\thantro_reg_write(vpu, &g2_filt_offset_tc, pps->pps_tc_offset_div2);\n\thantro_reg_write(vpu, &g2_slice_hdr_ext_e,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_SLICE_SEGMENT_HEADER_EXTENSION_PRESENT));\n\thantro_reg_write(vpu, &g2_slice_hdr_ext_bits, pps->num_extra_slice_header_bits);\n\thantro_reg_write(vpu, &g2_slice_chqp_present,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT));\n\thantro_reg_write(vpu, &g2_weight_bipr_idc,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_WEIGHTED_BIPRED));\n\thantro_reg_write(vpu, &g2_transq_bypass,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_TRANSQUANT_BYPASS_ENABLED));\n\thantro_reg_write(vpu, &g2_list_mod_e,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_LISTS_MODIFICATION_PRESENT));\n\thantro_reg_write(vpu, &g2_entropy_sync_e,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_ENTROPY_CODING_SYNC_ENABLED));\n\thantro_reg_write(vpu, &g2_cabac_init_present,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_CABAC_INIT_PRESENT));\n\thantro_reg_write(vpu, &g2_idr_pic_e,\n\t\t\t !!(decode_params->flags & V4L2_HEVC_DECODE_PARAM_FLAG_IRAP_PIC));\n\thantro_reg_write(vpu, &hevc_parallel_merge,\n\t\t\t pps->log2_parallel_merge_level_minus2 + 2);\n\thantro_reg_write(vpu, &g2_pcm_filt_d,\n\t\t\t !!(sps->flags & V4L2_HEVC_SPS_FLAG_PCM_LOOP_FILTER_DISABLED));\n\thantro_reg_write(vpu, &g2_pcm_e,\n\t\t\t !!(sps->flags & V4L2_HEVC_SPS_FLAG_PCM_ENABLED));\n\tif (sps->flags & V4L2_HEVC_SPS_FLAG_PCM_ENABLED) {\n\t\thantro_reg_write(vpu, &g2_max_pcm_size,\n\t\t\t\t sps->log2_diff_max_min_pcm_luma_coding_block_size +\n\t\t\t\t sps->log2_min_pcm_luma_coding_block_size_minus3 + 3);\n\t\thantro_reg_write(vpu, &g2_min_pcm_size,\n\t\t\t\t sps->log2_min_pcm_luma_coding_block_size_minus3 + 3);\n\t\thantro_reg_write(vpu, &g2_bit_depth_pcm_y,\n\t\t\t\t sps->pcm_sample_bit_depth_luma_minus1 + 1);\n\t\thantro_reg_write(vpu, &g2_bit_depth_pcm_c,\n\t\t\t\t sps->pcm_sample_bit_depth_chroma_minus1 + 1);\n\t} else {\n\t\thantro_reg_write(vpu, &g2_max_pcm_size, 0);\n\t\thantro_reg_write(vpu, &g2_min_pcm_size, 0);\n\t\thantro_reg_write(vpu, &g2_bit_depth_pcm_y, 0);\n\t\thantro_reg_write(vpu, &g2_bit_depth_pcm_c, 0);\n\t}\n\n\thantro_reg_write(vpu, &g2_start_code_e, 1);\n\thantro_reg_write(vpu, &g2_init_qp, pps->init_qp_minus26 + 26);\n\thantro_reg_write(vpu, &g2_weight_pred_e,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_WEIGHTED_PRED));\n\thantro_reg_write(vpu, &g2_cabac_init_present,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_CABAC_INIT_PRESENT));\n\thantro_reg_write(vpu, &g2_const_intra_e,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_CONSTRAINED_INTRA_PRED));\n\thantro_reg_write(vpu, &g2_transform_skip,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_TRANSFORM_SKIP_ENABLED));\n\thantro_reg_write(vpu, &g2_out_filtering_dis,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_PPS_DISABLE_DEBLOCKING_FILTER));\n\thantro_reg_write(vpu, &g2_filt_ctrl_pres,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT));\n\thantro_reg_write(vpu, &g2_dependent_slice,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_DEPENDENT_SLICE_SEGMENT_ENABLED));\n\thantro_reg_write(vpu, &g2_filter_override,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_DEBLOCKING_FILTER_OVERRIDE_ENABLED));\n\thantro_reg_write(vpu, &g2_refidx0_active,\n\t\t\t pps->num_ref_idx_l0_default_active_minus1 + 1);\n\thantro_reg_write(vpu, &g2_refidx1_active,\n\t\t\t pps->num_ref_idx_l1_default_active_minus1 + 1);\n\thantro_reg_write(vpu, &g2_apf_threshold, 8);\n}\n\nstatic void set_ref_pic_list(struct hantro_ctx *ctx)\n{\n\tconst struct hantro_hevc_dec_ctrls *ctrls = &ctx->hevc_dec.ctrls;\n\tstruct hantro_dev *vpu = ctx->dev;\n\tconst struct v4l2_ctrl_hevc_decode_params *decode_params = ctrls->decode_params;\n\tu32 list0[V4L2_HEVC_DPB_ENTRIES_NUM_MAX] = {};\n\tu32 list1[V4L2_HEVC_DPB_ENTRIES_NUM_MAX] = {};\n\tstatic const struct hantro_reg ref_pic_regs0[] = {\n\t\thevc_rlist_f0,\n\t\thevc_rlist_f1,\n\t\thevc_rlist_f2,\n\t\thevc_rlist_f3,\n\t\thevc_rlist_f4,\n\t\thevc_rlist_f5,\n\t\thevc_rlist_f6,\n\t\thevc_rlist_f7,\n\t\thevc_rlist_f8,\n\t\thevc_rlist_f9,\n\t\thevc_rlist_f10,\n\t\thevc_rlist_f11,\n\t\thevc_rlist_f12,\n\t\thevc_rlist_f13,\n\t\thevc_rlist_f14,\n\t\thevc_rlist_f15,\n\t};\n\tstatic const struct hantro_reg ref_pic_regs1[] = {\n\t\thevc_rlist_b0,\n\t\thevc_rlist_b1,\n\t\thevc_rlist_b2,\n\t\thevc_rlist_b3,\n\t\thevc_rlist_b4,\n\t\thevc_rlist_b5,\n\t\thevc_rlist_b6,\n\t\thevc_rlist_b7,\n\t\thevc_rlist_b8,\n\t\thevc_rlist_b9,\n\t\thevc_rlist_b10,\n\t\thevc_rlist_b11,\n\t\thevc_rlist_b12,\n\t\thevc_rlist_b13,\n\t\thevc_rlist_b14,\n\t\thevc_rlist_b15,\n\t};\n\tunsigned int i, j;\n\n\t \n\tj = 0;\n\tfor (i = 0; i < decode_params->num_poc_st_curr_before && j < ARRAY_SIZE(list0); i++)\n\t\tlist0[j++] = decode_params->poc_st_curr_before[i];\n\tfor (i = 0; i < decode_params->num_poc_st_curr_after && j < ARRAY_SIZE(list0); i++)\n\t\tlist0[j++] = decode_params->poc_st_curr_after[i];\n\tfor (i = 0; i < decode_params->num_poc_lt_curr && j < ARRAY_SIZE(list0); i++)\n\t\tlist0[j++] = decode_params->poc_lt_curr[i];\n\n\t \n\ti = 0;\n\twhile (j < ARRAY_SIZE(list0))\n\t\tlist0[j++] = list0[i++];\n\n\tj = 0;\n\tfor (i = 0; i < decode_params->num_poc_st_curr_after && j < ARRAY_SIZE(list1); i++)\n\t\tlist1[j++] = decode_params->poc_st_curr_after[i];\n\tfor (i = 0; i < decode_params->num_poc_st_curr_before && j < ARRAY_SIZE(list1); i++)\n\t\tlist1[j++] = decode_params->poc_st_curr_before[i];\n\tfor (i = 0; i < decode_params->num_poc_lt_curr && j < ARRAY_SIZE(list1); i++)\n\t\tlist1[j++] = decode_params->poc_lt_curr[i];\n\n\ti = 0;\n\twhile (j < ARRAY_SIZE(list1))\n\t\tlist1[j++] = list1[i++];\n\n\tfor (i = 0; i < V4L2_HEVC_DPB_ENTRIES_NUM_MAX; i++) {\n\t\thantro_reg_write(vpu, &ref_pic_regs0[i], list0[i]);\n\t\thantro_reg_write(vpu, &ref_pic_regs1[i], list1[i]);\n\t}\n}\n\nstatic int set_ref(struct hantro_ctx *ctx)\n{\n\tconst struct hantro_hevc_dec_ctrls *ctrls = &ctx->hevc_dec.ctrls;\n\tconst struct v4l2_ctrl_hevc_pps *pps = ctrls->pps;\n\tconst struct v4l2_ctrl_hevc_decode_params *decode_params = ctrls->decode_params;\n\tconst struct v4l2_hevc_dpb_entry *dpb = decode_params->dpb;\n\tdma_addr_t luma_addr, chroma_addr, mv_addr = 0;\n\tstruct hantro_dev *vpu = ctx->dev;\n\tstruct vb2_v4l2_buffer *vb2_dst;\n\tstruct hantro_decoded_buffer *dst;\n\tsize_t cr_offset = hantro_hevc_chroma_offset(ctx);\n\tsize_t mv_offset = hantro_hevc_motion_vectors_offset(ctx);\n\tu32 max_ref_frames;\n\tu16 dpb_longterm_e;\n\tstatic const struct hantro_reg cur_poc[] = {\n\t\thevc_cur_poc_00,\n\t\thevc_cur_poc_01,\n\t\thevc_cur_poc_02,\n\t\thevc_cur_poc_03,\n\t\thevc_cur_poc_04,\n\t\thevc_cur_poc_05,\n\t\thevc_cur_poc_06,\n\t\thevc_cur_poc_07,\n\t\thevc_cur_poc_08,\n\t\thevc_cur_poc_09,\n\t\thevc_cur_poc_10,\n\t\thevc_cur_poc_11,\n\t\thevc_cur_poc_12,\n\t\thevc_cur_poc_13,\n\t\thevc_cur_poc_14,\n\t\thevc_cur_poc_15,\n\t};\n\tunsigned int i;\n\n\tmax_ref_frames = decode_params->num_poc_lt_curr +\n\t\tdecode_params->num_poc_st_curr_before +\n\t\tdecode_params->num_poc_st_curr_after;\n\t \n\tmax_ref_frames = max_ref_frames ? max_ref_frames : 1;\n\thantro_reg_write(vpu, &g2_num_ref_frames, max_ref_frames);\n\thantro_reg_write(vpu, &g2_filter_over_slices,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED));\n\thantro_reg_write(vpu, &g2_filter_over_tiles,\n\t\t\t !!(pps->flags & V4L2_HEVC_PPS_FLAG_LOOP_FILTER_ACROSS_TILES_ENABLED));\n\n\t \n\tfor (i = 0; i < decode_params->num_active_dpb_entries && i < ARRAY_SIZE(cur_poc); i++) {\n\t\tchar poc_diff = decode_params->pic_order_cnt_val - dpb[i].pic_order_cnt_val;\n\n\t\thantro_reg_write(vpu, &cur_poc[i], poc_diff);\n\t}\n\n\tif (i < ARRAY_SIZE(cur_poc)) {\n\t\t \n\t\thantro_reg_write(vpu, &cur_poc[i], 0);\n\t\ti++;\n\t}\n\n\t \n\tfor (; i < ARRAY_SIZE(cur_poc); i++)\n\t\thantro_reg_write(vpu, &cur_poc[i], decode_params->pic_order_cnt_val);\n\n\tset_ref_pic_list(ctx);\n\n\t \n\thantro_hevc_ref_init(ctx);\n\n\t \n\tdpb_longterm_e = 0;\n\tfor (i = 0; i < decode_params->num_active_dpb_entries &&\n\t     i < (V4L2_HEVC_DPB_ENTRIES_NUM_MAX - 1); i++) {\n\t\tluma_addr = hantro_hevc_get_ref_buf(ctx, dpb[i].pic_order_cnt_val);\n\t\tif (!luma_addr)\n\t\t\treturn -ENOMEM;\n\n\t\tchroma_addr = luma_addr + cr_offset;\n\t\tmv_addr = luma_addr + mv_offset;\n\n\t\tif (dpb[i].flags & V4L2_HEVC_DPB_ENTRY_LONG_TERM_REFERENCE)\n\t\t\tdpb_longterm_e |= BIT(V4L2_HEVC_DPB_ENTRIES_NUM_MAX - 1 - i);\n\n\t\thantro_write_addr(vpu, G2_REF_LUMA_ADDR(i), luma_addr);\n\t\thantro_write_addr(vpu, G2_REF_CHROMA_ADDR(i), chroma_addr);\n\t\thantro_write_addr(vpu, G2_REF_MV_ADDR(i), mv_addr);\n\t}\n\n\tvb2_dst = hantro_get_dst_buf(ctx);\n\tdst = vb2_to_hantro_decoded_buf(&vb2_dst->vb2_buf);\n\tluma_addr = hantro_get_dec_buf_addr(ctx, &dst->base.vb.vb2_buf);\n\tif (!luma_addr)\n\t\treturn -ENOMEM;\n\n\tif (hantro_hevc_add_ref_buf(ctx, decode_params->pic_order_cnt_val, luma_addr))\n\t\treturn -EINVAL;\n\n\tchroma_addr = luma_addr + cr_offset;\n\tmv_addr = luma_addr + mv_offset;\n\n\thantro_write_addr(vpu, G2_REF_LUMA_ADDR(i), luma_addr);\n\thantro_write_addr(vpu, G2_REF_CHROMA_ADDR(i), chroma_addr);\n\thantro_write_addr(vpu, G2_REF_MV_ADDR(i++), mv_addr);\n\n\thantro_write_addr(vpu, G2_OUT_LUMA_ADDR, luma_addr);\n\thantro_write_addr(vpu, G2_OUT_CHROMA_ADDR, chroma_addr);\n\thantro_write_addr(vpu, G2_OUT_MV_ADDR, mv_addr);\n\n\tfor (; i < V4L2_HEVC_DPB_ENTRIES_NUM_MAX; i++) {\n\t\thantro_write_addr(vpu, G2_REF_LUMA_ADDR(i), 0);\n\t\thantro_write_addr(vpu, G2_REF_CHROMA_ADDR(i), 0);\n\t\thantro_write_addr(vpu, G2_REF_MV_ADDR(i), 0);\n\t}\n\n\thantro_reg_write(vpu, &g2_refer_lterm_e, dpb_longterm_e);\n\n\treturn 0;\n}\n\nstatic void set_buffers(struct hantro_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *src_buf;\n\tstruct hantro_dev *vpu = ctx->dev;\n\tdma_addr_t src_dma;\n\tu32 src_len, src_buf_len;\n\n\tsrc_buf = hantro_get_src_buf(ctx);\n\n\t \n\tsrc_dma = vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\n\tsrc_len = vb2_get_plane_payload(&src_buf->vb2_buf, 0);\n\tsrc_buf_len = vb2_plane_size(&src_buf->vb2_buf, 0);\n\n\thantro_write_addr(vpu, G2_STREAM_ADDR, src_dma);\n\thantro_reg_write(vpu, &g2_stream_len, src_len);\n\thantro_reg_write(vpu, &g2_strm_buffer_len, src_buf_len);\n\thantro_reg_write(vpu, &g2_strm_start_offset, 0);\n\thantro_reg_write(vpu, &g2_write_mvs_e, 1);\n\n\thantro_write_addr(vpu, G2_TILE_SIZES_ADDR, ctx->hevc_dec.tile_sizes.dma);\n\thantro_write_addr(vpu, G2_TILE_FILTER_ADDR, ctx->hevc_dec.tile_filter.dma);\n\thantro_write_addr(vpu, G2_TILE_SAO_ADDR, ctx->hevc_dec.tile_sao.dma);\n\thantro_write_addr(vpu, G2_TILE_BSD_ADDR, ctx->hevc_dec.tile_bsd.dma);\n}\n\nstatic void prepare_scaling_list_buffer(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tconst struct hantro_hevc_dec_ctrls *ctrls = &ctx->hevc_dec.ctrls;\n\tconst struct v4l2_ctrl_hevc_scaling_matrix *sc = ctrls->scaling;\n\tconst struct v4l2_ctrl_hevc_sps *sps = ctrls->sps;\n\tu8 *p = ((u8 *)ctx->hevc_dec.scaling_lists.cpu);\n\tunsigned int scaling_list_enabled;\n\tunsigned int i, j, k;\n\n\tscaling_list_enabled = !!(sps->flags & V4L2_HEVC_SPS_FLAG_SCALING_LIST_ENABLED);\n\thantro_reg_write(vpu, &g2_scaling_list_e, scaling_list_enabled);\n\n\tif (!scaling_list_enabled)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(sc->scaling_list_dc_coef_16x16); i++)\n\t\t*p++ = sc->scaling_list_dc_coef_16x16[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(sc->scaling_list_dc_coef_32x32); i++)\n\t\t*p++ = sc->scaling_list_dc_coef_32x32[i];\n\n\t \n\tp += 8;\n\n\t \n\n\tfor (i = 0; i < 6; i++)\n\t\tfor (j = 0; j < 4; j++)\n\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t*p++ = sc->scaling_list_4x4[i][4 * k + j];\n\n\tfor (i = 0; i < 6; i++)\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tfor (k = 0; k < 8; k++)\n\t\t\t\t*p++ = sc->scaling_list_8x8[i][8 * k + j];\n\n\tfor (i = 0; i < 6; i++)\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tfor (k = 0; k < 8; k++)\n\t\t\t\t*p++ = sc->scaling_list_16x16[i][8 * k + j];\n\n\tfor (i = 0; i < 2; i++)\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tfor (k = 0; k < 8; k++)\n\t\t\t\t*p++ = sc->scaling_list_32x32[i][8 * k + j];\n\n\thantro_write_addr(vpu, G2_HEVC_SCALING_LIST_ADDR, ctx->hevc_dec.scaling_lists.dma);\n}\n\nint hantro_g2_hevc_dec_run(struct hantro_ctx *ctx)\n{\n\tstruct hantro_dev *vpu = ctx->dev;\n\tint ret;\n\n\thantro_g2_check_idle(vpu);\n\n\t \n\tret = hantro_hevc_dec_prepare_run(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tset_params(ctx);\n\n\t \n\tret = set_ref(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tset_buffers(ctx);\n\tprepare_tile_info_buffer(ctx);\n\n\tprepare_scaling_list_buffer(ctx);\n\n\thantro_end_prepare_run(ctx);\n\n\thantro_reg_write(vpu, &g2_mode, HEVC_DEC_MODE);\n\thantro_reg_write(vpu, &g2_clk_gate_e, 1);\n\n\t \n\thantro_reg_write(vpu, &g2_out_dis, 0);\n\n\t \n\thantro_reg_write(vpu, &g2_ref_compress_bypass, 1);\n\n\t \n\thantro_reg_write(vpu, &g2_buswidth, BUS_WIDTH_128);\n\thantro_reg_write(vpu, &g2_max_burst, 16);\n\n\t \n\thantro_reg_write(vpu, &g2_strm_swap, 0xf);\n\thantro_reg_write(vpu, &g2_dirmv_swap, 0xf);\n\thantro_reg_write(vpu, &g2_compress_swap, 0xf);\n\n\t \n\tvdpu_write(vpu, G2_REG_INTERRUPT_DEC_E, G2_REG_INTERRUPT);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}