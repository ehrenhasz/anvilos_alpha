{
  "module_name": "coda-h264.c",
  "hash_id": "a2bf8b6d5b8438cce6a62864eee27b2a909249de16c9c35d307f1249297f5533",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/chips-media/coda-h264.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/videodev2.h>\n\n#include \"coda.h\"\n\nstatic const u8 coda_filler_size[8] = { 0, 7, 14, 13, 12, 11, 10, 9 };\n\nstatic const u8 *coda_find_nal_header(const u8 *buf, const u8 *end)\n{\n\tu32 val = 0xffffffff;\n\n\tdo {\n\t\tval = val << 8 | *buf++;\n\t\tif (buf >= end)\n\t\t\treturn NULL;\n\t} while (val != 0x00000001);\n\n\treturn buf;\n}\n\nint coda_sps_parse_profile(struct coda_ctx *ctx, struct vb2_buffer *vb)\n{\n\tconst u8 *buf = vb2_plane_vaddr(vb, 0);\n\tconst u8 *end = buf + vb2_get_plane_payload(vb, 0);\n\n\t \n\tdo {\n\t\tbuf = coda_find_nal_header(buf, end);\n\t\tif (!buf)\n\t\t\treturn -EINVAL;\n\t} while ((*buf++ & 0x1f) != 0x7);\n\n\tctx->params.h264_profile_idc = buf[0];\n\tctx->params.h264_level_idc = buf[2];\n\n\treturn 0;\n}\n\nint coda_h264_filler_nal(int size, char *p)\n{\n\tif (size < 6)\n\t\treturn -EINVAL;\n\n\tp[0] = 0x00;\n\tp[1] = 0x00;\n\tp[2] = 0x00;\n\tp[3] = 0x01;\n\tp[4] = 0x0c;\n\tmemset(p + 5, 0xff, size - 6);\n\t \n\tp[size - 1] = 0x80;\n\n\treturn 0;\n}\n\nint coda_h264_padding(int size, char *p)\n{\n\tint nal_size;\n\tint diff;\n\n\tdiff = size - (size & ~0x7);\n\tif (diff == 0)\n\t\treturn 0;\n\n\tnal_size = coda_filler_size[diff];\n\tcoda_h264_filler_nal(nal_size, p);\n\n\treturn nal_size;\n}\n\nint coda_h264_profile(int profile_idc)\n{\n\tswitch (profile_idc) {\n\tcase 66: return V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE;\n\tcase 77: return V4L2_MPEG_VIDEO_H264_PROFILE_MAIN;\n\tcase 88: return V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED;\n\tcase 100: return V4L2_MPEG_VIDEO_H264_PROFILE_HIGH;\n\tdefault: return -EINVAL;\n\t}\n}\n\nint coda_h264_level(int level_idc)\n{\n\tswitch (level_idc) {\n\tcase 10: return V4L2_MPEG_VIDEO_H264_LEVEL_1_0;\n\tcase 9:  return V4L2_MPEG_VIDEO_H264_LEVEL_1B;\n\tcase 11: return V4L2_MPEG_VIDEO_H264_LEVEL_1_1;\n\tcase 12: return V4L2_MPEG_VIDEO_H264_LEVEL_1_2;\n\tcase 13: return V4L2_MPEG_VIDEO_H264_LEVEL_1_3;\n\tcase 20: return V4L2_MPEG_VIDEO_H264_LEVEL_2_0;\n\tcase 21: return V4L2_MPEG_VIDEO_H264_LEVEL_2_1;\n\tcase 22: return V4L2_MPEG_VIDEO_H264_LEVEL_2_2;\n\tcase 30: return V4L2_MPEG_VIDEO_H264_LEVEL_3_0;\n\tcase 31: return V4L2_MPEG_VIDEO_H264_LEVEL_3_1;\n\tcase 32: return V4L2_MPEG_VIDEO_H264_LEVEL_3_2;\n\tcase 40: return V4L2_MPEG_VIDEO_H264_LEVEL_4_0;\n\tcase 41: return V4L2_MPEG_VIDEO_H264_LEVEL_4_1;\n\tcase 42: return V4L2_MPEG_VIDEO_H264_LEVEL_4_2;\n\tcase 50: return V4L2_MPEG_VIDEO_H264_LEVEL_5_0;\n\tcase 51: return V4L2_MPEG_VIDEO_H264_LEVEL_5_1;\n\tdefault: return -EINVAL;\n\t}\n}\n\nstruct rbsp {\n\tchar *buf;\n\tint size;\n\tint pos;\n};\n\nstatic inline int rbsp_read_bit(struct rbsp *rbsp)\n{\n\tint shift = 7 - (rbsp->pos % 8);\n\tint ofs = rbsp->pos++ / 8;\n\n\tif (ofs >= rbsp->size)\n\t\treturn -EINVAL;\n\n\treturn (rbsp->buf[ofs] >> shift) & 1;\n}\n\nstatic inline int rbsp_write_bit(struct rbsp *rbsp, int bit)\n{\n\tint shift = 7 - (rbsp->pos % 8);\n\tint ofs = rbsp->pos++ / 8;\n\n\tif (ofs >= rbsp->size)\n\t\treturn -EINVAL;\n\n\trbsp->buf[ofs] &= ~(1 << shift);\n\trbsp->buf[ofs] |= bit << shift;\n\n\treturn 0;\n}\n\nstatic inline int rbsp_read_bits(struct rbsp *rbsp, int num, int *val)\n{\n\tint i, ret;\n\tint tmp = 0;\n\n\tif (num > 32)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = rbsp_read_bit(rbsp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ttmp |= ret << (num - i - 1);\n\t}\n\n\tif (val)\n\t\t*val = tmp;\n\n\treturn 0;\n}\n\nstatic int rbsp_write_bits(struct rbsp *rbsp, int num, int value)\n{\n\tint ret;\n\n\twhile (num--) {\n\t\tret = rbsp_write_bit(rbsp, (value >> num) & 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rbsp_read_uev(struct rbsp *rbsp, unsigned int *val)\n{\n\tint leading_zero_bits = 0;\n\tunsigned int tmp = 0;\n\tint ret;\n\n\twhile ((ret = rbsp_read_bit(rbsp)) == 0)\n\t\tleading_zero_bits++;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (leading_zero_bits > 0) {\n\t\tret = rbsp_read_bits(rbsp, leading_zero_bits, &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (val)\n\t\t*val = (1 << leading_zero_bits) - 1 + tmp;\n\n\treturn 0;\n}\n\nstatic int rbsp_write_uev(struct rbsp *rbsp, unsigned int value)\n{\n\tint i;\n\tint ret;\n\tint tmp = value + 1;\n\tint leading_zero_bits = fls(tmp) - 1;\n\n\tfor (i = 0; i < leading_zero_bits; i++) {\n\t\tret = rbsp_write_bit(rbsp, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn rbsp_write_bits(rbsp, leading_zero_bits + 1, tmp);\n}\n\nstatic int rbsp_read_sev(struct rbsp *rbsp, int *val)\n{\n\tunsigned int tmp;\n\tint ret;\n\n\tret = rbsp_read_uev(rbsp, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val) {\n\t\tif (tmp & 1)\n\t\t\t*val = (tmp + 1) / 2;\n\t\telse\n\t\t\t*val = -(tmp / 2);\n\t}\n\n\treturn 0;\n}\n\n \nint coda_h264_sps_fixup(struct coda_ctx *ctx, int width, int height, char *buf,\n\t\t\tint *size, int max_size)\n{\n\tint profile_idc;\n\tunsigned int pic_order_cnt_type;\n\tint pic_width_in_mbs_minus1, pic_height_in_map_units_minus1;\n\tint frame_mbs_only_flag, frame_cropping_flag;\n\tint vui_parameters_present_flag;\n\tunsigned int crop_right, crop_bottom;\n\tstruct rbsp sps;\n\tint pos;\n\tint ret;\n\n\tif (*size < 8 || *size >= max_size)\n\t\treturn -EINVAL;\n\n\tsps.buf = buf + 5;  \n\tsps.size = *size - 5;\n\n\tprofile_idc = sps.buf[0];\n\t \n\t \n\tsps.pos = 24;\n\n\t \n\tret = rbsp_read_uev(&sps, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (profile_idc == 100 || profile_idc == 110 || profile_idc == 122 ||\n\t    profile_idc == 244 || profile_idc == 44 || profile_idc == 83 ||\n\t    profile_idc == 86 || profile_idc == 118 || profile_idc == 128 ||\n\t    profile_idc == 138 || profile_idc == 139 || profile_idc == 134 ||\n\t    profile_idc == 135) {\n\t\tdev_err(ctx->fh.vdev->dev_parent,\n\t\t\t\"%s: Handling profile_idc %d not implemented\\n\",\n\t\t\t__func__, profile_idc);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = rbsp_read_uev(&sps, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rbsp_read_uev(&sps, &pic_order_cnt_type);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pic_order_cnt_type == 0) {\n\t\t \n\t\tret = rbsp_read_uev(&sps, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (pic_order_cnt_type == 1) {\n\t\tunsigned int i, num_ref_frames_in_pic_order_cnt_cycle;\n\n\t\t \n\t\tret = rbsp_read_bit(&sps);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tret = rbsp_read_sev(&sps, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tret = rbsp_read_sev(&sps, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = rbsp_read_uev(&sps,\n\t\t\t\t    &num_ref_frames_in_pic_order_cnt_cycle);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tfor (i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\n\t\t\t \n\t\t\tret = rbsp_read_sev(&sps, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = rbsp_read_uev(&sps, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = rbsp_read_bit(&sps);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rbsp_read_uev(&sps, &pic_width_in_mbs_minus1);\n\tif (ret)\n\t\treturn ret;\n\tret = rbsp_read_uev(&sps, &pic_height_in_map_units_minus1);\n\tif (ret)\n\t\treturn ret;\n\tframe_mbs_only_flag = ret = rbsp_read_bit(&sps);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!frame_mbs_only_flag) {\n\t\t \n\t\tret = rbsp_read_bit(&sps);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\t \n\tret = rbsp_read_bit(&sps);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpos = sps.pos;\n\tframe_cropping_flag = ret = rbsp_read_bit(&sps);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (frame_cropping_flag) {\n\t\tunsigned int crop_left, crop_top;\n\n\t\tret = rbsp_read_uev(&sps, &crop_left);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = rbsp_read_uev(&sps, &crop_right);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = rbsp_read_uev(&sps, &crop_top);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = rbsp_read_uev(&sps, &crop_bottom);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tvui_parameters_present_flag = ret = rbsp_read_bit(&sps);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (vui_parameters_present_flag) {\n\t\tdev_err(ctx->fh.vdev->dev_parent,\n\t\t\t\"%s: Handling vui_parameters not implemented\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tcrop_right = round_up(width, 16) - width;\n\tcrop_bottom = round_up(height, 16) - height;\n\tcrop_right /= 2;\n\tif (frame_mbs_only_flag)\n\t\tcrop_bottom /= 2;\n\telse\n\t\tcrop_bottom /= 4;\n\n\n\tsps.size = max_size - 5;\n\tsps.pos = pos;\n\tframe_cropping_flag = 1;\n\tret = rbsp_write_bit(&sps, frame_cropping_flag);\n\tif (ret)\n\t\treturn ret;\n\tret = rbsp_write_uev(&sps, 0);  \n\tif (ret)\n\t\treturn ret;\n\tret = rbsp_write_uev(&sps, crop_right);\n\tif (ret)\n\t\treturn ret;\n\tret = rbsp_write_uev(&sps, 0);  \n\tif (ret)\n\t\treturn ret;\n\tret = rbsp_write_uev(&sps, crop_bottom);\n\tif (ret)\n\t\treturn ret;\n\tret = rbsp_write_bit(&sps, 0);  \n\tif (ret)\n\t\treturn ret;\n\tret = rbsp_write_bit(&sps, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t*size = 5 + DIV_ROUND_UP(sps.pos, 8);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}