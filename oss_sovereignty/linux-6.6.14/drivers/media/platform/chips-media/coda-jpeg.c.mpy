{
  "module_name": "coda-jpeg.c",
  "hash_id": "61e62b03ee7d3a7d63ef0dde1434b6a35849f93b7cd93e08c1de9e3e1ca1cc1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/chips-media/coda-jpeg.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/irqreturn.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/slab.h>\n#include <linux/swab.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-jpeg.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-core.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"coda.h\"\n#include \"trace.h\"\n\n#define SOI_MARKER\t0xffd8\n#define APP9_MARKER\t0xffe9\n#define DRI_MARKER\t0xffdd\n#define DQT_MARKER\t0xffdb\n#define DHT_MARKER\t0xffc4\n#define SOF_MARKER\t0xffc0\n#define SOS_MARKER\t0xffda\n#define EOI_MARKER\t0xffd9\n\nenum {\n\tCODA9_JPEG_FORMAT_420,\n\tCODA9_JPEG_FORMAT_422,\n\tCODA9_JPEG_FORMAT_224,\n\tCODA9_JPEG_FORMAT_444,\n\tCODA9_JPEG_FORMAT_400,\n};\n\nstruct coda_huff_tab {\n\tu8 luma_dc[16 + 12];\n\tu8 chroma_dc[16 + 12];\n\tu8 luma_ac[16 + 162];\n\tu8 chroma_ac[16 + 162];\n\n\t \n\ts16\tmin[4 * 16];\n\ts16\tmax[4 * 16];\n\ts8\tptr[4 * 16];\n};\n\n#define CODA9_JPEG_ENC_HUFF_DATA_SIZE\t(256 + 256 + 16 + 16)\n\n \n\nstatic const unsigned char luma_dc[16 + 12] = {\n\t \n\t0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01,\n\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t \n\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t0x08, 0x09, 0x0a, 0x0b,\n};\n\nstatic const unsigned char chroma_dc[16 + 12] = {\n\t \n\t0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n\t0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t \n\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t0x08, 0x09, 0x0a, 0x0b,\n};\n\nstatic const unsigned char luma_ac[16 + 162 + 2] = {\n\t \n\t0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03,\n\t0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7d,\n\t \n\t0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,\n\t0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,\n\t0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,\n\t0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,\n\t0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,\n\t0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,\n\t0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,\n\t0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n\t0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,\n\t0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,\n\t0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,\n\t0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,\n\t0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,\n\t0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n\t0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,\n\t0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,\n\t0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,\n\t0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,\n\t0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,\n\t0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n\t0xf9, 0xfa,  \n};\n\nstatic const unsigned char chroma_ac[16 + 162 + 2] = {\n\t \n\t0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04,\n\t0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77,\n\t \n\t0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,\n\t0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,\n\t0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,\n\t0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,\n\t0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,\n\t0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,\n\t0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,\n\t0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\n\t0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n\t0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,\n\t0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n\t0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n\t0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,\n\t0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,\n\t0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,\n\t0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,\n\t0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,\n\t0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,\n\t0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,\n\t0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n\t0xf9, 0xfa,  \n};\n\n \n\nstatic unsigned char luma_q[64] = {\n\t0x06, 0x04, 0x04, 0x04, 0x05, 0x04, 0x06, 0x05,\n\t0x05, 0x06, 0x09, 0x06, 0x05, 0x06, 0x09, 0x0b,\n\t0x08, 0x06, 0x06, 0x08, 0x0b, 0x0c, 0x0a, 0x0a,\n\t0x0b, 0x0a, 0x0a, 0x0c, 0x10, 0x0c, 0x0c, 0x0c,\n\t0x0c, 0x0c, 0x0c, 0x10, 0x0c, 0x0c, 0x0c, 0x0c,\n\t0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,\n\t0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,\n\t0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,\n};\n\nstatic unsigned char chroma_q[64] = {\n\t0x07, 0x07, 0x07, 0x0d, 0x0c, 0x0d, 0x18, 0x10,\n\t0x10, 0x18, 0x14, 0x0e, 0x0e, 0x0e, 0x14, 0x14,\n\t0x0e, 0x0e, 0x0e, 0x0e, 0x14, 0x11, 0x0c, 0x0c,\n\t0x0c, 0x0c, 0x0c, 0x11, 0x11, 0x0c, 0x0c, 0x0c,\n\t0x0c, 0x0c, 0x0c, 0x11, 0x0c, 0x0c, 0x0c, 0x0c,\n\t0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,\n\t0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,\n\t0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,\n};\n\nstatic const unsigned char width_align[] = {\n\t[CODA9_JPEG_FORMAT_420] = 16,\n\t[CODA9_JPEG_FORMAT_422] = 16,\n\t[CODA9_JPEG_FORMAT_224] = 8,\n\t[CODA9_JPEG_FORMAT_444] = 8,\n\t[CODA9_JPEG_FORMAT_400] = 8,\n};\n\nstatic const unsigned char height_align[] = {\n\t[CODA9_JPEG_FORMAT_420] = 16,\n\t[CODA9_JPEG_FORMAT_422] = 8,\n\t[CODA9_JPEG_FORMAT_224] = 16,\n\t[CODA9_JPEG_FORMAT_444] = 8,\n\t[CODA9_JPEG_FORMAT_400] = 8,\n};\n\nstatic int coda9_jpeg_chroma_format(u32 pixfmt)\n{\n\tswitch (pixfmt) {\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_NV12:\n\t\treturn CODA9_JPEG_FORMAT_420;\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\treturn CODA9_JPEG_FORMAT_422;\n\tcase V4L2_PIX_FMT_YUV444:\n\t\treturn CODA9_JPEG_FORMAT_444;\n\tcase V4L2_PIX_FMT_GREY:\n\t\treturn CODA9_JPEG_FORMAT_400;\n\t}\n\treturn -EINVAL;\n}\n\nstruct coda_memcpy_desc {\n\tint offset;\n\tconst void *src;\n\tsize_t len;\n};\n\nstatic void coda_memcpy_parabuf(void *parabuf,\n\t\t\t\tconst struct coda_memcpy_desc *desc)\n{\n\tu32 *dst = parabuf + desc->offset;\n\tconst u32 *src = desc->src;\n\tint len = desc->len / 4;\n\tint i;\n\n\tfor (i = 0; i < len; i += 2) {\n\t\tdst[i + 1] = swab32(src[i]);\n\t\tdst[i] = swab32(src[i + 1]);\n\t}\n}\n\nint coda_jpeg_write_tables(struct coda_ctx *ctx)\n{\n\tint i;\n\tstatic const struct coda_memcpy_desc huff[8] = {\n\t\t{ 0,   luma_dc,    sizeof(luma_dc)    },\n\t\t{ 32,  luma_ac,    sizeof(luma_ac)    },\n\t\t{ 216, chroma_dc,  sizeof(chroma_dc)  },\n\t\t{ 248, chroma_ac,  sizeof(chroma_ac)  },\n\t};\n\tstruct coda_memcpy_desc qmat[3] = {\n\t\t{ 512, ctx->params.jpeg_qmat_tab[0], 64 },\n\t\t{ 576, ctx->params.jpeg_qmat_tab[1], 64 },\n\t\t{ 640, ctx->params.jpeg_qmat_tab[1], 64 },\n\t};\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(huff); i++)\n\t\tcoda_memcpy_parabuf(ctx->parabuf.vaddr, huff + i);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(qmat); i++)\n\t\tcoda_memcpy_parabuf(ctx->parabuf.vaddr, qmat + i);\n\n\treturn 0;\n}\n\nbool coda_jpeg_check_buffer(struct coda_ctx *ctx, struct vb2_buffer *vb)\n{\n\tvoid *vaddr = vb2_plane_vaddr(vb, 0);\n\tu16 soi, eoi;\n\tint len, i;\n\n\tsoi = be16_to_cpup((__be16 *)vaddr);\n\tif (soi != SOI_MARKER)\n\t\treturn false;\n\n\tlen = vb2_get_plane_payload(vb, 0);\n\tvaddr += len - 2;\n\tfor (i = 0; i < 32; i++) {\n\t\teoi = be16_to_cpup((__be16 *)(vaddr - i));\n\t\tif (eoi == EOI_MARKER) {\n\t\t\tif (i > 0)\n\t\t\t\tvb2_set_plane_payload(vb, 0, len - i);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int coda9_jpeg_gen_dec_huff_tab(struct coda_ctx *ctx, int tab_num);\n\nint coda_jpeg_decode_header(struct coda_ctx *ctx, struct vb2_buffer *vb)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tu8 *buf = vb2_plane_vaddr(vb, 0);\n\tsize_t len = vb2_get_plane_payload(vb, 0);\n\tstruct v4l2_jpeg_scan_header scan_header;\n\tstruct v4l2_jpeg_reference quantization_tables[4] = { };\n\tstruct v4l2_jpeg_reference huffman_tables[4] = { };\n\tstruct v4l2_jpeg_header header = {\n\t\t.scan = &scan_header,\n\t\t.quantization_tables = quantization_tables,\n\t\t.huffman_tables = huffman_tables,\n\t};\n\tstruct coda_q_data *q_data_src;\n\tstruct coda_huff_tab *huff_tab;\n\tint i, j, ret;\n\n\tret = v4l2_jpeg_parse_header(buf, len, &header);\n\tif (ret < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"failed to parse JPEG header: %pe\\n\",\n\t\t\t ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tctx->params.jpeg_restart_interval = header.restart_interval;\n\n\t \n\tif (header.frame.height > ctx->codec->max_h ||\n\t    header.frame.width > ctx->codec->max_w) {\n\t\tv4l2_err(&dev->v4l2_dev, \"invalid dimensions: %dx%d\\n\",\n\t\t\t header.frame.width, header.frame.height);\n\t\treturn -EINVAL;\n\t}\n\n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tif (header.frame.height != q_data_src->height ||\n\t    header.frame.width != q_data_src->width) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"dimensions don't match format: %dx%d\\n\",\n\t\t\t header.frame.width, header.frame.height);\n\t\treturn -EINVAL;\n\t}\n\n\tif (header.frame.num_components != 3) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"unsupported number of components: %d\\n\",\n\t\t\t header.frame.num_components);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (quantization_tables[3].start) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"only 3 quantization tables supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\tif (!quantization_tables[i].start)\n\t\t\tcontinue;\n\t\tif (quantization_tables[i].length != 64) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"only 8-bit quantization tables supported\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ctx->params.jpeg_qmat_tab[i]) {\n\t\t\tctx->params.jpeg_qmat_tab[i] = kmalloc(64, GFP_KERNEL);\n\t\t\tif (!ctx->params.jpeg_qmat_tab[i])\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(ctx->params.jpeg_qmat_tab[i],\n\t\t       quantization_tables[i].start, 64);\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (!huffman_tables[i].start) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"missing Huffman table\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (huffman_tables[i].length < 17 ||\n\t\t    huffman_tables[i].length > 178 ||\n\t\t    ((i & 2) == 0 && huffman_tables[i].length > 28)) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"invalid Huffman table %d length: %zu\\n\",\n\t\t\t\t i, huffman_tables[i].length);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\thuff_tab = ctx->params.jpeg_huff_tab;\n\tif (!huff_tab) {\n\t\thuff_tab = kzalloc(sizeof(struct coda_huff_tab), GFP_KERNEL);\n\t\tif (!huff_tab)\n\t\t\treturn -ENOMEM;\n\t\tctx->params.jpeg_huff_tab = huff_tab;\n\t}\n\n\tmemset(huff_tab, 0, sizeof(*huff_tab));\n\tmemcpy(huff_tab->luma_dc, huffman_tables[0].start, huffman_tables[0].length);\n\tmemcpy(huff_tab->chroma_dc, huffman_tables[1].start, huffman_tables[1].length);\n\tmemcpy(huff_tab->luma_ac, huffman_tables[2].start, huffman_tables[2].length);\n\tmemcpy(huff_tab->chroma_ac, huffman_tables[3].start, huffman_tables[3].length);\n\n\t \n\tfor (i = 0; i < scan_header.num_components; i++) {\n\t\tstruct v4l2_jpeg_scan_component_spec *scan_component;\n\n\t\tscan_component = &scan_header.component[i];\n\t\tfor (j = 0; j < header.frame.num_components; j++) {\n\t\t\tif (header.frame.component[j].component_identifier ==\n\t\t\t    scan_component->component_selector)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == header.frame.num_components)\n\t\t\tcontinue;\n\n\t\tctx->params.jpeg_huff_dc_index[j] =\n\t\t\tscan_component->dc_entropy_coding_table_selector;\n\t\tctx->params.jpeg_huff_ac_index[j] =\n\t\t\tscan_component->ac_entropy_coding_table_selector;\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\tcoda9_jpeg_gen_dec_huff_tab(ctx, i);\n\n\t \n\tctx->jpeg_ecs_offset = header.ecs_offset;\n\n\tswitch (header.frame.subsampling) {\n\tcase V4L2_JPEG_CHROMA_SUBSAMPLING_420:\n\tcase V4L2_JPEG_CHROMA_SUBSAMPLING_422:\n\t\tctx->params.jpeg_chroma_subsampling = header.frame.subsampling;\n\t\tbreak;\n\tdefault:\n\t\tv4l2_err(&dev->v4l2_dev, \"chroma subsampling not supported: %d\",\n\t\t\t header.frame.subsampling);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void coda9_jpeg_write_huff_values(struct coda_dev *dev, u8 *bits,\n\t\t\t\t\t\tint num_values)\n{\n\ts8 *values = (s8 *)(bits + 16);\n\tint huff_length, i;\n\n\tfor (huff_length = 0, i = 0; i < 16; i++)\n\t\thuff_length += bits[i];\n\tfor (i = huff_length; i < num_values; i++)\n\t\tvalues[i] = -1;\n\tfor (i = 0; i < num_values; i++)\n\t\tcoda_write(dev, (s32)values[i], CODA9_REG_JPEG_HUFF_DATA);\n}\n\nstatic void coda9_jpeg_dec_huff_setup(struct coda_ctx *ctx)\n{\n\tstruct coda_huff_tab *huff_tab = ctx->params.jpeg_huff_tab;\n\tstruct coda_dev *dev = ctx->dev;\n\ts16 *huff_min = huff_tab->min;\n\ts16 *huff_max = huff_tab->max;\n\ts8 *huff_ptr = huff_tab->ptr;\n\tint i;\n\n\t \n\tcoda_write(dev, 0x003, CODA9_REG_JPEG_HUFF_CTRL);\n\tcoda_write(dev, 0x000, CODA9_REG_JPEG_HUFF_ADDR);\n\tfor (i = 0; i < 4 * 16; i++)\n\t\tcoda_write(dev, (s32)huff_min[i], CODA9_REG_JPEG_HUFF_DATA);\n\n\t \n\tcoda_write(dev, 0x403, CODA9_REG_JPEG_HUFF_CTRL);\n\tcoda_write(dev, 0x440, CODA9_REG_JPEG_HUFF_ADDR);\n\tfor (i = 0; i < 4 * 16; i++)\n\t\tcoda_write(dev, (s32)huff_max[i], CODA9_REG_JPEG_HUFF_DATA);\n\n\t \n\tcoda_write(dev, 0x803, CODA9_REG_JPEG_HUFF_CTRL);\n\tcoda_write(dev, 0x880, CODA9_REG_JPEG_HUFF_ADDR);\n\tfor (i = 0; i < 4 * 16; i++)\n\t\tcoda_write(dev, (s32)huff_ptr[i], CODA9_REG_JPEG_HUFF_DATA);\n\n\t \n\tcoda_write(dev, 0xc03, CODA9_REG_JPEG_HUFF_CTRL);\n\tcoda9_jpeg_write_huff_values(dev, huff_tab->luma_dc, 12);\n\tcoda9_jpeg_write_huff_values(dev, huff_tab->chroma_dc, 12);\n\tcoda9_jpeg_write_huff_values(dev, huff_tab->luma_ac, 162);\n\tcoda9_jpeg_write_huff_values(dev, huff_tab->chroma_ac, 162);\n\tcoda_write(dev, 0x000, CODA9_REG_JPEG_HUFF_CTRL);\n}\n\nstatic inline void coda9_jpeg_write_qmat_tab(struct coda_dev *dev,\n\t\t\t\t\t     u8 *qmat, int index)\n{\n\tint i;\n\n\tcoda_write(dev, index | 0x3, CODA9_REG_JPEG_QMAT_CTRL);\n\tfor (i = 0; i < 64; i++)\n\t\tcoda_write(dev, qmat[i], CODA9_REG_JPEG_QMAT_DATA);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_QMAT_CTRL);\n}\n\nstatic void coda9_jpeg_qmat_setup(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tint *qmat_index = ctx->params.jpeg_qmat_index;\n\tu8 **qmat_tab = ctx->params.jpeg_qmat_tab;\n\n\tcoda9_jpeg_write_qmat_tab(dev, qmat_tab[qmat_index[0]], 0x00);\n\tcoda9_jpeg_write_qmat_tab(dev, qmat_tab[qmat_index[1]], 0x40);\n\tcoda9_jpeg_write_qmat_tab(dev, qmat_tab[qmat_index[2]], 0x80);\n}\n\nstatic void coda9_jpeg_dec_bbc_gbu_setup(struct coda_ctx *ctx,\n\t\t\t\t\t struct vb2_buffer *buf, u32 ecs_offset)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tint page_ptr, word_ptr, bit_ptr;\n\tu32 bbc_base_addr, end_addr;\n\tint bbc_cur_pos;\n\tint ret, val;\n\n\tbbc_base_addr = vb2_dma_contig_plane_dma_addr(buf, 0);\n\tend_addr = bbc_base_addr + vb2_get_plane_payload(buf, 0);\n\n\tpage_ptr = ecs_offset / 256;\n\tword_ptr = (ecs_offset % 256) / 4;\n\tif (page_ptr & 1)\n\t\tword_ptr += 64;\n\tbit_ptr = (ecs_offset % 4) * 8;\n\tif (word_ptr & 1)\n\t\tbit_ptr += 32;\n\tword_ptr &= ~0x1;\n\n\tcoda_write(dev, end_addr, CODA9_REG_JPEG_BBC_WR_PTR);\n\tcoda_write(dev, bbc_base_addr, CODA9_REG_JPEG_BBC_BAS_ADDR);\n\n\t \n\tcoda_write(dev, end_addr + 256 * 3 + 256, CODA9_REG_JPEG_BBC_END_ADDR);\n\tval = DIV_ROUND_UP(vb2_plane_size(buf, 0), 256) + 3;\n\tcoda_write(dev, BIT(31) | val, CODA9_REG_JPEG_BBC_STRM_CTRL);\n\n\tbbc_cur_pos = page_ptr;\n\tcoda_write(dev, bbc_cur_pos, CODA9_REG_JPEG_BBC_CUR_POS);\n\tcoda_write(dev, bbc_base_addr + (bbc_cur_pos << 8),\n\t\t\tCODA9_REG_JPEG_BBC_EXT_ADDR);\n\tcoda_write(dev, (bbc_cur_pos & 1) << 6, CODA9_REG_JPEG_BBC_INT_ADDR);\n\tcoda_write(dev, 64, CODA9_REG_JPEG_BBC_DATA_CNT);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_BBC_COMMAND);\n\tdo {\n\t\tret = coda_read(dev, CODA9_REG_JPEG_BBC_BUSY);\n\t} while (ret == 1);\n\n\tbbc_cur_pos++;\n\tcoda_write(dev, bbc_cur_pos, CODA9_REG_JPEG_BBC_CUR_POS);\n\tcoda_write(dev, bbc_base_addr + (bbc_cur_pos << 8),\n\t\t\tCODA9_REG_JPEG_BBC_EXT_ADDR);\n\tcoda_write(dev, (bbc_cur_pos & 1) << 6, CODA9_REG_JPEG_BBC_INT_ADDR);\n\tcoda_write(dev, 64, CODA9_REG_JPEG_BBC_DATA_CNT);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_BBC_COMMAND);\n\tdo {\n\t\tret = coda_read(dev, CODA9_REG_JPEG_BBC_BUSY);\n\t} while (ret == 1);\n\n\tbbc_cur_pos++;\n\tcoda_write(dev, bbc_cur_pos, CODA9_REG_JPEG_BBC_CUR_POS);\n\tcoda_write(dev, 1, CODA9_REG_JPEG_BBC_CTRL);\n\n\tcoda_write(dev, 0, CODA9_REG_JPEG_GBU_TT_CNT);\n\tcoda_write(dev, word_ptr, CODA9_REG_JPEG_GBU_WD_PTR);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_GBU_BBSR);\n\tcoda_write(dev, 127, CODA9_REG_JPEG_GBU_BBER);\n\tif (page_ptr & 1) {\n\t\tcoda_write(dev, 0, CODA9_REG_JPEG_GBU_BBIR);\n\t\tcoda_write(dev, 0, CODA9_REG_JPEG_GBU_BBHR);\n\t} else {\n\t\tcoda_write(dev, 64, CODA9_REG_JPEG_GBU_BBIR);\n\t\tcoda_write(dev, 64, CODA9_REG_JPEG_GBU_BBHR);\n\t}\n\tcoda_write(dev, 4, CODA9_REG_JPEG_GBU_CTRL);\n\tcoda_write(dev, bit_ptr, CODA9_REG_JPEG_GBU_FF_RPTR);\n\tcoda_write(dev, 3, CODA9_REG_JPEG_GBU_CTRL);\n}\n\nstatic const int bus_req_num[] = {\n\t[CODA9_JPEG_FORMAT_420] = 2,\n\t[CODA9_JPEG_FORMAT_422] = 3,\n\t[CODA9_JPEG_FORMAT_224] = 3,\n\t[CODA9_JPEG_FORMAT_444] = 4,\n\t[CODA9_JPEG_FORMAT_400] = 4,\n};\n\n#define MCU_INFO(mcu_block_num, comp_num, comp0_info, comp1_info, comp2_info) \\\n\t(((mcu_block_num) << CODA9_JPEG_MCU_BLOCK_NUM_OFFSET) | \\\n\t ((comp_num) << CODA9_JPEG_COMP_NUM_OFFSET) | \\\n\t ((comp0_info) << CODA9_JPEG_COMP0_INFO_OFFSET) | \\\n\t ((comp1_info) << CODA9_JPEG_COMP1_INFO_OFFSET) | \\\n\t ((comp2_info) << CODA9_JPEG_COMP2_INFO_OFFSET))\n\nstatic const u32 mcu_info[] = {\n\t[CODA9_JPEG_FORMAT_420] = MCU_INFO(6, 3, 10, 5, 5),\n\t[CODA9_JPEG_FORMAT_422] = MCU_INFO(4, 3, 9, 5, 5),\n\t[CODA9_JPEG_FORMAT_224] = MCU_INFO(4, 3, 6, 5, 5),\n\t[CODA9_JPEG_FORMAT_444] = MCU_INFO(3, 3, 5, 5, 5),\n\t[CODA9_JPEG_FORMAT_400] = MCU_INFO(1, 1, 5, 0, 0),\n};\n\n \nstatic int coda9_jpeg_gen_enc_huff_tab(struct coda_ctx *ctx, int tab_num,\n\t\t\t\t       int *ehufsi, int *ehufco)\n{\n\tint i, j, k, lastk, si, code, maxsymbol;\n\tconst u8 *bits, *huffval;\n\tstruct {\n\t\tint size[256];\n\t\tint code[256];\n\t} *huff;\n\tstatic const unsigned char *huff_tabs[4] = {\n\t\tluma_dc, luma_ac, chroma_dc, chroma_ac,\n\t};\n\tint ret = -EINVAL;\n\n\thuff = kzalloc(sizeof(*huff), GFP_KERNEL);\n\tif (!huff)\n\t\treturn -ENOMEM;\n\n\tbits = huff_tabs[tab_num];\n\thuffval = huff_tabs[tab_num] + 16;\n\n\tmaxsymbol = tab_num & 1 ? 256 : 16;\n\n\t \n\tk = 0;\n\tfor (i = 1; i <= 16; i++) {\n\t\tj = bits[i - 1];\n\t\tif (k + j > maxsymbol)\n\t\t\tgoto out;\n\t\twhile (j--)\n\t\t\thuff->size[k++] = i;\n\t}\n\tlastk = k;\n\n\t \n\tk = 0;\n\tcode = 0;\n\tsi = huff->size[0];\n\twhile (k < lastk) {\n\t\twhile (huff->size[k] == si) {\n\t\t\thuff->code[k++] = code;\n\t\t\tcode++;\n\t\t}\n\t\tif (code >= (1 << si))\n\t\t\tgoto out;\n\t\tcode <<= 1;\n\t\tsi++;\n\t}\n\n\t \n\tfor (k = 0; k < lastk; k++) {\n\t\ti = huffval[k];\n\t\tif (i >= maxsymbol || ehufsi[i])\n\t\t\tgoto out;\n\t\tehufco[i] = huff->code[k];\n\t\tehufsi[i] = huff->size[k];\n\t}\n\n\tret = 0;\nout:\n\tkfree(huff);\n\treturn ret;\n}\n\n#define DC_TABLE_INDEX0\t\t    0\n#define AC_TABLE_INDEX0\t\t    1\n#define DC_TABLE_INDEX1\t\t    2\n#define AC_TABLE_INDEX1\t\t    3\n\nstatic u8 *coda9_jpeg_get_huff_bits(struct coda_ctx *ctx, int tab_num)\n{\n\tstruct coda_huff_tab *huff_tab = ctx->params.jpeg_huff_tab;\n\n\tif (!huff_tab)\n\t\treturn NULL;\n\n\tswitch (tab_num) {\n\tcase DC_TABLE_INDEX0: return huff_tab->luma_dc;\n\tcase AC_TABLE_INDEX0: return huff_tab->luma_ac;\n\tcase DC_TABLE_INDEX1: return huff_tab->chroma_dc;\n\tcase AC_TABLE_INDEX1: return huff_tab->chroma_ac;\n\t}\n\n\treturn NULL;\n}\n\nstatic int coda9_jpeg_gen_dec_huff_tab(struct coda_ctx *ctx, int tab_num)\n{\n\tint ptr_cnt = 0, huff_code = 0, zero_flag = 0, data_flag = 0;\n\tu8 *huff_bits;\n\ts16 *huff_max;\n\ts16 *huff_min;\n\ts8 *huff_ptr;\n\tint ofs;\n\tint i;\n\n\thuff_bits = coda9_jpeg_get_huff_bits(ctx, tab_num);\n\tif (!huff_bits)\n\t\treturn -EINVAL;\n\n\t \n\tofs = ((tab_num & 1) << 1) | ((tab_num >> 1) & 1);\n\tofs *= 16;\n\n\thuff_ptr = ctx->params.jpeg_huff_tab->ptr + ofs;\n\thuff_max = ctx->params.jpeg_huff_tab->max + ofs;\n\thuff_min = ctx->params.jpeg_huff_tab->min + ofs;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (huff_bits[i]) {\n\t\t\thuff_ptr[i] = ptr_cnt;\n\t\t\tptr_cnt += huff_bits[i];\n\t\t\thuff_min[i] = huff_code;\n\t\t\thuff_max[i] = huff_code + (huff_bits[i] - 1);\n\t\t\tdata_flag = 1;\n\t\t\tzero_flag = 0;\n\t\t} else {\n\t\t\thuff_ptr[i] = -1;\n\t\t\thuff_min[i] = -1;\n\t\t\thuff_max[i] = -1;\n\t\t\tzero_flag = 1;\n\t\t}\n\n\t\tif (data_flag == 1) {\n\t\t\tif (zero_flag == 1)\n\t\t\t\thuff_code <<= 1;\n\t\t\telse\n\t\t\t\thuff_code = (huff_max[i] + 1) << 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int coda9_jpeg_load_huff_tab(struct coda_ctx *ctx)\n{\n\tstruct {\n\t\tint size[4][256];\n\t\tint code[4][256];\n\t} *huff;\n\tu32 *huff_data;\n\tint i, j;\n\tint ret;\n\n\thuff = kzalloc(sizeof(*huff), GFP_KERNEL);\n\tif (!huff)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tret = coda9_jpeg_gen_enc_huff_tab(ctx, i, huff->size[i],\n\t\t\t\t\t\t  huff->code[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (!ctx->params.jpeg_huff_data) {\n\t\tctx->params.jpeg_huff_data =\n\t\t\tkzalloc(sizeof(u32) * CODA9_JPEG_ENC_HUFF_DATA_SIZE,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!ctx->params.jpeg_huff_data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\thuff_data = ctx->params.jpeg_huff_data;\n\n\tfor (j = 0; j < 4; j++) {\n\t\t \n\t\tint t = (j == 0) ? AC_TABLE_INDEX0 :\n\t\t\t(j == 1) ? AC_TABLE_INDEX1 :\n\t\t\t(j == 2) ? DC_TABLE_INDEX0 :\n\t\t\t\t   DC_TABLE_INDEX1;\n\t\t \n\t\tint len = (j < 2) ? 256 : 16;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (huff->size[t][i] == 0 && huff->code[t][i] == 0)\n\t\t\t\t*(huff_data++) = 0;\n\t\t\telse\n\t\t\t\t*(huff_data++) =\n\t\t\t\t\t((huff->size[t][i] - 1) << 16) |\n\t\t\t\t\thuff->code[t][i];\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tkfree(huff);\n\treturn ret;\n}\n\nstatic void coda9_jpeg_write_huff_tab(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tu32 *huff_data = ctx->params.jpeg_huff_data;\n\tint i;\n\n\t \n\tcoda_write(dev, 0x3, CODA9_REG_JPEG_HUFF_CTRL);\n\tfor (i = 0; i < CODA9_JPEG_ENC_HUFF_DATA_SIZE; i++)\n\t\tcoda_write(dev, *(huff_data++), CODA9_REG_JPEG_HUFF_DATA);\n\tcoda_write(dev, 0x0, CODA9_REG_JPEG_HUFF_CTRL);\n}\n\nstatic inline void coda9_jpeg_write_qmat_quotients(struct coda_dev *dev,\n\t\t\t\t\t\t   u8 *qmat, int index)\n{\n\tint i;\n\n\tcoda_write(dev, index | 0x3, CODA9_REG_JPEG_QMAT_CTRL);\n\tfor (i = 0; i < 64; i++)\n\t\tcoda_write(dev, 0x80000 / qmat[i], CODA9_REG_JPEG_QMAT_DATA);\n\tcoda_write(dev, index, CODA9_REG_JPEG_QMAT_CTRL);\n}\n\nstatic void coda9_jpeg_load_qmat_tab(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tu8 *luma_tab;\n\tu8 *chroma_tab;\n\n\tluma_tab = ctx->params.jpeg_qmat_tab[0];\n\tif (!luma_tab)\n\t\tluma_tab = luma_q;\n\n\tchroma_tab = ctx->params.jpeg_qmat_tab[1];\n\tif (!chroma_tab)\n\t\tchroma_tab = chroma_q;\n\n\tcoda9_jpeg_write_qmat_quotients(dev, luma_tab, 0x00);\n\tcoda9_jpeg_write_qmat_quotients(dev, chroma_tab, 0x40);\n\tcoda9_jpeg_write_qmat_quotients(dev, chroma_tab, 0x80);\n}\n\nstruct coda_jpeg_stream {\n\tu8 *curr;\n\tu8 *end;\n};\n\nstatic inline int coda_jpeg_put_byte(u8 byte, struct coda_jpeg_stream *stream)\n{\n\tif (stream->curr >= stream->end)\n\t\treturn -EINVAL;\n\n\t*stream->curr++ = byte;\n\n\treturn 0;\n}\n\nstatic inline int coda_jpeg_put_word(u16 word, struct coda_jpeg_stream *stream)\n{\n\tif (stream->curr + sizeof(__be16) > stream->end)\n\t\treturn -EINVAL;\n\n\tput_unaligned_be16(word, stream->curr);\n\tstream->curr += sizeof(__be16);\n\n\treturn 0;\n}\n\nstatic int coda_jpeg_put_table(u16 marker, u8 index, const u8 *table,\n\t\t\t       size_t len, struct coda_jpeg_stream *stream)\n{\n\tint i, ret;\n\n\tret = coda_jpeg_put_word(marker, stream);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = coda_jpeg_put_word(3 + len, stream);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = coda_jpeg_put_byte(index, stream);\n\tfor (i = 0; i < len && ret == 0; i++)\n\t\tret = coda_jpeg_put_byte(table[i], stream);\n\n\treturn ret;\n}\n\nstatic int coda_jpeg_define_quantization_table(struct coda_ctx *ctx, u8 index,\n\t\t\t\t\t       struct coda_jpeg_stream *stream)\n{\n\treturn coda_jpeg_put_table(DQT_MARKER, index,\n\t\t\t\t   ctx->params.jpeg_qmat_tab[index], 64,\n\t\t\t\t   stream);\n}\n\nstatic int coda_jpeg_define_huffman_table(u8 index, const u8 *table, size_t len,\n\t\t\t\t\t  struct coda_jpeg_stream *stream)\n{\n\treturn coda_jpeg_put_table(DHT_MARKER, index, table, len, stream);\n}\n\nstatic int coda9_jpeg_encode_header(struct coda_ctx *ctx, int len, u8 *buf)\n{\n\tstruct coda_jpeg_stream stream = { buf, buf + len };\n\tstruct coda_q_data *q_data_src;\n\tint chroma_format, comp_num;\n\tint i, ret, pad;\n\n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tchroma_format = coda9_jpeg_chroma_format(q_data_src->fourcc);\n\tif (chroma_format < 0)\n\t\treturn 0;\n\n\t \n\tret = coda_jpeg_put_word(SOI_MARKER, &stream);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ctx->params.jpeg_restart_interval) {\n\t\tret = coda_jpeg_put_word(DRI_MARKER, &stream);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = coda_jpeg_put_word(4, &stream);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = coda_jpeg_put_word(ctx->params.jpeg_restart_interval,\n\t\t\t\t\t &stream);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = coda_jpeg_define_quantization_table(ctx, 0x00, &stream);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (chroma_format != CODA9_JPEG_FORMAT_400) {\n\t\tret = coda_jpeg_define_quantization_table(ctx, 0x01, &stream);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = coda_jpeg_define_huffman_table(0x00, luma_dc, 16 + 12, &stream);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = coda_jpeg_define_huffman_table(0x10, luma_ac, 16 + 162, &stream);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (chroma_format != CODA9_JPEG_FORMAT_400) {\n\t\tret = coda_jpeg_define_huffman_table(0x01, chroma_dc, 16 + 12,\n\t\t\t\t\t\t     &stream);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = coda_jpeg_define_huffman_table(0x11, chroma_ac, 16 + 162,\n\t\t\t\t\t\t     &stream);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = coda_jpeg_put_word(SOF_MARKER, &stream);\n\tif (ret < 0)\n\t\treturn ret;\n\tcomp_num = (chroma_format == CODA9_JPEG_FORMAT_400) ? 1 : 3;\n\tret = coda_jpeg_put_word(8 + comp_num * 3, &stream);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = coda_jpeg_put_byte(0x08, &stream);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = coda_jpeg_put_word(q_data_src->height, &stream);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = coda_jpeg_put_word(q_data_src->width, &stream);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = coda_jpeg_put_byte(comp_num, &stream);\n\tif (ret < 0)\n\t\treturn ret;\n\tfor (i = 0; i < comp_num; i++) {\n\t\tstatic unsigned char subsampling[5][3] = {\n\t\t\t[CODA9_JPEG_FORMAT_420] = { 0x22, 0x11, 0x11 },\n\t\t\t[CODA9_JPEG_FORMAT_422] = { 0x21, 0x11, 0x11 },\n\t\t\t[CODA9_JPEG_FORMAT_224] = { 0x12, 0x11, 0x11 },\n\t\t\t[CODA9_JPEG_FORMAT_444] = { 0x11, 0x11, 0x11 },\n\t\t\t[CODA9_JPEG_FORMAT_400] = { 0x11 },\n\t\t};\n\n\t\t \n\t\tret = coda_jpeg_put_byte(i + 1, &stream);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = coda_jpeg_put_byte(subsampling[chroma_format][i],\n\t\t\t\t\t &stream);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tret = coda_jpeg_put_byte((i == 0) ? 0 : 1, &stream);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tpad = (stream.curr - buf) % 8;\n\tif (pad) {\n\t\tpad = 8 - pad;\n\t\twhile (pad--) {\n\t\t\tret = coda_jpeg_put_byte(0x00, &stream);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn stream.curr - buf;\n}\n\n \nstatic void coda_scale_quant_table(u8 *q_tab, int scale)\n{\n\tunsigned int temp;\n\tint i;\n\n\tfor (i = 0; i < 64; i++) {\n\t\ttemp = DIV_ROUND_CLOSEST((unsigned int)q_tab[i] * scale, 100);\n\t\tif (temp <= 0)\n\t\t\ttemp = 1;\n\t\tif (temp > 255)\n\t\t\ttemp = 255;\n\t\tq_tab[i] = (unsigned char)temp;\n\t}\n}\n\nvoid coda_set_jpeg_compression_quality(struct coda_ctx *ctx, int quality)\n{\n\tunsigned int scale;\n\n\tctx->params.jpeg_quality = quality;\n\n\t \n\tif (quality > 100)\n\t\tquality = 100;\n\tif (quality < 5)\n\t\tquality = 5;\n\n\t \n\tif (quality < 50)\n\t\tscale = 5000 / quality;\n\telse\n\t\tscale = 200 - 2 * quality;\n\n\tif (ctx->params.jpeg_qmat_tab[0]) {\n\t\tmemcpy(ctx->params.jpeg_qmat_tab[0], luma_q, 64);\n\t\tcoda_scale_quant_table(ctx->params.jpeg_qmat_tab[0], scale);\n\t}\n\tif (ctx->params.jpeg_qmat_tab[1]) {\n\t\tmemcpy(ctx->params.jpeg_qmat_tab[1], chroma_q, 64);\n\t\tcoda_scale_quant_table(ctx->params.jpeg_qmat_tab[1], scale);\n\t}\n}\n\n \n\nstatic int coda9_jpeg_start_encoding(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tint ret;\n\n\tret = coda9_jpeg_load_huff_tab(ctx);\n\tif (ret < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"error loading Huffman tables\\n\");\n\t\treturn ret;\n\t}\n\tif (!ctx->params.jpeg_qmat_tab[0]) {\n\t\tctx->params.jpeg_qmat_tab[0] = kmalloc(64, GFP_KERNEL);\n\t\tif (!ctx->params.jpeg_qmat_tab[0])\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!ctx->params.jpeg_qmat_tab[1]) {\n\t\tctx->params.jpeg_qmat_tab[1] = kmalloc(64, GFP_KERNEL);\n\t\tif (!ctx->params.jpeg_qmat_tab[1])\n\t\t\treturn -ENOMEM;\n\t}\n\tcoda_set_jpeg_compression_quality(ctx, ctx->params.jpeg_quality);\n\n\treturn 0;\n}\n\nstatic int coda9_jpeg_prepare_encode(struct coda_ctx *ctx)\n{\n\tstruct coda_q_data *q_data_src;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct coda_dev *dev = ctx->dev;\n\tu32 start_addr, end_addr;\n\tu16 aligned_width, aligned_height;\n\tbool chroma_interleave;\n\tint chroma_format;\n\tint header_len;\n\tint ret;\n\tktime_t timeout;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\n\tif (vb2_get_plane_payload(&src_buf->vb2_buf, 0) == 0)\n\t\tvb2_set_plane_payload(&src_buf->vb2_buf, 0,\n\t\t\t\t      vb2_plane_size(&src_buf->vb2_buf, 0));\n\n\tsrc_buf->sequence = ctx->osequence;\n\tdst_buf->sequence = ctx->osequence;\n\tctx->osequence++;\n\n\tsrc_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;\n\tsrc_buf->flags &= ~V4L2_BUF_FLAG_PFRAME;\n\n\tcoda_set_gdi_regs(ctx);\n\n\tstart_addr = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\tend_addr = start_addr + vb2_plane_size(&dst_buf->vb2_buf, 0);\n\n\tchroma_format = coda9_jpeg_chroma_format(q_data_src->fourcc);\n\tif (chroma_format < 0)\n\t\treturn chroma_format;\n\n\t \n\taligned_width = round_up(q_data_src->width, width_align[chroma_format]);\n\taligned_height = round_up(q_data_src->height,\n\t\t\t\t  height_align[chroma_format]);\n\tif (aligned_width != q_data_src->bytesperline) {\n\t\tv4l2_err(&dev->v4l2_dev, \"wrong stride: %d instead of %d\\n\",\n\t\t\t aligned_width, q_data_src->bytesperline);\n\t}\n\n\theader_len =\n\t\tcoda9_jpeg_encode_header(ctx,\n\t\t\t\t\t vb2_plane_size(&dst_buf->vb2_buf, 0),\n\t\t\t\t\t vb2_plane_vaddr(&dst_buf->vb2_buf, 0));\n\tif (header_len < 0)\n\t\treturn header_len;\n\n\tcoda_write(dev, start_addr + header_len, CODA9_REG_JPEG_BBC_BAS_ADDR);\n\tcoda_write(dev, end_addr, CODA9_REG_JPEG_BBC_END_ADDR);\n\tcoda_write(dev, start_addr + header_len, CODA9_REG_JPEG_BBC_WR_PTR);\n\tcoda_write(dev, start_addr + header_len, CODA9_REG_JPEG_BBC_RD_PTR);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_BBC_CUR_POS);\n\t \n\tcoda_write(dev, 64, CODA9_REG_JPEG_BBC_DATA_CNT);\n\tcoda_write(dev, start_addr, CODA9_REG_JPEG_BBC_EXT_ADDR);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_BBC_INT_ADDR);\n\n\tcoda_write(dev, 0, CODA9_REG_JPEG_GBU_BT_PTR);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_GBU_WD_PTR);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_GBU_BBSR);\n\tcoda_write(dev, BIT(31) | ((end_addr - start_addr - header_len) / 256),\n\t\t   CODA9_REG_JPEG_BBC_STRM_CTRL);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_GBU_CTRL);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_GBU_FF_RPTR);\n\tcoda_write(dev, 127, CODA9_REG_JPEG_GBU_BBER);\n\tcoda_write(dev, 64, CODA9_REG_JPEG_GBU_BBIR);\n\tcoda_write(dev, 64, CODA9_REG_JPEG_GBU_BBHR);\n\n\tchroma_interleave = (q_data_src->fourcc == V4L2_PIX_FMT_NV12);\n\tcoda_write(dev, CODA9_JPEG_PIC_CTRL_TC_DIRECTION |\n\t\t   CODA9_JPEG_PIC_CTRL_ENCODER_EN, CODA9_REG_JPEG_PIC_CTRL);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_SCL_INFO);\n\tcoda_write(dev, chroma_interleave, CODA9_REG_JPEG_DPB_CONFIG);\n\tcoda_write(dev, ctx->params.jpeg_restart_interval,\n\t\t   CODA9_REG_JPEG_RST_INTVAL);\n\tcoda_write(dev, 1, CODA9_REG_JPEG_BBC_CTRL);\n\n\tcoda_write(dev, bus_req_num[chroma_format], CODA9_REG_JPEG_OP_INFO);\n\n\tcoda9_jpeg_write_huff_tab(ctx);\n\tcoda9_jpeg_load_qmat_tab(ctx);\n\n\tif (ctx->params.rot_mode & CODA_ROT_90) {\n\t\taligned_width = aligned_height;\n\t\taligned_height = q_data_src->bytesperline;\n\t\tif (chroma_format == CODA9_JPEG_FORMAT_422)\n\t\t\tchroma_format = CODA9_JPEG_FORMAT_224;\n\t\telse if (chroma_format == CODA9_JPEG_FORMAT_224)\n\t\t\tchroma_format = CODA9_JPEG_FORMAT_422;\n\t}\n\t \n\tcoda_write(dev, aligned_width << 16 | aligned_height,\n\t\t   CODA9_REG_JPEG_PIC_SIZE);\n\tcoda_write(dev, ctx->params.rot_mode ?\n\t\t   (CODA_ROT_MIR_ENABLE | ctx->params.rot_mode) : 0,\n\t\t   CODA9_REG_JPEG_ROT_INFO);\n\n\tcoda_write(dev, mcu_info[chroma_format], CODA9_REG_JPEG_MCU_INFO);\n\n\tcoda_write(dev, 1, CODA9_GDI_CONTROL);\n\ttimeout = ktime_add_us(ktime_get(), 100000);\n\tdo {\n\t\tret = coda_read(dev, CODA9_GDI_STATUS);\n\t\tif (ktime_compare(ktime_get(), timeout) > 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"timeout waiting for GDI\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} while (!ret);\n\n\tcoda_write(dev, (chroma_format << 17) | (chroma_interleave << 16) |\n\t\t   q_data_src->bytesperline, CODA9_GDI_INFO_CONTROL);\n\t \n\tcoda_write(dev, aligned_width << 16 | aligned_height,\n\t\t   CODA9_GDI_INFO_PIC_SIZE);\n\n\tcoda_write_base(ctx, q_data_src, src_buf, CODA9_GDI_INFO_BASE_Y);\n\n\tcoda_write(dev, 0, CODA9_REG_JPEG_DPB_BASE00);\n\tcoda_write(dev, 0, CODA9_GDI_CONTROL);\n\tcoda_write(dev, 1, CODA9_GDI_PIC_INIT_HOST);\n\n\tcoda_write(dev, 1, CODA9_GDI_WPROT_ERR_CLR);\n\tcoda_write(dev, 0, CODA9_GDI_WPROT_RGN_EN);\n\n\ttrace_coda_jpeg_run(ctx, src_buf);\n\n\tcoda_write(dev, 1, CODA9_REG_JPEG_PIC_START);\n\n\treturn 0;\n}\n\nstatic void coda9_jpeg_finish_encode(struct coda_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct coda_dev *dev = ctx->dev;\n\tu32 wr_ptr, start_ptr;\n\tu32 err_mb;\n\n\tif (ctx->aborting) {\n\t\tcoda_write(ctx->dev, 0, CODA9_REG_JPEG_BBC_FLUSH_CMD);\n\t\treturn;\n\t}\n\n\t \n\tmutex_lock(&ctx->wakeup_mutex);\n\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\ttrace_coda_jpeg_done(ctx, dst_buf);\n\n\t \n\tstart_ptr = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\twr_ptr = coda_read(dev, CODA9_REG_JPEG_BBC_WR_PTR);\n\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, wr_ptr - start_ptr);\n\n\terr_mb = coda_read(dev, CODA9_REG_JPEG_PIC_ERRMB);\n\tif (err_mb)\n\t\tcoda_dbg(1, ctx, \"ERRMB: 0x%x\\n\", err_mb);\n\n\tcoda_write(dev, 0, CODA9_REG_JPEG_BBC_FLUSH_CMD);\n\n\tdst_buf->flags &= ~(V4L2_BUF_FLAG_PFRAME | V4L2_BUF_FLAG_LAST);\n\tdst_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;\n\tdst_buf->flags |= src_buf->flags & V4L2_BUF_FLAG_LAST;\n\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, false);\n\n\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\tcoda_m2m_buf_done(ctx, dst_buf, err_mb ? VB2_BUF_STATE_ERROR :\n\t\t\t\t\t\t VB2_BUF_STATE_DONE);\n\tmutex_unlock(&ctx->wakeup_mutex);\n\n\tcoda_dbg(1, ctx, \"job finished: encoded frame (%u)%s\\n\",\n\t\t dst_buf->sequence,\n\t\t (dst_buf->flags & V4L2_BUF_FLAG_LAST) ? \" (last)\" : \"\");\n\n\t \n\tcoda_hw_reset(ctx);\n}\n\nstatic void coda9_jpeg_encode_timeout(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tu32 end_addr, wr_ptr;\n\n\t \n\tend_addr = coda_read(dev, CODA9_REG_JPEG_BBC_END_ADDR);\n\twr_ptr = coda_read(dev, CODA9_REG_JPEG_BBC_WR_PTR);\n\tif (wr_ptr >= end_addr - 256) {\n\t\tv4l2_err(&dev->v4l2_dev, \"JPEG too large for capture buffer\\n\");\n\t\tcoda9_jpeg_finish_encode(ctx);\n\t\treturn;\n\t}\n\n\tcoda_hw_reset(ctx);\n}\n\nstatic void coda9_jpeg_release(struct coda_ctx *ctx)\n{\n\tint i;\n\n\tif (ctx->params.jpeg_qmat_tab[0] == luma_q)\n\t\tctx->params.jpeg_qmat_tab[0] = NULL;\n\tif (ctx->params.jpeg_qmat_tab[1] == chroma_q)\n\t\tctx->params.jpeg_qmat_tab[1] = NULL;\n\tfor (i = 0; i < 3; i++)\n\t\tkfree(ctx->params.jpeg_qmat_tab[i]);\n\tkfree(ctx->params.jpeg_huff_data);\n\tkfree(ctx->params.jpeg_huff_tab);\n}\n\nconst struct coda_context_ops coda9_jpeg_encode_ops = {\n\t.queue_init = coda_encoder_queue_init,\n\t.start_streaming = coda9_jpeg_start_encoding,\n\t.prepare_run = coda9_jpeg_prepare_encode,\n\t.finish_run = coda9_jpeg_finish_encode,\n\t.run_timeout = coda9_jpeg_encode_timeout,\n\t.release = coda9_jpeg_release,\n};\n\n \n\nstatic int coda9_jpeg_start_decoding(struct coda_ctx *ctx)\n{\n\tctx->params.jpeg_qmat_index[0] = 0;\n\tctx->params.jpeg_qmat_index[1] = 1;\n\tctx->params.jpeg_qmat_index[2] = 1;\n\tctx->params.jpeg_qmat_tab[0] = luma_q;\n\tctx->params.jpeg_qmat_tab[1] = chroma_q;\n\t \n\n\t \n\n\treturn 0;\n}\n\nstatic int coda9_jpeg_prepare_decode(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tint aligned_width, aligned_height;\n\tint chroma_format;\n\tint ret;\n\tu32 val, dst_fourcc;\n\tstruct coda_q_data *q_data_src, *q_data_dst;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tint chroma_interleave;\n\tint scl_hor_mode, scl_ver_mode;\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tdst_fourcc = q_data_dst->fourcc;\n\n\tscl_hor_mode = coda_jpeg_scale(q_data_src->width, q_data_dst->width);\n\tscl_ver_mode = coda_jpeg_scale(q_data_src->height, q_data_dst->height);\n\n\tif (vb2_get_plane_payload(&src_buf->vb2_buf, 0) == 0)\n\t\tvb2_set_plane_payload(&src_buf->vb2_buf, 0,\n\t\t\t\t      vb2_plane_size(&src_buf->vb2_buf, 0));\n\n\tchroma_format = coda9_jpeg_chroma_format(q_data_dst->fourcc);\n\tif (chroma_format < 0)\n\t\treturn chroma_format;\n\n\tret = coda_jpeg_decode_header(ctx, &src_buf->vb2_buf);\n\tif (ret < 0) {\n\t\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\n\n\t\treturn ret;\n\t}\n\n\t \n\taligned_width = round_up(q_data_src->width, width_align[chroma_format]);\n\taligned_height = round_up(q_data_src->height, height_align[chroma_format]);\n\tif (aligned_width != q_data_dst->bytesperline) {\n\t\tv4l2_err(&dev->v4l2_dev, \"stride mismatch: %d != %d\\n\",\n\t\t\t aligned_width, q_data_dst->bytesperline);\n\t}\n\n\tcoda_set_gdi_regs(ctx);\n\n\tval = ctx->params.jpeg_huff_ac_index[0] << 12 |\n\t      ctx->params.jpeg_huff_ac_index[1] << 11 |\n\t      ctx->params.jpeg_huff_ac_index[2] << 10 |\n\t      ctx->params.jpeg_huff_dc_index[0] << 9 |\n\t      ctx->params.jpeg_huff_dc_index[1] << 8 |\n\t      ctx->params.jpeg_huff_dc_index[2] << 7;\n\tif (ctx->params.jpeg_huff_tab)\n\t\tval |= CODA9_JPEG_PIC_CTRL_USER_HUFFMAN_EN;\n\tcoda_write(dev, val, CODA9_REG_JPEG_PIC_CTRL);\n\n\tcoda_write(dev, aligned_width << 16 | aligned_height,\n\t\t\tCODA9_REG_JPEG_PIC_SIZE);\n\n\tchroma_interleave = (dst_fourcc == V4L2_PIX_FMT_NV12);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_ROT_INFO);\n\tcoda_write(dev, bus_req_num[chroma_format], CODA9_REG_JPEG_OP_INFO);\n\tcoda_write(dev, mcu_info[chroma_format], CODA9_REG_JPEG_MCU_INFO);\n\tif (scl_hor_mode || scl_ver_mode)\n\t\tval = CODA9_JPEG_SCL_ENABLE | (scl_hor_mode << 2) | scl_ver_mode;\n\telse\n\t\tval = 0;\n\tcoda_write(dev, val, CODA9_REG_JPEG_SCL_INFO);\n\tcoda_write(dev, chroma_interleave, CODA9_REG_JPEG_DPB_CONFIG);\n\tcoda_write(dev, ctx->params.jpeg_restart_interval,\n\t\t\tCODA9_REG_JPEG_RST_INTVAL);\n\n\tif (ctx->params.jpeg_huff_tab)\n\t\tcoda9_jpeg_dec_huff_setup(ctx);\n\n\tcoda9_jpeg_qmat_setup(ctx);\n\n\tcoda9_jpeg_dec_bbc_gbu_setup(ctx, &src_buf->vb2_buf,\n\t\t\t\t     ctx->jpeg_ecs_offset);\n\n\tcoda_write(dev, 0, CODA9_REG_JPEG_RST_INDEX);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_RST_COUNT);\n\n\tcoda_write(dev, 0, CODA9_REG_JPEG_DPCM_DIFF_Y);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_DPCM_DIFF_CB);\n\tcoda_write(dev, 0, CODA9_REG_JPEG_DPCM_DIFF_CR);\n\n\tcoda_write(dev, 0, CODA9_REG_JPEG_ROT_INFO);\n\n\tcoda_write(dev, 1, CODA9_GDI_CONTROL);\n\tdo {\n\t\tret = coda_read(dev, CODA9_GDI_STATUS);\n\t} while (!ret);\n\n\tval = (chroma_format << 17) | (chroma_interleave << 16) |\n\t      q_data_dst->bytesperline;\n\tif (ctx->tiled_map_type == GDI_TILED_FRAME_MB_RASTER_MAP)\n\t\tval |= 3 << 20;\n\tcoda_write(dev, val, CODA9_GDI_INFO_CONTROL);\n\n\tcoda_write(dev, aligned_width << 16 | aligned_height,\n\t\t\tCODA9_GDI_INFO_PIC_SIZE);\n\n\tcoda_write_base(ctx, q_data_dst, dst_buf, CODA9_GDI_INFO_BASE_Y);\n\n\tcoda_write(dev, 0, CODA9_REG_JPEG_DPB_BASE00);\n\tcoda_write(dev, 0, CODA9_GDI_CONTROL);\n\tcoda_write(dev, 1, CODA9_GDI_PIC_INIT_HOST);\n\n\ttrace_coda_jpeg_run(ctx, src_buf);\n\n\tcoda_write(dev, 1, CODA9_REG_JPEG_PIC_START);\n\n\treturn 0;\n}\n\nstatic void coda9_jpeg_finish_decode(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tstruct vb2_v4l2_buffer *dst_buf, *src_buf;\n\tstruct coda_q_data *q_data_dst;\n\tu32 err_mb;\n\n\terr_mb = coda_read(dev, CODA9_REG_JPEG_PIC_ERRMB);\n\tif (err_mb)\n\t\tv4l2_err(&dev->v4l2_dev, \"ERRMB: 0x%x\\n\", err_mb);\n\n\tcoda_write(dev, 0, CODA9_REG_JPEG_BBC_FLUSH_CMD);\n\n\t \n\tmutex_lock(&ctx->wakeup_mutex);\n\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tdst_buf->sequence = ctx->osequence++;\n\n\ttrace_coda_jpeg_done(ctx, dst_buf);\n\n\tdst_buf->flags &= ~(V4L2_BUF_FLAG_PFRAME | V4L2_BUF_FLAG_LAST);\n\tdst_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;\n\tdst_buf->flags |= src_buf->flags & V4L2_BUF_FLAG_LAST;\n\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, false);\n\n\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, q_data_dst->sizeimage);\n\n\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\tcoda_m2m_buf_done(ctx, dst_buf, err_mb ? VB2_BUF_STATE_ERROR :\n\t\t\t\t\t\t VB2_BUF_STATE_DONE);\n\n\tmutex_unlock(&ctx->wakeup_mutex);\n\n\tcoda_dbg(1, ctx, \"job finished: decoded frame (%u)%s\\n\",\n\t\t dst_buf->sequence,\n\t\t (dst_buf->flags & V4L2_BUF_FLAG_LAST) ? \" (last)\" : \"\");\n\n\t \n\tcoda_hw_reset(ctx);\n}\n\nconst struct coda_context_ops coda9_jpeg_decode_ops = {\n\t.queue_init = coda_encoder_queue_init,  \n\t.start_streaming = coda9_jpeg_start_decoding,\n\t.prepare_run = coda9_jpeg_prepare_decode,\n\t.finish_run = coda9_jpeg_finish_decode,\n\t.release = coda9_jpeg_release,\n};\n\nirqreturn_t coda9_jpeg_irq_handler(int irq, void *data)\n{\n\tstruct coda_dev *dev = data;\n\tstruct coda_ctx *ctx;\n\tint status;\n\tint err_mb;\n\n\tstatus = coda_read(dev, CODA9_REG_JPEG_PIC_STATUS);\n\tif (status == 0)\n\t\treturn IRQ_HANDLED;\n\tcoda_write(dev, status, CODA9_REG_JPEG_PIC_STATUS);\n\n\tif (status & CODA9_JPEG_STATUS_OVERFLOW)\n\t\tv4l2_err(&dev->v4l2_dev, \"JPEG overflow\\n\");\n\n\tif (status & CODA9_JPEG_STATUS_BBC_INT)\n\t\tv4l2_err(&dev->v4l2_dev, \"JPEG BBC interrupt\\n\");\n\n\tif (status & CODA9_JPEG_STATUS_ERROR) {\n\t\tv4l2_err(&dev->v4l2_dev, \"JPEG error\\n\");\n\n\t\terr_mb = coda_read(dev, CODA9_REG_JPEG_PIC_ERRMB);\n\t\tif (err_mb) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"ERRMB: 0x%x: rst idx %d, mcu pos (%d,%d)\\n\",\n\t\t\t\t err_mb, err_mb >> 24, (err_mb >> 12) & 0xfff,\n\t\t\t\t err_mb & 0xfff);\n\t\t}\n\t}\n\n\tctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);\n\tif (!ctx) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Instance released before the end of transaction\\n\");\n\t\tmutex_unlock(&dev->coda_mutex);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tcomplete(&ctx->completion);\n\n\treturn IRQ_HANDLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}