{
  "module_name": "imx-vdoa.c",
  "hash_id": "30b65174625e2b42facf915f54fd27717383d712540e90eb791368e46efe9b05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/chips-media/imx-vdoa.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/videodev2.h>\n#include <linux/slab.h>\n\n#include \"imx-vdoa.h\"\n\n#define VDOA_NAME \"imx-vdoa\"\n\n#define VDOAC\t\t0x00\n#define VDOASRR\t\t0x04\n#define VDOAIE\t\t0x08\n#define VDOAIST\t\t0x0c\n#define VDOAFP\t\t0x10\n#define VDOAIEBA00\t0x14\n#define VDOAIEBA01\t0x18\n#define VDOAIEBA02\t0x1c\n#define VDOAIEBA10\t0x20\n#define VDOAIEBA11\t0x24\n#define VDOAIEBA12\t0x28\n#define VDOASL\t\t0x2c\n#define VDOAIUBO\t0x30\n#define VDOAVEBA0\t0x34\n#define VDOAVEBA1\t0x38\n#define VDOAVEBA2\t0x3c\n#define VDOAVUBO\t0x40\n#define VDOASR\t\t0x44\n\n#define VDOAC_ISEL\t\tBIT(6)\n#define VDOAC_PFS\t\tBIT(5)\n#define VDOAC_SO\t\tBIT(4)\n#define VDOAC_SYNC\t\tBIT(3)\n#define VDOAC_NF\t\tBIT(2)\n#define VDOAC_BNDM_MASK\t\t0x3\n#define VDOAC_BAND_HEIGHT_8\t0x0\n#define VDOAC_BAND_HEIGHT_16\t0x1\n#define VDOAC_BAND_HEIGHT_32\t0x2\n\n#define VDOASRR_START\t\tBIT(1)\n#define VDOASRR_SWRST\t\tBIT(0)\n\n#define VDOAIE_EITERR\t\tBIT(1)\n#define VDOAIE_EIEOT\t\tBIT(0)\n\n#define VDOAIST_TERR\t\tBIT(1)\n#define VDOAIST_EOT\t\tBIT(0)\n\n#define VDOAFP_FH_MASK\t\t(0x1fff << 16)\n#define VDOAFP_FW_MASK\t\t(0x3fff)\n\n#define VDOASL_VSLY_MASK\t(0x3fff << 16)\n#define VDOASL_ISLY_MASK\t(0x7fff)\n\n#define VDOASR_ERRW\t\tBIT(4)\n#define VDOASR_EOB\t\tBIT(3)\n#define VDOASR_CURRENT_FRAME\t(0x3 << 1)\n#define VDOASR_CURRENT_BUFFER\tBIT(1)\n\nenum {\n\tV4L2_M2M_SRC = 0,\n\tV4L2_M2M_DST = 1,\n};\n\nstruct vdoa_data {\n\tstruct vdoa_ctx\t\t*curr_ctx;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*vdoa_clk;\n\tvoid __iomem\t\t*regs;\n};\n\nstruct vdoa_q_data {\n\tunsigned int\twidth;\n\tunsigned int\theight;\n\tunsigned int\tbytesperline;\n\tunsigned int\tsizeimage;\n\tu32\t\tpixelformat;\n};\n\nstruct vdoa_ctx {\n\tstruct vdoa_data\t*vdoa;\n\tstruct completion\tcompletion;\n\tstruct vdoa_q_data\tq_data[2];\n\tunsigned int\t\tsubmitted_job;\n\tunsigned int\t\tcompleted_job;\n};\n\nstatic irqreturn_t vdoa_irq_handler(int irq, void *data)\n{\n\tstruct vdoa_data *vdoa = data;\n\tstruct vdoa_ctx *curr_ctx;\n\tu32 val;\n\n\t \n\twritel(0, vdoa->regs + VDOAIE);\n\n\tcurr_ctx = vdoa->curr_ctx;\n\tif (!curr_ctx) {\n\t\tdev_warn(vdoa->dev,\n\t\t\t\"Instance released before the end of transaction\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tval = readl(vdoa->regs + VDOAIST);\n\twritel(val, vdoa->regs + VDOAIST);\n\tif (val & VDOAIST_TERR) {\n\t\tval = readl(vdoa->regs + VDOASR) & VDOASR_ERRW;\n\t\tdev_err(vdoa->dev, \"AXI %s error\\n\", val ? \"write\" : \"read\");\n\t} else if (!(val & VDOAIST_EOT)) {\n\t\tdev_warn(vdoa->dev, \"Spurious interrupt\\n\");\n\t}\n\tcurr_ctx->completed_job++;\n\tcomplete(&curr_ctx->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nint vdoa_wait_for_completion(struct vdoa_ctx *ctx)\n{\n\tstruct vdoa_data *vdoa = ctx->vdoa;\n\n\tif (ctx->submitted_job == ctx->completed_job)\n\t\treturn 0;\n\n\tif (!wait_for_completion_timeout(&ctx->completion,\n\t\t\t\t\t msecs_to_jiffies(300))) {\n\t\tdev_err(vdoa->dev,\n\t\t\t\"Timeout waiting for transfer result\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vdoa_wait_for_completion);\n\nvoid vdoa_device_run(struct vdoa_ctx *ctx, dma_addr_t dst, dma_addr_t src)\n{\n\tstruct vdoa_q_data *src_q_data, *dst_q_data;\n\tstruct vdoa_data *vdoa = ctx->vdoa;\n\tu32 val;\n\n\tif (vdoa->curr_ctx)\n\t\tvdoa_wait_for_completion(vdoa->curr_ctx);\n\n\tvdoa->curr_ctx = ctx;\n\n\treinit_completion(&ctx->completion);\n\tctx->submitted_job++;\n\n\tsrc_q_data = &ctx->q_data[V4L2_M2M_SRC];\n\tdst_q_data = &ctx->q_data[V4L2_M2M_DST];\n\n\t \n\tif (dst_q_data->pixelformat == V4L2_PIX_FMT_YUYV)\n\t\tval = VDOAC_PFS;\n\telse\n\t\tval = 0;\n\twritel(val, vdoa->regs + VDOAC);\n\n\twritel(dst_q_data->height << 16 | dst_q_data->width,\n\t       vdoa->regs + VDOAFP);\n\n\tval = dst;\n\twritel(val, vdoa->regs + VDOAIEBA00);\n\n\twritel(src_q_data->bytesperline << 16 | dst_q_data->bytesperline,\n\t       vdoa->regs + VDOASL);\n\n\tif (dst_q_data->pixelformat == V4L2_PIX_FMT_NV12 ||\n\t    dst_q_data->pixelformat == V4L2_PIX_FMT_NV21)\n\t\tval = dst_q_data->bytesperline * dst_q_data->height;\n\telse\n\t\tval = 0;\n\twritel(val, vdoa->regs + VDOAIUBO);\n\n\tval = src;\n\twritel(val, vdoa->regs + VDOAVEBA0);\n\tval = round_up(src_q_data->bytesperline * src_q_data->height, 4096);\n\twritel(val, vdoa->regs + VDOAVUBO);\n\n\t \n\twritel(VDOAIE_EITERR | VDOAIE_EIEOT, vdoa->regs + VDOAIE);\n\twritel(VDOASRR_START, vdoa->regs + VDOASRR);\n}\nEXPORT_SYMBOL(vdoa_device_run);\n\nstruct vdoa_ctx *vdoa_context_create(struct vdoa_data *vdoa)\n{\n\tstruct vdoa_ctx *ctx;\n\tint err;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\terr = clk_prepare_enable(vdoa->vdoa_clk);\n\tif (err) {\n\t\tkfree(ctx);\n\t\treturn NULL;\n\t}\n\n\tinit_completion(&ctx->completion);\n\tctx->vdoa = vdoa;\n\n\treturn ctx;\n}\nEXPORT_SYMBOL(vdoa_context_create);\n\nvoid vdoa_context_destroy(struct vdoa_ctx *ctx)\n{\n\tstruct vdoa_data *vdoa = ctx->vdoa;\n\n\tif (vdoa->curr_ctx == ctx) {\n\t\tvdoa_wait_for_completion(vdoa->curr_ctx);\n\t\tvdoa->curr_ctx = NULL;\n\t}\n\n\tclk_disable_unprepare(vdoa->vdoa_clk);\n\tkfree(ctx);\n}\nEXPORT_SYMBOL(vdoa_context_destroy);\n\nint vdoa_context_configure(struct vdoa_ctx *ctx,\n\t\t\t   unsigned int width, unsigned int height,\n\t\t\t   u32 pixelformat)\n{\n\tstruct vdoa_q_data *src_q_data;\n\tstruct vdoa_q_data *dst_q_data;\n\n\tif (width < 16 || width  > 8192 || width % 16 != 0 ||\n\t    height < 16 || height > 4096 || height % 16 != 0)\n\t\treturn -EINVAL;\n\n\tif (pixelformat != V4L2_PIX_FMT_YUYV &&\n\t    pixelformat != V4L2_PIX_FMT_NV12)\n\t\treturn -EINVAL;\n\n\t \n\tif (!ctx)\n\t\treturn 0;\n\n\tsrc_q_data = &ctx->q_data[V4L2_M2M_SRC];\n\tdst_q_data = &ctx->q_data[V4L2_M2M_DST];\n\n\tsrc_q_data->width = width;\n\tsrc_q_data->height = height;\n\tsrc_q_data->bytesperline = width;\n\tsrc_q_data->sizeimage =\n\t\tround_up(src_q_data->bytesperline * height, 4096) +\n\t\tsrc_q_data->bytesperline * height / 2;\n\n\tdst_q_data->width = width;\n\tdst_q_data->height = height;\n\tdst_q_data->pixelformat = pixelformat;\n\tswitch (pixelformat) {\n\tcase V4L2_PIX_FMT_YUYV:\n\t\tdst_q_data->bytesperline = width * 2;\n\t\tdst_q_data->sizeimage = dst_q_data->bytesperline * height;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12:\n\tdefault:\n\t\tdst_q_data->bytesperline = width;\n\t\tdst_q_data->sizeimage =\n\t\t\tdst_q_data->bytesperline * height * 3 / 2;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vdoa_context_configure);\n\nstatic int vdoa_probe(struct platform_device *pdev)\n{\n\tstruct vdoa_data *vdoa;\n\tint ret;\n\n\tret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"DMA enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tvdoa = devm_kzalloc(&pdev->dev, sizeof(*vdoa), GFP_KERNEL);\n\tif (!vdoa)\n\t\treturn -ENOMEM;\n\n\tvdoa->dev = &pdev->dev;\n\n\tvdoa->vdoa_clk = devm_clk_get(vdoa->dev, NULL);\n\tif (IS_ERR(vdoa->vdoa_clk)) {\n\t\tdev_err(vdoa->dev, \"Failed to get clock\\n\");\n\t\treturn PTR_ERR(vdoa->vdoa_clk);\n\t}\n\n\tvdoa->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(vdoa->regs))\n\t\treturn PTR_ERR(vdoa->regs);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = devm_request_threaded_irq(&pdev->dev, ret, NULL,\n\t\t\t\t\tvdoa_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\t\"vdoa\", vdoa);\n\tif (ret < 0) {\n\t\tdev_err(vdoa->dev, \"Failed to get irq\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, vdoa);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id vdoa_dt_ids[] = {\n\t{ .compatible = \"fsl,imx6q-vdoa\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, vdoa_dt_ids);\n\nstatic struct platform_driver vdoa_driver = {\n\t.probe\t\t= vdoa_probe,\n\t.driver\t\t= {\n\t\t.name\t= VDOA_NAME,\n\t\t.of_match_table = vdoa_dt_ids,\n\t},\n};\n\nmodule_platform_driver(vdoa_driver);\n\nMODULE_DESCRIPTION(\"Video Data Order Adapter\");\nMODULE_AUTHOR(\"Philipp Zabel <philipp.zabel@gmail.com>\");\nMODULE_ALIAS(\"platform:imx-vdoa\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}