{
  "module_name": "coda-common.c",
  "hash_id": "10523cee50c000fbb9bd6a23877289b66c20466c92dde624ff1b179776042622",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/chips-media/coda-common.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/gcd.h>\n#include <linux/genalloc.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kfifo.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/ratelimit.h>\n#include <linux/reset.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"coda.h\"\n#include \"imx-vdoa.h\"\n\n#define CODA_NAME\t\t\"coda\"\n\n#define CODADX6_MAX_INSTANCES\t4\n#define CODA_MAX_FORMATS\t5\n\n#define CODA_ISRAM_SIZE\t(2048 * 2)\n\n#define MIN_W 48\n#define MIN_H 16\n\n#define S_ALIGN\t\t1  \n#define W_ALIGN\t\t1  \n#define H_ALIGN\t\t1  \n\n#define fh_to_ctx(__fh)\tcontainer_of(__fh, struct coda_ctx, fh)\n\nint coda_debug;\nmodule_param(coda_debug, int, 0644);\nMODULE_PARM_DESC(coda_debug, \"Debug level (0-2)\");\n\nstatic int disable_tiling;\nmodule_param(disable_tiling, int, 0644);\nMODULE_PARM_DESC(disable_tiling, \"Disable tiled frame buffers\");\n\nstatic int disable_vdoa;\nmodule_param(disable_vdoa, int, 0644);\nMODULE_PARM_DESC(disable_vdoa, \"Disable Video Data Order Adapter tiled to raster-scan conversion\");\n\nstatic int enable_bwb = 0;\nmodule_param(enable_bwb, int, 0644);\nMODULE_PARM_DESC(enable_bwb, \"Enable BWB unit for decoding, may crash on certain streams\");\n\nvoid coda_write(struct coda_dev *dev, u32 data, u32 reg)\n{\n\tv4l2_dbg(3, coda_debug, &dev->v4l2_dev,\n\t\t \"%s: data=0x%x, reg=0x%x\\n\", __func__, data, reg);\n\twritel(data, dev->regs_base + reg);\n}\n\nunsigned int coda_read(struct coda_dev *dev, u32 reg)\n{\n\tu32 data;\n\n\tdata = readl(dev->regs_base + reg);\n\tv4l2_dbg(3, coda_debug, &dev->v4l2_dev,\n\t\t \"%s: data=0x%x, reg=0x%x\\n\", __func__, data, reg);\n\treturn data;\n}\n\nvoid coda_write_base(struct coda_ctx *ctx, struct coda_q_data *q_data,\n\t\t     struct vb2_v4l2_buffer *buf, unsigned int reg_y)\n{\n\tu32 base_y = vb2_dma_contig_plane_dma_addr(&buf->vb2_buf, 0);\n\tu32 base_cb, base_cr;\n\n\tswitch (q_data->fourcc) {\n\tcase V4L2_PIX_FMT_YUYV:\n\t\t \n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_YUV420:\n\tdefault:\n\t\tbase_cb = base_y + q_data->bytesperline * q_data->height;\n\t\tbase_cr = base_cb + q_data->bytesperline * q_data->height / 4;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YVU420:\n\t\t \n\t\tbase_cr = base_y + q_data->bytesperline * q_data->height;\n\t\tbase_cb = base_cr + q_data->bytesperline * q_data->height / 4;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\tbase_cb = base_y + q_data->bytesperline * q_data->height;\n\t\tbase_cr = base_cb + q_data->bytesperline * q_data->height / 2;\n\t}\n\n\tcoda_write(ctx->dev, base_y, reg_y);\n\tcoda_write(ctx->dev, base_cb, reg_y + 4);\n\tcoda_write(ctx->dev, base_cr, reg_y + 8);\n}\n\n#define CODA_CODEC(mode, src_fourcc, dst_fourcc, max_w, max_h) \\\n\t{ mode, src_fourcc, dst_fourcc, max_w, max_h }\n\n \nstatic const struct coda_codec codadx6_codecs[] = {\n\tCODA_CODEC(CODADX6_MODE_ENCODE_H264, V4L2_PIX_FMT_YUV420, V4L2_PIX_FMT_H264,  720, 576),\n\tCODA_CODEC(CODADX6_MODE_ENCODE_MP4,  V4L2_PIX_FMT_YUV420, V4L2_PIX_FMT_MPEG4, 720, 576),\n};\n\nstatic const struct coda_codec codahx4_codecs[] = {\n\tCODA_CODEC(CODA7_MODE_ENCODE_H264, V4L2_PIX_FMT_YUV420, V4L2_PIX_FMT_H264,   720, 576),\n\tCODA_CODEC(CODA7_MODE_DECODE_H264, V4L2_PIX_FMT_H264,   V4L2_PIX_FMT_YUV420, 1920, 1088),\n\tCODA_CODEC(CODA7_MODE_DECODE_MP2,  V4L2_PIX_FMT_MPEG2,  V4L2_PIX_FMT_YUV420, 1920, 1088),\n\tCODA_CODEC(CODA7_MODE_DECODE_MP4,  V4L2_PIX_FMT_MPEG4,  V4L2_PIX_FMT_YUV420, 1280, 720),\n};\n\nstatic const struct coda_codec coda7_codecs[] = {\n\tCODA_CODEC(CODA7_MODE_ENCODE_H264, V4L2_PIX_FMT_YUV420, V4L2_PIX_FMT_H264,   1280, 720),\n\tCODA_CODEC(CODA7_MODE_ENCODE_MP4,  V4L2_PIX_FMT_YUV420, V4L2_PIX_FMT_MPEG4,  1280, 720),\n\tCODA_CODEC(CODA7_MODE_ENCODE_MJPG, V4L2_PIX_FMT_YUV420, V4L2_PIX_FMT_JPEG,   8192, 8192),\n\tCODA_CODEC(CODA7_MODE_DECODE_H264, V4L2_PIX_FMT_H264,   V4L2_PIX_FMT_YUV420, 1920, 1088),\n\tCODA_CODEC(CODA7_MODE_DECODE_MP2,  V4L2_PIX_FMT_MPEG2,  V4L2_PIX_FMT_YUV420, 1920, 1088),\n\tCODA_CODEC(CODA7_MODE_DECODE_MP4,  V4L2_PIX_FMT_MPEG4,  V4L2_PIX_FMT_YUV420, 1920, 1088),\n\tCODA_CODEC(CODA7_MODE_DECODE_MJPG, V4L2_PIX_FMT_JPEG,   V4L2_PIX_FMT_YUV420, 8192, 8192),\n};\n\nstatic const struct coda_codec coda9_codecs[] = {\n\tCODA_CODEC(CODA9_MODE_ENCODE_H264, V4L2_PIX_FMT_YUV420, V4L2_PIX_FMT_H264,   1920, 1088),\n\tCODA_CODEC(CODA9_MODE_ENCODE_MP4,  V4L2_PIX_FMT_YUV420, V4L2_PIX_FMT_MPEG4,  1920, 1088),\n\tCODA_CODEC(CODA9_MODE_ENCODE_MJPG, V4L2_PIX_FMT_YUV420, V4L2_PIX_FMT_JPEG,   8192, 8192),\n\tCODA_CODEC(CODA9_MODE_DECODE_H264, V4L2_PIX_FMT_H264,   V4L2_PIX_FMT_YUV420, 1920, 1088),\n\tCODA_CODEC(CODA9_MODE_DECODE_MP2,  V4L2_PIX_FMT_MPEG2,  V4L2_PIX_FMT_YUV420, 1920, 1088),\n\tCODA_CODEC(CODA9_MODE_DECODE_MP4,  V4L2_PIX_FMT_MPEG4,  V4L2_PIX_FMT_YUV420, 1920, 1088),\n\tCODA_CODEC(CODA9_MODE_DECODE_MJPG, V4L2_PIX_FMT_JPEG,\tV4L2_PIX_FMT_YUV420, 8192, 8192),\n};\n\nstruct coda_video_device {\n\tconst char *name;\n\tenum coda_inst_type type;\n\tconst struct coda_context_ops *ops;\n\tbool direct;\n\tu32 src_formats[CODA_MAX_FORMATS];\n\tu32 dst_formats[CODA_MAX_FORMATS];\n};\n\nstatic const struct coda_video_device coda_bit_encoder = {\n\t.name = \"coda-video-encoder\",\n\t.type = CODA_INST_ENCODER,\n\t.ops = &coda_bit_encode_ops,\n\t.src_formats = {\n\t\tV4L2_PIX_FMT_NV12,\n\t\tV4L2_PIX_FMT_YUV420,\n\t\tV4L2_PIX_FMT_YVU420,\n\t},\n\t.dst_formats = {\n\t\tV4L2_PIX_FMT_H264,\n\t\tV4L2_PIX_FMT_MPEG4,\n\t},\n};\n\nstatic const struct coda_video_device coda_bit_jpeg_encoder = {\n\t.name = \"coda-jpeg-encoder\",\n\t.type = CODA_INST_ENCODER,\n\t.ops = &coda_bit_encode_ops,\n\t.src_formats = {\n\t\tV4L2_PIX_FMT_NV12,\n\t\tV4L2_PIX_FMT_YUV420,\n\t\tV4L2_PIX_FMT_YVU420,\n\t\tV4L2_PIX_FMT_YUV422P,\n\t},\n\t.dst_formats = {\n\t\tV4L2_PIX_FMT_JPEG,\n\t},\n};\n\nstatic const struct coda_video_device coda_bit_decoder = {\n\t.name = \"coda-video-decoder\",\n\t.type = CODA_INST_DECODER,\n\t.ops = &coda_bit_decode_ops,\n\t.src_formats = {\n\t\tV4L2_PIX_FMT_H264,\n\t\tV4L2_PIX_FMT_MPEG2,\n\t\tV4L2_PIX_FMT_MPEG4,\n\t},\n\t.dst_formats = {\n\t\tV4L2_PIX_FMT_NV12,\n\t\tV4L2_PIX_FMT_YUV420,\n\t\tV4L2_PIX_FMT_YVU420,\n\t\t \n\t\tV4L2_PIX_FMT_YUYV,\n\t},\n};\n\nstatic const struct coda_video_device coda_bit_jpeg_decoder = {\n\t.name = \"coda-jpeg-decoder\",\n\t.type = CODA_INST_DECODER,\n\t.ops = &coda_bit_decode_ops,\n\t.src_formats = {\n\t\tV4L2_PIX_FMT_JPEG,\n\t},\n\t.dst_formats = {\n\t\tV4L2_PIX_FMT_NV12,\n\t\tV4L2_PIX_FMT_YUV420,\n\t\tV4L2_PIX_FMT_YVU420,\n\t\tV4L2_PIX_FMT_YUV422P,\n\t},\n};\n\nstatic const struct coda_video_device coda9_jpeg_encoder = {\n\t.name = \"coda-jpeg-encoder\",\n\t.type = CODA_INST_ENCODER,\n\t.ops = &coda9_jpeg_encode_ops,\n\t.direct = true,\n\t.src_formats = {\n\t\tV4L2_PIX_FMT_NV12,\n\t\tV4L2_PIX_FMT_YUV420,\n\t\tV4L2_PIX_FMT_YVU420,\n\t\tV4L2_PIX_FMT_YUV422P,\n\t\tV4L2_PIX_FMT_GREY,\n\t},\n\t.dst_formats = {\n\t\tV4L2_PIX_FMT_JPEG,\n\t},\n};\n\nstatic const struct coda_video_device coda9_jpeg_decoder = {\n\t.name = \"coda-jpeg-decoder\",\n\t.type = CODA_INST_DECODER,\n\t.ops = &coda9_jpeg_decode_ops,\n\t.direct = true,\n\t.src_formats = {\n\t\tV4L2_PIX_FMT_JPEG,\n\t},\n\t.dst_formats = {\n\t\tV4L2_PIX_FMT_NV12,\n\t\tV4L2_PIX_FMT_YUV420,\n\t\tV4L2_PIX_FMT_YVU420,\n\t\tV4L2_PIX_FMT_YUV422P,\n\t},\n};\n\nstatic const struct coda_video_device *codadx6_video_devices[] = {\n\t&coda_bit_encoder,\n};\n\nstatic const struct coda_video_device *codahx4_video_devices[] = {\n\t&coda_bit_encoder,\n\t&coda_bit_decoder,\n};\n\nstatic const struct coda_video_device *coda7_video_devices[] = {\n\t&coda_bit_jpeg_encoder,\n\t&coda_bit_jpeg_decoder,\n\t&coda_bit_encoder,\n\t&coda_bit_decoder,\n};\n\nstatic const struct coda_video_device *coda9_video_devices[] = {\n\t&coda9_jpeg_encoder,\n\t&coda9_jpeg_decoder,\n\t&coda_bit_encoder,\n\t&coda_bit_decoder,\n};\n\n \nstatic u32 coda_format_normalize_yuv(u32 fourcc)\n{\n\tswitch (fourcc) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\tcase V4L2_PIX_FMT_YUV422P:\n\tcase V4L2_PIX_FMT_YUYV:\n\t\treturn V4L2_PIX_FMT_YUV420;\n\tdefault:\n\t\treturn fourcc;\n\t}\n}\n\nstatic const struct coda_codec *coda_find_codec(struct coda_dev *dev,\n\t\t\t\t\t\tint src_fourcc, int dst_fourcc)\n{\n\tconst struct coda_codec *codecs = dev->devtype->codecs;\n\tint num_codecs = dev->devtype->num_codecs;\n\tint k;\n\n\tsrc_fourcc = coda_format_normalize_yuv(src_fourcc);\n\tdst_fourcc = coda_format_normalize_yuv(dst_fourcc);\n\tif (src_fourcc == dst_fourcc)\n\t\treturn NULL;\n\n\tfor (k = 0; k < num_codecs; k++) {\n\t\tif (codecs[k].src_fourcc == src_fourcc &&\n\t\t    codecs[k].dst_fourcc == dst_fourcc)\n\t\t\tbreak;\n\t}\n\n\tif (k == num_codecs)\n\t\treturn NULL;\n\n\treturn &codecs[k];\n}\n\nstatic void coda_get_max_dimensions(struct coda_dev *dev,\n\t\t\t\t    const struct coda_codec *codec,\n\t\t\t\t    int *max_w, int *max_h)\n{\n\tconst struct coda_codec *codecs = dev->devtype->codecs;\n\tint num_codecs = dev->devtype->num_codecs;\n\tunsigned int w, h;\n\tint k;\n\n\tif (codec) {\n\t\tw = codec->max_w;\n\t\th = codec->max_h;\n\t} else {\n\t\tfor (k = 0, w = 0, h = 0; k < num_codecs; k++) {\n\t\t\tw = max(w, codecs[k].max_w);\n\t\t\th = max(h, codecs[k].max_h);\n\t\t}\n\t}\n\n\tif (max_w)\n\t\t*max_w = w;\n\tif (max_h)\n\t\t*max_h = h;\n}\n\nstatic const struct coda_video_device *to_coda_video_device(struct video_device\n\t\t\t\t\t\t\t    *vdev)\n{\n\tstruct coda_dev *dev = video_get_drvdata(vdev);\n\tunsigned int i = vdev - dev->vfd;\n\n\tif (i >= dev->devtype->num_vdevs)\n\t\treturn NULL;\n\n\treturn dev->devtype->vdevs[i];\n}\n\nconst char *coda_product_name(int product)\n{\n\tstatic char buf[9];\n\n\tswitch (product) {\n\tcase CODA_DX6:\n\t\treturn \"CodaDx6\";\n\tcase CODA_HX4:\n\t\treturn \"CodaHx4\";\n\tcase CODA_7541:\n\t\treturn \"CODA7541\";\n\tcase CODA_960:\n\t\treturn \"CODA960\";\n\tdefault:\n\t\tsnprintf(buf, sizeof(buf), \"(0x%04x)\", product);\n\t\treturn buf;\n\t}\n}\n\nstatic struct vdoa_data *coda_get_vdoa_data(void)\n{\n\tstruct device_node *vdoa_node;\n\tstruct platform_device *vdoa_pdev;\n\tstruct vdoa_data *vdoa_data = NULL;\n\n\tvdoa_node = of_find_compatible_node(NULL, NULL, \"fsl,imx6q-vdoa\");\n\tif (!vdoa_node)\n\t\treturn NULL;\n\n\tvdoa_pdev = of_find_device_by_node(vdoa_node);\n\tif (!vdoa_pdev)\n\t\tgoto out;\n\n\tvdoa_data = platform_get_drvdata(vdoa_pdev);\n\tif (!vdoa_data)\n\t\tvdoa_data = ERR_PTR(-EPROBE_DEFER);\n\n\tput_device(&vdoa_pdev->dev);\nout:\n\tof_node_put(vdoa_node);\n\n\treturn vdoa_data;\n}\n\n \nstatic int coda_querycap(struct file *file, void *priv,\n\t\t\t struct v4l2_capability *cap)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(priv);\n\n\tstrscpy(cap->driver, CODA_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, coda_product_name(ctx->dev->devtype->product),\n\t\tsizeof(cap->card));\n\tstrscpy(cap->bus_info, \"platform:\" CODA_NAME, sizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic const u32 coda_formats_420[CODA_MAX_FORMATS] = {\n\t\tV4L2_PIX_FMT_NV12,\n\t\tV4L2_PIX_FMT_YUV420,\n\t\tV4L2_PIX_FMT_YVU420,\n};\n\nstatic int coda_enum_fmt(struct file *file, void *priv,\n\t\t\t struct v4l2_fmtdesc *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tconst struct coda_video_device *cvd = to_coda_video_device(vdev);\n\tstruct coda_ctx *ctx = fh_to_ctx(priv);\n\tconst u32 *formats;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tformats = cvd->src_formats;\n\telse if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\tstruct coda_q_data *q_data_src;\n\t\tstruct vb2_queue *src_vq;\n\n\t\tformats = cvd->dst_formats;\n\n\t\t \n\t\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\t\tsrc_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\t\tif (q_data_src->fourcc == V4L2_PIX_FMT_JPEG &&\n\t\t    vb2_is_streaming(src_vq)) {\n\t\t\tif (ctx->params.jpeg_chroma_subsampling ==\n\t\t\t    V4L2_JPEG_CHROMA_SUBSAMPLING_420) {\n\t\t\t\tformats = coda_formats_420;\n\t\t\t} else if (ctx->params.jpeg_chroma_subsampling ==\n\t\t\t\t   V4L2_JPEG_CHROMA_SUBSAMPLING_422) {\n\t\t\t\tf->pixelformat = V4L2_PIX_FMT_YUV422P;\n\t\t\t\treturn f->index ? -EINVAL : 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (f->index >= CODA_MAX_FORMATS || formats[f->index] == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (!ctx->vdoa && f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    formats[f->index] == V4L2_PIX_FMT_YUYV)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[f->index];\n\n\treturn 0;\n}\n\nstatic int coda_g_fmt(struct file *file, void *priv,\n\t\t      struct v4l2_format *f)\n{\n\tstruct coda_q_data *q_data;\n\tstruct coda_ctx *ctx = fh_to_ctx(priv);\n\n\tq_data = get_q_data(ctx, f->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tf->fmt.pix.field\t= V4L2_FIELD_NONE;\n\tf->fmt.pix.pixelformat\t= q_data->fourcc;\n\tf->fmt.pix.width\t= q_data->width;\n\tf->fmt.pix.height\t= q_data->height;\n\tf->fmt.pix.bytesperline = q_data->bytesperline;\n\n\tf->fmt.pix.sizeimage\t= q_data->sizeimage;\n\tf->fmt.pix.colorspace\t= ctx->colorspace;\n\tf->fmt.pix.xfer_func\t= ctx->xfer_func;\n\tf->fmt.pix.ycbcr_enc\t= ctx->ycbcr_enc;\n\tf->fmt.pix.quantization\t= ctx->quantization;\n\n\treturn 0;\n}\n\nstatic int coda_try_pixelformat(struct coda_ctx *ctx, struct v4l2_format *f)\n{\n\tstruct coda_q_data *q_data;\n\tconst u32 *formats;\n\tint i;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tformats = ctx->cvd->src_formats;\n\telse if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tformats = ctx->cvd->dst_formats;\n\telse\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < CODA_MAX_FORMATS; i++) {\n\t\t \n\t\tif (!ctx->vdoa && f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t\t    formats[i] == V4L2_PIX_FMT_YUYV)\n\t\t\tcontinue;\n\n\t\tif (formats[i] == f->fmt.pix.pixelformat) {\n\t\t\tf->fmt.pix.pixelformat = formats[i];\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tq_data = get_q_data(ctx, f->type);\n\tf->fmt.pix.pixelformat = q_data->fourcc;\n\n\treturn 0;\n}\n\nstatic int coda_try_fmt_vdoa(struct coda_ctx *ctx, struct v4l2_format *f,\n\t\t\t     bool *use_vdoa)\n{\n\tint err;\n\n\tif (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (!use_vdoa)\n\t\treturn -EINVAL;\n\n\tif (!ctx->vdoa) {\n\t\t*use_vdoa = false;\n\t\treturn 0;\n\t}\n\n\terr = vdoa_context_configure(NULL, round_up(f->fmt.pix.width, 16),\n\t\t\t\t     f->fmt.pix.height, f->fmt.pix.pixelformat);\n\tif (err) {\n\t\t*use_vdoa = false;\n\t\treturn 0;\n\t}\n\n\t*use_vdoa = true;\n\treturn 0;\n}\n\nstatic unsigned int coda_estimate_sizeimage(struct coda_ctx *ctx, u32 sizeimage,\n\t\t\t\t\t    u32 width, u32 height)\n{\n\t \n\treturn round_up(clamp(sizeimage, width * height / 8,\n\t\t\t\t\t width * height * 2), PAGE_SIZE);\n}\n\nstatic int coda_try_fmt(struct coda_ctx *ctx, const struct coda_codec *codec,\n\t\t\tstruct v4l2_format *f)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tunsigned int max_w, max_h;\n\tenum v4l2_field field;\n\n\tfield = f->fmt.pix.field;\n\tif (field == V4L2_FIELD_ANY)\n\t\tfield = V4L2_FIELD_NONE;\n\telse if (V4L2_FIELD_NONE != field)\n\t\treturn -EINVAL;\n\n\t \n\tf->fmt.pix.field = field;\n\n\tcoda_get_max_dimensions(dev, codec, &max_w, &max_h);\n\tv4l_bound_align_image(&f->fmt.pix.width, MIN_W, max_w, W_ALIGN,\n\t\t\t      &f->fmt.pix.height, MIN_H, max_h, H_ALIGN,\n\t\t\t      S_ALIGN);\n\n\tswitch (f->fmt.pix.pixelformat) {\n\tcase V4L2_PIX_FMT_NV12:\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\t\t \n\t\tf->fmt.pix.bytesperline = round_up(f->fmt.pix.width, 16);\n\t\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\n\t\t\t\t\tf->fmt.pix.height * 3 / 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUYV:\n\t\tf->fmt.pix.bytesperline = round_up(f->fmt.pix.width, 16) * 2;\n\t\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\n\t\t\t\t\tf->fmt.pix.height;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\tf->fmt.pix.bytesperline = round_up(f->fmt.pix.width, 16);\n\t\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\n\t\t\t\t\tf->fmt.pix.height * 2;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_GREY:\n\t\t \n\t\tf->fmt.pix.bytesperline = round_up(f->fmt.pix.width, 16);\n\t\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * f->fmt.pix.height;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_JPEG:\n\tcase V4L2_PIX_FMT_H264:\n\tcase V4L2_PIX_FMT_MPEG4:\n\tcase V4L2_PIX_FMT_MPEG2:\n\t\tf->fmt.pix.bytesperline = 0;\n\t\tf->fmt.pix.sizeimage = coda_estimate_sizeimage(ctx,\n\t\t\t\t\t\t\tf->fmt.pix.sizeimage,\n\t\t\t\t\t\t\tf->fmt.pix.width,\n\t\t\t\t\t\t\tf->fmt.pix.height);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn 0;\n}\n\nstatic int coda_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(priv);\n\tconst struct coda_q_data *q_data_src;\n\tconst struct coda_codec *codec;\n\tstruct vb2_queue *src_vq;\n\tint hscale = 0;\n\tint vscale = 0;\n\tint ret;\n\tbool use_vdoa;\n\n\tret = coda_try_pixelformat(ctx, f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\n\t \n\tsrc_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tif (vb2_is_streaming(src_vq)) {\n\t\tif (q_data_src->fourcc == V4L2_PIX_FMT_JPEG &&\n\t\t    ctx->dev->devtype->product == CODA_960) {\n\t\t\thscale = coda_jpeg_scale(q_data_src->width, f->fmt.pix.width);\n\t\t\tvscale = coda_jpeg_scale(q_data_src->height, f->fmt.pix.height);\n\t\t}\n\t\tf->fmt.pix.width = q_data_src->width >> hscale;\n\t\tf->fmt.pix.height = q_data_src->height >> vscale;\n\n\t\tif (q_data_src->fourcc == V4L2_PIX_FMT_JPEG) {\n\t\t\tif (ctx->params.jpeg_chroma_subsampling ==\n\t\t\t    V4L2_JPEG_CHROMA_SUBSAMPLING_420 &&\n\t\t\t    f->fmt.pix.pixelformat == V4L2_PIX_FMT_YUV422P)\n\t\t\t\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_NV12;\n\t\t\telse if (ctx->params.jpeg_chroma_subsampling ==\n\t\t\t\t V4L2_JPEG_CHROMA_SUBSAMPLING_422)\n\t\t\t\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422P;\n\t\t}\n\t}\n\n\tf->fmt.pix.colorspace = ctx->colorspace;\n\tf->fmt.pix.xfer_func = ctx->xfer_func;\n\tf->fmt.pix.ycbcr_enc = ctx->ycbcr_enc;\n\tf->fmt.pix.quantization = ctx->quantization;\n\n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tcodec = coda_find_codec(ctx->dev, q_data_src->fourcc,\n\t\t\t\tf->fmt.pix.pixelformat);\n\tif (!codec)\n\t\treturn -EINVAL;\n\n\tret = coda_try_fmt(ctx, codec, f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ctx->inst_type == CODA_INST_DECODER) {\n\t\tf->fmt.pix.bytesperline = round_up(f->fmt.pix.width, 16 >> hscale);\n\t\tf->fmt.pix.height = round_up(f->fmt.pix.height, 16 >> vscale);\n\t\tif (codec->src_fourcc == V4L2_PIX_FMT_JPEG &&\n\t\t    f->fmt.pix.pixelformat == V4L2_PIX_FMT_YUV422P) {\n\t\t\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\n\t\t\t\t\t       f->fmt.pix.height * 2;\n\t\t} else {\n\t\t\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\n\t\t\t\t\t       f->fmt.pix.height * 3 / 2;\n\t\t}\n\n\t\tret = coda_try_fmt_vdoa(ctx, f, &use_vdoa);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_YUYV) {\n\t\t\tif (!use_vdoa)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tf->fmt.pix.bytesperline = round_up(f->fmt.pix.width, 16) * 2;\n\t\t\tf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\n\t\t\t\tf->fmt.pix.height;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void coda_set_default_colorspace(struct v4l2_pix_format *fmt)\n{\n\tenum v4l2_colorspace colorspace;\n\n\tif (fmt->pixelformat == V4L2_PIX_FMT_JPEG)\n\t\tcolorspace = V4L2_COLORSPACE_JPEG;\n\telse if (fmt->width <= 720 && fmt->height <= 576)\n\t\tcolorspace = V4L2_COLORSPACE_SMPTE170M;\n\telse\n\t\tcolorspace = V4L2_COLORSPACE_REC709;\n\n\tfmt->colorspace = colorspace;\n\tfmt->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\tfmt->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tfmt->quantization = V4L2_QUANTIZATION_DEFAULT;\n}\n\nstatic int coda_try_fmt_vid_out(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(priv);\n\tstruct coda_dev *dev = ctx->dev;\n\tconst struct coda_q_data *q_data_dst;\n\tconst struct coda_codec *codec;\n\tint ret;\n\n\tret = coda_try_pixelformat(ctx, f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (f->fmt.pix.colorspace == V4L2_COLORSPACE_DEFAULT)\n\t\tcoda_set_default_colorspace(&f->fmt.pix);\n\n\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tcodec = coda_find_codec(dev, f->fmt.pix.pixelformat, q_data_dst->fourcc);\n\n\treturn coda_try_fmt(ctx, codec, f);\n}\n\nstatic int coda_s_fmt(struct coda_ctx *ctx, struct v4l2_format *f,\n\t\t      struct v4l2_rect *r)\n{\n\tstruct coda_q_data *q_data;\n\tstruct vb2_queue *vq;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ctx, f->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"%s: %s queue busy: %d\\n\",\n\t\t\t __func__, v4l2_type_names[f->type], vq->num_buffers);\n\t\treturn -EBUSY;\n\t}\n\n\tq_data->fourcc = f->fmt.pix.pixelformat;\n\tq_data->width = f->fmt.pix.width;\n\tq_data->height = f->fmt.pix.height;\n\tq_data->bytesperline = f->fmt.pix.bytesperline;\n\tq_data->sizeimage = f->fmt.pix.sizeimage;\n\tif (r) {\n\t\tq_data->rect = *r;\n\t} else {\n\t\tq_data->rect.left = 0;\n\t\tq_data->rect.top = 0;\n\t\tq_data->rect.width = f->fmt.pix.width;\n\t\tq_data->rect.height = f->fmt.pix.height;\n\t}\n\n\tswitch (f->fmt.pix.pixelformat) {\n\tcase V4L2_PIX_FMT_YUYV:\n\t\tctx->tiled_map_type = GDI_TILED_FRAME_MB_RASTER_MAP;\n\t\tbreak;\n\tcase V4L2_PIX_FMT_NV12:\n\t\tif (!disable_tiling && ctx->use_bit &&\n\t\t    ctx->dev->devtype->product == CODA_960) {\n\t\t\tctx->tiled_map_type = GDI_TILED_FRAME_MB_RASTER_MAP;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase V4L2_PIX_FMT_YUV420:\n\tcase V4L2_PIX_FMT_YVU420:\n\tcase V4L2_PIX_FMT_YUV422P:\n\t\tctx->tiled_map_type = GDI_LINEAR_FRAME_MAP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ctx->tiled_map_type == GDI_TILED_FRAME_MB_RASTER_MAP &&\n\t    !coda_try_fmt_vdoa(ctx, f, &ctx->use_vdoa) &&\n\t    ctx->use_vdoa)\n\t\tvdoa_context_configure(ctx->vdoa,\n\t\t\t\t       round_up(f->fmt.pix.width, 16),\n\t\t\t\t       f->fmt.pix.height,\n\t\t\t\t       f->fmt.pix.pixelformat);\n\telse\n\t\tctx->use_vdoa = false;\n\n\tcoda_dbg(1, ctx, \"Setting %s format, wxh: %dx%d, fmt: %4.4s %c\\n\",\n\t\t v4l2_type_names[f->type], q_data->width, q_data->height,\n\t\t (char *)&q_data->fourcc,\n\t\t (ctx->tiled_map_type == GDI_LINEAR_FRAME_MAP) ? 'L' : 'T');\n\n\treturn 0;\n}\n\nstatic int coda_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(priv);\n\tstruct coda_q_data *q_data_src;\n\tconst struct coda_codec *codec;\n\tstruct v4l2_rect r;\n\tint hscale = 0;\n\tint vscale = 0;\n\tint ret;\n\n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\n\tif (q_data_src->fourcc == V4L2_PIX_FMT_JPEG &&\n\t    ctx->dev->devtype->product == CODA_960) {\n\t\thscale = coda_jpeg_scale(q_data_src->width, f->fmt.pix.width);\n\t\tvscale = coda_jpeg_scale(q_data_src->height, f->fmt.pix.height);\n\t}\n\n\tret = coda_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tr.left = 0;\n\tr.top = 0;\n\tr.width = q_data_src->width >> hscale;\n\tr.height = q_data_src->height >> vscale;\n\n\tret = coda_s_fmt(ctx, f, &r);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->inst_type != CODA_INST_ENCODER)\n\t\treturn 0;\n\n\t \n\tcodec = coda_find_codec(ctx->dev, q_data_src->fourcc,\n\t\t\t\tf->fmt.pix.pixelformat);\n\tif (!codec) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"failed to determine codec\\n\");\n\t\treturn -EINVAL;\n\t}\n\tctx->codec = codec;\n\n\tctx->colorspace = f->fmt.pix.colorspace;\n\tctx->xfer_func = f->fmt.pix.xfer_func;\n\tctx->ycbcr_enc = f->fmt.pix.ycbcr_enc;\n\tctx->quantization = f->fmt.pix.quantization;\n\n\treturn 0;\n}\n\nstatic int coda_s_fmt_vid_out(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(priv);\n\tconst struct coda_codec *codec;\n\tstruct v4l2_format f_cap;\n\tstruct vb2_queue *dst_vq;\n\tint ret;\n\n\tret = coda_try_fmt_vid_out(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tret = coda_s_fmt(ctx, f, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->colorspace = f->fmt.pix.colorspace;\n\tctx->xfer_func = f->fmt.pix.xfer_func;\n\tctx->ycbcr_enc = f->fmt.pix.ycbcr_enc;\n\tctx->quantization = f->fmt.pix.quantization;\n\n\tif (ctx->inst_type != CODA_INST_DECODER)\n\t\treturn 0;\n\n\t \n\tcodec = coda_find_codec(ctx->dev, f->fmt.pix.pixelformat,\n\t\t\t\tV4L2_PIX_FMT_YUV420);\n\tif (!codec) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"failed to determine codec\\n\");\n\t\treturn -EINVAL;\n\t}\n\tctx->codec = codec;\n\n\tdst_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tif (!dst_vq)\n\t\treturn -EINVAL;\n\n\t \n\tif (vb2_is_busy(dst_vq))\n\t\treturn 0;\n\n\tmemset(&f_cap, 0, sizeof(f_cap));\n\tf_cap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tcoda_g_fmt(file, priv, &f_cap);\n\tf_cap.fmt.pix.width = f->fmt.pix.width;\n\tf_cap.fmt.pix.height = f->fmt.pix.height;\n\n\treturn coda_s_fmt_vid_cap(file, priv, &f_cap);\n}\n\nstatic int coda_reqbufs(struct file *file, void *priv,\n\t\t\tstruct v4l2_requestbuffers *rb)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(priv);\n\tint ret;\n\n\tret = v4l2_m2m_reqbufs(file, ctx->fh.m2m_ctx, rb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (rb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT && ctx->ops->reqbufs)\n\t\treturn ctx->ops->reqbufs(ctx, rb);\n\n\treturn 0;\n}\n\nstatic int coda_qbuf(struct file *file, void *priv,\n\t\t     struct v4l2_buffer *buf)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(priv);\n\n\tif (ctx->inst_type == CODA_INST_DECODER &&\n\t    buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tbuf->flags &= ~V4L2_BUF_FLAG_LAST;\n\n\treturn v4l2_m2m_qbuf(file, ctx->fh.m2m_ctx, buf);\n}\n\nstatic int coda_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(priv);\n\tint ret;\n\n\tret = v4l2_m2m_dqbuf(file, ctx->fh.m2m_ctx, buf);\n\n\tif (ctx->inst_type == CODA_INST_DECODER &&\n\t    buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tbuf->flags &= ~V4L2_BUF_FLAG_LAST;\n\n\treturn ret;\n}\n\nvoid coda_m2m_buf_done(struct coda_ctx *ctx, struct vb2_v4l2_buffer *buf,\n\t\t       enum vb2_buffer_state state)\n{\n\tconst struct v4l2_event eos_event = {\n\t\t.type = V4L2_EVENT_EOS\n\t};\n\n\tif (buf->flags & V4L2_BUF_FLAG_LAST)\n\t\tv4l2_event_queue_fh(&ctx->fh, &eos_event);\n\n\tv4l2_m2m_buf_done(buf, state);\n}\n\nstatic int coda_g_selection(struct file *file, void *fh,\n\t\t\t    struct v4l2_selection *s)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(fh);\n\tstruct coda_q_data *q_data;\n\tstruct v4l2_rect r, *rsel;\n\n\tq_data = get_q_data(ctx, s->type);\n\tif (!q_data)\n\t\treturn -EINVAL;\n\n\tr.left = 0;\n\tr.top = 0;\n\tr.width = q_data->width;\n\tr.height = q_data->height;\n\trsel = &q_data->rect;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\trsel = &r;\n\t\tfallthrough;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\n\t\t    ctx->inst_type == CODA_INST_DECODER)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\tcase V4L2_SEL_TGT_COMPOSE_PADDED:\n\t\trsel = &r;\n\t\tfallthrough;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\n\t\t    ctx->inst_type == CODA_INST_ENCODER)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ts->r = *rsel;\n\n\treturn 0;\n}\n\nstatic int coda_s_selection(struct file *file, void *fh,\n\t\t\t    struct v4l2_selection *s)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(fh);\n\tstruct coda_q_data *q_data;\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (ctx->inst_type == CODA_INST_ENCODER &&\n\t\t    s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\t\tq_data = get_q_data(ctx, s->type);\n\t\t\tif (!q_data)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ts->r.left = 0;\n\t\t\ts->r.top = 0;\n\t\t\ts->r.width = clamp(s->r.width, 2U, q_data->width);\n\t\t\ts->r.height = clamp(s->r.height, 2U, q_data->height);\n\n\t\t\tif (s->flags & V4L2_SEL_FLAG_LE) {\n\t\t\t\ts->r.width = round_up(s->r.width, 2);\n\t\t\t\ts->r.height = round_up(s->r.height, 2);\n\t\t\t} else {\n\t\t\t\ts->r.width = round_down(s->r.width, 2);\n\t\t\t\ts->r.height = round_down(s->r.height, 2);\n\t\t\t}\n\n\t\t\tq_data->rect = s->r;\n\n\t\t\tcoda_dbg(1, ctx, \"Setting crop rectangle: %dx%d\\n\",\n\t\t\t\t s->r.width, s->r.height);\n\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tcase V4L2_SEL_TGT_NATIVE_SIZE:\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\treturn coda_g_selection(file, fh, s);\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void coda_wake_up_capture_queue(struct coda_ctx *ctx)\n{\n\tstruct vb2_queue *dst_vq;\n\n\tcoda_dbg(1, ctx, \"waking up capture queue\\n\");\n\n\tdst_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tdst_vq->last_buffer_dequeued = true;\n\twake_up(&dst_vq->done_wq);\n}\n\nstatic int coda_encoder_cmd(struct file *file, void *fh,\n\t\t\t    struct v4l2_encoder_cmd *ec)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(fh);\n\tstruct vb2_v4l2_buffer *buf;\n\tint ret;\n\n\tret = v4l2_m2m_ioctl_try_encoder_cmd(file, fh, ec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&ctx->wakeup_mutex);\n\tbuf = v4l2_m2m_last_src_buf(ctx->fh.m2m_ctx);\n\tif (buf) {\n\t\t \n\t\tbuf->flags |= V4L2_BUF_FLAG_LAST;\n\t} else {\n\t\t \n\t\tctx->bit_stream_param |= CODA_BIT_STREAM_END_FLAG;\n\n\t\t \n\t\tcoda_wake_up_capture_queue(ctx);\n\t}\n\tmutex_unlock(&ctx->wakeup_mutex);\n\n\treturn 0;\n}\n\nstatic bool coda_mark_last_meta(struct coda_ctx *ctx)\n{\n\tstruct coda_buffer_meta *meta;\n\n\tcoda_dbg(1, ctx, \"marking last meta\\n\");\n\n\tspin_lock(&ctx->buffer_meta_lock);\n\tif (list_empty(&ctx->buffer_meta_list)) {\n\t\tspin_unlock(&ctx->buffer_meta_lock);\n\t\treturn false;\n\t}\n\n\tmeta = list_last_entry(&ctx->buffer_meta_list, struct coda_buffer_meta,\n\t\t\t       list);\n\tmeta->last = true;\n\n\tspin_unlock(&ctx->buffer_meta_lock);\n\treturn true;\n}\n\nstatic bool coda_mark_last_dst_buf(struct coda_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *buf;\n\tstruct vb2_buffer *dst_vb;\n\tstruct vb2_queue *dst_vq;\n\tunsigned long flags;\n\n\tcoda_dbg(1, ctx, \"marking last capture buffer\\n\");\n\n\tdst_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tspin_lock_irqsave(&dst_vq->done_lock, flags);\n\tif (list_empty(&dst_vq->done_list)) {\n\t\tspin_unlock_irqrestore(&dst_vq->done_lock, flags);\n\t\treturn false;\n\t}\n\n\tdst_vb = list_last_entry(&dst_vq->done_list, struct vb2_buffer,\n\t\t\t\t done_entry);\n\tbuf = to_vb2_v4l2_buffer(dst_vb);\n\tbuf->flags |= V4L2_BUF_FLAG_LAST;\n\n\tspin_unlock_irqrestore(&dst_vq->done_lock, flags);\n\treturn true;\n}\n\nstatic int coda_decoder_cmd(struct file *file, void *fh,\n\t\t\t    struct v4l2_decoder_cmd *dc)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(fh);\n\tstruct coda_dev *dev = ctx->dev;\n\tstruct vb2_v4l2_buffer *buf;\n\tstruct vb2_queue *dst_vq;\n\tbool stream_end;\n\tbool wakeup;\n\tint ret;\n\n\tret = v4l2_m2m_ioctl_try_decoder_cmd(file, fh, dc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (dc->cmd) {\n\tcase V4L2_DEC_CMD_START:\n\t\tmutex_lock(&dev->coda_mutex);\n\t\tmutex_lock(&ctx->bitstream_mutex);\n\t\tcoda_bitstream_flush(ctx);\n\t\tdst_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,\n\t\t\t\t\t V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\tvb2_clear_last_buffer_dequeued(dst_vq);\n\t\tctx->bit_stream_param &= ~CODA_BIT_STREAM_END_FLAG;\n\t\tcoda_fill_bitstream(ctx, NULL);\n\t\tmutex_unlock(&ctx->bitstream_mutex);\n\t\tmutex_unlock(&dev->coda_mutex);\n\t\tbreak;\n\tcase V4L2_DEC_CMD_STOP:\n\t\tstream_end = false;\n\t\twakeup = false;\n\n\t\tmutex_lock(&ctx->wakeup_mutex);\n\n\t\tbuf = v4l2_m2m_last_src_buf(ctx->fh.m2m_ctx);\n\t\tif (buf) {\n\t\t\tcoda_dbg(1, ctx, \"marking last pending buffer\\n\");\n\n\t\t\t \n\t\t\tbuf->flags |= V4L2_BUF_FLAG_LAST;\n\n\t\t\tif (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) == 0) {\n\t\t\t\tcoda_dbg(1, ctx, \"all remaining buffers queued\\n\");\n\t\t\t\tstream_end = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ctx->use_bit)\n\t\t\t\tif (coda_mark_last_meta(ctx))\n\t\t\t\t\tstream_end = true;\n\t\t\t\telse\n\t\t\t\t\twakeup = true;\n\t\t\telse\n\t\t\t\tif (!coda_mark_last_dst_buf(ctx))\n\t\t\t\t\twakeup = true;\n\t\t}\n\n\t\tif (stream_end) {\n\t\t\tcoda_dbg(1, ctx, \"all remaining buffers queued\\n\");\n\n\t\t\t \n\t\t\tcoda_bit_stream_end_flag(ctx);\n\t\t\tctx->hold = false;\n\t\t\tv4l2_m2m_try_schedule(ctx->fh.m2m_ctx);\n\t\t}\n\n\t\tif (wakeup) {\n\t\t\t \n\t\t\tcoda_wake_up_capture_queue(ctx);\n\t\t}\n\n\t\tmutex_unlock(&ctx->wakeup_mutex);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int coda_enum_framesizes(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_frmsizeenum *fsize)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(fh);\n\tstruct coda_q_data *q_data_dst;\n\tconst struct coda_codec *codec;\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\n\tif (coda_format_normalize_yuv(fsize->pixel_format) ==\n\t    V4L2_PIX_FMT_YUV420) {\n\t\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\tcodec = coda_find_codec(ctx->dev, fsize->pixel_format,\n\t\t\t\t\tq_data_dst->fourcc);\n\t} else {\n\t\tcodec = coda_find_codec(ctx->dev, V4L2_PIX_FMT_YUV420,\n\t\t\t\t\tfsize->pixel_format);\n\t}\n\tif (!codec)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\tfsize->stepwise.min_width = MIN_W;\n\tfsize->stepwise.max_width = codec->max_w;\n\tfsize->stepwise.step_width = 1;\n\tfsize->stepwise.min_height = MIN_H;\n\tfsize->stepwise.max_height = codec->max_h;\n\tfsize->stepwise.step_height = 1;\n\n\treturn 0;\n}\n\nstatic int coda_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t    struct v4l2_frmivalenum *f)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(fh);\n\tstruct coda_q_data *q_data;\n\tconst struct coda_codec *codec;\n\n\tif (f->index)\n\t\treturn -EINVAL;\n\n\t \n\tif (!ctx->vdoa && f->pixel_format == V4L2_PIX_FMT_YUYV)\n\t\treturn -EINVAL;\n\n\tif (coda_format_normalize_yuv(f->pixel_format) == V4L2_PIX_FMT_YUV420) {\n\t\tq_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\tcodec = coda_find_codec(ctx->dev, f->pixel_format,\n\t\t\t\t\tq_data->fourcc);\n\t} else {\n\t\tcodec = coda_find_codec(ctx->dev, V4L2_PIX_FMT_YUV420,\n\t\t\t\t\tf->pixel_format);\n\t}\n\tif (!codec)\n\t\treturn -EINVAL;\n\n\tif (f->width < MIN_W || f->width > codec->max_w ||\n\t    f->height < MIN_H || f->height > codec->max_h)\n\t\treturn -EINVAL;\n\n\tf->type = V4L2_FRMIVAL_TYPE_CONTINUOUS;\n\tf->stepwise.min.numerator = 1;\n\tf->stepwise.min.denominator = 65535;\n\tf->stepwise.max.numerator = 65536;\n\tf->stepwise.max.denominator = 1;\n\tf->stepwise.step.numerator = 1;\n\tf->stepwise.step.denominator = 1;\n\n\treturn 0;\n}\n\nstatic int coda_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(fh);\n\tstruct v4l2_fract *tpf;\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\ta->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\n\ttpf = &a->parm.output.timeperframe;\n\ttpf->denominator = ctx->params.framerate & CODA_FRATE_RES_MASK;\n\ttpf->numerator = 1 + (ctx->params.framerate >>\n\t\t\t      CODA_FRATE_DIV_OFFSET);\n\n\treturn 0;\n}\n\n \nstatic void coda_approximate_timeperframe(struct v4l2_fract *timeperframe)\n{\n\tstruct v4l2_fract s = *timeperframe;\n\tstruct v4l2_fract f0;\n\tstruct v4l2_fract f1 = { 1, 0 };\n\tstruct v4l2_fract f2 = { 0, 1 };\n\tunsigned int i, div, s_denominator;\n\n\t \n\tif (s.numerator == 0 || s.denominator / s.numerator > 65535) {\n\t\ttimeperframe->numerator = 1;\n\t\ttimeperframe->denominator = 65535;\n\t\treturn;\n\t}\n\n\t \n\tif (s.denominator == 0 || s.numerator / s.denominator > 65536) {\n\t\ttimeperframe->numerator = 65536;\n\t\ttimeperframe->denominator = 1;\n\t\treturn;\n\t}\n\n\t \n\tdiv = gcd(s.numerator, s.denominator);\n\tif (div > 1) {\n\t\ts.numerator /= div;\n\t\ts.denominator /= div;\n\t}\n\n\tif (s.numerator <= 65536 && s.denominator < 65536) {\n\t\t*timeperframe = s;\n\t\treturn;\n\t}\n\n\t \n\twhile (f2.numerator <= 65536 && f2.denominator < 65536) {\n\t\tf0 = f1;\n\t\tf1 = f2;\n\n\t\t \n\t\tif (s.numerator == 0)\n\t\t\tbreak;\n\n\t\ti = s.denominator / s.numerator;\n\n\t\tf2.numerator = f0.numerator + i * f1.numerator;\n\t\tf2.denominator = f0.denominator + i * f2.denominator;\n\n\t\ts_denominator = s.numerator;\n\t\ts.numerator = s.denominator % s.numerator;\n\t\ts.denominator = s_denominator;\n\t}\n\n\t*timeperframe = f1;\n}\n\nstatic uint32_t coda_timeperframe_to_frate(struct v4l2_fract *timeperframe)\n{\n\treturn ((timeperframe->numerator - 1) << CODA_FRATE_DIV_OFFSET) |\n\t\ttimeperframe->denominator;\n}\n\nstatic int coda_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(fh);\n\tstruct v4l2_fract *tpf;\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\ta->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\n\ttpf = &a->parm.output.timeperframe;\n\tcoda_approximate_timeperframe(tpf);\n\tctx->params.framerate = coda_timeperframe_to_frate(tpf);\n\tctx->params.framerate_changed = true;\n\n\treturn 0;\n}\n\nstatic int coda_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\tconst struct v4l2_event_subscription *sub)\n{\n\tstruct coda_ctx *ctx = fh_to_ctx(fh);\n\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_EOS:\n\t\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n\tcase V4L2_EVENT_SOURCE_CHANGE:\n\t\tif (ctx->inst_type == CODA_INST_DECODER)\n\t\t\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n\t\telse\n\t\t\treturn -EINVAL;\n\tdefault:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\t}\n}\n\nstatic const struct v4l2_ioctl_ops coda_ioctl_ops = {\n\t.vidioc_querycap\t= coda_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = coda_enum_fmt,\n\t.vidioc_g_fmt_vid_cap\t= coda_g_fmt,\n\t.vidioc_try_fmt_vid_cap\t= coda_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t= coda_s_fmt_vid_cap,\n\n\t.vidioc_enum_fmt_vid_out = coda_enum_fmt,\n\t.vidioc_g_fmt_vid_out\t= coda_g_fmt,\n\t.vidioc_try_fmt_vid_out\t= coda_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out\t= coda_s_fmt_vid_out,\n\n\t.vidioc_reqbufs\t\t= coda_reqbufs,\n\t.vidioc_querybuf\t= v4l2_m2m_ioctl_querybuf,\n\n\t.vidioc_qbuf\t\t= coda_qbuf,\n\t.vidioc_expbuf\t\t= v4l2_m2m_ioctl_expbuf,\n\t.vidioc_dqbuf\t\t= coda_dqbuf,\n\t.vidioc_create_bufs\t= v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_prepare_buf\t= v4l2_m2m_ioctl_prepare_buf,\n\n\t.vidioc_streamon\t= v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff\t= v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_g_selection\t= coda_g_selection,\n\t.vidioc_s_selection\t= coda_s_selection,\n\n\t.vidioc_try_encoder_cmd\t= v4l2_m2m_ioctl_try_encoder_cmd,\n\t.vidioc_encoder_cmd\t= coda_encoder_cmd,\n\t.vidioc_try_decoder_cmd\t= v4l2_m2m_ioctl_try_decoder_cmd,\n\t.vidioc_decoder_cmd\t= coda_decoder_cmd,\n\n\t.vidioc_g_parm\t\t= coda_g_parm,\n\t.vidioc_s_parm\t\t= coda_s_parm,\n\n\t.vidioc_enum_framesizes\t= coda_enum_framesizes,\n\t.vidioc_enum_frameintervals = coda_enum_frameintervals,\n\n\t.vidioc_subscribe_event = coda_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n \n\nstatic void coda_device_run(void *m2m_priv)\n{\n\tstruct coda_ctx *ctx = m2m_priv;\n\tstruct coda_dev *dev = ctx->dev;\n\n\tqueue_work(dev->workqueue, &ctx->pic_run_work);\n}\n\nstatic void coda_pic_run_work(struct work_struct *work)\n{\n\tstruct coda_ctx *ctx = container_of(work, struct coda_ctx, pic_run_work);\n\tstruct coda_dev *dev = ctx->dev;\n\tint ret;\n\n\tmutex_lock(&ctx->buffer_mutex);\n\tmutex_lock(&dev->coda_mutex);\n\n\tret = ctx->ops->prepare_run(ctx);\n\tif (ret < 0 && ctx->inst_type == CODA_INST_DECODER)\n\t\tgoto out;\n\n\tif (!wait_for_completion_timeout(&ctx->completion,\n\t\t\t\t\t msecs_to_jiffies(1000))) {\n\t\tif (ctx->use_bit) {\n\t\t\tdev_err(dev->dev, \"CODA PIC_RUN timeout\\n\");\n\n\t\t\tctx->hold = true;\n\n\t\t\tcoda_hw_reset(ctx);\n\t\t}\n\n\t\tif (ctx->ops->run_timeout)\n\t\t\tctx->ops->run_timeout(ctx);\n\t} else {\n\t\tctx->ops->finish_run(ctx);\n\t}\n\n\tif ((ctx->aborting || (!ctx->streamon_cap && !ctx->streamon_out)) &&\n\t    ctx->ops->seq_end_work)\n\t\tqueue_work(dev->workqueue, &ctx->seq_end_work);\n\nout:\n\tmutex_unlock(&dev->coda_mutex);\n\tmutex_unlock(&ctx->buffer_mutex);\n\n\tv4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);\n}\n\nstatic int coda_job_ready(void *m2m_priv)\n{\n\tstruct coda_ctx *ctx = m2m_priv;\n\tint src_bufs = v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx);\n\n\t \n\tif (!src_bufs && ctx->inst_type != CODA_INST_DECODER) {\n\t\tcoda_dbg(1, ctx, \"not ready: not enough vid-out buffers.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx)) {\n\t\tcoda_dbg(1, ctx, \"not ready: not enough vid-cap buffers.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (ctx->inst_type == CODA_INST_DECODER && ctx->use_bit) {\n\t\tbool stream_end = ctx->bit_stream_param &\n\t\t\t\t  CODA_BIT_STREAM_END_FLAG;\n\t\tint num_metas = ctx->num_metas;\n\t\tstruct coda_buffer_meta *meta;\n\t\tunsigned int count;\n\n\t\tcount = hweight32(ctx->frm_dis_flg);\n\t\tif (ctx->use_vdoa && count >= (ctx->num_internal_frames - 1)) {\n\t\t\tcoda_dbg(1, ctx,\n\t\t\t\t \"not ready: all internal buffers in use: %d/%d (0x%x)\",\n\t\t\t\t count, ctx->num_internal_frames,\n\t\t\t\t ctx->frm_dis_flg);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (ctx->hold && !src_bufs) {\n\t\t\tcoda_dbg(1, ctx,\n\t\t\t\t \"not ready: on hold for more buffers.\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!stream_end && (num_metas + src_bufs) < 2) {\n\t\t\tcoda_dbg(1, ctx,\n\t\t\t\t \"not ready: need 2 buffers available (queue:%d + bitstream:%d)\\n\",\n\t\t\t\t num_metas, src_bufs);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmeta = list_first_entry(&ctx->buffer_meta_list,\n\t\t\t\t\tstruct coda_buffer_meta, list);\n\t\tif (!coda_bitstream_can_fetch_past(ctx, meta->end) &&\n\t\t    !stream_end) {\n\t\t\tcoda_dbg(1, ctx,\n\t\t\t\t \"not ready: not enough bitstream data to read past %u (%u)\\n\",\n\t\t\t\t meta->end, ctx->bitstream_fifo.kfifo.in);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (ctx->aborting) {\n\t\tcoda_dbg(1, ctx, \"not ready: aborting\\n\");\n\t\treturn 0;\n\t}\n\n\tcoda_dbg(2, ctx, \"job ready\\n\");\n\n\treturn 1;\n}\n\nstatic void coda_job_abort(void *priv)\n{\n\tstruct coda_ctx *ctx = priv;\n\n\tctx->aborting = 1;\n\n\tcoda_dbg(1, ctx, \"job abort\\n\");\n}\n\nstatic const struct v4l2_m2m_ops coda_m2m_ops = {\n\t.device_run\t= coda_device_run,\n\t.job_ready\t= coda_job_ready,\n\t.job_abort\t= coda_job_abort,\n};\n\nstatic void set_default_params(struct coda_ctx *ctx)\n{\n\tunsigned int max_w, max_h, usize, csize;\n\n\tctx->codec = coda_find_codec(ctx->dev, ctx->cvd->src_formats[0],\n\t\t\t\t     ctx->cvd->dst_formats[0]);\n\tmax_w = min(ctx->codec->max_w, 1920U);\n\tmax_h = min(ctx->codec->max_h, 1088U);\n\tusize = max_w * max_h * 3 / 2;\n\tcsize = coda_estimate_sizeimage(ctx, usize, max_w, max_h);\n\n\tctx->params.codec_mode = ctx->codec->mode;\n\tif (ctx->cvd->src_formats[0] == V4L2_PIX_FMT_JPEG ||\n\t    ctx->cvd->dst_formats[0] == V4L2_PIX_FMT_JPEG) {\n\t\tctx->colorspace = V4L2_COLORSPACE_SRGB;\n\t\tctx->xfer_func = V4L2_XFER_FUNC_SRGB;\n\t\tctx->ycbcr_enc = V4L2_YCBCR_ENC_601;\n\t\tctx->quantization = V4L2_QUANTIZATION_FULL_RANGE;\n\t} else {\n\t\tctx->colorspace = V4L2_COLORSPACE_REC709;\n\t\tctx->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\t\tctx->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\t\tctx->quantization = V4L2_QUANTIZATION_DEFAULT;\n\t}\n\tctx->params.framerate = 30;\n\n\t \n\tctx->q_data[V4L2_M2M_SRC].fourcc = ctx->cvd->src_formats[0];\n\tctx->q_data[V4L2_M2M_DST].fourcc = ctx->cvd->dst_formats[0];\n\tctx->q_data[V4L2_M2M_SRC].width = max_w;\n\tctx->q_data[V4L2_M2M_SRC].height = max_h;\n\tctx->q_data[V4L2_M2M_DST].width = max_w;\n\tctx->q_data[V4L2_M2M_DST].height = max_h;\n\tif (ctx->codec->src_fourcc == V4L2_PIX_FMT_YUV420) {\n\t\tctx->q_data[V4L2_M2M_SRC].bytesperline = max_w;\n\t\tctx->q_data[V4L2_M2M_SRC].sizeimage = usize;\n\t\tctx->q_data[V4L2_M2M_DST].bytesperline = 0;\n\t\tctx->q_data[V4L2_M2M_DST].sizeimage = csize;\n\t} else {\n\t\tctx->q_data[V4L2_M2M_SRC].bytesperline = 0;\n\t\tctx->q_data[V4L2_M2M_SRC].sizeimage = csize;\n\t\tctx->q_data[V4L2_M2M_DST].bytesperline = max_w;\n\t\tctx->q_data[V4L2_M2M_DST].sizeimage = usize;\n\t}\n\tctx->q_data[V4L2_M2M_SRC].rect.width = max_w;\n\tctx->q_data[V4L2_M2M_SRC].rect.height = max_h;\n\tctx->q_data[V4L2_M2M_DST].rect.width = max_w;\n\tctx->q_data[V4L2_M2M_DST].rect.height = max_h;\n\n\t \n\tctx->tiled_map_type = GDI_LINEAR_FRAME_MAP;\n}\n\n \nstatic int coda_queue_setup(struct vb2_queue *vq,\n\t\t\t\tunsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t\tunsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct coda_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct coda_q_data *q_data;\n\tunsigned int size;\n\n\tq_data = get_q_data(ctx, vq->type);\n\tsize = q_data->sizeimage;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\tcoda_dbg(1, ctx, \"get %d buffer(s) of size %d each.\\n\", *nbuffers,\n\t\t size);\n\n\treturn 0;\n}\n\nstatic int coda_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct coda_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct coda_q_data *q_data;\n\n\tq_data = get_q_data(ctx, vb->vb2_queue->type);\n\tif (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\n\t\tif (vbuf->field == V4L2_FIELD_ANY)\n\t\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tif (vbuf->field != V4L2_FIELD_NONE) {\n\t\t\tv4l2_warn(&ctx->dev->v4l2_dev,\n\t\t\t\t  \"%s field isn't supported\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (vb2_plane_size(vb, 0) < q_data->sizeimage) {\n\t\tv4l2_warn(&ctx->dev->v4l2_dev,\n\t\t\t  \"%s data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t  __func__, vb2_plane_size(vb, 0),\n\t\t\t  (long)q_data->sizeimage);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void coda_update_menu_ctrl(struct v4l2_ctrl *ctrl, int value)\n{\n\tif (!ctrl)\n\t\treturn;\n\n\tv4l2_ctrl_lock(ctrl);\n\n\t \n\tif (value > ctrl->maximum) {\n\t\t__v4l2_ctrl_modify_range(ctrl, ctrl->minimum, value,\n\t\t\tctrl->menu_skip_mask & ~(1 << value),\n\t\t\tctrl->default_value);\n\t} else if (value < ctrl->minimum) {\n\t\t__v4l2_ctrl_modify_range(ctrl, value, ctrl->maximum,\n\t\t\tctrl->menu_skip_mask & ~(1 << value),\n\t\t\tctrl->default_value);\n\t}\n\n\t__v4l2_ctrl_s_ctrl(ctrl, value);\n\n\tv4l2_ctrl_unlock(ctrl);\n}\n\nvoid coda_update_profile_level_ctrls(struct coda_ctx *ctx, u8 profile_idc,\n\t\t\t\t     u8 level_idc)\n{\n\tconst char * const *profile_names;\n\tconst char * const *level_names;\n\tstruct v4l2_ctrl *profile_ctrl;\n\tstruct v4l2_ctrl *level_ctrl;\n\tconst char *codec_name;\n\tu32 profile_cid;\n\tu32 level_cid;\n\tint profile;\n\tint level;\n\n\tswitch (ctx->codec->src_fourcc) {\n\tcase V4L2_PIX_FMT_H264:\n\t\tcodec_name = \"H264\";\n\t\tprofile_cid = V4L2_CID_MPEG_VIDEO_H264_PROFILE;\n\t\tlevel_cid = V4L2_CID_MPEG_VIDEO_H264_LEVEL;\n\t\tprofile_ctrl = ctx->h264_profile_ctrl;\n\t\tlevel_ctrl = ctx->h264_level_ctrl;\n\t\tprofile = coda_h264_profile(profile_idc);\n\t\tlevel = coda_h264_level(level_idc);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG2:\n\t\tcodec_name = \"MPEG-2\";\n\t\tprofile_cid = V4L2_CID_MPEG_VIDEO_MPEG2_PROFILE;\n\t\tlevel_cid = V4L2_CID_MPEG_VIDEO_MPEG2_LEVEL;\n\t\tprofile_ctrl = ctx->mpeg2_profile_ctrl;\n\t\tlevel_ctrl = ctx->mpeg2_level_ctrl;\n\t\tprofile = coda_mpeg2_profile(profile_idc);\n\t\tlevel = coda_mpeg2_level(level_idc);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG4:\n\t\tcodec_name = \"MPEG-4\";\n\t\tprofile_cid = V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE;\n\t\tlevel_cid = V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL;\n\t\tprofile_ctrl = ctx->mpeg4_profile_ctrl;\n\t\tlevel_ctrl = ctx->mpeg4_level_ctrl;\n\t\tprofile = coda_mpeg4_profile(profile_idc);\n\t\tlevel = coda_mpeg4_level(level_idc);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tprofile_names = v4l2_ctrl_get_menu(profile_cid);\n\tlevel_names = v4l2_ctrl_get_menu(level_cid);\n\n\tif (profile < 0) {\n\t\tv4l2_warn(&ctx->dev->v4l2_dev, \"Invalid %s profile: %u\\n\",\n\t\t\t  codec_name, profile_idc);\n\t} else {\n\t\tcoda_dbg(1, ctx, \"Parsed %s profile: %s\\n\", codec_name,\n\t\t\t profile_names[profile]);\n\t\tcoda_update_menu_ctrl(profile_ctrl, profile);\n\t}\n\n\tif (level < 0) {\n\t\tv4l2_warn(&ctx->dev->v4l2_dev, \"Invalid %s level: %u\\n\",\n\t\t\t  codec_name, level_idc);\n\t} else {\n\t\tcoda_dbg(1, ctx, \"Parsed %s level: %s\\n\", codec_name,\n\t\t\t level_names[level]);\n\t\tcoda_update_menu_ctrl(level_ctrl, level);\n\t}\n}\n\nstatic void coda_queue_source_change_event(struct coda_ctx *ctx)\n{\n\tstatic const struct v4l2_event source_change_event = {\n\t\t.type = V4L2_EVENT_SOURCE_CHANGE,\n\t\t.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\n\t};\n\n\tv4l2_event_queue_fh(&ctx->fh, &source_change_event);\n}\n\nstatic void coda_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct coda_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct coda_q_data *q_data;\n\n\tq_data = get_q_data(ctx, vb->vb2_queue->type);\n\n\t \n\tif (ctx->bitstream.size && vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\t \n\t\tif (vb2_get_plane_payload(vb, 0) == 0)\n\t\t\tcoda_bit_stream_end_flag(ctx);\n\n\t\tif (q_data->fourcc == V4L2_PIX_FMT_H264) {\n\t\t\t \n\t\t\tif (!ctx->params.h264_profile_idc) {\n\t\t\t\tcoda_sps_parse_profile(ctx, vb);\n\t\t\t\tcoda_update_profile_level_ctrls(ctx,\n\t\t\t\t\t\tctx->params.h264_profile_idc,\n\t\t\t\t\t\tctx->params.h264_level_idc);\n\t\t\t}\n\t\t}\n\n\t\tmutex_lock(&ctx->bitstream_mutex);\n\t\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n\t\tif (vb2_is_streaming(vb->vb2_queue))\n\t\t\t \n\t\t\tcoda_fill_bitstream(ctx, NULL);\n\t\tmutex_unlock(&ctx->bitstream_mutex);\n\n\t\tif (!ctx->initialized) {\n\t\t\t \n\t\t\tif (vb2_is_streaming(vb->vb2_queue) &&\n\t\t\t    ctx->ops->seq_init_work) {\n\t\t\t\tqueue_work(ctx->dev->workqueue,\n\t\t\t\t\t   &ctx->seq_init_work);\n\t\t\t\tflush_work(&ctx->seq_init_work);\n\t\t\t}\n\n\t\t\tif (ctx->initialized)\n\t\t\t\tcoda_queue_source_change_event(ctx);\n\t\t}\n\t} else {\n\t\tif ((ctx->inst_type == CODA_INST_ENCODER || !ctx->use_bit) &&\n\t\t    vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\tvbuf->sequence = ctx->qsequence++;\n\t\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n\t}\n}\n\nint coda_alloc_aux_buf(struct coda_dev *dev, struct coda_aux_buf *buf,\n\t\t       size_t size, const char *name, struct dentry *parent)\n{\n\tbuf->vaddr = dma_alloc_coherent(dev->dev, size, &buf->paddr,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!buf->vaddr) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Failed to allocate %s buffer of size %zu\\n\",\n\t\t\t name, size);\n\t\treturn -ENOMEM;\n\t}\n\n\tbuf->size = size;\n\n\tif (name && parent) {\n\t\tbuf->blob.data = buf->vaddr;\n\t\tbuf->blob.size = size;\n\t\tbuf->dentry = debugfs_create_blob(name, 0444, parent,\n\t\t\t\t\t\t  &buf->blob);\n\t}\n\n\treturn 0;\n}\n\nvoid coda_free_aux_buf(struct coda_dev *dev,\n\t\t       struct coda_aux_buf *buf)\n{\n\tif (buf->vaddr) {\n\t\tdma_free_coherent(dev->dev, buf->size, buf->vaddr, buf->paddr);\n\t\tbuf->vaddr = NULL;\n\t\tbuf->size = 0;\n\t\tdebugfs_remove(buf->dentry);\n\t\tbuf->dentry = NULL;\n\t}\n}\n\nstatic int coda_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct coda_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct v4l2_device *v4l2_dev = &ctx->dev->v4l2_dev;\n\tstruct coda_q_data *q_data_src, *q_data_dst;\n\tstruct v4l2_m2m_buffer *m2m_buf, *tmp;\n\tstruct vb2_v4l2_buffer *buf;\n\tstruct list_head list;\n\tint ret = 0;\n\n\tif (count < 1)\n\t\treturn -EINVAL;\n\n\tcoda_dbg(1, ctx, \"start streaming %s\\n\", v4l2_type_names[q->type]);\n\n\tINIT_LIST_HEAD(&list);\n\n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tif (ctx->inst_type == CODA_INST_DECODER && ctx->use_bit) {\n\t\t\t \n\t\t\tmutex_lock(&ctx->bitstream_mutex);\n\t\t\tcoda_fill_bitstream(ctx, &list);\n\t\t\tmutex_unlock(&ctx->bitstream_mutex);\n\n\t\t\tif (ctx->dev->devtype->product != CODA_960 &&\n\t\t\t    coda_get_bitstream_payload(ctx) < 512) {\n\t\t\t\tv4l2_err(v4l2_dev, \"start payload < 512\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (!ctx->initialized) {\n\t\t\t\t \n\t\t\t\tif (ctx->ops->seq_init_work) {\n\t\t\t\t\tqueue_work(ctx->dev->workqueue,\n\t\t\t\t\t\t   &ctx->seq_init_work);\n\t\t\t\t\tflush_work(&ctx->seq_init_work);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (q_data_src->fourcc == V4L2_PIX_FMT_JPEG) {\n\t\t\tbuf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\t\t\tcoda_jpeg_decode_header(ctx, &buf->vb2_buf);\n\t\t\t \n\n\t\t\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\t\tq_data_dst->width = round_up(q_data_src->width, 16);\n\t\t\tq_data_dst->height = round_up(q_data_src->height, 16);\n\t\t\tq_data_dst->bytesperline = q_data_dst->width;\n\t\t\tif (ctx->params.jpeg_chroma_subsampling ==\n\t\t\t    V4L2_JPEG_CHROMA_SUBSAMPLING_420) {\n\t\t\t\tq_data_dst->sizeimage =\n\t\t\t\t\t\tq_data_dst->bytesperline *\n\t\t\t\t\t\tq_data_dst->height * 3 / 2;\n\t\t\t\tif (q_data_dst->fourcc != V4L2_PIX_FMT_YUV420)\n\t\t\t\t\tq_data_dst->fourcc = V4L2_PIX_FMT_NV12;\n\t\t\t} else {\n\t\t\t\tq_data_dst->sizeimage =\n\t\t\t\t\t\tq_data_dst->bytesperline *\n\t\t\t\t\t\tq_data_dst->height * 2;\n\t\t\t\tq_data_dst->fourcc = V4L2_PIX_FMT_YUV422P;\n\t\t\t}\n\t\t\tq_data_dst->rect.left = 0;\n\t\t\tq_data_dst->rect.top = 0;\n\t\t\tq_data_dst->rect.width = q_data_src->width;\n\t\t\tq_data_dst->rect.height = q_data_src->height;\n\t\t}\n\t\tctx->streamon_out = 1;\n\t} else {\n\t\tctx->streamon_cap = 1;\n\t}\n\n\t \n\tif (!(ctx->streamon_out && ctx->streamon_cap))\n\t\tgoto out;\n\n\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tif ((q_data_src->rect.width != q_data_dst->width &&\n\t     round_up(q_data_src->rect.width, 16) != q_data_dst->width) ||\n\t    (q_data_src->rect.height != q_data_dst->height &&\n\t     round_up(q_data_src->rect.height, 16) != q_data_dst->height)) {\n\t\tv4l2_err(v4l2_dev, \"can't convert %dx%d to %dx%d\\n\",\n\t\t\t q_data_src->rect.width, q_data_src->rect.height,\n\t\t\t q_data_dst->width, q_data_dst->height);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif (ctx->inst_type == CODA_INST_DECODER && ctx->use_bit)\n\t\tv4l2_m2m_set_src_buffered(ctx->fh.m2m_ctx, true);\n\n\tctx->gopcounter = ctx->params.gop_size - 1;\n\n\tif (q_data_dst->fourcc == V4L2_PIX_FMT_JPEG)\n\t\tctx->params.gop_size = 1;\n\tctx->gopcounter = ctx->params.gop_size - 1;\n\t \n\tif (ctx->mb_err_cnt_ctrl)\n\t\tv4l2_ctrl_s_ctrl(ctx->mb_err_cnt_ctrl, 0);\n\n\tret = ctx->ops->start_streaming(ctx);\n\tif (ctx->inst_type == CODA_INST_DECODER) {\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto out;\n\t}\n\tif (ret < 0)\n\t\tgoto err;\n\nout:\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tlist_for_each_entry_safe(m2m_buf, tmp, &list, list) {\n\t\t\tlist_del(&m2m_buf->list);\n\t\t\tv4l2_m2m_buf_done(&m2m_buf->vb, VB2_BUF_STATE_DONE);\n\t\t}\n\t}\n\treturn 0;\n\nerr:\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tlist_for_each_entry_safe(m2m_buf, tmp, &list, list) {\n\t\t\tlist_del(&m2m_buf->list);\n\t\t\tv4l2_m2m_buf_done(&m2m_buf->vb, VB2_BUF_STATE_QUEUED);\n\t\t}\n\t\twhile ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);\n\t} else {\n\t\twhile ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);\n\t}\n\treturn ret;\n}\n\nstatic void coda_stop_streaming(struct vb2_queue *q)\n{\n\tstruct coda_ctx *ctx = vb2_get_drv_priv(q);\n\tstruct coda_dev *dev = ctx->dev;\n\tstruct vb2_v4l2_buffer *buf;\n\tbool stop;\n\n\tstop = ctx->streamon_out && ctx->streamon_cap;\n\n\tcoda_dbg(1, ctx, \"stop streaming %s\\n\", v4l2_type_names[q->type]);\n\n\tif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\n\t\tctx->streamon_out = 0;\n\n\t\tcoda_bit_stream_end_flag(ctx);\n\n\t\tctx->qsequence = 0;\n\n\t\twhile ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);\n\t} else {\n\t\tctx->streamon_cap = 0;\n\n\t\tctx->osequence = 0;\n\t\tctx->sequence_offset = 0;\n\n\t\twhile ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);\n\t}\n\n\tif (stop) {\n\t\tstruct coda_buffer_meta *meta;\n\n\t\tif (ctx->ops->seq_end_work) {\n\t\t\tqueue_work(dev->workqueue, &ctx->seq_end_work);\n\t\t\tflush_work(&ctx->seq_end_work);\n\t\t}\n\t\tspin_lock(&ctx->buffer_meta_lock);\n\t\twhile (!list_empty(&ctx->buffer_meta_list)) {\n\t\t\tmeta = list_first_entry(&ctx->buffer_meta_list,\n\t\t\t\t\t\tstruct coda_buffer_meta, list);\n\t\t\tlist_del(&meta->list);\n\t\t\tkfree(meta);\n\t\t}\n\t\tctx->num_metas = 0;\n\t\tspin_unlock(&ctx->buffer_meta_lock);\n\t\tkfifo_init(&ctx->bitstream_fifo,\n\t\t\tctx->bitstream.vaddr, ctx->bitstream.size);\n\t\tctx->runcounter = 0;\n\t\tctx->aborting = 0;\n\t\tctx->hold = false;\n\t}\n\n\tif (!ctx->streamon_out && !ctx->streamon_cap)\n\t\tctx->bit_stream_param &= ~CODA_BIT_STREAM_END_FLAG;\n}\n\nstatic const struct vb2_ops coda_qops = {\n\t.queue_setup\t\t= coda_queue_setup,\n\t.buf_prepare\t\t= coda_buf_prepare,\n\t.buf_queue\t\t= coda_buf_queue,\n\t.start_streaming\t= coda_start_streaming,\n\t.stop_streaming\t\t= coda_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic int coda_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tconst char * const *val_names = v4l2_ctrl_get_menu(ctrl->id);\n\tstruct coda_ctx *ctx =\n\t\t\tcontainer_of(ctrl->handler, struct coda_ctx, ctrls);\n\n\tif (val_names)\n\t\tcoda_dbg(2, ctx, \"s_ctrl: id = 0x%x, name = \\\"%s\\\", val = %d (\\\"%s\\\")\\n\",\n\t\t\t ctrl->id, ctrl->name, ctrl->val, val_names[ctrl->val]);\n\telse\n\t\tcoda_dbg(2, ctx, \"s_ctrl: id = 0x%x, name = \\\"%s\\\", val = %d\\n\",\n\t\t\t ctrl->id, ctrl->name, ctrl->val);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tif (ctrl->val)\n\t\t\tctx->params.rot_mode |= CODA_MIR_HOR;\n\t\telse\n\t\t\tctx->params.rot_mode &= ~CODA_MIR_HOR;\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tif (ctrl->val)\n\t\t\tctx->params.rot_mode |= CODA_MIR_VER;\n\t\telse\n\t\t\tctx->params.rot_mode &= ~CODA_MIR_VER;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE:\n\t\tctx->params.bitrate = ctrl->val / 1000;\n\t\tctx->params.bitrate_changed = true;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\n\t\tctx->params.gop_size = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP:\n\t\tctx->params.h264_intra_qp = ctrl->val;\n\t\tctx->params.h264_intra_qp_changed = true;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP:\n\t\tctx->params.h264_inter_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_MIN_QP:\n\t\tctx->params.h264_min_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_MAX_QP:\n\t\tctx->params.h264_max_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA:\n\t\tctx->params.h264_slice_alpha_c0_offset_div2 = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA:\n\t\tctx->params.h264_slice_beta_offset_div2 = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE:\n\t\tctx->params.h264_disable_deblocking_filter_idc = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_CONSTRAINED_INTRA_PREDICTION:\n\t\tctx->params.h264_constrained_intra_pred_flag = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:\n\t\tctx->params.frame_rc_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE:\n\t\tctx->params.mb_rc_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_CHROMA_QP_INDEX_OFFSET:\n\t\tctx->params.h264_chroma_qp_index_offset = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_PROFILE:\n\t\t \n\t\tif (ctx->inst_type == CODA_INST_ENCODER)\n\t\t\tctx->params.h264_profile_idc = 66;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_LEVEL:\n\t\t \n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP:\n\t\tctx->params.mpeg4_intra_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP:\n\t\tctx->params.mpeg4_inter_qp = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MPEG2_PROFILE:\n\tcase V4L2_CID_MPEG_VIDEO_MPEG2_LEVEL:\n\tcase V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE:\n\tcase V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL:\n\t\t \n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:\n\t\tctx->params.slice_mode = ctrl->val;\n\t\tctx->params.slice_mode_changed = true;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB:\n\t\tctx->params.slice_max_mb = ctrl->val;\n\t\tctx->params.slice_mode_changed = true;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES:\n\t\tctx->params.slice_max_bits = ctrl->val * 8;\n\t\tctx->params.slice_mode_changed = true;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_HEADER_MODE:\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB:\n\t\tctx->params.intra_refresh = ctrl->val;\n\t\tctx->params.intra_refresh_changed = true;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME:\n\t\tctx->params.force_ipicture = true;\n\t\tbreak;\n\tcase V4L2_CID_JPEG_COMPRESSION_QUALITY:\n\t\tcoda_set_jpeg_compression_quality(ctx, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_JPEG_RESTART_INTERVAL:\n\t\tctx->params.jpeg_restart_interval = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VBV_DELAY:\n\t\tctx->params.vbv_delay = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_VBV_SIZE:\n\t\tctx->params.vbv_size = min(ctrl->val * 8192, 0x7fffffff);\n\t\tbreak;\n\tdefault:\n\t\tcoda_dbg(1, ctx, \"Invalid control, id=%d, val=%d\\n\",\n\t\t\t ctrl->id, ctrl->val);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops coda_ctrl_ops = {\n\t.s_ctrl = coda_s_ctrl,\n};\n\nstatic void coda_encode_ctrls(struct coda_ctx *ctx)\n{\n\tint max_gop_size = (ctx->dev->devtype->product == CODA_DX6) ? 60 : 99;\n\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_BITRATE, 0, 32767000, 1000, 0);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_GOP_SIZE, 0, max_gop_size, 1, 16);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP, 0, 51, 1, 25);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP, 0, 51, 1, 25);\n\tif (ctx->dev->devtype->product != CODA_960) {\n\t\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_H264_MIN_QP, 0, 51, 1, 12);\n\t}\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_H264_MAX_QP, 0, 51, 1, 51);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA, -6, 6, 1, 0);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA, -6, 6, 1, 0);\n\tv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE,\n\t\tV4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY,\n\t\t0x0, V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_H264_CONSTRAINED_INTRA_PREDICTION, 0, 1, 1,\n\t\t0);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE, 0, 1, 1, 1);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_MB_RC_ENABLE, 0, 1, 1, 1);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_H264_CHROMA_QP_INDEX_OFFSET, -12, 12, 1, 0);\n\tv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_H264_PROFILE,\n\t\tV4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE, 0x0,\n\t\tV4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE);\n\tif (ctx->dev->devtype->product == CODA_HX4 ||\n\t    ctx->dev->devtype->product == CODA_7541) {\n\t\tv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_H264_LEVEL,\n\t\t\tV4L2_MPEG_VIDEO_H264_LEVEL_3_1,\n\t\t\t~((1 << V4L2_MPEG_VIDEO_H264_LEVEL_2_0) |\n\t\t\t  (1 << V4L2_MPEG_VIDEO_H264_LEVEL_3_0) |\n\t\t\t  (1 << V4L2_MPEG_VIDEO_H264_LEVEL_3_1)),\n\t\t\tV4L2_MPEG_VIDEO_H264_LEVEL_3_1);\n\t}\n\tif (ctx->dev->devtype->product == CODA_960) {\n\t\tv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_H264_LEVEL,\n\t\t\tV4L2_MPEG_VIDEO_H264_LEVEL_4_2,\n\t\t\t~((1 << V4L2_MPEG_VIDEO_H264_LEVEL_1_0) |\n\t\t\t  (1 << V4L2_MPEG_VIDEO_H264_LEVEL_2_0) |\n\t\t\t  (1 << V4L2_MPEG_VIDEO_H264_LEVEL_3_0) |\n\t\t\t  (1 << V4L2_MPEG_VIDEO_H264_LEVEL_3_1) |\n\t\t\t  (1 << V4L2_MPEG_VIDEO_H264_LEVEL_3_2) |\n\t\t\t  (1 << V4L2_MPEG_VIDEO_H264_LEVEL_4_0) |\n\t\t\t  (1 << V4L2_MPEG_VIDEO_H264_LEVEL_4_1) |\n\t\t\t  (1 << V4L2_MPEG_VIDEO_H264_LEVEL_4_2)),\n\t\t\tV4L2_MPEG_VIDEO_H264_LEVEL_4_0);\n\t}\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP, 1, 31, 1, 2);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP, 1, 31, 1, 2);\n\tv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_MPEG4_PROFILE,\n\t\tV4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE, 0x0,\n\t\tV4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE);\n\tif (ctx->dev->devtype->product == CODA_HX4 ||\n\t    ctx->dev->devtype->product == CODA_7541 ||\n\t    ctx->dev->devtype->product == CODA_960) {\n\t\tv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_MPEG4_LEVEL,\n\t\t\tV4L2_MPEG_VIDEO_MPEG4_LEVEL_5,\n\t\t\t~(1 << V4L2_MPEG_VIDEO_MPEG4_LEVEL_5),\n\t\t\tV4L2_MPEG_VIDEO_MPEG4_LEVEL_5);\n\t}\n\tv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE,\n\t\tV4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES, 0x0,\n\t\tV4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB, 1, 0x3fffffff, 1, 1);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES, 1, 0x3fffffff, 1,\n\t\t500);\n\tv4l2_ctrl_new_std_menu(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_HEADER_MODE,\n\t\tV4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME,\n\t\t(1 << V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE),\n\t\tV4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB, 0,\n\t\t1920 * 1088 / 256, 1, 0);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_VBV_DELAY, 0, 0x7fff, 1, 0);\n\t \n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_MPEG_VIDEO_VBV_SIZE, 0, 262144, 1, 0);\n}\n\nstatic void coda_jpeg_encode_ctrls(struct coda_ctx *ctx)\n{\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_JPEG_COMPRESSION_QUALITY, 5, 100, 1, 50);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_JPEG_RESTART_INTERVAL, 0, 100, 1, 0);\n}\n\nstatic void coda_decode_ctrls(struct coda_ctx *ctx)\n{\n\tu8 max;\n\n\tctx->h264_profile_ctrl = v4l2_ctrl_new_std_menu(&ctx->ctrls,\n\t\t&coda_ctrl_ops, V4L2_CID_MPEG_VIDEO_H264_PROFILE,\n\t\tV4L2_MPEG_VIDEO_H264_PROFILE_HIGH,\n\t\t~((1 << V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE) |\n\t\t  (1 << V4L2_MPEG_VIDEO_H264_PROFILE_MAIN) |\n\t\t  (1 << V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)),\n\t\tV4L2_MPEG_VIDEO_H264_PROFILE_HIGH);\n\tif (ctx->h264_profile_ctrl)\n\t\tctx->h264_profile_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tif (ctx->dev->devtype->product == CODA_HX4 ||\n\t    ctx->dev->devtype->product == CODA_7541)\n\t\tmax = V4L2_MPEG_VIDEO_H264_LEVEL_4_0;\n\telse if (ctx->dev->devtype->product == CODA_960)\n\t\tmax = V4L2_MPEG_VIDEO_H264_LEVEL_4_1;\n\telse\n\t\treturn;\n\tctx->h264_level_ctrl = v4l2_ctrl_new_std_menu(&ctx->ctrls,\n\t\t&coda_ctrl_ops, V4L2_CID_MPEG_VIDEO_H264_LEVEL, max, 0, max);\n\tif (ctx->h264_level_ctrl)\n\t\tctx->h264_level_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tctx->mpeg2_profile_ctrl = v4l2_ctrl_new_std_menu(&ctx->ctrls,\n\t\t&coda_ctrl_ops, V4L2_CID_MPEG_VIDEO_MPEG2_PROFILE,\n\t\tV4L2_MPEG_VIDEO_MPEG2_PROFILE_HIGH, 0,\n\t\tV4L2_MPEG_VIDEO_MPEG2_PROFILE_HIGH);\n\tif (ctx->mpeg2_profile_ctrl)\n\t\tctx->mpeg2_profile_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tctx->mpeg2_level_ctrl = v4l2_ctrl_new_std_menu(&ctx->ctrls,\n\t\t&coda_ctrl_ops, V4L2_CID_MPEG_VIDEO_MPEG2_LEVEL,\n\t\tV4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH, 0,\n\t\tV4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH);\n\tif (ctx->mpeg2_level_ctrl)\n\t\tctx->mpeg2_level_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tctx->mpeg4_profile_ctrl = v4l2_ctrl_new_std_menu(&ctx->ctrls,\n\t\t&coda_ctrl_ops, V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE,\n\t\tV4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_CODING_EFFICIENCY, 0,\n\t\tV4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_CODING_EFFICIENCY);\n\tif (ctx->mpeg4_profile_ctrl)\n\t\tctx->mpeg4_profile_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\n\tctx->mpeg4_level_ctrl = v4l2_ctrl_new_std_menu(&ctx->ctrls,\n\t\t&coda_ctrl_ops, V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL,\n\t\tV4L2_MPEG_VIDEO_MPEG4_LEVEL_5, 0,\n\t\tV4L2_MPEG_VIDEO_MPEG4_LEVEL_5);\n\tif (ctx->mpeg4_level_ctrl)\n\t\tctx->mpeg4_level_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n}\n\nstatic const struct v4l2_ctrl_config coda_mb_err_cnt_ctrl_config = {\n\t.id\t= V4L2_CID_CODA_MB_ERR_CNT,\n\t.name\t= \"Macroblocks Error Count\",\n\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t.min\t= 0,\n\t.max\t= 0x7fffffff,\n\t.step\t= 1,\n};\n\nstatic int coda_ctrls_setup(struct coda_ctx *ctx)\n{\n\tv4l2_ctrl_handler_init(&ctx->ctrls, 2);\n\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_HFLIP, 0, 1, 1, 0);\n\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\tV4L2_CID_VFLIP, 0, 1, 1, 0);\n\tif (ctx->inst_type == CODA_INST_ENCODER) {\n\t\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\t\t\t  V4L2_CID_MIN_BUFFERS_FOR_OUTPUT,\n\t\t\t\t  1, 1, 1, 1);\n\t\tif (ctx->cvd->dst_formats[0] == V4L2_PIX_FMT_JPEG)\n\t\t\tcoda_jpeg_encode_ctrls(ctx);\n\t\telse\n\t\t\tcoda_encode_ctrls(ctx);\n\t} else {\n\t\tv4l2_ctrl_new_std(&ctx->ctrls, &coda_ctrl_ops,\n\t\t\t\t  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE,\n\t\t\t\t  1, 1, 1, 1);\n\t\tif (ctx->cvd->src_formats[0] == V4L2_PIX_FMT_H264)\n\t\t\tcoda_decode_ctrls(ctx);\n\n\t\tctx->mb_err_cnt_ctrl = v4l2_ctrl_new_custom(&ctx->ctrls,\n\t\t\t\t\t\t&coda_mb_err_cnt_ctrl_config,\n\t\t\t\t\t\tNULL);\n\t\tif (ctx->mb_err_cnt_ctrl)\n\t\t\tctx->mb_err_cnt_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\n\t}\n\n\tif (ctx->ctrls.error) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t\"control initialization error (%d)\",\n\t\t\tctx->ctrls.error);\n\t\treturn -EINVAL;\n\t}\n\n\treturn v4l2_ctrl_handler_setup(&ctx->ctrls);\n}\n\nstatic int coda_queue_init(struct coda_ctx *ctx, struct vb2_queue *vq)\n{\n\tvq->drv_priv = ctx;\n\tvq->ops = &coda_qops;\n\tvq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tvq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tvq->lock = &ctx->dev->dev_mutex;\n\t \n\tvq->allow_zero_bytesused = 1;\n\t \n\tvq->min_buffers_needed = 1;\n\tvq->dev = ctx->dev->dev;\n\n\treturn vb2_queue_init(vq);\n}\n\nint coda_encoder_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t    struct vb2_queue *dst_vq)\n{\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_DMABUF | VB2_MMAP;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\n\tret = coda_queue_init(priv, src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_DMABUF | VB2_MMAP;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\n\treturn coda_queue_init(priv, dst_vq);\n}\n\nint coda_decoder_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t    struct vb2_queue *dst_vq)\n{\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_DMABUF | VB2_MMAP | VB2_USERPTR;\n\tsrc_vq->mem_ops = &vb2_vmalloc_memops;\n\n\tret = coda_queue_init(priv, src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_DMABUF | VB2_MMAP;\n\tdst_vq->dma_attrs = DMA_ATTR_NO_KERNEL_MAPPING;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\n\treturn coda_queue_init(priv, dst_vq);\n}\n\n \n\nstatic int coda_open(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct coda_dev *dev = video_get_drvdata(vdev);\n\tstruct coda_ctx *ctx;\n\tunsigned int max = ~0;\n\tchar *name;\n\tint ret;\n\tint idx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (dev->devtype->product == CODA_DX6)\n\t\tmax = CODADX6_MAX_INSTANCES - 1;\n\tidx = ida_alloc_max(&dev->ida, max, GFP_KERNEL);\n\tif (idx < 0) {\n\t\tret = idx;\n\t\tgoto err_coda_max;\n\t}\n\n\tname = kasprintf(GFP_KERNEL, \"context%d\", idx);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_coda_name_init;\n\t}\n\n\tctx->debugfs_entry = debugfs_create_dir(name, dev->debugfs_root);\n\tkfree(name);\n\n\tctx->cvd = to_coda_video_device(vdev);\n\tctx->inst_type = ctx->cvd->type;\n\tctx->ops = ctx->cvd->ops;\n\tctx->use_bit = !ctx->cvd->direct;\n\tinit_completion(&ctx->completion);\n\tINIT_WORK(&ctx->pic_run_work, coda_pic_run_work);\n\tif (ctx->ops->seq_init_work)\n\t\tINIT_WORK(&ctx->seq_init_work, ctx->ops->seq_init_work);\n\tif (ctx->ops->seq_end_work)\n\t\tINIT_WORK(&ctx->seq_end_work, ctx->ops->seq_end_work);\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\tctx->dev = dev;\n\tctx->idx = idx;\n\n\tcoda_dbg(1, ctx, \"open instance (%p)\\n\", ctx);\n\n\tswitch (dev->devtype->product) {\n\tcase CODA_960:\n\t\t \n\t\tif (enable_bwb || ctx->inst_type == CODA_INST_ENCODER)\n\t\t\tctx->frame_mem_ctrl = CODA9_FRAME_ENABLE_BWB;\n\t\tfallthrough;\n\tcase CODA_HX4:\n\tcase CODA_7541:\n\t\tctx->reg_idx = 0;\n\t\tbreak;\n\tdefault:\n\t\tctx->reg_idx = idx;\n\t}\n\tif (ctx->dev->vdoa && !disable_vdoa) {\n\t\tctx->vdoa = vdoa_context_create(dev->vdoa);\n\t\tif (!ctx->vdoa)\n\t\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t\t  \"Failed to create vdoa context: not using vdoa\");\n\t}\n\tctx->use_vdoa = false;\n\n\t \n\tret = pm_runtime_resume_and_get(dev->dev);\n\tif (ret < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"failed to power up: %d\\n\", ret);\n\t\tgoto err_pm_get;\n\t}\n\n\tret = clk_prepare_enable(dev->clk_per);\n\tif (ret)\n\t\tgoto err_clk_enable;\n\n\tret = clk_prepare_enable(dev->clk_ahb);\n\tif (ret)\n\t\tgoto err_clk_ahb;\n\n\tset_default_params(ctx);\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx,\n\t\t\t\t\t    ctx->ops->queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\n\t\tv4l2_err(&dev->v4l2_dev, \"%s return error (%d)\\n\",\n\t\t\t __func__, ret);\n\t\tgoto err_ctx_init;\n\t}\n\n\tret = coda_ctrls_setup(ctx);\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"failed to setup coda controls\\n\");\n\t\tgoto err_ctrls_setup;\n\t}\n\n\tctx->fh.ctrl_handler = &ctx->ctrls;\n\n\tmutex_init(&ctx->bitstream_mutex);\n\tmutex_init(&ctx->buffer_mutex);\n\tmutex_init(&ctx->wakeup_mutex);\n\tINIT_LIST_HEAD(&ctx->buffer_meta_list);\n\tspin_lock_init(&ctx->buffer_meta_lock);\n\n\treturn 0;\n\nerr_ctrls_setup:\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\nerr_ctx_init:\n\tclk_disable_unprepare(dev->clk_ahb);\nerr_clk_ahb:\n\tclk_disable_unprepare(dev->clk_per);\nerr_clk_enable:\n\tpm_runtime_put_sync(dev->dev);\nerr_pm_get:\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\nerr_coda_name_init:\n\tida_free(&dev->ida, ctx->idx);\nerr_coda_max:\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic int coda_release(struct file *file)\n{\n\tstruct coda_dev *dev = video_drvdata(file);\n\tstruct coda_ctx *ctx = fh_to_ctx(file->private_data);\n\n\tcoda_dbg(1, ctx, \"release instance (%p)\\n\", ctx);\n\n\tif (ctx->inst_type == CODA_INST_DECODER && ctx->use_bit)\n\t\tcoda_bit_stream_end_flag(ctx);\n\n\t \n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\n\tif (ctx->vdoa)\n\t\tvdoa_context_destroy(ctx->vdoa);\n\n\t \n\tif (ctx->ops->seq_end_work) {\n\t\tqueue_work(dev->workqueue, &ctx->seq_end_work);\n\t\tflush_work(&ctx->seq_end_work);\n\t}\n\n\tif (ctx->dev->devtype->product == CODA_DX6)\n\t\tcoda_free_aux_buf(dev, &ctx->workbuf);\n\n\tv4l2_ctrl_handler_free(&ctx->ctrls);\n\tclk_disable_unprepare(dev->clk_ahb);\n\tclk_disable_unprepare(dev->clk_per);\n\tpm_runtime_put_sync(dev->dev);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tida_free(&dev->ida, ctx->idx);\n\tif (ctx->ops->release)\n\t\tctx->ops->release(ctx);\n\tdebugfs_remove_recursive(ctx->debugfs_entry);\n\tkfree(ctx);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations coda_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= coda_open,\n\t.release\t= coda_release,\n\t.poll\t\t= v4l2_m2m_fop_poll,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= v4l2_m2m_fop_mmap,\n};\n\nstatic int coda_hw_init(struct coda_dev *dev)\n{\n\tu32 data;\n\tu16 *p;\n\tint i, ret;\n\n\tret = clk_prepare_enable(dev->clk_per);\n\tif (ret)\n\t\tgoto err_clk_per;\n\n\tret = clk_prepare_enable(dev->clk_ahb);\n\tif (ret)\n\t\tgoto err_clk_ahb;\n\n\treset_control_reset(dev->rstc);\n\n\t \n\tp = (u16 *)dev->codebuf.vaddr;\n\tif (dev->devtype->product == CODA_DX6) {\n\t\tfor (i = 0; i < (CODA_ISRAM_SIZE / 2); i++)  {\n\t\t\tdata = CODA_DOWN_ADDRESS_SET(i) |\n\t\t\t\tCODA_DOWN_DATA_SET(p[i ^ 1]);\n\t\t\tcoda_write(dev, data, CODA_REG_BIT_CODE_DOWN);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < (CODA_ISRAM_SIZE / 2); i++) {\n\t\t\tdata = CODA_DOWN_ADDRESS_SET(i) |\n\t\t\t\tCODA_DOWN_DATA_SET(p[round_down(i, 4) +\n\t\t\t\t\t\t\t3 - (i % 4)]);\n\t\t\tcoda_write(dev, data, CODA_REG_BIT_CODE_DOWN);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 64; i++)\n\t\tcoda_write(dev, 0, CODA_REG_BIT_CODE_BUF_ADDR + i * 4);\n\n\t \n\tif (dev->devtype->product == CODA_960 ||\n\t    dev->devtype->product == CODA_7541 ||\n\t    dev->devtype->product == CODA_HX4) {\n\t\tcoda_write(dev, dev->tempbuf.paddr,\n\t\t\t\tCODA_REG_BIT_TEMP_BUF_ADDR);\n\t\tcoda_write(dev, 0, CODA_REG_BIT_BIT_STREAM_PARAM);\n\t} else {\n\t\tcoda_write(dev, dev->workbuf.paddr,\n\t\t\t      CODA_REG_BIT_WORK_BUF_ADDR);\n\t}\n\tcoda_write(dev, dev->codebuf.paddr,\n\t\t      CODA_REG_BIT_CODE_BUF_ADDR);\n\tcoda_write(dev, 0, CODA_REG_BIT_CODE_RUN);\n\n\t \n\tswitch (dev->devtype->product) {\n\tcase CODA_DX6:\n\t\tcoda_write(dev, CODADX6_STREAM_BUF_PIC_FLUSH,\n\t\t\t   CODA_REG_BIT_STREAM_CTRL);\n\t\tbreak;\n\tdefault:\n\t\tcoda_write(dev, CODA7_STREAM_BUF_PIC_FLUSH,\n\t\t\t   CODA_REG_BIT_STREAM_CTRL);\n\t}\n\tif (dev->devtype->product == CODA_960)\n\t\tcoda_write(dev, CODA9_FRAME_ENABLE_BWB,\n\t\t\t\tCODA_REG_BIT_FRAME_MEM_CTRL);\n\telse\n\t\tcoda_write(dev, 0, CODA_REG_BIT_FRAME_MEM_CTRL);\n\n\tif (dev->devtype->product != CODA_DX6)\n\t\tcoda_write(dev, 0, CODA7_REG_BIT_AXI_SRAM_USE);\n\n\tcoda_write(dev, CODA_INT_INTERRUPT_ENABLE,\n\t\t      CODA_REG_BIT_INT_ENABLE);\n\n\t \n\tdata = coda_read(dev, CODA_REG_BIT_CODE_RESET);\n\tdata |= CODA_REG_RESET_ENABLE;\n\tcoda_write(dev, data, CODA_REG_BIT_CODE_RESET);\n\tudelay(10);\n\tdata &= ~CODA_REG_RESET_ENABLE;\n\tcoda_write(dev, data, CODA_REG_BIT_CODE_RESET);\n\tcoda_write(dev, CODA_REG_RUN_ENABLE, CODA_REG_BIT_CODE_RUN);\n\n\tclk_disable_unprepare(dev->clk_ahb);\n\tclk_disable_unprepare(dev->clk_per);\n\n\treturn 0;\n\nerr_clk_ahb:\n\tclk_disable_unprepare(dev->clk_per);\nerr_clk_per:\n\treturn ret;\n}\n\nstatic int coda_register_device(struct coda_dev *dev, int i)\n{\n\tstruct video_device *vfd = &dev->vfd[i];\n\tconst char *name;\n\tint ret;\n\n\tif (i >= dev->devtype->num_vdevs)\n\t\treturn -EINVAL;\n\tname = dev->devtype->vdevs[i]->name;\n\n\tstrscpy(vfd->name, dev->devtype->vdevs[i]->name, sizeof(vfd->name));\n\tvfd->fops\t= &coda_fops;\n\tvfd->ioctl_ops\t= &coda_ioctl_ops;\n\tvfd->release\t= video_device_release_empty;\n\tvfd->lock\t= &dev->dev_mutex;\n\tvfd->v4l2_dev\t= &dev->v4l2_dev;\n\tvfd->vfl_dir\t= VFL_DIR_M2M;\n\tvfd->device_caps = V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING;\n\tvideo_set_drvdata(vfd, dev);\n\n\t \n\tv4l2_disable_ioctl(vfd, VIDIOC_CROPCAP);\n\tv4l2_disable_ioctl(vfd, VIDIOC_G_CROP);\n\tv4l2_disable_ioctl(vfd, VIDIOC_S_CROP);\n\n\tif (dev->devtype->vdevs[i]->type == CODA_INST_ENCODER) {\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_DECODER_CMD);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_TRY_DECODER_CMD);\n\t\tif (dev->devtype->vdevs[i]->dst_formats[0] == V4L2_PIX_FMT_JPEG) {\n\t\t\tv4l2_disable_ioctl(vfd, VIDIOC_ENUM_FRAMEINTERVALS);\n\t\t\tv4l2_disable_ioctl(vfd, VIDIOC_G_PARM);\n\t\t\tv4l2_disable_ioctl(vfd, VIDIOC_S_PARM);\n\t\t}\n\t} else {\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_ENCODER_CMD);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_TRY_ENCODER_CMD);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_ENUM_FRAMESIZES);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_ENUM_FRAMEINTERVALS);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_G_PARM);\n\t\tv4l2_disable_ioctl(vfd, VIDIOC_S_PARM);\n\t}\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);\n\tif (!ret)\n\t\tv4l2_info(&dev->v4l2_dev, \"%s registered as %s\\n\",\n\t\t\t  name, video_device_node_name(vfd));\n\treturn ret;\n}\n\nstatic void coda_copy_firmware(struct coda_dev *dev, const u8 * const buf,\n\t\t\t       size_t size)\n{\n\tu32 *src = (u32 *)buf;\n\n\t \n\tif (buf[0] == 'M' && buf[1] == 'X')\n\t\tsrc += 4;\n\t \n\tif (__le16_to_cpup((__le16 *)src) == 0xe40e) {\n\t\tu32 *dst = dev->codebuf.vaddr;\n\t\tint i;\n\n\t\t \n\t\tif (dev->devtype->product == CODA_DX6) {\n\t\t\tfor (i = 0; i < (size - 16) / 4; i++)\n\t\t\t\tdst[i] = (src[i] << 16) | (src[i] >> 16);\n\t\t} else {\n\t\t\tfor (i = 0; i < (size - 16) / 4; i += 2) {\n\t\t\t\tdst[i] = (src[i + 1] << 16) | (src[i + 1] >> 16);\n\t\t\t\tdst[i + 1] = (src[i] << 16) | (src[i] >> 16);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tmemcpy(dev->codebuf.vaddr, src, size);\n\t}\n}\n\nstatic void coda_fw_callback(const struct firmware *fw, void *context);\n\nstatic int coda_firmware_request(struct coda_dev *dev)\n{\n\tchar *fw;\n\n\tif (dev->firmware >= ARRAY_SIZE(dev->devtype->firmware))\n\t\treturn -EINVAL;\n\n\tfw = dev->devtype->firmware[dev->firmware];\n\n\tdev_dbg(dev->dev, \"requesting firmware '%s' for %s\\n\", fw,\n\t\tcoda_product_name(dev->devtype->product));\n\n\treturn request_firmware_nowait(THIS_MODULE, true, fw, dev->dev,\n\t\t\t\t       GFP_KERNEL, dev, coda_fw_callback);\n}\n\nstatic void coda_fw_callback(const struct firmware *fw, void *context)\n{\n\tstruct coda_dev *dev = context;\n\tint i, ret;\n\n\tif (!fw) {\n\t\tdev->firmware++;\n\t\tret = coda_firmware_request(dev);\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"firmware request failed\\n\");\n\t\t\tgoto put_pm;\n\t\t}\n\t\treturn;\n\t}\n\tif (dev->firmware > 0) {\n\t\t \n\t\tdev_info(dev->dev, \"Using fallback firmware %s\\n\",\n\t\t\t dev->devtype->firmware[dev->firmware]);\n\t}\n\n\t \n\tret = coda_alloc_aux_buf(dev, &dev->codebuf, fw->size, \"codebuf\",\n\t\t\t\t dev->debugfs_root);\n\tif (ret < 0)\n\t\tgoto put_pm;\n\n\tcoda_copy_firmware(dev, fw->data, fw->size);\n\trelease_firmware(fw);\n\n\tret = coda_hw_init(dev);\n\tif (ret < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"HW initialization failed\\n\");\n\t\tgoto put_pm;\n\t}\n\n\tret = coda_check_firmware(dev);\n\tif (ret < 0)\n\t\tgoto put_pm;\n\n\tdev->m2m_dev = v4l2_m2m_init(&coda_m2m_ops);\n\tif (IS_ERR(dev->m2m_dev)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tgoto put_pm;\n\t}\n\n\tfor (i = 0; i < dev->devtype->num_vdevs; i++) {\n\t\tret = coda_register_device(dev, i);\n\t\tif (ret) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"Failed to register %s video device: %d\\n\",\n\t\t\t\t dev->devtype->vdevs[i]->name, ret);\n\t\t\tgoto rel_vfd;\n\t\t}\n\t}\n\n\tpm_runtime_put_sync(dev->dev);\n\treturn;\n\nrel_vfd:\n\twhile (--i >= 0)\n\t\tvideo_unregister_device(&dev->vfd[i]);\n\tv4l2_m2m_release(dev->m2m_dev);\nput_pm:\n\tpm_runtime_put_sync(dev->dev);\n}\n\nenum coda_platform {\n\tCODA_IMX27,\n\tCODA_IMX51,\n\tCODA_IMX53,\n\tCODA_IMX6Q,\n\tCODA_IMX6DL,\n};\n\nstatic const struct coda_devtype coda_devdata[] = {\n\t[CODA_IMX27] = {\n\t\t.firmware     = {\n\t\t\t\"vpu_fw_imx27_TO2.bin\",\n\t\t\t\"vpu/vpu_fw_imx27_TO2.bin\",\n\t\t\t\"v4l-codadx6-imx27.bin\"\n\t\t},\n\t\t.product      = CODA_DX6,\n\t\t.codecs       = codadx6_codecs,\n\t\t.num_codecs   = ARRAY_SIZE(codadx6_codecs),\n\t\t.vdevs        = codadx6_video_devices,\n\t\t.num_vdevs    = ARRAY_SIZE(codadx6_video_devices),\n\t\t.workbuf_size = 288 * 1024 + FMO_SLICE_SAVE_BUF_SIZE * 8 * 1024,\n\t\t.iram_size    = 0xb000,\n\t},\n\t[CODA_IMX51] = {\n\t\t.firmware     = {\n\t\t\t\"vpu_fw_imx51.bin\",\n\t\t\t\"vpu/vpu_fw_imx51.bin\",\n\t\t\t\"v4l-codahx4-imx51.bin\"\n\t\t},\n\t\t.product      = CODA_HX4,\n\t\t.codecs       = codahx4_codecs,\n\t\t.num_codecs   = ARRAY_SIZE(codahx4_codecs),\n\t\t.vdevs        = codahx4_video_devices,\n\t\t.num_vdevs    = ARRAY_SIZE(codahx4_video_devices),\n\t\t.workbuf_size = 128 * 1024,\n\t\t.tempbuf_size = 304 * 1024,\n\t\t.iram_size    = 0x14000,\n\t},\n\t[CODA_IMX53] = {\n\t\t.firmware     = {\n\t\t\t\"vpu_fw_imx53.bin\",\n\t\t\t\"vpu/vpu_fw_imx53.bin\",\n\t\t\t\"v4l-coda7541-imx53.bin\"\n\t\t},\n\t\t.product      = CODA_7541,\n\t\t.codecs       = coda7_codecs,\n\t\t.num_codecs   = ARRAY_SIZE(coda7_codecs),\n\t\t.vdevs        = coda7_video_devices,\n\t\t.num_vdevs    = ARRAY_SIZE(coda7_video_devices),\n\t\t.workbuf_size = 128 * 1024,\n\t\t.tempbuf_size = 304 * 1024,\n\t\t.iram_size    = 0x14000,\n\t},\n\t[CODA_IMX6Q] = {\n\t\t.firmware     = {\n\t\t\t\"vpu_fw_imx6q.bin\",\n\t\t\t\"vpu/vpu_fw_imx6q.bin\",\n\t\t\t\"v4l-coda960-imx6q.bin\"\n\t\t},\n\t\t.product      = CODA_960,\n\t\t.codecs       = coda9_codecs,\n\t\t.num_codecs   = ARRAY_SIZE(coda9_codecs),\n\t\t.vdevs        = coda9_video_devices,\n\t\t.num_vdevs    = ARRAY_SIZE(coda9_video_devices),\n\t\t.workbuf_size = 80 * 1024,\n\t\t.tempbuf_size = 204 * 1024,\n\t\t.iram_size    = 0x21000,\n\t},\n\t[CODA_IMX6DL] = {\n\t\t.firmware     = {\n\t\t\t\"vpu_fw_imx6d.bin\",\n\t\t\t\"vpu/vpu_fw_imx6d.bin\",\n\t\t\t\"v4l-coda960-imx6dl.bin\"\n\t\t},\n\t\t.product      = CODA_960,\n\t\t.codecs       = coda9_codecs,\n\t\t.num_codecs   = ARRAY_SIZE(coda9_codecs),\n\t\t.vdevs        = coda9_video_devices,\n\t\t.num_vdevs    = ARRAY_SIZE(coda9_video_devices),\n\t\t.workbuf_size = 80 * 1024,\n\t\t.tempbuf_size = 204 * 1024,\n\t\t.iram_size    = 0x1f000,  \n\t},\n};\n\nstatic const struct of_device_id coda_dt_ids[] = {\n\t{ .compatible = \"fsl,imx27-vpu\", .data = &coda_devdata[CODA_IMX27] },\n\t{ .compatible = \"fsl,imx51-vpu\", .data = &coda_devdata[CODA_IMX51] },\n\t{ .compatible = \"fsl,imx53-vpu\", .data = &coda_devdata[CODA_IMX53] },\n\t{ .compatible = \"fsl,imx6q-vpu\", .data = &coda_devdata[CODA_IMX6Q] },\n\t{ .compatible = \"fsl,imx6dl-vpu\", .data = &coda_devdata[CODA_IMX6DL] },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, coda_dt_ids);\n\nstatic int coda_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct gen_pool *pool;\n\tstruct coda_dev *dev;\n\tint ret, irq;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->devtype = of_device_get_match_data(&pdev->dev);\n\n\tdev->dev = &pdev->dev;\n\tdev->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(dev->clk_per)) {\n\t\tdev_err(&pdev->dev, \"Could not get per clock\\n\");\n\t\treturn PTR_ERR(dev->clk_per);\n\t}\n\n\tdev->clk_ahb = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(dev->clk_ahb)) {\n\t\tdev_err(&pdev->dev, \"Could not get ahb clock\\n\");\n\t\treturn PTR_ERR(dev->clk_ahb);\n\t}\n\n\t \n\tdev->regs_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->regs_base))\n\t\treturn PTR_ERR(dev->regs_base);\n\n\t \n\tirq = platform_get_irq_byname(pdev, \"bit\");\n\tif (irq < 0)\n\t\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, coda_irq_handler, 0,\n\t\t\t       CODA_NAME \"-video\", dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (dev->devtype->product == CODA_960) {\n\t\tirq = platform_get_irq_byname(pdev, \"jpeg\");\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\t\tcoda9_jpeg_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT, CODA_NAME \"-jpeg\",\n\t\t\t\t\t\tdev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to request jpeg irq\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev->rstc = devm_reset_control_get_optional_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t      NULL);\n\tif (IS_ERR(dev->rstc)) {\n\t\tret = PTR_ERR(dev->rstc);\n\t\tdev_err(&pdev->dev, \"failed get reset control: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tpool = of_gen_pool_get(np, \"iram\", 0);\n\tif (!pool) {\n\t\tdev_err(&pdev->dev, \"iram pool not available\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdev->iram_pool = pool;\n\n\t \n\tdev->vdoa = coda_get_vdoa_data();\n\tif (PTR_ERR(dev->vdoa) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tratelimit_default_init(&dev->mb_err_rs);\n\tmutex_init(&dev->dev_mutex);\n\tmutex_init(&dev->coda_mutex);\n\tida_init(&dev->ida);\n\n\tdev->debugfs_root = debugfs_create_dir(\"coda\", NULL);\n\n\t \n\tif (dev->devtype->product == CODA_DX6) {\n\t\tret = coda_alloc_aux_buf(dev, &dev->workbuf,\n\t\t\t\t\t dev->devtype->workbuf_size, \"workbuf\",\n\t\t\t\t\t dev->debugfs_root);\n\t\tif (ret < 0)\n\t\t\tgoto err_v4l2_register;\n\t}\n\n\tif (dev->devtype->tempbuf_size) {\n\t\tret = coda_alloc_aux_buf(dev, &dev->tempbuf,\n\t\t\t\t\t dev->devtype->tempbuf_size, \"tempbuf\",\n\t\t\t\t\t dev->debugfs_root);\n\t\tif (ret < 0)\n\t\t\tgoto err_v4l2_register;\n\t}\n\n\tdev->iram.size = dev->devtype->iram_size;\n\tdev->iram.vaddr = gen_pool_dma_alloc(dev->iram_pool, dev->iram.size,\n\t\t\t\t\t     &dev->iram.paddr);\n\tif (!dev->iram.vaddr) {\n\t\tdev_warn(&pdev->dev, \"unable to alloc iram\\n\");\n\t} else {\n\t\tmemset(dev->iram.vaddr, 0, dev->iram.size);\n\t\tdev->iram.blob.data = dev->iram.vaddr;\n\t\tdev->iram.blob.size = dev->iram.size;\n\t\tdev->iram.dentry = debugfs_create_blob(\"iram\", 0444,\n\t\t\t\t\t\t       dev->debugfs_root,\n\t\t\t\t\t\t       &dev->iram.blob);\n\t}\n\n\tdev->workqueue = alloc_ordered_workqueue(\"coda\", WQ_MEM_RECLAIM);\n\tif (!dev->workqueue) {\n\t\tdev_err(&pdev->dev, \"unable to alloc workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_v4l2_register;\n\t}\n\n\tplatform_set_drvdata(pdev, dev);\n\n\t \n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = coda_firmware_request(dev);\n\tif (ret)\n\t\tgoto err_alloc_workqueue;\n\treturn 0;\n\nerr_alloc_workqueue:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tdestroy_workqueue(dev->workqueue);\nerr_v4l2_register:\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\treturn ret;\n}\n\nstatic void coda_remove(struct platform_device *pdev)\n{\n\tstruct coda_dev *dev = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dev->vfd); i++) {\n\t\tif (video_get_drvdata(&dev->vfd[i]))\n\t\t\tvideo_unregister_device(&dev->vfd[i]);\n\t}\n\tif (dev->m2m_dev)\n\t\tv4l2_m2m_release(dev->m2m_dev);\n\tpm_runtime_disable(&pdev->dev);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tdestroy_workqueue(dev->workqueue);\n\tif (dev->iram.vaddr)\n\t\tgen_pool_free(dev->iram_pool, (unsigned long)dev->iram.vaddr,\n\t\t\t      dev->iram.size);\n\tcoda_free_aux_buf(dev, &dev->codebuf);\n\tcoda_free_aux_buf(dev, &dev->tempbuf);\n\tcoda_free_aux_buf(dev, &dev->workbuf);\n\tdebugfs_remove_recursive(dev->debugfs_root);\n\tida_destroy(&dev->ida);\n}\n\n#ifdef CONFIG_PM\nstatic int coda_runtime_resume(struct device *dev)\n{\n\tstruct coda_dev *cdev = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (dev->pm_domain && cdev->codebuf.vaddr) {\n\t\tret = coda_hw_init(cdev);\n\t\tif (ret)\n\t\t\tv4l2_err(&cdev->v4l2_dev, \"HW initialization failed\\n\");\n\t}\n\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops coda_pm_ops = {\n\tSET_RUNTIME_PM_OPS(NULL, coda_runtime_resume, NULL)\n};\n\nstatic struct platform_driver coda_driver = {\n\t.probe\t= coda_probe,\n\t.remove_new = coda_remove,\n\t.driver\t= {\n\t\t.name\t= CODA_NAME,\n\t\t.of_match_table = coda_dt_ids,\n\t\t.pm\t= &coda_pm_ops,\n\t},\n};\n\nmodule_platform_driver(coda_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Javier Martin <javier.martin@vista-silicon.com>\");\nMODULE_DESCRIPTION(\"Coda multi-standard codec V4L2 driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}