{
  "module_name": "coda-bit.c",
  "hash_id": "cf89a500af1af46b3671fc86ec964dd97dcaa912853ce35c23af882ab9ed1585",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/chips-media/coda-bit.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/irqreturn.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/platform_device.h>\n#include <linux/ratelimit.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"coda.h\"\n#include \"imx-vdoa.h\"\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\n#define CODA_PARA_BUF_SIZE\t(10 * 1024)\n#define CODA7_PS_BUF_SIZE\t0x28000\n#define CODA9_PS_SAVE_SIZE\t(512 * 1024)\n\n#define CODA_DEFAULT_GAMMA\t4096\n#define CODA9_DEFAULT_GAMMA\t24576\t \n\nstatic void coda_free_bitstream_buffer(struct coda_ctx *ctx);\n\nstatic inline int coda_is_initialized(struct coda_dev *dev)\n{\n\treturn coda_read(dev, CODA_REG_BIT_CUR_PC) != 0;\n}\n\nstatic inline unsigned long coda_isbusy(struct coda_dev *dev)\n{\n\treturn coda_read(dev, CODA_REG_BIT_BUSY);\n}\n\nstatic int coda_wait_timeout(struct coda_dev *dev)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\n\twhile (coda_isbusy(dev)) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\nstatic void coda_command_async(struct coda_ctx *ctx, int cmd)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\n\tif (dev->devtype->product == CODA_HX4 ||\n\t    dev->devtype->product == CODA_7541 ||\n\t    dev->devtype->product == CODA_960) {\n\t\t \n\t\tcoda_write(dev, ctx->bit_stream_param,\n\t\t\t\tCODA_REG_BIT_BIT_STREAM_PARAM);\n\t\tcoda_write(dev, ctx->frm_dis_flg,\n\t\t\t\tCODA_REG_BIT_FRM_DIS_FLG(ctx->reg_idx));\n\t\tcoda_write(dev, ctx->frame_mem_ctrl,\n\t\t\t\tCODA_REG_BIT_FRAME_MEM_CTRL);\n\t\tcoda_write(dev, ctx->workbuf.paddr, CODA_REG_BIT_WORK_BUF_ADDR);\n\t}\n\n\tif (dev->devtype->product == CODA_960) {\n\t\tcoda_write(dev, 1, CODA9_GDI_WPROT_ERR_CLR);\n\t\tcoda_write(dev, 0, CODA9_GDI_WPROT_RGN_EN);\n\t}\n\n\tcoda_write(dev, CODA_REG_BIT_BUSY_FLAG, CODA_REG_BIT_BUSY);\n\n\tcoda_write(dev, ctx->idx, CODA_REG_BIT_RUN_INDEX);\n\tcoda_write(dev, ctx->params.codec_mode, CODA_REG_BIT_RUN_COD_STD);\n\tcoda_write(dev, ctx->params.codec_mode_aux, CODA7_REG_BIT_RUN_AUX_STD);\n\n\ttrace_coda_bit_run(ctx, cmd);\n\n\tcoda_write(dev, cmd, CODA_REG_BIT_RUN_COMMAND);\n}\n\nstatic int coda_command_sync(struct coda_ctx *ctx, int cmd)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tint ret;\n\n\tlockdep_assert_held(&dev->coda_mutex);\n\n\tcoda_command_async(ctx, cmd);\n\tret = coda_wait_timeout(dev);\n\ttrace_coda_bit_done(ctx);\n\n\treturn ret;\n}\n\nint coda_hw_reset(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tunsigned long timeout;\n\tunsigned int idx;\n\tint ret;\n\n\tlockdep_assert_held(&dev->coda_mutex);\n\n\tif (!dev->rstc)\n\t\treturn -ENOENT;\n\n\tidx = coda_read(dev, CODA_REG_BIT_RUN_INDEX);\n\n\tif (dev->devtype->product == CODA_960) {\n\t\ttimeout = jiffies + msecs_to_jiffies(100);\n\t\tcoda_write(dev, 0x11, CODA9_GDI_BUS_CTRL);\n\t\twhile (coda_read(dev, CODA9_GDI_BUS_STATUS) != 0x77) {\n\t\t\tif (time_after(jiffies, timeout))\n\t\t\t\treturn -ETIME;\n\t\t\tcpu_relax();\n\t\t}\n\t}\n\n\tret = reset_control_reset(dev->rstc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dev->devtype->product == CODA_960)\n\t\tcoda_write(dev, 0x00, CODA9_GDI_BUS_CTRL);\n\tcoda_write(dev, CODA_REG_BIT_BUSY_FLAG, CODA_REG_BIT_BUSY);\n\tcoda_write(dev, CODA_REG_RUN_ENABLE, CODA_REG_BIT_CODE_RUN);\n\tret = coda_wait_timeout(dev);\n\tcoda_write(dev, idx, CODA_REG_BIT_RUN_INDEX);\n\n\treturn ret;\n}\n\nstatic void coda_kfifo_sync_from_device(struct coda_ctx *ctx)\n{\n\tstruct __kfifo *kfifo = &ctx->bitstream_fifo.kfifo;\n\tstruct coda_dev *dev = ctx->dev;\n\tu32 rd_ptr;\n\n\trd_ptr = coda_read(dev, CODA_REG_BIT_RD_PTR(ctx->reg_idx));\n\tkfifo->out = (kfifo->in & ~kfifo->mask) |\n\t\t      (rd_ptr - ctx->bitstream.paddr);\n\tif (kfifo->out > kfifo->in)\n\t\tkfifo->out -= kfifo->mask + 1;\n}\n\nstatic void coda_kfifo_sync_to_device_full(struct coda_ctx *ctx)\n{\n\tstruct __kfifo *kfifo = &ctx->bitstream_fifo.kfifo;\n\tstruct coda_dev *dev = ctx->dev;\n\tu32 rd_ptr, wr_ptr;\n\n\trd_ptr = ctx->bitstream.paddr + (kfifo->out & kfifo->mask);\n\tcoda_write(dev, rd_ptr, CODA_REG_BIT_RD_PTR(ctx->reg_idx));\n\twr_ptr = ctx->bitstream.paddr + (kfifo->in & kfifo->mask);\n\tcoda_write(dev, wr_ptr, CODA_REG_BIT_WR_PTR(ctx->reg_idx));\n}\n\nstatic void coda_kfifo_sync_to_device_write(struct coda_ctx *ctx)\n{\n\tstruct __kfifo *kfifo = &ctx->bitstream_fifo.kfifo;\n\tstruct coda_dev *dev = ctx->dev;\n\tu32 wr_ptr;\n\n\twr_ptr = ctx->bitstream.paddr + (kfifo->in & kfifo->mask);\n\tcoda_write(dev, wr_ptr, CODA_REG_BIT_WR_PTR(ctx->reg_idx));\n}\n\nstatic int coda_h264_bitstream_pad(struct coda_ctx *ctx, u32 size)\n{\n\tunsigned char *buf;\n\tu32 n;\n\n\tif (size < 6)\n\t\tsize = 6;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tcoda_h264_filler_nal(size, buf);\n\tn = kfifo_in(&ctx->bitstream_fifo, buf, size);\n\tkfree(buf);\n\n\treturn (n < size) ? -ENOSPC : 0;\n}\n\nint coda_bitstream_flush(struct coda_ctx *ctx)\n{\n\tint ret;\n\n\tif (ctx->inst_type != CODA_INST_DECODER || !ctx->use_bit)\n\t\treturn 0;\n\n\tret = coda_command_sync(ctx, CODA_COMMAND_DEC_BUF_FLUSH);\n\tif (ret < 0) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"failed to flush bitstream\\n\");\n\t\treturn ret;\n\t}\n\n\tkfifo_init(&ctx->bitstream_fifo, ctx->bitstream.vaddr,\n\t\t   ctx->bitstream.size);\n\tcoda_kfifo_sync_to_device_full(ctx);\n\n\treturn 0;\n}\n\nstatic int coda_bitstream_queue(struct coda_ctx *ctx, const u8 *buf, u32 size)\n{\n\tu32 n = kfifo_in(&ctx->bitstream_fifo, buf, size);\n\n\treturn (n < size) ? -ENOSPC : 0;\n}\n\nstatic u32 coda_buffer_parse_headers(struct coda_ctx *ctx,\n\t\t\t\t     struct vb2_v4l2_buffer *src_buf,\n\t\t\t\t     u32 payload)\n{\n\tu8 *vaddr = vb2_plane_vaddr(&src_buf->vb2_buf, 0);\n\tu32 size = 0;\n\n\tswitch (ctx->codec->src_fourcc) {\n\tcase V4L2_PIX_FMT_MPEG2:\n\t\tsize = coda_mpeg2_parse_headers(ctx, vaddr, payload);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG4:\n\t\tsize = coda_mpeg4_parse_headers(ctx, vaddr, payload);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic bool coda_bitstream_try_queue(struct coda_ctx *ctx,\n\t\t\t\t     struct vb2_v4l2_buffer *src_buf)\n{\n\tunsigned long payload = vb2_get_plane_payload(&src_buf->vb2_buf, 0);\n\tu8 *vaddr = vb2_plane_vaddr(&src_buf->vb2_buf, 0);\n\tint ret;\n\tint i;\n\n\tif (coda_get_bitstream_payload(ctx) + payload + 512 >=\n\t    ctx->bitstream.size)\n\t\treturn false;\n\n\tif (!vaddr) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"trying to queue empty buffer\\n\");\n\t\treturn true;\n\t}\n\n\tif (ctx->qsequence == 0 && payload < 512) {\n\t\t \n\t\tu32 header_size = coda_buffer_parse_headers(ctx, src_buf,\n\t\t\t\t\t\t\t    payload);\n\n\t\tif (header_size) {\n\t\t\tcoda_dbg(1, ctx, \"pad with %u-byte header\\n\",\n\t\t\t\t header_size);\n\t\t\tfor (i = payload; i < 512; i += header_size) {\n\t\t\t\tret = coda_bitstream_queue(ctx, vaddr,\n\t\t\t\t\t\t\t   header_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t\t\t\t \"bitstream buffer overflow\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (ctx->dev->devtype->product == CODA_960)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tcoda_dbg(1, ctx,\n\t\t\t\t \"could not parse header, sequence initialization might fail\\n\");\n\t\t}\n\n\t\t \n\t\tif (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264)\n\t\t\tcoda_h264_bitstream_pad(ctx, 512 - payload);\n\t}\n\n\tret = coda_bitstream_queue(ctx, vaddr, payload);\n\tif (ret < 0) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev, \"bitstream buffer overflow\\n\");\n\t\treturn false;\n\t}\n\n\tsrc_buf->sequence = ctx->qsequence++;\n\n\t \n\tif (ctx == v4l2_m2m_get_curr_priv(ctx->dev->m2m_dev))\n\t\tcoda_kfifo_sync_to_device_write(ctx);\n\n\t \n\tif (src_buf->flags & V4L2_BUF_FLAG_LAST)\n\t\tcoda_bit_stream_end_flag(ctx);\n\tctx->hold = false;\n\n\treturn true;\n}\n\nvoid coda_fill_bitstream(struct coda_ctx *ctx, struct list_head *buffer_list)\n{\n\tstruct vb2_v4l2_buffer *src_buf;\n\tstruct coda_buffer_meta *meta;\n\tu32 start;\n\n\tlockdep_assert_held(&ctx->bitstream_mutex);\n\n\tif (ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG)\n\t\treturn;\n\n\twhile (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) > 0) {\n\t\t \n\t\tif (ctx->codec->src_fourcc == V4L2_PIX_FMT_JPEG &&\n\t\t    ctx->num_metas > 1)\n\t\t\tbreak;\n\n\t\tif (ctx->num_internal_frames &&\n\t\t    ctx->num_metas >= ctx->num_internal_frames) {\n\t\t\tmeta = list_first_entry(&ctx->buffer_meta_list,\n\t\t\t\t\t\tstruct coda_buffer_meta, list);\n\n\t\t\t \n\t\t\tif (coda_bitstream_can_fetch_past(ctx, meta->end))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\n\t\t \n\t\tif (ctx->codec->src_fourcc == V4L2_PIX_FMT_JPEG &&\n\t\t    !coda_jpeg_check_buffer(ctx, &src_buf->vb2_buf)) {\n\t\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t\t \"dropping invalid JPEG frame %d\\n\",\n\t\t\t\t ctx->qsequence);\n\t\t\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\t\tif (buffer_list) {\n\t\t\t\tstruct v4l2_m2m_buffer *m2m_buf;\n\n\t\t\t\tm2m_buf = container_of(src_buf,\n\t\t\t\t\t\t       struct v4l2_m2m_buffer,\n\t\t\t\t\t\t       vb);\n\t\t\t\tlist_add_tail(&m2m_buf->list, buffer_list);\n\t\t\t} else {\n\t\t\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!vb2_get_plane_payload(&src_buf->vb2_buf, 0)) {\n\t\t\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tstart = ctx->bitstream_fifo.kfifo.in;\n\n\t\tif (coda_bitstream_try_queue(ctx, src_buf)) {\n\t\t\t \n\t\t\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\n\t\t\tmeta = kmalloc(sizeof(*meta), GFP_KERNEL);\n\t\t\tif (meta) {\n\t\t\t\tmeta->sequence = src_buf->sequence;\n\t\t\t\tmeta->timecode = src_buf->timecode;\n\t\t\t\tmeta->timestamp = src_buf->vb2_buf.timestamp;\n\t\t\t\tmeta->start = start;\n\t\t\t\tmeta->end = ctx->bitstream_fifo.kfifo.in;\n\t\t\t\tmeta->last = src_buf->flags & V4L2_BUF_FLAG_LAST;\n\t\t\t\tif (meta->last)\n\t\t\t\t\tcoda_dbg(1, ctx, \"marking last meta\");\n\t\t\t\tspin_lock(&ctx->buffer_meta_lock);\n\t\t\t\tlist_add_tail(&meta->list,\n\t\t\t\t\t      &ctx->buffer_meta_list);\n\t\t\t\tctx->num_metas++;\n\t\t\t\tspin_unlock(&ctx->buffer_meta_lock);\n\n\t\t\t\ttrace_coda_bit_queue(ctx, src_buf, meta);\n\t\t\t}\n\n\t\t\tif (buffer_list) {\n\t\t\t\tstruct v4l2_m2m_buffer *m2m_buf;\n\n\t\t\t\tm2m_buf = container_of(src_buf,\n\t\t\t\t\t\t       struct v4l2_m2m_buffer,\n\t\t\t\t\t\t       vb);\n\t\t\t\tlist_add_tail(&m2m_buf->list, buffer_list);\n\t\t\t} else {\n\t\t\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid coda_bit_stream_end_flag(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\n\tctx->bit_stream_param |= CODA_BIT_STREAM_END_FLAG;\n\n\t \n\tif ((dev->devtype->product == CODA_960) &&\n\t    coda_isbusy(dev) &&\n\t    (ctx->idx == coda_read(dev, CODA_REG_BIT_RUN_INDEX))) {\n\t\tcoda_write(dev, ctx->bit_stream_param,\n\t\t\t   CODA_REG_BIT_BIT_STREAM_PARAM);\n\t}\n}\n\nstatic void coda_parabuf_write(struct coda_ctx *ctx, int index, u32 value)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tu32 *p = ctx->parabuf.vaddr;\n\n\tif (dev->devtype->product == CODA_DX6)\n\t\tp[index] = value;\n\telse\n\t\tp[index ^ 1] = value;\n}\n\nstatic inline int coda_alloc_context_buf(struct coda_ctx *ctx,\n\t\t\t\t\t struct coda_aux_buf *buf, size_t size,\n\t\t\t\t\t const char *name)\n{\n\treturn coda_alloc_aux_buf(ctx->dev, buf, size, name, ctx->debugfs_entry);\n}\n\n\nstatic void coda_free_framebuffers(struct coda_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < CODA_MAX_FRAMEBUFFERS; i++)\n\t\tcoda_free_aux_buf(ctx->dev, &ctx->internal_frames[i].buf);\n}\n\nstatic int coda_alloc_framebuffers(struct coda_ctx *ctx,\n\t\t\t\t   struct coda_q_data *q_data, u32 fourcc)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tunsigned int ysize, ycbcr_size;\n\tint ret;\n\tint i;\n\n\tif (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264 ||\n\t    ctx->codec->dst_fourcc == V4L2_PIX_FMT_H264 ||\n\t    ctx->codec->src_fourcc == V4L2_PIX_FMT_MPEG4 ||\n\t    ctx->codec->dst_fourcc == V4L2_PIX_FMT_MPEG4)\n\t\tysize = round_up(q_data->rect.width, 16) *\n\t\t\tround_up(q_data->rect.height, 16);\n\telse\n\t\tysize = round_up(q_data->rect.width, 8) * q_data->rect.height;\n\n\tif (ctx->tiled_map_type == GDI_TILED_FRAME_MB_RASTER_MAP)\n\t\tycbcr_size = round_up(ysize, 4096) + ysize / 2;\n\telse\n\t\tycbcr_size = ysize + ysize / 2;\n\n\t \n\tfor (i = 0; i < ctx->num_internal_frames; i++) {\n\t\tsize_t size = ycbcr_size;\n\t\tchar *name;\n\n\t\t \n\t\tif (dev->devtype->product != CODA_DX6 &&\n\t\t    (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264 ||\n\t\t     (ctx->codec->src_fourcc == V4L2_PIX_FMT_MPEG4 && i == 0)))\n\t\t\tsize += ysize / 4;\n\t\tname = kasprintf(GFP_KERNEL, \"fb%d\", i);\n\t\tif (!name) {\n\t\t\tcoda_free_framebuffers(ctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = coda_alloc_context_buf(ctx, &ctx->internal_frames[i].buf,\n\t\t\t\t\t     size, name);\n\t\tkfree(name);\n\t\tif (ret < 0) {\n\t\t\tcoda_free_framebuffers(ctx);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ctx->num_internal_frames; i++) {\n\t\tu32 y, cb, cr, mvcol;\n\n\t\t \n\t\ty = ctx->internal_frames[i].buf.paddr;\n\t\tcb = y + ysize;\n\t\tcr = y + ysize + ysize/4;\n\t\tmvcol = y + ysize + ysize/4 + ysize/4;\n\t\tif (ctx->tiled_map_type == GDI_TILED_FRAME_MB_RASTER_MAP) {\n\t\t\tcb = round_up(cb, 4096);\n\t\t\tmvcol = cb + ysize/2;\n\t\t\tcr = 0;\n\t\t\t \n\t\t\t \n\t\t\ty = (y & 0xfffff000) | cb >> 20;\n\t\t\tcb = (cb & 0x000ff000) << 12;\n\t\t}\n\t\tcoda_parabuf_write(ctx, i * 3 + 0, y);\n\t\tcoda_parabuf_write(ctx, i * 3 + 1, cb);\n\t\tcoda_parabuf_write(ctx, i * 3 + 2, cr);\n\n\t\tif (dev->devtype->product == CODA_DX6)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264)\n\t\t\tcoda_parabuf_write(ctx, 96 + i, mvcol);\n\t\tif (ctx->codec->src_fourcc == V4L2_PIX_FMT_MPEG4 && i == 0)\n\t\t\tcoda_parabuf_write(ctx, 97, mvcol);\n\t}\n\n\treturn 0;\n}\n\nstatic void coda_free_context_buffers(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\n\tcoda_free_aux_buf(dev, &ctx->slicebuf);\n\tcoda_free_aux_buf(dev, &ctx->psbuf);\n\tif (dev->devtype->product != CODA_DX6)\n\t\tcoda_free_aux_buf(dev, &ctx->workbuf);\n\tcoda_free_aux_buf(dev, &ctx->parabuf);\n}\n\nstatic int coda_alloc_context_buffers(struct coda_ctx *ctx,\n\t\t\t\t      struct coda_q_data *q_data)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tsize_t size;\n\tint ret;\n\n\tif (!ctx->parabuf.vaddr) {\n\t\tret = coda_alloc_context_buf(ctx, &ctx->parabuf,\n\t\t\t\t\t     CODA_PARA_BUF_SIZE, \"parabuf\");\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (dev->devtype->product == CODA_DX6)\n\t\treturn 0;\n\n\tif (!ctx->slicebuf.vaddr && q_data->fourcc == V4L2_PIX_FMT_H264) {\n\t\t \n\t\tsize = (DIV_ROUND_UP(q_data->rect.width, 16) *\n\t\t\tDIV_ROUND_UP(q_data->rect.height, 16)) * 3200 / 8 + 512;\n\t\tret = coda_alloc_context_buf(ctx, &ctx->slicebuf, size,\n\t\t\t\t\t     \"slicebuf\");\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tif (!ctx->psbuf.vaddr && (dev->devtype->product == CODA_HX4 ||\n\t\t\t\t  dev->devtype->product == CODA_7541)) {\n\t\tret = coda_alloc_context_buf(ctx, &ctx->psbuf,\n\t\t\t\t\t     CODA7_PS_BUF_SIZE, \"psbuf\");\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tif (!ctx->workbuf.vaddr) {\n\t\tsize = dev->devtype->workbuf_size;\n\t\tif (dev->devtype->product == CODA_960 &&\n\t\t    q_data->fourcc == V4L2_PIX_FMT_H264)\n\t\t\tsize += CODA9_PS_SAVE_SIZE;\n\t\tret = coda_alloc_context_buf(ctx, &ctx->workbuf, size,\n\t\t\t\t\t     \"workbuf\");\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tcoda_free_context_buffers(ctx);\n\treturn ret;\n}\n\nstatic int coda_encode_header(struct coda_ctx *ctx, struct vb2_v4l2_buffer *buf,\n\t\t\t      int header_code, u8 *header, int *size)\n{\n\tstruct vb2_buffer *vb = &buf->vb2_buf;\n\tstruct coda_dev *dev = ctx->dev;\n\tstruct coda_q_data *q_data_src;\n\tstruct v4l2_rect *r;\n\tsize_t bufsize;\n\tint ret;\n\tint i;\n\n\tif (dev->devtype->product == CODA_960)\n\t\tmemset(vb2_plane_vaddr(vb, 0), 0, 64);\n\n\tcoda_write(dev, vb2_dma_contig_plane_dma_addr(vb, 0),\n\t\t   CODA_CMD_ENC_HEADER_BB_START);\n\tbufsize = vb2_plane_size(vb, 0);\n\tif (dev->devtype->product == CODA_960)\n\t\tbufsize /= 1024;\n\tcoda_write(dev, bufsize, CODA_CMD_ENC_HEADER_BB_SIZE);\n\tif (dev->devtype->product == CODA_960 &&\n\t    ctx->codec->dst_fourcc == V4L2_PIX_FMT_H264 &&\n\t    header_code == CODA_HEADER_H264_SPS) {\n\t\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\t\tr = &q_data_src->rect;\n\n\t\tif (r->width % 16 || r->height % 16) {\n\t\t\tu32 crop_right = round_up(r->width, 16) -  r->width;\n\t\t\tu32 crop_bottom = round_up(r->height, 16) - r->height;\n\n\t\t\tcoda_write(dev, crop_right,\n\t\t\t\t   CODA9_CMD_ENC_HEADER_FRAME_CROP_H);\n\t\t\tcoda_write(dev, crop_bottom,\n\t\t\t\t   CODA9_CMD_ENC_HEADER_FRAME_CROP_V);\n\t\t\theader_code |= CODA9_HEADER_FRAME_CROP;\n\t\t}\n\t}\n\tcoda_write(dev, header_code, CODA_CMD_ENC_HEADER_CODE);\n\tret = coda_command_sync(ctx, CODA_COMMAND_ENCODE_HEADER);\n\tif (ret < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"CODA_COMMAND_ENCODE_HEADER timeout\\n\");\n\t\treturn ret;\n\t}\n\n\tif (dev->devtype->product == CODA_960) {\n\t\tfor (i = 63; i > 0; i--)\n\t\t\tif (((char *)vb2_plane_vaddr(vb, 0))[i] != 0)\n\t\t\t\tbreak;\n\t\t*size = i + 1;\n\t} else {\n\t\t*size = coda_read(dev, CODA_REG_BIT_WR_PTR(ctx->reg_idx)) -\n\t\t\tcoda_read(dev, CODA_CMD_ENC_HEADER_BB_START);\n\t}\n\tmemcpy(header, vb2_plane_vaddr(vb, 0), *size);\n\n\treturn 0;\n}\n\nstatic u32 coda_slice_mode(struct coda_ctx *ctx)\n{\n\tint size, unit;\n\n\tswitch (ctx->params.slice_mode) {\n\tcase V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE:\n\tdefault:\n\t\treturn 0;\n\tcase V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB:\n\t\tsize = ctx->params.slice_max_mb;\n\t\tunit = 1;\n\t\tbreak;\n\tcase V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES:\n\t\tsize = ctx->params.slice_max_bits;\n\t\tunit = 0;\n\t\tbreak;\n\t}\n\n\treturn ((size & CODA_SLICING_SIZE_MASK) << CODA_SLICING_SIZE_OFFSET) |\n\t       ((unit & CODA_SLICING_UNIT_MASK) << CODA_SLICING_UNIT_OFFSET) |\n\t       ((1 & CODA_SLICING_MODE_MASK) << CODA_SLICING_MODE_OFFSET);\n}\n\nstatic int coda_enc_param_change(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tu32 change_enable = 0;\n\tu32 success;\n\tint ret;\n\n\tif (ctx->params.gop_size_changed) {\n\t\tchange_enable |= CODA_PARAM_CHANGE_RC_GOP;\n\t\tcoda_write(dev, ctx->params.gop_size,\n\t\t\t   CODA_CMD_ENC_PARAM_RC_GOP);\n\t\tctx->gopcounter = ctx->params.gop_size - 1;\n\t\tctx->params.gop_size_changed = false;\n\t}\n\tif (ctx->params.h264_intra_qp_changed) {\n\t\tcoda_dbg(1, ctx, \"parameter change: intra Qp %u\\n\",\n\t\t\t ctx->params.h264_intra_qp);\n\n\t\tif (ctx->params.bitrate) {\n\t\t\tchange_enable |= CODA_PARAM_CHANGE_RC_INTRA_QP;\n\t\t\tcoda_write(dev, ctx->params.h264_intra_qp,\n\t\t\t\t   CODA_CMD_ENC_PARAM_RC_INTRA_QP);\n\t\t}\n\t\tctx->params.h264_intra_qp_changed = false;\n\t}\n\tif (ctx->params.bitrate_changed) {\n\t\tcoda_dbg(1, ctx, \"parameter change: bitrate %u kbit/s\\n\",\n\t\t\t ctx->params.bitrate);\n\t\tchange_enable |= CODA_PARAM_CHANGE_RC_BITRATE;\n\t\tcoda_write(dev, ctx->params.bitrate,\n\t\t\t   CODA_CMD_ENC_PARAM_RC_BITRATE);\n\t\tctx->params.bitrate_changed = false;\n\t}\n\tif (ctx->params.framerate_changed) {\n\t\tcoda_dbg(1, ctx, \"parameter change: frame rate %u/%u Hz\\n\",\n\t\t\t ctx->params.framerate & 0xffff,\n\t\t\t (ctx->params.framerate >> 16) + 1);\n\t\tchange_enable |= CODA_PARAM_CHANGE_RC_FRAME_RATE;\n\t\tcoda_write(dev, ctx->params.framerate,\n\t\t\t   CODA_CMD_ENC_PARAM_RC_FRAME_RATE);\n\t\tctx->params.framerate_changed = false;\n\t}\n\tif (ctx->params.intra_refresh_changed) {\n\t\tcoda_dbg(1, ctx, \"parameter change: intra refresh MBs %u\\n\",\n\t\t\t ctx->params.intra_refresh);\n\t\tchange_enable |= CODA_PARAM_CHANGE_INTRA_MB_NUM;\n\t\tcoda_write(dev, ctx->params.intra_refresh,\n\t\t\t   CODA_CMD_ENC_PARAM_INTRA_MB_NUM);\n\t\tctx->params.intra_refresh_changed = false;\n\t}\n\tif (ctx->params.slice_mode_changed) {\n\t\tchange_enable |= CODA_PARAM_CHANGE_SLICE_MODE;\n\t\tcoda_write(dev, coda_slice_mode(ctx),\n\t\t\t   CODA_CMD_ENC_PARAM_SLICE_MODE);\n\t\tctx->params.slice_mode_changed = false;\n\t}\n\n\tif (!change_enable)\n\t\treturn 0;\n\n\tcoda_write(dev, change_enable, CODA_CMD_ENC_PARAM_CHANGE_ENABLE);\n\n\tret = coda_command_sync(ctx, CODA_COMMAND_RC_CHANGE_PARAMETER);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsuccess = coda_read(dev, CODA_RET_ENC_PARAM_CHANGE_SUCCESS);\n\tif (success != 1)\n\t\tcoda_dbg(1, ctx, \"parameter change failed: %u\\n\", success);\n\n\treturn 0;\n}\n\nstatic phys_addr_t coda_iram_alloc(struct coda_iram_info *iram, size_t size)\n{\n\tphys_addr_t ret;\n\n\tsize = round_up(size, 1024);\n\tif (size > iram->remaining)\n\t\treturn 0;\n\tiram->remaining -= size;\n\n\tret = iram->next_paddr;\n\tiram->next_paddr += size;\n\n\treturn ret;\n}\n\nstatic void coda_setup_iram(struct coda_ctx *ctx)\n{\n\tstruct coda_iram_info *iram_info = &ctx->iram_info;\n\tstruct coda_dev *dev = ctx->dev;\n\tint w64, w128;\n\tint mb_width;\n\tint dbk_bits;\n\tint bit_bits;\n\tint ip_bits;\n\tint me_bits;\n\n\tmemset(iram_info, 0, sizeof(*iram_info));\n\tiram_info->next_paddr = dev->iram.paddr;\n\tiram_info->remaining = dev->iram.size;\n\n\tif (!dev->iram.vaddr)\n\t\treturn;\n\n\tswitch (dev->devtype->product) {\n\tcase CODA_HX4:\n\t\tdbk_bits = CODA7_USE_HOST_DBK_ENABLE;\n\t\tbit_bits = CODA7_USE_HOST_BIT_ENABLE;\n\t\tip_bits = CODA7_USE_HOST_IP_ENABLE;\n\t\tme_bits = CODA7_USE_HOST_ME_ENABLE;\n\t\tbreak;\n\tcase CODA_7541:\n\t\tdbk_bits = CODA7_USE_HOST_DBK_ENABLE | CODA7_USE_DBK_ENABLE;\n\t\tbit_bits = CODA7_USE_HOST_BIT_ENABLE | CODA7_USE_BIT_ENABLE;\n\t\tip_bits = CODA7_USE_HOST_IP_ENABLE | CODA7_USE_IP_ENABLE;\n\t\tme_bits = CODA7_USE_HOST_ME_ENABLE | CODA7_USE_ME_ENABLE;\n\t\tbreak;\n\tcase CODA_960:\n\t\tdbk_bits = CODA9_USE_HOST_DBK_ENABLE | CODA9_USE_DBK_ENABLE;\n\t\tbit_bits = CODA9_USE_HOST_BIT_ENABLE | CODA7_USE_BIT_ENABLE;\n\t\tip_bits = CODA9_USE_HOST_IP_ENABLE | CODA7_USE_IP_ENABLE;\n\t\tme_bits = 0;\n\t\tbreak;\n\tdefault:  \n\t\treturn;\n\t}\n\n\tif (ctx->inst_type == CODA_INST_ENCODER) {\n\t\tstruct coda_q_data *q_data_src;\n\n\t\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\t\tmb_width = DIV_ROUND_UP(q_data_src->rect.width, 16);\n\t\tw128 = mb_width * 128;\n\t\tw64 = mb_width * 64;\n\n\t\t \n\t\tif (dev->devtype->product == CODA_HX4 ||\n\t\t    dev->devtype->product == CODA_7541) {\n\t\t\tiram_info->search_ram_size = round_up(mb_width * 16 *\n\t\t\t\t\t\t\t      36 + 2048, 1024);\n\t\t\tiram_info->search_ram_paddr = coda_iram_alloc(iram_info,\n\t\t\t\t\t\tiram_info->search_ram_size);\n\t\t\tif (!iram_info->search_ram_paddr) {\n\t\t\t\tpr_err(\"IRAM is smaller than the search ram size\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tiram_info->axi_sram_use |= me_bits;\n\t\t}\n\n\t\t \n\t\tiram_info->buf_dbk_y_use = coda_iram_alloc(iram_info, w64);\n\t\tiram_info->buf_dbk_c_use = coda_iram_alloc(iram_info, w64);\n\t\tif (!iram_info->buf_dbk_y_use || !iram_info->buf_dbk_c_use)\n\t\t\tgoto out;\n\t\tiram_info->axi_sram_use |= dbk_bits;\n\n\t\tiram_info->buf_bit_use = coda_iram_alloc(iram_info, w128);\n\t\tif (!iram_info->buf_bit_use)\n\t\t\tgoto out;\n\t\tiram_info->axi_sram_use |= bit_bits;\n\n\t\tiram_info->buf_ip_ac_dc_use = coda_iram_alloc(iram_info, w128);\n\t\tif (!iram_info->buf_ip_ac_dc_use)\n\t\t\tgoto out;\n\t\tiram_info->axi_sram_use |= ip_bits;\n\n\t\t \n\t} else if (ctx->inst_type == CODA_INST_DECODER) {\n\t\tstruct coda_q_data *q_data_dst;\n\n\t\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\tmb_width = DIV_ROUND_UP(q_data_dst->width, 16);\n\t\tw128 = mb_width * 128;\n\n\t\tiram_info->buf_dbk_y_use = coda_iram_alloc(iram_info, w128);\n\t\tiram_info->buf_dbk_c_use = coda_iram_alloc(iram_info, w128);\n\t\tif (!iram_info->buf_dbk_y_use || !iram_info->buf_dbk_c_use)\n\t\t\tgoto out;\n\t\tiram_info->axi_sram_use |= dbk_bits;\n\n\t\tiram_info->buf_bit_use = coda_iram_alloc(iram_info, w128);\n\t\tif (!iram_info->buf_bit_use)\n\t\t\tgoto out;\n\t\tiram_info->axi_sram_use |= bit_bits;\n\n\t\tiram_info->buf_ip_ac_dc_use = coda_iram_alloc(iram_info, w128);\n\t\tif (!iram_info->buf_ip_ac_dc_use)\n\t\t\tgoto out;\n\t\tiram_info->axi_sram_use |= ip_bits;\n\n\t\t \n\t}\n\nout:\n\tif (!(iram_info->axi_sram_use & CODA7_USE_HOST_IP_ENABLE))\n\t\tcoda_dbg(1, ctx, \"IRAM smaller than needed\\n\");\n\n\tif (dev->devtype->product == CODA_HX4 ||\n\t    dev->devtype->product == CODA_7541) {\n\t\t \n\t\tif (ctx->inst_type == CODA_INST_DECODER) {\n\t\t\t \n\t\t\tiram_info->axi_sram_use &= ~(CODA7_USE_HOST_IP_ENABLE |\n\t\t\t\t\t\t     CODA7_USE_IP_ENABLE);\n\t\t} else {\n\t\t\t \n\t\t\tiram_info->axi_sram_use &= ~(CODA7_USE_HOST_IP_ENABLE |\n\t\t\t\t\t\t     CODA7_USE_HOST_DBK_ENABLE |\n\t\t\t\t\t\t     CODA7_USE_IP_ENABLE |\n\t\t\t\t\t\t     CODA7_USE_DBK_ENABLE);\n\t\t}\n\t}\n}\n\nstatic u32 coda_supported_firmwares[] = {\n\tCODA_FIRMWARE_VERNUM(CODA_DX6, 2, 2, 5),\n\tCODA_FIRMWARE_VERNUM(CODA_HX4, 1, 4, 50),\n\tCODA_FIRMWARE_VERNUM(CODA_7541, 1, 4, 50),\n\tCODA_FIRMWARE_VERNUM(CODA_960, 2, 1, 5),\n\tCODA_FIRMWARE_VERNUM(CODA_960, 2, 1, 9),\n\tCODA_FIRMWARE_VERNUM(CODA_960, 2, 3, 10),\n\tCODA_FIRMWARE_VERNUM(CODA_960, 3, 1, 1),\n};\n\nstatic bool coda_firmware_supported(u32 vernum)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(coda_supported_firmwares); i++)\n\t\tif (vernum == coda_supported_firmwares[i])\n\t\t\treturn true;\n\treturn false;\n}\n\nint coda_check_firmware(struct coda_dev *dev)\n{\n\tu16 product, major, minor, release;\n\tu32 data;\n\tint ret;\n\n\tret = clk_prepare_enable(dev->clk_per);\n\tif (ret)\n\t\tgoto err_clk_per;\n\n\tret = clk_prepare_enable(dev->clk_ahb);\n\tif (ret)\n\t\tgoto err_clk_ahb;\n\n\tcoda_write(dev, 0, CODA_CMD_FIRMWARE_VERNUM);\n\tcoda_write(dev, CODA_REG_BIT_BUSY_FLAG, CODA_REG_BIT_BUSY);\n\tcoda_write(dev, 0, CODA_REG_BIT_RUN_INDEX);\n\tcoda_write(dev, 0, CODA_REG_BIT_RUN_COD_STD);\n\tcoda_write(dev, CODA_COMMAND_FIRMWARE_GET, CODA_REG_BIT_RUN_COMMAND);\n\tif (coda_wait_timeout(dev)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"firmware get command error\\n\");\n\t\tret = -EIO;\n\t\tgoto err_run_cmd;\n\t}\n\n\tif (dev->devtype->product == CODA_960) {\n\t\tdata = coda_read(dev, CODA9_CMD_FIRMWARE_CODE_REV);\n\t\tv4l2_info(&dev->v4l2_dev, \"Firmware code revision: %d\\n\",\n\t\t\t  data);\n\t}\n\n\t \n\tdata = coda_read(dev, CODA_CMD_FIRMWARE_VERNUM);\n\tproduct = CODA_FIRMWARE_PRODUCT(data);\n\tmajor = CODA_FIRMWARE_MAJOR(data);\n\tminor = CODA_FIRMWARE_MINOR(data);\n\trelease = CODA_FIRMWARE_RELEASE(data);\n\n\tclk_disable_unprepare(dev->clk_per);\n\tclk_disable_unprepare(dev->clk_ahb);\n\n\tif (product != dev->devtype->product) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Wrong firmware. Hw: %s, Fw: %s, Version: %u.%u.%u\\n\",\n\t\t\t coda_product_name(dev->devtype->product),\n\t\t\t coda_product_name(product), major, minor, release);\n\t\treturn -EINVAL;\n\t}\n\n\tv4l2_info(&dev->v4l2_dev, \"Initialized %s.\\n\",\n\t\t  coda_product_name(product));\n\n\tif (coda_firmware_supported(data)) {\n\t\tv4l2_info(&dev->v4l2_dev, \"Firmware version: %u.%u.%u\\n\",\n\t\t\t  major, minor, release);\n\t} else {\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"Unsupported firmware version: %u.%u.%u\\n\",\n\t\t\t  major, minor, release);\n\t}\n\n\treturn 0;\n\nerr_run_cmd:\n\tclk_disable_unprepare(dev->clk_ahb);\nerr_clk_ahb:\n\tclk_disable_unprepare(dev->clk_per);\nerr_clk_per:\n\treturn ret;\n}\n\nstatic void coda9_set_frame_cache(struct coda_ctx *ctx, u32 fourcc)\n{\n\tu32 cache_size, cache_config;\n\n\tif (ctx->tiled_map_type == GDI_LINEAR_FRAME_MAP) {\n\t\t \n\t\tcache_size = 0x20262024;\n\t\tcache_config = 2 << CODA9_CACHE_PAGEMERGE_OFFSET;\n\t} else {\n\t\t \n\t\tcache_size = 0x02440243;\n\t\tcache_config = 1 << CODA9_CACHE_PAGEMERGE_OFFSET;\n\t}\n\tcoda_write(ctx->dev, cache_size, CODA9_CMD_SET_FRAME_CACHE_SIZE);\n\tif (fourcc == V4L2_PIX_FMT_NV12 || fourcc == V4L2_PIX_FMT_YUYV) {\n\t\tcache_config |= 32 << CODA9_CACHE_LUMA_BUFFER_SIZE_OFFSET |\n\t\t\t\t16 << CODA9_CACHE_CR_BUFFER_SIZE_OFFSET |\n\t\t\t\t0 << CODA9_CACHE_CB_BUFFER_SIZE_OFFSET;\n\t} else {\n\t\tcache_config |= 32 << CODA9_CACHE_LUMA_BUFFER_SIZE_OFFSET |\n\t\t\t\t8 << CODA9_CACHE_CR_BUFFER_SIZE_OFFSET |\n\t\t\t\t8 << CODA9_CACHE_CB_BUFFER_SIZE_OFFSET;\n\t}\n\tcoda_write(ctx->dev, cache_config, CODA9_CMD_SET_FRAME_CACHE_CONFIG);\n}\n\n \n\nstatic int coda_encoder_reqbufs(struct coda_ctx *ctx,\n\t\t\t\tstruct v4l2_requestbuffers *rb)\n{\n\tstruct coda_q_data *q_data_src;\n\tint ret;\n\n\tif (rb->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn 0;\n\n\tif (rb->count) {\n\t\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\t\tret = coda_alloc_context_buffers(ctx, q_data_src);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tcoda_free_context_buffers(ctx);\n\t}\n\n\treturn 0;\n}\n\nstatic int coda_start_encoding(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tstruct v4l2_device *v4l2_dev = &dev->v4l2_dev;\n\tstruct coda_q_data *q_data_src, *q_data_dst;\n\tu32 bitstream_buf, bitstream_size;\n\tstruct vb2_v4l2_buffer *buf;\n\tint gamma, ret, value;\n\tu32 dst_fourcc;\n\tint num_fb;\n\tu32 stride;\n\n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tdst_fourcc = q_data_dst->fourcc;\n\n\tbuf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tbitstream_buf = vb2_dma_contig_plane_dma_addr(&buf->vb2_buf, 0);\n\tbitstream_size = q_data_dst->sizeimage;\n\n\tif (!coda_is_initialized(dev)) {\n\t\tv4l2_err(v4l2_dev, \"coda is not initialized.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (dst_fourcc == V4L2_PIX_FMT_JPEG) {\n\t\tif (!ctx->params.jpeg_qmat_tab[0]) {\n\t\t\tctx->params.jpeg_qmat_tab[0] = kmalloc(64, GFP_KERNEL);\n\t\t\tif (!ctx->params.jpeg_qmat_tab[0])\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!ctx->params.jpeg_qmat_tab[1]) {\n\t\t\tctx->params.jpeg_qmat_tab[1] = kmalloc(64, GFP_KERNEL);\n\t\t\tif (!ctx->params.jpeg_qmat_tab[1])\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcoda_set_jpeg_compression_quality(ctx, ctx->params.jpeg_quality);\n\t}\n\n\tmutex_lock(&dev->coda_mutex);\n\n\tcoda_write(dev, ctx->parabuf.paddr, CODA_REG_BIT_PARA_BUF_ADDR);\n\tcoda_write(dev, bitstream_buf, CODA_REG_BIT_RD_PTR(ctx->reg_idx));\n\tcoda_write(dev, bitstream_buf, CODA_REG_BIT_WR_PTR(ctx->reg_idx));\n\tswitch (dev->devtype->product) {\n\tcase CODA_DX6:\n\t\tcoda_write(dev, CODADX6_STREAM_BUF_DYNALLOC_EN |\n\t\t\tCODADX6_STREAM_BUF_PIC_RESET, CODA_REG_BIT_STREAM_CTRL);\n\t\tbreak;\n\tcase CODA_960:\n\t\tcoda_write(dev, 0, CODA9_GDI_WPROT_RGN_EN);\n\t\tfallthrough;\n\tcase CODA_HX4:\n\tcase CODA_7541:\n\t\tcoda_write(dev, CODA7_STREAM_BUF_DYNALLOC_EN |\n\t\t\tCODA7_STREAM_BUF_PIC_RESET, CODA_REG_BIT_STREAM_CTRL);\n\t\tbreak;\n\t}\n\n\tctx->frame_mem_ctrl &= ~(CODA_FRAME_CHROMA_INTERLEAVE | (0x3 << 9) |\n\t\t\t\t CODA9_FRAME_TILED2LINEAR);\n\tif (q_data_src->fourcc == V4L2_PIX_FMT_NV12)\n\t\tctx->frame_mem_ctrl |= CODA_FRAME_CHROMA_INTERLEAVE;\n\tif (ctx->tiled_map_type == GDI_TILED_FRAME_MB_RASTER_MAP)\n\t\tctx->frame_mem_ctrl |= (0x3 << 9) | CODA9_FRAME_TILED2LINEAR;\n\tcoda_write(dev, ctx->frame_mem_ctrl, CODA_REG_BIT_FRAME_MEM_CTRL);\n\n\tif (dev->devtype->product == CODA_DX6) {\n\t\t \n\t\tcoda_write(dev, dev->iram.paddr,\n\t\t\t   CODADX6_REG_BIT_SEARCH_RAM_BASE_ADDR);\n\t}\n\n\t \n\tvalue = 0;\n\tswitch (dev->devtype->product) {\n\tcase CODA_DX6:\n\t\tvalue = (q_data_src->rect.width & CODADX6_PICWIDTH_MASK)\n\t\t\t<< CODADX6_PICWIDTH_OFFSET;\n\t\tvalue |= (q_data_src->rect.height & CODADX6_PICHEIGHT_MASK)\n\t\t\t << CODA_PICHEIGHT_OFFSET;\n\t\tbreak;\n\tcase CODA_HX4:\n\tcase CODA_7541:\n\t\tif (dst_fourcc == V4L2_PIX_FMT_H264) {\n\t\t\tvalue = (round_up(q_data_src->rect.width, 16) &\n\t\t\t\t CODA7_PICWIDTH_MASK) << CODA7_PICWIDTH_OFFSET;\n\t\t\tvalue |= (round_up(q_data_src->rect.height, 16) &\n\t\t\t\t CODA7_PICHEIGHT_MASK) << CODA_PICHEIGHT_OFFSET;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase CODA_960:\n\t\tvalue = (q_data_src->rect.width & CODA7_PICWIDTH_MASK)\n\t\t\t<< CODA7_PICWIDTH_OFFSET;\n\t\tvalue |= (q_data_src->rect.height & CODA7_PICHEIGHT_MASK)\n\t\t\t << CODA_PICHEIGHT_OFFSET;\n\t}\n\tcoda_write(dev, value, CODA_CMD_ENC_SEQ_SRC_SIZE);\n\tif (dst_fourcc == V4L2_PIX_FMT_JPEG)\n\t\tctx->params.framerate = 0;\n\tcoda_write(dev, ctx->params.framerate,\n\t\t   CODA_CMD_ENC_SEQ_SRC_F_RATE);\n\n\tctx->params.codec_mode = ctx->codec->mode;\n\tswitch (dst_fourcc) {\n\tcase V4L2_PIX_FMT_MPEG4:\n\t\tif (dev->devtype->product == CODA_960)\n\t\t\tcoda_write(dev, CODA9_STD_MPEG4,\n\t\t\t\t   CODA_CMD_ENC_SEQ_COD_STD);\n\t\telse\n\t\t\tcoda_write(dev, CODA_STD_MPEG4,\n\t\t\t\t   CODA_CMD_ENC_SEQ_COD_STD);\n\t\tcoda_write(dev, 0, CODA_CMD_ENC_SEQ_MP4_PARA);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_H264:\n\t\tif (dev->devtype->product == CODA_960)\n\t\t\tcoda_write(dev, CODA9_STD_H264,\n\t\t\t\t   CODA_CMD_ENC_SEQ_COD_STD);\n\t\telse\n\t\t\tcoda_write(dev, CODA_STD_H264,\n\t\t\t\t   CODA_CMD_ENC_SEQ_COD_STD);\n\t\tvalue = ((ctx->params.h264_disable_deblocking_filter_idc &\n\t\t\t  CODA_264PARAM_DISABLEDEBLK_MASK) <<\n\t\t\t CODA_264PARAM_DISABLEDEBLK_OFFSET) |\n\t\t\t((ctx->params.h264_slice_alpha_c0_offset_div2 &\n\t\t\t  CODA_264PARAM_DEBLKFILTEROFFSETALPHA_MASK) <<\n\t\t\t CODA_264PARAM_DEBLKFILTEROFFSETALPHA_OFFSET) |\n\t\t\t((ctx->params.h264_slice_beta_offset_div2 &\n\t\t\t  CODA_264PARAM_DEBLKFILTEROFFSETBETA_MASK) <<\n\t\t\t CODA_264PARAM_DEBLKFILTEROFFSETBETA_OFFSET) |\n\t\t\t(ctx->params.h264_constrained_intra_pred_flag <<\n\t\t\t CODA_264PARAM_CONSTRAINEDINTRAPREDFLAG_OFFSET) |\n\t\t\t(ctx->params.h264_chroma_qp_index_offset &\n\t\t\t CODA_264PARAM_CHROMAQPOFFSET_MASK);\n\t\tcoda_write(dev, value, CODA_CMD_ENC_SEQ_264_PARA);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_JPEG:\n\t\tcoda_write(dev, 0, CODA_CMD_ENC_SEQ_JPG_PARA);\n\t\tcoda_write(dev, ctx->params.jpeg_restart_interval,\n\t\t\t\tCODA_CMD_ENC_SEQ_JPG_RST_INTERVAL);\n\t\tcoda_write(dev, 0, CODA_CMD_ENC_SEQ_JPG_THUMB_EN);\n\t\tcoda_write(dev, 0, CODA_CMD_ENC_SEQ_JPG_THUMB_SIZE);\n\t\tcoda_write(dev, 0, CODA_CMD_ENC_SEQ_JPG_THUMB_OFFSET);\n\n\t\tcoda_jpeg_write_tables(ctx);\n\t\tbreak;\n\tdefault:\n\t\tv4l2_err(v4l2_dev,\n\t\t\t \"dst format (0x%08x) invalid.\\n\", dst_fourcc);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (dst_fourcc != V4L2_PIX_FMT_JPEG) {\n\t\tvalue = coda_slice_mode(ctx);\n\t\tcoda_write(dev, value, CODA_CMD_ENC_SEQ_SLICE_MODE);\n\t\tvalue = ctx->params.gop_size;\n\t\tcoda_write(dev, value, CODA_CMD_ENC_SEQ_GOP_SIZE);\n\t}\n\n\tif (ctx->params.bitrate && (ctx->params.frame_rc_enable ||\n\t\t\t\t    ctx->params.mb_rc_enable)) {\n\t\tctx->params.bitrate_changed = false;\n\t\tctx->params.h264_intra_qp_changed = false;\n\n\t\t \n\t\tvalue = (ctx->params.bitrate & CODA_RATECONTROL_BITRATE_MASK)\n\t\t\t<< CODA_RATECONTROL_BITRATE_OFFSET;\n\t\tvalue |=  1 & CODA_RATECONTROL_ENABLE_MASK;\n\t\tvalue |= (ctx->params.vbv_delay &\n\t\t\t  CODA_RATECONTROL_INITIALDELAY_MASK)\n\t\t\t << CODA_RATECONTROL_INITIALDELAY_OFFSET;\n\t\tif (dev->devtype->product == CODA_960)\n\t\t\tvalue |= BIT(31);  \n\t} else {\n\t\tvalue = 0;\n\t}\n\tcoda_write(dev, value, CODA_CMD_ENC_SEQ_RC_PARA);\n\n\tcoda_write(dev, ctx->params.vbv_size, CODA_CMD_ENC_SEQ_RC_BUF_SIZE);\n\tcoda_write(dev, ctx->params.intra_refresh,\n\t\t   CODA_CMD_ENC_SEQ_INTRA_REFRESH);\n\n\tcoda_write(dev, bitstream_buf, CODA_CMD_ENC_SEQ_BB_START);\n\tcoda_write(dev, bitstream_size / 1024, CODA_CMD_ENC_SEQ_BB_SIZE);\n\n\n\tvalue = 0;\n\tif (dev->devtype->product == CODA_960)\n\t\tgamma = CODA9_DEFAULT_GAMMA;\n\telse\n\t\tgamma = CODA_DEFAULT_GAMMA;\n\tif (gamma > 0) {\n\t\tcoda_write(dev, (gamma & CODA_GAMMA_MASK) << CODA_GAMMA_OFFSET,\n\t\t\t   CODA_CMD_ENC_SEQ_RC_GAMMA);\n\t}\n\n\tif (ctx->params.h264_min_qp || ctx->params.h264_max_qp) {\n\t\tcoda_write(dev,\n\t\t\t   ctx->params.h264_min_qp << CODA_QPMIN_OFFSET |\n\t\t\t   ctx->params.h264_max_qp << CODA_QPMAX_OFFSET,\n\t\t\t   CODA_CMD_ENC_SEQ_RC_QP_MIN_MAX);\n\t}\n\tif (dev->devtype->product == CODA_960) {\n\t\tif (ctx->params.h264_max_qp)\n\t\t\tvalue |= 1 << CODA9_OPTION_RCQPMAX_OFFSET;\n\t\tif (CODA_DEFAULT_GAMMA > 0)\n\t\t\tvalue |= 1 << CODA9_OPTION_GAMMA_OFFSET;\n\t} else {\n\t\tif (CODA_DEFAULT_GAMMA > 0) {\n\t\t\tif (dev->devtype->product == CODA_DX6)\n\t\t\t\tvalue |= 1 << CODADX6_OPTION_GAMMA_OFFSET;\n\t\t\telse\n\t\t\t\tvalue |= 1 << CODA7_OPTION_GAMMA_OFFSET;\n\t\t}\n\t\tif (ctx->params.h264_min_qp)\n\t\t\tvalue |= 1 << CODA7_OPTION_RCQPMIN_OFFSET;\n\t\tif (ctx->params.h264_max_qp)\n\t\t\tvalue |= 1 << CODA7_OPTION_RCQPMAX_OFFSET;\n\t}\n\tcoda_write(dev, value, CODA_CMD_ENC_SEQ_OPTION);\n\n\tif (ctx->params.frame_rc_enable && !ctx->params.mb_rc_enable)\n\t\tvalue = 1;\n\telse\n\t\tvalue = 0;\n\tcoda_write(dev, value, CODA_CMD_ENC_SEQ_RC_INTERVAL_MODE);\n\n\tcoda_setup_iram(ctx);\n\n\tif (dst_fourcc == V4L2_PIX_FMT_H264) {\n\t\tswitch (dev->devtype->product) {\n\t\tcase CODA_DX6:\n\t\t\tvalue = FMO_SLICE_SAVE_BUF_SIZE << 7;\n\t\t\tcoda_write(dev, value, CODADX6_CMD_ENC_SEQ_FMO);\n\t\t\tbreak;\n\t\tcase CODA_HX4:\n\t\tcase CODA_7541:\n\t\t\tcoda_write(dev, ctx->iram_info.search_ram_paddr,\n\t\t\t\t\tCODA7_CMD_ENC_SEQ_SEARCH_BASE);\n\t\t\tcoda_write(dev, ctx->iram_info.search_ram_size,\n\t\t\t\t\tCODA7_CMD_ENC_SEQ_SEARCH_SIZE);\n\t\t\tbreak;\n\t\tcase CODA_960:\n\t\t\tcoda_write(dev, 0, CODA9_CMD_ENC_SEQ_ME_OPTION);\n\t\t\tcoda_write(dev, 0, CODA9_CMD_ENC_SEQ_INTRA_WEIGHT);\n\t\t}\n\t}\n\n\tret = coda_command_sync(ctx, CODA_COMMAND_SEQ_INIT);\n\tif (ret < 0) {\n\t\tv4l2_err(v4l2_dev, \"CODA_COMMAND_SEQ_INIT timeout\\n\");\n\t\tgoto out;\n\t}\n\n\tif (coda_read(dev, CODA_RET_ENC_SEQ_SUCCESS) == 0) {\n\t\tv4l2_err(v4l2_dev, \"CODA_COMMAND_SEQ_INIT failed\\n\");\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tctx->initialized = 1;\n\n\tif (dst_fourcc != V4L2_PIX_FMT_JPEG) {\n\t\tif (dev->devtype->product == CODA_960)\n\t\t\tctx->num_internal_frames = 4;\n\t\telse\n\t\t\tctx->num_internal_frames = 2;\n\t\tret = coda_alloc_framebuffers(ctx, q_data_src, dst_fourcc);\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(v4l2_dev, \"failed to allocate framebuffers\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tnum_fb = 2;\n\t\tstride = q_data_src->bytesperline;\n\t} else {\n\t\tctx->num_internal_frames = 0;\n\t\tnum_fb = 0;\n\t\tstride = 0;\n\t}\n\tcoda_write(dev, num_fb, CODA_CMD_SET_FRAME_BUF_NUM);\n\tcoda_write(dev, stride, CODA_CMD_SET_FRAME_BUF_STRIDE);\n\n\tif (dev->devtype->product == CODA_HX4 ||\n\t    dev->devtype->product == CODA_7541) {\n\t\tcoda_write(dev, q_data_src->bytesperline,\n\t\t\t\tCODA7_CMD_SET_FRAME_SOURCE_BUF_STRIDE);\n\t}\n\tif (dev->devtype->product != CODA_DX6) {\n\t\tcoda_write(dev, ctx->iram_info.buf_bit_use,\n\t\t\t\tCODA7_CMD_SET_FRAME_AXI_BIT_ADDR);\n\t\tcoda_write(dev, ctx->iram_info.buf_ip_ac_dc_use,\n\t\t\t\tCODA7_CMD_SET_FRAME_AXI_IPACDC_ADDR);\n\t\tcoda_write(dev, ctx->iram_info.buf_dbk_y_use,\n\t\t\t\tCODA7_CMD_SET_FRAME_AXI_DBKY_ADDR);\n\t\tcoda_write(dev, ctx->iram_info.buf_dbk_c_use,\n\t\t\t\tCODA7_CMD_SET_FRAME_AXI_DBKC_ADDR);\n\t\tcoda_write(dev, ctx->iram_info.buf_ovl_use,\n\t\t\t\tCODA7_CMD_SET_FRAME_AXI_OVL_ADDR);\n\t\tif (dev->devtype->product == CODA_960) {\n\t\t\tcoda_write(dev, ctx->iram_info.buf_btp_use,\n\t\t\t\t\tCODA9_CMD_SET_FRAME_AXI_BTP_ADDR);\n\n\t\t\tcoda9_set_frame_cache(ctx, q_data_src->fourcc);\n\n\t\t\t \n\t\t\tcoda_write(dev, ctx->internal_frames[2].buf.paddr,\n\t\t\t\t   CODA9_CMD_SET_FRAME_SUBSAMP_A);\n\t\t\tcoda_write(dev, ctx->internal_frames[3].buf.paddr,\n\t\t\t\t   CODA9_CMD_SET_FRAME_SUBSAMP_B);\n\t\t}\n\t}\n\n\tret = coda_command_sync(ctx, CODA_COMMAND_SET_FRAME_BUF);\n\tif (ret < 0) {\n\t\tv4l2_err(v4l2_dev, \"CODA_COMMAND_SET_FRAME_BUF timeout\\n\");\n\t\tgoto out;\n\t}\n\n\tcoda_dbg(1, ctx, \"start encoding %dx%d %4.4s->%4.4s @ %d/%d Hz\\n\",\n\t\t q_data_src->rect.width, q_data_src->rect.height,\n\t\t (char *)&ctx->codec->src_fourcc, (char *)&dst_fourcc,\n\t\t ctx->params.framerate & 0xffff,\n\t\t (ctx->params.framerate >> 16) + 1);\n\n\t \n\tbuf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tswitch (dst_fourcc) {\n\tcase V4L2_PIX_FMT_H264:\n\t\t \n\t\tret = coda_encode_header(ctx, buf, CODA_HEADER_H264_SPS,\n\t\t\t\t\t &ctx->vpu_header[0][0],\n\t\t\t\t\t &ctx->vpu_header_size[0]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (ctx->dev->devtype->product != CODA_960 &&\n\t\t    ((q_data_src->rect.width % 16) ||\n\t\t     (q_data_src->rect.height % 16))) {\n\t\t\tret = coda_h264_sps_fixup(ctx, q_data_src->rect.width,\n\t\t\t\t\t\t  q_data_src->rect.height,\n\t\t\t\t\t\t  &ctx->vpu_header[0][0],\n\t\t\t\t\t\t  &ctx->vpu_header_size[0],\n\t\t\t\t\t\t  sizeof(ctx->vpu_header[0]));\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = coda_encode_header(ctx, buf, CODA_HEADER_H264_PPS,\n\t\t\t\t\t &ctx->vpu_header[1][0],\n\t\t\t\t\t &ctx->vpu_header_size[1]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tctx->vpu_header_size[2] = coda_h264_padding(\n\t\t\t\t\t(ctx->vpu_header_size[0] +\n\t\t\t\t\t ctx->vpu_header_size[1]),\n\t\t\t\t\t ctx->vpu_header[2]);\n\t\tbreak;\n\tcase V4L2_PIX_FMT_MPEG4:\n\t\t \n\t\tret = coda_encode_header(ctx, buf, CODA_HEADER_MP4V_VOS,\n\t\t\t\t\t &ctx->vpu_header[0][0],\n\t\t\t\t\t &ctx->vpu_header_size[0]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = coda_encode_header(ctx, buf, CODA_HEADER_MP4V_VIS,\n\t\t\t\t\t &ctx->vpu_header[1][0],\n\t\t\t\t\t &ctx->vpu_header_size[1]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = coda_encode_header(ctx, buf, CODA_HEADER_MP4V_VOL,\n\t\t\t\t\t &ctx->vpu_header[2][0],\n\t\t\t\t\t &ctx->vpu_header_size[2]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&dev->coda_mutex);\n\treturn ret;\n}\n\nstatic int coda_prepare_encode(struct coda_ctx *ctx)\n{\n\tstruct coda_q_data *q_data_src, *q_data_dst;\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct coda_dev *dev = ctx->dev;\n\tint force_ipicture;\n\tint quant_param = 0;\n\tu32 pic_stream_buffer_addr, pic_stream_buffer_size;\n\tu32 rot_mode = 0;\n\tu32 dst_fourcc;\n\tu32 reg;\n\tint ret;\n\n\tret = coda_enc_param_change(ctx);\n\tif (ret < 0) {\n\t\tv4l2_warn(&ctx->dev->v4l2_dev, \"parameter change failed: %d\\n\",\n\t\t\t  ret);\n\t}\n\n\tsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tdst_fourcc = q_data_dst->fourcc;\n\n\tsrc_buf->sequence = ctx->osequence;\n\tdst_buf->sequence = ctx->osequence;\n\tctx->osequence++;\n\n\tforce_ipicture = ctx->params.force_ipicture;\n\tif (force_ipicture)\n\t\tctx->params.force_ipicture = false;\n\telse if (ctx->params.gop_size != 0 &&\n\t\t (src_buf->sequence % ctx->params.gop_size) == 0)\n\t\tforce_ipicture = 1;\n\n\t \n\tif (!force_ipicture) {\n\t\tsrc_buf->flags |= V4L2_BUF_FLAG_PFRAME;\n\t\tsrc_buf->flags &= ~V4L2_BUF_FLAG_KEYFRAME;\n\t} else {\n\t\tsrc_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;\n\t\tsrc_buf->flags &= ~V4L2_BUF_FLAG_PFRAME;\n\t}\n\n\tif (dev->devtype->product == CODA_960)\n\t\tcoda_set_gdi_regs(ctx);\n\n\t \n\tif (src_buf->sequence == 0 || force_ipicture) {\n\t\tpic_stream_buffer_addr =\n\t\t\tvb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0) +\n\t\t\tctx->vpu_header_size[0] +\n\t\t\tctx->vpu_header_size[1] +\n\t\t\tctx->vpu_header_size[2];\n\t\tpic_stream_buffer_size = q_data_dst->sizeimage -\n\t\t\tctx->vpu_header_size[0] -\n\t\t\tctx->vpu_header_size[1] -\n\t\t\tctx->vpu_header_size[2];\n\t\tmemcpy(vb2_plane_vaddr(&dst_buf->vb2_buf, 0),\n\t\t       &ctx->vpu_header[0][0], ctx->vpu_header_size[0]);\n\t\tmemcpy(vb2_plane_vaddr(&dst_buf->vb2_buf, 0)\n\t\t\t+ ctx->vpu_header_size[0], &ctx->vpu_header[1][0],\n\t\t\tctx->vpu_header_size[1]);\n\t\tmemcpy(vb2_plane_vaddr(&dst_buf->vb2_buf, 0)\n\t\t\t+ ctx->vpu_header_size[0] + ctx->vpu_header_size[1],\n\t\t\t&ctx->vpu_header[2][0], ctx->vpu_header_size[2]);\n\t} else {\n\t\tpic_stream_buffer_addr =\n\t\t\tvb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\t\tpic_stream_buffer_size = q_data_dst->sizeimage;\n\t}\n\n\tif (force_ipicture) {\n\t\tswitch (dst_fourcc) {\n\t\tcase V4L2_PIX_FMT_H264:\n\t\t\tquant_param = ctx->params.h264_intra_qp;\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_MPEG4:\n\t\t\tquant_param = ctx->params.mpeg4_intra_qp;\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_JPEG:\n\t\t\tquant_param = 30;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv4l2_warn(&ctx->dev->v4l2_dev,\n\t\t\t\t\"cannot set intra qp, fmt not supported\\n\");\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (dst_fourcc) {\n\t\tcase V4L2_PIX_FMT_H264:\n\t\t\tquant_param = ctx->params.h264_inter_qp;\n\t\t\tbreak;\n\t\tcase V4L2_PIX_FMT_MPEG4:\n\t\t\tquant_param = ctx->params.mpeg4_inter_qp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv4l2_warn(&ctx->dev->v4l2_dev,\n\t\t\t\t\"cannot set inter qp, fmt not supported\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ctx->params.rot_mode)\n\t\trot_mode = CODA_ROT_MIR_ENABLE | ctx->params.rot_mode;\n\tcoda_write(dev, rot_mode, CODA_CMD_ENC_PIC_ROT_MODE);\n\tcoda_write(dev, quant_param, CODA_CMD_ENC_PIC_QS);\n\n\tif (dev->devtype->product == CODA_960) {\n\t\tcoda_write(dev, 4 , CODA9_CMD_ENC_PIC_SRC_INDEX);\n\t\tcoda_write(dev, q_data_src->bytesperline,\n\t\t\t   CODA9_CMD_ENC_PIC_SRC_STRIDE);\n\t\tcoda_write(dev, 0, CODA9_CMD_ENC_PIC_SUB_FRAME_SYNC);\n\n\t\treg = CODA9_CMD_ENC_PIC_SRC_ADDR_Y;\n\t} else {\n\t\treg = CODA_CMD_ENC_PIC_SRC_ADDR_Y;\n\t}\n\tcoda_write_base(ctx, q_data_src, src_buf, reg);\n\n\tcoda_write(dev, force_ipicture << 1 & 0x2,\n\t\t   CODA_CMD_ENC_PIC_OPTION);\n\n\tcoda_write(dev, pic_stream_buffer_addr, CODA_CMD_ENC_PIC_BB_START);\n\tcoda_write(dev, pic_stream_buffer_size / 1024,\n\t\t   CODA_CMD_ENC_PIC_BB_SIZE);\n\n\tif (!ctx->streamon_out) {\n\t\t \n\t\tctx->bit_stream_param |= CODA_BIT_STREAM_END_FLAG;\n\t\tcoda_write(dev, ctx->bit_stream_param,\n\t\t\t   CODA_REG_BIT_BIT_STREAM_PARAM);\n\t}\n\n\tif (dev->devtype->product != CODA_DX6)\n\t\tcoda_write(dev, ctx->iram_info.axi_sram_use,\n\t\t\t\tCODA7_REG_BIT_AXI_SRAM_USE);\n\n\ttrace_coda_enc_pic_run(ctx, src_buf);\n\n\tcoda_command_async(ctx, CODA_COMMAND_PIC_RUN);\n\n\treturn 0;\n}\n\nstatic char coda_frame_type_char(u32 flags)\n{\n\treturn (flags & V4L2_BUF_FLAG_KEYFRAME) ? 'I' :\n\t       (flags & V4L2_BUF_FLAG_PFRAME) ? 'P' :\n\t       (flags & V4L2_BUF_FLAG_BFRAME) ? 'B' : '?';\n}\n\nstatic void coda_finish_encode(struct coda_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *src_buf, *dst_buf;\n\tstruct coda_dev *dev = ctx->dev;\n\tu32 wr_ptr, start_ptr;\n\n\tif (ctx->aborting)\n\t\treturn;\n\n\t \n\tmutex_lock(&ctx->wakeup_mutex);\n\tsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\ttrace_coda_enc_pic_done(ctx, dst_buf);\n\n\t \n\tstart_ptr = coda_read(dev, CODA_CMD_ENC_PIC_BB_START);\n\twr_ptr = coda_read(dev, CODA_REG_BIT_WR_PTR(ctx->reg_idx));\n\n\t \n\tif (dst_buf->sequence == 0 ||\n\t    src_buf->flags & V4L2_BUF_FLAG_KEYFRAME) {\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, wr_ptr - start_ptr +\n\t\t\t\t\tctx->vpu_header_size[0] +\n\t\t\t\t\tctx->vpu_header_size[1] +\n\t\t\t\t\tctx->vpu_header_size[2]);\n\t} else {\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0, wr_ptr - start_ptr);\n\t}\n\n\tcoda_dbg(1, ctx, \"frame size = %u\\n\", wr_ptr - start_ptr);\n\n\tcoda_read(dev, CODA_RET_ENC_PIC_SLICE_NUM);\n\tcoda_read(dev, CODA_RET_ENC_PIC_FLAG);\n\n\tdst_buf->flags &= ~(V4L2_BUF_FLAG_KEYFRAME |\n\t\t\t    V4L2_BUF_FLAG_PFRAME |\n\t\t\t    V4L2_BUF_FLAG_LAST);\n\tif (coda_read(dev, CODA_RET_ENC_PIC_TYPE) == 0)\n\t\tdst_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;\n\telse\n\t\tdst_buf->flags |= V4L2_BUF_FLAG_PFRAME;\n\tdst_buf->flags |= src_buf->flags & V4L2_BUF_FLAG_LAST;\n\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, false);\n\n\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tcoda_m2m_buf_done(ctx, dst_buf, VB2_BUF_STATE_DONE);\n\tmutex_unlock(&ctx->wakeup_mutex);\n\n\tctx->gopcounter--;\n\tif (ctx->gopcounter < 0)\n\t\tctx->gopcounter = ctx->params.gop_size - 1;\n\n\tcoda_dbg(1, ctx, \"job finished: encoded %c frame (%d)%s\\n\",\n\t\t coda_frame_type_char(dst_buf->flags), dst_buf->sequence,\n\t\t (dst_buf->flags & V4L2_BUF_FLAG_LAST) ? \" (last)\" : \"\");\n}\n\nstatic void coda_seq_end_work(struct work_struct *work)\n{\n\tstruct coda_ctx *ctx = container_of(work, struct coda_ctx, seq_end_work);\n\tstruct coda_dev *dev = ctx->dev;\n\n\tmutex_lock(&ctx->buffer_mutex);\n\tmutex_lock(&dev->coda_mutex);\n\n\tif (ctx->initialized == 0)\n\t\tgoto out;\n\n\tcoda_dbg(1, ctx, \"%s: sent command 'SEQ_END' to coda\\n\", __func__);\n\tif (coda_command_sync(ctx, CODA_COMMAND_SEQ_END)) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"CODA_COMMAND_SEQ_END failed\\n\");\n\t}\n\n\t \n\tif (dev->devtype->product == CODA_960)\n\t\tcoda_hw_reset(ctx);\n\n\tkfifo_init(&ctx->bitstream_fifo,\n\t\tctx->bitstream.vaddr, ctx->bitstream.size);\n\n\tcoda_free_framebuffers(ctx);\n\n\tctx->initialized = 0;\n\nout:\n\tmutex_unlock(&dev->coda_mutex);\n\tmutex_unlock(&ctx->buffer_mutex);\n}\n\nstatic void coda_bit_release(struct coda_ctx *ctx)\n{\n\tmutex_lock(&ctx->buffer_mutex);\n\tcoda_free_framebuffers(ctx);\n\tcoda_free_context_buffers(ctx);\n\tcoda_free_bitstream_buffer(ctx);\n\tmutex_unlock(&ctx->buffer_mutex);\n}\n\nconst struct coda_context_ops coda_bit_encode_ops = {\n\t.queue_init = coda_encoder_queue_init,\n\t.reqbufs = coda_encoder_reqbufs,\n\t.start_streaming = coda_start_encoding,\n\t.prepare_run = coda_prepare_encode,\n\t.finish_run = coda_finish_encode,\n\t.seq_end_work = coda_seq_end_work,\n\t.release = coda_bit_release,\n};\n\n \n\nstatic int coda_alloc_bitstream_buffer(struct coda_ctx *ctx,\n\t\t\t\t       struct coda_q_data *q_data)\n{\n\tif (ctx->bitstream.vaddr)\n\t\treturn 0;\n\n\tctx->bitstream.size = roundup_pow_of_two(q_data->sizeimage * 2);\n\tctx->bitstream.vaddr = dma_alloc_wc(ctx->dev->dev, ctx->bitstream.size,\n\t\t\t\t\t    &ctx->bitstream.paddr, GFP_KERNEL);\n\tif (!ctx->bitstream.vaddr) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"failed to allocate bitstream ringbuffer\");\n\t\treturn -ENOMEM;\n\t}\n\tkfifo_init(&ctx->bitstream_fifo,\n\t\t   ctx->bitstream.vaddr, ctx->bitstream.size);\n\n\treturn 0;\n}\n\nstatic void coda_free_bitstream_buffer(struct coda_ctx *ctx)\n{\n\tif (ctx->bitstream.vaddr == NULL)\n\t\treturn;\n\n\tdma_free_wc(ctx->dev->dev, ctx->bitstream.size, ctx->bitstream.vaddr,\n\t\t    ctx->bitstream.paddr);\n\tctx->bitstream.vaddr = NULL;\n\tkfifo_init(&ctx->bitstream_fifo, NULL, 0);\n}\n\nstatic int coda_decoder_reqbufs(struct coda_ctx *ctx,\n\t\t\t\tstruct v4l2_requestbuffers *rb)\n{\n\tstruct coda_q_data *q_data_src;\n\tint ret;\n\n\tif (rb->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn 0;\n\n\tif (rb->count) {\n\t\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\t\tret = coda_alloc_context_buffers(ctx, q_data_src);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = coda_alloc_bitstream_buffer(ctx, q_data_src);\n\t\tif (ret < 0) {\n\t\t\tcoda_free_context_buffers(ctx);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tcoda_free_bitstream_buffer(ctx);\n\t\tcoda_free_context_buffers(ctx);\n\t}\n\n\treturn 0;\n}\n\nstatic bool coda_reorder_enable(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tint profile;\n\n\tif (dev->devtype->product != CODA_HX4 &&\n\t    dev->devtype->product != CODA_7541 &&\n\t    dev->devtype->product != CODA_960)\n\t\treturn false;\n\n\tif (ctx->codec->src_fourcc == V4L2_PIX_FMT_JPEG)\n\t\treturn false;\n\n\tif (ctx->codec->src_fourcc != V4L2_PIX_FMT_H264)\n\t\treturn true;\n\n\tprofile = coda_h264_profile(ctx->params.h264_profile_idc);\n\tif (profile < 0)\n\t\tv4l2_warn(&dev->v4l2_dev, \"Unknown H264 Profile: %u\\n\",\n\t\t\t  ctx->params.h264_profile_idc);\n\n\t \n\treturn profile > V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE;\n}\n\nstatic void coda_decoder_drop_used_metas(struct coda_ctx *ctx)\n{\n\tstruct coda_buffer_meta *meta, *tmp;\n\n\t \n\tspin_lock(&ctx->buffer_meta_lock);\n\tlist_for_each_entry_safe(meta, tmp, &ctx->buffer_meta_list, list) {\n\t\tif (ctx->bitstream_fifo.kfifo.out >= meta->end) {\n\t\t\tcoda_dbg(2, ctx, \"releasing meta: seq=%d start=%d end=%d\\n\",\n\t\t\t\t meta->sequence, meta->start, meta->end);\n\n\t\t\tlist_del(&meta->list);\n\t\t\tctx->num_metas--;\n\t\t\tctx->first_frame_sequence++;\n\t\t\tkfree(meta);\n\t\t}\n\t}\n\tspin_unlock(&ctx->buffer_meta_lock);\n}\n\nstatic int __coda_decoder_seq_init(struct coda_ctx *ctx)\n{\n\tstruct coda_q_data *q_data_src, *q_data_dst;\n\tu32 bitstream_buf, bitstream_size;\n\tstruct coda_dev *dev = ctx->dev;\n\tint width, height;\n\tu32 src_fourcc, dst_fourcc;\n\tu32 val;\n\tint ret;\n\n\tlockdep_assert_held(&dev->coda_mutex);\n\n\tcoda_dbg(1, ctx, \"Video Data Order Adapter: %s\\n\",\n\t\t ctx->use_vdoa ? \"Enabled\" : \"Disabled\");\n\n\t \n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tbitstream_buf = ctx->bitstream.paddr;\n\tbitstream_size = ctx->bitstream.size;\n\tsrc_fourcc = q_data_src->fourcc;\n\tdst_fourcc = q_data_dst->fourcc;\n\n\t \n\tcoda_kfifo_sync_to_device_full(ctx);\n\n\tctx->frame_mem_ctrl &= ~(CODA_FRAME_CHROMA_INTERLEAVE | (0x3 << 9) |\n\t\t\t\t CODA9_FRAME_TILED2LINEAR);\n\tif (dst_fourcc == V4L2_PIX_FMT_NV12 || dst_fourcc == V4L2_PIX_FMT_YUYV)\n\t\tctx->frame_mem_ctrl |= CODA_FRAME_CHROMA_INTERLEAVE;\n\tif (ctx->tiled_map_type == GDI_TILED_FRAME_MB_RASTER_MAP)\n\t\tctx->frame_mem_ctrl |= (0x3 << 9) |\n\t\t\t((ctx->use_vdoa) ? 0 : CODA9_FRAME_TILED2LINEAR);\n\tcoda_write(dev, ctx->frame_mem_ctrl, CODA_REG_BIT_FRAME_MEM_CTRL);\n\n\tctx->display_idx = -1;\n\tctx->frm_dis_flg = 0;\n\tcoda_write(dev, 0, CODA_REG_BIT_FRM_DIS_FLG(ctx->reg_idx));\n\n\tcoda_write(dev, bitstream_buf, CODA_CMD_DEC_SEQ_BB_START);\n\tcoda_write(dev, bitstream_size / 1024, CODA_CMD_DEC_SEQ_BB_SIZE);\n\tval = 0;\n\tif (coda_reorder_enable(ctx))\n\t\tval |= CODA_REORDER_ENABLE;\n\tif (ctx->codec->src_fourcc == V4L2_PIX_FMT_JPEG)\n\t\tval |= CODA_NO_INT_ENABLE;\n\tcoda_write(dev, val, CODA_CMD_DEC_SEQ_OPTION);\n\n\tctx->params.codec_mode = ctx->codec->mode;\n\tif (dev->devtype->product == CODA_960 &&\n\t    src_fourcc == V4L2_PIX_FMT_MPEG4)\n\t\tctx->params.codec_mode_aux = CODA_MP4_AUX_MPEG4;\n\telse\n\t\tctx->params.codec_mode_aux = 0;\n\tif (src_fourcc == V4L2_PIX_FMT_MPEG4) {\n\t\tcoda_write(dev, CODA_MP4_CLASS_MPEG4,\n\t\t\t   CODA_CMD_DEC_SEQ_MP4_ASP_CLASS);\n\t}\n\tif (src_fourcc == V4L2_PIX_FMT_H264) {\n\t\tif (dev->devtype->product == CODA_HX4 ||\n\t\t    dev->devtype->product == CODA_7541) {\n\t\t\tcoda_write(dev, ctx->psbuf.paddr,\n\t\t\t\t\tCODA_CMD_DEC_SEQ_PS_BB_START);\n\t\t\tcoda_write(dev, (CODA7_PS_BUF_SIZE / 1024),\n\t\t\t\t\tCODA_CMD_DEC_SEQ_PS_BB_SIZE);\n\t\t}\n\t\tif (dev->devtype->product == CODA_960) {\n\t\t\tcoda_write(dev, 0, CODA_CMD_DEC_SEQ_X264_MV_EN);\n\t\t\tcoda_write(dev, 512, CODA_CMD_DEC_SEQ_SPP_CHUNK_SIZE);\n\t\t}\n\t}\n\tif (src_fourcc == V4L2_PIX_FMT_JPEG)\n\t\tcoda_write(dev, 0, CODA_CMD_DEC_SEQ_JPG_THUMB_EN);\n\tif (dev->devtype->product != CODA_960)\n\t\tcoda_write(dev, 0, CODA_CMD_DEC_SEQ_SRC_SIZE);\n\n\tctx->bit_stream_param = CODA_BIT_DEC_SEQ_INIT_ESCAPE;\n\tret = coda_command_sync(ctx, CODA_COMMAND_SEQ_INIT);\n\tctx->bit_stream_param = 0;\n\tif (ret) {\n\t\tv4l2_err(&dev->v4l2_dev, \"CODA_COMMAND_SEQ_INIT timeout\\n\");\n\t\treturn ret;\n\t}\n\tctx->sequence_offset = ~0U;\n\tctx->initialized = 1;\n\tctx->first_frame_sequence = 0;\n\n\t \n\tcoda_kfifo_sync_from_device(ctx);\n\n\t \n\tcoda_decoder_drop_used_metas(ctx);\n\n\tif (coda_read(dev, CODA_RET_DEC_SEQ_SUCCESS) == 0) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\"CODA_COMMAND_SEQ_INIT failed, error code = 0x%x\\n\",\n\t\t\tcoda_read(dev, CODA_RET_DEC_SEQ_ERR_REASON));\n\t\treturn -EAGAIN;\n\t}\n\n\tval = coda_read(dev, CODA_RET_DEC_SEQ_SRC_SIZE);\n\tif (dev->devtype->product == CODA_DX6) {\n\t\twidth = (val >> CODADX6_PICWIDTH_OFFSET) & CODADX6_PICWIDTH_MASK;\n\t\theight = val & CODADX6_PICHEIGHT_MASK;\n\t} else {\n\t\twidth = (val >> CODA7_PICWIDTH_OFFSET) & CODA7_PICWIDTH_MASK;\n\t\theight = val & CODA7_PICHEIGHT_MASK;\n\t}\n\n\tif (width > q_data_dst->bytesperline || height > q_data_dst->height) {\n\t\tv4l2_err(&dev->v4l2_dev, \"stream is %dx%d, not %dx%d\\n\",\n\t\t\t width, height, q_data_dst->bytesperline,\n\t\t\t q_data_dst->height);\n\t\treturn -EINVAL;\n\t}\n\n\twidth = round_up(width, 16);\n\theight = round_up(height, 16);\n\n\tcoda_dbg(1, ctx, \"start decoding: %dx%d\\n\", width, height);\n\n\tctx->num_internal_frames = coda_read(dev, CODA_RET_DEC_SEQ_FRAME_NEED);\n\t \n\tif (ctx->use_vdoa)\n\t\tctx->num_internal_frames += 1;\n\tif (ctx->num_internal_frames > CODA_MAX_FRAMEBUFFERS) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"not enough framebuffers to decode (%d < %d)\\n\",\n\t\t\t CODA_MAX_FRAMEBUFFERS, ctx->num_internal_frames);\n\t\treturn -EINVAL;\n\t}\n\n\tif (src_fourcc == V4L2_PIX_FMT_H264) {\n\t\tu32 left_right;\n\t\tu32 top_bottom;\n\n\t\tleft_right = coda_read(dev, CODA_RET_DEC_SEQ_CROP_LEFT_RIGHT);\n\t\ttop_bottom = coda_read(dev, CODA_RET_DEC_SEQ_CROP_TOP_BOTTOM);\n\n\t\tq_data_dst->rect.left = (left_right >> 10) & 0x3ff;\n\t\tq_data_dst->rect.top = (top_bottom >> 10) & 0x3ff;\n\t\tq_data_dst->rect.width = width - q_data_dst->rect.left -\n\t\t\t\t\t (left_right & 0x3ff);\n\t\tq_data_dst->rect.height = height - q_data_dst->rect.top -\n\t\t\t\t\t  (top_bottom & 0x3ff);\n\t}\n\n\tif (dev->devtype->product != CODA_DX6) {\n\t\tu8 profile, level;\n\n\t\tval = coda_read(dev, CODA7_RET_DEC_SEQ_HEADER_REPORT);\n\t\tprofile = val & 0xff;\n\t\tlevel = (val >> 8) & 0x7f;\n\n\t\tif (profile || level)\n\t\t\tcoda_update_profile_level_ctrls(ctx, profile, level);\n\t}\n\n\treturn 0;\n}\n\nstatic void coda_dec_seq_init_work(struct work_struct *work)\n{\n\tstruct coda_ctx *ctx = container_of(work,\n\t\t\t\t\t    struct coda_ctx, seq_init_work);\n\tstruct coda_dev *dev = ctx->dev;\n\n\tmutex_lock(&ctx->buffer_mutex);\n\tmutex_lock(&dev->coda_mutex);\n\n\tif (!ctx->initialized)\n\t\t__coda_decoder_seq_init(ctx);\n\n\tmutex_unlock(&dev->coda_mutex);\n\tmutex_unlock(&ctx->buffer_mutex);\n}\n\nstatic int __coda_start_decoding(struct coda_ctx *ctx)\n{\n\tstruct coda_q_data *q_data_src, *q_data_dst;\n\tstruct coda_dev *dev = ctx->dev;\n\tu32 src_fourcc, dst_fourcc;\n\tint ret;\n\n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\tsrc_fourcc = q_data_src->fourcc;\n\tdst_fourcc = q_data_dst->fourcc;\n\n\tif (!ctx->initialized) {\n\t\tret = __coda_decoder_seq_init(ctx);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tctx->frame_mem_ctrl &= ~(CODA_FRAME_CHROMA_INTERLEAVE | (0x3 << 9) |\n\t\t\t\t\t CODA9_FRAME_TILED2LINEAR);\n\t\tif (dst_fourcc == V4L2_PIX_FMT_NV12 || dst_fourcc == V4L2_PIX_FMT_YUYV)\n\t\t\tctx->frame_mem_ctrl |= CODA_FRAME_CHROMA_INTERLEAVE;\n\t\tif (ctx->tiled_map_type == GDI_TILED_FRAME_MB_RASTER_MAP)\n\t\t\tctx->frame_mem_ctrl |= (0x3 << 9) |\n\t\t\t\t((ctx->use_vdoa) ? 0 : CODA9_FRAME_TILED2LINEAR);\n\t}\n\n\tcoda_write(dev, ctx->parabuf.paddr, CODA_REG_BIT_PARA_BUF_ADDR);\n\n\tret = coda_alloc_framebuffers(ctx, q_data_dst, src_fourcc);\n\tif (ret < 0) {\n\t\tv4l2_err(&dev->v4l2_dev, \"failed to allocate framebuffers\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tcoda_write(dev, ctx->num_internal_frames, CODA_CMD_SET_FRAME_BUF_NUM);\n\tcoda_write(dev, round_up(q_data_dst->rect.width, 16),\n\t\t   CODA_CMD_SET_FRAME_BUF_STRIDE);\n\n\tif (dev->devtype->product != CODA_DX6) {\n\t\t \n\t\tcoda_setup_iram(ctx);\n\n\t\tcoda_write(dev, ctx->iram_info.buf_bit_use,\n\t\t\t\tCODA7_CMD_SET_FRAME_AXI_BIT_ADDR);\n\t\tcoda_write(dev, ctx->iram_info.buf_ip_ac_dc_use,\n\t\t\t\tCODA7_CMD_SET_FRAME_AXI_IPACDC_ADDR);\n\t\tcoda_write(dev, ctx->iram_info.buf_dbk_y_use,\n\t\t\t\tCODA7_CMD_SET_FRAME_AXI_DBKY_ADDR);\n\t\tcoda_write(dev, ctx->iram_info.buf_dbk_c_use,\n\t\t\t\tCODA7_CMD_SET_FRAME_AXI_DBKC_ADDR);\n\t\tcoda_write(dev, ctx->iram_info.buf_ovl_use,\n\t\t\t\tCODA7_CMD_SET_FRAME_AXI_OVL_ADDR);\n\t\tif (dev->devtype->product == CODA_960) {\n\t\t\tcoda_write(dev, ctx->iram_info.buf_btp_use,\n\t\t\t\t\tCODA9_CMD_SET_FRAME_AXI_BTP_ADDR);\n\n\t\t\tcoda_write(dev, -1, CODA9_CMD_SET_FRAME_DELAY);\n\t\t\tcoda9_set_frame_cache(ctx, dst_fourcc);\n\t\t}\n\t}\n\n\tif (src_fourcc == V4L2_PIX_FMT_H264) {\n\t\tcoda_write(dev, ctx->slicebuf.paddr,\n\t\t\t\tCODA_CMD_SET_FRAME_SLICE_BB_START);\n\t\tcoda_write(dev, ctx->slicebuf.size / 1024,\n\t\t\t\tCODA_CMD_SET_FRAME_SLICE_BB_SIZE);\n\t}\n\n\tif (dev->devtype->product == CODA_HX4 ||\n\t    dev->devtype->product == CODA_7541) {\n\t\tint max_mb_x = 1920 / 16;\n\t\tint max_mb_y = 1088 / 16;\n\t\tint max_mb_num = max_mb_x * max_mb_y;\n\n\t\tcoda_write(dev, max_mb_num << 16 | max_mb_x << 8 | max_mb_y,\n\t\t\t\tCODA7_CMD_SET_FRAME_MAX_DEC_SIZE);\n\t} else if (dev->devtype->product == CODA_960) {\n\t\tint max_mb_x = 1920 / 16;\n\t\tint max_mb_y = 1088 / 16;\n\t\tint max_mb_num = max_mb_x * max_mb_y;\n\n\t\tcoda_write(dev, max_mb_num << 16 | max_mb_x << 8 | max_mb_y,\n\t\t\t\tCODA9_CMD_SET_FRAME_MAX_DEC_SIZE);\n\t}\n\n\tif (coda_command_sync(ctx, CODA_COMMAND_SET_FRAME_BUF)) {\n\t\tv4l2_err(&ctx->dev->v4l2_dev,\n\t\t\t \"CODA_COMMAND_SET_FRAME_BUF timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int coda_start_decoding(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tint ret;\n\n\tmutex_lock(&dev->coda_mutex);\n\tret = __coda_start_decoding(ctx);\n\tmutex_unlock(&dev->coda_mutex);\n\n\treturn ret;\n}\n\nstatic int coda_prepare_decode(struct coda_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *dst_buf;\n\tstruct coda_dev *dev = ctx->dev;\n\tstruct coda_q_data *q_data_dst;\n\tstruct coda_buffer_meta *meta;\n\tu32 rot_mode = 0;\n\tu32 reg_addr, reg_stride;\n\n\tdst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\t \n\tmutex_lock(&ctx->bitstream_mutex);\n\tcoda_fill_bitstream(ctx, NULL);\n\tmutex_unlock(&ctx->bitstream_mutex);\n\n\tif (coda_get_bitstream_payload(ctx) < 512 &&\n\t    (!(ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG))) {\n\t\tcoda_dbg(1, ctx, \"bitstream payload: %d, skipping\\n\",\n\t\t\t coda_get_bitstream_payload(ctx));\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (!ctx->initialized) {\n\t\tint ret = __coda_start_decoding(ctx);\n\n\t\tif (ret < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev, \"failed to start decoding\\n\");\n\t\t\treturn -EAGAIN;\n\t\t} else {\n\t\t\tctx->initialized = 1;\n\t\t}\n\t}\n\n\tif (dev->devtype->product == CODA_960)\n\t\tcoda_set_gdi_regs(ctx);\n\n\tif (ctx->use_vdoa &&\n\t    ctx->display_idx >= 0 &&\n\t    ctx->display_idx < ctx->num_internal_frames) {\n\t\tvdoa_device_run(ctx->vdoa,\n\t\t\t\tvb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0),\n\t\t\t\tctx->internal_frames[ctx->display_idx].buf.paddr);\n\t} else {\n\t\tif (dev->devtype->product == CODA_960) {\n\t\t\t \n\t\t\tcoda_write(dev, CODA_MAX_FRAMEBUFFERS,\n\t\t\t\t   CODA9_CMD_DEC_PIC_ROT_INDEX);\n\n\t\t\treg_addr = CODA9_CMD_DEC_PIC_ROT_ADDR_Y;\n\t\t\treg_stride = CODA9_CMD_DEC_PIC_ROT_STRIDE;\n\t\t} else {\n\t\t\treg_addr = CODA_CMD_DEC_PIC_ROT_ADDR_Y;\n\t\t\treg_stride = CODA_CMD_DEC_PIC_ROT_STRIDE;\n\t\t}\n\t\tcoda_write_base(ctx, q_data_dst, dst_buf, reg_addr);\n\t\tcoda_write(dev, q_data_dst->bytesperline, reg_stride);\n\n\t\trot_mode = CODA_ROT_MIR_ENABLE | ctx->params.rot_mode;\n\t}\n\n\tcoda_write(dev, rot_mode, CODA_CMD_DEC_PIC_ROT_MODE);\n\n\tswitch (dev->devtype->product) {\n\tcase CODA_DX6:\n\t\t \n\tcase CODA_HX4:\n\tcase CODA_7541:\n\t\tcoda_write(dev, CODA_PRE_SCAN_EN, CODA_CMD_DEC_PIC_OPTION);\n\t\tbreak;\n\tcase CODA_960:\n\t\t \n\t\tcoda_write(dev, (1 << 10), CODA_CMD_DEC_PIC_OPTION);\n\t\tbreak;\n\t}\n\n\tcoda_write(dev, 0, CODA_CMD_DEC_PIC_SKIP_NUM);\n\n\tcoda_write(dev, 0, CODA_CMD_DEC_PIC_BB_START);\n\tcoda_write(dev, 0, CODA_CMD_DEC_PIC_START_BYTE);\n\n\tif (dev->devtype->product != CODA_DX6)\n\t\tcoda_write(dev, ctx->iram_info.axi_sram_use,\n\t\t\t\tCODA7_REG_BIT_AXI_SRAM_USE);\n\n\tspin_lock(&ctx->buffer_meta_lock);\n\tmeta = list_first_entry_or_null(&ctx->buffer_meta_list,\n\t\t\t\t\tstruct coda_buffer_meta, list);\n\n\tif (meta && ctx->codec->src_fourcc == V4L2_PIX_FMT_JPEG) {\n\n\t\t \n\t\tif (meta->end == ctx->bitstream_fifo.kfifo.in) {\n\t\t\tstatic unsigned char buf[512];\n\t\t\tunsigned int pad;\n\n\t\t\t \n\t\t\tpad = ((0 - meta->end) & 0xff) + 256;\n\n\t\t\tmemset(buf, 0xff, sizeof(buf));\n\n\t\t\tkfifo_in(&ctx->bitstream_fifo, buf, pad);\n\t\t}\n\t}\n\tspin_unlock(&ctx->buffer_meta_lock);\n\n\tcoda_kfifo_sync_to_device_full(ctx);\n\n\t \n\tcoda_write(dev, 0, CODA_RET_DEC_PIC_SUCCESS);\n\n\t \n\tcoda_write(dev, 0, CODA_RET_DEC_PIC_ERR_MB);\n\n\ttrace_coda_dec_pic_run(ctx, meta);\n\n\tcoda_command_async(ctx, CODA_COMMAND_PIC_RUN);\n\n\treturn 0;\n}\n\nstatic void coda_finish_decode(struct coda_ctx *ctx)\n{\n\tstruct coda_dev *dev = ctx->dev;\n\tstruct coda_q_data *q_data_src;\n\tstruct coda_q_data *q_data_dst;\n\tstruct vb2_v4l2_buffer *dst_buf;\n\tstruct coda_buffer_meta *meta;\n\tint width, height;\n\tint decoded_idx;\n\tint display_idx;\n\tstruct coda_internal_frame *decoded_frame = NULL;\n\tu32 src_fourcc;\n\tint success;\n\tu32 err_mb;\n\tint err_vdoa = 0;\n\tu32 val;\n\n\tif (ctx->aborting)\n\t\treturn;\n\n\t \n\tcoda_kfifo_sync_from_device(ctx);\n\n\t \n\tif (ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG) {\n\t\tif (coda_get_bitstream_payload(ctx) >= ctx->bitstream.size - 512)\n\t\t\tkfifo_init(&ctx->bitstream_fifo,\n\t\t\t\tctx->bitstream.vaddr, ctx->bitstream.size);\n\t}\n\n\tq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tsrc_fourcc = q_data_src->fourcc;\n\n\tval = coda_read(dev, CODA_RET_DEC_PIC_SUCCESS);\n\tif (val != 1)\n\t\tpr_err(\"DEC_PIC_SUCCESS = %d\\n\", val);\n\n\tsuccess = val & 0x1;\n\tif (!success)\n\t\tv4l2_err(&dev->v4l2_dev, \"decode failed\\n\");\n\n\tif (src_fourcc == V4L2_PIX_FMT_H264) {\n\t\tif (val & (1 << 3))\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"insufficient PS buffer space (%d bytes)\\n\",\n\t\t\t\t ctx->psbuf.size);\n\t\tif (val & (1 << 2))\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"insufficient slice buffer space (%d bytes)\\n\",\n\t\t\t\t ctx->slicebuf.size);\n\t}\n\n\tval = coda_read(dev, CODA_RET_DEC_PIC_SIZE);\n\twidth = (val >> 16) & 0xffff;\n\theight = val & 0xffff;\n\n\tq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\t \n\tif (src_fourcc == V4L2_PIX_FMT_H264) {\n\t\tu32 left_right;\n\t\tu32 top_bottom;\n\n\t\tleft_right = coda_read(dev, CODA_RET_DEC_PIC_CROP_LEFT_RIGHT);\n\t\ttop_bottom = coda_read(dev, CODA_RET_DEC_PIC_CROP_TOP_BOTTOM);\n\n\t\tif (left_right == 0xffffffff && top_bottom == 0xffffffff) {\n\t\t\t \n\t\t} else {\n\t\t\tstruct v4l2_rect *rect = &q_data_dst->rect;\n\n\t\t\trect->left = left_right >> 16 & 0xffff;\n\t\t\trect->top = top_bottom >> 16 & 0xffff;\n\t\t\trect->width = width - rect->left -\n\t\t\t\t      (left_right & 0xffff);\n\t\t\trect->height = height - rect->top -\n\t\t\t\t       (top_bottom & 0xffff);\n\t\t}\n\t} else {\n\t\t \n\t}\n\n\terr_mb = coda_read(dev, CODA_RET_DEC_PIC_ERR_MB);\n\tif (err_mb > 0) {\n\t\tif (__ratelimit(&dev->mb_err_rs))\n\t\t\tcoda_dbg(1, ctx, \"errors in %d macroblocks\\n\", err_mb);\n\t\tv4l2_ctrl_s_ctrl(ctx->mb_err_cnt_ctrl,\n\t\t\t\t v4l2_ctrl_g_ctrl(ctx->mb_err_cnt_ctrl) + err_mb);\n\t}\n\n\tif (dev->devtype->product == CODA_HX4 ||\n\t    dev->devtype->product == CODA_7541) {\n\t\tval = coda_read(dev, CODA_RET_DEC_PIC_OPTION);\n\t\tif (val == 0) {\n\t\t\t \n\t\t\tcoda_dbg(1, ctx, \"prescan failed: %d\\n\", val);\n\t\t\tctx->hold = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (ctx->use_vdoa &&\n\t    ctx->display_idx >= 0 &&\n\t    ctx->display_idx < ctx->num_internal_frames) {\n\t\terr_vdoa = vdoa_wait_for_completion(ctx->vdoa);\n\t}\n\n\tctx->frm_dis_flg = coda_read(dev,\n\t\t\t\t     CODA_REG_BIT_FRM_DIS_FLG(ctx->reg_idx));\n\n\t \n\tif (ctx->display_idx >= 0 &&\n\t    ctx->display_idx < ctx->num_internal_frames) {\n\t\tctx->frm_dis_flg &= ~(1 << ctx->display_idx);\n\t\tcoda_write(dev, ctx->frm_dis_flg,\n\t\t\t\tCODA_REG_BIT_FRM_DIS_FLG(ctx->reg_idx));\n\t}\n\n\t \n\tdecoded_idx = coda_read(dev, CODA_RET_DEC_PIC_CUR_IDX);\n\tdisplay_idx = coda_read(dev, CODA_RET_DEC_PIC_FRAME_IDX);\n\n\tif (decoded_idx == -1) {\n\t\t \n\t\tif (display_idx >= 0 && display_idx < ctx->num_internal_frames)\n\t\t\tctx->sequence_offset++;\n\t\telse if (ctx->display_idx < 0)\n\t\t\tctx->hold = true;\n\t} else if (decoded_idx == -2) {\n\t\tif (ctx->display_idx >= 0 &&\n\t\t    ctx->display_idx < ctx->num_internal_frames)\n\t\t\tctx->sequence_offset++;\n\t\t \n\t} else if (decoded_idx < 0 || decoded_idx >= ctx->num_internal_frames) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"decoded frame index out of range: %d\\n\", decoded_idx);\n\t} else {\n\t\tint sequence;\n\n\t\tdecoded_frame = &ctx->internal_frames[decoded_idx];\n\n\t\tval = coda_read(dev, CODA_RET_DEC_PIC_FRAME_NUM);\n\t\tif (ctx->sequence_offset == -1)\n\t\t\tctx->sequence_offset = val;\n\n\t\tsequence = val + ctx->first_frame_sequence\n\t\t\t       - ctx->sequence_offset;\n\t\tspin_lock(&ctx->buffer_meta_lock);\n\t\tif (!list_empty(&ctx->buffer_meta_list)) {\n\t\t\tmeta = list_first_entry(&ctx->buffer_meta_list,\n\t\t\t\t\t      struct coda_buffer_meta, list);\n\t\t\tlist_del(&meta->list);\n\t\t\tctx->num_metas--;\n\t\t\tspin_unlock(&ctx->buffer_meta_lock);\n\t\t\t \n\t\t\tif ((sequence & 0xffff) != (meta->sequence & 0xffff)) {\n\t\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t\t \"sequence number mismatch (%d(%d) != %d)\\n\",\n\t\t\t\t\t sequence, ctx->sequence_offset,\n\t\t\t\t\t meta->sequence);\n\t\t\t}\n\t\t\tdecoded_frame->meta = *meta;\n\t\t\tkfree(meta);\n\t\t} else {\n\t\t\tspin_unlock(&ctx->buffer_meta_lock);\n\t\t\tv4l2_err(&dev->v4l2_dev, \"empty timestamp list!\\n\");\n\t\t\tmemset(&decoded_frame->meta, 0,\n\t\t\t       sizeof(struct coda_buffer_meta));\n\t\t\tdecoded_frame->meta.sequence = sequence;\n\t\t\tdecoded_frame->meta.last = false;\n\t\t\tctx->sequence_offset++;\n\t\t}\n\n\t\ttrace_coda_dec_pic_done(ctx, &decoded_frame->meta);\n\n\t\tval = coda_read(dev, CODA_RET_DEC_PIC_TYPE) & 0x7;\n\t\tdecoded_frame->type = (val == 0) ? V4L2_BUF_FLAG_KEYFRAME :\n\t\t\t\t      (val == 1) ? V4L2_BUF_FLAG_PFRAME :\n\t\t\t\t\t\t   V4L2_BUF_FLAG_BFRAME;\n\n\t\tdecoded_frame->error = err_mb;\n\t}\n\n\tif (display_idx == -1) {\n\t\t \n\t\tctx->hold = true;\n\t} else if (display_idx == -3) {\n\t\t \n\t} else if (display_idx < 0 || display_idx >= ctx->num_internal_frames) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"presentation frame index out of range: %d\\n\",\n\t\t\t display_idx);\n\t}\n\n\t \n\tif (ctx->display_idx >= 0 &&\n\t    ctx->display_idx < ctx->num_internal_frames) {\n\t\tstruct coda_internal_frame *ready_frame;\n\n\t\tready_frame = &ctx->internal_frames[ctx->display_idx];\n\n\t\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tdst_buf->sequence = ctx->osequence++;\n\n\t\tdst_buf->field = V4L2_FIELD_NONE;\n\t\tdst_buf->flags &= ~(V4L2_BUF_FLAG_KEYFRAME |\n\t\t\t\t\t     V4L2_BUF_FLAG_PFRAME |\n\t\t\t\t\t     V4L2_BUF_FLAG_BFRAME);\n\t\tdst_buf->flags |= ready_frame->type;\n\t\tmeta = &ready_frame->meta;\n\t\tif (meta->last && !coda_reorder_enable(ctx)) {\n\t\t\t \n\t\t\tcoda_dbg(1, ctx, \"last meta, marking as last frame\\n\");\n\t\t\tdst_buf->flags |= V4L2_BUF_FLAG_LAST;\n\t\t} else if (ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG &&\n\t\t\t   display_idx == -1) {\n\t\t\t \n\t\t\tcoda_dbg(1, ctx,\n\t\t\t\t \"no more frames to return, marking as last frame\\n\");\n\t\t\tdst_buf->flags |= V4L2_BUF_FLAG_LAST;\n\t\t}\n\t\tdst_buf->timecode = meta->timecode;\n\t\tdst_buf->vb2_buf.timestamp = meta->timestamp;\n\n\t\ttrace_coda_dec_rot_done(ctx, dst_buf, meta);\n\n\t\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0,\n\t\t\t\t      q_data_dst->sizeimage);\n\n\t\tif (ready_frame->error || err_vdoa)\n\t\t\tcoda_m2m_buf_done(ctx, dst_buf, VB2_BUF_STATE_ERROR);\n\t\telse\n\t\t\tcoda_m2m_buf_done(ctx, dst_buf, VB2_BUF_STATE_DONE);\n\n\t\tif (decoded_frame) {\n\t\t\tcoda_dbg(1, ctx, \"job finished: decoded %c frame %u, returned %c frame %u (%u/%u)%s\\n\",\n\t\t\t\t coda_frame_type_char(decoded_frame->type),\n\t\t\t\t decoded_frame->meta.sequence,\n\t\t\t\t coda_frame_type_char(dst_buf->flags),\n\t\t\t\t ready_frame->meta.sequence,\n\t\t\t\t dst_buf->sequence, ctx->qsequence,\n\t\t\t\t (dst_buf->flags & V4L2_BUF_FLAG_LAST) ?\n\t\t\t\t \" (last)\" : \"\");\n\t\t} else {\n\t\t\tcoda_dbg(1, ctx, \"job finished: no frame decoded (%d), returned %c frame %u (%u/%u)%s\\n\",\n\t\t\t\t decoded_idx,\n\t\t\t\t coda_frame_type_char(dst_buf->flags),\n\t\t\t\t ready_frame->meta.sequence,\n\t\t\t\t dst_buf->sequence, ctx->qsequence,\n\t\t\t\t (dst_buf->flags & V4L2_BUF_FLAG_LAST) ?\n\t\t\t\t \" (last)\" : \"\");\n\t\t}\n\t} else {\n\t\tif (decoded_frame) {\n\t\t\tcoda_dbg(1, ctx, \"job finished: decoded %c frame %u, no frame returned (%d)\\n\",\n\t\t\t\t coda_frame_type_char(decoded_frame->type),\n\t\t\t\t decoded_frame->meta.sequence,\n\t\t\t\t ctx->display_idx);\n\t\t} else {\n\t\t\tcoda_dbg(1, ctx, \"job finished: no frame decoded (%d) or returned (%d)\\n\",\n\t\t\t\t decoded_idx, ctx->display_idx);\n\t\t}\n\t}\n\n\t \n\tctx->display_idx = display_idx;\n\n\t \n\tmutex_lock(&ctx->bitstream_mutex);\n\tcoda_fill_bitstream(ctx, NULL);\n\tmutex_unlock(&ctx->bitstream_mutex);\n}\n\nstatic void coda_decode_timeout(struct coda_ctx *ctx)\n{\n\tstruct vb2_v4l2_buffer *dst_buf;\n\n\t \n\tif (!(ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG))\n\t\treturn;\n\n\tdst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\tdst_buf->sequence = ctx->qsequence - 1;\n\n\tcoda_m2m_buf_done(ctx, dst_buf, VB2_BUF_STATE_ERROR);\n}\n\nconst struct coda_context_ops coda_bit_decode_ops = {\n\t.queue_init = coda_decoder_queue_init,\n\t.reqbufs = coda_decoder_reqbufs,\n\t.start_streaming = coda_start_decoding,\n\t.prepare_run = coda_prepare_decode,\n\t.finish_run = coda_finish_decode,\n\t.run_timeout = coda_decode_timeout,\n\t.seq_init_work = coda_dec_seq_init_work,\n\t.seq_end_work = coda_seq_end_work,\n\t.release = coda_bit_release,\n};\n\nirqreturn_t coda_irq_handler(int irq, void *data)\n{\n\tstruct coda_dev *dev = data;\n\tstruct coda_ctx *ctx;\n\n\t \n\tcoda_read(dev, CODA_REG_BIT_INT_STATUS);\n\tcoda_write(dev, 0, CODA_REG_BIT_INT_REASON);\n\tcoda_write(dev, CODA_REG_BIT_INT_CLEAR_SET,\n\t\t      CODA_REG_BIT_INT_CLEAR);\n\n\tctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);\n\tif (ctx == NULL) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"Instance released before the end of transaction\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\ttrace_coda_bit_done(ctx);\n\n\tif (ctx->aborting) {\n\t\tcoda_dbg(1, ctx, \"task has been aborted\\n\");\n\t}\n\n\tif (coda_isbusy(ctx->dev)) {\n\t\tcoda_dbg(1, ctx, \"coda is still busy!!!!\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tcomplete(&ctx->completion);\n\n\treturn IRQ_HANDLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}