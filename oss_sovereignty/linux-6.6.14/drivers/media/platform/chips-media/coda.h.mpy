{
  "module_name": "coda.h",
  "hash_id": "d15ce73988c5a5c16db7e89a6fc41cbc49249f749a468a6978090c5800fdec5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/chips-media/coda.h",
  "human_readable_source": " \n \n\n#ifndef __CODA_H__\n#define __CODA_H__\n\n#include <linux/debugfs.h>\n#include <linux/idr.h>\n#include <linux/irqreturn.h>\n#include <linux/mutex.h>\n#include <linux/kfifo.h>\n#include <linux/videodev2.h>\n#include <linux/ratelimit.h>\n\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-fh.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"coda_regs.h\"\n\n#define CODA_MAX_FRAMEBUFFERS\t19\n#define FMO_SLICE_SAVE_BUF_SIZE\t(32)\n\n \n#define V4L2_CID_CODA_MB_ERR_CNT (V4L2_CID_USER_CODA_BASE + 0)\n\nenum {\n\tV4L2_M2M_SRC = 0,\n\tV4L2_M2M_DST = 1,\n};\n\nenum coda_inst_type {\n\tCODA_INST_ENCODER,\n\tCODA_INST_DECODER,\n};\n\nenum coda_product {\n\tCODA_DX6 = 0xf001,\n\tCODA_HX4 = 0xf00a,\n\tCODA_7541 = 0xf012,\n\tCODA_960 = 0xf020,\n};\n\nstruct coda_video_device;\n\nstruct coda_devtype {\n\tchar\t\t\t*firmware[3];\n\tenum coda_product\tproduct;\n\tconst struct coda_codec\t*codecs;\n\tunsigned int\t\tnum_codecs;\n\tconst struct coda_video_device **vdevs;\n\tunsigned int\t\tnum_vdevs;\n\tsize_t\t\t\tworkbuf_size;\n\tsize_t\t\t\ttempbuf_size;\n\tsize_t\t\t\tiram_size;\n};\n\nstruct coda_aux_buf {\n\tvoid\t\t\t*vaddr;\n\tdma_addr_t\t\tpaddr;\n\tu32\t\t\tsize;\n\tstruct debugfs_blob_wrapper blob;\n\tstruct dentry\t\t*dentry;\n};\n\nstruct coda_dev {\n\tstruct v4l2_device\tv4l2_dev;\n\tstruct video_device\tvfd[6];\n\tstruct device\t\t*dev;\n\tconst struct coda_devtype *devtype;\n\tint\t\t\tfirmware;\n\tstruct vdoa_data\t*vdoa;\n\n\tvoid __iomem\t\t*regs_base;\n\tstruct clk\t\t*clk_per;\n\tstruct clk\t\t*clk_ahb;\n\tstruct reset_control\t*rstc;\n\n\tstruct coda_aux_buf\tcodebuf;\n\tstruct coda_aux_buf\ttempbuf;\n\tstruct coda_aux_buf\tworkbuf;\n\tstruct gen_pool\t\t*iram_pool;\n\tstruct coda_aux_buf\tiram;\n\n\tstruct mutex\t\tdev_mutex;\n\tstruct mutex\t\tcoda_mutex;\n\tstruct workqueue_struct\t*workqueue;\n\tstruct v4l2_m2m_dev\t*m2m_dev;\n\tstruct ida\t\tida;\n\tstruct dentry\t\t*debugfs_root;\n\tstruct ratelimit_state\tmb_err_rs;\n};\n\nstruct coda_codec {\n\tu32 mode;\n\tu32 src_fourcc;\n\tu32 dst_fourcc;\n\tu32 max_w;\n\tu32 max_h;\n};\n\nstruct coda_huff_tab;\n\nstruct coda_params {\n\tu8\t\t\trot_mode;\n\tu8\t\t\th264_intra_qp;\n\tu8\t\t\th264_inter_qp;\n\tu8\t\t\th264_min_qp;\n\tu8\t\t\th264_max_qp;\n\tu8\t\t\th264_disable_deblocking_filter_idc;\n\ts8\t\t\th264_slice_alpha_c0_offset_div2;\n\ts8\t\t\th264_slice_beta_offset_div2;\n\tbool\t\t\th264_constrained_intra_pred_flag;\n\ts8\t\t\th264_chroma_qp_index_offset;\n\tu8\t\t\th264_profile_idc;\n\tu8\t\t\th264_level_idc;\n\tu8\t\t\tmpeg2_profile_idc;\n\tu8\t\t\tmpeg2_level_idc;\n\tu8\t\t\tmpeg4_intra_qp;\n\tu8\t\t\tmpeg4_inter_qp;\n\tu8\t\t\tgop_size;\n\tint\t\t\tintra_refresh;\n\tenum v4l2_jpeg_chroma_subsampling jpeg_chroma_subsampling;\n\tu8\t\t\tjpeg_quality;\n\tu8\t\t\tjpeg_restart_interval;\n\tu8\t\t\t*jpeg_qmat_tab[3];\n\tint\t\t\tjpeg_qmat_index[3];\n\tint\t\t\tjpeg_huff_dc_index[3];\n\tint\t\t\tjpeg_huff_ac_index[3];\n\tu32\t\t\t*jpeg_huff_data;\n\tstruct coda_huff_tab\t*jpeg_huff_tab;\n\tint\t\t\tcodec_mode;\n\tint\t\t\tcodec_mode_aux;\n\tenum v4l2_mpeg_video_multi_slice_mode slice_mode;\n\tu32\t\t\tframerate;\n\tu16\t\t\tbitrate;\n\tu16\t\t\tvbv_delay;\n\tu32\t\t\tvbv_size;\n\tu32\t\t\tslice_max_bits;\n\tu32\t\t\tslice_max_mb;\n\tbool\t\t\tforce_ipicture;\n\tbool\t\t\tgop_size_changed;\n\tbool\t\t\tbitrate_changed;\n\tbool\t\t\tframerate_changed;\n\tbool\t\t\th264_intra_qp_changed;\n\tbool\t\t\tintra_refresh_changed;\n\tbool\t\t\tslice_mode_changed;\n\tbool\t\t\tframe_rc_enable;\n\tbool\t\t\tmb_rc_enable;\n};\n\nstruct coda_buffer_meta {\n\tstruct list_head\tlist;\n\tu32\t\t\tsequence;\n\tstruct v4l2_timecode\ttimecode;\n\tu64\t\t\ttimestamp;\n\tunsigned int\t\tstart;\n\tunsigned int\t\tend;\n\tbool\t\t\tlast;\n};\n\n \nstruct coda_q_data {\n\tunsigned int\t\twidth;\n\tunsigned int\t\theight;\n\tunsigned int\t\tbytesperline;\n\tunsigned int\t\tsizeimage;\n\tunsigned int\t\tfourcc;\n\tstruct v4l2_rect\trect;\n};\n\nstruct coda_iram_info {\n\tu32\t\taxi_sram_use;\n\tphys_addr_t\tbuf_bit_use;\n\tphys_addr_t\tbuf_ip_ac_dc_use;\n\tphys_addr_t\tbuf_dbk_y_use;\n\tphys_addr_t\tbuf_dbk_c_use;\n\tphys_addr_t\tbuf_ovl_use;\n\tphys_addr_t\tbuf_btp_use;\n\tphys_addr_t\tsearch_ram_paddr;\n\tint\t\tsearch_ram_size;\n\tint\t\tremaining;\n\tphys_addr_t\tnext_paddr;\n};\n\n#define GDI_LINEAR_FRAME_MAP 0\n#define GDI_TILED_FRAME_MB_RASTER_MAP 1\n\nstruct coda_ctx;\n\nstruct coda_context_ops {\n\tint (*queue_init)(void *priv, struct vb2_queue *src_vq,\n\t\t\t  struct vb2_queue *dst_vq);\n\tint (*reqbufs)(struct coda_ctx *ctx, struct v4l2_requestbuffers *rb);\n\tint (*start_streaming)(struct coda_ctx *ctx);\n\tint (*prepare_run)(struct coda_ctx *ctx);\n\tvoid (*finish_run)(struct coda_ctx *ctx);\n\tvoid (*run_timeout)(struct coda_ctx *ctx);\n\tvoid (*seq_init_work)(struct work_struct *work);\n\tvoid (*seq_end_work)(struct work_struct *work);\n\tvoid (*release)(struct coda_ctx *ctx);\n};\n\nstruct coda_internal_frame {\n\tstruct coda_aux_buf\t\tbuf;\n\tstruct coda_buffer_meta\t\tmeta;\n\tu32\t\t\t\ttype;\n\tu32\t\t\t\terror;\n};\n\nstruct coda_ctx {\n\tstruct coda_dev\t\t\t*dev;\n\tstruct mutex\t\t\tbuffer_mutex;\n\tstruct work_struct\t\tpic_run_work;\n\tstruct work_struct\t\tseq_init_work;\n\tstruct work_struct\t\tseq_end_work;\n\tstruct completion\t\tcompletion;\n\tconst struct coda_video_device\t*cvd;\n\tconst struct coda_context_ops\t*ops;\n\tint\t\t\t\taborting;\n\tint\t\t\t\tinitialized;\n\tint\t\t\t\tstreamon_out;\n\tint\t\t\t\tstreamon_cap;\n\tu32\t\t\t\tqsequence;\n\tu32\t\t\t\tosequence;\n\tu32\t\t\t\tsequence_offset;\n\tstruct coda_q_data\t\tq_data[2];\n\tenum coda_inst_type\t\tinst_type;\n\tconst struct coda_codec\t\t*codec;\n\tenum v4l2_colorspace\t\tcolorspace;\n\tenum v4l2_xfer_func\t\txfer_func;\n\tenum v4l2_ycbcr_encoding\tycbcr_enc;\n\tenum v4l2_quantization\t\tquantization;\n\tstruct coda_params\t\tparams;\n\tstruct v4l2_ctrl_handler\tctrls;\n\tstruct v4l2_ctrl\t\t*h264_profile_ctrl;\n\tstruct v4l2_ctrl\t\t*h264_level_ctrl;\n\tstruct v4l2_ctrl\t\t*mpeg2_profile_ctrl;\n\tstruct v4l2_ctrl\t\t*mpeg2_level_ctrl;\n\tstruct v4l2_ctrl\t\t*mpeg4_profile_ctrl;\n\tstruct v4l2_ctrl\t\t*mpeg4_level_ctrl;\n\tstruct v4l2_ctrl\t\t*mb_err_cnt_ctrl;\n\tstruct v4l2_fh\t\t\tfh;\n\tint\t\t\t\tgopcounter;\n\tint\t\t\t\truncounter;\n\tint\t\t\t\tjpeg_ecs_offset;\n\tchar\t\t\t\tvpu_header[3][64];\n\tint\t\t\t\tvpu_header_size[3];\n\tstruct kfifo\t\t\tbitstream_fifo;\n\tstruct mutex\t\t\tbitstream_mutex;\n\tstruct coda_aux_buf\t\tbitstream;\n\tbool\t\t\t\thold;\n\tstruct coda_aux_buf\t\tparabuf;\n\tstruct coda_aux_buf\t\tpsbuf;\n\tstruct coda_aux_buf\t\tslicebuf;\n\tstruct coda_internal_frame\tinternal_frames[CODA_MAX_FRAMEBUFFERS];\n\tstruct list_head\t\tbuffer_meta_list;\n\tspinlock_t\t\t\tbuffer_meta_lock;\n\tint\t\t\t\tnum_metas;\n\tunsigned int\t\t\tfirst_frame_sequence;\n\tstruct coda_aux_buf\t\tworkbuf;\n\tint\t\t\t\tnum_internal_frames;\n\tint\t\t\t\tidx;\n\tint\t\t\t\treg_idx;\n\tstruct coda_iram_info\t\tiram_info;\n\tint\t\t\t\ttiled_map_type;\n\tu32\t\t\t\tbit_stream_param;\n\tu32\t\t\t\tfrm_dis_flg;\n\tu32\t\t\t\tframe_mem_ctrl;\n\tu32\t\t\t\tpara_change;\n\tint\t\t\t\tdisplay_idx;\n\tstruct dentry\t\t\t*debugfs_entry;\n\tbool\t\t\t\tuse_bit;\n\tbool\t\t\t\tuse_vdoa;\n\tstruct vdoa_ctx\t\t\t*vdoa;\n\t \n\tstruct mutex\t\t\twakeup_mutex;\n};\n\nextern int coda_debug;\n\n#define coda_dbg(level, ctx, fmt, arg...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (coda_debug >= (level))\t\t\t\t\\\n\t\t\tv4l2_dbg((level), coda_debug, &(ctx)->dev->v4l2_dev, \\\n\t\t\t \"%u: \" fmt, (ctx)->idx, ##arg);\t\t\\\n\t} while (0)\n\nvoid coda_write(struct coda_dev *dev, u32 data, u32 reg);\nunsigned int coda_read(struct coda_dev *dev, u32 reg);\nvoid coda_write_base(struct coda_ctx *ctx, struct coda_q_data *q_data,\n\t\t     struct vb2_v4l2_buffer *buf, unsigned int reg_y);\n\nint coda_alloc_aux_buf(struct coda_dev *dev, struct coda_aux_buf *buf,\n\t\t       size_t size, const char *name, struct dentry *parent);\nvoid coda_free_aux_buf(struct coda_dev *dev, struct coda_aux_buf *buf);\n\nint coda_encoder_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t    struct vb2_queue *dst_vq);\nint coda_decoder_queue_init(void *priv, struct vb2_queue *src_vq,\n\t\t\t    struct vb2_queue *dst_vq);\n\nint coda_hw_reset(struct coda_ctx *ctx);\n\nvoid coda_fill_bitstream(struct coda_ctx *ctx, struct list_head *buffer_list);\n\nvoid coda_set_gdi_regs(struct coda_ctx *ctx);\n\nstatic inline struct coda_q_data *get_q_data(struct coda_ctx *ctx,\n\t\t\t\t\t     enum v4l2_buf_type type)\n{\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\treturn &(ctx->q_data[V4L2_M2M_SRC]);\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn &(ctx->q_data[V4L2_M2M_DST]);\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nconst char *coda_product_name(int product);\n\nint coda_check_firmware(struct coda_dev *dev);\n\nstatic inline unsigned int coda_get_bitstream_payload(struct coda_ctx *ctx)\n{\n\treturn kfifo_len(&ctx->bitstream_fifo);\n}\n\n \nstatic inline bool coda_bitstream_can_fetch_past(struct coda_ctx *ctx,\n\t\t\t\t\t\t unsigned int pos)\n{\n\treturn (int)(ctx->bitstream_fifo.kfifo.in - ALIGN(pos, 256)) > 512;\n}\n\nbool coda_bitstream_can_fetch_past(struct coda_ctx *ctx, unsigned int pos);\nint coda_bitstream_flush(struct coda_ctx *ctx);\n\nvoid coda_bit_stream_end_flag(struct coda_ctx *ctx);\n\nvoid coda_m2m_buf_done(struct coda_ctx *ctx, struct vb2_v4l2_buffer *buf,\n\t\t       enum vb2_buffer_state state);\n\nint coda_h264_filler_nal(int size, char *p);\nint coda_h264_padding(int size, char *p);\nint coda_h264_profile(int profile_idc);\nint coda_h264_level(int level_idc);\nint coda_sps_parse_profile(struct coda_ctx *ctx, struct vb2_buffer *vb);\nint coda_h264_sps_fixup(struct coda_ctx *ctx, int width, int height, char *buf,\n\t\t\tint *size, int max_size);\n\nint coda_mpeg2_profile(int profile_idc);\nint coda_mpeg2_level(int level_idc);\nu32 coda_mpeg2_parse_headers(struct coda_ctx *ctx, u8 *buf, u32 size);\nint coda_mpeg4_profile(int profile_idc);\nint coda_mpeg4_level(int level_idc);\nu32 coda_mpeg4_parse_headers(struct coda_ctx *ctx, u8 *buf, u32 size);\n\nvoid coda_update_profile_level_ctrls(struct coda_ctx *ctx, u8 profile_idc,\n\t\t\t\t     u8 level_idc);\n\nstatic inline int coda_jpeg_scale(int src, int dst)\n{\n\treturn (dst <= src / 8) ? 3 :\n\t       (dst <= src / 4) ? 2 :\n\t       (dst <= src / 2) ? 1 : 0;\n}\n\nbool coda_jpeg_check_buffer(struct coda_ctx *ctx, struct vb2_buffer *vb);\nint coda_jpeg_decode_header(struct coda_ctx *ctx, struct vb2_buffer *vb);\nint coda_jpeg_write_tables(struct coda_ctx *ctx);\nvoid coda_set_jpeg_compression_quality(struct coda_ctx *ctx, int quality);\n\nextern const struct coda_context_ops coda_bit_encode_ops;\nextern const struct coda_context_ops coda_bit_decode_ops;\nextern const struct coda_context_ops coda9_jpeg_encode_ops;\nextern const struct coda_context_ops coda9_jpeg_decode_ops;\n\nirqreturn_t coda_irq_handler(int irq, void *data);\nirqreturn_t coda9_jpeg_irq_handler(int irq, void *data);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}