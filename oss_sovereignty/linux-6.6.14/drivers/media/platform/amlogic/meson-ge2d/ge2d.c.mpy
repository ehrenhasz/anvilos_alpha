{
  "module_name": "ge2d.c",
  "hash_id": "cc1782c2aed880a32a2de5019c2708c696aafa6c8b52659d38ec380a143b9e17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/amlogic/meson-ge2d/ge2d.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/bitfield.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/reset.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/regmap.h>\n\n#include <linux/platform_device.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/v4l2-ctrls.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"ge2d-regs.h\"\n\n#define GE2D_NAME\t\"meson-ge2d\"\n\n#define DEFAULT_WIDTH\t128\n#define DEFAULT_HEIGHT\t128\n#define DEFAULT_STRIDE\t512\n\n#define MAX_WIDTH\t8191\n#define MAX_HEIGHT\t8191\n\n \n\nstruct ge2d_fmt {\n\tu32 fourcc;\n\tbool alpha;\n\tbool le;\n\tunsigned int depth;\n\tunsigned int hw_fmt;\n\tunsigned int hw_map;\n};\n\nstruct ge2d_frame {\n\tstruct vb2_v4l2_buffer *buf;\n\n\t \n\tstruct v4l2_pix_format pix_fmt;\n\n\t \n\tstruct v4l2_rect crop;\n\n\t \n\tconst struct ge2d_fmt *fmt;\n};\n\nstruct ge2d_ctx {\n\tstruct v4l2_fh fh;\n\tstruct meson_ge2d *ge2d;\n\tstruct ge2d_frame in;\n\tstruct ge2d_frame out;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\n\tunsigned long sequence_out, sequence_cap;\n\n\t \n\tu32 hflip;\n\tu32 vflip;\n\tu32 xy_swap;\n};\n\nstruct meson_ge2d {\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_m2m_dev *m2m_dev;\n\tstruct video_device *vfd;\n\n\tstruct device *dev;\n\tstruct regmap *map;\n\tstruct clk *clk;\n\n\t \n\tstruct mutex mutex;\n\n\tstruct ge2d_ctx *curr;\n};\n\n#define FMT(_fourcc, _alpha, _depth, _map)\t\t\\\n{\t\t\t\t\t\t\t\\\n\t.fourcc = _fourcc,\t\t\t\t\\\n\t.alpha = (_alpha),\t\t\t\t\\\n\t.depth = (_depth),\t\t\t\t\\\n\t.hw_fmt = GE2D_FORMAT_ ## _depth ## BIT,\t\\\n\t.hw_map = GE2D_COLOR_MAP_ ## _map,\t\t\\\n}\n\n \nstatic const struct ge2d_fmt formats[] = {\n\t \n\tFMT(V4L2_PIX_FMT_XRGB32, false, 32, BGRA8888),\n\tFMT(V4L2_PIX_FMT_RGB32, true, 32, BGRA8888),\n\tFMT(V4L2_PIX_FMT_ARGB32, true, 32, BGRA8888),\n\tFMT(V4L2_PIX_FMT_RGBX32, false, 32, ABGR8888),\n\tFMT(V4L2_PIX_FMT_RGBA32, true, 32, ABGR8888),\n\tFMT(V4L2_PIX_FMT_BGRX32, false, 32, RGBA8888),\n\tFMT(V4L2_PIX_FMT_BGRA32, true, 32, RGBA8888),\n\tFMT(V4L2_PIX_FMT_BGR32, true, 32, ARGB8888),\n\tFMT(V4L2_PIX_FMT_ABGR32, true, 32, ARGB8888),\n\tFMT(V4L2_PIX_FMT_XBGR32, false, 32, ARGB8888),\n\n\tFMT(V4L2_PIX_FMT_RGB24, false, 24, BGR888),\n\tFMT(V4L2_PIX_FMT_BGR24, false, 24, RGB888),\n\n\tFMT(V4L2_PIX_FMT_XRGB555X, false, 16, ARGB1555),\n\tFMT(V4L2_PIX_FMT_ARGB555X, true, 16, ARGB1555),\n\tFMT(V4L2_PIX_FMT_RGB565, false, 16, RGB565),\n\tFMT(V4L2_PIX_FMT_RGBX444, false, 16, RGBA4444),\n\tFMT(V4L2_PIX_FMT_RGBA444, true, 16, RGBA4444),\n\tFMT(V4L2_PIX_FMT_XRGB444, false, 16, ARGB4444),\n\tFMT(V4L2_PIX_FMT_ARGB444, true, 16, ARGB4444),\n};\n\n#define NUM_FORMATS ARRAY_SIZE(formats)\n\nstatic const struct ge2d_fmt *find_fmt(struct v4l2_format *f)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < NUM_FORMATS; i++) {\n\t\tif (formats[i].fourcc == f->fmt.pix.pixelformat)\n\t\t\treturn &formats[i];\n\t}\n\n\t \n\treturn &formats[0];\n}\n\nstatic struct ge2d_frame *get_frame(struct ge2d_ctx *ctx,\n\t\t\t\t    enum v4l2_buf_type type)\n{\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\treturn &ctx->in;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\treturn &ctx->out;\n\tdefault:\n\t\t \n\t\tdev_warn(ctx->ge2d->dev, \"%s: invalid buffer type\\n\", __func__);\n\t\treturn &ctx->in;\n\t}\n}\n\nstatic void ge2d_hw_start(struct meson_ge2d *ge2d)\n{\n\tstruct ge2d_ctx *ctx = ge2d->curr;\n\tu32 reg;\n\n\t \n\tregmap_update_bits(ge2d->map, GE2D_GEN_CTRL1,\n\t\t\t   GE2D_SOFT_RST, GE2D_SOFT_RST);\n\tregmap_update_bits(ge2d->map, GE2D_GEN_CTRL1,\n\t\t\t   GE2D_SOFT_RST, 0);\n\n\tusleep_range(100, 200);\n\n\t \n\tregmap_write(ge2d->map, GE2D_SRC1_BADDR_CTRL,\n\t\t     (vb2_dma_contig_plane_dma_addr(&ctx->in.buf->vb2_buf, 0) + 7) >> 3);\n\tregmap_write(ge2d->map, GE2D_SRC1_STRIDE_CTRL,\n\t\t     (ctx->in.pix_fmt.bytesperline + 7) >> 3);\n\tregmap_write(ge2d->map, GE2D_SRC2_BADDR_CTRL,\n\t\t     (vb2_dma_contig_plane_dma_addr(&ctx->out.buf->vb2_buf, 0) + 7) >> 3);\n\tregmap_write(ge2d->map, GE2D_SRC2_STRIDE_CTRL,\n\t\t     (ctx->out.pix_fmt.bytesperline + 7) >> 3);\n\tregmap_write(ge2d->map, GE2D_DST1_BADDR_CTRL,\n\t\t     (vb2_dma_contig_plane_dma_addr(&ctx->out.buf->vb2_buf, 0) + 7) >> 3);\n\tregmap_write(ge2d->map, GE2D_DST1_STRIDE_CTRL,\n\t\t     (ctx->out.pix_fmt.bytesperline + 7) >> 3);\n\n\tregmap_write(ge2d->map, GE2D_GEN_CTRL0, 0);\n\tregmap_write(ge2d->map, GE2D_GEN_CTRL1,\n\t\t     FIELD_PREP(GE2D_INTERRUPT_CTRL, 2) |\n\t\t     FIELD_PREP(GE2D_SRC2_BURST_SIZE_CTRL, 3) |\n\t\t     FIELD_PREP(GE2D_SRC1_BURST_SIZE_CTRL, 0x3f));\n\n\tregmap_write(ge2d->map, GE2D_GEN_CTRL2,\n\t\t     GE2D_SRC1_LITTLE_ENDIAN |\n\t\t     GE2D_SRC2_LITTLE_ENDIAN |\n\t\t     GE2D_DST_LITTLE_ENDIAN |\n\t\t     FIELD_PREP(GE2D_DST1_COLOR_MAP, ctx->out.fmt->hw_map) |\n\t\t     FIELD_PREP(GE2D_DST1_FORMAT, ctx->out.fmt->hw_fmt) |\n\t\t     FIELD_PREP(GE2D_SRC2_COLOR_MAP, ctx->out.fmt->hw_map) |\n\t\t     FIELD_PREP(GE2D_SRC2_FORMAT, ctx->out.fmt->hw_fmt) |\n\t\t     FIELD_PREP(GE2D_SRC1_COLOR_MAP, ctx->in.fmt->hw_map) |\n\t\t     FIELD_PREP(GE2D_SRC1_FORMAT, ctx->in.fmt->hw_fmt));\n\tregmap_write(ge2d->map, GE2D_GEN_CTRL3,\n\t\t     GE2D_DST1_ENABLE);\n\n\tregmap_write(ge2d->map, GE2D_SRC1_CLIPY_START_END,\n\t\t     FIELD_PREP(GE2D_START, ctx->in.crop.top) |\n\t\t     FIELD_PREP(GE2D_END, ctx->in.crop.top + ctx->in.crop.height - 1));\n\tregmap_write(ge2d->map, GE2D_SRC1_CLIPX_START_END,\n\t\t     FIELD_PREP(GE2D_START, ctx->in.crop.left) |\n\t\t     FIELD_PREP(GE2D_END, ctx->in.crop.left + ctx->in.crop.width - 1));\n\tregmap_write(ge2d->map, GE2D_SRC2_CLIPY_START_END,\n\t\t     FIELD_PREP(GE2D_START, ctx->out.crop.top) |\n\t\t     FIELD_PREP(GE2D_END, ctx->out.crop.top + ctx->out.crop.height - 1));\n\tregmap_write(ge2d->map, GE2D_SRC2_CLIPX_START_END,\n\t\t     FIELD_PREP(GE2D_START, ctx->out.crop.left) |\n\t\t     FIELD_PREP(GE2D_END, ctx->out.crop.left + ctx->out.crop.width - 1));\n\tregmap_write(ge2d->map, GE2D_DST_CLIPY_START_END,\n\t\t     FIELD_PREP(GE2D_START, ctx->out.crop.top) |\n\t\t     FIELD_PREP(GE2D_END, ctx->out.crop.top + ctx->out.crop.height - 1));\n\tregmap_write(ge2d->map, GE2D_DST_CLIPX_START_END,\n\t\t     FIELD_PREP(GE2D_START, ctx->out.crop.left) |\n\t\t     FIELD_PREP(GE2D_END, ctx->out.crop.left + ctx->out.crop.width - 1));\n\n\tregmap_write(ge2d->map, GE2D_SRC1_Y_START_END,\n\t\t     FIELD_PREP(GE2D_END, ctx->in.pix_fmt.height - 1));\n\tregmap_write(ge2d->map, GE2D_SRC1_X_START_END,\n\t\t     FIELD_PREP(GE2D_END, ctx->in.pix_fmt.width - 1));\n\tregmap_write(ge2d->map, GE2D_SRC2_Y_START_END,\n\t\t     FIELD_PREP(GE2D_END, ctx->out.pix_fmt.height - 1));\n\tregmap_write(ge2d->map, GE2D_SRC2_X_START_END,\n\t\t     FIELD_PREP(GE2D_END, ctx->out.pix_fmt.width - 1));\n\tregmap_write(ge2d->map, GE2D_DST_Y_START_END,\n\t\t     FIELD_PREP(GE2D_END, ctx->out.pix_fmt.height - 1));\n\tregmap_write(ge2d->map, GE2D_DST_X_START_END,\n\t\t     FIELD_PREP(GE2D_END, ctx->out.pix_fmt.width - 1));\n\n\t \n\treg = GE2D_ALU_DO_COLOR_OPERATION_LOGIC(LOGIC_OPERATION_COPY,\n\t\t\t\t\t\tCOLOR_FACTOR_SRC_COLOR);\n\n\tif (ctx->in.fmt->alpha && ctx->out.fmt->alpha)\n\t\t \n\t\treg |= GE2D_ALU_DO_ALPHA_OPERATION_LOGIC(LOGIC_OPERATION_COPY,\n\t\t\t\t\t\t\t COLOR_FACTOR_SRC_ALPHA);\n\telse if (!ctx->out.fmt->alpha)\n\t\t \n\t\treg |= GE2D_ALU_DO_ALPHA_OPERATION_LOGIC(LOGIC_OPERATION_SET,\n\t\t\t\t\t\t\t COLOR_FACTOR_ZERO);\n\telse\n\t\t \n\t\treg |= GE2D_ALU_DO_ALPHA_OPERATION_LOGIC(LOGIC_OPERATION_COPY,\n\t\t\t\t\t\t\t COLOR_FACTOR_DST_ALPHA);\n\n\tregmap_write(ge2d->map, GE2D_ALU_OP_CTRL, reg);\n\n\t \n\tregmap_write(ge2d->map, GE2D_CMD_CTRL,\n\t\t     (ctx->xy_swap ? GE2D_DST_XY_SWAP : 0) |\n\t\t     (ctx->hflip ? GE2D_SRC1_Y_REV : 0) |\n\t\t     (ctx->vflip ? GE2D_SRC1_X_REV : 0) |\n\t\t     GE2D_CBUS_CMD_WR);\n}\n\nstatic void device_run(void *priv)\n{\n\tstruct ge2d_ctx *ctx = priv;\n\tstruct meson_ge2d *ge2d = ctx->ge2d;\n\n\tge2d->curr = ctx;\n\n\tctx->in.buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\n\tctx->out.buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\n\n\tge2d_hw_start(ge2d);\n}\n\nstatic irqreturn_t ge2d_isr(int irq, void *priv)\n{\n\tstruct meson_ge2d *ge2d = priv;\n\tu32 intr;\n\n\tregmap_read(ge2d->map, GE2D_STATUS0, &intr);\n\n\tif (!(intr & GE2D_GE2D_BUSY)) {\n\t\tstruct vb2_v4l2_buffer *src, *dst;\n\t\tstruct ge2d_ctx *ctx = ge2d->curr;\n\n\t\tge2d->curr = NULL;\n\n\t\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tsrc->sequence = ctx->sequence_out++;\n\t\tdst->sequence = ctx->sequence_cap++;\n\n\t\tdst->timecode = src->timecode;\n\t\tdst->vb2_buf.timestamp = src->vb2_buf.timestamp;\n\t\tdst->flags = src->flags;\n\n\t\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_job_finish(ge2d->m2m_dev, ctx->fh.m2m_ctx);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct v4l2_m2m_ops ge2d_m2m_ops = {\n\t.device_run = device_run,\n};\n\nstatic int ge2d_queue_setup(struct vb2_queue *vq,\n\t\t\t    unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t    unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct ge2d_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct ge2d_frame *f = get_frame(ctx, vq->type);\n\n\tif (*nplanes)\n\t\treturn sizes[0] < f->pix_fmt.sizeimage ? -EINVAL : 0;\n\n\tsizes[0] = f->pix_fmt.sizeimage;\n\t*nplanes = 1;\n\n\treturn 0;\n}\n\nstatic int ge2d_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct ge2d_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct ge2d_frame *f = get_frame(ctx, vb->vb2_queue->type);\n\n\tvbuf->field = V4L2_FIELD_NONE;\n\n\tvb2_set_plane_payload(vb, 0, f->pix_fmt.sizeimage);\n\n\treturn 0;\n}\n\nstatic void ge2d_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct ge2d_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\n\tv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\n}\n\nstatic int ge2d_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct ge2d_ctx *ctx = vb2_get_drv_priv(vq);\n\n\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\tctx->sequence_out = 0;\n\telse\n\t\tctx->sequence_cap = 0;\n\n\treturn 0;\n}\n\nstatic void ge2d_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct ge2d_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct vb2_v4l2_buffer *vbuf;\n\n\tfor (;;) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\t\tvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\telse\n\t\t\tvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\t\tif (!vbuf)\n\t\t\tbreak;\n\t\tv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\n\t}\n}\n\nstatic const struct vb2_ops ge2d_qops = {\n\t.queue_setup = ge2d_queue_setup,\n\t.buf_prepare = ge2d_buf_prepare,\n\t.buf_queue = ge2d_buf_queue,\n\t.start_streaming = ge2d_start_streaming,\n\t.stop_streaming = ge2d_stop_streaming,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\nstatic int\nqueue_init(void *priv, struct vb2_queue *src_vq, struct vb2_queue *dst_vq)\n{\n\tstruct ge2d_ctx *ctx = priv;\n\tint ret;\n\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tsrc_vq->drv_priv = ctx;\n\tsrc_vq->ops = &ge2d_qops;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->lock = &ctx->ge2d->mutex;\n\tsrc_vq->dev = ctx->ge2d->v4l2_dev.dev;\n\n\tret = vb2_queue_init(src_vq);\n\tif (ret)\n\t\treturn ret;\n\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\n\tdst_vq->drv_priv = ctx;\n\tdst_vq->ops = &ge2d_qops;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->lock = &ctx->ge2d->mutex;\n\tdst_vq->dev = ctx->ge2d->v4l2_dev.dev;\n\n\treturn vb2_queue_init(dst_vq);\n}\n\nstatic int\nvidioc_querycap(struct file *file, void *priv, struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, GE2D_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, GE2D_NAME, sizeof(cap->card));\n\tstrscpy(cap->bus_info, \"platform:\" GE2D_NAME, sizeof(cap->bus_info));\n\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt(struct file *file, void *priv, struct v4l2_fmtdesc *f)\n{\n\tconst struct ge2d_fmt *fmt;\n\n\tif (f->index >= NUM_FORMATS)\n\t\treturn -EINVAL;\n\n\tfmt = &formats[f->index];\n\tf->pixelformat = fmt->fourcc;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_selection(struct file *file, void *priv,\n\t\t\t      struct v4l2_selection *s)\n{\n\tstruct ge2d_ctx *ctx = priv;\n\tstruct ge2d_frame *f;\n\tbool use_frame = false;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\n\t    s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tf = get_frame(ctx, s->type);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE_DEFAULT:\n\tcase V4L2_SEL_TGT_COMPOSE_BOUNDS:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP_DEFAULT:\n\tcase V4L2_SEL_TGT_CROP_BOUNDS:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tuse_frame = true;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tuse_frame = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (use_frame) {\n\t\ts->r = f->crop;\n\t} else {\n\t\ts->r.left = 0;\n\t\ts->r.top = 0;\n\t\ts->r.width = f->pix_fmt.width;\n\t\ts->r.height = f->pix_fmt.height;\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_s_selection(struct file *file, void *priv,\n\t\t\t      struct v4l2_selection *s)\n{\n\tstruct ge2d_ctx *ctx = priv;\n\tstruct meson_ge2d *ge2d = ctx->ge2d;\n\tstruct ge2d_frame *f;\n\tint ret = 0;\n\n\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\n\t    s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tf = get_frame(ctx, s->type);\n\n\tswitch (s->target) {\n\tcase V4L2_SEL_TGT_COMPOSE:\n\t\t \n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase V4L2_SEL_TGT_CROP:\n\t\t \n\t\tif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (s->r.top < 0 || s->r.left < 0) {\n\t\tv4l2_err(&ge2d->v4l2_dev,\n\t\t\t \"doesn't support negative values for top & left.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (s->r.left + s->r.width > f->pix_fmt.width ||\n\t    s->r.top + s->r.height > f->pix_fmt.height) {\n\t\tv4l2_err(&ge2d->v4l2_dev, \"unsupported rectangle value.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tf->crop = s->r;\n\n\treturn ret;\n}\n\nstatic void vidioc_setup_cap_fmt(struct ge2d_ctx *ctx, struct v4l2_pix_format *f)\n{\n\tstruct ge2d_frame *frm_out = get_frame(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\n\t*f = frm_out->pix_fmt;\n\n\tif (ctx->xy_swap) {\n\t\tf->width = frm_out->pix_fmt.height;\n\t\tf->height = frm_out->pix_fmt.width;\n\t}\n}\n\nstatic int vidioc_try_fmt_cap(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tconst struct ge2d_fmt *fmt = find_fmt(f);\n\tstruct ge2d_ctx *ctx = priv;\n\tstruct v4l2_pix_format fmt_cap;\n\n\tvidioc_setup_cap_fmt(ctx, &fmt_cap);\n\n\tfmt_cap.pixelformat = fmt->fourcc;\n\n\tfmt_cap.bytesperline = max(f->fmt.pix.bytesperline,\n\t\t\t\t   ALIGN((fmt_cap.width * fmt->depth) >> 3, 8));\n\n\tfmt_cap.sizeimage = max(f->fmt.pix.sizeimage,\n\t\t\t\tfmt_cap.height * fmt_cap.bytesperline);\n\n\tf->fmt.pix = fmt_cap;\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_cap(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct ge2d_ctx *ctx = priv;\n\tstruct meson_ge2d *ge2d = ctx->ge2d;\n\tstruct vb2_queue *vq;\n\tstruct ge2d_frame *frm;\n\tint ret = 0;\n\n\t \n\tret = vidioc_try_fmt_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&ge2d->v4l2_dev, \"queue (%d) bust\\n\", f->type);\n\t\treturn -EBUSY;\n\t}\n\n\tfrm = get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\tfrm->pix_fmt = f->fmt.pix;\n\tfrm->fmt = find_fmt(f);\n\tf->fmt.pix.pixelformat = frm->fmt->fourcc;\n\n\t \n\tfrm->crop.left = 0;\n\tfrm->crop.top = 0;\n\tfrm->crop.width = frm->pix_fmt.width;\n\tfrm->crop.height = frm->pix_fmt.height;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct ge2d_ctx *ctx = priv;\n\tstruct vb2_queue *vq;\n\tstruct ge2d_frame *frm;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tfrm = get_frame(ctx, f->type);\n\n\tf->fmt.pix = frm->pix_fmt;\n\tf->fmt.pix.pixelformat = frm->fmt->fourcc;\n\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_out(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tconst struct ge2d_fmt *fmt = find_fmt(f);\n\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\tf->fmt.pix.pixelformat = fmt->fourcc;\n\n\tif (f->fmt.pix.width > MAX_WIDTH)\n\t\tf->fmt.pix.width = MAX_WIDTH;\n\tif (f->fmt.pix.height > MAX_HEIGHT)\n\t\tf->fmt.pix.height = MAX_HEIGHT;\n\n\tf->fmt.pix.bytesperline = max(f->fmt.pix.bytesperline,\n\t\t\t\t      ALIGN((f->fmt.pix.width * fmt->depth) >> 3, 8));\n\n\tf->fmt.pix.sizeimage = max(f->fmt.pix.sizeimage,\n\t\t\t\t   f->fmt.pix.height * f->fmt.pix.bytesperline);\n\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_out(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct ge2d_ctx *ctx = priv;\n\tstruct meson_ge2d *ge2d = ctx->ge2d;\n\tstruct vb2_queue *vq;\n\tstruct ge2d_frame *frm, *frm_cap;\n\tint ret = 0;\n\n\t \n\tret = vidioc_try_fmt_out(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&ge2d->v4l2_dev, \"queue (%d) bust\\n\", f->type);\n\t\treturn -EBUSY;\n\t}\n\n\tfrm = get_frame(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\tfrm_cap = get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\n\tfrm->pix_fmt = f->fmt.pix;\n\tfrm->fmt = find_fmt(f);\n\tf->fmt.pix.pixelformat = frm->fmt->fourcc;\n\n\t \n\tfrm->crop.left = 0;\n\tfrm->crop.top = 0;\n\tfrm->crop.width = frm->pix_fmt.width;\n\tfrm->crop.height = frm->pix_fmt.height;\n\n\t \n\tvidioc_setup_cap_fmt(ctx, &frm_cap->pix_fmt);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops ge2d_ioctl_ops = {\n\t.vidioc_querycap = vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt,\n\t.vidioc_g_fmt_vid_cap = vidioc_g_fmt,\n\t.vidioc_try_fmt_vid_cap = vidioc_try_fmt_cap,\n\t.vidioc_s_fmt_vid_cap = vidioc_s_fmt_cap,\n\n\t.vidioc_enum_fmt_vid_out = vidioc_enum_fmt,\n\t.vidioc_g_fmt_vid_out = vidioc_g_fmt,\n\t.vidioc_try_fmt_vid_out = vidioc_try_fmt_out,\n\t.vidioc_s_fmt_vid_out = vidioc_s_fmt_out,\n\n\t.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,\n\t.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,\n\t.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,\n\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\n\t.vidioc_streamon = v4l2_m2m_ioctl_streamon,\n\t.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_g_selection = vidioc_g_selection,\n\t.vidioc_s_selection = vidioc_s_selection,\n};\n\nstatic int ge2d_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct ge2d_ctx *ctx = container_of(ctrl->handler, struct ge2d_ctx,\n\t\t\t\t\t   ctrl_handler);\n\tstruct v4l2_pix_format fmt;\n\tstruct vb2_queue *vq;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_HFLIP:\n\t\tctx->hflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_VFLIP:\n\t\tctx->vflip = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_ROTATE:\n\t\tvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\n\t\tif (vb2_is_busy(vq))\n\t\t\treturn -EBUSY;\n\n\t\tif (ctrl->val == 90) {\n\t\t\tctx->hflip = 0;\n\t\t\tctx->vflip = 1;\n\t\t\tctx->xy_swap = 1;\n\t\t} else if (ctrl->val == 180) {\n\t\t\tctx->hflip = 1;\n\t\t\tctx->vflip = 1;\n\t\t\tctx->xy_swap = 0;\n\t\t} else if (ctrl->val == 270) {\n\t\t\tctx->hflip = 1;\n\t\t\tctx->vflip = 0;\n\t\t\tctx->xy_swap = 1;\n\t\t} else {\n\t\t\tctx->hflip = 0;\n\t\t\tctx->vflip = 0;\n\t\t\tctx->xy_swap = 0;\n\t\t}\n\n\t\tvidioc_setup_cap_fmt(ctx, &fmt);\n\n\t\t \n\t\tctx->out.pix_fmt = fmt;\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops ge2d_ctrl_ops = {\n\t.s_ctrl = ge2d_s_ctrl,\n};\n\nstatic int ge2d_setup_ctrls(struct ge2d_ctx *ctx)\n{\n\tstruct meson_ge2d *ge2d = ctx->ge2d;\n\n\tv4l2_ctrl_handler_init(&ctx->ctrl_handler, 4);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &ge2d_ctrl_ops,\n\t\t\t  V4L2_CID_HFLIP, 0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &ge2d_ctrl_ops,\n\t\t\t  V4L2_CID_VFLIP, 0, 1, 1, 0);\n\n\tv4l2_ctrl_new_std(&ctx->ctrl_handler, &ge2d_ctrl_ops,\n\t\t\t  V4L2_CID_ROTATE, 0, 270, 90, 0);\n\n\tif (ctx->ctrl_handler.error) {\n\t\tint err = ctx->ctrl_handler.error;\n\n\t\tv4l2_err(&ge2d->v4l2_dev, \"%s failed\\n\", __func__);\n\t\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ge2d_frame def_frame = {\n\t.pix_fmt = {\n\t\t.width = DEFAULT_WIDTH,\n\t\t.height = DEFAULT_HEIGHT,\n\t\t.bytesperline = DEFAULT_STRIDE,\n\t\t.sizeimage = DEFAULT_STRIDE * DEFAULT_HEIGHT,\n\t\t.field = V4L2_FIELD_NONE,\n\t},\n\t.crop.width = DEFAULT_WIDTH,\n\t.crop.height = DEFAULT_HEIGHT,\n\t.fmt = &formats[0],\n};\n\nstatic int ge2d_open(struct file *file)\n{\n\tstruct meson_ge2d *ge2d = video_drvdata(file);\n\tstruct ge2d_ctx *ctx = NULL;\n\tint ret = 0;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->ge2d = ge2d;\n\n\t \n\tctx->in = def_frame;\n\tctx->out = def_frame;\n\n\tif (mutex_lock_interruptible(&ge2d->mutex)) {\n\t\tkfree(ctx);\n\t\treturn -ERESTARTSYS;\n\t}\n\tctx->fh.m2m_ctx = v4l2_m2m_ctx_init(ge2d->m2m_dev, ctx, &queue_init);\n\tif (IS_ERR(ctx->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(ctx->fh.m2m_ctx);\n\t\tmutex_unlock(&ge2d->mutex);\n\t\tkfree(ctx);\n\t\treturn ret;\n\t}\n\tv4l2_fh_init(&ctx->fh, video_devdata(file));\n\tfile->private_data = &ctx->fh;\n\tv4l2_fh_add(&ctx->fh);\n\n\tge2d_setup_ctrls(ctx);\n\n\t \n\tv4l2_ctrl_handler_setup(&ctx->ctrl_handler);\n\n\tctx->fh.ctrl_handler = &ctx->ctrl_handler;\n\tmutex_unlock(&ge2d->mutex);\n\n\treturn 0;\n}\n\nstatic int ge2d_release(struct file *file)\n{\n\tstruct ge2d_ctx *ctx =\n\t\tcontainer_of(file->private_data, struct ge2d_ctx, fh);\n\tstruct meson_ge2d *ge2d = ctx->ge2d;\n\n\tmutex_lock(&ge2d->mutex);\n\n\tv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\n\n\tv4l2_ctrl_handler_free(&ctx->ctrl_handler);\n\tv4l2_fh_del(&ctx->fh);\n\tv4l2_fh_exit(&ctx->fh);\n\tkfree(ctx);\n\n\tmutex_unlock(&ge2d->mutex);\n\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations ge2d_fops = {\n\t.owner = THIS_MODULE,\n\t.open = ge2d_open,\n\t.release = ge2d_release,\n\t.poll = v4l2_m2m_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap = v4l2_m2m_fop_mmap,\n};\n\nstatic const struct video_device ge2d_videodev = {\n\t.name = \"meson-ge2d\",\n\t.fops = &ge2d_fops,\n\t.ioctl_ops = &ge2d_ioctl_ops,\n\t.minor = -1,\n\t.release = video_device_release,\n\t.vfl_dir = VFL_DIR_M2M,\n\t.device_caps = V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING,\n};\n\nstatic const struct regmap_config meson_ge2d_regmap_conf = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = GE2D_SRC2_STRIDE_CTRL,\n};\n\nstatic int ge2d_probe(struct platform_device *pdev)\n{\n\tstruct reset_control *rst;\n\tstruct video_device *vfd;\n\tstruct meson_ge2d *ge2d;\n\tvoid __iomem *regs;\n\tint ret = 0;\n\tint irq;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tge2d = devm_kzalloc(&pdev->dev, sizeof(*ge2d), GFP_KERNEL);\n\tif (!ge2d)\n\t\treturn -ENOMEM;\n\n\tge2d->dev = &pdev->dev;\n\tmutex_init(&ge2d->mutex);\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tge2d->map = devm_regmap_init_mmio(ge2d->dev, regs,\n\t\t\t\t\t  &meson_ge2d_regmap_conf);\n\tif (IS_ERR(ge2d->map))\n\t\treturn PTR_ERR(ge2d->map);\n\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_irq(ge2d->dev, irq, ge2d_isr, 0,\n\t\t\t       dev_name(ge2d->dev), ge2d);\n\tif (ret < 0) {\n\t\tdev_err(ge2d->dev, \"failed to request irq\\n\");\n\t\treturn ret;\n\t}\n\n\trst = devm_reset_control_get(ge2d->dev, NULL);\n\tif (IS_ERR(rst)) {\n\t\tdev_err(ge2d->dev, \"failed to get core reset controller\\n\");\n\t\treturn PTR_ERR(rst);\n\t}\n\n\tge2d->clk = devm_clk_get(ge2d->dev, NULL);\n\tif (IS_ERR(ge2d->clk)) {\n\t\tdev_err(ge2d->dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(ge2d->clk);\n\t}\n\n\treset_control_assert(rst);\n\tudelay(1);\n\treset_control_deassert(rst);\n\n\tret = clk_prepare_enable(ge2d->clk);\n\tif (ret) {\n\t\tdev_err(ge2d->dev, \"Cannot enable ge2d sclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = v4l2_device_register(&pdev->dev, &ge2d->v4l2_dev);\n\tif (ret)\n\t\tgoto disable_clks;\n\n\tvfd = video_device_alloc();\n\tif (!vfd) {\n\t\tv4l2_err(&ge2d->v4l2_dev, \"Failed to allocate video device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto unreg_v4l2_dev;\n\t}\n\n\t*vfd = ge2d_videodev;\n\tvfd->lock = &ge2d->mutex;\n\tvfd->v4l2_dev = &ge2d->v4l2_dev;\n\n\tvideo_set_drvdata(vfd, ge2d);\n\tge2d->vfd = vfd;\n\n\tplatform_set_drvdata(pdev, ge2d);\n\tge2d->m2m_dev = v4l2_m2m_init(&ge2d_m2m_ops);\n\tif (IS_ERR(ge2d->m2m_dev)) {\n\t\tv4l2_err(&ge2d->v4l2_dev, \"Failed to init mem2mem device\\n\");\n\t\tret = PTR_ERR(ge2d->m2m_dev);\n\t\tgoto rel_vdev;\n\t}\n\n\tret = video_register_device(vfd, VFL_TYPE_VIDEO, -1);\n\tif (ret) {\n\t\tv4l2_err(&ge2d->v4l2_dev, \"Failed to register video device\\n\");\n\t\tgoto rel_m2m;\n\t}\n\n\tv4l2_info(&ge2d->v4l2_dev, \"Registered %s as /dev/%s\\n\",\n\t\t  vfd->name, video_device_node_name(vfd));\n\n\treturn 0;\n\nrel_m2m:\n\tv4l2_m2m_release(ge2d->m2m_dev);\nrel_vdev:\n\tvideo_device_release(ge2d->vfd);\nunreg_v4l2_dev:\n\tv4l2_device_unregister(&ge2d->v4l2_dev);\ndisable_clks:\n\tclk_disable_unprepare(ge2d->clk);\n\n\treturn ret;\n}\n\nstatic void ge2d_remove(struct platform_device *pdev)\n{\n\tstruct meson_ge2d *ge2d = platform_get_drvdata(pdev);\n\n\tvideo_unregister_device(ge2d->vfd);\n\tv4l2_m2m_release(ge2d->m2m_dev);\n\tv4l2_device_unregister(&ge2d->v4l2_dev);\n\tclk_disable_unprepare(ge2d->clk);\n}\n\nstatic const struct of_device_id meson_ge2d_match[] = {\n\t{\n\t\t.compatible = \"amlogic,axg-ge2d\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, meson_ge2d_match);\n\nstatic struct platform_driver ge2d_drv = {\n\t.probe = ge2d_probe,\n\t.remove_new = ge2d_remove,\n\t.driver = {\n\t\t.name = \"meson-ge2d\",\n\t\t.of_match_table = meson_ge2d_match,\n\t},\n};\n\nmodule_platform_driver(ge2d_drv);\n\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_DESCRIPTION(\"Amlogic 2D Graphic Acceleration Unit\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}