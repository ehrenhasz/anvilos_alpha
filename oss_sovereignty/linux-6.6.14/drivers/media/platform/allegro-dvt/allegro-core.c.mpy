{
  "module_name": "allegro-core.c",
  "hash_id": "87531ae70b8e7cf178a706b6972719b48d5aa31b326b71e4f1304975d85b5219",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/allegro-dvt/allegro-core.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/firmware.h>\n#include <linux/gcd.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/xlnx-vcu.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-mem2mem.h>\n#include <media/videobuf2-dma-contig.h>\n#include <media/videobuf2-v4l2.h>\n\n#include \"allegro-mail.h\"\n#include \"nal-h264.h\"\n#include \"nal-hevc.h\"\n\n \n#define ALLEGRO_WIDTH_MIN 128\n#define ALLEGRO_WIDTH_DEFAULT 1920\n#define ALLEGRO_WIDTH_MAX 3840\n#define ALLEGRO_HEIGHT_MIN 64\n#define ALLEGRO_HEIGHT_DEFAULT 1080\n#define ALLEGRO_HEIGHT_MAX 2160\n\n#define ALLEGRO_FRAMERATE_DEFAULT ((struct v4l2_fract) { 30, 1 })\n\n#define ALLEGRO_GOP_SIZE_DEFAULT 25\n#define ALLEGRO_GOP_SIZE_MAX 1000\n\n \n#define AL5_MCU_RESET                   0x0000\n#define AL5_MCU_RESET_SOFT              BIT(0)\n#define AL5_MCU_RESET_REGS              BIT(1)\n#define AL5_MCU_RESET_MODE              0x0004\n#define AL5_MCU_RESET_MODE_SLEEP        BIT(0)\n#define AL5_MCU_RESET_MODE_HALT         BIT(1)\n#define AL5_MCU_STA                     0x0008\n#define AL5_MCU_STA_SLEEP               BIT(0)\n#define AL5_MCU_WAKEUP                  0x000c\n\n#define AL5_ICACHE_ADDR_OFFSET_MSB      0x0010\n#define AL5_ICACHE_ADDR_OFFSET_LSB      0x0014\n#define AL5_DCACHE_ADDR_OFFSET_MSB      0x0018\n#define AL5_DCACHE_ADDR_OFFSET_LSB      0x001c\n\n#define AL5_MCU_INTERRUPT               0x0100\n#define AL5_ITC_CPU_IRQ_MSK             0x0104\n#define AL5_ITC_CPU_IRQ_CLR             0x0108\n#define AL5_ITC_CPU_IRQ_STA             0x010C\n#define AL5_ITC_CPU_IRQ_STA_TRIGGERED   BIT(0)\n\n#define AXI_ADDR_OFFSET_IP              0x0208\n\n \n#define MCU_CACHE_OFFSET SZ_2G\n\n \n#define ENCODER_STREAM_OFFSET SZ_128\n\n#define SIZE_MACROBLOCK 16\n\n \n#define LOG2_MAX_FRAME_NUM\t\t4\n#define LOG2_MAX_PIC_ORDER_CNT\t\t10\n#define BETA_OFFSET_DIV_2\t\t-1\n#define TC_OFFSET_DIV_2\t\t\t-1\n\n \n#define V4L2_CID_USER_ALLEGRO_ENCODER_BUFFER (V4L2_CID_USER_ALLEGRO_BASE + 0)\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Debug level (0-2)\");\n\nstruct allegro_buffer {\n\tvoid *vaddr;\n\tdma_addr_t paddr;\n\tsize_t size;\n\tstruct list_head head;\n};\n\nstruct allegro_dev;\nstruct allegro_channel;\n\nstruct allegro_mbox {\n\tstruct allegro_dev *dev;\n\tunsigned int head;\n\tunsigned int tail;\n\tunsigned int data;\n\tsize_t size;\n\t \n\tstruct mutex lock;\n};\n\nstruct allegro_encoder_buffer {\n\tunsigned int size;\n\tunsigned int color_depth;\n\tunsigned int num_cores;\n\tunsigned int clk_rate;\n};\n\nstruct allegro_dev {\n\tstruct v4l2_device v4l2_dev;\n\tstruct video_device video_dev;\n\tstruct v4l2_m2m_dev *m2m_dev;\n\tstruct platform_device *plat_dev;\n\n\t \n\tstruct mutex lock;\n\n\tstruct regmap *regmap;\n\tstruct regmap *sram;\n\tstruct regmap *settings;\n\n\tstruct clk *clk_core;\n\tstruct clk *clk_mcu;\n\n\tconst struct fw_info *fw_info;\n\tstruct allegro_buffer firmware;\n\tstruct allegro_buffer suballocator;\n\tbool has_encoder_buffer;\n\tstruct allegro_encoder_buffer encoder_buffer;\n\n\tstruct completion init_complete;\n\tbool initialized;\n\n\t \n\tstruct allegro_mbox *mbox_command;\n\tstruct allegro_mbox *mbox_status;\n\n\t \n\tunsigned long channel_user_ids;\n\tstruct list_head channels;\n};\n\nstatic struct regmap_config allegro_regmap_config = {\n\t.name = \"regmap\",\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = 0xfff,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic struct regmap_config allegro_sram_config = {\n\t.name = \"sram\",\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = 0x7fff,\n\t.cache_type = REGCACHE_NONE,\n};\n\n#define fh_to_channel(__fh) container_of(__fh, struct allegro_channel, fh)\n\nstruct allegro_channel {\n\tstruct allegro_dev *dev;\n\tstruct v4l2_fh fh;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\n\tunsigned int width;\n\tunsigned int height;\n\tunsigned int stride;\n\tstruct v4l2_fract framerate;\n\n\tenum v4l2_colorspace colorspace;\n\tenum v4l2_ycbcr_encoding ycbcr_enc;\n\tenum v4l2_quantization quantization;\n\tenum v4l2_xfer_func xfer_func;\n\n\tu32 pixelformat;\n\tunsigned int sizeimage_raw;\n\tunsigned int osequence;\n\n\tu32 codec;\n\tunsigned int sizeimage_encoded;\n\tunsigned int csequence;\n\n\tbool frame_rc_enable;\n\tunsigned int bitrate;\n\tunsigned int bitrate_peak;\n\n\tstruct allegro_buffer config_blob;\n\n\tunsigned int log2_max_frame_num;\n\tbool temporal_mvp_enable;\n\n\tbool enable_loop_filter_across_tiles;\n\tbool enable_loop_filter_across_slices;\n\tbool enable_deblocking_filter_override;\n\tbool enable_reordering;\n\tbool dbf_ovr_en;\n\n\tunsigned int num_ref_idx_l0;\n\tunsigned int num_ref_idx_l1;\n\n\t \n\tint b_hrz_me_range;\n\tint b_vrt_me_range;\n\tint p_hrz_me_range;\n\tint p_vrt_me_range;\n\t \n\tint min_cu_size;\n\tint max_cu_size;\n\t \n\tint min_tu_size;\n\tint max_tu_size;\n\tint max_transfo_depth_intra;\n\tint max_transfo_depth_inter;\n\n\tstruct v4l2_ctrl *mpeg_video_h264_profile;\n\tstruct v4l2_ctrl *mpeg_video_h264_level;\n\tstruct v4l2_ctrl *mpeg_video_h264_i_frame_qp;\n\tstruct v4l2_ctrl *mpeg_video_h264_max_qp;\n\tstruct v4l2_ctrl *mpeg_video_h264_min_qp;\n\tstruct v4l2_ctrl *mpeg_video_h264_p_frame_qp;\n\tstruct v4l2_ctrl *mpeg_video_h264_b_frame_qp;\n\n\tstruct v4l2_ctrl *mpeg_video_hevc_profile;\n\tstruct v4l2_ctrl *mpeg_video_hevc_level;\n\tstruct v4l2_ctrl *mpeg_video_hevc_tier;\n\tstruct v4l2_ctrl *mpeg_video_hevc_i_frame_qp;\n\tstruct v4l2_ctrl *mpeg_video_hevc_max_qp;\n\tstruct v4l2_ctrl *mpeg_video_hevc_min_qp;\n\tstruct v4l2_ctrl *mpeg_video_hevc_p_frame_qp;\n\tstruct v4l2_ctrl *mpeg_video_hevc_b_frame_qp;\n\n\tstruct v4l2_ctrl *mpeg_video_frame_rc_enable;\n\tstruct {  \n\t\tstruct v4l2_ctrl *mpeg_video_bitrate_mode;\n\t\tstruct v4l2_ctrl *mpeg_video_bitrate;\n\t\tstruct v4l2_ctrl *mpeg_video_bitrate_peak;\n\t};\n\tstruct v4l2_ctrl *mpeg_video_cpb_size;\n\tstruct v4l2_ctrl *mpeg_video_gop_size;\n\n\tstruct v4l2_ctrl *encoder_buffer;\n\n\t \n\t \n\tint user_id;\n\t \n\tint mcu_channel_id;\n\n\tstruct list_head buffers_reference;\n\tstruct list_head buffers_intermediate;\n\n\tstruct list_head source_shadow_list;\n\tstruct list_head stream_shadow_list;\n\t \n\tstruct mutex shadow_list_lock;\n\n\tstruct list_head list;\n\tstruct completion completion;\n\n\tunsigned int error;\n};\n\nstatic inline int\nallegro_channel_get_i_frame_qp(struct allegro_channel *channel)\n{\n\tif (channel->codec == V4L2_PIX_FMT_HEVC)\n\t\treturn v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_i_frame_qp);\n\telse\n\t\treturn v4l2_ctrl_g_ctrl(channel->mpeg_video_h264_i_frame_qp);\n}\n\nstatic inline int\nallegro_channel_get_p_frame_qp(struct allegro_channel *channel)\n{\n\tif (channel->codec == V4L2_PIX_FMT_HEVC)\n\t\treturn v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_p_frame_qp);\n\telse\n\t\treturn v4l2_ctrl_g_ctrl(channel->mpeg_video_h264_p_frame_qp);\n}\n\nstatic inline int\nallegro_channel_get_b_frame_qp(struct allegro_channel *channel)\n{\n\tif (channel->codec == V4L2_PIX_FMT_HEVC)\n\t\treturn v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_b_frame_qp);\n\telse\n\t\treturn v4l2_ctrl_g_ctrl(channel->mpeg_video_h264_b_frame_qp);\n}\n\nstatic inline int\nallegro_channel_get_min_qp(struct allegro_channel *channel)\n{\n\tif (channel->codec == V4L2_PIX_FMT_HEVC)\n\t\treturn v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_min_qp);\n\telse\n\t\treturn v4l2_ctrl_g_ctrl(channel->mpeg_video_h264_min_qp);\n}\n\nstatic inline int\nallegro_channel_get_max_qp(struct allegro_channel *channel)\n{\n\tif (channel->codec == V4L2_PIX_FMT_HEVC)\n\t\treturn v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_max_qp);\n\telse\n\t\treturn v4l2_ctrl_g_ctrl(channel->mpeg_video_h264_max_qp);\n}\n\nstruct allegro_m2m_buffer {\n\tstruct v4l2_m2m_buffer buf;\n\tstruct list_head head;\n};\n\n#define to_allegro_m2m_buffer(__buf) \\\n\tcontainer_of(__buf, struct allegro_m2m_buffer, buf)\n\nstruct fw_info {\n\tunsigned int id;\n\tunsigned int id_codec;\n\tchar *version;\n\tunsigned int mailbox_cmd;\n\tunsigned int mailbox_status;\n\tsize_t mailbox_size;\n\tenum mcu_msg_version mailbox_version;\n\tsize_t suballocator_size;\n};\n\nstatic const struct fw_info supported_firmware[] = {\n\t{\n\t\t.id = 18296,\n\t\t.id_codec = 96272,\n\t\t.version = \"v2018.2\",\n\t\t.mailbox_cmd = 0x7800,\n\t\t.mailbox_status = 0x7c00,\n\t\t.mailbox_size = 0x400 - 0x8,\n\t\t.mailbox_version = MCU_MSG_VERSION_2018_2,\n\t\t.suballocator_size = SZ_16M,\n\t}, {\n\t\t.id = 14680,\n\t\t.id_codec = 126572,\n\t\t.version = \"v2019.2\",\n\t\t.mailbox_cmd = 0x7000,\n\t\t.mailbox_status = 0x7800,\n\t\t.mailbox_size = 0x800 - 0x8,\n\t\t.mailbox_version = MCU_MSG_VERSION_2019_2,\n\t\t.suballocator_size = SZ_32M,\n\t},\n};\n\nstatic inline u32 to_mcu_addr(struct allegro_dev *dev, dma_addr_t phys)\n{\n\tif (upper_32_bits(phys) || (lower_32_bits(phys) & MCU_CACHE_OFFSET))\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"address %pad is outside mcu window\\n\", &phys);\n\n\treturn lower_32_bits(phys) | MCU_CACHE_OFFSET;\n}\n\nstatic inline u32 to_mcu_size(struct allegro_dev *dev, size_t size)\n{\n\treturn lower_32_bits(size);\n}\n\nstatic inline u32 to_codec_addr(struct allegro_dev *dev, dma_addr_t phys)\n{\n\tif (upper_32_bits(phys))\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"address %pad cannot be used by codec\\n\", &phys);\n\n\treturn lower_32_bits(phys);\n}\n\nstatic inline u64 ptr_to_u64(const void *ptr)\n{\n\treturn (uintptr_t)ptr;\n}\n\n \n\nstatic unsigned long allegro_next_user_id(struct allegro_dev *dev)\n{\n\tif (dev->channel_user_ids == ~0UL)\n\t\treturn -EBUSY;\n\n\treturn ffz(dev->channel_user_ids);\n}\n\nstatic struct allegro_channel *\nallegro_find_channel_by_user_id(struct allegro_dev *dev,\n\t\t\t\tunsigned int user_id)\n{\n\tstruct allegro_channel *channel;\n\n\tlist_for_each_entry(channel, &dev->channels, list) {\n\t\tif (channel->user_id == user_id)\n\t\t\treturn channel;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct allegro_channel *\nallegro_find_channel_by_channel_id(struct allegro_dev *dev,\n\t\t\t\t   unsigned int channel_id)\n{\n\tstruct allegro_channel *channel;\n\n\tlist_for_each_entry(channel, &dev->channels, list) {\n\t\tif (channel->mcu_channel_id == channel_id)\n\t\t\treturn channel;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic inline bool channel_exists(struct allegro_channel *channel)\n{\n\treturn channel->mcu_channel_id != -1;\n}\n\n#define AL_ERROR\t\t\t0x80\n#define AL_ERR_INIT_FAILED\t\t0x81\n#define AL_ERR_NO_FRAME_DECODED\t\t0x82\n#define AL_ERR_RESOLUTION_CHANGE\t0x85\n#define AL_ERR_NO_MEMORY\t\t0x87\n#define AL_ERR_STREAM_OVERFLOW\t\t0x88\n#define AL_ERR_TOO_MANY_SLICES\t\t0x89\n#define AL_ERR_BUF_NOT_READY\t\t0x8c\n#define AL_ERR_NO_CHANNEL_AVAILABLE\t0x8d\n#define AL_ERR_RESOURCE_UNAVAILABLE\t0x8e\n#define AL_ERR_NOT_ENOUGH_CORES\t\t0x8f\n#define AL_ERR_REQUEST_MALFORMED\t0x90\n#define AL_ERR_CMD_NOT_ALLOWED\t\t0x91\n#define AL_ERR_INVALID_CMD_VALUE\t0x92\n\nstatic inline const char *allegro_err_to_string(unsigned int err)\n{\n\tswitch (err) {\n\tcase AL_ERR_INIT_FAILED:\n\t\treturn \"initialization failed\";\n\tcase AL_ERR_NO_FRAME_DECODED:\n\t\treturn \"no frame decoded\";\n\tcase AL_ERR_RESOLUTION_CHANGE:\n\t\treturn \"resolution change\";\n\tcase AL_ERR_NO_MEMORY:\n\t\treturn \"out of memory\";\n\tcase AL_ERR_STREAM_OVERFLOW:\n\t\treturn \"stream buffer overflow\";\n\tcase AL_ERR_TOO_MANY_SLICES:\n\t\treturn \"too many slices\";\n\tcase AL_ERR_BUF_NOT_READY:\n\t\treturn \"buffer not ready\";\n\tcase AL_ERR_NO_CHANNEL_AVAILABLE:\n\t\treturn \"no channel available\";\n\tcase AL_ERR_RESOURCE_UNAVAILABLE:\n\t\treturn \"resource unavailable\";\n\tcase AL_ERR_NOT_ENOUGH_CORES:\n\t\treturn \"not enough cores\";\n\tcase AL_ERR_REQUEST_MALFORMED:\n\t\treturn \"request malformed\";\n\tcase AL_ERR_CMD_NOT_ALLOWED:\n\t\treturn \"command not allowed\";\n\tcase AL_ERR_INVALID_CMD_VALUE:\n\t\treturn \"invalid command value\";\n\tcase AL_ERROR:\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}\n\nstatic unsigned int estimate_stream_size(unsigned int width,\n\t\t\t\t\t unsigned int height)\n{\n\tunsigned int offset = ENCODER_STREAM_OFFSET;\n\tunsigned int num_blocks = DIV_ROUND_UP(width, SIZE_MACROBLOCK) *\n\t\t\t\t\tDIV_ROUND_UP(height, SIZE_MACROBLOCK);\n\tunsigned int pcm_size = SZ_256;\n\tunsigned int partition_table = SZ_256;\n\n\treturn round_up(offset + num_blocks * pcm_size + partition_table, 32);\n}\n\nstatic enum v4l2_mpeg_video_h264_level\nselect_minimum_h264_level(unsigned int width, unsigned int height)\n{\n\tunsigned int pic_width_in_mb = DIV_ROUND_UP(width, SIZE_MACROBLOCK);\n\tunsigned int frame_height_in_mb = DIV_ROUND_UP(height, SIZE_MACROBLOCK);\n\tunsigned int frame_size_in_mb = pic_width_in_mb * frame_height_in_mb;\n\tenum v4l2_mpeg_video_h264_level level = V4L2_MPEG_VIDEO_H264_LEVEL_4_0;\n\n\t \n\tif (frame_size_in_mb <= 99)\n\t\tlevel = V4L2_MPEG_VIDEO_H264_LEVEL_1_0;\n\telse if (frame_size_in_mb <= 396)\n\t\tlevel = V4L2_MPEG_VIDEO_H264_LEVEL_1_1;\n\telse if (frame_size_in_mb <= 792)\n\t\tlevel = V4L2_MPEG_VIDEO_H264_LEVEL_2_1;\n\telse if (frame_size_in_mb <= 1620)\n\t\tlevel = V4L2_MPEG_VIDEO_H264_LEVEL_2_2;\n\telse if (frame_size_in_mb <= 3600)\n\t\tlevel = V4L2_MPEG_VIDEO_H264_LEVEL_3_1;\n\telse if (frame_size_in_mb <= 5120)\n\t\tlevel = V4L2_MPEG_VIDEO_H264_LEVEL_3_2;\n\telse if (frame_size_in_mb <= 8192)\n\t\tlevel = V4L2_MPEG_VIDEO_H264_LEVEL_4_0;\n\telse if (frame_size_in_mb <= 8704)\n\t\tlevel = V4L2_MPEG_VIDEO_H264_LEVEL_4_2;\n\telse if (frame_size_in_mb <= 22080)\n\t\tlevel = V4L2_MPEG_VIDEO_H264_LEVEL_5_0;\n\telse\n\t\tlevel = V4L2_MPEG_VIDEO_H264_LEVEL_5_1;\n\n\treturn level;\n}\n\nstatic unsigned int h264_maximum_bitrate(enum v4l2_mpeg_video_h264_level level)\n{\n\tswitch (level) {\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_0:\n\t\treturn 64000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1B:\n\t\treturn 128000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_1:\n\t\treturn 192000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_2:\n\t\treturn 384000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_3:\n\t\treturn 768000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_2_0:\n\t\treturn 2000000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_2_1:\n\t\treturn 4000000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_2_2:\n\t\treturn 4000000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_3_0:\n\t\treturn 10000000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_3_1:\n\t\treturn 14000000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_3_2:\n\t\treturn 20000000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_4_0:\n\t\treturn 20000000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_4_1:\n\t\treturn 50000000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_4_2:\n\t\treturn 50000000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_5_0:\n\t\treturn 135000000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_5_1:\n\tdefault:\n\t\treturn 240000000;\n\t}\n}\n\nstatic unsigned int h264_maximum_cpb_size(enum v4l2_mpeg_video_h264_level level)\n{\n\tswitch (level) {\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_0:\n\t\treturn 175;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1B:\n\t\treturn 350;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_1:\n\t\treturn 500;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_2:\n\t\treturn 1000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_3:\n\t\treturn 2000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_2_0:\n\t\treturn 2000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_2_1:\n\t\treturn 4000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_2_2:\n\t\treturn 4000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_3_0:\n\t\treturn 10000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_3_1:\n\t\treturn 14000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_3_2:\n\t\treturn 20000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_4_0:\n\t\treturn 25000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_4_1:\n\t\treturn 62500;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_4_2:\n\t\treturn 62500;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_5_0:\n\t\treturn 135000;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_5_1:\n\tdefault:\n\t\treturn 240000;\n\t}\n}\n\nstatic enum v4l2_mpeg_video_hevc_level\nselect_minimum_hevc_level(unsigned int width, unsigned int height)\n{\n\tunsigned int luma_picture_size = width * height;\n\tenum v4l2_mpeg_video_hevc_level level;\n\n\tif (luma_picture_size <= 36864)\n\t\tlevel = V4L2_MPEG_VIDEO_HEVC_LEVEL_1;\n\telse if (luma_picture_size <= 122880)\n\t\tlevel = V4L2_MPEG_VIDEO_HEVC_LEVEL_2;\n\telse if (luma_picture_size <= 245760)\n\t\tlevel = V4L2_MPEG_VIDEO_HEVC_LEVEL_2_1;\n\telse if (luma_picture_size <= 552960)\n\t\tlevel = V4L2_MPEG_VIDEO_HEVC_LEVEL_3;\n\telse if (luma_picture_size <= 983040)\n\t\tlevel = V4L2_MPEG_VIDEO_HEVC_LEVEL_3_1;\n\telse if (luma_picture_size <= 2228224)\n\t\tlevel = V4L2_MPEG_VIDEO_HEVC_LEVEL_4;\n\telse if (luma_picture_size <= 8912896)\n\t\tlevel = V4L2_MPEG_VIDEO_HEVC_LEVEL_5;\n\telse\n\t\tlevel = V4L2_MPEG_VIDEO_HEVC_LEVEL_6;\n\n\treturn level;\n}\n\nstatic unsigned int hevc_maximum_bitrate(enum v4l2_mpeg_video_hevc_level level)\n{\n\t \n\tswitch (level) {\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_1:\n\t\treturn 128;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_2:\n\t\treturn 1500;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_2_1:\n\t\treturn 3000;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_3:\n\t\treturn 6000;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_3_1:\n\t\treturn 10000;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_4:\n\t\treturn 12000;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1:\n\t\treturn 20000;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_5:\n\t\treturn 25000;\n\tdefault:\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1:\n\t\treturn 40000;\n\t}\n}\n\nstatic unsigned int hevc_maximum_cpb_size(enum v4l2_mpeg_video_hevc_level level)\n{\n\tswitch (level) {\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_1:\n\t\treturn 350;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_2:\n\t\treturn 1500;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_2_1:\n\t\treturn 3000;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_3:\n\t\treturn 6000;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_3_1:\n\t\treturn 10000;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_4:\n\t\treturn 12000;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1:\n\t\treturn 20000;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_5:\n\t\treturn 25000;\n\tdefault:\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1:\n\t\treturn 40000;\n\t}\n}\n\nstatic const struct fw_info *\nallegro_get_firmware_info(struct allegro_dev *dev,\n\t\t\t  const struct firmware *fw,\n\t\t\t  const struct firmware *fw_codec)\n{\n\tint i;\n\tunsigned int id = fw->size;\n\tunsigned int id_codec = fw_codec->size;\n\n\tfor (i = 0; i < ARRAY_SIZE(supported_firmware); i++)\n\t\tif (supported_firmware[i].id == id &&\n\t\t    supported_firmware[i].id_codec == id_codec)\n\t\t\treturn &supported_firmware[i];\n\n\treturn NULL;\n}\n\n \n\nstatic int allegro_alloc_buffer(struct allegro_dev *dev,\n\t\t\t\tstruct allegro_buffer *buffer, size_t size)\n{\n\tbuffer->vaddr = dma_alloc_coherent(&dev->plat_dev->dev, size,\n\t\t\t\t\t   &buffer->paddr, GFP_KERNEL);\n\tif (!buffer->vaddr)\n\t\treturn -ENOMEM;\n\tbuffer->size = size;\n\n\treturn 0;\n}\n\nstatic void allegro_free_buffer(struct allegro_dev *dev,\n\t\t\t\tstruct allegro_buffer *buffer)\n{\n\tif (buffer->vaddr) {\n\t\tdma_free_coherent(&dev->plat_dev->dev, buffer->size,\n\t\t\t\t  buffer->vaddr, buffer->paddr);\n\t\tbuffer->vaddr = NULL;\n\t\tbuffer->size = 0;\n\t}\n}\n\n \n\nstatic void allegro_mcu_interrupt(struct allegro_dev *dev);\nstatic void allegro_handle_message(struct allegro_dev *dev,\n\t\t\t\t   union mcu_msg_response *msg);\n\nstatic struct allegro_mbox *allegro_mbox_init(struct allegro_dev *dev,\n\t\t\t\t\t      unsigned int base, size_t size)\n{\n\tstruct allegro_mbox *mbox;\n\n\tmbox = devm_kmalloc(&dev->plat_dev->dev, sizeof(*mbox), GFP_KERNEL);\n\tif (!mbox)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmbox->dev = dev;\n\n\tmbox->head = base;\n\tmbox->tail = base + 0x4;\n\tmbox->data = base + 0x8;\n\tmbox->size = size;\n\tmutex_init(&mbox->lock);\n\n\tregmap_write(dev->sram, mbox->head, 0);\n\tregmap_write(dev->sram, mbox->tail, 0);\n\n\treturn mbox;\n}\n\nstatic int allegro_mbox_write(struct allegro_mbox *mbox,\n\t\t\t      const u32 *src, size_t size)\n{\n\tstruct regmap *sram = mbox->dev->sram;\n\tunsigned int tail;\n\tsize_t size_no_wrap;\n\tint err = 0;\n\tint stride = regmap_get_reg_stride(sram);\n\n\tif (!src)\n\t\treturn -EINVAL;\n\n\tif (size > mbox->size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mbox->lock);\n\tregmap_read(sram, mbox->tail, &tail);\n\tif (tail > mbox->size) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\tsize_no_wrap = min(size, mbox->size - (size_t)tail);\n\tregmap_bulk_write(sram, mbox->data + tail,\n\t\t\t  src, size_no_wrap / stride);\n\tregmap_bulk_write(sram, mbox->data,\n\t\t\t  src + (size_no_wrap / sizeof(*src)),\n\t\t\t  (size - size_no_wrap) / stride);\n\tregmap_write(sram, mbox->tail, (tail + size) % mbox->size);\n\nout:\n\tmutex_unlock(&mbox->lock);\n\n\treturn err;\n}\n\nstatic ssize_t allegro_mbox_read(struct allegro_mbox *mbox,\n\t\t\t\t u32 *dst, size_t nbyte)\n{\n\tstruct {\n\t\tu16 length;\n\t\tu16 type;\n\t} __attribute__ ((__packed__)) *header;\n\tstruct regmap *sram = mbox->dev->sram;\n\tunsigned int head;\n\tssize_t size;\n\tsize_t body_no_wrap;\n\tint stride = regmap_get_reg_stride(sram);\n\n\tregmap_read(sram, mbox->head, &head);\n\tif (head > mbox->size)\n\t\treturn -EIO;\n\n\t \n\tregmap_bulk_read(sram, mbox->data + head,\n\t\t\t dst, sizeof(*header) / stride);\n\theader = (void *)dst;\n\tsize = header->length + sizeof(*header);\n\tif (size > mbox->size || size & 0x3)\n\t\treturn -EIO;\n\tif (size > nbyte)\n\t\treturn -EINVAL;\n\n\t \n\tbody_no_wrap = min((size_t)header->length,\n\t\t\t   (size_t)(mbox->size - (head + sizeof(*header))));\n\tregmap_bulk_read(sram, mbox->data + head + sizeof(*header),\n\t\t\t dst + (sizeof(*header) / sizeof(*dst)),\n\t\t\t body_no_wrap / stride);\n\tregmap_bulk_read(sram, mbox->data,\n\t\t\t dst + (sizeof(*header) + body_no_wrap) / sizeof(*dst),\n\t\t\t (header->length - body_no_wrap) / stride);\n\n\tregmap_write(sram, mbox->head, (head + size) % mbox->size);\n\n\treturn size;\n}\n\n \nstatic int allegro_mbox_send(struct allegro_mbox *mbox, void *msg)\n{\n\tstruct allegro_dev *dev = mbox->dev;\n\tssize_t size;\n\tint err;\n\tu32 *tmp;\n\n\ttmp = kzalloc(mbox->size, GFP_KERNEL);\n\tif (!tmp) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsize = allegro_encode_mail(tmp, msg);\n\n\terr = allegro_mbox_write(mbox, tmp, size);\n\tkfree(tmp);\n\tif (err)\n\t\tgoto out;\n\n\tallegro_mcu_interrupt(dev);\n\nout:\n\treturn err;\n}\n\n \nstatic void allegro_mbox_notify(struct allegro_mbox *mbox)\n{\n\tstruct allegro_dev *dev = mbox->dev;\n\tunion mcu_msg_response *msg;\n\tssize_t size;\n\tu32 *tmp;\n\tint err;\n\n\tmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tmsg->header.version = dev->fw_info->mailbox_version;\n\n\ttmp = kmalloc(mbox->size, GFP_KERNEL);\n\tif (!tmp)\n\t\tgoto out;\n\n\tsize = allegro_mbox_read(mbox, tmp, mbox->size);\n\tif (size < 0)\n\t\tgoto out;\n\n\terr = allegro_decode_mail(msg, tmp);\n\tif (err)\n\t\tgoto out;\n\n\tallegro_handle_message(dev, msg);\n\nout:\n\tkfree(tmp);\n\tkfree(msg);\n}\n\nstatic int allegro_encoder_buffer_init(struct allegro_dev *dev,\n\t\t\t\t       struct allegro_encoder_buffer *buffer)\n{\n\tint err;\n\tstruct regmap *settings = dev->settings;\n\tunsigned int supports_10_bit;\n\tunsigned int memory_depth;\n\tunsigned int num_cores;\n\tunsigned int color_depth;\n\tunsigned long clk_rate;\n\n\t \n\tif (dev->fw_info->mailbox_version < MCU_MSG_VERSION_2019_2)\n\t\treturn -ENODEV;\n\n\tif (!settings)\n\t\treturn -EINVAL;\n\n\terr = regmap_read(settings, VCU_ENC_COLOR_DEPTH, &supports_10_bit);\n\tif (err < 0)\n\t\treturn err;\n\terr = regmap_read(settings, VCU_MEMORY_DEPTH, &memory_depth);\n\tif (err < 0)\n\t\treturn err;\n\terr = regmap_read(settings, VCU_NUM_CORE, &num_cores);\n\tif (err < 0)\n\t\treturn err;\n\n\tclk_rate = clk_get_rate(dev->clk_core);\n\tif (clk_rate == 0)\n\t\treturn -EINVAL;\n\n\tcolor_depth = supports_10_bit ? 10 : 8;\n\t \n\tbuffer->size = color_depth * 32 * memory_depth;\n\tbuffer->color_depth = color_depth;\n\tbuffer->num_cores = num_cores;\n\tbuffer->clk_rate = clk_rate;\n\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"using %d bits encoder buffer with %d-bit color depth\\n\",\n\t\t buffer->size, color_depth);\n\n\treturn 0;\n}\n\nstatic void allegro_mcu_send_init(struct allegro_dev *dev,\n\t\t\t\t  dma_addr_t suballoc_dma, size_t suballoc_size)\n{\n\tstruct mcu_msg_init_request msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tmsg.header.type = MCU_MSG_TYPE_INIT;\n\tmsg.header.version = dev->fw_info->mailbox_version;\n\n\tmsg.suballoc_dma = to_mcu_addr(dev, suballoc_dma);\n\tmsg.suballoc_size = to_mcu_size(dev, suballoc_size);\n\n\tif (dev->has_encoder_buffer) {\n\t\tmsg.encoder_buffer_size = dev->encoder_buffer.size;\n\t\tmsg.encoder_buffer_color_depth = dev->encoder_buffer.color_depth;\n\t\tmsg.num_cores = dev->encoder_buffer.num_cores;\n\t\tmsg.clk_rate = dev->encoder_buffer.clk_rate;\n\t} else {\n\t\tmsg.encoder_buffer_size = -1;\n\t\tmsg.encoder_buffer_color_depth = -1;\n\t\tmsg.num_cores = -1;\n\t\tmsg.clk_rate = -1;\n\t}\n\n\tallegro_mbox_send(dev->mbox_command, &msg);\n}\n\nstatic u32 v4l2_pixelformat_to_mcu_format(u32 pixelformat)\n{\n\tswitch (pixelformat) {\n\tcase V4L2_PIX_FMT_NV12:\n\t\t \n\t\treturn 0x100 | 0x88;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic u32 v4l2_colorspace_to_mcu_colorspace(enum v4l2_colorspace colorspace)\n{\n\tswitch (colorspace) {\n\tcase V4L2_COLORSPACE_REC709:\n\t\treturn 2;\n\tcase V4L2_COLORSPACE_SMPTE170M:\n\t\treturn 3;\n\tcase V4L2_COLORSPACE_SMPTE240M:\n\t\treturn 4;\n\tcase V4L2_COLORSPACE_SRGB:\n\t\treturn 7;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n}\n\nstatic u8 v4l2_profile_to_mcu_profile(enum v4l2_mpeg_video_h264_profile profile)\n{\n\tswitch (profile) {\n\tcase V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:\n\tdefault:\n\t\treturn 66;\n\t}\n}\n\nstatic u16 v4l2_level_to_mcu_level(enum v4l2_mpeg_video_h264_level level)\n{\n\tswitch (level) {\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_0:\n\t\treturn 10;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_1:\n\t\treturn 11;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_2:\n\t\treturn 12;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_1_3:\n\t\treturn 13;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_2_0:\n\t\treturn 20;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_2_1:\n\t\treturn 21;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_2_2:\n\t\treturn 22;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_3_0:\n\t\treturn 30;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_3_1:\n\t\treturn 31;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_3_2:\n\t\treturn 32;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_4_0:\n\t\treturn 40;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_4_1:\n\t\treturn 41;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_4_2:\n\t\treturn 42;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_5_0:\n\t\treturn 50;\n\tcase V4L2_MPEG_VIDEO_H264_LEVEL_5_1:\n\tdefault:\n\t\treturn 51;\n\t}\n}\n\nstatic u8 hevc_profile_to_mcu_profile(enum v4l2_mpeg_video_hevc_profile profile)\n{\n\tswitch (profile) {\n\tdefault:\n\tcase V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN:\n\t\treturn 1;\n\tcase V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10:\n\t\treturn 2;\n\tcase V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE:\n\t\treturn 3;\n\t}\n}\n\nstatic u16 hevc_level_to_mcu_level(enum v4l2_mpeg_video_hevc_level level)\n{\n\tswitch (level) {\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_1:\n\t\treturn 10;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_2:\n\t\treturn 20;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_2_1:\n\t\treturn 21;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_3:\n\t\treturn 30;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_3_1:\n\t\treturn 31;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_4:\n\t\treturn 40;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1:\n\t\treturn 41;\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_5:\n\t\treturn 50;\n\tdefault:\n\tcase V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1:\n\t\treturn 51;\n\t}\n}\n\nstatic u8 hevc_tier_to_mcu_tier(enum v4l2_mpeg_video_hevc_tier tier)\n{\n\tswitch (tier) {\n\tdefault:\n\tcase V4L2_MPEG_VIDEO_HEVC_TIER_MAIN:\n\t\treturn 0;\n\tcase V4L2_MPEG_VIDEO_HEVC_TIER_HIGH:\n\t\treturn 1;\n\t}\n}\n\nstatic u32\nv4l2_bitrate_mode_to_mcu_mode(enum v4l2_mpeg_video_bitrate_mode mode)\n{\n\tswitch (mode) {\n\tcase V4L2_MPEG_VIDEO_BITRATE_MODE_VBR:\n\t\treturn 2;\n\tcase V4L2_MPEG_VIDEO_BITRATE_MODE_CBR:\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic u32 v4l2_cpb_size_to_mcu(unsigned int cpb_size, unsigned int bitrate)\n{\n\tunsigned int cpb_size_kbit;\n\tunsigned int bitrate_kbps;\n\n\t \n\tcpb_size_kbit = cpb_size * BITS_PER_BYTE;\n\tbitrate_kbps = bitrate / 1000;\n\n\treturn (cpb_size_kbit * 90000) / bitrate_kbps;\n}\n\nstatic s16 get_qp_delta(int minuend, int subtrahend)\n{\n\tif (minuend == subtrahend)\n\t\treturn -1;\n\telse\n\t\treturn minuend - subtrahend;\n}\n\nstatic u32 allegro_channel_get_entropy_mode(struct allegro_channel *channel)\n{\n#define ALLEGRO_ENTROPY_MODE_CAVLC 0\n#define ALLEGRO_ENTROPY_MODE_CABAC 1\n\n\t \n\tif (channel->codec == V4L2_PIX_FMT_HEVC)\n\t\treturn ALLEGRO_ENTROPY_MODE_CABAC;\n\n\treturn ALLEGRO_ENTROPY_MODE_CAVLC;\n}\n\nstatic int fill_create_channel_param(struct allegro_channel *channel,\n\t\t\t\t     struct create_channel_param *param)\n{\n\tint i_frame_qp = allegro_channel_get_i_frame_qp(channel);\n\tint p_frame_qp = allegro_channel_get_p_frame_qp(channel);\n\tint b_frame_qp = allegro_channel_get_b_frame_qp(channel);\n\tint bitrate_mode = v4l2_ctrl_g_ctrl(channel->mpeg_video_bitrate_mode);\n\tunsigned int cpb_size = v4l2_ctrl_g_ctrl(channel->mpeg_video_cpb_size);\n\n\tparam->width = channel->width;\n\tparam->height = channel->height;\n\tparam->format = v4l2_pixelformat_to_mcu_format(channel->pixelformat);\n\tparam->colorspace =\n\t\tv4l2_colorspace_to_mcu_colorspace(channel->colorspace);\n\tparam->src_mode = 0x0;\n\n\tparam->codec = channel->codec;\n\tif (channel->codec == V4L2_PIX_FMT_H264) {\n\t\tenum v4l2_mpeg_video_h264_profile profile;\n\t\tenum v4l2_mpeg_video_h264_level level;\n\n\t\tprofile = v4l2_ctrl_g_ctrl(channel->mpeg_video_h264_profile);\n\t\tlevel = v4l2_ctrl_g_ctrl(channel->mpeg_video_h264_level);\n\n\t\tparam->profile = v4l2_profile_to_mcu_profile(profile);\n\t\tparam->constraint_set_flags = BIT(1);\n\t\tparam->level = v4l2_level_to_mcu_level(level);\n\t} else {\n\t\tenum v4l2_mpeg_video_hevc_profile profile;\n\t\tenum v4l2_mpeg_video_hevc_level level;\n\t\tenum v4l2_mpeg_video_hevc_tier tier;\n\n\t\tprofile = v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_profile);\n\t\tlevel = v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_level);\n\t\ttier = v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_tier);\n\n\t\tparam->profile = hevc_profile_to_mcu_profile(profile);\n\t\tparam->level = hevc_level_to_mcu_level(level);\n\t\tparam->tier = hevc_tier_to_mcu_tier(tier);\n\t}\n\n\tparam->log2_max_poc = LOG2_MAX_PIC_ORDER_CNT;\n\tparam->log2_max_frame_num = channel->log2_max_frame_num;\n\tparam->temporal_mvp_enable = channel->temporal_mvp_enable;\n\n\tparam->dbf_ovr_en = channel->dbf_ovr_en;\n\tparam->override_lf = channel->enable_deblocking_filter_override;\n\tparam->enable_reordering = channel->enable_reordering;\n\tparam->entropy_mode = allegro_channel_get_entropy_mode(channel);\n\tparam->rdo_cost_mode = 1;\n\tparam->custom_lda = 1;\n\tparam->lf = 1;\n\tparam->lf_x_tile = channel->enable_loop_filter_across_tiles;\n\tparam->lf_x_slice = channel->enable_loop_filter_across_slices;\n\n\tparam->src_bit_depth = 8;\n\n\tparam->beta_offset = BETA_OFFSET_DIV_2;\n\tparam->tc_offset = TC_OFFSET_DIV_2;\n\tparam->num_slices = 1;\n\tparam->me_range[0] = channel->b_hrz_me_range;\n\tparam->me_range[1] = channel->b_vrt_me_range;\n\tparam->me_range[2] = channel->p_hrz_me_range;\n\tparam->me_range[3] = channel->p_vrt_me_range;\n\tparam->max_cu_size = channel->max_cu_size;\n\tparam->min_cu_size = channel->min_cu_size;\n\tparam->max_tu_size = channel->max_tu_size;\n\tparam->min_tu_size = channel->min_tu_size;\n\tparam->max_transfo_depth_intra = channel->max_transfo_depth_intra;\n\tparam->max_transfo_depth_inter = channel->max_transfo_depth_inter;\n\n\tparam->encoder_buffer_enabled = v4l2_ctrl_g_ctrl(channel->encoder_buffer);\n\tparam->encoder_buffer_offset = 0;\n\n\tparam->rate_control_mode = channel->frame_rc_enable ?\n\t\tv4l2_bitrate_mode_to_mcu_mode(bitrate_mode) : 0;\n\n\tparam->cpb_size = v4l2_cpb_size_to_mcu(cpb_size, channel->bitrate_peak);\n\t \n\tparam->initial_rem_delay = param->cpb_size;\n\tparam->framerate = DIV_ROUND_UP(channel->framerate.numerator,\n\t\t\t\t\tchannel->framerate.denominator);\n\tparam->clk_ratio = channel->framerate.denominator == 1001 ? 1001 : 1000;\n\tparam->target_bitrate = channel->bitrate;\n\tparam->max_bitrate = channel->bitrate_peak;\n\tparam->initial_qp = i_frame_qp;\n\tparam->min_qp = allegro_channel_get_min_qp(channel);\n\tparam->max_qp = allegro_channel_get_max_qp(channel);\n\tparam->ip_delta = get_qp_delta(i_frame_qp, p_frame_qp);\n\tparam->pb_delta = get_qp_delta(p_frame_qp, b_frame_qp);\n\tparam->golden_ref = 0;\n\tparam->golden_delta = 2;\n\tparam->golden_ref_frequency = 10;\n\tparam->rate_control_option = 0x00000000;\n\n\tparam->num_pixel = channel->width + channel->height;\n\tparam->max_psnr = 4200;\n\tparam->max_pixel_value = 255;\n\n\tparam->gop_ctrl_mode = 0x00000002;\n\tparam->freq_idr = v4l2_ctrl_g_ctrl(channel->mpeg_video_gop_size);\n\tparam->freq_lt = 0;\n\tparam->gdr_mode = 0x00000000;\n\tparam->gop_length = v4l2_ctrl_g_ctrl(channel->mpeg_video_gop_size);\n\tparam->subframe_latency = 0x00000000;\n\n\tparam->lda_factors[0] = 51;\n\tparam->lda_factors[1] = 90;\n\tparam->lda_factors[2] = 151;\n\tparam->lda_factors[3] = 151;\n\tparam->lda_factors[4] = 151;\n\tparam->lda_factors[5] = 151;\n\n\tparam->max_num_merge_cand = 5;\n\n\treturn 0;\n}\n\nstatic int allegro_mcu_send_create_channel(struct allegro_dev *dev,\n\t\t\t\t\t   struct allegro_channel *channel)\n{\n\tstruct mcu_msg_create_channel msg;\n\tstruct allegro_buffer *blob = &channel->config_blob;\n\tstruct create_channel_param param;\n\tsize_t size;\n\n\tmemset(&param, 0, sizeof(param));\n\tfill_create_channel_param(channel, &param);\n\tallegro_alloc_buffer(dev, blob, sizeof(struct create_channel_param));\n\tparam.version = dev->fw_info->mailbox_version;\n\tsize = allegro_encode_config_blob(blob->vaddr, &param);\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tmsg.header.type = MCU_MSG_TYPE_CREATE_CHANNEL;\n\tmsg.header.version = dev->fw_info->mailbox_version;\n\n\tmsg.user_id = channel->user_id;\n\n\tmsg.blob = blob->vaddr;\n\tmsg.blob_size = size;\n\tmsg.blob_mcu_addr = to_mcu_addr(dev, blob->paddr);\n\n\tallegro_mbox_send(dev->mbox_command, &msg);\n\n\treturn 0;\n}\n\nstatic int allegro_mcu_send_destroy_channel(struct allegro_dev *dev,\n\t\t\t\t\t    struct allegro_channel *channel)\n{\n\tstruct mcu_msg_destroy_channel msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tmsg.header.type = MCU_MSG_TYPE_DESTROY_CHANNEL;\n\tmsg.header.version = dev->fw_info->mailbox_version;\n\n\tmsg.channel_id = channel->mcu_channel_id;\n\n\tallegro_mbox_send(dev->mbox_command, &msg);\n\n\treturn 0;\n}\n\nstatic int allegro_mcu_send_put_stream_buffer(struct allegro_dev *dev,\n\t\t\t\t\t      struct allegro_channel *channel,\n\t\t\t\t\t      dma_addr_t paddr,\n\t\t\t\t\t      unsigned long size,\n\t\t\t\t\t      u64 dst_handle)\n{\n\tstruct mcu_msg_put_stream_buffer msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tmsg.header.type = MCU_MSG_TYPE_PUT_STREAM_BUFFER;\n\tmsg.header.version = dev->fw_info->mailbox_version;\n\n\tmsg.channel_id = channel->mcu_channel_id;\n\tmsg.dma_addr = to_codec_addr(dev, paddr);\n\tmsg.mcu_addr = to_mcu_addr(dev, paddr);\n\tmsg.size = size;\n\tmsg.offset = ENCODER_STREAM_OFFSET;\n\t \n\tmsg.dst_handle = dst_handle;\n\n\tallegro_mbox_send(dev->mbox_command, &msg);\n\n\treturn 0;\n}\n\nstatic int allegro_mcu_send_encode_frame(struct allegro_dev *dev,\n\t\t\t\t\t struct allegro_channel *channel,\n\t\t\t\t\t dma_addr_t src_y, dma_addr_t src_uv,\n\t\t\t\t\t u64 src_handle)\n{\n\tstruct mcu_msg_encode_frame msg;\n\tbool use_encoder_buffer = v4l2_ctrl_g_ctrl(channel->encoder_buffer);\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tmsg.header.type = MCU_MSG_TYPE_ENCODE_FRAME;\n\tmsg.header.version = dev->fw_info->mailbox_version;\n\n\tmsg.channel_id = channel->mcu_channel_id;\n\tmsg.encoding_options = AL_OPT_FORCE_LOAD;\n\tif (use_encoder_buffer)\n\t\tmsg.encoding_options |= AL_OPT_USE_L2;\n\tmsg.pps_qp = 26;  \n\tmsg.user_param = 0;  \n\t \n\tmsg.src_handle = src_handle;\n\tmsg.src_y = to_codec_addr(dev, src_y);\n\tmsg.src_uv = to_codec_addr(dev, src_uv);\n\tmsg.stride = channel->stride;\n\n\tallegro_mbox_send(dev->mbox_command, &msg);\n\n\treturn 0;\n}\n\nstatic int allegro_mcu_wait_for_init_timeout(struct allegro_dev *dev,\n\t\t\t\t\t     unsigned long timeout_ms)\n{\n\tunsigned long tmo;\n\n\ttmo = wait_for_completion_timeout(&dev->init_complete,\n\t\t\t\t\t  msecs_to_jiffies(timeout_ms));\n\tif (tmo == 0)\n\t\treturn -ETIMEDOUT;\n\n\treinit_completion(&dev->init_complete);\n\treturn 0;\n}\n\nstatic int allegro_mcu_push_buffer_internal(struct allegro_channel *channel,\n\t\t\t\t\t    enum mcu_msg_type type)\n{\n\tstruct allegro_dev *dev = channel->dev;\n\tstruct mcu_msg_push_buffers_internal *msg;\n\tstruct mcu_msg_push_buffers_internal_buffer *buffer;\n\tunsigned int num_buffers = 0;\n\tsize_t size;\n\tstruct allegro_buffer *al_buffer;\n\tstruct list_head *list;\n\tint err;\n\n\tswitch (type) {\n\tcase MCU_MSG_TYPE_PUSH_BUFFER_REFERENCE:\n\t\tlist = &channel->buffers_reference;\n\t\tbreak;\n\tcase MCU_MSG_TYPE_PUSH_BUFFER_INTERMEDIATE:\n\t\tlist = &channel->buffers_intermediate;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlist_for_each_entry(al_buffer, list, head)\n\t\tnum_buffers++;\n\tsize = struct_size(msg, buffer, num_buffers);\n\n\tmsg = kmalloc(size, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->header.type = type;\n\tmsg->header.version = dev->fw_info->mailbox_version;\n\n\tmsg->channel_id = channel->mcu_channel_id;\n\tmsg->num_buffers = num_buffers;\n\n\tbuffer = msg->buffer;\n\tlist_for_each_entry(al_buffer, list, head) {\n\t\tbuffer->dma_addr = to_codec_addr(dev, al_buffer->paddr);\n\t\tbuffer->mcu_addr = to_mcu_addr(dev, al_buffer->paddr);\n\t\tbuffer->size = to_mcu_size(dev, al_buffer->size);\n\t\tbuffer++;\n\t}\n\n\terr = allegro_mbox_send(dev->mbox_command, msg);\n\n\tkfree(msg);\n\treturn err;\n}\n\nstatic int allegro_mcu_push_buffer_intermediate(struct allegro_channel *channel)\n{\n\tenum mcu_msg_type type = MCU_MSG_TYPE_PUSH_BUFFER_INTERMEDIATE;\n\n\treturn allegro_mcu_push_buffer_internal(channel, type);\n}\n\nstatic int allegro_mcu_push_buffer_reference(struct allegro_channel *channel)\n{\n\tenum mcu_msg_type type = MCU_MSG_TYPE_PUSH_BUFFER_REFERENCE;\n\n\treturn allegro_mcu_push_buffer_internal(channel, type);\n}\n\nstatic int allocate_buffers_internal(struct allegro_channel *channel,\n\t\t\t\t     struct list_head *list,\n\t\t\t\t     size_t n, size_t size)\n{\n\tstruct allegro_dev *dev = channel->dev;\n\tunsigned int i;\n\tint err;\n\tstruct allegro_buffer *buffer, *tmp;\n\n\tfor (i = 0; i < n; i++) {\n\t\tbuffer = kmalloc(sizeof(*buffer), GFP_KERNEL);\n\t\tif (!buffer) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tINIT_LIST_HEAD(&buffer->head);\n\n\t\terr = allegro_alloc_buffer(dev, buffer, size);\n\t\tif (err)\n\t\t\tgoto err;\n\t\tlist_add(&buffer->head, list);\n\t}\n\n\treturn 0;\n\nerr:\n\tlist_for_each_entry_safe(buffer, tmp, list, head) {\n\t\tlist_del(&buffer->head);\n\t\tallegro_free_buffer(dev, buffer);\n\t\tkfree(buffer);\n\t}\n\treturn err;\n}\n\nstatic void destroy_buffers_internal(struct allegro_channel *channel,\n\t\t\t\t     struct list_head *list)\n{\n\tstruct allegro_dev *dev = channel->dev;\n\tstruct allegro_buffer *buffer, *tmp;\n\n\tlist_for_each_entry_safe(buffer, tmp, list, head) {\n\t\tlist_del(&buffer->head);\n\t\tallegro_free_buffer(dev, buffer);\n\t\tkfree(buffer);\n\t}\n}\n\nstatic void destroy_reference_buffers(struct allegro_channel *channel)\n{\n\treturn destroy_buffers_internal(channel, &channel->buffers_reference);\n}\n\nstatic void destroy_intermediate_buffers(struct allegro_channel *channel)\n{\n\treturn destroy_buffers_internal(channel,\n\t\t\t\t\t&channel->buffers_intermediate);\n}\n\nstatic int allocate_intermediate_buffers(struct allegro_channel *channel,\n\t\t\t\t\t size_t n, size_t size)\n{\n\treturn allocate_buffers_internal(channel,\n\t\t\t\t\t &channel->buffers_intermediate,\n\t\t\t\t\t n, size);\n}\n\nstatic int allocate_reference_buffers(struct allegro_channel *channel,\n\t\t\t\t      size_t n, size_t size)\n{\n\treturn allocate_buffers_internal(channel,\n\t\t\t\t\t &channel->buffers_reference,\n\t\t\t\t\t n, PAGE_ALIGN(size));\n}\n\nstatic ssize_t allegro_h264_write_sps(struct allegro_channel *channel,\n\t\t\t\t      void *dest, size_t n)\n{\n\tstruct allegro_dev *dev = channel->dev;\n\tstruct nal_h264_sps *sps;\n\tssize_t size;\n\tunsigned int size_mb = SIZE_MACROBLOCK;\n\t \n\tunsigned int crop_unit_x = 2;\n\tunsigned int crop_unit_y = 2;\n\tenum v4l2_mpeg_video_h264_profile profile;\n\tenum v4l2_mpeg_video_h264_level level;\n\tunsigned int cpb_size;\n\tunsigned int cpb_size_scale;\n\n\tsps = kzalloc(sizeof(*sps), GFP_KERNEL);\n\tif (!sps)\n\t\treturn -ENOMEM;\n\n\tprofile = v4l2_ctrl_g_ctrl(channel->mpeg_video_h264_profile);\n\tlevel = v4l2_ctrl_g_ctrl(channel->mpeg_video_h264_level);\n\n\tsps->profile_idc = nal_h264_profile(profile);\n\tsps->constraint_set0_flag = 0;\n\tsps->constraint_set1_flag = 1;\n\tsps->constraint_set2_flag = 0;\n\tsps->constraint_set3_flag = 0;\n\tsps->constraint_set4_flag = 0;\n\tsps->constraint_set5_flag = 0;\n\tsps->level_idc = nal_h264_level(level);\n\tsps->seq_parameter_set_id = 0;\n\tsps->log2_max_frame_num_minus4 = LOG2_MAX_FRAME_NUM - 4;\n\tsps->pic_order_cnt_type = 0;\n\tsps->log2_max_pic_order_cnt_lsb_minus4 = LOG2_MAX_PIC_ORDER_CNT - 4;\n\tsps->max_num_ref_frames = 3;\n\tsps->gaps_in_frame_num_value_allowed_flag = 0;\n\tsps->pic_width_in_mbs_minus1 =\n\t\tDIV_ROUND_UP(channel->width, size_mb) - 1;\n\tsps->pic_height_in_map_units_minus1 =\n\t\tDIV_ROUND_UP(channel->height, size_mb) - 1;\n\tsps->frame_mbs_only_flag = 1;\n\tsps->mb_adaptive_frame_field_flag = 0;\n\tsps->direct_8x8_inference_flag = 1;\n\tsps->frame_cropping_flag =\n\t\t(channel->width % size_mb) || (channel->height % size_mb);\n\tif (sps->frame_cropping_flag) {\n\t\tsps->crop_left = 0;\n\t\tsps->crop_right = (round_up(channel->width, size_mb) - channel->width) / crop_unit_x;\n\t\tsps->crop_top = 0;\n\t\tsps->crop_bottom = (round_up(channel->height, size_mb) - channel->height) / crop_unit_y;\n\t}\n\tsps->vui_parameters_present_flag = 1;\n\tsps->vui.aspect_ratio_info_present_flag = 0;\n\tsps->vui.overscan_info_present_flag = 0;\n\n\tsps->vui.video_signal_type_present_flag = 1;\n\tsps->vui.video_format = 5;  \n\tsps->vui.video_full_range_flag = nal_h264_full_range(channel->quantization);\n\tsps->vui.colour_description_present_flag = 1;\n\tsps->vui.colour_primaries = nal_h264_color_primaries(channel->colorspace);\n\tsps->vui.transfer_characteristics =\n\t\tnal_h264_transfer_characteristics(channel->colorspace, channel->xfer_func);\n\tsps->vui.matrix_coefficients =\n\t\tnal_h264_matrix_coeffs(channel->colorspace, channel->ycbcr_enc);\n\n\tsps->vui.chroma_loc_info_present_flag = 1;\n\tsps->vui.chroma_sample_loc_type_top_field = 0;\n\tsps->vui.chroma_sample_loc_type_bottom_field = 0;\n\n\tsps->vui.timing_info_present_flag = 1;\n\tsps->vui.num_units_in_tick = channel->framerate.denominator;\n\tsps->vui.time_scale = 2 * channel->framerate.numerator;\n\n\tsps->vui.fixed_frame_rate_flag = 1;\n\tsps->vui.nal_hrd_parameters_present_flag = 0;\n\tsps->vui.vcl_hrd_parameters_present_flag = 1;\n\tsps->vui.vcl_hrd_parameters.cpb_cnt_minus1 = 0;\n\t \n\tsps->vui.vcl_hrd_parameters.bit_rate_scale =\n\t\tffs(channel->bitrate_peak) - 6;\n\tsps->vui.vcl_hrd_parameters.bit_rate_value_minus1[0] =\n\t\tchannel->bitrate_peak / (1 << (6 + sps->vui.vcl_hrd_parameters.bit_rate_scale)) - 1;\n\t \n\tcpb_size = v4l2_ctrl_g_ctrl(channel->mpeg_video_cpb_size);\n\tcpb_size_scale = ffs(cpb_size) - 4;\n\tsps->vui.vcl_hrd_parameters.cpb_size_scale = cpb_size_scale;\n\tsps->vui.vcl_hrd_parameters.cpb_size_value_minus1[0] =\n\t\t(cpb_size * 1000) / (1 << (4 + cpb_size_scale)) - 1;\n\tsps->vui.vcl_hrd_parameters.cbr_flag[0] =\n\t\t!v4l2_ctrl_g_ctrl(channel->mpeg_video_frame_rc_enable);\n\tsps->vui.vcl_hrd_parameters.initial_cpb_removal_delay_length_minus1 = 31;\n\tsps->vui.vcl_hrd_parameters.cpb_removal_delay_length_minus1 = 31;\n\tsps->vui.vcl_hrd_parameters.dpb_output_delay_length_minus1 = 31;\n\tsps->vui.vcl_hrd_parameters.time_offset_length = 0;\n\tsps->vui.low_delay_hrd_flag = 0;\n\tsps->vui.pic_struct_present_flag = 1;\n\tsps->vui.bitstream_restriction_flag = 0;\n\n\tsize = nal_h264_write_sps(&dev->plat_dev->dev, dest, n, sps);\n\n\tkfree(sps);\n\n\treturn size;\n}\n\nstatic ssize_t allegro_h264_write_pps(struct allegro_channel *channel,\n\t\t\t\t      void *dest, size_t n)\n{\n\tstruct allegro_dev *dev = channel->dev;\n\tstruct nal_h264_pps *pps;\n\tssize_t size;\n\n\tpps = kzalloc(sizeof(*pps), GFP_KERNEL);\n\tif (!pps)\n\t\treturn -ENOMEM;\n\n\tpps->pic_parameter_set_id = 0;\n\tpps->seq_parameter_set_id = 0;\n\tpps->entropy_coding_mode_flag = 0;\n\tpps->bottom_field_pic_order_in_frame_present_flag = 0;\n\tpps->num_slice_groups_minus1 = 0;\n\tpps->num_ref_idx_l0_default_active_minus1 = channel->num_ref_idx_l0 - 1;\n\tpps->num_ref_idx_l1_default_active_minus1 = channel->num_ref_idx_l1 - 1;\n\tpps->weighted_pred_flag = 0;\n\tpps->weighted_bipred_idc = 0;\n\tpps->pic_init_qp_minus26 = 0;\n\tpps->pic_init_qs_minus26 = 0;\n\tpps->chroma_qp_index_offset = 0;\n\tpps->deblocking_filter_control_present_flag = 1;\n\tpps->constrained_intra_pred_flag = 0;\n\tpps->redundant_pic_cnt_present_flag = 0;\n\tpps->transform_8x8_mode_flag = 0;\n\tpps->pic_scaling_matrix_present_flag = 0;\n\tpps->second_chroma_qp_index_offset = 0;\n\n\tsize = nal_h264_write_pps(&dev->plat_dev->dev, dest, n, pps);\n\n\tkfree(pps);\n\n\treturn size;\n}\n\nstatic void allegro_channel_eos_event(struct allegro_channel *channel)\n{\n\tconst struct v4l2_event eos_event = {\n\t\t.type = V4L2_EVENT_EOS\n\t};\n\n\tv4l2_event_queue_fh(&channel->fh, &eos_event);\n}\n\nstatic ssize_t allegro_hevc_write_vps(struct allegro_channel *channel,\n\t\t\t\t      void *dest, size_t n)\n{\n\tstruct allegro_dev *dev = channel->dev;\n\tstruct nal_hevc_vps *vps;\n\tstruct nal_hevc_profile_tier_level *ptl;\n\tssize_t size;\n\tunsigned int num_ref_frames = channel->num_ref_idx_l0;\n\ts32 profile = v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_profile);\n\ts32 level = v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_level);\n\ts32 tier = v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_tier);\n\n\tvps = kzalloc(sizeof(*vps), GFP_KERNEL);\n\tif (!vps)\n\t\treturn -ENOMEM;\n\n\tvps->base_layer_internal_flag = 1;\n\tvps->base_layer_available_flag = 1;\n\tvps->temporal_id_nesting_flag = 1;\n\n\tptl = &vps->profile_tier_level;\n\tptl->general_profile_idc = nal_hevc_profile(profile);\n\tptl->general_profile_compatibility_flag[ptl->general_profile_idc] = 1;\n\tptl->general_tier_flag = nal_hevc_tier(tier);\n\tptl->general_progressive_source_flag = 1;\n\tptl->general_frame_only_constraint_flag = 1;\n\tptl->general_level_idc = nal_hevc_level(level);\n\n\tvps->sub_layer_ordering_info_present_flag = 0;\n\tvps->max_dec_pic_buffering_minus1[0] = num_ref_frames;\n\tvps->max_num_reorder_pics[0] = num_ref_frames;\n\n\tsize = nal_hevc_write_vps(&dev->plat_dev->dev, dest, n, vps);\n\n\tkfree(vps);\n\n\treturn size;\n}\n\nstatic ssize_t allegro_hevc_write_sps(struct allegro_channel *channel,\n\t\t\t\t      void *dest, size_t n)\n{\n\tstruct allegro_dev *dev = channel->dev;\n\tstruct nal_hevc_sps *sps;\n\tstruct nal_hevc_profile_tier_level *ptl;\n\tstruct nal_hevc_vui_parameters *vui;\n\tstruct nal_hevc_hrd_parameters *hrd;\n\tssize_t size;\n\tunsigned int cpb_size;\n\tunsigned int num_ref_frames = channel->num_ref_idx_l0;\n\ts32 profile = v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_profile);\n\ts32 level = v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_level);\n\ts32 tier = v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_tier);\n\n\tsps = kzalloc(sizeof(*sps), GFP_KERNEL);\n\tif (!sps)\n\t\treturn -ENOMEM;\n\n\tsps->temporal_id_nesting_flag = 1;\n\n\tptl = &sps->profile_tier_level;\n\tptl->general_profile_idc = nal_hevc_profile(profile);\n\tptl->general_profile_compatibility_flag[ptl->general_profile_idc] = 1;\n\tptl->general_tier_flag = nal_hevc_tier(tier);\n\tptl->general_progressive_source_flag = 1;\n\tptl->general_frame_only_constraint_flag = 1;\n\tptl->general_level_idc = nal_hevc_level(level);\n\n\tsps->seq_parameter_set_id = 0;\n\tsps->chroma_format_idc = 1;  \n\tsps->pic_width_in_luma_samples = round_up(channel->width, 8);\n\tsps->pic_height_in_luma_samples = round_up(channel->height, 8);\n\tsps->conf_win_right_offset =\n\t\tsps->pic_width_in_luma_samples - channel->width;\n\tsps->conf_win_bottom_offset =\n\t\tsps->pic_height_in_luma_samples - channel->height;\n\tsps->conformance_window_flag =\n\t\tsps->conf_win_right_offset || sps->conf_win_bottom_offset;\n\n\tsps->log2_max_pic_order_cnt_lsb_minus4 = LOG2_MAX_PIC_ORDER_CNT - 4;\n\n\tsps->sub_layer_ordering_info_present_flag = 1;\n\tsps->max_dec_pic_buffering_minus1[0] = num_ref_frames;\n\tsps->max_num_reorder_pics[0] = num_ref_frames;\n\n\tsps->log2_min_luma_coding_block_size_minus3 =\n\t\tchannel->min_cu_size - 3;\n\tsps->log2_diff_max_min_luma_coding_block_size =\n\t\tchannel->max_cu_size - channel->min_cu_size;\n\tsps->log2_min_luma_transform_block_size_minus2 =\n\t\tchannel->min_tu_size - 2;\n\tsps->log2_diff_max_min_luma_transform_block_size =\n\t\tchannel->max_tu_size - channel->min_tu_size;\n\tsps->max_transform_hierarchy_depth_intra =\n\t\tchannel->max_transfo_depth_intra;\n\tsps->max_transform_hierarchy_depth_inter =\n\t\tchannel->max_transfo_depth_inter;\n\n\tsps->sps_temporal_mvp_enabled_flag = channel->temporal_mvp_enable;\n\tsps->strong_intra_smoothing_enabled_flag = channel->max_cu_size > 4;\n\n\tsps->vui_parameters_present_flag = 1;\n\tvui = &sps->vui;\n\n\tvui->video_signal_type_present_flag = 1;\n\tvui->video_format = 5;  \n\tvui->video_full_range_flag = nal_hevc_full_range(channel->quantization);\n\tvui->colour_description_present_flag = 1;\n\tvui->colour_primaries = nal_hevc_color_primaries(channel->colorspace);\n\tvui->transfer_characteristics = nal_hevc_transfer_characteristics(channel->colorspace,\n\t\t\t\t\t\t\t\t\t  channel->xfer_func);\n\tvui->matrix_coeffs = nal_hevc_matrix_coeffs(channel->colorspace, channel->ycbcr_enc);\n\n\tvui->chroma_loc_info_present_flag = 1;\n\tvui->chroma_sample_loc_type_top_field = 0;\n\tvui->chroma_sample_loc_type_bottom_field = 0;\n\n\tvui->vui_timing_info_present_flag = 1;\n\tvui->vui_num_units_in_tick = channel->framerate.denominator;\n\tvui->vui_time_scale = channel->framerate.numerator;\n\n\tvui->bitstream_restriction_flag = 1;\n\tvui->motion_vectors_over_pic_boundaries_flag = 1;\n\tvui->restricted_ref_pic_lists_flag = 1;\n\tvui->log2_max_mv_length_horizontal = 15;\n\tvui->log2_max_mv_length_vertical = 15;\n\n\tvui->vui_hrd_parameters_present_flag = 1;\n\thrd = &vui->nal_hrd_parameters;\n\thrd->vcl_hrd_parameters_present_flag = 1;\n\n\thrd->initial_cpb_removal_delay_length_minus1 = 31;\n\thrd->au_cpb_removal_delay_length_minus1 = 30;\n\thrd->dpb_output_delay_length_minus1 = 30;\n\n\thrd->bit_rate_scale = ffs(channel->bitrate_peak) - 6;\n\thrd->vcl_hrd[0].bit_rate_value_minus1[0] =\n\t\t(channel->bitrate_peak >> (6 + hrd->bit_rate_scale)) - 1;\n\n\tcpb_size = v4l2_ctrl_g_ctrl(channel->mpeg_video_cpb_size) * 1000;\n\thrd->cpb_size_scale = ffs(cpb_size) - 4;\n\thrd->vcl_hrd[0].cpb_size_value_minus1[0] = (cpb_size >> (4 + hrd->cpb_size_scale)) - 1;\n\n\thrd->vcl_hrd[0].cbr_flag[0] = !v4l2_ctrl_g_ctrl(channel->mpeg_video_frame_rc_enable);\n\n\tsize = nal_hevc_write_sps(&dev->plat_dev->dev, dest, n, sps);\n\n\tkfree(sps);\n\n\treturn size;\n}\n\nstatic ssize_t allegro_hevc_write_pps(struct allegro_channel *channel,\n\t\t\t\t      struct mcu_msg_encode_frame_response *msg,\n\t\t\t\t      void *dest, size_t n)\n{\n\tstruct allegro_dev *dev = channel->dev;\n\tstruct nal_hevc_pps *pps;\n\tssize_t size;\n\tint i;\n\n\tpps = kzalloc(sizeof(*pps), GFP_KERNEL);\n\tif (!pps)\n\t\treturn -ENOMEM;\n\n\tpps->pps_pic_parameter_set_id = 0;\n\tpps->pps_seq_parameter_set_id = 0;\n\n\tif (msg->num_column > 1 || msg->num_row > 1) {\n\t\tpps->tiles_enabled_flag = 1;\n\t\tpps->num_tile_columns_minus1 = msg->num_column - 1;\n\t\tpps->num_tile_rows_minus1 = msg->num_row - 1;\n\n\t\tfor (i = 0; i < msg->num_column; i++)\n\t\t\tpps->column_width_minus1[i] = msg->tile_width[i] - 1;\n\n\t\tfor (i = 0; i < msg->num_row; i++)\n\t\t\tpps->row_height_minus1[i] = msg->tile_height[i] - 1;\n\t}\n\n\tpps->loop_filter_across_tiles_enabled_flag =\n\t\tchannel->enable_loop_filter_across_tiles;\n\tpps->pps_loop_filter_across_slices_enabled_flag =\n\t\tchannel->enable_loop_filter_across_slices;\n\tpps->deblocking_filter_control_present_flag = 1;\n\tpps->deblocking_filter_override_enabled_flag =\n\t\tchannel->enable_deblocking_filter_override;\n\tpps->pps_beta_offset_div2 = BETA_OFFSET_DIV_2;\n\tpps->pps_tc_offset_div2 = TC_OFFSET_DIV_2;\n\n\tpps->lists_modification_present_flag = channel->enable_reordering;\n\n\tsize = nal_hevc_write_pps(&dev->plat_dev->dev, dest, n, pps);\n\n\tkfree(pps);\n\n\treturn size;\n}\n\nstatic u64 allegro_put_buffer(struct allegro_channel *channel,\n\t\t\t      struct list_head *list,\n\t\t\t      struct vb2_v4l2_buffer *buffer)\n{\n\tstruct v4l2_m2m_buffer *b = container_of(buffer,\n\t\t\t\t\t\t struct v4l2_m2m_buffer, vb);\n\tstruct allegro_m2m_buffer *shadow = to_allegro_m2m_buffer(b);\n\n\tmutex_lock(&channel->shadow_list_lock);\n\tlist_add_tail(&shadow->head, list);\n\tmutex_unlock(&channel->shadow_list_lock);\n\n\treturn ptr_to_u64(buffer);\n}\n\nstatic struct vb2_v4l2_buffer *\nallegro_get_buffer(struct allegro_channel *channel,\n\t\t   struct list_head *list, u64 handle)\n{\n\tstruct allegro_m2m_buffer *shadow, *tmp;\n\tstruct vb2_v4l2_buffer *buffer = NULL;\n\n\tmutex_lock(&channel->shadow_list_lock);\n\tlist_for_each_entry_safe(shadow, tmp, list, head) {\n\t\tif (handle == ptr_to_u64(&shadow->buf.vb)) {\n\t\t\tbuffer = &shadow->buf.vb;\n\t\t\tlist_del_init(&shadow->head);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&channel->shadow_list_lock);\n\n\treturn buffer;\n}\n\nstatic void allegro_channel_finish_frame(struct allegro_channel *channel,\n\t\tstruct mcu_msg_encode_frame_response *msg)\n{\n\tstruct allegro_dev *dev = channel->dev;\n\tstruct vb2_v4l2_buffer *src_buf;\n\tstruct vb2_v4l2_buffer *dst_buf;\n\tstruct {\n\t\tu32 offset;\n\t\tu32 size;\n\t} *partition;\n\tenum vb2_buffer_state state = VB2_BUF_STATE_ERROR;\n\tchar *curr;\n\tssize_t len;\n\tssize_t free;\n\n\tsrc_buf = allegro_get_buffer(channel, &channel->source_shadow_list,\n\t\t\t\t     msg->src_handle);\n\tif (!src_buf)\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"channel %d: invalid source buffer\\n\",\n\t\t\t  channel->mcu_channel_id);\n\n\tdst_buf = allegro_get_buffer(channel, &channel->stream_shadow_list,\n\t\t\t\t     msg->dst_handle);\n\tif (!dst_buf)\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"channel %d: invalid stream buffer\\n\",\n\t\t\t  channel->mcu_channel_id);\n\n\tif (!src_buf || !dst_buf)\n\t\tgoto err;\n\n\tif (v4l2_m2m_is_last_draining_src_buf(channel->fh.m2m_ctx, src_buf)) {\n\t\tdst_buf->flags |= V4L2_BUF_FLAG_LAST;\n\t\tallegro_channel_eos_event(channel);\n\t\tv4l2_m2m_mark_stopped(channel->fh.m2m_ctx);\n\t}\n\n\tdst_buf->sequence = channel->csequence++;\n\n\tif (msg->error_code & AL_ERROR) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"channel %d: failed to encode frame: %s (%x)\\n\",\n\t\t\t channel->mcu_channel_id,\n\t\t\t allegro_err_to_string(msg->error_code),\n\t\t\t msg->error_code);\n\t\tgoto err;\n\t}\n\n\tif (msg->partition_table_size != 1) {\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"channel %d: only handling first partition table entry (%d entries)\\n\",\n\t\t\t  channel->mcu_channel_id, msg->partition_table_size);\n\t}\n\n\tif (msg->partition_table_offset +\n\t    msg->partition_table_size * sizeof(*partition) >\n\t    vb2_plane_size(&dst_buf->vb2_buf, 0)) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"channel %d: partition table outside of dst_buf\\n\",\n\t\t\t channel->mcu_channel_id);\n\t\tgoto err;\n\t}\n\n\tpartition =\n\t    vb2_plane_vaddr(&dst_buf->vb2_buf, 0) + msg->partition_table_offset;\n\tif (partition->offset + partition->size >\n\t    vb2_plane_size(&dst_buf->vb2_buf, 0)) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"channel %d: encoded frame is outside of dst_buf (offset 0x%x, size 0x%x)\\n\",\n\t\t\t channel->mcu_channel_id, partition->offset,\n\t\t\t partition->size);\n\t\tgoto err;\n\t}\n\n\tv4l2_dbg(2, debug, &dev->v4l2_dev,\n\t\t \"channel %d: encoded frame of size %d is at offset 0x%x\\n\",\n\t\t channel->mcu_channel_id, partition->size, partition->offset);\n\n\t \n\tvb2_set_plane_payload(&dst_buf->vb2_buf, 0,\n\t\t\t      partition->offset + partition->size);\n\n\tcurr = vb2_plane_vaddr(&dst_buf->vb2_buf, 0);\n\tfree = partition->offset;\n\n\tif (channel->codec == V4L2_PIX_FMT_HEVC && msg->is_idr) {\n\t\tlen = allegro_hevc_write_vps(channel, curr, free);\n\t\tif (len < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"not enough space for video parameter set: %zd left\\n\",\n\t\t\t\t free);\n\t\t\tgoto err;\n\t\t}\n\t\tcurr += len;\n\t\tfree -= len;\n\t\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t\t \"channel %d: wrote %zd byte VPS nal unit\\n\",\n\t\t\t channel->mcu_channel_id, len);\n\t}\n\n\tif (msg->is_idr) {\n\t\tif (channel->codec == V4L2_PIX_FMT_H264)\n\t\t\tlen = allegro_h264_write_sps(channel, curr, free);\n\t\telse\n\t\t\tlen = allegro_hevc_write_sps(channel, curr, free);\n\t\tif (len < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"not enough space for sequence parameter set: %zd left\\n\",\n\t\t\t\t free);\n\t\t\tgoto err;\n\t\t}\n\t\tcurr += len;\n\t\tfree -= len;\n\t\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t\t \"channel %d: wrote %zd byte SPS nal unit\\n\",\n\t\t\t channel->mcu_channel_id, len);\n\t}\n\n\tif (msg->slice_type == AL_ENC_SLICE_TYPE_I) {\n\t\tif (channel->codec == V4L2_PIX_FMT_H264)\n\t\t\tlen = allegro_h264_write_pps(channel, curr, free);\n\t\telse\n\t\t\tlen = allegro_hevc_write_pps(channel, msg, curr, free);\n\t\tif (len < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"not enough space for picture parameter set: %zd left\\n\",\n\t\t\t\t free);\n\t\t\tgoto err;\n\t\t}\n\t\tcurr += len;\n\t\tfree -= len;\n\t\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t\t \"channel %d: wrote %zd byte PPS nal unit\\n\",\n\t\t\t channel->mcu_channel_id, len);\n\t}\n\n\tif (msg->slice_type != AL_ENC_SLICE_TYPE_I && !msg->is_idr) {\n\t\tdst_buf->vb2_buf.planes[0].data_offset = free;\n\t\tfree = 0;\n\t} else {\n\t\tif (channel->codec == V4L2_PIX_FMT_H264)\n\t\t\tlen = nal_h264_write_filler(&dev->plat_dev->dev, curr, free);\n\t\telse\n\t\t\tlen = nal_hevc_write_filler(&dev->plat_dev->dev, curr, free);\n\t\tif (len < 0) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"failed to write %zd filler data\\n\", free);\n\t\t\tgoto err;\n\t\t}\n\t\tcurr += len;\n\t\tfree -= len;\n\t\tv4l2_dbg(2, debug, &dev->v4l2_dev,\n\t\t\t \"channel %d: wrote %zd bytes filler nal unit\\n\",\n\t\t\t channel->mcu_channel_id, len);\n\t}\n\n\tif (free != 0) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"non-VCL NAL units do not fill space until VCL NAL unit: %zd bytes left\\n\",\n\t\t\t free);\n\t\tgoto err;\n\t}\n\n\tstate = VB2_BUF_STATE_DONE;\n\n\tv4l2_m2m_buf_copy_metadata(src_buf, dst_buf, false);\n\tif (msg->is_idr)\n\t\tdst_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;\n\telse\n\t\tdst_buf->flags |= V4L2_BUF_FLAG_PFRAME;\n\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"channel %d: encoded frame #%03d (%s%s, QP %d, %d bytes)\\n\",\n\t\t channel->mcu_channel_id,\n\t\t dst_buf->sequence,\n\t\t msg->is_idr ? \"IDR, \" : \"\",\n\t\t msg->slice_type == AL_ENC_SLICE_TYPE_I ? \"I slice\" :\n\t\t msg->slice_type == AL_ENC_SLICE_TYPE_P ? \"P slice\" : \"unknown\",\n\t\t msg->qp, partition->size);\n\nerr:\n\tif (src_buf)\n\t\tv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\n\n\tif (dst_buf)\n\t\tv4l2_m2m_buf_done(dst_buf, state);\n}\n\nstatic int allegro_handle_init(struct allegro_dev *dev,\n\t\t\t       struct mcu_msg_init_response *msg)\n{\n\tcomplete(&dev->init_complete);\n\n\treturn 0;\n}\n\nstatic int\nallegro_handle_create_channel(struct allegro_dev *dev,\n\t\t\t      struct mcu_msg_create_channel_response *msg)\n{\n\tstruct allegro_channel *channel;\n\tint err = 0;\n\tstruct create_channel_param param;\n\n\tchannel = allegro_find_channel_by_user_id(dev, msg->user_id);\n\tif (IS_ERR(channel)) {\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"received %s for unknown user %d\\n\",\n\t\t\t  msg_type_name(msg->header.type),\n\t\t\t  msg->user_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (msg->error_code) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"user %d: mcu failed to create channel: %s (%x)\\n\",\n\t\t\t channel->user_id,\n\t\t\t allegro_err_to_string(msg->error_code),\n\t\t\t msg->error_code);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tchannel->mcu_channel_id = msg->channel_id;\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"user %d: channel has channel id %d\\n\",\n\t\t channel->user_id, channel->mcu_channel_id);\n\n\terr = allegro_decode_config_blob(&param, msg, channel->config_blob.vaddr);\n\tallegro_free_buffer(channel->dev, &channel->config_blob);\n\tif (err)\n\t\tgoto out;\n\n\tchannel->num_ref_idx_l0 = param.num_ref_idx_l0;\n\tchannel->num_ref_idx_l1 = param.num_ref_idx_l1;\n\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"channel %d: intermediate buffers: %d x %d bytes\\n\",\n\t\t channel->mcu_channel_id,\n\t\t msg->int_buffers_count, msg->int_buffers_size);\n\terr = allocate_intermediate_buffers(channel, msg->int_buffers_count,\n\t\t\t\t\t    msg->int_buffers_size);\n\tif (err) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"channel %d: failed to allocate intermediate buffers\\n\",\n\t\t\t channel->mcu_channel_id);\n\t\tgoto out;\n\t}\n\terr = allegro_mcu_push_buffer_intermediate(channel);\n\tif (err)\n\t\tgoto out;\n\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"channel %d: reference buffers: %d x %d bytes\\n\",\n\t\t channel->mcu_channel_id,\n\t\t msg->rec_buffers_count, msg->rec_buffers_size);\n\terr = allocate_reference_buffers(channel, msg->rec_buffers_count,\n\t\t\t\t\t msg->rec_buffers_size);\n\tif (err) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"channel %d: failed to allocate reference buffers\\n\",\n\t\t\t channel->mcu_channel_id);\n\t\tgoto out;\n\t}\n\terr = allegro_mcu_push_buffer_reference(channel);\n\tif (err)\n\t\tgoto out;\n\nout:\n\tchannel->error = err;\n\tcomplete(&channel->completion);\n\n\t \n\treturn 0;\n}\n\nstatic int\nallegro_handle_destroy_channel(struct allegro_dev *dev,\n\t\t\t       struct mcu_msg_destroy_channel_response *msg)\n{\n\tstruct allegro_channel *channel;\n\n\tchannel = allegro_find_channel_by_channel_id(dev, msg->channel_id);\n\tif (IS_ERR(channel)) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"received %s for unknown channel %d\\n\",\n\t\t\t msg_type_name(msg->header.type),\n\t\t\t msg->channel_id);\n\t\treturn -EINVAL;\n\t}\n\n\tv4l2_dbg(2, debug, &dev->v4l2_dev,\n\t\t \"user %d: vcu destroyed channel %d\\n\",\n\t\t channel->user_id, channel->mcu_channel_id);\n\tcomplete(&channel->completion);\n\n\treturn 0;\n}\n\nstatic int\nallegro_handle_encode_frame(struct allegro_dev *dev,\n\t\t\t    struct mcu_msg_encode_frame_response *msg)\n{\n\tstruct allegro_channel *channel;\n\n\tchannel = allegro_find_channel_by_channel_id(dev, msg->channel_id);\n\tif (IS_ERR(channel)) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"received %s for unknown channel %d\\n\",\n\t\t\t msg_type_name(msg->header.type),\n\t\t\t msg->channel_id);\n\t\treturn -EINVAL;\n\t}\n\n\tallegro_channel_finish_frame(channel, msg);\n\n\treturn 0;\n}\n\nstatic void allegro_handle_message(struct allegro_dev *dev,\n\t\t\t\t   union mcu_msg_response *msg)\n{\n\tswitch (msg->header.type) {\n\tcase MCU_MSG_TYPE_INIT:\n\t\tallegro_handle_init(dev, &msg->init);\n\t\tbreak;\n\tcase MCU_MSG_TYPE_CREATE_CHANNEL:\n\t\tallegro_handle_create_channel(dev, &msg->create_channel);\n\t\tbreak;\n\tcase MCU_MSG_TYPE_DESTROY_CHANNEL:\n\t\tallegro_handle_destroy_channel(dev, &msg->destroy_channel);\n\t\tbreak;\n\tcase MCU_MSG_TYPE_ENCODE_FRAME:\n\t\tallegro_handle_encode_frame(dev, &msg->encode_frame);\n\t\tbreak;\n\tdefault:\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"%s: unknown message %s\\n\",\n\t\t\t  __func__, msg_type_name(msg->header.type));\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t allegro_hardirq(int irq, void *data)\n{\n\tstruct allegro_dev *dev = data;\n\tunsigned int status;\n\n\tregmap_read(dev->regmap, AL5_ITC_CPU_IRQ_STA, &status);\n\tif (!(status & AL5_ITC_CPU_IRQ_STA_TRIGGERED))\n\t\treturn IRQ_NONE;\n\n\tregmap_write(dev->regmap, AL5_ITC_CPU_IRQ_CLR, status);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t allegro_irq_thread(int irq, void *data)\n{\n\tstruct allegro_dev *dev = data;\n\n\t \n\tif (!dev->mbox_status)\n\t\treturn IRQ_NONE;\n\n\tallegro_mbox_notify(dev->mbox_status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void allegro_copy_firmware(struct allegro_dev *dev,\n\t\t\t\t  const u8 * const buf, size_t size)\n{\n\tint err = 0;\n\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"copy mcu firmware (%zu B) to SRAM\\n\", size);\n\terr = regmap_bulk_write(dev->sram, 0x0, buf, size / 4);\n\tif (err)\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"failed to copy firmware: %d\\n\", err);\n}\n\nstatic void allegro_copy_fw_codec(struct allegro_dev *dev,\n\t\t\t\t  const u8 * const buf, size_t size)\n{\n\tint err;\n\tdma_addr_t icache_offset, dcache_offset;\n\n\t \n\terr = allegro_alloc_buffer(dev, &dev->firmware, size);\n\tif (err) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"failed to allocate %zu bytes for firmware\\n\", size);\n\t\treturn;\n\t}\n\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"copy codec firmware (%zd B) to phys %pad\\n\",\n\t\t size, &dev->firmware.paddr);\n\tmemcpy(dev->firmware.vaddr, buf, size);\n\n\tregmap_write(dev->regmap, AXI_ADDR_OFFSET_IP,\n\t\t     upper_32_bits(dev->firmware.paddr));\n\n\ticache_offset = dev->firmware.paddr - MCU_CACHE_OFFSET;\n\tv4l2_dbg(2, debug, &dev->v4l2_dev,\n\t\t \"icache_offset: msb = 0x%x, lsb = 0x%x\\n\",\n\t\t upper_32_bits(icache_offset), lower_32_bits(icache_offset));\n\tregmap_write(dev->regmap, AL5_ICACHE_ADDR_OFFSET_MSB,\n\t\t     upper_32_bits(icache_offset));\n\tregmap_write(dev->regmap, AL5_ICACHE_ADDR_OFFSET_LSB,\n\t\t     lower_32_bits(icache_offset));\n\n\tdcache_offset =\n\t    (dev->firmware.paddr & 0xffffffff00000000ULL) - MCU_CACHE_OFFSET;\n\tv4l2_dbg(2, debug, &dev->v4l2_dev,\n\t\t \"dcache_offset: msb = 0x%x, lsb = 0x%x\\n\",\n\t\t upper_32_bits(dcache_offset), lower_32_bits(dcache_offset));\n\tregmap_write(dev->regmap, AL5_DCACHE_ADDR_OFFSET_MSB,\n\t\t     upper_32_bits(dcache_offset));\n\tregmap_write(dev->regmap, AL5_DCACHE_ADDR_OFFSET_LSB,\n\t\t     lower_32_bits(dcache_offset));\n}\n\nstatic void allegro_free_fw_codec(struct allegro_dev *dev)\n{\n\tallegro_free_buffer(dev, &dev->firmware);\n}\n\n \n\nstatic int allegro_mcu_enable_interrupts(struct allegro_dev *dev)\n{\n\treturn regmap_write(dev->regmap, AL5_ITC_CPU_IRQ_MSK, BIT(0));\n}\n\nstatic int allegro_mcu_disable_interrupts(struct allegro_dev *dev)\n{\n\treturn regmap_write(dev->regmap, AL5_ITC_CPU_IRQ_MSK, 0);\n}\n\nstatic int allegro_mcu_wait_for_sleep(struct allegro_dev *dev)\n{\n\tunsigned long timeout;\n\tunsigned int status;\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\twhile (regmap_read(dev->regmap, AL5_MCU_STA, &status) == 0 &&\n\t       status != AL5_MCU_STA_SLEEP) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\t\tcpu_relax();\n\t}\n\n\treturn 0;\n}\n\nstatic int allegro_mcu_start(struct allegro_dev *dev)\n{\n\tunsigned long timeout;\n\tunsigned int status;\n\tint err;\n\n\terr = regmap_write(dev->regmap, AL5_MCU_WAKEUP, BIT(0));\n\tif (err)\n\t\treturn err;\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\twhile (regmap_read(dev->regmap, AL5_MCU_STA, &status) == 0 &&\n\t       status == AL5_MCU_STA_SLEEP) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\t\tcpu_relax();\n\t}\n\n\terr = regmap_write(dev->regmap, AL5_MCU_WAKEUP, 0);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int allegro_mcu_reset(struct allegro_dev *dev)\n{\n\tint err;\n\n\t \n\terr = regmap_write(dev->regmap, AL5_MCU_WAKEUP, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(dev->regmap,\n\t\t\t   AL5_MCU_RESET_MODE, AL5_MCU_RESET_MODE_SLEEP);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = regmap_write(dev->regmap, AL5_MCU_RESET, AL5_MCU_RESET_SOFT);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn allegro_mcu_wait_for_sleep(dev);\n}\n\nstatic void allegro_mcu_interrupt(struct allegro_dev *dev)\n{\n\tregmap_write(dev->regmap, AL5_MCU_INTERRUPT, BIT(0));\n}\n\nstatic void allegro_destroy_channel(struct allegro_channel *channel)\n{\n\tstruct allegro_dev *dev = channel->dev;\n\tunsigned long timeout;\n\n\tif (channel_exists(channel)) {\n\t\treinit_completion(&channel->completion);\n\t\tallegro_mcu_send_destroy_channel(dev, channel);\n\t\ttimeout = wait_for_completion_timeout(&channel->completion,\n\t\t\t\t\t\t      msecs_to_jiffies(5000));\n\t\tif (timeout == 0)\n\t\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t\t  \"channel %d: timeout while destroying\\n\",\n\t\t\t\t  channel->mcu_channel_id);\n\n\t\tchannel->mcu_channel_id = -1;\n\t}\n\n\tdestroy_intermediate_buffers(channel);\n\tdestroy_reference_buffers(channel);\n\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_profile, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_level, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_i_frame_qp, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_max_qp, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_min_qp, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_p_frame_qp, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_b_frame_qp, false);\n\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_profile, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_level, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_tier, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_i_frame_qp, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_max_qp, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_min_qp, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_p_frame_qp, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_b_frame_qp, false);\n\n\tv4l2_ctrl_grab(channel->mpeg_video_frame_rc_enable, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_bitrate_mode, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_bitrate, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_bitrate_peak, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_cpb_size, false);\n\tv4l2_ctrl_grab(channel->mpeg_video_gop_size, false);\n\n\tv4l2_ctrl_grab(channel->encoder_buffer, false);\n\n\tif (channel->user_id != -1) {\n\t\tclear_bit(channel->user_id, &dev->channel_user_ids);\n\t\tchannel->user_id = -1;\n\t}\n}\n\n \nstatic int allegro_create_channel(struct allegro_channel *channel)\n{\n\tstruct allegro_dev *dev = channel->dev;\n\tunsigned long timeout;\n\n\tif (channel_exists(channel)) {\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"channel already exists\\n\");\n\t\treturn 0;\n\t}\n\n\tchannel->user_id = allegro_next_user_id(dev);\n\tif (channel->user_id < 0) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"no free channels available\\n\");\n\t\treturn -EBUSY;\n\t}\n\tset_bit(channel->user_id, &dev->channel_user_ids);\n\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"user %d: creating channel (%4.4s, %dx%d@%d)\\n\",\n\t\t channel->user_id,\n\t\t (char *)&channel->codec, channel->width, channel->height,\n\t\t DIV_ROUND_UP(channel->framerate.numerator,\n\t\t\t      channel->framerate.denominator));\n\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_profile, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_level, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_i_frame_qp, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_max_qp, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_min_qp, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_p_frame_qp, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_h264_b_frame_qp, true);\n\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_profile, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_level, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_tier, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_i_frame_qp, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_max_qp, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_min_qp, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_p_frame_qp, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_hevc_b_frame_qp, true);\n\n\tv4l2_ctrl_grab(channel->mpeg_video_frame_rc_enable, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_bitrate_mode, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_bitrate, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_bitrate_peak, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_cpb_size, true);\n\tv4l2_ctrl_grab(channel->mpeg_video_gop_size, true);\n\n\tv4l2_ctrl_grab(channel->encoder_buffer, true);\n\n\treinit_completion(&channel->completion);\n\tallegro_mcu_send_create_channel(dev, channel);\n\ttimeout = wait_for_completion_timeout(&channel->completion,\n\t\t\t\t\t      msecs_to_jiffies(5000));\n\tif (timeout == 0)\n\t\tchannel->error = -ETIMEDOUT;\n\tif (channel->error)\n\t\tgoto err;\n\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"channel %d: accepting buffers\\n\",\n\t\t channel->mcu_channel_id);\n\n\treturn 0;\n\nerr:\n\tallegro_destroy_channel(channel);\n\n\treturn channel->error;\n}\n\n \nstatic void allegro_channel_adjust(struct allegro_channel *channel)\n{\n\tstruct allegro_dev *dev = channel->dev;\n\tu32 codec = channel->codec;\n\tstruct v4l2_ctrl *ctrl;\n\ts64 min;\n\ts64 max;\n\n\tchannel->sizeimage_encoded =\n\t\testimate_stream_size(channel->width, channel->height);\n\n\tif (codec == V4L2_PIX_FMT_H264) {\n\t\tctrl = channel->mpeg_video_h264_level;\n\t\tmin = select_minimum_h264_level(channel->width, channel->height);\n\t} else {\n\t\tctrl = channel->mpeg_video_hevc_level;\n\t\tmin = select_minimum_hevc_level(channel->width, channel->height);\n\t}\n\tif (ctrl->minimum > min)\n\t\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t\t \"%s.minimum: %lld -> %lld\\n\",\n\t\t\t v4l2_ctrl_get_name(ctrl->id), ctrl->minimum, min);\n\tv4l2_ctrl_lock(ctrl);\n\t__v4l2_ctrl_modify_range(ctrl, min, ctrl->maximum,\n\t\t\t\t ctrl->step, ctrl->default_value);\n\tv4l2_ctrl_unlock(ctrl);\n\n\tctrl = channel->mpeg_video_bitrate;\n\tif (codec == V4L2_PIX_FMT_H264)\n\t\tmax = h264_maximum_bitrate(v4l2_ctrl_g_ctrl(channel->mpeg_video_h264_level));\n\telse\n\t\tmax = hevc_maximum_bitrate(v4l2_ctrl_g_ctrl(channel->mpeg_video_hevc_level));\n\tif (ctrl->maximum < max)\n\t\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t\t \"%s: maximum: %lld -> %lld\\n\",\n\t\t\t v4l2_ctrl_get_name(ctrl->id), ctrl->maximum, max);\n\tv4l2_ctrl_lock(ctrl);\n\t__v4l2_ctrl_modify_range(ctrl, ctrl->minimum, max,\n\t\t\t\t ctrl->step, ctrl->default_value);\n\tv4l2_ctrl_unlock(ctrl);\n\n\tctrl = channel->mpeg_video_bitrate_peak;\n\tv4l2_ctrl_lock(ctrl);\n\t__v4l2_ctrl_modify_range(ctrl, ctrl->minimum, max,\n\t\t\t\t ctrl->step, ctrl->default_value);\n\tv4l2_ctrl_unlock(ctrl);\n\n\tv4l2_ctrl_activate(channel->mpeg_video_h264_profile,\n\t\t\t   codec == V4L2_PIX_FMT_H264);\n\tv4l2_ctrl_activate(channel->mpeg_video_h264_level,\n\t\t\t   codec == V4L2_PIX_FMT_H264);\n\tv4l2_ctrl_activate(channel->mpeg_video_h264_i_frame_qp,\n\t\t\t   codec == V4L2_PIX_FMT_H264);\n\tv4l2_ctrl_activate(channel->mpeg_video_h264_max_qp,\n\t\t\t   codec == V4L2_PIX_FMT_H264);\n\tv4l2_ctrl_activate(channel->mpeg_video_h264_min_qp,\n\t\t\t   codec == V4L2_PIX_FMT_H264);\n\tv4l2_ctrl_activate(channel->mpeg_video_h264_p_frame_qp,\n\t\t\t   codec == V4L2_PIX_FMT_H264);\n\tv4l2_ctrl_activate(channel->mpeg_video_h264_b_frame_qp,\n\t\t\t   codec == V4L2_PIX_FMT_H264);\n\n\tv4l2_ctrl_activate(channel->mpeg_video_hevc_profile,\n\t\t\t   codec == V4L2_PIX_FMT_HEVC);\n\tv4l2_ctrl_activate(channel->mpeg_video_hevc_level,\n\t\t\t   codec == V4L2_PIX_FMT_HEVC);\n\tv4l2_ctrl_activate(channel->mpeg_video_hevc_tier,\n\t\t\t   codec == V4L2_PIX_FMT_HEVC);\n\tv4l2_ctrl_activate(channel->mpeg_video_hevc_i_frame_qp,\n\t\t\t   codec == V4L2_PIX_FMT_HEVC);\n\tv4l2_ctrl_activate(channel->mpeg_video_hevc_max_qp,\n\t\t\t   codec == V4L2_PIX_FMT_HEVC);\n\tv4l2_ctrl_activate(channel->mpeg_video_hevc_min_qp,\n\t\t\t   codec == V4L2_PIX_FMT_HEVC);\n\tv4l2_ctrl_activate(channel->mpeg_video_hevc_p_frame_qp,\n\t\t\t   codec == V4L2_PIX_FMT_HEVC);\n\tv4l2_ctrl_activate(channel->mpeg_video_hevc_b_frame_qp,\n\t\t\t   codec == V4L2_PIX_FMT_HEVC);\n\n\tif (codec == V4L2_PIX_FMT_H264)\n\t\tchannel->log2_max_frame_num = LOG2_MAX_FRAME_NUM;\n\tchannel->temporal_mvp_enable = true;\n\tchannel->dbf_ovr_en = (codec == V4L2_PIX_FMT_H264);\n\tchannel->enable_deblocking_filter_override = (codec == V4L2_PIX_FMT_HEVC);\n\tchannel->enable_reordering = (codec == V4L2_PIX_FMT_HEVC);\n\tchannel->enable_loop_filter_across_tiles = true;\n\tchannel->enable_loop_filter_across_slices = true;\n\n\tif (codec == V4L2_PIX_FMT_H264) {\n\t\tchannel->b_hrz_me_range = 8;\n\t\tchannel->b_vrt_me_range = 8;\n\t\tchannel->p_hrz_me_range = 16;\n\t\tchannel->p_vrt_me_range = 16;\n\t\tchannel->max_cu_size = ilog2(16);\n\t\tchannel->min_cu_size = ilog2(8);\n\t\tchannel->max_tu_size = ilog2(4);\n\t\tchannel->min_tu_size = ilog2(4);\n\t} else {\n\t\tchannel->b_hrz_me_range = 16;\n\t\tchannel->b_vrt_me_range = 16;\n\t\tchannel->p_hrz_me_range = 32;\n\t\tchannel->p_vrt_me_range = 32;\n\t\tchannel->max_cu_size = ilog2(32);\n\t\tchannel->min_cu_size = ilog2(8);\n\t\tchannel->max_tu_size = ilog2(32);\n\t\tchannel->min_tu_size = ilog2(4);\n\t}\n\tchannel->max_transfo_depth_intra = 1;\n\tchannel->max_transfo_depth_inter = 1;\n}\n\nstatic void allegro_set_default_params(struct allegro_channel *channel)\n{\n\tchannel->width = ALLEGRO_WIDTH_DEFAULT;\n\tchannel->height = ALLEGRO_HEIGHT_DEFAULT;\n\tchannel->stride = round_up(channel->width, 32);\n\tchannel->framerate = ALLEGRO_FRAMERATE_DEFAULT;\n\n\tchannel->colorspace = V4L2_COLORSPACE_REC709;\n\tchannel->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\n\tchannel->quantization = V4L2_QUANTIZATION_DEFAULT;\n\tchannel->xfer_func = V4L2_XFER_FUNC_DEFAULT;\n\n\tchannel->pixelformat = V4L2_PIX_FMT_NV12;\n\tchannel->sizeimage_raw = channel->stride * channel->height * 3 / 2;\n\n\tchannel->codec = V4L2_PIX_FMT_H264;\n}\n\nstatic int allegro_queue_setup(struct vb2_queue *vq,\n\t\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t       unsigned int sizes[],\n\t\t\t       struct device *alloc_devs[])\n{\n\tstruct allegro_channel *channel = vb2_get_drv_priv(vq);\n\tstruct allegro_dev *dev = channel->dev;\n\n\tv4l2_dbg(2, debug, &dev->v4l2_dev,\n\t\t \"%s: queue setup[%s]: nplanes = %d\\n\",\n\t\t V4L2_TYPE_IS_OUTPUT(vq->type) ? \"output\" : \"capture\",\n\t\t *nplanes == 0 ? \"REQBUFS\" : \"CREATE_BUFS\", *nplanes);\n\n\tif (*nplanes != 0) {\n\t\tif (V4L2_TYPE_IS_OUTPUT(vq->type)) {\n\t\t\tif (sizes[0] < channel->sizeimage_raw)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (sizes[0] < channel->sizeimage_encoded)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t*nplanes = 1;\n\t\tif (V4L2_TYPE_IS_OUTPUT(vq->type))\n\t\t\tsizes[0] = channel->sizeimage_raw;\n\t\telse\n\t\t\tsizes[0] = channel->sizeimage_encoded;\n\t}\n\n\treturn 0;\n}\n\nstatic int allegro_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct allegro_channel *channel = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct allegro_dev *dev = channel->dev;\n\n\tif (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\n\t\tif (vbuf->field == V4L2_FIELD_ANY)\n\t\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tif (vbuf->field != V4L2_FIELD_NONE) {\n\t\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t\t \"channel %d: unsupported field\\n\",\n\t\t\t\t channel->mcu_channel_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void allegro_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct allegro_channel *channel = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *q = vb->vb2_queue;\n\n\tif (V4L2_TYPE_IS_CAPTURE(q->type) &&\n\t    vb2_is_streaming(q) &&\n\t    v4l2_m2m_dst_buf_is_last(channel->fh.m2m_ctx)) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < vb->num_planes; i++)\n\t\t\tvb2_set_plane_payload(vb, i, 0);\n\n\t\tvbuf->field = V4L2_FIELD_NONE;\n\t\tvbuf->sequence = channel->csequence++;\n\n\t\tv4l2_m2m_last_buffer_done(channel->fh.m2m_ctx, vbuf);\n\t\tallegro_channel_eos_event(channel);\n\t\treturn;\n\t}\n\n\tv4l2_m2m_buf_queue(channel->fh.m2m_ctx, vbuf);\n}\n\nstatic int allegro_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct allegro_channel *channel = vb2_get_drv_priv(q);\n\tstruct allegro_dev *dev = channel->dev;\n\n\tv4l2_dbg(2, debug, &dev->v4l2_dev,\n\t\t \"%s: start streaming\\n\",\n\t\t V4L2_TYPE_IS_OUTPUT(q->type) ? \"output\" : \"capture\");\n\n\tv4l2_m2m_update_start_streaming_state(channel->fh.m2m_ctx, q);\n\n\tif (V4L2_TYPE_IS_OUTPUT(q->type))\n\t\tchannel->osequence = 0;\n\telse\n\t\tchannel->csequence = 0;\n\n\treturn 0;\n}\n\nstatic void allegro_stop_streaming(struct vb2_queue *q)\n{\n\tstruct allegro_channel *channel = vb2_get_drv_priv(q);\n\tstruct allegro_dev *dev = channel->dev;\n\tstruct vb2_v4l2_buffer *buffer;\n\tstruct allegro_m2m_buffer *shadow, *tmp;\n\n\tv4l2_dbg(2, debug, &dev->v4l2_dev,\n\t\t \"%s: stop streaming\\n\",\n\t\t V4L2_TYPE_IS_OUTPUT(q->type) ? \"output\" : \"capture\");\n\n\tif (V4L2_TYPE_IS_OUTPUT(q->type)) {\n\t\tmutex_lock(&channel->shadow_list_lock);\n\t\tlist_for_each_entry_safe(shadow, tmp,\n\t\t\t\t\t &channel->source_shadow_list, head) {\n\t\t\tlist_del(&shadow->head);\n\t\t\tv4l2_m2m_buf_done(&shadow->buf.vb, VB2_BUF_STATE_ERROR);\n\t\t}\n\t\tmutex_unlock(&channel->shadow_list_lock);\n\n\t\twhile ((buffer = v4l2_m2m_src_buf_remove(channel->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buffer, VB2_BUF_STATE_ERROR);\n\t} else {\n\t\tmutex_lock(&channel->shadow_list_lock);\n\t\tlist_for_each_entry_safe(shadow, tmp,\n\t\t\t\t\t &channel->stream_shadow_list, head) {\n\t\t\tlist_del(&shadow->head);\n\t\t\tv4l2_m2m_buf_done(&shadow->buf.vb, VB2_BUF_STATE_ERROR);\n\t\t}\n\t\tmutex_unlock(&channel->shadow_list_lock);\n\n\t\tallegro_destroy_channel(channel);\n\t\twhile ((buffer = v4l2_m2m_dst_buf_remove(channel->fh.m2m_ctx)))\n\t\t\tv4l2_m2m_buf_done(buffer, VB2_BUF_STATE_ERROR);\n\t}\n\n\tv4l2_m2m_update_stop_streaming_state(channel->fh.m2m_ctx, q);\n\n\tif (V4L2_TYPE_IS_OUTPUT(q->type) &&\n\t    v4l2_m2m_has_stopped(channel->fh.m2m_ctx))\n\t\tallegro_channel_eos_event(channel);\n}\n\nstatic const struct vb2_ops allegro_queue_ops = {\n\t.queue_setup = allegro_queue_setup,\n\t.buf_prepare = allegro_buf_prepare,\n\t.buf_queue = allegro_buf_queue,\n\t.start_streaming = allegro_start_streaming,\n\t.stop_streaming = allegro_stop_streaming,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\nstatic int allegro_queue_init(void *priv,\n\t\t\t      struct vb2_queue *src_vq,\n\t\t\t      struct vb2_queue *dst_vq)\n{\n\tint err;\n\tstruct allegro_channel *channel = priv;\n\n\tsrc_vq->dev = &channel->dev->plat_dev->dev;\n\tsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\tsrc_vq->io_modes = VB2_DMABUF | VB2_MMAP;\n\tsrc_vq->mem_ops = &vb2_dma_contig_memops;\n\tsrc_vq->drv_priv = channel;\n\tsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tsrc_vq->ops = &allegro_queue_ops;\n\tsrc_vq->buf_struct_size = sizeof(struct allegro_m2m_buffer);\n\tsrc_vq->lock = &channel->dev->lock;\n\terr = vb2_queue_init(src_vq);\n\tif (err)\n\t\treturn err;\n\n\tdst_vq->dev = &channel->dev->plat_dev->dev;\n\tdst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tdst_vq->io_modes = VB2_DMABUF | VB2_MMAP;\n\tdst_vq->mem_ops = &vb2_dma_contig_memops;\n\tdst_vq->drv_priv = channel;\n\tdst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\tdst_vq->ops = &allegro_queue_ops;\n\tdst_vq->buf_struct_size = sizeof(struct allegro_m2m_buffer);\n\tdst_vq->lock = &channel->dev->lock;\n\terr = vb2_queue_init(dst_vq);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int allegro_clamp_qp(struct allegro_channel *channel,\n\t\t\t    struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_ctrl *next_ctrl;\n\n\tif (ctrl->id == V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP)\n\t\tnext_ctrl = channel->mpeg_video_h264_p_frame_qp;\n\telse if (ctrl->id == V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP)\n\t\tnext_ctrl = channel->mpeg_video_h264_b_frame_qp;\n\telse\n\t\treturn 0;\n\n\t \n\t__v4l2_ctrl_modify_range(next_ctrl, ctrl->val, 51, 1, ctrl->val);\n\n\treturn allegro_clamp_qp(channel, next_ctrl);\n}\n\nstatic int allegro_clamp_bitrate(struct allegro_channel *channel,\n\t\t\t\t struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_ctrl *ctrl_bitrate = channel->mpeg_video_bitrate;\n\tstruct v4l2_ctrl *ctrl_bitrate_peak = channel->mpeg_video_bitrate_peak;\n\n\tif (ctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR &&\n\t    ctrl_bitrate_peak->val < ctrl_bitrate->val)\n\t\tctrl_bitrate_peak->val = ctrl_bitrate->val;\n\n\treturn 0;\n}\n\nstatic int allegro_try_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct allegro_channel *channel = container_of(ctrl->handler,\n\t\t\t\t\t\t       struct allegro_channel,\n\t\t\t\t\t\t       ctrl_handler);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\n\t\tallegro_clamp_bitrate(channel, ctrl);\n\t\tbreak;\n\tcase V4L2_CID_USER_ALLEGRO_ENCODER_BUFFER:\n\t\tif (!channel->dev->has_encoder_buffer)\n\t\t\tctrl->val = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int allegro_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct allegro_channel *channel = container_of(ctrl->handler,\n\t\t\t\t\t\t       struct allegro_channel,\n\t\t\t\t\t\t       ctrl_handler);\n\tstruct allegro_dev *dev = channel->dev;\n\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"s_ctrl: %s = %d\\n\", v4l2_ctrl_get_name(ctrl->id), ctrl->val);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:\n\t\tchannel->frame_rc_enable = ctrl->val;\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\n\t\tchannel->bitrate = channel->mpeg_video_bitrate->val;\n\t\tchannel->bitrate_peak = channel->mpeg_video_bitrate_peak->val;\n\t\tv4l2_ctrl_activate(channel->mpeg_video_bitrate_peak,\n\t\t\t\t   ctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR);\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP:\n\tcase V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP:\n\tcase V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP:\n\t\tallegro_clamp_qp(channel, ctrl);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops allegro_ctrl_ops = {\n\t.try_ctrl = allegro_try_ctrl,\n\t.s_ctrl = allegro_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config allegro_encoder_buffer_ctrl_config = {\n\t.id = V4L2_CID_USER_ALLEGRO_ENCODER_BUFFER,\n\t.name = \"Encoder Buffer Enable\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.min = 0,\n\t.max = 1,\n\t.step = 1,\n\t.def = 1,\n};\n\nstatic int allegro_open(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct allegro_dev *dev = video_get_drvdata(vdev);\n\tstruct allegro_channel *channel = NULL;\n\tstruct v4l2_ctrl_handler *handler;\n\tu64 mask;\n\tint ret;\n\tunsigned int bitrate_max;\n\tunsigned int bitrate_def;\n\tunsigned int cpb_size_max;\n\tunsigned int cpb_size_def;\n\n\tchannel = kzalloc(sizeof(*channel), GFP_KERNEL);\n\tif (!channel)\n\t\treturn -ENOMEM;\n\n\tv4l2_fh_init(&channel->fh, vdev);\n\n\tinit_completion(&channel->completion);\n\tINIT_LIST_HEAD(&channel->source_shadow_list);\n\tINIT_LIST_HEAD(&channel->stream_shadow_list);\n\tmutex_init(&channel->shadow_list_lock);\n\n\tchannel->dev = dev;\n\n\tallegro_set_default_params(channel);\n\n\thandler = &channel->ctrl_handler;\n\tv4l2_ctrl_handler_init(handler, 0);\n\tchannel->mpeg_video_h264_profile = v4l2_ctrl_new_std_menu(handler,\n\t\t\t&allegro_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_H264_PROFILE,\n\t\t\tV4L2_MPEG_VIDEO_H264_PROFILE_BASELINE, 0x0,\n\t\t\tV4L2_MPEG_VIDEO_H264_PROFILE_BASELINE);\n\tmask = 1 << V4L2_MPEG_VIDEO_H264_LEVEL_1B;\n\tchannel->mpeg_video_h264_level = v4l2_ctrl_new_std_menu(handler,\n\t\t\t&allegro_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_H264_LEVEL,\n\t\t\tV4L2_MPEG_VIDEO_H264_LEVEL_5_1, mask,\n\t\t\tV4L2_MPEG_VIDEO_H264_LEVEL_5_1);\n\tchannel->mpeg_video_h264_i_frame_qp =\n\t\tv4l2_ctrl_new_std(handler,\n\t\t\t\t  &allegro_ctrl_ops,\n\t\t\t\t  V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP,\n\t\t\t\t  0, 51, 1, 30);\n\tchannel->mpeg_video_h264_max_qp =\n\t\tv4l2_ctrl_new_std(handler,\n\t\t\t\t  &allegro_ctrl_ops,\n\t\t\t\t  V4L2_CID_MPEG_VIDEO_H264_MAX_QP,\n\t\t\t\t  0, 51, 1, 51);\n\tchannel->mpeg_video_h264_min_qp =\n\t\tv4l2_ctrl_new_std(handler,\n\t\t\t\t  &allegro_ctrl_ops,\n\t\t\t\t  V4L2_CID_MPEG_VIDEO_H264_MIN_QP,\n\t\t\t\t  0, 51, 1, 0);\n\tchannel->mpeg_video_h264_p_frame_qp =\n\t\tv4l2_ctrl_new_std(handler,\n\t\t\t\t  &allegro_ctrl_ops,\n\t\t\t\t  V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP,\n\t\t\t\t  0, 51, 1, 30);\n\tchannel->mpeg_video_h264_b_frame_qp =\n\t\tv4l2_ctrl_new_std(handler,\n\t\t\t\t  &allegro_ctrl_ops,\n\t\t\t\t  V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP,\n\t\t\t\t  0, 51, 1, 30);\n\n\tchannel->mpeg_video_hevc_profile =\n\t\tv4l2_ctrl_new_std_menu(handler,\n\t\t\t\t       &allegro_ctrl_ops,\n\t\t\t\t       V4L2_CID_MPEG_VIDEO_HEVC_PROFILE,\n\t\t\t\t       V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN, 0x0,\n\t\t\t\t       V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN);\n\tchannel->mpeg_video_hevc_level =\n\t\tv4l2_ctrl_new_std_menu(handler,\n\t\t\t\t       &allegro_ctrl_ops,\n\t\t\t\t       V4L2_CID_MPEG_VIDEO_HEVC_LEVEL,\n\t\t\t\t       V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1, 0x0,\n\t\t\t\t       V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1);\n\tchannel->mpeg_video_hevc_tier =\n\t\tv4l2_ctrl_new_std_menu(handler,\n\t\t\t\t       &allegro_ctrl_ops,\n\t\t\t\t       V4L2_CID_MPEG_VIDEO_HEVC_TIER,\n\t\t\t\t       V4L2_MPEG_VIDEO_HEVC_TIER_HIGH, 0x0,\n\t\t\t\t       V4L2_MPEG_VIDEO_HEVC_TIER_MAIN);\n\tchannel->mpeg_video_hevc_i_frame_qp =\n\t\tv4l2_ctrl_new_std(handler,\n\t\t\t\t  &allegro_ctrl_ops,\n\t\t\t\t  V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP,\n\t\t\t\t  0, 51, 1, 30);\n\tchannel->mpeg_video_hevc_max_qp =\n\t\tv4l2_ctrl_new_std(handler,\n\t\t\t\t  &allegro_ctrl_ops,\n\t\t\t\t  V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP,\n\t\t\t\t  0, 51, 1, 51);\n\tchannel->mpeg_video_hevc_min_qp =\n\t\tv4l2_ctrl_new_std(handler,\n\t\t\t\t  &allegro_ctrl_ops,\n\t\t\t\t  V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP,\n\t\t\t\t  0, 51, 1, 0);\n\tchannel->mpeg_video_hevc_p_frame_qp =\n\t\tv4l2_ctrl_new_std(handler,\n\t\t\t\t  &allegro_ctrl_ops,\n\t\t\t\t  V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP,\n\t\t\t\t  0, 51, 1, 30);\n\tchannel->mpeg_video_hevc_b_frame_qp =\n\t\tv4l2_ctrl_new_std(handler,\n\t\t\t\t  &allegro_ctrl_ops,\n\t\t\t\t  V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP,\n\t\t\t\t  0, 51, 1, 30);\n\n\tchannel->mpeg_video_frame_rc_enable =\n\t\tv4l2_ctrl_new_std(handler,\n\t\t\t\t  &allegro_ctrl_ops,\n\t\t\t\t  V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE,\n\t\t\t\t  false, 0x1,\n\t\t\t\t  true, false);\n\tchannel->mpeg_video_bitrate_mode = v4l2_ctrl_new_std_menu(handler,\n\t\t\t&allegro_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_BITRATE_MODE,\n\t\t\tV4L2_MPEG_VIDEO_BITRATE_MODE_CBR, 0,\n\t\t\tV4L2_MPEG_VIDEO_BITRATE_MODE_CBR);\n\n\tif (channel->codec == V4L2_PIX_FMT_H264) {\n\t\tbitrate_max = h264_maximum_bitrate(V4L2_MPEG_VIDEO_H264_LEVEL_5_1);\n\t\tbitrate_def = h264_maximum_bitrate(V4L2_MPEG_VIDEO_H264_LEVEL_5_1);\n\t\tcpb_size_max = h264_maximum_cpb_size(V4L2_MPEG_VIDEO_H264_LEVEL_5_1);\n\t\tcpb_size_def = h264_maximum_cpb_size(V4L2_MPEG_VIDEO_H264_LEVEL_5_1);\n\t} else {\n\t\tbitrate_max = hevc_maximum_bitrate(V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1);\n\t\tbitrate_def = hevc_maximum_bitrate(V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1);\n\t\tcpb_size_max = hevc_maximum_cpb_size(V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1);\n\t\tcpb_size_def = hevc_maximum_cpb_size(V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1);\n\t}\n\tchannel->mpeg_video_bitrate = v4l2_ctrl_new_std(handler,\n\t\t\t&allegro_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_BITRATE,\n\t\t\t0, bitrate_max, 1, bitrate_def);\n\tchannel->mpeg_video_bitrate_peak = v4l2_ctrl_new_std(handler,\n\t\t\t&allegro_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_BITRATE_PEAK,\n\t\t\t0, bitrate_max, 1, bitrate_def);\n\tchannel->mpeg_video_cpb_size = v4l2_ctrl_new_std(handler,\n\t\t\t&allegro_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_H264_CPB_SIZE,\n\t\t\t0, cpb_size_max, 1, cpb_size_def);\n\tchannel->mpeg_video_gop_size = v4l2_ctrl_new_std(handler,\n\t\t\t&allegro_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_GOP_SIZE,\n\t\t\t0, ALLEGRO_GOP_SIZE_MAX,\n\t\t\t1, ALLEGRO_GOP_SIZE_DEFAULT);\n\tchannel->encoder_buffer = v4l2_ctrl_new_custom(handler,\n\t\t\t&allegro_encoder_buffer_ctrl_config, NULL);\n\tv4l2_ctrl_new_std(handler,\n\t\t\t  &allegro_ctrl_ops,\n\t\t\t  V4L2_CID_MIN_BUFFERS_FOR_OUTPUT,\n\t\t\t  1, 32,\n\t\t\t  1, 1);\n\tif (handler->error != 0) {\n\t\tret = handler->error;\n\t\tgoto error;\n\t}\n\n\tchannel->fh.ctrl_handler = handler;\n\n\tv4l2_ctrl_cluster(3, &channel->mpeg_video_bitrate_mode);\n\n\tv4l2_ctrl_handler_setup(handler);\n\n\tchannel->mcu_channel_id = -1;\n\tchannel->user_id = -1;\n\n\tINIT_LIST_HEAD(&channel->buffers_reference);\n\tINIT_LIST_HEAD(&channel->buffers_intermediate);\n\n\tchannel->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, channel,\n\t\t\t\t\t\tallegro_queue_init);\n\n\tif (IS_ERR(channel->fh.m2m_ctx)) {\n\t\tret = PTR_ERR(channel->fh.m2m_ctx);\n\t\tgoto error;\n\t}\n\n\tlist_add(&channel->list, &dev->channels);\n\tfile->private_data = &channel->fh;\n\tv4l2_fh_add(&channel->fh);\n\n\tallegro_channel_adjust(channel);\n\n\treturn 0;\n\nerror:\n\tv4l2_ctrl_handler_free(handler);\n\tkfree(channel);\n\treturn ret;\n}\n\nstatic int allegro_release(struct file *file)\n{\n\tstruct allegro_channel *channel = fh_to_channel(file->private_data);\n\n\tv4l2_m2m_ctx_release(channel->fh.m2m_ctx);\n\n\tlist_del(&channel->list);\n\n\tv4l2_ctrl_handler_free(&channel->ctrl_handler);\n\n\tv4l2_fh_del(&channel->fh);\n\tv4l2_fh_exit(&channel->fh);\n\n\tkfree(channel);\n\n\treturn 0;\n}\n\nstatic int allegro_querycap(struct file *file, void *fh,\n\t\t\t    struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrscpy(cap->card, \"Allegro DVT Video Encoder\", sizeof(cap->card));\n\n\treturn 0;\n}\n\nstatic int allegro_enum_fmt_vid(struct file *file, void *fh,\n\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tswitch (f->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (f->index >= 1)\n\t\t\treturn -EINVAL;\n\t\tf->pixelformat = V4L2_PIX_FMT_NV12;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (f->index >= 2)\n\t\t\treturn -EINVAL;\n\t\tif (f->index == 0)\n\t\t\tf->pixelformat = V4L2_PIX_FMT_H264;\n\t\tif (f->index == 1)\n\t\t\tf->pixelformat = V4L2_PIX_FMT_HEVC;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int allegro_g_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct allegro_channel *channel = fh_to_channel(fh);\n\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\tf->fmt.pix.width = channel->width;\n\tf->fmt.pix.height = channel->height;\n\n\tf->fmt.pix.colorspace = channel->colorspace;\n\tf->fmt.pix.ycbcr_enc = channel->ycbcr_enc;\n\tf->fmt.pix.quantization = channel->quantization;\n\tf->fmt.pix.xfer_func = channel->xfer_func;\n\n\tf->fmt.pix.pixelformat = channel->codec;\n\tf->fmt.pix.bytesperline = 0;\n\tf->fmt.pix.sizeimage = channel->sizeimage_encoded;\n\n\treturn 0;\n}\n\nstatic int allegro_try_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\n\tf->fmt.pix.width = clamp_t(__u32, f->fmt.pix.width,\n\t\t\t\t   ALLEGRO_WIDTH_MIN, ALLEGRO_WIDTH_MAX);\n\tf->fmt.pix.height = clamp_t(__u32, f->fmt.pix.height,\n\t\t\t\t    ALLEGRO_HEIGHT_MIN, ALLEGRO_HEIGHT_MAX);\n\n\tif (f->fmt.pix.pixelformat != V4L2_PIX_FMT_HEVC &&\n\t    f->fmt.pix.pixelformat != V4L2_PIX_FMT_H264)\n\t\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_H264;\n\n\tf->fmt.pix.bytesperline = 0;\n\tf->fmt.pix.sizeimage =\n\t\testimate_stream_size(f->fmt.pix.width, f->fmt.pix.height);\n\n\treturn 0;\n}\n\nstatic int allegro_s_fmt_vid_cap(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct allegro_channel *channel = fh_to_channel(fh);\n\tstruct vb2_queue *vq;\n\tint err;\n\n\terr = allegro_try_fmt_vid_cap(file, fh, f);\n\tif (err)\n\t\treturn err;\n\n\tvq = v4l2_m2m_get_vq(channel->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\tif (vb2_is_busy(vq))\n\t\treturn -EBUSY;\n\n\tchannel->codec = f->fmt.pix.pixelformat;\n\n\tallegro_channel_adjust(channel);\n\n\treturn 0;\n}\n\nstatic int allegro_g_fmt_vid_out(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct allegro_channel *channel = fh_to_channel(fh);\n\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\n\tf->fmt.pix.width = channel->width;\n\tf->fmt.pix.height = channel->height;\n\n\tf->fmt.pix.colorspace = channel->colorspace;\n\tf->fmt.pix.ycbcr_enc = channel->ycbcr_enc;\n\tf->fmt.pix.quantization = channel->quantization;\n\tf->fmt.pix.xfer_func = channel->xfer_func;\n\n\tf->fmt.pix.pixelformat = channel->pixelformat;\n\tf->fmt.pix.bytesperline = channel->stride;\n\tf->fmt.pix.sizeimage = channel->sizeimage_raw;\n\n\treturn 0;\n}\n\nstatic int allegro_try_fmt_vid_out(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_format *f)\n{\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\n\t \n\tf->fmt.pix.width = clamp_t(__u32, f->fmt.pix.width,\n\t\t\t\t   ALLEGRO_WIDTH_MIN, ALLEGRO_WIDTH_MAX);\n\tf->fmt.pix.height = clamp_t(__u32, f->fmt.pix.height,\n\t\t\t\t    ALLEGRO_HEIGHT_MIN, ALLEGRO_HEIGHT_MAX);\n\n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_NV12;\n\tf->fmt.pix.bytesperline = round_up(f->fmt.pix.width, 32);\n\tf->fmt.pix.sizeimage =\n\t\tf->fmt.pix.bytesperline * f->fmt.pix.height * 3 / 2;\n\n\treturn 0;\n}\n\nstatic int allegro_s_fmt_vid_out(struct file *file, void *fh,\n\t\t\t\t struct v4l2_format *f)\n{\n\tstruct allegro_channel *channel = fh_to_channel(fh);\n\tint err;\n\n\terr = allegro_try_fmt_vid_out(file, fh, f);\n\tif (err)\n\t\treturn err;\n\n\tchannel->width = f->fmt.pix.width;\n\tchannel->height = f->fmt.pix.height;\n\tchannel->stride = f->fmt.pix.bytesperline;\n\tchannel->sizeimage_raw = f->fmt.pix.sizeimage;\n\n\tchannel->colorspace = f->fmt.pix.colorspace;\n\tchannel->ycbcr_enc = f->fmt.pix.ycbcr_enc;\n\tchannel->quantization = f->fmt.pix.quantization;\n\tchannel->xfer_func = f->fmt.pix.xfer_func;\n\n\tallegro_channel_adjust(channel);\n\n\treturn 0;\n}\n\nstatic int allegro_channel_cmd_stop(struct allegro_channel *channel)\n{\n\tif (v4l2_m2m_has_stopped(channel->fh.m2m_ctx))\n\t\tallegro_channel_eos_event(channel);\n\n\treturn 0;\n}\n\nstatic int allegro_channel_cmd_start(struct allegro_channel *channel)\n{\n\tif (v4l2_m2m_has_stopped(channel->fh.m2m_ctx))\n\t\tvb2_clear_last_buffer_dequeued(&channel->fh.m2m_ctx->cap_q_ctx.q);\n\n\treturn 0;\n}\n\nstatic int allegro_encoder_cmd(struct file *file, void *fh,\n\t\t\t       struct v4l2_encoder_cmd *cmd)\n{\n\tstruct allegro_channel *channel = fh_to_channel(fh);\n\tint err;\n\n\terr = v4l2_m2m_ioctl_try_encoder_cmd(file, fh, cmd);\n\tif (err)\n\t\treturn err;\n\n\terr = v4l2_m2m_ioctl_encoder_cmd(file, fh, cmd);\n\tif (err)\n\t\treturn err;\n\n\tif (cmd->cmd == V4L2_ENC_CMD_STOP)\n\t\terr = allegro_channel_cmd_stop(channel);\n\n\tif (cmd->cmd == V4L2_ENC_CMD_START)\n\t\terr = allegro_channel_cmd_start(channel);\n\n\treturn err;\n}\n\nstatic int allegro_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_frmsizeenum *fsize)\n{\n\tswitch (fsize->pixel_format) {\n\tcase V4L2_PIX_FMT_HEVC:\n\tcase V4L2_PIX_FMT_H264:\n\tcase V4L2_PIX_FMT_NV12:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (fsize->index)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\tfsize->stepwise.min_width = ALLEGRO_WIDTH_MIN;\n\tfsize->stepwise.max_width = ALLEGRO_WIDTH_MAX;\n\tfsize->stepwise.step_width = 1;\n\tfsize->stepwise.min_height = ALLEGRO_HEIGHT_MIN;\n\tfsize->stepwise.max_height = ALLEGRO_HEIGHT_MAX;\n\tfsize->stepwise.step_height = 1;\n\n\treturn 0;\n}\n\nstatic int allegro_ioctl_streamon(struct file *file, void *priv,\n\t\t\t\t  enum v4l2_buf_type type)\n{\n\tstruct v4l2_fh *fh = file->private_data;\n\tstruct allegro_channel *channel = fh_to_channel(fh);\n\tint err;\n\n\tif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\n\t\terr = allegro_create_channel(channel);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn v4l2_m2m_streamon(file, fh->m2m_ctx, type);\n}\n\nstatic int allegro_g_parm(struct file *file, void *fh,\n\t\t\t  struct v4l2_streamparm *a)\n{\n\tstruct allegro_channel *channel = fh_to_channel(fh);\n\tstruct v4l2_fract *timeperframe;\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\ta->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\n\ttimeperframe = &a->parm.output.timeperframe;\n\ttimeperframe->numerator = channel->framerate.denominator;\n\ttimeperframe->denominator = channel->framerate.numerator;\n\n\treturn 0;\n}\n\nstatic int allegro_s_parm(struct file *file, void *fh,\n\t\t\t  struct v4l2_streamparm *a)\n{\n\tstruct allegro_channel *channel = fh_to_channel(fh);\n\tstruct v4l2_fract *timeperframe;\n\tint div;\n\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\treturn -EINVAL;\n\n\ta->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\n\ttimeperframe = &a->parm.output.timeperframe;\n\n\tif (timeperframe->numerator == 0 || timeperframe->denominator == 0)\n\t\treturn allegro_g_parm(file, fh, a);\n\n\tdiv = gcd(timeperframe->denominator, timeperframe->numerator);\n\tchannel->framerate.numerator = timeperframe->denominator / div;\n\tchannel->framerate.denominator = timeperframe->numerator / div;\n\n\treturn 0;\n}\n\nstatic int allegro_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t   const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_EOS:\n\t\treturn v4l2_event_subscribe(fh, sub, 0, NULL);\n\tdefault:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\t}\n}\n\nstatic const struct v4l2_ioctl_ops allegro_ioctl_ops = {\n\t.vidioc_querycap = allegro_querycap,\n\t.vidioc_enum_fmt_vid_cap = allegro_enum_fmt_vid,\n\t.vidioc_enum_fmt_vid_out = allegro_enum_fmt_vid,\n\t.vidioc_g_fmt_vid_cap = allegro_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap = allegro_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap = allegro_s_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_out = allegro_g_fmt_vid_out,\n\t.vidioc_try_fmt_vid_out = allegro_try_fmt_vid_out,\n\t.vidioc_s_fmt_vid_out = allegro_s_fmt_vid_out,\n\n\t.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,\n\t.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,\n\n\t.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,\n\t.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,\n\t.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,\n\t.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,\n\t.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,\n\n\t.vidioc_streamon = allegro_ioctl_streamon,\n\t.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,\n\n\t.vidioc_try_encoder_cmd = v4l2_m2m_ioctl_try_encoder_cmd,\n\t.vidioc_encoder_cmd = allegro_encoder_cmd,\n\t.vidioc_enum_framesizes = allegro_enum_framesizes,\n\n\t.vidioc_g_parm\t\t= allegro_g_parm,\n\t.vidioc_s_parm\t\t= allegro_s_parm,\n\n\t.vidioc_subscribe_event = allegro_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\nstatic const struct v4l2_file_operations allegro_fops = {\n\t.owner = THIS_MODULE,\n\t.open = allegro_open,\n\t.release = allegro_release,\n\t.poll = v4l2_m2m_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap = v4l2_m2m_fop_mmap,\n};\n\nstatic int allegro_register_device(struct allegro_dev *dev)\n{\n\tstruct video_device *video_dev = &dev->video_dev;\n\n\tstrscpy(video_dev->name, \"allegro\", sizeof(video_dev->name));\n\tvideo_dev->fops = &allegro_fops;\n\tvideo_dev->ioctl_ops = &allegro_ioctl_ops;\n\tvideo_dev->release = video_device_release_empty;\n\tvideo_dev->lock = &dev->lock;\n\tvideo_dev->v4l2_dev = &dev->v4l2_dev;\n\tvideo_dev->vfl_dir = VFL_DIR_M2M;\n\tvideo_dev->device_caps = V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING;\n\tvideo_set_drvdata(video_dev, dev);\n\n\treturn video_register_device(video_dev, VFL_TYPE_VIDEO, 0);\n}\n\nstatic void allegro_device_run(void *priv)\n{\n\tstruct allegro_channel *channel = priv;\n\tstruct allegro_dev *dev = channel->dev;\n\tstruct vb2_v4l2_buffer *src_buf;\n\tstruct vb2_v4l2_buffer *dst_buf;\n\tdma_addr_t src_y;\n\tdma_addr_t src_uv;\n\tdma_addr_t dst_addr;\n\tunsigned long dst_size;\n\tu64 src_handle;\n\tu64 dst_handle;\n\n\tdst_buf = v4l2_m2m_dst_buf_remove(channel->fh.m2m_ctx);\n\tdst_addr = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\n\tdst_size = vb2_plane_size(&dst_buf->vb2_buf, 0);\n\tdst_handle = allegro_put_buffer(channel, &channel->stream_shadow_list,\n\t\t\t\t\tdst_buf);\n\tallegro_mcu_send_put_stream_buffer(dev, channel, dst_addr, dst_size,\n\t\t\t\t\t   dst_handle);\n\n\tsrc_buf = v4l2_m2m_src_buf_remove(channel->fh.m2m_ctx);\n\tsrc_buf->sequence = channel->osequence++;\n\tsrc_y = vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\n\tsrc_uv = src_y + (channel->stride * channel->height);\n\tsrc_handle = allegro_put_buffer(channel, &channel->source_shadow_list,\n\t\t\t\t\tsrc_buf);\n\tallegro_mcu_send_encode_frame(dev, channel, src_y, src_uv, src_handle);\n\n\tv4l2_m2m_job_finish(dev->m2m_dev, channel->fh.m2m_ctx);\n}\n\nstatic const struct v4l2_m2m_ops allegro_m2m_ops = {\n\t.device_run = allegro_device_run,\n};\n\nstatic int allegro_mcu_hw_init(struct allegro_dev *dev,\n\t\t\t       const struct fw_info *info)\n{\n\tint err;\n\n\tdev->mbox_command = allegro_mbox_init(dev, info->mailbox_cmd,\n\t\t\t\t\t      info->mailbox_size);\n\tdev->mbox_status = allegro_mbox_init(dev, info->mailbox_status,\n\t\t\t\t\t     info->mailbox_size);\n\tif (IS_ERR(dev->mbox_command) || IS_ERR(dev->mbox_status)) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"failed to initialize mailboxes\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = allegro_encoder_buffer_init(dev, &dev->encoder_buffer);\n\tdev->has_encoder_buffer = (err == 0);\n\tif (!dev->has_encoder_buffer)\n\t\tv4l2_info(&dev->v4l2_dev, \"encoder buffer not available\\n\");\n\n\tallegro_mcu_enable_interrupts(dev);\n\n\t \n\tallegro_mcu_start(dev);\n\terr = allegro_mcu_wait_for_init_timeout(dev, 5000);\n\tif (err < 0) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"mcu did not send INIT after reset\\n\");\n\t\terr = -EIO;\n\t\tgoto err_disable_interrupts;\n\t}\n\n\terr = allegro_alloc_buffer(dev, &dev->suballocator,\n\t\t\t\t   info->suballocator_size);\n\tif (err) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"failed to allocate %zu bytes for suballocator\\n\",\n\t\t\t info->suballocator_size);\n\t\tgoto err_reset_mcu;\n\t}\n\n\tallegro_mcu_send_init(dev, dev->suballocator.paddr,\n\t\t\t      dev->suballocator.size);\n\terr = allegro_mcu_wait_for_init_timeout(dev, 5000);\n\tif (err < 0) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"mcu failed to configure sub-allocator\\n\");\n\t\terr = -EIO;\n\t\tgoto err_free_suballocator;\n\t}\n\n\treturn 0;\n\nerr_free_suballocator:\n\tallegro_free_buffer(dev, &dev->suballocator);\nerr_reset_mcu:\n\tallegro_mcu_reset(dev);\nerr_disable_interrupts:\n\tallegro_mcu_disable_interrupts(dev);\n\n\treturn err;\n}\n\nstatic int allegro_mcu_hw_deinit(struct allegro_dev *dev)\n{\n\tint err;\n\n\terr = allegro_mcu_reset(dev);\n\tif (err)\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"mcu failed to enter sleep state\\n\");\n\n\terr = allegro_mcu_disable_interrupts(dev);\n\tif (err)\n\t\tv4l2_warn(&dev->v4l2_dev,\n\t\t\t  \"failed to disable interrupts\\n\");\n\n\tallegro_free_buffer(dev, &dev->suballocator);\n\n\treturn 0;\n}\n\nstatic void allegro_fw_callback(const struct firmware *fw, void *context)\n{\n\tstruct allegro_dev *dev = context;\n\tconst char *fw_codec_name = \"al5e.fw\";\n\tconst struct firmware *fw_codec;\n\tint err;\n\n\tif (!fw)\n\t\treturn;\n\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"requesting codec firmware '%s'\\n\", fw_codec_name);\n\terr = request_firmware(&fw_codec, fw_codec_name, &dev->plat_dev->dev);\n\tif (err)\n\t\tgoto err_release_firmware;\n\n\tdev->fw_info = allegro_get_firmware_info(dev, fw, fw_codec);\n\tif (!dev->fw_info) {\n\t\tv4l2_err(&dev->v4l2_dev, \"firmware is not supported\\n\");\n\t\tgoto err_release_firmware_codec;\n\t}\n\n\tv4l2_info(&dev->v4l2_dev,\n\t\t  \"using mcu firmware version '%s'\\n\", dev->fw_info->version);\n\n\tpm_runtime_enable(&dev->plat_dev->dev);\n\terr = pm_runtime_resume_and_get(&dev->plat_dev->dev);\n\tif (err)\n\t\tgoto err_release_firmware_codec;\n\n\t \n\terr = allegro_mcu_reset(dev);\n\tif (err) {\n\t\tv4l2_err(&dev->v4l2_dev, \"failed to reset mcu\\n\");\n\t\tgoto err_suspend;\n\t}\n\n\tallegro_copy_firmware(dev, fw->data, fw->size);\n\tallegro_copy_fw_codec(dev, fw_codec->data, fw_codec->size);\n\n\terr = allegro_mcu_hw_init(dev, dev->fw_info);\n\tif (err) {\n\t\tv4l2_err(&dev->v4l2_dev, \"failed to initialize mcu\\n\");\n\t\tgoto err_free_fw_codec;\n\t}\n\n\tdev->m2m_dev = v4l2_m2m_init(&allegro_m2m_ops);\n\tif (IS_ERR(dev->m2m_dev)) {\n\t\tv4l2_err(&dev->v4l2_dev, \"failed to init mem2mem device\\n\");\n\t\tgoto err_mcu_hw_deinit;\n\t}\n\n\terr = allegro_register_device(dev);\n\tif (err) {\n\t\tv4l2_err(&dev->v4l2_dev, \"failed to register video device\\n\");\n\t\tgoto err_m2m_release;\n\t}\n\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"allegro codec registered as /dev/video%d\\n\",\n\t\t dev->video_dev.num);\n\n\tdev->initialized = true;\n\n\trelease_firmware(fw_codec);\n\trelease_firmware(fw);\n\n\treturn;\n\nerr_m2m_release:\n\tv4l2_m2m_release(dev->m2m_dev);\n\tdev->m2m_dev = NULL;\nerr_mcu_hw_deinit:\n\tallegro_mcu_hw_deinit(dev);\nerr_free_fw_codec:\n\tallegro_free_fw_codec(dev);\nerr_suspend:\n\tpm_runtime_put(&dev->plat_dev->dev);\n\tpm_runtime_disable(&dev->plat_dev->dev);\nerr_release_firmware_codec:\n\trelease_firmware(fw_codec);\nerr_release_firmware:\n\trelease_firmware(fw);\n}\n\nstatic int allegro_firmware_request_nowait(struct allegro_dev *dev)\n{\n\tconst char *fw = \"al5e_b.fw\";\n\n\tv4l2_dbg(1, debug, &dev->v4l2_dev,\n\t\t \"requesting firmware '%s'\\n\", fw);\n\treturn request_firmware_nowait(THIS_MODULE, true, fw,\n\t\t\t\t       &dev->plat_dev->dev, GFP_KERNEL, dev,\n\t\t\t\t       allegro_fw_callback);\n}\n\nstatic int allegro_probe(struct platform_device *pdev)\n{\n\tstruct allegro_dev *dev;\n\tstruct resource *res, *sram_res;\n\tint ret;\n\tint irq;\n\tvoid __iomem *regs, *sram_regs;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->plat_dev = pdev;\n\tinit_completion(&dev->init_complete);\n\tINIT_LIST_HEAD(&dev->channels);\n\n\tmutex_init(&dev->lock);\n\n\tdev->initialized = false;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"regs\");\n\tif (!res) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"regs resource missing from device tree\\n\");\n\t\treturn -EINVAL;\n\t}\n\tregs = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!regs) {\n\t\tdev_err(&pdev->dev, \"failed to map registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdev->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\n\t\t\t\t\t    &allegro_regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tdev_err(&pdev->dev, \"failed to init regmap\\n\");\n\t\treturn PTR_ERR(dev->regmap);\n\t}\n\n\tsram_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"sram\");\n\tif (!sram_res) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"sram resource missing from device tree\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsram_regs = devm_ioremap(&pdev->dev,\n\t\t\t\t sram_res->start,\n\t\t\t\t resource_size(sram_res));\n\tif (!sram_regs) {\n\t\tdev_err(&pdev->dev, \"failed to map sram\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdev->sram = devm_regmap_init_mmio(&pdev->dev, sram_regs,\n\t\t\t\t\t  &allegro_sram_config);\n\tif (IS_ERR(dev->sram)) {\n\t\tdev_err(&pdev->dev, \"failed to init sram\\n\");\n\t\treturn PTR_ERR(dev->sram);\n\t}\n\n\tdev->settings = syscon_regmap_lookup_by_compatible(\"xlnx,vcu-settings\");\n\tif (IS_ERR(dev->settings))\n\t\tdev_warn(&pdev->dev, \"failed to open settings\\n\");\n\n\tdev->clk_core = devm_clk_get(&pdev->dev, \"core_clk\");\n\tif (IS_ERR(dev->clk_core))\n\t\treturn PTR_ERR(dev->clk_core);\n\n\tdev->clk_mcu = devm_clk_get(&pdev->dev, \"mcu_clk\");\n\tif (IS_ERR(dev->clk_mcu))\n\t\treturn PTR_ERR(dev->clk_mcu);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tret = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\t\tallegro_hardirq,\n\t\t\t\t\tallegro_irq_thread,\n\t\t\t\t\tIRQF_SHARED, dev_name(&pdev->dev), dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tret = allegro_firmware_request_nowait(dev);\n\tif (ret < 0) {\n\t\tv4l2_err(&dev->v4l2_dev,\n\t\t\t \"failed to request firmware: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void allegro_remove(struct platform_device *pdev)\n{\n\tstruct allegro_dev *dev = platform_get_drvdata(pdev);\n\n\tif (dev->initialized) {\n\t\tvideo_unregister_device(&dev->video_dev);\n\t\tif (dev->m2m_dev)\n\t\t\tv4l2_m2m_release(dev->m2m_dev);\n\t\tallegro_mcu_hw_deinit(dev);\n\t\tallegro_free_fw_codec(dev);\n\t}\n\n\tpm_runtime_put(&dev->plat_dev->dev);\n\tpm_runtime_disable(&dev->plat_dev->dev);\n\n\tv4l2_device_unregister(&dev->v4l2_dev);\n}\n\nstatic int allegro_runtime_resume(struct device *device)\n{\n\tstruct allegro_dev *dev = dev_get_drvdata(device);\n\tstruct regmap *settings = dev->settings;\n\tunsigned int clk_mcu;\n\tunsigned int clk_core;\n\tint err;\n\n\tif (!settings)\n\t\treturn -EINVAL;\n\n#define MHZ_TO_HZ(freq) ((freq) * 1000 * 1000)\n\n\terr = regmap_read(settings, VCU_CORE_CLK, &clk_core);\n\tif (err < 0)\n\t\treturn err;\n\terr = clk_set_rate(dev->clk_core, MHZ_TO_HZ(clk_core));\n\tif (err < 0)\n\t\treturn err;\n\terr = clk_prepare_enable(dev->clk_core);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_read(settings, VCU_MCU_CLK, &clk_mcu);\n\tif (err < 0)\n\t\tgoto disable_clk_core;\n\terr = clk_set_rate(dev->clk_mcu, MHZ_TO_HZ(clk_mcu));\n\tif (err < 0)\n\t\tgoto disable_clk_core;\n\terr = clk_prepare_enable(dev->clk_mcu);\n\tif (err)\n\t\tgoto disable_clk_core;\n\n#undef MHZ_TO_HZ\n\n\treturn 0;\n\ndisable_clk_core:\n\tclk_disable_unprepare(dev->clk_core);\n\n\treturn err;\n}\n\nstatic int allegro_runtime_suspend(struct device *device)\n{\n\tstruct allegro_dev *dev = dev_get_drvdata(device);\n\n\tclk_disable_unprepare(dev->clk_mcu);\n\tclk_disable_unprepare(dev->clk_core);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id allegro_dt_ids[] = {\n\t{ .compatible = \"allegro,al5e-1.1\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, allegro_dt_ids);\n\nstatic const struct dev_pm_ops allegro_pm_ops = {\n\t.runtime_resume = allegro_runtime_resume,\n\t.runtime_suspend = allegro_runtime_suspend,\n};\n\nstatic struct platform_driver allegro_driver = {\n\t.probe = allegro_probe,\n\t.remove_new = allegro_remove,\n\t.driver = {\n\t\t.name = \"allegro\",\n\t\t.of_match_table = allegro_dt_ids,\n\t\t.pm = &allegro_pm_ops,\n\t},\n};\n\nmodule_platform_driver(allegro_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michael Tretter <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"Allegro DVT encoder driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}