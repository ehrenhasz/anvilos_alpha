{
  "module_name": "allegro-mail.c",
  "hash_id": "9466e0ddb79323aeae76fd847d0b194f60b9ce852081a0900ec99db34e0de682",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/platform/allegro-dvt/allegro-mail.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/videodev2.h>\n\n#include \"allegro-mail.h\"\n\nconst char *msg_type_name(enum mcu_msg_type type)\n{\n\tstatic char buf[9];\n\n\tswitch (type) {\n\tcase MCU_MSG_TYPE_INIT:\n\t\treturn \"INIT\";\n\tcase MCU_MSG_TYPE_CREATE_CHANNEL:\n\t\treturn \"CREATE_CHANNEL\";\n\tcase MCU_MSG_TYPE_DESTROY_CHANNEL:\n\t\treturn \"DESTROY_CHANNEL\";\n\tcase MCU_MSG_TYPE_ENCODE_FRAME:\n\t\treturn \"ENCODE_FRAME\";\n\tcase MCU_MSG_TYPE_PUT_STREAM_BUFFER:\n\t\treturn \"PUT_STREAM_BUFFER\";\n\tcase MCU_MSG_TYPE_PUSH_BUFFER_INTERMEDIATE:\n\t\treturn \"PUSH_BUFFER_INTERMEDIATE\";\n\tcase MCU_MSG_TYPE_PUSH_BUFFER_REFERENCE:\n\t\treturn \"PUSH_BUFFER_REFERENCE\";\n\tdefault:\n\t\tsnprintf(buf, sizeof(buf), \"(0x%04x)\", type);\n\t\treturn buf;\n\t}\n}\nEXPORT_SYMBOL(msg_type_name);\n\nstatic ssize_t\nallegro_enc_init(u32 *dst, struct mcu_msg_init_request *msg)\n{\n\tunsigned int i = 0;\n\tenum mcu_msg_version version = msg->header.version;\n\n\tdst[i++] = msg->reserved0;\n\tdst[i++] = msg->suballoc_dma;\n\tdst[i++] = msg->suballoc_size;\n\tdst[i++] = msg->encoder_buffer_size;\n\tdst[i++] = msg->encoder_buffer_color_depth;\n\tdst[i++] = msg->num_cores;\n\tif (version >= MCU_MSG_VERSION_2019_2) {\n\t\tdst[i++] = msg->clk_rate;\n\t\tdst[i++] = 0;\n\t}\n\n\treturn i * sizeof(*dst);\n}\n\nstatic inline u32 settings_get_mcu_codec(struct create_channel_param *param)\n{\n\tenum mcu_msg_version version = param->version;\n\tu32 pixelformat = param->codec;\n\n\tif (version < MCU_MSG_VERSION_2019_2) {\n\t\tswitch (pixelformat) {\n\t\tcase V4L2_PIX_FMT_HEVC:\n\t\t\treturn 2;\n\t\tcase V4L2_PIX_FMT_H264:\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tswitch (pixelformat) {\n\t\tcase V4L2_PIX_FMT_HEVC:\n\t\t\treturn 1;\n\t\tcase V4L2_PIX_FMT_H264:\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\nssize_t\nallegro_encode_config_blob(u32 *dst, struct create_channel_param *param)\n{\n\tenum mcu_msg_version version = param->version;\n\tunsigned int i = 0;\n\tunsigned int j = 0;\n\tu32 val;\n\tunsigned int codec = settings_get_mcu_codec(param);\n\n\tif (version >= MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = param->layer_id;\n\tdst[i++] = FIELD_PREP(GENMASK(31, 16), param->height) |\n\t\t   FIELD_PREP(GENMASK(15, 0), param->width);\n\tif (version >= MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = param->videomode;\n\tdst[i++] = param->format;\n\tif (version < MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = param->colorspace;\n\tdst[i++] = param->src_mode;\n\tif (version >= MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = param->src_bit_depth;\n\tdst[i++] = FIELD_PREP(GENMASK(31, 24), codec) |\n\t\t   FIELD_PREP(GENMASK(23, 8), param->constraint_set_flags) |\n\t\t   FIELD_PREP(GENMASK(7, 0), param->profile);\n\tdst[i++] = FIELD_PREP(GENMASK(31, 16), param->tier) |\n\t\t   FIELD_PREP(GENMASK(15, 0), param->level);\n\n\tval = 0;\n\tval |= param->temporal_mvp_enable ? BIT(20) : 0;\n\tval |= FIELD_PREP(GENMASK(7, 4), param->log2_max_frame_num);\n\tif (version >= MCU_MSG_VERSION_2019_2)\n\t\tval |= FIELD_PREP(GENMASK(3, 0), param->log2_max_poc - 1);\n\telse\n\t\tval |= FIELD_PREP(GENMASK(3, 0), param->log2_max_poc);\n\tdst[i++] = val;\n\n\tval = 0;\n\tval |= param->enable_reordering ? BIT(0) : 0;\n\tval |= param->dbf_ovr_en ? BIT(2) : 0;\n\tval |= param->override_lf ? BIT(12) : 0;\n\tdst[i++] = val;\n\n\tif (version >= MCU_MSG_VERSION_2019_2) {\n\t\tval = 0;\n\t\tval |= param->custom_lda ? BIT(2) : 0;\n\t\tval |= param->rdo_cost_mode ? BIT(20) : 0;\n\t\tdst[i++] = val;\n\n\t\tval = 0;\n\t\tval |= param->lf ? BIT(2) : 0;\n\t\tval |= param->lf_x_tile ? BIT(3) : 0;\n\t\tval |= param->lf_x_slice ? BIT(4) : 0;\n\t\tdst[i++] = val;\n\t} else {\n\t\tval = 0;\n\t\tdst[i++] = val;\n\t}\n\n\tdst[i++] = FIELD_PREP(GENMASK(15, 8), param->beta_offset) |\n\t\t   FIELD_PREP(GENMASK(7, 0), param->tc_offset);\n\tdst[i++] = param->unknown11;\n\tdst[i++] = param->unknown12;\n\tdst[i++] = param->num_slices;\n\tdst[i++] = param->encoder_buffer_offset;\n\tdst[i++] = param->encoder_buffer_enabled;\n\n\tdst[i++] = FIELD_PREP(GENMASK(31, 16), param->clip_vrt_range) |\n\t\t   FIELD_PREP(GENMASK(15, 0), param->clip_hrz_range);\n\tdst[i++] = FIELD_PREP(GENMASK(31, 16), param->me_range[1]) |\n\t\t   FIELD_PREP(GENMASK(15, 0), param->me_range[0]);\n\tdst[i++] = FIELD_PREP(GENMASK(31, 16), param->me_range[3]) |\n\t\t   FIELD_PREP(GENMASK(15, 0), param->me_range[2]);\n\tdst[i++] = FIELD_PREP(GENMASK(31, 24), param->min_tu_size) |\n\t\t   FIELD_PREP(GENMASK(23, 16), param->max_tu_size) |\n\t\t   FIELD_PREP(GENMASK(15, 8), param->min_cu_size) |\n\t\t   FIELD_PREP(GENMASK(8, 0), param->max_cu_size);\n\tdst[i++] = FIELD_PREP(GENMASK(15, 8), param->max_transfo_depth_intra) |\n\t\t   FIELD_PREP(GENMASK(7, 0), param->max_transfo_depth_inter);\n\tdst[i++] = param->entropy_mode;\n\tdst[i++] = param->wp_mode;\n\n\tdst[i++] = param->rate_control_mode;\n\tdst[i++] = param->initial_rem_delay;\n\tdst[i++] = param->cpb_size;\n\tdst[i++] = FIELD_PREP(GENMASK(31, 16), param->clk_ratio) |\n\t\t   FIELD_PREP(GENMASK(15, 0), param->framerate);\n\tdst[i++] = param->target_bitrate;\n\tdst[i++] = param->max_bitrate;\n\tdst[i++] = FIELD_PREP(GENMASK(31, 16), param->min_qp) |\n\t\t   FIELD_PREP(GENMASK(15, 0), param->initial_qp);\n\tdst[i++] = FIELD_PREP(GENMASK(31, 16), param->ip_delta) |\n\t\t   FIELD_PREP(GENMASK(15, 0), param->max_qp);\n\tdst[i++] = FIELD_PREP(GENMASK(31, 16), param->golden_ref) |\n\t\t   FIELD_PREP(GENMASK(15, 0), param->pb_delta);\n\tdst[i++] = FIELD_PREP(GENMASK(31, 16), param->golden_ref_frequency) |\n\t\t   FIELD_PREP(GENMASK(15, 0), param->golden_delta);\n\tif (version >= MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = param->rate_control_option;\n\telse\n\t\tdst[i++] = 0;\n\n\tif (version >= MCU_MSG_VERSION_2019_2) {\n\t\tdst[i++] = param->num_pixel;\n\t\tdst[i++] = FIELD_PREP(GENMASK(31, 16), param->max_pixel_value) |\n\t\t\tFIELD_PREP(GENMASK(15, 0), param->max_psnr);\n\t\tfor (j = 0; j < 3; j++)\n\t\t\tdst[i++] = param->maxpicturesize[j];\n\t}\n\n\tif (version >= MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = param->gop_ctrl_mode;\n\telse\n\t\tdst[i++] = 0;\n\n\tif (version >= MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = FIELD_PREP(GENMASK(31, 24), param->freq_golden_ref) |\n\t\t\t   FIELD_PREP(GENMASK(23, 16), param->num_b) |\n\t\t\t   FIELD_PREP(GENMASK(15, 0), param->gop_length);\n\tdst[i++] = param->freq_idr;\n\tif (version >= MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = param->enable_lt;\n\tdst[i++] = param->freq_lt;\n\tdst[i++] = param->gdr_mode;\n\tif (version < MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = FIELD_PREP(GENMASK(31, 24), param->freq_golden_ref) |\n\t\t\t   FIELD_PREP(GENMASK(23, 16), param->num_b) |\n\t\t\t   FIELD_PREP(GENMASK(15, 0), param->gop_length);\n\n\tif (version >= MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = param->tmpdqp;\n\n\tdst[i++] = param->subframe_latency;\n\tdst[i++] = param->lda_control_mode;\n\tif (version < MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = param->unknown41;\n\n\tif (version >= MCU_MSG_VERSION_2019_2) {\n\t\tfor (j = 0; j < 6; j++)\n\t\t\tdst[i++] = param->lda_factors[j];\n\t\tdst[i++] = param->max_num_merge_cand;\n\t}\n\n\treturn i * sizeof(*dst);\n}\n\nstatic ssize_t\nallegro_enc_create_channel(u32 *dst, struct mcu_msg_create_channel *msg)\n{\n\tenum mcu_msg_version version = msg->header.version;\n\tunsigned int i = 0;\n\n\tdst[i++] = msg->user_id;\n\n\tif (version >= MCU_MSG_VERSION_2019_2) {\n\t\tdst[i++] = msg->blob_mcu_addr;\n\t} else {\n\t\tmemcpy(&dst[i], msg->blob, msg->blob_size);\n\t\ti += msg->blob_size / sizeof(*dst);\n\t}\n\n\tif (version >= MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = msg->ep1_addr;\n\n\treturn i * sizeof(*dst);\n}\n\nssize_t allegro_decode_config_blob(struct create_channel_param *param,\n\t\t\t\t   struct mcu_msg_create_channel_response *msg,\n\t\t\t\t   u32 *src)\n{\n\tenum mcu_msg_version version = msg->header.version;\n\n\tif (version >= MCU_MSG_VERSION_2019_2) {\n\t\tparam->num_ref_idx_l0 = FIELD_GET(GENMASK(7, 4), src[9]);\n\t\tparam->num_ref_idx_l1 = FIELD_GET(GENMASK(11, 8), src[9]);\n\t} else {\n\t\tparam->num_ref_idx_l0 = msg->num_ref_idx_l0;\n\t\tparam->num_ref_idx_l1 = msg->num_ref_idx_l1;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t\nallegro_enc_destroy_channel(u32 *dst, struct mcu_msg_destroy_channel *msg)\n{\n\tunsigned int i = 0;\n\n\tdst[i++] = msg->channel_id;\n\n\treturn i * sizeof(*dst);\n}\n\nstatic ssize_t\nallegro_enc_push_buffers(u32 *dst, struct mcu_msg_push_buffers_internal *msg)\n{\n\tunsigned int i = 0;\n\tstruct mcu_msg_push_buffers_internal_buffer *buffer;\n\tunsigned int num_buffers = msg->num_buffers;\n\tunsigned int j;\n\n\tdst[i++] = msg->channel_id;\n\n\tfor (j = 0; j < num_buffers; j++) {\n\t\tbuffer = &msg->buffer[j];\n\t\tdst[i++] = buffer->dma_addr;\n\t\tdst[i++] = buffer->mcu_addr;\n\t\tdst[i++] = buffer->size;\n\t}\n\n\treturn i * sizeof(*dst);\n}\n\nstatic ssize_t\nallegro_enc_put_stream_buffer(u32 *dst,\n\t\t\t      struct mcu_msg_put_stream_buffer *msg)\n{\n\tunsigned int i = 0;\n\n\tdst[i++] = msg->channel_id;\n\tdst[i++] = msg->dma_addr;\n\tdst[i++] = msg->mcu_addr;\n\tdst[i++] = msg->size;\n\tdst[i++] = msg->offset;\n\tdst[i++] = lower_32_bits(msg->dst_handle);\n\tdst[i++] = upper_32_bits(msg->dst_handle);\n\n\treturn i * sizeof(*dst);\n}\n\nstatic ssize_t\nallegro_enc_encode_frame(u32 *dst, struct mcu_msg_encode_frame *msg)\n{\n\tenum mcu_msg_version version = msg->header.version;\n\tunsigned int i = 0;\n\n\tdst[i++] = msg->channel_id;\n\n\tdst[i++] = msg->reserved;\n\tdst[i++] = msg->encoding_options;\n\tdst[i++] = FIELD_PREP(GENMASK(31, 16), msg->padding) |\n\t\t   FIELD_PREP(GENMASK(15, 0), msg->pps_qp);\n\n\tif (version >= MCU_MSG_VERSION_2019_2) {\n\t\tdst[i++] = 0;\n\t\tdst[i++] = 0;\n\t\tdst[i++] = 0;\n\t\tdst[i++] = 0;\n\t}\n\n\tdst[i++] = lower_32_bits(msg->user_param);\n\tdst[i++] = upper_32_bits(msg->user_param);\n\tdst[i++] = lower_32_bits(msg->src_handle);\n\tdst[i++] = upper_32_bits(msg->src_handle);\n\tdst[i++] = msg->request_options;\n\tdst[i++] = msg->src_y;\n\tdst[i++] = msg->src_uv;\n\tif (version >= MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = msg->is_10_bit;\n\tdst[i++] = msg->stride;\n\tif (version >= MCU_MSG_VERSION_2019_2)\n\t\tdst[i++] = msg->format;\n\tdst[i++] = msg->ep2;\n\tdst[i++] = lower_32_bits(msg->ep2_v);\n\tdst[i++] = upper_32_bits(msg->ep2_v);\n\n\treturn i * sizeof(*dst);\n}\n\nstatic ssize_t\nallegro_dec_init(struct mcu_msg_init_response *msg, u32 *src)\n{\n\tunsigned int i = 0;\n\n\tmsg->reserved0 = src[i++];\n\n\treturn i * sizeof(*src);\n}\n\nstatic ssize_t\nallegro_dec_create_channel(struct mcu_msg_create_channel_response *msg,\n\t\t\t   u32 *src)\n{\n\tenum mcu_msg_version version = msg->header.version;\n\tunsigned int i = 0;\n\n\tmsg->channel_id = src[i++];\n\tmsg->user_id = src[i++];\n\t \n\tif (version < MCU_MSG_VERSION_2019_2) {\n\t\tmsg->options = src[i++];\n\t\tmsg->num_core = src[i++];\n\t\tmsg->num_ref_idx_l0 = FIELD_GET(GENMASK(7, 4), src[i]);\n\t\tmsg->num_ref_idx_l1 = FIELD_GET(GENMASK(11, 8), src[i++]);\n\t}\n\tmsg->int_buffers_count = src[i++];\n\tmsg->int_buffers_size = src[i++];\n\tmsg->rec_buffers_count = src[i++];\n\tmsg->rec_buffers_size = src[i++];\n\tmsg->reserved = src[i++];\n\tmsg->error_code = src[i++];\n\n\treturn i * sizeof(*src);\n}\n\nstatic ssize_t\nallegro_dec_destroy_channel(struct mcu_msg_destroy_channel_response *msg,\n\t\t\t    u32 *src)\n{\n\tunsigned int i = 0;\n\n\tmsg->channel_id = src[i++];\n\n\treturn i * sizeof(*src);\n}\n\nstatic ssize_t\nallegro_dec_encode_frame(struct mcu_msg_encode_frame_response *msg, u32 *src)\n{\n\tenum mcu_msg_version version = msg->header.version;\n\tunsigned int i = 0;\n\tunsigned int j;\n\n\tmsg->channel_id = src[i++];\n\n\tmsg->dst_handle = src[i++];\n\tmsg->dst_handle |= (((u64)src[i++]) << 32);\n\tmsg->user_param = src[i++];\n\tmsg->user_param |= (((u64)src[i++]) << 32);\n\tmsg->src_handle = src[i++];\n\tmsg->src_handle |= (((u64)src[i++]) << 32);\n\tmsg->skip = FIELD_GET(GENMASK(31, 16), src[i]);\n\tmsg->is_ref = FIELD_GET(GENMASK(15, 0), src[i++]);\n\tmsg->initial_removal_delay = src[i++];\n\tmsg->dpb_output_delay = src[i++];\n\tmsg->size = src[i++];\n\tmsg->frame_tag_size = src[i++];\n\tmsg->stuffing = src[i++];\n\tmsg->filler = src[i++];\n\tmsg->num_row = FIELD_GET(GENMASK(31, 16), src[i]);\n\tmsg->num_column = FIELD_GET(GENMASK(15, 0), src[i++]);\n\tmsg->num_ref_idx_l1 = FIELD_GET(GENMASK(31, 24), src[i]);\n\tmsg->num_ref_idx_l0 = FIELD_GET(GENMASK(23, 16), src[i]);\n\tmsg->qp = FIELD_GET(GENMASK(15, 0), src[i++]);\n\tmsg->partition_table_offset = src[i++];\n\tmsg->partition_table_size = src[i++];\n\tmsg->sum_complex = src[i++];\n\tfor (j = 0; j < 4; j++)\n\t\tmsg->tile_width[j] = src[i++];\n\tfor (j = 0; j < 22; j++)\n\t\tmsg->tile_height[j] = src[i++];\n\tmsg->error_code = src[i++];\n\tmsg->slice_type = src[i++];\n\tmsg->pic_struct = src[i++];\n\tmsg->reserved = FIELD_GET(GENMASK(31, 24), src[i]);\n\tmsg->is_last_slice = FIELD_GET(GENMASK(23, 16), src[i]);\n\tmsg->is_first_slice = FIELD_GET(GENMASK(15, 8), src[i]);\n\tmsg->is_idr = FIELD_GET(GENMASK(7, 0), src[i++]);\n\n\tmsg->reserved1 = FIELD_GET(GENMASK(31, 16), src[i]);\n\tmsg->pps_qp = FIELD_GET(GENMASK(15, 0), src[i++]);\n\n\tmsg->reserved2 = src[i++];\n\tif (version >= MCU_MSG_VERSION_2019_2) {\n\t\tmsg->reserved3 = src[i++];\n\t\tmsg->reserved4 = src[i++];\n\t\tmsg->reserved5 = src[i++];\n\t\tmsg->reserved6 = src[i++];\n\t}\n\n\treturn i * sizeof(*src);\n}\n\n \nssize_t allegro_encode_mail(u32 *dst, void *msg)\n{\n\tconst struct mcu_msg_header *header = msg;\n\tssize_t size;\n\n\tif (!msg || !dst)\n\t\treturn -EINVAL;\n\n\tswitch (header->type) {\n\tcase MCU_MSG_TYPE_INIT:\n\t\tsize = allegro_enc_init(&dst[1], msg);\n\t\tbreak;\n\tcase MCU_MSG_TYPE_CREATE_CHANNEL:\n\t\tsize = allegro_enc_create_channel(&dst[1], msg);\n\t\tbreak;\n\tcase MCU_MSG_TYPE_DESTROY_CHANNEL:\n\t\tsize = allegro_enc_destroy_channel(&dst[1], msg);\n\t\tbreak;\n\tcase MCU_MSG_TYPE_ENCODE_FRAME:\n\t\tsize = allegro_enc_encode_frame(&dst[1], msg);\n\t\tbreak;\n\tcase MCU_MSG_TYPE_PUT_STREAM_BUFFER:\n\t\tsize = allegro_enc_put_stream_buffer(&dst[1], msg);\n\t\tbreak;\n\tcase MCU_MSG_TYPE_PUSH_BUFFER_INTERMEDIATE:\n\tcase MCU_MSG_TYPE_PUSH_BUFFER_REFERENCE:\n\t\tsize = allegro_enc_push_buffers(&dst[1], msg);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdst[0] = FIELD_PREP(GENMASK(31, 16), header->type) |\n\t\t FIELD_PREP(GENMASK(15, 0), size);\n\n\treturn size + sizeof(*dst);\n}\n\n \nint allegro_decode_mail(void *msg, u32 *src)\n{\n\tstruct mcu_msg_header *header;\n\n\tif (!src || !msg)\n\t\treturn -EINVAL;\n\n\theader = msg;\n\theader->type = FIELD_GET(GENMASK(31, 16), src[0]);\n\n\tsrc++;\n\tswitch (header->type) {\n\tcase MCU_MSG_TYPE_INIT:\n\t\tallegro_dec_init(msg, src);\n\t\tbreak;\n\tcase MCU_MSG_TYPE_CREATE_CHANNEL:\n\t\tallegro_dec_create_channel(msg, src);\n\t\tbreak;\n\tcase MCU_MSG_TYPE_DESTROY_CHANNEL:\n\t\tallegro_dec_destroy_channel(msg, src);\n\t\tbreak;\n\tcase MCU_MSG_TYPE_ENCODE_FRAME:\n\t\tallegro_dec_encode_frame(msg, src);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}