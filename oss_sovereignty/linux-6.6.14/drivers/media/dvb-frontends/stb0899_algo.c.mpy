{
  "module_name": "stb0899_algo.c",
  "hash_id": "f0621df5ee69c9c49c37f24266150e10c765b00db959b8b2bd42cfb5dc4a4690",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stb0899_algo.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include \"stb0899_drv.h\"\n#include \"stb0899_priv.h\"\n#include \"stb0899_reg.h\"\n\nstatic inline u32 stb0899_do_div(u64 n, u32 d)\n{\n\t \n\n\tdo_div(n, d);\n\treturn n;\n}\n\n#if 0\n \n \nstatic u32 stb0899_calc_srate(u32 master_clk, u8 *sfr)\n{\n\tu64 tmp;\n\n\t \n\n\t \n\ttmp = (((u32)sfr[0]) << 16) | (((u32)sfr[1]) << 8) | sfr[2];\n\ttmp &= ~0xf;\n\ttmp *= master_clk;\n\ttmp >>= 24;\n\n\treturn tmp;\n}\n\n \nstatic u32 stb0899_get_srate(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tu8 sfr[3];\n\n\tstb0899_read_regs(state, STB0899_SFRH, sfr, 3);\n\n\treturn stb0899_calc_srate(internal->master_clk, sfr);\n}\n#endif\n\n \nstatic u32 stb0899_set_srate(struct stb0899_state *state, u32 master_clk, u32 srate)\n{\n\tu32 tmp;\n\tu8 sfr[3];\n\n\tdprintk(state->verbose, FE_DEBUG, 1, \"-->\");\n\t \n\n\ttmp = stb0899_do_div((((u64)srate) << 21) + master_clk, 2 * master_clk);\n\ttmp <<= 4;\n\n\tsfr[0] = tmp >> 16;\n\tsfr[1] = tmp >>  8;\n\tsfr[2] = tmp;\n\n\tstb0899_write_regs(state, STB0899_SFRH, sfr, 3);\n\n\treturn srate;\n}\n\n \nstatic long stb0899_calc_derot_time(long srate)\n{\n\tif (srate > 0)\n\t\treturn (100000 / (srate / 1000));\n\telse\n\t\treturn 0;\n}\n\n \nlong stb0899_carr_width(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\n\treturn (internal->srate + (internal->srate * internal->rolloff) / 100);\n}\n\n \nstatic void stb0899_first_subrange(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal\t= &state->internal;\n\tstruct stb0899_params *params\t\t= &state->params;\n\tstruct stb0899_config *config\t\t=  state->config;\n\n\tint range = 0;\n\tu32 bandwidth = 0;\n\n\tif (config->tuner_get_bandwidth) {\n\t\tstb0899_i2c_gate_ctrl(&state->frontend, 1);\n\t\tconfig->tuner_get_bandwidth(&state->frontend, &bandwidth);\n\t\tstb0899_i2c_gate_ctrl(&state->frontend, 0);\n\t\trange = bandwidth - stb0899_carr_width(state) / 2;\n\t}\n\n\tif (range > 0)\n\t\tinternal->sub_range = min(internal->srch_range, range);\n\telse\n\t\tinternal->sub_range = 0;\n\n\tinternal->freq = params->freq;\n\tinternal->tuner_offst = 0L;\n\tinternal->sub_dir = 1;\n}\n\n \nstatic enum stb0899_status stb0899_check_tmg(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tint lock;\n\tu8 reg;\n\ts8 timing;\n\n\tmsleep(internal->t_derot);\n\n\tstb0899_write_reg(state, STB0899_RTF, 0xf2);\n\treg = stb0899_read_reg(state, STB0899_TLIR);\n\tlock = STB0899_GETFIELD(TLIR_TMG_LOCK_IND, reg);\n\ttiming = stb0899_read_reg(state, STB0899_RTF);\n\n\tif (lock >= 42) {\n\t\tif ((lock > 48) && (abs(timing) >= 110)) {\n\t\t\tinternal->status = ANALOGCARRIER;\n\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"-->ANALOG Carrier !\");\n\t\t} else {\n\t\t\tinternal->status = TIMINGOK;\n\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"------->TIMING OK !\");\n\t\t}\n\t} else {\n\t\tinternal->status = NOTIMING;\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"-->NO TIMING !\");\n\t}\n\treturn internal->status;\n}\n\n \nstatic enum stb0899_status stb0899_search_tmg(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tstruct stb0899_params *params = &state->params;\n\n\tshort int derot_step, derot_freq = 0, derot_limit, next_loop = 3;\n\tint index = 0;\n\tu8 cfr[2];\n\n\tinternal->status = NOTIMING;\n\n\t \n\tderot_limit = (internal->sub_range / 2L) / internal->mclk;\n\tderot_step = (params->srate / 2L) / internal->mclk;\n\n\twhile ((stb0899_check_tmg(state) != TIMINGOK) && next_loop) {\n\t\tindex++;\n\t\tderot_freq += index * internal->direction * derot_step;\t \n\n\t\tif (abs(derot_freq) > derot_limit)\n\t\t\tnext_loop--;\n\n\t\tif (next_loop) {\n\t\t\tSTB0899_SETFIELD_VAL(CFRM, cfr[0], MSB(internal->inversion * derot_freq));\n\t\t\tSTB0899_SETFIELD_VAL(CFRL, cfr[1], LSB(internal->inversion * derot_freq));\n\t\t\tstb0899_write_regs(state, STB0899_CFRM, cfr, 2);  \n\t\t}\n\t\tinternal->direction = -internal->direction;\t \n\t}\n\n\tif (internal->status == TIMINGOK) {\n\t\tstb0899_read_regs(state, STB0899_CFRM, cfr, 2);  \n\t\tinternal->derot_freq = internal->inversion * MAKEWORD16(cfr[0], cfr[1]);\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"------->TIMING OK ! Derot Freq = %d\", internal->derot_freq);\n\t}\n\n\treturn internal->status;\n}\n\n \nstatic enum stb0899_status stb0899_check_carrier(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tu8 reg;\n\n\tmsleep(internal->t_derot);  \n\n\treg = stb0899_read_reg(state, STB0899_CFD);\n\tSTB0899_SETFIELD_VAL(CFD_ON, reg, 1);\n\tstb0899_write_reg(state, STB0899_CFD, reg);\n\n\treg = stb0899_read_reg(state, STB0899_DSTATUS);\n\tdprintk(state->verbose, FE_DEBUG, 1, \"--------------------> STB0899_DSTATUS=[0x%02x]\", reg);\n\tif (STB0899_GETFIELD(CARRIER_FOUND, reg)) {\n\t\tinternal->status = CARRIEROK;\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"-------------> CARRIEROK !\");\n\t} else {\n\t\tinternal->status = NOCARRIER;\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"-------------> NOCARRIER !\");\n\t}\n\n\treturn internal->status;\n}\n\n \nstatic enum stb0899_status stb0899_search_carrier(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\n\tshort int derot_freq = 0, last_derot_freq = 0, derot_limit, next_loop = 3;\n\tint index = 0;\n\tu8 cfr[2];\n\tu8 reg;\n\n\tinternal->status = NOCARRIER;\n\tderot_limit = (internal->sub_range / 2L) / internal->mclk;\n\tderot_freq = internal->derot_freq;\n\n\treg = stb0899_read_reg(state, STB0899_CFD);\n\tSTB0899_SETFIELD_VAL(CFD_ON, reg, 1);\n\tstb0899_write_reg(state, STB0899_CFD, reg);\n\n\tdo {\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Derot Freq=%d, mclk=%d\", derot_freq, internal->mclk);\n\t\tif (stb0899_check_carrier(state) == NOCARRIER) {\n\t\t\tindex++;\n\t\t\tlast_derot_freq = derot_freq;\n\t\t\tderot_freq += index * internal->direction * internal->derot_step;  \n\n\t\t\tif(abs(derot_freq) > derot_limit)\n\t\t\t\tnext_loop--;\n\n\t\t\tif (next_loop) {\n\t\t\t\treg = stb0899_read_reg(state, STB0899_CFD);\n\t\t\t\tSTB0899_SETFIELD_VAL(CFD_ON, reg, 1);\n\t\t\t\tstb0899_write_reg(state, STB0899_CFD, reg);\n\n\t\t\t\tSTB0899_SETFIELD_VAL(CFRM, cfr[0], MSB(internal->inversion * derot_freq));\n\t\t\t\tSTB0899_SETFIELD_VAL(CFRL, cfr[1], LSB(internal->inversion * derot_freq));\n\t\t\t\tstb0899_write_regs(state, STB0899_CFRM, cfr, 2);  \n\t\t\t}\n\t\t}\n\n\t\tinternal->direction = -internal->direction;  \n\t} while ((internal->status != CARRIEROK) && next_loop);\n\n\tif (internal->status == CARRIEROK) {\n\t\tstb0899_read_regs(state, STB0899_CFRM, cfr, 2);  \n\t\tinternal->derot_freq = internal->inversion * MAKEWORD16(cfr[0], cfr[1]);\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"----> CARRIER OK !, Derot Freq=%d\", internal->derot_freq);\n\t} else {\n\t\tinternal->derot_freq = last_derot_freq;\n\t}\n\n\treturn internal->status;\n}\n\n \nstatic enum stb0899_status stb0899_check_data(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tstruct stb0899_params *params = &state->params;\n\n\tint lock = 0, index = 0, dataTime = 500, loop;\n\tu8 reg;\n\n\tinternal->status = NODATA;\n\n\t \n\treg = stb0899_read_reg(state, STB0899_TSTRES);\n\tSTB0899_SETFIELD_VAL(FRESACS, reg, 1);\n\tstb0899_write_reg(state, STB0899_TSTRES, reg);\n\tmsleep(1);\n\treg = stb0899_read_reg(state, STB0899_TSTRES);\n\tSTB0899_SETFIELD_VAL(FRESACS, reg, 0);\n\tstb0899_write_reg(state, STB0899_TSTRES, reg);\n\n\tif (params->srate <= 2000000)\n\t\tdataTime = 2000;\n\telse if (params->srate <= 5000000)\n\t\tdataTime = 1500;\n\telse if (params->srate <= 15000000)\n\t\tdataTime = 1000;\n\telse\n\t\tdataTime = 500;\n\n\t \n\tstb0899_read_reg(state, STB0899_VSTATUS);\n\n\tstb0899_write_reg(state, STB0899_DSTATUS2, 0x00);  \n\twhile (1) {\n\t\t \n\t\treg = stb0899_read_reg(state, STB0899_VSTATUS);\n\t\tlock = STB0899_GETFIELD(VSTATUS_LOCKEDVIT, reg);\n\t\tloop = STB0899_GETFIELD(VSTATUS_END_LOOPVIT, reg);\n\n\t\tif (lock || loop || (index > dataTime))\n\t\t\tbreak;\n\t\tindex++;\n\t}\n\n\tif (lock) {\t \n\t\tinternal->status = DATAOK;\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"-----------------> DATA OK !\");\n\t}\n\n\treturn internal->status;\n}\n\n \nstatic enum stb0899_status stb0899_search_data(struct stb0899_state *state)\n{\n\tshort int derot_freq, derot_step, derot_limit, next_loop = 3;\n\tu8 cfr[2];\n\tu8 reg;\n\tint index = 1;\n\n\tstruct stb0899_internal *internal = &state->internal;\n\tstruct stb0899_params *params = &state->params;\n\n\tderot_step = (params->srate / 4L) / internal->mclk;\n\tderot_limit = (internal->sub_range / 2L) / internal->mclk;\n\tderot_freq = internal->derot_freq;\n\n\tdo {\n\t\tif ((internal->status != CARRIEROK) || (stb0899_check_data(state) != DATAOK)) {\n\n\t\t\tderot_freq += index * internal->direction * derot_step;\t \n\t\t\tif (abs(derot_freq) > derot_limit)\n\t\t\t\tnext_loop--;\n\n\t\t\tif (next_loop) {\n\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Derot freq=%d, mclk=%d\", derot_freq, internal->mclk);\n\t\t\t\treg = stb0899_read_reg(state, STB0899_CFD);\n\t\t\t\tSTB0899_SETFIELD_VAL(CFD_ON, reg, 1);\n\t\t\t\tstb0899_write_reg(state, STB0899_CFD, reg);\n\n\t\t\t\tSTB0899_SETFIELD_VAL(CFRM, cfr[0], MSB(internal->inversion * derot_freq));\n\t\t\t\tSTB0899_SETFIELD_VAL(CFRL, cfr[1], LSB(internal->inversion * derot_freq));\n\t\t\t\tstb0899_write_regs(state, STB0899_CFRM, cfr, 2);  \n\n\t\t\t\tstb0899_check_carrier(state);\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\tinternal->direction = -internal->direction;  \n\t} while ((internal->status != DATAOK) && next_loop);\n\n\tif (internal->status == DATAOK) {\n\t\tstb0899_read_regs(state, STB0899_CFRM, cfr, 2);  \n\n\t\t \n\t\treg = stb0899_read_reg(state, STB0899_IQSWAP);\n\t\tif (STB0899_GETFIELD(SYM, reg))\n\t\t\tinternal->inversion = IQ_SWAP_ON;\n\t\telse\n\t\t\tinternal->inversion = IQ_SWAP_OFF;\n\n\t\tinternal->derot_freq = internal->inversion * MAKEWORD16(cfr[0], cfr[1]);\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"------> DATAOK ! Derot Freq=%d\", internal->derot_freq);\n\t}\n\n\treturn internal->status;\n}\n\n \nstatic enum stb0899_status stb0899_check_range(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tstruct stb0899_params *params = &state->params;\n\n\tint range_offst, tp_freq;\n\n\trange_offst = internal->srch_range / 2000;\n\ttp_freq = internal->freq - (internal->derot_freq * internal->mclk) / 1000;\n\n\tif ((tp_freq >= params->freq - range_offst) && (tp_freq <= params->freq + range_offst)) {\n\t\tinternal->status = RANGEOK;\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"----> RANGEOK !\");\n\t} else {\n\t\tinternal->status = OUTOFRANGE;\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"----> OUT OF RANGE !\");\n\t}\n\n\treturn internal->status;\n}\n\n \nstatic void next_sub_range(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tstruct stb0899_params *params = &state->params;\n\n\tlong old_sub_range;\n\n\tif (internal->sub_dir > 0) {\n\t\told_sub_range = internal->sub_range;\n\t\tinternal->sub_range = min((internal->srch_range / 2) -\n\t\t\t\t\t  (internal->tuner_offst + internal->sub_range / 2),\n\t\t\t\t\t   internal->sub_range);\n\n\t\tif (internal->sub_range < 0)\n\t\t\tinternal->sub_range = 0;\n\n\t\tinternal->tuner_offst += (old_sub_range + internal->sub_range) / 2;\n\t}\n\n\tinternal->freq = params->freq + (internal->sub_dir * internal->tuner_offst) / 1000;\n\tinternal->sub_dir = -internal->sub_dir;\n}\n\n \nenum stb0899_status stb0899_dvbs_algo(struct stb0899_state *state)\n{\n\tstruct stb0899_params *params\t\t= &state->params;\n\tstruct stb0899_internal *internal\t= &state->internal;\n\tstruct stb0899_config *config\t\t= state->config;\n\n\tu8 bclc, reg;\n\tu8 cfr[2];\n\tu8 eq_const[10];\n\ts32 clnI = 3;\n\tu32 bandwidth = 0;\n\n\t \n\ts32 betaTab[5][4] = {\n\t        \n\t\t{ 37,  34,  32,  31 },  \n\t\t{ 37,  35,  33,  31 },  \n\t\t{ 37,  35,  33,  31 },  \n\t\t{ 37,  36,  33,\t 32 },  \n\t\t{ 37,  36,  33,\t 32 }   \n\t};\n\n\tinternal->direction = 1;\n\n\tstb0899_set_srate(state, internal->master_clk, params->srate);\n\t \n\tif (params->srate <= 5000000) {\n\t\tstb0899_write_reg(state, STB0899_ACLC, 0x89);\n\t\tbclc = stb0899_read_reg(state, STB0899_BCLC);\n\t\tSTB0899_SETFIELD_VAL(BETA, bclc, 0x1c);\n\t\tstb0899_write_reg(state, STB0899_BCLC, bclc);\n\t\tclnI = 0;\n\t} else if (params->srate <= 15000000) {\n\t\tstb0899_write_reg(state, STB0899_ACLC, 0xc9);\n\t\tbclc = stb0899_read_reg(state, STB0899_BCLC);\n\t\tSTB0899_SETFIELD_VAL(BETA, bclc, 0x22);\n\t\tstb0899_write_reg(state, STB0899_BCLC, bclc);\n\t\tclnI = 1;\n\t} else if(params->srate <= 25000000) {\n\t\tstb0899_write_reg(state, STB0899_ACLC, 0x89);\n\t\tbclc = stb0899_read_reg(state, STB0899_BCLC);\n\t\tSTB0899_SETFIELD_VAL(BETA, bclc, 0x27);\n\t\tstb0899_write_reg(state, STB0899_BCLC, bclc);\n\t\tclnI = 2;\n\t} else {\n\t\tstb0899_write_reg(state, STB0899_ACLC, 0xc8);\n\t\tbclc = stb0899_read_reg(state, STB0899_BCLC);\n\t\tSTB0899_SETFIELD_VAL(BETA, bclc, 0x29);\n\t\tstb0899_write_reg(state, STB0899_BCLC, bclc);\n\t\tclnI = 3;\n\t}\n\n\tdprintk(state->verbose, FE_DEBUG, 1, \"Set the timing loop to acquisition\");\n\t \n\tstb0899_write_reg(state, STB0899_RTC, 0x46);\n\tstb0899_write_reg(state, STB0899_CFD, 0xee);\n\n\t \n\tdprintk(state->verbose, FE_DEBUG, 1, \"Derot Percent=%d Srate=%d mclk=%d\",\n\t\tinternal->derot_percent, params->srate, internal->mclk);\n\n\t \n\tinternal->derot_step = internal->derot_percent * (params->srate / 1000L) / internal->mclk;  \n\tinternal->t_derot = stb0899_calc_derot_time(params->srate);\n\tinternal->t_data = 500;\n\n\tdprintk(state->verbose, FE_DEBUG, 1, \"RESET stream merger\");\n\t \n\treg = stb0899_read_reg(state, STB0899_TSTRES);\n\tSTB0899_SETFIELD_VAL(FRESRS, reg, 1);\n\tstb0899_write_reg(state, STB0899_TSTRES, reg);\n\n\t \n\treg = stb0899_read_reg(state, STB0899_DEMAPVIT);\n\tSTB0899_SETFIELD_VAL(DEMAPVIT_KDIVIDER, reg, 60);\n\tstb0899_write_reg(state, STB0899_DEMAPVIT, reg);\n\n\tstb0899_write_reg(state, STB0899_EQON, 0x01);  \n\tstb0899_write_reg(state, STB0899_VITSYNC, 0x19);\n\n\tstb0899_first_subrange(state);\n\tdo {\n\t\t \n\t\tcfr[0] = cfr[1] = 0;\n\t\tstb0899_write_regs(state, STB0899_CFRM, cfr, 2);  \n\n\t\tstb0899_write_reg(state, STB0899_RTF, 0);\n\t\treg = stb0899_read_reg(state, STB0899_CFD);\n\t\tSTB0899_SETFIELD_VAL(CFD_ON, reg, 1);\n\t\tstb0899_write_reg(state, STB0899_CFD, reg);\n\n\t\tinternal->derot_freq = 0;\n\t\tinternal->status = NOAGC1;\n\n\t\t \n\t\tstb0899_i2c_gate_ctrl(&state->frontend, 1);\n\n\t\t \n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Tuner set frequency\");\n\t\tif (state->config->tuner_set_frequency)\n\t\t\tstate->config->tuner_set_frequency(&state->frontend, internal->freq);\n\n\t\tif (state->config->tuner_get_frequency)\n\t\t\tstate->config->tuner_get_frequency(&state->frontend, &internal->freq);\n\n\t\tmsleep(internal->t_agc1 + internal->t_agc2 + internal->t_derot);  \n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"current derot freq=%d\", internal->derot_freq);\n\t\tinternal->status = AGC1OK;\n\n\t\t \n\t\tif (config->tuner_get_bandwidth)\n\t\t\tconfig->tuner_get_bandwidth(&state->frontend, &bandwidth);\n\n\t\t \n\t\tstb0899_i2c_gate_ctrl(&state->frontend, 0);\n\n\t\tif (params->srate <= bandwidth / 2)\n\t\t\tstb0899_search_tmg(state);  \n\t\telse\n\t\t\tstb0899_check_tmg(state);  \n\n\t\tif (internal->status == TIMINGOK) {\n\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n\t\t\t\t\"TIMING OK ! Derot freq=%d, mclk=%d\",\n\t\t\t\tinternal->derot_freq, internal->mclk);\n\n\t\t\tif (stb0899_search_carrier(state) == CARRIEROK) {\t \n\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n\t\t\t\t\t\"CARRIER OK ! Derot freq=%d, mclk=%d\",\n\t\t\t\t\tinternal->derot_freq, internal->mclk);\n\n\t\t\t\tif (stb0899_search_data(state) == DATAOK) {\t \n\t\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n\t\t\t\t\t\t\"DATA OK ! Derot freq=%d, mclk=%d\",\n\t\t\t\t\t\tinternal->derot_freq, internal->mclk);\n\n\t\t\t\t\tif (stb0899_check_range(state) == RANGEOK) {\n\t\t\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n\t\t\t\t\t\t\t\"RANGE OK ! derot freq=%d, mclk=%d\",\n\t\t\t\t\t\t\tinternal->derot_freq, internal->mclk);\n\n\t\t\t\t\t\tinternal->freq = params->freq - ((internal->derot_freq * internal->mclk) / 1000);\n\t\t\t\t\t\treg = stb0899_read_reg(state, STB0899_PLPARM);\n\t\t\t\t\t\tinternal->fecrate = STB0899_GETFIELD(VITCURPUN, reg);\n\t\t\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n\t\t\t\t\t\t\t\"freq=%d, internal resultant freq=%d\",\n\t\t\t\t\t\t\tparams->freq, internal->freq);\n\n\t\t\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n\t\t\t\t\t\t\t\"internal puncture rate=%d\",\n\t\t\t\t\t\t\tinternal->fecrate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (internal->status != RANGEOK)\n\t\t\tnext_sub_range(state);\n\n\t} while (internal->sub_range && internal->status != RANGEOK);\n\n\t \n\tstb0899_write_reg(state, STB0899_RTC, 0x33);\n\tstb0899_write_reg(state, STB0899_CFD, 0xf7);\n\t \n\tif (internal->status == RANGEOK) {\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Locked & Range OK !\");\n\t\tstb0899_write_reg(state, STB0899_EQON, 0x41);\t\t \n\t\tstb0899_write_reg(state, STB0899_VITSYNC, 0x39);\t \n\n\t\t \n\t\treg = stb0899_read_reg(state, STB0899_BCLC);\n\t\tswitch (internal->fecrate) {\n\t\tcase STB0899_FEC_1_2:\t\t \n\t\t\tstb0899_write_reg(state, STB0899_DEMAPVIT, 0x1a);\n\t\t\tSTB0899_SETFIELD_VAL(BETA, reg, betaTab[0][clnI]);\n\t\t\tstb0899_write_reg(state, STB0899_BCLC, reg);\n\t\t\tbreak;\n\t\tcase STB0899_FEC_2_3:\t\t \n\t\t\tstb0899_write_reg(state, STB0899_DEMAPVIT, 44);\n\t\t\tSTB0899_SETFIELD_VAL(BETA, reg, betaTab[1][clnI]);\n\t\t\tstb0899_write_reg(state, STB0899_BCLC, reg);\n\t\t\tbreak;\n\t\tcase STB0899_FEC_3_4:\t\t \n\t\t\tstb0899_write_reg(state, STB0899_DEMAPVIT, 60);\n\t\t\tSTB0899_SETFIELD_VAL(BETA, reg, betaTab[2][clnI]);\n\t\t\tstb0899_write_reg(state, STB0899_BCLC, reg);\n\t\t\tbreak;\n\t\tcase STB0899_FEC_5_6:\t\t \n\t\t\tstb0899_write_reg(state, STB0899_DEMAPVIT, 75);\n\t\t\tSTB0899_SETFIELD_VAL(BETA, reg, betaTab[3][clnI]);\n\t\t\tstb0899_write_reg(state, STB0899_BCLC, reg);\n\t\t\tbreak;\n\t\tcase STB0899_FEC_6_7:\t\t \n\t\t\tstb0899_write_reg(state, STB0899_DEMAPVIT, 88);\n\t\t\tstb0899_write_reg(state, STB0899_ACLC, 0x88);\n\t\t\tstb0899_write_reg(state, STB0899_BCLC, 0x9a);\n\t\t\tbreak;\n\t\tcase STB0899_FEC_7_8:\t\t \n\t\t\tstb0899_write_reg(state, STB0899_DEMAPVIT, 94);\n\t\t\tSTB0899_SETFIELD_VAL(BETA, reg, betaTab[4][clnI]);\n\t\t\tstb0899_write_reg(state, STB0899_BCLC, reg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Unsupported Puncture Rate\");\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\treg = stb0899_read_reg(state, STB0899_TSTRES);\n\t\tSTB0899_SETFIELD_VAL(FRESRS, reg, 0);\n\t\tstb0899_write_reg(state, STB0899_TSTRES, reg);\n\n\t\t \n\t\treg = stb0899_read_reg(state, STB0899_CFD);\n\t\tSTB0899_SETFIELD_VAL(CFD_ON, reg, 0);\n\t\tstb0899_write_reg(state, STB0899_CFD, reg);\n\n\t\tstb0899_read_regs(state, STB0899_EQUAI1, eq_const, 10);\n\t}\n\n\treturn internal->status;\n}\n\n \nstatic void stb0899_dvbs2_config_uwp(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tstruct stb0899_config *config = state->config;\n\tu32 uwp1, uwp2, uwp3, reg;\n\n\tuwp1 = STB0899_READ_S2REG(STB0899_S2DEMOD, UWP_CNTRL1);\n\tuwp2 = STB0899_READ_S2REG(STB0899_S2DEMOD, UWP_CNTRL2);\n\tuwp3 = STB0899_READ_S2REG(STB0899_S2DEMOD, UWP_CNTRL3);\n\n\tSTB0899_SETFIELD_VAL(UWP_ESN0_AVE, uwp1, config->esno_ave);\n\tSTB0899_SETFIELD_VAL(UWP_ESN0_QUANT, uwp1, config->esno_quant);\n\tSTB0899_SETFIELD_VAL(UWP_TH_SOF, uwp1, config->uwp_threshold_sof);\n\n\tSTB0899_SETFIELD_VAL(FE_COARSE_TRK, uwp2, internal->av_frame_coarse);\n\tSTB0899_SETFIELD_VAL(FE_FINE_TRK, uwp2, internal->av_frame_fine);\n\tSTB0899_SETFIELD_VAL(UWP_MISS_TH, uwp2, config->miss_threshold);\n\n\tSTB0899_SETFIELD_VAL(UWP_TH_ACQ, uwp3, config->uwp_threshold_acq);\n\tSTB0899_SETFIELD_VAL(UWP_TH_TRACK, uwp3, config->uwp_threshold_track);\n\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_UWP_CNTRL1, STB0899_OFF0_UWP_CNTRL1, uwp1);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_UWP_CNTRL2, STB0899_OFF0_UWP_CNTRL2, uwp2);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_UWP_CNTRL3, STB0899_OFF0_UWP_CNTRL3, uwp3);\n\n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, SOF_SRCH_TO);\n\tSTB0899_SETFIELD_VAL(SOF_SEARCH_TIMEOUT, reg, config->sof_search_timeout);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_SOF_SRCH_TO, STB0899_OFF0_SOF_SRCH_TO, reg);\n}\n\n \nstatic void stb0899_dvbs2_config_csm_auto(struct stb0899_state *state)\n{\n\tu32 reg;\n\n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, CSM_CNTRL1);\n\tSTB0899_SETFIELD_VAL(CSM_AUTO_PARAM, reg, 1);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CSM_CNTRL1, STB0899_OFF0_CSM_CNTRL1, reg);\n}\n\nstatic long Log2Int(int number)\n{\n\tint i;\n\n\ti = 0;\n\twhile ((1 << i) <= abs(number))\n\t\ti++;\n\n\tif (number == 0)\n\t\ti = 1;\n\n\treturn i - 1;\n}\n\n \nstatic u32 stb0899_dvbs2_calc_srate(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal\t= &state->internal;\n\tstruct stb0899_config *config\t\t= state->config;\n\n\tu32 dec_ratio, dec_rate, decim, remain, intval, btr_nom_freq;\n\tu32 master_clk, srate;\n\n\tdec_ratio = (internal->master_clk * 2) / (5 * internal->srate);\n\tdec_ratio = (dec_ratio == 0) ? 1 : dec_ratio;\n\tdec_rate = Log2Int(dec_ratio);\n\tdecim = 1 << dec_rate;\n\tmaster_clk = internal->master_clk / 1000;\n\tsrate = internal->srate / 1000;\n\n\tif (decim <= 4) {\n\t\tintval = (decim * (1 << (config->btr_nco_bits - 1))) / master_clk;\n\t\tremain = (decim * (1 << (config->btr_nco_bits - 1))) % master_clk;\n\t} else {\n\t\tintval = (1 << (config->btr_nco_bits - 1)) / (master_clk / 100) * decim / 100;\n\t\tremain = (decim * (1 << (config->btr_nco_bits - 1))) % master_clk;\n\t}\n\tbtr_nom_freq = (intval * srate) + ((remain * srate) / master_clk);\n\n\treturn btr_nom_freq;\n}\n\n \nstatic u32 stb0899_dvbs2_calc_dev(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tu32 dec_ratio, correction, master_clk, srate;\n\n\tdec_ratio = (internal->master_clk * 2) / (5 * internal->srate);\n\tdec_ratio = (dec_ratio == 0) ? 1 : dec_ratio;\n\n\tmaster_clk = internal->master_clk / 1000;\t \n\tsrate = internal->srate / 1000;\t \n\tcorrection = (512 * master_clk) / (2 * dec_ratio * srate);\n\n\treturn\tcorrection;\n}\n\n \nstatic void stb0899_dvbs2_set_srate(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\n\tu32 dec_ratio, dec_rate, win_sel, decim, f_sym, btr_nom_freq;\n\tu32 correction, freq_adj, band_lim, decim_cntrl, reg;\n\tu8 anti_alias;\n\n\t \n\tdec_ratio = (internal->master_clk * 2) / (5 * internal->srate);\n\tdec_ratio = (dec_ratio == 0) ? 1 : dec_ratio;\n\tdec_rate = Log2Int(dec_ratio);\n\n\twin_sel = 0;\n\tif (dec_rate >= 5)\n\t\twin_sel = dec_rate - 4;\n\n\tdecim = (1 << dec_rate);\n\t \n\tf_sym = internal->master_clk / ((decim * internal->srate) / 1000);\n\n\tif (f_sym <= 2250)\t \n\t\tband_lim = 1;\n\telse\n\t\tband_lim = 0;\t \n\n\tdecim_cntrl = ((win_sel << 3) & 0x18) + ((band_lim << 5) & 0x20) + (dec_rate & 0x7);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_DECIM_CNTRL, STB0899_OFF0_DECIM_CNTRL, decim_cntrl);\n\n\tif (f_sym <= 3450)\n\t\tanti_alias = 0;\n\telse if (f_sym <= 4250)\n\t\tanti_alias = 1;\n\telse\n\t\tanti_alias = 2;\n\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_ANTI_ALIAS_SEL, STB0899_OFF0_ANTI_ALIAS_SEL, anti_alias);\n\tbtr_nom_freq = stb0899_dvbs2_calc_srate(state);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_BTR_NOM_FREQ, STB0899_OFF0_BTR_NOM_FREQ, btr_nom_freq);\n\n\tcorrection = stb0899_dvbs2_calc_dev(state);\n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, BTR_CNTRL);\n\tSTB0899_SETFIELD_VAL(BTR_FREQ_CORR, reg, correction);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_BTR_CNTRL, STB0899_OFF0_BTR_CNTRL, reg);\n\n\t \n\tfreq_adj =  internal->srate / (internal->master_clk / 4096);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_FREQ_ADJ_SCALE, STB0899_OFF0_FREQ_ADJ_SCALE, freq_adj);\n}\n\n \nstatic void stb0899_dvbs2_set_btr_loopbw(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal\t= &state->internal;\n\tstruct stb0899_config *config\t\t= state->config;\n\n\tu32 sym_peak = 23, zeta = 707, loopbw_percent = 60;\n\ts32 dec_ratio, dec_rate, k_btr1_rshft, k_btr1, k_btr0_rshft;\n\ts32 k_btr0, k_btr2_rshft, k_direct_shift, k_indirect_shift;\n\tu32 decim, K, wn, k_direct, k_indirect;\n\tu32 reg;\n\n\tdec_ratio = (internal->master_clk * 2) / (5 * internal->srate);\n\tdec_ratio = (dec_ratio == 0) ? 1 : dec_ratio;\n\tdec_rate = Log2Int(dec_ratio);\n\tdecim = (1 << dec_rate);\n\n\tsym_peak *= 576000;\n\tK = (1 << config->btr_nco_bits) / (internal->master_clk / 1000);\n\tK *= (internal->srate / 1000000) * decim;  \n\n\tif (K != 0) {\n\t\tK = sym_peak / K;\n\t\twn = (4 * zeta * zeta) + 1000000;\n\t\twn = (2 * (loopbw_percent * 1000) * 40 * zeta) /wn;   \n\n\t\tk_indirect = (wn * wn) / K;\t \n\t\tk_direct   = (2 * wn * zeta) / K;\t \n\t\tk_direct  *= 100;\n\n\t\tk_direct_shift = Log2Int(k_direct) - Log2Int(10000) - 2;\n\t\tk_btr1_rshft = (-1 * k_direct_shift) + config->btr_gain_shift_offset;\n\t\tk_btr1 = k_direct / (1 << k_direct_shift);\n\t\tk_btr1 /= 10000;\n\n\t\tk_indirect_shift = Log2Int(k_indirect + 15) - 20  ;\n\t\tk_btr0_rshft = (-1 * k_indirect_shift) + config->btr_gain_shift_offset;\n\t\tk_btr0 = k_indirect * (1 << (-k_indirect_shift));\n\t\tk_btr0 /= 1000000;\n\n\t\tk_btr2_rshft = 0;\n\t\tif (k_btr0_rshft > 15) {\n\t\t\tk_btr2_rshft = k_btr0_rshft - 15;\n\t\t\tk_btr0_rshft = 15;\n\t\t}\n\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, BTR_LOOP_GAIN);\n\t\tSTB0899_SETFIELD_VAL(KBTR0_RSHFT, reg, k_btr0_rshft);\n\t\tSTB0899_SETFIELD_VAL(KBTR0, reg, k_btr0);\n\t\tSTB0899_SETFIELD_VAL(KBTR1_RSHFT, reg, k_btr1_rshft);\n\t\tSTB0899_SETFIELD_VAL(KBTR1, reg, k_btr1);\n\t\tSTB0899_SETFIELD_VAL(KBTR2_RSHFT, reg, k_btr2_rshft);\n\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_BTR_LOOP_GAIN, STB0899_OFF0_BTR_LOOP_GAIN, reg);\n\t} else\n\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_BTR_LOOP_GAIN, STB0899_OFF0_BTR_LOOP_GAIN, 0xc4c4f);\n}\n\n \nstatic void stb0899_dvbs2_set_carr_freq(struct stb0899_state *state, s32 carr_freq, u32 master_clk)\n{\n\tstruct stb0899_config *config = state->config;\n\ts32 crl_nom_freq;\n\tu32 reg;\n\n\tcrl_nom_freq = (1 << config->crl_nco_bits) / master_clk;\n\tcrl_nom_freq *= carr_freq;\n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, CRL_NOM_FREQ);\n\tSTB0899_SETFIELD_VAL(CRL_NOM_FREQ, reg, crl_nom_freq);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CRL_NOM_FREQ, STB0899_OFF0_CRL_NOM_FREQ, reg);\n}\n\n \nstatic void stb0899_dvbs2_init_calc(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\ts32 steps, step_size;\n\tu32 range, reg;\n\n\t \n\tstb0899_dvbs2_config_uwp(state);\n\tstb0899_dvbs2_config_csm_auto(state);\n\n\t \n\tstb0899_dvbs2_set_srate(state);\n\tstb0899_dvbs2_set_btr_loopbw(state);\n\n\tif (internal->srate / 1000000 >= 15)\n\t\tstep_size = (1 << 17) / 5;\n\telse if (internal->srate / 1000000 >= 10)\n\t\tstep_size = (1 << 17) / 7;\n\telse if (internal->srate / 1000000 >= 5)\n\t\tstep_size = (1 << 17) / 10;\n\telse\n\t\tstep_size = (1 << 17) / 4;\n\n\trange = internal->srch_range / 1000000;\n\tsteps = (10 * range * (1 << 17)) / (step_size * (internal->srate / 1000000));\n\tsteps = (steps + 6) / 10;\n\tsteps = (steps == 0) ? 1 : steps;\n\tif (steps % 2 == 0)\n\t\tstb0899_dvbs2_set_carr_freq(state, internal->center_freq -\n\t\t\t\t\t   (internal->step_size * (internal->srate / 20000000)),\n\t\t\t\t\t   (internal->master_clk) / 1000000);\n\telse\n\t\tstb0899_dvbs2_set_carr_freq(state, internal->center_freq, (internal->master_clk) / 1000000);\n\n\t \n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, ACQ_CNTRL2);\n\tSTB0899_SETFIELD_VAL(ZIGZAG, reg, 1);\n\tSTB0899_SETFIELD_VAL(NUM_STEPS, reg, steps);\n\tSTB0899_SETFIELD_VAL(FREQ_STEPSIZE, reg, step_size);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_ACQ_CNTRL2, STB0899_OFF0_ACQ_CNTRL2, reg);\n}\n\n \nstatic void stb0899_dvbs2_btr_init(struct stb0899_state *state)\n{\n\tu32 reg;\n\n\t \n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, BTR_CNTRL);\n\tSTB0899_SETFIELD_VAL(INTRP_PHS_SENSE, reg, 1);\n\tSTB0899_SETFIELD_VAL(BTR_ERR_ENA, reg, 1);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_BTR_CNTRL, STB0899_OFF0_BTR_CNTRL, reg);\n\n\t \n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_BTR_FREQ_INIT, STB0899_OFF0_BTR_FREQ_INIT, 0x10000000);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_BTR_FREQ_INIT, STB0899_OFF0_BTR_FREQ_INIT, 0x00000000);\n\n\t \n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_BTR_PHS_INIT, STB0899_OFF0_BTR_PHS_INIT, 0x10000000);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_BTR_PHS_INIT, STB0899_OFF0_BTR_PHS_INIT, 0x00000000);\n}\n\n \nstatic void stb0899_dvbs2_reacquire(struct stb0899_state *state)\n{\n\tu32 reg = 0;\n\n\t \n\tSTB0899_SETFIELD_VAL(DVBS2_RESET, reg, 1);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_RESET_CNTRL, STB0899_OFF0_RESET_CNTRL, reg);\n\n\t \n\tstb0899_dvbs2_btr_init(state);\n\n\t \n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CRL_FREQ_INIT, STB0899_OFF0_CRL_FREQ_INIT, (1 << 30));\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CRL_FREQ_INIT, STB0899_OFF0_CRL_FREQ_INIT, 0);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CRL_LOOP_GAIN, STB0899_OFF0_CRL_LOOP_GAIN, 0);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CRL_PHS_INIT, STB0899_OFF0_CRL_PHS_INIT, (1 << 30));\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CRL_PHS_INIT, STB0899_OFF0_CRL_PHS_INIT, 0);\n\n\t \n\treg = 0;\n\tSTB0899_SETFIELD_VAL(DVBS2_RESET, reg, 0);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_RESET_CNTRL, STB0899_OFF0_RESET_CNTRL, reg);\n\n\t \n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_ACQUIRE_TRIG, STB0899_OFF0_ACQUIRE_TRIG, 1);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_LOCK_LOST, STB0899_OFF0_LOCK_LOST, 0);\n\n\t \n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_EQUALIZER_INIT, STB0899_OFF0_EQUALIZER_INIT, 1);\n\n\t \n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_EQUALIZER_INIT, STB0899_OFF0_EQUALIZER_INIT, 0);\n\n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, EQ_CNTRL);\n\tSTB0899_SETFIELD_VAL(EQ_SHIFT, reg, 0);\n\tSTB0899_SETFIELD_VAL(EQ_DISABLE_UPDATE, reg, 0);\n\tSTB0899_SETFIELD_VAL(EQ_DELAY, reg, 0x05);\n\tSTB0899_SETFIELD_VAL(EQ_ADAPT_MODE, reg, 0x01);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_EQ_CNTRL, STB0899_OFF0_EQ_CNTRL, reg);\n\n\t \n\tstb0899_write_reg(state, STB0899_PDELCTRL, 0x4a);\n}\n\n \nstatic enum stb0899_status stb0899_dvbs2_get_dmd_status(struct stb0899_state *state, int timeout)\n{\n\tint time = -10, lock = 0, uwp, csm;\n\tu32 reg;\n\n\tdo {\n\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, DMD_STATUS);\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"DMD_STATUS=[0x%02x]\", reg);\n\t\tif (STB0899_GETFIELD(IF_AGC_LOCK, reg))\n\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"------------->IF AGC LOCKED !\");\n\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, DMD_STAT2);\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"----------->DMD STAT2=[0x%02x]\", reg);\n\t\tuwp = STB0899_GETFIELD(UWP_LOCK, reg);\n\t\tcsm = STB0899_GETFIELD(CSM_LOCK, reg);\n\t\tif (uwp && csm)\n\t\t\tlock = 1;\n\n\t\ttime += 10;\n\t\tmsleep(10);\n\n\t} while ((!lock) && (time <= timeout));\n\n\tif (lock) {\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"----------------> DVB-S2 LOCK !\");\n\t\treturn DVBS2_DEMOD_LOCK;\n\t} else {\n\t\treturn DVBS2_DEMOD_NOLOCK;\n\t}\n}\n\n \nstatic int stb0899_dvbs2_get_data_lock(struct stb0899_state *state, int timeout)\n{\n\tint time = 0, lock = 0;\n\tu8 reg;\n\n\twhile ((!lock) && (time < timeout)) {\n\t\treg = stb0899_read_reg(state, STB0899_CFGPDELSTATUS1);\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"---------> CFGPDELSTATUS=[0x%02x]\", reg);\n\t\tlock = STB0899_GETFIELD(CFGPDELSTATUS_LOCK, reg);\n\t\ttime++;\n\t}\n\n\treturn lock;\n}\n\n \nstatic enum stb0899_status stb0899_dvbs2_get_fec_status(struct stb0899_state *state, int timeout)\n{\n\tint time = 0, Locked;\n\n\tdo {\n\t\tLocked = stb0899_dvbs2_get_data_lock(state, 1);\n\t\ttime++;\n\t\tmsleep(1);\n\n\t} while ((!Locked) && (time < timeout));\n\n\tif (Locked) {\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"---------->DVB-S2 FEC LOCK !\");\n\t\treturn DVBS2_FEC_LOCK;\n\t} else {\n\t\treturn DVBS2_FEC_NOLOCK;\n\t}\n}\n\n\n \nstatic void stb0899_dvbs2_init_csm(struct stb0899_state *state, int pilots, enum stb0899_modcod modcod)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\n\ts32 dvt_tbl = 1, two_pass = 0, agc_gain = 6, agc_shift = 0, loop_shift = 0, phs_diff_thr = 0x80;\n\ts32 gamma_acq, gamma_rho_acq, gamma_trk, gamma_rho_trk, lock_count_thr;\n\tu32 csm1, csm2, csm3, csm4;\n\n\tif (((internal->master_clk / internal->srate) <= 4) && (modcod <= 11) && (pilots == 1)) {\n\t\tswitch (modcod) {\n\t\tcase STB0899_QPSK_12:\n\t\t\tgamma_acq\t\t= 25;\n\t\t\tgamma_rho_acq\t\t= 2700;\n\t\t\tgamma_trk\t\t= 12;\n\t\t\tgamma_rho_trk\t\t= 180;\n\t\t\tlock_count_thr\t\t= 8;\n\t\t\tbreak;\n\t\tcase STB0899_QPSK_35:\n\t\t\tgamma_acq\t\t= 38;\n\t\t\tgamma_rho_acq\t\t= 7182;\n\t\t\tgamma_trk\t\t= 14;\n\t\t\tgamma_rho_trk\t\t= 308;\n\t\t\tlock_count_thr\t\t= 8;\n\t\t\tbreak;\n\t\tcase STB0899_QPSK_23:\n\t\t\tgamma_acq\t\t= 42;\n\t\t\tgamma_rho_acq\t\t= 9408;\n\t\t\tgamma_trk\t\t= 17;\n\t\t\tgamma_rho_trk\t\t= 476;\n\t\t\tlock_count_thr\t\t= 8;\n\t\t\tbreak;\n\t\tcase STB0899_QPSK_34:\n\t\t\tgamma_acq\t\t= 53;\n\t\t\tgamma_rho_acq\t\t= 16642;\n\t\t\tgamma_trk\t\t= 19;\n\t\t\tgamma_rho_trk\t\t= 646;\n\t\t\tlock_count_thr\t\t= 8;\n\t\t\tbreak;\n\t\tcase STB0899_QPSK_45:\n\t\t\tgamma_acq\t\t= 53;\n\t\t\tgamma_rho_acq\t\t= 17119;\n\t\t\tgamma_trk\t\t= 22;\n\t\t\tgamma_rho_trk\t\t= 880;\n\t\t\tlock_count_thr\t\t= 8;\n\t\t\tbreak;\n\t\tcase STB0899_QPSK_56:\n\t\t\tgamma_acq\t\t= 55;\n\t\t\tgamma_rho_acq\t\t= 19250;\n\t\t\tgamma_trk\t\t= 23;\n\t\t\tgamma_rho_trk\t\t= 989;\n\t\t\tlock_count_thr\t\t= 8;\n\t\t\tbreak;\n\t\tcase STB0899_QPSK_89:\n\t\t\tgamma_acq\t\t= 60;\n\t\t\tgamma_rho_acq\t\t= 24240;\n\t\t\tgamma_trk\t\t= 24;\n\t\t\tgamma_rho_trk\t\t= 1176;\n\t\t\tlock_count_thr\t\t= 8;\n\t\t\tbreak;\n\t\tcase STB0899_QPSK_910:\n\t\t\tgamma_acq\t\t= 66;\n\t\t\tgamma_rho_acq\t\t= 29634;\n\t\t\tgamma_trk\t\t= 24;\n\t\t\tgamma_rho_trk\t\t= 1176;\n\t\t\tlock_count_thr\t\t= 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgamma_acq\t\t= 66;\n\t\t\tgamma_rho_acq\t\t= 29634;\n\t\t\tgamma_trk\t\t= 24;\n\t\t\tgamma_rho_trk\t\t= 1176;\n\t\t\tlock_count_thr\t\t= 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tcsm1 = STB0899_READ_S2REG(STB0899_S2DEMOD, CSM_CNTRL1);\n\t\tSTB0899_SETFIELD_VAL(CSM_AUTO_PARAM, csm1, 0);\n\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CSM_CNTRL1, STB0899_OFF0_CSM_CNTRL1, csm1);\n\n\t\tcsm1 = STB0899_READ_S2REG(STB0899_S2DEMOD, CSM_CNTRL1);\n\t\tcsm2 = STB0899_READ_S2REG(STB0899_S2DEMOD, CSM_CNTRL2);\n\t\tcsm3 = STB0899_READ_S2REG(STB0899_S2DEMOD, CSM_CNTRL3);\n\t\tcsm4 = STB0899_READ_S2REG(STB0899_S2DEMOD, CSM_CNTRL4);\n\n\t\tSTB0899_SETFIELD_VAL(CSM_DVT_TABLE, csm1, dvt_tbl);\n\t\tSTB0899_SETFIELD_VAL(CSM_TWO_PASS, csm1, two_pass);\n\t\tSTB0899_SETFIELD_VAL(CSM_AGC_GAIN, csm1, agc_gain);\n\t\tSTB0899_SETFIELD_VAL(CSM_AGC_SHIFT, csm1, agc_shift);\n\t\tSTB0899_SETFIELD_VAL(FE_LOOP_SHIFT, csm1, loop_shift);\n\t\tSTB0899_SETFIELD_VAL(CSM_GAMMA_ACQ, csm2, gamma_acq);\n\t\tSTB0899_SETFIELD_VAL(CSM_GAMMA_RHOACQ, csm2, gamma_rho_acq);\n\t\tSTB0899_SETFIELD_VAL(CSM_GAMMA_TRACK, csm3, gamma_trk);\n\t\tSTB0899_SETFIELD_VAL(CSM_GAMMA_RHOTRACK, csm3, gamma_rho_trk);\n\t\tSTB0899_SETFIELD_VAL(CSM_LOCKCOUNT_THRESH, csm4, lock_count_thr);\n\t\tSTB0899_SETFIELD_VAL(CSM_PHASEDIFF_THRESH, csm4, phs_diff_thr);\n\n\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CSM_CNTRL1, STB0899_OFF0_CSM_CNTRL1, csm1);\n\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CSM_CNTRL2, STB0899_OFF0_CSM_CNTRL2, csm2);\n\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CSM_CNTRL3, STB0899_OFF0_CSM_CNTRL3, csm3);\n\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CSM_CNTRL4, STB0899_OFF0_CSM_CNTRL4, csm4);\n\t}\n}\n\n \nstatic u32 stb0899_dvbs2_get_srate(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tstruct stb0899_config *config = state->config;\n\n\tu32 bTrNomFreq, srate, decimRate, intval1, intval2, reg;\n\tint div1, div2, rem1, rem2;\n\n\tdiv1 = config->btr_nco_bits / 2;\n\tdiv2 = config->btr_nco_bits - div1 - 1;\n\n\tbTrNomFreq = STB0899_READ_S2REG(STB0899_S2DEMOD, BTR_NOM_FREQ);\n\n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, DECIM_CNTRL);\n\tdecimRate = STB0899_GETFIELD(DECIM_RATE, reg);\n\tdecimRate = (1 << decimRate);\n\n\tintval1 = internal->master_clk / (1 << div1);\n\tintval2 = bTrNomFreq / (1 << div2);\n\n\trem1 = internal->master_clk % (1 << div1);\n\trem2 = bTrNomFreq % (1 << div2);\n\t \n\tsrate = (intval1 * intval2) + ((intval1 * rem2) / (1 << div2)) + ((intval2 * rem1) / (1 << div1));\n\tsrate /= decimRate;\t \n\n\treturn\tsrate;\n}\n\n \nenum stb0899_status stb0899_dvbs2_algo(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tenum stb0899_modcod modcod;\n\n\ts32 offsetfreq, searchTime, FecLockTime, pilots, iqSpectrum;\n\tint i = 0;\n\tu32 reg, csm1;\n\n\tif (internal->srate <= 2000000) {\n\t\tsearchTime\t= 5000;\t \n\t\tFecLockTime\t= 350;\t \n\t} else if (internal->srate <= 5000000) {\n\t\tsearchTime\t= 2500;\t \n\t\tFecLockTime\t= 170;\t \n\t} else if (internal->srate <= 10000000) {\n\t\tsearchTime\t= 1500;\t \n\t\tFecLockTime\t= 80;\t \n\t} else if (internal->srate <= 15000000) {\n\t\tsearchTime\t= 500;\t \n\t\tFecLockTime\t= 50;\t \n\t} else if (internal->srate <= 20000000) {\n\t\tsearchTime\t= 300;\t \n\t\tFecLockTime\t= 30;\t \n\t} else if (internal->srate <= 25000000) {\n\t\tsearchTime\t= 250;\t \n\t\tFecLockTime\t= 25;\t \n\t} else {\n\t\tsearchTime\t= 150;\t \n\t\tFecLockTime\t= 20;\t \n\t}\n\n\t \n\treg = stb0899_read_reg(state, STB0899_TSTRES);\n\tSTB0899_SETFIELD_VAL(FRESRS, reg, 1);\n\tstb0899_write_reg(state, STB0899_TSTRES, reg);\n\n\t \n\tstb0899_i2c_gate_ctrl(&state->frontend, 1);\n\n\t \n\tif (state->config->tuner_set_frequency)\n\t\tstate->config->tuner_set_frequency(&state->frontend, internal->freq);\n\tif (state->config->tuner_get_frequency)\n\t\tstate->config->tuner_get_frequency(&state->frontend, &internal->freq);\n\n\t \n\tstb0899_i2c_gate_ctrl(&state->frontend, 0);\n\n\t \n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, IF_AGC_CNTRL);\n\tSTB0899_SETFIELD_VAL(IF_LOOP_GAIN, reg,  4);\n\tSTB0899_SETFIELD_VAL(IF_AGC_REF, reg, 32);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_IF_AGC_CNTRL, STB0899_OFF0_IF_AGC_CNTRL, reg);\n\n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, IF_AGC_CNTRL2);\n\tSTB0899_SETFIELD_VAL(IF_AGC_DUMP_PER, reg, 0);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_IF_AGC_CNTRL2, STB0899_OFF0_IF_AGC_CNTRL2, reg);\n\n\t \n\tstb0899_dvbs2_init_calc(state);\n\n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, DMD_CNTRL2);\n\tswitch (internal->inversion) {\n\tcase IQ_SWAP_OFF:\n\t\tSTB0899_SETFIELD_VAL(SPECTRUM_INVERT, reg, 0);\n\t\tbreak;\n\tcase IQ_SWAP_ON:\n\t\tSTB0899_SETFIELD_VAL(SPECTRUM_INVERT, reg, 1);\n\t\tbreak;\n\t}\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_DMD_CNTRL2, STB0899_OFF0_DMD_CNTRL2, reg);\n\tstb0899_dvbs2_reacquire(state);\n\n\t \n\tinternal->status = stb0899_dvbs2_get_dmd_status(state, searchTime);\n\n\tif (internal->status == DVBS2_DEMOD_LOCK) {\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"------------> DVB-S2 DEMOD LOCK !\");\n\t\ti = 0;\n\t\t \n\t\tinternal->status = stb0899_dvbs2_get_fec_status(state, FecLockTime);\n\n\t\t \n\t\twhile ((internal->status != DVBS2_FEC_LOCK) && (i < 3)) {\n\t\t\t \n\t\t\toffsetfreq = STB0899_READ_S2REG(STB0899_S2DEMOD, CRL_FREQ);\n\n\t\t\t \n\t\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, CRL_NOM_FREQ);\n\t\t\tSTB0899_SETFIELD_VAL(CRL_NOM_FREQ, reg, offsetfreq);\n\t\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CRL_NOM_FREQ, STB0899_OFF0_CRL_NOM_FREQ, reg);\n\t\t\tstb0899_dvbs2_reacquire(state);\n\t\t\tinternal->status = stb0899_dvbs2_get_fec_status(state, searchTime);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (internal->status != DVBS2_FEC_LOCK) {\n\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, DMD_CNTRL2);\n\t\tiqSpectrum = STB0899_GETFIELD(SPECTRUM_INVERT, reg);\n\t\t \n\t\tSTB0899_SETFIELD_VAL(SPECTRUM_INVERT, reg, !iqSpectrum);\n\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_DMD_CNTRL2, STB0899_OFF0_DMD_CNTRL2, reg);\n\t\t \n\t\tstb0899_dvbs2_reacquire(state);\n\n\t\t \n\t\tinternal->status = stb0899_dvbs2_get_dmd_status(state, searchTime);\n\t\tif (internal->status == DVBS2_DEMOD_LOCK) {\n\t\t\ti = 0;\n\t\t\t \n\t\t\tinternal->status = stb0899_dvbs2_get_fec_status(state, FecLockTime);\n\t\t\t \n\t\t\twhile ((internal->status != DVBS2_FEC_LOCK) && (i < 3)) {\n\t\t\t\t \n\t\t\t\toffsetfreq = STB0899_READ_S2REG(STB0899_S2DEMOD, CRL_FREQ);\n\n\t\t\t\t \n\t\t\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, CRL_NOM_FREQ);\n\t\t\t\tSTB0899_SETFIELD_VAL(CRL_NOM_FREQ, reg, offsetfreq);\n\t\t\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CRL_NOM_FREQ, STB0899_OFF0_CRL_NOM_FREQ, reg);\n\n\t\t\t\tstb0899_dvbs2_reacquire(state);\n\t\t\t\tinternal->status = stb0899_dvbs2_get_fec_status(state, searchTime);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n \n\t}\n\tif (internal->status == DVBS2_FEC_LOCK) {\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"----------------> DVB-S2 FEC Lock !\");\n\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, UWP_STAT2);\n\t\tmodcod = STB0899_GETFIELD(UWP_DECODE_MOD, reg) >> 2;\n\t\tpilots = STB0899_GETFIELD(UWP_DECODE_MOD, reg) & 0x01;\n\n\t\tif ((((10 * internal->master_clk) / (internal->srate / 10)) <= 410) &&\n\t\t      (INRANGE(STB0899_QPSK_23, modcod, STB0899_QPSK_910)) &&\n\t\t      (pilots == 1)) {\n\n\t\t\tstb0899_dvbs2_init_csm(state, pilots, modcod);\n\t\t\t \n\t\t\tinternal->status = stb0899_dvbs2_get_fec_status(state, FecLockTime);\n\n\t\t\ti = 0;\n\t\t\twhile ((internal->status != DVBS2_FEC_LOCK) && (i < 3)) {\n\t\t\t\tcsm1 = STB0899_READ_S2REG(STB0899_S2DEMOD, CSM_CNTRL1);\n\t\t\t\tSTB0899_SETFIELD_VAL(CSM_TWO_PASS, csm1, 1);\n\t\t\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CSM_CNTRL1, STB0899_OFF0_CSM_CNTRL1, csm1);\n\t\t\t\tcsm1 = STB0899_READ_S2REG(STB0899_S2DEMOD, CSM_CNTRL1);\n\t\t\t\tSTB0899_SETFIELD_VAL(CSM_TWO_PASS, csm1, 0);\n\t\t\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_CSM_CNTRL1, STB0899_OFF0_CSM_CNTRL1, csm1);\n\n\t\t\t\tinternal->status = stb0899_dvbs2_get_fec_status(state, FecLockTime);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif ((((10 * internal->master_clk) / (internal->srate / 10)) <= 410) &&\n\t\t      (INRANGE(STB0899_QPSK_12, modcod, STB0899_QPSK_35)) &&\n\t\t      (pilots == 1)) {\n\n\t\t\t \n\t\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, EQ_CNTRL);\n\t\t\tSTB0899_SETFIELD_VAL(EQ_DISABLE_UPDATE, reg, 1);\n\t\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_EQ_CNTRL, STB0899_OFF0_EQ_CNTRL, reg);\n\t\t}\n\n\t\t \n\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, EQ_CNTRL);\n\t\tSTB0899_SETFIELD_VAL(EQ_SHIFT, reg, 0x02);\n\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_EQ_CNTRL, STB0899_OFF0_EQ_CNTRL, reg);\n\n\t\t \n\t\toffsetfreq = STB0899_READ_S2REG(STB0899_S2DEMOD, CRL_FREQ);\n\n\t\toffsetfreq = sign_extend32(offsetfreq, 29);\n\n\t\toffsetfreq = offsetfreq / ((1 << 30) / 1000);\n\t\toffsetfreq *= (internal->master_clk / 1000000);\n\n\t\t \n\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, DMD_CNTRL2);\n\t\tif (STB0899_GETFIELD(SPECTRUM_INVERT, reg))\n\t\t\tinternal->inversion = IQ_SWAP_ON;\n\t\telse\n\t\t\tinternal->inversion = IQ_SWAP_OFF;\n\n\t\tinternal->freq = internal->freq + offsetfreq;\n\t\tinternal->srate = stb0899_dvbs2_get_srate(state);\n\n\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, UWP_STAT2);\n\t\tinternal->modcod = STB0899_GETFIELD(UWP_DECODE_MOD, reg) >> 2;\n\t\tinternal->pilots = STB0899_GETFIELD(UWP_DECODE_MOD, reg) & 0x01;\n\t\tinternal->frame_length = (STB0899_GETFIELD(UWP_DECODE_MOD, reg) >> 1) & 0x01;\n\n\t\t  \n\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, IF_AGC_CNTRL);\n\t\tSTB0899_SETFIELD_VAL(IF_LOOP_GAIN, reg,  3);\n\n\t\t \n\t\tif (INRANGE(STB0899_QPSK_12, internal->modcod, STB0899_QPSK_23))\n\t\t\tSTB0899_SETFIELD_VAL(IF_AGC_REF, reg, 16);\n\n\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_IF_AGC_CNTRL, STB0899_OFF0_IF_AGC_CNTRL, reg);\n\n\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, IF_AGC_CNTRL2);\n\t\tSTB0899_SETFIELD_VAL(IF_AGC_DUMP_PER, reg, 7);\n\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_IF_AGC_CNTRL2, STB0899_OFF0_IF_AGC_CNTRL2, reg);\n\t}\n\n\t \n\treg = stb0899_read_reg(state, STB0899_TSTRES);\n\tSTB0899_SETFIELD_VAL(FRESRS, reg, 0);\n\tstb0899_write_reg(state, STB0899_TSTRES, reg);\n\n\treturn internal->status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}