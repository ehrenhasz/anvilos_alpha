{
  "module_name": "drxd_hard.c",
  "hash_id": "4412866f187fe86b91c0ebe3ab7aea7ccac5bbcddbc685ab6163ce2d3eb1079f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/drxd_hard.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"drxd.h\"\n#include \"drxd_firm.h\"\n\n#define DRX_FW_FILENAME_A2 \"drxd-a2-1.1.fw\"\n#define DRX_FW_FILENAME_B1 \"drxd-b1-1.1.fw\"\n\n#define CHUNK_SIZE 48\n\n#define DRX_I2C_RMW           0x10\n#define DRX_I2C_BROADCAST     0x20\n#define DRX_I2C_CLEARCRC      0x80\n#define DRX_I2C_SINGLE_MASTER 0xC0\n#define DRX_I2C_MODEFLAGS     0xC0\n#define DRX_I2C_FLAGS         0xF0\n\n#define DEFAULT_LOCK_TIMEOUT    1100\n\n#define DRX_CHANNEL_AUTO 0\n#define DRX_CHANNEL_HIGH 1\n#define DRX_CHANNEL_LOW  2\n\n#define DRX_LOCK_MPEG  1\n#define DRX_LOCK_FEC   2\n#define DRX_LOCK_DEMOD 4\n\n \n\nenum CSCDState {\n\tCSCD_INIT = 0,\n\tCSCD_SET,\n\tCSCD_SAVED\n};\n\nenum CDrxdState {\n\tDRXD_UNINITIALIZED = 0,\n\tDRXD_STOPPED,\n\tDRXD_STARTED\n};\n\nenum AGC_CTRL_MODE {\n\tAGC_CTRL_AUTO = 0,\n\tAGC_CTRL_USER,\n\tAGC_CTRL_OFF\n};\n\nenum OperationMode {\n\tOM_Default,\n\tOM_DVBT_Diversity_Front,\n\tOM_DVBT_Diversity_End\n};\n\nstruct SCfgAgc {\n\tenum AGC_CTRL_MODE ctrlMode;\n\tu16 outputLevel;\t \n\tu16 settleLevel;\t \n\tu16 minOutputLevel;\t \n\tu16 maxOutputLevel;\t \n\tu16 speed;\t\t \n\n\tu16 R1;\n\tu16 R2;\n\tu16 R3;\n};\n\nstruct SNoiseCal {\n\tint cpOpt;\n\tshort cpNexpOfs;\n\tshort tdCal2k;\n\tshort tdCal8k;\n};\n\nenum app_env {\n\tAPPENV_STATIC = 0,\n\tAPPENV_PORTABLE = 1,\n\tAPPENV_MOBILE = 2\n};\n\nenum EIFFilter {\n\tIFFILTER_SAW = 0,\n\tIFFILTER_DISCRETE = 1\n};\n\nstruct drxd_state {\n\tstruct dvb_frontend frontend;\n\tstruct dvb_frontend_ops ops;\n\tstruct dtv_frontend_properties props;\n\n\tconst struct firmware *fw;\n\tstruct device *dev;\n\n\tstruct i2c_adapter *i2c;\n\tvoid *priv;\n\tstruct drxd_config config;\n\n\tint i2c_access;\n\tint init_done;\n\tstruct mutex mutex;\n\n\tu8 chip_adr;\n\tu16 hi_cfg_timing_div;\n\tu16 hi_cfg_bridge_delay;\n\tu16 hi_cfg_wakeup_key;\n\tu16 hi_cfg_ctrl;\n\n\tu16 intermediate_freq;\n\tu16 osc_clock_freq;\n\n\tenum CSCDState cscd_state;\n\tenum CDrxdState drxd_state;\n\n\tu16 sys_clock_freq;\n\ts16 osc_clock_deviation;\n\tu16 expected_sys_clock_freq;\n\n\tu16 insert_rs_byte;\n\tu16 enable_parallel;\n\n\tint operation_mode;\n\n\tstruct SCfgAgc if_agc_cfg;\n\tstruct SCfgAgc rf_agc_cfg;\n\n\tstruct SNoiseCal noise_cal;\n\n\tu32 fe_fs_add_incr;\n\tu32 org_fe_fs_add_incr;\n\tu16 current_fe_if_incr;\n\n\tu16 m_FeAgRegAgPwd;\n\tu16 m_FeAgRegAgAgcSio;\n\n\tu16 m_EcOcRegOcModeLop;\n\tu16 m_EcOcRegSncSncLvl;\n\tu8 *m_InitAtomicRead;\n\tu8 *m_HiI2cPatch;\n\n\tu8 *m_ResetCEFR;\n\tu8 *m_InitFE_1;\n\tu8 *m_InitFE_2;\n\tu8 *m_InitCP;\n\tu8 *m_InitCE;\n\tu8 *m_InitEQ;\n\tu8 *m_InitSC;\n\tu8 *m_InitEC;\n\tu8 *m_ResetECRAM;\n\tu8 *m_InitDiversityFront;\n\tu8 *m_InitDiversityEnd;\n\tu8 *m_DisableDiversity;\n\tu8 *m_StartDiversityFront;\n\tu8 *m_StartDiversityEnd;\n\n\tu8 *m_DiversityDelay8MHZ;\n\tu8 *m_DiversityDelay6MHZ;\n\n\tu8 *microcode;\n\tu32 microcode_length;\n\n\tint type_A;\n\tint PGA;\n\tint diversity;\n\tint tuner_mirrors;\n\n\tenum app_env app_env_default;\n\tenum app_env app_env_diversity;\n\n};\n\n \n \n \n\nstatic int i2c_write(struct i2c_adapter *adap, u8 adr, u8 * data, int len)\n{\n\tstruct i2c_msg msg = {.addr = adr, .flags = 0, .buf = data, .len = len };\n\n\tif (i2c_transfer(adap, &msg, 1) != 1)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int i2c_read(struct i2c_adapter *adap,\n\t\t    u8 adr, u8 *msg, int len, u8 *answ, int alen)\n{\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr = adr, .flags = 0,\n\t\t\t.buf = msg, .len = len\n\t\t}, {\n\t\t\t.addr = adr, .flags = I2C_M_RD,\n\t\t\t.buf = answ, .len = alen\n\t\t}\n\t};\n\tif (i2c_transfer(adap, msgs, 2) != 2)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic inline u32 MulDiv32(u32 a, u32 b, u32 c)\n{\n\tu64 tmp64;\n\n\ttmp64 = (u64)a * (u64)b;\n\tdo_div(tmp64, c);\n\n\treturn (u32) tmp64;\n}\n\nstatic int Read16(struct drxd_state *state, u32 reg, u16 *data, u8 flags)\n{\n\tu8 adr = state->config.demod_address;\n\tu8 mm1[4] = { reg & 0xff, (reg >> 16) & 0xff,\n\t\tflags | ((reg >> 24) & 0xff), (reg >> 8) & 0xff\n\t};\n\tu8 mm2[2];\n\tif (i2c_read(state->i2c, adr, mm1, 4, mm2, 2) < 0)\n\t\treturn -1;\n\tif (data)\n\t\t*data = mm2[0] | (mm2[1] << 8);\n\treturn mm2[0] | (mm2[1] << 8);\n}\n\nstatic int Read32(struct drxd_state *state, u32 reg, u32 *data, u8 flags)\n{\n\tu8 adr = state->config.demod_address;\n\tu8 mm1[4] = { reg & 0xff, (reg >> 16) & 0xff,\n\t\tflags | ((reg >> 24) & 0xff), (reg >> 8) & 0xff\n\t};\n\tu8 mm2[4];\n\n\tif (i2c_read(state->i2c, adr, mm1, 4, mm2, 4) < 0)\n\t\treturn -1;\n\tif (data)\n\t\t*data =\n\t\t    mm2[0] | (mm2[1] << 8) | (mm2[2] << 16) | (mm2[3] << 24);\n\treturn 0;\n}\n\nstatic int Write16(struct drxd_state *state, u32 reg, u16 data, u8 flags)\n{\n\tu8 adr = state->config.demod_address;\n\tu8 mm[6] = { reg & 0xff, (reg >> 16) & 0xff,\n\t\tflags | ((reg >> 24) & 0xff), (reg >> 8) & 0xff,\n\t\tdata & 0xff, (data >> 8) & 0xff\n\t};\n\n\tif (i2c_write(state->i2c, adr, mm, 6) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int Write32(struct drxd_state *state, u32 reg, u32 data, u8 flags)\n{\n\tu8 adr = state->config.demod_address;\n\tu8 mm[8] = { reg & 0xff, (reg >> 16) & 0xff,\n\t\tflags | ((reg >> 24) & 0xff), (reg >> 8) & 0xff,\n\t\tdata & 0xff, (data >> 8) & 0xff,\n\t\t(data >> 16) & 0xff, (data >> 24) & 0xff\n\t};\n\n\tif (i2c_write(state->i2c, adr, mm, 8) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int write_chunk(struct drxd_state *state,\n\t\t       u32 reg, u8 *data, u32 len, u8 flags)\n{\n\tu8 adr = state->config.demod_address;\n\tu8 mm[CHUNK_SIZE + 4] = { reg & 0xff, (reg >> 16) & 0xff,\n\t\tflags | ((reg >> 24) & 0xff), (reg >> 8) & 0xff\n\t};\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tmm[4 + i] = data[i];\n\tif (i2c_write(state->i2c, adr, mm, 4 + len) < 0) {\n\t\tprintk(KERN_ERR \"error in write_chunk\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int WriteBlock(struct drxd_state *state,\n\t\t      u32 Address, u16 BlockSize, u8 *pBlock, u8 Flags)\n{\n\twhile (BlockSize > 0) {\n\t\tu16 Chunk = BlockSize > CHUNK_SIZE ? CHUNK_SIZE : BlockSize;\n\n\t\tif (write_chunk(state, Address, pBlock, Chunk, Flags) < 0)\n\t\t\treturn -1;\n\t\tpBlock += Chunk;\n\t\tAddress += (Chunk >> 1);\n\t\tBlockSize -= Chunk;\n\t}\n\treturn 0;\n}\n\nstatic int WriteTable(struct drxd_state *state, u8 * pTable)\n{\n\tint status = 0;\n\n\tif (!pTable)\n\t\treturn 0;\n\n\twhile (!status) {\n\t\tu16 Length;\n\t\tu32 Address = pTable[0] | (pTable[1] << 8) |\n\t\t    (pTable[2] << 16) | (pTable[3] << 24);\n\n\t\tif (Address == 0xFFFFFFFF)\n\t\t\tbreak;\n\t\tpTable += sizeof(u32);\n\n\t\tLength = pTable[0] | (pTable[1] << 8);\n\t\tpTable += sizeof(u16);\n\t\tif (!Length)\n\t\t\tbreak;\n\t\tstatus = WriteBlock(state, Address, Length * 2, pTable, 0);\n\t\tpTable += (Length * 2);\n\t}\n\treturn status;\n}\n\n \n \n \n\nstatic int ResetCEFR(struct drxd_state *state)\n{\n\treturn WriteTable(state, state->m_ResetCEFR);\n}\n\nstatic int InitCP(struct drxd_state *state)\n{\n\treturn WriteTable(state, state->m_InitCP);\n}\n\nstatic int InitCE(struct drxd_state *state)\n{\n\tint status;\n\tenum app_env AppEnv = state->app_env_default;\n\n\tdo {\n\t\tstatus = WriteTable(state, state->m_InitCE);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tif (state->operation_mode == OM_DVBT_Diversity_Front ||\n\t\t    state->operation_mode == OM_DVBT_Diversity_End) {\n\t\t\tAppEnv = state->app_env_diversity;\n\t\t}\n\t\tif (AppEnv == APPENV_STATIC) {\n\t\t\tstatus = Write16(state, CE_REG_TAPSET__A, 0x0000, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else if (AppEnv == APPENV_PORTABLE) {\n\t\t\tstatus = Write16(state, CE_REG_TAPSET__A, 0x0001, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else if (AppEnv == APPENV_MOBILE && state->type_A) {\n\t\t\tstatus = Write16(state, CE_REG_TAPSET__A, 0x0002, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else if (AppEnv == APPENV_MOBILE && !state->type_A) {\n\t\t\tstatus = Write16(state, CE_REG_TAPSET__A, 0x0006, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tstatus = Write16(state, B_CE_REG_COMM_EXEC__A, 0x0001, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t} while (0);\n\treturn status;\n}\n\nstatic int StopOC(struct drxd_state *state)\n{\n\tint status = 0;\n\tu16 ocSyncLvl = 0;\n\tu16 ocModeLop = state->m_EcOcRegOcModeLop;\n\tu16 dtoIncLop = 0;\n\tu16 dtoIncHip = 0;\n\n\tdo {\n\t\t \n\t\tstatus = Read16(state, EC_OC_REG_SNC_ISC_LVL__A, &ocSyncLvl, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\t \n\t\tstate->m_EcOcRegSncSncLvl = ocSyncLvl;\n\t\t \n\n\t\t \n\t\tstatus = Read16(state, EC_OC_REG_RCN_MAP_LOP__A, &dtoIncLop, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Read16(state, EC_OC_REG_RCN_MAP_HIP__A, &dtoIncHip, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, EC_OC_REG_DTO_INC_LOP__A, dtoIncLop, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, EC_OC_REG_DTO_INC_HIP__A, dtoIncHip, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tocModeLop &= ~(EC_OC_REG_OC_MODE_LOP_DTO_CTR_SRC__M);\n\t\tocModeLop |= EC_OC_REG_OC_MODE_LOP_DTO_CTR_SRC_STATIC;\n\t\tstatus = Write16(state, EC_OC_REG_OC_MODE_LOP__A, ocModeLop, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, EC_OC_REG_COMM_EXEC__A, EC_OC_REG_COMM_EXEC_CTL_HOLD, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t\t \n\t\tstatus = Write16(state, EC_OC_REG_OCR_MPG_UOS__A, EC_OC_REG_OCR_MPG_UOS__M, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tocSyncLvl &= ~(EC_OC_REG_SNC_ISC_LVL_OSC__M);\n\t\tstatus = Write16(state, EC_OC_REG_SNC_ISC_LVL__A, ocSyncLvl, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tocModeLop &= ~(EC_OC_REG_OC_MODE_LOP_PAR_ENA__M);\n\t\tocModeLop |= EC_OC_REG_OC_MODE_LOP_PAR_ENA_ENABLE;\n\t\tocModeLop |= 0x2;\t \n\t\tstatus = Write16(state, EC_OC_REG_OC_MODE_LOP__A, ocModeLop, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, EC_OC_REG_COMM_INT_STA__A, 0x0, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, EC_OC_REG_COMM_EXEC__A, EC_OC_REG_COMM_EXEC_CTL_ACTIVE, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t} while (0);\n\n\treturn status;\n}\n\nstatic int StartOC(struct drxd_state *state)\n{\n\tint status = 0;\n\n\tdo {\n\t\t \n\t\tstatus = Write16(state, EC_OC_REG_COMM_EXEC__A, EC_OC_REG_COMM_EXEC_CTL_HOLD, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tstatus = Write16(state, EC_OC_REG_SNC_ISC_LVL__A, state->m_EcOcRegSncSncLvl, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, EC_OC_REG_OC_MODE_LOP__A, state->m_EcOcRegOcModeLop, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tstatus = Write16(state, EC_OC_REG_OCR_MPG_UOS__A, EC_OC_REG_OCR_MPG_UOS_INIT, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tstatus = Write16(state, EC_OC_REG_COMM_EXEC__A, EC_OC_REG_COMM_EXEC_CTL_ACTIVE, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t} while (0);\n\treturn status;\n}\n\nstatic int InitEQ(struct drxd_state *state)\n{\n\treturn WriteTable(state, state->m_InitEQ);\n}\n\nstatic int InitEC(struct drxd_state *state)\n{\n\treturn WriteTable(state, state->m_InitEC);\n}\n\nstatic int InitSC(struct drxd_state *state)\n{\n\treturn WriteTable(state, state->m_InitSC);\n}\n\nstatic int InitAtomicRead(struct drxd_state *state)\n{\n\treturn WriteTable(state, state->m_InitAtomicRead);\n}\n\nstatic int CorrectSysClockDeviation(struct drxd_state *state);\n\nstatic int DRX_GetLockStatus(struct drxd_state *state, u32 * pLockStatus)\n{\n\tu16 ScRaRamLock = 0;\n\tconst u16 mpeg_lock_mask = (SC_RA_RAM_LOCK_MPEG__M |\n\t\t\t\t    SC_RA_RAM_LOCK_FEC__M |\n\t\t\t\t    SC_RA_RAM_LOCK_DEMOD__M);\n\tconst u16 fec_lock_mask = (SC_RA_RAM_LOCK_FEC__M |\n\t\t\t\t   SC_RA_RAM_LOCK_DEMOD__M);\n\tconst u16 demod_lock_mask = SC_RA_RAM_LOCK_DEMOD__M;\n\n\tint status;\n\n\t*pLockStatus = 0;\n\n\tstatus = Read16(state, SC_RA_RAM_LOCK__A, &ScRaRamLock, 0x0000);\n\tif (status < 0) {\n\t\tprintk(KERN_ERR \"Can't read SC_RA_RAM_LOCK__A status = %08x\\n\", status);\n\t\treturn status;\n\t}\n\n\tif (state->drxd_state != DRXD_STARTED)\n\t\treturn 0;\n\n\tif ((ScRaRamLock & mpeg_lock_mask) == mpeg_lock_mask) {\n\t\t*pLockStatus |= DRX_LOCK_MPEG;\n\t\tCorrectSysClockDeviation(state);\n\t}\n\n\tif ((ScRaRamLock & fec_lock_mask) == fec_lock_mask)\n\t\t*pLockStatus |= DRX_LOCK_FEC;\n\n\tif ((ScRaRamLock & demod_lock_mask) == demod_lock_mask)\n\t\t*pLockStatus |= DRX_LOCK_DEMOD;\n\treturn 0;\n}\n\n \n\nstatic int SetCfgIfAgc(struct drxd_state *state, struct SCfgAgc *cfg)\n{\n\tint status;\n\n\tif (cfg->outputLevel > DRXD_FE_CTRL_MAX)\n\t\treturn -1;\n\n\tif (cfg->ctrlMode == AGC_CTRL_USER) {\n\t\tdo {\n\t\t\tu16 FeAgRegPm1AgcWri;\n\t\t\tu16 FeAgRegAgModeLop;\n\n\t\t\tstatus = Read16(state, FE_AG_REG_AG_MODE_LOP__A, &FeAgRegAgModeLop, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tFeAgRegAgModeLop &= (~FE_AG_REG_AG_MODE_LOP_MODE_4__M);\n\t\t\tFeAgRegAgModeLop |= FE_AG_REG_AG_MODE_LOP_MODE_4_STATIC;\n\t\t\tstatus = Write16(state, FE_AG_REG_AG_MODE_LOP__A, FeAgRegAgModeLop, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\tFeAgRegPm1AgcWri = (u16) (cfg->outputLevel &\n\t\t\t\t\t\t  FE_AG_REG_PM1_AGC_WRI__M);\n\t\t\tstatus = Write16(state, FE_AG_REG_PM1_AGC_WRI__A, FeAgRegPm1AgcWri, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} while (0);\n\t} else if (cfg->ctrlMode == AGC_CTRL_AUTO) {\n\t\tif (((cfg->maxOutputLevel) < (cfg->minOutputLevel)) ||\n\t\t    ((cfg->maxOutputLevel) > DRXD_FE_CTRL_MAX) ||\n\t\t    ((cfg->speed) > DRXD_FE_CTRL_MAX) ||\n\t\t    ((cfg->settleLevel) > DRXD_FE_CTRL_MAX)\n\t\t    )\n\t\t\treturn -1;\n\t\tdo {\n\t\t\tu16 FeAgRegAgModeLop;\n\t\t\tu16 FeAgRegEgcSetLvl;\n\t\t\tu16 slope, offset;\n\n\t\t\t \n\n\t\t\tstatus = Read16(state, FE_AG_REG_AG_MODE_LOP__A, &FeAgRegAgModeLop, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tFeAgRegAgModeLop &= (~FE_AG_REG_AG_MODE_LOP_MODE_4__M);\n\t\t\tFeAgRegAgModeLop |=\n\t\t\t    FE_AG_REG_AG_MODE_LOP_MODE_4_DYNAMIC;\n\t\t\tstatus = Write16(state, FE_AG_REG_AG_MODE_LOP__A, FeAgRegAgModeLop, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\n\t\t\tFeAgRegEgcSetLvl = (u16) ((cfg->settleLevel >> 1) &\n\t\t\t\t\t\t  FE_AG_REG_EGC_SET_LVL__M);\n\t\t\tstatus = Write16(state, FE_AG_REG_EGC_SET_LVL__A, FeAgRegEgcSetLvl, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\n\t\t\tslope = (u16) ((cfg->maxOutputLevel -\n\t\t\t\t\tcfg->minOutputLevel) / 2);\n\t\t\toffset = (u16) ((cfg->maxOutputLevel +\n\t\t\t\t\t cfg->minOutputLevel) / 2 - 511);\n\n\t\t\tstatus = Write16(state, FE_AG_REG_GC1_AGC_RIC__A, slope, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = Write16(state, FE_AG_REG_GC1_AGC_OFF__A, offset, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\t{\n\t\t\t\tconst u16 maxRur = 8;\n\t\t\t\tstatic const u16 slowIncrDecLUT[] = {\n\t\t\t\t\t3, 4, 4, 5, 6 };\n\t\t\t\tstatic const u16 fastIncrDecLUT[] = {\n\t\t\t\t\t14, 15, 15, 16,\n\t\t\t\t\t17, 18, 18, 19,\n\t\t\t\t\t20, 21, 22, 23,\n\t\t\t\t\t24, 26, 27, 28,\n\t\t\t\t\t29, 31\n\t\t\t\t};\n\n\t\t\t\tu16 fineSteps = (DRXD_FE_CTRL_MAX + 1) /\n\t\t\t\t    (maxRur + 1);\n\t\t\t\tu16 fineSpeed = (u16) (cfg->speed -\n\t\t\t\t\t\t       ((cfg->speed /\n\t\t\t\t\t\t\t fineSteps) *\n\t\t\t\t\t\t\tfineSteps));\n\t\t\t\tu16 invRurCount = (u16) (cfg->speed /\n\t\t\t\t\t\t\t fineSteps);\n\t\t\t\tu16 rurCount;\n\t\t\t\tif (invRurCount > maxRur) {\n\t\t\t\t\trurCount = 0;\n\t\t\t\t\tfineSpeed += fineSteps;\n\t\t\t\t} else {\n\t\t\t\t\trurCount = maxRur - invRurCount;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\t{\n\t\t\t\t\tu16 fastIncrDec =\n\t\t\t\t\t    fastIncrDecLUT[fineSpeed /\n\t\t\t\t\t\t\t   ((fineSteps /\n\t\t\t\t\t\t\t     (14 + 1)) + 1)];\n\t\t\t\t\tu16 slowIncrDec =\n\t\t\t\t\t    slowIncrDecLUT[fineSpeed /\n\t\t\t\t\t\t\t   (fineSteps /\n\t\t\t\t\t\t\t    (3 + 1))];\n\n\t\t\t\t\tstatus = Write16(state, FE_AG_REG_EGC_RUR_CNT__A, rurCount, 0);\n\t\t\t\t\tif (status < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tstatus = Write16(state, FE_AG_REG_EGC_FAS_INC__A, fastIncrDec, 0);\n\t\t\t\t\tif (status < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tstatus = Write16(state, FE_AG_REG_EGC_FAS_DEC__A, fastIncrDec, 0);\n\t\t\t\t\tif (status < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tstatus = Write16(state, FE_AG_REG_EGC_SLO_INC__A, slowIncrDec, 0);\n\t\t\t\t\tif (status < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tstatus = Write16(state, FE_AG_REG_EGC_SLO_DEC__A, slowIncrDec, 0);\n\t\t\t\t\tif (status < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (0);\n\n\t} else {\n\t\t \n\t\treturn -1;\n\t}\n\treturn status;\n}\n\nstatic int SetCfgRfAgc(struct drxd_state *state, struct SCfgAgc *cfg)\n{\n\tint status = 0;\n\n\tif (cfg->outputLevel > DRXD_FE_CTRL_MAX)\n\t\treturn -1;\n\n\tif (cfg->ctrlMode == AGC_CTRL_USER) {\n\t\tdo {\n\t\t\tu16 AgModeLop = 0;\n\t\t\tu16 level = (cfg->outputLevel);\n\n\t\t\tif (level == DRXD_FE_CTRL_MAX)\n\t\t\t\tlevel++;\n\n\t\t\tstatus = Write16(state, FE_AG_REG_PM2_AGC_WRI__A, level, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\n\t\t\t \n\t\t\tstate->m_FeAgRegAgPwd &= ~(FE_AG_REG_AG_PWD_PWD_PD2__M);\n\t\t\tstate->m_FeAgRegAgPwd |=\n\t\t\t    FE_AG_REG_AG_PWD_PWD_PD2_DISABLE;\n\t\t\tstatus = Write16(state, FE_AG_REG_AG_PWD__A, state->m_FeAgRegAgPwd, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\tstatus = Read16(state, FE_AG_REG_AG_MODE_LOP__A, &AgModeLop, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tAgModeLop &= (~(FE_AG_REG_AG_MODE_LOP_MODE_5__M |\n\t\t\t\t\tFE_AG_REG_AG_MODE_LOP_MODE_E__M));\n\t\t\tAgModeLop |= (FE_AG_REG_AG_MODE_LOP_MODE_5_STATIC |\n\t\t\t\t      FE_AG_REG_AG_MODE_LOP_MODE_E_STATIC);\n\t\t\tstatus = Write16(state, FE_AG_REG_AG_MODE_LOP__A, AgModeLop, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\t{\n\t\t\t\tu16 FeAgRegAgAgcSio = 0;\n\t\t\t\tstatus = Read16(state, FE_AG_REG_AG_AGC_SIO__A, &FeAgRegAgAgcSio, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tFeAgRegAgAgcSio &=\n\t\t\t\t    ~(FE_AG_REG_AG_AGC_SIO_AGC_SIO_2__M);\n\t\t\t\tFeAgRegAgAgcSio |=\n\t\t\t\t    FE_AG_REG_AG_AGC_SIO_AGC_SIO_2_OUTPUT;\n\t\t\t\tstatus = Write16(state, FE_AG_REG_AG_AGC_SIO__A, FeAgRegAgAgcSio, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} while (0);\n\t} else if (cfg->ctrlMode == AGC_CTRL_AUTO) {\n\t\tu16 AgModeLop = 0;\n\n\t\tdo {\n\t\t\tu16 level;\n\t\t\t \n\t\t\t \n\t\t\t(state->m_FeAgRegAgPwd) &=\n\t\t\t    ~(FE_AG_REG_AG_PWD_PWD_PD2__M);\n\t\t\t(state->m_FeAgRegAgPwd) |=\n\t\t\t    FE_AG_REG_AG_PWD_PWD_PD2_DISABLE;\n\t\t\tstatus = Write16(state, FE_AG_REG_AG_PWD__A, (state->m_FeAgRegAgPwd), 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\tstatus = Read16(state, FE_AG_REG_AG_MODE_LOP__A, &AgModeLop, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tAgModeLop &= (~(FE_AG_REG_AG_MODE_LOP_MODE_5__M |\n\t\t\t\t\tFE_AG_REG_AG_MODE_LOP_MODE_E__M));\n\t\t\tAgModeLop |= (FE_AG_REG_AG_MODE_LOP_MODE_5_STATIC |\n\t\t\t\t      FE_AG_REG_AG_MODE_LOP_MODE_E_DYNAMIC);\n\t\t\tstatus = Write16(state, FE_AG_REG_AG_MODE_LOP__A, AgModeLop, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tlevel = (((cfg->settleLevel) >> 4) &\n\t\t\t\t FE_AG_REG_TGC_SET_LVL__M);\n\t\t\tstatus = Write16(state, FE_AG_REG_TGC_SET_LVL__A, level, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\n\t\t\t \n\n\t\t\t \n\t\t\t{\n\t\t\t\tu16 FeAgRegAgAgcSio = 0;\n\t\t\t\tstatus = Read16(state, FE_AG_REG_AG_AGC_SIO__A, &FeAgRegAgAgcSio, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tFeAgRegAgAgcSio &=\n\t\t\t\t    ~(FE_AG_REG_AG_AGC_SIO_AGC_SIO_2__M);\n\t\t\t\tFeAgRegAgAgcSio |=\n\t\t\t\t    FE_AG_REG_AG_AGC_SIO_AGC_SIO_2_OUTPUT;\n\t\t\t\tstatus = Write16(state, FE_AG_REG_AG_AGC_SIO__A, FeAgRegAgAgcSio, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} while (0);\n\t} else {\n\t\tu16 AgModeLop = 0;\n\n\t\tdo {\n\t\t\t \n\t\t\t \n\t\t\t(state->m_FeAgRegAgPwd) &=\n\t\t\t    ~(FE_AG_REG_AG_PWD_PWD_PD2__M);\n\t\t\t(state->m_FeAgRegAgPwd) |=\n\t\t\t    FE_AG_REG_AG_PWD_PWD_PD2_ENABLE;\n\t\t\tstatus = Write16(state, FE_AG_REG_AG_PWD__A, (state->m_FeAgRegAgPwd), 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\tstatus = Read16(state, FE_AG_REG_AG_MODE_LOP__A, &AgModeLop, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tAgModeLop &= (~(FE_AG_REG_AG_MODE_LOP_MODE_5__M |\n\t\t\t\t\tFE_AG_REG_AG_MODE_LOP_MODE_E__M));\n\t\t\tAgModeLop |= (FE_AG_REG_AG_MODE_LOP_MODE_5_STATIC |\n\t\t\t\t      FE_AG_REG_AG_MODE_LOP_MODE_E_STATIC);\n\t\t\tstatus = Write16(state, FE_AG_REG_AG_MODE_LOP__A, AgModeLop, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\t{\n\t\t\t\tu16 FeAgRegAgAgcSio = 0;\n\t\t\t\tstatus = Read16(state, FE_AG_REG_AG_AGC_SIO__A, &FeAgRegAgAgcSio, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tFeAgRegAgAgcSio &=\n\t\t\t\t    ~(FE_AG_REG_AG_AGC_SIO_AGC_SIO_2__M);\n\t\t\t\tFeAgRegAgAgcSio |=\n\t\t\t\t    FE_AG_REG_AG_AGC_SIO_AGC_SIO_2_INPUT;\n\t\t\t\tstatus = Write16(state, FE_AG_REG_AG_AGC_SIO__A, FeAgRegAgAgcSio, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (0);\n\t}\n\treturn status;\n}\n\nstatic int ReadIFAgc(struct drxd_state *state, u32 * pValue)\n{\n\tint status = 0;\n\n\t*pValue = 0;\n\tif (state->if_agc_cfg.ctrlMode != AGC_CTRL_OFF) {\n\t\tu16 Value;\n\t\tstatus = Read16(state, FE_AG_REG_GC1_AGC_DAT__A, &Value, 0);\n\t\tValue &= FE_AG_REG_GC1_AGC_DAT__M;\n\t\tif (status >= 0) {\n\t\t\t \n\t\t\tu32 R1 = state->if_agc_cfg.R1;\n\t\t\tu32 R2 = state->if_agc_cfg.R2;\n\t\t\tu32 R3 = state->if_agc_cfg.R3;\n\n\t\t\tu32 Vmax, Rpar, Vmin, Vout;\n\n\t\t\tif (R2 == 0 && (R1 == 0 || R3 == 0))\n\t\t\t\treturn 0;\n\n\t\t\tVmax = (3300 * R2) / (R1 + R2);\n\t\t\tRpar = (R2 * R3) / (R3 + R2);\n\t\t\tVmin = (3300 * Rpar) / (R1 + Rpar);\n\t\t\tVout = Vmin + ((Vmax - Vmin) * Value) / 1024;\n\n\t\t\t*pValue = Vout;\n\t\t}\n\t}\n\treturn status;\n}\n\nstatic int load_firmware(struct drxd_state *state, const char *fw_name)\n{\n\tconst struct firmware *fw;\n\n\tif (request_firmware(&fw, fw_name, state->dev) < 0) {\n\t\tprintk(KERN_ERR \"drxd: firmware load failure [%s]\\n\", fw_name);\n\t\treturn -EIO;\n\t}\n\n\tstate->microcode = kmemdup(fw->data, fw->size, GFP_KERNEL);\n\tif (!state->microcode) {\n\t\trelease_firmware(fw);\n\t\treturn -ENOMEM;\n\t}\n\n\tstate->microcode_length = fw->size;\n\trelease_firmware(fw);\n\treturn 0;\n}\n\nstatic int DownloadMicrocode(struct drxd_state *state,\n\t\t\t     const u8 *pMCImage, u32 Length)\n{\n\tu8 *pSrc;\n\tu32 Address;\n\tu16 nBlocks;\n\tu16 BlockSize;\n\tint i, status = 0;\n\n\tpSrc = (u8 *) pMCImage;\n\t \n\t \n\tpSrc += sizeof(u16);\n\tnBlocks = (pSrc[0] << 8) | pSrc[1];\n\tpSrc += sizeof(u16);\n\n\tfor (i = 0; i < nBlocks; i++) {\n\t\tAddress = (pSrc[0] << 24) | (pSrc[1] << 16) |\n\t\t    (pSrc[2] << 8) | pSrc[3];\n\t\tpSrc += sizeof(u32);\n\n\t\tBlockSize = ((pSrc[0] << 8) | pSrc[1]) * sizeof(u16);\n\t\tpSrc += sizeof(u16);\n\n\t\t \n\t\t \n\t\tpSrc += sizeof(u16);\n\n\t\t \n\t\t \n\t\tpSrc += sizeof(u16);\n\n\t\tstatus = WriteBlock(state, Address, BlockSize,\n\t\t\t\t    pSrc, DRX_I2C_CLEARCRC);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tpSrc += BlockSize;\n\t}\n\n\treturn status;\n}\n\nstatic int HI_Command(struct drxd_state *state, u16 cmd, u16 * pResult)\n{\n\tu32 nrRetries = 0;\n\tint status;\n\n\tstatus = Write16(state, HI_RA_RAM_SRV_CMD__A, cmd, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\tdo {\n\t\tnrRetries += 1;\n\t\tif (nrRetries > DRXD_MAX_RETRIES) {\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t\t}\n\t\tstatus = Read16(state, HI_RA_RAM_SRV_CMD__A, NULL, 0);\n\t} while (status != 0);\n\n\tif (status >= 0)\n\t\tstatus = Read16(state, HI_RA_RAM_SRV_RES__A, pResult, 0);\n\treturn status;\n}\n\nstatic int HI_CfgCommand(struct drxd_state *state)\n{\n\tint status = 0;\n\n\tmutex_lock(&state->mutex);\n\tWrite16(state, HI_RA_RAM_SRV_CFG_KEY__A, HI_RA_RAM_SRV_RST_KEY_ACT, 0);\n\tWrite16(state, HI_RA_RAM_SRV_CFG_DIV__A, state->hi_cfg_timing_div, 0);\n\tWrite16(state, HI_RA_RAM_SRV_CFG_BDL__A, state->hi_cfg_bridge_delay, 0);\n\tWrite16(state, HI_RA_RAM_SRV_CFG_WUP__A, state->hi_cfg_wakeup_key, 0);\n\tWrite16(state, HI_RA_RAM_SRV_CFG_ACT__A, state->hi_cfg_ctrl, 0);\n\n\tWrite16(state, HI_RA_RAM_SRV_CFG_KEY__A, HI_RA_RAM_SRV_RST_KEY_ACT, 0);\n\n\tif ((state->hi_cfg_ctrl & HI_RA_RAM_SRV_CFG_ACT_PWD_EXE) ==\n\t    HI_RA_RAM_SRV_CFG_ACT_PWD_EXE)\n\t\tstatus = Write16(state, HI_RA_RAM_SRV_CMD__A,\n\t\t\t\t HI_RA_RAM_SRV_CMD_CONFIG, 0);\n\telse\n\t\tstatus = HI_Command(state, HI_RA_RAM_SRV_CMD_CONFIG, NULL);\n\tmutex_unlock(&state->mutex);\n\treturn status;\n}\n\nstatic int InitHI(struct drxd_state *state)\n{\n\tstate->hi_cfg_wakeup_key = (state->chip_adr);\n\t \n\tstate->hi_cfg_ctrl = HI_RA_RAM_SRV_CFG_ACT_SLV0_ON;\n\treturn HI_CfgCommand(state);\n}\n\nstatic int HI_ResetCommand(struct drxd_state *state)\n{\n\tint status;\n\n\tmutex_lock(&state->mutex);\n\tstatus = Write16(state, HI_RA_RAM_SRV_RST_KEY__A,\n\t\t\t HI_RA_RAM_SRV_RST_KEY_ACT, 0);\n\tif (status == 0)\n\t\tstatus = HI_Command(state, HI_RA_RAM_SRV_CMD_RESET, NULL);\n\tmutex_unlock(&state->mutex);\n\tmsleep(1);\n\treturn status;\n}\n\nstatic int DRX_ConfigureI2CBridge(struct drxd_state *state, int bEnableBridge)\n{\n\tstate->hi_cfg_ctrl &= (~HI_RA_RAM_SRV_CFG_ACT_BRD__M);\n\tif (bEnableBridge)\n\t\tstate->hi_cfg_ctrl |= HI_RA_RAM_SRV_CFG_ACT_BRD_ON;\n\telse\n\t\tstate->hi_cfg_ctrl |= HI_RA_RAM_SRV_CFG_ACT_BRD_OFF;\n\n\treturn HI_CfgCommand(state);\n}\n\n#define HI_TR_WRITE      0x9\n#define HI_TR_READ       0xA\n#define HI_TR_READ_WRITE 0xB\n#define HI_TR_BROADCAST  0x4\n\n#if 0\nstatic int AtomicReadBlock(struct drxd_state *state,\n\t\t\t   u32 Addr, u16 DataSize, u8 *pData, u8 Flags)\n{\n\tint status;\n\tint i = 0;\n\n\t \n\tif ((!pData) || ((DataSize & 1) != 0))\n\t\treturn -1;\n\n\tmutex_lock(&state->mutex);\n\n\tdo {\n\t\t \n\t\t \n\t\tstatus = Write16(state, HI_RA_RAM_SRV_CFG_KEY__A, (HI_TR_FUNC_ADDR & 0xFFFF), 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, HI_RA_RAM_SRV_CFG_DIV__A, (u16) (Addr >> 16), 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, HI_RA_RAM_SRV_CFG_BDL__A, (u16) (Addr & 0xFFFF), 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, HI_RA_RAM_SRV_CFG_WUP__A, (u16) ((DataSize / 2) - 1), 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, HI_RA_RAM_SRV_CFG_ACT__A, HI_TR_READ, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = HI_Command(state, HI_RA_RAM_SRV_CMD_EXECUTE, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t} while (0);\n\n\tif (status >= 0) {\n\t\tfor (i = 0; i < (DataSize / 2); i += 1) {\n\t\t\tu16 word;\n\n\t\t\tstatus = Read16(state, (HI_RA_RAM_USR_BEGIN__A + i),\n\t\t\t\t\t&word, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tpData[2 * i] = (u8) (word & 0xFF);\n\t\t\tpData[(2 * i) + 1] = (u8) (word >> 8);\n\t\t}\n\t}\n\tmutex_unlock(&state->mutex);\n\treturn status;\n}\n\nstatic int AtomicReadReg32(struct drxd_state *state,\n\t\t\t   u32 Addr, u32 *pData, u8 Flags)\n{\n\tu8 buf[sizeof(u32)];\n\tint status;\n\n\tif (!pData)\n\t\treturn -1;\n\tstatus = AtomicReadBlock(state, Addr, sizeof(u32), buf, Flags);\n\t*pData = (((u32) buf[0]) << 0) +\n\t    (((u32) buf[1]) << 8) +\n\t    (((u32) buf[2]) << 16) + (((u32) buf[3]) << 24);\n\treturn status;\n}\n#endif\n\nstatic int StopAllProcessors(struct drxd_state *state)\n{\n\treturn Write16(state, HI_COMM_EXEC__A,\n\t\t       SC_COMM_EXEC_CTL_STOP, DRX_I2C_BROADCAST);\n}\n\nstatic int EnableAndResetMB(struct drxd_state *state)\n{\n\tif (state->type_A) {\n\t\t \n\t\tWrite16(state, EC_OC_REG_OC_MON_SIO__A, 0x0000, 0x0000);\n\t}\n\n\t \n\tWrite16(state, HI_COMM_MB__A, 0x0000, DRX_I2C_BROADCAST);\n\tWrite16(state, HI_COMM_MB__A, 0x0000, 0x0000);\n\treturn 0;\n}\n\nstatic int InitCC(struct drxd_state *state)\n{\n\tint status = 0;\n\n\tif (state->osc_clock_freq == 0 ||\n\t    state->osc_clock_freq > 20000 ||\n\t    (state->osc_clock_freq % 4000) != 0) {\n\t\tprintk(KERN_ERR \"invalid osc frequency %d\\n\", state->osc_clock_freq);\n\t\treturn -1;\n\t}\n\n\tstatus |= Write16(state, CC_REG_OSC_MODE__A, CC_REG_OSC_MODE_M20, 0);\n\tstatus |= Write16(state, CC_REG_PLL_MODE__A,\n\t\t\t\tCC_REG_PLL_MODE_BYPASS_PLL |\n\t\t\t\tCC_REG_PLL_MODE_PUMP_CUR_12, 0);\n\tstatus |= Write16(state, CC_REG_REF_DIVIDE__A,\n\t\t\t\tstate->osc_clock_freq / 4000, 0);\n\tstatus |= Write16(state, CC_REG_PWD_MODE__A, CC_REG_PWD_MODE_DOWN_PLL,\n\t\t\t\t0);\n\tstatus |= Write16(state, CC_REG_UPDATE__A, CC_REG_UPDATE_KEY, 0);\n\n\treturn status;\n}\n\nstatic int ResetECOD(struct drxd_state *state)\n{\n\tint status = 0;\n\n\tif (state->type_A)\n\t\tstatus = Write16(state, EC_OD_REG_SYNC__A, 0x0664, 0);\n\telse\n\t\tstatus = Write16(state, B_EC_OD_REG_SYNC__A, 0x0664, 0);\n\n\tif (!(status < 0))\n\t\tstatus = WriteTable(state, state->m_ResetECRAM);\n\tif (!(status < 0))\n\t\tstatus = Write16(state, EC_OD_REG_COMM_EXEC__A, 0x0001, 0);\n\treturn status;\n}\n\n \n\nstatic int SetCfgPga(struct drxd_state *state, int pgaSwitch)\n{\n\tint status;\n\tu16 AgModeLop = 0;\n\tu16 AgModeHip = 0;\n\tdo {\n\t\tif (pgaSwitch) {\n\t\t\t \n\t\t\t \n\t\t\tstatus = Read16(state, B_FE_AG_REG_AG_MODE_LOP__A, &AgModeLop, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tAgModeLop &= (~(B_FE_AG_REG_AG_MODE_LOP_MODE_C__M));\n\t\t\tAgModeLop |= B_FE_AG_REG_AG_MODE_LOP_MODE_C_DYNAMIC;\n\t\t\tstatus = Write16(state, B_FE_AG_REG_AG_MODE_LOP__A, AgModeLop, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tstatus = Read16(state, B_FE_AG_REG_AG_MODE_HIP__A, &AgModeHip, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tAgModeHip &= (~(B_FE_AG_REG_AG_MODE_HIP_MODE_J__M));\n\t\t\tAgModeHip |= B_FE_AG_REG_AG_MODE_HIP_MODE_J_DYNAMIC;\n\t\t\tstatus = Write16(state, B_FE_AG_REG_AG_MODE_HIP__A, AgModeHip, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tstatus = Write16(state, B_FE_AG_REG_AG_PGA_MODE__A, B_FE_AG_REG_AG_PGA_MODE_PFY_PCY_AFY_REN, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\t\t\tstatus = Read16(state, B_FE_AG_REG_AG_MODE_LOP__A, &AgModeLop, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tAgModeLop &= (~(B_FE_AG_REG_AG_MODE_LOP_MODE_C__M));\n\t\t\tAgModeLop |= B_FE_AG_REG_AG_MODE_LOP_MODE_C_STATIC;\n\t\t\tstatus = Write16(state, B_FE_AG_REG_AG_MODE_LOP__A, AgModeLop, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tstatus = Read16(state, B_FE_AG_REG_AG_MODE_HIP__A, &AgModeHip, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tAgModeHip &= (~(B_FE_AG_REG_AG_MODE_HIP_MODE_J__M));\n\t\t\tAgModeHip |= B_FE_AG_REG_AG_MODE_HIP_MODE_J_STATIC;\n\t\t\tstatus = Write16(state, B_FE_AG_REG_AG_MODE_HIP__A, AgModeHip, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tstatus = Write16(state, B_FE_AG_REG_AG_PGA_MODE__A, B_FE_AG_REG_AG_PGA_MODE_PFN_PCN_AFY_REN, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t} while (0);\n\treturn status;\n}\n\nstatic int InitFE(struct drxd_state *state)\n{\n\tint status;\n\n\tdo {\n\t\tstatus = WriteTable(state, state->m_InitFE_1);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tif (state->type_A) {\n\t\t\tstatus = Write16(state, FE_AG_REG_AG_PGA_MODE__A,\n\t\t\t\t\t FE_AG_REG_AG_PGA_MODE_PFN_PCN_AFY_REN,\n\t\t\t\t\t 0);\n\t\t} else {\n\t\t\tif (state->PGA)\n\t\t\t\tstatus = SetCfgPga(state, 0);\n\t\t\telse\n\t\t\t\tstatus =\n\t\t\t\t    Write16(state, B_FE_AG_REG_AG_PGA_MODE__A,\n\t\t\t\t\t    B_FE_AG_REG_AG_PGA_MODE_PFN_PCN_AFY_REN,\n\t\t\t\t\t    0);\n\t\t}\n\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, FE_AG_REG_AG_AGC_SIO__A, state->m_FeAgRegAgAgcSio, 0x0000);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, FE_AG_REG_AG_PWD__A, state->m_FeAgRegAgPwd, 0x0000);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = WriteTable(state, state->m_InitFE_2);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t} while (0);\n\n\treturn status;\n}\n\nstatic int InitFT(struct drxd_state *state)\n{\n\t \n\treturn Write16(state, FT_REG_COMM_EXEC__A, 0x0001, 0x0000);\n}\n\nstatic int SC_WaitForReady(struct drxd_state *state)\n{\n\tint i;\n\n\tfor (i = 0; i < DRXD_MAX_RETRIES; i += 1) {\n\t\tint status = Read16(state, SC_RA_RAM_CMD__A, NULL, 0);\n\t\tif (status == 0)\n\t\t\treturn status;\n\t}\n\treturn -1;\n}\n\nstatic int SC_SendCommand(struct drxd_state *state, u16 cmd)\n{\n\tint status = 0, ret;\n\tu16 errCode;\n\n\tstatus = Write16(state, SC_RA_RAM_CMD__A, cmd, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\tSC_WaitForReady(state);\n\n\tret = Read16(state, SC_RA_RAM_CMD_ADDR__A, &errCode, 0);\n\n\tif (ret < 0 || errCode == 0xFFFF) {\n\t\tprintk(KERN_ERR \"Command Error\\n\");\n\t\tstatus = -1;\n\t}\n\n\treturn status;\n}\n\nstatic int SC_ProcStartCommand(struct drxd_state *state,\n\t\t\t       u16 subCmd, u16 param0, u16 param1)\n{\n\tint ret, status = 0;\n\tu16 scExec;\n\n\tmutex_lock(&state->mutex);\n\tdo {\n\t\tret = Read16(state, SC_COMM_EXEC__A, &scExec, 0);\n\t\tif (ret < 0 || scExec != 1) {\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t\t}\n\t\tSC_WaitForReady(state);\n\t\tstatus |= Write16(state, SC_RA_RAM_CMD_ADDR__A, subCmd, 0);\n\t\tstatus |= Write16(state, SC_RA_RAM_PARAM1__A, param1, 0);\n\t\tstatus |= Write16(state, SC_RA_RAM_PARAM0__A, param0, 0);\n\n\t\tSC_SendCommand(state, SC_RA_RAM_CMD_PROC_START);\n\t} while (0);\n\tmutex_unlock(&state->mutex);\n\treturn status;\n}\n\nstatic int SC_SetPrefParamCommand(struct drxd_state *state,\n\t\t\t\t  u16 subCmd, u16 param0, u16 param1)\n{\n\tint status;\n\n\tmutex_lock(&state->mutex);\n\tdo {\n\t\tstatus = SC_WaitForReady(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, SC_RA_RAM_CMD_ADDR__A, subCmd, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, SC_RA_RAM_PARAM1__A, param1, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, SC_RA_RAM_PARAM0__A, param0, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = SC_SendCommand(state, SC_RA_RAM_CMD_SET_PREF_PARAM);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t} while (0);\n\tmutex_unlock(&state->mutex);\n\treturn status;\n}\n\n#if 0\nstatic int SC_GetOpParamCommand(struct drxd_state *state, u16 * result)\n{\n\tint status = 0;\n\n\tmutex_lock(&state->mutex);\n\tdo {\n\t\tstatus = SC_WaitForReady(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = SC_SendCommand(state, SC_RA_RAM_CMD_GET_OP_PARAM);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Read16(state, SC_RA_RAM_PARAM0__A, result, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t} while (0);\n\tmutex_unlock(&state->mutex);\n\treturn status;\n}\n#endif\n\nstatic int ConfigureMPEGOutput(struct drxd_state *state, int bEnableOutput)\n{\n\tint status;\n\n\tdo {\n\t\tu16 EcOcRegIprInvMpg = 0;\n\t\tu16 EcOcRegOcModeLop = 0;\n\t\tu16 EcOcRegOcModeHip = 0;\n\t\tu16 EcOcRegOcMpgSio = 0;\n\n\t\t \n\n\t\tif (state->operation_mode == OM_DVBT_Diversity_Front) {\n\t\t\tif (bEnableOutput) {\n\t\t\t\tEcOcRegOcModeHip |=\n\t\t\t\t    B_EC_OC_REG_OC_MODE_HIP_MPG_BUS_SRC_MONITOR;\n\t\t\t} else\n\t\t\t\tEcOcRegOcMpgSio |= EC_OC_REG_OC_MPG_SIO__M;\n\t\t\tEcOcRegOcModeLop |=\n\t\t\t    EC_OC_REG_OC_MODE_LOP_PAR_ENA_DISABLE;\n\t\t} else {\n\t\t\tEcOcRegOcModeLop = state->m_EcOcRegOcModeLop;\n\n\t\t\tif (bEnableOutput)\n\t\t\t\tEcOcRegOcMpgSio &= (~(EC_OC_REG_OC_MPG_SIO__M));\n\t\t\telse\n\t\t\t\tEcOcRegOcMpgSio |= EC_OC_REG_OC_MPG_SIO__M;\n\n\t\t\t \n\t\t\tif (state->insert_rs_byte) {\n\t\t\t\tEcOcRegOcModeLop &=\n\t\t\t\t    (~(EC_OC_REG_OC_MODE_LOP_PAR_ENA__M));\n\t\t\t\tEcOcRegOcModeHip &=\n\t\t\t\t    (~EC_OC_REG_OC_MODE_HIP_MPG_PAR_VAL__M);\n\t\t\t\tEcOcRegOcModeHip |=\n\t\t\t\t    EC_OC_REG_OC_MODE_HIP_MPG_PAR_VAL_ENABLE;\n\t\t\t} else {\n\t\t\t\tEcOcRegOcModeLop |=\n\t\t\t\t    EC_OC_REG_OC_MODE_LOP_PAR_ENA_DISABLE;\n\t\t\t\tEcOcRegOcModeHip &=\n\t\t\t\t    (~EC_OC_REG_OC_MODE_HIP_MPG_PAR_VAL__M);\n\t\t\t\tEcOcRegOcModeHip |=\n\t\t\t\t    EC_OC_REG_OC_MODE_HIP_MPG_PAR_VAL_DISABLE;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (state->enable_parallel)\n\t\t\t\tEcOcRegOcModeLop &=\n\t\t\t\t    (~(EC_OC_REG_OC_MODE_LOP_MPG_TRM_MDE__M));\n\t\t\telse\n\t\t\t\tEcOcRegOcModeLop |=\n\t\t\t\t    EC_OC_REG_OC_MODE_LOP_MPG_TRM_MDE_SERIAL;\n\t\t}\n\t\t \n\t\t \n\t\tEcOcRegIprInvMpg &= (~(0x00FF));\n\n\t\t \n\t\t \n\t\tEcOcRegIprInvMpg &= (~(0x0100));\n\n\t\t \n\t\t \n\t\tEcOcRegIprInvMpg &= (~(0x0200));\n\n\t\t \n\t\t \n\t\tEcOcRegIprInvMpg &= (~(0x0400));\n\n\t\t \n\t\t \n\t\tEcOcRegIprInvMpg &= (~(0x0800));\n\n\t\t \n\t\tstatus = Write16(state, EC_OC_REG_IPR_INV_MPG__A, EcOcRegIprInvMpg, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, EC_OC_REG_OC_MODE_LOP__A, EcOcRegOcModeLop, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, EC_OC_REG_OC_MODE_HIP__A, EcOcRegOcModeHip, 0x0000);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, EC_OC_REG_OC_MPG_SIO__A, EcOcRegOcMpgSio, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t} while (0);\n\treturn status;\n}\n\nstatic int SetDeviceTypeId(struct drxd_state *state)\n{\n\tint status = 0;\n\tu16 deviceId = 0;\n\n\tdo {\n\t\tstatus = Read16(state, CC_REG_JTAGID_L__A, &deviceId, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\t \n\t\tstatus = Read16(state, CC_REG_JTAGID_L__A, &deviceId, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tprintk(KERN_INFO \"drxd: deviceId = %04x\\n\", deviceId);\n\n\t\tstate->type_A = 0;\n\t\tstate->PGA = 0;\n\t\tstate->diversity = 0;\n\t\tif (deviceId == 0) {\t \n\t\t\tstate->type_A = 1;\n\t\t\tprintk(KERN_INFO \"DRX3975D-A2\\n\");\n\t\t} else {\n\t\t\tdeviceId >>= 12;\n\t\t\tprintk(KERN_INFO \"DRX397%dD-B1\\n\", deviceId);\n\t\t\tswitch (deviceId) {\n\t\t\tcase 4:\n\t\t\t\tstate->diversity = 1;\n\t\t\t\tfallthrough;\n\t\t\tcase 3:\n\t\t\tcase 7:\n\t\t\t\tstate->PGA = 1;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tstate->diversity = 1;\n\t\t\t\tfallthrough;\n\t\t\tcase 5:\n\t\t\tcase 8:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstatus = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (0);\n\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tstate->m_InitAtomicRead = DRXD_InitAtomicRead;\n\tstate->m_InitSC = DRXD_InitSC;\n\tstate->m_ResetECRAM = DRXD_ResetECRAM;\n\tif (state->type_A) {\n\t\tstate->m_ResetCEFR = DRXD_ResetCEFR;\n\t\tstate->m_InitFE_1 = DRXD_InitFEA2_1;\n\t\tstate->m_InitFE_2 = DRXD_InitFEA2_2;\n\t\tstate->m_InitCP = DRXD_InitCPA2;\n\t\tstate->m_InitCE = DRXD_InitCEA2;\n\t\tstate->m_InitEQ = DRXD_InitEQA2;\n\t\tstate->m_InitEC = DRXD_InitECA2;\n\t\tif (load_firmware(state, DRX_FW_FILENAME_A2))\n\t\t\treturn -EIO;\n\t} else {\n\t\tstate->m_ResetCEFR = NULL;\n\t\tstate->m_InitFE_1 = DRXD_InitFEB1_1;\n\t\tstate->m_InitFE_2 = DRXD_InitFEB1_2;\n\t\tstate->m_InitCP = DRXD_InitCPB1;\n\t\tstate->m_InitCE = DRXD_InitCEB1;\n\t\tstate->m_InitEQ = DRXD_InitEQB1;\n\t\tstate->m_InitEC = DRXD_InitECB1;\n\t\tif (load_firmware(state, DRX_FW_FILENAME_B1))\n\t\t\treturn -EIO;\n\t}\n\tif (state->diversity) {\n\t\tstate->m_InitDiversityFront = DRXD_InitDiversityFront;\n\t\tstate->m_InitDiversityEnd = DRXD_InitDiversityEnd;\n\t\tstate->m_DisableDiversity = DRXD_DisableDiversity;\n\t\tstate->m_StartDiversityFront = DRXD_StartDiversityFront;\n\t\tstate->m_StartDiversityEnd = DRXD_StartDiversityEnd;\n\t\tstate->m_DiversityDelay8MHZ = DRXD_DiversityDelay8MHZ;\n\t\tstate->m_DiversityDelay6MHZ = DRXD_DiversityDelay6MHZ;\n\t} else {\n\t\tstate->m_InitDiversityFront = NULL;\n\t\tstate->m_InitDiversityEnd = NULL;\n\t\tstate->m_DisableDiversity = NULL;\n\t\tstate->m_StartDiversityFront = NULL;\n\t\tstate->m_StartDiversityEnd = NULL;\n\t\tstate->m_DiversityDelay8MHZ = NULL;\n\t\tstate->m_DiversityDelay6MHZ = NULL;\n\t}\n\n\treturn status;\n}\n\nstatic int CorrectSysClockDeviation(struct drxd_state *state)\n{\n\tint status;\n\ts32 incr = 0;\n\ts32 nomincr = 0;\n\tu32 bandwidth = 0;\n\tu32 sysClockInHz = 0;\n\tu32 sysClockFreq = 0;\t \n\ts16 oscClockDeviation;\n\ts16 Diff;\n\n\tdo {\n\t\t \n\n\t\t \n\t\tstatus = Read32(state, LC_RA_RAM_IFINCR_NOM_L__A, ((u32 *) &nomincr), 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Read32(state, FE_IF_REG_INCR0__A, (u32 *) &incr, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tif (state->type_A) {\n\t\t\tif ((nomincr - incr < -500) || (nomincr - incr > 500))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif ((nomincr - incr < -2000) || (nomincr - incr > 2000))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tswitch (state->props.bandwidth_hz) {\n\t\tcase 8000000:\n\t\t\tbandwidth = DRXD_BANDWIDTH_8MHZ_IN_HZ;\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\tbandwidth = DRXD_BANDWIDTH_7MHZ_IN_HZ;\n\t\t\tbreak;\n\t\tcase 6000000:\n\t\t\tbandwidth = DRXD_BANDWIDTH_6MHZ_IN_HZ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tincr += (1 << 23);\n\t\tsysClockInHz = MulDiv32(incr, bandwidth, 1 << 21);\n\t\tsysClockFreq = (u32) (sysClockInHz / 1000);\n\t\t \n\t\tif ((sysClockInHz % 1000) > 500)\n\t\t\tsysClockFreq++;\n\n\t\t \n\t\toscClockDeviation = (u16) ((((s32) (sysClockFreq) -\n\t\t\t\t\t     (s32)\n\t\t\t\t\t     (state->expected_sys_clock_freq)) *\n\t\t\t\t\t    1000000L) /\n\t\t\t\t\t   (s32)\n\t\t\t\t\t   (state->expected_sys_clock_freq));\n\n\t\tDiff = oscClockDeviation - state->osc_clock_deviation;\n\t\t \n\t\tif (Diff >= -200 && Diff <= 200) {\n\t\t\tstate->sys_clock_freq = (u16) sysClockFreq;\n\t\t\tif (oscClockDeviation != state->osc_clock_deviation) {\n\t\t\t\tif (state->config.osc_deviation) {\n\t\t\t\t\tstate->config.osc_deviation(state->priv,\n\t\t\t\t\t\t\t\t    oscClockDeviation,\n\t\t\t\t\t\t\t\t    1);\n\t\t\t\t\tstate->osc_clock_deviation =\n\t\t\t\t\t    oscClockDeviation;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tstatus = Write16(state, SC_RA_RAM_SAMPLE_RATE_COUNT__A, DRXD_OSCDEV_DONT_SCAN, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tstatus = Write16(state, SC_RA_RAM_IF_SAVE__AX, state->current_fe_if_incr, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstate->cscd_state = CSCD_SAVED;\n\t\t}\n\t} while (0);\n\n\treturn status;\n}\n\nstatic int DRX_Stop(struct drxd_state *state)\n{\n\tint status;\n\n\tif (state->drxd_state != DRXD_STARTED)\n\t\treturn 0;\n\n\tdo {\n\t\tif (state->cscd_state != CSCD_SAVED) {\n\t\t\tu32 lock;\n\t\t\tstatus = DRX_GetLockStatus(state, &lock);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstatus = StopOC(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstate->drxd_state = DRXD_STOPPED;\n\n\t\tstatus = ConfigureMPEGOutput(state, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tif (state->type_A) {\n\t\t\t \n\t\t\tstatus = Write16(state, EC_OD_REG_COMM_EXEC__A, 0x0000, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\tstatus = Write16(state, SC_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = Write16(state, LC_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tstatus = Write16(state, B_SC_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = Write16(state, B_LC_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = Write16(state, B_FT_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = Write16(state, B_CP_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = Write16(state, B_CE_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = Write16(state, B_EQ_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = Write16(state, EC_OD_REG_COMM_EXEC__A, 0x0000, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t} while (0);\n\treturn status;\n}\n\n#if 0\t \nstatic int SetOperationMode(struct drxd_state *state, int oMode)\n{\n\tint status;\n\n\tdo {\n\t\tif (state->drxd_state != DRXD_STOPPED) {\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (oMode == state->operation_mode) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (oMode != OM_Default && !state->diversity) {\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (oMode) {\n\t\tcase OM_DVBT_Diversity_Front:\n\t\t\tstatus = WriteTable(state, state->m_InitDiversityFront);\n\t\t\tbreak;\n\t\tcase OM_DVBT_Diversity_End:\n\t\t\tstatus = WriteTable(state, state->m_InitDiversityEnd);\n\t\t\tbreak;\n\t\tcase OM_Default:\n\t\t\t \n\t\tdefault:\n\t\t\tstatus = WriteTable(state, state->m_DisableDiversity);\n\t\t\tbreak;\n\t\t}\n\t} while (0);\n\n\tif (!status)\n\t\tstate->operation_mode = oMode;\n\treturn status;\n}\n#endif\n\nstatic int StartDiversity(struct drxd_state *state)\n{\n\tint status = 0;\n\tu16 rcControl;\n\n\tdo {\n\t\tif (state->operation_mode == OM_DVBT_Diversity_Front) {\n\t\t\tstatus = WriteTable(state, state->m_StartDiversityFront);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else if (state->operation_mode == OM_DVBT_Diversity_End) {\n\t\t\tstatus = WriteTable(state, state->m_StartDiversityEnd);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tif (state->props.bandwidth_hz == 8000000) {\n\t\t\t\tstatus = WriteTable(state, state->m_DiversityDelay8MHZ);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tstatus = WriteTable(state, state->m_DiversityDelay6MHZ);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = Read16(state, B_EQ_REG_RC_SEL_CAR__A, &rcControl, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\trcControl &= ~(B_EQ_REG_RC_SEL_CAR_FFTMODE__M);\n\t\t\trcControl |= B_EQ_REG_RC_SEL_CAR_DIV_ON |\n\t\t\t     \n\t\t\t    B_EQ_REG_RC_SEL_CAR_MEAS_A_CC |\n\t\t\t    B_EQ_REG_RC_SEL_CAR_PASS_A_CC |\n\t\t\t    B_EQ_REG_RC_SEL_CAR_LOCAL_A_CC;\n\t\t\tstatus = Write16(state, B_EQ_REG_RC_SEL_CAR__A, rcControl, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t} while (0);\n\treturn status;\n}\n\nstatic int SetFrequencyShift(struct drxd_state *state,\n\t\t\t     u32 offsetFreq, int channelMirrored)\n{\n\tint negativeShift = (state->tuner_mirrors == channelMirrored);\n\n\t \n\n\t \n\tstate->fe_fs_add_incr = MulDiv32(state->intermediate_freq +\n\t\t\t\t\t offsetFreq,\n\t\t\t\t\t 1 << 28, state->sys_clock_freq);\n\t \n\tstate->fe_fs_add_incr &= 0x0FFFFFFFL;\n\tif (negativeShift)\n\t\tstate->fe_fs_add_incr = ((1 << 28) - state->fe_fs_add_incr);\n\n\t \n\tstate->org_fe_fs_add_incr = MulDiv32(state->intermediate_freq,\n\t\t\t\t\t     1 << 28, state->sys_clock_freq);\n\t \n\tstate->org_fe_fs_add_incr &= 0x0FFFFFFFL;\n\tif (negativeShift)\n\t\tstate->org_fe_fs_add_incr = ((1L << 28) -\n\t\t\t\t\t     state->org_fe_fs_add_incr);\n\n\treturn Write32(state, FE_FS_REG_ADD_INC_LOP__A,\n\t\t       state->fe_fs_add_incr, 0);\n}\n\nstatic int SetCfgNoiseCalibration(struct drxd_state *state,\n\t\t\t\t  struct SNoiseCal *noiseCal)\n{\n\tu16 beOptEna;\n\tint status = 0;\n\n\tdo {\n\t\tstatus = Read16(state, SC_RA_RAM_BE_OPT_ENA__A, &beOptEna, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (noiseCal->cpOpt) {\n\t\t\tbeOptEna |= (1 << SC_RA_RAM_BE_OPT_ENA_CP_OPT);\n\t\t} else {\n\t\t\tbeOptEna &= ~(1 << SC_RA_RAM_BE_OPT_ENA_CP_OPT);\n\t\t\tstatus = Write16(state, CP_REG_AC_NEXP_OFFS__A, noiseCal->cpNexpOfs, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tstatus = Write16(state, SC_RA_RAM_BE_OPT_ENA__A, beOptEna, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tif (!state->type_A) {\n\t\t\tstatus = Write16(state, B_SC_RA_RAM_CO_TD_CAL_2K__A, noiseCal->tdCal2k, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = Write16(state, B_SC_RA_RAM_CO_TD_CAL_8K__A, noiseCal->tdCal8k, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t} while (0);\n\n\treturn status;\n}\n\nstatic int DRX_Start(struct drxd_state *state, s32 off)\n{\n\tstruct dtv_frontend_properties *p = &state->props;\n\tint status;\n\n\tu16 transmissionParams = 0;\n\tu16 operationMode = 0;\n\tu16 qpskTdTpsPwr = 0;\n\tu16 qam16TdTpsPwr = 0;\n\tu16 qam64TdTpsPwr = 0;\n\tu32 feIfIncr = 0;\n\tu32 bandwidth = 0;\n\tint mirrorFreqSpect;\n\n\tu16 qpskSnCeGain = 0;\n\tu16 qam16SnCeGain = 0;\n\tu16 qam64SnCeGain = 0;\n\tu16 qpskIsGainMan = 0;\n\tu16 qam16IsGainMan = 0;\n\tu16 qam64IsGainMan = 0;\n\tu16 qpskIsGainExp = 0;\n\tu16 qam16IsGainExp = 0;\n\tu16 qam64IsGainExp = 0;\n\tu16 bandwidthParam = 0;\n\n\tif (off < 0)\n\t\toff = (off - 500) / 1000;\n\telse\n\t\toff = (off + 500) / 1000;\n\n\tdo {\n\t\tif (state->drxd_state != DRXD_STOPPED)\n\t\t\treturn -1;\n\t\tstatus = ResetECOD(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (state->type_A) {\n\t\t\tstatus = InitSC(state);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tstatus = InitFT(state);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = InitCP(state);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = InitCE(state);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = InitEQ(state);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = InitSC(state);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tstatus = SetCfgIfAgc(state, &state->if_agc_cfg);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = SetCfgRfAgc(state, &state->rf_agc_cfg);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tmirrorFreqSpect = (state->props.inversion == INVERSION_ON);\n\n\t\tswitch (p->transmission_mode) {\n\t\tdefault:\t \n\t\t\toperationMode |= SC_RA_RAM_OP_AUTO_MODE__M;\n\t\t\tfallthrough;\t \n\t\tcase TRANSMISSION_MODE_8K:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_MODE_8K;\n\t\t\tif (state->type_A) {\n\t\t\t\tstatus = Write16(state, EC_SB_REG_TR_MODE__A, EC_SB_REG_TR_MODE_8K, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tqpskSnCeGain = 99;\n\t\t\t\tqam16SnCeGain = 83;\n\t\t\t\tqam64SnCeGain = 67;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRANSMISSION_MODE_2K:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_MODE_2K;\n\t\t\tif (state->type_A) {\n\t\t\t\tstatus = Write16(state, EC_SB_REG_TR_MODE__A, EC_SB_REG_TR_MODE_2K, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tqpskSnCeGain = 97;\n\t\t\t\tqam16SnCeGain = 71;\n\t\t\t\tqam64SnCeGain = 65;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (p->guard_interval) {\n\t\tcase GUARD_INTERVAL_1_4:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_GUARD_4;\n\t\t\tbreak;\n\t\tcase GUARD_INTERVAL_1_8:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_GUARD_8;\n\t\t\tbreak;\n\t\tcase GUARD_INTERVAL_1_16:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_GUARD_16;\n\t\t\tbreak;\n\t\tcase GUARD_INTERVAL_1_32:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_GUARD_32;\n\t\t\tbreak;\n\t\tdefault:\t \n\t\t\toperationMode |= SC_RA_RAM_OP_AUTO_GUARD__M;\n\t\t\t \n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_GUARD_4;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (p->hierarchy) {\n\t\tcase HIERARCHY_1:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_HIER_A1;\n\t\t\tif (state->type_A) {\n\t\t\t\tstatus = Write16(state, EQ_REG_OT_ALPHA__A, 0x0001, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_ALPHA__A, 0x0001, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tqpskTdTpsPwr = EQ_TD_TPS_PWR_UNKNOWN;\n\t\t\t\tqam16TdTpsPwr = EQ_TD_TPS_PWR_QAM16_ALPHA1;\n\t\t\t\tqam64TdTpsPwr = EQ_TD_TPS_PWR_QAM64_ALPHA1;\n\n\t\t\t\tqpskIsGainMan =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_UNKNOWN_MAN__PRE;\n\t\t\t\tqam16IsGainMan =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_16QAM_MAN__PRE;\n\t\t\t\tqam64IsGainMan =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_64QAM_MAN__PRE;\n\n\t\t\t\tqpskIsGainExp =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_UNKNOWN_EXP__PRE;\n\t\t\t\tqam16IsGainExp =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_16QAM_EXP__PRE;\n\t\t\t\tqam64IsGainExp =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_64QAM_EXP__PRE;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HIERARCHY_2:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_HIER_A2;\n\t\t\tif (state->type_A) {\n\t\t\t\tstatus = Write16(state, EQ_REG_OT_ALPHA__A, 0x0002, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_ALPHA__A, 0x0002, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tqpskTdTpsPwr = EQ_TD_TPS_PWR_UNKNOWN;\n\t\t\t\tqam16TdTpsPwr = EQ_TD_TPS_PWR_QAM16_ALPHA2;\n\t\t\t\tqam64TdTpsPwr = EQ_TD_TPS_PWR_QAM64_ALPHA2;\n\n\t\t\t\tqpskIsGainMan =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_UNKNOWN_MAN__PRE;\n\t\t\t\tqam16IsGainMan =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_16QAM_A2_MAN__PRE;\n\t\t\t\tqam64IsGainMan =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_64QAM_A2_MAN__PRE;\n\n\t\t\t\tqpskIsGainExp =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_UNKNOWN_EXP__PRE;\n\t\t\t\tqam16IsGainExp =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_16QAM_A2_EXP__PRE;\n\t\t\t\tqam64IsGainExp =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_64QAM_A2_EXP__PRE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HIERARCHY_4:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_HIER_A4;\n\t\t\tif (state->type_A) {\n\t\t\t\tstatus = Write16(state, EQ_REG_OT_ALPHA__A, 0x0003, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_ALPHA__A, 0x0003, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tqpskTdTpsPwr = EQ_TD_TPS_PWR_UNKNOWN;\n\t\t\t\tqam16TdTpsPwr = EQ_TD_TPS_PWR_QAM16_ALPHA4;\n\t\t\t\tqam64TdTpsPwr = EQ_TD_TPS_PWR_QAM64_ALPHA4;\n\n\t\t\t\tqpskIsGainMan =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_UNKNOWN_MAN__PRE;\n\t\t\t\tqam16IsGainMan =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_16QAM_A4_MAN__PRE;\n\t\t\t\tqam64IsGainMan =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_64QAM_A4_MAN__PRE;\n\n\t\t\t\tqpskIsGainExp =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_UNKNOWN_EXP__PRE;\n\t\t\t\tqam16IsGainExp =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_16QAM_A4_EXP__PRE;\n\t\t\t\tqam64IsGainExp =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_64QAM_A4_EXP__PRE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HIERARCHY_AUTO:\n\t\tdefault:\n\t\t\t \n\t\t\toperationMode |= SC_RA_RAM_OP_AUTO_HIER__M;\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_HIER_NO;\n\t\t\tif (state->type_A) {\n\t\t\t\tstatus = Write16(state, EQ_REG_OT_ALPHA__A, 0x0000, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_ALPHA__A, 0x0000, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tqpskTdTpsPwr = EQ_TD_TPS_PWR_QPSK;\n\t\t\t\tqam16TdTpsPwr = EQ_TD_TPS_PWR_QAM16_ALPHAN;\n\t\t\t\tqam64TdTpsPwr = EQ_TD_TPS_PWR_QAM64_ALPHAN;\n\n\t\t\t\tqpskIsGainMan =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_QPSK_MAN__PRE;\n\t\t\t\tqam16IsGainMan =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_16QAM_MAN__PRE;\n\t\t\t\tqam64IsGainMan =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_64QAM_MAN__PRE;\n\n\t\t\t\tqpskIsGainExp =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_QPSK_EXP__PRE;\n\t\t\t\tqam16IsGainExp =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_16QAM_EXP__PRE;\n\t\t\t\tqam64IsGainExp =\n\t\t\t\t    SC_RA_RAM_EQ_IS_GAIN_64QAM_EXP__PRE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tswitch (p->modulation) {\n\t\tdefault:\n\t\t\toperationMode |= SC_RA_RAM_OP_AUTO_CONST__M;\n\t\t\tfallthrough;\t \n\t\tcase QAM_64:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_CONST_QAM64;\n\t\t\tif (state->type_A) {\n\t\t\t\tstatus = Write16(state, EQ_REG_OT_CONST__A, 0x0002, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_CONST__A, EC_SB_REG_CONST_64QAM, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_SCALE_MSB__A, 0x0020, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_SCALE_BIT2__A, 0x0008, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_SCALE_LSB__A, 0x0002, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tstatus = Write16(state, EQ_REG_TD_TPS_PWR_OFS__A, qam64TdTpsPwr, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EQ_REG_SN_CEGAIN__A, qam64SnCeGain, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EQ_REG_IS_GAIN_MAN__A, qam64IsGainMan, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EQ_REG_IS_GAIN_EXP__A, qam64IsGainExp, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QPSK:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_CONST_QPSK;\n\t\t\tif (state->type_A) {\n\t\t\t\tstatus = Write16(state, EQ_REG_OT_CONST__A, 0x0000, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_CONST__A, EC_SB_REG_CONST_QPSK, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_SCALE_MSB__A, 0x0010, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_SCALE_BIT2__A, 0x0000, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_SCALE_LSB__A, 0x0000, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tstatus = Write16(state, EQ_REG_TD_TPS_PWR_OFS__A, qpskTdTpsPwr, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EQ_REG_SN_CEGAIN__A, qpskSnCeGain, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EQ_REG_IS_GAIN_MAN__A, qpskIsGainMan, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EQ_REG_IS_GAIN_EXP__A, qpskIsGainExp, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase QAM_16:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_CONST_QAM16;\n\t\t\tif (state->type_A) {\n\t\t\t\tstatus = Write16(state, EQ_REG_OT_CONST__A, 0x0001, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_CONST__A, EC_SB_REG_CONST_16QAM, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_SCALE_MSB__A, 0x0010, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_SCALE_BIT2__A, 0x0004, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EC_SB_REG_SCALE_LSB__A, 0x0000, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tstatus = Write16(state, EQ_REG_TD_TPS_PWR_OFS__A, qam16TdTpsPwr, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EQ_REG_SN_CEGAIN__A, qam16SnCeGain, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EQ_REG_IS_GAIN_MAN__A, qam16IsGainMan, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tstatus = Write16(state, EQ_REG_IS_GAIN_EXP__A, qam16IsGainExp, 0x0000);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tswitch (DRX_CHANNEL_HIGH) {\n\t\tdefault:\n\t\tcase DRX_CHANNEL_AUTO:\n\t\tcase DRX_CHANNEL_LOW:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_PRIO_LO;\n\t\t\tstatus = Write16(state, EC_SB_REG_PRIOR__A, EC_SB_REG_PRIOR_LO, 0x0000);\n\t\t\tbreak;\n\t\tcase DRX_CHANNEL_HIGH:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_PRIO_HI;\n\t\t\tstatus = Write16(state, EC_SB_REG_PRIOR__A, EC_SB_REG_PRIOR_HI, 0x0000);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (p->code_rate_HP) {\n\t\tcase FEC_1_2:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_RATE_1_2;\n\t\t\tif (state->type_A)\n\t\t\t\tstatus = Write16(state, EC_VD_REG_SET_CODERATE__A, EC_VD_REG_SET_CODERATE_C1_2, 0x0000);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toperationMode |= SC_RA_RAM_OP_AUTO_RATE__M;\n\t\t\tfallthrough;\n\t\tcase FEC_2_3:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_RATE_2_3;\n\t\t\tif (state->type_A)\n\t\t\t\tstatus = Write16(state, EC_VD_REG_SET_CODERATE__A, EC_VD_REG_SET_CODERATE_C2_3, 0x0000);\n\t\t\tbreak;\n\t\tcase FEC_3_4:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_RATE_3_4;\n\t\t\tif (state->type_A)\n\t\t\t\tstatus = Write16(state, EC_VD_REG_SET_CODERATE__A, EC_VD_REG_SET_CODERATE_C3_4, 0x0000);\n\t\t\tbreak;\n\t\tcase FEC_5_6:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_RATE_5_6;\n\t\t\tif (state->type_A)\n\t\t\t\tstatus = Write16(state, EC_VD_REG_SET_CODERATE__A, EC_VD_REG_SET_CODERATE_C5_6, 0x0000);\n\t\t\tbreak;\n\t\tcase FEC_7_8:\n\t\t\ttransmissionParams |= SC_RA_RAM_OP_PARAM_RATE_7_8;\n\t\t\tif (state->type_A)\n\t\t\t\tstatus = Write16(state, EC_VD_REG_SET_CODERATE__A, EC_VD_REG_SET_CODERATE_C7_8, 0x0000);\n\t\t\tbreak;\n\t\t}\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\t\t \n\t\t \n\t\tswitch (p->bandwidth_hz) {\n\t\tcase 0:\n\t\t\tp->bandwidth_hz = 8000000;\n\t\t\tfallthrough;\n\t\tcase 8000000:\n\t\t\t \n\t\t\tbandwidth = DRXD_BANDWIDTH_8MHZ_IN_HZ;\n\n\t\t\tbandwidthParam = 0;\n\t\t\tstatus = Write16(state,\n\t\t\t\t\t FE_AG_REG_IND_DEL__A, 50, 0x0000);\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\t \n\t\t\tbandwidth = DRXD_BANDWIDTH_7MHZ_IN_HZ;\n\t\t\tbandwidthParam = 0x4807;\t \n\t\t\tstatus = Write16(state,\n\t\t\t\t\t FE_AG_REG_IND_DEL__A, 59, 0x0000);\n\t\t\tbreak;\n\t\tcase 6000000:\n\t\t\t \n\t\t\tbandwidth = DRXD_BANDWIDTH_6MHZ_IN_HZ;\n\t\t\tbandwidthParam = 0x0F07;\t \n\t\t\tstatus = Write16(state,\n\t\t\t\t\t FE_AG_REG_IND_DEL__A, 71, 0x0000);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = Write16(state, SC_RA_RAM_BAND__A, bandwidthParam, 0x0000);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t{\n\t\t\tu16 sc_config;\n\t\t\tstatus = Read16(state, SC_RA_RAM_CONFIG__A, &sc_config, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif ((p->transmission_mode == TRANSMISSION_MODE_2K) &&\n\t\t\t    (p->guard_interval == GUARD_INTERVAL_1_32)) {\n\t\t\t\t \n\t\t\t\tsc_config |= SC_RA_RAM_CONFIG_SLAVE__M;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsc_config &= ~SC_RA_RAM_CONFIG_SLAVE__M;\n\t\t\t}\n\t\t\tstatus = Write16(state, SC_RA_RAM_CONFIG__A, sc_config, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstatus = SetCfgNoiseCalibration(state, &state->noise_cal);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tif (state->cscd_state == CSCD_INIT) {\n\t\t\t \n\t\t\tstatus = Write16(state, SC_RA_RAM_SAMPLE_RATE_COUNT__A, DRXD_OSCDEV_DO_SCAN, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n \n\t\t\tstate->cscd_state = CSCD_SET;\n\t\t}\n\n\t\t \n\t\t \n\t\tfeIfIncr = MulDiv32(state->sys_clock_freq * 1000,\n\t\t\t\t    (1ULL << 21), bandwidth) - (1 << 23);\n\t\tstatus = Write16(state, FE_IF_REG_INCR0__A, (u16) (feIfIncr & FE_IF_REG_INCR0__M), 0x0000);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, FE_IF_REG_INCR1__A, (u16) ((feIfIncr >> FE_IF_REG_INCR0__W) & FE_IF_REG_INCR1__M), 0x0000);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\t \n\n\t\t \n\t\tSetFrequencyShift(state, off, mirrorFreqSpect);\n\n\t\t \n\n\t\t \n\t\tstatus = Write16(state, SC_COMM_STATE__A, 0, 0x0000);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, SC_COMM_EXEC__A, 1, 0x0000);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n#if 1\n\t\toperationMode = (SC_RA_RAM_OP_AUTO_MODE__M |\n\t\t\t\t SC_RA_RAM_OP_AUTO_GUARD__M |\n\t\t\t\t SC_RA_RAM_OP_AUTO_CONST__M |\n\t\t\t\t SC_RA_RAM_OP_AUTO_HIER__M |\n\t\t\t\t SC_RA_RAM_OP_AUTO_RATE__M);\n#endif\n\t\tstatus = SC_SetPrefParamCommand(state, 0x0000, transmissionParams, operationMode);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tstatus = SC_ProcStartCommand(state, SC_RA_RAM_PROC_LOCKTRACK, SC_RA_RAM_SW_EVENT_RUN_NMASK__M, SC_RA_RAM_LOCKTRACK_MIN);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = StartOC(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tif (state->operation_mode != OM_Default) {\n\t\t\tstatus = StartDiversity(state);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstate->drxd_state = DRXD_STARTED;\n\t} while (0);\n\n\treturn status;\n}\n\nstatic int CDRXD(struct drxd_state *state, u32 IntermediateFrequency)\n{\n\tu32 ulRfAgcOutputLevel = 0xffffffff;\n\tu32 ulRfAgcSettleLevel = 528;\t \n\tu32 ulRfAgcMinLevel = 0;\t \n\tu32 ulRfAgcMaxLevel = DRXD_FE_CTRL_MAX;\t \n\tu32 ulRfAgcSpeed = 0;\t \n\tu32 ulRfAgcMode = 0;\t \n\tu32 ulRfAgcR1 = 820;\n\tu32 ulRfAgcR2 = 2200;\n\tu32 ulRfAgcR3 = 150;\n\tu32 ulIfAgcMode = 0;\t \n\tu32 ulIfAgcOutputLevel = 0xffffffff;\n\tu32 ulIfAgcSettleLevel = 0xffffffff;\n\tu32 ulIfAgcMinLevel = 0xffffffff;\n\tu32 ulIfAgcMaxLevel = 0xffffffff;\n\tu32 ulIfAgcSpeed = 0xffffffff;\n\tu32 ulIfAgcR1 = 820;\n\tu32 ulIfAgcR2 = 2200;\n\tu32 ulIfAgcR3 = 150;\n\tu32 ulClock = state->config.clock;\n\tu32 ulSerialMode = 0;\n\tu32 ulEcOcRegOcModeLop = 4;\t \n\tu32 ulHiI2cDelay = HI_I2C_DELAY;\n\tu32 ulHiI2cBridgeDelay = HI_I2C_BRIDGE_DELAY;\n\tu32 ulHiI2cPatch = 0;\n\tu32 ulEnvironment = APPENV_PORTABLE;\n\tu32 ulEnvironmentDiversity = APPENV_MOBILE;\n\tu32 ulIFFilter = IFFILTER_SAW;\n\n\tstate->if_agc_cfg.ctrlMode = AGC_CTRL_AUTO;\n\tstate->if_agc_cfg.outputLevel = 0;\n\tstate->if_agc_cfg.settleLevel = 140;\n\tstate->if_agc_cfg.minOutputLevel = 0;\n\tstate->if_agc_cfg.maxOutputLevel = 1023;\n\tstate->if_agc_cfg.speed = 904;\n\n\tif (ulIfAgcMode == 1 && ulIfAgcOutputLevel <= DRXD_FE_CTRL_MAX) {\n\t\tstate->if_agc_cfg.ctrlMode = AGC_CTRL_USER;\n\t\tstate->if_agc_cfg.outputLevel = (u16) (ulIfAgcOutputLevel);\n\t}\n\n\tif (ulIfAgcMode == 0 &&\n\t    ulIfAgcSettleLevel <= DRXD_FE_CTRL_MAX &&\n\t    ulIfAgcMinLevel <= DRXD_FE_CTRL_MAX &&\n\t    ulIfAgcMaxLevel <= DRXD_FE_CTRL_MAX &&\n\t    ulIfAgcSpeed <= DRXD_FE_CTRL_MAX) {\n\t\tstate->if_agc_cfg.ctrlMode = AGC_CTRL_AUTO;\n\t\tstate->if_agc_cfg.settleLevel = (u16) (ulIfAgcSettleLevel);\n\t\tstate->if_agc_cfg.minOutputLevel = (u16) (ulIfAgcMinLevel);\n\t\tstate->if_agc_cfg.maxOutputLevel = (u16) (ulIfAgcMaxLevel);\n\t\tstate->if_agc_cfg.speed = (u16) (ulIfAgcSpeed);\n\t}\n\n\tstate->if_agc_cfg.R1 = (u16) (ulIfAgcR1);\n\tstate->if_agc_cfg.R2 = (u16) (ulIfAgcR2);\n\tstate->if_agc_cfg.R3 = (u16) (ulIfAgcR3);\n\n\tstate->rf_agc_cfg.R1 = (u16) (ulRfAgcR1);\n\tstate->rf_agc_cfg.R2 = (u16) (ulRfAgcR2);\n\tstate->rf_agc_cfg.R3 = (u16) (ulRfAgcR3);\n\n\tstate->rf_agc_cfg.ctrlMode = AGC_CTRL_AUTO;\n\t \n\tif (ulRfAgcMode == 1 && ulRfAgcOutputLevel <= DRXD_FE_CTRL_MAX) {\n\t\tstate->rf_agc_cfg.ctrlMode = AGC_CTRL_USER;\n\t\tstate->rf_agc_cfg.outputLevel = (u16) (ulRfAgcOutputLevel);\n\t}\n\n\tif (ulRfAgcMode == 0 &&\n\t    ulRfAgcSettleLevel <= DRXD_FE_CTRL_MAX &&\n\t    ulRfAgcMinLevel <= DRXD_FE_CTRL_MAX &&\n\t    ulRfAgcMaxLevel <= DRXD_FE_CTRL_MAX &&\n\t    ulRfAgcSpeed <= DRXD_FE_CTRL_MAX) {\n\t\tstate->rf_agc_cfg.ctrlMode = AGC_CTRL_AUTO;\n\t\tstate->rf_agc_cfg.settleLevel = (u16) (ulRfAgcSettleLevel);\n\t\tstate->rf_agc_cfg.minOutputLevel = (u16) (ulRfAgcMinLevel);\n\t\tstate->rf_agc_cfg.maxOutputLevel = (u16) (ulRfAgcMaxLevel);\n\t\tstate->rf_agc_cfg.speed = (u16) (ulRfAgcSpeed);\n\t}\n\n\tif (ulRfAgcMode == 2)\n\t\tstate->rf_agc_cfg.ctrlMode = AGC_CTRL_OFF;\n\n\tif (ulEnvironment <= 2)\n\t\tstate->app_env_default = (enum app_env)\n\t\t    (ulEnvironment);\n\tif (ulEnvironmentDiversity <= 2)\n\t\tstate->app_env_diversity = (enum app_env)\n\t\t    (ulEnvironmentDiversity);\n\n\tif (ulIFFilter == IFFILTER_DISCRETE) {\n\t\t \n\t\tstate->noise_cal.cpOpt = 0;\n\t\tstate->noise_cal.cpNexpOfs = 40;\n\t\tstate->noise_cal.tdCal2k = -40;\n\t\tstate->noise_cal.tdCal8k = -24;\n\t} else {\n\t\t \n\t\tstate->noise_cal.cpOpt = 1;\n\t\tstate->noise_cal.cpNexpOfs = 0;\n\t\tstate->noise_cal.tdCal2k = -21;\n\t\tstate->noise_cal.tdCal8k = -24;\n\t}\n\tstate->m_EcOcRegOcModeLop = (u16) (ulEcOcRegOcModeLop);\n\n\tstate->chip_adr = (state->config.demod_address << 1) | 1;\n\tswitch (ulHiI2cPatch) {\n\tcase 1:\n\t\tstate->m_HiI2cPatch = DRXD_HiI2cPatch_1;\n\t\tbreak;\n\tcase 3:\n\t\tstate->m_HiI2cPatch = DRXD_HiI2cPatch_3;\n\t\tbreak;\n\tdefault:\n\t\tstate->m_HiI2cPatch = NULL;\n\t}\n\n\t \n\tstate->intermediate_freq = (u16) (IntermediateFrequency / 1000);\n\t \n\tstate->expected_sys_clock_freq = 48000;\n\t \n\tstate->sys_clock_freq = 48000;\n\tstate->osc_clock_freq = (u16) ulClock;\n\tstate->osc_clock_deviation = 0;\n\tstate->cscd_state = CSCD_INIT;\n\tstate->drxd_state = DRXD_UNINITIALIZED;\n\n\tstate->PGA = 0;\n\tstate->type_A = 0;\n\tstate->tuner_mirrors = 0;\n\n\t \n\tstate->insert_rs_byte = state->config.insert_rs_byte;\n\tstate->enable_parallel = (ulSerialMode != 1);\n\n\t \n\t \n\n\tstate->hi_cfg_timing_div = (u16) ((state->sys_clock_freq / 1000) *\n\t\t\t\t\t  ulHiI2cDelay) / 1000;\n\t \n\t \n\tstate->hi_cfg_bridge_delay = (u16) ((state->osc_clock_freq / 1000) *\n\t\t\t\t\t    ulHiI2cBridgeDelay) / 1000;\n\n\tstate->m_FeAgRegAgPwd = DRXD_DEF_AG_PWD_CONSUMER;\n\t \n\tstate->m_FeAgRegAgAgcSio = DRXD_DEF_AG_AGC_SIO;\n\treturn 0;\n}\n\nstatic int DRXD_init(struct drxd_state *state, const u8 *fw, u32 fw_size)\n{\n\tint status = 0;\n\tu32 driverVersion;\n\n\tif (state->init_done)\n\t\treturn 0;\n\n\tCDRXD(state, state->config.IF ? state->config.IF : 36000000);\n\n\tdo {\n\t\tstate->operation_mode = OM_Default;\n\n\t\tstatus = SetDeviceTypeId(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!state->type_A && state->m_HiI2cPatch) {\n\t\t\tstatus = WriteTable(state, state->m_HiI2cPatch);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (state->type_A) {\n\t\t\t \n\t\t\tstatus = Write16(state, 0x43012D, 0x047f, 0);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstatus = HI_ResetCommand(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = StopAllProcessors(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = InitCC(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstate->osc_clock_deviation = 0;\n\n\t\tif (state->config.osc_deviation)\n\t\t\tstate->osc_clock_deviation =\n\t\t\t    state->config.osc_deviation(state->priv, 0, 0);\n\t\t{\n\t\t\t \n\t\t\ts32 devB;\n\t\t\ts32 devA = (s32) (state->osc_clock_deviation) *\n\t\t\t    (s32) (state->expected_sys_clock_freq);\n\t\t\t \n\t\t\ts32 deviation = (devA / (1000000L));\n\t\t\t \n\t\t\tif (devA > 0)\n\t\t\t\tdevB = (2);\n\t\t\telse\n\t\t\t\tdevB = (-2);\n\t\t\tif ((devB * (devA % 1000000L) > 1000000L)) {\n\t\t\t\t \n\t\t\t\tdeviation += (devB / 2);\n\t\t\t}\n\n\t\t\tstate->sys_clock_freq =\n\t\t\t    (u16) ((state->expected_sys_clock_freq) +\n\t\t\t\t   deviation);\n\t\t}\n\t\tstatus = InitHI(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = InitAtomicRead(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = EnableAndResetMB(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (state->type_A) {\n\t\t\tstatus = ResetCEFR(state);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (fw) {\n\t\t\tstatus = DownloadMicrocode(state, fw, fw_size);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tstatus = DownloadMicrocode(state, state->microcode, state->microcode_length);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (state->PGA) {\n\t\t\tstate->m_FeAgRegAgPwd = DRXD_DEF_AG_PWD_PRO;\n\t\t\tSetCfgPga(state, 0);\t \n\t\t} else {\n\t\t\tstate->m_FeAgRegAgPwd = DRXD_DEF_AG_PWD_CONSUMER;\n\t\t}\n\n\t\tstate->m_FeAgRegAgAgcSio = DRXD_DEF_AG_AGC_SIO;\n\n\t\tstatus = InitFE(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = InitFT(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = InitCP(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = InitCE(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = InitEQ(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = InitEC(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = InitSC(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = SetCfgIfAgc(state, &state->if_agc_cfg);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = SetCfgRfAgc(state, &state->rf_agc_cfg);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstate->cscd_state = CSCD_INIT;\n\t\tstatus = Write16(state, SC_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Write16(state, LC_COMM_EXEC__A, SC_COMM_EXEC_CTL_STOP, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tdriverVersion = (((VERSION_MAJOR / 10) << 4) +\n\t\t\t\t (VERSION_MAJOR % 10)) << 24;\n\t\tdriverVersion += (((VERSION_MINOR / 10) << 4) +\n\t\t\t\t  (VERSION_MINOR % 10)) << 16;\n\t\tdriverVersion += ((VERSION_PATCH / 1000) << 12) +\n\t\t    ((VERSION_PATCH / 100) << 8) +\n\t\t    ((VERSION_PATCH / 10) << 4) + (VERSION_PATCH % 10);\n\n\t\tstatus = Write32(state, SC_RA_RAM_DRIVER_VERSION__AX, driverVersion, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = StopOC(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstate->drxd_state = DRXD_STOPPED;\n\t\tstate->init_done = 1;\n\t\tstatus = 0;\n\t} while (0);\n\treturn status;\n}\n\nstatic int DRXD_status(struct drxd_state *state, u32 *pLockStatus)\n{\n\tDRX_GetLockStatus(state, pLockStatus);\n\n\t \n\tif (*pLockStatus & DRX_LOCK_FEC) {\n\t\tConfigureMPEGOutput(state, 1);\n\t\t \n\t\t \n\t}\n\n\treturn 0;\n}\n\n \n \n \n\nstatic int drxd_read_signal_strength(struct dvb_frontend *fe, u16 * strength)\n{\n\tstruct drxd_state *state = fe->demodulator_priv;\n\tu32 value;\n\tint res;\n\n\tres = ReadIFAgc(state, &value);\n\tif (res < 0)\n\t\t*strength = 0;\n\telse\n\t\t*strength = 0xffff - (value << 4);\n\treturn 0;\n}\n\nstatic int drxd_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct drxd_state *state = fe->demodulator_priv;\n\tu32 lock;\n\n\tDRXD_status(state, &lock);\n\t*status = 0;\n\t \n#if 1\n\tif (lock & DRX_LOCK_MPEG)\n\t\t*status |= FE_HAS_LOCK;\n#else\n\tif (lock & DRX_LOCK_FEC)\n\t\t*status |= FE_HAS_LOCK;\n#endif\n\tif (lock & DRX_LOCK_FEC)\n\t\t*status |= FE_HAS_VITERBI | FE_HAS_SYNC;\n\tif (lock & DRX_LOCK_DEMOD)\n\t\t*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\n\n\treturn 0;\n}\n\nstatic int drxd_init(struct dvb_frontend *fe)\n{\n\tstruct drxd_state *state = fe->demodulator_priv;\n\n\treturn DRXD_init(state, NULL, 0);\n}\n\nstatic int drxd_config_i2c(struct dvb_frontend *fe, int onoff)\n{\n\tstruct drxd_state *state = fe->demodulator_priv;\n\n\tif (state->config.disable_i2c_gate_ctrl == 1)\n\t\treturn 0;\n\n\treturn DRX_ConfigureI2CBridge(state, onoff);\n}\n\nstatic int drxd_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t  struct dvb_frontend_tune_settings *sets)\n{\n\tsets->min_delay_ms = 10000;\n\tsets->max_drift = 0;\n\tsets->step_size = 0;\n\treturn 0;\n}\n\nstatic int drxd_read_ber(struct dvb_frontend *fe, u32 * ber)\n{\n\t*ber = 0;\n\treturn 0;\n}\n\nstatic int drxd_read_snr(struct dvb_frontend *fe, u16 * snr)\n{\n\t*snr = 0;\n\treturn 0;\n}\n\nstatic int drxd_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)\n{\n\t*ucblocks = 0;\n\treturn 0;\n}\n\nstatic int drxd_sleep(struct dvb_frontend *fe)\n{\n\tstruct drxd_state *state = fe->demodulator_priv;\n\n\tConfigureMPEGOutput(state, 0);\n\treturn 0;\n}\n\nstatic int drxd_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\treturn drxd_config_i2c(fe, enable);\n}\n\nstatic int drxd_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct drxd_state *state = fe->demodulator_priv;\n\ts32 off = 0;\n\n\tstate->props = *p;\n\tDRX_Stop(state);\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tmsleep(200);\n\n\treturn DRX_Start(state, off);\n}\n\nstatic void drxd_release(struct dvb_frontend *fe)\n{\n\tstruct drxd_state *state = fe->demodulator_priv;\n\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops drxd_ops = {\n\t.delsys = { SYS_DVBT},\n\t.info = {\n\t\t .name = \"Micronas DRXD DVB-T\",\n\t\t .frequency_min_hz =  47125 * kHz,\n\t\t .frequency_max_hz = 855250 * kHz,\n\t\t .frequency_stepsize_hz = 166667,\n\t\t .caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |\n\t\t FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |\n\t\t FE_CAN_FEC_AUTO |\n\t\t FE_CAN_QAM_16 | FE_CAN_QAM_64 |\n\t\t FE_CAN_QAM_AUTO |\n\t\t FE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t FE_CAN_GUARD_INTERVAL_AUTO |\n\t\t FE_CAN_HIERARCHY_AUTO | FE_CAN_RECOVER | FE_CAN_MUTE_TS},\n\n\t.release = drxd_release,\n\t.init = drxd_init,\n\t.sleep = drxd_sleep,\n\t.i2c_gate_ctrl = drxd_i2c_gate_ctrl,\n\n\t.set_frontend = drxd_set_frontend,\n\t.get_tune_settings = drxd_get_tune_settings,\n\n\t.read_status = drxd_read_status,\n\t.read_ber = drxd_read_ber,\n\t.read_signal_strength = drxd_read_signal_strength,\n\t.read_snr = drxd_read_snr,\n\t.read_ucblocks = drxd_read_ucblocks,\n};\n\nstruct dvb_frontend *drxd_attach(const struct drxd_config *config,\n\t\t\t\t void *priv, struct i2c_adapter *i2c,\n\t\t\t\t struct device *dev)\n{\n\tstruct drxd_state *state = NULL;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tstate->ops = drxd_ops;\n\tstate->dev = dev;\n\tstate->config = *config;\n\tstate->i2c = i2c;\n\tstate->priv = priv;\n\n\tmutex_init(&state->mutex);\n\n\tif (Read16(state, 0, NULL, 0) < 0)\n\t\tgoto error;\n\n\tstate->frontend.ops = drxd_ops;\n\tstate->frontend.demodulator_priv = state;\n\tConfigureMPEGOutput(state, 0);\n\t \n\tCDRXD(state, state->config.IF ? state->config.IF : 36000000);\n\tInitHI(state);\n\n\treturn &state->frontend;\n\nerror:\n\tprintk(KERN_ERR \"drxd: not found\\n\");\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(drxd_attach);\n\nMODULE_DESCRIPTION(\"DRXD driver\");\nMODULE_AUTHOR(\"Micronas\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}