{
  "module_name": "stv6111.c",
  "hash_id": "fb5097b53c8cc7fd713fab0469c15bdd347220bbabe0b999a529c12a7aa3ed2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stv6111.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <asm/div64.h>\n\n#include \"stv6111.h\"\n\n#include <media/dvb_frontend.h>\n\nstruct stv {\n\tstruct i2c_adapter *i2c;\n\tu8 adr;\n\n\tu8 reg[11];\n\tu32 ref_freq;\n\tu32 frequency;\n};\n\nstruct slookup {\n\ts16 value;\n\tu16 reg_value;\n};\n\nstatic const struct slookup lnagain_nf_lookup[] = {\n\t \nstatic const struct slookup gain_channel_agc_nf_lookup[] = {\n\t \n\n\tstate->reg[0x03] = (state->reg[0x03] & ~0x80) | (psel << 7);\n\tstate->reg[0x04] = (div & 0xFF);\n\tstate->reg[0x05] = (((div >> 8) & 0x01) | ((frac & 0x7F) << 1)) & 0xff;\n\tstate->reg[0x06] = ((frac >> 7) & 0xFF);\n\tstate->reg[0x07] = (state->reg[0x07] & ~0x07) | ((frac >> 15) & 0x07);\n\tstate->reg[0x07] = (state->reg[0x07] & ~0xE0) | (icp << 5);\n\n\tstate->reg[0x08] = (state->reg[0x08] & ~0xFC) | ((index - 6) << 2);\n\t \n\tstate->reg[0x09] = (state->reg[0x09] & ~0x0C) | 0x0C;\n\twrite_regs(state, 2, 8);\n\n\twait_for_call_done(state, 0x0C);\n\n\tusleep_range(10000, 12000);\n\n\tread_reg(state, 0x03, &tmp);\n\tif (tmp & 0x10)\t{\n\t\tstate->reg[0x02] &= ~0x80;  \n\t\twrite_regs(state, 2, 1);\n\t}\n\tread_reg(state, 0x08, &tmp);\n\n\tstate->frequency = frequency;\n\n\treturn 0;\n}\n\nstatic int set_params(struct dvb_frontend *fe)\n{\n\tstruct stv *state = fe->tuner_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 freq, cutoff;\n\tint stat = 0;\n\n\tif (p->delivery_system != SYS_DVBS && p->delivery_system != SYS_DVBS2)\n\t\treturn -EINVAL;\n\n\tfreq = p->frequency * 1000;\n\tcutoff = 5000000 + muldiv32(p->symbol_rate, 135, 200);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tstat = fe->ops.i2c_gate_ctrl(fe, 1);\n\tif (!stat)\n\t\tset_lof(state, freq, cutoff);\n\tif (fe->ops.i2c_gate_ctrl && !stat)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\treturn 0;\n}\n\nstatic s32 table_lookup(const struct slookup *table,\n\t\t\tint table_size, u16 reg_value)\n{\n\ts32 gain;\n\ts32 reg_diff;\n\tint imin = 0;\n\tint imax = table_size - 1;\n\tint i;\n\n\t \n\tif (reg_value <= table[0].reg_value) {\n\t\tgain = table[0].value;\n\t} else if (reg_value >= table[imax].reg_value) {\n\t\tgain = table[imax].value;\n\t} else {\n\t\twhile ((imax - imin) > 1) {\n\t\t\ti = (imax + imin) / 2;\n\t\t\tif ((table[imin].reg_value <= reg_value) &&\n\t\t\t    (reg_value <= table[i].reg_value))\n\t\t\t\timax = i;\n\t\t\telse\n\t\t\t\timin = i;\n\t\t}\n\t\treg_diff = table[imax].reg_value - table[imin].reg_value;\n\t\tgain = table[imin].value;\n\t\tif (reg_diff != 0)\n\t\t\tgain += ((s32)(reg_value - table[imin].reg_value) *\n\t\t\t\t(s32)(table[imax].value\n\t\t\t\t- table[imin].value)) / reg_diff;\n\t}\n\treturn gain;\n}\n\nstatic int get_rf_strength(struct dvb_frontend *fe, u16 *st)\n{\n\tstruct stv *state = fe->tuner_priv;\n\tu16 rfagc = *st;\n\ts32 gain;\n\n\tif ((state->reg[0x03] & 0x60) == 0) {\n\t\t \n\t\tu8 reg = 0;\n\t\tint stat = 0;\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tstat = fe->ops.i2c_gate_ctrl(fe, 1);\n\t\tif (!stat) {\n\t\t\twrite_reg(state, 0x02, state->reg[0x02] | 0x20);\n\t\t\tread_reg(state, 2, &reg);\n\t\t\tif (reg & 0x20)\n\t\t\t\tread_reg(state, 2, &reg);\n\t\t}\n\t\tif (fe->ops.i2c_gate_ctrl && !stat)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\t\tif ((state->reg[0x02] & 0x80) == 0)\n\t\t\t \n\t\t\tgain = table_lookup(lnagain_nf_lookup,\n\t\t\t\t\t    ARRAY_SIZE(lnagain_nf_lookup),\n\t\t\t\t\t    reg & 0x1F);\n\t\telse\n\t\t\t \n\t\t\tgain = table_lookup(lnagain_iip3_lookup,\n\t\t\t\t\t    ARRAY_SIZE(lnagain_iip3_lookup),\n\t\t\t\t\t    reg & 0x1F);\n\n\t\tgain += table_lookup(gain_rfagc_lookup,\n\t\t\t\t     ARRAY_SIZE(gain_rfagc_lookup), rfagc);\n\n\t\tgain -= 2400;\n\t} else {\n\t\t \n\t\tif ((state->reg[0x02] & 0x80) == 0) {\n\t\t\t \n\t\t\tgain = table_lookup(\n\t\t\t\tgain_channel_agc_nf_lookup,\n\t\t\t\tARRAY_SIZE(gain_channel_agc_nf_lookup), rfagc);\n\n\t\t\tgain += 600;\n\t\t} else {\n\t\t\t \n\t\t\tgain = table_lookup(\n\t\t\t\tgain_channel_agc_iip3_lookup,\n\t\t\t\tARRAY_SIZE(gain_channel_agc_iip3_lookup),\n\t\t\t\trfagc);\n\t\t}\n\t}\n\n\tif (state->frequency > 0)\n\t\t \n\t\tgain -= ((((s32)(state->frequency / 1000) - 1550) * 2) / 12);\n\n\t \n\tgain +=  (s32)((state->reg[0x01] & 0xC0) >> 6) * 600 - 1300;\n\n\tif (gain < 0)\n\t\tgain = 0;\n\telse if (gain > 10000)\n\t\tgain = 10000;\n\n\t*st = 10000 - gain;\n\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops tuner_ops = {\n\t.info = {\n\t\t.name\t\t= \"ST STV6111\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t},\n\t.set_params\t\t= set_params,\n\t.release\t\t= release,\n\t.get_rf_strength\t= get_rf_strength,\n\t.set_bandwidth\t\t= set_bandwidth,\n};\n\nstruct dvb_frontend *stv6111_attach(struct dvb_frontend *fe,\n\t\t\t\t    struct i2c_adapter *i2c, u8 adr)\n{\n\tstruct stv *state;\n\tint stat = -ENODEV;\n\tint gatestat = 0;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\tstate->adr = adr;\n\tstate->i2c = i2c;\n\tmemcpy(&fe->ops.tuner_ops, &tuner_ops, sizeof(struct dvb_tuner_ops));\n\tinit_state(state);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tgatestat = fe->ops.i2c_gate_ctrl(fe, 1);\n\tif (!gatestat)\n\t\tstat = attach_init(state);\n\tif (fe->ops.i2c_gate_ctrl && !gatestat)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\tif (stat < 0) {\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\tfe->tuner_priv = state;\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(stv6111_attach);\n\nMODULE_DESCRIPTION(\"ST STV6111 satellite tuner driver\");\nMODULE_AUTHOR(\"Ralph Metzler, Manfred Voelkel\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}