{
  "module_name": "tua6100.c",
  "hash_id": "12895b4acab259af269634f302504b203c88dcdb8a5fe5cb707b75470fb958dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tua6100.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/dvb/frontend.h>\n#include <asm/types.h>\n\n#include \"tua6100.h\"\n\nstruct tua6100_priv {\n\t \n\tint i2c_address;\n\tstruct i2c_adapter *i2c;\n\tu32 frequency;\n};\n\nstatic void tua6100_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int tua6100_sleep(struct dvb_frontend *fe)\n{\n\tstruct tua6100_priv *priv = fe->tuner_priv;\n\tint ret;\n\tu8 reg0[] = { 0x00, 0x00 };\n\tstruct i2c_msg msg = { .addr = priv->i2c_address, .flags = 0, .buf = reg0, .len = 2 };\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif ((ret = i2c_transfer (priv->i2c, &msg, 1)) != 1) {\n\t\tprintk(\"%s: i2c error\\n\", __func__);\n\t}\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn (ret == 1) ? 0 : ret;\n}\n\nstatic int tua6100_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct tua6100_priv *priv = fe->tuner_priv;\n\tu32 div;\n\tu32 prediv;\n\tu8 reg0[] = { 0x00, 0x00 };\n\tu8 reg1[] = { 0x01, 0x00, 0x00, 0x00 };\n\tu8 reg2[] = { 0x02, 0x00, 0x00 };\n\tstruct i2c_msg msg0 = { .addr = priv->i2c_address, .flags = 0, .buf = reg0, .len = 2 };\n\tstruct i2c_msg msg1 = { .addr = priv->i2c_address, .flags = 0, .buf = reg1, .len = 4 };\n\tstruct i2c_msg msg2 = { .addr = priv->i2c_address, .flags = 0, .buf = reg2, .len = 3 };\n\n#define _R_VAL 4\n#define _P_VAL 32\n#define _ri 4000000\n\n\t\n\tif (c->frequency < 2000000)\n\t\treg0[1] = 0x03;\n\telse\n\t\treg0[1] = 0x07;\n\n\t\n\tif (c->frequency < 1630000)\n\t\treg1[1] = 0x2c;\n\telse\n\t\treg1[1] = 0x0c;\n\n\tif (_P_VAL == 64)\n\t\treg1[1] |= 0x40;\n\tif (c->frequency >= 1525000)\n\t\treg1[1] |= 0x80;\n\n\t\n\treg2[1] = (_R_VAL >> 8) & 0x03;\n\treg2[2] = _R_VAL;\n\tif (c->frequency < 1455000)\n\t\treg2[1] |= 0x1c;\n\telse if (c->frequency < 1630000)\n\t\treg2[1] |= 0x0c;\n\telse\n\t\treg2[1] |= 0x1c;\n\n\t \n\tprediv = (c->frequency * _R_VAL) / (_ri / 1000);\n\tdiv = prediv / _P_VAL;\n\treg1[1] |= (div >> 9) & 0x03;\n\treg1[2] = div >> 1;\n\treg1[3] = (div << 7);\n\tpriv->frequency = ((div * _P_VAL) * (_ri / 1000)) / _R_VAL;\n\n\t\n\treg1[3] |= (prediv - (div*_P_VAL)) & 0x7f;\n\n#undef _R_VAL\n#undef _P_VAL\n#undef _ri\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(priv->i2c, &msg0, 1) != 1)\n\t\treturn -EIO;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(priv->i2c, &msg2, 1) != 1)\n\t\treturn -EIO;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(priv->i2c, &msg1, 1) != 1)\n\t\treturn -EIO;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\nstatic int tua6100_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct tua6100_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops tua6100_tuner_ops = {\n\t.info = {\n\t\t.name = \"Infineon TUA6100\",\n\t\t.frequency_min_hz  =  950 * MHz,\n\t\t.frequency_max_hz  = 2150 * MHz,\n\t\t.frequency_step_hz =    1 * MHz,\n\t},\n\t.release = tua6100_release,\n\t.sleep = tua6100_sleep,\n\t.set_params = tua6100_set_params,\n\t.get_frequency = tua6100_get_frequency,\n};\n\nstruct dvb_frontend *tua6100_attach(struct dvb_frontend *fe, int addr, struct i2c_adapter *i2c)\n{\n\tstruct tua6100_priv *priv = NULL;\n\tu8 b1 [] = { 0x80 };\n\tu8 b2 [] = { 0x00 };\n\tstruct i2c_msg msg [] = { { .addr = addr, .flags = 0, .buf = b1, .len = 1 },\n\t\t\t\t  { .addr = addr, .flags = I2C_M_RD, .buf = b2, .len = 1 } };\n\tint ret;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tret = i2c_transfer (i2c, msg, 2);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tif (ret != 2)\n\t\treturn NULL;\n\n\tpriv = kzalloc(sizeof(struct tua6100_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\n\tpriv->i2c_address = addr;\n\tpriv->i2c = i2c;\n\n\tmemcpy(&fe->ops.tuner_ops, &tua6100_tuner_ops, sizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = priv;\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(tua6100_attach);\n\nMODULE_DESCRIPTION(\"DVB tua6100 driver\");\nMODULE_AUTHOR(\"Andrew de Quincey\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}