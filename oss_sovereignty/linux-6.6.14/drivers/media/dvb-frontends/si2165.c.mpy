{
  "module_name": "si2165.c",
  "hash_id": "009241de11da9e314679605b3f51f5ea274658f6f7c31f00ae4c341c496ba1e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/si2165.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/firmware.h>\n#include <linux/regmap.h>\n\n#include <media/dvb_frontend.h>\n#include <linux/int_log.h>\n#include \"si2165_priv.h\"\n#include \"si2165.h\"\n\n \n\nstruct si2165_state {\n\tstruct i2c_client *client;\n\n\tstruct regmap *regmap;\n\n\tstruct dvb_frontend fe;\n\n\tstruct si2165_config config;\n\n\tu8 chip_revcode;\n\tu8 chip_type;\n\n\t \n\tu32 fvco_hz;\n\tu32 sys_clk;\n\tu32 adc_clk;\n\n\t \n\tu64 ber_prev;\n\n\tbool has_dvbc;\n\tbool has_dvbt;\n\tbool firmware_loaded;\n};\n\nstatic int si2165_write(struct si2165_state *state, const u16 reg,\n\t\t\tconst u8 *src, const int count)\n{\n\tint ret;\n\n\tdev_dbg(&state->client->dev, \"i2c write: reg: 0x%04x, data: %*ph\\n\",\n\t\treg, count, src);\n\n\tret = regmap_bulk_write(state->regmap, reg, src, count);\n\n\tif (ret)\n\t\tdev_err(&state->client->dev, \"%s: ret == %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int si2165_read(struct si2165_state *state,\n\t\t       const u16 reg, u8 *val, const int count)\n{\n\tint ret = regmap_bulk_read(state->regmap, reg, val, count);\n\n\tif (ret) {\n\t\tdev_err(&state->client->dev, \"%s: error (addr %02x reg %04x error (ret == %i)\\n\",\n\t\t\t__func__, state->config.i2c_addr, reg, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&state->client->dev, \"i2c read: reg: 0x%04x, data: %*ph\\n\",\n\t\treg, count, val);\n\n\treturn 0;\n}\n\nstatic int si2165_readreg8(struct si2165_state *state,\n\t\t\t   const u16 reg, u8 *val)\n{\n\tunsigned int val_tmp;\n\tint ret = regmap_read(state->regmap, reg, &val_tmp);\n\t*val = (u8)val_tmp;\n\tdev_dbg(&state->client->dev, \"reg read: R(0x%04x)=0x%02x\\n\", reg, *val);\n\treturn ret;\n}\n\nstatic int si2165_readreg16(struct si2165_state *state,\n\t\t\t    const u16 reg, u16 *val)\n{\n\tu8 buf[2];\n\n\tint ret = si2165_read(state, reg, buf, 2);\n\t*val = buf[0] | buf[1] << 8;\n\tdev_dbg(&state->client->dev, \"reg read: R(0x%04x)=0x%04x\\n\", reg, *val);\n\treturn ret;\n}\n\nstatic int si2165_readreg24(struct si2165_state *state,\n\t\t\t    const u16 reg, u32 *val)\n{\n\tu8 buf[3];\n\n\tint ret = si2165_read(state, reg, buf, 3);\n\t*val = buf[0] | buf[1] << 8 | buf[2] << 16;\n\tdev_dbg(&state->client->dev, \"reg read: R(0x%04x)=0x%06x\\n\", reg, *val);\n\treturn ret;\n}\n\nstatic int si2165_writereg8(struct si2165_state *state, const u16 reg, u8 val)\n{\n\treturn regmap_write(state->regmap, reg, val);\n}\n\nstatic int si2165_writereg16(struct si2165_state *state, const u16 reg, u16 val)\n{\n\tu8 buf[2] = { val & 0xff, (val >> 8) & 0xff };\n\n\treturn si2165_write(state, reg, buf, 2);\n}\n\nstatic int si2165_writereg24(struct si2165_state *state, const u16 reg, u32 val)\n{\n\tu8 buf[3] = { val & 0xff, (val >> 8) & 0xff, (val >> 16) & 0xff };\n\n\treturn si2165_write(state, reg, buf, 3);\n}\n\nstatic int si2165_writereg32(struct si2165_state *state, const u16 reg, u32 val)\n{\n\tu8 buf[4] = {\n\t\tval & 0xff,\n\t\t(val >> 8) & 0xff,\n\t\t(val >> 16) & 0xff,\n\t\t(val >> 24) & 0xff\n\t};\n\treturn si2165_write(state, reg, buf, 4);\n}\n\nstatic int si2165_writereg_mask8(struct si2165_state *state, const u16 reg,\n\t\t\t\t u8 val, u8 mask)\n{\n\tif (mask != 0xff) {\n\t\tu8 tmp;\n\t\tint ret = si2165_readreg8(state, reg, &tmp);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval &= mask;\n\t\ttmp &= ~mask;\n\t\tval |= tmp;\n\t}\n\treturn si2165_writereg8(state, reg, val);\n}\n\n#define REG16(reg, val) \\\n\t{ (reg), (val) & 0xff }, \\\n\t{ (reg) + 1, (val) >> 8 & 0xff }\nstruct si2165_reg_value_pair {\n\tu16 reg;\n\tu8 val;\n};\n\nstatic int si2165_write_reg_list(struct si2165_state *state,\n\t\t\t\t const struct si2165_reg_value_pair *regs,\n\t\t\t\t int count)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = si2165_writereg8(state, regs[i].reg, regs[i].val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int si2165_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t    struct dvb_frontend_tune_settings *s)\n{\n\ts->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic int si2165_init_pll(struct si2165_state *state)\n{\n\tu32 ref_freq_hz = state->config.ref_freq_hz;\n\tu8 divr = 1;  \n\tu8 divp = 1;  \n\tu8 divn = 56;  \n\tu8 divm = 8;\n\tu8 divl = 12;\n\tu8 buf[4];\n\n\t \n\tswitch (ref_freq_hz) {\n\tcase 16000000u:\n\t\tdivn = 56;\n\t\tbreak;\n\tcase 24000000u:\n\t\tdivr = 2;\n\t\tdivp = 4;\n\t\tdivn = 19;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (ref_freq_hz > 16000000u)\n\t\t\tdivr = 2;\n\n\t\t \n\t\tif (1624000000u * divr > ref_freq_hz * 2u * 63u)\n\t\t\tdivp = 4;\n\n\t\t \n\t\tdivn = 1624000000u * divr / (ref_freq_hz * 2u * divp);\n\t\tbreak;\n\t}\n\n\t \n\tstate->fvco_hz = ref_freq_hz / divr\n\t\t\t* 2u * divn * divp;\n\tstate->adc_clk = state->fvco_hz / (divm * 4u);\n\tstate->sys_clk = state->fvco_hz / (divl * 2u);\n\n\t \n\tbuf[0] = divl;\n\tbuf[1] = divm;\n\tbuf[2] = (divn & 0x3f) | ((divp == 1) ? 0x40 : 0x00) | 0x80;\n\tbuf[3] = divr;\n\treturn si2165_write(state, REG_PLL_DIVL, buf, 4);\n}\n\nstatic int si2165_adjust_pll_divl(struct si2165_state *state, u8 divl)\n{\n\tstate->sys_clk = state->fvco_hz / (divl * 2u);\n\treturn si2165_writereg8(state, REG_PLL_DIVL, divl);\n}\n\nstatic u32 si2165_get_fe_clk(struct si2165_state *state)\n{\n\t \n\treturn state->adc_clk;\n}\n\nstatic int si2165_wait_init_done(struct si2165_state *state)\n{\n\tint ret;\n\tu8 val = 0;\n\tint i;\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tret = si2165_readreg8(state, REG_INIT_DONE, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (val == 0x01)\n\t\t\treturn 0;\n\t\tusleep_range(1000, 50000);\n\t}\n\tdev_err(&state->client->dev, \"init_done was not set\\n\");\n\treturn -EINVAL;\n}\n\nstatic int si2165_upload_firmware_block(struct si2165_state *state,\n\t\t\t\t\tconst u8 *data, u32 len, u32 *poffset,\n\t\t\t\t\tu32 block_count)\n{\n\tint ret;\n\tu8 buf_ctrl[4] = { 0x00, 0x00, 0x00, 0xc0 };\n\tu8 wordcount;\n\tu32 cur_block = 0;\n\tu32 offset = poffset ? *poffset : 0;\n\n\tif (len < 4)\n\t\treturn -EINVAL;\n\tif (len % 4 != 0)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&state->client->dev,\n\t\t\"fw load: %s: called with len=0x%x offset=0x%x blockcount=0x%x\\n\",\n\t\t__func__, len, offset, block_count);\n\twhile (offset + 12 <= len && cur_block < block_count) {\n\t\tdev_dbg(&state->client->dev,\n\t\t\t\"fw load: %s: in while len=0x%x offset=0x%x cur_block=0x%x blockcount=0x%x\\n\",\n\t\t\t__func__, len, offset, cur_block, block_count);\n\t\twordcount = data[offset];\n\t\tif (wordcount < 1 || data[offset + 1] ||\n\t\t    data[offset + 2] || data[offset + 3]) {\n\t\t\tdev_warn(&state->client->dev,\n\t\t\t\t \"bad fw data[0..3] = %*ph\\n\",\n\t\t\t\t 4, data);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (offset + 8 + wordcount * 4 > len) {\n\t\t\tdev_warn(&state->client->dev,\n\t\t\t\t \"len is too small for block len=%d, wordcount=%d\\n\",\n\t\t\t\tlen, wordcount);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbuf_ctrl[0] = wordcount - 1;\n\n\t\tret = si2165_write(state, REG_DCOM_CONTROL_BYTE, buf_ctrl, 4);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tret = si2165_write(state, REG_DCOM_ADDR, data + offset + 4, 4);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\toffset += 8;\n\n\t\twhile (wordcount > 0) {\n\t\t\tret = si2165_write(state, REG_DCOM_DATA,\n\t\t\t\t\t   data + offset, 4);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\twordcount--;\n\t\t\toffset += 4;\n\t\t}\n\t\tcur_block++;\n\t}\n\n\tdev_dbg(&state->client->dev,\n\t\t\"fw load: %s: after while len=0x%x offset=0x%x cur_block=0x%x blockcount=0x%x\\n\",\n\t\t__func__, len, offset, cur_block, block_count);\n\n\tif (poffset)\n\t\t*poffset = offset;\n\n\tdev_dbg(&state->client->dev,\n\t\t\"fw load: %s: returned offset=0x%x\\n\",\n\t\t__func__, offset);\n\n\treturn 0;\nerror:\n\treturn ret;\n}\n\nstatic int si2165_upload_firmware(struct si2165_state *state)\n{\n\t \n\tu8 val[3];\n\tu16 val16;\n\tint ret;\n\n\tconst struct firmware *fw = NULL;\n\tu8 *fw_file;\n\tconst u8 *data;\n\tu32 len;\n\tu32 offset;\n\tu8 patch_version;\n\tu8 block_count;\n\tu16 crc_expected;\n\n\tswitch (state->chip_revcode) {\n\tcase 0x03:  \n\t\tfw_file = SI2165_FIRMWARE_REV_D;\n\t\tbreak;\n\tdefault:\n\t\tdev_info(&state->client->dev, \"no firmware file for revision=%d\\n\",\n\t\t\t state->chip_revcode);\n\t\treturn 0;\n\t}\n\n\t \n\tret = request_firmware(&fw, fw_file, &state->client->dev);\n\tif (ret) {\n\t\tdev_warn(&state->client->dev, \"firmware file '%s' not found\\n\",\n\t\t\t fw_file);\n\t\tgoto error;\n\t}\n\n\tdata = fw->data;\n\tlen = fw->size;\n\n\tdev_info(&state->client->dev, \"downloading firmware from file '%s' size=%d\\n\",\n\t\t fw_file, len);\n\n\tif (len % 4 != 0) {\n\t\tdev_warn(&state->client->dev, \"firmware size is not multiple of 4\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tif (len < 8) {\n\t\tdev_warn(&state->client->dev, \"firmware header is missing\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (data[0] != 1 || data[1] != 0) {\n\t\tdev_warn(&state->client->dev, \"firmware file version is wrong\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tpatch_version = data[2];\n\tblock_count = data[4];\n\tcrc_expected = data[7] << 8 | data[6];\n\n\t \n\t \n\tret = si2165_writereg8(state, REG_WDOG_AND_BOOT, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\t \n\tret = si2165_writereg8(state, REG_RST_ALL, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\t \n\tret = si2165_readreg8(state, REG_WDOG_AND_BOOT, val);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tret = si2165_readreg8(state, REG_EN_RST_ERROR, val);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_readreg8(state, REG_EN_RST_ERROR, val);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_writereg8(state, REG_EN_RST_ERROR, 0x02);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\toffset = 8;\n\n\tdev_info(&state->client->dev, \"%s: extracted patch_version=0x%02x, block_count=0x%02x, crc_expected=0x%04x\\n\",\n\t\t __func__, patch_version, block_count, crc_expected);\n\n\tret = si2165_upload_firmware_block(state, data, len, &offset, 1);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = si2165_writereg8(state, REG_PATCH_VERSION, patch_version);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tret = si2165_writereg8(state, REG_RST_CRC, 0x01);\n\tif (ret)\n\t\tgoto error;\n\n\tret = si2165_upload_firmware_block(state, data, len,\n\t\t\t\t\t   &offset, block_count);\n\tif (ret < 0) {\n\t\tdev_err(&state->client->dev,\n\t\t\t\"firmware could not be uploaded\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tret = si2165_readreg16(state, REG_CRC, &val16);\n\tif (ret)\n\t\tgoto error;\n\n\tif (val16 != crc_expected) {\n\t\tdev_err(&state->client->dev,\n\t\t\t\"firmware crc mismatch %04x != %04x\\n\",\n\t\t\tval16, crc_expected);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tret = si2165_upload_firmware_block(state, data, len, &offset, 5);\n\tif (ret)\n\t\tgoto error;\n\n\tif (len != offset) {\n\t\tdev_err(&state->client->dev,\n\t\t\t\"firmware len mismatch %04x != %04x\\n\",\n\t\t\tlen, offset);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tret = si2165_writereg_mask8(state, REG_WDOG_AND_BOOT, 0x02, 0x02);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tret = si2165_writereg_mask8(state, REG_EN_RST_ERROR, 0x01, 0x01);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdev_info(&state->client->dev, \"fw load finished\\n\");\n\n\tret = 0;\n\tstate->firmware_loaded = true;\nerror:\n\tif (fw) {\n\t\trelease_firmware(fw);\n\t\tfw = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int si2165_init(struct dvb_frontend *fe)\n{\n\tint ret = 0;\n\tstruct si2165_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu8 val;\n\tu8 patch_version = 0x00;\n\n\tdev_dbg(&state->client->dev, \"%s: called\\n\", __func__);\n\n\t \n\tret = si2165_writereg8(state, REG_CHIP_MODE, state->config.chip_mode);\n\tif (ret < 0)\n\t\tgoto error;\n\t \n\tret = si2165_writereg8(state, REG_DSP_CLOCK, 0x01);\n\tif (ret < 0)\n\t\tgoto error;\n\t \n\tret = si2165_readreg8(state, REG_CHIP_MODE, &val);\n\tif (ret < 0)\n\t\tgoto error;\n\tif (val != state->config.chip_mode) {\n\t\tdev_err(&state->client->dev, \"could not set chip_mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = si2165_writereg8(state, REG_AGC_IF_TRI, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_writereg8(state, REG_AGC_IF_SLR, 0x01);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_writereg8(state, REG_AGC2_OUTPUT, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_writereg8(state, REG_AGC2_CLKDIV, 0x07);\n\tif (ret < 0)\n\t\tgoto error;\n\t \n\tret = si2165_writereg8(state, REG_RSSI_PAD_CTRL, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_writereg8(state, REG_RSSI_ENABLE, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = si2165_init_pll(state);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tret = si2165_writereg8(state, REG_CHIP_INIT, 0x01);\n\tif (ret < 0)\n\t\tgoto error;\n\t \n\tret = si2165_writereg8(state, REG_START_INIT, 0x01);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = si2165_wait_init_done(state);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tret = si2165_writereg8(state, REG_CHIP_INIT, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tret = si2165_writereg16(state, REG_BER_PKT,\n\t\t\t\tSTATISTICS_PERIOD_PKT_COUNT);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = si2165_readreg8(state, REG_PATCH_VERSION, &patch_version);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = si2165_writereg8(state, REG_AUTO_RESET, 0x00);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tret = si2165_writereg32(state, REG_ADDR_JUMP, 0xf4000000);\n\tif (ret < 0)\n\t\tgoto error;\n\t \n\tret = si2165_readreg8(state, REG_WDOG_AND_BOOT, &val);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (patch_version == 0x00) {\n\t\tret = si2165_upload_firmware(state);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\t \n\tret = si2165_writereg8(state, REG_TS_DATA_MODE, 0x20);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = si2165_writereg16(state, REG_TS_TRI, 0x00fe);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = si2165_writereg24(state, REG_TS_SLR, 0x555555);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = si2165_writereg8(state, REG_TS_CLK_MODE, 0x01);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = si2165_writereg8(state, REG_TS_PARALLEL_MODE, 0x00);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tc = &state->fe.dtv_property_cache;\n\tc->cnr.len = 1;\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.len = 1;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\treturn 0;\nerror:\n\treturn ret;\n}\n\nstatic int si2165_sleep(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct si2165_state *state = fe->demodulator_priv;\n\n\t \n\tret = si2165_writereg8(state, REG_DSP_CLOCK, 0x00);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tret = si2165_writereg8(state, REG_CHIP_MODE, SI2165_MODE_OFF);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int si2165_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tint ret;\n\tu8 u8tmp;\n\tu32 u32tmp;\n\tstruct si2165_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 delsys = c->delivery_system;\n\n\t*status = 0;\n\n\tswitch (delsys) {\n\tcase SYS_DVBT:\n\t\t \n\t\tret = si2165_readreg8(state, REG_CHECK_SIGNAL, &u8tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tswitch (u8tmp & 0x3) {\n\t\tcase 0:  \n\t\tcase 1:  \n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\t \n\t\tret = si2165_readreg8(state, REG_PS_LOCK, &u8tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (u8tmp & 0x01) {\n\t\t\t*status |= FE_HAS_SIGNAL;\n\t\t\t*status |= FE_HAS_CARRIER;\n\t\t\t*status |= FE_HAS_VITERBI;\n\t\t\t*status |= FE_HAS_SYNC;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tret = si2165_readreg8(state, REG_FEC_LOCK, &u8tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (u8tmp & 0x01) {\n\t\t*status |= FE_HAS_SIGNAL;\n\t\t*status |= FE_HAS_CARRIER;\n\t\t*status |= FE_HAS_VITERBI;\n\t\t*status |= FE_HAS_SYNC;\n\t\t*status |= FE_HAS_LOCK;\n\t}\n\n\t \n\tif (delsys == SYS_DVBC_ANNEX_A && *status & FE_HAS_VITERBI) {\n\t\tret = si2165_readreg24(state, REG_C_N, &u32tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tu32tmp = (1000 * 10 * (121210686 - (u64)intlog10(u32tmp)))\n\t\t\t\t>> 24;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[0].svalue = u32tmp;\n\t} else\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\t \n\tif (*status & FE_HAS_VITERBI) {\n\t\tif (c->post_bit_error.stat[0].scale == FE_SCALE_NOT_AVAILABLE) {\n\t\t\t \n\t\t\tret = si2165_writereg8(state, REG_BER_RST, 0x01);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_error.stat[0].uvalue = 0;\n\t\t\tc->post_bit_count.stat[0].uvalue = 0;\n\n\t\t\t \n\t\t\tstate->ber_prev = 0;\n\n\t\t} else {\n\t\t\tret = si2165_readreg8(state, REG_BER_AVAIL, &u8tmp);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (u8tmp & 1) {\n\t\t\t\tu32 biterrcnt;\n\n\t\t\t\tret = si2165_readreg24(state, REG_BER_BIT,\n\t\t\t\t\t\t\t&biterrcnt);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tc->post_bit_error.stat[0].uvalue +=\n\t\t\t\t\tbiterrcnt;\n\t\t\t\tc->post_bit_count.stat[0].uvalue +=\n\t\t\t\t\tSTATISTICS_PERIOD_BIT_COUNT;\n\n\t\t\t\t \n\t\t\t\tret = si2165_writereg8(state,\n\t\t\t\t\t\t\tREG_BER_RST, 0x01);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tdev_dbg(&state->client->dev,\n\t\t\t\t\t\"post_bit_error=%u post_bit_count=%u\\n\",\n\t\t\t\t\tbiterrcnt, STATISTICS_PERIOD_BIT_COUNT);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn 0;\n}\n\nstatic int si2165_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL)\n\t\t*snr = div_s64(c->cnr.stat[0].svalue, 100);\n\telse\n\t\t*snr = 0;\n\treturn 0;\n}\n\nstatic int si2165_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct si2165_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->post_bit_error.stat[0].scale != FE_SCALE_COUNTER) {\n\t\t*ber = 0;\n\t\treturn 0;\n\t}\n\n\t*ber = c->post_bit_error.stat[0].uvalue - state->ber_prev;\n\tstate->ber_prev = c->post_bit_error.stat[0].uvalue;\n\n\treturn 0;\n}\n\nstatic int si2165_set_oversamp(struct si2165_state *state, u32 dvb_rate)\n{\n\tu64 oversamp;\n\tu32 reg_value;\n\n\tif (!dvb_rate)\n\t\treturn -EINVAL;\n\n\toversamp = si2165_get_fe_clk(state);\n\toversamp <<= 23;\n\tdo_div(oversamp, dvb_rate);\n\treg_value = oversamp & 0x3fffffff;\n\n\tdev_dbg(&state->client->dev, \"Write oversamp=%#x\\n\", reg_value);\n\treturn si2165_writereg32(state, REG_OVERSAMP, reg_value);\n}\n\nstatic int si2165_set_if_freq_shift(struct si2165_state *state)\n{\n\tstruct dvb_frontend *fe = &state->fe;\n\tu64 if_freq_shift;\n\ts32 reg_value = 0;\n\tu32 fe_clk = si2165_get_fe_clk(state);\n\tu32 IF = 0;\n\n\tif (!fe->ops.tuner_ops.get_if_frequency) {\n\t\tdev_err(&state->client->dev,\n\t\t\t\"Error: get_if_frequency() not defined at tuner. Can't work without it!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!fe_clk)\n\t\treturn -EINVAL;\n\n\tfe->ops.tuner_ops.get_if_frequency(fe, &IF);\n\tif_freq_shift = IF;\n\tif_freq_shift <<= 29;\n\n\tdo_div(if_freq_shift, fe_clk);\n\treg_value = (s32)if_freq_shift;\n\n\tif (state->config.inversion)\n\t\treg_value = -reg_value;\n\n\treg_value = reg_value & 0x1fffffff;\n\n\t \n\treturn si2165_writereg32(state, REG_IF_FREQ_SHIFT, reg_value);\n}\n\nstatic const struct si2165_reg_value_pair dvbt_regs[] = {\n\t \n\t{ REG_DVB_STANDARD, 0x01 },\n\t \n\t{ REG_IMPULSIVE_NOISE_REM, 0x01 },\n\t{ REG_AUTO_RESET, 0x00 },\n\t \n\t{ REG_AGC2_MIN, 0x41 },\n\t{ REG_AGC2_KACQ, 0x0e },\n\t{ REG_AGC2_KLOC, 0x10 },\n\t \n\t{ REG_AGC_UNFREEZE_THR, 0x03 },\n\t{ REG_AGC_CRESTF_DBX8, 0x78 },\n\t \n\t{ REG_AAF_CRESTF_DBX8, 0x78 },\n\t{ REG_ACI_CRESTF_DBX8, 0x68 },\n\t \n\tREG16(REG_FREQ_SYNC_RANGE, 0x0064),\n\t \n\t{ REG_GP_REG0_MSB, 0x00 }\n};\n\nstatic int si2165_set_frontend_dvbt(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct si2165_state *state = fe->demodulator_priv;\n\tu32 dvb_rate = 0;\n\tu16 bw10k;\n\tu32 bw_hz = p->bandwidth_hz;\n\n\tdev_dbg(&state->client->dev, \"%s: called\\n\", __func__);\n\n\tif (!state->has_dvbt)\n\t\treturn -EINVAL;\n\n\t \n\tif (bw_hz == 0)\n\t\treturn -EINVAL;\n\n\tdvb_rate = bw_hz * 8 / 7;\n\tbw10k = bw_hz / 10000;\n\n\tret = si2165_adjust_pll_divl(state, 12);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = si2165_writereg16(state, REG_T_BANDWIDTH, bw10k);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = si2165_set_oversamp(state, dvb_rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = si2165_write_reg_list(state, dvbt_regs, ARRAY_SIZE(dvbt_regs));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct si2165_reg_value_pair dvbc_regs[] = {\n\t \n\t{ REG_DVB_STANDARD, 0x05 },\n\n\t \n\t{ REG_AGC2_MIN, 0x50 },\n\t{ REG_AGC2_KACQ, 0x0e },\n\t{ REG_AGC2_KLOC, 0x10 },\n\t \n\t{ REG_AGC_UNFREEZE_THR, 0x03 },\n\t{ REG_AGC_CRESTF_DBX8, 0x68 },\n\t \n\t{ REG_AAF_CRESTF_DBX8, 0x68 },\n\t{ REG_ACI_CRESTF_DBX8, 0x50 },\n\n\t{ REG_EQ_AUTO_CONTROL, 0x0d },\n\n\t{ REG_KP_LOCK, 0x05 },\n\t{ REG_CENTRAL_TAP, 0x09 },\n\tREG16(REG_UNKNOWN_350, 0x3e80),\n\n\t{ REG_AUTO_RESET, 0x01 },\n\tREG16(REG_UNKNOWN_24C, 0x0000),\n\tREG16(REG_UNKNOWN_27C, 0x0000),\n\t{ REG_SWEEP_STEP, 0x03 },\n\t{ REG_AGC_IF_TRI, 0x00 },\n};\n\nstatic int si2165_set_frontend_dvbc(struct dvb_frontend *fe)\n{\n\tstruct si2165_state *state = fe->demodulator_priv;\n\tint ret;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tconst u32 dvb_rate = p->symbol_rate;\n\tu8 u8tmp;\n\n\tif (!state->has_dvbc)\n\t\treturn -EINVAL;\n\n\tif (dvb_rate == 0)\n\t\treturn -EINVAL;\n\n\tret = si2165_adjust_pll_divl(state, 14);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = si2165_set_oversamp(state, dvb_rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (p->modulation) {\n\tcase QPSK:\n\t\tu8tmp = 0x3;\n\t\tbreak;\n\tcase QAM_16:\n\t\tu8tmp = 0x7;\n\t\tbreak;\n\tcase QAM_32:\n\t\tu8tmp = 0x8;\n\t\tbreak;\n\tcase QAM_64:\n\t\tu8tmp = 0x9;\n\t\tbreak;\n\tcase QAM_128:\n\t\tu8tmp = 0xa;\n\t\tbreak;\n\tcase QAM_256:\n\tdefault:\n\t\tu8tmp = 0xb;\n\t\tbreak;\n\t}\n\tret = si2165_writereg8(state, REG_REQ_CONSTELLATION, u8tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = si2165_writereg32(state, REG_LOCK_TIMEOUT, 0x007a1200);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = si2165_write_reg_list(state, dvbc_regs, ARRAY_SIZE(dvbc_regs));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct si2165_reg_value_pair adc_rewrite[] = {\n\t{ REG_ADC_RI1, 0x46 },\n\t{ REG_ADC_RI3, 0x00 },\n\t{ REG_ADC_RI5, 0x0a },\n\t{ REG_ADC_RI6, 0xff },\n\t{ REG_ADC_RI8, 0x70 }\n};\n\nstatic int si2165_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct si2165_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 delsys = p->delivery_system;\n\tint ret;\n\tu8 val[3];\n\n\t \n\tret = si2165_set_if_freq_shift(state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (delsys) {\n\tcase SYS_DVBT:\n\t\tret = si2165_set_frontend_dvbt(fe);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tret = si2165_set_frontend_dvbc(fe);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = si2165_writereg32(state, REG_ADDR_JUMP, 0xf4000000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\n\t \n\tret = si2165_set_if_freq_shift(state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = si2165_readreg8(state, REG_WDOG_AND_BOOT, val);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = si2165_writereg8(state, REG_WDOG_AND_BOOT, 0x00);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = si2165_writereg8(state, REG_RST_ALL, 0x00);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tret = si2165_writereg32(state, REG_GP_REG0_LSB, 0x00000000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = si2165_write_reg_list(state, adc_rewrite,\n\t\t\t\t    ARRAY_SIZE(adc_rewrite));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = si2165_writereg8(state, REG_START_SYNCHRO, 0x01);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tret = si2165_readreg8(state, REG_WDOG_AND_BOOT, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops si2165_ops = {\n\t.info = {\n\t\t.name = \"Silicon Labs \",\n\t\t  \n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 7200000,\n\t\t \n\t\t.frequency_stepsize_hz = 166667,\n\t\t.caps = FE_CAN_FEC_1_2 |\n\t\t\tFE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 |\n\t\t\tFE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK |\n\t\t\tFE_CAN_QAM_16 |\n\t\t\tFE_CAN_QAM_32 |\n\t\t\tFE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_128 |\n\t\t\tFE_CAN_QAM_256 |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO |\n\t\t\tFE_CAN_MUTE_TS |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_RECOVER\n\t},\n\n\t.get_tune_settings = si2165_get_tune_settings,\n\n\t.init = si2165_init,\n\t.sleep = si2165_sleep,\n\n\t.set_frontend      = si2165_set_frontend,\n\t.read_status       = si2165_read_status,\n\t.read_snr          = si2165_read_snr,\n\t.read_ber          = si2165_read_ber,\n};\n\nstatic int si2165_probe(struct i2c_client *client)\n{\n\tstruct si2165_state *state = NULL;\n\tstruct si2165_platform_data *pdata = client->dev.platform_data;\n\tint n;\n\tint ret = 0;\n\tu8 val;\n\tchar rev_char;\n\tconst char *chip_name;\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits = 16,\n\t\t.val_bits = 8,\n\t\t.max_register = 0x08ff,\n\t};\n\n\t \n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tstate->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(state->regmap)) {\n\t\tret = PTR_ERR(state->regmap);\n\t\tgoto error;\n\t}\n\n\t \n\tstate->client = client;\n\tstate->config.i2c_addr = client->addr;\n\tstate->config.chip_mode = pdata->chip_mode;\n\tstate->config.ref_freq_hz = pdata->ref_freq_hz;\n\tstate->config.inversion = pdata->inversion;\n\n\tif (state->config.ref_freq_hz < 4000000 ||\n\t    state->config.ref_freq_hz > 27000000) {\n\t\tdev_err(&state->client->dev, \"ref_freq of %d Hz not supported by this driver\\n\",\n\t\t\tstate->config.ref_freq_hz);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tmemcpy(&state->fe.ops, &si2165_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\tstate->fe.ops.release = NULL;\n\tstate->fe.demodulator_priv = state;\n\ti2c_set_clientdata(client, state);\n\n\t \n\tret = si2165_writereg8(state, REG_CHIP_MODE, state->config.chip_mode);\n\tif (ret < 0)\n\t\tgoto nodev_error;\n\n\tret = si2165_readreg8(state, REG_CHIP_MODE, &val);\n\tif (ret < 0)\n\t\tgoto nodev_error;\n\tif (val != state->config.chip_mode)\n\t\tgoto nodev_error;\n\n\tret = si2165_readreg8(state, REG_CHIP_REVCODE, &state->chip_revcode);\n\tif (ret < 0)\n\t\tgoto nodev_error;\n\n\tret = si2165_readreg8(state, REV_CHIP_TYPE, &state->chip_type);\n\tif (ret < 0)\n\t\tgoto nodev_error;\n\n\t \n\tret = si2165_writereg8(state, REG_CHIP_MODE, SI2165_MODE_OFF);\n\tif (ret < 0)\n\t\tgoto nodev_error;\n\n\tif (state->chip_revcode < 26)\n\t\trev_char = 'A' + state->chip_revcode;\n\telse\n\t\trev_char = '?';\n\n\tswitch (state->chip_type) {\n\tcase 0x06:\n\t\tchip_name = \"Si2161\";\n\t\tstate->has_dvbt = true;\n\t\tbreak;\n\tcase 0x07:\n\t\tchip_name = \"Si2165\";\n\t\tstate->has_dvbt = true;\n\t\tstate->has_dvbc = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&state->client->dev, \"Unsupported Silicon Labs chip (type %d, rev %d)\\n\",\n\t\t\tstate->chip_type, state->chip_revcode);\n\t\tgoto nodev_error;\n\t}\n\n\tdev_info(&state->client->dev,\n\t\t \"Detected Silicon Labs %s-%c (type %d, rev %d)\\n\",\n\t\tchip_name, rev_char, state->chip_type,\n\t\tstate->chip_revcode);\n\n\tstrlcat(state->fe.ops.info.name, chip_name,\n\t\tsizeof(state->fe.ops.info.name));\n\n\tn = 0;\n\tif (state->has_dvbt) {\n\t\tstate->fe.ops.delsys[n++] = SYS_DVBT;\n\t\tstrlcat(state->fe.ops.info.name, \" DVB-T\",\n\t\t\tsizeof(state->fe.ops.info.name));\n\t}\n\tif (state->has_dvbc) {\n\t\tstate->fe.ops.delsys[n++] = SYS_DVBC_ANNEX_A;\n\t\tstrlcat(state->fe.ops.info.name, \" DVB-C\",\n\t\t\tsizeof(state->fe.ops.info.name));\n\t}\n\n\t \n\t*pdata->fe = &state->fe;\n\n\treturn 0;\n\nnodev_error:\n\tret = -ENODEV;\nerror:\n\tkfree(state);\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void si2165_remove(struct i2c_client *client)\n{\n\tstruct si2165_state *state = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tkfree(state);\n}\n\nstatic const struct i2c_device_id si2165_id_table[] = {\n\t{\"si2165\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, si2165_id_table);\n\nstatic struct i2c_driver si2165_driver = {\n\t.driver = {\n\t\t.name\t= \"si2165\",\n\t},\n\t.probe\t\t= si2165_probe,\n\t.remove\t\t= si2165_remove,\n\t.id_table\t= si2165_id_table,\n};\n\nmodule_i2c_driver(si2165_driver);\n\nMODULE_DESCRIPTION(\"Silicon Labs Si2165 DVB-C/-T Demodulator driver\");\nMODULE_AUTHOR(\"Matthias Schwarzott <zzam@gentoo.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(SI2165_FIRMWARE_REV_D);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}