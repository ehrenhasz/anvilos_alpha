{
  "module_name": "cx24117.c",
  "hash_id": "9682f9c892faf5d2135b99ba5d1df76329c80bf9d2be2748714b7f42caeb273d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cx24117.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/firmware.h>\n\n#include \"tuner-i2c.h\"\n#include <media/dvb_frontend.h>\n#include \"cx24117.h\"\n\n\n#define CX24117_DEFAULT_FIRMWARE \"dvb-fe-cx24117.fw\"\n#define CX24117_SEARCH_RANGE_KHZ 5000\n\n \n#define CX24117_REG_COMMAND      (0x00)       \n#define CX24117_REG_EXECUTE      (0x1f)       \n\n#define CX24117_REG_FREQ3_0      (0x34)       \n#define CX24117_REG_FREQ2_0      (0x35)\n#define CX24117_REG_FREQ1_0      (0x36)\n#define CX24117_REG_STATE0       (0x39)\n#define CX24117_REG_SSTATUS0     (0x3a)       \n#define CX24117_REG_SIGNAL0      (0x3b)\n#define CX24117_REG_FREQ5_0      (0x3c)       \n#define CX24117_REG_FREQ6_0      (0x3d)\n#define CX24117_REG_SRATE2_0     (0x3e)       \n#define CX24117_REG_SRATE1_0     (0x3f)\n#define CX24117_REG_QUALITY2_0   (0x40)\n#define CX24117_REG_QUALITY1_0   (0x41)\n\n#define CX24117_REG_BER4_0       (0x47)\n#define CX24117_REG_BER3_0       (0x48)\n#define CX24117_REG_BER2_0       (0x49)\n#define CX24117_REG_BER1_0       (0x4a)\n#define CX24117_REG_DVBS_UCB2_0  (0x4b)\n#define CX24117_REG_DVBS_UCB1_0  (0x4c)\n#define CX24117_REG_DVBS2_UCB2_0 (0x50)\n#define CX24117_REG_DVBS2_UCB1_0 (0x51)\n#define CX24117_REG_QSTATUS0     (0x93)\n#define CX24117_REG_CLKDIV0      (0xe6)\n#define CX24117_REG_RATEDIV0     (0xf0)\n\n\n#define CX24117_REG_FREQ3_1      (0x55)       \n#define CX24117_REG_FREQ2_1      (0x56)\n#define CX24117_REG_FREQ1_1      (0x57)\n#define CX24117_REG_STATE1       (0x5a)\n#define CX24117_REG_SSTATUS1     (0x5b)       \n#define CX24117_REG_SIGNAL1      (0x5c)\n#define CX24117_REG_FREQ5_1      (0x5d)       \n#define CX24117_REG_FREQ4_1      (0x5e)\n#define CX24117_REG_SRATE2_1     (0x5f)\n#define CX24117_REG_SRATE1_1     (0x60)\n#define CX24117_REG_QUALITY2_1   (0x61)\n#define CX24117_REG_QUALITY1_1   (0x62)\n#define CX24117_REG_BER4_1       (0x68)\n#define CX24117_REG_BER3_1       (0x69)\n#define CX24117_REG_BER2_1       (0x6a)\n#define CX24117_REG_BER1_1       (0x6b)\n#define CX24117_REG_DVBS_UCB2_1  (0x6c)\n#define CX24117_REG_DVBS_UCB1_1  (0x6d)\n#define CX24117_REG_DVBS2_UCB2_1 (0x71)\n#define CX24117_REG_DVBS2_UCB1_1 (0x72)\n#define CX24117_REG_QSTATUS1     (0x9f)\n#define CX24117_REG_CLKDIV1      (0xe7)\n#define CX24117_REG_RATEDIV1     (0xf1)\n\n\n \n#define CX24117_ARGLEN       (0x1e)\n\n \n#define CX24117_ROLLOFF_020  (0x00)\n#define CX24117_ROLLOFF_025  (0x01)\n#define CX24117_ROLLOFF_035  (0x02)\n\n \n#define CX24117_PILOT_OFF    (0x00)\n#define CX24117_PILOT_ON     (0x40)\n#define CX24117_PILOT_AUTO   (0x80)\n\n \n#define CX24117_HAS_SIGNAL   (0x01)\n#define CX24117_HAS_CARRIER  (0x02)\n#define CX24117_HAS_VITERBI  (0x04)\n#define CX24117_HAS_SYNCLOCK (0x08)\n#define CX24117_STATUS_MASK  (0x0f)\n#define CX24117_SIGNAL_MASK  (0xc0)\n\n\n \n#define CX24117_DISEQC_DEMOD  (1)\n#define CX24117_DISEQC_BURST  (2)\n#define CX24117_DISEQC_ARG3_2 (3)    \n#define CX24117_DISEQC_ARG4_0 (4)    \n#define CX24117_DISEQC_ARG5_0 (5)    \n#define CX24117_DISEQC_MSGLEN (6)\n#define CX24117_DISEQC_MSGOFS (7)\n\n \n#define CX24117_DISEQC_MINI_A (0)\n#define CX24117_DISEQC_MINI_B (1)\n\n\n#define CX24117_PNE\t(0)  \n#define CX24117_OCC\t(1)  \n\n\nenum cmds {\n\tCMD_SET_VCOFREQ    = 0x10,\n\tCMD_TUNEREQUEST    = 0x11,\n\tCMD_GLOBAL_MPEGCFG = 0x13,\n\tCMD_MPEGCFG        = 0x14,\n\tCMD_TUNERINIT      = 0x15,\n\tCMD_GET_SRATE      = 0x18,\n\tCMD_SET_GOLDCODE   = 0x19,\n\tCMD_GET_AGCACC     = 0x1a,\n\tCMD_DEMODINIT      = 0x1b,\n\tCMD_GETCTLACC      = 0x1c,\n\n\tCMD_LNBCONFIG      = 0x20,\n\tCMD_LNBSEND        = 0x21,\n\tCMD_LNBDCLEVEL     = 0x22,\n\tCMD_LNBPCBCONFIG   = 0x23,\n\tCMD_LNBSENDTONEBST = 0x24,\n\tCMD_LNBUPDREPLY    = 0x25,\n\n\tCMD_SET_GPIOMODE   = 0x30,\n\tCMD_SET_GPIOEN     = 0x31,\n\tCMD_SET_GPIODIR    = 0x32,\n\tCMD_SET_GPIOOUT    = 0x33,\n\tCMD_ENABLERSCORR   = 0x34,\n\tCMD_FWVERSION      = 0x35,\n\tCMD_SET_SLEEPMODE  = 0x36,\n\tCMD_BERCTRL        = 0x3c,\n\tCMD_EVENTCTRL      = 0x3d,\n};\n\nstatic LIST_HEAD(hybrid_tuner_instance_list);\nstatic DEFINE_MUTEX(cx24117_list_mutex);\n\n \nstruct cx24117_tuning {\n\tu32 frequency;\n\tu32 symbol_rate;\n\tenum fe_spectral_inversion inversion;\n\tenum fe_code_rate fec;\n\n\tenum fe_delivery_system delsys;\n\tenum fe_modulation modulation;\n\tenum fe_pilot pilot;\n\tenum fe_rolloff rolloff;\n\n\t \n\tu8 fec_val;\n\tu8 fec_mask;\n\tu8 inversion_val;\n\tu8 pilot_val;\n\tu8 rolloff_val;\n};\n\n \nstruct cx24117_cmd {\n\tu8 len;\n\tu8 args[CX24117_ARGLEN];\n};\n\n \nstruct cx24117_priv {\n\tu8 demod_address;\n\tstruct i2c_adapter *i2c;\n\tu8 skip_fw_load;\n\tstruct mutex fe_lock;\n\n\t \n\tstruct tuner_i2c_props i2c_props;\n\tstruct list_head hybrid_tuner_instance_list;\n};\n\n \nstruct cx24117_state {\n\tstruct cx24117_priv *priv;\n\tstruct dvb_frontend frontend;\n\n\tstruct cx24117_tuning dcur;\n\tstruct cx24117_tuning dnxt;\n\tstruct cx24117_cmd dsec_cmd;\n\n\tint demod;\n};\n\n \n \nstatic struct cx24117_modfec {\n\tenum fe_delivery_system delivery_system;\n\tenum fe_modulation modulation;\n\tenum fe_code_rate fec;\n\tu8 mask;\t \n\tu8 val;\t\t \n} cx24117_modfec_modes[] = {\n\t \n\n\t \n\t{ SYS_DVBS, QPSK, FEC_NONE, 0xfe, 0x30 },\n\t{ SYS_DVBS, QPSK, FEC_1_2,  0x02, 0x2e },  \n\t{ SYS_DVBS, QPSK, FEC_2_3,  0x04, 0x2f },  \n\t{ SYS_DVBS, QPSK, FEC_3_4,  0x08, 0x30 },  \n\t{ SYS_DVBS, QPSK, FEC_4_5,  0xfe, 0x30 },  \n\t{ SYS_DVBS, QPSK, FEC_5_6,  0x20, 0x31 },  \n\t{ SYS_DVBS, QPSK, FEC_6_7,  0xfe, 0x30 },  \n\t{ SYS_DVBS, QPSK, FEC_7_8,  0x80, 0x32 },  \n\t{ SYS_DVBS, QPSK, FEC_8_9,  0xfe, 0x30 },  \n\t{ SYS_DVBS, QPSK, FEC_AUTO, 0xfe, 0x30 },\n\t \n\t{ SYS_DVBS2, QPSK, FEC_NONE, 0x00, 0x00 },\n\t{ SYS_DVBS2, QPSK, FEC_1_2,  0x00, 0x04 },\n\t{ SYS_DVBS2, QPSK, FEC_3_5,  0x00, 0x05 },\n\t{ SYS_DVBS2, QPSK, FEC_2_3,  0x00, 0x06 },\n\t{ SYS_DVBS2, QPSK, FEC_3_4,  0x00, 0x07 },\n\t{ SYS_DVBS2, QPSK, FEC_4_5,  0x00, 0x08 },\n\t{ SYS_DVBS2, QPSK, FEC_5_6,  0x00, 0x09 },\n\t{ SYS_DVBS2, QPSK, FEC_8_9,  0x00, 0x0a },\n\t{ SYS_DVBS2, QPSK, FEC_9_10, 0x00, 0x0b },\n\t{ SYS_DVBS2, QPSK, FEC_AUTO, 0x00, 0x00 },\n\t \n\t{ SYS_DVBS2, PSK_8, FEC_NONE, 0x00, 0x00 },\n\t{ SYS_DVBS2, PSK_8, FEC_3_5,  0x00, 0x0c },\n\t{ SYS_DVBS2, PSK_8, FEC_2_3,  0x00, 0x0d },\n\t{ SYS_DVBS2, PSK_8, FEC_3_4,  0x00, 0x0e },\n\t{ SYS_DVBS2, PSK_8, FEC_5_6,  0x00, 0x0f },\n\t{ SYS_DVBS2, PSK_8, FEC_8_9,  0x00, 0x10 },\n\t{ SYS_DVBS2, PSK_8, FEC_9_10, 0x00, 0x11 },\n\t{ SYS_DVBS2, PSK_8, FEC_AUTO, 0x00, 0x00 },\n\t \n};\n\n\nstatic int cx24117_writereg(struct cx24117_state *state, u8 reg, u8 data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->priv->demod_address,\n\t\t.flags = 0, .buf = buf, .len = 2 };\n\tint ret;\n\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\t\"%s() demod%d i2c wr @0x%02x=0x%02x\\n\",\n\t\t\t__func__, state->demod, reg, data);\n\n\tret = i2c_transfer(state->priv->i2c, &msg, 1);\n\tif (ret < 0) {\n\t\tdev_warn(&state->priv->i2c->dev,\n\t\t\t\"%s: demod%d i2c wr err(%i) @0x%02x=0x%02x\\n\",\n\t\t\tKBUILD_MODNAME, state->demod, ret, reg, data);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int cx24117_writecmd(struct cx24117_state *state,\n\tstruct cx24117_cmd *cmd)\n{\n\tstruct i2c_msg msg;\n\tu8 buf[CX24117_ARGLEN+1];\n\tint ret;\n\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\t\"%s() demod%d i2c wr cmd len=%d\\n\",\n\t\t\t__func__, state->demod, cmd->len);\n\n\tbuf[0] = CX24117_REG_COMMAND;\n\tmemcpy(&buf[1], cmd->args, cmd->len);\n\n\tmsg.addr = state->priv->demod_address;\n\tmsg.flags = 0;\n\tmsg.len = cmd->len+1;\n\tmsg.buf = buf;\n\tret = i2c_transfer(state->priv->i2c, &msg, 1);\n\tif (ret < 0) {\n\t\tdev_warn(&state->priv->i2c->dev,\n\t\t\t\"%s: demod%d i2c wr cmd err(%i) len=%d\\n\",\n\t\t\tKBUILD_MODNAME, state->demod, ret, cmd->len);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int cx24117_readreg(struct cx24117_state *state, u8 reg)\n{\n\tint ret;\n\tu8 recv = 0;\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->priv->demod_address, .flags = 0,\n\t\t\t.buf = &reg, .len = 1 },\n\t\t{ .addr = state->priv->demod_address, .flags = I2C_M_RD,\n\t\t\t.buf = &recv, .len = 1 }\n\t};\n\n\tret = i2c_transfer(state->priv->i2c, msg, 2);\n\tif (ret < 0) {\n\t\tdev_warn(&state->priv->i2c->dev,\n\t\t\t\"%s: demod%d i2c rd err(%d) @0x%x\\n\",\n\t\t\tKBUILD_MODNAME, state->demod, ret, reg);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d i2c rd @0x%02x=0x%02x\\n\",\n\t\t__func__, state->demod, reg, recv);\n\n\treturn recv;\n}\n\nstatic int cx24117_readregN(struct cx24117_state *state,\n\tu8 reg, u8 *buf, int len)\n{\n\tint ret;\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->priv->demod_address, .flags = 0,\n\t\t\t.buf = &reg, .len = 1 },\n\t\t{ .addr = state->priv->demod_address, .flags = I2C_M_RD,\n\t\t\t.buf = buf, .len = len }\n\t};\n\n\tret = i2c_transfer(state->priv->i2c, msg, 2);\n\tif (ret < 0) {\n\t\tdev_warn(&state->priv->i2c->dev,\n\t\t\t\"%s: demod%d i2c rd err(%d) @0x%x\\n\",\n\t\t\tKBUILD_MODNAME, state->demod, ret, reg);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int cx24117_set_inversion(struct cx24117_state *state,\n\tenum fe_spectral_inversion inversion)\n{\n\tdev_dbg(&state->priv->i2c->dev, \"%s(%d) demod%d\\n\",\n\t\t__func__, inversion, state->demod);\n\n\tswitch (inversion) {\n\tcase INVERSION_OFF:\n\t\tstate->dnxt.inversion_val = 0x00;\n\t\tbreak;\n\tcase INVERSION_ON:\n\t\tstate->dnxt.inversion_val = 0x04;\n\t\tbreak;\n\tcase INVERSION_AUTO:\n\t\tstate->dnxt.inversion_val = 0x0C;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstate->dnxt.inversion = inversion;\n\n\treturn 0;\n}\n\nstatic int cx24117_lookup_fecmod(struct cx24117_state *state,\n\tenum fe_delivery_system d, enum fe_modulation m, enum fe_code_rate f)\n{\n\tint i, ret = -EINVAL;\n\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s(demod(0x%02x,0x%02x) demod%d\\n\",\n\t\t__func__, m, f, state->demod);\n\n\tfor (i = 0; i < ARRAY_SIZE(cx24117_modfec_modes); i++) {\n\t\tif ((d == cx24117_modfec_modes[i].delivery_system) &&\n\t\t\t(m == cx24117_modfec_modes[i].modulation) &&\n\t\t\t(f == cx24117_modfec_modes[i].fec)) {\n\t\t\t\tret = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int cx24117_set_fec(struct cx24117_state *state,\n\t\t\t   enum fe_delivery_system delsys,\n\t\t\t   enum fe_modulation mod,\n\t\t\t   enum fe_code_rate fec)\n{\n\tint ret;\n\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s(0x%02x,0x%02x) demod%d\\n\",\n\t\t__func__, mod, fec, state->demod);\n\n\tret = cx24117_lookup_fecmod(state, delsys, mod, fec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstate->dnxt.fec = fec;\n\tstate->dnxt.fec_val = cx24117_modfec_modes[ret].val;\n\tstate->dnxt.fec_mask = cx24117_modfec_modes[ret].mask;\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s() demod%d mask/val = 0x%02x/0x%02x\\n\", __func__,\n\t\tstate->demod, state->dnxt.fec_mask, state->dnxt.fec_val);\n\n\treturn 0;\n}\n\nstatic int cx24117_set_symbolrate(struct cx24117_state *state, u32 rate)\n{\n\tdev_dbg(&state->priv->i2c->dev, \"%s(%d) demod%d\\n\",\n\t\t__func__, rate, state->demod);\n\n\tstate->dnxt.symbol_rate = rate;\n\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s() demod%d symbol_rate = %d\\n\",\n\t\t__func__, state->demod, rate);\n\n\treturn 0;\n}\n\nstatic int cx24117_load_firmware(struct dvb_frontend *fe,\n\tconst struct firmware *fw);\n\nstatic int cx24117_firmware_ondemand(struct dvb_frontend *fe)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tconst struct firmware *fw;\n\tint ret = 0;\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d skip_fw_load=%d\\n\",\n\t\t__func__, state->demod, state->priv->skip_fw_load);\n\n\tif (state->priv->skip_fw_load)\n\t\treturn 0;\n\n\t \n\tif (cx24117_readreg(state, 0xeb) != 0xa) {\n\t\t \n\t\t \n\t\tdev_dbg(&state->priv->i2c->dev,\n\t\t\t\"%s: Waiting for firmware upload (%s)...\\n\",\n\t\t\t__func__, CX24117_DEFAULT_FIRMWARE);\n\t\tret = request_firmware(&fw, CX24117_DEFAULT_FIRMWARE,\n\t\t\tstate->priv->i2c->dev.parent);\n\t\tdev_dbg(&state->priv->i2c->dev,\n\t\t\t\"%s: Waiting for firmware upload(2)...\\n\", __func__);\n\t\tif (ret) {\n\t\t\tdev_err(&state->priv->i2c->dev,\n\t\t\t\t\"%s: No firmware uploaded (timeout or file not found?)\\n\",\n__func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tstate->priv->skip_fw_load = 1;\n\n\t\tret = cx24117_load_firmware(fe, fw);\n\t\tif (ret)\n\t\t\tdev_err(&state->priv->i2c->dev,\n\t\t\t\t\"%s: Writing firmware failed\\n\", __func__);\n\t\trelease_firmware(fw);\n\n\t\tdev_info(&state->priv->i2c->dev,\n\t\t\t\"%s: Firmware upload %s\\n\", __func__,\n\t\t\tret == 0 ? \"complete\" : \"failed\");\n\n\t\t \n\t\tstate->priv->skip_fw_load = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int cx24117_cmd_execute_nolock(struct dvb_frontend *fe,\n\tstruct cx24117_cmd *cmd)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d\\n\",\n\t\t__func__, state->demod);\n\n\t \n\tret = cx24117_firmware_ondemand(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tcx24117_writecmd(state, cmd);\n\n\t \n\tcx24117_writereg(state, CX24117_REG_EXECUTE, 0x01);\n\ti = 0;\n\twhile (cx24117_readreg(state, CX24117_REG_EXECUTE)) {\n\t\tmsleep(20);\n\t\tif (i++ > 40) {\n\t\t\t \n\t\t\tdev_warn(&state->priv->i2c->dev,\n\t\t\t\t\"%s() Firmware not responding\\n\", __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cx24117_cmd_execute(struct dvb_frontend *fe, struct cx24117_cmd *cmd)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tmutex_lock(&state->priv->fe_lock);\n\tret = cx24117_cmd_execute_nolock(fe, cmd);\n\tmutex_unlock(&state->priv->fe_lock);\n\n\treturn ret;\n}\n\nstatic int cx24117_load_firmware(struct dvb_frontend *fe,\n\tconst struct firmware *fw)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tstruct cx24117_cmd cmd;\n\tint i, ret;\n\tunsigned char vers[4];\n\n\tstruct i2c_msg msg;\n\tu8 *buf;\n\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s() demod%d FW is %zu bytes (%02x %02x .. %02x %02x)\\n\",\n\t\t__func__, state->demod, fw->size, fw->data[0], fw->data[1],\n\t\tfw->data[fw->size - 2], fw->data[fw->size - 1]);\n\n\tcx24117_writereg(state, 0xea, 0x00);\n\tcx24117_writereg(state, 0xea, 0x01);\n\tcx24117_writereg(state, 0xea, 0x00);\n\n\tcx24117_writereg(state, 0xce, 0x92);\n\n\tcx24117_writereg(state, 0xfb, 0x00);\n\tcx24117_writereg(state, 0xfc, 0x00);\n\n\tcx24117_writereg(state, 0xc3, 0x04);\n\tcx24117_writereg(state, 0xc4, 0x04);\n\n\tcx24117_writereg(state, 0xce, 0x00);\n\tcx24117_writereg(state, 0xcf, 0x00);\n\n\tcx24117_writereg(state, 0xea, 0x00);\n\tcx24117_writereg(state, 0xeb, 0x0c);\n\tcx24117_writereg(state, 0xec, 0x06);\n\tcx24117_writereg(state, 0xed, 0x05);\n\tcx24117_writereg(state, 0xee, 0x03);\n\tcx24117_writereg(state, 0xef, 0x05);\n\n\tcx24117_writereg(state, 0xf3, 0x03);\n\tcx24117_writereg(state, 0xf4, 0x44);\n\n\tcx24117_writereg(state, CX24117_REG_RATEDIV0, 0x04);\n\tcx24117_writereg(state, CX24117_REG_CLKDIV0, 0x02);\n\n\tcx24117_writereg(state, CX24117_REG_RATEDIV1, 0x04);\n\tcx24117_writereg(state, CX24117_REG_CLKDIV1, 0x02);\n\n\tcx24117_writereg(state, 0xf2, 0x04);\n\tcx24117_writereg(state, 0xe8, 0x02);\n\tcx24117_writereg(state, 0xea, 0x01);\n\tcx24117_writereg(state, 0xc8, 0x00);\n\tcx24117_writereg(state, 0xc9, 0x00);\n\tcx24117_writereg(state, 0xca, 0x00);\n\tcx24117_writereg(state, 0xcb, 0x00);\n\tcx24117_writereg(state, 0xcc, 0x00);\n\tcx24117_writereg(state, 0xcd, 0x00);\n\tcx24117_writereg(state, 0xe4, 0x03);\n\tcx24117_writereg(state, 0xeb, 0x0a);\n\n\tcx24117_writereg(state, 0xfb, 0x00);\n\tcx24117_writereg(state, 0xe0, 0x76);\n\tcx24117_writereg(state, 0xf7, 0x81);\n\tcx24117_writereg(state, 0xf8, 0x00);\n\tcx24117_writereg(state, 0xf9, 0x00);\n\n\tbuf = kmalloc(fw->size + 1, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tstate->priv->skip_fw_load = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tbuf[0] = 0xfa;\n\tmemcpy(&buf[1], fw->data, fw->size);\n\n\t \n\tmsg.addr = state->priv->demod_address;\n\tmsg.flags = 0;\n\tmsg.len = fw->size + 1;\n\tmsg.buf = buf;\n\n\t \n\tret = i2c_transfer(state->priv->i2c, &msg, 1);\n\tif (ret < 0) {\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tkfree(buf);\n\n\tcx24117_writereg(state, 0xf7, 0x0c);\n\tcx24117_writereg(state, 0xe0, 0x00);\n\n\t \n\tcmd.args[0] = CMD_DEMODINIT;\n\tcmd.args[1] = 0x00;\n\tcmd.args[2] = 0x01;\n\tcmd.args[3] = 0x00;\n\tcmd.len = 4;\n\tret = cx24117_cmd_execute_nolock(fe, &cmd);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tcmd.args[0] = CMD_SET_VCOFREQ;\n\tcmd.args[1] = 0x06;\n\tcmd.args[2] = 0x2b;\n\tcmd.args[3] = 0xd8;\n\tcmd.args[4] = 0xa5;\n\tcmd.args[5] = 0xee;\n\tcmd.args[6] = 0x03;\n\tcmd.args[7] = 0x9d;\n\tcmd.args[8] = 0xfc;\n\tcmd.args[9] = 0x06;\n\tcmd.args[10] = 0x02;\n\tcmd.args[11] = 0x9d;\n\tcmd.args[12] = 0xfc;\n\tcmd.len = 13;\n\tret = cx24117_cmd_execute_nolock(fe, &cmd);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tcmd.args[0] = CMD_TUNERINIT;\n\tcmd.args[1] = 0x00;\n\tcmd.args[2] = 0x01;\n\tcmd.args[3] = 0x00;\n\tcmd.args[4] = 0x00;\n\tcmd.args[5] = 0x01;\n\tcmd.args[6] = 0x01;\n\tcmd.args[7] = 0x01;\n\tcmd.args[8] = 0x00;\n\tcmd.args[9] = 0x05;\n\tcmd.args[10] = 0x02;\n\tcmd.args[11] = 0x02;\n\tcmd.args[12] = 0x00;\n\tcmd.len = 13;\n\tret = cx24117_cmd_execute_nolock(fe, &cmd);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tcmd.args[0] = CMD_GLOBAL_MPEGCFG;\n\tcmd.args[1] = 0x00;\n\tcmd.args[2] = 0x00;\n\tcmd.args[3] = 0x00;\n\tcmd.args[4] = 0x01;\n\tcmd.args[5] = 0x00;\n\tcmd.len = 6;\n\tret = cx24117_cmd_execute_nolock(fe, &cmd);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tcmd.args[0] = CMD_MPEGCFG;\n\t\tcmd.args[1] = (u8) i;\n\t\tcmd.args[2] = 0x00;\n\t\tcmd.args[3] = 0x05;\n\t\tcmd.args[4] = 0x00;\n\t\tcmd.args[5] = 0x00;\n\t\tcmd.args[6] = 0x55;\n\t\tcmd.args[7] = 0x00;\n\t\tcmd.len = 8;\n\t\tret = cx24117_cmd_execute_nolock(fe, &cmd);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t}\n\n\tcx24117_writereg(state, 0xce, 0xc0);\n\tcx24117_writereg(state, 0xcf, 0x00);\n\tcx24117_writereg(state, 0xe5, 0x04);\n\n\t \n\tcmd.args[0] = CMD_FWVERSION;\n\tcmd.len = 2;\n\tfor (i = 0; i < 4; i++) {\n\t\tcmd.args[1] = i;\n\t\tret = cx24117_cmd_execute_nolock(fe, &cmd);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t\tvers[i] = cx24117_readreg(state, 0x33);\n\t}\n\tdev_info(&state->priv->i2c->dev,\n\t\t\"%s: FW version %i.%i.%i.%i\\n\", __func__,\n\t\tvers[0], vers[1], vers[2], vers[3]);\n\treturn 0;\nerror:\n\tstate->priv->skip_fw_load = 0;\n\tdev_err(&state->priv->i2c->dev, \"%s() Error running FW.\\n\", __func__);\n\treturn ret;\n}\n\nstatic int cx24117_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tint lock;\n\n\tlock = cx24117_readreg(state,\n\t\t(state->demod == 0) ? CX24117_REG_SSTATUS0 :\n\t\t\t\t      CX24117_REG_SSTATUS1) &\n\t\tCX24117_STATUS_MASK;\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d status = 0x%02x\\n\",\n\t\t__func__, state->demod, lock);\n\n\t*status = 0;\n\n\tif (lock & CX24117_HAS_SIGNAL)\n\t\t*status |= FE_HAS_SIGNAL;\n\tif (lock & CX24117_HAS_CARRIER)\n\t\t*status |= FE_HAS_CARRIER;\n\tif (lock & CX24117_HAS_VITERBI)\n\t\t*status |= FE_HAS_VITERBI;\n\tif (lock & CX24117_HAS_SYNCLOCK)\n\t\t*status |= FE_HAS_SYNC | FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int cx24117_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 buf[4];\n\tu8 base_reg = (state->demod == 0) ?\n\t\t\tCX24117_REG_BER4_0 :\n\t\t\tCX24117_REG_BER4_1;\n\n\tret = cx24117_readregN(state, base_reg, buf, 4);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t*ber = (buf[0] << 24) | (buf[1] << 16) |\n\t\t(buf[1] << 8) | buf[0];\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d ber=0x%04x\\n\",\n\t\t__func__, state->demod, *ber);\n\n\treturn 0;\n}\n\nstatic int cx24117_read_signal_strength(struct dvb_frontend *fe,\n\tu16 *signal_strength)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tstruct cx24117_cmd cmd;\n\tint ret;\n\tu16 sig_reading;\n\tu8 buf[2];\n\tu8 reg = (state->demod == 0) ?\n\t\tCX24117_REG_SSTATUS0 : CX24117_REG_SSTATUS1;\n\n\t \n\tcmd.args[0] = CMD_GET_AGCACC;\n\tcmd.args[1] = (u8) state->demod;\n\tcmd.len = 2;\n\tret = cx24117_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = cx24117_readregN(state, reg, buf, 2);\n\tif (ret != 0)\n\t\treturn ret;\n\tsig_reading = ((buf[0] & CX24117_SIGNAL_MASK) << 2) | buf[1];\n\n\t*signal_strength = -100 * sig_reading + 94324;\n\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s() demod%d raw / cooked = 0x%04x / 0x%04x\\n\",\n\t\t__func__, state->demod, sig_reading, *signal_strength);\n\n\treturn 0;\n}\n\nstatic int cx24117_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 buf[2];\n\tu8 reg = (state->demod == 0) ?\n\t\tCX24117_REG_QUALITY2_0 : CX24117_REG_QUALITY2_1;\n\n\tret = cx24117_readregN(state, reg, buf, 2);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t*snr = (buf[0] << 8) | buf[1];\n\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s() demod%d snr = 0x%04x\\n\",\n\t\t__func__, state->demod, *snr);\n\n\treturn ret;\n}\n\nstatic int cx24117_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tenum fe_delivery_system delsys = fe->dtv_property_cache.delivery_system;\n\tint ret;\n\tu8 buf[2];\n\tu8 reg = (state->demod == 0) ?\n\t\tCX24117_REG_DVBS_UCB2_0 :\n\t\tCX24117_REG_DVBS_UCB2_1;\n\n\tswitch (delsys) {\n\tcase SYS_DVBS:\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\treg += (CX24117_REG_DVBS2_UCB2_0 - CX24117_REG_DVBS_UCB2_0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = cx24117_readregN(state, reg, buf, 2);\n\tif (ret != 0)\n\t\treturn ret;\n\t*ucblocks = (buf[0] << 8) | buf[1];\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d ucb=0x%04x\\n\",\n\t\t__func__, state->demod, *ucblocks);\n\n\treturn 0;\n}\n\n \nstatic void cx24117_clone_params(struct dvb_frontend *fe)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tstate->dcur = state->dnxt;\n}\n\n \nstatic int cx24117_wait_for_lnb(struct dvb_frontend *fe)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tint i;\n\tu8 val, reg = (state->demod == 0) ? CX24117_REG_QSTATUS0 :\n\t\t\t\t\t    CX24117_REG_QSTATUS1;\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d qstatus = 0x%02x\\n\",\n\t\t__func__, state->demod, cx24117_readreg(state, reg));\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tval = cx24117_readreg(state, reg) & 0x01;\n\t\tif (val != 0)\n\t\t\treturn 0;\n\t\tmsleep(30);\n\t}\n\n\tdev_warn(&state->priv->i2c->dev, \"%s: demod%d LNB not ready\\n\",\n\t\tKBUILD_MODNAME, state->demod);\n\n\treturn -ETIMEDOUT;  \n}\n\nstatic int cx24117_set_voltage(struct dvb_frontend *fe,\n\t\t\t       enum fe_sec_voltage voltage)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tstruct cx24117_cmd cmd;\n\tint ret;\n\tu8 reg = (state->demod == 0) ? 0x10 : 0x20;\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d %s\\n\",\n\t\t__func__, state->demod,\n\t\tvoltage == SEC_VOLTAGE_13 ? \"SEC_VOLTAGE_13\" :\n\t\tvoltage == SEC_VOLTAGE_18 ? \"SEC_VOLTAGE_18\" :\n\t\t\"SEC_VOLTAGE_OFF\");\n\n\t \n\tcmd.args[0] = CMD_SET_GPIOOUT;\n\tcmd.args[2] = reg;  \n\tcmd.len = 3;\n\n\tif ((voltage == SEC_VOLTAGE_13) ||\n\t    (voltage == SEC_VOLTAGE_18)) {\n\t\t \n\t\tcmd.args[1] = reg;\n\t\tret = cx24117_cmd_execute(fe, &cmd);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tret = cx24117_wait_for_lnb(fe);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tmsleep(100);\n\n\t\t \n\t\tcmd.args[0] = CMD_LNBDCLEVEL;\n\t\tcmd.args[1] = state->demod ? 0 : 1;\n\t\tcmd.args[2] = (voltage == SEC_VOLTAGE_18 ? 0x01 : 0x00);\n\t\tcmd.len = 3;\n\t\tret = cx24117_cmd_execute(fe, &cmd);\n\n\t\t \n\t\tmsleep(20);\n\t} else {\n\t\t \n\t\tcmd.args[1] = 0x00;\n\t\tret = cx24117_cmd_execute(fe, &cmd);\n\t}\n\n\treturn ret;\n}\n\nstatic int cx24117_set_tone(struct dvb_frontend *fe,\n\t\t\t    enum fe_sec_tone_mode tone)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tstruct cx24117_cmd cmd;\n\tint ret;\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s(%d) demod%d\\n\",\n\t\t__func__, state->demod, tone);\n\tif ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {\n\t\tdev_warn(&state->priv->i2c->dev, \"%s: demod%d invalid tone=%d\\n\",\n\t\t\tKBUILD_MODNAME, state->demod, tone);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = cx24117_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tmsleep(20);\n\n\t \n\tcmd.args[0] = CMD_LNBPCBCONFIG;\n\tcmd.args[1] = (state->demod ? 0 : 1);\n\tcmd.args[2] = 0x00;\n\tcmd.args[3] = 0x00;\n\tcmd.len = 5;\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\tcmd.args[4] = 0x01;\n\t\tbreak;\n\tcase SEC_TONE_OFF:\n\t\tcmd.args[4] = 0x00;\n\t\tbreak;\n\t}\n\n\tmsleep(20);\n\n\treturn cx24117_cmd_execute(fe, &cmd);\n}\n\n \nstatic int cx24117_diseqc_init(struct dvb_frontend *fe)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\n\t \n\tstate->dsec_cmd.args[0] = CMD_LNBSEND;\n\n\t \n\tstate->dsec_cmd.args[CX24117_DISEQC_DEMOD] = state->demod ? 0 : 1;\n\n\t \n\tstate->dsec_cmd.args[CX24117_DISEQC_BURST] = CX24117_DISEQC_MINI_A;\n\n\t \n\tstate->dsec_cmd.args[CX24117_DISEQC_ARG3_2] = 0x02;\n\tstate->dsec_cmd.args[CX24117_DISEQC_ARG4_0] = 0x00;\n\n\t \n\tstate->dsec_cmd.args[CX24117_DISEQC_ARG5_0] = 0x00;\n\n\t \n\tstate->dsec_cmd.args[CX24117_DISEQC_MSGLEN] = 0x00;\n\n\t \n\tstate->dsec_cmd.len = 7;\n\n\treturn 0;\n}\n\n \nstatic int cx24117_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t \n\tdev_dbg(&state->priv->i2c->dev, \"%s: demod %d (\",\n\t\t__func__, state->demod);\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tdev_dbg(&state->priv->i2c->dev, \"0x%02x \", d->msg[i]);\n\tdev_dbg(&state->priv->i2c->dev, \")\\n\");\n\n\t \n\tif (d->msg_len > sizeof(d->msg))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24117_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t \n\tstate->dsec_cmd.args[CX24117_DISEQC_MSGLEN] = d->msg_len;\n\n\t \n\tstate->dsec_cmd.len = CX24117_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24117_DISEQC_MSGLEN];\n\n\t \n\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\tstate->dsec_cmd.args[CX24117_DISEQC_BURST] =\n\t\t\t((d->msg[3] & 4) >> 2);\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d burst=%d\\n\",\n\t\t__func__, state->demod,\n\t\tstate->dsec_cmd.args[CX24117_DISEQC_BURST]);\n\n\t \n\tret = cx24117_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tmsleep(100);\n\n\t \n\tret = cx24117_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t \n\tmsleep((state->dsec_cmd.args[CX24117_DISEQC_MSGLEN] << 4) + 60);\n\n\treturn 0;\n}\n\n \nstatic int cx24117_diseqc_send_burst(struct dvb_frontend *fe,\n\tenum fe_sec_mini_cmd burst)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s(%d) demod=%d\\n\",\n\t\t__func__, burst, state->demod);\n\n\t \n\tif (burst == SEC_MINI_A)\n\t\tstate->dsec_cmd.args[CX24117_DISEQC_BURST] =\n\t\t\tCX24117_DISEQC_MINI_A;\n\telse if (burst == SEC_MINI_B)\n\t\tstate->dsec_cmd.args[CX24117_DISEQC_BURST] =\n\t\t\tCX24117_DISEQC_MINI_B;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cx24117_get_priv(struct cx24117_priv **priv,\n\tstruct i2c_adapter *i2c, u8 client_address)\n{\n\tint ret;\n\n\tmutex_lock(&cx24117_list_mutex);\n\tret = hybrid_tuner_request_state(struct cx24117_priv, (*priv),\n\t\thybrid_tuner_instance_list, i2c, client_address, \"cx24117\");\n\tmutex_unlock(&cx24117_list_mutex);\n\n\treturn ret;\n}\n\nstatic void cx24117_release_priv(struct cx24117_priv *priv)\n{\n\tmutex_lock(&cx24117_list_mutex);\n\tif (priv != NULL)\n\t\thybrid_tuner_release_state(priv);\n\tmutex_unlock(&cx24117_list_mutex);\n}\n\nstatic void cx24117_release(struct dvb_frontend *fe)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tdev_dbg(&state->priv->i2c->dev, \"%s demod%d\\n\",\n\t\t__func__, state->demod);\n\tcx24117_release_priv(state->priv);\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops cx24117_ops;\n\nstruct dvb_frontend *cx24117_attach(const struct cx24117_config *config,\n\tstruct i2c_adapter *i2c)\n{\n\tstruct cx24117_state *state = NULL;\n\tstruct cx24117_priv *priv = NULL;\n\tint demod = 0;\n\n\t \n\tdemod = cx24117_get_priv(&priv, i2c, config->demod_address);\n\n\tswitch (demod) {\n\tcase 0:\n\t\tdev_err(&i2c->dev,\n\t\t\t\"%s: Error attaching frontend %d\\n\",\n\t\t\tKBUILD_MODNAME, demod);\n\t\tgoto error1;\n\tcase 1:\n\t\t \n\t\tpriv->i2c = i2c;\n\t\tpriv->demod_address = config->demod_address;\n\t\tmutex_init(&priv->fe_lock);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tstate = kzalloc(sizeof(struct cx24117_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error2;\n\n\tstate->demod = demod - 1;\n\tstate->priv = priv;\n\n\tdev_info(&state->priv->i2c->dev,\n\t\t\"%s: Attaching frontend %d\\n\",\n\t\tKBUILD_MODNAME, state->demod);\n\n\t \n\tmemcpy(&state->frontend.ops, &cx24117_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror2:\n\tcx24117_release_priv(priv);\nerror1:\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cx24117_attach);\n\n \nstatic int cx24117_initfe(struct dvb_frontend *fe)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tstruct cx24117_cmd cmd;\n\tint ret;\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d\\n\",\n\t\t__func__, state->demod);\n\n\tmutex_lock(&state->priv->fe_lock);\n\n\t \n\tcmd.args[0] = CMD_SET_SLEEPMODE;\n\tcmd.args[1] = (state->demod ? 1 : 0);\n\tcmd.args[2] = 0;\n\tcmd.len = 3;\n\tret = cx24117_cmd_execute_nolock(fe, &cmd);\n\tif (ret != 0)\n\t\tgoto exit;\n\n\tret = cx24117_diseqc_init(fe);\n\tif (ret != 0)\n\t\tgoto exit;\n\n\t \n\tcmd.args[0] = CMD_BERCTRL;\n\tcmd.args[1] = (state->demod ? 1 : 0);\n\tcmd.args[2] = 0x10;\n\tcmd.args[3] = 0x10;\n\tcmd.len = 4;\n\tret = cx24117_cmd_execute_nolock(fe, &cmd);\n\tif (ret != 0)\n\t\tgoto exit;\n\n\t \n\tcmd.args[0] = CMD_ENABLERSCORR;\n\tcmd.args[1] = (state->demod ? 1 : 0);\n\tcmd.args[2] = CX24117_OCC;\n\tcmd.len = 3;\n\tret = cx24117_cmd_execute_nolock(fe, &cmd);\n\tif (ret != 0)\n\t\tgoto exit;\n\n\t \n\t \n\tcmd.args[0] = CMD_SET_GPIODIR;\n\tcmd.args[1] = 0x30;\n\tcmd.args[2] = 0x30;\n\tcmd.len = 3;\n\tret = cx24117_cmd_execute_nolock(fe, &cmd);\n\nexit:\n\tmutex_unlock(&state->priv->fe_lock);\n\n\treturn ret;\n}\n\n \nstatic int cx24117_sleep(struct dvb_frontend *fe)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tstruct cx24117_cmd cmd;\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d\\n\",\n\t\t__func__, state->demod);\n\n\t \n\tcmd.args[0] = CMD_SET_SLEEPMODE;\n\tcmd.args[1] = (state->demod ? 1 : 0);\n\tcmd.args[2] = 1;\n\tcmd.len = 3;\n\treturn cx24117_cmd_execute(fe, &cmd);\n}\n\n \nstatic int cx24117_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct cx24117_cmd cmd;\n\tenum fe_status tunerstat;\n\tint i, status, ret, retune = 1;\n\tu8 reg_clkdiv, reg_ratediv;\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d\\n\",\n\t\t__func__, state->demod);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d DVB-S\\n\",\n\t\t\t__func__, state->demod);\n\n\t\t \n\t\tif (c->modulation != QPSK) {\n\t\t\tdev_dbg(&state->priv->i2c->dev,\n\t\t\t\t\"%s() demod%d unsupported modulation (%d)\\n\",\n\t\t\t\t__func__, state->demod, c->modulation);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tstate->dnxt.pilot_val = CX24117_PILOT_OFF;\n\n\t\t \n\t\tstate->dnxt.rolloff_val = CX24117_ROLLOFF_035;\n\t\tbreak;\n\n\tcase SYS_DVBS2:\n\t\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d DVB-S2\\n\",\n\t\t\t__func__, state->demod);\n\n\t\t \n\t\tif (c->modulation != PSK_8 && c->modulation != QPSK) {\n\t\t\tdev_dbg(&state->priv->i2c->dev,\n\t\t\t\t\"%s() demod%d unsupported modulation (%d)\\n\",\n\t\t\t\t__func__, state->demod, c->modulation);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tswitch (c->pilot) {\n\t\tcase PILOT_AUTO:\n\t\t\tstate->dnxt.pilot_val = CX24117_PILOT_AUTO;\n\t\t\tbreak;\n\t\tcase PILOT_OFF:\n\t\t\tstate->dnxt.pilot_val = CX24117_PILOT_OFF;\n\t\t\tbreak;\n\t\tcase PILOT_ON:\n\t\t\tstate->dnxt.pilot_val = CX24117_PILOT_ON;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&state->priv->i2c->dev,\n\t\t\t\t\"%s() demod%d unsupported pilot mode (%d)\\n\",\n\t\t\t\t__func__, state->demod, c->pilot);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tswitch (c->rolloff) {\n\t\tcase ROLLOFF_20:\n\t\t\tstate->dnxt.rolloff_val = CX24117_ROLLOFF_020;\n\t\t\tbreak;\n\t\tcase ROLLOFF_25:\n\t\t\tstate->dnxt.rolloff_val = CX24117_ROLLOFF_025;\n\t\t\tbreak;\n\t\tcase ROLLOFF_35:\n\t\t\tstate->dnxt.rolloff_val = CX24117_ROLLOFF_035;\n\t\t\tbreak;\n\t\tcase ROLLOFF_AUTO:\n\t\t\tstate->dnxt.rolloff_val = CX24117_ROLLOFF_035;\n\t\t\t \n\t\t\tretune = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&state->priv->i2c->dev,\n\t\t\t\t\"%s: demod%d unsupported rolloff (%d)\\n\",\n\t\t\t\tKBUILD_MODNAME, state->demod, c->rolloff);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&state->priv->i2c->dev,\n\t\t\t\"%s: demod %d unsupported delivery system (%d)\\n\",\n\t\t\tKBUILD_MODNAME, state->demod, c->delivery_system);\n\t\treturn -EINVAL;\n\t}\n\n\tstate->dnxt.delsys = c->delivery_system;\n\tstate->dnxt.modulation = c->modulation;\n\tstate->dnxt.frequency = c->frequency;\n\tstate->dnxt.pilot = c->pilot;\n\tstate->dnxt.rolloff = c->rolloff;\n\n\tret = cx24117_set_inversion(state, c->inversion);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\tret = cx24117_set_fec(state,\n\t\tc->delivery_system, c->modulation, c->fec_inner);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\tret = cx24117_set_symbolrate(state, c->symbol_rate);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\t \n\tcx24117_clone_params(fe);\n\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s: delsys      = %d\\n\", __func__, state->dcur.delsys);\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s: modulation  = %d\\n\", __func__, state->dcur.modulation);\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s: frequency   = %d\\n\", __func__, state->dcur.frequency);\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s: pilot       = %d (val = 0x%02x)\\n\", __func__,\n\t\tstate->dcur.pilot, state->dcur.pilot_val);\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s: retune      = %d\\n\", __func__, retune);\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s: rolloff     = %d (val = 0x%02x)\\n\", __func__,\n\t\tstate->dcur.rolloff, state->dcur.rolloff_val);\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s: symbol_rate = %d\\n\", __func__, state->dcur.symbol_rate);\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s: FEC         = %d (mask/val = 0x%02x/0x%02x)\\n\", __func__,\n\t\tstate->dcur.fec, state->dcur.fec_mask, state->dcur.fec_val);\n\tdev_dbg(&state->priv->i2c->dev,\n\t\t\"%s: Inversion   = %d (val = 0x%02x)\\n\", __func__,\n\t\tstate->dcur.inversion, state->dcur.inversion_val);\n\n\t \n\tcmd.args[0] = CMD_TUNEREQUEST;\n\n\t \n\tcmd.args[1] = state->demod;\n\n\t \n\tcmd.args[2] = (state->dcur.frequency & 0xff0000) >> 16;\n\tcmd.args[3] = (state->dcur.frequency & 0x00ff00) >> 8;\n\tcmd.args[4] = (state->dcur.frequency & 0x0000ff);\n\n\t \n\tcmd.args[5] = ((state->dcur.symbol_rate / 1000) & 0xff00) >> 8;\n\tcmd.args[6] = ((state->dcur.symbol_rate / 1000) & 0x00ff);\n\n\t \n\tcmd.args[7] = state->dcur.inversion_val;\n\n\t \n\tcmd.args[8] = state->dcur.fec_val | state->dcur.pilot_val;\n\n\tcmd.args[9] = CX24117_SEARCH_RANGE_KHZ >> 8;\n\tcmd.args[10] = CX24117_SEARCH_RANGE_KHZ & 0xff;\n\n\tcmd.args[11] = state->dcur.rolloff_val;\n\tcmd.args[12] = state->dcur.fec_mask;\n\n\tif (state->dcur.symbol_rate > 30000000) {\n\t\treg_ratediv = 0x04;\n\t\treg_clkdiv = 0x02;\n\t} else if (state->dcur.symbol_rate > 10000000) {\n\t\treg_ratediv = 0x06;\n\t\treg_clkdiv = 0x03;\n\t} else {\n\t\treg_ratediv = 0x0a;\n\t\treg_clkdiv = 0x05;\n\t}\n\n\tcmd.args[13] = reg_ratediv;\n\tcmd.args[14] = reg_clkdiv;\n\n\tcx24117_writereg(state, (state->demod == 0) ?\n\t\tCX24117_REG_CLKDIV0 : CX24117_REG_CLKDIV1, reg_clkdiv);\n\tcx24117_writereg(state, (state->demod == 0) ?\n\t\tCX24117_REG_RATEDIV0 : CX24117_REG_RATEDIV1, reg_ratediv);\n\n\tcmd.args[15] = CX24117_PNE;\n\tcmd.len = 16;\n\n\tdo {\n\t\t \n\t\tstatus = cx24117_readreg(state, (state->demod == 0) ?\n\t\t\tCX24117_REG_SSTATUS0 : CX24117_REG_SSTATUS1) &\n\t\t\tCX24117_SIGNAL_MASK;\n\n\t\tdev_dbg(&state->priv->i2c->dev,\n\t\t\t\"%s() demod%d status_setfe = %02x\\n\",\n\t\t\t__func__, state->demod, status);\n\n\t\tcx24117_writereg(state, (state->demod == 0) ?\n\t\t\tCX24117_REG_SSTATUS0 : CX24117_REG_SSTATUS1, status);\n\n\t\t \n\t\tret = cx24117_cmd_execute(fe, &cmd);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\t \n\t\tfor (i = 0; i < 50; i++) {\n\t\t\tcx24117_read_status(fe, &tunerstat);\n\t\t\tstatus = tunerstat & (FE_HAS_SIGNAL | FE_HAS_SYNC);\n\t\t\tif (status == (FE_HAS_SIGNAL | FE_HAS_SYNC)) {\n\t\t\t\tdev_dbg(&state->priv->i2c->dev,\n\t\t\t\t\t\"%s() demod%d tuned\\n\",\n\t\t\t\t\t__func__, state->demod);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmsleep(20);\n\t\t}\n\n\t\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d not tuned\\n\",\n\t\t\t__func__, state->demod);\n\n\t\t \n\t\tif (state->dcur.rolloff == 3)\n\t\t\tcmd.args[11]--;\n\n\t} while (--retune);\n\treturn -EINVAL;\n}\n\nstatic int cx24117_tune(struct dvb_frontend *fe, bool re_tune,\n\tunsigned int mode_flags, unsigned int *delay, enum fe_status *status)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\n\tdev_dbg(&state->priv->i2c->dev, \"%s() demod%d\\n\",\n\t\t__func__, state->demod);\n\n\t*delay = HZ / 5;\n\tif (re_tune) {\n\t\tint ret = cx24117_set_frontend(fe);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn cx24117_read_status(fe, status);\n}\n\nstatic enum dvbfe_algo cx24117_get_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic int cx24117_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *c)\n{\n\tstruct cx24117_state *state = fe->demodulator_priv;\n\tstruct cx24117_cmd cmd;\n\tu8 reg, st, inv;\n\tint ret, idx;\n\tunsigned int freq;\n\tshort srate_os, freq_os;\n\n\tu8 buf[0x1f-4];\n\n\t \n\tcmd.args[0] = CMD_GETCTLACC;\n\tcmd.args[1] = (u8) state->demod;\n\tcmd.len = 2;\n\tret = cx24117_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\treg = (state->demod == 0) ? CX24117_REG_FREQ3_0 : CX24117_REG_FREQ3_1;\n\tret = cx24117_readregN(state, reg, buf, 0x1f-4);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tst = buf[5];\n\n\t \n\tinv = (((state->demod == 0) ? ~st : st) >> 6) & 1;\n\tif (inv == 0)\n\t\tc->inversion = INVERSION_OFF;\n\telse\n\t\tc->inversion = INVERSION_ON;\n\n\t \n\tidx = st & 0x3f;\n\tif (c->delivery_system == SYS_DVBS2) {\n\t\tif (idx > 11)\n\t\t\tidx += 9;\n\t\telse\n\t\t\tidx += 7;\n\t}\n\n\tc->modulation = cx24117_modfec_modes[idx].modulation;\n\tc->fec_inner = cx24117_modfec_modes[idx].fec;\n\n\t \n\tfreq = (buf[0] << 16) | (buf[1] << 8) | buf[2];\n\tfreq_os = (buf[8] << 8) | buf[9];\n\tc->frequency = freq + freq_os;\n\n\t \n\tsrate_os = (buf[10] << 8) | buf[11];\n\tc->symbol_rate = -1000 * srate_os + state->dcur.symbol_rate;\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops cx24117_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2 },\n\t.info = {\n\t\t.name = \"Conexant CX24117/CX24132\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t\t.frequency_stepsize_hz = 1011 * kHz,\n\t\t.frequency_tolerance_hz = 5 * MHz,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |\n\t\t\tFE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_2G_MODULATION |\n\t\t\tFE_CAN_QPSK | FE_CAN_RECOVER\n\t},\n\n\t.release = cx24117_release,\n\n\t.init = cx24117_initfe,\n\t.sleep = cx24117_sleep,\n\t.read_status = cx24117_read_status,\n\t.read_ber = cx24117_read_ber,\n\t.read_signal_strength = cx24117_read_signal_strength,\n\t.read_snr = cx24117_read_snr,\n\t.read_ucblocks = cx24117_read_ucblocks,\n\t.set_tone = cx24117_set_tone,\n\t.set_voltage = cx24117_set_voltage,\n\t.diseqc_send_master_cmd = cx24117_send_diseqc_msg,\n\t.diseqc_send_burst = cx24117_diseqc_send_burst,\n\t.get_frontend_algo = cx24117_get_algo,\n\t.tune = cx24117_tune,\n\n\t.set_frontend = cx24117_set_frontend,\n\t.get_frontend = cx24117_get_frontend,\n};\n\n\nMODULE_DESCRIPTION(\"DVB Frontend module for Conexant cx24117/cx24132 hardware\");\nMODULE_AUTHOR(\"Luis Alves (ljalvs@gmail.com)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.1\");\nMODULE_FIRMWARE(CX24117_DEFAULT_FIRMWARE);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}