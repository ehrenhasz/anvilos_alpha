{
  "module_name": "dib0090.c",
  "hash_id": "c278b48d0e238d0e4e3f5b1de62c8f9712d6f361e52bc97de2e623292e403e29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/dib0090.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"dib0090.h\"\n#include \"dibx000_common.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"turn on debugging (default: 0)\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\n#define CONFIG_SYS_DVBT\n#define CONFIG_SYS_ISDBT\n#define CONFIG_BAND_CBAND\n#define CONFIG_BAND_VHF\n#define CONFIG_BAND_UHF\n#define CONFIG_DIB0090_USE_PWM_AGC\n\n#define EN_LNA0      0x8000\n#define EN_LNA1      0x4000\n#define EN_LNA2      0x2000\n#define EN_LNA3      0x1000\n#define EN_MIX0      0x0800\n#define EN_MIX1      0x0400\n#define EN_MIX2      0x0200\n#define EN_MIX3      0x0100\n#define EN_IQADC     0x0040\n#define EN_PLL       0x0020\n#define EN_TX        0x0010\n#define EN_BB        0x0008\n#define EN_LO        0x0004\n#define EN_BIAS      0x0001\n\n#define EN_IQANA     0x0002\n#define EN_DIGCLK    0x0080\t \n#define EN_CRYSTAL   0x0002\n\n#define EN_UHF\t\t 0x22E9\n#define EN_VHF\t\t 0x44E9\n#define EN_LBD\t\t 0x11E9\n#define EN_SBD\t\t 0x44E9\n#define EN_CAB\t\t 0x88E9\n\n \n#define      DC_CAL 0x1\n#define     WBD_CAL 0x2\n#define    TEMP_CAL 0x4\n#define CAPTRIM_CAL 0x8\n\n#define KROSUS_PLL_LOCKED   0x800\n#define KROSUS              0x2\n\n \n#define SOC               0x02\n#define SOC_7090_P1G_11R1 0x82\n#define SOC_7090_P1G_21R1 0x8a\n#define SOC_8090_P1G_11R1 0x86\n#define SOC_8090_P1G_21R1 0x8e\n\n \n#define P1A_B      0x0\n#define P1C\t   0x1\n#define P1D_E_F    0x3\n#define P1G\t   0x7\n#define P1G_21R2   0xf\n\n#define MP001 0x1\t\t \n#define MP005 0x4\t\t \n#define MP008 0x6\t\t \n#define MP009 0x7\t\t \n\n#define pgm_read_word(w) (*w)\n\nstruct dc_calibration;\n\nstruct dib0090_tuning {\n\tu32 max_freq;\t\t \n\tu8 switch_trim;\n\tu8 lna_tune;\n\tu16 lna_bias;\n\tu16 v2i;\n\tu16 mix;\n\tu16 load;\n\tu16 tuner_enable;\n};\n\nstruct dib0090_pll {\n\tu32 max_freq;\t\t \n\tu8 vco_band;\n\tu8 hfdiv_code;\n\tu8 hfdiv;\n\tu8 topresc;\n};\n\nstruct dib0090_identity {\n\tu8 version;\n\tu8 product;\n\tu8 p1g;\n\tu8 in_soc;\n};\n\nstruct dib0090_state {\n\tstruct i2c_adapter *i2c;\n\tstruct dvb_frontend *fe;\n\tconst struct dib0090_config *config;\n\n\tu8 current_band;\n\tenum frontend_tune_state tune_state;\n\tu32 current_rf;\n\n\tu16 wbd_offset;\n\ts16 wbd_target;\t\t \n\n\ts16 rf_gain_limit;\t \n\ts16 current_gain;\t \n\tu8 agc_step;\t\t \n\n\tu16 gain[2];\t\t \n\n\tconst u16 *rf_ramp;\n\tconst u16 *bb_ramp;\n\n\t \n\tu16 bb_1_def;\n\tu16 rf_lt_def;\n\tu16 gain_reg[4];\n\n\t \n\ts8 step;\n\ts16 adc_diff;\n\ts16 min_adc_diff;\n\n\ts8 captrim;\n\ts8 fcaptrim;\n\n\tconst struct dc_calibration *dc;\n\tu16 bb6, bb7;\n\n\tconst struct dib0090_tuning *current_tune_table_index;\n\tconst struct dib0090_pll *current_pll_table_index;\n\n\tu8 tuner_is_tuned;\n\tu8 agc_freeze;\n\n\tstruct dib0090_identity identity;\n\n\tu32 rf_request;\n\tu8 current_standard;\n\n\tu8 calibrate;\n\tu32 rest;\n\tu16 bias;\n\ts16 temperature;\n\n\tu8 wbd_calibration_gain;\n\tconst struct dib0090_wbd_slope *current_wbd_table;\n\tu16 wbdmux;\n\n\t \n\tstruct i2c_msg msg[2];\n\tu8 i2c_write_buffer[3];\n\tu8 i2c_read_buffer[2];\n\tstruct mutex i2c_buffer_lock;\n};\n\nstruct dib0090_fw_state {\n\tstruct i2c_adapter *i2c;\n\tstruct dvb_frontend *fe;\n\tstruct dib0090_identity identity;\n\tconst struct dib0090_config *config;\n\n\t \n\tstruct i2c_msg msg;\n\tu8 i2c_write_buffer[2];\n\tu8 i2c_read_buffer[2];\n\tstruct mutex i2c_buffer_lock;\n};\n\nstatic u16 dib0090_read_reg(struct dib0090_state *state, u8 reg)\n{\n\tu16 ret;\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn 0;\n\t}\n\n\tstate->i2c_write_buffer[0] = reg;\n\n\tmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\n\tstate->msg[0].addr = state->config->i2c_address;\n\tstate->msg[0].flags = 0;\n\tstate->msg[0].buf = state->i2c_write_buffer;\n\tstate->msg[0].len = 1;\n\tstate->msg[1].addr = state->config->i2c_address;\n\tstate->msg[1].flags = I2C_M_RD;\n\tstate->msg[1].buf = state->i2c_read_buffer;\n\tstate->msg[1].len = 2;\n\n\tif (i2c_transfer(state->i2c, state->msg, 2) != 2) {\n\t\tpr_warn(\"DiB0090 I2C read failed\\n\");\n\t\tret = 0;\n\t} else\n\t\tret = (state->i2c_read_buffer[0] << 8)\n\t\t\t| state->i2c_read_buffer[1];\n\n\tmutex_unlock(&state->i2c_buffer_lock);\n\treturn ret;\n}\n\nstatic int dib0090_write_reg(struct dib0090_state *state, u32 reg, u16 val)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstate->i2c_write_buffer[0] = reg & 0xff;\n\tstate->i2c_write_buffer[1] = val >> 8;\n\tstate->i2c_write_buffer[2] = val & 0xff;\n\n\tmemset(state->msg, 0, sizeof(struct i2c_msg));\n\tstate->msg[0].addr = state->config->i2c_address;\n\tstate->msg[0].flags = 0;\n\tstate->msg[0].buf = state->i2c_write_buffer;\n\tstate->msg[0].len = 3;\n\n\tif (i2c_transfer(state->i2c, state->msg, 1) != 1) {\n\t\tpr_warn(\"DiB0090 I2C write failed\\n\");\n\t\tret = -EREMOTEIO;\n\t} else\n\t\tret = 0;\n\n\tmutex_unlock(&state->i2c_buffer_lock);\n\treturn ret;\n}\n\nstatic u16 dib0090_fw_read_reg(struct dib0090_fw_state *state, u8 reg)\n{\n\tu16 ret;\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn 0;\n\t}\n\n\tstate->i2c_write_buffer[0] = reg;\n\n\tmemset(&state->msg, 0, sizeof(struct i2c_msg));\n\tstate->msg.addr = reg;\n\tstate->msg.flags = I2C_M_RD;\n\tstate->msg.buf = state->i2c_read_buffer;\n\tstate->msg.len = 2;\n\tif (i2c_transfer(state->i2c, &state->msg, 1) != 1) {\n\t\tpr_warn(\"DiB0090 I2C read failed\\n\");\n\t\tret = 0;\n\t} else\n\t\tret = (state->i2c_read_buffer[0] << 8)\n\t\t\t| state->i2c_read_buffer[1];\n\n\tmutex_unlock(&state->i2c_buffer_lock);\n\treturn ret;\n}\n\nstatic int dib0090_fw_write_reg(struct dib0090_fw_state *state, u8 reg, u16 val)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstate->i2c_write_buffer[0] = val >> 8;\n\tstate->i2c_write_buffer[1] = val & 0xff;\n\n\tmemset(&state->msg, 0, sizeof(struct i2c_msg));\n\tstate->msg.addr = reg;\n\tstate->msg.flags = 0;\n\tstate->msg.buf = state->i2c_write_buffer;\n\tstate->msg.len = 2;\n\tif (i2c_transfer(state->i2c, &state->msg, 1) != 1) {\n\t\tpr_warn(\"DiB0090 I2C write failed\\n\");\n\t\tret = -EREMOTEIO;\n\t} else\n\t\tret = 0;\n\n\tmutex_unlock(&state->i2c_buffer_lock);\n\treturn ret;\n}\n\n#define HARD_RESET(state) do {  if (cfg->reset) {  if (cfg->sleep) cfg->sleep(fe, 0); msleep(10);  cfg->reset(fe, 1); msleep(10);  cfg->reset(fe, 0); msleep(10);  }  } while (0)\n#define ADC_TARGET -220\n#define GAIN_ALPHA 5\n#define WBD_ALPHA 6\n#define LPF\t100\nstatic void dib0090_write_regs(struct dib0090_state *state, u8 r, const u16 * b, u8 c)\n{\n\tdo {\n\t\tdib0090_write_reg(state, r++, *b++);\n\t} while (--c);\n}\n\nstatic int dib0090_identify(struct dvb_frontend *fe)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tu16 v;\n\tstruct dib0090_identity *identity = &state->identity;\n\n\tv = dib0090_read_reg(state, 0x1a);\n\n\tidentity->p1g = 0;\n\tidentity->in_soc = 0;\n\n\tdprintk(\"Tuner identification (Version = 0x%04x)\\n\", v);\n\n\t \n\tv &= ~KROSUS_PLL_LOCKED;\n\n\tidentity->version = v & 0xff;\n\tidentity->product = (v >> 8) & 0xf;\n\n\tif (identity->product != KROSUS)\n\t\tgoto identification_error;\n\n\tif ((identity->version & 0x3) == SOC) {\n\t\tidentity->in_soc = 1;\n\t\tswitch (identity->version) {\n\t\tcase SOC_8090_P1G_11R1:\n\t\t\tdprintk(\"SOC 8090 P1-G11R1 Has been detected\\n\");\n\t\t\tidentity->p1g = 1;\n\t\t\tbreak;\n\t\tcase SOC_8090_P1G_21R1:\n\t\t\tdprintk(\"SOC 8090 P1-G21R1 Has been detected\\n\");\n\t\t\tidentity->p1g = 1;\n\t\t\tbreak;\n\t\tcase SOC_7090_P1G_11R1:\n\t\t\tdprintk(\"SOC 7090 P1-G11R1 Has been detected\\n\");\n\t\t\tidentity->p1g = 1;\n\t\t\tbreak;\n\t\tcase SOC_7090_P1G_21R1:\n\t\t\tdprintk(\"SOC 7090 P1-G21R1 Has been detected\\n\");\n\t\t\tidentity->p1g = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto identification_error;\n\t\t}\n\t} else {\n\t\tswitch ((identity->version >> 5) & 0x7) {\n\t\tcase MP001:\n\t\t\tdprintk(\"MP001 : 9090/8096\\n\");\n\t\t\tbreak;\n\t\tcase MP005:\n\t\t\tdprintk(\"MP005 : Single Sband\\n\");\n\t\t\tbreak;\n\t\tcase MP008:\n\t\t\tdprintk(\"MP008 : diversity VHF-UHF-LBAND\\n\");\n\t\t\tbreak;\n\t\tcase MP009:\n\t\t\tdprintk(\"MP009 : diversity 29098 CBAND-UHF-LBAND-SBAND\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto identification_error;\n\t\t}\n\n\t\tswitch (identity->version & 0x1f) {\n\t\tcase P1G_21R2:\n\t\t\tdprintk(\"P1G_21R2 detected\\n\");\n\t\t\tidentity->p1g = 1;\n\t\t\tbreak;\n\t\tcase P1G:\n\t\t\tdprintk(\"P1G detected\\n\");\n\t\t\tidentity->p1g = 1;\n\t\t\tbreak;\n\t\tcase P1D_E_F:\n\t\t\tdprintk(\"P1D/E/F detected\\n\");\n\t\t\tbreak;\n\t\tcase P1C:\n\t\t\tdprintk(\"P1C detected\\n\");\n\t\t\tbreak;\n\t\tcase P1A_B:\n\t\t\tdprintk(\"P1-A/B detected: driver is deactivated - not available\\n\");\n\t\t\tgoto identification_error;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto identification_error;\n\t\t}\n\t}\n\n\treturn 0;\n\nidentification_error:\n\treturn -EIO;\n}\n\nstatic int dib0090_fw_identify(struct dvb_frontend *fe)\n{\n\tstruct dib0090_fw_state *state = fe->tuner_priv;\n\tstruct dib0090_identity *identity = &state->identity;\n\n\tu16 v = dib0090_fw_read_reg(state, 0x1a);\n\tidentity->p1g = 0;\n\tidentity->in_soc = 0;\n\n\tdprintk(\"FE: Tuner identification (Version = 0x%04x)\\n\", v);\n\n\t \n\tv &= ~KROSUS_PLL_LOCKED;\n\n\tidentity->version = v & 0xff;\n\tidentity->product = (v >> 8) & 0xf;\n\n\tif (identity->product != KROSUS)\n\t\tgoto identification_error;\n\n\tif ((identity->version & 0x3) == SOC) {\n\t\tidentity->in_soc = 1;\n\t\tswitch (identity->version) {\n\t\tcase SOC_8090_P1G_11R1:\n\t\t\tdprintk(\"SOC 8090 P1-G11R1 Has been detected\\n\");\n\t\t\tidentity->p1g = 1;\n\t\t\tbreak;\n\t\tcase SOC_8090_P1G_21R1:\n\t\t\tdprintk(\"SOC 8090 P1-G21R1 Has been detected\\n\");\n\t\t\tidentity->p1g = 1;\n\t\t\tbreak;\n\t\tcase SOC_7090_P1G_11R1:\n\t\t\tdprintk(\"SOC 7090 P1-G11R1 Has been detected\\n\");\n\t\t\tidentity->p1g = 1;\n\t\t\tbreak;\n\t\tcase SOC_7090_P1G_21R1:\n\t\t\tdprintk(\"SOC 7090 P1-G21R1 Has been detected\\n\");\n\t\t\tidentity->p1g = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto identification_error;\n\t\t}\n\t} else {\n\t\tswitch ((identity->version >> 5) & 0x7) {\n\t\tcase MP001:\n\t\t\tdprintk(\"MP001 : 9090/8096\\n\");\n\t\t\tbreak;\n\t\tcase MP005:\n\t\t\tdprintk(\"MP005 : Single Sband\\n\");\n\t\t\tbreak;\n\t\tcase MP008:\n\t\t\tdprintk(\"MP008 : diversity VHF-UHF-LBAND\\n\");\n\t\t\tbreak;\n\t\tcase MP009:\n\t\t\tdprintk(\"MP009 : diversity 29098 CBAND-UHF-LBAND-SBAND\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto identification_error;\n\t\t}\n\n\t\tswitch (identity->version & 0x1f) {\n\t\tcase P1G_21R2:\n\t\t\tdprintk(\"P1G_21R2 detected\\n\");\n\t\t\tidentity->p1g = 1;\n\t\t\tbreak;\n\t\tcase P1G:\n\t\t\tdprintk(\"P1G detected\\n\");\n\t\t\tidentity->p1g = 1;\n\t\t\tbreak;\n\t\tcase P1D_E_F:\n\t\t\tdprintk(\"P1D/E/F detected\\n\");\n\t\t\tbreak;\n\t\tcase P1C:\n\t\t\tdprintk(\"P1C detected\\n\");\n\t\t\tbreak;\n\t\tcase P1A_B:\n\t\t\tdprintk(\"P1-A/B detected: driver is deactivated - not available\\n\");\n\t\t\tgoto identification_error;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto identification_error;\n\t\t}\n\t}\n\n\treturn 0;\n\nidentification_error:\n\treturn -EIO;\n}\n\nstatic void dib0090_reset_digital(struct dvb_frontend *fe, const struct dib0090_config *cfg)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tu16 PllCfg, i, v;\n\n\tHARD_RESET(state);\n\tdib0090_write_reg(state, 0x24, EN_PLL | EN_CRYSTAL);\n\tif (cfg->in_soc)\n\t\treturn;\n\n\tdib0090_write_reg(state, 0x1b, EN_DIGCLK | EN_PLL | EN_CRYSTAL);\t \n\t \n\tdib0090_write_reg(state, 0x20, ((cfg->io.adc_clock_ratio - 1) << 11) | (0 << 10) | (1 << 9) | (1 << 8) | (0 << 4) | 0);\n\tif (cfg->clkoutdrive != 0)\n\t\tdib0090_write_reg(state, 0x23, (0 << 15) | ((!cfg->analog_output) << 14) | (2 << 10) | (1 << 9) | (0 << 8)\n\t\t\t\t| (cfg->clkoutdrive << 5) | (cfg->clkouttobamse << 4) | (0 << 2) | (0));\n\telse\n\t\tdib0090_write_reg(state, 0x23, (0 << 15) | ((!cfg->analog_output) << 14) | (2 << 10) | (1 << 9) | (0 << 8)\n\t\t\t\t| (7 << 5) | (cfg->clkouttobamse << 4) | (0 << 2) | (0));\n\n\t \n\tPllCfg = dib0090_read_reg(state, 0x21);\n\n\t \n\tif ((PllCfg & 0x1FFF) != ((cfg->io.pll_range << 12) | (cfg->io.pll_loopdiv << 6) | (cfg->io.pll_prediv)) && (!cfg->in_soc)\n\t\t\t&& !cfg->io.pll_bypass) {\n\n\t\t \n\t\tPllCfg |= (1 << 15);\n\t\tdib0090_write_reg(state, 0x21, PllCfg);\n\n\t\t \n\t\tPllCfg &= ~(1 << 13);\n\t\tdib0090_write_reg(state, 0x21, PllCfg);\n\n\t \n\t\tPllCfg = (1 << 15) | (0 << 13) | (cfg->io.pll_range << 12) | (cfg->io.pll_loopdiv << 6) | (cfg->io.pll_prediv);\n\t\tdib0090_write_reg(state, 0x21, PllCfg);\n\n\t\t \n\t\tPllCfg |= (1 << 13);\n\t\tdib0090_write_reg(state, 0x21, PllCfg);\n\n\t \n\t\ti = 100;\n\t\tdo {\n\t\t\tv = !!(dib0090_read_reg(state, 0x1a) & 0x800);\n\t\t\tif (v)\n\t\t\t\tbreak;\n\t\t} while (--i);\n\n\t\tif (i == 0) {\n\t\t\tdprintk(\"Pll: Unable to lock Pll\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tPllCfg &= ~(1 << 15);\n\t\tdib0090_write_reg(state, 0x21, PllCfg);\n\t}\n\n\tif (cfg->io.pll_bypass) {\n\t\tPllCfg |= (cfg->io.pll_bypass << 15);\n\t\tdib0090_write_reg(state, 0x21, PllCfg);\n\t}\n}\n\nstatic int dib0090_fw_reset_digital(struct dvb_frontend *fe, const struct dib0090_config *cfg)\n{\n\tstruct dib0090_fw_state *state = fe->tuner_priv;\n\tu16 PllCfg;\n\tu16 v;\n\tint i;\n\n\tdprintk(\"fw reset digital\\n\");\n\tHARD_RESET(state);\n\n\tdib0090_fw_write_reg(state, 0x24, EN_PLL | EN_CRYSTAL);\n\tdib0090_fw_write_reg(state, 0x1b, EN_DIGCLK | EN_PLL | EN_CRYSTAL);\t \n\n\tdib0090_fw_write_reg(state, 0x20,\n\t\t\t((cfg->io.adc_clock_ratio - 1) << 11) | (0 << 10) | (1 << 9) | (1 << 8) | (cfg->data_tx_drv << 4) | cfg->ls_cfg_pad_drv);\n\n\tv = (0 << 15) | ((!cfg->analog_output) << 14) | (1 << 9) | (0 << 8) | (cfg->clkouttobamse << 4) | (0 << 2) | (0);\n\tif (cfg->clkoutdrive != 0)\n\t\tv |= cfg->clkoutdrive << 5;\n\telse\n\t\tv |= 7 << 5;\n\n\tv |= 2 << 10;\n\tdib0090_fw_write_reg(state, 0x23, v);\n\n\t \n\tPllCfg = dib0090_fw_read_reg(state, 0x21);\n\n\t \n\tif ((PllCfg & 0x1FFF) != ((cfg->io.pll_range << 12) | (cfg->io.pll_loopdiv << 6) | (cfg->io.pll_prediv)) && !cfg->io.pll_bypass) {\n\n\t\t \n\t\tPllCfg |= (1 << 15);\n\t\tdib0090_fw_write_reg(state, 0x21, PllCfg);\n\n\t\t \n\t\tPllCfg &= ~(1 << 13);\n\t\tdib0090_fw_write_reg(state, 0x21, PllCfg);\n\n\t \n\t\tPllCfg = (1 << 15) | (0 << 13) | (cfg->io.pll_range << 12) | (cfg->io.pll_loopdiv << 6) | (cfg->io.pll_prediv);\n\t\tdib0090_fw_write_reg(state, 0x21, PllCfg);\n\n\t\t \n\t\tPllCfg |= (1 << 13);\n\t\tdib0090_fw_write_reg(state, 0x21, PllCfg);\n\n\t \n\t\ti = 100;\n\t\tdo {\n\t\t\tv = !!(dib0090_fw_read_reg(state, 0x1a) & 0x800);\n\t\t\tif (v)\n\t\t\t\tbreak;\n\t\t} while (--i);\n\n\t\tif (i == 0) {\n\t\t\tdprintk(\"Pll: Unable to lock Pll\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tPllCfg &= ~(1 << 15);\n\t\tdib0090_fw_write_reg(state, 0x21, PllCfg);\n\t}\n\n\tif (cfg->io.pll_bypass) {\n\t\tPllCfg |= (cfg->io.pll_bypass << 15);\n\t\tdib0090_fw_write_reg(state, 0x21, PllCfg);\n\t}\n\n\treturn dib0090_fw_identify(fe);\n}\n\nstatic int dib0090_wakeup(struct dvb_frontend *fe)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tif (state->config->sleep)\n\t\tstate->config->sleep(fe, 0);\n\n\t \n\tdib0090_write_reg(state, 0x23, dib0090_read_reg(state, 0x23) | (1 << 14));\n\treturn 0;\n}\n\nstatic int dib0090_sleep(struct dvb_frontend *fe)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tif (state->config->sleep)\n\t\tstate->config->sleep(fe, 1);\n\treturn 0;\n}\n\nvoid dib0090_dcc_freq(struct dvb_frontend *fe, u8 fast)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tif (fast)\n\t\tdib0090_write_reg(state, 0x04, 0);\n\telse\n\t\tdib0090_write_reg(state, 0x04, 1);\n}\n\nEXPORT_SYMBOL(dib0090_dcc_freq);\n\nstatic const u16 bb_ramp_pwm_normal_socs[] = {\n\t550,  \n\t(1<<9) | 8,  \n\t440,\n\t(4  << 9) | 0,  \n\t(0  << 9) | 208,  \n\t(4  << 9) | 208,  \n\t(0  << 9) | 440,  \n};\n\nstatic const u16 rf_ramp_pwm_cband_7090p[] = {\n\t280,  \n\t18,  \n\t504,  \n\t(29 << 10) | 364,  \n\t(0  << 10) | 504,  \n\t(60 << 10) | 228,  \n\t(0  << 10) | 364,  \n\t(34 << 10) | 109,  \n\t(0  << 10) | 228,  \n\t(37 << 10) | 0,  \n\t(0  << 10) | 109,  \n};\n\nstatic const u16 rf_ramp_pwm_cband_7090e_sensitivity[] = {\n\t186,  \n\t40,  \n\t746,  \n\t(10 << 10) | 345,  \n\t(0  << 10) | 746,  \n\t(0 << 10) | 0,  \n\t(0  << 10) | 0,  \n\t(28 << 10) | 200,    \n\t(0  << 10) | 345,  \n\t(20 << 10) | 0,    \n\t(0  << 10) | 200,  \n};\n\nstatic const u16 rf_ramp_pwm_cband_7090e_aci[] = {\n\t86,  \n\t40,  \n\t345,  \n\t(0 << 10) | 0,    \n\t(0 << 10) | 0,  \n\t(0 << 10) | 0,  \n\t(0 << 10) | 0,  \n\t(28 << 10) | 200,    \n\t(0  << 10) | 345,  \n\t(20 << 10) | 0,    \n\t(0  << 10) | 200,  \n};\n\nstatic const u16 rf_ramp_pwm_cband_8090[] = {\n\t345,  \n\t29,  \n\t1000,  \n\t(35 << 10) | 772,  \n\t(0  << 10) | 1000,  \n\t(58 << 10) | 496,  \n\t(0  << 10) | 772,  \n\t(27 << 10) | 200,  \n\t(0  << 10) | 496,  \n\t(40 << 10) | 0,  \n\t(0  << 10) | 200,  \n};\n\nstatic const u16 rf_ramp_pwm_uhf_7090[] = {\n\t407,  \n\t13,  \n\t529,  \n\t(23 << 10) | 0,  \n\t(0  << 10) | 176,  \n\t(63 << 10) | 400,  \n\t(0  << 10) | 529,  \n\t(48 << 10) | 316,  \n\t(0  << 10) | 400,  \n\t(29 << 10) | 176,  \n\t(0  << 10) | 316,  \n};\n\nstatic const u16 rf_ramp_pwm_uhf_8090[] = {\n\t388,  \n\t26,  \n\t1008,  \n\t(11 << 10) | 0,  \n\t(0  << 10) | 369,  \n\t(41 << 10) | 809,  \n\t(0  << 10) | 1008,  \n\t(27 << 10) | 659,  \n\t(0  << 10) | 809,  \n\t(14 << 10) | 369,  \n\t(0  << 10) | 659,  \n};\n\n \nstatic const u16 bb_ramp_pwm_normal[] = {\n\t500,  \n\t8,  \n\t400,\n\t(2  << 9) | 0,  \n\t(0  << 9) | 168,  \n\t(2  << 9) | 168,  \n\t(0  << 9) | 400,  \n};\n\n#if 0\n \nstatic const u16 bb_ramp_pwm_boost[] = {\n\t550,  \n\t8,  \n\t440,\n\t(2  << 9) | 0,  \n\t(0  << 9) | 208,  \n\t(2  << 9) | 208,  \n\t(0  << 9) | 440,  \n};\n#endif\n\nstatic const u16 rf_ramp_pwm_cband[] = {\n\t314,  \n\t33,  \n\t1023,  \n\t(8  << 10) | 743,  \n\t(0  << 10) | 1023,  \n\t(15 << 10) | 469,  \n\t(0  << 10) | 742,  \n\t(9  << 10) | 234,  \n\t(0  << 10) | 468,  \n\t(9  << 10) | 0,  \n\t(0  << 10) | 233,  \n};\n\nstatic const u16 rf_ramp_pwm_vhf[] = {\n\t398,  \n\t24,  \n\t954,  \n\t(7  << 10) | 0,  \n\t(0  << 10) | 290,  \n\t(16 << 10) | 699,  \n\t(0  << 10) | 954,  \n\t(17 << 10) | 580,  \n\t(0  << 10) | 699,  \n\t(7  << 10) | 290,  \n\t(0  << 10) | 580,  \n};\n\nstatic const u16 rf_ramp_pwm_uhf[] = {\n\t398,  \n\t24,  \n\t954,  \n\t(7  << 10) | 0,  \n\t(0  << 10) | 290,  \n\t(16 << 10) | 699,  \n\t(0  << 10) | 954,  \n\t(17 << 10) | 580,  \n\t(0  << 10) | 699,  \n\t(7  << 10) | 290,  \n\t(0  << 10) | 580,  \n};\n\n#if 0\n \nstatic const u16 rf_ramp_pwm_sband[] = {\n\t253,  \n\t38,  \n\t961,\n\t(4  << 10) | 0,  \n\t(0  << 10) | 508,  \n\t(9  << 10) | 508,  \n\t(0  << 10) | 961,  \n\t(0  << 10) | 0,  \n\t(0  << 10) | 0,  \n\t(0  << 10) | 0,  \n\t(0  << 10) | 0,  \n};\n#endif\n\nstruct slope {\n\ts16 range;\n\ts16 slope;\n};\nstatic u16 slopes_to_scale(const struct slope *slopes, u8 num, s16 val)\n{\n\tu8 i;\n\tu16 rest;\n\tu16 ret = 0;\n\tfor (i = 0; i < num; i++) {\n\t\tif (val > slopes[i].range)\n\t\t\trest = slopes[i].range;\n\t\telse\n\t\t\trest = val;\n\t\tret += (rest * slopes[i].slope) / slopes[i].range;\n\t\tval -= rest;\n\t}\n\treturn ret;\n}\n\nstatic const struct slope dib0090_wbd_slopes[3] = {\n\t{66, 120},\t\t \n\t{600, 170},\t\t \n\t{170, 250},\t\t \n};\n\nstatic s16 dib0090_wbd_to_db(struct dib0090_state *state, u16 wbd)\n{\n\twbd &= 0x3ff;\n\tif (wbd < state->wbd_offset)\n\t\twbd = 0;\n\telse\n\t\twbd -= state->wbd_offset;\n\t \n\treturn -640 + (s16) slopes_to_scale(dib0090_wbd_slopes, ARRAY_SIZE(dib0090_wbd_slopes), wbd);\n}\n\nstatic void dib0090_wbd_target(struct dib0090_state *state, u32 rf)\n{\n\tu16 offset = 250;\n\n\t \n\n\tif (state->current_band == BAND_VHF)\n\t\toffset = 650;\n#ifndef FIRMWARE_FIREFLY\n\tif (state->current_band == BAND_VHF)\n\t\toffset = state->config->wbd_vhf_offset;\n\tif (state->current_band == BAND_CBAND)\n\t\toffset = state->config->wbd_cband_offset;\n#endif\n\n\tstate->wbd_target = dib0090_wbd_to_db(state, state->wbd_offset + offset);\n\tdprintk(\"wbd-target: %d dB\\n\", (u32) state->wbd_target);\n}\n\nstatic const int gain_reg_addr[4] = {\n\t0x08, 0x0a, 0x0f, 0x01\n};\n\nstatic void dib0090_gain_apply(struct dib0090_state *state, s16 gain_delta, s16 top_delta, u8 force)\n{\n\tu16 rf, bb, ref;\n\tu16 i, v, gain_reg[4] = { 0 }, gain;\n\tconst u16 *g;\n\n\tif (top_delta < -511)\n\t\ttop_delta = -511;\n\tif (top_delta > 511)\n\t\ttop_delta = 511;\n\n\tif (force) {\n\t\ttop_delta *= (1 << WBD_ALPHA);\n\t\tgain_delta *= (1 << GAIN_ALPHA);\n\t}\n\n\tif (top_delta >= ((s16) (state->rf_ramp[0] << WBD_ALPHA) - state->rf_gain_limit))\t \n\t\tstate->rf_gain_limit = state->rf_ramp[0] << WBD_ALPHA;\n\telse\n\t\tstate->rf_gain_limit += top_delta;\n\n\tif (state->rf_gain_limit < 0)\t \n\t\tstate->rf_gain_limit = 0;\n\n\t \n\tgain = ((state->rf_gain_limit >> WBD_ALPHA) + state->bb_ramp[0]) << GAIN_ALPHA;\n\tif (gain_delta >= ((s16) gain - state->current_gain))\t \n\t\tstate->current_gain = gain;\n\telse\n\t\tstate->current_gain += gain_delta;\n\t \n\tif (state->current_gain < 0)\n\t\tstate->current_gain = 0;\n\n\t \n\tgain = state->current_gain >> GAIN_ALPHA;\n\n\t \n\tif (gain > (state->rf_gain_limit >> WBD_ALPHA)) {\n\t\trf = state->rf_gain_limit >> WBD_ALPHA;\n\t\tbb = gain - rf;\n\t\tif (bb > state->bb_ramp[0])\n\t\t\tbb = state->bb_ramp[0];\n\t} else {\t\t \n\t\trf = gain;\n\t\tbb = 0;\n\t}\n\n\tstate->gain[0] = rf;\n\tstate->gain[1] = bb;\n\n\t \n\t \n\tg = state->rf_ramp + 1;\t \n\tref = rf;\n\tfor (i = 0; i < 7; i++) {\t \n\t\tif (g[0] == 0 || ref < (g[1] - g[0]))\t \n\t\t\tv = 0;\t \n\t\telse if (ref >= g[1])\t \n\t\t\tv = g[2];\t \n\t\telse\t\t \n\t\t\tv = ((ref - (g[1] - g[0])) * g[2]) / g[0];\n\n\t\tif (i == 0)\t \n\t\t\tgain_reg[0] = v;\n\t\telse if (i == 1)\t \n\t\t\tgain_reg[0] |= v << 7;\n\t\telse if (i == 2)\t \n\t\t\tgain_reg[1] = v;\n\t\telse if (i == 3)\t \n\t\t\tgain_reg[1] |= v << 7;\n\t\telse if (i == 4)\t \n\t\t\tgain_reg[2] = v | state->rf_lt_def;\n\t\telse if (i == 5)\t \n\t\t\tgain_reg[3] = v << 3;\n\t\telse if (i == 6)\t \n\t\t\tgain_reg[3] |= v << 8;\n\n\t\tg += 3;\t\t \n\n\t\t \n\t\tif (i == 4) {\n\t\t\tg = state->bb_ramp + 1;\t \n\t\t\tref = bb;\n\t\t}\n\t}\n\tgain_reg[3] |= state->bb_1_def;\n\tgain_reg[3] |= ((bb % 10) * 100) / 125;\n\n#ifdef DEBUG_AGC\n\tdprintk(\"GA CALC: DB: %3d(rf) + %3d(bb) = %3d gain_reg[0]=%04x gain_reg[1]=%04x gain_reg[2]=%04x gain_reg[0]=%04x\\n\", rf, bb, rf + bb,\n\t\tgain_reg[0], gain_reg[1], gain_reg[2], gain_reg[3]);\n#endif\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tv = gain_reg[i];\n\t\tif (force || state->gain_reg[i] != v) {\n\t\t\tstate->gain_reg[i] = v;\n\t\t\tdib0090_write_reg(state, gain_reg_addr[i], v);\n\t\t}\n\t}\n}\n\nstatic void dib0090_set_boost(struct dib0090_state *state, int onoff)\n{\n\tstate->bb_1_def &= 0xdfff;\n\tstate->bb_1_def |= onoff << 13;\n}\n\nstatic void dib0090_set_rframp(struct dib0090_state *state, const u16 * cfg)\n{\n\tstate->rf_ramp = cfg;\n}\n\nstatic void dib0090_set_rframp_pwm(struct dib0090_state *state, const u16 * cfg)\n{\n\tstate->rf_ramp = cfg;\n\n\tdib0090_write_reg(state, 0x2a, 0xffff);\n\n\tdprintk(\"total RF gain: %ddB, step: %d\\n\", (u32) cfg[0], dib0090_read_reg(state, 0x2a));\n\n\tdib0090_write_regs(state, 0x2c, cfg + 3, 6);\n\tdib0090_write_regs(state, 0x3e, cfg + 9, 2);\n}\n\nstatic void dib0090_set_bbramp(struct dib0090_state *state, const u16 * cfg)\n{\n\tstate->bb_ramp = cfg;\n\tdib0090_set_boost(state, cfg[0] > 500);\t \n}\n\nstatic void dib0090_set_bbramp_pwm(struct dib0090_state *state, const u16 * cfg)\n{\n\tstate->bb_ramp = cfg;\n\n\tdib0090_set_boost(state, cfg[0] > 500);\t \n\n\tdib0090_write_reg(state, 0x33, 0xffff);\n\tdprintk(\"total BB gain: %ddB, step: %d\\n\", (u32) cfg[0], dib0090_read_reg(state, 0x33));\n\tdib0090_write_regs(state, 0x35, cfg + 3, 4);\n}\n\nvoid dib0090_pwm_gain_reset(struct dvb_frontend *fe)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tconst u16 *bb_ramp = bb_ramp_pwm_normal;  \n\tconst u16 *rf_ramp = NULL;\n\tu8 en_pwm_rf_mux = 1;\n\n\t \n\tif (state->config->use_pwm_agc) {\n\t\tif (state->current_band == BAND_CBAND) {\n\t\t\tif (state->identity.in_soc) {\n\t\t\t\tbb_ramp = bb_ramp_pwm_normal_socs;\n\t\t\t\tif (state->identity.version == SOC_8090_P1G_11R1 || state->identity.version == SOC_8090_P1G_21R1)\n\t\t\t\t\trf_ramp = rf_ramp_pwm_cband_8090;\n\t\t\t\telse if (state->identity.version == SOC_7090_P1G_11R1 || state->identity.version == SOC_7090_P1G_21R1) {\n\t\t\t\t\tif (state->config->is_dib7090e) {\n\t\t\t\t\t\tif (state->rf_ramp == NULL)\n\t\t\t\t\t\t\trf_ramp = rf_ramp_pwm_cband_7090e_sensitivity;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\trf_ramp = state->rf_ramp;\n\t\t\t\t\t} else\n\t\t\t\t\t\trf_ramp = rf_ramp_pwm_cband_7090p;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\trf_ramp = rf_ramp_pwm_cband;\n\t\t} else\n\n\t\t\tif (state->current_band == BAND_VHF) {\n\t\t\t\tif (state->identity.in_soc) {\n\t\t\t\t\tbb_ramp = bb_ramp_pwm_normal_socs;\n\t\t\t\t\t   \n\t\t\t\t} else\n\t\t\t\t\trf_ramp = rf_ramp_pwm_vhf;\n\t\t\t} else if (state->current_band == BAND_UHF) {\n\t\t\t\tif (state->identity.in_soc) {\n\t\t\t\t\tbb_ramp = bb_ramp_pwm_normal_socs;\n\t\t\t\t\tif (state->identity.version == SOC_8090_P1G_11R1 || state->identity.version == SOC_8090_P1G_21R1)\n\t\t\t\t\t\trf_ramp = rf_ramp_pwm_uhf_8090;\n\t\t\t\t\telse if (state->identity.version == SOC_7090_P1G_11R1 || state->identity.version == SOC_7090_P1G_21R1)\n\t\t\t\t\t\trf_ramp = rf_ramp_pwm_uhf_7090;\n\t\t\t\t} else\n\t\t\t\t\trf_ramp = rf_ramp_pwm_uhf;\n\t\t\t}\n\t\tif (rf_ramp)\n\t\t\tdib0090_set_rframp_pwm(state, rf_ramp);\n\t\tdib0090_set_bbramp_pwm(state, bb_ramp);\n\n\t\t \n\t\tif (state->rf_ramp)\n\t\t\tdprintk(\"ramp RF gain = %d BAND = %s version = %d\\n\",\n\t\t\t\tstate->rf_ramp[0],\n\t\t\t\t(state->current_band == BAND_CBAND) ? \"CBAND\" : \"NOT CBAND\",\n\t\t\t\tstate->identity.version & 0x1f);\n\n\t\tif (rf_ramp && ((state->rf_ramp && state->rf_ramp[0] == 0) ||\n\t\t    (state->current_band == BAND_CBAND &&\n\t\t    (state->identity.version & 0x1f) <= P1D_E_F))) {\n\t\t\tdprintk(\"DE-Engage mux for direct gain reg control\\n\");\n\t\t\ten_pwm_rf_mux = 0;\n\t\t} else\n\t\t\tdprintk(\"Engage mux for PWM control\\n\");\n\n\t\tdib0090_write_reg(state, 0x32, (en_pwm_rf_mux << 12) | (en_pwm_rf_mux << 11));\n\n\t\t \n\t\tif (state->identity.version == SOC_7090_P1G_11R1 || state->identity.version == SOC_7090_P1G_21R1)\n\t\t\tdib0090_write_reg(state, 0x04, 3);\n\t\telse\n\t\t\tdib0090_write_reg(state, 0x04, 1);\n\t\tdib0090_write_reg(state, 0x39, (1 << 10));  \n\t}\n}\nEXPORT_SYMBOL(dib0090_pwm_gain_reset);\n\nvoid dib0090_set_dc_servo(struct dvb_frontend *fe, u8 DC_servo_cutoff)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tif (DC_servo_cutoff < 4)\n\t\tdib0090_write_reg(state, 0x04, DC_servo_cutoff);\n}\nEXPORT_SYMBOL(dib0090_set_dc_servo);\n\nstatic u32 dib0090_get_slow_adc_val(struct dib0090_state *state)\n{\n\tu16 adc_val = dib0090_read_reg(state, 0x1d);\n\tif (state->identity.in_soc)\n\t\tadc_val >>= 2;\n\treturn adc_val;\n}\n\nint dib0090_gain_control(struct dvb_frontend *fe)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tenum frontend_tune_state *tune_state = &state->tune_state;\n\tint ret = 10;\n\n\tu16 wbd_val = 0;\n\tu8 apply_gain_immediatly = 1;\n\ts16 wbd_error = 0, adc_error = 0;\n\n\tif (*tune_state == CT_AGC_START) {\n\t\tstate->agc_freeze = 0;\n\t\tdib0090_write_reg(state, 0x04, 0x0);\n\n#ifdef CONFIG_BAND_SBAND\n\t\tif (state->current_band == BAND_SBAND) {\n\t\t\tdib0090_set_rframp(state, rf_ramp_sband);\n\t\t\tdib0090_set_bbramp(state, bb_ramp_boost);\n\t\t} else\n#endif\n#ifdef CONFIG_BAND_VHF\n\t\tif (state->current_band == BAND_VHF && !state->identity.p1g) {\n\t\t\tdib0090_set_rframp(state, rf_ramp_pwm_vhf);\n\t\t\tdib0090_set_bbramp(state, bb_ramp_pwm_normal);\n\t\t} else\n#endif\n#ifdef CONFIG_BAND_CBAND\n\t\tif (state->current_band == BAND_CBAND && !state->identity.p1g) {\n\t\t\tdib0090_set_rframp(state, rf_ramp_pwm_cband);\n\t\t\tdib0090_set_bbramp(state, bb_ramp_pwm_normal);\n\t\t} else\n#endif\n\t\tif ((state->current_band == BAND_CBAND || state->current_band == BAND_VHF) && state->identity.p1g) {\n\t\t\tdib0090_set_rframp(state, rf_ramp_pwm_cband_7090p);\n\t\t\tdib0090_set_bbramp(state, bb_ramp_pwm_normal_socs);\n\t\t} else {\n\t\t\tdib0090_set_rframp(state, rf_ramp_pwm_uhf);\n\t\t\tdib0090_set_bbramp(state, bb_ramp_pwm_normal);\n\t\t}\n\n\t\tdib0090_write_reg(state, 0x32, 0);\n\t\tdib0090_write_reg(state, 0x39, 0);\n\n\t\tdib0090_wbd_target(state, state->current_rf);\n\n\t\tstate->rf_gain_limit = state->rf_ramp[0] << WBD_ALPHA;\n\t\tstate->current_gain = ((state->rf_ramp[0] + state->bb_ramp[0]) / 2) << GAIN_ALPHA;\n\n\t\t*tune_state = CT_AGC_STEP_0;\n\t} else if (!state->agc_freeze) {\n\t\ts16 wbd = 0, i, cnt;\n\n\t\tint adc;\n\t\twbd_val = dib0090_get_slow_adc_val(state);\n\n\t\tif (*tune_state == CT_AGC_STEP_0)\n\t\t\tcnt = 5;\n\t\telse\n\t\t\tcnt = 1;\n\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\twbd_val = dib0090_get_slow_adc_val(state);\n\t\t\twbd += dib0090_wbd_to_db(state, wbd_val);\n\t\t}\n\t\twbd /= cnt;\n\t\twbd_error = state->wbd_target - wbd;\n\n\t\tif (*tune_state == CT_AGC_STEP_0) {\n\t\t\tif (wbd_error < 0 && state->rf_gain_limit > 0 && !state->identity.p1g) {\n#ifdef CONFIG_BAND_CBAND\n\t\t\t\t \n\t\t\t\tu8 ltg2 = (state->rf_lt_def >> 10) & 0x7;\n\t\t\t\tif (state->current_band == BAND_CBAND && ltg2) {\n\t\t\t\t\tltg2 >>= 1;\n\t\t\t\t\tstate->rf_lt_def &= ltg2 << 10;\t \n\t\t\t\t}\n#endif\n\t\t\t} else {\n\t\t\t\tstate->agc_step = 0;\n\t\t\t\t*tune_state = CT_AGC_STEP_1;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tadc = state->config->get_adc_power(fe);\n\t\t\tadc = (adc * ((s32) 355774) + (((s32) 1) << 20)) >> 21;\t \n\n\t\t\tadc_error = (s16) (((s32) ADC_TARGET) - adc);\n#ifdef CONFIG_STANDARD_DAB\n\t\t\tif (state->fe->dtv_property_cache.delivery_system == STANDARD_DAB)\n\t\t\t\tadc_error -= 10;\n#endif\n#ifdef CONFIG_STANDARD_DVBT\n\t\t\tif (state->fe->dtv_property_cache.delivery_system == STANDARD_DVBT &&\n\t\t\t\t\t(state->fe->dtv_property_cache.modulation == QAM_64 || state->fe->dtv_property_cache.modulation == QAM_16))\n\t\t\t\tadc_error += 60;\n#endif\n#ifdef CONFIG_SYS_ISDBT\n\t\t\tif ((state->fe->dtv_property_cache.delivery_system == SYS_ISDBT) && (((state->fe->dtv_property_cache.layer[0].segment_count >\n\t\t\t\t\t\t\t\t0)\n\t\t\t\t\t\t\t&&\n\t\t\t\t\t\t\t((state->fe->dtv_property_cache.layer[0].modulation ==\n\t\t\t\t\t\t\t  QAM_64)\n\t\t\t\t\t\t\t || (state->fe->dtv_property_cache.\n\t\t\t\t\t\t\t\t layer[0].modulation == QAM_16)))\n\t\t\t\t\t\t||\n\t\t\t\t\t\t((state->fe->dtv_property_cache.layer[1].segment_count >\n\t\t\t\t\t\t  0)\n\t\t\t\t\t\t &&\n\t\t\t\t\t\t ((state->fe->dtv_property_cache.layer[1].modulation ==\n\t\t\t\t\t\t   QAM_64)\n\t\t\t\t\t\t  || (state->fe->dtv_property_cache.\n\t\t\t\t\t\t\t  layer[1].modulation == QAM_16)))\n\t\t\t\t\t\t||\n\t\t\t\t\t\t((state->fe->dtv_property_cache.layer[2].segment_count >\n\t\t\t\t\t\t  0)\n\t\t\t\t\t\t &&\n\t\t\t\t\t\t ((state->fe->dtv_property_cache.layer[2].modulation ==\n\t\t\t\t\t\t   QAM_64)\n\t\t\t\t\t\t  || (state->fe->dtv_property_cache.\n\t\t\t\t\t\t\t  layer[2].modulation == QAM_16)))\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\tadc_error += 60;\n#endif\n\n\t\t\tif (*tune_state == CT_AGC_STEP_1) {\t \n\t\t\t\tif (abs(adc_error) < 50 || state->agc_step++ > 5) {\n\n#ifdef CONFIG_STANDARD_DAB\n\t\t\t\t\tif (state->fe->dtv_property_cache.delivery_system == STANDARD_DAB) {\n\t\t\t\t\t\tdib0090_write_reg(state, 0x02, (1 << 15) | (15 << 11) | (31 << 6) | (63));\t \n\t\t\t\t\t\tdib0090_write_reg(state, 0x04, 0x0);\n\t\t\t\t\t} else\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tdib0090_write_reg(state, 0x02, (1 << 15) | (3 << 11) | (6 << 6) | (32));\n\t\t\t\t\t\tdib0090_write_reg(state, 0x04, 0x01);\t \n\t\t\t\t\t}\n\n\t\t\t\t\t*tune_state = CT_AGC_STOP;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tret = 100;\t \n\t\t\t\tapply_gain_immediatly = 0;\n\t\t\t}\n\t\t}\n#ifdef DEBUG_AGC\n\t\tdprintk\n\t\t\t(\"tune state %d, ADC = %3ddB (ADC err %3d) WBD %3ddB (WBD err %3d, WBD val SADC: %4d), RFGainLimit (TOP): %3d, signal: %3ddBm\",\n\t\t\t (u32) *tune_state, (u32) adc, (u32) adc_error, (u32) wbd, (u32) wbd_error, (u32) wbd_val,\n\t\t\t (u32) state->rf_gain_limit >> WBD_ALPHA, (s32) 200 + adc - (state->current_gain >> GAIN_ALPHA));\n#endif\n\t}\n\n\t \n\tif (!state->agc_freeze)\n\t\tdib0090_gain_apply(state, adc_error, wbd_error, apply_gain_immediatly);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(dib0090_gain_control);\n\nvoid dib0090_get_current_gain(struct dvb_frontend *fe, u16 * rf, u16 * bb, u16 * rf_gain_limit, u16 * rflt)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tif (rf)\n\t\t*rf = state->gain[0];\n\tif (bb)\n\t\t*bb = state->gain[1];\n\tif (rf_gain_limit)\n\t\t*rf_gain_limit = state->rf_gain_limit;\n\tif (rflt)\n\t\t*rflt = (state->rf_lt_def >> 10) & 0x7;\n}\n\nEXPORT_SYMBOL(dib0090_get_current_gain);\n\nu16 dib0090_get_wbd_target(struct dvb_frontend *fe)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tu32 f_MHz = state->fe->dtv_property_cache.frequency / 1000000;\n\ts32 current_temp = state->temperature;\n\ts32 wbd_thot, wbd_tcold;\n\tconst struct dib0090_wbd_slope *wbd = state->current_wbd_table;\n\n\twhile (f_MHz > wbd->max_freq)\n\t\twbd++;\n\n\tdprintk(\"using wbd-table-entry with max freq %d\\n\", wbd->max_freq);\n\n\tif (current_temp < 0)\n\t\tcurrent_temp = 0;\n\tif (current_temp > 128)\n\t\tcurrent_temp = 128;\n\n\tstate->wbdmux &= ~(7 << 13);\n\tif (wbd->wbd_gain != 0)\n\t\tstate->wbdmux |= (wbd->wbd_gain << 13);\n\telse\n\t\tstate->wbdmux |= (4 << 13);\n\n\tdib0090_write_reg(state, 0x10, state->wbdmux);\n\n\twbd_thot = wbd->offset_hot - (((u32) wbd->slope_hot * f_MHz) >> 6);\n\twbd_tcold = wbd->offset_cold - (((u32) wbd->slope_cold * f_MHz) >> 6);\n\n\twbd_tcold += ((wbd_thot - wbd_tcold) * current_temp) >> 7;\n\n\tstate->wbd_target = dib0090_wbd_to_db(state, state->wbd_offset + wbd_tcold);\n\tdprintk(\"wbd-target: %d dB\\n\", (u32) state->wbd_target);\n\tdprintk(\"wbd offset applied is %d\\n\", wbd_tcold);\n\n\treturn state->wbd_offset + wbd_tcold;\n}\nEXPORT_SYMBOL(dib0090_get_wbd_target);\n\nu16 dib0090_get_wbd_offset(struct dvb_frontend *fe)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\treturn state->wbd_offset;\n}\nEXPORT_SYMBOL(dib0090_get_wbd_offset);\n\nint dib0090_set_switch(struct dvb_frontend *fe, u8 sw1, u8 sw2, u8 sw3)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\n\tdib0090_write_reg(state, 0x0b, (dib0090_read_reg(state, 0x0b) & 0xfff8)\n\t\t\t| ((sw3 & 1) << 2) | ((sw2 & 1) << 1) | (sw1 & 1));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dib0090_set_switch);\n\nint dib0090_set_vga(struct dvb_frontend *fe, u8 onoff)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\n\tdib0090_write_reg(state, 0x09, (dib0090_read_reg(state, 0x09) & 0x7fff)\n\t\t\t| ((onoff & 1) << 15));\n\treturn 0;\n}\nEXPORT_SYMBOL(dib0090_set_vga);\n\nint dib0090_update_rframp_7090(struct dvb_frontend *fe, u8 cfg_sensitivity)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\n\tif ((!state->identity.p1g) || (!state->identity.in_soc)\n\t\t\t|| ((state->identity.version != SOC_7090_P1G_21R1)\n\t\t\t\t&& (state->identity.version != SOC_7090_P1G_11R1))) {\n\t\tdprintk(\"%s() function can only be used for dib7090P\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (cfg_sensitivity)\n\t\tstate->rf_ramp = rf_ramp_pwm_cband_7090e_sensitivity;\n\telse\n\t\tstate->rf_ramp = rf_ramp_pwm_cband_7090e_aci;\n\tdib0090_pwm_gain_reset(fe);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dib0090_update_rframp_7090);\n\nstatic const u16 dib0090_defaults[] = {\n\n\t25, 0x01,\n\t0x0000,\n\t0x99a0,\n\t0x6008,\n\t0x0000,\n\t0x8bcb,\n\t0x0000,\n\t0x0405,\n\t0x0000,\n\t0x0000,\n\t0x0000,\n\t0xb802,\n\t0x0300,\n\t0x2d12,\n\t0xbac0,\n\t0x7c00,\n\t0xdbb9,\n\t0x0954,\n\t0x0743,\n\t0x8000,\n\t0x0001,\n\t0x0040,\n\t0x0100,\n\t0x0000,\n\t0xe910,\n\t0x149e,\n\n\t1, 0x1c,\n\t0xff2d,\n\n\t1, 0x39,\n\t0x0000,\n\n\t2, 0x1e,\n\t0x07FF,\n\t0x0007,\n\n\t1, 0x24,\n\tEN_UHF | EN_CRYSTAL,\n\n\t2, 0x3c,\n\t0x3ff,\n\t0x111,\n\t0\n};\n\nstatic const u16 dib0090_p1g_additionnal_defaults[] = {\n\t1, 0x05,\n\t0xabcd,\n\n\t1, 0x11,\n\t0x00b4,\n\n\t1, 0x1c,\n\t0xfffd,\n\n\t1, 0x40,\n\t0x108,\n\t0\n};\n\nstatic void dib0090_set_default_config(struct dib0090_state *state, const u16 * n)\n{\n\tu16 l, r;\n\n\tl = pgm_read_word(n++);\n\twhile (l) {\n\t\tr = pgm_read_word(n++);\n\t\tdo {\n\t\t\tdib0090_write_reg(state, r, pgm_read_word(n++));\n\t\t\tr++;\n\t\t} while (--l);\n\t\tl = pgm_read_word(n++);\n\t}\n}\n\n#define CAP_VALUE_MIN (u8)  9\n#define CAP_VALUE_MAX (u8) 40\n#define HR_MIN\t      (u8) 25\n#define HR_MAX\t      (u8) 40\n#define POLY_MIN      (u8)  0\n#define POLY_MAX      (u8)  8\n\nstatic void dib0090_set_EFUSE(struct dib0090_state *state)\n{\n\tu8 c, h, n;\n\tu16 e2, e4;\n\tu16 cal;\n\n\te2 = dib0090_read_reg(state, 0x26);\n\te4 = dib0090_read_reg(state, 0x28);\n\n\tif ((state->identity.version == P1D_E_F) ||\n\t\t\t(state->identity.version == P1G) || (e2 == 0xffff)) {\n\n\t\tdib0090_write_reg(state, 0x22, 0x10);\n\t\tcal = (dib0090_read_reg(state, 0x22) >> 6) & 0x3ff;\n\n\t\tif ((cal < 670) || (cal == 1023))\n\t\t\tcal = 850;\n\t\tn = 165 - ((cal * 10)>>6) ;\n\t\te2 = e4 = (3<<12) | (34<<6) | (n);\n\t}\n\n\tif (e2 != e4)\n\t\te2 &= e4;  \n\n\tif (e2 != 0xffff) {\n\t\tc = e2 & 0x3f;\n\t\tn = (e2 >> 12) & 0xf;\n\t\th = (e2 >> 6) & 0x3f;\n\n\t\tif ((c >= CAP_VALUE_MAX) || (c <= CAP_VALUE_MIN))\n\t\t\tc = 32;\n\t\telse\n\t\t\tc += 14;\n\t\tif ((h >= HR_MAX) || (h <= HR_MIN))\n\t\t\th = 34;\n\t\tif ((n >= POLY_MAX) || (n <= POLY_MIN))\n\t\t\tn = 3;\n\n\t\tdib0090_write_reg(state, 0x13, (h << 10));\n\t\te2 = (n << 11) | ((h >> 2)<<6) | c;\n\t\tdib0090_write_reg(state, 0x2, e2);  \n\t}\n}\n\nstatic int dib0090_reset(struct dvb_frontend *fe)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\n\tdib0090_reset_digital(fe, state->config);\n\tif (dib0090_identify(fe) < 0)\n\t\treturn -EIO;\n\n#ifdef CONFIG_TUNER_DIB0090_P1B_SUPPORT\n\tif (!(state->identity.version & 0x1))\t \n\t\treturn 0;\n#endif\n\n\tif (!state->identity.in_soc) {\n\t\tif ((dib0090_read_reg(state, 0x1a) >> 5) & 0x2)\n\t\t\tdib0090_write_reg(state, 0x1b, (EN_IQADC | EN_BB | EN_BIAS | EN_DIGCLK | EN_PLL | EN_CRYSTAL));\n\t\telse\n\t\t\tdib0090_write_reg(state, 0x1b, (EN_DIGCLK | EN_PLL | EN_CRYSTAL));\n\t}\n\n\tdib0090_set_default_config(state, dib0090_defaults);\n\n\tif (state->identity.in_soc)\n\t\tdib0090_write_reg(state, 0x18, 0x2910);   \n\n\tif (state->identity.p1g)\n\t\tdib0090_set_default_config(state, dib0090_p1g_additionnal_defaults);\n\n\t \n\tif (((state->identity.version & 0x1f) >= P1D_E_F) || (state->identity.in_soc))\n\t\tdib0090_set_EFUSE(state);\n\n\t \n\tif (state->config->force_crystal_mode != 0)\n\t\tdib0090_write_reg(state, 0x14,\n\t\t\t\tstate->config->force_crystal_mode & 3);\n\telse if (state->config->io.clock_khz >= 24000)\n\t\tdib0090_write_reg(state, 0x14, 1);\n\telse\n\t\tdib0090_write_reg(state, 0x14, 2);\n\tdprintk(\"Pll lock : %d\\n\", (dib0090_read_reg(state, 0x1a) >> 11) & 0x1);\n\n\tstate->calibrate = DC_CAL | WBD_CAL | TEMP_CAL;\t \n\n\treturn 0;\n}\n\n#define steps(u) (((u) > 15) ? ((u)-16) : (u))\n#define INTERN_WAIT 10\nstatic int dib0090_get_offset(struct dib0090_state *state, enum frontend_tune_state *tune_state)\n{\n\tint ret = INTERN_WAIT * 10;\n\n\tswitch (*tune_state) {\n\tcase CT_TUNER_STEP_2:\n\t\t \n\t\tdib0090_write_reg(state, 0x1f, 0x7);\n\t\t*tune_state = CT_TUNER_STEP_3;\n\t\tbreak;\n\n\tcase CT_TUNER_STEP_3:\n\t\tstate->adc_diff = dib0090_read_reg(state, 0x1d);\n\n\t\t \n\t\tdib0090_write_reg(state, 0x1f, 0x4);\n\t\t*tune_state = CT_TUNER_STEP_4;\n\t\tbreak;\n\n\tcase CT_TUNER_STEP_4:\n\t\tstate->adc_diff -= dib0090_read_reg(state, 0x1d);\n\t\t*tune_state = CT_TUNER_STEP_5;\n\t\tret = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstruct dc_calibration {\n\tu8 addr;\n\tu8 offset;\n\tu8 pga:1;\n\tu16 bb1;\n\tu8 i:1;\n};\n\nstatic const struct dc_calibration dc_table[] = {\n\t \n\t{0x06, 5, 1, (1 << 13) | (0 << 8) | (26 << 3), 1},\n\t{0x07, 11, 1, (1 << 13) | (0 << 8) | (26 << 3), 0},\n\t \n\t{0x06, 0, 0, (1 << 13) | (29 << 8) | (26 << 3), 1},\n\t{0x06, 10, 0, (1 << 13) | (29 << 8) | (26 << 3), 0},\n\t{0},\n};\n\nstatic const struct dc_calibration dc_p1g_table[] = {\n\t \n\t \n\t{0x06, 5, 1, (1 << 13) | (0 << 8) | (15 << 3), 1},\n\t{0x07, 11, 1, (1 << 13) | (0 << 8) | (15 << 3), 0},\n\t \n\t{0x06, 0, 0, (1 << 13) | (29 << 8) | (15 << 3), 1},\n\t{0x06, 10, 0, (1 << 13) | (29 << 8) | (15 << 3), 0},\n\t{0},\n};\n\nstatic void dib0090_set_trim(struct dib0090_state *state)\n{\n\tu16 *val;\n\n\tif (state->dc->addr == 0x07)\n\t\tval = &state->bb7;\n\telse\n\t\tval = &state->bb6;\n\n\t*val &= ~(0x1f << state->dc->offset);\n\t*val |= state->step << state->dc->offset;\n\n\tdib0090_write_reg(state, state->dc->addr, *val);\n}\n\nstatic int dib0090_dc_offset_calibration(struct dib0090_state *state, enum frontend_tune_state *tune_state)\n{\n\tint ret = 0;\n\tu16 reg;\n\n\tswitch (*tune_state) {\n\tcase CT_TUNER_START:\n\t\tdprintk(\"Start DC offset calibration\");\n\n\t\t \n\t\tstate->bb6 = 0;\n\t\tstate->bb7 = 0x040d;\n\n\t\t \n\t\treg = dib0090_read_reg(state, 0x24) & 0x0ffb;\t \n\t\tdib0090_write_reg(state, 0x24, reg);\n\n\t\tstate->wbdmux = dib0090_read_reg(state, 0x10);\n\t\tdib0090_write_reg(state, 0x10, (state->wbdmux & ~(0xff << 3)) | (0x7 << 3) | 0x3);\n\t\tdib0090_write_reg(state, 0x23, dib0090_read_reg(state, 0x23) & ~(1 << 14));\n\n\t\tstate->dc = dc_table;\n\n\t\tif (state->identity.p1g)\n\t\t\tstate->dc = dc_p1g_table;\n\n\t\tfallthrough;\n\tcase CT_TUNER_STEP_0:\n\t\tdprintk(\"Start/continue DC calibration for %s path\\n\",\n\t\t\t(state->dc->i == 1) ? \"I\" : \"Q\");\n\t\tdib0090_write_reg(state, 0x01, state->dc->bb1);\n\t\tdib0090_write_reg(state, 0x07, state->bb7 | (state->dc->i << 7));\n\n\t\tstate->step = 0;\n\t\tstate->min_adc_diff = 1023;\n\t\t*tune_state = CT_TUNER_STEP_1;\n\t\tret = 50;\n\t\tbreak;\n\n\tcase CT_TUNER_STEP_1:\n\t\tdib0090_set_trim(state);\n\t\t*tune_state = CT_TUNER_STEP_2;\n\t\tbreak;\n\n\tcase CT_TUNER_STEP_2:\n\tcase CT_TUNER_STEP_3:\n\tcase CT_TUNER_STEP_4:\n\t\tret = dib0090_get_offset(state, tune_state);\n\t\tbreak;\n\n\tcase CT_TUNER_STEP_5:\t \n\t\tdprintk(\"adc_diff = %d, current step= %d\\n\", (u32) state->adc_diff, state->step);\n\t\tif (state->step == 0 && state->adc_diff < 0) {\n\t\t\tstate->min_adc_diff = -1023;\n\t\t\tdprintk(\"Change of sign of the minimum adc diff\\n\");\n\t\t}\n\n\t\tdprintk(\"adc_diff = %d, min_adc_diff = %d current_step = %d\\n\", state->adc_diff, state->min_adc_diff, state->step);\n\n\t\t \n\t\tif (state->step == 0) {\n\t\t\tif (state->dc->pga && state->adc_diff < 0)\n\t\t\t\tstate->step = 0x10;\n\t\t\tif (state->dc->pga == 0 && state->adc_diff > 0)\n\t\t\t\tstate->step = 0x10;\n\t\t}\n\n\t\t \n\t\tif ((state->adc_diff & 0x8000) == (state->min_adc_diff & 0x8000) && steps(state->step) < 15) {\n\t\t\t \n\t\t\tstate->step++;\n\t\t\tstate->min_adc_diff = state->adc_diff;\n\t\t\t*tune_state = CT_TUNER_STEP_1;\n\t\t} else {\n\t\t\t \n\t\t\tif (abs(state->adc_diff) > abs(state->min_adc_diff)) {\n\t\t\t\tdprintk(\"Since adc_diff N = %d  > adc_diff step N-1 = %d, Come back one step\\n\", state->adc_diff, state->min_adc_diff);\n\t\t\t\tstate->step--;\n\t\t\t}\n\n\t\t\tdib0090_set_trim(state);\n\t\t\tdprintk(\"BB Offset Cal, BBreg=%u,Offset=%d,Value Set=%d\\n\",\n\t\t\t\tstate->dc->addr, state->adc_diff, state->step);\n\n\t\t\tstate->dc++;\n\t\t\tif (state->dc->addr == 0)\t \n\t\t\t\t*tune_state = CT_TUNER_STEP_6;\n\t\t\telse\n\t\t\t\t*tune_state = CT_TUNER_STEP_0;\n\n\t\t}\n\t\tbreak;\n\n\tcase CT_TUNER_STEP_6:\n\t\tdib0090_write_reg(state, 0x07, state->bb7 & ~0x0008);\n\t\tdib0090_write_reg(state, 0x1f, 0x7);\n\t\t*tune_state = CT_TUNER_START;\t \n\t\tstate->calibrate &= ~DC_CAL;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int dib0090_wbd_calibration(struct dib0090_state *state, enum frontend_tune_state *tune_state)\n{\n\tu8 wbd_gain;\n\tconst struct dib0090_wbd_slope *wbd = state->current_wbd_table;\n\n\tswitch (*tune_state) {\n\tcase CT_TUNER_START:\n\t\twhile (state->current_rf / 1000 > wbd->max_freq)\n\t\t\twbd++;\n\t\tif (wbd->wbd_gain != 0)\n\t\t\twbd_gain = wbd->wbd_gain;\n\t\telse {\n\t\t\twbd_gain = 4;\n#if defined(CONFIG_BAND_LBAND) || defined(CONFIG_BAND_SBAND)\n\t\t\tif ((state->current_band == BAND_LBAND) || (state->current_band == BAND_SBAND))\n\t\t\t\twbd_gain = 2;\n#endif\n\t\t}\n\n\t\tif (wbd_gain == state->wbd_calibration_gain) {\t \n\t\t\t*tune_state = CT_TUNER_START;\n\t\t\tstate->calibrate &= ~WBD_CAL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdib0090_write_reg(state, 0x10, 0x1b81 | (1 << 10) | (wbd_gain << 13) | (1 << 3));\n\n\t\tdib0090_write_reg(state, 0x24, ((EN_UHF & 0x0fff) | (1 << 1)));\n\t\t*tune_state = CT_TUNER_STEP_0;\n\t\tstate->wbd_calibration_gain = wbd_gain;\n\t\treturn 90;\t \n\n\tcase CT_TUNER_STEP_0:\n\t\tstate->wbd_offset = dib0090_get_slow_adc_val(state);\n\t\tdprintk(\"WBD calibration offset = %d\\n\", state->wbd_offset);\n\t\t*tune_state = CT_TUNER_START;\t \n\t\tstate->calibrate &= ~WBD_CAL;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void dib0090_set_bandwidth(struct dib0090_state *state)\n{\n\tu16 tmp;\n\n\tif (state->fe->dtv_property_cache.bandwidth_hz / 1000 <= 5000)\n\t\ttmp = (3 << 14);\n\telse if (state->fe->dtv_property_cache.bandwidth_hz / 1000 <= 6000)\n\t\ttmp = (2 << 14);\n\telse if (state->fe->dtv_property_cache.bandwidth_hz / 1000 <= 7000)\n\t\ttmp = (1 << 14);\n\telse\n\t\ttmp = (0 << 14);\n\n\tstate->bb_1_def &= 0x3fff;\n\tstate->bb_1_def |= tmp;\n\n\tdib0090_write_reg(state, 0x01, state->bb_1_def);\t \n\n\tdib0090_write_reg(state, 0x03, 0x6008);\t \n\tdib0090_write_reg(state, 0x04, 0x1);\t \n\tif (state->identity.in_soc) {\n\t\tdib0090_write_reg(state, 0x05, 0x9bcf);  \n\t} else {\n\t\tdib0090_write_reg(state, 0x02, (5 << 11) | (8 << 6) | (22 & 0x3f));\t \n\t\tdib0090_write_reg(state, 0x05, 0xabcd);\t \n\t}\n}\n\nstatic const struct dib0090_pll dib0090_pll_table[] = {\n#ifdef CONFIG_BAND_CBAND\n\t{56000, 0, 9, 48, 6},\n\t{70000, 1, 9, 48, 6},\n\t{87000, 0, 8, 32, 4},\n\t{105000, 1, 8, 32, 4},\n\t{115000, 0, 7, 24, 6},\n\t{140000, 1, 7, 24, 6},\n\t{170000, 0, 6, 16, 4},\n#endif\n#ifdef CONFIG_BAND_VHF\n\t{200000, 1, 6, 16, 4},\n\t{230000, 0, 5, 12, 6},\n\t{280000, 1, 5, 12, 6},\n\t{340000, 0, 4, 8, 4},\n\t{380000, 1, 4, 8, 4},\n\t{450000, 0, 3, 6, 6},\n#endif\n#ifdef CONFIG_BAND_UHF\n\t{580000, 1, 3, 6, 6},\n\t{700000, 0, 2, 4, 4},\n\t{860000, 1, 2, 4, 4},\n#endif\n#ifdef CONFIG_BAND_LBAND\n\t{1800000, 1, 0, 2, 4},\n#endif\n#ifdef CONFIG_BAND_SBAND\n\t{2900000, 0, 14, 1, 4},\n#endif\n};\n\nstatic const struct dib0090_tuning dib0090_tuning_table_fm_vhf_on_cband[] = {\n\n#ifdef CONFIG_BAND_CBAND\n\t{184000, 4, 1, 15, 0x280, 0x2912, 0xb94e, EN_CAB},\n\t{227000, 4, 3, 15, 0x280, 0x2912, 0xb94e, EN_CAB},\n\t{380000, 4, 7, 15, 0x280, 0x2912, 0xb94e, EN_CAB},\n#endif\n#ifdef CONFIG_BAND_UHF\n\t{520000, 2, 0, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{550000, 2, 2, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{650000, 2, 3, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{750000, 2, 5, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{850000, 2, 6, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{900000, 2, 7, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n#endif\n#ifdef CONFIG_BAND_LBAND\n\t{1500000, 4, 0, 20, 0x300, 0x1912, 0x82c9, EN_LBD},\n\t{1600000, 4, 1, 20, 0x300, 0x1912, 0x82c9, EN_LBD},\n\t{1800000, 4, 3, 20, 0x300, 0x1912, 0x82c9, EN_LBD},\n#endif\n#ifdef CONFIG_BAND_SBAND\n\t{2300000, 1, 4, 20, 0x300, 0x2d2A, 0x82c7, EN_SBD},\n\t{2900000, 1, 7, 20, 0x280, 0x2deb, 0x8347, EN_SBD},\n#endif\n};\n\nstatic const struct dib0090_tuning dib0090_tuning_table[] = {\n\n#ifdef CONFIG_BAND_CBAND\n\t{170000, 4, 1, 15, 0x280, 0x2912, 0xb94e, EN_CAB},\n#endif\n#ifdef CONFIG_BAND_VHF\n\t{184000, 1, 1, 15, 0x300, 0x4d12, 0xb94e, EN_VHF},\n\t{227000, 1, 3, 15, 0x300, 0x4d12, 0xb94e, EN_VHF},\n\t{380000, 1, 7, 15, 0x300, 0x4d12, 0xb94e, EN_VHF},\n#endif\n#ifdef CONFIG_BAND_UHF\n\t{520000, 2, 0, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{550000, 2, 2, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{650000, 2, 3, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{750000, 2, 5, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{850000, 2, 6, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{900000, 2, 7, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n#endif\n#ifdef CONFIG_BAND_LBAND\n\t{1500000, 4, 0, 20, 0x300, 0x1912, 0x82c9, EN_LBD},\n\t{1600000, 4, 1, 20, 0x300, 0x1912, 0x82c9, EN_LBD},\n\t{1800000, 4, 3, 20, 0x300, 0x1912, 0x82c9, EN_LBD},\n#endif\n#ifdef CONFIG_BAND_SBAND\n\t{2300000, 1, 4, 20, 0x300, 0x2d2A, 0x82c7, EN_SBD},\n\t{2900000, 1, 7, 20, 0x280, 0x2deb, 0x8347, EN_SBD},\n#endif\n};\n\nstatic const struct dib0090_tuning dib0090_p1g_tuning_table[] = {\n#ifdef CONFIG_BAND_CBAND\n\t{170000, 4, 1, 0x820f, 0x300, 0x2d22, 0x82cb, EN_CAB},\n#endif\n#ifdef CONFIG_BAND_VHF\n\t{184000, 1, 1, 15, 0x300, 0x4d12, 0xb94e, EN_VHF},\n\t{227000, 1, 3, 15, 0x300, 0x4d12, 0xb94e, EN_VHF},\n\t{380000, 1, 7, 15, 0x300, 0x4d12, 0xb94e, EN_VHF},\n#endif\n#ifdef CONFIG_BAND_UHF\n\t{510000, 2, 0, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{540000, 2, 1, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{600000, 2, 3, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{630000, 2, 4, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{680000, 2, 5, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{720000, 2, 6, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{900000, 2, 7, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n#endif\n#ifdef CONFIG_BAND_LBAND\n\t{1500000, 4, 0, 20, 0x300, 0x1912, 0x82c9, EN_LBD},\n\t{1600000, 4, 1, 20, 0x300, 0x1912, 0x82c9, EN_LBD},\n\t{1800000, 4, 3, 20, 0x300, 0x1912, 0x82c9, EN_LBD},\n#endif\n#ifdef CONFIG_BAND_SBAND\n\t{2300000, 1, 4, 20, 0x300, 0x2d2A, 0x82c7, EN_SBD},\n\t{2900000, 1, 7, 20, 0x280, 0x2deb, 0x8347, EN_SBD},\n#endif\n};\n\nstatic const struct dib0090_pll dib0090_p1g_pll_table[] = {\n#ifdef CONFIG_BAND_CBAND\n\t{57000, 0, 11, 48, 6},\n\t{70000, 1, 11, 48, 6},\n\t{86000, 0, 10, 32, 4},\n\t{105000, 1, 10, 32, 4},\n\t{115000, 0, 9, 24, 6},\n\t{140000, 1, 9, 24, 6},\n\t{170000, 0, 8, 16, 4},\n#endif\n#ifdef CONFIG_BAND_VHF\n\t{200000, 1, 8, 16, 4},\n\t{230000, 0, 7, 12, 6},\n\t{280000, 1, 7, 12, 6},\n\t{340000, 0, 6, 8, 4},\n\t{380000, 1, 6, 8, 4},\n\t{455000, 0, 5, 6, 6},\n#endif\n#ifdef CONFIG_BAND_UHF\n\t{580000, 1, 5, 6, 6},\n\t{680000, 0, 4, 4, 4},\n\t{860000, 1, 4, 4, 4},\n#endif\n#ifdef CONFIG_BAND_LBAND\n\t{1800000, 1, 2, 2, 4},\n#endif\n#ifdef CONFIG_BAND_SBAND\n\t{2900000, 0, 1, 1, 6},\n#endif\n};\n\nstatic const struct dib0090_tuning dib0090_p1g_tuning_table_fm_vhf_on_cband[] = {\n#ifdef CONFIG_BAND_CBAND\n\t{184000, 4, 3, 0x4187, 0x2c0, 0x2d22, 0x81cb, EN_CAB},\n\t{227000, 4, 3, 0x4187, 0x2c0, 0x2d22, 0x81cb, EN_CAB},\n\t{380000, 4, 3, 0x4187, 0x2c0, 0x2d22, 0x81cb, EN_CAB},\n#endif\n#ifdef CONFIG_BAND_UHF\n\t{520000, 2, 0, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{550000, 2, 2, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{650000, 2, 3, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{750000, 2, 5, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{850000, 2, 6, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n\t{900000, 2, 7, 15, 0x300, 0x1d12, 0xb9ce, EN_UHF},\n#endif\n#ifdef CONFIG_BAND_LBAND\n\t{1500000, 4, 0, 20, 0x300, 0x1912, 0x82c9, EN_LBD},\n\t{1600000, 4, 1, 20, 0x300, 0x1912, 0x82c9, EN_LBD},\n\t{1800000, 4, 3, 20, 0x300, 0x1912, 0x82c9, EN_LBD},\n#endif\n#ifdef CONFIG_BAND_SBAND\n\t{2300000, 1, 4, 20, 0x300, 0x2d2A, 0x82c7, EN_SBD},\n\t{2900000, 1, 7, 20, 0x280, 0x2deb, 0x8347, EN_SBD},\n#endif\n};\n\nstatic const struct dib0090_tuning dib0090_tuning_table_cband_7090[] = {\n#ifdef CONFIG_BAND_CBAND\n\t{300000, 4, 3, 0x018F, 0x2c0, 0x2d22, 0xb9ce, EN_CAB},\n\t{380000, 4, 10, 0x018F, 0x2c0, 0x2d22, 0xb9ce, EN_CAB},\n\t{570000, 4, 10, 0x8190, 0x2c0, 0x2d22, 0xb9ce, EN_CAB},\n\t{858000, 4, 5, 0x8190, 0x2c0, 0x2d22, 0xb9ce, EN_CAB},\n#endif\n};\n\nstatic const struct dib0090_tuning dib0090_tuning_table_cband_7090e_sensitivity[] = {\n#ifdef CONFIG_BAND_CBAND\n\t{ 300000,  0 ,  3,  0x8105, 0x2c0, 0x2d12, 0xb84e, EN_CAB },\n\t{ 380000,  0 ,  10, 0x810F, 0x2c0, 0x2d12, 0xb84e, EN_CAB },\n\t{ 600000,  0 ,  10, 0x815E, 0x280, 0x2d12, 0xb84e, EN_CAB },\n\t{ 660000,  0 ,  5,  0x85E3, 0x280, 0x2d12, 0xb84e, EN_CAB },\n\t{ 720000,  0 ,  5,  0x852E, 0x280, 0x2d12, 0xb84e, EN_CAB },\n\t{ 860000,  0 ,  4,  0x85E5, 0x280, 0x2d12, 0xb84e, EN_CAB },\n#endif\n};\n\nint dib0090_update_tuning_table_7090(struct dvb_frontend *fe,\n\t\tu8 cfg_sensitivity)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tconst struct dib0090_tuning *tune =\n\t\tdib0090_tuning_table_cband_7090e_sensitivity;\n\tstatic const struct dib0090_tuning dib0090_tuning_table_cband_7090e_aci[] = {\n\t\t{ 300000,  0 ,  3,  0x8165, 0x2c0, 0x2d12, 0xb84e, EN_CAB },\n\t\t{ 650000,  0 ,  4,  0x815B, 0x280, 0x2d12, 0xb84e, EN_CAB },\n\t\t{ 860000,  0 ,  5,  0x84EF, 0x280, 0x2d12, 0xb84e, EN_CAB },\n\t};\n\n\tif ((!state->identity.p1g) || (!state->identity.in_soc)\n\t\t\t|| ((state->identity.version != SOC_7090_P1G_21R1)\n\t\t\t\t&& (state->identity.version != SOC_7090_P1G_11R1))) {\n\t\tdprintk(\"%s() function can only be used for dib7090\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (cfg_sensitivity)\n\t\ttune = dib0090_tuning_table_cband_7090e_sensitivity;\n\telse\n\t\ttune = dib0090_tuning_table_cband_7090e_aci;\n\n\twhile (state->rf_request > tune->max_freq)\n\t\ttune++;\n\n\tdib0090_write_reg(state, 0x09, (dib0090_read_reg(state, 0x09) & 0x8000)\n\t\t\t| (tune->lna_bias & 0x7fff));\n\tdib0090_write_reg(state, 0x0b, (dib0090_read_reg(state, 0x0b) & 0xf83f)\n\t\t\t| ((tune->lna_tune << 6) & 0x07c0));\n\treturn 0;\n}\nEXPORT_SYMBOL(dib0090_update_tuning_table_7090);\n\nstatic int dib0090_captrim_search(struct dib0090_state *state, enum frontend_tune_state *tune_state)\n{\n\tint ret = 0;\n\tu16 lo4 = 0xe900;\n\n\ts16 adc_target;\n\tu16 adc;\n\ts8 step_sign;\n\tu8 force_soft_search = 0;\n\n\tif (state->identity.version == SOC_8090_P1G_11R1 || state->identity.version == SOC_8090_P1G_21R1)\n\t\tforce_soft_search = 1;\n\n\tif (*tune_state == CT_TUNER_START) {\n\t\tdprintk(\"Start Captrim search : %s\\n\",\n\t\t\t(force_soft_search == 1) ? \"FORCE SOFT SEARCH\" : \"AUTO\");\n\t\tdib0090_write_reg(state, 0x10, 0x2B1);\n\t\tdib0090_write_reg(state, 0x1e, 0x0032);\n\n\t\tif (!state->tuner_is_tuned) {\n\t\t\t \n\t\t\tif (!state->identity.p1g || force_soft_search)\n\t\t\t\tstate->step = state->captrim = state->fcaptrim = 64;\n\n\t\t\tstate->current_rf = state->rf_request;\n\t\t} else {\t \n\t\t\tif (!state->identity.p1g || force_soft_search) {\n\t\t\t\t \n\t\t\t\tstate->step = 4;\n\t\t\t\tstate->captrim = state->fcaptrim = dib0090_read_reg(state, 0x18) & 0x7f;\n\t\t\t}\n\t\t}\n\t\tstate->adc_diff = 3000;\n\t\t*tune_state = CT_TUNER_STEP_0;\n\n\t} else if (*tune_state == CT_TUNER_STEP_0) {\n\t\tif (state->identity.p1g && !force_soft_search) {\n\t\t\tu8 ratio = 31;\n\n\t\t\tdib0090_write_reg(state, 0x40, (3 << 7) | (ratio << 2) | (1 << 1) | 1);\n\t\t\tdib0090_read_reg(state, 0x40);\n\t\t\tret = 50;\n\t\t} else {\n\t\t\tstate->step /= 2;\n\t\t\tdib0090_write_reg(state, 0x18, lo4 | state->captrim);\n\n\t\t\tif (state->identity.in_soc)\n\t\t\t\tret = 25;\n\t\t}\n\t\t*tune_state = CT_TUNER_STEP_1;\n\n\t} else if (*tune_state == CT_TUNER_STEP_1) {\n\t\tif (state->identity.p1g && !force_soft_search) {\n\t\t\tdib0090_write_reg(state, 0x40, 0x18c | (0 << 1) | 0);\n\t\t\tdib0090_read_reg(state, 0x40);\n\n\t\t\tstate->fcaptrim = dib0090_read_reg(state, 0x18) & 0x7F;\n\t\t\tdprintk(\"***Final Captrim= 0x%x\\n\", state->fcaptrim);\n\t\t\t*tune_state = CT_TUNER_STEP_3;\n\n\t\t} else {\n\t\t\t \n\t\t\tadc = dib0090_get_slow_adc_val(state);\n\t\t\tdprintk(\"CAPTRIM=%d; ADC = %d (ADC) & %dmV\\n\", (u32) state->captrim, (u32) adc, (u32) (adc) * (u32) 1800 / (u32) 1024);\n\n\t\t\tif (state->rest == 0 || state->identity.in_soc) {\t \n\t\t\t\tadc_target = 200;\n\t\t\t} else\n\t\t\t\tadc_target = 400;\n\n\t\t\tif (adc >= adc_target) {\n\t\t\t\tadc -= adc_target;\n\t\t\t\tstep_sign = -1;\n\t\t\t} else {\n\t\t\t\tadc = adc_target - adc;\n\t\t\t\tstep_sign = 1;\n\t\t\t}\n\n\t\t\tif (adc < state->adc_diff) {\n\t\t\t\tdprintk(\"CAPTRIM=%d is closer to target (%d/%d)\\n\", (u32) state->captrim, (u32) adc, (u32) state->adc_diff);\n\t\t\t\tstate->adc_diff = adc;\n\t\t\t\tstate->fcaptrim = state->captrim;\n\t\t\t}\n\n\t\t\tstate->captrim += step_sign * state->step;\n\t\t\tif (state->step >= 1)\n\t\t\t\t*tune_state = CT_TUNER_STEP_0;\n\t\t\telse\n\t\t\t\t*tune_state = CT_TUNER_STEP_2;\n\n\t\t\tret = 25;\n\t\t}\n\t} else if (*tune_state == CT_TUNER_STEP_2) {\t \n\t\t \n\t\tdib0090_write_reg(state, 0x18, lo4 | state->fcaptrim);\n\n\t\t*tune_state = CT_TUNER_STEP_3;\n\n\t} else if (*tune_state == CT_TUNER_STEP_3) {\n\t\tstate->calibrate &= ~CAPTRIM_CAL;\n\t\t*tune_state = CT_TUNER_STEP_0;\n\t}\n\n\treturn ret;\n}\n\nstatic int dib0090_get_temperature(struct dib0090_state *state, enum frontend_tune_state *tune_state)\n{\n\tint ret = 15;\n\ts16 val;\n\n\tswitch (*tune_state) {\n\tcase CT_TUNER_START:\n\t\tstate->wbdmux = dib0090_read_reg(state, 0x10);\n\t\tdib0090_write_reg(state, 0x10, (state->wbdmux & ~(0xff << 3)) | (0x8 << 3));\n\n\t\tstate->bias = dib0090_read_reg(state, 0x13);\n\t\tdib0090_write_reg(state, 0x13, state->bias | (0x3 << 8));\n\n\t\t*tune_state = CT_TUNER_STEP_0;\n\t\t \n\t\tbreak;\n\n\tcase CT_TUNER_STEP_0:\n\t\tstate->adc_diff = dib0090_get_slow_adc_val(state);\n\t\tdib0090_write_reg(state, 0x13, (state->bias & ~(0x3 << 8)) | (0x2 << 8));\n\t\t*tune_state = CT_TUNER_STEP_1;\n\t\tbreak;\n\n\tcase CT_TUNER_STEP_1:\n\t\tval = dib0090_get_slow_adc_val(state);\n\t\tstate->temperature = ((s16) ((val - state->adc_diff) * 180) >> 8) + 55;\n\n\t\tdprintk(\"temperature: %d C\\n\", state->temperature - 30);\n\n\t\t*tune_state = CT_TUNER_STEP_2;\n\t\tbreak;\n\n\tcase CT_TUNER_STEP_2:\n\t\tdib0090_write_reg(state, 0x13, state->bias);\n\t\tdib0090_write_reg(state, 0x10, state->wbdmux);\t \n\n\t\t*tune_state = CT_TUNER_START;\n\t\tstate->calibrate &= ~TEMP_CAL;\n\t\tif (state->config->analog_output == 0)\n\t\t\tdib0090_write_reg(state, 0x23, dib0090_read_reg(state, 0x23) | (1 << 14));\n\n\t\tbreak;\n\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n#define WBD     0x781\t\t \nstatic int dib0090_tune(struct dvb_frontend *fe)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tconst struct dib0090_tuning *tune = state->current_tune_table_index;\n\tconst struct dib0090_pll *pll = state->current_pll_table_index;\n\tenum frontend_tune_state *tune_state = &state->tune_state;\n\n\tu16 lo5, lo6, Den, tmp;\n\tu32 FBDiv, Rest, FREF, VCOF_kHz = 0;\n\tint ret = 10;\t\t \n\tu8 c, i;\n\n\t \n\t \n\t \n\t \n\n\t \n\tif (*tune_state == CT_TUNER_START) {\n\t\t \n\t\tif (state->calibrate & (DC_CAL | TEMP_CAL | WBD_CAL))\n\t\t\tdib0090_write_reg(state, 0x23, dib0090_read_reg(state, 0x23) & ~(1 << 14));\n\t\telse\n\t\t\t \n\t\t\tif (state->config->analog_output == 0)\n\t\t\t\tdib0090_write_reg(state, 0x23, dib0090_read_reg(state, 0x23) | (1 << 14));\n\t}\n\n\tif (state->calibrate & DC_CAL)\n\t\treturn dib0090_dc_offset_calibration(state, tune_state);\n\telse if (state->calibrate & WBD_CAL) {\n\t\tif (state->current_rf == 0)\n\t\t\tstate->current_rf = state->fe->dtv_property_cache.frequency / 1000;\n\t\treturn dib0090_wbd_calibration(state, tune_state);\n\t} else if (state->calibrate & TEMP_CAL)\n\t\treturn dib0090_get_temperature(state, tune_state);\n\telse if (state->calibrate & CAPTRIM_CAL)\n\t\treturn dib0090_captrim_search(state, tune_state);\n\n\tif (*tune_state == CT_TUNER_START) {\n\t\t \n\t\tif (state->config->use_pwm_agc && state->identity.in_soc) {\n\t\t\ttmp = dib0090_read_reg(state, 0x39);\n\t\t\tif ((tmp >> 10) & 0x1)\n\t\t\t\tdib0090_write_reg(state, 0x39, tmp & ~(1 << 10));\n\t\t}\n\n\t\tstate->current_band = (u8) BAND_OF_FREQUENCY(state->fe->dtv_property_cache.frequency / 1000);\n\t\tstate->rf_request =\n\t\t\tstate->fe->dtv_property_cache.frequency / 1000 + (state->current_band ==\n\t\t\t\t\tBAND_UHF ? state->config->freq_offset_khz_uhf : state->config->\n\t\t\t\t\tfreq_offset_khz_vhf);\n\n\t\t \n\t\tif ((state->fe->dtv_property_cache.delivery_system == SYS_ISDBT && state->fe->dtv_property_cache.isdbt_sb_mode == 1\n\t\t\t\t\t&& state->fe->dtv_property_cache.isdbt_partial_reception == 0)) {\n\t\t\tconst struct dib0090_low_if_offset_table *LUT_offset = state->config->low_if;\n\t\t\tu8 found_offset = 0;\n\t\t\tu32 margin_khz = 100;\n\n\t\t\tif (LUT_offset != NULL) {\n\t\t\t\twhile (LUT_offset->RF_freq != 0xffff) {\n\t\t\t\t\tif (((state->rf_request > (LUT_offset->RF_freq - margin_khz))\n\t\t\t\t\t\t\t\t&& (state->rf_request < (LUT_offset->RF_freq + margin_khz)))\n\t\t\t\t\t\t\t&& LUT_offset->std == state->fe->dtv_property_cache.delivery_system) {\n\t\t\t\t\t\tstate->rf_request += LUT_offset->offset_khz;\n\t\t\t\t\t\tfound_offset = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tLUT_offset++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (found_offset == 0)\n\t\t\t\tstate->rf_request += 400;\n\t\t}\n\t\tif (state->current_rf != state->rf_request || (state->current_standard != state->fe->dtv_property_cache.delivery_system)) {\n\t\t\tstate->tuner_is_tuned = 0;\n\t\t\tstate->current_rf = 0;\n\t\t\tstate->current_standard = 0;\n\n\t\t\ttune = dib0090_tuning_table;\n\t\t\tif (state->identity.p1g)\n\t\t\t\ttune = dib0090_p1g_tuning_table;\n\n\t\t\ttmp = (state->identity.version >> 5) & 0x7;\n\n\t\t\tif (state->identity.in_soc) {\n\t\t\t\tif (state->config->force_cband_input) {\t \n\t\t\t\t\tif (state->current_band & BAND_CBAND || state->current_band & BAND_FM || state->current_band & BAND_VHF\n\t\t\t\t\t\t\t|| state->current_band & BAND_UHF) {\n\t\t\t\t\t\tstate->current_band = BAND_CBAND;\n\t\t\t\t\t\tif (state->config->is_dib7090e)\n\t\t\t\t\t\t\ttune = dib0090_tuning_table_cband_7090e_sensitivity;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttune = dib0090_tuning_table_cband_7090;\n\t\t\t\t\t}\n\t\t\t\t} else {\t \n\t\t\t\t\tif (state->current_band & BAND_CBAND || state->current_band & BAND_FM || state->current_band & BAND_VHF) {\n\t\t\t\t\t\tstate->current_band = BAND_CBAND;\n\t\t\t\t\t\tif (state->config->is_dib7090e)\n\t\t\t\t\t\t\ttune = dib0090_tuning_table_cband_7090e_sensitivity;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttune = dib0090_tuning_table_cband_7090;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t if (tmp == 0x4 || tmp == 0x7) {\n\t\t\t\t \n\t\t\t\tif (state->current_band == BAND_FM || state->current_band == BAND_CBAND || state->current_band == BAND_VHF) {\n\t\t\t\t\tstate->current_band = BAND_CBAND;\t \n\n\t\t\t\t\ttune = dib0090_tuning_table_fm_vhf_on_cband;\n\t\t\t\t\tif (state->identity.p1g)\n\t\t\t\t\t\ttune = dib0090_p1g_tuning_table_fm_vhf_on_cband;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpll = dib0090_pll_table;\n\t\t\tif (state->identity.p1g)\n\t\t\t\tpll = dib0090_p1g_pll_table;\n\n\t\t\t \n\t\t\twhile (state->rf_request > tune->max_freq)\n\t\t\t\ttune++;\n\t\t\twhile (state->rf_request > pll->max_freq)\n\t\t\t\tpll++;\n\n\t\t\tstate->current_tune_table_index = tune;\n\t\t\tstate->current_pll_table_index = pll;\n\n\t\t\tdib0090_write_reg(state, 0x0b, 0xb800 | (tune->switch_trim));\n\n\t\t\tVCOF_kHz = (pll->hfdiv * state->rf_request) * 2;\n\n\t\t\tFREF = state->config->io.clock_khz;\n\t\t\tif (state->config->fref_clock_ratio != 0)\n\t\t\t\tFREF /= state->config->fref_clock_ratio;\n\n\t\t\tFBDiv = (VCOF_kHz / pll->topresc / FREF);\n\t\t\tRest = (VCOF_kHz / pll->topresc) - FBDiv * FREF;\n\n\t\t\tif (Rest < LPF)\n\t\t\t\tRest = 0;\n\t\t\telse if (Rest < 2 * LPF)\n\t\t\t\tRest = 2 * LPF;\n\t\t\telse if (Rest > (FREF - LPF)) {\n\t\t\t\tRest = 0;\n\t\t\t\tFBDiv += 1;\n\t\t\t} else if (Rest > (FREF - 2 * LPF))\n\t\t\t\tRest = FREF - 2 * LPF;\n\t\t\tRest = (Rest * 6528) / (FREF / 10);\n\t\t\tstate->rest = Rest;\n\n\t\t\t \n\n\t\t\tif (Rest == 0) {\n\t\t\t\tif (pll->vco_band)\n\t\t\t\t\tlo5 = 0x049f;\n\t\t\t\telse\n\t\t\t\t\tlo5 = 0x041f;\n\t\t\t} else {\n\t\t\t\tif (pll->vco_band)\n\t\t\t\t\tlo5 = 0x049e;\n\t\t\t\telse if (state->config->analog_output)\n\t\t\t\t\tlo5 = 0x041d;\n\t\t\t\telse\n\t\t\t\t\tlo5 = 0x041c;\n\t\t\t}\n\n\t\t\tif (state->identity.p1g) {\t \n\t\t\t\tif (state->identity.in_soc) {\n\t\t\t\t\tif (state->identity.version == SOC_8090_P1G_11R1)\n\t\t\t\t\t\tlo5 = 0x46f;\n\t\t\t\t\telse\n\t\t\t\t\t\tlo5 = 0x42f;\n\t\t\t\t} else\n\t\t\t\t\tlo5 = 0x42c;\n\t\t\t}\n\n\t\t\tlo5 |= (pll->hfdiv_code << 11) | (pll->vco_band << 7);\t \n\n\t\t\tif (!state->config->io.pll_int_loop_filt) {\n\t\t\t\tif (state->identity.in_soc)\n\t\t\t\t\tlo6 = 0xff98;\n\t\t\t\telse if (state->identity.p1g || (Rest == 0))\n\t\t\t\t\tlo6 = 0xfff8;\n\t\t\t\telse\n\t\t\t\t\tlo6 = 0xff28;\n\t\t\t} else\n\t\t\t\tlo6 = (state->config->io.pll_int_loop_filt << 3);\n\n\t\t\tDen = 1;\n\n\t\t\tif (Rest > 0) {\n\t\t\t\tlo6 |= (1 << 2) | 2;\n\t\t\t\tDen = 255;\n\t\t\t}\n\t\t\tdib0090_write_reg(state, 0x15, (u16) FBDiv);\n\t\t\tif (state->config->fref_clock_ratio != 0)\n\t\t\t\tdib0090_write_reg(state, 0x16, (Den << 8) | state->config->fref_clock_ratio);\n\t\t\telse\n\t\t\t\tdib0090_write_reg(state, 0x16, (Den << 8) | 1);\n\t\t\tdib0090_write_reg(state, 0x17, (u16) Rest);\n\t\t\tdib0090_write_reg(state, 0x19, lo5);\n\t\t\tdib0090_write_reg(state, 0x1c, lo6);\n\n\t\t\tlo6 = tune->tuner_enable;\n\t\t\tif (state->config->analog_output)\n\t\t\t\tlo6 = (lo6 & 0xff9f) | 0x2;\n\n\t\t\tdib0090_write_reg(state, 0x24, lo6 | EN_LO | state->config->use_pwm_agc * EN_CRYSTAL);\n\n\t\t}\n\n\t\tstate->current_rf = state->rf_request;\n\t\tstate->current_standard = state->fe->dtv_property_cache.delivery_system;\n\n\t\tret = 20;\n\t\tstate->calibrate = CAPTRIM_CAL;\t \n\t}\n\n\telse if (*tune_state == CT_TUNER_STEP_0) {\t \n\t\tconst struct dib0090_wbd_slope *wbd = state->current_wbd_table;\n\n\t\twhile (state->current_rf / 1000 > wbd->max_freq)\n\t\t\twbd++;\n\n\t\tdib0090_write_reg(state, 0x1e, 0x07ff);\n\t\tdprintk(\"Final Captrim: %d\\n\", (u32) state->fcaptrim);\n\t\tdprintk(\"HFDIV code: %d\\n\", (u32) pll->hfdiv_code);\n\t\tdprintk(\"VCO = %d\\n\", (u32) pll->vco_band);\n\t\tdprintk(\"VCOF in kHz: %d ((%d*%d) << 1))\\n\", (u32) ((pll->hfdiv * state->rf_request) * 2), (u32) pll->hfdiv, (u32) state->rf_request);\n\t\tdprintk(\"REFDIV: %d, FREF: %d\\n\", (u32) 1, (u32) state->config->io.clock_khz);\n\t\tdprintk(\"FBDIV: %d, Rest: %d\\n\", (u32) dib0090_read_reg(state, 0x15), (u32) dib0090_read_reg(state, 0x17));\n\t\tdprintk(\"Num: %d, Den: %d, SD: %d\\n\", (u32) dib0090_read_reg(state, 0x17), (u32) (dib0090_read_reg(state, 0x16) >> 8),\n\t\t\t(u32) dib0090_read_reg(state, 0x1c) & 0x3);\n\n#define WBD     0x781\t\t \n\t\tc = 4;\n\t\ti = 3;\n\n\t\tif (wbd->wbd_gain != 0)\n\t\t\tc = wbd->wbd_gain;\n\n\t\tstate->wbdmux = (c << 13) | (i << 11) | (WBD | (state->config->use_pwm_agc << 1));\n\t\tdib0090_write_reg(state, 0x10, state->wbdmux);\n\n\t\tif ((tune->tuner_enable == EN_CAB) && state->identity.p1g) {\n\t\t\tdprintk(\"P1G : The cable band is selected and lna_tune = %d\\n\", tune->lna_tune);\n\t\t\tdib0090_write_reg(state, 0x09, tune->lna_bias);\n\t\t\tdib0090_write_reg(state, 0x0b, 0xb800 | (tune->lna_tune << 6) | (tune->switch_trim));\n\t\t} else\n\t\t\tdib0090_write_reg(state, 0x09, (tune->lna_tune << 5) | tune->lna_bias);\n\n\t\tdib0090_write_reg(state, 0x0c, tune->v2i);\n\t\tdib0090_write_reg(state, 0x0d, tune->mix);\n\t\tdib0090_write_reg(state, 0x0e, tune->load);\n\t\t*tune_state = CT_TUNER_STEP_1;\n\n\t} else if (*tune_state == CT_TUNER_STEP_1) {\n\t\t \n\t\tstate->rf_lt_def = 0x7c00;\n\n\t\tdib0090_set_bandwidth(state);\n\t\tstate->tuner_is_tuned = 1;\n\n\t\tstate->calibrate |= WBD_CAL;\n\t\tstate->calibrate |= TEMP_CAL;\n\t\t*tune_state = CT_TUNER_STOP;\n\t} else\n\t\tret = FE_CALLBACK_TIME_NEVER;\n\treturn ret;\n}\n\nstatic void dib0090_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nenum frontend_tune_state dib0090_get_tune_state(struct dvb_frontend *fe)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\n\treturn state->tune_state;\n}\n\nEXPORT_SYMBOL(dib0090_get_tune_state);\n\nint dib0090_set_tune_state(struct dvb_frontend *fe, enum frontend_tune_state tune_state)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\n\tstate->tune_state = tune_state;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(dib0090_set_tune_state);\n\nstatic int dib0090_get_frequency(struct dvb_frontend *fe, u32 * frequency)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\n\t*frequency = 1000 * state->current_rf;\n\treturn 0;\n}\n\nstatic int dib0090_set_params(struct dvb_frontend *fe)\n{\n\tstruct dib0090_state *state = fe->tuner_priv;\n\tu32 ret;\n\n\tstate->tune_state = CT_TUNER_START;\n\n\tdo {\n\t\tret = dib0090_tune(fe);\n\t\tif (ret == FE_CALLBACK_TIME_NEVER)\n\t\t\tbreak;\n\n\t\t \n\t\tret = 10 * (ret + 99)/100;\n\t\tusleep_range(ret * 1000, (ret + 1) * 1000);\n\t} while (state->tune_state != CT_TUNER_STOP);\n\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops dib0090_ops = {\n\t.info = {\n\t\t .name = \"DiBcom DiB0090\",\n\t\t .frequency_min_hz  =  45 * MHz,\n\t\t .frequency_max_hz  = 860 * MHz,\n\t\t .frequency_step_hz =   1 * kHz,\n\t\t },\n\t.release = dib0090_release,\n\n\t.init = dib0090_wakeup,\n\t.sleep = dib0090_sleep,\n\t.set_params = dib0090_set_params,\n\t.get_frequency = dib0090_get_frequency,\n};\n\nstatic const struct dvb_tuner_ops dib0090_fw_ops = {\n\t.info = {\n\t\t .name = \"DiBcom DiB0090\",\n\t\t .frequency_min_hz  =  45 * MHz,\n\t\t .frequency_max_hz  = 860 * MHz,\n\t\t .frequency_step_hz =   1 * kHz,\n\t\t },\n\t.release = dib0090_release,\n\n\t.init = NULL,\n\t.sleep = NULL,\n\t.set_params = NULL,\n\t.get_frequency = NULL,\n};\n\nstatic const struct dib0090_wbd_slope dib0090_wbd_table_default[] = {\n\t{470, 0, 250, 0, 100, 4},\n\t{860, 51, 866, 21, 375, 4},\n\t{1700, 0, 800, 0, 850, 4},\n\t{2900, 0, 250, 0, 100, 6},\n\t{0xFFFF, 0, 0, 0, 0, 0},\n};\n\nstruct dvb_frontend *dib0090_register(struct dvb_frontend *fe, struct i2c_adapter *i2c, const struct dib0090_config *config)\n{\n\tstruct dib0090_state *st = kzalloc(sizeof(struct dib0090_state), GFP_KERNEL);\n\tif (st == NULL)\n\t\treturn NULL;\n\n\tst->config = config;\n\tst->i2c = i2c;\n\tst->fe = fe;\n\tmutex_init(&st->i2c_buffer_lock);\n\tfe->tuner_priv = st;\n\n\tif (config->wbd == NULL)\n\t\tst->current_wbd_table = dib0090_wbd_table_default;\n\telse\n\t\tst->current_wbd_table = config->wbd;\n\n\tif (dib0090_reset(fe) != 0)\n\t\tgoto free_mem;\n\n\tpr_info(\"DiB0090: successfully identified\\n\");\n\tmemcpy(&fe->ops.tuner_ops, &dib0090_ops, sizeof(struct dvb_tuner_ops));\n\n\treturn fe;\n free_mem:\n\tkfree(st);\n\tfe->tuner_priv = NULL;\n\treturn NULL;\n}\n\nEXPORT_SYMBOL_GPL(dib0090_register);\n\nstruct dvb_frontend *dib0090_fw_register(struct dvb_frontend *fe, struct i2c_adapter *i2c, const struct dib0090_config *config)\n{\n\tstruct dib0090_fw_state *st = kzalloc(sizeof(struct dib0090_fw_state), GFP_KERNEL);\n\tif (st == NULL)\n\t\treturn NULL;\n\n\tst->config = config;\n\tst->i2c = i2c;\n\tst->fe = fe;\n\tmutex_init(&st->i2c_buffer_lock);\n\tfe->tuner_priv = st;\n\n\tif (dib0090_fw_reset_digital(fe, st->config) != 0)\n\t\tgoto free_mem;\n\n\tdprintk(\"DiB0090 FW: successfully identified\\n\");\n\tmemcpy(&fe->ops.tuner_ops, &dib0090_fw_ops, sizeof(struct dvb_tuner_ops));\n\n\treturn fe;\nfree_mem:\n\tkfree(st);\n\tfe->tuner_priv = NULL;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(dib0090_fw_register);\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_AUTHOR(\"Olivier Grenie <olivier.grenie@parrot.com>\");\nMODULE_DESCRIPTION(\"Driver for the DiBcom 0090 base-band RF Tuner\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}