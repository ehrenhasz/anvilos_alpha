{
  "module_name": "lgs8gl5.c",
  "hash_id": "8a9ee63bdfa682a1d80a85bcb219bbd2a16b6b81ec84348ef4a76590dc57a84b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/lgs8gl5.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <media/dvb_frontend.h>\n#include \"lgs8gl5.h\"\n\n\n#define REG_RESET\t\t0x02\n#define REG_RESET_OFF\t\t\t0x01\n#define REG_03\t\t\t0x03\n#define REG_04\t\t\t0x04\n#define REG_07\t\t\t0x07\n#define REG_09\t\t\t0x09\n#define REG_0A\t\t\t0x0a\n#define REG_0B\t\t\t0x0b\n#define REG_0C\t\t\t0x0c\n#define REG_37\t\t\t0x37\n#define REG_STRENGTH\t\t0x4b\n#define REG_STRENGTH_MASK\t\t0x7f\n#define REG_STRENGTH_CARRIER\t\t0x80\n#define REG_INVERSION\t\t0x7c\n#define REG_INVERSION_ON\t\t0x80\n#define REG_7D\t\t\t0x7d\n#define REG_7E\t\t\t0x7e\n#define REG_A2\t\t\t0xa2\n#define REG_STATUS\t\t0xa4\n#define REG_STATUS_SYNC\t\t0x04\n#define REG_STATUS_LOCK\t\t0x01\n\n\nstruct lgs8gl5_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct lgs8gl5_config *config;\n\tstruct dvb_frontend frontend;\n};\n\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_DEBUG \"lgs8gl5: \" args); \\\n\t} while (0)\n\n\n \nstatic int\nlgs8gl5_write_reg(struct lgs8gl5_state *state, u8 reg, u8 data)\n{\n\tint ret;\n\tu8 buf[] = {reg, data};\n\tstruct i2c_msg msg = {\n\t\t.addr  = state->config->demod_address,\n\t\t.flags = 0,\n\t\t.buf   = buf,\n\t\t.len   = 2\n\t};\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\tif (ret != 1)\n\t\tdprintk(\"%s: error (reg=0x%02x, val=0x%02x, ret=%i)\\n\",\n\t\t\t__func__, reg, data, ret);\n\treturn (ret != 1) ? -1 : 0;\n}\n\n\n \nstatic int\nlgs8gl5_read_reg(struct lgs8gl5_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = {reg};\n\tu8 b1[] = {0};\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr  = state->config->demod_address,\n\t\t\t.flags = 0,\n\t\t\t.buf   = b0,\n\t\t\t.len   = 1\n\t\t},\n\t\t{\n\t\t\t.addr  = state->config->demod_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf   = b1,\n\t\t\t.len   = 1\n\t\t}\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\tif (ret != 2)\n\t\treturn -EIO;\n\n\treturn b1[0];\n}\n\n\nstatic int\nlgs8gl5_update_reg(struct lgs8gl5_state *state, u8 reg, u8 data)\n{\n\tlgs8gl5_read_reg(state, reg);\n\tlgs8gl5_write_reg(state, reg, data);\n\treturn 0;\n}\n\n\n \n \nstatic int\nlgs8gl5_update_alt_reg(struct lgs8gl5_state *state, u8 reg, u8 data)\n{\n\tint ret;\n\tu8 b0[] = {reg};\n\tu8 b1[] = {0};\n\tu8 b2[] = {reg, data};\n\tstruct i2c_msg msg[3] = {\n\t\t{\n\t\t\t.addr  = state->config->demod_address + 2,\n\t\t\t.flags = 0,\n\t\t\t.buf   = b0,\n\t\t\t.len   = 1\n\t\t},\n\t\t{\n\t\t\t.addr  = state->config->demod_address + 2,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf   = b1,\n\t\t\t.len   = 1\n\t\t},\n\t\t{\n\t\t\t.addr  = state->config->demod_address + 2,\n\t\t\t.flags = 0,\n\t\t\t.buf   = b2,\n\t\t\t.len   = 2\n\t\t},\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 3);\n\treturn (ret != 3) ? -1 : 0;\n}\n\n\nstatic void\nlgs8gl5_soft_reset(struct lgs8gl5_state *state)\n{\n\tu8 val;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tval = lgs8gl5_read_reg(state, REG_RESET);\n\tlgs8gl5_write_reg(state, REG_RESET, val & ~REG_RESET_OFF);\n\tlgs8gl5_write_reg(state, REG_RESET, val | REG_RESET_OFF);\n\tmsleep(5);\n}\n\n\n \nstatic void\nlgs8gl5_start_demod(struct lgs8gl5_state *state)\n{\n\tu8  val;\n\tint n;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tlgs8gl5_update_alt_reg(state, 0xc2, 0x28);\n\tlgs8gl5_soft_reset(state);\n\tlgs8gl5_update_reg(state, REG_07, 0x10);\n\tlgs8gl5_update_reg(state, REG_07, 0x10);\n\tlgs8gl5_write_reg(state, REG_09, 0x0e);\n\tlgs8gl5_write_reg(state, REG_0A, 0xe5);\n\tlgs8gl5_write_reg(state, REG_0B, 0x35);\n\tlgs8gl5_write_reg(state, REG_0C, 0x30);\n\n\tlgs8gl5_update_reg(state, REG_03, 0x00);\n\tlgs8gl5_update_reg(state, REG_7E, 0x01);\n\tlgs8gl5_update_alt_reg(state, 0xc5, 0x00);\n\tlgs8gl5_update_reg(state, REG_04, 0x02);\n\tlgs8gl5_update_reg(state, REG_37, 0x01);\n\tlgs8gl5_soft_reset(state);\n\n\t \n\tfor (n = 0;  n < 10;  n++) {\n\t\tval = lgs8gl5_read_reg(state, REG_STRENGTH);\n\t\tdprintk(\"Wait for carrier[%d] 0x%02X\\n\", n, val);\n\t\tif (val & REG_STRENGTH_CARRIER)\n\t\t\tbreak;\n\t\tmsleep(4);\n\t}\n\tif (!(val & REG_STRENGTH_CARRIER))\n\t\treturn;\n\n\t \n\tfor (n = 0;  n < 20;  n++) {\n\t\tval = lgs8gl5_read_reg(state, REG_STATUS);\n\t\tdprintk(\"Wait for lock[%d] 0x%02X\\n\", n, val);\n\t\tif (val & REG_STATUS_LOCK)\n\t\t\tbreak;\n\t\tmsleep(12);\n\t}\n\tif (!(val & REG_STATUS_LOCK))\n\t\treturn;\n\n\tlgs8gl5_write_reg(state, REG_7D, lgs8gl5_read_reg(state, REG_A2));\n\tlgs8gl5_soft_reset(state);\n}\n\n\nstatic int\nlgs8gl5_init(struct dvb_frontend *fe)\n{\n\tstruct lgs8gl5_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tlgs8gl5_update_alt_reg(state, 0xc2, 0x28);\n\tlgs8gl5_soft_reset(state);\n\tlgs8gl5_update_reg(state, REG_07, 0x10);\n\tlgs8gl5_update_reg(state, REG_07, 0x10);\n\tlgs8gl5_write_reg(state, REG_09, 0x0e);\n\tlgs8gl5_write_reg(state, REG_0A, 0xe5);\n\tlgs8gl5_write_reg(state, REG_0B, 0x35);\n\tlgs8gl5_write_reg(state, REG_0C, 0x30);\n\n\treturn 0;\n}\n\n\nstatic int\nlgs8gl5_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct lgs8gl5_state *state = fe->demodulator_priv;\n\tu8 level = lgs8gl5_read_reg(state, REG_STRENGTH);\n\tu8 flags = lgs8gl5_read_reg(state, REG_STATUS);\n\n\t*status = 0;\n\n\tif ((level & REG_STRENGTH_MASK) > 0)\n\t\t*status |= FE_HAS_SIGNAL;\n\tif (level & REG_STRENGTH_CARRIER)\n\t\t*status |= FE_HAS_CARRIER;\n\tif (flags & REG_STATUS_SYNC)\n\t\t*status |= FE_HAS_SYNC;\n\tif (flags & REG_STATUS_LOCK)\n\t\t*status |= FE_HAS_LOCK;\n\n\treturn 0;\n}\n\n\nstatic int\nlgs8gl5_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\t*ber = 0;\n\n\treturn 0;\n}\n\n\nstatic int\nlgs8gl5_read_signal_strength(struct dvb_frontend *fe, u16 *signal_strength)\n{\n\tstruct lgs8gl5_state *state = fe->demodulator_priv;\n\tu8 level = lgs8gl5_read_reg(state, REG_STRENGTH);\n\t*signal_strength = (level & REG_STRENGTH_MASK) << 8;\n\n\treturn 0;\n}\n\n\nstatic int\nlgs8gl5_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct lgs8gl5_state *state = fe->demodulator_priv;\n\tu8 level = lgs8gl5_read_reg(state, REG_STRENGTH);\n\t*snr = (level & REG_STRENGTH_MASK) << 8;\n\n\treturn 0;\n}\n\n\nstatic int\nlgs8gl5_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\t*ucblocks = 0;\n\n\treturn 0;\n}\n\n\nstatic int\nlgs8gl5_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct lgs8gl5_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (p->bandwidth_hz != 8000000)\n\t\treturn -EINVAL;\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t \n\n\tlgs8gl5_start_demod(state);\n\n\treturn 0;\n}\n\n\nstatic int\nlgs8gl5_get_frontend(struct dvb_frontend *fe,\n\t\t     struct dtv_frontend_properties *p)\n{\n\tstruct lgs8gl5_state *state = fe->demodulator_priv;\n\n\tu8 inv = lgs8gl5_read_reg(state, REG_INVERSION);\n\n\tp->inversion = (inv & REG_INVERSION_ON) ? INVERSION_ON : INVERSION_OFF;\n\n\tp->code_rate_HP = FEC_1_2;\n\tp->code_rate_LP = FEC_7_8;\n\tp->guard_interval = GUARD_INTERVAL_1_32;\n\tp->transmission_mode = TRANSMISSION_MODE_2K;\n\tp->modulation = QAM_64;\n\tp->hierarchy = HIERARCHY_NONE;\n\tp->bandwidth_hz = 8000000;\n\n\treturn 0;\n}\n\n\nstatic int\nlgs8gl5_get_tune_settings(struct dvb_frontend *fe,\n\t\tstruct dvb_frontend_tune_settings *fesettings)\n{\n\tfesettings->min_delay_ms = 240;\n\tfesettings->step_size    = 0;\n\tfesettings->max_drift    = 0;\n\treturn 0;\n}\n\n\nstatic void\nlgs8gl5_release(struct dvb_frontend *fe)\n{\n\tstruct lgs8gl5_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\n\nstatic const struct dvb_frontend_ops lgs8gl5_ops;\n\n\nstruct dvb_frontend*\nlgs8gl5_attach(const struct lgs8gl5_config *config, struct i2c_adapter *i2c)\n{\n\tstruct lgs8gl5_state *state = NULL;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tstate = kzalloc(sizeof(struct lgs8gl5_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c    = i2c;\n\n\t \n\tif (lgs8gl5_read_reg(state, REG_RESET) < 0)\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &lgs8gl5_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL(lgs8gl5_attach);\n\n\nstatic const struct dvb_frontend_ops lgs8gl5_ops = {\n\t.delsys = { SYS_DTMB },\n\t.info = {\n\t\t.name\t\t\t= \"Legend Silicon LGS-8GL5 DMB-TH\",\n\t\t.frequency_min_hz\t= 474 * MHz,\n\t\t.frequency_max_hz\t= 858 * MHz,\n\t\t.frequency_stepsize_hz\t=  10 * kHz,\n\t\t.caps = FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_32 |\n\t\t\tFE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_BANDWIDTH_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO |\n\t\t\tFE_CAN_RECOVER\n\t},\n\n\t.release = lgs8gl5_release,\n\n\t.init = lgs8gl5_init,\n\n\t.set_frontend = lgs8gl5_set_frontend,\n\t.get_frontend = lgs8gl5_get_frontend,\n\t.get_tune_settings = lgs8gl5_get_tune_settings,\n\n\t.read_status = lgs8gl5_read_status,\n\t.read_ber = lgs8gl5_read_ber,\n\t.read_signal_strength = lgs8gl5_read_signal_strength,\n\t.read_snr = lgs8gl5_read_snr,\n\t.read_ucblocks = lgs8gl5_read_ucblocks,\n};\n\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"Legend Silicon LGS-8GL5 DMB-TH Demodulator driver\");\nMODULE_AUTHOR(\"Timothy Lee\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}