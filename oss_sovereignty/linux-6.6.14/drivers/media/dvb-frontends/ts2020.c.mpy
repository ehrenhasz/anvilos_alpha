{
  "module_name": "ts2020.c",
  "hash_id": "c9904330674baf61ea6970e1ed8be71fe41df9d374a2eaa20e53dea3780d7cbc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/ts2020.c",
  "human_readable_source": "\n \n\n#include <media/dvb_frontend.h>\n#include \"ts2020.h\"\n#include <linux/regmap.h>\n#include <linux/math64.h>\n\n#define TS2020_XTAL_FREQ   27000  \n#define FREQ_OFFSET_LOW_SYM_RATE 3000\n\nstruct ts2020_priv {\n\tstruct i2c_client *client;\n\tstruct mutex regmap_mutex;\n\tstruct regmap_config regmap_config;\n\tstruct regmap *regmap;\n\tstruct dvb_frontend *fe;\n\tstruct delayed_work stat_work;\n\tint (*get_agc_pwm)(struct dvb_frontend *fe, u8 *_agc_pwm);\n\t \n\tstruct i2c_adapter *i2c;\n\tint i2c_address;\n\tbool loop_through:1;\n\tu8 clk_out:2;\n\tu8 clk_out_div:5;\n\tbool dont_poll:1;\n\tu32 frequency_div;  \n\tu32 frequency_khz;  \n#define TS2020_M88TS2020 0\n#define TS2020_M88TS2022 1\n\tu8 tuner;\n};\n\nstruct ts2020_reg_val {\n\tu8 reg;\n\tu8 val;\n};\n\nstatic void ts2020_stat_work(struct work_struct *work);\n\nstatic void ts2020_release(struct dvb_frontend *fe)\n{\n\tstruct ts2020_priv *priv = fe->tuner_priv;\n\tstruct i2c_client *client = priv->client;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\ti2c_unregister_device(client);\n}\n\nstatic int ts2020_sleep(struct dvb_frontend *fe)\n{\n\tstruct ts2020_priv *priv = fe->tuner_priv;\n\tint ret;\n\tu8 u8tmp;\n\n\tif (priv->tuner == TS2020_M88TS2020)\n\t\tu8tmp = 0x0a;  \n\telse\n\t\tu8tmp = 0x00;\n\n\tret = regmap_write(priv->regmap, u8tmp, 0x00);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!priv->dont_poll)\n\t\tcancel_delayed_work_sync(&priv->stat_work);\n\treturn 0;\n}\n\nstatic int ts2020_init(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct ts2020_priv *priv = fe->tuner_priv;\n\tint i;\n\tu8 u8tmp;\n\n\tif (priv->tuner == TS2020_M88TS2020) {\n\t\tregmap_write(priv->regmap, 0x42, 0x73);\n\t\tregmap_write(priv->regmap, 0x05, priv->clk_out_div);\n\t\tregmap_write(priv->regmap, 0x20, 0x27);\n\t\tregmap_write(priv->regmap, 0x07, 0x02);\n\t\tregmap_write(priv->regmap, 0x11, 0xff);\n\t\tregmap_write(priv->regmap, 0x60, 0xf9);\n\t\tregmap_write(priv->regmap, 0x08, 0x01);\n\t\tregmap_write(priv->regmap, 0x00, 0x41);\n\t} else {\n\t\tstatic const struct ts2020_reg_val reg_vals[] = {\n\t\t\t{0x7d, 0x9d},\n\t\t\t{0x7c, 0x9a},\n\t\t\t{0x7a, 0x76},\n\t\t\t{0x3b, 0x01},\n\t\t\t{0x63, 0x88},\n\t\t\t{0x61, 0x85},\n\t\t\t{0x22, 0x30},\n\t\t\t{0x30, 0x40},\n\t\t\t{0x20, 0x23},\n\t\t\t{0x24, 0x02},\n\t\t\t{0x12, 0xa0},\n\t\t};\n\n\t\tregmap_write(priv->regmap, 0x00, 0x01);\n\t\tregmap_write(priv->regmap, 0x00, 0x03);\n\n\t\tswitch (priv->clk_out) {\n\t\tcase TS2020_CLK_OUT_DISABLED:\n\t\t\tu8tmp = 0x60;\n\t\t\tbreak;\n\t\tcase TS2020_CLK_OUT_ENABLED:\n\t\t\tu8tmp = 0x70;\n\t\t\tregmap_write(priv->regmap, 0x05, priv->clk_out_div);\n\t\t\tbreak;\n\t\tcase TS2020_CLK_OUT_ENABLED_XTALOUT:\n\t\t\tu8tmp = 0x6c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tu8tmp = 0x60;\n\t\t\tbreak;\n\t\t}\n\n\t\tregmap_write(priv->regmap, 0x42, u8tmp);\n\n\t\tif (priv->loop_through)\n\t\t\tu8tmp = 0xec;\n\t\telse\n\t\t\tu8tmp = 0x6c;\n\n\t\tregmap_write(priv->regmap, 0x62, u8tmp);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(reg_vals); i++)\n\t\t\tregmap_write(priv->regmap, reg_vals[i].reg,\n\t\t\t\t     reg_vals[i].val);\n\t}\n\n\t \n\tc->strength.len = 1;\n\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\tc->strength.stat[0].uvalue = 0;\n\n\t \n\tts2020_stat_work(&priv->stat_work.work);\n\treturn 0;\n}\n\nstatic int ts2020_tuner_gate_ctrl(struct dvb_frontend *fe, u8 offset)\n{\n\tstruct ts2020_priv *priv = fe->tuner_priv;\n\tint ret;\n\tret = regmap_write(priv->regmap, 0x51, 0x1f - offset);\n\tret |= regmap_write(priv->regmap, 0x51, 0x1f);\n\tret |= regmap_write(priv->regmap, 0x50, offset);\n\tret |= regmap_write(priv->regmap, 0x50, 0x00);\n\tmsleep(20);\n\treturn ret;\n}\n\nstatic int ts2020_set_tuner_rf(struct dvb_frontend *fe)\n{\n\tstruct ts2020_priv *dev = fe->tuner_priv;\n\tint ret;\n\tunsigned int utmp;\n\n\tret = regmap_read(dev->regmap, 0x3d, &utmp);\n\tif (ret)\n\t\treturn ret;\n\n\tutmp &= 0x7f;\n\tif (utmp < 0x16)\n\t\tutmp = 0xa1;\n\telse if (utmp == 0x16)\n\t\tutmp = 0x99;\n\telse\n\t\tutmp = 0xf9;\n\n\tregmap_write(dev->regmap, 0x60, utmp);\n\tret = ts2020_tuner_gate_ctrl(fe, 0x08);\n\n\treturn ret;\n}\n\nstatic int ts2020_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct ts2020_priv *priv = fe->tuner_priv;\n\tint ret;\n\tunsigned int utmp;\n\tu32 f3db, gdiv28;\n\tu16 u16tmp, value, lpf_coeff;\n\tu8 buf[3], reg10, lpf_mxdiv, mlpf_max, mlpf_min, nlpf;\n\tunsigned int f_ref_khz, f_vco_khz, div_ref, div_out, pll_n;\n\tunsigned int frequency_khz = c->frequency;\n\n\t \n\tf_ref_khz = TS2020_XTAL_FREQ;\n\tdiv_ref = DIV_ROUND_CLOSEST(f_ref_khz, 2000);\n\n\t \n\tif (frequency_khz < priv->frequency_div) {\n\t\tdiv_out = 4;\n\t\treg10 = 0x10;\n\t} else {\n\t\tdiv_out = 2;\n\t\treg10 = 0x00;\n\t}\n\n\tf_vco_khz = frequency_khz * div_out;\n\tpll_n = f_vco_khz * div_ref / f_ref_khz;\n\tpll_n += pll_n % 2;\n\tpriv->frequency_khz = pll_n * f_ref_khz / div_ref / div_out;\n\n\tpr_debug(\"frequency=%u offset=%d f_vco_khz=%u pll_n=%u div_ref=%u div_out=%u\\n\",\n\t\t priv->frequency_khz, priv->frequency_khz - c->frequency,\n\t\t f_vco_khz, pll_n, div_ref, div_out);\n\n\tif (priv->tuner == TS2020_M88TS2020) {\n\t\tlpf_coeff = 2766;\n\t\treg10 |= 0x01;\n\t\tret = regmap_write(priv->regmap, 0x10, reg10);\n\t} else {\n\t\tlpf_coeff = 3200;\n\t\treg10 |= 0x0b;\n\t\tret = regmap_write(priv->regmap, 0x10, reg10);\n\t\tret |= regmap_write(priv->regmap, 0x11, 0x40);\n\t}\n\n\tu16tmp = pll_n - 1024;\n\tbuf[0] = (u16tmp >> 8) & 0xff;\n\tbuf[1] = (u16tmp >> 0) & 0xff;\n\tbuf[2] = div_ref - 8;\n\n\tret |= regmap_write(priv->regmap, 0x01, buf[0]);\n\tret |= regmap_write(priv->regmap, 0x02, buf[1]);\n\tret |= regmap_write(priv->regmap, 0x03, buf[2]);\n\n\tret |= ts2020_tuner_gate_ctrl(fe, 0x10);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tret |= ts2020_tuner_gate_ctrl(fe, 0x08);\n\n\t \n\tif (priv->tuner == TS2020_M88TS2020)\n\t\tret |= ts2020_set_tuner_rf(fe);\n\n\tgdiv28 = (TS2020_XTAL_FREQ / 1000 * 1694 + 500) / 1000;\n\tret |= regmap_write(priv->regmap, 0x04, gdiv28 & 0xff);\n\tret |= ts2020_tuner_gate_ctrl(fe, 0x04);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tif (priv->tuner == TS2020_M88TS2022) {\n\t\tret = regmap_write(priv->regmap, 0x25, 0x00);\n\t\tret |= regmap_write(priv->regmap, 0x27, 0x70);\n\t\tret |= regmap_write(priv->regmap, 0x41, 0x09);\n\t\tret |= regmap_write(priv->regmap, 0x08, 0x0b);\n\t\tif (ret < 0)\n\t\t\treturn -ENODEV;\n\t}\n\n\tregmap_read(priv->regmap, 0x26, &utmp);\n\tvalue = utmp;\n\n\tf3db = (c->bandwidth_hz / 1000 / 2) + 2000;\n\tf3db += FREQ_OFFSET_LOW_SYM_RATE;  \n\tf3db = clamp(f3db, 7000U, 40000U);\n\n\tgdiv28 = gdiv28 * 207 / (value * 2 + 151);\n\tmlpf_max = gdiv28 * 135 / 100;\n\tmlpf_min = gdiv28 * 78 / 100;\n\tif (mlpf_max > 63)\n\t\tmlpf_max = 63;\n\n\tnlpf = (f3db * gdiv28 * 2 / lpf_coeff /\n\t\t(TS2020_XTAL_FREQ / 1000)  + 1) / 2;\n\tif (nlpf > 23)\n\t\tnlpf = 23;\n\tif (nlpf < 1)\n\t\tnlpf = 1;\n\n\tlpf_mxdiv = (nlpf * (TS2020_XTAL_FREQ / 1000)\n\t\t* lpf_coeff * 2  / f3db + 1) / 2;\n\n\tif (lpf_mxdiv < mlpf_min) {\n\t\tnlpf++;\n\t\tlpf_mxdiv = (nlpf * (TS2020_XTAL_FREQ / 1000)\n\t\t\t* lpf_coeff * 2  / f3db + 1) / 2;\n\t}\n\n\tif (lpf_mxdiv > mlpf_max)\n\t\tlpf_mxdiv = mlpf_max;\n\n\tret = regmap_write(priv->regmap, 0x04, lpf_mxdiv);\n\tret |= regmap_write(priv->regmap, 0x06, nlpf);\n\n\tret |= ts2020_tuner_gate_ctrl(fe, 0x04);\n\n\tret |= ts2020_tuner_gate_ctrl(fe, 0x01);\n\n\tmsleep(80);\n\n\treturn (ret < 0) ? -EINVAL : 0;\n}\n\nstatic int ts2020_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct ts2020_priv *priv = fe->tuner_priv;\n\n\t*frequency = priv->frequency_khz;\n\treturn 0;\n}\n\nstatic int ts2020_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\t*frequency = 0;  \n\treturn 0;\n}\n\n \nstatic int ts2020_read_tuner_gain(struct dvb_frontend *fe, unsigned v_agc,\n\t\t\t\t  __s64 *_gain)\n{\n\tstruct ts2020_priv *priv = fe->tuner_priv;\n\tunsigned long gain1, gain2, gain3;\n\tunsigned utmp;\n\tint ret;\n\n\t \n\tret = regmap_read(priv->regmap, 0x3d, &utmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tgain1 = utmp & 0x1f;\n\n\t \n\tret = regmap_read(priv->regmap, 0x21, &utmp);\n\tif (ret < 0)\n\t\treturn ret;\n\tgain2 = utmp & 0x1f;\n\n\tswitch (priv->tuner) {\n\tcase TS2020_M88TS2020:\n\t\tgain1 = clamp_t(long, gain1, 0, 15);\n\t\tgain2 = clamp_t(long, gain2, 0, 13);\n\t\tv_agc = clamp_t(long, v_agc, 400, 1100);\n\n\t\t*_gain = -((__s64)gain1 * 2330 +\n\t\t\t   gain2 * 3500 +\n\t\t\t   v_agc * 24 / 10 * 10 +\n\t\t\t   10000);\n\t\t \n\t\tbreak;\n\n\tcase TS2020_M88TS2022:\n\t\tret = regmap_read(priv->regmap, 0x66, &utmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgain3 = (utmp >> 3) & 0x07;\n\n\t\tgain1 = clamp_t(long, gain1, 0, 15);\n\t\tgain2 = clamp_t(long, gain2, 2, 16);\n\t\tgain3 = clamp_t(long, gain3, 0, 6);\n\t\tv_agc = clamp_t(long, v_agc, 600, 1600);\n\n\t\t*_gain = -((__s64)gain1 * 2650 +\n\t\t\t   gain2 * 3380 +\n\t\t\t   gain3 * 2850 +\n\t\t\t   v_agc * 176 / 100 * 10 -\n\t\t\t   30000);\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ts2020_get_tuner_gain(struct dvb_frontend *fe, __s64 *_gain)\n{\n\tstruct ts2020_priv *priv = fe->tuner_priv;\n\tint v_agc = 0, ret;\n\tu8 agc_pwm;\n\n\t \n\tif (priv->get_agc_pwm) {\n\t\tret = priv->get_agc_pwm(fe, &agc_pwm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tswitch (priv->tuner) {\n\t\tcase TS2020_M88TS2020:\n\t\t\tv_agc = (int)agc_pwm * 20 - 1166;\n\t\t\tbreak;\n\t\tcase TS2020_M88TS2022:\n\t\t\tv_agc = (int)agc_pwm * 16 - 670;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (v_agc < 0)\n\t\t\tv_agc = 0;\n\t}\n\n\treturn ts2020_read_tuner_gain(fe, v_agc, _gain);\n}\n\n \nstatic void ts2020_stat_work(struct work_struct *work)\n{\n\tstruct ts2020_priv *priv = container_of(work, struct ts2020_priv,\n\t\t\t\t\t       stat_work.work);\n\tstruct i2c_client *client = priv->client;\n\tstruct dtv_frontend_properties *c = &priv->fe->dtv_property_cache;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tret = ts2020_get_tuner_gain(priv->fe, &c->strength.stat[0].svalue);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\n\tif (!priv->dont_poll)\n\t\tschedule_delayed_work(&priv->stat_work, msecs_to_jiffies(2000));\n\treturn;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n}\n\n \nstatic int ts2020_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t       u16 *_signal_strength)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct ts2020_priv *priv = fe->tuner_priv;\n\tunsigned strength;\n\t__s64 gain;\n\n\tif (priv->dont_poll)\n\t\tts2020_stat_work(&priv->stat_work.work);\n\n\tif (c->strength.stat[0].scale == FE_SCALE_NOT_AVAILABLE) {\n\t\t*_signal_strength = 0;\n\t\treturn 0;\n\t}\n\n\tgain = c->strength.stat[0].svalue;\n\n\t \n\tif (gain < -85000)\n\t\t \n\t\tstrength = 0;\n\telse if (gain < -65000)\n\t\t \n\t\tstrength = 0 + div64_s64((85000 + gain) * 3, 1000);\n\telse if (gain < -45000)\n\t\t \n\t\tstrength = 60 + div64_s64((65000 + gain) * 3, 2000);\n\telse\n\t\t \n\t\tstrength = 90 + div64_s64((45000 + gain), 5000);\n\n\t*_signal_strength = strength * 65535 / 100;\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops ts2020_tuner_ops = {\n\t.info = {\n\t\t.name = \"TS2020\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz\n\t},\n\t.init = ts2020_init,\n\t.release = ts2020_release,\n\t.sleep = ts2020_sleep,\n\t.set_params = ts2020_set_params,\n\t.get_frequency = ts2020_get_frequency,\n\t.get_if_frequency = ts2020_get_if_frequency,\n\t.get_rf_strength = ts2020_read_signal_strength,\n};\n\nstruct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,\n\t\t\t\t\tconst struct ts2020_config *config,\n\t\t\t\t\tstruct i2c_adapter *i2c)\n{\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\n\t \n\tstruct ts2020_config pdata;\n\n\tmemcpy(&pdata, config, sizeof(pdata));\n\tpdata.fe = fe;\n\tpdata.attach_in_use = true;\n\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrscpy(board_info.type, \"ts2020\", I2C_NAME_SIZE);\n\tboard_info.addr = config->tuner_address;\n\tboard_info.platform_data = &pdata;\n\tclient = i2c_new_client_device(i2c, &board_info);\n\tif (!i2c_client_has_driver(client))\n\t\treturn NULL;\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(ts2020_attach);\n\n \nstatic void ts2020_regmap_lock(void *__dev)\n{\n\tstruct ts2020_priv *dev = __dev;\n\n\tmutex_lock(&dev->regmap_mutex);\n\tif (dev->fe->ops.i2c_gate_ctrl)\n\t\tdev->fe->ops.i2c_gate_ctrl(dev->fe, 1);\n}\n\nstatic void ts2020_regmap_unlock(void *__dev)\n{\n\tstruct ts2020_priv *dev = __dev;\n\n\tif (dev->fe->ops.i2c_gate_ctrl)\n\t\tdev->fe->ops.i2c_gate_ctrl(dev->fe, 0);\n\tmutex_unlock(&dev->regmap_mutex);\n}\n\nstatic int ts2020_probe(struct i2c_client *client)\n{\n\tstruct ts2020_config *pdata = client->dev.platform_data;\n\tstruct dvb_frontend *fe = pdata->fe;\n\tstruct ts2020_priv *dev;\n\tint ret;\n\tu8 u8tmp;\n\tunsigned int utmp;\n\tchar *chip_str;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tmutex_init(&dev->regmap_mutex);\n\tdev->regmap_config.reg_bits = 8;\n\tdev->regmap_config.val_bits = 8;\n\tdev->regmap_config.lock = ts2020_regmap_lock;\n\tdev->regmap_config.unlock = ts2020_regmap_unlock;\n\tdev->regmap_config.lock_arg = dev;\n\tdev->regmap = regmap_init_i2c(client, &dev->regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err_kfree;\n\t}\n\n\tdev->i2c = client->adapter;\n\tdev->i2c_address = client->addr;\n\tdev->loop_through = pdata->loop_through;\n\tdev->clk_out = pdata->clk_out;\n\tdev->clk_out_div = pdata->clk_out_div;\n\tdev->dont_poll = pdata->dont_poll;\n\tdev->frequency_div = pdata->frequency_div;\n\tdev->fe = fe;\n\tdev->get_agc_pwm = pdata->get_agc_pwm;\n\tfe->tuner_priv = dev;\n\tdev->client = client;\n\tINIT_DELAYED_WORK(&dev->stat_work, ts2020_stat_work);\n\n\t \n\tret = regmap_read(dev->regmap, 0x00, &utmp);\n\tif (ret)\n\t\tgoto err_regmap_exit;\n\n\tif ((utmp & 0x03) == 0x00) {\n\t\tret = regmap_write(dev->regmap, 0x00, 0x01);\n\t\tif (ret)\n\t\t\tgoto err_regmap_exit;\n\n\t\tusleep_range(2000, 50000);\n\t}\n\n\tret = regmap_write(dev->regmap, 0x00, 0x03);\n\tif (ret)\n\t\tgoto err_regmap_exit;\n\n\tusleep_range(2000, 50000);\n\n\tret = regmap_read(dev->regmap, 0x00, &utmp);\n\tif (ret)\n\t\tgoto err_regmap_exit;\n\n\tdev_dbg(&client->dev, \"chip_id=%02x\\n\", utmp);\n\n\tswitch (utmp) {\n\tcase 0x01:\n\tcase 0x41:\n\tcase 0x81:\n\t\tdev->tuner = TS2020_M88TS2020;\n\t\tchip_str = \"TS2020\";\n\t\tif (!dev->frequency_div)\n\t\t\tdev->frequency_div = 1060000;\n\t\tbreak;\n\tcase 0xc3:\n\tcase 0x83:\n\t\tdev->tuner = TS2020_M88TS2022;\n\t\tchip_str = \"TS2022\";\n\t\tif (!dev->frequency_div)\n\t\t\tdev->frequency_div = 1103000;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t\tgoto err_regmap_exit;\n\t}\n\n\tif (dev->tuner == TS2020_M88TS2022) {\n\t\tswitch (dev->clk_out) {\n\t\tcase TS2020_CLK_OUT_DISABLED:\n\t\t\tu8tmp = 0x60;\n\t\t\tbreak;\n\t\tcase TS2020_CLK_OUT_ENABLED:\n\t\t\tu8tmp = 0x70;\n\t\t\tret = regmap_write(dev->regmap, 0x05, dev->clk_out_div);\n\t\t\tif (ret)\n\t\t\t\tgoto err_regmap_exit;\n\t\t\tbreak;\n\t\tcase TS2020_CLK_OUT_ENABLED_XTALOUT:\n\t\t\tu8tmp = 0x6c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_regmap_exit;\n\t\t}\n\n\t\tret = regmap_write(dev->regmap, 0x42, u8tmp);\n\t\tif (ret)\n\t\t\tgoto err_regmap_exit;\n\n\t\tif (dev->loop_through)\n\t\t\tu8tmp = 0xec;\n\t\telse\n\t\t\tu8tmp = 0x6c;\n\n\t\tret = regmap_write(dev->regmap, 0x62, u8tmp);\n\t\tif (ret)\n\t\t\tgoto err_regmap_exit;\n\t}\n\n\t \n\tret = regmap_write(dev->regmap, 0x00, 0x00);\n\tif (ret)\n\t\tgoto err_regmap_exit;\n\n\tdev_info(&client->dev,\n\t\t \"Montage Technology %s successfully identified\\n\", chip_str);\n\n\tmemcpy(&fe->ops.tuner_ops, &ts2020_tuner_ops,\n\t\t\tsizeof(struct dvb_tuner_ops));\n\tif (!pdata->attach_in_use)\n\t\tfe->ops.tuner_ops.release = NULL;\n\n\ti2c_set_clientdata(client, dev);\n\treturn 0;\nerr_regmap_exit:\n\tregmap_exit(dev->regmap);\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void ts2020_remove(struct i2c_client *client)\n{\n\tstruct ts2020_priv *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tif (!dev->dont_poll)\n\t\tcancel_delayed_work_sync(&dev->stat_work);\n\n\tregmap_exit(dev->regmap);\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id ts2020_id_table[] = {\n\t{\"ts2020\", 0},\n\t{\"ts2022\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ts2020_id_table);\n\nstatic struct i2c_driver ts2020_driver = {\n\t.driver = {\n\t\t.name\t= \"ts2020\",\n\t},\n\t.probe\t\t= ts2020_probe,\n\t.remove\t\t= ts2020_remove,\n\t.id_table\t= ts2020_id_table,\n};\n\nmodule_i2c_driver(ts2020_driver);\n\nMODULE_AUTHOR(\"Konstantin Dimitrov <kosio.dimitrov@gmail.com>\");\nMODULE_DESCRIPTION(\"Montage Technology TS2020 - Silicon tuner driver module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}