{
  "module_name": "lg2160.c",
  "hash_id": "cc20ded78f063bdb21c2ec03bbd9e19ce433436a80bc879912139939942fa397",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/lg2160.c",
  "human_readable_source": "\n \n\n#include <linux/jiffies.h>\n#include <linux/dvb/frontend.h>\n#include \"lg2160.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debug level (info=1, reg=2 (or-able))\");\n\n#define DBG_INFO 1\n#define DBG_REG  2\n\n#define lg_printk(kern, fmt, arg...)\t\t\t\t\t\\\n\tprintk(kern \"%s: \" fmt, __func__, ##arg)\n\n#define lg_info(fmt, arg...)\tprintk(KERN_INFO \"lg2160: \" fmt, ##arg)\n#define lg_warn(fmt, arg...)\tlg_printk(KERN_WARNING,       fmt, ##arg)\n#define lg_err(fmt, arg...)\tlg_printk(KERN_ERR,           fmt, ##arg)\n#define lg_dbg(fmt, arg...) if (debug & DBG_INFO)\t\t\t\\\n\t\t\t\tlg_printk(KERN_DEBUG,         fmt, ##arg)\n#define lg_reg(fmt, arg...) if (debug & DBG_REG)\t\t\t\\\n\t\t\t\tlg_printk(KERN_DEBUG,         fmt, ##arg)\n\n#define lg_fail(ret)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __ret;\t\t\t\t\t\t\t\\\n\t__ret = (ret < 0);\t\t\t\t\t\t\\\n\tif (__ret)\t\t\t\t\t\t\t\\\n\t\tlg_err(\"error %d on line %d\\n\",\tret, __LINE__);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\nstruct lg216x_state {\n\tstruct i2c_adapter *i2c_adap;\n\tconst struct lg2160_config *cfg;\n\n\tstruct dvb_frontend frontend;\n\n\tu32 current_frequency;\n\tu8 parade_id;\n\tu8 fic_ver;\n\tunsigned int last_reset;\n};\n\n \n\nstatic int lg216x_write_reg(struct lg216x_state *state, u16 reg, u8 val)\n{\n\tint ret;\n\tu8 buf[] = { reg >> 8, reg & 0xff, val };\n\tstruct i2c_msg msg = {\n\t\t.addr = state->cfg->i2c_addr, .flags = 0,\n\t\t.buf = buf, .len = 3,\n\t};\n\n\tlg_reg(\"reg: 0x%04x, val: 0x%02x\\n\", reg, val);\n\n\tret = i2c_transfer(state->i2c_adap, &msg, 1);\n\n\tif (ret != 1) {\n\t\tlg_err(\"error (addr %02x %02x <- %02x, err = %i)\\n\",\n\t\t       msg.buf[0], msg.buf[1], msg.buf[2], ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int lg216x_read_reg(struct lg216x_state *state, u16 reg, u8 *val)\n{\n\tint ret;\n\tu8 reg_buf[] = { reg >> 8, reg & 0xff };\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->cfg->i2c_addr,\n\t\t  .flags = 0, .buf = reg_buf, .len = 2 },\n\t\t{ .addr = state->cfg->i2c_addr,\n\t\t  .flags = I2C_M_RD, .buf = val, .len = 1 },\n\t};\n\n\tlg_reg(\"reg: 0x%04x\\n\", reg);\n\n\tret = i2c_transfer(state->i2c_adap, msg, 2);\n\n\tif (ret != 2) {\n\t\tlg_err(\"error (addr %02x reg %04x error (ret == %i)\\n\",\n\t\t       state->cfg->i2c_addr, reg, ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstruct lg216x_reg {\n\tu16 reg;\n\tu8 val;\n};\n\nstatic int lg216x_write_regs(struct lg216x_state *state,\n\t\t\t     struct lg216x_reg *regs, int len)\n{\n\tint i, ret;\n\n\tlg_reg(\"writing %d registers...\\n\", len);\n\n\tfor (i = 0; i < len; i++) {\n\t\tret = lg216x_write_reg(state, regs[i].reg, regs[i].val);\n\t\tif (lg_fail(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int lg216x_set_reg_bit(struct lg216x_state *state,\n\t\t\t      u16 reg, int bit, int onoff)\n{\n\tu8 val;\n\tint ret;\n\n\tlg_reg(\"reg: 0x%04x, bit: %d, level: %d\\n\", reg, bit, onoff);\n\n\tret = lg216x_read_reg(state, reg, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= ~(1 << bit);\n\tval |= (onoff & 1) << bit;\n\n\tret = lg216x_write_reg(state, reg, val);\n\tlg_fail(ret);\nfail:\n\treturn ret;\n}\n\n \n\nstatic int lg216x_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct lg216x_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tif (state->cfg->deny_i2c_rptr)\n\t\treturn 0;\n\n\tlg_dbg(\"(%d)\\n\", enable);\n\n\tret = lg216x_set_reg_bit(state, 0x0000, 0, enable ? 0 : 1);\n\n\tmsleep(1);\n\n\treturn ret;\n}\n\nstatic int lg216x_soft_reset(struct lg216x_state *state)\n{\n\tint ret;\n\n\tlg_dbg(\"\\n\");\n\n\tret = lg216x_write_reg(state, 0x0002, 0x00);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tmsleep(20);\n\tret = lg216x_write_reg(state, 0x0002, 0x01);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tstate->last_reset = jiffies_to_msecs(jiffies);\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_initialize(struct lg216x_state *state)\n{\n\tint ret;\n\n\tstatic struct lg216x_reg lg2160_init[] = {\n#if 0\n\t\t{ .reg = 0x0015, .val = 0xe6 },\n#else\n\t\t{ .reg = 0x0015, .val = 0xf7 },\n\t\t{ .reg = 0x001b, .val = 0x52 },\n\t\t{ .reg = 0x0208, .val = 0x00 },\n\t\t{ .reg = 0x0209, .val = 0x82 },\n\t\t{ .reg = 0x0210, .val = 0xf9 },\n\t\t{ .reg = 0x020a, .val = 0x00 },\n\t\t{ .reg = 0x020b, .val = 0x82 },\n\t\t{ .reg = 0x020d, .val = 0x28 },\n\t\t{ .reg = 0x020f, .val = 0x14 },\n#endif\n\t};\n\n\tstatic struct lg216x_reg lg2161_init[] = {\n\t\t{ .reg = 0x0000, .val = 0x41 },\n\t\t{ .reg = 0x0001, .val = 0xfb },\n\t\t{ .reg = 0x0216, .val = 0x00 },\n\t\t{ .reg = 0x0219, .val = 0x00 },\n\t\t{ .reg = 0x021b, .val = 0x55 },\n\t\t{ .reg = 0x0606, .val = 0x0a },\n\t};\n\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tret = lg216x_write_regs(state,\n\t\t\t\t\tlg2160_init, ARRAY_SIZE(lg2160_init));\n\t\tbreak;\n\tcase LG2161:\n\t\tret = lg216x_write_regs(state,\n\t\t\t\t\tlg2161_init, ARRAY_SIZE(lg2161_init));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lg216x_soft_reset(state);\n\tlg_fail(ret);\nfail:\n\treturn ret;\n}\n\n \n\nstatic int lg216x_set_if(struct lg216x_state *state)\n{\n\tu8 val;\n\tint ret;\n\n\tlg_dbg(\"%d KHz\\n\", state->cfg->if_khz);\n\n\tret = lg216x_read_reg(state, 0x0132, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= 0xfb;\n\tval |= (0 == state->cfg->if_khz) ? 0x04 : 0x00;\n\n\tret = lg216x_write_reg(state, 0x0132, val);\n\tlg_fail(ret);\n\n\t \nfail:\n\treturn ret;\n}\n\n \n\nstatic int lg2160_agc_fix(struct lg216x_state *state,\n\t\t\t  int if_agc_fix, int rf_agc_fix)\n{\n\tu8 val;\n\tint ret;\n\n\tret = lg216x_read_reg(state, 0x0100, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= 0xf3;\n\tval |= (if_agc_fix) ? 0x08 : 0x00;\n\tval |= (rf_agc_fix) ? 0x04 : 0x00;\n\n\tret = lg216x_write_reg(state, 0x0100, val);\n\tlg_fail(ret);\nfail:\n\treturn ret;\n}\n\n#if 0\nstatic int lg2160_agc_freeze(struct lg216x_state *state,\n\t\t\t     int if_agc_freeze, int rf_agc_freeze)\n{\n\tu8 val;\n\tint ret;\n\n\tret = lg216x_read_reg(state, 0x0100, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= 0xcf;\n\tval |= (if_agc_freeze) ? 0x20 : 0x00;\n\tval |= (rf_agc_freeze) ? 0x10 : 0x00;\n\n\tret = lg216x_write_reg(state, 0x0100, val);\n\tlg_fail(ret);\nfail:\n\treturn ret;\n}\n#endif\n\nstatic int lg2160_agc_polarity(struct lg216x_state *state,\n\t\t\t       int if_agc_polarity, int rf_agc_polarity)\n{\n\tu8 val;\n\tint ret;\n\n\tret = lg216x_read_reg(state, 0x0100, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= 0xfc;\n\tval |= (if_agc_polarity) ? 0x02 : 0x00;\n\tval |= (rf_agc_polarity) ? 0x01 : 0x00;\n\n\tret = lg216x_write_reg(state, 0x0100, val);\n\tlg_fail(ret);\nfail:\n\treturn ret;\n}\n\nstatic int lg2160_tuner_pwr_save_polarity(struct lg216x_state *state,\n\t\t\t\t\t  int polarity)\n{\n\tu8 val;\n\tint ret;\n\n\tret = lg216x_read_reg(state, 0x0008, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= 0xfe;\n\tval |= (polarity) ? 0x01 : 0x00;\n\n\tret = lg216x_write_reg(state, 0x0008, val);\n\tlg_fail(ret);\nfail:\n\treturn ret;\n}\n\nstatic int lg2160_spectrum_polarity(struct lg216x_state *state,\n\t\t\t\t    int inverted)\n{\n\tu8 val;\n\tint ret;\n\n\tret = lg216x_read_reg(state, 0x0132, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= 0xfd;\n\tval |= (inverted) ? 0x02 : 0x00;\n\n\tret = lg216x_write_reg(state, 0x0132, val);\n\tlg_fail(ret);\nfail:\n\treturn lg216x_soft_reset(state);\n}\n\nstatic int lg2160_tuner_pwr_save(struct lg216x_state *state, int onoff)\n{\n\tu8 val;\n\tint ret;\n\n\tret = lg216x_read_reg(state, 0x0007, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= 0xbf;\n\tval |= (onoff) ? 0x40 : 0x00;\n\n\tret = lg216x_write_reg(state, 0x0007, val);\n\tlg_fail(ret);\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_set_parade(struct lg216x_state *state, int id)\n{\n\tint ret;\n\n\tret = lg216x_write_reg(state, 0x013e, id & 0x7f);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tstate->parade_id = id & 0x7f;\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_set_ensemble(struct lg216x_state *state, int id)\n{\n\tint ret;\n\tu16 reg;\n\tu8 val;\n\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\treg = 0x0400;\n\t\tbreak;\n\tcase LG2161:\n\tdefault:\n\t\treg = 0x0500;\n\t\tbreak;\n\t}\n\n\tret = lg216x_read_reg(state, reg, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= 0xfe;\n\tval |= (id) ? 0x01 : 0x00;\n\n\tret = lg216x_write_reg(state, reg, val);\n\tlg_fail(ret);\nfail:\n\treturn ret;\n}\n\nstatic int lg2160_set_spi_clock(struct lg216x_state *state)\n{\n\tu8 val;\n\tint ret;\n\n\tret = lg216x_read_reg(state, 0x0014, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= 0xf3;\n\tval |= (state->cfg->spi_clock << 2);\n\n\tret = lg216x_write_reg(state, 0x0014, val);\n\tlg_fail(ret);\nfail:\n\treturn ret;\n}\n\nstatic int lg2161_set_output_interface(struct lg216x_state *state)\n{\n\tu8 val;\n\tint ret;\n\n\tret = lg216x_read_reg(state, 0x0014, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= ~0x07;\n\tval |= state->cfg->output_if;  \n\n\tret = lg216x_write_reg(state, 0x0014, val);\n\tlg_fail(ret);\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_enable_fic(struct lg216x_state *state, int onoff)\n{\n\tint ret;\n\n\tret = lg216x_write_reg(state, 0x0017, 0x23);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lg216x_write_reg(state, 0x0016, 0xfc);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tret = lg216x_write_reg(state, 0x0016,\n\t\t\t\t       0xfc | ((onoff) ? 0x02 : 0x00));\n\t\tbreak;\n\tcase LG2161:\n\t\tret = lg216x_write_reg(state, 0x0016, (onoff) ? 0x10 : 0x00);\n\t\tbreak;\n\t}\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lg216x_initialize(state);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tif (onoff) {\n\t\tret = lg216x_write_reg(state, 0x0017, 0x03);\n\t\tlg_fail(ret);\n\t}\nfail:\n\treturn ret;\n}\n\n \n\nstatic int lg216x_get_fic_version(struct lg216x_state *state, u8 *ficver)\n{\n\tu8 val;\n\tint ret;\n\n\t*ficver = 0xff;  \n\n\tret = lg216x_read_reg(state, 0x0128, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*ficver = (val >> 3) & 0x1f;\nfail:\n\treturn ret;\n}\n\n#if 0\nstatic int lg2160_get_parade_id(struct lg216x_state *state, u8 *id)\n{\n\tu8 val;\n\tint ret;\n\n\t*id = 0xff;  \n\n\tret = lg216x_read_reg(state, 0x0123, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*id = val & 0x7f;\nfail:\n\treturn ret;\n}\n#endif\n\nstatic int lg216x_get_nog(struct lg216x_state *state, u8 *nog)\n{\n\tu8 val;\n\tint ret;\n\n\t*nog = 0xff;  \n\n\tret = lg216x_read_reg(state, 0x0124, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*nog = ((val >> 4) & 0x07) + 1;\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_get_tnog(struct lg216x_state *state, u8 *tnog)\n{\n\tu8 val;\n\tint ret;\n\n\t*tnog = 0xff;  \n\n\tret = lg216x_read_reg(state, 0x0125, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*tnog = val & 0x1f;\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_get_sgn(struct lg216x_state *state, u8 *sgn)\n{\n\tu8 val;\n\tint ret;\n\n\t*sgn = 0xff;  \n\n\tret = lg216x_read_reg(state, 0x0124, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*sgn = val & 0x0f;\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_get_prc(struct lg216x_state *state, u8 *prc)\n{\n\tu8 val;\n\tint ret;\n\n\t*prc = 0xff;  \n\n\tret = lg216x_read_reg(state, 0x0125, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*prc = ((val >> 5) & 0x07) + 1;\nfail:\n\treturn ret;\n}\n\n \n\nstatic int lg216x_get_rs_frame_mode(struct lg216x_state *state,\n\t\t\t\t    enum atscmh_rs_frame_mode *rs_framemode)\n{\n\tu8 val;\n\tint ret;\n\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tret = lg216x_read_reg(state, 0x0410, &val);\n\t\tbreak;\n\tcase LG2161:\n\t\tret = lg216x_read_reg(state, 0x0513, &val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tswitch ((val >> 4) & 0x03) {\n#if 1\n\tdefault:\n#endif\n\tcase 0x00:\n\t\t*rs_framemode = ATSCMH_RSFRAME_PRI_ONLY;\n\t\tbreak;\n\tcase 0x01:\n\t\t*rs_framemode = ATSCMH_RSFRAME_PRI_SEC;\n\t\tbreak;\n#if 0\n\tdefault:\n\t\t*rs_framemode = ATSCMH_RSFRAME_RES;\n\t\tbreak;\n#endif\n\t}\nfail:\n\treturn ret;\n}\n\nstatic\nint lg216x_get_rs_frame_ensemble(struct lg216x_state *state,\n\t\t\t\t enum atscmh_rs_frame_ensemble *rs_frame_ens)\n{\n\tu8 val;\n\tint ret;\n\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tret = lg216x_read_reg(state, 0x0400, &val);\n\t\tbreak;\n\tcase LG2161:\n\t\tret = lg216x_read_reg(state, 0x0500, &val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= 0x01;\n\t*rs_frame_ens = (enum atscmh_rs_frame_ensemble) val;\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_get_rs_code_mode(struct lg216x_state *state,\n\t\t\t\t   enum atscmh_rs_code_mode *rs_code_pri,\n\t\t\t\t   enum atscmh_rs_code_mode *rs_code_sec)\n{\n\tu8 val;\n\tint ret;\n\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tret = lg216x_read_reg(state, 0x0410, &val);\n\t\tbreak;\n\tcase LG2161:\n\t\tret = lg216x_read_reg(state, 0x0513, &val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*rs_code_pri = (enum atscmh_rs_code_mode) ((val >> 2) & 0x03);\n\t*rs_code_sec = (enum atscmh_rs_code_mode) (val & 0x03);\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_get_sccc_block_mode(struct lg216x_state *state,\n\t\t\t\t      enum atscmh_sccc_block_mode *sccc_block)\n{\n\tu8 val;\n\tint ret;\n\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tret = lg216x_read_reg(state, 0x0315, &val);\n\t\tbreak;\n\tcase LG2161:\n\t\tret = lg216x_read_reg(state, 0x0511, &val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tswitch (val & 0x03) {\n\tcase 0x00:\n\t\t*sccc_block = ATSCMH_SCCC_BLK_SEP;\n\t\tbreak;\n\tcase 0x01:\n\t\t*sccc_block = ATSCMH_SCCC_BLK_COMB;\n\t\tbreak;\n\tdefault:\n\t\t*sccc_block = ATSCMH_SCCC_BLK_RES;\n\t\tbreak;\n\t}\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_get_sccc_code_mode(struct lg216x_state *state,\n\t\t\t\t     enum atscmh_sccc_code_mode *mode_a,\n\t\t\t\t     enum atscmh_sccc_code_mode *mode_b,\n\t\t\t\t     enum atscmh_sccc_code_mode *mode_c,\n\t\t\t\t     enum atscmh_sccc_code_mode *mode_d)\n{\n\tu8 val;\n\tint ret;\n\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tret = lg216x_read_reg(state, 0x0316, &val);\n\t\tbreak;\n\tcase LG2161:\n\t\tret = lg216x_read_reg(state, 0x0512, &val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tswitch ((val >> 6) & 0x03) {\n\tcase 0x00:\n\t\t*mode_a = ATSCMH_SCCC_CODE_HLF;\n\t\tbreak;\n\tcase 0x01:\n\t\t*mode_a = ATSCMH_SCCC_CODE_QTR;\n\t\tbreak;\n\tdefault:\n\t\t*mode_a = ATSCMH_SCCC_CODE_RES;\n\t\tbreak;\n\t}\n\n\tswitch ((val >> 4) & 0x03) {\n\tcase 0x00:\n\t\t*mode_b = ATSCMH_SCCC_CODE_HLF;\n\t\tbreak;\n\tcase 0x01:\n\t\t*mode_b = ATSCMH_SCCC_CODE_QTR;\n\t\tbreak;\n\tdefault:\n\t\t*mode_b = ATSCMH_SCCC_CODE_RES;\n\t\tbreak;\n\t}\n\n\tswitch ((val >> 2) & 0x03) {\n\tcase 0x00:\n\t\t*mode_c = ATSCMH_SCCC_CODE_HLF;\n\t\tbreak;\n\tcase 0x01:\n\t\t*mode_c = ATSCMH_SCCC_CODE_QTR;\n\t\tbreak;\n\tdefault:\n\t\t*mode_c = ATSCMH_SCCC_CODE_RES;\n\t\tbreak;\n\t}\n\n\tswitch (val & 0x03) {\n\tcase 0x00:\n\t\t*mode_d = ATSCMH_SCCC_CODE_HLF;\n\t\tbreak;\n\tcase 0x01:\n\t\t*mode_d = ATSCMH_SCCC_CODE_QTR;\n\t\tbreak;\n\tdefault:\n\t\t*mode_d = ATSCMH_SCCC_CODE_RES;\n\t\tbreak;\n\t}\nfail:\n\treturn ret;\n}\n\n \n\n#if 0\nstatic int lg216x_read_fic_err_count(struct lg216x_state *state, u8 *err)\n{\n\tu8 fic_err;\n\tint ret;\n\n\t*err = 0;\n\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tret = lg216x_read_reg(state, 0x0012, &fic_err);\n\t\tbreak;\n\tcase LG2161:\n\t\tret = lg216x_read_reg(state, 0x001e, &fic_err);\n\t\tbreak;\n\t}\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*err = fic_err;\nfail:\n\treturn ret;\n}\n\nstatic int lg2160_read_crc_err_count(struct lg216x_state *state, u16 *err)\n{\n\tu8 crc_err1, crc_err2;\n\tint ret;\n\n\t*err = 0;\n\n\tret = lg216x_read_reg(state, 0x0411, &crc_err1);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lg216x_read_reg(state, 0x0412, &crc_err2);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*err = (u16)(((crc_err2 & 0x0f) << 8) | crc_err1);\nfail:\n\treturn ret;\n}\n\nstatic int lg2161_read_crc_err_count(struct lg216x_state *state, u16 *err)\n{\n\tu8 crc_err;\n\tint ret;\n\n\t*err = 0;\n\n\tret = lg216x_read_reg(state, 0x0612, &crc_err);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*err = (u16)crc_err;\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_read_crc_err_count(struct lg216x_state *state, u16 *err)\n{\n\tint ret;\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tret = lg2160_read_crc_err_count(state, err);\n\t\tbreak;\n\tcase LG2161:\n\t\tret = lg2161_read_crc_err_count(state, err);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int lg2160_read_rs_err_count(struct lg216x_state *state, u16 *err)\n{\n\tu8 rs_err1, rs_err2;\n\tint ret;\n\n\t*err = 0;\n\n\tret = lg216x_read_reg(state, 0x0413, &rs_err1);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lg216x_read_reg(state, 0x0414, &rs_err2);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*err = (u16)(((rs_err2 & 0x0f) << 8) | rs_err1);\nfail:\n\treturn ret;\n}\n\nstatic int lg2161_read_rs_err_count(struct lg216x_state *state, u16 *err)\n{\n\tu8 rs_err1, rs_err2;\n\tint ret;\n\n\t*err = 0;\n\n\tret = lg216x_read_reg(state, 0x0613, &rs_err1);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lg216x_read_reg(state, 0x0614, &rs_err2);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*err = (u16)((rs_err1 << 8) | rs_err2);\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_read_rs_err_count(struct lg216x_state *state, u16 *err)\n{\n\tint ret;\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tret = lg2160_read_rs_err_count(state, err);\n\t\tbreak;\n\tcase LG2161:\n\t\tret = lg2161_read_rs_err_count(state, err);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n#endif\n\n \n\nstatic int lg216x_get_frontend(struct dvb_frontend *fe,\n\t\t\t       struct dtv_frontend_properties *c)\n{\n\tstruct lg216x_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tlg_dbg(\"\\n\");\n\n\tc->modulation = VSB_8;\n\tc->frequency = state->current_frequency;\n\tc->delivery_system = SYS_ATSCMH;\n\n\tret = lg216x_get_fic_version(state,\n\t\t\t\t     &c->atscmh_fic_ver);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\tif (state->fic_ver != c->atscmh_fic_ver) {\n\t\tstate->fic_ver = c->atscmh_fic_ver;\n\n#if 0\n\t\tret = lg2160_get_parade_id(state,\n\t\t\t\t&c->atscmh_parade_id);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n \n\t\tc->atscmh_parade_id = state->parade_id;\n#endif\n\t\tret = lg216x_get_nog(state,\n\t\t\t\t     &c->atscmh_nog);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tret = lg216x_get_tnog(state,\n\t\t\t\t      &c->atscmh_tnog);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tret = lg216x_get_sgn(state,\n\t\t\t\t     &c->atscmh_sgn);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tret = lg216x_get_prc(state,\n\t\t\t\t     &c->atscmh_prc);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\n\t\tret = lg216x_get_rs_frame_mode(state,\n\t\t\t(enum atscmh_rs_frame_mode *)\n\t\t\t&c->atscmh_rs_frame_mode);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tret = lg216x_get_rs_frame_ensemble(state,\n\t\t\t(enum atscmh_rs_frame_ensemble *)\n\t\t\t&c->atscmh_rs_frame_ensemble);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tret = lg216x_get_rs_code_mode(state,\n\t\t\t(enum atscmh_rs_code_mode *)\n\t\t\t&c->atscmh_rs_code_mode_pri,\n\t\t\t(enum atscmh_rs_code_mode *)\n\t\t\t&c->atscmh_rs_code_mode_sec);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tret = lg216x_get_sccc_block_mode(state,\n\t\t\t(enum atscmh_sccc_block_mode *)\n\t\t\t&c->atscmh_sccc_block_mode);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tret = lg216x_get_sccc_code_mode(state,\n\t\t\t(enum atscmh_sccc_code_mode *)\n\t\t\t&c->atscmh_sccc_code_mode_a,\n\t\t\t(enum atscmh_sccc_code_mode *)\n\t\t\t&c->atscmh_sccc_code_mode_b,\n\t\t\t(enum atscmh_sccc_code_mode *)\n\t\t\t&c->atscmh_sccc_code_mode_c,\n\t\t\t(enum atscmh_sccc_code_mode *)\n\t\t\t&c->atscmh_sccc_code_mode_d);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t}\n#if 0\n\tret = lg216x_read_fic_err_count(state,\n\t\t\t\t(u8 *)&c->atscmh_fic_err);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\tret = lg216x_read_crc_err_count(state,\n\t\t\t\t&c->atscmh_crc_err);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\tret = lg216x_read_rs_err_count(state,\n\t\t\t\t&c->atscmh_rs_err);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tif (((c->atscmh_rs_err >= 240) &&\n\t\t     (c->atscmh_crc_err >= 240)) &&\n\t\t    ((jiffies_to_msecs(jiffies) - state->last_reset) > 6000))\n\t\t\tret = lg216x_soft_reset(state);\n\t\tbreak;\n\tcase LG2161:\n\t\t \n\t\tret = 0;\n\t\tbreak;\n\t}\n\tlg_fail(ret);\n#endif\nfail:\n\treturn ret;\n}\n\nstatic int lg2160_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct lg216x_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\n\tlg_dbg(\"(%d)\\n\", fe->dtv_property_cache.frequency);\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tstate->current_frequency = fe->dtv_property_cache.frequency;\n\t}\n\n\tret = lg2160_agc_fix(state, 0, 0);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\tret = lg2160_agc_polarity(state, 0, 0);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\tret = lg2160_tuner_pwr_save_polarity(state, 1);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\tret = lg216x_set_if(state);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\tret = lg2160_spectrum_polarity(state, state->cfg->spectral_inversion);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t \n\tret = lg216x_soft_reset(state);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lg2160_tuner_pwr_save(state, 0);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tret = lg2160_set_spi_clock(state);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tbreak;\n\tcase LG2161:\n\t\tret = lg2161_set_output_interface(state);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tbreak;\n\t}\n\n\tret = lg216x_set_parade(state, fe->dtv_property_cache.atscmh_parade_id);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lg216x_set_ensemble(state,\n\t\t\tfe->dtv_property_cache.atscmh_rs_frame_ensemble);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lg216x_initialize(state);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lg216x_enable_fic(state, 1);\n\tlg_fail(ret);\n\n\tlg216x_get_frontend(fe, c);\nfail:\n\treturn ret;\n}\n\n \n\nstatic int lg2160_read_lock_status(struct lg216x_state *state,\n\t\t\t\t   int *acq_lock, int *sync_lock)\n{\n\tu8 val;\n\tint ret;\n\n\t*acq_lock = 0;\n\t*sync_lock = 0;\n\n\tret = lg216x_read_reg(state, 0x011b, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*sync_lock = (val & 0x20) ? 0 : 1;\n\t*acq_lock  = (val & 0x40) ? 0 : 1;\nfail:\n\treturn ret;\n}\n\n#ifdef USE_LG2161_LOCK_BITS\nstatic int lg2161_read_lock_status(struct lg216x_state *state,\n\t\t\t\t   int *acq_lock, int *sync_lock)\n{\n\tu8 val;\n\tint ret;\n\n\t*acq_lock = 0;\n\t*sync_lock = 0;\n\n\tret = lg216x_read_reg(state, 0x0304, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*sync_lock = (val & 0x80) ? 0 : 1;\n\n\tret = lg216x_read_reg(state, 0x011b, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*acq_lock  = (val & 0x40) ? 0 : 1;\nfail:\n\treturn ret;\n}\n#endif\n\nstatic int lg216x_read_lock_status(struct lg216x_state *state,\n\t\t\t\t   int *acq_lock, int *sync_lock)\n{\n#ifdef USE_LG2161_LOCK_BITS\n\tint ret;\n\tswitch (state->cfg->lg_chip) {\n\tcase LG2160:\n\t\tret = lg2160_read_lock_status(state, acq_lock, sync_lock);\n\t\tbreak;\n\tcase LG2161:\n\t\tret = lg2161_read_lock_status(state, acq_lock, sync_lock);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n#else\n\treturn lg2160_read_lock_status(state, acq_lock, sync_lock);\n#endif\n}\n\nstatic int lg216x_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct lg216x_state *state = fe->demodulator_priv;\n\tint ret, acq_lock, sync_lock;\n\n\t*status = 0;\n\n\tret = lg216x_read_lock_status(state, &acq_lock, &sync_lock);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tlg_dbg(\"%s%s\\n\",\n\t       acq_lock  ? \"SIGNALEXIST \" : \"\",\n\t       sync_lock ? \"SYNCLOCK\"     : \"\");\n\n\tif (acq_lock)\n\t\t*status |= FE_HAS_SIGNAL;\n\tif (sync_lock)\n\t\t*status |= FE_HAS_SYNC;\n\n\tif (*status)\n\t\t*status |= FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_LOCK;\n\nfail:\n\treturn ret;\n}\n\n \n\nstatic int lg2160_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct lg216x_state *state = fe->demodulator_priv;\n\tu8 snr1, snr2;\n\tint ret;\n\n\t*snr = 0;\n\n\tret = lg216x_read_reg(state, 0x0202, &snr1);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lg216x_read_reg(state, 0x0203, &snr2);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tif ((snr1 == 0xba) || (snr2 == 0xdf))\n\t\t*snr = 0;\n\telse\n#if 1\n\t*snr =  ((snr1 >> 4) * 100) + ((snr1 & 0x0f) * 10) + (snr2 >> 4);\n#else  \n\t*snr =  (snr2 | (snr1 << 8));\n#endif\nfail:\n\treturn ret;\n}\n\nstatic int lg2161_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct lg216x_state *state = fe->demodulator_priv;\n\tu8 snr1, snr2;\n\tint ret;\n\n\t*snr = 0;\n\n\tret = lg216x_read_reg(state, 0x0302, &snr1);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lg216x_read_reg(state, 0x0303, &snr2);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tif ((snr1 == 0xba) || (snr2 == 0xfd))\n\t\t*snr = 0;\n\telse\n\n\t*snr =  ((snr1 >> 4) * 100) + ((snr1 & 0x0f) * 10) + (snr2 & 0x0f);\nfail:\n\treturn ret;\n}\n\nstatic int lg216x_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t       u16 *strength)\n{\n#if 0\n\t \n\tstruct lg216x_state *state = fe->demodulator_priv;\n\tu16 snr;\n\tint ret;\n#endif\n\t*strength = 0;\n#if 0\n\tret = fe->ops.read_snr(fe, &snr);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\t \n\t \n\tif (state->snr >= 8960 * 0x10000)\n\t\t*strength = 0xffff;\n\telse\n\t\t*strength = state->snr / 8960;\nfail:\n\treturn ret;\n#else\n\treturn 0;\n#endif\n}\n\n \n\nstatic int lg216x_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n#if 0\n\tstruct lg216x_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tret = lg216x_read_rs_err_count(state,\n\t\t\t\t       &fe->dtv_property_cache.atscmh_rs_err);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t*ucblocks = fe->dtv_property_cache.atscmh_rs_err;\nfail:\n#else\n\t*ucblocks = 0;\n#endif\n\treturn 0;\n}\n\nstatic int lg216x_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t    struct dvb_frontend_tune_settings\n\t\t\t\t    *fe_tune_settings)\n{\n\tfe_tune_settings->min_delay_ms = 500;\n\tlg_dbg(\"\\n\");\n\treturn 0;\n}\n\nstatic void lg216x_release(struct dvb_frontend *fe)\n{\n\tstruct lg216x_state *state = fe->demodulator_priv;\n\tlg_dbg(\"\\n\");\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops lg2160_ops = {\n\t.delsys = { SYS_ATSCMH },\n\t.info = {\n\t\t.name = \"LG Electronics LG2160 ATSC/MH Frontend\",\n\t\t.frequency_min_hz      =  54 * MHz,\n\t\t.frequency_max_hz      = 858 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t},\n\t.i2c_gate_ctrl        = lg216x_i2c_gate_ctrl,\n#if 0\n\t.init                 = lg216x_init,\n\t.sleep                = lg216x_sleep,\n#endif\n\t.set_frontend         = lg2160_set_frontend,\n\t.get_frontend         = lg216x_get_frontend,\n\t.get_tune_settings    = lg216x_get_tune_settings,\n\t.read_status          = lg216x_read_status,\n#if 0\n\t.read_ber             = lg216x_read_ber,\n#endif\n\t.read_signal_strength = lg216x_read_signal_strength,\n\t.read_snr             = lg2160_read_snr,\n\t.read_ucblocks        = lg216x_read_ucblocks,\n\t.release              = lg216x_release,\n};\n\nstatic const struct dvb_frontend_ops lg2161_ops = {\n\t.delsys = { SYS_ATSCMH },\n\t.info = {\n\t\t.name = \"LG Electronics LG2161 ATSC/MH Frontend\",\n\t\t.frequency_min_hz      =  54 * MHz,\n\t\t.frequency_max_hz      = 858 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t},\n\t.i2c_gate_ctrl        = lg216x_i2c_gate_ctrl,\n#if 0\n\t.init                 = lg216x_init,\n\t.sleep                = lg216x_sleep,\n#endif\n\t.set_frontend         = lg2160_set_frontend,\n\t.get_frontend         = lg216x_get_frontend,\n\t.get_tune_settings    = lg216x_get_tune_settings,\n\t.read_status          = lg216x_read_status,\n#if 0\n\t.read_ber             = lg216x_read_ber,\n#endif\n\t.read_signal_strength = lg216x_read_signal_strength,\n\t.read_snr             = lg2161_read_snr,\n\t.read_ucblocks        = lg216x_read_ucblocks,\n\t.release              = lg216x_release,\n};\n\nstruct dvb_frontend *lg2160_attach(const struct lg2160_config *config,\n\t\t\t\t   struct i2c_adapter *i2c_adap)\n{\n\tstruct lg216x_state *state = NULL;\n\n\tlg_dbg(\"(%d-%04x)\\n\",\n\t       i2c_adap ? i2c_adapter_id(i2c_adap) : 0,\n\t       config ? config->i2c_addr : 0);\n\n\tstate = kzalloc(sizeof(struct lg216x_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tstate->cfg = config;\n\tstate->i2c_adap = i2c_adap;\n\tstate->fic_ver = 0xff;\n\tstate->parade_id = 0xff;\n\n\tswitch (config->lg_chip) {\n\tdefault:\n\t\tlg_warn(\"invalid chip requested, defaulting to LG2160\");\n\t\tfallthrough;\n\tcase LG2160:\n\t\tmemcpy(&state->frontend.ops, &lg2160_ops,\n\t\t       sizeof(struct dvb_frontend_ops));\n\t\tbreak;\n\tcase LG2161:\n\t\tmemcpy(&state->frontend.ops, &lg2161_ops,\n\t\t       sizeof(struct dvb_frontend_ops));\n\t\tbreak;\n\t}\n\n\tstate->frontend.demodulator_priv = state;\n\tstate->current_frequency = -1;\n\t \n\tstate->frontend.dtv_property_cache.atscmh_parade_id = 1;\n\n\treturn &state->frontend;\n}\nEXPORT_SYMBOL_GPL(lg2160_attach);\n\nMODULE_DESCRIPTION(\"LG Electronics LG216x ATSC/MH Demodulator Driver\");\nMODULE_AUTHOR(\"Michael Krufky <mkrufky@linuxtv.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.3\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}