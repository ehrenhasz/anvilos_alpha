{
  "module_name": "dvb-pll.c",
  "hash_id": "813be283da03a93e01c4bbd4ab961b232cab3cff15d7336b28916e0601c6bdbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/dvb-pll.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/idr.h>\n#include <linux/dvb/frontend.h>\n#include <asm/types.h>\n\n#include \"dvb-pll.h\"\n\n#define dprintk(fmt, arg...) \\\n\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt), __func__, ##arg)\n\nstruct dvb_pll_priv {\n\t \n\tint nr;\n\n\t \n\tint pll_i2c_address;\n\tstruct i2c_adapter *i2c;\n\n\t \n\tconst struct dvb_pll_desc *pll_desc;\n\n\t \n\tu32 frequency;\n\tu32 bandwidth;\n};\n\n#define DVB_PLL_MAX 64\nstatic DEFINE_IDA(pll_ida);\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable verbose debug messages\");\n\nstatic unsigned int id[DVB_PLL_MAX] =\n\t{ [ 0 ... (DVB_PLL_MAX-1) ] = DVB_PLL_UNDEFINED };\nmodule_param_array(id, int, NULL, 0644);\nMODULE_PARM_DESC(id, \"force pll id to use (DEBUG ONLY)\");\n\n \n\nstruct dvb_pll_desc {\n\tconst char *name;\n\tu32  min;\n\tu32  max;\n\tu32  iffreq;\n\tvoid (*set)(struct dvb_frontend *fe, u8 *buf);\n\tu8   *initdata;\n\tu8   *initdata2;\n\tu8   *sleepdata;\n\tint  count;\n\tstruct {\n\t\tu32 limit;\n\t\tu32 stepsize;\n\t\tu8  config;\n\t\tu8  cb;\n\t} entries[];\n};\n\n \n \n\nstatic const struct dvb_pll_desc dvb_pll_thomson_dtt7579 = {\n\t.name  = \"Thomson dtt7579\",\n\t.min   = 177 * MHz,\n\t.max   = 858 * MHz,\n\t.iffreq= 36166667,\n\t.sleepdata = (u8[]){ 2, 0xb4, 0x03 },\n\t.count = 4,\n\t.entries = {\n\t\t{  443250000, 166667, 0xb4, 0x02 },\n\t\t{  542000000, 166667, 0xb4, 0x08 },\n\t\t{  771000000, 166667, 0xbc, 0x08 },\n\t\t{  999999999, 166667, 0xf4, 0x08 },\n\t},\n};\n\nstatic void thomson_dtt759x_bw(struct dvb_frontend *fe, u8 *buf)\n{\n\tu32 bw = fe->dtv_property_cache.bandwidth_hz;\n\tif (bw == 7000000)\n\t\tbuf[3] |= 0x10;\n}\n\nstatic const struct dvb_pll_desc dvb_pll_thomson_dtt759x = {\n\t.name  = \"Thomson dtt759x\",\n\t.min   = 177 * MHz,\n\t.max   = 896 * MHz,\n\t.set   = thomson_dtt759x_bw,\n\t.iffreq= 36166667,\n\t.sleepdata = (u8[]){ 2, 0x84, 0x03 },\n\t.count = 5,\n\t.entries = {\n\t\t{  264000000, 166667, 0xb4, 0x02 },\n\t\t{  470000000, 166667, 0xbc, 0x02 },\n\t\t{  735000000, 166667, 0xbc, 0x08 },\n\t\t{  835000000, 166667, 0xf4, 0x08 },\n\t\t{  999999999, 166667, 0xfc, 0x08 },\n\t},\n};\n\nstatic void thomson_dtt7520x_bw(struct dvb_frontend *fe, u8 *buf)\n{\n\tu32 bw = fe->dtv_property_cache.bandwidth_hz;\n\tif (bw == 8000000)\n\t\tbuf[3] ^= 0x10;\n}\n\nstatic const struct dvb_pll_desc dvb_pll_thomson_dtt7520x = {\n\t.name  = \"Thomson dtt7520x\",\n\t.min   = 185 * MHz,\n\t.max   = 900 * MHz,\n\t.set   = thomson_dtt7520x_bw,\n\t.iffreq = 36166667,\n\t.count = 7,\n\t.entries = {\n\t\t{  305000000, 166667, 0xb4, 0x12 },\n\t\t{  405000000, 166667, 0xbc, 0x12 },\n\t\t{  445000000, 166667, 0xbc, 0x12 },\n\t\t{  465000000, 166667, 0xf4, 0x18 },\n\t\t{  735000000, 166667, 0xfc, 0x18 },\n\t\t{  835000000, 166667, 0xbc, 0x18 },\n\t\t{  999999999, 166667, 0xfc, 0x18 },\n\t},\n};\n\nstatic const struct dvb_pll_desc dvb_pll_lg_z201 = {\n\t.name  = \"LG z201\",\n\t.min   = 174 * MHz,\n\t.max   = 862 * MHz,\n\t.iffreq= 36166667,\n\t.sleepdata = (u8[]){ 2, 0xbc, 0x03 },\n\t.count = 5,\n\t.entries = {\n\t\t{  157500000, 166667, 0xbc, 0x01 },\n\t\t{  443250000, 166667, 0xbc, 0x02 },\n\t\t{  542000000, 166667, 0xbc, 0x04 },\n\t\t{  830000000, 166667, 0xf4, 0x04 },\n\t\t{  999999999, 166667, 0xfc, 0x04 },\n\t},\n};\n\nstatic const struct dvb_pll_desc dvb_pll_unknown_1 = {\n\t.name  = \"unknown 1\",  \n\t.min   = 174 * MHz,\n\t.max   = 862 * MHz,\n\t.iffreq= 36166667,\n\t.count = 9,\n\t.entries = {\n\t\t{  150000000, 166667, 0xb4, 0x01 },\n\t\t{  173000000, 166667, 0xbc, 0x01 },\n\t\t{  250000000, 166667, 0xb4, 0x02 },\n\t\t{  400000000, 166667, 0xbc, 0x02 },\n\t\t{  420000000, 166667, 0xf4, 0x02 },\n\t\t{  470000000, 166667, 0xfc, 0x02 },\n\t\t{  600000000, 166667, 0xbc, 0x08 },\n\t\t{  730000000, 166667, 0xf4, 0x08 },\n\t\t{  999999999, 166667, 0xfc, 0x08 },\n\t},\n};\n\n \nstatic const struct dvb_pll_desc dvb_pll_tua6010xs = {\n\t.name  = \"Infineon TUA6010XS\",\n\t.min   = 44250 * kHz,\n\t.max   = 858 * MHz,\n\t.iffreq= 36125000,\n\t.count = 3,\n\t.entries = {\n\t\t{  115750000, 62500, 0x8e, 0x03 },\n\t\t{  403250000, 62500, 0x8e, 0x06 },\n\t\t{  999999999, 62500, 0x8e, 0x85 },\n\t},\n};\n\n \nstatic const struct dvb_pll_desc dvb_pll_env57h1xd5 = {\n\t.name  = \"Panasonic ENV57H1XD5\",\n\t.min   = 44250 * kHz,\n\t.max   = 858 * MHz,\n\t.iffreq= 36125000,\n\t.count = 4,\n\t.entries = {\n\t\t{  153000000, 166667, 0xc2, 0x41 },\n\t\t{  470000000, 166667, 0xc2, 0x42 },\n\t\t{  526000000, 166667, 0xc2, 0x84 },\n\t\t{  999999999, 166667, 0xc2, 0xa4 },\n\t},\n};\n\n \nstatic void tda665x_bw(struct dvb_frontend *fe, u8 *buf)\n{\n\tu32 bw = fe->dtv_property_cache.bandwidth_hz;\n\tif (bw == 8000000)\n\t\tbuf[3] |= 0x08;\n}\n\nstatic const struct dvb_pll_desc dvb_pll_tda665x = {\n\t.name  = \"Philips TDA6650/TDA6651\",\n\t.min   = 44250 * kHz,\n\t.max   = 858 * MHz,\n\t.set   = tda665x_bw,\n\t.iffreq= 36166667,\n\t.initdata = (u8[]){ 4, 0x0b, 0xf5, 0x85, 0xab },\n\t.count = 12,\n\t.entries = {\n\t\t{   93834000, 166667, 0xca, 0x61   },\n\t\t{  123834000, 166667, 0xca, 0xa1   },\n\t\t{  161000000, 166667, 0xca, 0xa1   },\n\t\t{  163834000, 166667, 0xca, 0xc2   },\n\t\t{  253834000, 166667, 0xca, 0x62   },\n\t\t{  383834000, 166667, 0xca, 0xa2   },\n\t\t{  443834000, 166667, 0xca, 0xc2   },\n\t\t{  444000000, 166667, 0xca, 0xc4   },\n\t\t{  583834000, 166667, 0xca, 0x64   },\n\t\t{  793834000, 166667, 0xca, 0xa4   },\n\t\t{  444834000, 166667, 0xca, 0xc4   },\n\t\t{  861000000, 166667, 0xca, 0xe4   },\n\t}\n};\n\n \nstatic void tua6034_bw(struct dvb_frontend *fe, u8 *buf)\n{\n\tu32 bw = fe->dtv_property_cache.bandwidth_hz;\n\tif (bw == 7000000)\n\t\tbuf[3] |= 0x08;\n}\n\nstatic const struct dvb_pll_desc dvb_pll_tua6034 = {\n\t.name  = \"Infineon TUA6034\",\n\t.min   = 44250 * kHz,\n\t.max   = 858 * MHz,\n\t.iffreq= 36166667,\n\t.count = 3,\n\t.set   = tua6034_bw,\n\t.entries = {\n\t\t{  174500000, 62500, 0xce, 0x01 },\n\t\t{  230000000, 62500, 0xce, 0x02 },\n\t\t{  999999999, 62500, 0xce, 0x04 },\n\t},\n};\n\n \nstatic void tded4_bw(struct dvb_frontend *fe, u8 *buf)\n{\n\tu32 bw = fe->dtv_property_cache.bandwidth_hz;\n\tif (bw == 8000000)\n\t\tbuf[3] |= 0x04;\n}\n\nstatic const struct dvb_pll_desc dvb_pll_tded4 = {\n\t.name = \"ALPS TDED4\",\n\t.min =  47 * MHz,\n\t.max = 863 * MHz,\n\t.iffreq= 36166667,\n\t.set   = tded4_bw,\n\t.count = 4,\n\t.entries = {\n\t\t{ 153000000, 166667, 0x85, 0x01 },\n\t\t{ 470000000, 166667, 0x85, 0x02 },\n\t\t{ 823000000, 166667, 0x85, 0x08 },\n\t\t{ 999999999, 166667, 0x85, 0x88 },\n\t}\n};\n\n \nstatic const struct dvb_pll_desc dvb_pll_tdhu2 = {\n\t.name = \"ALPS TDHU2\",\n\t.min =  54 * MHz,\n\t.max = 864 * MHz,\n\t.iffreq= 44000000,\n\t.count = 4,\n\t.entries = {\n\t\t{ 162000000, 62500, 0x85, 0x01 },\n\t\t{ 426000000, 62500, 0x85, 0x02 },\n\t\t{ 782000000, 62500, 0x85, 0x08 },\n\t\t{ 999999999, 62500, 0x85, 0x88 },\n\t}\n};\n\n \nstatic const struct dvb_pll_desc dvb_pll_samsung_tbmv = {\n\t.name = \"Samsung TBMV30111IN / TBMV30712IN1\",\n\t.min =  54 * MHz,\n\t.max = 860 * MHz,\n\t.iffreq= 44000000,\n\t.count = 6,\n\t.entries = {\n\t\t{ 172000000, 166667, 0xb4, 0x01 },\n\t\t{ 214000000, 166667, 0xb4, 0x02 },\n\t\t{ 467000000, 166667, 0xbc, 0x02 },\n\t\t{ 721000000, 166667, 0xbc, 0x08 },\n\t\t{ 841000000, 166667, 0xf4, 0x08 },\n\t\t{ 999999999, 166667, 0xfc, 0x02 },\n\t}\n};\n\n \nstatic const struct dvb_pll_desc dvb_pll_philips_sd1878_tda8261 = {\n\t.name  = \"Philips SD1878\",\n\t.min   =  950 * MHz,\n\t.max   = 2150 * MHz,\n\t.iffreq= 249,  \n\t.count = 4,\n\t.entries = {\n\t\t{ 1250000, 500, 0xc4, 0x00},\n\t\t{ 1450000, 500, 0xc4, 0x40},\n\t\t{ 2050000, 500, 0xc4, 0x80},\n\t\t{ 2150000, 500, 0xc4, 0xc0},\n\t},\n};\n\nstatic void opera1_bw(struct dvb_frontend *fe, u8 *buf)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct dvb_pll_priv *priv = fe->tuner_priv;\n\tu32 b_w  = (c->symbol_rate * 27) / 32000;\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->pll_i2c_address,\n\t\t.flags = 0,\n\t\t.buf = buf,\n\t\t.len = 4\n\t};\n\tint result;\n\tu8 lpf;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tresult = i2c_transfer(priv->i2c, &msg, 1);\n\tif (result != 1)\n\t\tpr_err(\"%s: i2c_transfer failed:%d\",\n\t\t\t__func__, result);\n\n\tif (b_w <= 10000)\n\t\tlpf = 0xc;\n\telse if (b_w <= 12000)\n\t\tlpf = 0x2;\n\telse if (b_w <= 14000)\n\t\tlpf = 0xa;\n\telse if (b_w <= 16000)\n\t\tlpf = 0x6;\n\telse if (b_w <= 18000)\n\t\tlpf = 0xe;\n\telse if (b_w <= 20000)\n\t\tlpf = 0x1;\n\telse if (b_w <= 22000)\n\t\tlpf = 0x9;\n\telse if (b_w <= 24000)\n\t\tlpf = 0x5;\n\telse if (b_w <= 26000)\n\t\tlpf = 0xd;\n\telse if (b_w <= 28000)\n\t\tlpf = 0x3;\n\t\telse\n\t\tlpf = 0xb;\n\tbuf[2] ^= 0x1c;  \n\t \n\tbuf[2] |= ((lpf >> 2) & 0x3) << 3;\n\tbuf[3] |= (lpf & 0x3) << 2;\n\n\treturn;\n}\n\nstatic const struct dvb_pll_desc dvb_pll_opera1 = {\n\t.name  = \"Opera Tuner\",\n\t.min   =  900 * MHz,\n\t.max   = 2250 * MHz,\n\t.initdata = (u8[]){ 4, 0x08, 0xe5, 0xe1, 0x00 },\n\t.initdata2 = (u8[]){ 4, 0x08, 0xe5, 0xe5, 0x00 },\n\t.iffreq= 0,\n\t.set   = opera1_bw,\n\t.count = 8,\n\t.entries = {\n\t\t{ 1064000, 500, 0xf9, 0xc2 },\n\t\t{ 1169000, 500, 0xf9, 0xe2 },\n\t\t{ 1299000, 500, 0xf9, 0x20 },\n\t\t{ 1444000, 500, 0xf9, 0x40 },\n\t\t{ 1606000, 500, 0xf9, 0x60 },\n\t\t{ 1777000, 500, 0xf9, 0x80 },\n\t\t{ 1941000, 500, 0xf9, 0xa0 },\n\t\t{ 2250000, 500, 0xf9, 0xc0 },\n\t}\n};\n\nstatic void samsung_dtos403ih102a_set(struct dvb_frontend *fe, u8 *buf)\n{\n\tstruct dvb_pll_priv *priv = fe->tuner_priv;\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->pll_i2c_address,\n\t\t.flags = 0,\n\t\t.buf = buf,\n\t\t.len = 4\n\t};\n\tint result;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tresult = i2c_transfer(priv->i2c, &msg, 1);\n\tif (result != 1)\n\t\tpr_err(\"%s: i2c_transfer failed:%d\",\n\t\t\t__func__, result);\n\n\tbuf[2] = 0x9e;\n\tbuf[3] = 0x90;\n\n\treturn;\n}\n\n \nstatic const struct dvb_pll_desc dvb_pll_samsung_dtos403ih102a = {\n\t.name   = \"Samsung DTOS403IH102A\",\n\t.min    = 44250 * kHz,\n\t.max    = 858 * MHz,\n\t.iffreq =  36125000,\n\t.count  = 8,\n\t.set    = samsung_dtos403ih102a_set,\n\t.entries = {\n\t\t{ 135000000, 62500, 0xbe, 0x01 },\n\t\t{ 177000000, 62500, 0xf6, 0x01 },\n\t\t{ 370000000, 62500, 0xbe, 0x02 },\n\t\t{ 450000000, 62500, 0xf6, 0x02 },\n\t\t{ 466000000, 62500, 0xfe, 0x02 },\n\t\t{ 538000000, 62500, 0xbe, 0x08 },\n\t\t{ 826000000, 62500, 0xf6, 0x08 },\n\t\t{ 999999999, 62500, 0xfe, 0x08 },\n\t}\n};\n\n \nstatic const struct dvb_pll_desc dvb_pll_samsung_tdtc9251dh0 = {\n\t.name\t= \"Samsung TDTC9251DH0\",\n\t.min\t=  48 * MHz,\n\t.max\t= 863 * MHz,\n\t.iffreq\t=  36166667,\n\t.count\t= 3,\n\t.entries = {\n\t\t{ 157500000, 166667, 0xcc, 0x09 },\n\t\t{ 443000000, 166667, 0xcc, 0x0a },\n\t\t{ 863000000, 166667, 0xcc, 0x08 },\n\t}\n};\n\n \nstatic const struct dvb_pll_desc dvb_pll_samsung_tbdu18132 = {\n\t.name = \"Samsung TBDU18132\",\n\t.min\t=  950 * MHz,\n\t.max\t= 2150 * MHz,  \n\t.iffreq = 0,\n\t.count = 2,\n\t.entries = {\n\t\t{ 1550000, 125, 0x84, 0x82 },\n\t\t{ 4095937, 125, 0x84, 0x80 },\n\t}\n\t \n};\n\n \nstatic const struct dvb_pll_desc dvb_pll_samsung_tbmu24112 = {\n\t.name = \"Samsung TBMU24112\",\n\t.min\t=  950 * MHz,\n\t.max\t= 2150 * MHz,  \n\t.iffreq = 0,\n\t.count = 2,\n\t.entries = {\n\t\t{ 1500000, 125, 0x84, 0x18 },\n\t\t{ 9999999, 125, 0x84, 0x08 },\n\t}\n};\n\n \n \nstatic const struct dvb_pll_desc dvb_pll_alps_tdee4 = {\n\t.name = \"ALPS TDEE4\",\n\t.min\t=  47 * MHz,\n\t.max\t= 862 * MHz,\n\t.iffreq\t=  36125000,\n\t.count = 4,\n\t.entries = {\n\t\t{ 153000000, 62500, 0x95, 0x01 },\n\t\t{ 430000000, 62500, 0x95, 0x02 },\n\t\t{ 822000000, 62500, 0x95, 0x08 },\n\t\t{ 999999999, 62500, 0x95, 0x88 },\n\t}\n};\n\n \n \nstatic const struct dvb_pll_desc dvb_pll_tua6034_friio = {\n\t.name   = \"Infineon TUA6034 ISDB-T (Friio)\",\n\t.min    =  90 * MHz,\n\t.max    = 770 * MHz,\n\t.iffreq =  57000000,\n\t.initdata = (u8[]){ 4, 0x9a, 0x50, 0xb2, 0x08 },\n\t.sleepdata = (u8[]){ 4, 0x9a, 0x70, 0xb3, 0x0b },\n\t.count = 3,\n\t.entries = {\n\t\t{ 170000000, 142857, 0xba, 0x09 },\n\t\t{ 470000000, 142857, 0xba, 0x0a },\n\t\t{ 770000000, 142857, 0xb2, 0x08 },\n\t}\n};\n\n \nstatic const struct dvb_pll_desc dvb_pll_tda665x_earth_pt1 = {\n\t.name   = \"Philips TDA6651 ISDB-T (EarthSoft PT1)\",\n\t.min    =  90 * MHz,\n\t.max    = 770 * MHz,\n\t.iffreq =  57000000,\n\t.initdata = (u8[]){ 5, 0x0e, 0x7f, 0xc1, 0x80, 0x80 },\n\t.count = 10,\n\t.entries = {\n\t\t{ 140000000, 142857, 0xc1, 0x81 },\n\t\t{ 170000000, 142857, 0xc1, 0xa1 },\n\t\t{ 220000000, 142857, 0xc1, 0x62 },\n\t\t{ 330000000, 142857, 0xc1, 0xa2 },\n\t\t{ 402000000, 142857, 0xc1, 0xe2 },\n\t\t{ 450000000, 142857, 0xc1, 0x64 },\n\t\t{ 550000000, 142857, 0xc1, 0x84 },\n\t\t{ 600000000, 142857, 0xc1, 0xa4 },\n\t\t{ 700000000, 142857, 0xc1, 0xc4 },\n\t\t{ 770000000, 142857, 0xc1, 0xe4 },\n\t}\n};\n\n \n\nstatic const struct dvb_pll_desc *pll_list[] = {\n\t[DVB_PLL_UNDEFINED]              = NULL,\n\t[DVB_PLL_THOMSON_DTT7579]        = &dvb_pll_thomson_dtt7579,\n\t[DVB_PLL_THOMSON_DTT759X]        = &dvb_pll_thomson_dtt759x,\n\t[DVB_PLL_THOMSON_DTT7520X]       = &dvb_pll_thomson_dtt7520x,\n\t[DVB_PLL_LG_Z201]                = &dvb_pll_lg_z201,\n\t[DVB_PLL_UNKNOWN_1]              = &dvb_pll_unknown_1,\n\t[DVB_PLL_TUA6010XS]              = &dvb_pll_tua6010xs,\n\t[DVB_PLL_ENV57H1XD5]             = &dvb_pll_env57h1xd5,\n\t[DVB_PLL_TUA6034]                = &dvb_pll_tua6034,\n\t[DVB_PLL_TDA665X]                = &dvb_pll_tda665x,\n\t[DVB_PLL_TDED4]                  = &dvb_pll_tded4,\n\t[DVB_PLL_TDEE4]                  = &dvb_pll_alps_tdee4,\n\t[DVB_PLL_TDHU2]                  = &dvb_pll_tdhu2,\n\t[DVB_PLL_SAMSUNG_TBMV]           = &dvb_pll_samsung_tbmv,\n\t[DVB_PLL_PHILIPS_SD1878_TDA8261] = &dvb_pll_philips_sd1878_tda8261,\n\t[DVB_PLL_OPERA1]                 = &dvb_pll_opera1,\n\t[DVB_PLL_SAMSUNG_DTOS403IH102A]  = &dvb_pll_samsung_dtos403ih102a,\n\t[DVB_PLL_SAMSUNG_TDTC9251DH0]    = &dvb_pll_samsung_tdtc9251dh0,\n\t[DVB_PLL_SAMSUNG_TBDU18132]\t = &dvb_pll_samsung_tbdu18132,\n\t[DVB_PLL_SAMSUNG_TBMU24112]      = &dvb_pll_samsung_tbmu24112,\n\t[DVB_PLL_TUA6034_FRIIO]          = &dvb_pll_tua6034_friio,\n\t[DVB_PLL_TDA665X_EARTH_PT1]      = &dvb_pll_tda665x_earth_pt1,\n};\n\n \n \n\nstatic int dvb_pll_configure(struct dvb_frontend *fe, u8 *buf,\n\t\t\t     const u32 frequency)\n{\n\tstruct dvb_pll_priv *priv = fe->tuner_priv;\n\tconst struct dvb_pll_desc *desc = priv->pll_desc;\n\tu32 div;\n\tint i;\n\n\tfor (i = 0; i < desc->count; i++) {\n\t\tif (frequency > desc->entries[i].limit)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (debug)\n\t\tdprintk(\"pll: %s: freq=%d | i=%d/%d\\n\", desc->name,\n\t\t       frequency, i, desc->count);\n\tif (i == desc->count)\n\t\treturn -EINVAL;\n\n\tdiv = (frequency + desc->iffreq +\n\t       desc->entries[i].stepsize/2) / desc->entries[i].stepsize;\n\tbuf[0] = div >> 8;\n\tbuf[1] = div & 0xff;\n\tbuf[2] = desc->entries[i].config;\n\tbuf[3] = desc->entries[i].cb;\n\n\tif (desc->set)\n\t\tdesc->set(fe, buf);\n\n\tif (debug)\n\t\tdprintk(\"pll: %s: div=%d | buf=0x%02x,0x%02x,0x%02x,0x%02x\\n\",\n\t\t       desc->name, div, buf[0], buf[1], buf[2], buf[3]);\n\n\t\n\treturn (div * desc->entries[i].stepsize) - desc->iffreq;\n}\n\nstatic void dvb_pll_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int dvb_pll_sleep(struct dvb_frontend *fe)\n{\n\tstruct dvb_pll_priv *priv = fe->tuner_priv;\n\n\tif (priv->i2c == NULL)\n\t\treturn -EINVAL;\n\n\tif (priv->pll_desc->sleepdata) {\n\t\tstruct i2c_msg msg = { .flags = 0,\n\t\t\t.addr = priv->pll_i2c_address,\n\t\t\t.buf = priv->pll_desc->sleepdata + 1,\n\t\t\t.len = priv->pll_desc->sleepdata[0] };\n\n\t\tint result;\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\tif ((result = i2c_transfer(priv->i2c, &msg, 1)) != 1) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 0;\n\t}\n\t \n\treturn -EINVAL;\n}\n\nstatic int dvb_pll_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct dvb_pll_priv *priv = fe->tuner_priv;\n\tu8 buf[4];\n\tstruct i2c_msg msg =\n\t\t{ .addr = priv->pll_i2c_address, .flags = 0,\n\t\t  .buf = buf, .len = sizeof(buf) };\n\tint result;\n\tu32 frequency = 0;\n\n\tif (priv->i2c == NULL)\n\t\treturn -EINVAL;\n\n\tresult = dvb_pll_configure(fe, buf, c->frequency);\n\tif (result < 0)\n\t\treturn result;\n\telse\n\t\tfrequency = result;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif ((result = i2c_transfer(priv->i2c, &msg, 1)) != 1) {\n\t\treturn result;\n\t}\n\n\tpriv->frequency = frequency;\n\tpriv->bandwidth = c->bandwidth_hz;\n\n\treturn 0;\n}\n\nstatic int dvb_pll_calc_regs(struct dvb_frontend *fe,\n\t\t\t     u8 *buf, int buf_len)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct dvb_pll_priv *priv = fe->tuner_priv;\n\tint result;\n\tu32 frequency = 0;\n\n\tif (buf_len < 5)\n\t\treturn -EINVAL;\n\n\tresult = dvb_pll_configure(fe, buf + 1, c->frequency);\n\tif (result < 0)\n\t\treturn result;\n\telse\n\t\tfrequency = result;\n\n\tbuf[0] = priv->pll_i2c_address;\n\n\tpriv->frequency = frequency;\n\tpriv->bandwidth = c->bandwidth_hz;\n\n\treturn 5;\n}\n\nstatic int dvb_pll_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct dvb_pll_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic int dvb_pll_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct dvb_pll_priv *priv = fe->tuner_priv;\n\t*bandwidth = priv->bandwidth;\n\treturn 0;\n}\n\nstatic int dvb_pll_init(struct dvb_frontend *fe)\n{\n\tstruct dvb_pll_priv *priv = fe->tuner_priv;\n\n\tif (priv->i2c == NULL)\n\t\treturn -EINVAL;\n\n\tif (priv->pll_desc->initdata) {\n\t\tstruct i2c_msg msg = { .flags = 0,\n\t\t\t.addr = priv->pll_i2c_address,\n\t\t\t.buf = priv->pll_desc->initdata + 1,\n\t\t\t.len = priv->pll_desc->initdata[0] };\n\n\t\tint result;\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\tresult = i2c_transfer(priv->i2c, &msg, 1);\n\t\tif (result != 1)\n\t\t\treturn result;\n\t\tif (priv->pll_desc->initdata2) {\n\t\t\tmsg.buf = priv->pll_desc->initdata2 + 1;\n\t\t\tmsg.len = priv->pll_desc->initdata2[0];\n\t\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\t\tresult = i2c_transfer(priv->i2c, &msg, 1);\n\t\t\tif (result != 1)\n\t\t\t\treturn result;\n\t\t}\n\t\treturn 0;\n\t}\n\t \n\treturn -EINVAL;\n}\n\nstatic const struct dvb_tuner_ops dvb_pll_tuner_ops = {\n\t.release = dvb_pll_release,\n\t.sleep = dvb_pll_sleep,\n\t.init = dvb_pll_init,\n\t.set_params = dvb_pll_set_params,\n\t.calc_regs = dvb_pll_calc_regs,\n\t.get_frequency = dvb_pll_get_frequency,\n\t.get_bandwidth = dvb_pll_get_bandwidth,\n};\n\nstruct dvb_frontend *dvb_pll_attach(struct dvb_frontend *fe, int pll_addr,\n\t\t\t\t    struct i2c_adapter *i2c,\n\t\t\t\t    unsigned int pll_desc_id)\n{\n\tu8 *b1;\n\tstruct i2c_msg msg = { .addr = pll_addr, .flags = I2C_M_RD, .len = 1 };\n\tstruct dvb_pll_priv *priv = NULL;\n\tint ret;\n\tconst struct dvb_pll_desc *desc;\n\tint nr;\n\n\tb1 = kmalloc(1, GFP_KERNEL);\n\tif (!b1)\n\t\treturn NULL;\n\n\tb1[0] = 0;\n\tmsg.buf = b1;\n\n\tnr = ida_simple_get(&pll_ida, 0, DVB_PLL_MAX, GFP_KERNEL);\n\tif (nr < 0) {\n\t\tkfree(b1);\n\t\treturn NULL;\n\t}\n\n\tif (id[nr] > DVB_PLL_UNDEFINED && id[nr] < ARRAY_SIZE(pll_list))\n\t\tpll_desc_id = id[nr];\n\n\tBUG_ON(pll_desc_id < 1 || pll_desc_id >= ARRAY_SIZE(pll_list));\n\n\tdesc = pll_list[pll_desc_id];\n\n\tif (i2c != NULL) {\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\tret = i2c_transfer (i2c, &msg, 1);\n\t\tif (ret != 1)\n\t\t\tgoto out;\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\t     fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tpriv = kzalloc(sizeof(struct dvb_pll_priv), GFP_KERNEL);\n\tif (!priv)\n\t\tgoto out;\n\n\tpriv->pll_i2c_address = pll_addr;\n\tpriv->i2c = i2c;\n\tpriv->pll_desc = desc;\n\tpriv->nr = nr;\n\n\tmemcpy(&fe->ops.tuner_ops, &dvb_pll_tuner_ops,\n\t       sizeof(struct dvb_tuner_ops));\n\n\tstrscpy(fe->ops.tuner_ops.info.name, desc->name,\n\t\tsizeof(fe->ops.tuner_ops.info.name));\n\n\tfe->ops.tuner_ops.info.frequency_min_hz = desc->min;\n\tfe->ops.tuner_ops.info.frequency_max_hz = desc->max;\n\n\tdprintk(\"%s tuner, frequency range: %u...%u\\n\",\n\t\tdesc->name, desc->min, desc->max);\n\n\tif (!desc->initdata)\n\t\tfe->ops.tuner_ops.init = NULL;\n\tif (!desc->sleepdata)\n\t\tfe->ops.tuner_ops.sleep = NULL;\n\n\tfe->tuner_priv = priv;\n\n\tif ((debug) || (id[priv->nr] == pll_desc_id)) {\n\t\tdprintk(\"dvb-pll[%d]\", priv->nr);\n\t\tif (i2c != NULL)\n\t\t\tpr_cont(\" %d-%04x\", i2c_adapter_id(i2c), pll_addr);\n\t\tpr_cont(\": id# %d (%s) attached, %s\\n\", pll_desc_id, desc->name,\n\t\t       id[priv->nr] == pll_desc_id ?\n\t\t\t\t\"insmod option\" : \"autodetected\");\n\t}\n\n\tkfree(b1);\n\n\treturn fe;\nout:\n\tkfree(b1);\n\tida_simple_remove(&pll_ida, nr);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(dvb_pll_attach);\n\n\nstatic int\ndvb_pll_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct dvb_pll_config *cfg;\n\tstruct dvb_frontend *fe;\n\tunsigned int desc_id;\n\n\tcfg = client->dev.platform_data;\n\tfe = cfg->fe;\n\ti2c_set_clientdata(client, fe);\n\tdesc_id = (unsigned int) id->driver_data;\n\n\tif (!dvb_pll_attach(fe, client->addr, client->adapter, desc_id))\n\t\treturn -ENOMEM;\n\n\t \n\tfe->ops.tuner_ops.release = NULL;\n\tdev_info(&client->dev, \"DVB Simple Tuner attached.\\n\");\n\treturn 0;\n}\n\nstatic void dvb_pll_remove(struct i2c_client *client)\n{\n\tstruct dvb_frontend *fe = i2c_get_clientdata(client);\n\tstruct dvb_pll_priv *priv = fe->tuner_priv;\n\n\tida_simple_remove(&pll_ida, priv->nr);\n\tdvb_pll_release(fe);\n}\n\n\nstatic const struct i2c_device_id dvb_pll_id[] = {\n\t{\"dtt7579\",\t\tDVB_PLL_THOMSON_DTT7579},\n\t{\"dtt759x\",\t\tDVB_PLL_THOMSON_DTT759X},\n\t{\"z201\",\t\tDVB_PLL_LG_Z201},\n\t{\"unknown_1\",\t\tDVB_PLL_UNKNOWN_1},\n\t{\"tua6010xs\",\t\tDVB_PLL_TUA6010XS},\n\t{\"env57h1xd5\",\t\tDVB_PLL_ENV57H1XD5},\n\t{\"tua6034\",\t\tDVB_PLL_TUA6034},\n\t{\"tda665x\",\t\tDVB_PLL_TDA665X},\n\t{\"tded4\",\t\tDVB_PLL_TDED4},\n\t{\"tdhu2\",\t\tDVB_PLL_TDHU2},\n\t{\"tbmv\",\t\tDVB_PLL_SAMSUNG_TBMV},\n\t{\"sd1878_tda8261\",\tDVB_PLL_PHILIPS_SD1878_TDA8261},\n\t{\"opera1\",\t\tDVB_PLL_OPERA1},\n\t{\"dtos403ih102a\",\tDVB_PLL_SAMSUNG_DTOS403IH102A},\n\t{\"tdtc9251dh0\",\t\tDVB_PLL_SAMSUNG_TDTC9251DH0},\n\t{\"tbdu18132\",\t\tDVB_PLL_SAMSUNG_TBDU18132},\n\t{\"tbmu24112\",\t\tDVB_PLL_SAMSUNG_TBMU24112},\n\t{\"tdee4\",\t\tDVB_PLL_TDEE4},\n\t{\"dtt7520x\",\t\tDVB_PLL_THOMSON_DTT7520X},\n\t{\"tua6034_friio\",\tDVB_PLL_TUA6034_FRIIO},\n\t{\"tda665x_earthpt1\",\tDVB_PLL_TDA665X_EARTH_PT1},\n\t{}\n};\n\n\nMODULE_DEVICE_TABLE(i2c, dvb_pll_id);\n\nstatic struct i2c_driver dvb_pll_driver = {\n\t.driver = {\n\t\t.name = \"dvb_pll\",\n\t},\n\t.probe    = dvb_pll_probe,\n\t.remove   = dvb_pll_remove,\n\t.id_table = dvb_pll_id,\n};\n\nmodule_i2c_driver(dvb_pll_driver);\n\nMODULE_DESCRIPTION(\"dvb pll library\");\nMODULE_AUTHOR(\"Gerd Knorr\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}