{
  "module_name": "bcm3510.c",
  "hash_id": "7b86a8cf594a1bb74eb92484328cf74467a4d4cf7ed67d1f9675b729edaa7c48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/bcm3510.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\n#include <media/dvb_frontend.h>\n#include \"bcm3510.h\"\n#include \"bcm3510_priv.h\"\n\n \n#define MAX_XFER_SIZE\t128\n\nstruct bcm3510_state {\n\n\tstruct i2c_adapter* i2c;\n\tconst struct bcm3510_config* config;\n\tstruct dvb_frontend frontend;\n\n\t \n\tstruct mutex hab_mutex;\n\tu8 firmware_loaded:1;\n\n\tunsigned long next_status_check;\n\tunsigned long status_check_interval;\n\tstruct bcm3510_hab_cmd_status1 status1;\n\tstruct bcm3510_hab_cmd_status2 status2;\n};\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info,2=i2c (|-able)).\");\n\n#define dprintk(level,x...) if (level & debug) printk(x)\n#define dbufout(b,l,m) {\\\n\t    int i; \\\n\t    for (i = 0; i < l; i++) \\\n\t\tm(\"%02x \",b[i]); \\\n}\n#define deb_info(args...) dprintk(0x01,args)\n#define deb_i2c(args...)  dprintk(0x02,args)\n#define deb_hab(args...)  dprintk(0x04,args)\n\n \nstatic int bcm3510_writebytes (struct bcm3510_state *state, u8 reg, u8 *buf, u8 len)\n{\n\tu8 b[256];\n\tint err;\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = b, .len = len + 1 };\n\n\tb[0] = reg;\n\tmemcpy(&b[1],buf,len);\n\n\tdeb_i2c(\"i2c wr %02x: \",reg);\n\tdbufout(buf,len,deb_i2c);\n\tdeb_i2c(\"\\n\");\n\n\tif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\n\n\t\tdeb_info(\"%s: i2c write error (addr %02x, reg %02x, err == %i)\\n\",\n\t\t\t__func__, state->config->demod_address, reg,  err);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm3510_readbytes (struct bcm3510_state *state, u8 reg, u8 *buf, u8 len)\n{\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->config->demod_address, .flags = 0,        .buf = &reg, .len = 1 },\n\t\t{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = buf,  .len = len }\n\t};\n\tint err;\n\n\tmemset(buf,0,len);\n\n\tif ((err = i2c_transfer (state->i2c, msg, 2)) != 2) {\n\t\tdeb_info(\"%s: i2c read error (addr %02x, reg %02x, err == %i)\\n\",\n\t\t\t__func__, state->config->demod_address, reg,  err);\n\t\treturn -EREMOTEIO;\n\t}\n\tdeb_i2c(\"i2c rd %02x: \",reg);\n\tdbufout(buf,len,deb_i2c);\n\tdeb_i2c(\"\\n\");\n\n\treturn 0;\n}\n\nstatic int bcm3510_writeB(struct bcm3510_state *state, u8 reg, bcm3510_register_value v)\n{\n\treturn bcm3510_writebytes(state,reg,&v.raw,1);\n}\n\nstatic int bcm3510_readB(struct bcm3510_state *state, u8 reg, bcm3510_register_value *v)\n{\n\treturn bcm3510_readbytes(state,reg,&v->raw,1);\n}\n\n \nstatic int bcm3510_hab_get_response(struct bcm3510_state *st, u8 *buf, int len)\n{\n\tbcm3510_register_value v;\n\tint ret,i;\n\n\tv.HABADR_a6.HABADR = 0;\n\tif ((ret = bcm3510_writeB(st,0xa6,v)) < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif ((ret = bcm3510_readB(st,0xa7,&v)) < 0)\n\t\t\treturn ret;\n\t\tbuf[i] = v.HABDATA_a7;\n\t}\n\treturn 0;\n}\n\nstatic int bcm3510_hab_send_request(struct bcm3510_state *st, u8 *buf, int len)\n{\n\tbcm3510_register_value v,hab;\n\tint ret,i;\n\tunsigned long t;\n\n \n\tif ((ret = bcm3510_readB(st,0xa8,&v)) < 0)\n\t\treturn ret;\n\tif (v.HABSTAT_a8.HABR) {\n\t\tdeb_info(\"HAB is running already - clearing it.\\n\");\n\t\tv.HABSTAT_a8.HABR = 0;\n\t\tbcm3510_writeB(st,0xa8,v);\n\n\t}\n\n \n\thab.HABADR_a6.HABADR = 0;\n\tif ((ret = bcm3510_writeB(st,0xa6,hab)) < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < len; i++) {\n\t\thab.HABDATA_a7 = buf[i];\n\t\tif ((ret = bcm3510_writeB(st,0xa7,hab)) < 0)\n\t\t\treturn ret;\n\t}\n\n \n\tv.raw = 0; v.HABSTAT_a8.HABR = 1; v.HABSTAT_a8.LDHABR = 1;\n\tif ((ret = bcm3510_writeB(st,0xa8,v)) < 0)\n\t\treturn ret;\n\n \n\tt = jiffies + 1*HZ;\n\twhile (time_before(jiffies, t)) {\n\t\tdeb_info(\"waiting for HAB to complete\\n\");\n\t\tmsleep(10);\n\t\tif ((ret = bcm3510_readB(st,0xa8,&v)) < 0)\n\t\t\treturn ret;\n\n\t\tif (!v.HABSTAT_a8.HABR)\n\t\t\treturn 0;\n\t}\n\n\tdeb_info(\"send_request execution timed out.\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int bcm3510_do_hab_cmd(struct bcm3510_state *st, u8 cmd, u8 msgid, u8 *obuf, u8 olen, u8 *ibuf, u8 ilen)\n{\n\tu8 ob[MAX_XFER_SIZE], ib[MAX_XFER_SIZE];\n\tint ret = 0;\n\n\tif (ilen + 2 > sizeof(ib)) {\n\t\tdeb_hab(\"do_hab_cmd: ilen=%d is too big!\\n\", ilen);\n\t\treturn -EINVAL;\n\t}\n\n\tif (olen + 2 > sizeof(ob)) {\n\t\tdeb_hab(\"do_hab_cmd: olen=%d is too big!\\n\", olen);\n\t\treturn -EINVAL;\n\t}\n\n\tob[0] = cmd;\n\tob[1] = msgid;\n\tmemcpy(&ob[2],obuf,olen);\n\n\tdeb_hab(\"hab snd: \");\n\tdbufout(ob,olen+2,deb_hab);\n\tdeb_hab(\"\\n\");\n\n\tif (mutex_lock_interruptible(&st->hab_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tif ((ret = bcm3510_hab_send_request(st, ob, olen+2)) < 0 ||\n\t\t(ret = bcm3510_hab_get_response(st, ib, ilen+2)) < 0)\n\t\tgoto error;\n\n\tdeb_hab(\"hab get: \");\n\tdbufout(ib,ilen+2,deb_hab);\n\tdeb_hab(\"\\n\");\n\n\tmemcpy(ibuf,&ib[2],ilen);\nerror:\n\tmutex_unlock(&st->hab_mutex);\n\treturn ret;\n}\n\n#if 0\n \nstatic int bcm3510_is_ap_ready(struct bcm3510_state *st)\n{\n\tbcm3510_register_value ap,hab;\n\tint ret;\n\n\tif ((ret = bcm3510_readB(st,0xa8,&hab)) < 0 ||\n\t\t(ret = bcm3510_readB(st,0xa2,&ap) < 0))\n\t\treturn ret;\n\n\tif (ap.APSTAT1_a2.RESET || ap.APSTAT1_a2.IDLE || ap.APSTAT1_a2.STOP || hab.HABSTAT_a8.HABR) {\n\t\tdeb_info(\"AP is busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int bcm3510_bert_reset(struct bcm3510_state *st)\n{\n\tbcm3510_register_value b;\n\tint ret;\n\n\tif ((ret = bcm3510_readB(st,0xfa,&b)) < 0)\n\t\treturn ret;\n\n\tb.BERCTL_fa.RESYNC = 0; bcm3510_writeB(st,0xfa,b);\n\tb.BERCTL_fa.RESYNC = 1; bcm3510_writeB(st,0xfa,b);\n\tb.BERCTL_fa.RESYNC = 0; bcm3510_writeB(st,0xfa,b);\n\tb.BERCTL_fa.CNTCTL = 1; b.BERCTL_fa.BITCNT = 1; bcm3510_writeB(st,0xfa,b);\n\n\t \n\treturn 0;\n}\n\nstatic int bcm3510_refresh_state(struct bcm3510_state *st)\n{\n\tif (time_after(jiffies,st->next_status_check)) {\n\t\tbcm3510_do_hab_cmd(st, CMD_STATUS, MSGID_STATUS1, NULL,0, (u8 *)&st->status1, sizeof(st->status1));\n\t\tbcm3510_do_hab_cmd(st, CMD_STATUS, MSGID_STATUS2, NULL,0, (u8 *)&st->status2, sizeof(st->status2));\n\t\tst->next_status_check = jiffies + (st->status_check_interval*HZ)/1000;\n\t}\n\treturn 0;\n}\n\nstatic int bcm3510_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct bcm3510_state* st = fe->demodulator_priv;\n\tbcm3510_refresh_state(st);\n\n\t*status = 0;\n\tif (st->status1.STATUS1.RECEIVER_LOCK)\n\t\t*status |= FE_HAS_LOCK | FE_HAS_SYNC;\n\n\tif (st->status1.STATUS1.FEC_LOCK)\n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (st->status1.STATUS1.OUT_PLL_LOCK)\n\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\n\tif (*status & FE_HAS_LOCK)\n\t\tst->status_check_interval = 1500;\n\telse  \n\t\tst->status_check_interval = 500;\n\n\tdeb_info(\"real_status: %02x\\n\",*status);\n\treturn 0;\n}\n\nstatic int bcm3510_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct bcm3510_state* st = fe->demodulator_priv;\n\tbcm3510_refresh_state(st);\n\n\t*ber = (st->status2.LDBER0 << 16) | (st->status2.LDBER1 << 8) | st->status2.LDBER2;\n\treturn 0;\n}\n\nstatic int bcm3510_read_unc(struct dvb_frontend* fe, u32* unc)\n{\n\tstruct bcm3510_state* st = fe->demodulator_priv;\n\tbcm3510_refresh_state(st);\n\t*unc = (st->status2.LDUERC0 << 8) | st->status2.LDUERC1;\n\treturn 0;\n}\n\nstatic int bcm3510_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\tstruct bcm3510_state* st = fe->demodulator_priv;\n\ts32 t;\n\n\tbcm3510_refresh_state(st);\n\tt = st->status2.SIGNAL;\n\n\tif (t > 190)\n\t\tt = 190;\n\tif (t < 90)\n\t\tt = 90;\n\n\tt -= 90;\n\tt = t * 0xff / 100;\n\t \n\t*strength = (t << 8) | t;\n\treturn 0;\n}\n\nstatic int bcm3510_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct bcm3510_state* st = fe->demodulator_priv;\n\tbcm3510_refresh_state(st);\n\n\t*snr = st->status1.SNR_EST0*1000 + ((st->status1.SNR_EST1*1000) >> 8);\n\treturn 0;\n}\n\n \nstatic int bcm3510_tuner_cmd(struct bcm3510_state* st,u8 bc, u16 n, u8 a)\n{\n\tstruct bcm3510_hab_cmd_tune c;\n\tmemset(&c,0,sizeof(struct bcm3510_hab_cmd_tune));\n\n \n\tc.length = 0x10;\n\tc.clock_width = 0;\n \n\tc.misc = 0x10;\n \n\tc.TUNCTL_state = 0x40;\n\n \n\tc.ctl_dat[0].ctrl.size = BITS_8;\n\tc.ctl_dat[0].data      = 0x80 | bc;\n\n \n\tc.ctl_dat[1].ctrl.size = BITS_8;\n\tc.ctl_dat[1].data      = 4;\n\n \n\tc.ctl_dat[2].ctrl.size = BITS_3;\n\tc.ctl_dat[2].data      = 0x20;\n\n \n\tc.ctl_dat[3].ctrl.size = BITS_3;\n\tc.ctl_dat[3].ctrl.clk_off = 1;\n\tc.ctl_dat[3].ctrl.cs0  = 1;\n\tc.ctl_dat[3].data      = 0x40;\n\n \n\tc.ctl_dat[4].ctrl.size = BITS_8;\n\tc.ctl_dat[4].data      = n >> 3;\n\n \n\tc.ctl_dat[5].ctrl.size = BITS_8;\n\tc.ctl_dat[5].data      = ((n & 0x7) << 5) | (a >> 2);\n\n \n\tc.ctl_dat[6].ctrl.size = BITS_3;\n\tc.ctl_dat[6].data      = (a << 6) & 0xdf;\n\n \n\tc.ctl_dat[7].ctrl.size = BITS_3;\n\tc.ctl_dat[7].ctrl.clk_off = 1;\n\tc.ctl_dat[7].ctrl.cs0  = 1;\n\tc.ctl_dat[7].data      = 0x40;\n\n \n\tc.ctl_dat[8].ctrl.size = BITS_8;\n\tc.ctl_dat[8].data      = 0x80;\n\n \n\tc.ctl_dat[9].ctrl.size = BITS_8;\n\tc.ctl_dat[9].data      = 0x10;\n\n \n\tc.ctl_dat[10].ctrl.size = BITS_3;\n\tc.ctl_dat[10].data      = 0x20;\n\n \n\tc.ctl_dat[11].ctrl.size = BITS_3;\n\tc.ctl_dat[11].ctrl.clk_off = 1;\n\tc.ctl_dat[11].ctrl.cs1  = 1;\n\tc.ctl_dat[11].data      = 0x40;\n\n \n\tc.ctl_dat[12].ctrl.size = BITS_8;\n\tc.ctl_dat[12].data      = 0x2a;\n\n \n\tc.ctl_dat[13].ctrl.size = BITS_8;\n\tc.ctl_dat[13].data      = 0x8e;\n\n \n\tc.ctl_dat[14].ctrl.size = BITS_3;\n\tc.ctl_dat[14].data      = 0;\n\n \n\tc.ctl_dat[15].ctrl.size = BITS_3;\n\tc.ctl_dat[15].ctrl.clk_off = 1;\n\tc.ctl_dat[15].ctrl.cs1  = 1;\n\tc.ctl_dat[15].data      = 0x40;\n\n\treturn bcm3510_do_hab_cmd(st,CMD_TUNE, MSGID_TUNE,(u8 *) &c,sizeof(c), NULL, 0);\n}\n\nstatic int bcm3510_set_freq(struct bcm3510_state* st,u32 freq)\n{\n\tu8 bc,a;\n\tu16 n;\n\ts32 YIntercept,Tfvco1;\n\n\tfreq /= 1000;\n\n\tdeb_info(\"%dkHz:\",freq);\n\t \n\tif (freq <= 168000)\n\t\tbc = 0x1c;\n\telse if (freq <= 378000)\n\t\tbc = 0x2c;\n\telse\n\t\tbc = 0x30;\n\n\tif (freq >= 470000) {\n\t\tfreq -= 470001;\n\t\tYIntercept = 18805;\n\t} else if (freq >= 90000) {\n\t\tfreq -= 90001;\n\t\tYIntercept = 15005;\n\t} else if (freq >= 76000){\n\t\tfreq -= 76001;\n\t\tYIntercept = 14865;\n\t} else {\n\t\tfreq -= 54001;\n\t\tYIntercept = 14645;\n\t}\n\n\tTfvco1 = (((freq/6000)*60 + YIntercept)*4)/10;\n\n\tn = Tfvco1 >> 6;\n\ta = Tfvco1 & 0x3f;\n\n\tdeb_info(\" BC1_2_3_4: %x, N: %x A: %x\\n\", bc, n, a);\n\tif (n >= 16 && n <= 2047)\n\t\treturn bcm3510_tuner_cmd(st,bc,n,a);\n\n\treturn -EINVAL;\n}\n\nstatic int bcm3510_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct bcm3510_state* st = fe->demodulator_priv;\n\tstruct bcm3510_hab_cmd_ext_acquire cmd;\n\tstruct bcm3510_hab_cmd_bert_control bert;\n\tint ret;\n\n\tmemset(&cmd,0,sizeof(cmd));\n\tswitch (c->modulation) {\n\t\tcase QAM_256:\n\t\t\tcmd.ACQUIRE0.MODE = 0x1;\n\t\t\tcmd.ACQUIRE1.SYM_RATE = 0x1;\n\t\t\tcmd.ACQUIRE1.IF_FREQ = 0x1;\n\t\t\tbreak;\n\t\tcase QAM_64:\n\t\t\tcmd.ACQUIRE0.MODE = 0x2;\n\t\t\tcmd.ACQUIRE1.SYM_RATE = 0x2;\n\t\t\tcmd.ACQUIRE1.IF_FREQ = 0x1;\n\t\t\tbreak;\n#if 0\n\t\tcase QAM_256:\n\t\t\tcmd.ACQUIRE0.MODE = 0x3;\n\t\t\tbreak;\n\t\tcase QAM_128:\n\t\t\tcmd.ACQUIRE0.MODE = 0x4;\n\t\t\tbreak;\n\t\tcase QAM_64:\n\t\t\tcmd.ACQUIRE0.MODE = 0x5;\n\t\t\tbreak;\n\t\tcase QAM_32:\n\t\t\tcmd.ACQUIRE0.MODE = 0x6;\n\t\t\tbreak;\n\t\tcase QAM_16:\n\t\t\tcmd.ACQUIRE0.MODE = 0x7;\n\t\t\tbreak;\n#endif\n\t\tcase VSB_8:\n\t\t\tcmd.ACQUIRE0.MODE = 0x8;\n\t\t\tcmd.ACQUIRE1.SYM_RATE = 0x0;\n\t\t\tcmd.ACQUIRE1.IF_FREQ = 0x0;\n\t\t\tbreak;\n\t\tcase VSB_16:\n\t\t\tcmd.ACQUIRE0.MODE = 0x9;\n\t\t\tcmd.ACQUIRE1.SYM_RATE = 0x0;\n\t\t\tcmd.ACQUIRE1.IF_FREQ = 0x0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\tcmd.ACQUIRE0.OFFSET = 0;\n\tcmd.ACQUIRE0.NTSCSWEEP = 1;\n\tcmd.ACQUIRE0.FA = 1;\n\tcmd.ACQUIRE0.BW = 0;\n\n \n\tbcm3510_do_hab_cmd(st, CMD_ACQUIRE, MSGID_EXT_TUNER_ACQUIRE, (u8 *) &cmd, sizeof(cmd), NULL, 0);\n\n \n\tbert.BE = 0;\n\tbert.unused = 0;\n\tbcm3510_do_hab_cmd(st, CMD_STATE_CONTROL, MSGID_BERT_CONTROL, (u8 *) &bert, sizeof(bert), NULL, 0);\n\tbcm3510_do_hab_cmd(st, CMD_STATE_CONTROL, MSGID_BERT_SET, (u8 *) &bert, sizeof(bert), NULL, 0);\n\n\tbcm3510_bert_reset(st);\n\n\tret = bcm3510_set_freq(st, c->frequency);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemset(&st->status1,0,sizeof(st->status1));\n\tmemset(&st->status2,0,sizeof(st->status2));\n\tst->status_check_interval = 500;\n\n \n\tmsleep(200);\n\n\treturn 0;\n}\n\nstatic int bcm3510_sleep(struct dvb_frontend* fe)\n{\n\treturn 0;\n}\n\nstatic int bcm3510_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings *s)\n{\n\ts->min_delay_ms = 1000;\n\ts->step_size = 0;\n\ts->max_drift = 0;\n\treturn 0;\n}\n\nstatic void bcm3510_release(struct dvb_frontend* fe)\n{\n\tstruct bcm3510_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\n \n#define BCM3510_DEFAULT_FIRMWARE \"dvb-fe-bcm3510-01.fw\"\n\nstatic int bcm3510_write_ram(struct bcm3510_state *st, u16 addr, const u8 *b,\n\t\t\t     u16 len)\n{\n\tint ret = 0,i;\n\tbcm3510_register_value vH, vL,vD;\n\n\tvH.MADRH_a9 = addr >> 8;\n\tvL.MADRL_aa = addr;\n\tif ((ret = bcm3510_writeB(st,0xa9,vH)) < 0) return ret;\n\tif ((ret = bcm3510_writeB(st,0xaa,vL)) < 0) return ret;\n\n\tfor (i = 0; i < len; i++) {\n\t\tvD.MDATA_ab = b[i];\n\t\tif ((ret = bcm3510_writeB(st,0xab,vD)) < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm3510_download_firmware(struct dvb_frontend* fe)\n{\n\tstruct bcm3510_state* st = fe->demodulator_priv;\n\tconst struct firmware *fw;\n\tu16 addr,len;\n\tconst u8 *b;\n\tint ret,i;\n\n\tdeb_info(\"requesting firmware\\n\");\n\tif ((ret = st->config->request_firmware(fe, &fw, BCM3510_DEFAULT_FIRMWARE)) < 0) {\n\t\terr(\"could not load firmware (%s): %d\",BCM3510_DEFAULT_FIRMWARE,ret);\n\t\treturn ret;\n\t}\n\tdeb_info(\"got firmware: %zu\\n\", fw->size);\n\n\tb = fw->data;\n\tfor (i = 0; i < fw->size;) {\n\t\taddr = le16_to_cpu(*((__le16 *)&b[i]));\n\t\tlen  = le16_to_cpu(*((__le16 *)&b[i+2]));\n\t\tdeb_info(\"firmware chunk, addr: 0x%04x, len: 0x%04x, total length: 0x%04zx\\n\",addr,len,fw->size);\n\t\tif ((ret = bcm3510_write_ram(st,addr,&b[i+4],len)) < 0) {\n\t\t\terr(\"firmware download failed: %d\\n\",ret);\n\t\t\trelease_firmware(fw);\n\t\t\treturn ret;\n\t\t}\n\t\ti += 4 + len;\n\t}\n\trelease_firmware(fw);\n\tdeb_info(\"firmware download successfully completed\\n\");\n\treturn 0;\n}\n\nstatic int bcm3510_check_firmware_version(struct bcm3510_state *st)\n{\n\tstruct bcm3510_hab_cmd_get_version_info ver;\n\tbcm3510_do_hab_cmd(st,CMD_GET_VERSION_INFO,MSGID_GET_VERSION_INFO,NULL,0,(u8*)&ver,sizeof(ver));\n\n\tdeb_info(\"Version information: 0x%02x 0x%02x 0x%02x 0x%02x\\n\",\n\t\tver.microcode_version, ver.script_version, ver.config_version, ver.demod_version);\n\n\tif (ver.script_version == BCM3510_DEF_SCRIPT_VERSION &&\n\t\tver.config_version == BCM3510_DEF_CONFIG_VERSION &&\n\t\tver.demod_version  == BCM3510_DEF_DEMOD_VERSION)\n\t\treturn 0;\n\n\tdeb_info(\"version check failed\\n\");\n\treturn -ENODEV;\n}\n\n \nstatic int bcm3510_reset(struct bcm3510_state *st)\n{\n\tint ret;\n\tunsigned long  t;\n\tbcm3510_register_value v;\n\n\tbcm3510_readB(st,0xa0,&v); v.HCTL1_a0.RESET = 1;\n\tif ((ret = bcm3510_writeB(st,0xa0,v)) < 0)\n\t\treturn ret;\n\n\tt = jiffies + 3*HZ;\n\twhile (time_before(jiffies, t)) {\n\t\tmsleep(10);\n\t\tif ((ret = bcm3510_readB(st,0xa2,&v)) < 0)\n\t\t\treturn ret;\n\n\t\tif (v.APSTAT1_a2.RESET)\n\t\t\treturn 0;\n\t}\n\tdeb_info(\"reset timed out\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int bcm3510_clear_reset(struct bcm3510_state *st)\n{\n\tbcm3510_register_value v;\n\tint ret;\n\tunsigned long t;\n\n\tv.raw = 0;\n\tif ((ret = bcm3510_writeB(st,0xa0,v)) < 0)\n\t\treturn ret;\n\n\tt = jiffies + 3*HZ;\n\twhile (time_before(jiffies, t)) {\n\t\tmsleep(10);\n\t\tif ((ret = bcm3510_readB(st,0xa2,&v)) < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!v.APSTAT1_a2.RESET)\n\t\t\treturn 0;\n\t}\n\tdeb_info(\"reset clear timed out\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int bcm3510_init_cold(struct bcm3510_state *st)\n{\n\tint ret;\n\tbcm3510_register_value v;\n\n\t \n\tif ((ret = bcm3510_readB(st,0xa2,&v)) < 0)\n\t\treturn ret;\n\tif (v.APSTAT1_a2.RUN) {\n\t\tdeb_info(\"AP is already running - firmware already loaded.\\n\");\n\t\treturn 0;\n\t}\n\n\tdeb_info(\"reset?\\n\");\n\tif ((ret = bcm3510_reset(st)) < 0)\n\t\treturn ret;\n\n\tdeb_info(\"tristate?\\n\");\n\t \n\tv.TSTCTL_2e.CTL = 0;\n\tif ((ret = bcm3510_writeB(st,0x2e,v)) < 0)\n\t\treturn ret;\n\n\tdeb_info(\"firmware?\\n\");\n\tif ((ret = bcm3510_download_firmware(&st->frontend)) < 0 ||\n\t\t(ret = bcm3510_clear_reset(st)) < 0)\n\t\treturn ret;\n\n\t \n\n\treturn 0;\n}\n\nstatic int bcm3510_init(struct dvb_frontend* fe)\n{\n\tstruct bcm3510_state* st = fe->demodulator_priv;\n\tbcm3510_register_value j;\n\tstruct bcm3510_hab_cmd_set_agc c;\n\tint ret;\n\n\tif ((ret = bcm3510_readB(st,0xca,&j)) < 0)\n\t\treturn ret;\n\n\tdeb_info(\"JDEC: %02x\\n\",j.raw);\n\n\tswitch (j.JDEC_ca.JDEC) {\n\t\tcase JDEC_WAIT_AT_RAM:\n\t\t\tdeb_info(\"attempting to download firmware\\n\");\n\t\t\tif ((ret = bcm3510_init_cold(st)) < 0)\n\t\t\t\treturn ret;\n\t\t\tfallthrough;\n\t\tcase JDEC_EEPROM_LOAD_WAIT:\n\t\t\tdeb_info(\"firmware is loaded\\n\");\n\t\t\tbcm3510_check_firmware_version(st);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t}\n\n\tmemset(&c,0,1);\n\tc.SEL = 1;\n\tbcm3510_do_hab_cmd(st,CMD_AUTO_PARAM,MSGID_SET_RF_AGC_SEL,(u8 *)&c,sizeof(c),NULL,0);\n\n\treturn 0;\n}\n\n\nstatic const struct dvb_frontend_ops bcm3510_ops;\n\nstruct dvb_frontend* bcm3510_attach(const struct bcm3510_config *config,\n\t\t\t\t   struct i2c_adapter *i2c)\n{\n\tstruct bcm3510_state* state = NULL;\n\tint ret;\n\tbcm3510_register_value v;\n\n\t \n\tstate = kzalloc(sizeof(struct bcm3510_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t \n\tmemcpy(&state->frontend.ops, &bcm3510_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\tmutex_init(&state->hab_mutex);\n\n\tif ((ret = bcm3510_readB(state,0xe0,&v)) < 0)\n\t\tgoto error;\n\n\tdeb_info(\"Revision: 0x%1x, Layer: 0x%1x.\\n\",v.REVID_e0.REV,v.REVID_e0.LAYER);\n\n\tif ((v.REVID_e0.REV != 0x1 && v.REVID_e0.LAYER != 0xb) &&  \n\t\t(v.REVID_e0.REV != 0x8 && v.REVID_e0.LAYER != 0x0))    \n\t\tgoto error;\n\n\tinfo(\"Revision: 0x%1x, Layer: 0x%1x.\",v.REVID_e0.REV,v.REVID_e0.LAYER);\n\n\tbcm3510_reset(state);\n\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(bcm3510_attach);\n\nstatic const struct dvb_frontend_ops bcm3510_ops = {\n\t.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },\n\t.info = {\n\t\t.name = \"Broadcom BCM3510 VSB/QAM frontend\",\n\t\t.frequency_min_hz =  54 * MHz,\n\t\t.frequency_max_hz = 803 * MHz,\n\t\t.caps =\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_8VSB | FE_CAN_16VSB |\n\t\t\tFE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_128 | FE_CAN_QAM_256\n\t},\n\n\t.release = bcm3510_release,\n\n\t.init = bcm3510_init,\n\t.sleep = bcm3510_sleep,\n\n\t.set_frontend = bcm3510_set_frontend,\n\t.get_tune_settings = bcm3510_get_tune_settings,\n\n\t.read_status = bcm3510_read_status,\n\t.read_ber = bcm3510_read_ber,\n\t.read_signal_strength = bcm3510_read_signal_strength,\n\t.read_snr = bcm3510_read_snr,\n\t.read_ucblocks = bcm3510_read_unc,\n};\n\nMODULE_DESCRIPTION(\"Broadcom BCM3510 ATSC (8VSB/16VSB & ITU J83 AnnexB FEC QAM64/256) demodulator driver\");\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}