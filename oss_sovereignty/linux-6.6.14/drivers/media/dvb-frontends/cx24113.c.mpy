{
  "module_name": "cx24113.c",
  "hash_id": "9e3a0f55d881dfada18094801bece1e4ef4b27c948ccb04db6cc26183a14e49b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cx24113.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#include <media/dvb_frontend.h>\n#include \"cx24113.h\"\n\nstatic int debug;\n\n#define cx_info(args...) do { printk(KERN_INFO \"CX24113: \" args); } while (0)\n#define cx_err(args...)  do { printk(KERN_ERR  \"CX24113: \" args); } while (0)\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) { \\\n\t\t\tprintk(KERN_DEBUG \"CX24113: %s: \", __func__); \\\n\t\t\tprintk(args); \\\n\t\t} \\\n\t} while (0)\n\nstruct cx24113_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct cx24113_config *config;\n\n#define REV_CX24113 0x23\n\tu8 rev;\n\tu8 ver;\n\n\tu8 icp_mode:1;\n\n#define ICP_LEVEL1 0\n#define ICP_LEVEL2 1\n#define ICP_LEVEL3 2\n#define ICP_LEVEL4 3\n\tu8 icp_man:2;\n\tu8 icp_auto_low:2;\n\tu8 icp_auto_mlow:2;\n\tu8 icp_auto_mhi:2;\n\tu8 icp_auto_hi:2;\n\tu8 icp_dig;\n\n#define LNA_MIN_GAIN 0\n#define LNA_MID_GAIN 1\n#define LNA_MAX_GAIN 2\n\tu8 lna_gain:2;\n\n\tu8 acp_on:1;\n\n\tu8 vco_mode:2;\n\tu8 vco_shift:1;\n#define VCOBANDSEL_6 0x80\n#define VCOBANDSEL_5 0x01\n#define VCOBANDSEL_4 0x02\n#define VCOBANDSEL_3 0x04\n#define VCOBANDSEL_2 0x08\n#define VCOBANDSEL_1 0x10\n\tu8 vco_band;\n\n#define VCODIV4 4\n#define VCODIV2 2\n\tu8 vcodiv;\n\n\tu8 bs_delay:4;\n\tu16 bs_freqcnt:13;\n\tu16 bs_rdiv;\n\tu8 prescaler_mode:1;\n\n\tu8 rfvga_bias_ctrl;\n\n\ts16 tuner_gain_thres;\n\tu8  gain_level;\n\n\tu32 frequency;\n\n\tu8 refdiv;\n\n\tu8 Fwindow_enabled;\n};\n\nstatic int cx24113_writereg(struct cx24113_state *state, int reg, int data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->i2c_addr,\n\t\t.flags = 0, .buf = buf, .len = 2 };\n\tint err = i2c_transfer(state->i2c, &msg, 1);\n\tif (err != 1) {\n\t\tprintk(KERN_DEBUG \"%s: writereg error(err == %i, reg == 0x%02x, data == 0x%02x)\\n\",\n\t\t       __func__, err, reg, data);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int cx24113_readreg(struct cx24113_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b;\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->config->i2c_addr,\n\t\t\t.flags = 0, .buf = &reg, .len = 1 },\n\t\t{ .addr = state->config->i2c_addr,\n\t\t\t.flags = I2C_M_RD, .buf = &b, .len = 1 }\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\tprintk(KERN_DEBUG \"%s: reg=0x%x (error=%d)\\n\",\n\t\t\t__func__, reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn b;\n}\n\nstatic void cx24113_set_parameters(struct cx24113_state *state)\n{\n\tu8 r;\n\n\tr = cx24113_readreg(state, 0x10) & 0x82;\n\tr |= state->icp_mode;\n\tr |= state->icp_man << 4;\n\tr |= state->icp_dig << 2;\n\tr |= state->prescaler_mode << 5;\n\tcx24113_writereg(state, 0x10, r);\n\n\tr = (state->icp_auto_low  << 0) | (state->icp_auto_mlow << 2)\n\t\t| (state->icp_auto_mhi << 4) | (state->icp_auto_hi << 6);\n\tcx24113_writereg(state, 0x11, r);\n\n\tif (state->rev == REV_CX24113) {\n\t\tr = cx24113_readreg(state, 0x20) & 0xec;\n\t\tr |= state->lna_gain;\n\t\tr |= state->rfvga_bias_ctrl << 4;\n\t\tcx24113_writereg(state, 0x20, r);\n\t}\n\n\tr = cx24113_readreg(state, 0x12) & 0x03;\n\tr |= state->acp_on << 2;\n\tr |= state->bs_delay << 4;\n\tcx24113_writereg(state, 0x12, r);\n\n\tr = cx24113_readreg(state, 0x18) & 0x40;\n\tr |= state->vco_shift;\n\tif (state->vco_band == VCOBANDSEL_6)\n\t\tr |= (1 << 7);\n\telse\n\t\tr |= (state->vco_band << 1);\n\tcx24113_writereg(state, 0x18, r);\n\n\tr  = cx24113_readreg(state, 0x14) & 0x20;\n\tr |= (state->vco_mode << 6) | ((state->bs_freqcnt >> 8) & 0x1f);\n\tcx24113_writereg(state, 0x14, r);\n\tcx24113_writereg(state, 0x15, (state->bs_freqcnt        & 0xff));\n\n\tcx24113_writereg(state, 0x16, (state->bs_rdiv >> 4) & 0xff);\n\tr = (cx24113_readreg(state, 0x17) & 0x0f) |\n\t\t((state->bs_rdiv & 0x0f) << 4);\n\tcx24113_writereg(state, 0x17, r);\n}\n\n#define VGA_0 0x00\n#define VGA_1 0x04\n#define VGA_2 0x02\n#define VGA_3 0x06\n#define VGA_4 0x01\n#define VGA_5 0x05\n#define VGA_6 0x03\n#define VGA_7 0x07\n\n#define RFVGA_0 0x00\n#define RFVGA_1 0x01\n#define RFVGA_2 0x02\n#define RFVGA_3 0x03\n\nstatic int cx24113_set_gain_settings(struct cx24113_state *state,\n\t\ts16 power_estimation)\n{\n\tu8 ampout = cx24113_readreg(state, 0x1d) & 0xf0,\n\t   vga    = cx24113_readreg(state, 0x1f) & 0x3f,\n\t   rfvga  = cx24113_readreg(state, 0x20) & 0xf3;\n\tu8 gain_level = power_estimation >= state->tuner_gain_thres;\n\n\tdprintk(\"power estimation: %d, thres: %d, gain_level: %d/%d\\n\",\n\t\t\tpower_estimation, state->tuner_gain_thres,\n\t\t\tstate->gain_level, gain_level);\n\n\tif (gain_level == state->gain_level)\n\t\treturn 0;  \n\n\tampout |= 0xf;\n\n\tif (gain_level) {\n\t\trfvga |= RFVGA_0 << 2;\n\t\tvga   |= (VGA_7 << 3) | VGA_7;\n\t} else {\n\t\trfvga |= RFVGA_2 << 2;\n\t\tvga  |= (VGA_6 << 3) | VGA_2;\n\t}\n\tstate->gain_level = gain_level;\n\n\tcx24113_writereg(state, 0x1d, ampout);\n\tcx24113_writereg(state, 0x1f, vga);\n\tcx24113_writereg(state, 0x20, rfvga);\n\n\treturn 1;  \n}\n\nstatic int cx24113_set_Fref(struct cx24113_state *state, u8 high)\n{\n\tu8 xtal = cx24113_readreg(state, 0x02);\n\tif (state->rev == 0x43 && state->vcodiv == VCODIV4)\n\t\thigh = 1;\n\n\txtal &= ~0x2;\n\tif (high)\n\t\txtal |= high << 1;\n\treturn cx24113_writereg(state, 0x02, xtal);\n}\n\nstatic int cx24113_enable(struct cx24113_state *state, u8 enable)\n{\n\tu8 r21 = (cx24113_readreg(state, 0x21) & 0xc0) | enable;\n\tif (state->rev == REV_CX24113)\n\t\tr21 |= (1 << 1);\n\treturn cx24113_writereg(state, 0x21, r21);\n}\n\nstatic int cx24113_set_bandwidth(struct cx24113_state *state, u32 bandwidth_khz)\n{\n\tu8 r;\n\n\tif (bandwidth_khz <= 19000)\n\t\tr = 0x03 << 6;\n\telse if (bandwidth_khz <= 25000)\n\t\tr = 0x02 << 6;\n\telse\n\t\tr = 0x01 << 6;\n\n\tdprintk(\"bandwidth to be set: %d\\n\", bandwidth_khz);\n\tbandwidth_khz *= 10;\n\tbandwidth_khz -= 10000;\n\tbandwidth_khz /= 1000;\n\tbandwidth_khz += 5;\n\tbandwidth_khz /= 10;\n\n\tdprintk(\"bandwidth: %d %d\\n\", r >> 6, bandwidth_khz);\n\n\tr |= bandwidth_khz & 0x3f;\n\n\treturn cx24113_writereg(state, 0x1e, r);\n}\n\nstatic int cx24113_set_clk_inversion(struct cx24113_state *state, u8 on)\n{\n\tu8 r = (cx24113_readreg(state, 0x10) & 0x7f) | ((on & 0x1) << 7);\n\treturn cx24113_writereg(state, 0x10, r);\n}\n\nstatic int cx24113_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tstruct cx24113_state *state = fe->tuner_priv;\n\tu8 r = (cx24113_readreg(state, 0x10) & 0x02) >> 1;\n\tif (r)\n\t\t*status |= TUNER_STATUS_LOCKED;\n\tdprintk(\"PLL locked: %d\\n\", r);\n\treturn 0;\n}\n\nstatic u8 cx24113_set_ref_div(struct cx24113_state *state, u8 refdiv)\n{\n\tif (state->rev == 0x43 && state->vcodiv == VCODIV4)\n\t\trefdiv = 2;\n\treturn state->refdiv = refdiv;\n}\n\nstatic void cx24113_calc_pll_nf(struct cx24113_state *state, u16 *n, s32 *f)\n{\n\ts32 N;\n\ts64 F;\n\tu64 dividend;\n\tu8 R, r;\n\tu8 vcodiv;\n\tu8 factor;\n\ts32 freq_hz = state->frequency * 1000;\n\n\tif (state->config->xtal_khz < 20000)\n\t\tfactor = 1;\n\telse\n\t\tfactor = 2;\n\n\tif (state->rev == REV_CX24113) {\n\t\tif (state->frequency >= 1100000)\n\t\t\tvcodiv = VCODIV2;\n\t\telse\n\t\t\tvcodiv = VCODIV4;\n\t} else {\n\t\tif (state->frequency >= 1165000)\n\t\t\tvcodiv = VCODIV2;\n\t\telse\n\t\t\tvcodiv = VCODIV4;\n\t}\n\tstate->vcodiv = vcodiv;\n\n\tdprintk(\"calculating N/F for %dHz with vcodiv %d\\n\", freq_hz, vcodiv);\n\tR = 0;\n\tdo {\n\t\tR = cx24113_set_ref_div(state, R + 1);\n\n\t\t \n\t\tN =  (freq_hz / 100 * vcodiv) * R;\n\t\tN /= (state->config->xtal_khz) * factor * 2;\n\t\tN += 5;      \n\t\tN /= 10;\n\t\tN -= 32;\n\t} while (N < 6 && R < 3);\n\n\tif (N < 6) {\n\t\tcx_err(\"strange frequency: N < 6\\n\");\n\t\treturn;\n\t}\n\tF = freq_hz;\n\tF *= (u64) (R * vcodiv * 262144);\n\tdprintk(\"1 N: %d, F: %lld, R: %d\\n\", N, (long long)F, R);\n\t \n\tdividend = F;\n\tdo_div(dividend, state->config->xtal_khz * 1000 * factor * 2);\n\tF = dividend;\n\tdprintk(\"2 N: %d, F: %lld, R: %d\\n\", N, (long long)F, R);\n\tF -= (N + 32) * 262144;\n\n\tdprintk(\"3 N: %d, F: %lld, R: %d\\n\", N, (long long)F, R);\n\n\tif (state->Fwindow_enabled) {\n\t\tif (F > (262144 / 2 - 1638))\n\t\t\tF = 262144 / 2 - 1638;\n\t\tif (F < (-262144 / 2 + 1638))\n\t\t\tF = -262144 / 2 + 1638;\n\t\tif ((F < 3277 && F > 0) || (F > -3277 && F < 0)) {\n\t\t\tF = 0;\n\t\t\tr = cx24113_readreg(state, 0x10);\n\t\t\tcx24113_writereg(state, 0x10, r | (1 << 6));\n\t\t}\n\t}\n\tdprintk(\"4 N: %d, F: %lld, R: %d\\n\", N, (long long)F, R);\n\n\t*n = (u16) N;\n\t*f = (s32) F;\n}\n\n\nstatic void cx24113_set_nfr(struct cx24113_state *state, u16 n, s32 f, u8 r)\n{\n\tu8 reg;\n\tcx24113_writereg(state, 0x19, (n >> 1) & 0xff);\n\n\treg = ((n & 0x1) << 7) | ((f >> 11) & 0x7f);\n\tcx24113_writereg(state, 0x1a, reg);\n\n\tcx24113_writereg(state, 0x1b, (f >> 3) & 0xff);\n\n\treg = cx24113_readreg(state, 0x1c) & 0x1f;\n\tcx24113_writereg(state, 0x1c, reg | ((f & 0x7) << 5));\n\n\tcx24113_set_Fref(state, r - 1);\n}\n\nstatic int cx24113_set_frequency(struct cx24113_state *state, u32 frequency)\n{\n\tu8 r;\n\tu16 n = 6;\n\ts32 f = 0;\n\n\tr = cx24113_readreg(state, 0x14);\n\tcx24113_writereg(state, 0x14, r & 0x3f);\n\n\tr = cx24113_readreg(state, 0x10);\n\tcx24113_writereg(state, 0x10, r & 0xbf);\n\n\tstate->frequency = frequency;\n\n\tdprintk(\"tuning to frequency: %d\\n\", frequency);\n\n\tcx24113_calc_pll_nf(state, &n, &f);\n\tcx24113_set_nfr(state, n, f, state->refdiv);\n\n\tr = cx24113_readreg(state, 0x18) & 0xbf;\n\tif (state->vcodiv != VCODIV2)\n\t\tr |= 1 << 6;\n\tcx24113_writereg(state, 0x18, r);\n\n\t \n\tmsleep(5);\n\n\tr = cx24113_readreg(state, 0x1c) & 0xef;\n\tcx24113_writereg(state, 0x1c, r | (1 << 4));\n\treturn 0;\n}\n\nstatic int cx24113_init(struct dvb_frontend *fe)\n{\n\tstruct cx24113_state *state = fe->tuner_priv;\n\tint ret;\n\n\tstate->tuner_gain_thres = -50;\n\tstate->gain_level = 255;  \n\tstate->icp_mode = 0;\n\n\tif (state->config->xtal_khz < 11000) {\n\t\tstate->icp_auto_hi  = ICP_LEVEL4;\n\t\tstate->icp_auto_mhi  = ICP_LEVEL4;\n\t\tstate->icp_auto_mlow = ICP_LEVEL3;\n\t\tstate->icp_auto_low = ICP_LEVEL3;\n\t} else {\n\t\tstate->icp_auto_hi  = ICP_LEVEL4;\n\t\tstate->icp_auto_mhi  = ICP_LEVEL4;\n\t\tstate->icp_auto_mlow = ICP_LEVEL3;\n\t\tstate->icp_auto_low = ICP_LEVEL2;\n\t}\n\n\tstate->icp_dig = ICP_LEVEL3;\n\tstate->icp_man = ICP_LEVEL1;\n\tstate->acp_on  = 1;\n\tstate->vco_mode = 0;\n\tstate->vco_shift = 0;\n\tstate->vco_band = VCOBANDSEL_1;\n\tstate->bs_delay = 8;\n\tstate->bs_freqcnt = 0x0fff;\n\tstate->bs_rdiv = 0x0fff;\n\tstate->prescaler_mode = 0;\n\tstate->lna_gain = LNA_MAX_GAIN;\n\tstate->rfvga_bias_ctrl = 1;\n\tstate->Fwindow_enabled = 1;\n\n\tcx24113_set_Fref(state, 0);\n\tcx24113_enable(state, 0x3d);\n\tcx24113_set_parameters(state);\n\n\tcx24113_set_gain_settings(state, -30);\n\n\tcx24113_set_bandwidth(state, 18025);\n\tcx24113_set_clk_inversion(state, 1);\n\n\tif (state->config->xtal_khz >= 40000)\n\t\tret = cx24113_writereg(state, 0x02,\n\t\t\t(cx24113_readreg(state, 0x02) & 0xfb) | (1 << 2));\n\telse\n\t\tret = cx24113_writereg(state, 0x02,\n\t\t\t(cx24113_readreg(state, 0x02) & 0xfb) | (0 << 2));\n\n\treturn ret;\n}\n\nstatic int cx24113_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct cx24113_state *state = fe->tuner_priv;\n\t \n\tu32 roll_off = 675;\n\tu32 bw;\n\n\tbw  = ((c->symbol_rate/100) * roll_off) / 1000;\n\tbw += (10000000/100) + 5;\n\tbw /= 10;\n\tbw += 1000;\n\tcx24113_set_bandwidth(state, bw);\n\n\tcx24113_set_frequency(state, c->frequency);\n\tmsleep(5);\n\treturn cx24113_get_status(fe, &bw);\n}\n\nstatic s8 cx24113_agc_table[2][10] = {\n\t{-54, -41, -35, -30, -25, -21, -16, -10,  -6,  -2},\n\t{-39, -35, -30, -25, -19, -15, -11,  -5,   1,   9},\n};\n\nvoid cx24113_agc_callback(struct dvb_frontend *fe)\n{\n\tstruct cx24113_state *state = fe->tuner_priv;\n\ts16 s, i;\n\tif (!fe->ops.read_signal_strength)\n\t\treturn;\n\n\tdo {\n\t\t \n\t\tfe->ops.read_signal_strength(fe, (u16 *) &s);\n\t\ts >>= 8;\n\t\tdprintk(\"signal strength: %d\\n\", s);\n\t\tfor (i = 0; i < sizeof(cx24113_agc_table[0]); i++)\n\t\t\tif (cx24113_agc_table[state->gain_level][i] > s)\n\t\t\t\tbreak;\n\t\ts = -25 - i*5;\n\t} while (cx24113_set_gain_settings(state, s));\n}\nEXPORT_SYMBOL(cx24113_agc_callback);\n\nstatic int cx24113_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct cx24113_state *state = fe->tuner_priv;\n\t*frequency = state->frequency;\n\treturn 0;\n}\n\nstatic void cx24113_release(struct dvb_frontend *fe)\n{\n\tstruct cx24113_state *state = fe->tuner_priv;\n\tdprintk(\"\\n\");\n\tfe->tuner_priv = NULL;\n\tkfree(state);\n}\n\nstatic const struct dvb_tuner_ops cx24113_tuner_ops = {\n\t.info = {\n\t\t.name              = \"Conexant CX24113\",\n\t\t.frequency_min_hz  =  950 * MHz,\n\t\t.frequency_max_hz  = 2150 * MHz,\n\t\t.frequency_step_hz =  125 * kHz,\n\t},\n\n\t.release       = cx24113_release,\n\n\t.init          = cx24113_init,\n\n\t.set_params    = cx24113_set_params,\n\t.get_frequency = cx24113_get_frequency,\n\t.get_status    = cx24113_get_status,\n};\n\nstruct dvb_frontend *cx24113_attach(struct dvb_frontend *fe,\n\t\tconst struct cx24113_config *config, struct i2c_adapter *i2c)\n{\n\t \n\tstruct cx24113_state *state = kzalloc(sizeof(*state), GFP_KERNEL);\n\tint rc;\n\n\tif (!state)\n\t\treturn NULL;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\tcx_info(\"trying to detect myself\\n\");\n\n\t \n\tcx24113_readreg(state, 0x00);\n\n\trc = cx24113_readreg(state, 0x00);\n\tif (rc < 0) {\n\t\tcx_info(\"CX24113 not found.\\n\");\n\t\tgoto error;\n\t}\n\tstate->rev = rc;\n\n\tswitch (rc) {\n\tcase 0x43:\n\t\tcx_info(\"detected CX24113 variant\\n\");\n\t\tbreak;\n\tcase REV_CX24113:\n\t\tcx_info(\"successfully detected\\n\");\n\t\tbreak;\n\tdefault:\n\t\tcx_err(\"unsupported device id: %x\\n\", state->rev);\n\t\tgoto error;\n\t}\n\tstate->ver = cx24113_readreg(state, 0x01);\n\tcx_info(\"version: %x\\n\", state->ver);\n\n\t \n\tmemcpy(&fe->ops.tuner_ops, &cx24113_tuner_ops,\n\t\t\tsizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = state;\n\treturn fe;\n\nerror:\n\tkfree(state);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cx24113_attach);\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Activates frontend debugging (default:0)\");\n\nMODULE_AUTHOR(\"Patrick Boettcher <pb@linuxtv.org>\");\nMODULE_DESCRIPTION(\"DVB Frontend module for Conexant CX24113/CX24128hardware\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}