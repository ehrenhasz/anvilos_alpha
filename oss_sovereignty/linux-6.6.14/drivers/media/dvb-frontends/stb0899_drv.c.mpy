{
  "module_name": "stb0899_drv.c",
  "hash_id": "e65f0c33658c42d0d598726f1872894082948df5d34400045f0e6d111e8c77eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stb0899_drv.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <linux/dvb/frontend.h>\n#include <media/dvb_frontend.h>\n\n#include \"stb0899_drv.h\"\n#include \"stb0899_priv.h\"\n#include \"stb0899_reg.h\"\n\n \n#define MAX_XFER_SIZE  64\n\nstatic unsigned int verbose = 0;\nmodule_param(verbose, int, 0644);\n\n \nstatic const struct stb0899_tab stb0899_cn_tab[] = {\n\t{ 200,\t2600 },\n\t{ 190,\t2700 },\n\t{ 180,\t2860 },\n\t{ 170,\t3020 },\n\t{ 160,\t3210 },\n\t{ 150,\t3440 },\n\t{ 140,\t3710 },\n\t{ 130,\t4010 },\n\t{ 120,\t4360 },\n\t{ 110,\t4740 },\n\t{ 100,\t5190 },\n\t{ 90,\t5670 },\n\t{ 80,\t6200 },\n\t{ 70,\t6770 },\n\t{ 60,\t7360 },\n\t{ 50,\t7970 },\n\t{ 40,\t8250 },\n\t{ 30,\t9000 },\n\t{ 20,\t9450 },\n\t{ 15,\t9600 },\n};\n\n \nstatic const struct stb0899_tab stb0899_dvbsrf_tab[] = {\n\t{ -750,\t-128 },\n\t{ -748,\t -94 },\n\t{ -745,\t -92 },\n\t{ -735,\t -90 },\n\t{ -720,\t -87 },\n\t{ -670,\t -77 },\n\t{ -640,\t -70 },\n\t{ -610,\t -62 },\n\t{ -600,\t -60 },\n\t{ -590,\t -56 },\n\t{ -560,\t -41 },\n\t{ -540,\t -25 },\n\t{ -530,\t -17 },\n\t{ -520,\t -11 },\n\t{ -500,\t   1 },\n\t{ -490,\t   6 },\n\t{ -480,\t  10 },\n\t{ -440,\t  22 },\n\t{ -420,\t  27 },\n\t{ -400,\t  31 },\n\t{ -380,\t  34 },\n\t{ -340,\t  40 },\n\t{ -320,\t  43 },\n\t{ -280,\t  48 },\n\t{ -250,\t  52 },\n\t{ -230,\t  55 },\n\t{ -180,\t  61 },\n\t{ -140,\t  66 },\n\t{  -90,\t  73 },\n\t{  -80,\t  74 },\n\t{  500,\t 127 }\n};\n\n \nstatic const struct stb0899_tab stb0899_dvbs2rf_tab[] = {\n\t{  700,\t    0 },\n\t{  -80,\t 3217 },\n\t{ -150,\t 3893 },\n\t{ -190,\t 4217 },\n\t{ -240,\t 4621 },\n\t{ -280,\t 4945 },\n\t{ -320,\t 5273 },\n\t{ -350,\t 5545 },\n\t{ -370,\t 5741 },\n\t{ -410,\t 6147 },\n\t{ -450,\t 6671 },\n\t{ -490,\t 7413 },\n\t{ -501,\t 7665 },\n\t{ -530,\t 8767 },\n\t{ -560,\t10219 },\n\t{ -580,\t10939 },\n\t{ -590,\t11518 },\n\t{ -600,\t11723 },\n\t{ -650,\t12659 },\n\t{ -690,\t13219 },\n\t{ -730,\t13645 },\n\t{ -750,\t13909 },\n\t{ -766,\t14153 },\n\t{ -950,\t16383 }\n};\n\n \nstatic struct stb0899_tab stb0899_quant_tab[] = {\n\t{    0,\t    0 },\n\t{    0,\t  100 },\n\t{  600,\t  200 },\n\t{  950,\t  299 },\n\t{ 1200,\t  398 },\n\t{ 1400,\t  501 },\n\t{ 1560,\t  603 },\n\t{ 1690,\t  700 },\n\t{ 1810,\t  804 },\n\t{ 1910,\t  902 },\n\t{ 2000,\t 1000 },\n\t{ 2080,\t 1096 },\n\t{ 2160,\t 1202 },\n\t{ 2230,\t 1303 },\n\t{ 2350,\t 1496 },\n\t{ 2410,\t 1603 },\n\t{ 2460,\t 1698 },\n\t{ 2510,\t 1799 },\n\t{ 2600,\t 1995 },\n\t{ 2650,\t 2113 },\n\t{ 2690,  2213 },\n\t{ 2720,\t 2291 },\n\t{ 2760,\t 2399 },\n\t{ 2800,\t 2512 },\n\t{ 2860,\t 2692 },\n\t{ 2930,\t 2917 },\n\t{ 2960,\t 3020 },\n\t{ 3010,\t 3199 },\n\t{ 3040,\t 3311 },\n\t{ 3060,\t 3388 },\n\t{ 3120,\t 3631 },\n\t{ 3190,\t 3936 },\n\t{ 3400,\t 5012 },\n\t{ 3610,\t 6383 },\n\t{ 3800,\t 7943 },\n\t{ 4210,\t12735 },\n\t{ 4500,\t17783 },\n\t{ 4690,\t22131 },\n\t{ 4810,\t25410 }\n};\n\n \nstatic struct stb0899_tab stb0899_est_tab[] = {\n\t{    0,\t     0 },\n\t{    0,\t     1 },\n\t{  301,\t     2 },\n\t{ 1204,\t    16 },\n\t{ 1806,\t    64 },\n\t{ 2408,\t   256 },\n\t{ 2709,\t   512 },\n\t{ 3010,\t  1023 },\n\t{ 3311,\t  2046 },\n\t{ 3612,\t  4093 },\n\t{ 3823,\t  6653 },\n\t{ 3913,\t  8185 },\n\t{ 4010,\t 10233 },\n\t{ 4107,\t 12794 },\n\t{ 4214,\t 16368 },\n\t{ 4266,\t 18450 },\n\t{ 4311,\t 20464 },\n\t{ 4353,\t 22542 },\n\t{ 4391,\t 24604 },\n\t{ 4425,\t 26607 },\n\t{ 4457,\t 28642 },\n\t{ 4487,\t 30690 },\n\t{ 4515,\t 32734 },\n\t{ 4612,\t 40926 },\n\t{ 4692,\t 49204 },\n\t{ 4816,\t 65464 },\n\t{ 4913,\t 81846 },\n\t{ 4993,\t 98401 },\n\t{ 5060,\t114815 },\n\t{ 5118,\t131220 },\n\t{ 5200,\t158489 },\n\t{ 5300,\t199526 },\n\t{ 5400,\t251189 },\n\t{ 5500,\t316228 },\n\t{ 5600,\t398107 },\n\t{ 5720,\t524807 },\n\t{ 5721,\t526017 },\n};\n\nstatic int _stb0899_read_reg(struct stb0899_state *state, unsigned int reg)\n{\n\tint ret;\n\n\tu8 b0[] = { reg >> 8, reg & 0xff };\n\tu8 buf;\n\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= state->config->demod_address,\n\t\t\t.flags\t= 0,\n\t\t\t.buf\t= b0,\n\t\t\t.len\t= 2\n\t\t},{\n\t\t\t.addr\t= state->config->demod_address,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.buf\t= &buf,\n\t\t\t.len\t= 1\n\t\t}\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\tif (ret != 2) {\n\t\tif (ret != -ERESTARTSYS)\n\t\t\tdprintk(state->verbose, FE_ERROR, 1,\n\t\t\t\t\"Read error, Reg=[0x%02x], Status=%d\",\n\t\t\t\treg, ret);\n\n\t\treturn ret < 0 ? ret : -EREMOTEIO;\n\t}\n\tif (unlikely(*state->verbose >= FE_DEBUGREG))\n\t\tdprintk(state->verbose, FE_ERROR, 1, \"Reg=[0x%02x], data=%02x\",\n\t\t\treg, buf);\n\n\treturn (unsigned int)buf;\n}\n\nint stb0899_read_reg(struct stb0899_state *state, unsigned int reg)\n{\n\tint result;\n\n\tresult = _stb0899_read_reg(state, reg);\n\t \n\tif ((reg != 0xf2ff) && (reg != 0xf6ff) &&\n\t    (((reg & 0xff00) == 0xf200) || ((reg & 0xff00) == 0xf600)))\n\t\t_stb0899_read_reg(state, (reg | 0x00ff));\n\n\treturn result;\n}\n\nu32 _stb0899_read_s2reg(struct stb0899_state *state,\n\t\t\tu32 stb0899_i2cdev,\n\t\t\tu32 stb0899_base_addr,\n\t\t\tu16 stb0899_reg_offset)\n{\n\tint status;\n\tu32 data;\n\tu8 buf[7] = { 0 };\n\tu16 tmpaddr;\n\n\tu8 buf_0[] = {\n\t\tGETBYTE(stb0899_i2cdev, BYTE1),\t\t \n\t\tGETBYTE(stb0899_i2cdev, BYTE0),\t\t \n\t\tGETBYTE(stb0899_base_addr, BYTE0),\t \n\t\tGETBYTE(stb0899_base_addr, BYTE1),\t \n\t\tGETBYTE(stb0899_base_addr, BYTE2),\t \n\t\tGETBYTE(stb0899_base_addr, BYTE3),\t \n\t};\n\tu8 buf_1[] = {\n\t\t0x00,\t \n\t\t0x00,\t \n\t};\n\n\tstruct i2c_msg msg_0 = {\n\t\t.addr\t= state->config->demod_address,\n\t\t.flags\t= 0,\n\t\t.buf\t= buf_0,\n\t\t.len\t= 6\n\t};\n\n\tstruct i2c_msg msg_1 = {\n\t\t.addr\t= state->config->demod_address,\n\t\t.flags\t= 0,\n\t\t.buf\t= buf_1,\n\t\t.len\t= 2\n\t};\n\n\tstruct i2c_msg msg_r = {\n\t\t.addr\t= state->config->demod_address,\n\t\t.flags\t= I2C_M_RD,\n\t\t.buf\t= buf,\n\t\t.len\t= 4\n\t};\n\n\ttmpaddr = stb0899_reg_offset & 0xff00;\n\tif (!(stb0899_reg_offset & 0x8))\n\t\ttmpaddr = stb0899_reg_offset | 0x20;\n\n\tbuf_1[0] = GETBYTE(tmpaddr, BYTE1);\n\tbuf_1[1] = GETBYTE(tmpaddr, BYTE0);\n\n\tstatus = i2c_transfer(state->i2c, &msg_0, 1);\n\tif (status < 1) {\n\t\tif (status != -ERESTARTSYS)\n\t\t\tprintk(KERN_ERR \"%s ERR(1), Device=[0x%04x], Base address=[0x%08x], Offset=[0x%04x], Status=%d\\n\",\n\t\t\t       __func__, stb0899_i2cdev, stb0899_base_addr, stb0899_reg_offset, status);\n\n\t\tgoto err;\n\t}\n\n\t \n\tstatus = i2c_transfer(state->i2c, &msg_1, 1);\n\tif (status < 1)\n\t\tgoto err;\n\n\tstatus = i2c_transfer(state->i2c, &msg_r, 1);\n\tif (status < 1)\n\t\tgoto err;\n\n\tbuf_1[0] = GETBYTE(stb0899_reg_offset, BYTE1);\n\tbuf_1[1] = GETBYTE(stb0899_reg_offset, BYTE0);\n\n\t \n\tstatus = i2c_transfer(state->i2c, &msg_1, 1);\n\tif (status < 1) {\n\t\tif (status != -ERESTARTSYS)\n\t\t\tprintk(KERN_ERR \"%s ERR(2), Device=[0x%04x], Base address=[0x%08x], Offset=[0x%04x], Status=%d\\n\",\n\t\t\t       __func__, stb0899_i2cdev, stb0899_base_addr, stb0899_reg_offset, status);\n\t\tgoto err;\n\t}\n\n\tstatus = i2c_transfer(state->i2c, &msg_r, 1);\n\tif (status < 1) {\n\t\tif (status != -ERESTARTSYS)\n\t\t\tprintk(KERN_ERR \"%s ERR(3), Device=[0x%04x], Base address=[0x%08x], Offset=[0x%04x], Status=%d\\n\",\n\t\t\t       __func__, stb0899_i2cdev, stb0899_base_addr, stb0899_reg_offset, status);\n\t\treturn status < 0 ? status : -EREMOTEIO;\n\t}\n\n\tdata = MAKEWORD32(buf[3], buf[2], buf[1], buf[0]);\n\tif (unlikely(*state->verbose >= FE_DEBUGREG))\n\t\tprintk(KERN_DEBUG \"%s Device=[0x%04x], Base address=[0x%08x], Offset=[0x%04x], Data=[0x%08x]\\n\",\n\t\t       __func__, stb0899_i2cdev, stb0899_base_addr, stb0899_reg_offset, data);\n\n\treturn data;\n\nerr:\n\treturn status < 0 ? status : -EREMOTEIO;\n}\n\nint stb0899_write_s2reg(struct stb0899_state *state,\n\t\t\tu32 stb0899_i2cdev,\n\t\t\tu32 stb0899_base_addr,\n\t\t\tu16 stb0899_reg_offset,\n\t\t\tu32 stb0899_data)\n{\n\tint status;\n\n\t \n\tu8 buf_0[] = {\n\t\tGETBYTE(stb0899_i2cdev, BYTE1),\t\t \n\t\tGETBYTE(stb0899_i2cdev, BYTE0),\t\t \n\t\tGETBYTE(stb0899_base_addr, BYTE0),\t \n\t\tGETBYTE(stb0899_base_addr, BYTE1),\t \n\t\tGETBYTE(stb0899_base_addr, BYTE2),\t \n\t\tGETBYTE(stb0899_base_addr, BYTE3),\t \n\t};\n\tu8 buf_1[] = {\n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t\t0x00,\t \n\t};\n\n\tstruct i2c_msg msg_0 = {\n\t\t.addr\t= state->config->demod_address,\n\t\t.flags\t= 0,\n\t\t.buf\t= buf_0,\n\t\t.len\t= 6\n\t};\n\n\tstruct i2c_msg msg_1 = {\n\t\t.addr\t= state->config->demod_address,\n\t\t.flags\t= 0,\n\t\t.buf\t= buf_1,\n\t\t.len\t= 6\n\t};\n\n\tbuf_1[0] = GETBYTE(stb0899_reg_offset, BYTE1);\n\tbuf_1[1] = GETBYTE(stb0899_reg_offset, BYTE0);\n\tbuf_1[2] = GETBYTE(stb0899_data, BYTE0);\n\tbuf_1[3] = GETBYTE(stb0899_data, BYTE1);\n\tbuf_1[4] = GETBYTE(stb0899_data, BYTE2);\n\tbuf_1[5] = GETBYTE(stb0899_data, BYTE3);\n\n\tif (unlikely(*state->verbose >= FE_DEBUGREG))\n\t\tprintk(KERN_DEBUG \"%s Device=[0x%04x], Base Address=[0x%08x], Offset=[0x%04x], Data=[0x%08x]\\n\",\n\t\t       __func__, stb0899_i2cdev, stb0899_base_addr, stb0899_reg_offset, stb0899_data);\n\n\tstatus = i2c_transfer(state->i2c, &msg_0, 1);\n\tif (unlikely(status < 1)) {\n\t\tif (status != -ERESTARTSYS)\n\t\t\tprintk(KERN_ERR \"%s ERR (1), Device=[0x%04x], Base Address=[0x%08x], Offset=[0x%04x], Data=[0x%08x], status=%d\\n\",\n\t\t\t       __func__, stb0899_i2cdev, stb0899_base_addr, stb0899_reg_offset, stb0899_data, status);\n\t\tgoto err;\n\t}\n\tstatus = i2c_transfer(state->i2c, &msg_1, 1);\n\tif (unlikely(status < 1)) {\n\t\tif (status != -ERESTARTSYS)\n\t\t\tprintk(KERN_ERR \"%s ERR (2), Device=[0x%04x], Base Address=[0x%08x], Offset=[0x%04x], Data=[0x%08x], status=%d\\n\",\n\t\t\t       __func__, stb0899_i2cdev, stb0899_base_addr, stb0899_reg_offset, stb0899_data, status);\n\n\t\treturn status < 0 ? status : -EREMOTEIO;\n\t}\n\n\treturn 0;\n\nerr:\n\treturn status < 0 ? status : -EREMOTEIO;\n}\n\nint stb0899_read_regs(struct stb0899_state *state, unsigned int reg, u8 *buf, u32 count)\n{\n\tint status;\n\n\tu8 b0[] = { reg >> 8, reg & 0xff };\n\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= state->config->demod_address,\n\t\t\t.flags\t= 0,\n\t\t\t.buf\t= b0,\n\t\t\t.len\t= 2\n\t\t},{\n\t\t\t.addr\t= state->config->demod_address,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.buf\t= buf,\n\t\t\t.len\t= count\n\t\t}\n\t};\n\n\tstatus = i2c_transfer(state->i2c, msg, 2);\n\tif (status != 2) {\n\t\tif (status != -ERESTARTSYS)\n\t\t\tprintk(KERN_ERR \"%s Read error, Reg=[0x%04x], Count=%u, Status=%d\\n\",\n\t\t\t       __func__, reg, count, status);\n\t\tgoto err;\n\t}\n\t \n\tif ((reg != 0xf2ff) && (reg != 0xf6ff) &&\n\t    (((reg & 0xff00) == 0xf200) || ((reg & 0xff00) == 0xf600)))\n\t\t_stb0899_read_reg(state, (reg | 0x00ff));\n\n\tdprintk(state->verbose, FE_DEBUGREG, 1,\n\t\t\"%s [0x%04x]: %*ph\", __func__, reg, count, buf);\n\n\treturn 0;\nerr:\n\treturn status < 0 ? status : -EREMOTEIO;\n}\n\nint stb0899_write_regs(struct stb0899_state *state, unsigned int reg, u8 *data, u32 count)\n{\n\tint ret;\n\tu8 buf[MAX_XFER_SIZE];\n\tstruct i2c_msg i2c_msg = {\n\t\t.addr\t= state->config->demod_address,\n\t\t.flags\t= 0,\n\t\t.buf\t= buf,\n\t\t.len\t= 2 + count\n\t};\n\n\tif (2 + count > sizeof(buf)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: i2c wr reg=%04x: len=%d is too big!\\n\",\n\t\t       KBUILD_MODNAME, reg, count);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xff;\n\tmemcpy(&buf[2], data, count);\n\n\tdprintk(state->verbose, FE_DEBUGREG, 1,\n\t\t\"%s [0x%04x]: %*ph\", __func__, reg, count, data);\n\tret = i2c_transfer(state->i2c, &i2c_msg, 1);\n\n\t \n\tif ((((reg & 0xff00) == 0xf200) || ((reg & 0xff00) == 0xf600)))\n\t\tstb0899_read_reg(state, (reg | 0x00ff));\n\n\tif (ret != 1) {\n\t\tif (ret != -ERESTARTSYS)\n\t\t\tdprintk(state->verbose, FE_ERROR, 1, \"Reg=[0x%04x], Data=[0x%02x ...], Count=%u, Status=%d\",\n\t\t\t\treg, data[0], count, ret);\n\t\treturn ret < 0 ? ret : -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nint stb0899_write_reg(struct stb0899_state *state, unsigned int reg, u8 data)\n{\n\tu8 tmp = data;\n\treturn stb0899_write_regs(state, reg, &tmp, 1);\n}\n\n \nstatic u32 stb0899_get_mclk(struct stb0899_state *state)\n{\n\tu32 mclk = 0, div = 0;\n\n\tdiv = stb0899_read_reg(state, STB0899_NCOARSE);\n\tmclk = (div + 1) * state->config->xtal_freq / 6;\n\tdprintk(state->verbose, FE_DEBUG, 1, \"div=%d, mclk=%d\", div, mclk);\n\n\treturn mclk;\n}\n\n \nstatic void stb0899_set_mclk(struct stb0899_state *state, u32 Mclk)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tu8 mdiv = 0;\n\n\tdprintk(state->verbose, FE_DEBUG, 1, \"state->config=%p\", state->config);\n\tmdiv = ((6 * Mclk) / state->config->xtal_freq) - 1;\n\tdprintk(state->verbose, FE_DEBUG, 1, \"mdiv=%d\", mdiv);\n\n\tstb0899_write_reg(state, STB0899_NCOARSE, mdiv);\n\tinternal->master_clk = stb0899_get_mclk(state);\n\n\tdprintk(state->verbose, FE_DEBUG, 1, \"MasterCLOCK=%d\", internal->master_clk);\n}\n\nstatic int stb0899_postproc(struct stb0899_state *state, u8 ctl, int enable)\n{\n\tstruct stb0899_config *config\t\t= state->config;\n\tconst struct stb0899_postproc *postproc\t= config->postproc;\n\n\t \n\tif (postproc) {\n\t\tif (enable) {\n\t\t\tif (postproc[ctl].level == STB0899_GPIOPULLUP)\n\t\t\t\tstb0899_write_reg(state, postproc[ctl].gpio, 0x02);\n\t\t\telse\n\t\t\t\tstb0899_write_reg(state, postproc[ctl].gpio, 0x82);\n\t\t} else {\n\t\t\tif (postproc[ctl].level == STB0899_GPIOPULLUP)\n\t\t\t\tstb0899_write_reg(state, postproc[ctl].gpio, 0x82);\n\t\t\telse\n\t\t\t\tstb0899_write_reg(state, postproc[ctl].gpio, 0x02);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void stb0899_detach(struct dvb_frontend *fe)\n{\n\tstruct stb0899_state *state = fe->demodulator_priv;\n\n\t \n\tstb0899_postproc(state, STB0899_POSTPROC_GPIO_POWER, 0);\n}\n\nstatic void stb0899_release(struct dvb_frontend *fe)\n{\n\tstruct stb0899_state *state = fe->demodulator_priv;\n\n\tdprintk(state->verbose, FE_DEBUG, 1, \"Release Frontend\");\n\tkfree(state);\n}\n\n \nstatic int stb0899_get_alpha(struct stb0899_state *state)\n{\n\tu8 mode_coeff;\n\n\tmode_coeff = stb0899_read_reg(state, STB0899_DEMOD);\n\n\tif (STB0899_GETFIELD(MODECOEFF, mode_coeff) == 1)\n\t\treturn 20;\n\telse\n\t\treturn 35;\n}\n\n \nstatic void stb0899_init_calc(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tint master_clk;\n\tu8 agc[2];\n\tu32 reg;\n\n\t \n\tstb0899_read_regs(state, STB0899_AGC1REF, agc, 2);  \n\n\t \n\tmaster_clk\t\t\t= stb0899_get_mclk(state);\n\tinternal->t_agc1\t\t= 0;\n\tinternal->t_agc2\t\t= 0;\n\tinternal->master_clk\t\t= master_clk;\n\tinternal->mclk\t\t\t= master_clk / 65536L;\n\tinternal->rolloff\t\t= stb0899_get_alpha(state);\n\n\t \n\t \n\tinternal->agc_gain\t\t= 8154;\n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, IF_AGC_CNTRL);\n\tSTB0899_SETFIELD_VAL(IF_GAIN_INIT, reg, internal->agc_gain);\n\tstb0899_write_s2reg(state, STB0899_S2DEMOD, STB0899_BASE_IF_AGC_CNTRL, STB0899_OFF0_IF_AGC_CNTRL, reg);\n\n\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, RRC_ALPHA);\n\tinternal->rrc_alpha\t\t= STB0899_GETFIELD(RRC_ALPHA, reg);\n\n\tinternal->center_freq\t\t= 0;\n\tinternal->av_frame_coarse\t= 10;\n\tinternal->av_frame_fine\t\t= 20;\n\tinternal->step_size\t\t= 2;\n \n}\n\nstatic int stb0899_wait_diseqc_fifo_empty(struct stb0899_state *state, int timeout)\n{\n\tu8 reg = 0;\n\tunsigned long start = jiffies;\n\n\twhile (1) {\n\t\treg = stb0899_read_reg(state, STB0899_DISSTATUS);\n\t\tif (!STB0899_GETFIELD(FIFOFULL, reg))\n\t\t\tbreak;\n\t\tif (time_after(jiffies, start + timeout)) {\n\t\t\tdprintk(state->verbose, FE_ERROR, 1, \"timed out !!\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int stb0899_send_diseqc_msg(struct dvb_frontend *fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct stb0899_state *state = fe->demodulator_priv;\n\tu8 reg, i;\n\n\tif (cmd->msg_len > sizeof(cmd->msg))\n\t\treturn -EINVAL;\n\n\t \n\treg = stb0899_read_reg(state, STB0899_DISCNTRL1);\n\tSTB0899_SETFIELD_VAL(DISPRECHARGE, reg, 1);\n\tstb0899_write_reg(state, STB0899_DISCNTRL1, reg);\n\tfor (i = 0; i < cmd->msg_len; i++) {\n\t\t \n\t\tif (stb0899_wait_diseqc_fifo_empty(state, 100) < 0)\n\t\t\treturn -ETIMEDOUT;\n\n\t\tstb0899_write_reg(state, STB0899_DISFIFO, cmd->msg[i]);\n\t}\n\treg = stb0899_read_reg(state, STB0899_DISCNTRL1);\n\tSTB0899_SETFIELD_VAL(DISPRECHARGE, reg, 0);\n\tstb0899_write_reg(state, STB0899_DISCNTRL1, reg);\n\tmsleep(100);\n\treturn 0;\n}\n\nstatic int stb0899_wait_diseqc_rxidle(struct stb0899_state *state, int timeout)\n{\n\tu8 reg = 0;\n\tunsigned long start = jiffies;\n\n\twhile (!STB0899_GETFIELD(RXEND, reg)) {\n\t\treg = stb0899_read_reg(state, STB0899_DISRX_ST0);\n\t\tif (time_after(jiffies, start + timeout)) {\n\t\t\tdprintk(state->verbose, FE_ERROR, 1, \"timed out!!\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(10);\n\t}\n\n\treturn 0;\n}\n\nstatic int stb0899_recv_slave_reply(struct dvb_frontend *fe, struct dvb_diseqc_slave_reply *reply)\n{\n\tstruct stb0899_state *state = fe->demodulator_priv;\n\tu8 reg, length = 0, i;\n\tint result;\n\n\tif (stb0899_wait_diseqc_rxidle(state, 100) < 0)\n\t\treturn -ETIMEDOUT;\n\n\treg = stb0899_read_reg(state, STB0899_DISRX_ST0);\n\tif (STB0899_GETFIELD(RXEND, reg)) {\n\n\t\treg = stb0899_read_reg(state, STB0899_DISRX_ST1);\n\t\tlength = STB0899_GETFIELD(FIFOBYTENBR, reg);\n\n\t\tif (length > sizeof (reply->msg)) {\n\t\t\tresult = -EOVERFLOW;\n\t\t\tgoto exit;\n\t\t}\n\t\treply->msg_len = length;\n\n\t\t \n\t\tfor (i = 0; i < length; i++)\n\t\t\treply->msg[i] = stb0899_read_reg(state, STB0899_DISFIFO);\n\t}\n\n\treturn 0;\nexit:\n\n\treturn result;\n}\n\nstatic int stb0899_wait_diseqc_txidle(struct stb0899_state *state, int timeout)\n{\n\tu8 reg = 0;\n\tunsigned long start = jiffies;\n\n\twhile (!STB0899_GETFIELD(TXIDLE, reg)) {\n\t\treg = stb0899_read_reg(state, STB0899_DISSTATUS);\n\t\tif (time_after(jiffies, start + timeout)) {\n\t\t\tdprintk(state->verbose, FE_ERROR, 1, \"timed out!!\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(10);\n\t}\n\treturn 0;\n}\n\nstatic int stb0899_send_diseqc_burst(struct dvb_frontend *fe,\n\t\t\t\t     enum fe_sec_mini_cmd burst)\n{\n\tstruct stb0899_state *state = fe->demodulator_priv;\n\tu8 reg, old_state;\n\n\t \n\tif (stb0899_wait_diseqc_txidle(state, 100) < 0)\n\t\treturn -ETIMEDOUT;\n\n\treg = stb0899_read_reg(state, STB0899_DISCNTRL1);\n\told_state = reg;\n\t \n\tSTB0899_SETFIELD_VAL(DISEQCMODE, reg, 0x03);\n\tSTB0899_SETFIELD_VAL(DISPRECHARGE, reg, 0x01);\n\tstb0899_write_reg(state, STB0899_DISCNTRL1, reg);\n\tswitch (burst) {\n\tcase SEC_MINI_A:\n\t\t \n\t\tstb0899_write_reg(state, STB0899_DISFIFO, 0x00);\n\t\tbreak;\n\tcase SEC_MINI_B:\n\t\t \n\t\tstb0899_write_reg(state, STB0899_DISFIFO, 0xff);\n\t\tbreak;\n\t}\n\treg = stb0899_read_reg(state, STB0899_DISCNTRL1);\n\tSTB0899_SETFIELD_VAL(DISPRECHARGE, reg, 0x00);\n\tstb0899_write_reg(state, STB0899_DISCNTRL1, reg);\n\t \n\tif (stb0899_wait_diseqc_txidle(state, 100) < 0)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tstb0899_write_reg(state, STB0899_DISCNTRL1, old_state);\n\n\treturn 0;\n}\n\nstatic int stb0899_diseqc_init(struct stb0899_state *state)\n{\n \n\tu8 f22_tx, reg;\n\n\tu32 mclk, tx_freq = 22000; \n\treg = stb0899_read_reg(state, STB0899_DISCNTRL2);\n\tSTB0899_SETFIELD_VAL(ONECHIP_TRX, reg, 0);\n\tstb0899_write_reg(state, STB0899_DISCNTRL2, reg);\n\n\t \n\treg = stb0899_read_reg(state, STB0899_DISCNTRL1);\n\tSTB0899_SETFIELD_VAL(DISEQCRESET, reg, 1);\n\tstb0899_write_reg(state, STB0899_DISCNTRL1, reg);\n\n\treg = stb0899_read_reg(state, STB0899_DISCNTRL1);\n\tSTB0899_SETFIELD_VAL(DISEQCRESET, reg, 0);\n\tstb0899_write_reg(state, STB0899_DISCNTRL1, reg);\n\n\tmclk = stb0899_get_mclk(state);\n\tf22_tx = mclk / (tx_freq * 32);\n\tstb0899_write_reg(state, STB0899_DISF22, f22_tx);  \n\tstate->rx_freq = 20000;\n\n\treturn 0;\n}\n\nstatic int stb0899_sleep(struct dvb_frontend *fe)\n{\n\tstruct stb0899_state *state = fe->demodulator_priv;\n \n\tdprintk(state->verbose, FE_DEBUG, 1, \"Going to Sleep .. (Really tired .. :-))\");\n\t \n\tstb0899_postproc(state, STB0899_POSTPROC_GPIO_POWER, 0);\n\n\treturn 0;\n}\n\nstatic int stb0899_wakeup(struct dvb_frontend *fe)\n{\n\tint rc;\n\tstruct stb0899_state *state = fe->demodulator_priv;\n\n\tif ((rc = stb0899_write_reg(state, STB0899_SYNTCTRL, STB0899_SELOSCI)))\n\t\treturn rc;\n\t \n\tif ((rc = stb0899_write_reg(state, STB0899_STOPCLK1, 0x00)))\n\t\treturn rc;\n\tif ((rc = stb0899_write_reg(state, STB0899_STOPCLK2, 0x00)))\n\t\treturn rc;\n\n\t \n\tstb0899_postproc(state, STB0899_POSTPROC_GPIO_POWER, 1);\n\n\treturn 0;\n}\n\nstatic int stb0899_init(struct dvb_frontend *fe)\n{\n\tint i;\n\tstruct stb0899_state *state = fe->demodulator_priv;\n\tstruct stb0899_config *config = state->config;\n\n\tdprintk(state->verbose, FE_DEBUG, 1, \"Initializing STB0899 ... \");\n\n\t \n\tdprintk(state->verbose, FE_DEBUG, 1, \"init device\");\n\tfor (i = 0; config->init_dev[i].address != 0xffff; i++)\n\t\tstb0899_write_reg(state, config->init_dev[i].address, config->init_dev[i].data);\n\n\tdprintk(state->verbose, FE_DEBUG, 1, \"init S2 demod\");\n\t \n\tfor (i = 0; config->init_s2_demod[i].offset != 0xffff; i++)\n\t\tstb0899_write_s2reg(state, STB0899_S2DEMOD,\n\t\t\t\t    config->init_s2_demod[i].base_address,\n\t\t\t\t    config->init_s2_demod[i].offset,\n\t\t\t\t    config->init_s2_demod[i].data);\n\n\tdprintk(state->verbose, FE_DEBUG, 1, \"init S1 demod\");\n\t \n\tfor (i = 0; config->init_s1_demod[i].address != 0xffff; i++)\n\t\tstb0899_write_reg(state, config->init_s1_demod[i].address, config->init_s1_demod[i].data);\n\n\tdprintk(state->verbose, FE_DEBUG, 1, \"init S2 FEC\");\n\t \n\tfor (i = 0; config->init_s2_fec[i].offset != 0xffff; i++)\n\t\tstb0899_write_s2reg(state, STB0899_S2FEC,\n\t\t\t\t    config->init_s2_fec[i].base_address,\n\t\t\t\t    config->init_s2_fec[i].offset,\n\t\t\t\t    config->init_s2_fec[i].data);\n\n\tdprintk(state->verbose, FE_DEBUG, 1, \"init TST\");\n\t \n\tfor (i = 0; config->init_tst[i].address != 0xffff; i++)\n\t\tstb0899_write_reg(state, config->init_tst[i].address, config->init_tst[i].data);\n\n\tstb0899_init_calc(state);\n\tstb0899_diseqc_init(state);\n\n\treturn 0;\n}\n\nstatic int stb0899_table_lookup(const struct stb0899_tab *tab, int max, int val)\n{\n\tint res = 0;\n\tint min = 0, med;\n\n\tif (val < tab[min].read)\n\t\tres = tab[min].real;\n\telse if (val >= tab[max].read)\n\t\tres = tab[max].real;\n\telse {\n\t\twhile ((max - min) > 1) {\n\t\t\tmed = (max + min) / 2;\n\t\t\tif (val >= tab[min].read && val < tab[med].read)\n\t\t\t\tmax = med;\n\t\t\telse\n\t\t\t\tmin = med;\n\t\t}\n\t\tres = ((val - tab[min].read) *\n\t\t       (tab[max].real - tab[min].real) /\n\t\t       (tab[max].read - tab[min].read)) +\n\t\t\ttab[min].real;\n\t}\n\n\treturn res;\n}\n\nstatic int stb0899_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct stb0899_state *state\t\t= fe->demodulator_priv;\n\tstruct stb0899_internal *internal\t= &state->internal;\n\n\tint val;\n\tu32 reg;\n\t*strength = 0;\n\tswitch (state->delsys) {\n\tcase SYS_DVBS:\n\tcase SYS_DSS:\n\t\tif (internal->lock) {\n\t\t\treg  = stb0899_read_reg(state, STB0899_VSTATUS);\n\t\t\tif (STB0899_GETFIELD(VSTATUS_LOCKEDVIT, reg)) {\n\n\t\t\t\treg = stb0899_read_reg(state, STB0899_AGCIQIN);\n\t\t\t\tval = (s32)(s8)STB0899_GETFIELD(AGCIQVALUE, reg);\n\n\t\t\t\t*strength = stb0899_table_lookup(stb0899_dvbsrf_tab, ARRAY_SIZE(stb0899_dvbsrf_tab) - 1, val);\n\t\t\t\t*strength += 750;\n\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"AGCIQVALUE = 0x%02x, C = %d * 0.1 dBm\",\n\t\t\t\t\tval & 0xff, *strength);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tif (internal->lock) {\n\t\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, IF_AGC_GAIN);\n\t\t\tval = STB0899_GETFIELD(IF_AGC_GAIN, reg);\n\n\t\t\t*strength = stb0899_table_lookup(stb0899_dvbs2rf_tab, ARRAY_SIZE(stb0899_dvbs2rf_tab) - 1, val);\n\t\t\t*strength += 950;\n\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"IF_AGC_GAIN = 0x%04x, C = %d * 0.1 dBm\",\n\t\t\t\tval & 0x3fff, *strength);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Unsupported delivery system\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int stb0899_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct stb0899_state *state\t\t= fe->demodulator_priv;\n\tstruct stb0899_internal *internal\t= &state->internal;\n\n\tunsigned int val, quant, quantn = -1, est, estn = -1;\n\tu8 buf[2];\n\tu32 reg;\n\n\t*snr = 0;\n\treg  = stb0899_read_reg(state, STB0899_VSTATUS);\n\tswitch (state->delsys) {\n\tcase SYS_DVBS:\n\tcase SYS_DSS:\n\t\tif (internal->lock) {\n\t\t\tif (STB0899_GETFIELD(VSTATUS_LOCKEDVIT, reg)) {\n\n\t\t\t\tstb0899_read_regs(state, STB0899_NIRM, buf, 2);\n\t\t\t\tval = MAKEWORD16(buf[0], buf[1]);\n\n\t\t\t\t*snr = stb0899_table_lookup(stb0899_cn_tab, ARRAY_SIZE(stb0899_cn_tab) - 1, val);\n\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"NIR = 0x%02x%02x = %u, C/N = %d * 0.1 dBm\\n\",\n\t\t\t\t\tbuf[0], buf[1], val, *snr);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tif (internal->lock) {\n\t\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, UWP_CNTRL1);\n\t\t\tquant = STB0899_GETFIELD(UWP_ESN0_QUANT, reg);\n\t\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, UWP_STAT2);\n\t\t\test = STB0899_GETFIELD(ESN0_EST, reg);\n\t\t\tif (est == 1)\n\t\t\t\tval = 301;  \n\t\t\telse if (est == 2)\n\t\t\t\tval = 270;  \n\t\t\telse {\n\t\t\t\t \n\t\t\t\tquantn = stb0899_table_lookup(stb0899_quant_tab, ARRAY_SIZE(stb0899_quant_tab) - 1, quant * 100);\n\t\t\t\t \n\t\t\t\testn = stb0899_table_lookup(stb0899_est_tab, ARRAY_SIZE(stb0899_est_tab) - 1, est);\n\t\t\t\t \n\t\t\t\tval = (quantn - estn) / 10;\n\t\t\t}\n\t\t\t*snr = val;\n\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Es/N0 quant = %d (%d) estimate = %u (%d), C/N = %d * 0.1 dBm\",\n\t\t\t\tquant, quantn, est, estn, val);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Unsupported delivery system\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int stb0899_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct stb0899_state *state\t\t= fe->demodulator_priv;\n\tstruct stb0899_internal *internal\t= &state->internal;\n\tu8 reg;\n\t*status = 0;\n\n\tswitch (state->delsys) {\n\tcase SYS_DVBS:\n\tcase SYS_DSS:\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Delivery system DVB-S/DSS\");\n\t\tif (internal->lock) {\n\t\t\treg  = stb0899_read_reg(state, STB0899_VSTATUS);\n\t\t\tif (STB0899_GETFIELD(VSTATUS_LOCKEDVIT, reg)) {\n\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"--------> FE_HAS_CARRIER | FE_HAS_LOCK\");\n\t\t\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_LOCK;\n\n\t\t\t\treg = stb0899_read_reg(state, STB0899_PLPARM);\n\t\t\t\tif (STB0899_GETFIELD(VITCURPUN, reg)) {\n\t\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"--------> FE_HAS_VITERBI | FE_HAS_SYNC\");\n\t\t\t\t\t*status |= FE_HAS_VITERBI | FE_HAS_SYNC;\n\t\t\t\t\t \n\t\t\t\t\tstb0899_postproc(state, STB0899_POSTPROC_GPIO_LOCK, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Delivery system DVB-S2\");\n\t\tif (internal->lock) {\n\t\t\treg = STB0899_READ_S2REG(STB0899_S2DEMOD, DMD_STAT2);\n\t\t\tif (STB0899_GETFIELD(UWP_LOCK, reg) && STB0899_GETFIELD(CSM_LOCK, reg)) {\n\t\t\t\t*status |= FE_HAS_CARRIER;\n\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n\t\t\t\t\t\"UWP & CSM Lock ! ---> DVB-S2 FE_HAS_CARRIER\");\n\n\t\t\t\treg = stb0899_read_reg(state, STB0899_CFGPDELSTATUS1);\n\t\t\t\tif (STB0899_GETFIELD(CFGPDELSTATUS_LOCK, reg)) {\n\t\t\t\t\t*status |= FE_HAS_LOCK;\n\t\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n\t\t\t\t\t\t\"Packet Delineator Locked ! -----> DVB-S2 FE_HAS_LOCK\");\n\n\t\t\t\t}\n\t\t\t\tif (STB0899_GETFIELD(CONTINUOUS_STREAM, reg)) {\n\t\t\t\t\t*status |= FE_HAS_VITERBI;\n\t\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n\t\t\t\t\t\t\"Packet Delineator found VITERBI ! -----> DVB-S2 FE_HAS_VITERBI\");\n\t\t\t\t}\n\t\t\t\tif (STB0899_GETFIELD(ACCEPTED_STREAM, reg)) {\n\t\t\t\t\t*status |= FE_HAS_SYNC;\n\t\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n\t\t\t\t\t\t\"Packet Delineator found SYNC ! -----> DVB-S2 FE_HAS_SYNC\");\n\t\t\t\t\t \n\t\t\t\t\tstb0899_postproc(state, STB0899_POSTPROC_GPIO_LOCK, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Unsupported delivery system\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int stb0899_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct stb0899_state *state\t\t= fe->demodulator_priv;\n\tstruct stb0899_internal *internal\t= &state->internal;\n\n\tu8  lsb, msb;\n\n\t*ber = 0;\n\n\tswitch (state->delsys) {\n\tcase SYS_DVBS:\n\tcase SYS_DSS:\n\t\tif (internal->lock) {\n\t\t\tlsb = stb0899_read_reg(state, STB0899_ECNT1L);\n\t\t\tmsb = stb0899_read_reg(state, STB0899_ECNT1M);\n\t\t\t*ber = MAKEWORD16(msb, lsb);\n\t\t\t \n\t\t\tif (STB0899_GETFIELD(VSTATUS_PRFVIT, internal->v_status)) {\n\t\t\t\t \n\t\t\t\t*ber *= 9766;\n\t\t\t\t \n\t\t\t\t*ber /= (-1 + (1 << (2 * STB0899_GETFIELD(NOE, internal->err_ctrl))));\n\t\t\t\t*ber /= 8;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tif (internal->lock) {\n\t\t\tlsb = stb0899_read_reg(state, STB0899_ECNT1L);\n\t\t\tmsb = stb0899_read_reg(state, STB0899_ECNT1M);\n\t\t\t*ber = MAKEWORD16(msb, lsb);\n\t\t\t \n\t\t\t*ber *= 10000000;\n\t\t\t*ber /= (-1 + (1 << (4 + 2 * STB0899_GETFIELD(NOE, internal->err_ctrl))));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Unsupported delivery system\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int stb0899_set_voltage(struct dvb_frontend *fe,\n\t\t\t       enum fe_sec_voltage voltage)\n{\n\tstruct stb0899_state *state = fe->demodulator_priv;\n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_13:\n\t\tstb0899_write_reg(state, STB0899_GPIO00CFG, 0x82);\n\t\tstb0899_write_reg(state, STB0899_GPIO01CFG, 0x02);\n\t\tstb0899_write_reg(state, STB0899_GPIO02CFG, 0x00);\n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\n\t\tstb0899_write_reg(state, STB0899_GPIO00CFG, 0x02);\n\t\tstb0899_write_reg(state, STB0899_GPIO01CFG, 0x02);\n\t\tstb0899_write_reg(state, STB0899_GPIO02CFG, 0x82);\n\t\tbreak;\n\tcase SEC_VOLTAGE_OFF:\n\t\tstb0899_write_reg(state, STB0899_GPIO00CFG, 0x82);\n\t\tstb0899_write_reg(state, STB0899_GPIO01CFG, 0x82);\n\t\tstb0899_write_reg(state, STB0899_GPIO02CFG, 0x82);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int stb0899_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\n{\n\tstruct stb0899_state *state = fe->demodulator_priv;\n\tstruct stb0899_internal *internal = &state->internal;\n\n\tu8 div, reg;\n\n\t \n\tif (stb0899_wait_diseqc_txidle(state, 100) < 0)\n\t\treturn -ETIMEDOUT;\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\tdiv = (internal->master_clk / 100) / 5632;\n\t\tdiv = (div + 5) / 10;\n\t\tstb0899_write_reg(state, STB0899_DISEQCOCFG, 0x66);\n\t\treg = stb0899_read_reg(state, STB0899_ACRPRESC);\n\t\tSTB0899_SETFIELD_VAL(ACRPRESC, reg, 0x03);\n\t\tstb0899_write_reg(state, STB0899_ACRPRESC, reg);\n\t\tstb0899_write_reg(state, STB0899_ACRDIV1, div);\n\t\tbreak;\n\tcase SEC_TONE_OFF:\n\t\tstb0899_write_reg(state, STB0899_DISEQCOCFG, 0x20);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint stb0899_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tint i2c_stat;\n\tstruct stb0899_state *state = fe->demodulator_priv;\n\n\ti2c_stat = stb0899_read_reg(state, STB0899_I2CRPT);\n\tif (i2c_stat < 0)\n\t\tgoto err;\n\n\tif (enable) {\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Enabling I2C Repeater ...\");\n\t\ti2c_stat |=  STB0899_I2CTON;\n\t\tif (stb0899_write_reg(state, STB0899_I2CRPT, i2c_stat) < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Disabling I2C Repeater ...\");\n\t\ti2c_stat &= ~STB0899_I2CTON;\n\t\tif (stb0899_write_reg(state, STB0899_I2CRPT, i2c_stat) < 0)\n\t\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tdprintk(state->verbose, FE_ERROR, 1, \"I2C Repeater control failed\");\n\treturn -EREMOTEIO;\n}\n\n\nstatic inline void CONVERT32(u32 x, char *str)\n{\n\t*str++\t= (x >> 24) & 0xff;\n\t*str++\t= (x >> 16) & 0xff;\n\t*str++\t= (x >>  8) & 0xff;\n\t*str++\t= (x >>  0) & 0xff;\n\t*str\t= '\\0';\n}\n\nstatic int stb0899_get_dev_id(struct stb0899_state *state)\n{\n\tu8 chip_id, release;\n\tu16 id;\n\tu32 demod_ver = 0, fec_ver = 0;\n\tchar demod_str[5] = { 0 };\n\tchar fec_str[5] = { 0 };\n\n\tid = stb0899_read_reg(state, STB0899_DEV_ID);\n\tdprintk(state->verbose, FE_DEBUG, 1, \"ID reg=[0x%02x]\", id);\n\tchip_id = STB0899_GETFIELD(CHIP_ID, id);\n\trelease = STB0899_GETFIELD(CHIP_REL, id);\n\n\tdprintk(state->verbose, FE_ERROR, 1, \"Device ID=[%d], Release=[%d]\",\n\t\tchip_id, release);\n\n\tCONVERT32(STB0899_READ_S2REG(STB0899_S2DEMOD, DMD_CORE_ID), (char *)&demod_str);\n\n\tdemod_ver = STB0899_READ_S2REG(STB0899_S2DEMOD, DMD_VERSION_ID);\n\tdprintk(state->verbose, FE_ERROR, 1, \"Demodulator Core ID=[%s], Version=[%d]\", (char *) &demod_str, demod_ver);\n\tCONVERT32(STB0899_READ_S2REG(STB0899_S2FEC, FEC_CORE_ID_REG), (char *)&fec_str);\n\tfec_ver = STB0899_READ_S2REG(STB0899_S2FEC, FEC_VER_ID_REG);\n\tif (! (chip_id > 0)) {\n\t\tdprintk(state->verbose, FE_ERROR, 1, \"couldn't find a STB 0899\");\n\n\t\treturn -ENODEV;\n\t}\n\tdprintk(state->verbose, FE_ERROR, 1, \"FEC Core ID=[%s], Version=[%d]\", (char*) &fec_str, fec_ver);\n\n\treturn 0;\n}\n\nstatic void stb0899_set_delivery(struct stb0899_state *state)\n{\n\tu8 reg;\n\tu8 stop_clk[2];\n\n\tstop_clk[0] = stb0899_read_reg(state, STB0899_STOPCLK1);\n\tstop_clk[1] = stb0899_read_reg(state, STB0899_STOPCLK2);\n\n\tswitch (state->delsys) {\n\tcase SYS_DVBS:\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Delivery System -- DVB-S\");\n\t\t \n\t\treg = stb0899_read_reg(state, STB0899_FECM);\n\t\tSTB0899_SETFIELD_VAL(FECM_RSVD0, reg, 0);\n\t\tSTB0899_SETFIELD_VAL(FECM_VITERBI_ON, reg, 1);\n\t\tstb0899_write_reg(state, STB0899_FECM, reg);\n\n\t\tstb0899_write_reg(state, STB0899_RSULC, 0xb1);\n\t\tstb0899_write_reg(state, STB0899_TSULC, 0x40);\n\t\tstb0899_write_reg(state, STB0899_RSLLC, 0x42);\n\t\tstb0899_write_reg(state, STB0899_TSLPL, 0x12);\n\n\t\treg = stb0899_read_reg(state, STB0899_TSTRES);\n\t\tSTB0899_SETFIELD_VAL(FRESLDPC, reg, 1);\n\t\tstb0899_write_reg(state, STB0899_TSTRES, reg);\n\n\t\tSTB0899_SETFIELD_VAL(STOP_CHK8PSK, stop_clk[0], 1);\n\t\tSTB0899_SETFIELD_VAL(STOP_CKFEC108, stop_clk[0], 1);\n\t\tSTB0899_SETFIELD_VAL(STOP_CKFEC216, stop_clk[0], 1);\n\n\t\tSTB0899_SETFIELD_VAL(STOP_CKPKDLIN108, stop_clk[1], 1);\n\t\tSTB0899_SETFIELD_VAL(STOP_CKPKDLIN216, stop_clk[1], 1);\n\n\t\tSTB0899_SETFIELD_VAL(STOP_CKINTBUF216, stop_clk[0], 1);\n\t\tSTB0899_SETFIELD_VAL(STOP_CKCORE216, stop_clk[0], 0);\n\n\t\tSTB0899_SETFIELD_VAL(STOP_CKS2DMD108, stop_clk[1], 1);\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\t \n\t\treg = stb0899_read_reg(state, STB0899_FECM);\n\t\tSTB0899_SETFIELD_VAL(FECM_RSVD0, reg, 0);\n\t\tSTB0899_SETFIELD_VAL(FECM_VITERBI_ON, reg, 0);\n\t\tstb0899_write_reg(state, STB0899_FECM, reg);\n\n\t\tstb0899_write_reg(state, STB0899_RSULC, 0xb1);\n\t\tstb0899_write_reg(state, STB0899_TSULC, 0x42);\n\t\tstb0899_write_reg(state, STB0899_RSLLC, 0x40);\n\t\tstb0899_write_reg(state, STB0899_TSLPL, 0x02);\n\n\t\treg = stb0899_read_reg(state, STB0899_TSTRES);\n\t\tSTB0899_SETFIELD_VAL(FRESLDPC, reg, 0);\n\t\tstb0899_write_reg(state, STB0899_TSTRES, reg);\n\n\t\tSTB0899_SETFIELD_VAL(STOP_CHK8PSK, stop_clk[0], 1);\n\t\tSTB0899_SETFIELD_VAL(STOP_CKFEC108, stop_clk[0], 0);\n\t\tSTB0899_SETFIELD_VAL(STOP_CKFEC216, stop_clk[0], 0);\n\n\t\tSTB0899_SETFIELD_VAL(STOP_CKPKDLIN108, stop_clk[1], 0);\n\t\tSTB0899_SETFIELD_VAL(STOP_CKPKDLIN216, stop_clk[1], 0);\n\n\t\tSTB0899_SETFIELD_VAL(STOP_CKINTBUF216, stop_clk[0], 0);\n\t\tSTB0899_SETFIELD_VAL(STOP_CKCORE216, stop_clk[0], 0);\n\n\t\tSTB0899_SETFIELD_VAL(STOP_CKS2DMD108, stop_clk[1], 0);\n\t\tbreak;\n\tcase SYS_DSS:\n\t\t \n\t\treg = stb0899_read_reg(state, STB0899_FECM);\n\t\tSTB0899_SETFIELD_VAL(FECM_RSVD0, reg, 1);\n\t\tSTB0899_SETFIELD_VAL(FECM_VITERBI_ON, reg, 1);\n\t\tstb0899_write_reg(state, STB0899_FECM, reg);\n\n\t\tstb0899_write_reg(state, STB0899_RSULC, 0xa1);\n\t\tstb0899_write_reg(state, STB0899_TSULC, 0x61);\n\t\tstb0899_write_reg(state, STB0899_RSLLC, 0x42);\n\n\t\treg = stb0899_read_reg(state, STB0899_TSTRES);\n\t\tSTB0899_SETFIELD_VAL(FRESLDPC, reg, 1);\n\t\tstb0899_write_reg(state, STB0899_TSTRES, reg);\n\n\t\tSTB0899_SETFIELD_VAL(STOP_CHK8PSK, stop_clk[0], 1);\n\t\tSTB0899_SETFIELD_VAL(STOP_CKFEC108, stop_clk[0], 1);\n\t\tSTB0899_SETFIELD_VAL(STOP_CKFEC216, stop_clk[0], 1);\n\n\t\tSTB0899_SETFIELD_VAL(STOP_CKPKDLIN108, stop_clk[1], 1);\n\t\tSTB0899_SETFIELD_VAL(STOP_CKPKDLIN216, stop_clk[1], 1);\n\n\t\tSTB0899_SETFIELD_VAL(STOP_CKCORE216, stop_clk[0], 0);\n\n\t\tSTB0899_SETFIELD_VAL(STOP_CKS2DMD108, stop_clk[1], 1);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(state->verbose, FE_ERROR, 1, \"Unsupported delivery system\");\n\t\tbreak;\n\t}\n\tSTB0899_SETFIELD_VAL(STOP_CKADCI108, stop_clk[0], 0);\n\tstb0899_write_regs(state, STB0899_STOPCLK1, stop_clk, 2);\n}\n\n \nstatic void stb0899_set_iterations(struct stb0899_state *state)\n{\n\tstruct stb0899_internal *internal = &state->internal;\n\tstruct stb0899_config *config = state->config;\n\n\ts32 iter_scale;\n\tu32 reg;\n\n\titer_scale = 17 * (internal->master_clk / 1000);\n\titer_scale += 410000;\n\titer_scale /= (internal->srate / 1000000);\n\titer_scale /= 1000;\n\n\tif (iter_scale > config->ldpc_max_iter)\n\t\titer_scale = config->ldpc_max_iter;\n\n\treg = STB0899_READ_S2REG(STB0899_S2FEC, MAX_ITER);\n\tSTB0899_SETFIELD_VAL(MAX_ITERATIONS, reg, iter_scale);\n\tstb0899_write_s2reg(state, STB0899_S2FEC, STB0899_BASE_MAX_ITER, STB0899_OFF0_MAX_ITER, reg);\n}\n\nstatic enum dvbfe_search stb0899_search(struct dvb_frontend *fe)\n{\n\tstruct stb0899_state *state = fe->demodulator_priv;\n\tstruct stb0899_params *i_params = &state->params;\n\tstruct stb0899_internal *internal = &state->internal;\n\tstruct stb0899_config *config = state->config;\n\tstruct dtv_frontend_properties *props = &fe->dtv_property_cache;\n\n\tu32 SearchRange, gain;\n\n\ti_params->freq\t= props->frequency;\n\ti_params->srate = props->symbol_rate;\n\tstate->delsys = props->delivery_system;\n\tdprintk(state->verbose, FE_DEBUG, 1, \"delivery system=%d\", state->delsys);\n\n\tSearchRange = 10000000;\n\tdprintk(state->verbose, FE_DEBUG, 1, \"Frequency=%d, Srate=%d\", i_params->freq, i_params->srate);\n\t \n\tif (INRANGE(i_params->srate, 1000000, 45000000)) {\n\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Parameters IN RANGE\");\n\t\tstb0899_set_delivery(state);\n\n\t\tif (state->config->tuner_set_rfsiggain) {\n\t\t\tif (internal->srate > 15000000)\n\t\t\t\tgain =  8;  \n\t\t\telse if (internal->srate > 5000000)\n\t\t\t\tgain = 12;  \n\t\t\telse\n\t\t\t\tgain = 14;  \n\t\t\tstate->config->tuner_set_rfsiggain(fe, gain);\n\t\t}\n\n\t\tif (i_params->srate <= 5000000)\n\t\t\tstb0899_set_mclk(state, config->lo_clk);\n\t\telse\n\t\t\tstb0899_set_mclk(state, config->hi_clk);\n\n\t\tswitch (state->delsys) {\n\t\tcase SYS_DVBS:\n\t\tcase SYS_DSS:\n\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"DVB-S delivery system\");\n\t\t\tinternal->freq\t= i_params->freq;\n\t\t\tinternal->srate\t= i_params->srate;\n\t\t\t \n\t\t\tinternal->srch_range\t= SearchRange + 1500000 + (i_params->srate / 5);\n\t\t\tinternal->derot_percent\t= 30;\n\n\t\t\t \n\t\t\t \n\t\t\tstb0899_i2c_gate_ctrl(&state->frontend, 1);\n\n\t\t\tif (state->config->tuner_set_bandwidth)\n\t\t\t\tstate->config->tuner_set_bandwidth(fe, (13 * (stb0899_carr_width(state) + SearchRange)) / 10);\n\t\t\tif (state->config->tuner_get_bandwidth)\n\t\t\t\tstate->config->tuner_get_bandwidth(fe, &internal->tuner_bw);\n\n\t\t\t \n\t\t\tstb0899_i2c_gate_ctrl(&state->frontend, 0);\n\n\t\t\t \n\t\t\tstb0899_write_reg(state, STB0899_AGCRFCFG, 0x11);\n\n\t\t\t \n\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"running DVB-S search algo ..\");\n\t\t\tif (stb0899_dvbs_algo(state)\t== RANGEOK) {\n\t\t\t\tinternal->lock\t\t= 1;\n\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n\t\t\t\t\t\"-------------------------------------> DVB-S LOCK !\");\n\n\n\n\n\n\n\n\t\t\t\treturn DVBFE_ALGO_SEARCH_SUCCESS;\n\t\t\t} else {\n\t\t\t\tinternal->lock\t\t= 0;\n\n\t\t\t\treturn DVBFE_ALGO_SEARCH_FAILED;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SYS_DVBS2:\n\t\t\tinternal->freq\t\t\t= i_params->freq;\n\t\t\tinternal->srate\t\t\t= i_params->srate;\n\t\t\tinternal->srch_range\t\t= SearchRange;\n\n\t\t\t \n\t\t\tstb0899_i2c_gate_ctrl(&state->frontend, 1);\n\n\t\t\tif (state->config->tuner_set_bandwidth)\n\t\t\t\tstate->config->tuner_set_bandwidth(fe, (stb0899_carr_width(state) + SearchRange));\n\t\t\tif (state->config->tuner_get_bandwidth)\n\t\t\t\tstate->config->tuner_get_bandwidth(fe, &internal->tuner_bw);\n\n\t\t\t \n\t\t\tstb0899_i2c_gate_ctrl(&state->frontend, 0);\n\n\n\n\t\t\t \n\t\t\tstb0899_write_reg(state, STB0899_AGCRFCFG, 0x1c);\n\n\t\t\t \n\t\t\tstb0899_set_iterations(state);\n\n\t\t\t \n\t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"running DVB-S2 search algo ..\");\n\t\t\tif (stb0899_dvbs2_algo(state)\t== DVBS2_FEC_LOCK) {\n\t\t\t\tinternal->lock\t\t= 1;\n\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n\t\t\t\t\t\"-------------------------------------> DVB-S2 LOCK !\");\n\n\n\n\n\n\t\t\t\treturn DVBFE_ALGO_SEARCH_SUCCESS;\n\t\t\t} else {\n\t\t\t\tinternal->lock\t\t= 0;\n\n\t\t\t\treturn DVBFE_ALGO_SEARCH_FAILED;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(state->verbose, FE_ERROR, 1, \"Unsupported delivery system\");\n\t\t\treturn DVBFE_ALGO_SEARCH_INVALID;\n\t\t}\n\t}\n\n\treturn DVBFE_ALGO_SEARCH_ERROR;\n}\n\nstatic int stb0899_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct stb0899_state *state\t\t= fe->demodulator_priv;\n\tstruct stb0899_internal *internal\t= &state->internal;\n\n\tdprintk(state->verbose, FE_DEBUG, 1, \"Get params\");\n\tp->symbol_rate = internal->srate;\n\tp->frequency = internal->freq;\n\n\treturn 0;\n}\n\nstatic enum dvbfe_algo stb0899_frontend_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_CUSTOM;\n}\n\nstatic const struct dvb_frontend_ops stb0899_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2, SYS_DSS },\n\t.info = {\n\t\t.name\t\t\t= \"STB0899 Multistandard\",\n\t\t.frequency_min_hz\t=  950 * MHz,\n\t\t.frequency_max_hz\t= 2150 * MHz,\n\t\t.symbol_rate_min\t=  5000000,\n\t\t.symbol_rate_max\t= 45000000,\n\n\t\t.caps\t\t\t= FE_CAN_INVERSION_AUTO\t|\n\t\t\t\t\t  FE_CAN_FEC_AUTO\t|\n\t\t\t\t\t  FE_CAN_2G_MODULATION\t|\n\t\t\t\t\t  FE_CAN_QPSK\n\t},\n\n\t.detach\t\t\t\t= stb0899_detach,\n\t.release\t\t\t= stb0899_release,\n\t.init\t\t\t\t= stb0899_init,\n\t.sleep\t\t\t\t= stb0899_sleep,\n\n\n\t.i2c_gate_ctrl\t\t\t= stb0899_i2c_gate_ctrl,\n\n\t.get_frontend_algo\t\t= stb0899_frontend_algo,\n\t.search\t\t\t\t= stb0899_search,\n\t.get_frontend                   = stb0899_get_frontend,\n\n\n\t.read_status\t\t\t= stb0899_read_status,\n\t.read_snr\t\t\t= stb0899_read_snr,\n\t.read_signal_strength\t\t= stb0899_read_signal_strength,\n\t.read_ber\t\t\t= stb0899_read_ber,\n\n\t.set_voltage\t\t\t= stb0899_set_voltage,\n\t.set_tone\t\t\t= stb0899_set_tone,\n\n\t.diseqc_send_master_cmd\t\t= stb0899_send_diseqc_msg,\n\t.diseqc_recv_slave_reply\t= stb0899_recv_slave_reply,\n\t.diseqc_send_burst\t\t= stb0899_send_diseqc_burst,\n};\n\nstruct dvb_frontend *stb0899_attach(struct stb0899_config *config, struct i2c_adapter *i2c)\n{\n\tstruct stb0899_state *state = NULL;\n\n\tstate = kzalloc(sizeof (struct stb0899_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\tstate->verbose\t\t\t\t= &verbose;\n\tstate->config\t\t\t\t= config;\n\tstate->i2c\t\t\t\t= i2c;\n\tstate->frontend.ops\t\t\t= stb0899_ops;\n\tstate->frontend.demodulator_priv\t= state;\n\t \n\tstate->internal.inversion\t\t= config->inversion;\n\n\tstb0899_wakeup(&state->frontend);\n\tif (stb0899_get_dev_id(state) == -ENODEV) {\n\t\tprintk(\"%s: Exiting .. !\\n\", __func__);\n\t\tgoto error;\n\t}\n\n\tprintk(\"%s: Attaching STB0899 \\n\", __func__);\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(stb0899_attach);\nMODULE_PARM_DESC(verbose, \"Set Verbosity level\");\nMODULE_AUTHOR(\"Manu Abraham\");\nMODULE_DESCRIPTION(\"STB0899 Multi-Std frontend\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}