{
  "module_name": "lnbh25.c",
  "hash_id": "26152226f6bcddb54277dedb173afd2a84d42a36010cb6ad1850b09a3763f298",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/lnbh25.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"lnbh25.h\"\n\n \nstruct lnbh25_priv {\n\tstruct i2c_adapter\t*i2c;\n\tu8\t\t\ti2c_address;\n\tu8\t\t\tconfig[3];\n};\n\n#define LNBH25_STATUS_OFL\t0x1\n#define LNBH25_STATUS_VMON\t0x4\n#define LNBH25_VSEL_13\t\t0x03\n#define LNBH25_VSEL_18\t\t0x0a\n\nstatic int lnbh25_read_vmon(struct lnbh25_priv *priv)\n{\n\tint i, ret;\n\tu8 addr = 0x00;\n\tu8 status[6];\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = priv->i2c_address,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &addr\n\t\t}, {\n\t\t\t.addr = priv->i2c_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(status),\n\t\t\t.buf = status\n\t\t}\n\t};\n\n\tfor (i = 0; i < 2; i++) {\n\t\tret = i2c_transfer(priv->i2c, &msg[i], 1);\n\t\tif (ret >= 0 && ret != 1)\n\t\t\tret = -EIO;\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\"%s(): I2C transfer %d failed (%d)\\n\",\n\t\t\t\t__func__, i, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tdev_dbg(&priv->i2c->dev, \"%s(): %*ph\\n\",\n\t\t__func__, (int) sizeof(status), status);\n\tif ((status[0] & (LNBH25_STATUS_OFL | LNBH25_STATUS_VMON)) != 0) {\n\t\tdev_err(&priv->i2c->dev,\n\t\t\t\"%s(): voltage in failure state, status reg 0x%x\\n\",\n\t\t\t__func__, status[0]);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int lnbh25_set_voltage(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_voltage voltage)\n{\n\tint ret;\n\tu8 data1_reg;\n\tconst char *vsel;\n\tstruct lnbh25_priv *priv = fe->sec_priv;\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->i2c_address,\n\t\t.flags = 0,\n\t\t.len = sizeof(priv->config),\n\t\t.buf = priv->config\n\t};\n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_OFF:\n\t\tdata1_reg = 0x00;\n\t\tvsel = \"Off\";\n\t\tbreak;\n\tcase SEC_VOLTAGE_13:\n\t\tdata1_reg = LNBH25_VSEL_13;\n\t\tvsel = \"13V\";\n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\n\t\tdata1_reg = LNBH25_VSEL_18;\n\t\tvsel = \"18V\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tpriv->config[1] = data1_reg;\n\tdev_dbg(&priv->i2c->dev,\n\t\t\"%s(): %s, I2C 0x%x write [ %02x %02x %02x ]\\n\",\n\t\t__func__, vsel, priv->i2c_address,\n\t\tpriv->config[0], priv->config[1], priv->config[2]);\n\tret = i2c_transfer(priv->i2c, &msg, 1);\n\tif (ret >= 0 && ret != 1)\n\t\tret = -EIO;\n\tif (ret < 0) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): I2C transfer error (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\tif (voltage != SEC_VOLTAGE_OFF) {\n\t\tmsleep(120);\n\t\tret = lnbh25_read_vmon(priv);\n\t} else {\n\t\tmsleep(20);\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic void lnbh25_release(struct dvb_frontend *fe)\n{\n\tstruct lnbh25_priv *priv = fe->sec_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tlnbh25_set_voltage(fe, SEC_VOLTAGE_OFF);\n\tkfree(fe->sec_priv);\n\tfe->sec_priv = NULL;\n}\n\nstruct dvb_frontend *lnbh25_attach(struct dvb_frontend *fe,\n\t\t\t\t   struct lnbh25_config *cfg,\n\t\t\t\t   struct i2c_adapter *i2c)\n{\n\tstruct lnbh25_priv *priv;\n\n\tdev_dbg(&i2c->dev, \"%s()\\n\", __func__);\n\tpriv = kzalloc(sizeof(struct lnbh25_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn NULL;\n\tpriv->i2c_address = (cfg->i2c_address >> 1);\n\tpriv->i2c = i2c;\n\tpriv->config[0] = 0x02;\n\tpriv->config[1] = 0x00;\n\tpriv->config[2] = cfg->data2_config;\n\tfe->sec_priv = priv;\n\tif (lnbh25_set_voltage(fe, SEC_VOLTAGE_OFF)) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"%s(): no LNBH25 found at I2C addr 0x%02x\\n\",\n\t\t\t__func__, priv->i2c_address);\n\t\tkfree(priv);\n\t\tfe->sec_priv = NULL;\n\t\treturn NULL;\n\t}\n\n\tfe->ops.release_sec = lnbh25_release;\n\tfe->ops.set_voltage = lnbh25_set_voltage;\n\n\tdev_info(&i2c->dev, \"%s(): attached at I2C addr 0x%02x\\n\",\n\t\t__func__, priv->i2c_address);\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(lnbh25_attach);\n\nMODULE_DESCRIPTION(\"ST LNBH25 driver\");\nMODULE_AUTHOR(\"info@netup.ru\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}