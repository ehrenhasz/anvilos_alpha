{
  "module_name": "si2168.c",
  "hash_id": "e37fa52eebd8046c8b84ba55e5c44d6b739c225969c98b1a9116a118450cdfbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/si2168.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include \"si2168_priv.h\"\n\nstatic const struct dvb_frontend_ops si2168_ops;\n\nstatic void cmd_init(struct si2168_cmd *cmd, const u8 *buf, int wlen, int rlen)\n{\n\tmemcpy(cmd->args, buf, wlen);\n\tcmd->wlen = wlen;\n\tcmd->rlen = rlen;\n}\n\n \nstatic int si2168_cmd_execute(struct i2c_client *client, struct si2168_cmd *cmd)\n{\n\tstruct si2168_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\tunsigned long timeout;\n\n\tmutex_lock(&dev->i2c_mutex);\n\n\tif (cmd->wlen) {\n\t\t \n\t\tret = i2c_master_send(client, cmd->args, cmd->wlen);\n\t\tif (ret < 0) {\n\t\t\tgoto err_mutex_unlock;\n\t\t} else if (ret != cmd->wlen) {\n\t\t\tret = -EREMOTEIO;\n\t\t\tgoto err_mutex_unlock;\n\t\t}\n\t}\n\n\tif (cmd->rlen) {\n\t\t \n\t\t#define TIMEOUT 70\n\t\ttimeout = jiffies + msecs_to_jiffies(TIMEOUT);\n\t\twhile (!time_after(jiffies, timeout)) {\n\t\t\tret = i2c_master_recv(client, cmd->args, cmd->rlen);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto err_mutex_unlock;\n\t\t\t} else if (ret != cmd->rlen) {\n\t\t\t\tret = -EREMOTEIO;\n\t\t\t\tgoto err_mutex_unlock;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((cmd->args[0] >> 7) & 0x01)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(&client->dev, \"cmd execution took %d ms\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies) -\n\t\t\t\t(jiffies_to_msecs(timeout) - TIMEOUT));\n\n\t\t \n\t\tif ((cmd->args[0] >> 6) & 0x01) {\n\t\t\tret = -EREMOTEIO;\n\t\t\tgoto err_mutex_unlock;\n\t\t}\n\n\t\tif (!((cmd->args[0] >> 7) & 0x01)) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto err_mutex_unlock;\n\t\t}\n\t}\n\n\tmutex_unlock(&dev->i2c_mutex);\n\treturn 0;\nerr_mutex_unlock:\n\tmutex_unlock(&dev->i2c_mutex);\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int si2168_ts_bus_ctrl(struct dvb_frontend *fe, int acquire)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct si2168_dev *dev = i2c_get_clientdata(client);\n\tstruct si2168_cmd cmd;\n\tint ret = 0;\n\n\tdev_dbg(&client->dev, \"%s acquire: %d\\n\", __func__, acquire);\n\n\t \n\tif (dev->ts_mode & SI2168_TS_CLK_MANUAL) {\n\t\tcmd_init(&cmd, \"\\x14\\x00\\x0d\\x10\\xe8\\x03\", 6, 4);\n\t\tret = si2168_cmd_execute(client, &cmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\t \n\tcmd_init(&cmd, \"\\x14\\x00\\x01\\x10\\x10\\x00\", 6, 4);\n\tif (dev->ts_mode & SI2168_TS_CLK_MANUAL)\n\t\tcmd.args[4] = SI2168_TS_CLK_MANUAL;\n\tif (acquire)\n\t\tcmd.args[4] |= dev->ts_mode;\n\telse\n\t\tcmd.args[4] |= SI2168_TS_TRISTATE;\n\tif (dev->ts_clock_gapped)\n\t\tcmd.args[4] |= 0x40;\n\tret = si2168_cmd_execute(client, &cmd);\n\n\treturn ret;\n}\n\nstatic int si2168_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct si2168_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i;\n\tunsigned int utmp, utmp1, utmp2;\n\tstruct si2168_cmd cmd;\n\n\t*status = 0;\n\n\tif (!dev->active) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tcmd_init(&cmd, \"\\xa0\\x01\", 2, 13);\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tcmd_init(&cmd, \"\\x90\\x01\", 2, 9);\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tcmd_init(&cmd, \"\\x50\\x01\", 2, 14);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tswitch ((cmd.args[2] >> 1) & 0x03) {\n\tcase 0x01:\n\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\t\tbreak;\n\tcase 0x03:\n\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |\n\t\t\t\tFE_HAS_SYNC | FE_HAS_LOCK;\n\t\tbreak;\n\t}\n\n\tdev->fe_status = *status;\n\n\tif (*status & FE_HAS_LOCK) {\n\t\tc->cnr.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[0].svalue = cmd.args[3] * 1000 / 4;\n\t} else {\n\t\tc->cnr.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\tdev_dbg(&client->dev, \"status=%02x args=%*ph\\n\",\n\t\t\t*status, cmd.rlen, cmd.args);\n\n\t \n\tif (*status & FE_HAS_VITERBI) {\n\t\tcmd_init(&cmd, \"\\x82\\x00\", 2, 3);\n\t\tret = si2168_cmd_execute(client, &cmd);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tutmp = clamp(8 - cmd.args[1], 0, 8);\n\t\tfor (i = 0, utmp1 = 1; i < utmp; i++)\n\t\t\tutmp1 = utmp1 * 10;\n\n\t\tutmp1 = cmd.args[2] * utmp1;\n\t\tutmp2 = 100000000;  \n\n\t\tdev_dbg(&client->dev,\n\t\t\t\"post_bit_error=%u post_bit_count=%u ber=%u*10^-%u\\n\",\n\t\t\tutmp1, utmp2, cmd.args[2], cmd.args[1]);\n\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[0].uvalue += utmp1;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[0].uvalue += utmp2;\n\t} else {\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (*status & FE_HAS_SYNC) {\n\t\tcmd_init(&cmd, \"\\x84\\x01\", 2, 3);\n\t\tret = si2168_cmd_execute(client, &cmd);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp1 = cmd.args[2] << 8 | cmd.args[1] << 0;\n\t\tdev_dbg(&client->dev, \"block_error=%u\\n\", utmp1);\n\n\t\t \n\t\tif (utmp1 == 0xffff)\n\t\t\tutmp1 = 0;\n\n\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_error.stat[0].uvalue += utmp1;\n\t} else {\n\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int si2168_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct si2168_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\tstruct si2168_cmd cmd;\n\tu8 bandwidth, delivery_system;\n\n\tdev_dbg(&client->dev,\n\t\t\t\"delivery_system=%u modulation=%u frequency=%u bandwidth_hz=%u symbol_rate=%u inversion=%u stream_id=%u\\n\",\n\t\t\tc->delivery_system, c->modulation, c->frequency,\n\t\t\tc->bandwidth_hz, c->symbol_rate, c->inversion,\n\t\t\tc->stream_id);\n\n\tif (!dev->active) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tdelivery_system = 0x20;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tdelivery_system = 0x30;\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tdelivery_system = 0x70;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (c->bandwidth_hz == 0) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t} else if (c->bandwidth_hz <= 2000000)\n\t\tbandwidth = 0x02;\n\telse if (c->bandwidth_hz <= 5000000)\n\t\tbandwidth = 0x05;\n\telse if (c->bandwidth_hz <= 6000000)\n\t\tbandwidth = 0x06;\n\telse if (c->bandwidth_hz <= 7000000)\n\t\tbandwidth = 0x07;\n\telse if (c->bandwidth_hz <= 8000000)\n\t\tbandwidth = 0x08;\n\telse if (c->bandwidth_hz <= 9000000)\n\t\tbandwidth = 0x09;\n\telse if (c->bandwidth_hz <= 10000000)\n\t\tbandwidth = 0x0a;\n\telse\n\t\tbandwidth = 0x0f;\n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tcmd_init(&cmd, \"\\x88\\x02\\x02\\x02\\x02\", 5, 5);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (c->delivery_system == SYS_DVBT)\n\t\tcmd_init(&cmd, \"\\x89\\x21\\x06\\x11\\xff\\x98\", 6, 3);\n\telse if (c->delivery_system == SYS_DVBC_ANNEX_A)\n\t\tcmd_init(&cmd, \"\\x89\\x21\\x06\\x11\\x89\\xf0\", 6, 3);\n\telse if (c->delivery_system == SYS_DVBT2)\n\t\tcmd_init(&cmd, \"\\x89\\x21\\x06\\x11\\x89\\x20\", 6, 3);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tif (c->delivery_system == SYS_DVBT2) {\n\t\t \n\t\tcmd.args[0] = 0x52;\n\t\tcmd.args[1] = c->stream_id & 0xff;\n\t\tcmd.args[2] = c->stream_id == NO_STREAM_ID_FILTER ? 0 : 1;\n\t\tcmd.wlen = 3;\n\t\tcmd.rlen = 1;\n\t\tret = si2168_cmd_execute(client, &cmd);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tcmd_init(&cmd, \"\\x51\\x03\", 2, 12);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd_init(&cmd, \"\\x12\\x08\\x04\", 3, 3);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd_init(&cmd, \"\\x14\\x00\\x0c\\x10\\x12\\x00\", 6, 4);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd_init(&cmd, \"\\x14\\x00\\x06\\x10\\x24\\x00\", 6, 4);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd_init(&cmd, \"\\x14\\x00\\x07\\x10\\x00\\x24\", 6, 4);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd_init(&cmd, \"\\x14\\x00\\x0a\\x10\\x00\\x00\", 6, 4);\n\tcmd.args[4] = delivery_system | bandwidth;\n\tif (dev->spectral_inversion)\n\t\tcmd.args[5] |= 1;\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (c->delivery_system == SYS_DVBC_ANNEX_A) {\n\t\tcmd_init(&cmd, \"\\x14\\x00\\x02\\x11\\x00\\x00\", 6, 4);\n\t\tcmd.args[4] = ((c->symbol_rate / 1000) >> 0) & 0xff;\n\t\tcmd.args[5] = ((c->symbol_rate / 1000) >> 8) & 0xff;\n\t\tret = si2168_cmd_execute(client, &cmd);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tcmd_init(&cmd, \"\\x14\\x00\\x0f\\x10\\x10\\x00\", 6, 4);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd_init(&cmd, \"\\x14\\x00\\x09\\x10\\xe3\\x08\", 6, 4);\n\tcmd.args[5] |= dev->ts_clock_inv ? 0x00 : 0x10;\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd_init(&cmd, \"\\x14\\x00\\x08\\x10\\xd7\\x05\", 6, 4);\n\tcmd.args[5] |= dev->ts_clock_inv ? 0x00 : 0x10;\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd_init(&cmd, \"\\x14\\x00\\x01\\x12\\x00\\x00\", 6, 4);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd_init(&cmd, \"\\x14\\x00\\x01\\x03\\x0c\\x00\", 6, 4);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd_init(&cmd, \"\\x85\", 1, 1);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->delivery_system = c->delivery_system;\n\n\t \n\tret = si2168_ts_bus_ctrl(fe, 1);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int si2168_init(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct si2168_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, len, remaining;\n\tconst struct firmware *fw;\n\tstruct si2168_cmd cmd;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tcmd_init(&cmd, \"\\xc0\\x12\\x00\\x0c\\x00\\x0d\\x16\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t 13, 0);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tif (dev->warm) {\n\t\t \n\t\tcmd_init(&cmd, \"\\xc0\\x06\\x08\\x0f\\x00\\x20\\x21\\x01\", 8, 1);\n\t\tret = si2168_cmd_execute(client, &cmd);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tudelay(100);\n\t\tcmd_init(&cmd, \"\\x85\", 1, 1);\n\t\tret = si2168_cmd_execute(client, &cmd);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tgoto warm;\n\t}\n\n\t \n\tcmd_init(&cmd, \"\\xc0\\x06\\x01\\x0f\\x00\\x20\\x20\\x01\", 8, 1);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = request_firmware(&fw, dev->firmware_name, &client->dev);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"firmware file '%s' not found\\n\",\n\t\t\tdev->firmware_name);\n\t\tgoto err_release_firmware;\n\t}\n\n\tdev_info(&client->dev, \"downloading firmware from file '%s'\\n\",\n\t\t\tdev->firmware_name);\n\n\tif ((fw->size % 17 == 0) && (fw->data[0] > 5)) {\n\t\t \n\t\tfor (remaining = fw->size; remaining > 0; remaining -= 17) {\n\t\t\tlen = fw->data[fw->size - remaining];\n\t\t\tif (len > SI2168_ARGLEN) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcmd_init(&cmd, &fw->data[(fw->size - remaining) + 1],\n\t\t\t\t len, 1);\n\t\t\tret = si2168_cmd_execute(client, &cmd);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t} else if (fw->size % 8 == 0) {\n\t\t \n\t\tfor (remaining = fw->size; remaining > 0; remaining -= 8) {\n\t\t\tcmd_init(&cmd, &fw->data[fw->size - remaining], 8, 1);\n\t\t\tret = si2168_cmd_execute(client, &cmd);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tret = -EINVAL;\n\t}\n\n\tif (ret) {\n\t\tdev_err(&client->dev, \"firmware download failed %d\\n\", ret);\n\t\tgoto err_release_firmware;\n\t}\n\n\trelease_firmware(fw);\n\n\tcmd_init(&cmd, \"\\x01\\x01\", 2, 1);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tcmd_init(&cmd, \"\\x11\", 1, 10);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->version = (cmd.args[9] + '@') << 24 | (cmd.args[6] - '0') << 16 |\n\t\t       (cmd.args[7] - '0') << 8 | (cmd.args[8]) << 0;\n\tdev_info(&client->dev, \"firmware version: %c %d.%d.%d\\n\",\n\t\t dev->version >> 24 & 0xff, dev->version >> 16 & 0xff,\n\t\t dev->version >> 8 & 0xff, dev->version >> 0 & 0xff);\n\n\t \n\tret = si2168_ts_bus_ctrl(fe, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->warm = true;\n\tdev->initialized = true;\nwarm:\n\t \n\tc->cnr.len = 1;\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.len = 1;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_error.len = 1;\n\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tdev->active = true;\n\n\treturn 0;\nerr_release_firmware:\n\trelease_firmware(fw);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int si2168_resume(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct si2168_dev *dev = i2c_get_clientdata(client);\n\n\t \n\tif (dev->initialized) {\n\t\tdev_dbg(&client->dev, \"previously initialized, call si2168_init()\\n\");\n\t\treturn si2168_init(fe);\n\t}\n\tdev_dbg(&client->dev, \"not initialized yet, skipping init on resume\\n\");\n\treturn 0;\n}\n\nstatic int si2168_sleep(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct si2168_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\tstruct si2168_cmd cmd;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tdev->active = false;\n\n\t \n\tret = si2168_ts_bus_ctrl(fe, 0);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (dev->version > ('B' << 24 | 4 << 16 | 0 << 8 | 11 << 0))\n\t\tdev->warm = false;\n\n\tcmd_init(&cmd, \"\\x13\", 1, 0);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int si2168_get_tune_settings(struct dvb_frontend *fe,\n\tstruct dvb_frontend_tune_settings *s)\n{\n\ts->min_delay_ms = 900;\n\n\treturn 0;\n}\n\nstatic int si2168_select(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct i2c_client *client = i2c_mux_priv(muxc);\n\tint ret;\n\tstruct si2168_cmd cmd;\n\n\t \n\tcmd_init(&cmd, \"\\xc0\\x0d\\x01\", 3, 0);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int si2168_deselect(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct i2c_client *client = i2c_mux_priv(muxc);\n\tint ret;\n\tstruct si2168_cmd cmd;\n\n\t \n\tcmd_init(&cmd, \"\\xc0\\x0d\\x00\", 3, 0);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dvb_frontend_ops si2168_ops = {\n\t.delsys = {SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A},\n\t.info = {\n\t\t.name = \"Silicon Labs Si2168\",\n\t\t.frequency_min_hz      =  48 * MHz,\n\t\t.frequency_max_hz      = 870 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.symbol_rate_min       = 1000000,\n\t\t.symbol_rate_max       = 7200000,\n\t\t.caps =\tFE_CAN_FEC_1_2 |\n\t\t\tFE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 |\n\t\t\tFE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK |\n\t\t\tFE_CAN_QAM_16 |\n\t\t\tFE_CAN_QAM_32 |\n\t\t\tFE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_128 |\n\t\t\tFE_CAN_QAM_256 |\n\t\t\tFE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO |\n\t\t\tFE_CAN_MUTE_TS |\n\t\t\tFE_CAN_2G_MODULATION |\n\t\t\tFE_CAN_MULTISTREAM\n\t},\n\n\t.get_tune_settings = si2168_get_tune_settings,\n\n\t.init = si2168_init,\n\t.sleep = si2168_sleep,\n\t.resume = si2168_resume,\n\n\t.set_frontend = si2168_set_frontend,\n\n\t.read_status = si2168_read_status,\n};\n\nstatic int si2168_probe(struct i2c_client *client)\n{\n\tstruct si2168_config *config = client->dev.platform_data;\n\tstruct si2168_dev *dev;\n\tint ret;\n\tstruct si2168_cmd cmd;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\ti2c_set_clientdata(client, dev);\n\tmutex_init(&dev->i2c_mutex);\n\n\t \n\tcmd_init(&cmd, \"\\xc0\\x12\\x00\\x0c\\x00\\x0d\\x16\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t 13, 0);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\t \n\tcmd_init(&cmd, \"\\xc0\\x06\\x01\\x0f\\x00\\x20\\x20\\x01\", 8, 1);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\t \n\tcmd_init(&cmd, \"\\x02\", 1, 13);\n\tret = si2168_cmd_execute(client, &cmd);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\tdev->chip_id = cmd.args[1] << 24 | cmd.args[2] << 16 |\n\t\t       cmd.args[3] << 8 | cmd.args[4] << 0;\n\n\tswitch (dev->chip_id) {\n\tcase SI2168_CHIP_ID_A20:\n\t\tdev->firmware_name = SI2168_A20_FIRMWARE;\n\t\tbreak;\n\tcase SI2168_CHIP_ID_A30:\n\t\tdev->firmware_name = SI2168_A30_FIRMWARE;\n\t\tbreak;\n\tcase SI2168_CHIP_ID_B40:\n\t\tdev->firmware_name = SI2168_B40_FIRMWARE;\n\t\tbreak;\n\tcase SI2168_CHIP_ID_D60:\n\t\tdev->firmware_name = SI2168_D60_FIRMWARE;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"unknown chip version Si21%d-%c%c%c\\n\",\n\t\t\tcmd.args[2], cmd.args[1], cmd.args[3], cmd.args[4]);\n\t\tret = -ENODEV;\n\t\tgoto err_kfree;\n\t}\n\n\tdev->version = (cmd.args[1]) << 24 | (cmd.args[3] - '0') << 16 |\n\t\t       (cmd.args[4] - '0') << 8 | (cmd.args[5]) << 0;\n\n\t \n\tdev->muxc = i2c_mux_alloc(client->adapter, &client->dev,\n\t\t\t\t  1, 0, I2C_MUX_LOCKED,\n\t\t\t\t  si2168_select, si2168_deselect);\n\tif (!dev->muxc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_kfree;\n\t}\n\tdev->muxc->priv = client;\n\tret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\t \n\tmemcpy(&dev->fe.ops, &si2168_ops, sizeof(struct dvb_frontend_ops));\n\tdev->fe.demodulator_priv = client;\n\t*config->i2c_adapter = dev->muxc->adapter[0];\n\t*config->fe = &dev->fe;\n\tdev->ts_mode = config->ts_mode;\n\tdev->ts_clock_inv = config->ts_clock_inv;\n\tdev->ts_clock_gapped = config->ts_clock_gapped;\n\tdev->spectral_inversion = config->spectral_inversion;\n\n\tdev_info(&client->dev, \"Silicon Labs Si2168-%c%d%d successfully identified\\n\",\n\t\t dev->version >> 24 & 0xff, dev->version >> 16 & 0xff,\n\t\t dev->version >> 8 & 0xff);\n\tdev_info(&client->dev, \"firmware version: %c %d.%d.%d\\n\",\n\t\t dev->version >> 24 & 0xff, dev->version >> 16 & 0xff,\n\t\t dev->version >> 8 & 0xff, dev->version >> 0 & 0xff);\n\n\treturn 0;\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_warn(&client->dev, \"probe failed = %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void si2168_remove(struct i2c_client *client)\n{\n\tstruct si2168_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\ti2c_mux_del_adapters(dev->muxc);\n\n\tdev->fe.ops.release = NULL;\n\tdev->fe.demodulator_priv = NULL;\n\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id si2168_id_table[] = {\n\t{\"si2168\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, si2168_id_table);\n\nstatic struct i2c_driver si2168_driver = {\n\t.driver = {\n\t\t.name                = \"si2168\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= si2168_probe,\n\t.remove\t\t= si2168_remove,\n\t.id_table\t= si2168_id_table,\n};\n\nmodule_i2c_driver(si2168_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Silicon Labs Si2168 DVB-T/T2/C demodulator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(SI2168_A20_FIRMWARE);\nMODULE_FIRMWARE(SI2168_A30_FIRMWARE);\nMODULE_FIRMWARE(SI2168_B40_FIRMWARE);\nMODULE_FIRMWARE(SI2168_D60_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}