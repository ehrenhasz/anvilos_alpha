{
  "module_name": "as102_fe.c",
  "hash_id": "f47561dc6efe3cede8b0ef9ede545444489911f11b1c7310cbbca3e9a33bd20e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/as102_fe.c",
  "human_readable_source": "\n \n\n#include <media/dvb_frontend.h>\n\n#include \"as102_fe.h\"\n\nstruct as102_state {\n\tstruct dvb_frontend frontend;\n\tstruct as10x_demod_stats demod_stats;\n\n\tconst struct as102_fe_ops *ops;\n\tvoid *priv;\n\tuint8_t elna_cfg;\n\n\t \n\tuint16_t signal_strength;\n\t \n\tuint32_t ber;\n};\n\nstatic uint8_t as102_fe_get_code_rate(enum fe_code_rate arg)\n{\n\tuint8_t c;\n\n\tswitch (arg) {\n\tcase FEC_1_2:\n\t\tc = CODE_RATE_1_2;\n\t\tbreak;\n\tcase FEC_2_3:\n\t\tc = CODE_RATE_2_3;\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tc = CODE_RATE_3_4;\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tc = CODE_RATE_5_6;\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tc = CODE_RATE_7_8;\n\t\tbreak;\n\tdefault:\n\t\tc = CODE_RATE_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn c;\n}\n\nstatic int as102_fe_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct as102_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct as10x_tune_args tune_args = { 0 };\n\n\t \n\ttune_args.freq = c->frequency / 1000;\n\n\t \n\ttune_args.interleaving_mode = INTLV_NATIVE;\n\n\tswitch (c->bandwidth_hz) {\n\tcase 8000000:\n\t\ttune_args.bandwidth = BW_8_MHZ;\n\t\tbreak;\n\tcase 7000000:\n\t\ttune_args.bandwidth = BW_7_MHZ;\n\t\tbreak;\n\tcase 6000000:\n\t\ttune_args.bandwidth = BW_6_MHZ;\n\t\tbreak;\n\tdefault:\n\t\ttune_args.bandwidth = BW_8_MHZ;\n\t}\n\n\tswitch (c->guard_interval) {\n\tcase GUARD_INTERVAL_1_32:\n\t\ttune_args.guard_interval = GUARD_INT_1_32;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_16:\n\t\ttune_args.guard_interval = GUARD_INT_1_16;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_8:\n\t\ttune_args.guard_interval = GUARD_INT_1_8;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_4:\n\t\ttune_args.guard_interval = GUARD_INT_1_4;\n\t\tbreak;\n\tcase GUARD_INTERVAL_AUTO:\n\tdefault:\n\t\ttune_args.guard_interval = GUARD_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tswitch (c->modulation) {\n\tcase QPSK:\n\t\ttune_args.modulation = CONST_QPSK;\n\t\tbreak;\n\tcase QAM_16:\n\t\ttune_args.modulation = CONST_QAM16;\n\t\tbreak;\n\tcase QAM_64:\n\t\ttune_args.modulation = CONST_QAM64;\n\t\tbreak;\n\tdefault:\n\t\ttune_args.modulation = CONST_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tswitch (c->transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\t\ttune_args.transmission_mode = TRANS_MODE_2K;\n\t\tbreak;\n\tcase TRANSMISSION_MODE_8K:\n\t\ttune_args.transmission_mode = TRANS_MODE_8K;\n\t\tbreak;\n\tdefault:\n\t\ttune_args.transmission_mode = TRANS_MODE_UNKNOWN;\n\t}\n\n\tswitch (c->hierarchy) {\n\tcase HIERARCHY_NONE:\n\t\ttune_args.hierarchy = HIER_NONE;\n\t\tbreak;\n\tcase HIERARCHY_1:\n\t\ttune_args.hierarchy = HIER_ALPHA_1;\n\t\tbreak;\n\tcase HIERARCHY_2:\n\t\ttune_args.hierarchy = HIER_ALPHA_2;\n\t\tbreak;\n\tcase HIERARCHY_4:\n\t\ttune_args.hierarchy = HIER_ALPHA_4;\n\t\tbreak;\n\tcase HIERARCHY_AUTO:\n\t\ttune_args.hierarchy = HIER_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tpr_debug(\"as102: tuner parameters: freq: %d  bw: 0x%02x  gi: 0x%02x\\n\",\n\t\t\tc->frequency,\n\t\t\ttune_args.bandwidth,\n\t\t\ttune_args.guard_interval);\n\n\t \n\tif ((tune_args.hierarchy != HIER_NONE) &&\n\t\t       ((c->code_rate_LP == FEC_NONE) ||\n\t\t\t(c->code_rate_HP == FEC_NONE))) {\n\n\t\tif (c->code_rate_LP == FEC_NONE) {\n\t\t\ttune_args.hier_select = HIER_HIGH_PRIORITY;\n\t\t\ttune_args.code_rate =\n\t\t\t   as102_fe_get_code_rate(c->code_rate_HP);\n\t\t}\n\n\t\tif (c->code_rate_HP == FEC_NONE) {\n\t\t\ttune_args.hier_select = HIER_LOW_PRIORITY;\n\t\t\ttune_args.code_rate =\n\t\t\t   as102_fe_get_code_rate(c->code_rate_LP);\n\t\t}\n\n\t\tpr_debug(\"as102: \\thierarchy: 0x%02x  selected: %s  code_rate_%s: 0x%02x\\n\",\n\t\t\ttune_args.hierarchy,\n\t\t\ttune_args.hier_select == HIER_HIGH_PRIORITY ?\n\t\t\t\"HP\" : \"LP\",\n\t\t\ttune_args.hier_select == HIER_HIGH_PRIORITY ?\n\t\t\t\"HP\" : \"LP\",\n\t\t\ttune_args.code_rate);\n\t} else {\n\t\ttune_args.code_rate =\n\t\t\tas102_fe_get_code_rate(c->code_rate_HP);\n\t}\n\n\t \n\treturn state->ops->set_tune(state->priv, &tune_args);\n}\n\nstatic int as102_fe_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t struct dtv_frontend_properties *c)\n{\n\tstruct as102_state *state = fe->demodulator_priv;\n\tint ret = 0;\n\tstruct as10x_tps tps = { 0 };\n\n\t \n\tret = state->ops->get_tps(state->priv, &tps);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tswitch (tps.modulation) {\n\tcase CONST_QPSK:\n\t\tc->modulation = QPSK;\n\t\tbreak;\n\tcase CONST_QAM16:\n\t\tc->modulation = QAM_16;\n\t\tbreak;\n\tcase CONST_QAM64:\n\t\tc->modulation = QAM_64;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (tps.hierarchy) {\n\tcase HIER_NONE:\n\t\tc->hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase HIER_ALPHA_1:\n\t\tc->hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tcase HIER_ALPHA_2:\n\t\tc->hierarchy = HIERARCHY_2;\n\t\tbreak;\n\tcase HIER_ALPHA_4:\n\t\tc->hierarchy = HIERARCHY_4;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (tps.code_rate_HP) {\n\tcase CODE_RATE_1_2:\n\t\tc->code_rate_HP = FEC_1_2;\n\t\tbreak;\n\tcase CODE_RATE_2_3:\n\t\tc->code_rate_HP = FEC_2_3;\n\t\tbreak;\n\tcase CODE_RATE_3_4:\n\t\tc->code_rate_HP = FEC_3_4;\n\t\tbreak;\n\tcase CODE_RATE_5_6:\n\t\tc->code_rate_HP = FEC_5_6;\n\t\tbreak;\n\tcase CODE_RATE_7_8:\n\t\tc->code_rate_HP = FEC_7_8;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (tps.code_rate_LP) {\n\tcase CODE_RATE_1_2:\n\t\tc->code_rate_LP = FEC_1_2;\n\t\tbreak;\n\tcase CODE_RATE_2_3:\n\t\tc->code_rate_LP = FEC_2_3;\n\t\tbreak;\n\tcase CODE_RATE_3_4:\n\t\tc->code_rate_LP = FEC_3_4;\n\t\tbreak;\n\tcase CODE_RATE_5_6:\n\t\tc->code_rate_LP = FEC_5_6;\n\t\tbreak;\n\tcase CODE_RATE_7_8:\n\t\tc->code_rate_LP = FEC_7_8;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (tps.guard_interval) {\n\tcase GUARD_INT_1_32:\n\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase GUARD_INT_1_16:\n\t\tc->guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase GUARD_INT_1_8:\n\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase GUARD_INT_1_4:\n\t\tc->guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (tps.transmission_mode) {\n\tcase TRANS_MODE_2K:\n\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n\tcase TRANS_MODE_8K:\n\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int as102_fe_get_tune_settings(struct dvb_frontend *fe,\n\t\t\tstruct dvb_frontend_tune_settings *settings)\n{\n\n\tsettings->min_delay_ms = 1000;\n\n\treturn 0;\n}\n\nstatic int as102_fe_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tint ret = 0;\n\tstruct as102_state *state = fe->demodulator_priv;\n\tstruct as10x_tune_status tstate = { 0 };\n\n\t \n\tret = state->ops->get_status(state->priv, &tstate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstate->signal_strength  = tstate.signal_strength;\n\tstate->ber  = tstate.BER;\n\n\tswitch (tstate.tune_state) {\n\tcase TUNE_STATUS_SIGNAL_DVB_OK:\n\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\t\tbreak;\n\tcase TUNE_STATUS_STREAM_DETECTED:\n\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_SYNC |\n\t\t\t  FE_HAS_VITERBI;\n\t\tbreak;\n\tcase TUNE_STATUS_STREAM_TUNED:\n\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_SYNC |\n\t\t\t  FE_HAS_LOCK | FE_HAS_VITERBI;\n\t\tbreak;\n\tdefault:\n\t\t*status = TUNE_STATUS_NOT_TUNED;\n\t}\n\n\tpr_debug(\"as102: tuner status: 0x%02x, strength %d, per: %d, ber: %d\\n\",\n\t\t tstate.tune_state, tstate.signal_strength,\n\t\t tstate.PER, tstate.BER);\n\n\tif (!(*status & FE_HAS_LOCK)) {\n\t\tmemset(&state->demod_stats, 0, sizeof(state->demod_stats));\n\t\treturn 0;\n\t}\n\n\tret = state->ops->get_stats(state->priv, &state->demod_stats);\n\tif (ret < 0)\n\t\tmemset(&state->demod_stats, 0, sizeof(state->demod_stats));\n\n\treturn ret;\n}\n\n \nstatic int as102_fe_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct as102_state *state = fe->demodulator_priv;\n\n\t*snr = state->demod_stats.mer;\n\n\treturn 0;\n}\n\nstatic int as102_fe_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct as102_state *state = fe->demodulator_priv;\n\n\t*ber = state->ber;\n\n\treturn 0;\n}\n\nstatic int as102_fe_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t\t u16 *strength)\n{\n\tstruct as102_state *state = fe->demodulator_priv;\n\n\t*strength = (((0xffff * 400) * state->signal_strength + 41000) * 2);\n\n\treturn 0;\n}\n\nstatic int as102_fe_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct as102_state *state = fe->demodulator_priv;\n\n\tif (state->demod_stats.has_started)\n\t\t*ucblocks = state->demod_stats.bad_frame_count;\n\telse\n\t\t*ucblocks = 0;\n\n\treturn 0;\n}\n\nstatic int as102_fe_ts_bus_ctrl(struct dvb_frontend *fe, int acquire)\n{\n\tstruct as102_state *state = fe->demodulator_priv;\n\n\treturn state->ops->stream_ctrl(state->priv, acquire,\n\t\t\t\t      state->elna_cfg);\n}\n\nstatic void as102_fe_release(struct dvb_frontend *fe)\n{\n\tstruct as102_state *state = fe->demodulator_priv;\n\n\tkfree(state);\n}\n\n\nstatic const struct dvb_frontend_ops as102_fe_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name\t\t\t= \"Abilis AS102 DVB-T\",\n\t\t.frequency_min_hz\t= 174 * MHz,\n\t\t.frequency_max_hz\t= 862 * MHz,\n\t\t.frequency_stepsize_hz\t= 166667,\n\t\t.caps = FE_CAN_INVERSION_AUTO\n\t\t\t| FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4\n\t\t\t| FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO\n\t\t\t| FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QPSK\n\t\t\t| FE_CAN_QAM_AUTO\n\t\t\t| FE_CAN_TRANSMISSION_MODE_AUTO\n\t\t\t| FE_CAN_GUARD_INTERVAL_AUTO\n\t\t\t| FE_CAN_HIERARCHY_AUTO\n\t\t\t| FE_CAN_RECOVER\n\t\t\t| FE_CAN_MUTE_TS\n\t},\n\n\t.set_frontend\t\t= as102_fe_set_frontend,\n\t.get_frontend\t\t= as102_fe_get_frontend,\n\t.get_tune_settings\t= as102_fe_get_tune_settings,\n\n\t.read_status\t\t= as102_fe_read_status,\n\t.read_snr\t\t= as102_fe_read_snr,\n\t.read_ber\t\t= as102_fe_read_ber,\n\t.read_signal_strength\t= as102_fe_read_signal_strength,\n\t.read_ucblocks\t\t= as102_fe_read_ucblocks,\n\t.ts_bus_ctrl\t\t= as102_fe_ts_bus_ctrl,\n\t.release\t\t= as102_fe_release,\n};\n\nstruct dvb_frontend *as102_attach(const char *name,\n\t\t\t\t  const struct as102_fe_ops *ops,\n\t\t\t\t  void *priv,\n\t\t\t\t  uint8_t elna_cfg)\n{\n\tstruct as102_state *state;\n\tstruct dvb_frontend *fe;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tfe = &state->frontend;\n\tfe->demodulator_priv = state;\n\tstate->ops = ops;\n\tstate->priv = priv;\n\tstate->elna_cfg = elna_cfg;\n\n\t \n\tmemcpy(&fe->ops, &as102_fe_ops, sizeof(struct dvb_frontend_ops));\n\tstrscpy(fe->ops.info.name, name, sizeof(fe->ops.info.name));\n\n\treturn fe;\n\n}\nEXPORT_SYMBOL_GPL(as102_attach);\n\nMODULE_DESCRIPTION(\"as102-fe\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pierrick Hascoet <pierrick.hascoet@abilis.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}