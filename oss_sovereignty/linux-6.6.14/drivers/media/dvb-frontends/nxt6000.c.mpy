{
  "module_name": "nxt6000.c",
  "hash_id": "aa2f56924a4091c5fa1bd2b0abe34b74c8baafd9941b74ccf36c17d9302cf258",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/nxt6000.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"nxt6000_priv.h\"\n#include \"nxt6000.h\"\n\n\n\nstruct nxt6000_state {\n\tstruct i2c_adapter* i2c;\n\t \n\tconst struct nxt6000_config* config;\n\tstruct dvb_frontend frontend;\n};\n\nstatic int debug;\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\nstatic int nxt6000_writereg(struct nxt6000_state* state, u8 reg, u8 data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = {.addr = state->config->demod_address,.flags = 0,.buf = buf,.len = 2 };\n\tint ret;\n\n\tif ((ret = i2c_transfer(state->i2c, &msg, 1)) != 1)\n\t\tdprintk(\"nxt6000: nxt6000_write error (reg: 0x%02X, data: 0x%02X, ret: %d)\\n\", reg, data, ret);\n\n\treturn (ret != 1) ? -EIO : 0;\n}\n\nstatic u8 nxt6000_readreg(struct nxt6000_state* state, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msgs[] = {\n\t\t{.addr = state->config->demod_address,.flags = 0,.buf = b0,.len = 1},\n\t\t{.addr = state->config->demod_address,.flags = I2C_M_RD,.buf = b1,.len = 1}\n\t};\n\n\tret = i2c_transfer(state->i2c, msgs, 2);\n\n\tif (ret != 2)\n\t\tdprintk(\"nxt6000: nxt6000_read error (reg: 0x%02X, ret: %d)\\n\", reg, ret);\n\n\treturn b1[0];\n}\n\nstatic void nxt6000_reset(struct nxt6000_state* state)\n{\n\tu8 val;\n\n\tval = nxt6000_readreg(state, OFDM_COR_CTL);\n\n\tnxt6000_writereg(state, OFDM_COR_CTL, val & ~COREACT);\n\tnxt6000_writereg(state, OFDM_COR_CTL, val | COREACT);\n}\n\nstatic int nxt6000_set_bandwidth(struct nxt6000_state *state, u32 bandwidth)\n{\n\tu16 nominal_rate;\n\tint result;\n\n\tswitch (bandwidth) {\n\tcase 6000000:\n\t\tnominal_rate = 0x55B7;\n\t\tbreak;\n\n\tcase 7000000:\n\t\tnominal_rate = 0x6400;\n\t\tbreak;\n\n\tcase 8000000:\n\t\tnominal_rate = 0x7249;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((result = nxt6000_writereg(state, OFDM_TRL_NOMINALRATE_1, nominal_rate & 0xFF)) < 0)\n\t\treturn result;\n\n\treturn nxt6000_writereg(state, OFDM_TRL_NOMINALRATE_2, (nominal_rate >> 8) & 0xFF);\n}\n\nstatic int nxt6000_set_guard_interval(struct nxt6000_state *state,\n\t\t\t\t      enum fe_guard_interval guard_interval)\n{\n\tswitch (guard_interval) {\n\n\tcase GUARD_INTERVAL_1_32:\n\t\treturn nxt6000_writereg(state, OFDM_COR_MODEGUARD, 0x00 | (nxt6000_readreg(state, OFDM_COR_MODEGUARD) & ~0x03));\n\n\tcase GUARD_INTERVAL_1_16:\n\t\treturn nxt6000_writereg(state, OFDM_COR_MODEGUARD, 0x01 | (nxt6000_readreg(state, OFDM_COR_MODEGUARD) & ~0x03));\n\n\tcase GUARD_INTERVAL_AUTO:\n\tcase GUARD_INTERVAL_1_8:\n\t\treturn nxt6000_writereg(state, OFDM_COR_MODEGUARD, 0x02 | (nxt6000_readreg(state, OFDM_COR_MODEGUARD) & ~0x03));\n\n\tcase GUARD_INTERVAL_1_4:\n\t\treturn nxt6000_writereg(state, OFDM_COR_MODEGUARD, 0x03 | (nxt6000_readreg(state, OFDM_COR_MODEGUARD) & ~0x03));\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nxt6000_set_inversion(struct nxt6000_state *state,\n\t\t\t\t enum fe_spectral_inversion inversion)\n{\n\tswitch (inversion) {\n\n\tcase INVERSION_OFF:\n\t\treturn nxt6000_writereg(state, OFDM_ITB_CTL, 0x00);\n\n\tcase INVERSION_ON:\n\t\treturn nxt6000_writereg(state, OFDM_ITB_CTL, ITBINV);\n\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n}\n\nstatic int\nnxt6000_set_transmission_mode(struct nxt6000_state *state,\n\t\t\t      enum fe_transmit_mode transmission_mode)\n{\n\tint result;\n\n\tswitch (transmission_mode) {\n\n\tcase TRANSMISSION_MODE_2K:\n\t\tif ((result = nxt6000_writereg(state, EN_DMD_RACQ, 0x00 | (nxt6000_readreg(state, EN_DMD_RACQ) & ~0x03))) < 0)\n\t\t\treturn result;\n\n\t\treturn nxt6000_writereg(state, OFDM_COR_MODEGUARD, (0x00 << 2) | (nxt6000_readreg(state, OFDM_COR_MODEGUARD) & ~0x04));\n\n\tcase TRANSMISSION_MODE_8K:\n\tcase TRANSMISSION_MODE_AUTO:\n\t\tif ((result = nxt6000_writereg(state, EN_DMD_RACQ, 0x02 | (nxt6000_readreg(state, EN_DMD_RACQ) & ~0x03))) < 0)\n\t\t\treturn result;\n\n\t\treturn nxt6000_writereg(state, OFDM_COR_MODEGUARD, (0x01 << 2) | (nxt6000_readreg(state, OFDM_COR_MODEGUARD) & ~0x04));\n\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n}\n\nstatic void nxt6000_setup(struct dvb_frontend* fe)\n{\n\tstruct nxt6000_state* state = fe->demodulator_priv;\n\n\tnxt6000_writereg(state, RS_COR_SYNC_PARAM, SYNC_PARAM);\n\tnxt6000_writereg(state, BER_CTRL,   (0x01 << 1) | 0x01);\n\tnxt6000_writereg(state, VIT_BERTIME_2, 0x00);  \n\tnxt6000_writereg(state, VIT_BERTIME_1, 0x02);  \n\tnxt6000_writereg(state, VIT_BERTIME_0, 0x00);  \n\tnxt6000_writereg(state, VIT_COR_INTEN, 0x98); \n\tnxt6000_writereg(state, VIT_COR_CTL, 0x82);   \n\tnxt6000_writereg(state, VIT_COR_CTL, VIT_COR_RESYNC | 0x02 );\n\tnxt6000_writereg(state, OFDM_COR_CTL, (0x01 << 5) | (nxt6000_readreg(state, OFDM_COR_CTL) & 0x0F));\n\tnxt6000_writereg(state, OFDM_COR_MODEGUARD, FORCEMODE8K | 0x02);\n\tnxt6000_writereg(state, OFDM_AGC_CTL, AGCLAST | INITIAL_AGC_BW);\n\tnxt6000_writereg(state, OFDM_ITB_FREQ_1, 0x06);\n\tnxt6000_writereg(state, OFDM_ITB_FREQ_2, 0x31);\n\tnxt6000_writereg(state, OFDM_CAS_CTL, (0x01 << 7) | (0x02 << 3) | 0x04);\n\tnxt6000_writereg(state, CAS_FREQ, 0xBB);\t \n\tnxt6000_writereg(state, OFDM_SYR_CTL, 1 << 2);\n\tnxt6000_writereg(state, OFDM_PPM_CTL_1, PPM256);\n\tnxt6000_writereg(state, OFDM_TRL_NOMINALRATE_1, 0x49);\n\tnxt6000_writereg(state, OFDM_TRL_NOMINALRATE_2, 0x72);\n\tnxt6000_writereg(state, ANALOG_CONTROL_0, 1 << 5);\n\tnxt6000_writereg(state, EN_DMD_RACQ, (1 << 7) | (3 << 4) | 2);\n\tnxt6000_writereg(state, DIAG_CONFIG, TB_SET);\n\n\tif (state->config->clock_inversion)\n\t\tnxt6000_writereg(state, SUB_DIAG_MODE_SEL, CLKINVERSION);\n\telse\n\t\tnxt6000_writereg(state, SUB_DIAG_MODE_SEL, 0);\n\n\tnxt6000_writereg(state, TS_FORMAT, 0);\n}\n\nstatic void nxt6000_dump_status(struct nxt6000_state *state)\n{\n\tu8 val;\n\n#if 0\n\tpr_info(\"RS_COR_STAT: 0x%02X\\n\",\n\t\tnxt6000_readreg(fe, RS_COR_STAT));\n\tpr_info(\"VIT_SYNC_STATUS: 0x%02X\\n\",\n\t\tnxt6000_readreg(fe, VIT_SYNC_STATUS));\n\tpr_info(\"OFDM_COR_STAT: 0x%02X\\n\",\n\t\tnxt6000_readreg(fe, OFDM_COR_STAT));\n\tpr_info(\"OFDM_SYR_STAT: 0x%02X\\n\",\n\t\tnxt6000_readreg(fe, OFDM_SYR_STAT));\n\tpr_info(\"OFDM_TPS_RCVD_1: 0x%02X\\n\",\n\t\tnxt6000_readreg(fe, OFDM_TPS_RCVD_1));\n\tpr_info(\"OFDM_TPS_RCVD_2: 0x%02X\\n\",\n\t\tnxt6000_readreg(fe, OFDM_TPS_RCVD_2));\n\tpr_info(\"OFDM_TPS_RCVD_3: 0x%02X\\n\",\n\t\tnxt6000_readreg(fe, OFDM_TPS_RCVD_3));\n\tpr_info(\"OFDM_TPS_RCVD_4: 0x%02X\\n\",\n\t\tnxt6000_readreg(fe, OFDM_TPS_RCVD_4));\n\tpr_info(\"OFDM_TPS_RESERVED_1: 0x%02X\\n\",\n\t\tnxt6000_readreg(fe, OFDM_TPS_RESERVED_1));\n\tpr_info(\"OFDM_TPS_RESERVED_2: 0x%02X\\n\",\n\t\tnxt6000_readreg(fe, OFDM_TPS_RESERVED_2));\n#endif\n\tpr_info(\"NXT6000 status:\");\n\n\tval = nxt6000_readreg(state, RS_COR_STAT);\n\n\tpr_cont(\" DATA DESCR LOCK: %d,\", val & 0x01);\n\tpr_cont(\" DATA SYNC LOCK: %d,\", (val >> 1) & 0x01);\n\n\tval = nxt6000_readreg(state, VIT_SYNC_STATUS);\n\n\tpr_cont(\" VITERBI LOCK: %d,\", (val >> 7) & 0x01);\n\n\tswitch ((val >> 4) & 0x07) {\n\n\tcase 0x00:\n\t\tpr_cont(\" VITERBI CODERATE: 1/2,\");\n\t\tbreak;\n\n\tcase 0x01:\n\t\tpr_cont(\" VITERBI CODERATE: 2/3,\");\n\t\tbreak;\n\n\tcase 0x02:\n\t\tpr_cont(\" VITERBI CODERATE: 3/4,\");\n\t\tbreak;\n\n\tcase 0x03:\n\t\tpr_cont(\" VITERBI CODERATE: 5/6,\");\n\t\tbreak;\n\n\tcase 0x04:\n\t\tpr_cont(\" VITERBI CODERATE: 7/8,\");\n\t\tbreak;\n\n\tdefault:\n\t\tpr_cont(\" VITERBI CODERATE: Reserved,\");\n\n\t}\n\n\tval = nxt6000_readreg(state, OFDM_COR_STAT);\n\n\tpr_cont(\" CHCTrack: %d,\", (val >> 7) & 0x01);\n\tpr_cont(\" TPSLock: %d,\", (val >> 6) & 0x01);\n\tpr_cont(\" SYRLock: %d,\", (val >> 5) & 0x01);\n\tpr_cont(\" AGCLock: %d,\", (val >> 4) & 0x01);\n\n\tswitch (val & 0x0F) {\n\n\tcase 0x00:\n\t\tpr_cont(\" CoreState: IDLE,\");\n\t\tbreak;\n\n\tcase 0x02:\n\t\tpr_cont(\" CoreState: WAIT_AGC,\");\n\t\tbreak;\n\n\tcase 0x03:\n\t\tpr_cont(\" CoreState: WAIT_SYR,\");\n\t\tbreak;\n\n\tcase 0x04:\n\t\tpr_cont(\" CoreState: WAIT_PPM,\");\n\t\tbreak;\n\n\tcase 0x01:\n\t\tpr_cont(\" CoreState: WAIT_TRL,\");\n\t\tbreak;\n\n\tcase 0x05:\n\t\tpr_cont(\" CoreState: WAIT_TPS,\");\n\t\tbreak;\n\n\tcase 0x06:\n\t\tpr_cont(\" CoreState: MONITOR_TPS,\");\n\t\tbreak;\n\n\tdefault:\n\t\tpr_cont(\" CoreState: Reserved,\");\n\n\t}\n\n\tval = nxt6000_readreg(state, OFDM_SYR_STAT);\n\n\tpr_cont(\" SYRLock: %d,\", (val >> 4) & 0x01);\n\tpr_cont(\" SYRMode: %s,\", (val >> 2) & 0x01 ? \"8K\" : \"2K\");\n\n\tswitch ((val >> 4) & 0x03) {\n\n\tcase 0x00:\n\t\tpr_cont(\" SYRGuard: 1/32,\");\n\t\tbreak;\n\n\tcase 0x01:\n\t\tpr_cont(\" SYRGuard: 1/16,\");\n\t\tbreak;\n\n\tcase 0x02:\n\t\tpr_cont(\" SYRGuard: 1/8,\");\n\t\tbreak;\n\n\tcase 0x03:\n\t\tpr_cont(\" SYRGuard: 1/4,\");\n\t\tbreak;\n\t}\n\n\tval = nxt6000_readreg(state, OFDM_TPS_RCVD_3);\n\n\tswitch ((val >> 4) & 0x07) {\n\n\tcase 0x00:\n\t\tpr_cont(\" TPSLP: 1/2,\");\n\t\tbreak;\n\n\tcase 0x01:\n\t\tpr_cont(\" TPSLP: 2/3,\");\n\t\tbreak;\n\n\tcase 0x02:\n\t\tpr_cont(\" TPSLP: 3/4,\");\n\t\tbreak;\n\n\tcase 0x03:\n\t\tpr_cont(\" TPSLP: 5/6,\");\n\t\tbreak;\n\n\tcase 0x04:\n\t\tpr_cont(\" TPSLP: 7/8,\");\n\t\tbreak;\n\n\tdefault:\n\t\tpr_cont(\" TPSLP: Reserved,\");\n\n\t}\n\n\tswitch (val & 0x07) {\n\n\tcase 0x00:\n\t\tpr_cont(\" TPSHP: 1/2,\");\n\t\tbreak;\n\n\tcase 0x01:\n\t\tpr_cont(\" TPSHP: 2/3,\");\n\t\tbreak;\n\n\tcase 0x02:\n\t\tpr_cont(\" TPSHP: 3/4,\");\n\t\tbreak;\n\n\tcase 0x03:\n\t\tpr_cont(\" TPSHP: 5/6,\");\n\t\tbreak;\n\n\tcase 0x04:\n\t\tpr_cont(\" TPSHP: 7/8,\");\n\t\tbreak;\n\n\tdefault:\n\t\tpr_cont(\" TPSHP: Reserved,\");\n\n\t}\n\n\tval = nxt6000_readreg(state, OFDM_TPS_RCVD_4);\n\n\tpr_cont(\" TPSMode: %s,\", val & 0x01 ? \"8K\" : \"2K\");\n\n\tswitch ((val >> 4) & 0x03) {\n\n\tcase 0x00:\n\t\tpr_cont(\" TPSGuard: 1/32,\");\n\t\tbreak;\n\n\tcase 0x01:\n\t\tpr_cont(\" TPSGuard: 1/16,\");\n\t\tbreak;\n\n\tcase 0x02:\n\t\tpr_cont(\" TPSGuard: 1/8,\");\n\t\tbreak;\n\n\tcase 0x03:\n\t\tpr_cont(\" TPSGuard: 1/4,\");\n\t\tbreak;\n\n\t}\n\n\t \n\tnxt6000_readreg(state, RF_AGC_VAL_1);\n\tval = nxt6000_readreg(state, RF_AGC_STATUS);\n\tval = nxt6000_readreg(state, RF_AGC_STATUS);\n\n\tpr_cont(\" RF AGC LOCK: %d,\", (val >> 4) & 0x01);\n\tpr_cont(\"\\n\");\n}\n\nstatic int nxt6000_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tu8 core_status;\n\tstruct nxt6000_state* state = fe->demodulator_priv;\n\n\t*status = 0;\n\n\tcore_status = nxt6000_readreg(state, OFDM_COR_STAT);\n\n\tif (core_status & AGCLOCKED)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (nxt6000_readreg(state, OFDM_SYR_STAT) & GI14_SYR_LOCK)\n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (nxt6000_readreg(state, VIT_SYNC_STATUS) & VITINSYNC)\n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (nxt6000_readreg(state, RS_COR_STAT) & RSCORESTATUS)\n\t\t*status |= FE_HAS_SYNC;\n\n\tif ((core_status & TPSLOCKED) && (*status == (FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC)))\n\t\t*status |= FE_HAS_LOCK;\n\n\tif (debug)\n\t\tnxt6000_dump_status(state);\n\n\treturn 0;\n}\n\nstatic int nxt6000_init(struct dvb_frontend* fe)\n{\n\tstruct nxt6000_state* state = fe->demodulator_priv;\n\n\tnxt6000_reset(state);\n\tnxt6000_setup(fe);\n\n\treturn 0;\n}\n\nstatic int nxt6000_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct nxt6000_state* state = fe->demodulator_priv;\n\tint result;\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tresult = nxt6000_set_bandwidth(state, p->bandwidth_hz);\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = nxt6000_set_guard_interval(state, p->guard_interval);\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = nxt6000_set_transmission_mode(state, p->transmission_mode);\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = nxt6000_set_inversion(state, p->inversion);\n\tif (result < 0)\n\t\treturn result;\n\n\tmsleep(500);\n\treturn 0;\n}\n\nstatic void nxt6000_release(struct dvb_frontend* fe)\n{\n\tstruct nxt6000_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic int nxt6000_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct nxt6000_state* state = fe->demodulator_priv;\n\n\t*snr = nxt6000_readreg( state, OFDM_CHC_SNR) / 8;\n\n\treturn 0;\n}\n\nstatic int nxt6000_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct nxt6000_state* state = fe->demodulator_priv;\n\n\tnxt6000_writereg( state, VIT_COR_INTSTAT, 0x18 );\n\n\t*ber = (nxt6000_readreg( state, VIT_BER_1 ) << 8 ) |\n\t\tnxt6000_readreg( state, VIT_BER_0 );\n\n\tnxt6000_writereg( state, VIT_COR_INTSTAT, 0x18); \n\n\treturn 0;\n}\n\nstatic int nxt6000_read_signal_strength(struct dvb_frontend* fe, u16* signal_strength)\n{\n\tstruct nxt6000_state* state = fe->demodulator_priv;\n\n\t*signal_strength = (short) (511 -\n\t\t(nxt6000_readreg(state, AGC_GAIN_1) +\n\t\t((nxt6000_readreg(state, AGC_GAIN_2) & 0x03) << 8)));\n\n\treturn 0;\n}\n\nstatic int nxt6000_fe_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 500;\n\treturn 0;\n}\n\nstatic int nxt6000_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\n{\n\tstruct nxt6000_state* state = fe->demodulator_priv;\n\n\tif (enable) {\n\t\treturn nxt6000_writereg(state, ENABLE_TUNER_IIC, 0x01);\n\t} else {\n\t\treturn nxt6000_writereg(state, ENABLE_TUNER_IIC, 0x00);\n\t}\n}\n\nstatic const struct dvb_frontend_ops nxt6000_ops;\n\nstruct dvb_frontend* nxt6000_attach(const struct nxt6000_config* config,\n\t\t\t\t    struct i2c_adapter* i2c)\n{\n\tstruct nxt6000_state* state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct nxt6000_state), GFP_KERNEL);\n\tif (state == NULL) goto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t \n\tif (nxt6000_readreg(state, OFDM_MSC_REV) != NXT6000ASICDEVICE) goto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &nxt6000_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops nxt6000_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name = \"NxtWave NXT6000 DVB-T\",\n\t\t.frequency_min_hz = 0,\n\t\t.frequency_max_hz = 863250 * kHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t \n\t\t.symbol_rate_max = 9360000,\t \n\t\t.symbol_rate_tolerance = 4000,\n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |\n\t\t\tFE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO,\n\t},\n\n\t.release = nxt6000_release,\n\n\t.init = nxt6000_init,\n\t.i2c_gate_ctrl = nxt6000_i2c_gate_ctrl,\n\n\t.get_tune_settings = nxt6000_fe_get_tune_settings,\n\n\t.set_frontend = nxt6000_set_frontend,\n\n\t.read_status = nxt6000_read_status,\n\t.read_ber = nxt6000_read_ber,\n\t.read_signal_strength = nxt6000_read_signal_strength,\n\t.read_snr = nxt6000_read_snr,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"NxtWave NXT6000 DVB-T demodulator driver\");\nMODULE_AUTHOR(\"Florian Schirmer\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(nxt6000_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}