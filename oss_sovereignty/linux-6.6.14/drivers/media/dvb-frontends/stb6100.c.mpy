{
  "module_name": "stb6100.c",
  "hash_id": "656eb5cbc0cf15ad7ba7bd423e347a60da78f513ab20aff0d12fb105076350a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stb6100.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <media/dvb_frontend.h>\n#include \"stb6100.h\"\n\nstatic unsigned int verbose;\nmodule_param(verbose, int, 0644);\n\n \n#define MAX_XFER_SIZE  64\n\n#define FE_ERROR\t\t0\n#define FE_NOTICE\t\t1\n#define FE_INFO\t\t\t2\n#define FE_DEBUG\t\t3\n\n#define dprintk(x, y, z, format, arg...) do {\t\t\t\t\t\t\\\n\tif (z) {\t\t\t\t\t\t\t\t\t\\\n\t\tif\t((x > FE_ERROR) && (x > y))\t\t\t\t\t\\\n\t\t\tprintk(KERN_ERR \"%s: \" format \"\\n\", __func__ , ##arg);\t\t\\\n\t\telse if\t((x > FE_NOTICE) && (x > y))\t\t\t\t\t\\\n\t\t\tprintk(KERN_NOTICE \"%s: \" format \"\\n\", __func__ , ##arg);\t\\\n\t\telse if ((x > FE_INFO) && (x > y))\t\t\t\t\t\\\n\t\t\tprintk(KERN_INFO \"%s: \" format \"\\n\", __func__ , ##arg);\t\t\\\n\t\telse if ((x > FE_DEBUG) && (x > y))\t\t\t\t\t\\\n\t\t\tprintk(KERN_DEBUG \"%s: \" format \"\\n\", __func__ , ##arg);\t\\\n\t} else {\t\t\t\t\t\t\t\t\t\\\n\t\tif (x > y)\t\t\t\t\t\t\t\t\\\n\t\t\tprintk(format, ##arg);\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\nstruct stb6100_lkup {\n\tu32 val_low;\n\tu32 val_high;\n\tu8   reg;\n};\n\nstatic void stb6100_release(struct dvb_frontend *fe);\n\nstatic const struct stb6100_lkup lkup[] = {\n\t{       0,  950000, 0x0a },\n\t{  950000, 1000000, 0x0a },\n\t{ 1000000, 1075000, 0x0c },\n\t{ 1075000, 1200000, 0x00 },\n\t{ 1200000, 1300000, 0x01 },\n\t{ 1300000, 1370000, 0x02 },\n\t{ 1370000, 1470000, 0x04 },\n\t{ 1470000, 1530000, 0x05 },\n\t{ 1530000, 1650000, 0x06 },\n\t{ 1650000, 1800000, 0x08 },\n\t{ 1800000, 1950000, 0x0a },\n\t{ 1950000, 2150000, 0x0c },\n\t{ 2150000, 9999999, 0x0c },\n\t{       0,       0, 0x00 }\n};\n\n \nstatic const char *stb6100_regnames[] = {\n\t[STB6100_LD]\t\t= \"LD\",\n\t[STB6100_VCO]\t\t= \"VCO\",\n\t[STB6100_NI]\t\t= \"NI\",\n\t[STB6100_NF_LSB]\t= \"NF\",\n\t[STB6100_K]\t\t= \"K\",\n\t[STB6100_G]\t\t= \"G\",\n\t[STB6100_F]\t\t= \"F\",\n\t[STB6100_DLB]\t\t= \"DLB\",\n\t[STB6100_TEST1]\t\t= \"TEST1\",\n\t[STB6100_FCCK]\t\t= \"FCCK\",\n\t[STB6100_LPEN]\t\t= \"LPEN\",\n\t[STB6100_TEST3]\t\t= \"TEST3\",\n};\n\n \nstruct stb6100_regmask {\n\tu8 mask;\n\tu8 set;\n};\n\nstatic const struct stb6100_regmask stb6100_template[] = {\n\t[STB6100_LD]\t\t= { 0xff, 0x00 },\n\t[STB6100_VCO]\t\t= { 0xff, 0x00 },\n\t[STB6100_NI]\t\t= { 0xff, 0x00 },\n\t[STB6100_NF_LSB]\t= { 0xff, 0x00 },\n\t[STB6100_K]\t\t= { 0xc7, 0x38 },\n\t[STB6100_G]\t\t= { 0xef, 0x10 },\n\t[STB6100_F]\t\t= { 0x1f, 0xc0 },\n\t[STB6100_DLB]\t\t= { 0x38, 0xc4 },\n\t[STB6100_TEST1]\t\t= { 0x00, 0x8f },\n\t[STB6100_FCCK]\t\t= { 0x40, 0x0d },\n\t[STB6100_LPEN]\t\t= { 0xf0, 0x0b },\n\t[STB6100_TEST3]\t\t= { 0x00, 0xde },\n};\n\n \nstatic __always_unused inline void stb6100_normalise_regs(u8 regs[])\n{\n\tint i;\n\n\tfor (i = 0; i < STB6100_NUMREGS; i++)\n\t\tregs[i] = (regs[i] & stb6100_template[i].mask) | stb6100_template[i].set;\n}\n\nstatic int stb6100_read_regs(struct stb6100_state *state, u8 regs[])\n{\n\tint rc;\n\tstruct i2c_msg msg = {\n\t\t.addr\t= state->config->tuner_address,\n\t\t.flags\t= I2C_M_RD,\n\t\t.buf\t= regs,\n\t\t.len\t= STB6100_NUMREGS\n\t};\n\n\trc = i2c_transfer(state->i2c, &msg, 1);\n\tif (unlikely(rc != 1)) {\n\t\tdprintk(verbose, FE_ERROR, 1, \"Read (0x%x) err, rc=[%d]\",\n\t\t\tstate->config->tuner_address, rc);\n\n\t\treturn -EREMOTEIO;\n\t}\n\tif (unlikely(verbose > FE_DEBUG)) {\n\t\tint i;\n\n\t\tdprintk(verbose, FE_DEBUG, 1, \"    Read from 0x%02x\", state->config->tuner_address);\n\t\tfor (i = 0; i < STB6100_NUMREGS; i++)\n\t\t\tdprintk(verbose, FE_DEBUG, 1, \"        %s: 0x%02x\", stb6100_regnames[i], regs[i]);\n\t}\n\treturn 0;\n}\n\nstatic int stb6100_read_reg(struct stb6100_state *state, u8 reg)\n{\n\tu8 regs[STB6100_NUMREGS];\n\n\tstruct i2c_msg msg = {\n\t\t.addr\t= state->config->tuner_address + reg,\n\t\t.flags\t= I2C_M_RD,\n\t\t.buf\t= regs,\n\t\t.len\t= 1\n\t};\n\n\ti2c_transfer(state->i2c, &msg, 1);\n\n\tif (unlikely(reg >= STB6100_NUMREGS)) {\n\t\tdprintk(verbose, FE_ERROR, 1, \"Invalid register offset 0x%x\", reg);\n\t\treturn -EINVAL;\n\t}\n\tif (unlikely(verbose > FE_DEBUG)) {\n\t\tdprintk(verbose, FE_DEBUG, 1, \"    Read from 0x%02x\", state->config->tuner_address);\n\t\tdprintk(verbose, FE_DEBUG, 1, \"        %s: 0x%02x\", stb6100_regnames[reg], regs[0]);\n\t}\n\n\treturn (unsigned int)regs[0];\n}\n\nstatic int stb6100_write_reg_range(struct stb6100_state *state, u8 buf[], int start, int len)\n{\n\tint rc;\n\tu8 cmdbuf[MAX_XFER_SIZE];\n\tstruct i2c_msg msg = {\n\t\t.addr\t= state->config->tuner_address,\n\t\t.flags\t= 0,\n\t\t.buf\t= cmdbuf,\n\t\t.len\t= len + 1\n\t};\n\n\tif (1 + len > sizeof(cmdbuf)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: i2c wr: len=%d is too big!\\n\",\n\t\t       KBUILD_MODNAME, len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(start < 1 || start + len > STB6100_NUMREGS)) {\n\t\tdprintk(verbose, FE_ERROR, 1, \"Invalid register range %d:%d\",\n\t\t\tstart, len);\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(&cmdbuf[1], buf, len);\n\tcmdbuf[0] = start;\n\n\tif (unlikely(verbose > FE_DEBUG)) {\n\t\tint i;\n\n\t\tdprintk(verbose, FE_DEBUG, 1, \"    Write @ 0x%02x: [%d:%d]\", state->config->tuner_address, start, len);\n\t\tfor (i = 0; i < len; i++)\n\t\t\tdprintk(verbose, FE_DEBUG, 1, \"        %s: 0x%02x\", stb6100_regnames[start + i], buf[i]);\n\t}\n\trc = i2c_transfer(state->i2c, &msg, 1);\n\tif (unlikely(rc != 1)) {\n\t\tdprintk(verbose, FE_ERROR, 1, \"(0x%x) write err [%d:%d], rc=[%d]\",\n\t\t\t(unsigned int)state->config->tuner_address, start, len,\trc);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int stb6100_write_reg(struct stb6100_state *state, u8 reg, u8 data)\n{\n\tu8 tmp = data;  \n\n\tif (unlikely(reg >= STB6100_NUMREGS)) {\n\t\tdprintk(verbose, FE_ERROR, 1, \"Invalid register offset 0x%x\", reg);\n\t\treturn -EREMOTEIO;\n\t}\n\ttmp = (tmp & stb6100_template[reg].mask) | stb6100_template[reg].set;\n\treturn stb6100_write_reg_range(state, &tmp, reg, 1);\n}\n\n\nstatic int stb6100_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tint rc;\n\tstruct stb6100_state *state = fe->tuner_priv;\n\n\trc = stb6100_read_reg(state, STB6100_LD);\n\tif (rc < 0) {\n\t\tdprintk(verbose, FE_ERROR, 1, \"%s failed\", __func__);\n\t\treturn rc;\n\t}\n\treturn (rc & STB6100_LD_LOCK) ? TUNER_STATUS_LOCKED : 0;\n}\n\nstatic int stb6100_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tint rc;\n\tu8 f;\n\tu32 bw;\n\tstruct stb6100_state *state = fe->tuner_priv;\n\n\trc = stb6100_read_reg(state, STB6100_F);\n\tif (rc < 0)\n\t\treturn rc;\n\tf = rc & STB6100_F_F;\n\n\tbw = (f + 5) * 2000;\t \n\n\t*bandwidth = state->bandwidth = bw * 1000;\n\tdprintk(verbose, FE_DEBUG, 1, \"bandwidth = %u Hz\", state->bandwidth);\n\treturn 0;\n}\n\nstatic int stb6100_set_bandwidth(struct dvb_frontend *fe, u32 bandwidth)\n{\n\tu32 tmp;\n\tint rc;\n\tstruct stb6100_state *state = fe->tuner_priv;\n\n\tdprintk(verbose, FE_DEBUG, 1, \"set bandwidth to %u Hz\", bandwidth);\n\n\tbandwidth /= 2;  \n\n\tif (bandwidth >= 36000000)\t \n\t\ttmp = 31;\n\telse if (bandwidth <= 5000000)\t \n\t\ttmp = 0;\n\telse\t\t\t\t \n\t\ttmp = (bandwidth + 500000) / 1000000 - 5;\n\n\t \n\trc = stb6100_write_reg(state, STB6100_FCCK, 0x0d | STB6100_FCCK_FCCK);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = stb6100_write_reg(state, STB6100_F, 0xc0 | tmp);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tmsleep(5);   \n\n\trc = stb6100_write_reg(state, STB6100_FCCK, 0x0d);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tmsleep(10);   \n\n\treturn 0;\n}\n\nstatic int stb6100_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tint rc;\n\tu32 nint, nfrac, fvco;\n\tint psd2, odiv;\n\tstruct stb6100_state *state = fe->tuner_priv;\n\tu8 regs[STB6100_NUMREGS];\n\n\trc = stb6100_read_regs(state, regs);\n\tif (rc < 0)\n\t\treturn rc;\n\n\todiv = (regs[STB6100_VCO] & STB6100_VCO_ODIV) >> STB6100_VCO_ODIV_SHIFT;\n\tpsd2 = (regs[STB6100_K] & STB6100_K_PSD2) >> STB6100_K_PSD2_SHIFT;\n\tnint = regs[STB6100_NI];\n\tnfrac = ((regs[STB6100_K] & STB6100_K_NF_MSB) << 8) | regs[STB6100_NF_LSB];\n\tfvco = (nfrac * state->reference >> (9 - psd2)) + (nint * state->reference << psd2);\n\t*frequency = state->frequency = fvco >> (odiv + 1);\n\n\tdprintk(verbose, FE_DEBUG, 1,\n\t\t\"frequency = %u kHz, odiv = %u, psd2 = %u, fxtal = %u kHz, fvco = %u kHz, N(I) = %u, N(F) = %u\",\n\t\tstate->frequency, odiv, psd2, state->reference,\tfvco, nint, nfrac);\n\treturn 0;\n}\n\n\nstatic int stb6100_set_frequency(struct dvb_frontend *fe, u32 frequency)\n{\n\tint rc;\n\tconst struct stb6100_lkup *ptr;\n\tstruct stb6100_state *state = fe->tuner_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tu32 srate = 0, fvco, nint, nfrac;\n\tu8 regs[STB6100_NUMREGS];\n\tu8 g, psd2, odiv;\n\n\tdprintk(verbose, FE_DEBUG, 1, \"Version 2010-8-14 13:51\");\n\n\tif (fe->ops.get_frontend) {\n\t\tdprintk(verbose, FE_DEBUG, 1, \"Get frontend parameters\");\n\t\tfe->ops.get_frontend(fe, p);\n\t}\n\tsrate = p->symbol_rate;\n\n\t \n\trc = stb6100_write_reg(state, STB6100_FCCK, 0x4d | STB6100_FCCK_FCCK);\n\tif (rc < 0)\n\t\treturn rc;   \n\n\t \n\tregs[STB6100_LPEN] = 0xeb;\n\trc = stb6100_write_reg(state, STB6100_LPEN, regs[STB6100_LPEN]);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\n\t \n\tif (frequency <= 1075000)\n\t\todiv = 1;\n\telse\n\t\todiv = 0;\n\n\t \n\tregs[STB6100_VCO] = 0xe0 | (odiv << STB6100_VCO_ODIV_SHIFT);\n\n\t \n\tfor (ptr = lkup;\n\t     (ptr->val_high != 0) && !CHKRANGE(frequency, ptr->val_low, ptr->val_high);\n\t     ptr++);\n\n\tif (ptr->val_high == 0) {\n\t\tprintk(KERN_ERR \"%s: frequency out of range: %u kHz\\n\", __func__, frequency);\n\t\treturn -EINVAL;\n\t}\n\tregs[STB6100_VCO] = (regs[STB6100_VCO] & ~STB6100_VCO_OSM) | ptr->reg;\n\trc = stb6100_write_reg(state, STB6100_VCO, regs[STB6100_VCO]);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif ((frequency > 1075000) && (frequency <= 1325000))\n\t\tpsd2 = 0;\n\telse\n\t\tpsd2 = 1;\n\t \n\tfvco = frequency << (1 + odiv);\n\t \n\tnint = fvco / (state->reference << psd2);\n\t \n\tnfrac = DIV_ROUND_CLOSEST((fvco - (nint * state->reference << psd2))\n\t\t\t\t\t << (9 - psd2), state->reference);\n\n\t \n\tregs[STB6100_NI] = nint;\n\trc = stb6100_write_reg(state, STB6100_NI, regs[STB6100_NI]);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tregs[STB6100_NF_LSB] = nfrac;\n\trc = stb6100_write_reg(state, STB6100_NF_LSB, regs[STB6100_NF_LSB]);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tregs[STB6100_K] = (0x38 & ~STB6100_K_PSD2) | (psd2 << STB6100_K_PSD2_SHIFT);\n\tregs[STB6100_K] = (regs[STB6100_K] & ~STB6100_K_NF_MSB) | ((nfrac >> 8) & STB6100_K_NF_MSB);\n\trc = stb6100_write_reg(state, STB6100_K, regs[STB6100_K]);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (srate >= 15000000)\n\t\tg = 9;   \n\telse if (srate >= 5000000)\n\t\tg = 11;  \n\telse\n\t\tg = 14;  \n\n\tregs[STB6100_G] = (0x10 & ~STB6100_G_G) | g;\n\tregs[STB6100_G] &= ~STB6100_G_GCT;  \n\tregs[STB6100_G] |= (1 << 5);  \n\trc = stb6100_write_reg(state, STB6100_G, regs[STB6100_G]);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\n\t \n\tregs[STB6100_DLB] = 0xcc;\n\trc = stb6100_write_reg(state, STB6100_DLB, regs[STB6100_DLB]);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tdprintk(verbose, FE_DEBUG, 1,\n\t\t\"frequency = %u, srate = %u, g = %u, odiv = %u, psd2 = %u, fxtal = %u, osm = %u, fvco = %u, N(I) = %u, N(F) = %u\",\n\t\tfrequency, srate, (unsigned int)g, (unsigned int)odiv,\n\t\t(unsigned int)psd2, state->reference,\n\t\tptr->reg, fvco, nint, nfrac);\n\n\t \n\tregs[STB6100_TEST1] = 0x8f;\n\trc = stb6100_write_reg(state, STB6100_TEST1, regs[STB6100_TEST1]);\n\tif (rc < 0)\n\t\treturn rc;\n\tregs[STB6100_TEST3] = 0xde;\n\trc = stb6100_write_reg(state, STB6100_TEST3, regs[STB6100_TEST3]);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tregs[STB6100_LPEN] = 0xfb;  \n\trc = stb6100_write_reg(state, STB6100_LPEN, regs[STB6100_LPEN]);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tmsleep(2);\n\n\t \n\tregs[STB6100_VCO] &= ~STB6100_VCO_OCK;\t\t \n\trc = stb6100_write_reg(state, STB6100_VCO, regs[STB6100_VCO]);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tmsleep(10);     \n\n\tregs[STB6100_VCO] &= ~STB6100_VCO_OSCH;\t\t \n\tregs[STB6100_VCO] |= STB6100_VCO_OCK;\t\t \n\trc = stb6100_write_reg(state, STB6100_VCO, regs[STB6100_VCO]);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = stb6100_write_reg(state, STB6100_FCCK, 0x0d);\n\tif (rc < 0)\n\t\treturn rc;   \n\n\tmsleep(10);   \n\t\t      \n\treturn 0;\n}\n\nstatic int stb6100_sleep(struct dvb_frontend *fe)\n{\n\t \n\treturn 0;\n}\n\nstatic int stb6100_init(struct dvb_frontend *fe)\n{\n\tstruct stb6100_state *state = fe->tuner_priv;\n\tint refclk = 27000000;  \n\n\t \n\tstate->bandwidth        = 36000000;\t\t \n\tstate->reference\t= refclk / 1000;\t \n\n\t \n\treturn 0;\n}\n\nstatic int stb6100_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->frequency > 0)\n\t\tstb6100_set_frequency(fe, c->frequency);\n\n\tif (c->bandwidth_hz > 0)\n\t\tstb6100_set_bandwidth(fe, c->bandwidth_hz);\n\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops stb6100_ops = {\n\t.info = {\n\t\t.name\t\t\t= \"STB6100 Silicon Tuner\",\n\t\t.frequency_min_hz\t=  950 * MHz,\n\t\t.frequency_max_hz\t= 2150 * MHz,\n\t},\n\n\t.init\t\t= stb6100_init,\n\t.sleep          = stb6100_sleep,\n\t.get_status\t= stb6100_get_status,\n\t.set_params\t= stb6100_set_params,\n\t.get_frequency  = stb6100_get_frequency,\n\t.get_bandwidth  = stb6100_get_bandwidth,\n\t.release\t= stb6100_release\n};\n\nstruct dvb_frontend *stb6100_attach(struct dvb_frontend *fe,\n\t\t\t\t    const struct stb6100_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct stb6100_state *state = NULL;\n\n\tstate = kzalloc(sizeof (struct stb6100_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tstate->config\t\t= config;\n\tstate->i2c\t\t= i2c;\n\tstate->frontend\t\t= fe;\n\tstate->reference\t= config->refclock / 1000;  \n\tfe->tuner_priv\t\t= state;\n\tfe->ops.tuner_ops\t= stb6100_ops;\n\n\tprintk(\"%s: Attaching STB6100 \\n\", __func__);\n\treturn fe;\n}\n\nstatic void stb6100_release(struct dvb_frontend *fe)\n{\n\tstruct stb6100_state *state = fe->tuner_priv;\n\n\tfe->tuner_priv = NULL;\n\tkfree(state);\n}\n\nEXPORT_SYMBOL_GPL(stb6100_attach);\nMODULE_PARM_DESC(verbose, \"Set Verbosity level\");\n\nMODULE_AUTHOR(\"Manu Abraham\");\nMODULE_DESCRIPTION(\"STB6100 Silicon tuner\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}