{
  "module_name": "cx24116.c",
  "hash_id": "be5f5078ab83edcdb455c666b25ae512e4cf6ff7a9d080644dd44f8cdccf4247",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cx24116.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/firmware.h>\n\n#include <media/dvb_frontend.h>\n#include \"cx24116.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Activates frontend debugging (default:0)\");\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_INFO \"cx24116: \" args); \\\n\t} while (0)\n\n#define CX24116_DEFAULT_FIRMWARE \"dvb-fe-cx24116.fw\"\n#define CX24116_SEARCH_RANGE_KHZ 5000\n\n \n#define CX24116_REG_COMMAND (0x00)       \n#define CX24116_REG_EXECUTE (0x1f)       \n#define CX24116_REG_MAILBOX (0x96)       \n#define CX24116_REG_RESET   (0x20)       \n#define CX24116_REG_SIGNAL  (0x9e)       \n#define CX24116_REG_SSTATUS (0x9d)       \n#define CX24116_REG_QUALITY8 (0xa3)\n#define CX24116_REG_QSTATUS (0xbc)\n#define CX24116_REG_QUALITY0 (0xd5)\n#define CX24116_REG_BER0    (0xc9)\n#define CX24116_REG_BER8    (0xc8)\n#define CX24116_REG_BER16   (0xc7)\n#define CX24116_REG_BER24   (0xc6)\n#define CX24116_REG_UCB0    (0xcb)\n#define CX24116_REG_UCB8    (0xca)\n#define CX24116_REG_CLKDIV  (0xf3)\n#define CX24116_REG_RATEDIV (0xf9)\n\n \n#define CX24116_REG_FECSTATUS (0x9c)\n\n \n \n#define CX24116_FEC_FECMASK   (0x1f)\n\n \n#define CX24116_FEC_DVBS      (0x20)\n#define CX24116_FEC_UNKNOWN   (0x40)     \n\n \n#define CX24116_FEC_PILOT     (0x80)\n\n \n#define CX24116_ARGLEN (0x1e)\n\n \n#define CX24116_ROLLOFF_020 (0x00)\n#define CX24116_ROLLOFF_025 (0x01)\n#define CX24116_ROLLOFF_035 (0x02)\n\n \n#define CX24116_PILOT_OFF (0x00)\n#define CX24116_PILOT_ON (0x40)\n\n \n#define CX24116_HAS_SIGNAL   (0x01)\n#define CX24116_HAS_CARRIER  (0x02)\n#define CX24116_HAS_VITERBI  (0x04)\n#define CX24116_HAS_SYNCLOCK (0x08)\n#define CX24116_HAS_UNKNOWN1 (0x10)\n#define CX24116_HAS_UNKNOWN2 (0x20)\n#define CX24116_STATUS_MASK  (0x0f)\n#define CX24116_SIGNAL_MASK  (0xc0)\n\n#define CX24116_DISEQC_TONEOFF   (0)     \n#define CX24116_DISEQC_TONECACHE (1)     \n#define CX24116_DISEQC_MESGCACHE (2)     \n\n \n#define CX24116_DISEQC_BURST  (1)\n#define CX24116_DISEQC_ARG2_2 (2)    \n#define CX24116_DISEQC_ARG3_0 (3)    \n#define CX24116_DISEQC_ARG4_0 (4)    \n#define CX24116_DISEQC_MSGLEN (5)\n#define CX24116_DISEQC_MSGOFS (6)\n\n \n#define CX24116_DISEQC_MINI_A (0)\n#define CX24116_DISEQC_MINI_B (1)\n\n \nstatic int toneburst = 1;\nmodule_param(toneburst, int, 0644);\nMODULE_PARM_DESC(toneburst, \"DiSEqC toneburst 0=OFF, 1=TONE CACHE, \"\\\n\t\"2=MESSAGE CACHE (default:1)\");\n\n \nstatic int esno_snr;\nmodule_param(esno_snr, int, 0644);\nMODULE_PARM_DESC(esno_snr, \"SNR return units, 0=PERCENTAGE 0-100, \"\\\n\t\"1=ESNO(db * 10) (default:0)\");\n\nenum cmds {\n\tCMD_SET_VCO     = 0x10,\n\tCMD_TUNEREQUEST = 0x11,\n\tCMD_MPEGCONFIG  = 0x13,\n\tCMD_TUNERINIT   = 0x14,\n\tCMD_BANDWIDTH   = 0x15,\n\tCMD_GETAGC      = 0x19,\n\tCMD_LNBCONFIG   = 0x20,\n\tCMD_LNBSEND     = 0x21,  \n\tCMD_LNBDCLEVEL  = 0x22,\n\tCMD_SET_TONE    = 0x23,\n\tCMD_UPDFWVERS   = 0x35,\n\tCMD_TUNERSLEEP  = 0x36,\n\tCMD_AGCCONTROL  = 0x3b,  \n};\n\n \nstruct cx24116_tuning {\n\tu32 frequency;\n\tu32 symbol_rate;\n\tenum fe_spectral_inversion inversion;\n\tenum fe_code_rate fec;\n\n\tenum fe_delivery_system delsys;\n\tenum fe_modulation modulation;\n\tenum fe_pilot pilot;\n\tenum fe_rolloff rolloff;\n\n\t \n\tu8 fec_val;\n\tu8 fec_mask;\n\tu8 inversion_val;\n\tu8 pilot_val;\n\tu8 rolloff_val;\n};\n\n \nstruct cx24116_cmd {\n\tu8 len;\n\tu8 args[CX24116_ARGLEN];\n};\n\nstruct cx24116_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct cx24116_config *config;\n\n\tstruct dvb_frontend frontend;\n\n\tstruct cx24116_tuning dcur;\n\tstruct cx24116_tuning dnxt;\n\n\tu8 skip_fw_load;\n\tu8 burst;\n\tstruct cx24116_cmd dsec_cmd;\n};\n\nstatic int cx24116_writereg(struct cx24116_state *state, int reg, int data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address,\n\t\t.flags = 0, .buf = buf, .len = 2 };\n\tint err;\n\n\tif (debug > 1)\n\t\tprintk(\"cx24116: %s: write reg 0x%02x, value 0x%02x\\n\",\n\t\t\t__func__, reg, data);\n\n\terr = i2c_transfer(state->i2c, &msg, 1);\n\tif (err != 1) {\n\t\tprintk(KERN_ERR \"%s: writereg error(err == %i, reg == 0x%02x, value == 0x%02x)\\n\",\n\t\t       __func__, err, reg, data);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cx24116_writeregN(struct cx24116_state *state, int reg,\n\t\t\t     const u8 *data, u16 len)\n{\n\tint ret;\n\tstruct i2c_msg msg;\n\tu8 *buf;\n\n\tbuf = kmalloc(len + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t*(buf) = reg;\n\tmemcpy(buf + 1, data, len);\n\n\tmsg.addr = state->config->demod_address;\n\tmsg.flags = 0;\n\tmsg.buf = buf;\n\tmsg.len = len + 1;\n\n\tif (debug > 1)\n\t\tprintk(KERN_INFO \"cx24116: %s:  write regN 0x%02x, len = %d\\n\",\n\t\t\t__func__, reg, len);\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\tif (ret != 1) {\n\t\tprintk(KERN_ERR \"%s: writereg error(err == %i, reg == 0x%02x\\n\",\n\t\t\t __func__, ret, reg);\n\t\tret = -EREMOTEIO;\n\t}\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int cx24116_readreg(struct cx24116_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->config->demod_address, .flags = 0,\n\t\t\t.buf = b0, .len = 1 },\n\t\t{ .addr = state->config->demod_address, .flags = I2C_M_RD,\n\t\t\t.buf = b1, .len = 1 }\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\tprintk(KERN_ERR \"%s: reg=0x%x (error=%d)\\n\",\n\t\t\t__func__, reg, ret);\n\t\treturn ret;\n\t}\n\n\tif (debug > 1)\n\t\tprintk(KERN_INFO \"cx24116: read reg 0x%02x, value 0x%02x\\n\",\n\t\t\treg, b1[0]);\n\n\treturn b1[0];\n}\n\nstatic int cx24116_set_inversion(struct cx24116_state *state,\n\tenum fe_spectral_inversion inversion)\n{\n\tdprintk(\"%s(%d)\\n\", __func__, inversion);\n\n\tswitch (inversion) {\n\tcase INVERSION_OFF:\n\t\tstate->dnxt.inversion_val = 0x00;\n\t\tbreak;\n\tcase INVERSION_ON:\n\t\tstate->dnxt.inversion_val = 0x04;\n\t\tbreak;\n\tcase INVERSION_AUTO:\n\t\tstate->dnxt.inversion_val = 0x0C;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstate->dnxt.inversion = inversion;\n\n\treturn 0;\n}\n\n \n\n \nstatic struct cx24116_modfec {\n\tenum fe_delivery_system delivery_system;\n\tenum fe_modulation modulation;\n\tenum fe_code_rate fec;\n\tu8 mask;\t \n\tu8 val;\t\t \n} CX24116_MODFEC_MODES[] = {\n  \n\n  \n { SYS_DVBS, QPSK, FEC_NONE, 0xfe, 0x30 },\n { SYS_DVBS, QPSK, FEC_1_2,  0x02, 0x2e },  \n { SYS_DVBS, QPSK, FEC_2_3,  0x04, 0x2f },  \n { SYS_DVBS, QPSK, FEC_3_4,  0x08, 0x30 },  \n { SYS_DVBS, QPSK, FEC_4_5,  0xfe, 0x30 },  \n { SYS_DVBS, QPSK, FEC_5_6,  0x20, 0x31 },  \n { SYS_DVBS, QPSK, FEC_6_7,  0xfe, 0x30 },  \n { SYS_DVBS, QPSK, FEC_7_8,  0x80, 0x32 },  \n { SYS_DVBS, QPSK, FEC_8_9,  0xfe, 0x30 },  \n { SYS_DVBS, QPSK, FEC_AUTO, 0xfe, 0x30 },\n  \n { SYS_DVBS2, QPSK, FEC_1_2,  0x00, 0x04 },\n { SYS_DVBS2, QPSK, FEC_3_5,  0x00, 0x05 },\n { SYS_DVBS2, QPSK, FEC_2_3,  0x00, 0x06 },\n { SYS_DVBS2, QPSK, FEC_3_4,  0x00, 0x07 },\n { SYS_DVBS2, QPSK, FEC_4_5,  0x00, 0x08 },\n { SYS_DVBS2, QPSK, FEC_5_6,  0x00, 0x09 },\n { SYS_DVBS2, QPSK, FEC_8_9,  0x00, 0x0a },\n { SYS_DVBS2, QPSK, FEC_9_10, 0x00, 0x0b },\n  \n { SYS_DVBS2, PSK_8, FEC_3_5,  0x00, 0x0c },\n { SYS_DVBS2, PSK_8, FEC_2_3,  0x00, 0x0d },\n { SYS_DVBS2, PSK_8, FEC_3_4,  0x00, 0x0e },\n { SYS_DVBS2, PSK_8, FEC_5_6,  0x00, 0x0f },\n { SYS_DVBS2, PSK_8, FEC_8_9,  0x00, 0x10 },\n { SYS_DVBS2, PSK_8, FEC_9_10, 0x00, 0x11 },\n  \n};\n\nstatic int cx24116_lookup_fecmod(struct cx24116_state *state,\n\tenum fe_delivery_system d, enum fe_modulation m, enum fe_code_rate f)\n{\n\tint i, ret = -EOPNOTSUPP;\n\n\tdprintk(\"%s(0x%02x,0x%02x)\\n\", __func__, m, f);\n\n\tfor (i = 0; i < ARRAY_SIZE(CX24116_MODFEC_MODES); i++) {\n\t\tif ((d == CX24116_MODFEC_MODES[i].delivery_system) &&\n\t\t\t(m == CX24116_MODFEC_MODES[i].modulation) &&\n\t\t\t(f == CX24116_MODFEC_MODES[i].fec)) {\n\t\t\t\tret = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int cx24116_set_fec(struct cx24116_state *state,\n\t\t\t   enum fe_delivery_system delsys,\n\t\t\t   enum fe_modulation mod,\n\t\t\t   enum fe_code_rate fec)\n{\n\tint ret = 0;\n\n\tdprintk(\"%s(0x%02x,0x%02x)\\n\", __func__, mod, fec);\n\n\tret = cx24116_lookup_fecmod(state, delsys, mod, fec);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstate->dnxt.fec = fec;\n\tstate->dnxt.fec_val = CX24116_MODFEC_MODES[ret].val;\n\tstate->dnxt.fec_mask = CX24116_MODFEC_MODES[ret].mask;\n\tdprintk(\"%s() mask/val = 0x%02x/0x%02x\\n\", __func__,\n\t\tstate->dnxt.fec_mask, state->dnxt.fec_val);\n\n\treturn 0;\n}\n\nstatic int cx24116_set_symbolrate(struct cx24116_state *state, u32 rate)\n{\n\tdprintk(\"%s(%d)\\n\", __func__, rate);\n\n\t \n\tif ((rate > state->frontend.ops.info.symbol_rate_max) ||\n\t    (rate < state->frontend.ops.info.symbol_rate_min)) {\n\t\tdprintk(\"%s() unsupported symbol_rate = %d\\n\", __func__, rate);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tstate->dnxt.symbol_rate = rate;\n\tdprintk(\"%s() symbol_rate = %d\\n\", __func__, rate);\n\n\treturn 0;\n}\n\nstatic int cx24116_load_firmware(struct dvb_frontend *fe,\n\tconst struct firmware *fw);\n\nstatic int cx24116_firmware_ondemand(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tconst struct firmware *fw;\n\tint ret = 0;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tif (cx24116_readreg(state, 0x20) > 0) {\n\n\t\tif (state->skip_fw_load)\n\t\t\treturn 0;\n\n\t\t \n\t\t \n\t\tprintk(KERN_INFO \"%s: Waiting for firmware upload (%s)...\\n\",\n\t\t\t__func__, CX24116_DEFAULT_FIRMWARE);\n\t\tret = request_firmware(&fw, CX24116_DEFAULT_FIRMWARE,\n\t\t\tstate->i2c->dev.parent);\n\t\tprintk(KERN_INFO \"%s: Waiting for firmware upload(2)...\\n\",\n\t\t\t__func__);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"%s: No firmware uploaded (timeout or file not found?)\\n\",\n\t\t\t       __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tstate->skip_fw_load = 1;\n\n\t\tret = cx24116_load_firmware(fe, fw);\n\t\tif (ret)\n\t\t\tprintk(KERN_ERR \"%s: Writing firmware to device failed\\n\",\n\t\t\t\t__func__);\n\n\t\trelease_firmware(fw);\n\n\t\tprintk(KERN_INFO \"%s: Firmware upload %s\\n\", __func__,\n\t\t\tret == 0 ? \"complete\" : \"failed\");\n\n\t\t \n\t\tstate->skip_fw_load = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int cx24116_cmd_execute(struct dvb_frontend *fe, struct cx24116_cmd *cmd)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t \n\tret = cx24116_firmware_ondemand(fe);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"%s(): Unable initialise the firmware\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < cmd->len ; i++) {\n\t\tdprintk(\"%s: 0x%02x == 0x%02x\\n\", __func__, i, cmd->args[i]);\n\t\tcx24116_writereg(state, i, cmd->args[i]);\n\t}\n\n\t \n\tcx24116_writereg(state, CX24116_REG_EXECUTE, 0x01);\n\twhile (cx24116_readreg(state, CX24116_REG_EXECUTE)) {\n\t\tmsleep(10);\n\t\tif (i++ > 64) {\n\t\t\t \n\t\t\tprintk(KERN_WARNING \"%s() Firmware not responding\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cx24116_load_firmware(struct dvb_frontend *fe,\n\tconst struct firmware *fw)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint i, ret, len, max, remaining;\n\tunsigned char vers[4];\n\n\tdprintk(\"%s\\n\", __func__);\n\tdprintk(\"Firmware is %zu bytes (%02x %02x .. %02x %02x)\\n\",\n\t\t\tfw->size,\n\t\t\tfw->data[0],\n\t\t\tfw->data[1],\n\t\t\tfw->data[fw->size-2],\n\t\t\tfw->data[fw->size-1]);\n\n\t \n\tif (state->config->reset_device)\n\t\tstate->config->reset_device(fe);\n\n\t \n\t \n\n\t \n\tcx24116_writereg(state, 0xE5, 0x00);\n\tcx24116_writereg(state, 0xF1, 0x08);\n\tcx24116_writereg(state, 0xF2, 0x13);\n\n\t \n\tcx24116_writereg(state, 0xe0, 0x03);\n\tcx24116_writereg(state, 0xe0, 0x00);\n\n\t \n\tcx24116_writereg(state, CX24116_REG_CLKDIV, 0x46);\n\tcx24116_writereg(state, CX24116_REG_RATEDIV, 0x00);\n\n\t \n\tcx24116_writereg(state, 0xF0, 0x03);\n\tcx24116_writereg(state, 0xF4, 0x81);\n\tcx24116_writereg(state, 0xF5, 0x00);\n\tcx24116_writereg(state, 0xF6, 0x00);\n\n\t \n\tif (state->config->i2c_wr_max)\n\t\tmax = state->config->i2c_wr_max;\n\telse\n\t\tmax = INT_MAX;  \n\n\tfor (remaining = fw->size; remaining > 0; remaining -= max - 1) {\n\t\tlen = remaining;\n\t\tif (len > max - 1)\n\t\t\tlen = max - 1;\n\n\t\tcx24116_writeregN(state, 0xF7, &fw->data[fw->size - remaining],\n\t\t\tlen);\n\t}\n\n\tcx24116_writereg(state, 0xF4, 0x10);\n\tcx24116_writereg(state, 0xF0, 0x00);\n\tcx24116_writereg(state, 0xF8, 0x06);\n\n\t \n\tcmd.args[0x00] = CMD_SET_VCO;\n\tcmd.args[0x01] = 0x05;\n\tcmd.args[0x02] = 0xdc;\n\tcmd.args[0x03] = 0xda;\n\tcmd.args[0x04] = 0xae;\n\tcmd.args[0x05] = 0xaa;\n\tcmd.args[0x06] = 0x04;\n\tcmd.args[0x07] = 0x9d;\n\tcmd.args[0x08] = 0xfc;\n\tcmd.args[0x09] = 0x06;\n\tcmd.len = 0x0a;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tcx24116_writereg(state, CX24116_REG_SSTATUS, 0x00);\n\n\t \n\tcmd.args[0x00] = CMD_TUNERINIT;\n\tcmd.args[0x01] = 0x00;\n\tcmd.args[0x02] = 0x00;\n\tcmd.len = 0x03;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tcx24116_writereg(state, 0xe5, 0x00);\n\n\t \n\tcmd.args[0x00] = CMD_MPEGCONFIG;\n\tcmd.args[0x01] = 0x01;\n\tcmd.args[0x02] = 0x75;\n\tcmd.args[0x03] = 0x00;\n\tif (state->config->mpg_clk_pos_pol)\n\t\tcmd.args[0x04] = state->config->mpg_clk_pos_pol;\n\telse\n\t\tcmd.args[0x04] = 0x02;\n\tcmd.args[0x05] = 0x00;\n\tcmd.len = 0x06;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tcmd.args[0x00] = CMD_UPDFWVERS;\n\tcmd.len = 0x02;\n\tfor (i = 0; i < 4; i++) {\n\t\tcmd.args[0x01] = i;\n\t\tret = cx24116_cmd_execute(fe, &cmd);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tvers[i] = cx24116_readreg(state, CX24116_REG_MAILBOX);\n\t}\n\tprintk(KERN_INFO \"%s: FW version %i.%i.%i.%i\\n\", __func__,\n\t\tvers[0], vers[1], vers[2], vers[3]);\n\n\treturn 0;\n}\n\nstatic int cx24116_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\n\tint lock = cx24116_readreg(state, CX24116_REG_SSTATUS) &\n\t\tCX24116_STATUS_MASK;\n\n\tdprintk(\"%s: status = 0x%02x\\n\", __func__, lock);\n\n\t*status = 0;\n\n\tif (lock & CX24116_HAS_SIGNAL)\n\t\t*status |= FE_HAS_SIGNAL;\n\tif (lock & CX24116_HAS_CARRIER)\n\t\t*status |= FE_HAS_CARRIER;\n\tif (lock & CX24116_HAS_VITERBI)\n\t\t*status |= FE_HAS_VITERBI;\n\tif (lock & CX24116_HAS_SYNCLOCK)\n\t\t*status |= FE_HAS_SYNC | FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int cx24116_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t*ber =  (cx24116_readreg(state, CX24116_REG_BER24) << 24) |\n\t\t(cx24116_readreg(state, CX24116_REG_BER16) << 16) |\n\t\t(cx24116_readreg(state, CX24116_REG_BER8)  << 8)  |\n\t\t cx24116_readreg(state, CX24116_REG_BER0);\n\n\treturn 0;\n}\n\n \nstatic int cx24116_read_signal_strength(struct dvb_frontend *fe,\n\tu16 *signal_strength)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\tu16 sig_reading;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t \n\tcmd.args[0x00] = CMD_GETAGC;\n\tcmd.len = 0x01;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tsig_reading =\n\t\t(cx24116_readreg(state,\n\t\t\tCX24116_REG_SSTATUS) & CX24116_SIGNAL_MASK) |\n\t\t(cx24116_readreg(state, CX24116_REG_SIGNAL) << 6);\n\t*signal_strength = 0 - sig_reading;\n\n\tdprintk(\"%s: raw / cooked = 0x%04x / 0x%04x\\n\",\n\t\t__func__, sig_reading, *signal_strength);\n\n\treturn 0;\n}\n\n \nstatic int cx24116_read_snr_pct(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tu8 snr_reading;\n\tstatic const u32 snr_tab[] = {  \n\t\t0x00000, 0x0199A, 0x03333, 0x04ccD, 0x06667,\n\t\t0x08000, 0x0999A, 0x0b333, 0x0cccD, 0x0e667,\n\t\t0x10000, 0x1199A, 0x13333, 0x14ccD, 0x16667,\n\t\t0x18000 };\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tsnr_reading = cx24116_readreg(state, CX24116_REG_QUALITY0);\n\n\tif (snr_reading >= 0xa0  )\n\t\t*snr = 0xffff;\n\telse\n\t\t*snr = snr_tab[(snr_reading & 0xf0) >> 4] +\n\t\t\t(snr_tab[(snr_reading & 0x0f)] >> 4);\n\n\tdprintk(\"%s: raw / cooked = 0x%02x / 0x%04x\\n\", __func__,\n\t\tsnr_reading, *snr);\n\n\treturn 0;\n}\n\n \nstatic int cx24116_read_snr_esno(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t*snr = cx24116_readreg(state, CX24116_REG_QUALITY8) << 8 |\n\t\tcx24116_readreg(state, CX24116_REG_QUALITY0);\n\n\tdprintk(\"%s: raw 0x%04x\\n\", __func__, *snr);\n\n\treturn 0;\n}\n\nstatic int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tif (esno_snr == 1)\n\t\treturn cx24116_read_snr_esno(fe, snr);\n\telse\n\t\treturn cx24116_read_snr_pct(fe, snr);\n}\n\nstatic int cx24116_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t*ucblocks = (cx24116_readreg(state, CX24116_REG_UCB8) << 8) |\n\t\tcx24116_readreg(state, CX24116_REG_UCB0);\n\n\treturn 0;\n}\n\n \nstatic void cx24116_clone_params(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstate->dcur = state->dnxt;\n}\n\n \nstatic int cx24116_wait_for_lnb(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i;\n\n\tdprintk(\"%s() qstatus = 0x%02x\\n\", __func__,\n\t\tcx24116_readreg(state, CX24116_REG_QSTATUS));\n\n\t \n\tfor (i = 0; i < 30 ; i++) {\n\t\tif (cx24116_readreg(state, CX24116_REG_QSTATUS) & 0x20)\n\t\t\treturn 0;\n\t\tmsleep(10);\n\t}\n\n\tdprintk(\"%s(): LNB not ready\\n\", __func__);\n\n\treturn -ETIMEDOUT;  \n}\n\nstatic int cx24116_set_voltage(struct dvb_frontend *fe,\n\tenum fe_sec_voltage voltage)\n{\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s: %s\\n\", __func__,\n\t\tvoltage == SEC_VOLTAGE_13 ? \"SEC_VOLTAGE_13\" :\n\t\tvoltage == SEC_VOLTAGE_18 ? \"SEC_VOLTAGE_18\" : \"??\");\n\n\t \n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tmsleep(100);\n\n\tcmd.args[0x00] = CMD_LNBDCLEVEL;\n\tcmd.args[0x01] = (voltage == SEC_VOLTAGE_18 ? 0x01 : 0x00);\n\tcmd.len = 0x02;\n\n\t \n\tmsleep(15);\n\n\treturn cx24116_cmd_execute(fe, &cmd);\n}\n\nstatic int cx24116_set_tone(struct dvb_frontend *fe,\n\tenum fe_sec_tone_mode tone)\n{\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s(%d)\\n\", __func__, tone);\n\tif ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {\n\t\tprintk(KERN_ERR \"%s: Invalid, tone=%d\\n\", __func__, tone);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tmsleep(15);  \n\n\t \n\tcmd.args[0x00] = CMD_SET_TONE;\n\tcmd.args[0x01] = 0x00;\n\tcmd.args[0x02] = 0x00;\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\tdprintk(\"%s: setting tone on\\n\", __func__);\n\t\tcmd.args[0x03] = 0x01;\n\t\tbreak;\n\tcase SEC_TONE_OFF:\n\t\tdprintk(\"%s: setting tone off\\n\", __func__);\n\t\tcmd.args[0x03] = 0x00;\n\t\tbreak;\n\t}\n\tcmd.len = 0x04;\n\n\t \n\tmsleep(15);  \n\n\treturn cx24116_cmd_execute(fe, &cmd);\n}\n\n \nstatic int cx24116_diseqc_init(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\t \n\tcmd.args[0x00] = CMD_LNBCONFIG;\n\tcmd.args[0x01] = 0x00;\n\tcmd.args[0x02] = 0x10;\n\tcmd.args[0x03] = 0x00;\n\tcmd.args[0x04] = 0x8f;\n\tcmd.args[0x05] = 0x28;\n\tcmd.args[0x06] = (toneburst == CX24116_DISEQC_TONEOFF) ? 0x00 : 0x01;\n\tcmd.args[0x07] = 0x01;\n\tcmd.len = 0x08;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tstate->dsec_cmd.args[0x00] = CMD_LNBSEND;\n\n\t \n\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]  = CX24116_DISEQC_MINI_A;\n\n\t \n\tstate->dsec_cmd.args[CX24116_DISEQC_ARG2_2] = 0x02;\n\tstate->dsec_cmd.args[CX24116_DISEQC_ARG3_0] = 0x00;\n\t \n\tstate->dsec_cmd.args[CX24116_DISEQC_ARG4_0] = 0x00;\n\n\t \n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = 0x00;\n\n\t \n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS;\n\n\treturn 0;\n}\n\n \nstatic int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t \n\tif (d->msg_len > sizeof(d->msg))\n\t\treturn -EINVAL;\n\n\t \n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t \n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t \n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t \n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t \n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t \n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t \n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t \n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t \n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tmsleep(100);\n\n\t \n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t \n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}\n\n \nstatic int cx24116_diseqc_send_burst(struct dvb_frontend *fe,\n\tenum fe_sec_mini_cmd burst)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tdprintk(\"%s(%d) toneburst=%d\\n\", __func__, burst, toneburst);\n\n\t \n\tif (burst == SEC_MINI_A)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\tCX24116_DISEQC_MINI_A;\n\telse if (burst == SEC_MINI_B)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\tCX24116_DISEQC_MINI_B;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tif (toneburst != CX24116_DISEQC_MESGCACHE)\n\t\t \n\t\treturn 0;\n\n\t \n\n\t \n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tmsleep(100);\n\n\t \n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) + 60);\n\n\treturn 0;\n}\n\nstatic void cx24116_release(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tdprintk(\"%s\\n\", __func__);\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops cx24116_ops;\n\nstruct dvb_frontend *cx24116_attach(const struct cx24116_config *config,\n\tstruct i2c_adapter *i2c)\n{\n\tstruct cx24116_state *state;\n\tint ret;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t \n\tret = (cx24116_readreg(state, 0xFF) << 8) |\n\t\tcx24116_readreg(state, 0xFE);\n\tif (ret != 0x0501) {\n\t\tkfree(state);\n\t\tprintk(KERN_INFO \"Invalid probe, probably not a CX24116 device\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tmemcpy(&state->frontend.ops, &cx24116_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n}\nEXPORT_SYMBOL_GPL(cx24116_attach);\n\n \nstatic int cx24116_initfe(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t \n\tcx24116_writereg(state, 0xe0, 0);\n\tcx24116_writereg(state, 0xe1, 0);\n\tcx24116_writereg(state, 0xea, 0);\n\n\t \n\tcmd.args[0x00] = CMD_TUNERSLEEP;\n\tcmd.args[0x01] = 0;\n\tcmd.len = 0x02;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = cx24116_diseqc_init(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\treturn cx24116_set_voltage(fe, SEC_VOLTAGE_13);\n}\n\n \nstatic int cx24116_sleep(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t \n\tcmd.args[0x00] = CMD_TUNERSLEEP;\n\tcmd.args[0x01] = 1;\n\tcmd.len = 0x02;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tcx24116_writereg(state, 0xea, 0xff);\n\tcx24116_writereg(state, 0xe1, 1);\n\tcx24116_writereg(state, 0xe0, 1);\n\n\treturn 0;\n}\n\n \nstatic int cx24116_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct cx24116_cmd cmd;\n\tenum fe_status tunerstat;\n\tint i, status, ret, retune = 1;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\tdprintk(\"%s: DVB-S delivery system selected\\n\", __func__);\n\n\t\t \n\t\tif (c->modulation != QPSK) {\n\t\t\tdprintk(\"%s: unsupported modulation selected (%d)\\n\",\n\t\t\t\t__func__, c->modulation);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\t \n\t\tstate->dnxt.pilot_val = CX24116_PILOT_OFF;\n\n\t\t \n\t\tif (c->rolloff != ROLLOFF_35) {\n\t\t\tdprintk(\"%s: unsupported rolloff selected (%d)\\n\",\n\t\t\t\t__func__, c->rolloff);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tstate->dnxt.rolloff_val = CX24116_ROLLOFF_035;\n\t\tbreak;\n\n\tcase SYS_DVBS2:\n\t\tdprintk(\"%s: DVB-S2 delivery system selected\\n\", __func__);\n\n\t\t \n\t\tif (c->modulation != PSK_8 && c->modulation != QPSK) {\n\t\t\tdprintk(\"%s: unsupported modulation selected (%d)\\n\",\n\t\t\t\t__func__, c->modulation);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tswitch (c->pilot) {\n\t\tcase PILOT_AUTO:\t \n\t\t\tstate->dnxt.pilot_val = (c->modulation == QPSK)\n\t\t\t\t? CX24116_PILOT_OFF : CX24116_PILOT_ON;\n\t\t\tretune++;\n\t\t\tbreak;\n\t\tcase PILOT_OFF:\n\t\t\tstate->dnxt.pilot_val = CX24116_PILOT_OFF;\n\t\t\tbreak;\n\t\tcase PILOT_ON:\n\t\t\tstate->dnxt.pilot_val = CX24116_PILOT_ON;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"%s: unsupported pilot mode selected (%d)\\n\",\n\t\t\t\t__func__, c->pilot);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tswitch (c->rolloff) {\n\t\tcase ROLLOFF_20:\n\t\t\tstate->dnxt.rolloff_val = CX24116_ROLLOFF_020;\n\t\t\tbreak;\n\t\tcase ROLLOFF_25:\n\t\t\tstate->dnxt.rolloff_val = CX24116_ROLLOFF_025;\n\t\t\tbreak;\n\t\tcase ROLLOFF_35:\n\t\t\tstate->dnxt.rolloff_val = CX24116_ROLLOFF_035;\n\t\t\tbreak;\n\t\tcase ROLLOFF_AUTO:\t \n\t\tdefault:\n\t\t\tdprintk(\"%s: unsupported rolloff selected (%d)\\n\",\n\t\t\t\t__func__, c->rolloff);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unsupported delivery system selected (%d)\\n\",\n\t\t\t__func__, c->delivery_system);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tstate->dnxt.delsys = c->delivery_system;\n\tstate->dnxt.modulation = c->modulation;\n\tstate->dnxt.frequency = c->frequency;\n\tstate->dnxt.pilot = c->pilot;\n\tstate->dnxt.rolloff = c->rolloff;\n\n\tret = cx24116_set_inversion(state, c->inversion);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\t \n\tret = cx24116_set_fec(state, c->delivery_system, c->modulation, c->fec_inner);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\tret = cx24116_set_symbolrate(state, c->symbol_rate);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\t \n\tcx24116_clone_params(fe);\n\n\tdprintk(\"%s:   delsys      = %d\\n\", __func__, state->dcur.delsys);\n\tdprintk(\"%s:   modulation  = %d\\n\", __func__, state->dcur.modulation);\n\tdprintk(\"%s:   frequency   = %d\\n\", __func__, state->dcur.frequency);\n\tdprintk(\"%s:   pilot       = %d (val = 0x%02x)\\n\", __func__,\n\t\tstate->dcur.pilot, state->dcur.pilot_val);\n\tdprintk(\"%s:   retune      = %d\\n\", __func__, retune);\n\tdprintk(\"%s:   rolloff     = %d (val = 0x%02x)\\n\", __func__,\n\t\tstate->dcur.rolloff, state->dcur.rolloff_val);\n\tdprintk(\"%s:   symbol_rate = %d\\n\", __func__, state->dcur.symbol_rate);\n\tdprintk(\"%s:   FEC         = %d (mask/val = 0x%02x/0x%02x)\\n\", __func__,\n\t\tstate->dcur.fec, state->dcur.fec_mask, state->dcur.fec_val);\n\tdprintk(\"%s:   Inversion   = %d (val = 0x%02x)\\n\", __func__,\n\t\tstate->dcur.inversion, state->dcur.inversion_val);\n\n\t \n\tif (state->config->set_ts_params)\n\t\tstate->config->set_ts_params(fe, 0);\n\n\t \n\tcmd.args[0x00] = CMD_BANDWIDTH;\n\tcmd.args[0x01] = 0x01;\n\tcmd.len = 0x02;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tcmd.args[0x00] = CMD_TUNEREQUEST;\n\n\t \n\tcmd.args[0x01] = (state->dcur.frequency & 0xff0000) >> 16;\n\tcmd.args[0x02] = (state->dcur.frequency & 0x00ff00) >> 8;\n\tcmd.args[0x03] = (state->dcur.frequency & 0x0000ff);\n\n\t \n\tcmd.args[0x04] = ((state->dcur.symbol_rate / 1000) & 0xff00) >> 8;\n\tcmd.args[0x05] = ((state->dcur.symbol_rate / 1000) & 0x00ff);\n\n\t \n\tcmd.args[0x06] = state->dcur.inversion_val;\n\n\t \n\tcmd.args[0x07] = state->dcur.fec_val | state->dcur.pilot_val;\n\n\tcmd.args[0x08] = CX24116_SEARCH_RANGE_KHZ >> 8;\n\tcmd.args[0x09] = CX24116_SEARCH_RANGE_KHZ & 0xff;\n\tcmd.args[0x0a] = 0x00;\n\tcmd.args[0x0b] = 0x00;\n\tcmd.args[0x0c] = state->dcur.rolloff_val;\n\tcmd.args[0x0d] = state->dcur.fec_mask;\n\n\tif (state->dcur.symbol_rate > 30000000) {\n\t\tcmd.args[0x0e] = 0x04;\n\t\tcmd.args[0x0f] = 0x00;\n\t\tcmd.args[0x10] = 0x01;\n\t\tcmd.args[0x11] = 0x77;\n\t\tcmd.args[0x12] = 0x36;\n\t\tcx24116_writereg(state, CX24116_REG_CLKDIV, 0x44);\n\t\tcx24116_writereg(state, CX24116_REG_RATEDIV, 0x01);\n\t} else {\n\t\tcmd.args[0x0e] = 0x06;\n\t\tcmd.args[0x0f] = 0x00;\n\t\tcmd.args[0x10] = 0x00;\n\t\tcmd.args[0x11] = 0xFA;\n\t\tcmd.args[0x12] = 0x24;\n\t\tcx24116_writereg(state, CX24116_REG_CLKDIV, 0x46);\n\t\tcx24116_writereg(state, CX24116_REG_RATEDIV, 0x00);\n\t}\n\n\tcmd.len = 0x13;\n\n\t \n\tdo {\n\t\t \n\t\tstatus = cx24116_readreg(state, CX24116_REG_SSTATUS)\n\t\t\t& CX24116_SIGNAL_MASK;\n\t\tcx24116_writereg(state, CX24116_REG_SSTATUS, status);\n\n\t\t \n\t\tret = cx24116_cmd_execute(fe, &cmd);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\t \n\t\tfor (i = 0; i < 50 ; i++) {\n\t\t\tcx24116_read_status(fe, &tunerstat);\n\t\t\tstatus = tunerstat & (FE_HAS_SIGNAL | FE_HAS_SYNC);\n\t\t\tif (status == (FE_HAS_SIGNAL | FE_HAS_SYNC)) {\n\t\t\t\tdprintk(\"%s: Tuned\\n\", __func__);\n\t\t\t\tgoto tuned;\n\t\t\t}\n\t\t\tmsleep(10);\n\t\t}\n\n\t\tdprintk(\"%s: Not tuned\\n\", __func__);\n\n\t\t \n\t\tif (state->dcur.pilot == PILOT_AUTO)\n\t\t\tcmd.args[0x07] ^= CX24116_PILOT_ON;\n\t} while (--retune);\n\ntuned:   \n\tcmd.args[0x00] = CMD_BANDWIDTH;\n\tcmd.args[0x01] = 0x00;\n\tcmd.len = 0x02;\n\treturn cx24116_cmd_execute(fe, &cmd);\n}\n\nstatic int cx24116_tune(struct dvb_frontend *fe, bool re_tune,\n\tunsigned int mode_flags, unsigned int *delay, enum fe_status *status)\n{\n\t \n\n\t*delay = HZ / 5;\n\tif (re_tune) {\n\t\tint ret = cx24116_set_frontend(fe);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn cx24116_read_status(fe, status);\n}\n\nstatic enum dvbfe_algo cx24116_get_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic const struct dvb_frontend_ops cx24116_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2 },\n\t.info = {\n\t\t.name = \"Conexant CX24116/CX24118\",\n\t\t.frequency_min_hz = 950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t\t.frequency_stepsize_hz = 1011 * kHz,\n\t\t.frequency_tolerance_hz = 5 * MHz,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |\n\t\t\tFE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_2G_MODULATION |\n\t\t\tFE_CAN_QPSK | FE_CAN_RECOVER\n\t},\n\n\t.release = cx24116_release,\n\n\t.init = cx24116_initfe,\n\t.sleep = cx24116_sleep,\n\t.read_status = cx24116_read_status,\n\t.read_ber = cx24116_read_ber,\n\t.read_signal_strength = cx24116_read_signal_strength,\n\t.read_snr = cx24116_read_snr,\n\t.read_ucblocks = cx24116_read_ucblocks,\n\t.set_tone = cx24116_set_tone,\n\t.set_voltage = cx24116_set_voltage,\n\t.diseqc_send_master_cmd = cx24116_send_diseqc_msg,\n\t.diseqc_send_burst = cx24116_diseqc_send_burst,\n\t.get_frontend_algo = cx24116_get_algo,\n\t.tune = cx24116_tune,\n\n\t.set_frontend = cx24116_set_frontend,\n};\n\nMODULE_DESCRIPTION(\"DVB Frontend module for Conexant cx24116/cx24118 hardware\");\nMODULE_AUTHOR(\"Steven Toth\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}