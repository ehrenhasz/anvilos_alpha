{
  "module_name": "a8293.c",
  "hash_id": "204363f3fb5cfa8f34552da991db256ff55e389c2b038cea6cf6ba69c2032c52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/a8293.c",
  "human_readable_source": "\n \n\n#include \"a8293.h\"\n\n#define A8293_FLAG_ODT\t\t\t0x10\n\nstruct a8293_dev {\n\tstruct i2c_client *client;\n\tu8 reg[2];\n\tint volt_slew_nanos_per_mv;\n};\n\n \n\nstatic int a8293_set_voltage_slew(struct a8293_dev *dev,\n\t\t\t\t  struct i2c_client *client,\n\t\t\t\t  enum fe_sec_voltage fe_sec_voltage,\n\t\t\t\t  int min_nanos_per_mv)\n{\n\tint ret;\n\tu8 reg0, reg1;\n\tint new_volt_idx;\n\tconst int idx_to_mv[] = {\n\t\t0,    12709, 13042, 13375, 14042, 15042, 18042, 18709, 19042\n\t};\n\tconst u8 idx_to_reg[] = {\n\t\t0x00, 0x20,  0x21,  0x22,  0x24,  0x27,  0x28,  0x2A,  0x2B\n\t};\n\tint this_volt_idx;\n\tu8 status;\n\tint prev_volt_idx;\n\n\tdev_dbg(&client->dev, \"set_voltage_slew fe_sec_voltage=%d\\n\",\n\t\tfe_sec_voltage);\n\n\t \n\tret = i2c_master_recv(client, &status, 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tswitch (dev->reg[0] & 0x2F) {\n\tcase 0x00:\n\t\tprev_volt_idx = 0;\n\t\tbreak;\n\tcase 0x20:\n\t\tprev_volt_idx = 1;\n\t\tbreak;\n\tcase 0x21:\n\t\tprev_volt_idx = 2;\n\t\tbreak;\n\tcase 0x22:\n\t\tprev_volt_idx = 3;\n\t\tbreak;\n\tcase 0x24:\n\t\tprev_volt_idx = 4;\n\t\tbreak;\n\tcase 0x27:\n\t\tprev_volt_idx = 5;\n\t\tbreak;\n\tcase 0x28:\n\t\tprev_volt_idx = 6;\n\t\tbreak;\n\tcase 0x2A:\n\t\tprev_volt_idx = 7;\n\t\tbreak;\n\tcase 0x2B:\n\t\tprev_volt_idx = 8;\n\t\tbreak;\n\tdefault:\n\t\tprev_volt_idx = 0;\n\t}\n\n\t \n\tswitch (fe_sec_voltage) {\n\tcase SEC_VOLTAGE_OFF:\n\t\tnew_volt_idx = 0;\n\t\tbreak;\n\tcase SEC_VOLTAGE_13:\n\t\tnew_volt_idx = 2;\n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\n\t\tnew_volt_idx = 6;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tthis_volt_idx = prev_volt_idx;\n\tif (this_volt_idx < new_volt_idx) {\n\t\twhile (this_volt_idx < new_volt_idx) {\n\t\t\tint delta_mv = idx_to_mv[this_volt_idx+1] - idx_to_mv[this_volt_idx];\n\t\t\tint min_wait_time = delta_mv * min_nanos_per_mv;\n\n\t\t\treg0 = idx_to_reg[this_volt_idx+1];\n\t\t\treg0 |= A8293_FLAG_ODT;\n\n\t\t\tret = i2c_master_send(client, &reg0, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t\tdev->reg[0] = reg0;\n\t\t\tthis_volt_idx++;\n\t\t\tusleep_range(min_wait_time, min_wait_time * 2);\n\t\t}\n\t} else {  \n\t\treg0 = idx_to_reg[new_volt_idx];\n\t\treg0 |= A8293_FLAG_ODT;\n\t\tret = i2c_master_send(client, &reg0, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tdev->reg[0] = reg0;\n\t}\n\n\t \n\treg1 = 0x82;\n\tif (reg1 != dev->reg[1]) {\n\t\tret = i2c_master_send(client, &reg1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tdev->reg[1] = reg1;\n\t}\n\n\tusleep_range(1500, 5000);\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\n\nstatic int a8293_set_voltage_noslew(struct dvb_frontend *fe,\n\t\t\t\t    enum fe_sec_voltage fe_sec_voltage)\n{\n\tstruct a8293_dev *dev = fe->sec_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu8 reg0, reg1;\n\n\tdev_dbg(&client->dev, \"set_voltage_noslew fe_sec_voltage=%d\\n\",\n\t\tfe_sec_voltage);\n\n\tswitch (fe_sec_voltage) {\n\tcase SEC_VOLTAGE_OFF:\n\t\t \n\t\treg0 = 0x10;\n\t\tbreak;\n\tcase SEC_VOLTAGE_13:\n\t\t \n\t\treg0 = 0x31;\n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\n\t\t \n\t\treg0 = 0x38;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tif (reg0 != dev->reg[0]) {\n\t\tret = i2c_master_send(client, &reg0, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tdev->reg[0] = reg0;\n\t}\n\n\t \n\treg1 = 0x82;\n\tif (reg1 != dev->reg[1]) {\n\t\tret = i2c_master_send(client, &reg1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tdev->reg[1] = reg1;\n\t}\n\n\tusleep_range(1500, 50000);\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int a8293_set_voltage(struct dvb_frontend *fe,\n\t\t\t     enum fe_sec_voltage fe_sec_voltage)\n{\n\tstruct a8293_dev *dev = fe->sec_priv;\n\tstruct i2c_client *client = dev->client;\n\tint volt_slew_nanos_per_mv = dev->volt_slew_nanos_per_mv;\n\n\tdev_dbg(&client->dev, \"set_voltage volt_slew_nanos_per_mv=%d\\n\",\n\t\tvolt_slew_nanos_per_mv);\n\n\t \n\tif (volt_slew_nanos_per_mv > 0 && volt_slew_nanos_per_mv < 1600)\n\t\ta8293_set_voltage_slew(dev, client, fe_sec_voltage,\n\t\t\t\t       volt_slew_nanos_per_mv);\n\telse\n\t\ta8293_set_voltage_noslew(fe, fe_sec_voltage);\n\n\treturn 0;\n}\n\nstatic int a8293_probe(struct i2c_client *client)\n{\n\tstruct a8293_dev *dev;\n\tstruct a8293_platform_data *pdata = client->dev.platform_data;\n\tstruct dvb_frontend *fe = pdata->dvb_frontend;\n\tint ret;\n\tu8 buf[2];\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev->client = client;\n\tdev->volt_slew_nanos_per_mv = pdata->volt_slew_nanos_per_mv;\n\n\t \n\tret = i2c_master_recv(client, buf, 2);\n\tif (ret < 0)\n\t\tgoto err_kfree;\n\n\t \n\tfe->ops.set_voltage = a8293_set_voltage;\n\tfe->sec_priv = dev;\n\ti2c_set_clientdata(client, dev);\n\n\tdev_info(&client->dev, \"Allegro A8293 SEC successfully attached\\n\");\n\treturn 0;\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void a8293_remove(struct i2c_client *client)\n{\n\tstruct a8293_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id a8293_id_table[] = {\n\t{\"a8293\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, a8293_id_table);\n\nstatic struct i2c_driver a8293_driver = {\n\t.driver = {\n\t\t.name\t= \"a8293\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= a8293_probe,\n\t.remove\t\t= a8293_remove,\n\t.id_table\t= a8293_id_table,\n};\n\nmodule_i2c_driver(a8293_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Allegro A8293 SEC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}