{
  "module_name": "ec100.c",
  "hash_id": "c12d4e0133a04d56e39eca9553920fc36d4f5008c8321bd5d83c4b5ed2a9273a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/ec100.c",
  "human_readable_source": "\n \n\n#include <media/dvb_frontend.h>\n#include \"ec100.h\"\n\nstruct ec100_state {\n\tstruct i2c_adapter *i2c;\n\tstruct dvb_frontend frontend;\n\tstruct ec100_config config;\n\n\tu16 ber;\n};\n\n \nstatic int ec100_write_reg(struct ec100_state *state, u8 reg, u8 val)\n{\n\tint ret;\n\tu8 buf[2] = {reg, val};\n\tstruct i2c_msg msg[1] = {\n\t\t{\n\t\t\t.addr = state->config.demod_address,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(buf),\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 1);\n\tif (ret == 1) {\n\t\tret = 0;\n\t} else {\n\t\tdev_warn(&state->i2c->dev, \"%s: i2c wr failed=%d reg=%02x\\n\",\n\t\t\t\tKBUILD_MODNAME, ret, reg);\n\t\tret = -EREMOTEIO;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ec100_read_reg(struct ec100_state *state, u8 reg, u8 *val)\n{\n\tint ret;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = state->config.demod_address,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &reg\n\t\t}, {\n\t\t\t.addr = state->config.demod_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = val\n\t\t}\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\tif (ret == 2) {\n\t\tret = 0;\n\t} else {\n\t\tdev_warn(&state->i2c->dev, \"%s: i2c rd failed=%d reg=%02x\\n\",\n\t\t\t\tKBUILD_MODNAME, ret, reg);\n\t\tret = -EREMOTEIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int ec100_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct ec100_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 tmp, tmp2;\n\n\tdev_dbg(&state->i2c->dev, \"%s: frequency=%d bandwidth_hz=%d\\n\",\n\t\t\t__func__, c->frequency, c->bandwidth_hz);\n\n\t \n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\n\tret = ec100_write_reg(state, 0x04, 0x06);\n\tif (ret)\n\t\tgoto error;\n\tret = ec100_write_reg(state, 0x67, 0x58);\n\tif (ret)\n\t\tgoto error;\n\tret = ec100_write_reg(state, 0x05, 0x18);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\n\tswitch (c->bandwidth_hz) {\n\tcase 6000000:\n\t\ttmp = 0xb7;\n\t\ttmp2 = 0x55;\n\t\tbreak;\n\tcase 7000000:\n\t\ttmp = 0x00;\n\t\ttmp2 = 0x64;\n\t\tbreak;\n\tcase 8000000:\n\tdefault:\n\t\ttmp = 0x49;\n\t\ttmp2 = 0x72;\n\t}\n\n\tret = ec100_write_reg(state, 0x1b, tmp);\n\tif (ret)\n\t\tgoto error;\n\tret = ec100_write_reg(state, 0x1c, tmp2);\n\tif (ret)\n\t\tgoto error;\n\n\tret = ec100_write_reg(state, 0x0c, 0xbb);  \n\tif (ret)\n\t\tgoto error;\n\tret = ec100_write_reg(state, 0x0d, 0x31);  \n\tif (ret)\n\t\tgoto error;\n\n\tret = ec100_write_reg(state, 0x08, 0x24);\n\tif (ret)\n\t\tgoto error;\n\n\tret = ec100_write_reg(state, 0x00, 0x00);  \n\tif (ret)\n\t\tgoto error;\n\tret = ec100_write_reg(state, 0x00, 0x20);  \n\tif (ret)\n\t\tgoto error;\n\n\treturn ret;\nerror:\n\tdev_dbg(&state->i2c->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int ec100_get_tune_settings(struct dvb_frontend *fe,\n\tstruct dvb_frontend_tune_settings *fesettings)\n{\n\tfesettings->min_delay_ms = 300;\n\tfesettings->step_size = 0;\n\tfesettings->max_drift = 0;\n\n\treturn 0;\n}\n\nstatic int ec100_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct ec100_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 tmp;\n\t*status = 0;\n\n\tret = ec100_read_reg(state, 0x42, &tmp);\n\tif (ret)\n\t\tgoto error;\n\n\tif (tmp & 0x80) {\n\t\t \n\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |\n\t\t\tFE_HAS_SYNC | FE_HAS_LOCK;\n\t} else {\n\t\tret = ec100_read_reg(state, 0x01, &tmp);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (tmp & 0x10) {\n\t\t\t \n\t\t\t*status |= FE_HAS_SIGNAL;\n\t\t\tif (!(tmp & 0x01)) {\n\t\t\t\t \n\t\t\t\t*status |= FE_HAS_CARRIER |  FE_HAS_VITERBI;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\nerror:\n\tdev_dbg(&state->i2c->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int ec100_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct ec100_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 tmp, tmp2;\n\tu16 ber2;\n\n\t*ber = 0;\n\n\tret = ec100_read_reg(state, 0x65, &tmp);\n\tif (ret)\n\t\tgoto error;\n\tret = ec100_read_reg(state, 0x66, &tmp2);\n\tif (ret)\n\t\tgoto error;\n\n\tber2 = (tmp2 << 8) | tmp;\n\n\t \n\tif (ber2 < state->ber)\n\t\t*ber = ber2;\n\telse\n\t\t*ber = ber2 - state->ber;\n\n\tstate->ber = ber2;\n\n\treturn ret;\nerror:\n\tdev_dbg(&state->i2c->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int ec100_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct ec100_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 tmp;\n\n\tret = ec100_read_reg(state, 0x24, &tmp);\n\tif (ret) {\n\t\t*strength = 0;\n\t\tgoto error;\n\t}\n\n\t*strength = ((tmp << 8) | tmp);\n\n\treturn ret;\nerror:\n\tdev_dbg(&state->i2c->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int ec100_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\t*snr = 0;\n\treturn 0;\n}\n\nstatic int ec100_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\t*ucblocks = 0;\n\treturn 0;\n}\n\nstatic void ec100_release(struct dvb_frontend *fe)\n{\n\tstruct ec100_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops ec100_ops;\n\nstruct dvb_frontend *ec100_attach(const struct ec100_config *config,\n\tstruct i2c_adapter *i2c)\n{\n\tint ret;\n\tstruct ec100_state *state = NULL;\n\tu8 tmp;\n\n\t \n\tstate = kzalloc(sizeof(struct ec100_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->i2c = i2c;\n\tmemcpy(&state->config, config, sizeof(struct ec100_config));\n\n\t \n\tret = ec100_read_reg(state, 0x33, &tmp);\n\tif (ret || tmp != 0x0b)\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &ec100_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\treturn &state->frontend;\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ec100_attach);\n\nstatic const struct dvb_frontend_ops ec100_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name = \"E3C EC100 DVB-T\",\n\t\t.caps =\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_QAM_16 |\n\t\t\tFE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO |\n\t\t\tFE_CAN_MUTE_TS\n\t},\n\n\t.release = ec100_release,\n\t.set_frontend = ec100_set_frontend,\n\t.get_tune_settings = ec100_get_tune_settings,\n\t.read_status = ec100_read_status,\n\t.read_ber = ec100_read_ber,\n\t.read_signal_strength = ec100_read_signal_strength,\n\t.read_snr = ec100_read_snr,\n\t.read_ucblocks = ec100_read_ucblocks,\n};\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"E3C EC100 DVB-T demodulator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}