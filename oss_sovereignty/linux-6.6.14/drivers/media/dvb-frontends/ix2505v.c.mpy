{
  "module_name": "ix2505v.c",
  "hash_id": "ea709b1476582651d9cc6662192832723c0672c02b989d89abd3742c4a307aba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/ix2505v.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/dvb/frontend.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"ix2505v.h\"\n\nstatic int ix2505v_debug;\n#define dprintk(level, args...) do { \\\n\tif (ix2505v_debug & level) \\\n\t\tprintk(KERN_DEBUG \"ix2505v: \" args); \\\n} while (0)\n\n#define deb_info(args...)  dprintk(0x01, args)\n#define deb_i2c(args...)  dprintk(0x02, args)\n\nstruct ix2505v_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct ix2505v_config *config;\n\tu32 frequency;\n};\n\n \n\nstatic int ix2505v_read_status_reg(struct ix2505v_state *state)\n{\n\tu8 addr = state->config->tuner_address;\n\tu8 b2[] = {0};\n\tint ret;\n\n\tstruct i2c_msg msg[1] = {\n\t\t{ .addr = addr, .flags = I2C_M_RD, .buf = b2, .len = 1 }\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 1);\n\tdeb_i2c(\"Read %s \", __func__);\n\n\treturn (ret == 1) ? (int) b2[0] : -1;\n}\n\nstatic int ix2505v_write(struct ix2505v_state *state, u8 buf[], u8 count)\n{\n\tstruct i2c_msg msg[1] = {\n\t\t{ .addr = state->config->tuner_address, .flags = 0,\n\t\t  .buf = buf, .len = count },\n\t};\n\n\tint ret;\n\n\tret = i2c_transfer(state->i2c, msg, 1);\n\n\tif (ret != 1) {\n\t\tdeb_i2c(\"%s: i2c error, ret=%d\\n\", __func__, ret);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void ix2505v_release(struct dvb_frontend *fe)\n{\n\tstruct ix2505v_state *state = fe->tuner_priv;\n\n\tfe->tuner_priv = NULL;\n\tkfree(state);\n\n}\n\n \n\nstatic int ix2505v_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct ix2505v_state *state = fe->tuner_priv;\n\tu32 frequency = c->frequency;\n\tu32 b_w  = (c->symbol_rate * 27) / 32000;\n\tu32 div_factor, N , A, x;\n\tint ret = 0, len;\n\tu8 gain, cc, ref, psc, local_osc, lpf;\n\tu8 data[4] = {0};\n\n\tif ((frequency < fe->ops.info.frequency_min_hz / kHz)\n\t||  (frequency > fe->ops.info.frequency_max_hz / kHz))\n\t\treturn -EINVAL;\n\n\tif (state->config->tuner_gain)\n\t\tgain = (state->config->tuner_gain < 4)\n\t\t\t? state->config->tuner_gain : 0;\n\telse\n\t\tgain = 0x0;\n\n\tif (state->config->tuner_chargepump)\n\t\tcc = state->config->tuner_chargepump;\n\telse\n\t\tcc = 0x3;\n\n\tref = 8;  \n\tpsc = 32;  \n\n\tdiv_factor = (frequency * ref) / 40;  \n\tx = div_factor / psc;\n\tN = x/100;\n\tA = ((x - (N * 100)) * psc) / 100;\n\n\tdata[0] = ((gain & 0x3) << 5) | (N >> 3);\n\tdata[1] = (N << 5) | (A & 0x1f);\n\tdata[2] = 0x81 | ((cc & 0x3) << 5) ;  \n\n\tdeb_info(\"Frq=%d x=%d N=%d A=%d\\n\", frequency, x, N, A);\n\n\tif (frequency <= 1065000)\n\t\tlocal_osc = (6 << 5) | 2;\n\telse if (frequency <= 1170000)\n\t\tlocal_osc = (7 << 5) | 2;\n\telse if (frequency <= 1300000)\n\t\tlocal_osc = (1 << 5);\n\telse if (frequency <= 1445000)\n\t\tlocal_osc = (2 << 5);\n\telse if (frequency <= 1607000)\n\t\tlocal_osc = (3 << 5);\n\telse if (frequency <= 1778000)\n\t\tlocal_osc = (4 << 5);\n\telse if (frequency <= 1942000)\n\t\tlocal_osc = (5 << 5);\n\telse\t\t \n\t\tlocal_osc = (6 << 5);\n\n\tdata[3] = local_osc;  \n\n\tif (b_w <= 10000)\n\t\tlpf = 0xc;\n\telse if (b_w <= 12000)\n\t\tlpf = 0x2;\n\telse if (b_w <= 14000)\n\t\tlpf = 0xa;\n\telse if (b_w <= 16000)\n\t\tlpf = 0x6;\n\telse if (b_w <= 18000)\n\t\tlpf = 0xe;\n\telse if (b_w <= 20000)\n\t\tlpf = 0x1;\n\telse if (b_w <= 22000)\n\t\tlpf = 0x9;\n\telse if (b_w <= 24000)\n\t\tlpf = 0x5;\n\telse if (b_w <= 26000)\n\t\tlpf = 0xd;\n\telse if (b_w <= 28000)\n\t\tlpf = 0x3;\n\t\telse\n\t\tlpf = 0xb;\n\n\tdeb_info(\"Osc=%x b_w=%x lpf=%x\\n\", local_osc, b_w, lpf);\n\tdeb_info(\"Data 0=[%4phN]\\n\", data);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tlen = sizeof(data);\n\tret |= ix2505v_write(state, data, len);\n\n\tdata[2] |= 0x4;  \n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tlen = 1;\n\tret |= ix2505v_write(state, &data[2], len);  \n\n\tmsleep(10);\n\n\tdata[2] |= ((lpf >> 2) & 0x3) << 3;  \n\tdata[3] |= (lpf & 0x3) << 2;\n\n\tdeb_info(\"Data 2=[%x%x]\\n\", data[2], data[3]);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tlen = 2;\n\tret |= ix2505v_write(state, &data[2], len);  \n\n\tif (state->config->min_delay_ms)\n\t\tmsleep(state->config->min_delay_ms);\n\n\tstate->frequency = frequency;\n\n\treturn ret;\n}\n\nstatic int ix2505v_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct ix2505v_state *state = fe->tuner_priv;\n\n\t*frequency = state->frequency;\n\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops ix2505v_tuner_ops = {\n\t.info = {\n\t\t.name = \"Sharp IX2505V (B0017)\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2175 * MHz\n\t},\n\t.release = ix2505v_release,\n\t.set_params = ix2505v_set_params,\n\t.get_frequency = ix2505v_get_frequency,\n};\n\nstruct dvb_frontend *ix2505v_attach(struct dvb_frontend *fe,\n\t\t\t\t    const struct ix2505v_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct ix2505v_state *state = NULL;\n\tint ret;\n\n\tif (NULL == config) {\n\t\tdeb_i2c(\"%s: no config \", __func__);\n\t\tgoto error;\n\t}\n\n\tstate = kzalloc(sizeof(struct ix2505v_state), GFP_KERNEL);\n\tif (NULL == state)\n\t\treturn NULL;\n\n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\tif (state->config->tuner_write_only) {\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\tret = ix2505v_read_status_reg(state);\n\n\t\tif (ret & 0x80) {\n\t\t\tdeb_i2c(\"%s: No IX2505V found\\n\", __func__);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tfe->tuner_priv = state;\n\n\tmemcpy(&fe->ops.tuner_ops, &ix2505v_tuner_ops,\n\t\tsizeof(struct dvb_tuner_ops));\n\tdeb_i2c(\"%s: initialization (%s addr=0x%02x) ok\\n\",\n\t\t__func__, fe->ops.tuner_ops.info.name, config->tuner_address);\n\n\treturn fe;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ix2505v_attach);\n\nmodule_param_named(debug, ix2505v_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\nMODULE_DESCRIPTION(\"DVB IX2505V tuner driver\");\nMODULE_AUTHOR(\"Malcolm Priestley\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}