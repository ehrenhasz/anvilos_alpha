{
  "module_name": "stv0367.c",
  "hash_id": "05d98c668860f8364e7ebe8e9c77c1cdaa50ef169a4522104bf0b8f886a97ae6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stv0367.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n\n#include <linux/int_log.h>\n\n#include \"stv0367.h\"\n#include \"stv0367_defs.h\"\n#include \"stv0367_regs.h\"\n#include \"stv0367_priv.h\"\n\n \n#define MAX_XFER_SIZE  64\n\nstatic int stvdebug;\nmodule_param_named(debug, stvdebug, int, 0644);\n\nstatic int i2cdebug;\nmodule_param_named(i2c_debug, i2cdebug, int, 0644);\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (stvdebug) \\\n\t\t\tprintk(KERN_DEBUG args); \\\n\t} while (0)\n\t \n\nenum active_demod_state { demod_none, demod_ter, demod_cab };\n\nstruct stv0367cab_state {\n\tenum stv0367_cab_signal_type\tstate;\n\tu32\tmclk;\n\tu32\tadc_clk;\n\ts32\tsearch_range;\n\ts32\tderot_offset;\n\t \n\tint locked;\t\t\t \n\tu32 freq_khz;\t\t\t \n\tu32 symbol_rate;\t\t \n\tenum fe_spectral_inversion spect_inv;  \n\tu32 qamfec_status_reg;           \n};\n\nstruct stv0367ter_state {\n\t \n\tenum stv0367_ter_signal_type state;\n\tenum stv0367_ter_if_iq_mode if_iq_mode;\n\tenum stv0367_ter_mode mode; \n\tenum fe_guard_interval guard;\n\tenum stv0367_ter_hierarchy hierarchy;\n\tu32 frequency;\n\tenum fe_spectral_inversion sense;  \n\tu8  force;  \n\tu8  bw;  \n\tu8  pBW;  \n\tu32 pBER;\n\tu32 pPER;\n\tu32 ucblocks;\n\ts8  echo_pos;  \n\tu8  first_lock;\n\tu8  unlock_counter;\n\tu32 agc_val;\n};\n\nstruct stv0367_state {\n\tstruct dvb_frontend fe;\n\tstruct i2c_adapter *i2c;\n\t \n\tconst struct stv0367_config *config;\n\tu8 chip_id;\n\t \n\tstruct stv0367cab_state *cab_state;\n\t \n\tstruct stv0367ter_state *ter_state;\n\t \n\tu8 use_i2c_gatectrl;\n\tu8 deftabs;\n\tu8 reinit_on_setfrontend;\n\tu8 auto_if_khz;\n\tenum active_demod_state activedemod;\n};\n\n#define RF_LOOKUP_TABLE_SIZE  31\n#define RF_LOOKUP_TABLE2_SIZE 16\n \nstatic const s32 stv0367cab_RF_LookUp1[RF_LOOKUP_TABLE_SIZE][RF_LOOKUP_TABLE_SIZE] = {\n\t{ \n\t\t48, 50, 51, 53, 54, 56, 57, 58, 60, 61, 62, 63,\n\t\t64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,\n\t\t76, 77, 78, 80, 83, 85, 88,\n\t}, { \n\t\t22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\n\t\t34, 35, 36, 37, 38, 39, 41, 42, 43, 44, 46, 47,\n\t\t49, 50, 52, 53, 54, 55, 56,\n\t}\n};\n \nstatic const s32 stv0367cab_RF_LookUp2[RF_LOOKUP_TABLE2_SIZE][RF_LOOKUP_TABLE2_SIZE] = {\n\t{ \n\t\t28, 29, 31, 32, 34, 35, 36, 37,\n\t\t38, 39, 40, 41, 42, 43, 44, 45,\n\t}, { \n\t\t57, 58, 59, 60, 61, 62, 63, 64,\n\t\t65, 66, 67, 68, 69, 70, 71, 72,\n\t}\n};\n\nstatic\nint stv0367_writeregs(struct stv0367_state *state, u16 reg, u8 *data, int len)\n{\n\tu8 buf[MAX_XFER_SIZE];\n\tstruct i2c_msg msg = {\n\t\t.addr = state->config->demod_address,\n\t\t.flags = 0,\n\t\t.buf = buf,\n\t\t.len = len + 2\n\t};\n\tint ret;\n\n\tif (2 + len > sizeof(buf)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: i2c wr reg=%04x: len=%d is too big!\\n\",\n\t\t       KBUILD_MODNAME, reg, len);\n\t\treturn -EINVAL;\n\t}\n\n\n\tbuf[0] = MSB(reg);\n\tbuf[1] = LSB(reg);\n\tmemcpy(buf + 2, data, len);\n\n\tif (i2cdebug)\n\t\tprintk(KERN_DEBUG \"%s: [%02x] %02x: %02x\\n\", __func__,\n\t\t\tstate->config->demod_address, reg, buf[2]);\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\tif (ret != 1)\n\t\tprintk(KERN_ERR \"%s: i2c write error! ([%02x] %02x: %02x)\\n\",\n\t\t\t__func__, state->config->demod_address, reg, buf[2]);\n\n\treturn (ret != 1) ? -EREMOTEIO : 0;\n}\n\nstatic int stv0367_writereg(struct stv0367_state *state, u16 reg, u8 data)\n{\n\tu8 tmp = data;  \n\n\treturn stv0367_writeregs(state, reg, &tmp, 1);\n}\n\nstatic u8 stv0367_readreg(struct stv0367_state *state, u16 reg)\n{\n\tu8 b0[] = { 0, 0 };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = state->config->demod_address,\n\t\t\t.flags = 0,\n\t\t\t.buf = b0,\n\t\t\t.len = 2\n\t\t}, {\n\t\t\t.addr = state->config->demod_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = b1,\n\t\t\t.len = 1\n\t\t}\n\t};\n\tint ret;\n\n\tb0[0] = MSB(reg);\n\tb0[1] = LSB(reg);\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\tif (ret != 2)\n\t\tprintk(KERN_ERR \"%s: i2c read error ([%02x] %02x: %02x)\\n\",\n\t\t\t__func__, state->config->demod_address, reg, b1[0]);\n\n\tif (i2cdebug)\n\t\tprintk(KERN_DEBUG \"%s: [%02x] %02x: %02x\\n\", __func__,\n\t\t\tstate->config->demod_address, reg, b1[0]);\n\n\treturn b1[0];\n}\n\nstatic void extract_mask_pos(u32 label, u8 *mask, u8 *pos)\n{\n\tu8 position = 0, i = 0;\n\n\t(*mask) = label & 0xff;\n\n\twhile ((position == 0) && (i < 8)) {\n\t\tposition = ((*mask) >> i) & 0x01;\n\t\ti++;\n\t}\n\n\t(*pos) = (i - 1);\n}\n\nstatic void stv0367_writebits(struct stv0367_state *state, u32 label, u8 val)\n{\n\tu8 reg, mask, pos;\n\n\treg = stv0367_readreg(state, (label >> 16) & 0xffff);\n\textract_mask_pos(label, &mask, &pos);\n\n\tval = mask & (val << pos);\n\n\treg = (reg & (~mask)) | val;\n\tstv0367_writereg(state, (label >> 16) & 0xffff, reg);\n\n}\n\nstatic void stv0367_setbits(u8 *reg, u32 label, u8 val)\n{\n\tu8 mask, pos;\n\n\textract_mask_pos(label, &mask, &pos);\n\n\tval = mask & (val << pos);\n\n\t(*reg) = ((*reg) & (~mask)) | val;\n}\n\nstatic u8 stv0367_readbits(struct stv0367_state *state, u32 label)\n{\n\tu8 val = 0xff;\n\tu8 mask, pos;\n\n\textract_mask_pos(label, &mask, &pos);\n\n\tval = stv0367_readreg(state, label >> 16);\n\tval = (val & mask) >> pos;\n\n\treturn val;\n}\n\n#if 0  \nstatic u8 stv0367_getbits(u8 reg, u32 label)\n{\n\tu8 mask, pos;\n\n\textract_mask_pos(label, &mask, &pos);\n\n\treturn (reg & mask) >> pos;\n}\n#endif\n\nstatic void stv0367_write_table(struct stv0367_state *state,\n\t\t\t\tconst struct st_register *deftab)\n{\n\tint i = 0;\n\n\twhile (1) {\n\t\tif (!deftab[i].addr)\n\t\t\tbreak;\n\t\tstv0367_writereg(state, deftab[i].addr, deftab[i].value);\n\t\ti++;\n\t}\n}\n\nstatic void stv0367_pll_setup(struct stv0367_state *state,\n\t\t\t\tu32 icspeed, u32 xtal)\n{\n\t \n\n\tswitch (icspeed) {\n\tcase STV0367_ICSPEED_58000:\n\t\tswitch (xtal) {\n\t\tdefault:\n\t\tcase 27000000:\n\t\t\tdprintk(\"STV0367 SetCLKgen for 58MHz IC and 27Mhz crystal\\n\");\n\t\t\t \n\t\t\tstv0367_writereg(state, R367TER_PLLMDIV, 0x1b);\n\t\t\tstv0367_writereg(state, R367TER_PLLNDIV, 0xe8);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase STV0367_ICSPEED_53125:\n\t\tswitch (xtal) {\n\t\t\t \n\t\tcase 16000000:\n\t\t\tstv0367_writereg(state, R367TER_PLLMDIV, 0x2);\n\t\t\tstv0367_writereg(state, R367TER_PLLNDIV, 0x1b);\n\t\t\tbreak;\n\t\tcase 25000000:\n\t\t\tstv0367_writereg(state, R367TER_PLLMDIV, 0xa);\n\t\t\tstv0367_writereg(state, R367TER_PLLNDIV, 0x55);\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 27000000:\n\t\t\tdprintk(\"FE_STV0367TER_SetCLKgen for 27Mhz\\n\");\n\t\t\tstv0367_writereg(state, R367TER_PLLMDIV, 0x1);\n\t\t\tstv0367_writereg(state, R367TER_PLLNDIV, 0x8);\n\t\t\tbreak;\n\t\tcase 30000000:\n\t\t\tstv0367_writereg(state, R367TER_PLLMDIV, 0xc);\n\t\t\tstv0367_writereg(state, R367TER_PLLNDIV, 0x55);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstv0367_writereg(state, R367TER_PLLSETUP, 0x18);\n}\n\nstatic int stv0367_get_if_khz(struct stv0367_state *state, u32 *ifkhz)\n{\n\tif (state->auto_if_khz && state->fe.ops.tuner_ops.get_if_frequency) {\n\t\tstate->fe.ops.tuner_ops.get_if_frequency(&state->fe, ifkhz);\n\t\t*ifkhz = *ifkhz / 1000;  \n\t} else\n\t\t*ifkhz = state->config->if_khz;\n\n\treturn 0;\n}\n\nstatic int stv0367ter_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tu8 tmp = stv0367_readreg(state, R367TER_I2CRPT);\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tif (enable) {\n\t\tstv0367_setbits(&tmp, F367TER_STOP_ENABLE, 0);\n\t\tstv0367_setbits(&tmp, F367TER_I2CT_ON, 1);\n\t} else {\n\t\tstv0367_setbits(&tmp, F367TER_STOP_ENABLE, 1);\n\t\tstv0367_setbits(&tmp, F367TER_I2CT_ON, 0);\n\t}\n\n\tstv0367_writereg(state, R367TER_I2CRPT, tmp);\n\n\treturn 0;\n}\n\nstatic u32 stv0367_get_tuner_freq(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_ops\t*frontend_ops = &fe->ops;\n\tstruct dvb_tuner_ops\t*tuner_ops = &frontend_ops->tuner_ops;\n\tu32 freq = 0;\n\tint err = 0;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tif (tuner_ops->get_frequency) {\n\t\terr = tuner_ops->get_frequency(fe, &freq);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR \"%s: Invalid parameter\\n\", __func__);\n\t\t\treturn err;\n\t\t}\n\n\t\tdprintk(\"%s: frequency=%d\\n\", __func__, freq);\n\n\t} else\n\t\treturn -1;\n\n\treturn freq;\n}\n\nstatic u16 CellsCoeffs_8MHz_367cofdm[3][6][5] = {\n\t{\n\t\t{0x10EF, 0xE205, 0x10EF, 0xCE49, 0x6DA7},  \n\t\t{0x2151, 0xc557, 0x2151, 0xc705, 0x6f93},  \n\t\t{0x2503, 0xc000, 0x2503, 0xc375, 0x7194},  \n\t\t{0x20E9, 0xca94, 0x20e9, 0xc153, 0x7194},  \n\t\t{0x06EF, 0xF852, 0x06EF, 0xC057, 0x7207},  \n\t\t{0x0000, 0x0ECC, 0x0ECC, 0x0000, 0x3647}  \n\t}, {\n\t\t{0x10A0, 0xE2AF, 0x10A1, 0xCE76, 0x6D6D},  \n\t\t{0x20DC, 0xC676, 0x20D9, 0xC80A, 0x6F29},\n\t\t{0x2532, 0xC000, 0x251D, 0xC391, 0x706F},\n\t\t{0x1F7A, 0xCD2B, 0x2032, 0xC15E, 0x711F},\n\t\t{0x0698, 0xFA5E, 0x0568, 0xC059, 0x7193},\n\t\t{0x0000, 0x0918, 0x149C, 0x0000, 0x3642}  \n\t}, {\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},  \n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000}\n\t}\n};\n\nstatic u16 CellsCoeffs_7MHz_367cofdm[3][6][5] = {\n\t{\n\t\t{0x12CA, 0xDDAF, 0x12CA, 0xCCEB, 0x6FB1},  \n\t\t{0x2329, 0xC000, 0x2329, 0xC6B0, 0x725F},  \n\t\t{0x2394, 0xC000, 0x2394, 0xC2C7, 0x7410},  \n\t\t{0x251C, 0xC000, 0x251C, 0xC103, 0x74D9},  \n\t\t{0x0804, 0xF546, 0x0804, 0xC040, 0x7544},  \n\t\t{0x0000, 0x0CD9, 0x0CD9, 0x0000, 0x370A}  \n\t}, {\n\t\t{0x1285, 0xDE47, 0x1285, 0xCD17, 0x6F76},  \n\t\t{0x234C, 0xC000, 0x2348, 0xC6DA, 0x7206},\n\t\t{0x23B4, 0xC000, 0x23AC, 0xC2DB, 0x73B3},\n\t\t{0x253D, 0xC000, 0x25B6, 0xC10B, 0x747F},\n\t\t{0x0721, 0xF79C, 0x065F, 0xC041, 0x74EB},\n\t\t{0x0000, 0x08FA, 0x1162, 0x0000, 0x36FF}\n\t}, {\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},  \n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000}\n\t}\n};\n\nstatic u16 CellsCoeffs_6MHz_367cofdm[3][6][5] = {\n\t{\n\t\t{0x1699, 0xD5B8, 0x1699, 0xCBC3, 0x713B},  \n\t\t{0x2245, 0xC000, 0x2245, 0xC568, 0x74D5},  \n\t\t{0x227F, 0xC000, 0x227F, 0xC1FC, 0x76C6},  \n\t\t{0x235E, 0xC000, 0x235E, 0xC0A7, 0x778A},  \n\t\t{0x0ECB, 0xEA0B, 0x0ECB, 0xC027, 0x77DD},  \n\t\t{0x0000, 0x0B68, 0x0B68, 0x0000, 0xC89A},  \n\t}, {\n\t\t{0x1655, 0xD64E, 0x1658, 0xCBEF, 0x70FE},  \n\t\t{0x225E, 0xC000, 0x2256, 0xC589, 0x7489},\n\t\t{0x2293, 0xC000, 0x2295, 0xC209, 0x767E},\n\t\t{0x2377, 0xC000, 0x23AA, 0xC0AB, 0x7746},\n\t\t{0x0DC7, 0xEBC8, 0x0D07, 0xC027, 0x7799},\n\t\t{0x0000, 0x0888, 0x0E9C, 0x0000, 0x3757}\n\n\t}, {\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},  \n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n\t\t{0x0000, 0x0000, 0x0000, 0x0000, 0x0000}\n\t}\n};\n\nstatic u32 stv0367ter_get_mclk(struct stv0367_state *state, u32 ExtClk_Hz)\n{\n\tu32 mclk_Hz = 0;  \n\tu32 m, n, p;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tif (stv0367_readbits(state, F367TER_BYPASS_PLLXN) == 0) {\n\t\tn = (u32)stv0367_readbits(state, F367TER_PLL_NDIV);\n\t\tif (n == 0)\n\t\t\tn = n + 1;\n\n\t\tm = (u32)stv0367_readbits(state, F367TER_PLL_MDIV);\n\t\tif (m == 0)\n\t\t\tm = m + 1;\n\n\t\tp = (u32)stv0367_readbits(state, F367TER_PLL_PDIV);\n\t\tif (p > 5)\n\t\t\tp = 5;\n\n\t\tmclk_Hz = ((ExtClk_Hz / 2) * n) / (m * (1 << p));\n\n\t\tdprintk(\"N=%d M=%d P=%d mclk_Hz=%d ExtClk_Hz=%d\\n\",\n\t\t\t\tn, m, p, mclk_Hz, ExtClk_Hz);\n\t} else\n\t\tmclk_Hz = ExtClk_Hz;\n\n\tdprintk(\"%s: mclk_Hz=%d\\n\", __func__, mclk_Hz);\n\n\treturn mclk_Hz;\n}\n\nstatic int stv0367ter_filt_coeff_init(struct stv0367_state *state,\n\t\t\t\tu16 CellsCoeffs[3][6][5], u32 DemodXtal)\n{\n\tint i, j, k, freq;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tfreq = stv0367ter_get_mclk(state, DemodXtal);\n\n\tif (freq == 53125000)\n\t\tk = 1;  \n\telse if (freq == 54000000)\n\t\tk = 0;  \n\telse if (freq == 52500000)\n\t\tk = 2;  \n\telse\n\t\treturn 0;\n\n\tfor (i = 1; i <= 6; i++) {\n\t\tstv0367_writebits(state, F367TER_IIR_CELL_NB, i - 1);\n\n\t\tfor (j = 1; j <= 5; j++) {\n\t\t\tstv0367_writereg(state,\n\t\t\t\t(R367TER_IIRCX_COEFF1_MSB + 2 * (j - 1)),\n\t\t\t\tMSB(CellsCoeffs[k][i-1][j-1]));\n\t\t\tstv0367_writereg(state,\n\t\t\t\t(R367TER_IIRCX_COEFF1_LSB + 2 * (j - 1)),\n\t\t\t\tLSB(CellsCoeffs[k][i-1][j-1]));\n\t\t}\n\t}\n\n\treturn 1;\n\n}\n\nstatic void stv0367ter_agc_iir_lock_detect_set(struct stv0367_state *state)\n{\n\tdprintk(\"%s:\\n\", __func__);\n\n\tstv0367_writebits(state, F367TER_LOCK_DETECT_LSB, 0x00);\n\n\t \n\tstv0367_writebits(state, F367TER_LOCK_DETECT_CHOICE, 0x00);\n\tstv0367_writebits(state, F367TER_LOCK_DETECT_MSB, 0x06);\n\tstv0367_writebits(state, F367TER_AUT_AGC_TARGET_LSB, 0x04);\n\n\t \n\tstv0367_writebits(state, F367TER_LOCK_DETECT_CHOICE, 0x01);\n\tstv0367_writebits(state, F367TER_LOCK_DETECT_MSB, 0x06);\n\tstv0367_writebits(state, F367TER_AUT_AGC_TARGET_LSB, 0x04);\n\n\t \n\tstv0367_writebits(state, F367TER_LOCK_DETECT_CHOICE, 0x02);\n\tstv0367_writebits(state, F367TER_LOCK_DETECT_MSB, 0x01);\n\tstv0367_writebits(state, F367TER_AUT_AGC_TARGET_LSB, 0x00);\n\n\t \n\tstv0367_writebits(state, F367TER_LOCK_DETECT_CHOICE, 0x03);\n\tstv0367_writebits(state, F367TER_LOCK_DETECT_MSB, 0x01);\n\tstv0367_writebits(state, F367TER_AUT_AGC_TARGET_LSB, 0x00);\n\n}\n\nstatic int stv0367_iir_filt_init(struct stv0367_state *state, u8 Bandwidth,\n\t\t\t\t\t\t\tu32 DemodXtalValue)\n{\n\tdprintk(\"%s:\\n\", __func__);\n\n\tstv0367_writebits(state, F367TER_NRST_IIR, 0);\n\n\tswitch (Bandwidth) {\n\tcase 6:\n\t\tif (!stv0367ter_filt_coeff_init(state,\n\t\t\t\tCellsCoeffs_6MHz_367cofdm,\n\t\t\t\tDemodXtalValue))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase 7:\n\t\tif (!stv0367ter_filt_coeff_init(state,\n\t\t\t\tCellsCoeffs_7MHz_367cofdm,\n\t\t\t\tDemodXtalValue))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase 8:\n\t\tif (!stv0367ter_filt_coeff_init(state,\n\t\t\t\tCellsCoeffs_8MHz_367cofdm,\n\t\t\t\tDemodXtalValue))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tstv0367_writebits(state, F367TER_NRST_IIR, 1);\n\n\treturn 1;\n}\n\nstatic void stv0367ter_agc_iir_rst(struct stv0367_state *state)\n{\n\n\tu8 com_n;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tcom_n = stv0367_readbits(state, F367TER_COM_N);\n\n\tstv0367_writebits(state, F367TER_COM_N, 0x07);\n\n\tstv0367_writebits(state, F367TER_COM_SOFT_RSTN, 0x00);\n\tstv0367_writebits(state, F367TER_COM_AGC_ON, 0x00);\n\n\tstv0367_writebits(state, F367TER_COM_SOFT_RSTN, 0x01);\n\tstv0367_writebits(state, F367TER_COM_AGC_ON, 0x01);\n\n\tstv0367_writebits(state, F367TER_COM_N, com_n);\n\n}\n\nstatic int stv0367ter_duration(s32 mode, int tempo1, int tempo2, int tempo3)\n{\n\tint local_tempo = 0;\n\tswitch (mode) {\n\tcase 0:\n\t\tlocal_tempo = tempo1;\n\t\tbreak;\n\tcase 1:\n\t\tlocal_tempo = tempo2;\n\t\tbreak ;\n\n\tcase 2:\n\t\tlocal_tempo = tempo3;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\treturn local_tempo;\n}\n\nstatic enum\nstv0367_ter_signal_type stv0367ter_check_syr(struct stv0367_state *state)\n{\n\tint wd = 100;\n\tunsigned short int SYR_var;\n\ts32 SYRStatus;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tSYR_var = stv0367_readbits(state, F367TER_SYR_LOCK);\n\n\twhile ((!SYR_var) && (wd > 0)) {\n\t\tusleep_range(2000, 3000);\n\t\twd -= 2;\n\t\tSYR_var = stv0367_readbits(state, F367TER_SYR_LOCK);\n\t}\n\n\tif (!SYR_var)\n\t\tSYRStatus = FE_TER_NOSYMBOL;\n\telse\n\t\tSYRStatus =  FE_TER_SYMBOLOK;\n\n\tdprintk(\"stv0367ter_check_syr SYRStatus %s\\n\",\n\t\t\t\tSYR_var == 0 ? \"No Symbol\" : \"OK\");\n\n\treturn SYRStatus;\n}\n\nstatic enum\nstv0367_ter_signal_type stv0367ter_check_cpamp(struct stv0367_state *state,\n\t\t\t\t\t\t\t\ts32 FFTmode)\n{\n\n\ts32  CPAMPvalue = 0, CPAMPStatus, CPAMPMin;\n\tint wd = 0;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tswitch (FFTmode) {\n\tcase 0:  \n\t\tCPAMPMin = 20;\n\t\twd = 10;\n\t\tbreak;\n\tcase 1:  \n\t\tCPAMPMin = 80;\n\t\twd = 55;\n\t\tbreak;\n\tcase 2:  \n\t\tCPAMPMin = 40;\n\t\twd = 30;\n\t\tbreak;\n\tdefault:\n\t\tCPAMPMin = 0xffff;   \n\t\tbreak;\n\t}\n\n\tdprintk(\"%s: CPAMPMin=%d wd=%d\\n\", __func__, CPAMPMin, wd);\n\n\tCPAMPvalue = stv0367_readbits(state, F367TER_PPM_CPAMP_DIRECT);\n\twhile ((CPAMPvalue < CPAMPMin) && (wd > 0)) {\n\t\tusleep_range(1000, 2000);\n\t\twd -= 1;\n\t\tCPAMPvalue = stv0367_readbits(state, F367TER_PPM_CPAMP_DIRECT);\n\t\t \n\t}\n\tdprintk(\"******last CPAMPvalue= %d at wd=%d\\n\", CPAMPvalue, wd);\n\tif (CPAMPvalue < CPAMPMin) {\n\t\tCPAMPStatus = FE_TER_NOCPAMP;\n\t\tdprintk(\"%s: CPAMP failed\\n\", __func__);\n\t} else {\n\t\tdprintk(\"%s: CPAMP OK !\\n\", __func__);\n\t\tCPAMPStatus = FE_TER_CPAMPOK;\n\t}\n\n\treturn CPAMPStatus;\n}\n\nstatic enum stv0367_ter_signal_type\nstv0367ter_lock_algo(struct stv0367_state *state)\n{\n\tenum stv0367_ter_signal_type ret_flag;\n\tshort int wd, tempo;\n\tu8 try, u_var1 = 0, u_var2 = 0, u_var3 = 0, u_var4 = 0, mode, guard;\n\tu8 tmp, tmp2;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tif (state == NULL)\n\t\treturn FE_TER_SWNOK;\n\n\ttry = 0;\n\tdo {\n\t\tret_flag = FE_TER_LOCKOK;\n\n\t\tstv0367_writebits(state, F367TER_CORE_ACTIVE, 0);\n\n\t\tif (state->config->if_iq_mode != 0)\n\t\t\tstv0367_writebits(state, F367TER_COM_N, 0x07);\n\n\t\tstv0367_writebits(state, F367TER_GUARD, 3); \n\t\tstv0367_writebits(state, F367TER_MODE, 0);\n\t\tstv0367_writebits(state, F367TER_SYR_TR_DIS, 0);\n\t\tusleep_range(5000, 10000);\n\n\t\tstv0367_writebits(state, F367TER_CORE_ACTIVE, 1);\n\n\n\t\tif (stv0367ter_check_syr(state) == FE_TER_NOSYMBOL)\n\t\t\treturn FE_TER_NOSYMBOL;\n\t\telse {  \n\t\t\tmode = stv0367_readbits(state, F367TER_SYR_MODE);\n\t\t\tif (stv0367ter_check_cpamp(state, mode) ==\n\t\t\t\t\t\t\tFE_TER_NOCPAMP) {\n\t\t\t\tif (try == 0)\n\t\t\t\t\tret_flag = FE_TER_NOCPAMP;\n\n\t\t\t}\n\t\t}\n\n\t\ttry++;\n\t} while ((try < 10) && (ret_flag != FE_TER_LOCKOK));\n\n\ttmp  = stv0367_readreg(state, R367TER_SYR_STAT);\n\ttmp2 = stv0367_readreg(state, R367TER_STATUS);\n\tdprintk(\"state=%p\\n\", state);\n\tdprintk(\"LOCK OK! mode=%d SYR_STAT=0x%x R367TER_STATUS=0x%x\\n\",\n\t\t\t\t\t\t\tmode, tmp, tmp2);\n\n\ttmp  = stv0367_readreg(state, R367TER_PRVIT);\n\ttmp2 = stv0367_readreg(state, R367TER_I2CRPT);\n\tdprintk(\"PRVIT=0x%x I2CRPT=0x%x\\n\", tmp, tmp2);\n\n\ttmp  = stv0367_readreg(state, R367TER_GAIN_SRC1);\n\tdprintk(\"GAIN_SRC1=0x%x\\n\", tmp);\n\n\tif ((mode != 0) && (mode != 1) && (mode != 2))\n\t\treturn FE_TER_SWNOK;\n\n\t \n\n\t \n#if 0\n\tswitch (guard) {\n\n\tcase 0:\n\tcase 1:\n\t\tstv0367_writebits(state, F367TER_AUTO_LE_EN, 0);\n\t\tstv0367_writereg(state, R367TER_CHC_CTL, 0x01);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tstv0367_writebits(state, F367TER_AUTO_LE_EN, 1);\n\t\tstv0367_writereg(state, R367TER_CHC_CTL, 0x11);\n\t\tbreak;\n\n\tdefault:\n\t\treturn FE_TER_SWNOK;\n\t}\n#endif\n\n\t \n\tstv0367_writebits(state, F367TER_RST_SFEC, 1);\n\tstv0367_writebits(state, F367TER_RST_REEDSOLO, 1);\n\tusleep_range(1000, 2000);\n\tstv0367_writebits(state, F367TER_RST_SFEC, 0);\n\tstv0367_writebits(state, F367TER_RST_REEDSOLO, 0);\n\n\tu_var1 = stv0367_readbits(state, F367TER_LK);\n\tu_var2 = stv0367_readbits(state, F367TER_PRF);\n\tu_var3 = stv0367_readbits(state, F367TER_TPS_LOCK);\n\t \n\n\twd = stv0367ter_duration(mode, 125, 500, 250);\n\ttempo = stv0367ter_duration(mode, 4, 16, 8);\n\n\t \n\twhile (((!u_var1) || (!u_var2) || (!u_var3)) && (wd >= 0)) {\n\t\tusleep_range(1000 * tempo, 1000 * (tempo + 1));\n\t\twd -= tempo;\n\t\tu_var1 = stv0367_readbits(state, F367TER_LK);\n\t\tu_var2 = stv0367_readbits(state, F367TER_PRF);\n\t\tu_var3 = stv0367_readbits(state, F367TER_TPS_LOCK);\n\t\t \n\t}\n\n\tif (!u_var1)\n\t\treturn FE_TER_NOLOCK;\n\n\n\tif (!u_var2)\n\t\treturn FE_TER_NOPRFOUND;\n\n\tif (!u_var3)\n\t\treturn FE_TER_NOTPS;\n\n\tguard = stv0367_readbits(state, F367TER_SYR_GUARD);\n\tstv0367_writereg(state, R367TER_CHC_CTL, 0x11);\n\tswitch (guard) {\n\tcase 0:\n\tcase 1:\n\t\tstv0367_writebits(state, F367TER_AUTO_LE_EN, 0);\n\t\t \n\t\tstv0367_writebits(state, F367TER_SYR_FILTER, 0);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tstv0367_writebits(state, F367TER_AUTO_LE_EN, 1);\n\t\t \n\t\tstv0367_writebits(state, F367TER_SYR_FILTER, 1);\n\t\tbreak;\n\n\tdefault:\n\t\treturn FE_TER_SWNOK;\n\t}\n\n\t \n\tif ((stv0367_readbits(state, F367TER_TPS_CONST) == 2) &&\n\t\t\t(mode == 1) &&\n\t\t\t(stv0367_readbits(state, F367TER_TPS_HPCODE) != 0)) {\n\t\tstv0367_writereg(state, R367TER_SFDLYSETH, 0xc0);\n\t\tstv0367_writereg(state, R367TER_SFDLYSETM, 0x60);\n\t\tstv0367_writereg(state, R367TER_SFDLYSETL, 0x0);\n\t} else\n\t\tstv0367_writereg(state, R367TER_SFDLYSETH, 0x0);\n\n\twd = stv0367ter_duration(mode, 125, 500, 250);\n\tu_var4 = stv0367_readbits(state, F367TER_TSFIFO_LINEOK);\n\n\twhile ((!u_var4) && (wd >= 0)) {\n\t\tusleep_range(1000 * tempo, 1000 * (tempo + 1));\n\t\twd -= tempo;\n\t\tu_var4 = stv0367_readbits(state, F367TER_TSFIFO_LINEOK);\n\t}\n\n\tif (!u_var4)\n\t\treturn FE_TER_NOLOCK;\n\n\t \n\t \n\n\tstv0367_writebits(state, F367TER_SYR_TR_DIS, 1);\n\n\tdprintk(\"FE_TER_LOCKOK !!!\\n\");\n\n\treturn\tFE_TER_LOCKOK;\n\n}\n\nstatic void stv0367ter_set_ts_mode(struct stv0367_state *state,\n\t\t\t\t\tenum stv0367_ts_mode PathTS)\n{\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tif (state == NULL)\n\t\treturn;\n\n\tstv0367_writebits(state, F367TER_TS_DIS, 0);\n\tswitch (PathTS) {\n\tdefault:\n\t\t \n\tcase STV0367_PARALLEL_PUNCT_CLOCK:\n\t\tstv0367_writebits(state, F367TER_TSFIFO_SERIAL, 0);\n\t\tstv0367_writebits(state, F367TER_TSFIFO_DVBCI, 0);\n\t\tbreak;\n\tcase STV0367_SERIAL_PUNCT_CLOCK:\n\t\tstv0367_writebits(state, F367TER_TSFIFO_SERIAL, 1);\n\t\tstv0367_writebits(state, F367TER_TSFIFO_DVBCI, 1);\n\t\tbreak;\n\t}\n}\n\nstatic void stv0367ter_set_clk_pol(struct stv0367_state *state,\n\t\t\t\t\tenum stv0367_clk_pol clock)\n{\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tif (state == NULL)\n\t\treturn;\n\n\tswitch (clock) {\n\tcase STV0367_RISINGEDGE_CLOCK:\n\t\tstv0367_writebits(state, F367TER_TS_BYTE_CLK_INV, 1);\n\t\tbreak;\n\tcase STV0367_FALLINGEDGE_CLOCK:\n\t\tstv0367_writebits(state, F367TER_TS_BYTE_CLK_INV, 0);\n\t\tbreak;\n\t\t \n\tdefault:\n\t\tstv0367_writebits(state, F367TER_TS_BYTE_CLK_INV, 0);\n\t\tbreak;\n\t}\n}\n\n#if 0\nstatic void stv0367ter_core_sw(struct stv0367_state *state)\n{\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tstv0367_writebits(state, F367TER_CORE_ACTIVE, 0);\n\tstv0367_writebits(state, F367TER_CORE_ACTIVE, 1);\n\tmsleep(350);\n}\n#endif\nstatic int stv0367ter_standby(struct dvb_frontend *fe, u8 standby_on)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tif (standby_on) {\n\t\tstv0367_writebits(state, F367TER_STDBY, 1);\n\t\tstv0367_writebits(state, F367TER_STDBY_FEC, 1);\n\t\tstv0367_writebits(state, F367TER_STDBY_CORE, 1);\n\t} else {\n\t\tstv0367_writebits(state, F367TER_STDBY, 0);\n\t\tstv0367_writebits(state, F367TER_STDBY_FEC, 0);\n\t\tstv0367_writebits(state, F367TER_STDBY_CORE, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0367ter_sleep(struct dvb_frontend *fe)\n{\n\treturn stv0367ter_standby(fe, 1);\n}\n\nstatic int stv0367ter_init(struct dvb_frontend *fe)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct stv0367ter_state *ter_state = state->ter_state;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tter_state->pBER = 0;\n\n\tstv0367_write_table(state,\n\t\tstv0367_deftabs[state->deftabs][STV0367_TAB_TER]);\n\n\tstv0367_pll_setup(state, STV0367_ICSPEED_53125, state->config->xtal);\n\n\tstv0367_writereg(state, R367TER_I2CRPT, 0xa0);\n\tstv0367_writereg(state, R367TER_ANACTRL, 0x00);\n\n\t \n\tstv0367ter_set_ts_mode(state, state->config->ts_mode);\n\tstv0367ter_set_clk_pol(state, state->config->clk_pol);\n\n\tstate->chip_id = stv0367_readreg(state, R367TER_ID);\n\tter_state->first_lock = 0;\n\tter_state->unlock_counter = 2;\n\n\treturn 0;\n}\n\nstatic int stv0367ter_algo(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct stv0367ter_state *ter_state = state->ter_state;\n\tint offset = 0, tempo = 0;\n\tu8 u_var;\n\tu8   counter;\n\ts8 step;\n\ts32 timing_offset = 0;\n\tu32 trl_nomrate = 0, InternalFreq = 0, temp = 0, ifkhz = 0;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tstv0367_get_if_khz(state, &ifkhz);\n\n\tter_state->frequency = p->frequency;\n\tter_state->force = FE_TER_FORCENONE\n\t\t\t+ stv0367_readbits(state, F367TER_FORCE) * 2;\n\tter_state->if_iq_mode = state->config->if_iq_mode;\n\tswitch (state->config->if_iq_mode) {\n\tcase FE_TER_NORMAL_IF_TUNER:   \n\t\tdprintk(\"ALGO: FE_TER_NORMAL_IF_TUNER selected\\n\");\n\t\tstv0367_writebits(state, F367TER_TUNER_BB, 0);\n\t\tstv0367_writebits(state, F367TER_LONGPATH_IF, 0);\n\t\tstv0367_writebits(state, F367TER_DEMUX_SWAP, 0);\n\t\tbreak;\n\tcase FE_TER_LONGPATH_IF_TUNER:   \n\t\tdprintk(\"ALGO: FE_TER_LONGPATH_IF_TUNER selected\\n\");\n\t\tstv0367_writebits(state, F367TER_TUNER_BB, 0);\n\t\tstv0367_writebits(state, F367TER_LONGPATH_IF, 1);\n\t\tstv0367_writebits(state, F367TER_DEMUX_SWAP, 1);\n\t\tbreak;\n\tcase FE_TER_IQ_TUNER:   \n\t\tdprintk(\"ALGO: FE_TER_IQ_TUNER selected\\n\");\n\t\tstv0367_writebits(state, F367TER_TUNER_BB, 1);\n\t\tstv0367_writebits(state, F367TER_PPM_INVSEL, 0);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"ALGO: wrong TUNER type selected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tusleep_range(5000, 7000);\n\n\tswitch (p->inversion) {\n\tcase INVERSION_AUTO:\n\tdefault:\n\t\tdprintk(\"%s: inversion AUTO\\n\", __func__);\n\t\tif (ter_state->if_iq_mode == FE_TER_IQ_TUNER)\n\t\t\tstv0367_writebits(state, F367TER_IQ_INVERT,\n\t\t\t\t\t\tter_state->sense);\n\t\telse\n\t\t\tstv0367_writebits(state, F367TER_INV_SPECTR,\n\t\t\t\t\t\tter_state->sense);\n\n\t\tbreak;\n\tcase INVERSION_ON:\n\tcase INVERSION_OFF:\n\t\tif (ter_state->if_iq_mode == FE_TER_IQ_TUNER)\n\t\t\tstv0367_writebits(state, F367TER_IQ_INVERT,\n\t\t\t\t\t\tp->inversion);\n\t\telse\n\t\t\tstv0367_writebits(state, F367TER_INV_SPECTR,\n\t\t\t\t\t\tp->inversion);\n\n\t\tbreak;\n\t}\n\n\tif ((ter_state->if_iq_mode != FE_TER_NORMAL_IF_TUNER) &&\n\t\t\t\t(ter_state->pBW != ter_state->bw)) {\n\t\tstv0367ter_agc_iir_lock_detect_set(state);\n\n\t\t \n\t\t \n\t\tstv0367_writebits(state, F367TER_SEL_IQNTAR, 1);\n\t\tstv0367_writebits(state, F367TER_AUT_AGC_TARGET_MSB, 0xB);\n\t\t \n\n\t\t \n\t\tstv0367_writebits(state, F367TER_SEL_IQNTAR, 0);\n\t\tstv0367_writebits(state, F367TER_AUT_AGC_TARGET_MSB, 0xB);\n\t\t \n\n\t\tif (!stv0367_iir_filt_init(state, ter_state->bw,\n\t\t\t\t\t\tstate->config->xtal))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tter_state->pBW = ter_state->bw;\n\n\t\tstv0367ter_agc_iir_rst(state);\n\t}\n\n\tif (ter_state->hierarchy == FE_TER_HIER_LOW_PRIO)\n\t\tstv0367_writebits(state, F367TER_BDI_LPSEL, 0x01);\n\telse\n\t\tstv0367_writebits(state, F367TER_BDI_LPSEL, 0x00);\n\n\tInternalFreq = stv0367ter_get_mclk(state, state->config->xtal) / 1000;\n\ttemp = (int)\n\t\t((((ter_state->bw * 64 * (1 << 15) * 100)\n\t\t\t\t\t\t/ (InternalFreq)) * 10) / 7);\n\n\tstv0367_writebits(state, F367TER_TRL_NOMRATE_LSB, temp % 2);\n\ttemp = temp / 2;\n\tstv0367_writebits(state, F367TER_TRL_NOMRATE_HI, temp / 256);\n\tstv0367_writebits(state, F367TER_TRL_NOMRATE_LO, temp % 256);\n\n\ttemp = stv0367_readbits(state, F367TER_TRL_NOMRATE_HI) * 512 +\n\t\t\tstv0367_readbits(state, F367TER_TRL_NOMRATE_LO) * 2 +\n\t\t\tstv0367_readbits(state, F367TER_TRL_NOMRATE_LSB);\n\ttemp = (int)(((1 << 17) * ter_state->bw * 1000) / (7 * (InternalFreq)));\n\tstv0367_writebits(state, F367TER_GAIN_SRC_HI, temp / 256);\n\tstv0367_writebits(state, F367TER_GAIN_SRC_LO, temp % 256);\n\ttemp = stv0367_readbits(state, F367TER_GAIN_SRC_HI) * 256 +\n\t\t\tstv0367_readbits(state, F367TER_GAIN_SRC_LO);\n\n\ttemp = (int)\n\t\t((InternalFreq - ifkhz) * (1 << 16) / (InternalFreq));\n\n\tdprintk(\"DEROT temp=0x%x\\n\", temp);\n\tstv0367_writebits(state, F367TER_INC_DEROT_HI, temp / 256);\n\tstv0367_writebits(state, F367TER_INC_DEROT_LO, temp % 256);\n\n\tter_state->echo_pos = 0;\n\tter_state->ucblocks = 0;  \n\tter_state->pBER = 0;  \n\tstv0367_writebits(state, F367TER_LONG_ECHO, ter_state->echo_pos);\n\n\tif (stv0367ter_lock_algo(state) != FE_TER_LOCKOK)\n\t\treturn 0;\n\n\tter_state->state = FE_TER_LOCKOK;\n\n\tter_state->mode = stv0367_readbits(state, F367TER_SYR_MODE);\n\tter_state->guard = stv0367_readbits(state, F367TER_SYR_GUARD);\n\n\tter_state->first_lock = 1;  \n\n\tter_state->agc_val =\n\t\t\t(stv0367_readbits(state, F367TER_AGC1_VAL_LO) << 16) +\n\t\t\t(stv0367_readbits(state, F367TER_AGC1_VAL_HI) << 24) +\n\t\t\tstv0367_readbits(state, F367TER_AGC2_VAL_LO) +\n\t\t\t(stv0367_readbits(state, F367TER_AGC2_VAL_HI) << 8);\n\n\t \n\tstv0367_writebits(state, F367TER_FREEZE, 1);\n\toffset = (stv0367_readbits(state, F367TER_CRL_FOFFSET_VHI) << 16) ;\n\toffset += (stv0367_readbits(state, F367TER_CRL_FOFFSET_HI) << 8);\n\toffset += (stv0367_readbits(state, F367TER_CRL_FOFFSET_LO));\n\tstv0367_writebits(state, F367TER_FREEZE, 0);\n\tif (offset > 8388607)\n\t\toffset -= 16777216;\n\n\toffset = offset * 2 / 16384;\n\n\tif (ter_state->mode == FE_TER_MODE_2K)\n\t\toffset = (offset * 4464) / 1000; \n\telse if (ter_state->mode == FE_TER_MODE_4K)\n\t\toffset = (offset * 223) / 100; \n\telse  if (ter_state->mode == FE_TER_MODE_8K)\n\t\toffset = (offset * 111) / 100; \n\n\tif (stv0367_readbits(state, F367TER_PPM_INVSEL) == 1) {\n\t\tif ((stv0367_readbits(state, F367TER_INV_SPECTR) ==\n\t\t\t\t(stv0367_readbits(state,\n\t\t\t\t\tF367TER_STATUS_INV_SPECRUM) == 1)))\n\t\t\toffset = offset * -1;\n\t}\n\n\tif (ter_state->bw == 6)\n\t\toffset = (offset * 6) / 8;\n\telse if (ter_state->bw == 7)\n\t\toffset = (offset * 7) / 8;\n\n\tter_state->frequency += offset;\n\n\ttempo = 10;   \n\twhile ((timing_offset == 0) && (tempo > 0)) {\n\t\tusleep_range(10000, 20000);\t \n\t\t \n\t\ttiming_offset = stv0367_readbits(state, F367TER_TRL_TOFFSET_LO)\n\t\t\t\t+ 256 * stv0367_readbits(state,\n\t\t\t\t\t\t\tF367TER_TRL_TOFFSET_HI);\n\t\tif (timing_offset >= 32768)\n\t\t\ttiming_offset -= 65536;\n\t\ttrl_nomrate = (512 * stv0367_readbits(state,\n\t\t\t\t\t\t\tF367TER_TRL_NOMRATE_HI)\n\t\t\t+ stv0367_readbits(state, F367TER_TRL_NOMRATE_LO) * 2\n\t\t\t+ stv0367_readbits(state, F367TER_TRL_NOMRATE_LSB));\n\n\t\ttiming_offset = ((signed)(1000000 / trl_nomrate) *\n\t\t\t\t\t\t\ttiming_offset) / 2048;\n\t\ttempo--;\n\t}\n\n\tif (timing_offset <= 0) {\n\t\ttiming_offset = (timing_offset - 11) / 22;\n\t\tstep = -1;\n\t} else {\n\t\ttiming_offset = (timing_offset + 11) / 22;\n\t\tstep = 1;\n\t}\n\n\tfor (counter = 0; counter < abs(timing_offset); counter++) {\n\t\ttrl_nomrate += step;\n\t\tstv0367_writebits(state, F367TER_TRL_NOMRATE_LSB,\n\t\t\t\t\t\ttrl_nomrate % 2);\n\t\tstv0367_writebits(state, F367TER_TRL_NOMRATE_LO,\n\t\t\t\t\t\ttrl_nomrate / 2);\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tusleep_range(5000, 6000);\n\t \n\tu_var = stv0367_readbits(state, F367TER_LK);\n\n\tif (!u_var) {\n\t\tstv0367_writebits(state, F367TER_CORE_ACTIVE, 0);\n\t\tmsleep(20);\n\t\tstv0367_writebits(state, F367TER_CORE_ACTIVE, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0367ter_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct stv0367ter_state *ter_state = state->ter_state;\n\n\t \n\ts8 num_trials, index;\n\tu8 SenseTrials[] = { INVERSION_ON, INVERSION_OFF };\n\n\tif (state->reinit_on_setfrontend)\n\t\tstv0367ter_init(fe);\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tif (state->use_i2c_gatectrl && fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (state->use_i2c_gatectrl && fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tswitch (p->transmission_mode) {\n\tdefault:\n\tcase TRANSMISSION_MODE_AUTO:\n\tcase TRANSMISSION_MODE_2K:\n\t\tter_state->mode = FE_TER_MODE_2K;\n\t\tbreak;\n \n\tcase TRANSMISSION_MODE_8K:\n\t\tter_state->mode = FE_TER_MODE_8K;\n\t\tbreak;\n\t}\n\n\tswitch (p->guard_interval) {\n\tdefault:\n\tcase GUARD_INTERVAL_1_32:\n\tcase GUARD_INTERVAL_1_16:\n\tcase GUARD_INTERVAL_1_8:\n\tcase GUARD_INTERVAL_1_4:\n\t\tter_state->guard = p->guard_interval;\n\t\tbreak;\n\tcase GUARD_INTERVAL_AUTO:\n\t\tter_state->guard = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\t}\n\n\tswitch (p->bandwidth_hz) {\n\tcase 6000000:\n\t\tter_state->bw = FE_TER_CHAN_BW_6M;\n\t\tbreak;\n\tcase 7000000:\n\t\tter_state->bw = FE_TER_CHAN_BW_7M;\n\t\tbreak;\n\tcase 8000000:\n\tdefault:\n\t\tter_state->bw = FE_TER_CHAN_BW_8M;\n\t}\n\n\tter_state->hierarchy = FE_TER_HIER_NONE;\n\n\tswitch (p->inversion) {\n\tcase INVERSION_OFF:\n\tcase INVERSION_ON:\n\t\tnum_trials = 1;\n\t\tbreak;\n\tdefault:\n\t\tnum_trials = 2;\n\t\tif (ter_state->first_lock)\n\t\t\tnum_trials = 1;\n\t\tbreak;\n\t}\n\n\tter_state->state = FE_TER_NOLOCK;\n\tindex = 0;\n\n\twhile (((index) < num_trials) && (ter_state->state != FE_TER_LOCKOK)) {\n\t\tif (!ter_state->first_lock) {\n\t\t\tif (p->inversion == INVERSION_AUTO)\n\t\t\t\tter_state->sense = SenseTrials[index];\n\n\t\t}\n\t\tstv0367ter_algo(fe);\n\n\t\tif ((ter_state->state == FE_TER_LOCKOK) &&\n\t\t\t\t(p->inversion == INVERSION_AUTO) &&\n\t\t\t\t\t\t\t\t(index == 1)) {\n\t\t\t \n\t\t\tSenseTrials[index] = SenseTrials[0];\n\t\t\tSenseTrials[(index + 1) % 2] = (SenseTrials[1] + 1) % 2;\n\t\t}\n\n\t\tindex++;\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0367ter_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct stv0367ter_state *ter_state = state->ter_state;\n\tu32 errs = 0;\n\n\t \n\tif (stv0367_readbits(state, F367TER_SFERRC_OLDVALUE) == 0) {\n\t\terrs =\n\t\t\t((u32)stv0367_readbits(state, F367TER_ERR_CNT1)\n\t\t\t* (1 << 16))\n\t\t\t+ ((u32)stv0367_readbits(state, F367TER_ERR_CNT1_HI)\n\t\t\t* (1 << 8))\n\t\t\t+ ((u32)stv0367_readbits(state, F367TER_ERR_CNT1_LO));\n\t\tter_state->ucblocks = errs;\n\t}\n\n\t(*ucblocks) = ter_state->ucblocks;\n\n\treturn 0;\n}\n\nstatic int stv0367ter_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t   struct dtv_frontend_properties *p)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct stv0367ter_state *ter_state = state->ter_state;\n\tenum stv0367_ter_mode mode;\n\tint constell = 0,  Data = 0;\n\n\tp->frequency = stv0367_get_tuner_freq(fe);\n\tif ((int)p->frequency < 0)\n\t\tp->frequency = -p->frequency;\n\n\tconstell = stv0367_readbits(state, F367TER_TPS_CONST);\n\tif (constell == 0)\n\t\tp->modulation = QPSK;\n\telse if (constell == 1)\n\t\tp->modulation = QAM_16;\n\telse\n\t\tp->modulation = QAM_64;\n\n\tp->inversion = stv0367_readbits(state, F367TER_INV_SPECTR);\n\n\t \n\tData = stv0367_readbits(state, F367TER_TPS_HIERMODE);\n\n\tswitch (Data) {\n\tcase 0:\n\t\tp->hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tp->hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tcase 2:\n\t\tp->hierarchy = HIERARCHY_2;\n\t\tbreak;\n\tcase 3:\n\t\tp->hierarchy = HIERARCHY_4;\n\t\tbreak;\n\tdefault:\n\t\tp->hierarchy = HIERARCHY_AUTO;\n\t\tbreak;  \n\t}\n\n\t \n\tif (ter_state->hierarchy == FE_TER_HIER_LOW_PRIO)\n\t\tData = stv0367_readbits(state, F367TER_TPS_LPCODE);\n\telse\n\t\tData = stv0367_readbits(state, F367TER_TPS_HPCODE);\n\n\tswitch (Data) {\n\tcase 0:\n\t\tp->code_rate_HP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tp->code_rate_HP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tp->code_rate_HP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tp->code_rate_HP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tp->code_rate_HP = FEC_7_8;\n\t\tbreak;\n\tdefault:\n\t\tp->code_rate_HP = FEC_AUTO;\n\t\tbreak;  \n\t}\n\n\tmode = stv0367_readbits(state, F367TER_SYR_MODE);\n\n\tswitch (mode) {\n\tcase FE_TER_MODE_2K:\n\t\tp->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n \n\tcase FE_TER_MODE_8K:\n\t\tp->transmission_mode = TRANSMISSION_MODE_8K;\n\t\tbreak;\n\tdefault:\n\t\tp->transmission_mode = TRANSMISSION_MODE_AUTO;\n\t}\n\n\tp->guard_interval = stv0367_readbits(state, F367TER_SYR_GUARD);\n\n\treturn 0;\n}\n\nstatic u32 stv0367ter_snr_readreg(struct dvb_frontend *fe)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tu32 snru32 = 0;\n\tint cpt = 0;\n\tu8 cut = stv0367_readbits(state, F367TER_IDENTIFICATIONREG);\n\n\twhile (cpt < 10) {\n\t\tusleep_range(2000, 3000);\n\t\tif (cut == 0x50)  \n\t\t\tsnru32 += stv0367_readbits(state, F367TER_CHCSNR) / 4;\n\t\telse  \n\t\t\tsnru32 += 125 * stv0367_readbits(state, F367TER_CHCSNR);\n\n\t\tcpt++;\n\t}\n\tsnru32 /= 10; \n\n\treturn snru32;\n}\n\nstatic int stv0367ter_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tu32 snrval = stv0367ter_snr_readreg(fe);\n\n\t*snr = snrval / 1000;\n\n\treturn 0;\n}\n\n#if 0\nstatic int stv0367ter_status(struct dvb_frontend *fe)\n{\n\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct stv0367ter_state *ter_state = state->ter_state;\n\tint locked = FALSE;\n\n\tlocked = (stv0367_readbits(state, F367TER_LK));\n\tif (!locked)\n\t\tter_state->unlock_counter += 1;\n\telse\n\t\tter_state->unlock_counter = 0;\n\n\tif (ter_state->unlock_counter > 2) {\n\t\tif (!stv0367_readbits(state, F367TER_TPS_LOCK) ||\n\t\t\t\t(!stv0367_readbits(state, F367TER_LK))) {\n\t\t\tstv0367_writebits(state, F367TER_CORE_ACTIVE, 0);\n\t\t\tusleep_range(2000, 3000);\n\t\t\tstv0367_writebits(state, F367TER_CORE_ACTIVE, 1);\n\t\t\tmsleep(350);\n\t\t\tlocked = (stv0367_readbits(state, F367TER_TPS_LOCK)) &&\n\t\t\t\t\t(stv0367_readbits(state, F367TER_LK));\n\t\t}\n\n\t}\n\n\treturn locked;\n}\n#endif\nstatic int stv0367ter_read_status(struct dvb_frontend *fe,\n\t\t\t\t  enum fe_status *status)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\t*status = 0;\n\n\tif (stv0367_readbits(state, F367TER_LK)) {\n\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI\n\t\t\t  | FE_HAS_SYNC | FE_HAS_LOCK;\n\t\tdprintk(\"%s: stv0367 has locked\\n\", __func__);\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0367ter_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct stv0367ter_state *ter_state = state->ter_state;\n\tu32 Errors = 0, tber = 0, temporary = 0;\n\tint abc = 0, def = 0;\n\n\n\t \n\tif (stv0367_readbits(state, F367TER_SFERRC_OLDVALUE) == 0)\n\t\tErrors = ((u32)stv0367_readbits(state, F367TER_SFEC_ERR_CNT)\n\t\t\t* (1 << 16))\n\t\t\t+ ((u32)stv0367_readbits(state, F367TER_SFEC_ERR_CNT_HI)\n\t\t\t* (1 << 8))\n\t\t\t+ ((u32)stv0367_readbits(state,\n\t\t\t\t\t\tF367TER_SFEC_ERR_CNT_LO));\n\t \n\telse {\n\t\ttber = ter_state->pBER;\n\t\treturn 0;\n\t}\n\n\tabc = stv0367_readbits(state, F367TER_SFEC_ERR_SOURCE);\n\tdef = stv0367_readbits(state, F367TER_SFEC_NUM_EVENT);\n\n\tif (Errors == 0) {\n\t\ttber = 0;\n\t} else if (abc == 0x7) {\n\t\tif (Errors <= 4) {\n\t\t\ttemporary = (Errors * 1000000000) / (8 * (1 << 14));\n\t\t} else if (Errors <= 42) {\n\t\t\ttemporary = (Errors * 100000000) / (8 * (1 << 14));\n\t\t\ttemporary = temporary * 10;\n\t\t} else if (Errors <= 429) {\n\t\t\ttemporary = (Errors * 10000000) / (8 * (1 << 14));\n\t\t\ttemporary = temporary * 100;\n\t\t} else if (Errors <= 4294) {\n\t\t\ttemporary = (Errors * 1000000) / (8 * (1 << 14));\n\t\t\ttemporary = temporary * 1000;\n\t\t} else if (Errors <= 42949) {\n\t\t\ttemporary = (Errors * 100000) / (8 * (1 << 14));\n\t\t\ttemporary = temporary * 10000;\n\t\t} else if (Errors <= 429496) {\n\t\t\ttemporary = (Errors * 10000) / (8 * (1 << 14));\n\t\t\ttemporary = temporary * 100000;\n\t\t} else {  \n\t\t\ttemporary = (Errors * 1000) / (8 * (1 << 14));\n\t\t\ttemporary = temporary * 100000;\t \n\t\t}\n\n\t\t \n\t\tif (def == 2)\n\t\t\t \n\t\t\ttber = temporary;\n\t\telse if (def == 3)\n\t\t\t \n\t\t\ttber = temporary / 4;\n\t\telse if (def == 4)\n\t\t\t \n\t\t\ttber = temporary / 16;\n\t\telse if (def == 5)\n\t\t\t \n\t\t\ttber = temporary / 64;\n\t\telse if (def == 6)\n\t\t\t \n\t\t\ttber = temporary / 256;\n\t\telse\n\t\t\t \n\t\t\ttber = 0;\n\n\t\tif ((Errors < 4294967) && (Errors > 429496))\n\t\t\ttber *= 10;\n\n\t}\n\n\t \n\tter_state->pBER = tber;\n\n\t(*ber) = tber;\n\n\treturn 0;\n}\n#if 0\nstatic u32 stv0367ter_get_per(struct stv0367_state *state)\n{\n\tstruct stv0367ter_state *ter_state = state->ter_state;\n\tu32 Errors = 0, Per = 0, temporary = 0;\n\tint abc = 0, def = 0, cpt = 0;\n\n\twhile (((stv0367_readbits(state, F367TER_SFERRC_OLDVALUE) == 1) &&\n\t\t\t(cpt < 400)) || ((Errors == 0) && (cpt < 400))) {\n\t\tusleep_range(1000, 2000);\n\t\tErrors = ((u32)stv0367_readbits(state, F367TER_ERR_CNT1)\n\t\t\t* (1 << 16))\n\t\t\t+ ((u32)stv0367_readbits(state, F367TER_ERR_CNT1_HI)\n\t\t\t* (1 << 8))\n\t\t\t+ ((u32)stv0367_readbits(state, F367TER_ERR_CNT1_LO));\n\t\tcpt++;\n\t}\n\tabc = stv0367_readbits(state, F367TER_ERR_SRC1);\n\tdef = stv0367_readbits(state, F367TER_NUM_EVT1);\n\n\tif (Errors == 0)\n\t\tPer = 0;\n\telse if (abc == 0x9) {\n\t\tif (Errors <= 4) {\n\t\t\ttemporary = (Errors * 1000000000) / (8 * (1 << 8));\n\t\t} else if (Errors <= 42) {\n\t\t\ttemporary = (Errors * 100000000) / (8 * (1 << 8));\n\t\t\ttemporary = temporary * 10;\n\t\t} else if (Errors <= 429) {\n\t\t\ttemporary = (Errors * 10000000) / (8 * (1 << 8));\n\t\t\ttemporary = temporary * 100;\n\t\t} else if (Errors <= 4294) {\n\t\t\ttemporary = (Errors * 1000000) / (8 * (1 << 8));\n\t\t\ttemporary = temporary * 1000;\n\t\t} else if (Errors <= 42949) {\n\t\t\ttemporary = (Errors * 100000) / (8 * (1 << 8));\n\t\t\ttemporary = temporary * 10000;\n\t\t} else {  \n\t\t\ttemporary = (Errors * 10000) / (8 * (1 << 8));\n\t\t\ttemporary = temporary * 100000;\n\t\t}\n\n\t\t \n\t\tif (def == 2)\n\t\t\t \n\t\t\tPer = temporary;\n\t\telse if (def == 3)\n\t\t\t \n\t\t\tPer = temporary / 4;\n\t\telse if (def == 4)\n\t\t\t \n\t\t\tPer = temporary / 16;\n\t\telse if (def == 5)\n\t\t\t \n\t\t\tPer = temporary / 64;\n\t\telse if (def == 6)\n\t\t\t \n\t\t\tPer = temporary / 256;\n\t\telse\n\t\t\tPer = 0;\n\n\t}\n\t \n\tter_state->pPER = Per;\n\n\treturn Per;\n}\n#endif\nstatic int stv0367_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t\tstruct dvb_frontend_tune_settings\n\t\t\t\t\t*fe_tune_settings)\n{\n\tfe_tune_settings->min_delay_ms = 1000;\n\tfe_tune_settings->step_size = 0;\n\tfe_tune_settings->max_drift = 0;\n\n\treturn 0;\n}\n\nstatic void stv0367_release(struct dvb_frontend *fe)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\n\tkfree(state->ter_state);\n\tkfree(state->cab_state);\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops stv0367ter_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name\t\t\t= \"ST STV0367 DVB-T\",\n\t\t.frequency_min_hz\t=  47 * MHz,\n\t\t.frequency_max_hz\t= 862 * MHz,\n\t\t.frequency_stepsize_hz\t= 15625,\n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_128 | FE_CAN_QAM_256 | FE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_RECOVER |\n\t\t\tFE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_MUTE_TS\n\t},\n\t.release = stv0367_release,\n\t.init = stv0367ter_init,\n\t.sleep = stv0367ter_sleep,\n\t.i2c_gate_ctrl = stv0367ter_gate_ctrl,\n\t.set_frontend = stv0367ter_set_frontend,\n\t.get_frontend = stv0367ter_get_frontend,\n\t.get_tune_settings = stv0367_get_tune_settings,\n\t.read_status = stv0367ter_read_status,\n\t.read_ber = stv0367ter_read_ber, \n \n\t.read_snr = stv0367ter_read_snr,\n\t.read_ucblocks = stv0367ter_read_ucblocks,\n};\n\nstruct dvb_frontend *stv0367ter_attach(const struct stv0367_config *config,\n\t\t\t\t   struct i2c_adapter *i2c)\n{\n\tstruct stv0367_state *state = NULL;\n\tstruct stv0367ter_state *ter_state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct stv0367_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\tter_state = kzalloc(sizeof(struct stv0367ter_state), GFP_KERNEL);\n\tif (ter_state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->i2c = i2c;\n\tstate->config = config;\n\tstate->ter_state = ter_state;\n\tstate->fe.ops = stv0367ter_ops;\n\tstate->fe.demodulator_priv = state;\n\tstate->chip_id = stv0367_readreg(state, 0xf000);\n\n\t \n\tstate->use_i2c_gatectrl = 1;\n\tstate->deftabs = STV0367_DEFTAB_GENERIC;\n\tstate->reinit_on_setfrontend = 1;\n\tstate->auto_if_khz = 0;\n\n\tdprintk(\"%s: chip_id = 0x%x\\n\", __func__, state->chip_id);\n\n\t \n\tif ((state->chip_id != 0x50) && (state->chip_id != 0x60))\n\t\tgoto error;\n\n\treturn &state->fe;\n\nerror:\n\tkfree(ter_state);\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(stv0367ter_attach);\n\nstatic int stv0367cab_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tstv0367_writebits(state, F367CAB_I2CT_ON, (enable > 0) ? 1 : 0);\n\n\treturn 0;\n}\n\nstatic u32 stv0367cab_get_mclk(struct dvb_frontend *fe, u32 ExtClk_Hz)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tu32 mclk_Hz = 0; \n\tu32 M, N, P;\n\n\n\tif (stv0367_readbits(state, F367CAB_BYPASS_PLLXN) == 0) {\n\t\tN = (u32)stv0367_readbits(state, F367CAB_PLL_NDIV);\n\t\tif (N == 0)\n\t\t\tN = N + 1;\n\n\t\tM = (u32)stv0367_readbits(state, F367CAB_PLL_MDIV);\n\t\tif (M == 0)\n\t\t\tM = M + 1;\n\n\t\tP = (u32)stv0367_readbits(state, F367CAB_PLL_PDIV);\n\n\t\tif (P > 5)\n\t\t\tP = 5;\n\n\t\tmclk_Hz = ((ExtClk_Hz / 2) * N) / (M * (1 << P));\n\t\tdprintk(\"stv0367cab_get_mclk BYPASS_PLLXN mclk_Hz=%d\\n\",\n\t\t\t\t\t\t\t\tmclk_Hz);\n\t} else\n\t\tmclk_Hz = ExtClk_Hz;\n\n\tdprintk(\"stv0367cab_get_mclk final mclk_Hz=%d\\n\", mclk_Hz);\n\n\treturn mclk_Hz;\n}\n\nstatic u32 stv0367cab_get_adc_freq(struct dvb_frontend *fe, u32 ExtClk_Hz)\n{\n\treturn stv0367cab_get_mclk(fe, ExtClk_Hz);\n}\n\nstatic enum stv0367cab_mod stv0367cab_SetQamSize(struct stv0367_state *state,\n\t\t\t\t\t\t u32 SymbolRate,\n\t\t\t\t\t\t enum stv0367cab_mod QAMSize)\n{\n\t \n\tstv0367_writebits(state, F367CAB_QAM_MODE, QAMSize);\n\n\t \n\tswitch (QAMSize) {\n\tcase FE_CAB_MOD_QAM4:\n\t\tstv0367_writereg(state, R367CAB_IQDEM_ADJ_AGC_REF, 0x00);\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM16:\n\t\tstv0367_writereg(state, R367CAB_AGC_PWR_REF_L, 0x64);\n\t\tstv0367_writereg(state, R367CAB_IQDEM_ADJ_AGC_REF, 0x00);\n\t\tstv0367_writereg(state, R367CAB_FSM_STATE, 0x90);\n\t\tstv0367_writereg(state, R367CAB_EQU_CTR_LPF_GAIN, 0xc1);\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LPF_GAIN, 0xa7);\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LD_SEN, 0x95);\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LIMITER, 0x40);\n\t\tstv0367_writereg(state, R367CAB_EQU_PNT_GAIN, 0x8a);\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM32:\n\t\tstv0367_writereg(state, R367CAB_IQDEM_ADJ_AGC_REF, 0x00);\n\t\tstv0367_writereg(state, R367CAB_AGC_PWR_REF_L, 0x6e);\n\t\tstv0367_writereg(state, R367CAB_FSM_STATE, 0xb0);\n\t\tstv0367_writereg(state, R367CAB_EQU_CTR_LPF_GAIN, 0xc1);\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LPF_GAIN, 0xb7);\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LD_SEN, 0x9d);\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LIMITER, 0x7f);\n\t\tstv0367_writereg(state, R367CAB_EQU_PNT_GAIN, 0xa7);\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM64:\n\t\tstv0367_writereg(state, R367CAB_IQDEM_ADJ_AGC_REF, 0x82);\n\t\tstv0367_writereg(state, R367CAB_AGC_PWR_REF_L, 0x5a);\n\t\tif (SymbolRate > 4500000) {\n\t\t\tstv0367_writereg(state, R367CAB_FSM_STATE, 0xb0);\n\t\t\tstv0367_writereg(state, R367CAB_EQU_CTR_LPF_GAIN, 0xc1);\n\t\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LPF_GAIN, 0xa5);\n\t\t} else if (SymbolRate > 2500000) {\n\t\t\tstv0367_writereg(state, R367CAB_FSM_STATE, 0xa0);\n\t\t\tstv0367_writereg(state, R367CAB_EQU_CTR_LPF_GAIN, 0xc1);\n\t\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LPF_GAIN, 0xa6);\n\t\t} else {\n\t\t\tstv0367_writereg(state, R367CAB_FSM_STATE, 0xa0);\n\t\t\tstv0367_writereg(state, R367CAB_EQU_CTR_LPF_GAIN, 0xd1);\n\t\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LPF_GAIN, 0xa7);\n\t\t}\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LD_SEN, 0x95);\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LIMITER, 0x40);\n\t\tstv0367_writereg(state, R367CAB_EQU_PNT_GAIN, 0x99);\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM128:\n\t\tstv0367_writereg(state, R367CAB_IQDEM_ADJ_AGC_REF, 0x00);\n\t\tstv0367_writereg(state, R367CAB_AGC_PWR_REF_L, 0x76);\n\t\tstv0367_writereg(state, R367CAB_FSM_STATE, 0x90);\n\t\tstv0367_writereg(state, R367CAB_EQU_CTR_LPF_GAIN, 0xb1);\n\t\tif (SymbolRate > 4500000)\n\t\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LPF_GAIN, 0xa7);\n\t\telse if (SymbolRate > 2500000)\n\t\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LPF_GAIN, 0xa6);\n\t\telse\n\t\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LPF_GAIN, 0x97);\n\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LD_SEN, 0x8e);\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LIMITER, 0x7f);\n\t\tstv0367_writereg(state, R367CAB_EQU_PNT_GAIN, 0xa7);\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM256:\n\t\tstv0367_writereg(state, R367CAB_IQDEM_ADJ_AGC_REF, 0x94);\n\t\tstv0367_writereg(state, R367CAB_AGC_PWR_REF_L, 0x5a);\n\t\tstv0367_writereg(state, R367CAB_FSM_STATE, 0xa0);\n\t\tif (SymbolRate > 4500000)\n\t\t\tstv0367_writereg(state, R367CAB_EQU_CTR_LPF_GAIN, 0xc1);\n\t\telse if (SymbolRate > 2500000)\n\t\t\tstv0367_writereg(state, R367CAB_EQU_CTR_LPF_GAIN, 0xc1);\n\t\telse\n\t\t\tstv0367_writereg(state, R367CAB_EQU_CTR_LPF_GAIN, 0xd1);\n\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LPF_GAIN, 0xa7);\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LD_SEN, 0x85);\n\t\tstv0367_writereg(state, R367CAB_EQU_CRL_LIMITER, 0x40);\n\t\tstv0367_writereg(state, R367CAB_EQU_PNT_GAIN, 0xa7);\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM512:\n\t\tstv0367_writereg(state, R367CAB_IQDEM_ADJ_AGC_REF, 0x00);\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM1024:\n\t\tstv0367_writereg(state, R367CAB_IQDEM_ADJ_AGC_REF, 0x00);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn QAMSize;\n}\n\nstatic u32 stv0367cab_set_derot_freq(struct stv0367_state *state,\n\t\t\t\t\tu32 adc_hz, s32 derot_hz)\n{\n\tu32 sampled_if = 0;\n\tu32 adc_khz;\n\n\tadc_khz = adc_hz / 1000;\n\n\tdprintk(\"%s: adc_hz=%d derot_hz=%d\\n\", __func__, adc_hz, derot_hz);\n\n\tif (adc_khz != 0) {\n\t\tif (derot_hz < 1000000)\n\t\t\tderot_hz = adc_hz / 4;  \n\t\tif (derot_hz > adc_hz)\n\t\t\tderot_hz = derot_hz - adc_hz;\n\t\tsampled_if = (u32)derot_hz / 1000;\n\t\tsampled_if *= 32768;\n\t\tsampled_if /= adc_khz;\n\t\tsampled_if *= 256;\n\t}\n\n\tif (sampled_if > 8388607)\n\t\tsampled_if = 8388607;\n\n\tdprintk(\"%s: sampled_if=0x%x\\n\", __func__, sampled_if);\n\n\tstv0367_writereg(state, R367CAB_MIX_NCO_LL, sampled_if);\n\tstv0367_writereg(state, R367CAB_MIX_NCO_HL, (sampled_if >> 8));\n\tstv0367_writebits(state, F367CAB_MIX_NCO_INC_HH, (sampled_if >> 16));\n\n\treturn derot_hz;\n}\n\nstatic u32 stv0367cab_get_derot_freq(struct stv0367_state *state, u32 adc_hz)\n{\n\tu32 sampled_if;\n\n\tsampled_if = stv0367_readbits(state, F367CAB_MIX_NCO_INC_LL) +\n\t\t\t(stv0367_readbits(state, F367CAB_MIX_NCO_INC_HL) << 8) +\n\t\t\t(stv0367_readbits(state, F367CAB_MIX_NCO_INC_HH) << 16);\n\n\tsampled_if /= 256;\n\tsampled_if *= (adc_hz / 1000);\n\tsampled_if += 1;\n\tsampled_if /= 32768;\n\n\treturn sampled_if;\n}\n\nstatic u32 stv0367cab_set_srate(struct stv0367_state *state, u32 adc_hz,\n\t\t\tu32 mclk_hz, u32 SymbolRate,\n\t\t\tenum stv0367cab_mod QAMSize)\n{\n\tu32 QamSizeCorr = 0;\n\tu32 u32_tmp = 0, u32_tmp1 = 0;\n\tu32 adp_khz;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\t \n\tswitch (QAMSize) {\n\tcase FE_CAB_MOD_QAM4:\n\t\tQamSizeCorr = 1110;\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM16:\n\t\tQamSizeCorr = 1032;\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM32:\n\t\tQamSizeCorr =  954;\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM64:\n\t\tQamSizeCorr =  983;\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM128:\n\t\tQamSizeCorr =  957;\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM256:\n\t\tQamSizeCorr =  948;\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM512:\n\t\tQamSizeCorr =    0;\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM1024:\n\t\tQamSizeCorr =  944;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (adc_hz != 0) {\n\t\tu32_tmp = 256 * SymbolRate;\n\t\tu32_tmp = u32_tmp / adc_hz;\n\t}\n\tstv0367_writereg(state, R367CAB_EQU_CRL_TFR, (u8)u32_tmp);\n\n\t \n\tadp_khz = (mclk_hz >> 1) / 1000; \n\tif (adp_khz != 0) {\n\t\tu32_tmp = SymbolRate;\n\t\tu32_tmp1 = SymbolRate;\n\n\t\tif (u32_tmp < 2097152) {  \n\t\t\t \n\t\t\tu32_tmp *= 2048;  \n\t\t\tu32_tmp = u32_tmp / adp_khz;\n\t\t\tu32_tmp = u32_tmp * 16384;  \n\t\t\tu32_tmp /= 125 ;  \n\t\t\tu32_tmp = u32_tmp * 8;  \n\n\t\t\t \n\t\t\tu32_tmp1 *= 2048;  \n\t\t\tu32_tmp1 /= 439;  \n\t\t\tu32_tmp1 *= 256;  \n\t\t\tu32_tmp1 = u32_tmp1 / adp_khz;  \n\t\t\tu32_tmp1 *= QamSizeCorr * 9;  \n\t\t\tu32_tmp1 = u32_tmp1 / 10000000;\n\n\t\t} else if (u32_tmp < 4194304) {  \n\t\t\t \n\t\t\tu32_tmp *= 1024 ;  \n\t\t\tu32_tmp = u32_tmp / adp_khz;\n\t\t\tu32_tmp = u32_tmp * 16384;  \n\t\t\tu32_tmp /= 125 ;  \n\t\t\tu32_tmp = u32_tmp * 16;  \n\n\t\t\t \n\t\t\tu32_tmp1 *= 1024;  \n\t\t\tu32_tmp1 /= 439;  \n\t\t\tu32_tmp1 *= 256;  \n\t\t\tu32_tmp1 = u32_tmp1 / adp_khz;  \n\t\t\tu32_tmp1 *= QamSizeCorr * 9;  \n\t\t\tu32_tmp1 = u32_tmp1 / 5000000;\n\t\t} else if (u32_tmp < 8388607) {  \n\t\t\t \n\t\t\tu32_tmp *= 512 ;  \n\t\t\tu32_tmp = u32_tmp / adp_khz;\n\t\t\tu32_tmp = u32_tmp * 16384;  \n\t\t\tu32_tmp /= 125 ;  \n\t\t\tu32_tmp = u32_tmp * 32;  \n\n\t\t\t \n\t\t\tu32_tmp1 *= 512;  \n\t\t\tu32_tmp1 /= 439;  \n\t\t\tu32_tmp1 *= 256;  \n\t\t\tu32_tmp1 = u32_tmp1 / adp_khz;  \n\t\t\tu32_tmp1 *= QamSizeCorr * 9;  \n\t\t\tu32_tmp1 = u32_tmp1 / 2500000;\n\t\t} else {\n\t\t\t \n\t\t\tu32_tmp *= 256 ;  \n\t\t\tu32_tmp = u32_tmp / adp_khz;\n\t\t\tu32_tmp = u32_tmp * 16384;  \n\t\t\tu32_tmp /= 125 ;  \n\t\t\tu32_tmp = u32_tmp * 64;  \n\n\t\t\t \n\t\t\tu32_tmp1 *= 256;  \n\t\t\tu32_tmp1 /= 439;  \n\t\t\tu32_tmp1 *= 256;  \n\t\t\tu32_tmp1 = u32_tmp1 / adp_khz;  \n\t\t\tu32_tmp1 *= QamSizeCorr * 9;  \n\t\t\tu32_tmp1 = u32_tmp1 / 1250000;\n\t\t}\n\t}\n#if 0\n\t \n\tif (stv0367_readbits(state, F367CAB_ADJ_EN)) {\n\t\tstv0367cab_SetIirAdjacentcoefficient(state, mclk_hz,\n\t\t\t\t\t\t\t\tSymbolRate);\n\t\t \n\t\tstv0367_writebits(state, F367CAB_ALLPASSFILT_EN, 1);\n\t\tstv0367cab_SetAllPasscoefficient(state, mclk_hz, SymbolRate);\n\t} else\n\t\t \n#endif\n\tstv0367_writebits(state, F367CAB_ALLPASSFILT_EN, 0);\n\n\tstv0367_writereg(state, R367CAB_SRC_NCO_LL, u32_tmp);\n\tstv0367_writereg(state, R367CAB_SRC_NCO_LH, (u32_tmp >> 8));\n\tstv0367_writereg(state, R367CAB_SRC_NCO_HL, (u32_tmp >> 16));\n\tstv0367_writereg(state, R367CAB_SRC_NCO_HH, (u32_tmp >> 24));\n\n\tstv0367_writereg(state, R367CAB_IQDEM_GAIN_SRC_L, u32_tmp1 & 0x00ff);\n\tstv0367_writebits(state, F367CAB_GAIN_SRC_HI, (u32_tmp1 >> 8) & 0x00ff);\n\n\treturn SymbolRate ;\n}\n\nstatic u32 stv0367cab_GetSymbolRate(struct stv0367_state *state, u32 mclk_hz)\n{\n\tu32 regsym;\n\tu32 adp_khz;\n\n\tregsym = stv0367_readreg(state, R367CAB_SRC_NCO_LL) +\n\t\t(stv0367_readreg(state, R367CAB_SRC_NCO_LH) << 8) +\n\t\t(stv0367_readreg(state, R367CAB_SRC_NCO_HL) << 16) +\n\t\t(stv0367_readreg(state, R367CAB_SRC_NCO_HH) << 24);\n\n\tadp_khz = (mclk_hz >> 1) / 1000; \n\n\tif (regsym < 134217728) {\t\t \n\t\tregsym = regsym * 32;\t\t \n\t\tregsym = regsym / 32768;\t \n\t\tregsym = adp_khz * regsym;\t \n\t\tregsym = regsym / 128;\t\t \n\t\tregsym *= 125 ;\t\t\t \n\t\tregsym /= 2048 ;\t\t \n\t} else if (regsym < 268435456) {\t \n\t\tregsym = regsym * 16;\t\t \n\t\tregsym = regsym / 32768;\t \n\t\tregsym = adp_khz * regsym;\t \n\t\tregsym = regsym / 128;\t\t \n\t\tregsym *= 125 ;\t\t\t \n\t\tregsym /= 1024 ;\t\t \n\t} else if (regsym < 536870912) {\t \n\t\tregsym = regsym * 8;\t\t \n\t\tregsym = regsym / 32768;\t \n\t\tregsym = adp_khz * regsym;\t \n\t\tregsym = regsym / 128;\t\t \n\t\tregsym *= 125 ;\t\t\t \n\t\tregsym /= 512 ;\t\t\t \n\t} else {\n\t\tregsym = regsym * 4;\t\t \n\t\tregsym = regsym / 32768;\t \n\t\tregsym = adp_khz * regsym;\t \n\t\tregsym = regsym / 128;\t\t \n\t\tregsym *= 125 ;\t\t\t \n\t\tregsym /= 256 ;\t\t\t \n\t}\n\n\treturn regsym;\n}\n\nstatic u32 stv0367cab_fsm_status(struct stv0367_state *state)\n{\n\treturn stv0367_readbits(state, F367CAB_FSM_STATUS);\n}\n\nstatic u32 stv0367cab_qamfec_lock(struct stv0367_state *state)\n{\n\treturn stv0367_readbits(state,\n\t\t(state->cab_state->qamfec_status_reg ?\n\t\t state->cab_state->qamfec_status_reg :\n\t\t F367CAB_QAMFEC_LOCK));\n}\n\nstatic\nenum stv0367_cab_signal_type stv0367cab_fsm_signaltype(u32 qam_fsm_status)\n{\n\tenum stv0367_cab_signal_type signaltype = FE_CAB_NOAGC;\n\n\tswitch (qam_fsm_status) {\n\tcase 1:\n\t\tsignaltype = FE_CAB_NOAGC;\n\t\tbreak;\n\tcase 2:\n\t\tsignaltype = FE_CAB_NOTIMING;\n\t\tbreak;\n\tcase 3:\n\t\tsignaltype = FE_CAB_TIMINGOK;\n\t\tbreak;\n\tcase 4:\n\t\tsignaltype = FE_CAB_NOCARRIER;\n\t\tbreak;\n\tcase 5:\n\t\tsignaltype = FE_CAB_CARRIEROK;\n\t\tbreak;\n\tcase 7:\n\t\tsignaltype = FE_CAB_NOBLIND;\n\t\tbreak;\n\tcase 8:\n\t\tsignaltype = FE_CAB_BLINDOK;\n\t\tbreak;\n\tcase 10:\n\t\tsignaltype = FE_CAB_NODEMOD;\n\t\tbreak;\n\tcase 11:\n\t\tsignaltype = FE_CAB_DEMODOK;\n\t\tbreak;\n\tcase 12:\n\t\tsignaltype = FE_CAB_DEMODOK;\n\t\tbreak;\n\tcase 13:\n\t\tsignaltype = FE_CAB_NODEMOD;\n\t\tbreak;\n\tcase 14:\n\t\tsignaltype = FE_CAB_NOBLIND;\n\t\tbreak;\n\tcase 15:\n\t\tsignaltype = FE_CAB_NOSIGNAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn signaltype;\n}\n\nstatic int stv0367cab_read_status(struct dvb_frontend *fe,\n\t\t\t\t  enum fe_status *status)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\t*status = 0;\n\n\t \n\tstate->cab_state->state = stv0367cab_fsm_signaltype(\n\t\tstv0367cab_fsm_status(state));\n\n\tif (stv0367cab_qamfec_lock(state)) {\n\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI\n\t\t\t  | FE_HAS_SYNC | FE_HAS_LOCK;\n\t\tdprintk(\"%s: stv0367 has locked\\n\", __func__);\n\t} else {\n\t\tif (state->cab_state->state > FE_CAB_NOSIGNAL)\n\t\t\t*status |= FE_HAS_SIGNAL;\n\n\t\tif (state->cab_state->state > FE_CAB_NOCARRIER)\n\t\t\t*status |= FE_HAS_CARRIER;\n\n\t\tif (state->cab_state->state >= FE_CAB_DEMODOK)\n\t\t\t*status |= FE_HAS_VITERBI;\n\n\t\tif (state->cab_state->state >= FE_CAB_DATAOK)\n\t\t\t*status |= FE_HAS_SYNC;\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0367cab_standby(struct dvb_frontend *fe, u8 standby_on)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tif (standby_on) {\n\t\tstv0367_writebits(state, F367CAB_BYPASS_PLLXN, 0x03);\n\t\tstv0367_writebits(state, F367CAB_STDBY_PLLXN, 0x01);\n\t\tstv0367_writebits(state, F367CAB_STDBY, 1);\n\t\tstv0367_writebits(state, F367CAB_STDBY_CORE, 1);\n\t\tstv0367_writebits(state, F367CAB_EN_BUFFER_I, 0);\n\t\tstv0367_writebits(state, F367CAB_EN_BUFFER_Q, 0);\n\t\tstv0367_writebits(state, F367CAB_POFFQ, 1);\n\t\tstv0367_writebits(state, F367CAB_POFFI, 1);\n\t} else {\n\t\tstv0367_writebits(state, F367CAB_STDBY_PLLXN, 0x00);\n\t\tstv0367_writebits(state, F367CAB_BYPASS_PLLXN, 0x00);\n\t\tstv0367_writebits(state, F367CAB_STDBY, 0);\n\t\tstv0367_writebits(state, F367CAB_STDBY_CORE, 0);\n\t\tstv0367_writebits(state, F367CAB_EN_BUFFER_I, 1);\n\t\tstv0367_writebits(state, F367CAB_EN_BUFFER_Q, 1);\n\t\tstv0367_writebits(state, F367CAB_POFFQ, 0);\n\t\tstv0367_writebits(state, F367CAB_POFFI, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0367cab_sleep(struct dvb_frontend *fe)\n{\n\treturn stv0367cab_standby(fe, 1);\n}\n\nstatic int stv0367cab_init(struct dvb_frontend *fe)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct stv0367cab_state *cab_state = state->cab_state;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tstv0367_write_table(state,\n\t\tstv0367_deftabs[state->deftabs][STV0367_TAB_CAB]);\n\n\tswitch (state->config->ts_mode) {\n\tcase STV0367_DVBCI_CLOCK:\n\t\tdprintk(\"Setting TSMode = STV0367_DVBCI_CLOCK\\n\");\n\t\tstv0367_writebits(state, F367CAB_OUTFORMAT, 0x03);\n\t\tbreak;\n\tcase STV0367_SERIAL_PUNCT_CLOCK:\n\tcase STV0367_SERIAL_CONT_CLOCK:\n\t\tstv0367_writebits(state, F367CAB_OUTFORMAT, 0x01);\n\t\tbreak;\n\tcase STV0367_PARALLEL_PUNCT_CLOCK:\n\tcase STV0367_OUTPUTMODE_DEFAULT:\n\t\tstv0367_writebits(state, F367CAB_OUTFORMAT, 0x00);\n\t\tbreak;\n\t}\n\n\tswitch (state->config->clk_pol) {\n\tcase STV0367_RISINGEDGE_CLOCK:\n\t\tstv0367_writebits(state, F367CAB_CLK_POLARITY, 0x00);\n\t\tbreak;\n\tcase STV0367_FALLINGEDGE_CLOCK:\n\tcase STV0367_CLOCKPOLARITY_DEFAULT:\n\t\tstv0367_writebits(state, F367CAB_CLK_POLARITY, 0x01);\n\t\tbreak;\n\t}\n\n\tstv0367_writebits(state, F367CAB_SYNC_STRIP, 0x00);\n\n\tstv0367_writebits(state, F367CAB_CT_NBST, 0x01);\n\n\tstv0367_writebits(state, F367CAB_TS_SWAP, 0x01);\n\n\tstv0367_writebits(state, F367CAB_FIFO_BYPASS, 0x00);\n\n\tstv0367_writereg(state, R367CAB_ANACTRL, 0x00); \n\n\tcab_state->mclk = stv0367cab_get_mclk(fe, state->config->xtal);\n\tcab_state->adc_clk = stv0367cab_get_adc_freq(fe, state->config->xtal);\n\n\treturn 0;\n}\nstatic\nenum stv0367_cab_signal_type stv0367cab_algo(struct stv0367_state *state,\n\t\t\t\t\t     struct dtv_frontend_properties *p)\n{\n\tstruct stv0367cab_state *cab_state = state->cab_state;\n\tenum stv0367_cab_signal_type signalType = FE_CAB_NOAGC;\n\tu32\tQAMFEC_Lock, QAM_Lock, u32_tmp, ifkhz,\n\t\tLockTime, TRLTimeOut, AGCTimeOut, CRLSymbols,\n\t\tCRLTimeOut, EQLTimeOut, DemodTimeOut, FECTimeOut;\n\tu8\tTrackAGCAccum;\n\ts32\ttmp;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tstv0367_get_if_khz(state, &ifkhz);\n\n\t \n\t \n\tAGCTimeOut = 25;\n\t \n\tTRLTimeOut = 100000000 / p->symbol_rate;\n\t \n\tswitch (p->modulation) {\n\tcase QAM_16:\n\t\tCRLSymbols = 150000;\n\t\tEQLTimeOut = 100;\n\t\tbreak;\n\tcase QAM_32:\n\t\tCRLSymbols = 250000;\n\t\tEQLTimeOut = 100;\n\t\tbreak;\n\tcase QAM_64:\n\t\tCRLSymbols = 200000;\n\t\tEQLTimeOut = 100;\n\t\tbreak;\n\tcase QAM_128:\n\t\tCRLSymbols = 250000;\n\t\tEQLTimeOut = 100;\n\t\tbreak;\n\tcase QAM_256:\n\t\tCRLSymbols = 250000;\n\t\tEQLTimeOut = 100;\n\t\tbreak;\n\tdefault:\n\t\tCRLSymbols = 200000;\n\t\tEQLTimeOut = 100;\n\t\tbreak;\n\t}\n#if 0\n\tif (pIntParams->search_range < 0) {\n\t\tCRLTimeOut = (25 * CRLSymbols *\n\t\t\t\t(-pIntParams->search_range / 1000)) /\n\t\t\t\t\t(pIntParams->symbol_rate / 1000);\n\t} else\n#endif\n\tCRLTimeOut = (25 * CRLSymbols * (cab_state->search_range / 1000)) /\n\t\t\t\t\t(p->symbol_rate / 1000);\n\n\tCRLTimeOut = (1000 * CRLTimeOut) / p->symbol_rate;\n\t \n\tif (CRLTimeOut < 50)\n\t\tCRLTimeOut = 50;\n\t \n\tFECTimeOut = 20;\n\tDemodTimeOut = AGCTimeOut + TRLTimeOut + CRLTimeOut + EQLTimeOut;\n\n\tdprintk(\"%s: DemodTimeOut=%d\\n\", __func__, DemodTimeOut);\n\n\t \n\tstv0367_writereg(state, R367CAB_CTRL_1, 0x04);\n\t \n\tTrackAGCAccum = stv0367_readbits(state, F367CAB_AGC_ACCUMRSTSEL);\n\tstv0367_writebits(state, F367CAB_AGC_ACCUMRSTSEL, 0x0);\n\t \n\tstv0367_writebits(state, F367CAB_MODULUSMAP_EN, 0);\n\t \n\tstv0367_writebits(state, F367CAB_SWEEP_EN, 0);\n\t \n\t \n\tstv0367cab_set_derot_freq(state, cab_state->adc_clk,\n\t\t(1000 * (s32)ifkhz + cab_state->derot_offset));\n\t \n\tif ((p->symbol_rate > 10800000) | (p->symbol_rate < 1800000)) {\n\t\tstv0367_writebits(state, F367CAB_ADJ_EN, 0);\n\t\tstv0367_writebits(state, F367CAB_ALLPASSFILT_EN, 0);\n\t}\n#if 0\n\t \n\ttuner_lock = stv0367cab_tuner_get_status(fe);\n\tif (tuner_lock == 0)\n\t\treturn FE_367CAB_NOTUNER;\n#endif\n\t \n\t \n\tLockTime = 0;\n\tstv0367_writereg(state, R367CAB_CTRL_1, 0x00);\n\tdo {\n\t\tQAM_Lock = stv0367cab_fsm_status(state);\n\t\tif ((LockTime >= (DemodTimeOut - EQLTimeOut)) &&\n\t\t\t\t\t\t\t(QAM_Lock == 0x04))\n\t\t\t \n\t\t\tLockTime = DemodTimeOut;\n\t\telse if ((LockTime >= (AGCTimeOut + TRLTimeOut)) &&\n\t\t\t\t\t\t\t(QAM_Lock == 0x02))\n\t\t\t \n\t\t{\n\t\t\tLockTime = DemodTimeOut;\n\t\t\tu32_tmp = stv0367_readbits(state,\n\t\t\t\t\t\tF367CAB_AGC_PWR_WORD_LO) +\n\t\t\t\t\t(stv0367_readbits(state,\n\t\t\t\t\t\tF367CAB_AGC_PWR_WORD_ME) << 8) +\n\t\t\t\t\t(stv0367_readbits(state,\n\t\t\t\t\t\tF367CAB_AGC_PWR_WORD_HI) << 16);\n\t\t\tif (u32_tmp >= 131072)\n\t\t\t\tu32_tmp = 262144 - u32_tmp;\n\t\t\tu32_tmp = u32_tmp / (1 << (11 - stv0367_readbits(state,\n\t\t\t\t\t\t\tF367CAB_AGC_IF_BWSEL)));\n\n\t\t\tif (u32_tmp < stv0367_readbits(state,\n\t\t\t\t\t\tF367CAB_AGC_PWRREF_LO) +\n\t\t\t\t\t256 * stv0367_readbits(state,\n\t\t\t\t\t\tF367CAB_AGC_PWRREF_HI) - 10)\n\t\t\t\tQAM_Lock = 0x0f;\n\t\t} else {\n\t\t\tusleep_range(10000, 20000);\n\t\t\tLockTime += 10;\n\t\t}\n\t\tdprintk(\"QAM_Lock=0x%x LockTime=%d\\n\", QAM_Lock, LockTime);\n\t\ttmp = stv0367_readreg(state, R367CAB_IT_STATUS1);\n\n\t\tdprintk(\"R367CAB_IT_STATUS1=0x%x\\n\", tmp);\n\n\t} while (((QAM_Lock != 0x0c) && (QAM_Lock != 0x0b)) &&\n\t\t\t\t\t\t(LockTime < DemodTimeOut));\n\n\tdprintk(\"QAM_Lock=0x%x\\n\", QAM_Lock);\n\n\ttmp = stv0367_readreg(state, R367CAB_IT_STATUS1);\n\tdprintk(\"R367CAB_IT_STATUS1=0x%x\\n\", tmp);\n\ttmp = stv0367_readreg(state, R367CAB_IT_STATUS2);\n\tdprintk(\"R367CAB_IT_STATUS2=0x%x\\n\", tmp);\n\n\ttmp  = stv0367cab_get_derot_freq(state, cab_state->adc_clk);\n\tdprintk(\"stv0367cab_get_derot_freq=0x%x\\n\", tmp);\n\n\tif ((QAM_Lock == 0x0c) || (QAM_Lock == 0x0b)) {\n\t\t \n\t\tLockTime = 0;\n\t\tdo {\n\t\t\tusleep_range(5000, 7000);\n\t\t\tLockTime += 5;\n\t\t\tQAMFEC_Lock = stv0367cab_qamfec_lock(state);\n\t\t} while (!QAMFEC_Lock && (LockTime < FECTimeOut));\n\t} else\n\t\tQAMFEC_Lock = 0;\n\n\tif (QAMFEC_Lock) {\n\t\tsignalType = FE_CAB_DATAOK;\n\t\tcab_state->spect_inv = stv0367_readbits(state,\n\t\t\t\t\t\t\tF367CAB_QUAD_INV);\n#if 0\n \n\t\tif (ifkhz != 0) {\n\t\t\tif (ifkhz > cab_state->adc_clk / 1000) {\n\t\t\t\tcab_state->freq_khz =\n\t\t\t\t\tFE_Cab_TunerGetFrequency(pIntParams->hTuner)\n\t\t\t\t- stv0367cab_get_derot_freq(state, cab_state->adc_clk)\n\t\t\t\t- cab_state->adc_clk / 1000 + ifkhz;\n\t\t\t} else {\n\t\t\t\tcab_state->freq_khz =\n\t\t\t\t\t\tFE_Cab_TunerGetFrequency(pIntParams->hTuner)\n\t\t\t\t\t\t- stv0367cab_get_derot_freq(state, cab_state->adc_clk)\n\t\t\t\t\t\t+ ifkhz;\n\t\t\t}\n\t\t} else {\n\t\t\tcab_state->freq_khz =\n\t\t\t\tFE_Cab_TunerGetFrequency(pIntParams->hTuner) +\n\t\t\t\tstv0367cab_get_derot_freq(state,\n\t\t\t\t\t\t\tcab_state->adc_clk) -\n\t\t\t\tcab_state->adc_clk / 4000;\n\t\t}\n#endif\n\t\tcab_state->symbol_rate = stv0367cab_GetSymbolRate(state,\n\t\t\t\t\t\t\tcab_state->mclk);\n\t\tcab_state->locked = 1;\n\n\t\t \n\t} else\n\t\tsignalType = stv0367cab_fsm_signaltype(QAM_Lock);\n\n\t \n\tstv0367_writebits(state, F367CAB_AGC_ACCUMRSTSEL, TrackAGCAccum);\n\treturn signalType;\n}\n\nstatic int stv0367cab_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct stv0367cab_state *cab_state = state->cab_state;\n\tenum stv0367cab_mod QAMSize = 0;\n\n\tdprintk(\"%s: freq = %d, srate = %d\\n\", __func__,\n\t\t\t\t\tp->frequency, p->symbol_rate);\n\n\tcab_state->derot_offset = 0;\n\n\tswitch (p->modulation) {\n\tcase QAM_16:\n\t\tQAMSize = FE_CAB_MOD_QAM16;\n\t\tbreak;\n\tcase QAM_32:\n\t\tQAMSize = FE_CAB_MOD_QAM32;\n\t\tbreak;\n\tcase QAM_64:\n\t\tQAMSize = FE_CAB_MOD_QAM64;\n\t\tbreak;\n\tcase QAM_128:\n\t\tQAMSize = FE_CAB_MOD_QAM128;\n\t\tbreak;\n\tcase QAM_256:\n\t\tQAMSize = FE_CAB_MOD_QAM256;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (state->reinit_on_setfrontend)\n\t\tstv0367cab_init(fe);\n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tif (state->use_i2c_gatectrl && fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (state->use_i2c_gatectrl && fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tstv0367cab_SetQamSize(\n\t\t\tstate,\n\t\t\tp->symbol_rate,\n\t\t\tQAMSize);\n\n\tstv0367cab_set_srate(state,\n\t\t\tcab_state->adc_clk,\n\t\t\tcab_state->mclk,\n\t\t\tp->symbol_rate,\n\t\t\tQAMSize);\n\t \n\tcab_state->state = stv0367cab_algo(state, p);\n\treturn 0;\n}\n\nstatic int stv0367cab_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t   struct dtv_frontend_properties *p)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct stv0367cab_state *cab_state = state->cab_state;\n\tu32 ifkhz = 0;\n\n\tenum stv0367cab_mod QAMSize;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tstv0367_get_if_khz(state, &ifkhz);\n\tp->symbol_rate = stv0367cab_GetSymbolRate(state, cab_state->mclk);\n\n\tQAMSize = stv0367_readbits(state, F367CAB_QAM_MODE);\n\tswitch (QAMSize) {\n\tcase FE_CAB_MOD_QAM16:\n\t\tp->modulation = QAM_16;\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM32:\n\t\tp->modulation = QAM_32;\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM64:\n\t\tp->modulation = QAM_64;\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM128:\n\t\tp->modulation = QAM_128;\n\t\tbreak;\n\tcase FE_CAB_MOD_QAM256:\n\t\tp->modulation = QAM_256;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tp->frequency = stv0367_get_tuner_freq(fe);\n\n\tdprintk(\"%s: tuner frequency = %d\\n\", __func__, p->frequency);\n\n\tif (ifkhz == 0) {\n\t\tp->frequency +=\n\t\t\t(stv0367cab_get_derot_freq(state, cab_state->adc_clk) -\n\t\t\tcab_state->adc_clk / 4000);\n\t\treturn 0;\n\t}\n\n\tif (ifkhz > cab_state->adc_clk / 1000)\n\t\tp->frequency += (ifkhz\n\t\t\t- stv0367cab_get_derot_freq(state, cab_state->adc_clk)\n\t\t\t- cab_state->adc_clk / 1000);\n\telse\n\t\tp->frequency += (ifkhz\n\t\t\t- stv0367cab_get_derot_freq(state, cab_state->adc_clk));\n\n\treturn 0;\n}\n\n#if 0\nvoid stv0367cab_GetErrorCount(state, enum stv0367cab_mod QAMSize,\n\t\t\tu32 symbol_rate, FE_367qam_Monitor *Monitor_results)\n{\n\tstv0367cab_OptimiseNByteAndGetBER(state, QAMSize, symbol_rate, Monitor_results);\n\tstv0367cab_GetPacketsCount(state, Monitor_results);\n\n\treturn;\n}\n\nstatic int stv0367cab_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\n\treturn 0;\n}\n#endif\nstatic s32 stv0367cab_get_rf_lvl(struct stv0367_state *state)\n{\n\ts32 rfLevel = 0;\n\ts32 RfAgcPwm = 0, IfAgcPwm = 0;\n\tu8 i;\n\n\tstv0367_writebits(state, F367CAB_STDBY_ADCGP, 0x0);\n\n\tRfAgcPwm =\n\t\t(stv0367_readbits(state, F367CAB_RF_AGC1_LEVEL_LO) & 0x03) +\n\t\t(stv0367_readbits(state, F367CAB_RF_AGC1_LEVEL_HI) << 2);\n\tRfAgcPwm = 100 * RfAgcPwm / 1023;\n\n\tIfAgcPwm =\n\t\tstv0367_readbits(state, F367CAB_AGC_IF_PWMCMD_LO) +\n\t\t(stv0367_readbits(state, F367CAB_AGC_IF_PWMCMD_HI) << 8);\n\tif (IfAgcPwm >= 2048)\n\t\tIfAgcPwm -= 2048;\n\telse\n\t\tIfAgcPwm += 2048;\n\n\tIfAgcPwm = 100 * IfAgcPwm / 4095;\n\n\t \n\tif (RfAgcPwm < 90  && IfAgcPwm < 28) {\n\t\tfor (i = 0; i < RF_LOOKUP_TABLE_SIZE; i++) {\n\t\t\tif (RfAgcPwm <= stv0367cab_RF_LookUp1[0][i]) {\n\t\t\t\trfLevel = (-1) * stv0367cab_RF_LookUp1[1][i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == RF_LOOKUP_TABLE_SIZE)\n\t\t\trfLevel = -56;\n\t} else {  \n\t\tfor (i = 0; i < RF_LOOKUP_TABLE2_SIZE; i++) {\n\t\t\tif (IfAgcPwm <= stv0367cab_RF_LookUp2[0][i]) {\n\t\t\t\trfLevel = (-1) * stv0367cab_RF_LookUp2[1][i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == RF_LOOKUP_TABLE2_SIZE)\n\t\t\trfLevel = -72;\n\t}\n\treturn rfLevel;\n}\n\nstatic int stv0367cab_read_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\n\ts32 signal =  stv0367cab_get_rf_lvl(state);\n\n\tdprintk(\"%s: signal=%d dBm\\n\", __func__, signal);\n\n\tif (signal <= -72)\n\t\t*strength = 65535;\n\telse\n\t\t*strength = (22 + signal) * (-1311);\n\n\tdprintk(\"%s: strength=%d\\n\", __func__, (*strength));\n\n\treturn 0;\n}\n\nstatic int stv0367cab_snr_power(struct dvb_frontend *fe)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tenum stv0367cab_mod QAMSize;\n\n\tQAMSize = stv0367_readbits(state, F367CAB_QAM_MODE);\n\tswitch (QAMSize) {\n\tcase FE_CAB_MOD_QAM4:\n\t\treturn 21904;\n\tcase FE_CAB_MOD_QAM16:\n\t\treturn 20480;\n\tcase FE_CAB_MOD_QAM32:\n\t\treturn 23040;\n\tcase FE_CAB_MOD_QAM64:\n\t\treturn 21504;\n\tcase FE_CAB_MOD_QAM128:\n\t\treturn 23616;\n\tcase FE_CAB_MOD_QAM256:\n\t\treturn 21760;\n\tcase FE_CAB_MOD_QAM1024:\n\t\treturn 21280;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\nstatic int stv0367cab_snr_readreg(struct dvb_frontend *fe, int avgdiv)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tu32 regval = 0;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tregval += (stv0367_readbits(state, F367CAB_SNR_LO)\n\t\t\t+ 256 * stv0367_readbits(state, F367CAB_SNR_HI));\n\t}\n\n\tif (avgdiv)\n\t\tregval /= 10;\n\n\treturn regval;\n}\n\nstatic int stv0367cab_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tu32 noisepercentage;\n\tu32 regval = 0, temp = 0;\n\tint power;\n\n\tpower = stv0367cab_snr_power(fe);\n\tregval = stv0367cab_snr_readreg(fe, 1);\n\n\tif (regval != 0) {\n\t\ttemp = power\n\t\t\t* (1 << (3 + stv0367_readbits(state, F367CAB_SNR_PER)));\n\t\ttemp /= regval;\n\t}\n\n\t \n\tif (temp >= 5012)\n\t\tnoisepercentage = 100;\n\telse if (temp >= 3981)\n\t\tnoisepercentage = 93;\n\telse if (temp >= 3162)\n\t\tnoisepercentage = 86;\n\telse if (temp >= 2512)\n\t\tnoisepercentage = 79;\n\telse if (temp >= 1995)\n\t\tnoisepercentage = 72;\n\telse if (temp >= 1585)\n\t\tnoisepercentage = 65;\n\telse if (temp >= 1259)\n\t\tnoisepercentage = 58;\n\telse if (temp >= 1000)\n\t\tnoisepercentage = 50;\n\telse if (temp >= 794)\n\t\tnoisepercentage = 43;\n\telse if (temp >= 501)\n\t\tnoisepercentage = 36;\n\telse if (temp >= 316)\n\t\tnoisepercentage = 29;\n\telse if (temp >= 200)\n\t\tnoisepercentage = 22;\n\telse if (temp >= 158)\n\t\tnoisepercentage = 14;\n\telse if (temp >= 126)\n\t\tnoisepercentage = 7;\n\telse\n\t\tnoisepercentage = 0;\n\n\tdprintk(\"%s: noisepercentage=%d\\n\", __func__, noisepercentage);\n\n\t*snr = (noisepercentage * 65535) / 100;\n\n\treturn 0;\n}\n\nstatic int stv0367cab_read_ucblcks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tint corrected, tscount;\n\n\t*ucblocks = (stv0367_readreg(state, R367CAB_RS_COUNTER_5) << 8)\n\t\t\t| stv0367_readreg(state, R367CAB_RS_COUNTER_4);\n\tcorrected = (stv0367_readreg(state, R367CAB_RS_COUNTER_3) << 8)\n\t\t\t| stv0367_readreg(state, R367CAB_RS_COUNTER_2);\n\ttscount = (stv0367_readreg(state, R367CAB_RS_COUNTER_2) << 8)\n\t\t\t| stv0367_readreg(state, R367CAB_RS_COUNTER_1);\n\n\tdprintk(\"%s: uncorrected blocks=%d corrected blocks=%d tscount=%d\\n\",\n\t\t\t\t__func__, *ucblocks, corrected, tscount);\n\n\treturn 0;\n};\n\nstatic const struct dvb_frontend_ops stv0367cab_ops = {\n\t.delsys = { SYS_DVBC_ANNEX_A },\n\t.info = {\n\t\t.name = \"ST STV0367 DVB-C\",\n\t\t.frequency_min_hz =  47 * MHz,\n\t\t.frequency_max_hz = 862 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.symbol_rate_min = 870000,\n\t\t.symbol_rate_max = 11700000,\n\t\t.caps = 0x400 | \n\t\t\tFE_CAN_QAM_16 | FE_CAN_QAM_32  |\n\t\t\tFE_CAN_QAM_64 | FE_CAN_QAM_128 |\n\t\t\tFE_CAN_QAM_256 | FE_CAN_FEC_AUTO\n\t},\n\t.release\t\t\t\t= stv0367_release,\n\t.init\t\t\t\t\t= stv0367cab_init,\n\t.sleep\t\t\t\t\t= stv0367cab_sleep,\n\t.i2c_gate_ctrl\t\t\t\t= stv0367cab_gate_ctrl,\n\t.set_frontend\t\t\t\t= stv0367cab_set_frontend,\n\t.get_frontend\t\t\t\t= stv0367cab_get_frontend,\n\t.read_status\t\t\t\t= stv0367cab_read_status,\n \n\t.read_signal_strength\t\t\t= stv0367cab_read_strength,\n\t.read_snr\t\t\t\t= stv0367cab_read_snr,\n\t.read_ucblocks\t\t\t\t= stv0367cab_read_ucblcks,\n\t.get_tune_settings\t\t\t= stv0367_get_tune_settings,\n};\n\nstruct dvb_frontend *stv0367cab_attach(const struct stv0367_config *config,\n\t\t\t\t   struct i2c_adapter *i2c)\n{\n\tstruct stv0367_state *state = NULL;\n\tstruct stv0367cab_state *cab_state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct stv0367_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\tcab_state = kzalloc(sizeof(struct stv0367cab_state), GFP_KERNEL);\n\tif (cab_state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->i2c = i2c;\n\tstate->config = config;\n\tcab_state->search_range = 280000;\n\tcab_state->qamfec_status_reg = F367CAB_QAMFEC_LOCK;\n\tstate->cab_state = cab_state;\n\tstate->fe.ops = stv0367cab_ops;\n\tstate->fe.demodulator_priv = state;\n\tstate->chip_id = stv0367_readreg(state, 0xf000);\n\n\t \n\tstate->use_i2c_gatectrl = 1;\n\tstate->deftabs = STV0367_DEFTAB_GENERIC;\n\tstate->reinit_on_setfrontend = 1;\n\tstate->auto_if_khz = 0;\n\n\tdprintk(\"%s: chip_id = 0x%x\\n\", __func__, state->chip_id);\n\n\t \n\tif ((state->chip_id != 0x50) && (state->chip_id != 0x60))\n\t\tgoto error;\n\n\treturn &state->fe;\n\nerror:\n\tkfree(cab_state);\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(stv0367cab_attach);\n\n \n\nstatic void stv0367ddb_setup_ter(struct stv0367_state *state)\n{\n\tstv0367_writereg(state, R367TER_DEBUG_LT4, 0x00);\n\tstv0367_writereg(state, R367TER_DEBUG_LT5, 0x00);\n\tstv0367_writereg(state, R367TER_DEBUG_LT6, 0x00);  \n\tstv0367_writereg(state, R367TER_DEBUG_LT7, 0x00);  \n\tstv0367_writereg(state, R367TER_DEBUG_LT8, 0x00);\n\tstv0367_writereg(state, R367TER_DEBUG_LT9, 0x00);\n\n\t \n\t \n\tstv0367_writereg(state, R367TER_ANADIGCTRL, 0x89);\n\tstv0367_writereg(state, R367TER_DUAL_AD12, 0x04);  \n\n\t \n\t \n\tstv0367_writereg(state, R367TER_ANACTRL, 0x0D);\n\tstv0367_writereg(state, R367TER_TOPCTRL, 0x00);  \n\n\t \n\tstv0367_pll_setup(state, STV0367_ICSPEED_53125, state->config->xtal);\n\n\tmsleep(50);\n\t \n\tstv0367_writereg(state, R367TER_ANACTRL, 0x00);\n\n\tstate->activedemod = demod_ter;\n}\n\nstatic void stv0367ddb_setup_cab(struct stv0367_state *state)\n{\n\tstv0367_writereg(state, R367TER_DEBUG_LT4, 0x00);\n\tstv0367_writereg(state, R367TER_DEBUG_LT5, 0x01);\n\tstv0367_writereg(state, R367TER_DEBUG_LT6, 0x06);  \n\tstv0367_writereg(state, R367TER_DEBUG_LT7, 0x03);  \n\tstv0367_writereg(state, R367TER_DEBUG_LT8, 0x00);\n\tstv0367_writereg(state, R367TER_DEBUG_LT9, 0x00);\n\n\t \n\t \n\tstv0367_writereg(state, R367TER_ANADIGCTRL, 0x8B);\n\t \n\tstv0367_writereg(state, R367TER_DUAL_AD12, 0x04);\n\n\t \n\t \n\tstv0367_writereg(state, R367TER_ANACTRL, 0x0D);\n\t \n\tstv0367_writereg(state, R367TER_TOPCTRL, 0x10);\n\n\t \n\tstv0367_pll_setup(state, STV0367_ICSPEED_58000, state->config->xtal);\n\n\tmsleep(50);\n\t \n\tstv0367_writereg(state, R367TER_ANACTRL, 0x00);\n\n\tstate->cab_state->mclk = stv0367cab_get_mclk(&state->fe,\n\t\tstate->config->xtal);\n\tstate->cab_state->adc_clk = stv0367cab_get_adc_freq(&state->fe,\n\t\tstate->config->xtal);\n\n\tstate->activedemod = demod_cab;\n}\n\nstatic int stv0367ddb_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\n\tswitch (fe->dtv_property_cache.delivery_system) {\n\tcase SYS_DVBT:\n\t\tif (state->activedemod != demod_ter)\n\t\t\tstv0367ddb_setup_ter(state);\n\n\t\treturn stv0367ter_set_frontend(fe);\n\tcase SYS_DVBC_ANNEX_A:\n\t\tif (state->activedemod != demod_cab)\n\t\t\tstv0367ddb_setup_cab(state);\n\n\t\t \n\t\tif (fe->dtv_property_cache.symbol_rate == 0) {\n\t\t\tprintk(KERN_ERR \"Invalid symbol rate\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn stv0367cab_set_frontend(fe);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void stv0367ddb_read_signal_strength(struct dvb_frontend *fe)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\ts32 signalstrength;\n\n\tswitch (state->activedemod) {\n\tcase demod_cab:\n\t\tsignalstrength = stv0367cab_get_rf_lvl(state) * 1000;\n\t\tbreak;\n\tdefault:\n\t\tp->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn;\n\t}\n\n\tp->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\tp->strength.stat[0].uvalue = signalstrength;\n}\n\nstatic void stv0367ddb_read_snr(struct dvb_frontend *fe)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tint cab_pwr;\n\tu32 regval, tmpval, snrval = 0;\n\n\tswitch (state->activedemod) {\n\tcase demod_ter:\n\t\tsnrval = stv0367ter_snr_readreg(fe);\n\t\tbreak;\n\tcase demod_cab:\n\t\tcab_pwr = stv0367cab_snr_power(fe);\n\t\tregval = stv0367cab_snr_readreg(fe, 0);\n\n\t\t \n\t\tif (!regval) {\n\t\t\tsnrval = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\ttmpval = (cab_pwr * 320) / regval;\n\t\tsnrval = ((tmpval != 0) ? (intlog2(tmpval) / 5581) : 0);\n\t\tbreak;\n\tdefault:\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn;\n\t}\n\n\tp->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\tp->cnr.stat[0].uvalue = snrval;\n}\n\nstatic void stv0367ddb_read_ucblocks(struct dvb_frontend *fe)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 ucblocks = 0;\n\n\tswitch (state->activedemod) {\n\tcase demod_ter:\n\t\tstv0367ter_read_ucblocks(fe, &ucblocks);\n\t\tbreak;\n\tcase demod_cab:\n\t\tstv0367cab_read_ucblcks(fe, &ucblocks);\n\t\tbreak;\n\tdefault:\n\t\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn;\n\t}\n\n\tp->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\tp->block_error.stat[0].uvalue = ucblocks;\n}\n\nstatic int stv0367ddb_read_status(struct dvb_frontend *fe,\n\t\t\t\t  enum fe_status *status)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tint ret = 0;\n\n\tswitch (state->activedemod) {\n\tcase demod_ter:\n\t\tret = stv0367ter_read_status(fe, status);\n\t\tbreak;\n\tcase demod_cab:\n\t\tret = stv0367cab_read_status(fe, status);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\tstv0367ddb_read_signal_strength(fe);\n\n\t \n\tif (*status & FE_HAS_CARRIER)\n\t\tstv0367ddb_read_snr(fe);\n\telse\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\t \n\tif (*status & FE_HAS_LOCK)\n\t\tstv0367ddb_read_ucblocks(fe);\n\telse\n\t\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\treturn 0;\n}\n\nstatic int stv0367ddb_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t   struct dtv_frontend_properties *p)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\n\tswitch (state->activedemod) {\n\tcase demod_ter:\n\t\treturn stv0367ter_get_frontend(fe, p);\n\tcase demod_cab:\n\t\treturn stv0367cab_get_frontend(fe, p);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0367ddb_sleep(struct dvb_frontend *fe)\n{\n\tstruct stv0367_state *state = fe->demodulator_priv;\n\n\tswitch (state->activedemod) {\n\tcase demod_ter:\n\t\tstate->activedemod = demod_none;\n\t\treturn stv0367ter_sleep(fe);\n\tcase demod_cab:\n\t\tstate->activedemod = demod_none;\n\t\treturn stv0367cab_sleep(fe);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stv0367ddb_init(struct stv0367_state *state)\n{\n\tstruct stv0367ter_state *ter_state = state->ter_state;\n\tstruct dtv_frontend_properties *p = &state->fe.dtv_property_cache;\n\n\tstv0367_writereg(state, R367TER_TOPCTRL, 0x10);\n\n\tif (stv0367_deftabs[state->deftabs][STV0367_TAB_BASE])\n\t\tstv0367_write_table(state,\n\t\t\tstv0367_deftabs[state->deftabs][STV0367_TAB_BASE]);\n\n\tstv0367_write_table(state,\n\t\tstv0367_deftabs[state->deftabs][STV0367_TAB_CAB]);\n\n\tstv0367_writereg(state, R367TER_TOPCTRL, 0x00);\n\tstv0367_write_table(state,\n\t\tstv0367_deftabs[state->deftabs][STV0367_TAB_TER]);\n\n\tstv0367_writereg(state, R367TER_GAIN_SRC1, 0x2A);\n\tstv0367_writereg(state, R367TER_GAIN_SRC2, 0xD6);\n\tstv0367_writereg(state, R367TER_INC_DEROT1, 0x55);\n\tstv0367_writereg(state, R367TER_INC_DEROT2, 0x55);\n\tstv0367_writereg(state, R367TER_TRL_CTL, 0x14);\n\tstv0367_writereg(state, R367TER_TRL_NOMRATE1, 0xAE);\n\tstv0367_writereg(state, R367TER_TRL_NOMRATE2, 0x56);\n\tstv0367_writereg(state, R367TER_FEPATH_CFG, 0x0);\n\n\t \n\n\tstv0367_writereg(state, R367TER_TSCFGH, 0x70);\n\tstv0367_writereg(state, R367TER_TSCFGM, 0xC0);\n\tstv0367_writereg(state, R367TER_TSCFGL, 0x20);\n\tstv0367_writereg(state, R367TER_TSSPEED, 0x40);  \n\n\tstv0367_writereg(state, R367TER_TSCFGH, 0x71);\n\tstv0367_writereg(state, R367TER_TSCFGH, 0x70);\n\n\tstv0367_writereg(state, R367TER_TOPCTRL, 0x10);\n\n\t \n\tstv0367_writereg(state, R367TER_AGC12C, 0x01);  \n\n\tstv0367_writereg(state, R367TER_AGCCTRL1, 0x8A);\n\n\t \n\t \n\t \n\tstv0367_writereg(state, R367CAB_OUTFORMAT_0, 0x85);\n\n\t \n\tstv0367_writereg(state, R367TER_ANACTRL, 0x0D);\n\n\t \n\tstv0367_pll_setup(state, STV0367_ICSPEED_58000, state->config->xtal);\n\n\t \n\t \n\tstv0367_writereg(state, R367TER_ANADIGCTRL, 0x8b);\n\tstv0367_writereg(state, R367TER_DUAL_AD12, 0x04);  \n\n\t \n\tstv0367_writereg(state, R367CAB_FSM_SNR2_HTH, 0x23);\n\t \n\tstv0367_writereg(state, R367CAB_IQ_QAM, 0x01);\n\t \n\tstv0367_writereg(state, R367CAB_EQU_FFE_LEAKAGE, 0x83);\n\t \n\tstv0367_writereg(state, R367CAB_IQDEM_ADJ_EN, 0x05);\n\n\t \n\tstv0367_writereg(state, R367TER_ANACTRL, 0x00);\n\n\tstv0367_writereg(state, R367TER_I2CRPT, (0x08 | ((5 & 0x07) << 4)));\n\n\tter_state->pBER = 0;\n\tter_state->first_lock = 0;\n\tter_state->unlock_counter = 2;\n\n\tp->strength.len = 1;\n\tp->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->cnr.len = 1;\n\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->block_error.len = 1;\n\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops stv0367ddb_ops = {\n\t.delsys = { SYS_DVBC_ANNEX_A, SYS_DVBT },\n\t.info = {\n\t\t.name\t\t\t= \"ST STV0367 DDB DVB-C/T\",\n\t\t.frequency_min_hz\t=  47 * MHz,\n\t\t.frequency_max_hz\t= 865 * MHz,\n\t\t.frequency_stepsize_hz\t= 166667,\n\t\t.symbol_rate_min\t= 870000,\n\t\t.symbol_rate_max\t= 11700000,\n\t\t.caps =  \n\t\t\t0x400 | \n\t\t\tFE_CAN_QAM_16 | FE_CAN_QAM_32  |\n\t\t\tFE_CAN_QAM_64 | FE_CAN_QAM_128 |\n\t\t\tFE_CAN_QAM_256 |\n\t\t\t \n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_RECOVER | FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_MUTE_TS\n\t},\n\t.release = stv0367_release,\n\t.sleep = stv0367ddb_sleep,\n\t.i2c_gate_ctrl = stv0367cab_gate_ctrl,  \n\t.set_frontend = stv0367ddb_set_frontend,\n\t.get_frontend = stv0367ddb_get_frontend,\n\t.get_tune_settings = stv0367_get_tune_settings,\n\t.read_status = stv0367ddb_read_status,\n};\n\nstruct dvb_frontend *stv0367ddb_attach(const struct stv0367_config *config,\n\t\t\t\t   struct i2c_adapter *i2c)\n{\n\tstruct stv0367_state *state = NULL;\n\tstruct stv0367ter_state *ter_state = NULL;\n\tstruct stv0367cab_state *cab_state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct stv0367_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\tter_state = kzalloc(sizeof(struct stv0367ter_state), GFP_KERNEL);\n\tif (ter_state == NULL)\n\t\tgoto error;\n\tcab_state = kzalloc(sizeof(struct stv0367cab_state), GFP_KERNEL);\n\tif (cab_state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->i2c = i2c;\n\tstate->config = config;\n\tstate->ter_state = ter_state;\n\tcab_state->search_range = 280000;\n\tcab_state->qamfec_status_reg = F367CAB_DESCR_SYNCSTATE;\n\tstate->cab_state = cab_state;\n\tstate->fe.ops = stv0367ddb_ops;\n\tstate->fe.demodulator_priv = state;\n\tstate->chip_id = stv0367_readreg(state, R367TER_ID);\n\n\t \n\tstate->use_i2c_gatectrl = 0;\n\tstate->deftabs = STV0367_DEFTAB_DDB;\n\tstate->reinit_on_setfrontend = 0;\n\tstate->auto_if_khz = 1;\n\tstate->activedemod = demod_none;\n\n\tdprintk(\"%s: chip_id = 0x%x\\n\", __func__, state->chip_id);\n\n\t \n\tif ((state->chip_id != 0x50) && (state->chip_id != 0x60))\n\t\tgoto error;\n\n\tdev_info(&i2c->dev, \"Found %s with ChipID %02X at adr %02X\\n\",\n\t\tstate->fe.ops.info.name, state->chip_id,\n\t\tconfig->demod_address);\n\n\tstv0367ddb_init(state);\n\n\treturn &state->fe;\n\nerror:\n\tkfree(cab_state);\n\tkfree(ter_state);\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(stv0367ddb_attach);\n\nMODULE_PARM_DESC(debug, \"Set debug\");\nMODULE_PARM_DESC(i2c_debug, \"Set i2c debug\");\n\nMODULE_AUTHOR(\"Igor M. Liplianin\");\nMODULE_DESCRIPTION(\"ST STV0367 DVB-C/T demodulator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}