{
  "module_name": "mn88472.c",
  "hash_id": "7199ed1b11b0c9066ddfd1d4c5dcec2cd455c54307012670c4bbbcf8dc2b0b98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/mn88472.c",
  "human_readable_source": "\n \n\n#include \"mn88472_priv.h\"\n\nstatic int mn88472_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t     struct dvb_frontend_tune_settings *s)\n{\n\ts->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic int mn88472_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct mn88472_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i, stmp;\n\tunsigned int utmp, utmp1, utmp2;\n\tu8 buf[5];\n\n\tif (!dev->active) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tret = regmap_read(dev->regmap[0], 0x7f, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif ((utmp & 0x0f) >= 0x09)\n\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t  FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\t\telse\n\t\t\t*status = 0;\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tret = regmap_read(dev->regmap[2], 0x92, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif ((utmp & 0x0f) >= 0x0d)\n\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t  FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\t\telse if ((utmp & 0x0f) >= 0x0a)\n\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t  FE_HAS_VITERBI;\n\t\telse if ((utmp & 0x0f) >= 0x07)\n\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\t\telse\n\t\t\t*status = 0;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tret = regmap_read(dev->regmap[1], 0x84, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif ((utmp & 0x0f) >= 0x08)\n\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t  FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\t\telse\n\t\t\t*status = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif (*status & FE_HAS_SIGNAL) {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tret = regmap_bulk_read(dev->regmap[2], 0x8e + i,\n\t\t\t\t\t       &buf[i], 1);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tutmp1 = buf[0] << 8 | buf[1] << 0 | buf[0] >> 2;\n\t\tdev_dbg(&client->dev, \"strength=%u\\n\", utmp1);\n\n\t\tc->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\t\tc->strength.stat[0].uvalue = utmp1;\n\t} else {\n\t\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (*status & FE_HAS_VITERBI && c->delivery_system == SYS_DVBT) {\n\t\t \n\t\tret = regmap_bulk_read(dev->regmap[0], 0x9c, buf, 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp = buf[0] << 8 | buf[1] << 0;\n\t\tif (utmp) {\n\t\t\t \n\t\t\t \n\t\t\tstmp = ((u64)80807124 - intlog10(utmp) + 3355443)\n\t\t\t       * 10000 >> 24;\n\n\t\t\tdev_dbg(&client->dev, \"cnr=%d value=%u\\n\", stmp, utmp);\n\t\t} else {\n\t\t\tstmp = 0;\n\t\t}\n\n\t\tc->cnr.stat[0].svalue = stmp;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t} else if (*status & FE_HAS_VITERBI &&\n\t\t   c->delivery_system == SYS_DVBT2) {\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tret = regmap_bulk_read(dev->regmap[2], 0xbc + i,\n\t\t\t\t\t       &buf[i], 1);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tutmp = buf[1] << 8 | buf[2] << 0;\n\t\tutmp1 = (buf[0] >> 2) & 0x01;  \n\t\tif (utmp) {\n\t\t\tif (utmp1) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tstmp = ((u64)70706234 - intlog10(utmp)\n\t\t\t\t       - 10066330) * 10000 >> 24;\n\t\t\t\tdev_dbg(&client->dev, \"cnr=%d value=%u MISO\\n\",\n\t\t\t\t\tstmp, utmp);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tstmp = ((u64)80807124 - intlog10(utmp)\n\t\t\t\t       + 3355443) * 10000 >> 24;\n\n\t\t\t\tdev_dbg(&client->dev, \"cnr=%d value=%u SISO\\n\",\n\t\t\t\t\tstmp, utmp);\n\t\t\t}\n\t\t} else {\n\t\t\tstmp = 0;\n\t\t}\n\n\t\tc->cnr.stat[0].svalue = stmp;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t} else if (*status & FE_HAS_VITERBI &&\n\t\t   c->delivery_system == SYS_DVBC_ANNEX_A) {\n\t\t \n\t\tret = regmap_bulk_read(dev->regmap[1], 0xa1, buf, 4);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp1 = buf[0] << 8 | buf[1] << 0;  \n\t\tutmp2 = buf[2] << 8 | buf[3] << 0;  \n\t\tif (utmp1 && utmp2) {\n\t\t\t \n\t\t\t \n\t\t\tstmp = ((u64)15151336 + intlog10(utmp1)\n\t\t\t       - intlog10(utmp2)) * 10000 >> 24;\n\n\t\t\tdev_dbg(&client->dev, \"cnr=%d signal=%u noise=%u\\n\",\n\t\t\t\tstmp, utmp1, utmp2);\n\t\t} else {\n\t\t\tstmp = 0;\n\t\t}\n\n\t\tc->cnr.stat[0].svalue = stmp;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t} else {\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (*status & FE_HAS_SYNC) {\n\t\tret = regmap_bulk_read(dev->regmap[0], 0xe1, buf, 4);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp1 = buf[0] << 8 | buf[1] << 0;\n\t\tutmp2 = buf[2] << 8 | buf[3] << 0;\n\t\tdev_dbg(&client->dev, \"block_error=%u block_count=%u\\n\",\n\t\t\tutmp1, utmp2);\n\n\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_error.stat[0].uvalue += utmp1;\n\t\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_count.stat[0].uvalue += utmp2;\n\t} else {\n\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int mn88472_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct mn88472_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i;\n\tunsigned int utmp;\n\tu32 if_frequency;\n\tu8 buf[3], delivery_system_val, bandwidth_val, *bandwidth_vals_ptr;\n\tu8 reg_bank0_b4_val, reg_bank0_cd_val, reg_bank0_d4_val;\n\tu8 reg_bank0_d6_val;\n\n\tdev_dbg(&client->dev,\n\t\t\"delivery_system=%u modulation=%u frequency=%u bandwidth_hz=%u symbol_rate=%u inversion=%d stream_id=%d\\n\",\n\t\tc->delivery_system, c->modulation, c->frequency,\n\t\tc->bandwidth_hz, c->symbol_rate, c->inversion, c->stream_id);\n\n\tif (!dev->active) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tdelivery_system_val = 0x02;\n\t\treg_bank0_b4_val = 0x00;\n\t\treg_bank0_cd_val = 0x1f;\n\t\treg_bank0_d4_val = 0x0a;\n\t\treg_bank0_d6_val = 0x48;\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tdelivery_system_val = 0x03;\n\t\treg_bank0_b4_val = 0xf6;\n\t\treg_bank0_cd_val = 0x01;\n\t\treg_bank0_d4_val = 0x09;\n\t\treg_bank0_d6_val = 0x46;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tdelivery_system_val = 0x04;\n\t\treg_bank0_b4_val = 0x00;\n\t\treg_bank0_cd_val = 0x17;\n\t\treg_bank0_d4_val = 0x09;\n\t\treg_bank0_d6_val = 0x48;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tswitch (c->bandwidth_hz) {\n\t\tcase 5000000:\n\t\t\tbandwidth_vals_ptr = \"\\xe5\\x99\\x9a\\x1b\\xa9\\x1b\\xa9\";\n\t\t\tbandwidth_val = 0x03;\n\t\t\tbreak;\n\t\tcase 6000000:\n\t\t\tbandwidth_vals_ptr = \"\\xbf\\x55\\x55\\x15\\x6b\\x15\\x6b\";\n\t\t\tbandwidth_val = 0x02;\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\tbandwidth_vals_ptr = \"\\xa4\\x00\\x00\\x0f\\x2c\\x0f\\x2c\";\n\t\t\tbandwidth_val = 0x01;\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\t\tbandwidth_vals_ptr = \"\\x8f\\x80\\x00\\x08\\xee\\x08\\xee\";\n\t\t\tbandwidth_val = 0x00;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tbandwidth_vals_ptr = NULL;\n\t\tbandwidth_val = 0x00;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (fe->ops.tuner_ops.get_if_frequency) {\n\t\tret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdev_dbg(&client->dev, \"get_if_frequency=%d\\n\", if_frequency);\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = regmap_write(dev->regmap[2], 0x00, 0x66);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x01, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x02, 0x01);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x03, delivery_system_val);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x04, bandwidth_val);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tutmp = DIV_ROUND_CLOSEST_ULL((u64)if_frequency * 0x1000000, dev->clk);\n\tbuf[0] = (utmp >> 16) & 0xff;\n\tbuf[1] = (utmp >>  8) & 0xff;\n\tbuf[2] = (utmp >>  0) & 0xff;\n\tfor (i = 0; i < 3; i++) {\n\t\tret = regmap_write(dev->regmap[2], 0x10 + i, buf[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (bandwidth_vals_ptr) {\n\t\tfor (i = 0; i < 7; i++) {\n\t\t\tret = regmap_write(dev->regmap[2], 0x13 + i,\n\t\t\t\t\t   bandwidth_vals_ptr[i]);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = regmap_write(dev->regmap[0], 0xb4, reg_bank0_b4_val);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0xcd, reg_bank0_cd_val);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0xd4, reg_bank0_d4_val);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0xd6, reg_bank0_d6_val);\n\tif (ret)\n\t\tgoto err;\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tret = regmap_write(dev->regmap[0], 0x07, 0x26);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_write(dev->regmap[0], 0x00, 0xba);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_write(dev->regmap[0], 0x01, 0x13);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tret = regmap_write(dev->regmap[2], 0x2b, 0x13);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_write(dev->regmap[2], 0x4f, 0x05);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_write(dev->regmap[1], 0xf6, 0x05);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_write(dev->regmap[2], 0x32,\n\t\t\t\t(c->stream_id == NO_STREAM_ID_FILTER) ? 0 :\n\t\t\t\tc->stream_id );\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tret = regmap_write(dev->regmap[2], 0xf8, 0x9f);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int mn88472_init(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct mn88472_dev *dev = i2c_get_clientdata(client);\n\tint ret, len, rem;\n\tunsigned int utmp;\n\tconst struct firmware *firmware;\n\tconst char *name = MN88472_FIRMWARE;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tret = regmap_write(dev->regmap[2], 0x05, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x0b, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x0c, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_read(dev->regmap[0], 0xf5, &utmp);\n\tif (ret)\n\t\tgoto err;\n\tif (!(utmp & 0x01))\n\t\tgoto warm;\n\n\tret = request_firmware(&firmware, name, &client->dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"firmware file '%s' not found\\n\", name);\n\t\tgoto err;\n\t}\n\n\tdev_info(&client->dev, \"downloading firmware from file '%s'\\n\", name);\n\n\tret = regmap_write(dev->regmap[0], 0xf5, 0x03);\n\tif (ret)\n\t\tgoto err_release_firmware;\n\n\tfor (rem = firmware->size; rem > 0; rem -= (dev->i2c_write_max - 1)) {\n\t\tlen = min(dev->i2c_write_max - 1, rem);\n\t\tret = regmap_bulk_write(dev->regmap[0], 0xf6,\n\t\t\t\t\t&firmware->data[firmware->size - rem],\n\t\t\t\t\tlen);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"firmware download failed %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_release_firmware;\n\t\t}\n\t}\n\n\t \n\tret = regmap_read(dev->regmap[0], 0xf8, &utmp);\n\tif (ret)\n\t\tgoto err_release_firmware;\n\tif (utmp & 0x10) {\n\t\tret = -EINVAL;\n\t\tdev_err(&client->dev, \"firmware did not run\\n\");\n\t\tgoto err_release_firmware;\n\t}\n\n\tret = regmap_write(dev->regmap[0], 0xf5, 0x00);\n\tif (ret)\n\t\tgoto err_release_firmware;\n\n\trelease_firmware(firmware);\nwarm:\n\t \n\tswitch (dev->ts_mode) {\n\tcase SERIAL_TS_MODE:\n\t\tutmp = 0x1d;\n\t\tbreak;\n\tcase PARALLEL_TS_MODE:\n\t\tutmp = 0x00;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tret = regmap_write(dev->regmap[2], 0x08, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tswitch (dev->ts_clk) {\n\tcase VARIABLE_TS_CLOCK:\n\t\tutmp = 0xe3;\n\t\tbreak;\n\tcase FIXED_TS_CLOCK:\n\t\tutmp = 0xe1;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tret = regmap_write(dev->regmap[0], 0xd9, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->active = true;\n\n\treturn 0;\nerr_release_firmware:\n\trelease_firmware(firmware);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int mn88472_sleep(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct mn88472_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tret = regmap_write(dev->regmap[2], 0x0c, 0x30);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x0b, 0x30);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x05, 0x3e);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dvb_frontend_ops mn88472_ops = {\n\t.delsys = {SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A},\n\t.info = {\n\t\t.name = \"Panasonic MN88472\",\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 7200000,\n\t\t.caps =\tFE_CAN_FEC_1_2                 |\n\t\t\tFE_CAN_FEC_2_3                 |\n\t\t\tFE_CAN_FEC_3_4                 |\n\t\t\tFE_CAN_FEC_5_6                 |\n\t\t\tFE_CAN_FEC_7_8                 |\n\t\t\tFE_CAN_FEC_AUTO                |\n\t\t\tFE_CAN_QPSK                    |\n\t\t\tFE_CAN_QAM_16                  |\n\t\t\tFE_CAN_QAM_32                  |\n\t\t\tFE_CAN_QAM_64                  |\n\t\t\tFE_CAN_QAM_128                 |\n\t\t\tFE_CAN_QAM_256                 |\n\t\t\tFE_CAN_QAM_AUTO                |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO  |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO     |\n\t\t\tFE_CAN_HIERARCHY_AUTO          |\n\t\t\tFE_CAN_MUTE_TS                 |\n\t\t\tFE_CAN_2G_MODULATION           |\n\t\t\tFE_CAN_MULTISTREAM\n\t},\n\n\t.get_tune_settings = mn88472_get_tune_settings,\n\n\t.init = mn88472_init,\n\t.sleep = mn88472_sleep,\n\n\t.set_frontend = mn88472_set_frontend,\n\n\t.read_status = mn88472_read_status,\n};\n\nstatic struct dvb_frontend *mn88472_get_dvb_frontend(struct i2c_client *client)\n{\n\tstruct mn88472_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\treturn &dev->fe;\n}\n\nstatic int mn88472_probe(struct i2c_client *client)\n{\n\tstruct mn88472_config *pdata = client->dev.platform_data;\n\tstruct mn88472_dev *dev;\n\tstruct dtv_frontend_properties *c;\n\tint ret;\n\tunsigned int utmp;\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t};\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev->i2c_write_max = pdata->i2c_wr_max ? pdata->i2c_wr_max : ~0;\n\tdev->clk = pdata->xtal;\n\tdev->ts_mode = pdata->ts_mode;\n\tdev->ts_clk = pdata->ts_clock;\n\tdev->client[0] = client;\n\tdev->regmap[0] = regmap_init_i2c(dev->client[0], &regmap_config);\n\tif (IS_ERR(dev->regmap[0])) {\n\t\tret = PTR_ERR(dev->regmap[0]);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tdev->client[1] = i2c_new_dummy_device(client->adapter, 0x1a);\n\tif (IS_ERR(dev->client[1])) {\n\t\tret = PTR_ERR(dev->client[1]);\n\t\tdev_err(&client->dev, \"I2C registration failed\\n\");\n\t\tgoto err_regmap_0_regmap_exit;\n\t}\n\tdev->regmap[1] = regmap_init_i2c(dev->client[1], &regmap_config);\n\tif (IS_ERR(dev->regmap[1])) {\n\t\tret = PTR_ERR(dev->regmap[1]);\n\t\tgoto err_client_1_i2c_unregister_device;\n\t}\n\ti2c_set_clientdata(dev->client[1], dev);\n\n\tdev->client[2] = i2c_new_dummy_device(client->adapter, 0x1c);\n\tif (IS_ERR(dev->client[2])) {\n\t\tret = PTR_ERR(dev->client[2]);\n\t\tdev_err(&client->dev, \"2nd I2C registration failed\\n\");\n\t\tgoto err_regmap_1_regmap_exit;\n\t}\n\tdev->regmap[2] = regmap_init_i2c(dev->client[2], &regmap_config);\n\tif (IS_ERR(dev->regmap[2])) {\n\t\tret = PTR_ERR(dev->regmap[2]);\n\t\tgoto err_client_2_i2c_unregister_device;\n\t}\n\ti2c_set_clientdata(dev->client[2], dev);\n\n\t \n\tret = regmap_read(dev->regmap[2], 0xff, &utmp);\n\tif (ret)\n\t\tgoto err_regmap_2_regmap_exit;\n\n\tdev_dbg(&client->dev, \"chip id=%02x\\n\", utmp);\n\n\tif (utmp != 0x02) {\n\t\tret = -ENODEV;\n\t\tgoto err_regmap_2_regmap_exit;\n\t}\n\n\t \n\tret = regmap_write(dev->regmap[2], 0x05, 0x3e);\n\tif (ret)\n\t\tgoto err_regmap_2_regmap_exit;\n\n\t \n\tmemcpy(&dev->fe.ops, &mn88472_ops, sizeof(struct dvb_frontend_ops));\n\tdev->fe.demodulator_priv = client;\n\t*pdata->fe = &dev->fe;\n\ti2c_set_clientdata(client, dev);\n\n\t \n\tc = &dev->fe.dtv_property_cache;\n\tc->strength.len = 1;\n\tc->cnr.len = 1;\n\tc->block_error.len = 1;\n\tc->block_count.len = 1;\n\n\t \n\tpdata->get_dvb_frontend = mn88472_get_dvb_frontend;\n\n\tdev_info(&client->dev, \"Panasonic MN88472 successfully identified\\n\");\n\n\treturn 0;\nerr_regmap_2_regmap_exit:\n\tregmap_exit(dev->regmap[2]);\nerr_client_2_i2c_unregister_device:\n\ti2c_unregister_device(dev->client[2]);\nerr_regmap_1_regmap_exit:\n\tregmap_exit(dev->regmap[1]);\nerr_client_1_i2c_unregister_device:\n\ti2c_unregister_device(dev->client[1]);\nerr_regmap_0_regmap_exit:\n\tregmap_exit(dev->regmap[0]);\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void mn88472_remove(struct i2c_client *client)\n{\n\tstruct mn88472_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tregmap_exit(dev->regmap[2]);\n\ti2c_unregister_device(dev->client[2]);\n\n\tregmap_exit(dev->regmap[1]);\n\ti2c_unregister_device(dev->client[1]);\n\n\tregmap_exit(dev->regmap[0]);\n\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id mn88472_id_table[] = {\n\t{\"mn88472\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, mn88472_id_table);\n\nstatic struct i2c_driver mn88472_driver = {\n\t.driver = {\n\t\t.name = \"mn88472\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe    = mn88472_probe,\n\t.remove   = mn88472_remove,\n\t.id_table = mn88472_id_table,\n};\n\nmodule_i2c_driver(mn88472_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Panasonic MN88472 DVB-T/T2/C demodulator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(MN88472_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}