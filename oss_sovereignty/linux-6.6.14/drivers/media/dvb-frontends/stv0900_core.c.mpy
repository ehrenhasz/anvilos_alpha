{
  "module_name": "stv0900_core.c",
  "hash_id": "560602981af8fbd50912fb219fd654f4794460ab1e24d2de92f3b57498acd0b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stv0900_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n\n#include \"stv0900.h\"\n#include \"stv0900_reg.h\"\n#include \"stv0900_priv.h\"\n#include \"stv0900_init.h\"\n\nint stvdebug = 1;\nmodule_param_named(debug, stvdebug, int, 0644);\n\n \nstruct stv0900_inode {\n\t \n\tstruct stv0900_internal\t\t*internal;\n\tstruct stv0900_inode\t\t*next_inode;\n};\n\n \nstatic struct stv0900_inode *stv0900_first_inode;\n\n \nstatic struct stv0900_inode *find_inode(struct i2c_adapter *i2c_adap,\n\t\t\t\t\t\t\tu8 i2c_addr)\n{\n\tstruct stv0900_inode *temp_chip = stv0900_first_inode;\n\n\tif (temp_chip != NULL) {\n\t\t \n\t\twhile ((temp_chip != NULL) &&\n\t\t\t((temp_chip->internal->i2c_adap != i2c_adap) ||\n\t\t\t(temp_chip->internal->i2c_addr != i2c_addr)))\n\n\t\t\ttemp_chip = temp_chip->next_inode;\n\n\t}\n\n\treturn temp_chip;\n}\n\n \nstatic void remove_inode(struct stv0900_internal *internal)\n{\n\tstruct stv0900_inode *prev_node = stv0900_first_inode;\n\tstruct stv0900_inode *del_node = find_inode(internal->i2c_adap,\n\t\t\t\t\t\tinternal->i2c_addr);\n\n\tif (del_node != NULL) {\n\t\tif (del_node == stv0900_first_inode) {\n\t\t\tstv0900_first_inode = del_node->next_inode;\n\t\t} else {\n\t\t\twhile (prev_node->next_inode != del_node)\n\t\t\t\tprev_node = prev_node->next_inode;\n\n\t\t\tif (del_node->next_inode == NULL)\n\t\t\t\tprev_node->next_inode = NULL;\n\t\t\telse\n\t\t\t\tprev_node->next_inode =\n\t\t\t\t\tprev_node->next_inode->next_inode;\n\t\t}\n\n\t\tkfree(del_node);\n\t}\n}\n\n \nstatic struct stv0900_inode *append_internal(struct stv0900_internal *internal)\n{\n\tstruct stv0900_inode *new_node = stv0900_first_inode;\n\n\tif (new_node == NULL) {\n\t\tnew_node = kmalloc(sizeof(struct stv0900_inode), GFP_KERNEL);\n\t\tstv0900_first_inode = new_node;\n\t} else {\n\t\twhile (new_node->next_inode != NULL)\n\t\t\tnew_node = new_node->next_inode;\n\n\t\tnew_node->next_inode = kmalloc(sizeof(struct stv0900_inode),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (new_node->next_inode != NULL)\n\t\t\tnew_node = new_node->next_inode;\n\t\telse\n\t\t\tnew_node = NULL;\n\t}\n\n\tif (new_node != NULL) {\n\t\tnew_node->internal = internal;\n\t\tnew_node->next_inode = NULL;\n\t}\n\n\treturn new_node;\n}\n\ns32 ge2comp(s32 a, s32 width)\n{\n\tif (width == 32)\n\t\treturn a;\n\telse\n\t\treturn (a >= (1 << (width - 1))) ? (a - (1 << width)) : a;\n}\n\nvoid stv0900_write_reg(struct stv0900_internal *intp, u16 reg_addr,\n\t\t\t\t\t\t\t\tu8 reg_data)\n{\n\tu8 data[3];\n\tint ret;\n\tstruct i2c_msg i2cmsg = {\n\t\t.addr  = intp->i2c_addr,\n\t\t.flags = 0,\n\t\t.len   = 3,\n\t\t.buf   = data,\n\t};\n\n\tdata[0] = MSB(reg_addr);\n\tdata[1] = LSB(reg_addr);\n\tdata[2] = reg_data;\n\n\tret = i2c_transfer(intp->i2c_adap, &i2cmsg, 1);\n\tif (ret != 1)\n\t\tdprintk(\"%s: i2c error %d\\n\", __func__, ret);\n}\n\nu8 stv0900_read_reg(struct stv0900_internal *intp, u16 reg)\n{\n\tint ret;\n\tu8 b0[] = { MSB(reg), LSB(reg) };\n\tu8 buf = 0;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= intp->i2c_addr,\n\t\t\t.flags\t= 0,\n\t\t\t.buf = b0,\n\t\t\t.len = 2,\n\t\t}, {\n\t\t\t.addr\t= intp->i2c_addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.buf = &buf,\n\t\t\t.len = 1,\n\t\t},\n\t};\n\n\tret = i2c_transfer(intp->i2c_adap, msg, 2);\n\tif (ret != 2)\n\t\tdprintk(\"%s: i2c error %d, reg[0x%02x]\\n\",\n\t\t\t\t__func__, ret, reg);\n\n\treturn buf;\n}\n\nstatic void extract_mask_pos(u32 label, u8 *mask, u8 *pos)\n{\n\tu8 position = 0, i = 0;\n\n\t(*mask) = label & 0xff;\n\n\twhile ((position == 0) && (i < 8)) {\n\t\tposition = ((*mask) >> i) & 0x01;\n\t\ti++;\n\t}\n\n\t(*pos) = (i - 1);\n}\n\nvoid stv0900_write_bits(struct stv0900_internal *intp, u32 label, u8 val)\n{\n\tu8 reg, mask, pos;\n\n\treg = stv0900_read_reg(intp, (label >> 16) & 0xffff);\n\textract_mask_pos(label, &mask, &pos);\n\n\tval = mask & (val << pos);\n\n\treg = (reg & (~mask)) | val;\n\tstv0900_write_reg(intp, (label >> 16) & 0xffff, reg);\n\n}\n\nu8 stv0900_get_bits(struct stv0900_internal *intp, u32 label)\n{\n\tu8 val;\n\tu8 mask, pos;\n\n\textract_mask_pos(label, &mask, &pos);\n\n\tval = stv0900_read_reg(intp, label >> 16);\n\tval = (val & mask) >> pos;\n\n\treturn val;\n}\n\nstatic enum fe_stv0900_error stv0900_initialize(struct stv0900_internal *intp)\n{\n\ts32 i;\n\n\tif (intp == NULL)\n\t\treturn STV0900_INVALID_HANDLE;\n\n\tintp->chip_id = stv0900_read_reg(intp, R0900_MID);\n\n\tif (intp->errs != STV0900_NO_ERROR)\n\t\treturn intp->errs;\n\n\t \n\tstv0900_write_reg(intp, R0900_P1_DMDISTATE, 0x5c);\n\tstv0900_write_reg(intp, R0900_P2_DMDISTATE, 0x5c);\n\tmsleep(3);\n\tstv0900_write_reg(intp, R0900_P1_TNRCFG, 0x6c);\n\tstv0900_write_reg(intp, R0900_P2_TNRCFG, 0x6f);\n\tstv0900_write_reg(intp, R0900_P1_I2CRPT, 0x20);\n\tstv0900_write_reg(intp, R0900_P2_I2CRPT, 0x20);\n\tstv0900_write_reg(intp, R0900_NCOARSE, 0x13);\n\tmsleep(3);\n\tstv0900_write_reg(intp, R0900_I2CCFG, 0x08);\n\n\tswitch (intp->clkmode) {\n\tcase 0:\n\tcase 2:\n\t\tstv0900_write_reg(intp, R0900_SYNTCTRL, 0x20\n\t\t\t\t| intp->clkmode);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\ti = 0x02 & stv0900_read_reg(intp, R0900_SYNTCTRL);\n\t\tstv0900_write_reg(intp, R0900_SYNTCTRL, 0x20 | i);\n\t\tbreak;\n\t}\n\n\tmsleep(3);\n\tfor (i = 0; i < 181; i++)\n\t\tstv0900_write_reg(intp, STV0900_InitVal[i][0],\n\t\t\t\tSTV0900_InitVal[i][1]);\n\n\tif (stv0900_read_reg(intp, R0900_MID) >= 0x20) {\n\t\tstv0900_write_reg(intp, R0900_TSGENERAL, 0x0c);\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tstv0900_write_reg(intp, STV0900_Cut20_AddOnVal[i][0],\n\t\t\t\t\tSTV0900_Cut20_AddOnVal[i][1]);\n\t}\n\n\tstv0900_write_reg(intp, R0900_P1_FSPYCFG, 0x6c);\n\tstv0900_write_reg(intp, R0900_P2_FSPYCFG, 0x6c);\n\n\tstv0900_write_reg(intp, R0900_P1_PDELCTRL2, 0x01);\n\tstv0900_write_reg(intp, R0900_P2_PDELCTRL2, 0x21);\n\n\tstv0900_write_reg(intp, R0900_P1_PDELCTRL3, 0x20);\n\tstv0900_write_reg(intp, R0900_P2_PDELCTRL3, 0x20);\n\n\tstv0900_write_reg(intp, R0900_TSTRES0, 0x80);\n\tstv0900_write_reg(intp, R0900_TSTRES0, 0x00);\n\n\treturn STV0900_NO_ERROR;\n}\n\nstatic u32 stv0900_get_mclk_freq(struct stv0900_internal *intp, u32 ext_clk)\n{\n\tu32 mclk, div, ad_div;\n\n\tdiv = stv0900_get_bits(intp, F0900_M_DIV);\n\tad_div = ((stv0900_get_bits(intp, F0900_SELX1RATIO) == 1) ? 4 : 6);\n\n\tmclk = (div + 1) * ext_clk / ad_div;\n\n\tdprintk(\"%s: Calculated Mclk = %d\\n\", __func__, mclk);\n\n\treturn mclk;\n}\n\nstatic enum fe_stv0900_error stv0900_set_mclk(struct stv0900_internal *intp, u32 mclk)\n{\n\tu32 m_div, clk_sel;\n\n\tif (intp == NULL)\n\t\treturn STV0900_INVALID_HANDLE;\n\n\tif (intp->errs)\n\t\treturn STV0900_I2C_ERROR;\n\n\tdprintk(\"%s: Mclk set to %d, Quartz = %d\\n\", __func__, mclk,\n\t\t\tintp->quartz);\n\n\tclk_sel = ((stv0900_get_bits(intp, F0900_SELX1RATIO) == 1) ? 4 : 6);\n\tm_div = ((clk_sel * mclk) / intp->quartz) - 1;\n\tstv0900_write_bits(intp, F0900_M_DIV, m_div);\n\tintp->mclk = stv0900_get_mclk_freq(intp,\n\t\t\t\t\tintp->quartz);\n\n\t \n\t \n\tm_div = intp->mclk / 704000;\n\tstv0900_write_reg(intp, R0900_P1_F22TX, m_div);\n\tstv0900_write_reg(intp, R0900_P1_F22RX, m_div);\n\n\tstv0900_write_reg(intp, R0900_P2_F22TX, m_div);\n\tstv0900_write_reg(intp, R0900_P2_F22RX, m_div);\n\n\tif ((intp->errs))\n\t\treturn STV0900_I2C_ERROR;\n\n\treturn STV0900_NO_ERROR;\n}\n\nstatic u32 stv0900_get_err_count(struct stv0900_internal *intp, int cntr,\n\t\t\t\t\tenum fe_stv0900_demod_num demod)\n{\n\tu32 lsb, msb, hsb, err_val;\n\n\tswitch (cntr) {\n\tcase 0:\n\tdefault:\n\t\thsb = stv0900_get_bits(intp, ERR_CNT12);\n\t\tmsb = stv0900_get_bits(intp, ERR_CNT11);\n\t\tlsb = stv0900_get_bits(intp, ERR_CNT10);\n\t\tbreak;\n\tcase 1:\n\t\thsb = stv0900_get_bits(intp, ERR_CNT22);\n\t\tmsb = stv0900_get_bits(intp, ERR_CNT21);\n\t\tlsb = stv0900_get_bits(intp, ERR_CNT20);\n\t\tbreak;\n\t}\n\n\terr_val = (hsb << 16) + (msb << 8) + (lsb);\n\n\treturn err_val;\n}\n\nstatic int stv0900_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tstruct stv0900_internal *intp = state->internal;\n\tenum fe_stv0900_demod_num demod = state->demod;\n\n\tstv0900_write_bits(intp, I2CT_ON, enable);\n\n\treturn 0;\n}\n\nstatic void stv0900_set_ts_parallel_serial(struct stv0900_internal *intp,\n\t\t\t\t\tenum fe_stv0900_clock_type path1_ts,\n\t\t\t\t\tenum fe_stv0900_clock_type path2_ts)\n{\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (intp->chip_id >= 0x20) {\n\t\tswitch (path1_ts) {\n\t\tcase STV0900_PARALLEL_PUNCT_CLOCK:\n\t\tcase STV0900_DVBCI_CLOCK:\n\t\t\tswitch (path2_ts) {\n\t\t\tcase STV0900_SERIAL_PUNCT_CLOCK:\n\t\t\tcase STV0900_SERIAL_CONT_CLOCK:\n\t\t\tdefault:\n\t\t\t\tstv0900_write_reg(intp, R0900_TSGENERAL,\n\t\t\t\t\t\t\t0x00);\n\t\t\t\tbreak;\n\t\t\tcase STV0900_PARALLEL_PUNCT_CLOCK:\n\t\t\tcase STV0900_DVBCI_CLOCK:\n\t\t\t\tstv0900_write_reg(intp, R0900_TSGENERAL,\n\t\t\t\t\t\t\t0x06);\n\t\t\t\tstv0900_write_bits(intp,\n\t\t\t\t\t\tF0900_P1_TSFIFO_MANSPEED, 3);\n\t\t\t\tstv0900_write_bits(intp,\n\t\t\t\t\t\tF0900_P2_TSFIFO_MANSPEED, 0);\n\t\t\t\tstv0900_write_reg(intp,\n\t\t\t\t\t\tR0900_P1_TSSPEED, 0x14);\n\t\t\t\tstv0900_write_reg(intp,\n\t\t\t\t\t\tR0900_P2_TSSPEED, 0x28);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STV0900_SERIAL_PUNCT_CLOCK:\n\t\tcase STV0900_SERIAL_CONT_CLOCK:\n\t\tdefault:\n\t\t\tswitch (path2_ts) {\n\t\t\tcase STV0900_SERIAL_PUNCT_CLOCK:\n\t\t\tcase STV0900_SERIAL_CONT_CLOCK:\n\t\t\tdefault:\n\t\t\t\tstv0900_write_reg(intp,\n\t\t\t\t\t\tR0900_TSGENERAL, 0x0C);\n\t\t\t\tbreak;\n\t\t\tcase STV0900_PARALLEL_PUNCT_CLOCK:\n\t\t\tcase STV0900_DVBCI_CLOCK:\n\t\t\t\tstv0900_write_reg(intp,\n\t\t\t\t\t\tR0900_TSGENERAL, 0x0A);\n\t\t\t\tdprintk(\"%s: 0x0a\\n\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (path1_ts) {\n\t\tcase STV0900_PARALLEL_PUNCT_CLOCK:\n\t\tcase STV0900_DVBCI_CLOCK:\n\t\t\tswitch (path2_ts) {\n\t\t\tcase STV0900_SERIAL_PUNCT_CLOCK:\n\t\t\tcase STV0900_SERIAL_CONT_CLOCK:\n\t\t\tdefault:\n\t\t\t\tstv0900_write_reg(intp, R0900_TSGENERAL1X,\n\t\t\t\t\t\t\t0x10);\n\t\t\t\tbreak;\n\t\t\tcase STV0900_PARALLEL_PUNCT_CLOCK:\n\t\t\tcase STV0900_DVBCI_CLOCK:\n\t\t\t\tstv0900_write_reg(intp, R0900_TSGENERAL1X,\n\t\t\t\t\t\t\t0x16);\n\t\t\t\tstv0900_write_bits(intp,\n\t\t\t\t\t\tF0900_P1_TSFIFO_MANSPEED, 3);\n\t\t\t\tstv0900_write_bits(intp,\n\t\t\t\t\t\tF0900_P2_TSFIFO_MANSPEED, 0);\n\t\t\t\tstv0900_write_reg(intp, R0900_P1_TSSPEED,\n\t\t\t\t\t\t\t0x14);\n\t\t\t\tstv0900_write_reg(intp, R0900_P2_TSSPEED,\n\t\t\t\t\t\t\t0x28);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase STV0900_SERIAL_PUNCT_CLOCK:\n\t\tcase STV0900_SERIAL_CONT_CLOCK:\n\t\tdefault:\n\t\t\tswitch (path2_ts) {\n\t\t\tcase STV0900_SERIAL_PUNCT_CLOCK:\n\t\t\tcase STV0900_SERIAL_CONT_CLOCK:\n\t\t\tdefault:\n\t\t\t\tstv0900_write_reg(intp, R0900_TSGENERAL1X,\n\t\t\t\t\t\t\t0x14);\n\t\t\t\tbreak;\n\t\t\tcase STV0900_PARALLEL_PUNCT_CLOCK:\n\t\t\tcase STV0900_DVBCI_CLOCK:\n\t\t\t\tstv0900_write_reg(intp, R0900_TSGENERAL1X,\n\t\t\t\t\t\t\t0x12);\n\t\t\t\tdprintk(\"%s: 0x12\\n\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (path1_ts) {\n\tcase STV0900_PARALLEL_PUNCT_CLOCK:\n\t\tstv0900_write_bits(intp, F0900_P1_TSFIFO_SERIAL, 0x00);\n\t\tstv0900_write_bits(intp, F0900_P1_TSFIFO_DVBCI, 0x00);\n\t\tbreak;\n\tcase STV0900_DVBCI_CLOCK:\n\t\tstv0900_write_bits(intp, F0900_P1_TSFIFO_SERIAL, 0x00);\n\t\tstv0900_write_bits(intp, F0900_P1_TSFIFO_DVBCI, 0x01);\n\t\tbreak;\n\tcase STV0900_SERIAL_PUNCT_CLOCK:\n\t\tstv0900_write_bits(intp, F0900_P1_TSFIFO_SERIAL, 0x01);\n\t\tstv0900_write_bits(intp, F0900_P1_TSFIFO_DVBCI, 0x00);\n\t\tbreak;\n\tcase STV0900_SERIAL_CONT_CLOCK:\n\t\tstv0900_write_bits(intp, F0900_P1_TSFIFO_SERIAL, 0x01);\n\t\tstv0900_write_bits(intp, F0900_P1_TSFIFO_DVBCI, 0x01);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (path2_ts) {\n\tcase STV0900_PARALLEL_PUNCT_CLOCK:\n\t\tstv0900_write_bits(intp, F0900_P2_TSFIFO_SERIAL, 0x00);\n\t\tstv0900_write_bits(intp, F0900_P2_TSFIFO_DVBCI, 0x00);\n\t\tbreak;\n\tcase STV0900_DVBCI_CLOCK:\n\t\tstv0900_write_bits(intp, F0900_P2_TSFIFO_SERIAL, 0x00);\n\t\tstv0900_write_bits(intp, F0900_P2_TSFIFO_DVBCI, 0x01);\n\t\tbreak;\n\tcase STV0900_SERIAL_PUNCT_CLOCK:\n\t\tstv0900_write_bits(intp, F0900_P2_TSFIFO_SERIAL, 0x01);\n\t\tstv0900_write_bits(intp, F0900_P2_TSFIFO_DVBCI, 0x00);\n\t\tbreak;\n\tcase STV0900_SERIAL_CONT_CLOCK:\n\t\tstv0900_write_bits(intp, F0900_P2_TSFIFO_SERIAL, 0x01);\n\t\tstv0900_write_bits(intp, F0900_P2_TSFIFO_DVBCI, 0x01);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tstv0900_write_bits(intp, F0900_P2_RST_HWARE, 1);\n\tstv0900_write_bits(intp, F0900_P2_RST_HWARE, 0);\n\tstv0900_write_bits(intp, F0900_P1_RST_HWARE, 1);\n\tstv0900_write_bits(intp, F0900_P1_RST_HWARE, 0);\n}\n\nvoid stv0900_set_tuner(struct dvb_frontend *fe, u32 frequency,\n\t\t\t\t\t\t\tu32 bandwidth)\n{\n\tstruct dvb_frontend_ops *frontend_ops = NULL;\n\tstruct dvb_tuner_ops *tuner_ops = NULL;\n\n\tfrontend_ops = &fe->ops;\n\ttuner_ops = &frontend_ops->tuner_ops;\n\n\tif (tuner_ops->set_frequency) {\n\t\tif ((tuner_ops->set_frequency(fe, frequency)) < 0)\n\t\t\tdprintk(\"%s: Invalid parameter\\n\", __func__);\n\t\telse\n\t\t\tdprintk(\"%s: Frequency=%d\\n\", __func__, frequency);\n\n\t}\n\n\tif (tuner_ops->set_bandwidth) {\n\t\tif ((tuner_ops->set_bandwidth(fe, bandwidth)) < 0)\n\t\t\tdprintk(\"%s: Invalid parameter\\n\", __func__);\n\t\telse\n\t\t\tdprintk(\"%s: Bandwidth=%d\\n\", __func__, bandwidth);\n\n\t}\n}\n\nvoid stv0900_set_bandwidth(struct dvb_frontend *fe, u32 bandwidth)\n{\n\tstruct dvb_frontend_ops *frontend_ops = NULL;\n\tstruct dvb_tuner_ops *tuner_ops = NULL;\n\n\tfrontend_ops = &fe->ops;\n\ttuner_ops = &frontend_ops->tuner_ops;\n\n\tif (tuner_ops->set_bandwidth) {\n\t\tif ((tuner_ops->set_bandwidth(fe, bandwidth)) < 0)\n\t\t\tdprintk(\"%s: Invalid parameter\\n\", __func__);\n\t\telse\n\t\t\tdprintk(\"%s: Bandwidth=%d\\n\", __func__, bandwidth);\n\n\t}\n}\n\nu32 stv0900_get_freq_auto(struct stv0900_internal *intp, int demod)\n{\n\tu32 freq, round;\n\t \n\tfreq = (stv0900_get_bits(intp, TUN_RFFREQ2) << 10) +\n\t\t(stv0900_get_bits(intp, TUN_RFFREQ1) << 2) +\n\t\tstv0900_get_bits(intp, TUN_RFFREQ0);\n\n\tfreq = (freq * 1000) / 64;\n\n\tround = (stv0900_get_bits(intp, TUN_RFRESTE1) >> 2) +\n\t\tstv0900_get_bits(intp, TUN_RFRESTE0);\n\n\tround = (round * 1000) / 2048;\n\n\treturn freq + round;\n}\n\nvoid stv0900_set_tuner_auto(struct stv0900_internal *intp, u32 Frequency,\n\t\t\t\t\t\tu32 Bandwidth, int demod)\n{\n\tu32 tunerFrequency;\n\t \n\ttunerFrequency = (Frequency * 64) / 1000;\n\n\tstv0900_write_bits(intp, TUN_RFFREQ2, (tunerFrequency >> 10));\n\tstv0900_write_bits(intp, TUN_RFFREQ1, (tunerFrequency >> 2) & 0xff);\n\tstv0900_write_bits(intp, TUN_RFFREQ0, (tunerFrequency & 0x03));\n\t \n\tstv0900_write_bits(intp, TUN_BW, Bandwidth / 2000000);\n\t \n\tstv0900_write_reg(intp, TNRLD, 1);\n}\n\nstatic s32 stv0900_get_rf_level(struct stv0900_internal *intp,\n\t\t\t\tconst struct stv0900_table *lookup,\n\t\t\t\tenum fe_stv0900_demod_num demod)\n{\n\ts32 agc_gain = 0,\n\t\timin,\n\t\timax,\n\t\ti,\n\t\trf_lvl = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif ((lookup == NULL) || (lookup->size <= 0))\n\t\treturn 0;\n\n\tagc_gain = MAKEWORD(stv0900_get_bits(intp, AGCIQ_VALUE1),\n\t\t\t\tstv0900_get_bits(intp, AGCIQ_VALUE0));\n\n\timin = 0;\n\timax = lookup->size - 1;\n\tif (INRANGE(lookup->table[imin].regval, agc_gain,\n\t\t\t\t\tlookup->table[imax].regval)) {\n\t\twhile ((imax - imin) > 1) {\n\t\t\ti = (imax + imin) >> 1;\n\n\t\t\tif (INRANGE(lookup->table[imin].regval,\n\t\t\t\t\tagc_gain,\n\t\t\t\t\tlookup->table[i].regval))\n\t\t\t\timax = i;\n\t\t\telse\n\t\t\t\timin = i;\n\t\t}\n\n\t\trf_lvl = (s32)agc_gain - lookup->table[imin].regval;\n\t\trf_lvl *= (lookup->table[imax].realval -\n\t\t\t\tlookup->table[imin].realval);\n\t\trf_lvl /= (lookup->table[imax].regval -\n\t\t\t\tlookup->table[imin].regval);\n\t\trf_lvl += lookup->table[imin].realval;\n\t} else if (agc_gain > lookup->table[0].regval)\n\t\trf_lvl = 5;\n\telse if (agc_gain < lookup->table[lookup->size-1].regval)\n\t\trf_lvl = -100;\n\n\tdprintk(\"%s: RFLevel = %d\\n\", __func__, rf_lvl);\n\n\treturn rf_lvl;\n}\n\nstatic int stv0900_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tstruct stv0900_internal *internal = state->internal;\n\ts32 rflevel = stv0900_get_rf_level(internal, &stv0900_rf,\n\t\t\t\t\t\t\t\tstate->demod);\n\n\trflevel = (rflevel + 100) * (65535 / 70);\n\tif (rflevel < 0)\n\t\trflevel = 0;\n\n\tif (rflevel > 65535)\n\t\trflevel = 65535;\n\n\t*strength = rflevel;\n\n\treturn 0;\n}\n\nstatic s32 stv0900_carr_get_quality(struct dvb_frontend *fe,\n\t\t\t\t\tconst struct stv0900_table *lookup)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tstruct stv0900_internal *intp = state->internal;\n\tenum fe_stv0900_demod_num demod = state->demod;\n\n\ts32\tc_n = -100,\n\t\tregval,\n\t\timin,\n\t\timax,\n\t\ti,\n\t\tnoise_field1,\n\t\tnoise_field0;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (stv0900_get_standard(fe, demod) == STV0900_DVBS2_STANDARD) {\n\t\tnoise_field1 = NOSPLHT_NORMED1;\n\t\tnoise_field0 = NOSPLHT_NORMED0;\n\t} else {\n\t\tnoise_field1 = NOSDATAT_NORMED1;\n\t\tnoise_field0 = NOSDATAT_NORMED0;\n\t}\n\n\tif (stv0900_get_bits(intp, LOCK_DEFINITIF)) {\n\t\tif ((lookup != NULL) && lookup->size) {\n\t\t\tregval = 0;\n\t\t\tmsleep(5);\n\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\tregval += MAKEWORD(stv0900_get_bits(intp,\n\t\t\t\t\t\t\t\tnoise_field1),\n\t\t\t\t\t\tstv0900_get_bits(intp,\n\t\t\t\t\t\t\t\tnoise_field0));\n\t\t\t\tmsleep(1);\n\t\t\t}\n\n\t\t\tregval /= 16;\n\t\t\timin = 0;\n\t\t\timax = lookup->size - 1;\n\t\t\tif (INRANGE(lookup->table[imin].regval,\n\t\t\t\t\tregval,\n\t\t\t\t\tlookup->table[imax].regval)) {\n\t\t\t\twhile ((imax - imin) > 1) {\n\t\t\t\t\ti = (imax + imin) >> 1;\n\t\t\t\t\tif (INRANGE(lookup->table[imin].regval,\n\t\t\t\t\t\t    regval,\n\t\t\t\t\t\t    lookup->table[i].regval))\n\t\t\t\t\t\timax = i;\n\t\t\t\t\telse\n\t\t\t\t\t\timin = i;\n\t\t\t\t}\n\n\t\t\t\tc_n = ((regval - lookup->table[imin].regval)\n\t\t\t\t\t\t* (lookup->table[imax].realval\n\t\t\t\t\t\t- lookup->table[imin].realval)\n\t\t\t\t\t\t/ (lookup->table[imax].regval\n\t\t\t\t\t\t- lookup->table[imin].regval))\n\t\t\t\t\t\t+ lookup->table[imin].realval;\n\t\t\t} else if (regval < lookup->table[imin].regval)\n\t\t\t\tc_n = 1000;\n\t\t}\n\t}\n\n\treturn c_n;\n}\n\nstatic int stv0900_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tstruct stv0900_internal *intp = state->internal;\n\tenum fe_stv0900_demod_num demod = state->demod;\n\tu8 err_val1, err_val0;\n\tu32 header_err_val = 0;\n\n\t*ucblocks = 0x0;\n\tif (stv0900_get_standard(fe, demod) == STV0900_DVBS2_STANDARD) {\n\t\t \n\n\t\t \n\t\terr_val1 = stv0900_read_reg(intp, BBFCRCKO1);\n\t\terr_val0 = stv0900_read_reg(intp, BBFCRCKO0);\n\t\theader_err_val = (err_val1 << 8) | err_val0;\n\n\t\t \n\t\terr_val1 = stv0900_read_reg(intp, UPCRCKO1);\n\t\terr_val0 = stv0900_read_reg(intp, UPCRCKO0);\n\t\t*ucblocks = (err_val1 << 8) | err_val0;\n\t\t*ucblocks += header_err_val;\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0900_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\ts32 snrlcl = stv0900_carr_get_quality(fe,\n\t\t\t(const struct stv0900_table *)&stv0900_s2_cn);\n\tsnrlcl = (snrlcl + 30) * 384;\n\tif (snrlcl < 0)\n\t\tsnrlcl = 0;\n\n\tif (snrlcl > 65535)\n\t\tsnrlcl = 65535;\n\n\t*snr = snrlcl;\n\n\treturn 0;\n}\n\nstatic u32 stv0900_get_ber(struct stv0900_internal *intp,\n\t\t\t\tenum fe_stv0900_demod_num demod)\n{\n\tu32 ber = 10000000, i;\n\ts32 demod_state;\n\n\tdemod_state = stv0900_get_bits(intp, HEADER_MODE);\n\n\tswitch (demod_state) {\n\tcase STV0900_SEARCH:\n\tcase STV0900_PLH_DETECTED:\n\tdefault:\n\t\tber = 10000000;\n\t\tbreak;\n\tcase STV0900_DVBS_FOUND:\n\t\tber = 0;\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tmsleep(5);\n\t\t\tber += stv0900_get_err_count(intp, 0, demod);\n\t\t}\n\n\t\tber /= 5;\n\t\tif (stv0900_get_bits(intp, PRFVIT)) {\n\t\t\tber *= 9766;\n\t\t\tber = ber >> 13;\n\t\t}\n\n\t\tbreak;\n\tcase STV0900_DVBS2_FOUND:\n\t\tber = 0;\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tmsleep(5);\n\t\t\tber += stv0900_get_err_count(intp, 0, demod);\n\t\t}\n\n\t\tber /= 5;\n\t\tif (stv0900_get_bits(intp, PKTDELIN_LOCK)) {\n\t\t\tber *= 9766;\n\t\t\tber = ber >> 13;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn ber;\n}\n\nstatic int stv0900_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tstruct stv0900_internal *internal = state->internal;\n\n\t*ber = stv0900_get_ber(internal, state->demod);\n\n\treturn 0;\n}\n\nint stv0900_get_demod_lock(struct stv0900_internal *intp,\n\t\t\tenum fe_stv0900_demod_num demod, s32 time_out)\n{\n\ts32 timer = 0,\n\t\tlock = 0;\n\n\tenum fe_stv0900_search_state\tdmd_state;\n\n\twhile ((timer < time_out) && (lock == 0)) {\n\t\tdmd_state = stv0900_get_bits(intp, HEADER_MODE);\n\t\tdprintk(\"Demod State = %d\\n\", dmd_state);\n\t\tswitch (dmd_state) {\n\t\tcase STV0900_SEARCH:\n\t\tcase STV0900_PLH_DETECTED:\n\t\tdefault:\n\t\t\tlock = 0;\n\t\t\tbreak;\n\t\tcase STV0900_DVBS2_FOUND:\n\t\tcase STV0900_DVBS_FOUND:\n\t\t\tlock = stv0900_get_bits(intp, LOCK_DEFINITIF);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (lock == 0)\n\t\t\tmsleep(10);\n\n\t\ttimer += 10;\n\t}\n\n\tif (lock)\n\t\tdprintk(\"DEMOD LOCK OK\\n\");\n\telse\n\t\tdprintk(\"DEMOD LOCK FAIL\\n\");\n\n\treturn lock;\n}\n\nvoid stv0900_stop_all_s2_modcod(struct stv0900_internal *intp,\n\t\t\t\tenum fe_stv0900_demod_num demod)\n{\n\ts32 regflist,\n\ti;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tregflist = MODCODLST0;\n\n\tfor (i = 0; i < 16; i++)\n\t\tstv0900_write_reg(intp, regflist + i, 0xff);\n}\n\nvoid stv0900_activate_s2_modcod(struct stv0900_internal *intp,\n\t\t\t\tenum fe_stv0900_demod_num demod)\n{\n\tu32 matype,\n\t\tmod_code,\n\t\tfmod,\n\t\treg_index,\n\t\tfield_index;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (intp->chip_id <= 0x11) {\n\t\tmsleep(5);\n\n\t\tmod_code = stv0900_read_reg(intp, PLHMODCOD);\n\t\tmatype = mod_code & 0x3;\n\t\tmod_code = (mod_code & 0x7f) >> 2;\n\n\t\treg_index = MODCODLSTF - mod_code / 2;\n\t\tfield_index = mod_code % 2;\n\n\t\tswitch (matype) {\n\t\tcase 0:\n\t\tdefault:\n\t\t\tfmod = 14;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfmod = 13;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfmod = 11;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tfmod = 7;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((INRANGE(STV0900_QPSK_12, mod_code, STV0900_8PSK_910))\n\t\t\t\t\t\t&& (matype <= 1)) {\n\t\t\tif (field_index == 0)\n\t\t\t\tstv0900_write_reg(intp, reg_index,\n\t\t\t\t\t\t\t0xf0 | fmod);\n\t\t\telse\n\t\t\t\tstv0900_write_reg(intp, reg_index,\n\t\t\t\t\t\t\t(fmod << 4) | 0xf);\n\t\t}\n\n\t} else if (intp->chip_id >= 0x12) {\n\t\tfor (reg_index = 0; reg_index < 7; reg_index++)\n\t\t\tstv0900_write_reg(intp, MODCODLST0 + reg_index, 0xff);\n\n\t\tstv0900_write_reg(intp, MODCODLSTE, 0xff);\n\t\tstv0900_write_reg(intp, MODCODLSTF, 0xcf);\n\t\tfor (reg_index = 0; reg_index < 8; reg_index++)\n\t\t\tstv0900_write_reg(intp, MODCODLST7 + reg_index, 0xcc);\n\n\n\t}\n}\n\nvoid stv0900_activate_s2_modcod_single(struct stv0900_internal *intp,\n\t\t\t\t\tenum fe_stv0900_demod_num demod)\n{\n\tu32 reg_index;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tstv0900_write_reg(intp, MODCODLST0, 0xff);\n\tstv0900_write_reg(intp, MODCODLST1, 0xf0);\n\tstv0900_write_reg(intp, MODCODLSTF, 0x0f);\n\tfor (reg_index = 0; reg_index < 13; reg_index++)\n\t\tstv0900_write_reg(intp, MODCODLST2 + reg_index, 0);\n\n}\n\nstatic enum dvbfe_algo stv0900_frontend_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_CUSTOM;\n}\n\nvoid stv0900_start_search(struct stv0900_internal *intp,\n\t\t\t\tenum fe_stv0900_demod_num demod)\n{\n\tu32 freq;\n\ts16 freq_s16 ;\n\n\tstv0900_write_bits(intp, DEMOD_MODE, 0x1f);\n\tif (intp->chip_id == 0x10)\n\t\tstv0900_write_reg(intp, CORRELEXP, 0xaa);\n\n\tif (intp->chip_id < 0x20)\n\t\tstv0900_write_reg(intp, CARHDR, 0x55);\n\n\tif (intp->chip_id <= 0x20) {\n\t\tif (intp->symbol_rate[0] <= 5000000) {\n\t\t\tstv0900_write_reg(intp, CARCFG, 0x44);\n\t\t\tstv0900_write_reg(intp, CFRUP1, 0x0f);\n\t\t\tstv0900_write_reg(intp, CFRUP0, 0xff);\n\t\t\tstv0900_write_reg(intp, CFRLOW1, 0xf0);\n\t\t\tstv0900_write_reg(intp, CFRLOW0, 0x00);\n\t\t\tstv0900_write_reg(intp, RTCS2, 0x68);\n\t\t} else {\n\t\t\tstv0900_write_reg(intp, CARCFG, 0xc4);\n\t\t\tstv0900_write_reg(intp, RTCS2, 0x44);\n\t\t}\n\n\t} else {  \n\t\tif (intp->symbol_rate[demod] <= 5000000)\n\t\t\tstv0900_write_reg(intp, RTCS2, 0x68);\n\t\telse\n\t\t\tstv0900_write_reg(intp, RTCS2, 0x44);\n\n\t\tstv0900_write_reg(intp, CARCFG, 0x46);\n\t\tif (intp->srch_algo[demod] == STV0900_WARM_START) {\n\t\t\tfreq = 1000 << 16;\n\t\t\tfreq /= (intp->mclk / 1000);\n\t\t\tfreq_s16 = (s16)freq;\n\t\t} else {\n\t\t\tfreq = (intp->srch_range[demod] / 2000);\n\t\t\tif (intp->symbol_rate[demod] <= 5000000)\n\t\t\t\tfreq += 80;\n\t\t\telse\n\t\t\t\tfreq += 600;\n\n\t\t\tfreq = freq << 16;\n\t\t\tfreq /= (intp->mclk / 1000);\n\t\t\tfreq_s16 = (s16)freq;\n\t\t}\n\n\t\tstv0900_write_bits(intp, CFR_UP1, MSB(freq_s16));\n\t\tstv0900_write_bits(intp, CFR_UP0, LSB(freq_s16));\n\t\tfreq_s16 *= (-1);\n\t\tstv0900_write_bits(intp, CFR_LOW1, MSB(freq_s16));\n\t\tstv0900_write_bits(intp, CFR_LOW0, LSB(freq_s16));\n\t}\n\n\tstv0900_write_reg(intp, CFRINIT1, 0);\n\tstv0900_write_reg(intp, CFRINIT0, 0);\n\n\tif (intp->chip_id >= 0x20) {\n\t\tstv0900_write_reg(intp, EQUALCFG, 0x41);\n\t\tstv0900_write_reg(intp, FFECFG, 0x41);\n\n\t\tif ((intp->srch_standard[demod] == STV0900_SEARCH_DVBS1) ||\n\t\t\t(intp->srch_standard[demod] == STV0900_SEARCH_DSS) ||\n\t\t\t(intp->srch_standard[demod] == STV0900_AUTO_SEARCH)) {\n\t\t\tstv0900_write_reg(intp, VITSCALE,\n\t\t\t\t\t\t\t\t0x82);\n\t\t\tstv0900_write_reg(intp, VAVSRVIT, 0x0);\n\t\t}\n\t}\n\n\tstv0900_write_reg(intp, SFRSTEP, 0x00);\n\tstv0900_write_reg(intp, TMGTHRISE, 0xe0);\n\tstv0900_write_reg(intp, TMGTHFALL, 0xc0);\n\tstv0900_write_bits(intp, SCAN_ENABLE, 0);\n\tstv0900_write_bits(intp, CFR_AUTOSCAN, 0);\n\tstv0900_write_bits(intp, S1S2_SEQUENTIAL, 0);\n\tstv0900_write_reg(intp, RTC, 0x88);\n\tif (intp->chip_id >= 0x20) {\n\t\tif (intp->symbol_rate[demod] < 2000000) {\n\t\t\tif (intp->chip_id <= 0x20)\n\t\t\t\tstv0900_write_reg(intp, CARFREQ, 0x39);\n\t\t\telse   \n\t\t\t\tstv0900_write_reg(intp, CARFREQ, 0x89);\n\n\t\t\tstv0900_write_reg(intp, CARHDR, 0x40);\n\t\t} else if (intp->symbol_rate[demod] < 10000000) {\n\t\t\tstv0900_write_reg(intp, CARFREQ, 0x4c);\n\t\t\tstv0900_write_reg(intp, CARHDR, 0x20);\n\t\t} else {\n\t\t\tstv0900_write_reg(intp, CARFREQ, 0x4b);\n\t\t\tstv0900_write_reg(intp, CARHDR, 0x20);\n\t\t}\n\n\t} else {\n\t\tif (intp->symbol_rate[demod] < 10000000)\n\t\t\tstv0900_write_reg(intp, CARFREQ, 0xef);\n\t\telse\n\t\t\tstv0900_write_reg(intp, CARFREQ, 0xed);\n\t}\n\n\tswitch (intp->srch_algo[demod]) {\n\tcase STV0900_WARM_START:\n\t\tstv0900_write_reg(intp, DMDISTATE, 0x1f);\n\t\tstv0900_write_reg(intp, DMDISTATE, 0x18);\n\t\tbreak;\n\tcase STV0900_COLD_START:\n\t\tstv0900_write_reg(intp, DMDISTATE, 0x1f);\n\t\tstv0900_write_reg(intp, DMDISTATE, 0x15);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nu8 stv0900_get_optim_carr_loop(s32 srate, enum fe_stv0900_modcode modcode,\n\t\t\t\t\t\t\ts32 pilot, u8 chip_id)\n{\n\tu8 aclc_value = 0x29;\n\ts32 i, cllas2_size;\n\tconst struct stv0900_car_loop_optim *cls2, *cllqs2, *cllas2;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (chip_id <= 0x12) {\n\t\tcls2 = FE_STV0900_S2CarLoop;\n\t\tcllqs2 = FE_STV0900_S2LowQPCarLoopCut30;\n\t\tcllas2 = FE_STV0900_S2APSKCarLoopCut30;\n\t\tcllas2_size = ARRAY_SIZE(FE_STV0900_S2APSKCarLoopCut30);\n\t} else if (chip_id == 0x20) {\n\t\tcls2 = FE_STV0900_S2CarLoopCut20;\n\t\tcllqs2 = FE_STV0900_S2LowQPCarLoopCut20;\n\t\tcllas2 = FE_STV0900_S2APSKCarLoopCut20;\n\t\tcllas2_size = ARRAY_SIZE(FE_STV0900_S2APSKCarLoopCut20);\n\t} else {\n\t\tcls2 = FE_STV0900_S2CarLoopCut30;\n\t\tcllqs2 = FE_STV0900_S2LowQPCarLoopCut30;\n\t\tcllas2 = FE_STV0900_S2APSKCarLoopCut30;\n\t\tcllas2_size = ARRAY_SIZE(FE_STV0900_S2APSKCarLoopCut30);\n\t}\n\n\tif (modcode < STV0900_QPSK_12) {\n\t\ti = 0;\n\t\twhile ((i < 3) && (modcode != cllqs2[i].modcode))\n\t\t\ti++;\n\n\t\tif (i >= 3)\n\t\t\ti = 2;\n\t} else {\n\t\ti = 0;\n\t\twhile ((i < 14) && (modcode != cls2[i].modcode))\n\t\t\ti++;\n\n\t\tif (i >= 14) {\n\t\t\ti = 0;\n\t\t\twhile ((i < 11) && (modcode != cllas2[i].modcode))\n\t\t\t\ti++;\n\n\t\t\tif (i >= 11)\n\t\t\t\ti = 10;\n\t\t}\n\t}\n\n\tif (modcode <= STV0900_QPSK_25) {\n\t\tif (pilot) {\n\t\t\tif (srate <= 3000000)\n\t\t\t\taclc_value = cllqs2[i].car_loop_pilots_on_2;\n\t\t\telse if (srate <= 7000000)\n\t\t\t\taclc_value = cllqs2[i].car_loop_pilots_on_5;\n\t\t\telse if (srate <= 15000000)\n\t\t\t\taclc_value = cllqs2[i].car_loop_pilots_on_10;\n\t\t\telse if (srate <= 25000000)\n\t\t\t\taclc_value = cllqs2[i].car_loop_pilots_on_20;\n\t\t\telse\n\t\t\t\taclc_value = cllqs2[i].car_loop_pilots_on_30;\n\t\t} else {\n\t\t\tif (srate <= 3000000)\n\t\t\t\taclc_value = cllqs2[i].car_loop_pilots_off_2;\n\t\t\telse if (srate <= 7000000)\n\t\t\t\taclc_value = cllqs2[i].car_loop_pilots_off_5;\n\t\t\telse if (srate <= 15000000)\n\t\t\t\taclc_value = cllqs2[i].car_loop_pilots_off_10;\n\t\t\telse if (srate <= 25000000)\n\t\t\t\taclc_value = cllqs2[i].car_loop_pilots_off_20;\n\t\t\telse\n\t\t\t\taclc_value = cllqs2[i].car_loop_pilots_off_30;\n\t\t}\n\n\t} else if (modcode <= STV0900_8PSK_910) {\n\t\tif (pilot) {\n\t\t\tif (srate <= 3000000)\n\t\t\t\taclc_value = cls2[i].car_loop_pilots_on_2;\n\t\t\telse if (srate <= 7000000)\n\t\t\t\taclc_value = cls2[i].car_loop_pilots_on_5;\n\t\t\telse if (srate <= 15000000)\n\t\t\t\taclc_value = cls2[i].car_loop_pilots_on_10;\n\t\t\telse if (srate <= 25000000)\n\t\t\t\taclc_value = cls2[i].car_loop_pilots_on_20;\n\t\t\telse\n\t\t\t\taclc_value = cls2[i].car_loop_pilots_on_30;\n\t\t} else {\n\t\t\tif (srate <= 3000000)\n\t\t\t\taclc_value = cls2[i].car_loop_pilots_off_2;\n\t\t\telse if (srate <= 7000000)\n\t\t\t\taclc_value = cls2[i].car_loop_pilots_off_5;\n\t\t\telse if (srate <= 15000000)\n\t\t\t\taclc_value = cls2[i].car_loop_pilots_off_10;\n\t\t\telse if (srate <= 25000000)\n\t\t\t\taclc_value = cls2[i].car_loop_pilots_off_20;\n\t\t\telse\n\t\t\t\taclc_value = cls2[i].car_loop_pilots_off_30;\n\t\t}\n\n\t} else if (i < cllas2_size) {\n\t\tif (srate <= 3000000)\n\t\t\taclc_value = cllas2[i].car_loop_pilots_on_2;\n\t\telse if (srate <= 7000000)\n\t\t\taclc_value = cllas2[i].car_loop_pilots_on_5;\n\t\telse if (srate <= 15000000)\n\t\t\taclc_value = cllas2[i].car_loop_pilots_on_10;\n\t\telse if (srate <= 25000000)\n\t\t\taclc_value = cllas2[i].car_loop_pilots_on_20;\n\t\telse\n\t\t\taclc_value = cllas2[i].car_loop_pilots_on_30;\n\t}\n\n\treturn aclc_value;\n}\n\nu8 stv0900_get_optim_short_carr_loop(s32 srate,\n\t\t\t\tenum fe_stv0900_modulation modulation,\n\t\t\t\tu8 chip_id)\n{\n\tconst struct stv0900_short_frames_car_loop_optim *s2scl;\n\tconst struct stv0900_short_frames_car_loop_optim_vs_mod *s2sclc30;\n\ts32 mod_index = 0;\n\tu8 aclc_value = 0x0b;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\ts2scl = FE_STV0900_S2ShortCarLoop;\n\ts2sclc30 = FE_STV0900_S2ShortCarLoopCut30;\n\n\tswitch (modulation) {\n\tcase STV0900_QPSK:\n\tdefault:\n\t\tmod_index = 0;\n\t\tbreak;\n\tcase STV0900_8PSK:\n\t\tmod_index = 1;\n\t\tbreak;\n\tcase STV0900_16APSK:\n\t\tmod_index = 2;\n\t\tbreak;\n\tcase STV0900_32APSK:\n\t\tmod_index = 3;\n\t\tbreak;\n\t}\n\n\tif (chip_id >= 0x30) {\n\t\tif (srate <= 3000000)\n\t\t\taclc_value = s2sclc30[mod_index].car_loop_2;\n\t\telse if (srate <= 7000000)\n\t\t\taclc_value = s2sclc30[mod_index].car_loop_5;\n\t\telse if (srate <= 15000000)\n\t\t\taclc_value = s2sclc30[mod_index].car_loop_10;\n\t\telse if (srate <= 25000000)\n\t\t\taclc_value = s2sclc30[mod_index].car_loop_20;\n\t\telse\n\t\t\taclc_value = s2sclc30[mod_index].car_loop_30;\n\n\t} else if (chip_id >= 0x20) {\n\t\tif (srate <= 3000000)\n\t\t\taclc_value = s2scl[mod_index].car_loop_cut20_2;\n\t\telse if (srate <= 7000000)\n\t\t\taclc_value = s2scl[mod_index].car_loop_cut20_5;\n\t\telse if (srate <= 15000000)\n\t\t\taclc_value = s2scl[mod_index].car_loop_cut20_10;\n\t\telse if (srate <= 25000000)\n\t\t\taclc_value = s2scl[mod_index].car_loop_cut20_20;\n\t\telse\n\t\t\taclc_value = s2scl[mod_index].car_loop_cut20_30;\n\n\t} else {\n\t\tif (srate <= 3000000)\n\t\t\taclc_value = s2scl[mod_index].car_loop_cut12_2;\n\t\telse if (srate <= 7000000)\n\t\t\taclc_value = s2scl[mod_index].car_loop_cut12_5;\n\t\telse if (srate <= 15000000)\n\t\t\taclc_value = s2scl[mod_index].car_loop_cut12_10;\n\t\telse if (srate <= 25000000)\n\t\t\taclc_value = s2scl[mod_index].car_loop_cut12_20;\n\t\telse\n\t\t\taclc_value = s2scl[mod_index].car_loop_cut12_30;\n\n\t}\n\n\treturn aclc_value;\n}\n\nstatic\nenum fe_stv0900_error stv0900_st_dvbs2_single(struct stv0900_internal *intp,\n\t\t\t\t\tenum fe_stv0900_demod_mode LDPC_Mode,\n\t\t\t\t\tenum fe_stv0900_demod_num demod)\n{\n\ts32 reg_ind;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tswitch (LDPC_Mode) {\n\tcase STV0900_DUAL:\n\tdefault:\n\t\tif ((intp->demod_mode != STV0900_DUAL)\n\t\t\t|| (stv0900_get_bits(intp, F0900_DDEMOD) != 1)) {\n\t\t\tstv0900_write_reg(intp, R0900_GENCFG, 0x1d);\n\n\t\t\tintp->demod_mode = STV0900_DUAL;\n\n\t\t\tstv0900_write_bits(intp, F0900_FRESFEC, 1);\n\t\t\tstv0900_write_bits(intp, F0900_FRESFEC, 0);\n\n\t\t\tfor (reg_ind = 0; reg_ind < 7; reg_ind++)\n\t\t\t\tstv0900_write_reg(intp,\n\t\t\t\t\t\tR0900_P1_MODCODLST0 + reg_ind,\n\t\t\t\t\t\t0xff);\n\t\t\tfor (reg_ind = 0; reg_ind < 8; reg_ind++)\n\t\t\t\tstv0900_write_reg(intp,\n\t\t\t\t\t\tR0900_P1_MODCODLST7 + reg_ind,\n\t\t\t\t\t\t0xcc);\n\n\t\t\tstv0900_write_reg(intp, R0900_P1_MODCODLSTE, 0xff);\n\t\t\tstv0900_write_reg(intp, R0900_P1_MODCODLSTF, 0xcf);\n\n\t\t\tfor (reg_ind = 0; reg_ind < 7; reg_ind++)\n\t\t\t\tstv0900_write_reg(intp,\n\t\t\t\t\t\tR0900_P2_MODCODLST0 + reg_ind,\n\t\t\t\t\t\t0xff);\n\t\t\tfor (reg_ind = 0; reg_ind < 8; reg_ind++)\n\t\t\t\tstv0900_write_reg(intp,\n\t\t\t\t\t\tR0900_P2_MODCODLST7 + reg_ind,\n\t\t\t\t\t\t0xcc);\n\n\t\t\tstv0900_write_reg(intp, R0900_P2_MODCODLSTE, 0xff);\n\t\t\tstv0900_write_reg(intp, R0900_P2_MODCODLSTF, 0xcf);\n\t\t}\n\n\t\tbreak;\n\tcase STV0900_SINGLE:\n\t\tif (demod == STV0900_DEMOD_2) {\n\t\t\tstv0900_stop_all_s2_modcod(intp, STV0900_DEMOD_1);\n\t\t\tstv0900_activate_s2_modcod_single(intp,\n\t\t\t\t\t\t\tSTV0900_DEMOD_2);\n\t\t\tstv0900_write_reg(intp, R0900_GENCFG, 0x06);\n\t\t} else {\n\t\t\tstv0900_stop_all_s2_modcod(intp, STV0900_DEMOD_2);\n\t\t\tstv0900_activate_s2_modcod_single(intp,\n\t\t\t\t\t\t\tSTV0900_DEMOD_1);\n\t\t\tstv0900_write_reg(intp, R0900_GENCFG, 0x04);\n\t\t}\n\n\t\tintp->demod_mode = STV0900_SINGLE;\n\n\t\tstv0900_write_bits(intp, F0900_FRESFEC, 1);\n\t\tstv0900_write_bits(intp, F0900_FRESFEC, 0);\n\t\tstv0900_write_bits(intp, F0900_P1_ALGOSWRST, 1);\n\t\tstv0900_write_bits(intp, F0900_P1_ALGOSWRST, 0);\n\t\tstv0900_write_bits(intp, F0900_P2_ALGOSWRST, 1);\n\t\tstv0900_write_bits(intp, F0900_P2_ALGOSWRST, 0);\n\t\tbreak;\n\t}\n\n\treturn STV0900_NO_ERROR;\n}\n\nstatic enum fe_stv0900_error stv0900_init_internal(struct dvb_frontend *fe,\n\t\t\t\t\tstruct stv0900_init_params *p_init)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tenum fe_stv0900_error error = STV0900_NO_ERROR;\n\tenum fe_stv0900_error demodError = STV0900_NO_ERROR;\n\tstruct stv0900_internal *intp = NULL;\n\tint selosci, i;\n\n\tstruct stv0900_inode *temp_int = find_inode(state->i2c_adap,\n\t\t\t\t\t\tstate->config->demod_address);\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif ((temp_int != NULL) && (p_init->demod_mode == STV0900_DUAL)) {\n\t\tstate->internal = temp_int->internal;\n\t\t(state->internal->dmds_used)++;\n\t\tdprintk(\"%s: Find Internal Structure!\\n\", __func__);\n\t\treturn STV0900_NO_ERROR;\n\t} else {\n\t\tstate->internal = kmalloc(sizeof(struct stv0900_internal),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (state->internal == NULL)\n\t\t\treturn STV0900_INVALID_HANDLE;\n\t\ttemp_int = append_internal(state->internal);\n\t\tif (temp_int == NULL) {\n\t\t\tkfree(state->internal);\n\t\t\tstate->internal = NULL;\n\t\t\treturn STV0900_INVALID_HANDLE;\n\t\t}\n\t\tstate->internal->dmds_used = 1;\n\t\tstate->internal->i2c_adap = state->i2c_adap;\n\t\tstate->internal->i2c_addr = state->config->demod_address;\n\t\tstate->internal->clkmode = state->config->clkmode;\n\t\tstate->internal->errs = STV0900_NO_ERROR;\n\t\tdprintk(\"%s: Create New Internal Structure!\\n\", __func__);\n\t}\n\n\tif (state->internal == NULL) {\n\t\terror = STV0900_INVALID_HANDLE;\n\t\treturn error;\n\t}\n\n\tdemodError = stv0900_initialize(state->internal);\n\tif (demodError == STV0900_NO_ERROR) {\n\t\t\terror = STV0900_NO_ERROR;\n\t} else {\n\t\tif (demodError == STV0900_INVALID_HANDLE)\n\t\t\terror = STV0900_INVALID_HANDLE;\n\t\telse\n\t\t\terror = STV0900_I2C_ERROR;\n\n\t\treturn error;\n\t}\n\n\tintp = state->internal;\n\n\tintp->demod_mode = p_init->demod_mode;\n\tstv0900_st_dvbs2_single(intp, intp->demod_mode,\tSTV0900_DEMOD_1);\n\tintp->chip_id = stv0900_read_reg(intp, R0900_MID);\n\tintp->rolloff = p_init->rolloff;\n\tintp->quartz = p_init->dmd_ref_clk;\n\n\tstv0900_write_bits(intp, F0900_P1_ROLLOFF_CONTROL, p_init->rolloff);\n\tstv0900_write_bits(intp, F0900_P2_ROLLOFF_CONTROL, p_init->rolloff);\n\n\tintp->ts_config = p_init->ts_config;\n\tif (intp->ts_config == NULL)\n\t\tstv0900_set_ts_parallel_serial(intp,\n\t\t\t\tp_init->path1_ts_clock,\n\t\t\t\tp_init->path2_ts_clock);\n\telse {\n\t\tfor (i = 0; intp->ts_config[i].addr != 0xffff; i++)\n\t\t\tstv0900_write_reg(intp,\n\t\t\t\t\tintp->ts_config[i].addr,\n\t\t\t\t\tintp->ts_config[i].val);\n\n\t\tstv0900_write_bits(intp, F0900_P2_RST_HWARE, 1);\n\t\tstv0900_write_bits(intp, F0900_P2_RST_HWARE, 0);\n\t\tstv0900_write_bits(intp, F0900_P1_RST_HWARE, 1);\n\t\tstv0900_write_bits(intp, F0900_P1_RST_HWARE, 0);\n\t}\n\n\tintp->tuner_type[0] = p_init->tuner1_type;\n\tintp->tuner_type[1] = p_init->tuner2_type;\n\t \n\tswitch (p_init->tuner1_type) {\n\tcase 3:  \n\t\tstv0900_write_reg(intp, R0900_P1_TNRCFG, 0x3c);\n\t\tstv0900_write_reg(intp, R0900_P1_TNRCFG2, 0x86);\n\t\tstv0900_write_reg(intp, R0900_P1_TNRCFG3, 0x18);\n\t\tstv0900_write_reg(intp, R0900_P1_TNRXTAL, 27);  \n\t\tstv0900_write_reg(intp, R0900_P1_TNRSTEPS, 0x05);\n\t\tstv0900_write_reg(intp, R0900_P1_TNRGAIN, 0x17);\n\t\tstv0900_write_reg(intp, R0900_P1_TNRADJ, 0x1f);\n\t\tstv0900_write_reg(intp, R0900_P1_TNRCTL2, 0x0);\n\t\tstv0900_write_bits(intp, F0900_P1_TUN_TYPE, 3);\n\t\tbreak;\n\t \n\tdefault:\n\t\tstv0900_write_bits(intp, F0900_P1_TUN_TYPE, 6);\n\t\tbreak;\n\t}\n\n\tstv0900_write_bits(intp, F0900_P1_TUN_MADDRESS, p_init->tun1_maddress);\n\tswitch (p_init->tuner1_adc) {\n\tcase 1:\n\t\tstv0900_write_reg(intp, R0900_TSTTNR1, 0x26);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tstv0900_write_reg(intp, R0900_P1_TNRLD, 1);  \n\n\t \n\tswitch (p_init->tuner2_type) {\n\tcase 3:  \n\t\tstv0900_write_reg(intp, R0900_P2_TNRCFG, 0x3c);\n\t\tstv0900_write_reg(intp, R0900_P2_TNRCFG2, 0x86);\n\t\tstv0900_write_reg(intp, R0900_P2_TNRCFG3, 0x18);\n\t\tstv0900_write_reg(intp, R0900_P2_TNRXTAL, 27);  \n\t\tstv0900_write_reg(intp, R0900_P2_TNRSTEPS, 0x05);\n\t\tstv0900_write_reg(intp, R0900_P2_TNRGAIN, 0x17);\n\t\tstv0900_write_reg(intp, R0900_P2_TNRADJ, 0x1f);\n\t\tstv0900_write_reg(intp, R0900_P2_TNRCTL2, 0x0);\n\t\tstv0900_write_bits(intp, F0900_P2_TUN_TYPE, 3);\n\t\tbreak;\n\t \n\tdefault:\n\t\tstv0900_write_bits(intp, F0900_P2_TUN_TYPE, 6);\n\t\tbreak;\n\t}\n\n\tstv0900_write_bits(intp, F0900_P2_TUN_MADDRESS, p_init->tun2_maddress);\n\tswitch (p_init->tuner2_adc) {\n\tcase 1:\n\t\tstv0900_write_reg(intp, R0900_TSTTNR3, 0x26);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tstv0900_write_reg(intp, R0900_P2_TNRLD, 1);  \n\n\tstv0900_write_bits(intp, F0900_P1_TUN_IQSWAP, p_init->tun1_iq_inv);\n\tstv0900_write_bits(intp, F0900_P2_TUN_IQSWAP, p_init->tun2_iq_inv);\n\tstv0900_set_mclk(intp, 135000000);\n\tmsleep(3);\n\n\tswitch (intp->clkmode) {\n\tcase 0:\n\tcase 2:\n\t\tstv0900_write_reg(intp, R0900_SYNTCTRL, 0x20 | intp->clkmode);\n\t\tbreak;\n\tdefault:\n\t\tselosci = 0x02 & stv0900_read_reg(intp, R0900_SYNTCTRL);\n\t\tstv0900_write_reg(intp, R0900_SYNTCTRL, 0x20 | selosci);\n\t\tbreak;\n\t}\n\tmsleep(3);\n\n\tintp->mclk = stv0900_get_mclk_freq(intp, intp->quartz);\n\tif (intp->errs)\n\t\terror = STV0900_I2C_ERROR;\n\n\treturn error;\n}\n\nstatic int stv0900_status(struct stv0900_internal *intp,\n\t\t\t\t\tenum fe_stv0900_demod_num demod)\n{\n\tenum fe_stv0900_search_state demod_state;\n\tint locked = FALSE;\n\tu8 tsbitrate0_val, tsbitrate1_val;\n\ts32 bitrate;\n\n\tdemod_state = stv0900_get_bits(intp, HEADER_MODE);\n\tswitch (demod_state) {\n\tcase STV0900_SEARCH:\n\tcase STV0900_PLH_DETECTED:\n\tdefault:\n\t\tlocked = FALSE;\n\t\tbreak;\n\tcase STV0900_DVBS2_FOUND:\n\t\tlocked = stv0900_get_bits(intp, LOCK_DEFINITIF) &&\n\t\t\t\tstv0900_get_bits(intp, PKTDELIN_LOCK) &&\n\t\t\t\tstv0900_get_bits(intp, TSFIFO_LINEOK);\n\t\tbreak;\n\tcase STV0900_DVBS_FOUND:\n\t\tlocked = stv0900_get_bits(intp, LOCK_DEFINITIF) &&\n\t\t\t\tstv0900_get_bits(intp, LOCKEDVIT) &&\n\t\t\t\tstv0900_get_bits(intp, TSFIFO_LINEOK);\n\t\tbreak;\n\t}\n\n\tdprintk(\"%s: locked = %d\\n\", __func__, locked);\n\n\tif (stvdebug) {\n\t\t \n\t\ttsbitrate0_val = stv0900_read_reg(intp, TSBITRATE0);\n\t\ttsbitrate1_val = stv0900_read_reg(intp, TSBITRATE1);\n\t\t \n\t\tbitrate = (stv0900_get_mclk_freq(intp, intp->quartz)/1000000)\n\t\t\t* (tsbitrate1_val << 8 | tsbitrate0_val);\n\t\tbitrate /= 16384;\n\t\tdprintk(\"TS bitrate = %d Mbit/sec\\n\", bitrate);\n\t}\n\n\treturn locked;\n}\n\nstatic int stv0900_set_mis(struct stv0900_internal *intp,\n\t\t\t\tenum fe_stv0900_demod_num demod, int mis)\n{\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (mis < 0 || mis > 255) {\n\t\tdprintk(\"Disable MIS filtering\\n\");\n\t\tstv0900_write_bits(intp, FILTER_EN, 0);\n\t} else {\n\t\tdprintk(\"Enable MIS filtering - %d\\n\", mis);\n\t\tstv0900_write_bits(intp, FILTER_EN, 1);\n\t\tstv0900_write_reg(intp, ISIENTRY, mis);\n\t\tstv0900_write_reg(intp, ISIBITENA, 0xff);\n\t}\n\n\treturn STV0900_NO_ERROR;\n}\n\n\nstatic enum dvbfe_search stv0900_search(struct dvb_frontend *fe)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tstruct stv0900_internal *intp = state->internal;\n\tenum fe_stv0900_demod_num demod = state->demod;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tstruct stv0900_search_params p_search;\n\tstruct stv0900_signal_info p_result = intp->result[demod];\n\n\tenum fe_stv0900_error error = STV0900_NO_ERROR;\n\n\tdprintk(\"%s: \", __func__);\n\n\tif (!(INRANGE(100000, c->symbol_rate, 70000000)))\n\t\treturn DVBFE_ALGO_SEARCH_FAILED;\n\n\tif (state->config->set_ts_params)\n\t\tstate->config->set_ts_params(fe, 0);\n\n\tstv0900_set_mis(intp, demod, c->stream_id);\n\n\tp_result.locked = FALSE;\n\tp_search.path = demod;\n\tp_search.frequency = c->frequency;\n\tp_search.symbol_rate = c->symbol_rate;\n\tp_search.search_range = 10000000;\n\tp_search.fec = STV0900_FEC_UNKNOWN;\n\tp_search.standard = STV0900_AUTO_SEARCH;\n\tp_search.iq_inversion = STV0900_IQ_AUTO;\n\tp_search.search_algo = STV0900_BLIND_SEARCH;\n\t \n\tif (c->delivery_system == SYS_DVBS)\n\t\tp_search.standard = STV0900_SEARCH_DVBS1;\n\n\tintp->srch_standard[demod] = p_search.standard;\n\tintp->symbol_rate[demod] = p_search.symbol_rate;\n\tintp->srch_range[demod] = p_search.search_range;\n\tintp->freq[demod] = p_search.frequency;\n\tintp->srch_algo[demod] = p_search.search_algo;\n\tintp->srch_iq_inv[demod] = p_search.iq_inversion;\n\tintp->fec[demod] = p_search.fec;\n\tif ((stv0900_algo(fe) == STV0900_RANGEOK) &&\n\t\t\t\t(intp->errs == STV0900_NO_ERROR)) {\n\t\tp_result.locked = intp->result[demod].locked;\n\t\tp_result.standard = intp->result[demod].standard;\n\t\tp_result.frequency = intp->result[demod].frequency;\n\t\tp_result.symbol_rate = intp->result[demod].symbol_rate;\n\t\tp_result.fec = intp->result[demod].fec;\n\t\tp_result.modcode = intp->result[demod].modcode;\n\t\tp_result.pilot = intp->result[demod].pilot;\n\t\tp_result.frame_len = intp->result[demod].frame_len;\n\t\tp_result.spectrum = intp->result[demod].spectrum;\n\t\tp_result.rolloff = intp->result[demod].rolloff;\n\t\tp_result.modulation = intp->result[demod].modulation;\n\t} else {\n\t\tp_result.locked = FALSE;\n\t\tswitch (intp->err[demod]) {\n\t\tcase STV0900_I2C_ERROR:\n\t\t\terror = STV0900_I2C_ERROR;\n\t\t\tbreak;\n\t\tcase STV0900_NO_ERROR:\n\t\tdefault:\n\t\t\terror = STV0900_SEARCH_FAILED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((p_result.locked == TRUE) && (error == STV0900_NO_ERROR)) {\n\t\tdprintk(\"Search Success\\n\");\n\t\treturn DVBFE_ALGO_SEARCH_SUCCESS;\n\t} else {\n\t\tdprintk(\"Search Fail\\n\");\n\t\treturn DVBFE_ALGO_SEARCH_FAILED;\n\t}\n\n}\n\nstatic int stv0900_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s: \", __func__);\n\n\tif ((stv0900_status(state->internal, state->demod)) == TRUE) {\n\t\tdprintk(\"DEMOD LOCK OK\\n\");\n\t\t*status = FE_HAS_CARRIER\n\t\t\t| FE_HAS_VITERBI\n\t\t\t| FE_HAS_SYNC\n\t\t\t| FE_HAS_LOCK;\n\t\tif (state->config->set_lock_led)\n\t\t\tstate->config->set_lock_led(fe, 1);\n\t} else {\n\t\t*status = 0;\n\t\tif (state->config->set_lock_led)\n\t\t\tstate->config->set_lock_led(fe, 0);\n\t\tdprintk(\"DEMOD LOCK FAIL\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0900_stop_ts(struct dvb_frontend *fe, int stop_ts)\n{\n\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tstruct stv0900_internal *intp = state->internal;\n\tenum fe_stv0900_demod_num demod = state->demod;\n\n\tif (stop_ts == TRUE)\n\t\tstv0900_write_bits(intp, RST_HWARE, 1);\n\telse\n\t\tstv0900_write_bits(intp, RST_HWARE, 0);\n\n\treturn 0;\n}\n\nstatic int stv0900_diseqc_init(struct dvb_frontend *fe)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tstruct stv0900_internal *intp = state->internal;\n\tenum fe_stv0900_demod_num demod = state->demod;\n\n\tstv0900_write_bits(intp, DISTX_MODE, state->config->diseqc_mode);\n\tstv0900_write_bits(intp, DISEQC_RESET, 1);\n\tstv0900_write_bits(intp, DISEQC_RESET, 0);\n\n\treturn 0;\n}\n\nstatic int stv0900_init(struct dvb_frontend *fe)\n{\n\tdprintk(\"%s\\n\", __func__);\n\n\tstv0900_stop_ts(fe, 1);\n\tstv0900_diseqc_init(fe);\n\n\treturn 0;\n}\n\nstatic int stv0900_diseqc_send(struct stv0900_internal *intp , u8 *data,\n\t\t\t\tu32 NbData, enum fe_stv0900_demod_num demod)\n{\n\ts32 i = 0;\n\n\tstv0900_write_bits(intp, DIS_PRECHARGE, 1);\n\twhile (i < NbData) {\n\t\twhile (stv0900_get_bits(intp, FIFO_FULL))\n\t\t\t; \n\t\tstv0900_write_reg(intp, DISTXDATA, data[i]);\n\t\ti++;\n\t}\n\n\tstv0900_write_bits(intp, DIS_PRECHARGE, 0);\n\ti = 0;\n\twhile ((stv0900_get_bits(intp, TX_IDLE) != 1) && (i < 10)) {\n\t\tmsleep(10);\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0900_send_master_cmd(struct dvb_frontend *fe,\n\t\t\t\t\tstruct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\n\treturn stv0900_diseqc_send(state->internal,\n\t\t\t\tcmd->msg,\n\t\t\t\tcmd->msg_len,\n\t\t\t\tstate->demod);\n}\n\nstatic int stv0900_send_burst(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_mini_cmd burst)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tstruct stv0900_internal *intp = state->internal;\n\tenum fe_stv0900_demod_num demod = state->demod;\n\tu8 data;\n\n\n\tswitch (burst) {\n\tcase SEC_MINI_A:\n\t\tstv0900_write_bits(intp, DISTX_MODE, 3); \n\t\tdata = 0x00;\n\t\tstv0900_diseqc_send(intp, &data, 1, state->demod);\n\t\tbreak;\n\tcase SEC_MINI_B:\n\t\tstv0900_write_bits(intp, DISTX_MODE, 2); \n\t\tdata = 0xff;\n\t\tstv0900_diseqc_send(intp, &data, 1, state->demod);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0900_recv_slave_reply(struct dvb_frontend *fe,\n\t\t\t\tstruct dvb_diseqc_slave_reply *reply)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tstruct stv0900_internal *intp = state->internal;\n\tenum fe_stv0900_demod_num demod = state->demod;\n\ts32 i = 0;\n\n\treply->msg_len = 0;\n\n\twhile ((stv0900_get_bits(intp, RX_END) != 1) && (i < 10)) {\n\t\tmsleep(10);\n\t\ti++;\n\t}\n\n\tif (stv0900_get_bits(intp, RX_END)) {\n\t\treply->msg_len = stv0900_get_bits(intp, FIFO_BYTENBR);\n\n\t\tfor (i = 0; i < reply->msg_len; i++)\n\t\t\treply->msg[i] = stv0900_read_reg(intp, DISRXDATA);\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0900_set_tone(struct dvb_frontend *fe,\n\t\t\t    enum fe_sec_tone_mode toneoff)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tstruct stv0900_internal *intp = state->internal;\n\tenum fe_stv0900_demod_num demod = state->demod;\n\n\tdprintk(\"%s: %s\\n\", __func__, ((toneoff == 0) ? \"On\" : \"Off\"));\n\n\tswitch (toneoff) {\n\tcase SEC_TONE_ON:\n\t\t \n\t\tstv0900_write_bits(intp, DISTX_MODE, 0);\n\t\tstv0900_write_bits(intp, DISEQC_RESET, 1);\n\t\t \n\t\tstv0900_write_bits(intp, DISEQC_RESET, 0);\n\t\tbreak;\n\tcase SEC_TONE_OFF:\n\t\t \n\t\tstv0900_write_bits(intp, DISTX_MODE,\n\t\t\t\tstate->config->diseqc_mode);\n\t\t \n\t\tstv0900_write_bits(intp, DISEQC_RESET, 1);\n\t\tstv0900_write_bits(intp, DISEQC_RESET, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void stv0900_release(struct dvb_frontend *fe)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (state->config->set_lock_led)\n\t\tstate->config->set_lock_led(fe, 0);\n\n\tif ((--(state->internal->dmds_used)) <= 0) {\n\n\t\tdprintk(\"%s: Actually removing\\n\", __func__);\n\n\t\tremove_inode(state->internal);\n\t\tkfree(state->internal);\n\t}\n\n\tkfree(state);\n}\n\nstatic int stv0900_sleep(struct dvb_frontend *fe)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (state->config->set_lock_led)\n\t\tstate->config->set_lock_led(fe, 0);\n\n\treturn 0;\n}\n\nstatic int stv0900_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct stv0900_state *state = fe->demodulator_priv;\n\tstruct stv0900_internal *intp = state->internal;\n\tenum fe_stv0900_demod_num demod = state->demod;\n\tstruct stv0900_signal_info p_result = intp->result[demod];\n\n\tp->frequency = p_result.locked ? p_result.frequency : 0;\n\tp->symbol_rate = p_result.locked ? p_result.symbol_rate : 0;\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops stv0900_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2, SYS_DSS },\n\t.info = {\n\t\t.name\t\t\t= \"STV0900 frontend\",\n\t\t.frequency_min_hz\t=  950 * MHz,\n\t\t.frequency_max_hz\t= 2150 * MHz,\n\t\t.frequency_stepsize_hz\t=  125 * kHz,\n\t\t.symbol_rate_min\t= 1000000,\n\t\t.symbol_rate_max\t= 45000000,\n\t\t.symbol_rate_tolerance\t= 500,\n\t\t.caps\t\t\t= FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |\n\t\t\t\t\t  FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 |\n\t\t\t\t\t  FE_CAN_FEC_7_8 | FE_CAN_QPSK    |\n\t\t\t\t\t  FE_CAN_2G_MODULATION |\n\t\t\t\t\t  FE_CAN_FEC_AUTO\n\t},\n\t.release\t\t\t= stv0900_release,\n\t.init\t\t\t\t= stv0900_init,\n\t.get_frontend                   = stv0900_get_frontend,\n\t.sleep\t\t\t\t= stv0900_sleep,\n\t.get_frontend_algo\t\t= stv0900_frontend_algo,\n\t.i2c_gate_ctrl\t\t\t= stv0900_i2c_gate_ctrl,\n\t.diseqc_send_master_cmd\t\t= stv0900_send_master_cmd,\n\t.diseqc_send_burst\t\t= stv0900_send_burst,\n\t.diseqc_recv_slave_reply\t= stv0900_recv_slave_reply,\n\t.set_tone\t\t\t= stv0900_set_tone,\n\t.search\t\t\t\t= stv0900_search,\n\t.read_status\t\t\t= stv0900_read_status,\n\t.read_ber\t\t\t= stv0900_read_ber,\n\t.read_signal_strength\t\t= stv0900_read_signal_strength,\n\t.read_snr\t\t\t= stv0900_read_snr,\n\t.read_ucblocks                  = stv0900_read_ucblocks,\n};\n\nstruct dvb_frontend *stv0900_attach(const struct stv0900_config *config,\n\t\t\t\t\tstruct i2c_adapter *i2c,\n\t\t\t\t\tint demod)\n{\n\tstruct stv0900_state *state = NULL;\n\tstruct stv0900_init_params init_params;\n\tenum fe_stv0900_error err_stv0900;\n\n\tstate = kzalloc(sizeof(struct stv0900_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\tstate->demod\t\t= demod;\n\tstate->config\t\t= config;\n\tstate->i2c_adap\t\t= i2c;\n\n\tmemcpy(&state->frontend.ops, &stv0900_ops,\n\t\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\tswitch (demod) {\n\tcase 0:\n\tcase 1:\n\t\tinit_params.dmd_ref_clk\t\t= config->xtal;\n\t\tinit_params.demod_mode\t\t= config->demod_mode;\n\t\tinit_params.rolloff\t\t= STV0900_35;\n\t\tinit_params.path1_ts_clock\t= config->path1_mode;\n\t\tinit_params.tun1_maddress\t= config->tun1_maddress;\n\t\tinit_params.tun1_iq_inv\t\t= STV0900_IQ_NORMAL;\n\t\tinit_params.tuner1_adc\t\t= config->tun1_adc;\n\t\tinit_params.tuner1_type\t\t= config->tun1_type;\n\t\tinit_params.path2_ts_clock\t= config->path2_mode;\n\t\tinit_params.ts_config\t\t= config->ts_config_regs;\n\t\tinit_params.tun2_maddress\t= config->tun2_maddress;\n\t\tinit_params.tuner2_adc\t\t= config->tun2_adc;\n\t\tinit_params.tuner2_type\t\t= config->tun2_type;\n\t\tinit_params.tun2_iq_inv\t\t= STV0900_IQ_SWAPPED;\n\n\t\terr_stv0900 = stv0900_init_internal(&state->frontend,\n\t\t\t\t\t\t\t&init_params);\n\n\t\tif (err_stv0900)\n\t\t\tgoto error;\n\n\t\tif (state->internal->chip_id >= 0x30)\n\t\t\tstate->frontend.ops.info.caps |= FE_CAN_MULTISTREAM;\n\n\t\tbreak;\n\tdefault:\n\t\tgoto error;\n\t\tbreak;\n\t}\n\n\tdprintk(\"%s: Attaching STV0900 demodulator(%d) \\n\", __func__, demod);\n\treturn &state->frontend;\n\nerror:\n\tdprintk(\"%s: Failed to attach STV0900 demodulator(%d) \\n\",\n\t\t__func__, demod);\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(stv0900_attach);\n\nMODULE_PARM_DESC(debug, \"Set debug\");\n\nMODULE_AUTHOR(\"Igor M. Liplianin\");\nMODULE_DESCRIPTION(\"ST STV0900 frontend\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}