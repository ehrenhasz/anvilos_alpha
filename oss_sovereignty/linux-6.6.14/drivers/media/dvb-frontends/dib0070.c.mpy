{
  "module_name": "dib0070.c",
  "hash_id": "978e5e8e1e25ac689797fcc518be81c581326522fbf8a168f38913365e519a8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/dib0070.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"dib0070.h\"\n#include \"dibx000_common.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"turn on debugging (default: 0)\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\n#define DIB0070_P1D  0x00\n#define DIB0070_P1F  0x01\n#define DIB0070_P1G  0x03\n#define DIB0070S_P1A 0x02\n\nstruct dib0070_state {\n\tstruct i2c_adapter *i2c;\n\tstruct dvb_frontend *fe;\n\tconst struct dib0070_config *cfg;\n\tu16 wbd_ff_offset;\n\tu8 revision;\n\n\tenum frontend_tune_state tune_state;\n\tu32 current_rf;\n\n\t \n\ts8 step;\n\tu16 adc_diff;\n\n\ts8 captrim;\n\ts8 fcaptrim;\n\tu16 lo4;\n\n\tconst struct dib0070_tuning *current_tune_table_index;\n\tconst struct dib0070_lna_match *lna_match;\n\n\tu8  wbd_gain_current;\n\tu16 wbd_offset_3_3[2];\n\n\t \n\tstruct i2c_msg msg[2];\n\tu8 i2c_write_buffer[3];\n\tu8 i2c_read_buffer[2];\n\tstruct mutex i2c_buffer_lock;\n};\n\nstatic u16 dib0070_read_reg(struct dib0070_state *state, u8 reg)\n{\n\tu16 ret;\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn 0;\n\t}\n\n\tstate->i2c_write_buffer[0] = reg;\n\n\tmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\n\tstate->msg[0].addr = state->cfg->i2c_address;\n\tstate->msg[0].flags = 0;\n\tstate->msg[0].buf = state->i2c_write_buffer;\n\tstate->msg[0].len = 1;\n\tstate->msg[1].addr = state->cfg->i2c_address;\n\tstate->msg[1].flags = I2C_M_RD;\n\tstate->msg[1].buf = state->i2c_read_buffer;\n\tstate->msg[1].len = 2;\n\n\tif (i2c_transfer(state->i2c, state->msg, 2) != 2) {\n\t\tpr_warn(\"DiB0070 I2C read failed\\n\");\n\t\tret = 0;\n\t} else\n\t\tret = (state->i2c_read_buffer[0] << 8)\n\t\t\t| state->i2c_read_buffer[1];\n\n\tmutex_unlock(&state->i2c_buffer_lock);\n\treturn ret;\n}\n\nstatic int dib0070_write_reg(struct dib0070_state *state, u8 reg, u16 val)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\tstate->i2c_write_buffer[0] = reg;\n\tstate->i2c_write_buffer[1] = val >> 8;\n\tstate->i2c_write_buffer[2] = val & 0xff;\n\n\tmemset(state->msg, 0, sizeof(struct i2c_msg));\n\tstate->msg[0].addr = state->cfg->i2c_address;\n\tstate->msg[0].flags = 0;\n\tstate->msg[0].buf = state->i2c_write_buffer;\n\tstate->msg[0].len = 3;\n\n\tif (i2c_transfer(state->i2c, state->msg, 1) != 1) {\n\t\tpr_warn(\"DiB0070 I2C write failed\\n\");\n\t\tret = -EREMOTEIO;\n\t} else\n\t\tret = 0;\n\n\tmutex_unlock(&state->i2c_buffer_lock);\n\treturn ret;\n}\n\n#define HARD_RESET(state) do { \\\n    state->cfg->sleep(state->fe, 0); \\\n    if (state->cfg->reset) { \\\n\tstate->cfg->reset(state->fe,1); msleep(10); \\\n\tstate->cfg->reset(state->fe,0); msleep(10); \\\n    } \\\n} while (0)\n\nstatic int dib0070_set_bandwidth(struct dvb_frontend *fe)\n\t{\n\tstruct dib0070_state *state = fe->tuner_priv;\n\tu16 tmp = dib0070_read_reg(state, 0x02) & 0x3fff;\n\n\tif (state->fe->dtv_property_cache.bandwidth_hz/1000 > 7000)\n\t\ttmp |= (0 << 14);\n\telse if (state->fe->dtv_property_cache.bandwidth_hz/1000 > 6000)\n\t\ttmp |= (1 << 14);\n\telse if (state->fe->dtv_property_cache.bandwidth_hz/1000 > 5000)\n\t\ttmp |= (2 << 14);\n\telse\n\t\ttmp |= (3 << 14);\n\n\tdib0070_write_reg(state, 0x02, tmp);\n\n\t \n\tif (state->fe->dtv_property_cache.delivery_system == SYS_ISDBT) {\n\t\tu16 value = dib0070_read_reg(state, 0x17);\n\n\t\tdib0070_write_reg(state, 0x17, value & 0xfffc);\n\t\ttmp = dib0070_read_reg(state, 0x01) & 0x01ff;\n\t\tdib0070_write_reg(state, 0x01, tmp | (60 << 9));\n\n\t\tdib0070_write_reg(state, 0x17, value);\n\t}\n\treturn 0;\n}\n\nstatic int dib0070_captrim(struct dib0070_state *state, enum frontend_tune_state *tune_state)\n{\n\tint8_t step_sign;\n\tu16 adc;\n\tint ret = 0;\n\n\tif (*tune_state == CT_TUNER_STEP_0) {\n\t\tdib0070_write_reg(state, 0x0f, 0xed10);\n\t\tdib0070_write_reg(state, 0x17,    0x0034);\n\n\t\tdib0070_write_reg(state, 0x18, 0x0032);\n\t\tstate->step = state->captrim = state->fcaptrim = 64;\n\t\tstate->adc_diff = 3000;\n\t\tret = 20;\n\n\t\t*tune_state = CT_TUNER_STEP_1;\n\t} else if (*tune_state == CT_TUNER_STEP_1) {\n\t\tstate->step /= 2;\n\t\tdib0070_write_reg(state, 0x14, state->lo4 | state->captrim);\n\t\tret = 15;\n\n\t\t*tune_state = CT_TUNER_STEP_2;\n\t} else if (*tune_state == CT_TUNER_STEP_2) {\n\n\t\tadc = dib0070_read_reg(state, 0x19);\n\n\t\tdprintk(\"CAPTRIM=%d; ADC = %hd (ADC) & %dmV\\n\", state->captrim,\n\t\t\tadc, (u32)adc * (u32)1800 / (u32)1024);\n\n\t\tif (adc >= 400) {\n\t\t\tadc -= 400;\n\t\t\tstep_sign = -1;\n\t\t} else {\n\t\t\tadc = 400 - adc;\n\t\t\tstep_sign = 1;\n\t\t}\n\n\t\tif (adc < state->adc_diff) {\n\t\t\tdprintk(\"CAPTRIM=%d is closer to target (%hd/%hd)\\n\",\n\t\t\t\tstate->captrim, adc, state->adc_diff);\n\t\t\tstate->adc_diff = adc;\n\t\t\tstate->fcaptrim = state->captrim;\n\t\t}\n\t\tstate->captrim += (step_sign * state->step);\n\n\t\tif (state->step >= 1)\n\t\t\t*tune_state = CT_TUNER_STEP_1;\n\t\telse\n\t\t\t*tune_state = CT_TUNER_STEP_3;\n\n\t} else if (*tune_state == CT_TUNER_STEP_3) {\n\t\tdib0070_write_reg(state, 0x14, state->lo4 | state->fcaptrim);\n\t\tdib0070_write_reg(state, 0x18, 0x07ff);\n\t\t*tune_state = CT_TUNER_STEP_4;\n\t}\n\n\treturn ret;\n}\n\nstatic int dib0070_set_ctrl_lo5(struct dvb_frontend *fe, u8 vco_bias_trim, u8 hf_div_trim, u8 cp_current, u8 third_order_filt)\n{\n\tstruct dib0070_state *state = fe->tuner_priv;\n\tu16 lo5 = (third_order_filt << 14) | (0 << 13) | (1 << 12) | (3 << 9) | (cp_current << 6) | (hf_div_trim << 3) | (vco_bias_trim << 0);\n\n\tdprintk(\"CTRL_LO5: 0x%x\\n\", lo5);\n\treturn dib0070_write_reg(state, 0x15, lo5);\n}\n\nvoid dib0070_ctrl_agc_filter(struct dvb_frontend *fe, u8 open)\n{\n\tstruct dib0070_state *state = fe->tuner_priv;\n\n\tif (open) {\n\t\tdib0070_write_reg(state, 0x1b, 0xff00);\n\t\tdib0070_write_reg(state, 0x1a, 0x0000);\n\t} else {\n\t\tdib0070_write_reg(state, 0x1b, 0x4112);\n\t\tif (state->cfg->vga_filter != 0) {\n\t\t\tdib0070_write_reg(state, 0x1a, state->cfg->vga_filter);\n\t\t\tdprintk(\"vga filter register is set to %x\\n\", state->cfg->vga_filter);\n\t\t} else\n\t\t\tdib0070_write_reg(state, 0x1a, 0x0009);\n\t}\n}\n\nEXPORT_SYMBOL(dib0070_ctrl_agc_filter);\nstruct dib0070_tuning {\n\tu32 max_freq;  \n\tu8 switch_trim;\n\tu8 vco_band;\n\tu8 hfdiv;\n\tu8 vco_multi;\n\tu8 presc;\n\tu8 wbdmux;\n\tu16 tuner_enable;\n};\n\nstruct dib0070_lna_match {\n\tu32 max_freq;  \n\tu8 lna_band;\n};\n\nstatic const struct dib0070_tuning dib0070s_tuning_table[] = {\n\t{     570000, 2, 1, 3, 6, 6, 2, 0x4000 | 0x0800 },  \n\t{     700000, 2, 0, 2, 4, 2, 2, 0x4000 | 0x0800 },\n\t{     863999, 2, 1, 2, 4, 2, 2, 0x4000 | 0x0800 },\n\t{    1500000, 0, 1, 1, 2, 2, 4, 0x2000 | 0x0400 },  \n\t{    1600000, 0, 1, 1, 2, 2, 4, 0x2000 | 0x0400 },\n\t{    2000000, 0, 1, 1, 2, 2, 4, 0x2000 | 0x0400 },\n\t{ 0xffffffff, 0, 0, 8, 1, 2, 1, 0x8000 | 0x1000 },  \n};\n\nstatic const struct dib0070_tuning dib0070_tuning_table[] = {\n\t{     115000, 1, 0, 7, 24, 2, 1, 0x8000 | 0x1000 },  \n\t{     179500, 1, 0, 3, 16, 2, 1, 0x8000 | 0x1000 },  \n\t{     189999, 1, 1, 3, 16, 2, 1, 0x8000 | 0x1000 },\n\t{     250000, 1, 0, 6, 12, 2, 1, 0x8000 | 0x1000 },\n\t{     569999, 2, 1, 5,  6, 2, 2, 0x4000 | 0x0800 },  \n\t{     699999, 2, 0, 1,  4, 2, 2, 0x4000 | 0x0800 },\n\t{     863999, 2, 1, 1,  4, 2, 2, 0x4000 | 0x0800 },\n\t{ 0xffffffff, 0, 1, 0,  2, 2, 4, 0x2000 | 0x0400 },  \n};\n\nstatic const struct dib0070_lna_match dib0070_lna_flip_chip[] = {\n\t{     180000, 0 },  \n\t{     188000, 1 },\n\t{     196400, 2 },\n\t{     250000, 3 },\n\t{     550000, 0 },  \n\t{     590000, 1 },\n\t{     666000, 3 },\n\t{     864000, 5 },\n\t{    1500000, 0 },  \n\t{    1600000, 1 },\n\t{    2000000, 3 },\n\t{ 0xffffffff, 7 },\n};\n\nstatic const struct dib0070_lna_match dib0070_lna[] = {\n\t{     180000, 0 },  \n\t{     188000, 1 },\n\t{     196400, 2 },\n\t{     250000, 3 },\n\t{     550000, 2 },  \n\t{     650000, 3 },\n\t{     750000, 5 },\n\t{     850000, 6 },\n\t{     864000, 7 },\n\t{    1500000, 0 },  \n\t{    1600000, 1 },\n\t{    2000000, 3 },\n\t{ 0xffffffff, 7 },\n};\n\n#define LPF\t100\nstatic int dib0070_tune_digital(struct dvb_frontend *fe)\n{\n\tstruct dib0070_state *state = fe->tuner_priv;\n\n\tconst struct dib0070_tuning *tune;\n\tconst struct dib0070_lna_match *lna_match;\n\n\tenum frontend_tune_state *tune_state = &state->tune_state;\n\tint ret = 10;  \n\n\tu8  band = (u8)BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency/1000);\n\tu32 freq = fe->dtv_property_cache.frequency/1000 + (band == BAND_VHF ? state->cfg->freq_offset_khz_vhf : state->cfg->freq_offset_khz_uhf);\n\n#ifdef CONFIG_SYS_ISDBT\n\tif (state->fe->dtv_property_cache.delivery_system == SYS_ISDBT && state->fe->dtv_property_cache.isdbt_sb_mode == 1)\n\t\t\tif (((state->fe->dtv_property_cache.isdbt_sb_segment_count % 2)\n\t\t\t&& (state->fe->dtv_property_cache.isdbt_sb_segment_idx == ((state->fe->dtv_property_cache.isdbt_sb_segment_count / 2) + 1)))\n\t\t\t|| (((state->fe->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)\n\t\t\t\t&& (state->fe->dtv_property_cache.isdbt_sb_segment_idx == (state->fe->dtv_property_cache.isdbt_sb_segment_count / 2)))\n\t\t\t|| (((state->fe->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)\n\t\t\t\t&& (state->fe->dtv_property_cache.isdbt_sb_segment_idx == ((state->fe->dtv_property_cache.isdbt_sb_segment_count / 2) + 1))))\n\t\t\t\tfreq += 850;\n#endif\n\tif (state->current_rf != freq) {\n\n\t\tswitch (state->revision) {\n\t\tcase DIB0070S_P1A:\n\t\ttune = dib0070s_tuning_table;\n\t\tlna_match = dib0070_lna;\n\t\tbreak;\n\t\tdefault:\n\t\ttune = dib0070_tuning_table;\n\t\tif (state->cfg->flip_chip)\n\t\t\tlna_match = dib0070_lna_flip_chip;\n\t\telse\n\t\t\tlna_match = dib0070_lna;\n\t\tbreak;\n\t\t}\n\t\twhile (freq > tune->max_freq)  \n\t\t\ttune++;\n\t\twhile (freq > lna_match->max_freq)  \n\t\t\tlna_match++;\n\n\t\tstate->current_tune_table_index = tune;\n\t\tstate->lna_match = lna_match;\n\t}\n\n\tif (*tune_state == CT_TUNER_START) {\n\t\tdprintk(\"Tuning for Band: %d (%d kHz)\\n\", band, freq);\n\t\tif (state->current_rf != freq) {\n\t\t\tu8 REFDIV;\n\t\t\tu32 FBDiv, Rest, FREF, VCOF_kHz;\n\t\t\tu8 Den;\n\n\t\t\tstate->current_rf = freq;\n\t\t\tstate->lo4 = (state->current_tune_table_index->vco_band << 11) | (state->current_tune_table_index->hfdiv << 7);\n\n\n\t\t\tdib0070_write_reg(state, 0x17, 0x30);\n\n\n\t\t\tVCOF_kHz = state->current_tune_table_index->vco_multi * freq * 2;\n\n\t\t\tswitch (band) {\n\t\t\tcase BAND_VHF:\n\t\t\t\tREFDIV = (u8) ((state->cfg->clock_khz + 9999) / 10000);\n\t\t\t\tbreak;\n\t\t\tcase BAND_FM:\n\t\t\t\tREFDIV = (u8) ((state->cfg->clock_khz) / 1000);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tREFDIV = (u8) (state->cfg->clock_khz  / 10000);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tFREF = state->cfg->clock_khz / REFDIV;\n\n\n\n\t\t\tswitch (state->revision) {\n\t\t\tcase DIB0070S_P1A:\n\t\t\t\tFBDiv = (VCOF_kHz / state->current_tune_table_index->presc / FREF);\n\t\t\t\tRest  = (VCOF_kHz / state->current_tune_table_index->presc) - FBDiv * FREF;\n\t\t\t\tbreak;\n\n\t\t\tcase DIB0070_P1G:\n\t\t\tcase DIB0070_P1F:\n\t\t\tdefault:\n\t\t\t\tFBDiv = (freq / (FREF / 2));\n\t\t\t\tRest  = 2 * freq - FBDiv * FREF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (Rest < LPF)\n\t\t\t\tRest = 0;\n\t\t\telse if (Rest < 2 * LPF)\n\t\t\t\tRest = 2 * LPF;\n\t\t\telse if (Rest > (FREF - LPF)) {\n\t\t\t\tRest = 0;\n\t\t\t\tFBDiv += 1;\n\t\t\t} else if (Rest > (FREF - 2 * LPF))\n\t\t\t\tRest = FREF - 2 * LPF;\n\t\t\tRest = (Rest * 6528) / (FREF / 10);\n\n\t\t\tDen = 1;\n\t\t\tif (Rest > 0) {\n\t\t\t\tstate->lo4 |= (1 << 14) | (1 << 12);\n\t\t\t\tDen = 255;\n\t\t\t}\n\n\n\t\t\tdib0070_write_reg(state, 0x11, (u16)FBDiv);\n\t\t\tdib0070_write_reg(state, 0x12, (Den << 8) | REFDIV);\n\t\t\tdib0070_write_reg(state, 0x13, (u16) Rest);\n\n\t\t\tif (state->revision == DIB0070S_P1A) {\n\n\t\t\t\tif (band == BAND_SBAND) {\n\t\t\t\t\tdib0070_set_ctrl_lo5(fe, 2, 4, 3, 0);\n\t\t\t\t\tdib0070_write_reg(state, 0x1d, 0xFFFF);\n\t\t\t\t} else\n\t\t\t\t\tdib0070_set_ctrl_lo5(fe, 5, 4, 3, 1);\n\t\t\t}\n\n\t\t\tdib0070_write_reg(state, 0x20,\n\t\t\t\t0x0040 | 0x0020 | 0x0010 | 0x0008 | 0x0002 | 0x0001 | state->current_tune_table_index->tuner_enable);\n\n\t\t\tdprintk(\"REFDIV: %u, FREF: %d\\n\", REFDIV, FREF);\n\t\t\tdprintk(\"FBDIV: %d, Rest: %d\\n\", FBDiv, Rest);\n\t\t\tdprintk(\"Num: %u, Den: %u, SD: %d\\n\", (u16)Rest, Den,\n\t\t\t\t(state->lo4 >> 12) & 0x1);\n\t\t\tdprintk(\"HFDIV code: %u\\n\",\n\t\t\t\tstate->current_tune_table_index->hfdiv);\n\t\t\tdprintk(\"VCO = %u\\n\",\n\t\t\t\tstate->current_tune_table_index->vco_band);\n\t\t\tdprintk(\"VCOF: ((%u*%d) << 1))\\n\",\n\t\t\t\tstate->current_tune_table_index->vco_multi,\n\t\t\t\tfreq);\n\n\t\t\t*tune_state = CT_TUNER_STEP_0;\n\t\t} else {  \n\t\t\tret = 50;  \n\t\t\t*tune_state = CT_TUNER_STEP_5;\n\t\t}\n\t} else if ((*tune_state > CT_TUNER_START) && (*tune_state < CT_TUNER_STEP_4)) {\n\n\t\tret = dib0070_captrim(state, tune_state);\n\n\t} else if (*tune_state == CT_TUNER_STEP_4) {\n\t\tconst struct dib0070_wbd_gain_cfg *tmp = state->cfg->wbd_gain;\n\t\tif (tmp != NULL) {\n\t\t\twhile (freq/1000 > tmp->freq)  \n\t\t\t\ttmp++;\n\t\t\tdib0070_write_reg(state, 0x0f,\n\t\t\t\t(0 << 15) | (1 << 14) | (3 << 12)\n\t\t\t\t| (tmp->wbd_gain_val << 9) | (0 << 8) | (1 << 7)\n\t\t\t\t| (state->current_tune_table_index->wbdmux << 0));\n\t\t\tstate->wbd_gain_current = tmp->wbd_gain_val;\n\t\t} else {\n\t\t\tdib0070_write_reg(state, 0x0f,\n\t\t\t\t\t  (0 << 15) | (1 << 14) | (3 << 12)\n\t\t\t\t\t  | (6 << 9) | (0 << 8) | (1 << 7)\n\t\t\t\t\t  | (state->current_tune_table_index->wbdmux << 0));\n\t\t\tstate->wbd_gain_current = 6;\n\t\t}\n\n\t\tdib0070_write_reg(state, 0x06, 0x3fff);\n\t\tdib0070_write_reg(state, 0x07,\n\t\t\t\t  (state->current_tune_table_index->switch_trim << 11) | (7 << 8) | (state->lna_match->lna_band << 3) | (3 << 0));\n\t\tdib0070_write_reg(state, 0x08, (state->lna_match->lna_band << 10) | (3 << 7) | (127));\n\t\tdib0070_write_reg(state, 0x0d, 0x0d80);\n\n\n\t\tdib0070_write_reg(state, 0x18,   0x07ff);\n\t\tdib0070_write_reg(state, 0x17, 0x0033);\n\n\n\t\t*tune_state = CT_TUNER_STEP_5;\n\t} else if (*tune_state == CT_TUNER_STEP_5) {\n\t\tdib0070_set_bandwidth(fe);\n\t\t*tune_state = CT_TUNER_STOP;\n\t} else {\n\t\tret = FE_CALLBACK_TIME_NEVER;  \n\t}\n\treturn ret;\n}\n\n\nstatic int dib0070_tune(struct dvb_frontend *fe)\n{\n\tstruct dib0070_state *state = fe->tuner_priv;\n\tuint32_t ret;\n\n\tstate->tune_state = CT_TUNER_START;\n\n\tdo {\n\t\tret = dib0070_tune_digital(fe);\n\t\tif (ret != FE_CALLBACK_TIME_NEVER)\n\t\t\tmsleep(ret/10);\n\t\telse\n\t\tbreak;\n\t} while (state->tune_state != CT_TUNER_STOP);\n\n\treturn 0;\n}\n\nstatic int dib0070_wakeup(struct dvb_frontend *fe)\n{\n\tstruct dib0070_state *state = fe->tuner_priv;\n\tif (state->cfg->sleep)\n\t\tstate->cfg->sleep(fe, 0);\n\treturn 0;\n}\n\nstatic int dib0070_sleep(struct dvb_frontend *fe)\n{\n\tstruct dib0070_state *state = fe->tuner_priv;\n\tif (state->cfg->sleep)\n\t\tstate->cfg->sleep(fe, 1);\n\treturn 0;\n}\n\nu8 dib0070_get_rf_output(struct dvb_frontend *fe)\n{\n\tstruct dib0070_state *state = fe->tuner_priv;\n\treturn (dib0070_read_reg(state, 0x07) >> 11) & 0x3;\n}\nEXPORT_SYMBOL(dib0070_get_rf_output);\n\nint dib0070_set_rf_output(struct dvb_frontend *fe, u8 no)\n{\n\tstruct dib0070_state *state = fe->tuner_priv;\n\tu16 rxrf2 = dib0070_read_reg(state, 0x07) & 0xfe7ff;\n\tif (no > 3)\n\t\tno = 3;\n\tif (no < 1)\n\t\tno = 1;\n\treturn dib0070_write_reg(state, 0x07, rxrf2 | (no << 11));\n}\nEXPORT_SYMBOL(dib0070_set_rf_output);\n\nstatic const u16 dib0070_p1f_defaults[] =\n\n{\n\t7, 0x02,\n\t\t0x0008,\n\t\t0x0000,\n\t\t0x0000,\n\t\t0x0000,\n\t\t0x0000,\n\t\t0x0002,\n\t\t0x0100,\n\n\t3, 0x0d,\n\t\t0x0d80,\n\t\t0x0001,\n\t\t0x0000,\n\n\t4, 0x11,\n\t\t0x0000,\n\t\t0x0103,\n\t\t0x0000,\n\t\t0x0000,\n\n\t3, 0x16,\n\t\t0x0004 | 0x0040,\n\t\t0x0030,\n\t\t0x07ff,\n\n\t6, 0x1b,\n\t\t0x4112,\n\t\t0xff00,\n\t\t0xc07f,\n\t\t0x0000,\n\t\t0x0180,\n\t\t0x4000 | 0x0800 | 0x0040 | 0x0020 | 0x0010 | 0x0008 | 0x0002 | 0x0001,\n\n\t0,\n};\n\nstatic u16 dib0070_read_wbd_offset(struct dib0070_state *state, u8 gain)\n{\n\tu16 tuner_en = dib0070_read_reg(state, 0x20);\n\tu16 offset;\n\n\tdib0070_write_reg(state, 0x18, 0x07ff);\n\tdib0070_write_reg(state, 0x20, 0x0800 | 0x4000 | 0x0040 | 0x0020 | 0x0010 | 0x0008 | 0x0002 | 0x0001);\n\tdib0070_write_reg(state, 0x0f, (1 << 14) | (2 << 12) | (gain << 9) | (1 << 8) | (1 << 7) | (0 << 0));\n\tmsleep(9);\n\toffset = dib0070_read_reg(state, 0x19);\n\tdib0070_write_reg(state, 0x20, tuner_en);\n\treturn offset;\n}\n\nstatic void dib0070_wbd_offset_calibration(struct dib0070_state *state)\n{\n\tu8 gain;\n\tfor (gain = 6; gain < 8; gain++) {\n\t\tstate->wbd_offset_3_3[gain - 6] = ((dib0070_read_wbd_offset(state, gain) * 8 * 18 / 33 + 1) / 2);\n\t\tdprintk(\"Gain: %d, WBDOffset (3.3V) = %hd\\n\", gain, state->wbd_offset_3_3[gain-6]);\n\t}\n}\n\nu16 dib0070_wbd_offset(struct dvb_frontend *fe)\n{\n\tstruct dib0070_state *state = fe->tuner_priv;\n\tconst struct dib0070_wbd_gain_cfg *tmp = state->cfg->wbd_gain;\n\tu32 freq = fe->dtv_property_cache.frequency/1000;\n\n\tif (tmp != NULL) {\n\t\twhile (freq/1000 > tmp->freq)  \n\t\t\ttmp++;\n\t\tstate->wbd_gain_current = tmp->wbd_gain_val;\n\t} else\n\t\tstate->wbd_gain_current = 6;\n\n\treturn state->wbd_offset_3_3[state->wbd_gain_current - 6];\n}\nEXPORT_SYMBOL(dib0070_wbd_offset);\n\n#define pgm_read_word(w) (*w)\nstatic int dib0070_reset(struct dvb_frontend *fe)\n{\n\tstruct dib0070_state *state = fe->tuner_priv;\n\tu16 l, r, *n;\n\n\tHARD_RESET(state);\n\n\n#ifndef FORCE_SBAND_TUNER\n\tif ((dib0070_read_reg(state, 0x22) >> 9) & 0x1)\n\t\tstate->revision = (dib0070_read_reg(state, 0x1f) >> 8) & 0xff;\n\telse\n#else\n#warning forcing SBAND\n#endif\n\tstate->revision = DIB0070S_P1A;\n\n\t \n\tdprintk(\"Revision: %x\\n\", state->revision);\n\n\tif (state->revision == DIB0070_P1D) {\n\t\tdprintk(\"Error: this driver is not to be used meant for P1D or earlier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tn = (u16 *) dib0070_p1f_defaults;\n\tl = pgm_read_word(n++);\n\twhile (l) {\n\t\tr = pgm_read_word(n++);\n\t\tdo {\n\t\t\tdib0070_write_reg(state, (u8)r, pgm_read_word(n++));\n\t\t\tr++;\n\t\t} while (--l);\n\t\tl = pgm_read_word(n++);\n\t}\n\n\tif (state->cfg->force_crystal_mode != 0)\n\t\tr = state->cfg->force_crystal_mode;\n\telse if (state->cfg->clock_khz >= 24000)\n\t\tr = 1;\n\telse\n\t\tr = 2;\n\n\n\tr |= state->cfg->osc_buffer_state << 3;\n\n\tdib0070_write_reg(state, 0x10, r);\n\tdib0070_write_reg(state, 0x1f, (1 << 8) | ((state->cfg->clock_pad_drive & 0xf) << 5));\n\n\tif (state->cfg->invert_iq) {\n\t\tr = dib0070_read_reg(state, 0x02) & 0xffdf;\n\t\tdib0070_write_reg(state, 0x02, r | (1 << 5));\n\t}\n\n\tif (state->revision == DIB0070S_P1A)\n\t\tdib0070_set_ctrl_lo5(fe, 2, 4, 3, 0);\n\telse\n\t\tdib0070_set_ctrl_lo5(fe, 5, 4, state->cfg->charge_pump,\n\t\t\t\t     state->cfg->enable_third_order_filter);\n\n\tdib0070_write_reg(state, 0x01, (54 << 9) | 0xc8);\n\n\tdib0070_wbd_offset_calibration(state);\n\n\treturn 0;\n}\n\nstatic int dib0070_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct dib0070_state *state = fe->tuner_priv;\n\n\t*frequency = 1000 * state->current_rf;\n\treturn 0;\n}\n\nstatic void dib0070_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic const struct dvb_tuner_ops dib0070_ops = {\n\t.info = {\n\t\t.name              = \"DiBcom DiB0070\",\n\t\t.frequency_min_hz  =  45 * MHz,\n\t\t.frequency_max_hz  = 860 * MHz,\n\t\t.frequency_step_hz =   1 * kHz,\n\t},\n\t.release       = dib0070_release,\n\n\t.init          = dib0070_wakeup,\n\t.sleep         = dib0070_sleep,\n\t.set_params    = dib0070_tune,\n\n\t.get_frequency = dib0070_get_frequency,\n\n};\n\nstruct dvb_frontend *dib0070_attach(struct dvb_frontend *fe, struct i2c_adapter *i2c, struct dib0070_config *cfg)\n{\n\tstruct dib0070_state *state = kzalloc(sizeof(struct dib0070_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tstate->cfg = cfg;\n\tstate->i2c = i2c;\n\tstate->fe  = fe;\n\tmutex_init(&state->i2c_buffer_lock);\n\tfe->tuner_priv = state;\n\n\tif (dib0070_reset(fe) != 0)\n\t\tgoto free_mem;\n\n\tpr_info(\"DiB0070: successfully identified\\n\");\n\tmemcpy(&fe->ops.tuner_ops, &dib0070_ops, sizeof(struct dvb_tuner_ops));\n\n\tfe->tuner_priv = state;\n\treturn fe;\n\nfree_mem:\n\tkfree(state);\n\tfe->tuner_priv = NULL;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(dib0070_attach);\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"Driver for the DiBcom 0070 base-band RF Tuner\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}