{
  "module_name": "isl6423.c",
  "hash_id": "bf8fe6a30c42c2e01ad0a22dc621fb7222f5910fdfb713b3d9235daf81224766",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/isl6423.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"isl6423.h\"\n\nstatic unsigned int verbose;\nmodule_param(verbose, int, 0644);\nMODULE_PARM_DESC(verbose, \"Set Verbosity level\");\n\n#define FE_ERROR\t\t\t\t0\n#define FE_NOTICE\t\t\t\t1\n#define FE_INFO\t\t\t\t\t2\n#define FE_DEBUG\t\t\t\t3\n#define FE_DEBUGREG\t\t\t\t4\n\n#define dprintk(__y, __z, format, arg...) do {\t\t\t\t\t\t\\\n\tif (__z) {\t\t\t\t\t\t\t\t\t\\\n\t\tif\t((verbose > FE_ERROR) && (verbose > __y))\t\t\t\\\n\t\t\tprintk(KERN_ERR \"%s: \" format \"\\n\", __func__ , ##arg);\t\t\\\n\t\telse if\t((verbose > FE_NOTICE) && (verbose > __y))\t\t\t\\\n\t\t\tprintk(KERN_NOTICE \"%s: \" format \"\\n\", __func__ , ##arg);\t\\\n\t\telse if ((verbose > FE_INFO) && (verbose > __y))\t\t\t\\\n\t\t\tprintk(KERN_INFO \"%s: \" format \"\\n\", __func__ , ##arg);\t\t\\\n\t\telse if ((verbose > FE_DEBUG) && (verbose > __y))\t\t\t\\\n\t\t\tprintk(KERN_DEBUG \"%s: \" format \"\\n\", __func__ , ##arg);\t\\\n\t} else {\t\t\t\t\t\t\t\t\t\\\n\t\tif (verbose > __y)\t\t\t\t\t\t\t\\\n\t\t\tprintk(format, ##arg);\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\nstruct isl6423_dev {\n\tconst struct isl6423_config\t*config;\n\tstruct i2c_adapter\t\t*i2c;\n\n\tu8 reg_3;\n\tu8 reg_4;\n\n\tunsigned int verbose;\n};\n\nstatic int isl6423_write(struct isl6423_dev *isl6423, u8 reg)\n{\n\tstruct i2c_adapter *i2c = isl6423->i2c;\n\tu8 addr\t\t\t= isl6423->config->addr;\n\tint err = 0;\n\n\tstruct i2c_msg msg = { .addr = addr, .flags = 0, .buf = &reg, .len = 1 };\n\n\tdprintk(FE_DEBUG, 1, \"write reg %02X\", reg);\n\terr = i2c_transfer(i2c, &msg, 1);\n\tif (err < 0)\n\t\tgoto exit;\n\treturn 0;\n\nexit:\n\tdprintk(FE_ERROR, 1, \"I/O error <%d>\", err);\n\treturn err;\n}\n\nstatic int isl6423_set_modulation(struct dvb_frontend *fe)\n{\n\tstruct isl6423_dev *isl6423\t\t= (struct isl6423_dev *) fe->sec_priv;\n\tconst struct isl6423_config *config\t= isl6423->config;\n\tint err = 0;\n\tu8 reg_2 = 0;\n\n\treg_2 = 0x01 << 5;\n\n\tif (config->mod_extern)\n\t\treg_2 |= (1 << 3);\n\telse\n\t\treg_2 |= (1 << 4);\n\n\terr = isl6423_write(isl6423, reg_2);\n\tif (err < 0)\n\t\tgoto exit;\n\treturn 0;\n\nexit:\n\tdprintk(FE_ERROR, 1, \"I/O error <%d>\", err);\n\treturn err;\n}\n\nstatic int isl6423_voltage_boost(struct dvb_frontend *fe, long arg)\n{\n\tstruct isl6423_dev *isl6423 = (struct isl6423_dev *) fe->sec_priv;\n\tu8 reg_3 = isl6423->reg_3;\n\tu8 reg_4 = isl6423->reg_4;\n\tint err = 0;\n\n\tif (arg) {\n\t\t \n\t\treg_4 |= (1 << 4);\n\t\treg_4 |= 0x1;\n\t\treg_3 |= (1 << 3);\n\t} else {\n\t\t \n\t\treg_4 |= (1 << 4);\n\t\treg_4 &= ~0x1;\n\t\treg_3 |= (1 << 3);\n\t}\n\terr = isl6423_write(isl6423, reg_3);\n\tif (err < 0)\n\t\tgoto exit;\n\n\terr = isl6423_write(isl6423, reg_4);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tisl6423->reg_3 = reg_3;\n\tisl6423->reg_4 = reg_4;\n\n\treturn 0;\nexit:\n\tdprintk(FE_ERROR, 1, \"I/O error <%d>\", err);\n\treturn err;\n}\n\n\nstatic int isl6423_set_voltage(struct dvb_frontend *fe,\n\t\t\t       enum fe_sec_voltage voltage)\n{\n\tstruct isl6423_dev *isl6423 = (struct isl6423_dev *) fe->sec_priv;\n\tu8 reg_3 = isl6423->reg_3;\n\tu8 reg_4 = isl6423->reg_4;\n\tint err = 0;\n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_OFF:\n\t\t \n\t\treg_4 &= ~(1 << 4);\n\t\tbreak;\n\n\tcase SEC_VOLTAGE_13:\n\t\t \n\t\treg_4 |= (1 << 4);\n\t\treg_4 &= ~0x3;\n\t\treg_3 |= (1 << 3);\n\t\tbreak;\n\n\tcase SEC_VOLTAGE_18:\n\t\t \n\t\treg_4 |= (1 << 4);\n\t\treg_4 |=  0x2;\n\t\treg_4 &= ~0x1;\n\t\treg_3 |= (1 << 3);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\terr = isl6423_write(isl6423, reg_3);\n\tif (err < 0)\n\t\tgoto exit;\n\n\terr = isl6423_write(isl6423, reg_4);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tisl6423->reg_3 = reg_3;\n\tisl6423->reg_4 = reg_4;\n\n\treturn 0;\nexit:\n\tdprintk(FE_ERROR, 1, \"I/O error <%d>\", err);\n\treturn err;\n}\n\nstatic int isl6423_set_current(struct dvb_frontend *fe)\n{\n\tstruct isl6423_dev *isl6423\t\t= (struct isl6423_dev *) fe->sec_priv;\n\tu8 reg_3 = isl6423->reg_3;\n\tconst struct isl6423_config *config\t= isl6423->config;\n\tint err = 0;\n\n\tswitch (config->current_max) {\n\tcase SEC_CURRENT_275m:\n\t\t \n\t\t \n\t\treg_3 &= ~0x3;\n\t\tbreak;\n\n\tcase SEC_CURRENT_515m:\n\t\t \n\t\t \n\t\treg_3 &= ~0x2;\n\t\treg_3 |=  0x1;\n\t\tbreak;\n\n\tcase SEC_CURRENT_635m:\n\t\t \n\t\t \n\t\treg_3 &= ~0x1;\n\t\treg_3 |=  0x2;\n\t\tbreak;\n\n\tcase SEC_CURRENT_800m:\n\t\t \n\t\t \n\t\treg_3 |= 0x3;\n\t\tbreak;\n\t}\n\n\terr = isl6423_write(isl6423, reg_3);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tswitch (config->curlim) {\n\tcase SEC_CURRENT_LIM_ON:\n\t\t \n\t\treg_3 &= ~0x10;\n\t\tbreak;\n\n\tcase SEC_CURRENT_LIM_OFF:\n\t\t \n\t\treg_3 |= 0x10;\n\t\tbreak;\n\t}\n\n\terr = isl6423_write(isl6423, reg_3);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tisl6423->reg_3 = reg_3;\n\n\treturn 0;\nexit:\n\tdprintk(FE_ERROR, 1, \"I/O error <%d>\", err);\n\treturn err;\n}\n\nstatic void isl6423_release(struct dvb_frontend *fe)\n{\n\tisl6423_set_voltage(fe, SEC_VOLTAGE_OFF);\n\n\tkfree(fe->sec_priv);\n\tfe->sec_priv = NULL;\n}\n\nstruct dvb_frontend *isl6423_attach(struct dvb_frontend *fe,\n\t\t\t\t    struct i2c_adapter *i2c,\n\t\t\t\t    const struct isl6423_config *config)\n{\n\tstruct isl6423_dev *isl6423;\n\n\tisl6423 = kzalloc(sizeof(struct isl6423_dev), GFP_KERNEL);\n\tif (!isl6423)\n\t\treturn NULL;\n\n\tisl6423->config\t= config;\n\tisl6423->i2c\t= i2c;\n\tfe->sec_priv\t= isl6423;\n\n\t \n\tisl6423->reg_3 = 0x02 << 5;\n\t \n\tisl6423->reg_4 = 0x03 << 5;\n\n\tif (isl6423_set_current(fe))\n\t\tgoto exit;\n\n\tif (isl6423_set_modulation(fe))\n\t\tgoto exit;\n\n\tfe->ops.release_sec\t\t= isl6423_release;\n\tfe->ops.set_voltage\t\t= isl6423_set_voltage;\n\tfe->ops.enable_high_lnb_voltage = isl6423_voltage_boost;\n\tisl6423->verbose\t\t= verbose;\n\n\treturn fe;\n\nexit:\n\tkfree(isl6423);\n\tfe->sec_priv = NULL;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(isl6423_attach);\n\nMODULE_DESCRIPTION(\"ISL6423 SEC\");\nMODULE_AUTHOR(\"Manu Abraham\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}