{
  "module_name": "rtl2832_sdr.c",
  "hash_id": "3df1c44b756300e3c23bc0966ac0e79f9137f95f1864cf19eea232ffd3bd94af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/rtl2832_sdr.c",
  "human_readable_source": "\n \n\n#include \"rtl2832_sdr.h\"\n#include \"dvb_usb.h\"\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include <linux/platform_device.h>\n#include <linux/jiffies.h>\n#include <linux/math64.h>\n#include <linux/regmap.h>\n\nstatic bool rtl2832_sdr_emulated_fmt;\nmodule_param_named(emulated_formats, rtl2832_sdr_emulated_fmt, bool, 0644);\nMODULE_PARM_DESC(emulated_formats, \"enable emulated formats (disappears in future)\");\n\n \n#define V4L2_SUBDEV_HAS_OP(sd, o, f) \\\n\t((sd) && (sd)->ops && (sd)->ops->o && (sd)->ops->o->f)\n\n#define MAX_BULK_BUFS            (10)\n#define BULK_BUFFER_SIZE         (128 * 512)\n\nstatic const struct v4l2_frequency_band bands_adc[] = {\n\t{\n\t\t.tuner = 0,\n\t\t.type = V4L2_TUNER_ADC,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =  300000,\n\t\t.rangehigh  =  300000,\n\t},\n\t{\n\t\t.tuner = 0,\n\t\t.type = V4L2_TUNER_ADC,\n\t\t.index = 1,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =  900001,\n\t\t.rangehigh  = 2800000,\n\t},\n\t{\n\t\t.tuner = 0,\n\t\t.type = V4L2_TUNER_ADC,\n\t\t.index = 2,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   = 3200000,\n\t\t.rangehigh  = 3200000,\n\t},\n};\n\nstatic const struct v4l2_frequency_band bands_fm[] = {\n\t{\n\t\t.tuner = 1,\n\t\t.type = V4L2_TUNER_RF,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =    50000000,\n\t\t.rangehigh  =  2000000000,\n\t},\n};\n\n \nstruct rtl2832_sdr_format {\n\tchar\t*name;\n\tu32\tpixelformat;\n\tu32\tbuffersize;\n};\n\nstatic struct rtl2832_sdr_format formats[] = {\n\t{\n\t\t.pixelformat\t= V4L2_SDR_FMT_CU8,\n\t\t.buffersize\t= BULK_BUFFER_SIZE,\n\t}, {\n\t\t.pixelformat\t= V4L2_SDR_FMT_CU16LE,\n\t\t.buffersize\t= BULK_BUFFER_SIZE * 2,\n\t},\n};\n\nstatic const unsigned int NUM_FORMATS = ARRAY_SIZE(formats);\n\n \nstruct rtl2832_sdr_frame_buf {\n\t \n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\nstruct rtl2832_sdr_dev {\n#define POWER_ON           0   \n#define URB_BUF            1   \n\tunsigned long flags;\n\n\tstruct platform_device *pdev;\n\tstruct regmap *regmap;\n\n\tstruct video_device vdev;\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_subdev *v4l2_subdev;\n\n\t \n\tstruct vb2_queue vb_queue;\n\tstruct list_head queued_bufs;\n\tspinlock_t queued_bufs_lock;  \n\tunsigned sequence;\t      \n\n\t \n\tstruct mutex v4l2_lock;       \n\tstruct mutex vb_queue_lock;   \n\n\t \n\tstruct usb_device *udev;  \n\n\tunsigned int vb_full;  \n\n\tstruct urb     *urb_list[MAX_BULK_BUFS];\n\tint            buf_num;\n\tunsigned long  buf_size;\n\tu8             *buf_list[MAX_BULK_BUFS];\n\tdma_addr_t     dma_addr[MAX_BULK_BUFS];\n\tint urbs_initialized;\n\tint urbs_submitted;\n\n\tunsigned int f_adc, f_tuner;\n\tu32 pixelformat;\n\tu32 buffersize;\n\tunsigned int num_formats;\n\n\t \n\tstruct v4l2_ctrl_handler hdl;\n\tstruct v4l2_ctrl *bandwidth_auto;\n\tstruct v4l2_ctrl *bandwidth;\n\n\t \n\tunsigned int sample;\n\tunsigned int sample_measured;\n\tunsigned long jiffies_next;\n};\n\n \nstatic struct rtl2832_sdr_frame_buf *rtl2832_sdr_get_next_fill_buf(\n\t\tstruct rtl2832_sdr_dev *dev)\n{\n\tunsigned long flags;\n\tstruct rtl2832_sdr_frame_buf *buf = NULL;\n\n\tspin_lock_irqsave(&dev->queued_bufs_lock, flags);\n\tif (list_empty(&dev->queued_bufs))\n\t\tgoto leave;\n\n\tbuf = list_entry(dev->queued_bufs.next,\n\t\t\tstruct rtl2832_sdr_frame_buf, list);\n\tlist_del(&buf->list);\nleave:\n\tspin_unlock_irqrestore(&dev->queued_bufs_lock, flags);\n\treturn buf;\n}\n\nstatic unsigned int rtl2832_sdr_convert_stream(struct rtl2832_sdr_dev *dev,\n\t\tvoid *dst, const u8 *src, unsigned int src_len)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tunsigned int dst_len;\n\n\tif (dev->pixelformat ==  V4L2_SDR_FMT_CU8) {\n\t\t \n\t\tmemcpy(dst, src, src_len);\n\t\tdst_len = src_len;\n\t} else if (dev->pixelformat == V4L2_SDR_FMT_CU16LE) {\n\t\t \n\t\tunsigned int i;\n\t\tu16 *u16dst = dst;\n\n\t\tfor (i = 0; i < src_len; i++)\n\t\t\t*u16dst++ = (src[i] << 8) | (src[i] >> 0);\n\t\tdst_len = 2 * src_len;\n\t} else {\n\t\tdst_len = 0;\n\t}\n\n\t \n\tif (unlikely(time_is_before_jiffies(dev->jiffies_next))) {\n\t\t#define MSECS 10000UL\n\t\tunsigned int msecs = jiffies_to_msecs(jiffies -\n\t\t\t\tdev->jiffies_next + msecs_to_jiffies(MSECS));\n\t\tunsigned int samples = dev->sample - dev->sample_measured;\n\n\t\tdev->jiffies_next = jiffies + msecs_to_jiffies(MSECS);\n\t\tdev->sample_measured = dev->sample;\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"slen=%u samples=%u msecs=%u sample rate=%lu\\n\",\n\t\t\tsrc_len, samples, msecs, samples * 1000UL / msecs);\n\t}\n\n\t \n\tdev->sample += src_len / 2;\n\n\treturn dst_len;\n}\n\n \nstatic void rtl2832_sdr_urb_complete(struct urb *urb)\n{\n\tstruct rtl2832_sdr_dev *dev = urb->context;\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct rtl2832_sdr_frame_buf *fbuf;\n\n\tdev_dbg_ratelimited(&pdev->dev, \"status=%d length=%d/%d errors=%d\\n\",\n\t\t\t    urb->status, urb->actual_length,\n\t\t\t    urb->transfer_buffer_length, urb->error_count);\n\n\tswitch (urb->status) {\n\tcase 0:              \n\tcase -ETIMEDOUT:     \n\t\tbreak;\n\tcase -ECONNRESET:    \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:             \n\t\tdev_err_ratelimited(&pdev->dev, \"urb failed=%d\\n\", urb->status);\n\t\tbreak;\n\t}\n\n\tif (likely(urb->actual_length > 0)) {\n\t\tvoid *ptr;\n\t\tunsigned int len;\n\t\t \n\t\tfbuf = rtl2832_sdr_get_next_fill_buf(dev);\n\t\tif (unlikely(fbuf == NULL)) {\n\t\t\tdev->vb_full++;\n\t\t\tdev_notice_ratelimited(&pdev->dev,\n\t\t\t\t\t       \"video buffer is full, %d packets dropped\\n\",\n\t\t\t\t\t       dev->vb_full);\n\t\t\tgoto skip;\n\t\t}\n\n\t\t \n\t\tptr = vb2_plane_vaddr(&fbuf->vb.vb2_buf, 0);\n\t\tlen = rtl2832_sdr_convert_stream(dev, ptr, urb->transfer_buffer,\n\t\t\t\turb->actual_length);\n\t\tvb2_set_plane_payload(&fbuf->vb.vb2_buf, 0, len);\n\t\tfbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tfbuf->vb.sequence = dev->sequence++;\n\t\tvb2_buffer_done(&fbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t}\nskip:\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic int rtl2832_sdr_kill_urbs(struct rtl2832_sdr_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tint i;\n\n\tfor (i = dev->urbs_submitted - 1; i >= 0; i--) {\n\t\tdev_dbg(&pdev->dev, \"kill urb=%d\\n\", i);\n\t\t \n\t\tusb_kill_urb(dev->urb_list[i]);\n\t}\n\tdev->urbs_submitted = 0;\n\n\treturn 0;\n}\n\nstatic int rtl2832_sdr_submit_urbs(struct rtl2832_sdr_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tint i, ret;\n\n\tfor (i = 0; i < dev->urbs_initialized; i++) {\n\t\tdev_dbg(&pdev->dev, \"submit urb=%d\\n\", i);\n\t\tret = usb_submit_urb(dev->urb_list[i], GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Could not submit urb no. %d - get them all back\\n\",\n\t\t\t\ti);\n\t\t\trtl2832_sdr_kill_urbs(dev);\n\t\t\treturn ret;\n\t\t}\n\t\tdev->urbs_submitted++;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl2832_sdr_free_stream_bufs(struct rtl2832_sdr_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\n\tif (test_bit(URB_BUF, &dev->flags)) {\n\t\twhile (dev->buf_num) {\n\t\t\tdev->buf_num--;\n\t\t\tdev_dbg(&pdev->dev, \"free buf=%d\\n\", dev->buf_num);\n\t\t\tusb_free_coherent(dev->udev, dev->buf_size,\n\t\t\t\t\t  dev->buf_list[dev->buf_num],\n\t\t\t\t\t  dev->dma_addr[dev->buf_num]);\n\t\t}\n\t}\n\tclear_bit(URB_BUF, &dev->flags);\n\n\treturn 0;\n}\n\nstatic int rtl2832_sdr_alloc_stream_bufs(struct rtl2832_sdr_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\n\tdev->buf_num = 0;\n\tdev->buf_size = BULK_BUFFER_SIZE;\n\n\tdev_dbg(&pdev->dev, \"all in all I will use %u bytes for streaming\\n\",\n\t\tMAX_BULK_BUFS * BULK_BUFFER_SIZE);\n\n\tfor (dev->buf_num = 0; dev->buf_num < MAX_BULK_BUFS; dev->buf_num++) {\n\t\tdev->buf_list[dev->buf_num] = usb_alloc_coherent(dev->udev,\n\t\t\t\tBULK_BUFFER_SIZE, GFP_KERNEL,\n\t\t\t\t&dev->dma_addr[dev->buf_num]);\n\t\tif (!dev->buf_list[dev->buf_num]) {\n\t\t\tdev_dbg(&pdev->dev, \"alloc buf=%d failed\\n\",\n\t\t\t\tdev->buf_num);\n\t\t\trtl2832_sdr_free_stream_bufs(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdev_dbg(&pdev->dev, \"alloc buf=%d %p (dma %llu)\\n\",\n\t\t\tdev->buf_num, dev->buf_list[dev->buf_num],\n\t\t\t(long long)dev->dma_addr[dev->buf_num]);\n\t\tset_bit(URB_BUF, &dev->flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl2832_sdr_free_urbs(struct rtl2832_sdr_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tint i;\n\n\trtl2832_sdr_kill_urbs(dev);\n\n\tfor (i = dev->urbs_initialized - 1; i >= 0; i--) {\n\t\tif (dev->urb_list[i]) {\n\t\t\tdev_dbg(&pdev->dev, \"free urb=%d\\n\", i);\n\t\t\t \n\t\t\tusb_free_urb(dev->urb_list[i]);\n\t\t}\n\t}\n\tdev->urbs_initialized = 0;\n\n\treturn 0;\n}\n\nstatic int rtl2832_sdr_alloc_urbs(struct rtl2832_sdr_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tint i, j;\n\n\t \n\tfor (i = 0; i < MAX_BULK_BUFS; i++) {\n\t\tdev_dbg(&pdev->dev, \"alloc urb=%d\\n\", i);\n\t\tdev->urb_list[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!dev->urb_list[i]) {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tusb_free_urb(dev->urb_list[j]);\n\t\t\t\tdev->urb_list[j] = NULL;\n\t\t\t}\n\t\t\tdev->urbs_initialized = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tusb_fill_bulk_urb(dev->urb_list[i],\n\t\t\t\tdev->udev,\n\t\t\t\tusb_rcvbulkpipe(dev->udev, 0x81),\n\t\t\t\tdev->buf_list[i],\n\t\t\t\tBULK_BUFFER_SIZE,\n\t\t\t\trtl2832_sdr_urb_complete, dev);\n\n\t\tdev->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\t\tdev->urb_list[i]->transfer_dma = dev->dma_addr[i];\n\t\tdev->urbs_initialized++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void rtl2832_sdr_cleanup_queued_bufs(struct rtl2832_sdr_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tunsigned long flags;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tspin_lock_irqsave(&dev->queued_bufs_lock, flags);\n\twhile (!list_empty(&dev->queued_bufs)) {\n\t\tstruct rtl2832_sdr_frame_buf *buf;\n\n\t\tbuf = list_entry(dev->queued_bufs.next,\n\t\t\t\tstruct rtl2832_sdr_frame_buf, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&dev->queued_bufs_lock, flags);\n}\n\nstatic int rtl2832_sdr_querycap(struct file *file, void *fh,\n\t\tstruct v4l2_capability *cap)\n{\n\tstruct rtl2832_sdr_dev *dev = video_drvdata(file);\n\tstruct platform_device *pdev = dev->pdev;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tstrscpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrscpy(cap->card, dev->vdev.name, sizeof(cap->card));\n\tusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\n\treturn 0;\n}\n\n \nstatic int rtl2832_sdr_queue_setup(struct vb2_queue *vq,\n\t\tunsigned int *nbuffers,\n\t\tunsigned int *nplanes, unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct rtl2832_sdr_dev *dev = vb2_get_drv_priv(vq);\n\tstruct platform_device *pdev = dev->pdev;\n\n\tdev_dbg(&pdev->dev, \"nbuffers=%d\\n\", *nbuffers);\n\n\t \n\tif (vq->num_buffers + *nbuffers < 8)\n\t\t*nbuffers = 8 - vq->num_buffers;\n\t*nplanes = 1;\n\tsizes[0] = PAGE_ALIGN(dev->buffersize);\n\tdev_dbg(&pdev->dev, \"nbuffers=%d sizes[0]=%d\\n\", *nbuffers, sizes[0]);\n\treturn 0;\n}\n\nstatic int rtl2832_sdr_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct rtl2832_sdr_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\n\t \n\tif (!dev->udev)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void rtl2832_sdr_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct rtl2832_sdr_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct rtl2832_sdr_frame_buf *buf =\n\t\t\tcontainer_of(vbuf, struct rtl2832_sdr_frame_buf, vb);\n\tunsigned long flags;\n\n\t \n\tif (!dev->udev) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&dev->queued_bufs_lock, flags);\n\tlist_add_tail(&buf->list, &dev->queued_bufs);\n\tspin_unlock_irqrestore(&dev->queued_bufs_lock, flags);\n}\n\nstatic int rtl2832_sdr_set_adc(struct rtl2832_sdr_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\n\tstruct dvb_frontend *fe = pdata->dvb_frontend;\n\tint ret;\n\tunsigned int f_sr, f_if;\n\tu8 buf[4], u8tmp1, u8tmp2;\n\tu64 u64tmp;\n\tu32 u32tmp;\n\n\tdev_dbg(&pdev->dev, \"f_adc=%u\\n\", dev->f_adc);\n\n\tif (!test_bit(POWER_ON, &dev->flags))\n\t\treturn 0;\n\n\tif (dev->f_adc == 0)\n\t\treturn 0;\n\n\tf_sr = dev->f_adc;\n\n\tret = regmap_bulk_write(dev->regmap, 0x13e, \"\\x00\\x00\", 2);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x115, \"\\x00\\x00\\x00\\x00\", 4);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (fe->ops.tuner_ops.get_if_frequency)\n\t\tret = fe->ops.tuner_ops.get_if_frequency(fe, &f_if);\n\telse\n\t\tret = -EINVAL;\n\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tu64tmp = f_if % pdata->clk;\n\tu64tmp *= 0x400000;\n\tu64tmp = div_u64(u64tmp, pdata->clk);\n\tu64tmp = -u64tmp;\n\tu32tmp = u64tmp & 0x3fffff;\n\n\tdev_dbg(&pdev->dev, \"f_if=%u if_ctl=%08x\\n\", f_if, u32tmp);\n\n\tbuf[0] = (u32tmp >> 16) & 0xff;\n\tbuf[1] = (u32tmp >>  8) & 0xff;\n\tbuf[2] = (u32tmp >>  0) & 0xff;\n\n\tret = regmap_bulk_write(dev->regmap, 0x119, buf, 3);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\t \n\tif (f_if) {\n\t\tu8tmp1 = 0x1a;  \n\t\tu8tmp2 = 0x8d;  \n\t} else {\n\t\tu8tmp1 = 0x1b;  \n\t\tu8tmp2 = 0xcd;  \n\t}\n\n\tret = regmap_write(dev->regmap, 0x1b1, u8tmp1);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x008, u8tmp2);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x006, 0x80);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tu32tmp = div_u64(pdata->clk * 0x400000ULL, f_sr * 4U);\n\tu32tmp <<= 2;\n\tbuf[0] = (u32tmp >> 24) & 0xff;\n\tbuf[1] = (u32tmp >> 16) & 0xff;\n\tbuf[2] = (u32tmp >>  8) & 0xff;\n\tbuf[3] = (u32tmp >>  0) & 0xff;\n\tret = regmap_bulk_write(dev->regmap, 0x19f, buf, 4);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_bulk_write(dev->regmap, 0x11c,\n\t\t\t\t\"\\xca\\xdc\\xd7\\xd8\\xe0\\xf2\\x0e\\x35\\x06\\x50\\x9c\\x0d\\x71\\x11\\x14\\x71\\x74\\x19\\x41\\xa5\",\n\t\t\t\t20);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x017, \"\\x11\\x10\", 2);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, 0x019, 0x05);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x01a,\n\t\t\t\t\"\\x1b\\x16\\x0d\\x06\\x01\\xff\", 6);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_bulk_write(dev->regmap, 0x192, \"\\x00\\xf0\\x0f\", 3);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, 0x061, 0x60);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tswitch (pdata->tuner) {\n\tcase RTL2832_SDR_TUNER_E4000:\n\t\tret = regmap_write(dev->regmap, 0x112, 0x5a);\n\t\tret = regmap_write(dev->regmap, 0x102, 0x40);\n\t\tret = regmap_write(dev->regmap, 0x103, 0x5a);\n\t\tret = regmap_write(dev->regmap, 0x1c7, 0x30);\n\t\tret = regmap_write(dev->regmap, 0x104, 0xd0);\n\t\tret = regmap_write(dev->regmap, 0x105, 0xbe);\n\t\tret = regmap_write(dev->regmap, 0x1c8, 0x18);\n\t\tret = regmap_write(dev->regmap, 0x106, 0x35);\n\t\tret = regmap_write(dev->regmap, 0x1c9, 0x21);\n\t\tret = regmap_write(dev->regmap, 0x1ca, 0x21);\n\t\tret = regmap_write(dev->regmap, 0x1cb, 0x00);\n\t\tret = regmap_write(dev->regmap, 0x107, 0x40);\n\t\tret = regmap_write(dev->regmap, 0x1cd, 0x10);\n\t\tret = regmap_write(dev->regmap, 0x1ce, 0x10);\n\t\tret = regmap_write(dev->regmap, 0x108, 0x80);\n\t\tret = regmap_write(dev->regmap, 0x109, 0x7f);\n\t\tret = regmap_write(dev->regmap, 0x10a, 0x80);\n\t\tret = regmap_write(dev->regmap, 0x10b, 0x7f);\n\t\tret = regmap_write(dev->regmap, 0x00e, 0xfc);\n\t\tret = regmap_write(dev->regmap, 0x00e, 0xfc);\n\t\tret = regmap_write(dev->regmap, 0x011, 0xd4);\n\t\tret = regmap_write(dev->regmap, 0x1e5, 0xf0);\n\t\tret = regmap_write(dev->regmap, 0x1d9, 0x00);\n\t\tret = regmap_write(dev->regmap, 0x1db, 0x00);\n\t\tret = regmap_write(dev->regmap, 0x1dd, 0x14);\n\t\tret = regmap_write(dev->regmap, 0x1de, 0xec);\n\t\tret = regmap_write(dev->regmap, 0x1d8, 0x0c);\n\t\tret = regmap_write(dev->regmap, 0x1e6, 0x02);\n\t\tret = regmap_write(dev->regmap, 0x1d7, 0x09);\n\t\tret = regmap_write(dev->regmap, 0x00d, 0x83);\n\t\tret = regmap_write(dev->regmap, 0x010, 0x49);\n\t\tret = regmap_write(dev->regmap, 0x00d, 0x87);\n\t\tret = regmap_write(dev->regmap, 0x00d, 0x85);\n\t\tret = regmap_write(dev->regmap, 0x013, 0x02);\n\t\tbreak;\n\tcase RTL2832_SDR_TUNER_FC0012:\n\tcase RTL2832_SDR_TUNER_FC0013:\n\t\tret = regmap_write(dev->regmap, 0x112, 0x5a);\n\t\tret = regmap_write(dev->regmap, 0x102, 0x40);\n\t\tret = regmap_write(dev->regmap, 0x103, 0x5a);\n\t\tret = regmap_write(dev->regmap, 0x1c7, 0x2c);\n\t\tret = regmap_write(dev->regmap, 0x104, 0xcc);\n\t\tret = regmap_write(dev->regmap, 0x105, 0xbe);\n\t\tret = regmap_write(dev->regmap, 0x1c8, 0x16);\n\t\tret = regmap_write(dev->regmap, 0x106, 0x35);\n\t\tret = regmap_write(dev->regmap, 0x1c9, 0x21);\n\t\tret = regmap_write(dev->regmap, 0x1ca, 0x21);\n\t\tret = regmap_write(dev->regmap, 0x1cb, 0x00);\n\t\tret = regmap_write(dev->regmap, 0x107, 0x40);\n\t\tret = regmap_write(dev->regmap, 0x1cd, 0x10);\n\t\tret = regmap_write(dev->regmap, 0x1ce, 0x10);\n\t\tret = regmap_write(dev->regmap, 0x108, 0x80);\n\t\tret = regmap_write(dev->regmap, 0x109, 0x7f);\n\t\tret = regmap_write(dev->regmap, 0x10a, 0x80);\n\t\tret = regmap_write(dev->regmap, 0x10b, 0x7f);\n\t\tret = regmap_write(dev->regmap, 0x00e, 0xfc);\n\t\tret = regmap_write(dev->regmap, 0x00e, 0xfc);\n\t\tret = regmap_bulk_write(dev->regmap, 0x011, \"\\xe9\\xbf\", 2);\n\t\tret = regmap_write(dev->regmap, 0x1e5, 0xf0);\n\t\tret = regmap_write(dev->regmap, 0x1d9, 0x00);\n\t\tret = regmap_write(dev->regmap, 0x1db, 0x00);\n\t\tret = regmap_write(dev->regmap, 0x1dd, 0x11);\n\t\tret = regmap_write(dev->regmap, 0x1de, 0xef);\n\t\tret = regmap_write(dev->regmap, 0x1d8, 0x0c);\n\t\tret = regmap_write(dev->regmap, 0x1e6, 0x02);\n\t\tret = regmap_write(dev->regmap, 0x1d7, 0x09);\n\t\tbreak;\n\tcase RTL2832_SDR_TUNER_R820T:\n\tcase RTL2832_SDR_TUNER_R828D:\n\t\tret = regmap_write(dev->regmap, 0x112, 0x5a);\n\t\tret = regmap_write(dev->regmap, 0x102, 0x40);\n\t\tret = regmap_write(dev->regmap, 0x115, 0x01);\n\t\tret = regmap_write(dev->regmap, 0x103, 0x80);\n\t\tret = regmap_write(dev->regmap, 0x1c7, 0x24);\n\t\tret = regmap_write(dev->regmap, 0x104, 0xcc);\n\t\tret = regmap_write(dev->regmap, 0x105, 0xbe);\n\t\tret = regmap_write(dev->regmap, 0x1c8, 0x14);\n\t\tret = regmap_write(dev->regmap, 0x106, 0x35);\n\t\tret = regmap_write(dev->regmap, 0x1c9, 0x21);\n\t\tret = regmap_write(dev->regmap, 0x1ca, 0x21);\n\t\tret = regmap_write(dev->regmap, 0x1cb, 0x00);\n\t\tret = regmap_write(dev->regmap, 0x107, 0x40);\n\t\tret = regmap_write(dev->regmap, 0x1cd, 0x10);\n\t\tret = regmap_write(dev->regmap, 0x1ce, 0x10);\n\t\tret = regmap_write(dev->regmap, 0x108, 0x80);\n\t\tret = regmap_write(dev->regmap, 0x109, 0x7f);\n\t\tret = regmap_write(dev->regmap, 0x10a, 0x80);\n\t\tret = regmap_write(dev->regmap, 0x10b, 0x7f);\n\t\tret = regmap_write(dev->regmap, 0x00e, 0xfc);\n\t\tret = regmap_write(dev->regmap, 0x00e, 0xfc);\n\t\tret = regmap_write(dev->regmap, 0x011, 0xf4);\n\t\tbreak;\n\tcase RTL2832_SDR_TUNER_FC2580:\n\t\tret = regmap_write(dev->regmap, 0x112, 0x39);\n\t\tret = regmap_write(dev->regmap, 0x102, 0x40);\n\t\tret = regmap_write(dev->regmap, 0x103, 0x5a);\n\t\tret = regmap_write(dev->regmap, 0x1c7, 0x2c);\n\t\tret = regmap_write(dev->regmap, 0x104, 0xcc);\n\t\tret = regmap_write(dev->regmap, 0x105, 0xbe);\n\t\tret = regmap_write(dev->regmap, 0x1c8, 0x16);\n\t\tret = regmap_write(dev->regmap, 0x106, 0x35);\n\t\tret = regmap_write(dev->regmap, 0x1c9, 0x21);\n\t\tret = regmap_write(dev->regmap, 0x1ca, 0x21);\n\t\tret = regmap_write(dev->regmap, 0x1cb, 0x00);\n\t\tret = regmap_write(dev->regmap, 0x107, 0x40);\n\t\tret = regmap_write(dev->regmap, 0x1cd, 0x10);\n\t\tret = regmap_write(dev->regmap, 0x1ce, 0x10);\n\t\tret = regmap_write(dev->regmap, 0x108, 0x80);\n\t\tret = regmap_write(dev->regmap, 0x109, 0x7f);\n\t\tret = regmap_write(dev->regmap, 0x10a, 0x9c);\n\t\tret = regmap_write(dev->regmap, 0x10b, 0x7f);\n\t\tret = regmap_write(dev->regmap, 0x00e, 0xfc);\n\t\tret = regmap_write(dev->regmap, 0x00e, 0xfc);\n\t\tret = regmap_bulk_write(dev->regmap, 0x011, \"\\xe9\\xf4\", 2);\n\t\tbreak;\n\tdefault:\n\t\tdev_notice(&pdev->dev, \"Unsupported tuner\\n\");\n\t}\n\n\t \n\tret = regmap_update_bits(dev->regmap, 0x101, 0x04, 0x04);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_update_bits(dev->regmap, 0x101, 0x04, 0x00);\n\tif (ret)\n\t\tgoto err;\nerr:\n\treturn ret;\n};\n\nstatic void rtl2832_sdr_unset_adc(struct rtl2832_sdr_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\t \n\tret = regmap_write(dev->regmap, 0x061, 0xe0);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(dev->regmap, 0x019, 0x20);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x017, \"\\x11\\x10\", 2);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_bulk_write(dev->regmap, 0x192, \"\\x00\\x0f\\xff\", 3);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x13e, \"\\x40\\x00\", 2);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0x115, \"\\x06\\x3f\\xce\\xcc\", 4);\n\tif (ret)\n\t\tgoto err;\nerr:\n\treturn;\n};\n\nstatic int rtl2832_sdr_set_tuner_freq(struct rtl2832_sdr_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\n\tstruct dvb_frontend *fe = pdata->dvb_frontend;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct v4l2_ctrl *bandwidth_auto;\n\tstruct v4l2_ctrl *bandwidth;\n\n\t \n\tif (dev->f_tuner == 0)\n\t\treturn 0;\n\n\t \n\tbandwidth_auto = v4l2_ctrl_find(&dev->hdl,\n\t\t\t\t\tV4L2_CID_RF_TUNER_BANDWIDTH_AUTO);\n\tbandwidth = v4l2_ctrl_find(&dev->hdl, V4L2_CID_RF_TUNER_BANDWIDTH);\n\tif (v4l2_ctrl_g_ctrl(bandwidth_auto)) {\n\t\tc->bandwidth_hz = dev->f_adc;\n\t\tv4l2_ctrl_s_ctrl(bandwidth, dev->f_adc);\n\t} else {\n\t\tc->bandwidth_hz = v4l2_ctrl_g_ctrl(bandwidth);\n\t}\n\n\tc->frequency = dev->f_tuner;\n\tc->delivery_system = SYS_DVBT;\n\n\tdev_dbg(&pdev->dev, \"frequency=%u bandwidth=%d\\n\",\n\t\tc->frequency, c->bandwidth_hz);\n\n\tif (!test_bit(POWER_ON, &dev->flags))\n\t\treturn 0;\n\n\tif (!V4L2_SUBDEV_HAS_OP(dev->v4l2_subdev, tuner, s_frequency)) {\n\t\tif (fe->ops.tuner_ops.set_params)\n\t\t\tfe->ops.tuner_ops.set_params(fe);\n\t}\n\n\treturn 0;\n};\n\nstatic int rtl2832_sdr_set_tuner(struct rtl2832_sdr_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\n\tstruct dvb_frontend *fe = pdata->dvb_frontend;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tif (fe->ops.tuner_ops.init)\n\t\tfe->ops.tuner_ops.init(fe);\n\n\treturn 0;\n};\n\nstatic void rtl2832_sdr_unset_tuner(struct rtl2832_sdr_dev *dev)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\n\tstruct dvb_frontend *fe = pdata->dvb_frontend;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tif (fe->ops.tuner_ops.sleep)\n\t\tfe->ops.tuner_ops.sleep(fe);\n\n\treturn;\n};\n\nstatic int rtl2832_sdr_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct rtl2832_sdr_dev *dev = vb2_get_drv_priv(vq);\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\n\tstruct dvb_usb_device *d = pdata->dvb_usb_device;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tif (!dev->udev)\n\t\treturn -ENODEV;\n\n\tif (mutex_lock_interruptible(&dev->v4l2_lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (d->props->power_ctrl)\n\t\td->props->power_ctrl(d, 1);\n\n\t \n\tif (d->props->frontend_ctrl)\n\t\td->props->frontend_ctrl(pdata->dvb_frontend, 1);\n\n\tset_bit(POWER_ON, &dev->flags);\n\n\t \n\tif (V4L2_SUBDEV_HAS_OP(dev->v4l2_subdev, core, s_power))\n\t\tret = v4l2_subdev_call(dev->v4l2_subdev, core, s_power, 1);\n\telse\n\t\tret = rtl2832_sdr_set_tuner(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl2832_sdr_set_tuner_freq(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl2832_sdr_set_adc(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl2832_sdr_alloc_stream_bufs(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl2832_sdr_alloc_urbs(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->sequence = 0;\n\n\tret = rtl2832_sdr_submit_urbs(dev);\n\tif (ret)\n\t\tgoto err;\n\nerr:\n\tmutex_unlock(&dev->v4l2_lock);\n\n\treturn ret;\n}\n\nstatic void rtl2832_sdr_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct rtl2832_sdr_dev *dev = vb2_get_drv_priv(vq);\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\n\tstruct dvb_usb_device *d = pdata->dvb_usb_device;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tmutex_lock(&dev->v4l2_lock);\n\n\trtl2832_sdr_kill_urbs(dev);\n\trtl2832_sdr_free_urbs(dev);\n\trtl2832_sdr_free_stream_bufs(dev);\n\trtl2832_sdr_cleanup_queued_bufs(dev);\n\trtl2832_sdr_unset_adc(dev);\n\n\t \n\tif (V4L2_SUBDEV_HAS_OP(dev->v4l2_subdev, core, s_power))\n\t\tv4l2_subdev_call(dev->v4l2_subdev, core, s_power, 0);\n\telse\n\t\trtl2832_sdr_unset_tuner(dev);\n\n\tclear_bit(POWER_ON, &dev->flags);\n\n\t \n\tif (d->props->frontend_ctrl)\n\t\td->props->frontend_ctrl(pdata->dvb_frontend, 0);\n\n\tif (d->props->power_ctrl)\n\t\td->props->power_ctrl(d, 0);\n\n\tmutex_unlock(&dev->v4l2_lock);\n}\n\nstatic const struct vb2_ops rtl2832_sdr_vb2_ops = {\n\t.queue_setup            = rtl2832_sdr_queue_setup,\n\t.buf_prepare            = rtl2832_sdr_buf_prepare,\n\t.buf_queue              = rtl2832_sdr_buf_queue,\n\t.start_streaming        = rtl2832_sdr_start_streaming,\n\t.stop_streaming         = rtl2832_sdr_stop_streaming,\n\t.wait_prepare           = vb2_ops_wait_prepare,\n\t.wait_finish            = vb2_ops_wait_finish,\n};\n\nstatic int rtl2832_sdr_g_tuner(struct file *file, void *priv,\n\t\tstruct v4l2_tuner *v)\n{\n\tstruct rtl2832_sdr_dev *dev = video_drvdata(file);\n\tstruct platform_device *pdev = dev->pdev;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"index=%d type=%d\\n\", v->index, v->type);\n\n\tif (v->index == 0) {\n\t\tstrscpy(v->name, \"ADC: Realtek RTL2832\", sizeof(v->name));\n\t\tv->type = V4L2_TUNER_ADC;\n\t\tv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tv->rangelow =   300000;\n\t\tv->rangehigh = 3200000;\n\t\tret = 0;\n\t} else if (v->index == 1 &&\n\t\t   V4L2_SUBDEV_HAS_OP(dev->v4l2_subdev, tuner, g_tuner)) {\n\t\tret = v4l2_subdev_call(dev->v4l2_subdev, tuner, g_tuner, v);\n\t} else if (v->index == 1) {\n\t\tstrscpy(v->name, \"RF: <unknown>\", sizeof(v->name));\n\t\tv->type = V4L2_TUNER_RF;\n\t\tv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\n\t\tv->rangelow =    50000000;\n\t\tv->rangehigh = 2000000000;\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int rtl2832_sdr_s_tuner(struct file *file, void *priv,\n\t\tconst struct v4l2_tuner *v)\n{\n\tstruct rtl2832_sdr_dev *dev = video_drvdata(file);\n\tstruct platform_device *pdev = dev->pdev;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tif (v->index == 0) {\n\t\tret = 0;\n\t} else if (v->index == 1 &&\n\t\t   V4L2_SUBDEV_HAS_OP(dev->v4l2_subdev, tuner, s_tuner)) {\n\t\tret = v4l2_subdev_call(dev->v4l2_subdev, tuner, s_tuner, v);\n\t} else if (v->index == 1) {\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int rtl2832_sdr_enum_freq_bands(struct file *file, void *priv,\n\t\tstruct v4l2_frequency_band *band)\n{\n\tstruct rtl2832_sdr_dev *dev = video_drvdata(file);\n\tstruct platform_device *pdev = dev->pdev;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"tuner=%d type=%d index=%d\\n\",\n\t\tband->tuner, band->type, band->index);\n\n\tif (band->tuner == 0) {\n\t\tif (band->index >= ARRAY_SIZE(bands_adc))\n\t\t\treturn -EINVAL;\n\n\t\t*band = bands_adc[band->index];\n\t\tret = 0;\n\t} else if (band->tuner == 1 &&\n\t\t   V4L2_SUBDEV_HAS_OP(dev->v4l2_subdev, tuner, enum_freq_bands)) {\n\t\tret = v4l2_subdev_call(dev->v4l2_subdev, tuner, enum_freq_bands, band);\n\t} else if (band->tuner == 1) {\n\t\tif (band->index >= ARRAY_SIZE(bands_fm))\n\t\t\treturn -EINVAL;\n\n\t\t*band = bands_fm[band->index];\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int rtl2832_sdr_g_frequency(struct file *file, void *priv,\n\t\tstruct v4l2_frequency *f)\n{\n\tstruct rtl2832_sdr_dev *dev = video_drvdata(file);\n\tstruct platform_device *pdev = dev->pdev;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"tuner=%d type=%d\\n\", f->tuner, f->type);\n\n\tif (f->tuner == 0) {\n\t\tf->frequency = dev->f_adc;\n\t\tf->type = V4L2_TUNER_ADC;\n\t\tret = 0;\n\t} else if (f->tuner == 1 &&\n\t\t   V4L2_SUBDEV_HAS_OP(dev->v4l2_subdev, tuner, g_frequency)) {\n\t\tf->type = V4L2_TUNER_RF;\n\t\tret = v4l2_subdev_call(dev->v4l2_subdev, tuner, g_frequency, f);\n\t} else if (f->tuner == 1) {\n\t\tf->frequency = dev->f_tuner;\n\t\tf->type = V4L2_TUNER_RF;\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int rtl2832_sdr_s_frequency(struct file *file, void *priv,\n\t\tconst struct v4l2_frequency *f)\n{\n\tstruct rtl2832_sdr_dev *dev = video_drvdata(file);\n\tstruct platform_device *pdev = dev->pdev;\n\tint ret, band;\n\n\tdev_dbg(&pdev->dev, \"tuner=%d type=%d frequency=%u\\n\",\n\t\tf->tuner, f->type, f->frequency);\n\n\t \n\t#define BAND_ADC_0 ((bands_adc[0].rangehigh + bands_adc[1].rangelow) / 2)\n\t#define BAND_ADC_1 ((bands_adc[1].rangehigh + bands_adc[2].rangelow) / 2)\n\n\tif (f->tuner == 0 && f->type == V4L2_TUNER_ADC) {\n\t\tif (f->frequency < BAND_ADC_0)\n\t\t\tband = 0;\n\t\telse if (f->frequency < BAND_ADC_1)\n\t\t\tband = 1;\n\t\telse\n\t\t\tband = 2;\n\n\t\tdev->f_adc = clamp_t(unsigned int, f->frequency,\n\t\t\t\t     bands_adc[band].rangelow,\n\t\t\t\t     bands_adc[band].rangehigh);\n\n\t\tdev_dbg(&pdev->dev, \"ADC frequency=%u Hz\\n\", dev->f_adc);\n\t\tret = rtl2832_sdr_set_adc(dev);\n\t} else if (f->tuner == 1 &&\n\t\t   V4L2_SUBDEV_HAS_OP(dev->v4l2_subdev, tuner, s_frequency)) {\n\t\tret = v4l2_subdev_call(dev->v4l2_subdev, tuner, s_frequency, f);\n\t} else if (f->tuner == 1) {\n\t\tdev->f_tuner = clamp_t(unsigned int, f->frequency,\n\t\t\t\tbands_fm[0].rangelow,\n\t\t\t\tbands_fm[0].rangehigh);\n\t\tdev_dbg(&pdev->dev, \"RF frequency=%u Hz\\n\", f->frequency);\n\n\t\tret = rtl2832_sdr_set_tuner_freq(dev);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int rtl2832_sdr_enum_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_fmtdesc *f)\n{\n\tstruct rtl2832_sdr_dev *dev = video_drvdata(file);\n\tstruct platform_device *pdev = dev->pdev;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tif (f->index >= dev->num_formats)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = formats[f->index].pixelformat;\n\n\treturn 0;\n}\n\nstatic int rtl2832_sdr_g_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_format *f)\n{\n\tstruct rtl2832_sdr_dev *dev = video_drvdata(file);\n\tstruct platform_device *pdev = dev->pdev;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tf->fmt.sdr.pixelformat = dev->pixelformat;\n\tf->fmt.sdr.buffersize = dev->buffersize;\n\n\treturn 0;\n}\n\nstatic int rtl2832_sdr_s_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_format *f)\n{\n\tstruct rtl2832_sdr_dev *dev = video_drvdata(file);\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct vb2_queue *q = &dev->vb_queue;\n\tint i;\n\n\tdev_dbg(&pdev->dev, \"pixelformat fourcc %4.4s\\n\",\n\t\t(char *)&f->fmt.sdr.pixelformat);\n\n\tif (vb2_is_busy(q))\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < dev->num_formats; i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\n\t\t\tdev->pixelformat = formats[i].pixelformat;\n\t\t\tdev->buffersize = formats[i].buffersize;\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev->pixelformat = formats[0].pixelformat;\n\tdev->buffersize = formats[0].buffersize;\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\n\treturn 0;\n}\n\nstatic int rtl2832_sdr_try_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_format *f)\n{\n\tstruct rtl2832_sdr_dev *dev = video_drvdata(file);\n\tstruct platform_device *pdev = dev->pdev;\n\tint i;\n\n\tdev_dbg(&pdev->dev, \"pixelformat fourcc %4.4s\\n\",\n\t\t(char *)&f->fmt.sdr.pixelformat);\n\n\tfor (i = 0; i < dev->num_formats; i++) {\n\t\tif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\n\t\t\tf->fmt.sdr.buffersize = formats[i].buffersize;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tf->fmt.sdr.pixelformat = formats[0].pixelformat;\n\tf->fmt.sdr.buffersize = formats[0].buffersize;\n\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops rtl2832_sdr_ioctl_ops = {\n\t.vidioc_querycap          = rtl2832_sdr_querycap,\n\n\t.vidioc_enum_fmt_sdr_cap  = rtl2832_sdr_enum_fmt_sdr_cap,\n\t.vidioc_g_fmt_sdr_cap     = rtl2832_sdr_g_fmt_sdr_cap,\n\t.vidioc_s_fmt_sdr_cap     = rtl2832_sdr_s_fmt_sdr_cap,\n\t.vidioc_try_fmt_sdr_cap   = rtl2832_sdr_try_fmt_sdr_cap,\n\n\t.vidioc_reqbufs           = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs       = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf       = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf          = vb2_ioctl_querybuf,\n\t.vidioc_qbuf              = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf             = vb2_ioctl_dqbuf,\n\n\t.vidioc_streamon          = vb2_ioctl_streamon,\n\t.vidioc_streamoff         = vb2_ioctl_streamoff,\n\n\t.vidioc_g_tuner           = rtl2832_sdr_g_tuner,\n\t.vidioc_s_tuner           = rtl2832_sdr_s_tuner,\n\n\t.vidioc_enum_freq_bands   = rtl2832_sdr_enum_freq_bands,\n\t.vidioc_g_frequency       = rtl2832_sdr_g_frequency,\n\t.vidioc_s_frequency       = rtl2832_sdr_s_frequency,\n\n\t.vidioc_subscribe_event   = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_log_status        = v4l2_ctrl_log_status,\n};\n\nstatic const struct v4l2_file_operations rtl2832_sdr_fops = {\n\t.owner                    = THIS_MODULE,\n\t.open                     = v4l2_fh_open,\n\t.release                  = vb2_fop_release,\n\t.read                     = vb2_fop_read,\n\t.poll                     = vb2_fop_poll,\n\t.mmap                     = vb2_fop_mmap,\n\t.unlocked_ioctl           = video_ioctl2,\n};\n\nstatic struct video_device rtl2832_sdr_template = {\n\t.name                     = \"Realtek RTL2832 SDR\",\n\t.release                  = video_device_release_empty,\n\t.fops                     = &rtl2832_sdr_fops,\n\t.ioctl_ops                = &rtl2832_sdr_ioctl_ops,\n\t.device_caps\t\t  = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_STREAMING |\n\t\t\t\t    V4L2_CAP_READWRITE | V4L2_CAP_TUNER,\n};\n\nstatic int rtl2832_sdr_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct rtl2832_sdr_dev *dev =\n\t\t\tcontainer_of(ctrl->handler, struct rtl2832_sdr_dev,\n\t\t\t\t\thdl);\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\n\tstruct dvb_frontend *fe = pdata->dvb_frontend;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"id=%d name=%s val=%d min=%lld max=%lld step=%lld\\n\",\n\t\tctrl->id, ctrl->name, ctrl->val, ctrl->minimum, ctrl->maximum,\n\t\tctrl->step);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\n\tcase V4L2_CID_RF_TUNER_BANDWIDTH:\n\t\t \n\t\tif (dev->bandwidth_auto->val) {\n\t\t\t \n\t\t\ts32 val = dev->f_adc + div_u64(dev->bandwidth->step, 2);\n\t\t\tu32 offset;\n\n\t\t\tval = clamp_t(s32, val, dev->bandwidth->minimum,\n\t\t\t\t      dev->bandwidth->maximum);\n\t\t\toffset = val - dev->bandwidth->minimum;\n\t\t\toffset = dev->bandwidth->step *\n\t\t\t\tdiv_u64(offset, dev->bandwidth->step);\n\t\t\tdev->bandwidth->val = dev->bandwidth->minimum + offset;\n\t\t}\n\t\tc->bandwidth_hz = dev->bandwidth->val;\n\n\t\tif (!test_bit(POWER_ON, &dev->flags))\n\t\t\treturn 0;\n\n\t\tif (fe->ops.tuner_ops.set_params)\n\t\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_ctrl_ops rtl2832_sdr_ctrl_ops = {\n\t.s_ctrl = rtl2832_sdr_s_ctrl,\n};\n\nstatic void rtl2832_sdr_video_release(struct v4l2_device *v)\n{\n\tstruct rtl2832_sdr_dev *dev =\n\t\t\tcontainer_of(v, struct rtl2832_sdr_dev, v4l2_dev);\n\tstruct platform_device *pdev = dev->pdev;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tv4l2_ctrl_handler_free(&dev->hdl);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tkfree(dev);\n}\n\n \nstatic int rtl2832_sdr_probe(struct platform_device *pdev)\n{\n\tstruct rtl2832_sdr_dev *dev;\n\tstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\n\tconst struct v4l2_ctrl_ops *ops = &rtl2832_sdr_ctrl_ops;\n\tstruct v4l2_subdev *subdev;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"Cannot proceed without platform data\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tif (!pdev->dev.parent->driver) {\n\t\tdev_dbg(&pdev->dev, \"No parent device\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\t \n\tif (!try_module_get(pdev->dev.parent->driver->owner)) {\n\t\tdev_err(&pdev->dev, \"Refcount fail\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_module_put;\n\t}\n\n\t \n\tsubdev = pdata->v4l2_subdev;\n\tdev->v4l2_subdev = pdata->v4l2_subdev;\n\tdev->pdev = pdev;\n\tdev->regmap = pdata->regmap;\n\tdev->udev = pdata->dvb_usb_device->udev;\n\tdev->f_adc = bands_adc[0].rangelow;\n\tdev->f_tuner = bands_fm[0].rangelow;\n\tdev->pixelformat = formats[0].pixelformat;\n\tdev->buffersize = formats[0].buffersize;\n\tdev->num_formats = NUM_FORMATS;\n\tif (!rtl2832_sdr_emulated_fmt)\n\t\tdev->num_formats -= 1;\n\n\tmutex_init(&dev->v4l2_lock);\n\tmutex_init(&dev->vb_queue_lock);\n\tspin_lock_init(&dev->queued_bufs_lock);\n\tINIT_LIST_HEAD(&dev->queued_bufs);\n\n\t \n\tdev->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\n\tdev->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\tdev->vb_queue.drv_priv = dev;\n\tdev->vb_queue.buf_struct_size = sizeof(struct rtl2832_sdr_frame_buf);\n\tdev->vb_queue.ops = &rtl2832_sdr_vb2_ops;\n\tdev->vb_queue.mem_ops = &vb2_vmalloc_memops;\n\tdev->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tret = vb2_queue_init(&dev->vb_queue);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not initialize vb2 queue\\n\");\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tswitch (pdata->tuner) {\n\tcase RTL2832_SDR_TUNER_E4000:\n\t\tv4l2_ctrl_handler_init(&dev->hdl, 9);\n\t\tif (subdev)\n\t\t\tv4l2_ctrl_add_handler(&dev->hdl, subdev->ctrl_handler,\n\t\t\t\t\t      NULL, true);\n\t\tbreak;\n\tcase RTL2832_SDR_TUNER_R820T:\n\tcase RTL2832_SDR_TUNER_R828D:\n\t\tv4l2_ctrl_handler_init(&dev->hdl, 2);\n\t\tdev->bandwidth_auto = v4l2_ctrl_new_std(&dev->hdl, ops,\n\t\t\t\t\t\t\tV4L2_CID_RF_TUNER_BANDWIDTH_AUTO,\n\t\t\t\t\t\t\t0, 1, 1, 1);\n\t\tdev->bandwidth = v4l2_ctrl_new_std(&dev->hdl, ops,\n\t\t\t\t\t\t   V4L2_CID_RF_TUNER_BANDWIDTH,\n\t\t\t\t\t\t   0, 8000000, 100000, 0);\n\t\tv4l2_ctrl_auto_cluster(2, &dev->bandwidth_auto, 0, false);\n\t\tbreak;\n\tcase RTL2832_SDR_TUNER_FC0012:\n\tcase RTL2832_SDR_TUNER_FC0013:\n\t\tv4l2_ctrl_handler_init(&dev->hdl, 2);\n\t\tdev->bandwidth_auto = v4l2_ctrl_new_std(&dev->hdl, ops,\n\t\t\t\t\t\t\tV4L2_CID_RF_TUNER_BANDWIDTH_AUTO,\n\t\t\t\t\t\t\t0, 1, 1, 1);\n\t\tdev->bandwidth = v4l2_ctrl_new_std(&dev->hdl, ops,\n\t\t\t\t\t\t   V4L2_CID_RF_TUNER_BANDWIDTH,\n\t\t\t\t\t\t   6000000, 8000000, 1000000,\n\t\t\t\t\t\t   6000000);\n\t\tv4l2_ctrl_auto_cluster(2, &dev->bandwidth_auto, 0, false);\n\t\tbreak;\n\tcase RTL2832_SDR_TUNER_FC2580:\n\t\tv4l2_ctrl_handler_init(&dev->hdl, 2);\n\t\tif (subdev)\n\t\t\tv4l2_ctrl_add_handler(&dev->hdl, subdev->ctrl_handler,\n\t\t\t\t\t      NULL, true);\n\t\tbreak;\n\tdefault:\n\t\tv4l2_ctrl_handler_init(&dev->hdl, 0);\n\t\tdev_err(&pdev->dev, \"Unsupported tuner\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_v4l2_ctrl_handler_free;\n\t}\n\tif (dev->hdl.error) {\n\t\tret = dev->hdl.error;\n\t\tdev_err(&pdev->dev, \"Could not initialize controls\\n\");\n\t\tgoto err_v4l2_ctrl_handler_free;\n\t}\n\n\t \n\tdev->vdev = rtl2832_sdr_template;\n\tdev->vdev.queue = &dev->vb_queue;\n\tdev->vdev.queue->lock = &dev->vb_queue_lock;\n\tvideo_set_drvdata(&dev->vdev, dev);\n\n\t \n\tdev->v4l2_dev.release = rtl2832_sdr_video_release;\n\tret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register v4l2-device %d\\n\", ret);\n\t\tgoto err_v4l2_ctrl_handler_free;\n\t}\n\n\tdev->v4l2_dev.ctrl_handler = &dev->hdl;\n\tdev->vdev.v4l2_dev = &dev->v4l2_dev;\n\tdev->vdev.lock = &dev->v4l2_lock;\n\tdev->vdev.vfl_dir = VFL_DIR_RX;\n\n\tret = video_register_device(&dev->vdev, VFL_TYPE_SDR, -1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register as video device %d\\n\",\n\t\t\tret);\n\t\tgoto err_v4l2_device_unregister;\n\t}\n\tdev_info(&pdev->dev, \"Registered as %s\\n\",\n\t\t video_device_node_name(&dev->vdev));\n\tdev_info(&pdev->dev, \"Realtek RTL2832 SDR attached\\n\");\n\tdev_notice(&pdev->dev,\n\t\t   \"SDR API is still slightly experimental and functionality changes may follow\\n\");\n\tplatform_set_drvdata(pdev, dev);\n\treturn 0;\nerr_v4l2_device_unregister:\n\tv4l2_device_unregister(&dev->v4l2_dev);\nerr_v4l2_ctrl_handler_free:\n\tv4l2_ctrl_handler_free(&dev->hdl);\nerr_kfree:\n\tkfree(dev);\nerr_module_put:\n\tmodule_put(pdev->dev.parent->driver->owner);\nerr:\n\treturn ret;\n}\n\nstatic void rtl2832_sdr_remove(struct platform_device *pdev)\n{\n\tstruct rtl2832_sdr_dev *dev = platform_get_drvdata(pdev);\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tmutex_lock(&dev->vb_queue_lock);\n\tmutex_lock(&dev->v4l2_lock);\n\t \n\tdev->udev = NULL;\n\tv4l2_device_disconnect(&dev->v4l2_dev);\n\tvideo_unregister_device(&dev->vdev);\n\tmutex_unlock(&dev->v4l2_lock);\n\tmutex_unlock(&dev->vb_queue_lock);\n\tv4l2_device_put(&dev->v4l2_dev);\n\tmodule_put(pdev->dev.parent->driver->owner);\n}\n\nstatic struct platform_driver rtl2832_sdr_driver = {\n\t.driver = {\n\t\t.name   = \"rtl2832_sdr\",\n\t},\n\t.probe          = rtl2832_sdr_probe,\n\t.remove_new     = rtl2832_sdr_remove,\n};\nmodule_platform_driver(rtl2832_sdr_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Realtek RTL2832 SDR driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}