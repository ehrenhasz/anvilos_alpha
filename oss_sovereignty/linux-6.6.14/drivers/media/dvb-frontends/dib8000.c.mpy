{
  "module_name": "dib8000.c",
  "hash_id": "a6971626453848f54f4f9147a3b53d4c09407880a1c769d57726050b638cc5a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/dib8000.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <asm/div64.h>\n\n#include <linux/int_log.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"dib8000.h\"\n\n#define LAYER_ALL -1\n#define LAYER_A   1\n#define LAYER_B   2\n#define LAYER_C   3\n\n#define MAX_NUMBER_OF_FRONTENDS 6\n \n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"turn on debugging (default: 0)\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\nstruct i2c_device {\n\tstruct i2c_adapter *adap;\n\tu8 addr;\n\tu8 *i2c_write_buffer;\n\tu8 *i2c_read_buffer;\n\tstruct mutex *i2c_buffer_lock;\n};\n\nenum param_loop_step {\n\tLOOP_TUNE_1,\n\tLOOP_TUNE_2\n};\n\nenum dib8000_autosearch_step {\n\tAS_START = 0,\n\tAS_SEARCHING_FFT,\n\tAS_SEARCHING_GUARD,\n\tAS_DONE = 100,\n};\n\nenum timeout_mode {\n\tSYMBOL_DEPENDENT_OFF = 0,\n\tSYMBOL_DEPENDENT_ON,\n};\n\nstruct dib8000_state {\n\tstruct dib8000_config cfg;\n\n\tstruct i2c_device i2c;\n\n\tstruct dibx000_i2c_master i2c_master;\n\n\tu16 wbd_ref;\n\n\tu8 current_band;\n\tu32 current_bandwidth;\n\tstruct dibx000_agc_config *current_agc;\n\tu32 timf;\n\tu32 timf_default;\n\n\tu8 div_force_off:1;\n\tu8 div_state:1;\n\tu16 div_sync_wait;\n\n\tu8 agc_state;\n\tu8 differential_constellation;\n\tu8 diversity_onoff;\n\n\ts16 ber_monitored_layer;\n\tu16 gpio_dir;\n\tu16 gpio_val;\n\n\tu16 revision;\n\tu8 isdbt_cfg_loaded;\n\tenum frontend_tune_state tune_state;\n\ts32 status;\n\n\tstruct dvb_frontend *fe[MAX_NUMBER_OF_FRONTENDS];\n\n\t \n\tstruct i2c_msg msg[2];\n\tu8 i2c_write_buffer[4];\n\tu8 i2c_read_buffer[2];\n\tstruct mutex i2c_buffer_lock;\n\tu8 input_mode_mpeg;\n\n\tu16 tuner_enable;\n\tstruct i2c_adapter dib8096p_tuner_adap;\n\tu16 current_demod_bw;\n\n\tu16 seg_mask;\n\tu16 seg_diff_mask;\n\tu16 mode;\n\tu8 layer_b_nb_seg;\n\tu8 layer_c_nb_seg;\n\n\tu8 channel_parameters_set;\n\tu16 autosearch_state;\n\tu16 found_nfft;\n\tu16 found_guard;\n\tu8 subchannel;\n\tu8 symbol_duration;\n\tunsigned long timeout;\n\tu8 longest_intlv_layer;\n\tu16 output_mode;\n\n\t \n\ts64 init_ucb;\n\tunsigned long per_jiffies_stats;\n\tunsigned long ber_jiffies_stats;\n\tunsigned long ber_jiffies_stats_layer[3];\n\n#ifdef DIB8000_AGC_FREEZE\n\tu16 agc1_max;\n\tu16 agc1_min;\n\tu16 agc2_max;\n\tu16 agc2_min;\n#endif\n};\n\nenum dib8000_power_mode {\n\tDIB8000_POWER_ALL = 0,\n\tDIB8000_POWER_INTERFACE_ONLY,\n};\n\nstatic u16 dib8000_i2c_read16(struct i2c_device *i2c, u16 reg)\n{\n\tu16 ret;\n\tstruct i2c_msg msg[2] = {\n\t\t{.addr = i2c->addr >> 1, .flags = 0, .len = 2},\n\t\t{.addr = i2c->addr >> 1, .flags = I2C_M_RD, .len = 2},\n\t};\n\n\tif (mutex_lock_interruptible(i2c->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn 0;\n\t}\n\n\tmsg[0].buf    = i2c->i2c_write_buffer;\n\tmsg[0].buf[0] = reg >> 8;\n\tmsg[0].buf[1] = reg & 0xff;\n\tmsg[1].buf    = i2c->i2c_read_buffer;\n\n\tif (i2c_transfer(i2c->adap, msg, 2) != 2)\n\t\tdprintk(\"i2c read error on %d\\n\", reg);\n\n\tret = (msg[1].buf[0] << 8) | msg[1].buf[1];\n\tmutex_unlock(i2c->i2c_buffer_lock);\n\treturn ret;\n}\n\nstatic u16 __dib8000_read_word(struct dib8000_state *state, u16 reg)\n{\n\tu16 ret;\n\n\tstate->i2c_write_buffer[0] = reg >> 8;\n\tstate->i2c_write_buffer[1] = reg & 0xff;\n\n\tmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\n\tstate->msg[0].addr = state->i2c.addr >> 1;\n\tstate->msg[0].flags = 0;\n\tstate->msg[0].buf = state->i2c_write_buffer;\n\tstate->msg[0].len = 2;\n\tstate->msg[1].addr = state->i2c.addr >> 1;\n\tstate->msg[1].flags = I2C_M_RD;\n\tstate->msg[1].buf = state->i2c_read_buffer;\n\tstate->msg[1].len = 2;\n\n\tif (i2c_transfer(state->i2c.adap, state->msg, 2) != 2)\n\t\tdprintk(\"i2c read error on %d\\n\", reg);\n\n\tret = (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];\n\n\treturn ret;\n}\n\nstatic u16 dib8000_read_word(struct dib8000_state *state, u16 reg)\n{\n\tu16 ret;\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn 0;\n\t}\n\n\tret = __dib8000_read_word(state, reg);\n\n\tmutex_unlock(&state->i2c_buffer_lock);\n\n\treturn ret;\n}\n\nstatic u32 dib8000_read32(struct dib8000_state *state, u16 reg)\n{\n\tu16 rw[2];\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn 0;\n\t}\n\n\trw[0] = __dib8000_read_word(state, reg + 0);\n\trw[1] = __dib8000_read_word(state, reg + 1);\n\n\tmutex_unlock(&state->i2c_buffer_lock);\n\n\treturn ((rw[0] << 16) | (rw[1]));\n}\n\nstatic int dib8000_i2c_write16(struct i2c_device *i2c, u16 reg, u16 val)\n{\n\tstruct i2c_msg msg = {.addr = i2c->addr >> 1, .flags = 0, .len = 4};\n\tint ret = 0;\n\n\tif (mutex_lock_interruptible(i2c->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmsg.buf    = i2c->i2c_write_buffer;\n\tmsg.buf[0] = (reg >> 8) & 0xff;\n\tmsg.buf[1] = reg & 0xff;\n\tmsg.buf[2] = (val >> 8) & 0xff;\n\tmsg.buf[3] = val & 0xff;\n\n\tret = i2c_transfer(i2c->adap, &msg, 1) != 1 ? -EREMOTEIO : 0;\n\tmutex_unlock(i2c->i2c_buffer_lock);\n\n\treturn ret;\n}\n\nstatic int dib8000_write_word(struct dib8000_state *state, u16 reg, u16 val)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstate->i2c_write_buffer[0] = (reg >> 8) & 0xff;\n\tstate->i2c_write_buffer[1] = reg & 0xff;\n\tstate->i2c_write_buffer[2] = (val >> 8) & 0xff;\n\tstate->i2c_write_buffer[3] = val & 0xff;\n\n\tmemset(&state->msg[0], 0, sizeof(struct i2c_msg));\n\tstate->msg[0].addr = state->i2c.addr >> 1;\n\tstate->msg[0].flags = 0;\n\tstate->msg[0].buf = state->i2c_write_buffer;\n\tstate->msg[0].len = 4;\n\n\tret = (i2c_transfer(state->i2c.adap, state->msg, 1) != 1 ?\n\t\t\t-EREMOTEIO : 0);\n\tmutex_unlock(&state->i2c_buffer_lock);\n\n\treturn ret;\n}\n\nstatic const s16 coeff_2k_sb_1seg_dqpsk[8] = {\n\t(769 << 5) | 0x0a, (745 << 5) | 0x03, (595 << 5) | 0x0d, (769 << 5) | 0x0a, (920 << 5) | 0x09, (784 << 5) | 0x02, (519 << 5) | 0x0c,\n\t\t(920 << 5) | 0x09\n};\n\nstatic const s16 coeff_2k_sb_1seg[8] = {\n\t(692 << 5) | 0x0b, (683 << 5) | 0x01, (519 << 5) | 0x09, (692 << 5) | 0x0b, 0 | 0x1f, 0 | 0x1f, 0 | 0x1f, 0 | 0x1f\n};\n\nstatic const s16 coeff_2k_sb_3seg_0dqpsk_1dqpsk[8] = {\n\t(832 << 5) | 0x10, (912 << 5) | 0x05, (900 << 5) | 0x12, (832 << 5) | 0x10, (-931 << 5) | 0x0f, (912 << 5) | 0x04, (807 << 5) | 0x11,\n\t\t(-931 << 5) | 0x0f\n};\n\nstatic const s16 coeff_2k_sb_3seg_0dqpsk[8] = {\n\t(622 << 5) | 0x0c, (941 << 5) | 0x04, (796 << 5) | 0x10, (622 << 5) | 0x0c, (982 << 5) | 0x0c, (519 << 5) | 0x02, (572 << 5) | 0x0e,\n\t\t(982 << 5) | 0x0c\n};\n\nstatic const s16 coeff_2k_sb_3seg_1dqpsk[8] = {\n\t(699 << 5) | 0x14, (607 << 5) | 0x04, (944 << 5) | 0x13, (699 << 5) | 0x14, (-720 << 5) | 0x0d, (640 << 5) | 0x03, (866 << 5) | 0x12,\n\t\t(-720 << 5) | 0x0d\n};\n\nstatic const s16 coeff_2k_sb_3seg[8] = {\n\t(664 << 5) | 0x0c, (925 << 5) | 0x03, (937 << 5) | 0x10, (664 << 5) | 0x0c, (-610 << 5) | 0x0a, (697 << 5) | 0x01, (836 << 5) | 0x0e,\n\t\t(-610 << 5) | 0x0a\n};\n\nstatic const s16 coeff_4k_sb_1seg_dqpsk[8] = {\n\t(-955 << 5) | 0x0e, (687 << 5) | 0x04, (818 << 5) | 0x10, (-955 << 5) | 0x0e, (-922 << 5) | 0x0d, (750 << 5) | 0x03, (665 << 5) | 0x0f,\n\t\t(-922 << 5) | 0x0d\n};\n\nstatic const s16 coeff_4k_sb_1seg[8] = {\n\t(638 << 5) | 0x0d, (683 << 5) | 0x02, (638 << 5) | 0x0d, (638 << 5) | 0x0d, (-655 << 5) | 0x0a, (517 << 5) | 0x00, (698 << 5) | 0x0d,\n\t\t(-655 << 5) | 0x0a\n};\n\nstatic const s16 coeff_4k_sb_3seg_0dqpsk_1dqpsk[8] = {\n\t(-707 << 5) | 0x14, (910 << 5) | 0x06, (889 << 5) | 0x16, (-707 << 5) | 0x14, (-958 << 5) | 0x13, (993 << 5) | 0x05, (523 << 5) | 0x14,\n\t\t(-958 << 5) | 0x13\n};\n\nstatic const s16 coeff_4k_sb_3seg_0dqpsk[8] = {\n\t(-723 << 5) | 0x13, (910 << 5) | 0x05, (777 << 5) | 0x14, (-723 << 5) | 0x13, (-568 << 5) | 0x0f, (547 << 5) | 0x03, (696 << 5) | 0x12,\n\t\t(-568 << 5) | 0x0f\n};\n\nstatic const s16 coeff_4k_sb_3seg_1dqpsk[8] = {\n\t(-940 << 5) | 0x15, (607 << 5) | 0x05, (915 << 5) | 0x16, (-940 << 5) | 0x15, (-848 << 5) | 0x13, (683 << 5) | 0x04, (543 << 5) | 0x14,\n\t\t(-848 << 5) | 0x13\n};\n\nstatic const s16 coeff_4k_sb_3seg[8] = {\n\t(612 << 5) | 0x12, (910 << 5) | 0x04, (864 << 5) | 0x14, (612 << 5) | 0x12, (-869 << 5) | 0x13, (683 << 5) | 0x02, (869 << 5) | 0x12,\n\t\t(-869 << 5) | 0x13\n};\n\nstatic const s16 coeff_8k_sb_1seg_dqpsk[8] = {\n\t(-835 << 5) | 0x12, (684 << 5) | 0x05, (735 << 5) | 0x14, (-835 << 5) | 0x12, (-598 << 5) | 0x10, (781 << 5) | 0x04, (739 << 5) | 0x13,\n\t\t(-598 << 5) | 0x10\n};\n\nstatic const s16 coeff_8k_sb_1seg[8] = {\n\t(673 << 5) | 0x0f, (683 << 5) | 0x03, (808 << 5) | 0x12, (673 << 5) | 0x0f, (585 << 5) | 0x0f, (512 << 5) | 0x01, (780 << 5) | 0x0f,\n\t\t(585 << 5) | 0x0f\n};\n\nstatic const s16 coeff_8k_sb_3seg_0dqpsk_1dqpsk[8] = {\n\t(863 << 5) | 0x17, (930 << 5) | 0x07, (878 << 5) | 0x19, (863 << 5) | 0x17, (0 << 5) | 0x14, (521 << 5) | 0x05, (980 << 5) | 0x18,\n\t\t(0 << 5) | 0x14\n};\n\nstatic const s16 coeff_8k_sb_3seg_0dqpsk[8] = {\n\t(-924 << 5) | 0x17, (910 << 5) | 0x06, (774 << 5) | 0x17, (-924 << 5) | 0x17, (-877 << 5) | 0x15, (565 << 5) | 0x04, (553 << 5) | 0x15,\n\t\t(-877 << 5) | 0x15\n};\n\nstatic const s16 coeff_8k_sb_3seg_1dqpsk[8] = {\n\t(-921 << 5) | 0x19, (607 << 5) | 0x06, (881 << 5) | 0x19, (-921 << 5) | 0x19, (-921 << 5) | 0x14, (713 << 5) | 0x05, (1018 << 5) | 0x18,\n\t\t(-921 << 5) | 0x14\n};\n\nstatic const s16 coeff_8k_sb_3seg[8] = {\n\t(514 << 5) | 0x14, (910 << 5) | 0x05, (861 << 5) | 0x17, (514 << 5) | 0x14, (690 << 5) | 0x14, (683 << 5) | 0x03, (662 << 5) | 0x15,\n\t\t(690 << 5) | 0x14\n};\n\nstatic const s16 ana_fe_coeff_3seg[24] = {\n\t81, 80, 78, 74, 68, 61, 54, 45, 37, 28, 19, 11, 4, 1022, 1017, 1013, 1010, 1008, 1008, 1008, 1008, 1010, 1014, 1017\n};\n\nstatic const s16 ana_fe_coeff_1seg[24] = {\n\t249, 226, 164, 82, 5, 981, 970, 988, 1018, 20, 31, 26, 8, 1012, 1000, 1018, 1012, 8, 15, 14, 9, 3, 1017, 1003\n};\n\nstatic const s16 ana_fe_coeff_13seg[24] = {\n\t396, 305, 105, -51, -77, -12, 41, 31, -11, -30, -11, 14, 15, -2, -13, -7, 5, 8, 1, -6, -7, -3, 0, 1\n};\n\nstatic u16 fft_to_mode(struct dib8000_state *state)\n{\n\tu16 mode;\n\tswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\t\tmode = 1;\n\t\tbreak;\n\tcase TRANSMISSION_MODE_4K:\n\t\tmode = 2;\n\t\tbreak;\n\tdefault:\n\tcase TRANSMISSION_MODE_AUTO:\n\tcase TRANSMISSION_MODE_8K:\n\t\tmode = 3;\n\t\tbreak;\n\t}\n\treturn mode;\n}\n\nstatic void dib8000_set_acquisition_mode(struct dib8000_state *state)\n{\n\tu16 nud = dib8000_read_word(state, 298);\n\tnud |= (1 << 3) | (1 << 0);\n\tdprintk(\"acquisition mode activated\\n\");\n\tdib8000_write_word(state, 298, nud);\n}\nstatic int dib8000_set_output_mode(struct dvb_frontend *fe, int mode)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu16 outreg, fifo_threshold, smo_mode, sram = 0x0205;\t \n\n\tstate->output_mode = mode;\n\toutreg = 0;\n\tfifo_threshold = 1792;\n\tsmo_mode = (dib8000_read_word(state, 299) & 0x0050) | (1 << 1);\n\n\tdprintk(\"-I-\tSetting output mode for demod %p to %d\\n\",\n\t\t\t&state->fe[0], mode);\n\n\tswitch (mode) {\n\tcase OUTMODE_MPEG2_PAR_GATED_CLK:\t\n\t\toutreg = (1 << 10);\t \n\t\tbreak;\n\tcase OUTMODE_MPEG2_PAR_CONT_CLK:\t\n\t\toutreg = (1 << 10) | (1 << 6);\t \n\t\tbreak;\n\tcase OUTMODE_MPEG2_SERIAL:\t\n\t\toutreg = (1 << 10) | (2 << 6) | (0 << 1);\t \n\t\tbreak;\n\tcase OUTMODE_DIVERSITY:\n\t\tif (state->cfg.hostbus_diversity) {\n\t\t\toutreg = (1 << 10) | (4 << 6);\t \n\t\t\tsram &= 0xfdff;\n\t\t} else\n\t\t\tsram |= 0x0c00;\n\t\tbreak;\n\tcase OUTMODE_MPEG2_FIFO:\t\n\t\tsmo_mode |= (3 << 1);\n\t\tfifo_threshold = 512;\n\t\toutreg = (1 << 10) | (5 << 6);\n\t\tbreak;\n\tcase OUTMODE_HIGH_Z:\t\n\t\toutreg = 0;\n\t\tbreak;\n\n\tcase OUTMODE_ANALOG_ADC:\n\t\toutreg = (1 << 10) | (3 << 6);\n\t\tdib8000_set_acquisition_mode(state);\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"Unhandled output_mode passed to be set for demod %p\\n\",\n\t\t\t\t&state->fe[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state->cfg.output_mpeg2_in_188_bytes)\n\t\tsmo_mode |= (1 << 5);\n\n\tdib8000_write_word(state, 299, smo_mode);\n\tdib8000_write_word(state, 300, fifo_threshold);\t \n\tdib8000_write_word(state, 1286, outreg);\n\tdib8000_write_word(state, 1291, sram);\n\n\treturn 0;\n}\n\nstatic int dib8000_set_diversity_in(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu16 tmp, sync_wait = dib8000_read_word(state, 273) & 0xfff0;\n\n\tdprintk(\"set diversity input to %i\\n\", onoff);\n\tif (!state->differential_constellation) {\n\t\tdib8000_write_word(state, 272, 1 << 9);\t\n\t\tdib8000_write_word(state, 273, sync_wait | (1 << 2) | 2);\t\n\t} else {\n\t\tdib8000_write_word(state, 272, 0);\t\n\t\tdib8000_write_word(state, 273, sync_wait);\t\n\t}\n\tstate->diversity_onoff = onoff;\n\n\tswitch (onoff) {\n\tcase 0:\t\t \n\t\tdib8000_write_word(state, 270, 1);\n\t\tdib8000_write_word(state, 271, 0);\n\t\tbreak;\n\tcase 1:\t\t \n\t\tdib8000_write_word(state, 270, 6);\n\t\tdib8000_write_word(state, 271, 6);\n\t\tbreak;\n\tcase 2:\t\t \n\t\tdib8000_write_word(state, 270, 0);\n\t\tdib8000_write_word(state, 271, 1);\n\t\tbreak;\n\t}\n\n\tif (state->revision == 0x8002) {\n\t\ttmp = dib8000_read_word(state, 903);\n\t\tdib8000_write_word(state, 903, tmp & ~(1 << 3));\n\t\tmsleep(30);\n\t\tdib8000_write_word(state, 903, tmp | (1 << 3));\n\t}\n\treturn 0;\n}\n\nstatic void dib8000_set_power_mode(struct dib8000_state *state, enum dib8000_power_mode mode)\n{\n\t \n\tu16 reg_774 = 0x3fff, reg_775 = 0xffff, reg_776 = 0xffff,\n\t\treg_900 = (dib8000_read_word(state, 900) & 0xfffc) | 0x3,\n\t\treg_1280;\n\n\tif (state->revision != 0x8090)\n\t\treg_1280 = (dib8000_read_word(state, 1280) & 0x00ff) | 0xff00;\n\telse\n\t\treg_1280 = (dib8000_read_word(state, 1280) & 0x707f) | 0x8f80;\n\n\t \n\tswitch (mode) {\n\t\t \n\tcase DIB8000_POWER_ALL:\n\t\treg_774 = 0x0000;\n\t\treg_775 = 0x0000;\n\t\treg_776 = 0x0000;\n\t\treg_900 &= 0xfffc;\n\t\tif (state->revision != 0x8090)\n\t\t\treg_1280 &= 0x00ff;\n\t\telse\n\t\t\treg_1280 &= 0x707f;\n\t\tbreak;\n\tcase DIB8000_POWER_INTERFACE_ONLY:\n\t\tif (state->revision != 0x8090)\n\t\t\treg_1280 &= 0x00ff;\n\t\telse\n\t\t\treg_1280 &= 0xfa7b;\n\t\tbreak;\n\t}\n\n\tdprintk(\"powermode : 774 : %x ; 775 : %x; 776 : %x ; 900 : %x; 1280 : %x\\n\", reg_774, reg_775, reg_776, reg_900, reg_1280);\n\tdib8000_write_word(state, 774, reg_774);\n\tdib8000_write_word(state, 775, reg_775);\n\tdib8000_write_word(state, 776, reg_776);\n\tdib8000_write_word(state, 900, reg_900);\n\tdib8000_write_word(state, 1280, reg_1280);\n}\n\nstatic int dib8000_set_adc_state(struct dib8000_state *state, enum dibx000_adc_states no)\n{\n\tint ret = 0;\n\tu16 reg, reg_907 = dib8000_read_word(state, 907);\n\tu16 reg_908 = dib8000_read_word(state, 908);\n\n\tswitch (no) {\n\tcase DIBX000_SLOW_ADC_ON:\n\t\tif (state->revision != 0x8090) {\n\t\t\treg_908 |= (1 << 1) | (1 << 0);\n\t\t\tret |= dib8000_write_word(state, 908, reg_908);\n\t\t\treg_908 &= ~(1 << 1);\n\t\t} else {\n\t\t\treg = dib8000_read_word(state, 1925);\n\t\t\t \n\t\t\tdib8000_write_word(state, 1925, reg |\n\t\t\t\t\t(1<<4) | (1<<2));\n\n\t\t\t \n\t\t\treg = dib8000_read_word(state, 1925);\n\t\t\tmsleep(20);\n\t\t\t \n\t\t\tdib8000_write_word(state, 1925, reg & ~(1<<4));\n\n\t\t\treg = dib8000_read_word(state, 921) & ~((0x3 << 14)\n\t\t\t\t\t| (0x3 << 12));\n\t\t\t \n\t\t\tdib8000_write_word(state, 921, reg | (1 << 14)\n\t\t\t\t\t| (3 << 12));\n\t\t}\n\t\tbreak;\n\n\tcase DIBX000_SLOW_ADC_OFF:\n\t\tif (state->revision == 0x8090) {\n\t\t\treg = dib8000_read_word(state, 1925);\n\t\t\t \n\t\t\tdib8000_write_word(state, 1925,\n\t\t\t\t\t(reg & ~(1<<2)) | (1<<4));\n\t\t}\n\t\treg_908 |= (1 << 1) | (1 << 0);\n\t\tbreak;\n\n\tcase DIBX000_ADC_ON:\n\t\treg_907 &= 0x0fff;\n\t\treg_908 &= 0x0003;\n\t\tbreak;\n\n\tcase DIBX000_ADC_OFF:\t\n\t\treg_907 = (1 << 13) | (1 << 12);\n\t\treg_908 = (1 << 6) | (1 << 5) | (1 << 4) | (1 << 3) | (1 << 1);\n\t\tbreak;\n\n\tcase DIBX000_VBG_ENABLE:\n\t\treg_907 &= ~(1 << 15);\n\t\tbreak;\n\n\tcase DIBX000_VBG_DISABLE:\n\t\treg_907 |= (1 << 15);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret |= dib8000_write_word(state, 907, reg_907);\n\tret |= dib8000_write_word(state, 908, reg_908);\n\n\treturn ret;\n}\n\nstatic int dib8000_set_bandwidth(struct dvb_frontend *fe, u32 bw)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu32 timf;\n\n\tif (bw == 0)\n\t\tbw = 6000;\n\n\tif (state->timf == 0) {\n\t\tdprintk(\"using default timf\\n\");\n\t\ttimf = state->timf_default;\n\t} else {\n\t\tdprintk(\"using updated timf\\n\");\n\t\ttimf = state->timf;\n\t}\n\n\tdib8000_write_word(state, 29, (u16) ((timf >> 16) & 0xffff));\n\tdib8000_write_word(state, 30, (u16) ((timf) & 0xffff));\n\n\treturn 0;\n}\n\nstatic int dib8000_sad_calib(struct dib8000_state *state)\n{\n\tu8 sad_sel = 3;\n\n\tif (state->revision == 0x8090) {\n\t\tdib8000_write_word(state, 922, (sad_sel << 2));\n\t\tdib8000_write_word(state, 923, 2048);\n\n\t\tdib8000_write_word(state, 922, (sad_sel << 2) | 0x1);\n\t\tdib8000_write_word(state, 922, (sad_sel << 2));\n\t} else {\n\t\t \n\t\tdib8000_write_word(state, 923, (0 << 1) | (0 << 0));\n\t\tdib8000_write_word(state, 924, 776);\n\n\t\t \n\t\tdib8000_write_word(state, 923, (1 << 0));\n\t\tdib8000_write_word(state, 923, (0 << 0));\n\t}\n\n\tmsleep(1);\n\treturn 0;\n}\n\nstatic int dib8000_set_wbd_ref(struct dvb_frontend *fe, u16 value)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tif (value > 4095)\n\t\tvalue = 4095;\n\tstate->wbd_ref = value;\n\treturn dib8000_write_word(state, 106, value);\n}\n\nstatic void dib8000_reset_pll_common(struct dib8000_state *state, const struct dibx000_bandwidth_config *bw)\n{\n\tdprintk(\"ifreq: %d %x, inversion: %d\\n\", bw->ifreq, bw->ifreq, bw->ifreq >> 25);\n\tif (state->revision != 0x8090) {\n\t\tdib8000_write_word(state, 23,\n\t\t\t\t(u16) (((bw->internal * 1000) >> 16) & 0xffff));\n\t\tdib8000_write_word(state, 24,\n\t\t\t\t(u16) ((bw->internal * 1000) & 0xffff));\n\t} else {\n\t\tdib8000_write_word(state, 23, (u16) (((bw->internal / 2 * 1000) >> 16) & 0xffff));\n\t\tdib8000_write_word(state, 24,\n\t\t\t\t(u16) ((bw->internal  / 2 * 1000) & 0xffff));\n\t}\n\tdib8000_write_word(state, 27, (u16) ((bw->ifreq >> 16) & 0x01ff));\n\tdib8000_write_word(state, 28, (u16) (bw->ifreq & 0xffff));\n\tdib8000_write_word(state, 26, (u16) ((bw->ifreq >> 25) & 0x0003));\n\n\tif (state->revision != 0x8090)\n\t\tdib8000_write_word(state, 922, bw->sad_cfg);\n}\n\nstatic void dib8000_reset_pll(struct dib8000_state *state)\n{\n\tconst struct dibx000_bandwidth_config *pll = state->cfg.pll;\n\tu16 clk_cfg1, reg;\n\n\tif (state->revision != 0x8090) {\n\t\tdib8000_write_word(state, 901,\n\t\t\t\t(pll->pll_prediv << 8) | (pll->pll_ratio << 0));\n\n\t\tclk_cfg1 = (1 << 10) | (0 << 9) | (pll->IO_CLK_en_core << 8) |\n\t\t\t(pll->bypclk_div << 5) | (pll->enable_refdiv << 4) |\n\t\t\t(1 << 3) | (pll->pll_range << 1) |\n\t\t\t(pll->pll_reset << 0);\n\n\t\tdib8000_write_word(state, 902, clk_cfg1);\n\t\tclk_cfg1 = (clk_cfg1 & 0xfff7) | (pll->pll_bypass << 3);\n\t\tdib8000_write_word(state, 902, clk_cfg1);\n\n\t\tdprintk(\"clk_cfg1: 0x%04x\\n\", clk_cfg1);\n\n\t\t \n\t\tif (state->cfg.pll->ADClkSrc == 0)\n\t\t\tdib8000_write_word(state, 904,\n\t\t\t\t\t(0 << 15) | (0 << 12) | (0 << 10) |\n\t\t\t\t\t(pll->modulo << 8) |\n\t\t\t\t\t(pll->ADClkSrc << 7) | (0 << 1));\n\t\telse if (state->cfg.refclksel != 0)\n\t\t\tdib8000_write_word(state, 904, (0 << 15) | (1 << 12) |\n\t\t\t\t\t((state->cfg.refclksel & 0x3) << 10) |\n\t\t\t\t\t(pll->modulo << 8) |\n\t\t\t\t\t(pll->ADClkSrc << 7) | (0 << 1));\n\t\telse\n\t\t\tdib8000_write_word(state, 904, (0 << 15) | (1 << 12) |\n\t\t\t\t\t(3 << 10) | (pll->modulo << 8) |\n\t\t\t\t\t(pll->ADClkSrc << 7) | (0 << 1));\n\t} else {\n\t\tdib8000_write_word(state, 1856, (!pll->pll_reset<<13) |\n\t\t\t\t(pll->pll_range<<12) | (pll->pll_ratio<<6) |\n\t\t\t\t(pll->pll_prediv));\n\n\t\treg = dib8000_read_word(state, 1857);\n\t\tdib8000_write_word(state, 1857, reg|(!pll->pll_bypass<<15));\n\n\t\treg = dib8000_read_word(state, 1858);  \n\t\tdib8000_write_word(state, 1858, reg | 1);\n\n\t\tdib8000_write_word(state, 904, (pll->modulo << 8));\n\t}\n\n\tdib8000_reset_pll_common(state, pll);\n}\n\nstatic int dib8000_update_pll(struct dvb_frontend *fe,\n\t\tstruct dibx000_bandwidth_config *pll, u32 bw, u8 ratio)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu16 reg_1857, reg_1856 = dib8000_read_word(state, 1856);\n\tu8 loopdiv, prediv, oldprediv = state->cfg.pll->pll_prediv ;\n\tu32 internal, xtal;\n\n\t \n\tprediv = reg_1856 & 0x3f;\n\tloopdiv = (reg_1856 >> 6) & 0x3f;\n\n\tif ((pll == NULL) || (pll->pll_prediv == prediv &&\n\t\t\t\tpll->pll_ratio == loopdiv))\n\t\treturn -EINVAL;\n\n\tdprintk(\"Updating pll (prediv: old =  %d new = %d ; loopdiv : old = %d new = %d)\\n\", prediv, pll->pll_prediv, loopdiv, pll->pll_ratio);\n\tif (state->revision == 0x8090) {\n\t\treg_1856 &= 0xf000;\n\t\treg_1857 = dib8000_read_word(state, 1857);\n\t\t \n\t\tdib8000_write_word(state, 1857, reg_1857 & ~(1 << 15));\n\n\t\tdib8000_write_word(state, 1856, reg_1856 |\n\t\t\t\t((pll->pll_ratio & 0x3f) << 6) |\n\t\t\t\t(pll->pll_prediv & 0x3f));\n\n\t\t \n\t\tinternal = dib8000_read32(state, 23) / 1000;\n\t\tdprintk(\"Old Internal = %d\\n\", internal);\n\t\txtal = 2 * (internal / loopdiv) * prediv;\n\t\tinternal = 1000 * (xtal/pll->pll_prediv) * pll->pll_ratio;\n\t\tdprintk(\"Xtal = %d , New Fmem = %d New Fdemod = %d, New Fsampling = %d\\n\", xtal, internal/1000, internal/2000, internal/8000);\n\t\tdprintk(\"New Internal = %d\\n\", internal);\n\n\t\tdib8000_write_word(state, 23,\n\t\t\t\t(u16) (((internal / 2) >> 16) & 0xffff));\n\t\tdib8000_write_word(state, 24, (u16) ((internal / 2) & 0xffff));\n\t\t \n\t\tdib8000_write_word(state, 1857, reg_1857 | (1 << 15));\n\n\t\twhile (((dib8000_read_word(state, 1856)>>15)&0x1) != 1)\n\t\t\tdprintk(\"Waiting for PLL to lock\\n\");\n\n\t\t \n\t\treg_1856 = dib8000_read_word(state, 1856);\n\t\tdprintk(\"PLL Updated with prediv = %d and loopdiv = %d\\n\",\n\t\t\t\treg_1856&0x3f, (reg_1856>>6)&0x3f);\n\t} else {\n\t\tif (bw != state->current_demod_bw) {\n\t\t\t \n\t\t\tdprintk(\"PLL: Bandwidth Change %d MHz -> %d MHz (prediv: %d->%d)\\n\", state->current_demod_bw / 1000, bw / 1000, oldprediv, state->cfg.pll->pll_prediv);\n\n\t\t\tif (state->cfg.pll->pll_prediv != oldprediv) {\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tdprintk(\"PLL: New Setting for %d MHz Bandwidth (prediv: %d, ratio: %d)\\n\", bw/1000, state->cfg.pll->pll_prediv, state->cfg.pll->pll_ratio);\n\t\t\t\tdib8000_write_word(state, 902, dib8000_read_word(state, 902) | (1<<3));  \n\t\t\t\tdib8000_reset_pll(state);\n\t\t\t\tdib8000_write_word(state, 898, 0x0004);  \n\t\t\t} else\n\t\t\t\tratio = state->cfg.pll->pll_ratio;\n\n\t\t\tstate->current_demod_bw = bw;\n\t\t}\n\n\t\tif (ratio != 0) {\n\t\t\t \n\t\t\tdprintk(\"PLL: Update ratio (prediv: %d, ratio: %d)\\n\", state->cfg.pll->pll_prediv, ratio);\n\t\t\tdib8000_write_word(state, 901, (state->cfg.pll->pll_prediv << 8) | (ratio << 0));  \n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dib8000_reset_gpio(struct dib8000_state *st)\n{\n\t \n\tdib8000_write_word(st, 1029, st->cfg.gpio_dir);\n\tdib8000_write_word(st, 1030, st->cfg.gpio_val);\n\n\t \n\n\tdib8000_write_word(st, 1032, st->cfg.gpio_pwm_pos);\n\n\tdib8000_write_word(st, 1037, st->cfg.pwm_freq_div);\n\treturn 0;\n}\n\nstatic int dib8000_cfg_gpio(struct dib8000_state *st, u8 num, u8 dir, u8 val)\n{\n\tst->cfg.gpio_dir = dib8000_read_word(st, 1029);\n\tst->cfg.gpio_dir &= ~(1 << num);\t \n\tst->cfg.gpio_dir |= (dir & 0x1) << num;\t \n\tdib8000_write_word(st, 1029, st->cfg.gpio_dir);\n\n\tst->cfg.gpio_val = dib8000_read_word(st, 1030);\n\tst->cfg.gpio_val &= ~(1 << num);\t \n\tst->cfg.gpio_val |= (val & 0x01) << num;\t \n\tdib8000_write_word(st, 1030, st->cfg.gpio_val);\n\n\tdprintk(\"gpio dir: %x: gpio val: %x\\n\", st->cfg.gpio_dir, st->cfg.gpio_val);\n\n\treturn 0;\n}\n\nstatic int dib8000_set_gpio(struct dvb_frontend *fe, u8 num, u8 dir, u8 val)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\treturn dib8000_cfg_gpio(state, num, dir, val);\n}\n\nstatic const u16 dib8000_defaults[] = {\n\t \n\t3, 7,\n\t0x0004,\n\t0x0400,\n\t0x0814,\n\n\t12, 11,\n\t0x001b,\n\t0x7740,\n\t0x005b,\n\t0x8d80,\n\t0x01c9,\n\t0xc380,\n\t0x0000,\n\t0x0080,\n\t0x0000,\n\t0x0090,\n\t0x0001,\n\t0xd4c0,\n\n\t \n\t(1 << 13) - 825 - 117,\n\t(1 << 13) - 837 - 117,\n\t(1 << 13) - 811 - 117,\n\t(1 << 13) - 766 - 117,\n\t(1 << 13) - 737 - 117,\n\t(1 << 13) - 693 - 117,\n\t(1 << 13) - 648 - 117,\n\t(1 << 13) - 619 - 117,\n\t(1 << 13) - 575 - 117,\n\t(1 << 13) - 531 - 117,\n\t(1 << 13) - 501 - 117,\n\n\t4, 108,\n\t0,\n\t0,\n\t0,\n\t0,\n\n\t1, 175,\n\t0x0410,\n\t1, 179,\n\t8192,\t\t\t\n\n\t6, 181,\n\t0x2800,\t\t\t\n\t0x2800,\n\t0x2800,\n\t0x2800,\t\t\t\n\t0x2800,\n\t0x2800,\n\n\t2, 193,\n\t0x0666,\t\t\t\n\t0x0000,\t\t\t\n\n\t2, 205,\n\t0x200f,\t\t\t\n\t0x000f,\t\t\t\n\n\t5, 215,\n\t0x023d,\t\t\t\n\t0x00a4,\t\t\t\n\t0x00a4,\t\t\t\n\t0x7ff0,\t\t\t\n\t0x3ccc,\t\t\t\n\n\t1, 230,\n\t0x0000,\t\t\t\n\n\t1, 263,\n\t0x800,\t\t\t\n\n\t1, 268,\n\t(2 << 9) | 39,\t\t\n\n\t1, 270,\n\t0x0001,\t\t\t\n\t1, 285,\n\t0x0020,\t\t\t\n\t1, 299,\n\t0x0062,\t\t\t \n\n\t1, 338,\n\t(1 << 12) |\t\t\n\t\t(1 << 10) |\n\t\t(0 << 9) |\t\t \n\t\t(3 << 5) |\t\t \n\t\t(1 << 0),\t\t \n\n\t0,\n};\n\nstatic u16 dib8000_identify(struct i2c_device *client)\n{\n\tu16 value;\n\n\t\n\tvalue = dib8000_i2c_read16(client, 896);\n\n\tif ((value = dib8000_i2c_read16(client, 896)) != 0x01b3) {\n\t\tdprintk(\"wrong Vendor ID (read=0x%x)\\n\", value);\n\t\treturn 0;\n\t}\n\n\tvalue = dib8000_i2c_read16(client, 897);\n\tif (value != 0x8000 && value != 0x8001 &&\n\t\t\tvalue != 0x8002 && value != 0x8090) {\n\t\tdprintk(\"wrong Device ID (%x)\\n\", value);\n\t\treturn 0;\n\t}\n\n\tswitch (value) {\n\tcase 0x8000:\n\t\tdprintk(\"found DiB8000A\\n\");\n\t\tbreak;\n\tcase 0x8001:\n\t\tdprintk(\"found DiB8000B\\n\");\n\t\tbreak;\n\tcase 0x8002:\n\t\tdprintk(\"found DiB8000C\\n\");\n\t\tbreak;\n\tcase 0x8090:\n\t\tdprintk(\"found DiB8096P\\n\");\n\t\tbreak;\n\t}\n\treturn value;\n}\n\nstatic int dib8000_read_unc_blocks(struct dvb_frontend *fe, u32 *unc);\n\nstatic void dib8000_reset_stats(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\tu32 ucb;\n\n\tmemset(&c->strength, 0, sizeof(c->strength));\n\tmemset(&c->cnr, 0, sizeof(c->cnr));\n\tmemset(&c->post_bit_error, 0, sizeof(c->post_bit_error));\n\tmemset(&c->post_bit_count, 0, sizeof(c->post_bit_count));\n\tmemset(&c->block_error, 0, sizeof(c->block_error));\n\n\tc->strength.len = 1;\n\tc->cnr.len = 1;\n\tc->block_error.len = 1;\n\tc->block_count.len = 1;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_count.len = 1;\n\n\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\tc->strength.stat[0].uvalue = 0;\n\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tdib8000_read_unc_blocks(fe, &ucb);\n\n\tstate->init_ucb = -ucb;\n\tstate->ber_jiffies_stats = 0;\n\tstate->per_jiffies_stats = 0;\n\tmemset(&state->ber_jiffies_stats_layer, 0,\n\t       sizeof(state->ber_jiffies_stats_layer));\n}\n\nstatic int dib8000_reset(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\n\tif ((state->revision = dib8000_identify(&state->i2c)) == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (state->revision != 0x8090)\n\t\tdib8000_write_word(state, 1287, 0x0003);\n\n\tif (state->revision == 0x8000)\n\t\tdprintk(\"error : dib8000 MA not supported\\n\");\n\n\tdibx000_reset_i2c_master(&state->i2c_master);\n\n\tdib8000_set_power_mode(state, DIB8000_POWER_ALL);\n\n\t \n\tdib8000_set_adc_state(state, DIBX000_ADC_OFF);\n\n\t \n\tdib8000_write_word(state, 770, 0xffff);\n\tdib8000_write_word(state, 771, 0xffff);\n\tdib8000_write_word(state, 772, 0xfffc);\n\tdib8000_write_word(state, 898, 0x000c);\t \n\tif (state->revision == 0x8090)\n\t\tdib8000_write_word(state, 1280, 0x0045);\n\telse\n\t\tdib8000_write_word(state, 1280, 0x004d);\n\tdib8000_write_word(state, 1281, 0x000c);\n\n\tdib8000_write_word(state, 770, 0x0000);\n\tdib8000_write_word(state, 771, 0x0000);\n\tdib8000_write_word(state, 772, 0x0000);\n\tdib8000_write_word(state, 898, 0x0004);\t\n\tdib8000_write_word(state, 1280, 0x0000);\n\tdib8000_write_word(state, 1281, 0x0000);\n\n\t \n\tif (state->revision != 0x8090) {\n\t\tif (state->cfg.drives)\n\t\t\tdib8000_write_word(state, 906, state->cfg.drives);\n\t\telse {\n\t\t\tdprintk(\"using standard PAD-drive-settings, please adjust settings in config-struct to be optimal.\\n\");\n\t\t\t \n\t\t\tdib8000_write_word(state, 906, 0x2d98);\n\t\t}\n\t}\n\n\tdib8000_reset_pll(state);\n\tif (state->revision != 0x8090)\n\t\tdib8000_write_word(state, 898, 0x0004);\n\n\tif (dib8000_reset_gpio(state) != 0)\n\t\tdprintk(\"GPIO reset was not successful.\\n\");\n\n\tif ((state->revision != 0x8090) &&\n\t\t\t(dib8000_set_output_mode(fe, OUTMODE_HIGH_Z) != 0))\n\t\tdprintk(\"OUTPUT_MODE could not be reset.\\n\");\n\n\tstate->current_agc = NULL;\n\n\t\n\t \n\tif (state->cfg.pll->ifreq == 0)\n\t\tdib8000_write_word(state, 40, 0x0755);\t \n\telse\n\t\tdib8000_write_word(state, 40, 0x1f55);\t \n\n\t{\n\t\tu16 l = 0, r;\n\t\tconst u16 *n;\n\t\tn = dib8000_defaults;\n\t\tl = *n++;\n\t\twhile (l) {\n\t\t\tr = *n++;\n\t\t\tdo {\n\t\t\t\tdib8000_write_word(state, r, *n++);\n\t\t\t\tr++;\n\t\t\t} while (--l);\n\t\t\tl = *n++;\n\t\t}\n\t}\n\n\tstate->isdbt_cfg_loaded = 0;\n\n\t\n\tif ((state->revision != 8090) && (state->cfg.div_cfg != 0))\n\t\tdib8000_write_word(state, 903, state->cfg.div_cfg);\n\n\t \n\tdib8000_write_word(state, 1285, dib8000_read_word(state, 1285) & ~(1 << 1));\n\n\tdib8000_set_bandwidth(fe, 6000);\n\n\tdib8000_set_adc_state(state, DIBX000_SLOW_ADC_ON);\n\tdib8000_sad_calib(state);\n\tif (state->revision != 0x8090)\n\t\tdib8000_set_adc_state(state, DIBX000_SLOW_ADC_OFF);\n\n\t \n\tdib8000_write_word(state, 285, (dib8000_read_word(state, 285) & ~0x60) | (3 << 5));\n\n\tdib8000_set_power_mode(state, DIB8000_POWER_INTERFACE_ONLY);\n\n\tdib8000_reset_stats(fe);\n\n\treturn 0;\n}\n\nstatic void dib8000_restart_agc(struct dib8000_state *state)\n{\n\t\n\tdib8000_write_word(state, 770, 0x0a00);\n\tdib8000_write_word(state, 770, 0x0000);\n}\n\nstatic int dib8000_update_lna(struct dib8000_state *state)\n{\n\tu16 dyn_gain;\n\n\tif (state->cfg.update_lna) {\n\t\t\n\t\tdyn_gain = dib8000_read_word(state, 390);\n\n\t\tif (state->cfg.update_lna(state->fe[0], dyn_gain)) {\n\t\t\tdib8000_restart_agc(state);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dib8000_set_agc_config(struct dib8000_state *state, u8 band)\n{\n\tstruct dibx000_agc_config *agc = NULL;\n\tint i;\n\tu16 reg;\n\n\tif (state->current_band == band && state->current_agc != NULL)\n\t\treturn 0;\n\tstate->current_band = band;\n\n\tfor (i = 0; i < state->cfg.agc_config_count; i++)\n\t\tif (state->cfg.agc[i].band_caps & band) {\n\t\t\tagc = &state->cfg.agc[i];\n\t\t\tbreak;\n\t\t}\n\n\tif (agc == NULL) {\n\t\tdprintk(\"no valid AGC configuration found for band 0x%02x\\n\", band);\n\t\treturn -EINVAL;\n\t}\n\n\tstate->current_agc = agc;\n\n\t \n\tdib8000_write_word(state, 76, agc->setup);\n\tdib8000_write_word(state, 77, agc->inv_gain);\n\tdib8000_write_word(state, 78, agc->time_stabiliz);\n\tdib8000_write_word(state, 101, (agc->alpha_level << 12) | agc->thlock);\n\n\t\n\tdib8000_write_word(state, 102, (agc->alpha_mant << 5) | agc->alpha_exp);\n\tdib8000_write_word(state, 103, (agc->beta_mant << 6) | agc->beta_exp);\n\n\tdprintk(\"WBD: ref: %d, sel: %d, active: %d, alpha: %d\\n\",\n\t\tstate->wbd_ref != 0 ? state->wbd_ref : agc->wbd_ref, agc->wbd_sel, !agc->perform_agc_softsplit, agc->wbd_sel);\n\n\t \n\tif (state->wbd_ref != 0)\n\t\tdib8000_write_word(state, 106, state->wbd_ref);\n\telse\t\t\t\n\t\tdib8000_write_word(state, 106, agc->wbd_ref);\n\n\tif (state->revision == 0x8090) {\n\t\treg = dib8000_read_word(state, 922) & (0x3 << 2);\n\t\tdib8000_write_word(state, 922, reg | (agc->wbd_sel << 2));\n\t}\n\n\tdib8000_write_word(state, 107, (agc->wbd_alpha << 9) | (agc->perform_agc_softsplit << 8));\n\tdib8000_write_word(state, 108, agc->agc1_max);\n\tdib8000_write_word(state, 109, agc->agc1_min);\n\tdib8000_write_word(state, 110, agc->agc2_max);\n\tdib8000_write_word(state, 111, agc->agc2_min);\n\tdib8000_write_word(state, 112, (agc->agc1_pt1 << 8) | agc->agc1_pt2);\n\tdib8000_write_word(state, 113, (agc->agc1_slope1 << 8) | agc->agc1_slope2);\n\tdib8000_write_word(state, 114, (agc->agc2_pt1 << 8) | agc->agc2_pt2);\n\tdib8000_write_word(state, 115, (agc->agc2_slope1 << 8) | agc->agc2_slope2);\n\n\tdib8000_write_word(state, 75, agc->agc1_pt3);\n\tif (state->revision != 0x8090)\n\t\tdib8000_write_word(state, 923,\n\t\t\t\t(dib8000_read_word(state, 923) & 0xffe3) |\n\t\t\t\t(agc->wbd_inv << 4) | (agc->wbd_sel << 2));\n\n\treturn 0;\n}\n\nstatic void dib8000_pwm_agc_reset(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tdib8000_set_adc_state(state, DIBX000_ADC_ON);\n\tdib8000_set_agc_config(state, (unsigned char)(BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency / 1000)));\n}\n\nstatic int dib8000_agc_soft_split(struct dib8000_state *state)\n{\n\tu16 agc, split_offset;\n\n\tif (!state->current_agc || !state->current_agc->perform_agc_softsplit || state->current_agc->split.max == 0)\n\t\treturn 0;\n\n\t\n\tagc = dib8000_read_word(state, 390);\n\n\tif (agc > state->current_agc->split.min_thres)\n\t\tsplit_offset = state->current_agc->split.min;\n\telse if (agc < state->current_agc->split.max_thres)\n\t\tsplit_offset = state->current_agc->split.max;\n\telse\n\t\tsplit_offset = state->current_agc->split.max *\n\t\t\t(agc - state->current_agc->split.min_thres) /\n\t\t\t(state->current_agc->split.max_thres - state->current_agc->split.min_thres);\n\n\tdprintk(\"AGC split_offset: %d\\n\", split_offset);\n\n\t\n\tdib8000_write_word(state, 107, (dib8000_read_word(state, 107) & 0xff00) | split_offset);\n\treturn 5000;\n}\n\nstatic int dib8000_agc_startup(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tenum frontend_tune_state *tune_state = &state->tune_state;\n\tint ret = 0;\n\tu16 reg;\n\tu32 upd_demod_gain_period = 0x8000;\n\n\tswitch (*tune_state) {\n\tcase CT_AGC_START:\n\t\t\n\n\t\tif (state->revision != 0x8090)\n\t\t\tdib8000_set_adc_state(state, DIBX000_ADC_ON);\n\t\telse {\n\t\t\tdib8000_set_power_mode(state, DIB8000_POWER_ALL);\n\n\t\t\treg = dib8000_read_word(state, 1947)&0xff00;\n\t\t\tdib8000_write_word(state, 1946,\n\t\t\t\t\tupd_demod_gain_period & 0xFFFF);\n\t\t\t \n\t\t\tdib8000_write_word(state, 1947, reg | (1<<14) |\n\t\t\t\t\t((upd_demod_gain_period >> 16) & 0xFF));\n\n\t\t\t \n\t\t\treg = dib8000_read_word(state, 1920);\n\t\t\tdib8000_write_word(state, 1920, (reg | 0x3) &\n\t\t\t\t\t(~(1 << 7)));\n\t\t}\n\n\t\tif (dib8000_set_agc_config(state, (unsigned char)(BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency / 1000))) != 0) {\n\t\t\t*tune_state = CT_AGC_STOP;\n\t\t\tstate->status = FE_STATUS_TUNE_FAILED;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = 70;\n\t\t*tune_state = CT_AGC_STEP_0;\n\t\tbreak;\n\n\tcase CT_AGC_STEP_0:\n\t\t\n\t\tif (state->cfg.agc_control)\n\t\t\tstate->cfg.agc_control(fe, 1);\n\n\t\tdib8000_restart_agc(state);\n\n\t\t\n\t\tret = 50;\n\t\t*tune_state = CT_AGC_STEP_1;\n\t\tbreak;\n\n\tcase CT_AGC_STEP_1:\n\t\t\n\t\tret = 70;\n\n\t\tif (dib8000_update_lna(state))\n\t\t\t\n\t\t\tret = 50;\n\t\telse\n\t\t\t*tune_state = CT_AGC_STEP_2;\n\t\tbreak;\n\n\tcase CT_AGC_STEP_2:\n\t\tdib8000_agc_soft_split(state);\n\n\t\tif (state->cfg.agc_control)\n\t\t\tstate->cfg.agc_control(fe, 0);\n\n\t\t*tune_state = CT_AGC_STOP;\n\t\tbreak;\n\tdefault:\n\t\tret = dib8000_agc_soft_split(state);\n\t\tbreak;\n\t}\n\treturn ret;\n\n}\n\nstatic void dib8096p_host_bus_drive(struct dib8000_state *state, u8 drive)\n{\n\tu16 reg;\n\n\tdrive &= 0x7;\n\n\t \n\treg = dib8000_read_word(state, 1798) &\n\t\t~(0x7 | (0x7 << 6) | (0x7 << 12));\n\treg |= (drive<<12) | (drive<<6) | drive;\n\tdib8000_write_word(state, 1798, reg);\n\n\t \n\treg = dib8000_read_word(state, 1799) & ~((0x7 << 2) | (0x7 << 8));\n\treg |= (drive<<8) | (drive<<2);\n\tdib8000_write_word(state, 1799, reg);\n\n\t \n\treg = dib8000_read_word(state, 1800) &\n\t\t~(0x7 | (0x7 << 6) | (0x7 << 12));\n\treg |= (drive<<12) | (drive<<6) | drive;\n\tdib8000_write_word(state, 1800, reg);\n\n\t \n\treg = dib8000_read_word(state, 1801) & ~((0x7 << 2) | (0x7 << 8));\n\treg |= (drive<<8) | (drive<<2);\n\tdib8000_write_word(state, 1801, reg);\n\n\t \n\treg = dib8000_read_word(state, 1802) &\n\t\t~(0x7 | (0x7 << 6) | (0x7 << 12));\n\treg |= (drive<<12) | (drive<<6) | drive;\n\tdib8000_write_word(state, 1802, reg);\n}\n\nstatic u32 dib8096p_calcSyncFreq(u32 P_Kin, u32 P_Kout,\n\t\tu32 insertExtSynchro, u32 syncSize)\n{\n\tu32 quantif = 3;\n\tu32 nom = (insertExtSynchro * P_Kin+syncSize);\n\tu32 denom = P_Kout;\n\tu32 syncFreq = ((nom << quantif) / denom);\n\n\tif ((syncFreq & ((1 << quantif) - 1)) != 0)\n\t\tsyncFreq = (syncFreq >> quantif) + 1;\n\telse\n\t\tsyncFreq = (syncFreq >> quantif);\n\n\tif (syncFreq != 0)\n\t\tsyncFreq = syncFreq - 1;\n\n\treturn syncFreq;\n}\n\nstatic void dib8096p_cfg_DibTx(struct dib8000_state *state, u32 P_Kin,\n\t\tu32 P_Kout, u32 insertExtSynchro, u32 synchroMode,\n\t\tu32 syncWord, u32 syncSize)\n{\n\tdprintk(\"Configure DibStream Tx\\n\");\n\n\tdib8000_write_word(state, 1615, 1);\n\tdib8000_write_word(state, 1603, P_Kin);\n\tdib8000_write_word(state, 1605, P_Kout);\n\tdib8000_write_word(state, 1606, insertExtSynchro);\n\tdib8000_write_word(state, 1608, synchroMode);\n\tdib8000_write_word(state, 1609, (syncWord >> 16) & 0xffff);\n\tdib8000_write_word(state, 1610, syncWord & 0xffff);\n\tdib8000_write_word(state, 1612, syncSize);\n\tdib8000_write_word(state, 1615, 0);\n}\n\nstatic void dib8096p_cfg_DibRx(struct dib8000_state *state, u32 P_Kin,\n\t\tu32 P_Kout, u32 synchroMode, u32 insertExtSynchro,\n\t\tu32 syncWord, u32 syncSize, u32 dataOutRate)\n{\n\tu32 syncFreq;\n\n\tdprintk(\"Configure DibStream Rx synchroMode = %d\\n\", synchroMode);\n\n\tif ((P_Kin != 0) && (P_Kout != 0)) {\n\t\tsyncFreq = dib8096p_calcSyncFreq(P_Kin, P_Kout,\n\t\t\t\tinsertExtSynchro, syncSize);\n\t\tdib8000_write_word(state, 1542, syncFreq);\n\t}\n\n\tdib8000_write_word(state, 1554, 1);\n\tdib8000_write_word(state, 1536, P_Kin);\n\tdib8000_write_word(state, 1537, P_Kout);\n\tdib8000_write_word(state, 1539, synchroMode);\n\tdib8000_write_word(state, 1540, (syncWord >> 16) & 0xffff);\n\tdib8000_write_word(state, 1541, syncWord & 0xffff);\n\tdib8000_write_word(state, 1543, syncSize);\n\tdib8000_write_word(state, 1544, dataOutRate);\n\tdib8000_write_word(state, 1554, 0);\n}\n\nstatic void dib8096p_enMpegMux(struct dib8000_state *state, int onoff)\n{\n\tu16 reg_1287;\n\n\treg_1287 = dib8000_read_word(state, 1287);\n\n\tswitch (onoff) {\n\tcase 1:\n\t\t\treg_1287 &= ~(1 << 8);\n\t\t\tbreak;\n\tcase 0:\n\t\t\treg_1287 |= (1 << 8);\n\t\t\tbreak;\n\t}\n\n\tdib8000_write_word(state, 1287, reg_1287);\n}\n\nstatic void dib8096p_configMpegMux(struct dib8000_state *state,\n\t\tu16 pulseWidth, u16 enSerialMode, u16 enSerialClkDiv2)\n{\n\tu16 reg_1287;\n\n\tdprintk(\"Enable Mpeg mux\\n\");\n\n\tdib8096p_enMpegMux(state, 0);\n\n\t \n\tif ((enSerialMode == 1) && (state->input_mode_mpeg == 1))\n\t\tenSerialClkDiv2 = 0;\n\n\treg_1287 = ((pulseWidth & 0x1f) << 3) |\n\t\t((enSerialMode & 0x1) << 2) | (enSerialClkDiv2 & 0x1);\n\tdib8000_write_word(state, 1287, reg_1287);\n\n\tdib8096p_enMpegMux(state, 1);\n}\n\nstatic void dib8096p_setDibTxMux(struct dib8000_state *state, int mode)\n{\n\tu16 reg_1288 = dib8000_read_word(state, 1288) & ~(0x7 << 7);\n\n\tswitch (mode) {\n\tcase MPEG_ON_DIBTX:\n\t\t\tdprintk(\"SET MPEG ON DIBSTREAM TX\\n\");\n\t\t\tdib8096p_cfg_DibTx(state, 8, 5, 0, 0, 0, 0);\n\t\t\treg_1288 |= (1 << 9); break;\n\tcase DIV_ON_DIBTX:\n\t\t\tdprintk(\"SET DIV_OUT ON DIBSTREAM TX\\n\");\n\t\t\tdib8096p_cfg_DibTx(state, 5, 5, 0, 0, 0, 0);\n\t\t\treg_1288 |= (1 << 8); break;\n\tcase ADC_ON_DIBTX:\n\t\t\tdprintk(\"SET ADC_OUT ON DIBSTREAM TX\\n\");\n\t\t\tdib8096p_cfg_DibTx(state, 20, 5, 10, 0, 0, 0);\n\t\t\treg_1288 |= (1 << 7); break;\n\tdefault:\n\t\t\tbreak;\n\t}\n\tdib8000_write_word(state, 1288, reg_1288);\n}\n\nstatic void dib8096p_setHostBusMux(struct dib8000_state *state, int mode)\n{\n\tu16 reg_1288 = dib8000_read_word(state, 1288) & ~(0x7 << 4);\n\n\tswitch (mode) {\n\tcase DEMOUT_ON_HOSTBUS:\n\t\t\tdprintk(\"SET DEM OUT OLD INTERF ON HOST BUS\\n\");\n\t\t\tdib8096p_enMpegMux(state, 0);\n\t\t\treg_1288 |= (1 << 6);\n\t\t\tbreak;\n\tcase DIBTX_ON_HOSTBUS:\n\t\t\tdprintk(\"SET DIBSTREAM TX ON HOST BUS\\n\");\n\t\t\tdib8096p_enMpegMux(state, 0);\n\t\t\treg_1288 |= (1 << 5);\n\t\t\tbreak;\n\tcase MPEG_ON_HOSTBUS:\n\t\t\tdprintk(\"SET MPEG MUX ON HOST BUS\\n\");\n\t\t\treg_1288 |= (1 << 4);\n\t\t\tbreak;\n\tdefault:\n\t\t\tbreak;\n\t}\n\tdib8000_write_word(state, 1288, reg_1288);\n}\n\nstatic int dib8096p_set_diversity_in(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu16 reg_1287;\n\n\tswitch (onoff) {\n\tcase 0:  \n\t\t\tdprintk(\"%s mode OFF : by default Enable Mpeg INPUT\\n\",\n\t\t\t\t\t__func__);\n\t\t\t \n\t\t\tdib8096p_cfg_DibRx(state, 8, 5, 0, 0, 0, 8, 0);\n\n\t\t\t \n\t\t\treg_1287 = dib8000_read_word(state, 1287);\n\t\t\t \n\t\t\tif ((reg_1287 & 0x1) == 1) {\n\t\t\t\t \n\t\t\t\treg_1287 &= ~0x1;\n\t\t\t\tdib8000_write_word(state, 1287, reg_1287);\n\t\t\t}\n\t\t\tstate->input_mode_mpeg = 1;\n\t\t\tbreak;\n\tcase 1:  \n\tcase 2:  \n\t\t\tdprintk(\"%s ON : Enable diversity INPUT\\n\", __func__);\n\t\t\tdib8096p_cfg_DibRx(state, 5, 5, 0, 0, 0, 0, 0);\n\t\t\tstate->input_mode_mpeg = 0;\n\t\t\tbreak;\n\t}\n\n\tdib8000_set_diversity_in(state->fe[0], onoff);\n\treturn 0;\n}\n\nstatic int dib8096p_set_output_mode(struct dvb_frontend *fe, int mode)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu16 outreg, smo_mode, fifo_threshold;\n\tu8 prefer_mpeg_mux_use = 1;\n\tint ret = 0;\n\n\tstate->output_mode = mode;\n\tdib8096p_host_bus_drive(state, 1);\n\n\tfifo_threshold = 1792;\n\tsmo_mode = (dib8000_read_word(state, 299) & 0x0050) | (1 << 1);\n\toutreg   = dib8000_read_word(state, 1286) &\n\t\t~((1 << 10) | (0x7 << 6) | (1 << 1));\n\n\tswitch (mode) {\n\tcase OUTMODE_HIGH_Z:\n\t\t\toutreg = 0;\n\t\t\tbreak;\n\n\tcase OUTMODE_MPEG2_SERIAL:\n\t\t\tif (prefer_mpeg_mux_use) {\n\t\t\t\tdprintk(\"dib8096P setting output mode TS_SERIAL using Mpeg Mux\\n\");\n\t\t\t\tdib8096p_configMpegMux(state, 3, 1, 1);\n\t\t\t\tdib8096p_setHostBusMux(state, MPEG_ON_HOSTBUS);\n\t\t\t} else { \n\t\t\t\tdprintk(\"dib8096P setting output mode TS_SERIAL using Smooth bloc\\n\");\n\t\t\t\tdib8096p_setHostBusMux(state,\n\t\t\t\t\t\tDEMOUT_ON_HOSTBUS);\n\t\t\t\toutreg |= (2 << 6) | (0 << 1);\n\t\t\t}\n\t\t\tbreak;\n\n\tcase OUTMODE_MPEG2_PAR_GATED_CLK:\n\t\t\tif (prefer_mpeg_mux_use) {\n\t\t\t\tdprintk(\"dib8096P setting output mode TS_PARALLEL_GATED using Mpeg Mux\\n\");\n\t\t\t\tdib8096p_configMpegMux(state, 2, 0, 0);\n\t\t\t\tdib8096p_setHostBusMux(state, MPEG_ON_HOSTBUS);\n\t\t\t} else {  \n\t\t\t\tdprintk(\"dib8096P setting output mode TS_PARALLEL_GATED using Smooth block\\n\");\n\t\t\t\tdib8096p_setHostBusMux(state,\n\t\t\t\t\t\tDEMOUT_ON_HOSTBUS);\n\t\t\t\toutreg |= (0 << 6);\n\t\t\t}\n\t\t\tbreak;\n\n\tcase OUTMODE_MPEG2_PAR_CONT_CLK:  \n\t\t\tdprintk(\"dib8096P setting output mode TS_PARALLEL_CONT using Smooth block\\n\");\n\t\t\tdib8096p_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\n\t\t\toutreg |= (1 << 6);\n\t\t\tbreak;\n\n\tcase OUTMODE_MPEG2_FIFO:\n\t\t\t \n\t\t\tdprintk(\"dib8096P setting output mode TS_FIFO using Smooth block\\n\");\n\t\t\tdib8096p_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\n\t\t\toutreg |= (5 << 6);\n\t\t\tsmo_mode |= (3 << 1);\n\t\t\tfifo_threshold = 512;\n\t\t\tbreak;\n\n\tcase OUTMODE_DIVERSITY:\n\t\t\tdprintk(\"dib8096P setting output mode MODE_DIVERSITY\\n\");\n\t\t\tdib8096p_setDibTxMux(state, DIV_ON_DIBTX);\n\t\t\tdib8096p_setHostBusMux(state, DIBTX_ON_HOSTBUS);\n\t\t\tbreak;\n\n\tcase OUTMODE_ANALOG_ADC:\n\t\t\tdprintk(\"dib8096P setting output mode MODE_ANALOG_ADC\\n\");\n\t\t\tdib8096p_setDibTxMux(state, ADC_ON_DIBTX);\n\t\t\tdib8096p_setHostBusMux(state, DIBTX_ON_HOSTBUS);\n\t\t\tbreak;\n\t}\n\n\tif (mode != OUTMODE_HIGH_Z)\n\t\toutreg |= (1<<10);\n\n\tdprintk(\"output_mpeg2_in_188_bytes = %d\\n\",\n\t\t\tstate->cfg.output_mpeg2_in_188_bytes);\n\tif (state->cfg.output_mpeg2_in_188_bytes)\n\t\tsmo_mode |= (1 << 5);\n\n\tret |= dib8000_write_word(state, 299, smo_mode);\n\t \n\tret |= dib8000_write_word(state, 299 + 1, fifo_threshold);\n\tret |= dib8000_write_word(state, 1286, outreg);\n\n\treturn ret;\n}\n\nstatic int map_addr_to_serpar_number(struct i2c_msg *msg)\n{\n\tif (msg->buf[0] <= 15)\n\t\tmsg->buf[0] -= 1;\n\telse if (msg->buf[0] == 17)\n\t\tmsg->buf[0] = 15;\n\telse if (msg->buf[0] == 16)\n\t\tmsg->buf[0] = 17;\n\telse if (msg->buf[0] == 19)\n\t\tmsg->buf[0] = 16;\n\telse if (msg->buf[0] >= 21 && msg->buf[0] <= 25)\n\t\tmsg->buf[0] -= 3;\n\telse if (msg->buf[0] == 28)\n\t\tmsg->buf[0] = 23;\n\telse if (msg->buf[0] == 99)\n\t\tmsg->buf[0] = 99;\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int dib8096p_tuner_write_serpar(struct i2c_adapter *i2c_adap,\n\t\tstruct i2c_msg msg[], int num)\n{\n\tstruct dib8000_state *state = i2c_get_adapdata(i2c_adap);\n\tu8 n_overflow = 1;\n\tu16 i = 1000;\n\tu16 serpar_num = msg[0].buf[0];\n\n\twhile (n_overflow == 1 && i) {\n\t\tn_overflow = (dib8000_read_word(state, 1984) >> 1) & 0x1;\n\t\ti--;\n\t\tif (i == 0)\n\t\t\tdprintk(\"Tuner ITF: write busy (overflow)\\n\");\n\t}\n\tdib8000_write_word(state, 1985, (1 << 6) | (serpar_num & 0x3f));\n\tdib8000_write_word(state, 1986, (msg[0].buf[1] << 8) | msg[0].buf[2]);\n\n\treturn num;\n}\n\nstatic int dib8096p_tuner_read_serpar(struct i2c_adapter *i2c_adap,\n\t\tstruct i2c_msg msg[], int num)\n{\n\tstruct dib8000_state *state = i2c_get_adapdata(i2c_adap);\n\tu8 n_overflow = 1, n_empty = 1;\n\tu16 i = 1000;\n\tu16 serpar_num = msg[0].buf[0];\n\tu16 read_word;\n\n\twhile (n_overflow == 1 && i) {\n\t\tn_overflow = (dib8000_read_word(state, 1984) >> 1) & 0x1;\n\t\ti--;\n\t\tif (i == 0)\n\t\t\tdprintk(\"TunerITF: read busy (overflow)\\n\");\n\t}\n\tdib8000_write_word(state, 1985, (0<<6) | (serpar_num&0x3f));\n\n\ti = 1000;\n\twhile (n_empty == 1 && i) {\n\t\tn_empty = dib8000_read_word(state, 1984)&0x1;\n\t\ti--;\n\t\tif (i == 0)\n\t\t\tdprintk(\"TunerITF: read busy (empty)\\n\");\n\t}\n\n\tread_word = dib8000_read_word(state, 1987);\n\tmsg[1].buf[0] = (read_word >> 8) & 0xff;\n\tmsg[1].buf[1] = (read_word) & 0xff;\n\n\treturn num;\n}\n\nstatic int dib8096p_tuner_rw_serpar(struct i2c_adapter *i2c_adap,\n\t\tstruct i2c_msg msg[], int num)\n{\n\tif (map_addr_to_serpar_number(&msg[0]) == 0) {\n\t\tif (num == 1)  \n\t\t\treturn dib8096p_tuner_write_serpar(i2c_adap, msg, 1);\n\t\telse  \n\t\t\treturn dib8096p_tuner_read_serpar(i2c_adap, msg, 2);\n\t}\n\treturn num;\n}\n\nstatic int dib8096p_rw_on_apb(struct i2c_adapter *i2c_adap,\n\t\tstruct i2c_msg msg[], int num, u16 apb_address)\n{\n\tstruct dib8000_state *state = i2c_get_adapdata(i2c_adap);\n\tu16 word;\n\n\tif (num == 1) {\t\t \n\t\tdib8000_write_word(state, apb_address,\n\t\t\t\t((msg[0].buf[1] << 8) | (msg[0].buf[2])));\n\t} else {\n\t\tword = dib8000_read_word(state, apb_address);\n\t\tmsg[1].buf[0] = (word >> 8) & 0xff;\n\t\tmsg[1].buf[1] = (word) & 0xff;\n\t}\n\treturn num;\n}\n\nstatic int dib8096p_tuner_xfer(struct i2c_adapter *i2c_adap,\n\t\tstruct i2c_msg msg[], int num)\n{\n\tstruct dib8000_state *state = i2c_get_adapdata(i2c_adap);\n\tu16 apb_address = 0, word;\n\tint i = 0;\n\n\tswitch (msg[0].buf[0]) {\n\tcase 0x12:\n\t\t\tapb_address = 1920;\n\t\t\tbreak;\n\tcase 0x14:\n\t\t\tapb_address = 1921;\n\t\t\tbreak;\n\tcase 0x24:\n\t\t\tapb_address = 1922;\n\t\t\tbreak;\n\tcase 0x1a:\n\t\t\tapb_address = 1923;\n\t\t\tbreak;\n\tcase 0x22:\n\t\t\tapb_address = 1924;\n\t\t\tbreak;\n\tcase 0x33:\n\t\t\tapb_address = 1926;\n\t\t\tbreak;\n\tcase 0x34:\n\t\t\tapb_address = 1927;\n\t\t\tbreak;\n\tcase 0x35:\n\t\t\tapb_address = 1928;\n\t\t\tbreak;\n\tcase 0x36:\n\t\t\tapb_address = 1929;\n\t\t\tbreak;\n\tcase 0x37:\n\t\t\tapb_address = 1930;\n\t\t\tbreak;\n\tcase 0x38:\n\t\t\tapb_address = 1931;\n\t\t\tbreak;\n\tcase 0x39:\n\t\t\tapb_address = 1932;\n\t\t\tbreak;\n\tcase 0x2a:\n\t\t\tapb_address = 1935;\n\t\t\tbreak;\n\tcase 0x2b:\n\t\t\tapb_address = 1936;\n\t\t\tbreak;\n\tcase 0x2c:\n\t\t\tapb_address = 1937;\n\t\t\tbreak;\n\tcase 0x2d:\n\t\t\tapb_address = 1938;\n\t\t\tbreak;\n\tcase 0x2e:\n\t\t\tapb_address = 1939;\n\t\t\tbreak;\n\tcase 0x2f:\n\t\t\tapb_address = 1940;\n\t\t\tbreak;\n\tcase 0x30:\n\t\t\tapb_address = 1941;\n\t\t\tbreak;\n\tcase 0x31:\n\t\t\tapb_address = 1942;\n\t\t\tbreak;\n\tcase 0x32:\n\t\t\tapb_address = 1943;\n\t\t\tbreak;\n\tcase 0x3e:\n\t\t\tapb_address = 1944;\n\t\t\tbreak;\n\tcase 0x3f:\n\t\t\tapb_address = 1945;\n\t\t\tbreak;\n\tcase 0x40:\n\t\t\tapb_address = 1948;\n\t\t\tbreak;\n\tcase 0x25:\n\t\t\tapb_address = 936;\n\t\t\tbreak;\n\tcase 0x26:\n\t\t\tapb_address = 937;\n\t\t\tbreak;\n\tcase 0x27:\n\t\t\tapb_address = 938;\n\t\t\tbreak;\n\tcase 0x28:\n\t\t\tapb_address = 939;\n\t\t\tbreak;\n\tcase 0x1d:\n\t\t\t \n\t\t\ti = ((dib8000_read_word(state, 921) >> 12)&0x3);\n\t\t\tword = dib8000_read_word(state, 924+i);\n\t\t\tmsg[1].buf[0] = (word >> 8) & 0xff;\n\t\t\tmsg[1].buf[1] = (word) & 0xff;\n\t\t\treturn num;\n\tcase 0x1f:\n\t\t\tif (num == 1) {\t \n\t\t\t\tword = (u16) ((msg[0].buf[1] << 8) |\n\t\t\t\t\t\tmsg[0].buf[2]);\n\t\t\t\t \n\t\t\t\tword &= 0x3;\n\t\t\t\tword = (dib8000_read_word(state, 921) &\n\t\t\t\t\t\t~(3<<12)) | (word<<12);\n\t\t\t\t \n\t\t\t\tdib8000_write_word(state, 921, word);\n\t\t\t\treturn num;\n\t\t\t}\n\t}\n\n\tif (apb_address != 0)  \n\t\treturn dib8096p_rw_on_apb(i2c_adap, msg, num, apb_address);\n\telse   \n\t\treturn dib8096p_tuner_rw_serpar(i2c_adap, msg, num);\n\n\treturn 0;\n}\n\nstatic u32 dib8096p_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm dib8096p_tuner_xfer_algo = {\n\t.master_xfer = dib8096p_tuner_xfer,\n\t.functionality = dib8096p_i2c_func,\n};\n\nstatic struct i2c_adapter *dib8096p_get_i2c_tuner(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *st = fe->demodulator_priv;\n\treturn &st->dib8096p_tuner_adap;\n}\n\nstatic int dib8096p_tuner_sleep(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu16 en_cur_state;\n\n\tdprintk(\"sleep dib8096p: %d\\n\", onoff);\n\n\ten_cur_state = dib8000_read_word(state, 1922);\n\n\t \n\tif (en_cur_state > 0xff)\n\t\tstate->tuner_enable = en_cur_state ;\n\n\tif (onoff)\n\t\ten_cur_state &= 0x00ff;\n\telse {\n\t\tif (state->tuner_enable != 0)\n\t\t\ten_cur_state = state->tuner_enable;\n\t}\n\n\tdib8000_write_word(state, 1922, en_cur_state);\n\n\treturn 0;\n}\n\nstatic const s32 lut_1000ln_mant[] =\n{\n\t908, 7003, 7090, 7170, 7244, 7313, 7377, 7438, 7495, 7549, 7600\n};\n\nstatic s32 dib8000_get_adc_power(struct dvb_frontend *fe, u8 mode)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu32 ix = 0, tmp_val = 0, exp = 0, mant = 0;\n\ts32 val;\n\n\tval = dib8000_read32(state, 384);\n\tif (mode) {\n\t\ttmp_val = val;\n\t\twhile (tmp_val >>= 1)\n\t\t\texp++;\n\t\tmant = (val * 1000 / (1<<exp));\n\t\tix = (u8)((mant-1000)/100);  \n\t\tval = (lut_1000ln_mant[ix] + 693*(exp-20) - 6908);\n\t\tval = (val*256)/1000;\n\t}\n\treturn val;\n}\n\nstatic int dib8090p_get_dc_power(struct dvb_frontend *fe, u8 IQ)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tint val = 0;\n\n\tswitch (IQ) {\n\tcase 1:\n\t\t\tval = dib8000_read_word(state, 403);\n\t\t\tbreak;\n\tcase 0:\n\t\t\tval = dib8000_read_word(state, 404);\n\t\t\tbreak;\n\t}\n\tif (val  & 0x200)\n\t\tval -= 1024;\n\n\treturn val;\n}\n\nstatic void dib8000_update_timf(struct dib8000_state *state)\n{\n\tu32 timf = state->timf = dib8000_read32(state, 435);\n\n\tdib8000_write_word(state, 29, (u16) (timf >> 16));\n\tdib8000_write_word(state, 30, (u16) (timf & 0xffff));\n\tdprintk(\"Updated timing frequency: %d (default: %d)\\n\", state->timf, state->timf_default);\n}\n\nstatic u32 dib8000_ctrl_timf(struct dvb_frontend *fe, uint8_t op, uint32_t timf)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\n\tswitch (op) {\n\tcase DEMOD_TIMF_SET:\n\t\t\tstate->timf = timf;\n\t\t\tbreak;\n\tcase DEMOD_TIMF_UPDATE:\n\t\t\tdib8000_update_timf(state);\n\t\t\tbreak;\n\tcase DEMOD_TIMF_GET:\n\t\t\tbreak;\n\t}\n\tdib8000_set_bandwidth(state->fe[0], 6000);\n\n\treturn state->timf;\n}\n\nstatic const u16 adc_target_16dB[11] = {\n\t7250, 7238, 7264, 7309, 7338, 7382, 7427, 7456, 7500, 7544, 7574\n};\n\nstatic const u8 permu_seg[] = { 6, 5, 7, 4, 8, 3, 9, 2, 10, 1, 11, 0, 12 };\n\nstatic u16 dib8000_set_layer(struct dib8000_state *state, u8 layer_index, u16 max_constellation)\n{\n\tu8  cr, constellation, time_intlv;\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\n\tswitch (c->layer[layer_index].modulation) {\n\tcase DQPSK:\n\t\t\tconstellation = 0;\n\t\t\tbreak;\n\tcase  QPSK:\n\t\t\tconstellation = 1;\n\t\t\tbreak;\n\tcase QAM_16:\n\t\t\tconstellation = 2;\n\t\t\tbreak;\n\tcase QAM_64:\n\tdefault:\n\t\t\tconstellation = 3;\n\t\t\tbreak;\n\t}\n\n\tswitch (c->layer[layer_index].fec) {\n\tcase FEC_1_2:\n\t\t\tcr = 1;\n\t\t\tbreak;\n\tcase FEC_2_3:\n\t\t\tcr = 2;\n\t\t\tbreak;\n\tcase FEC_3_4:\n\t\t\tcr = 3;\n\t\t\tbreak;\n\tcase FEC_5_6:\n\t\t\tcr = 5;\n\t\t\tbreak;\n\tcase FEC_7_8:\n\tdefault:\n\t\t\tcr = 7;\n\t\t\tbreak;\n\t}\n\n\ttime_intlv = fls(c->layer[layer_index].interleaving);\n\tif (time_intlv > 3 && !(time_intlv == 4 && c->isdbt_sb_mode == 1))\n\t\ttime_intlv = 0;\n\n\tdib8000_write_word(state, 2 + layer_index, (constellation << 10) | ((c->layer[layer_index].segment_count & 0xf) << 6) | (cr << 3) | time_intlv);\n\tif (c->layer[layer_index].segment_count > 0) {\n\t\tswitch (max_constellation) {\n\t\tcase DQPSK:\n\t\tcase QPSK:\n\t\t\t\tif (c->layer[layer_index].modulation == QAM_16 || c->layer[layer_index].modulation == QAM_64)\n\t\t\t\t\tmax_constellation = c->layer[layer_index].modulation;\n\t\t\t\tbreak;\n\t\tcase QAM_16:\n\t\t\t\tif (c->layer[layer_index].modulation == QAM_64)\n\t\t\t\t\tmax_constellation = c->layer[layer_index].modulation;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn  max_constellation;\n}\n\nstatic const u16 adp_Q64[4] = {0x0148, 0xfff0, 0x00a4, 0xfff8};  \nstatic const u16 adp_Q16[4] = {0x023d, 0xffdf, 0x00a4, 0xfff0};  \nstatic const u16 adp_Qdefault[4] = {0x099a, 0xffae, 0x0333, 0xfff8};  \nstatic u16 dib8000_adp_fine_tune(struct dib8000_state *state, u16 max_constellation)\n{\n\tu16 i, ana_gain = 0;\n\tconst u16 *adp;\n\n\t \n\tswitch (max_constellation) {\n\tcase QAM_64:\n\t\t\tana_gain = 0x7;\n\t\t\tadp = &adp_Q64[0];\n\t\t\tbreak;\n\tcase QAM_16:\n\t\t\tana_gain = 0x7;\n\t\t\tadp = &adp_Q16[0];\n\t\t\tbreak;\n\tdefault:\n\t\t\tana_gain = 0;\n\t\t\tadp = &adp_Qdefault[0];\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tdib8000_write_word(state, 215 + i, adp[i]);\n\n\treturn ana_gain;\n}\n\nstatic void dib8000_update_ana_gain(struct dib8000_state *state, u16 ana_gain)\n{\n\tu16 i;\n\n\tdib8000_write_word(state, 116, ana_gain);\n\n\t \n\tif (ana_gain) {  \n\t\tfor (i = 0; i < 10; i++)\n\t\t\tdib8000_write_word(state, 80 + i, adc_target_16dB[i]);\n\t} else {  \n\t\tfor (i = 0; i < 10; i++)\n\t\t\tdib8000_write_word(state, 80 + i, adc_target_16dB[i] - 355);\n\t}\n}\n\nstatic void dib8000_load_ana_fe_coefs(struct dib8000_state *state, const s16 *ana_fe)\n{\n\tu16 mode = 0;\n\n\tif (state->isdbt_cfg_loaded == 0)\n\t\tfor (mode = 0; mode < 24; mode++)\n\t\t\tdib8000_write_word(state, 117 + mode, ana_fe[mode]);\n}\n\nstatic const u16 lut_prbs_2k[13] = {\n\t0x423, 0x009, 0x5C7,\n\t0x7A6, 0x3D8, 0x527,\n\t0x7FF, 0x79B, 0x3D6,\n\t0x3A2, 0x53B, 0x2F4,\n\t0x213\n};\n\nstatic const u16 lut_prbs_4k[13] = {\n\t0x208, 0x0C3, 0x7B9,\n\t0x423, 0x5C7, 0x3D8,\n\t0x7FF, 0x3D6, 0x53B,\n\t0x213, 0x029, 0x0D0,\n\t0x48E\n};\n\nstatic const u16 lut_prbs_8k[13] = {\n\t0x740, 0x069, 0x7DD,\n\t0x208, 0x7B9, 0x5C7,\n\t0x7FF, 0x53B, 0x029,\n\t0x48E, 0x4C4, 0x367,\n\t0x684\n};\n\nstatic u16 dib8000_get_init_prbs(struct dib8000_state *state, u16 subchannel)\n{\n\tint sub_channel_prbs_group = 0;\n\tint prbs_group;\n\n\tsub_channel_prbs_group = subchannel / 3;\n\tif (sub_channel_prbs_group >= ARRAY_SIZE(lut_prbs_2k))\n\t\treturn 0;\n\n\tswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\t\tprbs_group = lut_prbs_2k[sub_channel_prbs_group];\n\t\tbreak;\n\tcase TRANSMISSION_MODE_4K:\n\t\tprbs_group =  lut_prbs_4k[sub_channel_prbs_group];\n\t\tbreak;\n\tdefault:\n\tcase TRANSMISSION_MODE_8K:\n\t\tprbs_group = lut_prbs_8k[sub_channel_prbs_group];\n\t}\n\n\tdprintk(\"sub_channel_prbs_group = %d , subchannel =%d prbs = 0x%04x\\n\",\n\t\tsub_channel_prbs_group, subchannel, prbs_group);\n\n\treturn prbs_group;\n}\n\nstatic void dib8000_set_13seg_channel(struct dib8000_state *state)\n{\n\tu16 i;\n\tu16 coff_pow = 0x2800;\n\n\tstate->seg_mask = 0x1fff;  \n\n\t \n\tif (state->isdbt_cfg_loaded == 0) {   \n\t\tdib8000_write_word(state, 180, (16 << 6) | 9);\n\t\tdib8000_write_word(state, 187, (4 << 12) | (8 << 5) | 0x2);\n\t\tcoff_pow = 0x2800;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tdib8000_write_word(state, 181+i, coff_pow);\n\n\t\t \n\t\t \n\t\tdib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (3 << 5) | 1);\n\n\t\t \n\t\tdib8000_write_word(state, 340, (8 << 6) | (6 << 0));\n\t\t \n\t\tdib8000_write_word(state, 341, (4 << 3) | (1 << 2) | (1 << 1) | (1 << 0));\n\n\t\tdib8000_write_word(state, 228, 0);   \n\t\tdib8000_write_word(state, 265, 31);  \n\t\tdib8000_write_word(state, 205, 0x200f);  \n\t}\n\n\t \n\n\tif (state->cfg.pll->ifreq == 0)\n\t\tdib8000_write_word(state, 266, ~state->seg_mask | state->seg_diff_mask | 0x40);  \n\n\tdib8000_load_ana_fe_coefs(state, ana_fe_coeff_13seg);\n}\n\nstatic void dib8000_set_subchannel_prbs(struct dib8000_state *state, u16 init_prbs)\n{\n\tu16 reg_1;\n\n\treg_1 = dib8000_read_word(state, 1);\n\tdib8000_write_word(state, 1, (init_prbs << 2) | (reg_1 & 0x3));  \n}\n\nstatic void dib8000_small_fine_tune(struct dib8000_state *state)\n{\n\tu16 i;\n\tconst s16 *ncoeff;\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\n\tdib8000_write_word(state, 352, state->seg_diff_mask);\n\tdib8000_write_word(state, 353, state->seg_mask);\n\n\t \n\tdib8000_write_word(state, 351, (c->isdbt_sb_mode << 9) | (c->isdbt_sb_mode << 8) | (13 << 4) | 5);\n\n\tif (c->isdbt_sb_mode) {\n\t\t \n\t\tswitch (c->transmission_mode) {\n\t\tcase TRANSMISSION_MODE_2K:\n\t\t\t\tif (c->isdbt_partial_reception == 0) {  \n\t\t\t\t\tif (c->layer[0].modulation == DQPSK)  \n\t\t\t\t\t\tncoeff = coeff_2k_sb_1seg_dqpsk;\n\t\t\t\t\telse  \n\t\t\t\t\t\tncoeff = coeff_2k_sb_1seg;\n\t\t\t\t} else {  \n\t\t\t\t\tif (c->layer[0].modulation == DQPSK) {  \n\t\t\t\t\t\tif (c->layer[1].modulation == DQPSK)  \n\t\t\t\t\t\t\tncoeff = coeff_2k_sb_3seg_0dqpsk_1dqpsk;\n\t\t\t\t\t\telse  \n\t\t\t\t\t\t\tncoeff = coeff_2k_sb_3seg_0dqpsk;\n\t\t\t\t\t} else {  \n\t\t\t\t\t\tif (c->layer[1].modulation == DQPSK)  \n\t\t\t\t\t\t\tncoeff = coeff_2k_sb_3seg_1dqpsk;\n\t\t\t\t\t\telse  \n\t\t\t\t\t\t\tncoeff = coeff_2k_sb_3seg;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\tcase TRANSMISSION_MODE_4K:\n\t\t\t\tif (c->isdbt_partial_reception == 0) {  \n\t\t\t\t\tif (c->layer[0].modulation == DQPSK)  \n\t\t\t\t\t\tncoeff = coeff_4k_sb_1seg_dqpsk;\n\t\t\t\t\telse  \n\t\t\t\t\t\tncoeff = coeff_4k_sb_1seg;\n\t\t\t\t} else {  \n\t\t\t\t\tif (c->layer[0].modulation == DQPSK) {  \n\t\t\t\t\t\tif (c->layer[1].modulation == DQPSK)  \n\t\t\t\t\t\t\tncoeff = coeff_4k_sb_3seg_0dqpsk_1dqpsk;\n\t\t\t\t\t\telse  \n\t\t\t\t\t\t\tncoeff = coeff_4k_sb_3seg_0dqpsk;\n\t\t\t\t\t} else {  \n\t\t\t\t\t\tif (c->layer[1].modulation == DQPSK)  \n\t\t\t\t\t\t\tncoeff = coeff_4k_sb_3seg_1dqpsk;\n\t\t\t\t\t\telse  \n\t\t\t\t\t\t\tncoeff = coeff_4k_sb_3seg;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\tcase TRANSMISSION_MODE_AUTO:\n\t\tcase TRANSMISSION_MODE_8K:\n\t\tdefault:\n\t\t\t\tif (c->isdbt_partial_reception == 0) {  \n\t\t\t\t\tif (c->layer[0].modulation == DQPSK)  \n\t\t\t\t\t\tncoeff = coeff_8k_sb_1seg_dqpsk;\n\t\t\t\t\telse  \n\t\t\t\t\t\tncoeff = coeff_8k_sb_1seg;\n\t\t\t\t} else {  \n\t\t\t\t\tif (c->layer[0].modulation == DQPSK) {  \n\t\t\t\t\t\tif (c->layer[1].modulation == DQPSK)  \n\t\t\t\t\t\t\tncoeff = coeff_8k_sb_3seg_0dqpsk_1dqpsk;\n\t\t\t\t\t\telse  \n\t\t\t\t\t\t\tncoeff = coeff_8k_sb_3seg_0dqpsk;\n\t\t\t\t\t} else {  \n\t\t\t\t\t\tif (c->layer[1].modulation == DQPSK)  \n\t\t\t\t\t\t\tncoeff = coeff_8k_sb_3seg_1dqpsk;\n\t\t\t\t\t\telse  \n\t\t\t\t\t\t\tncoeff = coeff_8k_sb_3seg;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tdib8000_write_word(state, 343 + i, ncoeff[i]);\n\t}\n}\n\nstatic const u16 coff_thres_1seg[3] = {300, 150, 80};\nstatic const u16 coff_thres_3seg[3] = {350, 300, 250};\nstatic void dib8000_set_sb_channel(struct dib8000_state *state)\n{\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\tconst u16 *coff;\n\tu16 i;\n\n\tif (c->transmission_mode == TRANSMISSION_MODE_2K || c->transmission_mode == TRANSMISSION_MODE_4K) {\n\t\tdib8000_write_word(state, 219, dib8000_read_word(state, 219) | 0x1);  \n\t\tdib8000_write_word(state, 190, dib8000_read_word(state, 190) | (0x1 << 14));  \n\t} else {\n\t\tdib8000_write_word(state, 219, dib8000_read_word(state, 219) & 0xfffe);  \n\t\tdib8000_write_word(state, 190, dib8000_read_word(state, 190) & 0xbfff);  \n\t}\n\n\tif (c->isdbt_partial_reception == 1)  \n\t\tstate->seg_mask = 0x00E0;\n\telse  \n\t\tstate->seg_mask = 0x0040;\n\n\tdib8000_write_word(state, 268, (dib8000_read_word(state, 268) & 0xF9FF) | 0x0200);\n\n\t \n\t \n\tdib8000_write_word(state, 187, (4 << 12) | (0 << 11) | (63 << 5) | (0x3 << 3) | ((~c->isdbt_partial_reception & 1) << 2) | 0x3);\n\n\tdib8000_write_word(state, 340, (16 << 6) | (8 << 0));  \n\tdib8000_write_word(state, 341, (6 << 3) | (1 << 2) | (1 << 1) | (1 << 0)); \n\n\t \n\tif (c->isdbt_partial_reception == 0) {\n\t\t \n\t\tif (state->mode == 3)\n\t\t\tdib8000_write_word(state, 180, 0x1fcf | ((state->mode - 1) << 14));\n\t\telse\n\t\t\tdib8000_write_word(state, 180, 0x0fcf | ((state->mode - 1) << 14));\n\n\t\t \n\t\tdib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (5 << 5) | 4);\n\t\tcoff = &coff_thres_1seg[0];\n\t} else {    \n\t\tdib8000_write_word(state, 180, 0x1fcf | (1 << 14));\n\t\t \n\t\tdib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (4 << 5) | 4);\n\t\tcoff = &coff_thres_3seg[0];\n\t}\n\n\tdib8000_write_word(state, 228, 1);  \n\tdib8000_write_word(state, 205, dib8000_read_word(state, 205) & 0xfff0);  \n\n\tif (c->isdbt_partial_reception == 0 && c->transmission_mode == TRANSMISSION_MODE_2K)\n\t\tdib8000_write_word(state, 265, 15);  \n\n\t \n\tfor (i = 0 ; i < 3; i++) {\n\t\tdib8000_write_word(state, 181+i, coff[i]);\n\t\tdib8000_write_word(state, 184+i, coff[i]);\n\t}\n\n\t \n\n\tdib8000_write_word(state, 266, ~state->seg_mask | state->seg_diff_mask);  \n\n\tif (c->isdbt_partial_reception == 0)\n\t\tdib8000_write_word(state, 178, 64);  \n\telse\n\t\tdib8000_write_word(state, 178, 32);  \n}\n\nstatic void dib8000_set_isdbt_common_channel(struct dib8000_state *state, u8 seq, u8 autosearching)\n{\n\tu16 p_cfr_left_edge  = 0, p_cfr_right_edge = 0;\n\tu16 tmcc_pow = 0, ana_gain = 0, tmp = 0, i = 0, nbseg_diff = 0 ;\n\tu16 max_constellation = DQPSK;\n\tint init_prbs;\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\n\tif (autosearching)\n\t\tc->isdbt_partial_reception = 1;\n\n\t \n\tdib8000_write_word(state, 10, (seq << 4));\n\n\t \n\tstate->mode = fft_to_mode(state);\n\n\t \n\ttmp = dib8000_read_word(state, 1);\n\tdib8000_write_word(state, 1, (tmp&0xfffc) | (c->guard_interval & 0x3));\n\n\tdib8000_write_word(state, 274, (dib8000_read_word(state, 274) & 0xffcf) | ((c->isdbt_partial_reception & 1) << 5) | ((c->isdbt_sb_mode & 1) << 4));\n\n\t \n\tif (c->isdbt_partial_reception) {\n\t\tstate->seg_diff_mask = (c->layer[0].modulation == DQPSK) << permu_seg[0];\n\t\tfor (i = 1; i < 3; i++)\n\t\t\tnbseg_diff += (c->layer[i].modulation == DQPSK) * c->layer[i].segment_count;\n\t\tfor (i = 0; i < nbseg_diff; i++)\n\t\t\tstate->seg_diff_mask |= 1 << permu_seg[i+1];\n\t} else {\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tnbseg_diff += (c->layer[i].modulation == DQPSK) * c->layer[i].segment_count;\n\t\tfor (i = 0; i < nbseg_diff; i++)\n\t\t\tstate->seg_diff_mask |= 1 << permu_seg[i];\n\t}\n\n\tif (state->seg_diff_mask)\n\t\tdib8000_write_word(state, 268, (dib8000_read_word(state, 268) & 0xF9FF) | 0x0200);\n\telse\n\t\tdib8000_write_word(state, 268, (2 << 9) | 39);  \n\n\tfor (i = 0; i < 3; i++)\n\t\tmax_constellation = dib8000_set_layer(state, i, max_constellation);\n\tif (autosearching == 0) {\n\t\tstate->layer_b_nb_seg = c->layer[1].segment_count;\n\t\tstate->layer_c_nb_seg = c->layer[2].segment_count;\n\t}\n\n\t \n\tdib8000_write_word(state, 0, (state->mode << 13) | state->seg_diff_mask);\n\n\tstate->differential_constellation = (state->seg_diff_mask != 0);\n\n\t \n\tana_gain = dib8000_adp_fine_tune(state, max_constellation);\n\n\t \n\tdib8000_update_ana_gain(state, ana_gain);\n\n\t \n\tif (c->isdbt_partial_reception)  \n\t\tdib8000_load_ana_fe_coefs(state, ana_fe_coeff_3seg);\n\telse\n\t\tdib8000_load_ana_fe_coefs(state, ana_fe_coeff_1seg);  \n\n\t \n\tif (c->isdbt_sb_mode) {\n\t\tdib8000_set_sb_channel(state);\n\t\tinit_prbs = dib8000_get_init_prbs(state,\n\t\t\t\t\t\t  c->isdbt_sb_subchannel);\n\t} else {\n\t\tdib8000_set_13seg_channel(state);\n\t\tinit_prbs = 0xfff;\n\t}\n\n\t \n\tdib8000_small_fine_tune(state);\n\n\tdib8000_set_subchannel_prbs(state, init_prbs);\n\n\t \n\tfor (i = 0; i < 13; i++) {\n\t\tif ((((~state->seg_diff_mask) >> i) & 1) == 1) {\n\t\t\tp_cfr_left_edge  += (1 << i) * ((i == 0) || ((((state->seg_mask & (~state->seg_diff_mask)) >> (i - 1)) & 1) == 0));\n\t\t\tp_cfr_right_edge += (1 << i) * ((i == 12) || ((((state->seg_mask & (~state->seg_diff_mask)) >> (i + 1)) & 1) == 0));\n\t\t}\n\t}\n\tdib8000_write_word(state, 222, p_cfr_left_edge);  \n\tdib8000_write_word(state, 223, p_cfr_right_edge);  \n\t \n\n\tdib8000_write_word(state, 189, ~state->seg_mask | state->seg_diff_mask);  \n\tdib8000_write_word(state, 192, ~state->seg_mask | state->seg_diff_mask);  \n\tdib8000_write_word(state, 225, ~state->seg_mask | state->seg_diff_mask);  \n\n\tif (!autosearching)\n\t\tdib8000_write_word(state, 288, (~state->seg_mask | state->seg_diff_mask) & 0x1fff);  \n\telse\n\t\tdib8000_write_word(state, 288, 0x1fff);  \n\n\tdib8000_write_word(state, 211, state->seg_mask & (~state->seg_diff_mask));  \n\tdib8000_write_word(state, 287, ~state->seg_mask | 0x1000);  \n\n\tdib8000_write_word(state, 178, 32);  \n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\ttmcc_pow += (((c->layer[i].modulation == DQPSK) * 4 + 1) * c->layer[i].segment_count) ;\n\n\t \n\t \n\ttmcc_pow *= (1 << (9-2));\n\tdib8000_write_word(state, 290, tmcc_pow);  \n\tdib8000_write_word(state, 291, tmcc_pow);  \n\tdib8000_write_word(state, 292, tmcc_pow);  \n\t \n\n\t \n\tif (state->isdbt_cfg_loaded == 0)\n\t\tdib8000_write_word(state, 250, 3285);  \n\n\tstate->isdbt_cfg_loaded = 0;\n}\n\nstatic u32 dib8000_wait_lock(struct dib8000_state *state, u32 internal,\n\t\t\t     u32 wait0_ms, u32 wait1_ms, u32 wait2_ms)\n{\n\tu32 value = 0;\t \n\tu16 reg = 11;\t \n\n\tfor (reg = 11; reg < 16; reg += 2) {\n\t\tif (reg == 11) {\n\t\t\tif (state->revision == 0x8090)\n\t\t\t\tvalue = internal * wait1_ms;\n\t\t\telse\n\t\t\t\tvalue = internal * wait0_ms;\n\t\t} else if (reg == 13)\n\t\t\tvalue = internal * wait1_ms;\n\t\telse if (reg == 15)\n\t\t\tvalue = internal * wait2_ms;\n\t\tdib8000_write_word(state, reg, (u16)((value >> 16) & 0xffff));\n\t\tdib8000_write_word(state, (reg + 1), (u16)(value & 0xffff));\n\t}\n\treturn value;\n}\n\nstatic int dib8000_autosearch_start(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\tu8 slist = 0;\n\tu32 value, internal = state->cfg.pll->internal;\n\n\tif (state->revision == 0x8090)\n\t\tinternal = dib8000_read32(state, 23) / 1000;\n\n\tif ((state->revision >= 0x8002) &&\n\t    (state->autosearch_state == AS_SEARCHING_FFT)) {\n\t\tdib8000_write_word(state,  37, 0x0065);  \n\t\tdib8000_write_word(state, 116, 0x0000);  \n\n\t\tdib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x1fff) | (0 << 13) | (1 << 15));  \n\t\tdib8000_write_word(state, 1, (dib8000_read_word(state, 1) & 0xfffc) | 0);  \n\t\tdib8000_write_word(state, 6, 0);  \n\t\tdib8000_write_word(state, 7, 0);  \n\t\tdib8000_write_word(state, 8, 0);  \n\t\tdib8000_write_word(state, 10, (dib8000_read_word(state, 10) & 0x200) | (16 << 4) | (0 << 0));  \n\n\t\tif (state->revision == 0x8090)\n\t\t\tvalue = dib8000_wait_lock(state, internal, 10, 10, 10);  \n\t\telse\n\t\t\tvalue = dib8000_wait_lock(state, internal, 20, 20, 20);  \n\n\t\tdib8000_write_word(state, 17, 0);\n\t\tdib8000_write_word(state, 18, 200);  \n\t\tdib8000_write_word(state, 19, 0);\n\t\tdib8000_write_word(state, 20, 400);  \n\t\tdib8000_write_word(state, 21, (value >> 16) & 0xffff);  \n\t\tdib8000_write_word(state, 22, value & 0xffff);\n\n\t\tif (state->revision == 0x8090)\n\t\t\tdib8000_write_word(state, 32, (dib8000_read_word(state, 32) & 0xf0ff) | (0 << 8));  \n\t\telse\n\t\t\tdib8000_write_word(state, 32, (dib8000_read_word(state, 32) & 0xf0ff) | (9 << 8));  \n\t\tdib8000_write_word(state, 355, 2);  \n\n\t\t \n\t\tdib8000_write_word(state, 356, 0);\n\t\tdib8000_write_word(state, 357, 0x111);\n\n\t\tdib8000_write_word(state, 770, (dib8000_read_word(state, 770) & 0xdfff) | (1 << 13));  \n\t\tdib8000_write_word(state, 770, (dib8000_read_word(state, 770) & 0xdfff) | (0 << 13));  \n\t\tdib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x7ff) | (0 << 15) | (1 << 13));  \n\t} else if ((state->revision >= 0x8002) &&\n\t\t   (state->autosearch_state == AS_SEARCHING_GUARD)) {\n\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\tc->inversion = 0;\n\t\tc->layer[0].modulation = QAM_64;\n\t\tc->layer[0].fec = FEC_2_3;\n\t\tc->layer[0].interleaving = 0;\n\t\tc->layer[0].segment_count = 13;\n\n\t\tslist = 16;\n\t\tc->transmission_mode = state->found_nfft;\n\n\t\tdib8000_set_isdbt_common_channel(state, slist, 1);\n\n\t\t \n\t\tdib8000_write_word(state, 6, 0x4);\n\t\tif (state->revision == 0x8090)\n\t\t\tdib8000_write_word(state, 7, ((1 << 12) | (1 << 11) | (1 << 10))); \n\t\telse\n\t\t\tdib8000_write_word(state, 7, 0x8);\n\t\tdib8000_write_word(state, 8, 0x1000);\n\n\t\t \n\t\tif (state->revision == 0x8090)\n\t\t\tdib8000_wait_lock(state, internal, 50, 100, 1000);  \n\t\telse\n\t\t\tdib8000_wait_lock(state, internal, 50, 200, 1000);  \n\n\t\tdib8000_write_word(state, 355, 3);  \n\n\t\t \n\t\tdib8000_write_word(state, 356, 0);\n\t\tdib8000_write_word(state, 357, 0xf);\n\n\t\tvalue = dib8000_read_word(state, 0);\n\t\tdib8000_write_word(state, 0, (u16)((1 << 15) | value));\n\t\tdib8000_read_word(state, 1284);   \n\t\tdib8000_write_word(state, 0, (u16)value);\n\t} else {\n\t\tc->inversion = 0;\n\t\tc->layer[0].modulation = QAM_64;\n\t\tc->layer[0].fec = FEC_2_3;\n\t\tc->layer[0].interleaving = 0;\n\t\tc->layer[0].segment_count = 13;\n\t\tif (!c->isdbt_sb_mode)\n\t\t\tc->layer[0].segment_count = 13;\n\n\t\t \n\t\tif (c->isdbt_sb_mode) {\n\t\t\tslist = 7;\n\t\t\tdib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));\n\t\t} else {\n\t\t\tif (c->guard_interval == GUARD_INTERVAL_AUTO) {\n\t\t\t\tif (c->transmission_mode == TRANSMISSION_MODE_AUTO) {\n\t\t\t\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t\t\t\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\t\t\t\tslist = 7;\n\t\t\t\t\tdib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));   \n\t\t\t\t} else {\n\t\t\t\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\t\t\t\tslist = 3;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (c->transmission_mode == TRANSMISSION_MODE_AUTO) {\n\t\t\t\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t\t\t\t\tslist = 2;\n\t\t\t\t\tdib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));   \n\t\t\t\t} else\n\t\t\t\t\tslist = 0;\n\t\t\t}\n\t\t}\n\t\tdprintk(\"Using list for autosearch : %d\\n\", slist);\n\n\t\tdib8000_set_isdbt_common_channel(state, slist, 1);\n\n\t\t \n\t\tdib8000_write_word(state, 6, 0x4);\n\t\tif (state->revision == 0x8090)\n\t\t\tdib8000_write_word(state, 7, (1 << 12) | (1 << 11) | (1 << 10));\n\t\telse\n\t\t\tdib8000_write_word(state, 7, 0x8);\n\t\tdib8000_write_word(state, 8, 0x1000);\n\n\t\t \n\t\tif (state->revision == 0x8090)\n\t\t\tdib8000_wait_lock(state, internal, 50, 200, 1000);  \n\t\telse\n\t\t\tdib8000_wait_lock(state, internal, 50, 100, 1000);  \n\n\t\tvalue = dib8000_read_word(state, 0);\n\t\tdib8000_write_word(state, 0, (u16)((1 << 15) | value));\n\t\tdib8000_read_word(state, 1284);   \n\t\tdib8000_write_word(state, 0, (u16)value);\n\t}\n\treturn 0;\n}\n\nstatic int dib8000_autosearch_irq(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu16 irq_pending = dib8000_read_word(state, 1284);\n\n\tif ((state->revision >= 0x8002) &&\n\t    (state->autosearch_state == AS_SEARCHING_FFT)) {\n\t\tif (irq_pending & 0x1) {\n\t\t\tdprintk(\"dib8000_autosearch_irq: max correlation result available\\n\");\n\t\t\treturn 3;\n\t\t}\n\t} else {\n\t\tif (irq_pending & 0x1) {\t \n\t\t\tdprintk(\"dib8000_autosearch_irq failed\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (irq_pending & 0x2) {\t \n\t\t\tdprintk(\"dib8000_autosearch_irq succeeded\\n\");\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\treturn 0;\t\t\n}\n\nstatic void dib8000_viterbi_state(struct dib8000_state *state, u8 onoff)\n{\n\tu16 tmp;\n\n\ttmp = dib8000_read_word(state, 771);\n\tif (onoff)  \n\t\tdib8000_write_word(state, 771, tmp & 0xfffd);\n\telse  \n\t\tdib8000_write_word(state, 771, tmp | (1<<1));\n}\n\nstatic void dib8000_set_dds(struct dib8000_state *state, s32 offset_khz)\n{\n\ts16 unit_khz_dds_val;\n\tu32 abs_offset_khz = abs(offset_khz);\n\tu32 dds = state->cfg.pll->ifreq & 0x1ffffff;\n\tu8 invert = !!(state->cfg.pll->ifreq & (1 << 25));\n\tu8 ratio;\n\n\tif (state->revision == 0x8090) {\n\t\tratio = 4;\n\t\tunit_khz_dds_val = (1<<26) / (dib8000_read32(state, 23) / 1000);\n\t\tif (offset_khz < 0)\n\t\t\tdds = (1 << 26) - (abs_offset_khz * unit_khz_dds_val);\n\t\telse\n\t\t\tdds = (abs_offset_khz * unit_khz_dds_val);\n\n\t\tif (invert)\n\t\t\tdds = (1<<26) - dds;\n\t} else {\n\t\tratio = 2;\n\t\tunit_khz_dds_val = (u16) (67108864 / state->cfg.pll->internal);\n\n\t\tif (offset_khz < 0)\n\t\t\tunit_khz_dds_val *= -1;\n\n\t\t \n\t\tif (invert)\n\t\t\tdds -= abs_offset_khz * unit_khz_dds_val;\n\t\telse\n\t\t\tdds += abs_offset_khz * unit_khz_dds_val;\n\t}\n\n\tdprintk(\"setting a DDS frequency offset of %c%dkHz\\n\", invert ? '-' : ' ', dds / unit_khz_dds_val);\n\n\tif (abs_offset_khz <= (state->cfg.pll->internal / ratio)) {\n\t\t \n\t\tdib8000_write_word(state, 26, invert);\n\t\tdib8000_write_word(state, 27, (u16)(dds >> 16) & 0x1ff);\n\t\tdib8000_write_word(state, 28, (u16)(dds & 0xffff));\n\t}\n}\n\nstatic void dib8000_set_frequency_offset(struct dib8000_state *state)\n{\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\tint i;\n\tu32 current_rf;\n\tint total_dds_offset_khz;\n\n\tif (state->fe[0]->ops.tuner_ops.get_frequency)\n\t\tstate->fe[0]->ops.tuner_ops.get_frequency(state->fe[0], &current_rf);\n\telse\n\t\tcurrent_rf = c->frequency;\n\tcurrent_rf /= 1000;\n\ttotal_dds_offset_khz = (int)current_rf - (int)c->frequency / 1000;\n\n\tif (c->isdbt_sb_mode) {\n\t\tstate->subchannel = c->isdbt_sb_subchannel;\n\n\t\ti = dib8000_read_word(state, 26) & 1;  \n\t\tdib8000_write_word(state, 26, c->inversion ^ i);\n\n\t\tif (state->cfg.pll->ifreq == 0) {  \n\t\t\tif ((c->inversion ^ i) == 0)\n\t\t\t\tdib8000_write_word(state, 26, dib8000_read_word(state, 26) | 1);\n\t\t} else {\n\t\t\tif ((c->inversion ^ i) == 0)\n\t\t\t\ttotal_dds_offset_khz *= -1;\n\t\t}\n\t}\n\n\tdprintk(\"%dkhz tuner offset (frequency = %dHz & current_rf = %dHz) total_dds_offset_hz = %d\\n\", c->frequency - current_rf, c->frequency, current_rf, total_dds_offset_khz);\n\n\t \n\tdib8000_set_dds(state, total_dds_offset_khz);\n}\n\nstatic u16 LUT_isdbt_symbol_duration[4] = { 26, 101, 63 };\n\nstatic u32 dib8000_get_symbol_duration(struct dib8000_state *state)\n{\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\tu16 i;\n\n\tswitch (c->transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\t\t\ti = 0;\n\t\t\tbreak;\n\tcase TRANSMISSION_MODE_4K:\n\t\t\ti = 2;\n\t\t\tbreak;\n\tdefault:\n\tcase TRANSMISSION_MODE_AUTO:\n\tcase TRANSMISSION_MODE_8K:\n\t\t\ti = 1;\n\t\t\tbreak;\n\t}\n\n\treturn (LUT_isdbt_symbol_duration[i] / (c->bandwidth_hz / 1000)) + 1;\n}\n\nstatic void dib8000_set_isdbt_loop_params(struct dib8000_state *state, enum param_loop_step loop_step)\n{\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\tu16 reg_32 = 0, reg_37 = 0;\n\n\tswitch (loop_step) {\n\tcase LOOP_TUNE_1:\n\t\t\tif (c->isdbt_sb_mode)  {\n\t\t\t\tif (c->isdbt_partial_reception == 0) {\n\t\t\t\t\treg_32 = ((11 - state->mode) << 12) | (6 << 8) | 0x40;  \n\t\t\t\t\treg_37 = (3 << 5) | (0 << 4) | (10 - state->mode);  \n\t\t\t\t} else {  \n\t\t\t\t\treg_32 = ((10 - state->mode) << 12) | (6 << 8) | 0x60;  \n\t\t\t\t\treg_37 = (3 << 5) | (0 << 4) | (9 - state->mode);  \n\t\t\t\t}\n\t\t\t} else {  \n\t\t\t\treg_32 = ((9 - state->mode) << 12) | (6 << 8) | 0x80;  \n\t\t\t\treg_37 = (3 << 5) | (0 << 4) | (8 - state->mode);  \n\t\t\t}\n\t\t\tbreak;\n\tcase LOOP_TUNE_2:\n\t\t\tif (c->isdbt_sb_mode)  {\n\t\t\t\tif (c->isdbt_partial_reception == 0) {   \n\t\t\t\t\treg_32 = ((13-state->mode) << 12) | (6 << 8) | 0x40;  \n\t\t\t\t\treg_37 = (12-state->mode) | ((5 + state->mode) << 5);\n\t\t\t\t} else {   \n\t\t\t\t\treg_32 = ((12-state->mode) << 12) | (6 << 8) | 0x60;  \n\t\t\t\t\treg_37 = (11-state->mode) | ((5 + state->mode) << 5);\n\t\t\t\t}\n\t\t\t} else {   \n\t\t\t\treg_32 = ((11-state->mode) << 12) | (6 << 8) | 0x80;  \n\t\t\t\treg_37 = ((5+state->mode) << 5) | (10 - state->mode);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tdib8000_write_word(state, 32, reg_32);\n\tdib8000_write_word(state, 37, reg_37);\n}\n\nstatic void dib8000_demod_restart(struct dib8000_state *state)\n{\n\tdib8000_write_word(state, 770, 0x4000);\n\tdib8000_write_word(state, 770, 0x0000);\n\treturn;\n}\n\nstatic void dib8000_set_sync_wait(struct dib8000_state *state)\n{\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\tu16 sync_wait = 64;\n\n\t \n\tswitch (c->transmission_mode) {\n\tcase TRANSMISSION_MODE_8K:\n\t\t\tsync_wait = 256;\n\t\t\tbreak;\n\tcase TRANSMISSION_MODE_4K:\n\t\t\tsync_wait = 128;\n\t\t\tbreak;\n\tdefault:\n\tcase TRANSMISSION_MODE_2K:\n\t\t\tsync_wait =  64;\n\t\t\tbreak;\n\t}\n\n\tif (state->cfg.diversity_delay == 0)\n\t\tsync_wait = (sync_wait * (1 << (c->guard_interval)) * 3) / 2 + 48;  \n\telse\n\t\tsync_wait = (sync_wait * (1 << (c->guard_interval)) * 3) / 2 + state->cfg.diversity_delay;  \n\n\tdib8000_write_word(state, 273, (dib8000_read_word(state, 273) & 0x000f) | (sync_wait << 4));\n}\n\nstatic unsigned long dib8000_get_timeout(struct dib8000_state *state, u32 delay, enum timeout_mode mode)\n{\n\tif (mode == SYMBOL_DEPENDENT_ON)\n\t\tdelay *= state->symbol_duration;\n\n\treturn jiffies + usecs_to_jiffies(delay * 100);\n}\n\nstatic s32 dib8000_get_status(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\treturn state->status;\n}\n\nstatic enum frontend_tune_state dib8000_get_tune_state(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\treturn state->tune_state;\n}\n\nstatic int dib8000_set_tune_state(struct dvb_frontend *fe, enum frontend_tune_state tune_state)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\n\tstate->tune_state = tune_state;\n\treturn 0;\n}\n\nstatic int dib8000_tune_restart_from_demod(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\n\tstate->status = FE_STATUS_TUNE_PENDING;\n\tstate->tune_state = CT_DEMOD_START;\n\treturn 0;\n}\n\nstatic u16 dib8000_read_lock(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\n\tif (state->revision == 0x8090)\n\t\treturn dib8000_read_word(state, 570);\n\treturn dib8000_read_word(state, 568);\n}\n\nstatic int dib8090p_init_sdram(struct dib8000_state *state)\n{\n\tu16 reg = 0;\n\tdprintk(\"init sdram\\n\");\n\n\treg = dib8000_read_word(state, 274) & 0xfff0;\n\tdib8000_write_word(state, 274, reg | 0x7);  \n\n\tdib8000_write_word(state, 1803, (7 << 2));\n\n\treg = dib8000_read_word(state, 1280);\n\tdib8000_write_word(state, 1280,  reg | (1 << 2));  \n\tdib8000_write_word(state, 1280,  reg);  \n\n\treturn 0;\n}\n\n \nstatic int is_manual_mode(struct dtv_frontend_properties *c)\n{\n\tint i, n_segs = 0;\n\n\t \n\tif (c->delivery_system != SYS_ISDBT)\n\t\treturn 0;\n\n\t \n\tif (c->transmission_mode == TRANSMISSION_MODE_AUTO) {\n\t\tdprintk(\"transmission mode auto\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (c->guard_interval == GUARD_INTERVAL_AUTO) {\n\t\tdprintk(\"guard interval auto\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (!c->isdbt_layer_enabled) {\n\t\tdprintk(\"no layer modulation specified\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tif (!(c->isdbt_layer_enabled & 1 << i))\n\t\t\tcontinue;\n\n\t\tif ((c->layer[i].segment_count > 13) ||\n\t\t    (c->layer[i].segment_count == 0)) {\n\t\t\tc->isdbt_layer_enabled &= ~(1 << i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tn_segs += c->layer[i].segment_count;\n\n\t\tif ((c->layer[i].modulation == QAM_AUTO) ||\n\t\t    (c->layer[i].fec == FEC_AUTO)) {\n\t\t\tdprintk(\"layer %c has either modulation or FEC auto\\n\",\n\t\t\t\t'A' + i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (n_segs == 0 || n_segs > 13) {\n\t\tdprintk(\"number of segments is invalid\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\treturn 1;\n}\n\nstatic int dib8000_tune(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\tenum frontend_tune_state *tune_state = &state->tune_state;\n\n\tu16 locks, deeper_interleaver = 0, i;\n\tint ret = 1;  \n\n\tunsigned long *timeout = &state->timeout;\n\tunsigned long now = jiffies;\n\tu16 init_prbs;\n#ifdef DIB8000_AGC_FREEZE\n\tu16 agc1, agc2;\n#endif\n\n\tu32 corm[4] = {0, 0, 0, 0};\n\tu8 find_index, max_value;\n\n#if 0\n\tif (*tune_state < CT_DEMOD_STOP)\n\t\tdprintk(\"IN: context status = %d, TUNE_STATE %d autosearch step = %u jiffies = %lu\\n\",\n\t\t\tstate->channel_parameters_set, *tune_state, state->autosearch_state, now);\n#endif\n\n\tswitch (*tune_state) {\n\tcase CT_DEMOD_START:  \n\t\tdib8000_reset_stats(fe);\n\n\t\tif (state->revision == 0x8090)\n\t\t\tdib8090p_init_sdram(state);\n\t\tstate->status = FE_STATUS_TUNE_PENDING;\n\t\tstate->channel_parameters_set = is_manual_mode(c);\n\n\t\tdprintk(\"Tuning channel on %s search mode\\n\",\n\t\t\tstate->channel_parameters_set ? \"manual\" : \"auto\");\n\n\t\tdib8000_viterbi_state(state, 0);  \n\n\t\t \n\t\tdib8000_write_word(state, 285, dib8000_read_word(state, 285) & 0x60);\n\n\t\tdib8000_set_frequency_offset(state);\n\t\tdib8000_set_bandwidth(fe, c->bandwidth_hz / 1000);\n\n\t\tif (state->channel_parameters_set == 0) {  \n#ifdef DIB8000_AGC_FREEZE\n\t\t\tif (state->revision != 0x8090) {\n\t\t\t\tstate->agc1_max = dib8000_read_word(state, 108);\n\t\t\t\tstate->agc1_min = dib8000_read_word(state, 109);\n\t\t\t\tstate->agc2_max = dib8000_read_word(state, 110);\n\t\t\t\tstate->agc2_min = dib8000_read_word(state, 111);\n\t\t\t\tagc1 = dib8000_read_word(state, 388);\n\t\t\t\tagc2 = dib8000_read_word(state, 389);\n\t\t\t\tdib8000_write_word(state, 108, agc1);\n\t\t\t\tdib8000_write_word(state, 109, agc1);\n\t\t\t\tdib8000_write_word(state, 110, agc2);\n\t\t\t\tdib8000_write_word(state, 111, agc2);\n\t\t\t}\n#endif\n\t\t\tstate->autosearch_state = AS_SEARCHING_FFT;\n\t\t\tstate->found_nfft = TRANSMISSION_MODE_AUTO;\n\t\t\tstate->found_guard = GUARD_INTERVAL_AUTO;\n\t\t\t*tune_state = CT_DEMOD_SEARCH_NEXT;\n\t\t} else {  \n\t\t\tstate->autosearch_state = AS_DONE;\n\t\t\t*tune_state = CT_DEMOD_STEP_3;\n\t\t}\n\t\tstate->symbol_duration = dib8000_get_symbol_duration(state);\n\t\tbreak;\n\n\tcase CT_DEMOD_SEARCH_NEXT:  \n\t\tdib8000_autosearch_start(fe);\n\t\tif (state->revision == 0x8090)\n\t\t\tret = 50;\n\t\telse\n\t\t\tret = 15;\n\t\t*tune_state = CT_DEMOD_STEP_1;\n\t\tbreak;\n\n\tcase CT_DEMOD_STEP_1:  \n\t\tswitch (dib8000_autosearch_irq(fe)) {\n\t\tcase 1:  \n\t\t\tstate->status = FE_STATUS_TUNE_FAILED;\n\t\t\tstate->autosearch_state = AS_DONE;\n\t\t\t*tune_state = CT_DEMOD_STOP;  \n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tstate->status = FE_STATUS_FFT_SUCCESS;  \n\t\t\t*tune_state = CT_DEMOD_STEP_3;\n\t\t\tif (state->autosearch_state == AS_SEARCHING_GUARD)\n\t\t\t\t*tune_state = CT_DEMOD_STEP_2;\n\t\t\telse\n\t\t\t\tstate->autosearch_state = AS_DONE;\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\t*tune_state = CT_DEMOD_STEP_2;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase CT_DEMOD_STEP_2:\n\t\tswitch (state->autosearch_state) {\n\t\tcase AS_SEARCHING_FFT:\n\t\t\t \n\t\t\tif (state->revision == 0x8090) {\n\t\t\t\tcorm[2] = (dib8000_read_word(state, 596) << 16) | (dib8000_read_word(state, 597));\n\t\t\t\tcorm[1] = (dib8000_read_word(state, 598) << 16) | (dib8000_read_word(state, 599));\n\t\t\t\tcorm[0] = (dib8000_read_word(state, 600) << 16) | (dib8000_read_word(state, 601));\n\t\t\t} else {\n\t\t\t\tcorm[2] = (dib8000_read_word(state, 594) << 16) | (dib8000_read_word(state, 595));\n\t\t\t\tcorm[1] = (dib8000_read_word(state, 596) << 16) | (dib8000_read_word(state, 597));\n\t\t\t\tcorm[0] = (dib8000_read_word(state, 598) << 16) | (dib8000_read_word(state, 599));\n\t\t\t}\n\t\t\t \n\n\t\t\tmax_value = 0;\n\t\t\tfor (find_index = 1 ; find_index < 3 ; find_index++) {\n\t\t\t\tif (corm[max_value] < corm[find_index])\n\t\t\t\t\tmax_value = find_index ;\n\t\t\t}\n\n\t\t\tswitch (max_value) {\n\t\t\tcase 0:\n\t\t\t\tstate->found_nfft = TRANSMISSION_MODE_2K;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tstate->found_nfft = TRANSMISSION_MODE_4K;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tdefault:\n\t\t\t\tstate->found_nfft = TRANSMISSION_MODE_8K;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\n\t\t\t*tune_state = CT_DEMOD_SEARCH_NEXT;\n\t\t\tstate->autosearch_state = AS_SEARCHING_GUARD;\n\t\t\tif (state->revision == 0x8090)\n\t\t\t\tret = 50;\n\t\t\telse\n\t\t\t\tret = 10;\n\t\t\tbreak;\n\t\tcase AS_SEARCHING_GUARD:\n\t\t\t \n\t\t\tif (state->revision == 0x8090)\n\t\t\t\tstate->found_guard = dib8000_read_word(state, 572) & 0x3;\n\t\t\telse\n\t\t\t\tstate->found_guard = dib8000_read_word(state, 570) & 0x3;\n\t\t\t \n\n\t\t\t*tune_state = CT_DEMOD_STEP_3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tstate->status = FE_STATUS_TUNE_FAILED;\n\t\t\tstate->autosearch_state = AS_DONE;\n\t\t\t*tune_state = CT_DEMOD_STOP;  \n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase CT_DEMOD_STEP_3:  \n\t\tdib8000_set_isdbt_loop_params(state, LOOP_TUNE_1);\n\t\tdib8000_set_isdbt_common_channel(state, 0, 0); \n\t\t*tune_state = CT_DEMOD_STEP_4;\n\t\tbreak;\n\n\tcase CT_DEMOD_STEP_4:  \n\t\tdib8000_demod_restart(state);\n\n\t\tdib8000_set_sync_wait(state);\n\t\tdib8000_set_diversity_in(state->fe[0], state->diversity_onoff);\n\n\t\tlocks = (dib8000_read_word(state, 180) >> 6) & 0x3f;  \n\t\t \n\t\t*timeout = dib8000_get_timeout(state, 2 * locks, SYMBOL_DEPENDENT_ON);\n\t\t*tune_state = CT_DEMOD_STEP_5;\n\t\tbreak;\n\n\tcase CT_DEMOD_STEP_5:  \n\t\tlocks = dib8000_read_lock(fe);\n\t\tif (locks & (0x3 << 11)) {  \n\t\t\tdib8000_update_timf(state);  \n\t\t\tif (!state->differential_constellation) {\n\t\t\t\t \n\t\t\t\t*timeout = dib8000_get_timeout(state, (20 * ((dib8000_read_word(state, 188)>>5)&0x1f)), SYMBOL_DEPENDENT_ON);\n\t\t\t\t*tune_state = CT_DEMOD_STEP_7;\n\t\t\t} else {\n\t\t\t\t*tune_state = CT_DEMOD_STEP_8;\n\t\t\t}\n\t\t} else if (time_after(now, *timeout)) {\n\t\t\t*tune_state = CT_DEMOD_STEP_6;  \n\t\t}\n\t\tbreak;\n\n\tcase CT_DEMOD_STEP_6:  \n\t\tif ((state->fe[1] != NULL) && (state->output_mode != OUTMODE_DIVERSITY)) {\n\t\t\t \n\t\t\tif (dib8000_get_status(state->fe[1]) <= FE_STATUS_STD_SUCCESS)  \n\t\t\t\t*tune_state = CT_DEMOD_STEP_8;  \n\t\t\telse if (dib8000_get_status(state->fe[1]) >= FE_STATUS_TUNE_TIME_TOO_SHORT) {  \n\t\t\t\t*tune_state = CT_DEMOD_STOP;  \n\t\t\t\tdib8000_viterbi_state(state, 1);  \n\t\t\t\tdib8000_set_isdbt_loop_params(state, LOOP_TUNE_2);\n\t\t\t\tstate->status = FE_STATUS_TUNE_FAILED;\n\t\t\t}\n\t\t} else {\n\t\t\tdib8000_viterbi_state(state, 1);  \n\t\t\tdib8000_set_isdbt_loop_params(state, LOOP_TUNE_2);\n\t\t\t*tune_state = CT_DEMOD_STOP;  \n\t\t\tstate->status = FE_STATUS_TUNE_FAILED;\n\t\t}\n\t\tbreak;\n\n\tcase CT_DEMOD_STEP_7:  \n\t\tlocks = dib8000_read_lock(fe);\n\t\tif (locks & (1<<10)) {  \n\t\t\tret = 14;  \n\t\t\t*tune_state = CT_DEMOD_STEP_8;\n\t\t} else if (time_after(now, *timeout))\n\t\t\t*tune_state = CT_DEMOD_STEP_6;  \n\t\tbreak;\n\n\tcase CT_DEMOD_STEP_8:  \n\t\tdib8000_viterbi_state(state, 1);  \n\t\tdib8000_set_isdbt_loop_params(state, LOOP_TUNE_2);\n\n\t\t \n\t\tif (c->isdbt_sb_mode\n\t\t    && c->isdbt_sb_subchannel < 14\n\t\t    && !state->differential_constellation) {\n\t\t\tstate->subchannel = 0;\n\t\t\t*tune_state = CT_DEMOD_STEP_11;\n\t\t} else {\n\t\t\t*tune_state = CT_DEMOD_STEP_9;\n\t\t\tstate->status = FE_STATUS_LOCKED;\n\t\t}\n\t\tbreak;\n\n\tcase CT_DEMOD_STEP_9:  \n\t\tif ((state->revision == 0x8090) || ((dib8000_read_word(state, 1291) >> 9) & 0x1)) {  \n\t\t\t \n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tif (c->layer[i].interleaving >= deeper_interleaver) {\n\t\t\t\t\tdprintk(\"layer%i: time interleaver = %d\\n\", i, c->layer[i].interleaving);\n\t\t\t\t\tif (c->layer[i].segment_count > 0) {  \n\t\t\t\t\t\tdeeper_interleaver = c->layer[0].interleaving;\n\t\t\t\t\t\tstate->longest_intlv_layer = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (deeper_interleaver == 0)\n\t\t\t\tlocks = 2;  \n\t\t\telse if (deeper_interleaver == 3)\n\t\t\t\tlocks = 8;\n\t\t\telse\n\t\t\t\tlocks = 2 * deeper_interleaver;\n\n\t\t\tif (state->diversity_onoff != 0)  \n\t\t\t\tlocks *= 2;\n\n\t\t\t*timeout = now + msecs_to_jiffies(200 * locks);  \n\t\t\tdprintk(\"Deeper interleaver mode = %d on layer %d : timeout mult factor = %d => will use timeout = %ld\\n\",\n\t\t\t\tdeeper_interleaver, state->longest_intlv_layer, locks, *timeout);\n\n\t\t\t*tune_state = CT_DEMOD_STEP_10;\n\t\t} else\n\t\t\t*tune_state = CT_DEMOD_STOP;\n\t\tbreak;\n\n\tcase CT_DEMOD_STEP_10:  \n\t\tlocks = dib8000_read_lock(fe);\n\t\tif (locks&(1<<(7-state->longest_intlv_layer))) {  \n\t\t\tdprintk(\"ISDB-T layer locks: Layer A %s, Layer B %s, Layer C %s\\n\",\n\t\t\t\tc->layer[0].segment_count ? (locks >> 7) & 0x1 ? \"locked\" : \"NOT LOCKED\" : \"not enabled\",\n\t\t\t\tc->layer[1].segment_count ? (locks >> 6) & 0x1 ? \"locked\" : \"NOT LOCKED\" : \"not enabled\",\n\t\t\t\tc->layer[2].segment_count ? (locks >> 5) & 0x1 ? \"locked\" : \"NOT LOCKED\" : \"not enabled\");\n\t\t\tif (c->isdbt_sb_mode\n\t\t\t    && c->isdbt_sb_subchannel < 14\n\t\t\t    && !state->differential_constellation)\n\t\t\t\t \n\t\t\t\tstate->status = FE_STATUS_DEMOD_SUCCESS;\n\t\t\telse\n\t\t\t\tstate->status = FE_STATUS_DATA_LOCKED;\n\t\t\t*tune_state = CT_DEMOD_STOP;\n\t\t} else if (time_after(now, *timeout)) {\n\t\t\tif (c->isdbt_sb_mode\n\t\t\t    && c->isdbt_sb_subchannel < 14\n\t\t\t    && !state->differential_constellation) {  \n\t\t\t\tstate->subchannel += 3;\n\t\t\t\t*tune_state = CT_DEMOD_STEP_11;\n\t\t\t} else {  \n\t\t\t\tif (locks & (0x7 << 5)) {\n\t\t\t\t\tdprintk(\"Not all ISDB-T layers locked in %d ms: Layer A %s, Layer B %s, Layer C %s\\n\",\n\t\t\t\t\t\tjiffies_to_msecs(now - *timeout),\n\t\t\t\t\t\tc->layer[0].segment_count ? (locks >> 7) & 0x1 ? \"locked\" : \"NOT LOCKED\" : \"not enabled\",\n\t\t\t\t\t\tc->layer[1].segment_count ? (locks >> 6) & 0x1 ? \"locked\" : \"NOT LOCKED\" : \"not enabled\",\n\t\t\t\t\t\tc->layer[2].segment_count ? (locks >> 5) & 0x1 ? \"locked\" : \"NOT LOCKED\" : \"not enabled\");\n\n\t\t\t\t\tstate->status = FE_STATUS_DATA_LOCKED;\n\t\t\t\t} else\n\t\t\t\t\tstate->status = FE_STATUS_TUNE_FAILED;\n\t\t\t\t*tune_state = CT_DEMOD_STOP;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase CT_DEMOD_STEP_11:   \n\t\tinit_prbs = dib8000_get_init_prbs(state, state->subchannel);\n\n\t\tif (init_prbs) {\n\t\t\tdib8000_set_subchannel_prbs(state, init_prbs);\n\t\t\t*tune_state = CT_DEMOD_STEP_9;\n\t\t} else {\n\t\t\t*tune_state = CT_DEMOD_STOP;\n\t\t\tstate->status = FE_STATUS_TUNE_FAILED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (*tune_state) {\n\tcase CT_DEMOD_STOP:  \n#ifdef DIB8000_AGC_FREEZE\n\t\tif ((state->revision != 0x8090) && (state->agc1_max != 0)) {\n\t\t\tdib8000_write_word(state, 108, state->agc1_max);\n\t\t\tdib8000_write_word(state, 109, state->agc1_min);\n\t\t\tdib8000_write_word(state, 110, state->agc2_max);\n\t\t\tdib8000_write_word(state, 111, state->agc2_min);\n\t\t\tstate->agc1_max = 0;\n\t\t\tstate->agc1_min = 0;\n\t\t\tstate->agc2_max = 0;\n\t\t\tstate->agc2_min = 0;\n\t\t}\n#endif\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((ret > 0) && (*tune_state > CT_DEMOD_STEP_3))\n\t\treturn ret * state->symbol_duration;\n\tif ((ret > 0) && (ret < state->symbol_duration))\n\t\treturn state->symbol_duration;  \n\treturn ret;\n}\n\nstatic int dib8000_wakeup(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu8 index_frontend;\n\tint ret;\n\n\tdib8000_set_power_mode(state, DIB8000_POWER_ALL);\n\tdib8000_set_adc_state(state, DIBX000_ADC_ON);\n\tif (dib8000_set_adc_state(state, DIBX000_SLOW_ADC_ON) != 0)\n\t\tdprintk(\"could not start Slow ADC\\n\");\n\n\tif (state->revision == 0x8090)\n\t\tdib8000_sad_calib(state);\n\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\tret = state->fe[index_frontend]->ops.init(state->fe[index_frontend]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dib8000_sleep(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu8 index_frontend;\n\tint ret;\n\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\tret = state->fe[index_frontend]->ops.sleep(state->fe[index_frontend]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (state->revision != 0x8090)\n\t\tdib8000_set_output_mode(fe, OUTMODE_HIGH_Z);\n\tdib8000_set_power_mode(state, DIB8000_POWER_INTERFACE_ONLY);\n\treturn dib8000_set_adc_state(state, DIBX000_SLOW_ADC_OFF) | dib8000_set_adc_state(state, DIBX000_ADC_OFF);\n}\n\nstatic int dib8000_read_status(struct dvb_frontend *fe, enum fe_status *stat);\n\nstatic int dib8000_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *c)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu16 i, val = 0;\n\tenum fe_status stat = 0;\n\tu8 index_frontend, sub_index_frontend;\n\n\tc->bandwidth_hz = 6000000;\n\n\t \n\tdib8000_read_status(fe, &stat);\n\tif (!(stat & FE_HAS_SYNC))\n\t\treturn 0;\n\n\tdprintk(\"dib8000_get_frontend: TMCC lock\\n\");\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\tstate->fe[index_frontend]->ops.read_status(state->fe[index_frontend], &stat);\n\t\tif (stat&FE_HAS_SYNC) {\n\t\t\tdprintk(\"TMCC lock on the slave%i\\n\", index_frontend);\n\t\t\t \n\t\t\tstate->fe[index_frontend]->ops.get_frontend(state->fe[index_frontend], c);\n\t\t\tfor (sub_index_frontend = 0; (sub_index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[sub_index_frontend] != NULL); sub_index_frontend++) {\n\t\t\t\tif (sub_index_frontend != index_frontend) {\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.isdbt_sb_mode = state->fe[index_frontend]->dtv_property_cache.isdbt_sb_mode;\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.inversion = state->fe[index_frontend]->dtv_property_cache.inversion;\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.transmission_mode = state->fe[index_frontend]->dtv_property_cache.transmission_mode;\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.guard_interval = state->fe[index_frontend]->dtv_property_cache.guard_interval;\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.isdbt_partial_reception = state->fe[index_frontend]->dtv_property_cache.isdbt_partial_reception;\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].segment_count = state->fe[index_frontend]->dtv_property_cache.layer[i].segment_count;\n\t\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].interleaving = state->fe[index_frontend]->dtv_property_cache.layer[i].interleaving;\n\t\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].fec = state->fe[index_frontend]->dtv_property_cache.layer[i].fec;\n\t\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].modulation = state->fe[index_frontend]->dtv_property_cache.layer[i].modulation;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tc->isdbt_sb_mode = dib8000_read_word(state, 508) & 0x1;\n\n\tif (state->revision == 0x8090)\n\t\tval = dib8000_read_word(state, 572);\n\telse\n\t\tval = dib8000_read_word(state, 570);\n\tc->inversion = (val & 0x40) >> 6;\n\tswitch ((val & 0x30) >> 4) {\n\tcase 1:\n\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tdprintk(\"dib8000_get_frontend: transmission mode 2K\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tc->transmission_mode = TRANSMISSION_MODE_4K;\n\t\tdprintk(\"dib8000_get_frontend: transmission mode 4K\\n\");\n\t\tbreak;\n\tcase 3:\n\tdefault:\n\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t\tdprintk(\"dib8000_get_frontend: transmission mode 8K\\n\");\n\t\tbreak;\n\t}\n\n\tswitch (val & 0x3) {\n\tcase 0:\n\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\tdprintk(\"dib8000_get_frontend: Guard Interval = 1/32\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tc->guard_interval = GUARD_INTERVAL_1_16;\n\t\tdprintk(\"dib8000_get_frontend: Guard Interval = 1/16\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tdprintk(\"dib8000_get_frontend: Guard Interval = 1/8\\n\");\n\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tdprintk(\"dib8000_get_frontend: Guard Interval = 1/4\\n\");\n\t\tc->guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\t}\n\n\tval = dib8000_read_word(state, 505);\n\tc->isdbt_partial_reception = val & 1;\n\tdprintk(\"dib8000_get_frontend: partial_reception = %d\\n\", c->isdbt_partial_reception);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tint show;\n\n\t\tval = dib8000_read_word(state, 493 + i) & 0x0f;\n\t\tc->layer[i].segment_count = val;\n\n\t\tif (val == 0 || val > 13)\n\t\t\tshow = 0;\n\t\telse\n\t\t\tshow = 1;\n\n\t\tif (show)\n\t\t\tdprintk(\"dib8000_get_frontend: Layer %d segments = %d\\n\",\n\t\t\t\ti, c->layer[i].segment_count);\n\n\t\tval = dib8000_read_word(state, 499 + i) & 0x3;\n\t\t \n\t\tif (val == 3)\n\t\t\tval = 4;\n\t\tc->layer[i].interleaving = val;\n\t\tif (show)\n\t\t\tdprintk(\"dib8000_get_frontend: Layer %d time_intlv = %d\\n\",\n\t\t\t\ti, c->layer[i].interleaving);\n\n\t\tval = dib8000_read_word(state, 481 + i);\n\t\tswitch (val & 0x7) {\n\t\tcase 1:\n\t\t\tc->layer[i].fec = FEC_1_2;\n\t\t\tif (show)\n\t\t\t\tdprintk(\"dib8000_get_frontend: Layer %d Code Rate = 1/2\\n\", i);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tc->layer[i].fec = FEC_2_3;\n\t\t\tif (show)\n\t\t\t\tdprintk(\"dib8000_get_frontend: Layer %d Code Rate = 2/3\\n\", i);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tc->layer[i].fec = FEC_3_4;\n\t\t\tif (show)\n\t\t\t\tdprintk(\"dib8000_get_frontend: Layer %d Code Rate = 3/4\\n\", i);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tc->layer[i].fec = FEC_5_6;\n\t\t\tif (show)\n\t\t\t\tdprintk(\"dib8000_get_frontend: Layer %d Code Rate = 5/6\\n\", i);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->layer[i].fec = FEC_7_8;\n\t\t\tif (show)\n\t\t\t\tdprintk(\"dib8000_get_frontend: Layer %d Code Rate = 7/8\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\tval = dib8000_read_word(state, 487 + i);\n\t\tswitch (val & 0x3) {\n\t\tcase 0:\n\t\t\tc->layer[i].modulation = DQPSK;\n\t\t\tif (show)\n\t\t\t\tdprintk(\"dib8000_get_frontend: Layer %d DQPSK\\n\", i);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tc->layer[i].modulation = QPSK;\n\t\t\tif (show)\n\t\t\t\tdprintk(\"dib8000_get_frontend: Layer %d QPSK\\n\", i);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tc->layer[i].modulation = QAM_16;\n\t\t\tif (show)\n\t\t\t\tdprintk(\"dib8000_get_frontend: Layer %d QAM16\\n\", i);\n\t\t\tbreak;\n\t\tcase 3:\n\t\tdefault:\n\t\t\tc->layer[i].modulation = QAM_64;\n\t\t\tif (show)\n\t\t\t\tdprintk(\"dib8000_get_frontend: Layer %d QAM64\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\tstate->fe[index_frontend]->dtv_property_cache.isdbt_sb_mode = c->isdbt_sb_mode;\n\t\tstate->fe[index_frontend]->dtv_property_cache.inversion = c->inversion;\n\t\tstate->fe[index_frontend]->dtv_property_cache.transmission_mode = c->transmission_mode;\n\t\tstate->fe[index_frontend]->dtv_property_cache.guard_interval = c->guard_interval;\n\t\tstate->fe[index_frontend]->dtv_property_cache.isdbt_partial_reception = c->isdbt_partial_reception;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tstate->fe[index_frontend]->dtv_property_cache.layer[i].segment_count = c->layer[i].segment_count;\n\t\t\tstate->fe[index_frontend]->dtv_property_cache.layer[i].interleaving = c->layer[i].interleaving;\n\t\t\tstate->fe[index_frontend]->dtv_property_cache.layer[i].fec = c->layer[i].fec;\n\t\t\tstate->fe[index_frontend]->dtv_property_cache.layer[i].modulation = c->layer[i].modulation;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dib8000_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\tint l, i, active, time, time_slave = 0;\n\tu8 exit_condition, index_frontend;\n\tunsigned long delay, callback_time;\n\n\tif (c->frequency == 0) {\n\t\tdprintk(\"dib8000: must at least specify frequency\\n\");\n\t\treturn 0;\n\t}\n\n\tif (c->bandwidth_hz == 0) {\n\t\tdprintk(\"dib8000: no bandwidth specified, set to default\\n\");\n\t\tc->bandwidth_hz = 6000000;\n\t}\n\n\tfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\t \n\t\tstate->fe[index_frontend]->dtv_property_cache.delivery_system = SYS_ISDBT;\n\t\tmemcpy(&state->fe[index_frontend]->dtv_property_cache, &fe->dtv_property_cache, sizeof(struct dtv_frontend_properties));\n\n\t\t \n\t\tif (state->revision != 0x8090) {\n\t\t\tdib8000_set_diversity_in(state->fe[index_frontend], 1);\n\t\t\tif (index_frontend != 0)\n\t\t\t\tdib8000_set_output_mode(state->fe[index_frontend],\n\t\t\t\t\t\tOUTMODE_DIVERSITY);\n\t\t\telse\n\t\t\t\tdib8000_set_output_mode(state->fe[0], OUTMODE_HIGH_Z);\n\t\t} else {\n\t\t\tdib8096p_set_diversity_in(state->fe[index_frontend], 1);\n\t\t\tif (index_frontend != 0)\n\t\t\t\tdib8096p_set_output_mode(state->fe[index_frontend],\n\t\t\t\t\t\tOUTMODE_DIVERSITY);\n\t\t\telse\n\t\t\t\tdib8096p_set_output_mode(state->fe[0], OUTMODE_HIGH_Z);\n\t\t}\n\n\t\t \n\t\tif (state->fe[index_frontend]->ops.tuner_ops.set_params)\n\t\t\tstate->fe[index_frontend]->ops.tuner_ops.set_params(state->fe[index_frontend]);\n\n\t\tdib8000_set_tune_state(state->fe[index_frontend], CT_AGC_START);\n\t}\n\n\t \n\tif (state->revision != 0x8090)\n\t\tdib8000_set_diversity_in(state->fe[index_frontend - 1], 0);\n\telse\n\t\tdib8096p_set_diversity_in(state->fe[index_frontend - 1], 0);\n\n\t \n\tdo {\n\t\ttime = dib8000_agc_startup(state->fe[0]);\n\t\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\t\ttime_slave = dib8000_agc_startup(state->fe[index_frontend]);\n\t\t\tif (time == 0)\n\t\t\t\ttime = time_slave;\n\t\t\telse if ((time_slave != 0) && (time_slave > time))\n\t\t\t\ttime = time_slave;\n\t\t}\n\t\tif (time == 0)\n\t\t\tbreak;\n\n\t\t \n\t\ttime = 10 * (time + 99)/100;\n\t\tusleep_range(time * 1000, (time + 1) * 1000);\n\t\texit_condition = 1;\n\t\tfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\t\tif (dib8000_get_tune_state(state->fe[index_frontend]) != CT_AGC_STOP) {\n\t\t\t\texit_condition = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (exit_condition == 0);\n\n\tfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\n\t\tdib8000_set_tune_state(state->fe[index_frontend], CT_DEMOD_START);\n\n\tactive = 1;\n\tdo {\n\t\tcallback_time = 0;\n\t\tfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\t\tdelay = dib8000_tune(state->fe[index_frontend]);\n\t\t\tif (delay != 0) {\n\t\t\t\tdelay = jiffies + usecs_to_jiffies(100 * delay);\n\t\t\t\tif (!callback_time || delay < callback_time)\n\t\t\t\t\tcallback_time = delay;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (state->channel_parameters_set == 0) {  \n\t\t\t\tif ((dib8000_get_status(state->fe[index_frontend]) == FE_STATUS_DEMOD_SUCCESS) || (dib8000_get_status(state->fe[index_frontend]) == FE_STATUS_FFT_SUCCESS)) {\n\t\t\t\t\tdprintk(\"autosearch succeeded on fe%i\\n\", index_frontend);\n\t\t\t\t\tdib8000_get_frontend(state->fe[index_frontend], c);  \n\t\t\t\t\tstate->channel_parameters_set = 1;\n\n\t\t\t\t\tfor (l = 0; (l < MAX_NUMBER_OF_FRONTENDS) && (state->fe[l] != NULL); l++) {\n\t\t\t\t\t\tif (l != index_frontend) {  \n\t\t\t\t\t\t\tdprintk(\"Restarting frontend %d\\n\", l);\n\t\t\t\t\t\t\tdib8000_tune_restart_from_demod(state->fe[l]);\n\n\t\t\t\t\t\t\tstate->fe[l]->dtv_property_cache.isdbt_sb_mode = state->fe[index_frontend]->dtv_property_cache.isdbt_sb_mode;\n\t\t\t\t\t\t\tstate->fe[l]->dtv_property_cache.inversion = state->fe[index_frontend]->dtv_property_cache.inversion;\n\t\t\t\t\t\t\tstate->fe[l]->dtv_property_cache.transmission_mode = state->fe[index_frontend]->dtv_property_cache.transmission_mode;\n\t\t\t\t\t\t\tstate->fe[l]->dtv_property_cache.guard_interval = state->fe[index_frontend]->dtv_property_cache.guard_interval;\n\t\t\t\t\t\t\tstate->fe[l]->dtv_property_cache.isdbt_partial_reception = state->fe[index_frontend]->dtv_property_cache.isdbt_partial_reception;\n\t\t\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\t\t\tstate->fe[l]->dtv_property_cache.layer[i].segment_count = state->fe[index_frontend]->dtv_property_cache.layer[i].segment_count;\n\t\t\t\t\t\t\t\tstate->fe[l]->dtv_property_cache.layer[i].interleaving = state->fe[index_frontend]->dtv_property_cache.layer[i].interleaving;\n\t\t\t\t\t\t\t\tstate->fe[l]->dtv_property_cache.layer[i].fec = state->fe[index_frontend]->dtv_property_cache.layer[i].fec;\n\t\t\t\t\t\t\t\tstate->fe[l]->dtv_property_cache.layer[i].modulation = state->fe[index_frontend]->dtv_property_cache.layer[i].modulation;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (dib8000_get_status(state->fe[0]) == FE_STATUS_TUNE_FAILED ||\n\t\t\t\tdib8000_get_status(state->fe[0]) == FE_STATUS_LOCKED ||\n\t\t\t\tdib8000_get_status(state->fe[0]) == FE_STATUS_DATA_LOCKED) {\n\t\t\tactive = 0;\n\t\t\t \n\t\t\tfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\t\t\tif (dib8000_get_tune_state(state->fe[index_frontend]) != CT_DEMOD_STOP)\n\t\t\t\t\tactive = 1;\n\t\t\t}\n\t\t\tif (active == 0)\n\t\t\t\tdprintk(\"tuning done with status %d\\n\", dib8000_get_status(state->fe[0]));\n\t\t}\n\n\t\tif ((active == 1) && (callback_time == 0)) {\n\t\t\tdprintk(\"strange callback time something went wrong\\n\");\n\t\t\tactive = 0;\n\t\t}\n\n\t\twhile ((active == 1) && (time_before(jiffies, callback_time)))\n\t\t\tmsleep(100);\n\t} while (active);\n\n\t \n\tif (state->revision != 0x8090)\n\t\tdib8000_set_output_mode(state->fe[0], state->cfg.output_mode);\n\telse {\n\t\tdib8096p_set_output_mode(state->fe[0], state->cfg.output_mode);\n\t\tif (state->cfg.enMpegOutput == 0) {\n\t\t\tdib8096p_setDibTxMux(state, MPEG_ON_DIBTX);\n\t\t\tdib8096p_setHostBusMux(state, DIBTX_ON_HOSTBUS);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dib8000_get_stats(struct dvb_frontend *fe, enum fe_status stat);\n\nstatic int dib8000_read_status(struct dvb_frontend *fe, enum fe_status *stat)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu16 lock_slave = 0, lock;\n\tu8 index_frontend;\n\n\tlock = dib8000_read_lock(fe);\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\n\t\tlock_slave |= dib8000_read_lock(state->fe[index_frontend]);\n\n\t*stat = 0;\n\n\tif (((lock >> 13) & 1) || ((lock_slave >> 13) & 1))\n\t\t*stat |= FE_HAS_SIGNAL;\n\n\tif (((lock >> 8) & 1) || ((lock_slave >> 8) & 1))  \n\t\t*stat |= FE_HAS_CARRIER;\n\n\tif ((((lock >> 1) & 0xf) == 0xf) || (((lock_slave >> 1) & 0xf) == 0xf))  \n\t\t*stat |= FE_HAS_SYNC;\n\n\tif ((((lock >> 12) & 1) || ((lock_slave >> 12) & 1)) && ((lock >> 5) & 7))  \n\t\t*stat |= FE_HAS_LOCK;\n\n\tif (((lock >> 12) & 1) || ((lock_slave >> 12) & 1)) {\n\t\tlock = dib8000_read_word(state, 554);  \n\t\tif (lock & 0x01)\n\t\t\t*stat |= FE_HAS_VITERBI;\n\n\t\tlock = dib8000_read_word(state, 555);  \n\t\tif (lock & 0x01)\n\t\t\t*stat |= FE_HAS_VITERBI;\n\n\t\tlock = dib8000_read_word(state, 556);  \n\t\tif (lock & 0x01)\n\t\t\t*stat |= FE_HAS_VITERBI;\n\t}\n\tdib8000_get_stats(fe, *stat);\n\n\treturn 0;\n}\n\nstatic int dib8000_read_ber(struct dvb_frontend *fe, u32 * ber)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\n\t \n\tif (state->revision == 0x8090)\n\t\t*ber = (dib8000_read_word(state, 562) << 16) |\n\t\t\tdib8000_read_word(state, 563);\n\telse\n\t\t*ber = (dib8000_read_word(state, 560) << 16) |\n\t\t\tdib8000_read_word(state, 561);\n\treturn 0;\n}\n\nstatic int dib8000_read_unc_blocks(struct dvb_frontend *fe, u32 * unc)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\n\t \n\tif (state->revision == 0x8090)\n\t\t*unc = dib8000_read_word(state, 567);\n\telse\n\t\t*unc = dib8000_read_word(state, 565);\n\treturn 0;\n}\n\nstatic int dib8000_read_signal_strength(struct dvb_frontend *fe, u16 * strength)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu8 index_frontend;\n\tu16 val;\n\n\t*strength = 0;\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\tstate->fe[index_frontend]->ops.read_signal_strength(state->fe[index_frontend], &val);\n\t\tif (val > 65535 - *strength)\n\t\t\t*strength = 65535;\n\t\telse\n\t\t\t*strength += val;\n\t}\n\n\tval = 65535 - dib8000_read_word(state, 390);\n\tif (val > 65535 - *strength)\n\t\t*strength = 65535;\n\telse\n\t\t*strength += val;\n\treturn 0;\n}\n\nstatic u32 dib8000_get_snr(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu32 n, s, exp;\n\tu16 val;\n\n\tif (state->revision != 0x8090)\n\t\tval = dib8000_read_word(state, 542);\n\telse\n\t\tval = dib8000_read_word(state, 544);\n\tn = (val >> 6) & 0xff;\n\texp = (val & 0x3f);\n\tif ((exp & 0x20) != 0)\n\t\texp -= 0x40;\n\tn <<= exp+16;\n\n\tif (state->revision != 0x8090)\n\t\tval = dib8000_read_word(state, 543);\n\telse\n\t\tval = dib8000_read_word(state, 545);\n\ts = (val >> 6) & 0xff;\n\texp = (val & 0x3f);\n\tif ((exp & 0x20) != 0)\n\t\texp -= 0x40;\n\ts <<= exp+16;\n\n\tif (n > 0) {\n\t\tu32 t = (s/n) << 16;\n\t\treturn t + ((s << 16) - n*t) / n;\n\t}\n\treturn 0xffffffff;\n}\n\nstatic int dib8000_read_snr(struct dvb_frontend *fe, u16 * snr)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu8 index_frontend;\n\tu32 snr_master;\n\n\tsnr_master = dib8000_get_snr(fe);\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\n\t\tsnr_master += dib8000_get_snr(state->fe[index_frontend]);\n\n\tif ((snr_master >> 16) != 0) {\n\t\tsnr_master = 10*intlog10(snr_master>>16);\n\t\t*snr = snr_master / ((1 << 24) / 10);\n\t}\n\telse\n\t\t*snr = 0;\n\n\treturn 0;\n}\n\nstruct per_layer_regs {\n\tu16 lock, ber, per;\n};\n\nstatic const struct per_layer_regs per_layer_regs[] = {\n\t{ 554, 560, 562 },\n\t{ 555, 576, 578 },\n\t{ 556, 581, 583 },\n};\n\nstruct linear_segments {\n\tunsigned x;\n\tsigned y;\n};\n\n \nstatic struct linear_segments strength_to_db_table[] = {\n\t{ 55953, 108500 },\t \n\t{ 55394, 108000 },\n\t{ 53834, 107000 },\n\t{ 52863, 106000 },\n\t{ 52239, 105000 },\n\t{ 52012, 104000 },\n\t{ 51803, 103000 },\n\t{ 51566, 102000 },\n\t{ 51356, 101000 },\n\t{ 51112, 100000 },\n\t{ 50869,  99000 },\n\t{ 50600,  98000 },\n\t{ 50363,  97000 },\n\t{ 50117,  96000 },\t \n\t{ 49889,  95000 },\n\t{ 49680,  94000 },\n\t{ 49493,  93000 },\n\t{ 49302,  92000 },\n\t{ 48929,  91000 },\n\t{ 48416,  90000 },\n\t{ 48035,  89000 },\n\t{ 47593,  88000 },\n\t{ 47282,  87000 },\n\t{ 46953,  86000 },\n\t{ 46698,  85000 },\n\t{ 45617,  84000 },\n\t{ 44773,  83000 },\n\t{ 43845,  82000 },\n\t{ 43020,  81000 },\n\t{ 42010,  80000 },\t \n\t{     0,      0 },\n};\n\nstatic u32 interpolate_value(u32 value, struct linear_segments *segments,\n\t\t\t     unsigned len)\n{\n\tu64 tmp64;\n\tu32 dx;\n\ts32 dy;\n\tint i, ret;\n\n\tif (value >= segments[0].x)\n\t\treturn segments[0].y;\n\tif (value < segments[len-1].x)\n\t\treturn segments[len-1].y;\n\n\tfor (i = 1; i < len - 1; i++) {\n\t\t \n\t\tif (value == segments[i].x)\n\t\t\treturn segments[i].y;\n\t\tif (value > segments[i].x)\n\t\t\tbreak;\n\t}\n\n\t \n\tdy = segments[i - 1].y - segments[i].y;\n\tdx = segments[i - 1].x - segments[i].x;\n\n\ttmp64 = value - segments[i].x;\n\ttmp64 *= dy;\n\tdo_div(tmp64, dx);\n\tret = segments[i].y + tmp64;\n\n\treturn ret;\n}\n\nstatic u32 dib8000_get_time_us(struct dvb_frontend *fe, int layer)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\tint ini_layer, end_layer, i;\n\tu64 time_us, tmp64;\n\tu32 tmp, denom;\n\tint guard, rate_num, rate_denum = 1, bits_per_symbol, nsegs;\n\tint interleaving = 0, fft_div;\n\n\tif (layer >= 0) {\n\t\tini_layer = layer;\n\t\tend_layer = layer + 1;\n\t} else {\n\t\tini_layer = 0;\n\t\tend_layer = 3;\n\t}\n\n\tswitch (c->guard_interval) {\n\tcase GUARD_INTERVAL_1_4:\n\t\tguard = 4;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_8:\n\t\tguard = 8;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_16:\n\t\tguard = 16;\n\t\tbreak;\n\tdefault:\n\tcase GUARD_INTERVAL_1_32:\n\t\tguard = 32;\n\t\tbreak;\n\t}\n\n\tswitch (c->transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\t\tfft_div = 4;\n\t\tbreak;\n\tcase TRANSMISSION_MODE_4K:\n\t\tfft_div = 2;\n\t\tbreak;\n\tdefault:\n\tcase TRANSMISSION_MODE_8K:\n\t\tfft_div = 1;\n\t\tbreak;\n\t}\n\n\tdenom = 0;\n\tfor (i = ini_layer; i < end_layer; i++) {\n\t\tnsegs = c->layer[i].segment_count;\n\t\tif (nsegs == 0 || nsegs > 13)\n\t\t\tcontinue;\n\n\t\tswitch (c->layer[i].modulation) {\n\t\tcase DQPSK:\n\t\tcase QPSK:\n\t\t\tbits_per_symbol = 2;\n\t\t\tbreak;\n\t\tcase QAM_16:\n\t\t\tbits_per_symbol = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase QAM_64:\n\t\t\tbits_per_symbol = 6;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (c->layer[i].fec) {\n\t\tcase FEC_1_2:\n\t\t\trate_num = 1;\n\t\t\trate_denum = 2;\n\t\t\tbreak;\n\t\tcase FEC_2_3:\n\t\t\trate_num = 2;\n\t\t\trate_denum = 3;\n\t\t\tbreak;\n\t\tcase FEC_3_4:\n\t\t\trate_num = 3;\n\t\t\trate_denum = 4;\n\t\t\tbreak;\n\t\tcase FEC_5_6:\n\t\t\trate_num = 5;\n\t\t\trate_denum = 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase FEC_7_8:\n\t\t\trate_num = 7;\n\t\t\trate_denum = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tinterleaving = c->layer[i].interleaving;\n\n\t\tdenom += bits_per_symbol * rate_num * fft_div * nsegs * 384;\n\t}\n\n\t \n\tif (!denom)\n\t\treturn 0;\n\n\t \n\ttime_us = rate_denum * (1008 * 1562500L);\n\ttmp64 = time_us;\n\tdo_div(tmp64, guard);\n\ttime_us = time_us + tmp64;\n\ttime_us += denom / 2;\n\tdo_div(time_us, denom);\n\n\ttmp = 1008 * 96 * interleaving;\n\ttime_us += tmp + tmp / guard;\n\n\treturn time_us;\n}\n\nstatic int dib8000_get_stats(struct dvb_frontend *fe, enum fe_status stat)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\n\tint i;\n\tint show_per_stats = 0;\n\tu32 time_us = 0, snr, val;\n\tu64 blocks;\n\ts32 db;\n\tu16 strength;\n\n\t \n\tdib8000_read_signal_strength(fe, &strength);\n\tval = strength;\n\tdb = interpolate_value(val,\n\t\t\t       strength_to_db_table,\n\t\t\t       ARRAY_SIZE(strength_to_db_table)) - 131000;\n\tc->strength.stat[0].svalue = db;\n\n\t \n\tif (!(stat & FE_HAS_LOCK)) {\n\t\tc->cnr.len = 1;\n\t\tc->block_count.len = 1;\n\t\tc->block_error.len = 1;\n\t\tc->post_bit_error.len = 1;\n\t\tc->post_bit_count.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn 0;\n\t}\n\n\t \n\tif (time_after(jiffies, state->per_jiffies_stats)) {\n\t\tstate->per_jiffies_stats = jiffies + msecs_to_jiffies(1000);\n\n\t\t \n\t\tsnr = dib8000_get_snr(fe);\n\t\tfor (i = 1; i < MAX_NUMBER_OF_FRONTENDS; i++) {\n\t\t\tif (state->fe[i])\n\t\t\t\tsnr += dib8000_get_snr(state->fe[i]);\n\t\t}\n\t\tsnr = snr >> 16;\n\n\t\tif (snr) {\n\t\t\tsnr = 10 * intlog10(snr);\n\t\t\tsnr = (1000L * snr) >> 24;\n\t\t} else {\n\t\t\tsnr = 0;\n\t\t}\n\t\tc->cnr.stat[0].svalue = snr;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\n\t\t \n\t\tdib8000_read_unc_blocks(fe, &val);\n\t\tif (val < state->init_ucb)\n\t\t\tstate->init_ucb += 0x100000000LL;\n\n\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_error.stat[0].uvalue = val + state->init_ucb;\n\n\t\t \n\t\tif (!time_us)\n\t\t\ttime_us = dib8000_get_time_us(fe, -1);\n\n\t\tif (time_us) {\n\t\t\tblocks = 1250000ULL * 1000000ULL;\n\t\t\tdo_div(blocks, time_us * 8 * 204);\n\t\t\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->block_count.stat[0].uvalue += blocks;\n\t\t}\n\n\t\tshow_per_stats = 1;\n\t}\n\n\t \n\tif (time_after(jiffies, state->ber_jiffies_stats)) {\n\t\ttime_us = dib8000_get_time_us(fe, -1);\n\t\tstate->ber_jiffies_stats = jiffies + msecs_to_jiffies((time_us + 500) / 1000);\n\n\t\tdprintk(\"Next all layers stats available in %u us.\\n\", time_us);\n\n\t\tdib8000_read_ber(fe, &val);\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[0].uvalue += val;\n\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[0].uvalue += 100000000;\n\t}\n\n\tif (state->revision < 0x8002)\n\t\treturn 0;\n\n\tc->block_error.len = 4;\n\tc->post_bit_error.len = 4;\n\tc->post_bit_count.len = 4;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned nsegs = c->layer[i].segment_count;\n\n\t\tif (nsegs == 0 || nsegs > 13)\n\t\t\tcontinue;\n\n\t\ttime_us = 0;\n\n\t\tif (time_after(jiffies, state->ber_jiffies_stats_layer[i])) {\n\t\t\ttime_us = dib8000_get_time_us(fe, i);\n\n\t\t\tstate->ber_jiffies_stats_layer[i] = jiffies + msecs_to_jiffies((time_us + 500) / 1000);\n\t\t\tdprintk(\"Next layer %c  stats will be available in %u us\\n\",\n\t\t\t\t'A' + i, time_us);\n\n\t\t\tval = dib8000_read_word(state, per_layer_regs[i].ber);\n\t\t\tc->post_bit_error.stat[1 + i].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_error.stat[1 + i].uvalue += val;\n\n\t\t\tc->post_bit_count.stat[1 + i].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_count.stat[1 + i].uvalue += 100000000;\n\t\t}\n\n\t\tif (show_per_stats) {\n\t\t\tval = dib8000_read_word(state, per_layer_regs[i].per);\n\n\t\t\tc->block_error.stat[1 + i].scale = FE_SCALE_COUNTER;\n\t\t\tc->block_error.stat[1 + i].uvalue += val;\n\n\t\t\tif (!time_us)\n\t\t\t\ttime_us = dib8000_get_time_us(fe, i);\n\t\t\tif (time_us) {\n\t\t\t\tblocks = 1250000ULL * 1000000ULL;\n\t\t\t\tdo_div(blocks, time_us * 8 * 204);\n\t\t\t\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\t\tc->block_count.stat[0].uvalue += blocks;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dib8000_set_slave_frontend(struct dvb_frontend *fe, struct dvb_frontend *fe_slave)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\tu8 index_frontend = 1;\n\n\twhile ((index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL))\n\t\tindex_frontend++;\n\tif (index_frontend < MAX_NUMBER_OF_FRONTENDS) {\n\t\tdprintk(\"set slave fe %p to index %i\\n\", fe_slave, index_frontend);\n\t\tstate->fe[index_frontend] = fe_slave;\n\t\treturn 0;\n\t}\n\n\tdprintk(\"too many slave frontend\\n\");\n\treturn -ENOMEM;\n}\n\nstatic struct dvb_frontend *dib8000_get_slave_frontend(struct dvb_frontend *fe, int slave_index)\n{\n\tstruct dib8000_state *state = fe->demodulator_priv;\n\n\tif (slave_index >= MAX_NUMBER_OF_FRONTENDS)\n\t\treturn NULL;\n\treturn state->fe[slave_index];\n}\n\nstatic int dib8000_i2c_enumeration(struct i2c_adapter *host, int no_of_demods,\n\t\tu8 default_addr, u8 first_addr, u8 is_dib8096p)\n{\n\tint k = 0, ret = 0;\n\tu8 new_addr = 0;\n\tstruct i2c_device client = {.adap = host };\n\n\tclient.i2c_write_buffer = kzalloc(4, GFP_KERNEL);\n\tif (!client.i2c_write_buffer) {\n\t\tdprintk(\"%s: not enough memory\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tclient.i2c_read_buffer = kzalloc(4, GFP_KERNEL);\n\tif (!client.i2c_read_buffer) {\n\t\tdprintk(\"%s: not enough memory\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto error_memory_read;\n\t}\n\tclient.i2c_buffer_lock = kzalloc(sizeof(struct mutex), GFP_KERNEL);\n\tif (!client.i2c_buffer_lock) {\n\t\tdprintk(\"%s: not enough memory\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto error_memory_lock;\n\t}\n\tmutex_init(client.i2c_buffer_lock);\n\n\tfor (k = no_of_demods - 1; k >= 0; k--) {\n\t\t \n\t\tnew_addr = first_addr + (k << 1);\n\n\t\tclient.addr = new_addr;\n\t\tif (!is_dib8096p)\n\t\t\tdib8000_i2c_write16(&client, 1287, 0x0003);\t \n\t\tif (dib8000_identify(&client) == 0) {\n\t\t\t \n\t\t\tif (!is_dib8096p)\n\t\t\t\tdib8000_i2c_write16(&client, 1287, 0x0003);\n\t\t\tclient.addr = default_addr;\n\t\t\tif (dib8000_identify(&client) == 0) {\n\t\t\t\tdprintk(\"#%d: not identified\\n\", k);\n\t\t\t\tret  = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdib8000_i2c_write16(&client, 1286, (1 << 10) | (4 << 6));\n\n\t\t \n\t\tdib8000_i2c_write16(&client, 1285, (new_addr << 2) | 0x2);\n\t\tclient.addr = new_addr;\n\t\tdib8000_identify(&client);\n\n\t\tdprintk(\"IC %d initialized (to i2c_address 0x%x)\\n\", k, new_addr);\n\t}\n\n\tfor (k = 0; k < no_of_demods; k++) {\n\t\tnew_addr = first_addr | (k << 1);\n\t\tclient.addr = new_addr;\n\n\t\t\n\t\tdib8000_i2c_write16(&client, 1285, new_addr << 2);\n\n\t\t \n\t\tdib8000_i2c_write16(&client, 1286, 0);\n\t}\n\nerror:\n\tkfree(client.i2c_buffer_lock);\nerror_memory_lock:\n\tkfree(client.i2c_read_buffer);\nerror_memory_read:\n\tkfree(client.i2c_write_buffer);\n\n\treturn ret;\n}\n\nstatic int dib8000_fe_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 1000;\n\ttune->step_size = 0;\n\ttune->max_drift = 0;\n\treturn 0;\n}\n\nstatic void dib8000_release(struct dvb_frontend *fe)\n{\n\tstruct dib8000_state *st = fe->demodulator_priv;\n\tu8 index_frontend;\n\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (st->fe[index_frontend] != NULL); index_frontend++)\n\t\tdvb_frontend_detach(st->fe[index_frontend]);\n\n\tdibx000_exit_i2c_master(&st->i2c_master);\n\ti2c_del_adapter(&st->dib8096p_tuner_adap);\n\tkfree(st->fe[0]);\n\tkfree(st);\n}\n\nstatic struct i2c_adapter *dib8000_get_i2c_master(struct dvb_frontend *fe, enum dibx000_i2c_interface intf, int gating)\n{\n\tstruct dib8000_state *st = fe->demodulator_priv;\n\treturn dibx000_get_i2c_adapter(&st->i2c_master, intf, gating);\n}\n\nstatic int dib8000_pid_filter_ctrl(struct dvb_frontend *fe, u8 onoff)\n{\n\tstruct dib8000_state *st = fe->demodulator_priv;\n\tu16 val = dib8000_read_word(st, 299) & 0xffef;\n\tval |= (onoff & 0x1) << 4;\n\n\tdprintk(\"pid filter enabled %d\\n\", onoff);\n\treturn dib8000_write_word(st, 299, val);\n}\n\nstatic int dib8000_pid_filter(struct dvb_frontend *fe, u8 id, u16 pid, u8 onoff)\n{\n\tstruct dib8000_state *st = fe->demodulator_priv;\n\tdprintk(\"Index %x, PID %d, OnOff %d\\n\", id, pid, onoff);\n\treturn dib8000_write_word(st, 305 + id, onoff ? (1 << 13) | pid : 0);\n}\n\nstatic const struct dvb_frontend_ops dib8000_ops = {\n\t.delsys = { SYS_ISDBT },\n\t.info = {\n\t\t .name = \"DiBcom 8000 ISDB-T\",\n\t\t .frequency_min_hz =  44250 * kHz,\n\t\t .frequency_max_hz = 867250 * kHz,\n\t\t .frequency_stepsize_hz = 62500,\n\t\t .caps = FE_CAN_INVERSION_AUTO |\n\t\t FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_RECOVER | FE_CAN_HIERARCHY_AUTO,\n\t\t },\n\n\t.release = dib8000_release,\n\n\t.init = dib8000_wakeup,\n\t.sleep = dib8000_sleep,\n\n\t.set_frontend = dib8000_set_frontend,\n\t.get_tune_settings = dib8000_fe_get_tune_settings,\n\t.get_frontend = dib8000_get_frontend,\n\n\t.read_status = dib8000_read_status,\n\t.read_ber = dib8000_read_ber,\n\t.read_signal_strength = dib8000_read_signal_strength,\n\t.read_snr = dib8000_read_snr,\n\t.read_ucblocks = dib8000_read_unc_blocks,\n};\n\nstatic struct dvb_frontend *dib8000_init(struct i2c_adapter *i2c_adap, u8 i2c_addr, struct dib8000_config *cfg)\n{\n\tstruct dvb_frontend *fe;\n\tstruct dib8000_state *state;\n\n\tdprintk(\"dib8000_init\\n\");\n\n\tstate = kzalloc(sizeof(struct dib8000_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn NULL;\n\tfe = kzalloc(sizeof(struct dvb_frontend), GFP_KERNEL);\n\tif (fe == NULL)\n\t\tgoto error;\n\n\tmemcpy(&state->cfg, cfg, sizeof(struct dib8000_config));\n\tstate->i2c.adap = i2c_adap;\n\tstate->i2c.addr = i2c_addr;\n\tstate->i2c.i2c_write_buffer = state->i2c_write_buffer;\n\tstate->i2c.i2c_read_buffer = state->i2c_read_buffer;\n\tmutex_init(&state->i2c_buffer_lock);\n\tstate->i2c.i2c_buffer_lock = &state->i2c_buffer_lock;\n\tstate->gpio_val = cfg->gpio_val;\n\tstate->gpio_dir = cfg->gpio_dir;\n\n\t \n\tif ((state->cfg.output_mode != OUTMODE_MPEG2_SERIAL) && (state->cfg.output_mode != OUTMODE_MPEG2_PAR_GATED_CLK))\n\t\tstate->cfg.output_mode = OUTMODE_MPEG2_FIFO;\n\n\tstate->fe[0] = fe;\n\tfe->demodulator_priv = state;\n\tmemcpy(&state->fe[0]->ops, &dib8000_ops, sizeof(struct dvb_frontend_ops));\n\n\tstate->timf_default = cfg->pll->timf;\n\n\tif (dib8000_identify(&state->i2c) == 0) {\n\t\tkfree(fe);\n\t\tgoto error;\n\t}\n\n\tdibx000_init_i2c_master(&state->i2c_master, DIB8000, state->i2c.adap, state->i2c.addr);\n\n\t \n\tstrscpy(state->dib8096p_tuner_adap.name, \"DiB8096P tuner interface\",\n\t\tsizeof(state->dib8096p_tuner_adap.name));\n\tstate->dib8096p_tuner_adap.algo = &dib8096p_tuner_xfer_algo;\n\tstate->dib8096p_tuner_adap.algo_data = NULL;\n\tstate->dib8096p_tuner_adap.dev.parent = state->i2c.adap->dev.parent;\n\ti2c_set_adapdata(&state->dib8096p_tuner_adap, state);\n\ti2c_add_adapter(&state->dib8096p_tuner_adap);\n\n\tdib8000_reset(fe);\n\n\tdib8000_write_word(state, 285, (dib8000_read_word(state, 285) & ~0x60) | (3 << 5));\t \n\tstate->current_demod_bw = 6000;\n\n\treturn fe;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nvoid *dib8000_attach(struct dib8000_ops *ops)\n{\n\tif (!ops)\n\t\treturn NULL;\n\n\tops->pwm_agc_reset = dib8000_pwm_agc_reset;\n\tops->get_dc_power = dib8090p_get_dc_power;\n\tops->set_gpio = dib8000_set_gpio;\n\tops->get_slave_frontend = dib8000_get_slave_frontend;\n\tops->set_tune_state = dib8000_set_tune_state;\n\tops->pid_filter_ctrl = dib8000_pid_filter_ctrl;\n\tops->get_adc_power = dib8000_get_adc_power;\n\tops->update_pll = dib8000_update_pll;\n\tops->tuner_sleep = dib8096p_tuner_sleep;\n\tops->get_tune_state = dib8000_get_tune_state;\n\tops->get_i2c_tuner = dib8096p_get_i2c_tuner;\n\tops->set_slave_frontend = dib8000_set_slave_frontend;\n\tops->pid_filter = dib8000_pid_filter;\n\tops->ctrl_timf = dib8000_ctrl_timf;\n\tops->init = dib8000_init;\n\tops->get_i2c_master = dib8000_get_i2c_master;\n\tops->i2c_enumeration = dib8000_i2c_enumeration;\n\tops->set_wbd_ref = dib8000_set_wbd_ref;\n\n\treturn ops;\n}\nEXPORT_SYMBOL_GPL(dib8000_attach);\n\nMODULE_AUTHOR(\"Olivier Grenie <Olivier.Grenie@parrot.com, Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"Driver for the DiBcom 8000 ISDB-T demodulator\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}