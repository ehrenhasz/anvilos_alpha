{
  "module_name": "tda10086.c",
  "hash_id": "701f5776a48593b7b44a1904e70bb36b8285da54cb9270a8360804bd6075ccea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tda10086.c",
  "human_readable_source": "\n   \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"tda10086.h\"\n\n#define SACLK 96000000U\n\nstruct tda10086_state {\n\tstruct i2c_adapter* i2c;\n\tconst struct tda10086_config* config;\n\tstruct dvb_frontend frontend;\n\n\t \n\tu32 frequency;\n\tu32 symbol_rate;\n\tbool has_lock;\n};\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) printk(KERN_DEBUG \"tda10086: \" args); \\\n\t} while (0)\n\nstatic int tda10086_write_byte(struct tda10086_state *state, int reg, int data)\n{\n\tint ret;\n\tu8 b0[] = { reg, data };\n\tstruct i2c_msg msg = { .flags = 0, .buf = b0, .len = 2 };\n\n\tmsg.addr = state->config->demod_address;\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tdprintk(\"%s: error reg=0x%x, data=0x%x, ret=%i\\n\",\n\t\t\t__func__, reg, data, ret);\n\n\treturn (ret != 1) ? ret : 0;\n}\n\nstatic int tda10086_read_byte(struct tda10086_state *state, int reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {{ .flags = 0, .buf = b0, .len = 1 },\n\t\t\t\t{ .flags = I2C_M_RD, .buf = b1, .len = 1 }};\n\n\tmsg[0].addr = state->config->demod_address;\n\tmsg[1].addr = state->config->demod_address;\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\tdprintk(\"%s: error reg=0x%x, ret=%i\\n\", __func__, reg,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn b1[0];\n}\n\nstatic int tda10086_write_mask(struct tda10086_state *state, int reg, int mask, int data)\n{\n\tint val;\n\n\t \n\tval = tda10086_read_byte(state, reg);\n\tif (val < 0)\n\t\treturn val;\n\n\t \n\tval = val & ~mask;\n\tval |= data & 0xff;\n\n\t \n\treturn tda10086_write_byte(state, reg, val);\n}\n\nstatic int tda10086_init(struct dvb_frontend* fe)\n{\n\tstruct tda10086_state* state = fe->demodulator_priv;\n\tu8 t22k_off = 0x80;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\tif (state->config->diseqc_tone)\n\t\tt22k_off = 0;\n\t \n\ttda10086_write_byte(state, 0x00, 0x00);\n\tmsleep(10);\n\n\t \n\ttda10086_write_byte(state, 0x01, 0x94);\n\ttda10086_write_byte(state, 0x02, 0x35);  \n\ttda10086_write_byte(state, 0x03, 0xe4);\n\ttda10086_write_byte(state, 0x04, 0x43);\n\ttda10086_write_byte(state, 0x0c, 0x0c);\n\ttda10086_write_byte(state, 0x1b, 0xb0);  \n\ttda10086_write_byte(state, 0x20, 0x89);  \n\ttda10086_write_byte(state, 0x30, 0x04);  \n\ttda10086_write_byte(state, 0x32, 0x00);  \n\ttda10086_write_byte(state, 0x31, 0x56);  \n\n\t \n\ttda10086_write_byte(state, 0x55, 0x2c);  \n\tif (state->config->xtal_freq == TDA10086_XTAL_16M) {\n\t\ttda10086_write_byte(state, 0x3a, 0x0b);  \n\t\ttda10086_write_byte(state, 0x3b, 0x01);  \n\t} else {\n\t\ttda10086_write_byte(state, 0x3a, 0x17);  \n\t\ttda10086_write_byte(state, 0x3b, 0x00);  \n\t}\n\ttda10086_write_mask(state, 0x55, 0x20, 0x00);  \n\n\t \n\ttda10086_write_byte(state, 0x11, 0x81);\n\ttda10086_write_byte(state, 0x12, 0x81);\n\ttda10086_write_byte(state, 0x19, 0x40);  \n\ttda10086_write_byte(state, 0x56, 0x80);  \n\ttda10086_write_byte(state, 0x57, 0x08);  \n\ttda10086_write_byte(state, 0x10, 0x2a);\n\n\t \n\ttda10086_write_byte(state, 0x58, 0x61);  \n\ttda10086_write_mask(state, 0x58, 0x01, 0x00);  \n\n\t \n\ttda10086_write_byte(state, 0x05, 0x0B);\n\ttda10086_write_byte(state, 0x37, 0x63);\n\ttda10086_write_byte(state, 0x3f, 0x0a);  \n\ttda10086_write_byte(state, 0x40, 0x64);\n\ttda10086_write_byte(state, 0x41, 0x4f);\n\ttda10086_write_byte(state, 0x42, 0x43);\n\n\t \n\ttda10086_write_byte(state, 0x1a, 0x11);  \n\n\t \n\ttda10086_write_byte(state, 0x3d, 0x80);\n\n\t \n\ttda10086_write_byte(state, 0x36, t22k_off);  \n\ttda10086_write_byte(state, 0x34, (((1<<19) * (22000/1000)) / (SACLK/1000)));\n\ttda10086_write_byte(state, 0x35, (((1<<19) * (22000/1000)) / (SACLK/1000)) >> 8);\n\n\treturn 0;\n}\n\nstatic void tda10086_diseqc_wait(struct tda10086_state *state)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(200);\n\twhile (!(tda10086_read_byte(state, 0x50) & 0x01)) {\n\t\tif(time_after(jiffies, timeout)) {\n\t\t\tprintk(\"%s: diseqc queue not ready, command may be lost.\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(10);\n\t}\n}\n\nstatic int tda10086_set_tone(struct dvb_frontend *fe,\n\t\t\t     enum fe_sec_tone_mode tone)\n{\n\tstruct tda10086_state* state = fe->demodulator_priv;\n\tu8 t22k_off = 0x80;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\tif (state->config->diseqc_tone)\n\t\tt22k_off = 0;\n\n\tswitch (tone) {\n\tcase SEC_TONE_OFF:\n\t\ttda10086_write_byte(state, 0x36, t22k_off);\n\t\tbreak;\n\n\tcase SEC_TONE_ON:\n\t\ttda10086_write_byte(state, 0x36, 0x01 + t22k_off);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tda10086_send_master_cmd (struct dvb_frontend* fe,\n\t\t\t\t    struct dvb_diseqc_master_cmd* cmd)\n{\n\tstruct tda10086_state* state = fe->demodulator_priv;\n\tint i;\n\tu8 oldval;\n\tu8 t22k_off = 0x80;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\tif (state->config->diseqc_tone)\n\t\tt22k_off = 0;\n\n\tif (cmd->msg_len > 6)\n\t\treturn -EINVAL;\n\toldval = tda10086_read_byte(state, 0x36);\n\n\tfor(i=0; i< cmd->msg_len; i++) {\n\t\ttda10086_write_byte(state, 0x48+i, cmd->msg[i]);\n\t}\n\ttda10086_write_byte(state, 0x36, (0x08 + t22k_off)\n\t\t\t\t\t| ((cmd->msg_len - 1) << 4));\n\n\ttda10086_diseqc_wait(state);\n\n\ttda10086_write_byte(state, 0x36, oldval);\n\n\treturn 0;\n}\n\nstatic int tda10086_send_burst(struct dvb_frontend *fe,\n\t\t\t       enum fe_sec_mini_cmd minicmd)\n{\n\tstruct tda10086_state* state = fe->demodulator_priv;\n\tu8 oldval = tda10086_read_byte(state, 0x36);\n\tu8 t22k_off = 0x80;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\tif (state->config->diseqc_tone)\n\t\tt22k_off = 0;\n\n\tswitch(minicmd) {\n\tcase SEC_MINI_A:\n\t\ttda10086_write_byte(state, 0x36, 0x04 + t22k_off);\n\t\tbreak;\n\n\tcase SEC_MINI_B:\n\t\ttda10086_write_byte(state, 0x36, 0x06 + t22k_off);\n\t\tbreak;\n\t}\n\n\ttda10086_diseqc_wait(state);\n\n\ttda10086_write_byte(state, 0x36, oldval);\n\n\treturn 0;\n}\n\nstatic int tda10086_set_inversion(struct tda10086_state *state,\n\t\t\t\t  struct dtv_frontend_properties *fe_params)\n{\n\tu8 invval = 0x80;\n\n\tdprintk (\"%s %i %i\\n\", __func__, fe_params->inversion, state->config->invert);\n\n\tswitch(fe_params->inversion) {\n\tcase INVERSION_OFF:\n\t\tif (state->config->invert)\n\t\t\tinvval = 0x40;\n\t\tbreak;\n\tcase INVERSION_ON:\n\t\tif (!state->config->invert)\n\t\t\tinvval = 0x40;\n\t\tbreak;\n\tcase INVERSION_AUTO:\n\t\tinvval = 0x00;\n\t\tbreak;\n\t}\n\ttda10086_write_mask(state, 0x0c, 0xc0, invval);\n\n\treturn 0;\n}\n\nstatic int tda10086_set_symbol_rate(struct tda10086_state *state,\n\t\t\t\t    struct dtv_frontend_properties *fe_params)\n{\n\tu8 dfn = 0;\n\tu8 afs = 0;\n\tu8 byp = 0;\n\tu8 reg37 = 0x43;\n\tu8 reg42 = 0x43;\n\tu64 big;\n\tu32 tmp;\n\tu32 bdr;\n\tu32 bdri;\n\tu32 symbol_rate = fe_params->symbol_rate;\n\n\tdprintk (\"%s %i\\n\", __func__, symbol_rate);\n\n\t \n\tif (symbol_rate < SACLK / 10000 * 137) {\n\t\tdfn=4;\n\t\tafs=1;\n\t} else if (symbol_rate < SACLK / 10000 * 208) {\n\t\tdfn=4;\n\t\tafs=0;\n\t} else if (symbol_rate < SACLK / 10000 * 270) {\n\t\tdfn=3;\n\t\tafs=1;\n\t} else if (symbol_rate < SACLK / 10000 * 416) {\n\t\tdfn=3;\n\t\tafs=0;\n\t} else if (symbol_rate < SACLK / 10000 * 550) {\n\t\tdfn=2;\n\t\tafs=1;\n\t} else if (symbol_rate < SACLK / 10000 * 833) {\n\t\tdfn=2;\n\t\tafs=0;\n\t} else if (symbol_rate < SACLK / 10000 * 1100) {\n\t\tdfn=1;\n\t\tafs=1;\n\t} else if (symbol_rate < SACLK / 10000 * 1666) {\n\t\tdfn=1;\n\t\tafs=0;\n\t} else if (symbol_rate < SACLK / 10000 * 2200) {\n\t\tdfn=0;\n\t\tafs=1;\n\t} else if (symbol_rate < SACLK / 10000 * 3333) {\n\t\tdfn=0;\n\t\tafs=0;\n\t} else {\n\t\treg37 = 0x63;\n\t\treg42 = 0x4f;\n\t\tbyp=1;\n\t}\n\n\t \n\tbig = (1ULL<<21) * ((u64) symbol_rate/1000ULL) * (1ULL<<dfn);\n\tbig += ((SACLK/1000ULL)-1ULL);\n\tdo_div(big, (SACLK/1000ULL));\n\tbdr = big & 0xfffff;\n\n\t \n\ttmp = (1<<dfn)*(symbol_rate/1000);\n\tbdri = ((32 * (SACLK/1000)) + (tmp-1)) / tmp;\n\n\ttda10086_write_byte(state, 0x21, (afs << 7) | dfn);\n\ttda10086_write_mask(state, 0x20, 0x08, byp << 3);\n\ttda10086_write_byte(state, 0x06, bdr);\n\ttda10086_write_byte(state, 0x07, bdr >> 8);\n\ttda10086_write_byte(state, 0x08, bdr >> 16);\n\ttda10086_write_byte(state, 0x09, bdri);\n\ttda10086_write_byte(state, 0x37, reg37);\n\ttda10086_write_byte(state, 0x42, reg42);\n\n\treturn 0;\n}\n\nstatic int tda10086_set_fec(struct tda10086_state *state,\n\t\t\t    struct dtv_frontend_properties *fe_params)\n{\n\tu8 fecval;\n\n\tdprintk(\"%s %i\\n\", __func__, fe_params->fec_inner);\n\n\tswitch (fe_params->fec_inner) {\n\tcase FEC_1_2:\n\t\tfecval = 0x00;\n\t\tbreak;\n\tcase FEC_2_3:\n\t\tfecval = 0x01;\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tfecval = 0x02;\n\t\tbreak;\n\tcase FEC_4_5:\n\t\tfecval = 0x03;\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tfecval = 0x04;\n\t\tbreak;\n\tcase FEC_6_7:\n\t\tfecval = 0x05;\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tfecval = 0x06;\n\t\tbreak;\n\tcase FEC_8_9:\n\t\tfecval = 0x07;\n\t\tbreak;\n\tcase FEC_AUTO:\n\t\tfecval = 0x08;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\ttda10086_write_byte(state, 0x0d, fecval);\n\n\treturn 0;\n}\n\nstatic int tda10086_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *fe_params = &fe->dtv_property_cache;\n\tstruct tda10086_state *state = fe->demodulator_priv;\n\tint ret;\n\tu32 freq = 0;\n\tint freqoff;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\t \n\ttda10086_write_byte(state, 0x02, 0x35);\n\tstate->has_lock = false;\n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\t\tif (fe->ops.tuner_ops.get_frequency)\n\t\t\tfe->ops.tuner_ops.get_frequency(fe, &freq);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t \n\tfreqoff = fe_params->frequency - freq;\n\tfreqoff = ((1<<16) * freqoff) / (SACLK/1000);\n\ttda10086_write_byte(state, 0x3d, 0x80 | ((freqoff >> 8) & 0x7f));\n\ttda10086_write_byte(state, 0x3e, freqoff);\n\n\tif ((ret = tda10086_set_inversion(state, fe_params)) < 0)\n\t\treturn ret;\n\tif ((ret = tda10086_set_symbol_rate(state, fe_params)) < 0)\n\t\treturn ret;\n\tif ((ret = tda10086_set_fec(state, fe_params)) < 0)\n\t\treturn ret;\n\n\t \n\ttda10086_write_mask(state, 0x10, 0x40, 0x40);\n\ttda10086_write_mask(state, 0x00, 0x01, 0x00);\n\n\tstate->symbol_rate = fe_params->symbol_rate;\n\tstate->frequency = fe_params->frequency;\n\treturn 0;\n}\n\nstatic int tda10086_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t struct dtv_frontend_properties *fe_params)\n{\n\tstruct tda10086_state* state = fe->demodulator_priv;\n\tu8 val;\n\tint tmp;\n\tu64 tmp64;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\t \n\tif (fe_params->symbol_rate < 500000)\n\t\treturn -EINVAL;\n\n\t \n\ttmp64 = ((u64)tda10086_read_byte(state, 0x52)\n\t\t| (tda10086_read_byte(state, 0x51) << 8));\n\tif (tmp64 & 0x8000)\n\t\ttmp64 |= 0xffffffffffff0000ULL;\n\ttmp64 = (tmp64 * (SACLK/1000ULL));\n\tdo_div(tmp64, (1ULL<<15) * (1ULL<<1));\n\tfe_params->frequency = (int) state->frequency + (int) tmp64;\n\n\t \n\tval = tda10086_read_byte(state, 0x0c);\n\tif (val & 0x80) {\n\t\tswitch(val & 0x40) {\n\t\tcase 0x00:\n\t\t\tfe_params->inversion = INVERSION_OFF;\n\t\t\tif (state->config->invert)\n\t\t\t\tfe_params->inversion = INVERSION_ON;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfe_params->inversion = INVERSION_ON;\n\t\t\tif (state->config->invert)\n\t\t\t\tfe_params->inversion = INVERSION_OFF;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ttda10086_read_byte(state, 0x0f);\n\t\tswitch(val & 0x02) {\n\t\tcase 0x00:\n\t\t\tfe_params->inversion = INVERSION_OFF;\n\t\t\tif (state->config->invert)\n\t\t\t\tfe_params->inversion = INVERSION_ON;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfe_params->inversion = INVERSION_ON;\n\t\t\tif (state->config->invert)\n\t\t\t\tfe_params->inversion = INVERSION_OFF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\ttmp = tda10086_read_byte(state, 0x1d);\n\tif (tmp & 0x80)\n\t\ttmp |= 0xffffff00;\n\ttmp = (tmp * 480 * (1<<1)) / 128;\n\ttmp = ((state->symbol_rate/1000) * tmp) / (1000000/1000);\n\tfe_params->symbol_rate = state->symbol_rate + tmp;\n\n\t \n\tval = (tda10086_read_byte(state, 0x0d) & 0x70) >> 4;\n\tswitch(val) {\n\tcase 0x00:\n\t\tfe_params->fec_inner = FEC_1_2;\n\t\tbreak;\n\tcase 0x01:\n\t\tfe_params->fec_inner = FEC_2_3;\n\t\tbreak;\n\tcase 0x02:\n\t\tfe_params->fec_inner = FEC_3_4;\n\t\tbreak;\n\tcase 0x03:\n\t\tfe_params->fec_inner = FEC_4_5;\n\t\tbreak;\n\tcase 0x04:\n\t\tfe_params->fec_inner = FEC_5_6;\n\t\tbreak;\n\tcase 0x05:\n\t\tfe_params->fec_inner = FEC_6_7;\n\t\tbreak;\n\tcase 0x06:\n\t\tfe_params->fec_inner = FEC_7_8;\n\t\tbreak;\n\tcase 0x07:\n\t\tfe_params->fec_inner = FEC_8_9;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tda10086_read_status(struct dvb_frontend *fe,\n\t\t\t\tenum fe_status *fe_status)\n{\n\tstruct tda10086_state* state = fe->demodulator_priv;\n\tu8 val;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\tval = tda10086_read_byte(state, 0x0e);\n\t*fe_status = 0;\n\tif (val & 0x01)\n\t\t*fe_status |= FE_HAS_SIGNAL;\n\tif (val & 0x02)\n\t\t*fe_status |= FE_HAS_CARRIER;\n\tif (val & 0x04)\n\t\t*fe_status |= FE_HAS_VITERBI;\n\tif (val & 0x08)\n\t\t*fe_status |= FE_HAS_SYNC;\n\tif (val & 0x10) {\n\t\t*fe_status |= FE_HAS_LOCK;\n\t\tif (!state->has_lock) {\n\t\t\tstate->has_lock = true;\n\t\t\t \n\t\t\ttda10086_write_byte(state, 0x02, 0x00);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tda10086_read_signal_strength(struct dvb_frontend* fe, u16 * signal)\n{\n\tstruct tda10086_state* state = fe->demodulator_priv;\n\tu8 _str;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\t_str = 0xff - tda10086_read_byte(state, 0x43);\n\t*signal = (_str << 8) | _str;\n\n\treturn 0;\n}\n\nstatic int tda10086_read_snr(struct dvb_frontend* fe, u16 * snr)\n{\n\tstruct tda10086_state* state = fe->demodulator_priv;\n\tu8 _snr;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\t_snr = 0xff - tda10086_read_byte(state, 0x1c);\n\t*snr = (_snr << 8) | _snr;\n\n\treturn 0;\n}\n\nstatic int tda10086_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct tda10086_state* state = fe->demodulator_priv;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\t \n\t*ucblocks = tda10086_read_byte(state, 0x18) & 0x7f;\n\n\t \n\ttda10086_write_byte(state, 0x18, 0x00);\n\ttda10086_write_byte(state, 0x18, 0x80);\n\n\treturn 0;\n}\n\nstatic int tda10086_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct tda10086_state* state = fe->demodulator_priv;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\t \n\t*ber = 0;\n\t*ber |= tda10086_read_byte(state, 0x15);\n\t*ber |= tda10086_read_byte(state, 0x16) << 8;\n\t*ber |= (tda10086_read_byte(state, 0x17) & 0xf) << 16;\n\n\treturn 0;\n}\n\nstatic int tda10086_sleep(struct dvb_frontend* fe)\n{\n\tstruct tda10086_state* state = fe->demodulator_priv;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\ttda10086_write_mask(state, 0x00, 0x08, 0x08);\n\n\treturn 0;\n}\n\nstatic int tda10086_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\n{\n\tstruct tda10086_state* state = fe->demodulator_priv;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\tif (enable) {\n\t\ttda10086_write_mask(state, 0x00, 0x10, 0x10);\n\t} else {\n\t\ttda10086_write_mask(state, 0x00, 0x10, 0x00);\n\t}\n\n\treturn 0;\n}\n\nstatic int tda10086_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tif (p->symbol_rate > 20000000) {\n\t\tfesettings->min_delay_ms = 50;\n\t\tfesettings->step_size = 2000;\n\t\tfesettings->max_drift = 8000;\n\t} else if (p->symbol_rate > 12000000) {\n\t\tfesettings->min_delay_ms = 100;\n\t\tfesettings->step_size = 1500;\n\t\tfesettings->max_drift = 9000;\n\t} else if (p->symbol_rate > 8000000) {\n\t\tfesettings->min_delay_ms = 100;\n\t\tfesettings->step_size = 1000;\n\t\tfesettings->max_drift = 8000;\n\t} else if (p->symbol_rate > 4000000) {\n\t\tfesettings->min_delay_ms = 100;\n\t\tfesettings->step_size = 500;\n\t\tfesettings->max_drift = 7000;\n\t} else if (p->symbol_rate > 2000000) {\n\t\tfesettings->min_delay_ms = 200;\n\t\tfesettings->step_size = p->symbol_rate / 8000;\n\t\tfesettings->max_drift = 14 * fesettings->step_size;\n\t} else {\n\t\tfesettings->min_delay_ms = 200;\n\t\tfesettings->step_size =  p->symbol_rate / 8000;\n\t\tfesettings->max_drift = 18 * fesettings->step_size;\n\t}\n\n\treturn 0;\n}\n\nstatic void tda10086_release(struct dvb_frontend* fe)\n{\n\tstruct tda10086_state *state = fe->demodulator_priv;\n\ttda10086_sleep(fe);\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops tda10086_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name     = \"Philips TDA10086 DVB-S\",\n\t\t.frequency_min_hz      =  950 * MHz,\n\t\t.frequency_max_hz      = 2150 * MHz,\n\t\t.frequency_stepsize_hz =  125 * kHz,\n\t\t.symbol_rate_min  = 1000000,\n\t\t.symbol_rate_max  = 45000000,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK\n\t},\n\n\t.release = tda10086_release,\n\n\t.init = tda10086_init,\n\t.sleep = tda10086_sleep,\n\t.i2c_gate_ctrl = tda10086_i2c_gate_ctrl,\n\n\t.set_frontend = tda10086_set_frontend,\n\t.get_frontend = tda10086_get_frontend,\n\t.get_tune_settings = tda10086_get_tune_settings,\n\n\t.read_status = tda10086_read_status,\n\t.read_ber = tda10086_read_ber,\n\t.read_signal_strength = tda10086_read_signal_strength,\n\t.read_snr = tda10086_read_snr,\n\t.read_ucblocks = tda10086_read_ucblocks,\n\n\t.diseqc_send_master_cmd = tda10086_send_master_cmd,\n\t.diseqc_send_burst = tda10086_send_burst,\n\t.set_tone = tda10086_set_tone,\n};\n\nstruct dvb_frontend* tda10086_attach(const struct tda10086_config* config,\n\t\t\t\t     struct i2c_adapter* i2c)\n{\n\tstruct tda10086_state *state;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\t \n\tstate = kzalloc(sizeof(struct tda10086_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t \n\tif (tda10086_read_byte(state, 0x1e) != 0xe1) {\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\n\t \n\tmemcpy(&state->frontend.ops, &tda10086_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n}\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"Philips TDA10086 DVB-S Demodulator\");\nMODULE_AUTHOR(\"Andrew de Quincey\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(tda10086_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}