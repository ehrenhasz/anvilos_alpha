{
  "module_name": "mt352.c",
  "hash_id": "6cbae3e9b597ab22219ead2203837713f618a3e6782f20066edf956f13f6f983",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/mt352.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"mt352_priv.h\"\n#include \"mt352.h\"\n\nstruct mt352_state {\n\tstruct i2c_adapter* i2c;\n\tstruct dvb_frontend frontend;\n\n\t \n\tstruct mt352_config config;\n};\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) printk(KERN_DEBUG \"mt352: \" args); \\\n\t} while (0)\n\nstatic int mt352_single_write(struct dvb_frontend *fe, u8 reg, u8 val)\n{\n\tstruct mt352_state* state = fe->demodulator_priv;\n\tu8 buf[2] = { reg, val };\n\tstruct i2c_msg msg = { .addr = state->config.demod_address, .flags = 0,\n\t\t\t       .buf = buf, .len = 2 };\n\tint err = i2c_transfer(state->i2c, &msg, 1);\n\tif (err != 1) {\n\t\tprintk(\"mt352_write() to reg %x failed (err = %d)!\\n\", reg, err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int _mt352_write(struct dvb_frontend* fe, const u8 ibuf[], int ilen)\n{\n\tint err,i;\n\tfor (i=0; i < ilen-1; i++)\n\t\tif ((err = mt352_single_write(fe,ibuf[0]+i,ibuf[i+1])))\n\t\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int mt352_read_register(struct mt352_state* state, u8 reg)\n{\n\tint ret;\n\tu8 b0 [] = { reg };\n\tu8 b1 [] = { 0 };\n\tstruct i2c_msg msg [] = { { .addr = state->config.demod_address,\n\t\t\t\t    .flags = 0,\n\t\t\t\t    .buf = b0, .len = 1 },\n\t\t\t\t  { .addr = state->config.demod_address,\n\t\t\t\t    .flags = I2C_M_RD,\n\t\t\t\t    .buf = b1, .len = 1 } };\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\tprintk(\"%s: readreg error (reg=%d, ret==%i)\\n\",\n\t\t       __func__, reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn b1[0];\n}\n\nstatic int mt352_sleep(struct dvb_frontend* fe)\n{\n\tstatic u8 mt352_softdown[] = { CLOCK_CTL, 0x20, 0x08 };\n\n\t_mt352_write(fe, mt352_softdown, sizeof(mt352_softdown));\n\treturn 0;\n}\n\nstatic void mt352_calc_nominal_rate(struct mt352_state* state,\n\t\t\t\t    u32 bandwidth,\n\t\t\t\t    unsigned char *buf)\n{\n\tu32 adc_clock = 20480;  \n\tu32 bw,value;\n\n\tswitch (bandwidth) {\n\tcase 6000000:\n\t\tbw = 6;\n\t\tbreak;\n\tcase 7000000:\n\t\tbw = 7;\n\t\tbreak;\n\tcase 8000000:\n\tdefault:\n\t\tbw = 8;\n\t\tbreak;\n\t}\n\tif (state->config.adc_clock)\n\t\tadc_clock = state->config.adc_clock;\n\n\tvalue = 64 * bw * (1<<16) / (7 * 8);\n\tvalue = value * 1000 / adc_clock;\n\tdprintk(\"%s: bw %d, adc_clock %d => 0x%x\\n\",\n\t\t__func__, bw, adc_clock, value);\n\tbuf[0] = msb(value);\n\tbuf[1] = lsb(value);\n}\n\nstatic void mt352_calc_input_freq(struct mt352_state* state,\n\t\t\t\t  unsigned char *buf)\n{\n\tint adc_clock = 20480;  \n\tint if2       = 36167;  \n\tint ife,value;\n\n\tif (state->config.adc_clock)\n\t\tadc_clock = state->config.adc_clock;\n\tif (state->config.if2)\n\t\tif2 = state->config.if2;\n\n\tif (adc_clock >= if2 * 2)\n\t\tife = if2;\n\telse {\n\t\tife = adc_clock - (if2 % adc_clock);\n\t\tif (ife > adc_clock / 2)\n\t\t\tife = adc_clock - ife;\n\t}\n\tvalue = -16374 * ife / adc_clock;\n\tdprintk(\"%s: if2 %d, ife %d, adc_clock %d => %d / 0x%x\\n\",\n\t\t__func__, if2, ife, adc_clock, value, value & 0x3fff);\n\tbuf[0] = msb(value);\n\tbuf[1] = lsb(value);\n}\n\nstatic int mt352_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *op = &fe->dtv_property_cache;\n\tstruct mt352_state* state = fe->demodulator_priv;\n\tunsigned char buf[13];\n\tstatic unsigned char tuner_go[] = { 0x5d, 0x01 };\n\tstatic unsigned char fsm_go[]   = { 0x5e, 0x01 };\n\tunsigned int tps = 0;\n\n\tswitch (op->code_rate_HP) {\n\t\tcase FEC_2_3:\n\t\t\ttps |= (1 << 7);\n\t\t\tbreak;\n\t\tcase FEC_3_4:\n\t\t\ttps |= (2 << 7);\n\t\t\tbreak;\n\t\tcase FEC_5_6:\n\t\t\ttps |= (3 << 7);\n\t\t\tbreak;\n\t\tcase FEC_7_8:\n\t\t\ttps |= (4 << 7);\n\t\t\tbreak;\n\t\tcase FEC_1_2:\n\t\tcase FEC_AUTO:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (op->code_rate_LP) {\n\t\tcase FEC_2_3:\n\t\t\ttps |= (1 << 4);\n\t\t\tbreak;\n\t\tcase FEC_3_4:\n\t\t\ttps |= (2 << 4);\n\t\t\tbreak;\n\t\tcase FEC_5_6:\n\t\t\ttps |= (3 << 4);\n\t\t\tbreak;\n\t\tcase FEC_7_8:\n\t\t\ttps |= (4 << 4);\n\t\t\tbreak;\n\t\tcase FEC_1_2:\n\t\tcase FEC_AUTO:\n\t\t\tbreak;\n\t\tcase FEC_NONE:\n\t\t\tif (op->hierarchy == HIERARCHY_AUTO ||\n\t\t\t    op->hierarchy == HIERARCHY_NONE)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (op->modulation) {\n\t\tcase QPSK:\n\t\t\tbreak;\n\t\tcase QAM_AUTO:\n\t\tcase QAM_16:\n\t\t\ttps |= (1 << 13);\n\t\t\tbreak;\n\t\tcase QAM_64:\n\t\t\ttps |= (2 << 13);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (op->transmission_mode) {\n\t\tcase TRANSMISSION_MODE_2K:\n\t\tcase TRANSMISSION_MODE_AUTO:\n\t\t\tbreak;\n\t\tcase TRANSMISSION_MODE_8K:\n\t\t\ttps |= (1 << 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (op->guard_interval) {\n\t\tcase GUARD_INTERVAL_1_32:\n\t\tcase GUARD_INTERVAL_AUTO:\n\t\t\tbreak;\n\t\tcase GUARD_INTERVAL_1_16:\n\t\t\ttps |= (1 << 2);\n\t\t\tbreak;\n\t\tcase GUARD_INTERVAL_1_8:\n\t\t\ttps |= (2 << 2);\n\t\t\tbreak;\n\t\tcase GUARD_INTERVAL_1_4:\n\t\t\ttps |= (3 << 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (op->hierarchy) {\n\t\tcase HIERARCHY_AUTO:\n\t\tcase HIERARCHY_NONE:\n\t\t\tbreak;\n\t\tcase HIERARCHY_1:\n\t\t\ttps |= (1 << 10);\n\t\t\tbreak;\n\t\tcase HIERARCHY_2:\n\t\t\ttps |= (2 << 10);\n\t\t\tbreak;\n\t\tcase HIERARCHY_4:\n\t\t\ttps |= (3 << 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\n\tbuf[0] = TPS_GIVEN_1;  \n\n\tbuf[1] = msb(tps);       \n\tbuf[2] = lsb(tps);\n\n\tbuf[3] = 0x50;  \n\n\n\tmt352_calc_nominal_rate(state, op->bandwidth_hz, buf+4);\n\tmt352_calc_input_freq(state, buf+6);\n\n\tif (state->config.no_tuner) {\n\t\tif (fe->ops.tuner_ops.set_params) {\n\t\t\tfe->ops.tuner_ops.set_params(fe);\n\t\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t\t}\n\n\t\t_mt352_write(fe, buf, 8);\n\t\t_mt352_write(fe, fsm_go, 2);\n\t} else {\n\t\tif (fe->ops.tuner_ops.calc_regs) {\n\t\t\tfe->ops.tuner_ops.calc_regs(fe, buf+8, 5);\n\t\t\tbuf[8] <<= 1;\n\t\t\t_mt352_write(fe, buf, sizeof(buf));\n\t\t\t_mt352_write(fe, tuner_go, 2);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mt352_get_parameters(struct dvb_frontend* fe,\n\t\t\t\tstruct dtv_frontend_properties *op)\n{\n\tstruct mt352_state* state = fe->demodulator_priv;\n\tu16 tps;\n\tu16 div;\n\tu8 trl;\n\tstatic const u8 tps_fec_to_api[8] =\n\t{\n\t\tFEC_1_2,\n\t\tFEC_2_3,\n\t\tFEC_3_4,\n\t\tFEC_5_6,\n\t\tFEC_7_8,\n\t\tFEC_AUTO,\n\t\tFEC_AUTO,\n\t\tFEC_AUTO\n\t};\n\n\tif ( (mt352_read_register(state,0x00) & 0xC0) != 0xC0 )\n\t\treturn -EINVAL;\n\n\t \n\ttps = (mt352_read_register(state, TPS_RECEIVED_1) << 8) | mt352_read_register(state, TPS_RECEIVED_0);\n\tdiv = (mt352_read_register(state, CHAN_START_1) << 8) | mt352_read_register(state, CHAN_START_0);\n\ttrl = mt352_read_register(state, TRL_NOMINAL_RATE_1);\n\n\top->code_rate_HP = tps_fec_to_api[(tps >> 7) & 7];\n\top->code_rate_LP = tps_fec_to_api[(tps >> 4) & 7];\n\n\tswitch ( (tps >> 13) & 3)\n\t{\n\t\tcase 0:\n\t\t\top->modulation = QPSK;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\top->modulation = QAM_16;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\top->modulation = QAM_64;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\top->modulation = QAM_AUTO;\n\t\t\tbreak;\n\t}\n\n\top->transmission_mode = (tps & 0x01) ? TRANSMISSION_MODE_8K : TRANSMISSION_MODE_2K;\n\n\tswitch ( (tps >> 2) & 3)\n\t{\n\t\tcase 0:\n\t\t\top->guard_interval = GUARD_INTERVAL_1_32;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\top->guard_interval = GUARD_INTERVAL_1_16;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\top->guard_interval = GUARD_INTERVAL_1_8;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\top->guard_interval = GUARD_INTERVAL_1_4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\top->guard_interval = GUARD_INTERVAL_AUTO;\n\t\t\tbreak;\n\t}\n\n\tswitch ( (tps >> 10) & 7)\n\t{\n\t\tcase 0:\n\t\t\top->hierarchy = HIERARCHY_NONE;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\top->hierarchy = HIERARCHY_1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\top->hierarchy = HIERARCHY_2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\top->hierarchy = HIERARCHY_4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\top->hierarchy = HIERARCHY_AUTO;\n\t\t\tbreak;\n\t}\n\n\top->frequency = (500 * (div - IF_FREQUENCYx6)) / 3 * 1000;\n\n\tif (trl == 0x72)\n\t\top->bandwidth_hz = 8000000;\n\telse if (trl == 0x64)\n\t\top->bandwidth_hz = 7000000;\n\telse\n\t\top->bandwidth_hz = 6000000;\n\n\n\tif (mt352_read_register(state, STATUS_2) & 0x02)\n\t\top->inversion = INVERSION_OFF;\n\telse\n\t\top->inversion = INVERSION_ON;\n\n\treturn 0;\n}\n\nstatic int mt352_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct mt352_state* state = fe->demodulator_priv;\n\tint s0, s1, s3;\n\n\t \n\n\tif ((s0 = mt352_read_register(state, STATUS_0)) < 0)\n\t\treturn -EREMOTEIO;\n\tif ((s1 = mt352_read_register(state, STATUS_1)) < 0)\n\t\treturn -EREMOTEIO;\n\tif ((s3 = mt352_read_register(state, STATUS_3)) < 0)\n\t\treturn -EREMOTEIO;\n\n\t*status = 0;\n\tif (s0 & (1 << 4))\n\t\t*status |= FE_HAS_CARRIER;\n\tif (s0 & (1 << 1))\n\t\t*status |= FE_HAS_VITERBI;\n\tif (s0 & (1 << 5))\n\t\t*status |= FE_HAS_LOCK;\n\tif (s1 & (1 << 1))\n\t\t*status |= FE_HAS_SYNC;\n\tif (s3 & (1 << 6))\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif ((*status & (FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC)) !=\n\t\t      (FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC))\n\t\t*status &= ~FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int mt352_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct mt352_state* state = fe->demodulator_priv;\n\n\t*ber = (mt352_read_register (state, RS_ERR_CNT_2) << 16) |\n\t       (mt352_read_register (state, RS_ERR_CNT_1) << 8) |\n\t       (mt352_read_register (state, RS_ERR_CNT_0));\n\n\treturn 0;\n}\n\nstatic int mt352_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\tstruct mt352_state* state = fe->demodulator_priv;\n\n\t \n\tu16 signal = ((mt352_read_register(state, AGC_GAIN_1) & 0x0f) << 12) |\n\t\t(mt352_read_register(state, AGC_GAIN_0) << 4);\n\n\t \n\t*strength = ~signal;\n\treturn 0;\n}\n\nstatic int mt352_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct mt352_state* state = fe->demodulator_priv;\n\n\tu8 _snr = mt352_read_register (state, SNR);\n\t*snr = (_snr << 8) | _snr;\n\n\treturn 0;\n}\n\nstatic int mt352_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct mt352_state* state = fe->demodulator_priv;\n\n\t*ucblocks = (mt352_read_register (state,  RS_UBC_1) << 8) |\n\t\t    (mt352_read_register (state,  RS_UBC_0));\n\n\treturn 0;\n}\n\nstatic int mt352_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fe_tune_settings)\n{\n\tfe_tune_settings->min_delay_ms = 800;\n\tfe_tune_settings->step_size = 0;\n\tfe_tune_settings->max_drift = 0;\n\n\treturn 0;\n}\n\nstatic int mt352_init(struct dvb_frontend* fe)\n{\n\tstruct mt352_state* state = fe->demodulator_priv;\n\n\tstatic u8 mt352_reset_attach [] = { RESET, 0xC0 };\n\n\tdprintk(\"%s: hello\\n\",__func__);\n\n\tif ((mt352_read_register(state, CLOCK_CTL) & 0x10) == 0 ||\n\t    (mt352_read_register(state, CONFIG) & 0x20) == 0) {\n\n\t\t \n\t\t_mt352_write(fe, mt352_reset_attach, sizeof(mt352_reset_attach));\n\t\treturn state->config.demod_init(fe);\n\t}\n\n\treturn 0;\n}\n\nstatic void mt352_release(struct dvb_frontend* fe)\n{\n\tstruct mt352_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops mt352_ops;\n\nstruct dvb_frontend* mt352_attach(const struct mt352_config* config,\n\t\t\t\t  struct i2c_adapter* i2c)\n{\n\tstruct mt352_state* state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct mt352_state), GFP_KERNEL);\n\tif (state == NULL) goto error;\n\n\t \n\tstate->i2c = i2c;\n\tmemcpy(&state->config,config,sizeof(struct mt352_config));\n\n\t \n\tif (mt352_read_register(state, CHIP_ID) != ID_MT352) goto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &mt352_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops mt352_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name\t\t\t= \"Zarlink MT352 DVB-T\",\n\t\t.frequency_min_hz\t= 174 * MHz,\n\t\t.frequency_max_hz\t= 862 * MHz,\n\t\t.frequency_stepsize_hz\t= 166667,\n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO | FE_CAN_RECOVER |\n\t\t\tFE_CAN_MUTE_TS\n\t},\n\n\t.release = mt352_release,\n\n\t.init = mt352_init,\n\t.sleep = mt352_sleep,\n\t.write = _mt352_write,\n\n\t.set_frontend = mt352_set_parameters,\n\t.get_frontend = mt352_get_parameters,\n\t.get_tune_settings = mt352_get_tune_settings,\n\n\t.read_status = mt352_read_status,\n\t.read_ber = mt352_read_ber,\n\t.read_signal_strength = mt352_read_signal_strength,\n\t.read_snr = mt352_read_snr,\n\t.read_ucblocks = mt352_read_ucblocks,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"Zarlink MT352 DVB-T Demodulator driver\");\nMODULE_AUTHOR(\"Holger Waechtler, Daniel Mack, Antonio Mancuso\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(mt352_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}