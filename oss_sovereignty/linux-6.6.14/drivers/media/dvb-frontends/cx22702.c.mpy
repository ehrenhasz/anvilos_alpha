{
  "module_name": "cx22702.c",
  "hash_id": "5c74e150690e7483a0a9b38dfda81544c3b3e70369fdf5847a345bee53b79640",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cx22702.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <media/dvb_frontend.h>\n#include \"cx22702.h\"\n\nstruct cx22702_state {\n\n\tstruct i2c_adapter *i2c;\n\n\t \n\tconst struct cx22702_config *config;\n\n\tstruct dvb_frontend frontend;\n\n\t \n\tu8 prevUCBlocks;\n};\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Enable verbose debug messages\");\n\n#define dprintk\tif (debug) printk\n\n \nstatic const u8 init_tab[] = {\n\t0x00, 0x00,  \n\t0x0B, 0x06,\n\t0x09, 0x01,\n\t0x0D, 0x41,\n\t0x16, 0x32,\n\t0x20, 0x0A,\n\t0x21, 0x17,\n\t0x24, 0x3e,\n\t0x26, 0xff,\n\t0x27, 0x10,\n\t0x28, 0x00,\n\t0x29, 0x00,\n\t0x2a, 0x10,\n\t0x2b, 0x00,\n\t0x2c, 0x10,\n\t0x2d, 0x00,\n\t0x48, 0xd4,\n\t0x49, 0x56,\n\t0x6b, 0x1e,\n\t0xc8, 0x02,\n\t0xf9, 0x00,\n\t0xfa, 0x00,\n\t0xfb, 0x00,\n\t0xfc, 0x00,\n\t0xfd, 0x00,\n};\n\nstatic int cx22702_writereg(struct cx22702_state *state, u8 reg, u8 data)\n{\n\tint ret;\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = {\n\t\t.addr = state->config->demod_address, .flags = 0,\n\t\t\t.buf = buf, .len = 2 };\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (unlikely(ret != 1)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"%s: error (reg == 0x%02x, val == 0x%02x, ret == %i)\\n\",\n\t\t\t__func__, reg, data, ret);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 cx22702_readreg(struct cx22702_state *state, u8 reg)\n{\n\tint ret;\n\tu8 data;\n\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->config->demod_address, .flags = 0,\n\t\t\t.buf = &reg, .len = 1 },\n\t\t{ .addr = state->config->demod_address, .flags = I2C_M_RD,\n\t\t\t.buf = &data, .len = 1 } };\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (unlikely(ret != 2)) {\n\t\tprintk(KERN_ERR \"%s: error (reg == 0x%02x, ret == %i)\\n\",\n\t\t\t__func__, reg, ret);\n\t\treturn 0;\n\t}\n\n\treturn data;\n}\n\nstatic int cx22702_set_inversion(struct cx22702_state *state, int inversion)\n{\n\tu8 val;\n\n\tval = cx22702_readreg(state, 0x0C);\n\tswitch (inversion) {\n\tcase INVERSION_AUTO:\n\t\treturn -EOPNOTSUPP;\n\tcase INVERSION_ON:\n\t\tval |= 0x01;\n\t\tbreak;\n\tcase INVERSION_OFF:\n\t\tval &= 0xfe;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn cx22702_writereg(state, 0x0C, val);\n}\n\n \nstatic int cx22702_get_tps(struct cx22702_state *state,\n\t\t\t   struct dtv_frontend_properties *p)\n{\n\tu8 val;\n\n\t \n\tif (!(cx22702_readreg(state, 0x0A) & 0x20))\n\t\treturn -EAGAIN;\n\n\tval = cx22702_readreg(state, 0x01);\n\tswitch ((val & 0x18) >> 3) {\n\tcase 0:\n\t\tp->modulation = QPSK;\n\t\tbreak;\n\tcase 1:\n\t\tp->modulation = QAM_16;\n\t\tbreak;\n\tcase 2:\n\t\tp->modulation = QAM_64;\n\t\tbreak;\n\t}\n\tswitch (val & 0x07) {\n\tcase 0:\n\t\tp->hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tp->hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tcase 2:\n\t\tp->hierarchy = HIERARCHY_2;\n\t\tbreak;\n\tcase 3:\n\t\tp->hierarchy = HIERARCHY_4;\n\t\tbreak;\n\t}\n\n\n\tval = cx22702_readreg(state, 0x02);\n\tswitch ((val & 0x38) >> 3) {\n\tcase 0:\n\t\tp->code_rate_HP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tp->code_rate_HP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tp->code_rate_HP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tp->code_rate_HP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tp->code_rate_HP = FEC_7_8;\n\t\tbreak;\n\t}\n\tswitch (val & 0x07) {\n\tcase 0:\n\t\tp->code_rate_LP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tp->code_rate_LP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tp->code_rate_LP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tp->code_rate_LP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tp->code_rate_LP = FEC_7_8;\n\t\tbreak;\n\t}\n\n\tval = cx22702_readreg(state, 0x03);\n\tswitch ((val & 0x0c) >> 2) {\n\tcase 0:\n\t\tp->guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\tp->guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\tp->guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tp->guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\t}\n\tswitch (val & 0x03) {\n\tcase 0:\n\t\tp->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n\tcase 1:\n\t\tp->transmission_mode = TRANSMISSION_MODE_8K;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cx22702_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct cx22702_state *state = fe->demodulator_priv;\n\tu8 val;\n\n\tdprintk(\"%s(%d)\\n\", __func__, enable);\n\tval = cx22702_readreg(state, 0x0D);\n\tif (enable)\n\t\tval &= 0xfe;\n\telse\n\t\tval |= 0x01;\n\treturn cx22702_writereg(state, 0x0D, val);\n}\n\n \nstatic int cx22702_set_tps(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu8 val;\n\tstruct cx22702_state *state = fe->demodulator_priv;\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t \n\tcx22702_set_inversion(state, p->inversion);\n\n\t \n\tval = cx22702_readreg(state, 0x0C) & 0xcf;\n\tswitch (p->bandwidth_hz) {\n\tcase 6000000:\n\t\tval |= 0x20;\n\t\tbreak;\n\tcase 7000000:\n\t\tval |= 0x10;\n\t\tbreak;\n\tcase 8000000:\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid bandwidth\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tcx22702_writereg(state, 0x0C, val);\n\n\tp->code_rate_LP = FEC_AUTO;  \n\n\t \n\tif ((p->hierarchy == HIERARCHY_AUTO) ||\n\t   (p->modulation == QAM_AUTO) ||\n\t   (p->code_rate_HP == FEC_AUTO) ||\n\t   (p->code_rate_LP == FEC_AUTO) ||\n\t   (p->guard_interval == GUARD_INTERVAL_AUTO) ||\n\t   (p->transmission_mode == TRANSMISSION_MODE_AUTO)) {\n\n\t\t \n\t\tcx22702_writereg(state, 0x06, 0x10);\n\t\tcx22702_writereg(state, 0x07, 0x9);\n\t\tcx22702_writereg(state, 0x08, 0xC1);\n\t\tcx22702_writereg(state, 0x0B, cx22702_readreg(state, 0x0B)\n\t\t\t& 0xfc);\n\t\tcx22702_writereg(state, 0x0C,\n\t\t\t(cx22702_readreg(state, 0x0C) & 0xBF) | 0x40);\n\t\tcx22702_writereg(state, 0x00, 0x01);  \n\t\tdprintk(\"%s: Autodetecting\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t \n\tswitch (p->modulation) {\t\t \n\tcase QPSK:\n\t\tval = 0x00;\n\t\tbreak;\n\tcase QAM_16:\n\t\tval = 0x08;\n\t\tbreak;\n\tcase QAM_64:\n\t\tval = 0x10;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid modulation\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->hierarchy) {\t \n\tcase HIERARCHY_NONE:\n\t\tbreak;\n\tcase HIERARCHY_1:\n\t\tval |= 0x01;\n\t\tbreak;\n\tcase HIERARCHY_2:\n\t\tval |= 0x02;\n\t\tbreak;\n\tcase HIERARCHY_4:\n\t\tval |= 0x03;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid hierarchy\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tcx22702_writereg(state, 0x06, val);\n\n\tswitch (p->code_rate_HP) {\t\t \n\tcase FEC_NONE:\n\tcase FEC_1_2:\n\t\tval = 0x00;\n\t\tbreak;\n\tcase FEC_2_3:\n\t\tval = 0x08;\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tval = 0x10;\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tval = 0x18;\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tval = 0x20;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid code_rate_HP\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->code_rate_LP) {\t\t \n\tcase FEC_NONE:\n\tcase FEC_1_2:\n\t\tbreak;\n\tcase FEC_2_3:\n\t\tval |= 0x01;\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tval |= 0x02;\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tval |= 0x03;\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tval |= 0x04;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid code_rate_LP\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tcx22702_writereg(state, 0x07, val);\n\n\tswitch (p->guard_interval) {\t\t \n\tcase GUARD_INTERVAL_1_32:\n\t\tval = 0x00;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_16:\n\t\tval = 0x04;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_8:\n\t\tval = 0x08;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_4:\n\t\tval = 0x0c;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid guard_interval\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->transmission_mode) {\t\t \n\tcase TRANSMISSION_MODE_2K:\n\t\tbreak;\n\tcase TRANSMISSION_MODE_8K:\n\t\tval |= 0x1;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid transmission_mode\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tcx22702_writereg(state, 0x08, val);\n\tcx22702_writereg(state, 0x0B,\n\t\t(cx22702_readreg(state, 0x0B) & 0xfc) | 0x02);\n\tcx22702_writereg(state, 0x0C,\n\t\t(cx22702_readreg(state, 0x0C) & 0xBF) | 0x40);\n\n\t \n\tcx22702_writereg(state, 0x00, 0x01);\n\n\treturn 0;\n}\n\n \nstatic int cx22702_init(struct dvb_frontend *fe)\n{\n\tint i;\n\tstruct cx22702_state *state = fe->demodulator_priv;\n\n\tcx22702_writereg(state, 0x00, 0x02);\n\n\tmsleep(10);\n\n\tfor (i = 0; i < ARRAY_SIZE(init_tab); i += 2)\n\t\tcx22702_writereg(state, init_tab[i], init_tab[i + 1]);\n\n\tcx22702_writereg(state, 0xf8, (state->config->output_mode << 1)\n\t\t& 0x02);\n\n\tcx22702_i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\nstatic int cx22702_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct cx22702_state *state = fe->demodulator_priv;\n\tu8 reg0A;\n\tu8 reg23;\n\n\t*status = 0;\n\n\treg0A = cx22702_readreg(state, 0x0A);\n\treg23 = cx22702_readreg(state, 0x23);\n\n\tdprintk(\"%s: status demod=0x%02x agc=0x%02x\\n\"\n\t\t, __func__, reg0A, reg23);\n\n\tif (reg0A & 0x10) {\n\t\t*status |= FE_HAS_LOCK;\n\t\t*status |= FE_HAS_VITERBI;\n\t\t*status |= FE_HAS_SYNC;\n\t}\n\n\tif (reg0A & 0x20)\n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (reg23 < 0xf0)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\treturn 0;\n}\n\nstatic int cx22702_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct cx22702_state *state = fe->demodulator_priv;\n\n\tif (cx22702_readreg(state, 0xE4) & 0x02) {\n\t\t \n\t\t*ber = (cx22702_readreg(state, 0xDE) & 0x7F) << 7\n\t\t\t| (cx22702_readreg(state, 0xDF) & 0x7F);\n\t} else {\n\t\t \n\t\t*ber = (cx22702_readreg(state, 0xDE) & 0x7F) << 7\n\t\t\t| cx22702_readreg(state, 0xDF);\n\t}\n\n\treturn 0;\n}\n\nstatic int cx22702_read_signal_strength(struct dvb_frontend *fe,\n\tu16 *signal_strength)\n{\n\tstruct cx22702_state *state = fe->demodulator_priv;\n\tu8 reg23;\n\n\t \n\treg23 = cx22702_readreg(state, 0x23);\n\tif (reg23 & 0x80) {\n\t\t*signal_strength = 0;\n\t} else {\n\t\treg23 = ~reg23 & 0x7f;\n\t\t \n\t\t*signal_strength = (reg23 << 9) | (reg23 << 2) | (reg23 >> 5);\n\t}\n\n\treturn 0;\n}\n\nstatic int cx22702_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct cx22702_state *state = fe->demodulator_priv;\n\n\tu16 rs_ber;\n\tif (cx22702_readreg(state, 0xE4) & 0x02) {\n\t\t \n\t\trs_ber = (cx22702_readreg(state, 0xDE) & 0x7F) << 7\n\t\t\t| (cx22702_readreg(state, 0xDF) & 0x7F);\n\t} else {\n\t\t \n\t\trs_ber = (cx22702_readreg(state, 0xDE) & 0x7F) << 8\n\t\t\t| cx22702_readreg(state, 0xDF);\n\t}\n\t*snr = ~rs_ber;\n\n\treturn 0;\n}\n\nstatic int cx22702_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct cx22702_state *state = fe->demodulator_priv;\n\n\tu8 _ucblocks;\n\n\t \n\t_ucblocks = cx22702_readreg(state, 0xE3);\n\tif (state->prevUCBlocks < _ucblocks)\n\t\t*ucblocks = (_ucblocks - state->prevUCBlocks);\n\telse\n\t\t*ucblocks = state->prevUCBlocks - _ucblocks;\n\tstate->prevUCBlocks = _ucblocks;\n\n\treturn 0;\n}\n\nstatic int cx22702_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *c)\n{\n\tstruct cx22702_state *state = fe->demodulator_priv;\n\n\tu8 reg0C = cx22702_readreg(state, 0x0C);\n\n\tc->inversion = reg0C & 0x1 ? INVERSION_ON : INVERSION_OFF;\n\treturn cx22702_get_tps(state, c);\n}\n\nstatic int cx22702_get_tune_settings(struct dvb_frontend *fe,\n\tstruct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic void cx22702_release(struct dvb_frontend *fe)\n{\n\tstruct cx22702_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops cx22702_ops;\n\nstruct dvb_frontend *cx22702_attach(const struct cx22702_config *config,\n\tstruct i2c_adapter *i2c)\n{\n\tstruct cx22702_state *state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct cx22702_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t \n\tif (cx22702_readreg(state, 0x1f) != 0x3)\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &cx22702_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cx22702_attach);\n\nstatic const struct dvb_frontend_ops cx22702_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name\t\t\t= \"Conexant CX22702 DVB-T\",\n\t\t.frequency_min_hz\t= 177 * MHz,\n\t\t.frequency_max_hz\t= 858 * MHz,\n\t\t.frequency_stepsize_hz\t= 166666,\n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\tFE_CAN_HIERARCHY_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |\n\t\tFE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_RECOVER\n\t},\n\n\t.release = cx22702_release,\n\n\t.init = cx22702_init,\n\t.i2c_gate_ctrl = cx22702_i2c_gate_ctrl,\n\n\t.set_frontend = cx22702_set_tps,\n\t.get_frontend = cx22702_get_frontend,\n\t.get_tune_settings = cx22702_get_tune_settings,\n\n\t.read_status = cx22702_read_status,\n\t.read_ber = cx22702_read_ber,\n\t.read_signal_strength = cx22702_read_signal_strength,\n\t.read_snr = cx22702_read_snr,\n\t.read_ucblocks = cx22702_read_ucblocks,\n};\n\nMODULE_DESCRIPTION(\"Conexant CX22702 DVB-T Demodulator driver\");\nMODULE_AUTHOR(\"Steven Toth\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}