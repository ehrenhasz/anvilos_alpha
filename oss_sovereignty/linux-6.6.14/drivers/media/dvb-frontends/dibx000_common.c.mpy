{
  "module_name": "dibx000_common.c",
  "hash_id": "27337b690088df9f79d90b710bcf31f46d59468da143f9d91d896a5bca1650af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/dibx000_common.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\n#include \"dibx000_common.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"turn on debugging (default: 0)\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\nstatic int dibx000_write_word(struct dibx000_i2c_master *mst, u16 reg, u16 val)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&mst->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmst->i2c_write_buffer[0] = (reg >> 8) & 0xff;\n\tmst->i2c_write_buffer[1] = reg & 0xff;\n\tmst->i2c_write_buffer[2] = (val >> 8) & 0xff;\n\tmst->i2c_write_buffer[3] = val & 0xff;\n\n\tmemset(mst->msg, 0, sizeof(struct i2c_msg));\n\tmst->msg[0].addr = mst->i2c_addr;\n\tmst->msg[0].flags = 0;\n\tmst->msg[0].buf = mst->i2c_write_buffer;\n\tmst->msg[0].len = 4;\n\n\tret = i2c_transfer(mst->i2c_adap, mst->msg, 1) != 1 ? -EREMOTEIO : 0;\n\tmutex_unlock(&mst->i2c_buffer_lock);\n\n\treturn ret;\n}\n\nstatic u16 dibx000_read_word(struct dibx000_i2c_master *mst, u16 reg)\n{\n\tu16 ret;\n\n\tif (mutex_lock_interruptible(&mst->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn 0;\n\t}\n\n\tmst->i2c_write_buffer[0] = reg >> 8;\n\tmst->i2c_write_buffer[1] = reg & 0xff;\n\n\tmemset(mst->msg, 0, 2 * sizeof(struct i2c_msg));\n\tmst->msg[0].addr = mst->i2c_addr;\n\tmst->msg[0].flags = 0;\n\tmst->msg[0].buf = mst->i2c_write_buffer;\n\tmst->msg[0].len = 2;\n\tmst->msg[1].addr = mst->i2c_addr;\n\tmst->msg[1].flags = I2C_M_RD;\n\tmst->msg[1].buf = mst->i2c_read_buffer;\n\tmst->msg[1].len = 2;\n\n\tif (i2c_transfer(mst->i2c_adap, mst->msg, 2) != 2)\n\t\tdprintk(\"i2c read error on %d\\n\", reg);\n\n\tret = (mst->i2c_read_buffer[0] << 8) | mst->i2c_read_buffer[1];\n\tmutex_unlock(&mst->i2c_buffer_lock);\n\n\treturn ret;\n}\n\nstatic int dibx000_is_i2c_done(struct dibx000_i2c_master *mst)\n{\n\tint i = 100;\n\tu16 status;\n\n\twhile (((status = dibx000_read_word(mst, mst->base_reg + 2)) & 0x0100) == 0 && --i > 0)\n\t\t;\n\n\t \n\tif (i == 0)\n\t\treturn -EREMOTEIO;\n\n\t \n\tif ((status & 0x0080) == 0)\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic int dibx000_master_i2c_write(struct dibx000_i2c_master *mst, struct i2c_msg *msg, u8 stop)\n{\n\tu16 data;\n\tu16 da;\n\tu16 i;\n\tu16 txlen = msg->len, len;\n\tconst u8 *b = msg->buf;\n\n\twhile (txlen) {\n\t\tdibx000_read_word(mst, mst->base_reg + 2);\n\n\t\tlen = txlen > 8 ? 8 : txlen;\n\t\tfor (i = 0; i < len; i += 2) {\n\t\t\tdata = *b++ << 8;\n\t\t\tif (i+1 < len)\n\t\t\t\tdata |= *b++;\n\t\t\tdibx000_write_word(mst, mst->base_reg, data);\n\t\t}\n\t\tda = (((u8) (msg->addr))  << 9) |\n\t\t\t(1           << 8) |\n\t\t\t(1           << 7) |\n\t\t\t(0           << 6) |\n\t\t\t(0           << 5) |\n\t\t\t((len & 0x7) << 2) |\n\t\t\t(0           << 1) |\n\t\t\t(0           << 0);\n\n\t\tif (txlen == msg->len)\n\t\t\tda |= 1 << 5;  \n\n\t\tif (txlen-len == 0 && stop)\n\t\t\tda |= 1 << 6;  \n\n\t\tdibx000_write_word(mst, mst->base_reg+1, da);\n\n\t\tif (dibx000_is_i2c_done(mst) != 0)\n\t\t\treturn -EREMOTEIO;\n\t\ttxlen -= len;\n\t}\n\n\treturn 0;\n}\n\nstatic int dibx000_master_i2c_read(struct dibx000_i2c_master *mst, struct i2c_msg *msg)\n{\n\tu16 da;\n\tu8 *b = msg->buf;\n\tu16 rxlen = msg->len, len;\n\n\twhile (rxlen) {\n\t\tlen = rxlen > 8 ? 8 : rxlen;\n\t\tda = (((u8) (msg->addr)) << 9) |\n\t\t\t(1           << 8) |\n\t\t\t(1           << 7) |\n\t\t\t(0           << 6) |\n\t\t\t(0           << 5) |\n\t\t\t((len & 0x7) << 2) |\n\t\t\t(1           << 1) |\n\t\t\t(0           << 0);\n\n\t\tif (rxlen == msg->len)\n\t\t\tda |= 1 << 5;  \n\n\t\tif (rxlen-len == 0)\n\t\t\tda |= 1 << 6;  \n\t\tdibx000_write_word(mst, mst->base_reg+1, da);\n\n\t\tif (dibx000_is_i2c_done(mst) != 0)\n\t\t\treturn -EREMOTEIO;\n\n\t\trxlen -= len;\n\n\t\twhile (len) {\n\t\t\tda = dibx000_read_word(mst, mst->base_reg);\n\t\t\t*b++ = (da >> 8) & 0xff;\n\t\t\tlen--;\n\t\t\tif (len >= 1) {\n\t\t\t\t*b++ =  da   & 0xff;\n\t\t\t\tlen--;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint dibx000_i2c_set_speed(struct i2c_adapter *i2c_adap, u16 speed)\n{\n\tstruct dibx000_i2c_master *mst = i2c_get_adapdata(i2c_adap);\n\n\tif (mst->device_rev < DIB7000MC && speed < 235)\n\t\tspeed = 235;\n\treturn dibx000_write_word(mst, mst->base_reg + 3, (u16)(60000 / speed));\n\n}\nEXPORT_SYMBOL(dibx000_i2c_set_speed);\n\nstatic u32 dibx000_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic int dibx000_i2c_select_interface(struct dibx000_i2c_master *mst,\n\t\t\t\t\tenum dibx000_i2c_interface intf)\n{\n\tif (mst->device_rev > DIB3000MC && mst->selected_interface != intf) {\n\t\tdprintk(\"selecting interface: %d\\n\", intf);\n\t\tmst->selected_interface = intf;\n\t\treturn dibx000_write_word(mst, mst->base_reg + 4, intf);\n\t}\n\treturn 0;\n}\n\nstatic int dibx000_i2c_master_xfer_gpio12(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\n{\n\tstruct dibx000_i2c_master *mst = i2c_get_adapdata(i2c_adap);\n\tint msg_index;\n\tint ret = 0;\n\n\tdibx000_i2c_select_interface(mst, DIBX000_I2C_INTERFACE_GPIO_1_2);\n\tfor (msg_index = 0; msg_index < num; msg_index++) {\n\t\tif (msg[msg_index].flags & I2C_M_RD) {\n\t\t\tret = dibx000_master_i2c_read(mst, &msg[msg_index]);\n\t\t\tif (ret != 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tret = dibx000_master_i2c_write(mst, &msg[msg_index], 1);\n\t\t\tif (ret != 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn num;\n}\n\nstatic int dibx000_i2c_master_xfer_gpio34(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\n{\n\tstruct dibx000_i2c_master *mst = i2c_get_adapdata(i2c_adap);\n\tint msg_index;\n\tint ret = 0;\n\n\tdibx000_i2c_select_interface(mst, DIBX000_I2C_INTERFACE_GPIO_3_4);\n\tfor (msg_index = 0; msg_index < num; msg_index++) {\n\t\tif (msg[msg_index].flags & I2C_M_RD) {\n\t\t\tret = dibx000_master_i2c_read(mst, &msg[msg_index]);\n\t\t\tif (ret != 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tret = dibx000_master_i2c_write(mst, &msg[msg_index], 1);\n\t\t\tif (ret != 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn num;\n}\n\nstatic struct i2c_algorithm dibx000_i2c_master_gpio12_xfer_algo = {\n\t.master_xfer = dibx000_i2c_master_xfer_gpio12,\n\t.functionality = dibx000_i2c_func,\n};\n\nstatic struct i2c_algorithm dibx000_i2c_master_gpio34_xfer_algo = {\n\t.master_xfer = dibx000_i2c_master_xfer_gpio34,\n\t.functionality = dibx000_i2c_func,\n};\n\nstatic int dibx000_i2c_gate_ctrl(struct dibx000_i2c_master *mst, u8 tx[4],\n\t\t\t\t u8 addr, int onoff)\n{\n\tu16 val;\n\n\n\tif (onoff)\n\t\tval = addr << 8;\t\n\telse\n\t\tval = 1 << 7;\n\n\tif (mst->device_rev > DIB7000)\n\t\tval <<= 1;\n\n\ttx[0] = (((mst->base_reg + 1) >> 8) & 0xff);\n\ttx[1] = ((mst->base_reg + 1) & 0xff);\n\ttx[2] = val >> 8;\n\ttx[3] = val & 0xff;\n\n\treturn 0;\n}\n\nstatic int dibx000_i2c_gated_gpio67_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t\t\tstruct i2c_msg msg[], int num)\n{\n\tstruct dibx000_i2c_master *mst = i2c_get_adapdata(i2c_adap);\n\tint ret;\n\n\tif (num > 32) {\n\t\tdprintk(\"%s: too much I2C message to be transmitted (%i). Maximum is 32\",\n\t\t\t__func__, num);\n\t\treturn -ENOMEM;\n\t}\n\n\tdibx000_i2c_select_interface(mst, DIBX000_I2C_INTERFACE_GPIO_6_7);\n\n\tif (mutex_lock_interruptible(&mst->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(mst->msg, 0, sizeof(struct i2c_msg) * (2 + num));\n\n\t \n\tdibx000_i2c_gate_ctrl(mst, &mst->i2c_write_buffer[0], msg[0].addr, 1);\n\tmst->msg[0].addr = mst->i2c_addr;\n\tmst->msg[0].buf = &mst->i2c_write_buffer[0];\n\tmst->msg[0].len = 4;\n\n\tmemcpy(&mst->msg[1], msg, sizeof(struct i2c_msg) * num);\n\n\t \n\tdibx000_i2c_gate_ctrl(mst, &mst->i2c_write_buffer[4], 0, 0);\n\tmst->msg[num + 1].addr = mst->i2c_addr;\n\tmst->msg[num + 1].buf = &mst->i2c_write_buffer[4];\n\tmst->msg[num + 1].len = 4;\n\n\tret = (i2c_transfer(mst->i2c_adap, mst->msg, 2 + num) == 2 + num ?\n\t\t\tnum : -EIO);\n\n\tmutex_unlock(&mst->i2c_buffer_lock);\n\treturn ret;\n}\n\nstatic struct i2c_algorithm dibx000_i2c_gated_gpio67_algo = {\n\t.master_xfer = dibx000_i2c_gated_gpio67_xfer,\n\t.functionality = dibx000_i2c_func,\n};\n\nstatic int dibx000_i2c_gated_tuner_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t\t\tstruct i2c_msg msg[], int num)\n{\n\tstruct dibx000_i2c_master *mst = i2c_get_adapdata(i2c_adap);\n\tint ret;\n\n\tif (num > 32) {\n\t\tdprintk(\"%s: too much I2C message to be transmitted (%i). Maximum is 32\",\n\t\t\t__func__, num);\n\t\treturn -ENOMEM;\n\t}\n\n\tdibx000_i2c_select_interface(mst, DIBX000_I2C_INTERFACE_TUNER);\n\n\tif (mutex_lock_interruptible(&mst->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemset(mst->msg, 0, sizeof(struct i2c_msg) * (2 + num));\n\n\t \n\tdibx000_i2c_gate_ctrl(mst, &mst->i2c_write_buffer[0], msg[0].addr, 1);\n\tmst->msg[0].addr = mst->i2c_addr;\n\tmst->msg[0].buf = &mst->i2c_write_buffer[0];\n\tmst->msg[0].len = 4;\n\n\tmemcpy(&mst->msg[1], msg, sizeof(struct i2c_msg) * num);\n\n\t \n\tdibx000_i2c_gate_ctrl(mst, &mst->i2c_write_buffer[4], 0, 0);\n\tmst->msg[num + 1].addr = mst->i2c_addr;\n\tmst->msg[num + 1].buf = &mst->i2c_write_buffer[4];\n\tmst->msg[num + 1].len = 4;\n\n\tret = (i2c_transfer(mst->i2c_adap, mst->msg, 2 + num) == 2 + num ?\n\t\t\tnum : -EIO);\n\tmutex_unlock(&mst->i2c_buffer_lock);\n\treturn ret;\n}\n\nstatic struct i2c_algorithm dibx000_i2c_gated_tuner_algo = {\n\t.master_xfer = dibx000_i2c_gated_tuner_xfer,\n\t.functionality = dibx000_i2c_func,\n};\n\nstruct i2c_adapter *dibx000_get_i2c_adapter(struct dibx000_i2c_master *mst,\n\t\t\t\t\t\tenum dibx000_i2c_interface intf,\n\t\t\t\t\t\tint gating)\n{\n\tstruct i2c_adapter *i2c = NULL;\n\n\tswitch (intf) {\n\tcase DIBX000_I2C_INTERFACE_TUNER:\n\t\tif (gating)\n\t\t\ti2c = &mst->gated_tuner_i2c_adap;\n\t\tbreak;\n\tcase DIBX000_I2C_INTERFACE_GPIO_1_2:\n\t\tif (!gating)\n\t\t\ti2c = &mst->master_i2c_adap_gpio12;\n\t\tbreak;\n\tcase DIBX000_I2C_INTERFACE_GPIO_3_4:\n\t\tif (!gating)\n\t\t\ti2c = &mst->master_i2c_adap_gpio34;\n\t\tbreak;\n\tcase DIBX000_I2C_INTERFACE_GPIO_6_7:\n\t\tif (gating)\n\t\t\ti2c = &mst->master_i2c_adap_gpio67;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"incorrect I2C interface selected\\n\");\n\t\tbreak;\n\t}\n\n\treturn i2c;\n}\n\nEXPORT_SYMBOL(dibx000_get_i2c_adapter);\n\nvoid dibx000_reset_i2c_master(struct dibx000_i2c_master *mst)\n{\n\t \n\tu8 tx[4];\n\tstruct i2c_msg m = {.addr = mst->i2c_addr,.buf = tx,.len = 4 };\n\n\tdibx000_i2c_gate_ctrl(mst, tx, 0, 0);\n\ti2c_transfer(mst->i2c_adap, &m, 1);\n\tmst->selected_interface = 0xff;\t\n\tdibx000_i2c_select_interface(mst, DIBX000_I2C_INTERFACE_TUNER);\n}\n\nEXPORT_SYMBOL(dibx000_reset_i2c_master);\n\nstatic int i2c_adapter_init(struct i2c_adapter *i2c_adap,\n\t\t\t\tstruct i2c_algorithm *algo, const char *name,\n\t\t\t\tstruct dibx000_i2c_master *mst)\n{\n\tstrscpy(i2c_adap->name, name, sizeof(i2c_adap->name));\n\ti2c_adap->algo = algo;\n\ti2c_adap->algo_data = NULL;\n\ti2c_set_adapdata(i2c_adap, mst);\n\tif (i2c_add_adapter(i2c_adap) < 0)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nint dibx000_init_i2c_master(struct dibx000_i2c_master *mst, u16 device_rev,\n\t\t\t\tstruct i2c_adapter *i2c_adap, u8 i2c_addr)\n{\n\tint ret;\n\n\tmutex_init(&mst->i2c_buffer_lock);\n\tif (mutex_lock_interruptible(&mst->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemset(mst->msg, 0, sizeof(struct i2c_msg));\n\tmst->msg[0].addr = i2c_addr >> 1;\n\tmst->msg[0].flags = 0;\n\tmst->msg[0].buf = mst->i2c_write_buffer;\n\tmst->msg[0].len = 4;\n\n\tmst->device_rev = device_rev;\n\tmst->i2c_adap = i2c_adap;\n\tmst->i2c_addr = i2c_addr >> 1;\n\n\tif (device_rev == DIB7000P || device_rev == DIB8000)\n\t\tmst->base_reg = 1024;\n\telse\n\t\tmst->base_reg = 768;\n\n\tmst->gated_tuner_i2c_adap.dev.parent = mst->i2c_adap->dev.parent;\n\tif (i2c_adapter_init\n\t\t\t(&mst->gated_tuner_i2c_adap, &dibx000_i2c_gated_tuner_algo,\n\t\t\t \"DiBX000 tuner I2C bus\", mst) != 0)\n\t\tpr_err(\"could not initialize the tuner i2c_adapter\\n\");\n\n\tmst->master_i2c_adap_gpio12.dev.parent = mst->i2c_adap->dev.parent;\n\tif (i2c_adapter_init\n\t\t\t(&mst->master_i2c_adap_gpio12, &dibx000_i2c_master_gpio12_xfer_algo,\n\t\t\t \"DiBX000 master GPIO12 I2C bus\", mst) != 0)\n\t\tpr_err(\"could not initialize the master i2c_adapter\\n\");\n\n\tmst->master_i2c_adap_gpio34.dev.parent = mst->i2c_adap->dev.parent;\n\tif (i2c_adapter_init\n\t\t\t(&mst->master_i2c_adap_gpio34, &dibx000_i2c_master_gpio34_xfer_algo,\n\t\t\t \"DiBX000 master GPIO34 I2C bus\", mst) != 0)\n\t\tpr_err(\"could not initialize the master i2c_adapter\\n\");\n\n\tmst->master_i2c_adap_gpio67.dev.parent = mst->i2c_adap->dev.parent;\n\tif (i2c_adapter_init\n\t\t\t(&mst->master_i2c_adap_gpio67, &dibx000_i2c_gated_gpio67_algo,\n\t\t\t \"DiBX000 master GPIO67 I2C bus\", mst) != 0)\n\t\tpr_err(\"could not initialize the master i2c_adapter\\n\");\n\n\t \n\tdibx000_i2c_gate_ctrl(mst, mst->i2c_write_buffer, 0, 0);\n\n\tret = (i2c_transfer(i2c_adap, mst->msg, 1) == 1);\n\tmutex_unlock(&mst->i2c_buffer_lock);\n\n\treturn ret;\n}\n\nEXPORT_SYMBOL(dibx000_init_i2c_master);\n\nvoid dibx000_exit_i2c_master(struct dibx000_i2c_master *mst)\n{\n\ti2c_del_adapter(&mst->gated_tuner_i2c_adap);\n\ti2c_del_adapter(&mst->master_i2c_adap_gpio12);\n\ti2c_del_adapter(&mst->master_i2c_adap_gpio34);\n\ti2c_del_adapter(&mst->master_i2c_adap_gpio67);\n}\nEXPORT_SYMBOL(dibx000_exit_i2c_master);\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"Common function the DiBcom demodulator family\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}