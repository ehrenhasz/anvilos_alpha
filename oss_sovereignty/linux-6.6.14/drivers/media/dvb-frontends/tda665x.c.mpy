{
  "module_name": "tda665x.c",
  "hash_id": "ef8589c2e2282e0e55636ffc7bcaec18a086447af468c79ca2e97deaa1fcdd54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tda665x.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"tda665x.h\"\n\nstruct tda665x_state {\n\tstruct dvb_frontend\t\t*fe;\n\tstruct i2c_adapter\t\t*i2c;\n\tconst struct tda665x_config\t*config;\n\n\tu32 frequency;\n\tu32 bandwidth;\n};\n\nstatic int tda665x_read(struct tda665x_state *state, u8 *buf)\n{\n\tconst struct tda665x_config *config = state->config;\n\tint err = 0;\n\tstruct i2c_msg msg = { .addr = config->addr, .flags = I2C_M_RD, .buf = buf, .len = 2 };\n\n\terr = i2c_transfer(state->i2c, &msg, 1);\n\tif (err != 1)\n\t\tgoto exit;\n\n\treturn err;\nexit:\n\tprintk(KERN_ERR \"%s: I/O Error err=<%d>\\n\", __func__, err);\n\treturn err;\n}\n\nstatic int tda665x_write(struct tda665x_state *state, u8 *buf, u8 length)\n{\n\tconst struct tda665x_config *config = state->config;\n\tint err = 0;\n\tstruct i2c_msg msg = { .addr = config->addr, .flags = 0, .buf = buf, .len = length };\n\n\terr = i2c_transfer(state->i2c, &msg, 1);\n\tif (err != 1)\n\t\tgoto exit;\n\n\treturn err;\nexit:\n\tprintk(KERN_ERR \"%s: I/O Error err=<%d>\\n\", __func__, err);\n\treturn err;\n}\n\nstatic int tda665x_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct tda665x_state *state = fe->tuner_priv;\n\n\t*frequency = state->frequency;\n\n\treturn 0;\n}\n\nstatic int tda665x_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tstruct tda665x_state *state = fe->tuner_priv;\n\tu8 result = 0;\n\tint err = 0;\n\n\t*status = 0;\n\n\terr = tda665x_read(state, &result);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tif ((result >> 6) & 0x01) {\n\t\tprintk(KERN_DEBUG \"%s: Tuner Phase Locked\\n\", __func__);\n\t\t*status = 1;\n\t}\n\n\treturn err;\nexit:\n\tprintk(KERN_ERR \"%s: I/O Error\\n\", __func__);\n\treturn err;\n}\n\nstatic int tda665x_set_frequency(struct dvb_frontend *fe,\n\t\t\t\t u32 new_frequency)\n{\n\tstruct tda665x_state *state = fe->tuner_priv;\n\tconst struct tda665x_config *config = state->config;\n\tu32 frequency, status = 0;\n\tu8 buf[4];\n\tint err = 0;\n\n\tif ((new_frequency < config->frequency_max)\n\t    || (new_frequency > config->frequency_min)) {\n\t\tprintk(KERN_ERR \"%s: Frequency beyond limits, frequency=%d\\n\",\n\t\t       __func__, new_frequency);\n\t\treturn -EINVAL;\n\t}\n\n\tfrequency = new_frequency;\n\n\tfrequency += config->frequency_offst;\n\tfrequency *= config->ref_multiplier;\n\tfrequency += config->ref_divider >> 1;\n\tfrequency /= config->ref_divider;\n\n\tbuf[0] = (u8) ((frequency & 0x7f00) >> 8);\n\tbuf[1] = (u8) (frequency & 0x00ff) >> 0;\n\tbuf[2] = 0x80 | 0x40 | 0x02;\n\tbuf[3] = 0x00;\n\n\t \n\tfrequency = new_frequency;\n\n\tif (frequency < 153000000) {\n\t\t \n\t\tbuf[3] |= 0x01;  \n\t\tif (frequency < 68000000)\n\t\t\tbuf[3] |= 0x40;  \n\t\tif (frequency < 1040000000)\n\t\t\tbuf[3] |= 0x60;  \n\t\tif (frequency < 1250000000)\n\t\t\tbuf[3] |= 0x80;  \n\t\telse\n\t\t\tbuf[3] |= 0xa0;  \n\t} else if (frequency < 438000000) {\n\t\t \n\t\tbuf[3] |= 0x02;  \n\t\tif (frequency < 230000000)\n\t\t\tbuf[3] |= 0x40;\n\t\tif (frequency < 300000000)\n\t\t\tbuf[3] |= 0x60;\n\t\telse\n\t\t\tbuf[3] |= 0x80;\n\t} else {\n\t\t \n\t\tbuf[3] |= 0x04;  \n\t\tif (frequency < 470000000)\n\t\t\tbuf[3] |= 0x60;\n\t\tif (frequency < 526000000)\n\t\t\tbuf[3] |= 0x80;\n\t\telse\n\t\t\tbuf[3] |= 0xa0;\n\t}\n\n\t \n\terr = tda665x_write(state, buf, 5);\n\tif (err < 0)\n\t\tgoto exit;\n\n\t \n\tprintk(KERN_DEBUG \"%s: Waiting to Phase LOCK\\n\", __func__);\n\tmsleep(20);\n\t \n\terr = tda665x_get_status(fe, &status);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tif (status == 1) {\n\t\tprintk(KERN_DEBUG \"%s: Tuner Phase locked: status=%d\\n\",\n\t\t       __func__, status);\n\t\tstate->frequency = frequency;  \n\t} else {\n\t\tprintk(KERN_ERR \"%s: No Phase lock: status=%d\\n\",\n\t\t       __func__, status);\n\t}\n\n\treturn 0;\nexit:\n\tprintk(KERN_ERR \"%s: I/O Error\\n\", __func__);\n\treturn err;\n}\n\nstatic int tda665x_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\ttda665x_set_frequency(fe, c->frequency);\n\n\treturn 0;\n}\n\nstatic void tda665x_release(struct dvb_frontend *fe)\n{\n\tstruct tda665x_state *state = fe->tuner_priv;\n\n\tfe->tuner_priv = NULL;\n\tkfree(state);\n}\n\nstatic const struct dvb_tuner_ops tda665x_ops = {\n\t.get_status\t= tda665x_get_status,\n\t.set_params\t= tda665x_set_params,\n\t.get_frequency\t= tda665x_get_frequency,\n\t.release\t= tda665x_release\n};\n\nstruct dvb_frontend *tda665x_attach(struct dvb_frontend *fe,\n\t\t\t\t    const struct tda665x_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct tda665x_state *state = NULL;\n\tstruct dvb_tuner_info *info;\n\n\tstate = kzalloc(sizeof(struct tda665x_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tstate->config\t\t= config;\n\tstate->i2c\t\t= i2c;\n\tstate->fe\t\t= fe;\n\tfe->tuner_priv\t\t= state;\n\tfe->ops.tuner_ops\t= tda665x_ops;\n\tinfo\t\t\t = &fe->ops.tuner_ops.info;\n\n\tmemcpy(info->name, config->name, sizeof(config->name));\n\tinfo->frequency_min_hz\t= config->frequency_min;\n\tinfo->frequency_max_hz\t= config->frequency_max;\n\tinfo->frequency_step_hz\t= config->frequency_offst;\n\n\tprintk(KERN_DEBUG \"%s: Attaching TDA665x (%s) tuner\\n\", __func__, info->name);\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(tda665x_attach);\n\nMODULE_DESCRIPTION(\"TDA665x driver\");\nMODULE_AUTHOR(\"Manu Abraham\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}