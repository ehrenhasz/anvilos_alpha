{
  "module_name": "mt312.c",
  "hash_id": "c38f096f6e3d6a6b1a5273aea45267b4265ff1fae96df88befde560c7fe43f06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/mt312.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"mt312_priv.h\"\n#include \"mt312.h\"\n\n \n#define MAX_XFER_SIZE  64\n\nstruct mt312_state {\n\tstruct i2c_adapter *i2c;\n\t \n\tconst struct mt312_config *config;\n\tstruct dvb_frontend frontend;\n\n\tu8 id;\n\tunsigned long xtal;\n\tu8 freq_mult;\n};\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_DEBUG \"mt312: \" args); \\\n\t} while (0)\n\n#define MT312_PLL_CLK\t\t10000000UL\t \n#define MT312_PLL_CLK_10_111\t10111000UL\t \n\nstatic int mt312_read(struct mt312_state *state, const enum mt312_reg_addr reg,\n\t\t      u8 *buf, const size_t count)\n{\n\tint ret;\n\tstruct i2c_msg msg[2];\n\tu8 regbuf[1] = { reg };\n\n\tmsg[0].addr = state->config->demod_address;\n\tmsg[0].flags = 0;\n\tmsg[0].buf = regbuf;\n\tmsg[0].len = 1;\n\tmsg[1].addr = state->config->demod_address;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].buf = buf;\n\tmsg[1].len = count;\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\tprintk(KERN_DEBUG \"%s: ret == %d\\n\", __func__, ret);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif (debug) {\n\t\tint i;\n\t\tdprintk(\"R(%d):\", reg & 0x7f);\n\t\tfor (i = 0; i < count; i++)\n\t\t\tprintk(KERN_CONT \" %02x\", buf[i]);\n\t\tprintk(\"\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int mt312_write(struct mt312_state *state, const enum mt312_reg_addr reg,\n\t\t       const u8 *src, const size_t count)\n{\n\tint ret;\n\tu8 buf[MAX_XFER_SIZE];\n\tstruct i2c_msg msg;\n\n\tif (1 + count > sizeof(buf)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"mt312: write: len=%zu is too big!\\n\", count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (debug) {\n\t\tint i;\n\t\tdprintk(\"W(%d):\", reg & 0x7f);\n\t\tfor (i = 0; i < count; i++)\n\t\t\tprintk(KERN_CONT \" %02x\", src[i]);\n\t\tprintk(\"\\n\");\n\t}\n\n\tbuf[0] = reg;\n\tmemcpy(&buf[1], src, count);\n\n\tmsg.addr = state->config->demod_address;\n\tmsg.flags = 0;\n\tmsg.buf = buf;\n\tmsg.len = count + 1;\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1) {\n\t\tdprintk(\"%s: ret == %d\\n\", __func__, ret);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int mt312_readreg(struct mt312_state *state,\n\t\t\t\tconst enum mt312_reg_addr reg, u8 *val)\n{\n\treturn mt312_read(state, reg, val, 1);\n}\n\nstatic inline int mt312_writereg(struct mt312_state *state,\n\t\t\t\t const enum mt312_reg_addr reg, const u8 val)\n{\n\tu8 tmp = val;  \n\n\n\treturn mt312_write(state, reg, &tmp, 1);\n}\n\nstatic int mt312_reset(struct mt312_state *state, const u8 full)\n{\n\treturn mt312_writereg(state, RESET, full ? 0x80 : 0x40);\n}\n\nstatic int mt312_get_inversion(struct mt312_state *state,\n\t\t\t       enum fe_spectral_inversion *i)\n{\n\tint ret;\n\tu8 vit_mode;\n\n\tret = mt312_readreg(state, VIT_MODE, &vit_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (vit_mode & 0x80)\t \n\t\t*i = (vit_mode & 0x40) ? INVERSION_ON : INVERSION_OFF;\n\n\treturn 0;\n}\n\nstatic int mt312_get_symbol_rate(struct mt312_state *state, u32 *sr)\n{\n\tint ret;\n\tu8 sym_rate_h;\n\tu8 dec_ratio;\n\tu16 sym_rat_op;\n\tu16 monitor;\n\tu8 buf[2];\n\n\tret = mt312_readreg(state, SYM_RATE_H, &sym_rate_h);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (sym_rate_h & 0x80) {\n\t\t \n\t\tret = mt312_writereg(state, MON_CTRL, 0x03);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = mt312_read(state, MONITOR_H, buf, sizeof(buf));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmonitor = (buf[0] << 8) | buf[1];\n\n\t\tdprintk(\"sr(auto) = %u\\n\",\n\t\t\tDIV_ROUND_CLOSEST(monitor * 15625, 4));\n\t} else {\n\t\tret = mt312_writereg(state, MON_CTRL, 0x05);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = mt312_read(state, MONITOR_H, buf, sizeof(buf));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdec_ratio = ((buf[0] >> 5) & 0x07) * 32;\n\n\t\tret = mt312_read(state, SYM_RAT_OP_H, buf, sizeof(buf));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsym_rat_op = (buf[0] << 8) | buf[1];\n\n\t\tdprintk(\"sym_rat_op=%d dec_ratio=%d\\n\",\n\t\t       sym_rat_op, dec_ratio);\n\t\tdprintk(\"*sr(manual) = %lu\\n\",\n\t\t       (((state->xtal * 8192) / (sym_rat_op + 8192)) *\n\t\t\t2) - dec_ratio);\n\t}\n\n\treturn 0;\n}\n\nstatic int mt312_get_code_rate(struct mt312_state *state, enum fe_code_rate *cr)\n{\n\tconst enum fe_code_rate fec_tab[8] =\n\t    { FEC_1_2, FEC_2_3, FEC_3_4, FEC_5_6, FEC_6_7, FEC_7_8,\n\t\tFEC_AUTO, FEC_AUTO };\n\n\tint ret;\n\tu8 fec_status;\n\n\tret = mt312_readreg(state, FEC_STATUS, &fec_status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*cr = fec_tab[(fec_status >> 4) & 0x07];\n\n\treturn 0;\n}\n\nstatic int mt312_initfe(struct dvb_frontend *fe)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 buf[2];\n\n\t \n\tret = mt312_writereg(state, CONFIG,\n\t\t\t(state->freq_mult == 6 ? 0x88 : 0x8c));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tudelay(150);\n\n\t \n\tret = mt312_reset(state, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n \n\t{\n\t\tu8 buf_def[8] = { 0x14, 0x12, 0x03, 0x02,\n\t\t\t\t  0x01, 0x00, 0x00, 0x00 };\n\n\t\tret = mt312_write(state, VIT_SETUP, buf_def, sizeof(buf_def));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tswitch (state->id) {\n\tcase ID_ZL10313:\n\t\t \n\t\tret = mt312_writereg(state, GPP_CTRL, 0x80);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tbuf[0] = 0x80;\n\t\tbuf[1] = 0xB0;\n\t\tret = mt312_write(state, HW_CTRL, buf, 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = mt312_writereg(state, HW_CTRL, 0x00);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = mt312_writereg(state, MPEG_CTRL, 0x00);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\t}\n\n\t \n\tbuf[0] = DIV_ROUND_CLOSEST(state->xtal * state->freq_mult * 2, 1000000);\n\n\t \n\tbuf[1] = DIV_ROUND_CLOSEST(state->xtal, 22000 * 4);\n\n\tret = mt312_write(state, SYS_CLK, buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt312_writereg(state, SNR_THS_HIGH, 0x32);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tswitch (state->id) {\n\tcase ID_ZL10313:\n\t\tbuf[0] = 0x33;\n\t\tbreak;\n\tdefault:\n\t\tbuf[0] = 0x53;\n\t\tbreak;\n\t}\n\n\tret = mt312_writereg(state, OP_CTRL, buf[0]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbuf[0] = 0x8c;\n\tbuf[1] = 0x98;\n\n\tret = mt312_write(state, TS_SW_LIM_L, buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt312_writereg(state, CS_SW_LIM, 0x69);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mt312_send_master_cmd(struct dvb_frontend *fe,\n\t\t\t\t struct dvb_diseqc_master_cmd *c)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 diseqc_mode;\n\n\tif ((c->msg_len == 0) || (c->msg_len > sizeof(c->msg)))\n\t\treturn -EINVAL;\n\n\tret = mt312_readreg(state, DISEQC_MODE, &diseqc_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt312_write(state, (0x80 | DISEQC_INSTR), c->msg, c->msg_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt312_writereg(state, DISEQC_MODE,\n\t\t\t     (diseqc_mode & 0x40) | ((c->msg_len - 1) << 3)\n\t\t\t     | 0x04);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmsleep(100);\n\n\t \n\tif (c->msg[0] & 0x02) {\n\t\tret = mt312_writereg(state, DISEQC_MODE, (diseqc_mode & 0x40));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt312_send_burst(struct dvb_frontend *fe,\n\t\t\t    const enum fe_sec_mini_cmd c)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tconst u8 mini_tab[2] = { 0x02, 0x03 };\n\n\tint ret;\n\tu8 diseqc_mode;\n\n\tif (c > SEC_MINI_B)\n\t\treturn -EINVAL;\n\n\tret = mt312_readreg(state, DISEQC_MODE, &diseqc_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt312_writereg(state, DISEQC_MODE,\n\t\t\t     (diseqc_mode & 0x40) | mini_tab[c]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mt312_set_tone(struct dvb_frontend *fe,\n\t\t\t  const enum fe_sec_tone_mode t)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tconst u8 tone_tab[2] = { 0x01, 0x00 };\n\n\tint ret;\n\tu8 diseqc_mode;\n\n\tif (t > SEC_TONE_OFF)\n\t\treturn -EINVAL;\n\n\tret = mt312_readreg(state, DISEQC_MODE, &diseqc_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt312_writereg(state, DISEQC_MODE,\n\t\t\t     (diseqc_mode & 0x40) | tone_tab[t]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mt312_set_voltage(struct dvb_frontend *fe,\n\t\t\t     const enum fe_sec_voltage v)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tconst u8 volt_tab[3] = { 0x00, 0x40, 0x00 };\n\tu8 val;\n\n\tif (v > SEC_VOLTAGE_OFF)\n\t\treturn -EINVAL;\n\n\tval = volt_tab[v];\n\tif (state->config->voltage_inverted)\n\t\tval ^= 0x40;\n\n\treturn mt312_writereg(state, DISEQC_MODE, val);\n}\n\nstatic int mt312_read_status(struct dvb_frontend *fe, enum fe_status *s)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 status[3];\n\n\t*s = 0;\n\n\tret = mt312_read(state, QPSK_STAT_H, status, sizeof(status));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdprintk(\"QPSK_STAT_H: 0x%02x, QPSK_STAT_L: 0x%02x, FEC_STATUS: 0x%02x\\n\",\n\t\tstatus[0], status[1], status[2]);\n\n\tif (status[0] & 0xc0)\n\t\t*s |= FE_HAS_SIGNAL;\t \n\tif (status[0] & 0x04)\n\t\t*s |= FE_HAS_CARRIER;\t \n\tif (status[2] & 0x02)\n\t\t*s |= FE_HAS_VITERBI;\t \n\tif (status[2] & 0x04)\n\t\t*s |= FE_HAS_SYNC;\t \n\tif (status[0] & 0x01)\n\t\t*s |= FE_HAS_LOCK;\t \n\n\treturn 0;\n}\n\nstatic int mt312_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 buf[3];\n\n\tret = mt312_read(state, RS_BERCNT_H, buf, 3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ber = ((buf[0] << 16) | (buf[1] << 8) | buf[2]) * 64;\n\n\treturn 0;\n}\n\nstatic int mt312_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t      u16 *signal_strength)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 buf[3];\n\tu16 agc;\n\ts16 err_db;\n\n\tret = mt312_read(state, AGC_H, buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tagc = (buf[0] << 6) | (buf[1] >> 2);\n\terr_db = (s16) (((buf[1] & 0x03) << 14) | buf[2] << 6) >> 6;\n\n\t*signal_strength = agc;\n\n\tdprintk(\"agc=%08x err_db=%hd\\n\", agc, err_db);\n\n\treturn 0;\n}\n\nstatic int mt312_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 buf[2];\n\n\tret = mt312_read(state, M_SNR_H, buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*snr = 0xFFFF - ((((buf[0] & 0x7f) << 8) | buf[1]) << 1);\n\n\treturn 0;\n}\n\nstatic int mt312_read_ucblocks(struct dvb_frontend *fe, u32 *ubc)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 buf[2];\n\n\tret = mt312_read(state, RS_UBC_H, buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ubc = (buf[0] << 8) | buf[1];\n\n\treturn 0;\n}\n\nstatic int mt312_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 buf[5], config_val;\n\tu16 sr;\n\n\tconst u8 fec_tab[10] =\n\t    { 0x00, 0x01, 0x02, 0x04, 0x3f, 0x08, 0x10, 0x20, 0x3f, 0x3f };\n\tconst u8 inv_tab[3] = { 0x00, 0x40, 0x80 };\n\n\tdprintk(\"%s: Freq %d\\n\", __func__, p->frequency);\n\n\tif ((p->frequency < fe->ops.info.frequency_min_hz / kHz)\n\t    || (p->frequency > fe->ops.info.frequency_max_hz / kHz))\n\t\treturn -EINVAL;\n\n\tif (((int)p->inversion < INVERSION_OFF)\n\t    || (p->inversion > INVERSION_ON))\n\t\treturn -EINVAL;\n\n\tif ((p->symbol_rate < fe->ops.info.symbol_rate_min)\n\t    || (p->symbol_rate > fe->ops.info.symbol_rate_max))\n\t\treturn -EINVAL;\n\n\tif (((int)p->fec_inner < FEC_NONE)\n\t    || (p->fec_inner > FEC_AUTO))\n\t\treturn -EINVAL;\n\n\tif ((p->fec_inner == FEC_4_5)\n\t    || (p->fec_inner == FEC_8_9))\n\t\treturn -EINVAL;\n\n\tswitch (state->id) {\n\tcase ID_VP310:\n\t \n\t\tret = mt312_readreg(state, CONFIG, &config_val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (p->symbol_rate >= 30000000) {\n\t\t\t \n\t\t\tif (state->freq_mult == 6) {\n\t\t\t\t \n\t\t\t\tstate->freq_mult = 9;\n\t\t\t\tret = mt312_initfe(fe);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (state->freq_mult == 9) {\n\t\t\t\t \n\t\t\t\tstate->freq_mult = 6;\n\t\t\t\tret = mt312_initfe(fe);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ID_MT312:\n\tcase ID_ZL10313:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t \n\tsr = DIV_ROUND_CLOSEST(p->symbol_rate * 4, 15625);\n\n\t \n\tbuf[0] = (sr >> 8) & 0x3f;\n\tbuf[1] = (sr >> 0) & 0xff;\n\n\t \n\tbuf[2] = inv_tab[p->inversion] | fec_tab[p->fec_inner];\n\n\t \n\tbuf[3] = 0x40;\t\t \n\n\tif (p->symbol_rate < 10000000)\n\t\tbuf[3] |= 0x04;\t \n\n\t \n\tbuf[4] = 0x01;\n\n\tret = mt312_write(state, SYM_RATE_H, buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt312_reset(state, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mt312_get_frontend(struct dvb_frontend *fe,\n\t\t\t      struct dtv_frontend_properties *p)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tret = mt312_get_inversion(state, &p->inversion);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt312_get_symbol_rate(state, &p->symbol_rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt312_get_code_rate(state, &p->fec_inner);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mt312_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\n\tu8 val = 0x00;\n\tint ret;\n\n\tswitch (state->id) {\n\tcase ID_ZL10313:\n\t\tret = mt312_readreg(state, GPP_CTRL, &val);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tval &= 0x80;\n\t\tbreak;\n\t}\n\n\tif (enable)\n\t\tval |= 0x40;\n\telse\n\t\tval &= ~0x40;\n\n\tret = mt312_writereg(state, GPP_CTRL, val);\n\nerror:\n\treturn ret;\n}\n\nstatic int mt312_sleep(struct dvb_frontend *fe)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 config;\n\n\t \n\tret = mt312_reset(state, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (state->id == ID_ZL10313) {\n\t\t \n\t\tret = mt312_writereg(state, GPP_CTRL, 0x00);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = mt312_writereg(state, HW_CTRL, 0x0d);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = mt312_readreg(state, CONFIG, &config);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = mt312_writereg(state, CONFIG, config & 0x7f);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mt312_get_tune_settings(struct dvb_frontend *fe,\n\t\tstruct dvb_frontend_tune_settings *fesettings)\n{\n\tfesettings->min_delay_ms = 50;\n\tfesettings->step_size = 0;\n\tfesettings->max_drift = 0;\n\treturn 0;\n}\n\nstatic void mt312_release(struct dvb_frontend *fe)\n{\n\tstruct mt312_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\n#define MT312_SYS_CLK\t\t90000000UL\t \nstatic const struct dvb_frontend_ops mt312_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name = \"Zarlink ???? DVB-S\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t\t \n\t\t.frequency_stepsize_hz = MT312_PLL_CLK / 128,\n\t\t.symbol_rate_min = MT312_SYS_CLK / 128,  \n\t\t.symbol_rate_max = MT312_SYS_CLK / 2,\n\t\t.caps =\n\t\t    FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |\n\t\t    FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |\n\t\t    FE_CAN_FEC_AUTO | FE_CAN_QPSK | FE_CAN_MUTE_TS |\n\t\t    FE_CAN_RECOVER\n\t},\n\n\t.release = mt312_release,\n\n\t.init = mt312_initfe,\n\t.sleep = mt312_sleep,\n\t.i2c_gate_ctrl = mt312_i2c_gate_ctrl,\n\n\t.set_frontend = mt312_set_frontend,\n\t.get_frontend = mt312_get_frontend,\n\t.get_tune_settings = mt312_get_tune_settings,\n\n\t.read_status = mt312_read_status,\n\t.read_ber = mt312_read_ber,\n\t.read_signal_strength = mt312_read_signal_strength,\n\t.read_snr = mt312_read_snr,\n\t.read_ucblocks = mt312_read_ucblocks,\n\n\t.diseqc_send_master_cmd = mt312_send_master_cmd,\n\t.diseqc_send_burst = mt312_send_burst,\n\t.set_tone = mt312_set_tone,\n\t.set_voltage = mt312_set_voltage,\n};\n\nstruct dvb_frontend *mt312_attach(const struct mt312_config *config,\n\t\t\t\t\tstruct i2c_adapter *i2c)\n{\n\tstruct mt312_state *state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct mt312_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t \n\tif (mt312_readreg(state, ID, &state->id) < 0)\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &mt312_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\tswitch (state->id) {\n\tcase ID_VP310:\n\t\tstrscpy(state->frontend.ops.info.name, \"Zarlink VP310 DVB-S\",\n\t\t\tsizeof(state->frontend.ops.info.name));\n\t\tstate->xtal = MT312_PLL_CLK;\n\t\tstate->freq_mult = 9;\n\t\tbreak;\n\tcase ID_MT312:\n\t\tstrscpy(state->frontend.ops.info.name, \"Zarlink MT312 DVB-S\",\n\t\t\tsizeof(state->frontend.ops.info.name));\n\t\tstate->xtal = MT312_PLL_CLK;\n\t\tstate->freq_mult = 6;\n\t\tbreak;\n\tcase ID_ZL10313:\n\t\tstrscpy(state->frontend.ops.info.name, \"Zarlink ZL10313 DVB-S\",\n\t\t\tsizeof(state->frontend.ops.info.name));\n\t\tstate->xtal = MT312_PLL_CLK_10_111;\n\t\tstate->freq_mult = 9;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"Only Zarlink VP310/MT312/ZL10313 are supported chips.\\n\");\n\t\tgoto error;\n\t}\n\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(mt312_attach);\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"Zarlink VP310/MT312/ZL10313 DVB-S Demodulator driver\");\nMODULE_AUTHOR(\"Andreas Oberritter <obi@linuxtv.org>\");\nMODULE_AUTHOR(\"Matthias Schwarzott <zzam@gentoo.org>\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}