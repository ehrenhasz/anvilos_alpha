{
  "module_name": "stv0297.c",
  "hash_id": "729e8170749308945f2417edde407ccde78e1dee671a150340733239295f3ebe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stv0297.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"stv0297.h\"\n\nstruct stv0297_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct stv0297_config *config;\n\tstruct dvb_frontend frontend;\n\n\tunsigned long last_ber;\n\tunsigned long base_freq;\n};\n\n#if 1\n#define dprintk(x...) printk(x)\n#else\n#define dprintk(x...)\n#endif\n\n#define STV0297_CLOCK_KHZ   28900\n\n\nstatic int stv0297_writereg(struct stv0297_state *state, u8 reg, u8 data)\n{\n\tint ret;\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = {.addr = state->config->demod_address,.flags = 0,.buf = buf,.len = 2 };\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tdprintk(\"%s: writereg error (reg == 0x%02x, val == 0x%02x, ret == %i)\\n\",\n\t\t\t__func__, reg, data, ret);\n\n\treturn (ret != 1) ? -1 : 0;\n}\n\nstatic int stv0297_readreg(struct stv0297_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = { {.addr = state->config->demod_address,.flags = 0,.buf = b0,.len = 1},\n\t\t\t\t {.addr = state->config->demod_address,.flags = I2C_M_RD,.buf = b1,.len = 1}\n\t\t\t       };\n\n\t\n\tif (state->config->stop_during_read) {\n\t\tif ((ret = i2c_transfer(state->i2c, &msg[0], 1)) != 1) {\n\t\t\tdprintk(\"%s: readreg error (reg == 0x%02x, ret == %i)\\n\", __func__, reg, ret);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((ret = i2c_transfer(state->i2c, &msg[1], 1)) != 1) {\n\t\t\tdprintk(\"%s: readreg error (reg == 0x%02x, ret == %i)\\n\", __func__, reg, ret);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif ((ret = i2c_transfer(state->i2c, msg, 2)) != 2) {\n\t\t\tdprintk(\"%s: readreg error (reg == 0x%02x, ret == %i)\\n\", __func__, reg, ret);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn b1[0];\n}\n\nstatic int stv0297_writereg_mask(struct stv0297_state *state, u8 reg, u8 mask, u8 data)\n{\n\tint val;\n\n\tval = stv0297_readreg(state, reg);\n\tval &= ~mask;\n\tval |= (data & mask);\n\tstv0297_writereg(state, reg, val);\n\n\treturn 0;\n}\n\nstatic int stv0297_readregs(struct stv0297_state *state, u8 reg1, u8 * b, u8 len)\n{\n\tint ret;\n\tstruct i2c_msg msg[] = { {.addr = state->config->demod_address,.flags = 0,.buf =\n\t\t\t\t  &reg1,.len = 1},\n\t{.addr = state->config->demod_address,.flags = I2C_M_RD,.buf = b,.len = len}\n\t};\n\n\t\n\tif (state->config->stop_during_read) {\n\t\tif ((ret = i2c_transfer(state->i2c, &msg[0], 1)) != 1) {\n\t\t\tdprintk(\"%s: readreg error (reg == 0x%02x, ret == %i)\\n\", __func__, reg1, ret);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((ret = i2c_transfer(state->i2c, &msg[1], 1)) != 1) {\n\t\t\tdprintk(\"%s: readreg error (reg == 0x%02x, ret == %i)\\n\", __func__, reg1, ret);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif ((ret = i2c_transfer(state->i2c, msg, 2)) != 2) {\n\t\t\tdprintk(\"%s: readreg error (reg == 0x%02x, ret == %i)\\n\", __func__, reg1, ret);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic u32 stv0297_get_symbolrate(struct stv0297_state *state)\n{\n\tu64 tmp;\n\n\ttmp = (u64)(stv0297_readreg(state, 0x55)\n\t\t    | (stv0297_readreg(state, 0x56) << 8)\n\t\t    | (stv0297_readreg(state, 0x57) << 16)\n\t\t    | (stv0297_readreg(state, 0x58) << 24));\n\n\ttmp *= STV0297_CLOCK_KHZ;\n\ttmp >>= 32;\n\n\treturn (u32) tmp;\n}\n\nstatic void stv0297_set_symbolrate(struct stv0297_state *state, u32 srate)\n{\n\tlong tmp;\n\n\ttmp = 131072L * srate;\t \n\ttmp = tmp / (STV0297_CLOCK_KHZ / 4);\t \n\ttmp = tmp * 8192L;\t \n\n\tstv0297_writereg(state, 0x55, (unsigned char) (tmp & 0xFF));\n\tstv0297_writereg(state, 0x56, (unsigned char) (tmp >> 8));\n\tstv0297_writereg(state, 0x57, (unsigned char) (tmp >> 16));\n\tstv0297_writereg(state, 0x58, (unsigned char) (tmp >> 24));\n}\n\nstatic void stv0297_set_sweeprate(struct stv0297_state *state, short fshift, long symrate)\n{\n\tlong tmp;\n\n\ttmp = (long) fshift *262144L;\t \n\ttmp /= symrate;\n\ttmp *= 1024;\t\t \n\n\t\n\tif (tmp >= 0) {\n\t\ttmp += 500000;\n\t} else {\n\t\ttmp -= 500000;\n\t}\n\ttmp /= 1000000;\n\n\tstv0297_writereg(state, 0x60, tmp & 0xFF);\n\tstv0297_writereg_mask(state, 0x69, 0xF0, (tmp >> 4) & 0xf0);\n}\n\nstatic void stv0297_set_carrieroffset(struct stv0297_state *state, long offset)\n{\n\tlong tmp;\n\n\t \n\ttmp = offset * 26844L;\t \n\tif (tmp < 0)\n\t\ttmp += 0x10000000;\n\ttmp &= 0x0FFFFFFF;\n\n\tstv0297_writereg(state, 0x66, (unsigned char) (tmp & 0xFF));\n\tstv0297_writereg(state, 0x67, (unsigned char) (tmp >> 8));\n\tstv0297_writereg(state, 0x68, (unsigned char) (tmp >> 16));\n\tstv0297_writereg_mask(state, 0x69, 0x0F, (tmp >> 24) & 0x0f);\n}\n\n \n\nstatic void stv0297_set_initialdemodfreq(struct stv0297_state *state, long freq)\n{\n\ts32 tmp;\n\n\tif (freq > 10000)\n\t\tfreq -= STV0297_CLOCK_KHZ;\n\n\ttmp = (STV0297_CLOCK_KHZ * 1000) / (1 << 16);\n\ttmp = (freq * 1000) / tmp;\n\tif (tmp > 0xffff)\n\t\ttmp = 0xffff;\n\n\tstv0297_writereg_mask(state, 0x25, 0x80, 0x80);\n\tstv0297_writereg(state, 0x21, tmp >> 8);\n\tstv0297_writereg(state, 0x20, tmp);\n}\n\nstatic int stv0297_set_qam(struct stv0297_state *state,\n\t\t\t   enum fe_modulation modulation)\n{\n\tint val = 0;\n\n\tswitch (modulation) {\n\tcase QAM_16:\n\t\tval = 0;\n\t\tbreak;\n\n\tcase QAM_32:\n\t\tval = 1;\n\t\tbreak;\n\n\tcase QAM_64:\n\t\tval = 4;\n\t\tbreak;\n\n\tcase QAM_128:\n\t\tval = 2;\n\t\tbreak;\n\n\tcase QAM_256:\n\t\tval = 3;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstv0297_writereg_mask(state, 0x00, 0x70, val << 4);\n\n\treturn 0;\n}\n\nstatic int stv0297_set_inversion(struct stv0297_state *state,\n\t\t\t\t enum fe_spectral_inversion inversion)\n{\n\tint val = 0;\n\n\tswitch (inversion) {\n\tcase INVERSION_OFF:\n\t\tval = 0;\n\t\tbreak;\n\n\tcase INVERSION_ON:\n\t\tval = 1;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstv0297_writereg_mask(state, 0x83, 0x08, val << 3);\n\n\treturn 0;\n}\n\nstatic int stv0297_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct stv0297_state *state = fe->demodulator_priv;\n\n\tif (enable) {\n\t\tstv0297_writereg(state, 0x87, 0x78);\n\t\tstv0297_writereg(state, 0x86, 0xc8);\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0297_init(struct dvb_frontend *fe)\n{\n\tstruct stv0297_state *state = fe->demodulator_priv;\n\tint i;\n\n\t \n\tfor (i=0; !(state->config->inittab[i] == 0xff && state->config->inittab[i+1] == 0xff); i+=2)\n\t\tstv0297_writereg(state, state->config->inittab[i], state->config->inittab[i+1]);\n\tmsleep(200);\n\n\tstate->last_ber = 0;\n\n\treturn 0;\n}\n\nstatic int stv0297_sleep(struct dvb_frontend *fe)\n{\n\tstruct stv0297_state *state = fe->demodulator_priv;\n\n\tstv0297_writereg_mask(state, 0x80, 1, 1);\n\n\treturn 0;\n}\n\nstatic int stv0297_read_status(struct dvb_frontend *fe,\n\t\t\t       enum fe_status *status)\n{\n\tstruct stv0297_state *state = fe->demodulator_priv;\n\n\tu8 sync = stv0297_readreg(state, 0xDF);\n\n\t*status = 0;\n\tif (sync & 0x80)\n\t\t*status |=\n\t\t\tFE_HAS_SYNC | FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_LOCK;\n\treturn 0;\n}\n\nstatic int stv0297_read_ber(struct dvb_frontend *fe, u32 * ber)\n{\n\tstruct stv0297_state *state = fe->demodulator_priv;\n\tu8 BER[3];\n\n\tstv0297_readregs(state, 0xA0, BER, 3);\n\tif (!(BER[0] & 0x80)) {\n\t\tstate->last_ber = BER[2] << 8 | BER[1];\n\t\tstv0297_writereg_mask(state, 0xA0, 0x80, 0x80);\n\t}\n\n\t*ber = state->last_ber;\n\n\treturn 0;\n}\n\n\nstatic int stv0297_read_signal_strength(struct dvb_frontend *fe, u16 * strength)\n{\n\tstruct stv0297_state *state = fe->demodulator_priv;\n\tu8 STRENGTH[3];\n\tu16 tmp;\n\n\tstv0297_readregs(state, 0x41, STRENGTH, 3);\n\ttmp = (STRENGTH[1] & 0x03) << 8 | STRENGTH[0];\n\tif (STRENGTH[2] & 0x20) {\n\t\tif (tmp < 0x200)\n\t\t\ttmp = 0;\n\t\telse\n\t\t\ttmp = tmp - 0x200;\n\t} else {\n\t\tif (tmp > 0x1ff)\n\t\t\ttmp = 0;\n\t\telse\n\t\t\ttmp = 0x1ff - tmp;\n\t}\n\t*strength = (tmp << 7) | (tmp >> 2);\n\treturn 0;\n}\n\nstatic int stv0297_read_snr(struct dvb_frontend *fe, u16 * snr)\n{\n\tstruct stv0297_state *state = fe->demodulator_priv;\n\tu8 SNR[2];\n\n\tstv0297_readregs(state, 0x07, SNR, 2);\n\t*snr = SNR[1] << 8 | SNR[0];\n\n\treturn 0;\n}\n\nstatic int stv0297_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)\n{\n\tstruct stv0297_state *state = fe->demodulator_priv;\n\n\tstv0297_writereg_mask(state, 0xDF, 0x03, 0x03);  \n\n\t*ucblocks = (stv0297_readreg(state, 0xD5) << 8)\n\t\t| stv0297_readreg(state, 0xD4);\n\n\tstv0297_writereg_mask(state, 0xDF, 0x03, 0x02);  \n\tstv0297_writereg_mask(state, 0xDF, 0x03, 0x01);  \n\n\treturn 0;\n}\n\nstatic int stv0297_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct stv0297_state *state = fe->demodulator_priv;\n\tint u_threshold;\n\tint initial_u;\n\tint blind_u;\n\tint delay;\n\tint sweeprate;\n\tint carrieroffset;\n\tunsigned long timeout;\n\tenum fe_spectral_inversion inversion;\n\n\tswitch (p->modulation) {\n\tcase QAM_16:\n\tcase QAM_32:\n\tcase QAM_64:\n\t\tdelay = 100;\n\t\tsweeprate = 1000;\n\t\tbreak;\n\n\tcase QAM_128:\n\tcase QAM_256:\n\t\tdelay = 200;\n\t\tsweeprate = 500;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tinversion = p->inversion;\n\tif (state->config->invert)\n\t\tinversion = (inversion == INVERSION_ON) ? INVERSION_OFF : INVERSION_ON;\n\tcarrieroffset = -330;\n\tswitch (inversion) {\n\tcase INVERSION_OFF:\n\t\tbreak;\n\n\tcase INVERSION_ON:\n\t\tsweeprate = -sweeprate;\n\t\tcarrieroffset = -carrieroffset;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstv0297_init(fe);\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t \n\tstv0297_writereg(state, 0x82, 0x0);\n\n\t \n\tstv0297_set_initialdemodfreq(state, 7250);\n\n\t \n\tstv0297_writereg_mask(state, 0x43, 0x10, 0x00);\n\tstv0297_writereg(state, 0x41, 0x00);\n\tstv0297_writereg_mask(state, 0x42, 0x03, 0x01);\n\tstv0297_writereg_mask(state, 0x36, 0x60, 0x00);\n\tstv0297_writereg_mask(state, 0x36, 0x18, 0x00);\n\tstv0297_writereg_mask(state, 0x71, 0x80, 0x80);\n\tstv0297_writereg(state, 0x72, 0x00);\n\tstv0297_writereg(state, 0x73, 0x00);\n\tstv0297_writereg_mask(state, 0x74, 0x0F, 0x00);\n\tstv0297_writereg_mask(state, 0x43, 0x08, 0x00);\n\tstv0297_writereg_mask(state, 0x71, 0x80, 0x00);\n\n\t \n\tstv0297_writereg_mask(state, 0x5a, 0x20, 0x20);\n\tstv0297_writereg_mask(state, 0x5b, 0x02, 0x02);\n\tstv0297_writereg_mask(state, 0x5b, 0x02, 0x00);\n\tstv0297_writereg_mask(state, 0x5b, 0x01, 0x00);\n\tstv0297_writereg_mask(state, 0x5a, 0x40, 0x40);\n\n\t \n\tstv0297_writereg_mask(state, 0x6a, 0x01, 0x00);\n\n\t \n\tstv0297_writereg_mask(state, 0x81, 0x01, 0x01);\n\tstv0297_writereg_mask(state, 0x81, 0x01, 0x00);\n\n\t \n\tstv0297_writereg_mask(state, 0x83, 0x20, 0x20);\n\tstv0297_writereg_mask(state, 0x83, 0x20, 0x00);\n\n\t \n\tu_threshold = stv0297_readreg(state, 0x00) & 0xf;\n\tinitial_u = stv0297_readreg(state, 0x01) >> 4;\n\tblind_u = stv0297_readreg(state, 0x01) & 0xf;\n\tstv0297_writereg_mask(state, 0x84, 0x01, 0x01);\n\tstv0297_writereg_mask(state, 0x84, 0x01, 0x00);\n\tstv0297_writereg_mask(state, 0x00, 0x0f, u_threshold);\n\tstv0297_writereg_mask(state, 0x01, 0xf0, initial_u << 4);\n\tstv0297_writereg_mask(state, 0x01, 0x0f, blind_u);\n\n\t \n\tstv0297_writereg_mask(state, 0x87, 0x80, 0x00);\n\n\t \n\tstv0297_writereg(state, 0x63, 0x00);\n\tstv0297_writereg(state, 0x64, 0x00);\n\tstv0297_writereg(state, 0x65, 0x00);\n\tstv0297_writereg(state, 0x66, 0x00);\n\tstv0297_writereg(state, 0x67, 0x00);\n\tstv0297_writereg(state, 0x68, 0x00);\n\tstv0297_writereg_mask(state, 0x69, 0x0f, 0x00);\n\n\t \n\tstv0297_set_qam(state, p->modulation);\n\tstv0297_set_symbolrate(state, p->symbol_rate / 1000);\n\tstv0297_set_sweeprate(state, sweeprate, p->symbol_rate / 1000);\n\tstv0297_set_carrieroffset(state, carrieroffset);\n\tstv0297_set_inversion(state, inversion);\n\n\t \n\t \n\tif (p->modulation == QAM_128 ||\n\t\tp->modulation == QAM_256)\n\t\tstv0297_writereg_mask(state, 0x88, 0x08, 0x00);\n\telse\n\t\tstv0297_writereg_mask(state, 0x88, 0x08, 0x08);\n\n\tstv0297_writereg_mask(state, 0x5a, 0x20, 0x00);\n\tstv0297_writereg_mask(state, 0x6a, 0x01, 0x01);\n\tstv0297_writereg_mask(state, 0x43, 0x40, 0x40);\n\tstv0297_writereg_mask(state, 0x5b, 0x30, 0x00);\n\tstv0297_writereg_mask(state, 0x03, 0x0c, 0x0c);\n\tstv0297_writereg_mask(state, 0x03, 0x03, 0x03);\n\tstv0297_writereg_mask(state, 0x43, 0x10, 0x10);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(2000);\n\twhile (time_before(jiffies, timeout)) {\n\t\tmsleep(10);\n\t\tif (stv0297_readreg(state, 0x43) & 0x08)\n\t\t\tbreak;\n\t}\n\tif (time_after(jiffies, timeout)) {\n\t\tgoto timeout;\n\t}\n\tmsleep(20);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile (time_before(jiffies, timeout)) {\n\t\tmsleep(10);\n\n\t\tif (stv0297_readreg(state, 0x82) & 0x04) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (time_after(jiffies, timeout)) {\n\t\tgoto timeout;\n\t}\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(delay);\n\twhile (time_before(jiffies, timeout)) {\n\t\tmsleep(10);\n\n\t\tif (stv0297_readreg(state, 0x82) & 0x08) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (time_after(jiffies, timeout)) {\n\t\tgoto timeout;\n\t}\n\n\t \n\tstv0297_writereg_mask(state, 0x6a, 1, 0);\n\tstv0297_writereg_mask(state, 0x88, 8, 0);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(20);\n\twhile (time_before(jiffies, timeout)) {\n\t\tmsleep(10);\n\n\t\tif (stv0297_readreg(state, 0xDF) & 0x80) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (time_after(jiffies, timeout)) {\n\t\tgoto timeout;\n\t}\n\tmsleep(100);\n\n\t \n\tif (!(stv0297_readreg(state, 0xDF) & 0x80)) {\n\t\tgoto timeout;\n\t}\n\n\t \n\tstv0297_writereg_mask(state, 0x5a, 0x40, 0x00);\n\tstate->base_freq = p->frequency;\n\treturn 0;\n\ntimeout:\n\tstv0297_writereg_mask(state, 0x6a, 0x01, 0x00);\n\treturn 0;\n}\n\nstatic int stv0297_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct stv0297_state *state = fe->demodulator_priv;\n\tint reg_00, reg_83;\n\n\treg_00 = stv0297_readreg(state, 0x00);\n\treg_83 = stv0297_readreg(state, 0x83);\n\n\tp->frequency = state->base_freq;\n\tp->inversion = (reg_83 & 0x08) ? INVERSION_ON : INVERSION_OFF;\n\tif (state->config->invert)\n\t\tp->inversion = (p->inversion == INVERSION_ON) ? INVERSION_OFF : INVERSION_ON;\n\tp->symbol_rate = stv0297_get_symbolrate(state) * 1000;\n\tp->fec_inner = FEC_NONE;\n\n\tswitch ((reg_00 >> 4) & 0x7) {\n\tcase 0:\n\t\tp->modulation = QAM_16;\n\t\tbreak;\n\tcase 1:\n\t\tp->modulation = QAM_32;\n\t\tbreak;\n\tcase 2:\n\t\tp->modulation = QAM_128;\n\t\tbreak;\n\tcase 3:\n\t\tp->modulation = QAM_256;\n\t\tbreak;\n\tcase 4:\n\t\tp->modulation = QAM_64;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void stv0297_release(struct dvb_frontend *fe)\n{\n\tstruct stv0297_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops stv0297_ops;\n\nstruct dvb_frontend *stv0297_attach(const struct stv0297_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct stv0297_state *state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct stv0297_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->last_ber = 0;\n\tstate->base_freq = 0;\n\n\t \n\tif ((stv0297_readreg(state, 0x80) & 0x70) != 0x20)\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &stv0297_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops stv0297_ops = {\n\t.delsys = { SYS_DVBC_ANNEX_A },\n\t.info = {\n\t\t .name = \"ST STV0297 DVB-C\",\n\t\t .frequency_min_hz = 47 * MHz,\n\t\t .frequency_max_hz = 862 * MHz,\n\t\t .frequency_stepsize_hz = 62500,\n\t\t .symbol_rate_min = 870000,\n\t\t .symbol_rate_max = 11700000,\n\t\t .caps = FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |\n\t\t FE_CAN_QAM_128 | FE_CAN_QAM_256 | FE_CAN_FEC_AUTO},\n\n\t.release = stv0297_release,\n\n\t.init = stv0297_init,\n\t.sleep = stv0297_sleep,\n\t.i2c_gate_ctrl = stv0297_i2c_gate_ctrl,\n\n\t.set_frontend = stv0297_set_frontend,\n\t.get_frontend = stv0297_get_frontend,\n\n\t.read_status = stv0297_read_status,\n\t.read_ber = stv0297_read_ber,\n\t.read_signal_strength = stv0297_read_signal_strength,\n\t.read_snr = stv0297_read_snr,\n\t.read_ucblocks = stv0297_read_ucblocks,\n};\n\nMODULE_DESCRIPTION(\"ST STV0297 DVB-C Demodulator driver\");\nMODULE_AUTHOR(\"Dennis Noermann and Andrew de Quincey\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(stv0297_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}