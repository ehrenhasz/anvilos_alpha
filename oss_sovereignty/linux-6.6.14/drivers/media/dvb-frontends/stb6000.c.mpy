{
  "module_name": "stb6000.c",
  "hash_id": "e31d419144d8daf88ee9ef357ecb06ad38a0613868c9300fcefe80539153e111",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stb6000.c",
  "human_readable_source": "\n   \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/dvb/frontend.h>\n#include <asm/types.h>\n\n#include \"stb6000.h\"\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_DEBUG \"stb6000: \" args); \\\n\t} while (0)\n\nstruct stb6000_priv {\n\t \n\tint i2c_address;\n\tstruct i2c_adapter *i2c;\n\tu32 frequency;\n};\n\nstatic void stb6000_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int stb6000_sleep(struct dvb_frontend *fe)\n{\n\tstruct stb6000_priv *priv = fe->tuner_priv;\n\tint ret;\n\tu8 buf[] = { 10, 0 };\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->i2c_address,\n\t\t.flags = 0,\n\t\t.buf = buf,\n\t\t.len = 2\n\t};\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tret = i2c_transfer(priv->i2c, &msg, 1);\n\tif (ret != 1)\n\t\tdprintk(\"%s: i2c error\\n\", __func__);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn (ret == 1) ? 0 : ret;\n}\n\nstatic int stb6000_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct stb6000_priv *priv = fe->tuner_priv;\n\tunsigned int n, m;\n\tint ret;\n\tu32 freq_mhz;\n\tint bandwidth;\n\tu8 buf[12];\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->i2c_address,\n\t\t.flags = 0,\n\t\t.buf = buf,\n\t\t.len = 12\n\t};\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tfreq_mhz = p->frequency / 1000;\n\tbandwidth = p->symbol_rate / 1000000;\n\n\tif (bandwidth > 31)\n\t\tbandwidth = 31;\n\n\tif ((freq_mhz > 949) && (freq_mhz < 2151)) {\n\t\tbuf[0] = 0x01;\n\t\tbuf[1] = 0xac;\n\t\tif (freq_mhz < 1950)\n\t\t\tbuf[1] = 0xaa;\n\t\tif (freq_mhz < 1800)\n\t\t\tbuf[1] = 0xa8;\n\t\tif (freq_mhz < 1650)\n\t\t\tbuf[1] = 0xa6;\n\t\tif (freq_mhz < 1530)\n\t\t\tbuf[1] = 0xa5;\n\t\tif (freq_mhz < 1470)\n\t\t\tbuf[1] = 0xa4;\n\t\tif (freq_mhz < 1370)\n\t\t\tbuf[1] = 0xa2;\n\t\tif (freq_mhz < 1300)\n\t\t\tbuf[1] = 0xa1;\n\t\tif (freq_mhz < 1200)\n\t\t\tbuf[1] = 0xa0;\n\t\tif (freq_mhz < 1075)\n\t\t\tbuf[1] = 0xbc;\n\t\tif (freq_mhz < 1000)\n\t\t\tbuf[1] = 0xba;\n\t\tif (freq_mhz < 1075) {\n\t\t\tn = freq_mhz / 8;  \n\t\t\tm = 2;\n\t\t} else {\n\t\t\tn = freq_mhz / 16;  \n\t\t\tm = 1;\n\t\t}\n\t\tbuf[2] = n >> 1;\n\t\tbuf[3] = (unsigned char)(((n & 1) << 7) |\n\t\t\t\t\t(m * freq_mhz - n * 16) | 0x60);\n\t\tbuf[4] = 0x04;\n\t\tbuf[5] = 0x0e;\n\n\t\tbuf[6] = (unsigned char)(bandwidth);\n\n\t\tbuf[7] = 0xd8;\n\t\tbuf[8] = 0xd0;\n\t\tbuf[9] = 0x50;\n\t\tbuf[10] = 0xeb;\n\t\tbuf[11] = 0x4f;\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\tret = i2c_transfer(priv->i2c, &msg, 1);\n\t\tif (ret != 1)\n\t\t\tdprintk(\"%s: i2c error\\n\", __func__);\n\n\t\tudelay(10);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\t\tbuf[0] = 0x07;\n\t\tbuf[1] = 0xdf;\n\t\tbuf[2] = 0xd0;\n\t\tbuf[3] = 0x50;\n\t\tbuf[4] = 0xfb;\n\t\tmsg.len = 5;\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\tret = i2c_transfer(priv->i2c, &msg, 1);\n\t\tif (ret != 1)\n\t\t\tdprintk(\"%s: i2c error\\n\", __func__);\n\n\t\tudelay(10);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\t\tpriv->frequency = freq_mhz * 1000;\n\n\t\treturn (ret == 1) ? 0 : ret;\n\t}\n\treturn -1;\n}\n\nstatic int stb6000_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct stb6000_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops stb6000_tuner_ops = {\n\t.info = {\n\t\t.name = \"ST STB6000\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz\n\t},\n\t.release = stb6000_release,\n\t.sleep = stb6000_sleep,\n\t.set_params = stb6000_set_params,\n\t.get_frequency = stb6000_get_frequency,\n};\n\nstruct dvb_frontend *stb6000_attach(struct dvb_frontend *fe, int addr,\n\t\t\t\t\t\tstruct i2c_adapter *i2c)\n{\n\tstruct stb6000_priv *priv = NULL;\n\tu8 b0[] = { 0 };\n\tu8 b1[] = { 0, 0 };\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = b0,\n\t\t\t.len = 0\n\t\t}, {\n\t\t\t.addr = addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = b1,\n\t\t\t.len = 2\n\t\t}\n\t};\n\tint ret;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t \n\tret = i2c_transfer(i2c, msg, 2);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tif (ret != 2)\n\t\treturn NULL;\n\n\tpriv = kzalloc(sizeof(struct stb6000_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\n\tpriv->i2c_address = addr;\n\tpriv->i2c = i2c;\n\n\tmemcpy(&fe->ops.tuner_ops, &stb6000_tuner_ops,\n\t\t\t\tsizeof(struct dvb_tuner_ops));\n\n\tfe->tuner_priv = priv;\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(stb6000_attach);\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"DVB STB6000 driver\");\nMODULE_AUTHOR(\"Igor M. Liplianin <liplianin@me.by>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}