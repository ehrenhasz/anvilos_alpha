{
  "module_name": "zl10353.c",
  "hash_id": "8f1e949367331d28dd8c51ab3a07362338aa29f8bbbe0cfc3e36491533837f78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/zl10353.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"zl10353_priv.h\"\n#include \"zl10353.h\"\n\nstruct zl10353_state {\n\tstruct i2c_adapter *i2c;\n\tstruct dvb_frontend frontend;\n\n\tstruct zl10353_config config;\n\n\tu32 bandwidth;\n\tu32 ucblocks;\n\tu32 frequency;\n};\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) printk(KERN_DEBUG \"zl10353: \" args); \\\n\t} while (0)\n\nstatic int debug_regs;\n\nstatic int zl10353_single_write(struct dvb_frontend *fe, u8 reg, u8 val)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\tu8 buf[2] = { reg, val };\n\tstruct i2c_msg msg = { .addr = state->config.demod_address, .flags = 0,\n\t\t\t       .buf = buf, .len = 2 };\n\tint err = i2c_transfer(state->i2c, &msg, 1);\n\tif (err != 1) {\n\t\tprintk(\"zl10353: write to reg %x failed (err = %d)!\\n\", reg, err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int zl10353_write(struct dvb_frontend *fe, const u8 ibuf[], int ilen)\n{\n\tint err, i;\n\tfor (i = 0; i < ilen - 1; i++)\n\t\tif ((err = zl10353_single_write(fe, ibuf[0] + i, ibuf[i + 1])))\n\t\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int zl10353_read_register(struct zl10353_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b0[1] = { reg };\n\tu8 b1[1] = { 0 };\n\tstruct i2c_msg msg[2] = { { .addr = state->config.demod_address,\n\t\t\t\t    .flags = 0,\n\t\t\t\t    .buf = b0, .len = 1 },\n\t\t\t\t  { .addr = state->config.demod_address,\n\t\t\t\t    .flags = I2C_M_RD,\n\t\t\t\t    .buf = b1, .len = 1 } };\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\tprintk(\"%s: readreg error (reg=%d, ret==%i)\\n\",\n\t\t       __func__, reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn b1[0];\n}\n\nstatic void zl10353_dump_regs(struct dvb_frontend *fe)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\tint ret;\n\tu8 reg;\n\n\t \n\tfor (reg = 0; ; reg++) {\n\t\tif (reg % 16 == 0) {\n\t\t\tif (reg)\n\t\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_DEBUG \"%02x:\", reg);\n\t\t}\n\t\tret = zl10353_read_register(state, reg);\n\t\tif (ret >= 0)\n\t\t\tprintk(KERN_CONT \" %02x\", (u8)ret);\n\t\telse\n\t\t\tprintk(KERN_CONT \" --\");\n\t\tif (reg == 0xff)\n\t\t\tbreak;\n\t}\n\tprintk(KERN_CONT \"\\n\");\n}\n\nstatic void zl10353_calc_nominal_rate(struct dvb_frontend *fe,\n\t\t\t\t      u32 bandwidth,\n\t\t\t\t      u16 *nominal_rate)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\tu32 adc_clock = 450560;  \n\tu64 value;\n\tu8 bw = bandwidth / 1000000;\n\n\tif (state->config.adc_clock)\n\t\tadc_clock = state->config.adc_clock;\n\n\tvalue = (u64)10 * (1 << 23) / 7 * 125;\n\tvalue = (bw * value) + adc_clock / 2;\n\t*nominal_rate = div_u64(value, adc_clock);\n\n\tdprintk(\"%s: bw %d, adc_clock %d => 0x%x\\n\",\n\t\t__func__, bw, adc_clock, *nominal_rate);\n}\n\nstatic void zl10353_calc_input_freq(struct dvb_frontend *fe,\n\t\t\t\t    u16 *input_freq)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\tu32 adc_clock = 450560;\t \n\tint if2 = 361667;\t \n\tint ife;\n\tu64 value;\n\n\tif (state->config.adc_clock)\n\t\tadc_clock = state->config.adc_clock;\n\tif (state->config.if2)\n\t\tif2 = state->config.if2;\n\n\tif (adc_clock >= if2 * 2)\n\t\tife = if2;\n\telse {\n\t\tife = adc_clock - (if2 % adc_clock);\n\t\tif (ife > adc_clock / 2)\n\t\t\tife = adc_clock - ife;\n\t}\n\tvalue = div_u64((u64)65536 * ife + adc_clock / 2, adc_clock);\n\t*input_freq = -value;\n\n\tdprintk(\"%s: if2 %d, ife %d, adc_clock %d => %d / 0x%x\\n\",\n\t\t__func__, if2, ife, adc_clock, -(int)value, *input_freq);\n}\n\nstatic int zl10353_sleep(struct dvb_frontend *fe)\n{\n\tstatic u8 zl10353_softdown[] = { 0x50, 0x0C, 0x44 };\n\n\tzl10353_write(fe, zl10353_softdown, sizeof(zl10353_softdown));\n\treturn 0;\n}\n\nstatic int zl10353_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\tu16 nominal_rate, input_freq;\n\tu8 pllbuf[6] = { 0x67 }, acq_ctl = 0;\n\tu16 tps = 0;\n\n\tstate->frequency = c->frequency;\n\n\tzl10353_single_write(fe, RESET, 0x80);\n\tudelay(200);\n\tzl10353_single_write(fe, 0xEA, 0x01);\n\tudelay(200);\n\tzl10353_single_write(fe, 0xEA, 0x00);\n\n\tzl10353_single_write(fe, AGC_TARGET, 0x28);\n\n\tif (c->transmission_mode != TRANSMISSION_MODE_AUTO)\n\t\tacq_ctl |= (1 << 0);\n\tif (c->guard_interval != GUARD_INTERVAL_AUTO)\n\t\tacq_ctl |= (1 << 1);\n\tzl10353_single_write(fe, ACQ_CTL, acq_ctl);\n\n\tswitch (c->bandwidth_hz) {\n\tcase 6000000:\n\t\t \n\t\tzl10353_single_write(fe, MCLK_RATIO, 0x97);\n\t\tzl10353_single_write(fe, 0x64, 0x34);\n\t\tzl10353_single_write(fe, 0xcc, 0xdd);\n\t\tbreak;\n\tcase 7000000:\n\t\tzl10353_single_write(fe, MCLK_RATIO, 0x86);\n\t\tzl10353_single_write(fe, 0x64, 0x35);\n\t\tzl10353_single_write(fe, 0xcc, 0x73);\n\t\tbreak;\n\tdefault:\n\t\tc->bandwidth_hz = 8000000;\n\t\tfallthrough;\n\tcase 8000000:\n\t\tzl10353_single_write(fe, MCLK_RATIO, 0x75);\n\t\tzl10353_single_write(fe, 0x64, 0x36);\n\t\tzl10353_single_write(fe, 0xcc, 0x73);\n\t}\n\n\tzl10353_calc_nominal_rate(fe, c->bandwidth_hz, &nominal_rate);\n\tzl10353_single_write(fe, TRL_NOMINAL_RATE_1, msb(nominal_rate));\n\tzl10353_single_write(fe, TRL_NOMINAL_RATE_0, lsb(nominal_rate));\n\tstate->bandwidth = c->bandwidth_hz;\n\n\tzl10353_calc_input_freq(fe, &input_freq);\n\tzl10353_single_write(fe, INPUT_FREQ_1, msb(input_freq));\n\tzl10353_single_write(fe, INPUT_FREQ_0, lsb(input_freq));\n\n\t \n\tswitch (c->code_rate_HP) {\n\tcase FEC_2_3:\n\t\ttps |= (1 << 7);\n\t\tbreak;\n\tcase FEC_3_4:\n\t\ttps |= (2 << 7);\n\t\tbreak;\n\tcase FEC_5_6:\n\t\ttps |= (3 << 7);\n\t\tbreak;\n\tcase FEC_7_8:\n\t\ttps |= (4 << 7);\n\t\tbreak;\n\tcase FEC_1_2:\n\tcase FEC_AUTO:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (c->code_rate_LP) {\n\tcase FEC_2_3:\n\t\ttps |= (1 << 4);\n\t\tbreak;\n\tcase FEC_3_4:\n\t\ttps |= (2 << 4);\n\t\tbreak;\n\tcase FEC_5_6:\n\t\ttps |= (3 << 4);\n\t\tbreak;\n\tcase FEC_7_8:\n\t\ttps |= (4 << 4);\n\t\tbreak;\n\tcase FEC_1_2:\n\tcase FEC_AUTO:\n\t\tbreak;\n\tcase FEC_NONE:\n\t\tif (c->hierarchy == HIERARCHY_AUTO ||\n\t\t    c->hierarchy == HIERARCHY_NONE)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (c->modulation) {\n\tcase QPSK:\n\t\tbreak;\n\tcase QAM_AUTO:\n\tcase QAM_16:\n\t\ttps |= (1 << 13);\n\t\tbreak;\n\tcase QAM_64:\n\t\ttps |= (2 << 13);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (c->transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\tcase TRANSMISSION_MODE_AUTO:\n\t\tbreak;\n\tcase TRANSMISSION_MODE_8K:\n\t\ttps |= (1 << 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (c->guard_interval) {\n\tcase GUARD_INTERVAL_1_32:\n\tcase GUARD_INTERVAL_AUTO:\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_16:\n\t\ttps |= (1 << 2);\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_8:\n\t\ttps |= (2 << 2);\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_4:\n\t\ttps |= (3 << 2);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (c->hierarchy) {\n\tcase HIERARCHY_AUTO:\n\tcase HIERARCHY_NONE:\n\t\tbreak;\n\tcase HIERARCHY_1:\n\t\ttps |= (1 << 10);\n\t\tbreak;\n\tcase HIERARCHY_2:\n\t\ttps |= (2 << 10);\n\t\tbreak;\n\tcase HIERARCHY_4:\n\t\ttps |= (3 << 10);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tzl10353_single_write(fe, TPS_GIVEN_1, msb(tps));\n\tzl10353_single_write(fe, TPS_GIVEN_0, lsb(tps));\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\t \n\tif (state->config.no_tuner) {\n\t\tif (fe->ops.tuner_ops.set_params) {\n\t\t\tfe->ops.tuner_ops.set_params(fe);\n\t\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t\t}\n\t} else if (fe->ops.tuner_ops.calc_regs) {\n\t\tfe->ops.tuner_ops.calc_regs(fe, pllbuf + 1, 5);\n\t\tpllbuf[1] <<= 1;\n\t\tzl10353_write(fe, pllbuf, sizeof(pllbuf));\n\t}\n\n\tzl10353_single_write(fe, 0x5F, 0x13);\n\n\t \n\tif (state->config.no_tuner || fe->ops.tuner_ops.calc_regs == NULL)\n\t\tzl10353_single_write(fe, FSM_GO, 0x01);\n\telse\n\t\tzl10353_single_write(fe, TUNER_GO, 0x01);\n\n\treturn 0;\n}\n\nstatic int zl10353_get_parameters(struct dvb_frontend *fe,\n\t\t\t\t  struct dtv_frontend_properties *c)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\tint s6, s9;\n\tu16 tps;\n\tstatic const u8 tps_fec_to_api[8] = {\n\t\tFEC_1_2,\n\t\tFEC_2_3,\n\t\tFEC_3_4,\n\t\tFEC_5_6,\n\t\tFEC_7_8,\n\t\tFEC_AUTO,\n\t\tFEC_AUTO,\n\t\tFEC_AUTO\n\t};\n\n\ts6 = zl10353_read_register(state, STATUS_6);\n\ts9 = zl10353_read_register(state, STATUS_9);\n\tif (s6 < 0 || s9 < 0)\n\t\treturn -EREMOTEIO;\n\tif ((s6 & (1 << 5)) == 0 || (s9 & (1 << 4)) == 0)\n\t\treturn -EINVAL;\t \n\n\ttps = zl10353_read_register(state, TPS_RECEIVED_1) << 8 |\n\t      zl10353_read_register(state, TPS_RECEIVED_0);\n\n\tc->code_rate_HP = tps_fec_to_api[(tps >> 7) & 7];\n\tc->code_rate_LP = tps_fec_to_api[(tps >> 4) & 7];\n\n\tswitch ((tps >> 13) & 3) {\n\tcase 0:\n\t\tc->modulation = QPSK;\n\t\tbreak;\n\tcase 1:\n\t\tc->modulation = QAM_16;\n\t\tbreak;\n\tcase 2:\n\t\tc->modulation = QAM_64;\n\t\tbreak;\n\tdefault:\n\t\tc->modulation = QAM_AUTO;\n\t\tbreak;\n\t}\n\n\tc->transmission_mode = (tps & 0x01) ? TRANSMISSION_MODE_8K :\n\t\t\t\t\t       TRANSMISSION_MODE_2K;\n\n\tswitch ((tps >> 2) & 3) {\n\tcase 0:\n\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\tc->guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tc->guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\tdefault:\n\t\tc->guard_interval = GUARD_INTERVAL_AUTO;\n\t\tbreak;\n\t}\n\n\tswitch ((tps >> 10) & 7) {\n\tcase 0:\n\t\tc->hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tc->hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tcase 2:\n\t\tc->hierarchy = HIERARCHY_2;\n\t\tbreak;\n\tcase 3:\n\t\tc->hierarchy = HIERARCHY_4;\n\t\tbreak;\n\tdefault:\n\t\tc->hierarchy = HIERARCHY_AUTO;\n\t\tbreak;\n\t}\n\n\tc->frequency = state->frequency;\n\tc->bandwidth_hz = state->bandwidth;\n\tc->inversion = INVERSION_AUTO;\n\n\treturn 0;\n}\n\nstatic int zl10353_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\tint s6, s7, s8;\n\n\tif ((s6 = zl10353_read_register(state, STATUS_6)) < 0)\n\t\treturn -EREMOTEIO;\n\tif ((s7 = zl10353_read_register(state, STATUS_7)) < 0)\n\t\treturn -EREMOTEIO;\n\tif ((s8 = zl10353_read_register(state, STATUS_8)) < 0)\n\t\treturn -EREMOTEIO;\n\n\t*status = 0;\n\tif (s6 & (1 << 2))\n\t\t*status |= FE_HAS_CARRIER;\n\tif (s6 & (1 << 1))\n\t\t*status |= FE_HAS_VITERBI;\n\tif (s6 & (1 << 5))\n\t\t*status |= FE_HAS_LOCK;\n\tif (s7 & (1 << 4))\n\t\t*status |= FE_HAS_SYNC;\n\tif (s8 & (1 << 6))\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif ((*status & (FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC)) !=\n\t    (FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC))\n\t\t*status &= ~FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int zl10353_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\n\t*ber = zl10353_read_register(state, RS_ERR_CNT_2) << 16 |\n\t       zl10353_read_register(state, RS_ERR_CNT_1) << 8 |\n\t       zl10353_read_register(state, RS_ERR_CNT_0);\n\n\treturn 0;\n}\n\nstatic int zl10353_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\n\tu16 signal = zl10353_read_register(state, AGC_GAIN_1) << 10 |\n\t\t     zl10353_read_register(state, AGC_GAIN_0) << 2 | 3;\n\n\t*strength = ~signal;\n\n\treturn 0;\n}\n\nstatic int zl10353_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\tu8 _snr;\n\n\tif (debug_regs)\n\t\tzl10353_dump_regs(fe);\n\n\t_snr = zl10353_read_register(state, SNR);\n\t*snr = 10 * _snr / 8;\n\n\treturn 0;\n}\n\nstatic int zl10353_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\tu32 ubl = 0;\n\n\tubl = zl10353_read_register(state, RS_UBC_1) << 8 |\n\t      zl10353_read_register(state, RS_UBC_0);\n\n\tstate->ucblocks += ubl;\n\t*ucblocks = state->ucblocks;\n\n\treturn 0;\n}\n\nstatic int zl10353_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t     struct dvb_frontend_tune_settings\n\t\t\t\t\t *fe_tune_settings)\n{\n\tfe_tune_settings->min_delay_ms = 1000;\n\tfe_tune_settings->step_size = 0;\n\tfe_tune_settings->max_drift = 0;\n\n\treturn 0;\n}\n\nstatic int zl10353_init(struct dvb_frontend *fe)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\tu8 zl10353_reset_attach[6] = { 0x50, 0x03, 0x64, 0x46, 0x15, 0x0F };\n\n\tif (debug_regs)\n\t\tzl10353_dump_regs(fe);\n\tif (state->config.parallel_ts)\n\t\tzl10353_reset_attach[2] &= ~0x20;\n\tif (state->config.clock_ctl_1)\n\t\tzl10353_reset_attach[3] = state->config.clock_ctl_1;\n\tif (state->config.pll_0)\n\t\tzl10353_reset_attach[4] = state->config.pll_0;\n\n\t \n\tif (zl10353_read_register(state, 0x50) != zl10353_reset_attach[1] ||\n\t    zl10353_read_register(state, 0x51) != zl10353_reset_attach[2]) {\n\t\tzl10353_write(fe, zl10353_reset_attach,\n\t\t\t\t   sizeof(zl10353_reset_attach));\n\t\tif (debug_regs)\n\t\t\tzl10353_dump_regs(fe);\n\t}\n\n\treturn 0;\n}\n\nstatic int zl10353_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\tu8 val = 0x0a;\n\n\tif (state->config.disable_i2c_gate_ctrl) {\n\t\t \n\t\t \n\t\treturn 0;\n\t}\n\n\tif (enable)\n\t\tval |= 0x10;\n\n\treturn zl10353_single_write(fe, 0x62, val);\n}\n\nstatic void zl10353_release(struct dvb_frontend *fe)\n{\n\tstruct zl10353_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops zl10353_ops;\n\nstruct dvb_frontend *zl10353_attach(const struct zl10353_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct zl10353_state *state = NULL;\n\tint id;\n\n\t \n\tstate = kzalloc(sizeof(struct zl10353_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->i2c = i2c;\n\tmemcpy(&state->config, config, sizeof(struct zl10353_config));\n\n\t \n\tid = zl10353_read_register(state, CHIP_ID);\n\tif ((id != ID_ZL10353) && (id != ID_CE6230) && (id != ID_CE6231))\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &zl10353_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\treturn &state->frontend;\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops zl10353_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name\t\t\t= \"Zarlink ZL10353 DVB-T\",\n\t\t.frequency_min_hz\t= 174 * MHz,\n\t\t.frequency_max_hz\t= 862 * MHz,\n\t\t.frequency_stepsize_hz\t= 166667,\n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO | FE_CAN_RECOVER |\n\t\t\tFE_CAN_MUTE_TS\n\t},\n\n\t.release = zl10353_release,\n\n\t.init = zl10353_init,\n\t.sleep = zl10353_sleep,\n\t.i2c_gate_ctrl = zl10353_i2c_gate_ctrl,\n\t.write = zl10353_write,\n\n\t.set_frontend = zl10353_set_parameters,\n\t.get_frontend = zl10353_get_parameters,\n\t.get_tune_settings = zl10353_get_tune_settings,\n\n\t.read_status = zl10353_read_status,\n\t.read_ber = zl10353_read_ber,\n\t.read_signal_strength = zl10353_read_signal_strength,\n\t.read_snr = zl10353_read_snr,\n\t.read_ucblocks = zl10353_read_ucblocks,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nmodule_param(debug_regs, int, 0644);\nMODULE_PARM_DESC(debug_regs, \"Turn on/off frontend register dumps (default:off).\");\n\nMODULE_DESCRIPTION(\"Zarlink ZL10353 DVB-T demodulator driver\");\nMODULE_AUTHOR(\"Chris Pascoe\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(zl10353_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}