{
  "module_name": "dib9000.c",
  "hash_id": "4114a280096d7c9f5c07e4cccc085a1caea55f3ac125e3ff1906bce2ff16a8ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/dib9000.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n\n#include <linux/int_log.h>\n#include <media/dvb_frontend.h>\n\n#include \"dib9000.h\"\n#include \"dibx000_common.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"turn on debugging (default: 0)\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\n#define MAX_NUMBER_OF_FRONTENDS 6\n\nstruct i2c_device {\n\tstruct i2c_adapter *i2c_adap;\n\tu8 i2c_addr;\n\tu8 *i2c_read_buffer;\n\tu8 *i2c_write_buffer;\n};\n\nstruct dib9000_pid_ctrl {\n#define DIB9000_PID_FILTER_CTRL 0\n#define DIB9000_PID_FILTER      1\n\tu8 cmd;\n\tu8 id;\n\tu16 pid;\n\tu8 onoff;\n};\n\nstruct dib9000_state {\n\tstruct i2c_device i2c;\n\n\tstruct dibx000_i2c_master i2c_master;\n\tstruct i2c_adapter tuner_adap;\n\tstruct i2c_adapter component_bus;\n\n\tu16 revision;\n\tu8 reg_offs;\n\n\tenum frontend_tune_state tune_state;\n\tu32 status;\n\tstruct dvb_frontend_parametersContext channel_status;\n\n\tu8 fe_id;\n\n#define DIB9000_GPIO_DEFAULT_DIRECTIONS 0xffff\n\tu16 gpio_dir;\n#define DIB9000_GPIO_DEFAULT_VALUES     0x0000\n\tu16 gpio_val;\n#define DIB9000_GPIO_DEFAULT_PWM_POS    0xffff\n\tu16 gpio_pwm_pos;\n\n\tunion {\t\t\t \n\t\tstruct {\n\t\t\tu8 mobile_mode:1;\n\t\t} host;\n\n\t\tstruct {\n\t\t\tstruct dib9000_fe_memory_map {\n\t\t\t\tu16 addr;\n\t\t\t\tu16 size;\n\t\t\t} fe_mm[18];\n\t\t\tu8 memcmd;\n\n\t\t\tstruct mutex mbx_if_lock;\t \n\t\t\tstruct mutex mbx_lock;\t \n\n\t\t\tstruct mutex mem_lock;\t \n\t\t\tstruct mutex mem_mbx_lock;\t \n\n#define MBX_MAX_WORDS (256 - 200 - 2)\n#define DIB9000_MSG_CACHE_SIZE 2\n\t\t\tu16 message_cache[DIB9000_MSG_CACHE_SIZE][MBX_MAX_WORDS];\n\t\t\tu8 fw_is_running;\n\t\t} risc;\n\t} platform;\n\n\tunion {\t\t\t \n\t\tstruct {\n\t\t\tstruct dib9000_config cfg;\n\t\t} d9;\n\t} chip;\n\n\tstruct dvb_frontend *fe[MAX_NUMBER_OF_FRONTENDS];\n\tu16 component_bus_speed;\n\n\t \n\tstruct i2c_msg msg[2];\n\tu8 i2c_write_buffer[255];\n\tu8 i2c_read_buffer[255];\n\tstruct mutex demod_lock;\n\tu8 get_frontend_internal;\n\tstruct dib9000_pid_ctrl pid_ctrl[10];\n\ts8 pid_ctrl_index;  \n};\n\nstatic const u32 fe_info[44] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0\n};\n\nenum dib9000_power_mode {\n\tDIB9000_POWER_ALL = 0,\n\n\tDIB9000_POWER_NO,\n\tDIB9000_POWER_INTERF_ANALOG_AGC,\n\tDIB9000_POWER_COR4_DINTLV_ICIRM_EQUAL_CFROD,\n\tDIB9000_POWER_COR4_CRY_ESRAM_MOUT_NUD,\n\tDIB9000_POWER_INTERFACE_ONLY,\n};\n\nenum dib9000_out_messages {\n\tOUT_MSG_HBM_ACK,\n\tOUT_MSG_HOST_BUF_FAIL,\n\tOUT_MSG_REQ_VERSION,\n\tOUT_MSG_BRIDGE_I2C_W,\n\tOUT_MSG_BRIDGE_I2C_R,\n\tOUT_MSG_BRIDGE_APB_W,\n\tOUT_MSG_BRIDGE_APB_R,\n\tOUT_MSG_SCAN_CHANNEL,\n\tOUT_MSG_MONIT_DEMOD,\n\tOUT_MSG_CONF_GPIO,\n\tOUT_MSG_DEBUG_HELP,\n\tOUT_MSG_SUBBAND_SEL,\n\tOUT_MSG_ENABLE_TIME_SLICE,\n\tOUT_MSG_FE_FW_DL,\n\tOUT_MSG_FE_CHANNEL_SEARCH,\n\tOUT_MSG_FE_CHANNEL_TUNE,\n\tOUT_MSG_FE_SLEEP,\n\tOUT_MSG_FE_SYNC,\n\tOUT_MSG_CTL_MONIT,\n\n\tOUT_MSG_CONF_SVC,\n\tOUT_MSG_SET_HBM,\n\tOUT_MSG_INIT_DEMOD,\n\tOUT_MSG_ENABLE_DIVERSITY,\n\tOUT_MSG_SET_OUTPUT_MODE,\n\tOUT_MSG_SET_PRIORITARY_CHANNEL,\n\tOUT_MSG_ACK_FRG,\n\tOUT_MSG_INIT_PMU,\n};\n\nenum dib9000_in_messages {\n\tIN_MSG_DATA,\n\tIN_MSG_FRAME_INFO,\n\tIN_MSG_CTL_MONIT,\n\tIN_MSG_ACK_FREE_ITEM,\n\tIN_MSG_DEBUG_BUF,\n\tIN_MSG_MPE_MONITOR,\n\tIN_MSG_RAWTS_MONITOR,\n\tIN_MSG_END_BRIDGE_I2C_RW,\n\tIN_MSG_END_BRIDGE_APB_RW,\n\tIN_MSG_VERSION,\n\tIN_MSG_END_OF_SCAN,\n\tIN_MSG_MONIT_DEMOD,\n\tIN_MSG_ERROR,\n\tIN_MSG_FE_FW_DL_DONE,\n\tIN_MSG_EVENT,\n\tIN_MSG_ACK_CHANGE_SVC,\n\tIN_MSG_HBM_PROF,\n};\n\n \n#define FE_MM_W_CHANNEL                   0\n#define FE_MM_W_FE_INFO                   1\n#define FE_MM_RW_SYNC                     2\n\n#define FE_SYNC_CHANNEL          1\n#define FE_SYNC_W_GENERIC_MONIT\t 2\n#define FE_SYNC_COMPONENT_ACCESS 3\n\n#define FE_MM_R_CHANNEL_SEARCH_STATE      3\n#define FE_MM_R_CHANNEL_UNION_CONTEXT     4\n#define FE_MM_R_FE_INFO                   5\n#define FE_MM_R_FE_MONITOR                6\n\n#define FE_MM_W_CHANNEL_HEAD              7\n#define FE_MM_W_CHANNEL_UNION             8\n#define FE_MM_W_CHANNEL_CONTEXT           9\n#define FE_MM_R_CHANNEL_UNION            10\n#define FE_MM_R_CHANNEL_CONTEXT          11\n#define FE_MM_R_CHANNEL_TUNE_STATE       12\n\n#define FE_MM_R_GENERIC_MONITORING_SIZE\t 13\n#define FE_MM_W_GENERIC_MONITORING\t     14\n#define FE_MM_R_GENERIC_MONITORING\t     15\n\n#define FE_MM_W_COMPONENT_ACCESS         16\n#define FE_MM_RW_COMPONENT_ACCESS_BUFFER 17\nstatic int dib9000_risc_apb_access_read(struct dib9000_state *state, u32 address, u16 attribute, const u8 * tx, u32 txlen, u8 * b, u32 len);\nstatic int dib9000_risc_apb_access_write(struct dib9000_state *state, u32 address, u16 attribute, const u8 * b, u32 len);\n\nstatic u16 to_fw_output_mode(u16 mode)\n{\n\tswitch (mode) {\n\tcase OUTMODE_HIGH_Z:\n\t\treturn 0;\n\tcase OUTMODE_MPEG2_PAR_GATED_CLK:\n\t\treturn 4;\n\tcase OUTMODE_MPEG2_PAR_CONT_CLK:\n\t\treturn 8;\n\tcase OUTMODE_MPEG2_SERIAL:\n\t\treturn 16;\n\tcase OUTMODE_DIVERSITY:\n\t\treturn 128;\n\tcase OUTMODE_MPEG2_FIFO:\n\t\treturn 2;\n\tcase OUTMODE_ANALOG_ADC:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int dib9000_read16_attr(struct dib9000_state *state, u16 reg, u8 *b, u32 len, u16 attribute)\n{\n\tu32 chunk_size = 126;\n\tu32 l;\n\tint ret;\n\n\tif (state->platform.risc.fw_is_running && (reg < 1024))\n\t\treturn dib9000_risc_apb_access_read(state, reg, attribute, NULL, 0, b, len);\n\n\tmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\n\tstate->msg[0].addr = state->i2c.i2c_addr >> 1;\n\tstate->msg[0].flags = 0;\n\tstate->msg[0].buf = state->i2c_write_buffer;\n\tstate->msg[0].len = 2;\n\tstate->msg[1].addr = state->i2c.i2c_addr >> 1;\n\tstate->msg[1].flags = I2C_M_RD;\n\tstate->msg[1].buf = b;\n\tstate->msg[1].len = len;\n\n\tstate->i2c_write_buffer[0] = reg >> 8;\n\tstate->i2c_write_buffer[1] = reg & 0xff;\n\n\tif (attribute & DATA_BUS_ACCESS_MODE_8BIT)\n\t\tstate->i2c_write_buffer[0] |= (1 << 5);\n\tif (attribute & DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT)\n\t\tstate->i2c_write_buffer[0] |= (1 << 4);\n\n\tdo {\n\t\tl = min(len, chunk_size);\n\t\tstate->msg[1].len = l;\n\t\tstate->msg[1].buf = b;\n\t\tret = i2c_transfer(state->i2c.i2c_adap, state->msg, 2) != 2 ? -EREMOTEIO : 0;\n\t\tif (ret != 0) {\n\t\t\tdprintk(\"i2c read error on %d\\n\", reg);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\n\t\tb += l;\n\t\tlen -= l;\n\n\t\tif (!(attribute & DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT))\n\t\t\treg += l / 2;\n\t} while ((ret == 0) && len);\n\n\treturn 0;\n}\n\nstatic u16 dib9000_i2c_read16(struct i2c_device *i2c, u16 reg)\n{\n\tstruct i2c_msg msg[2] = {\n\t\t{.addr = i2c->i2c_addr >> 1, .flags = 0,\n\t\t\t.buf = i2c->i2c_write_buffer, .len = 2},\n\t\t{.addr = i2c->i2c_addr >> 1, .flags = I2C_M_RD,\n\t\t\t.buf = i2c->i2c_read_buffer, .len = 2},\n\t};\n\n\ti2c->i2c_write_buffer[0] = reg >> 8;\n\ti2c->i2c_write_buffer[1] = reg & 0xff;\n\n\tif (i2c_transfer(i2c->i2c_adap, msg, 2) != 2) {\n\t\tdprintk(\"read register %x error\\n\", reg);\n\t\treturn 0;\n\t}\n\n\treturn (i2c->i2c_read_buffer[0] << 8) | i2c->i2c_read_buffer[1];\n}\n\nstatic inline u16 dib9000_read_word(struct dib9000_state *state, u16 reg)\n{\n\tif (dib9000_read16_attr(state, reg, state->i2c_read_buffer, 2, 0) != 0)\n\t\treturn 0;\n\treturn (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];\n}\n\nstatic inline u16 dib9000_read_word_attr(struct dib9000_state *state, u16 reg, u16 attribute)\n{\n\tif (dib9000_read16_attr(state, reg, state->i2c_read_buffer, 2,\n\t\t\t\tattribute) != 0)\n\t\treturn 0;\n\treturn (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];\n}\n\n#define dib9000_read16_noinc_attr(state, reg, b, len, attribute) dib9000_read16_attr(state, reg, b, len, (attribute) | DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT)\n\nstatic int dib9000_write16_attr(struct dib9000_state *state, u16 reg, const u8 *buf, u32 len, u16 attribute)\n{\n\tu32 chunk_size = 126;\n\tu32 l;\n\tint ret;\n\n\tif (state->platform.risc.fw_is_running && (reg < 1024)) {\n\t\tif (dib9000_risc_apb_access_write\n\t\t    (state, reg, DATA_BUS_ACCESS_MODE_16BIT | DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT | attribute, buf, len) != 0)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tmemset(&state->msg[0], 0, sizeof(struct i2c_msg));\n\tstate->msg[0].addr = state->i2c.i2c_addr >> 1;\n\tstate->msg[0].flags = 0;\n\tstate->msg[0].buf = state->i2c_write_buffer;\n\tstate->msg[0].len = len + 2;\n\n\tstate->i2c_write_buffer[0] = (reg >> 8) & 0xff;\n\tstate->i2c_write_buffer[1] = (reg) & 0xff;\n\n\tif (attribute & DATA_BUS_ACCESS_MODE_8BIT)\n\t\tstate->i2c_write_buffer[0] |= (1 << 5);\n\tif (attribute & DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT)\n\t\tstate->i2c_write_buffer[0] |= (1 << 4);\n\n\tdo {\n\t\tl = min(len, chunk_size);\n\t\tstate->msg[0].len = l + 2;\n\t\tmemcpy(&state->i2c_write_buffer[2], buf, l);\n\n\t\tret = i2c_transfer(state->i2c.i2c_adap, state->msg, 1) != 1 ? -EREMOTEIO : 0;\n\n\t\tbuf += l;\n\t\tlen -= l;\n\n\t\tif (!(attribute & DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT))\n\t\t\treg += l / 2;\n\t} while ((ret == 0) && len);\n\n\treturn ret;\n}\n\nstatic int dib9000_i2c_write16(struct i2c_device *i2c, u16 reg, u16 val)\n{\n\tstruct i2c_msg msg = {\n\t\t.addr = i2c->i2c_addr >> 1, .flags = 0,\n\t\t.buf = i2c->i2c_write_buffer, .len = 4\n\t};\n\n\ti2c->i2c_write_buffer[0] = (reg >> 8) & 0xff;\n\ti2c->i2c_write_buffer[1] = reg & 0xff;\n\ti2c->i2c_write_buffer[2] = (val >> 8) & 0xff;\n\ti2c->i2c_write_buffer[3] = val & 0xff;\n\n\treturn i2c_transfer(i2c->i2c_adap, &msg, 1) != 1 ? -EREMOTEIO : 0;\n}\n\nstatic inline int dib9000_write_word(struct dib9000_state *state, u16 reg, u16 val)\n{\n\tu8 b[2] = { val >> 8, val & 0xff };\n\treturn dib9000_write16_attr(state, reg, b, 2, 0);\n}\n\nstatic inline int dib9000_write_word_attr(struct dib9000_state *state, u16 reg, u16 val, u16 attribute)\n{\n\tu8 b[2] = { val >> 8, val & 0xff };\n\treturn dib9000_write16_attr(state, reg, b, 2, attribute);\n}\n\n#define dib9000_write(state, reg, buf, len) dib9000_write16_attr(state, reg, buf, len, 0)\n#define dib9000_write16_noinc(state, reg, buf, len) dib9000_write16_attr(state, reg, buf, len, DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT)\n#define dib9000_write16_noinc_attr(state, reg, buf, len, attribute) dib9000_write16_attr(state, reg, buf, len, DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT | (attribute))\n\n#define dib9000_mbx_send(state, id, data, len) dib9000_mbx_send_attr(state, id, data, len, 0)\n#define dib9000_mbx_get_message(state, id, msg, len) dib9000_mbx_get_message_attr(state, id, msg, len, 0)\n\n#define MAC_IRQ      (1 << 1)\n#define IRQ_POL_MSK  (1 << 4)\n\n#define dib9000_risc_mem_read_chunks(state, b, len) dib9000_read16_attr(state, 1063, b, len, DATA_BUS_ACCESS_MODE_8BIT | DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT)\n#define dib9000_risc_mem_write_chunks(state, buf, len) dib9000_write16_attr(state, 1063, buf, len, DATA_BUS_ACCESS_MODE_8BIT | DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT)\n\nstatic void dib9000_risc_mem_setup_cmd(struct dib9000_state *state, u32 addr, u32 len, u8 reading)\n{\n\tu8 b[14] = { 0 };\n\n \n \n\tb[1] = 1;\n\n \n \n\tb[4] = (u8) (addr >> 8);\n\tb[5] = (u8) (addr & 0xff);\n\n \n \n\tb[12] = (u8) (addr >> 8);\n\tb[13] = (u8) (addr & 0xff);\n\n\taddr += len;\n \n \n\tb[8] = (u8) (addr >> 8);\n\tb[9] = (u8) (addr & 0xff);\n\n\tdib9000_write(state, 1056, b, 14);\n\tif (reading)\n\t\tdib9000_write_word(state, 1056, (1 << 15) | 1);\n\tstate->platform.risc.memcmd = -1;\t \n}\n\nstatic void dib9000_risc_mem_setup(struct dib9000_state *state, u8 cmd)\n{\n\tstruct dib9000_fe_memory_map *m = &state->platform.risc.fe_mm[cmd & 0x7f];\n\t \n\tif (state->platform.risc.memcmd == cmd &&\t \n\t    !(cmd & 0x80 && m->size < 67))\t \n\t\treturn;\n\tdib9000_risc_mem_setup_cmd(state, m->addr, m->size, cmd & 0x80);\n\tstate->platform.risc.memcmd = cmd;\n}\n\nstatic int dib9000_risc_mem_read(struct dib9000_state *state, u8 cmd, u8 * b, u16 len)\n{\n\tif (!state->platform.risc.fw_is_running)\n\t\treturn -EIO;\n\n\tif (mutex_lock_interruptible(&state->platform.risc.mem_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -EINTR;\n\t}\n\tdib9000_risc_mem_setup(state, cmd | 0x80);\n\tdib9000_risc_mem_read_chunks(state, b, len);\n\tmutex_unlock(&state->platform.risc.mem_lock);\n\treturn 0;\n}\n\nstatic int dib9000_risc_mem_write(struct dib9000_state *state, u8 cmd, const u8 * b)\n{\n\tstruct dib9000_fe_memory_map *m = &state->platform.risc.fe_mm[cmd];\n\tif (!state->platform.risc.fw_is_running)\n\t\treturn -EIO;\n\n\tif (mutex_lock_interruptible(&state->platform.risc.mem_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -EINTR;\n\t}\n\tdib9000_risc_mem_setup(state, cmd);\n\tdib9000_risc_mem_write_chunks(state, b, m->size);\n\tmutex_unlock(&state->platform.risc.mem_lock);\n\treturn 0;\n}\n\nstatic int dib9000_firmware_download(struct dib9000_state *state, u8 risc_id, u16 key, const u8 * code, u32 len)\n{\n\tu16 offs;\n\n\tif (risc_id == 1)\n\t\toffs = 16;\n\telse\n\t\toffs = 0;\n\n\t \n\tdib9000_write_word(state, 1024 + offs, 0x000f);\n\tdib9000_write_word(state, 1025 + offs, 0);\n\tdib9000_write_word(state, 1031 + offs, key);\n\n\tdprintk(\"going to download %dB of microcode\\n\", len);\n\tif (dib9000_write16_noinc(state, 1026 + offs, (u8 *) code, (u16) len) != 0) {\n\t\tdprintk(\"error while downloading microcode for RISC %c\\n\", 'A' + risc_id);\n\t\treturn -EIO;\n\t}\n\n\tdprintk(\"Microcode for RISC %c loaded\\n\", 'A' + risc_id);\n\n\treturn 0;\n}\n\nstatic int dib9000_mbx_host_init(struct dib9000_state *state, u8 risc_id)\n{\n\tu16 mbox_offs;\n\tu16 reset_reg;\n\tu16 tries = 1000;\n\n\tif (risc_id == 1)\n\t\tmbox_offs = 16;\n\telse\n\t\tmbox_offs = 0;\n\n\t \n\tdib9000_write_word(state, 1027 + mbox_offs, 0x8000);\n\n\t \n\tdo {\n\t\treset_reg = dib9000_read_word(state, 1027 + mbox_offs);\n\t\tmsleep(100);\n\t} while ((reset_reg & 0x8000) && --tries);\n\n\tif (reset_reg & 0x8000) {\n\t\tdprintk(\"MBX: init ERROR, no response from RISC %c\\n\", 'A' + risc_id);\n\t\treturn -EIO;\n\t}\n\tdprintk(\"MBX: initialized\\n\");\n\treturn 0;\n}\n\n#define MAX_MAILBOX_TRY 100\nstatic int dib9000_mbx_send_attr(struct dib9000_state *state, u8 id, u16 * data, u8 len, u16 attr)\n{\n\tu8 *d, b[2];\n\tu16 tmp;\n\tu16 size;\n\tu32 i;\n\tint ret = 0;\n\n\tif (!state->platform.risc.fw_is_running)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&state->platform.risc.mbx_if_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -EINTR;\n\t}\n\ttmp = MAX_MAILBOX_TRY;\n\tdo {\n\t\tsize = dib9000_read_word_attr(state, 1043, attr) & 0xff;\n\t\tif ((size + len + 1) > MBX_MAX_WORDS && --tmp) {\n\t\t\tdprintk(\"MBX: RISC mbx full, retrying\\n\");\n\t\t\tmsleep(100);\n\t\t} else\n\t\t\tbreak;\n\t} while (1);\n\n\t \n\n\tif (tmp == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n#ifdef DUMP_MSG\n\tdprintk(\"--> %02x %d %*ph\\n\", id, len + 1, len, data);\n#endif\n\n\t \n\td = (u8 *) data;\n\tfor (i = 0; i < len; i++) {\n\t\ttmp = data[i];\n\t\t*d++ = tmp >> 8;\n\t\t*d++ = tmp & 0xff;\n\t}\n\n\t \n\tb[0] = id;\n\tb[1] = len + 1;\n\tif (dib9000_write16_noinc_attr(state, 1045, b, 2, attr) != 0 || dib9000_write16_noinc_attr(state, 1045, (u8 *) data, len * 2, attr) != 0) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tret = (u8) dib9000_write_word_attr(state, 1043, 1 << 14, attr);\n\nout:\n\tmutex_unlock(&state->platform.risc.mbx_if_lock);\n\n\treturn ret;\n}\n\nstatic u8 dib9000_mbx_read(struct dib9000_state *state, u16 * data, u8 risc_id, u16 attr)\n{\n#ifdef DUMP_MSG\n\tu16 *d = data;\n#endif\n\n\tu16 tmp, i;\n\tu8 size;\n\tu8 mc_base;\n\n\tif (!state->platform.risc.fw_is_running)\n\t\treturn 0;\n\n\tif (mutex_lock_interruptible(&state->platform.risc.mbx_if_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn 0;\n\t}\n\tif (risc_id == 1)\n\t\tmc_base = 16;\n\telse\n\t\tmc_base = 0;\n\n\t \n\t*data = dib9000_read_word_attr(state, 1029 + mc_base, attr);\n\n\tsize = *data & 0xff;\n\tif (size <= MBX_MAX_WORDS) {\n\t\tdata++;\n\t\tsize--;\t\t \n\n\t\tdib9000_read16_noinc_attr(state, 1029 + mc_base, (u8 *) data, size * 2, attr);\n\n\t\t \n\t\tfor (i = 0; i < size; i++) {\n\t\t\ttmp = *data;\n\t\t\t*data = (tmp >> 8) | (tmp << 8);\n\t\t\tdata++;\n\t\t}\n\n#ifdef DUMP_MSG\n\t\tdprintk(\"<--\\n\");\n\t\tfor (i = 0; i < size + 1; i++)\n\t\t\tdprintk(\"%04x\\n\", d[i]);\n\t\tdprintk(\"\\n\");\n#endif\n\t} else {\n\t\tdprintk(\"MBX: message is too big for message cache (%d), flushing message\\n\", size);\n\t\tsize--;\t\t \n\t\twhile (size--)\n\t\t\tdib9000_read16_noinc_attr(state, 1029 + mc_base, (u8 *) data, 2, attr);\n\t}\n\t \n\tdib9000_write_word_attr(state, 1028 + mc_base, 1 << 14, attr);\n\n\tmutex_unlock(&state->platform.risc.mbx_if_lock);\n\n\treturn size + 1;\n}\n\nstatic int dib9000_risc_debug_buf(struct dib9000_state *state, u16 * data, u8 size)\n{\n\tu32 ts = data[1] << 16 | data[0];\n\tchar *b = (char *)&data[2];\n\n\tb[2 * (size - 2) - 1] = '\\0';\t \n\tif (*b == '~') {\n\t\tb++;\n\t\tdprintk(\"%s\\n\", b);\n\t} else\n\t\tdprintk(\"RISC%d: %d.%04d %s\\n\",\n\t\t\tstate->fe_id,\n\t\t\tts / 10000, ts % 10000, *b ? b : \"<empty>\");\n\treturn 1;\n}\n\nstatic int dib9000_mbx_fetch_to_cache(struct dib9000_state *state, u16 attr)\n{\n\tint i;\n\tu8 size;\n\tu16 *block;\n\t \n\tfor (i = 0; i < DIB9000_MSG_CACHE_SIZE; i++) {\n\t\tblock = state->platform.risc.message_cache[i];\n\t\tif (*block == 0) {\n\t\t\tsize = dib9000_mbx_read(state, block, 1, attr);\n\n \n\n\t\t\tswitch (*block >> 8) {\n\t\t\tcase IN_MSG_DEBUG_BUF:\n\t\t\t\tdib9000_risc_debug_buf(state, block + 1, size);\t \n\t\t\t\t*block = 0;\t \n\t\t\t\tbreak;\n#if 0\n\t\t\tcase IN_MSG_DATA:\t \n\t\t\t\tdib9000_risc_data_process(state, block + 1, size);\n\t\t\t\t*block = 0;\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\tdprintk(\"MBX: no free cache-slot found for new message...\\n\");\n\treturn -1;\n}\n\nstatic u8 dib9000_mbx_count(struct dib9000_state *state, u8 risc_id, u16 attr)\n{\n\tif (risc_id == 0)\n\t\treturn (u8) (dib9000_read_word_attr(state, 1028, attr) >> 10) & 0x1f;\t \n\telse\n\t\treturn (u8) (dib9000_read_word_attr(state, 1044, attr) >> 8) & 0x7f;\t \n}\n\nstatic int dib9000_mbx_process(struct dib9000_state *state, u16 attr)\n{\n\tint ret = 0;\n\n\tif (!state->platform.risc.fw_is_running)\n\t\treturn -1;\n\n\tif (mutex_lock_interruptible(&state->platform.risc.mbx_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -1;\n\t}\n\n\tif (dib9000_mbx_count(state, 1, attr))\t \n\t\tret = dib9000_mbx_fetch_to_cache(state, attr);\n\n\tdib9000_read_word_attr(state, 1229, attr);\t \n \n \n\tmutex_unlock(&state->platform.risc.mbx_lock);\n\n\treturn ret;\n}\n\nstatic int dib9000_mbx_get_message_attr(struct dib9000_state *state, u16 id, u16 * msg, u8 * size, u16 attr)\n{\n\tu8 i;\n\tu16 *block;\n\tu16 timeout = 30;\n\n\t*msg = 0;\n\tdo {\n\t\t \n\t\tfor (i = 0; i < DIB9000_MSG_CACHE_SIZE; i++) {\n\t\t\tblock = state->platform.risc.message_cache[i];\n\t\t\tif ((*block >> 8) == id) {\n\t\t\t\t*size = (*block & 0xff) - 1;\n\t\t\t\tmemcpy(msg, block + 1, (*size) * 2);\n\t\t\t\t*block = 0;\t \n\t\t\t\ti = 0;\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == 0)\n\t\t\tbreak;\n\n\t\tif (dib9000_mbx_process(state, attr) == -1)\t \n\t\t\treturn -1;\n\n\t} while (--timeout);\n\n\tif (timeout == 0) {\n\t\tdprintk(\"waiting for message %d timed out\\n\", id);\n\t\treturn -1;\n\t}\n\n\treturn i == 0;\n}\n\nstatic int dib9000_risc_check_version(struct dib9000_state *state)\n{\n\tu8 r[4];\n\tu8 size;\n\tu16 fw_version = 0;\n\n\tif (dib9000_mbx_send(state, OUT_MSG_REQ_VERSION, &fw_version, 1) != 0)\n\t\treturn -EIO;\n\n\tif (dib9000_mbx_get_message(state, IN_MSG_VERSION, (u16 *) r, &size) < 0)\n\t\treturn -EIO;\n\n\tfw_version = (r[0] << 8) | r[1];\n\tdprintk(\"RISC: ver: %d.%02d (IC: %d)\\n\", fw_version >> 10, fw_version & 0x3ff, (r[2] << 8) | r[3]);\n\n\tif ((fw_version >> 10) != 7)\n\t\treturn -EINVAL;\n\n\tswitch (fw_version & 0x3ff) {\n\tcase 11:\n\tcase 12:\n\tcase 14:\n\tcase 15:\n\tcase 16:\n\tcase 17:\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"RISC: invalid firmware version\");\n\t\treturn -EINVAL;\n\t}\n\n\tdprintk(\"RISC: valid firmware version\");\n\treturn 0;\n}\n\nstatic int dib9000_fw_boot(struct dib9000_state *state, const u8 * codeA, u32 lenA, const u8 * codeB, u32 lenB)\n{\n\t \n\tdib9000_write_word(state, 1225, 0x02);\t \n\tdib9000_write_word(state, 1226, 0x05);\n\n\t \n\tdib9000_write_word(state, 1542, 1);\n\n\t \n\tdib9000_write_word(state, 1074, 0);\n\tdib9000_write_word(state, 1075, 0);\n\n\t \n\tdib9000_write_word(state, 1237, 0);\n\n\t \n\tif (codeA != NULL)\n\t\tdib9000_write_word(state, 1024, 2);\n\telse\n\t\tdib9000_write_word(state, 1024, 15);\n\tif (codeB != NULL)\n\t\tdib9000_write_word(state, 1040, 2);\n\n\tif (codeA != NULL)\n\t\tdib9000_firmware_download(state, 0, 0x1234, codeA, lenA);\n\tif (codeB != NULL)\n\t\tdib9000_firmware_download(state, 1, 0x1234, codeB, lenB);\n\n\t \n\tif (codeA != NULL)\n\t\tdib9000_write_word(state, 1024, 0);\n\tif (codeB != NULL)\n\t\tdib9000_write_word(state, 1040, 0);\n\n\tif (codeA != NULL)\n\t\tif (dib9000_mbx_host_init(state, 0) != 0)\n\t\t\treturn -EIO;\n\tif (codeB != NULL)\n\t\tif (dib9000_mbx_host_init(state, 1) != 0)\n\t\t\treturn -EIO;\n\n\tmsleep(100);\n\tstate->platform.risc.fw_is_running = 1;\n\n\tif (dib9000_risc_check_version(state) != 0)\n\t\treturn -EINVAL;\n\n\tstate->platform.risc.memcmd = 0xff;\n\treturn 0;\n}\n\nstatic u16 dib9000_identify(struct i2c_device *client)\n{\n\tu16 value;\n\n\tvalue = dib9000_i2c_read16(client, 896);\n\tif (value != 0x01b3) {\n\t\tdprintk(\"wrong Vendor ID (0x%x)\\n\", value);\n\t\treturn 0;\n\t}\n\n\tvalue = dib9000_i2c_read16(client, 897);\n\tif (value != 0x4000 && value != 0x4001 && value != 0x4002 && value != 0x4003 && value != 0x4004 && value != 0x4005) {\n\t\tdprintk(\"wrong Device ID (0x%x)\\n\", value);\n\t\treturn 0;\n\t}\n\n\t \n\tif (value == 0x4000 && dib9000_i2c_read16(client, 769) == 0x4000) {\n\t\tdprintk(\"this driver does not work with DiB7000PC\\n\");\n\t\treturn 0;\n\t}\n\n\tswitch (value) {\n\tcase 0x4000:\n\t\tdprintk(\"found DiB7000MA/PA/MB/PB\\n\");\n\t\tbreak;\n\tcase 0x4001:\n\t\tdprintk(\"found DiB7000HC\\n\");\n\t\tbreak;\n\tcase 0x4002:\n\t\tdprintk(\"found DiB7000MC\\n\");\n\t\tbreak;\n\tcase 0x4003:\n\t\tdprintk(\"found DiB9000A\\n\");\n\t\tbreak;\n\tcase 0x4004:\n\t\tdprintk(\"found DiB9000H\\n\");\n\t\tbreak;\n\tcase 0x4005:\n\t\tdprintk(\"found DiB9000M\\n\");\n\t\tbreak;\n\t}\n\n\treturn value;\n}\n\nstatic void dib9000_set_power_mode(struct dib9000_state *state, enum dib9000_power_mode mode)\n{\n\t \n\tu16 reg_903 = 0x3fff, reg_904 = 0xffff, reg_905 = 0xffff, reg_906;\n\tu8 offset;\n\n\tif (state->revision == 0x4003 || state->revision == 0x4004 || state->revision == 0x4005)\n\t\toffset = 1;\n\telse\n\t\toffset = 0;\n\n\treg_906 = dib9000_read_word(state, 906 + offset) | 0x3;\t \n\n\t \n\tswitch (mode) {\n\t\t \n\tcase DIB9000_POWER_ALL:\n\t\treg_903 = 0x0000;\n\t\treg_904 = 0x0000;\n\t\treg_905 = 0x0000;\n\t\treg_906 = 0x0000;\n\t\tbreak;\n\n\t\t \n\tcase DIB9000_POWER_INTERFACE_ONLY:\t \n\t\treg_905 &= ~((1 << 7) | (1 << 6) | (1 << 5) | (1 << 2));\n\t\tbreak;\n\n\tcase DIB9000_POWER_INTERF_ANALOG_AGC:\n\t\treg_903 &= ~((1 << 15) | (1 << 14) | (1 << 11) | (1 << 10));\n\t\treg_905 &= ~((1 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (1 << 2));\n\t\treg_906 &= ~((1 << 0));\n\t\tbreak;\n\n\tcase DIB9000_POWER_COR4_DINTLV_ICIRM_EQUAL_CFROD:\n\t\treg_903 = 0x0000;\n\t\treg_904 = 0x801f;\n\t\treg_905 = 0x0000;\n\t\treg_906 &= ~((1 << 0));\n\t\tbreak;\n\n\tcase DIB9000_POWER_COR4_CRY_ESRAM_MOUT_NUD:\n\t\treg_903 = 0x0000;\n\t\treg_904 = 0x8000;\n\t\treg_905 = 0x010b;\n\t\treg_906 &= ~((1 << 0));\n\t\tbreak;\n\tdefault:\n\tcase DIB9000_POWER_NO:\n\t\tbreak;\n\t}\n\n\t \n\tif (!state->platform.host.mobile_mode)\n\t\treg_904 |= (1 << 7) | (1 << 6) | (1 << 4) | (1 << 2) | (1 << 1);\n\n\t \n\tif (state->revision != 0x4000)\n\t\treg_906 <<= 1;\n\n\tdib9000_write_word(state, 903 + offset, reg_903);\n\tdib9000_write_word(state, 904 + offset, reg_904);\n\tdib9000_write_word(state, 905 + offset, reg_905);\n\tdib9000_write_word(state, 906 + offset, reg_906);\n}\n\nstatic int dib9000_fw_reset(struct dvb_frontend *fe)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\n\tdib9000_write_word(state, 1817, 0x0003);\n\n\tdib9000_write_word(state, 1227, 1);\n\tdib9000_write_word(state, 1227, 0);\n\n\tswitch ((state->revision = dib9000_identify(&state->i2c))) {\n\tcase 0x4003:\n\tcase 0x4004:\n\tcase 0x4005:\n\t\tstate->reg_offs = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdibx000_reset_i2c_master(&state->i2c_master);\n\n\tdib9000_set_power_mode(state, DIB9000_POWER_ALL);\n\n\t \n\tdib9000_write_word(state, 1794, dib9000_read_word(state, 1794) & ~(1 << 1));\n\tdib9000_write_word(state, 1796, 0);\n\tdib9000_write_word(state, 1805, 0x805);\n\n\t \n\tdib9000_write_word(state, 898, 0xffff);\n\tdib9000_write_word(state, 899, 0xffff);\n\tdib9000_write_word(state, 900, 0x0001);\n\tdib9000_write_word(state, 901, 0xff19);\n\tdib9000_write_word(state, 902, 0x003c);\n\n\tdib9000_write_word(state, 898, 0);\n\tdib9000_write_word(state, 899, 0);\n\tdib9000_write_word(state, 900, 0);\n\tdib9000_write_word(state, 901, 0);\n\tdib9000_write_word(state, 902, 0);\n\n\tdib9000_write_word(state, 911, state->chip.d9.cfg.if_drives);\n\n\tdib9000_set_power_mode(state, DIB9000_POWER_INTERFACE_ONLY);\n\n\treturn 0;\n}\n\nstatic int dib9000_risc_apb_access_read(struct dib9000_state *state, u32 address, u16 attribute, const u8 * tx, u32 txlen, u8 * b, u32 len)\n{\n\tu16 mb[10];\n\tu8 i, s;\n\n\tif (address >= 1024 || !state->platform.risc.fw_is_running)\n\t\treturn -EINVAL;\n\n\t \n\n\tmb[0] = (u16) address;\n\tmb[1] = len / 2;\n\tdib9000_mbx_send_attr(state, OUT_MSG_BRIDGE_APB_R, mb, 2, attribute);\n\tswitch (dib9000_mbx_get_message_attr(state, IN_MSG_END_BRIDGE_APB_RW, mb, &s, attribute)) {\n\tcase 1:\n\t\ts--;\n\t\tfor (i = 0; i < s; i++) {\n\t\t\tb[i * 2] = (mb[i + 1] >> 8) & 0xff;\n\t\t\tb[i * 2 + 1] = (mb[i + 1]) & 0xff;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\treturn -EIO;\n}\n\nstatic int dib9000_risc_apb_access_write(struct dib9000_state *state, u32 address, u16 attribute, const u8 * b, u32 len)\n{\n\tu16 mb[10];\n\tu8 s, i;\n\n\tif (address >= 1024 || !state->platform.risc.fw_is_running)\n\t\treturn -EINVAL;\n\n\tif (len > 18)\n\t\treturn -EINVAL;\n\n\t \n\n\tmb[0] = (u16)address;\n\tfor (i = 0; i + 1 < len; i += 2)\n\t\tmb[1 + i / 2] = b[i] << 8 | b[i + 1];\n\tif (len & 1)\n\t\tmb[1 + len / 2] = b[len - 1] << 8;\n\n\tdib9000_mbx_send_attr(state, OUT_MSG_BRIDGE_APB_W, mb, (3 + len) / 2, attribute);\n\treturn dib9000_mbx_get_message_attr(state, IN_MSG_END_BRIDGE_APB_RW, mb, &s, attribute) == 1 ? 0 : -EINVAL;\n}\n\nstatic int dib9000_fw_memmbx_sync(struct dib9000_state *state, u8 i)\n{\n\tu8 index_loop = 10;\n\n\tif (!state->platform.risc.fw_is_running)\n\t\treturn 0;\n\tdib9000_risc_mem_write(state, FE_MM_RW_SYNC, &i);\n\tdo {\n\t\tdib9000_risc_mem_read(state, FE_MM_RW_SYNC, state->i2c_read_buffer, 1);\n\t} while (state->i2c_read_buffer[0] && index_loop--);\n\n\tif (index_loop > 0)\n\t\treturn 0;\n\treturn -EIO;\n}\n\nstatic int dib9000_fw_init(struct dib9000_state *state)\n{\n\tstruct dibGPIOFunction *f;\n\tu16 b[40] = { 0 };\n\tu8 i;\n\tu8 size;\n\n\tif (dib9000_fw_boot(state, NULL, 0, state->chip.d9.cfg.microcode_B_fe_buffer, state->chip.d9.cfg.microcode_B_fe_size) != 0)\n\t\treturn -EIO;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(state->chip.d9.cfg.gpio_function); i++) {\n\t\tf = &state->chip.d9.cfg.gpio_function[i];\n\t\tif (f->mask) {\n\t\t\tswitch (f->function) {\n\t\t\tcase BOARD_GPIO_FUNCTION_COMPONENT_ON:\n\t\t\t\tb[0] = (u16) f->mask;\n\t\t\t\tb[1] = (u16) f->direction;\n\t\t\t\tb[2] = (u16) f->value;\n\t\t\t\tbreak;\n\t\t\tcase BOARD_GPIO_FUNCTION_COMPONENT_OFF:\n\t\t\t\tb[3] = (u16) f->mask;\n\t\t\t\tb[4] = (u16) f->direction;\n\t\t\t\tb[5] = (u16) f->value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (dib9000_mbx_send(state, OUT_MSG_CONF_GPIO, b, 15) != 0)\n\t\treturn -EIO;\n\n\t \n\tb[0] = state->chip.d9.cfg.subband.size;\t \n\tfor (i = 0; i < state->chip.d9.cfg.subband.size; i++) {\n\t\tb[1 + i * 4] = state->chip.d9.cfg.subband.subband[i].f_mhz;\n\t\tb[2 + i * 4] = (u16) state->chip.d9.cfg.subband.subband[i].gpio.mask;\n\t\tb[3 + i * 4] = (u16) state->chip.d9.cfg.subband.subband[i].gpio.direction;\n\t\tb[4 + i * 4] = (u16) state->chip.d9.cfg.subband.subband[i].gpio.value;\n\t}\n\tb[1 + i * 4] = 0;\t \n\tif (dib9000_mbx_send(state, OUT_MSG_SUBBAND_SEL, b, 2 + 4 * i) != 0)\n\t\treturn -EIO;\n\n\t \n\tb[0] = (0 << 8) | 1;\n\t \n\tb[1] = (0 << 8) | (0);\n\tb[2] = (u16) (((state->chip.d9.cfg.xtal_clock_khz * 1000) >> 16) & 0xffff);\n\tb[3] = (u16) (((state->chip.d9.cfg.xtal_clock_khz * 1000)) & 0xffff);\n\tb[4] = (u16) ((state->chip.d9.cfg.vcxo_timer >> 16) & 0xffff);\n\tb[5] = (u16) ((state->chip.d9.cfg.vcxo_timer) & 0xffff);\n\tb[6] = (u16) ((state->chip.d9.cfg.timing_frequency >> 16) & 0xffff);\n\tb[7] = (u16) ((state->chip.d9.cfg.timing_frequency) & 0xffff);\n\tb[29] = state->chip.d9.cfg.if_drives;\n\tif (dib9000_mbx_send(state, OUT_MSG_INIT_DEMOD, b, ARRAY_SIZE(b)) != 0)\n\t\treturn -EIO;\n\n\tif (dib9000_mbx_send(state, OUT_MSG_FE_FW_DL, NULL, 0) != 0)\n\t\treturn -EIO;\n\n\tif (dib9000_mbx_get_message(state, IN_MSG_FE_FW_DL_DONE, b, &size) < 0)\n\t\treturn -EIO;\n\n\tif (size > ARRAY_SIZE(b)) {\n\t\tdprintk(\"error : firmware returned %dbytes needed but the used buffer has only %dbytes\\n Firmware init ABORTED\", size,\n\t\t\t(int)ARRAY_SIZE(b));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i += 2) {\n\t\tstate->platform.risc.fe_mm[i / 2].addr = b[i + 0];\n\t\tstate->platform.risc.fe_mm[i / 2].size = b[i + 1];\n\t}\n\n\treturn 0;\n}\n\nstatic void dib9000_fw_set_channel_head(struct dib9000_state *state)\n{\n\tu8 b[9];\n\tu32 freq = state->fe[0]->dtv_property_cache.frequency / 1000;\n\tif (state->fe_id % 2)\n\t\tfreq += 101;\n\n\tb[0] = (u8) ((freq >> 0) & 0xff);\n\tb[1] = (u8) ((freq >> 8) & 0xff);\n\tb[2] = (u8) ((freq >> 16) & 0xff);\n\tb[3] = (u8) ((freq >> 24) & 0xff);\n\tb[4] = (u8) ((state->fe[0]->dtv_property_cache.bandwidth_hz / 1000 >> 0) & 0xff);\n\tb[5] = (u8) ((state->fe[0]->dtv_property_cache.bandwidth_hz / 1000 >> 8) & 0xff);\n\tb[6] = (u8) ((state->fe[0]->dtv_property_cache.bandwidth_hz / 1000 >> 16) & 0xff);\n\tb[7] = (u8) ((state->fe[0]->dtv_property_cache.bandwidth_hz / 1000 >> 24) & 0xff);\n\tb[8] = 0x80;\t\t \n\tif (state->fe[0]->dtv_property_cache.delivery_system == SYS_DVBT)\n\t\tb[8] |= 1;\n\tdib9000_risc_mem_write(state, FE_MM_W_CHANNEL_HEAD, b);\n}\n\nstatic int dib9000_fw_get_channel(struct dvb_frontend *fe)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tstruct dibDVBTChannel {\n\t\ts8 spectrum_inversion;\n\n\t\ts8 nfft;\n\t\ts8 guard;\n\t\ts8 constellation;\n\n\t\ts8 hrch;\n\t\ts8 alpha;\n\t\ts8 code_rate_hp;\n\t\ts8 code_rate_lp;\n\t\ts8 select_hp;\n\n\t\ts8 intlv_native;\n\t};\n\tstruct dibDVBTChannel *ch;\n\tint ret = 0;\n\n\tif (mutex_lock_interruptible(&state->platform.risc.mem_mbx_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -EINTR;\n\t}\n\tif (dib9000_fw_memmbx_sync(state, FE_SYNC_CHANNEL) < 0) {\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\n\tdib9000_risc_mem_read(state, FE_MM_R_CHANNEL_UNION,\n\t\t\tstate->i2c_read_buffer, sizeof(struct dibDVBTChannel));\n\tch = (struct dibDVBTChannel *)state->i2c_read_buffer;\n\n\n\tswitch (ch->spectrum_inversion & 0x7) {\n\tcase 1:\n\t\tstate->fe[0]->dtv_property_cache.inversion = INVERSION_ON;\n\t\tbreak;\n\tcase 0:\n\t\tstate->fe[0]->dtv_property_cache.inversion = INVERSION_OFF;\n\t\tbreak;\n\tdefault:\n\tcase -1:\n\t\tstate->fe[0]->dtv_property_cache.inversion = INVERSION_AUTO;\n\t\tbreak;\n\t}\n\tswitch (ch->nfft) {\n\tcase 0:\n\t\tstate->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n\tcase 2:\n\t\tstate->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_4K;\n\t\tbreak;\n\tcase 1:\n\t\tstate->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_8K;\n\t\tbreak;\n\tdefault:\n\tcase -1:\n\t\tstate->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_AUTO;\n\t\tbreak;\n\t}\n\tswitch (ch->guard) {\n\tcase 0:\n\t\tstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\tstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\tstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\tdefault:\n\tcase -1:\n\t\tstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_AUTO;\n\t\tbreak;\n\t}\n\tswitch (ch->constellation) {\n\tcase 2:\n\t\tstate->fe[0]->dtv_property_cache.modulation = QAM_64;\n\t\tbreak;\n\tcase 1:\n\t\tstate->fe[0]->dtv_property_cache.modulation = QAM_16;\n\t\tbreak;\n\tcase 0:\n\t\tstate->fe[0]->dtv_property_cache.modulation = QPSK;\n\t\tbreak;\n\tdefault:\n\tcase -1:\n\t\tstate->fe[0]->dtv_property_cache.modulation = QAM_AUTO;\n\t\tbreak;\n\t}\n\tswitch (ch->hrch) {\n\tcase 0:\n\t\tstate->fe[0]->dtv_property_cache.hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tstate->fe[0]->dtv_property_cache.hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tdefault:\n\tcase -1:\n\t\tstate->fe[0]->dtv_property_cache.hierarchy = HIERARCHY_AUTO;\n\t\tbreak;\n\t}\n\tswitch (ch->code_rate_hp) {\n\tcase 1:\n\t\tstate->fe[0]->dtv_property_cache.code_rate_HP = FEC_1_2;\n\t\tbreak;\n\tcase 2:\n\t\tstate->fe[0]->dtv_property_cache.code_rate_HP = FEC_2_3;\n\t\tbreak;\n\tcase 3:\n\t\tstate->fe[0]->dtv_property_cache.code_rate_HP = FEC_3_4;\n\t\tbreak;\n\tcase 5:\n\t\tstate->fe[0]->dtv_property_cache.code_rate_HP = FEC_5_6;\n\t\tbreak;\n\tcase 7:\n\t\tstate->fe[0]->dtv_property_cache.code_rate_HP = FEC_7_8;\n\t\tbreak;\n\tdefault:\n\tcase -1:\n\t\tstate->fe[0]->dtv_property_cache.code_rate_HP = FEC_AUTO;\n\t\tbreak;\n\t}\n\tswitch (ch->code_rate_lp) {\n\tcase 1:\n\t\tstate->fe[0]->dtv_property_cache.code_rate_LP = FEC_1_2;\n\t\tbreak;\n\tcase 2:\n\t\tstate->fe[0]->dtv_property_cache.code_rate_LP = FEC_2_3;\n\t\tbreak;\n\tcase 3:\n\t\tstate->fe[0]->dtv_property_cache.code_rate_LP = FEC_3_4;\n\t\tbreak;\n\tcase 5:\n\t\tstate->fe[0]->dtv_property_cache.code_rate_LP = FEC_5_6;\n\t\tbreak;\n\tcase 7:\n\t\tstate->fe[0]->dtv_property_cache.code_rate_LP = FEC_7_8;\n\t\tbreak;\n\tdefault:\n\tcase -1:\n\t\tstate->fe[0]->dtv_property_cache.code_rate_LP = FEC_AUTO;\n\t\tbreak;\n\t}\n\nerror:\n\tmutex_unlock(&state->platform.risc.mem_mbx_lock);\n\treturn ret;\n}\n\nstatic int dib9000_fw_set_channel_union(struct dvb_frontend *fe)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tstruct dibDVBTChannel {\n\t\ts8 spectrum_inversion;\n\n\t\ts8 nfft;\n\t\ts8 guard;\n\t\ts8 constellation;\n\n\t\ts8 hrch;\n\t\ts8 alpha;\n\t\ts8 code_rate_hp;\n\t\ts8 code_rate_lp;\n\t\ts8 select_hp;\n\n\t\ts8 intlv_native;\n\t};\n\tstruct dibDVBTChannel ch;\n\n\tswitch (state->fe[0]->dtv_property_cache.inversion) {\n\tcase INVERSION_ON:\n\t\tch.spectrum_inversion = 1;\n\t\tbreak;\n\tcase INVERSION_OFF:\n\t\tch.spectrum_inversion = 0;\n\t\tbreak;\n\tdefault:\n\tcase INVERSION_AUTO:\n\t\tch.spectrum_inversion = -1;\n\t\tbreak;\n\t}\n\tswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\t\tch.nfft = 0;\n\t\tbreak;\n\tcase TRANSMISSION_MODE_4K:\n\t\tch.nfft = 2;\n\t\tbreak;\n\tcase TRANSMISSION_MODE_8K:\n\t\tch.nfft = 1;\n\t\tbreak;\n\tdefault:\n\tcase TRANSMISSION_MODE_AUTO:\n\t\tch.nfft = 1;\n\t\tbreak;\n\t}\n\tswitch (state->fe[0]->dtv_property_cache.guard_interval) {\n\tcase GUARD_INTERVAL_1_32:\n\t\tch.guard = 0;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_16:\n\t\tch.guard = 1;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_8:\n\t\tch.guard = 2;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_4:\n\t\tch.guard = 3;\n\t\tbreak;\n\tdefault:\n\tcase GUARD_INTERVAL_AUTO:\n\t\tch.guard = -1;\n\t\tbreak;\n\t}\n\tswitch (state->fe[0]->dtv_property_cache.modulation) {\n\tcase QAM_64:\n\t\tch.constellation = 2;\n\t\tbreak;\n\tcase QAM_16:\n\t\tch.constellation = 1;\n\t\tbreak;\n\tcase QPSK:\n\t\tch.constellation = 0;\n\t\tbreak;\n\tdefault:\n\tcase QAM_AUTO:\n\t\tch.constellation = -1;\n\t\tbreak;\n\t}\n\tswitch (state->fe[0]->dtv_property_cache.hierarchy) {\n\tcase HIERARCHY_NONE:\n\t\tch.hrch = 0;\n\t\tbreak;\n\tcase HIERARCHY_1:\n\tcase HIERARCHY_2:\n\tcase HIERARCHY_4:\n\t\tch.hrch = 1;\n\t\tbreak;\n\tdefault:\n\tcase HIERARCHY_AUTO:\n\t\tch.hrch = -1;\n\t\tbreak;\n\t}\n\tch.alpha = 1;\n\tswitch (state->fe[0]->dtv_property_cache.code_rate_HP) {\n\tcase FEC_1_2:\n\t\tch.code_rate_hp = 1;\n\t\tbreak;\n\tcase FEC_2_3:\n\t\tch.code_rate_hp = 2;\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tch.code_rate_hp = 3;\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tch.code_rate_hp = 5;\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tch.code_rate_hp = 7;\n\t\tbreak;\n\tdefault:\n\tcase FEC_AUTO:\n\t\tch.code_rate_hp = -1;\n\t\tbreak;\n\t}\n\tswitch (state->fe[0]->dtv_property_cache.code_rate_LP) {\n\tcase FEC_1_2:\n\t\tch.code_rate_lp = 1;\n\t\tbreak;\n\tcase FEC_2_3:\n\t\tch.code_rate_lp = 2;\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tch.code_rate_lp = 3;\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tch.code_rate_lp = 5;\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tch.code_rate_lp = 7;\n\t\tbreak;\n\tdefault:\n\tcase FEC_AUTO:\n\t\tch.code_rate_lp = -1;\n\t\tbreak;\n\t}\n\tch.select_hp = 1;\n\tch.intlv_native = 1;\n\n\tdib9000_risc_mem_write(state, FE_MM_W_CHANNEL_UNION, (u8 *) &ch);\n\n\treturn 0;\n}\n\nstatic int dib9000_fw_tune(struct dvb_frontend *fe)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tint ret = 10, search = state->channel_status.status == CHANNEL_STATUS_PARAMETERS_UNKNOWN;\n\ts8 i;\n\n\tswitch (state->tune_state) {\n\tcase CT_DEMOD_START:\n\t\tdib9000_fw_set_channel_head(state);\n\n\t\t \n\t\tdib9000_risc_mem_write(state, FE_MM_W_CHANNEL_CONTEXT, (u8 *) fe_info);\n\t\tdib9000_risc_mem_write(state, FE_MM_W_FE_INFO, (u8 *) fe_info);\n\n\t\tif (search)\n\t\t\tdib9000_mbx_send(state, OUT_MSG_FE_CHANNEL_SEARCH, NULL, 0);\n\t\telse {\n\t\t\tdib9000_fw_set_channel_union(fe);\n\t\t\tdib9000_mbx_send(state, OUT_MSG_FE_CHANNEL_TUNE, NULL, 0);\n\t\t}\n\t\tstate->tune_state = CT_DEMOD_STEP_1;\n\t\tbreak;\n\tcase CT_DEMOD_STEP_1:\n\t\tif (search)\n\t\t\tdib9000_risc_mem_read(state, FE_MM_R_CHANNEL_SEARCH_STATE, state->i2c_read_buffer, 1);\n\t\telse\n\t\t\tdib9000_risc_mem_read(state, FE_MM_R_CHANNEL_TUNE_STATE, state->i2c_read_buffer, 1);\n\t\ti = (s8)state->i2c_read_buffer[0];\n\t\tswitch (i) {\t \n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -2:\t \n\t\t\tif (search)\n\t\t\t\tstate->status = FE_STATUS_DEMOD_SUCCESS;\n\t\t\telse {\n\t\t\t\tstate->tune_state = CT_DEMOD_STOP;\n\t\t\t\tstate->status = FE_STATUS_LOCKED;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstate->status = FE_STATUS_TUNE_FAILED;\n\t\t\tstate->tune_state = CT_DEMOD_STOP;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = FE_CALLBACK_TIME_NEVER;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int dib9000_fw_set_diversity_in(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu16 mode = (u16) onoff;\n\treturn dib9000_mbx_send(state, OUT_MSG_ENABLE_DIVERSITY, &mode, 1);\n}\n\nstatic int dib9000_fw_set_output_mode(struct dvb_frontend *fe, int mode)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu16 outreg, smo_mode;\n\n\tdprintk(\"setting output mode for demod %p to %d\\n\", fe, mode);\n\n\tswitch (mode) {\n\tcase OUTMODE_MPEG2_PAR_GATED_CLK:\n\t\toutreg = (1 << 10);\t \n\t\tbreak;\n\tcase OUTMODE_MPEG2_PAR_CONT_CLK:\n\t\toutreg = (1 << 10) | (1 << 6);\t \n\t\tbreak;\n\tcase OUTMODE_MPEG2_SERIAL:\n\t\toutreg = (1 << 10) | (2 << 6) | (0 << 1);\t \n\t\tbreak;\n\tcase OUTMODE_DIVERSITY:\n\t\toutreg = (1 << 10) | (4 << 6);\t \n\t\tbreak;\n\tcase OUTMODE_MPEG2_FIFO:\n\t\toutreg = (1 << 10) | (5 << 6);\n\t\tbreak;\n\tcase OUTMODE_HIGH_Z:\n\t\toutreg = 0;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"Unhandled output_mode passed to be set for demod %p\\n\", &state->fe[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tdib9000_write_word(state, 1795, outreg);\n\n\tswitch (mode) {\n\tcase OUTMODE_MPEG2_PAR_GATED_CLK:\n\tcase OUTMODE_MPEG2_PAR_CONT_CLK:\n\tcase OUTMODE_MPEG2_SERIAL:\n\tcase OUTMODE_MPEG2_FIFO:\n\t\tsmo_mode = (dib9000_read_word(state, 295) & 0x0010) | (1 << 1);\n\t\tif (state->chip.d9.cfg.output_mpeg2_in_188_bytes)\n\t\t\tsmo_mode |= (1 << 5);\n\t\tdib9000_write_word(state, 295, smo_mode);\n\t\tbreak;\n\t}\n\n\toutreg = to_fw_output_mode(mode);\n\treturn dib9000_mbx_send(state, OUT_MSG_SET_OUTPUT_MODE, &outreg, 1);\n}\n\nstatic int dib9000_tuner_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\n{\n\tstruct dib9000_state *state = i2c_get_adapdata(i2c_adap);\n\tu16 i, len, t, index_msg;\n\n\tfor (index_msg = 0; index_msg < num; index_msg++) {\n\t\tif (msg[index_msg].flags & I2C_M_RD) {\t \n\t\t\tlen = msg[index_msg].len;\n\t\t\tif (len > 16)\n\t\t\t\tlen = 16;\n\n\t\t\tif (dib9000_read_word(state, 790) != 0)\n\t\t\t\tdprintk(\"TunerITF: read busy\\n\");\n\n\t\t\tdib9000_write_word(state, 784, (u16) (msg[index_msg].addr));\n\t\t\tdib9000_write_word(state, 787, (len / 2) - 1);\n\t\t\tdib9000_write_word(state, 786, 1);\t \n\n\t\t\ti = 1000;\n\t\t\twhile (dib9000_read_word(state, 790) != (len / 2) && i)\n\t\t\t\ti--;\n\n\t\t\tif (i == 0)\n\t\t\t\tdprintk(\"TunerITF: read failed\\n\");\n\n\t\t\tfor (i = 0; i < len; i += 2) {\n\t\t\t\tt = dib9000_read_word(state, 785);\n\t\t\t\tmsg[index_msg].buf[i] = (t >> 8) & 0xff;\n\t\t\t\tmsg[index_msg].buf[i + 1] = (t) & 0xff;\n\t\t\t}\n\t\t\tif (dib9000_read_word(state, 790) != 0)\n\t\t\t\tdprintk(\"TunerITF: read more data than expected\\n\");\n\t\t} else {\n\t\t\ti = 1000;\n\t\t\twhile (dib9000_read_word(state, 789) && i)\n\t\t\t\ti--;\n\t\t\tif (i == 0)\n\t\t\t\tdprintk(\"TunerITF: write busy\\n\");\n\n\t\t\tlen = msg[index_msg].len;\n\t\t\tif (len > 16)\n\t\t\t\tlen = 16;\n\n\t\t\tfor (i = 0; i < len; i += 2)\n\t\t\t\tdib9000_write_word(state, 785, (msg[index_msg].buf[i] << 8) | msg[index_msg].buf[i + 1]);\n\t\t\tdib9000_write_word(state, 784, (u16) msg[index_msg].addr);\n\t\t\tdib9000_write_word(state, 787, (len / 2) - 1);\n\t\t\tdib9000_write_word(state, 786, 0);\t \n\n\t\t\ti = 1000;\n\t\t\twhile (dib9000_read_word(state, 791) > 0 && i)\n\t\t\t\ti--;\n\t\t\tif (i == 0)\n\t\t\t\tdprintk(\"TunerITF: write failed\\n\");\n\t\t}\n\t}\n\treturn num;\n}\n\nint dib9000_fw_set_component_bus_speed(struct dvb_frontend *fe, u16 speed)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\n\tstate->component_bus_speed = speed;\n\treturn 0;\n}\nEXPORT_SYMBOL(dib9000_fw_set_component_bus_speed);\n\nstatic int dib9000_fw_component_bus_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\n{\n\tstruct dib9000_state *state = i2c_get_adapdata(i2c_adap);\n\tu8 type = 0;\t\t \n\tu8 port = DIBX000_I2C_INTERFACE_GPIO_3_4;\n\tu16 scl = state->component_bus_speed;\t \n\tstruct dib9000_fe_memory_map *m = &state->platform.risc.fe_mm[FE_MM_RW_COMPONENT_ACCESS_BUFFER];\n\tu8 p[13] = { 0 };\n\n\tp[0] = type;\n\tp[1] = port;\n\tp[2] = msg[0].addr << 1;\n\n\tp[3] = (u8) scl & 0xff;\t \n\tp[4] = (u8) (scl >> 8);\n\n\tp[7] = 0;\n\tp[8] = 0;\n\n\tp[9] = (u8) (msg[0].len);\n\tp[10] = (u8) (msg[0].len >> 8);\n\tif ((num > 1) && (msg[1].flags & I2C_M_RD)) {\n\t\tp[11] = (u8) (msg[1].len);\n\t\tp[12] = (u8) (msg[1].len >> 8);\n\t} else {\n\t\tp[11] = 0;\n\t\tp[12] = 0;\n\t}\n\n\tif (mutex_lock_interruptible(&state->platform.risc.mem_mbx_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn 0;\n\t}\n\n\tdib9000_risc_mem_write(state, FE_MM_W_COMPONENT_ACCESS, p);\n\n\t{\t\t\t \n\t\tdib9000_risc_mem_setup_cmd(state, m->addr, msg[0].len, 0);\n\t\tdib9000_risc_mem_write_chunks(state, msg[0].buf, msg[0].len);\n\t}\n\n\t \n\tif (dib9000_fw_memmbx_sync(state, FE_SYNC_COMPONENT_ACCESS) < 0) {\n\t\tmutex_unlock(&state->platform.risc.mem_mbx_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tif ((num > 1) && (msg[1].flags & I2C_M_RD))\n\t\tdib9000_risc_mem_read(state, FE_MM_RW_COMPONENT_ACCESS_BUFFER, msg[1].buf, msg[1].len);\n\n\tmutex_unlock(&state->platform.risc.mem_mbx_lock);\n\n\treturn num;\n}\n\nstatic u32 dib9000_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm dib9000_tuner_algo = {\n\t.master_xfer = dib9000_tuner_xfer,\n\t.functionality = dib9000_i2c_func,\n};\n\nstatic const struct i2c_algorithm dib9000_component_bus_algo = {\n\t.master_xfer = dib9000_fw_component_bus_xfer,\n\t.functionality = dib9000_i2c_func,\n};\n\nstruct i2c_adapter *dib9000_get_tuner_interface(struct dvb_frontend *fe)\n{\n\tstruct dib9000_state *st = fe->demodulator_priv;\n\treturn &st->tuner_adap;\n}\nEXPORT_SYMBOL(dib9000_get_tuner_interface);\n\nstruct i2c_adapter *dib9000_get_component_bus_interface(struct dvb_frontend *fe)\n{\n\tstruct dib9000_state *st = fe->demodulator_priv;\n\treturn &st->component_bus;\n}\nEXPORT_SYMBOL(dib9000_get_component_bus_interface);\n\nstruct i2c_adapter *dib9000_get_i2c_master(struct dvb_frontend *fe, enum dibx000_i2c_interface intf, int gating)\n{\n\tstruct dib9000_state *st = fe->demodulator_priv;\n\treturn dibx000_get_i2c_adapter(&st->i2c_master, intf, gating);\n}\nEXPORT_SYMBOL(dib9000_get_i2c_master);\n\nint dib9000_set_i2c_adapter(struct dvb_frontend *fe, struct i2c_adapter *i2c)\n{\n\tstruct dib9000_state *st = fe->demodulator_priv;\n\n\tst->i2c.i2c_adap = i2c;\n\treturn 0;\n}\nEXPORT_SYMBOL(dib9000_set_i2c_adapter);\n\nstatic int dib9000_cfg_gpio(struct dib9000_state *st, u8 num, u8 dir, u8 val)\n{\n\tst->gpio_dir = dib9000_read_word(st, 773);\n\tst->gpio_dir &= ~(1 << num);\t \n\tst->gpio_dir |= (dir & 0x1) << num;\t \n\tdib9000_write_word(st, 773, st->gpio_dir);\n\n\tst->gpio_val = dib9000_read_word(st, 774);\n\tst->gpio_val &= ~(1 << num);\t \n\tst->gpio_val |= (val & 0x01) << num;\t \n\tdib9000_write_word(st, 774, st->gpio_val);\n\n\tdprintk(\"gpio dir: %04x: gpio val: %04x\\n\", st->gpio_dir, st->gpio_val);\n\n\treturn 0;\n}\n\nint dib9000_set_gpio(struct dvb_frontend *fe, u8 num, u8 dir, u8 val)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\treturn dib9000_cfg_gpio(state, num, dir, val);\n}\nEXPORT_SYMBOL(dib9000_set_gpio);\n\nint dib9000_fw_pid_filter_ctrl(struct dvb_frontend *fe, u8 onoff)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu16 val;\n\tint ret;\n\n\tif ((state->pid_ctrl_index != -2) && (state->pid_ctrl_index < 9)) {\n\t\t \n\t\tdprintk(\"pid filter cmd postpone\\n\");\n\t\tstate->pid_ctrl_index++;\n\t\tstate->pid_ctrl[state->pid_ctrl_index].cmd = DIB9000_PID_FILTER_CTRL;\n\t\tstate->pid_ctrl[state->pid_ctrl_index].onoff = onoff;\n\t\treturn 0;\n\t}\n\n\tif (mutex_lock_interruptible(&state->demod_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -EINTR;\n\t}\n\n\tval = dib9000_read_word(state, 294 + 1) & 0xffef;\n\tval |= (onoff & 0x1) << 4;\n\n\tdprintk(\"PID filter enabled %d\\n\", onoff);\n\tret = dib9000_write_word(state, 294 + 1, val);\n\tmutex_unlock(&state->demod_lock);\n\treturn ret;\n\n}\nEXPORT_SYMBOL(dib9000_fw_pid_filter_ctrl);\n\nint dib9000_fw_pid_filter(struct dvb_frontend *fe, u8 id, u16 pid, u8 onoff)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tif (state->pid_ctrl_index != -2) {\n\t\t \n\t\tdprintk(\"pid filter postpone\\n\");\n\t\tif (state->pid_ctrl_index < 9) {\n\t\t\tstate->pid_ctrl_index++;\n\t\t\tstate->pid_ctrl[state->pid_ctrl_index].cmd = DIB9000_PID_FILTER;\n\t\t\tstate->pid_ctrl[state->pid_ctrl_index].id = id;\n\t\t\tstate->pid_ctrl[state->pid_ctrl_index].pid = pid;\n\t\t\tstate->pid_ctrl[state->pid_ctrl_index].onoff = onoff;\n\t\t} else\n\t\t\tdprintk(\"can not add any more pid ctrl cmd\\n\");\n\t\treturn 0;\n\t}\n\n\tif (mutex_lock_interruptible(&state->demod_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -EINTR;\n\t}\n\tdprintk(\"Index %x, PID %d, OnOff %d\\n\", id, pid, onoff);\n\tret = dib9000_write_word(state, 300 + 1 + id,\n\t\t\tonoff ? (1 << 13) | pid : 0);\n\tmutex_unlock(&state->demod_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(dib9000_fw_pid_filter);\n\nint dib9000_firmware_post_pll_init(struct dvb_frontend *fe)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\treturn dib9000_fw_init(state);\n}\nEXPORT_SYMBOL(dib9000_firmware_post_pll_init);\n\nstatic void dib9000_release(struct dvb_frontend *demod)\n{\n\tstruct dib9000_state *st = demod->demodulator_priv;\n\tu8 index_frontend;\n\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (st->fe[index_frontend] != NULL); index_frontend++)\n\t\tdvb_frontend_detach(st->fe[index_frontend]);\n\n\tdibx000_exit_i2c_master(&st->i2c_master);\n\n\ti2c_del_adapter(&st->tuner_adap);\n\ti2c_del_adapter(&st->component_bus);\n\tkfree(st->fe[0]);\n\tkfree(st);\n}\n\nstatic int dib9000_wakeup(struct dvb_frontend *fe)\n{\n\treturn 0;\n}\n\nstatic int dib9000_sleep(struct dvb_frontend *fe)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu8 index_frontend;\n\tint ret = 0;\n\n\tif (mutex_lock_interruptible(&state->demod_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -EINTR;\n\t}\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\tret = state->fe[index_frontend]->ops.sleep(state->fe[index_frontend]);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\tret = dib9000_mbx_send(state, OUT_MSG_FE_SLEEP, NULL, 0);\n\nerror:\n\tmutex_unlock(&state->demod_lock);\n\treturn ret;\n}\n\nstatic int dib9000_fe_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic int dib9000_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *c)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu8 index_frontend, sub_index_frontend;\n\tenum fe_status stat;\n\tint ret = 0;\n\n\tif (state->get_frontend_internal == 0) {\n\t\tif (mutex_lock_interruptible(&state->demod_lock) < 0) {\n\t\t\tdprintk(\"could not get the lock\\n\");\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\tstate->fe[index_frontend]->ops.read_status(state->fe[index_frontend], &stat);\n\t\tif (stat & FE_HAS_SYNC) {\n\t\t\tdprintk(\"TPS lock on the slave%i\\n\", index_frontend);\n\n\t\t\t \n\t\t\tstate->fe[index_frontend]->ops.get_frontend(state->fe[index_frontend], c);\n\t\t\tfor (sub_index_frontend = 0; (sub_index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[sub_index_frontend] != NULL);\n\t\t\t     sub_index_frontend++) {\n\t\t\t\tif (sub_index_frontend != index_frontend) {\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.modulation =\n\t\t\t\t\t    state->fe[index_frontend]->dtv_property_cache.modulation;\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.inversion =\n\t\t\t\t\t    state->fe[index_frontend]->dtv_property_cache.inversion;\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.transmission_mode =\n\t\t\t\t\t    state->fe[index_frontend]->dtv_property_cache.transmission_mode;\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.guard_interval =\n\t\t\t\t\t    state->fe[index_frontend]->dtv_property_cache.guard_interval;\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.hierarchy =\n\t\t\t\t\t    state->fe[index_frontend]->dtv_property_cache.hierarchy;\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.code_rate_HP =\n\t\t\t\t\t    state->fe[index_frontend]->dtv_property_cache.code_rate_HP;\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.code_rate_LP =\n\t\t\t\t\t    state->fe[index_frontend]->dtv_property_cache.code_rate_LP;\n\t\t\t\t\tstate->fe[sub_index_frontend]->dtv_property_cache.rolloff =\n\t\t\t\t\t    state->fe[index_frontend]->dtv_property_cache.rolloff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = 0;\n\t\t\tgoto return_value;\n\t\t}\n\t}\n\n\t \n\tret = dib9000_fw_get_channel(fe);\n\tif (ret != 0)\n\t\tgoto return_value;\n\n\t \n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\tstate->fe[index_frontend]->dtv_property_cache.inversion = c->inversion;\n\t\tstate->fe[index_frontend]->dtv_property_cache.transmission_mode = c->transmission_mode;\n\t\tstate->fe[index_frontend]->dtv_property_cache.guard_interval = c->guard_interval;\n\t\tstate->fe[index_frontend]->dtv_property_cache.modulation = c->modulation;\n\t\tstate->fe[index_frontend]->dtv_property_cache.hierarchy = c->hierarchy;\n\t\tstate->fe[index_frontend]->dtv_property_cache.code_rate_HP = c->code_rate_HP;\n\t\tstate->fe[index_frontend]->dtv_property_cache.code_rate_LP = c->code_rate_LP;\n\t\tstate->fe[index_frontend]->dtv_property_cache.rolloff = c->rolloff;\n\t}\n\tret = 0;\n\nreturn_value:\n\tif (state->get_frontend_internal == 0)\n\t\tmutex_unlock(&state->demod_lock);\n\treturn ret;\n}\n\nstatic int dib9000_set_tune_state(struct dvb_frontend *fe, enum frontend_tune_state tune_state)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tstate->tune_state = tune_state;\n\tif (tune_state == CT_DEMOD_START)\n\t\tstate->status = FE_STATUS_TUNE_PENDING;\n\n\treturn 0;\n}\n\nstatic u32 dib9000_get_status(struct dvb_frontend *fe)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\treturn state->status;\n}\n\nstatic int dib9000_set_channel_status(struct dvb_frontend *fe, struct dvb_frontend_parametersContext *channel_status)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\n\tmemcpy(&state->channel_status, channel_status, sizeof(struct dvb_frontend_parametersContext));\n\treturn 0;\n}\n\nstatic int dib9000_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tint sleep_time, sleep_time_slave;\n\tu32 frontend_status;\n\tu8 nbr_pending, exit_condition, index_frontend, index_frontend_success;\n\tstruct dvb_frontend_parametersContext channel_status;\n\n\t \n\tif (state->fe[0]->dtv_property_cache.frequency == 0) {\n\t\tdprintk(\"dib9000: must specify frequency\\n\");\n\t\treturn 0;\n\t}\n\n\tif (state->fe[0]->dtv_property_cache.bandwidth_hz == 0) {\n\t\tdprintk(\"dib9000: must specify bandwidth\\n\");\n\t\treturn 0;\n\t}\n\n\tstate->pid_ctrl_index = -1;  \n\tif (mutex_lock_interruptible(&state->demod_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn 0;\n\t}\n\n\tfe->dtv_property_cache.delivery_system = SYS_DVBT;\n\n\t \n\tif (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO ||\n\t    state->fe[0]->dtv_property_cache.guard_interval == GUARD_INTERVAL_AUTO ||\n\t    state->fe[0]->dtv_property_cache.modulation == QAM_AUTO ||\n\t    state->fe[0]->dtv_property_cache.code_rate_HP == FEC_AUTO) {\n\t\t \n\t\tstate->channel_status.status = CHANNEL_STATUS_PARAMETERS_UNKNOWN;\n\t} else\n\t\tstate->channel_status.status = CHANNEL_STATUS_PARAMETERS_SET;\n\n\t \n\tfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\tdib9000_fw_set_diversity_in(state->fe[index_frontend], 1);\n\n\t\t \n\t\tmemcpy(&state->fe[index_frontend]->dtv_property_cache, &fe->dtv_property_cache, sizeof(struct dtv_frontend_properties));\n\n\t\tstate->fe[index_frontend]->dtv_property_cache.delivery_system = SYS_DVBT;\n\t\tdib9000_fw_set_output_mode(state->fe[index_frontend], OUTMODE_HIGH_Z);\n\n\t\tdib9000_set_channel_status(state->fe[index_frontend], &state->channel_status);\n\t\tdib9000_set_tune_state(state->fe[index_frontend], CT_DEMOD_START);\n\t}\n\n\t \n\texit_condition = 0;\t \n\tindex_frontend_success = 0;\n\tdo {\n\t\tsleep_time = dib9000_fw_tune(state->fe[0]);\n\t\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\t\tsleep_time_slave = dib9000_fw_tune(state->fe[index_frontend]);\n\t\t\tif (sleep_time == FE_CALLBACK_TIME_NEVER)\n\t\t\t\tsleep_time = sleep_time_slave;\n\t\t\telse if ((sleep_time_slave != FE_CALLBACK_TIME_NEVER) && (sleep_time_slave > sleep_time))\n\t\t\t\tsleep_time = sleep_time_slave;\n\t\t}\n\t\tif (sleep_time != FE_CALLBACK_TIME_NEVER)\n\t\t\tmsleep(sleep_time / 10);\n\t\telse\n\t\t\tbreak;\n\n\t\tnbr_pending = 0;\n\t\texit_condition = 0;\n\t\tindex_frontend_success = 0;\n\t\tfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\t\tfrontend_status = -dib9000_get_status(state->fe[index_frontend]);\n\t\t\tif (frontend_status > -FE_STATUS_TUNE_PENDING) {\n\t\t\t\texit_condition = 2;\t \n\t\t\t\tindex_frontend_success = index_frontend;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (frontend_status == -FE_STATUS_TUNE_PENDING)\n\t\t\t\tnbr_pending++;\t \n\t\t}\n\t\tif ((exit_condition != 2) && (nbr_pending == 0))\n\t\t\texit_condition = 1;\t \n\n\t} while (exit_condition == 0);\n\n\t \n\tif (exit_condition == 1) {\t \n\t\tdprintk(\"tune failed\\n\");\n\t\tmutex_unlock(&state->demod_lock);\n\t\t \n\t\tstate->pid_ctrl_index = -1;\n\t\treturn 0;\n\t}\n\n\tdprintk(\"tune success on frontend%i\\n\", index_frontend_success);\n\n\t \n\tstate->get_frontend_internal = 1;\n\tdib9000_get_frontend(state->fe[0], &state->fe[0]->dtv_property_cache);\n\tstate->get_frontend_internal = 0;\n\n\t \n\tchannel_status.status = CHANNEL_STATUS_PARAMETERS_SET;\n\tfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\t \n\t\tif (index_frontend != index_frontend_success) {\n\t\t\tdib9000_set_channel_status(state->fe[index_frontend], &channel_status);\n\t\t\tdib9000_set_tune_state(state->fe[index_frontend], CT_DEMOD_START);\n\t\t}\n\t}\n\tdo {\n\t\tsleep_time = FE_CALLBACK_TIME_NEVER;\n\t\tfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\t\tif (index_frontend != index_frontend_success) {\n\t\t\t\tsleep_time_slave = dib9000_fw_tune(state->fe[index_frontend]);\n\t\t\t\tif (sleep_time == FE_CALLBACK_TIME_NEVER)\n\t\t\t\t\tsleep_time = sleep_time_slave;\n\t\t\t\telse if ((sleep_time_slave != FE_CALLBACK_TIME_NEVER) && (sleep_time_slave > sleep_time))\n\t\t\t\t\tsleep_time = sleep_time_slave;\n\t\t\t}\n\t\t}\n\t\tif (sleep_time != FE_CALLBACK_TIME_NEVER)\n\t\t\tmsleep(sleep_time / 10);\n\t\telse\n\t\t\tbreak;\n\n\t\tnbr_pending = 0;\n\t\tfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\t\tif (index_frontend != index_frontend_success) {\n\t\t\t\tfrontend_status = -dib9000_get_status(state->fe[index_frontend]);\n\t\t\t\tif ((index_frontend != index_frontend_success) && (frontend_status == -FE_STATUS_TUNE_PENDING))\n\t\t\t\t\tnbr_pending++;\t \n\t\t\t}\n\t\t}\n\t} while (nbr_pending != 0);\n\n\t \n\tdib9000_fw_set_output_mode(state->fe[0], state->chip.d9.cfg.output_mode);\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\n\t\tdib9000_fw_set_output_mode(state->fe[index_frontend], OUTMODE_DIVERSITY);\n\n\t \n\tdib9000_fw_set_diversity_in(state->fe[index_frontend - 1], 0);\n\n\tmutex_unlock(&state->demod_lock);\n\tif (state->pid_ctrl_index >= 0) {\n\t\tu8 index_pid_filter_cmd;\n\t\tu8 pid_ctrl_index = state->pid_ctrl_index;\n\n\t\tstate->pid_ctrl_index = -2;\n\t\tfor (index_pid_filter_cmd = 0;\n\t\t\t\tindex_pid_filter_cmd <= pid_ctrl_index;\n\t\t\t\tindex_pid_filter_cmd++) {\n\t\t\tif (state->pid_ctrl[index_pid_filter_cmd].cmd == DIB9000_PID_FILTER_CTRL)\n\t\t\t\tdib9000_fw_pid_filter_ctrl(state->fe[0],\n\t\t\t\t\t\tstate->pid_ctrl[index_pid_filter_cmd].onoff);\n\t\t\telse if (state->pid_ctrl[index_pid_filter_cmd].cmd == DIB9000_PID_FILTER)\n\t\t\t\tdib9000_fw_pid_filter(state->fe[0],\n\t\t\t\t\t\tstate->pid_ctrl[index_pid_filter_cmd].id,\n\t\t\t\t\t\tstate->pid_ctrl[index_pid_filter_cmd].pid,\n\t\t\t\t\t\tstate->pid_ctrl[index_pid_filter_cmd].onoff);\n\t\t}\n\t}\n\t \n\tstate->pid_ctrl_index = -2;\n\n\treturn 0;\n}\n\nstatic u16 dib9000_read_lock(struct dvb_frontend *fe)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\n\treturn dib9000_read_word(state, 535);\n}\n\nstatic int dib9000_read_status(struct dvb_frontend *fe, enum fe_status *stat)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu8 index_frontend;\n\tu16 lock = 0, lock_slave = 0;\n\n\tif (mutex_lock_interruptible(&state->demod_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -EINTR;\n\t}\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\n\t\tlock_slave |= dib9000_read_lock(state->fe[index_frontend]);\n\n\tlock = dib9000_read_word(state, 535);\n\n\t*stat = 0;\n\n\tif ((lock & 0x8000) || (lock_slave & 0x8000))\n\t\t*stat |= FE_HAS_SIGNAL;\n\tif ((lock & 0x3000) || (lock_slave & 0x3000))\n\t\t*stat |= FE_HAS_CARRIER;\n\tif ((lock & 0x0100) || (lock_slave & 0x0100))\n\t\t*stat |= FE_HAS_VITERBI;\n\tif (((lock & 0x0038) == 0x38) || ((lock_slave & 0x0038) == 0x38))\n\t\t*stat |= FE_HAS_SYNC;\n\tif ((lock & 0x0008) || (lock_slave & 0x0008))\n\t\t*stat |= FE_HAS_LOCK;\n\n\tmutex_unlock(&state->demod_lock);\n\n\treturn 0;\n}\n\nstatic int dib9000_read_ber(struct dvb_frontend *fe, u32 * ber)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu16 *c;\n\tint ret = 0;\n\n\tif (mutex_lock_interruptible(&state->demod_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -EINTR;\n\t}\n\tif (mutex_lock_interruptible(&state->platform.risc.mem_mbx_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\tret = -EINTR;\n\t\tgoto error;\n\t}\n\tif (dib9000_fw_memmbx_sync(state, FE_SYNC_CHANNEL) < 0) {\n\t\tmutex_unlock(&state->platform.risc.mem_mbx_lock);\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\tdib9000_risc_mem_read(state, FE_MM_R_FE_MONITOR,\n\t\t\tstate->i2c_read_buffer, 16 * 2);\n\tmutex_unlock(&state->platform.risc.mem_mbx_lock);\n\n\tc = (u16 *)state->i2c_read_buffer;\n\n\t*ber = c[10] << 16 | c[11];\n\nerror:\n\tmutex_unlock(&state->demod_lock);\n\treturn ret;\n}\n\nstatic int dib9000_read_signal_strength(struct dvb_frontend *fe, u16 * strength)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu8 index_frontend;\n\tu16 *c = (u16 *)state->i2c_read_buffer;\n\tu16 val;\n\tint ret = 0;\n\n\tif (mutex_lock_interruptible(&state->demod_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -EINTR;\n\t}\n\t*strength = 0;\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\n\t\tstate->fe[index_frontend]->ops.read_signal_strength(state->fe[index_frontend], &val);\n\t\tif (val > 65535 - *strength)\n\t\t\t*strength = 65535;\n\t\telse\n\t\t\t*strength += val;\n\t}\n\n\tif (mutex_lock_interruptible(&state->platform.risc.mem_mbx_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\tret = -EINTR;\n\t\tgoto error;\n\t}\n\tif (dib9000_fw_memmbx_sync(state, FE_SYNC_CHANNEL) < 0) {\n\t\tmutex_unlock(&state->platform.risc.mem_mbx_lock);\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\tdib9000_risc_mem_read(state, FE_MM_R_FE_MONITOR, (u8 *) c, 16 * 2);\n\tmutex_unlock(&state->platform.risc.mem_mbx_lock);\n\n\tval = 65535 - c[4];\n\tif (val > 65535 - *strength)\n\t\t*strength = 65535;\n\telse\n\t\t*strength += val;\n\nerror:\n\tmutex_unlock(&state->demod_lock);\n\treturn ret;\n}\n\nstatic u32 dib9000_get_snr(struct dvb_frontend *fe)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu16 *c = (u16 *)state->i2c_read_buffer;\n\tu32 n, s, exp;\n\tu16 val;\n\n\tif (mutex_lock_interruptible(&state->platform.risc.mem_mbx_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn 0;\n\t}\n\tif (dib9000_fw_memmbx_sync(state, FE_SYNC_CHANNEL) < 0) {\n\t\tmutex_unlock(&state->platform.risc.mem_mbx_lock);\n\t\treturn 0;\n\t}\n\tdib9000_risc_mem_read(state, FE_MM_R_FE_MONITOR, (u8 *) c, 16 * 2);\n\tmutex_unlock(&state->platform.risc.mem_mbx_lock);\n\n\tval = c[7];\n\tn = (val >> 4) & 0xff;\n\texp = ((val & 0xf) << 2);\n\tval = c[8];\n\texp += ((val >> 14) & 0x3);\n\tif ((exp & 0x20) != 0)\n\t\texp -= 0x40;\n\tn <<= exp + 16;\n\n\ts = (val >> 6) & 0xFF;\n\texp = (val & 0x3F);\n\tif ((exp & 0x20) != 0)\n\t\texp -= 0x40;\n\ts <<= exp + 16;\n\n\tif (n > 0) {\n\t\tu32 t = (s / n) << 16;\n\t\treturn t + ((s << 16) - n * t) / n;\n\t}\n\treturn 0xffffffff;\n}\n\nstatic int dib9000_read_snr(struct dvb_frontend *fe, u16 * snr)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu8 index_frontend;\n\tu32 snr_master;\n\n\tif (mutex_lock_interruptible(&state->demod_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -EINTR;\n\t}\n\tsnr_master = dib9000_get_snr(fe);\n\tfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\n\t\tsnr_master += dib9000_get_snr(state->fe[index_frontend]);\n\n\tif ((snr_master >> 16) != 0) {\n\t\tsnr_master = 10 * intlog10(snr_master >> 16);\n\t\t*snr = snr_master / ((1 << 24) / 10);\n\t} else\n\t\t*snr = 0;\n\n\tmutex_unlock(&state->demod_lock);\n\n\treturn 0;\n}\n\nstatic int dib9000_read_unc_blocks(struct dvb_frontend *fe, u32 * unc)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu16 *c = (u16 *)state->i2c_read_buffer;\n\tint ret = 0;\n\n\tif (mutex_lock_interruptible(&state->demod_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\treturn -EINTR;\n\t}\n\tif (mutex_lock_interruptible(&state->platform.risc.mem_mbx_lock) < 0) {\n\t\tdprintk(\"could not get the lock\\n\");\n\t\tret = -EINTR;\n\t\tgoto error;\n\t}\n\tif (dib9000_fw_memmbx_sync(state, FE_SYNC_CHANNEL) < 0) {\n\t\tmutex_unlock(&state->platform.risc.mem_mbx_lock);\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\tdib9000_risc_mem_read(state, FE_MM_R_FE_MONITOR, (u8 *) c, 16 * 2);\n\tmutex_unlock(&state->platform.risc.mem_mbx_lock);\n\n\t*unc = c[12];\n\nerror:\n\tmutex_unlock(&state->demod_lock);\n\treturn ret;\n}\n\nint dib9000_i2c_enumeration(struct i2c_adapter *i2c, int no_of_demods, u8 default_addr, u8 first_addr)\n{\n\tint k = 0, ret = 0;\n\tu8 new_addr = 0;\n\tstruct i2c_device client = {.i2c_adap = i2c };\n\n\tclient.i2c_write_buffer = kzalloc(4, GFP_KERNEL);\n\tif (!client.i2c_write_buffer) {\n\t\tdprintk(\"%s: not enough memory\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tclient.i2c_read_buffer = kzalloc(4, GFP_KERNEL);\n\tif (!client.i2c_read_buffer) {\n\t\tdprintk(\"%s: not enough memory\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto error_memory;\n\t}\n\n\tclient.i2c_addr = default_addr + 16;\n\tdib9000_i2c_write16(&client, 1796, 0x0);\n\n\tfor (k = no_of_demods - 1; k >= 0; k--) {\n\t\t \n\t\tnew_addr = first_addr + (k << 1);\n\t\tclient.i2c_addr = default_addr;\n\n\t\tdib9000_i2c_write16(&client, 1817, 3);\n\t\tdib9000_i2c_write16(&client, 1796, 0);\n\t\tdib9000_i2c_write16(&client, 1227, 1);\n\t\tdib9000_i2c_write16(&client, 1227, 0);\n\n\t\tclient.i2c_addr = new_addr;\n\t\tdib9000_i2c_write16(&client, 1817, 3);\n\t\tdib9000_i2c_write16(&client, 1796, 0);\n\t\tdib9000_i2c_write16(&client, 1227, 1);\n\t\tdib9000_i2c_write16(&client, 1227, 0);\n\n\t\tif (dib9000_identify(&client) == 0) {\n\t\t\tclient.i2c_addr = default_addr;\n\t\t\tif (dib9000_identify(&client) == 0) {\n\t\t\t\tdprintk(\"DiB9000 #%d: not identified\\n\", k);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tdib9000_i2c_write16(&client, 1795, (1 << 10) | (4 << 6));\n\t\tdib9000_i2c_write16(&client, 1794, (new_addr << 2) | 2);\n\n\t\tdprintk(\"IC %d initialized (to i2c_address 0x%x)\\n\", k, new_addr);\n\t}\n\n\tfor (k = 0; k < no_of_demods; k++) {\n\t\tnew_addr = first_addr | (k << 1);\n\t\tclient.i2c_addr = new_addr;\n\n\t\tdib9000_i2c_write16(&client, 1794, (new_addr << 2));\n\t\tdib9000_i2c_write16(&client, 1795, 0);\n\t}\n\nerror:\n\tkfree(client.i2c_read_buffer);\nerror_memory:\n\tkfree(client.i2c_write_buffer);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dib9000_i2c_enumeration);\n\nint dib9000_set_slave_frontend(struct dvb_frontend *fe, struct dvb_frontend *fe_slave)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\tu8 index_frontend = 1;\n\n\twhile ((index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL))\n\t\tindex_frontend++;\n\tif (index_frontend < MAX_NUMBER_OF_FRONTENDS) {\n\t\tdprintk(\"set slave fe %p to index %i\\n\", fe_slave, index_frontend);\n\t\tstate->fe[index_frontend] = fe_slave;\n\t\treturn 0;\n\t}\n\n\tdprintk(\"too many slave frontend\\n\");\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(dib9000_set_slave_frontend);\n\nstruct dvb_frontend *dib9000_get_slave_frontend(struct dvb_frontend *fe, int slave_index)\n{\n\tstruct dib9000_state *state = fe->demodulator_priv;\n\n\tif (slave_index >= MAX_NUMBER_OF_FRONTENDS)\n\t\treturn NULL;\n\treturn state->fe[slave_index];\n}\nEXPORT_SYMBOL(dib9000_get_slave_frontend);\n\nstatic const struct dvb_frontend_ops dib9000_ops;\nstruct dvb_frontend *dib9000_attach(struct i2c_adapter *i2c_adap, u8 i2c_addr, const struct dib9000_config *cfg)\n{\n\tstruct dvb_frontend *fe;\n\tstruct dib9000_state *st;\n\tst = kzalloc(sizeof(struct dib9000_state), GFP_KERNEL);\n\tif (st == NULL)\n\t\treturn NULL;\n\tfe = kzalloc(sizeof(struct dvb_frontend), GFP_KERNEL);\n\tif (fe == NULL) {\n\t\tkfree(st);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(&st->chip.d9.cfg, cfg, sizeof(struct dib9000_config));\n\tst->i2c.i2c_adap = i2c_adap;\n\tst->i2c.i2c_addr = i2c_addr;\n\tst->i2c.i2c_write_buffer = st->i2c_write_buffer;\n\tst->i2c.i2c_read_buffer = st->i2c_read_buffer;\n\n\tst->gpio_dir = DIB9000_GPIO_DEFAULT_DIRECTIONS;\n\tst->gpio_val = DIB9000_GPIO_DEFAULT_VALUES;\n\tst->gpio_pwm_pos = DIB9000_GPIO_DEFAULT_PWM_POS;\n\n\tmutex_init(&st->platform.risc.mbx_if_lock);\n\tmutex_init(&st->platform.risc.mbx_lock);\n\tmutex_init(&st->platform.risc.mem_lock);\n\tmutex_init(&st->platform.risc.mem_mbx_lock);\n\tmutex_init(&st->demod_lock);\n\tst->get_frontend_internal = 0;\n\n\tst->pid_ctrl_index = -2;\n\n\tst->fe[0] = fe;\n\tfe->demodulator_priv = st;\n\tmemcpy(&st->fe[0]->ops, &dib9000_ops, sizeof(struct dvb_frontend_ops));\n\n\t \n\tif ((st->chip.d9.cfg.output_mode != OUTMODE_MPEG2_SERIAL) && (st->chip.d9.cfg.output_mode != OUTMODE_MPEG2_PAR_GATED_CLK))\n\t\tst->chip.d9.cfg.output_mode = OUTMODE_MPEG2_FIFO;\n\n\tif (dib9000_identify(&st->i2c) == 0)\n\t\tgoto error;\n\n\tdibx000_init_i2c_master(&st->i2c_master, DIB7000MC, st->i2c.i2c_adap, st->i2c.i2c_addr);\n\n\tst->tuner_adap.dev.parent = i2c_adap->dev.parent;\n\tstrscpy(st->tuner_adap.name, \"DIB9000_FW TUNER ACCESS\",\n\t\tsizeof(st->tuner_adap.name));\n\tst->tuner_adap.algo = &dib9000_tuner_algo;\n\tst->tuner_adap.algo_data = NULL;\n\ti2c_set_adapdata(&st->tuner_adap, st);\n\tif (i2c_add_adapter(&st->tuner_adap) < 0)\n\t\tgoto error;\n\n\tst->component_bus.dev.parent = i2c_adap->dev.parent;\n\tstrscpy(st->component_bus.name, \"DIB9000_FW COMPONENT BUS ACCESS\",\n\t\tsizeof(st->component_bus.name));\n\tst->component_bus.algo = &dib9000_component_bus_algo;\n\tst->component_bus.algo_data = NULL;\n\tst->component_bus_speed = 340;\n\ti2c_set_adapdata(&st->component_bus, st);\n\tif (i2c_add_adapter(&st->component_bus) < 0)\n\t\tgoto component_bus_add_error;\n\n\tdib9000_fw_reset(fe);\n\n\treturn fe;\n\ncomponent_bus_add_error:\n\ti2c_del_adapter(&st->tuner_adap);\nerror:\n\tkfree(st);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(dib9000_attach);\n\nstatic const struct dvb_frontend_ops dib9000_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t .name = \"DiBcom 9000\",\n\t\t .frequency_min_hz =  44250 * kHz,\n\t\t .frequency_max_hz = 867250 * kHz,\n\t\t .frequency_stepsize_hz = 62500,\n\t\t .caps = FE_CAN_INVERSION_AUTO |\n\t\t FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_RECOVER | FE_CAN_HIERARCHY_AUTO,\n\t\t },\n\n\t.release = dib9000_release,\n\n\t.init = dib9000_wakeup,\n\t.sleep = dib9000_sleep,\n\n\t.set_frontend = dib9000_set_frontend,\n\t.get_tune_settings = dib9000_fe_get_tune_settings,\n\t.get_frontend = dib9000_get_frontend,\n\n\t.read_status = dib9000_read_status,\n\t.read_ber = dib9000_read_ber,\n\t.read_signal_strength = dib9000_read_signal_strength,\n\t.read_snr = dib9000_read_snr,\n\t.read_ucblocks = dib9000_read_unc_blocks,\n};\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_AUTHOR(\"Olivier Grenie <olivier.grenie@parrot.com>\");\nMODULE_DESCRIPTION(\"Driver for the DiBcom 9000 COFDM demodulator\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}