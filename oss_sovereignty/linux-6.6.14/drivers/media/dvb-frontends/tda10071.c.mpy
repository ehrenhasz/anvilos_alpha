{
  "module_name": "tda10071.c",
  "hash_id": "07731d78abd339a2a3472c8ffda1222bd9f20a88ef4ea6c1f796eec125f33025",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tda10071.c",
  "human_readable_source": "\n \n\n#include \"tda10071_priv.h\"\n\nstatic const struct dvb_frontend_ops tda10071_ops;\n\n \n \nstatic int tda10071_wr_reg_mask(struct tda10071_dev *dev,\n\t\t\t\tu8 reg, u8 val, u8 mask)\n{\n\tint ret;\n\tu8 tmp;\n\n\t \n\tif (mask != 0xff) {\n\t\tret = regmap_bulk_read(dev->regmap, reg, &tmp, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval &= mask;\n\t\ttmp &= ~mask;\n\t\tval |= tmp;\n\t}\n\n\treturn regmap_bulk_write(dev->regmap, reg, &val, 1);\n}\n\n \nstatic int tda10071_cmd_execute(struct tda10071_dev *dev,\n\tstruct tda10071_cmd *cmd)\n{\n\tstruct i2c_client *client = dev->client;\n\tint ret, i;\n\tunsigned int uitmp;\n\n\tif (!dev->warm) {\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tmutex_lock(&dev->cmd_execute_mutex);\n\n\t \n\tret = regmap_bulk_write(dev->regmap, 0x00, cmd->args, cmd->len);\n\tif (ret)\n\t\tgoto error_mutex_unlock;\n\n\t \n\tret = regmap_write(dev->regmap, 0x1f, 1);\n\tif (ret)\n\t\tgoto error_mutex_unlock;\n\n\t \n\tfor (i = 1000, uitmp = 1; i && uitmp; i--) {\n\t\tret = regmap_read(dev->regmap, 0x1f, &uitmp);\n\t\tif (ret)\n\t\t\tgoto error_mutex_unlock;\n\n\t\tusleep_range(200, 5000);\n\t}\n\n\tmutex_unlock(&dev->cmd_execute_mutex);\n\tdev_dbg(&client->dev, \"loop=%d\\n\", i);\n\n\tif (i == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\treturn ret;\nerror_mutex_unlock:\n\tmutex_unlock(&dev->cmd_execute_mutex);\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tda10071_set_tone(struct dvb_frontend *fe,\n\tenum fe_sec_tone_mode fe_sec_tone_mode)\n{\n\tstruct tda10071_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct tda10071_cmd cmd;\n\tint ret;\n\tu8 tone;\n\n\tif (!dev->warm) {\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tdev_dbg(&client->dev, \"tone_mode=%d\\n\", fe_sec_tone_mode);\n\n\tswitch (fe_sec_tone_mode) {\n\tcase SEC_TONE_ON:\n\t\ttone = 1;\n\t\tbreak;\n\tcase SEC_TONE_OFF:\n\t\ttone = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid fe_sec_tone_mode\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tcmd.args[0] = CMD_LNB_PCB_CONFIG;\n\tcmd.args[1] = 0;\n\tcmd.args[2] = 0x00;\n\tcmd.args[3] = 0x00;\n\tcmd.args[4] = tone;\n\tcmd.len = 5;\n\tret = tda10071_cmd_execute(dev, &cmd);\n\tif (ret)\n\t\tgoto error;\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tda10071_set_voltage(struct dvb_frontend *fe,\n\tenum fe_sec_voltage fe_sec_voltage)\n{\n\tstruct tda10071_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct tda10071_cmd cmd;\n\tint ret;\n\tu8 voltage;\n\n\tif (!dev->warm) {\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tdev_dbg(&client->dev, \"voltage=%d\\n\", fe_sec_voltage);\n\n\tswitch (fe_sec_voltage) {\n\tcase SEC_VOLTAGE_13:\n\t\tvoltage = 0;\n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\n\t\tvoltage = 1;\n\t\tbreak;\n\tcase SEC_VOLTAGE_OFF:\n\t\tvoltage = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid fe_sec_voltage\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tcmd.args[0] = CMD_LNB_SET_DC_LEVEL;\n\tcmd.args[1] = 0;\n\tcmd.args[2] = voltage;\n\tcmd.len = 3;\n\tret = tda10071_cmd_execute(dev, &cmd);\n\tif (ret)\n\t\tgoto error;\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tda10071_diseqc_send_master_cmd(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *diseqc_cmd)\n{\n\tstruct tda10071_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct tda10071_cmd cmd;\n\tint ret, i;\n\tunsigned int uitmp;\n\n\tif (!dev->warm) {\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tdev_dbg(&client->dev, \"msg_len=%d\\n\", diseqc_cmd->msg_len);\n\n\tif (diseqc_cmd->msg_len < 3 || diseqc_cmd->msg_len > 6) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tfor (i = 500, uitmp = 0; i && !uitmp; i--) {\n\t\tret = regmap_read(dev->regmap, 0x47, &uitmp);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tuitmp = (uitmp >> 0) & 1;\n\t\tusleep_range(10000, 20000);\n\t}\n\n\tdev_dbg(&client->dev, \"loop=%d\\n\", i);\n\n\tif (i == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\tret = regmap_update_bits(dev->regmap, 0x47, 0x01, 0x00);\n\tif (ret)\n\t\tgoto error;\n\n\tcmd.args[0] = CMD_LNB_SEND_DISEQC;\n\tcmd.args[1] = 0;\n\tcmd.args[2] = 0;\n\tcmd.args[3] = 0;\n\tcmd.args[4] = 2;\n\tcmd.args[5] = 0;\n\tcmd.args[6] = diseqc_cmd->msg_len;\n\tmemcpy(&cmd.args[7], diseqc_cmd->msg, diseqc_cmd->msg_len);\n\tcmd.len = 7 + diseqc_cmd->msg_len;\n\tret = tda10071_cmd_execute(dev, &cmd);\n\tif (ret)\n\t\tgoto error;\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tda10071_diseqc_recv_slave_reply(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_slave_reply *reply)\n{\n\tstruct tda10071_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct tda10071_cmd cmd;\n\tint ret, i;\n\tunsigned int uitmp;\n\n\tif (!dev->warm) {\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tfor (i = 500, uitmp = 0; i && !uitmp; i--) {\n\t\tret = regmap_read(dev->regmap, 0x47, &uitmp);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tuitmp = (uitmp >> 1) & 1;\n\t\tusleep_range(10000, 20000);\n\t}\n\n\tdev_dbg(&client->dev, \"loop=%d\\n\", i);\n\n\tif (i == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\t \n\tret = regmap_read(dev->regmap, 0x46, &uitmp);\n\tif (ret)\n\t\tgoto error;\n\n\treply->msg_len = uitmp & 0x1f;  \n\tif (reply->msg_len > sizeof(reply->msg))\n\t\treply->msg_len = sizeof(reply->msg);  \n\n\t \n\tcmd.args[0] = CMD_LNB_UPDATE_REPLY;\n\tcmd.args[1] = 0;\n\tcmd.len = 2;\n\tret = tda10071_cmd_execute(dev, &cmd);\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_bulk_read(dev->regmap, cmd.len, reply->msg,\n\t\t\t       reply->msg_len);\n\tif (ret)\n\t\tgoto error;\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tda10071_diseqc_send_burst(struct dvb_frontend *fe,\n\tenum fe_sec_mini_cmd fe_sec_mini_cmd)\n{\n\tstruct tda10071_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct tda10071_cmd cmd;\n\tint ret, i;\n\tunsigned int uitmp;\n\tu8 burst;\n\n\tif (!dev->warm) {\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tdev_dbg(&client->dev, \"fe_sec_mini_cmd=%d\\n\", fe_sec_mini_cmd);\n\n\tswitch (fe_sec_mini_cmd) {\n\tcase SEC_MINI_A:\n\t\tburst = 0;\n\t\tbreak;\n\tcase SEC_MINI_B:\n\t\tburst = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid fe_sec_mini_cmd\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tfor (i = 500, uitmp = 0; i && !uitmp; i--) {\n\t\tret = regmap_read(dev->regmap, 0x47, &uitmp);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tuitmp = (uitmp >> 0) & 1;\n\t\tusleep_range(10000, 20000);\n\t}\n\n\tdev_dbg(&client->dev, \"loop=%d\\n\", i);\n\n\tif (i == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\tret = regmap_update_bits(dev->regmap, 0x47, 0x01, 0x00);\n\tif (ret)\n\t\tgoto error;\n\n\tcmd.args[0] = CMD_LNB_SEND_TONEBURST;\n\tcmd.args[1] = 0;\n\tcmd.args[2] = burst;\n\tcmd.len = 3;\n\tret = tda10071_cmd_execute(dev, &cmd);\n\tif (ret)\n\t\tgoto error;\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tda10071_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct tda10071_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct tda10071_cmd cmd;\n\tint ret;\n\tunsigned int uitmp;\n\tu8 buf[8];\n\n\t*status = 0;\n\n\tif (!dev->warm) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tret = regmap_read(dev->regmap, 0x39, &uitmp);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tif (uitmp & 0x02)  \n\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\tif (uitmp & 0x04)  \n\t\t*status |= FE_HAS_VITERBI;\n\tif (uitmp & 0x08)  \n\t\t*status |= FE_HAS_SYNC | FE_HAS_LOCK;\n\n\tdev->fe_status = *status;\n\n\t \n\tif (dev->fe_status & FE_HAS_SIGNAL) {\n\t\tcmd.args[0] = CMD_GET_AGCACC;\n\t\tcmd.args[1] = 0;\n\t\tcmd.len = 2;\n\t\tret = tda10071_cmd_execute(dev, &cmd);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tret = regmap_read(dev->regmap, 0x50, &uitmp);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->strength.stat[0].svalue = (int) (uitmp - 256) * 1000;\n\t} else {\n\t\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (dev->fe_status & FE_HAS_VITERBI) {\n\t\t \n\t\tret = regmap_bulk_read(dev->regmap, 0x3a, buf, 2);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[0].svalue = (buf[0] << 8 | buf[1] << 0) * 100;\n\t} else {\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (dev->fe_status & FE_HAS_LOCK) {\n\t\t \n\t\tu8 delivery_system, reg, len;\n\n\t\tswitch (dev->delivery_system) {\n\t\tcase SYS_DVBS:\n\t\t\treg = 0x4c;\n\t\t\tlen = 8;\n\t\t\tdelivery_system = 1;\n\t\t\tbreak;\n\t\tcase SYS_DVBS2:\n\t\t\treg = 0x4d;\n\t\t\tlen = 4;\n\t\t\tdelivery_system = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = regmap_read(dev->regmap, reg, &uitmp);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (dev->meas_count == uitmp) {\n\t\t\tdev_dbg(&client->dev, \"meas not ready=%02x\\n\", uitmp);\n\t\t\tret = 0;\n\t\t\tgoto error;\n\t\t} else {\n\t\t\tdev->meas_count = uitmp;\n\t\t}\n\n\t\tcmd.args[0] = CMD_BER_UPDATE_COUNTERS;\n\t\tcmd.args[1] = 0;\n\t\tcmd.args[2] = delivery_system;\n\t\tcmd.len = 3;\n\t\tret = tda10071_cmd_execute(dev, &cmd);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tret = regmap_bulk_read(dev->regmap, cmd.len, buf, len);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (dev->delivery_system == SYS_DVBS) {\n\t\t\tu32 bit_error = buf[0] << 24 | buf[1] << 16 |\n\t\t\t\t\tbuf[2] << 8 | buf[3] << 0;\n\n\t\t\tdev->dvbv3_ber = bit_error;\n\t\t\tdev->post_bit_error += bit_error;\n\t\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\n\t\t\tdev->block_error += buf[4] << 8 | buf[5] << 0;\n\t\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->block_error.stat[0].uvalue = dev->block_error;\n\t\t} else {\n\t\t\tdev->dvbv3_ber = buf[0] << 8 | buf[1] << 0;\n\t\t\tdev->post_bit_error += buf[0] << 8 | buf[1] << 0;\n\t\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\n\t\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t}\n\t} else {\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tda10071_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL)\n\t\t*snr = div_s64(c->cnr.stat[0].svalue, 100);\n\telse\n\t\t*snr = 0;\n\treturn 0;\n}\n\nstatic int tda10071_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tunsigned int uitmp;\n\n\tif (c->strength.stat[0].scale == FE_SCALE_DECIBEL) {\n\t\tuitmp = div_s64(c->strength.stat[0].svalue, 1000) + 256;\n\t\tuitmp = clamp(uitmp, 181U, 236U);  \n\t\t \n\t\t*strength = (uitmp-181) * 0xffff / (236-181);\n\t} else {\n\t\t*strength = 0;\n\t}\n\treturn 0;\n}\n\nstatic int tda10071_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct tda10071_dev *dev = fe->demodulator_priv;\n\n\t*ber = dev->dvbv3_ber;\n\treturn 0;\n}\n\nstatic int tda10071_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->block_error.stat[0].scale == FE_SCALE_COUNTER)\n\t\t*ucblocks = c->block_error.stat[0].uvalue;\n\telse\n\t\t*ucblocks = 0;\n\treturn 0;\n}\n\nstatic int tda10071_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct tda10071_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct tda10071_cmd cmd;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i;\n\tu8 mode, rolloff, pilot, inversion, div;\n\tenum fe_modulation modulation;\n\n\tdev_dbg(&client->dev,\n\t\t\"delivery_system=%d modulation=%d frequency=%u symbol_rate=%d inversion=%d pilot=%d rolloff=%d\\n\",\n\t\tc->delivery_system, c->modulation, c->frequency, c->symbol_rate,\n\t\tc->inversion, c->pilot, c->rolloff);\n\n\tdev->delivery_system = SYS_UNDEFINED;\n\n\tif (!dev->warm) {\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tswitch (c->inversion) {\n\tcase INVERSION_OFF:\n\t\tinversion = 1;\n\t\tbreak;\n\tcase INVERSION_ON:\n\t\tinversion = 0;\n\t\tbreak;\n\tcase INVERSION_AUTO:\n\t\t \n\t\tinversion = 3;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid inversion\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\tmodulation = QPSK;\n\t\trolloff = 0;\n\t\tpilot = 2;\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tmodulation = c->modulation;\n\n\t\tswitch (c->rolloff) {\n\t\tcase ROLLOFF_20:\n\t\t\trolloff = 2;\n\t\t\tbreak;\n\t\tcase ROLLOFF_25:\n\t\t\trolloff = 1;\n\t\t\tbreak;\n\t\tcase ROLLOFF_35:\n\t\t\trolloff = 0;\n\t\t\tbreak;\n\t\tcase ROLLOFF_AUTO:\n\t\tdefault:\n\t\t\tdev_dbg(&client->dev, \"invalid rolloff\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tswitch (c->pilot) {\n\t\tcase PILOT_OFF:\n\t\t\tpilot = 0;\n\t\t\tbreak;\n\t\tcase PILOT_ON:\n\t\t\tpilot = 1;\n\t\t\tbreak;\n\t\tcase PILOT_AUTO:\n\t\t\tpilot = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&client->dev, \"invalid pilot\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid delivery_system\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tfor (i = 0, mode = 0xff; i < ARRAY_SIZE(TDA10071_MODCOD); i++) {\n\t\tif (c->delivery_system == TDA10071_MODCOD[i].delivery_system &&\n\t\t\tmodulation == TDA10071_MODCOD[i].modulation &&\n\t\t\tc->fec_inner == TDA10071_MODCOD[i].fec) {\n\t\t\tmode = TDA10071_MODCOD[i].val;\n\t\t\tdev_dbg(&client->dev, \"mode found=%02x\\n\", mode);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (mode == 0xff) {\n\t\tdev_dbg(&client->dev, \"invalid parameter combination\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (c->symbol_rate <= 5000000)\n\t\tdiv = 14;\n\telse\n\t\tdiv = 4;\n\n\tret = regmap_write(dev->regmap, 0x81, div);\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_write(dev->regmap, 0xe3, div);\n\tif (ret)\n\t\tgoto error;\n\n\tcmd.args[0] = CMD_CHANGE_CHANNEL;\n\tcmd.args[1] = 0;\n\tcmd.args[2] = mode;\n\tcmd.args[3] = (c->frequency >> 16) & 0xff;\n\tcmd.args[4] = (c->frequency >>  8) & 0xff;\n\tcmd.args[5] = (c->frequency >>  0) & 0xff;\n\tcmd.args[6] = ((c->symbol_rate / 1000) >> 8) & 0xff;\n\tcmd.args[7] = ((c->symbol_rate / 1000) >> 0) & 0xff;\n\tcmd.args[8] = ((tda10071_ops.info.frequency_tolerance_hz / 1000) >> 8) & 0xff;\n\tcmd.args[9] = ((tda10071_ops.info.frequency_tolerance_hz / 1000) >> 0) & 0xff;\n\tcmd.args[10] = rolloff;\n\tcmd.args[11] = inversion;\n\tcmd.args[12] = pilot;\n\tcmd.args[13] = 0x00;\n\tcmd.args[14] = 0x00;\n\tcmd.len = 15;\n\tret = tda10071_cmd_execute(dev, &cmd);\n\tif (ret)\n\t\tgoto error;\n\n\tdev->delivery_system = c->delivery_system;\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tda10071_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t struct dtv_frontend_properties *c)\n{\n\tstruct tda10071_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret, i;\n\tu8 buf[5], tmp;\n\n\tif (!dev->warm || !(dev->fe_status & FE_HAS_LOCK)) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tret = regmap_bulk_read(dev->regmap, 0x30, buf, 5);\n\tif (ret)\n\t\tgoto error;\n\n\ttmp = buf[0] & 0x3f;\n\tfor (i = 0; i < ARRAY_SIZE(TDA10071_MODCOD); i++) {\n\t\tif (tmp == TDA10071_MODCOD[i].val) {\n\t\t\tc->modulation = TDA10071_MODCOD[i].modulation;\n\t\t\tc->fec_inner = TDA10071_MODCOD[i].fec;\n\t\t\tc->delivery_system = TDA10071_MODCOD[i].delivery_system;\n\t\t}\n\t}\n\n\tswitch ((buf[1] >> 0) & 0x01) {\n\tcase 0:\n\t\tc->inversion = INVERSION_ON;\n\t\tbreak;\n\tcase 1:\n\t\tc->inversion = INVERSION_OFF;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[1] >> 7) & 0x01) {\n\tcase 0:\n\t\tc->pilot = PILOT_OFF;\n\t\tbreak;\n\tcase 1:\n\t\tc->pilot = PILOT_ON;\n\t\tbreak;\n\t}\n\n\tc->frequency = (buf[2] << 16) | (buf[3] << 8) | (buf[4] << 0);\n\n\tret = regmap_bulk_read(dev->regmap, 0x52, buf, 3);\n\tif (ret)\n\t\tgoto error;\n\n\tc->symbol_rate = ((buf[0] << 16) | (buf[1] << 8) | (buf[2] << 0)) * 1000;\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tda10071_init(struct dvb_frontend *fe)\n{\n\tstruct tda10071_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct tda10071_cmd cmd;\n\tint ret, i, len, remaining, fw_size;\n\tunsigned int uitmp;\n\tconst struct firmware *fw;\n\tu8 *fw_file = TDA10071_FIRMWARE;\n\tu8 tmp, buf[4];\n\tstruct tda10071_reg_val_mask tab[] = {\n\t\t{ 0xcd, 0x00, 0x07 },\n\t\t{ 0x80, 0x00, 0x02 },\n\t\t{ 0xcd, 0x00, 0xc0 },\n\t\t{ 0xce, 0x00, 0x1b },\n\t\t{ 0x9d, 0x00, 0x01 },\n\t\t{ 0x9d, 0x00, 0x02 },\n\t\t{ 0x9e, 0x00, 0x01 },\n\t\t{ 0x87, 0x00, 0x80 },\n\t\t{ 0xce, 0x00, 0x08 },\n\t\t{ 0xce, 0x00, 0x10 },\n\t};\n\tstruct tda10071_reg_val_mask tab2[] = {\n\t\t{ 0xf1, 0x70, 0xff },\n\t\t{ 0x88, dev->pll_multiplier, 0x3f },\n\t\t{ 0x89, 0x00, 0x10 },\n\t\t{ 0x89, 0x10, 0x10 },\n\t\t{ 0xc0, 0x01, 0x01 },\n\t\t{ 0xc0, 0x00, 0x01 },\n\t\t{ 0xe0, 0xff, 0xff },\n\t\t{ 0xe0, 0x00, 0xff },\n\t\t{ 0x96, 0x1e, 0x7e },\n\t\t{ 0x8b, 0x08, 0x08 },\n\t\t{ 0x8b, 0x00, 0x08 },\n\t\t{ 0x8f, 0x1a, 0x7e },\n\t\t{ 0x8c, 0x68, 0xff },\n\t\t{ 0x8d, 0x08, 0xff },\n\t\t{ 0x8e, 0x4c, 0xff },\n\t\t{ 0x8f, 0x01, 0x01 },\n\t\t{ 0x8b, 0x04, 0x04 },\n\t\t{ 0x8b, 0x00, 0x04 },\n\t\t{ 0x87, 0x05, 0x07 },\n\t\t{ 0x80, 0x00, 0x20 },\n\t\t{ 0xc8, 0x01, 0xff },\n\t\t{ 0xb4, 0x47, 0xff },\n\t\t{ 0xb5, 0x9c, 0xff },\n\t\t{ 0xb6, 0x7d, 0xff },\n\t\t{ 0xba, 0x00, 0x03 },\n\t\t{ 0xb7, 0x47, 0xff },\n\t\t{ 0xb8, 0x9c, 0xff },\n\t\t{ 0xb9, 0x7d, 0xff },\n\t\t{ 0xba, 0x00, 0x0c },\n\t\t{ 0xc8, 0x00, 0xff },\n\t\t{ 0xcd, 0x00, 0x04 },\n\t\t{ 0xcd, 0x00, 0x20 },\n\t\t{ 0xe8, 0x02, 0xff },\n\t\t{ 0xcf, 0x20, 0xff },\n\t\t{ 0x9b, 0xd7, 0xff },\n\t\t{ 0x9a, 0x01, 0x03 },\n\t\t{ 0xa8, 0x05, 0x0f },\n\t\t{ 0xa8, 0x65, 0xf0 },\n\t\t{ 0xa6, 0xa0, 0xf0 },\n\t\t{ 0x9d, 0x50, 0xfc },\n\t\t{ 0x9e, 0x20, 0xe0 },\n\t\t{ 0xa3, 0x1c, 0x7c },\n\t\t{ 0xd5, 0x03, 0x03 },\n\t};\n\n\tif (dev->warm) {\n\t\t \n\n\t\tfor (i = 0; i < ARRAY_SIZE(tab); i++) {\n\t\t\tret = tda10071_wr_reg_mask(dev, tab[i].reg,\n\t\t\t\ttab[i].val, tab[i].mask);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tcmd.args[0] = CMD_SET_SLEEP_MODE;\n\t\tcmd.args[1] = 0;\n\t\tcmd.args[2] = 0;\n\t\tcmd.len = 3;\n\t\tret = tda10071_cmd_execute(dev, &cmd);\n\t\tif (ret)\n\t\t\tgoto error;\n\t} else {\n\t\t \n\n\t\t \n\t\tret = request_firmware(&fw, fw_file, &client->dev);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"did not find the firmware file '%s' (status %d). You can use <kernel_dir>/scripts/get_dvb_firmware to get the firmware\\n\",\n\t\t\t\tfw_file, ret);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(tab2); i++) {\n\t\t\tret = tda10071_wr_reg_mask(dev, tab2[i].reg,\n\t\t\t\ttab2[i].val, tab2[i].mask);\n\t\t\tif (ret)\n\t\t\t\tgoto error_release_firmware;\n\t\t}\n\n\t\t \n\t\tret = regmap_write(dev->regmap, 0xe0, 0x7f);\n\t\tif (ret)\n\t\t\tgoto error_release_firmware;\n\n\t\tret = regmap_write(dev->regmap, 0xf7, 0x81);\n\t\tif (ret)\n\t\t\tgoto error_release_firmware;\n\n\t\tret = regmap_write(dev->regmap, 0xf8, 0x00);\n\t\tif (ret)\n\t\t\tgoto error_release_firmware;\n\n\t\tret = regmap_write(dev->regmap, 0xf9, 0x00);\n\t\tif (ret)\n\t\t\tgoto error_release_firmware;\n\n\t\tdev_info(&client->dev,\n\t\t\t \"found a '%s' in cold state, will try to load a firmware\\n\",\n\t\t\t tda10071_ops.info.name);\n\t\tdev_info(&client->dev, \"downloading firmware from file '%s'\\n\",\n\t\t\t fw_file);\n\n\t\t \n\t\tfw_size = fw->size - 1;\n\n\t\tfor (remaining = fw_size; remaining > 0;\n\t\t\tremaining -= (dev->i2c_wr_max - 1)) {\n\t\t\tlen = remaining;\n\t\t\tif (len > (dev->i2c_wr_max - 1))\n\t\t\t\tlen = (dev->i2c_wr_max - 1);\n\n\t\t\tret = regmap_bulk_write(dev->regmap, 0xfa,\n\t\t\t\t(u8 *) &fw->data[fw_size - remaining], len);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"firmware download failed=%d\\n\", ret);\n\t\t\t\tgoto error_release_firmware;\n\t\t\t}\n\t\t}\n\t\trelease_firmware(fw);\n\n\t\tret = regmap_write(dev->regmap, 0xf7, 0x0c);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tret = regmap_write(dev->regmap, 0xe0, 0x00);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\t \n\t\tmsleep(250);\n\n\t\t \n\t\tret = regmap_read(dev->regmap, 0x51, &uitmp);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (uitmp) {\n\t\t\tdev_info(&client->dev, \"firmware did not run\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto error;\n\t\t} else {\n\t\t\tdev->warm = true;\n\t\t}\n\n\t\tcmd.args[0] = CMD_GET_FW_VERSION;\n\t\tcmd.len = 1;\n\t\tret = tda10071_cmd_execute(dev, &cmd);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tret = regmap_bulk_read(dev->regmap, cmd.len, buf, 4);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tdev_info(&client->dev, \"firmware version %d.%d.%d.%d\\n\",\n\t\t\t buf[0], buf[1], buf[2], buf[3]);\n\t\tdev_info(&client->dev, \"found a '%s' in warm state\\n\",\n\t\t\t tda10071_ops.info.name);\n\n\t\tret = regmap_bulk_read(dev->regmap, 0x81, buf, 2);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tcmd.args[0] = CMD_DEMOD_INIT;\n\t\tcmd.args[1] = ((dev->clk / 1000) >> 8) & 0xff;\n\t\tcmd.args[2] = ((dev->clk / 1000) >> 0) & 0xff;\n\t\tcmd.args[3] = buf[0];\n\t\tcmd.args[4] = buf[1];\n\t\tcmd.args[5] = dev->pll_multiplier;\n\t\tcmd.args[6] = dev->spec_inv;\n\t\tcmd.args[7] = 0x00;\n\t\tcmd.len = 8;\n\t\tret = tda10071_cmd_execute(dev, &cmd);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (dev->tuner_i2c_addr)\n\t\t\ttmp = dev->tuner_i2c_addr;\n\t\telse\n\t\t\ttmp = 0x14;\n\n\t\tcmd.args[0] = CMD_TUNER_INIT;\n\t\tcmd.args[1] = 0x00;\n\t\tcmd.args[2] = 0x00;\n\t\tcmd.args[3] = 0x00;\n\t\tcmd.args[4] = 0x00;\n\t\tcmd.args[5] = tmp;\n\t\tcmd.args[6] = 0x00;\n\t\tcmd.args[7] = 0x03;\n\t\tcmd.args[8] = 0x02;\n\t\tcmd.args[9] = 0x02;\n\t\tcmd.args[10] = 0x00;\n\t\tcmd.args[11] = 0x00;\n\t\tcmd.args[12] = 0x00;\n\t\tcmd.args[13] = 0x00;\n\t\tcmd.args[14] = 0x00;\n\t\tcmd.len = 15;\n\t\tret = tda10071_cmd_execute(dev, &cmd);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tcmd.args[0] = CMD_MPEG_CONFIG;\n\t\tcmd.args[1] = 0;\n\t\tcmd.args[2] = dev->ts_mode;\n\t\tcmd.args[3] = 0x00;\n\t\tcmd.args[4] = 0x04;\n\t\tcmd.args[5] = 0x00;\n\t\tcmd.len = 6;\n\t\tret = tda10071_cmd_execute(dev, &cmd);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tret = regmap_update_bits(dev->regmap, 0xf0, 0x01, 0x01);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tcmd.args[0] = CMD_LNB_CONFIG;\n\t\tcmd.args[1] = 0;\n\t\tcmd.args[2] = 150;\n\t\tcmd.args[3] = 3;\n\t\tcmd.args[4] = 22;\n\t\tcmd.args[5] = 1;\n\t\tcmd.args[6] = 1;\n\t\tcmd.args[7] = 30;\n\t\tcmd.args[8] = 30;\n\t\tcmd.args[9] = 30;\n\t\tcmd.args[10] = 30;\n\t\tcmd.len = 11;\n\t\tret = tda10071_cmd_execute(dev, &cmd);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tcmd.args[0] = CMD_BER_CONTROL;\n\t\tcmd.args[1] = 0;\n\t\tcmd.args[2] = 14;\n\t\tcmd.args[3] = 14;\n\t\tcmd.len = 4;\n\t\tret = tda10071_cmd_execute(dev, &cmd);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\t \n\tc->strength.len = 1;\n\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->cnr.len = 1;\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_error.len = 1;\n\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\treturn ret;\nerror_release_firmware:\n\trelease_firmware(fw);\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tda10071_sleep(struct dvb_frontend *fe)\n{\n\tstruct tda10071_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct tda10071_cmd cmd;\n\tint ret, i;\n\tstruct tda10071_reg_val_mask tab[] = {\n\t\t{ 0xcd, 0x07, 0x07 },\n\t\t{ 0x80, 0x02, 0x02 },\n\t\t{ 0xcd, 0xc0, 0xc0 },\n\t\t{ 0xce, 0x1b, 0x1b },\n\t\t{ 0x9d, 0x01, 0x01 },\n\t\t{ 0x9d, 0x02, 0x02 },\n\t\t{ 0x9e, 0x01, 0x01 },\n\t\t{ 0x87, 0x80, 0x80 },\n\t\t{ 0xce, 0x08, 0x08 },\n\t\t{ 0xce, 0x10, 0x10 },\n\t};\n\n\tif (!dev->warm) {\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tcmd.args[0] = CMD_SET_SLEEP_MODE;\n\tcmd.args[1] = 0;\n\tcmd.args[2] = 1;\n\tcmd.len = 3;\n\tret = tda10071_cmd_execute(dev, &cmd);\n\tif (ret)\n\t\tgoto error;\n\n\tfor (i = 0; i < ARRAY_SIZE(tab); i++) {\n\t\tret = tda10071_wr_reg_mask(dev, tab[i].reg, tab[i].val,\n\t\t\ttab[i].mask);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tda10071_get_tune_settings(struct dvb_frontend *fe,\n\tstruct dvb_frontend_tune_settings *s)\n{\n\ts->min_delay_ms = 8000;\n\ts->step_size = 0;\n\ts->max_drift = 0;\n\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops tda10071_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2 },\n\t.info = {\n\t\t.name = \"NXP TDA10071\",\n\t\t.frequency_min_hz    =  950 * MHz,\n\t\t.frequency_max_hz    = 2150 * MHz,\n\t\t.frequency_tolerance_hz = 5 * MHz,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 |\n\t\t\tFE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_4_5 |\n\t\t\tFE_CAN_FEC_5_6 |\n\t\t\tFE_CAN_FEC_6_7 |\n\t\t\tFE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_8_9 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK |\n\t\t\tFE_CAN_RECOVER |\n\t\t\tFE_CAN_2G_MODULATION\n\t},\n\n\t.get_tune_settings = tda10071_get_tune_settings,\n\n\t.init = tda10071_init,\n\t.sleep = tda10071_sleep,\n\n\t.set_frontend = tda10071_set_frontend,\n\t.get_frontend = tda10071_get_frontend,\n\n\t.read_status = tda10071_read_status,\n\t.read_snr = tda10071_read_snr,\n\t.read_signal_strength = tda10071_read_signal_strength,\n\t.read_ber = tda10071_read_ber,\n\t.read_ucblocks = tda10071_read_ucblocks,\n\n\t.diseqc_send_master_cmd = tda10071_diseqc_send_master_cmd,\n\t.diseqc_recv_slave_reply = tda10071_diseqc_recv_slave_reply,\n\t.diseqc_send_burst = tda10071_diseqc_send_burst,\n\n\t.set_tone = tda10071_set_tone,\n\t.set_voltage = tda10071_set_voltage,\n};\n\nstatic struct dvb_frontend *tda10071_get_dvb_frontend(struct i2c_client *client)\n{\n\tstruct tda10071_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\treturn &dev->fe;\n}\n\nstatic int tda10071_probe(struct i2c_client *client)\n{\n\tstruct tda10071_dev *dev;\n\tstruct tda10071_platform_data *pdata = client->dev.platform_data;\n\tint ret;\n\tunsigned int uitmp;\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t};\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev->client = client;\n\tmutex_init(&dev->cmd_execute_mutex);\n\tdev->clk = pdata->clk;\n\tdev->i2c_wr_max = pdata->i2c_wr_max;\n\tdev->ts_mode = pdata->ts_mode;\n\tdev->spec_inv = pdata->spec_inv;\n\tdev->pll_multiplier = pdata->pll_multiplier;\n\tdev->tuner_i2c_addr = pdata->tuner_i2c_addr;\n\tdev->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tret = regmap_read(dev->regmap, 0xff, &uitmp);\n\tif (ret)\n\t\tgoto err_kfree;\n\tif (uitmp != 0x0f) {\n\t\tret = -ENODEV;\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tret = regmap_read(dev->regmap, 0xdd, &uitmp);\n\tif (ret)\n\t\tgoto err_kfree;\n\tif (uitmp != 0x00) {\n\t\tret = -ENODEV;\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tret = regmap_read(dev->regmap, 0xfe, &uitmp);\n\tif (ret)\n\t\tgoto err_kfree;\n\tif (uitmp != 0x01) {\n\t\tret = -ENODEV;\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tmemcpy(&dev->fe.ops, &tda10071_ops, sizeof(struct dvb_frontend_ops));\n\tdev->fe.demodulator_priv = dev;\n\ti2c_set_clientdata(client, dev);\n\n\t \n\tpdata->get_dvb_frontend = tda10071_get_dvb_frontend;\n\n\tdev_info(&client->dev, \"NXP TDA10071 successfully identified\\n\");\n\treturn 0;\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void tda10071_remove(struct i2c_client *client)\n{\n\tstruct tda10071_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id tda10071_id_table[] = {\n\t{\"tda10071_cx24118\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, tda10071_id_table);\n\nstatic struct i2c_driver tda10071_driver = {\n\t.driver = {\n\t\t.name\t= \"tda10071\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= tda10071_probe,\n\t.remove\t\t= tda10071_remove,\n\t.id_table\t= tda10071_id_table,\n};\n\nmodule_i2c_driver(tda10071_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"NXP TDA10071 DVB-S/S2 demodulator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(TDA10071_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}