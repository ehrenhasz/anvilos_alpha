{
  "module_name": "lnbp22.c",
  "hash_id": "da9d0f357c3c0a86323dbcaa2c1f66e10a6ca62e8c18e14b390804486c91140e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/lnbp22.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"lnbp22.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging (default:off).\");\n\n\n#define dprintk(lvl, arg...) if (debug >= (lvl)) printk(arg)\n\nstruct lnbp22 {\n\tu8\t\t    config[4];\n\tstruct i2c_adapter *i2c;\n};\n\nstatic int lnbp22_set_voltage(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_voltage voltage)\n{\n\tstruct lnbp22 *lnbp22 = (struct lnbp22 *)fe->sec_priv;\n\tstruct i2c_msg msg = {\n\t\t.addr = 0x08,\n\t\t.flags = 0,\n\t\t.buf = (char *)&lnbp22->config,\n\t\t.len = sizeof(lnbp22->config),\n\t};\n\n\tdprintk(1, \"%s: %d (18V=%d 13V=%d)\\n\", __func__, voltage,\n\t       SEC_VOLTAGE_18, SEC_VOLTAGE_13);\n\n\tlnbp22->config[3] = 0x60;  \n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_OFF:\n\t\tbreak;\n\tcase SEC_VOLTAGE_13:\n\t\tlnbp22->config[3] |= LNBP22_EN;\n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\n\t\tlnbp22->config[3] |= (LNBP22_EN | LNBP22_VSEL);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdprintk(1, \"%s: 0x%02x)\\n\", __func__, lnbp22->config[3]);\n\treturn (i2c_transfer(lnbp22->i2c, &msg, 1) == 1) ? 0 : -EIO;\n}\n\nstatic int lnbp22_enable_high_lnb_voltage(struct dvb_frontend *fe, long arg)\n{\n\tstruct lnbp22 *lnbp22 = (struct lnbp22 *) fe->sec_priv;\n\tstruct i2c_msg msg = {\n\t\t.addr = 0x08,\n\t\t.flags = 0,\n\t\t.buf = (char *)&lnbp22->config,\n\t\t.len = sizeof(lnbp22->config),\n\t};\n\n\tdprintk(1, \"%s: %d\\n\", __func__, (int)arg);\n\tif (arg)\n\t\tlnbp22->config[3] |= LNBP22_LLC;\n\telse\n\t\tlnbp22->config[3] &= ~LNBP22_LLC;\n\n\treturn (i2c_transfer(lnbp22->i2c, &msg, 1) == 1) ? 0 : -EIO;\n}\n\nstatic void lnbp22_release(struct dvb_frontend *fe)\n{\n\tdprintk(1, \"%s\\n\", __func__);\n\t \n\tlnbp22_set_voltage(fe, SEC_VOLTAGE_OFF);\n\n\t \n\tkfree(fe->sec_priv);\n\tfe->sec_priv = NULL;\n}\n\nstruct dvb_frontend *lnbp22_attach(struct dvb_frontend *fe,\n\t\t\t\t\tstruct i2c_adapter *i2c)\n{\n\tstruct lnbp22 *lnbp22 = kmalloc(sizeof(struct lnbp22), GFP_KERNEL);\n\tif (!lnbp22)\n\t\treturn NULL;\n\n\t \n\tlnbp22->config[0] = 0x00;  \n\tlnbp22->config[1] = 0x28;  \n\tlnbp22->config[2] = 0x48;  \n\tlnbp22->config[3] = 0x60;  \n\tlnbp22->i2c = i2c;\n\tfe->sec_priv = lnbp22;\n\n\t \n\tif (lnbp22_set_voltage(fe, SEC_VOLTAGE_OFF)) {\n\t\tdprintk(0, \"%s LNBP22 not found\\n\", __func__);\n\t\tkfree(lnbp22);\n\t\tfe->sec_priv = NULL;\n\t\treturn NULL;\n\t}\n\n\t \n\tfe->ops.release_sec = lnbp22_release;\n\n\t \n\tfe->ops.set_voltage = lnbp22_set_voltage;\n\tfe->ops.enable_high_lnb_voltage = lnbp22_enable_high_lnb_voltage;\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(lnbp22_attach);\n\nMODULE_DESCRIPTION(\"Driver for lnb supply and control ic lnbp22\");\nMODULE_AUTHOR(\"Dominik Kuhlen\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}