{
  "module_name": "lgdt3306a.c",
  "hash_id": "f3553b0f0ebe427b1a799fda88c885e13dff95fe0cdb5a4b5cc44b6878ce3473",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/lgdt3306a.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <asm/div64.h>\n#include <linux/kernel.h>\n#include <linux/dvb/frontend.h>\n#include <linux/int_log.h>\n#include \"lgdt3306a.h\"\n#include <linux/i2c-mux.h>\n\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debug level (info=1, reg=2 (or-able))\");\n\n \nstatic int forced_manual;\nmodule_param(forced_manual, int, 0644);\nMODULE_PARM_DESC(forced_manual, \"if set, QAM64 and QAM256 will only lock to modulation specified\");\n\n#define DBG_INFO 1\n#define DBG_REG  2\n#define DBG_DUMP 4  \n\n#define lg_debug(fmt, arg...) \\\n\tprintk(KERN_DEBUG pr_fmt(fmt), ## arg)\n\n#define dbg_info(fmt, arg...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (debug & DBG_INFO)\t\t\t\t\\\n\t\t\tlg_debug(fmt, ## arg);\t\t\t\\\n\t} while (0)\n\n#define dbg_reg(fmt, arg...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (debug & DBG_REG)\t\t\t\t\\\n\t\t\tlg_debug(fmt, ## arg);\t\t\t\\\n\t} while (0)\n\n#define lg_chkerr(ret)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __ret;\t\t\t\t\t\t\t\\\n\t__ret = (ret < 0);\t\t\t\t\t\t\\\n\tif (__ret)\t\t\t\t\t\t\t\\\n\t\tpr_err(\"error %d on line %d\\n\",\tret, __LINE__);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\nstruct lgdt3306a_state {\n\tstruct i2c_adapter *i2c_adap;\n\tconst struct lgdt3306a_config *cfg;\n\n\tstruct dvb_frontend frontend;\n\n\tenum fe_modulation current_modulation;\n\tu32 current_frequency;\n\tu32 snr;\n\n\tstruct i2c_mux_core *muxc;\n};\n\n \n\nenum lgdt3306a_lock_status {\n\tLG3306_UNLOCK       = 0x00,\n\tLG3306_LOCK         = 0x01,\n\tLG3306_UNKNOWN_LOCK = 0xff\n};\n\nenum lgdt3306a_neverlock_status {\n\tLG3306_NL_INIT    = 0x00,\n\tLG3306_NL_PROCESS = 0x01,\n\tLG3306_NL_LOCK    = 0x02,\n\tLG3306_NL_FAIL    = 0x03,\n\tLG3306_NL_UNKNOWN = 0xff\n};\n\nenum lgdt3306a_modulation {\n\tLG3306_VSB          = 0x00,\n\tLG3306_QAM64        = 0x01,\n\tLG3306_QAM256       = 0x02,\n\tLG3306_UNKNOWN_MODE = 0xff\n};\n\nenum lgdt3306a_lock_check {\n\tLG3306_SYNC_LOCK,\n\tLG3306_FEC_LOCK,\n\tLG3306_TR_LOCK,\n\tLG3306_AGC_LOCK,\n};\n\n\n#ifdef DBG_DUMP\nstatic void lgdt3306a_DumpAllRegs(struct lgdt3306a_state *state);\nstatic void lgdt3306a_DumpRegs(struct lgdt3306a_state *state);\n#endif\n\n\nstatic int lgdt3306a_write_reg(struct lgdt3306a_state *state, u16 reg, u8 val)\n{\n\tint ret;\n\tu8 buf[] = { reg >> 8, reg & 0xff, val };\n\tstruct i2c_msg msg = {\n\t\t.addr = state->cfg->i2c_addr, .flags = 0,\n\t\t.buf = buf, .len = 3,\n\t};\n\n\tdbg_reg(\"reg: 0x%04x, val: 0x%02x\\n\", reg, val);\n\n\tret = i2c_transfer(state->i2c_adap, &msg, 1);\n\n\tif (ret != 1) {\n\t\tpr_err(\"error (addr %02x %02x <- %02x, err = %i)\\n\",\n\t\t       msg.buf[0], msg.buf[1], msg.buf[2], ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int lgdt3306a_read_reg(struct lgdt3306a_state *state, u16 reg, u8 *val)\n{\n\tint ret;\n\tu8 reg_buf[] = { reg >> 8, reg & 0xff };\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->cfg->i2c_addr,\n\t\t  .flags = 0, .buf = reg_buf, .len = 2 },\n\t\t{ .addr = state->cfg->i2c_addr,\n\t\t  .flags = I2C_M_RD, .buf = val, .len = 1 },\n\t};\n\n\tret = i2c_transfer(state->i2c_adap, msg, 2);\n\n\tif (ret != 2) {\n\t\tpr_err(\"error (addr %02x reg %04x error (ret == %i)\\n\",\n\t\t       state->cfg->i2c_addr, reg, ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn -EREMOTEIO;\n\t}\n\tdbg_reg(\"reg: 0x%04x, val: 0x%02x\\n\", reg, *val);\n\n\treturn 0;\n}\n\n#define read_reg(state, reg)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tu8 __val;\t\t\t\t\t\t\t\\\n\tint ret = lgdt3306a_read_reg(state, reg, &__val);\t\t\\\n\tif (lg_chkerr(ret))\t\t\t\t\t\t\\\n\t\t__val = 0;\t\t\t\t\t\t\\\n\t__val;\t\t\t\t\t\t\t\t\\\n})\n\nstatic int lgdt3306a_set_reg_bit(struct lgdt3306a_state *state,\n\t\t\t\tu16 reg, int bit, int onoff)\n{\n\tu8 val;\n\tint ret;\n\n\tdbg_reg(\"reg: 0x%04x, bit: %d, level: %d\\n\", reg, bit, onoff);\n\n\tret = lgdt3306a_read_reg(state, reg, &val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tval &= ~(1 << bit);\n\tval |= (onoff & 1) << bit;\n\n\tret = lgdt3306a_write_reg(state, reg, val);\n\tlg_chkerr(ret);\nfail:\n\treturn ret;\n}\n\n \n\nstatic int lgdt3306a_soft_reset(struct lgdt3306a_state *state)\n{\n\tint ret;\n\n\tdbg_info(\"\\n\");\n\n\tret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 0);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tmsleep(20);\n\tret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 1);\n\tlg_chkerr(ret);\n\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3306a_mpeg_mode(struct lgdt3306a_state *state,\n\t\t\t\t     enum lgdt3306a_mpeg_mode mode)\n{\n\tu8 val;\n\tint ret;\n\n\tdbg_info(\"(%d)\\n\", mode);\n\t \n\tret = lgdt3306a_set_reg_bit(state, 0x0071, 7,\n\t\t\t\t     mode == LGDT3306A_MPEG_PARALLEL ? 1 : 0);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_set_reg_bit(state, 0x0071, 6, 0);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tret = lgdt3306a_read_reg(state, 0x0070, &val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tval |= 0x10;  \n\n\tif (mode == LGDT3306A_MPEG_PARALLEL)\n\t\tval &= ~0x10;\n\n\tret = lgdt3306a_write_reg(state, 0x0070, val);\n\tlg_chkerr(ret);\n\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3306a_mpeg_mode_polarity(struct lgdt3306a_state *state,\n\t\t\t\t       enum lgdt3306a_tp_clock_edge edge,\n\t\t\t\t       enum lgdt3306a_tp_valid_polarity valid)\n{\n\tu8 val;\n\tint ret;\n\n\tdbg_info(\"edge=%d, valid=%d\\n\", edge, valid);\n\n\tret = lgdt3306a_read_reg(state, 0x0070, &val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tval &= ~0x06;  \n\n\tif (edge == LGDT3306A_TPCLK_RISING_EDGE)\n\t\tval |= 0x04;\n\tif (valid == LGDT3306A_TP_VALID_HIGH)\n\t\tval |= 0x02;\n\n\tret = lgdt3306a_write_reg(state, 0x0070, val);\n\tlg_chkerr(ret);\n\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3306a_mpeg_tristate(struct lgdt3306a_state *state,\n\t\t\t\t     int mode)\n{\n\tu8 val;\n\tint ret;\n\n\tdbg_info(\"(%d)\\n\", mode);\n\n\tif (mode) {\n\t\tret = lgdt3306a_read_reg(state, 0x0070, &val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\t\t \n\t\tval &= ~0xa8;\n\t\tret = lgdt3306a_write_reg(state, 0x0070, val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\n\t\t \n\t\tret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 1);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\n\t} else {\n\t\t \n\t\tret = lgdt3306a_set_reg_bit(state, 0x0003, 6, 0);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\n\t\tret = lgdt3306a_read_reg(state, 0x0070, &val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\n\t\tval |= 0xa8;  \n\t\tret = lgdt3306a_write_reg(state, 0x0070, val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\t}\n\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3306a_ts_bus_ctrl(struct dvb_frontend *fe, int acquire)\n{\n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\n\tdbg_info(\"acquire=%d\\n\", acquire);\n\n\treturn lgdt3306a_mpeg_tristate(state, acquire ? 0 : 1);\n\n}\n\nstatic int lgdt3306a_power(struct lgdt3306a_state *state,\n\t\t\t\t     int mode)\n{\n\tint ret;\n\n\tdbg_info(\"(%d)\\n\", mode);\n\n\tif (mode == 0) {\n\t\t \n\t\tret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 0);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\n\t\t \n\t\tret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 0);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\n\t} else {\n\t\t \n\t\tret = lgdt3306a_set_reg_bit(state, 0x0000, 7, 1);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\n\t\t \n\t\tret = lgdt3306a_set_reg_bit(state, 0x0000, 0, 1);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\t}\n\n#ifdef DBG_DUMP\n\tlgdt3306a_DumpAllRegs(state);\n#endif\nfail:\n\treturn ret;\n}\n\n\nstatic int lgdt3306a_set_vsb(struct lgdt3306a_state *state)\n{\n\tu8 val;\n\tint ret;\n\n\tdbg_info(\"\\n\");\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x0002, &val);\n\tval &= 0xf7;  \n\tval |= 0x04;  \n\tret = lgdt3306a_write_reg(state, 0x0002, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_write_reg(state, 0x0008, 0x80);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x0009, &val);\n\tval &= 0xe3;\n\tval |= 0x0c;  \n\tret = lgdt3306a_write_reg(state, 0x0009, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x0009, &val);\n\tval &= 0xfc;  \n\tret = lgdt3306a_write_reg(state, 0x0009, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x000d, &val);\n\tval &= 0xbf;  \n\tret = lgdt3306a_write_reg(state, 0x000d, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n#if 0\n\t \n\n\tret = lgdt3306a_write_reg(state, 0x0024, 0x00);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_write_reg(state, 0x002e, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x002f, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x0030, 0x00);\n\n\t \n\tret = lgdt3306a_write_reg(state, 0x002b, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x002c, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x002d, 0x00);\n\n\t \n\tret = lgdt3306a_write_reg(state, 0x0028, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x0029, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x002a, 0x00);\n\n\t \n\tret = lgdt3306a_write_reg(state, 0x0025, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x0026, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x0027, 0x00);\n\n#else\n\t \n\n\t \n\tret = lgdt3306a_write_reg(state, 0x0024, 0x5A);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_write_reg(state, 0x002e, 0x5A);\n\tret = lgdt3306a_write_reg(state, 0x002f, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x0030, 0x00);\n\n\t \n\tret = lgdt3306a_write_reg(state, 0x002b, 0x36);\n\tret = lgdt3306a_write_reg(state, 0x002c, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x002d, 0x00);\n\n\t \n\tret = lgdt3306a_write_reg(state, 0x0028, 0x2A);\n\tret = lgdt3306a_write_reg(state, 0x0029, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x002a, 0x00);\n\n\t \n\tret = lgdt3306a_write_reg(state, 0x0025, 0x06);\n\tret = lgdt3306a_write_reg(state, 0x0026, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x0027, 0x00);\n#endif\n\n\tret = lgdt3306a_read_reg(state, 0x001e, &val);\n\tval &= 0x0f;\n\tval |= 0xa0;\n\tret = lgdt3306a_write_reg(state, 0x001e, val);\n\n\tret = lgdt3306a_write_reg(state, 0x0022, 0x08);\n\n\tret = lgdt3306a_write_reg(state, 0x0023, 0xFF);\n\n\tret = lgdt3306a_read_reg(state, 0x211f, &val);\n\tval &= 0xef;\n\tret = lgdt3306a_write_reg(state, 0x211f, val);\n\n\tret = lgdt3306a_write_reg(state, 0x2173, 0x01);\n\n\tret = lgdt3306a_read_reg(state, 0x1061, &val);\n\tval &= 0xf8;\n\tval |= 0x04;\n\tret = lgdt3306a_write_reg(state, 0x1061, val);\n\n\tret = lgdt3306a_read_reg(state, 0x103d, &val);\n\tval &= 0xcf;\n\tret = lgdt3306a_write_reg(state, 0x103d, val);\n\n\tret = lgdt3306a_write_reg(state, 0x2122, 0x40);\n\n\tret = lgdt3306a_read_reg(state, 0x2141, &val);\n\tval &= 0x3f;\n\tret = lgdt3306a_write_reg(state, 0x2141, val);\n\n\tret = lgdt3306a_read_reg(state, 0x2135, &val);\n\tval &= 0x0f;\n\tval |= 0x70;\n\tret = lgdt3306a_write_reg(state, 0x2135, val);\n\n\tret = lgdt3306a_read_reg(state, 0x0003, &val);\n\tval &= 0xf7;\n\tret = lgdt3306a_write_reg(state, 0x0003, val);\n\n\tret = lgdt3306a_read_reg(state, 0x001c, &val);\n\tval &= 0x7f;\n\tret = lgdt3306a_write_reg(state, 0x001c, val);\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x2179, &val);\n\tval &= 0xf8;\n\tret = lgdt3306a_write_reg(state, 0x2179, val);\n\n\tret = lgdt3306a_read_reg(state, 0x217a, &val);\n\tval &= 0xf8;\n\tret = lgdt3306a_write_reg(state, 0x217a, val);\n\n\t \n\tret = lgdt3306a_soft_reset(state);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tdbg_info(\"complete\\n\");\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3306a_set_qam(struct lgdt3306a_state *state, int modulation)\n{\n\tu8 val;\n\tint ret;\n\n\tdbg_info(\"modulation=%d\\n\", modulation);\n\n\t \n\tret = lgdt3306a_write_reg(state, 0x0008, 0x08);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x0002, &val);\n\tval &= 0xfb;  \n\tval |= 0x08;  \n\tret = lgdt3306a_write_reg(state, 0x0002, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x0009, &val);\n\tval &= 0xe3;  \n\tret = lgdt3306a_write_reg(state, 0x0009, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x0009, &val);\n\tval &= 0xfc;\n\t \n\tif(forced_manual && (modulation != QAM_AUTO)){\n\t\tval |= 0x01;  \n\t} else {\n\t\tval |= 0x02;  \n\t}\n\tret = lgdt3306a_write_reg(state, 0x0009, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x101a, &val);\n\tval &= 0xf8;\n\tif (modulation == QAM_64)\n\t\tval |= 0x02;  \n\telse\n\t\tval |= 0x04;  \n\n\tret = lgdt3306a_write_reg(state, 0x101a, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x000d, &val);\n\tval &= 0xbf;\n\tval |= 0x40;  \n\tret = lgdt3306a_write_reg(state, 0x000d, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x0024, &val);\n\tval &= 0x00;\n\tret = lgdt3306a_write_reg(state, 0x0024, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x000a, &val);\n\tval &= 0xfd;\n\tval |= 0x02;\n\tret = lgdt3306a_write_reg(state, 0x000a, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x2849, &val);\n\tval &= 0xdf;\n\tret = lgdt3306a_write_reg(state, 0x2849, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x302b, &val);\n\tval &= 0x7f;   \n\tret = lgdt3306a_write_reg(state, 0x302b, val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_soft_reset(state);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tdbg_info(\"complete\\n\");\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3306a_set_modulation(struct lgdt3306a_state *state,\n\t\t\t\t   struct dtv_frontend_properties *p)\n{\n\tint ret;\n\n\tdbg_info(\"\\n\");\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tret = lgdt3306a_set_vsb(state);\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\tcase QAM_AUTO:\n\t\tret = lgdt3306a_set_qam(state, p->modulation);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tstate->current_modulation = p->modulation;\n\nfail:\n\treturn ret;\n}\n\n \n\nstatic int lgdt3306a_agc_setup(struct lgdt3306a_state *state,\n\t\t\t      struct dtv_frontend_properties *p)\n{\n\t \n\tdbg_info(\"\\n\");\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\tcase QAM_AUTO:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int lgdt3306a_set_inversion(struct lgdt3306a_state *state,\n\t\t\t\t       int inversion)\n{\n\tint ret;\n\n\tdbg_info(\"(%d)\\n\", inversion);\n\n\tret = lgdt3306a_set_reg_bit(state, 0x0002, 2, inversion ? 1 : 0);\n\treturn ret;\n}\n\nstatic int lgdt3306a_set_inversion_auto(struct lgdt3306a_state *state,\n\t\t\t\t       int enabled)\n{\n\tint ret;\n\n\tdbg_info(\"(%d)\\n\", enabled);\n\n\t \n\tret = lgdt3306a_set_reg_bit(state, 0x0002, 3, enabled);\n\treturn ret;\n}\n\nstatic int lgdt3306a_set_if(struct lgdt3306a_state *state,\n\t\t\t   struct dtv_frontend_properties *p)\n{\n\tint ret;\n\tu16 if_freq_khz;\n\tu8 nco1, nco2;\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tif_freq_khz = state->cfg->vsb_if_khz;\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\tcase QAM_AUTO:\n\t\tif_freq_khz = state->cfg->qam_if_khz;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (if_freq_khz) {\n\tdefault:\n\t\tpr_warn(\"IF=%d KHz is not supported, 3250 assumed\\n\",\n\t\t\tif_freq_khz);\n\t\tfallthrough;\n\tcase 3250:  \n\t\tnco1 = 0x34;\n\t\tnco2 = 0x00;\n\t\tbreak;\n\tcase 3500:  \n\t\tnco1 = 0x38;\n\t\tnco2 = 0x00;\n\t\tbreak;\n\tcase 4000:  \n\t\tnco1 = 0x40;\n\t\tnco2 = 0x00;\n\t\tbreak;\n\tcase 5000:  \n\t\tnco1 = 0x50;\n\t\tnco2 = 0x00;\n\t\tbreak;\n\tcase 5380:  \n\t\tnco1 = 0x56;\n\t\tnco2 = 0x14;\n\t\tbreak;\n\t}\n\tret = lgdt3306a_write_reg(state, 0x0010, nco1);\n\tif (ret)\n\t\treturn ret;\n\tret = lgdt3306a_write_reg(state, 0x0011, nco2);\n\tif (ret)\n\t\treturn ret;\n\n\tdbg_info(\"if_freq=%d KHz->[%04x]\\n\", if_freq_khz, nco1<<8 | nco2);\n\n\treturn 0;\n}\n\n \n\nstatic int lgdt3306a_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\n\tif (state->cfg->deny_i2c_rptr) {\n\t\tdbg_info(\"deny_i2c_rptr=%d\\n\", state->cfg->deny_i2c_rptr);\n\t\treturn 0;\n\t}\n\tdbg_info(\"(%d)\\n\", enable);\n\n\t \n\treturn lgdt3306a_set_reg_bit(state, 0x0002, 7, enable ? 0 : 1);\n}\n\nstatic int lgdt3306a_sleep(struct lgdt3306a_state *state)\n{\n\tint ret;\n\n\tdbg_info(\"\\n\");\n\tstate->current_frequency = -1;  \n\n\tret = lgdt3306a_mpeg_tristate(state, 1);  \n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tret = lgdt3306a_power(state, 0);  \n\tlg_chkerr(ret);\n\nfail:\n\treturn 0;\n}\n\nstatic int lgdt3306a_fe_sleep(struct dvb_frontend *fe)\n{\n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\n\treturn lgdt3306a_sleep(state);\n}\n\nstatic int lgdt3306a_init(struct dvb_frontend *fe)\n{\n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu8 val;\n\tint ret;\n\n\tdbg_info(\"\\n\");\n\n\t \n\tret = lgdt3306a_set_reg_bit(state, 0x0001, 0, 1);  \n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_set_inversion_auto(state, 0);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3306a_set_inversion(state, 1);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\n\t \n\tret = lgdt3306a_set_reg_bit(state, 0x0004, 7, 1);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\n\t \n\tret = lgdt3306a_set_reg_bit(state, 0x0004, 2, 0);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\n\t \n\tret = lgdt3306a_set_reg_bit(state, 0x0004, 3, 0);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\n\t \n\tret = lgdt3306a_set_reg_bit(state, 0x0005, 6, 0);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tif (state->cfg->xtalMHz == 24) {\t \n\t\t \n\t\tret = lgdt3306a_read_reg(state, 0x0005, &val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\t\tval &= 0xc0;\n\t\tval |= 0x25;\n\t\tret = lgdt3306a_write_reg(state, 0x0005, val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\t\tret = lgdt3306a_write_reg(state, 0x0006, 0x64);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\n\t\t \n\t\tret = lgdt3306a_read_reg(state, 0x000d, &val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\t\tval &= 0xc0;\n\t\tval |= 0x18;\n\t\tret = lgdt3306a_write_reg(state, 0x000d, val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\n\t} else if (state->cfg->xtalMHz == 25) {  \n\t\t \n\t\tret = lgdt3306a_read_reg(state, 0x0005, &val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\t\tval &= 0xc0;\n\t\tval |= 0x25;\n\t\tret = lgdt3306a_write_reg(state, 0x0005, val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\t\tret = lgdt3306a_write_reg(state, 0x0006, 0x64);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\n\t\t \n\t\tret = lgdt3306a_read_reg(state, 0x000d, &val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\t\tval &= 0xc0;\n\t\tval |= 0x19;\n\t\tret = lgdt3306a_write_reg(state, 0x000d, val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\t} else {\n\t\tpr_err(\"Bad xtalMHz=%d\\n\", state->cfg->xtalMHz);\n\t}\n#if 0\n\tret = lgdt3306a_write_reg(state, 0x000e, 0x00);\n\tret = lgdt3306a_write_reg(state, 0x000f, 0x00);\n#endif\n\n\t \n\tret = lgdt3306a_write_reg(state, 0x0010, 0x34);  \n\tret = lgdt3306a_write_reg(state, 0x0011, 0x00);\n\n\t \n\tret = lgdt3306a_write_reg(state, 0x0014, 0);  \n\n\t \n\tret = lgdt3306a_read_reg(state, 0x103c, &val);\n\tval &= 0x0f;\n\tval |= 0x20;  \n\tret = lgdt3306a_write_reg(state, 0x103c, val);\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x103d, &val);\n\tval &= 0xfc;\n\tval |= 0x03;\n\tret = lgdt3306a_write_reg(state, 0x103d, val);\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x1036, &val);\n\tval &= 0xf0;\n\tval |= 0x0c;\n\tret = lgdt3306a_write_reg(state, 0x1036, val);\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x211f, &val);\n\tval &= 0xef;  \n\tret = lgdt3306a_write_reg(state, 0x211f, val);\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x2849, &val);\n\tval &= 0xef;  \n\tret = lgdt3306a_write_reg(state, 0x2849, val);\n\n\t \n\tret = lgdt3306a_set_vsb(state);\n\n\t \n\tret = lgdt3306a_mpeg_mode(state, state->cfg->mpeg_mode);\n\n\t \n\tret = lgdt3306a_mpeg_tristate(state, 1);\n\n\t \n\tret = lgdt3306a_sleep(state);\n\tlg_chkerr(ret);\n\n\tc->cnr.len = 1;\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3306a_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tdbg_info(\"(%d, %d)\\n\", p->frequency, p->modulation);\n\n\tif (state->current_frequency  == p->frequency &&\n\t   state->current_modulation == p->modulation) {\n\t\tdbg_info(\" (already set, skipping ...)\\n\");\n\t\treturn 0;\n\t}\n\tstate->current_frequency = -1;\n\tstate->current_modulation = -1;\n\n\tret = lgdt3306a_power(state, 1);  \n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n#if 0\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\t\tstate->current_frequency = p->frequency;\n#endif\n\t}\n\n\tret = lgdt3306a_set_modulation(state, p);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tret = lgdt3306a_agc_setup(state, p);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tret = lgdt3306a_set_if(state, p);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\t \n\n\tret = lgdt3306a_mpeg_mode(state, state->cfg->mpeg_mode);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tret = lgdt3306a_mpeg_mode_polarity(state,\n\t\t\t\t\t  state->cfg->tpclk_edge,\n\t\t\t\t\t  state->cfg->tpvalid_polarity);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tret = lgdt3306a_mpeg_tristate(state, 0);  \n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tret = lgdt3306a_soft_reset(state);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n#ifdef DBG_DUMP\n\tlgdt3306a_DumpAllRegs(state);\n#endif\n\tstate->current_frequency = p->frequency;\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3306a_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t  struct dtv_frontend_properties *p)\n{\n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\n\tdbg_info(\"(%u, %d)\\n\",\n\t\t state->current_frequency, state->current_modulation);\n\n\tp->modulation = state->current_modulation;\n\tp->frequency = state->current_frequency;\n\treturn 0;\n}\n\nstatic enum dvbfe_algo lgdt3306a_get_frontend_algo(struct dvb_frontend *fe)\n{\n#if 1\n\treturn DVBFE_ALGO_CUSTOM;\n#else\n\treturn DVBFE_ALGO_HW;\n#endif\n}\n\n \nstatic int lgdt3306a_monitor_vsb(struct lgdt3306a_state *state)\n{\n\tu8 val;\n\tint ret;\n\tu8 snrRef, maxPowerMan, nCombDet;\n\tu16 fbDlyCir;\n\n\tret = lgdt3306a_read_reg(state, 0x21a1, &val);\n\tif (ret)\n\t\treturn ret;\n\tsnrRef = val & 0x3f;\n\n\tret = lgdt3306a_read_reg(state, 0x2185, &maxPowerMan);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lgdt3306a_read_reg(state, 0x2191, &val);\n\tif (ret)\n\t\treturn ret;\n\tnCombDet = (val & 0x80) >> 7;\n\n\tret = lgdt3306a_read_reg(state, 0x2180, &val);\n\tif (ret)\n\t\treturn ret;\n\tfbDlyCir = (val & 0x03) << 8;\n\n\tret = lgdt3306a_read_reg(state, 0x2181, &val);\n\tif (ret)\n\t\treturn ret;\n\tfbDlyCir |= val;\n\n\tdbg_info(\"snrRef=%d maxPowerMan=0x%x nCombDet=%d fbDlyCir=0x%x\\n\",\n\t\tsnrRef, maxPowerMan, nCombDet, fbDlyCir);\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x1061, &val);\n\tif (ret)\n\t\treturn ret;\n\tval &= 0xf8;\n\tif ((snrRef > 18) && (maxPowerMan > 0x68)\n\t    && (nCombDet == 0x01)\n\t    && ((fbDlyCir == 0x03FF) || (fbDlyCir < 0x6C))) {\n\t\t \n\t\tval |= 0x00;  \n\t} else {\n\t\tval |= 0x04;  \n\t}\n\tret = lgdt3306a_write_reg(state, 0x1061, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x0024, &val);\n\tif (ret)\n\t\treturn ret;\n\tval &= 0x0f;\n\tif (nCombDet == 0) {  \n\t\tval |= 0x50;\n\t}\n\tret = lgdt3306a_write_reg(state, 0x0024, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x103d, &val);\n\tif (ret)\n\t\treturn ret;\n\tval &= 0xcf;\n\tval |= 0x20;\n\tret = lgdt3306a_write_reg(state, 0x103d, val);\n\n\treturn ret;\n}\n\nstatic enum lgdt3306a_modulation\nlgdt3306a_check_oper_mode(struct lgdt3306a_state *state)\n{\n\tu8 val = 0;\n\tint ret;\n\n\tret = lgdt3306a_read_reg(state, 0x0081, &val);\n\tif (ret)\n\t\tgoto err;\n\n\tif (val & 0x80)\t{\n\t\tdbg_info(\"VSB\\n\");\n\t\treturn LG3306_VSB;\n\t}\n\tif (val & 0x08) {\n\t\tret = lgdt3306a_read_reg(state, 0x00a6, &val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tval = val >> 2;\n\t\tif (val & 0x01) {\n\t\t\tdbg_info(\"QAM256\\n\");\n\t\t\treturn LG3306_QAM256;\n\t\t}\n\t\tdbg_info(\"QAM64\\n\");\n\t\treturn LG3306_QAM64;\n\t}\nerr:\n\tpr_warn(\"UNKNOWN\\n\");\n\treturn LG3306_UNKNOWN_MODE;\n}\n\nstatic enum lgdt3306a_lock_status\nlgdt3306a_check_lock_status(struct lgdt3306a_state *state,\n\t\t\t    enum lgdt3306a_lock_check whatLock)\n{\n\tu8 val = 0;\n\tint ret;\n\tenum lgdt3306a_modulation\tmodeOper;\n\tenum lgdt3306a_lock_status lockStatus;\n\n\tmodeOper = LG3306_UNKNOWN_MODE;\n\n\tswitch (whatLock) {\n\tcase LG3306_SYNC_LOCK:\n\t{\n\t\tret = lgdt3306a_read_reg(state, 0x00a6, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((val & 0x80) == 0x80)\n\t\t\tlockStatus = LG3306_LOCK;\n\t\telse\n\t\t\tlockStatus = LG3306_UNLOCK;\n\n\t\tdbg_info(\"SYNC_LOCK=%x\\n\", lockStatus);\n\t\tbreak;\n\t}\n\tcase LG3306_AGC_LOCK:\n\t{\n\t\tret = lgdt3306a_read_reg(state, 0x0080, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((val & 0x40) == 0x40)\n\t\t\tlockStatus = LG3306_LOCK;\n\t\telse\n\t\t\tlockStatus = LG3306_UNLOCK;\n\n\t\tdbg_info(\"AGC_LOCK=%x\\n\", lockStatus);\n\t\tbreak;\n\t}\n\tcase LG3306_TR_LOCK:\n\t{\n\t\tmodeOper = lgdt3306a_check_oper_mode(state);\n\t\tif ((modeOper == LG3306_QAM64) || (modeOper == LG3306_QAM256)) {\n\t\t\tret = lgdt3306a_read_reg(state, 0x1094, &val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif ((val & 0x80) == 0x80)\n\t\t\t\tlockStatus = LG3306_LOCK;\n\t\t\telse\n\t\t\t\tlockStatus = LG3306_UNLOCK;\n\t\t} else\n\t\t\tlockStatus = LG3306_UNKNOWN_LOCK;\n\n\t\tdbg_info(\"TR_LOCK=%x\\n\", lockStatus);\n\t\tbreak;\n\t}\n\tcase LG3306_FEC_LOCK:\n\t{\n\t\tmodeOper = lgdt3306a_check_oper_mode(state);\n\t\tif ((modeOper == LG3306_QAM64) || (modeOper == LG3306_QAM256)) {\n\t\t\tret = lgdt3306a_read_reg(state, 0x0080, &val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif ((val & 0x10) == 0x10)\n\t\t\t\tlockStatus = LG3306_LOCK;\n\t\t\telse\n\t\t\t\tlockStatus = LG3306_UNLOCK;\n\t\t} else\n\t\t\tlockStatus = LG3306_UNKNOWN_LOCK;\n\n\t\tdbg_info(\"FEC_LOCK=%x\\n\", lockStatus);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tlockStatus = LG3306_UNKNOWN_LOCK;\n\t\tpr_warn(\"UNKNOWN whatLock=%d\\n\", whatLock);\n\t\tbreak;\n\t}\n\n\treturn lockStatus;\n}\n\nstatic enum lgdt3306a_neverlock_status\nlgdt3306a_check_neverlock_status(struct lgdt3306a_state *state)\n{\n\tu8 val = 0;\n\tint ret;\n\tenum lgdt3306a_neverlock_status lockStatus;\n\n\tret = lgdt3306a_read_reg(state, 0x0080, &val);\n\tif (ret)\n\t\treturn ret;\n\tlockStatus = (enum lgdt3306a_neverlock_status)(val & 0x03);\n\n\tdbg_info(\"NeverLock=%d\", lockStatus);\n\n\treturn lockStatus;\n}\n\nstatic int lgdt3306a_pre_monitoring(struct lgdt3306a_state *state)\n{\n\tu8 val = 0;\n\tint ret;\n\tu8 currChDiffACQ, snrRef, mainStrong, aiccrejStatus;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x21bc, &currChDiffACQ);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x21a1, &val);\n\tif (ret)\n\t\treturn ret;\n\tsnrRef = val & 0x3f;\n\n\t \n\tret = lgdt3306a_read_reg(state, 0x2199, &val);\n\tif (ret)\n\t\treturn ret;\n\tmainStrong = (val & 0x40) >> 6;\n\n\tret = lgdt3306a_read_reg(state, 0x0090, &val);\n\tif (ret)\n\t\treturn ret;\n\taiccrejStatus = (val & 0xf0) >> 4;\n\n\tdbg_info(\"snrRef=%d mainStrong=%d aiccrejStatus=%d currChDiffACQ=0x%x\\n\",\n\t\tsnrRef, mainStrong, aiccrejStatus, currChDiffACQ);\n\n#if 0\n\t \n\tif ((mainStrong == 0) && (currChDiffACQ > 0x70))\n#endif\n\tif (mainStrong == 0) {\n\t\tret = lgdt3306a_read_reg(state, 0x2135, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval &= 0x0f;\n\t\tval |= 0xa0;\n\t\tret = lgdt3306a_write_reg(state, 0x2135, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = lgdt3306a_read_reg(state, 0x2141, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval &= 0x3f;\n\t\tval |= 0x80;\n\t\tret = lgdt3306a_write_reg(state, 0x2141, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = lgdt3306a_write_reg(state, 0x2122, 0x70);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {  \n\t\tret = lgdt3306a_read_reg(state, 0x2135, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval &= 0x0f;\n\t\tval |= 0x70;\n\t\tret = lgdt3306a_write_reg(state, 0x2135, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = lgdt3306a_read_reg(state, 0x2141, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval &= 0x3f;\n\t\tval |= 0x40;\n\t\tret = lgdt3306a_write_reg(state, 0x2141, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = lgdt3306a_write_reg(state, 0x2122, 0x40);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic enum lgdt3306a_lock_status\nlgdt3306a_sync_lock_poll(struct lgdt3306a_state *state)\n{\n\tenum lgdt3306a_lock_status syncLockStatus = LG3306_UNLOCK;\n\tint\ti;\n\n\tfor (i = 0; i < 2; i++)\t{\n\t\tmsleep(30);\n\n\t\tsyncLockStatus = lgdt3306a_check_lock_status(state,\n\t\t\t\t\t\t\t     LG3306_SYNC_LOCK);\n\n\t\tif (syncLockStatus == LG3306_LOCK) {\n\t\t\tdbg_info(\"locked(%d)\\n\", i);\n\t\t\treturn LG3306_LOCK;\n\t\t}\n\t}\n\tdbg_info(\"not locked\\n\");\n\treturn LG3306_UNLOCK;\n}\n\nstatic enum lgdt3306a_lock_status\nlgdt3306a_fec_lock_poll(struct lgdt3306a_state *state)\n{\n\tenum lgdt3306a_lock_status FECLockStatus = LG3306_UNLOCK;\n\tint\ti;\n\n\tfor (i = 0; i < 2; i++)\t{\n\t\tmsleep(30);\n\n\t\tFECLockStatus = lgdt3306a_check_lock_status(state,\n\t\t\t\t\t\t\t    LG3306_FEC_LOCK);\n\n\t\tif (FECLockStatus == LG3306_LOCK) {\n\t\t\tdbg_info(\"locked(%d)\\n\", i);\n\t\t\treturn FECLockStatus;\n\t\t}\n\t}\n\tdbg_info(\"not locked\\n\");\n\treturn FECLockStatus;\n}\n\nstatic enum lgdt3306a_neverlock_status\nlgdt3306a_neverlock_poll(struct lgdt3306a_state *state)\n{\n\tenum lgdt3306a_neverlock_status NLLockStatus = LG3306_NL_FAIL;\n\tint\ti;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tmsleep(30);\n\n\t\tNLLockStatus = lgdt3306a_check_neverlock_status(state);\n\n\t\tif (NLLockStatus == LG3306_NL_LOCK) {\n\t\t\tdbg_info(\"NL_LOCK(%d)\\n\", i);\n\t\t\treturn NLLockStatus;\n\t\t}\n\t}\n\tdbg_info(\"NLLockStatus=%d\\n\", NLLockStatus);\n\treturn NLLockStatus;\n}\n\nstatic u8 lgdt3306a_get_packet_error(struct lgdt3306a_state *state)\n{\n\tu8 val;\n\tint ret;\n\n\tret = lgdt3306a_read_reg(state, 0x00fa, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic const u32 valx_x10[] = {\n\t10,  11,  13,  15,  17,  20,  25,  33,  41,  50,  59,  73,  87,  100\n};\nstatic const u32 log10x_x1000[] = {\n\t0,   41, 114, 176, 230, 301, 398, 518, 613, 699, 771, 863, 939, 1000\n};\n\nstatic u32 log10_x1000(u32 x)\n{\n\tu32 diff_val, step_val, step_log10;\n\tu32 log_val = 0;\n\tu32 i;\n\n\tif (x <= 0)\n\t\treturn -1000000;  \n\n\tif (x == 10)\n\t\treturn 0;  \n\n\tif (x < 10) {\n\t\twhile (x < 10) {\n\t\t\tx = x * 10;\n\t\t\tlog_val--;\n\t\t}\n\t} else {\t \n\t\twhile (x >= 100) {\n\t\t\tx = x / 10;\n\t\t\tlog_val++;\n\t\t}\n\t}\n\tlog_val *= 1000;\n\n\tif (x == 10)  \n\t\treturn log_val;\t \n\n\t \n\tfor (i = 1; i < ARRAY_SIZE(valx_x10); i++) {\n\t\tif (valx_x10[i] >= x)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(valx_x10))\n\t\treturn log_val + log10x_x1000[i - 1];\n\n\tdiff_val   = x - valx_x10[i-1];\n\tstep_val   = valx_x10[i] - valx_x10[i - 1];\n\tstep_log10 = log10x_x1000[i] - log10x_x1000[i - 1];\n\n\t \n\treturn log_val + log10x_x1000[i - 1] +\n\t\t((diff_val*step_log10) / step_val);\n}\n\nstatic u32 lgdt3306a_calculate_snr_x100(struct lgdt3306a_state *state)\n{\n\tu32 mse;  \n\tu32 pwr;  \n\tu32 snr_x100;\n\n\tmse = (read_reg(state, 0x00ec) << 8) |\n\t      (read_reg(state, 0x00ed));\n\tpwr = (read_reg(state, 0x00e8) << 8) |\n\t      (read_reg(state, 0x00e9));\n\n\tif (mse == 0)  \n\t\treturn 0;\n\n\tsnr_x100 = log10_x1000((pwr * 10000) / mse) - 3000;\n\tdbg_info(\"mse=%u, pwr=%u, snr_x100=%d\\n\", mse, pwr, snr_x100);\n\n\treturn snr_x100;\n}\n\nstatic enum lgdt3306a_lock_status\nlgdt3306a_vsb_lock_poll(struct lgdt3306a_state *state)\n{\n\tint ret;\n\tu8 cnt = 0;\n\tu8 packet_error;\n\tu32 snr;\n\n\tfor (cnt = 0; cnt < 10; cnt++) {\n\t\tif (lgdt3306a_sync_lock_poll(state) == LG3306_UNLOCK) {\n\t\t\tdbg_info(\"no sync lock!\\n\");\n\t\t\treturn LG3306_UNLOCK;\n\t\t}\n\n\t\tmsleep(20);\n\t\tret = lgdt3306a_pre_monitoring(state);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tpacket_error = lgdt3306a_get_packet_error(state);\n\t\tsnr = lgdt3306a_calculate_snr_x100(state);\n\t\tdbg_info(\"cnt=%d errors=%d snr=%d\\n\", cnt, packet_error, snr);\n\n\t\tif ((snr >= 1500) && (packet_error < 0xff))\n\t\t\treturn LG3306_LOCK;\n\t}\n\n\tdbg_info(\"not locked!\\n\");\n\treturn LG3306_UNLOCK;\n}\n\nstatic enum lgdt3306a_lock_status\nlgdt3306a_qam_lock_poll(struct lgdt3306a_state *state)\n{\n\tu8 cnt;\n\tu8 packet_error;\n\tu32\tsnr;\n\n\tfor (cnt = 0; cnt < 10; cnt++) {\n\t\tif (lgdt3306a_fec_lock_poll(state) == LG3306_UNLOCK) {\n\t\t\tdbg_info(\"no fec lock!\\n\");\n\t\t\treturn LG3306_UNLOCK;\n\t\t}\n\n\t\tmsleep(20);\n\n\t\tpacket_error = lgdt3306a_get_packet_error(state);\n\t\tsnr = lgdt3306a_calculate_snr_x100(state);\n\t\tdbg_info(\"cnt=%d errors=%d snr=%d\\n\", cnt, packet_error, snr);\n\n\t\tif ((snr >= 1500) && (packet_error < 0xff))\n\t\t\treturn LG3306_LOCK;\n\t}\n\n\tdbg_info(\"not locked!\\n\");\n\treturn LG3306_UNLOCK;\n}\n\nstatic int lgdt3306a_read_status(struct dvb_frontend *fe,\n\t\t\t\t enum fe_status *status)\n{\n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu16 strength = 0;\n\tint ret = 0;\n\n\tif (fe->ops.tuner_ops.get_rf_strength) {\n\t\tret = fe->ops.tuner_ops.get_rf_strength(fe, &strength);\n\t\tif (ret == 0)\n\t\t\tdbg_info(\"strength=%d\\n\", strength);\n\t\telse\n\t\t\tdbg_info(\"fe->ops.tuner_ops.get_rf_strength() failed\\n\");\n\t}\n\n\t*status = 0;\n\tif (lgdt3306a_neverlock_poll(state) == LG3306_NL_LOCK) {\n\t\t*status |= FE_HAS_SIGNAL;\n\t\t*status |= FE_HAS_CARRIER;\n\n\t\tswitch (state->current_modulation) {\n\t\tcase QAM_256:\n\t\tcase QAM_64:\n\t\tcase QAM_AUTO:\n\t\t\tif (lgdt3306a_qam_lock_poll(state) == LG3306_LOCK) {\n\t\t\t\t*status |= FE_HAS_VITERBI;\n\t\t\t\t*status |= FE_HAS_SYNC;\n\n\t\t\t\t*status |= FE_HAS_LOCK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VSB_8:\n\t\t\tif (lgdt3306a_vsb_lock_poll(state) == LG3306_LOCK) {\n\t\t\t\t*status |= FE_HAS_VITERBI;\n\t\t\t\t*status |= FE_HAS_SYNC;\n\n\t\t\t\t*status |= FE_HAS_LOCK;\n\n\t\t\t\tret = lgdt3306a_monitor_vsb(state);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tif (*status & FE_HAS_SYNC) {\n\t\t\tc->cnr.len = 1;\n\t\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\t\tc->cnr.stat[0].svalue = lgdt3306a_calculate_snr_x100(state) * 10;\n\t\t} else {\n\t\t\tc->cnr.len = 1;\n\t\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nstatic int lgdt3306a_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\n\tstate->snr = lgdt3306a_calculate_snr_x100(state);\n\t \n\t*snr = state->snr/10;\n\n\treturn 0;\n}\n\nstatic int lgdt3306a_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t\t u16 *strength)\n{\n\t \n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\tu8 val;\n\tu16 snr;  \n\tint ret;\n\tu32 ref_snr;  \n\tu32 str;\n\n\t*strength = 0;\n\n\tswitch (state->current_modulation) {\n\tcase VSB_8:\n\t\t ref_snr = 1600;  \n\t\t break;\n\tcase QAM_64:\n\tcase QAM_256:\n\tcase QAM_AUTO:\n\t\t \n\t\tret = lgdt3306a_read_reg(state, 0x00a6, &val);\n\t\tif (lg_chkerr(ret))\n\t\t\tgoto fail;\n\n\t\tif(val & 0x04)\n\t\t\tref_snr = 2800;  \n\t\telse\n\t\t\tref_snr = 2200;  \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = fe->ops.read_snr(fe, &snr);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\n\tif (state->snr <= (ref_snr - 100))\n\t\tstr = 0;\n\telse if (state->snr <= ref_snr)\n\t\tstr = (0xffff * 65) / 100;  \n\telse {\n\t\tstr = state->snr - ref_snr;\n\t\tstr /= 50;\n\t\tstr += 78;  \n\t\tif (str > 100)\n\t\t\tstr = 100;\n\t\tstr = (0xffff * str) / 100;\n\t}\n\t*strength = (u16)str;\n\tdbg_info(\"strength=%u\\n\", *strength);\n\nfail:\n\treturn ret;\n}\n\n \n\nstatic int lgdt3306a_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\tu32 tmp;\n\n\t*ber = 0;\n#if 1\n\t \n\ttmp =              read_reg(state, 0x00fc);  \n\ttmp = (tmp << 8) | read_reg(state, 0x00fd);  \n\ttmp = (tmp << 8) | read_reg(state, 0x00fe);  \n\ttmp = (tmp << 8) | read_reg(state, 0x00ff);  \n\t*ber = tmp;\n\tdbg_info(\"ber=%u\\n\", tmp);\n#endif\n\treturn 0;\n}\n\nstatic int lgdt3306a_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\n\t*ucblocks = 0;\n#if 1\n\t \n\t*ucblocks = read_reg(state, 0x00f4);  \n\tdbg_info(\"ucblocks=%u\\n\", *ucblocks);\n#endif\n\n\treturn 0;\n}\n\nstatic int lgdt3306a_tune(struct dvb_frontend *fe, bool re_tune,\n\t\t\t  unsigned int mode_flags, unsigned int *delay,\n\t\t\t  enum fe_status *status)\n{\n\tint ret = 0;\n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\n\tdbg_info(\"re_tune=%u\\n\", re_tune);\n\n\tif (re_tune) {\n\t\tstate->current_frequency = -1;  \n\t\tret = lgdt3306a_set_parameters(fe);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\t*delay = 125;\n\tret = lgdt3306a_read_status(fe, status);\n\n\treturn ret;\n}\n\nstatic int lgdt3306a_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t       struct dvb_frontend_tune_settings\n\t\t\t\t       *fe_tune_settings)\n{\n\tfe_tune_settings->min_delay_ms = 100;\n\tdbg_info(\"\\n\");\n\treturn 0;\n}\n\nstatic enum dvbfe_search lgdt3306a_search(struct dvb_frontend *fe)\n{\n\tenum fe_status status = 0;\n\tint ret;\n\n\t \n\tret = lgdt3306a_set_parameters(fe);\n\tif (ret)\n\t\tgoto error;\n\n\tret = lgdt3306a_read_status(fe, &status);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tif (status & FE_HAS_LOCK)\n\t\treturn DVBFE_ALGO_SEARCH_SUCCESS;\n\telse\n\t\treturn DVBFE_ALGO_SEARCH_AGAIN;\n\nerror:\n\tdbg_info(\"failed (%d)\\n\", ret);\n\treturn DVBFE_ALGO_SEARCH_ERROR;\n}\n\nstatic void lgdt3306a_release(struct dvb_frontend *fe)\n{\n\tstruct lgdt3306a_state *state = fe->demodulator_priv;\n\n\tdbg_info(\"\\n\");\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops lgdt3306a_ops;\n\nstruct dvb_frontend *lgdt3306a_attach(const struct lgdt3306a_config *config,\n\t\t\t\t      struct i2c_adapter *i2c_adap)\n{\n\tstruct lgdt3306a_state *state = NULL;\n\tint ret;\n\tu8 val;\n\n\tdbg_info(\"(%d-%04x)\\n\",\n\t       i2c_adap ? i2c_adapter_id(i2c_adap) : 0,\n\t       config ? config->i2c_addr : 0);\n\n\tstate = kzalloc(sizeof(struct lgdt3306a_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto fail;\n\n\tstate->cfg = config;\n\tstate->i2c_adap = i2c_adap;\n\n\tmemcpy(&state->frontend.ops, &lgdt3306a_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\t \n\t \n\tret = lgdt3306a_read_reg(state, 0x0000, &val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\tif ((val & 0x74) != 0x74) {\n\t\tpr_warn(\"expected 0x74, got 0x%x\\n\", (val & 0x74));\n#if 0\n\t\t \n\t\tgoto fail;\n#endif\n\t}\n\tret = lgdt3306a_read_reg(state, 0x0001, &val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\tif ((val & 0xf6) != 0xc6) {\n\t\tpr_warn(\"expected 0xc6, got 0x%x\\n\", (val & 0xf6));\n#if 0\n\t\t \n\t\tgoto fail;\n#endif\n\t}\n\tret = lgdt3306a_read_reg(state, 0x0002, &val);\n\tif (lg_chkerr(ret))\n\t\tgoto fail;\n\tif ((val & 0x73) != 0x03) {\n\t\tpr_warn(\"expected 0x03, got 0x%x\\n\", (val & 0x73));\n#if 0\n\t\t \n\t\tgoto fail;\n#endif\n\t}\n\n\tstate->current_frequency = -1;\n\tstate->current_modulation = -1;\n\n\tlgdt3306a_sleep(state);\n\n\treturn &state->frontend;\n\nfail:\n\tpr_warn(\"unable to detect LGDT3306A hardware\\n\");\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(lgdt3306a_attach);\n\n#ifdef DBG_DUMP\n\nstatic const short regtab[] = {\n\t0x0000,  \n\t0x0001,  \n\t0x0002,  \n\t0x0003,  \n\t0x0004,  \n\t0x0005,  \n\t0x0006,  \n\t0x0007,  \n\t0x0008,  \n\t0x0009,  \n\t0x000a,  \n\t0x000b,  \n\t0x000d,  \n\t0x000e,  \n\t0x000f,  \n\t0x0010,  \n\t0x0011,  \n\t0x0012,  \n\t0x0013,  \n\t0x0014,  \n\t0x0015,  \n\t0x0016,  \n\t0x0017,  \n\t0x0018,  \n\t0x0019,  \n\t0x001c,  \n\t0x001d,  \n\t0x001e,  \n\t0x001f,  \n\t0x0020,  \n\t0x0021,  \n\t0x0022,  \n\t0x0023,  \n\t0x0024,  \n\t0x0025,  \n\t0x0026,  \n\t0x0027,  \n\t0x0028,  \n\t0x0029,  \n\t0x002a,  \n\t0x002b,  \n\t0x002c,  \n\t0x002d,  \n\t0x002e,  \n\t0x002f,  \n\t0x0030,  \n\t0x0031,  \n\t0x0032,  \n\t0x0033,  \n\t0x0034,  \n\t0x0035,  \n\t0x0036,  \n\t0x0037,  \n\t0x0038,  \n\t0x003d,  \n\t0x0040,  \n\t0x0041,  \n\t0x0044,  \n\t0x0045,  \n\t0x0046,  \n\t0x0047,  \n\t0x0048,  \n\t0x0049,  \n\t0x004a,  \n\t0x0050,  \n\t0x0070,  \n\t0x0071,  \n\t0x0073,  \n\t0x0075,  \n\t0x0076,  \n\t0x0077,  \n\t0x0078,  \n\t0x0079,  \n\t0x007a,  \n\t0x007b,  \n\t0x007c,  \n\t0x007d,  \n\t0x007e,  \n\t0x007f,  \n\t0x0080,  \n\t0x0085,  \n\t0x0088,  \n\t0x0089,  \n\t0x008c,  \n\t0x008d,  \n\t0x008e,  \n\t0x008f,  \n\t0x0090,  \n\t0x0091,  \n\t0x009c,  \n\t0x009d,  \n\t0x00a1,  \n\t0x00a2,  \n\t0x00a3,  \n\t0x00a6,  \n#if 0  \n\t0x00e8,  \n\t0x00e9,  \n\t0x00ea,  \n\t0x00eb,  \n\t0x00ec,  \n\t0x00ed,  \n\t0x00ee,  \n\t0x00ef,  \n#endif\n\t0x00f4,  \n\t0x00f5,  \n\t0x00f6,  \n\t0x00f7,  \n\t0x00f8,  \n\t0x00f9,  \n\t0x00fa,  \n\t0x00fb,  \n\t0x00fc,  \n\t0x00fd,  \n\t0x00fe,  \n\t0x00ff,  \n\t0x1000,  \n\t0x1005,  \n\t0x1009,  \n\t0x100a,  \n\t0x101a,  \n\t0x1036,  \n\t0x103c,  \n\t0x103d,  \n\t0x103f,  \n\t0x105d,  \n\t0x105f,  \n\t0x1060,  \n\t0x1061,  \n\t0x1065,  \n\t0x1066,  \n\t0x1068,  \n\t0x106e,  \n\t0x106f,  \n\t0x1072,  \n\t0x1073,  \n\t0x1074,  \n\t0x1080,  \n\t0x1081,  \n\t0x10a9,  \n\t0x10b7,  \n#if 0  \n\t0x1f00,  \n\t0x1f01,  \n\t0x1f03,  \n\t0x1f04,  \n\t0x1f05,  \n\t0x1f06,  \n\t0x1f07,  \n\t0x1f09,  \n\t0x1f0a,  \n\t0x1f0b,  \n\t0x1f0c,  \n\t0x1f0d,  \n\t0x1f0e,  \n\t0x1f0f,  \n\t0x1f11,  \n\t0x1f12,  \n\t0x1f13,  \n\t0x1f14,  \n\t0x1f15,  \n\t0x1f16,  \n\t0x1f17,  \n\t0x1f19,  \n\t0x1f1a,  \n\t0x1f1b,  \n\t0x1f1d,  \n\t0x1f1f,  \n\t0x1f20,  \n\t0x1f21,  \n\t0x1f80,  \n\t0x1f81,  \n\t0x1f82,  \n\t0x1f83,  \n\t0x1f84,  \n\t0x1f85,  \n\t0x1f86,  \n\t0x1f87,  \n\t0x1f89,  \n\t0x1f8a,  \n\t0x1f8b,  \n\t0x1f8c,  \n\t0x1f8d,  \n\t0x1f8e,  \n\t0x1f8f,  \n\t0x1f91,  \n\t0x1f92,  \n\t0x1f93,  \n\t0x1f95,  \n\t0x1f96,  \n\t0x1f97,  \n#endif  \n\t0x211f,  \n\t0x212a,  \n\t0x2122,  \n\t0x212b,  \n\t0x212c,  \n\t0x212d,  \n\t0x2135,  \n\t0x2141,  \n\t0x2162,  \n\t0x2173,  \n\t0x2179,  \n\t0x217a,  \n\t0x217e,  \n\t0x217f,  \n\t0x2180,  \n\t0x2181,  \n\t0x2185,  \n\t0x2191,  \n\t0x2199,  \n\t0x219a,  \n\t0x21a1,  \n\t0x2845,  \n\t0x2846,  \n\t0x2847,  \n\t0x2849,  \n\t0x284a,  \n\t0x3000,  \n\t0x3001,  \n\t0x3031,  \n\t0x3032,  \n\t0x30a9,  \n\t0x30aa,  \n};\n\n#define numDumpRegs (ARRAY_SIZE(regtab))\nstatic u8 regval1[numDumpRegs] = {0, };\nstatic u8 regval2[numDumpRegs] = {0, };\n\nstatic void lgdt3306a_DumpAllRegs(struct lgdt3306a_state *state)\n{\n\t\tmemset(regval2, 0xff, sizeof(regval2));\n\t\tlgdt3306a_DumpRegs(state);\n}\n\nstatic void lgdt3306a_DumpRegs(struct lgdt3306a_state *state)\n{\n\tint i;\n\tint sav_debug = debug;\n\n\tif ((debug & DBG_DUMP) == 0)\n\t\treturn;\n\tdebug &= ~DBG_REG;  \n\n\tlg_debug(\"\\n\");\n\n\tfor (i = 0; i < numDumpRegs; i++) {\n\t\tlgdt3306a_read_reg(state, regtab[i], &regval1[i]);\n\t\tif (regval1[i] != regval2[i]) {\n\t\t\tlg_debug(\" %04X = %02X\\n\", regtab[i], regval1[i]);\n\t\t\tregval2[i] = regval1[i];\n\t\t}\n\t}\n\tdebug = sav_debug;\n}\n#endif  \n\n\n\nstatic const struct dvb_frontend_ops lgdt3306a_ops = {\n\t.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },\n\t.info = {\n\t\t.name = \"LG Electronics LGDT3306A VSB/QAM Frontend\",\n\t\t.frequency_min_hz      =  54 * MHz,\n\t\t.frequency_max_hz      = 858 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.caps = FE_CAN_QAM_AUTO | FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB\n\t},\n\t.i2c_gate_ctrl        = lgdt3306a_i2c_gate_ctrl,\n\t.init                 = lgdt3306a_init,\n\t.sleep                = lgdt3306a_fe_sleep,\n\t \n\t.tune                 = lgdt3306a_tune,\n\t.set_frontend         = lgdt3306a_set_parameters,\n\t.get_frontend         = lgdt3306a_get_frontend,\n\t.get_frontend_algo    = lgdt3306a_get_frontend_algo,\n\t.get_tune_settings    = lgdt3306a_get_tune_settings,\n\t.read_status          = lgdt3306a_read_status,\n\t.read_ber             = lgdt3306a_read_ber,\n\t.read_signal_strength = lgdt3306a_read_signal_strength,\n\t.read_snr             = lgdt3306a_read_snr,\n\t.read_ucblocks        = lgdt3306a_read_ucblocks,\n\t.release              = lgdt3306a_release,\n\t.ts_bus_ctrl          = lgdt3306a_ts_bus_ctrl,\n\t.search               = lgdt3306a_search,\n};\n\nstatic int lgdt3306a_select(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct i2c_client *client = i2c_mux_priv(muxc);\n\tstruct lgdt3306a_state *state = i2c_get_clientdata(client);\n\n\treturn lgdt3306a_i2c_gate_ctrl(&state->frontend, 1);\n}\n\nstatic int lgdt3306a_deselect(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct i2c_client *client = i2c_mux_priv(muxc);\n\tstruct lgdt3306a_state *state = i2c_get_clientdata(client);\n\n\treturn lgdt3306a_i2c_gate_ctrl(&state->frontend, 0);\n}\n\nstatic int lgdt3306a_probe(struct i2c_client *client)\n{\n\tstruct lgdt3306a_config *config;\n\tstruct lgdt3306a_state *state;\n\tstruct dvb_frontend *fe;\n\tint ret;\n\n\tconfig = kmemdup(client->dev.platform_data,\n\t\t\t sizeof(struct lgdt3306a_config), GFP_KERNEL);\n\tif (config == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tconfig->i2c_addr = client->addr;\n\tfe = lgdt3306a_attach(config, client->adapter);\n\tif (fe == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto err_fe;\n\t}\n\n\ti2c_set_clientdata(client, fe->demodulator_priv);\n\tstate = fe->demodulator_priv;\n\tstate->frontend.ops.release = NULL;\n\n\t \n\tstate->muxc = i2c_mux_alloc(client->adapter, &client->dev,\n\t\t\t\t  1, 0, I2C_MUX_LOCKED,\n\t\t\t\t  lgdt3306a_select, lgdt3306a_deselect);\n\tif (!state->muxc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_kfree;\n\t}\n\tstate->muxc->priv = client;\n\tret = i2c_mux_add_adapter(state->muxc, 0, 0, 0);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\t \n\tfe->ops.i2c_gate_ctrl = NULL;\n\t*config->i2c_adapter = state->muxc->adapter[0];\n\t*config->fe = fe;\n\n\tdev_info(&client->dev, \"LG Electronics LGDT3306A successfully identified\\n\");\n\n\treturn 0;\n\nerr_kfree:\n\tkfree(state);\nerr_fe:\n\tkfree(config);\nfail:\n\tdev_warn(&client->dev, \"probe failed = %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void lgdt3306a_remove(struct i2c_client *client)\n{\n\tstruct lgdt3306a_state *state = i2c_get_clientdata(client);\n\n\ti2c_mux_del_adapters(state->muxc);\n\n\tstate->frontend.ops.release = NULL;\n\tstate->frontend.demodulator_priv = NULL;\n\n\tkfree(state->cfg);\n\tkfree(state);\n}\n\nstatic const struct i2c_device_id lgdt3306a_id_table[] = {\n\t{\"lgdt3306a\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, lgdt3306a_id_table);\n\nstatic struct i2c_driver lgdt3306a_driver = {\n\t.driver = {\n\t\t.name                = \"lgdt3306a\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= lgdt3306a_probe,\n\t.remove\t\t= lgdt3306a_remove,\n\t.id_table\t= lgdt3306a_id_table,\n};\n\nmodule_i2c_driver(lgdt3306a_driver);\n\nMODULE_DESCRIPTION(\"LG Electronics LGDT3306A ATSC/QAM-B Demodulator Driver\");\nMODULE_AUTHOR(\"Fred Richter <frichter@hauppauge.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}