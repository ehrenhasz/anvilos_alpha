{
  "module_name": "ds3000.c",
  "hash_id": "9750e2f23e282bf14ded51f5cc9a2c16e696849a8d9d7b9f9b6966da4530a997",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/ds3000.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/firmware.h>\n\n#include <media/dvb_frontend.h>\n#include \"ts2020.h\"\n#include \"ds3000.h\"\n\nstatic int debug;\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(args); \\\n\t} while (0)\n\n \n \n#define DS3000_DEFAULT_FIRMWARE \"dvb-fe-ds3000.fw\"\n\n#define DS3000_SAMPLE_RATE 96000  \n\n \nstatic u8 ds3000_dvbs_init_tab[] = {\n\t0x23, 0x05,\n\t0x08, 0x03,\n\t0x0c, 0x00,\n\t0x21, 0x54,\n\t0x25, 0x82,\n\t0x27, 0x31,\n\t0x30, 0x08,\n\t0x31, 0x40,\n\t0x32, 0x32,\n\t0x33, 0x35,\n\t0x35, 0xff,\n\t0x3a, 0x00,\n\t0x37, 0x10,\n\t0x38, 0x10,\n\t0x39, 0x02,\n\t0x42, 0x60,\n\t0x4a, 0x40,\n\t0x4b, 0x04,\n\t0x4d, 0x91,\n\t0x5d, 0xc8,\n\t0x50, 0x77,\n\t0x51, 0x77,\n\t0x52, 0x36,\n\t0x53, 0x36,\n\t0x56, 0x01,\n\t0x63, 0x43,\n\t0x64, 0x30,\n\t0x65, 0x40,\n\t0x68, 0x26,\n\t0x69, 0x4c,\n\t0x70, 0x20,\n\t0x71, 0x70,\n\t0x72, 0x04,\n\t0x73, 0x00,\n\t0x70, 0x40,\n\t0x71, 0x70,\n\t0x72, 0x04,\n\t0x73, 0x00,\n\t0x70, 0x60,\n\t0x71, 0x70,\n\t0x72, 0x04,\n\t0x73, 0x00,\n\t0x70, 0x80,\n\t0x71, 0x70,\n\t0x72, 0x04,\n\t0x73, 0x00,\n\t0x70, 0xa0,\n\t0x71, 0x70,\n\t0x72, 0x04,\n\t0x73, 0x00,\n\t0x70, 0x1f,\n\t0x76, 0x00,\n\t0x77, 0xd1,\n\t0x78, 0x0c,\n\t0x79, 0x80,\n\t0x7f, 0x04,\n\t0x7c, 0x00,\n\t0x80, 0x86,\n\t0x81, 0xa6,\n\t0x85, 0x04,\n\t0xcd, 0xf4,\n\t0x90, 0x33,\n\t0xa0, 0x44,\n\t0xc0, 0x18,\n\t0xc3, 0x10,\n\t0xc4, 0x08,\n\t0xc5, 0x80,\n\t0xc6, 0x80,\n\t0xc7, 0x0a,\n\t0xc8, 0x1a,\n\t0xc9, 0x80,\n\t0xfe, 0x92,\n\t0xe0, 0xf8,\n\t0xe6, 0x8b,\n\t0xd0, 0x40,\n\t0xf8, 0x20,\n\t0xfa, 0x0f,\n\t0xfd, 0x20,\n\t0xad, 0x20,\n\t0xae, 0x07,\n\t0xb8, 0x00,\n};\n\n \nstatic u8 ds3000_dvbs2_init_tab[] = {\n\t0x23, 0x0f,\n\t0x08, 0x07,\n\t0x0c, 0x00,\n\t0x21, 0x54,\n\t0x25, 0x82,\n\t0x27, 0x31,\n\t0x30, 0x08,\n\t0x31, 0x32,\n\t0x32, 0x32,\n\t0x33, 0x35,\n\t0x35, 0xff,\n\t0x3a, 0x00,\n\t0x37, 0x10,\n\t0x38, 0x10,\n\t0x39, 0x02,\n\t0x42, 0x60,\n\t0x4a, 0x80,\n\t0x4b, 0x04,\n\t0x4d, 0x81,\n\t0x5d, 0x88,\n\t0x50, 0x36,\n\t0x51, 0x36,\n\t0x52, 0x36,\n\t0x53, 0x36,\n\t0x63, 0x60,\n\t0x64, 0x10,\n\t0x65, 0x10,\n\t0x68, 0x04,\n\t0x69, 0x29,\n\t0x70, 0x20,\n\t0x71, 0x70,\n\t0x72, 0x04,\n\t0x73, 0x00,\n\t0x70, 0x40,\n\t0x71, 0x70,\n\t0x72, 0x04,\n\t0x73, 0x00,\n\t0x70, 0x60,\n\t0x71, 0x70,\n\t0x72, 0x04,\n\t0x73, 0x00,\n\t0x70, 0x80,\n\t0x71, 0x70,\n\t0x72, 0x04,\n\t0x73, 0x00,\n\t0x70, 0xa0,\n\t0x71, 0x70,\n\t0x72, 0x04,\n\t0x73, 0x00,\n\t0x70, 0x1f,\n\t0xa0, 0x44,\n\t0xc0, 0x08,\n\t0xc1, 0x10,\n\t0xc2, 0x08,\n\t0xc3, 0x10,\n\t0xc4, 0x08,\n\t0xc5, 0xf0,\n\t0xc6, 0xf0,\n\t0xc7, 0x0a,\n\t0xc8, 0x1a,\n\t0xc9, 0x80,\n\t0xca, 0x23,\n\t0xcb, 0x24,\n\t0xce, 0x74,\n\t0x90, 0x03,\n\t0x76, 0x80,\n\t0x77, 0x42,\n\t0x78, 0x0a,\n\t0x79, 0x80,\n\t0xad, 0x40,\n\t0xae, 0x07,\n\t0x7f, 0xd4,\n\t0x7c, 0x00,\n\t0x80, 0xa8,\n\t0x81, 0xda,\n\t0x7c, 0x01,\n\t0x80, 0xda,\n\t0x81, 0xec,\n\t0x7c, 0x02,\n\t0x80, 0xca,\n\t0x81, 0xeb,\n\t0x7c, 0x03,\n\t0x80, 0xba,\n\t0x81, 0xdb,\n\t0x85, 0x08,\n\t0x86, 0x00,\n\t0x87, 0x02,\n\t0x89, 0x80,\n\t0x8b, 0x44,\n\t0x8c, 0xaa,\n\t0x8a, 0x10,\n\t0xba, 0x00,\n\t0xf5, 0x04,\n\t0xfe, 0x44,\n\t0xd2, 0x32,\n\t0xb8, 0x00,\n};\n\nstruct ds3000_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct ds3000_config *config;\n\tstruct dvb_frontend frontend;\n\t \n\tu16 prevUCBS2;\n};\n\nstatic int ds3000_writereg(struct ds3000_state *state, int reg, int data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address,\n\t\t.flags = 0, .buf = buf, .len = 2 };\n\tint err;\n\n\tdprintk(\"%s: write reg 0x%02x, value 0x%02x\\n\", __func__, reg, data);\n\n\terr = i2c_transfer(state->i2c, &msg, 1);\n\tif (err != 1) {\n\t\tprintk(KERN_ERR \"%s: writereg error(err == %i, reg == 0x%02x, value == 0x%02x)\\n\",\n\t\t       __func__, err, reg, data);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ds3000_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\n\tif (enable)\n\t\tds3000_writereg(state, 0x03, 0x12);\n\telse\n\t\tds3000_writereg(state, 0x03, 0x02);\n\n\treturn 0;\n}\n\n \nstatic int ds3000_writeFW(struct ds3000_state *state, int reg,\n\t\t\t\tconst u8 *data, u16 len)\n{\n\tint i, ret = 0;\n\tstruct i2c_msg msg;\n\tu8 *buf;\n\n\tbuf = kmalloc(33, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t*(buf) = reg;\n\n\tmsg.addr = state->config->demod_address;\n\tmsg.flags = 0;\n\tmsg.buf = buf;\n\tmsg.len = 33;\n\n\tfor (i = 0; i < len; i += 32) {\n\t\tmemcpy(buf + 1, data + i, 32);\n\n\t\tdprintk(\"%s: write reg 0x%02x, len = %d\\n\", __func__, reg, len);\n\n\t\tret = i2c_transfer(state->i2c, &msg, 1);\n\t\tif (ret != 1) {\n\t\t\tprintk(KERN_ERR \"%s: write error(err == %i, reg == 0x%02x\\n\",\n\t\t\t       __func__, ret, reg);\n\t\t\tret = -EREMOTEIO;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = 0;\n\nerror:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int ds3000_readreg(struct ds3000_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = state->config->demod_address,\n\t\t\t.flags = 0,\n\t\t\t.buf = b0,\n\t\t\t.len = 1\n\t\t}, {\n\t\t\t.addr = state->config->demod_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = b1,\n\t\t\t.len = 1\n\t\t}\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\tprintk(KERN_ERR \"%s: reg=0x%x(error=%d)\\n\", __func__, reg, ret);\n\t\treturn ret;\n\t}\n\n\tdprintk(\"%s: read reg 0x%02x, value 0x%02x\\n\", __func__, reg, b1[0]);\n\n\treturn b1[0];\n}\n\nstatic int ds3000_load_firmware(struct dvb_frontend *fe,\n\t\t\t\t\tconst struct firmware *fw);\n\nstatic int ds3000_firmware_ondemand(struct dvb_frontend *fe)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\tconst struct firmware *fw;\n\tint ret = 0;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tret = ds3000_readreg(state, 0xb2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t \n\tprintk(KERN_INFO \"%s: Waiting for firmware upload (%s)...\\n\", __func__,\n\t\t\t\tDS3000_DEFAULT_FIRMWARE);\n\tret = request_firmware(&fw, DS3000_DEFAULT_FIRMWARE,\n\t\t\t\tstate->i2c->dev.parent);\n\tprintk(KERN_INFO \"%s: Waiting for firmware upload(2)...\\n\", __func__);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: No firmware uploaded (timeout or file not found?)\\n\",\n\t\t       __func__);\n\t\treturn ret;\n\t}\n\n\tret = ds3000_load_firmware(fe, fw);\n\tif (ret)\n\t\tprintk(\"%s: Writing firmware to device failed\\n\", __func__);\n\n\trelease_firmware(fw);\n\n\tdprintk(\"%s: Firmware upload %s\\n\", __func__,\n\t\t\tret == 0 ? \"complete\" : \"failed\");\n\n\treturn ret;\n}\n\nstatic int ds3000_load_firmware(struct dvb_frontend *fe,\n\t\t\t\t\tconst struct firmware *fw)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\tint ret = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\tdprintk(\"Firmware is %zu bytes (%02x %02x .. %02x %02x)\\n\",\n\t\t\tfw->size,\n\t\t\tfw->data[0],\n\t\t\tfw->data[1],\n\t\t\tfw->data[fw->size - 2],\n\t\t\tfw->data[fw->size - 1]);\n\n\t \n\tds3000_writereg(state, 0xb2, 0x01);\n\t \n\tret = ds3000_writeFW(state, 0xb0, fw->data, fw->size);\n\tds3000_writereg(state, 0xb2, 0x00);\n\n\treturn ret;\n}\n\nstatic int ds3000_set_voltage(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_voltage voltage)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\tu8 data;\n\n\tdprintk(\"%s(%d)\\n\", __func__, voltage);\n\n\tdata = ds3000_readreg(state, 0xa2);\n\tdata |= 0x03;  \n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_18:\n\t\tdata &= ~0x03;\n\t\tbreak;\n\tcase SEC_VOLTAGE_13:\n\t\tdata &= ~0x03;\n\t\tdata |= 0x01;\n\t\tbreak;\n\tcase SEC_VOLTAGE_OFF:\n\t\tbreak;\n\t}\n\n\tds3000_writereg(state, 0xa2, data);\n\n\treturn 0;\n}\n\nstatic int ds3000_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint lock;\n\n\t*status = 0;\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\tlock = ds3000_readreg(state, 0xd1);\n\t\tif ((lock & 0x07) == 0x07)\n\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\tFE_HAS_VITERBI | FE_HAS_SYNC |\n\t\t\t\tFE_HAS_LOCK;\n\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tlock = ds3000_readreg(state, 0x0d);\n\t\tif ((lock & 0x8f) == 0x8f)\n\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\tFE_HAS_VITERBI | FE_HAS_SYNC |\n\t\t\t\tFE_HAS_LOCK;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (state->config->set_lock_led)\n\t\tstate->config->set_lock_led(fe, *status == 0 ? 0 : 1);\n\n\tdprintk(\"%s: status = 0x%02x\\n\", __func__, lock);\n\n\treturn 0;\n}\n\n \nstatic int ds3000_read_ber(struct dvb_frontend *fe, u32* ber)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu8 data;\n\tu32 ber_reading, lpdc_frames;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\t \n\t\tds3000_writereg(state, 0xf9, 0x04);\n\t\t \n\t\tdata = ds3000_readreg(state, 0xf8);\n\t\t \n\t\tif ((data & 0x10) == 0) {\n\t\t\t \n\t\t\t*ber = (ds3000_readreg(state, 0xf7) << 8) |\n\t\t\t\tds3000_readreg(state, 0xf6);\n\t\t\t \n\t\t\t \n\t\t\tdata |= 0x10;\n\t\t\tds3000_writereg(state, 0xf8, data);\n\t\t\tds3000_writereg(state, 0xf8, data);\n\t\t} else\n\t\t\t \n\t\t\t*ber = 0xffffffff;\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\t \n\t\tlpdc_frames = (ds3000_readreg(state, 0xd7) << 16) |\n\t\t\t\t(ds3000_readreg(state, 0xd6) << 8) |\n\t\t\t\tds3000_readreg(state, 0xd5);\n\t\t \n\t\tber_reading = (ds3000_readreg(state, 0xf8) << 8) |\n\t\t\t\tds3000_readreg(state, 0xf7);\n\t\tif (lpdc_frames > 750) {\n\t\t\t \n\t\t\tds3000_writereg(state, 0xd1, 0x01);\n\t\t\t \n\t\t\tds3000_writereg(state, 0xf9, 0x01);\n\t\t\t \n\t\t\tds3000_writereg(state, 0xf9, 0x00);\n\t\t\t \n\t\t\tds3000_writereg(state, 0xd1, 0x00);\n\t\t\t*ber = ber_reading;\n\t\t} else\n\t\t\t \n\t\t\t*ber = 0xffffffff;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ds3000_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t\t\tu16 *signal_strength)\n{\n\tif (fe->ops.tuner_ops.get_rf_strength)\n\t\tfe->ops.tuner_ops.get_rf_strength(fe, signal_strength);\n\n\treturn 0;\n}\n\n \nstatic int ds3000_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu8 snr_reading, snr_value;\n\tu32 dvbs2_signal_reading, dvbs2_noise_reading, tmp;\n\tstatic const u16 dvbs_snr_tab[] = {  \n\t\t0x0000, 0x1b13, 0x2aea, 0x3627, 0x3ede, 0x45fe, 0x4c03,\n\t\t0x513a, 0x55d4, 0x59f2, 0x5dab, 0x6111, 0x6431, 0x6717,\n\t\t0x69c9, 0x6c4e, 0x6eac, 0x70e8, 0x7304, 0x7505\n\t};\n\tstatic const u16 dvbs2_snr_tab[] = {  \n\t\t0x0000, 0x0bc2, 0x12a3, 0x1785, 0x1b4e, 0x1e65, 0x2103,\n\t\t0x2347, 0x2546, 0x2710, 0x28ae, 0x2a28, 0x2b83, 0x2cc5,\n\t\t0x2df1, 0x2f09, 0x3010, 0x3109, 0x31f4, 0x32d2, 0x33a6,\n\t\t0x3470, 0x3531, 0x35ea, 0x369b, 0x3746, 0x37ea, 0x3888,\n\t\t0x3920, 0x39b3, 0x3a42, 0x3acc, 0x3b51, 0x3bd3, 0x3c51,\n\t\t0x3ccb, 0x3d42, 0x3db6, 0x3e27, 0x3e95, 0x3f00, 0x3f68,\n\t\t0x3fcf, 0x4033, 0x4094, 0x40f4, 0x4151, 0x41ac, 0x4206,\n\t\t0x425e, 0x42b4, 0x4308, 0x435b, 0x43ac, 0x43fc, 0x444a,\n\t\t0x4497, 0x44e2, 0x452d, 0x4576, 0x45bd, 0x4604, 0x4649,\n\t\t0x468e, 0x46d1, 0x4713, 0x4755, 0x4795, 0x47d4, 0x4813,\n\t\t0x4851, 0x488d, 0x48c9, 0x4904, 0x493f, 0x4978, 0x49b1,\n\t\t0x49e9, 0x4a20, 0x4a57\n\t};\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\tsnr_reading = ds3000_readreg(state, 0xff);\n\t\tsnr_reading /= 8;\n\t\tif (snr_reading == 0)\n\t\t\t*snr = 0x0000;\n\t\telse {\n\t\t\tif (snr_reading > 20)\n\t\t\t\tsnr_reading = 20;\n\t\t\tsnr_value = dvbs_snr_tab[snr_reading - 1] * 10 / 23026;\n\t\t\t \n\t\t\t*snr = snr_value * 8 * 655;\n\t\t}\n\t\tdprintk(\"%s: raw / cooked = 0x%02x / 0x%04x\\n\", __func__,\n\t\t\t\tsnr_reading, *snr);\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tdvbs2_noise_reading = (ds3000_readreg(state, 0x8c) & 0x3f) +\n\t\t\t\t(ds3000_readreg(state, 0x8d) << 4);\n\t\tdvbs2_signal_reading = ds3000_readreg(state, 0x8e);\n\t\ttmp = dvbs2_signal_reading * dvbs2_signal_reading >> 1;\n\t\tif (tmp == 0) {\n\t\t\t*snr = 0x0000;\n\t\t\treturn 0;\n\t\t}\n\t\tif (dvbs2_noise_reading == 0) {\n\t\t\tsnr_value = 0x0013;\n\t\t\t \n\t\t\t*snr = 0xffff;\n\t\t\treturn 0;\n\t\t}\n\t\tif (tmp > dvbs2_noise_reading) {\n\t\t\tsnr_reading = tmp / dvbs2_noise_reading;\n\t\t\tif (snr_reading > 80)\n\t\t\t\tsnr_reading = 80;\n\t\t\tsnr_value = dvbs2_snr_tab[snr_reading - 1] / 1000;\n\t\t\t \n\t\t\t*snr = snr_value * 5 * 655;\n\t\t} else {\n\t\t\tsnr_reading = dvbs2_noise_reading / tmp;\n\t\t\tif (snr_reading > 80)\n\t\t\t\tsnr_reading = 80;\n\t\t\t*snr = -(dvbs2_snr_tab[snr_reading - 1] / 1000);\n\t\t}\n\t\tdprintk(\"%s: raw / cooked = 0x%02x / 0x%04x\\n\", __func__,\n\t\t\t\tsnr_reading, *snr);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ds3000_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu8 data;\n\tu16 _ucblocks;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\t*ucblocks = (ds3000_readreg(state, 0xf5) << 8) |\n\t\t\t\tds3000_readreg(state, 0xf4);\n\t\tdata = ds3000_readreg(state, 0xf8);\n\t\t \n\t\tdata &= ~0x20;\n\t\tds3000_writereg(state, 0xf8, data);\n\t\t \n\t\tdata |= 0x20;\n\t\tds3000_writereg(state, 0xf8, data);\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\t_ucblocks = (ds3000_readreg(state, 0xe2) << 8) |\n\t\t\t\tds3000_readreg(state, 0xe1);\n\t\tif (_ucblocks > state->prevUCBS2)\n\t\t\t*ucblocks = _ucblocks - state->prevUCBS2;\n\t\telse\n\t\t\t*ucblocks = state->prevUCBS2 - _ucblocks;\n\t\tstate->prevUCBS2 = _ucblocks;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ds3000_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\tu8 data;\n\n\tdprintk(\"%s(%d)\\n\", __func__, tone);\n\tif ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {\n\t\tprintk(KERN_ERR \"%s: Invalid, tone=%d\\n\", __func__, tone);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = ds3000_readreg(state, 0xa2);\n\tdata &= ~0xc0;\n\tds3000_writereg(state, 0xa2, data);\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\tdprintk(\"%s: setting tone on\\n\", __func__);\n\t\tdata = ds3000_readreg(state, 0xa1);\n\t\tdata &= ~0x43;\n\t\tdata |= 0x04;\n\t\tds3000_writereg(state, 0xa1, data);\n\t\tbreak;\n\tcase SEC_TONE_OFF:\n\t\tdprintk(\"%s: setting tone off\\n\", __func__);\n\t\tdata = ds3000_readreg(state, 0xa2);\n\t\tdata |= 0x80;\n\t\tds3000_writereg(state, 0xa2, data);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ds3000_send_diseqc_msg(struct dvb_frontend *fe,\n\t\t\t\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\tint i;\n\tu8 data;\n\n\t \n\tdprintk(\"%s(\", __func__);\n\tfor (i = 0 ; i < d->msg_len;) {\n\t\tdprintk(\"0x%02x\", d->msg[i]);\n\t\tif (++i < d->msg_len)\n\t\t\tdprintk(\", \");\n\t}\n\n\t \n\tdata = ds3000_readreg(state, 0xa2);\n\tdata &= ~0xc0;\n\tds3000_writereg(state, 0xa2, data);\n\n\t \n\tfor (i = 0; i < d->msg_len; i++)\n\t\tds3000_writereg(state, 0xa3 + i, d->msg[i]);\n\n\tdata = ds3000_readreg(state, 0xa1);\n\t \n\tdata &= ~0xf8;\n\t \n\tdata |= ((d->msg_len - 1) << 3) | 0x07;\n\tds3000_writereg(state, 0xa1, data);\n\n\t \n\tfor (i = 0; i < 15; i++) {\n\t\tdata = ds3000_readreg(state, 0xa1);\n\t\tif ((data & 0x40) == 0)\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\n\t \n\tif (i == 15) {\n\t\tdata = ds3000_readreg(state, 0xa1);\n\t\tdata &= ~0x80;\n\t\tdata |= 0x40;\n\t\tds3000_writereg(state, 0xa1, data);\n\n\t\tdata = ds3000_readreg(state, 0xa2);\n\t\tdata &= ~0xc0;\n\t\tdata |= 0x80;\n\t\tds3000_writereg(state, 0xa2, data);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdata = ds3000_readreg(state, 0xa2);\n\tdata &= ~0xc0;\n\tdata |= 0x80;\n\tds3000_writereg(state, 0xa2, data);\n\n\treturn 0;\n}\n\n \nstatic int ds3000_diseqc_send_burst(struct dvb_frontend *fe,\n\t\t\t\t    enum fe_sec_mini_cmd burst)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\tint i;\n\tu8 data;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tdata = ds3000_readreg(state, 0xa2);\n\tdata &= ~0xc0;\n\tds3000_writereg(state, 0xa2, data);\n\n\t \n\tif (burst == SEC_MINI_A)\n\t\t \n\t\tds3000_writereg(state, 0xa1, 0x02);\n\telse if (burst == SEC_MINI_B)\n\t\t \n\t\tds3000_writereg(state, 0xa1, 0x01);\n\telse\n\t\treturn -EINVAL;\n\n\tmsleep(13);\n\tfor (i = 0; i < 5; i++) {\n\t\tdata = ds3000_readreg(state, 0xa1);\n\t\tif ((data & 0x40) == 0)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\tif (i == 5) {\n\t\tdata = ds3000_readreg(state, 0xa1);\n\t\tdata &= ~0x80;\n\t\tdata |= 0x40;\n\t\tds3000_writereg(state, 0xa1, data);\n\n\t\tdata = ds3000_readreg(state, 0xa2);\n\t\tdata &= ~0xc0;\n\t\tdata |= 0x80;\n\t\tds3000_writereg(state, 0xa2, data);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdata = ds3000_readreg(state, 0xa2);\n\tdata &= ~0xc0;\n\tdata |= 0x80;\n\tds3000_writereg(state, 0xa2, data);\n\n\treturn 0;\n}\n\nstatic void ds3000_release(struct dvb_frontend *fe)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\n\tif (state->config->set_lock_led)\n\t\tstate->config->set_lock_led(fe, 0);\n\n\tdprintk(\"%s\\n\", __func__);\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops ds3000_ops;\n\nstruct dvb_frontend *ds3000_attach(const struct ds3000_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct ds3000_state *state;\n\tint ret;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->prevUCBS2 = 0;\n\n\t \n\tret = ds3000_readreg(state, 0x00) & 0xfe;\n\tif (ret != 0xe0) {\n\t\tkfree(state);\n\t\tprintk(KERN_ERR \"Invalid probe, probably not a DS3000\\n\");\n\t\treturn NULL;\n\t}\n\n\tprintk(KERN_INFO \"DS3000 chip version: %d.%d attached.\\n\",\n\t\t\tds3000_readreg(state, 0x02),\n\t\t\tds3000_readreg(state, 0x01));\n\n\tmemcpy(&state->frontend.ops, &ds3000_ops,\n\t\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\t \n\tds3000_set_voltage(&state->frontend, SEC_VOLTAGE_OFF);\n\treturn &state->frontend;\n}\nEXPORT_SYMBOL_GPL(ds3000_attach);\n\nstatic int ds3000_set_carrier_offset(struct dvb_frontend *fe,\n\t\t\t\t\ts32 carrier_offset_khz)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\ts32 tmp;\n\n\ttmp = carrier_offset_khz;\n\ttmp *= 65536;\n\ttmp = (2 * tmp + DS3000_SAMPLE_RATE) / (2 * DS3000_SAMPLE_RATE);\n\n\tif (tmp < 0)\n\t\ttmp += 65536;\n\n\tds3000_writereg(state, 0x5f, tmp >> 8);\n\tds3000_writereg(state, 0x5e, tmp & 0xff);\n\n\treturn 0;\n}\n\nstatic int ds3000_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tint i;\n\tenum fe_status status;\n\ts32 offset_khz;\n\tu32 frequency;\n\tu16 value;\n\n\tdprintk(\"%s() \", __func__);\n\n\tif (state->config->set_ts_params)\n\t\tstate->config->set_ts_params(fe, 0);\n\t \n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\n\t \n\tds3000_writereg(state, 0x07, 0x80);\n\tds3000_writereg(state, 0x07, 0x00);\n\t \n\tds3000_writereg(state, 0xb2, 0x01);\n\t \n\tds3000_writereg(state, 0x00, 0x01);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\t \n\t\tfor (i = 0; i < sizeof(ds3000_dvbs_init_tab); i += 2)\n\t\t\tds3000_writereg(state,\n\t\t\t\tds3000_dvbs_init_tab[i],\n\t\t\t\tds3000_dvbs_init_tab[i + 1]);\n\t\tvalue = ds3000_readreg(state, 0xfe);\n\t\tvalue &= 0xc0;\n\t\tvalue |= 0x1b;\n\t\tds3000_writereg(state, 0xfe, value);\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\t \n\t\tfor (i = 0; i < sizeof(ds3000_dvbs2_init_tab); i += 2)\n\t\t\tds3000_writereg(state,\n\t\t\t\tds3000_dvbs2_init_tab[i],\n\t\t\t\tds3000_dvbs2_init_tab[i + 1]);\n\t\tif (c->symbol_rate >= 30000000)\n\t\t\tds3000_writereg(state, 0xfe, 0x54);\n\t\telse\n\t\t\tds3000_writereg(state, 0xfe, 0x98);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tds3000_writereg(state, 0x29, 0x80);\n\t \n\tds3000_writereg(state, 0x25, 0x8a);\n\n\tif ((c->symbol_rate < ds3000_ops.info.symbol_rate_min) ||\n\t\t\t(c->symbol_rate > ds3000_ops.info.symbol_rate_max)) {\n\t\tdprintk(\"%s() symbol_rate %u out of range (%u ... %u)\\n\",\n\t\t\t\t__func__, c->symbol_rate,\n\t\t\t\tds3000_ops.info.symbol_rate_min,\n\t\t\t\tds3000_ops.info.symbol_rate_max);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((c->symbol_rate / 1000) <= 5000) {\n\t\tvalue = 29777 / (c->symbol_rate / 1000) + 1;\n\t\tif (value % 2 != 0)\n\t\t\tvalue++;\n\t\tds3000_writereg(state, 0xc3, 0x0d);\n\t\tds3000_writereg(state, 0xc8, value);\n\t\tds3000_writereg(state, 0xc4, 0x10);\n\t\tds3000_writereg(state, 0xc7, 0x0e);\n\t} else if ((c->symbol_rate / 1000) <= 10000) {\n\t\tvalue = 92166 / (c->symbol_rate / 1000) + 1;\n\t\tif (value % 2 != 0)\n\t\t\tvalue++;\n\t\tds3000_writereg(state, 0xc3, 0x07);\n\t\tds3000_writereg(state, 0xc8, value);\n\t\tds3000_writereg(state, 0xc4, 0x09);\n\t\tds3000_writereg(state, 0xc7, 0x12);\n\t} else if ((c->symbol_rate / 1000) <= 20000) {\n\t\tvalue = 64516 / (c->symbol_rate / 1000) + 1;\n\t\tds3000_writereg(state, 0xc3, value);\n\t\tds3000_writereg(state, 0xc8, 0x0e);\n\t\tds3000_writereg(state, 0xc4, 0x07);\n\t\tds3000_writereg(state, 0xc7, 0x18);\n\t} else {\n\t\tvalue = 129032 / (c->symbol_rate / 1000) + 1;\n\t\tds3000_writereg(state, 0xc3, value);\n\t\tds3000_writereg(state, 0xc8, 0x0a);\n\t\tds3000_writereg(state, 0xc4, 0x05);\n\t\tds3000_writereg(state, 0xc7, 0x24);\n\t}\n\n\t \n\tvalue = (((c->symbol_rate / 1000) << 16) +\n\t\t\t(DS3000_SAMPLE_RATE / 2)) / DS3000_SAMPLE_RATE;\n\tds3000_writereg(state, 0x61, value & 0x00ff);\n\tds3000_writereg(state, 0x62, (value & 0xff00) >> 8);\n\n\t \n\tds3000_writereg(state, 0x56, 0x00);\n\n\t \n\tds3000_writereg(state, 0x76, 0x00);\n\n\t \n\n\tif (state->config->ci_mode) {\n\t\tswitch (c->delivery_system) {\n\t\tcase SYS_DVBS:\n\t\tdefault:\n\t\t\tds3000_writereg(state, 0xfd, 0x80);\n\t\tbreak;\n\t\tcase SYS_DVBS2:\n\t\t\tds3000_writereg(state, 0xfd, 0x01);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tds3000_writereg(state, 0x00, 0x00);\n\t \n\tds3000_writereg(state, 0xb2, 0x00);\n\n\tif (fe->ops.tuner_ops.get_frequency) {\n\t\tfe->ops.tuner_ops.get_frequency(fe, &frequency);\n\t\toffset_khz = frequency - c->frequency;\n\t\tds3000_set_carrier_offset(fe, offset_khz);\n\t}\n\n\tfor (i = 0; i < 30 ; i++) {\n\t\tds3000_read_status(fe, &status);\n\t\tif (status & FE_HAS_LOCK)\n\t\t\tbreak;\n\n\t\tmsleep(10);\n\t}\n\n\treturn 0;\n}\n\nstatic int ds3000_tune(struct dvb_frontend *fe,\n\t\t\tbool re_tune,\n\t\t\tunsigned int mode_flags,\n\t\t\tunsigned int *delay,\n\t\t\tenum fe_status *status)\n{\n\tif (re_tune) {\n\t\tint ret = ds3000_set_frontend(fe);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*delay = HZ / 5;\n\n\treturn ds3000_read_status(fe, status);\n}\n\nstatic enum dvbfe_algo ds3000_get_algo(struct dvb_frontend *fe)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\n\tif (state->config->set_lock_led)\n\t\tstate->config->set_lock_led(fe, 0);\n\n\tdprintk(\"%s()\\n\", __func__);\n\treturn DVBFE_ALGO_HW;\n}\n\n \nstatic int ds3000_initfe(struct dvb_frontend *fe)\n{\n\tstruct ds3000_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\t \n\tds3000_writereg(state, 0x08, 0x01 | ds3000_readreg(state, 0x08));\n\tmsleep(1);\n\n\t \n\tret = ds3000_firmware_ondemand(fe);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"%s: Unable initialize firmware\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops ds3000_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2 },\n\t.info = {\n\t\t.name = \"Montage Technology DS3000\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t\t.frequency_stepsize_hz = 1011 * kHz,\n\t\t.frequency_tolerance_hz = 5 * MHz,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |\n\t\t\tFE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_2G_MODULATION |\n\t\t\tFE_CAN_QPSK | FE_CAN_RECOVER\n\t},\n\n\t.release = ds3000_release,\n\n\t.init = ds3000_initfe,\n\t.i2c_gate_ctrl = ds3000_i2c_gate_ctrl,\n\t.read_status = ds3000_read_status,\n\t.read_ber = ds3000_read_ber,\n\t.read_signal_strength = ds3000_read_signal_strength,\n\t.read_snr = ds3000_read_snr,\n\t.read_ucblocks = ds3000_read_ucblocks,\n\t.set_voltage = ds3000_set_voltage,\n\t.set_tone = ds3000_set_tone,\n\t.diseqc_send_master_cmd = ds3000_send_diseqc_msg,\n\t.diseqc_send_burst = ds3000_diseqc_send_burst,\n\t.get_frontend_algo = ds3000_get_algo,\n\n\t.set_frontend = ds3000_set_frontend,\n\t.tune = ds3000_tune,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Activates frontend debugging (default:0)\");\n\nMODULE_DESCRIPTION(\"DVB Frontend module for Montage Technology DS3000 hardware\");\nMODULE_AUTHOR(\"Konstantin Dimitrov <kosio.dimitrov@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(DS3000_DEFAULT_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}