{
  "module_name": "or51132.c",
  "hash_id": "703cd8af9dbe5fd34dad8121cd009720a5b90b6be0977bd9f6204fe9f3a3d0a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/or51132.c",
  "human_readable_source": "\n \n\n \n#define OR51132_VSB_FIRMWARE \"dvb-fe-or51132-vsb.fw\"\n#define OR51132_QAM_FIRMWARE \"dvb-fe-or51132-qam.fw\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <asm/byteorder.h>\n\n#include <linux/int_log.h>\n#include <media/dvb_frontend.h>\n#include \"or51132.h\"\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) printk(KERN_DEBUG \"or51132: \" args); \\\n\t} while (0)\n\n\nstruct or51132_state\n{\n\tstruct i2c_adapter* i2c;\n\n\t \n\tconst struct or51132_config* config;\n\n\tstruct dvb_frontend frontend;\n\n\t \n\tenum fe_modulation current_modulation;\n\tu32 snr;  \n\n\t \n\tu32 current_frequency;\n};\n\n\n \nstatic int or51132_writebuf(struct or51132_state *state, const u8 *buf, int len)\n{\n\tint err;\n\tstruct i2c_msg msg = { .addr = state->config->demod_address,\n\t\t\t       .flags = 0, .buf = (u8*)buf, .len = len };\n\n\t   \n\tif ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {\n\t\tprintk(KERN_WARNING \"or51132: I2C write (addr 0x%02x len %d) error: %d\\n\",\n\t\t       msg.addr, msg.len, err);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\n \n#define or51132_writebytes(state, data...)  \\\n\t({ static const u8 _data[] = {data}; \\\n\tor51132_writebuf(state, _data, sizeof(_data)); })\n\n \nstatic int or51132_readbuf(struct or51132_state *state, u8 *buf, int len)\n{\n\tint err;\n\tstruct i2c_msg msg = { .addr = state->config->demod_address,\n\t\t\t       .flags = I2C_M_RD, .buf = buf, .len = len };\n\n\t   \n\tif ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {\n\t\tprintk(KERN_WARNING \"or51132: I2C read (addr 0x%02x len %d) error: %d\\n\",\n\t\t       msg.addr, msg.len, err);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int or51132_readreg(struct or51132_state *state, u8 reg)\n{\n\tu8 buf[2] = { 0x04, reg };\n\tstruct i2c_msg msg[2] = {\n\t\t{.addr = state->config->demod_address, .flags = 0,\n\t\t .buf = buf, .len = 2 },\n\t\t{.addr = state->config->demod_address, .flags = I2C_M_RD,\n\t\t .buf = buf, .len = 2 }};\n\tint err;\n\n\tif ((err = i2c_transfer(state->i2c, msg, 2)) != 2) {\n\t\tprintk(KERN_WARNING \"or51132: I2C error reading register %d: %d\\n\",\n\t\t       reg, err);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn buf[0] | (buf[1] << 8);\n}\n\nstatic int or51132_load_firmware (struct dvb_frontend* fe, const struct firmware *fw)\n{\n\tstruct or51132_state* state = fe->demodulator_priv;\n\tstatic const u8 run_buf[] = {0x7F,0x01};\n\tu8 rec_buf[8];\n\tu32 firmwareAsize, firmwareBsize;\n\tint i,ret;\n\n\tdprintk(\"Firmware is %zd bytes\\n\",fw->size);\n\n\t \n\tfirmwareAsize = le32_to_cpu(*((__le32*)fw->data));\n\tdprintk(\"FirmwareA is %i bytes\\n\",firmwareAsize);\n\tfirmwareBsize = le32_to_cpu(*((__le32*)(fw->data+4)));\n\tdprintk(\"FirmwareB is %i bytes\\n\",firmwareBsize);\n\n\t \n\tif ((ret = or51132_writebuf(state, &fw->data[8], firmwareAsize))) {\n\t\tprintk(KERN_WARNING \"or51132: load_firmware error 1\\n\");\n\t\treturn ret;\n\t}\n\tif ((ret = or51132_writebuf(state, &fw->data[8+firmwareAsize],\n\t\t\t\t    firmwareBsize))) {\n\t\tprintk(KERN_WARNING \"or51132: load_firmware error 2\\n\");\n\t\treturn ret;\n\t}\n\n\tif ((ret = or51132_writebuf(state, run_buf, 2))) {\n\t\tprintk(KERN_WARNING \"or51132: load_firmware error 3\\n\");\n\t\treturn ret;\n\t}\n\tif ((ret = or51132_writebuf(state, run_buf, 2))) {\n\t\tprintk(KERN_WARNING \"or51132: load_firmware error 4\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tmsleep(50);\n\n\t \n\t \n\tif ((ret = or51132_writebytes(state, 0x10, 0x10, 0x00))) {\n\t\tprintk(KERN_WARNING \"or51132: load_firmware error a\\n\");\n\t\treturn ret;\n\t}\n\tif ((ret = or51132_writebytes(state, 0x04, 0x17))) {\n\t\tprintk(KERN_WARNING \"or51132: load_firmware error b\\n\");\n\t\treturn ret;\n\t}\n\tif ((ret = or51132_writebytes(state, 0x00, 0x00))) {\n\t\tprintk(KERN_WARNING \"or51132: load_firmware error c\\n\");\n\t\treturn ret;\n\t}\n\tfor (i=0;i<4;i++) {\n\t\t \n\t\t \n\t\tif ((ret = or51132_readbuf(state, &rec_buf[i*2], 2))) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"or51132: load_firmware error d - %d\\n\",i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tprintk(KERN_WARNING\n\t       \"or51132: Version: %02X%02X%02X%02X-%02X%02X%02X%02X (%02X%01X-%01X-%02X%01X-%01X)\\n\",\n\t       rec_buf[1],rec_buf[0],rec_buf[3],rec_buf[2],\n\t       rec_buf[5],rec_buf[4],rec_buf[7],rec_buf[6],\n\t       rec_buf[3],rec_buf[2]>>4,rec_buf[2]&0x0f,\n\t       rec_buf[5],rec_buf[4]>>4,rec_buf[4]&0x0f);\n\n\tif ((ret = or51132_writebytes(state, 0x10, 0x00, 0x00))) {\n\t\tprintk(KERN_WARNING \"or51132: load_firmware error e\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n};\n\nstatic int or51132_init(struct dvb_frontend* fe)\n{\n\treturn 0;\n}\n\nstatic int or51132_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\t*ber = 0;\n\treturn 0;\n}\n\nstatic int or51132_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\t*ucblocks = 0;\n\treturn 0;\n}\n\nstatic int or51132_sleep(struct dvb_frontend* fe)\n{\n\treturn 0;\n}\n\nstatic int or51132_setmode(struct dvb_frontend* fe)\n{\n\tstruct or51132_state* state = fe->demodulator_priv;\n\tu8 cmd_buf1[3] = {0x04, 0x01, 0x5f};\n\tu8 cmd_buf2[3] = {0x1c, 0x00, 0 };\n\n\tdprintk(\"setmode %d\\n\",(int)state->current_modulation);\n\n\tswitch (state->current_modulation) {\n\tcase VSB_8:\n\t\t \n\t\tcmd_buf1[2] = 0x50;\n\t\t \n\t\tcmd_buf2[1] = 0x03;\n\t\t \n\t\tcmd_buf2[2] = 0x06;\n\t\tbreak;\n\t \n\tcase QAM_AUTO:\n\t\t \n\t\tcmd_buf2[2] = 0x4f;\n\t\tbreak;\n\tcase QAM_256:\n\t\t \n\t\tcmd_buf2[2] = 0x45;\n\t\tbreak;\n\tcase QAM_64:\n\t\t \n\t\tcmd_buf2[2] = 0x43;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING\n\t\t       \"or51132: setmode: Modulation set to unsupported value (%d)\\n\",\n\t\t       state->current_modulation);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (or51132_writebuf(state, cmd_buf1, 3)) {\n\t\tprintk(KERN_WARNING \"or51132: set_mode error 1\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\tdprintk(\"set #1 to %02x\\n\", cmd_buf1[2]);\n\n\t \n\tif (or51132_writebuf(state, cmd_buf2, 3)) {\n\t\tprintk(KERN_WARNING \"or51132: set_mode error 2\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\tdprintk(\"set #6 to 0x%02x%02x\\n\", cmd_buf2[1], cmd_buf2[2]);\n\n\treturn 0;\n}\n\n \n#define MOD_FWCLASS_UNKNOWN\t0\n#define MOD_FWCLASS_VSB\t\t1\n#define MOD_FWCLASS_QAM\t\t2\nstatic int modulation_fw_class(enum fe_modulation modulation)\n{\n\tswitch(modulation) {\n\tcase VSB_8:\n\t\treturn MOD_FWCLASS_VSB;\n\tcase QAM_AUTO:\n\tcase QAM_64:\n\tcase QAM_256:\n\t\treturn MOD_FWCLASS_QAM;\n\tdefault:\n\t\treturn MOD_FWCLASS_UNKNOWN;\n\t}\n}\n\nstatic int or51132_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tint ret;\n\tstruct or51132_state* state = fe->demodulator_priv;\n\tconst struct firmware *fw;\n\tconst char *fwname;\n\tint clock_mode;\n\n\t \n\tif (modulation_fw_class(state->current_modulation) !=\n\t    modulation_fw_class(p->modulation)) {\n\t\tswitch (modulation_fw_class(p->modulation)) {\n\t\tcase MOD_FWCLASS_VSB:\n\t\t\tdprintk(\"set_parameters VSB MODE\\n\");\n\t\t\tfwname = OR51132_VSB_FIRMWARE;\n\n\t\t\t \n\t\t\tclock_mode = 0;\n\t\t\tbreak;\n\t\tcase MOD_FWCLASS_QAM:\n\t\t\tdprintk(\"set_parameters QAM MODE\\n\");\n\t\t\tfwname = OR51132_QAM_FIRMWARE;\n\n\t\t\t \n\t\t\tclock_mode = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"or51132: Modulation type(%d) UNSUPPORTED\\n\",\n\t\t\t       p->modulation);\n\t\t\treturn -1;\n\t\t}\n\t\tprintk(\"or51132: Waiting for firmware upload(%s)...\\n\",\n\t\t       fwname);\n\t\tret = request_firmware(&fw, fwname, state->i2c->dev.parent);\n\t\tif (ret) {\n\t\t\tprintk(KERN_WARNING \"or51132: No firmware uploaded(timeout or file not found?)\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tret = or51132_load_firmware(fe, fw);\n\t\trelease_firmware(fw);\n\t\tif (ret) {\n\t\t\tprintk(KERN_WARNING \"or51132: Writing firmware to device failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tprintk(\"or51132: Firmware upload complete.\\n\");\n\t\tstate->config->set_ts_params(fe, clock_mode);\n\t}\n\t \n\tif (state->current_modulation != p->modulation) {\n\t\tstate->current_modulation = p->modulation;\n\t\tor51132_setmode(fe);\n\t}\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t \n\tor51132_setmode(fe);\n\n\t \n\tstate->current_frequency = p->frequency;\n\treturn 0;\n}\n\nstatic int or51132_get_parameters(struct dvb_frontend* fe,\n\t\t\t\t  struct dtv_frontend_properties *p)\n{\n\tstruct or51132_state* state = fe->demodulator_priv;\n\tint status;\n\tint retry = 1;\n\nstart:\n\t \n\tif ((status = or51132_readreg(state, 0x00)) < 0) {\n\t\tprintk(KERN_WARNING \"or51132: get_parameters: error reading receiver status\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\tswitch(status&0xff) {\n\tcase 0x06:\n\t\tp->modulation = VSB_8;\n\t\tbreak;\n\tcase 0x43:\n\t\tp->modulation = QAM_64;\n\t\tbreak;\n\tcase 0x45:\n\t\tp->modulation = QAM_256;\n\t\tbreak;\n\tdefault:\n\t\tif (retry--)\n\t\t\tgoto start;\n\t\tprintk(KERN_WARNING \"or51132: unknown status 0x%02x\\n\",\n\t\t       status&0xff);\n\t\treturn -EREMOTEIO;\n\t}\n\n\t \n\tp->frequency = state->current_frequency;\n\n\t \n\tp->inversion = INVERSION_AUTO;\n\n\treturn 0;\n}\n\nstatic int or51132_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct or51132_state* state = fe->demodulator_priv;\n\tint reg;\n\n\t \n\tif ((reg = or51132_readreg(state, 0x00)) < 0) {\n\t\tprintk(KERN_WARNING \"or51132: read_status: error reading receiver status: %d\\n\", reg);\n\t\t*status = 0;\n\t\treturn -EREMOTEIO;\n\t}\n\tdprintk(\"%s: read_status %04x\\n\", __func__, reg);\n\n\tif (reg & 0x0100)  \n\t\t*status = FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|\n\t\t\t  FE_HAS_SYNC|FE_HAS_LOCK;\n\telse\n\t\t*status = 0;\n\treturn 0;\n}\n\n \n\nstatic u32 calculate_snr(u32 mse, u32 c)\n{\n\tif (mse == 0)  \n\t\treturn 0;\n\n\tmse = 2*intlog10(mse);\n\tif (mse > c) {\n\t\t \n\t\treturn 0;\n\t}\n\treturn 10*(c - mse);\n}\n\nstatic int or51132_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct or51132_state* state = fe->demodulator_priv;\n\tint noise, reg;\n\tu32 c, usK = 0;\n\tint retry = 1;\n\nstart:\n\t \n\tnoise = or51132_readreg(state, 0x02);\n\tif (noise < 0) {\n\t\tprintk(KERN_WARNING \"or51132: read_snr: error reading equalizer\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\tdprintk(\"read_snr noise (%d)\\n\", noise);\n\n\t \n\treg = or51132_readreg(state, 0x00);\n\tif (reg < 0) {\n\t\tprintk(KERN_WARNING \"or51132: read_snr: error reading receiver status\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\tswitch (reg&0xff) {\n\tcase 0x06:\n\t\tif (reg & 0x1000) usK = 3 << 24;\n\t\tfallthrough;\n\tcase 0x43:  \n\t\tc = 150204167;\n\t\tbreak;\n\tcase 0x45:\n\t\tc = 150290396;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"or51132: unknown status 0x%02x\\n\", reg&0xff);\n\t\tif (retry--) goto start;\n\t\treturn -EREMOTEIO;\n\t}\n\tdprintk(\"%s: modulation %02x, NTSC rej O%s\\n\", __func__,\n\t\treg&0xff, reg&0x1000?\"n\":\"ff\");\n\n\t \n\tstate->snr = calculate_snr(noise, c) - usK;\n\t*snr = (state->snr) >> 16;\n\n\tdprintk(\"%s: noise = 0x%08x, snr = %d.%02d dB\\n\", __func__, noise,\n\t\tstate->snr >> 24, (((state->snr>>8) & 0xffff) * 100) >> 16);\n\n\treturn 0;\n}\n\nstatic int or51132_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\t \n\t \n\t \n\tstruct or51132_state* state = (struct or51132_state*) fe->demodulator_priv;\n\tu16 snr;\n\tint ret;\n\n\tret = fe->ops.read_snr(fe, &snr);\n\tif (ret != 0)\n\t\treturn ret;\n\t \n\t \n\tif (state->snr >= 8960 * 0x10000)\n\t\t*strength = 0xffff;\n\telse\n\t\t*strength = state->snr / 8960;\n\n\treturn 0;\n}\n\nstatic int or51132_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fe_tune_settings)\n{\n\tfe_tune_settings->min_delay_ms = 500;\n\tfe_tune_settings->step_size = 0;\n\tfe_tune_settings->max_drift = 0;\n\n\treturn 0;\n}\n\nstatic void or51132_release(struct dvb_frontend* fe)\n{\n\tstruct or51132_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops or51132_ops;\n\nstruct dvb_frontend* or51132_attach(const struct or51132_config* config,\n\t\t\t\t    struct i2c_adapter* i2c)\n{\n\tstruct or51132_state* state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct or51132_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn NULL;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->current_frequency = -1;\n\tstate->current_modulation = -1;\n\n\t \n\tmemcpy(&state->frontend.ops, &or51132_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n}\n\nstatic const struct dvb_frontend_ops or51132_ops = {\n\t.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },\n\t.info = {\n\t\t.name\t\t\t= \"Oren OR51132 VSB/QAM Frontend\",\n\t\t.frequency_min_hz\t=  44 * MHz,\n\t\t.frequency_max_hz\t= 958 * MHz,\n\t\t.frequency_stepsize_hz\t= 166666,\n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_8VSB\n\t},\n\n\t.release = or51132_release,\n\n\t.init = or51132_init,\n\t.sleep = or51132_sleep,\n\n\t.set_frontend = or51132_set_parameters,\n\t.get_frontend = or51132_get_parameters,\n\t.get_tune_settings = or51132_get_tune_settings,\n\n\t.read_status = or51132_read_status,\n\t.read_ber = or51132_read_ber,\n\t.read_signal_strength = or51132_read_signal_strength,\n\t.read_snr = or51132_read_snr,\n\t.read_ucblocks = or51132_read_ucblocks,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"OR51132 ATSC [pcHDTV HD-3000] (8VSB & ITU J83 AnnexB FEC QAM64/256) Demodulator Driver\");\nMODULE_AUTHOR(\"Kirk Lapray\");\nMODULE_AUTHOR(\"Trent Piepho\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(or51132_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}