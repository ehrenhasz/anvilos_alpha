{
  "module_name": "dib7000m.c",
  "hash_id": "6ffe2c764f29a9851081d9710934b5662ee8d4ef2a7eee3f2bd25bc7e7598afc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/dib7000m.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"dib7000m.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"turn on debugging (default: 0)\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\nstruct dib7000m_state {\n\tstruct dvb_frontend demod;\n    struct dib7000m_config cfg;\n\n\tu8 i2c_addr;\n\tstruct i2c_adapter   *i2c_adap;\n\n\tstruct dibx000_i2c_master i2c_master;\n\n \n\tu8 reg_offs;\n\n\tu16 wbd_ref;\n\n\tu8 current_band;\n\tu32 current_bandwidth;\n\tstruct dibx000_agc_config *current_agc;\n\tu32 timf;\n\tu32 timf_default;\n\tu32 internal_clk;\n\n\tu8 div_force_off : 1;\n\tu8 div_state : 1;\n\tu16 div_sync_wait;\n\n\tu16 revision;\n\n\tu8 agc_state;\n\n\t \n\tstruct i2c_msg msg[2];\n\tu8 i2c_write_buffer[4];\n\tu8 i2c_read_buffer[2];\n\tstruct mutex i2c_buffer_lock;\n};\n\nenum dib7000m_power_mode {\n\tDIB7000M_POWER_ALL = 0,\n\n\tDIB7000M_POWER_NO,\n\tDIB7000M_POWER_INTERF_ANALOG_AGC,\n\tDIB7000M_POWER_COR4_DINTLV_ICIRM_EQUAL_CFROD,\n\tDIB7000M_POWER_COR4_CRY_ESRAM_MOUT_NUD,\n\tDIB7000M_POWER_INTERFACE_ONLY,\n};\n\nstatic u16 dib7000m_read_word(struct dib7000m_state *state, u16 reg)\n{\n\tu16 ret;\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn 0;\n\t}\n\n\tstate->i2c_write_buffer[0] = (reg >> 8) | 0x80;\n\tstate->i2c_write_buffer[1] = reg & 0xff;\n\n\tmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\n\tstate->msg[0].addr = state->i2c_addr >> 1;\n\tstate->msg[0].flags = 0;\n\tstate->msg[0].buf = state->i2c_write_buffer;\n\tstate->msg[0].len = 2;\n\tstate->msg[1].addr = state->i2c_addr >> 1;\n\tstate->msg[1].flags = I2C_M_RD;\n\tstate->msg[1].buf = state->i2c_read_buffer;\n\tstate->msg[1].len = 2;\n\n\tif (i2c_transfer(state->i2c_adap, state->msg, 2) != 2)\n\t\tdprintk(\"i2c read error on %d\\n\", reg);\n\n\tret = (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];\n\tmutex_unlock(&state->i2c_buffer_lock);\n\n\treturn ret;\n}\n\nstatic int dib7000m_write_word(struct dib7000m_state *state, u16 reg, u16 val)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstate->i2c_write_buffer[0] = (reg >> 8) & 0xff;\n\tstate->i2c_write_buffer[1] = reg & 0xff;\n\tstate->i2c_write_buffer[2] = (val >> 8) & 0xff;\n\tstate->i2c_write_buffer[3] = val & 0xff;\n\n\tmemset(&state->msg[0], 0, sizeof(struct i2c_msg));\n\tstate->msg[0].addr = state->i2c_addr >> 1;\n\tstate->msg[0].flags = 0;\n\tstate->msg[0].buf = state->i2c_write_buffer;\n\tstate->msg[0].len = 4;\n\n\tret = (i2c_transfer(state->i2c_adap, state->msg, 1) != 1 ?\n\t\t\t-EREMOTEIO : 0);\n\tmutex_unlock(&state->i2c_buffer_lock);\n\treturn ret;\n}\nstatic void dib7000m_write_tab(struct dib7000m_state *state, u16 *buf)\n{\n\tu16 l = 0, r, *n;\n\tn = buf;\n\tl = *n++;\n\twhile (l) {\n\t\tr = *n++;\n\n\t\tif (state->reg_offs && (r >= 112 && r <= 331)) \n\t\t\tr++;\n\n\t\tdo {\n\t\t\tdib7000m_write_word(state, r, *n++);\n\t\t\tr++;\n\t\t} while (--l);\n\t\tl = *n++;\n\t}\n}\n\nstatic int dib7000m_set_output_mode(struct dib7000m_state *state, int mode)\n{\n\tint    ret = 0;\n\tu16 outreg, fifo_threshold, smo_mode,\n\t\tsram = 0x0005;  \n\n\toutreg = 0;\n\tfifo_threshold = 1792;\n\tsmo_mode = (dib7000m_read_word(state, 294 + state->reg_offs) & 0x0010) | (1 << 1);\n\n\tdprintk(\"setting output mode for demod %p to %d\\n\", &state->demod, mode);\n\n\tswitch (mode) {\n\t\tcase OUTMODE_MPEG2_PAR_GATED_CLK:   \n\t\t\toutreg = (1 << 10);   \n\t\t\tbreak;\n\t\tcase OUTMODE_MPEG2_PAR_CONT_CLK:    \n\t\t\toutreg = (1 << 10) | (1 << 6);  \n\t\t\tbreak;\n\t\tcase OUTMODE_MPEG2_SERIAL:          \n\t\t\toutreg = (1 << 10) | (2 << 6) | (0 << 1);  \n\t\t\tbreak;\n\t\tcase OUTMODE_DIVERSITY:\n\t\t\tif (state->cfg.hostbus_diversity)\n\t\t\t\toutreg = (1 << 10) | (4 << 6);  \n\t\t\telse\n\t\t\t\tsram   |= 0x0c00;\n\t\t\tbreak;\n\t\tcase OUTMODE_MPEG2_FIFO:            \n\t\t\tsmo_mode |= (3 << 1);\n\t\t\tfifo_threshold = 512;\n\t\t\toutreg = (1 << 10) | (5 << 6);\n\t\t\tbreak;\n\t\tcase OUTMODE_HIGH_Z:  \n\t\t\toutreg = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Unhandled output_mode passed to be set for demod %p\\n\", &state->demod);\n\t\t\tbreak;\n\t}\n\n\tif (state->cfg.output_mpeg2_in_188_bytes)\n\t\tsmo_mode |= (1 << 5) ;\n\n\tret |= dib7000m_write_word(state,  294 + state->reg_offs, smo_mode);\n\tret |= dib7000m_write_word(state,  295 + state->reg_offs, fifo_threshold);  \n\tret |= dib7000m_write_word(state, 1795, outreg);\n\tret |= dib7000m_write_word(state, 1805, sram);\n\n\tif (state->revision == 0x4003) {\n\t\tu16 clk_cfg1 = dib7000m_read_word(state, 909) & 0xfffd;\n\t\tif (mode == OUTMODE_DIVERSITY)\n\t\t\tclk_cfg1 |= (1 << 1); \n\t\tdib7000m_write_word(state, 909, clk_cfg1);\n\t}\n\treturn ret;\n}\n\nstatic void dib7000m_set_power_mode(struct dib7000m_state *state, enum dib7000m_power_mode mode)\n{\n\t \n\tu16 reg_903 = 0xffff, reg_904 = 0xffff, reg_905 = 0xffff, reg_906  = 0x3fff;\n\tu8  offset = 0;\n\n\t \n\tswitch (mode) {\n\t\t \n\t\tcase DIB7000M_POWER_ALL:\n\t\t\treg_903 = 0x0000; reg_904 = 0x0000; reg_905 = 0x0000; reg_906 = 0x0000;\n\t\t\tbreak;\n\n\t\t \n\t\tcase DIB7000M_POWER_INTERFACE_ONLY:  \n\t\t\treg_905 &= ~((1 << 7) | (1 << 6) | (1 << 5) | (1 << 2));\n\t\t\tbreak;\n\n\t\tcase DIB7000M_POWER_INTERF_ANALOG_AGC:\n\t\t\treg_903 &= ~((1 << 15) | (1 << 14) | (1 << 11) | (1 << 10));\n\t\t\treg_905 &= ~((1 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (1 << 2));\n\t\t\treg_906 &= ~((1 << 0));\n\t\t\tbreak;\n\n\t\tcase DIB7000M_POWER_COR4_DINTLV_ICIRM_EQUAL_CFROD:\n\t\t\treg_903 = 0x0000; reg_904 = 0x801f; reg_905 = 0x0000; reg_906 = 0x0000;\n\t\t\tbreak;\n\n\t\tcase DIB7000M_POWER_COR4_CRY_ESRAM_MOUT_NUD:\n\t\t\treg_903 = 0x0000; reg_904 = 0x8000; reg_905 = 0x010b; reg_906 = 0x0000;\n\t\t\tbreak;\n\t\tcase DIB7000M_POWER_NO:\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!state->cfg.mobile_mode)\n\t\treg_904 |= (1 << 7) | (1 << 6) | (1 << 4) | (1 << 2) | (1 << 1);\n\n\t \n\tif (state->revision != 0x4000)\n\t\treg_906 <<= 1;\n\n\tif (state->revision == 0x4003)\n\t\toffset = 1;\n\n\tdib7000m_write_word(state, 903 + offset, reg_903);\n\tdib7000m_write_word(state, 904 + offset, reg_904);\n\tdib7000m_write_word(state, 905 + offset, reg_905);\n\tdib7000m_write_word(state, 906 + offset, reg_906);\n}\n\nstatic int dib7000m_set_adc_state(struct dib7000m_state *state, enum dibx000_adc_states no)\n{\n\tint ret = 0;\n\tu16 reg_913 = dib7000m_read_word(state, 913),\n\t       reg_914 = dib7000m_read_word(state, 914);\n\n\tswitch (no) {\n\t\tcase DIBX000_SLOW_ADC_ON:\n\t\t\treg_914 |= (1 << 1) | (1 << 0);\n\t\t\tret |= dib7000m_write_word(state, 914, reg_914);\n\t\t\treg_914 &= ~(1 << 1);\n\t\t\tbreak;\n\n\t\tcase DIBX000_SLOW_ADC_OFF:\n\t\t\treg_914 |=  (1 << 1) | (1 << 0);\n\t\t\tbreak;\n\n\t\tcase DIBX000_ADC_ON:\n\t\t\tif (state->revision == 0x4000) { \n\t\t\t\t\n\t\t\t\tdib7000m_write_word(state, 913, 0);\n\t\t\t\tdib7000m_write_word(state, 914, reg_914 & 0x3);\n\t\t\t\t\n\t\t\t\tdib7000m_write_word(state, 913, (1 << 15));\n\t\t\t\tdib7000m_write_word(state, 914, reg_914 & 0x3);\n\t\t\t}\n\n\t\t\treg_913 &= 0x0fff;\n\t\t\treg_914 &= 0x0003;\n\t\t\tbreak;\n\n\t\tcase DIBX000_ADC_OFF: \n\t\t\treg_913 |= (1 << 14) | (1 << 13) | (1 << 12);\n\t\t\treg_914 |= (1 << 5) | (1 << 4) | (1 << 3) | (1 << 2);\n\t\t\tbreak;\n\n\t\tcase DIBX000_VBG_ENABLE:\n\t\t\treg_913 &= ~(1 << 15);\n\t\t\tbreak;\n\n\t\tcase DIBX000_VBG_DISABLE:\n\t\t\treg_913 |= (1 << 15);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\n\tret |= dib7000m_write_word(state, 913, reg_913);\n\tret |= dib7000m_write_word(state, 914, reg_914);\n\n\treturn ret;\n}\n\nstatic int dib7000m_set_bandwidth(struct dib7000m_state *state, u32 bw)\n{\n\tu32 timf;\n\n\tif (!bw)\n\t\tbw = 8000;\n\n\t\n\tstate->current_bandwidth = bw;\n\n\tif (state->timf == 0) {\n\t\tdprintk(\"using default timf\\n\");\n\t\ttimf = state->timf_default;\n\t} else {\n\t\tdprintk(\"using updated timf\\n\");\n\t\ttimf = state->timf;\n\t}\n\n\ttimf = timf * (bw / 50) / 160;\n\n\tdib7000m_write_word(state, 23, (u16) ((timf >> 16) & 0xffff));\n\tdib7000m_write_word(state, 24, (u16) ((timf      ) & 0xffff));\n\n\treturn 0;\n}\n\nstatic int dib7000m_set_diversity_in(struct dvb_frontend *demod, int onoff)\n{\n\tstruct dib7000m_state *state = demod->demodulator_priv;\n\n\tif (state->div_force_off) {\n\t\tdprintk(\"diversity combination deactivated - forced by COFDM parameters\\n\");\n\t\tonoff = 0;\n\t}\n\tstate->div_state = (u8)onoff;\n\n\tif (onoff) {\n\t\tdib7000m_write_word(state, 263 + state->reg_offs, 6);\n\t\tdib7000m_write_word(state, 264 + state->reg_offs, 6);\n\t\tdib7000m_write_word(state, 266 + state->reg_offs, (state->div_sync_wait << 4) | (1 << 2) | (2 << 0));\n\t} else {\n\t\tdib7000m_write_word(state, 263 + state->reg_offs, 1);\n\t\tdib7000m_write_word(state, 264 + state->reg_offs, 0);\n\t\tdib7000m_write_word(state, 266 + state->reg_offs, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int dib7000m_sad_calib(struct dib7000m_state *state)\n{\n\n \n\n\tdib7000m_write_word(state, 929, (0 << 1) | (0 << 0));\n\tdib7000m_write_word(state, 930, 776); \n\n\t \n\tdib7000m_write_word(state, 929, (1 << 0));\n\tdib7000m_write_word(state, 929, (0 << 0));\n\n\tmsleep(1);\n\n\treturn 0;\n}\n\nstatic void dib7000m_reset_pll_common(struct dib7000m_state *state, const struct dibx000_bandwidth_config *bw)\n{\n\tdib7000m_write_word(state, 18, (u16) (((bw->internal*1000) >> 16) & 0xffff));\n\tdib7000m_write_word(state, 19, (u16) ( (bw->internal*1000)        & 0xffff));\n\tdib7000m_write_word(state, 21, (u16) ( (bw->ifreq          >> 16) & 0xffff));\n\tdib7000m_write_word(state, 22, (u16) (  bw->ifreq                 & 0xffff));\n\n\tdib7000m_write_word(state, 928, bw->sad_cfg);\n}\n\nstatic void dib7000m_reset_pll(struct dib7000m_state *state)\n{\n\tconst struct dibx000_bandwidth_config *bw = state->cfg.bw;\n\tu16 reg_907,reg_910;\n\n\t \n\treg_907 = (bw->pll_bypass << 15) | (bw->modulo << 7) |\n\t\t(bw->ADClkSrc << 6) | (bw->IO_CLK_en_core << 5) | (bw->bypclk_div << 2) |\n\t\t(bw->enable_refdiv << 1) | (0 << 0);\n\treg_910 = (((bw->pll_ratio >> 6) & 0x3) << 3) | (bw->pll_range << 1) | bw->pll_reset;\n\n\t\n\t\n\tif (!state->cfg.quartz_direct) {\n\t\treg_910 |= (1 << 5);  \n\n\t\t\n\t\tif(state->cfg.input_clk_is_div_2)\n\t\t\treg_907 |= (16 << 9);\n\t\telse \n\t\t\treg_907 |= (8 << 9);\n\t} else {\n\t\treg_907 |= (bw->pll_ratio & 0x3f) << 9;\n\t\treg_910 |= (bw->pll_prediv << 5);\n\t}\n\n\tdib7000m_write_word(state, 910, reg_910); \n\tdib7000m_write_word(state, 907, reg_907); \n\tdib7000m_write_word(state, 908, 0x0006);  \n\n\tdib7000m_reset_pll_common(state, bw);\n}\n\nstatic void dib7000mc_reset_pll(struct dib7000m_state *state)\n{\n\tconst struct dibx000_bandwidth_config *bw = state->cfg.bw;\n\tu16 clk_cfg1;\n\n\t\n\tdib7000m_write_word(state, 907, (bw->pll_prediv << 8) | (bw->pll_ratio << 0));\n\n\t\n\t\n\tclk_cfg1 = (0 << 14) | (3 << 12) |(0 << 11) |\n\t\t\t(bw->IO_CLK_en_core << 10) | (bw->bypclk_div << 5) | (bw->enable_refdiv << 4) |\n\t\t\t(1 << 3) | (bw->pll_range << 1) | (bw->pll_reset << 0);\n\tdib7000m_write_word(state, 908, clk_cfg1);\n\tclk_cfg1 = (clk_cfg1 & 0xfff7) | (bw->pll_bypass << 3);\n\tdib7000m_write_word(state, 908, clk_cfg1);\n\n\t\n\tdib7000m_write_word(state, 910, (1 << 12) | (2 << 10) | (bw->modulo << 8) | (bw->ADClkSrc << 7));\n\n\tdib7000m_reset_pll_common(state, bw);\n}\n\nstatic int dib7000m_reset_gpio(struct dib7000m_state *st)\n{\n\t \n\tdib7000m_write_word(st, 773, st->cfg.gpio_dir);\n\tdib7000m_write_word(st, 774, st->cfg.gpio_val);\n\n\t \n\n\tdib7000m_write_word(st, 775, st->cfg.gpio_pwm_pos);\n\n\tdib7000m_write_word(st, 780, st->cfg.pwm_freq_div);\n\treturn 0;\n}\n\nstatic u16 dib7000m_defaults_common[] =\n\n{\n\t\n\t3, 2,\n\t\t0x0004,\n\t\t0x1000,\n\t\t0x0814,\n\n\t12, 6,\n\t\t0x001b,\n\t\t0x7740,\n\t\t0x005b,\n\t\t0x8d80,\n\t\t0x01c9,\n\t\t0xc380,\n\t\t0x0000,\n\t\t0x0080,\n\t\t0x0000,\n\t\t0x0090,\n\t\t0x0001,\n\t\t0xd4c0,\n\n\t1, 26,\n\t\t0x6680, \n\n\t1, 170,\n\t\t0x0410, \n\n\t8, 173,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\n\t1, 182,\n\t\t8192, \n\n\t2, 195,\n\t\t0x0ccd, \n\t\t0,      \n\n\t1, 205,\n\t\t0x200f, \n\n\t5, 214,\n\t\t0x023d, \n\t\t0x00a4, \n\t\t0x00a4, \n\t\t0x7ff0, \n\t\t0x3ccc, \n\n\t1, 226,\n\t\t0, \n\n\t1, 255,\n\t\t0x800, \n\n\t1, 263,\n\t\t0x0001,\n\n\t1, 281,\n\t\t0x0010, \n\n\t1, 294,\n\t\t0x0062, \n\n\t0\n};\n\nstatic u16 dib7000m_defaults[] =\n\n{\n\t \n\t11, 76,\n\t\t(1 << 13) - 825 - 117,\n\t\t(1 << 13) - 837 - 117,\n\t\t(1 << 13) - 811 - 117,\n\t\t(1 << 13) - 766 - 117,\n\t\t(1 << 13) - 737 - 117,\n\t\t(1 << 13) - 693 - 117,\n\t\t(1 << 13) - 648 - 117,\n\t\t(1 << 13) - 619 - 117,\n\t\t(1 << 13) - 575 - 117,\n\t\t(1 << 13) - 531 - 117,\n\t\t(1 << 13) - 501 - 117,\n\n\t\n\t1, 912,\n\t\t0x2c8a,\n\n\t1, 1817,\n\t\t1,\n\n\t0,\n};\n\nstatic int dib7000m_demod_reset(struct dib7000m_state *state)\n{\n\tdib7000m_set_power_mode(state, DIB7000M_POWER_ALL);\n\n\t \n\tdib7000m_set_adc_state(state, DIBX000_VBG_ENABLE);\n\n\t \n\tdib7000m_write_word(state,  898, 0xffff);\n\tdib7000m_write_word(state,  899, 0xffff);\n\tdib7000m_write_word(state,  900, 0xff0f);\n\tdib7000m_write_word(state,  901, 0xfffc);\n\n\tdib7000m_write_word(state,  898, 0);\n\tdib7000m_write_word(state,  899, 0);\n\tdib7000m_write_word(state,  900, 0);\n\tdib7000m_write_word(state,  901, 0);\n\n\tif (state->revision == 0x4000)\n\t\tdib7000m_reset_pll(state);\n\telse\n\t\tdib7000mc_reset_pll(state);\n\n\tif (dib7000m_reset_gpio(state) != 0)\n\t\tdprintk(\"GPIO reset was not successful.\\n\");\n\n\tif (dib7000m_set_output_mode(state, OUTMODE_HIGH_Z) != 0)\n\t\tdprintk(\"OUTPUT_MODE could not be reset.\\n\");\n\n\t \n\tdib7000m_write_word(state, 1794, dib7000m_read_word(state, 1794) & ~(1 << 1) );\n\n\tdib7000m_set_bandwidth(state, 8000);\n\n\tdib7000m_set_adc_state(state, DIBX000_SLOW_ADC_ON);\n\tdib7000m_sad_calib(state);\n\tdib7000m_set_adc_state(state, DIBX000_SLOW_ADC_OFF);\n\n\tif (state->cfg.dvbt_mode)\n\t\tdib7000m_write_word(state, 1796, 0x0); \n\n\tif (state->cfg.mobile_mode)\n\t\tdib7000m_write_word(state, 261 + state->reg_offs, 2);\n\telse\n\t\tdib7000m_write_word(state, 224 + state->reg_offs, 1);\n\n\t\n\tif(state->cfg.tuner_is_baseband)\n\t\tdib7000m_write_word(state, 36, 0x0755);\n\telse\n\t\tdib7000m_write_word(state, 36, 0x1f55);\n\n\t\n\tif (state->revision == 0x4000)\n\t\tdib7000m_write_word(state, 909, (3 << 10) | (1 << 6));\n\telse\n\t\tdib7000m_write_word(state, 909, (3 << 4) | 1);\n\n\tdib7000m_write_tab(state, dib7000m_defaults_common);\n\tdib7000m_write_tab(state, dib7000m_defaults);\n\n\tdib7000m_set_power_mode(state, DIB7000M_POWER_INTERFACE_ONLY);\n\n\tstate->internal_clk = state->cfg.bw->internal;\n\n\treturn 0;\n}\n\nstatic void dib7000m_restart_agc(struct dib7000m_state *state)\n{\n\t\n\tdib7000m_write_word(state, 898, 0x0c00);\n\tdib7000m_write_word(state, 898, 0x0000);\n}\n\nstatic int dib7000m_agc_soft_split(struct dib7000m_state *state)\n{\n\tu16 agc,split_offset;\n\n\tif(!state->current_agc || !state->current_agc->perform_agc_softsplit || state->current_agc->split.max == 0)\n\t\treturn 0;\n\n\t\n\tagc = dib7000m_read_word(state, 390);\n\n\tif (agc > state->current_agc->split.min_thres)\n\t\tsplit_offset = state->current_agc->split.min;\n\telse if (agc < state->current_agc->split.max_thres)\n\t\tsplit_offset = state->current_agc->split.max;\n\telse\n\t\tsplit_offset = state->current_agc->split.max *\n\t\t\t(agc - state->current_agc->split.min_thres) /\n\t\t\t(state->current_agc->split.max_thres - state->current_agc->split.min_thres);\n\n\tdprintk(\"AGC split_offset: %d\\n\", split_offset);\n\n\t\n\treturn dib7000m_write_word(state, 103, (dib7000m_read_word(state, 103) & 0xff00) | split_offset);\n}\n\nstatic int dib7000m_update_lna(struct dib7000m_state *state)\n{\n\tu16 dyn_gain;\n\n\tif (state->cfg.update_lna) {\n\t\t\n\t\tdyn_gain = dib7000m_read_word(state, 390);\n\n\t\tif (state->cfg.update_lna(&state->demod,dyn_gain)) { \n\t\t\tdib7000m_restart_agc(state);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dib7000m_set_agc_config(struct dib7000m_state *state, u8 band)\n{\n\tstruct dibx000_agc_config *agc = NULL;\n\tint i;\n\tif (state->current_band == band && state->current_agc != NULL)\n\t\treturn 0;\n\tstate->current_band = band;\n\n\tfor (i = 0; i < state->cfg.agc_config_count; i++)\n\t\tif (state->cfg.agc[i].band_caps & band) {\n\t\t\tagc = &state->cfg.agc[i];\n\t\t\tbreak;\n\t\t}\n\n\tif (agc == NULL) {\n\t\tdprintk(\"no valid AGC configuration found for band 0x%02x\\n\", band);\n\t\treturn -EINVAL;\n\t}\n\n\tstate->current_agc = agc;\n\n\t \n\tdib7000m_write_word(state, 72 ,  agc->setup);\n\tdib7000m_write_word(state, 73 ,  agc->inv_gain);\n\tdib7000m_write_word(state, 74 ,  agc->time_stabiliz);\n\tdib7000m_write_word(state, 97 , (agc->alpha_level << 12) | agc->thlock);\n\n\t\n\tdib7000m_write_word(state, 98, (agc->alpha_mant << 5) | agc->alpha_exp);\n\tdib7000m_write_word(state, 99, (agc->beta_mant  << 6) | agc->beta_exp);\n\n\tdprintk(\"WBD: ref: %d, sel: %d, active: %d, alpha: %d\\n\",\n\t\tstate->wbd_ref != 0 ? state->wbd_ref : agc->wbd_ref, agc->wbd_sel, !agc->perform_agc_softsplit, agc->wbd_sel);\n\n\t \n\tif (state->wbd_ref != 0)\n\t\tdib7000m_write_word(state, 102, state->wbd_ref);\n\telse \n\t\tdib7000m_write_word(state, 102, agc->wbd_ref);\n\n\tdib7000m_write_word(state, 103, (agc->wbd_alpha << 9) | (agc->perform_agc_softsplit << 8) );\n\tdib7000m_write_word(state, 104,  agc->agc1_max);\n\tdib7000m_write_word(state, 105,  agc->agc1_min);\n\tdib7000m_write_word(state, 106,  agc->agc2_max);\n\tdib7000m_write_word(state, 107,  agc->agc2_min);\n\tdib7000m_write_word(state, 108, (agc->agc1_pt1 << 8) | agc->agc1_pt2 );\n\tdib7000m_write_word(state, 109, (agc->agc1_slope1 << 8) | agc->agc1_slope2);\n\tdib7000m_write_word(state, 110, (agc->agc2_pt1 << 8) | agc->agc2_pt2);\n\tdib7000m_write_word(state, 111, (agc->agc2_slope1 << 8) | agc->agc2_slope2);\n\n\tif (state->revision > 0x4000) { \n\t\tdib7000m_write_word(state, 71,   agc->agc1_pt3);\n\n\n\t\tdib7000m_write_word(state, 929, (dib7000m_read_word(state, 929) & 0xffe3) | (agc->wbd_inv << 4) | (agc->wbd_sel << 2));\n\t} else {\n\t\t\n\t\tu16 b[9] = { 676, 696, 717, 737, 758, 778, 799, 819, 840 };\n\t\tfor (i = 0; i < 9; i++)\n\t\t\tdib7000m_write_word(state, 88 + i, b[i]);\n\t}\n\treturn 0;\n}\n\nstatic void dib7000m_update_timf(struct dib7000m_state *state)\n{\n\tu32 timf = (dib7000m_read_word(state, 436) << 16) | dib7000m_read_word(state, 437);\n\tstate->timf = timf * 160 / (state->current_bandwidth / 50);\n\tdib7000m_write_word(state, 23, (u16) (timf >> 16));\n\tdib7000m_write_word(state, 24, (u16) (timf & 0xffff));\n\tdprintk(\"updated timf_frequency: %d (default: %d)\\n\", state->timf, state->timf_default);\n}\n\nstatic int dib7000m_agc_startup(struct dvb_frontend *demod)\n{\n\tstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\n\tstruct dib7000m_state *state = demod->demodulator_priv;\n\tu16 cfg_72 = dib7000m_read_word(state, 72);\n\tint ret = -1;\n\tu8 *agc_state = &state->agc_state;\n\tu8 agc_split;\n\n\tswitch (state->agc_state) {\n\t\tcase 0:\n\t\t\t\n\t\t\tdib7000m_set_power_mode(state, DIB7000M_POWER_INTERF_ANALOG_AGC);\n\t\t\tdib7000m_set_adc_state(state, DIBX000_ADC_ON);\n\n\t\t\tif (dib7000m_set_agc_config(state, BAND_OF_FREQUENCY(ch->frequency/1000)) != 0)\n\t\t\t\treturn -1;\n\n\t\t\tret = 7;  \n\t\t\t(*agc_state)++;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t \n\t\t\tif (state->cfg.agc_control)\n\t\t\t\tstate->cfg.agc_control(&state->demod, 1);\n\n\t\t\tdib7000m_write_word(state, 75, 32768);\n\t\t\tif (!state->current_agc->perform_agc_softsplit) {\n\t\t\t\t \n\t\t\t\tdib7000m_write_word(state, 103, 1 << 8);  \n\t\t\t\t(*agc_state)++;\n\t\t\t\tret = 5;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t(*agc_state) = 4;\n\t\t\t\t \n\t\t\t\tret = 7;\n\t\t\t}\n\n\t\t\tdib7000m_restart_agc(state);\n\t\t\tbreak;\n\n\t\tcase 2:  \n\t\t\tdib7000m_write_word(state,  72, cfg_72 | (1 << 4));  \n\t\t\tdib7000m_write_word(state, 103, 2 << 9);             \n\t\t\t(*agc_state)++;\n\t\t\tret = 14;\n\t\t\tbreak;\n\n\tcase 3:  \n\t\t\tagc_split = (u8)dib7000m_read_word(state, 392);  \n\t\t\tdib7000m_write_word(state, 75, dib7000m_read_word(state, 390));  \n\n\t\t\tdib7000m_write_word(state, 72,  cfg_72 & ~(1 << 4));    \n\t\t\tdib7000m_write_word(state, 103, (state->current_agc->wbd_alpha << 9) | agc_split);  \n\n\t\t\tdib7000m_restart_agc(state);\n\n\t\t\tdprintk(\"SPLIT %p: %u\\n\", demod, agc_split);\n\n\t\t\t(*agc_state)++;\n\t\t\tret = 5;\n\t\t\tbreak;\n\n\t\tcase 4:  \n\t\t\t \n\t\t\tret = 7;\n\n\t\t\tif (dib7000m_update_lna(state))\n\t\t\t\t\n\t\t\t\tret = 5;\n\t\t\telse\n\t\t\t\t(*agc_state)++;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\tdib7000m_agc_soft_split(state);\n\n\t\t\tif (state->cfg.agc_control)\n\t\t\t\tstate->cfg.agc_control(&state->demod, 0);\n\n\t\t\t(*agc_state)++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void dib7000m_set_channel(struct dib7000m_state *state, struct dtv_frontend_properties *ch,\n\t\t\t\t u8 seq)\n{\n\tu16 value, est[4];\n\n\tdib7000m_set_bandwidth(state, BANDWIDTH_TO_KHZ(ch->bandwidth_hz));\n\n\t \n\tvalue = 0;\n\tswitch (ch->transmission_mode) {\n\t\tcase TRANSMISSION_MODE_2K: value |= (0 << 7); break;\n\t\tcase TRANSMISSION_MODE_4K: value |= (2 << 7); break;\n\t\tdefault:\n\t\tcase TRANSMISSION_MODE_8K: value |= (1 << 7); break;\n\t}\n\tswitch (ch->guard_interval) {\n\t\tcase GUARD_INTERVAL_1_32: value |= (0 << 5); break;\n\t\tcase GUARD_INTERVAL_1_16: value |= (1 << 5); break;\n\t\tcase GUARD_INTERVAL_1_4:  value |= (3 << 5); break;\n\t\tdefault:\n\t\tcase GUARD_INTERVAL_1_8:  value |= (2 << 5); break;\n\t}\n\tswitch (ch->modulation) {\n\t\tcase QPSK:  value |= (0 << 3); break;\n\t\tcase QAM_16: value |= (1 << 3); break;\n\t\tdefault:\n\t\tcase QAM_64: value |= (2 << 3); break;\n\t}\n\tswitch (HIERARCHY_1) {\n\t\tcase HIERARCHY_2: value |= 2; break;\n\t\tcase HIERARCHY_4: value |= 4; break;\n\t\tdefault:\n\t\tcase HIERARCHY_1: value |= 1; break;\n\t}\n\tdib7000m_write_word(state, 0, value);\n\tdib7000m_write_word(state, 5, (seq << 4));\n\n\t \n\tvalue = 0;\n\tif (1 != 0)\n\t\tvalue |= (1 << 6);\n\tif (ch->hierarchy == 1)\n\t\tvalue |= (1 << 4);\n\tif (1 == 1)\n\t\tvalue |= 1;\n\tswitch ((ch->hierarchy == 0 || 1 == 1) ? ch->code_rate_HP : ch->code_rate_LP) {\n\t\tcase FEC_2_3: value |= (2 << 1); break;\n\t\tcase FEC_3_4: value |= (3 << 1); break;\n\t\tcase FEC_5_6: value |= (5 << 1); break;\n\t\tcase FEC_7_8: value |= (7 << 1); break;\n\t\tdefault:\n\t\tcase FEC_1_2: value |= (1 << 1); break;\n\t}\n\tdib7000m_write_word(state, 267 + state->reg_offs, value);\n\n\t \n\n\t \n\tdib7000m_write_word(state, 26, (6 << 12) | (6 << 8) | 0x80);\n\n\t \n\tdib7000m_write_word(state, 29, (0 << 14) | (4 << 10) | (1 << 9) | (3 << 5) | (1 << 4) | (0x3));\n\n\t \n\tdib7000m_write_word(state, 32, (0 << 4) | 0x3);\n\n\t \n\tdib7000m_write_word(state, 33, (0 << 4) | 0x5);\n\n\t \n\tswitch (ch->transmission_mode) {\n\t\tcase TRANSMISSION_MODE_8K: value = 256; break;\n\t\tcase TRANSMISSION_MODE_4K: value = 128; break;\n\t\tcase TRANSMISSION_MODE_2K:\n\t\tdefault: value = 64; break;\n\t}\n\tswitch (ch->guard_interval) {\n\t\tcase GUARD_INTERVAL_1_16: value *= 2; break;\n\t\tcase GUARD_INTERVAL_1_8:  value *= 4; break;\n\t\tcase GUARD_INTERVAL_1_4:  value *= 8; break;\n\t\tdefault:\n\t\tcase GUARD_INTERVAL_1_32: value *= 1; break;\n\t}\n\tstate->div_sync_wait = (value * 3) / 2 + 32; \n\n\t \n\t \n\tif (1 == 1 || state->revision > 0x4000)\n\t\tstate->div_force_off = 0;\n\telse\n\t\tstate->div_force_off = 1;\n\tdib7000m_set_diversity_in(&state->demod, state->div_state);\n\n\t \n\tswitch (ch->modulation) {\n\t\tcase QAM_64:\n\t\t\test[0] = 0x0148;        \n\t\t\test[1] = 0xfff0;        \n\t\t\test[2] = 0x00a4;        \n\t\t\test[3] = 0xfff8;        \n\t\t\tbreak;\n\t\tcase QAM_16:\n\t\t\test[0] = 0x023d;        \n\t\t\test[1] = 0xffdf;        \n\t\t\test[2] = 0x00a4;        \n\t\t\test[3] = 0xfff0;        \n\t\t\tbreak;\n\t\tdefault:\n\t\t\test[0] = 0x099a;        \n\t\t\test[1] = 0xffae;        \n\t\t\test[2] = 0x0333;        \n\t\t\test[3] = 0xfff8;        \n\t\t\tbreak;\n\t}\n\tfor (value = 0; value < 4; value++)\n\t\tdib7000m_write_word(state, 214 + value + state->reg_offs, est[value]);\n\n\t\n\tdib7000m_set_power_mode(state, DIB7000M_POWER_COR4_DINTLV_ICIRM_EQUAL_CFROD);\n}\n\nstatic int dib7000m_autosearch_start(struct dvb_frontend *demod)\n{\n\tstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\n\tstruct dib7000m_state *state = demod->demodulator_priv;\n\tstruct dtv_frontend_properties schan;\n\tint ret = 0;\n\tu32 value, factor;\n\n\tschan = *ch;\n\n\tschan.modulation = QAM_64;\n\tschan.guard_interval        = GUARD_INTERVAL_1_32;\n\tschan.transmission_mode         = TRANSMISSION_MODE_8K;\n\tschan.code_rate_HP = FEC_2_3;\n\tschan.code_rate_LP = FEC_3_4;\n\tschan.hierarchy    = 0;\n\n\tdib7000m_set_channel(state, &schan, 7);\n\n\tfactor = BANDWIDTH_TO_KHZ(schan.bandwidth_hz);\n\tif (factor >= 5000)\n\t\tfactor = 1;\n\telse\n\t\tfactor = 6;\n\n\t\n\tvalue = 30 * state->internal_clk * factor;\n\tret |= dib7000m_write_word(state, 6,  (u16) ((value >> 16) & 0xffff)); \n\tret |= dib7000m_write_word(state, 7,  (u16)  (value        & 0xffff)); \n\tvalue = 100 * state->internal_clk * factor;\n\tret |= dib7000m_write_word(state, 8,  (u16) ((value >> 16) & 0xffff)); \n\tret |= dib7000m_write_word(state, 9,  (u16)  (value        & 0xffff)); \n\tvalue = 500 * state->internal_clk * factor;\n\tret |= dib7000m_write_word(state, 10, (u16) ((value >> 16) & 0xffff)); \n\tret |= dib7000m_write_word(state, 11, (u16)  (value        & 0xffff)); \n\n\t\n\tvalue = dib7000m_read_word(state, 0);\n\tret |= dib7000m_write_word(state, 0, (u16) (value | (1 << 9)));\n\n\t \n\tif (state->revision == 0x4000)\n\t\tdib7000m_write_word(state, 1793, 0);\n\telse\n\t\tdib7000m_read_word(state, 537);\n\n\tret |= dib7000m_write_word(state, 0, (u16) value);\n\n\treturn ret;\n}\n\nstatic int dib7000m_autosearch_irq(struct dib7000m_state *state, u16 reg)\n{\n\tu16 irq_pending = dib7000m_read_word(state, reg);\n\n\tif (irq_pending & 0x1) { \n\t\tdprintk(\"autosearch failed\\n\");\n\t\treturn 1;\n\t}\n\n\tif (irq_pending & 0x2) { \n\t\tdprintk(\"autosearch succeeded\\n\");\n\t\treturn 2;\n\t}\n\treturn 0; \n}\n\nstatic int dib7000m_autosearch_is_irq(struct dvb_frontend *demod)\n{\n\tstruct dib7000m_state *state = demod->demodulator_priv;\n\tif (state->revision == 0x4000)\n\t\treturn dib7000m_autosearch_irq(state, 1793);\n\telse\n\t\treturn dib7000m_autosearch_irq(state, 537);\n}\n\nstatic int dib7000m_tune(struct dvb_frontend *demod)\n{\n\tstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\n\tstruct dib7000m_state *state = demod->demodulator_priv;\n\tint ret = 0;\n\tu16 value;\n\n\t\n\tdib7000m_set_channel(state, ch, 0);\n\n\t\n\tret |= dib7000m_write_word(state, 898, 0x4000);\n\tret |= dib7000m_write_word(state, 898, 0x0000);\n\tmsleep(45);\n\n\tdib7000m_set_power_mode(state, DIB7000M_POWER_COR4_CRY_ESRAM_MOUT_NUD);\n\t \n\tret |= dib7000m_write_word(state, 29, (0 << 14) | (4 << 10) | (0 << 9) | (3 << 5) | (1 << 4) | (0x3));\n\n\t\n\tif (state->timf == 0)\n\t\tmsleep(200);\n\n\t\n\t \n\tvalue = (6 << 8) | 0x80;\n\tswitch (ch->transmission_mode) {\n\t\tcase TRANSMISSION_MODE_2K: value |= (7 << 12); break;\n\t\tcase TRANSMISSION_MODE_4K: value |= (8 << 12); break;\n\t\tdefault:\n\t\tcase TRANSMISSION_MODE_8K: value |= (9 << 12); break;\n\t}\n\tret |= dib7000m_write_word(state, 26, value);\n\n\t \n\tvalue = (0 << 4);\n\tswitch (ch->transmission_mode) {\n\t\tcase TRANSMISSION_MODE_2K: value |= 0x6; break;\n\t\tcase TRANSMISSION_MODE_4K: value |= 0x7; break;\n\t\tdefault:\n\t\tcase TRANSMISSION_MODE_8K: value |= 0x8; break;\n\t}\n\tret |= dib7000m_write_word(state, 32, value);\n\n\t \n\tvalue = (0 << 4);\n\tswitch (ch->transmission_mode) {\n\t\tcase TRANSMISSION_MODE_2K: value |= 0x6; break;\n\t\tcase TRANSMISSION_MODE_4K: value |= 0x7; break;\n\t\tdefault:\n\t\tcase TRANSMISSION_MODE_8K: value |= 0x8; break;\n\t}\n\tret |= dib7000m_write_word(state, 33,  value);\n\n\t\n\tif ((dib7000m_read_word(state, 535) >> 6)  & 0x1)\n\t\tdib7000m_update_timf(state);\n\n\tdib7000m_set_bandwidth(state, BANDWIDTH_TO_KHZ(ch->bandwidth_hz));\n\treturn ret;\n}\n\nstatic int dib7000m_wakeup(struct dvb_frontend *demod)\n{\n\tstruct dib7000m_state *state = demod->demodulator_priv;\n\n\tdib7000m_set_power_mode(state, DIB7000M_POWER_ALL);\n\n\tif (dib7000m_set_adc_state(state, DIBX000_SLOW_ADC_ON) != 0)\n\t\tdprintk(\"could not start Slow ADC\\n\");\n\n\treturn 0;\n}\n\nstatic int dib7000m_sleep(struct dvb_frontend *demod)\n{\n\tstruct dib7000m_state *st = demod->demodulator_priv;\n\tdib7000m_set_output_mode(st, OUTMODE_HIGH_Z);\n\tdib7000m_set_power_mode(st, DIB7000M_POWER_INTERFACE_ONLY);\n\treturn dib7000m_set_adc_state(st, DIBX000_SLOW_ADC_OFF) |\n\t\tdib7000m_set_adc_state(st, DIBX000_ADC_OFF);\n}\n\nstatic int dib7000m_identify(struct dib7000m_state *state)\n{\n\tu16 value;\n\n\tif ((value = dib7000m_read_word(state, 896)) != 0x01b3) {\n\t\tdprintk(\"wrong Vendor ID (0x%x)\\n\", value);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tstate->revision = dib7000m_read_word(state, 897);\n\tif (state->revision != 0x4000 &&\n\t\tstate->revision != 0x4001 &&\n\t\tstate->revision != 0x4002 &&\n\t\tstate->revision != 0x4003) {\n\t\tdprintk(\"wrong Device ID (0x%x)\\n\", value);\n\t\treturn -EREMOTEIO;\n\t}\n\n\t \n\tif (state->revision == 0x4000 && dib7000m_read_word(state, 769) == 0x4000) {\n\t\tdprintk(\"this driver does not work with DiB7000PC\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\tswitch (state->revision) {\n\tcase 0x4000: dprintk(\"found DiB7000MA/PA/MB/PB\\n\"); break;\n\tcase 0x4001: state->reg_offs = 1; dprintk(\"found DiB7000HC\\n\"); break;\n\tcase 0x4002: state->reg_offs = 1; dprintk(\"found DiB7000MC\\n\"); break;\n\tcase 0x4003: state->reg_offs = 1; dprintk(\"found DiB9000\\n\"); break;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int dib7000m_get_frontend(struct dvb_frontend* fe,\n\t\t\t\t struct dtv_frontend_properties *fep)\n{\n\tstruct dib7000m_state *state = fe->demodulator_priv;\n\tu16 tps = dib7000m_read_word(state,480);\n\n\tfep->inversion = INVERSION_AUTO;\n\n\tfep->bandwidth_hz = BANDWIDTH_TO_HZ(state->current_bandwidth);\n\n\tswitch ((tps >> 8) & 0x3) {\n\t\tcase 0: fep->transmission_mode = TRANSMISSION_MODE_2K; break;\n\t\tcase 1: fep->transmission_mode = TRANSMISSION_MODE_8K; break;\n\t\t \n\t}\n\n\tswitch (tps & 0x3) {\n\t\tcase 0: fep->guard_interval = GUARD_INTERVAL_1_32; break;\n\t\tcase 1: fep->guard_interval = GUARD_INTERVAL_1_16; break;\n\t\tcase 2: fep->guard_interval = GUARD_INTERVAL_1_8; break;\n\t\tcase 3: fep->guard_interval = GUARD_INTERVAL_1_4; break;\n\t}\n\n\tswitch ((tps >> 14) & 0x3) {\n\t\tcase 0: fep->modulation = QPSK; break;\n\t\tcase 1: fep->modulation = QAM_16; break;\n\t\tcase 2:\n\t\tdefault: fep->modulation = QAM_64; break;\n\t}\n\n\t \n\t \n\n\tfep->hierarchy = HIERARCHY_NONE;\n\tswitch ((tps >> 5) & 0x7) {\n\t\tcase 1: fep->code_rate_HP = FEC_1_2; break;\n\t\tcase 2: fep->code_rate_HP = FEC_2_3; break;\n\t\tcase 3: fep->code_rate_HP = FEC_3_4; break;\n\t\tcase 5: fep->code_rate_HP = FEC_5_6; break;\n\t\tcase 7:\n\t\tdefault: fep->code_rate_HP = FEC_7_8; break;\n\n\t}\n\n\tswitch ((tps >> 2) & 0x7) {\n\t\tcase 1: fep->code_rate_LP = FEC_1_2; break;\n\t\tcase 2: fep->code_rate_LP = FEC_2_3; break;\n\t\tcase 3: fep->code_rate_LP = FEC_3_4; break;\n\t\tcase 5: fep->code_rate_LP = FEC_5_6; break;\n\t\tcase 7:\n\t\tdefault: fep->code_rate_LP = FEC_7_8; break;\n\t}\n\n\t \n\n\treturn 0;\n}\n\nstatic int dib7000m_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *fep = &fe->dtv_property_cache;\n\tstruct dib7000m_state *state = fe->demodulator_priv;\n\tint time, ret;\n\n\tdib7000m_set_output_mode(state, OUTMODE_HIGH_Z);\n\n\tdib7000m_set_bandwidth(state, BANDWIDTH_TO_KHZ(fep->bandwidth_hz));\n\n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\n\t \n\tstate->agc_state = 0;\n\tdo {\n\t\ttime = dib7000m_agc_startup(fe);\n\t\tif (time != -1)\n\t\t\tmsleep(time);\n\t} while (time != -1);\n\n\tif (fep->transmission_mode == TRANSMISSION_MODE_AUTO ||\n\t\tfep->guard_interval    == GUARD_INTERVAL_AUTO ||\n\t\tfep->modulation        == QAM_AUTO ||\n\t\tfep->code_rate_HP      == FEC_AUTO) {\n\t\tint i = 800, found;\n\n\t\tdib7000m_autosearch_start(fe);\n\t\tdo {\n\t\t\tmsleep(1);\n\t\t\tfound = dib7000m_autosearch_is_irq(fe);\n\t\t} while (found == 0 && i--);\n\n\t\tdprintk(\"autosearch returns: %d\\n\", found);\n\t\tif (found == 0 || found == 1)\n\t\t\treturn 0; \n\n\t\tdib7000m_get_frontend(fe, fep);\n\t}\n\n\tret = dib7000m_tune(fe);\n\n\t \n\tdib7000m_set_output_mode(state, OUTMODE_MPEG2_FIFO);\n\treturn ret;\n}\n\nstatic int dib7000m_read_status(struct dvb_frontend *fe, enum fe_status *stat)\n{\n\tstruct dib7000m_state *state = fe->demodulator_priv;\n\tu16 lock = dib7000m_read_word(state, 535);\n\n\t*stat = 0;\n\n\tif (lock & 0x8000)\n\t\t*stat |= FE_HAS_SIGNAL;\n\tif (lock & 0x3000)\n\t\t*stat |= FE_HAS_CARRIER;\n\tif (lock & 0x0100)\n\t\t*stat |= FE_HAS_VITERBI;\n\tif (lock & 0x0010)\n\t\t*stat |= FE_HAS_SYNC;\n\tif (lock & 0x0008)\n\t\t*stat |= FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int dib7000m_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct dib7000m_state *state = fe->demodulator_priv;\n\t*ber = (dib7000m_read_word(state, 526) << 16) | dib7000m_read_word(state, 527);\n\treturn 0;\n}\n\nstatic int dib7000m_read_unc_blocks(struct dvb_frontend *fe, u32 *unc)\n{\n\tstruct dib7000m_state *state = fe->demodulator_priv;\n\t*unc = dib7000m_read_word(state, 534);\n\treturn 0;\n}\n\nstatic int dib7000m_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct dib7000m_state *state = fe->demodulator_priv;\n\tu16 val = dib7000m_read_word(state, 390);\n\t*strength = 65535 - val;\n\treturn 0;\n}\n\nstatic int dib7000m_read_snr(struct dvb_frontend* fe, u16 *snr)\n{\n\t*snr = 0x0000;\n\treturn 0;\n}\n\nstatic int dib7000m_fe_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic void dib7000m_release(struct dvb_frontend *demod)\n{\n\tstruct dib7000m_state *st = demod->demodulator_priv;\n\tdibx000_exit_i2c_master(&st->i2c_master);\n\tkfree(st);\n}\n\nstruct i2c_adapter * dib7000m_get_i2c_master(struct dvb_frontend *demod, enum dibx000_i2c_interface intf, int gating)\n{\n\tstruct dib7000m_state *st = demod->demodulator_priv;\n\treturn dibx000_get_i2c_adapter(&st->i2c_master, intf, gating);\n}\nEXPORT_SYMBOL(dib7000m_get_i2c_master);\n\nint dib7000m_pid_filter_ctrl(struct dvb_frontend *fe, u8 onoff)\n{\n\tstruct dib7000m_state *state = fe->demodulator_priv;\n\tu16 val = dib7000m_read_word(state, 294 + state->reg_offs) & 0xffef;\n\tval |= (onoff & 0x1) << 4;\n\tdprintk(\"PID filter enabled %d\\n\", onoff);\n\treturn dib7000m_write_word(state, 294 + state->reg_offs, val);\n}\nEXPORT_SYMBOL(dib7000m_pid_filter_ctrl);\n\nint dib7000m_pid_filter(struct dvb_frontend *fe, u8 id, u16 pid, u8 onoff)\n{\n\tstruct dib7000m_state *state = fe->demodulator_priv;\n\tdprintk(\"PID filter: index %x, PID %d, OnOff %d\\n\", id, pid, onoff);\n\treturn dib7000m_write_word(state, 300 + state->reg_offs + id,\n\t\t\tonoff ? (1 << 13) | pid : 0);\n}\nEXPORT_SYMBOL(dib7000m_pid_filter);\n\n#if 0\n \nint dib7000m_i2c_enumeration(struct i2c_adapter *i2c, int no_of_demods,\n\t\tu8 default_addr, struct dib7000m_config cfg[])\n{\n\tstruct dib7000m_state st = { .i2c_adap = i2c };\n\tint k = 0;\n\tu8 new_addr = 0;\n\n\tfor (k = no_of_demods-1; k >= 0; k--) {\n\t\tst.cfg = cfg[k];\n\n\t\t \n\t\tnew_addr          = (0x40 + k) << 1;\n\t\tst.i2c_addr = new_addr;\n\t\tif (dib7000m_identify(&st) != 0) {\n\t\t\tst.i2c_addr = default_addr;\n\t\t\tif (dib7000m_identify(&st) != 0) {\n\t\t\t\tdprintk(\"DiB7000M #%d: not identified\\n\", k);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdib7000m_set_output_mode(&st, OUTMODE_DIVERSITY);\n\n\t\tdib7000m_write_word(&st, 1796, 0x0); \n\n\t\t \n\t\tdib7000m_write_word(&st, 1794, (new_addr << 2) | 0x2);\n\n\t\tdprintk(\"IC %d initialized (to i2c_address 0x%x)\\n\", k, new_addr);\n\t}\n\n\tfor (k = 0; k < no_of_demods; k++) {\n\t\tst.cfg = cfg[k];\n\t\tst.i2c_addr = (0x40 + k) << 1;\n\n\t\t\n\t\tdib7000m_write_word(&st,1794, st.i2c_addr << 2);\n\n\t\t \n\t\tdib7000m_set_output_mode(&st, OUTMODE_HIGH_Z);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dib7000m_i2c_enumeration);\n#endif\n\nstatic const struct dvb_frontend_ops dib7000m_ops;\nstruct dvb_frontend * dib7000m_attach(struct i2c_adapter *i2c_adap, u8 i2c_addr, struct dib7000m_config *cfg)\n{\n\tstruct dvb_frontend *demod;\n\tstruct dib7000m_state *st;\n\tst = kzalloc(sizeof(struct dib7000m_state), GFP_KERNEL);\n\tif (st == NULL)\n\t\treturn NULL;\n\n\tmemcpy(&st->cfg, cfg, sizeof(struct dib7000m_config));\n\tst->i2c_adap = i2c_adap;\n\tst->i2c_addr = i2c_addr;\n\n\tdemod                   = &st->demod;\n\tdemod->demodulator_priv = st;\n\tmemcpy(&st->demod.ops, &dib7000m_ops, sizeof(struct dvb_frontend_ops));\n\tmutex_init(&st->i2c_buffer_lock);\n\n\tst->timf_default = cfg->bw->timf;\n\n\tif (dib7000m_identify(st) != 0)\n\t\tgoto error;\n\n\tif (st->revision == 0x4000)\n\t\tdibx000_init_i2c_master(&st->i2c_master, DIB7000, st->i2c_adap, st->i2c_addr);\n\telse\n\t\tdibx000_init_i2c_master(&st->i2c_master, DIB7000MC, st->i2c_adap, st->i2c_addr);\n\n\tdib7000m_demod_reset(st);\n\n\treturn demod;\n\nerror:\n\tkfree(st);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(dib7000m_attach);\n\nstatic const struct dvb_frontend_ops dib7000m_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name = \"DiBcom 7000MA/MB/PA/PB/MC\",\n\t\t.frequency_min_hz      =  44250 * kHz,\n\t\t.frequency_max_hz      = 867250 * kHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_RECOVER |\n\t\t\tFE_CAN_HIERARCHY_AUTO,\n\t},\n\n\t.release              = dib7000m_release,\n\n\t.init                 = dib7000m_wakeup,\n\t.sleep                = dib7000m_sleep,\n\n\t.set_frontend         = dib7000m_set_frontend,\n\t.get_tune_settings    = dib7000m_fe_get_tune_settings,\n\t.get_frontend         = dib7000m_get_frontend,\n\n\t.read_status          = dib7000m_read_status,\n\t.read_ber             = dib7000m_read_ber,\n\t.read_signal_strength = dib7000m_read_signal_strength,\n\t.read_snr             = dib7000m_read_snr,\n\t.read_ucblocks        = dib7000m_read_unc_blocks,\n};\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"Driver for the DiBcom 7000MA/MB/PA/PB/MC COFDM demodulator\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}