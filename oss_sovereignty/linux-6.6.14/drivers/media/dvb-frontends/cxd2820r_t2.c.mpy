{
  "module_name": "cxd2820r_t2.c",
  "hash_id": "8f047dbbe0b1e1ced99f0c7551982207ee4842ac764fb7074f2249fac64adec2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cxd2820r_t2.c",
  "human_readable_source": "\n \n\n\n#include \"cxd2820r_priv.h\"\n\nint cxd2820r_set_frontend_t2(struct dvb_frontend *fe)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, bw_i;\n\tunsigned int utmp;\n\tu32 if_frequency;\n\tu8 buf[3], bw_param;\n\tu8 bw_params1[][5] = {\n\t\t{ 0x1c, 0xb3, 0x33, 0x33, 0x33 },  \n\t\t{ 0x17, 0xea, 0xaa, 0xaa, 0xaa },  \n\t\t{ 0x14, 0x80, 0x00, 0x00, 0x00 },  \n\t\t{ 0x11, 0xf0, 0x00, 0x00, 0x00 },  \n\t};\n\tstruct reg_val_mask tab[] = {\n\t\t{ 0x00080, 0x02, 0xff },\n\t\t{ 0x00081, 0x20, 0xff },\n\t\t{ 0x00085, 0x07, 0xff },\n\t\t{ 0x00088, 0x01, 0xff },\n\t\t{ 0x02069, 0x01, 0xff },\n\n\t\t{ 0x0207f, 0x2a, 0xff },\n\t\t{ 0x02082, 0x0a, 0xff },\n\t\t{ 0x02083, 0x0a, 0xff },\n\t\t{ 0x020cb, priv->if_agc_polarity << 6, 0x40 },\n\t\t{ 0x02070, priv->ts_mode, 0xff },\n\t\t{ 0x02071, !priv->ts_clk_inv << 6, 0x40 },\n\t\t{ 0x020b5, priv->spec_inv << 4, 0x10 },\n\t\t{ 0x02567, 0x07, 0x0f },\n\t\t{ 0x02569, 0x03, 0x03 },\n\t\t{ 0x02595, 0x1a, 0xff },\n\t\t{ 0x02596, 0x50, 0xff },\n\t\t{ 0x02a8c, 0x00, 0xff },\n\t\t{ 0x02a8d, 0x34, 0xff },\n\t\t{ 0x02a45, 0x06, 0x07 },\n\t\t{ 0x03f10, 0x0d, 0xff },\n\t\t{ 0x03f11, 0x02, 0xff },\n\t\t{ 0x03f12, 0x01, 0xff },\n\t\t{ 0x03f23, 0x2c, 0xff },\n\t\t{ 0x03f51, 0x13, 0xff },\n\t\t{ 0x03f52, 0x01, 0xff },\n\t\t{ 0x03f53, 0x00, 0xff },\n\t\t{ 0x027e6, 0x14, 0xff },\n\t\t{ 0x02786, 0x02, 0x07 },\n\t\t{ 0x02787, 0x40, 0xe0 },\n\t\t{ 0x027ef, 0x10, 0x18 },\n\t};\n\n\tdev_dbg(&client->dev,\n\t\t\"delivery_system=%d modulation=%d frequency=%u bandwidth_hz=%u inversion=%d stream_id=%u\\n\",\n\t\tc->delivery_system, c->modulation, c->frequency,\n\t\tc->bandwidth_hz, c->inversion, c->stream_id);\n\n\tswitch (c->bandwidth_hz) {\n\tcase 5000000:\n\t\tbw_i = 0;\n\t\tbw_param = 3;\n\t\tbreak;\n\tcase 6000000:\n\t\tbw_i = 1;\n\t\tbw_param = 2;\n\t\tbreak;\n\tcase 7000000:\n\t\tbw_i = 2;\n\t\tbw_param = 1;\n\t\tbreak;\n\tcase 8000000:\n\t\tbw_i = 3;\n\t\tbw_param = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\n\tif (priv->delivery_system != SYS_DVBT2) {\n\t\tret = cxd2820r_wr_reg_val_mask_tab(priv, tab, ARRAY_SIZE(tab));\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tpriv->delivery_system = SYS_DVBT2;\n\n\t \n\tif (fe->ops.tuner_ops.get_if_frequency) {\n\t\tret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tdev_dbg(&client->dev, \"if_frequency=%u\\n\", if_frequency);\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tutmp = DIV_ROUND_CLOSEST_ULL((u64)if_frequency * 0x1000000, CXD2820R_CLK);\n\tbuf[0] = (utmp >> 16) & 0xff;\n\tbuf[1] = (utmp >>  8) & 0xff;\n\tbuf[2] = (utmp >>  0) & 0xff;\n\tret = regmap_bulk_write(priv->regmap[0], 0x20b6, buf, 3);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tif (c->stream_id > 255) {\n\t\tdev_dbg(&client->dev, \"disable PLP filtering\\n\");\n\t\tret = regmap_write(priv->regmap[0], 0x23ad, 0x00);\n\t\tif (ret)\n\t\t\tgoto error;\n\t} else {\n\t\tdev_dbg(&client->dev, \"enable PLP filtering\\n\");\n\t\tret = regmap_write(priv->regmap[0], 0x23af, c->stream_id & 0xff);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tret = regmap_write(priv->regmap[0], 0x23ad, 0x01);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tret = regmap_bulk_write(priv->regmap[0], 0x209f, bw_params1[bw_i], 5);\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_update_bits(priv->regmap[0], 0x20d7, 0xc0, bw_param << 6);\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_write(priv->regmap[0], 0x00ff, 0x08);\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_write(priv->regmap[0], 0x00fe, 0x01);\n\tif (ret)\n\t\tgoto error;\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n\n}\n\nint cxd2820r_get_frontend_t2(struct dvb_frontend *fe,\n\t\t\t     struct dtv_frontend_properties *c)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tint ret;\n\tunsigned int utmp;\n\tu8 buf[2];\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tret = regmap_bulk_read(priv->regmap[0], 0x205c, buf, 2);\n\tif (ret)\n\t\tgoto error;\n\n\tswitch ((buf[0] >> 0) & 0x07) {\n\tcase 0:\n\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n\tcase 1:\n\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t\tbreak;\n\tcase 2:\n\t\tc->transmission_mode = TRANSMISSION_MODE_4K;\n\t\tbreak;\n\tcase 3:\n\t\tc->transmission_mode = TRANSMISSION_MODE_1K;\n\t\tbreak;\n\tcase 4:\n\t\tc->transmission_mode = TRANSMISSION_MODE_16K;\n\t\tbreak;\n\tcase 5:\n\t\tc->transmission_mode = TRANSMISSION_MODE_32K;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[1] >> 4) & 0x07) {\n\tcase 0:\n\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\tc->guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tc->guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\tcase 4:\n\t\tc->guard_interval = GUARD_INTERVAL_1_128;\n\t\tbreak;\n\tcase 5:\n\t\tc->guard_interval = GUARD_INTERVAL_19_128;\n\t\tbreak;\n\tcase 6:\n\t\tc->guard_interval = GUARD_INTERVAL_19_256;\n\t\tbreak;\n\t}\n\n\tret = regmap_bulk_read(priv->regmap[0], 0x225b, buf, 2);\n\tif (ret)\n\t\tgoto error;\n\n\tswitch ((buf[0] >> 0) & 0x07) {\n\tcase 0:\n\t\tc->fec_inner = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tc->fec_inner = FEC_3_5;\n\t\tbreak;\n\tcase 2:\n\t\tc->fec_inner = FEC_2_3;\n\t\tbreak;\n\tcase 3:\n\t\tc->fec_inner = FEC_3_4;\n\t\tbreak;\n\tcase 4:\n\t\tc->fec_inner = FEC_4_5;\n\t\tbreak;\n\tcase 5:\n\t\tc->fec_inner = FEC_5_6;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[1] >> 0) & 0x07) {\n\tcase 0:\n\t\tc->modulation = QPSK;\n\t\tbreak;\n\tcase 1:\n\t\tc->modulation = QAM_16;\n\t\tbreak;\n\tcase 2:\n\t\tc->modulation = QAM_64;\n\t\tbreak;\n\tcase 3:\n\t\tc->modulation = QAM_256;\n\t\tbreak;\n\t}\n\n\tret = regmap_read(priv->regmap[0], 0x20b5, &utmp);\n\tif (ret)\n\t\tgoto error;\n\n\tswitch ((utmp >> 4) & 0x01) {\n\tcase 0:\n\t\tc->inversion = INVERSION_OFF;\n\t\tbreak;\n\tcase 1:\n\t\tc->inversion = INVERSION_ON;\n\t\tbreak;\n\t}\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nint cxd2820r_read_status_t2(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct i2c_client *client = priv->client[0];\n\tint ret;\n\tunsigned int utmp, utmp1, utmp2;\n\tu8 buf[4];\n\n\t \n\tret = regmap_bulk_read(priv->regmap[0], 0x2010, &buf[0], 1);\n\tif (ret)\n\t\tgoto error;\n\n\tutmp1 = (buf[0] >> 0) & 0x07;\n\tutmp2 = (buf[0] >> 5) & 0x01;\n\n\tif (utmp1 == 6 && utmp2 == 1) {\n\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t  FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\t} else if (utmp1 == 6 || utmp2 == 1) {\n\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t  FE_HAS_VITERBI | FE_HAS_SYNC;\n\t} else {\n\t\t*status = 0;\n\t}\n\n\tdev_dbg(&client->dev, \"status=%02x raw=%*ph sync=%u ts=%u\\n\",\n\t\t*status, 1, buf, utmp1, utmp2);\n\n\t \n\tif (*status & FE_HAS_SIGNAL) {\n\t\tunsigned int strength;\n\n\t\tret = regmap_bulk_read(priv->regmap[0], 0x2026, buf, 2);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tutmp = buf[0] << 8 | buf[1] << 0;\n\t\tutmp = ~utmp & 0x0fff;\n\t\t \n\t\tstrength = utmp << 4 | utmp >> 8;\n\n\t\tc->strength.len = 1;\n\t\tc->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\t\tc->strength.stat[0].uvalue = strength;\n\t} else {\n\t\tc->strength.len = 1;\n\t\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (*status & FE_HAS_VITERBI) {\n\t\tunsigned int cnr;\n\n\t\tret = regmap_bulk_read(priv->regmap[0], 0x2028, buf, 2);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tutmp = buf[0] << 8 | buf[1] << 0;\n\t\tutmp = utmp & 0x0fff;\n\t\t#define CXD2820R_LOG10_8_24 15151336  \n\t\tif (utmp)\n\t\t\tcnr = div_u64((u64)(intlog10(utmp)\n\t\t\t\t      - CXD2820R_LOG10_8_24) * 10000,\n\t\t\t\t      (1 << 24));\n\t\telse\n\t\t\tcnr = 0;\n\n\t\tc->cnr.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[0].svalue = cnr;\n\t} else {\n\t\tc->cnr.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (*status & FE_HAS_SYNC) {\n\t\tunsigned int post_bit_error;\n\n\t\tret = regmap_bulk_read(priv->regmap[0], 0x2039, buf, 4);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif ((buf[0] >> 4) & 0x01) {\n\t\t\tpost_bit_error = buf[0] << 24 | buf[1] << 16 |\n\t\t\t\t\t buf[2] << 8 | buf[3] << 0;\n\t\t\tpost_bit_error &= 0x0fffffff;\n\t\t} else {\n\t\t\tpost_bit_error = 0;\n\t\t}\n\n\t\tpriv->post_bit_error += post_bit_error;\n\n\t\tc->post_bit_error.len = 1;\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[0].uvalue = priv->post_bit_error;\n\t} else {\n\t\tc->post_bit_error.len = 1;\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nint cxd2820r_sleep_t2(struct dvb_frontend *fe)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tint ret;\n\tstatic const struct reg_val_mask tab[] = {\n\t\t{ 0x000ff, 0x1f, 0xff },\n\t\t{ 0x00085, 0x00, 0xff },\n\t\t{ 0x00088, 0x01, 0xff },\n\t\t{ 0x02069, 0x00, 0xff },\n\t\t{ 0x00081, 0x00, 0xff },\n\t\t{ 0x00080, 0x00, 0xff },\n\t};\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tret = cxd2820r_wr_reg_val_mask_tab(priv, tab, ARRAY_SIZE(tab));\n\tif (ret)\n\t\tgoto error;\n\n\tpriv->delivery_system = SYS_UNDEFINED;\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nint cxd2820r_get_tune_settings_t2(struct dvb_frontend *fe,\n\tstruct dvb_frontend_tune_settings *s)\n{\n\ts->min_delay_ms = 1500;\n\ts->step_size = fe->ops.info.frequency_stepsize_hz * 2;\n\ts->max_drift = (fe->ops.info.frequency_stepsize_hz * 2) + 1;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}