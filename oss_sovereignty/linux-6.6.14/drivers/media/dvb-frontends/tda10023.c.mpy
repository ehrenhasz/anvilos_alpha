{
  "module_name": "tda10023.c",
  "hash_id": "b31232e576620907fbfb192ec4edda3bf4936b941ae5c4f36fe84adc6d9431e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tda10023.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"tda1002x.h\"\n\n#define REG0_INIT_VAL 0x23\n\nstruct tda10023_state {\n\tstruct i2c_adapter* i2c;\n\t \n\tconst struct tda10023_config *config;\n\tstruct dvb_frontend frontend;\n\n\tu8 pwm;\n\tu8 reg0;\n\n\t \n\tu32 xtal;\n\tu8 pll_m;\n\tu8 pll_p;\n\tu8 pll_n;\n\tu32 sysclk;\n};\n\n#define dprintk(x...)\n\nstatic int verbose;\n\nstatic u8 tda10023_readreg (struct tda10023_state* state, u8 reg)\n{\n\tu8 b0 [] = { reg };\n\tu8 b1 [] = { 0 };\n\tstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },\n\t\t\t\t  { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\n\tint ret;\n\n\tret = i2c_transfer (state->i2c, msg, 2);\n\tif (ret != 2) {\n\t\tint num = state->frontend.dvb ? state->frontend.dvb->num : -1;\n\t\tprintk(KERN_ERR \"DVB: TDA10023(%d): %s: readreg error (reg == 0x%02x, ret == %i)\\n\",\n\t\t\tnum, __func__, reg, ret);\n\t}\n\treturn b1[0];\n}\n\nstatic int tda10023_writereg (struct tda10023_state* state, u8 reg, u8 data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\n\tint ret;\n\n\tret = i2c_transfer (state->i2c, &msg, 1);\n\tif (ret != 1) {\n\t\tint num = state->frontend.dvb ? state->frontend.dvb->num : -1;\n\t\tprintk(KERN_ERR \"DVB: TDA10023(%d): %s, writereg error (reg == 0x%02x, val == 0x%02x, ret == %i)\\n\",\n\t\t\tnum, __func__, reg, data, ret);\n\t}\n\treturn (ret != 1) ? -EREMOTEIO : 0;\n}\n\n\nstatic int tda10023_writebit (struct tda10023_state* state, u8 reg, u8 mask,u8 data)\n{\n\tif (mask==0xff)\n\t\treturn tda10023_writereg(state, reg, data);\n\telse {\n\t\tu8 val;\n\t\tval=tda10023_readreg(state,reg);\n\t\tval&=~mask;\n\t\tval|=(data&mask);\n\t\treturn tda10023_writereg(state, reg, val);\n\t}\n}\n\nstatic void tda10023_writetab(struct tda10023_state* state, u8* tab)\n{\n\tu8 r,m,v;\n\twhile (1) {\n\t\tr=*tab++;\n\t\tm=*tab++;\n\t\tv=*tab++;\n\t\tif (r==0xff) {\n\t\t\tif (m==0xff)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tmsleep(m);\n\t\t}\n\t\telse\n\t\t\ttda10023_writebit(state,r,m,v);\n\t}\n}\n\n\nstatic int lock_tuner(struct tda10023_state* state)\n{\n\tu8 buf[2] = { 0x0f, 0xc0 };\n\tstruct i2c_msg msg = {.addr=state->config->demod_address, .flags=0, .buf=buf, .len=2};\n\n\tif(i2c_transfer(state->i2c, &msg, 1) != 1)\n\t{\n\t\tprintk(\"tda10023: lock tuner fails\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\n\nstatic int unlock_tuner(struct tda10023_state* state)\n{\n\tu8 buf[2] = { 0x0f, 0x40 };\n\tstruct i2c_msg msg_post={.addr=state->config->demod_address, .flags=0, .buf=buf, .len=2};\n\n\tif(i2c_transfer(state->i2c, &msg_post, 1) != 1)\n\t{\n\t\tprintk(\"tda10023: unlock tuner fails\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int tda10023_setup_reg0 (struct tda10023_state* state, u8 reg0)\n{\n\treg0 |= state->reg0 & 0x63;\n\n\ttda10023_writereg (state, 0x00, reg0 & 0xfe);\n\ttda10023_writereg (state, 0x00, reg0 | 0x01);\n\n\tstate->reg0 = reg0;\n\treturn 0;\n}\n\nstatic int tda10023_set_symbolrate (struct tda10023_state* state, u32 sr)\n{\n\ts32 BDR;\n\ts32 BDRI;\n\ts16 SFIL=0;\n\tu16 NDEC = 0;\n\n\t \n\tu32 sysclk_x_10 = state->sysclk * 10;\n\n\tif (sr < (u32)(sysclk_x_10/984)) {\n\t\tNDEC=3;\n\t\tSFIL=1;\n\t} else if (sr < (u32)(sysclk_x_10/640)) {\n\t\tNDEC=3;\n\t\tSFIL=0;\n\t} else if (sr < (u32)(sysclk_x_10/492)) {\n\t\tNDEC=2;\n\t\tSFIL=1;\n\t} else if (sr < (u32)(sysclk_x_10/320)) {\n\t\tNDEC=2;\n\t\tSFIL=0;\n\t} else if (sr < (u32)(sysclk_x_10/246)) {\n\t\tNDEC=1;\n\t\tSFIL=1;\n\t} else if (sr < (u32)(sysclk_x_10/160)) {\n\t\tNDEC=1;\n\t\tSFIL=0;\n\t} else if (sr < (u32)(sysclk_x_10/123)) {\n\t\tNDEC=0;\n\t\tSFIL=1;\n\t}\n\n\tBDRI = (state->sysclk)*16;\n\tBDRI>>=NDEC;\n\tBDRI +=sr/2;\n\tBDRI /=sr;\n\n\tif (BDRI>255)\n\t\tBDRI=255;\n\n\t{\n\t\tu64 BDRX;\n\n\t\tBDRX=1<<(24+NDEC);\n\t\tBDRX*=sr;\n\t\tdo_div(BDRX, state->sysclk);\t \n\n\t\tBDR=(s32)BDRX;\n\t}\n\tdprintk(\"Symbolrate %i, BDR %i BDRI %i, NDEC %i\\n\",\n\t\tsr, BDR, BDRI, NDEC);\n\ttda10023_writebit (state, 0x03, 0xc0, NDEC<<6);\n\ttda10023_writereg (state, 0x0a, BDR&255);\n\ttda10023_writereg (state, 0x0b, (BDR>>8)&255);\n\ttda10023_writereg (state, 0x0c, (BDR>>16)&31);\n\ttda10023_writereg (state, 0x0d, BDRI);\n\ttda10023_writereg (state, 0x3d, (SFIL<<7));\n\treturn 0;\n}\n\nstatic int tda10023_init (struct dvb_frontend *fe)\n{\n\tstruct tda10023_state* state = fe->demodulator_priv;\n\tu8 tda10023_inittab[] = {\n \n  0x2a, 0xff, 0x02,   \n  0xff, 0x64, 0x00,   \n  0x2a, 0xff, 0x03,   \n  0xff, 0x64, 0x00,   \n\t\t\t    \n  0x28, 0xff, (state->pll_m-1),\n\t\t\t    \n  0x29, 0xff, ((state->pll_p-1)<<6)|(state->pll_n-1),\n\t\t\t    \n  0x00, 0xff, REG0_INIT_VAL,\n  0x2a, 0xff, 0x08,   \n  0xff, 0x64, 0x00,   \n  0x1f, 0xff, 0x00,   \n  0xff, 0x64, 0x00,   \n  0xe6, 0x0c, 0x04,   \n  0x10, 0xc0, 0x80,   \n\n  0x0e, 0xff, 0x82,   \n  0x03, 0x08, 0x08,   \n  0x2e, 0xbf, 0x30,   \n  0x01, 0xff, 0x30,   \n  0x1e, 0x84, 0x84,   \n  0x1b, 0xff, 0xc8,   \n  0x3b, 0xff, 0xff,   \n  0x3c, 0xff, 0x00,   \n  0x34, 0xff, 0x00,   \n  0x35, 0xff, 0xff,   \n  0x36, 0xff, 0x00,   \n  0x06, 0xff, 0x7f,   \n  0x1c, 0x30, 0x30,   \n  0x37, 0xff, 0xf6,   \n  0x38, 0xff, 0xff,   \n  0x02, 0xff, 0x93,   \n  0x2d, 0xff, 0xf6,   \n  0x04, 0x10, 0x00,   \n  0x12, 0xff, TDA10023_OUTPUT_MODE_PARALLEL_B,  \n  0x2b, 0x01, 0xa1,   \n  0x20, 0xff, 0x04,   \n  0x2c, 0xff, 0x0d,   \n  0xc4, 0xff, 0x00,\n  0xc3, 0x30, 0x00,\n  0xb5, 0xff, 0x19,   \n  0x00, 0x03, 0x01,   \n  0x00, 0x03, 0x03,   \n  0xff, 0x64, 0x00,   \n  0xff, 0xff, 0xff\n};\n\tdprintk(\"DVB: TDA10023(%d): init chip\\n\", fe->dvb->num);\n\n\t \n\tif (state->config->deltaf) {\n\t\ttda10023_inittab[80] = (state->config->deltaf & 0xff);\n\t\ttda10023_inittab[83] = (state->config->deltaf >> 8);\n\t}\n\n\tif (state->config->output_mode)\n\t\ttda10023_inittab[95] = state->config->output_mode;\n\n\ttda10023_writetab(state, tda10023_inittab);\n\n\treturn 0;\n}\n\nstruct qam_params {\n\tu8 qam, lockthr, mseth, aref, agcrefnyq, eragnyq_thd;\n};\n\nstatic int tda10023_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 delsys  = c->delivery_system;\n\tunsigned qam = c->modulation;\n\tbool is_annex_c;\n\tstruct tda10023_state* state = fe->demodulator_priv;\n\tstatic const struct qam_params qam_params[] = {\n\t\t \n\t\t[QPSK]    = { (5<<2),  0x78,    0x8c,   0x96,   0x78,   0x4c  },\n\t\t[QAM_16]  = { (0<<2),  0x87,    0xa2,   0x91,   0x8c,   0x57  },\n\t\t[QAM_32]  = { (1<<2),  0x64,    0x74,   0x96,   0x8c,   0x57  },\n\t\t[QAM_64]  = { (2<<2),  0x46,    0x43,   0x6a,   0x6a,   0x44  },\n\t\t[QAM_128] = { (3<<2),  0x36,    0x34,   0x7e,   0x78,   0x4c  },\n\t\t[QAM_256] = { (4<<2),  0x26,    0x23,   0x6c,   0x5c,   0x3c  },\n\t};\n\n\tswitch (delsys) {\n\tcase SYS_DVBC_ANNEX_A:\n\t\tis_annex_c = false;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_C:\n\t\tis_annex_c = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (qam) {\n\tcase QPSK:\n\tcase QAM_16:\n\tcase QAM_32:\n\tcase QAM_64:\n\tcase QAM_128:\n\tcase QAM_256:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\ttda10023_set_symbolrate(state, c->symbol_rate);\n\ttda10023_writereg(state, 0x05, qam_params[qam].lockthr);\n\ttda10023_writereg(state, 0x08, qam_params[qam].mseth);\n\ttda10023_writereg(state, 0x09, qam_params[qam].aref);\n\ttda10023_writereg(state, 0xb4, qam_params[qam].agcrefnyq);\n\ttda10023_writereg(state, 0xb6, qam_params[qam].eragnyq_thd);\n#if 0\n\ttda10023_writereg(state, 0x04, (c->inversion ? 0x12 : 0x32));\n\ttda10023_writebit(state, 0x04, 0x60, (c->inversion ? 0 : 0x20));\n#endif\n\ttda10023_writebit(state, 0x04, 0x40, 0x40);\n\n\tif (is_annex_c)\n\t\ttda10023_writebit(state, 0x3d, 0xfc, 0x03);\n\telse\n\t\ttda10023_writebit(state, 0x3d, 0xfc, 0x02);\n\n\ttda10023_setup_reg0(state, qam_params[qam].qam);\n\n\treturn 0;\n}\n\nstatic int tda10023_read_status(struct dvb_frontend *fe,\n\t\t\t\tenum fe_status *status)\n{\n\tstruct tda10023_state* state = fe->demodulator_priv;\n\tint sync;\n\n\t*status = 0;\n\n\t\n\t\n\t\n\t\n\tsync = tda10023_readreg (state, 0x11);\n\n\tif (sync & 2)\n\t\t*status |= FE_HAS_SIGNAL|FE_HAS_CARRIER;\n\n\tif (sync & 4)\n\t\t*status |= FE_HAS_SYNC|FE_HAS_VITERBI;\n\n\tif (sync & 8)\n\t\t*status |= FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int tda10023_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct tda10023_state* state = fe->demodulator_priv;\n\tu8 a,b,c;\n\ta=tda10023_readreg(state, 0x14);\n\tb=tda10023_readreg(state, 0x15);\n\tc=tda10023_readreg(state, 0x16)&0xf;\n\ttda10023_writebit (state, 0x10, 0xc0, 0x00);\n\n\t*ber = a | (b<<8)| (c<<16);\n\treturn 0;\n}\n\nstatic int tda10023_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\tstruct tda10023_state* state = fe->demodulator_priv;\n\tu8 ifgain=tda10023_readreg(state, 0x2f);\n\n\tu16 gain = ((255-tda10023_readreg(state, 0x17))) + (255-ifgain)/16;\n\t\n\tif (gain>0x90)\n\t\tgain=gain+2*(gain-0x90);\n\tif (gain>255)\n\t\tgain=255;\n\n\t*strength = (gain<<8)|gain;\n\treturn 0;\n}\n\nstatic int tda10023_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct tda10023_state* state = fe->demodulator_priv;\n\n\tu8 quality = ~tda10023_readreg(state, 0x18);\n\t*snr = (quality << 8) | quality;\n\treturn 0;\n}\n\nstatic int tda10023_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct tda10023_state* state = fe->demodulator_priv;\n\tu8 a,b,c,d;\n\ta= tda10023_readreg (state, 0x74);\n\tb= tda10023_readreg (state, 0x75);\n\tc= tda10023_readreg (state, 0x76);\n\td= tda10023_readreg (state, 0x77);\n\t*ucblocks = a | (b<<8)|(c<<16)|(d<<24);\n\n\ttda10023_writebit (state, 0x10, 0x20,0x00);\n\ttda10023_writebit (state, 0x10, 0x20,0x20);\n\ttda10023_writebit (state, 0x13, 0x01, 0x00);\n\n\treturn 0;\n}\n\nstatic int tda10023_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t struct dtv_frontend_properties *p)\n{\n\tstruct tda10023_state* state = fe->demodulator_priv;\n\tint sync,inv;\n\ts8 afc = 0;\n\n\tsync = tda10023_readreg(state, 0x11);\n\tafc = tda10023_readreg(state, 0x19);\n\tinv = tda10023_readreg(state, 0x04);\n\n\tif (verbose) {\n\t\t \n\t\tprintk(sync & 2 ? \"DVB: TDA10023(%d): AFC (%d) %dHz\\n\" :\n\t\t\t\t  \"DVB: TDA10023(%d): [AFC (%d) %dHz]\\n\",\n\t\t\tstate->frontend.dvb->num, afc,\n\t\t       -((s32)p->symbol_rate * afc) >> 10);\n\t}\n\n\tp->inversion = (inv&0x20?0:1);\n\tp->modulation = ((state->reg0 >> 2) & 7) + QAM_16;\n\n\tp->fec_inner = FEC_NONE;\n\tp->frequency = ((p->frequency + 31250) / 62500) * 62500;\n\n\tif (sync & 2)\n\t\tp->frequency -= ((s32)p->symbol_rate * afc) >> 10;\n\n\treturn 0;\n}\n\nstatic int tda10023_sleep(struct dvb_frontend* fe)\n{\n\tstruct tda10023_state* state = fe->demodulator_priv;\n\n\ttda10023_writereg (state, 0x1b, 0x02);   \n\ttda10023_writereg (state, 0x00, 0x80);   \n\n\treturn 0;\n}\n\nstatic int tda10023_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\n{\n\tstruct tda10023_state* state = fe->demodulator_priv;\n\n\tif (enable) {\n\t\tlock_tuner(state);\n\t} else {\n\t\tunlock_tuner(state);\n\t}\n\treturn 0;\n}\n\nstatic void tda10023_release(struct dvb_frontend* fe)\n{\n\tstruct tda10023_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops tda10023_ops;\n\nstruct dvb_frontend *tda10023_attach(const struct tda10023_config *config,\n\t\t\t\t     struct i2c_adapter *i2c,\n\t\t\t\t     u8 pwm)\n{\n\tstruct tda10023_state* state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct tda10023_state), GFP_KERNEL);\n\tif (state == NULL) goto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t \n\ttda10023_writereg (state, 0x00, 0x33);\n\t \n\tif ((tda10023_readreg(state, 0x1a) & 0xf0) != 0x70) goto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &tda10023_ops, sizeof(struct dvb_frontend_ops));\n\tstate->pwm = pwm;\n\tstate->reg0 = REG0_INIT_VAL;\n\tif (state->config->xtal) {\n\t\tstate->xtal  = state->config->xtal;\n\t\tstate->pll_m = state->config->pll_m;\n\t\tstate->pll_p = state->config->pll_p;\n\t\tstate->pll_n = state->config->pll_n;\n\t} else {\n\t\t \n\t\tstate->xtal  = 28920000;\n\t\tstate->pll_m = 8;\n\t\tstate->pll_p = 4;\n\t\tstate->pll_n = 1;\n\t}\n\n\t \n\tstate->sysclk = (state->xtal * state->pll_m / \\\n\t\t\t(state->pll_n * state->pll_p));\n\n\tstate->frontend.ops.info.symbol_rate_min = (state->sysclk/2)/64;\n\tstate->frontend.ops.info.symbol_rate_max = (state->sysclk/2)/4;\n\n\tdprintk(\"DVB: TDA10023 %s: xtal:%d pll_m:%d pll_p:%d pll_n:%d\\n\",\n\t\t__func__, state->xtal, state->pll_m, state->pll_p,\n\t\tstate->pll_n);\n\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops tda10023_ops = {\n\t.delsys = { SYS_DVBC_ANNEX_A, SYS_DVBC_ANNEX_C },\n\t.info = {\n\t\t.name = \"Philips TDA10023 DVB-C\",\n\t\t.frequency_min_hz =  47 * MHz,\n\t\t.frequency_max_hz = 862 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.symbol_rate_min = 0,   \n\t\t.symbol_rate_max = 0,   \n\t\t.caps = 0x400 | \n\t\t\tFE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_128 | FE_CAN_QAM_256 |\n\t\t\tFE_CAN_FEC_AUTO\n\t},\n\n\t.release = tda10023_release,\n\n\t.init = tda10023_init,\n\t.sleep = tda10023_sleep,\n\t.i2c_gate_ctrl = tda10023_i2c_gate_ctrl,\n\n\t.set_frontend = tda10023_set_parameters,\n\t.get_frontend = tda10023_get_frontend,\n\t.read_status = tda10023_read_status,\n\t.read_ber = tda10023_read_ber,\n\t.read_signal_strength = tda10023_read_signal_strength,\n\t.read_snr = tda10023_read_snr,\n\t.read_ucblocks = tda10023_read_ucblocks,\n};\n\n\nMODULE_DESCRIPTION(\"Philips TDA10023 DVB-C demodulator driver\");\nMODULE_AUTHOR(\"Georg Acher, Hartmut Birr\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(tda10023_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}