{
  "module_name": "s5h1409.c",
  "hash_id": "5f25683bcd3a66657638840b289a428c31ee23578c1412c09f6708f90cb57957",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/s5h1409.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <media/dvb_frontend.h>\n#include \"s5h1409.h\"\n\nstruct s5h1409_state {\n\n\tstruct i2c_adapter *i2c;\n\n\t \n\tconst struct s5h1409_config *config;\n\n\tstruct dvb_frontend frontend;\n\n\t \n\tenum fe_modulation current_modulation;\n\n\tu32 current_frequency;\n\tint if_freq;\n\n\tu32 is_qam_locked;\n\n\t \n#define QAM_STATE_UNTUNED 0\n#define QAM_STATE_TUNING_STARTED 1\n#define QAM_STATE_INTERLEAVE_SET 2\n#define QAM_STATE_QAM_OPTIMIZED_L1 3\n#define QAM_STATE_QAM_OPTIMIZED_L2 4\n#define QAM_STATE_QAM_OPTIMIZED_L3 5\n\tu8  qam_state;\n};\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Enable verbose debug messages\");\n\n#define dprintk\tif (debug) printk\n\n \nstatic struct init_tab {\n\tu8\treg;\n\tu16\tdata;\n} init_tab[] = {\n\t{ 0x00, 0x0071, },\n\t{ 0x01, 0x3213, },\n\t{ 0x09, 0x0025, },\n\t{ 0x1c, 0x001d, },\n\t{ 0x1f, 0x002d, },\n\t{ 0x20, 0x001d, },\n\t{ 0x22, 0x0022, },\n\t{ 0x23, 0x0020, },\n\t{ 0x29, 0x110f, },\n\t{ 0x2a, 0x10b4, },\n\t{ 0x2b, 0x10ae, },\n\t{ 0x2c, 0x0031, },\n\t{ 0x31, 0x010d, },\n\t{ 0x32, 0x0100, },\n\t{ 0x44, 0x0510, },\n\t{ 0x54, 0x0104, },\n\t{ 0x58, 0x2222, },\n\t{ 0x59, 0x1162, },\n\t{ 0x5a, 0x3211, },\n\t{ 0x5d, 0x0370, },\n\t{ 0x5e, 0x0296, },\n\t{ 0x61, 0x0010, },\n\t{ 0x63, 0x4a00, },\n\t{ 0x65, 0x0800, },\n\t{ 0x71, 0x0003, },\n\t{ 0x72, 0x0470, },\n\t{ 0x81, 0x0002, },\n\t{ 0x82, 0x0600, },\n\t{ 0x86, 0x0002, },\n\t{ 0x8a, 0x2c38, },\n\t{ 0x8b, 0x2a37, },\n\t{ 0x92, 0x302f, },\n\t{ 0x93, 0x3332, },\n\t{ 0x96, 0x000c, },\n\t{ 0x99, 0x0101, },\n\t{ 0x9c, 0x2e37, },\n\t{ 0x9d, 0x2c37, },\n\t{ 0x9e, 0x2c37, },\n\t{ 0xab, 0x0100, },\n\t{ 0xac, 0x1003, },\n\t{ 0xad, 0x103f, },\n\t{ 0xe2, 0x0100, },\n\t{ 0xe3, 0x1000, },\n\t{ 0x28, 0x1010, },\n\t{ 0xb1, 0x000e, },\n};\n\n \nstatic struct vsb_snr_tab {\n\tu16\tval;\n\tu16\tdata;\n} vsb_snr_tab[] = {\n\t{  924, 300, },\n\t{  923, 300, },\n\t{  918, 295, },\n\t{  915, 290, },\n\t{  911, 285, },\n\t{  906, 280, },\n\t{  901, 275, },\n\t{  896, 270, },\n\t{  891, 265, },\n\t{  885, 260, },\n\t{  879, 255, },\n\t{  873, 250, },\n\t{  864, 245, },\n\t{  858, 240, },\n\t{  850, 235, },\n\t{  841, 230, },\n\t{  832, 225, },\n\t{  823, 220, },\n\t{  812, 215, },\n\t{  802, 210, },\n\t{  788, 205, },\n\t{  778, 200, },\n\t{  767, 195, },\n\t{  753, 190, },\n\t{  740, 185, },\n\t{  725, 180, },\n\t{  707, 175, },\n\t{  689, 170, },\n\t{  671, 165, },\n\t{  656, 160, },\n\t{  637, 155, },\n\t{  616, 150, },\n\t{  542, 145, },\n\t{  519, 140, },\n\t{  507, 135, },\n\t{  497, 130, },\n\t{  492, 125, },\n\t{  474, 120, },\n\t{  300, 111, },\n\t{    0,   0, },\n};\n\n \nstatic struct qam64_snr_tab {\n\tu16\tval;\n\tu16\tdata;\n} qam64_snr_tab[] = {\n\t{    1,   0, },\n\t{   12, 300, },\n\t{   15, 290, },\n\t{   18, 280, },\n\t{   22, 270, },\n\t{   23, 268, },\n\t{   24, 266, },\n\t{   25, 264, },\n\t{   27, 262, },\n\t{   28, 260, },\n\t{   29, 258, },\n\t{   30, 256, },\n\t{   32, 254, },\n\t{   33, 252, },\n\t{   34, 250, },\n\t{   35, 249, },\n\t{   36, 248, },\n\t{   37, 247, },\n\t{   38, 246, },\n\t{   39, 245, },\n\t{   40, 244, },\n\t{   41, 243, },\n\t{   42, 241, },\n\t{   43, 240, },\n\t{   44, 239, },\n\t{   45, 238, },\n\t{   46, 237, },\n\t{   47, 236, },\n\t{   48, 235, },\n\t{   49, 234, },\n\t{   50, 233, },\n\t{   51, 232, },\n\t{   52, 231, },\n\t{   53, 230, },\n\t{   55, 229, },\n\t{   56, 228, },\n\t{   57, 227, },\n\t{   58, 226, },\n\t{   59, 225, },\n\t{   60, 224, },\n\t{   62, 223, },\n\t{   63, 222, },\n\t{   65, 221, },\n\t{   66, 220, },\n\t{   68, 219, },\n\t{   69, 218, },\n\t{   70, 217, },\n\t{   72, 216, },\n\t{   73, 215, },\n\t{   75, 214, },\n\t{   76, 213, },\n\t{   78, 212, },\n\t{   80, 211, },\n\t{   81, 210, },\n\t{   83, 209, },\n\t{   84, 208, },\n\t{   85, 207, },\n\t{   87, 206, },\n\t{   89, 205, },\n\t{   91, 204, },\n\t{   93, 203, },\n\t{   95, 202, },\n\t{   96, 201, },\n\t{  104, 200, },\n\t{  255,   0, },\n};\n\n \nstatic struct qam256_snr_tab {\n\tu16\tval;\n\tu16\tdata;\n} qam256_snr_tab[] = {\n\t{    1,   0, },\n\t{   12, 400, },\n\t{   13, 390, },\n\t{   15, 380, },\n\t{   17, 360, },\n\t{   19, 350, },\n\t{   22, 348, },\n\t{   23, 346, },\n\t{   24, 344, },\n\t{   25, 342, },\n\t{   26, 340, },\n\t{   27, 336, },\n\t{   28, 334, },\n\t{   29, 332, },\n\t{   30, 330, },\n\t{   31, 328, },\n\t{   32, 326, },\n\t{   33, 325, },\n\t{   34, 322, },\n\t{   35, 320, },\n\t{   37, 318, },\n\t{   39, 316, },\n\t{   40, 314, },\n\t{   41, 312, },\n\t{   42, 310, },\n\t{   43, 308, },\n\t{   46, 306, },\n\t{   47, 304, },\n\t{   49, 302, },\n\t{   51, 300, },\n\t{   53, 298, },\n\t{   54, 297, },\n\t{   55, 296, },\n\t{   56, 295, },\n\t{   57, 294, },\n\t{   59, 293, },\n\t{   60, 292, },\n\t{   61, 291, },\n\t{   63, 290, },\n\t{   64, 289, },\n\t{   65, 288, },\n\t{   66, 287, },\n\t{   68, 286, },\n\t{   69, 285, },\n\t{   71, 284, },\n\t{   72, 283, },\n\t{   74, 282, },\n\t{   75, 281, },\n\t{   76, 280, },\n\t{   77, 279, },\n\t{   78, 278, },\n\t{   81, 277, },\n\t{   83, 276, },\n\t{   84, 275, },\n\t{   86, 274, },\n\t{   87, 273, },\n\t{   89, 272, },\n\t{   90, 271, },\n\t{   92, 270, },\n\t{   93, 269, },\n\t{   95, 268, },\n\t{   96, 267, },\n\t{   98, 266, },\n\t{  100, 265, },\n\t{  102, 264, },\n\t{  104, 263, },\n\t{  105, 262, },\n\t{  106, 261, },\n\t{  110, 260, },\n\t{  255,   0, },\n};\n\n \nstatic int s5h1409_writereg(struct s5h1409_state *state, u8 reg, u16 data)\n{\n\tint ret;\n\tu8 buf[] = { reg, data >> 8,  data & 0xff };\n\n\tstruct i2c_msg msg = { .addr = state->config->demod_address,\n\t\t\t       .flags = 0, .buf = buf, .len = 3 };\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tprintk(KERN_ERR \"%s: error (reg == 0x%02x, val == 0x%04x, ret == %i)\\n\",\n\t\t       __func__, reg, data, ret);\n\n\treturn (ret != 1) ? -1 : 0;\n}\n\nstatic u16 s5h1409_readreg(struct s5h1409_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0, 0 };\n\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->config->demod_address, .flags = 0,\n\t\t  .buf = b0, .len = 1 },\n\t\t{ .addr = state->config->demod_address, .flags = I2C_M_RD,\n\t\t  .buf = b1, .len = 2 } };\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tprintk(\"%s: readreg error (ret == %i)\\n\", __func__, ret);\n\treturn (b1[0] << 8) | b1[1];\n}\n\nstatic int s5h1409_softreset(struct dvb_frontend *fe)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\ts5h1409_writereg(state, 0xf5, 0);\n\ts5h1409_writereg(state, 0xf5, 1);\n\tstate->is_qam_locked = 0;\n\tstate->qam_state = QAM_STATE_UNTUNED;\n\treturn 0;\n}\n\n#define S5H1409_VSB_IF_FREQ 5380\n#define S5H1409_QAM_IF_FREQ (state->config->qam_if)\n\nstatic int s5h1409_set_if_freq(struct dvb_frontend *fe, int KHz)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(%d KHz)\\n\", __func__, KHz);\n\n\tswitch (KHz) {\n\tcase 4000:\n\t\ts5h1409_writereg(state, 0x87, 0x014b);\n\t\ts5h1409_writereg(state, 0x88, 0x0cb5);\n\t\ts5h1409_writereg(state, 0x89, 0x03e2);\n\t\tbreak;\n\tcase 5380:\n\tcase 44000:\n\tdefault:\n\t\ts5h1409_writereg(state, 0x87, 0x01be);\n\t\ts5h1409_writereg(state, 0x88, 0x0436);\n\t\ts5h1409_writereg(state, 0x89, 0x054d);\n\t\tbreak;\n\t}\n\tstate->if_freq = KHz;\n\n\treturn 0;\n}\n\nstatic int s5h1409_set_spectralinversion(struct dvb_frontend *fe, int inverted)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(%d)\\n\", __func__, inverted);\n\n\tif (inverted == 1)\n\t\treturn s5h1409_writereg(state, 0x1b, 0x1101);  \n\telse\n\t\treturn s5h1409_writereg(state, 0x1b, 0x0110);  \n}\n\nstatic int s5h1409_enable_modulation(struct dvb_frontend *fe,\n\t\t\t\t     enum fe_modulation m)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(0x%08x)\\n\", __func__, m);\n\n\tswitch (m) {\n\tcase VSB_8:\n\t\tdprintk(\"%s() VSB_8\\n\", __func__);\n\t\tif (state->if_freq != S5H1409_VSB_IF_FREQ)\n\t\t\ts5h1409_set_if_freq(fe, S5H1409_VSB_IF_FREQ);\n\t\ts5h1409_writereg(state, 0xf4, 0);\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\tcase QAM_AUTO:\n\t\tdprintk(\"%s() QAM_AUTO (64/256)\\n\", __func__);\n\t\tif (state->if_freq != S5H1409_QAM_IF_FREQ)\n\t\t\ts5h1409_set_if_freq(fe, S5H1409_QAM_IF_FREQ);\n\t\ts5h1409_writereg(state, 0xf4, 1);\n\t\ts5h1409_writereg(state, 0x85, 0x110);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s() Invalid modulation\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tstate->current_modulation = m;\n\ts5h1409_softreset(fe);\n\n\treturn 0;\n}\n\nstatic int s5h1409_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(%d)\\n\", __func__, enable);\n\n\tif (enable)\n\t\treturn s5h1409_writereg(state, 0xf3, 1);\n\telse\n\t\treturn s5h1409_writereg(state, 0xf3, 0);\n}\n\nstatic int s5h1409_set_gpio(struct dvb_frontend *fe, int enable)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(%d)\\n\", __func__, enable);\n\n\tif (enable)\n\t\treturn s5h1409_writereg(state, 0xe3,\n\t\t\ts5h1409_readreg(state, 0xe3) | 0x1100);\n\telse\n\t\treturn s5h1409_writereg(state, 0xe3,\n\t\t\ts5h1409_readreg(state, 0xe3) & 0xfeff);\n}\n\nstatic int s5h1409_sleep(struct dvb_frontend *fe, int enable)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(%d)\\n\", __func__, enable);\n\n\treturn s5h1409_writereg(state, 0xf2, enable);\n}\n\nstatic int s5h1409_register_reset(struct dvb_frontend *fe)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\treturn s5h1409_writereg(state, 0xfa, 0);\n}\n\nstatic void s5h1409_set_qam_amhum_mode(struct dvb_frontend *fe)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\tu16 reg;\n\n\tif (state->qam_state < QAM_STATE_INTERLEAVE_SET) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (state->qam_state == QAM_STATE_QAM_OPTIMIZED_L3) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\treg = s5h1409_readreg(state, 0xf0);\n\n\tif ((reg >> 13) & 0x1) {\n\t\treg &= 0xff;\n\n\t\ts5h1409_writereg(state, 0x96, 0x000c);\n\t\tif (reg < 0x68) {\n\t\t\tif (state->qam_state < QAM_STATE_QAM_OPTIMIZED_L3) {\n\t\t\t\tdprintk(\"%s() setting QAM state to OPT_L3\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\ts5h1409_writereg(state, 0x93, 0x3130);\n\t\t\t\ts5h1409_writereg(state, 0x9e, 0x2836);\n\t\t\t\tstate->qam_state = QAM_STATE_QAM_OPTIMIZED_L3;\n\t\t\t}\n\t\t} else {\n\t\t\tif (state->qam_state < QAM_STATE_QAM_OPTIMIZED_L2) {\n\t\t\t\tdprintk(\"%s() setting QAM state to OPT_L2\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\ts5h1409_writereg(state, 0x93, 0x3332);\n\t\t\t\ts5h1409_writereg(state, 0x9e, 0x2c37);\n\t\t\t\tstate->qam_state = QAM_STATE_QAM_OPTIMIZED_L2;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tif (state->qam_state < QAM_STATE_QAM_OPTIMIZED_L1) {\n\t\t\tdprintk(\"%s() setting QAM state to OPT_L1\\n\", __func__);\n\t\t\ts5h1409_writereg(state, 0x96, 0x0008);\n\t\t\ts5h1409_writereg(state, 0x93, 0x3332);\n\t\t\ts5h1409_writereg(state, 0x9e, 0x2c37);\n\t\t\tstate->qam_state = QAM_STATE_QAM_OPTIMIZED_L1;\n\t\t}\n\t}\n}\n\nstatic void s5h1409_set_qam_amhum_mode_legacy(struct dvb_frontend *fe)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\tu16 reg;\n\n\tif (state->is_qam_locked)\n\t\treturn;\n\n\t \n\treg = s5h1409_readreg(state, 0xf0);\n\n\tif ((reg >> 13) & 0x1) {\n\n\t\tstate->is_qam_locked = 1;\n\t\treg &= 0xff;\n\n\t\ts5h1409_writereg(state, 0x96, 0x00c);\n\t\tif ((reg < 0x38) || (reg > 0x68)) {\n\t\t\ts5h1409_writereg(state, 0x93, 0x3332);\n\t\t\ts5h1409_writereg(state, 0x9e, 0x2c37);\n\t\t} else {\n\t\t\ts5h1409_writereg(state, 0x93, 0x3130);\n\t\t\ts5h1409_writereg(state, 0x9e, 0x2836);\n\t\t}\n\n\t} else {\n\t\ts5h1409_writereg(state, 0x96, 0x0008);\n\t\ts5h1409_writereg(state, 0x93, 0x3332);\n\t\ts5h1409_writereg(state, 0x9e, 0x2c37);\n\t}\n}\n\nstatic void s5h1409_set_qam_interleave_mode(struct dvb_frontend *fe)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\tu16 reg, reg1, reg2;\n\n\tif (state->qam_state >= QAM_STATE_INTERLEAVE_SET) {\n\t\t \n\t\treturn;\n\t}\n\n\treg = s5h1409_readreg(state, 0xf1);\n\n\t \n\tif ((reg >> 15) & 0x1) {\n\t\tif (state->qam_state == QAM_STATE_UNTUNED ||\n\t\t    state->qam_state == QAM_STATE_TUNING_STARTED) {\n\t\t\tdprintk(\"%s() setting QAM state to INTERLEAVE_SET\\n\",\n\t\t\t\t__func__);\n\t\t\treg1 = s5h1409_readreg(state, 0xb2);\n\t\t\treg2 = s5h1409_readreg(state, 0xad);\n\n\t\t\ts5h1409_writereg(state, 0x96, 0x0020);\n\t\t\ts5h1409_writereg(state, 0xad,\n\t\t\t\t(((reg1 & 0xf000) >> 4) | (reg2 & 0xf0ff)));\n\t\t\tstate->qam_state = QAM_STATE_INTERLEAVE_SET;\n\t\t}\n\t} else {\n\t\tif (state->qam_state == QAM_STATE_UNTUNED) {\n\t\t\tdprintk(\"%s() setting QAM state to TUNING_STARTED\\n\",\n\t\t\t\t__func__);\n\t\t\ts5h1409_writereg(state, 0x96, 0x08);\n\t\t\ts5h1409_writereg(state, 0xab,\n\t\t\t\ts5h1409_readreg(state, 0xab) | 0x1001);\n\t\t\tstate->qam_state = QAM_STATE_TUNING_STARTED;\n\t\t}\n\t}\n}\n\nstatic void s5h1409_set_qam_interleave_mode_legacy(struct dvb_frontend *fe)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\tu16 reg, reg1, reg2;\n\n\treg = s5h1409_readreg(state, 0xf1);\n\n\t \n\tif ((reg >> 15) & 0x1) {\n\t\tif (state->qam_state != 2) {\n\t\t\tstate->qam_state = 2;\n\t\t\treg1 = s5h1409_readreg(state, 0xb2);\n\t\t\treg2 = s5h1409_readreg(state, 0xad);\n\n\t\t\ts5h1409_writereg(state, 0x96, 0x20);\n\t\t\ts5h1409_writereg(state, 0xad,\n\t\t\t\t(((reg1 & 0xf000) >> 4) | (reg2 & 0xf0ff)));\n\t\t\ts5h1409_writereg(state, 0xab,\n\t\t\t\ts5h1409_readreg(state, 0xab) & 0xeffe);\n\t\t}\n\t} else {\n\t\tif (state->qam_state != 1) {\n\t\t\tstate->qam_state = 1;\n\t\t\ts5h1409_writereg(state, 0x96, 0x08);\n\t\t\ts5h1409_writereg(state, 0xab,\n\t\t\t\ts5h1409_readreg(state, 0xab) | 0x1001);\n\t\t}\n\t}\n}\n\n \nstatic int s5h1409_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(frequency=%d)\\n\", __func__, p->frequency);\n\n\ts5h1409_softreset(fe);\n\n\tstate->current_frequency = p->frequency;\n\n\ts5h1409_enable_modulation(fe, p->modulation);\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t \n\ts5h1409_softreset(fe);\n\n\t \n\tif (state->current_modulation != VSB_8) {\n\t\t \n\t\tif (state->config->hvr1600_opt == S5H1409_HVR1600_OPTIMIZE) {\n\t\t\ts5h1409_set_qam_interleave_mode(fe);\n\t\t\ts5h1409_set_qam_amhum_mode(fe);\n\t\t} else {\n\t\t\ts5h1409_set_qam_amhum_mode_legacy(fe);\n\t\t\ts5h1409_set_qam_interleave_mode_legacy(fe);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int s5h1409_set_mpeg_timing(struct dvb_frontend *fe, int mode)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\tu16 val;\n\n\tdprintk(\"%s(%d)\\n\", __func__, mode);\n\n\tval = s5h1409_readreg(state, 0xac) & 0xcfff;\n\tswitch (mode) {\n\tcase S5H1409_MPEGTIMING_CONTINUOUS_INVERTING_CLOCK:\n\t\tval |= 0x0000;\n\t\tbreak;\n\tcase S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK:\n\t\tdprintk(\"%s(%d) Mode1 or Defaulting\\n\", __func__, mode);\n\t\tval |= 0x1000;\n\t\tbreak;\n\tcase S5H1409_MPEGTIMING_NONCONTINUOUS_INVERTING_CLOCK:\n\t\tval |= 0x2000;\n\t\tbreak;\n\tcase S5H1409_MPEGTIMING_NONCONTINUOUS_NONINVERTING_CLOCK:\n\t\tval |= 0x3000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn s5h1409_writereg(state, 0xac, val);\n}\n\n \nstatic int s5h1409_init(struct dvb_frontend *fe)\n{\n\tint i;\n\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\tdprintk(\"%s()\\n\", __func__);\n\n\ts5h1409_sleep(fe, 0);\n\ts5h1409_register_reset(fe);\n\n\tfor (i = 0; i < ARRAY_SIZE(init_tab); i++)\n\t\ts5h1409_writereg(state, init_tab[i].reg, init_tab[i].data);\n\n\t \n\tstate->current_modulation = VSB_8;\n\n\t \n\tif (state->config->hvr1600_opt == S5H1409_HVR1600_OPTIMIZE) {\n\t\t \n\t\ts5h1409_writereg(state, 0x09, 0x0050);\n\n\t\t \n\t\ts5h1409_writereg(state, 0x21, 0x0001);\n\t\ts5h1409_writereg(state, 0x50, 0x030e);\n\n\t\t \n\t\ts5h1409_writereg(state, 0x82, 0x0800);\n\t}\n\n\tif (state->config->output_mode == S5H1409_SERIAL_OUTPUT)\n\t\ts5h1409_writereg(state, 0xab,\n\t\t\ts5h1409_readreg(state, 0xab) | 0x100);  \n\telse\n\t\ts5h1409_writereg(state, 0xab,\n\t\t\ts5h1409_readreg(state, 0xab) & 0xfeff);  \n\n\ts5h1409_set_spectralinversion(fe, state->config->inversion);\n\ts5h1409_set_if_freq(fe, state->if_freq);\n\ts5h1409_set_gpio(fe, state->config->gpio);\n\ts5h1409_set_mpeg_timing(fe, state->config->mpeg_timing);\n\ts5h1409_softreset(fe);\n\n\t \n\ts5h1409_i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\nstatic int s5h1409_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\tu16 reg;\n\tu32 tuner_status = 0;\n\n\t*status = 0;\n\n\t \n\tif (state->current_modulation != VSB_8) {\n\t\t \n\t\tif (state->config->hvr1600_opt == S5H1409_HVR1600_OPTIMIZE) {\n\t\t\ts5h1409_set_qam_interleave_mode(fe);\n\t\t\ts5h1409_set_qam_amhum_mode(fe);\n\t\t}\n\t}\n\n\t \n\treg = s5h1409_readreg(state, 0xf1);\n\tif (reg & 0x1000)\n\t\t*status |= FE_HAS_VITERBI;\n\tif (reg & 0x8000)\n\t\t*status |= FE_HAS_LOCK | FE_HAS_SYNC;\n\n\tswitch (state->config->status_mode) {\n\tcase S5H1409_DEMODLOCKING:\n\t\tif (*status & FE_HAS_VITERBI)\n\t\t\t*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\n\t\tbreak;\n\tcase S5H1409_TUNERLOCKING:\n\t\t \n\t\tif (fe->ops.tuner_ops.get_status) {\n\t\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\t\tfe->ops.tuner_ops.get_status(fe, &tuner_status);\n\n\t\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t\t}\n\t\tif (tuner_status)\n\t\t\t*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\n\t\tbreak;\n\t}\n\n\tdprintk(\"%s() status 0x%08x\\n\", __func__, *status);\n\n\treturn 0;\n}\n\nstatic int s5h1409_qam256_lookup_snr(struct dvb_frontend *fe, u16 *snr, u16 v)\n{\n\tint i, ret = -EINVAL;\n\tdprintk(\"%s()\\n\", __func__);\n\n\tfor (i = 0; i < ARRAY_SIZE(qam256_snr_tab); i++) {\n\t\tif (v < qam256_snr_tab[i].val) {\n\t\t\t*snr = qam256_snr_tab[i].data;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int s5h1409_qam64_lookup_snr(struct dvb_frontend *fe, u16 *snr, u16 v)\n{\n\tint i, ret = -EINVAL;\n\tdprintk(\"%s()\\n\", __func__);\n\n\tfor (i = 0; i < ARRAY_SIZE(qam64_snr_tab); i++) {\n\t\tif (v < qam64_snr_tab[i].val) {\n\t\t\t*snr = qam64_snr_tab[i].data;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int s5h1409_vsb_lookup_snr(struct dvb_frontend *fe, u16 *snr, u16 v)\n{\n\tint i, ret = -EINVAL;\n\tdprintk(\"%s()\\n\", __func__);\n\n\tfor (i = 0; i < ARRAY_SIZE(vsb_snr_tab); i++) {\n\t\tif (v > vsb_snr_tab[i].val) {\n\t\t\t*snr = vsb_snr_tab[i].data;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdprintk(\"%s() snr=%d\\n\", __func__, *snr);\n\treturn ret;\n}\n\nstatic int s5h1409_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\tu16 reg;\n\tdprintk(\"%s()\\n\", __func__);\n\n\tswitch (state->current_modulation) {\n\tcase QAM_64:\n\t\treg = s5h1409_readreg(state, 0xf0) & 0xff;\n\t\treturn s5h1409_qam64_lookup_snr(fe, snr, reg);\n\tcase QAM_256:\n\t\treg = s5h1409_readreg(state, 0xf0) & 0xff;\n\t\treturn s5h1409_qam256_lookup_snr(fe, snr, reg);\n\tcase VSB_8:\n\t\treg = s5h1409_readreg(state, 0xf1) & 0x3ff;\n\t\treturn s5h1409_vsb_lookup_snr(fe, snr, reg);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int s5h1409_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t\tu16 *signal_strength)\n{\n\t \n\tu16 snr;\n\tu32 tmp;\n\tint ret = s5h1409_read_snr(fe, &snr);\n\n\t*signal_strength = 0;\n\n\tif (0 == ret) {\n\t\t \n\n\t\t \n\t\ttmp = (snr * ((1 << 24) / 10));\n\n\t\t \n\t\tif (tmp >= 8960 * 0x10000)\n\t\t\t*signal_strength = 0xffff;\n\t\telse\n\t\t\t*signal_strength = tmp / 8960;\n\t}\n\n\treturn ret;\n}\n\nstatic int s5h1409_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\n\t*ucblocks = s5h1409_readreg(state, 0xb5);\n\n\treturn 0;\n}\n\nstatic int s5h1409_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\treturn s5h1409_read_ucblocks(fe, ber);\n}\n\nstatic int s5h1409_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\n\tp->frequency = state->current_frequency;\n\tp->modulation = state->current_modulation;\n\n\treturn 0;\n}\n\nstatic int s5h1409_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t     struct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic void s5h1409_release(struct dvb_frontend *fe)\n{\n\tstruct s5h1409_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops s5h1409_ops;\n\nstruct dvb_frontend *s5h1409_attach(const struct s5h1409_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct s5h1409_state *state = NULL;\n\tu16 reg;\n\n\t \n\tstate = kzalloc(sizeof(struct s5h1409_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->current_modulation = 0;\n\tstate->if_freq = S5H1409_VSB_IF_FREQ;\n\n\t \n\treg = s5h1409_readreg(state, 0x04);\n\tif ((reg != 0x0066) && (reg != 0x007f))\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &s5h1409_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\tif (s5h1409_init(&state->frontend) != 0) {\n\t\tprintk(KERN_ERR \"%s: Failed to initialize correctly\\n\",\n\t\t\t__func__);\n\t\tgoto error;\n\t}\n\n\t \n\ts5h1409_i2c_gate_ctrl(&state->frontend, 1);\n\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(s5h1409_attach);\n\nstatic const struct dvb_frontend_ops s5h1409_ops = {\n\t.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },\n\t.info = {\n\t\t.name\t\t\t= \"Samsung S5H1409 QAM/8VSB Frontend\",\n\t\t.frequency_min_hz\t=  54 * MHz,\n\t\t.frequency_max_hz\t= 858 * MHz,\n\t\t.frequency_stepsize_hz\t= 62500,\n\t\t.caps = FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB\n\t},\n\n\t.init                 = s5h1409_init,\n\t.i2c_gate_ctrl        = s5h1409_i2c_gate_ctrl,\n\t.set_frontend         = s5h1409_set_frontend,\n\t.get_frontend         = s5h1409_get_frontend,\n\t.get_tune_settings    = s5h1409_get_tune_settings,\n\t.read_status          = s5h1409_read_status,\n\t.read_ber             = s5h1409_read_ber,\n\t.read_signal_strength = s5h1409_read_signal_strength,\n\t.read_snr             = s5h1409_read_snr,\n\t.read_ucblocks        = s5h1409_read_ucblocks,\n\t.release              = s5h1409_release,\n};\n\nMODULE_DESCRIPTION(\"Samsung S5H1409 QAM-B/ATSC Demodulator driver\");\nMODULE_AUTHOR(\"Steven Toth\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}