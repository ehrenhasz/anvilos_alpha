{
  "module_name": "mxl692.c",
  "hash_id": "1241c7ff65ec9db7d031b1f22ffd6082fbc56a11749cec118463b77ddff9554e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/mxl692.c",
  "human_readable_source": "\n \n\n#include <linux/mutex.h>\n#include <linux/i2c-mux.h>\n#include <linux/string.h>\n#include <linux/firmware.h>\n\n#include \"mxl692.h\"\n#include \"mxl692_defs.h\"\n\nstatic const struct dvb_frontend_ops mxl692_ops;\n\nstruct mxl692_dev {\n\tstruct dvb_frontend fe;\n\tstruct i2c_client *i2c_client;\n\tstruct mutex i2c_lock;\t\t \n\tenum MXL_EAGLE_DEMOD_TYPE_E demod_type;\n\tenum MXL_EAGLE_POWER_MODE_E power_mode;\n\tu32 current_frequency;\n\tint device_type;\n\tint seqnum;\n\tint init_done;\n};\n\nstatic int mxl692_i2c_write(struct mxl692_dev *dev, u8 *buffer, u16 buf_len)\n{\n\tint ret = 0;\n\tstruct i2c_msg msg = {\n\t\t.addr = dev->i2c_client->addr,\n\t\t.flags = 0,\n\t\t.buf = buffer,\n\t\t.len = buf_len\n\t};\n\n\tret = i2c_transfer(dev->i2c_client->adapter, &msg, 1);\n\tif (ret != 1)\n\t\tdev_dbg(&dev->i2c_client->dev, \"i2c write error!\\n\");\n\n\treturn ret;\n}\n\nstatic int mxl692_i2c_read(struct mxl692_dev *dev, u8 *buffer, u16 buf_len)\n{\n\tint ret = 0;\n\tstruct i2c_msg msg = {\n\t\t.addr = dev->i2c_client->addr,\n\t\t.flags = I2C_M_RD,\n\t\t.buf = buffer,\n\t\t.len = buf_len\n\t};\n\n\tret = i2c_transfer(dev->i2c_client->adapter, &msg, 1);\n\tif (ret != 1)\n\t\tdev_dbg(&dev->i2c_client->dev, \"i2c read error!\\n\");\n\n\treturn ret;\n}\n\nstatic int convert_endian(u32 size, u8 *d)\n{\n\tu32 i;\n\n\tfor (i = 0; i < (size & ~3); i += 4) {\n\t\td[i + 0] ^= d[i + 3];\n\t\td[i + 3] ^= d[i + 0];\n\t\td[i + 0] ^= d[i + 3];\n\n\t\td[i + 1] ^= d[i + 2];\n\t\td[i + 2] ^= d[i + 1];\n\t\td[i + 1] ^= d[i + 2];\n\t}\n\n\tswitch (size & 3) {\n\tcase 0:\n\tcase 1:\n\t\t \n\t\tbreak;\n\tcase 2:\n\t\td[i + 0] ^= d[i + 1];\n\t\td[i + 1] ^= d[i + 0];\n\t\td[i + 0] ^= d[i + 1];\n\t\tbreak;\n\n\tcase 3:\n\t\td[i + 0] ^= d[i + 2];\n\t\td[i + 2] ^= d[i + 0];\n\t\td[i + 0] ^= d[i + 2];\n\t\tbreak;\n\t}\n\treturn size;\n}\n\nstatic int convert_endian_n(int n, u32 size, u8 *d)\n{\n\tint i, count = 0;\n\n\tfor (i = 0; i < n; i += size)\n\t\tcount += convert_endian(size, d + i);\n\treturn count;\n}\n\nstatic void mxl692_tx_swap(enum MXL_EAGLE_OPCODE_E opcode, u8 *buffer)\n{\n#ifdef __BIG_ENDIAN\n\treturn;\n#endif\n\tbuffer += MXL_EAGLE_HOST_MSG_HEADER_SIZE;  \n\n\tswitch (opcode) {\n\tcase MXL_EAGLE_OPCODE_DEVICE_INTR_MASK_SET:\n\tcase MXL_EAGLE_OPCODE_TUNER_CHANNEL_TUNE_SET:\n\tcase MXL_EAGLE_OPCODE_SMA_TRANSMIT_SET:\n\t\tbuffer += convert_endian(sizeof(u32), buffer);\n\t\tbreak;\n\tcase MXL_EAGLE_OPCODE_QAM_PARAMS_SET:\n\t\tbuffer += 5;\n\t\tbuffer += convert_endian(2 * sizeof(u32), buffer);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic void mxl692_rx_swap(enum MXL_EAGLE_OPCODE_E opcode, u8 *buffer)\n{\n#ifdef __BIG_ENDIAN\n\treturn;\n#endif\n\tbuffer += MXL_EAGLE_HOST_MSG_HEADER_SIZE;  \n\n\tswitch (opcode) {\n\tcase MXL_EAGLE_OPCODE_TUNER_AGC_STATUS_GET:\n\t\tbuffer++;\n\t\tbuffer += convert_endian(2 * sizeof(u16), buffer);\n\t\tbreak;\n\tcase MXL_EAGLE_OPCODE_ATSC_STATUS_GET:\n\t\tbuffer += convert_endian_n(2, sizeof(u16), buffer);\n\t\tbuffer += convert_endian(sizeof(u32), buffer);\n\t\tbreak;\n\tcase MXL_EAGLE_OPCODE_ATSC_ERROR_COUNTERS_GET:\n\t\tbuffer += convert_endian(3 * sizeof(u32), buffer);\n\t\tbreak;\n\tcase MXL_EAGLE_OPCODE_ATSC_EQUALIZER_FILTER_FFE_TAPS_GET:\n\t\tbuffer += convert_endian_n(24, sizeof(u16), buffer);\n\t\tbreak;\n\tcase MXL_EAGLE_OPCODE_QAM_STATUS_GET:\n\t\tbuffer += 8;\n\t\tbuffer += convert_endian_n(2, sizeof(u16), buffer);\n\t\tbuffer += convert_endian(sizeof(u32), buffer);\n\t\tbreak;\n\tcase MXL_EAGLE_OPCODE_QAM_ERROR_COUNTERS_GET:\n\t\tbuffer += convert_endian(7 * sizeof(u32), buffer);\n\t\tbreak;\n\tcase MXL_EAGLE_OPCODE_QAM_CONSTELLATION_VALUE_GET:\n\tcase MXL_EAGLE_OPCODE_QAM_EQUALIZER_FILTER_DFE_START_GET:\n\tcase MXL_EAGLE_OPCODE_QAM_EQUALIZER_FILTER_DFE_MIDDLE_GET:\n\tcase MXL_EAGLE_OPCODE_QAM_EQUALIZER_FILTER_DFE_END_GET:\n\tcase MXL_EAGLE_OPCODE_QAM_EQUALIZER_FILTER_SPUR_START_GET:\n\t\tbuffer += convert_endian_n(24, sizeof(u16), buffer);\n\t\tbreak;\n\tcase MXL_EAGLE_OPCODE_QAM_EQUALIZER_FILTER_SPUR_END_GET:\n\t\tbuffer += convert_endian_n(8, sizeof(u16), buffer);\n\t\tbreak;\n\tcase MXL_EAGLE_OPCODE_QAM_EQUALIZER_FILTER_FFE_GET:\n\t\tbuffer += convert_endian_n(17, sizeof(u16), buffer);\n\t\tbreak;\n\tcase MXL_EAGLE_OPCODE_OOB_ERROR_COUNTERS_GET:\n\t\tbuffer += convert_endian(3 * sizeof(u32), buffer);\n\t\tbreak;\n\tcase MXL_EAGLE_OPCODE_OOB_STATUS_GET:\n\t\tbuffer += convert_endian_n(2, sizeof(u16), buffer);\n\t\tbuffer += convert_endian(sizeof(u32), buffer);\n\t\tbreak;\n\tcase MXL_EAGLE_OPCODE_SMA_RECEIVE_GET:\n\t\tbuffer += convert_endian(sizeof(u32), buffer);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic u32 mxl692_checksum(u8 *buffer, u32 size)\n{\n\tu32 ix, div_size;\n\tu32 cur_cksum = 0;\n\t__be32 *buf;\n\n\tdiv_size = DIV_ROUND_UP(size, 4);\n\n\tbuf = (__be32 *)buffer;\n\tfor (ix = 0; ix < div_size; ix++)\n\t\tcur_cksum += be32_to_cpu(buf[ix]);\n\n\tcur_cksum ^= 0xDEADBEEF;\n\n\treturn cur_cksum;\n}\n\nstatic int mxl692_validate_fw_header(struct mxl692_dev *dev,\n\t\t\t\t     const u8 *buffer, u32 buf_len)\n{\n\tint status = 0;\n\tu32 ix, temp;\n\t__be32 *local_buf = NULL;\n\tu8 temp_cksum = 0;\n\tstatic const u8 fw_hdr[] = {\n\t\t0x4D, 0x31, 0x10, 0x02, 0x40, 0x00, 0x00, 0x80\n\t};\n\n\tif (memcmp(buffer, fw_hdr, 8) != 0) {\n\t\tstatus = -EINVAL;\n\t\tgoto err_finish;\n\t}\n\n\tlocal_buf = (__be32 *)(buffer + 8);\n\ttemp = be32_to_cpu(*local_buf);\n\n\tif ((buf_len - 16) != temp >> 8) {\n\t\tstatus = -EINVAL;\n\t\tgoto err_finish;\n\t}\n\n\tfor (ix = 16; ix < buf_len; ix++)\n\t\ttemp_cksum += buffer[ix];\n\n\tif (temp_cksum != buffer[11])\n\t\tstatus = -EINVAL;\n\nerr_finish:\n\tif (status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"failed\\n\");\n\treturn status;\n}\n\nstatic int mxl692_write_fw_block(struct mxl692_dev *dev, const u8 *buffer,\n\t\t\t\t u32 buf_len, u32 *index)\n{\n\tint status = 0;\n\tu32 ix = 0, total_len = 0, addr = 0, chunk_len = 0, prevchunk_len = 0;\n\tu8 local_buf[MXL_EAGLE_MAX_I2C_PACKET_SIZE] = {}, *plocal_buf = NULL;\n\tint payload_max = MXL_EAGLE_MAX_I2C_PACKET_SIZE - MXL_EAGLE_I2C_MHEADER_SIZE;\n\n\tix = *index;\n\n\tif (buffer[ix] == 0x53) {\n\t\ttotal_len = buffer[ix + 1] << 16 | buffer[ix + 2] << 8 | buffer[ix + 3];\n\t\ttotal_len = (total_len + 3) & ~3;\n\t\taddr      = buffer[ix + 4] << 24 | buffer[ix + 5] << 16 |\n\t\t\t    buffer[ix + 6] << 8 | buffer[ix + 7];\n\t\tix       += MXL_EAGLE_FW_SEGMENT_HEADER_SIZE;\n\n\t\twhile ((total_len > 0) && (status == 0)) {\n\t\t\tplocal_buf = local_buf;\n\t\t\tchunk_len  = (total_len < payload_max) ? total_len : payload_max;\n\n\t\t\t*plocal_buf++ = 0xFC;\n\t\t\t*plocal_buf++ = chunk_len + sizeof(u32);\n\n\t\t\t*(u32 *)plocal_buf = addr + prevchunk_len;\n#ifdef __BIG_ENDIAN\n\t\t\tconvert_endian(sizeof(u32), plocal_buf);\n#endif\n\t\t\tplocal_buf += sizeof(u32);\n\n\t\t\tmemcpy(plocal_buf, &buffer[ix], chunk_len);\n\t\t\tconvert_endian(chunk_len, plocal_buf);\n\t\t\tif (mxl692_i2c_write(dev, local_buf,\n\t\t\t\t\t     (chunk_len + MXL_EAGLE_I2C_MHEADER_SIZE)) < 0) {\n\t\t\t\tstatus = -EREMOTEIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprevchunk_len += chunk_len;\n\t\t\ttotal_len -= chunk_len;\n\t\t\tix += chunk_len;\n\t\t}\n\t\t*index = ix;\n\t} else {\n\t\tstatus = -EINVAL;\n\t}\n\n\tif (status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", status);\n\n\treturn status;\n}\n\nstatic int mxl692_memwrite(struct mxl692_dev *dev, u32 addr,\n\t\t\t   u8 *buffer, u32 size)\n{\n\tint status = 0, total_len = 0;\n\tu8 local_buf[MXL_EAGLE_MAX_I2C_PACKET_SIZE] = {}, *plocal_buf = NULL;\n\n\ttotal_len = size;\n\ttotal_len = (total_len + 3) & ~3;   \n\n\tif (total_len > (MXL_EAGLE_MAX_I2C_PACKET_SIZE - MXL_EAGLE_I2C_MHEADER_SIZE))\n\t\tdev_dbg(&dev->i2c_client->dev, \"hrmph?\\n\");\n\n\tplocal_buf = local_buf;\n\n\t*plocal_buf++ = 0xFC;\n\t*plocal_buf++ = total_len + sizeof(u32);\n\n\t*(u32 *)plocal_buf = addr;\n\tplocal_buf += sizeof(u32);\n\n\tmemcpy(plocal_buf, buffer, total_len);\n#ifdef __BIG_ENDIAN\n\tconvert_endian(sizeof(u32) + total_len, local_buf + 2);\n#endif\n\tif (mxl692_i2c_write(dev, local_buf,\n\t\t\t     (total_len + MXL_EAGLE_I2C_MHEADER_SIZE)) < 0) {\n\t\tstatus = -EREMOTEIO;\n\t\tgoto err_finish;\n\t}\n\n\treturn status;\nerr_finish:\n\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", status);\n\treturn status;\n}\n\nstatic int mxl692_memread(struct mxl692_dev *dev, u32 addr,\n\t\t\t  u8 *buffer, u32 size)\n{\n\tint status = 0;\n\tu8 local_buf[MXL_EAGLE_I2C_MHEADER_SIZE] = {}, *plocal_buf = NULL;\n\n\tplocal_buf = local_buf;\n\n\t*plocal_buf++ = 0xFB;\n\t*plocal_buf++ = sizeof(u32);\n\t*(u32 *)plocal_buf = addr;\n#ifdef __BIG_ENDIAN\n\tconvert_endian(sizeof(u32), plocal_buf);\n#endif\n\tmutex_lock(&dev->i2c_lock);\n\n\tif (mxl692_i2c_write(dev, local_buf, MXL_EAGLE_I2C_MHEADER_SIZE) > 0) {\n\t\tsize = (size + 3) & ~3;   \n\t\tstatus = mxl692_i2c_read(dev, buffer, (u16)size) < 0 ? -EREMOTEIO : 0;\n#ifdef __BIG_ENDIAN\n\t\tif (status == 0)\n\t\t\tconvert_endian(size, buffer);\n#endif\n\t} else {\n\t\tstatus = -EREMOTEIO;\n\t}\n\n\tmutex_unlock(&dev->i2c_lock);\n\n\tif (status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", status);\n\n\treturn status;\n}\n\nstatic const char *mxl692_opcode_string(u8 opcode)\n{\n\tif (opcode <= MXL_EAGLE_OPCODE_INTERNAL)\n\t\treturn MXL_EAGLE_OPCODE_STRING[opcode];\n\n\treturn \"invalid opcode\";\n}\n\nstatic int mxl692_opwrite(struct mxl692_dev *dev, u8 *buffer,\n\t\t\t  u32 size)\n{\n\tint status = 0, total_len = 0;\n\tu8 local_buf[MXL_EAGLE_MAX_I2C_PACKET_SIZE] = {}, *plocal_buf = NULL;\n\tstruct MXL_EAGLE_HOST_MSG_HEADER_T *tx_hdr = (struct MXL_EAGLE_HOST_MSG_HEADER_T *)buffer;\n\n\ttotal_len = size;\n\ttotal_len = (total_len + 3) & ~3;   \n\n\tif (total_len > (MXL_EAGLE_MAX_I2C_PACKET_SIZE - MXL_EAGLE_I2C_PHEADER_SIZE))\n\t\tdev_dbg(&dev->i2c_client->dev, \"hrmph?\\n\");\n\n\tplocal_buf = local_buf;\n\n\t*plocal_buf++ = 0xFE;\n\t*plocal_buf++ = (u8)total_len;\n\n\tmemcpy(plocal_buf, buffer, total_len);\n\tconvert_endian(total_len, plocal_buf);\n\n\tif (mxl692_i2c_write(dev, local_buf,\n\t\t\t     (total_len + MXL_EAGLE_I2C_PHEADER_SIZE)) < 0) {\n\t\tstatus = -EREMOTEIO;\n\t\tgoto err_finish;\n\t}\nerr_finish:\n\tif (status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"opcode %s  err %d\\n\",\n\t\t\tmxl692_opcode_string(tx_hdr->opcode), status);\n\treturn status;\n}\n\nstatic int mxl692_opread(struct mxl692_dev *dev, u8 *buffer,\n\t\t\t u32 size)\n{\n\tint status = 0;\n\tu32 ix = 0;\n\tu8 local_buf[MXL_EAGLE_I2C_PHEADER_SIZE] = {};\n\n\tlocal_buf[0] = 0xFD;\n\tlocal_buf[1] = 0;\n\n\tif (mxl692_i2c_write(dev, local_buf, MXL_EAGLE_I2C_PHEADER_SIZE) > 0) {\n\t\tsize = (size + 3) & ~3;   \n\n\t\t \n\t\tfor (ix = 0; ix < size; ix += 4) {\n\t\t\tif (mxl692_i2c_read(dev, buffer + ix, 4) < 0) {\n\t\t\t\tdev_dbg(&dev->i2c_client->dev, \"ix=%d   size=%d\\n\", ix, size);\n\t\t\t\tstatus = -EREMOTEIO;\n\t\t\t\tgoto err_finish;\n\t\t\t}\n\t\t}\n\t\tconvert_endian(size, buffer);\n\t} else {\n\t\tstatus = -EREMOTEIO;\n\t}\nerr_finish:\n\tif (status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", status);\n\treturn status;\n}\n\nstatic int mxl692_i2c_writeread(struct mxl692_dev *dev,\n\t\t\t\tu8 opcode,\n\t\t\t\tu8 *tx_payload,\n\t\t\t\tu8 tx_payload_size,\n\t\t\t\tu8 *rx_payload,\n\t\t\t\tu8 rx_payload_expected)\n{\n\tint status = 0, timeout = 40;\n\tu8 tx_buf[MXL_EAGLE_MAX_I2C_PACKET_SIZE] = {};\n\tu8 rx_buf[MXL_EAGLE_MAX_I2C_PACKET_SIZE] = {};\n\tu32 resp_checksum = 0, resp_checksum_tmp = 0;\n\tstruct MXL_EAGLE_HOST_MSG_HEADER_T *tx_header;\n\tstruct MXL_EAGLE_HOST_MSG_HEADER_T *rx_header;\n\n\tmutex_lock(&dev->i2c_lock);\n\n\tif ((tx_payload_size + MXL_EAGLE_HOST_MSG_HEADER_SIZE) >\n\t    (MXL_EAGLE_MAX_I2C_PACKET_SIZE - MXL_EAGLE_I2C_PHEADER_SIZE)) {\n\t\tstatus = -EINVAL;\n\t\tgoto err_finish;\n\t}\n\n\ttx_header = (struct MXL_EAGLE_HOST_MSG_HEADER_T *)tx_buf;\n\ttx_header->opcode = opcode;\n\ttx_header->seqnum = dev->seqnum++;\n\ttx_header->payload_size = tx_payload_size;\n\ttx_header->checksum = 0;\n\n\tif (dev->seqnum == 0)\n\t\tdev->seqnum = 1;\n\n\tif (tx_payload && tx_payload_size > 0)\n\t\tmemcpy(&tx_buf[MXL_EAGLE_HOST_MSG_HEADER_SIZE], tx_payload, tx_payload_size);\n\n\tmxl692_tx_swap(opcode, tx_buf);\n\n\ttx_header->checksum = 0;\n\ttx_header->checksum = mxl692_checksum(tx_buf,\n\t\t\t\t\t      MXL_EAGLE_HOST_MSG_HEADER_SIZE + tx_payload_size);\n#ifdef __LITTLE_ENDIAN\n\tconvert_endian(4, (u8 *)&tx_header->checksum);  \n#endif\n\t \n\tstatus = mxl692_opwrite(dev, tx_buf,\n\t\t\t\ttx_payload_size + MXL_EAGLE_HOST_MSG_HEADER_SIZE);\n\tif (status) {\n\t\tstatus = -EREMOTEIO;\n\t\tgoto err_finish;\n\t}\n\n\t \n\trx_header = (struct MXL_EAGLE_HOST_MSG_HEADER_T *)rx_buf;\n\n\tdo {\n\t\tstatus = mxl692_opread(dev, rx_buf,\n\t\t\t\t       rx_payload_expected + MXL_EAGLE_HOST_MSG_HEADER_SIZE);\n\t\tusleep_range(1000, 2000);\n\t\ttimeout--;\n\t} while ((timeout > 0) && (status == 0) &&\n\t\t (rx_header->seqnum == 0) &&\n\t\t (rx_header->checksum == 0));\n\n\tif (timeout == 0 || status) {\n\t\tdev_dbg(&dev->i2c_client->dev, \"timeout=%d   status=%d\\n\",\n\t\t\ttimeout, status);\n\t\tstatus = -ETIMEDOUT;\n\t\tgoto err_finish;\n\t}\n\n\tif (rx_header->status) {\n\t\tdev_dbg(&dev->i2c_client->dev, \"rx header status code: %d\\n\", rx_header->status);\n\t\tstatus = -EREMOTEIO;\n\t\tgoto err_finish;\n\t}\n\n\tif (rx_header->seqnum != tx_header->seqnum ||\n\t    rx_header->opcode != tx_header->opcode ||\n\t    rx_header->payload_size != rx_payload_expected) {\n\t\tdev_dbg(&dev->i2c_client->dev, \"Something failed seq=%s  opcode=%s  pSize=%s\\n\",\n\t\t\trx_header->seqnum != tx_header->seqnum ? \"X\" : \"0\",\n\t\t\trx_header->opcode != tx_header->opcode ? \"X\" : \"0\",\n\t\t\trx_header->payload_size != rx_payload_expected ? \"X\" : \"0\");\n\t\tif (rx_header->payload_size != rx_payload_expected)\n\t\t\tdev_dbg(&dev->i2c_client->dev,\n\t\t\t\t\"rx_header->payloadSize=%d   rx_payload_expected=%d\\n\",\n\t\t\t\trx_header->payload_size, rx_payload_expected);\n\t\tstatus = -EREMOTEIO;\n\t\tgoto err_finish;\n\t}\n\n\tresp_checksum = rx_header->checksum;\n\trx_header->checksum = 0;\n\n\tresp_checksum_tmp = mxl692_checksum(rx_buf,\n\t\t\t\t\t    MXL_EAGLE_HOST_MSG_HEADER_SIZE + rx_header->payload_size);\n#ifdef __LITTLE_ENDIAN\n\tconvert_endian(4, (u8 *)&resp_checksum_tmp);  \n#endif\n\tif (resp_checksum != resp_checksum_tmp) {\n\t\tdev_dbg(&dev->i2c_client->dev, \"rx checksum failure\\n\");\n\t\tstatus = -EREMOTEIO;\n\t\tgoto err_finish;\n\t}\n\n\tmxl692_rx_swap(rx_header->opcode, rx_buf);\n\n\tif (rx_header->payload_size > 0) {\n\t\tif (!rx_payload) {\n\t\t\tdev_dbg(&dev->i2c_client->dev, \"no rx payload?!?\\n\");\n\t\t\tstatus = -EREMOTEIO;\n\t\t\tgoto err_finish;\n\t\t}\n\t\tmemcpy(rx_payload, rx_buf + MXL_EAGLE_HOST_MSG_HEADER_SIZE,\n\t\t       rx_header->payload_size);\n\t}\nerr_finish:\n\tif (status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", status);\n\n\tmutex_unlock(&dev->i2c_lock);\n\treturn status;\n}\n\nstatic int mxl692_fwdownload(struct mxl692_dev *dev,\n\t\t\t     const u8 *firmware_buf, u32 buf_len)\n{\n\tint status = 0;\n\tu32 ix, reg_val = 0x1;\n\tu8 rx_buf[MXL_EAGLE_MAX_I2C_PACKET_SIZE] = {};\n\tstruct MXL_EAGLE_DEV_STATUS_T *dev_status;\n\n\tif (buf_len < MXL_EAGLE_FW_HEADER_SIZE ||\n\t    buf_len > MXL_EAGLE_FW_MAX_SIZE_IN_KB * 1000)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->i2c_lock);\n\n\tdev_dbg(&dev->i2c_client->dev, \"\\n\");\n\n\tstatus = mxl692_validate_fw_header(dev, firmware_buf, buf_len);\n\tif (status)\n\t\tgoto err_finish;\n\n\tix = 16;\n\tstatus = mxl692_write_fw_block(dev, firmware_buf, buf_len, &ix);  \n\tif (status)\n\t\tgoto err_finish;\n\n\tstatus = mxl692_write_fw_block(dev, firmware_buf, buf_len, &ix);  \n\tif (status)\n\t\tgoto err_finish;\n\n\t \n\tstatus = mxl692_memwrite(dev, 0x70000018, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\tmutex_unlock(&dev->i2c_lock);\n\n\tif (status == 0) {\n\t\t \n\t\tusleep_range(MXL_EAGLE_FW_LOAD_TIME * 1000, (MXL_EAGLE_FW_LOAD_TIME + 5) * 1000);\n\t\tdev_status = (struct MXL_EAGLE_DEV_STATUS_T *)&rx_buf;\n\t\tstatus = mxl692_i2c_writeread(dev,\n\t\t\t\t\t      MXL_EAGLE_OPCODE_DEVICE_STATUS_GET,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      0,\n\t\t\t\t\t      (u8 *)dev_status,\n\t\t\t\t\t      sizeof(struct MXL_EAGLE_DEV_STATUS_T));\n\t}\n\n\treturn status;\nerr_finish:\n\tmutex_unlock(&dev->i2c_lock);\n\tif (status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", status);\n\treturn status;\n}\n\nstatic int mxl692_get_versions(struct mxl692_dev *dev)\n{\n\tint status = 0;\n\tstruct MXL_EAGLE_DEV_VER_T dev_ver = {};\n\tstatic const char * const chip_id[] = {\"N/A\", \"691\", \"248\", \"692\"};\n\n\tstatus = mxl692_i2c_writeread(dev, MXL_EAGLE_OPCODE_DEVICE_VERSION_GET,\n\t\t\t\t      NULL,\n\t\t\t\t      0,\n\t\t\t\t      (u8 *)&dev_ver,\n\t\t\t\t      sizeof(struct MXL_EAGLE_DEV_VER_T));\n\tif (status)\n\t\treturn status;\n\n\tdev_info(&dev->i2c_client->dev, \"MxL692_DEMOD Chip ID: %s\\n\",\n\t\t chip_id[dev_ver.chip_id]);\n\n\tdev_info(&dev->i2c_client->dev,\n\t\t \"MxL692_DEMOD FW Version: %d.%d.%d.%d_RC%d\\n\",\n\t\t dev_ver.firmware_ver[0],\n\t\t dev_ver.firmware_ver[1],\n\t\t dev_ver.firmware_ver[2],\n\t\t dev_ver.firmware_ver[3],\n\t\t dev_ver.firmware_ver[4]);\n\n\treturn status;\n}\n\nstatic int mxl692_reset(struct mxl692_dev *dev)\n{\n\tint status = 0;\n\tu32 dev_type = MXL_EAGLE_DEVICE_MAX, reg_val = 0x2;\n\n\tdev_dbg(&dev->i2c_client->dev, \"\\n\");\n\n\t \n\tstatus = mxl692_memwrite(dev, 0x80000100, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\t \n\tstatus = mxl692_memread(dev, 0x70000188, (u8 *)&dev_type, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\tif (dev_type != dev->device_type)\n\t\tgoto err_finish;\n\nerr_finish:\n\tif (status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", status);\n\treturn status;\n}\n\nstatic int mxl692_config_regulators(struct mxl692_dev *dev,\n\t\t\t\t    enum MXL_EAGLE_POWER_SUPPLY_SOURCE_E power_supply)\n{\n\tint status = 0;\n\tu32 reg_val;\n\n\tdev_dbg(&dev->i2c_client->dev, \"\\n\");\n\n\t \n\tstatus = mxl692_memread(dev, 0x90000000, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\treg_val &= 0x00FFFFFF;\n\treg_val |= (power_supply == MXL_EAGLE_POWER_SUPPLY_SOURCE_SINGLE) ?\n\t\t\t\t\t0x14000000 : 0x10000000;\n\n\tstatus = mxl692_memwrite(dev, 0x90000000, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\t \n\tstatus = mxl692_memread(dev, 0x90000018, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\treg_val |= 0x800;\n\n\tstatus = mxl692_memwrite(dev, 0x90000018, (u8 *)&reg_val, sizeof(u32));\n\nerr_finish:\n\tif (status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", status);\n\treturn status;\n}\n\nstatic int mxl692_config_xtal(struct mxl692_dev *dev,\n\t\t\t      struct MXL_EAGLE_DEV_XTAL_T *dev_xtal)\n{\n\tint status = 0;\n\tu32 reg_val, reg_val1;\n\n\tdev_dbg(&dev->i2c_client->dev, \"\\n\");\n\n\tstatus = mxl692_memread(dev, 0x90000000, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\t \n\treg_val &= 0xFFFFFFE0;\n\treg_val |= dev_xtal->xtal_cap;\n\n\t \n\treg_val = dev_xtal->clk_out_enable ? (reg_val | 0x0100) : (reg_val & 0xFFFFFEFF);\n\n\tstatus = mxl692_memwrite(dev, 0x90000000, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\t \n\treg_val = dev_xtal->clk_out_div_enable ? (reg_val | 0x0200) : (reg_val & 0xFFFFFDFF);\n\n\tstatus = mxl692_memwrite(dev, 0x90000000, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\t \n\treg_val = dev_xtal->xtal_sharing_enable ? (reg_val | 0x010400) : (reg_val & 0xFFFEFBFF);\n\n\tstatus = mxl692_memwrite(dev, 0x90000000, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\t \n\tstatus = mxl692_memread(dev, 0x90000030, (u8 *)&reg_val1, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\tif (dev_xtal->xtal_calibration_enable) {\n\t\t \n\t\treg_val1 &= 0xFFFFFFFD;\n\t\treg_val1 |= 0x30;\n\n\t\tstatus = mxl692_memwrite(dev, 0x90000030, (u8 *)&reg_val1, sizeof(u32));\n\t\tif (status)\n\t\t\tgoto err_finish;\n\t} else {\n\t\t \n\t\treg_val1 |= 0x2;\n\n\t\tstatus = mxl692_memwrite(dev, 0x90000030, (u8 *)&reg_val1, sizeof(u32));\n\t\tif (status)\n\t\t\tgoto err_finish;\n\n\t\t \n\t\tstatus = mxl692_memread(dev, 0x9000002c, (u8 *)&reg_val, sizeof(u32));\n\t\tif (status)\n\t\t\tgoto err_finish;\n\n\t\treg_val &= 0xC0FFFFFF;\n\t\treg_val |= 0xA000000;\n\n\t\tstatus = mxl692_memwrite(dev, 0x9000002c, (u8 *)&reg_val, sizeof(u32));\n\t\tif (status)\n\t\t\tgoto err_finish;\n\t}\n\n\t \n\tstatus = mxl692_memread(dev, 0x70000010, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\treg_val |= 0x8;\n\n\tstatus = mxl692_memwrite(dev, 0x70000010, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\tstatus = mxl692_memread(dev, 0x70000018, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\treg_val |= 0x10;\n\n\tstatus = mxl692_memwrite(dev, 0x70000018, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\tstatus = mxl692_memread(dev, 0x9001014c, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\treg_val &= 0xFFFFEFFF;\n\n\tstatus = mxl692_memwrite(dev, 0x9001014c, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\treg_val |= 0x1000;\n\n\tstatus = mxl692_memwrite(dev, 0x9001014c, (u8 *)&reg_val, sizeof(u32));\n\tif (status)\n\t\tgoto err_finish;\n\n\tusleep_range(45000, 55000);\n\nerr_finish:\n\tif (status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", status);\n\treturn status;\n}\n\nstatic int mxl692_powermode(struct mxl692_dev *dev,\n\t\t\t    enum MXL_EAGLE_POWER_MODE_E power_mode)\n{\n\tint status = 0;\n\tu8 mode = power_mode;\n\n\tdev_dbg(&dev->i2c_client->dev, \"%s\\n\",\n\t\tpower_mode == MXL_EAGLE_POWER_MODE_SLEEP ? \"sleep\" : \"active\");\n\n\tstatus = mxl692_i2c_writeread(dev,\n\t\t\t\t      MXL_EAGLE_OPCODE_DEVICE_POWERMODE_SET,\n\t\t\t\t      &mode,\n\t\t\t\t      sizeof(u8),\n\t\t\t\t      NULL,\n\t\t\t\t      0);\n\tif (status) {\n\t\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tdev->power_mode = power_mode;\n\n\treturn status;\n}\n\nstatic int mxl692_init(struct dvb_frontend *fe)\n{\n\tstruct mxl692_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->i2c_client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint status = 0;\n\tconst struct firmware *firmware;\n\tstruct MXL_EAGLE_DEV_XTAL_T xtal_config = {};\n\n\tdev_dbg(&dev->i2c_client->dev, \"\\n\");\n\n\tif (dev->init_done)\n\t\tgoto warm;\n\n\tdev->seqnum = 1;\n\n\tstatus = mxl692_reset(dev);\n\tif (status)\n\t\tgoto err;\n\n\tusleep_range(50 * 1000, 60 * 1000);  \n\n\tstatus = mxl692_config_regulators(dev, MXL_EAGLE_POWER_SUPPLY_SOURCE_DUAL);\n\tif (status)\n\t\tgoto err;\n\n\txtal_config.xtal_cap = 26;\n\txtal_config.clk_out_div_enable = 0;\n\txtal_config.clk_out_enable = 0;\n\txtal_config.xtal_calibration_enable = 0;\n\txtal_config.xtal_sharing_enable = 1;\n\tstatus = mxl692_config_xtal(dev, &xtal_config);\n\tif (status)\n\t\tgoto err;\n\n\tstatus = request_firmware(&firmware, MXL692_FIRMWARE, &client->dev);\n\tif (status) {\n\t\tdev_dbg(&dev->i2c_client->dev, \"firmware missing? %s\\n\",\n\t\t\tMXL692_FIRMWARE);\n\t\tgoto err;\n\t}\n\n\tstatus = mxl692_fwdownload(dev, firmware->data, firmware->size);\n\tif (status)\n\t\tgoto err_release_firmware;\n\n\trelease_firmware(firmware);\n\n\tstatus = mxl692_get_versions(dev);\n\tif (status)\n\t\tgoto err;\n\n\tdev->power_mode = MXL_EAGLE_POWER_MODE_SLEEP;\nwarm:\n\t \n\tif (dev->power_mode != MXL_EAGLE_POWER_MODE_ACTIVE) {\n\t\tstatus = mxl692_powermode(dev, MXL_EAGLE_POWER_MODE_ACTIVE);\n\t\tif (status)\n\t\t\tgoto err;\n\n\t\tusleep_range(50 * 1000, 60 * 1000);  \n\t}\n\n\t \n\tc->cnr.len = 1;\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.len = 1;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_error.len = 1;\n\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tdev->init_done = 1;\n\treturn 0;\nerr_release_firmware:\n\trelease_firmware(firmware);\nerr:\n\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", status);\n\treturn status;\n}\n\nstatic int mxl692_sleep(struct dvb_frontend *fe)\n{\n\tstruct mxl692_dev *dev = fe->demodulator_priv;\n\n\tif (dev->power_mode != MXL_EAGLE_POWER_MODE_SLEEP)\n\t\tmxl692_powermode(dev, MXL_EAGLE_POWER_MODE_SLEEP);\n\n\treturn 0;\n}\n\nstatic int mxl692_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct mxl692_dev *dev = fe->demodulator_priv;\n\n\tint status = 0;\n\tenum MXL_EAGLE_DEMOD_TYPE_E demod_type;\n\tstruct MXL_EAGLE_MPEGOUT_PARAMS_T mpeg_params = {};\n\tenum MXL_EAGLE_QAM_DEMOD_ANNEX_TYPE_E qam_annex = MXL_EAGLE_QAM_DEMOD_ANNEX_B;\n\tstruct MXL_EAGLE_QAM_DEMOD_PARAMS_T qam_params = {};\n\tstruct MXL_EAGLE_TUNER_CHANNEL_PARAMS_T tuner_params = {};\n\tu8 op_param = 0;\n\n\tdev_dbg(&dev->i2c_client->dev, \"\\n\");\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tdemod_type = MXL_EAGLE_DEMOD_TYPE_ATSC;\n\t\tbreak;\n\tcase QAM_AUTO:\n\tcase QAM_64:\n\tcase QAM_128:\n\tcase QAM_256:\n\t\tdemod_type = MXL_EAGLE_DEMOD_TYPE_QAM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->current_frequency == p->frequency && dev->demod_type == demod_type) {\n\t\tdev_dbg(&dev->i2c_client->dev, \"already set up\\n\");\n\t\treturn 0;\n\t}\n\n\tdev->current_frequency = -1;\n\tdev->demod_type = -1;\n\n\top_param = demod_type;\n\tstatus = mxl692_i2c_writeread(dev,\n\t\t\t\t      MXL_EAGLE_OPCODE_DEVICE_DEMODULATOR_TYPE_SET,\n\t\t\t\t      &op_param,\n\t\t\t\t      sizeof(u8),\n\t\t\t\t      NULL,\n\t\t\t\t      0);\n\tif (status) {\n\t\tdev_dbg(&dev->i2c_client->dev,\n\t\t\t\"DEVICE_DEMODULATOR_TYPE_SET...FAIL  err 0x%x\\n\", status);\n\t\tgoto err;\n\t}\n\n\tusleep_range(20 * 1000, 30 * 1000);  \n\n\tmpeg_params.mpeg_parallel = 0;\n\tmpeg_params.msb_first = MXL_EAGLE_DATA_SERIAL_MSB_1ST;\n\tmpeg_params.mpeg_sync_pulse_width = MXL_EAGLE_DATA_SYNC_WIDTH_BIT;\n\tmpeg_params.mpeg_valid_pol = MXL_EAGLE_CLOCK_POSITIVE;\n\tmpeg_params.mpeg_sync_pol = MXL_EAGLE_CLOCK_POSITIVE;\n\tmpeg_params.mpeg_clk_pol = MXL_EAGLE_CLOCK_NEGATIVE;\n\tmpeg_params.mpeg3wire_mode_enable = 0;\n\tmpeg_params.mpeg_clk_freq = MXL_EAGLE_MPEG_CLOCK_27MHZ;\n\n\tswitch (demod_type) {\n\tcase MXL_EAGLE_DEMOD_TYPE_ATSC:\n\t\tstatus = mxl692_i2c_writeread(dev,\n\t\t\t\t\t      MXL_EAGLE_OPCODE_DEVICE_MPEG_OUT_PARAMS_SET,\n\t\t\t\t\t      (u8 *)&mpeg_params,\n\t\t\t\t\t      sizeof(struct MXL_EAGLE_MPEGOUT_PARAMS_T),\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      0);\n\t\tif (status)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase MXL_EAGLE_DEMOD_TYPE_QAM:\n\t\tif (qam_annex == MXL_EAGLE_QAM_DEMOD_ANNEX_A)\n\t\t\tmpeg_params.msb_first = MXL_EAGLE_DATA_SERIAL_LSB_1ST;\n\t\tstatus = mxl692_i2c_writeread(dev,\n\t\t\t\t\t      MXL_EAGLE_OPCODE_DEVICE_MPEG_OUT_PARAMS_SET,\n\t\t\t\t\t      (u8 *)&mpeg_params,\n\t\t\t\t\t      sizeof(struct MXL_EAGLE_MPEGOUT_PARAMS_T),\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      0);\n\t\tif (status)\n\t\t\tgoto err;\n\n\t\tqam_params.annex_type = qam_annex;\n\t\tqam_params.qam_type = MXL_EAGLE_QAM_DEMOD_AUTO;\n\t\tqam_params.iq_flip = MXL_EAGLE_DEMOD_IQ_AUTO;\n\t\tif (p->modulation == QAM_64)\n\t\t\tqam_params.symbol_rate_hz = 5057000;\n\t\telse\n\t\t\tqam_params.symbol_rate_hz = 5361000;\n\n\t\tqam_params.symbol_rate_256qam_hz = 5361000;\n\n\t\tstatus = mxl692_i2c_writeread(dev,\n\t\t\t\t\t      MXL_EAGLE_OPCODE_QAM_PARAMS_SET,\n\t\t\t\t\t      (u8 *)&qam_params,\n\t\t\t\t\t      sizeof(struct MXL_EAGLE_QAM_DEMOD_PARAMS_T),\n\t\t\t\t\t      NULL, 0);\n\t\tif (status)\n\t\t\tgoto err;\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tusleep_range(20 * 1000, 30 * 1000);  \n\n\ttuner_params.freq_hz = p->frequency;\n\ttuner_params.bandwidth = MXL_EAGLE_TUNER_BW_6MHZ;\n\ttuner_params.tune_mode = MXL_EAGLE_TUNER_CHANNEL_TUNE_MODE_VIEW;\n\n\tdev_dbg(&dev->i2c_client->dev, \" Tuning Freq: %d %s\\n\", tuner_params.freq_hz,\n\t\tdemod_type == MXL_EAGLE_DEMOD_TYPE_ATSC ? \"ATSC\" : \"QAM\");\n\n\tstatus = mxl692_i2c_writeread(dev,\n\t\t\t\t      MXL_EAGLE_OPCODE_TUNER_CHANNEL_TUNE_SET,\n\t\t\t\t      (u8 *)&tuner_params,\n\t\t\t\t      sizeof(struct MXL_EAGLE_TUNER_CHANNEL_PARAMS_T),\n\t\t\t\t      NULL,\n\t\t\t\t      0);\n\tif (status)\n\t\tgoto err;\n\n\tusleep_range(20 * 1000, 30 * 1000);  \n\n\tswitch (demod_type) {\n\tcase MXL_EAGLE_DEMOD_TYPE_ATSC:\n\t\tstatus = mxl692_i2c_writeread(dev,\n\t\t\t\t\t      MXL_EAGLE_OPCODE_ATSC_INIT_SET,\n\t\t\t\t\t      NULL, 0, NULL, 0);\n\t\tif (status)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase MXL_EAGLE_DEMOD_TYPE_QAM:\n\t\tstatus = mxl692_i2c_writeread(dev,\n\t\t\t\t\t      MXL_EAGLE_OPCODE_QAM_RESTART_SET,\n\t\t\t\t\t      NULL, 0, NULL, 0);\n\t\tif (status)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev->demod_type = demod_type;\n\tdev->current_frequency = p->frequency;\n\n\treturn 0;\nerr:\n\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", status);\n\treturn status;\n}\n\nstatic int mxl692_get_frontend(struct dvb_frontend *fe,\n\t\t\t       struct dtv_frontend_properties *p)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tp->modulation = c->modulation;\n\tp->frequency = c->frequency;\n\n\treturn 0;\n}\n\nstatic int mxl692_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct mxl692_dev *dev = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu8 rx_buf[MXL_EAGLE_MAX_I2C_PACKET_SIZE] = {};\n\tstruct MXL_EAGLE_ATSC_DEMOD_STATUS_T *atsc_status;\n\tstruct MXL_EAGLE_QAM_DEMOD_STATUS_T *qam_status;\n\tenum MXL_EAGLE_DEMOD_TYPE_E demod_type = dev->demod_type;\n\tint mxl_status = 0;\n\n\t*snr = 0;\n\n\tdev_dbg(&dev->i2c_client->dev, \"\\n\");\n\n\tatsc_status = (struct MXL_EAGLE_ATSC_DEMOD_STATUS_T *)&rx_buf;\n\tqam_status = (struct MXL_EAGLE_QAM_DEMOD_STATUS_T *)&rx_buf;\n\n\tswitch (demod_type) {\n\tcase MXL_EAGLE_DEMOD_TYPE_ATSC:\n\t\tmxl_status = mxl692_i2c_writeread(dev,\n\t\t\t\t\t\t  MXL_EAGLE_OPCODE_ATSC_STATUS_GET,\n\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  rx_buf,\n\t\t\t\t\t\t  sizeof(struct MXL_EAGLE_ATSC_DEMOD_STATUS_T));\n\t\tif (!mxl_status) {\n\t\t\t*snr = (u16)(atsc_status->snr_db_tenths / 10);\n\t\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\t\tc->cnr.stat[0].svalue = *snr;\n\t\t}\n\t\tbreak;\n\tcase MXL_EAGLE_DEMOD_TYPE_QAM:\n\t\tmxl_status = mxl692_i2c_writeread(dev,\n\t\t\t\t\t\t  MXL_EAGLE_OPCODE_QAM_STATUS_GET,\n\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  rx_buf,\n\t\t\t\t\t\t  sizeof(struct MXL_EAGLE_QAM_DEMOD_STATUS_T));\n\t\tif (!mxl_status)\n\t\t\t*snr = (u16)(qam_status->snr_db_tenths / 10);\n\t\tbreak;\n\tcase MXL_EAGLE_DEMOD_TYPE_OOB:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (mxl_status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", mxl_status);\n\treturn mxl_status;\n}\n\nstatic int mxl692_read_ber_ucb(struct dvb_frontend *fe)\n{\n\tstruct mxl692_dev *dev = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu8 rx_buf[MXL_EAGLE_MAX_I2C_PACKET_SIZE] = {};\n\tstruct MXL_EAGLE_ATSC_DEMOD_ERROR_COUNTERS_T *atsc_errors;\n\tenum MXL_EAGLE_DEMOD_TYPE_E demod_type = dev->demod_type;\n\tint mxl_status = 0;\n\tu32 utmp;\n\n\tdev_dbg(&dev->i2c_client->dev, \"\\n\");\n\n\tatsc_errors = (struct MXL_EAGLE_ATSC_DEMOD_ERROR_COUNTERS_T *)&rx_buf;\n\n\tswitch (demod_type) {\n\tcase MXL_EAGLE_DEMOD_TYPE_ATSC:\n\t\tmxl_status = mxl692_i2c_writeread(dev,\n\t\t\t\t\t\t  MXL_EAGLE_OPCODE_ATSC_ERROR_COUNTERS_GET,\n\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  rx_buf,\n\t\t\t\t\t\t  sizeof(struct MXL_EAGLE_ATSC_DEMOD_ERROR_COUNTERS_T));\n\t\tif (!mxl_status) {\n\t\t\tif (atsc_errors->error_packets == 0)\n\t\t\t\tutmp = 0;\n\t\t\telse\n\t\t\t\tutmp = ((atsc_errors->error_bytes / atsc_errors->error_packets) *\n\t\t\t\t\tatsc_errors->total_packets);\n\t\t\t \n\t\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_error.stat[0].uvalue += atsc_errors->error_bytes;\n\t\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_count.stat[0].uvalue += utmp;\n\t\t\t \n\t\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->block_error.stat[0].uvalue += atsc_errors->error_packets;\n\n\t\t\tdev_dbg(&dev->i2c_client->dev, \"%llu   %llu\\n\",\n\t\t\t\tc->post_bit_count.stat[0].uvalue, c->block_error.stat[0].uvalue);\n\t\t}\n\t\tbreak;\n\tcase MXL_EAGLE_DEMOD_TYPE_QAM:\n\tcase MXL_EAGLE_DEMOD_TYPE_OOB:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (mxl_status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", mxl_status);\n\n\treturn mxl_status;\n}\n\nstatic int mxl692_read_status(struct dvb_frontend *fe,\n\t\t\t      enum fe_status *status)\n{\n\tstruct mxl692_dev *dev = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu8 rx_buf[MXL_EAGLE_MAX_I2C_PACKET_SIZE] = {};\n\tstruct MXL_EAGLE_ATSC_DEMOD_STATUS_T *atsc_status;\n\tstruct MXL_EAGLE_QAM_DEMOD_STATUS_T *qam_status;\n\tenum MXL_EAGLE_DEMOD_TYPE_E demod_type = dev->demod_type;\n\tint mxl_status = 0;\n\t*status = 0;\n\n\tdev_dbg(&dev->i2c_client->dev, \"\\n\");\n\n\tatsc_status = (struct MXL_EAGLE_ATSC_DEMOD_STATUS_T *)&rx_buf;\n\tqam_status = (struct MXL_EAGLE_QAM_DEMOD_STATUS_T *)&rx_buf;\n\n\tswitch (demod_type) {\n\tcase MXL_EAGLE_DEMOD_TYPE_ATSC:\n\t\tmxl_status = mxl692_i2c_writeread(dev,\n\t\t\t\t\t\t  MXL_EAGLE_OPCODE_ATSC_STATUS_GET,\n\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  rx_buf,\n\t\t\t\t\t\t  sizeof(struct MXL_EAGLE_ATSC_DEMOD_STATUS_T));\n\t\tif (!mxl_status && atsc_status->atsc_lock) {\n\t\t\t*status |= FE_HAS_SIGNAL;\n\t\t\t*status |= FE_HAS_CARRIER;\n\t\t\t*status |= FE_HAS_VITERBI;\n\t\t\t*status |= FE_HAS_SYNC;\n\t\t\t*status |= FE_HAS_LOCK;\n\n\t\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\t\tc->cnr.stat[0].svalue = atsc_status->snr_db_tenths / 10;\n\t\t}\n\t\tbreak;\n\tcase MXL_EAGLE_DEMOD_TYPE_QAM:\n\t\tmxl_status = mxl692_i2c_writeread(dev,\n\t\t\t\t\t\t  MXL_EAGLE_OPCODE_QAM_STATUS_GET,\n\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  rx_buf,\n\t\t\t\t\t\t  sizeof(struct MXL_EAGLE_QAM_DEMOD_STATUS_T));\n\t\tif (!mxl_status && qam_status->qam_locked) {\n\t\t\t*status |= FE_HAS_SIGNAL;\n\t\t\t*status |= FE_HAS_CARRIER;\n\t\t\t*status |= FE_HAS_VITERBI;\n\t\t\t*status |= FE_HAS_SYNC;\n\t\t\t*status |= FE_HAS_LOCK;\n\n\t\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\t\tc->cnr.stat[0].svalue = qam_status->snr_db_tenths / 10;\n\t\t}\n\t\tbreak;\n\tcase MXL_EAGLE_DEMOD_TYPE_OOB:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((*status & FE_HAS_LOCK) == 0) {\n\t\t \n\t\tc->cnr.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn 0;\n\t}\n\n\tif (mxl_status)\n\t\tdev_dbg(&dev->i2c_client->dev, \"err %d\\n\", mxl_status);\n\telse\n\t\tmxl_status = mxl692_read_ber_ucb(fe);\n\n\treturn mxl_status;\n}\n\nstatic const struct dvb_frontend_ops mxl692_ops = {\n\t.delsys = { SYS_ATSC },\n\t.info = {\n\t\t.name = \"MaxLinear MxL692 VSB tuner-demodulator\",\n\t\t.frequency_min_hz      = 54000000,\n\t\t.frequency_max_hz      = 858000000,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.caps = FE_CAN_8VSB\n\t},\n\n\t.init         = mxl692_init,\n\t.sleep        = mxl692_sleep,\n\t.set_frontend = mxl692_set_frontend,\n\t.get_frontend = mxl692_get_frontend,\n\n\t.read_status          = mxl692_read_status,\n\t.read_snr             = mxl692_read_snr,\n};\n\nstatic int mxl692_probe(struct i2c_client *client)\n{\n\tstruct mxl692_config *config = client->dev.platform_data;\n\tstruct mxl692_dev *dev;\n\tint ret = 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tdev_dbg(&client->dev, \"kzalloc() failed\\n\");\n\t\tgoto err;\n\t}\n\n\tmemcpy(&dev->fe.ops, &mxl692_ops, sizeof(struct dvb_frontend_ops));\n\tdev->fe.demodulator_priv = dev;\n\tdev->i2c_client = client;\n\t*config->fe = &dev->fe;\n\tmutex_init(&dev->i2c_lock);\n\ti2c_set_clientdata(client, dev);\n\n\tdev_info(&client->dev, \"MaxLinear mxl692 successfully attached\\n\");\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn -ENODEV;\n}\n\nstatic void mxl692_remove(struct i2c_client *client)\n{\n\tstruct mxl692_dev *dev = i2c_get_clientdata(client);\n\n\tdev->fe.demodulator_priv = NULL;\n\ti2c_set_clientdata(client, NULL);\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id mxl692_id_table[] = {\n\t{\"mxl692\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, mxl692_id_table);\n\nstatic struct i2c_driver mxl692_driver = {\n\t.driver = {\n\t\t.name\t= \"mxl692\",\n\t},\n\t.probe\t\t= mxl692_probe,\n\t.remove\t\t= mxl692_remove,\n\t.id_table\t= mxl692_id_table,\n};\n\nmodule_i2c_driver(mxl692_driver);\n\nMODULE_AUTHOR(\"Brad Love <brad@nextdimension.cc>\");\nMODULE_DESCRIPTION(\"MaxLinear MxL692 demodulator/tuner driver\");\nMODULE_FIRMWARE(MXL692_FIRMWARE);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}