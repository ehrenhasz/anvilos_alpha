{
  "module_name": "s921.c",
  "hash_id": "84ac4579db013a86079c879a956dfb8124437a209b8328e5ab8a8ae8681228d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/s921.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"s921.h\"\n\nstatic int debug = 1;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Activates frontend debugging (default:0)\");\n\n#define rc(args...)  do {\t\t\t\t\t\t\\\n\tprintk(KERN_ERR  \"s921: \" args);\t\t\t\t\\\n} while (0)\n\n#define dprintk(args...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (debug) {\t\t\t\t\t\t\\\n\t\t\tprintk(KERN_DEBUG \"s921: %s: \", __func__);\t\\\n\t\t\tprintk(args);\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstruct s921_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct s921_config *config;\n\n\tstruct dvb_frontend frontend;\n\n\t \n\tu32 currentfreq;\n};\n\n \nstatic struct s921_bandselect_val {\n\tu32 freq_low;\n\tu8  band_reg;\n} s921_bandselect[] = {\n\t{         0, 0x7b },\n\t{ 485140000, 0x5b },\n\t{ 515140000, 0x3b },\n\t{ 545140000, 0x1b },\n\t{ 599140000, 0xfb },\n\t{ 623140000, 0xdb },\n\t{ 659140000, 0xbb },\n\t{ 713140000, 0x9b },\n};\n\nstruct regdata {\n\tu8 reg;\n\tu8 data;\n};\n\nstatic struct regdata s921_init[] = {\n\t{ 0x01, 0x80 },\t\t \n\t{ 0x01, 0x40 },\n\t{ 0x01, 0x80 },\n\t{ 0x01, 0x40 },\n\n\t{ 0x02, 0x00 },\n\t{ 0x03, 0x40 },\n\t{ 0x04, 0x01 },\n\t{ 0x05, 0x00 },\n\t{ 0x06, 0x00 },\n\t{ 0x07, 0x00 },\n\t{ 0x08, 0x00 },\n\t{ 0x09, 0x00 },\n\t{ 0x0a, 0x00 },\n\t{ 0x0b, 0x5a },\n\t{ 0x0c, 0x00 },\n\t{ 0x0d, 0x00 },\n\t{ 0x0f, 0x00 },\n\t{ 0x13, 0x1b },\n\t{ 0x14, 0x80 },\n\t{ 0x15, 0x40 },\n\t{ 0x17, 0x70 },\n\t{ 0x18, 0x01 },\n\t{ 0x19, 0x12 },\n\t{ 0x1a, 0x01 },\n\t{ 0x1b, 0x12 },\n\t{ 0x1c, 0xa0 },\n\t{ 0x1d, 0x00 },\n\t{ 0x1e, 0x0a },\n\t{ 0x1f, 0x08 },\n\t{ 0x20, 0x40 },\n\t{ 0x21, 0xff },\n\t{ 0x22, 0x4c },\n\t{ 0x23, 0x4e },\n\t{ 0x24, 0x4c },\n\t{ 0x25, 0x00 },\n\t{ 0x26, 0x00 },\n\t{ 0x27, 0xf4 },\n\t{ 0x28, 0x60 },\n\t{ 0x29, 0x88 },\n\t{ 0x2a, 0x40 },\n\t{ 0x2b, 0x40 },\n\t{ 0x2c, 0xff },\n\t{ 0x2d, 0x00 },\n\t{ 0x2e, 0xff },\n\t{ 0x2f, 0x00 },\n\t{ 0x30, 0x20 },\n\t{ 0x31, 0x06 },\n\t{ 0x32, 0x0c },\n\t{ 0x34, 0x0f },\n\t{ 0x37, 0xfe },\n\t{ 0x38, 0x00 },\n\t{ 0x39, 0x63 },\n\t{ 0x3a, 0x10 },\n\t{ 0x3b, 0x10 },\n\t{ 0x47, 0x00 },\n\t{ 0x49, 0xe5 },\n\t{ 0x4b, 0x00 },\n\t{ 0x50, 0xc0 },\n\t{ 0x52, 0x20 },\n\t{ 0x54, 0x5a },\n\t{ 0x55, 0x5b },\n\t{ 0x56, 0x40 },\n\t{ 0x57, 0x70 },\n\t{ 0x5c, 0x50 },\n\t{ 0x5d, 0x00 },\n\t{ 0x62, 0x17 },\n\t{ 0x63, 0x2f },\n\t{ 0x64, 0x6f },\n\t{ 0x68, 0x00 },\n\t{ 0x69, 0x89 },\n\t{ 0x6a, 0x00 },\n\t{ 0x6b, 0x00 },\n\t{ 0x6c, 0x00 },\n\t{ 0x6d, 0x00 },\n\t{ 0x6e, 0x00 },\n\t{ 0x70, 0x10 },\n\t{ 0x71, 0x00 },\n\t{ 0x75, 0x00 },\n\t{ 0x76, 0x30 },\n\t{ 0x77, 0x01 },\n\t{ 0xaf, 0x00 },\n\t{ 0xb0, 0xa0 },\n\t{ 0xb2, 0x3d },\n\t{ 0xb3, 0x25 },\n\t{ 0xb4, 0x8b },\n\t{ 0xb5, 0x4b },\n\t{ 0xb6, 0x3f },\n\t{ 0xb7, 0xff },\n\t{ 0xb8, 0xff },\n\t{ 0xb9, 0xfc },\n\t{ 0xba, 0x00 },\n\t{ 0xbb, 0x00 },\n\t{ 0xbc, 0x00 },\n\t{ 0xd0, 0x30 },\n\t{ 0xe4, 0x84 },\n\t{ 0xf0, 0x48 },\n\t{ 0xf1, 0x19 },\n\t{ 0xf2, 0x5a },\n\t{ 0xf3, 0x8e },\n\t{ 0xf4, 0x2d },\n\t{ 0xf5, 0x07 },\n\t{ 0xf6, 0x5a },\n\t{ 0xf7, 0xba },\n\t{ 0xf8, 0xd7 },\n};\n\nstatic struct regdata s921_prefreq[] = {\n\t{ 0x47, 0x60 },\n\t{ 0x68, 0x00 },\n\t{ 0x69, 0x89 },\n\t{ 0xf0, 0x48 },\n\t{ 0xf1, 0x19 },\n};\n\nstatic struct regdata s921_postfreq[] = {\n\t{ 0xf5, 0xae },\n\t{ 0xf6, 0xb7 },\n\t{ 0xf7, 0xba },\n\t{ 0xf8, 0xd7 },\n\t{ 0x68, 0x0a },\n\t{ 0x69, 0x09 },\n};\n\nstatic int s921_i2c_writereg(struct s921_state *state,\n\t\t\t     u8 i2c_addr, int reg, int data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = {\n\t\t.addr = i2c_addr, .flags = 0, .buf = buf, .len = 2\n\t};\n\tint rc;\n\n\trc = i2c_transfer(state->i2c, &msg, 1);\n\tif (rc != 1) {\n\t\tprintk(\"%s: writereg rcor(rc == %i, reg == 0x%02x, data == 0x%02x)\\n\",\n\t\t       __func__, rc, reg, data);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int s921_i2c_writeregdata(struct s921_state *state, u8 i2c_addr,\n\t\t\t\t struct regdata *rd, int size)\n{\n\tint i, rc;\n\n\tfor (i = 0; i < size; i++) {\n\t\trc = s921_i2c_writereg(state, i2c_addr, rd[i].reg, rd[i].data);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int s921_i2c_readreg(struct s921_state *state, u8 i2c_addr, u8 reg)\n{\n\tu8 val;\n\tint rc;\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = i2c_addr, .flags = 0, .buf = &reg, .len = 1 },\n\t\t{ .addr = i2c_addr, .flags = I2C_M_RD, .buf = &val, .len = 1 }\n\t};\n\n\trc = i2c_transfer(state->i2c, msg, 2);\n\n\tif (rc != 2) {\n\t\trc(\"%s: reg=0x%x (rcor=%d)\\n\", __func__, reg, rc);\n\t\treturn rc;\n\t}\n\n\treturn val;\n}\n\n#define s921_readreg(state, reg) \\\n\ts921_i2c_readreg(state, state->config->demod_address, reg)\n#define s921_writereg(state, reg, val) \\\n\ts921_i2c_writereg(state, state->config->demod_address, reg, val)\n#define s921_writeregdata(state, regdata) \\\n\ts921_i2c_writeregdata(state, state->config->demod_address, \\\n\tregdata, ARRAY_SIZE(regdata))\n\nstatic int s921_pll_tune(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct s921_state *state = fe->demodulator_priv;\n\tint band, rc, i;\n\tunsigned long f_offset;\n\tu8 f_switch;\n\tu64 offset;\n\n\tdprintk(\"frequency=%i\\n\", p->frequency);\n\n\tfor (band = 0; band < ARRAY_SIZE(s921_bandselect); band++)\n\t\tif (p->frequency < s921_bandselect[band].freq_low)\n\t\t\tbreak;\n\tband--;\n\n\tif (band < 0) {\n\t\trc(\"%s: frequency out of range\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tf_switch = s921_bandselect[band].band_reg;\n\n\toffset = ((u64)p->frequency) * 258;\n\tdo_div(offset, 6000000);\n\tf_offset = ((unsigned long)offset) + 2321;\n\n\trc = s921_writeregdata(state, s921_prefreq);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = s921_writereg(state, 0xf2, (f_offset >> 8) & 0xff);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = s921_writereg(state, 0xf3, f_offset & 0xff);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = s921_writereg(state, 0xf4, f_switch);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = s921_writeregdata(state, s921_postfreq);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tfor (i = 0 ; i < 6; i++) {\n\t\trc = s921_readreg(state, 0x80);\n\t\tdprintk(\"status 0x80: %02x\\n\", rc);\n\t}\n\trc = s921_writereg(state, 0x01, 0x40);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = s921_readreg(state, 0x01);\n\tdprintk(\"status 0x01: %02x\\n\", rc);\n\n\trc = s921_readreg(state, 0x80);\n\tdprintk(\"status 0x80: %02x\\n\", rc);\n\n\trc = s921_readreg(state, 0x80);\n\tdprintk(\"status 0x80: %02x\\n\", rc);\n\n\trc = s921_readreg(state, 0x32);\n\tdprintk(\"status 0x32: %02x\\n\", rc);\n\n\tdprintk(\"pll tune band=%d, pll=%d\\n\", f_switch, (int)f_offset);\n\n\treturn 0;\n}\n\nstatic int s921_initfe(struct dvb_frontend *fe)\n{\n\tstruct s921_state *state = fe->demodulator_priv;\n\tint rc;\n\n\tdprintk(\"\\n\");\n\n\trc = s921_writeregdata(state, s921_init);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int s921_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct s921_state *state = fe->demodulator_priv;\n\tint regstatus, rc;\n\n\t*status = 0;\n\n\trc = s921_readreg(state, 0x81);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tregstatus = rc << 8;\n\n\trc = s921_readreg(state, 0x82);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tregstatus |= rc;\n\n\tdprintk(\"status = %04x\\n\", regstatus);\n\n\t \n\tif ((regstatus & 0xff) == 0x40) {\n\t\t*status = FE_HAS_SIGNAL  |\n\t\t\t  FE_HAS_CARRIER |\n\t\t\t  FE_HAS_VITERBI |\n\t\t\t  FE_HAS_SYNC    |\n\t\t\t  FE_HAS_LOCK;\n\t} else if (regstatus & 0x40) {\n\t\t \n\t\t*status = FE_HAS_SIGNAL  |\n\t\t\t  FE_HAS_CARRIER |\n\t\t\t  FE_HAS_VITERBI |\n\t\t\t  FE_HAS_SYNC;\n\t}\n\n\treturn 0;\n}\n\nstatic int s921_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tenum fe_status\tstatus;\n\tstruct s921_state *state = fe->demodulator_priv;\n\tint rc;\n\n\t \n\trc = s921_read_status(fe, &status);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*strength = (status & FE_HAS_LOCK) ? 0xffff : 0;\n\n\tdprintk(\"strength = 0x%04x\\n\", *strength);\n\n\trc = s921_readreg(state, 0x01);\n\tdprintk(\"status 0x01: %02x\\n\", rc);\n\n\trc = s921_readreg(state, 0x80);\n\tdprintk(\"status 0x80: %02x\\n\", rc);\n\n\trc = s921_readreg(state, 0x32);\n\tdprintk(\"status 0x32: %02x\\n\", rc);\n\n\treturn 0;\n}\n\nstatic int s921_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct s921_state *state = fe->demodulator_priv;\n\tint rc;\n\n\tdprintk(\"\\n\");\n\n\t \n\n\trc = s921_pll_tune(fe);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tstate->currentfreq = p->frequency;\n\n\treturn 0;\n}\n\nstatic int s921_get_frontend(struct dvb_frontend *fe,\n\t\t\t     struct dtv_frontend_properties *p)\n{\n\tstruct s921_state *state = fe->demodulator_priv;\n\n\t \n\tp->frequency = state->currentfreq;\n\tp->delivery_system = SYS_ISDBT;\n\n\treturn 0;\n}\n\nstatic int s921_tune(struct dvb_frontend *fe,\n\t\t\tbool re_tune,\n\t\t\tunsigned int mode_flags,\n\t\t\tunsigned int *delay,\n\t\t\tenum fe_status *status)\n{\n\tint rc = 0;\n\n\tdprintk(\"\\n\");\n\n\tif (re_tune)\n\t\trc = s921_set_frontend(fe);\n\n\tif (!(mode_flags & FE_TUNE_MODE_ONESHOT))\n\t\ts921_read_status(fe, status);\n\n\treturn rc;\n}\n\nstatic enum dvbfe_algo s921_get_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic void s921_release(struct dvb_frontend *fe)\n{\n\tstruct s921_state *state = fe->demodulator_priv;\n\n\tdprintk(\"\\n\");\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops s921_ops;\n\nstruct dvb_frontend *s921_attach(const struct s921_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\t \n\tstruct s921_state *state =\n\t\tkzalloc(sizeof(struct s921_state), GFP_KERNEL);\n\n\tdprintk(\"\\n\");\n\tif (!state) {\n\t\trc(\"Unable to kzalloc\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t \n\tmemcpy(&state->frontend.ops, &s921_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\treturn &state->frontend;\n}\nEXPORT_SYMBOL_GPL(s921_attach);\n\nstatic const struct dvb_frontend_ops s921_ops = {\n\t.delsys = { SYS_ISDBT },\n\t \n\t.info = {\n\t\t.name = \"Sharp S921\",\n\t\t.frequency_min_hz = 470 * MHz,\n\t\t \n\t\t.frequency_max_hz = 806 * MHz,\n\t\t.caps =  FE_CAN_INVERSION_AUTO |\n\t\t\t FE_CAN_FEC_1_2  | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\t FE_CAN_FEC_5_6  | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\t FE_CAN_QPSK     | FE_CAN_QAM_16 | FE_CAN_QAM_64 |\n\t\t\t FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\t FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_RECOVER |\n\t\t\t FE_CAN_HIERARCHY_AUTO,\n\t},\n\n\t.release = s921_release,\n\n\t.init = s921_initfe,\n\t.set_frontend = s921_set_frontend,\n\t.get_frontend = s921_get_frontend,\n\t.read_status = s921_read_status,\n\t.read_signal_strength = s921_read_signal_strength,\n\t.tune = s921_tune,\n\t.get_frontend_algo = s921_get_algo,\n};\n\nMODULE_DESCRIPTION(\"DVB Frontend module for Sharp S921 hardware\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_AUTHOR(\"Douglas Landgraf <dougsland@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}