{
  "module_name": "mb86a16.c",
  "hash_id": "ffc78da92160067da504d34172c0e9e1d261683e2e47d1f2631f3880d4b65ce5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/mb86a16.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"mb86a16.h\"\n#include \"mb86a16_priv.h\"\n\nstatic unsigned int verbose = 5;\nmodule_param(verbose, int, 0644);\n\nstruct mb86a16_state {\n\tstruct i2c_adapter\t\t*i2c_adap;\n\tconst struct mb86a16_config\t*config;\n\tstruct dvb_frontend\t\tfrontend;\n\n\t \n\tint\t\t\t\tfrequency;\n\tint\t\t\t\tsrate;\n\n\t \n\tint\t\t\t\tmaster_clk;\n\tint\t\t\t\tdeci;\n\tint\t\t\t\tcsel;\n\tint\t\t\t\trsel;\n};\n\n#define MB86A16_ERROR\t\t0\n#define MB86A16_NOTICE\t\t1\n#define MB86A16_INFO\t\t2\n#define MB86A16_DEBUG\t\t3\n\n#define dprintk(x, y, z, format, arg...) do {\t\t\t\t\t\t\\\n\tif (z) {\t\t\t\t\t\t\t\t\t\\\n\t\tif\t((x > MB86A16_ERROR) && (x > y))\t\t\t\t\\\n\t\t\tprintk(KERN_ERR \"%s: \" format \"\\n\", __func__, ##arg);\t\t\\\n\t\telse if ((x > MB86A16_NOTICE) && (x > y))\t\t\t\t\\\n\t\t\tprintk(KERN_NOTICE \"%s: \" format \"\\n\", __func__, ##arg);\t\\\n\t\telse if ((x > MB86A16_INFO) && (x > y))\t\t\t\t\t\\\n\t\t\tprintk(KERN_INFO \"%s: \" format \"\\n\", __func__, ##arg);\t\t\\\n\t\telse if ((x > MB86A16_DEBUG) && (x > y))\t\t\t\t\\\n\t\t\tprintk(KERN_DEBUG \"%s: \" format \"\\n\", __func__, ##arg);\t\t\\\n\t} else {\t\t\t\t\t\t\t\t\t\\\n\t\tif (x > y)\t\t\t\t\t\t\t\t\\\n\t\t\tprintk(format, ##arg);\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define TRACE_IN\tdprintk(verbose, MB86A16_DEBUG, 1, \"-->()\")\n#define TRACE_OUT\tdprintk(verbose, MB86A16_DEBUG, 1, \"()-->\")\n\nstatic int mb86a16_write(struct mb86a16_state *state, u8 reg, u8 val)\n{\n\tint ret;\n\tu8 buf[] = { reg, val };\n\n\tstruct i2c_msg msg = {\n\t\t.addr = state->config->demod_address,\n\t\t.flags = 0,\n\t\t.buf = buf,\n\t\t.len = 2\n\t};\n\n\tdprintk(verbose, MB86A16_DEBUG, 1,\n\t\t\"writing to [0x%02x],Reg[0x%02x],Data[0x%02x]\",\n\t\tstate->config->demod_address, buf[0], buf[1]);\n\n\tret = i2c_transfer(state->i2c_adap, &msg, 1);\n\n\treturn (ret != 1) ? -EREMOTEIO : 0;\n}\n\nstatic int mb86a16_read(struct mb86a16_state *state, u8 reg, u8 *val)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = state->config->demod_address,\n\t\t\t.flags = 0,\n\t\t\t.buf = b0,\n\t\t\t.len = 1\n\t\t}, {\n\t\t\t.addr = state->config->demod_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = b1,\n\t\t\t.len = 1\n\t\t}\n\t};\n\tret = i2c_transfer(state->i2c_adap, msg, 2);\n\tif (ret != 2) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"read error(reg=0x%02x, ret=%i)\",\n\t\t\treg, ret);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EREMOTEIO;\n\t}\n\t*val = b1[0];\n\n\treturn ret;\n}\n\nstatic int CNTM_set(struct mb86a16_state *state,\n\t\t    unsigned char timint1,\n\t\t    unsigned char timint2,\n\t\t    unsigned char cnext)\n{\n\tunsigned char val;\n\n\tval = (timint1 << 4) | (timint2 << 2) | cnext;\n\tif (mb86a16_write(state, MB86A16_CNTMR, val) < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic int smrt_set(struct mb86a16_state *state, int rate)\n{\n\tint tmp ;\n\tint m ;\n\tunsigned char STOFS0, STOFS1;\n\n\tm = 1 << state->deci;\n\ttmp = (8192 * state->master_clk - 2 * m * rate * 8192 + state->master_clk / 2) / state->master_clk;\n\n\tSTOFS0 = tmp & 0x0ff;\n\tSTOFS1 = (tmp & 0xf00) >> 8;\n\n\tif (mb86a16_write(state, MB86A16_SRATE1, (state->deci << 2) |\n\t\t\t\t       (state->csel << 1) |\n\t\t\t\t\tstate->rsel) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_SRATE2, STOFS0) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_SRATE3, STOFS1) < 0)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -1;\n}\n\nstatic int srst(struct mb86a16_state *state)\n{\n\tif (mb86a16_write(state, MB86A16_RESET, 0x04) < 0)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n\n}\n\nstatic int afcex_data_set(struct mb86a16_state *state,\n\t\t\t  unsigned char AFCEX_L,\n\t\t\t  unsigned char AFCEX_H)\n{\n\tif (mb86a16_write(state, MB86A16_AFCEXL, AFCEX_L) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_AFCEXH, AFCEX_H) < 0)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\n\treturn -1;\n}\n\nstatic int afcofs_data_set(struct mb86a16_state *state,\n\t\t\t   unsigned char AFCEX_L,\n\t\t\t   unsigned char AFCEX_H)\n{\n\tif (mb86a16_write(state, 0x58, AFCEX_L) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, 0x59, AFCEX_H) < 0)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic int stlp_set(struct mb86a16_state *state,\n\t\t    unsigned char STRAS,\n\t\t    unsigned char STRBS)\n{\n\tif (mb86a16_write(state, MB86A16_STRFILTCOEF1, (STRBS << 3) | (STRAS)) < 0)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic int Vi_set(struct mb86a16_state *state, unsigned char ETH, unsigned char VIA)\n{\n\tif (mb86a16_write(state, MB86A16_VISET2, 0x04) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_VISET3, 0xf5) < 0)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic int initial_set(struct mb86a16_state *state)\n{\n\tif (stlp_set(state, 5, 7))\n\t\tgoto err;\n\n\tudelay(100);\n\tif (afcex_data_set(state, 0, 0))\n\t\tgoto err;\n\n\tudelay(100);\n\tif (afcofs_data_set(state, 0, 0))\n\t\tgoto err;\n\n\tudelay(100);\n\tif (mb86a16_write(state, MB86A16_CRLFILTCOEF1, 0x16) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, 0x2f, 0x21) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_VIMAG, 0x38) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_FAGCS1, 0x00) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_FAGCS2, 0x1c) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_FAGCS3, 0x20) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_FAGCS4, 0x1e) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_FAGCS5, 0x23) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, 0x54, 0xff) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_TSOUT, 0x00) < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic int S01T_set(struct mb86a16_state *state,\n\t\t    unsigned char s1t,\n\t\t    unsigned s0t)\n{\n\tif (mb86a16_write(state, 0x33, (s1t << 3) | s0t) < 0)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\n\nstatic int EN_set(struct mb86a16_state *state,\n\t\t  int cren,\n\t\t  int afcen)\n{\n\tunsigned char val;\n\n\tval = 0x7a | (cren << 7) | (afcen << 2);\n\tif (mb86a16_write(state, 0x49, val) < 0)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic int AFCEXEN_set(struct mb86a16_state *state,\n\t\t       int afcexen,\n\t\t       int smrt)\n{\n\tunsigned char AFCA ;\n\n\tif (smrt > 18875)\n\t\tAFCA = 4;\n\telse if (smrt > 9375)\n\t\tAFCA = 3;\n\telse if (smrt > 2250)\n\t\tAFCA = 2;\n\telse\n\t\tAFCA = 1;\n\n\tif (mb86a16_write(state, 0x2a, 0x02 | (afcexen << 5) | (AFCA << 2)) < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic int DAGC_data_set(struct mb86a16_state *state,\n\t\t\t unsigned char DAGCA,\n\t\t\t unsigned char DAGCW)\n{\n\tif (mb86a16_write(state, 0x2d, (DAGCA << 3) | DAGCW) < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic void smrt_info_get(struct mb86a16_state *state, int rate)\n{\n\tif (rate >= 37501) {\n\t\tstate->deci = 0; state->csel = 0; state->rsel = 0;\n\t} else if (rate >= 30001) {\n\t\tstate->deci = 0; state->csel = 0; state->rsel = 1;\n\t} else if (rate >= 26251) {\n\t\tstate->deci = 0; state->csel = 1; state->rsel = 0;\n\t} else if (rate >= 22501) {\n\t\tstate->deci = 0; state->csel = 1; state->rsel = 1;\n\t} else if (rate >= 18751) {\n\t\tstate->deci = 1; state->csel = 0; state->rsel = 0;\n\t} else if (rate >= 15001) {\n\t\tstate->deci = 1; state->csel = 0; state->rsel = 1;\n\t} else if (rate >= 13126) {\n\t\tstate->deci = 1; state->csel = 1; state->rsel = 0;\n\t} else if (rate >= 11251) {\n\t\tstate->deci = 1; state->csel = 1; state->rsel = 1;\n\t} else if (rate >= 9376) {\n\t\tstate->deci = 2; state->csel = 0; state->rsel = 0;\n\t} else if (rate >= 7501) {\n\t\tstate->deci = 2; state->csel = 0; state->rsel = 1;\n\t} else if (rate >= 6563) {\n\t\tstate->deci = 2; state->csel = 1; state->rsel = 0;\n\t} else if (rate >= 5626) {\n\t\tstate->deci = 2; state->csel = 1; state->rsel = 1;\n\t} else if (rate >= 4688) {\n\t\tstate->deci = 3; state->csel = 0; state->rsel = 0;\n\t} else if (rate >= 3751) {\n\t\tstate->deci = 3; state->csel = 0; state->rsel = 1;\n\t} else if (rate >= 3282) {\n\t\tstate->deci = 3; state->csel = 1; state->rsel = 0;\n\t} else if (rate >= 2814) {\n\t\tstate->deci = 3; state->csel = 1; state->rsel = 1;\n\t} else if (rate >= 2344) {\n\t\tstate->deci = 4; state->csel = 0; state->rsel = 0;\n\t} else if (rate >= 1876) {\n\t\tstate->deci = 4; state->csel = 0; state->rsel = 1;\n\t} else if (rate >= 1641) {\n\t\tstate->deci = 4; state->csel = 1; state->rsel = 0;\n\t} else if (rate >= 1407) {\n\t\tstate->deci = 4; state->csel = 1; state->rsel = 1;\n\t} else if (rate >= 1172) {\n\t\tstate->deci = 5; state->csel = 0; state->rsel = 0;\n\t} else if (rate >=  939) {\n\t\tstate->deci = 5; state->csel = 0; state->rsel = 1;\n\t} else if (rate >=  821) {\n\t\tstate->deci = 5; state->csel = 1; state->rsel = 0;\n\t} else {\n\t\tstate->deci = 5; state->csel = 1; state->rsel = 1;\n\t}\n\n\tif (state->csel == 0)\n\t\tstate->master_clk = 92000;\n\telse\n\t\tstate->master_clk = 61333;\n\n}\n\nstatic int signal_det(struct mb86a16_state *state,\n\t\t      int smrt,\n\t\t      unsigned char *SIG)\n{\n\tint ret;\n\tint smrtd;\n\tunsigned char S[3];\n\tint i;\n\n\tif (*SIG > 45) {\n\t\tif (CNTM_set(state, 2, 1, 2) < 0) {\n\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"CNTM set Error\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (CNTM_set(state, 3, 1, 2) < 0) {\n\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"CNTM set Error\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\tif (i == 0)\n\t\t\tsmrtd = smrt * 98 / 100;\n\t\telse if (i == 1)\n\t\t\tsmrtd = smrt;\n\t\telse\n\t\t\tsmrtd = smrt * 102 / 100;\n\t\tsmrt_info_get(state, smrtd);\n\t\tsmrt_set(state, smrtd);\n\t\tsrst(state);\n\t\tmsleep_interruptible(10);\n\t\tif (mb86a16_read(state, 0x37, &(S[i])) != 2) {\n\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\tif ((S[1] > S[0] * 112 / 100) && (S[1] > S[2] * 112 / 100))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\t*SIG = S[1];\n\n\tif (CNTM_set(state, 0, 1, 2) < 0) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"CNTM set Error\");\n\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n\nstatic int rf_val_set(struct mb86a16_state *state,\n\t\t      int f,\n\t\t      int smrt,\n\t\t      unsigned char R)\n{\n\tunsigned char C, F, B;\n\tint M;\n\tunsigned char rf_val[5];\n\tint ack = -1;\n\n\tif (smrt > 37750)\n\t\tC = 1;\n\telse if (smrt > 18875)\n\t\tC = 2;\n\telse if (smrt > 5500)\n\t\tC = 3;\n\telse\n\t\tC = 4;\n\n\tif (smrt > 30500)\n\t\tF = 3;\n\telse if (smrt > 9375)\n\t\tF = 1;\n\telse if (smrt > 4625)\n\t\tF = 0;\n\telse\n\t\tF = 2;\n\n\tif (f < 1060)\n\t\tB = 0;\n\telse if (f < 1175)\n\t\tB = 1;\n\telse if (f < 1305)\n\t\tB = 2;\n\telse if (f < 1435)\n\t\tB = 3;\n\telse if (f < 1570)\n\t\tB = 4;\n\telse if (f < 1715)\n\t\tB = 5;\n\telse if (f < 1845)\n\t\tB = 6;\n\telse if (f < 1980)\n\t\tB = 7;\n\telse if (f < 2080)\n\t\tB = 8;\n\telse\n\t\tB = 9;\n\n\tM = f * (1 << R) / 2;\n\n\trf_val[0] = 0x01 | (C << 3) | (F << 1);\n\trf_val[1] = (R << 5) | ((M & 0x1f000) >> 12);\n\trf_val[2] = (M & 0x00ff0) >> 4;\n\trf_val[3] = ((M & 0x0000f) << 4) | B;\n\n\t \n\tif (mb86a16_write(state, 0x21, rf_val[0]) < 0)\n\t\tack = 0;\n\tif (mb86a16_write(state, 0x22, rf_val[1]) < 0)\n\t\tack = 0;\n\tif (mb86a16_write(state, 0x23, rf_val[2]) < 0)\n\t\tack = 0;\n\tif (mb86a16_write(state, 0x24, rf_val[3]) < 0)\n\t\tack = 0;\n\tif (mb86a16_write(state, 0x25, 0x01) < 0)\n\t\tack = 0;\n\tif (ack == 0) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"RF Setup - I2C transfer error\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int afcerr_chk(struct mb86a16_state *state)\n{\n\tunsigned char AFCM_L, AFCM_H ;\n\tint AFCM ;\n\tint afcm, afcerr ;\n\n\tif (mb86a16_read(state, 0x0e, &AFCM_L) != 2)\n\t\tgoto err;\n\tif (mb86a16_read(state, 0x0f, &AFCM_H) != 2)\n\t\tgoto err;\n\n\tAFCM = (AFCM_H << 8) + AFCM_L;\n\n\tif (AFCM > 2048)\n\t\tafcm = AFCM - 4096;\n\telse\n\t\tafcm = AFCM;\n\tafcerr = afcm * state->master_clk / 8192;\n\n\treturn afcerr;\n\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic int dagcm_val_get(struct mb86a16_state *state)\n{\n\tint DAGCM;\n\tunsigned char DAGCM_H, DAGCM_L;\n\n\tif (mb86a16_read(state, 0x45, &DAGCM_L) != 2)\n\t\tgoto err;\n\tif (mb86a16_read(state, 0x46, &DAGCM_H) != 2)\n\t\tgoto err;\n\n\tDAGCM = (DAGCM_H << 8) + DAGCM_L;\n\n\treturn DAGCM;\n\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic int mb86a16_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tu8 stat, stat2;\n\tstruct mb86a16_state *state = fe->demodulator_priv;\n\n\t*status = 0;\n\n\tif (mb86a16_read(state, MB86A16_SIG1, &stat) != 2)\n\t\tgoto err;\n\tif (mb86a16_read(state, MB86A16_SIG2, &stat2) != 2)\n\t\tgoto err;\n\tif ((stat > 25) && (stat2 > 25))\n\t\t*status |= FE_HAS_SIGNAL;\n\tif ((stat > 45) && (stat2 > 45))\n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (mb86a16_read(state, MB86A16_STATUS, &stat) != 2)\n\t\tgoto err;\n\n\tif (stat & 0x01)\n\t\t*status |= FE_HAS_SYNC;\n\tif (stat & 0x01)\n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (mb86a16_read(state, MB86A16_FRAMESYNC, &stat) != 2)\n\t\tgoto err;\n\n\tif ((stat & 0x0f) && (*status & FE_HAS_VITERBI))\n\t\t*status |= FE_HAS_LOCK;\n\n\treturn 0;\n\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic int sync_chk(struct mb86a16_state *state,\n\t\t    unsigned char *VIRM)\n{\n\tunsigned char val;\n\tint sync;\n\n\tif (mb86a16_read(state, 0x0d, &val) != 2)\n\t\tgoto err;\n\n\tdprintk(verbose, MB86A16_INFO, 1, \"Status = %02x,\", val);\n\tsync = val & 0x01;\n\t*VIRM = (val & 0x1c) >> 2;\n\n\treturn sync;\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t*VIRM = 0;\n\treturn -EREMOTEIO;\n\n}\n\nstatic int freqerr_chk(struct mb86a16_state *state,\n\t\t       int fTP,\n\t\t       int smrt,\n\t\t       int unit)\n{\n\tunsigned char CRM, AFCML, AFCMH;\n\tunsigned char temp1, temp2, temp3;\n\tint crm, afcm, AFCM;\n\tint crrerr, afcerr;\t\t \n\tint frqerr;\t\t\t \n\tint afcen, afcexen = 0;\n\tint R, M, fOSC, fOSC_OFS;\n\n\tif (mb86a16_read(state, 0x43, &CRM) != 2)\n\t\tgoto err;\n\n\tif (CRM > 127)\n\t\tcrm = CRM - 256;\n\telse\n\t\tcrm = CRM;\n\n\tcrrerr = smrt * crm / 256;\n\tif (mb86a16_read(state, 0x49, &temp1) != 2)\n\t\tgoto err;\n\n\tafcen = (temp1 & 0x04) >> 2;\n\tif (afcen == 0) {\n\t\tif (mb86a16_read(state, 0x2a, &temp1) != 2)\n\t\t\tgoto err;\n\t\tafcexen = (temp1 & 0x20) >> 5;\n\t}\n\n\tif (afcen == 1) {\n\t\tif (mb86a16_read(state, 0x0e, &AFCML) != 2)\n\t\t\tgoto err;\n\t\tif (mb86a16_read(state, 0x0f, &AFCMH) != 2)\n\t\t\tgoto err;\n\t} else if (afcexen == 1) {\n\t\tif (mb86a16_read(state, 0x2b, &AFCML) != 2)\n\t\t\tgoto err;\n\t\tif (mb86a16_read(state, 0x2c, &AFCMH) != 2)\n\t\t\tgoto err;\n\t}\n\tif ((afcen == 1) || (afcexen == 1)) {\n\t\tsmrt_info_get(state, smrt);\n\t\tAFCM = ((AFCMH & 0x01) << 8) + AFCML;\n\t\tif (AFCM > 255)\n\t\t\tafcm = AFCM - 512;\n\t\telse\n\t\t\tafcm = AFCM;\n\n\t\tafcerr = afcm * state->master_clk / 8192;\n\t} else\n\t\tafcerr = 0;\n\n\tif (mb86a16_read(state, 0x22, &temp1) != 2)\n\t\tgoto err;\n\tif (mb86a16_read(state, 0x23, &temp2) != 2)\n\t\tgoto err;\n\tif (mb86a16_read(state, 0x24, &temp3) != 2)\n\t\tgoto err;\n\n\tR = (temp1 & 0xe0) >> 5;\n\tM = ((temp1 & 0x1f) << 12) + (temp2 << 4) + (temp3 >> 4);\n\tif (R == 0)\n\t\tfOSC = 2 * M;\n\telse\n\t\tfOSC = M;\n\n\tfOSC_OFS = fOSC - fTP;\n\n\tif (unit == 0) {\t \n\t\tif (crrerr + afcerr + fOSC_OFS * 1000 >= 0)\n\t\t\tfrqerr = (crrerr + afcerr + fOSC_OFS * 1000 + 500) / 1000;\n\t\telse\n\t\t\tfrqerr = (crrerr + afcerr + fOSC_OFS * 1000 - 500) / 1000;\n\t} else {\t \n\t\tfrqerr = crrerr + afcerr + fOSC_OFS * 1000;\n\t}\n\n\treturn frqerr;\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic unsigned char vco_dev_get(struct mb86a16_state *state, int smrt)\n{\n\tunsigned char R;\n\n\tif (smrt > 9375)\n\t\tR = 0;\n\telse\n\t\tR = 1;\n\n\treturn R;\n}\n\nstatic void swp_info_get(struct mb86a16_state *state,\n\t\t\t int fOSC_start,\n\t\t\t int smrt,\n\t\t\t int v, int R,\n\t\t\t int swp_ofs,\n\t\t\t int *fOSC,\n\t\t\t int *afcex_freq,\n\t\t\t unsigned char *AFCEX_L,\n\t\t\t unsigned char *AFCEX_H)\n{\n\tint AFCEX ;\n\tint crnt_swp_freq ;\n\n\tcrnt_swp_freq = fOSC_start * 1000 + v * swp_ofs;\n\n\tif (R == 0)\n\t\t*fOSC = (crnt_swp_freq + 1000) / 2000 * 2;\n\telse\n\t\t*fOSC = (crnt_swp_freq + 500) / 1000;\n\n\tif (*fOSC >= crnt_swp_freq)\n\t\t*afcex_freq = *fOSC * 1000 - crnt_swp_freq;\n\telse\n\t\t*afcex_freq = crnt_swp_freq - *fOSC * 1000;\n\n\tAFCEX = *afcex_freq * 8192 / state->master_clk;\n\t*AFCEX_L =  AFCEX & 0x00ff;\n\t*AFCEX_H = (AFCEX & 0x0f00) >> 8;\n}\n\n\nstatic int swp_freq_calcuation(struct mb86a16_state *state, int i, int v, int *V,  int vmax, int vmin,\n\t\t\t       int SIGMIN, int fOSC, int afcex_freq, int swp_ofs, unsigned char *SIG1)\n{\n\tint swp_freq ;\n\n\tif ((i % 2 == 1) && (v <= vmax)) {\n\t\t \n\t\tif ((v - 1 == vmin)\t\t\t\t&&\n\t\t    (*(V + 30 + v) >= 0)\t\t\t&&\n\t\t    (*(V + 30 + v - 1) >= 0)\t\t\t&&\n\t\t    (*(V + 30 + v - 1) > *(V + 30 + v))\t\t&&\n\t\t    (*(V + 30 + v - 1) > SIGMIN)) {\n\n\t\t\tswp_freq = fOSC * 1000 + afcex_freq - swp_ofs;\n\t\t\t*SIG1 = *(V + 30 + v - 1);\n\t\t} else if ((v == vmax)\t\t\t\t&&\n\t\t\t   (*(V + 30 + v) >= 0)\t\t\t&&\n\t\t\t   (*(V + 30 + v - 1) >= 0)\t\t&&\n\t\t\t   (*(V + 30 + v) > *(V + 30 + v - 1))\t&&\n\t\t\t   (*(V + 30 + v) > SIGMIN)) {\n\t\t\t \n\t\t\tswp_freq = fOSC * 1000 + afcex_freq;\n\t\t\t*SIG1 = *(V + 30 + v);\n\t\t} else if ((*(V + 30 + v) > 0)\t\t\t&&\n\t\t\t   (*(V + 30 + v - 1) > 0)\t\t&&\n\t\t\t   (*(V + 30 + v - 2) > 0)\t\t&&\n\t\t\t   (*(V + 30 + v - 3) > 0)\t\t&&\n\t\t\t   (*(V + 30 + v - 1) > *(V + 30 + v))\t&&\n\t\t\t   (*(V + 30 + v - 2) > *(V + 30 + v - 3)) &&\n\t\t\t   ((*(V + 30 + v - 1) > SIGMIN)\t||\n\t\t\t   (*(V + 30 + v - 2) > SIGMIN))) {\n\t\t\t \n\t\t\tif (*(V + 30 + v - 1) >= *(V + 30 + v - 2)) {\n\t\t\t\tswp_freq = fOSC * 1000 + afcex_freq - swp_ofs;\n\t\t\t\t*SIG1 = *(V + 30 + v - 1);\n\t\t\t} else {\n\t\t\t\tswp_freq = fOSC * 1000 + afcex_freq - swp_ofs * 2;\n\t\t\t\t*SIG1 = *(V + 30 + v - 2);\n\t\t\t}\n\t\t} else if ((v == vmax)\t\t\t\t&&\n\t\t\t   (*(V + 30 + v) >= 0)\t\t\t&&\n\t\t\t   (*(V + 30 + v - 1) >= 0)\t\t&&\n\t\t\t   (*(V + 30 + v - 2) >= 0)\t\t&&\n\t\t\t   (*(V + 30 + v) > *(V + 30 + v - 2))\t&&\n\t\t\t   (*(V + 30 + v - 1) > *(V + 30 + v - 2)) &&\n\t\t\t   ((*(V + 30 + v) > SIGMIN)\t\t||\n\t\t\t   (*(V + 30 + v - 1) > SIGMIN))) {\n\t\t\t \n\t\t\tif (*(V + 30 + v) >= *(V + 30 + v - 1)) {\n\t\t\t\tswp_freq = fOSC * 1000 + afcex_freq;\n\t\t\t\t*SIG1 = *(V + 30 + v);\n\t\t\t} else {\n\t\t\t\tswp_freq = fOSC * 1000 + afcex_freq - swp_ofs;\n\t\t\t\t*SIG1 = *(V + 30 + v - 1);\n\t\t\t}\n\t\t} else  {\n\t\t\tswp_freq = -1 ;\n\t\t}\n\t} else if ((i % 2 == 0) && (v >= vmin)) {\n\t\t \n\t\tif ((*(V + 30 + v) > 0)\t\t\t\t&&\n\t\t    (*(V + 30 + v + 1) > 0)\t\t\t&&\n\t\t    (*(V + 30 + v + 2) > 0)\t\t\t&&\n\t\t    (*(V + 30 + v + 1) > *(V + 30 + v))\t\t&&\n\t\t    (*(V + 30 + v + 1) > *(V + 30 + v + 2))\t&&\n\t\t    (*(V + 30 + v + 1) > SIGMIN)) {\n\n\t\t\tswp_freq = fOSC * 1000 + afcex_freq + swp_ofs;\n\t\t\t*SIG1 = *(V + 30 + v + 1);\n\t\t} else if ((v + 1 == vmax)\t\t\t&&\n\t\t\t   (*(V + 30 + v) >= 0)\t\t\t&&\n\t\t\t   (*(V + 30 + v + 1) >= 0)\t\t&&\n\t\t\t   (*(V + 30 + v + 1) > *(V + 30 + v))\t&&\n\t\t\t   (*(V + 30 + v + 1) > SIGMIN)) {\n\t\t\t \n\t\t\tswp_freq = fOSC * 1000 + afcex_freq + swp_ofs;\n\t\t\t*SIG1 = *(V + 30 + v);\n\t\t} else if ((v == vmin)\t\t\t\t&&\n\t\t\t   (*(V + 30 + v) > 0)\t\t\t&&\n\t\t\t   (*(V + 30 + v + 1) > 0)\t\t&&\n\t\t\t   (*(V + 30 + v + 2) > 0)\t\t&&\n\t\t\t   (*(V + 30 + v) > *(V + 30 + v + 1))\t&&\n\t\t\t   (*(V + 30 + v) > *(V + 30 + v + 2))\t&&\n\t\t\t   (*(V + 30 + v) > SIGMIN)) {\n\t\t\t \n\t\t\tswp_freq = fOSC * 1000 + afcex_freq;\n\t\t\t*SIG1 = *(V + 30 + v);\n\t\t} else if ((*(V + 30 + v) >= 0)\t\t\t&&\n\t\t\t   (*(V + 30 + v + 1) >= 0)\t\t&&\n\t\t\t   (*(V + 30 + v + 2) >= 0)\t\t&&\n\t\t\t   (*(V + 30 + v + 3) >= 0)\t\t&&\n\t\t\t   (*(V + 30 + v + 1) > *(V + 30 + v))\t&&\n\t\t\t   (*(V + 30 + v + 2) > *(V + 30 + v + 3)) &&\n\t\t\t   ((*(V + 30 + v + 1) > SIGMIN)\t||\n\t\t\t    (*(V + 30 + v + 2) > SIGMIN))) {\n\t\t\t \n\t\t\tif (*(V + 30 + v + 1) >= *(V + 30 + v + 2)) {\n\t\t\t\tswp_freq = fOSC * 1000 + afcex_freq + swp_ofs;\n\t\t\t\t*SIG1 = *(V + 30 + v + 1);\n\t\t\t} else {\n\t\t\t\tswp_freq = fOSC * 1000 + afcex_freq + swp_ofs * 2;\n\t\t\t\t*SIG1 = *(V + 30 + v + 2);\n\t\t\t}\n\t\t} else if ((*(V + 30 + v) >= 0)\t\t\t&&\n\t\t\t   (*(V + 30 + v + 1) >= 0)\t\t&&\n\t\t\t   (*(V + 30 + v + 2) >= 0)\t\t&&\n\t\t\t   (*(V + 30 + v + 3) >= 0)\t\t&&\n\t\t\t   (*(V + 30 + v) > *(V + 30 + v + 2))\t&&\n\t\t\t   (*(V + 30 + v + 1) > *(V + 30 + v + 2)) &&\n\t\t\t   (*(V + 30 + v) > *(V + 30 + v + 3))\t&&\n\t\t\t   (*(V + 30 + v + 1) > *(V + 30 + v + 3)) &&\n\t\t\t   ((*(V + 30 + v) > SIGMIN)\t\t||\n\t\t\t    (*(V + 30 + v + 1) > SIGMIN))) {\n\t\t\t \n\t\t\tif (*(V + 30 + v) >= *(V + 30 + v + 1)) {\n\t\t\t\tswp_freq = fOSC * 1000 + afcex_freq;\n\t\t\t\t*SIG1 = *(V + 30 + v);\n\t\t\t} else {\n\t\t\t\tswp_freq = fOSC * 1000 + afcex_freq + swp_ofs;\n\t\t\t\t*SIG1 = *(V + 30 + v + 1);\n\t\t\t}\n\t\t} else if ((v + 2 == vmin)\t\t\t&&\n\t\t\t   (*(V + 30 + v) >= 0)\t\t\t&&\n\t\t\t   (*(V + 30 + v + 1) >= 0)\t\t&&\n\t\t\t   (*(V + 30 + v + 2) >= 0)\t\t&&\n\t\t\t   (*(V + 30 + v + 1) > *(V + 30 + v))\t&&\n\t\t\t   (*(V + 30 + v + 2) > *(V + 30 + v))\t&&\n\t\t\t   ((*(V + 30 + v + 1) > SIGMIN)\t||\n\t\t\t    (*(V + 30 + v + 2) > SIGMIN))) {\n\t\t\t \n\t\t\tif (*(V + 30 + v + 1) >= *(V + 30 + v + 2)) {\n\t\t\t\tswp_freq = fOSC * 1000 + afcex_freq + swp_ofs;\n\t\t\t\t*SIG1 = *(V + 30 + v + 1);\n\t\t\t} else {\n\t\t\t\tswp_freq = fOSC * 1000 + afcex_freq + swp_ofs * 2;\n\t\t\t\t*SIG1 = *(V + 30 + v + 2);\n\t\t\t}\n\t\t} else if ((vmax == 0) && (vmin == 0) && (*(V + 30 + v) > SIGMIN)) {\n\t\t\tswp_freq = fOSC * 1000;\n\t\t\t*SIG1 = *(V + 30 + v);\n\t\t} else\n\t\t\tswp_freq = -1;\n\t} else\n\t\tswp_freq = -1;\n\n\treturn swp_freq;\n}\n\nstatic void swp_info_get2(struct mb86a16_state *state,\n\t\t\t  int smrt,\n\t\t\t  int R,\n\t\t\t  int swp_freq,\n\t\t\t  int *afcex_freq,\n\t\t\t  int *fOSC,\n\t\t\t  unsigned char *AFCEX_L,\n\t\t\t  unsigned char *AFCEX_H)\n{\n\tint AFCEX ;\n\n\tif (R == 0)\n\t\t*fOSC = (swp_freq + 1000) / 2000 * 2;\n\telse\n\t\t*fOSC = (swp_freq + 500) / 1000;\n\n\tif (*fOSC >= swp_freq)\n\t\t*afcex_freq = *fOSC * 1000 - swp_freq;\n\telse\n\t\t*afcex_freq = swp_freq - *fOSC * 1000;\n\n\tAFCEX = *afcex_freq * 8192 / state->master_clk;\n\t*AFCEX_L =  AFCEX & 0x00ff;\n\t*AFCEX_H = (AFCEX & 0x0f00) >> 8;\n}\n\nstatic void afcex_info_get(struct mb86a16_state *state,\n\t\t\t   int afcex_freq,\n\t\t\t   unsigned char *AFCEX_L,\n\t\t\t   unsigned char *AFCEX_H)\n{\n\tint AFCEX ;\n\n\tAFCEX = afcex_freq * 8192 / state->master_clk;\n\t*AFCEX_L =  AFCEX & 0x00ff;\n\t*AFCEX_H = (AFCEX & 0x0f00) >> 8;\n}\n\nstatic int SEQ_set(struct mb86a16_state *state, unsigned char loop)\n{\n\t \n\tif (mb86a16_write(state, 0x32, 0x02 | (loop << 2)) < 0) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int iq_vt_set(struct mb86a16_state *state, unsigned char IQINV)\n{\n\t \n\tif (mb86a16_write(state, 0x06, 0xdf | (IQINV << 5)) < 0) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int FEC_srst(struct mb86a16_state *state)\n{\n\tif (mb86a16_write(state, MB86A16_RESET, 0x02) < 0) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int S2T_set(struct mb86a16_state *state, unsigned char S2T)\n{\n\tif (mb86a16_write(state, 0x34, 0x70 | S2T) < 0) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int S45T_set(struct mb86a16_state *state, unsigned char S4T, unsigned char S5T)\n{\n\tif (mb86a16_write(state, 0x35, 0x00 | (S5T << 4) | S4T) < 0) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int mb86a16_set_fe(struct mb86a16_state *state)\n{\n\tu8 agcval, cnmval;\n\n\tint i, j;\n\tint fOSC = 0;\n\tint fOSC_start = 0;\n\tint wait_t;\n\tint fcp;\n\tint swp_ofs;\n\tint V[60];\n\tu8 SIG1MIN;\n\n\tunsigned char CREN, AFCEN, AFCEXEN;\n\tunsigned char SIG1;\n\tunsigned char TIMINT1, TIMINT2, TIMEXT;\n\tunsigned char S0T, S1T;\n\tunsigned char S2T;\n \n\tunsigned char S4T, S5T;\n\tunsigned char AFCEX_L, AFCEX_H;\n\tunsigned char R;\n\tunsigned char VIRM;\n\tunsigned char ETH, VIA;\n\tunsigned char junk;\n\n\tint loop;\n\tint ftemp;\n\tint v, vmax, vmin;\n\tint vmax_his, vmin_his;\n\tint swp_freq, prev_swp_freq[20];\n\tint prev_freq_num;\n\tint signal_dupl;\n\tint afcex_freq;\n\tint signal;\n\tint afcerr;\n\tint temp_freq, delta_freq;\n\tint dagcm[4];\n\tint smrt_d;\n \n\tint n;\n\tint ret = -1;\n\tint sync;\n\n\tdprintk(verbose, MB86A16_INFO, 1, \"freq=%d Mhz, symbrt=%d Ksps\", state->frequency, state->srate);\n\n\tfcp = 3000;\n\tswp_ofs = state->srate / 4;\n\n\tfor (i = 0; i < 60; i++)\n\t\tV[i] = -1;\n\n\tfor (i = 0; i < 20; i++)\n\t\tprev_swp_freq[i] = 0;\n\n\tSIG1MIN = 25;\n\n\tfor (n = 0; ((n < 3) && (ret == -1)); n++) {\n\t\tSEQ_set(state, 0);\n\t\tiq_vt_set(state, 0);\n\n\t\tCREN = 0;\n\t\tAFCEN = 0;\n\t\tAFCEXEN = 1;\n\t\tTIMINT1 = 0;\n\t\tTIMINT2 = 1;\n\t\tTIMEXT = 2;\n\t\tS1T = 0;\n\t\tS0T = 0;\n\n\t\tif (initial_set(state) < 0) {\n\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"initial set failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (DAGC_data_set(state, 3, 2) < 0) {\n\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"DAGC data set error\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (EN_set(state, CREN, AFCEN) < 0) {\n\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"EN set error\");\n\t\t\treturn -1;  \n\t\t}\n\t\tif (AFCEXEN_set(state, AFCEXEN, state->srate) < 0) {\n\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"AFCEXEN set error\");\n\t\t\treturn -1;  \n\t\t}\n\t\tif (CNTM_set(state, TIMINT1, TIMINT2, TIMEXT) < 0) {\n\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"CNTM set error\");\n\t\t\treturn -1;  \n\t\t}\n\t\tif (S01T_set(state, S1T, S0T) < 0) {\n\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"S01T set error\");\n\t\t\treturn -1;  \n\t\t}\n\t\tsmrt_info_get(state, state->srate);\n\t\tif (smrt_set(state, state->srate) < 0) {\n\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"smrt info get error\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tR = vco_dev_get(state, state->srate);\n\t\tif (R == 1)\n\t\t\tfOSC_start = state->frequency;\n\n\t\telse if (R == 0) {\n\t\t\tif (state->frequency % 2 == 0) {\n\t\t\t\tfOSC_start = state->frequency;\n\t\t\t} else {\n\t\t\t\tfOSC_start = state->frequency + 1;\n\t\t\t\tif (fOSC_start > 2150)\n\t\t\t\t\tfOSC_start = state->frequency - 1;\n\t\t\t}\n\t\t}\n\t\tloop = 1;\n\t\tftemp = fOSC_start * 1000;\n\t\tvmax = 0 ;\n\t\twhile (loop == 1) {\n\t\t\tftemp = ftemp + swp_ofs;\n\t\t\tvmax++;\n\n\t\t\t \n\t\t\tif (ftemp > 2150000) {\n\t\t\t\tloop = 0;\n\t\t\t\tvmax--;\n\t\t\t} else {\n\t\t\t\tif ((ftemp == 2150000) ||\n\t\t\t\t    (ftemp - state->frequency * 1000 >= fcp + state->srate / 4))\n\t\t\t\t\tloop = 0;\n\t\t\t}\n\t\t}\n\n\t\tloop = 1;\n\t\tftemp = fOSC_start * 1000;\n\t\tvmin = 0 ;\n\t\twhile (loop == 1) {\n\t\t\tftemp = ftemp - swp_ofs;\n\t\t\tvmin--;\n\n\t\t\t \n\t\t\tif (ftemp < 950000) {\n\t\t\t\tloop = 0;\n\t\t\t\tvmin++;\n\t\t\t} else {\n\t\t\t\tif ((ftemp == 950000) ||\n\t\t\t\t    (state->frequency * 1000 - ftemp >= fcp + state->srate / 4))\n\t\t\t\t\tloop = 0;\n\t\t\t}\n\t\t}\n\n\t\twait_t = (8000 + state->srate / 2) / state->srate;\n\t\tif (wait_t == 0)\n\t\t\twait_t = 1;\n\n\t\ti = 0;\n\t\tj = 0;\n\t\tprev_freq_num = 0;\n\t\tloop = 1;\n\t\tsignal = 0;\n\t\tvmax_his = 0;\n\t\tvmin_his = 0;\n\t\tv = 0;\n\n\t\twhile (loop == 1) {\n\t\t\tswp_info_get(state, fOSC_start, state->srate,\n\t\t\t\t     v, R, swp_ofs, &fOSC,\n\t\t\t\t     &afcex_freq, &AFCEX_L, &AFCEX_H);\n\n\t\t\tudelay(100);\n\t\t\tif (rf_val_set(state, fOSC, state->srate, R) < 0) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"rf val set error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tudelay(100);\n\t\t\tif (afcex_data_set(state, AFCEX_L, AFCEX_H) < 0) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"afcex data set error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (srst(state) < 0) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"srst error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmsleep_interruptible(wait_t);\n\n\t\t\tif (mb86a16_read(state, 0x37, &SIG1) != 2) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tV[30 + v] = SIG1 ;\n\t\t\tswp_freq = swp_freq_calcuation(state, i, v, V, vmax, vmin,\n\t\t\t\t\t\t      SIG1MIN, fOSC, afcex_freq,\n\t\t\t\t\t\t      swp_ofs, &SIG1);\t \n\n\t\t\tsignal_dupl = 0;\n\t\t\tfor (j = 0; j < prev_freq_num; j++) {\n\t\t\t\tif ((abs(prev_swp_freq[j] - swp_freq)) < (swp_ofs * 3 / 2)) {\n\t\t\t\t\tsignal_dupl = 1;\n\t\t\t\t\tdprintk(verbose, MB86A16_INFO, 1, \"Probably Duplicate Signal, j = %d\", j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((signal_dupl == 0) && (swp_freq > 0) && (abs(swp_freq - state->frequency * 1000) < fcp + state->srate / 6)) {\n\t\t\t\tdprintk(verbose, MB86A16_DEBUG, 1, \"------ Signal detect ------ [swp_freq=[%07d, srate=%05d]]\", swp_freq, state->srate);\n\t\t\t\tprev_swp_freq[prev_freq_num] = swp_freq;\n\t\t\t\tprev_freq_num++;\n\t\t\t\tswp_info_get2(state, state->srate, R, swp_freq,\n\t\t\t\t\t      &afcex_freq, &fOSC,\n\t\t\t\t\t      &AFCEX_L, &AFCEX_H);\n\n\t\t\t\tif (rf_val_set(state, fOSC, state->srate, R) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"rf val set error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (afcex_data_set(state, AFCEX_L, AFCEX_H) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"afcex data set error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tsignal = signal_det(state, state->srate, &SIG1);\n\t\t\t\tif (signal == 1) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"***** Signal Found *****\");\n\t\t\t\t\tloop = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"!!!!! No signal !!!!!, try again...\");\n\t\t\t\t\tsmrt_info_get(state, state->srate);\n\t\t\t\t\tif (smrt_set(state, state->srate) < 0) {\n\t\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"smrt set error\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v > vmax)\n\t\t\t\tvmax_his = 1 ;\n\t\t\tif (v < vmin)\n\t\t\t\tvmin_his = 1 ;\n\t\t\ti++;\n\n\t\t\tif ((i % 2 == 1) && (vmax_his == 1))\n\t\t\t\ti++;\n\t\t\tif ((i % 2 == 0) && (vmin_his == 1))\n\t\t\t\ti++;\n\n\t\t\tif (i % 2 == 1)\n\t\t\t\tv = (i + 1) / 2;\n\t\t\telse\n\t\t\t\tv = -i / 2;\n\n\t\t\tif ((vmax_his == 1) && (vmin_his == 1))\n\t\t\t\tloop = 0 ;\n\t\t}\n\n\t\tif (signal == 1) {\n\t\t\tdprintk(verbose, MB86A16_INFO, 1, \" Start Freq Error Check\");\n\t\t\tS1T = 7 ;\n\t\t\tS0T = 1 ;\n\t\t\tCREN = 0 ;\n\t\t\tAFCEN = 1 ;\n\t\t\tAFCEXEN = 0 ;\n\n\t\t\tif (S01T_set(state, S1T, S0T) < 0) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"S01T set error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsmrt_info_get(state, state->srate);\n\t\t\tif (smrt_set(state, state->srate) < 0) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"smrt set error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (EN_set(state, CREN, AFCEN) < 0) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"EN set error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (AFCEXEN_set(state, AFCEXEN, state->srate) < 0) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"AFCEXEN set error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tafcex_info_get(state, afcex_freq, &AFCEX_L, &AFCEX_H);\n\t\t\tif (afcofs_data_set(state, AFCEX_L, AFCEX_H) < 0) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"AFCOFS data set error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (srst(state) < 0) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"srst error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t \n\t\t\twait_t = 200000 / state->master_clk + 200000 / state->srate;\n\t\t\tmsleep(wait_t);\n\t\t\tafcerr = afcerr_chk(state);\n\t\t\tif (afcerr == -1)\n\t\t\t\treturn -1;\n\n\t\t\tswp_freq = fOSC * 1000 + afcerr ;\n\t\t\tAFCEXEN = 1 ;\n\t\t\tif (state->srate >= 1500)\n\t\t\t\tsmrt_d = state->srate / 3;\n\t\t\telse\n\t\t\t\tsmrt_d = state->srate / 2;\n\t\t\tsmrt_info_get(state, smrt_d);\n\t\t\tif (smrt_set(state, smrt_d) < 0) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"smrt set error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (AFCEXEN_set(state, AFCEXEN, smrt_d) < 0) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"AFCEXEN set error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tR = vco_dev_get(state, smrt_d);\n\t\t\tif (DAGC_data_set(state, 2, 0) < 0) {\n\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"DAGC data set error\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\ttemp_freq = swp_freq + (i - 1) * state->srate / 8;\n\t\t\t\tswp_info_get2(state, smrt_d, R, temp_freq, &afcex_freq, &fOSC, &AFCEX_L, &AFCEX_H);\n\t\t\t\tif (rf_val_set(state, fOSC, smrt_d, R) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"rf val set error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (afcex_data_set(state, AFCEX_L, AFCEX_H) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"afcex data set error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\twait_t = 200000 / state->master_clk + 40000 / smrt_d;\n\t\t\t\tmsleep(wait_t);\n\t\t\t\tdagcm[i] = dagcm_val_get(state);\n\t\t\t}\n\t\t\tif ((dagcm[0] > dagcm[1]) &&\n\t\t\t    (dagcm[0] > dagcm[2]) &&\n\t\t\t    (dagcm[0] - dagcm[1] > 2 * (dagcm[2] - dagcm[1]))) {\n\n\t\t\t\ttemp_freq = swp_freq - 2 * state->srate / 8;\n\t\t\t\tswp_info_get2(state, smrt_d, R, temp_freq, &afcex_freq, &fOSC, &AFCEX_L, &AFCEX_H);\n\t\t\t\tif (rf_val_set(state, fOSC, smrt_d, R) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"rf val set error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (afcex_data_set(state, AFCEX_L, AFCEX_H) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"afcex data set\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\twait_t = 200000 / state->master_clk + 40000 / smrt_d;\n\t\t\t\tmsleep(wait_t);\n\t\t\t\tdagcm[3] = dagcm_val_get(state);\n\t\t\t\tif (dagcm[3] > dagcm[1])\n\t\t\t\t\tdelta_freq = (dagcm[2] - dagcm[0] + dagcm[1] - dagcm[3]) * state->srate / 300;\n\t\t\t\telse\n\t\t\t\t\tdelta_freq = 0;\n\t\t\t} else if ((dagcm[2] > dagcm[1]) &&\n\t\t\t\t   (dagcm[2] > dagcm[0]) &&\n\t\t\t\t   (dagcm[2] - dagcm[1] > 2 * (dagcm[0] - dagcm[1]))) {\n\n\t\t\t\ttemp_freq = swp_freq + 2 * state->srate / 8;\n\t\t\t\tswp_info_get2(state, smrt_d, R, temp_freq, &afcex_freq, &fOSC, &AFCEX_L, &AFCEX_H);\n\t\t\t\tif (rf_val_set(state, fOSC, smrt_d, R) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"rf val set\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (afcex_data_set(state, AFCEX_L, AFCEX_H) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"afcex data set\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\twait_t = 200000 / state->master_clk + 40000 / smrt_d;\n\t\t\t\tmsleep(wait_t);\n\t\t\t\tdagcm[3] = dagcm_val_get(state);\n\t\t\t\tif (dagcm[3] > dagcm[1])\n\t\t\t\t\tdelta_freq = (dagcm[2] - dagcm[0] + dagcm[3] - dagcm[1]) * state->srate / 300;\n\t\t\t\telse\n\t\t\t\t\tdelta_freq = 0 ;\n\n\t\t\t} else {\n\t\t\t\tdelta_freq = 0 ;\n\t\t\t}\n\t\t\tdprintk(verbose, MB86A16_INFO, 1, \"SWEEP Frequency = %d\", swp_freq);\n\t\t\tswp_freq += delta_freq;\n\t\t\tdprintk(verbose, MB86A16_INFO, 1, \"Adjusting .., DELTA Freq = %d, SWEEP Freq=%d\", delta_freq, swp_freq);\n\t\t\tif (abs(state->frequency * 1000 - swp_freq) > 3800) {\n\t\t\t\tdprintk(verbose, MB86A16_INFO, 1, \"NO  --  SIGNAL !\");\n\t\t\t} else {\n\n\t\t\t\tS1T = 0;\n\t\t\t\tS0T = 3;\n\t\t\t\tCREN = 1;\n\t\t\t\tAFCEN = 0;\n\t\t\t\tAFCEXEN = 1;\n\n\t\t\t\tif (S01T_set(state, S1T, S0T) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"S01T set error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (DAGC_data_set(state, 0, 0) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"DAGC data set error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tR = vco_dev_get(state, state->srate);\n\t\t\t\tsmrt_info_get(state, state->srate);\n\t\t\t\tif (smrt_set(state, state->srate) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"smrt set error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (EN_set(state, CREN, AFCEN) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"EN set error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (AFCEXEN_set(state, AFCEXEN, state->srate) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"AFCEXEN set error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tswp_info_get2(state, state->srate, R, swp_freq, &afcex_freq, &fOSC, &AFCEX_L, &AFCEX_H);\n\t\t\t\tif (rf_val_set(state, fOSC, state->srate, R) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"rf val set error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (afcex_data_set(state, AFCEX_L, AFCEX_H) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"afcex data set error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (srst(state) < 0) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"srst error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\twait_t = 7 + (10000 + state->srate / 2) / state->srate;\n\t\t\t\tif (wait_t == 0)\n\t\t\t\t\twait_t = 1;\n\t\t\t\tmsleep_interruptible(wait_t);\n\t\t\t\tif (mb86a16_read(state, 0x37, &SIG1) != 2) {\n\t\t\t\t\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t\t\t\t\treturn -EREMOTEIO;\n\t\t\t\t}\n\n\t\t\t\tif (SIG1 > 110) {\n\t\t\t\t\tS2T = 4; S4T = 1; S5T = 6; ETH = 4; VIA = 6;\n\t\t\t\t\twait_t = 7 + (917504 + state->srate / 2) / state->srate;\n\t\t\t\t} else if (SIG1 > 105) {\n\t\t\t\t\tS2T = 4; S4T = 2; S5T = 8; ETH = 7; VIA = 2;\n\t\t\t\t\twait_t = 7 + (1048576 + state->srate / 2) / state->srate;\n\t\t\t\t} else if (SIG1 > 85) {\n\t\t\t\t\tS2T = 5; S4T = 2; S5T = 8; ETH = 7; VIA = 2;\n\t\t\t\t\twait_t = 7 + (1310720 + state->srate / 2) / state->srate;\n\t\t\t\t} else if (SIG1 > 65) {\n\t\t\t\t\tS2T = 6; S4T = 2; S5T = 8; ETH = 7; VIA = 2;\n\t\t\t\t\twait_t = 7 + (1572864 + state->srate / 2) / state->srate;\n\t\t\t\t} else {\n\t\t\t\t\tS2T = 7; S4T = 2; S5T = 8; ETH = 7; VIA = 2;\n\t\t\t\t\twait_t = 7 + (2097152 + state->srate / 2) / state->srate;\n\t\t\t\t}\n\t\t\t\twait_t *= 2;  \n\t\t\t\tS2T_set(state, S2T);\n\t\t\t\tS45T_set(state, S4T, S5T);\n\t\t\t\tVi_set(state, ETH, VIA);\n\t\t\t\tsrst(state);\n\t\t\t\tmsleep_interruptible(wait_t);\n\t\t\t\tsync = sync_chk(state, &VIRM);\n\t\t\t\tdprintk(verbose, MB86A16_INFO, 1, \"-------- Viterbi=[%d] SYNC=[%d] ---------\", VIRM, sync);\n\t\t\t\tif (VIRM) {\n\t\t\t\t\tif (VIRM == 4) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (SIG1 > 110)\n\t\t\t\t\t\t\twait_t = (786432 + state->srate / 2) / state->srate;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twait_t = (1572864 + state->srate / 2) / state->srate;\n\n\t\t\t\t\t\tmsleep_interruptible(wait_t);\n\n\t\t\t\t\t\tif (sync_chk(state, &junk) == 0) {\n\t\t\t\t\t\t\tiq_vt_set(state, 1);\n\t\t\t\t\t\t\tFEC_srst(state);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t \n\t\t\t\t\tif (SIG1 > 110)\n\t\t\t\t\t\twait_t = (786432 + state->srate / 2) / state->srate;\n\t\t\t\t\telse\n\t\t\t\t\t\twait_t = (1572864 + state->srate / 2) / state->srate;\n\t\t\t\t\tmsleep_interruptible(wait_t);\n\t\t\t\t\tSEQ_set(state, 1);\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(verbose, MB86A16_INFO, 1, \"NO  -- SYNC\");\n\t\t\t\t\tSEQ_set(state, 1);\n\t\t\t\t\tret = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdprintk(verbose, MB86A16_INFO, 1, \"NO  -- SIGNAL\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tsync = sync_chk(state, &junk);\n\t\tif (sync) {\n\t\t\tdprintk(verbose, MB86A16_INFO, 1, \"******* SYNC *******\");\n\t\t\tfreqerr_chk(state, state->frequency, state->srate, 1);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (mb86a16_read(state, 0x15, &agcval) != 2 ||\tmb86a16_read(state, 0x26, &cnmval) != 2) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t\tret = -EREMOTEIO;\n\t} else {\n\t\tdprintk(verbose, MB86A16_INFO, 1, \"AGC = %02x CNM = %02x\", agcval, cnmval);\n\t}\n\treturn ret;\n}\n\nstatic int mb86a16_send_diseqc_msg(struct dvb_frontend *fe,\n\t\t\t\t   struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct mb86a16_state *state = fe->demodulator_priv;\n\tint ret = -EREMOTEIO;\n\tint i;\n\tu8 regs;\n\n\tif (mb86a16_write(state, MB86A16_DCC1, MB86A16_DCC1_DISTA) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_DCCOUT, 0x00) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_TONEOUT2, 0x04) < 0)\n\t\tgoto err;\n\n\tregs = 0x18;\n\n\tif (cmd->msg_len > 5 || cmd->msg_len < 4) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < cmd->msg_len; i++) {\n\t\tif (mb86a16_write(state, regs, cmd->msg[i]) < 0)\n\t\t\tgoto err;\n\n\t\tregs++;\n\t}\n\ti += 0x90;\n\n\tmsleep_interruptible(10);\n\n\tif (mb86a16_write(state, MB86A16_DCC1, i) < 0)\n\t\tgoto err;\n\tif (mb86a16_write(state, MB86A16_DCCOUT, MB86A16_DCCOUT_DISEN) < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn ret;\n}\n\nstatic int mb86a16_send_diseqc_burst(struct dvb_frontend *fe,\n\t\t\t\t     enum fe_sec_mini_cmd burst)\n{\n\tstruct mb86a16_state *state = fe->demodulator_priv;\n\n\tswitch (burst) {\n\tcase SEC_MINI_A:\n\t\tif (mb86a16_write(state, MB86A16_DCC1, MB86A16_DCC1_DISTA |\n\t\t\t\t\t\t       MB86A16_DCC1_TBEN  |\n\t\t\t\t\t\t       MB86A16_DCC1_TBO) < 0)\n\t\t\tgoto err;\n\t\tif (mb86a16_write(state, MB86A16_DCCOUT, MB86A16_DCCOUT_DISEN) < 0)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase SEC_MINI_B:\n\t\tif (mb86a16_write(state, MB86A16_DCC1, MB86A16_DCC1_DISTA |\n\t\t\t\t\t\t       MB86A16_DCC1_TBEN) < 0)\n\t\t\tgoto err;\n\t\tif (mb86a16_write(state, MB86A16_DCCOUT, MB86A16_DCCOUT_DISEN) < 0)\n\t\t\tgoto err;\n\t\tbreak;\n\t}\n\n\treturn 0;\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic int mb86a16_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\n{\n\tstruct mb86a16_state *state = fe->demodulator_priv;\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\tif (mb86a16_write(state, MB86A16_TONEOUT2, 0x00) < 0)\n\t\t\tgoto err;\n\t\tif (mb86a16_write(state, MB86A16_DCC1, MB86A16_DCC1_DISTA |\n\t\t\t\t\t\t       MB86A16_DCC1_CTOE) < 0)\n\n\t\t\tgoto err;\n\t\tif (mb86a16_write(state, MB86A16_DCCOUT, MB86A16_DCCOUT_DISEN) < 0)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase SEC_TONE_OFF:\n\t\tif (mb86a16_write(state, MB86A16_TONEOUT2, 0x04) < 0)\n\t\t\tgoto err;\n\t\tif (mb86a16_write(state, MB86A16_DCC1, MB86A16_DCC1_DISTA) < 0)\n\t\t\tgoto err;\n\t\tif (mb86a16_write(state, MB86A16_DCCOUT, 0x00) < 0)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic enum dvbfe_search mb86a16_search(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct mb86a16_state *state = fe->demodulator_priv;\n\n\tstate->frequency = p->frequency / 1000;\n\tstate->srate = p->symbol_rate / 1000;\n\n\tif (!mb86a16_set_fe(state)) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"Successfully acquired LOCK\");\n\t\treturn DVBFE_ALGO_SEARCH_SUCCESS;\n\t}\n\n\tdprintk(verbose, MB86A16_ERROR, 1, \"Lock acquisition failed!\");\n\treturn DVBFE_ALGO_SEARCH_FAILED;\n}\n\nstatic void mb86a16_release(struct dvb_frontend *fe)\n{\n\tstruct mb86a16_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic int mb86a16_init(struct dvb_frontend *fe)\n{\n\treturn 0;\n}\n\nstatic int mb86a16_sleep(struct dvb_frontend *fe)\n{\n\treturn 0;\n}\n\nstatic int mb86a16_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tu8 ber_mon, ber_tab, ber_lsb, ber_mid, ber_msb, ber_tim, ber_rst;\n\tu32 timer;\n\n\tstruct mb86a16_state *state = fe->demodulator_priv;\n\n\t*ber = 0;\n\tif (mb86a16_read(state, MB86A16_BERMON, &ber_mon) != 2)\n\t\tgoto err;\n\tif (mb86a16_read(state, MB86A16_BERTAB, &ber_tab) != 2)\n\t\tgoto err;\n\tif (mb86a16_read(state, MB86A16_BERLSB, &ber_lsb) != 2)\n\t\tgoto err;\n\tif (mb86a16_read(state, MB86A16_BERMID, &ber_mid) != 2)\n\t\tgoto err;\n\tif (mb86a16_read(state, MB86A16_BERMSB, &ber_msb) != 2)\n\t\tgoto err;\n\t \n\tif (ber_mon & 0x04) {\n\t\t \n\t\t*ber = ber_tab & 0x1f;\n\t\tdprintk(verbose, MB86A16_DEBUG, 1, \"BER coarse=[0x%02x]\", *ber);\n\t\tif (ber_mon & 0x01) {\n\t\t\t \n\t\t\tber_rst = (ber_mon >> 3) & 0x03;\n\t\t\t*ber = (((ber_msb << 8) | ber_mid) << 8) | ber_lsb;\n\t\t\tif (ber_rst == 0)\n\t\t\t\ttimer =  12500000;\n\t\t\telse if (ber_rst == 1)\n\t\t\t\ttimer =  25000000;\n\t\t\telse if (ber_rst == 2)\n\t\t\t\ttimer =  50000000;\n\t\t\telse  \n\t\t\t\ttimer = 100000000;\n\n\t\t\t*ber /= timer;\n\t\t\tdprintk(verbose, MB86A16_DEBUG, 1, \"BER fine=[0x%02x]\", *ber);\n\t\t} else {\n\t\t\t \n\t\t\tber_tim = (ber_mon >> 1) & 0x01;\n\t\t\t*ber = (((ber_msb << 8) | ber_mid) << 8) | ber_lsb;\n\t\t\tif (ber_tim == 0)\n\t\t\t\ttimer = 16;\n\t\t\telse  \n\t\t\t\ttimer = 24;\n\n\t\t\t*ber /= 2 ^ timer;\n\t\t\tdprintk(verbose, MB86A16_DEBUG, 1, \"BER fine=[0x%02x]\", *ber);\n\t\t}\n\t}\n\treturn 0;\nerr:\n\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\treturn -EREMOTEIO;\n}\n\nstatic int mb86a16_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tu8 agcm = 0;\n\tstruct mb86a16_state *state = fe->demodulator_priv;\n\n\t*strength = 0;\n\tif (mb86a16_read(state, MB86A16_AGCM, &agcm) != 2) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\t*strength = ((0xff - agcm) * 100) / 256;\n\tdprintk(verbose, MB86A16_DEBUG, 1, \"Signal strength=[%d %%]\", (u8) *strength);\n\t*strength = (0xffff - 0xff) + agcm;\n\n\treturn 0;\n}\n\nstruct cnr {\n\tu8 cn_reg;\n\tu8 cn_val;\n};\n\nstatic const struct cnr cnr_tab[] = {\n\t{  35,  2 },\n\t{  40,  3 },\n\t{  50,  4 },\n\t{  60,  5 },\n\t{  70,  6 },\n\t{  80,  7 },\n\t{  92,  8 },\n\t{ 103,  9 },\n\t{ 115, 10 },\n\t{ 138, 12 },\n\t{ 162, 15 },\n\t{ 180, 18 },\n\t{ 185, 19 },\n\t{ 189, 20 },\n\t{ 195, 22 },\n\t{ 199, 24 },\n\t{ 201, 25 },\n\t{ 202, 26 },\n\t{ 203, 27 },\n\t{ 205, 28 },\n\t{ 208, 30 }\n};\n\nstatic int mb86a16_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct mb86a16_state *state = fe->demodulator_priv;\n\tint i = 0;\n\tint low_tide = 2, high_tide = 30, q_level;\n\tu8  cn;\n\n\t*snr = 0;\n\tif (mb86a16_read(state, 0x26, &cn) != 2) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(cnr_tab); i++) {\n\t\tif (cn < cnr_tab[i].cn_reg) {\n\t\t\t*snr = cnr_tab[i].cn_val;\n\t\t\tbreak;\n\t\t}\n\t}\n\tq_level = (*snr * 100) / (high_tide - low_tide);\n\tdprintk(verbose, MB86A16_ERROR, 1, \"SNR (Quality) = [%d dB], Level=%d %%\", *snr, q_level);\n\t*snr = (0xffff - 0xff) + *snr;\n\n\treturn 0;\n}\n\nstatic int mb86a16_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tu8 dist;\n\tstruct mb86a16_state *state = fe->demodulator_priv;\n\n\tif (mb86a16_read(state, MB86A16_DISTMON, &dist) != 2) {\n\t\tdprintk(verbose, MB86A16_ERROR, 1, \"I2C transfer error\");\n\t\treturn -EREMOTEIO;\n\t}\n\t*ucblocks = dist;\n\n\treturn 0;\n}\n\nstatic enum dvbfe_algo mb86a16_frontend_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_CUSTOM;\n}\n\nstatic const struct dvb_frontend_ops mb86a16_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name\t\t\t= \"Fujitsu MB86A16 DVB-S\",\n\t\t.frequency_min_hz\t=  950 * MHz,\n\t\t.frequency_max_hz\t= 2150 * MHz,\n\t\t.frequency_stepsize_hz\t=    3 * MHz,\n\t\t.symbol_rate_min\t= 1000000,\n\t\t.symbol_rate_max\t= 45000000,\n\t\t.symbol_rate_tolerance\t= 500,\n\t\t.caps\t\t\t= FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |\n\t\t\t\t\t  FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 |\n\t\t\t\t\t  FE_CAN_FEC_7_8 | FE_CAN_QPSK    |\n\t\t\t\t\t  FE_CAN_FEC_AUTO\n\t},\n\t.release\t\t\t= mb86a16_release,\n\n\t.get_frontend_algo\t\t= mb86a16_frontend_algo,\n\t.search\t\t\t\t= mb86a16_search,\n\t.init\t\t\t\t= mb86a16_init,\n\t.sleep\t\t\t\t= mb86a16_sleep,\n\t.read_status\t\t\t= mb86a16_read_status,\n\n\t.read_ber\t\t\t= mb86a16_read_ber,\n\t.read_signal_strength\t\t= mb86a16_read_signal_strength,\n\t.read_snr\t\t\t= mb86a16_read_snr,\n\t.read_ucblocks\t\t\t= mb86a16_read_ucblocks,\n\n\t.diseqc_send_master_cmd\t\t= mb86a16_send_diseqc_msg,\n\t.diseqc_send_burst\t\t= mb86a16_send_diseqc_burst,\n\t.set_tone\t\t\t= mb86a16_set_tone,\n};\n\nstruct dvb_frontend *mb86a16_attach(const struct mb86a16_config *config,\n\t\t\t\t    struct i2c_adapter *i2c_adap)\n{\n\tu8 dev_id = 0;\n\tstruct mb86a16_state *state = NULL;\n\n\tstate = kmalloc(sizeof(struct mb86a16_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\tstate->config = config;\n\tstate->i2c_adap = i2c_adap;\n\n\tmb86a16_read(state, 0x7f, &dev_id);\n\tif (dev_id != 0xfe)\n\t\tgoto error;\n\n\tmemcpy(&state->frontend.ops, &mb86a16_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\tstate->frontend.ops.set_voltage = state->config->set_voltage;\n\n\treturn &state->frontend;\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(mb86a16_attach);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Manu Abraham\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}