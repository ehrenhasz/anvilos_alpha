{
  "module_name": "dib3000mb.c",
  "hash_id": "756e7ac045d6d38c138ddf2315c5bdc21d1edbc91b8007f595212d7b4bd82d2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/dib3000mb.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"dib3000.h\"\n#include \"dib3000mb_priv.h\"\n\n \n#define DRIVER_VERSION \"0.1\"\n#define DRIVER_DESC \"DiBcom 3000M-B DVB-T demodulator\"\n#define DRIVER_AUTHOR \"Patrick Boettcher, patrick.boettcher@posteo.de\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info,2=xfer,4=setfe,8=getfe (|-able)).\");\n\n#define deb_info(args...) dprintk(0x01, args)\n#define deb_i2c(args...)  dprintk(0x02, args)\n#define deb_srch(args...) dprintk(0x04, args)\n#define deb_info(args...) dprintk(0x01, args)\n#define deb_xfer(args...) dprintk(0x02, args)\n#define deb_setf(args...) dprintk(0x04, args)\n#define deb_getf(args...) dprintk(0x08, args)\n\nstatic int dib3000_read_reg(struct dib3000_state *state, u16 reg)\n{\n\tu8 wb[] = { ((reg >> 8) | 0x80) & 0xff, reg & 0xff };\n\tu8 rb[2];\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->config.demod_address, .flags = 0,        .buf = wb, .len = 2 },\n\t\t{ .addr = state->config.demod_address, .flags = I2C_M_RD, .buf = rb, .len = 2 },\n\t};\n\n\tif (i2c_transfer(state->i2c, msg, 2) != 2)\n\t\tdeb_i2c(\"i2c read error\\n\");\n\n\tdeb_i2c(\"reading i2c bus (reg: %5d 0x%04x, val: %5d 0x%04x)\\n\",reg,reg,\n\t\t\t(rb[0] << 8) | rb[1],(rb[0] << 8) | rb[1]);\n\n\treturn (rb[0] << 8) | rb[1];\n}\n\nstatic int dib3000_write_reg(struct dib3000_state *state, u16 reg, u16 val)\n{\n\tu8 b[] = {\n\t\t(reg >> 8) & 0xff, reg & 0xff,\n\t\t(val >> 8) & 0xff, val & 0xff,\n\t};\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->config.demod_address, .flags = 0, .buf = b, .len = 4 }\n\t};\n\tdeb_i2c(\"writing i2c bus (reg: %5d 0x%04x, val: %5d 0x%04x)\\n\",reg,reg,val,val);\n\n\treturn i2c_transfer(state->i2c,msg, 1) != 1 ? -EREMOTEIO : 0;\n}\n\nstatic int dib3000_search_status(u16 irq,u16 lock)\n{\n\tif (irq & 0x02) {\n\t\tif (lock & 0x01) {\n\t\t\tdeb_srch(\"auto search succeeded\\n\");\n\t\t\treturn 1; \n\t\t} else {\n\t\t\tdeb_srch(\"auto search not successful\\n\");\n\t\t\treturn 0; \n\t\t}\n\t} else if (irq & 0x01)  {\n\t\tdeb_srch(\"auto search failed\\n\");\n\t\treturn 0; \n\t}\n\treturn -1; \n}\n\n \nstatic u16 dib3000_seq[2][2][2] =      \n\t{  \n\t\t{  \n\t\t\t{ 0, 1 },                    \n\t\t\t{ 3, 9 },                    \n\t\t},\n\t\t{\n\t\t\t{ 2, 5 },                    \n\t\t\t{ 6, 11 },                   \n\t\t}\n\t};\n\nstatic int dib3000mb_get_frontend(struct dvb_frontend* fe,\n\t\t\t\t  struct dtv_frontend_properties *c);\n\nstatic int dib3000mb_set_frontend(struct dvb_frontend *fe, int tuner)\n{\n\tstruct dib3000_state* state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tenum fe_code_rate fe_cr = FEC_NONE;\n\tint search_state, seq;\n\n\tif (tuner && fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\n\t\tswitch (c->bandwidth_hz) {\n\t\t\tcase 8000000:\n\t\t\t\twr_foreach(dib3000mb_reg_timing_freq, dib3000mb_timing_freq[2]);\n\t\t\t\twr_foreach(dib3000mb_reg_bandwidth, dib3000mb_bandwidth_8mhz);\n\t\t\t\tbreak;\n\t\t\tcase 7000000:\n\t\t\t\twr_foreach(dib3000mb_reg_timing_freq, dib3000mb_timing_freq[1]);\n\t\t\t\twr_foreach(dib3000mb_reg_bandwidth, dib3000mb_bandwidth_7mhz);\n\t\t\t\tbreak;\n\t\t\tcase 6000000:\n\t\t\t\twr_foreach(dib3000mb_reg_timing_freq, dib3000mb_timing_freq[0]);\n\t\t\t\twr_foreach(dib3000mb_reg_bandwidth, dib3000mb_bandwidth_6mhz);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tdefault:\n\t\t\t\tpr_err(\"unknown bandwidth value.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tdeb_setf(\"bandwidth: %d MHZ\\n\", c->bandwidth_hz / 1000000);\n\t}\n\twr(DIB3000MB_REG_LOCK1_MASK, DIB3000MB_LOCK1_SEARCH_4);\n\n\tswitch (c->transmission_mode) {\n\t\tcase TRANSMISSION_MODE_2K:\n\t\t\tdeb_setf(\"transmission mode: 2k\\n\");\n\t\t\twr(DIB3000MB_REG_FFT, DIB3000_TRANSMISSION_MODE_2K);\n\t\t\tbreak;\n\t\tcase TRANSMISSION_MODE_8K:\n\t\t\tdeb_setf(\"transmission mode: 8k\\n\");\n\t\t\twr(DIB3000MB_REG_FFT, DIB3000_TRANSMISSION_MODE_8K);\n\t\t\tbreak;\n\t\tcase TRANSMISSION_MODE_AUTO:\n\t\t\tdeb_setf(\"transmission mode: auto\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (c->guard_interval) {\n\t\tcase GUARD_INTERVAL_1_32:\n\t\t\tdeb_setf(\"guard 1_32\\n\");\n\t\t\twr(DIB3000MB_REG_GUARD_TIME, DIB3000_GUARD_TIME_1_32);\n\t\t\tbreak;\n\t\tcase GUARD_INTERVAL_1_16:\n\t\t\tdeb_setf(\"guard 1_16\\n\");\n\t\t\twr(DIB3000MB_REG_GUARD_TIME, DIB3000_GUARD_TIME_1_16);\n\t\t\tbreak;\n\t\tcase GUARD_INTERVAL_1_8:\n\t\t\tdeb_setf(\"guard 1_8\\n\");\n\t\t\twr(DIB3000MB_REG_GUARD_TIME, DIB3000_GUARD_TIME_1_8);\n\t\t\tbreak;\n\t\tcase GUARD_INTERVAL_1_4:\n\t\t\tdeb_setf(\"guard 1_4\\n\");\n\t\t\twr(DIB3000MB_REG_GUARD_TIME, DIB3000_GUARD_TIME_1_4);\n\t\t\tbreak;\n\t\tcase GUARD_INTERVAL_AUTO:\n\t\t\tdeb_setf(\"guard auto\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (c->inversion) {\n\t\tcase INVERSION_OFF:\n\t\t\tdeb_setf(\"inversion off\\n\");\n\t\t\twr(DIB3000MB_REG_DDS_INV, DIB3000_DDS_INVERSION_OFF);\n\t\t\tbreak;\n\t\tcase INVERSION_AUTO:\n\t\t\tdeb_setf(\"inversion auto\\n\");\n\t\t\tbreak;\n\t\tcase INVERSION_ON:\n\t\t\tdeb_setf(\"inversion on\\n\");\n\t\t\twr(DIB3000MB_REG_DDS_INV, DIB3000_DDS_INVERSION_ON);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (c->modulation) {\n\t\tcase QPSK:\n\t\t\tdeb_setf(\"modulation: qpsk\\n\");\n\t\t\twr(DIB3000MB_REG_QAM, DIB3000_CONSTELLATION_QPSK);\n\t\t\tbreak;\n\t\tcase QAM_16:\n\t\t\tdeb_setf(\"modulation: qam16\\n\");\n\t\t\twr(DIB3000MB_REG_QAM, DIB3000_CONSTELLATION_16QAM);\n\t\t\tbreak;\n\t\tcase QAM_64:\n\t\t\tdeb_setf(\"modulation: qam64\\n\");\n\t\t\twr(DIB3000MB_REG_QAM, DIB3000_CONSTELLATION_64QAM);\n\t\t\tbreak;\n\t\tcase QAM_AUTO:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\tswitch (c->hierarchy) {\n\t\tcase HIERARCHY_NONE:\n\t\t\tdeb_setf(\"hierarchy: none\\n\");\n\t\t\tfallthrough;\n\t\tcase HIERARCHY_1:\n\t\t\tdeb_setf(\"hierarchy: alpha=1\\n\");\n\t\t\twr(DIB3000MB_REG_VIT_ALPHA, DIB3000_ALPHA_1);\n\t\t\tbreak;\n\t\tcase HIERARCHY_2:\n\t\t\tdeb_setf(\"hierarchy: alpha=2\\n\");\n\t\t\twr(DIB3000MB_REG_VIT_ALPHA, DIB3000_ALPHA_2);\n\t\t\tbreak;\n\t\tcase HIERARCHY_4:\n\t\t\tdeb_setf(\"hierarchy: alpha=4\\n\");\n\t\t\twr(DIB3000MB_REG_VIT_ALPHA, DIB3000_ALPHA_4);\n\t\t\tbreak;\n\t\tcase HIERARCHY_AUTO:\n\t\t\tdeb_setf(\"hierarchy: alpha=auto\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (c->hierarchy == HIERARCHY_NONE) {\n\t\twr(DIB3000MB_REG_VIT_HRCH, DIB3000_HRCH_OFF);\n\t\twr(DIB3000MB_REG_VIT_HP, DIB3000_SELECT_HP);\n\t\tfe_cr = c->code_rate_HP;\n\t} else if (c->hierarchy != HIERARCHY_AUTO) {\n\t\twr(DIB3000MB_REG_VIT_HRCH, DIB3000_HRCH_ON);\n\t\twr(DIB3000MB_REG_VIT_HP, DIB3000_SELECT_LP);\n\t\tfe_cr = c->code_rate_LP;\n\t}\n\tswitch (fe_cr) {\n\t\tcase FEC_1_2:\n\t\t\tdeb_setf(\"fec: 1_2\\n\");\n\t\t\twr(DIB3000MB_REG_VIT_CODE_RATE, DIB3000_FEC_1_2);\n\t\t\tbreak;\n\t\tcase FEC_2_3:\n\t\t\tdeb_setf(\"fec: 2_3\\n\");\n\t\t\twr(DIB3000MB_REG_VIT_CODE_RATE, DIB3000_FEC_2_3);\n\t\t\tbreak;\n\t\tcase FEC_3_4:\n\t\t\tdeb_setf(\"fec: 3_4\\n\");\n\t\t\twr(DIB3000MB_REG_VIT_CODE_RATE, DIB3000_FEC_3_4);\n\t\t\tbreak;\n\t\tcase FEC_5_6:\n\t\t\tdeb_setf(\"fec: 5_6\\n\");\n\t\t\twr(DIB3000MB_REG_VIT_CODE_RATE, DIB3000_FEC_5_6);\n\t\t\tbreak;\n\t\tcase FEC_7_8:\n\t\t\tdeb_setf(\"fec: 7_8\\n\");\n\t\t\twr(DIB3000MB_REG_VIT_CODE_RATE, DIB3000_FEC_7_8);\n\t\t\tbreak;\n\t\tcase FEC_NONE:\n\t\t\tdeb_setf(\"fec: none\\n\");\n\t\t\tbreak;\n\t\tcase FEC_AUTO:\n\t\t\tdeb_setf(\"fec: auto\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tseq = dib3000_seq\n\t\t[c->transmission_mode == TRANSMISSION_MODE_AUTO]\n\t\t[c->guard_interval == GUARD_INTERVAL_AUTO]\n\t\t[c->inversion == INVERSION_AUTO];\n\n\tdeb_setf(\"seq? %d\\n\", seq);\n\n\twr(DIB3000MB_REG_SEQ, seq);\n\n\twr(DIB3000MB_REG_ISI, seq ? DIB3000MB_ISI_INHIBIT : DIB3000MB_ISI_ACTIVATE);\n\n\tif (c->transmission_mode == TRANSMISSION_MODE_2K) {\n\t\tif (c->guard_interval == GUARD_INTERVAL_1_8) {\n\t\t\twr(DIB3000MB_REG_SYNC_IMPROVEMENT, DIB3000MB_SYNC_IMPROVE_2K_1_8);\n\t\t} else {\n\t\t\twr(DIB3000MB_REG_SYNC_IMPROVEMENT, DIB3000MB_SYNC_IMPROVE_DEFAULT);\n\t\t}\n\n\t\twr(DIB3000MB_REG_UNK_121, DIB3000MB_UNK_121_2K);\n\t} else {\n\t\twr(DIB3000MB_REG_UNK_121, DIB3000MB_UNK_121_DEFAULT);\n\t}\n\n\twr(DIB3000MB_REG_MOBILE_ALGO, DIB3000MB_MOBILE_ALGO_OFF);\n\twr(DIB3000MB_REG_MOBILE_MODE_QAM, DIB3000MB_MOBILE_MODE_QAM_OFF);\n\twr(DIB3000MB_REG_MOBILE_MODE, DIB3000MB_MOBILE_MODE_OFF);\n\n\twr_foreach(dib3000mb_reg_agc_bandwidth, dib3000mb_agc_bandwidth_high);\n\n\twr(DIB3000MB_REG_ISI, DIB3000MB_ISI_ACTIVATE);\n\n\twr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_AGC + DIB3000MB_RESTART_CTRL);\n\twr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_OFF);\n\n\t \n\tmsleep(70);\n\n\twr_foreach(dib3000mb_reg_agc_bandwidth, dib3000mb_agc_bandwidth_low);\n\n\t \n\tif (c->modulation == QAM_AUTO ||\n\t\tc->hierarchy == HIERARCHY_AUTO ||\n\t\tfe_cr == FEC_AUTO ||\n\t\tc->inversion == INVERSION_AUTO) {\n\t\tint as_count=0;\n\n\t\tdeb_setf(\"autosearch enabled.\\n\");\n\n\t\twr(DIB3000MB_REG_ISI, DIB3000MB_ISI_INHIBIT);\n\n\t\twr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_AUTO_SEARCH);\n\t\twr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_OFF);\n\n\t\twhile ((search_state =\n\t\t\t\tdib3000_search_status(\n\t\t\t\t\trd(DIB3000MB_REG_AS_IRQ_PENDING),\n\t\t\t\t\trd(DIB3000MB_REG_LOCK2_VALUE))) < 0 && as_count++ < 100)\n\t\t\tmsleep(1);\n\n\t\tdeb_setf(\"search_state after autosearch %d after %d checks\\n\",\n\t\t\t search_state, as_count);\n\n\t\tif (search_state == 1) {\n\t\t\tif (dib3000mb_get_frontend(fe, c) == 0) {\n\t\t\t\tdeb_setf(\"reading tuning data from frontend succeeded.\\n\");\n\t\t\t\treturn dib3000mb_set_frontend(fe, 0);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\twr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_CTRL);\n\t\twr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_OFF);\n\t}\n\n\treturn 0;\n}\n\nstatic int dib3000mb_fe_init(struct dvb_frontend* fe, int mobile_mode)\n{\n\tstruct dib3000_state* state = fe->demodulator_priv;\n\n\tdeb_info(\"dib3000mb is getting up.\\n\");\n\twr(DIB3000MB_REG_POWER_CONTROL, DIB3000MB_POWER_UP);\n\n\twr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_AGC);\n\n\twr(DIB3000MB_REG_RESET_DEVICE, DIB3000MB_RESET_DEVICE);\n\twr(DIB3000MB_REG_RESET_DEVICE, DIB3000MB_RESET_DEVICE_RST);\n\n\twr(DIB3000MB_REG_CLOCK, DIB3000MB_CLOCK_DEFAULT);\n\n\twr(DIB3000MB_REG_ELECT_OUT_MODE, DIB3000MB_ELECT_OUT_MODE_ON);\n\n\twr(DIB3000MB_REG_DDS_FREQ_MSB, DIB3000MB_DDS_FREQ_MSB);\n\twr(DIB3000MB_REG_DDS_FREQ_LSB, DIB3000MB_DDS_FREQ_LSB);\n\n\twr_foreach(dib3000mb_reg_timing_freq, dib3000mb_timing_freq[2]);\n\n\twr_foreach(dib3000mb_reg_impulse_noise,\n\t\t\tdib3000mb_impulse_noise_values[DIB3000MB_IMPNOISE_OFF]);\n\n\twr_foreach(dib3000mb_reg_agc_gain, dib3000mb_default_agc_gain);\n\n\twr(DIB3000MB_REG_PHASE_NOISE, DIB3000MB_PHASE_NOISE_DEFAULT);\n\n\twr_foreach(dib3000mb_reg_phase_noise, dib3000mb_default_noise_phase);\n\n\twr_foreach(dib3000mb_reg_lock_duration, dib3000mb_default_lock_duration);\n\n\twr_foreach(dib3000mb_reg_agc_bandwidth, dib3000mb_agc_bandwidth_low);\n\n\twr(DIB3000MB_REG_LOCK0_MASK, DIB3000MB_LOCK0_DEFAULT);\n\twr(DIB3000MB_REG_LOCK1_MASK, DIB3000MB_LOCK1_SEARCH_4);\n\twr(DIB3000MB_REG_LOCK2_MASK, DIB3000MB_LOCK2_DEFAULT);\n\twr(DIB3000MB_REG_SEQ, dib3000_seq[1][1][1]);\n\n\twr_foreach(dib3000mb_reg_bandwidth, dib3000mb_bandwidth_8mhz);\n\n\twr(DIB3000MB_REG_UNK_68, DIB3000MB_UNK_68);\n\twr(DIB3000MB_REG_UNK_69, DIB3000MB_UNK_69);\n\twr(DIB3000MB_REG_UNK_71, DIB3000MB_UNK_71);\n\twr(DIB3000MB_REG_UNK_77, DIB3000MB_UNK_77);\n\twr(DIB3000MB_REG_UNK_78, DIB3000MB_UNK_78);\n\twr(DIB3000MB_REG_ISI, DIB3000MB_ISI_INHIBIT);\n\twr(DIB3000MB_REG_UNK_92, DIB3000MB_UNK_92);\n\twr(DIB3000MB_REG_UNK_96, DIB3000MB_UNK_96);\n\twr(DIB3000MB_REG_UNK_97, DIB3000MB_UNK_97);\n\twr(DIB3000MB_REG_UNK_106, DIB3000MB_UNK_106);\n\twr(DIB3000MB_REG_UNK_107, DIB3000MB_UNK_107);\n\twr(DIB3000MB_REG_UNK_108, DIB3000MB_UNK_108);\n\twr(DIB3000MB_REG_UNK_122, DIB3000MB_UNK_122);\n\twr(DIB3000MB_REG_MOBILE_MODE_QAM, DIB3000MB_MOBILE_MODE_QAM_OFF);\n\twr(DIB3000MB_REG_BERLEN, DIB3000MB_BERLEN_DEFAULT);\n\n\twr_foreach(dib3000mb_reg_filter_coeffs, dib3000mb_filter_coeffs);\n\n\twr(DIB3000MB_REG_MOBILE_ALGO, DIB3000MB_MOBILE_ALGO_ON);\n\twr(DIB3000MB_REG_MULTI_DEMOD_MSB, DIB3000MB_MULTI_DEMOD_MSB);\n\twr(DIB3000MB_REG_MULTI_DEMOD_LSB, DIB3000MB_MULTI_DEMOD_LSB);\n\n\twr(DIB3000MB_REG_OUTPUT_MODE, DIB3000MB_OUTPUT_MODE_SLAVE);\n\n\twr(DIB3000MB_REG_FIFO_142, DIB3000MB_FIFO_142);\n\twr(DIB3000MB_REG_MPEG2_OUT_MODE, DIB3000MB_MPEG2_OUT_MODE_188);\n\twr(DIB3000MB_REG_PID_PARSE, DIB3000MB_PID_PARSE_ACTIVATE);\n\twr(DIB3000MB_REG_FIFO, DIB3000MB_FIFO_INHIBIT);\n\twr(DIB3000MB_REG_FIFO_146, DIB3000MB_FIFO_146);\n\twr(DIB3000MB_REG_FIFO_147, DIB3000MB_FIFO_147);\n\n\twr(DIB3000MB_REG_DATA_IN_DIVERSITY, DIB3000MB_DATA_DIVERSITY_IN_OFF);\n\n\treturn 0;\n}\n\nstatic int dib3000mb_get_frontend(struct dvb_frontend* fe,\n\t\t\t\t  struct dtv_frontend_properties *c)\n{\n\tstruct dib3000_state* state = fe->demodulator_priv;\n\tenum fe_code_rate *cr;\n\tu16 tps_val;\n\tint inv_test1,inv_test2;\n\tu32 dds_val, threshold = 0x800000;\n\n\tif (!rd(DIB3000MB_REG_TPS_LOCK))\n\t\treturn 0;\n\n\tdds_val = ((rd(DIB3000MB_REG_DDS_VALUE_MSB) & 0xff) << 16) + rd(DIB3000MB_REG_DDS_VALUE_LSB);\n\tdeb_getf(\"DDS_VAL: %x %x %x\\n\", dds_val, rd(DIB3000MB_REG_DDS_VALUE_MSB), rd(DIB3000MB_REG_DDS_VALUE_LSB));\n\tif (dds_val < threshold)\n\t\tinv_test1 = 0;\n\telse if (dds_val == threshold)\n\t\tinv_test1 = 1;\n\telse\n\t\tinv_test1 = 2;\n\n\tdds_val = ((rd(DIB3000MB_REG_DDS_FREQ_MSB) & 0xff) << 16) + rd(DIB3000MB_REG_DDS_FREQ_LSB);\n\tdeb_getf(\"DDS_FREQ: %x %x %x\\n\", dds_val, rd(DIB3000MB_REG_DDS_FREQ_MSB), rd(DIB3000MB_REG_DDS_FREQ_LSB));\n\tif (dds_val < threshold)\n\t\tinv_test2 = 0;\n\telse if (dds_val == threshold)\n\t\tinv_test2 = 1;\n\telse\n\t\tinv_test2 = 2;\n\n\tc->inversion =\n\t\t((inv_test2 == 2) && (inv_test1==1 || inv_test1==0)) ||\n\t\t((inv_test2 == 0) && (inv_test1==1 || inv_test1==2)) ?\n\t\tINVERSION_ON : INVERSION_OFF;\n\n\tdeb_getf(\"inversion %d %d, %d\\n\", inv_test2, inv_test1, c->inversion);\n\n\tswitch ((tps_val = rd(DIB3000MB_REG_TPS_QAM))) {\n\t\tcase DIB3000_CONSTELLATION_QPSK:\n\t\t\tdeb_getf(\"QPSK\\n\");\n\t\t\tc->modulation = QPSK;\n\t\t\tbreak;\n\t\tcase DIB3000_CONSTELLATION_16QAM:\n\t\t\tdeb_getf(\"QAM16\\n\");\n\t\t\tc->modulation = QAM_16;\n\t\t\tbreak;\n\t\tcase DIB3000_CONSTELLATION_64QAM:\n\t\t\tdeb_getf(\"QAM64\\n\");\n\t\t\tc->modulation = QAM_64;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unexpected constellation returned by TPS (%d)\\n\", tps_val);\n\t\t\tbreak;\n\t}\n\tdeb_getf(\"TPS: %d\\n\", tps_val);\n\n\tif (rd(DIB3000MB_REG_TPS_HRCH)) {\n\t\tdeb_getf(\"HRCH ON\\n\");\n\t\tcr = &c->code_rate_LP;\n\t\tc->code_rate_HP = FEC_NONE;\n\t\tswitch ((tps_val = rd(DIB3000MB_REG_TPS_VIT_ALPHA))) {\n\t\t\tcase DIB3000_ALPHA_0:\n\t\t\t\tdeb_getf(\"HIERARCHY_NONE\\n\");\n\t\t\t\tc->hierarchy = HIERARCHY_NONE;\n\t\t\t\tbreak;\n\t\t\tcase DIB3000_ALPHA_1:\n\t\t\t\tdeb_getf(\"HIERARCHY_1\\n\");\n\t\t\t\tc->hierarchy = HIERARCHY_1;\n\t\t\t\tbreak;\n\t\t\tcase DIB3000_ALPHA_2:\n\t\t\t\tdeb_getf(\"HIERARCHY_2\\n\");\n\t\t\t\tc->hierarchy = HIERARCHY_2;\n\t\t\t\tbreak;\n\t\t\tcase DIB3000_ALPHA_4:\n\t\t\t\tdeb_getf(\"HIERARCHY_4\\n\");\n\t\t\t\tc->hierarchy = HIERARCHY_4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_err(\"Unexpected ALPHA value returned by TPS (%d)\\n\", tps_val);\n\t\t\t\tbreak;\n\t\t}\n\t\tdeb_getf(\"TPS: %d\\n\", tps_val);\n\n\t\ttps_val = rd(DIB3000MB_REG_TPS_CODE_RATE_LP);\n\t} else {\n\t\tdeb_getf(\"HRCH OFF\\n\");\n\t\tcr = &c->code_rate_HP;\n\t\tc->code_rate_LP = FEC_NONE;\n\t\tc->hierarchy = HIERARCHY_NONE;\n\n\t\ttps_val = rd(DIB3000MB_REG_TPS_CODE_RATE_HP);\n\t}\n\n\tswitch (tps_val) {\n\t\tcase DIB3000_FEC_1_2:\n\t\t\tdeb_getf(\"FEC_1_2\\n\");\n\t\t\t*cr = FEC_1_2;\n\t\t\tbreak;\n\t\tcase DIB3000_FEC_2_3:\n\t\t\tdeb_getf(\"FEC_2_3\\n\");\n\t\t\t*cr = FEC_2_3;\n\t\t\tbreak;\n\t\tcase DIB3000_FEC_3_4:\n\t\t\tdeb_getf(\"FEC_3_4\\n\");\n\t\t\t*cr = FEC_3_4;\n\t\t\tbreak;\n\t\tcase DIB3000_FEC_5_6:\n\t\t\tdeb_getf(\"FEC_5_6\\n\");\n\t\t\t*cr = FEC_4_5;\n\t\t\tbreak;\n\t\tcase DIB3000_FEC_7_8:\n\t\t\tdeb_getf(\"FEC_7_8\\n\");\n\t\t\t*cr = FEC_7_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unexpected FEC returned by TPS (%d)\\n\", tps_val);\n\t\t\tbreak;\n\t}\n\tdeb_getf(\"TPS: %d\\n\",tps_val);\n\n\tswitch ((tps_val = rd(DIB3000MB_REG_TPS_GUARD_TIME))) {\n\t\tcase DIB3000_GUARD_TIME_1_32:\n\t\t\tdeb_getf(\"GUARD_INTERVAL_1_32\\n\");\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\t\tbreak;\n\t\tcase DIB3000_GUARD_TIME_1_16:\n\t\t\tdeb_getf(\"GUARD_INTERVAL_1_16\\n\");\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_16;\n\t\t\tbreak;\n\t\tcase DIB3000_GUARD_TIME_1_8:\n\t\t\tdeb_getf(\"GUARD_INTERVAL_1_8\\n\");\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\t\tbreak;\n\t\tcase DIB3000_GUARD_TIME_1_4:\n\t\t\tdeb_getf(\"GUARD_INTERVAL_1_4\\n\");\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unexpected Guard Time returned by TPS (%d)\\n\", tps_val);\n\t\t\tbreak;\n\t}\n\tdeb_getf(\"TPS: %d\\n\", tps_val);\n\n\tswitch ((tps_val = rd(DIB3000MB_REG_TPS_FFT))) {\n\t\tcase DIB3000_TRANSMISSION_MODE_2K:\n\t\t\tdeb_getf(\"TRANSMISSION_MODE_2K\\n\");\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\t\tbreak;\n\t\tcase DIB3000_TRANSMISSION_MODE_8K:\n\t\t\tdeb_getf(\"TRANSMISSION_MODE_8K\\n\");\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"unexpected transmission mode return by TPS (%d)\\n\", tps_val);\n\t\t\tbreak;\n\t}\n\tdeb_getf(\"TPS: %d\\n\", tps_val);\n\n\treturn 0;\n}\n\nstatic int dib3000mb_read_status(struct dvb_frontend *fe,\n\t\t\t\t enum fe_status *stat)\n{\n\tstruct dib3000_state* state = fe->demodulator_priv;\n\n\t*stat = 0;\n\n\tif (rd(DIB3000MB_REG_AGC_LOCK))\n\t\t*stat |= FE_HAS_SIGNAL;\n\tif (rd(DIB3000MB_REG_CARRIER_LOCK))\n\t\t*stat |= FE_HAS_CARRIER;\n\tif (rd(DIB3000MB_REG_VIT_LCK))\n\t\t*stat |= FE_HAS_VITERBI;\n\tif (rd(DIB3000MB_REG_TS_SYNC_LOCK))\n\t\t*stat |= (FE_HAS_SYNC | FE_HAS_LOCK);\n\n\tdeb_getf(\"actual status is %2x\\n\",*stat);\n\n\tdeb_getf(\"autoval: tps: %d, qam: %d, hrch: %d, alpha: %d, hp: %d, lp: %d, guard: %d, fft: %d cell: %d\\n\",\n\t\t\trd(DIB3000MB_REG_TPS_LOCK),\n\t\t\trd(DIB3000MB_REG_TPS_QAM),\n\t\t\trd(DIB3000MB_REG_TPS_HRCH),\n\t\t\trd(DIB3000MB_REG_TPS_VIT_ALPHA),\n\t\t\trd(DIB3000MB_REG_TPS_CODE_RATE_HP),\n\t\t\trd(DIB3000MB_REG_TPS_CODE_RATE_LP),\n\t\t\trd(DIB3000MB_REG_TPS_GUARD_TIME),\n\t\t\trd(DIB3000MB_REG_TPS_FFT),\n\t\t\trd(DIB3000MB_REG_TPS_CELL_ID));\n\n\t\n\treturn 0;\n}\n\nstatic int dib3000mb_read_ber(struct dvb_frontend* fe, u32 *ber)\n{\n\tstruct dib3000_state* state = fe->demodulator_priv;\n\n\t*ber = ((rd(DIB3000MB_REG_BER_MSB) << 16) | rd(DIB3000MB_REG_BER_LSB));\n\treturn 0;\n}\n\n \nstatic int dib3000mb_read_signal_strength(struct dvb_frontend* fe, u16 *strength)\n{\n\tstruct dib3000_state* state = fe->demodulator_priv;\n\n\t*strength = rd(DIB3000MB_REG_SIGNAL_POWER) * 0xffff / 0x170;\n\treturn 0;\n}\n\nstatic int dib3000mb_read_snr(struct dvb_frontend* fe, u16 *snr)\n{\n\tstruct dib3000_state* state = fe->demodulator_priv;\n\tshort sigpow = rd(DIB3000MB_REG_SIGNAL_POWER);\n\tint icipow = ((rd(DIB3000MB_REG_NOISE_POWER_MSB) & 0xff) << 16) |\n\t\trd(DIB3000MB_REG_NOISE_POWER_LSB);\n\t*snr = (sigpow << 8) / ((icipow > 0) ? icipow : 1);\n\treturn 0;\n}\n\nstatic int dib3000mb_read_unc_blocks(struct dvb_frontend* fe, u32 *unc)\n{\n\tstruct dib3000_state* state = fe->demodulator_priv;\n\n\t*unc = rd(DIB3000MB_REG_PACKET_ERROR_RATE);\n\treturn 0;\n}\n\nstatic int dib3000mb_sleep(struct dvb_frontend* fe)\n{\n\tstruct dib3000_state* state = fe->demodulator_priv;\n\tdeb_info(\"dib3000mb is going to bed.\\n\");\n\twr(DIB3000MB_REG_POWER_CONTROL, DIB3000MB_POWER_DOWN);\n\treturn 0;\n}\n\nstatic int dib3000mb_fe_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 800;\n\treturn 0;\n}\n\nstatic int dib3000mb_fe_init_nonmobile(struct dvb_frontend* fe)\n{\n\treturn dib3000mb_fe_init(fe, 0);\n}\n\nstatic int dib3000mb_set_frontend_and_tuner(struct dvb_frontend *fe)\n{\n\treturn dib3000mb_set_frontend(fe, 1);\n}\n\nstatic void dib3000mb_release(struct dvb_frontend* fe)\n{\n\tstruct dib3000_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\n \nstatic int dib3000mb_pid_control(struct dvb_frontend *fe,int index, int pid,int onoff)\n{\n\tstruct dib3000_state *state = fe->demodulator_priv;\n\tpid = (onoff ? pid | DIB3000_ACTIVATE_PID_FILTERING : 0);\n\twr(index+DIB3000MB_REG_FIRST_PID,pid);\n\treturn 0;\n}\n\nstatic int dib3000mb_fifo_control(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dib3000_state *state = fe->demodulator_priv;\n\n\tdeb_xfer(\"%s fifo\\n\",onoff ? \"enabling\" : \"disabling\");\n\tif (onoff) {\n\t\twr(DIB3000MB_REG_FIFO, DIB3000MB_FIFO_ACTIVATE);\n\t} else {\n\t\twr(DIB3000MB_REG_FIFO, DIB3000MB_FIFO_INHIBIT);\n\t}\n\treturn 0;\n}\n\nstatic int dib3000mb_pid_parse(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dib3000_state *state = fe->demodulator_priv;\n\tdeb_xfer(\"%s pid parsing\\n\",onoff ? \"enabling\" : \"disabling\");\n\twr(DIB3000MB_REG_PID_PARSE,onoff);\n\treturn 0;\n}\n\nstatic int dib3000mb_tuner_pass_ctrl(struct dvb_frontend *fe, int onoff, u8 pll_addr)\n{\n\tstruct dib3000_state *state = fe->demodulator_priv;\n\tif (onoff) {\n\t\twr(DIB3000MB_REG_TUNER, DIB3000_TUNER_WRITE_ENABLE(pll_addr));\n\t} else {\n\t\twr(DIB3000MB_REG_TUNER, DIB3000_TUNER_WRITE_DISABLE(pll_addr));\n\t}\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops dib3000mb_ops;\n\nstruct dvb_frontend* dib3000mb_attach(const struct dib3000_config* config,\n\t\t\t\t      struct i2c_adapter* i2c, struct dib_fe_xfer_ops *xfer_ops)\n{\n\tstruct dib3000_state* state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct dib3000_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->i2c = i2c;\n\tmemcpy(&state->config,config,sizeof(struct dib3000_config));\n\n\t \n\tif (rd(DIB3000_REG_MANUFACTOR_ID) != DIB3000_I2C_ID_DIBCOM)\n\t\tgoto error;\n\n\tif (rd(DIB3000_REG_DEVICE_ID) != DIB3000MB_DEVICE_ID)\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &dib3000mb_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\t \n\txfer_ops->pid_parse = dib3000mb_pid_parse;\n\txfer_ops->fifo_ctrl = dib3000mb_fifo_control;\n\txfer_ops->pid_ctrl = dib3000mb_pid_control;\n\txfer_ops->tuner_pass_ctrl = dib3000mb_tuner_pass_ctrl;\n\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops dib3000mb_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name\t\t\t= \"DiBcom 3000M-B DVB-T\",\n\t\t.frequency_min_hz\t=  44250 * kHz,\n\t\t.frequency_max_hz\t= 867250 * kHz,\n\t\t.frequency_stepsize_hz\t= 62500,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\t\tFE_CAN_RECOVER |\n\t\t\t\tFE_CAN_HIERARCHY_AUTO,\n\t},\n\n\t.release = dib3000mb_release,\n\n\t.init = dib3000mb_fe_init_nonmobile,\n\t.sleep = dib3000mb_sleep,\n\n\t.set_frontend = dib3000mb_set_frontend_and_tuner,\n\t.get_frontend = dib3000mb_get_frontend,\n\t.get_tune_settings = dib3000mb_fe_get_tune_settings,\n\n\t.read_status = dib3000mb_read_status,\n\t.read_ber = dib3000mb_read_ber,\n\t.read_signal_strength = dib3000mb_read_signal_strength,\n\t.read_snr = dib3000mb_read_snr,\n\t.read_ucblocks = dib3000mb_read_unc_blocks,\n};\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(dib3000mb_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}