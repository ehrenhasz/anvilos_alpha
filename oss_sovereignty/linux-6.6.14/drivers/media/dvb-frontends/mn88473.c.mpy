{
  "module_name": "mn88473.c",
  "hash_id": "a2535bca3de18cb948358fa5e92646eee17eb3beab0863bd32b03d255451ebc1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/mn88473.c",
  "human_readable_source": "\n \n\n#include \"mn88473_priv.h\"\n\nstatic int mn88473_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t     struct dvb_frontend_tune_settings *s)\n{\n\ts->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic int mn88473_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct mn88473_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i;\n\tunsigned int uitmp;\n\tu32 if_frequency;\n\tu8 delivery_system_val, if_val[3], *conf_val_ptr;\n\tu8 reg_bank2_2d_val, reg_bank0_d2_val;\n\n\tdev_dbg(&client->dev,\n\t\t\"delivery_system=%u modulation=%u frequency=%u bandwidth_hz=%u symbol_rate=%u inversion=%d stream_id=%d\\n\",\n\t\tc->delivery_system, c->modulation, c->frequency,\n\t\tc->bandwidth_hz, c->symbol_rate, c->inversion, c->stream_id);\n\n\tif (!dev->active) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tdelivery_system_val = 0x02;\n\t\treg_bank2_2d_val = 0x23;\n\t\treg_bank0_d2_val = 0x2a;\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tdelivery_system_val = 0x03;\n\t\treg_bank2_2d_val = 0x3b;\n\t\treg_bank0_d2_val = 0x29;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tdelivery_system_val = 0x04;\n\t\treg_bank2_2d_val = 0x3b;\n\t\treg_bank0_d2_val = 0x29;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tswitch (c->bandwidth_hz) {\n\t\tcase 6000000:\n\t\t\tconf_val_ptr = \"\\xe9\\x55\\x55\\x1c\\x29\\x1c\\x29\";\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\tconf_val_ptr = \"\\xc8\\x00\\x00\\x17\\x0a\\x17\\x0a\";\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\t\tconf_val_ptr = \"\\xaf\\x00\\x00\\x11\\xec\\x11\\xec\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tconf_val_ptr = \"\\x10\\xab\\x0d\\xae\\x1d\\x9d\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (fe->ops.tuner_ops.get_if_frequency) {\n\t\tret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdev_dbg(&client->dev, \"get_if_frequency=%u\\n\", if_frequency);\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tuitmp = DIV_ROUND_CLOSEST_ULL((u64) if_frequency * 0x1000000, dev->clk);\n\tif_val[0] = (uitmp >> 16) & 0xff;\n\tif_val[1] = (uitmp >>  8) & 0xff;\n\tif_val[2] = (uitmp >>  0) & 0xff;\n\n\tret = regmap_write(dev->regmap[2], 0x05, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0xfb, 0x13);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0xef, 0x13);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0xf9, 0x13);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x00, 0x18);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x01, 0x01);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x02, 0x21);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x03, delivery_system_val);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x0b, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = 0; i < sizeof(if_val); i++) {\n\t\tret = regmap_write(dev->regmap[2], 0x10 + i, if_val[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tfor (i = 0; i < 7; i++) {\n\t\t\tret = regmap_write(dev->regmap[2], 0x13 + i,\n\t\t\t\t\t   conf_val_ptr[i]);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tret = regmap_bulk_write(dev->regmap[1], 0x10, conf_val_ptr, 6);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = regmap_write(dev->regmap[2], 0x2d, reg_bank2_2d_val);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x2e, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x56, 0x0d);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_bulk_write(dev->regmap[0], 0x01,\n\t\t\t\t\"\\xba\\x13\\x80\\xba\\x91\\xdd\\xe7\\x28\", 8);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0x0a, 0x1a);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0x13, 0x1f);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0x19, 0x03);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0x1d, 0xb0);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0x2a, 0x72);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0x2d, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0x3c, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0x3f, 0xf8);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_bulk_write(dev->regmap[0], 0x40, \"\\xf4\\x08\", 2);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0xd2, reg_bank0_d2_val);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0xd4, 0x55);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[1], 0xbe, 0x08);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0xb2, 0x37);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[0], 0xd7, 0x04);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (c->delivery_system == SYS_DVBT2) {\n\t\tret = regmap_write(dev->regmap[2], 0x36,\n\t\t\t\t(c->stream_id == NO_STREAM_ID_FILTER) ? 0 :\n\t\t\t\tc->stream_id );\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tret = regmap_write(dev->regmap[2], 0xf8, 0x9f);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int mn88473_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct mn88473_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i, stmp;\n\tunsigned int utmp, utmp1, utmp2;\n\tu8 buf[5];\n\n\tif (!dev->active) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\t \n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tret = regmap_read(dev->regmap[0], 0x62, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!(utmp & 0xa0)) {\n\t\t\tif ((utmp & 0x0f) >= 0x09)\n\t\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t\t  FE_HAS_VITERBI | FE_HAS_SYNC |\n\t\t\t\t\t  FE_HAS_LOCK;\n\t\t\telse if ((utmp & 0x0f) >= 0x03)\n\t\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\t\t} else {\n\t\t\t*status = 0;\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tret = regmap_read(dev->regmap[2], 0x8b, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!(utmp & 0x40)) {\n\t\t\tif ((utmp & 0x0f) >= 0x0d)\n\t\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t\t  FE_HAS_VITERBI | FE_HAS_SYNC |\n\t\t\t\t\t  FE_HAS_LOCK;\n\t\t\telse if ((utmp & 0x0f) >= 0x0a)\n\t\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t\t  FE_HAS_VITERBI;\n\t\t\telse if ((utmp & 0x0f) >= 0x07)\n\t\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\t\t} else {\n\t\t\t*status = 0;\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tret = regmap_read(dev->regmap[1], 0x85, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!(utmp & 0x40)) {\n\t\t\tret = regmap_read(dev->regmap[1], 0x89, &utmp);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tif (utmp & 0x01)\n\t\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t\t\tFE_HAS_VITERBI | FE_HAS_SYNC |\n\t\t\t\t\t\tFE_HAS_LOCK;\n\t\t} else {\n\t\t\t*status = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif (*status & FE_HAS_SIGNAL) {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tret = regmap_bulk_read(dev->regmap[2], 0x86 + i,\n\t\t\t\t\t       &buf[i], 1);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tutmp1 = buf[0] << 8 | buf[1] << 0 | buf[0] >> 2;\n\t\tdev_dbg(&client->dev, \"strength=%u\\n\", utmp1);\n\n\t\tc->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\t\tc->strength.stat[0].uvalue = utmp1;\n\t} else {\n\t\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (*status & FE_HAS_VITERBI && c->delivery_system == SYS_DVBT) {\n\t\t \n\t\tret = regmap_bulk_read(dev->regmap[0], 0x8f, buf, 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp = buf[0] << 8 | buf[1] << 0;\n\t\tif (utmp) {\n\t\t\t \n\t\t\t \n\t\t\tstmp = div_u64(((u64)80807124 - intlog10(utmp)\n\t\t\t\t\t+ 3355443) * 10000, 1 << 24);\n\t\t\tdev_dbg(&client->dev, \"cnr=%d value=%u\\n\", stmp, utmp);\n\t\t} else {\n\t\t\tstmp = 0;\n\t\t}\n\n\t\tc->cnr.stat[0].svalue = stmp;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t} else if (*status & FE_HAS_VITERBI &&\n\t\t   c->delivery_system == SYS_DVBT2) {\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tret = regmap_bulk_read(dev->regmap[2], 0xb7 + i,\n\t\t\t\t\t       &buf[i], 1);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tutmp = buf[1] << 8 | buf[2] << 0;\n\t\tutmp1 = (buf[0] >> 2) & 0x01;  \n\t\tif (utmp) {\n\t\t\tif (utmp1) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tstmp = div_u64(((u64)70706234 - intlog10(utmp)\n\t\t\t\t\t\t- 10066330) * 10000, 1 << 24);\n\t\t\t\tdev_dbg(&client->dev, \"cnr=%d value=%u MISO\\n\",\n\t\t\t\t\tstmp, utmp);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tstmp = div_u64(((u64)80807124 - intlog10(utmp)\n\t\t\t\t\t\t+ 3355443) * 10000, 1 << 24);\n\t\t\t\tdev_dbg(&client->dev, \"cnr=%d value=%u SISO\\n\",\n\t\t\t\t\tstmp, utmp);\n\t\t\t}\n\t\t} else {\n\t\t\tstmp = 0;\n\t\t}\n\n\t\tc->cnr.stat[0].svalue = stmp;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t} else if (*status & FE_HAS_VITERBI &&\n\t\t   c->delivery_system == SYS_DVBC_ANNEX_A) {\n\t\t \n\t\tret = regmap_bulk_read(dev->regmap[1], 0xa1, buf, 4);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp1 = buf[0] << 8 | buf[1] << 0;  \n\t\tutmp2 = buf[2] << 8 | buf[3] << 0;  \n\t\tif (utmp1 && utmp2) {\n\t\t\t \n\t\t\t \n\t\t\tstmp = div_u64(((u64)15151336 + intlog10(utmp1)\n\t\t\t\t\t- intlog10(utmp2)) * 10000, 1 << 24);\n\t\t\tdev_dbg(&client->dev, \"cnr=%d signal=%u noise=%u\\n\",\n\t\t\t\tstmp, utmp1, utmp2);\n\t\t} else {\n\t\t\tstmp = 0;\n\t\t}\n\n\t\tc->cnr.stat[0].svalue = stmp;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t} else {\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (*status & FE_HAS_LOCK && (c->delivery_system == SYS_DVBT ||\n\t\t\t\t      c->delivery_system == SYS_DVBC_ANNEX_A)) {\n\t\t \n\t\tret = regmap_bulk_read(dev->regmap[0], 0x92, buf, 5);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp1 = buf[0] << 16 | buf[1] << 8 | buf[2] << 0;\n\t\tutmp2 = buf[3] << 8 | buf[4] << 0;\n\t\tutmp2 = utmp2 * 8 * 204;\n\t\tdev_dbg(&client->dev, \"post_bit_error=%u post_bit_count=%u\\n\",\n\t\t\tutmp1, utmp2);\n\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[0].uvalue += utmp1;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[0].uvalue += utmp2;\n\t} else {\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (*status & FE_HAS_LOCK) {\n\t\tret = regmap_bulk_read(dev->regmap[0], 0xdd, buf, 4);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp1 = buf[0] << 8 | buf[1] << 0;\n\t\tutmp2 = buf[2] << 8 | buf[3] << 0;\n\t\tdev_dbg(&client->dev, \"block_error=%u block_count=%u\\n\",\n\t\t\tutmp1, utmp2);\n\n\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_error.stat[0].uvalue += utmp1;\n\t\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_count.stat[0].uvalue += utmp2;\n\t} else {\n\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int mn88473_init(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct mn88473_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, len, remain;\n\tunsigned int uitmp;\n\tconst struct firmware *fw;\n\tconst char *name = MN88473_FIRMWARE;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tret = regmap_read(dev->regmap[0], 0xf5, &uitmp);\n\tif (ret)\n\t\tgoto err;\n\n\tif (!(uitmp & 0x01))\n\t\tgoto warm;\n\n\t \n\tret = request_firmware(&fw, name, &client->dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"firmware file '%s' not found\\n\", name);\n\t\tgoto err;\n\t}\n\n\tdev_info(&client->dev, \"downloading firmware from file '%s'\\n\", name);\n\n\tret = regmap_write(dev->regmap[0], 0xf5, 0x03);\n\tif (ret)\n\t\tgoto err_release_firmware;\n\n\tfor (remain = fw->size; remain > 0; remain -= (dev->i2c_wr_max - 1)) {\n\t\tlen = min(dev->i2c_wr_max - 1, remain);\n\t\tret = regmap_bulk_write(dev->regmap[0], 0xf6,\n\t\t\t\t\t&fw->data[fw->size - remain], len);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"firmware download failed %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_release_firmware;\n\t\t}\n\t}\n\n\trelease_firmware(fw);\n\n\t \n\tret = regmap_read(dev->regmap[0], 0xf8, &uitmp);\n\tif (ret)\n\t\tgoto err;\n\n\tif (uitmp & 0x10) {\n\t\tdev_err(&client->dev, \"firmware parity check failed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = regmap_write(dev->regmap[0], 0xf5, 0x00);\n\tif (ret)\n\t\tgoto err;\nwarm:\n\t \n\tret = regmap_write(dev->regmap[2], 0x09, 0x08);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap[2], 0x08, 0x1d);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->active = true;\n\n\t \n\tc->strength.len = 1;\n\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->cnr.len = 1;\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.len = 1;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_error.len = 1;\n\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_count.len = 1;\n\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\treturn 0;\nerr_release_firmware:\n\trelease_firmware(fw);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int mn88473_sleep(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct mn88473_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tdev->active = false;\n\n\tret = regmap_write(dev->regmap[2], 0x05, 0x3e);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dvb_frontend_ops mn88473_ops = {\n\t.delsys = {SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A},\n\t.info = {\n\t\t.name = \"Panasonic MN88473\",\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 7200000,\n\t\t.caps =\tFE_CAN_FEC_1_2                 |\n\t\t\tFE_CAN_FEC_2_3                 |\n\t\t\tFE_CAN_FEC_3_4                 |\n\t\t\tFE_CAN_FEC_5_6                 |\n\t\t\tFE_CAN_FEC_7_8                 |\n\t\t\tFE_CAN_FEC_AUTO                |\n\t\t\tFE_CAN_QPSK                    |\n\t\t\tFE_CAN_QAM_16                  |\n\t\t\tFE_CAN_QAM_32                  |\n\t\t\tFE_CAN_QAM_64                  |\n\t\t\tFE_CAN_QAM_128                 |\n\t\t\tFE_CAN_QAM_256                 |\n\t\t\tFE_CAN_QAM_AUTO                |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO  |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO     |\n\t\t\tFE_CAN_HIERARCHY_AUTO          |\n\t\t\tFE_CAN_MUTE_TS                 |\n\t\t\tFE_CAN_2G_MODULATION           |\n\t\t\tFE_CAN_MULTISTREAM\n\t},\n\n\t.get_tune_settings = mn88473_get_tune_settings,\n\n\t.init = mn88473_init,\n\t.sleep = mn88473_sleep,\n\n\t.set_frontend = mn88473_set_frontend,\n\n\t.read_status = mn88473_read_status,\n};\n\nstatic int mn88473_probe(struct i2c_client *client)\n{\n\tstruct mn88473_config *config = client->dev.platform_data;\n\tstruct mn88473_dev *dev;\n\tint ret;\n\tunsigned int uitmp;\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t};\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tif (config->fe == NULL) {\n\t\tdev_err(&client->dev, \"frontend pointer not defined\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tif (config->i2c_wr_max)\n\t\tdev->i2c_wr_max = config->i2c_wr_max;\n\telse\n\t\tdev->i2c_wr_max = ~0;\n\n\tif (config->xtal)\n\t\tdev->clk = config->xtal;\n\telse\n\t\tdev->clk = 25000000;\n\tdev->client[0] = client;\n\tdev->regmap[0] = regmap_init_i2c(dev->client[0], &regmap_config);\n\tif (IS_ERR(dev->regmap[0])) {\n\t\tret = PTR_ERR(dev->regmap[0]);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tdev->client[1] = i2c_new_dummy_device(client->adapter, 0x1a);\n\tif (IS_ERR(dev->client[1])) {\n\t\tret = PTR_ERR(dev->client[1]);\n\t\tdev_err(&client->dev, \"I2C registration failed\\n\");\n\t\tgoto err_regmap_0_regmap_exit;\n\t}\n\tdev->regmap[1] = regmap_init_i2c(dev->client[1], &regmap_config);\n\tif (IS_ERR(dev->regmap[1])) {\n\t\tret = PTR_ERR(dev->regmap[1]);\n\t\tgoto err_client_1_i2c_unregister_device;\n\t}\n\ti2c_set_clientdata(dev->client[1], dev);\n\n\tdev->client[2] = i2c_new_dummy_device(client->adapter, 0x1c);\n\tif (IS_ERR(dev->client[2])) {\n\t\tret = PTR_ERR(dev->client[2]);\n\t\tdev_err(&client->dev, \"2nd I2C registration failed\\n\");\n\t\tgoto err_regmap_1_regmap_exit;\n\t}\n\tdev->regmap[2] = regmap_init_i2c(dev->client[2], &regmap_config);\n\tif (IS_ERR(dev->regmap[2])) {\n\t\tret = PTR_ERR(dev->regmap[2]);\n\t\tgoto err_client_2_i2c_unregister_device;\n\t}\n\ti2c_set_clientdata(dev->client[2], dev);\n\n\t \n\tret = regmap_read(dev->regmap[2], 0xff, &uitmp);\n\tif (ret)\n\t\tgoto err_regmap_2_regmap_exit;\n\n\tdev_dbg(&client->dev, \"chip id=%02x\\n\", uitmp);\n\n\tif (uitmp != 0x03) {\n\t\tret = -ENODEV;\n\t\tgoto err_regmap_2_regmap_exit;\n\t}\n\n\t \n\tret = regmap_write(dev->regmap[2], 0x05, 0x3e);\n\tif (ret)\n\t\tgoto err_regmap_2_regmap_exit;\n\n\t \n\tmemcpy(&dev->frontend.ops, &mn88473_ops, sizeof(dev->frontend.ops));\n\tdev->frontend.demodulator_priv = client;\n\t*config->fe = &dev->frontend;\n\ti2c_set_clientdata(client, dev);\n\n\tdev_info(&client->dev, \"Panasonic MN88473 successfully identified\\n\");\n\n\treturn 0;\nerr_regmap_2_regmap_exit:\n\tregmap_exit(dev->regmap[2]);\nerr_client_2_i2c_unregister_device:\n\ti2c_unregister_device(dev->client[2]);\nerr_regmap_1_regmap_exit:\n\tregmap_exit(dev->regmap[1]);\nerr_client_1_i2c_unregister_device:\n\ti2c_unregister_device(dev->client[1]);\nerr_regmap_0_regmap_exit:\n\tregmap_exit(dev->regmap[0]);\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void mn88473_remove(struct i2c_client *client)\n{\n\tstruct mn88473_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tregmap_exit(dev->regmap[2]);\n\ti2c_unregister_device(dev->client[2]);\n\n\tregmap_exit(dev->regmap[1]);\n\ti2c_unregister_device(dev->client[1]);\n\n\tregmap_exit(dev->regmap[0]);\n\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id mn88473_id_table[] = {\n\t{\"mn88473\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, mn88473_id_table);\n\nstatic struct i2c_driver mn88473_driver = {\n\t.driver = {\n\t\t.name\t\t     = \"mn88473\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= mn88473_probe,\n\t.remove\t\t= mn88473_remove,\n\t.id_table\t= mn88473_id_table,\n};\n\nmodule_i2c_driver(mn88473_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Panasonic MN88473 DVB-T/T2/C demodulator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(MN88473_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}