{
  "module_name": "tda10048.c",
  "hash_id": "baa285c09fb02c4ea108d65f71ef670034cf2af4c9e19c5c861be04ec2f0d4f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tda10048.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/math64.h>\n#include <asm/div64.h>\n#include <media/dvb_frontend.h>\n#include <linux/int_log.h>\n#include \"tda10048.h\"\n\n#define TDA10048_DEFAULT_FIRMWARE \"dvb-fe-tda10048-1.0.fw\"\n#define TDA10048_DEFAULT_FIRMWARE_SIZE 24878\n\n \n#define TDA10048_IDENTITY          0x00\n#define TDA10048_VERSION           0x01\n#define TDA10048_DSP_CODE_CPT      0x0C\n#define TDA10048_DSP_CODE_IN       0x0E\n#define TDA10048_IN_CONF1          0x10\n#define TDA10048_IN_CONF2          0x11\n#define TDA10048_IN_CONF3          0x12\n#define TDA10048_OUT_CONF1         0x14\n#define TDA10048_OUT_CONF2         0x15\n#define TDA10048_OUT_CONF3         0x16\n#define TDA10048_AUTO              0x18\n#define TDA10048_SYNC_STATUS       0x1A\n#define TDA10048_CONF_C4_1         0x1E\n#define TDA10048_CONF_C4_2         0x1F\n#define TDA10048_CODE_IN_RAM       0x20\n#define TDA10048_CHANNEL_INFO1_R   0x22\n#define TDA10048_CHANNEL_INFO2_R   0x23\n#define TDA10048_CHANNEL_INFO1     0x24\n#define TDA10048_CHANNEL_INFO2     0x25\n#define TDA10048_TIME_ERROR_R      0x26\n#define TDA10048_TIME_ERROR        0x27\n#define TDA10048_FREQ_ERROR_LSB_R  0x28\n#define TDA10048_FREQ_ERROR_MSB_R  0x29\n#define TDA10048_FREQ_ERROR_LSB    0x2A\n#define TDA10048_FREQ_ERROR_MSB    0x2B\n#define TDA10048_IT_SEL            0x30\n#define TDA10048_IT_STAT           0x32\n#define TDA10048_DSP_AD_LSB        0x3C\n#define TDA10048_DSP_AD_MSB        0x3D\n#define TDA10048_DSP_REG_LSB       0x3E\n#define TDA10048_DSP_REG_MSB       0x3F\n#define TDA10048_CONF_TRISTATE1    0x44\n#define TDA10048_CONF_TRISTATE2    0x45\n#define TDA10048_CONF_POLARITY     0x46\n#define TDA10048_GPIO_SP_DS0       0x48\n#define TDA10048_GPIO_SP_DS1       0x49\n#define TDA10048_GPIO_SP_DS2       0x4A\n#define TDA10048_GPIO_SP_DS3       0x4B\n#define TDA10048_GPIO_OUT_SEL      0x4C\n#define TDA10048_GPIO_SELECT       0x4D\n#define TDA10048_IC_MODE           0x4E\n#define TDA10048_CONF_XO           0x50\n#define TDA10048_CONF_PLL1         0x51\n#define TDA10048_CONF_PLL2         0x52\n#define TDA10048_CONF_PLL3         0x53\n#define TDA10048_CONF_ADC          0x54\n#define TDA10048_CONF_ADC_2        0x55\n#define TDA10048_CONF_C1_1         0x60\n#define TDA10048_CONF_C1_3         0x62\n#define TDA10048_AGC_CONF          0x70\n#define TDA10048_AGC_THRESHOLD_LSB 0x72\n#define TDA10048_AGC_THRESHOLD_MSB 0x73\n#define TDA10048_AGC_RENORM        0x74\n#define TDA10048_AGC_GAINS         0x76\n#define TDA10048_AGC_TUN_MIN       0x78\n#define TDA10048_AGC_TUN_MAX       0x79\n#define TDA10048_AGC_IF_MIN        0x7A\n#define TDA10048_AGC_IF_MAX        0x7B\n#define TDA10048_AGC_TUN_LEVEL     0x7E\n#define TDA10048_AGC_IF_LEVEL      0x7F\n#define TDA10048_DIG_AGC_LEVEL     0x81\n#define TDA10048_FREQ_PHY2_LSB     0x86\n#define TDA10048_FREQ_PHY2_MSB     0x87\n#define TDA10048_TIME_INVWREF_LSB  0x88\n#define TDA10048_TIME_INVWREF_MSB  0x89\n#define TDA10048_TIME_WREF_LSB     0x8A\n#define TDA10048_TIME_WREF_MID1    0x8B\n#define TDA10048_TIME_WREF_MID2    0x8C\n#define TDA10048_TIME_WREF_MSB     0x8D\n#define TDA10048_NP_OUT            0xA2\n#define TDA10048_CELL_ID_LSB       0xA4\n#define TDA10048_CELL_ID_MSB       0xA5\n#define TDA10048_EXTTPS_ODD        0xAA\n#define TDA10048_EXTTPS_EVEN       0xAB\n#define TDA10048_TPS_LENGTH        0xAC\n#define TDA10048_FREE_REG_1        0xB2\n#define TDA10048_FREE_REG_2        0xB3\n#define TDA10048_CONF_C3_1         0xC0\n#define TDA10048_CVBER_CTRL        0xC2\n#define TDA10048_CBER_NMAX_LSB     0xC4\n#define TDA10048_CBER_NMAX_MSB     0xC5\n#define TDA10048_CBER_LSB          0xC6\n#define TDA10048_CBER_MSB          0xC7\n#define TDA10048_VBER_LSB          0xC8\n#define TDA10048_VBER_MID          0xC9\n#define TDA10048_VBER_MSB          0xCA\n#define TDA10048_CVBER_LUT         0xCC\n#define TDA10048_UNCOR_CTRL        0xCD\n#define TDA10048_UNCOR_CPT_LSB     0xCE\n#define TDA10048_UNCOR_CPT_MSB     0xCF\n#define TDA10048_SOFT_IT_C3        0xD6\n#define TDA10048_CONF_TS2          0xE0\n#define TDA10048_CONF_TS1          0xE1\n\nstatic unsigned int debug;\n\n#define dprintk(level, fmt, arg...)\\\n\tdo { if (debug >= level)\\\n\t\tprintk(KERN_DEBUG \"tda10048: \" fmt, ## arg);\\\n\t} while (0)\n\nstruct tda10048_state {\n\n\tstruct i2c_adapter *i2c;\n\n\t \n\tstruct tda10048_config config;\n\tstruct dvb_frontend frontend;\n\n\tint fwloaded;\n\n\tu32 freq_if_hz;\n\tu32 xtal_hz;\n\tu32 pll_mfactor;\n\tu32 pll_nfactor;\n\tu32 pll_pfactor;\n\tu32 sample_freq;\n\n\tu32 bandwidth;\n};\n\nstatic struct init_tab {\n\tu8\treg;\n\tu16\tdata;\n} init_tab[] = {\n\t{ TDA10048_CONF_PLL1, 0x08 },\n\t{ TDA10048_CONF_ADC_2, 0x00 },\n\t{ TDA10048_CONF_C4_1, 0x00 },\n\t{ TDA10048_CONF_PLL1, 0x0f },\n\t{ TDA10048_CONF_PLL2, 0x0a },\n\t{ TDA10048_CONF_PLL3, 0x43 },\n\t{ TDA10048_FREQ_PHY2_LSB, 0x02 },\n\t{ TDA10048_FREQ_PHY2_MSB, 0x0a },\n\t{ TDA10048_TIME_WREF_LSB, 0xbd },\n\t{ TDA10048_TIME_WREF_MID1, 0xe4 },\n\t{ TDA10048_TIME_WREF_MID2, 0xa8 },\n\t{ TDA10048_TIME_WREF_MSB, 0x02 },\n\t{ TDA10048_TIME_INVWREF_LSB, 0x04 },\n\t{ TDA10048_TIME_INVWREF_MSB, 0x06 },\n\t{ TDA10048_CONF_C4_1, 0x00 },\n\t{ TDA10048_CONF_C1_1, 0xa8 },\n\t{ TDA10048_AGC_CONF, 0x16 },\n\t{ TDA10048_CONF_C1_3, 0x0b },\n\t{ TDA10048_AGC_TUN_MIN, 0x00 },\n\t{ TDA10048_AGC_TUN_MAX, 0xff },\n\t{ TDA10048_AGC_IF_MIN, 0x00 },\n\t{ TDA10048_AGC_IF_MAX, 0xff },\n\t{ TDA10048_AGC_THRESHOLD_MSB, 0x00 },\n\t{ TDA10048_AGC_THRESHOLD_LSB, 0x70 },\n\t{ TDA10048_CVBER_CTRL, 0x38 },\n\t{ TDA10048_AGC_GAINS, 0x12 },\n\t{ TDA10048_CONF_XO, 0x00 },\n\t{ TDA10048_CONF_TS1, 0x07 },\n\t{ TDA10048_IC_MODE, 0x00 },\n\t{ TDA10048_CONF_TS2, 0xc0 },\n\t{ TDA10048_CONF_TRISTATE1, 0x21 },\n\t{ TDA10048_CONF_TRISTATE2, 0x00 },\n\t{ TDA10048_CONF_POLARITY, 0x00 },\n\t{ TDA10048_CONF_C4_2, 0x04 },\n\t{ TDA10048_CONF_ADC, 0x60 },\n\t{ TDA10048_CONF_ADC_2, 0x10 },\n\t{ TDA10048_CONF_ADC, 0x60 },\n\t{ TDA10048_CONF_ADC_2, 0x00 },\n\t{ TDA10048_CONF_C1_1, 0xa8 },\n\t{ TDA10048_UNCOR_CTRL, 0x00 },\n\t{ TDA10048_CONF_C4_2, 0x04 },\n};\n\nstatic struct pll_tab {\n\tu32\tclk_freq_khz;\n\tu32\tif_freq_khz;\n} pll_tab[] = {\n\t{ TDA10048_CLK_4000,  TDA10048_IF_36130 },\n\t{ TDA10048_CLK_16000, TDA10048_IF_3300 },\n\t{ TDA10048_CLK_16000, TDA10048_IF_3500 },\n\t{ TDA10048_CLK_16000, TDA10048_IF_3800 },\n\t{ TDA10048_CLK_16000, TDA10048_IF_4000 },\n\t{ TDA10048_CLK_16000, TDA10048_IF_4300 },\n\t{ TDA10048_CLK_16000, TDA10048_IF_4500 },\n\t{ TDA10048_CLK_16000, TDA10048_IF_5000 },\n\t{ TDA10048_CLK_16000, TDA10048_IF_36130 },\n};\n\nstatic int tda10048_writereg(struct tda10048_state *state, u8 reg, u8 data)\n{\n\tstruct tda10048_config *config = &state->config;\n\tint ret;\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = {\n\t\t.addr = config->demod_address,\n\t\t.flags = 0, .buf = buf, .len = 2 };\n\n\tdprintk(2, \"%s(reg = 0x%02x, data = 0x%02x)\\n\", __func__, reg, data);\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tprintk(\"%s: writereg error (ret == %i)\\n\", __func__, ret);\n\n\treturn (ret != 1) ? -1 : 0;\n}\n\nstatic u8 tda10048_readreg(struct tda10048_state *state, u8 reg)\n{\n\tstruct tda10048_config *config = &state->config;\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = config->demod_address,\n\t\t\t.flags = 0, .buf = b0, .len = 1 },\n\t\t{ .addr = config->demod_address,\n\t\t\t.flags = I2C_M_RD, .buf = b1, .len = 1 } };\n\n\tdprintk(2, \"%s(reg = 0x%02x)\\n\", __func__, reg);\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tprintk(KERN_ERR \"%s: readreg error (ret == %i)\\n\",\n\t\t\t__func__, ret);\n\n\treturn b1[0];\n}\n\nstatic int tda10048_writeregbulk(struct tda10048_state *state, u8 reg,\n\t\t\t\t const u8 *data, u16 len)\n{\n\tstruct tda10048_config *config = &state->config;\n\tint ret = -EREMOTEIO;\n\tstruct i2c_msg msg;\n\tu8 *buf;\n\n\tdprintk(2, \"%s(%d, ?, len = %d)\\n\", __func__, reg, len);\n\n\tbuf = kmalloc(len + 1, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t*buf = reg;\n\tmemcpy(buf + 1, data, len);\n\n\tmsg.addr = config->demod_address;\n\tmsg.flags = 0;\n\tmsg.buf = buf;\n\tmsg.len = len + 1;\n\n\tdprintk(2, \"%s():  write len = %d\\n\",\n\t\t__func__, msg.len);\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\tif (ret != 1) {\n\t\tprintk(KERN_ERR \"%s(): writereg error err %i\\n\",\n\t\t\t __func__, ret);\n\t\tret = -EREMOTEIO;\n\t}\n\nerror:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int tda10048_set_phy2(struct dvb_frontend *fe, u32 sample_freq_hz,\n\t\t\t     u32 if_hz)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tu64 t;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (sample_freq_hz == 0)\n\t\treturn -EINVAL;\n\n\tif (if_hz < (sample_freq_hz / 2)) {\n\t\t \n\t\tt = if_hz;\n\t\tt *= 10;\n\t\tt *= 32768;\n\t\tdo_div(t, sample_freq_hz);\n\t\tt += 5;\n\t\tdo_div(t, 10);\n\t} else {\n\t\t \n\t\tt = sample_freq_hz - if_hz;\n\t\tt *= 10;\n\t\tt *= 32768;\n\t\tdo_div(t, sample_freq_hz);\n\t\tt += 5;\n\t\tdo_div(t, 10);\n\t\tt = ~t + 1;\n\t}\n\n\ttda10048_writereg(state, TDA10048_FREQ_PHY2_LSB, (u8)t);\n\ttda10048_writereg(state, TDA10048_FREQ_PHY2_MSB, (u8)(t >> 8));\n\n\treturn 0;\n}\n\nstatic int tda10048_set_wref(struct dvb_frontend *fe, u32 sample_freq_hz,\n\t\t\t     u32 bw)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tu64 t, z;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (sample_freq_hz == 0)\n\t\treturn -EINVAL;\n\n\t \n\tt = bw * 10;\n\t \n\t \n\tt *= (2048 * 1024);\n\tt *= 1024;\n\tz = 7 * sample_freq_hz;\n\tdo_div(t, z);\n\tt += 5;\n\tdo_div(t, 10);\n\n\ttda10048_writereg(state, TDA10048_TIME_WREF_LSB, (u8)t);\n\ttda10048_writereg(state, TDA10048_TIME_WREF_MID1, (u8)(t >> 8));\n\ttda10048_writereg(state, TDA10048_TIME_WREF_MID2, (u8)(t >> 16));\n\ttda10048_writereg(state, TDA10048_TIME_WREF_MSB, (u8)(t >> 24));\n\n\treturn 0;\n}\n\nstatic int tda10048_set_invwref(struct dvb_frontend *fe, u32 sample_freq_hz,\n\t\t\t\tu32 bw)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tu64 t;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (sample_freq_hz == 0)\n\t\treturn -EINVAL;\n\n\t \n\tt = sample_freq_hz;\n\tt *= 7;\n\tt *= 32;\n\tt *= 10;\n\tdo_div(t, bw);\n\tt += 5;\n\tdo_div(t, 10);\n\n\ttda10048_writereg(state, TDA10048_TIME_INVWREF_LSB, (u8)t);\n\ttda10048_writereg(state, TDA10048_TIME_INVWREF_MSB, (u8)(t >> 8));\n\n\treturn 0;\n}\n\nstatic int tda10048_set_bandwidth(struct dvb_frontend *fe,\n\tu32 bw)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tdprintk(1, \"%s(bw=%d)\\n\", __func__, bw);\n\n\t \n\tswitch (bw) {\n\tcase 6000000:\n\tcase 7000000:\n\tcase 8000000:\n\t\ttda10048_set_wref(fe, state->sample_freq, bw);\n\t\ttda10048_set_invwref(fe, state->sample_freq, bw);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s() invalid bandwidth\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tstate->bandwidth = bw;\n\n\treturn 0;\n}\n\nstatic int tda10048_set_if(struct dvb_frontend *fe, u32 bw)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tstruct tda10048_config *config = &state->config;\n\tint i;\n\tu32 if_freq_khz;\n\n\tdprintk(1, \"%s(bw = %d)\\n\", __func__, bw);\n\n\t \n\tswitch (bw) {\n\tcase 6000000:\n\t\tif_freq_khz = config->dtv6_if_freq_khz;\n\t\tbreak;\n\tcase 7000000:\n\t\tif_freq_khz = config->dtv7_if_freq_khz;\n\t\tbreak;\n\tcase 8000000:\n\t\tif_freq_khz = config->dtv8_if_freq_khz;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s() no default\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pll_tab); i++) {\n\t\tif ((pll_tab[i].clk_freq_khz == config->clk_freq_khz) &&\n\t\t\t(pll_tab[i].if_freq_khz == if_freq_khz)) {\n\n\t\t\tstate->freq_if_hz = pll_tab[i].if_freq_khz * 1000;\n\t\t\tstate->xtal_hz = pll_tab[i].clk_freq_khz * 1000;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(pll_tab)) {\n\t\tprintk(KERN_ERR \"%s() Incorrect attach settings\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdprintk(1, \"- freq_if_hz = %d\\n\", state->freq_if_hz);\n\tdprintk(1, \"- xtal_hz = %d\\n\", state->xtal_hz);\n\tdprintk(1, \"- pll_mfactor = %d\\n\", state->pll_mfactor);\n\tdprintk(1, \"- pll_nfactor = %d\\n\", state->pll_nfactor);\n\tdprintk(1, \"- pll_pfactor = %d\\n\", state->pll_pfactor);\n\n\t \n\tstate->sample_freq = state->xtal_hz * (state->pll_mfactor + 45);\n\tstate->sample_freq /= (state->pll_nfactor + 1);\n\tstate->sample_freq /= (state->pll_pfactor + 4);\n\tdprintk(1, \"- sample_freq = %d\\n\", state->sample_freq);\n\n\t \n\ttda10048_set_phy2(fe, state->sample_freq, state->freq_if_hz);\n\n\treturn 0;\n}\n\nstatic int tda10048_firmware_upload(struct dvb_frontend *fe)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tstruct tda10048_config *config = &state->config;\n\tconst struct firmware *fw;\n\tint ret;\n\tint pos = 0;\n\tint cnt;\n\tu8 wlen = config->fwbulkwritelen;\n\n\tif ((wlen != TDA10048_BULKWRITE_200) && (wlen != TDA10048_BULKWRITE_50))\n\t\twlen = TDA10048_BULKWRITE_200;\n\n\t \n\tprintk(KERN_INFO \"%s: waiting for firmware upload (%s)...\\n\",\n\t\t__func__,\n\t\tTDA10048_DEFAULT_FIRMWARE);\n\n\tret = request_firmware(&fw, TDA10048_DEFAULT_FIRMWARE,\n\t\tstate->i2c->dev.parent);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: Upload failed. (file not found?)\\n\",\n\t\t\t__func__);\n\t\treturn -EIO;\n\t} else {\n\t\tprintk(KERN_INFO \"%s: firmware read %zu bytes.\\n\",\n\t\t\t__func__,\n\t\t\tfw->size);\n\t\tret = 0;\n\t}\n\n\tif (fw->size != TDA10048_DEFAULT_FIRMWARE_SIZE) {\n\t\tprintk(KERN_ERR \"%s: firmware incorrect size\\n\", __func__);\n\t\tret = -EIO;\n\t} else {\n\t\tprintk(KERN_INFO \"%s: firmware uploading\\n\", __func__);\n\n\t\t \n\t\ttda10048_writereg(state, TDA10048_CONF_TRISTATE1,\n\t\t\ttda10048_readreg(state, TDA10048_CONF_TRISTATE1)\n\t\t\t\t& 0xfe);\n\t\ttda10048_writereg(state, TDA10048_CONF_TRISTATE1,\n\t\t\ttda10048_readreg(state, TDA10048_CONF_TRISTATE1)\n\t\t\t\t| 0x01);\n\n\t\t \n\t\ttda10048_writereg(state, TDA10048_CONF_C4_1,\n\t\t\ttda10048_readreg(state, TDA10048_CONF_C4_1) & 0xf9);\n\n\t\t \n\t\ttda10048_writereg(state, TDA10048_CONF_C4_1,\n\t\t\ttda10048_readreg(state, TDA10048_CONF_C4_1) | 0x08);\n\n\t\t \n\t\ttda10048_writereg(state, TDA10048_DSP_CODE_CPT, 0);\n\n\t\t \n\t\twhile (pos < fw->size) {\n\n\t\t\tif ((fw->size - pos) > wlen)\n\t\t\t\tcnt = wlen;\n\t\t\telse\n\t\t\t\tcnt = fw->size - pos;\n\n\t\t\ttda10048_writeregbulk(state, TDA10048_DSP_CODE_IN,\n\t\t\t\t&fw->data[pos], cnt);\n\n\t\t\tpos += cnt;\n\t\t}\n\n\t\tret = -EIO;\n\t\t \n\t\tfor (cnt = 0; cnt < 250 ; cnt += 10) {\n\n\t\t\tmsleep(10);\n\n\t\t\tif (tda10048_readreg(state, TDA10048_SYNC_STATUS)\n\t\t\t\t& 0x40) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\trelease_firmware(fw);\n\n\tif (ret == 0) {\n\t\tprintk(KERN_INFO \"%s: firmware uploaded\\n\", __func__);\n\t\tstate->fwloaded = 1;\n\t} else\n\t\tprintk(KERN_ERR \"%s: firmware upload failed\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic int tda10048_set_inversion(struct dvb_frontend *fe, int inversion)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\n\tdprintk(1, \"%s(%d)\\n\", __func__, inversion);\n\n\tif (inversion == TDA10048_INVERSION_ON)\n\t\ttda10048_writereg(state, TDA10048_CONF_C1_1,\n\t\t\ttda10048_readreg(state, TDA10048_CONF_C1_1) | 0x20);\n\telse\n\t\ttda10048_writereg(state, TDA10048_CONF_C1_1,\n\t\t\ttda10048_readreg(state, TDA10048_CONF_C1_1) & 0xdf);\n\n\treturn 0;\n}\n\n \nstatic int tda10048_get_tps(struct tda10048_state *state,\n\tstruct dtv_frontend_properties *p)\n{\n\tu8 val;\n\n\t \n\tif (!(tda10048_readreg(state, TDA10048_AUTO) & 0x01))\n\t\treturn -EAGAIN;\n\n\tval = tda10048_readreg(state, TDA10048_OUT_CONF2);\n\tswitch ((val & 0x60) >> 5) {\n\tcase 0:\n\t\tp->modulation = QPSK;\n\t\tbreak;\n\tcase 1:\n\t\tp->modulation = QAM_16;\n\t\tbreak;\n\tcase 2:\n\t\tp->modulation = QAM_64;\n\t\tbreak;\n\t}\n\tswitch ((val & 0x18) >> 3) {\n\tcase 0:\n\t\tp->hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tp->hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tcase 2:\n\t\tp->hierarchy = HIERARCHY_2;\n\t\tbreak;\n\tcase 3:\n\t\tp->hierarchy = HIERARCHY_4;\n\t\tbreak;\n\t}\n\tswitch (val & 0x07) {\n\tcase 0:\n\t\tp->code_rate_HP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tp->code_rate_HP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tp->code_rate_HP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tp->code_rate_HP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tp->code_rate_HP = FEC_7_8;\n\t\tbreak;\n\t}\n\n\tval = tda10048_readreg(state, TDA10048_OUT_CONF3);\n\tswitch (val & 0x07) {\n\tcase 0:\n\t\tp->code_rate_LP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tp->code_rate_LP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tp->code_rate_LP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tp->code_rate_LP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tp->code_rate_LP = FEC_7_8;\n\t\tbreak;\n\t}\n\n\tval = tda10048_readreg(state, TDA10048_OUT_CONF1);\n\tswitch ((val & 0x0c) >> 2) {\n\tcase 0:\n\t\tp->guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\tp->guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\tp->guard_interval =  GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tp->guard_interval =  GUARD_INTERVAL_1_4;\n\t\tbreak;\n\t}\n\tswitch (val & 0x03) {\n\tcase 0:\n\t\tp->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n\tcase 1:\n\t\tp->transmission_mode = TRANSMISSION_MODE_8K;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tda10048_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tstruct tda10048_config *config = &state->config;\n\tdprintk(1, \"%s(%d)\\n\", __func__, enable);\n\n\tif (config->disable_gate_access)\n\t\treturn 0;\n\n\tif (enable)\n\t\treturn tda10048_writereg(state, TDA10048_CONF_C4_1,\n\t\t\ttda10048_readreg(state, TDA10048_CONF_C4_1) | 0x02);\n\telse\n\t\treturn tda10048_writereg(state, TDA10048_CONF_C4_1,\n\t\t\ttda10048_readreg(state, TDA10048_CONF_C4_1) & 0xfd);\n}\n\nstatic int tda10048_output_mode(struct dvb_frontend *fe, int serial)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tdprintk(1, \"%s(%d)\\n\", __func__, serial);\n\n\t \n\ttda10048_writereg(state, TDA10048_CONF_TRISTATE1, 0x21);\n\ttda10048_writereg(state, TDA10048_CONF_TRISTATE2, 0x00);\n\n\tif (serial) {\n\t\ttda10048_writereg(state, TDA10048_IC_MODE, 0x80 | 0x20);\n\t\ttda10048_writereg(state, TDA10048_CONF_TS2, 0xc0);\n\t} else {\n\t\ttda10048_writereg(state, TDA10048_IC_MODE, 0x00);\n\t\ttda10048_writereg(state, TDA10048_CONF_TS2, 0x01);\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic int tda10048_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\n\tdprintk(1, \"%s(frequency=%d)\\n\", __func__, p->frequency);\n\n\t \n\tif (p->bandwidth_hz != state->bandwidth) {\n\t\ttda10048_set_if(fe, p->bandwidth_hz);\n\t\ttda10048_set_bandwidth(fe, p->bandwidth_hz);\n\t}\n\n\tif (fe->ops.tuner_ops.set_params) {\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\tfe->ops.tuner_ops.set_params(fe);\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t \n\ttda10048_writereg(state, TDA10048_AUTO, 0x57);\n\t \n\ttda10048_writereg(state, TDA10048_CVBER_CTRL, 0x3B);\n\n\treturn 0;\n}\n\n \nstatic int tda10048_init(struct dvb_frontend *fe)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tstruct tda10048_config *config = &state->config;\n\tint ret = 0, i;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tinit_tab[4].data = (u8)(state->pll_mfactor);\n\tinit_tab[5].data = (u8)(state->pll_nfactor) | 0x40;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(init_tab); i++)\n\t\ttda10048_writereg(state, init_tab[i].reg, init_tab[i].data);\n\n\tif (state->fwloaded == 0)\n\t\tret = tda10048_firmware_upload(fe);\n\n\t \n\ttda10048_output_mode(fe, config->output_mode);\n\n\t \n\ttda10048_set_inversion(fe, config->inversion);\n\n\t \n\ttda10048_set_if(fe, 8000000);\n\ttda10048_set_bandwidth(fe, 8000000);\n\n\t \n\ttda10048_i2c_gate_ctrl(fe, 0);\n\n\treturn ret;\n}\n\nstatic int tda10048_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tu8 reg;\n\n\t*status = 0;\n\n\treg = tda10048_readreg(state, TDA10048_SYNC_STATUS);\n\n\tdprintk(1, \"%s() status =0x%02x\\n\", __func__, reg);\n\n\tif (reg & 0x02)\n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (reg & 0x04)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (reg & 0x08) {\n\t\t*status |= FE_HAS_LOCK;\n\t\t*status |= FE_HAS_VITERBI;\n\t\t*status |= FE_HAS_SYNC;\n\t}\n\n\treturn 0;\n}\n\nstatic int tda10048_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tstatic u32 cber_current;\n\tu32 cber_nmax;\n\tu64 cber_tmp;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tif (tda10048_readreg(state, TDA10048_SOFT_IT_C3) & 0x01) {\n\t\tcber_tmp = tda10048_readreg(state, TDA10048_CBER_MSB) << 8 |\n\t\t\ttda10048_readreg(state, TDA10048_CBER_LSB);\n\t\tcber_nmax = tda10048_readreg(state, TDA10048_CBER_NMAX_MSB) << 8 |\n\t\t\ttda10048_readreg(state, TDA10048_CBER_NMAX_LSB);\n\t\tcber_tmp *= 100000000;\n\t\tcber_tmp *= 2;\n\t\tcber_tmp = div_u64(cber_tmp, (cber_nmax * 32) + 1);\n\t\tcber_current = (u32)cber_tmp;\n\t\t \n\t\ttda10048_writereg(state, TDA10048_CVBER_CTRL, 0x39);\n\t}\n\t \n\t*ber = cber_current;\n\n\treturn 0;\n}\n\nstatic int tda10048_read_signal_strength(struct dvb_frontend *fe,\n\tu16 *signal_strength)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tu8 v;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t*signal_strength = 65535;\n\n\tv = tda10048_readreg(state, TDA10048_NP_OUT);\n\tif (v > 0)\n\t\t*signal_strength -= (v << 8) | v;\n\n\treturn 0;\n}\n\n \nstatic struct snr_tab {\n\tu8 val;\n\tu8 data;\n} snr_tab[] = {\n\t{   0,   0 },\n\t{   1, 246 },\n\t{   2, 215 },\n\t{   3, 198 },\n\t{   4, 185 },\n\t{   5, 176 },\n\t{   6, 168 },\n\t{   7, 161 },\n\t{   8, 155 },\n\t{   9, 150 },\n\t{  10, 146 },\n\t{  11, 141 },\n\t{  12, 138 },\n\t{  13, 134 },\n\t{  14, 131 },\n\t{  15, 128 },\n\t{  16, 125 },\n\t{  17, 122 },\n\t{  18, 120 },\n\t{  19, 118 },\n\t{  20, 115 },\n\t{  21, 113 },\n\t{  22, 111 },\n\t{  23, 109 },\n\t{  24, 107 },\n\t{  25, 106 },\n\t{  26, 104 },\n\t{  27, 102 },\n\t{  28, 101 },\n\t{  29,  99 },\n\t{  30,  98 },\n\t{  31,  96 },\n\t{  32,  95 },\n\t{  33,  94 },\n\t{  34,  92 },\n\t{  35,  91 },\n\t{  36,  90 },\n\t{  37,  89 },\n\t{  38,  88 },\n\t{  39,  86 },\n\t{  40,  85 },\n\t{  41,  84 },\n\t{  42,  83 },\n\t{  43,  82 },\n\t{  44,  81 },\n\t{  45,  80 },\n\t{  46,  79 },\n\t{  47,  78 },\n\t{  48,  77 },\n\t{  49,  76 },\n\t{  50,  76 },\n\t{  51,  75 },\n\t{  52,  74 },\n\t{  53,  73 },\n\t{  54,  72 },\n\t{  56,  71 },\n\t{  57,  70 },\n\t{  58,  69 },\n\t{  60,  68 },\n\t{  61,  67 },\n\t{  63,  66 },\n\t{  64,  65 },\n\t{  66,  64 },\n\t{  67,  63 },\n\t{  68,  62 },\n\t{  69,  62 },\n\t{  70,  61 },\n\t{  72,  60 },\n\t{  74,  59 },\n\t{  75,  58 },\n\t{  77,  57 },\n\t{  79,  56 },\n\t{  81,  55 },\n\t{  83,  54 },\n\t{  85,  53 },\n\t{  87,  52 },\n\t{  89,  51 },\n\t{  91,  50 },\n\t{  93,  49 },\n\t{  95,  48 },\n\t{  97,  47 },\n\t{ 100,  46 },\n\t{ 102,  45 },\n\t{ 104,  44 },\n\t{ 107,  43 },\n\t{ 109,  42 },\n\t{ 112,  41 },\n\t{ 114,  40 },\n\t{ 117,  39 },\n\t{ 120,  38 },\n\t{ 123,  37 },\n\t{ 125,  36 },\n\t{ 128,  35 },\n\t{ 131,  34 },\n\t{ 134,  33 },\n\t{ 138,  32 },\n\t{ 141,  31 },\n\t{ 144,  30 },\n\t{ 147,  29 },\n\t{ 151,  28 },\n\t{ 154,  27 },\n\t{ 158,  26 },\n\t{ 162,  25 },\n\t{ 165,  24 },\n\t{ 169,  23 },\n\t{ 173,  22 },\n\t{ 177,  21 },\n\t{ 181,  20 },\n\t{ 186,  19 },\n\t{ 190,  18 },\n\t{ 194,  17 },\n\t{ 199,  16 },\n\t{ 204,  15 },\n\t{ 208,  14 },\n\t{ 213,  13 },\n\t{ 218,  12 },\n\t{ 223,  11 },\n\t{ 229,  10 },\n\t{ 234,   9 },\n\t{ 239,   8 },\n\t{ 245,   7 },\n\t{ 251,   6 },\n\t{ 255,   5 },\n};\n\nstatic int tda10048_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tu8 v;\n\tint i, ret = -EINVAL;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tv = tda10048_readreg(state, TDA10048_NP_OUT);\n\tfor (i = 0; i < ARRAY_SIZE(snr_tab); i++) {\n\t\tif (v <= snr_tab[i].val) {\n\t\t\t*snr = snr_tab[i].data;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int tda10048_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t*ucblocks = tda10048_readreg(state, TDA10048_UNCOR_CPT_MSB) << 8 |\n\t\ttda10048_readreg(state, TDA10048_UNCOR_CPT_LSB);\n\t \n\tif (*ucblocks == 0xFFFF)\n\t\ttda10048_writereg(state, TDA10048_UNCOR_CTRL, 0x80);\n\n\treturn 0;\n}\n\nstatic int tda10048_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t struct dtv_frontend_properties *p)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tp->inversion = tda10048_readreg(state, TDA10048_CONF_C1_1)\n\t\t& 0x20 ? INVERSION_ON : INVERSION_OFF;\n\n\treturn tda10048_get_tps(state, p);\n}\n\nstatic int tda10048_get_tune_settings(struct dvb_frontend *fe,\n\tstruct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic void tda10048_release(struct dvb_frontend *fe)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tdprintk(1, \"%s()\\n\", __func__);\n\tkfree(state);\n}\n\nstatic void tda10048_establish_defaults(struct dvb_frontend *fe)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tstruct tda10048_config *config = &state->config;\n\n\t \n\tif (config->dtv6_if_freq_khz == 0) {\n\t\tconfig->dtv6_if_freq_khz = TDA10048_IF_4300;\n\t\tprintk(KERN_WARNING \"%s() tda10048_config.dtv6_if_freq_khz is not set (defaulting to %d)\\n\",\n\t\t\t__func__,\n\t\t\tconfig->dtv6_if_freq_khz);\n\t}\n\n\tif (config->dtv7_if_freq_khz == 0) {\n\t\tconfig->dtv7_if_freq_khz = TDA10048_IF_4300;\n\t\tprintk(KERN_WARNING \"%s() tda10048_config.dtv7_if_freq_khz is not set (defaulting to %d)\\n\",\n\t\t\t__func__,\n\t\t\tconfig->dtv7_if_freq_khz);\n\t}\n\n\tif (config->dtv8_if_freq_khz == 0) {\n\t\tconfig->dtv8_if_freq_khz = TDA10048_IF_4300;\n\t\tprintk(KERN_WARNING \"%s() tda10048_config.dtv8_if_freq_khz is not set (defaulting to %d)\\n\",\n\t\t\t__func__,\n\t\t\tconfig->dtv8_if_freq_khz);\n\t}\n\n\tif (config->clk_freq_khz == 0) {\n\t\tconfig->clk_freq_khz = TDA10048_CLK_16000;\n\t\tprintk(KERN_WARNING \"%s() tda10048_config.clk_freq_khz is not set (defaulting to %d)\\n\",\n\t\t\t__func__,\n\t\t\tconfig->clk_freq_khz);\n\t}\n}\n\nstatic const struct dvb_frontend_ops tda10048_ops;\n\nstruct dvb_frontend *tda10048_attach(const struct tda10048_config *config,\n\tstruct i2c_adapter *i2c)\n{\n\tstruct tda10048_state *state = NULL;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tstate = kzalloc(sizeof(struct tda10048_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->config, config, sizeof(*config));\n\tstate->i2c = i2c;\n\tstate->fwloaded = config->no_firmware;\n\tstate->bandwidth = 8000000;\n\n\t \n\tif (tda10048_readreg(state, TDA10048_IDENTITY) != 0x048)\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &tda10048_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\t \n\tif (config->set_pll) {\n\t\tstate->pll_mfactor = config->pll_m;\n\t\tstate->pll_nfactor = config->pll_n;\n\t\tstate->pll_pfactor = config->pll_p;\n\t} else {\n\t\tstate->pll_mfactor = 10;\n\t\tstate->pll_nfactor = 3;\n\t\tstate->pll_pfactor = 0;\n\t}\n\n\t \n\ttda10048_establish_defaults(&state->frontend);\n\n\t \n\tif (tda10048_set_if(&state->frontend, 8000000) != 0)\n\t\tgoto error;\n\n\t \n\tif (tda10048_set_bandwidth(&state->frontend, 8000000) != 0)\n\t\tgoto error;\n\n\t \n\ttda10048_i2c_gate_ctrl(&state->frontend, 0);\n\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(tda10048_attach);\n\nstatic const struct dvb_frontend_ops tda10048_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name\t\t\t= \"NXP TDA10048HN DVB-T\",\n\t\t.frequency_min_hz\t= 177 * MHz,\n\t\t.frequency_max_hz\t= 858 * MHz,\n\t\t.frequency_stepsize_hz\t= 166666,\n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\tFE_CAN_HIERARCHY_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |\n\t\tFE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_RECOVER\n\t},\n\n\t.release = tda10048_release,\n\t.init = tda10048_init,\n\t.i2c_gate_ctrl = tda10048_i2c_gate_ctrl,\n\t.set_frontend = tda10048_set_frontend,\n\t.get_frontend = tda10048_get_frontend,\n\t.get_tune_settings = tda10048_get_tune_settings,\n\t.read_status = tda10048_read_status,\n\t.read_ber = tda10048_read_ber,\n\t.read_signal_strength = tda10048_read_signal_strength,\n\t.read_snr = tda10048_read_snr,\n\t.read_ucblocks = tda10048_read_ucblocks,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Enable verbose debug messages\");\n\nMODULE_DESCRIPTION(\"NXP TDA10048HN DVB-T Demodulator driver\");\nMODULE_AUTHOR(\"Steven Toth\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}