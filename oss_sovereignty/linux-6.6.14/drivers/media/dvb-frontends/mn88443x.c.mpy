{
  "module_name": "mn88443x.c",
  "hash_id": "ea55e11303644b2540671f5ac1b0066b2d40dd11984fc91ffc94db0dba7cae89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/mn88443x.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/int_log.h>\n\n#include \"mn88443x.h\"\n\n \n#define ATSIDU_S                                    0x2f\n#define ATSIDL_S                                    0x30\n#define TSSET_S                                     0x31\n#define AGCREAD_S                                   0x5a\n#define CPMON1_S                                    0x5e\n#define   CPMON1_S_FSYNC                              BIT(5)\n#define   CPMON1_S_ERRMON                             BIT(4)\n#define   CPMON1_S_SIGOFF                             BIT(3)\n#define   CPMON1_S_W2LOCK                             BIT(2)\n#define   CPMON1_S_W1LOCK                             BIT(1)\n#define   CPMON1_S_DW1LOCK                            BIT(0)\n#define TRMON_S                                     0x60\n#define BERCNFLG_S                                  0x68\n#define   BERCNFLG_S_BERVRDY                          BIT(5)\n#define   BERCNFLG_S_BERVCHK                          BIT(4)\n#define   BERCNFLG_S_BERDRDY                          BIT(3)\n#define   BERCNFLG_S_BERDCHK                          BIT(2)\n#define CNRDXU_S                                    0x69\n#define CNRDXL_S                                    0x6a\n#define CNRDYU_S                                    0x6b\n#define CNRDYL_S                                    0x6c\n#define BERVRDU_S                                   0x71\n#define BERVRDL_S                                   0x72\n#define DOSET1_S                                    0x73\n\n \n#define PLLASET1                                    0x00\n#define PLLASET2                                    0x01\n#define PLLBSET1                                    0x02\n#define PLLBSET2                                    0x03\n#define PLLSET                                      0x04\n#define OUTCSET                                     0x08\n#define   OUTCSET_CHDRV_8MA                           0xff\n#define   OUTCSET_CHDRV_4MA                           0x00\n#define PLDWSET                                     0x09\n#define   PLDWSET_NORMAL                             0x00\n#define   PLDWSET_PULLDOWN                           0xff\n#define HIZSET1                                     0x0a\n#define HIZSET2                                     0x0b\n\n \n#define RCVSET                                      0x00\n#define TSSET1_M                                    0x01\n#define TSSET2_M                                    0x02\n#define TSSET3_M                                    0x03\n#define INTACSET                                    0x08\n#define HIZSET3                                     0x0b\n\n \n#define TSSET1                                      0x05\n#define   TSSET1_TSASEL_MASK                          GENMASK(4, 3)\n#define   TSSET1_TSASEL_ISDBT                         (0x0 << 3)\n#define   TSSET1_TSASEL_ISDBS                         (0x1 << 3)\n#define   TSSET1_TSASEL_NONE                          (0x2 << 3)\n#define   TSSET1_TSBSEL_MASK                          GENMASK(2, 1)\n#define   TSSET1_TSBSEL_ISDBS                         (0x0 << 1)\n#define   TSSET1_TSBSEL_ISDBT                         (0x1 << 1)\n#define   TSSET1_TSBSEL_NONE                          (0x2 << 1)\n#define TSSET2                                      0x06\n#define TSSET3                                      0x07\n#define   TSSET3_INTASEL_MASK                         GENMASK(7, 6)\n#define   TSSET3_INTASEL_T                            (0x0 << 6)\n#define   TSSET3_INTASEL_S                            (0x1 << 6)\n#define   TSSET3_INTASEL_NONE                         (0x2 << 6)\n#define   TSSET3_INTBSEL_MASK                         GENMASK(5, 4)\n#define   TSSET3_INTBSEL_S                            (0x0 << 4)\n#define   TSSET3_INTBSEL_T                            (0x1 << 4)\n#define   TSSET3_INTBSEL_NONE                         (0x2 << 4)\n#define OUTSET2                                     0x0d\n#define PWDSET                                      0x0f\n#define   PWDSET_OFDMPD_MASK                          GENMASK(3, 2)\n#define   PWDSET_OFDMPD_DOWN                          BIT(3)\n#define   PWDSET_PSKPD_MASK                           GENMASK(1, 0)\n#define   PWDSET_PSKPD_DOWN                           BIT(1)\n#define CLKSET1_T                                   0x11\n#define MDSET_T                                     0x13\n#define   MDSET_T_MDAUTO_MASK                         GENMASK(7, 4)\n#define   MDSET_T_MDAUTO_AUTO                         (0xf << 4)\n#define   MDSET_T_MDAUTO_MANUAL                       (0x0 << 4)\n#define   MDSET_T_FFTS_MASK                           GENMASK(3, 2)\n#define   MDSET_T_FFTS_MODE1                          (0x0 << 2)\n#define   MDSET_T_FFTS_MODE2                          (0x1 << 2)\n#define   MDSET_T_FFTS_MODE3                          (0x2 << 2)\n#define   MDSET_T_GI_MASK                             GENMASK(1, 0)\n#define   MDSET_T_GI_1_32                             (0x0 << 0)\n#define   MDSET_T_GI_1_16                             (0x1 << 0)\n#define   MDSET_T_GI_1_8                              (0x2 << 0)\n#define   MDSET_T_GI_1_4                              (0x3 << 0)\n#define MDASET_T                                    0x14\n#define ADCSET1_T                                   0x20\n#define   ADCSET1_T_REFSEL_MASK                       GENMASK(1, 0)\n#define   ADCSET1_T_REFSEL_2V                         (0x3 << 0)\n#define   ADCSET1_T_REFSEL_1_5V                       (0x2 << 0)\n#define   ADCSET1_T_REFSEL_1V                         (0x1 << 0)\n#define NCOFREQU_T                                  0x24\n#define NCOFREQM_T                                  0x25\n#define NCOFREQL_T                                  0x26\n#define FADU_T                                      0x27\n#define FADM_T                                      0x28\n#define FADL_T                                      0x29\n#define AGCSET2_T                                   0x2c\n#define   AGCSET2_T_IFPOLINV_INC                      BIT(0)\n#define   AGCSET2_T_RFPOLINV_INC                      BIT(1)\n#define AGCV3_T                                     0x3e\n#define MDRD_T                                      0xa2\n#define   MDRD_T_SEGID_MASK                           GENMASK(5, 4)\n#define   MDRD_T_SEGID_13                             (0x0 << 4)\n#define   MDRD_T_SEGID_1                              (0x1 << 4)\n#define   MDRD_T_SEGID_3                              (0x2 << 4)\n#define   MDRD_T_FFTS_MASK                            GENMASK(3, 2)\n#define   MDRD_T_FFTS_MODE1                           (0x0 << 2)\n#define   MDRD_T_FFTS_MODE2                           (0x1 << 2)\n#define   MDRD_T_FFTS_MODE3                           (0x2 << 2)\n#define   MDRD_T_GI_MASK                              GENMASK(1, 0)\n#define   MDRD_T_GI_1_32                              (0x0 << 0)\n#define   MDRD_T_GI_1_16                              (0x1 << 0)\n#define   MDRD_T_GI_1_8                               (0x2 << 0)\n#define   MDRD_T_GI_1_4                               (0x3 << 0)\n#define SSEQRD_T                                    0xa3\n#define   SSEQRD_T_SSEQSTRD_MASK                      GENMASK(3, 0)\n#define   SSEQRD_T_SSEQSTRD_RESET                     (0x0 << 0)\n#define   SSEQRD_T_SSEQSTRD_TUNING                    (0x1 << 0)\n#define   SSEQRD_T_SSEQSTRD_AGC                       (0x2 << 0)\n#define   SSEQRD_T_SSEQSTRD_SEARCH                    (0x3 << 0)\n#define   SSEQRD_T_SSEQSTRD_CLOCK_SYNC                (0x4 << 0)\n#define   SSEQRD_T_SSEQSTRD_FREQ_SYNC                 (0x8 << 0)\n#define   SSEQRD_T_SSEQSTRD_FRAME_SYNC                (0x9 << 0)\n#define   SSEQRD_T_SSEQSTRD_SYNC                      (0xa << 0)\n#define   SSEQRD_T_SSEQSTRD_LOCK                      (0xb << 0)\n#define AGCRDU_T                                    0xa8\n#define AGCRDL_T                                    0xa9\n#define CNRDU_T                                     0xbe\n#define CNRDL_T                                     0xbf\n#define BERFLG_T                                    0xc0\n#define   BERFLG_T_BERDRDY                            BIT(7)\n#define   BERFLG_T_BERDCHK                            BIT(6)\n#define   BERFLG_T_BERVRDYA                           BIT(5)\n#define   BERFLG_T_BERVCHKA                           BIT(4)\n#define   BERFLG_T_BERVRDYB                           BIT(3)\n#define   BERFLG_T_BERVCHKB                           BIT(2)\n#define   BERFLG_T_BERVRDYC                           BIT(1)\n#define   BERFLG_T_BERVCHKC                           BIT(0)\n#define BERRDU_T                                    0xc1\n#define BERRDM_T                                    0xc2\n#define BERRDL_T                                    0xc3\n#define BERLENRDU_T                                 0xc4\n#define BERLENRDL_T                                 0xc5\n#define ERRFLG_T                                    0xc6\n#define   ERRFLG_T_BERDOVF                            BIT(7)\n#define   ERRFLG_T_BERVOVFA                           BIT(6)\n#define   ERRFLG_T_BERVOVFB                           BIT(5)\n#define   ERRFLG_T_BERVOVFC                           BIT(4)\n#define   ERRFLG_T_NERRFA                             BIT(3)\n#define   ERRFLG_T_NERRFB                             BIT(2)\n#define   ERRFLG_T_NERRFC                             BIT(1)\n#define   ERRFLG_T_NERRF                              BIT(0)\n#define DOSET1_T                                    0xcf\n\n#define CLK_LOW            4000000\n#define CLK_DIRECT         20200000\n#define CLK_MAX            25410000\n\n#define S_T_FREQ           8126984  \n\nstruct mn88443x_spec {\n\tbool primary;\n};\n\nstruct mn88443x_priv {\n\tconst struct mn88443x_spec *spec;\n\n\tstruct dvb_frontend fe;\n\tstruct clk *mclk;\n\tstruct gpio_desc *reset_gpio;\n\tu32 clk_freq;\n\tu32 if_freq;\n\n\t \n\tbool use_clkbuf;\n\n\t \n\tstruct i2c_client *client_s;\n\tstruct regmap *regmap_s;\n\n\t \n\tstruct i2c_client *client_t;\n\tstruct regmap *regmap_t;\n};\n\nstatic int mn88443x_cmn_power_on(struct mn88443x_priv *chip)\n{\n\tstruct device *dev = &chip->client_s->dev;\n\tstruct regmap *r_t = chip->regmap_t;\n\tint ret;\n\n\tret = clk_prepare_enable(chip->mclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to prepare and enable mclk: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value_cansleep(chip->reset_gpio, 1);\n\tusleep_range(100, 1000);\n\tgpiod_set_value_cansleep(chip->reset_gpio, 0);\n\n\tif (chip->spec->primary) {\n\t\tregmap_write(r_t, OUTCSET, OUTCSET_CHDRV_8MA);\n\t\tregmap_write(r_t, PLDWSET, PLDWSET_NORMAL);\n\t\tregmap_write(r_t, HIZSET1, 0x80);\n\t\tregmap_write(r_t, HIZSET2, 0xe0);\n\t} else {\n\t\tregmap_write(r_t, HIZSET3, 0x8f);\n\t}\n\n\treturn 0;\n}\n\nstatic void mn88443x_cmn_power_off(struct mn88443x_priv *chip)\n{\n\tgpiod_set_value_cansleep(chip->reset_gpio, 1);\n\n\tclk_disable_unprepare(chip->mclk);\n}\n\nstatic void mn88443x_s_sleep(struct mn88443x_priv *chip)\n{\n\tstruct regmap *r_t = chip->regmap_t;\n\n\tregmap_update_bits(r_t, PWDSET, PWDSET_PSKPD_MASK,\n\t\t\t   PWDSET_PSKPD_DOWN);\n}\n\nstatic void mn88443x_s_wake(struct mn88443x_priv *chip)\n{\n\tstruct regmap *r_t = chip->regmap_t;\n\n\tregmap_update_bits(r_t, PWDSET, PWDSET_PSKPD_MASK, 0);\n}\n\nstatic void mn88443x_s_tune(struct mn88443x_priv *chip,\n\t\t\t    struct dtv_frontend_properties *c)\n{\n\tstruct regmap *r_s = chip->regmap_s;\n\n\tregmap_write(r_s, ATSIDU_S, c->stream_id >> 8);\n\tregmap_write(r_s, ATSIDL_S, c->stream_id);\n\tregmap_write(r_s, TSSET_S, 0);\n}\n\nstatic int mn88443x_s_read_status(struct mn88443x_priv *chip,\n\t\t\t\t  struct dtv_frontend_properties *c,\n\t\t\t\t  enum fe_status *status)\n{\n\tstruct regmap *r_s = chip->regmap_s;\n\tu32 cpmon, tmpu, tmpl, flg;\n\tu64 tmp;\n\n\t \n\tregmap_read(r_s, CPMON1_S, &cpmon);\n\n\t*status = 0;\n\tif (cpmon & CPMON1_S_FSYNC)\n\t\t*status |= FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\tif (cpmon & CPMON1_S_W2LOCK)\n\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\n\t \n\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tif (*status & FE_HAS_SIGNAL) {\n\t\tu32 agc;\n\n\t\tregmap_read(r_s, AGCREAD_S, &tmpu);\n\t\tagc = tmpu << 8;\n\n\t\tc->strength.len = 1;\n\t\tc->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\t\tc->strength.stat[0].uvalue = agc;\n\t}\n\n\t \n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tif (*status & FE_HAS_VITERBI) {\n\t\tu32 cnr = 0, x, y, d;\n\t\tu64 d_3 = 0;\n\n\t\tregmap_read(r_s, CNRDXU_S, &tmpu);\n\t\tregmap_read(r_s, CNRDXL_S, &tmpl);\n\t\tx = (tmpu << 8) | tmpl;\n\t\tregmap_read(r_s, CNRDYU_S, &tmpu);\n\t\tregmap_read(r_s, CNRDYL_S, &tmpl);\n\t\ty = (tmpu << 8) | tmpl;\n\n\t\t \n\t\t \n\t\td = (y << 15) - x * x;\n\t\tif (d > 0) {\n\t\t\t \n\t\t\t \n\t\t\td_3 = div_u64(16 * x * x, d);\n\t\t\td_3 = d_3 * d_3 * d_3;\n\t\t\tif (d_3)\n\t\t\t\td_3 = div_u64(211243671486ULL, d_3);\n\t\t}\n\n\t\tif (d_3) {\n\t\t\t \n\t\t\ttmp = (s64)2 * intlog10(x) - intlog10(abs(d)) - d_3\n\t\t\t\t- 5033164;\n\t\t\tcnr = div_u64(tmp * 10000, 1 << 24);\n\t\t}\n\n\t\tif (cnr) {\n\t\t\tc->cnr.len = 1;\n\t\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\t\tc->cnr.stat[0].uvalue = cnr;\n\t\t}\n\t}\n\n\t \n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tregmap_read(r_s, BERCNFLG_S, &flg);\n\n\tif ((*status & FE_HAS_VITERBI) && (flg & BERCNFLG_S_BERVRDY)) {\n\t\tu32 bit_err, bit_cnt;\n\n\t\tregmap_read(r_s, BERVRDU_S, &tmpu);\n\t\tregmap_read(r_s, BERVRDL_S, &tmpl);\n\t\tbit_err = (tmpu << 8) | tmpl;\n\t\tbit_cnt = (1 << 13) * 204;\n\n\t\tif (bit_cnt) {\n\t\t\tc->post_bit_error.len = 1;\n\t\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_error.stat[0].uvalue = bit_err;\n\t\t\tc->post_bit_count.len = 1;\n\t\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_count.stat[0].uvalue = bit_cnt;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void mn88443x_t_sleep(struct mn88443x_priv *chip)\n{\n\tstruct regmap *r_t = chip->regmap_t;\n\n\tregmap_update_bits(r_t, PWDSET, PWDSET_OFDMPD_MASK,\n\t\t\t   PWDSET_OFDMPD_DOWN);\n}\n\nstatic void mn88443x_t_wake(struct mn88443x_priv *chip)\n{\n\tstruct regmap *r_t = chip->regmap_t;\n\n\tregmap_update_bits(r_t, PWDSET, PWDSET_OFDMPD_MASK, 0);\n}\n\nstatic bool mn88443x_t_is_valid_clk(u32 adckt, u32 if_freq)\n{\n\tif (if_freq == DIRECT_IF_57MHZ) {\n\t\tif (adckt >= CLK_DIRECT && adckt <= 21000000)\n\t\t\treturn true;\n\t\tif (adckt >= 25300000 && adckt <= CLK_MAX)\n\t\t\treturn true;\n\t} else if (if_freq == DIRECT_IF_44MHZ) {\n\t\tif (adckt >= 25000000 && adckt <= CLK_MAX)\n\t\t\treturn true;\n\t} else if (if_freq >= LOW_IF_4MHZ && if_freq < DIRECT_IF_44MHZ) {\n\t\tif (adckt >= CLK_DIRECT && adckt <= CLK_MAX)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int mn88443x_t_set_freq(struct mn88443x_priv *chip)\n{\n\tstruct device *dev = &chip->client_s->dev;\n\tstruct regmap *r_t = chip->regmap_t;\n\ts64 adckt, nco, ad_t;\n\tu32 m, v;\n\n\t \n\tif (chip->clk_freq >= CLK_LOW && chip->clk_freq < CLK_DIRECT) {\n\t\tchip->use_clkbuf = true;\n\t\tregmap_write(r_t, CLKSET1_T, 0x07);\n\n\t\tadckt = 0;\n\t} else {\n\t\tchip->use_clkbuf = false;\n\t\tregmap_write(r_t, CLKSET1_T, 0x00);\n\n\t\tadckt = chip->clk_freq;\n\t}\n\tif (!mn88443x_t_is_valid_clk(adckt, chip->if_freq)) {\n\t\tdev_err(dev, \"Invalid clock, CLK:%d, ADCKT:%lld, IF:%d\\n\",\n\t\t\tchip->clk_freq, adckt, chip->if_freq);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (chip->if_freq == DIRECT_IF_57MHZ ||\n\t    chip->if_freq == DIRECT_IF_44MHZ)\n\t\tnco = adckt * 2 - chip->if_freq;\n\telse\n\t\tnco = -((s64)chip->if_freq);\n\tnco = div_s64(nco << 24, adckt);\n\tad_t = div_s64(adckt << 22, S_T_FREQ);\n\n\tregmap_write(r_t, NCOFREQU_T, nco >> 16);\n\tregmap_write(r_t, NCOFREQM_T, nco >> 8);\n\tregmap_write(r_t, NCOFREQL_T, nco);\n\tregmap_write(r_t, FADU_T, ad_t >> 16);\n\tregmap_write(r_t, FADM_T, ad_t >> 8);\n\tregmap_write(r_t, FADL_T, ad_t);\n\n\t \n\tm = ADCSET1_T_REFSEL_MASK;\n\tv = ADCSET1_T_REFSEL_1_5V;\n\tregmap_update_bits(r_t, ADCSET1_T, m, v);\n\n\t \n\tv = AGCSET2_T_IFPOLINV_INC | AGCSET2_T_RFPOLINV_INC;\n\tregmap_update_bits(r_t, AGCSET2_T, v, v);\n\n\t \n\tregmap_write(r_t, AGCV3_T, 0x00);\n\n\tregmap_write(r_t, MDSET_T, 0xfa);\n\n\treturn 0;\n}\n\nstatic void mn88443x_t_tune(struct mn88443x_priv *chip,\n\t\t\t    struct dtv_frontend_properties *c)\n{\n\tstruct regmap *r_t = chip->regmap_t;\n\tu32 m, v;\n\n\tm = MDSET_T_MDAUTO_MASK | MDSET_T_FFTS_MASK | MDSET_T_GI_MASK;\n\tv = MDSET_T_MDAUTO_AUTO | MDSET_T_FFTS_MODE3 | MDSET_T_GI_1_8;\n\tregmap_update_bits(r_t, MDSET_T, m, v);\n\n\tregmap_write(r_t, MDASET_T, 0);\n}\n\nstatic int mn88443x_t_read_status(struct mn88443x_priv *chip,\n\t\t\t\t  struct dtv_frontend_properties *c,\n\t\t\t\t  enum fe_status *status)\n{\n\tstruct regmap *r_t = chip->regmap_t;\n\tu32 seqrd, st, flg, tmpu, tmpm, tmpl;\n\tu64 tmp;\n\n\t \n\tregmap_read(r_t, SSEQRD_T, &seqrd);\n\tst = seqrd & SSEQRD_T_SSEQSTRD_MASK;\n\n\t*status = 0;\n\tif (st >= SSEQRD_T_SSEQSTRD_SYNC)\n\t\t*status |= FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\tif (st >= SSEQRD_T_SSEQSTRD_FRAME_SYNC)\n\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\n\t \n\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tif (*status & FE_HAS_SIGNAL) {\n\t\tu32 agc;\n\n\t\tregmap_read(r_t, AGCRDU_T, &tmpu);\n\t\tregmap_read(r_t, AGCRDL_T, &tmpl);\n\t\tagc = (tmpu << 8) | tmpl;\n\n\t\tc->strength.len = 1;\n\t\tc->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\t\tc->strength.stat[0].uvalue = agc;\n\t}\n\n\t \n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tif (*status & FE_HAS_VITERBI) {\n\t\tu32 cnr;\n\n\t\tregmap_read(r_t, CNRDU_T, &tmpu);\n\t\tregmap_read(r_t, CNRDL_T, &tmpl);\n\n\t\tif (tmpu || tmpl) {\n\t\t\t \n\t\t\t \n\t\t\ttmp = (u64)80807124 - intlog10((tmpu << 8) | tmpl)\n\t\t\t\t+ 3355443;\n\t\t\tcnr = div_u64(tmp * 10000, 1 << 24);\n\t\t} else {\n\t\t\tcnr = 0;\n\t\t}\n\n\t\tc->cnr.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[0].uvalue = cnr;\n\t}\n\n\t \n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tregmap_read(r_t, BERFLG_T, &flg);\n\n\tif ((*status & FE_HAS_VITERBI) && (flg & BERFLG_T_BERVRDYA)) {\n\t\tu32 bit_err, bit_cnt;\n\n\t\tregmap_read(r_t, BERRDU_T, &tmpu);\n\t\tregmap_read(r_t, BERRDM_T, &tmpm);\n\t\tregmap_read(r_t, BERRDL_T, &tmpl);\n\t\tbit_err = (tmpu << 16) | (tmpm << 8) | tmpl;\n\n\t\tregmap_read(r_t, BERLENRDU_T, &tmpu);\n\t\tregmap_read(r_t, BERLENRDL_T, &tmpl);\n\t\tbit_cnt = ((tmpu << 8) | tmpl) * 203 * 8;\n\n\t\tif (bit_cnt) {\n\t\t\tc->post_bit_error.len = 1;\n\t\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_error.stat[0].uvalue = bit_err;\n\t\t\tc->post_bit_count.len = 1;\n\t\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_count.stat[0].uvalue = bit_cnt;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mn88443x_sleep(struct dvb_frontend *fe)\n{\n\tstruct mn88443x_priv *chip = fe->demodulator_priv;\n\n\tmn88443x_s_sleep(chip);\n\tmn88443x_t_sleep(chip);\n\n\treturn 0;\n}\n\nstatic int mn88443x_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct mn88443x_priv *chip = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct regmap *r_s = chip->regmap_s;\n\tstruct regmap *r_t = chip->regmap_t;\n\tu8 tssel = 0, intsel = 0;\n\n\tif (c->delivery_system == SYS_ISDBS) {\n\t\tmn88443x_s_wake(chip);\n\t\tmn88443x_t_sleep(chip);\n\n\t\ttssel = TSSET1_TSASEL_ISDBS;\n\t\tintsel = TSSET3_INTASEL_S;\n\t} else if (c->delivery_system == SYS_ISDBT) {\n\t\tmn88443x_s_sleep(chip);\n\t\tmn88443x_t_wake(chip);\n\n\t\tmn88443x_t_set_freq(chip);\n\n\t\ttssel = TSSET1_TSASEL_ISDBT;\n\t\tintsel = TSSET3_INTASEL_T;\n\t}\n\n\tregmap_update_bits(r_t, TSSET1,\n\t\t\t   TSSET1_TSASEL_MASK | TSSET1_TSBSEL_MASK,\n\t\t\t   tssel | TSSET1_TSBSEL_NONE);\n\tregmap_write(r_t, TSSET2, 0);\n\tregmap_update_bits(r_t, TSSET3,\n\t\t\t   TSSET3_INTASEL_MASK | TSSET3_INTBSEL_MASK,\n\t\t\t   intsel | TSSET3_INTBSEL_NONE);\n\n\tregmap_write(r_t, DOSET1_T, 0x95);\n\tregmap_write(r_s, DOSET1_S, 0x80);\n\n\tif (c->delivery_system == SYS_ISDBS)\n\t\tmn88443x_s_tune(chip, c);\n\telse if (c->delivery_system == SYS_ISDBT)\n\t\tmn88443x_t_tune(chip, c);\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int mn88443x_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t      struct dvb_frontend_tune_settings *s)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\ts->min_delay_ms = 850;\n\n\tif (c->delivery_system == SYS_ISDBS) {\n\t\ts->max_drift = 30000 * 2 + 1;\n\t\ts->step_size = 30000;\n\t} else if (c->delivery_system == SYS_ISDBT) {\n\t\ts->max_drift = 142857 * 2 + 1;\n\t\ts->step_size = 142857 * 2;\n\t}\n\n\treturn 0;\n}\n\nstatic int mn88443x_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct mn88443x_priv *chip = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->delivery_system == SYS_ISDBS)\n\t\treturn mn88443x_s_read_status(chip, c, status);\n\n\tif (c->delivery_system == SYS_ISDBT)\n\t\treturn mn88443x_t_read_status(chip, c, status);\n\n\treturn -EINVAL;\n}\n\nstatic const struct dvb_frontend_ops mn88443x_ops = {\n\t.delsys = { SYS_ISDBS, SYS_ISDBT },\n\t.info = {\n\t\t.name = \"Socionext MN88443x\",\n\t\t.frequency_min_hz =  470 * MHz,\n\t\t.frequency_max_hz = 2071 * MHz,\n\t\t.symbol_rate_min  = 28860000,\n\t\t.symbol_rate_max  = 28860000,\n\t\t.caps = FE_CAN_INVERSION_AUTO | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO,\n\t},\n\n\t.sleep                   = mn88443x_sleep,\n\t.set_frontend            = mn88443x_set_frontend,\n\t.get_tune_settings       = mn88443x_get_tune_settings,\n\t.read_status             = mn88443x_read_status,\n};\n\nstatic const struct regmap_config regmap_config = {\n\t.reg_bits   = 8,\n\t.val_bits   = 8,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic int mn88443x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct mn88443x_config *conf = client->dev.platform_data;\n\tstruct mn88443x_priv *chip;\n\tstruct device *dev = &client->dev;\n\tint ret;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tif (dev->of_node)\n\t\tchip->spec = of_device_get_match_data(dev);\n\telse\n\t\tchip->spec = (struct mn88443x_spec *)id->driver_data;\n\tif (!chip->spec)\n\t\treturn -EINVAL;\n\n\tchip->mclk = devm_clk_get(dev, \"mclk\");\n\tif (IS_ERR(chip->mclk) && !conf) {\n\t\tdev_err(dev, \"Failed to request mclk: %ld\\n\",\n\t\t\tPTR_ERR(chip->mclk));\n\t\treturn PTR_ERR(chip->mclk);\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"if-frequency\",\n\t\t\t\t   &chip->if_freq);\n\tif (ret && !conf) {\n\t\tdev_err(dev, \"Failed to load IF frequency: %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tchip->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(chip->reset_gpio)) {\n\t\tdev_err(dev, \"Failed to request reset_gpio: %ld\\n\",\n\t\t\tPTR_ERR(chip->reset_gpio));\n\t\treturn PTR_ERR(chip->reset_gpio);\n\t}\n\n\tif (conf) {\n\t\tchip->mclk = conf->mclk;\n\t\tchip->if_freq = conf->if_freq;\n\t\tchip->reset_gpio = conf->reset_gpio;\n\n\t\t*conf->fe = &chip->fe;\n\t}\n\n\tchip->client_s = client;\n\tchip->regmap_s = devm_regmap_init_i2c(chip->client_s, &regmap_config);\n\tif (IS_ERR(chip->regmap_s))\n\t\treturn PTR_ERR(chip->regmap_s);\n\n\t \n\tchip->client_t = i2c_new_dummy_device(client->adapter, client->addr + 4);\n\tif (IS_ERR(chip->client_t))\n\t\treturn PTR_ERR(chip->client_t);\n\n\tchip->regmap_t = devm_regmap_init_i2c(chip->client_t, &regmap_config);\n\tif (IS_ERR(chip->regmap_t)) {\n\t\tret = PTR_ERR(chip->regmap_t);\n\t\tgoto err_i2c_t;\n\t}\n\n\tchip->clk_freq = clk_get_rate(chip->mclk);\n\n\tmemcpy(&chip->fe.ops, &mn88443x_ops, sizeof(mn88443x_ops));\n\tchip->fe.demodulator_priv = chip;\n\ti2c_set_clientdata(client, chip);\n\n\tret = mn88443x_cmn_power_on(chip);\n\tif (ret)\n\t\tgoto err_i2c_t;\n\n\tmn88443x_s_sleep(chip);\n\tmn88443x_t_sleep(chip);\n\n\treturn 0;\n\nerr_i2c_t:\n\ti2c_unregister_device(chip->client_t);\n\n\treturn ret;\n}\n\nstatic void mn88443x_remove(struct i2c_client *client)\n{\n\tstruct mn88443x_priv *chip = i2c_get_clientdata(client);\n\n\tmn88443x_cmn_power_off(chip);\n\n\ti2c_unregister_device(chip->client_t);\n}\n\nstatic const struct mn88443x_spec mn88443x_spec_pri = {\n\t.primary = true,\n};\n\nstatic const struct mn88443x_spec mn88443x_spec_sec = {\n\t.primary = false,\n};\n\nstatic const struct of_device_id mn88443x_of_match[] = {\n\t{ .compatible = \"socionext,mn884433\",   .data = &mn88443x_spec_pri, },\n\t{ .compatible = \"socionext,mn884434-0\", .data = &mn88443x_spec_pri, },\n\t{ .compatible = \"socionext,mn884434-1\", .data = &mn88443x_spec_sec, },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mn88443x_of_match);\n\nstatic const struct i2c_device_id mn88443x_i2c_id[] = {\n\t{ \"mn884433\",   (kernel_ulong_t)&mn88443x_spec_pri },\n\t{ \"mn884434-0\", (kernel_ulong_t)&mn88443x_spec_pri },\n\t{ \"mn884434-1\", (kernel_ulong_t)&mn88443x_spec_sec },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, mn88443x_i2c_id);\n\nstatic struct i2c_driver mn88443x_driver = {\n\t.driver = {\n\t\t.name = \"mn88443x\",\n\t\t.of_match_table = mn88443x_of_match,\n\t},\n\t.probe    = mn88443x_probe,\n\t.remove   = mn88443x_remove,\n\t.id_table = mn88443x_i2c_id,\n};\n\nmodule_i2c_driver(mn88443x_driver);\n\nMODULE_AUTHOR(\"Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>\");\nMODULE_DESCRIPTION(\"Socionext MN88443x series demodulator driver.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}