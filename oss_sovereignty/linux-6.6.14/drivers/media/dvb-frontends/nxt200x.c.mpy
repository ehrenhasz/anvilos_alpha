{
  "module_name": "nxt200x.c",
  "hash_id": "2ae6e28e60929026e18a9372f5b85325ae6d116b56d3cf422945168654bedd54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/nxt200x.c",
  "human_readable_source": "\n \n\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n \n#define MAX_XFER_SIZE  256\n\n#define NXT2002_DEFAULT_FIRMWARE \"dvb-fe-nxt2002.fw\"\n#define NXT2004_DEFAULT_FIRMWARE \"dvb-fe-nxt2004.fw\"\n#define CRC_CCIT_MASK 0x1021\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <media/dvb_frontend.h>\n#include \"nxt200x.h\"\n\nstruct nxt200x_state {\n\n\tstruct i2c_adapter* i2c;\n\tconst struct nxt200x_config* config;\n\tstruct dvb_frontend frontend;\n\n\t \n\tnxt_chip_type demod_chip;\n\tu8 initialised:1;\n};\n\nstatic int debug;\n#define dprintk(args...)\tdo { if (debug) pr_debug(args); } while (0)\n\nstatic int i2c_writebytes (struct nxt200x_state* state, u8 addr, u8 *buf, u8 len)\n{\n\tint err;\n\tstruct i2c_msg msg = { .addr = addr, .flags = 0, .buf = buf, .len = len };\n\n\tif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\n\t\tpr_warn(\"%s: i2c write error (addr 0x%02x, err == %i)\\n\",\n\t\t\t__func__, addr, err);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int i2c_readbytes(struct nxt200x_state *state, u8 addr, u8 *buf, u8 len)\n{\n\tint err;\n\tstruct i2c_msg msg = { .addr = addr, .flags = I2C_M_RD, .buf = buf, .len = len };\n\n\tif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\n\t\tpr_warn(\"%s: i2c read error (addr 0x%02x, err == %i)\\n\",\n\t\t\t__func__, addr, err);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int nxt200x_writebytes (struct nxt200x_state* state, u8 reg,\n\t\t\t       const u8 *buf, u8 len)\n{\n\tu8 buf2[MAX_XFER_SIZE];\n\tint err;\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf2, .len = len + 1 };\n\n\tif (1 + len > sizeof(buf2)) {\n\t\tpr_warn(\"%s: i2c wr reg=%04x: len=%d is too big!\\n\",\n\t\t\t __func__, reg, len);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf2[0] = reg;\n\tmemcpy(&buf2[1], buf, len);\n\n\tif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\n\t\tpr_warn(\"%s: i2c write error (addr 0x%02x, err == %i)\\n\",\n\t\t\t__func__, state->config->demod_address, err);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int nxt200x_readbytes(struct nxt200x_state *state, u8 reg, u8 *buf, u8 len)\n{\n\tu8 reg2 [] = { reg };\n\n\tstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = reg2, .len = 1 },\n\t\t\t{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = buf, .len = len } };\n\n\tint err;\n\n\tif ((err = i2c_transfer (state->i2c, msg, 2)) != 2) {\n\t\tpr_warn(\"%s: i2c read error (addr 0x%02x, err == %i)\\n\",\n\t\t\t__func__, state->config->demod_address, err);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic u16 nxt200x_crc(u16 crc, u8 c)\n{\n\tu8 i;\n\tu16 input = (u16) c & 0xFF;\n\n\tinput<<=8;\n\tfor(i=0; i<8; i++) {\n\t\tif((crc^input) & 0x8000)\n\t\t\tcrc=(crc<<1)^CRC_CCIT_MASK;\n\t\telse\n\t\t\tcrc<<=1;\n\t\tinput<<=1;\n\t}\n\treturn crc;\n}\n\nstatic int nxt200x_writereg_multibyte (struct nxt200x_state* state, u8 reg, u8* data, u8 len)\n{\n\tu8 attr, len2, buf;\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tnxt200x_writebytes(state, 0x35, &reg, 1);\n\n\t \n\tnxt200x_writebytes(state, 0x36, data, len);\n\n\tswitch (state->demod_chip) {\n\t\tcase NXT2002:\n\t\t\tlen2 = len;\n\t\t\tbuf = 0x02;\n\t\t\tbreak;\n\t\tcase NXT2004:\n\t\t\t \n\t\t\tattr = 0x02;\n\t\t\tif (reg & 0x80) {\n\t\t\t\tattr = attr << 1;\n\t\t\t\tif (reg & 0x04)\n\t\t\t\t\tattr = attr >> 1;\n\t\t\t}\n\t\t\t \n\t\t\tlen2 = ((attr << 4) | 0x10) | len;\n\t\t\tbuf = 0x80;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tnxt200x_writebytes(state, 0x34, &len2, 1);\n\n\t \n\tnxt200x_writebytes(state, 0x21, &buf, 1);\n\n\tnxt200x_readbytes(state, 0x21, &buf, 1);\n\n\tswitch (state->demod_chip) {\n\t\tcase NXT2002:\n\t\t\tif ((buf & 0x02) == 0)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase NXT2004:\n\t\t\tif (buf == 0)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tpr_warn(\"Error writing multireg register 0x%02X\\n\", reg);\n\n\treturn 0;\n}\n\nstatic int nxt200x_readreg_multibyte (struct nxt200x_state* state, u8 reg, u8* data, u8 len)\n{\n\tint i;\n\tu8 buf, len2, attr;\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tnxt200x_writebytes(state, 0x35, &reg, 1);\n\n\tswitch (state->demod_chip) {\n\t\tcase NXT2002:\n\t\t\t \n\t\t\tlen2 = len & 0x80;\n\t\t\tnxt200x_writebytes(state, 0x34, &len2, 1);\n\n\t\t\t \n\t\t\tnxt200x_readbytes(state, reg, data, len);\n\t\t\treturn 0;\n\t\tcase NXT2004:\n\t\t\t \n\t\t\tattr = 0x02;\n\t\t\tif (reg & 0x80) {\n\t\t\t\tattr = attr << 1;\n\t\t\t\tif (reg & 0x04)\n\t\t\t\t\tattr = attr >> 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tlen2 = (attr << 4) | len;\n\t\t\tnxt200x_writebytes(state, 0x34, &len2, 1);\n\n\t\t\t \n\t\t\tbuf = 0x80;\n\t\t\tnxt200x_writebytes(state, 0x21, &buf, 1);\n\n\t\t\t \n\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\tnxt200x_readbytes(state, 0x36 + i, &data[i], 1);\n\t\t\t}\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n}\n\nstatic void nxt200x_microcontroller_stop (struct nxt200x_state* state)\n{\n\tu8 buf, stopval, counter = 0;\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tswitch (state->demod_chip) {\n\t\tcase NXT2002:\n\t\t\tstopval = 0x40;\n\t\t\tbreak;\n\t\tcase NXT2004:\n\t\t\tstopval = 0x10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstopval = 0;\n\t\t\tbreak;\n\t}\n\n\tbuf = 0x80;\n\tnxt200x_writebytes(state, 0x22, &buf, 1);\n\n\twhile (counter < 20) {\n\t\tnxt200x_readbytes(state, 0x31, &buf, 1);\n\t\tif (buf & stopval)\n\t\t\treturn;\n\t\tmsleep(10);\n\t\tcounter++;\n\t}\n\n\tpr_warn(\"Timeout waiting for nxt200x to stop. This is ok after firmware upload.\\n\");\n\treturn;\n}\n\nstatic void nxt200x_microcontroller_start (struct nxt200x_state* state)\n{\n\tu8 buf;\n\tdprintk(\"%s\\n\", __func__);\n\n\tbuf = 0x00;\n\tnxt200x_writebytes(state, 0x22, &buf, 1);\n}\n\nstatic void nxt2004_microcontroller_init (struct nxt200x_state* state)\n{\n\tu8 buf[9];\n\tu8 counter = 0;\n\tdprintk(\"%s\\n\", __func__);\n\n\tbuf[0] = 0x00;\n\tnxt200x_writebytes(state, 0x2b, buf, 1);\n\tbuf[0] = 0x70;\n\tnxt200x_writebytes(state, 0x34, buf, 1);\n\tbuf[0] = 0x04;\n\tnxt200x_writebytes(state, 0x35, buf, 1);\n\tbuf[0] = 0x01; buf[1] = 0x23; buf[2] = 0x45; buf[3] = 0x67; buf[4] = 0x89;\n\tbuf[5] = 0xAB; buf[6] = 0xCD; buf[7] = 0xEF; buf[8] = 0xC0;\n\tnxt200x_writebytes(state, 0x36, buf, 9);\n\tbuf[0] = 0x80;\n\tnxt200x_writebytes(state, 0x21, buf, 1);\n\n\twhile (counter < 20) {\n\t\tnxt200x_readbytes(state, 0x21, buf, 1);\n\t\tif (buf[0] == 0)\n\t\t\treturn;\n\t\tmsleep(10);\n\t\tcounter++;\n\t}\n\n\tpr_warn(\"Timeout waiting for nxt2004 to init.\\n\");\n\n\treturn;\n}\n\nstatic int nxt200x_writetuner (struct nxt200x_state* state, u8* data)\n{\n\tu8 buf, count = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tdprintk(\"Tuner Bytes: %*ph\\n\", 4, data + 1);\n\n\t \n\tswitch (state->demod_chip) {\n\t\tcase NXT2004:\n\t\t\tif (i2c_writebytes(state, data[0], data+1, 4))\n\t\t\t\tpr_warn(\"error writing to tuner\\n\");\n\t\t\t \n\t\t\twhile (count < 20) {\n\t\t\t\ti2c_readbytes(state, data[0], &buf, 1);\n\t\t\t\tif (buf & 0x40)\n\t\t\t\t\treturn 0;\n\t\t\t\tmsleep(100);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tpr_warn(\"timeout waiting for tuner lock\\n\");\n\t\t\tbreak;\n\t\tcase NXT2002:\n\t\t\t \n\t\t\tbuf = 0x03;\n\t\t\tnxt200x_writebytes(state, 0x20, &buf, 1);\n\n\t\t\t \n\t\t\tbuf = 0x04;\n\t\t\tnxt200x_writebytes(state, 0x34, &buf, 1);\n\n\t\t\t \n\t\t\tnxt200x_writebytes(state, 0x36, data+1, 4);\n\n\t\t\t \n\t\t\tbuf = data[0] << 1;\n\t\t\tnxt200x_writebytes(state, 0x35, &buf, 1);\n\n\t\t\t \n\t\t\tbuf = 0x80;\n\t\t\tnxt200x_writebytes(state, 0x21, &buf, 1);\n\n\t\t\twhile (count < 20) {\n\t\t\t\tnxt200x_readbytes(state, 0x21, &buf, 1);\n\t\t\t\tif ((buf & 0x80)== 0x00)\n\t\t\t\t\treturn 0;\n\t\t\t\tmsleep(100);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tpr_warn(\"timeout error writing to tuner\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void nxt200x_agc_reset(struct nxt200x_state* state)\n{\n\tu8 buf;\n\tdprintk(\"%s\\n\", __func__);\n\n\tswitch (state->demod_chip) {\n\t\tcase NXT2002:\n\t\t\tbuf = 0x08;\n\t\t\tnxt200x_writebytes(state, 0x08, &buf, 1);\n\t\t\tbuf = 0x00;\n\t\t\tnxt200x_writebytes(state, 0x08, &buf, 1);\n\t\t\tbreak;\n\t\tcase NXT2004:\n\t\t\tnxt200x_readreg_multibyte(state, 0x08, &buf, 1);\n\t\t\tbuf = 0x08;\n\t\t\tnxt200x_writereg_multibyte(state, 0x08, &buf, 1);\n\t\t\tbuf = 0x00;\n\t\t\tnxt200x_writereg_multibyte(state, 0x08, &buf, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn;\n}\n\nstatic int nxt2002_load_firmware (struct dvb_frontend* fe, const struct firmware *fw)\n{\n\n\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tu8 buf[3], written = 0, chunkpos = 0;\n\tu16 rambase, position, crc = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\tdprintk(\"Firmware is %zu bytes\\n\", fw->size);\n\n\t \n\tnxt200x_readbytes(state, 0x10, buf, 1);\n\n\tif (buf[0] & 0x10)\n\t\trambase = 0x1000;\n\telse\n\t\trambase = 0x0000;\n\n\tdprintk(\"rambase on this nxt2002 is %04X\\n\", rambase);\n\n\t \n\tbuf[0] = 0x80;\n\tnxt200x_writebytes(state, 0x2B, buf, 1);\n\n\tfor (position = 0; position < fw->size; position++) {\n\t\tif (written == 0) {\n\t\t\tcrc = 0;\n\t\t\tchunkpos = 0x28;\n\t\t\tbuf[0] = ((rambase + position) >> 8);\n\t\t\tbuf[1] = (rambase + position) & 0xFF;\n\t\t\tbuf[2] = 0x81;\n\t\t\t \n\t\t\tnxt200x_writebytes(state, 0x29, buf, 3);\n\t\t}\n\t\twritten++;\n\t\tchunkpos++;\n\n\t\tif ((written % 4) == 0)\n\t\t\tnxt200x_writebytes(state, chunkpos, &fw->data[position-3], 4);\n\n\t\tcrc = nxt200x_crc(crc, fw->data[position]);\n\n\t\tif ((written == 255) || (position+1 == fw->size)) {\n\t\t\t \n\t\t\tnxt200x_writebytes(state, chunkpos+4-(written %4),\n\t\t\t\t&fw->data[position-(written %4) + 1],\n\t\t\t\twritten %4);\n\t\t\tbuf[0] = crc << 8;\n\t\t\tbuf[1] = crc & 0xFF;\n\n\t\t\t \n\t\t\tnxt200x_writebytes(state, 0x2C, buf, 2);\n\n\t\t\t \n\t\t\tnxt200x_readbytes(state, 0x2A, buf, 1);\n\n\t\t\t \n\t\t\tbuf[0] = 0x80;\n\t\t\tnxt200x_writebytes(state, 0x2B, buf, 1);\n\n\t\t\twritten = 0;\n\t\t}\n\t}\n\n\treturn 0;\n};\n\nstatic int nxt2004_load_firmware (struct dvb_frontend* fe, const struct firmware *fw)\n{\n\n\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tu8 buf[3];\n\tu16 rambase, position, crc=0;\n\n\tdprintk(\"%s\\n\", __func__);\n\tdprintk(\"Firmware is %zu bytes\\n\", fw->size);\n\n\t \n\trambase = 0x1000;\n\n\t \n\tbuf[0] = 0x80;\n\tnxt200x_writebytes(state, 0x2B, buf,1);\n\n\t \n\tfor (position = 0; position < fw->size; position++) {\n\t\tcrc = nxt200x_crc(crc, fw->data[position]);\n\t}\n\n\tbuf[0] = rambase >> 8;\n\tbuf[1] = rambase & 0xFF;\n\tbuf[2] = 0x81;\n\t \n\tnxt200x_writebytes(state,0x29,buf,3);\n\n\tfor (position = 0; position < fw->size;) {\n\t\tnxt200x_writebytes(state, 0x2C, &fw->data[position],\n\t\t\tfw->size-position > 255 ? 255 : fw->size-position);\n\t\tposition += (fw->size-position > 255 ? 255 : fw->size-position);\n\t}\n\tbuf[0] = crc >> 8;\n\tbuf[1] = crc & 0xFF;\n\n\tdprintk(\"firmware crc is 0x%02X 0x%02X\\n\", buf[0], buf[1]);\n\n\t \n\tnxt200x_writebytes(state, 0x2C, buf,2);\n\n\t \n\tnxt200x_readbytes(state, 0x2C, buf, 1);\n\n\t \n\tbuf[0] = 0x80;\n\tnxt200x_writebytes(state, 0x2B, buf,1);\n\n\treturn 0;\n};\n\nstatic int nxt200x_setup_frontend_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tu8 buf[5];\n\n\t \n\tnxt200x_microcontroller_stop(state);\n\n\tif (state->demod_chip == NXT2004) {\n\t\t \n\t\tbuf[0] = 0x04;\n\t\tnxt200x_writebytes(state, 0x14, buf, 1);\n\t\tbuf[0] = 0x00;\n\t\tnxt200x_writebytes(state, 0x17, buf, 1);\n\t}\n\n\t \n\tswitch (p->modulation) {\n\t\tcase QAM_64:\n\t\tcase QAM_256:\n\t\t\t \n\t\t\t \n\t\t\tif (state->config->set_ts_params)\n\t\t\t\tstate->config->set_ts_params(fe, 1);\n\t\t\tbreak;\n\t\tcase VSB_8:\n\t\t\t \n\t\t\tif (state->config->set_ts_params)\n\t\t\t\tstate->config->set_ts_params(fe, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (fe->ops.tuner_ops.calc_regs) {\n\t\t \n\t\tfe->ops.tuner_ops.calc_regs(fe, buf, 5);\n\n\t\t \n\t\tnxt200x_writetuner(state, buf);\n\t}\n\n\t \n\tnxt200x_agc_reset(state);\n\n\t \n\tswitch (p->modulation) {\n\t\tcase QAM_64:\n\t\tcase QAM_256:\n\t\t\tbuf[0] = 0x74;\n\t\t\tbreak;\n\t\tcase VSB_8:\n\t\t\tbuf[0] = 0x70;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\tnxt200x_writebytes(state, 0x42, buf, 1);\n\n\t \n\tswitch (state->demod_chip) {\n\t\tcase NXT2002:\n\t\t\tbuf[0] = 0x87;\n\t\t\tbreak;\n\t\tcase NXT2004:\n\t\t\tbuf[0] = 0x07;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\tnxt200x_writebytes(state, 0x57, buf, 1);\n\n\t \n\tbuf[0] = 0x10;\n\tbuf[1] = 0x00;\n\tswitch (state->demod_chip) {\n\t\tcase NXT2002:\n\t\t\tnxt200x_writereg_multibyte(state, 0x58, buf, 2);\n\t\t\tbreak;\n\t\tcase NXT2004:\n\t\t\tnxt200x_writebytes(state, 0x58, buf, 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (p->modulation) {\n\t\tcase QAM_64:\n\t\t\t\tbuf[0] = 0x68;\n\t\t\t\tbreak;\n\t\tcase QAM_256:\n\t\t\t\tbuf[0] = 0x64;\n\t\t\t\tbreak;\n\t\tcase VSB_8:\n\t\t\t\tbuf[0] = 0x60;\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t}\n\tbuf[1] = 0x00;\n\tswitch (state->demod_chip) {\n\t\tcase NXT2002:\n\t\t\tnxt200x_writereg_multibyte(state, 0x5C, buf, 2);\n\t\t\tbreak;\n\t\tcase NXT2004:\n\t\t\tnxt200x_writebytes(state, 0x5C, buf, 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tbuf[0] = 0x05;\n\tnxt200x_writebytes(state, 0x43, buf, 1);\n\n\tif (state->demod_chip == NXT2004) {\n\t\t \n\t\tbuf[0] = 0x00;\n\t\tbuf[1] = 0x00;\n\t\tnxt200x_writebytes(state, 0x46, buf, 2);\n\t}\n\n\t \n\tbuf[0] = 0x80;\n\tbuf[1] = 0x00;\n\tswitch (state->demod_chip) {\n\t\tcase NXT2002:\n\t\t\tnxt200x_writereg_multibyte(state, 0x4B, buf, 2);\n\t\t\tbreak;\n\t\tcase NXT2004:\n\t\t\tnxt200x_writebytes(state, 0x4B, buf, 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tbuf[0] = 0x00;\n\tnxt200x_writebytes(state, 0x4D, buf, 1);\n\n\t \n\tbuf[0] = 0x44;\n\tnxt200x_writebytes(state, 0x55, buf, 1);\n\n\t \n\tbuf[0] = 0x04;\n\tnxt200x_writebytes(state, 0x41, buf, 1);\n\n\tif (state->demod_chip == NXT2004) {\n\t\tnxt200x_readreg_multibyte(state, 0x80, buf, 1);\n\t\tbuf[0] = 0x24;\n\t\tnxt200x_writereg_multibyte(state, 0x80, buf, 1);\n\n\t\t \n\t\tnxt200x_readreg_multibyte(state, 0x08, buf, 1);\n\t\tbuf[0] = 0x10;\n\t\tnxt200x_writereg_multibyte(state, 0x08, buf, 1);\n\t\tnxt200x_readreg_multibyte(state, 0x08, buf, 1);\n\t\tbuf[0] = 0x00;\n\t\tnxt200x_writereg_multibyte(state, 0x08, buf, 1);\n\n\t\tnxt200x_readreg_multibyte(state, 0x80, buf, 1);\n\t\tbuf[0] = 0x04;\n\t\tnxt200x_writereg_multibyte(state, 0x80, buf, 1);\n\t\tbuf[0] = 0x00;\n\t\tnxt200x_writereg_multibyte(state, 0x81, buf, 1);\n\t\tbuf[0] = 0x80; buf[1] = 0x00; buf[2] = 0x00;\n\t\tnxt200x_writereg_multibyte(state, 0x82, buf, 3);\n\t\tnxt200x_readreg_multibyte(state, 0x88, buf, 1);\n\t\tbuf[0] = 0x11;\n\t\tnxt200x_writereg_multibyte(state, 0x88, buf, 1);\n\t\tnxt200x_readreg_multibyte(state, 0x80, buf, 1);\n\t\tbuf[0] = 0x44;\n\t\tnxt200x_writereg_multibyte(state, 0x80, buf, 1);\n\t}\n\n\t \n\tswitch (p->modulation) {\n\t\tcase QAM_64:\n\t\t\t\tbuf[0] = 0x02;\n\t\t\t\tbreak;\n\t\tcase QAM_256:\n\t\t\t\tbuf[0] = 0x03;\n\t\t\t\tbreak;\n\t\tcase VSB_8:\n\t\t\t\tbuf[0] = 0x00;\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t}\n\tnxt200x_writebytes(state, 0x30, buf, 1);\n\n\t \n\tbuf[0] = 0x00;\n\tnxt200x_writebytes(state, 0x41, buf, 1);\n\n\t \n\tbuf[0] = 0x80;\n\tbuf[1] = 0x00;\n\tswitch (state->demod_chip) {\n\t\tcase NXT2002:\n\t\t\tnxt200x_writereg_multibyte(state, 0x49, buf, 2);\n\t\t\tnxt200x_writereg_multibyte(state, 0x4B, buf, 2);\n\t\t\tbreak;\n\t\tcase NXT2004:\n\t\t\tnxt200x_writebytes(state, 0x49, buf, 2);\n\t\t\tnxt200x_writebytes(state, 0x4B, buf, 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tbuf[0] = 0x04;\n\tnxt200x_writebytes(state, 0x41, buf, 1);\n\n\tnxt200x_microcontroller_start(state);\n\n\tif (state->demod_chip == NXT2004) {\n\t\tnxt2004_microcontroller_init(state);\n\n\t\t \n\t\tbuf[0] = 0xF0;\n\t\tbuf[1] = 0x00;\n\t\tnxt200x_writebytes(state, 0x5C, buf, 2);\n\t}\n\n\t \n\n\treturn 0;\n}\n\nstatic int nxt200x_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tu8 lock;\n\tnxt200x_readbytes(state, 0x31, &lock, 1);\n\n\t*status = 0;\n\tif (lock & 0x20) {\n\t\t*status |= FE_HAS_SIGNAL;\n\t\t*status |= FE_HAS_CARRIER;\n\t\t*status |= FE_HAS_VITERBI;\n\t\t*status |= FE_HAS_SYNC;\n\t\t*status |= FE_HAS_LOCK;\n\t}\n\treturn 0;\n}\n\nstatic int nxt200x_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tu8 b[3];\n\n\tnxt200x_readreg_multibyte(state, 0xE6, b, 3);\n\n\t*ber = ((b[0] << 8) + b[1]) * 8;\n\n\treturn 0;\n}\n\nstatic int nxt200x_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tu8 b[2];\n\tu16 temp = 0;\n\n\t \n\tb[0] = 0x00;\n\tnxt200x_writebytes(state, 0xA1, b, 1);\n\n\t \n\tnxt200x_readreg_multibyte(state, 0xA6, b, 2);\n\n\ttemp = (b[0] << 8) | b[1];\n\t*strength = ((0x7FFF - temp) & 0x0FFF) * 16;\n\n\treturn 0;\n}\n\nstatic int nxt200x_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\n\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tu8 b[2];\n\tu16 temp = 0, temp2;\n\tu32 snrdb = 0;\n\n\t \n\tb[0] = 0x00;\n\tnxt200x_writebytes(state, 0xA1, b, 1);\n\n\t \n\tnxt200x_readreg_multibyte(state, 0xA6, b, 2);\n\n\ttemp = (b[0] << 8) | b[1];\n\ttemp2 = 0x7FFF - temp;\n\n\t \n\tif (temp2 > 0x7F00)\n\t\tsnrdb = 1000*24 + ( 1000*(30-24) * ( temp2 - 0x7F00 ) / ( 0x7FFF - 0x7F00 ) );\n\telse if (temp2 > 0x7EC0)\n\t\tsnrdb = 1000*18 + ( 1000*(24-18) * ( temp2 - 0x7EC0 ) / ( 0x7F00 - 0x7EC0 ) );\n\telse if (temp2 > 0x7C00)\n\t\tsnrdb = 1000*12 + ( 1000*(18-12) * ( temp2 - 0x7C00 ) / ( 0x7EC0 - 0x7C00 ) );\n\telse\n\t\tsnrdb = 1000*0 + ( 1000*(12-0) * ( temp2 - 0 ) / ( 0x7C00 - 0 ) );\n\n\t \n\t*snr = snrdb * (0xFFFF/32000);\n\n\treturn 0;\n}\n\nstatic int nxt200x_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tu8 b[3];\n\n\tnxt200x_readreg_multibyte(state, 0xE6, b, 3);\n\t*ucblocks = b[2];\n\n\treturn 0;\n}\n\nstatic int nxt200x_sleep(struct dvb_frontend* fe)\n{\n\treturn 0;\n}\n\nstatic int nxt2002_init(struct dvb_frontend* fe)\n{\n\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tconst struct firmware *fw;\n\tint ret;\n\tu8 buf[2];\n\n\t \n\tpr_debug(\"%s: Waiting for firmware upload (%s)...\\n\",\n\t\t __func__, NXT2002_DEFAULT_FIRMWARE);\n\tret = request_firmware(&fw, NXT2002_DEFAULT_FIRMWARE,\n\t\t\t       state->i2c->dev.parent);\n\tpr_debug(\"%s: Waiting for firmware upload(2)...\\n\", __func__);\n\tif (ret) {\n\t\tpr_err(\"%s: No firmware uploaded (timeout or file not found?)\\n\",\n\t\t       __func__);\n\t\treturn ret;\n\t}\n\n\tret = nxt2002_load_firmware(fe, fw);\n\trelease_firmware(fw);\n\tif (ret) {\n\t\tpr_err(\"%s: Writing firmware to device failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\tpr_info(\"%s: Firmware upload complete\\n\", __func__);\n\n\t \n\tnxt200x_microcontroller_stop(state);\n\n\t \n\tbuf[0]=0x00;\n\tnxt200x_writebytes(state, 0x2B, buf, 1);\n\n\t \n\tnxt200x_microcontroller_stop(state);\n\n\t \n\tbuf[0] = 0x0F;\n\tnxt200x_writebytes(state, 0x08, buf, 1);\n\tbuf[0] = 0x00;\n\tnxt200x_writebytes(state, 0x08, buf, 1);\n\n\t \n\tbuf[0] = 0xF1;\n\tnxt200x_writebytes(state, 0x57, buf, 1);\n\n\t \n\tbuf[0] = 0x20;\n\tnxt200x_writebytes(state, 0x09, buf, 1);\n\n\t \n\tbuf[0] = 0x7E;\n\tbuf[1] = 0x00;\n\tnxt200x_writebytes(state, 0xE9, buf, 2);\n\n\t \n\tbuf[0] = 0x00;\n\tnxt200x_writebytes(state, 0xCC, buf, 1);\n\n\treturn 0;\n}\n\nstatic int nxt2004_init(struct dvb_frontend* fe)\n{\n\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tconst struct firmware *fw;\n\tint ret;\n\tu8 buf[3];\n\n\t \n\tbuf[0]=0x00;\n\tnxt200x_writebytes(state, 0x1E, buf, 1);\n\n\t \n\tpr_debug(\"%s: Waiting for firmware upload (%s)...\\n\",\n\t\t __func__, NXT2004_DEFAULT_FIRMWARE);\n\tret = request_firmware(&fw, NXT2004_DEFAULT_FIRMWARE,\n\t\t\t       state->i2c->dev.parent);\n\tpr_debug(\"%s: Waiting for firmware upload(2)...\\n\", __func__);\n\tif (ret) {\n\t\tpr_err(\"%s: No firmware uploaded (timeout or file not found?)\\n\",\n\t\t       __func__);\n\t\treturn ret;\n\t}\n\n\tret = nxt2004_load_firmware(fe, fw);\n\trelease_firmware(fw);\n\tif (ret) {\n\t\tpr_err(\"%s: Writing firmware to device failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\tpr_info(\"%s: Firmware upload complete\\n\", __func__);\n\n\t \n\tbuf[0] = 0x01;\n\tnxt200x_writebytes(state, 0x19, buf, 1);\n\n\tnxt2004_microcontroller_init(state);\n\tnxt200x_microcontroller_stop(state);\n\tnxt200x_microcontroller_stop(state);\n\tnxt2004_microcontroller_init(state);\n\tnxt200x_microcontroller_stop(state);\n\n\t \n\tbuf[0] = 0xFF;\n\tnxt200x_writereg_multibyte(state, 0x08, buf, 1);\n\tbuf[0] = 0x00;\n\tnxt200x_writereg_multibyte(state, 0x08, buf, 1);\n\n\t \n\tbuf[0] = 0xD7;\n\tnxt200x_writebytes(state, 0x57, buf, 1);\n\n\t \n\tbuf[0] = 0x07;\n\tbuf[1] = 0xfe;\n\tnxt200x_writebytes(state, 0x35, buf, 2);\n\tbuf[0] = 0x12;\n\tnxt200x_writebytes(state, 0x34, buf, 1);\n\tbuf[0] = 0x80;\n\tnxt200x_writebytes(state, 0x21, buf, 1);\n\n\t \n\tbuf[0] = 0x21;\n\tnxt200x_writebytes(state, 0x0A, buf, 1);\n\n\t \n\tbuf[0] = 0x01;\n\tnxt200x_writereg_multibyte(state, 0x80, buf, 1);\n\n\t \n\tbuf[0] = 0x7E;\n\tbuf[1] = 0x00;\n\tnxt200x_writebytes(state, 0xE9, buf, 2);\n\n\t \n\tbuf[0] = 0x00;\n\tnxt200x_writebytes(state, 0xCC, buf, 1);\n\n\t \n\tnxt200x_readreg_multibyte(state, 0x80, buf, 1);\n\tbuf[0] = 0x00;\n\tnxt200x_writereg_multibyte(state, 0x80, buf, 1);\n\n\t \n\tnxt200x_readreg_multibyte(state, 0x08, buf, 1);\n\tbuf[0] = 0x10;\n\tnxt200x_writereg_multibyte(state, 0x08, buf, 1);\n\tnxt200x_readreg_multibyte(state, 0x08, buf, 1);\n\tbuf[0] = 0x00;\n\tnxt200x_writereg_multibyte(state, 0x08, buf, 1);\n\n\t \n\tnxt200x_readreg_multibyte(state, 0x80, buf, 1);\n\tbuf[0] = 0x01;\n\tnxt200x_writereg_multibyte(state, 0x80, buf, 1);\n\tbuf[0] = 0x70;\n\tnxt200x_writereg_multibyte(state, 0x81, buf, 1);\n\tbuf[0] = 0x31; buf[1] = 0x5E; buf[2] = 0x66;\n\tnxt200x_writereg_multibyte(state, 0x82, buf, 3);\n\n\tnxt200x_readreg_multibyte(state, 0x88, buf, 1);\n\tbuf[0] = 0x11;\n\tnxt200x_writereg_multibyte(state, 0x88, buf, 1);\n\tnxt200x_readreg_multibyte(state, 0x80, buf, 1);\n\tbuf[0] = 0x40;\n\tnxt200x_writereg_multibyte(state, 0x80, buf, 1);\n\n\tnxt200x_readbytes(state, 0x10, buf, 1);\n\tbuf[0] = 0x10;\n\tnxt200x_writebytes(state, 0x10, buf, 1);\n\tnxt200x_readbytes(state, 0x0A, buf, 1);\n\tbuf[0] = 0x21;\n\tnxt200x_writebytes(state, 0x0A, buf, 1);\n\n\tnxt2004_microcontroller_init(state);\n\n\tbuf[0] = 0x21;\n\tnxt200x_writebytes(state, 0x0A, buf, 1);\n\tbuf[0] = 0x7E;\n\tnxt200x_writebytes(state, 0xE9, buf, 1);\n\tbuf[0] = 0x00;\n\tnxt200x_writebytes(state, 0xEA, buf, 1);\n\n\tnxt200x_readreg_multibyte(state, 0x80, buf, 1);\n\tbuf[0] = 0x00;\n\tnxt200x_writereg_multibyte(state, 0x80, buf, 1);\n\tnxt200x_readreg_multibyte(state, 0x80, buf, 1);\n\tbuf[0] = 0x00;\n\tnxt200x_writereg_multibyte(state, 0x80, buf, 1);\n\n\t \n\tnxt200x_readreg_multibyte(state, 0x08, buf, 1);\n\tbuf[0] = 0x10;\n\tnxt200x_writereg_multibyte(state, 0x08, buf, 1);\n\tnxt200x_readreg_multibyte(state, 0x08, buf, 1);\n\tbuf[0] = 0x00;\n\tnxt200x_writereg_multibyte(state, 0x08, buf, 1);\n\n\tnxt200x_readreg_multibyte(state, 0x80, buf, 1);\n\tbuf[0] = 0x04;\n\tnxt200x_writereg_multibyte(state, 0x80, buf, 1);\n\tbuf[0] = 0x00;\n\tnxt200x_writereg_multibyte(state, 0x81, buf, 1);\n\tbuf[0] = 0x80; buf[1] = 0x00; buf[2] = 0x00;\n\tnxt200x_writereg_multibyte(state, 0x82, buf, 3);\n\n\tnxt200x_readreg_multibyte(state, 0x88, buf, 1);\n\tbuf[0] = 0x11;\n\tnxt200x_writereg_multibyte(state, 0x88, buf, 1);\n\n\tnxt200x_readreg_multibyte(state, 0x80, buf, 1);\n\tbuf[0] = 0x44;\n\tnxt200x_writereg_multibyte(state, 0x80, buf, 1);\n\n\t \n\tnxt200x_readbytes(state, 0x10, buf, 1);\n\tbuf[0] = 0x12;\n\tnxt200x_writebytes(state, 0x10, buf, 1);\n\tbuf[0] = 0x04;\n\tnxt200x_writebytes(state, 0x13, buf, 1);\n\tbuf[0] = 0x00;\n\tnxt200x_writebytes(state, 0x16, buf, 1);\n\tbuf[0] = 0x04;\n\tnxt200x_writebytes(state, 0x14, buf, 1);\n\tbuf[0] = 0x00;\n\tnxt200x_writebytes(state, 0x14, buf, 1);\n\tnxt200x_writebytes(state, 0x17, buf, 1);\n\tnxt200x_writebytes(state, 0x14, buf, 1);\n\tnxt200x_writebytes(state, 0x17, buf, 1);\n\n\treturn 0;\n}\n\nstatic int nxt200x_init(struct dvb_frontend* fe)\n{\n\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tint ret = 0;\n\n\tif (!state->initialised) {\n\t\tswitch (state->demod_chip) {\n\t\t\tcase NXT2002:\n\t\t\t\tret = nxt2002_init(fe);\n\t\t\t\tbreak;\n\t\t\tcase NXT2004:\n\t\t\t\tret = nxt2004_init(fe);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tstate->initialised = 1;\n\t}\n\treturn ret;\n}\n\nstatic int nxt200x_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\n{\n\tfesettings->min_delay_ms = 500;\n\tfesettings->step_size = 0;\n\tfesettings->max_drift = 0;\n\treturn 0;\n}\n\nstatic void nxt200x_release(struct dvb_frontend* fe)\n{\n\tstruct nxt200x_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops nxt200x_ops;\n\nstruct dvb_frontend* nxt200x_attach(const struct nxt200x_config* config,\n\t\t\t\t   struct i2c_adapter* i2c)\n{\n\tstruct nxt200x_state* state = NULL;\n\tu8 buf [] = {0,0,0,0,0};\n\n\t \n\tstate = kzalloc(sizeof(struct nxt200x_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->initialised = 0;\n\n\t \n\tnxt200x_readbytes(state, 0x00, buf, 5);\n\tdprintk(\"NXT info: %*ph\\n\", 5, buf);\n\n\t \n\tswitch (buf[0]) {\n\t\tcase 0x04:\n\t\t\tstate->demod_chip = NXT2002;\n\t\t\tpr_info(\"NXT2002 Detected\\n\");\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tstate->demod_chip = NXT2004;\n\t\t\tpr_info(\"NXT2004 Detected\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t}\n\n\t \n\tswitch (state->demod_chip) {\n\t\tcase NXT2002:\n\t\t\tif (buf[0] != 0x04) goto error;\t\t \n\t\t\tif (buf[1] != 0x02) goto error;\t\t \n\t\t\tif (buf[2] != 0x11) goto error;\t\t \n\t\t\tif (buf[3] != 0x20) goto error;\t\t \n\t\t\tif (buf[4] != 0x00) goto error;\t\t \n\t\t\tbreak;\n\t\tcase NXT2004:\n\t\t\tif (buf[0] != 0x05) goto error;\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t}\n\n\t \n\tmemcpy(&state->frontend.ops, &nxt200x_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\tpr_err(\"Unknown/Unsupported NXT chip: %*ph\\n\", 5, buf);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops nxt200x_ops = {\n\t.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },\n\t.info = {\n\t\t.name = \"Nextwave NXT200X VSB/QAM frontend\",\n\t\t.frequency_min_hz =  54 * MHz,\n\t\t.frequency_max_hz = 860 * MHz,\n\t\t.frequency_stepsize_hz = 166666,\t \n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_8VSB | FE_CAN_QAM_64 | FE_CAN_QAM_256\n\t},\n\n\t.release = nxt200x_release,\n\n\t.init = nxt200x_init,\n\t.sleep = nxt200x_sleep,\n\n\t.set_frontend = nxt200x_setup_frontend_parameters,\n\t.get_tune_settings = nxt200x_get_tune_settings,\n\n\t.read_status = nxt200x_read_status,\n\t.read_ber = nxt200x_read_ber,\n\t.read_signal_strength = nxt200x_read_signal_strength,\n\t.read_snr = nxt200x_read_snr,\n\t.read_ucblocks = nxt200x_read_ucblocks,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"NXT200X (ATSC 8VSB & ITU-T J.83 AnnexB 64/256 QAM) Demodulator Driver\");\nMODULE_AUTHOR(\"Kirk Lapray, Michael Krufky, Jean-Francois Thibert, and Taylor Jacob\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(nxt200x_attach);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}