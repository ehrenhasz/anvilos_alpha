{
  "module_name": "cxd2820r_core.c",
  "hash_id": "e50e764a14a6d3e7170c623c3546e01b83117209321d6c3ba6cf4d45e43e7096",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cxd2820r_core.c",
  "human_readable_source": "\n \n\n\n#include \"cxd2820r_priv.h\"\n\n \nint cxd2820r_wr_reg_val_mask_tab(struct cxd2820r_priv *priv,\n\t\t\t\t const struct reg_val_mask *tab, int tab_len)\n{\n\tstruct i2c_client *client = priv->client[0];\n\tint ret;\n\tunsigned int i, reg, mask, val;\n\tstruct regmap *regmap;\n\n\tdev_dbg(&client->dev, \"tab_len=%d\\n\", tab_len);\n\n\tfor (i = 0; i < tab_len; i++) {\n\t\tif ((tab[i].reg >> 16) & 0x1)\n\t\t\tregmap = priv->regmap[1];\n\t\telse\n\t\t\tregmap = priv->regmap[0];\n\n\t\treg = (tab[i].reg >> 0) & 0xffff;\n\t\tval = tab[i].val;\n\t\tmask = tab[i].mask;\n\n\t\tif (mask == 0xff)\n\t\t\tret = regmap_write(regmap, reg, val);\n\t\telse\n\t\t\tret = regmap_write_bits(regmap, reg, mask, val);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nint cxd2820r_gpio(struct dvb_frontend *fe, u8 *gpio)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i;\n\tu8 tmp0, tmp1;\n\n\tdev_dbg(&client->dev, \"delivery_system=%d\\n\", c->delivery_system);\n\n\t \n\tif (!memcmp(gpio, priv->gpio, sizeof(priv->gpio)))\n\t\treturn 0;\n\n\ttmp0 = 0x00;\n\ttmp1 = 0x00;\n\tfor (i = 0; i < sizeof(priv->gpio); i++) {\n\t\t \n\t\tif (gpio[i] & CXD2820R_GPIO_E)\n\t\t\ttmp0 |= (2 << 6) >> (2 * i);\n\t\telse\n\t\t\ttmp0 |= (1 << 6) >> (2 * i);\n\n\t\t \n\t\tif (gpio[i] & CXD2820R_GPIO_I)\n\t\t\ttmp1 |= (1 << (3 + i));\n\t\telse\n\t\t\ttmp1 |= (0 << (3 + i));\n\n\t\t \n\t\tif (gpio[i] & CXD2820R_GPIO_H)\n\t\t\ttmp1 |= (1 << (0 + i));\n\t\telse\n\t\t\ttmp1 |= (0 << (0 + i));\n\n\t\tdev_dbg(&client->dev, \"gpio i=%d %02x %02x\\n\", i, tmp0, tmp1);\n\t}\n\n\tdev_dbg(&client->dev, \"wr gpio=%02x %02x\\n\", tmp0, tmp1);\n\n\t \n\tret = regmap_update_bits(priv->regmap[0], 0x0089, 0xfc, tmp0);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = regmap_update_bits(priv->regmap[0], 0x008e, 0x3f, tmp1);\n\tif (ret)\n\t\tgoto error;\n\n\tmemcpy(priv->gpio, gpio, sizeof(priv->gpio));\n\n\treturn ret;\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int cxd2820r_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"delivery_system=%d\\n\", c->delivery_system);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tret = cxd2820r_init_t(fe);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tret = cxd2820r_set_frontend_t(fe);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tret = cxd2820r_init_t(fe);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tret = cxd2820r_set_frontend_t2(fe);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tret = cxd2820r_init_c(fe);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tret = cxd2820r_set_frontend_c(fe);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid delivery_system\\n\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nerr:\n\treturn ret;\n}\n\nstatic int cxd2820r_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"delivery_system=%d\\n\", c->delivery_system);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tret = cxd2820r_read_status_t(fe, status);\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tret = cxd2820r_read_status_t2(fe, status);\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tret = cxd2820r_read_status_c(fe, status);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int cxd2820r_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t struct dtv_frontend_properties *p)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"delivery_system=%d\\n\", c->delivery_system);\n\n\tif (priv->delivery_system == SYS_UNDEFINED)\n\t\treturn 0;\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tret = cxd2820r_get_frontend_t(fe, p);\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tret = cxd2820r_get_frontend_t2(fe, p);\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tret = cxd2820r_get_frontend_c(fe, p);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int cxd2820r_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tdev_dbg(&client->dev, \"delivery_system=%d\\n\", c->delivery_system);\n\n\t*ber = (priv->post_bit_error - priv->post_bit_error_prev_dvbv3);\n\tpriv->post_bit_error_prev_dvbv3 = priv->post_bit_error;\n\n\treturn 0;\n}\n\nstatic int cxd2820r_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tdev_dbg(&client->dev, \"delivery_system=%d\\n\", c->delivery_system);\n\n\tif (c->strength.stat[0].scale == FE_SCALE_RELATIVE)\n\t\t*strength = c->strength.stat[0].uvalue;\n\telse\n\t\t*strength = 0;\n\n\treturn 0;\n}\n\nstatic int cxd2820r_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tdev_dbg(&client->dev, \"delivery_system=%d\\n\", c->delivery_system);\n\n\tif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL)\n\t\t*snr = div_s64(c->cnr.stat[0].svalue, 100);\n\telse\n\t\t*snr = 0;\n\n\treturn 0;\n}\n\nstatic int cxd2820r_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tdev_dbg(&client->dev, \"delivery_system=%d\\n\", c->delivery_system);\n\n\t*ucblocks = 0;\n\n\treturn 0;\n}\n\nstatic int cxd2820r_init(struct dvb_frontend *fe)\n{\n\treturn 0;\n}\n\nstatic int cxd2820r_sleep(struct dvb_frontend *fe)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"delivery_system=%d\\n\", c->delivery_system);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tret = cxd2820r_sleep_t(fe);\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tret = cxd2820r_sleep_t2(fe);\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tret = cxd2820r_sleep_c(fe);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int cxd2820r_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t      struct dvb_frontend_tune_settings *s)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"delivery_system=%d\\n\", c->delivery_system);\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBT:\n\t\tret = cxd2820r_get_tune_settings_t(fe, s);\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tret = cxd2820r_get_tune_settings_t2(fe, s);\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\t\tret = cxd2820r_get_tune_settings_c(fe, s);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic enum dvbfe_search cxd2820r_search(struct dvb_frontend *fe)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i;\n\tenum fe_status status = 0;\n\n\tdev_dbg(&client->dev, \"delivery_system=%d\\n\", c->delivery_system);\n\n\t \n\tif (priv->last_tune_failed) {\n\t\tif (priv->delivery_system == SYS_DVBT) {\n\t\t\tret = cxd2820r_sleep_t(fe);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\tc->delivery_system = SYS_DVBT2;\n\t\t} else if (priv->delivery_system == SYS_DVBT2) {\n\t\t\tret = cxd2820r_sleep_t2(fe);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\tc->delivery_system = SYS_DVBT;\n\t\t}\n\t}\n\n\t \n\tret = cxd2820r_set_frontend(fe);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tswitch (priv->delivery_system) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBC_ANNEX_A:\n\t\ti = 20;\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\ti = 40;\n\t\tbreak;\n\tcase SYS_UNDEFINED:\n\tdefault:\n\t\ti = 0;\n\t\tbreak;\n\t}\n\n\t \n\tfor (; i > 0; i--) {\n\t\tdev_dbg(&client->dev, \"loop=%d\\n\", i);\n\t\tmsleep(50);\n\t\tret = cxd2820r_read_status(fe, &status);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (status & FE_HAS_LOCK)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (status & FE_HAS_LOCK) {\n\t\tpriv->last_tune_failed = false;\n\t\treturn DVBFE_ALGO_SEARCH_SUCCESS;\n\t} else {\n\t\tpriv->last_tune_failed = true;\n\t\treturn DVBFE_ALGO_SEARCH_AGAIN;\n\t}\n\nerror:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn DVBFE_ALGO_SEARCH_ERROR;\n}\n\nstatic enum dvbfe_algo cxd2820r_get_frontend_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_CUSTOM;\n}\n\nstatic void cxd2820r_release(struct dvb_frontend *fe)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\ti2c_unregister_device(client);\n\n\treturn;\n}\n\nstatic int cxd2820r_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct cxd2820r_priv *priv = fe->demodulator_priv;\n\tstruct i2c_client *client = priv->client[0];\n\n\tdev_dbg_ratelimited(&client->dev, \"enable=%d\\n\", enable);\n\n\treturn regmap_update_bits(priv->regmap[0], 0x00db, 0x01, enable ? 1 : 0);\n}\n\n#ifdef CONFIG_GPIOLIB\nstatic int cxd2820r_gpio_direction_output(struct gpio_chip *chip, unsigned nr,\n\t\tint val)\n{\n\tstruct cxd2820r_priv *priv = gpiochip_get_data(chip);\n\tstruct i2c_client *client = priv->client[0];\n\tu8 gpio[GPIO_COUNT];\n\n\tdev_dbg(&client->dev, \"nr=%u val=%d\\n\", nr, val);\n\n\tmemcpy(gpio, priv->gpio, sizeof(gpio));\n\tgpio[nr] = CXD2820R_GPIO_E | CXD2820R_GPIO_O | (val << 2);\n\n\treturn cxd2820r_gpio(&priv->fe, gpio);\n}\n\nstatic void cxd2820r_gpio_set(struct gpio_chip *chip, unsigned nr, int val)\n{\n\tstruct cxd2820r_priv *priv = gpiochip_get_data(chip);\n\tstruct i2c_client *client = priv->client[0];\n\tu8 gpio[GPIO_COUNT];\n\n\tdev_dbg(&client->dev, \"nr=%u val=%d\\n\", nr, val);\n\n\tmemcpy(gpio, priv->gpio, sizeof(gpio));\n\tgpio[nr] = CXD2820R_GPIO_E | CXD2820R_GPIO_O | (val << 2);\n\n\t(void) cxd2820r_gpio(&priv->fe, gpio);\n\n\treturn;\n}\n\nstatic int cxd2820r_gpio_get(struct gpio_chip *chip, unsigned nr)\n{\n\tstruct cxd2820r_priv *priv = gpiochip_get_data(chip);\n\tstruct i2c_client *client = priv->client[0];\n\n\tdev_dbg(&client->dev, \"nr=%u\\n\", nr);\n\n\treturn (priv->gpio[nr] >> 2) & 0x01;\n}\n#endif\n\nstatic const struct dvb_frontend_ops cxd2820r_ops = {\n\t.delsys = { SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },\n\t \n\t.info = {\n\t\t.name = \"Sony CXD2820R\",\n\n\t\t.caps =\tFE_CAN_FEC_1_2\t\t\t|\n\t\t\tFE_CAN_FEC_2_3\t\t\t|\n\t\t\tFE_CAN_FEC_3_4\t\t\t|\n\t\t\tFE_CAN_FEC_5_6\t\t\t|\n\t\t\tFE_CAN_FEC_7_8\t\t\t|\n\t\t\tFE_CAN_FEC_AUTO\t\t\t|\n\t\t\tFE_CAN_QPSK\t\t\t|\n\t\t\tFE_CAN_QAM_16\t\t\t|\n\t\t\tFE_CAN_QAM_32\t\t\t|\n\t\t\tFE_CAN_QAM_64\t\t\t|\n\t\t\tFE_CAN_QAM_128\t\t\t|\n\t\t\tFE_CAN_QAM_256\t\t\t|\n\t\t\tFE_CAN_QAM_AUTO\t\t\t|\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO\t|\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO\t|\n\t\t\tFE_CAN_HIERARCHY_AUTO\t\t|\n\t\t\tFE_CAN_MUTE_TS\t\t\t|\n\t\t\tFE_CAN_2G_MODULATION\t\t|\n\t\t\tFE_CAN_MULTISTREAM\n\t\t},\n\n\t.release\t\t= cxd2820r_release,\n\t.init\t\t\t= cxd2820r_init,\n\t.sleep\t\t\t= cxd2820r_sleep,\n\n\t.get_tune_settings\t= cxd2820r_get_tune_settings,\n\t.i2c_gate_ctrl\t\t= cxd2820r_i2c_gate_ctrl,\n\n\t.get_frontend\t\t= cxd2820r_get_frontend,\n\n\t.get_frontend_algo\t= cxd2820r_get_frontend_algo,\n\t.search\t\t\t= cxd2820r_search,\n\n\t.read_status\t\t= cxd2820r_read_status,\n\t.read_snr\t\t= cxd2820r_read_snr,\n\t.read_ber\t\t= cxd2820r_read_ber,\n\t.read_ucblocks\t\t= cxd2820r_read_ucblocks,\n\t.read_signal_strength\t= cxd2820r_read_signal_strength,\n};\n\n \nstruct dvb_frontend *cxd2820r_attach(const struct cxd2820r_config *config,\n\t\t\t\t     struct i2c_adapter *adapter,\n\t\t\t\t     int *gpio_chip_base)\n{\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\tstruct cxd2820r_platform_data pdata;\n\n\tpdata.ts_mode = config->ts_mode;\n\tpdata.ts_clk_inv = config->ts_clock_inv;\n\tpdata.if_agc_polarity = config->if_agc_polarity;\n\tpdata.spec_inv = config->spec_inv;\n\tpdata.gpio_chip_base = &gpio_chip_base;\n\tpdata.attach_in_use = true;\n\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrscpy(board_info.type, \"cxd2820r\", I2C_NAME_SIZE);\n\tboard_info.addr = config->i2c_address;\n\tboard_info.platform_data = &pdata;\n\tclient = i2c_new_client_device(adapter, &board_info);\n\tif (!i2c_client_has_driver(client))\n\t\treturn NULL;\n\n\treturn pdata.get_dvb_frontend(client);\n}\nEXPORT_SYMBOL_GPL(cxd2820r_attach);\n\nstatic struct dvb_frontend *cxd2820r_get_dvb_frontend(struct i2c_client *client)\n{\n\tstruct cxd2820r_priv *priv = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\treturn &priv->fe;\n}\n\nstatic int cxd2820r_probe(struct i2c_client *client)\n{\n\tstruct cxd2820r_platform_data *pdata = client->dev.platform_data;\n\tstruct cxd2820r_priv *priv;\n\tint ret, *gpio_chip_base;\n\tunsigned int utmp;\n\tstatic const struct regmap_range_cfg regmap_range_cfg0[] = {\n\t\t{\n\t\t\t.range_min        = 0x0000,\n\t\t\t.range_max        = 0x3fff,\n\t\t\t.selector_reg     = 0x00,\n\t\t\t.selector_mask    = 0xff,\n\t\t\t.selector_shift   = 0,\n\t\t\t.window_start     = 0x00,\n\t\t\t.window_len       = 0x100,\n\t\t},\n\t};\n\tstatic const struct regmap_range_cfg regmap_range_cfg1[] = {\n\t\t{\n\t\t\t.range_min        = 0x0000,\n\t\t\t.range_max        = 0x01ff,\n\t\t\t.selector_reg     = 0x00,\n\t\t\t.selector_mask    = 0xff,\n\t\t\t.selector_shift   = 0,\n\t\t\t.window_start     = 0x00,\n\t\t\t.window_len       = 0x100,\n\t\t},\n\t};\n\tstatic const struct regmap_config regmap_config0 = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0x3fff,\n\t\t.ranges = regmap_range_cfg0,\n\t\t.num_ranges = ARRAY_SIZE(regmap_range_cfg0),\n\t\t.cache_type = REGCACHE_NONE,\n\t};\n\tstatic const struct regmap_config regmap_config1 = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0x01ff,\n\t\t.ranges = regmap_range_cfg1,\n\t\t.num_ranges = ARRAY_SIZE(regmap_range_cfg1),\n\t\t.cache_type = REGCACHE_NONE,\n\t};\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tpriv->client[0] = client;\n\tpriv->fe.demodulator_priv = priv;\n\tpriv->i2c = client->adapter;\n\tpriv->ts_mode = pdata->ts_mode;\n\tpriv->ts_clk_inv = pdata->ts_clk_inv;\n\tpriv->if_agc_polarity = pdata->if_agc_polarity;\n\tpriv->spec_inv = pdata->spec_inv;\n\tgpio_chip_base = *pdata->gpio_chip_base;\n\tpriv->regmap[0] = regmap_init_i2c(priv->client[0], &regmap_config0);\n\tif (IS_ERR(priv->regmap[0])) {\n\t\tret = PTR_ERR(priv->regmap[0]);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tret = regmap_read(priv->regmap[0], 0x00fd, &utmp);\n\tif (ret)\n\t\tgoto err_regmap_0_regmap_exit;\n\n\tdev_dbg(&client->dev, \"chip_id=%02x\\n\", utmp);\n\n\tif (utmp != 0xe1) {\n\t\tret = -ENODEV;\n\t\tgoto err_regmap_0_regmap_exit;\n\t}\n\n\t \n\tpriv->client[1] = i2c_new_dummy_device(client->adapter, client->addr | (1 << 1));\n\tif (IS_ERR(priv->client[1])) {\n\t\tret = PTR_ERR(priv->client[1]);\n\t\tdev_err(&client->dev, \"I2C registration failed\\n\");\n\t\tgoto err_regmap_0_regmap_exit;\n\t}\n\n\tpriv->regmap[1] = regmap_init_i2c(priv->client[1], &regmap_config1);\n\tif (IS_ERR(priv->regmap[1])) {\n\t\tret = PTR_ERR(priv->regmap[1]);\n\t\tgoto err_client_1_i2c_unregister_device;\n\t}\n\n\tif (gpio_chip_base) {\n#ifdef CONFIG_GPIOLIB\n\t\t \n\t\tpriv->gpio_chip.label = KBUILD_MODNAME;\n\t\tpriv->gpio_chip.parent = &client->dev;\n\t\tpriv->gpio_chip.owner = THIS_MODULE;\n\t\tpriv->gpio_chip.direction_output = cxd2820r_gpio_direction_output;\n\t\tpriv->gpio_chip.set = cxd2820r_gpio_set;\n\t\tpriv->gpio_chip.get = cxd2820r_gpio_get;\n\t\tpriv->gpio_chip.base = -1;  \n\t\tpriv->gpio_chip.ngpio = GPIO_COUNT;\n\t\tpriv->gpio_chip.can_sleep = 1;\n\t\tret = gpiochip_add_data(&priv->gpio_chip, priv);\n\t\tif (ret)\n\t\t\tgoto err_regmap_1_regmap_exit;\n\n\t\tdev_dbg(&client->dev, \"gpio_chip.base=%d\\n\",\n\t\t\tpriv->gpio_chip.base);\n\n\t\t*gpio_chip_base = priv->gpio_chip.base;\n#else\n\t\t \n\t\tu8 gpio[GPIO_COUNT];\n\t\tgpio[0] = (*gpio_chip_base >> 0) & 0x07;\n\t\tgpio[1] = (*gpio_chip_base >> 3) & 0x07;\n\t\tgpio[2] = 0;\n\t\tret = cxd2820r_gpio(&priv->fe, gpio);\n\t\tif (ret)\n\t\t\tgoto err_regmap_1_regmap_exit;\n#endif\n\t}\n\n\t \n\tmemcpy(&priv->fe.ops, &cxd2820r_ops, sizeof(priv->fe.ops));\n\tif (!pdata->attach_in_use)\n\t\tpriv->fe.ops.release = NULL;\n\ti2c_set_clientdata(client, priv);\n\n\t \n\tpdata->get_dvb_frontend = cxd2820r_get_dvb_frontend;\n\n\tdev_info(&client->dev, \"Sony CXD2820R successfully identified\\n\");\n\n\treturn 0;\nerr_regmap_1_regmap_exit:\n\tregmap_exit(priv->regmap[1]);\nerr_client_1_i2c_unregister_device:\n\ti2c_unregister_device(priv->client[1]);\nerr_regmap_0_regmap_exit:\n\tregmap_exit(priv->regmap[0]);\nerr_kfree:\n\tkfree(priv);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void cxd2820r_remove(struct i2c_client *client)\n{\n\tstruct cxd2820r_priv *priv = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n#ifdef CONFIG_GPIOLIB\n\tif (priv->gpio_chip.label)\n\t\tgpiochip_remove(&priv->gpio_chip);\n#endif\n\tregmap_exit(priv->regmap[1]);\n\ti2c_unregister_device(priv->client[1]);\n\n\tregmap_exit(priv->regmap[0]);\n\n\tkfree(priv);\n}\n\nstatic const struct i2c_device_id cxd2820r_id_table[] = {\n\t{\"cxd2820r\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, cxd2820r_id_table);\n\nstatic struct i2c_driver cxd2820r_driver = {\n\t.driver = {\n\t\t.name                = \"cxd2820r\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe    = cxd2820r_probe,\n\t.remove   = cxd2820r_remove,\n\t.id_table = cxd2820r_id_table,\n};\n\nmodule_i2c_driver(cxd2820r_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Sony CXD2820R demodulator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}