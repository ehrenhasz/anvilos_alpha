{
  "module_name": "cxd2841er.c",
  "hash_id": "0d2791fc02da4d8043183eed7756bcd09e172368455bba67c3ea0b5179809772",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cxd2841er.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/math64.h>\n#include <linux/log2.h>\n#include <linux/dynamic_debug.h>\n#include <linux/kernel.h>\n\n#include <linux/int_log.h>\n#include <media/dvb_frontend.h>\n#include \"cxd2841er.h\"\n#include \"cxd2841er_priv.h\"\n\n#define MAX_WRITE_REGSIZE\t16\n#define LOG2_E_100X 144\n\n#define INTLOG10X100(x) ((u32) (((u64) intlog10(x) * 100) >> 24))\n\n \nenum sony_dvbc_constellation_t {\n\tSONY_DVBC_CONSTELLATION_16QAM,\n\tSONY_DVBC_CONSTELLATION_32QAM,\n\tSONY_DVBC_CONSTELLATION_64QAM,\n\tSONY_DVBC_CONSTELLATION_128QAM,\n\tSONY_DVBC_CONSTELLATION_256QAM\n};\n\nenum cxd2841er_state {\n\tSTATE_SHUTDOWN = 0,\n\tSTATE_SLEEP_S,\n\tSTATE_ACTIVE_S,\n\tSTATE_SLEEP_TC,\n\tSTATE_ACTIVE_TC\n};\n\nstruct cxd2841er_priv {\n\tstruct dvb_frontend\t\tfrontend;\n\tstruct i2c_adapter\t\t*i2c;\n\tu8\t\t\t\ti2c_addr_slvx;\n\tu8\t\t\t\ti2c_addr_slvt;\n\tconst struct cxd2841er_config\t*config;\n\tenum cxd2841er_state\t\tstate;\n\tu8\t\t\t\tsystem;\n\tenum cxd2841er_xtal\t\txtal;\n\tenum fe_caps caps;\n\tu32\t\t\t\tflags;\n\tunsigned long\t\t\tstats_time;\n};\n\nstatic const struct cxd2841er_cnr_data s_cn_data[] = {\n\t{ 0x033e, 0 }, { 0x0339, 100 }, { 0x0333, 200 },\n\t{ 0x032e, 300 }, { 0x0329, 400 }, { 0x0324, 500 },\n\t{ 0x031e, 600 }, { 0x0319, 700 }, { 0x0314, 800 },\n\t{ 0x030f, 900 }, { 0x030a, 1000 }, { 0x02ff, 1100 },\n\t{ 0x02f4, 1200 }, { 0x02e9, 1300 }, { 0x02de, 1400 },\n\t{ 0x02d4, 1500 }, { 0x02c9, 1600 }, { 0x02bf, 1700 },\n\t{ 0x02b5, 1800 }, { 0x02ab, 1900 }, { 0x02a1, 2000 },\n\t{ 0x029b, 2100 }, { 0x0295, 2200 }, { 0x0290, 2300 },\n\t{ 0x028a, 2400 }, { 0x0284, 2500 }, { 0x027f, 2600 },\n\t{ 0x0279, 2700 }, { 0x0274, 2800 }, { 0x026e, 2900 },\n\t{ 0x0269, 3000 }, { 0x0262, 3100 }, { 0x025c, 3200 },\n\t{ 0x0255, 3300 }, { 0x024f, 3400 }, { 0x0249, 3500 },\n\t{ 0x0242, 3600 }, { 0x023c, 3700 }, { 0x0236, 3800 },\n\t{ 0x0230, 3900 }, { 0x022a, 4000 }, { 0x0223, 4100 },\n\t{ 0x021c, 4200 }, { 0x0215, 4300 }, { 0x020e, 4400 },\n\t{ 0x0207, 4500 }, { 0x0201, 4600 }, { 0x01fa, 4700 },\n\t{ 0x01f4, 4800 }, { 0x01ed, 4900 }, { 0x01e7, 5000 },\n\t{ 0x01e0, 5100 }, { 0x01d9, 5200 }, { 0x01d2, 5300 },\n\t{ 0x01cb, 5400 }, { 0x01c4, 5500 }, { 0x01be, 5600 },\n\t{ 0x01b7, 5700 }, { 0x01b1, 5800 }, { 0x01aa, 5900 },\n\t{ 0x01a4, 6000 }, { 0x019d, 6100 }, { 0x0196, 6200 },\n\t{ 0x018f, 6300 }, { 0x0189, 6400 }, { 0x0182, 6500 },\n\t{ 0x017c, 6600 }, { 0x0175, 6700 }, { 0x016f, 6800 },\n\t{ 0x0169, 6900 }, { 0x0163, 7000 }, { 0x015c, 7100 },\n\t{ 0x0156, 7200 }, { 0x0150, 7300 }, { 0x014a, 7400 },\n\t{ 0x0144, 7500 }, { 0x013e, 7600 }, { 0x0138, 7700 },\n\t{ 0x0132, 7800 }, { 0x012d, 7900 }, { 0x0127, 8000 },\n\t{ 0x0121, 8100 }, { 0x011c, 8200 }, { 0x0116, 8300 },\n\t{ 0x0111, 8400 }, { 0x010b, 8500 }, { 0x0106, 8600 },\n\t{ 0x0101, 8700 }, { 0x00fc, 8800 }, { 0x00f7, 8900 },\n\t{ 0x00f2, 9000 }, { 0x00ee, 9100 }, { 0x00ea, 9200 },\n\t{ 0x00e6, 9300 }, { 0x00e2, 9400 }, { 0x00de, 9500 },\n\t{ 0x00da, 9600 }, { 0x00d7, 9700 }, { 0x00d3, 9800 },\n\t{ 0x00d0, 9900 }, { 0x00cc, 10000 }, { 0x00c7, 10100 },\n\t{ 0x00c3, 10200 }, { 0x00bf, 10300 }, { 0x00ba, 10400 },\n\t{ 0x00b6, 10500 }, { 0x00b2, 10600 }, { 0x00ae, 10700 },\n\t{ 0x00aa, 10800 }, { 0x00a7, 10900 }, { 0x00a3, 11000 },\n\t{ 0x009f, 11100 }, { 0x009c, 11200 }, { 0x0098, 11300 },\n\t{ 0x0094, 11400 }, { 0x0091, 11500 }, { 0x008e, 11600 },\n\t{ 0x008a, 11700 }, { 0x0087, 11800 }, { 0x0084, 11900 },\n\t{ 0x0081, 12000 }, { 0x007e, 12100 }, { 0x007b, 12200 },\n\t{ 0x0079, 12300 }, { 0x0076, 12400 }, { 0x0073, 12500 },\n\t{ 0x0071, 12600 }, { 0x006e, 12700 }, { 0x006c, 12800 },\n\t{ 0x0069, 12900 }, { 0x0067, 13000 }, { 0x0065, 13100 },\n\t{ 0x0062, 13200 }, { 0x0060, 13300 }, { 0x005e, 13400 },\n\t{ 0x005c, 13500 }, { 0x005a, 13600 }, { 0x0058, 13700 },\n\t{ 0x0056, 13800 }, { 0x0054, 13900 }, { 0x0052, 14000 },\n\t{ 0x0050, 14100 }, { 0x004e, 14200 }, { 0x004c, 14300 },\n\t{ 0x004b, 14400 }, { 0x0049, 14500 }, { 0x0047, 14600 },\n\t{ 0x0046, 14700 }, { 0x0044, 14800 }, { 0x0043, 14900 },\n\t{ 0x0041, 15000 }, { 0x003f, 15100 }, { 0x003e, 15200 },\n\t{ 0x003c, 15300 }, { 0x003b, 15400 }, { 0x003a, 15500 },\n\t{ 0x0037, 15700 }, { 0x0036, 15800 }, { 0x0034, 15900 },\n\t{ 0x0033, 16000 }, { 0x0032, 16100 }, { 0x0031, 16200 },\n\t{ 0x0030, 16300 }, { 0x002f, 16400 }, { 0x002e, 16500 },\n\t{ 0x002d, 16600 }, { 0x002c, 16700 }, { 0x002b, 16800 },\n\t{ 0x002a, 16900 }, { 0x0029, 17000 }, { 0x0028, 17100 },\n\t{ 0x0027, 17200 }, { 0x0026, 17300 }, { 0x0025, 17400 },\n\t{ 0x0024, 17500 }, { 0x0023, 17600 }, { 0x0022, 17800 },\n\t{ 0x0021, 17900 }, { 0x0020, 18000 }, { 0x001f, 18200 },\n\t{ 0x001e, 18300 }, { 0x001d, 18500 }, { 0x001c, 18700 },\n\t{ 0x001b, 18900 }, { 0x001a, 19000 }, { 0x0019, 19200 },\n\t{ 0x0018, 19300 }, { 0x0017, 19500 }, { 0x0016, 19700 },\n\t{ 0x0015, 19900 }, { 0x0014, 20000 },\n};\n\nstatic const struct cxd2841er_cnr_data s2_cn_data[] = {\n\t{ 0x05af, 0 }, { 0x0597, 100 }, { 0x057e, 200 },\n\t{ 0x0567, 300 }, { 0x0550, 400 }, { 0x0539, 500 },\n\t{ 0x0522, 600 }, { 0x050c, 700 }, { 0x04f6, 800 },\n\t{ 0x04e1, 900 }, { 0x04cc, 1000 }, { 0x04b6, 1100 },\n\t{ 0x04a1, 1200 }, { 0x048c, 1300 }, { 0x0477, 1400 },\n\t{ 0x0463, 1500 }, { 0x044f, 1600 }, { 0x043c, 1700 },\n\t{ 0x0428, 1800 }, { 0x0416, 1900 }, { 0x0403, 2000 },\n\t{ 0x03ef, 2100 }, { 0x03dc, 2200 }, { 0x03c9, 2300 },\n\t{ 0x03b6, 2400 }, { 0x03a4, 2500 }, { 0x0392, 2600 },\n\t{ 0x0381, 2700 }, { 0x036f, 2800 }, { 0x035f, 2900 },\n\t{ 0x034e, 3000 }, { 0x033d, 3100 }, { 0x032d, 3200 },\n\t{ 0x031d, 3300 }, { 0x030d, 3400 }, { 0x02fd, 3500 },\n\t{ 0x02ee, 3600 }, { 0x02df, 3700 }, { 0x02d0, 3800 },\n\t{ 0x02c2, 3900 }, { 0x02b4, 4000 }, { 0x02a6, 4100 },\n\t{ 0x0299, 4200 }, { 0x028c, 4300 }, { 0x027f, 4400 },\n\t{ 0x0272, 4500 }, { 0x0265, 4600 }, { 0x0259, 4700 },\n\t{ 0x024d, 4800 }, { 0x0241, 4900 }, { 0x0236, 5000 },\n\t{ 0x022b, 5100 }, { 0x0220, 5200 }, { 0x0215, 5300 },\n\t{ 0x020a, 5400 }, { 0x0200, 5500 }, { 0x01f6, 5600 },\n\t{ 0x01ec, 5700 }, { 0x01e2, 5800 }, { 0x01d8, 5900 },\n\t{ 0x01cf, 6000 }, { 0x01c6, 6100 }, { 0x01bc, 6200 },\n\t{ 0x01b3, 6300 }, { 0x01aa, 6400 }, { 0x01a2, 6500 },\n\t{ 0x0199, 6600 }, { 0x0191, 6700 }, { 0x0189, 6800 },\n\t{ 0x0181, 6900 }, { 0x0179, 7000 }, { 0x0171, 7100 },\n\t{ 0x0169, 7200 }, { 0x0161, 7300 }, { 0x015a, 7400 },\n\t{ 0x0153, 7500 }, { 0x014b, 7600 }, { 0x0144, 7700 },\n\t{ 0x013d, 7800 }, { 0x0137, 7900 }, { 0x0130, 8000 },\n\t{ 0x012a, 8100 }, { 0x0124, 8200 }, { 0x011e, 8300 },\n\t{ 0x0118, 8400 }, { 0x0112, 8500 }, { 0x010c, 8600 },\n\t{ 0x0107, 8700 }, { 0x0101, 8800 }, { 0x00fc, 8900 },\n\t{ 0x00f7, 9000 }, { 0x00f2, 9100 }, { 0x00ec, 9200 },\n\t{ 0x00e7, 9300 }, { 0x00e2, 9400 }, { 0x00dd, 9500 },\n\t{ 0x00d8, 9600 }, { 0x00d4, 9700 }, { 0x00cf, 9800 },\n\t{ 0x00ca, 9900 }, { 0x00c6, 10000 }, { 0x00c2, 10100 },\n\t{ 0x00be, 10200 }, { 0x00b9, 10300 }, { 0x00b5, 10400 },\n\t{ 0x00b1, 10500 }, { 0x00ae, 10600 }, { 0x00aa, 10700 },\n\t{ 0x00a6, 10800 }, { 0x00a3, 10900 }, { 0x009f, 11000 },\n\t{ 0x009b, 11100 }, { 0x0098, 11200 }, { 0x0095, 11300 },\n\t{ 0x0091, 11400 }, { 0x008e, 11500 }, { 0x008b, 11600 },\n\t{ 0x0088, 11700 }, { 0x0085, 11800 }, { 0x0082, 11900 },\n\t{ 0x007f, 12000 }, { 0x007c, 12100 }, { 0x007a, 12200 },\n\t{ 0x0077, 12300 }, { 0x0074, 12400 }, { 0x0072, 12500 },\n\t{ 0x006f, 12600 }, { 0x006d, 12700 }, { 0x006b, 12800 },\n\t{ 0x0068, 12900 }, { 0x0066, 13000 }, { 0x0064, 13100 },\n\t{ 0x0061, 13200 }, { 0x005f, 13300 }, { 0x005d, 13400 },\n\t{ 0x005b, 13500 }, { 0x0059, 13600 }, { 0x0057, 13700 },\n\t{ 0x0055, 13800 }, { 0x0053, 13900 }, { 0x0051, 14000 },\n\t{ 0x004f, 14100 }, { 0x004e, 14200 }, { 0x004c, 14300 },\n\t{ 0x004a, 14400 }, { 0x0049, 14500 }, { 0x0047, 14600 },\n\t{ 0x0045, 14700 }, { 0x0044, 14800 }, { 0x0042, 14900 },\n\t{ 0x0041, 15000 }, { 0x003f, 15100 }, { 0x003e, 15200 },\n\t{ 0x003c, 15300 }, { 0x003b, 15400 }, { 0x003a, 15500 },\n\t{ 0x0038, 15600 }, { 0x0037, 15700 }, { 0x0036, 15800 },\n\t{ 0x0034, 15900 }, { 0x0033, 16000 }, { 0x0032, 16100 },\n\t{ 0x0031, 16200 }, { 0x0030, 16300 }, { 0x002f, 16400 },\n\t{ 0x002e, 16500 }, { 0x002d, 16600 }, { 0x002c, 16700 },\n\t{ 0x002b, 16800 }, { 0x002a, 16900 }, { 0x0029, 17000 },\n\t{ 0x0028, 17100 }, { 0x0027, 17200 }, { 0x0026, 17300 },\n\t{ 0x0025, 17400 }, { 0x0024, 17500 }, { 0x0023, 17600 },\n\t{ 0x0022, 17800 }, { 0x0021, 17900 }, { 0x0020, 18000 },\n\t{ 0x001f, 18200 }, { 0x001e, 18300 }, { 0x001d, 18500 },\n\t{ 0x001c, 18700 }, { 0x001b, 18900 }, { 0x001a, 19000 },\n\t{ 0x0019, 19200 }, { 0x0018, 19300 }, { 0x0017, 19500 },\n\t{ 0x0016, 19700 }, { 0x0015, 19900 }, { 0x0014, 20000 },\n};\n\nstatic int cxd2841er_freeze_regs(struct cxd2841er_priv *priv);\nstatic int cxd2841er_unfreeze_regs(struct cxd2841er_priv *priv);\n\nstatic void cxd2841er_i2c_debug(struct cxd2841er_priv *priv,\n\t\t\t\tu8 addr, u8 reg, u8 write,\n\t\t\t\tconst u8 *data, u32 len)\n{\n\tdev_dbg(&priv->i2c->dev,\n\t\t\"cxd2841er: I2C %s addr %02x reg 0x%02x size %d data %*ph\\n\",\n\t\t(write == 0 ? \"read\" : \"write\"), addr, reg, len, len, data);\n}\n\nstatic int cxd2841er_write_regs(struct cxd2841er_priv *priv,\n\t\t\t\tu8 addr, u8 reg, const u8 *data, u32 len)\n{\n\tint ret;\n\tu8 buf[MAX_WRITE_REGSIZE + 1];\n\tu8 i2c_addr = (addr == I2C_SLVX ?\n\t\tpriv->i2c_addr_slvx : priv->i2c_addr_slvt);\n\tstruct i2c_msg msg[1] = {\n\t\t{\n\t\t\t.addr = i2c_addr,\n\t\t\t.flags = 0,\n\t\t\t.len = len + 1,\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\n\tif (len + 1 >= sizeof(buf)) {\n\t\tdev_warn(&priv->i2c->dev, \"wr reg=%04x: len=%d is too big!\\n\",\n\t\t\t reg, len + 1);\n\t\treturn -E2BIG;\n\t}\n\n\tcxd2841er_i2c_debug(priv, i2c_addr, reg, 1, data, len);\n\tbuf[0] = reg;\n\tmemcpy(&buf[1], data, len);\n\n\tret = i2c_transfer(priv->i2c, msg, 1);\n\tif (ret >= 0 && ret != 1)\n\t\tret = -EIO;\n\tif (ret < 0) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t\"%s: i2c wr failed=%d addr=%02x reg=%02x len=%d\\n\",\n\t\t\tKBUILD_MODNAME, ret, i2c_addr, reg, len);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int cxd2841er_write_reg(struct cxd2841er_priv *priv,\n\t\t\t       u8 addr, u8 reg, u8 val)\n{\n\tu8 tmp = val;  \n\n\treturn cxd2841er_write_regs(priv, addr, reg, &tmp, 1);\n}\n\nstatic int cxd2841er_read_regs(struct cxd2841er_priv *priv,\n\t\t\t       u8 addr, u8 reg, u8 *val, u32 len)\n{\n\tint ret;\n\tu8 i2c_addr = (addr == I2C_SLVX ?\n\t\tpriv->i2c_addr_slvx : priv->i2c_addr_slvt);\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = i2c_addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &reg,\n\t\t}, {\n\t\t\t.addr = i2c_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = val,\n\t\t}\n\t};\n\n\tret = i2c_transfer(priv->i2c, msg, 2);\n\tif (ret >= 0 && ret != 2)\n\t\tret = -EIO;\n\tif (ret < 0) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t\"%s: i2c rd failed=%d addr=%02x reg=%02x\\n\",\n\t\t\tKBUILD_MODNAME, ret, i2c_addr, reg);\n\t\treturn ret;\n\t}\n\tcxd2841er_i2c_debug(priv, i2c_addr, reg, 0, val, len);\n\treturn 0;\n}\n\nstatic int cxd2841er_read_reg(struct cxd2841er_priv *priv,\n\t\t\t      u8 addr, u8 reg, u8 *val)\n{\n\treturn cxd2841er_read_regs(priv, addr, reg, val, 1);\n}\n\nstatic int cxd2841er_set_reg_bits(struct cxd2841er_priv *priv,\n\t\t\t\t  u8 addr, u8 reg, u8 data, u8 mask)\n{\n\tint res;\n\tu8 rdata;\n\n\tif (mask != 0xff) {\n\t\tres = cxd2841er_read_reg(priv, addr, reg, &rdata);\n\t\tif (res)\n\t\t\treturn res;\n\t\tdata = ((data & mask) | (rdata & (mask ^ 0xFF)));\n\t}\n\treturn cxd2841er_write_reg(priv, addr, reg, data);\n}\n\nstatic u32 cxd2841er_calc_iffreq_xtal(enum cxd2841er_xtal xtal, u32 ifhz)\n{\n\tu64 tmp;\n\n\ttmp = (u64) ifhz * 16777216;\n\tdo_div(tmp, ((xtal == SONY_XTAL_24000) ? 48000000 : 41000000));\n\n\treturn (u32) tmp;\n}\n\nstatic u32 cxd2841er_calc_iffreq(u32 ifhz)\n{\n\treturn cxd2841er_calc_iffreq_xtal(SONY_XTAL_20500, ifhz);\n}\n\nstatic int cxd2841er_get_if_hz(struct cxd2841er_priv *priv, u32 def_hz)\n{\n\tu32 hz;\n\n\tif (priv->frontend.ops.tuner_ops.get_if_frequency\n\t\t\t&& (priv->flags & CXD2841ER_AUTO_IFHZ))\n\t\tpriv->frontend.ops.tuner_ops.get_if_frequency(\n\t\t\t&priv->frontend, &hz);\n\telse\n\t\thz = def_hz;\n\n\treturn hz;\n}\n\nstatic int cxd2841er_tuner_set(struct dvb_frontend *fe)\n{\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\n\tif ((priv->flags & CXD2841ER_USE_GATECTRL) && fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\tif ((priv->flags & CXD2841ER_USE_GATECTRL) && fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\nstatic int cxd2841er_dvbs2_set_symbol_rate(struct cxd2841er_priv *priv,\n\t\t\t\t\t   u32 symbol_rate)\n{\n\tu32 reg_value = 0;\n\tu8 data[3] = {0, 0, 0};\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\t \n\treg_value = DIV_ROUND_CLOSEST(symbol_rate * 16384, 1000);\n\tif ((reg_value == 0) || (reg_value > 0xFFFFF)) {\n\t\tdev_err(&priv->i2c->dev,\n\t\t\t\"%s(): reg_value is out of range\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tdata[0] = (u8)((reg_value >> 16) & 0x0F);\n\tdata[1] = (u8)((reg_value >>  8) & 0xFF);\n\tdata[2] = (u8)(reg_value & 0xFF);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);\n\tcxd2841er_write_regs(priv, I2C_SLVT, 0x20, data, 3);\n\treturn 0;\n}\n\nstatic void cxd2841er_set_ts_clock_mode(struct cxd2841er_priv *priv,\n\t\t\t\t\tu8 system);\n\nstatic int cxd2841er_sleep_s_to_active_s(struct cxd2841er_priv *priv,\n\t\t\t\t\t u8 system, u32 symbol_rate)\n{\n\tint ret;\n\tu8 data[4] = { 0, 0, 0, 0 };\n\n\tif (priv->state != STATE_SLEEP_S) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, (int)priv->state);\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tcxd2841er_set_ts_clock_mode(priv, SYS_DVBS);\n\t \n\tif (system == SYS_DVBS) {\n\t\tdata[0] = 0x0A;\n\t} else if (system == SYS_DVBS2) {\n\t\tdata[0] = 0x0B;\n\t} else {\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid delsys %d\\n\",\n\t\t\t__func__, system);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x17, data[0]);\n\t \n\tdata[0] = 0x00;\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2d, data[0]);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x30, data[0]);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x31, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x3f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa3);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0xac, 0x00);\n\tdata[0] = 0x07;\n\tdata[1] = 0x3B;\n\tdata[2] = 0x08;\n\tdata[3] = 0xC5;\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xab);\n\tcxd2841er_write_regs(priv, I2C_SLVT, 0x98, data, 4);\n\tdata[0] = 0x05;\n\tdata[1] = 0x80;\n\tdata[2] = 0x0A;\n\tdata[3] = 0x80;\n\tcxd2841er_write_regs(priv, I2C_SLVT, 0xa8, data, 4);\n\tdata[0] = 0x0C;\n\tdata[1] = 0xCC;\n\tcxd2841er_write_regs(priv, I2C_SLVT, 0xc3, data, 2);\n\t \n\tret = cxd2841er_dvbs2_set_symbol_rate(priv, symbol_rate);\n\tif (ret != 0)\n\t\treturn ret;\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x10);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\n\tpriv->state = STATE_ACTIVE_S;\n\treturn 0;\n}\n\nstatic int cxd2841er_sleep_tc_to_active_t_band(struct cxd2841er_priv *priv,\n\t\t\t\t\t       u32 bandwidth);\n\nstatic int cxd2841er_sleep_tc_to_active_t2_band(struct cxd2841er_priv *priv,\n\t\t\t\t\t\tu32 bandwidth);\n\nstatic int cxd2841er_sleep_tc_to_active_c_band(struct cxd2841er_priv *priv,\n\t\t\t\t\t       u32 bandwidth);\n\nstatic int cxd2841er_sleep_tc_to_active_i(struct cxd2841er_priv *priv,\n\t\tu32 bandwidth);\n\nstatic int cxd2841er_active_i_to_sleep_tc(struct cxd2841er_priv *priv);\n\nstatic int cxd2841er_sleep_tc_to_shutdown(struct cxd2841er_priv *priv);\n\nstatic int cxd2841er_shutdown_to_sleep_tc(struct cxd2841er_priv *priv);\n\nstatic int cxd2841er_sleep_tc(struct dvb_frontend *fe);\n\nstatic int cxd2841er_retune_active(struct cxd2841er_priv *priv,\n\t\t\t\t   struct dtv_frontend_properties *p)\n{\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_S &&\n\t\t\tpriv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\n\tif (priv->state == STATE_ACTIVE_S)\n\t\treturn cxd2841er_dvbs2_set_symbol_rate(\n\t\t\t\tpriv, p->symbol_rate / 1000);\n\telse if (priv->state == STATE_ACTIVE_TC) {\n\t\tswitch (priv->system) {\n\t\tcase SYS_DVBT:\n\t\t\treturn cxd2841er_sleep_tc_to_active_t_band(\n\t\t\t\t\tpriv, p->bandwidth_hz);\n\t\tcase SYS_DVBT2:\n\t\t\treturn cxd2841er_sleep_tc_to_active_t2_band(\n\t\t\t\t\tpriv, p->bandwidth_hz);\n\t\tcase SYS_DVBC_ANNEX_A:\n\t\t\treturn cxd2841er_sleep_tc_to_active_c_band(\n\t\t\t\t\tpriv, p->bandwidth_hz);\n\t\tcase SYS_ISDBT:\n\t\t\tcxd2841er_active_i_to_sleep_tc(priv);\n\t\t\tcxd2841er_sleep_tc_to_shutdown(priv);\n\t\t\tcxd2841er_shutdown_to_sleep_tc(priv);\n\t\t\treturn cxd2841er_sleep_tc_to_active_i(\n\t\t\t\t\tpriv, p->bandwidth_hz);\n\t\t}\n\t}\n\tdev_dbg(&priv->i2c->dev, \"%s(): invalid delivery system %d\\n\",\n\t\t__func__, priv->system);\n\treturn -EINVAL;\n}\n\nstatic int cxd2841er_active_s_to_sleep_s(struct cxd2841er_priv *priv)\n{\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_S) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x1f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x31, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2d, 0x00);\n\tpriv->state = STATE_SLEEP_S;\n\treturn 0;\n}\n\nstatic int cxd2841er_sleep_s_to_shutdown(struct cxd2841er_priv *priv)\n{\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_SLEEP_S) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid demod state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x9c, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x15, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);\n\tpriv->state = STATE_SHUTDOWN;\n\treturn 0;\n}\n\nstatic int cxd2841er_sleep_tc_to_shutdown(struct cxd2841er_priv *priv)\n{\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_SLEEP_TC) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid demod state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x15, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);\n\tpriv->state = STATE_SHUTDOWN;\n\treturn 0;\n}\n\nstatic int cxd2841er_active_t_to_sleep_tc(struct cxd2841er_priv *priv)\n{\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\n\tpriv->state = STATE_SLEEP_TC;\n\treturn 0;\n}\n\nstatic int cxd2841er_active_t2_to_sleep_tc(struct cxd2841er_priv *priv)\n{\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x83, 0x40);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x86, 0x21);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9e, 0x09, 0x0f);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x9f, 0xfb);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2a);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x38, 0x00, 0x0f);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x11, 0x00, 0x3f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\n\tpriv->state = STATE_SLEEP_TC;\n\treturn 0;\n}\n\nstatic int cxd2841er_active_c_to_sleep_tc(struct cxd2841er_priv *priv)\n{\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa3, 0x00, 0x1f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\n\tpriv->state = STATE_SLEEP_TC;\n\treturn 0;\n}\n\nstatic int cxd2841er_active_i_to_sleep_tc(struct cxd2841er_priv *priv)\n{\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\n\n\t \n\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\n\tpriv->state = STATE_SLEEP_TC;\n\treturn 0;\n}\n\nstatic int cxd2841er_shutdown_to_sleep_s(struct cxd2841er_priv *priv)\n{\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_SHUTDOWN) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid demod state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x02, 0x00);\n\tusleep_range(3000, 5000);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x01);\n\n\tswitch (priv->xtal) {\n\tcase SONY_XTAL_20500:\n\t\tcxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x00);\n\t\tbreak;\n\tcase SONY_XTAL_24000:\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);\n\t\tcxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x03);\n\t\tbreak;\n\tcase SONY_XTAL_41000:\n\t\tcxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x01);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid demod xtal %d\\n\",\n\t\t\t\t__func__, priv->xtal);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x0a);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x00);\n\tusleep_range(1000, 2000);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x1F);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x9C, 0x40);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);\n\tpriv->state = STATE_SLEEP_S;\n\treturn 0;\n}\n\nstatic int cxd2841er_shutdown_to_sleep_tc(struct cxd2841er_priv *priv)\n{\n\tu8 data = 0;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_SHUTDOWN) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid demod state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x02, 0x00);\n\tusleep_range(3000, 5000);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x01);\n   \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x13, 0x00);\n\n\tswitch (priv->xtal) {\n\tcase SONY_XTAL_20500:\n\t\tdata = 0x0;\n\t\tbreak;\n\tcase SONY_XTAL_24000:\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);\n\t\tdata = 0x3;\n\t\tbreak;\n\tcase SONY_XTAL_41000:\n\t\tcxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);\n\t\tdata = 0x1;\n\t\tbreak;\n\t}\n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x14, data);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x00);\n\tusleep_range(1000, 2000);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);\n\tpriv->state = STATE_SLEEP_TC;\n\treturn 0;\n}\n\nstatic int cxd2841er_tune_done(struct cxd2841er_priv *priv)\n{\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0, 0);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0xfe, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x00);\n\treturn 0;\n}\n\n \nstatic void cxd2841er_set_ts_clock_mode(struct cxd2841er_priv *priv,\n\t\t\t\t\tu8 system)\n{\n\tu8 serial_ts, ts_rate_ctrl_off, ts_in_off;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0xc4, &serial_ts);\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0xd3, &ts_rate_ctrl_off);\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0xde, &ts_in_off);\n\tdev_dbg(&priv->i2c->dev, \"%s(): ser_ts=0x%02x rate_ctrl_off=0x%02x in_off=0x%02x\\n\",\n\t\t__func__, serial_ts, ts_rate_ctrl_off, ts_in_off);\n\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc4,\n\t\t((priv->flags & CXD2841ER_TS_SERIAL) ? 0x01 : 0x00), 0x03);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd1,\n\t\t((priv->flags & CXD2841ER_TS_SERIAL) ? 0x01 : 0x00), 0x03);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0xd9, 0x08);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x32, 0x00, 0x01);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x33,\n\t\t((priv->flags & CXD2841ER_TS_SERIAL) ? 0x01 : 0x00), 0x03);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x32, 0x01, 0x01);\n\n\tif (system == SYS_DVBT) {\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x66, 0x01, 0x01);\n\t} else if (system == SYS_DVBC_ANNEX_A) {\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x66, 0x01, 0x01);\n\t}\n}\n\nstatic u8 cxd2841er_chip_id(struct cxd2841er_priv *priv)\n{\n\tu8 chip_id = 0;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (cxd2841er_write_reg(priv, I2C_SLVT, 0, 0) == 0)\n\t\tcxd2841er_read_reg(priv, I2C_SLVT, 0xfd, &chip_id);\n\telse if (cxd2841er_write_reg(priv, I2C_SLVX, 0, 0) == 0)\n\t\tcxd2841er_read_reg(priv, I2C_SLVX, 0xfd, &chip_id);\n\n\treturn chip_id;\n}\n\nstatic int cxd2841er_read_status_s(struct dvb_frontend *fe,\n\t\t\t\t   enum fe_status *status)\n{\n\tu8 reg = 0;\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\t*status = 0;\n\tif (priv->state != STATE_ACTIVE_S) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\n\t \n\tcxd2841er_read_reg(priv, I2C_SLVT, 0x11, &reg);\n\tif (reg & 0x04) {\n\t\t*status = FE_HAS_SIGNAL\n\t\t\t| FE_HAS_CARRIER\n\t\t\t| FE_HAS_VITERBI\n\t\t\t| FE_HAS_SYNC\n\t\t\t| FE_HAS_LOCK;\n\t}\n\tdev_dbg(&priv->i2c->dev, \"%s(): result 0x%x\\n\", __func__, *status);\n\treturn 0;\n}\n\nstatic int cxd2841er_read_status_t_t2(struct cxd2841er_priv *priv,\n\t\t\t\t      u8 *sync, u8 *tslock, u8 *unlock)\n{\n\tu8 data = 0;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC)\n\t\treturn -EINVAL;\n\tif (priv->system == SYS_DVBT) {\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\t} else {\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\n\t}\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);\n\tif ((data & 0x07) == 0x07) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): invalid hardware state detected\\n\", __func__);\n\t\t*sync = 0;\n\t\t*tslock = 0;\n\t\t*unlock = 0;\n\t} else {\n\t\t*sync = ((data & 0x07) == 0x6 ? 1 : 0);\n\t\t*tslock = ((data & 0x20) ? 1 : 0);\n\t\t*unlock = ((data & 0x10) ? 1 : 0);\n\t}\n\treturn 0;\n}\n\nstatic int cxd2841er_read_status_c(struct cxd2841er_priv *priv, u8 *tslock)\n{\n\tu8 data;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC)\n\t\treturn -EINVAL;\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0x88, &data);\n\tif ((data & 0x01) == 0) {\n\t\t*tslock = 0;\n\t} else {\n\t\tcxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);\n\t\t*tslock = ((data & 0x20) ? 1 : 0);\n\t}\n\treturn 0;\n}\n\nstatic int cxd2841er_read_status_i(struct cxd2841er_priv *priv,\n\t\tu8 *sync, u8 *tslock, u8 *unlock)\n{\n\tu8 data = 0;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC)\n\t\treturn -EINVAL;\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);\n\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): lock=0x%x\\n\", __func__, data);\n\t*sync = ((data & 0x02) ? 1 : 0);\n\t*tslock = ((data & 0x01) ? 1 : 0);\n\t*unlock = ((data & 0x10) ? 1 : 0);\n\treturn 0;\n}\n\nstatic int cxd2841er_read_status_tc(struct dvb_frontend *fe,\n\t\t\t\t    enum fe_status *status)\n{\n\tint ret = 0;\n\tu8 sync = 0;\n\tu8 tslock = 0;\n\tu8 unlock = 0;\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\n\t*status = 0;\n\tif (priv->state == STATE_ACTIVE_TC) {\n\t\tif (priv->system == SYS_DVBT || priv->system == SYS_DVBT2) {\n\t\t\tret = cxd2841er_read_status_t_t2(\n\t\t\t\tpriv, &sync, &tslock, &unlock);\n\t\t\tif (ret)\n\t\t\t\tgoto done;\n\t\t\tif (unlock)\n\t\t\t\tgoto done;\n\t\t\tif (sync)\n\t\t\t\t*status = FE_HAS_SIGNAL |\n\t\t\t\t\tFE_HAS_CARRIER |\n\t\t\t\t\tFE_HAS_VITERBI |\n\t\t\t\t\tFE_HAS_SYNC;\n\t\t\tif (tslock)\n\t\t\t\t*status |= FE_HAS_LOCK;\n\t\t} else if (priv->system == SYS_ISDBT) {\n\t\t\tret = cxd2841er_read_status_i(\n\t\t\t\t\tpriv, &sync, &tslock, &unlock);\n\t\t\tif (ret)\n\t\t\t\tgoto done;\n\t\t\tif (unlock)\n\t\t\t\tgoto done;\n\t\t\tif (sync)\n\t\t\t\t*status = FE_HAS_SIGNAL |\n\t\t\t\t\tFE_HAS_CARRIER |\n\t\t\t\t\tFE_HAS_VITERBI |\n\t\t\t\t\tFE_HAS_SYNC;\n\t\t\tif (tslock)\n\t\t\t\t*status |= FE_HAS_LOCK;\n\t\t} else if (priv->system == SYS_DVBC_ANNEX_A) {\n\t\t\tret = cxd2841er_read_status_c(priv, &tslock);\n\t\t\tif (ret)\n\t\t\t\tgoto done;\n\t\t\tif (tslock)\n\t\t\t\t*status = FE_HAS_SIGNAL |\n\t\t\t\t\tFE_HAS_CARRIER |\n\t\t\t\t\tFE_HAS_VITERBI |\n\t\t\t\t\tFE_HAS_SYNC |\n\t\t\t\t\tFE_HAS_LOCK;\n\t\t}\n\t}\ndone:\n\tdev_dbg(&priv->i2c->dev, \"%s(): status 0x%x\\n\", __func__, *status);\n\treturn ret;\n}\n\nstatic int cxd2841er_get_carrier_offset_s_s2(struct cxd2841er_priv *priv,\n\t\t\t\t\t     int *offset)\n{\n\tu8 data[3];\n\tu8 is_hs_mode;\n\ts32 cfrl_ctrlval;\n\ts32 temp_div, temp_q, temp_r;\n\n\tif (priv->state != STATE_ACTIVE_S) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data[0]);\n\tif (data[0] & 0x01) {\n\t\t \n\t\tcxd2841er_read_reg(priv, I2C_SLVT, 0x50, &data[0]);\n\t\tis_hs_mode = (data[0] & 0x10 ? 1 : 0);\n\t} else {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): unable to detect sampling rate mode\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x45, data, 3);\n\tcfrl_ctrlval = sign_extend32((((u32)data[0] & 0x1F) << 16) |\n\t\t\t\t(((u32)data[1] & 0xFF) <<  8) |\n\t\t\t\t((u32)data[2] & 0xFF), 20);\n\ttemp_div = (is_hs_mode ? 1048576 : 1572864);\n\tif (cfrl_ctrlval > 0) {\n\t\ttemp_q = div_s64_rem(97375LL * cfrl_ctrlval,\n\t\t\ttemp_div, &temp_r);\n\t} else {\n\t\ttemp_q = div_s64_rem(-97375LL * cfrl_ctrlval,\n\t\t\ttemp_div, &temp_r);\n\t}\n\tif (temp_r >= temp_div / 2)\n\t\ttemp_q++;\n\tif (cfrl_ctrlval > 0)\n\t\ttemp_q *= -1;\n\t*offset = temp_q;\n\treturn 0;\n}\n\nstatic int cxd2841er_get_carrier_offset_i(struct cxd2841er_priv *priv,\n\t\t\t\t\t   u32 bandwidth, int *offset)\n{\n\tu8 data[4];\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tif (priv->system != SYS_ISDBT) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid delivery system %d\\n\",\n\t\t\t__func__, priv->system);\n\t\treturn -EINVAL;\n\t}\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));\n\t*offset = -1 * sign_extend32(\n\t\t((u32)(data[0] & 0x1F) << 24) | ((u32)data[1] << 16) |\n\t\t((u32)data[2] << 8) | (u32)data[3], 29);\n\n\tswitch (bandwidth) {\n\tcase 6000000:\n\t\t*offset = -1 * ((*offset) * 8/264);\n\t\tbreak;\n\tcase 7000000:\n\t\t*offset = -1 * ((*offset) * 8/231);\n\t\tbreak;\n\tcase 8000000:\n\t\t*offset = -1 * ((*offset) * 8/198);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid bandwidth %d\\n\",\n\t\t\t\t__func__, bandwidth);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): bandwidth %d offset %d\\n\",\n\t\t\t__func__, bandwidth, *offset);\n\n\treturn 0;\n}\n\nstatic int cxd2841er_get_carrier_offset_t(struct cxd2841er_priv *priv,\n\t\t\t\t\t   u32 bandwidth, int *offset)\n{\n\tu8 data[4];\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tif (priv->system != SYS_DVBT) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid delivery system %d\\n\",\n\t\t\t__func__, priv->system);\n\t\treturn -EINVAL;\n\t}\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));\n\t*offset = -1 * sign_extend32(\n\t\t((u32)(data[0] & 0x1F) << 24) | ((u32)data[1] << 16) |\n\t\t((u32)data[2] << 8) | (u32)data[3], 29);\n\t*offset *= (bandwidth / 1000000);\n\t*offset /= 235;\n\treturn 0;\n}\n\nstatic int cxd2841er_get_carrier_offset_t2(struct cxd2841er_priv *priv,\n\t\t\t\t\t   u32 bandwidth, int *offset)\n{\n\tu8 data[4];\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tif (priv->system != SYS_DVBT2) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid delivery system %d\\n\",\n\t\t\t__func__, priv->system);\n\t\treturn -EINVAL;\n\t}\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));\n\t*offset = -1 * sign_extend32(\n\t\t((u32)(data[0] & 0x0F) << 24) | ((u32)data[1] << 16) |\n\t\t((u32)data[2] << 8) | (u32)data[3], 27);\n\tswitch (bandwidth) {\n\tcase 1712000:\n\t\t*offset /= 582;\n\t\tbreak;\n\tcase 5000000:\n\tcase 6000000:\n\tcase 7000000:\n\tcase 8000000:\n\t\t*offset *= (bandwidth / 1000000);\n\t\t*offset /= 940;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid bandwidth %d\\n\",\n\t\t\t__func__, bandwidth);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cxd2841er_get_carrier_offset_c(struct cxd2841er_priv *priv,\n\t\t\t\t\t  int *offset)\n{\n\tu8 data[2];\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tif (priv->system != SYS_DVBC_ANNEX_A) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid delivery system %d\\n\",\n\t\t\t__func__, priv->system);\n\t\treturn -EINVAL;\n\t}\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x15, data, sizeof(data));\n\t*offset = div_s64(41000LL * sign_extend32((((u32)data[0] & 0x3f) << 8)\n\t\t\t\t\t\t| (u32)data[1], 13), 16384);\n\treturn 0;\n}\n\nstatic int cxd2841er_read_packet_errors_c(\n\t\tstruct cxd2841er_priv *priv, u32 *penum)\n{\n\tu8 data[3];\n\n\t*penum = 0;\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0xea, data, sizeof(data));\n\tif (data[2] & 0x01)\n\t\t*penum = ((u32)data[0] << 8) | (u32)data[1];\n\treturn 0;\n}\n\nstatic int cxd2841er_read_packet_errors_t(\n\t\tstruct cxd2841er_priv *priv, u32 *penum)\n{\n\tu8 data[3];\n\n\t*penum = 0;\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0xea, data, sizeof(data));\n\tif (data[2] & 0x01)\n\t\t*penum = ((u32)data[0] << 8) | (u32)data[1];\n\treturn 0;\n}\n\nstatic int cxd2841er_read_packet_errors_t2(\n\t\tstruct cxd2841er_priv *priv, u32 *penum)\n{\n\tu8 data[3];\n\n\t*penum = 0;\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x24);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0xfd, data, sizeof(data));\n\tif (data[0] & 0x01)\n\t\t*penum = ((u32)data[1] << 8) | (u32)data[2];\n\treturn 0;\n}\n\nstatic int cxd2841er_read_packet_errors_i(\n\t\tstruct cxd2841er_priv *priv, u32 *penum)\n{\n\tu8 data[2];\n\n\t*penum = 0;\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0xA1, data, 1);\n\n\tif (!(data[0] & 0x01))\n\t\treturn 0;\n\n\t \n\tcxd2841er_read_regs(priv, I2C_SLVT, 0xA2, data, sizeof(data));\n\t*penum = ((u32)data[0] << 8) | (u32)data[1];\n\n\t \n\tcxd2841er_read_regs(priv, I2C_SLVT, 0xA4, data, sizeof(data));\n\t*penum += ((u32)data[0] << 8) | (u32)data[1];\n\n\t \n\tcxd2841er_read_regs(priv, I2C_SLVT, 0xA6, data, sizeof(data));\n\t*penum += ((u32)data[0] << 8) | (u32)data[1];\n\n\treturn 0;\n}\n\nstatic int cxd2841er_read_ber_c(struct cxd2841er_priv *priv,\n\t\tu32 *bit_error, u32 *bit_count)\n{\n\tu8 data[3];\n\tu32 bit_err, period_exp;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x62, data, sizeof(data));\n\tif (!(data[0] & 0x80)) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\"%s(): no valid BER data\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tbit_err = ((u32)(data[0] & 0x3f) << 16) |\n\t\t((u32)data[1] << 8) |\n\t\t(u32)data[2];\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0x60, data);\n\tperiod_exp = data[0] & 0x1f;\n\n\tif ((period_exp <= 11) && (bit_err > (1 << period_exp) * 204 * 8)) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\"%s(): period_exp(%u) or bit_err(%u)  not in range. no valid BER data\\n\",\n\t\t\t\t__func__, period_exp, bit_err);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): period_exp(%u) or bit_err(%u) count=%d\\n\",\n\t\t\t__func__, period_exp, bit_err,\n\t\t\t((1 << period_exp) * 204 * 8));\n\n\t*bit_error = bit_err;\n\t*bit_count = ((1 << period_exp) * 204 * 8);\n\n\treturn 0;\n}\n\nstatic int cxd2841er_read_ber_i(struct cxd2841er_priv *priv,\n\t\tu32 *bit_error, u32 *bit_count)\n{\n\tu8 data[3];\n\tu8 pktnum[2];\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\n\tcxd2841er_freeze_regs(priv);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x5B, pktnum, sizeof(pktnum));\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x16, data, sizeof(data));\n\tcxd2841er_unfreeze_regs(priv);\n\n\tif (!pktnum[0] && !pktnum[1]) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\"%s(): no valid BER data\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t*bit_error = ((u32)(data[0] & 0x7F) << 16) |\n\t\t((u32)data[1] << 8) | data[2];\n\t*bit_count = ((((u32)pktnum[0] << 8) | pktnum[1]) * 204 * 8);\n\tdev_dbg(&priv->i2c->dev, \"%s(): bit_error=%u bit_count=%u\\n\",\n\t\t\t__func__, *bit_error, *bit_count);\n\n\treturn 0;\n}\n\nstatic int cxd2841er_mon_read_ber_s(struct cxd2841er_priv *priv,\n\t\t\t\t    u32 *bit_error, u32 *bit_count)\n{\n\tu8 data[11];\n\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\n\t \n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x35, data, 11);\n\tif (data[0] & 0x01) {\n\t\t*bit_error = ((u32)(data[1]  & 0x3F) << 16) |\n\t\t\t     ((u32)(data[2]  & 0xFF) <<  8) |\n\t\t\t     (u32)(data[3]  & 0xFF);\n\t\t*bit_count = ((u32)(data[8]  & 0x3F) << 16) |\n\t\t\t     ((u32)(data[9]  & 0xFF) <<  8) |\n\t\t\t     (u32)(data[10] & 0xFF);\n\t\tif ((*bit_count == 0) || (*bit_error > *bit_count)) {\n\t\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\"%s(): invalid bit_error %d, bit_count %d\\n\",\n\t\t\t\t__func__, *bit_error, *bit_count);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\tdev_dbg(&priv->i2c->dev, \"%s(): no data available\\n\", __func__);\n\treturn -EINVAL;\n}\n\n\nstatic int cxd2841er_mon_read_ber_s2(struct cxd2841er_priv *priv,\n\t\t\t\t     u32 *bit_error, u32 *bit_count)\n{\n\tu8 data[5];\n\tu32 period;\n\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xb2);\n\t \n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x30, data, 5);\n\tif (data[0] & 0x01) {\n\t\t \n\t\t*bit_error = ((u32)(data[1] & 0x0F) << 24) |\n\t\t\t     ((u32)(data[2] & 0xFF) << 16) |\n\t\t\t     ((u32)(data[3] & 0xFF) <<  8) |\n\t\t\t     (u32)(data[4] & 0xFF);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\n\t\tcxd2841er_read_reg(priv, I2C_SLVT, 0x7a, data);\n\t\t \n\t\tperiod = (u32)(1 << (data[0] & 0x0F));\n\t\tif (period == 0) {\n\t\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\"%s(): period is 0\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (*bit_error > (period * 64800)) {\n\t\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\"%s(): invalid bit_err 0x%x period 0x%x\\n\",\n\t\t\t\t__func__, *bit_error, period);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*bit_count = period * 64800;\n\n\t\treturn 0;\n\t} else {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): no data available\\n\", __func__);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int cxd2841er_read_ber_t2(struct cxd2841er_priv *priv,\n\t\t\t\t u32 *bit_error, u32 *bit_count)\n{\n\tu8 data[4];\n\tu32 period_exp, n_ldpc;\n\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): invalid state %d\\n\", __func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x39, data, sizeof(data));\n\tif (!(data[0] & 0x10)) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): no valid BER data\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\t*bit_error = ((u32)(data[0] & 0x0f) << 24) |\n\t\t     ((u32)data[1] << 16) |\n\t\t     ((u32)data[2] << 8) |\n\t\t     (u32)data[3];\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0x6f, data);\n\tperiod_exp = data[0] & 0x0f;\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x22);\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0x5e, data);\n\tn_ldpc = ((data[0] & 0x03) == 0 ? 16200 : 64800);\n\tif (*bit_error > ((1U << period_exp) * n_ldpc)) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): invalid BER value\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (period_exp >= 4) {\n\t\t*bit_count = (1U << (period_exp - 4)) * (n_ldpc / 200);\n\t\t*bit_error *= 3125ULL;\n\t} else {\n\t\t*bit_count = (1U << period_exp) * (n_ldpc / 200);\n\t\t*bit_error *= 50000ULL;\n\t}\n\treturn 0;\n}\n\nstatic int cxd2841er_read_ber_t(struct cxd2841er_priv *priv,\n\t\t\t\tu32 *bit_error, u32 *bit_count)\n{\n\tu8 data[2];\n\tu32 period;\n\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): invalid state %d\\n\", __func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0x39, data);\n\tif (!(data[0] & 0x01)) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): no valid BER data\\n\", __func__);\n\t\treturn 0;\n\t}\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x22, data, sizeof(data));\n\t*bit_error = ((u32)data[0] << 8) | (u32)data[1];\n\tcxd2841er_read_reg(priv, I2C_SLVT, 0x6f, data);\n\tperiod = ((data[0] & 0x07) == 0) ? 256 : (4096 << (data[0] & 0x07));\n\n\t \n\t*bit_count = period / 128;\n\t*bit_error *= 78125ULL;\n\treturn 0;\n}\n\nstatic int cxd2841er_freeze_regs(struct cxd2841er_priv *priv)\n{\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x01, 0x01);\n\treturn 0;\n}\n\nstatic int cxd2841er_unfreeze_regs(struct cxd2841er_priv *priv)\n{\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x01, 0x00);\n\treturn 0;\n}\n\nstatic u32 cxd2841er_dvbs_read_snr(struct cxd2841er_priv *priv,\n\t\tu8 delsys, u32 *snr)\n{\n\tu8 data[3];\n\tu32 res = 0, value;\n\tint min_index, max_index, index;\n\tstatic const struct cxd2841er_cnr_data *cn_data;\n\n\tcxd2841er_freeze_regs(priv);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa1);\n\t \n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x10, data, 3);\n\tcxd2841er_unfreeze_regs(priv);\n\n\tif (data[0] & 0x01) {\n\t\tvalue = ((u32)(data[1] & 0x1F) << 8) | (u32)(data[2] & 0xFF);\n\t\tmin_index = 0;\n\t\tif (delsys == SYS_DVBS) {\n\t\t\tcn_data = s_cn_data;\n\t\t\tmax_index = ARRAY_SIZE(s_cn_data) - 1;\n\t\t} else {\n\t\t\tcn_data = s2_cn_data;\n\t\t\tmax_index = ARRAY_SIZE(s2_cn_data) - 1;\n\t\t}\n\t\tif (value >= cn_data[min_index].value) {\n\t\t\tres = cn_data[min_index].cnr_x1000;\n\t\t\tgoto done;\n\t\t}\n\t\tif (value <= cn_data[max_index].value) {\n\t\t\tres = cn_data[max_index].cnr_x1000;\n\t\t\tgoto done;\n\t\t}\n\t\twhile ((max_index - min_index) > 1) {\n\t\t\tindex = (max_index + min_index) / 2;\n\t\t\tif (value == cn_data[index].value) {\n\t\t\t\tres = cn_data[index].cnr_x1000;\n\t\t\t\tgoto done;\n\t\t\t} else if (value > cn_data[index].value)\n\t\t\t\tmax_index = index;\n\t\t\telse\n\t\t\t\tmin_index = index;\n\t\t\tif ((max_index - min_index) <= 1) {\n\t\t\t\tif (value == cn_data[max_index].value) {\n\t\t\t\t\tres = cn_data[max_index].cnr_x1000;\n\t\t\t\t\tgoto done;\n\t\t\t\t} else {\n\t\t\t\t\tres = cn_data[min_index].cnr_x1000;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): no data available\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\ndone:\n\t*snr = res;\n\treturn 0;\n}\n\nstatic uint32_t sony_log(uint32_t x)\n{\n\treturn (((10000>>8)*(intlog2(x)>>16) + LOG2_E_100X/2)/LOG2_E_100X);\n}\n\nstatic int cxd2841er_read_snr_c(struct cxd2841er_priv *priv, u32 *snr)\n{\n\tu32 reg;\n\tu8 data[2];\n\tenum sony_dvbc_constellation_t qam = SONY_DVBC_CONSTELLATION_16QAM;\n\n\t*snr = 0;\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\"%s(): invalid state %d\\n\",\n\t\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\n\tcxd2841er_freeze_regs(priv);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x19, data, 1);\n\tqam = (enum sony_dvbc_constellation_t) (data[0] & 0x07);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x4C, data, 2);\n\tcxd2841er_unfreeze_regs(priv);\n\n\treg = ((u32)(data[0]&0x1f) << 8) | (u32)data[1];\n\tif (reg == 0) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\"%s(): reg value out of range\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tswitch (qam) {\n\tcase SONY_DVBC_CONSTELLATION_16QAM:\n\tcase SONY_DVBC_CONSTELLATION_64QAM:\n\tcase SONY_DVBC_CONSTELLATION_256QAM:\n\t\t \n\t\tif (reg < 126)\n\t\t\treg = 126;\n\t\t*snr = -95 * (int32_t)sony_log(reg) + 95941;\n\t\tbreak;\n\tcase SONY_DVBC_CONSTELLATION_32QAM:\n\tcase SONY_DVBC_CONSTELLATION_128QAM:\n\t\t \n\t\tif (reg < 69)\n\t\t\treg = 69;\n\t\t*snr = -88 * (int32_t)sony_log(reg) + 86999;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxd2841er_read_snr_t(struct cxd2841er_priv *priv, u32 *snr)\n{\n\tu32 reg;\n\tu8 data[2];\n\n\t*snr = 0;\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): invalid state %d\\n\", __func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\n\tcxd2841er_freeze_regs(priv);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));\n\tcxd2841er_unfreeze_regs(priv);\n\n\treg = ((u32)data[0] << 8) | (u32)data[1];\n\tif (reg == 0) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): reg value out of range\\n\", __func__);\n\t\treturn 0;\n\t}\n\tif (reg > 4996)\n\t\treg = 4996;\n\t*snr = 100 * ((INTLOG10X100(reg) - INTLOG10X100(5350 - reg)) + 285);\n\treturn 0;\n}\n\nstatic int cxd2841er_read_snr_t2(struct cxd2841er_priv *priv, u32 *snr)\n{\n\tu32 reg;\n\tu8 data[2];\n\n\t*snr = 0;\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): invalid state %d\\n\", __func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\n\tcxd2841er_freeze_regs(priv);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));\n\tcxd2841er_unfreeze_regs(priv);\n\n\treg = ((u32)data[0] << 8) | (u32)data[1];\n\tif (reg == 0) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): reg value out of range\\n\", __func__);\n\t\treturn 0;\n\t}\n\tif (reg > 10876)\n\t\treg = 10876;\n\t*snr = 100 * ((INTLOG10X100(reg) - INTLOG10X100(12600 - reg)) + 320);\n\treturn 0;\n}\n\nstatic int cxd2841er_read_snr_i(struct cxd2841er_priv *priv, u32 *snr)\n{\n\tu32 reg;\n\tu8 data[2];\n\n\t*snr = 0;\n\tif (priv->state != STATE_ACTIVE_TC) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\"%s(): invalid state %d\\n\", __func__,\n\t\t\t\tpriv->state);\n\t\treturn -EINVAL;\n\t}\n\n\tcxd2841er_freeze_regs(priv);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));\n\tcxd2841er_unfreeze_regs(priv);\n\n\treg = ((u32)data[0] << 8) | (u32)data[1];\n\tif (reg == 0) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\"%s(): reg value out of range\\n\", __func__);\n\t\treturn 0;\n\t}\n\t*snr = 10000 * (intlog10(reg) >> 24) - 9031;\n\treturn 0;\n}\n\nstatic u16 cxd2841er_read_agc_gain_c(struct cxd2841er_priv *priv,\n\t\t\t\t\tu8 delsys)\n{\n\tu8 data[2];\n\n\tcxd2841er_write_reg(\n\t\tpriv, I2C_SLVT, 0x00, 0x40);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x49, data, 2);\n\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): AGC value=%u\\n\",\n\t\t\t__func__, (((u16)data[0] & 0x0F) << 8) |\n\t\t\t(u16)(data[1] & 0xFF));\n\treturn ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;\n}\n\nstatic u16 cxd2841er_read_agc_gain_t_t2(struct cxd2841er_priv *priv,\n\t\t\t\t\tu8 delsys)\n{\n\tu8 data[2];\n\n\tcxd2841er_write_reg(\n\t\tpriv, I2C_SLVT, 0x00, (delsys == SYS_DVBT ? 0x10 : 0x20));\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x26, data, 2);\n\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): AGC value=%u\\n\",\n\t\t\t__func__, (((u16)data[0] & 0x0F) << 8) |\n\t\t\t(u16)(data[1] & 0xFF));\n\treturn ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;\n}\n\nstatic u16 cxd2841er_read_agc_gain_i(struct cxd2841er_priv *priv,\n\t\tu8 delsys)\n{\n\tu8 data[2];\n\n\tcxd2841er_write_reg(\n\t\t\tpriv, I2C_SLVT, 0x00, 0x60);\n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x26, data, 2);\n\n\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): AGC value=%u\\n\",\n\t\t\t__func__, (((u16)data[0] & 0x0F) << 8) |\n\t\t\t(u16)(data[1] & 0xFF));\n\treturn ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;\n}\n\nstatic u16 cxd2841er_read_agc_gain_s(struct cxd2841er_priv *priv)\n{\n\tu8 data[2];\n\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\n\t \n\tcxd2841er_read_regs(priv, I2C_SLVT, 0x1f, data, 2);\n\treturn ((((u16)data[0] & 0x1F) << 8) | (u16)(data[1] & 0xFF)) << 3;\n}\n\nstatic void cxd2841er_read_ber(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\tu32 ret, bit_error = 0, bit_count = 0;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tswitch (p->delivery_system) {\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_B:\n\tcase SYS_DVBC_ANNEX_C:\n\t\tret = cxd2841er_read_ber_c(priv, &bit_error, &bit_count);\n\t\tbreak;\n\tcase SYS_ISDBT:\n\t\tret = cxd2841er_read_ber_i(priv, &bit_error, &bit_count);\n\t\tbreak;\n\tcase SYS_DVBS:\n\t\tret = cxd2841er_mon_read_ber_s(priv, &bit_error, &bit_count);\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tret = cxd2841er_mon_read_ber_s2(priv, &bit_error, &bit_count);\n\t\tbreak;\n\tcase SYS_DVBT:\n\t\tret = cxd2841er_read_ber_t(priv, &bit_error, &bit_count);\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tret = cxd2841er_read_ber_t2(priv, &bit_error, &bit_count);\n\t\tbreak;\n\tdefault:\n\t\tp->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn;\n\t}\n\n\tif (!ret) {\n\t\tp->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tp->post_bit_error.stat[0].uvalue += bit_error;\n\t\tp->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tp->post_bit_count.stat[0].uvalue += bit_count;\n\t} else {\n\t\tp->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n}\n\nstatic void cxd2841er_read_signal_strength(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\ts32 strength;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tswitch (p->delivery_system) {\n\tcase SYS_DVBT:\n\tcase SYS_DVBT2:\n\t\tstrength = cxd2841er_read_agc_gain_t_t2(priv,\n\t\t\t\t\t\t\tp->delivery_system);\n\t\tp->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\t\t \n\t\tp->strength.stat[0].uvalue = strength * 366 / 100 - 89520;\n\t\tbreak;\t \n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_B:\n\tcase SYS_DVBC_ANNEX_C:\n\t\tstrength = cxd2841er_read_agc_gain_c(priv,\n\t\t\t\t\t\t\tp->delivery_system);\n\t\tp->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\t\t \n\t\tp->strength.stat[0].uvalue = strength * 4045 / 1000 - 85224;\n\t\tbreak;\n\tcase SYS_ISDBT:\n\t\tstrength = cxd2841er_read_agc_gain_i(priv, p->delivery_system);\n\t\tp->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\t\t \n\t\tp->strength.stat[0].uvalue = strength * 3775 / 1000 - 90185;\n\t\tbreak;\n\tcase SYS_DVBS:\n\tcase SYS_DVBS2:\n\t\tstrength = 65535 - cxd2841er_read_agc_gain_s(priv);\n\t\tp->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\t\tp->strength.stat[0].uvalue = strength;\n\t\tbreak;\n\tdefault:\n\t\tp->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tbreak;\n\t}\n}\n\nstatic void cxd2841er_read_snr(struct dvb_frontend *fe)\n{\n\tu32 tmp = 0;\n\tint ret = 0;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tswitch (p->delivery_system) {\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_B:\n\tcase SYS_DVBC_ANNEX_C:\n\t\tret = cxd2841er_read_snr_c(priv, &tmp);\n\t\tbreak;\n\tcase SYS_DVBT:\n\t\tret = cxd2841er_read_snr_t(priv, &tmp);\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tret = cxd2841er_read_snr_t2(priv, &tmp);\n\t\tbreak;\n\tcase SYS_ISDBT:\n\t\tret = cxd2841er_read_snr_i(priv, &tmp);\n\t\tbreak;\n\tcase SYS_DVBS:\n\tcase SYS_DVBS2:\n\t\tret = cxd2841er_dvbs_read_snr(priv, p->delivery_system, &tmp);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): unknown delivery system %d\\n\",\n\t\t\t__func__, p->delivery_system);\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn;\n\t}\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): snr=%d\\n\",\n\t\t\t__func__, (int32_t)tmp);\n\n\tif (!ret) {\n\t\tp->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tp->cnr.stat[0].svalue = tmp;\n\t} else {\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n}\n\nstatic void cxd2841er_read_ucblocks(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\tu32 ucblocks = 0;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tswitch (p->delivery_system) {\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_B:\n\tcase SYS_DVBC_ANNEX_C:\n\t\tcxd2841er_read_packet_errors_c(priv, &ucblocks);\n\t\tbreak;\n\tcase SYS_DVBT:\n\t\tcxd2841er_read_packet_errors_t(priv, &ucblocks);\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tcxd2841er_read_packet_errors_t2(priv, &ucblocks);\n\t\tbreak;\n\tcase SYS_ISDBT:\n\t\tcxd2841er_read_packet_errors_i(priv, &ucblocks);\n\t\tbreak;\n\tdefault:\n\t\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn;\n\t}\n\tdev_dbg(&priv->i2c->dev, \"%s() ucblocks=%u\\n\", __func__, ucblocks);\n\n\tp->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\tp->block_error.stat[0].uvalue = ucblocks;\n}\n\nstatic int cxd2841er_dvbt2_set_profile(\n\tstruct cxd2841er_priv *priv, enum cxd2841er_dvbt2_profile_t profile)\n{\n\tu8 tune_mode;\n\tu8 seq_not2d_time;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tswitch (profile) {\n\tcase DVBT2_PROFILE_BASE:\n\t\ttune_mode = 0x01;\n\t\t \n\t\tseq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x0E:0x0C;\n\t\tbreak;\n\tcase DVBT2_PROFILE_LITE:\n\t\ttune_mode = 0x05;\n\t\t \n\t\tseq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x2E:0x28;\n\t\tbreak;\n\tcase DVBT2_PROFILE_ANY:\n\t\ttune_mode = 0x00;\n\t\t \n\t\tseq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x2E:0x28;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2e);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x10, tune_mode, 0x07);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x9d, seq_not2d_time);\n\treturn 0;\n}\n\nstatic int cxd2841er_dvbt2_set_plp_config(struct cxd2841er_priv *priv,\n\t\t\t\t\t  u8 is_auto, u8 plp_id)\n{\n\tif (is_auto) {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s() using auto PLP selection\\n\", __func__);\n\t} else {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s() using manual PLP selection, ID %d\\n\",\n\t\t\t__func__, plp_id);\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x23);\n\tif (!is_auto) {\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0xaf, plp_id);\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0xad, (is_auto ? 0x00 : 0x01));\n\treturn 0;\n}\n\nstatic int cxd2841er_sleep_tc_to_active_t2_band(struct cxd2841er_priv *priv,\n\t\t\t\t\t\tu32 bandwidth)\n{\n\tu32 iffreq, ifhz;\n\tu8 data[MAX_WRITE_REGSIZE];\n\n\tstatic const uint8_t nominalRate8bw[3][5] = {\n\t\t \n\t\t{0x11, 0xF0, 0x00, 0x00, 0x00},  \n\t\t{0x15, 0x00, 0x00, 0x00, 0x00},  \n\t\t{0x11, 0xF0, 0x00, 0x00, 0x00}   \n\t};\n\n\tstatic const uint8_t nominalRate7bw[3][5] = {\n\t\t \n\t\t{0x14, 0x80, 0x00, 0x00, 0x00},  \n\t\t{0x18, 0x00, 0x00, 0x00, 0x00},  \n\t\t{0x14, 0x80, 0x00, 0x00, 0x00}   \n\t};\n\n\tstatic const uint8_t nominalRate6bw[3][5] = {\n\t\t \n\t\t{0x17, 0xEA, 0xAA, 0xAA, 0xAA},  \n\t\t{0x1C, 0x00, 0x00, 0x00, 0x00},  \n\t\t{0x17, 0xEA, 0xAA, 0xAA, 0xAA}   \n\t};\n\n\tstatic const uint8_t nominalRate5bw[3][5] = {\n\t\t \n\t\t{0x1C, 0xB3, 0x33, 0x33, 0x33},  \n\t\t{0x21, 0x99, 0x99, 0x99, 0x99},  \n\t\t{0x1C, 0xB3, 0x33, 0x33, 0x33}   \n\t};\n\n\tstatic const uint8_t nominalRate17bw[3][5] = {\n\t\t \n\t\t{0x58, 0xE2, 0xAF, 0xE0, 0xBC},  \n\t\t{0x68, 0x0F, 0xA2, 0x32, 0xD0},  \n\t\t{0x58, 0xE2, 0xAF, 0xE0, 0xBC}   \n\t};\n\n\tstatic const uint8_t itbCoef8bw[3][14] = {\n\t\t{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA,\n\t\t\t0x23, 0xA9, 0x1F, 0xA8, 0x2C, 0xC8},  \n\t\t{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1,\n\t\t\t0x29, 0xA5, 0x2A, 0xAC, 0x29, 0xB5},  \n\t\t{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA,\n\t\t\t0x23, 0xA9, 0x1F, 0xA8, 0x2C, 0xC8}   \n\t};\n\n\tstatic const uint8_t itbCoef7bw[3][14] = {\n\t\t{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6,\n\t\t\t0x29, 0xB0, 0x26, 0xA9, 0x21, 0xA5},  \n\t\t{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0,\n\t\t\t0x29, 0xA2, 0x2B, 0xA6, 0x2B, 0xAD},  \n\t\t{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6,\n\t\t\t0x29, 0xB0, 0x26, 0xA9, 0x21, 0xA5}   \n\t};\n\n\tstatic const uint8_t itbCoef6bw[3][14] = {\n\t\t{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,\n\t\t\t0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4},  \n\t\t{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E,\n\t\t\t0x29, 0xA4, 0x29, 0xA2, 0x29, 0xA8},  \n\t\t{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,\n\t\t\t0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}   \n\t};\n\n\tstatic const uint8_t itbCoef5bw[3][14] = {\n\t\t{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,\n\t\t\t0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4},  \n\t\t{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E,\n\t\t\t0x29, 0xA4, 0x29, 0xA2, 0x29, 0xA8},  \n\t\t{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,\n\t\t\t0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}   \n\t};\n\n\tstatic const uint8_t itbCoef17bw[3][14] = {\n\t\t{0x25, 0xA0, 0x36, 0x8D, 0x2E, 0x94, 0x28, 0x9B,\n\t\t\t0x32, 0x90, 0x2C, 0x9D, 0x29, 0x99},  \n\t\t{0x33, 0x8E, 0x2B, 0x97, 0x2D, 0x95, 0x37, 0x8B,\n\t\t\t0x30, 0x97, 0x2D, 0x9A, 0x21, 0xA4},  \n\t\t{0x25, 0xA0, 0x36, 0x8D, 0x2E, 0x94, 0x28, 0x9B,\n\t\t\t0x32, 0x90, 0x2C, 0x9D, 0x29, 0x99}   \n\t};\n\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\n\n\tswitch (bandwidth) {\n\tcase 8000000:\n\t\t \n\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0x9F, nominalRate8bw[priv->xtal], 5);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT,\n\t\t\t\t0x7a, 0x00, 0x0f);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\n\t\t \n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0xA6, itbCoef8bw[priv->xtal], 14);\n\t\t \n\t\tifhz = cxd2841er_get_if_hz(priv, 4800000);\n\t\tiffreq = cxd2841er_calc_iffreq_xtal(priv->xtal, ifhz);\n\t\tdata[0] = (u8) ((iffreq >> 16) & 0xff);\n\t\tdata[1] = (u8)((iffreq >> 8) & 0xff);\n\t\tdata[2] = (u8)(iffreq & 0xff);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\n\t\t \n\t\tcxd2841er_set_reg_bits(\n\t\t\t\tpriv, I2C_SLVT, 0xD7, 0x00, 0x07);\n\t\tbreak;\n\tcase 7000000:\n\t\t \n\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0x9F, nominalRate7bw[priv->xtal], 5);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT,\n\t\t\t\t0x7a, 0x00, 0x0f);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\n\t\t \n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0xA6, itbCoef7bw[priv->xtal], 14);\n\t\t \n\t\tifhz = cxd2841er_get_if_hz(priv, 4200000);\n\t\tiffreq = cxd2841er_calc_iffreq_xtal(priv->xtal, ifhz);\n\t\tdata[0] = (u8) ((iffreq >> 16) & 0xff);\n\t\tdata[1] = (u8)((iffreq >> 8) & 0xff);\n\t\tdata[2] = (u8)(iffreq & 0xff);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\n\t\t \n\t\tcxd2841er_set_reg_bits(\n\t\t\t\tpriv, I2C_SLVT, 0xD7, 0x02, 0x07);\n\t\tbreak;\n\tcase 6000000:\n\t\t \n\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0x9F, nominalRate6bw[priv->xtal], 5);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT,\n\t\t\t\t0x7a, 0x00, 0x0f);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\n\t\t \n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0xA6, itbCoef6bw[priv->xtal], 14);\n\t\t \n\t\tifhz = cxd2841er_get_if_hz(priv, 3600000);\n\t\tiffreq = cxd2841er_calc_iffreq_xtal(priv->xtal, ifhz);\n\t\tdata[0] = (u8) ((iffreq >> 16) & 0xff);\n\t\tdata[1] = (u8)((iffreq >> 8) & 0xff);\n\t\tdata[2] = (u8)(iffreq & 0xff);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\n\t\t \n\t\tcxd2841er_set_reg_bits(\n\t\t\t\tpriv, I2C_SLVT, 0xD7, 0x04, 0x07);\n\t\tbreak;\n\tcase 5000000:\n\t\t \n\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0x9F, nominalRate5bw[priv->xtal], 5);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT,\n\t\t\t\t0x7a, 0x00, 0x0f);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\n\t\t \n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0xA6, itbCoef5bw[priv->xtal], 14);\n\t\t \n\t\tifhz = cxd2841er_get_if_hz(priv, 3600000);\n\t\tiffreq = cxd2841er_calc_iffreq_xtal(priv->xtal, ifhz);\n\t\tdata[0] = (u8) ((iffreq >> 16) & 0xff);\n\t\tdata[1] = (u8)((iffreq >> 8) & 0xff);\n\t\tdata[2] = (u8)(iffreq & 0xff);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\n\t\t \n\t\tcxd2841er_set_reg_bits(\n\t\t\t\tpriv, I2C_SLVT, 0xD7, 0x06, 0x07);\n\t\tbreak;\n\tcase 1712000:\n\t\t \n\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0x9F, nominalRate17bw[priv->xtal], 5);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT,\n\t\t\t\t0x7a, 0x03, 0x0f);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\n\t\t \n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0xA6, itbCoef17bw[priv->xtal], 14);\n\t\t \n\t\tifhz = cxd2841er_get_if_hz(priv, 3500000);\n\t\tiffreq = cxd2841er_calc_iffreq_xtal(priv->xtal, ifhz);\n\t\tdata[0] = (u8) ((iffreq >> 16) & 0xff);\n\t\tdata[1] = (u8)((iffreq >> 8) & 0xff);\n\t\tdata[2] = (u8)(iffreq & 0xff);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\n\t\t \n\t\tcxd2841er_set_reg_bits(\n\t\t\t\tpriv, I2C_SLVT, 0xD7, 0x03, 0x07);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cxd2841er_sleep_tc_to_active_t_band(\n\t\tstruct cxd2841er_priv *priv, u32 bandwidth)\n{\n\tu8 data[MAX_WRITE_REGSIZE];\n\tu32 iffreq, ifhz;\n\tstatic const u8 nominalRate8bw[3][5] = {\n\t\t \n\t\t{0x11, 0xF0, 0x00, 0x00, 0x00},  \n\t\t{0x15, 0x00, 0x00, 0x00, 0x00},  \n\t\t{0x11, 0xF0, 0x00, 0x00, 0x00}   \n\t};\n\tstatic const u8 nominalRate7bw[3][5] = {\n\t\t \n\t\t{0x14, 0x80, 0x00, 0x00, 0x00},  \n\t\t{0x18, 0x00, 0x00, 0x00, 0x00},  \n\t\t{0x14, 0x80, 0x00, 0x00, 0x00}   \n\t};\n\tstatic const u8 nominalRate6bw[3][5] = {\n\t\t \n\t\t{0x17, 0xEA, 0xAA, 0xAA, 0xAA},  \n\t\t{0x1C, 0x00, 0x00, 0x00, 0x00},  \n\t\t{0x17, 0xEA, 0xAA, 0xAA, 0xAA}   \n\t};\n\tstatic const u8 nominalRate5bw[3][5] = {\n\t\t \n\t\t{0x1C, 0xB3, 0x33, 0x33, 0x33},  \n\t\t{0x21, 0x99, 0x99, 0x99, 0x99},  \n\t\t{0x1C, 0xB3, 0x33, 0x33, 0x33}   \n\t};\n\n\tstatic const u8 itbCoef8bw[3][14] = {\n\t\t{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA, 0x23, 0xA9,\n\t\t\t0x1F, 0xA8, 0x2C, 0xC8},  \n\t\t{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1, 0x29, 0xA5,\n\t\t\t0x2A, 0xAC, 0x29, 0xB5},  \n\t\t{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA, 0x23, 0xA9,\n\t\t\t0x1F, 0xA8, 0x2C, 0xC8}   \n\t};\n\tstatic const u8 itbCoef7bw[3][14] = {\n\t\t{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6, 0x29, 0xB0,\n\t\t\t0x26, 0xA9, 0x21, 0xA5},  \n\t\t{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0, 0x29, 0xA2,\n\t\t\t0x2B, 0xA6, 0x2B, 0xAD},  \n\t\t{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6, 0x29, 0xB0,\n\t\t\t0x26, 0xA9, 0x21, 0xA5}   \n\t};\n\tstatic const u8 itbCoef6bw[3][14] = {\n\t\t{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,\n\t\t\t0x00, 0xE6, 0x23, 0xA4},  \n\t\t{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29, 0xA4,\n\t\t\t0x29, 0xA2, 0x29, 0xA8},  \n\t\t{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,\n\t\t\t0x00, 0xE6, 0x23, 0xA4}   \n\t};\n\tstatic const u8 itbCoef5bw[3][14] = {\n\t\t{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,\n\t\t\t0x00, 0xE6, 0x23, 0xA4},  \n\t\t{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29, 0xA4,\n\t\t\t0x29, 0xA2, 0x29, 0xA8},  \n\t\t{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,\n\t\t\t0x00, 0xE6, 0x23, 0xA4}   \n\t};\n\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);\n\t \n\tdata[0] = 0x01;\n\tdata[1] = 0x14;\n\tcxd2841er_write_regs(priv, I2C_SLVT, 0x9C, data, 2);\n\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\n\tswitch (bandwidth) {\n\tcase 8000000:\n\t\t \n\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0x9F, nominalRate8bw[priv->xtal], 5);\n\t\t \n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0xA6, itbCoef8bw[priv->xtal], 14);\n\t\t \n\t\tifhz = cxd2841er_get_if_hz(priv, 4800000);\n\t\tiffreq = cxd2841er_calc_iffreq_xtal(priv->xtal, ifhz);\n\t\tdata[0] = (u8) ((iffreq >> 16) & 0xff);\n\t\tdata[1] = (u8)((iffreq >> 8) & 0xff);\n\t\tdata[2] = (u8)(iffreq & 0xff);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\n\t\t \n\t\tcxd2841er_set_reg_bits(\n\t\t\tpriv, I2C_SLVT, 0xD7, 0x00, 0x07);\n\n\t\t \n\t\tif (priv->xtal == SONY_XTAL_24000) {\n\t\t\tdata[0] = 0x15;\n\t\t\tdata[1] = 0x28;\n\t\t} else {\n\t\t\tdata[0] = 0x01;\n\t\t\tdata[1] = 0xE0;\n\t\t}\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\n\n\t\t \n\t\tdata[0] = 0x01;\n\t\tdata[1] = 0x02;\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);\n\t\tbreak;\n\tcase 7000000:\n\t\t \n\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0x9F, nominalRate7bw[priv->xtal], 5);\n\t\t \n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0xA6, itbCoef7bw[priv->xtal], 14);\n\t\t \n\t\tifhz = cxd2841er_get_if_hz(priv, 4200000);\n\t\tiffreq = cxd2841er_calc_iffreq_xtal(priv->xtal, ifhz);\n\t\tdata[0] = (u8) ((iffreq >> 16) & 0xff);\n\t\tdata[1] = (u8)((iffreq >> 8) & 0xff);\n\t\tdata[2] = (u8)(iffreq & 0xff);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\n\t\t \n\t\tcxd2841er_set_reg_bits(\n\t\t\tpriv, I2C_SLVT, 0xD7, 0x02, 0x07);\n\n\t\t \n\t\tif (priv->xtal == SONY_XTAL_24000) {\n\t\t\tdata[0] = 0x1F;\n\t\t\tdata[1] = 0xF8;\n\t\t} else {\n\t\t\tdata[0] = 0x12;\n\t\t\tdata[1] = 0xF8;\n\t\t}\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\n\n\t\t \n\t\tdata[0] = 0x00;\n\t\tdata[1] = 0x03;\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);\n\t\tbreak;\n\tcase 6000000:\n\t\t \n\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0x9F, nominalRate6bw[priv->xtal], 5);\n\t\t \n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0xA6, itbCoef6bw[priv->xtal], 14);\n\t\t \n\t\tifhz = cxd2841er_get_if_hz(priv, 3600000);\n\t\tiffreq = cxd2841er_calc_iffreq_xtal(priv->xtal, ifhz);\n\t\tdata[0] = (u8) ((iffreq >> 16) & 0xff);\n\t\tdata[1] = (u8)((iffreq >> 8) & 0xff);\n\t\tdata[2] = (u8)(iffreq & 0xff);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\n\t\t \n\t\tcxd2841er_set_reg_bits(\n\t\t\tpriv, I2C_SLVT, 0xD7, 0x04, 0x07);\n\n\t\t \n\t\tif (priv->xtal == SONY_XTAL_24000) {\n\t\t\tdata[0] = 0x25;\n\t\t\tdata[1] = 0x4C;\n\t\t} else {\n\t\t\tdata[0] = 0x1F;\n\t\t\tdata[1] = 0xDC;\n\t\t}\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\n\n\t\t \n\t\tdata[0] = 0x00;\n\t\tdata[1] = 0x03;\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);\n\t\tbreak;\n\tcase 5000000:\n\t\t \n\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0x9F, nominalRate5bw[priv->xtal], 5);\n\t\t \n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0xA6, itbCoef5bw[priv->xtal], 14);\n\t\t \n\t\tifhz = cxd2841er_get_if_hz(priv, 3600000);\n\t\tiffreq = cxd2841er_calc_iffreq_xtal(priv->xtal, ifhz);\n\t\tdata[0] = (u8) ((iffreq >> 16) & 0xff);\n\t\tdata[1] = (u8)((iffreq >> 8) & 0xff);\n\t\tdata[2] = (u8)(iffreq & 0xff);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\n\t\t \n\t\tcxd2841er_set_reg_bits(\n\t\t\tpriv, I2C_SLVT, 0xD7, 0x06, 0x07);\n\n\t\t \n\t\tif (priv->xtal == SONY_XTAL_24000) {\n\t\t\tdata[0] = 0x2C;\n\t\t\tdata[1] = 0xC2;\n\t\t} else {\n\t\t\tdata[0] = 0x26;\n\t\t\tdata[1] = 0x3C;\n\t\t}\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\n\n\t\t \n\t\tdata[0] = 0x00;\n\t\tdata[1] = 0x03;\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxd2841er_sleep_tc_to_active_i_band(\n\t\tstruct cxd2841er_priv *priv, u32 bandwidth)\n{\n\tu32 iffreq, ifhz;\n\tu8 data[3];\n\n\t \n\tstatic const u8 nominalRate8bw[3][5] = {\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00},  \n\t\t{0x11, 0xB8, 0x00, 0x00, 0x00},  \n\t\t{0x00, 0x00, 0x00, 0x00, 0x00}   \n\t};\n\n\tstatic const u8 nominalRate7bw[3][5] = {\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00},  \n\t\t{0x14, 0x40, 0x00, 0x00, 0x00},  \n\t\t{0x00, 0x00, 0x00, 0x00, 0x00}   \n\t};\n\n\tstatic const u8 nominalRate6bw[3][5] = {\n\t\t{0x14, 0x2E, 0x00, 0x00, 0x00},  \n\t\t{0x17, 0xA0, 0x00, 0x00, 0x00},  \n\t\t{0x14, 0x2E, 0x00, 0x00, 0x00}   \n\t};\n\n\tstatic const u8 itbCoef8bw[3][14] = {\n\t\t{0x00},  \n\t\t{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1, 0x29,\n\t\t\t0xA5, 0x2A, 0xAC, 0x29, 0xB5},  \n\t\t{0x0},  \n\t};\n\n\tstatic const u8 itbCoef7bw[3][14] = {\n\t\t{0x00},  \n\t\t{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0, 0x29,\n\t\t\t0xA2, 0x2B, 0xA6, 0x2B, 0xAD},  \n\t\t{0x00},  \n\t};\n\n\tstatic const u8 itbCoef6bw[3][14] = {\n\t\t{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00,\n\t\t\t0xCF, 0x00, 0xE6, 0x23, 0xA4},  \n\t\t{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29,\n\t\t\t0xA4, 0x29, 0xA2, 0x29, 0xA8},  \n\t\t{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00,\n\t\t\t0xCF, 0x00, 0xE6, 0x23, 0xA4},  \n\t};\n\n\tdev_dbg(&priv->i2c->dev, \"%s() bandwidth=%u\\n\", __func__, bandwidth);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\n\t \n\tif (priv->xtal != SONY_XTAL_24000 && bandwidth > 6000000) {\n\t\tdev_err(&priv->i2c->dev,\n\t\t\t\"%s(): bandwidth %d supported only for 24MHz xtal\\n\",\n\t\t\t__func__, bandwidth);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (bandwidth) {\n\tcase 8000000:\n\t\t \n\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0x9F, nominalRate8bw[priv->xtal], 5);\n\t\t \n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0xA6, itbCoef8bw[priv->xtal], 14);\n\n\t\t \n\t\tifhz = cxd2841er_get_if_hz(priv, 4750000);\n\t\tiffreq = cxd2841er_calc_iffreq_xtal(priv->xtal, ifhz);\n\t\tdata[0] = (u8) ((iffreq >> 16) & 0xff);\n\t\tdata[1] = (u8)((iffreq >> 8) & 0xff);\n\t\tdata[2] = (u8)(iffreq & 0xff);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\n\n\t\t \n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x0, 0x7);\n\n\t\t \n\t\tdata[0] = 0x13;\n\t\tdata[1] = 0xFC;\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);\n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x03, 0x07);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x03);\n\t\tbreak;\n\tcase 7000000:\n\t\t \n\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0x9F, nominalRate7bw[priv->xtal], 5);\n\t\t \n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0xA6, itbCoef7bw[priv->xtal], 14);\n\n\t\t \n\t\tifhz = cxd2841er_get_if_hz(priv, 4150000);\n\t\tiffreq = cxd2841er_calc_iffreq_xtal(priv->xtal, ifhz);\n\t\tdata[0] = (u8) ((iffreq >> 16) & 0xff);\n\t\tdata[1] = (u8)((iffreq >> 8) & 0xff);\n\t\tdata[2] = (u8)(iffreq & 0xff);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\n\n\t\t \n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x02, 0x7);\n\n\t\t \n\t\tdata[0] = 0x1A;\n\t\tdata[1] = 0xFA;\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);\n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x03, 0x07);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x02);\n\t\tbreak;\n\tcase 6000000:\n\t\t \n\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0x9F, nominalRate6bw[priv->xtal], 5);\n\t\t \n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(priv, I2C_SLVT,\n\t\t\t\t0xA6, itbCoef6bw[priv->xtal], 14);\n\n\t\t \n\t\tifhz = cxd2841er_get_if_hz(priv, 3550000);\n\t\tiffreq = cxd2841er_calc_iffreq_xtal(priv->xtal, ifhz);\n\t\tdata[0] = (u8) ((iffreq >> 16) & 0xff);\n\t\tdata[1] = (u8)((iffreq >> 8) & 0xff);\n\t\tdata[2] = (u8)(iffreq & 0xff);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\n\n\t\t \n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x04, 0x7);\n\n\t\t \n\t\tif (priv->xtal == SONY_XTAL_24000) {\n\t\t\tdata[0] = 0x1F;\n\t\t\tdata[1] = 0x79;\n\t\t} else {\n\t\t\tdata[0] = 0x1A;\n\t\t\tdata[1] = 0xE2;\n\t\t}\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);\n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x07, 0x07);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x02);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid bandwidth %d\\n\",\n\t\t\t\t__func__, bandwidth);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cxd2841er_sleep_tc_to_active_c_band(struct cxd2841er_priv *priv,\n\t\t\t\t\t       u32 bandwidth)\n{\n\tu8 bw7_8mhz_b10_a6[] = {\n\t\t0x2D, 0xC7, 0x04, 0xF4, 0x07, 0xC5, 0x2A, 0xB8,\n\t\t0x27, 0x9E, 0x27, 0xA4, 0x29, 0xAB };\n\tu8 bw6mhz_b10_a6[] = {\n\t\t0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,\n\t\t0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4 };\n\tu8 b10_b6[3];\n\tu32 iffreq, ifhz;\n\n\tif (bandwidth != 6000000 &&\n\t\t\tbandwidth != 7000000 &&\n\t\t\tbandwidth != 8000000) {\n\t\tdev_info(&priv->i2c->dev, \"%s(): unsupported bandwidth %d. Forcing 8Mhz!\\n\",\n\t\t\t\t__func__, bandwidth);\n\t\tbandwidth = 8000000;\n\t}\n\n\tdev_dbg(&priv->i2c->dev, \"%s() bw=%d\\n\", __func__, bandwidth);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\tswitch (bandwidth) {\n\tcase 8000000:\n\tcase 7000000:\n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(\n\t\t\t\tpriv, I2C_SLVT, 0xa6,\n\t\t\t\tbw7_8mhz_b10_a6, sizeof(bw7_8mhz_b10_a6));\n\t\tifhz = cxd2841er_get_if_hz(priv, 4900000);\n\t\tiffreq = cxd2841er_calc_iffreq(ifhz);\n\t\tbreak;\n\tcase 6000000:\n\t\tif (priv->flags & CXD2841ER_ASCOT)\n\t\t\tcxd2841er_write_regs(\n\t\t\t\tpriv, I2C_SLVT, 0xa6,\n\t\t\t\tbw6mhz_b10_a6, sizeof(bw6mhz_b10_a6));\n\t\tifhz = cxd2841er_get_if_hz(priv, 3700000);\n\t\tiffreq = cxd2841er_calc_iffreq(ifhz);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&priv->i2c->dev, \"%s(): unsupported bandwidth %d\\n\",\n\t\t\t__func__, bandwidth);\n\t\treturn -EINVAL;\n\t}\n\t \n\tb10_b6[0] = (u8) ((iffreq >> 16) & 0xff);\n\tb10_b6[1] = (u8)((iffreq >> 8) & 0xff);\n\tb10_b6[2] = (u8)(iffreq & 0xff);\n\tcxd2841er_write_regs(priv, I2C_SLVT, 0xb6, b10_b6, sizeof(b10_b6));\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\n\tswitch (bandwidth) {\n\tcase 8000000:\n\tcase 7000000:\n\t\tcxd2841er_set_reg_bits(\n\t\t\tpriv, I2C_SLVT, 0xa3, 0x00, 0x1f);\n\t\tbreak;\n\tcase 6000000:\n\t\tcxd2841er_set_reg_bits(\n\t\t\tpriv, I2C_SLVT, 0xa3, 0x14, 0x1f);\n\t\tbreak;\n\t}\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\n\tswitch (bandwidth) {\n\tcase 8000000:\n\t\tcxd2841er_set_reg_bits(\n\t\t\tpriv, I2C_SLVT, 0x26, 0x0b, 0x0f);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT,  0x27, 0x3e);\n\t\tbreak;\n\tcase 7000000:\n\t\tcxd2841er_set_reg_bits(\n\t\t\tpriv, I2C_SLVT, 0x26, 0x09, 0x0f);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT,  0x27, 0xd6);\n\t\tbreak;\n\tcase 6000000:\n\t\tcxd2841er_set_reg_bits(\n\t\t\tpriv, I2C_SLVT, 0x26, 0x08, 0x0f);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT,  0x27, 0x6e);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int cxd2841er_sleep_tc_to_active_t(struct cxd2841er_priv *priv,\n\t\t\t\t\t  u32 bandwidth)\n{\n\tu8 data[2] = { 0x09, 0x54 };\n\tu8 data24m[3] = {0xDC, 0x6C, 0x00};\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tcxd2841er_set_ts_clock_mode(priv, SYS_DVBT);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);\n\t \n\tif (priv->xtal == SONY_XTAL_41000) {\n\t\tdata[0] = 0x0A;\n\t\tdata[1] = 0xD4;\n\t}\n\tcxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x0c, 0x1f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x50);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5,\n\t\t((priv->flags & CXD2841ER_ASCOT) ? 0x01 : 0x00), 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x18);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x36, 0x40, 0x07);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x30, 0x01, 0x01);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x31, 0x01, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);\n\n\tif (priv->xtal == SONY_XTAL_24000) {\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0xBF, 0x60);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x18);\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0x24, data24m, 3);\n\t}\n\n\tcxd2841er_sleep_tc_to_active_t_band(priv, bandwidth);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\n\tpriv->state = STATE_ACTIVE_TC;\n\treturn 0;\n}\n\nstatic int cxd2841er_sleep_tc_to_active_t2(struct cxd2841er_priv *priv,\n\t\t\t\t\t   u32 bandwidth)\n{\n\tu8 data[MAX_WRITE_REGSIZE];\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tcxd2841er_set_ts_clock_mode(priv, SYS_DVBT2);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x02);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x59, 0x00);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);\n\n\tif (priv->xtal == SONY_XTAL_41000) {\n\t\tdata[0] = 0x0A;\n\t\tdata[1] = 0xD4;\n\t} else {\n\t\tdata[0] = 0x09;\n\t\tdata[1] = 0x54;\n\t}\n\n\tcxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x0c, 0x1f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x50);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5,\n\t\t((priv->flags & CXD2841ER_ASCOT) ? 0x01 : 0x00), 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x8b, 0x3c);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x76, 0x20, 0x70);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x23);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xE6, 0x00, 0x03);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x83, 0x10);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x86, 0x34);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9e, 0x09, 0x0f);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x9f, 0xd8);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2a);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x38, 0x04, 0x0f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x11, 0x20, 0x3f);\n\n\t \n\tif (priv->xtal == SONY_XTAL_24000) {\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\n\t\tdata[0] = 0xEB;\n\t\tdata[1] = 0x03;\n\t\tdata[2] = 0x3B;\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0x33, data, 3);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\n\t\tdata[0] = 0x5E;\n\t\tdata[1] = 0x5E;\n\t\tdata[2] = 0x47;\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0x95, data, 3);\n\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x99, 0x18);\n\n\t\tdata[0] = 0x3F;\n\t\tdata[1] = 0xFF;\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x24);\n\t\tdata[0] = 0x0B;\n\t\tdata[1] = 0x72;\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0x34, data, 2);\n\n\t\tdata[0] = 0x93;\n\t\tdata[1] = 0xF3;\n\t\tdata[2] = 0x00;\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xD2, data, 3);\n\n\t\tdata[0] = 0x05;\n\t\tdata[1] = 0xB8;\n\t\tdata[2] = 0xD8;\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0xDD, data, 3);\n\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0xE0, 0x00);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x25);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0xED, 0x60);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0xFA, 0x34);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2B);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x4B, 0x2F);\n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x9E, 0x0E);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2D);\n\t\tdata[0] = 0x89;\n\t\tdata[1] = 0x89;\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0x24, data, 2);\n\n\t\t \n\t\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x5E);\n\t\tdata[0] = 0x24;\n\t\tdata[1] = 0x95;\n\t\tcxd2841er_write_regs(priv, I2C_SLVT, 0x8C, data, 2);\n\t}\n\n\tcxd2841er_sleep_tc_to_active_t2_band(priv, bandwidth);\n\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\n\tpriv->state = STATE_ACTIVE_TC;\n\treturn 0;\n}\n\n \nstatic int cxd2841er_sleep_tc_to_active_i(struct cxd2841er_priv *priv,\n\t\tu32 bandwidth)\n{\n\tu8 data[2] = { 0x09, 0x54 };\n\tu8 data24m[2] = {0x60, 0x00};\n\tu8 data24m2[3] = {0xB7, 0x1B, 0x00};\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tcxd2841er_set_ts_clock_mode(priv, SYS_DVBT);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x06);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x01);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x59, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);\n\t \n\tcxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5,\n\t\t((priv->flags & CXD2841ER_ASCOT) ? 0x01 : 0x00), 0x01);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x30, 0x01, 0x01);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x31, 0x00, 0x01);\n\t \n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x00, 0x01);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x00, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x69, 0x04, 0x07);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x6B, 0x03, 0x07);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9D, 0x50, 0xFF);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xD3, 0x06, 0x1F);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xED, 0x00, 0x01);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xE2, 0xCE, 0x80);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xF2, 0x13, 0x10);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xDE, 0x2E, 0x3F);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xDE, 0x02, 0x03);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x1E);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x73, 0x68, 0xFF);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x63);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0x81, 0x00, 0x01);\n\n\t \n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\tcxd2841er_write_regs(priv, I2C_SLVT, 0xBF, data24m, 2);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);\n\tcxd2841er_write_regs(priv, I2C_SLVT, 0xA8, data24m2, 3);\n\n\tcxd2841er_sleep_tc_to_active_i_band(priv, bandwidth);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\n\tpriv->state = STATE_ACTIVE_TC;\n\treturn 0;\n}\n\nstatic int cxd2841er_sleep_tc_to_active_c(struct cxd2841er_priv *priv,\n\t\t\t\t\t  u32 bandwidth)\n{\n\tu8 data[2] = { 0x09, 0x54 };\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tcxd2841er_set_ts_clock_mode(priv, SYS_DVBC_ANNEX_A);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x04);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x59, 0x00);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);\n\t \n\tcxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x09, 0x1f);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x48);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5,\n\t\t((priv->flags & CXD2841ER_ASCOT) ? 0x01 : 0x00), 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc3, 0x00, 0x04);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);\n\n\tcxd2841er_sleep_tc_to_active_c_band(priv, bandwidth);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\n\tpriv->state = STATE_ACTIVE_TC;\n\treturn 0;\n}\n\nstatic int cxd2841er_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t  struct dtv_frontend_properties *p)\n{\n\tenum fe_status status = 0;\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state == STATE_ACTIVE_S)\n\t\tcxd2841er_read_status_s(fe, &status);\n\telse if (priv->state == STATE_ACTIVE_TC)\n\t\tcxd2841er_read_status_tc(fe, &status);\n\n\tif (priv->state == STATE_ACTIVE_TC || priv->state == STATE_ACTIVE_S)\n\t\tcxd2841er_read_signal_strength(fe);\n\telse\n\t\tp->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tif (status & FE_HAS_LOCK) {\n\t\tif (priv->stats_time &&\n\t\t    (!time_after(jiffies, priv->stats_time)))\n\t\t\treturn 0;\n\n\t\t \n\t\tpriv->stats_time = jiffies + msecs_to_jiffies(1000);\n\n\t\tcxd2841er_read_snr(fe);\n\t\tcxd2841er_read_ucblocks(fe);\n\t\tcxd2841er_read_ber(fe);\n\t} else {\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\treturn 0;\n}\n\nstatic int cxd2841er_set_frontend_s(struct dvb_frontend *fe)\n{\n\tint ret = 0, i, timeout, carr_offset;\n\tenum fe_status status;\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 symbol_rate = p->symbol_rate/1000;\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): %s frequency=%d symbol_rate=%d xtal=%d\\n\",\n\t\t__func__,\n\t\t(p->delivery_system == SYS_DVBS ? \"DVB-S\" : \"DVB-S2\"),\n\t\t p->frequency, symbol_rate, priv->xtal);\n\n\tif (priv->flags & CXD2841ER_EARLY_TUNE)\n\t\tcxd2841er_tuner_set(fe);\n\n\tswitch (priv->state) {\n\tcase STATE_SLEEP_S:\n\t\tret = cxd2841er_sleep_s_to_active_s(\n\t\t\tpriv, p->delivery_system, symbol_rate);\n\t\tbreak;\n\tcase STATE_ACTIVE_S:\n\t\tret = cxd2841er_retune_active(priv, p);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tif (ret) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): tune failed\\n\", __func__);\n\t\tgoto done;\n\t}\n\n\tif (!(priv->flags & CXD2841ER_EARLY_TUNE))\n\t\tcxd2841er_tuner_set(fe);\n\n\tcxd2841er_tune_done(priv);\n\ttimeout = DIV_ROUND_UP(3000000, symbol_rate) + 150;\n\n\ti = 0;\n\tdo {\n\t\tusleep_range(CXD2841ER_DVBS_POLLING_INVL*1000,\n\t\t\t(CXD2841ER_DVBS_POLLING_INVL + 2) * 1000);\n\t\tcxd2841er_read_status_s(fe, &status);\n\t\tif (status & FE_HAS_LOCK)\n\t\t\tbreak;\n\t\ti++;\n\t} while (i < timeout / CXD2841ER_DVBS_POLLING_INVL);\n\n\tif (status & FE_HAS_LOCK) {\n\t\tif (cxd2841er_get_carrier_offset_s_s2(\n\t\t\t\tpriv, &carr_offset)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): carrier_offset=%d\\n\",\n\t\t\t__func__, carr_offset);\n\t}\ndone:\n\t \n\tp->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\t \n\tpriv->stats_time = 0;\n\n\treturn ret;\n}\n\nstatic int cxd2841er_set_frontend_tc(struct dvb_frontend *fe)\n{\n\tint ret = 0, timeout;\n\tenum fe_status status;\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tdev_dbg(&priv->i2c->dev, \"%s() delivery_system=%d bandwidth_hz=%d\\n\",\n\t\t __func__, p->delivery_system, p->bandwidth_hz);\n\n\tif (priv->flags & CXD2841ER_EARLY_TUNE)\n\t\tcxd2841er_tuner_set(fe);\n\n\t \n\tif (priv->state == STATE_ACTIVE_TC &&\n\t    priv->system != p->delivery_system) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): old_delsys=%d, new_delsys=%d -> sleep\\n\",\n\t\t\t __func__, priv->system, p->delivery_system);\n\t\tcxd2841er_sleep_tc(fe);\n\t}\n\n\tif (p->delivery_system == SYS_DVBT) {\n\t\tpriv->system = SYS_DVBT;\n\t\tswitch (priv->state) {\n\t\tcase STATE_SLEEP_TC:\n\t\t\tret = cxd2841er_sleep_tc_to_active_t(\n\t\t\t\tpriv, p->bandwidth_hz);\n\t\t\tbreak;\n\t\tcase STATE_ACTIVE_TC:\n\t\t\tret = cxd2841er_retune_active(priv, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t\t__func__, priv->state);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if (p->delivery_system == SYS_DVBT2) {\n\t\tpriv->system = SYS_DVBT2;\n\t\tcxd2841er_dvbt2_set_plp_config(priv,\n\t\t\t(int)(p->stream_id > 255), p->stream_id);\n\t\tcxd2841er_dvbt2_set_profile(priv, DVBT2_PROFILE_BASE);\n\t\tswitch (priv->state) {\n\t\tcase STATE_SLEEP_TC:\n\t\t\tret = cxd2841er_sleep_tc_to_active_t2(priv,\n\t\t\t\tp->bandwidth_hz);\n\t\t\tbreak;\n\t\tcase STATE_ACTIVE_TC:\n\t\t\tret = cxd2841er_retune_active(priv, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t\t__func__, priv->state);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if (p->delivery_system == SYS_ISDBT) {\n\t\tpriv->system = SYS_ISDBT;\n\t\tswitch (priv->state) {\n\t\tcase STATE_SLEEP_TC:\n\t\t\tret = cxd2841er_sleep_tc_to_active_i(\n\t\t\t\t\tpriv, p->bandwidth_hz);\n\t\t\tbreak;\n\t\tcase STATE_ACTIVE_TC:\n\t\t\tret = cxd2841er_retune_active(priv, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t\t\t__func__, priv->state);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if (p->delivery_system == SYS_DVBC_ANNEX_A ||\n\t\t\tp->delivery_system == SYS_DVBC_ANNEX_C) {\n\t\tpriv->system = SYS_DVBC_ANNEX_A;\n\t\t \n\t\tif (p->bandwidth_hz != 6000000 &&\n\t\t\t\tp->bandwidth_hz != 7000000 &&\n\t\t\t\tp->bandwidth_hz != 8000000) {\n\t\t\tp->bandwidth_hz = 8000000;\n\t\t\tdev_dbg(&priv->i2c->dev, \"%s(): forcing bandwidth to %d\\n\",\n\t\t\t\t\t__func__, p->bandwidth_hz);\n\t\t}\n\n\t\tswitch (priv->state) {\n\t\tcase STATE_SLEEP_TC:\n\t\t\tret = cxd2841er_sleep_tc_to_active_c(\n\t\t\t\tpriv, p->bandwidth_hz);\n\t\t\tbreak;\n\t\tcase STATE_ACTIVE_TC:\n\t\t\tret = cxd2841er_retune_active(priv, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t\t__func__, priv->state);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): invalid delivery system %d\\n\",\n\t\t\t__func__, p->delivery_system);\n\t\tret = -EINVAL;\n\t}\n\tif (ret)\n\t\tgoto done;\n\n\tif (!(priv->flags & CXD2841ER_EARLY_TUNE))\n\t\tcxd2841er_tuner_set(fe);\n\n\tcxd2841er_tune_done(priv);\n\n\tif (priv->flags & CXD2841ER_NO_WAIT_LOCK)\n\t\tgoto done;\n\n\ttimeout = 2500;\n\twhile (timeout > 0) {\n\t\tret = cxd2841er_read_status_tc(fe, &status);\n\t\tif (ret)\n\t\t\tgoto done;\n\t\tif (status & FE_HAS_LOCK)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t\ttimeout -= 20;\n\t}\n\tif (timeout < 0)\n\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): LOCK wait timeout\\n\", __func__);\ndone:\n\treturn ret;\n}\n\nstatic int cxd2841er_tune_s(struct dvb_frontend *fe,\n\t\t\t    bool re_tune,\n\t\t\t    unsigned int mode_flags,\n\t\t\t    unsigned int *delay,\n\t\t\t    enum fe_status *status)\n{\n\tint ret, carrier_offset;\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tdev_dbg(&priv->i2c->dev, \"%s() re_tune=%d\\n\", __func__, re_tune);\n\tif (re_tune) {\n\t\tret = cxd2841er_set_frontend_s(fe);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcxd2841er_read_status_s(fe, status);\n\t\tif (*status & FE_HAS_LOCK) {\n\t\t\tif (cxd2841er_get_carrier_offset_s_s2(\n\t\t\t\t\tpriv, &carrier_offset))\n\t\t\t\treturn -EINVAL;\n\t\t\tp->frequency += carrier_offset;\n\t\t\tret = cxd2841er_set_frontend_s(fe);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\t*delay = HZ / 5;\n\treturn cxd2841er_read_status_s(fe, status);\n}\n\nstatic int cxd2841er_tune_tc(struct dvb_frontend *fe,\n\t\t\t     bool re_tune,\n\t\t\t     unsigned int mode_flags,\n\t\t\t     unsigned int *delay,\n\t\t\t     enum fe_status *status)\n{\n\tint ret, carrier_offset;\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): re_tune %d bandwidth=%d\\n\", __func__,\n\t\t\tre_tune, p->bandwidth_hz);\n\tif (re_tune) {\n\t\tret = cxd2841er_set_frontend_tc(fe);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcxd2841er_read_status_tc(fe, status);\n\t\tif (*status & FE_HAS_LOCK) {\n\t\t\tswitch (priv->system) {\n\t\t\tcase SYS_ISDBT:\n\t\t\t\tret = cxd2841er_get_carrier_offset_i(\n\t\t\t\t\t\tpriv, p->bandwidth_hz,\n\t\t\t\t\t\t&carrier_offset);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tbreak;\n\t\t\tcase SYS_DVBT:\n\t\t\t\tret = cxd2841er_get_carrier_offset_t(\n\t\t\t\t\tpriv, p->bandwidth_hz,\n\t\t\t\t\t&carrier_offset);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tbreak;\n\t\t\tcase SYS_DVBT2:\n\t\t\t\tret = cxd2841er_get_carrier_offset_t2(\n\t\t\t\t\tpriv, p->bandwidth_hz,\n\t\t\t\t\t&carrier_offset);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tbreak;\n\t\t\tcase SYS_DVBC_ANNEX_A:\n\t\t\t\tret = cxd2841er_get_carrier_offset_c(\n\t\t\t\t\tpriv, &carrier_offset);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\t\"%s(): invalid delivery system %d\\n\",\n\t\t\t\t\t__func__, priv->system);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdev_dbg(&priv->i2c->dev, \"%s(): carrier offset %d\\n\",\n\t\t\t\t__func__, carrier_offset);\n\t\t\tp->frequency += carrier_offset;\n\t\t\tret = cxd2841er_set_frontend_tc(fe);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\t*delay = HZ / 5;\n\treturn cxd2841er_read_status_tc(fe, status);\n}\n\nstatic int cxd2841er_sleep_s(struct dvb_frontend *fe)\n{\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tcxd2841er_active_s_to_sleep_s(fe->demodulator_priv);\n\tcxd2841er_sleep_s_to_shutdown(fe->demodulator_priv);\n\treturn 0;\n}\n\nstatic int cxd2841er_sleep_tc(struct dvb_frontend *fe)\n{\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\n\tif (priv->state == STATE_ACTIVE_TC) {\n\t\tswitch (priv->system) {\n\t\tcase SYS_DVBT:\n\t\t\tcxd2841er_active_t_to_sleep_tc(priv);\n\t\t\tbreak;\n\t\tcase SYS_DVBT2:\n\t\t\tcxd2841er_active_t2_to_sleep_tc(priv);\n\t\t\tbreak;\n\t\tcase SYS_ISDBT:\n\t\t\tcxd2841er_active_i_to_sleep_tc(priv);\n\t\t\tbreak;\n\t\tcase SYS_DVBC_ANNEX_A:\n\t\t\tcxd2841er_active_c_to_sleep_tc(priv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&priv->i2c->dev,\n\t\t\t\t\"%s(): unknown delivery system %d\\n\",\n\t\t\t\t__func__, priv->system);\n\t\t}\n\t}\n\tif (priv->state != STATE_SLEEP_TC) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cxd2841er_shutdown_tc(struct dvb_frontend *fe)\n{\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\n\tif (!cxd2841er_sleep_tc(fe))\n\t\tcxd2841er_sleep_tc_to_shutdown(priv);\n\treturn 0;\n}\n\nstatic int cxd2841er_send_burst(struct dvb_frontend *fe,\n\t\t\t\tenum fe_sec_mini_cmd burst)\n{\n\tu8 data;\n\tstruct cxd2841er_priv *priv  = fe->demodulator_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): burst mode %s\\n\", __func__,\n\t\t(burst == SEC_MINI_A ? \"A\" : \"B\"));\n\tif (priv->state != STATE_SLEEP_S &&\n\t\t\tpriv->state != STATE_ACTIVE_S) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid demod state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tdata = (burst == SEC_MINI_A ? 0 : 1);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x34, 0x01);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x35, data);\n\treturn 0;\n}\n\nstatic int cxd2841er_set_tone(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_tone_mode tone)\n{\n\tu8 data;\n\tstruct cxd2841er_priv *priv  = fe->demodulator_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): tone %s\\n\", __func__,\n\t\t(tone == SEC_TONE_ON ? \"On\" : \"Off\"));\n\tif (priv->state != STATE_SLEEP_S &&\n\t\t\tpriv->state != STATE_ACTIVE_S) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid demod state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tdata = (tone == SEC_TONE_ON ? 1 : 0);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x36, data);\n\treturn 0;\n}\n\nstatic int cxd2841er_send_diseqc_msg(struct dvb_frontend *fe,\n\t\t\t\t     struct dvb_diseqc_master_cmd *cmd)\n{\n\tint i;\n\tu8 data[12];\n\tstruct cxd2841er_priv *priv  = fe->demodulator_priv;\n\n\tif (priv->state != STATE_SLEEP_S &&\n\t\t\tpriv->state != STATE_ACTIVE_S) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid demod state %d\\n\",\n\t\t\t__func__, priv->state);\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(&priv->i2c->dev,\n\t\t\"%s(): cmd->len %d\\n\", __func__, cmd->msg_len);\n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x33, 0x01);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x3d, cmd->msg_len);\n\tmemset(data, 0, sizeof(data));\n\tfor (i = 0; i < cmd->msg_len && i < sizeof(data); i++)\n\t\tdata[i] = cmd->msg[i];\n\tcxd2841er_write_regs(priv, I2C_SLVT, 0x3e, data, sizeof(data));\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x37, 1);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x38, 0);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x32, 0x01);\n\t \n\tfor (i = 0; i < 50; i++) {\n\t\tcxd2841er_read_reg(priv, I2C_SLVT, 0x10, data);\n\t\tif (!data[0]) {\n\t\t\tdev_dbg(&priv->i2c->dev,\n\t\t\t\t\"%s(): DiSEqC cmd has been sent\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\t\tmsleep(20);\n\t}\n\tdev_dbg(&priv->i2c->dev,\n\t\t\"%s(): DiSEqC cmd transmit timeout\\n\", __func__);\n\treturn -ETIMEDOUT;\n}\n\nstatic void cxd2841er_release(struct dvb_frontend *fe)\n{\n\tstruct cxd2841er_priv *priv  = fe->demodulator_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tkfree(priv);\n}\n\nstatic int cxd2841er_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): enable=%d\\n\", __func__, enable);\n\tcxd2841er_set_reg_bits(\n\t\tpriv, I2C_SLVX, 0x8, (enable ? 0x01 : 0x00), 0x01);\n\treturn 0;\n}\n\nstatic enum dvbfe_algo cxd2841er_get_algo(struct dvb_frontend *fe)\n{\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic void cxd2841er_init_stats(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tp->strength.len = 1;\n\tp->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\tp->cnr.len = 1;\n\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->block_error.len = 1;\n\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->post_bit_error.len = 1;\n\tp->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->post_bit_count.len = 1;\n\tp->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n}\n\n\nstatic int cxd2841er_init_s(struct dvb_frontend *fe)\n{\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\n\t \n\tif (priv->state == STATE_SLEEP_S) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s() forcing sleep->shutdown\\n\",\n\t\t\t\t__func__);\n\t\tcxd2841er_sleep_s_to_shutdown(priv);\n\t} else if (priv->state == STATE_ACTIVE_S) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s() forcing active->sleep->shutdown\\n\",\n\t\t\t\t__func__);\n\t\tcxd2841er_active_s_to_sleep_s(priv);\n\t\tcxd2841er_sleep_s_to_shutdown(priv);\n\t}\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tcxd2841er_shutdown_to_sleep_s(priv);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xb9, 0x01, 0x01);\n\n\tcxd2841er_init_stats(fe);\n\n\treturn 0;\n}\n\nstatic int cxd2841er_init_tc(struct dvb_frontend *fe)\n{\n\tstruct cxd2841er_priv *priv = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tdev_dbg(&priv->i2c->dev, \"%s() bandwidth_hz=%d\\n\",\n\t\t\t__func__, p->bandwidth_hz);\n\tcxd2841er_shutdown_to_sleep_tc(priv);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcb,\n\t\t((priv->flags & CXD2841ER_NO_AGCNEG) ? 0x00 : 0x40), 0x40);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0xcd, 0x50);\n\t \n\tcxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\n\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc4,\n\t\t((priv->flags & CXD2841ER_TS_SERIAL) ? 0x80 : 0x00), 0x80);\n\n\t \n\tif (priv->flags & CXD2841ER_TSBITS)\n\t\tcxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc4, 0x00, 0x18);\n\n\tcxd2841er_init_stats(fe);\n\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops cxd2841er_dvbs_s2_ops;\nstatic struct dvb_frontend_ops cxd2841er_t_c_ops;\n\nstatic struct dvb_frontend *cxd2841er_attach(struct cxd2841er_config *cfg,\n\t\t\t\t\t     struct i2c_adapter *i2c,\n\t\t\t\t\t     u8 system)\n{\n\tu8 chip_id = 0;\n\tconst char *type;\n\tconst char *name;\n\tstruct cxd2841er_priv *priv = NULL;\n\n\t \n\tpriv = kzalloc(sizeof(struct cxd2841er_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn NULL;\n\tpriv->i2c = i2c;\n\tpriv->config = cfg;\n\tpriv->i2c_addr_slvx = (cfg->i2c_addr + 4) >> 1;\n\tpriv->i2c_addr_slvt = (cfg->i2c_addr) >> 1;\n\tpriv->xtal = cfg->xtal;\n\tpriv->flags = cfg->flags;\n\tpriv->frontend.demodulator_priv = priv;\n\tdev_info(&priv->i2c->dev,\n\t\t\"%s(): I2C adapter %p SLVX addr %x SLVT addr %x\\n\",\n\t\t__func__, priv->i2c,\n\t\tpriv->i2c_addr_slvx, priv->i2c_addr_slvt);\n\tchip_id = cxd2841er_chip_id(priv);\n\tswitch (chip_id) {\n\tcase CXD2837ER_CHIP_ID:\n\t\tsnprintf(cxd2841er_t_c_ops.info.name, 128,\n\t\t\t\t\"Sony CXD2837ER DVB-T/T2/C demodulator\");\n\t\tname = \"CXD2837ER\";\n\t\ttype = \"C/T/T2\";\n\t\tbreak;\n\tcase CXD2838ER_CHIP_ID:\n\t\tsnprintf(cxd2841er_t_c_ops.info.name, 128,\n\t\t\t\t\"Sony CXD2838ER ISDB-T demodulator\");\n\t\tcxd2841er_t_c_ops.delsys[0] = SYS_ISDBT;\n\t\tcxd2841er_t_c_ops.delsys[1] = SYS_UNDEFINED;\n\t\tcxd2841er_t_c_ops.delsys[2] = SYS_UNDEFINED;\n\t\tname = \"CXD2838ER\";\n\t\ttype = \"ISDB-T\";\n\t\tbreak;\n\tcase CXD2841ER_CHIP_ID:\n\t\tsnprintf(cxd2841er_t_c_ops.info.name, 128,\n\t\t\t\t\"Sony CXD2841ER DVB-T/T2/C demodulator\");\n\t\tname = \"CXD2841ER\";\n\t\ttype = \"T/T2/C/ISDB-T\";\n\t\tbreak;\n\tcase CXD2843ER_CHIP_ID:\n\t\tsnprintf(cxd2841er_t_c_ops.info.name, 128,\n\t\t\t\t\"Sony CXD2843ER DVB-T/T2/C/C2 demodulator\");\n\t\tname = \"CXD2843ER\";\n\t\ttype = \"C/C2/T/T2\";\n\t\tbreak;\n\tcase CXD2854ER_CHIP_ID:\n\t\tsnprintf(cxd2841er_t_c_ops.info.name, 128,\n\t\t\t\t\"Sony CXD2854ER DVB-T/T2/C and ISDB-T demodulator\");\n\t\tcxd2841er_t_c_ops.delsys[3] = SYS_ISDBT;\n\t\tname = \"CXD2854ER\";\n\t\ttype = \"C/C2/T/T2/ISDB-T\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&priv->i2c->dev, \"%s(): invalid chip ID 0x%02x\\n\",\n\t\t\t\t__func__, chip_id);\n\t\tpriv->frontend.demodulator_priv = NULL;\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (system == SYS_DVBS) {\n\t\tmemcpy(&priv->frontend.ops,\n\t\t\t&cxd2841er_dvbs_s2_ops,\n\t\t\tsizeof(struct dvb_frontend_ops));\n\t\ttype = \"S/S2\";\n\t} else {\n\t\tmemcpy(&priv->frontend.ops,\n\t\t\t&cxd2841er_t_c_ops,\n\t\t\tsizeof(struct dvb_frontend_ops));\n\t}\n\n\tdev_info(&priv->i2c->dev,\n\t\t\"%s(): attaching %s DVB-%s frontend\\n\",\n\t\t__func__, name, type);\n\tdev_info(&priv->i2c->dev, \"%s(): chip ID 0x%02x OK.\\n\",\n\t\t__func__, chip_id);\n\treturn &priv->frontend;\n}\n\nstruct dvb_frontend *cxd2841er_attach_s(struct cxd2841er_config *cfg,\n\t\t\t\t\tstruct i2c_adapter *i2c)\n{\n\treturn cxd2841er_attach(cfg, i2c, SYS_DVBS);\n}\nEXPORT_SYMBOL_GPL(cxd2841er_attach_s);\n\nstruct dvb_frontend *cxd2841er_attach_t_c(struct cxd2841er_config *cfg,\n\t\t\t\t\tstruct i2c_adapter *i2c)\n{\n\treturn cxd2841er_attach(cfg, i2c, 0);\n}\nEXPORT_SYMBOL_GPL(cxd2841er_attach_t_c);\n\nstatic const struct dvb_frontend_ops cxd2841er_dvbs_s2_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2 },\n\t.info = {\n\t\t.name\t\t= \"Sony CXD2841ER DVB-S/S2 demodulator\",\n\t\t.frequency_min_hz\t=  500 * MHz,\n\t\t.frequency_max_hz\t= 2500 * MHz,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.symbol_rate_tolerance = 500,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK,\n\t},\n\t.init = cxd2841er_init_s,\n\t.sleep = cxd2841er_sleep_s,\n\t.release = cxd2841er_release,\n\t.set_frontend = cxd2841er_set_frontend_s,\n\t.get_frontend = cxd2841er_get_frontend,\n\t.read_status = cxd2841er_read_status_s,\n\t.i2c_gate_ctrl = cxd2841er_i2c_gate_ctrl,\n\t.get_frontend_algo = cxd2841er_get_algo,\n\t.set_tone = cxd2841er_set_tone,\n\t.diseqc_send_burst = cxd2841er_send_burst,\n\t.diseqc_send_master_cmd = cxd2841er_send_diseqc_msg,\n\t.tune = cxd2841er_tune_s\n};\n\nstatic struct dvb_frontend_ops cxd2841er_t_c_ops = {\n\t.delsys = { SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },\n\t.info = {\n\t\t.name\t= \"\",  \n\t\t.caps = FE_CAN_FEC_1_2 |\n\t\t\tFE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 |\n\t\t\tFE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK |\n\t\t\tFE_CAN_QAM_16 |\n\t\t\tFE_CAN_QAM_32 |\n\t\t\tFE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_128 |\n\t\t\tFE_CAN_QAM_256 |\n\t\t\tFE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO |\n\t\t\tFE_CAN_MUTE_TS |\n\t\t\tFE_CAN_2G_MODULATION,\n\t\t.frequency_min_hz =   42 * MHz,\n\t\t.frequency_max_hz = 1002 * MHz,\n\t\t.symbol_rate_min = 870000,\n\t\t.symbol_rate_max = 11700000\n\t},\n\t.init = cxd2841er_init_tc,\n\t.sleep = cxd2841er_shutdown_tc,\n\t.release = cxd2841er_release,\n\t.set_frontend = cxd2841er_set_frontend_tc,\n\t.get_frontend = cxd2841er_get_frontend,\n\t.read_status = cxd2841er_read_status_tc,\n\t.tune = cxd2841er_tune_tc,\n\t.i2c_gate_ctrl = cxd2841er_i2c_gate_ctrl,\n\t.get_frontend_algo = cxd2841er_get_algo\n};\n\nMODULE_DESCRIPTION(\"Sony CXD2837/38/41/43/54ER DVB-C/C2/T/T2/S/S2 demodulator driver\");\nMODULE_AUTHOR(\"Sergey Kozlov <serjk@netup.ru>, Abylay Ospan <aospan@netup.ru>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}