{
  "module_name": "lnbh29.c",
  "hash_id": "7d5b22926dbd89ae84a19b6379e845e6e3bef5357d74b6d3b4b88f973b095ea6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/lnbh29.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"lnbh29.h\"\n\n \nstruct lnbh29_priv {\n\tstruct i2c_adapter *i2c;\n\tu8 i2c_address;\n\tu8 config[2];\n};\n\n#define LNBH29_STATUS_OLF     BIT(0)\n#define LNBH29_STATUS_OTF     BIT(1)\n#define LNBH29_STATUS_VMON    BIT(2)\n#define LNBH29_STATUS_PNG     BIT(3)\n#define LNBH29_STATUS_PDO     BIT(4)\n#define LNBH29_VSEL_MASK      GENMASK(2, 0)\n#define LNBH29_VSEL_0         0x00\n \n#define LNBH29_VSEL_13        0x03\n \n#define LNBH29_VSEL_18        0x07\n\nstatic int lnbh29_read_vmon(struct lnbh29_priv *priv)\n{\n\tu8 addr = 0x00;\n\tu8 status[2];\n\tint ret;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = priv->i2c_address,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &addr\n\t\t}, {\n\t\t\t.addr = priv->i2c_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(status),\n\t\t\t.buf = status\n\t\t}\n\t};\n\n\tret = i2c_transfer(priv->i2c, msg, 2);\n\tif (ret >= 0 && ret != 2)\n\t\tret = -EIO;\n\tif (ret < 0) {\n\t\tdev_dbg(&priv->i2c->dev, \"LNBH29 I2C transfer failed (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (status[0] & (LNBH29_STATUS_OLF | LNBH29_STATUS_VMON)) {\n\t\tdev_err(&priv->i2c->dev,\n\t\t\t\"LNBH29 voltage in failure state, status reg 0x%x\\n\",\n\t\t\tstatus[0]);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int lnbh29_set_voltage(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_voltage voltage)\n{\n\tstruct lnbh29_priv *priv = fe->sec_priv;\n\tu8 data_reg;\n\tint ret;\n\tstruct i2c_msg msg = {\n\t\t.addr = priv->i2c_address,\n\t\t.flags = 0,\n\t\t.len = sizeof(priv->config),\n\t\t.buf = priv->config\n\t};\n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_OFF:\n\t\tdata_reg = LNBH29_VSEL_0;\n\t\tbreak;\n\tcase SEC_VOLTAGE_13:\n\t\tdata_reg = LNBH29_VSEL_13;\n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\n\t\tdata_reg = LNBH29_VSEL_18;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tpriv->config[1] &= ~LNBH29_VSEL_MASK;\n\tpriv->config[1] |= data_reg;\n\n\tret = i2c_transfer(priv->i2c, &msg, 1);\n\tif (ret >= 0 && ret != 1)\n\t\tret = -EIO;\n\tif (ret < 0) {\n\t\tdev_err(&priv->i2c->dev, \"LNBH29 I2C transfer error (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tusleep_range(6000, 20000);\n\n\tif (voltage == SEC_VOLTAGE_OFF)\n\t\treturn 0;\n\n\treturn lnbh29_read_vmon(priv);\n}\n\nstatic void lnbh29_release(struct dvb_frontend *fe)\n{\n\tlnbh29_set_voltage(fe, SEC_VOLTAGE_OFF);\n\tkfree(fe->sec_priv);\n\tfe->sec_priv = NULL;\n}\n\nstruct dvb_frontend *lnbh29_attach(struct dvb_frontend *fe,\n\t\t\t\t   struct lnbh29_config *cfg,\n\t\t\t\t   struct i2c_adapter *i2c)\n{\n\tstruct lnbh29_priv *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn NULL;\n\n\tpriv->i2c_address = (cfg->i2c_address >> 1);\n\tpriv->i2c = i2c;\n\tpriv->config[0] = 0x01;\n\tpriv->config[1] = cfg->data_config;\n\tfe->sec_priv = priv;\n\n\tif (lnbh29_set_voltage(fe, SEC_VOLTAGE_OFF)) {\n\t\tdev_err(&i2c->dev, \"no LNBH29 found at I2C addr 0x%02x\\n\",\n\t\t\tpriv->i2c_address);\n\t\tkfree(priv);\n\t\tfe->sec_priv = NULL;\n\t\treturn NULL;\n\t}\n\n\tfe->ops.release_sec = lnbh29_release;\n\tfe->ops.set_voltage = lnbh29_set_voltage;\n\n\tdev_info(&i2c->dev, \"LNBH29 attached at I2C addr 0x%02x\\n\",\n\t\t priv->i2c_address);\n\n\treturn fe;\n}\nEXPORT_SYMBOL(lnbh29_attach);\n\nMODULE_AUTHOR(\"Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics LNBH29 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}