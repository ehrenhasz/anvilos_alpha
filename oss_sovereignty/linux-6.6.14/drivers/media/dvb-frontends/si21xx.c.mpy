{
  "module_name": "si21xx.c",
  "hash_id": "df59580ae3a675159c6222923f042ddb7a5f42b7d13f618a51d7690373e6bfef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/si21xx.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"si21xx.h\"\n\n#define\tREVISION_REG\t\t\t0x00\n#define\tSYSTEM_MODE_REG\t\t\t0x01\n#define\tTS_CTRL_REG_1\t\t\t0x02\n#define\tTS_CTRL_REG_2\t\t\t0x03\n#define\tPIN_CTRL_REG_1\t\t\t0x04\n#define\tPIN_CTRL_REG_2\t\t\t0x05\n#define\tLOCK_STATUS_REG_1\t\t0x0f\n#define\tLOCK_STATUS_REG_2\t\t0x10\n#define\tACQ_STATUS_REG\t\t\t0x11\n#define\tACQ_CTRL_REG_1\t\t\t0x13\n#define\tACQ_CTRL_REG_2\t\t\t0x14\n#define\tPLL_DIVISOR_REG\t\t\t0x15\n#define\tCOARSE_TUNE_REG\t\t\t0x16\n#define\tFINE_TUNE_REG_L\t\t\t0x17\n#define\tFINE_TUNE_REG_H\t\t\t0x18\n\n#define\tANALOG_AGC_POWER_LEVEL_REG\t0x28\n#define\tCFO_ESTIMATOR_CTRL_REG_1\t0x29\n#define\tCFO_ESTIMATOR_CTRL_REG_2\t0x2a\n#define\tCFO_ESTIMATOR_CTRL_REG_3\t0x2b\n\n#define\tSYM_RATE_ESTIMATE_REG_L\t\t0x31\n#define\tSYM_RATE_ESTIMATE_REG_M\t\t0x32\n#define\tSYM_RATE_ESTIMATE_REG_H\t\t0x33\n\n#define\tCFO_ESTIMATOR_OFFSET_REG_L\t0x36\n#define\tCFO_ESTIMATOR_OFFSET_REG_H\t0x37\n#define\tCFO_ERROR_REG_L\t\t\t0x38\n#define\tCFO_ERROR_REG_H\t\t\t0x39\n#define\tSYM_RATE_ESTIMATOR_CTRL_REG\t0x3a\n\n#define\tSYM_RATE_REG_L\t\t\t0x3f\n#define\tSYM_RATE_REG_M\t\t\t0x40\n#define\tSYM_RATE_REG_H\t\t\t0x41\n#define\tSYM_RATE_ESTIMATOR_MAXIMUM_REG\t0x42\n#define\tSYM_RATE_ESTIMATOR_MINIMUM_REG\t0x43\n\n#define\tC_N_ESTIMATOR_CTRL_REG\t\t0x7c\n#define\tC_N_ESTIMATOR_THRSHLD_REG\t0x7d\n#define\tC_N_ESTIMATOR_LEVEL_REG_L\t0x7e\n#define\tC_N_ESTIMATOR_LEVEL_REG_H\t0x7f\n\n#define\tBLIND_SCAN_CTRL_REG\t\t0x80\n\n#define\tLSA_CTRL_REG_1\t\t\t0x8D\n#define\tSPCTRM_TILT_CORR_THRSHLD_REG\t0x8f\n#define\tONE_DB_BNDWDTH_THRSHLD_REG\t0x90\n#define\tTWO_DB_BNDWDTH_THRSHLD_REG\t0x91\n#define\tTHREE_DB_BNDWDTH_THRSHLD_REG\t0x92\n#define\tINBAND_POWER_THRSHLD_REG\t0x93\n#define\tREF_NOISE_LVL_MRGN_THRSHLD_REG\t0x94\n\n#define\tVIT_SRCH_CTRL_REG_1\t\t0xa0\n#define\tVIT_SRCH_CTRL_REG_2\t\t0xa1\n#define\tVIT_SRCH_CTRL_REG_3\t\t0xa2\n#define\tVIT_SRCH_STATUS_REG\t\t0xa3\n#define\tVITERBI_BER_COUNT_REG_L\t\t0xab\n#define\tREED_SOLOMON_CTRL_REG\t\t0xb0\n#define\tREED_SOLOMON_ERROR_COUNT_REG_L\t0xb1\n#define\tPRBS_CTRL_REG\t\t\t0xb5\n\n#define\tLNB_CTRL_REG_1\t\t\t0xc0\n#define\tLNB_CTRL_REG_2\t\t\t0xc1\n#define\tLNB_CTRL_REG_3\t\t\t0xc2\n#define\tLNB_CTRL_REG_4\t\t\t0xc3\n#define\tLNB_CTRL_STATUS_REG\t\t0xc4\n#define\tLNB_FIFO_REGS_0\t\t\t0xc5\n#define\tLNB_FIFO_REGS_1\t\t\t0xc6\n#define\tLNB_FIFO_REGS_2\t\t\t0xc7\n#define\tLNB_FIFO_REGS_3\t\t\t0xc8\n#define\tLNB_FIFO_REGS_4\t\t\t0xc9\n#define\tLNB_FIFO_REGS_5\t\t\t0xca\n#define\tLNB_SUPPLY_CTRL_REG_1\t\t0xcb\n#define\tLNB_SUPPLY_CTRL_REG_2\t\t0xcc\n#define\tLNB_SUPPLY_CTRL_REG_3\t\t0xcd\n#define\tLNB_SUPPLY_CTRL_REG_4\t\t0xce\n#define\tLNB_SUPPLY_STATUS_REG\t\t0xcf\n\n#define FAIL\t-1\n#define PASS\t0\n\n#define ALLOWABLE_FS_COUNT\t10\n#define STATUS_BER\t\t0\n#define STATUS_UCBLOCKS\t\t1\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_DEBUG \"si21xx: \" args); \\\n\t} while (0)\n\nenum {\n\tACTIVE_HIGH,\n\tACTIVE_LOW\n};\nenum {\n\tBYTE_WIDE,\n\tBIT_WIDE\n};\nenum {\n\tCLK_GAPPED_MODE,\n\tCLK_CONTINUOUS_MODE\n};\nenum {\n\tRISING_EDGE,\n\tFALLING_EDGE\n};\nenum {\n\tMSB_FIRST,\n\tLSB_FIRST\n};\nenum {\n\tSERIAL,\n\tPARALLEL\n};\n\nstruct si21xx_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct si21xx_config *config;\n\tstruct dvb_frontend frontend;\n\tu8 initialised:1;\n\tint errmode;\n\tint fs;\t\t\t \n};\n\n \nstatic u8 serit_sp1511lhb_inittab[] = {\n\t0x01, 0x28,\t \n\t0x20, 0x03,\n\t0x27, 0x20,\n\t0xe0, 0x45,\n\t0xe1, 0x08,\n\t0xfe, 0x01,\n\t0x01, 0x28,\n\t0x89, 0x09,\n\t0x04, 0x80,\n\t0x05, 0x01,\n\t0x06, 0x00,\n\t0x20, 0x03,\n\t0x24, 0x88,\n\t0x29, 0x09,\n\t0x2a, 0x0f,\n\t0x2c, 0x10,\n\t0x2d, 0x19,\n\t0x2e, 0x08,\n\t0x2f, 0x10,\n\t0x30, 0x19,\n\t0x34, 0x20,\n\t0x35, 0x03,\n\t0x45, 0x02,\n\t0x46, 0x45,\n\t0x47, 0xd0,\n\t0x48, 0x00,\n\t0x49, 0x40,\n\t0x4a, 0x03,\n\t0x4c, 0xfd,\n\t0x4f, 0x2e,\n\t0x50, 0x2e,\n\t0x51, 0x10,\n\t0x52, 0x10,\n\t0x56, 0x92,\n\t0x59, 0x00,\n\t0x5a, 0x2d,\n\t0x5b, 0x33,\n\t0x5c, 0x1f,\n\t0x5f, 0x76,\n\t0x62, 0xc0,\n\t0x63, 0xc0,\n\t0x64, 0xf3,\n\t0x65, 0xf3,\n\t0x79, 0x40,\n\t0x6a, 0x40,\n\t0x6b, 0x0a,\n\t0x6c, 0x80,\n\t0x6d, 0x27,\n\t0x71, 0x06,\n\t0x75, 0x60,\n\t0x78, 0x00,\n\t0x79, 0xb5,\n\t0x7c, 0x05,\n\t0x7d, 0x1a,\n\t0x87, 0x55,\n\t0x88, 0x72,\n\t0x8f, 0x08,\n\t0x90, 0xe0,\n\t0x94, 0x40,\n\t0xa0, 0x3f,\n\t0xa1, 0xc0,\n\t0xa4, 0xcc,\n\t0xa5, 0x66,\n\t0xa6, 0x66,\n\t0xa7, 0x7b,\n\t0xa8, 0x7b,\n\t0xa9, 0x7b,\n\t0xaa, 0x9a,\n\t0xed, 0x04,\n\t0xad, 0x00,\n\t0xae, 0x03,\n\t0xcc, 0xab,\n\t0x01, 0x08,\n\t0xff, 0xff\n};\n\n \nstatic int si21_writeregs(struct si21xx_state *state, u8 reg1,\n\t\t\t\t\t\t\tu8 *data, int len)\n{\n\tint ret;\n\tu8 buf[60]; \n\tstruct i2c_msg msg = {\n\t\t\t\t.addr = state->config->demod_address,\n\t\t\t\t.flags = 0,\n\t\t\t\t.buf = buf,\n\t\t\t\t.len = len + 1\n\t};\n\n\tif (len > sizeof(buf) - 1)\n\t\treturn -EINVAL;\n\n\tmsg.buf[0] =  reg1;\n\tmemcpy(msg.buf + 1, data, len);\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tdprintk(\"%s: writereg error (reg1 == 0x%02x, data == 0x%02x, ret == %i)\\n\",\n\t\t\t__func__, reg1, data[0], ret);\n\n\treturn (ret != 1) ? -EREMOTEIO : 0;\n}\n\nstatic int si21_writereg(struct si21xx_state *state, u8 reg, u8 data)\n{\n\tint ret;\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = {\n\t\t\t\t.addr = state->config->demod_address,\n\t\t\t\t.flags = 0,\n\t\t\t\t.buf = buf,\n\t\t\t\t.len = 2\n\t};\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tdprintk(\"%s: writereg error (reg == 0x%02x, data == 0x%02x, ret == %i)\\n\",\n\t\t\t__func__, reg, data, ret);\n\n\treturn (ret != 1) ? -EREMOTEIO : 0;\n}\n\nstatic int si21_write(struct dvb_frontend *fe, const u8 buf[], int len)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\treturn si21_writereg(state, buf[0], buf[1]);\n}\n\nstatic u8 si21_readreg(struct si21xx_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = state->config->demod_address,\n\t\t\t.flags = 0,\n\t\t\t.buf = b0,\n\t\t\t.len = 1\n\t\t}, {\n\t\t\t.addr = state->config->demod_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = b1,\n\t\t\t.len = 1\n\t\t}\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tdprintk(\"%s: readreg error (reg == 0x%02x, ret == %i)\\n\",\n\t\t\t__func__, reg, ret);\n\n\treturn b1[0];\n}\n\nstatic int si21_readregs(struct si21xx_state *state, u8 reg1, u8 *b, u8 len)\n{\n\tint ret;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = state->config->demod_address,\n\t\t\t.flags = 0,\n\t\t\t.buf = &reg1,\n\t\t\t.len = 1\n\t\t}, {\n\t\t\t.addr = state->config->demod_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = b,\n\t\t\t.len = len\n\t\t}\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tdprintk(\"%s: readreg error (ret == %i)\\n\", __func__, ret);\n\n\treturn ret == 2 ? 0 : -1;\n}\n\nstatic int si21xx_wait_diseqc_idle(struct si21xx_state *state, int timeout)\n{\n\tunsigned long start = jiffies;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\twhile ((si21_readreg(state, LNB_CTRL_REG_1) & 0x8) == 8) {\n\t\tif (time_is_before_jiffies(start + timeout)) {\n\t\t\tdprintk(\"%s: timeout!!\\n\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(10);\n\t}\n\n\treturn 0;\n}\n\nstatic int si21xx_set_symbolrate(struct dvb_frontend *fe, u32 srate)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\tu32 sym_rate, data_rate;\n\tint i;\n\tu8 sym_rate_bytes[3];\n\n\tdprintk(\"%s : srate = %i\\n\", __func__ , srate);\n\n\tif ((srate < 1000000) || (srate > 45000000))\n\t\treturn -EINVAL;\n\n\tdata_rate = srate;\n\tsym_rate = 0;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tsym_rate /= 100;\n\t\tsym_rate = sym_rate + ((data_rate % 100) * 0x800000) /\n\t\t\t\t\t\t\t\tstate->fs;\n\t\tdata_rate /= 100;\n\t}\n\tfor (i = 0; i < 3; ++i)\n\t\tsym_rate_bytes[i] = (u8)((sym_rate >> (i * 8)) & 0xff);\n\n\tsi21_writeregs(state, SYM_RATE_REG_L, sym_rate_bytes, 0x03);\n\n\treturn 0;\n}\n\nstatic int si21xx_send_diseqc_msg(struct dvb_frontend *fe,\n\t\t\t\t\tstruct dvb_diseqc_master_cmd *m)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\tu8 lnb_status;\n\tu8 LNB_CTRL_1;\n\tint status;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tstatus = PASS;\n\tLNB_CTRL_1 = 0;\n\n\tstatus |= si21_readregs(state, LNB_CTRL_STATUS_REG, &lnb_status, 0x01);\n\tstatus |= si21_readregs(state, LNB_CTRL_REG_1, &lnb_status, 0x01);\n\n\t \n\tstatus |= si21_writeregs(state, LNB_FIFO_REGS_0, m->msg, m->msg_len);\n\n\tLNB_CTRL_1 = (lnb_status & 0x70);\n\tLNB_CTRL_1 |= m->msg_len;\n\n\tLNB_CTRL_1 |= 0x80;\t \n\n\tstatus |= si21_writeregs(state, LNB_CTRL_REG_1, &LNB_CTRL_1, 0x01);\n\n\treturn status;\n}\n\nstatic int si21xx_send_diseqc_burst(struct dvb_frontend *fe,\n\t\t\t\t    enum fe_sec_mini_cmd burst)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\tu8 val;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (si21xx_wait_diseqc_idle(state, 100) < 0)\n\t\treturn -ETIMEDOUT;\n\n\tval = (0x80 | si21_readreg(state, 0xc1));\n\tif (si21_writereg(state, LNB_CTRL_REG_1,\n\t\t\tburst == SEC_MINI_A ? (val & ~0x10) : (val | 0x10)))\n\t\treturn -EREMOTEIO;\n\n\tif (si21xx_wait_diseqc_idle(state, 100) < 0)\n\t\treturn -ETIMEDOUT;\n\n\tif (si21_writereg(state, LNB_CTRL_REG_1, val))\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n \nstatic int si21xx_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\tu8 val;\n\n\tdprintk(\"%s\\n\", __func__);\n\tval = (0x80 | si21_readreg(state, LNB_CTRL_REG_1));\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\treturn si21_writereg(state, LNB_CTRL_REG_1, val | 0x20);\n\n\tcase SEC_TONE_OFF:\n\t\treturn si21_writereg(state, LNB_CTRL_REG_1, (val & ~0x20));\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int si21xx_set_voltage(struct dvb_frontend *fe, enum fe_sec_voltage volt)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\n\tu8 val;\n\tdprintk(\"%s: %s\\n\", __func__,\n\t\tvolt == SEC_VOLTAGE_13 ? \"SEC_VOLTAGE_13\" :\n\t\tvolt == SEC_VOLTAGE_18 ? \"SEC_VOLTAGE_18\" : \"??\");\n\n\n\tval = (0x80 | si21_readreg(state, LNB_CTRL_REG_1));\n\n\tswitch (volt) {\n\tcase SEC_VOLTAGE_18:\n\t\treturn si21_writereg(state, LNB_CTRL_REG_1, val | 0x40);\n\tcase SEC_VOLTAGE_13:\n\t\treturn si21_writereg(state, LNB_CTRL_REG_1, (val & ~0x40));\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int si21xx_init(struct dvb_frontend *fe)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\tint i;\n\tint status = 0;\n\tu8 reg1;\n\tu8 val;\n\tu8 reg2[2];\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tfor (i = 0; ; i += 2) {\n\t\treg1 = serit_sp1511lhb_inittab[i];\n\t\tval = serit_sp1511lhb_inittab[i+1];\n\t\tif (reg1 == 0xff && val == 0xff)\n\t\t\tbreak;\n\t\tsi21_writeregs(state, reg1, &val, 1);\n\t}\n\n\t \n\treg1 = 0x08;\n\tsi21_writeregs(state, SYSTEM_MODE_REG, &reg1, 0x01);\n\n\t \n\t \n\treg2[0] =\n\t\tPARALLEL + (LSB_FIRST << 1)\n\t\t+ (FALLING_EDGE << 2) + (CLK_GAPPED_MODE << 3)\n\t\t+ (BYTE_WIDE << 4) + (ACTIVE_HIGH << 5)\n\t\t+ (ACTIVE_HIGH << 6) + (ACTIVE_HIGH << 7);\n\n\treg2[1] = 0;\n\t \n\tstatus |= si21_writeregs(state, TS_CTRL_REG_1, reg2, 0x02);\n\tif (status != 0)\n\t\tdprintk(\" %s : TS Set Error\\n\", __func__);\n\n\treturn 0;\n\n}\n\nstatic int si21_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\tu8 regs_read[2];\n\tu8 reg_read;\n\tu8 i;\n\tu8 lock;\n\tu8 signal = si21_readreg(state, ANALOG_AGC_POWER_LEVEL_REG);\n\n\tsi21_readregs(state, LOCK_STATUS_REG_1, regs_read, 0x02);\n\treg_read = 0;\n\n\tfor (i = 0; i < 7; ++i)\n\t\treg_read |= ((regs_read[0] >> i) & 0x01) << (6 - i);\n\n\tlock = ((reg_read & 0x7f) | (regs_read[1] & 0x80));\n\n\tdprintk(\"%s : FE_READ_STATUS : VSTATUS: 0x%02x\\n\", __func__, lock);\n\t*status = 0;\n\n\tif (signal > 10)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (lock & 0x2)\n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (lock & 0x20)\n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (lock & 0x40)\n\t\t*status |= FE_HAS_SYNC;\n\n\tif ((lock & 0x7b) == 0x7b)\n\t\t*status |= FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int si21_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\n\t \n\n\tu16 signal = (3 * si21_readreg(state, 0x27) *\n\t\t\t\t\tsi21_readreg(state, 0x28));\n\n\tdprintk(\"%s : AGCPWR: 0x%02x%02x, signal=0x%04x\\n\", __func__,\n\t\tsi21_readreg(state, 0x27),\n\t\tsi21_readreg(state, 0x28), (int) signal);\n\n\tsignal  <<= 4;\n\t*strength = signal;\n\n\treturn 0;\n}\n\nstatic int si21_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (state->errmode != STATUS_BER)\n\t\treturn 0;\n\n\t*ber = (si21_readreg(state, 0x1d) << 8) |\n\t\t\t\tsi21_readreg(state, 0x1e);\n\n\treturn 0;\n}\n\nstatic int si21_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\n\ts32 xsnr = 0xffff - ((si21_readreg(state, 0x24) << 8) |\n\t\t\t\t\tsi21_readreg(state, 0x25));\n\txsnr = 3 * (xsnr - 0xa100);\n\t*snr = (xsnr > 0xffff) ? 0xffff : (xsnr < 0) ? 0 : xsnr;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic int si21_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (state->errmode != STATUS_UCBLOCKS)\n\t\t*ucblocks = 0;\n\telse\n\t\t*ucblocks = (si21_readreg(state, 0x1d) << 8) |\n\t\t\t\t\tsi21_readreg(state, 0x1e);\n\n\treturn 0;\n}\n\n \nstatic int si21xx_setacquire(struct dvb_frontend *fe, int symbrate,\n\t\t\t     enum fe_code_rate crate)\n{\n\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\tu8 coderates[] = {\n\t\t\t\t0x0, 0x01, 0x02, 0x04, 0x00,\n\t\t\t\t0x8, 0x10, 0x20, 0x00, 0x3f\n\t};\n\n\tu8 coderate_ptr;\n\tint status;\n\tu8 start_acq = 0x80;\n\tu8 reg, regs[3];\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tstatus = PASS;\n\tcoderate_ptr = coderates[crate];\n\n\tsi21xx_set_symbolrate(fe, symbrate);\n\n\t \n\tstatus |= si21_writeregs(state,\n\t\t\t\tVIT_SRCH_CTRL_REG_1,\n\t\t\t\t&coderate_ptr, 0x01);\n\n\t \n\tstatus |= si21_readregs(state, ACQ_CTRL_REG_2, &reg, 0x01);\n\treg &= ~start_acq;\n\tstatus |= si21_writeregs(state, ACQ_CTRL_REG_2, &reg, 0x01);\n\n\t \n\tregs[0] = 0xCB;\n\tregs[1] = 0x40;\n\tregs[2] = 0xCB;\n\n\tstatus |= si21_writeregs(state,\n\t\t\t\tTWO_DB_BNDWDTH_THRSHLD_REG,\n\t\t\t\t&regs[0], 0x03);\n\treg = 0x56;\n\tstatus |= si21_writeregs(state,\n\t\t\t\tLSA_CTRL_REG_1, &reg, 1);\n\treg = 0x05;\n\tstatus |= si21_writeregs(state,\n\t\t\t\tBLIND_SCAN_CTRL_REG, &reg, 1);\n\t \n\tstatus |= si21_writeregs(state,\n\t\t\t\tACQ_CTRL_REG_2, &start_acq, 0x01);\n\n\treturn status;\n}\n\nstatic int si21xx_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\t \n\n\t \n\tunsigned char coarse_tune_freq;\n\tint fine_tune_freq;\n\tunsigned char sample_rate = 0;\n\t \n\tbool inband_interferer_ind;\n\n\t \n\tint icoarse_tune_freq;  \n\tint ifine_tune_freq;  \n\tunsigned int band_high;\n\tunsigned int band_low;\n\tunsigned int x1;\n\tunsigned int x2;\n\tint i;\n\tbool inband_interferer_div2[ALLOWABLE_FS_COUNT];\n\tbool inband_interferer_div4[ALLOWABLE_FS_COUNT];\n\tint status = 0;\n\n\t \n\tint afs[ALLOWABLE_FS_COUNT] = { 200, 192, 193, 194, 195,\n\t\t\t\t\t196, 204, 205, 206, 207\n\t};\n\t \n\tint if_limit_high;\n\tint if_limit_low;\n\tint lnb_lo;\n\tint lnb_uncertanity;\n\n\tint rf_freq;\n\tint data_rate;\n\tunsigned char regs[4];\n\n\tdprintk(\"%s : FE_SET_FRONTEND\\n\", __func__);\n\n\tif (c->delivery_system != SYS_DVBS) {\n\t\t\tdprintk(\"%s: unsupported delivery system selected (%d)\\n\",\n\t\t\t\t__func__, c->delivery_system);\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfor (i = 0; i < ALLOWABLE_FS_COUNT; ++i)\n\t\tinband_interferer_div2[i] = inband_interferer_div4[i] = false;\n\n\tif_limit_high = -700000;\n\tif_limit_low = -100000;\n\t \n\tlnb_lo = 0;\n\tlnb_uncertanity = 0;\n\n\trf_freq = 10 * c->frequency ;\n\tdata_rate = c->symbol_rate / 100;\n\n\tband_low = (rf_freq - lnb_lo) - ((lnb_uncertanity * 200)\n\t\t\t\t\t+ (data_rate * 135)) / 200;\n\n\tband_high = (rf_freq - lnb_lo) + ((lnb_uncertanity * 200)\n\t\t\t\t\t+ (data_rate * 135)) / 200;\n\n\n\ticoarse_tune_freq = 100000 *\n\t\t\t\t(((rf_freq - lnb_lo) -\n\t\t\t\t\t(if_limit_low + if_limit_high) / 2)\n\t\t\t\t\t\t\t\t/ 100000);\n\n\tifine_tune_freq = (rf_freq - lnb_lo) - icoarse_tune_freq ;\n\n\tfor (i = 0; i < ALLOWABLE_FS_COUNT; ++i) {\n\t\tx1 = ((rf_freq - lnb_lo) / (afs[i] * 2500)) *\n\t\t\t\t\t(afs[i] * 2500) + afs[i] * 2500;\n\n\t\tx2 = ((rf_freq - lnb_lo) / (afs[i] * 2500)) *\n\t\t\t\t\t\t\t(afs[i] * 2500);\n\n\t\tif (((band_low < x1) && (x1 < band_high)) ||\n\t\t\t\t\t((band_low < x2) && (x2 < band_high)))\n\t\t\t\t\tinband_interferer_div4[i] = true;\n\n\t}\n\n\tfor (i = 0; i < ALLOWABLE_FS_COUNT; ++i) {\n\t\tx1 = ((rf_freq - lnb_lo) / (afs[i] * 5000)) *\n\t\t\t\t\t(afs[i] * 5000) + afs[i] * 5000;\n\n\t\tx2 = ((rf_freq - lnb_lo) / (afs[i] * 5000)) *\n\t\t\t\t\t(afs[i] * 5000);\n\n\t\tif (((band_low < x1) && (x1 < band_high)) ||\n\t\t\t\t\t((band_low < x2) && (x2 < band_high)))\n\t\t\t\t\tinband_interferer_div2[i] = true;\n\t}\n\n\tinband_interferer_ind = true;\n\tfor (i = 0; i < ALLOWABLE_FS_COUNT; ++i) {\n\t\tif (inband_interferer_div2[i] || inband_interferer_div4[i]) {\n\t\t\tinband_interferer_ind = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (inband_interferer_ind) {\n\t\tfor (i = 0; i < ALLOWABLE_FS_COUNT; ++i) {\n\t\t\tif (!inband_interferer_div2[i]) {\n\t\t\t\tsample_rate = (u8) afs[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ALLOWABLE_FS_COUNT; ++i) {\n\t\t\tif ((inband_interferer_div2[i] ||\n\t\t\t     !inband_interferer_div4[i])) {\n\t\t\t\tsample_rate = (u8) afs[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (sample_rate > 207 || sample_rate < 192)\n\t\tsample_rate = 200;\n\n\tfine_tune_freq = ((0x4000 * (ifine_tune_freq / 10)) /\n\t\t\t\t\t((sample_rate) * 1000));\n\n\tcoarse_tune_freq = (u8)(icoarse_tune_freq / 100000);\n\n\tregs[0] = sample_rate;\n\tregs[1] = coarse_tune_freq;\n\tregs[2] = fine_tune_freq & 0xFF;\n\tregs[3] = fine_tune_freq >> 8 & 0xFF;\n\n\tstatus |= si21_writeregs(state, PLL_DIVISOR_REG, &regs[0], 0x04);\n\n\tstate->fs = sample_rate; \n\tsi21xx_setacquire(fe, c->symbol_rate, c->fec_inner);\n\n\tif (status)\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic int si21xx_sleep(struct dvb_frontend *fe)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\tu8 regdata;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tsi21_readregs(state, SYSTEM_MODE_REG, &regdata, 0x01);\n\tregdata |= 1 << 6;\n\tsi21_writeregs(state, SYSTEM_MODE_REG, &regdata, 0x01);\n\tstate->initialised = 0;\n\n\treturn 0;\n}\n\nstatic void si21xx_release(struct dvb_frontend *fe)\n{\n\tstruct si21xx_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops si21xx_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name\t\t\t= \"SL SI21XX DVB-S\",\n\t\t.frequency_min_hz\t=  950 * MHz,\n\t\t.frequency_max_hz\t= 2150 * MHz,\n\t\t.frequency_stepsize_hz\t=  125 * kHz,\n\t\t.symbol_rate_min\t= 1000000,\n\t\t.symbol_rate_max\t= 45000000,\n\t\t.symbol_rate_tolerance\t= 500,\t \n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |\n\t\tFE_CAN_QPSK |\n\t\tFE_CAN_FEC_AUTO\n\t},\n\n\t.release = si21xx_release,\n\t.init = si21xx_init,\n\t.sleep = si21xx_sleep,\n\t.write = si21_write,\n\t.read_status = si21_read_status,\n\t.read_ber = si21_read_ber,\n\t.read_signal_strength = si21_read_signal_strength,\n\t.read_snr = si21_read_snr,\n\t.read_ucblocks = si21_read_ucblocks,\n\t.diseqc_send_master_cmd = si21xx_send_diseqc_msg,\n\t.diseqc_send_burst = si21xx_send_diseqc_burst,\n\t.set_tone = si21xx_set_tone,\n\t.set_voltage = si21xx_set_voltage,\n\n\t.set_frontend = si21xx_set_frontend,\n};\n\nstruct dvb_frontend *si21xx_attach(const struct si21xx_config *config,\n\t\t\t\t\t\tstruct i2c_adapter *i2c)\n{\n\tstruct si21xx_state *state = NULL;\n\tint id;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tstate = kzalloc(sizeof(struct si21xx_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->initialised = 0;\n\tstate->errmode = STATUS_BER;\n\n\t \n\tid = si21_readreg(state, SYSTEM_MODE_REG);\n\tsi21_writereg(state, SYSTEM_MODE_REG, id | 0x40);  \n\tmsleep(200);\n\tid = si21_readreg(state, 0x00);\n\n\t \n\tif (id != 0x04 && id != 0x14)\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &si21xx_ops,\n\t\t\t\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(si21xx_attach);\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"SL SI21XX DVB Demodulator driver\");\nMODULE_AUTHOR(\"Igor M. Liplianin\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}