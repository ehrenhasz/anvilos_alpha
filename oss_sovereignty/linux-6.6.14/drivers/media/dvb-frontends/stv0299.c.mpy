{
  "module_name": "stv0299.c",
  "hash_id": "92d107f6c8a2f3bdd8d285e769e862f3984e86356fd2e72708fb4b0f95522ebb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stv0299.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"stv0299.h\"\n\nstruct stv0299_state {\n\tstruct i2c_adapter* i2c;\n\tconst struct stv0299_config* config;\n\tstruct dvb_frontend frontend;\n\n\tu8 initialised:1;\n\tu32 tuner_frequency;\n\tu32 symbol_rate;\n\tenum fe_code_rate fec_inner;\n\tint errmode;\n\tu32 ucblocks;\n\tu8 mcr_reg;\n};\n\n#define STATUS_BER 0\n#define STATUS_UCBLOCKS 1\n\nstatic int debug;\nstatic int debug_legacy_dish_switch;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) printk(KERN_DEBUG \"stv0299: \" args); \\\n\t} while (0)\n\n\nstatic int stv0299_writeregI (struct stv0299_state* state, u8 reg, u8 data)\n{\n\tint ret;\n\tu8 buf [] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\n\n\tret = i2c_transfer (state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tdprintk(\"%s: writereg error (reg == 0x%02x, val == 0x%02x, ret == %i)\\n\",\n\t\t\t__func__, reg, data, ret);\n\n\treturn (ret != 1) ? -EREMOTEIO : 0;\n}\n\nstatic int stv0299_write(struct dvb_frontend* fe, const u8 buf[], int len)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\treturn stv0299_writeregI(state, buf[0], buf[1]);\n}\n\nstatic u8 stv0299_readreg (struct stv0299_state* state, u8 reg)\n{\n\tint ret;\n\tu8 b0 [] = { reg };\n\tu8 b1 [] = { 0 };\n\tstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },\n\t\t\t   { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\n\n\tret = i2c_transfer (state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tdprintk(\"%s: readreg error (reg == 0x%02x, ret == %i)\\n\",\n\t\t\t\t__func__, reg, ret);\n\n\treturn b1[0];\n}\n\nstatic int stv0299_readregs (struct stv0299_state* state, u8 reg1, u8 *b, u8 len)\n{\n\tint ret;\n\tstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = &reg1, .len = 1 },\n\t\t\t   { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b, .len = len } };\n\n\tret = i2c_transfer (state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tdprintk(\"%s: readreg error (ret == %i)\\n\", __func__, ret);\n\n\treturn ret == 2 ? 0 : ret;\n}\n\nstatic int stv0299_set_FEC(struct stv0299_state *state, enum fe_code_rate fec)\n{\n\tdprintk (\"%s\\n\", __func__);\n\n\tswitch (fec) {\n\tcase FEC_AUTO:\n\t{\n\t\treturn stv0299_writeregI (state, 0x31, 0x1f);\n\t}\n\tcase FEC_1_2:\n\t{\n\t\treturn stv0299_writeregI (state, 0x31, 0x01);\n\t}\n\tcase FEC_2_3:\n\t{\n\t\treturn stv0299_writeregI (state, 0x31, 0x02);\n\t}\n\tcase FEC_3_4:\n\t{\n\t\treturn stv0299_writeregI (state, 0x31, 0x04);\n\t}\n\tcase FEC_5_6:\n\t{\n\t\treturn stv0299_writeregI (state, 0x31, 0x08);\n\t}\n\tcase FEC_7_8:\n\t{\n\t\treturn stv0299_writeregI (state, 0x31, 0x10);\n\t}\n\tdefault:\n\t{\n\t\treturn -EINVAL;\n\t}\n    }\n}\n\nstatic enum fe_code_rate stv0299_get_fec(struct stv0299_state *state)\n{\n\tstatic const enum fe_code_rate fec_tab[] = {\n\t\tFEC_2_3, FEC_3_4, FEC_5_6, FEC_7_8, FEC_1_2\n\t};\n\tu8 index;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\tindex = stv0299_readreg (state, 0x1b);\n\tindex &= 0x7;\n\n\tif (index > 4)\n\t\treturn FEC_AUTO;\n\n\treturn fec_tab [index];\n}\n\nstatic int stv0299_wait_diseqc_fifo (struct stv0299_state* state, int timeout)\n{\n\tunsigned long start = jiffies;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\twhile (stv0299_readreg(state, 0x0a) & 1) {\n\t\tif (time_is_before_jiffies(start + timeout)) {\n\t\t\tdprintk (\"%s: timeout!!\\n\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(10);\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0299_wait_diseqc_idle (struct stv0299_state* state, int timeout)\n{\n\tunsigned long start = jiffies;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\twhile ((stv0299_readreg(state, 0x0a) & 3) != 2 ) {\n\t\tif (time_is_before_jiffies(start + timeout)) {\n\t\t\tdprintk (\"%s: timeout!!\\n\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(10);\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0299_set_symbolrate (struct dvb_frontend* fe, u32 srate)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\tu64 big = srate;\n\tu32 ratio;\n\n\t\n\tif ((srate < 1000000) || (srate > 45000000)) return -EINVAL;\n\n\t\n\tbig = big << 20;\n\tbig += (state->config->mclk-1); \n\tdo_div(big, state->config->mclk);\n\tratio = big << 4;\n\n\treturn state->config->set_symbol_rate(fe, srate, ratio);\n}\n\nstatic int stv0299_get_symbolrate (struct stv0299_state* state)\n{\n\tu32 Mclk = state->config->mclk / 4096L;\n\tu32 srate;\n\ts32 offset;\n\tu8 sfr[3];\n\ts8 rtf;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\tstv0299_readregs (state, 0x1f, sfr, 3);\n\tstv0299_readregs (state, 0x1a, (u8 *)&rtf, 1);\n\n\tsrate = (sfr[0] << 8) | sfr[1];\n\tsrate *= Mclk;\n\tsrate /= 16;\n\tsrate += (sfr[2] >> 4) * Mclk / 256;\n\toffset = (s32) rtf * (srate / 4096L);\n\toffset /= 128;\n\n\tdprintk (\"%s : srate = %i\\n\", __func__, srate);\n\tdprintk (\"%s : ofset = %i\\n\", __func__, offset);\n\n\tsrate += offset;\n\n\tsrate += 1000;\n\tsrate /= 2000;\n\tsrate *= 2000;\n\n\treturn srate;\n}\n\nstatic int stv0299_send_diseqc_msg (struct dvb_frontend* fe,\n\t\t\t\t    struct dvb_diseqc_master_cmd *m)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\tu8 val;\n\tint i;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\tif (stv0299_wait_diseqc_idle (state, 100) < 0)\n\t\treturn -ETIMEDOUT;\n\n\tval = stv0299_readreg (state, 0x08);\n\n\tif (stv0299_writeregI (state, 0x08, (val & ~0x7) | 0x6))   \n\t\treturn -EREMOTEIO;\n\n\tfor (i=0; i<m->msg_len; i++) {\n\t\tif (stv0299_wait_diseqc_fifo (state, 100) < 0)\n\t\t\treturn -ETIMEDOUT;\n\n\t\tif (stv0299_writeregI (state, 0x09, m->msg[i]))\n\t\t\treturn -EREMOTEIO;\n\t}\n\n\tif (stv0299_wait_diseqc_idle (state, 100) < 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int stv0299_send_diseqc_burst(struct dvb_frontend *fe,\n\t\t\t\t     enum fe_sec_mini_cmd burst)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\tu8 val;\n\n\tdprintk (\"%s\\n\", __func__);\n\n\tif (stv0299_wait_diseqc_idle (state, 100) < 0)\n\t\treturn -ETIMEDOUT;\n\n\tval = stv0299_readreg (state, 0x08);\n\n\tif (stv0299_writeregI (state, 0x08, (val & ~0x7) | 0x2))\t \n\t\treturn -EREMOTEIO;\n\n\tif (stv0299_writeregI (state, 0x09, burst == SEC_MINI_A ? 0x00 : 0xff))\n\t\treturn -EREMOTEIO;\n\n\tif (stv0299_wait_diseqc_idle (state, 100) < 0)\n\t\treturn -ETIMEDOUT;\n\n\tif (stv0299_writeregI (state, 0x08, val))\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic int stv0299_set_tone(struct dvb_frontend *fe,\n\t\t\t    enum fe_sec_tone_mode tone)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\tu8 val;\n\n\tif (stv0299_wait_diseqc_idle (state, 100) < 0)\n\t\treturn -ETIMEDOUT;\n\n\tval = stv0299_readreg (state, 0x08);\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\treturn stv0299_writeregI (state, 0x08, val | 0x3);\n\n\tcase SEC_TONE_OFF:\n\t\treturn stv0299_writeregI (state, 0x08, (val & ~0x3) | 0x02);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int stv0299_set_voltage(struct dvb_frontend *fe,\n\t\t\t       enum fe_sec_voltage voltage)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\tu8 reg0x08;\n\tu8 reg0x0c;\n\n\tdprintk(\"%s: %s\\n\", __func__,\n\t\tvoltage == SEC_VOLTAGE_13 ? \"SEC_VOLTAGE_13\" :\n\t\tvoltage == SEC_VOLTAGE_18 ? \"SEC_VOLTAGE_18\" : \"??\");\n\n\treg0x08 = stv0299_readreg (state, 0x08);\n\treg0x0c = stv0299_readreg (state, 0x0c);\n\n\t \n\treg0x0c &= 0x0f;\n\treg0x08 = (reg0x08 & 0x3f) | (state->config->lock_output << 6);\n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_13:\n\t\tif (state->config->volt13_op0_op1 == STV0299_VOLT13_OP0)\n\t\t\treg0x0c |= 0x10;  \n\t\telse\n\t\t\treg0x0c |= 0x40;  \n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\n\t\treg0x0c |= 0x50;  \n\t\tbreak;\n\tcase SEC_VOLTAGE_OFF:\n\t\t \n\t\treg0x08 = 0x00;\n\t\treg0x0c = 0x00;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (state->config->op0_off)\n\t\treg0x0c &= ~0x10;\n\n\tstv0299_writeregI(state, 0x08, reg0x08);\n\treturn stv0299_writeregI(state, 0x0c, reg0x0c);\n}\n\nstatic int stv0299_send_legacy_dish_cmd (struct dvb_frontend* fe, unsigned long cmd)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\tu8 reg0x08;\n\tu8 reg0x0c;\n\tu8 lv_mask = 0x40;\n\tu8 last = 1;\n\tint i;\n\tktime_t nexttime;\n\tktime_t tv[10];\n\n\treg0x08 = stv0299_readreg (state, 0x08);\n\treg0x0c = stv0299_readreg (state, 0x0c);\n\treg0x0c &= 0x0f;\n\tstv0299_writeregI (state, 0x08, (reg0x08 & 0x3f) | (state->config->lock_output << 6));\n\tif (state->config->volt13_op0_op1 == STV0299_VOLT13_OP0)\n\t\tlv_mask = 0x10;\n\n\tcmd = cmd << 1;\n\tif (debug_legacy_dish_switch)\n\t\tprintk (\"%s switch command: 0x%04lx\\n\",__func__, cmd);\n\n\tnexttime = ktime_get_boottime();\n\tif (debug_legacy_dish_switch)\n\t\ttv[0] = nexttime;\n\tstv0299_writeregI (state, 0x0c, reg0x0c | 0x50);  \n\n\tdvb_frontend_sleep_until(&nexttime, 32000);\n\n\tfor (i=0; i<9; i++) {\n\t\tif (debug_legacy_dish_switch)\n\t\t\ttv[i+1] = ktime_get_boottime();\n\t\tif((cmd & 0x01) != last) {\n\t\t\t \n\t\t\tstv0299_writeregI (state, 0x0c, reg0x0c | (last ? lv_mask : 0x50));\n\t\t\tlast = (last) ? 0 : 1;\n\t\t}\n\n\t\tcmd = cmd >> 1;\n\n\t\tif (i != 8)\n\t\t\tdvb_frontend_sleep_until(&nexttime, 8000);\n\t}\n\tif (debug_legacy_dish_switch) {\n\t\tprintk (\"%s(%d): switch delay (should be 32k followed by all 8k\\n\",\n\t\t\t__func__, fe->dvb->num);\n\t\tfor (i = 1; i < 10; i++)\n\t\t\tprintk(\"%d: %d\\n\", i,\n\t\t\t       (int) ktime_us_delta(tv[i], tv[i-1]));\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0299_init (struct dvb_frontend* fe)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\tint i;\n\tu8 reg;\n\tu8 val;\n\n\tdprintk(\"stv0299: init chip\\n\");\n\n\tstv0299_writeregI(state, 0x02, 0x30 | state->mcr_reg);\n\tmsleep(50);\n\n\tfor (i = 0; ; i += 2)  {\n\t\treg = state->config->inittab[i];\n\t\tval = state->config->inittab[i+1];\n\t\tif (reg == 0xff && val == 0xff)\n\t\t\tbreak;\n\t\tif (reg == 0x0c && state->config->op0_off)\n\t\t\tval &= ~0x10;\n\t\tif (reg == 0x2)\n\t\t\tstate->mcr_reg = val & 0xf;\n\t\tstv0299_writeregI(state, reg, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0299_read_status(struct dvb_frontend *fe,\n\t\t\t       enum fe_status *status)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\n\tu8 signal = 0xff - stv0299_readreg (state, 0x18);\n\tu8 sync = stv0299_readreg (state, 0x1b);\n\n\tdprintk (\"%s : FE_READ_STATUS : VSTATUS: 0x%02x\\n\", __func__, sync);\n\t*status = 0;\n\n\tif (signal > 10)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (sync & 0x80)\n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (sync & 0x10)\n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (sync & 0x08)\n\t\t*status |= FE_HAS_SYNC;\n\n\tif ((sync & 0x98) == 0x98)\n\t\t*status |= FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int stv0299_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\n\tif (state->errmode != STATUS_BER)\n\t\treturn -ENOSYS;\n\n\t*ber = stv0299_readreg(state, 0x1e) | (stv0299_readreg(state, 0x1d) << 8);\n\n\treturn 0;\n}\n\nstatic int stv0299_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\n\ts32 signal =  0xffff - ((stv0299_readreg (state, 0x18) << 8)\n\t\t\t       | stv0299_readreg (state, 0x19));\n\n\tdprintk (\"%s : FE_READ_SIGNAL_STRENGTH : AGC2I: 0x%02x%02x, signal=0x%04x\\n\", __func__,\n\t\t stv0299_readreg (state, 0x18),\n\t\t stv0299_readreg (state, 0x19), (int) signal);\n\n\tsignal = signal * 5 / 4;\n\t*strength = (signal > 0xffff) ? 0xffff : (signal < 0) ? 0 : signal;\n\n\treturn 0;\n}\n\nstatic int stv0299_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\n\ts32 xsnr = 0xffff - ((stv0299_readreg (state, 0x24) << 8)\n\t\t\t   | stv0299_readreg (state, 0x25));\n\txsnr = 3 * (xsnr - 0xa100);\n\t*snr = (xsnr > 0xffff) ? 0xffff : (xsnr < 0) ? 0 : xsnr;\n\n\treturn 0;\n}\n\nstatic int stv0299_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\n\tif (state->errmode != STATUS_UCBLOCKS)\n\t\treturn -ENOSYS;\n\n\tstate->ucblocks += stv0299_readreg(state, 0x1e);\n\tstate->ucblocks += (stv0299_readreg(state, 0x1d) << 8);\n\t*ucblocks = state->ucblocks;\n\n\treturn 0;\n}\n\nstatic int stv0299_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\tint invval = 0;\n\n\tdprintk (\"%s : FE_SET_FRONTEND\\n\", __func__);\n\tif (state->config->set_ts_params)\n\t\tstate->config->set_ts_params(fe, 0);\n\n\t\n\tif (p->inversion == INVERSION_OFF) invval = 0;\n\telse if (p->inversion == INVERSION_ON) invval = 1;\n\telse {\n\t\tprintk(\"stv0299 does not support auto-inversion\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (state->config->invert) invval = (~invval) & 1;\n\tstv0299_writeregI(state, 0x0c, (stv0299_readreg(state, 0x0c) & 0xfe) | invval);\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tstv0299_set_FEC(state, p->fec_inner);\n\tstv0299_set_symbolrate(fe, p->symbol_rate);\n\tstv0299_writeregI(state, 0x22, 0x00);\n\tstv0299_writeregI(state, 0x23, 0x00);\n\n\tstate->tuner_frequency = p->frequency;\n\tstate->fec_inner = p->fec_inner;\n\tstate->symbol_rate = p->symbol_rate;\n\n\treturn 0;\n}\n\nstatic int stv0299_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\ts32 derot_freq;\n\tint invval;\n\n\tderot_freq = (s32)(s16) ((stv0299_readreg (state, 0x22) << 8)\n\t\t\t\t| stv0299_readreg (state, 0x23));\n\n\tderot_freq *= (state->config->mclk >> 16);\n\tderot_freq += 500;\n\tderot_freq /= 1000;\n\n\tp->frequency += derot_freq;\n\n\tinvval = stv0299_readreg (state, 0x0c) & 1;\n\tif (state->config->invert) invval = (~invval) & 1;\n\tp->inversion = invval ? INVERSION_ON : INVERSION_OFF;\n\n\tp->fec_inner = stv0299_get_fec(state);\n\tp->symbol_rate = stv0299_get_symbolrate(state);\n\n\treturn 0;\n}\n\nstatic int stv0299_sleep(struct dvb_frontend* fe)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\n\tstv0299_writeregI(state, 0x02, 0xb0 | state->mcr_reg);\n\tstate->initialised = 0;\n\n\treturn 0;\n}\n\nstatic int stv0299_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\n\tif (enable) {\n\t\tstv0299_writeregI(state, 0x05, 0xb5);\n\t} else {\n\t\tstv0299_writeregI(state, 0x05, 0x35);\n\t}\n\tudelay(1);\n\treturn 0;\n}\n\nstatic int stv0299_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tfesettings->min_delay_ms = state->config->min_delay_ms;\n\tif (p->symbol_rate < 10000000) {\n\t\tfesettings->step_size = p->symbol_rate / 32000;\n\t\tfesettings->max_drift = 5000;\n\t} else {\n\t\tfesettings->step_size = p->symbol_rate / 16000;\n\t\tfesettings->max_drift = p->symbol_rate / 2000;\n\t}\n\treturn 0;\n}\n\nstatic void stv0299_release(struct dvb_frontend* fe)\n{\n\tstruct stv0299_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops stv0299_ops;\n\nstruct dvb_frontend* stv0299_attach(const struct stv0299_config* config,\n\t\t\t\t    struct i2c_adapter* i2c)\n{\n\tstruct stv0299_state* state = NULL;\n\tint id;\n\n\t \n\tstate = kzalloc(sizeof(struct stv0299_state), GFP_KERNEL);\n\tif (state == NULL) goto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->initialised = 0;\n\tstate->tuner_frequency = 0;\n\tstate->symbol_rate = 0;\n\tstate->fec_inner = 0;\n\tstate->errmode = STATUS_BER;\n\n\t \n\tstv0299_writeregI(state, 0x02, 0x30);  \n\tmsleep(200);\n\tid = stv0299_readreg(state, 0x00);\n\n\t \n\t \n\tif (id != 0xa1 && id != 0x80) goto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &stv0299_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops stv0299_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name\t\t\t= \"ST STV0299 DVB-S\",\n\t\t.frequency_min_hz\t=  950 * MHz,\n\t\t.frequency_max_hz\t= 2150 * MHz,\n\t\t.frequency_stepsize_hz\t=  125 * kHz,\n\t\t.symbol_rate_min\t= 1000000,\n\t\t.symbol_rate_max\t= 45000000,\n\t\t.symbol_rate_tolerance\t= 500,\t \n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t      FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |\n\t\t      FE_CAN_QPSK |\n\t\t      FE_CAN_FEC_AUTO\n\t},\n\n\t.release = stv0299_release,\n\n\t.init = stv0299_init,\n\t.sleep = stv0299_sleep,\n\t.write = stv0299_write,\n\t.i2c_gate_ctrl = stv0299_i2c_gate_ctrl,\n\n\t.set_frontend = stv0299_set_frontend,\n\t.get_frontend = stv0299_get_frontend,\n\t.get_tune_settings = stv0299_get_tune_settings,\n\n\t.read_status = stv0299_read_status,\n\t.read_ber = stv0299_read_ber,\n\t.read_signal_strength = stv0299_read_signal_strength,\n\t.read_snr = stv0299_read_snr,\n\t.read_ucblocks = stv0299_read_ucblocks,\n\n\t.diseqc_send_master_cmd = stv0299_send_diseqc_msg,\n\t.diseqc_send_burst = stv0299_send_diseqc_burst,\n\t.set_tone = stv0299_set_tone,\n\t.set_voltage = stv0299_set_voltage,\n\t.dishnetwork_send_legacy_command = stv0299_send_legacy_dish_cmd,\n};\n\nmodule_param(debug_legacy_dish_switch, int, 0444);\nMODULE_PARM_DESC(debug_legacy_dish_switch, \"Enable timing analysis for Dish Network legacy switches\");\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"ST STV0299 DVB Demodulator driver\");\nMODULE_AUTHOR(\"Ralph Metzler, Holger Waechtler, Peter Schildmann, Felix Domke, Andreas Oberritter, Andrew de Quincey, Kenneth Aafly\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(stv0299_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}