{
  "module_name": "lgs8gxx.c",
  "hash_id": "54666038e7d461f413059fc965a2b3a13e162404746646b34c577c587abe40a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/lgs8gxx.c",
  "human_readable_source": "\n \n\n#include <asm/div64.h>\n#include <linux/firmware.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"lgs8gxx.h\"\n#include \"lgs8gxx_priv.h\"\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_DEBUG \"lgs8gxx: \" args); \\\n\t} while (0)\n\nstatic int debug;\nstatic int fake_signal_str = 1;\n\n#define LGS8GXX_FIRMWARE \"lgs8g75.fw\"\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nmodule_param(fake_signal_str, int, 0644);\nMODULE_PARM_DESC(fake_signal_str, \"fake signal strength for LGS8913.\"\n\"Signal strength calculation is slow.(default:on).\");\n\n \n\nstatic int lgs8gxx_write_reg(struct lgs8gxx_state *priv, u8 reg, u8 data)\n{\n\tint ret;\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = { .flags = 0, .buf = buf, .len = 2 };\n\n\tmsg.addr = priv->config->demod_address;\n\tif (priv->config->prod != LGS8GXX_PROD_LGS8G75 && reg >= 0xC0)\n\t\tmsg.addr += 0x02;\n\n\tif (debug >= 2)\n\t\tdprintk(\"%s: reg=0x%02X, data=0x%02X\\n\", __func__, reg, data);\n\n\tret = i2c_transfer(priv->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tdprintk(\"%s: error reg=0x%x, data=0x%x, ret=%i\\n\",\n\t\t\t__func__, reg, data, ret);\n\n\treturn (ret != 1) ? -1 : 0;\n}\n\nstatic int lgs8gxx_read_reg(struct lgs8gxx_state *priv, u8 reg, u8 *p_data)\n{\n\tint ret;\n\tu8 dev_addr;\n\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{ .flags = 0, .buf = b0, .len = 1 },\n\t\t{ .flags = I2C_M_RD, .buf = b1, .len = 1 },\n\t};\n\n\tdev_addr = priv->config->demod_address;\n\tif (priv->config->prod != LGS8GXX_PROD_LGS8G75 && reg >= 0xC0)\n\t\tdev_addr += 0x02;\n\tmsg[1].addr =  msg[0].addr = dev_addr;\n\n\tret = i2c_transfer(priv->i2c, msg, 2);\n\tif (ret != 2) {\n\t\tdprintk(\"%s: error reg=0x%x, ret=%i\\n\", __func__, reg, ret);\n\t\treturn -1;\n\t}\n\n\t*p_data = b1[0];\n\tif (debug >= 2)\n\t\tdprintk(\"%s: reg=0x%02X, data=0x%02X\\n\", __func__, reg, b1[0]);\n\treturn 0;\n}\n\nstatic int lgs8gxx_soft_reset(struct lgs8gxx_state *priv)\n{\n\tlgs8gxx_write_reg(priv, 0x02, 0x00);\n\tmsleep(1);\n\tlgs8gxx_write_reg(priv, 0x02, 0x01);\n\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic int wait_reg_mask(struct lgs8gxx_state *priv, u8 reg, u8 mask,\n\tu8 val, u8 delay, u8 tries)\n{\n\tu8 t;\n\tint i;\n\n\tfor (i = 0; i < tries; i++) {\n\t\tlgs8gxx_read_reg(priv, reg, &t);\n\n\t\tif ((t & mask) == val)\n\t\t\treturn 0;\n\t\tmsleep(delay);\n\t}\n\n\treturn 1;\n}\n\nstatic int lgs8gxx_set_ad_mode(struct lgs8gxx_state *priv)\n{\n\tconst struct lgs8gxx_config *config = priv->config;\n\tu8 if_conf;\n\n\tif_conf = 0x10;  \n\n\tif_conf |=\n\t\t((config->ext_adc) ? 0x80 : 0x00) |\n\t\t((config->if_neg_center) ? 0x04 : 0x00) |\n\t\t((config->if_freq == 0) ? 0x08 : 0x00) |  \n\t\t((config->adc_signed) ? 0x02 : 0x00) |\n\t\t((config->if_neg_edge) ? 0x01 : 0x00);\n\n\tif (config->ext_adc &&\n\t\t(config->prod == LGS8GXX_PROD_LGS8G52)) {\n\t\tlgs8gxx_write_reg(priv, 0xBA, 0x40);\n\t}\n\n\tlgs8gxx_write_reg(priv, 0x07, if_conf);\n\n\treturn 0;\n}\n\nstatic int lgs8gxx_set_if_freq(struct lgs8gxx_state *priv, u32 freq  )\n{\n\tu64 val;\n\tu32 v32;\n\tu32 if_clk;\n\n\tif_clk = priv->config->if_clk_freq;\n\n\tval = freq;\n\tif (freq != 0) {\n\t\tval <<= 32;\n\t\tif (if_clk != 0)\n\t\t\tdo_div(val, if_clk);\n\t\tv32 = val & 0xFFFFFFFF;\n\t\tdprintk(\"Set IF Freq to %dkHz\\n\", freq);\n\t} else {\n\t\tv32 = 0;\n\t\tdprintk(\"Set IF Freq to baseband\\n\");\n\t}\n\tdprintk(\"AFC_INIT_FREQ = 0x%08X\\n\", v32);\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\n\t\tlgs8gxx_write_reg(priv, 0x08, 0xFF & (v32));\n\t\tlgs8gxx_write_reg(priv, 0x09, 0xFF & (v32 >> 8));\n\t\tlgs8gxx_write_reg(priv, 0x0A, 0xFF & (v32 >> 16));\n\t\tlgs8gxx_write_reg(priv, 0x0B, 0xFF & (v32 >> 24));\n\t} else {\n\t\tlgs8gxx_write_reg(priv, 0x09, 0xFF & (v32));\n\t\tlgs8gxx_write_reg(priv, 0x0A, 0xFF & (v32 >> 8));\n\t\tlgs8gxx_write_reg(priv, 0x0B, 0xFF & (v32 >> 16));\n\t\tlgs8gxx_write_reg(priv, 0x0C, 0xFF & (v32 >> 24));\n\t}\n\n\treturn 0;\n}\n\nstatic int lgs8gxx_get_afc_phase(struct lgs8gxx_state *priv)\n{\n\tu64 val;\n\tu32 v32 = 0;\n\tu8 reg_addr, t;\n\tint i;\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75)\n\t\treg_addr = 0x23;\n\telse\n\t\treg_addr = 0x48;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tlgs8gxx_read_reg(priv, reg_addr, &t);\n\t\tv32 <<= 8;\n\t\tv32 |= t;\n\t\treg_addr--;\n\t}\n\n\tval = v32;\n\tval *= priv->config->if_clk_freq;\n\tval >>= 32;\n\tdprintk(\"AFC = %u kHz\\n\", (u32)val);\n\treturn 0;\n}\n\nstatic int lgs8gxx_set_mode_auto(struct lgs8gxx_state *priv)\n{\n\tu8 t;\n\tu8 prod = priv->config->prod;\n\n\tif (prod == LGS8GXX_PROD_LGS8913)\n\t\tlgs8gxx_write_reg(priv, 0xC6, 0x01);\n\n\tif (prod == LGS8GXX_PROD_LGS8G75) {\n\t\tlgs8gxx_read_reg(priv, 0x0C, &t);\n\t\tt &= (~0x04);\n\t\tlgs8gxx_write_reg(priv, 0x0C, t | 0x80);\n\t\tlgs8gxx_write_reg(priv, 0x39, 0x00);\n\t\tlgs8gxx_write_reg(priv, 0x3D, 0x04);\n\t} else if (prod == LGS8GXX_PROD_LGS8913 ||\n\t\tprod == LGS8GXX_PROD_LGS8GL5 ||\n\t\tprod == LGS8GXX_PROD_LGS8G42 ||\n\t\tprod == LGS8GXX_PROD_LGS8G52 ||\n\t\tprod == LGS8GXX_PROD_LGS8G54) {\n\t\tlgs8gxx_read_reg(priv, 0x7E, &t);\n\t\tlgs8gxx_write_reg(priv, 0x7E, t | 0x01);\n\n\t\t \n\t\tlgs8gxx_read_reg(priv, 0xC5, &t);\n\t\tlgs8gxx_write_reg(priv, 0xC5, t & 0xE0);\n\t}\n\n\tif (prod == LGS8GXX_PROD_LGS8913) {\n\t\t \n\t\tlgs8gxx_write_reg(priv, 0xC1, 0x03);\n\n\t\tlgs8gxx_read_reg(priv, 0x7C, &t);\n\t\tt = (t & 0x8C) | 0x03;\n\t\tlgs8gxx_write_reg(priv, 0x7C, t);\n\n\t\t \n\t\tlgs8gxx_read_reg(priv, 0xC3, &t);\n\t\tt = (t & 0xEF) |  0x10;\n\t\tlgs8gxx_write_reg(priv, 0xC3, t);\n\t}\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G52)\n\t\tlgs8gxx_write_reg(priv, 0xD9, 0x40);\n\n\treturn 0;\n}\n\nstatic int lgs8gxx_set_mode_manual(struct lgs8gxx_state *priv)\n{\n\tu8 t;\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\n\t\tu8 t2;\n\t\tlgs8gxx_read_reg(priv, 0x0C, &t);\n\t\tt &= (~0x80);\n\t\tlgs8gxx_write_reg(priv, 0x0C, t);\n\n\t\tlgs8gxx_read_reg(priv, 0x0C, &t);\n\t\tlgs8gxx_read_reg(priv, 0x19, &t2);\n\n\t\tif (((t&0x03) == 0x01) && (t2&0x01)) {\n\t\t\tlgs8gxx_write_reg(priv, 0x6E, 0x05);\n\t\t\tlgs8gxx_write_reg(priv, 0x39, 0x02);\n\t\t\tlgs8gxx_write_reg(priv, 0x39, 0x03);\n\t\t\tlgs8gxx_write_reg(priv, 0x3D, 0x05);\n\t\t\tlgs8gxx_write_reg(priv, 0x3E, 0x28);\n\t\t\tlgs8gxx_write_reg(priv, 0x53, 0x80);\n\t\t} else {\n\t\t\tlgs8gxx_write_reg(priv, 0x6E, 0x3F);\n\t\t\tlgs8gxx_write_reg(priv, 0x39, 0x00);\n\t\t\tlgs8gxx_write_reg(priv, 0x3D, 0x04);\n\t\t}\n\n\t\tlgs8gxx_soft_reset(priv);\n\t\treturn 0;\n\t}\n\n\t \n\tlgs8gxx_write_reg(priv, 0x7E, 0);\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8913)\n\t\tlgs8gxx_write_reg(priv, 0xC1, 0);\n\n\tlgs8gxx_read_reg(priv, 0xC5, &t);\n\tt = (t & 0xE0) | 0x06;\n\tlgs8gxx_write_reg(priv, 0xC5, t);\n\n\tlgs8gxx_soft_reset(priv);\n\n\treturn 0;\n}\n\nstatic int lgs8gxx_is_locked(struct lgs8gxx_state *priv, u8 *locked)\n{\n\tint ret = 0;\n\tu8 t;\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75)\n\t\tret = lgs8gxx_read_reg(priv, 0x13, &t);\n\telse\n\t\tret = lgs8gxx_read_reg(priv, 0x4B, &t);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75)\n\t\t*locked = ((t & 0x80) == 0x80) ? 1 : 0;\n\telse\n\t\t*locked = ((t & 0xC0) == 0xC0) ? 1 : 0;\n\treturn 0;\n}\n\n \nstatic int lgs8gxx_wait_ca_lock(struct lgs8gxx_state *priv, u8 *locked)\n{\n\tint ret = 0;\n\tu8 reg, mask, val;\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\n\t\treg = 0x13;\n\t\tmask = 0x80;\n\t\tval = 0x80;\n\t} else {\n\t\treg = 0x4B;\n\t\tmask = 0xC0;\n\t\tval = 0xC0;\n\t}\n\n\tret = wait_reg_mask(priv, reg, mask, val, 50, 40);\n\t*locked = (ret == 0) ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int lgs8gxx_is_autodetect_finished(struct lgs8gxx_state *priv,\n\t\t\t\t\t  u8 *finished)\n{\n\tint ret = 0;\n\tu8 reg, mask, val;\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\n\t\treg = 0x1f;\n\t\tmask = 0xC0;\n\t\tval = 0x80;\n\t} else {\n\t\treg = 0xA4;\n\t\tmask = 0x03;\n\t\tval = 0x01;\n\t}\n\n\tret = wait_reg_mask(priv, reg, mask, val, 10, 20);\n\t*finished = (ret == 0) ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int lgs8gxx_autolock_gi(struct lgs8gxx_state *priv, u8 gi, u8 cpn,\n\tu8 *locked)\n{\n\tint err = 0;\n\tu8 ad_fini = 0;\n\tu8 t1, t2;\n\n\tif (gi == GI_945)\n\t\tdprintk(\"try GI 945\\n\");\n\telse if (gi == GI_595)\n\t\tdprintk(\"try GI 595\\n\");\n\telse if (gi == GI_420)\n\t\tdprintk(\"try GI 420\\n\");\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\n\t\tlgs8gxx_read_reg(priv, 0x0C, &t1);\n\t\tlgs8gxx_read_reg(priv, 0x18, &t2);\n\t\tt1 &= ~(GI_MASK);\n\t\tt1 |= gi;\n\t\tt2 &= 0xFE;\n\t\tt2 |= cpn ? 0x01 : 0x00;\n\t\tlgs8gxx_write_reg(priv, 0x0C, t1);\n\t\tlgs8gxx_write_reg(priv, 0x18, t2);\n\t} else {\n\t\tlgs8gxx_write_reg(priv, 0x04, gi);\n\t}\n\tlgs8gxx_soft_reset(priv);\n\terr = lgs8gxx_wait_ca_lock(priv, locked);\n\tif (err || !(*locked))\n\t\treturn err;\n\terr = lgs8gxx_is_autodetect_finished(priv, &ad_fini);\n\tif (err != 0)\n\t\treturn err;\n\tif (ad_fini) {\n\t\tdprintk(\"auto detect finished\\n\");\n\t} else\n\t\t*locked = 0;\n\n\treturn 0;\n}\n\nstatic int lgs8gxx_auto_detect(struct lgs8gxx_state *priv,\n\t\t\t       u8 *detected_param, u8 *gi)\n{\n\tint i, j;\n\tint err = 0;\n\tu8 locked = 0, tmp_gi;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tlgs8gxx_set_mode_auto(priv);\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\n\t\tlgs8gxx_write_reg(priv, 0x67, 0xAA);\n\t\tlgs8gxx_write_reg(priv, 0x6E, 0x3F);\n\t} else {\n\t\t \n\t\tlgs8gxx_write_reg(priv, 0x03, 00);\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\ttmp_gi = GI_945;\n\t\t\terr = lgs8gxx_autolock_gi(priv, GI_945, j, &locked);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tif (locked)\n\t\t\t\tgoto locked;\n\t\t}\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\ttmp_gi = GI_420;\n\t\t\terr = lgs8gxx_autolock_gi(priv, GI_420, j, &locked);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tif (locked)\n\t\t\t\tgoto locked;\n\t\t}\n\t\ttmp_gi = GI_595;\n\t\terr = lgs8gxx_autolock_gi(priv, GI_595, 1, &locked);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (locked)\n\t\t\tgoto locked;\n\t}\n\nlocked:\n\tif ((err == 0) && (locked == 1)) {\n\t\tu8 t;\n\n\t\tif (priv->config->prod != LGS8GXX_PROD_LGS8G75) {\n\t\t\tlgs8gxx_read_reg(priv, 0xA2, &t);\n\t\t\t*detected_param = t;\n\t\t} else {\n\t\t\tlgs8gxx_read_reg(priv, 0x1F, &t);\n\t\t\t*detected_param = t & 0x3F;\n\t\t}\n\n\t\tif (tmp_gi == GI_945)\n\t\t\tdprintk(\"GI 945 locked\\n\");\n\t\telse if (tmp_gi == GI_595)\n\t\t\tdprintk(\"GI 595 locked\\n\");\n\t\telse if (tmp_gi == GI_420)\n\t\t\tdprintk(\"GI 420 locked\\n\");\n\t\t*gi = tmp_gi;\n\t}\n\tif (!locked)\n\t\terr = -1;\n\nout:\n\treturn err;\n}\n\nstatic void lgs8gxx_auto_lock(struct lgs8gxx_state *priv)\n{\n\ts8 err;\n\tu8 gi = 0x2;\n\tu8 detected_param = 0;\n\n\terr = lgs8gxx_auto_detect(priv, &detected_param, &gi);\n\n\tif (err != 0) {\n\t\tdprintk(\"lgs8gxx_auto_detect failed\\n\");\n\t} else\n\t\tdprintk(\"detected param = 0x%02X\\n\", detected_param);\n\n\t \n\tif (priv->config->prod == LGS8GXX_PROD_LGS8913) {\n\t\tu8 inter_leave_len = detected_param & TIM_MASK ;\n\t\t \n\t\tinter_leave_len = (inter_leave_len == TIM_MIDDLE) ? 0x60 : 0x40;\n\t\tdetected_param &= CF_MASK | SC_MASK  | LGS_FEC_MASK;\n\t\tdetected_param |= inter_leave_len;\n\t}\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\n\t\tu8 t;\n\t\tlgs8gxx_read_reg(priv, 0x19, &t);\n\t\tt &= 0x81;\n\t\tt |= detected_param << 1;\n\t\tlgs8gxx_write_reg(priv, 0x19, t);\n\t} else {\n\t\tlgs8gxx_write_reg(priv, 0x7D, detected_param);\n\t\tif (priv->config->prod == LGS8GXX_PROD_LGS8913)\n\t\t\tlgs8gxx_write_reg(priv, 0xC0, detected_param);\n\t}\n\t \n\n\t \n\tlgs8gxx_set_mode_manual(priv);\n\n\tswitch (gi) {\n\tcase GI_945:\n\t\tpriv->curr_gi = 945; break;\n\tcase GI_595:\n\t\tpriv->curr_gi = 595; break;\n\tcase GI_420:\n\t\tpriv->curr_gi = 420; break;\n\tdefault:\n\t\tpriv->curr_gi = 945; break;\n\t}\n}\n\nstatic int lgs8gxx_set_mpeg_mode(struct lgs8gxx_state *priv,\n\tu8 serial, u8 clk_pol, u8 clk_gated)\n{\n\tint ret = 0;\n\tu8 t, reg_addr;\n\n\treg_addr = (priv->config->prod == LGS8GXX_PROD_LGS8G75) ? 0x30 : 0xC2;\n\tret = lgs8gxx_read_reg(priv, reg_addr, &t);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tt &= 0xF8;\n\tt |= serial ? TS_SERIAL : TS_PARALLEL;\n\tt |= clk_pol ? TS_CLK_INVERTED : TS_CLK_NORMAL;\n\tt |= clk_gated ? TS_CLK_GATED : TS_CLK_FREERUN;\n\n\tret = lgs8gxx_write_reg(priv, reg_addr, t);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int lgs8g75_set_adc_vpp(struct lgs8gxx_state *priv,\n\tu8 sel)\n{\n\tu8 r26 = 0x73, r27 = 0x90;\n\n\tif (priv->config->prod != LGS8GXX_PROD_LGS8G75)\n\t\treturn 0;\n\n\tr26 |= (sel & 0x01) << 7;\n\tr27 |= (sel & 0x02) >> 1;\n\tlgs8gxx_write_reg(priv, 0x26, r26);\n\tlgs8gxx_write_reg(priv, 0x27, r27);\n\n\treturn 0;\n}\n\n \n\nstatic int lgs8913_init(struct lgs8gxx_state *priv)\n{\n\tu8 t;\n\n\t \n\tlgs8gxx_write_reg(priv, 0xc1, 0x3);\n\n\tlgs8gxx_read_reg(priv, 0x7c, &t);\n\tlgs8gxx_write_reg(priv, 0x7c, (t&0x8c) | 0x3);\n\n\t \n\tlgs8gxx_read_reg(priv, 0xc3, &t);\n\tlgs8gxx_write_reg(priv, 0xc3, t&0x10);\n\n\n\treturn 0;\n}\n\nstatic int lgs8g75_init_data(struct lgs8gxx_state *priv)\n{\n\tconst struct firmware *fw;\n\tint rc;\n\tint i;\n\n\trc = request_firmware(&fw, LGS8GXX_FIRMWARE, &priv->i2c->dev);\n\tif (rc)\n\t\treturn rc;\n\n\tlgs8gxx_write_reg(priv, 0xC6, 0x40);\n\n\tlgs8gxx_write_reg(priv, 0x3D, 0x04);\n\tlgs8gxx_write_reg(priv, 0x39, 0x00);\n\n\tlgs8gxx_write_reg(priv, 0x3A, 0x00);\n\tlgs8gxx_write_reg(priv, 0x38, 0x00);\n\tlgs8gxx_write_reg(priv, 0x3B, 0x00);\n\tlgs8gxx_write_reg(priv, 0x38, 0x00);\n\n\tfor (i = 0; i < fw->size; i++) {\n\t\tlgs8gxx_write_reg(priv, 0x38, 0x00);\n\t\tlgs8gxx_write_reg(priv, 0x3A, (u8)(i&0xff));\n\t\tlgs8gxx_write_reg(priv, 0x3B, (u8)(i>>8));\n\t\tlgs8gxx_write_reg(priv, 0x3C, fw->data[i]);\n\t}\n\n\tlgs8gxx_write_reg(priv, 0x38, 0x00);\n\n\trelease_firmware(fw);\n\treturn 0;\n}\n\nstatic int lgs8gxx_init(struct dvb_frontend *fe)\n{\n\tstruct lgs8gxx_state *priv =\n\t\t(struct lgs8gxx_state *)fe->demodulator_priv;\n\tconst struct lgs8gxx_config *config = priv->config;\n\tu8 data = 0;\n\ts8 err;\n\tdprintk(\"%s\\n\", __func__);\n\n\tlgs8gxx_read_reg(priv, 0, &data);\n\tdprintk(\"reg 0 = 0x%02X\\n\", data);\n\n\tif (config->prod == LGS8GXX_PROD_LGS8G75)\n\t\tlgs8g75_set_adc_vpp(priv, config->adc_vpp);\n\n\t \n\terr = lgs8gxx_set_mpeg_mode(priv, config->serial_ts,\n\t\t\t\t    config->ts_clk_pol,\n\t\t\t\t    config->ts_clk_gated);\n\tif (err != 0)\n\t\treturn -EIO;\n\n\tif (config->prod == LGS8GXX_PROD_LGS8913)\n\t\tlgs8913_init(priv);\n\tlgs8gxx_set_if_freq(priv, priv->config->if_freq);\n\tlgs8gxx_set_ad_mode(priv);\n\n\treturn 0;\n}\n\nstatic void lgs8gxx_release(struct dvb_frontend *fe)\n{\n\tstruct lgs8gxx_state *state = fe->demodulator_priv;\n\tdprintk(\"%s\\n\", __func__);\n\n\tkfree(state);\n}\n\n\nstatic int lgs8gxx_write(struct dvb_frontend *fe, const u8 buf[], int len)\n{\n\tstruct lgs8gxx_state *priv = fe->demodulator_priv;\n\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\treturn lgs8gxx_write_reg(priv, buf[0], buf[1]);\n}\n\nstatic int lgs8gxx_set_fe(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *fe_params = &fe->dtv_property_cache;\n\tstruct lgs8gxx_state *priv = fe->demodulator_priv;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t \n\tlgs8gxx_auto_lock(priv);\n\n\tmsleep(10);\n\n\t \n\n\t \n\tfe_params->bandwidth_hz = 8000000;\n\n\tfe_params->code_rate_HP = FEC_AUTO;\n\tfe_params->code_rate_LP = FEC_AUTO;\n\n\tfe_params->modulation = QAM_AUTO;\n\n\t \n\tfe_params->transmission_mode = TRANSMISSION_MODE_AUTO;\n\n\t \n\tfe_params->guard_interval = GUARD_INTERVAL_AUTO;\n\n\t \n\tfe_params->hierarchy = HIERARCHY_NONE;\n\n\treturn 0;\n}\n\nstatic\nint lgs8gxx_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t      struct dvb_frontend_tune_settings *fesettings)\n{\n\t \n\tfesettings->min_delay_ms = 800;\n\tfesettings->step_size = 0;\n\tfesettings->max_drift = 0;\n\treturn 0;\n}\n\nstatic int lgs8gxx_read_status(struct dvb_frontend *fe,\n\t\t\t       enum fe_status *fe_status)\n{\n\tstruct lgs8gxx_state *priv = fe->demodulator_priv;\n\ts8 ret;\n\tu8 t, locked = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\t*fe_status = 0;\n\n\tlgs8gxx_get_afc_phase(priv);\n\tlgs8gxx_is_locked(priv, &locked);\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\n\t\tif (locked)\n\t\t\t*fe_status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\tFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\t\treturn 0;\n\t}\n\n\tret = lgs8gxx_read_reg(priv, 0x4B, &t);\n\tif (ret != 0)\n\t\treturn -EIO;\n\n\tdprintk(\"Reg 0x4B: 0x%02X\\n\", t);\n\n\t*fe_status = 0;\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8913) {\n\t\tif ((t & 0x40) == 0x40)\n\t\t\t*fe_status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\t\tif ((t & 0x80) == 0x80)\n\t\t\t*fe_status |= FE_HAS_VITERBI | FE_HAS_SYNC |\n\t\t\t\tFE_HAS_LOCK;\n\t} else {\n\t\tif ((t & 0x80) == 0x80)\n\t\t\t*fe_status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\tFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\t}\n\n\t \n\tdprintk(\"%s: fe_status=0x%x\\n\", __func__, *fe_status);\n\treturn 0;\n}\n\nstatic int lgs8gxx_read_signal_agc(struct lgs8gxx_state *priv, u16 *signal)\n{\n\tu16 v;\n\tu8 agc_lvl[2], cat;\n\n\tdprintk(\"%s()\\n\", __func__);\n\tlgs8gxx_read_reg(priv, 0x3F, &agc_lvl[0]);\n\tlgs8gxx_read_reg(priv, 0x3E, &agc_lvl[1]);\n\n\tv = agc_lvl[0];\n\tv <<= 8;\n\tv |= agc_lvl[1];\n\n\tdprintk(\"agc_lvl: 0x%04X\\n\", v);\n\n\tif (v < 0x100)\n\t\tcat = 0;\n\telse if (v < 0x190)\n\t\tcat = 5;\n\telse if (v < 0x2A8)\n\t\tcat = 4;\n\telse if (v < 0x381)\n\t\tcat = 3;\n\telse if (v < 0x400)\n\t\tcat = 2;\n\telse if (v == 0x400)\n\t\tcat = 1;\n\telse\n\t\tcat = 0;\n\n\t*signal = cat * 65535 / 5;\n\n\treturn 0;\n}\n\nstatic int lgs8913_read_signal_strength(struct lgs8gxx_state *priv, u16 *signal)\n{\n\tu8 t; s8 ret;\n\ts16 max_strength = 0;\n\tu8 str;\n\tu16 i, gi = priv->curr_gi;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tret = lgs8gxx_read_reg(priv, 0x4B, &t);\n\tif (ret != 0)\n\t\treturn -EIO;\n\n\tif (fake_signal_str) {\n\t\tif ((t & 0xC0) == 0xC0) {\n\t\t\tdprintk(\"Fake signal strength\\n\");\n\t\t\t*signal = 0x7FFF;\n\t\t} else\n\t\t\t*signal = 0;\n\t\treturn 0;\n\t}\n\n\tdprintk(\"gi = %d\\n\", gi);\n\tfor (i = 0; i < gi; i++) {\n\n\t\tif ((i & 0xFF) == 0)\n\t\t\tlgs8gxx_write_reg(priv, 0x84, 0x03 & (i >> 8));\n\t\tlgs8gxx_write_reg(priv, 0x83, i & 0xFF);\n\n\t\tlgs8gxx_read_reg(priv, 0x94, &str);\n\t\tif (max_strength < str)\n\t\t\tmax_strength = str;\n\t}\n\n\t*signal = max_strength;\n\tdprintk(\"%s: signal=0x%02X\\n\", __func__, *signal);\n\n\tlgs8gxx_read_reg(priv, 0x95, &t);\n\tdprintk(\"%s: AVG Noise=0x%02X\\n\", __func__, t);\n\n\treturn 0;\n}\n\nstatic int lgs8g75_read_signal_strength(struct lgs8gxx_state *priv, u16 *signal)\n{\n\tu8 t;\n\ts16 v = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tlgs8gxx_read_reg(priv, 0xB1, &t);\n\tv |= t;\n\tv <<= 8;\n\tlgs8gxx_read_reg(priv, 0xB0, &t);\n\tv |= t;\n\n\t*signal = v;\n\tdprintk(\"%s: signal=0x%02X\\n\", __func__, *signal);\n\n\treturn 0;\n}\n\nstatic int lgs8gxx_read_signal_strength(struct dvb_frontend *fe, u16 *signal)\n{\n\tstruct lgs8gxx_state *priv = fe->demodulator_priv;\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8913)\n\t\treturn lgs8913_read_signal_strength(priv, signal);\n\telse if (priv->config->prod == LGS8GXX_PROD_LGS8G75)\n\t\treturn lgs8g75_read_signal_strength(priv, signal);\n\telse\n\t\treturn lgs8gxx_read_signal_agc(priv, signal);\n}\n\nstatic int lgs8gxx_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct lgs8gxx_state *priv = fe->demodulator_priv;\n\tu8 t;\n\t*snr = 0;\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75)\n\t\tlgs8gxx_read_reg(priv, 0x34, &t);\n\telse\n\t\tlgs8gxx_read_reg(priv, 0x95, &t);\n\tdprintk(\"AVG Noise=0x%02X\\n\", t);\n\t*snr = 256 - t;\n\t*snr <<= 8;\n\tdprintk(\"snr=0x%x\\n\", *snr);\n\n\treturn 0;\n}\n\nstatic int lgs8gxx_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\t*ucblocks = 0;\n\tdprintk(\"%s: ucblocks=0x%x\\n\", __func__, *ucblocks);\n\treturn 0;\n}\n\nstatic void packet_counter_start(struct lgs8gxx_state *priv)\n{\n\tu8 orig, t;\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\n\t\tlgs8gxx_read_reg(priv, 0x30, &orig);\n\t\torig &= 0xE7;\n\t\tt = orig | 0x10;\n\t\tlgs8gxx_write_reg(priv, 0x30, t);\n\t\tt = orig | 0x18;\n\t\tlgs8gxx_write_reg(priv, 0x30, t);\n\t\tt = orig | 0x10;\n\t\tlgs8gxx_write_reg(priv, 0x30, t);\n\t} else {\n\t\tlgs8gxx_write_reg(priv, 0xC6, 0x01);\n\t\tlgs8gxx_write_reg(priv, 0xC6, 0x41);\n\t\tlgs8gxx_write_reg(priv, 0xC6, 0x01);\n\t}\n}\n\nstatic void packet_counter_stop(struct lgs8gxx_state *priv)\n{\n\tu8 t;\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\n\t\tlgs8gxx_read_reg(priv, 0x30, &t);\n\t\tt &= 0xE7;\n\t\tlgs8gxx_write_reg(priv, 0x30, t);\n\t} else {\n\t\tlgs8gxx_write_reg(priv, 0xC6, 0x81);\n\t}\n}\n\nstatic int lgs8gxx_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct lgs8gxx_state *priv = fe->demodulator_priv;\n\tu8 reg_err, reg_total, t;\n\tu32 total_cnt = 0, err_cnt = 0;\n\tint i;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tpacket_counter_start(priv);\n\tmsleep(200);\n\tpacket_counter_stop(priv);\n\n\tif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\n\t\treg_total = 0x28; reg_err = 0x2C;\n\t} else {\n\t\treg_total = 0xD0; reg_err = 0xD4;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\ttotal_cnt <<= 8;\n\t\tlgs8gxx_read_reg(priv, reg_total+3-i, &t);\n\t\ttotal_cnt |= t;\n\t}\n\tfor (i = 0; i < 4; i++) {\n\t\terr_cnt <<= 8;\n\t\tlgs8gxx_read_reg(priv, reg_err+3-i, &t);\n\t\terr_cnt |= t;\n\t}\n\tdprintk(\"error=%d total=%d\\n\", err_cnt, total_cnt);\n\n\tif (total_cnt == 0)\n\t\t*ber = 0;\n\telse\n\t\t*ber = err_cnt * 100 / total_cnt;\n\n\tdprintk(\"%s: ber=0x%x\\n\", __func__, *ber);\n\treturn 0;\n}\n\nstatic int lgs8gxx_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct lgs8gxx_state *priv = fe->demodulator_priv;\n\n\tif (priv->config->tuner_address == 0)\n\t\treturn 0;\n\tif (enable) {\n\t\tu8 v = 0x80 | priv->config->tuner_address;\n\t\treturn lgs8gxx_write_reg(priv, 0x01, v);\n\t}\n\treturn lgs8gxx_write_reg(priv, 0x01, 0);\n}\n\nstatic const struct dvb_frontend_ops lgs8gxx_ops = {\n\t.delsys = { SYS_DTMB },\n\t.info = {\n\t\t.name = \"Legend Silicon LGS8913/LGS8GXX DMB-TH\",\n\t\t.frequency_min_hz = 474 * MHz,\n\t\t.frequency_max_hz = 858 * MHz,\n\t\t.frequency_stepsize_hz = 10 * kHz,\n\t\t.caps =\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO\n\t},\n\n\t.release = lgs8gxx_release,\n\n\t.init = lgs8gxx_init,\n\t.write = lgs8gxx_write,\n\t.i2c_gate_ctrl = lgs8gxx_i2c_gate_ctrl,\n\n\t.set_frontend = lgs8gxx_set_fe,\n\t.get_tune_settings = lgs8gxx_get_tune_settings,\n\n\t.read_status = lgs8gxx_read_status,\n\t.read_ber = lgs8gxx_read_ber,\n\t.read_signal_strength = lgs8gxx_read_signal_strength,\n\t.read_snr = lgs8gxx_read_snr,\n\t.read_ucblocks = lgs8gxx_read_ucblocks,\n};\n\nstruct dvb_frontend *lgs8gxx_attach(const struct lgs8gxx_config *config,\n\tstruct i2c_adapter *i2c)\n{\n\tstruct lgs8gxx_state *priv = NULL;\n\tu8 data = 0;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tif (config == NULL || i2c == NULL)\n\t\treturn NULL;\n\n\tpriv = kzalloc(sizeof(struct lgs8gxx_state), GFP_KERNEL);\n\tif (priv == NULL)\n\t\tgoto error_out;\n\n\tpriv->config = config;\n\tpriv->i2c = i2c;\n\n\t \n\tif (lgs8gxx_read_reg(priv, 0, &data) != 0) {\n\t\tdprintk(\"%s lgs8gxx not found at i2c addr 0x%02X\\n\",\n\t\t\t__func__, priv->config->demod_address);\n\t\tgoto error_out;\n\t}\n\n\tlgs8gxx_read_reg(priv, 1, &data);\n\n\tmemcpy(&priv->frontend.ops, &lgs8gxx_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\tpriv->frontend.demodulator_priv = priv;\n\n\tif (config->prod == LGS8GXX_PROD_LGS8G75)\n\t\tlgs8g75_init_data(priv);\n\n\treturn &priv->frontend;\n\nerror_out:\n\tdprintk(\"%s() error_out\\n\", __func__);\n\tkfree(priv);\n\treturn NULL;\n\n}\nEXPORT_SYMBOL_GPL(lgs8gxx_attach);\n\nMODULE_DESCRIPTION(\"Legend Silicon LGS8913/LGS8GXX DMB-TH demodulator driver\");\nMODULE_AUTHOR(\"David T. L. Wong <davidtlwong@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(LGS8GXX_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}