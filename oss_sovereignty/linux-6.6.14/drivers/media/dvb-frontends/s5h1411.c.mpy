{
  "module_name": "s5h1411.c",
  "hash_id": "54516a2a1bc894b60cdc149d649ae6283fbe9a0b7705b9ed8c9a7c2b67a5a172",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/s5h1411.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <media/dvb_frontend.h>\n#include \"s5h1411.h\"\n\nstruct s5h1411_state {\n\n\tstruct i2c_adapter *i2c;\n\n\t \n\tconst struct s5h1411_config *config;\n\n\tstruct dvb_frontend frontend;\n\n\tenum fe_modulation current_modulation;\n\tunsigned int first_tune:1;\n\n\tu32 current_frequency;\n\tint if_freq;\n\n\tu8 inversion;\n};\n\nstatic int debug;\n\n#define dprintk(arg...) do {\t\\\n\tif (debug)\t\t\\\n\t\tprintk(arg);\t\\\n} while (0)\n\n \nstatic struct init_tab {\n\tu8\taddr;\n\tu8\treg;\n\tu16\tdata;\n} init_tab[] = {\n\t{ S5H1411_I2C_TOP_ADDR, 0x00, 0x0071, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x08, 0x0047, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x1c, 0x0400, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x1e, 0x0370, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x1f, 0x342c, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x24, 0x0231, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x25, 0x1011, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x26, 0x0f07, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x27, 0x0f04, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x28, 0x070f, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x29, 0x2820, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x2a, 0x102e, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x2b, 0x0220, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x2e, 0x0d0e, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x2f, 0x1013, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x31, 0x171b, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x32, 0x0e0f, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x33, 0x0f10, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x34, 0x170e, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x35, 0x4b10, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x36, 0x0f17, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x3c, 0x1577, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x3d, 0x081a, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x3e, 0x77ee, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x40, 0x1e09, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x41, 0x0f0c, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x42, 0x1f10, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x4d, 0x0509, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x4e, 0x0a00, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x50, 0x0000, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x5b, 0x0000, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x5c, 0x0008, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x57, 0x1101, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x65, 0x007c, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x68, 0x0512, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x69, 0x0258, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x70, 0x0004, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x71, 0x0007, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x76, 0x00a9, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x78, 0x3141, },\n\t{ S5H1411_I2C_TOP_ADDR, 0x7a, 0x3141, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xb3, 0x8003, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xb5, 0xa6bb, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xb6, 0x0609, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xb7, 0x2f06, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xb8, 0x003f, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xb9, 0x2700, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xba, 0xfac8, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xbe, 0x1003, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xbf, 0x103f, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xce, 0x2000, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xcf, 0x0800, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xd0, 0x0800, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xd1, 0x0400, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xd2, 0x0800, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xd3, 0x2000, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xd4, 0x3000, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xdb, 0x4a9b, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xdc, 0x1000, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xde, 0x0001, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xdf, 0x0000, },\n\t{ S5H1411_I2C_TOP_ADDR, 0xe3, 0x0301, },\n\t{ S5H1411_I2C_QAM_ADDR, 0xf3, 0x0000, },\n\t{ S5H1411_I2C_QAM_ADDR, 0xf3, 0x0001, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x08, 0x0600, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x18, 0x4201, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x1e, 0x6476, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x21, 0x0830, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x0c, 0x5679, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x0d, 0x579b, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x24, 0x0102, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x31, 0x7488, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x32, 0x0a08, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x3d, 0x8689, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x49, 0x0048, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x57, 0x2012, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x5d, 0x7676, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x04, 0x0400, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x58, 0x00c0, },\n\t{ S5H1411_I2C_QAM_ADDR, 0x5b, 0x0100, },\n};\n\n \nstatic struct vsb_snr_tab {\n\tu16\tval;\n\tu16\tdata;\n} vsb_snr_tab[] = {\n\t{  0x39f, 300, },\n\t{  0x39b, 295, },\n\t{  0x397, 290, },\n\t{  0x394, 285, },\n\t{  0x38f, 280, },\n\t{  0x38b, 275, },\n\t{  0x387, 270, },\n\t{  0x382, 265, },\n\t{  0x37d, 260, },\n\t{  0x377, 255, },\n\t{  0x370, 250, },\n\t{  0x36a, 245, },\n\t{  0x364, 240, },\n\t{  0x35b, 235, },\n\t{  0x353, 230, },\n\t{  0x349, 225, },\n\t{  0x340, 220, },\n\t{  0x337, 215, },\n\t{  0x327, 210, },\n\t{  0x31b, 205, },\n\t{  0x310, 200, },\n\t{  0x302, 195, },\n\t{  0x2f3, 190, },\n\t{  0x2e4, 185, },\n\t{  0x2d7, 180, },\n\t{  0x2cd, 175, },\n\t{  0x2bb, 170, },\n\t{  0x2a9, 165, },\n\t{  0x29e, 160, },\n\t{  0x284, 155, },\n\t{  0x27a, 150, },\n\t{  0x260, 145, },\n\t{  0x23a, 140, },\n\t{  0x224, 135, },\n\t{  0x213, 130, },\n\t{  0x204, 125, },\n\t{  0x1fe, 120, },\n\t{      0,   0, },\n};\n\n \nstatic struct qam64_snr_tab {\n\tu16\tval;\n\tu16\tdata;\n} qam64_snr_tab[] = {\n\t{  0x0001,   0, },\n\t{  0x0af0, 300, },\n\t{  0x0d80, 290, },\n\t{  0x10a0, 280, },\n\t{  0x14b5, 270, },\n\t{  0x1590, 268, },\n\t{  0x1680, 266, },\n\t{  0x17b0, 264, },\n\t{  0x18c0, 262, },\n\t{  0x19b0, 260, },\n\t{  0x1ad0, 258, },\n\t{  0x1d00, 256, },\n\t{  0x1da0, 254, },\n\t{  0x1ef0, 252, },\n\t{  0x2050, 250, },\n\t{  0x20f0, 249, },\n\t{  0x21d0, 248, },\n\t{  0x22b0, 247, },\n\t{  0x23a0, 246, },\n\t{  0x2470, 245, },\n\t{  0x24f0, 244, },\n\t{  0x25a0, 243, },\n\t{  0x26c0, 242, },\n\t{  0x27b0, 241, },\n\t{  0x28d0, 240, },\n\t{  0x29b0, 239, },\n\t{  0x2ad0, 238, },\n\t{  0x2ba0, 237, },\n\t{  0x2c80, 236, },\n\t{  0x2d20, 235, },\n\t{  0x2e00, 234, },\n\t{  0x2f10, 233, },\n\t{  0x3050, 232, },\n\t{  0x3190, 231, },\n\t{  0x3300, 230, },\n\t{  0x3340, 229, },\n\t{  0x3200, 228, },\n\t{  0x3550, 227, },\n\t{  0x3610, 226, },\n\t{  0x3600, 225, },\n\t{  0x3700, 224, },\n\t{  0x3800, 223, },\n\t{  0x3920, 222, },\n\t{  0x3a20, 221, },\n\t{  0x3b30, 220, },\n\t{  0x3d00, 219, },\n\t{  0x3e00, 218, },\n\t{  0x4000, 217, },\n\t{  0x4100, 216, },\n\t{  0x4300, 215, },\n\t{  0x4400, 214, },\n\t{  0x4600, 213, },\n\t{  0x4700, 212, },\n\t{  0x4800, 211, },\n\t{  0x4a00, 210, },\n\t{  0x4b00, 209, },\n\t{  0x4d00, 208, },\n\t{  0x4f00, 207, },\n\t{  0x5050, 206, },\n\t{  0x5200, 205, },\n\t{  0x53c0, 204, },\n\t{  0x5450, 203, },\n\t{  0x5650, 202, },\n\t{  0x5820, 201, },\n\t{  0x6000, 200, },\n\t{  0xffff,   0, },\n};\n\n \nstatic struct qam256_snr_tab {\n\tu16\tval;\n\tu16\tdata;\n} qam256_snr_tab[] = {\n\t{  0x0001,   0, },\n\t{  0x0970, 400, },\n\t{  0x0a90, 390, },\n\t{  0x0b90, 380, },\n\t{  0x0d90, 370, },\n\t{  0x0ff0, 360, },\n\t{  0x1240, 350, },\n\t{  0x1345, 348, },\n\t{  0x13c0, 346, },\n\t{  0x14c0, 344, },\n\t{  0x1500, 342, },\n\t{  0x1610, 340, },\n\t{  0x1700, 338, },\n\t{  0x1800, 336, },\n\t{  0x18b0, 334, },\n\t{  0x1900, 332, },\n\t{  0x1ab0, 330, },\n\t{  0x1bc0, 328, },\n\t{  0x1cb0, 326, },\n\t{  0x1db0, 324, },\n\t{  0x1eb0, 322, },\n\t{  0x2030, 320, },\n\t{  0x2200, 318, },\n\t{  0x2280, 316, },\n\t{  0x2410, 314, },\n\t{  0x25b0, 312, },\n\t{  0x27a0, 310, },\n\t{  0x2840, 308, },\n\t{  0x29d0, 306, },\n\t{  0x2b10, 304, },\n\t{  0x2d30, 302, },\n\t{  0x2f20, 300, },\n\t{  0x30c0, 298, },\n\t{  0x3260, 297, },\n\t{  0x32c0, 296, },\n\t{  0x3300, 295, },\n\t{  0x33b0, 294, },\n\t{  0x34b0, 293, },\n\t{  0x35a0, 292, },\n\t{  0x3650, 291, },\n\t{  0x3800, 290, },\n\t{  0x3900, 289, },\n\t{  0x3a50, 288, },\n\t{  0x3b30, 287, },\n\t{  0x3cb0, 286, },\n\t{  0x3e20, 285, },\n\t{  0x3fa0, 284, },\n\t{  0x40a0, 283, },\n\t{  0x41c0, 282, },\n\t{  0x42f0, 281, },\n\t{  0x44a0, 280, },\n\t{  0x4600, 279, },\n\t{  0x47b0, 278, },\n\t{  0x4900, 277, },\n\t{  0x4a00, 276, },\n\t{  0x4ba0, 275, },\n\t{  0x4d00, 274, },\n\t{  0x4f00, 273, },\n\t{  0x5000, 272, },\n\t{  0x51f0, 272, },\n\t{  0x53a0, 270, },\n\t{  0x5520, 269, },\n\t{  0x5700, 268, },\n\t{  0x5800, 267, },\n\t{  0x5a00, 266, },\n\t{  0x5c00, 265, },\n\t{  0x5d00, 264, },\n\t{  0x5f00, 263, },\n\t{  0x6000, 262, },\n\t{  0x6200, 261, },\n\t{  0x6400, 260, },\n\t{  0xffff,   0, },\n};\n\n \nstatic int s5h1411_writereg(struct s5h1411_state *state,\n\tu8 addr, u8 reg, u16 data)\n{\n\tint ret;\n\tu8 buf[] = { reg, data >> 8,  data & 0xff };\n\n\tstruct i2c_msg msg = { .addr = addr, .flags = 0, .buf = buf, .len = 3 };\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tprintk(KERN_ERR \"%s: writereg error 0x%02x 0x%02x 0x%04x, ret == %i)\\n\",\n\t\t       __func__, addr, reg, data, ret);\n\n\treturn (ret != 1) ? -1 : 0;\n}\n\nstatic u16 s5h1411_readreg(struct s5h1411_state *state, u8 addr, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0, 0 };\n\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = addr, .flags = 0, .buf = b0, .len = 1 },\n\t\t{ .addr = addr, .flags = I2C_M_RD, .buf = b1, .len = 2 } };\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tprintk(KERN_ERR \"%s: readreg error (ret == %i)\\n\",\n\t\t\t__func__, ret);\n\treturn (b1[0] << 8) | b1[1];\n}\n\nstatic int s5h1411_softreset(struct dvb_frontend *fe)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf7, 0);\n\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf7, 1);\n\treturn 0;\n}\n\nstatic int s5h1411_set_if_freq(struct dvb_frontend *fe, int KHz)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(%d KHz)\\n\", __func__, KHz);\n\n\tswitch (KHz) {\n\tcase 3250:\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x38, 0x10d5);\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x39, 0x5342);\n\t\ts5h1411_writereg(state, S5H1411_I2C_QAM_ADDR, 0x2c, 0x10d9);\n\t\tbreak;\n\tcase 3500:\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x38, 0x1225);\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x39, 0x1e96);\n\t\ts5h1411_writereg(state, S5H1411_I2C_QAM_ADDR, 0x2c, 0x1225);\n\t\tbreak;\n\tcase 4000:\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x38, 0x14bc);\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x39, 0xb53e);\n\t\ts5h1411_writereg(state, S5H1411_I2C_QAM_ADDR, 0x2c, 0x14bd);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s(%d KHz) Invalid, defaulting to 5380\\n\",\n\t\t\t__func__, KHz);\n\t\tfallthrough;\n\tcase 5380:\n\tcase 44000:\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x38, 0x1be4);\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x39, 0x3655);\n\t\ts5h1411_writereg(state, S5H1411_I2C_QAM_ADDR, 0x2c, 0x1be4);\n\t\tbreak;\n\t}\n\n\tstate->if_freq = KHz;\n\n\treturn 0;\n}\n\nstatic int s5h1411_set_mpeg_timing(struct dvb_frontend *fe, int mode)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\tu16 val;\n\n\tdprintk(\"%s(%d)\\n\", __func__, mode);\n\n\tval = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xbe) & 0xcfff;\n\tswitch (mode) {\n\tcase S5H1411_MPEGTIMING_CONTINUOUS_INVERTING_CLOCK:\n\t\tval |= 0x0000;\n\t\tbreak;\n\tcase S5H1411_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK:\n\t\tdprintk(\"%s(%d) Mode1 or Defaulting\\n\", __func__, mode);\n\t\tval |= 0x1000;\n\t\tbreak;\n\tcase S5H1411_MPEGTIMING_NONCONTINUOUS_INVERTING_CLOCK:\n\t\tval |= 0x2000;\n\t\tbreak;\n\tcase S5H1411_MPEGTIMING_NONCONTINUOUS_NONINVERTING_CLOCK:\n\t\tval |= 0x3000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xbe, val);\n}\n\nstatic int s5h1411_set_spectralinversion(struct dvb_frontend *fe, int inversion)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\tu16 val;\n\n\tdprintk(\"%s(%d)\\n\", __func__, inversion);\n\tval = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0x24) & ~0x1000;\n\n\tif (inversion == 1)\n\t\tval |= 0x1000;  \n\n\tstate->inversion = inversion;\n\treturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x24, val);\n}\n\nstatic int s5h1411_set_serialmode(struct dvb_frontend *fe, int serial)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\tu16 val;\n\n\tdprintk(\"%s(%d)\\n\", __func__, serial);\n\tval = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xbd) & ~0x100;\n\n\tif (serial == 1)\n\t\tval |= 0x100;\n\n\treturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xbd, val);\n}\n\nstatic int s5h1411_enable_modulation(struct dvb_frontend *fe,\n\t\t\t\t     enum fe_modulation m)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(0x%08x)\\n\", __func__, m);\n\n\tif ((state->first_tune == 0) && (m == state->current_modulation)) {\n\t\tdprintk(\"%s() Already at desired modulation.  Skipping...\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\tswitch (m) {\n\tcase VSB_8:\n\t\tdprintk(\"%s() VSB_8\\n\", __func__);\n\t\ts5h1411_set_if_freq(fe, state->config->vsb_if);\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x00, 0x71);\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf6, 0x00);\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xcd, 0xf1);\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\tcase QAM_AUTO:\n\t\tdprintk(\"%s() QAM_AUTO (64/256)\\n\", __func__);\n\t\ts5h1411_set_if_freq(fe, state->config->qam_if);\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0x00, 0x0171);\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf6, 0x0001);\n\t\ts5h1411_writereg(state, S5H1411_I2C_QAM_ADDR, 0x16, 0x1101);\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xcd, 0x00f0);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s() Invalid modulation\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tstate->current_modulation = m;\n\tstate->first_tune = 0;\n\ts5h1411_softreset(fe);\n\n\treturn 0;\n}\n\nstatic int s5h1411_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(%d)\\n\", __func__, enable);\n\n\tif (enable)\n\t\treturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf5, 1);\n\telse\n\t\treturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf5, 0);\n}\n\nstatic int s5h1411_set_gpio(struct dvb_frontend *fe, int enable)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\tu16 val;\n\n\tdprintk(\"%s(%d)\\n\", __func__, enable);\n\n\tval = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xe0) & ~0x02;\n\n\tif (enable)\n\t\treturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xe0,\n\t\t\t\tval | 0x02);\n\telse\n\t\treturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xe0, val);\n}\n\nstatic int s5h1411_set_powerstate(struct dvb_frontend *fe, int enable)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(%d)\\n\", __func__, enable);\n\n\tif (enable)\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf4, 1);\n\telse {\n\t\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf4, 0);\n\t\ts5h1411_softreset(fe);\n\t}\n\n\treturn 0;\n}\n\nstatic int s5h1411_sleep(struct dvb_frontend *fe)\n{\n\treturn s5h1411_set_powerstate(fe, 1);\n}\n\nstatic int s5h1411_register_reset(struct dvb_frontend *fe)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\treturn s5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf3, 0);\n}\n\n \nstatic int s5h1411_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(frequency=%d)\\n\", __func__, p->frequency);\n\n\ts5h1411_softreset(fe);\n\n\tstate->current_frequency = p->frequency;\n\n\ts5h1411_enable_modulation(fe, p->modulation);\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\tfe->ops.tuner_ops.set_params(fe);\n\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t \n\ts5h1411_softreset(fe);\n\n\treturn 0;\n}\n\n \nstatic int s5h1411_init(struct dvb_frontend *fe)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\tint i;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\ts5h1411_set_powerstate(fe, 0);\n\ts5h1411_register_reset(fe);\n\n\tfor (i = 0; i < ARRAY_SIZE(init_tab); i++)\n\t\ts5h1411_writereg(state, init_tab[i].addr,\n\t\t\tinit_tab[i].reg,\n\t\t\tinit_tab[i].data);\n\n\t \n\tstate->current_modulation = VSB_8;\n\n\t \n\tstate->first_tune = 1;\n\n\tif (state->config->output_mode == S5H1411_SERIAL_OUTPUT)\n\t\t \n\t\ts5h1411_set_serialmode(fe, 1);\n\telse\n\t\t \n\t\ts5h1411_set_serialmode(fe, 0);\n\n\ts5h1411_set_spectralinversion(fe, state->config->inversion);\n\ts5h1411_set_if_freq(fe, state->config->vsb_if);\n\ts5h1411_set_gpio(fe, state->config->gpio);\n\ts5h1411_set_mpeg_timing(fe, state->config->mpeg_timing);\n\ts5h1411_softreset(fe);\n\n\t \n\ts5h1411_i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\nstatic int s5h1411_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\tu16 reg;\n\tu32 tuner_status = 0;\n\n\t*status = 0;\n\n\t \n\n\tswitch (state->current_modulation) {\n\tcase QAM_64:\n\tcase QAM_256:\n\t\treg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xf0);\n\t\tif (reg & 0x10)  \n\t\t\t*status |= FE_HAS_SYNC | FE_HAS_LOCK;\n\t\tif (reg & 0x100)  \n\t\t\t*status |= FE_HAS_VITERBI | FE_HAS_CARRIER | FE_HAS_SIGNAL;\n\n\t\tbreak;\n\tcase VSB_8:\n\t\treg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xf2);\n\t\tif (reg & 0x1000)  \n\t\t\t*status |= FE_HAS_SYNC | FE_HAS_LOCK;\n\t\tif (reg & 0x2000)  \n\t\t\t*status |= FE_HAS_VITERBI | FE_HAS_CARRIER | FE_HAS_SIGNAL;\n\n\t\treg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0x53);\n\t\tif (reg & 0x1)  \n\t\t\t*status |= FE_HAS_SIGNAL;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (state->config->status_mode) {\n\tcase S5H1411_DEMODLOCKING:\n\t\tif (*status & FE_HAS_VITERBI)\n\t\t\t*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\n\t\tbreak;\n\tcase S5H1411_TUNERLOCKING:\n\t\t \n\t\tif (fe->ops.tuner_ops.get_status) {\n\t\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\t\tfe->ops.tuner_ops.get_status(fe, &tuner_status);\n\n\t\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t\t}\n\t\tif (tuner_status)\n\t\t\t*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\n\t\tbreak;\n\t}\n\n\tdprintk(\"%s() status 0x%08x\\n\", __func__, *status);\n\n\treturn 0;\n}\n\nstatic int s5h1411_qam256_lookup_snr(struct dvb_frontend *fe, u16 *snr, u16 v)\n{\n\tint i, ret = -EINVAL;\n\tdprintk(\"%s()\\n\", __func__);\n\n\tfor (i = 0; i < ARRAY_SIZE(qam256_snr_tab); i++) {\n\t\tif (v < qam256_snr_tab[i].val) {\n\t\t\t*snr = qam256_snr_tab[i].data;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int s5h1411_qam64_lookup_snr(struct dvb_frontend *fe, u16 *snr, u16 v)\n{\n\tint i, ret = -EINVAL;\n\tdprintk(\"%s()\\n\", __func__);\n\n\tfor (i = 0; i < ARRAY_SIZE(qam64_snr_tab); i++) {\n\t\tif (v < qam64_snr_tab[i].val) {\n\t\t\t*snr = qam64_snr_tab[i].data;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int s5h1411_vsb_lookup_snr(struct dvb_frontend *fe, u16 *snr, u16 v)\n{\n\tint i, ret = -EINVAL;\n\tdprintk(\"%s()\\n\", __func__);\n\n\tfor (i = 0; i < ARRAY_SIZE(vsb_snr_tab); i++) {\n\t\tif (v > vsb_snr_tab[i].val) {\n\t\t\t*snr = vsb_snr_tab[i].data;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdprintk(\"%s() snr=%d\\n\", __func__, *snr);\n\treturn ret;\n}\n\nstatic int s5h1411_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\tu16 reg;\n\tdprintk(\"%s()\\n\", __func__);\n\n\tswitch (state->current_modulation) {\n\tcase QAM_64:\n\t\treg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xf1);\n\t\treturn s5h1411_qam64_lookup_snr(fe, snr, reg);\n\tcase QAM_256:\n\t\treg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xf1);\n\t\treturn s5h1411_qam256_lookup_snr(fe, snr, reg);\n\tcase VSB_8:\n\t\treg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR,\n\t\t\t0xf2) & 0x3ff;\n\t\treturn s5h1411_vsb_lookup_snr(fe, snr, reg);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int s5h1411_read_signal_strength(struct dvb_frontend *fe,\n\tu16 *signal_strength)\n{\n\t \n\tu16 snr;\n\tu32 tmp;\n\tint ret = s5h1411_read_snr(fe, &snr);\n\n\t*signal_strength = 0;\n\n\tif (0 == ret) {\n\t\t \n\n\t\t \n\t\ttmp = (snr * ((1 << 24) / 10));\n\n\t\t \n\t\tif (tmp >= 8960 * 0x10000)\n\t\t\t*signal_strength = 0xffff;\n\t\telse\n\t\t\t*signal_strength = tmp / 8960;\n\t}\n\n\treturn ret;\n}\n\nstatic int s5h1411_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\n\t*ucblocks = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0xc9);\n\n\treturn 0;\n}\n\nstatic int s5h1411_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\treturn s5h1411_read_ucblocks(fe, ber);\n}\n\nstatic int s5h1411_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\n\tp->frequency = state->current_frequency;\n\tp->modulation = state->current_modulation;\n\n\treturn 0;\n}\n\nstatic int s5h1411_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t     struct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic void s5h1411_release(struct dvb_frontend *fe)\n{\n\tstruct s5h1411_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops s5h1411_ops;\n\nstruct dvb_frontend *s5h1411_attach(const struct s5h1411_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct s5h1411_state *state = NULL;\n\tu16 reg;\n\n\t \n\tstate = kzalloc(sizeof(struct s5h1411_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->current_modulation = VSB_8;\n\tstate->inversion = state->config->inversion;\n\n\t \n\treg = s5h1411_readreg(state, S5H1411_I2C_TOP_ADDR, 0x05);\n\tif (reg != 0x0066)\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &s5h1411_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\n\tstate->frontend.demodulator_priv = state;\n\n\tif (s5h1411_init(&state->frontend) != 0) {\n\t\tprintk(KERN_ERR \"%s: Failed to initialize correctly\\n\",\n\t\t\t__func__);\n\t\tgoto error;\n\t}\n\n\t \n\ts5h1411_writereg(state, S5H1411_I2C_TOP_ADDR, 0xf5, 1);\n\n\t \n\ts5h1411_set_powerstate(&state->frontend, 1);\n\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(s5h1411_attach);\n\nstatic const struct dvb_frontend_ops s5h1411_ops = {\n\t.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },\n\t.info = {\n\t\t.name\t\t\t= \"Samsung S5H1411 QAM/8VSB Frontend\",\n\t\t.frequency_min_hz\t=  54 * MHz,\n\t\t.frequency_max_hz\t= 858 * MHz,\n\t\t.frequency_stepsize_hz\t= 62500,\n\t\t.caps = FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB\n\t},\n\n\t.init                 = s5h1411_init,\n\t.sleep                = s5h1411_sleep,\n\t.i2c_gate_ctrl        = s5h1411_i2c_gate_ctrl,\n\t.set_frontend         = s5h1411_set_frontend,\n\t.get_frontend         = s5h1411_get_frontend,\n\t.get_tune_settings    = s5h1411_get_tune_settings,\n\t.read_status          = s5h1411_read_status,\n\t.read_ber             = s5h1411_read_ber,\n\t.read_signal_strength = s5h1411_read_signal_strength,\n\t.read_snr             = s5h1411_read_snr,\n\t.read_ucblocks        = s5h1411_read_ucblocks,\n\t.release              = s5h1411_release,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Enable verbose debug messages\");\n\nMODULE_DESCRIPTION(\"Samsung S5H1411 QAM-B/ATSC Demodulator driver\");\nMODULE_AUTHOR(\"Steven Toth\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}