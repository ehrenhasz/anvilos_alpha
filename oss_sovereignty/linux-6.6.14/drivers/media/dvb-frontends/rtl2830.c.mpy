{
  "module_name": "rtl2830.c",
  "hash_id": "9cccb8f5667f6d9fcd14e9ee70b3e7547af25b8202e6a7299570ccd2dfd3cb35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/rtl2830.c",
  "human_readable_source": "\n \n\n#include \"rtl2830_priv.h\"\n\n \nstatic int rtl2830_bulk_write(struct i2c_client *client, unsigned int reg,\n\t\t\t      const void *val, size_t val_count)\n{\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\n\ti2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tret = regmap_bulk_write(dev->regmap, reg, val, val_count);\n\ti2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\treturn ret;\n}\n\nstatic int rtl2830_update_bits(struct i2c_client *client, unsigned int reg,\n\t\t\t       unsigned int mask, unsigned int val)\n{\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\n\ti2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tret = regmap_update_bits(dev->regmap, reg, mask, val);\n\ti2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\treturn ret;\n}\n\nstatic int rtl2830_bulk_read(struct i2c_client *client, unsigned int reg,\n\t\t\t     void *val, size_t val_count)\n{\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\n\ti2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tret = regmap_bulk_read(dev->regmap, reg, val, val_count);\n\ti2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\treturn ret;\n}\n\nstatic int rtl2830_init(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\n\tint ret, i;\n\tstruct rtl2830_reg_val_mask tab[] = {\n\t\t{0x00d, 0x01, 0x03},\n\t\t{0x00d, 0x10, 0x10},\n\t\t{0x104, 0x00, 0x1e},\n\t\t{0x105, 0x80, 0x80},\n\t\t{0x110, 0x02, 0x03},\n\t\t{0x110, 0x08, 0x0c},\n\t\t{0x17b, 0x00, 0x40},\n\t\t{0x17d, 0x05, 0x0f},\n\t\t{0x17d, 0x50, 0xf0},\n\t\t{0x18c, 0x08, 0x0f},\n\t\t{0x18d, 0x00, 0xc0},\n\t\t{0x188, 0x05, 0x0f},\n\t\t{0x189, 0x00, 0xfc},\n\t\t{0x2d5, 0x02, 0x02},\n\t\t{0x2f1, 0x02, 0x06},\n\t\t{0x2f1, 0x20, 0xf8},\n\t\t{0x16d, 0x00, 0x01},\n\t\t{0x1a6, 0x00, 0x80},\n\t\t{0x106, dev->pdata->vtop, 0x3f},\n\t\t{0x107, dev->pdata->krf, 0x3f},\n\t\t{0x112, 0x28, 0xff},\n\t\t{0x103, dev->pdata->agc_targ_val, 0xff},\n\t\t{0x00a, 0x02, 0x07},\n\t\t{0x140, 0x0c, 0x3c},\n\t\t{0x140, 0x40, 0xc0},\n\t\t{0x15b, 0x05, 0x07},\n\t\t{0x15b, 0x28, 0x38},\n\t\t{0x15c, 0x05, 0x07},\n\t\t{0x15c, 0x28, 0x38},\n\t\t{0x115, dev->pdata->spec_inv, 0x01},\n\t\t{0x16f, 0x01, 0x07},\n\t\t{0x170, 0x18, 0x38},\n\t\t{0x172, 0x0f, 0x0f},\n\t\t{0x173, 0x08, 0x38},\n\t\t{0x175, 0x01, 0x07},\n\t\t{0x176, 0x00, 0xc0},\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(tab); i++) {\n\t\tret = rtl2830_update_bits(client, tab[i].reg, tab[i].mask,\n\t\t\t\t\t  tab[i].val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = rtl2830_bulk_write(client, 0x18f, \"\\x28\\x00\", 2);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl2830_bulk_write(client, 0x195,\n\t\t\t\t \"\\x04\\x06\\x0a\\x12\\x0a\\x12\\x1e\\x28\", 8);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\n\t \n\tret = rtl2830_update_bits(client, 0x101, 0x04, 0x04);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl2830_update_bits(client, 0x101, 0x04, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tc->strength.len = 1;\n\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->cnr.len = 1;\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.len = 1;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tdev->sleeping = false;\n\n\treturn ret;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2830_sleep(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\n\tdev->sleeping = true;\n\tdev->fe_status = 0;\n\n\treturn 0;\n}\n\nstatic int rtl2830_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t     struct dvb_frontend_tune_settings *s)\n{\n\ts->min_delay_ms = 500;\n\ts->step_size = fe->ops.info.frequency_stepsize_hz * 2;\n\ts->max_drift = (fe->ops.info.frequency_stepsize_hz * 2) + 1;\n\n\treturn 0;\n}\n\nstatic int rtl2830_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i;\n\tu64 num;\n\tu8 buf[3], u8tmp;\n\tu32 if_ctl, if_frequency;\n\tstatic const u8 bw_params1[3][34] = {\n\t\t{\n\t\t0x1f, 0xf0, 0x1f, 0xf0, 0x1f, 0xfa, 0x00, 0x17, 0x00, 0x41,\n\t\t0x00, 0x64, 0x00, 0x67, 0x00, 0x38, 0x1f, 0xde, 0x1f, 0x7a,\n\t\t0x1f, 0x47, 0x1f, 0x7c, 0x00, 0x30, 0x01, 0x4b, 0x02, 0x82,\n\t\t0x03, 0x73, 0x03, 0xcf,  \n\t\t}, {\n\t\t0x1f, 0xfa, 0x1f, 0xda, 0x1f, 0xc1, 0x1f, 0xb3, 0x1f, 0xca,\n\t\t0x00, 0x07, 0x00, 0x4d, 0x00, 0x6d, 0x00, 0x40, 0x1f, 0xca,\n\t\t0x1f, 0x4d, 0x1f, 0x2a, 0x1f, 0xb2, 0x00, 0xec, 0x02, 0x7e,\n\t\t0x03, 0xd0, 0x04, 0x53,  \n\t\t}, {\n\t\t0x00, 0x10, 0x00, 0x0e, 0x1f, 0xf7, 0x1f, 0xc9, 0x1f, 0xa0,\n\t\t0x1f, 0xa6, 0x1f, 0xec, 0x00, 0x4e, 0x00, 0x7d, 0x00, 0x3a,\n\t\t0x1f, 0x98, 0x1f, 0x10, 0x1f, 0x40, 0x00, 0x75, 0x02, 0x5f,\n\t\t0x04, 0x24, 0x04, 0xdb,  \n\t\t},\n\t};\n\tstatic const u8 bw_params2[3][6] = {\n\t\t{0xc3, 0x0c, 0x44, 0x33, 0x33, 0x30},  \n\t\t{0xb8, 0xe3, 0x93, 0x99, 0x99, 0x98},  \n\t\t{0xae, 0xba, 0xf3, 0x26, 0x66, 0x64},  \n\t};\n\n\tdev_dbg(&client->dev, \"frequency=%u bandwidth_hz=%u inversion=%u\\n\",\n\t\tc->frequency, c->bandwidth_hz, c->inversion);\n\n\t \n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\n\tswitch (c->bandwidth_hz) {\n\tcase 6000000:\n\t\ti = 0;\n\t\tbreak;\n\tcase 7000000:\n\t\ti = 1;\n\t\tbreak;\n\tcase 8000000:\n\t\ti = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"invalid bandwidth_hz %u\\n\",\n\t\t\tc->bandwidth_hz);\n\t\treturn -EINVAL;\n\t}\n\n\tret = rtl2830_update_bits(client, 0x008, 0x06, i << 1);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (fe->ops.tuner_ops.get_if_frequency)\n\t\tret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\n\telse\n\t\tret = -EINVAL;\n\tif (ret)\n\t\tgoto err;\n\n\tnum = if_frequency % dev->pdata->clk;\n\tnum *= 0x400000;\n\tnum = div_u64(num, dev->pdata->clk);\n\tnum = -num;\n\tif_ctl = num & 0x3fffff;\n\tdev_dbg(&client->dev, \"if_frequency=%d if_ctl=%08x\\n\",\n\t\tif_frequency, if_ctl);\n\n\tbuf[0] = (if_ctl >> 16) & 0x3f;\n\tbuf[1] = (if_ctl >>  8) & 0xff;\n\tbuf[2] = (if_ctl >>  0) & 0xff;\n\n\tret = rtl2830_bulk_read(client, 0x119, &u8tmp, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tbuf[0] |= u8tmp & 0xc0;   \n\n\tret = rtl2830_bulk_write(client, 0x119, buf, 3);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = rtl2830_bulk_write(client, 0x11c, &bw_params1[i][0], 17);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = rtl2830_bulk_write(client, 0x12d, &bw_params1[i][17], 17);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl2830_bulk_write(client, 0x19d, bw_params2[i], 6);\n\tif (ret)\n\t\tgoto err;\n\n\treturn ret;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2830_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *c)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\tu8 buf[3];\n\n\tif (dev->sleeping)\n\t\treturn 0;\n\n\tret = rtl2830_bulk_read(client, 0x33c, buf, 2);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl2830_bulk_read(client, 0x351, &buf[2], 1);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_dbg(&client->dev, \"TPS=%*ph\\n\", 3, buf);\n\n\tswitch ((buf[0] >> 2) & 3) {\n\tcase 0:\n\t\tc->modulation = QPSK;\n\t\tbreak;\n\tcase 1:\n\t\tc->modulation = QAM_16;\n\t\tbreak;\n\tcase 2:\n\t\tc->modulation = QAM_64;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[2] >> 2) & 1) {\n\tcase 0:\n\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n\tcase 1:\n\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t}\n\n\tswitch ((buf[2] >> 0) & 3) {\n\tcase 0:\n\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\tc->guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tc->guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[0] >> 4) & 7) {\n\tcase 0:\n\t\tc->hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tc->hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tcase 2:\n\t\tc->hierarchy = HIERARCHY_2;\n\t\tbreak;\n\tcase 3:\n\t\tc->hierarchy = HIERARCHY_4;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[1] >> 3) & 7) {\n\tcase 0:\n\t\tc->code_rate_HP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tc->code_rate_HP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tc->code_rate_HP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tc->code_rate_HP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tc->code_rate_HP = FEC_7_8;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[1] >> 0) & 7) {\n\tcase 0:\n\t\tc->code_rate_LP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tc->code_rate_LP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tc->code_rate_LP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tc->code_rate_LP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tc->code_rate_LP = FEC_7_8;\n\t\tbreak;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2830_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\tstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\n\tint ret, stmp;\n\tunsigned int utmp;\n\tu8 u8tmp, buf[2];\n\n\t*status = 0;\n\n\tif (dev->sleeping)\n\t\treturn 0;\n\n\tret = rtl2830_bulk_read(client, 0x351, &u8tmp, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tu8tmp = (u8tmp >> 3) & 0x0f;  \n\tif (u8tmp == 11) {\n\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\tFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\t} else if (u8tmp == 10) {\n\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\tFE_HAS_VITERBI;\n\t}\n\n\tdev->fe_status = *status;\n\n\t \n\tif (dev->fe_status & FE_HAS_SIGNAL) {\n\t\t \n\t\tret = rtl2830_bulk_read(client, 0x359, buf, 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tstmp = buf[0] << 8 | buf[1] << 0;\n\t\tstmp = sign_extend32(stmp, 13);\n\t\tutmp = clamp_val(-4 * stmp + 32767, 0x0000, 0xffff);\n\n\t\tdev_dbg(&client->dev, \"IF AGC=%d\\n\", stmp);\n\n\t\tc->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\t\tc->strength.stat[0].uvalue = utmp;\n\t} else {\n\t\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (dev->fe_status & FE_HAS_VITERBI) {\n\t\tunsigned int hierarchy, constellation;\n\t\t#define CONSTELLATION_NUM 3\n\t\t#define HIERARCHY_NUM 4\n\t\tstatic const u32 constant[CONSTELLATION_NUM][HIERARCHY_NUM] = {\n\t\t\t{70705899, 70705899, 70705899, 70705899},\n\t\t\t{82433173, 82433173, 87483115, 94445660},\n\t\t\t{92888734, 92888734, 95487525, 99770748},\n\t\t};\n\n\t\tret = rtl2830_bulk_read(client, 0x33c, &u8tmp, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tconstellation = (u8tmp >> 2) & 0x03;  \n\t\tif (constellation > CONSTELLATION_NUM - 1)\n\t\t\tgoto err;\n\n\t\thierarchy = (u8tmp >> 4) & 0x07;  \n\t\tif (hierarchy > HIERARCHY_NUM - 1)\n\t\t\tgoto err;\n\n\t\tret = rtl2830_bulk_read(client, 0x40c, buf, 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp = buf[0] << 8 | buf[1] << 0;\n\t\tif (utmp)\n\t\t\tstmp = (constant[constellation][hierarchy] -\n\t\t\t       intlog10(utmp)) / ((1 << 24) / 10000);\n\t\telse\n\t\t\tstmp = 0;\n\n\t\tdev_dbg(&client->dev, \"CNR raw=%u\\n\", utmp);\n\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[0].svalue = stmp;\n\t} else {\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (dev->fe_status & FE_HAS_LOCK) {\n\t\tret = rtl2830_bulk_read(client, 0x34e, buf, 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp = buf[0] << 8 | buf[1] << 0;\n\t\tdev->post_bit_error += utmp;\n\t\tdev->post_bit_count += 1000000;\n\n\t\tdev_dbg(&client->dev, \"BER errors=%u total=1000000\\n\", utmp);\n\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[0].uvalue = dev->post_bit_count;\n\t} else {\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\n\treturn ret;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL)\n\t\t*snr = div_s64(c->cnr.stat[0].svalue, 100);\n\telse\n\t\t*snr = 0;\n\n\treturn 0;\n}\n\nstatic int rtl2830_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\n\t*ber = (dev->post_bit_error - dev->post_bit_error_prev);\n\tdev->post_bit_error_prev = dev->post_bit_error;\n\n\treturn 0;\n}\n\nstatic int rtl2830_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\t*ucblocks = 0;\n\n\treturn 0;\n}\n\nstatic int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->strength.stat[0].scale == FE_SCALE_RELATIVE)\n\t\t*strength = c->strength.stat[0].uvalue;\n\telse\n\t\t*strength = 0;\n\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops rtl2830_ops = {\n\t.delsys = {SYS_DVBT},\n\t.info = {\n\t\t.name = \"Realtek RTL2830 (DVB-T)\",\n\t\t.caps = FE_CAN_FEC_1_2 |\n\t\t\tFE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 |\n\t\t\tFE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK |\n\t\t\tFE_CAN_QAM_16 |\n\t\t\tFE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO |\n\t\t\tFE_CAN_RECOVER |\n\t\t\tFE_CAN_MUTE_TS\n\t},\n\n\t.init = rtl2830_init,\n\t.sleep = rtl2830_sleep,\n\n\t.get_tune_settings = rtl2830_get_tune_settings,\n\n\t.set_frontend = rtl2830_set_frontend,\n\t.get_frontend = rtl2830_get_frontend,\n\n\t.read_status = rtl2830_read_status,\n\t.read_snr = rtl2830_read_snr,\n\t.read_ber = rtl2830_read_ber,\n\t.read_ucblocks = rtl2830_read_ucblocks,\n\t.read_signal_strength = rtl2830_read_signal_strength,\n};\n\nstatic int rtl2830_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tint ret;\n\tu8 u8tmp;\n\n\tdev_dbg(&client->dev, \"onoff=%d\\n\", onoff);\n\n\t \n\tif (onoff)\n\t\tu8tmp = 0x80;\n\telse\n\t\tu8tmp = 0x00;\n\n\tret = rtl2830_update_bits(client, 0x061, 0x80, u8tmp);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2830_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid, int onoff)\n{\n\tstruct i2c_client *client = fe->demodulator_priv;\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\tu8 buf[4];\n\n\tdev_dbg(&client->dev, \"index=%d pid=%04x onoff=%d\\n\",\n\t\tindex, pid, onoff);\n\n\t \n\tif (pid > 0x1fff || index > 32)\n\t\treturn 0;\n\n\tif (onoff)\n\t\tset_bit(index, &dev->filters);\n\telse\n\t\tclear_bit(index, &dev->filters);\n\n\t \n\tbuf[0] = (dev->filters >>  0) & 0xff;\n\tbuf[1] = (dev->filters >>  8) & 0xff;\n\tbuf[2] = (dev->filters >> 16) & 0xff;\n\tbuf[3] = (dev->filters >> 24) & 0xff;\n\tret = rtl2830_bulk_write(client, 0x062, buf, 4);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tbuf[0] = (pid >> 8) & 0xff;\n\tbuf[1] = (pid >> 0) & 0xff;\n\tret = rtl2830_bulk_write(client, 0x066 + 2 * index, buf, 2);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\n \nstatic int rtl2830_select(struct i2c_mux_core *muxc, u32 chan_id)\n{\n\tstruct i2c_client *client = i2c_mux_priv(muxc);\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\t \n\tret = regmap_update_bits(dev->regmap, 0x101, 0x08, 0x08);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic struct dvb_frontend *rtl2830_get_dvb_frontend(struct i2c_client *client)\n{\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\treturn &dev->fe;\n}\n\nstatic struct i2c_adapter *rtl2830_get_i2c_adapter(struct i2c_client *client)\n{\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\treturn dev->muxc->adapter[0];\n}\n\n \nstatic int rtl2830_regmap_read(void *context, const void *reg_buf,\n\t\t\t       size_t reg_size, void *val_buf, size_t val_size)\n{\n\tstruct i2c_client *client = context;\n\tint ret;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = reg_size,\n\t\t\t.buf = (u8 *)reg_buf,\n\t\t}, {\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = val_size,\n\t\t\t.buf = val_buf,\n\t\t}\n\t};\n\n\tret = __i2c_transfer(client->adapter, msg, 2);\n\tif (ret != 2) {\n\t\tdev_warn(&client->dev, \"i2c reg read failed %d\\n\", ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EREMOTEIO;\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int rtl2830_regmap_write(void *context, const void *data, size_t count)\n{\n\tstruct i2c_client *client = context;\n\tint ret;\n\tstruct i2c_msg msg[1] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = count,\n\t\t\t.buf = (u8 *)data,\n\t\t}\n\t};\n\n\tret = __i2c_transfer(client->adapter, msg, 1);\n\tif (ret != 1) {\n\t\tdev_warn(&client->dev, \"i2c reg write failed %d\\n\", ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EREMOTEIO;\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int rtl2830_regmap_gather_write(void *context, const void *reg,\n\t\t\t\t       size_t reg_len, const void *val,\n\t\t\t\t       size_t val_len)\n{\n\tstruct i2c_client *client = context;\n\tint ret;\n\tu8 buf[256];\n\tstruct i2c_msg msg[1] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1 + val_len,\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\n\tbuf[0] = *(u8 const *)reg;\n\tmemcpy(&buf[1], val, val_len);\n\n\tret = __i2c_transfer(client->adapter, msg, 1);\n\tif (ret != 1) {\n\t\tdev_warn(&client->dev, \"i2c reg write failed %d\\n\", ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EREMOTEIO;\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int rtl2830_probe(struct i2c_client *client)\n{\n\tstruct rtl2830_platform_data *pdata = client->dev.platform_data;\n\tstruct rtl2830_dev *dev;\n\tint ret;\n\tu8 u8tmp;\n\tstatic const struct regmap_bus regmap_bus = {\n\t\t.read = rtl2830_regmap_read,\n\t\t.write = rtl2830_regmap_write,\n\t\t.gather_write = rtl2830_regmap_gather_write,\n\t\t.val_format_endian_default = REGMAP_ENDIAN_NATIVE,\n\t};\n\tstatic const struct regmap_range_cfg regmap_range_cfg[] = {\n\t\t{\n\t\t\t.selector_reg     = 0x00,\n\t\t\t.selector_mask    = 0xff,\n\t\t\t.selector_shift   = 0,\n\t\t\t.window_start     = 0,\n\t\t\t.window_len       = 0x100,\n\t\t\t.range_min        = 0 * 0x100,\n\t\t\t.range_max        = 5 * 0x100,\n\t\t},\n\t};\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits    =  8,\n\t\t.val_bits    =  8,\n\t\t.max_register = 5 * 0x100,\n\t\t.ranges = regmap_range_cfg,\n\t\t.num_ranges = ARRAY_SIZE(regmap_range_cfg),\n\t};\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tif (pdata == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\ti2c_set_clientdata(client, dev);\n\tdev->client = client;\n\tdev->pdata = client->dev.platform_data;\n\tdev->sleeping = true;\n\tdev->regmap = regmap_init(&client->dev, &regmap_bus, client,\n\t\t\t\t  &regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tret = rtl2830_bulk_read(client, 0x000, &u8tmp, 1);\n\tif (ret)\n\t\tgoto err_regmap_exit;\n\n\t \n\tdev->muxc = i2c_mux_alloc(client->adapter, &client->dev, 1, 0, 0,\n\t\t\t\t  rtl2830_select, NULL);\n\tif (!dev->muxc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_regmap_exit;\n\t}\n\tdev->muxc->priv = client;\n\tret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);\n\tif (ret)\n\t\tgoto err_regmap_exit;\n\n\t \n\tmemcpy(&dev->fe.ops, &rtl2830_ops, sizeof(dev->fe.ops));\n\tdev->fe.demodulator_priv = client;\n\n\t \n\tpdata->get_dvb_frontend = rtl2830_get_dvb_frontend;\n\tpdata->get_i2c_adapter = rtl2830_get_i2c_adapter;\n\tpdata->pid_filter = rtl2830_pid_filter;\n\tpdata->pid_filter_ctrl = rtl2830_pid_filter_ctrl;\n\n\tdev_info(&client->dev, \"Realtek RTL2830 successfully attached\\n\");\n\n\treturn 0;\nerr_regmap_exit:\n\tregmap_exit(dev->regmap);\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void rtl2830_remove(struct i2c_client *client)\n{\n\tstruct rtl2830_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\ti2c_mux_del_adapters(dev->muxc);\n\tregmap_exit(dev->regmap);\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id rtl2830_id_table[] = {\n\t{\"rtl2830\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, rtl2830_id_table);\n\nstatic struct i2c_driver rtl2830_driver = {\n\t.driver = {\n\t\t.name\t\t\t= \"rtl2830\",\n\t\t.suppress_bind_attrs\t= true,\n\t},\n\t.probe\t\t= rtl2830_probe,\n\t.remove\t\t= rtl2830_remove,\n\t.id_table\t= rtl2830_id_table,\n};\n\nmodule_i2c_driver(rtl2830_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Realtek RTL2830 DVB-T demodulator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}