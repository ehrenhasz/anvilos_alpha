{
  "module_name": "dib3000mc.c",
  "hash_id": "86b1e9e0028b863370bdafe4f07976ae589699a0debc12663cbefde32b3f2015",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/dib3000mc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"dib3000mc.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"turn on debugging (default: 0)\");\n\nstatic int buggy_sfn_workaround;\nmodule_param(buggy_sfn_workaround, int, 0644);\nMODULE_PARM_DESC(buggy_sfn_workaround, \"Enable work-around for buggy SFNs (default: 0)\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\nstruct dib3000mc_state {\n\tstruct dvb_frontend demod;\n\tstruct dib3000mc_config *cfg;\n\n\tu8 i2c_addr;\n\tstruct i2c_adapter *i2c_adap;\n\n\tstruct dibx000_i2c_master i2c_master;\n\n\tu32 timf;\n\n\tu32 current_bandwidth;\n\n\tu16 dev_id;\n\n\tu8 sfn_workaround_active :1;\n};\n\nstatic u16 dib3000mc_read_word(struct dib3000mc_state *state, u16 reg)\n{\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = state->i2c_addr >> 1, .flags = 0,        .len = 2 },\n\t\t{ .addr = state->i2c_addr >> 1, .flags = I2C_M_RD, .len = 2 },\n\t};\n\tu16 word;\n\tu8 *b;\n\n\tb = kmalloc(4, GFP_KERNEL);\n\tif (!b)\n\t\treturn 0;\n\n\tb[0] = (reg >> 8) | 0x80;\n\tb[1] = reg;\n\tb[2] = 0;\n\tb[3] = 0;\n\n\tmsg[0].buf = b;\n\tmsg[1].buf = b + 2;\n\n\tif (i2c_transfer(state->i2c_adap, msg, 2) != 2)\n\t\tdprintk(\"i2c read error on %d\\n\",reg);\n\n\tword = (b[2] << 8) | b[3];\n\tkfree(b);\n\n\treturn word;\n}\n\nstatic int dib3000mc_write_word(struct dib3000mc_state *state, u16 reg, u16 val)\n{\n\tstruct i2c_msg msg = {\n\t\t.addr = state->i2c_addr >> 1, .flags = 0, .len = 4\n\t};\n\tint rc;\n\tu8 *b;\n\n\tb = kmalloc(4, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tb[0] = reg >> 8;\n\tb[1] = reg;\n\tb[2] = val >> 8;\n\tb[3] = val;\n\n\tmsg.buf = b;\n\n\trc = i2c_transfer(state->i2c_adap, &msg, 1) != 1 ? -EREMOTEIO : 0;\n\tkfree(b);\n\n\treturn rc;\n}\n\nstatic int dib3000mc_identify(struct dib3000mc_state *state)\n{\n\tu16 value;\n\tif ((value = dib3000mc_read_word(state, 1025)) != 0x01b3) {\n\t\tdprintk(\"-E-  DiB3000MC/P: wrong Vendor ID (read=0x%x)\\n\",value);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tvalue = dib3000mc_read_word(state, 1026);\n\tif (value != 0x3001 && value != 0x3002) {\n\t\tdprintk(\"-E-  DiB3000MC/P: wrong Device ID (%x)\\n\",value);\n\t\treturn -EREMOTEIO;\n\t}\n\tstate->dev_id = value;\n\n\tdprintk(\"-I-  found DiB3000MC/P: %x\\n\",state->dev_id);\n\n\treturn 0;\n}\n\nstatic int dib3000mc_set_timing(struct dib3000mc_state *state, s16 nfft, u32 bw, u8 update_offset)\n{\n\tu32 timf;\n\n\tif (state->timf == 0) {\n\t\ttimf = 1384402; \n\t\tif (update_offset)\n\t\t\tmsleep(200); \n\t} else\n\t\ttimf = state->timf;\n\n\ttimf *= (bw / 1000);\n\n\tif (update_offset) {\n\t\ts16 tim_offs = dib3000mc_read_word(state, 416);\n\n\t\tif (tim_offs &  0x2000)\n\t\t\ttim_offs -= 0x4000;\n\n\t\tif (nfft == TRANSMISSION_MODE_2K)\n\t\t\ttim_offs *= 4;\n\n\t\ttimf += tim_offs;\n\t\tstate->timf = timf / (bw / 1000);\n\t}\n\n\tdprintk(\"timf: %d\\n\", timf);\n\n\tdib3000mc_write_word(state, 23, (u16) (timf >> 16));\n\tdib3000mc_write_word(state, 24, (u16) (timf      ) & 0xffff);\n\n\treturn 0;\n}\n\nstatic int dib3000mc_setup_pwm_state(struct dib3000mc_state *state)\n{\n\tu16 reg_51, reg_52 = state->cfg->agc->setup & 0xfefb;\n\tif (state->cfg->pwm3_inversion) {\n\t\treg_51 =  (2 << 14) | (0 << 10) | (7 << 6) | (2 << 2) | (2 << 0);\n\t\treg_52 |= (1 << 2);\n\t} else {\n\t\treg_51 = (2 << 14) | (4 << 10) | (7 << 6) | (2 << 2) | (2 << 0);\n\t\treg_52 |= (1 << 8);\n\t}\n\tdib3000mc_write_word(state, 51, reg_51);\n\tdib3000mc_write_word(state, 52, reg_52);\n\n\tif (state->cfg->use_pwm3)\n\t\tdib3000mc_write_word(state, 245, (1 << 3) | (1 << 0));\n\telse\n\t\tdib3000mc_write_word(state, 245, 0);\n\n\tdib3000mc_write_word(state, 1040, 0x3);\n\treturn 0;\n}\n\nstatic int dib3000mc_set_output_mode(struct dib3000mc_state *state, int mode)\n{\n\tint    ret = 0;\n\tu16 fifo_threshold = 1792;\n\tu16 outreg = 0;\n\tu16 outmode = 0;\n\tu16 elecout = 1;\n\tu16 smo_reg = dib3000mc_read_word(state, 206) & 0x0010;  \n\n\tdprintk(\"-I-  Setting output mode for demod %p to %d\\n\",\n\t\t\t&state->demod, mode);\n\n\tswitch (mode) {\n\t\tcase OUTMODE_HIGH_Z:  \n\t\t\telecout = 0;\n\t\t\tbreak;\n\t\tcase OUTMODE_MPEG2_PAR_GATED_CLK:   \n\t\t\toutmode = 0;\n\t\t\tbreak;\n\t\tcase OUTMODE_MPEG2_PAR_CONT_CLK:    \n\t\t\toutmode = 1;\n\t\t\tbreak;\n\t\tcase OUTMODE_MPEG2_SERIAL:          \n\t\t\toutmode = 2;\n\t\t\tbreak;\n\t\tcase OUTMODE_MPEG2_FIFO:            \n\t\t\telecout = 3;\n\t\t\t \n\t\t\tsmo_reg |= 3 << 1;\n\t\t\tfifo_threshold = 512;\n\t\t\toutmode = 5;\n\t\t\tbreak;\n\t\tcase OUTMODE_DIVERSITY:\n\t\t\toutmode = 4;\n\t\t\telecout = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Unhandled output_mode passed to be set for demod %p\\n\",&state->demod);\n\t\t\toutmode = 0;\n\t\t\tbreak;\n\t}\n\n\tif ((state->cfg->output_mpeg2_in_188_bytes))\n\t\tsmo_reg |= (1 << 5); \n\n\toutreg = dib3000mc_read_word(state, 244) & 0x07FF;\n\toutreg |= (outmode << 11);\n\tret |= dib3000mc_write_word(state,  244, outreg);\n\tret |= dib3000mc_write_word(state,  206, smo_reg);    \n\tret |= dib3000mc_write_word(state,  207, fifo_threshold);  \n\tret |= dib3000mc_write_word(state, 1040, elecout);          \n\treturn ret;\n}\n\nstatic int dib3000mc_set_bandwidth(struct dib3000mc_state *state, u32 bw)\n{\n\tu16 bw_cfg[6] = { 0 };\n\tu16 imp_bw_cfg[3] = { 0 };\n\tu16 reg;\n\n \n\tswitch (bw) {\n\t\tcase 8000:\n\t\t\tbw_cfg[0] = 0x0019; bw_cfg[1] = 0x5c30; bw_cfg[2] = 0x0054; bw_cfg[3] = 0x88a0; bw_cfg[4] = 0x01a6; bw_cfg[5] = 0xab20;\n\t\t\timp_bw_cfg[0] = 0x04db; imp_bw_cfg[1] = 0x00db; imp_bw_cfg[2] = 0x00b7;\n\t\t\tbreak;\n\n\t\tcase 7000:\n\t\t\tbw_cfg[0] = 0x001c; bw_cfg[1] = 0xfba5; bw_cfg[2] = 0x0060; bw_cfg[3] = 0x9c25; bw_cfg[4] = 0x01e3; bw_cfg[5] = 0x0cb7;\n\t\t\timp_bw_cfg[0] = 0x04c0; imp_bw_cfg[1] = 0x00c0; imp_bw_cfg[2] = 0x00a0;\n\t\t\tbreak;\n\n\t\tcase 6000:\n\t\t\tbw_cfg[0] = 0x0021; bw_cfg[1] = 0xd040; bw_cfg[2] = 0x0070; bw_cfg[3] = 0xb62b; bw_cfg[4] = 0x0233; bw_cfg[5] = 0x8ed5;\n\t\t\timp_bw_cfg[0] = 0x04a5; imp_bw_cfg[1] = 0x00a5; imp_bw_cfg[2] = 0x0089;\n\t\t\tbreak;\n\n\t\tcase 5000:\n\t\t\tbw_cfg[0] = 0x0028; bw_cfg[1] = 0x9380; bw_cfg[2] = 0x0087; bw_cfg[3] = 0x4100; bw_cfg[4] = 0x02a4; bw_cfg[5] = 0x4500;\n\t\t\timp_bw_cfg[0] = 0x0489; imp_bw_cfg[1] = 0x0089; imp_bw_cfg[2] = 0x0072;\n\t\t\tbreak;\n\n\t\tdefault: return -EINVAL;\n\t}\n\n\tfor (reg = 6; reg < 12; reg++)\n\t\tdib3000mc_write_word(state, reg, bw_cfg[reg - 6]);\n\tdib3000mc_write_word(state, 12, 0x0000);\n\tdib3000mc_write_word(state, 13, 0x03e8);\n\tdib3000mc_write_word(state, 14, 0x0000);\n\tdib3000mc_write_word(state, 15, 0x03f2);\n\tdib3000mc_write_word(state, 16, 0x0001);\n\tdib3000mc_write_word(state, 17, 0xb0d0);\n\t\n\tdib3000mc_write_word(state, 18, 0x0393);\n\tdib3000mc_write_word(state, 19, 0x8700);\n\n\tfor (reg = 55; reg < 58; reg++)\n\t\tdib3000mc_write_word(state, reg, imp_bw_cfg[reg - 55]);\n\n\t\n\tdib3000mc_set_timing(state, TRANSMISSION_MODE_2K, bw, 0);\n\n\treturn 0;\n}\n\nstatic u16 impulse_noise_val[29] =\n\n{\n\t0x38, 0x6d9, 0x3f28, 0x7a7, 0x3a74, 0x196, 0x32a, 0x48c, 0x3ffe, 0x7f3,\n\t0x2d94, 0x76, 0x53d, 0x3ff8, 0x7e3, 0x3320, 0x76, 0x5b3, 0x3feb, 0x7d2,\n\t0x365e, 0x76, 0x48c, 0x3ffe, 0x5b3, 0x3feb, 0x76, 0x0000, 0xd\n};\n\nstatic void dib3000mc_set_impulse_noise(struct dib3000mc_state *state, u8 mode, s16 nfft)\n{\n\tu16 i;\n\tfor (i = 58; i < 87; i++)\n\t\tdib3000mc_write_word(state, i, impulse_noise_val[i-58]);\n\n\tif (nfft == TRANSMISSION_MODE_8K) {\n\t\tdib3000mc_write_word(state, 58, 0x3b);\n\t\tdib3000mc_write_word(state, 84, 0x00);\n\t\tdib3000mc_write_word(state, 85, 0x8200);\n\t}\n\n\tdib3000mc_write_word(state, 34, 0x1294);\n\tdib3000mc_write_word(state, 35, 0x1ff8);\n\tif (mode == 1)\n\t\tdib3000mc_write_word(state, 55, dib3000mc_read_word(state, 55) | (1 << 10));\n}\n\nstatic int dib3000mc_init(struct dvb_frontend *demod)\n{\n\tstruct dib3000mc_state *state = demod->demodulator_priv;\n\tstruct dibx000_agc_config *agc = state->cfg->agc;\n\n\t\n\tdib3000mc_write_word(state, 1027, 0x8000);\n\tdib3000mc_write_word(state, 1027, 0x0000);\n\n\t\n\tdib3000mc_write_word(state, 140, 0x0000);\n\tdib3000mc_write_word(state, 1031, 0);\n\n\tif (state->cfg->mobile_mode) {\n\t\tdib3000mc_write_word(state, 139,  0x0000);\n\t\tdib3000mc_write_word(state, 141,  0x0000);\n\t\tdib3000mc_write_word(state, 175,  0x0002);\n\t\tdib3000mc_write_word(state, 1032, 0x0000);\n\t} else {\n\t\tdib3000mc_write_word(state, 139,  0x0001);\n\t\tdib3000mc_write_word(state, 141,  0x0000);\n\t\tdib3000mc_write_word(state, 175,  0x0000);\n\t\tdib3000mc_write_word(state, 1032, 0x012C);\n\t}\n\tdib3000mc_write_word(state, 1033, 0x0000);\n\n\t\n\tdib3000mc_write_word(state, 1037, 0x3130);\n\n\t\n\n\t\n\tdib3000mc_write_word(state, 33, (5 << 0));\n\tdib3000mc_write_word(state, 88, (1 << 10) | (0x10 << 0));\n\n\t\n\t\n\tdib3000mc_write_word(state, 99, (1 << 9) | (0x20 << 0));\n\n\tif (state->cfg->phase_noise_mode == 0)\n\t\tdib3000mc_write_word(state, 111, 0x00);\n\telse\n\t\tdib3000mc_write_word(state, 111, 0x02);\n\n\t\n\tdib3000mc_write_word(state, 50, 0x8000);\n\n\t\n\tdib3000mc_setup_pwm_state(state);\n\n\t\n\tdib3000mc_write_word(state, 53, 0x87);\n\t\n\tdib3000mc_write_word(state, 54, 0x87);\n\n\t \n\tdib3000mc_write_word(state, 36, state->cfg->max_time);\n\tdib3000mc_write_word(state, 37, (state->cfg->agc_command1 << 13) | (state->cfg->agc_command2 << 12) | (0x1d << 0));\n\tdib3000mc_write_word(state, 38, state->cfg->pwm3_value);\n\tdib3000mc_write_word(state, 39, state->cfg->ln_adc_level);\n\n\t\n\tdib3000mc_write_word(state, 40, 0x0179);\n\tdib3000mc_write_word(state, 41, 0x03f0);\n\n\tdib3000mc_write_word(state, 42, agc->agc1_max);\n\tdib3000mc_write_word(state, 43, agc->agc1_min);\n\tdib3000mc_write_word(state, 44, agc->agc2_max);\n\tdib3000mc_write_word(state, 45, agc->agc2_min);\n\tdib3000mc_write_word(state, 46, (agc->agc1_pt1 << 8) | agc->agc1_pt2);\n\tdib3000mc_write_word(state, 47, (agc->agc1_slope1 << 8) | agc->agc1_slope2);\n\tdib3000mc_write_word(state, 48, (agc->agc2_pt1 << 8) | agc->agc2_pt2);\n\tdib3000mc_write_word(state, 49, (agc->agc2_slope1 << 8) | agc->agc2_slope2);\n\n\n\t\n\tdib3000mc_write_word(state, 110, 3277);\n\t\n\tdib3000mc_write_word(state,  26, 0x6680);\n\t\n\tdib3000mc_write_word(state, 1, 4);\n\t\n\tdib3000mc_write_word(state, 2, 4);\n\t\n\tdib3000mc_write_word(state, 3, 0x1000);\n\t\n\tdib3000mc_write_word(state, 5, 1);\n\n\tdib3000mc_set_bandwidth(state, 8000);\n\n\t\n\tdib3000mc_write_word(state,  4, 0x814);\n\n\tdib3000mc_write_word(state, 21, (1 << 9) | 0x164);\n\tdib3000mc_write_word(state, 22, 0x463d);\n\n\t\n\t\n\tdib3000mc_write_word(state, 120, 0x200f);\n\t\n\tdib3000mc_write_word(state, 134, 0);\n\n\t\n\tdib3000mc_write_word(state, 195, 0x10);\n\n\t\n\tdib3000mc_write_word(state, 180, 0x2FF0);\n\n\t\n\tdib3000mc_set_impulse_noise(state, 0, TRANSMISSION_MODE_8K);\n\n\t\n\tdib3000mc_set_output_mode(state, OUTMODE_HIGH_Z);\n\n\t \n\tdib3000mc_write_word(state, 769, (1 << 7) );\n\n\treturn 0;\n}\n\nstatic int dib3000mc_sleep(struct dvb_frontend *demod)\n{\n\tstruct dib3000mc_state *state = demod->demodulator_priv;\n\n\tdib3000mc_write_word(state, 1031, 0xFFFF);\n\tdib3000mc_write_word(state, 1032, 0xFFFF);\n\tdib3000mc_write_word(state, 1033, 0xFFF0);\n\n\treturn 0;\n}\n\nstatic void dib3000mc_set_adp_cfg(struct dib3000mc_state *state, s16 qam)\n{\n\tu16 cfg[4] = { 0 },reg;\n\tswitch (qam) {\n\t\tcase QPSK:\n\t\t\tcfg[0] = 0x099a; cfg[1] = 0x7fae; cfg[2] = 0x0333; cfg[3] = 0x7ff0;\n\t\t\tbreak;\n\t\tcase QAM_16:\n\t\t\tcfg[0] = 0x023d; cfg[1] = 0x7fdf; cfg[2] = 0x00a4; cfg[3] = 0x7ff0;\n\t\t\tbreak;\n\t\tcase QAM_64:\n\t\t\tcfg[0] = 0x0148; cfg[1] = 0x7ff0; cfg[2] = 0x00a4; cfg[3] = 0x7ff8;\n\t\t\tbreak;\n\t}\n\tfor (reg = 129; reg < 133; reg++)\n\t\tdib3000mc_write_word(state, reg, cfg[reg - 129]);\n}\n\nstatic void dib3000mc_set_channel_cfg(struct dib3000mc_state *state,\n\t\t\t\t      struct dtv_frontend_properties *ch, u16 seq)\n{\n\tu16 value;\n\tu32 bw = BANDWIDTH_TO_KHZ(ch->bandwidth_hz);\n\n\tdib3000mc_set_bandwidth(state, bw);\n\tdib3000mc_set_timing(state, ch->transmission_mode, bw, 0);\n\n#if 1\n\tdib3000mc_write_word(state, 100, (16 << 6) + 9);\n#else\n\tif (boost)\n\t\tdib3000mc_write_word(state, 100, (11 << 6) + 6);\n\telse\n\t\tdib3000mc_write_word(state, 100, (16 << 6) + 9);\n#endif\n\n\tdib3000mc_write_word(state, 1027, 0x0800);\n\tdib3000mc_write_word(state, 1027, 0x0000);\n\n\t\n\tdib3000mc_write_word(state, 26,  0x6680);\n\tdib3000mc_write_word(state, 29,  0x1273);\n\tdib3000mc_write_word(state, 33,       5);\n\tdib3000mc_set_adp_cfg(state, QAM_16);\n\tdib3000mc_write_word(state, 133,  15564);\n\n\tdib3000mc_write_word(state, 12 , 0x0);\n\tdib3000mc_write_word(state, 13 , 0x3e8);\n\tdib3000mc_write_word(state, 14 , 0x0);\n\tdib3000mc_write_word(state, 15 , 0x3f2);\n\n\tdib3000mc_write_word(state, 93,0);\n\tdib3000mc_write_word(state, 94,0);\n\tdib3000mc_write_word(state, 95,0);\n\tdib3000mc_write_word(state, 96,0);\n\tdib3000mc_write_word(state, 97,0);\n\tdib3000mc_write_word(state, 98,0);\n\n\tdib3000mc_set_impulse_noise(state, 0, ch->transmission_mode);\n\n\tvalue = 0;\n\tswitch (ch->transmission_mode) {\n\t\tcase TRANSMISSION_MODE_2K: value |= (0 << 7); break;\n\t\tdefault:\n\t\tcase TRANSMISSION_MODE_8K: value |= (1 << 7); break;\n\t}\n\tswitch (ch->guard_interval) {\n\t\tcase GUARD_INTERVAL_1_32: value |= (0 << 5); break;\n\t\tcase GUARD_INTERVAL_1_16: value |= (1 << 5); break;\n\t\tcase GUARD_INTERVAL_1_4:  value |= (3 << 5); break;\n\t\tdefault:\n\t\tcase GUARD_INTERVAL_1_8:  value |= (2 << 5); break;\n\t}\n\tswitch (ch->modulation) {\n\t\tcase QPSK:  value |= (0 << 3); break;\n\t\tcase QAM_16: value |= (1 << 3); break;\n\t\tdefault:\n\t\tcase QAM_64: value |= (2 << 3); break;\n\t}\n\tswitch (HIERARCHY_1) {\n\t\tcase HIERARCHY_2: value |= 2; break;\n\t\tcase HIERARCHY_4: value |= 4; break;\n\t\tdefault:\n\t\tcase HIERARCHY_1: value |= 1; break;\n\t}\n\tdib3000mc_write_word(state, 0, value);\n\tdib3000mc_write_word(state, 5, (1 << 8) | ((seq & 0xf) << 4));\n\n\tvalue = 0;\n\tif (ch->hierarchy == 1)\n\t\tvalue |= (1 << 4);\n\tif (1 == 1)\n\t\tvalue |= 1;\n\tswitch ((ch->hierarchy == 0 || 1 == 1) ? ch->code_rate_HP : ch->code_rate_LP) {\n\t\tcase FEC_2_3: value |= (2 << 1); break;\n\t\tcase FEC_3_4: value |= (3 << 1); break;\n\t\tcase FEC_5_6: value |= (5 << 1); break;\n\t\tcase FEC_7_8: value |= (7 << 1); break;\n\t\tdefault:\n\t\tcase FEC_1_2: value |= (1 << 1); break;\n\t}\n\tdib3000mc_write_word(state, 181, value);\n\n\t\n\tswitch (ch->transmission_mode) {\n\t\tcase TRANSMISSION_MODE_8K: value = 256; break;\n\t\tcase TRANSMISSION_MODE_2K:\n\t\tdefault: value = 64; break;\n\t}\n\tswitch (ch->guard_interval) {\n\t\tcase GUARD_INTERVAL_1_16: value *= 2; break;\n\t\tcase GUARD_INTERVAL_1_8:  value *= 4; break;\n\t\tcase GUARD_INTERVAL_1_4:  value *= 8; break;\n\t\tdefault:\n\t\tcase GUARD_INTERVAL_1_32: value *= 1; break;\n\t}\n\tvalue <<= 4;\n\tvalue |= dib3000mc_read_word(state, 180) & 0x000f;\n\tdib3000mc_write_word(state, 180, value);\n\n\t\n\tvalue = dib3000mc_read_word(state, 0);\n\tdib3000mc_write_word(state, 0, value | (1 << 9));\n\tdib3000mc_write_word(state, 0, value);\n\n\tmsleep(30);\n\n\tdib3000mc_set_impulse_noise(state, state->cfg->impulse_noise_mode, ch->transmission_mode);\n}\n\nstatic int dib3000mc_autosearch_start(struct dvb_frontend *demod)\n{\n\tstruct dtv_frontend_properties *chan = &demod->dtv_property_cache;\n\tstruct dib3000mc_state *state = demod->demodulator_priv;\n\tu16 reg;\n\n\tstruct dtv_frontend_properties schan;\n\n\tschan = *chan;\n\n\t \n\n\t \n\tschan.transmission_mode = TRANSMISSION_MODE_8K;\n\tschan.guard_interval = GUARD_INTERVAL_1_32;\n\tschan.modulation = QAM_64;\n\tschan.code_rate_HP = FEC_2_3;\n\tschan.code_rate_LP = FEC_2_3;\n\tschan.hierarchy = 0;\n\n\tdib3000mc_set_channel_cfg(state, &schan, 11);\n\n\treg = dib3000mc_read_word(state, 0);\n\tdib3000mc_write_word(state, 0, reg | (1 << 8));\n\tdib3000mc_read_word(state, 511);\n\tdib3000mc_write_word(state, 0, reg);\n\n\treturn 0;\n}\n\nstatic int dib3000mc_autosearch_is_irq(struct dvb_frontend *demod)\n{\n\tstruct dib3000mc_state *state = demod->demodulator_priv;\n\tu16 irq_pending = dib3000mc_read_word(state, 511);\n\n\tif (irq_pending & 0x1) \n\t\treturn 1;\n\n\tif (irq_pending & 0x2) \n\t\treturn 2;\n\n\treturn 0; \n}\n\nstatic int dib3000mc_tune(struct dvb_frontend *demod)\n{\n\tstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\n\tstruct dib3000mc_state *state = demod->demodulator_priv;\n\n\t\n\tdib3000mc_set_channel_cfg(state, ch, 0);\n\n\t\n\tif (state->sfn_workaround_active) {\n\t\tdprintk(\"SFN workaround is active\\n\");\n\t\tdib3000mc_write_word(state, 29, 0x1273);\n\t\tdib3000mc_write_word(state, 108, 0x4000); \n\t} else {\n\t\tdib3000mc_write_word(state, 29, 0x1073);\n\t\tdib3000mc_write_word(state, 108, 0x0000); \n\t}\n\n\tdib3000mc_set_adp_cfg(state, (u8)ch->modulation);\n\tif (ch->transmission_mode == TRANSMISSION_MODE_8K) {\n\t\tdib3000mc_write_word(state, 26, 38528);\n\t\tdib3000mc_write_word(state, 33, 8);\n\t} else {\n\t\tdib3000mc_write_word(state, 26, 30336);\n\t\tdib3000mc_write_word(state, 33, 6);\n\t}\n\n\tif (dib3000mc_read_word(state, 509) & 0x80)\n\t\tdib3000mc_set_timing(state, ch->transmission_mode,\n\t\t\t\t     BANDWIDTH_TO_KHZ(ch->bandwidth_hz), 1);\n\n\treturn 0;\n}\n\nstruct i2c_adapter * dib3000mc_get_tuner_i2c_master(struct dvb_frontend *demod, int gating)\n{\n\tstruct dib3000mc_state *st = demod->demodulator_priv;\n\treturn dibx000_get_i2c_adapter(&st->i2c_master, DIBX000_I2C_INTERFACE_TUNER, gating);\n}\n\nEXPORT_SYMBOL(dib3000mc_get_tuner_i2c_master);\n\nstatic int dib3000mc_get_frontend(struct dvb_frontend* fe,\n\t\t\t\t  struct dtv_frontend_properties *fep)\n{\n\tstruct dib3000mc_state *state = fe->demodulator_priv;\n\tu16 tps = dib3000mc_read_word(state,458);\n\n\tfep->inversion = INVERSION_AUTO;\n\n\tfep->bandwidth_hz = state->current_bandwidth;\n\n\tswitch ((tps >> 8) & 0x1) {\n\t\tcase 0: fep->transmission_mode = TRANSMISSION_MODE_2K; break;\n\t\tcase 1: fep->transmission_mode = TRANSMISSION_MODE_8K; break;\n\t}\n\n\tswitch (tps & 0x3) {\n\t\tcase 0: fep->guard_interval = GUARD_INTERVAL_1_32; break;\n\t\tcase 1: fep->guard_interval = GUARD_INTERVAL_1_16; break;\n\t\tcase 2: fep->guard_interval = GUARD_INTERVAL_1_8; break;\n\t\tcase 3: fep->guard_interval = GUARD_INTERVAL_1_4; break;\n\t}\n\n\tswitch ((tps >> 13) & 0x3) {\n\t\tcase 0: fep->modulation = QPSK; break;\n\t\tcase 1: fep->modulation = QAM_16; break;\n\t\tcase 2:\n\t\tdefault: fep->modulation = QAM_64; break;\n\t}\n\n\t \n\t \n\n\tfep->hierarchy = HIERARCHY_NONE;\n\tswitch ((tps >> 5) & 0x7) {\n\t\tcase 1: fep->code_rate_HP = FEC_1_2; break;\n\t\tcase 2: fep->code_rate_HP = FEC_2_3; break;\n\t\tcase 3: fep->code_rate_HP = FEC_3_4; break;\n\t\tcase 5: fep->code_rate_HP = FEC_5_6; break;\n\t\tcase 7:\n\t\tdefault: fep->code_rate_HP = FEC_7_8; break;\n\n\t}\n\n\tswitch ((tps >> 2) & 0x7) {\n\t\tcase 1: fep->code_rate_LP = FEC_1_2; break;\n\t\tcase 2: fep->code_rate_LP = FEC_2_3; break;\n\t\tcase 3: fep->code_rate_LP = FEC_3_4; break;\n\t\tcase 5: fep->code_rate_LP = FEC_5_6; break;\n\t\tcase 7:\n\t\tdefault: fep->code_rate_LP = FEC_7_8; break;\n\t}\n\n\treturn 0;\n}\n\nstatic int dib3000mc_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *fep = &fe->dtv_property_cache;\n\tstruct dib3000mc_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tdib3000mc_set_output_mode(state, OUTMODE_HIGH_Z);\n\n\tstate->current_bandwidth = fep->bandwidth_hz;\n\tdib3000mc_set_bandwidth(state, BANDWIDTH_TO_KHZ(fep->bandwidth_hz));\n\n\t \n\tstate->sfn_workaround_active = buggy_sfn_workaround;\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tmsleep(100);\n\t}\n\n\tif (fep->transmission_mode  == TRANSMISSION_MODE_AUTO ||\n\t    fep->guard_interval == GUARD_INTERVAL_AUTO ||\n\t    fep->modulation     == QAM_AUTO ||\n\t    fep->code_rate_HP   == FEC_AUTO) {\n\t\tint i = 1000, found;\n\n\t\tdib3000mc_autosearch_start(fe);\n\t\tdo {\n\t\t\tmsleep(1);\n\t\t\tfound = dib3000mc_autosearch_is_irq(fe);\n\t\t} while (found == 0 && i--);\n\n\t\tdprintk(\"autosearch returns: %d\\n\",found);\n\t\tif (found == 0 || found == 1)\n\t\t\treturn 0; \n\n\t\tdib3000mc_get_frontend(fe, fep);\n\t}\n\n\tret = dib3000mc_tune(fe);\n\n\t \n\tdib3000mc_set_output_mode(state, OUTMODE_MPEG2_FIFO);\n\treturn ret;\n}\n\nstatic int dib3000mc_read_status(struct dvb_frontend *fe, enum fe_status *stat)\n{\n\tstruct dib3000mc_state *state = fe->demodulator_priv;\n\tu16 lock = dib3000mc_read_word(state, 509);\n\n\t*stat = 0;\n\n\tif (lock & 0x8000)\n\t\t*stat |= FE_HAS_SIGNAL;\n\tif (lock & 0x3000)\n\t\t*stat |= FE_HAS_CARRIER;\n\tif (lock & 0x0100)\n\t\t*stat |= FE_HAS_VITERBI;\n\tif (lock & 0x0010)\n\t\t*stat |= FE_HAS_SYNC;\n\tif (lock & 0x0008)\n\t\t*stat |= FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int dib3000mc_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct dib3000mc_state *state = fe->demodulator_priv;\n\t*ber = (dib3000mc_read_word(state, 500) << 16) | dib3000mc_read_word(state, 501);\n\treturn 0;\n}\n\nstatic int dib3000mc_read_unc_blocks(struct dvb_frontend *fe, u32 *unc)\n{\n\tstruct dib3000mc_state *state = fe->demodulator_priv;\n\t*unc = dib3000mc_read_word(state, 508);\n\treturn 0;\n}\n\nstatic int dib3000mc_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct dib3000mc_state *state = fe->demodulator_priv;\n\tu16 val = dib3000mc_read_word(state, 392);\n\t*strength = 65535 - val;\n\treturn 0;\n}\n\nstatic int dib3000mc_read_snr(struct dvb_frontend* fe, u16 *snr)\n{\n\t*snr = 0x0000;\n\treturn 0;\n}\n\nstatic int dib3000mc_fe_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic void dib3000mc_release(struct dvb_frontend *fe)\n{\n\tstruct dib3000mc_state *state = fe->demodulator_priv;\n\tdibx000_exit_i2c_master(&state->i2c_master);\n\tkfree(state);\n}\n\nint dib3000mc_pid_control(struct dvb_frontend *fe, int index, int pid,int onoff)\n{\n\tstruct dib3000mc_state *state = fe->demodulator_priv;\n\tdib3000mc_write_word(state, 212 + index,  onoff ? (1 << 13) | pid : 0);\n\treturn 0;\n}\nEXPORT_SYMBOL(dib3000mc_pid_control);\n\nint dib3000mc_pid_parse(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dib3000mc_state *state = fe->demodulator_priv;\n\tu16 tmp = dib3000mc_read_word(state, 206) & ~(1 << 4);\n\ttmp |= (onoff << 4);\n\treturn dib3000mc_write_word(state, 206, tmp);\n}\nEXPORT_SYMBOL(dib3000mc_pid_parse);\n\nvoid dib3000mc_set_config(struct dvb_frontend *fe, struct dib3000mc_config *cfg)\n{\n\tstruct dib3000mc_state *state = fe->demodulator_priv;\n\tstate->cfg = cfg;\n}\nEXPORT_SYMBOL(dib3000mc_set_config);\n\nint dib3000mc_i2c_enumeration(struct i2c_adapter *i2c, int no_of_demods, u8 default_addr, struct dib3000mc_config cfg[])\n{\n\tstruct dib3000mc_state *dmcst;\n\tint k;\n\tu8 new_addr;\n\n\tstatic const u8 DIB3000MC_I2C_ADDRESS[] = { 20, 22, 24, 26 };\n\n\tdmcst = kzalloc(sizeof(struct dib3000mc_state), GFP_KERNEL);\n\tif (dmcst == NULL)\n\t\treturn -ENOMEM;\n\n\tdmcst->i2c_adap = i2c;\n\n\tfor (k = no_of_demods-1; k >= 0; k--) {\n\t\tdmcst->cfg = &cfg[k];\n\n\t\t \n\t\tnew_addr          = DIB3000MC_I2C_ADDRESS[k];\n\t\tdmcst->i2c_addr = new_addr;\n\t\tif (dib3000mc_identify(dmcst) != 0) {\n\t\t\tdmcst->i2c_addr = default_addr;\n\t\t\tif (dib3000mc_identify(dmcst) != 0) {\n\t\t\t\tdprintk(\"-E-  DiB3000P/MC #%d: not identified\\n\", k);\n\t\t\t\tkfree(dmcst);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\n\t\tdib3000mc_set_output_mode(dmcst, OUTMODE_MPEG2_PAR_CONT_CLK);\n\n\t\t\n\t\tdib3000mc_write_word(dmcst, 1024, (new_addr << 3) | 0x1);\n\t\tdmcst->i2c_addr = new_addr;\n\t}\n\n\tfor (k = 0; k < no_of_demods; k++) {\n\t\tdmcst->cfg = &cfg[k];\n\t\tdmcst->i2c_addr = DIB3000MC_I2C_ADDRESS[k];\n\n\t\tdib3000mc_write_word(dmcst, 1024, dmcst->i2c_addr << 3);\n\n\t\t \n\t\tdib3000mc_set_output_mode(dmcst, OUTMODE_HIGH_Z);\n\t}\n\n\tkfree(dmcst);\n\treturn 0;\n}\nEXPORT_SYMBOL(dib3000mc_i2c_enumeration);\n\nstatic const struct dvb_frontend_ops dib3000mc_ops;\n\nstruct dvb_frontend * dib3000mc_attach(struct i2c_adapter *i2c_adap, u8 i2c_addr, struct dib3000mc_config *cfg)\n{\n\tstruct dvb_frontend *demod;\n\tstruct dib3000mc_state *st;\n\tst = kzalloc(sizeof(struct dib3000mc_state), GFP_KERNEL);\n\tif (st == NULL)\n\t\treturn NULL;\n\n\tst->cfg = cfg;\n\tst->i2c_adap = i2c_adap;\n\tst->i2c_addr = i2c_addr;\n\n\tdemod                   = &st->demod;\n\tdemod->demodulator_priv = st;\n\tmemcpy(&st->demod.ops, &dib3000mc_ops, sizeof(struct dvb_frontend_ops));\n\n\tif (dib3000mc_identify(st) != 0)\n\t\tgoto error;\n\n\tdibx000_init_i2c_master(&st->i2c_master, DIB3000MC, st->i2c_adap, st->i2c_addr);\n\n\tdib3000mc_write_word(st, 1037, 0x3130);\n\n\treturn demod;\n\nerror:\n\tkfree(st);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(dib3000mc_attach);\n\nstatic const struct dvb_frontend_ops dib3000mc_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name = \"DiBcom 3000MC/P\",\n\t\t.frequency_min_hz      =  44250 * kHz,\n\t\t.frequency_max_hz      = 867250 * kHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_RECOVER |\n\t\t\tFE_CAN_HIERARCHY_AUTO,\n\t},\n\n\t.release              = dib3000mc_release,\n\n\t.init                 = dib3000mc_init,\n\t.sleep                = dib3000mc_sleep,\n\n\t.set_frontend         = dib3000mc_set_frontend,\n\t.get_tune_settings    = dib3000mc_fe_get_tune_settings,\n\t.get_frontend         = dib3000mc_get_frontend,\n\n\t.read_status          = dib3000mc_read_status,\n\t.read_ber             = dib3000mc_read_ber,\n\t.read_signal_strength = dib3000mc_read_signal_strength,\n\t.read_snr             = dib3000mc_read_snr,\n\t.read_ucblocks        = dib3000mc_read_unc_blocks,\n};\n\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"Driver for the DiBcom 3000MC/P COFDM demodulator\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}