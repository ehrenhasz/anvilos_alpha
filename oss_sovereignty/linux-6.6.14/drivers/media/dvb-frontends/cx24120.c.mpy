{
  "module_name": "cx24120.c",
  "hash_id": "7efdedc2988f2e95ca6e11839fe42c5c3d543e5ebaf90f9ef978f7e7fec3194e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cx24120.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/firmware.h>\n#include <media/dvb_frontend.h>\n#include \"cx24120.h\"\n\n#define CX24120_SEARCH_RANGE_KHZ 5000\n#define CX24120_FIRMWARE \"dvb-fe-cx24120-1.20.58.2.fw\"\n\n \n#define CX24120_REG_CMD_START\t0x00\t\t \n#define CX24120_REG_CMD_ARGS\t0x01\t\t \n#define CX24120_REG_CMD_END\t0x1f\t\t \n\n#define CX24120_REG_MAILBOX\t0x33\n#define CX24120_REG_FREQ3\t0x34\t\t \n#define CX24120_REG_FREQ2\t0x35\n#define CX24120_REG_FREQ1\t0x36\n\n#define CX24120_REG_FECMODE\t0x39\t\t \n#define CX24120_REG_STATUS\t0x3a\t\t \n#define CX24120_REG_SIGSTR_H\t0x3a\t\t \n#define CX24120_REG_SIGSTR_L\t0x3b\t\t \n#define CX24120_REG_QUALITY_H\t0x40\t\t \n#define CX24120_REG_QUALITY_L\t0x41\t\t \n\n#define CX24120_REG_BER_HH\t0x47\t\t \n#define CX24120_REG_BER_HL\t0x48\t\t \n#define CX24120_REG_BER_LH\t0x49\t\t \n#define CX24120_REG_BER_LL\t0x4a\t\t \n\n#define CX24120_REG_UCB_H\t0x50\t\t \n#define CX24120_REG_UCB_L\t0x51\t\t \n\n#define CX24120_REG_CLKDIV\t0xe6\n#define CX24120_REG_RATEDIV\t0xf0\n\n#define CX24120_REG_REVISION\t0xff\t\t \n\n \nenum command_message_id {\n\tCMD_VCO_SET\t\t= 0x10,\t\t \n\tCMD_TUNEREQUEST\t\t= 0x11,\t\t \n\n\tCMD_MPEG_ONOFF\t\t= 0x13,\t\t \n\tCMD_MPEG_INIT\t\t= 0x14,\t\t \n\tCMD_BANDWIDTH\t\t= 0x15,\t\t \n\tCMD_CLOCK_READ\t\t= 0x16,\t\t \n\tCMD_CLOCK_SET\t\t= 0x17,\t\t \n\n\tCMD_DISEQC_MSG1\t\t= 0x20,\t\t \n\tCMD_DISEQC_MSG2\t\t= 0x21,\t\t \n\tCMD_SETVOLTAGE\t\t= 0x22,\t\t \n\tCMD_SETTONE\t\t= 0x23,\t\t \n\tCMD_DISEQC_BURST\t= 0x24,\t\t \n\n\tCMD_READ_SNR\t\t= 0x1a,\t\t \n\tCMD_START_TUNER\t\t= 0x1b,\t\t \n\n\tCMD_FWVERSION\t\t= 0x35,\n\n\tCMD_BER_CTRL\t\t= 0x3c,\t\t \n};\n\n#define CX24120_MAX_CMD_LEN\t30\n\n \n#define CX24120_PILOT_OFF\t0x00\n#define CX24120_PILOT_ON\t0x40\n#define CX24120_PILOT_AUTO\t0x80\n\n \n#define CX24120_HAS_SIGNAL\t0x01\n#define CX24120_HAS_CARRIER\t0x02\n#define CX24120_HAS_VITERBI\t0x04\n#define CX24120_HAS_LOCK\t0x08\n#define CX24120_HAS_UNK1\t0x10\n#define CX24120_HAS_UNK2\t0x20\n#define CX24120_STATUS_MASK\t0x0f\n#define CX24120_SIGNAL_MASK\t0xc0\n\n \n#define CX24120_BER_WINDOW\t16\n#define CX24120_BER_WSIZE\t((1 << CX24120_BER_WINDOW) * 208 * 8)\n\n#define info(args...) pr_info(\"cx24120: \" args)\n#define err(args...)  pr_err(\"cx24120: ### ERROR: \" args)\n\n \nstruct cx24120_tuning {\n\tu32 frequency;\n\tu32 symbol_rate;\n\tenum fe_spectral_inversion inversion;\n\tenum fe_code_rate fec;\n\n\tenum fe_delivery_system delsys;\n\tenum fe_modulation modulation;\n\tenum fe_pilot pilot;\n\n\t \n\tu8 fec_val;\n\tu8 fec_mask;\n\tu8 clkdiv;\n\tu8 ratediv;\n\tu8 inversion_val;\n\tu8 pilot_val;\n};\n\n \nstruct cx24120_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct cx24120_config *config;\n\tstruct dvb_frontend frontend;\n\n\tu8 cold_init;\n\tu8 mpeg_enabled;\n\tu8 need_clock_set;\n\n\t \n\tstruct cx24120_tuning dcur;\n\tstruct cx24120_tuning dnxt;\n\n\tenum fe_status fe_status;\n\n\t \n\tu32 bitrate;\n\tu32 berw_usecs;\n\tu32 ber_prev;\n\tu32 ucb_offset;\n\tunsigned long ber_jiffies_stats;\n\tunsigned long per_jiffies_stats;\n};\n\n \nstruct cx24120_cmd {\n\tu8 id;\n\tu8 len;\n\tu8 arg[CX24120_MAX_CMD_LEN];\n};\n\n \nstatic int cx24120_readreg(struct cx24120_state *state, u8 reg)\n{\n\tint ret;\n\tu8 buf = 0;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = state->config->i2c_addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &reg\n\t\t}, {\n\t\t\t.addr = state->config->i2c_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = &buf\n\t\t}\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\tif (ret != 2) {\n\t\terr(\"Read error: reg=0x%02x, ret=%i)\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&state->i2c->dev, \"reg=0x%02x; data=0x%02x\\n\", reg, buf);\n\n\treturn buf;\n}\n\n \nstatic int cx24120_writereg(struct cx24120_state *state, u8 reg, u8 data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = {\n\t\t.addr = state->config->i2c_addr,\n\t\t.flags = 0,\n\t\t.buf = buf,\n\t\t.len = 2\n\t};\n\tint ret;\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\tif (ret != 1) {\n\t\terr(\"Write error: i2c_write error(err == %i, 0x%02x: 0x%02x)\\n\",\n\t\t    ret, reg, data);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&state->i2c->dev, \"reg=0x%02x; data=0x%02x\\n\", reg, data);\n\n\treturn 0;\n}\n\n \nstatic int cx24120_writeregs(struct cx24120_state *state,\n\t\t\t     u8 reg, const u8 *values, u16 len, u8 incr)\n{\n\tint ret;\n\tu16 max = state->config->i2c_wr_max > 0 ?\n\t\t\t\tstate->config->i2c_wr_max :\n\t\t\t\tlen;\n\n\tstruct i2c_msg msg = {\n\t\t.addr = state->config->i2c_addr,\n\t\t.flags = 0,\n\t};\n\n\tmsg.buf = kmalloc(max + 1, GFP_KERNEL);\n\tif (!msg.buf)\n\t\treturn -ENOMEM;\n\n\twhile (len) {\n\t\tmsg.buf[0] = reg;\n\t\tmsg.len = len > max ? max : len;\n\t\tmemcpy(&msg.buf[1], values, msg.len);\n\n\t\tlen    -= msg.len;       \n\t\tvalues += msg.len;       \n\n\t\tif (incr)\n\t\t\treg += msg.len;\n\t\tmsg.len++;               \n\n\t\tret = i2c_transfer(state->i2c, &msg, 1);\n\t\tif (ret != 1) {\n\t\t\terr(\"i2c_write error(err == %i, 0x%02x)\\n\", ret, reg);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdev_dbg(&state->i2c->dev, \"reg=0x%02x; data=%*ph\\n\",\n\t\t\treg, msg.len - 1, msg.buf + 1);\n\t}\n\n\tret = 0;\n\nout:\n\tkfree(msg.buf);\n\treturn ret;\n}\n\nstatic const struct dvb_frontend_ops cx24120_ops;\n\nstruct dvb_frontend *cx24120_attach(const struct cx24120_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct cx24120_state *state;\n\tint demod_rev;\n\n\tinfo(\"Conexant cx24120/cx24118 - DVBS/S2 Satellite demod/tuner\\n\");\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state) {\n\t\terr(\"Unable to allocate memory for cx24120_state\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t \n\tdemod_rev = cx24120_readreg(state, CX24120_REG_REVISION);\n\tswitch (demod_rev) {\n\tcase 0x07:\n\t\tinfo(\"Demod cx24120 rev. 0x07 detected.\\n\");\n\t\tbreak;\n\tcase 0x05:\n\t\tinfo(\"Demod cx24120 rev. 0x05 detected.\\n\");\n\t\tbreak;\n\tdefault:\n\t\terr(\"Unsupported demod revision: 0x%x detected.\\n\", demod_rev);\n\t\tgoto error;\n\t}\n\n\t \n\tstate->cold_init = 0;\n\tmemcpy(&state->frontend.ops, &cx24120_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\tinfo(\"Conexant cx24120/cx24118 attached.\\n\");\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cx24120_attach);\n\nstatic int cx24120_test_rom(struct cx24120_state *state)\n{\n\tint err, ret;\n\n\terr = cx24120_readreg(state, 0xfd);\n\tif (err & 4) {\n\t\tret = cx24120_readreg(state, 0xdf) & 0xfe;\n\t\terr = cx24120_writereg(state, 0xdf, ret);\n\t}\n\treturn err;\n}\n\nstatic int cx24120_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->cnr.stat[0].scale != FE_SCALE_DECIBEL)\n\t\t*snr = 0;\n\telse\n\t\t*snr = div_s64(c->cnr.stat[0].svalue, 100);\n\n\treturn 0;\n}\n\nstatic int cx24120_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->post_bit_error.stat[0].scale != FE_SCALE_COUNTER) {\n\t\t*ber = 0;\n\t\treturn 0;\n\t}\n\n\t*ber = c->post_bit_error.stat[0].uvalue - state->ber_prev;\n\tstate->ber_prev = c->post_bit_error.stat[0].uvalue;\n\n\treturn 0;\n}\n\nstatic int cx24120_msg_mpeg_output_global_config(struct cx24120_state *state,\n\t\t\t\t\t\t u8 flag);\n\n \nstatic void cx24120_check_cmd(struct cx24120_state *state, u8 id)\n{\n\tswitch (id) {\n\tcase CMD_TUNEREQUEST:\n\tcase CMD_CLOCK_READ:\n\tcase CMD_DISEQC_MSG1:\n\tcase CMD_DISEQC_MSG2:\n\tcase CMD_SETVOLTAGE:\n\tcase CMD_SETTONE:\n\tcase CMD_DISEQC_BURST:\n\t\tcx24120_msg_mpeg_output_global_config(state, 0);\n\t\t \n\t\treturn;\n\tdefault:\n\t\treturn;\n\t}\n}\n\n \nstatic int cx24120_message_send(struct cx24120_state *state,\n\t\t\t\tstruct cx24120_cmd *cmd)\n{\n\tint ficus;\n\n\tif (state->mpeg_enabled) {\n\t\t \n\t\tcx24120_check_cmd(state, cmd->id);\n\t}\n\n\tcx24120_writereg(state, CX24120_REG_CMD_START, cmd->id);\n\tcx24120_writeregs(state, CX24120_REG_CMD_ARGS, &cmd->arg[0],\n\t\t\t  cmd->len, 1);\n\tcx24120_writereg(state, CX24120_REG_CMD_END, 0x01);\n\n\tficus = 1000;\n\twhile (cx24120_readreg(state, CX24120_REG_CMD_END)) {\n\t\tmsleep(20);\n\t\tficus -= 20;\n\t\tif (ficus == 0) {\n\t\t\terr(\"Error sending message to firmware\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\tdev_dbg(&state->i2c->dev, \"sent message 0x%02x\\n\", cmd->id);\n\n\treturn 0;\n}\n\n \nstatic int cx24120_message_sendrcv(struct cx24120_state *state,\n\t\t\t\t   struct cx24120_cmd *cmd, u8 numreg)\n{\n\tint ret, i;\n\n\tif (numreg > CX24120_MAX_CMD_LEN) {\n\t\terr(\"Too many registers to read. cmd->reg = %d\", numreg);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tret = cx24120_message_send(state, cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (!numreg)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < numreg; i++)\n\t\tcmd->arg[i] = cx24120_readreg(state, (cmd->len + i + 1));\n\n\treturn 0;\n}\n\nstatic int cx24120_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t\tu16 *signal_strength)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->strength.stat[0].scale != FE_SCALE_RELATIVE)\n\t\t*signal_strength = 0;\n\telse\n\t\t*signal_strength = c->strength.stat[0].uvalue;\n\n\treturn 0;\n}\n\nstatic int cx24120_msg_mpeg_output_global_config(struct cx24120_state *state,\n\t\t\t\t\t\t u8 enable)\n{\n\tstruct cx24120_cmd cmd;\n\tint ret;\n\n\tcmd.id = CMD_MPEG_ONOFF;\n\tcmd.len = 4;\n\tcmd.arg[0] = 0x01;\n\tcmd.arg[1] = 0x00;\n\tcmd.arg[2] = enable ? 0 : (u8)(-1);\n\tcmd.arg[3] = 0x01;\n\n\tret = cx24120_message_send(state, &cmd);\n\tif (ret != 0) {\n\t\tdev_dbg(&state->i2c->dev, \"failed to %s MPEG output\\n\",\n\t\t\tenable ? \"enable\" : \"disable\");\n\t\treturn ret;\n\t}\n\n\tstate->mpeg_enabled = enable;\n\tdev_dbg(&state->i2c->dev, \"MPEG output %s\\n\",\n\t\tenable ? \"enabled\" : \"disabled\");\n\n\treturn 0;\n}\n\nstatic int cx24120_msg_mpeg_output_config(struct cx24120_state *state, u8 seq)\n{\n\tstruct cx24120_cmd cmd;\n\tstruct cx24120_initial_mpeg_config i =\n\t\t\tstate->config->initial_mpeg_config;\n\n\tcmd.id = CMD_MPEG_INIT;\n\tcmd.len = 7;\n\tcmd.arg[0] = seq;  \n\tcmd.arg[1] = ((i.x1 & 0x01) << 1) | ((i.x1 >> 1) & 0x01);\n\tcmd.arg[2] = 0x05;\n\tcmd.arg[3] = 0x02;\n\tcmd.arg[4] = ((i.x2 >> 1) & 0x01);\n\tcmd.arg[5] = (i.x2 & 0xf0) | (i.x3 & 0x0f);\n\tcmd.arg[6] = 0x10;\n\n\treturn cx24120_message_send(state, &cmd);\n}\n\nstatic int cx24120_diseqc_send_burst(struct dvb_frontend *fe,\n\t\t\t\t     enum fe_sec_mini_cmd burst)\n{\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tstruct cx24120_cmd cmd;\n\n\tdev_dbg(&state->i2c->dev, \"\\n\");\n\n\t \n\tcmd.id = CMD_DISEQC_BURST;\n\tcmd.len = 0;\n\tcmd.arg[0] = 0x00;\n\tcmd.arg[1] = (burst == SEC_MINI_B) ? 0x01 : 0x00;\n\n\treturn cx24120_message_send(state, &cmd);\n}\n\nstatic int cx24120_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\n{\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tstruct cx24120_cmd cmd;\n\n\tdev_dbg(&state->i2c->dev, \"(%d)\\n\", tone);\n\n\tif ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {\n\t\terr(\"Invalid tone=%d\\n\", tone);\n\t\treturn -EINVAL;\n\t}\n\n\tcmd.id = CMD_SETTONE;\n\tcmd.len = 4;\n\tcmd.arg[0] = 0x00;\n\tcmd.arg[1] = 0x00;\n\tcmd.arg[2] = 0x00;\n\tcmd.arg[3] = (tone == SEC_TONE_ON) ? 0x01 : 0x00;\n\n\treturn cx24120_message_send(state, &cmd);\n}\n\nstatic int cx24120_set_voltage(struct dvb_frontend *fe,\n\t\t\t       enum fe_sec_voltage voltage)\n{\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tstruct cx24120_cmd cmd;\n\n\tdev_dbg(&state->i2c->dev, \"(%d)\\n\", voltage);\n\n\tcmd.id = CMD_SETVOLTAGE;\n\tcmd.len = 2;\n\tcmd.arg[0] = 0x00;\n\tcmd.arg[1] = (voltage == SEC_VOLTAGE_18) ? 0x01 : 0x00;\n\n\treturn cx24120_message_send(state, &cmd);\n}\n\nstatic int cx24120_send_diseqc_msg(struct dvb_frontend *fe,\n\t\t\t\t   struct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tstruct cx24120_cmd cmd;\n\tint back_count;\n\n\tdev_dbg(&state->i2c->dev, \"\\n\");\n\n\tcmd.id = CMD_DISEQC_MSG1;\n\tcmd.len = 11;\n\tcmd.arg[0] = 0x00;\n\tcmd.arg[1] = 0x00;\n\tcmd.arg[2] = 0x03;\n\tcmd.arg[3] = 0x16;\n\tcmd.arg[4] = 0x28;\n\tcmd.arg[5] = 0x01;\n\tcmd.arg[6] = 0x01;\n\tcmd.arg[7] = 0x14;\n\tcmd.arg[8] = 0x19;\n\tcmd.arg[9] = 0x14;\n\tcmd.arg[10] = 0x1e;\n\n\tif (cx24120_message_send(state, &cmd)) {\n\t\terr(\"send 1st message(0x%x) failed\\n\", cmd.id);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tcmd.id = CMD_DISEQC_MSG2;\n\tcmd.len = d->msg_len + 6;\n\tcmd.arg[0] = 0x00;\n\tcmd.arg[1] = 0x01;\n\tcmd.arg[2] = 0x02;\n\tcmd.arg[3] = 0x00;\n\tcmd.arg[4] = 0x00;\n\tcmd.arg[5] = d->msg_len;\n\n\tmemcpy(&cmd.arg[6], &d->msg, d->msg_len);\n\n\tif (cx24120_message_send(state, &cmd)) {\n\t\terr(\"send 2nd message(0x%x) failed\\n\", cmd.id);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tback_count = 500;\n\tdo {\n\t\tif (!(cx24120_readreg(state, 0x93) & 0x01)) {\n\t\t\tdev_dbg(&state->i2c->dev, \"diseqc sequence sent\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tmsleep(20);\n\t\tback_count -= 20;\n\t} while (back_count);\n\n\terr(\"Too long waiting for diseqc.\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic void cx24120_get_stats(struct cx24120_state *state)\n{\n\tstruct dvb_frontend *fe = &state->frontend;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct cx24120_cmd cmd;\n\tint ret, cnr, msecs;\n\tu16 sig, ucb;\n\tu32 ber;\n\n\tdev_dbg(&state->i2c->dev, \"\\n\");\n\n\t \n\tif (state->fe_status & FE_HAS_SIGNAL) {\n\t\tcmd.id = CMD_READ_SNR;\n\t\tcmd.len = 1;\n\t\tcmd.arg[0] = 0x00;\n\n\t\tret = cx24120_message_send(state, &cmd);\n\t\tif (ret != 0) {\n\t\t\terr(\"error reading signal strength\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tsig = cx24120_readreg(state, CX24120_REG_SIGSTR_H) >> 6;\n\t\tsig = sig << 8;\n\t\tsig |= cx24120_readreg(state, CX24120_REG_SIGSTR_L);\n\t\tdev_dbg(&state->i2c->dev,\n\t\t\t\"signal strength from firmware = 0x%x\\n\", sig);\n\n\t\t \n\t\tsig = -100 * sig + 94324;\n\n\t\tc->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\t\tc->strength.stat[0].uvalue = sig;\n\t} else {\n\t\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (state->fe_status & FE_HAS_VITERBI) {\n\t\tcnr = cx24120_readreg(state, CX24120_REG_QUALITY_H) << 8;\n\t\tcnr |= cx24120_readreg(state, CX24120_REG_QUALITY_L);\n\t\tdev_dbg(&state->i2c->dev, \"read SNR index = %d\\n\", cnr);\n\n\t\t \n\t\tcnr = cnr * 100;\n\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[0].svalue = cnr;\n\t} else {\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (!(state->fe_status & FE_HAS_LOCK)) {\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn;\n\t}\n\n\t \n\tif (time_after(jiffies, state->ber_jiffies_stats)) {\n\t\tmsecs = (state->berw_usecs + 500) / 1000;\n\t\tstate->ber_jiffies_stats = jiffies + msecs_to_jiffies(msecs);\n\n\t\tber = cx24120_readreg(state, CX24120_REG_BER_HH) << 24;\n\t\tber |= cx24120_readreg(state, CX24120_REG_BER_HL) << 16;\n\t\tber |= cx24120_readreg(state, CX24120_REG_BER_LH) << 8;\n\t\tber |= cx24120_readreg(state, CX24120_REG_BER_LL);\n\t\tdev_dbg(&state->i2c->dev, \"read BER index = %d\\n\", ber);\n\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[0].uvalue += ber;\n\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[0].uvalue += CX24120_BER_WSIZE;\n\t}\n\n\t \n\tif (time_after(jiffies, state->per_jiffies_stats)) {\n\t\tstate->per_jiffies_stats = jiffies + msecs_to_jiffies(1000);\n\n\t\tucb = cx24120_readreg(state, CX24120_REG_UCB_H) << 8;\n\t\tucb |= cx24120_readreg(state, CX24120_REG_UCB_L);\n\t\tdev_dbg(&state->i2c->dev, \"ucblocks = %d\\n\", ucb);\n\n\t\t \n\t\tif (ucb < state->ucb_offset)\n\t\t\tstate->ucb_offset = c->block_error.stat[0].uvalue;\n\n\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_error.stat[0].uvalue = ucb + state->ucb_offset;\n\n\t\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_count.stat[0].uvalue += state->bitrate / 8 / 208;\n\t}\n}\n\nstatic void cx24120_set_clock_ratios(struct dvb_frontend *fe);\n\n \nstatic int cx24120_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tint lock;\n\n\tlock = cx24120_readreg(state, CX24120_REG_STATUS);\n\n\tdev_dbg(&state->i2c->dev, \"status = 0x%02x\\n\", lock);\n\n\t*status = 0;\n\n\tif (lock & CX24120_HAS_SIGNAL)\n\t\t*status = FE_HAS_SIGNAL;\n\tif (lock & CX24120_HAS_CARRIER)\n\t\t*status |= FE_HAS_CARRIER;\n\tif (lock & CX24120_HAS_VITERBI)\n\t\t*status |= FE_HAS_VITERBI | FE_HAS_SYNC;\n\tif (lock & CX24120_HAS_LOCK)\n\t\t*status |= FE_HAS_LOCK;\n\n\t \n\n\tstate->fe_status = *status;\n\tcx24120_get_stats(state);\n\n\t \n\tif (state->need_clock_set && *status & FE_HAS_LOCK) {\n\t\t \n\t\tcx24120_set_clock_ratios(fe);\n\n\t\t \n\n\t\t \n\t\tif (!state->mpeg_enabled)\n\t\t\tcx24120_msg_mpeg_output_global_config(state, 1);\n\n\t\tstate->need_clock_set = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstruct cx24120_modfec {\n\tenum fe_delivery_system delsys;\n\tenum fe_modulation mod;\n\tenum fe_code_rate fec;\n\tu8 val;\n};\n\nstatic const struct cx24120_modfec modfec_lookup_table[] = {\n\t \n\t{ SYS_DVBS,  QPSK,  FEC_1_2,  0x01 },\n\t{ SYS_DVBS,  QPSK,  FEC_2_3,  0x02 },\n\t{ SYS_DVBS,  QPSK,  FEC_3_4,  0x03 },\n\t{ SYS_DVBS,  QPSK,  FEC_4_5,  0x04 },\n\t{ SYS_DVBS,  QPSK,  FEC_5_6,  0x05 },\n\t{ SYS_DVBS,  QPSK,  FEC_6_7,  0x06 },\n\t{ SYS_DVBS,  QPSK,  FEC_7_8,  0x07 },\n\n\t{ SYS_DVBS2, QPSK,  FEC_1_2,  0x04 },\n\t{ SYS_DVBS2, QPSK,  FEC_3_5,  0x05 },\n\t{ SYS_DVBS2, QPSK,  FEC_2_3,  0x06 },\n\t{ SYS_DVBS2, QPSK,  FEC_3_4,  0x07 },\n\t{ SYS_DVBS2, QPSK,  FEC_4_5,  0x08 },\n\t{ SYS_DVBS2, QPSK,  FEC_5_6,  0x09 },\n\t{ SYS_DVBS2, QPSK,  FEC_8_9,  0x0a },\n\t{ SYS_DVBS2, QPSK,  FEC_9_10, 0x0b },\n\n\t{ SYS_DVBS2, PSK_8, FEC_3_5,  0x0c },\n\t{ SYS_DVBS2, PSK_8, FEC_2_3,  0x0d },\n\t{ SYS_DVBS2, PSK_8, FEC_3_4,  0x0e },\n\t{ SYS_DVBS2, PSK_8, FEC_5_6,  0x0f },\n\t{ SYS_DVBS2, PSK_8, FEC_8_9,  0x10 },\n\t{ SYS_DVBS2, PSK_8, FEC_9_10, 0x11 },\n};\n\n \nstatic int cx24120_get_fec(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tint idx;\n\tint ret;\n\tint fec;\n\n\tret = cx24120_readreg(state, CX24120_REG_FECMODE);\n\tfec = ret & 0x3f;  \n\n\tdev_dbg(&state->i2c->dev, \"raw fec = %d\\n\", fec);\n\n\tfor (idx = 0; idx < ARRAY_SIZE(modfec_lookup_table); idx++) {\n\t\tif (modfec_lookup_table[idx].delsys != state->dcur.delsys)\n\t\t\tcontinue;\n\t\tif (modfec_lookup_table[idx].val != fec)\n\t\t\tcontinue;\n\n\t\tbreak;  \n\t}\n\n\tif (idx >= ARRAY_SIZE(modfec_lookup_table)) {\n\t\tdev_dbg(&state->i2c->dev, \"couldn't find fec!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tc->modulation = modfec_lookup_table[idx].mod;\n\tc->fec_inner = modfec_lookup_table[idx].fec;\n\tc->pilot = (ret & 0x80) ? PILOT_ON : PILOT_OFF;\n\n\tdev_dbg(&state->i2c->dev, \"mod(%d), fec(%d), pilot(%d)\\n\",\n\t\tc->modulation, c->fec_inner, c->pilot);\n\n\treturn 0;\n}\n\n \nstatic void cx24120_calculate_ber_window(struct cx24120_state *state, u32 rate)\n{\n\tstruct dvb_frontend *fe = &state->frontend;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu64 tmp;\n\n\t \n\ttmp = (u64)c->symbol_rate * rate;\n\tdo_div(tmp, 256);\n\tstate->bitrate = tmp;\n\n\t \n\ttmp = 1000000ULL * CX24120_BER_WSIZE;\n\tdo_div(tmp, state->bitrate);\n\tstate->berw_usecs = tmp;\n\n\tdev_dbg(&state->i2c->dev, \"bitrate: %u, berw_usecs: %u\\n\",\n\t\tstate->bitrate, state->berw_usecs);\n}\n\n \nstruct cx24120_clock_ratios_table {\n\tenum fe_delivery_system delsys;\n\tenum fe_pilot pilot;\n\tenum fe_modulation mod;\n\tenum fe_code_rate fec;\n\tu32 m_rat;\n\tu32 n_rat;\n\tu32 rate;\n};\n\nstatic const struct cx24120_clock_ratios_table clock_ratios_table[] = {\n\t \n\t{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_1_2,  273088,  254505, 274 },\n\t{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_3_5,  17272,   13395,  330 },\n\t{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_2_3,  24344,   16967,  367 },\n\t{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_3_4,  410788,  254505, 413 },\n\t{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_4_5,  438328,  254505, 440 },\n\t{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_5_6,  30464,   16967,  459 },\n\t{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_8_9,  487832,  254505, 490 },\n\t{ SYS_DVBS2, PILOT_OFF, QPSK,  FEC_9_10, 493952,  254505, 496 },\n\t{ SYS_DVBS2, PILOT_OFF, PSK_8, FEC_3_5,  328168,  169905, 494 },\n\t{ SYS_DVBS2, PILOT_OFF, PSK_8, FEC_2_3,  24344,   11327,  550 },\n\t{ SYS_DVBS2, PILOT_OFF, PSK_8, FEC_3_4,  410788,  169905, 618 },\n\t{ SYS_DVBS2, PILOT_OFF, PSK_8, FEC_5_6,  30464,   11327,  688 },\n\t{ SYS_DVBS2, PILOT_OFF, PSK_8, FEC_8_9,  487832,  169905, 735 },\n\t{ SYS_DVBS2, PILOT_OFF, PSK_8, FEC_9_10, 493952,  169905, 744 },\n\t{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_1_2,  273088,  260709, 268 },\n\t{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_3_5,  328168,  260709, 322 },\n\t{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_2_3,  121720,  86903,  358 },\n\t{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_3_4,  410788,  260709, 403 },\n\t{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_4_5,  438328,  260709, 430 },\n\t{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_5_6,  152320,  86903,  448 },\n\t{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_8_9,  487832,  260709, 479 },\n\t{ SYS_DVBS2, PILOT_ON,  QPSK,  FEC_9_10, 493952,  260709, 485 },\n\t{ SYS_DVBS2, PILOT_ON,  PSK_8, FEC_3_5,  328168,  173853, 483 },\n\t{ SYS_DVBS2, PILOT_ON,  PSK_8, FEC_2_3,  121720,  57951,  537 },\n\t{ SYS_DVBS2, PILOT_ON,  PSK_8, FEC_3_4,  410788,  173853, 604 },\n\t{ SYS_DVBS2, PILOT_ON,  PSK_8, FEC_5_6,  152320,  57951,  672 },\n\t{ SYS_DVBS2, PILOT_ON,  PSK_8, FEC_8_9,  487832,  173853, 718 },\n\t{ SYS_DVBS2, PILOT_ON,  PSK_8, FEC_9_10, 493952,  173853, 727 },\n\t{ SYS_DVBS,  PILOT_OFF, QPSK,  FEC_1_2,  152592,  152592, 256 },\n\t{ SYS_DVBS,  PILOT_OFF, QPSK,  FEC_2_3,  305184,  228888, 341 },\n\t{ SYS_DVBS,  PILOT_OFF, QPSK,  FEC_3_4,  457776,  305184, 384 },\n\t{ SYS_DVBS,  PILOT_OFF, QPSK,  FEC_5_6,  762960,  457776, 427 },\n\t{ SYS_DVBS,  PILOT_OFF, QPSK,  FEC_7_8,  1068144, 610368, 448 },\n};\n\n \nstatic void cx24120_set_clock_ratios(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tstruct cx24120_cmd cmd;\n\tint ret, idx;\n\n\t \n\tret = cx24120_get_fec(fe);\n\tif (ret != 0)\n\t\treturn;\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(clock_ratios_table); idx++) {\n\t\tif (clock_ratios_table[idx].delsys != state->dcur.delsys)\n\t\t\tcontinue;\n\t\tif (clock_ratios_table[idx].mod != c->modulation)\n\t\t\tcontinue;\n\t\tif (clock_ratios_table[idx].fec != c->fec_inner)\n\t\t\tcontinue;\n\t\tif (clock_ratios_table[idx].pilot != c->pilot)\n\t\t\tcontinue;\n\n\t\tbreak;\t\t \n\t}\n\n\tif (idx >= ARRAY_SIZE(clock_ratios_table)) {\n\t\tinfo(\"Clock ratio not found - data reception in danger\\n\");\n\t\treturn;\n\t}\n\n\t \n\tcmd.id = CMD_CLOCK_READ;\n\tcmd.len = 1;\n\tcmd.arg[0] = 0x00;\n\tret = cx24120_message_sendrcv(state, &cmd, 6);\n\tif (ret != 0)\n\t\treturn;\n\t \n\n\tdev_dbg(&state->i2c->dev, \"m=%d, n=%d; idx: %d m=%d, n=%d, rate=%d\\n\",\n\t\tcmd.arg[2] | (cmd.arg[1] << 8) | (cmd.arg[0] << 16),\n\t\tcmd.arg[5] | (cmd.arg[4] << 8) | (cmd.arg[3] << 16),\n\t\tidx,\n\t\tclock_ratios_table[idx].m_rat,\n\t\tclock_ratios_table[idx].n_rat,\n\t\tclock_ratios_table[idx].rate);\n\n\t \n\tcmd.id = CMD_CLOCK_SET;\n\tcmd.len = 10;\n\tcmd.arg[0] = 0;\n\tcmd.arg[1] = 0x10;\n\tcmd.arg[2] = (clock_ratios_table[idx].m_rat >> 16) & 0xff;\n\tcmd.arg[3] = (clock_ratios_table[idx].m_rat >>  8) & 0xff;\n\tcmd.arg[4] = (clock_ratios_table[idx].m_rat >>  0) & 0xff;\n\tcmd.arg[5] = (clock_ratios_table[idx].n_rat >> 16) & 0xff;\n\tcmd.arg[6] = (clock_ratios_table[idx].n_rat >>  8) & 0xff;\n\tcmd.arg[7] = (clock_ratios_table[idx].n_rat >>  0) & 0xff;\n\tcmd.arg[8] = (clock_ratios_table[idx].rate >> 8) & 0xff;\n\tcmd.arg[9] = (clock_ratios_table[idx].rate >> 0) & 0xff;\n\n\tret = cx24120_message_send(state, &cmd);\n\tif (ret != 0)\n\t\treturn;\n\n\t \n\tcx24120_calculate_ber_window(state, clock_ratios_table[idx].rate);\n}\n\n \nstatic int cx24120_set_inversion(struct cx24120_state *state,\n\t\t\t\t enum fe_spectral_inversion inversion)\n{\n\tdev_dbg(&state->i2c->dev, \"(%d)\\n\", inversion);\n\n\tswitch (inversion) {\n\tcase INVERSION_OFF:\n\t\tstate->dnxt.inversion_val = 0x00;\n\t\tbreak;\n\tcase INVERSION_ON:\n\t\tstate->dnxt.inversion_val = 0x04;\n\t\tbreak;\n\tcase INVERSION_AUTO:\n\t\tstate->dnxt.inversion_val = 0x0c;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstate->dnxt.inversion = inversion;\n\n\treturn 0;\n}\n\n \nstruct cx24120_modfec_table {\n\tenum fe_delivery_system delsys;\n\tenum fe_modulation mod;\n\tenum fe_code_rate fec;\n\tu8 val;\n};\n\nstatic const struct cx24120_modfec_table modfec_table[] = {\n\t \n\t{ SYS_DVBS,  QPSK,  FEC_1_2,  0x2e },\n\t{ SYS_DVBS,  QPSK,  FEC_2_3,  0x2f },\n\t{ SYS_DVBS,  QPSK,  FEC_3_4,  0x30 },\n\t{ SYS_DVBS,  QPSK,  FEC_5_6,  0x31 },\n\t{ SYS_DVBS,  QPSK,  FEC_6_7,  0x32 },\n\t{ SYS_DVBS,  QPSK,  FEC_7_8,  0x33 },\n\n\t{ SYS_DVBS2, QPSK,  FEC_1_2,  0x04 },\n\t{ SYS_DVBS2, QPSK,  FEC_3_5,  0x05 },\n\t{ SYS_DVBS2, QPSK,  FEC_2_3,  0x06 },\n\t{ SYS_DVBS2, QPSK,  FEC_3_4,  0x07 },\n\t{ SYS_DVBS2, QPSK,  FEC_4_5,  0x08 },\n\t{ SYS_DVBS2, QPSK,  FEC_5_6,  0x09 },\n\t{ SYS_DVBS2, QPSK,  FEC_8_9,  0x0a },\n\t{ SYS_DVBS2, QPSK,  FEC_9_10, 0x0b },\n\n\t{ SYS_DVBS2, PSK_8, FEC_3_5,  0x0c },\n\t{ SYS_DVBS2, PSK_8, FEC_2_3,  0x0d },\n\t{ SYS_DVBS2, PSK_8, FEC_3_4,  0x0e },\n\t{ SYS_DVBS2, PSK_8, FEC_5_6,  0x0f },\n\t{ SYS_DVBS2, PSK_8, FEC_8_9,  0x10 },\n\t{ SYS_DVBS2, PSK_8, FEC_9_10, 0x11 },\n};\n\n \nstatic int cx24120_set_fec(struct cx24120_state *state, enum fe_modulation mod,\n\t\t\t   enum fe_code_rate fec)\n{\n\tint idx;\n\n\tdev_dbg(&state->i2c->dev, \"(0x%02x,0x%02x)\\n\", mod, fec);\n\n\tstate->dnxt.fec = fec;\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(modfec_table); idx++) {\n\t\tif (modfec_table[idx].delsys != state->dnxt.delsys)\n\t\t\tcontinue;\n\t\tif (modfec_table[idx].mod != mod)\n\t\t\tcontinue;\n\t\tif (modfec_table[idx].fec != fec)\n\t\t\tcontinue;\n\n\t\t \n\t\tstate->dnxt.fec_mask = 0x00;\n\t\tstate->dnxt.fec_val = modfec_table[idx].val;\n\t\treturn 0;\n\t}\n\n\tif (state->dnxt.delsys == SYS_DVBS2) {\n\t\t \n\t\tstate->dnxt.fec_mask = 0x00;\n\t\tstate->dnxt.fec_val  = 0x00;\n\t} else {\n\t\t \n\t\tstate->dnxt.fec_val  = 0x2e;\n\t\tstate->dnxt.fec_mask = 0xac;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cx24120_set_pilot(struct cx24120_state *state, enum fe_pilot pilot)\n{\n\tdev_dbg(&state->i2c->dev, \"(%d)\\n\", pilot);\n\n\t \n\tif (state->dnxt.delsys != SYS_DVBS2) {\n\t\tstate->dnxt.pilot_val = CX24120_PILOT_OFF;\n\t\treturn 0;\n\t}\n\n\tswitch (pilot) {\n\tcase PILOT_OFF:\n\t\tstate->dnxt.pilot_val = CX24120_PILOT_OFF;\n\t\tbreak;\n\tcase PILOT_ON:\n\t\tstate->dnxt.pilot_val = CX24120_PILOT_ON;\n\t\tbreak;\n\tcase PILOT_AUTO:\n\tdefault:\n\t\tstate->dnxt.pilot_val = CX24120_PILOT_AUTO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cx24120_set_symbolrate(struct cx24120_state *state, u32 rate)\n{\n\tdev_dbg(&state->i2c->dev, \"(%d)\\n\", rate);\n\n\tstate->dnxt.symbol_rate = rate;\n\n\t \n\tif (rate  > 31000000) {\n\t\tstate->dnxt.clkdiv  = (-(rate < 31000001) & 3) + 2;\n\t\tstate->dnxt.ratediv = (-(rate < 31000001) & 6) + 4;\n\t} else {\n\t\tstate->dnxt.clkdiv  = 3;\n\t\tstate->dnxt.ratediv = 6;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void cx24120_clone_params(struct dvb_frontend *fe)\n{\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\n\tstate->dcur = state->dnxt;\n}\n\nstatic int cx24120_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tstruct cx24120_cmd cmd;\n\tint ret;\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS2:\n\t\tdev_dbg(&state->i2c->dev, \"DVB-S2\\n\");\n\t\tbreak;\n\tcase SYS_DVBS:\n\t\tdev_dbg(&state->i2c->dev, \"DVB-S\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&state->i2c->dev,\n\t\t\t\"delivery system(%d) not supported\\n\",\n\t\t\tc->delivery_system);\n\t\treturn -EINVAL;\n\t}\n\n\tstate->dnxt.delsys = c->delivery_system;\n\tstate->dnxt.modulation = c->modulation;\n\tstate->dnxt.frequency = c->frequency;\n\tstate->dnxt.pilot = c->pilot;\n\n\tret = cx24120_set_inversion(state, c->inversion);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\tret = cx24120_set_fec(state, c->modulation, c->fec_inner);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\tret = cx24120_set_pilot(state, c->pilot);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = cx24120_set_symbolrate(state, c->symbol_rate);\n\tif (ret !=  0)\n\t\treturn ret;\n\n\t \n\tcx24120_clone_params(fe);\n\n\tdev_dbg(&state->i2c->dev,\n\t\t\"delsys      = %d\\n\", state->dcur.delsys);\n\tdev_dbg(&state->i2c->dev,\n\t\t\"modulation  = %d\\n\", state->dcur.modulation);\n\tdev_dbg(&state->i2c->dev,\n\t\t\"frequency   = %d\\n\", state->dcur.frequency);\n\tdev_dbg(&state->i2c->dev,\n\t\t\"pilot       = %d (val = 0x%02x)\\n\",\n\t\tstate->dcur.pilot, state->dcur.pilot_val);\n\tdev_dbg(&state->i2c->dev,\n\t\t\"symbol_rate = %d (clkdiv/ratediv = 0x%02x/0x%02x)\\n\",\n\t\t state->dcur.symbol_rate,\n\t\t state->dcur.clkdiv, state->dcur.ratediv);\n\tdev_dbg(&state->i2c->dev,\n\t\t\"FEC         = %d (mask/val = 0x%02x/0x%02x)\\n\",\n\t\tstate->dcur.fec, state->dcur.fec_mask, state->dcur.fec_val);\n\tdev_dbg(&state->i2c->dev,\n\t\t\"Inversion   = %d (val = 0x%02x)\\n\",\n\t\tstate->dcur.inversion, state->dcur.inversion_val);\n\n\t \n\tstate->need_clock_set = 1;\n\n\t \n\tcmd.id = CMD_TUNEREQUEST;\n\tcmd.len = 15;\n\tcmd.arg[0] = 0;\n\tcmd.arg[1]  = (state->dcur.frequency & 0xff0000) >> 16;\n\tcmd.arg[2]  = (state->dcur.frequency & 0x00ff00) >> 8;\n\tcmd.arg[3]  = (state->dcur.frequency & 0x0000ff);\n\tcmd.arg[4]  = ((state->dcur.symbol_rate / 1000) & 0xff00) >> 8;\n\tcmd.arg[5]  = ((state->dcur.symbol_rate / 1000) & 0x00ff);\n\tcmd.arg[6]  = state->dcur.inversion;\n\tcmd.arg[7]  = state->dcur.fec_val | state->dcur.pilot_val;\n\tcmd.arg[8]  = CX24120_SEARCH_RANGE_KHZ >> 8;\n\tcmd.arg[9]  = CX24120_SEARCH_RANGE_KHZ & 0xff;\n\tcmd.arg[10] = 0;\t\t \n\tcmd.arg[11] = state->dcur.fec_mask;\n\tcmd.arg[12] = state->dcur.ratediv;\n\tcmd.arg[13] = state->dcur.clkdiv;\n\tcmd.arg[14] = 0;\n\n\t \n\tret = cx24120_message_send(state, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tret = cx24120_writereg(state, CX24120_REG_CLKDIV, state->dcur.clkdiv);\n\tret = cx24120_readreg(state, CX24120_REG_RATEDIV);\n\tret &= 0xfffffff0;\n\tret |= state->dcur.ratediv;\n\tret = cx24120_writereg(state, CX24120_REG_RATEDIV, ret);\n\n\treturn 0;\n}\n\n \nstatic int cx24120_set_vco(struct cx24120_state *state)\n{\n\tstruct cx24120_cmd cmd;\n\tu32 nxtal_khz, vco;\n\tu64 inv_vco;\n\tu32 xtal_khz = state->config->xtal_khz;\n\n\tnxtal_khz = xtal_khz * 4;\n\tvco = nxtal_khz * 10;\n\tinv_vco = DIV_ROUND_CLOSEST_ULL(0x400000000ULL, vco);\n\n\tdev_dbg(&state->i2c->dev, \"xtal=%d, vco=%d, inv_vco=%lld\\n\",\n\t\txtal_khz, vco, inv_vco);\n\n\tcmd.id = CMD_VCO_SET;\n\tcmd.len = 12;\n\tcmd.arg[0] = (vco >> 16) & 0xff;\n\tcmd.arg[1] = (vco >> 8) & 0xff;\n\tcmd.arg[2] = vco & 0xff;\n\tcmd.arg[3] = (inv_vco >> 8) & 0xff;\n\tcmd.arg[4] = (inv_vco) & 0xff;\n\tcmd.arg[5] = 0x03;\n\tcmd.arg[6] = (nxtal_khz >> 8) & 0xff;\n\tcmd.arg[7] = nxtal_khz & 0xff;\n\tcmd.arg[8] = 0x06;\n\tcmd.arg[9] = 0x03;\n\tcmd.arg[10] = (xtal_khz >> 16) & 0xff;\n\tcmd.arg[11] = xtal_khz & 0xff;\n\n\treturn cx24120_message_send(state, &cmd);\n}\n\nstatic int cx24120_init(struct dvb_frontend *fe)\n{\n\tconst struct firmware *fw;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tstruct cx24120_cmd cmd;\n\tu8 reg;\n\tint ret, i;\n\tunsigned char vers[4];\n\n\tif (state->cold_init)\n\t\treturn 0;\n\n\t \n\tcx24120_writereg(state, 0xea, 0x00);\n\tcx24120_test_rom(state);\n\treg = cx24120_readreg(state, 0xfb) & 0xfe;\n\tcx24120_writereg(state, 0xfb, reg);\n\treg = cx24120_readreg(state, 0xfc) & 0xfe;\n\tcx24120_writereg(state, 0xfc, reg);\n\tcx24120_writereg(state, 0xc3, 0x04);\n\tcx24120_writereg(state, 0xc4, 0x04);\n\tcx24120_writereg(state, 0xce, 0x00);\n\tcx24120_writereg(state, 0xcf, 0x00);\n\treg = cx24120_readreg(state, 0xea) & 0xfe;\n\tcx24120_writereg(state, 0xea, reg);\n\tcx24120_writereg(state, 0xeb, 0x0c);\n\tcx24120_writereg(state, 0xec, 0x06);\n\tcx24120_writereg(state, 0xed, 0x05);\n\tcx24120_writereg(state, 0xee, 0x03);\n\tcx24120_writereg(state, 0xef, 0x05);\n\tcx24120_writereg(state, 0xf3, 0x03);\n\tcx24120_writereg(state, 0xf4, 0x44);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tcx24120_writereg(state, 0xf0 + i, 0x04);\n\t\tcx24120_writereg(state, 0xe6 + i, 0x02);\n\t}\n\n\tcx24120_writereg(state, 0xea, (reg | 0x01));\n\tfor (i = 0; i < 6; i += 2) {\n\t\tcx24120_writereg(state, 0xc5 + i, 0x00);\n\t\tcx24120_writereg(state, 0xc6 + i, 0x00);\n\t}\n\n\tcx24120_writereg(state, 0xe4, 0x03);\n\tcx24120_writereg(state, 0xeb, 0x0a);\n\n\tdev_dbg(&state->i2c->dev, \"requesting firmware (%s) to download...\\n\",\n\t\tCX24120_FIRMWARE);\n\n\tret = state->config->request_firmware(fe, &fw, CX24120_FIRMWARE);\n\tif (ret) {\n\t\terr(\"Could not load firmware (%s): %d\\n\", CX24120_FIRMWARE,\n\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&state->i2c->dev,\n\t\t\"Firmware found, size %d bytes (%02x %02x .. %02x %02x)\\n\",\n\t\t(int)fw->size,\t\t\t \n\t\tfw->data[0],\t\t\t \n\t\tfw->data[1],\t\t\t \n\t\tfw->data[fw->size - 2],\t\t \n\t\tfw->data[fw->size - 1]);\t \n\n\tcx24120_test_rom(state);\n\treg = cx24120_readreg(state, 0xfb) & 0xfe;\n\tcx24120_writereg(state, 0xfb, reg);\n\tcx24120_writereg(state, 0xe0, 0x76);\n\tcx24120_writereg(state, 0xf7, 0x81);\n\tcx24120_writereg(state, 0xf8, 0x00);\n\tcx24120_writereg(state, 0xf9, 0x00);\n\tcx24120_writeregs(state, 0xfa, fw->data, (fw->size - 1), 0x00);\n\tcx24120_writereg(state, 0xf7, 0xc0);\n\tcx24120_writereg(state, 0xe0, 0x00);\n\treg = (fw->size - 2) & 0x00ff;\n\tcx24120_writereg(state, 0xf8, reg);\n\treg = ((fw->size - 2) >> 8) & 0x00ff;\n\tcx24120_writereg(state, 0xf9, reg);\n\tcx24120_writereg(state, 0xf7, 0x00);\n\tcx24120_writereg(state, 0xdc, 0x00);\n\tcx24120_writereg(state, 0xdc, 0x07);\n\tmsleep(500);\n\n\t \n\treg = cx24120_readreg(state, 0xe1);\n\tif (reg == fw->data[fw->size - 1]) {\n\t\tdev_dbg(&state->i2c->dev, \"Firmware uploaded successfully\\n\");\n\t\tret = 0;\n\t} else {\n\t\terr(\"Firmware upload failed. Last byte returned=0x%x\\n\", ret);\n\t\tret = -EREMOTEIO;\n\t}\n\tcx24120_writereg(state, 0xdc, 0x00);\n\trelease_firmware(fw);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tcmd.id = CMD_START_TUNER;\n\tcmd.len = 3;\n\tcmd.arg[0] = 0x00;\n\tcmd.arg[1] = 0x00;\n\tcmd.arg[2] = 0x00;\n\n\tif (cx24120_message_send(state, &cmd) != 0) {\n\t\terr(\"Error tuner start! :(\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\t \n\tret = cx24120_set_vco(state);\n\tif (ret != 0) {\n\t\terr(\"Error set VCO! :(\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tcmd.id = CMD_BANDWIDTH;\n\tcmd.len = 12;\n\tcmd.arg[0] = 0x00;\n\tcmd.arg[1] = 0x00;\n\tcmd.arg[2] = 0x00;\n\tcmd.arg[3] = 0x00;\n\tcmd.arg[4] = 0x05;\n\tcmd.arg[5] = 0x02;\n\tcmd.arg[6] = 0x02;\n\tcmd.arg[7] = 0x00;\n\tcmd.arg[8] = 0x05;\n\tcmd.arg[9] = 0x02;\n\tcmd.arg[10] = 0x02;\n\tcmd.arg[11] = 0x00;\n\n\tif (cx24120_message_send(state, &cmd)) {\n\t\terr(\"Error set bandwidth!\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\treg = cx24120_readreg(state, 0xba);\n\tif (reg > 3) {\n\t\tdev_dbg(&state->i2c->dev, \"Reset-readreg 0xba: %x\\n\", ret);\n\t\terr(\"Error initialising tuner!\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\tdev_dbg(&state->i2c->dev, \"Tuner initialised correctly.\\n\");\n\n\t \n\tcx24120_writereg(state, 0xeb, 0x0a);\n\tif (cx24120_msg_mpeg_output_global_config(state, 0) ||\n\t    cx24120_msg_mpeg_output_config(state, 0) ||\n\t    cx24120_msg_mpeg_output_config(state, 1) ||\n\t    cx24120_msg_mpeg_output_config(state, 2)) {\n\t\terr(\"Error initialising mpeg output. :(\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\t \n\tcmd.id = CMD_BER_CTRL;\n\tcmd.len = 3;\n\tcmd.arg[0] = 0x00;\n\tcmd.arg[1] = CX24120_BER_WINDOW;\n\tcmd.arg[2] = CX24120_BER_WINDOW;\n\tif (cx24120_message_send(state, &cmd)) {\n\t\terr(\"Error setting ber window\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\t \n\tcmd.id = CMD_FWVERSION;\n\tcmd.len = 1;\n\tfor (i = 0; i < 4; i++) {\n\t\tcmd.arg[0] = i;\n\t\tret = cx24120_message_send(state, &cmd);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tvers[i] = cx24120_readreg(state, CX24120_REG_MAILBOX);\n\t}\n\tinfo(\"FW version %i.%i.%i.%i\\n\", vers[0], vers[1], vers[2], vers[3]);\n\n\t \n\tc->strength.len = 1;\n\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->cnr.len = 1;\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.len = 1;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_error.len = 1;\n\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_count.len = 1;\n\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tstate->cold_init = 1;\n\n\treturn 0;\n}\n\nstatic int cx24120_tune(struct dvb_frontend *fe, bool re_tune,\n\t\t\tunsigned int mode_flags, unsigned int *delay,\n\t\t\tenum fe_status *status)\n{\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tdev_dbg(&state->i2c->dev, \"(%d)\\n\", re_tune);\n\n\t \n\n\tif (re_tune) {\n\t\tret = cx24120_set_frontend(fe);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn cx24120_read_status(fe, status);\n}\n\nstatic enum dvbfe_algo cx24120_get_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic int cx24120_sleep(struct dvb_frontend *fe)\n{\n\treturn 0;\n}\n\nstatic int cx24120_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *c)\n{\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tu8 freq1, freq2, freq3;\n\tint status;\n\n\tdev_dbg(&state->i2c->dev, \"\\n\");\n\n\t \n\tstatus = cx24120_readreg(state, CX24120_REG_STATUS);\n\tif (!(status & CX24120_HAS_LOCK))\n\t\treturn 0;\n\n\t \n\tfreq1 = cx24120_readreg(state, CX24120_REG_FREQ1);\n\tfreq2 = cx24120_readreg(state, CX24120_REG_FREQ2);\n\tfreq3 = cx24120_readreg(state, CX24120_REG_FREQ3);\n\tc->frequency = (freq3 << 16) | (freq2 << 8) | freq1;\n\tdev_dbg(&state->i2c->dev, \"frequency = %d\\n\", c->frequency);\n\n\t \n\tcx24120_get_fec(fe);\n\n\treturn 0;\n}\n\nstatic void cx24120_release(struct dvb_frontend *fe)\n{\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\n\tdev_dbg(&state->i2c->dev, \"Clear state structure\\n\");\n\tkfree(state);\n}\n\nstatic int cx24120_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct cx24120_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->block_error.stat[0].scale != FE_SCALE_COUNTER) {\n\t\t*ucblocks = 0;\n\t\treturn 0;\n\t}\n\n\t*ucblocks = c->block_error.stat[0].uvalue - state->ucb_offset;\n\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops cx24120_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2 },\n\t.info = {\n\t\t.name = \"Conexant CX24120/CX24118\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t\t.frequency_stepsize_hz = 1011 * kHz,\n\t\t.frequency_tolerance_hz = 5 * MHz,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.caps =\tFE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |\n\t\t\tFE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_2G_MODULATION |\n\t\t\tFE_CAN_QPSK | FE_CAN_RECOVER\n\t},\n\t.release =\t\t\tcx24120_release,\n\n\t.init =\t\t\t\tcx24120_init,\n\t.sleep =\t\t\tcx24120_sleep,\n\n\t.tune =\t\t\t\tcx24120_tune,\n\t.get_frontend_algo =\t\tcx24120_get_algo,\n\t.set_frontend =\t\t\tcx24120_set_frontend,\n\n\t.get_frontend =\t\t\tcx24120_get_frontend,\n\t.read_status =\t\t\tcx24120_read_status,\n\t.read_ber =\t\t\tcx24120_read_ber,\n\t.read_signal_strength =\t\tcx24120_read_signal_strength,\n\t.read_snr =\t\t\tcx24120_read_snr,\n\t.read_ucblocks =\t\tcx24120_read_ucblocks,\n\n\t.diseqc_send_master_cmd =\tcx24120_send_diseqc_msg,\n\n\t.diseqc_send_burst =\t\tcx24120_diseqc_send_burst,\n\t.set_tone =\t\t\tcx24120_set_tone,\n\t.set_voltage =\t\t\tcx24120_set_voltage,\n};\n\nMODULE_DESCRIPTION(\"DVB Frontend module for Conexant CX24120/CX24118 hardware\");\nMODULE_AUTHOR(\"Jemma Denson\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}