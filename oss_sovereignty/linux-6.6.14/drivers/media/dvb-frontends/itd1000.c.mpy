{
  "module_name": "itd1000.c",
  "hash_id": "1fddefb24e9ae3a67fa4b7610eef1e3674267fc969ac89734f3d1b08f1466bc9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/itd1000.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/dvb/frontend.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"itd1000.h\"\n#include \"itd1000_priv.h\"\n\n \n#define MAX_XFER_SIZE  64\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging (default:off).\");\n\n#define itd_dbg(args...)  do { \\\n\tif (debug) { \\\n\t\tprintk(KERN_DEBUG   \"ITD1000: \" args);\\\n\t} \\\n} while (0)\n\n#define itd_warn(args...) do { \\\n\tprintk(KERN_WARNING \"ITD1000: \" args); \\\n} while (0)\n\n#define itd_info(args...) do { \\\n\tprintk(KERN_INFO    \"ITD1000: \" args); \\\n} while (0)\n\n \nstatic int itd1000_write_regs(struct itd1000_state *state, u8 reg, u8 v[], u8 len)\n{\n\tu8 buf[MAX_XFER_SIZE];\n\tstruct i2c_msg msg = {\n\t\t.addr = state->cfg->i2c_address, .flags = 0, .buf = buf, .len = len+1\n\t};\n\n\tif (1 + len > sizeof(buf)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"itd1000: i2c wr reg=%04x: len=%d is too big!\\n\",\n\t\t       reg, len);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf[0] = reg;\n\tmemcpy(&buf[1], v, len);\n\n\t \n\n\tif (i2c_transfer(state->i2c, &msg, 1) != 1) {\n\t\tprintk(KERN_WARNING \"itd1000 I2C write failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int itd1000_read_reg(struct itd1000_state *state, u8 reg)\n{\n\tu8 val;\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = state->cfg->i2c_address, .flags = 0,        .buf = &reg, .len = 1 },\n\t\t{ .addr = state->cfg->i2c_address, .flags = I2C_M_RD, .buf = &val, .len = 1 },\n\t};\n\n\t \n\titd1000_write_regs(state, (reg - 1) & 0xff, &state->shadow[(reg - 1) & 0xff], 1);\n\n\tif (i2c_transfer(state->i2c, msg, 2) != 2) {\n\t\titd_warn(\"itd1000 I2C read failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn val;\n}\n\nstatic inline int itd1000_write_reg(struct itd1000_state *state, u8 r, u8 v)\n{\n\tu8 tmp = v;  \n\tint ret = itd1000_write_regs(state, r, &tmp, 1);\n\tstate->shadow[r] = tmp;\n\treturn ret;\n}\n\n\nstatic struct {\n\tu32 symbol_rate;\n\tu8  pgaext  : 4;  \n\tu8  bbgvmin : 4;  \n} itd1000_lpf_pga[] = {\n\t{        0, 0x8, 0x3 },\n\t{  5200000, 0x8, 0x3 },\n\t{ 12200000, 0x4, 0x3 },\n\t{ 15400000, 0x2, 0x3 },\n\t{ 19800000, 0x2, 0x3 },\n\t{ 21500000, 0x2, 0x3 },\n\t{ 24500000, 0x2, 0x3 },\n\t{ 28400000, 0x2, 0x3 },\n\t{ 33400000, 0x2, 0x3 },\n\t{ 34400000, 0x1, 0x4 },\n\t{ 34400000, 0x1, 0x4 },\n\t{ 38400000, 0x1, 0x4 },\n\t{ 38400000, 0x1, 0x4 },\n\t{ 40400000, 0x1, 0x4 },\n\t{ 45400000, 0x1, 0x4 },\n};\n\nstatic void itd1000_set_lpf_bw(struct itd1000_state *state, u32 symbol_rate)\n{\n\tu8 i;\n\tu8 con1    = itd1000_read_reg(state, CON1)    & 0xfd;\n\tu8 pllfh   = itd1000_read_reg(state, PLLFH)   & 0x0f;\n\tu8 bbgvmin = itd1000_read_reg(state, BBGVMIN) & 0xf0;\n\tu8 bw      = itd1000_read_reg(state, BW)      & 0xf0;\n\n\titd_dbg(\"symbol_rate = %d\\n\", symbol_rate);\n\n\t \n\titd1000_write_reg(state, CON1, con1 | (1 << 1));\n\n\tfor (i = 0; i < ARRAY_SIZE(itd1000_lpf_pga); i++)\n\t\tif (symbol_rate < itd1000_lpf_pga[i].symbol_rate) {\n\t\t\titd_dbg(\"symrate: index: %d pgaext: %x, bbgvmin: %x\\n\", i, itd1000_lpf_pga[i].pgaext, itd1000_lpf_pga[i].bbgvmin);\n\t\t\titd1000_write_reg(state, PLLFH,   pllfh | (itd1000_lpf_pga[i].pgaext << 4));\n\t\t\titd1000_write_reg(state, BBGVMIN, bbgvmin | (itd1000_lpf_pga[i].bbgvmin));\n\t\t\titd1000_write_reg(state, BW,      bw | (i & 0x0f));\n\t\t\tbreak;\n\t\t}\n\n\titd1000_write_reg(state, CON1, con1 | (0 << 1));\n}\n\nstatic struct {\n\tu8 vcorg;\n\tu32 fmax_rg;\n} itd1000_vcorg[] = {\n\t{  1,  920000 },\n\t{  2,  971000 },\n\t{  3, 1031000 },\n\t{  4, 1091000 },\n\t{  5, 1171000 },\n\t{  6, 1281000 },\n\t{  7, 1381000 },\n\t{  8,  500000 },\t \n\t{  9, 1451000 },\n\t{ 10, 1531000 },\n\t{ 11, 1631000 },\n\t{ 12, 1741000 },\n\t{ 13, 1891000 },\n\t{ 14, 2071000 },\n\t{ 15, 2250000 },\n};\n\nstatic void itd1000_set_vco(struct itd1000_state *state, u32 freq_khz)\n{\n\tu8 i;\n\tu8 gvbb_i2c     = itd1000_read_reg(state, GVBB_I2C) & 0xbf;\n\tu8 vco_chp1_i2c = itd1000_read_reg(state, VCO_CHP1_I2C) & 0x0f;\n\tu8 adcout;\n\n\t \n\titd1000_write_reg(state, GVBB_I2C, gvbb_i2c | (1 << 6));\n\n\tfor (i = 0; i < ARRAY_SIZE(itd1000_vcorg); i++) {\n\t\tif (freq_khz < itd1000_vcorg[i].fmax_rg) {\n\t\t\titd1000_write_reg(state, VCO_CHP1_I2C, vco_chp1_i2c | (itd1000_vcorg[i].vcorg << 4));\n\t\t\tmsleep(1);\n\n\t\t\tadcout = itd1000_read_reg(state, PLLLOCK) & 0x0f;\n\n\t\t\titd_dbg(\"VCO: %dkHz: %d -> ADCOUT: %d %02x\\n\", freq_khz, itd1000_vcorg[i].vcorg, adcout, vco_chp1_i2c);\n\n\t\t\tif (adcout > 13) {\n\t\t\t\tif (!(itd1000_vcorg[i].vcorg == 7 || itd1000_vcorg[i].vcorg == 15))\n\t\t\t\t\titd1000_write_reg(state, VCO_CHP1_I2C, vco_chp1_i2c | ((itd1000_vcorg[i].vcorg + 1) << 4));\n\t\t\t} else if (adcout < 2) {\n\t\t\t\tif (!(itd1000_vcorg[i].vcorg == 1 || itd1000_vcorg[i].vcorg == 9))\n\t\t\t\t\titd1000_write_reg(state, VCO_CHP1_I2C, vco_chp1_i2c | ((itd1000_vcorg[i].vcorg - 1) << 4));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic const struct {\n\tu32 freq;\n\tu8 values[10];  \n} itd1000_fre_values[] = {\n\t{ 1075000, { 0x59, 0x1d, 0x1c, 0x17, 0x16, 0x0f, 0x0e, 0x0c, 0x0b, 0x0a } },\n\t{ 1250000, { 0x89, 0x1e, 0x1d, 0x17, 0x15, 0x0f, 0x0e, 0x0c, 0x0b, 0x0a } },\n\t{ 1450000, { 0x89, 0x1e, 0x1d, 0x17, 0x15, 0x0f, 0x0e, 0x0c, 0x0b, 0x0a } },\n\t{ 1650000, { 0x69, 0x1e, 0x1d, 0x17, 0x15, 0x0f, 0x0e, 0x0c, 0x0b, 0x0a } },\n\t{ 1750000, { 0x69, 0x1e, 0x17, 0x15, 0x14, 0x0f, 0x0e, 0x0c, 0x0b, 0x0a } },\n\t{ 1850000, { 0x69, 0x1d, 0x17, 0x16, 0x14, 0x0f, 0x0e, 0x0d, 0x0b, 0x0a } },\n\t{ 1900000, { 0x69, 0x1d, 0x17, 0x15, 0x14, 0x0f, 0x0e, 0x0d, 0x0b, 0x0a } },\n\t{ 1950000, { 0x69, 0x1d, 0x17, 0x16, 0x14, 0x13, 0x0e, 0x0d, 0x0b, 0x0a } },\n\t{ 2050000, { 0x69, 0x1e, 0x1d, 0x17, 0x16, 0x14, 0x13, 0x0e, 0x0b, 0x0a } },\n\t{ 2150000, { 0x69, 0x1d, 0x1c, 0x17, 0x15, 0x14, 0x13, 0x0f, 0x0e, 0x0b } }\n};\n\n\n#define FREF 16\n\nstatic void itd1000_set_lo(struct itd1000_state *state, u32 freq_khz)\n{\n\tint i, j;\n\tu32 plln, pllf;\n\tu64 tmp;\n\n\tplln = (freq_khz * 1000) / 2 / FREF;\n\n\t \n\ttmp  = plln % 1000000;\n\tplln /= 1000000;\n\n\ttmp *= 1048576;\n\tdo_div(tmp, 1000000);\n\tpllf = (u32) tmp;\n\n\tstate->frequency = ((plln * 1000) + (pllf * 1000)/1048576) * 2*FREF;\n\titd_dbg(\"frequency: %dkHz (wanted) %dkHz (set), PLLF = %d, PLLN = %d\\n\", freq_khz, state->frequency, pllf, plln);\n\n\titd1000_write_reg(state, PLLNH, 0x80);  \n\titd1000_write_reg(state, PLLNL, plln & 0xff);\n\titd1000_write_reg(state, PLLFH, (itd1000_read_reg(state, PLLFH) & 0xf0) | ((pllf >> 16) & 0x0f));\n\titd1000_write_reg(state, PLLFM, (pllf >> 8) & 0xff);\n\titd1000_write_reg(state, PLLFL, (pllf >> 0) & 0xff);\n\n\tfor (i = 0; i < ARRAY_SIZE(itd1000_fre_values); i++) {\n\t\tif (freq_khz <= itd1000_fre_values[i].freq) {\n\t\t\titd_dbg(\"fre_values: %d\\n\", i);\n\t\t\titd1000_write_reg(state, RFTR, itd1000_fre_values[i].values[0]);\n\t\t\tfor (j = 0; j < 9; j++)\n\t\t\t\titd1000_write_reg(state, RFST1+j, itd1000_fre_values[i].values[j+1]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\titd1000_set_vco(state, freq_khz);\n}\n\nstatic int itd1000_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct itd1000_state *state = fe->tuner_priv;\n\tu8 pllcon1;\n\n\titd1000_set_lo(state, c->frequency);\n\titd1000_set_lpf_bw(state, c->symbol_rate);\n\n\tpllcon1 = itd1000_read_reg(state, PLLCON1) & 0x7f;\n\titd1000_write_reg(state, PLLCON1, pllcon1 | (1 << 7));\n\titd1000_write_reg(state, PLLCON1, pllcon1);\n\n\treturn 0;\n}\n\nstatic int itd1000_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct itd1000_state *state = fe->tuner_priv;\n\t*frequency = state->frequency;\n\treturn 0;\n}\n\nstatic int itd1000_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\treturn 0;\n}\n\nstatic u8 itd1000_init_tab[][2] = {\n\t{ PLLCON1,       0x65 },  \n\t{ PLLNH,         0x80 },  \n\t{ RESERVED_0X6D, 0x3b },\n\t{ VCO_CHP2_I2C,  0x12 },\n\t{ 0x72,          0xf9 },  \n\t{ RESERVED_0X73, 0xff },\n\t{ RESERVED_0X74, 0xb2 },\n\t{ RESERVED_0X75, 0xc7 },\n\t{ EXTGVBBRF,     0xf0 },\n\t{ DIVAGCCK,      0x80 },\n\t{ BBTR,          0xa0 },\n\t{ RESERVED_0X7E, 0x4f },\n\t{ 0x82,          0x88 },  \n\t{ 0x83,          0x80 },  \n\t{ 0x84,          0x80 },  \n\t{ RESERVED_0X85, 0x74 },\n\t{ RESERVED_0X86, 0xff },\n\t{ RESERVED_0X88, 0x02 },\n\t{ RESERVED_0X89, 0x16 },\n\t{ RFST0,         0x1f },\n\t{ RESERVED_0X94, 0x66 },\n\t{ RESERVED_0X95, 0x66 },\n\t{ RESERVED_0X96, 0x77 },\n\t{ RESERVED_0X97, 0x99 },\n\t{ RESERVED_0X98, 0xff },\n\t{ RESERVED_0X99, 0xfc },\n\t{ RESERVED_0X9A, 0xba },\n\t{ RESERVED_0X9B, 0xaa },\n};\n\nstatic u8 itd1000_reinit_tab[][2] = {\n\t{ VCO_CHP1_I2C, 0x8a },\n\t{ BW,           0x87 },\n\t{ GVBB_I2C,     0x03 },\n\t{ BBGVMIN,      0x03 },\n\t{ CON1,         0x2e },\n};\n\n\nstatic int itd1000_init(struct dvb_frontend *fe)\n{\n\tstruct itd1000_state *state = fe->tuner_priv;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(itd1000_init_tab); i++)\n\t\titd1000_write_reg(state, itd1000_init_tab[i][0], itd1000_init_tab[i][1]);\n\n\tfor (i = 0; i < ARRAY_SIZE(itd1000_reinit_tab); i++)\n\t\titd1000_write_reg(state, itd1000_reinit_tab[i][0], itd1000_reinit_tab[i][1]);\n\n\treturn 0;\n}\n\nstatic int itd1000_sleep(struct dvb_frontend *fe)\n{\n\treturn 0;\n}\n\nstatic void itd1000_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic const struct dvb_tuner_ops itd1000_tuner_ops = {\n\t.info = {\n\t\t.name              = \"Integrant ITD1000\",\n\t\t.frequency_min_hz  =  950 * MHz,\n\t\t.frequency_max_hz  = 2150 * MHz,\n\t\t.frequency_step_hz =  125 * kHz,\n\t},\n\n\t.release       = itd1000_release,\n\n\t.init          = itd1000_init,\n\t.sleep         = itd1000_sleep,\n\n\t.set_params    = itd1000_set_parameters,\n\t.get_frequency = itd1000_get_frequency,\n\t.get_bandwidth = itd1000_get_bandwidth\n};\n\n\nstruct dvb_frontend *itd1000_attach(struct dvb_frontend *fe, struct i2c_adapter *i2c, struct itd1000_config *cfg)\n{\n\tstruct itd1000_state *state = NULL;\n\tu8 i = 0;\n\n\tstate = kzalloc(sizeof(struct itd1000_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tstate->cfg = cfg;\n\tstate->i2c = i2c;\n\n\ti = itd1000_read_reg(state, 0);\n\tif (i != 0) {\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\titd_info(\"successfully identified (ID: %d)\\n\", i);\n\n\tmemset(state->shadow, 0xff, sizeof(state->shadow));\n\tfor (i = 0x65; i < 0x9c; i++)\n\t\tstate->shadow[i] = itd1000_read_reg(state, i);\n\n\tmemcpy(&fe->ops.tuner_ops, &itd1000_tuner_ops, sizeof(struct dvb_tuner_ops));\n\n\tfe->tuner_priv = state;\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(itd1000_attach);\n\nMODULE_AUTHOR(\"Patrick Boettcher <pb@linuxtv.org>\");\nMODULE_DESCRIPTION(\"Integrant ITD1000 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}