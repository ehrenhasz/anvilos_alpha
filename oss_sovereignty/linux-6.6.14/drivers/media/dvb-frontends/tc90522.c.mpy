{
  "module_name": "tc90522.c",
  "hash_id": "0f7236a290cf8d753efaa5ce3dd1e5c8253080351bdf22bfc3e86258bfdc37c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tc90522.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/dvb/frontend.h>\n#include <linux/int_log.h>\n#include \"tc90522.h\"\n\n#define TC90522_I2C_THRU_REG 0xfe\n\n#define TC90522_MODULE_IDX(addr) (((u8)(addr) & 0x02U) >> 1)\n\nstruct tc90522_state {\n\tstruct tc90522_config cfg;\n\tstruct dvb_frontend fe;\n\tstruct i2c_client *i2c_client;\n\tstruct i2c_adapter tuner_i2c;\n\n\tbool lna;\n};\n\nstruct reg_val {\n\tu8 reg;\n\tu8 val;\n};\n\nstatic int\nreg_write(struct tc90522_state *state, const struct reg_val *regs, int num)\n{\n\tint i, ret;\n\tstruct i2c_msg msg;\n\n\tret = 0;\n\tmsg.addr = state->i2c_client->addr;\n\tmsg.flags = 0;\n\tmsg.len = 2;\n\tfor (i = 0; i < num; i++) {\n\t\tmsg.buf = (u8 *)&regs[i];\n\t\tret = i2c_transfer(state->i2c_client->adapter, &msg, 1);\n\t\tif (ret == 0)\n\t\t\tret = -EIO;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int reg_read(struct tc90522_state *state, u8 reg, u8 *val, u8 len)\n{\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr = state->i2c_client->addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = &reg,\n\t\t\t.len = 1,\n\t\t},\n\t\t{\n\t\t\t.addr = state->i2c_client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = val,\n\t\t\t.len = len,\n\t\t},\n\t};\n\tint ret;\n\n\tret = i2c_transfer(state->i2c_client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret == ARRAY_SIZE(msgs))\n\t\tret = 0;\n\telse if (ret >= 0)\n\t\tret = -EIO;\n\treturn ret;\n}\n\nstatic struct tc90522_state *cfg_to_state(struct tc90522_config *c)\n{\n\treturn container_of(c, struct tc90522_state, cfg);\n}\n\n\nstatic int tc90522s_set_tsid(struct dvb_frontend *fe)\n{\n\tstruct reg_val set_tsid[] = {\n\t\t{ 0x8f, 00 },\n\t\t{ 0x90, 00 }\n\t};\n\n\tset_tsid[0].val = (fe->dtv_property_cache.stream_id & 0xff00) >> 8;\n\tset_tsid[1].val = fe->dtv_property_cache.stream_id & 0xff;\n\treturn reg_write(fe->demodulator_priv, set_tsid, ARRAY_SIZE(set_tsid));\n}\n\nstatic int tc90522t_set_layers(struct dvb_frontend *fe)\n{\n\tstruct reg_val rv;\n\tu8 laysel;\n\n\tlaysel = ~fe->dtv_property_cache.isdbt_layer_enabled & 0x07;\n\tlaysel = (laysel & 0x01) << 2 | (laysel & 0x02) | (laysel & 0x04) >> 2;\n\trv.reg = 0x71;\n\trv.val = laysel;\n\treturn reg_write(fe->demodulator_priv, &rv, 1);\n}\n\n \n\nstatic int tc90522s_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct tc90522_state *state;\n\tint ret;\n\tu8 reg;\n\n\tstate = fe->demodulator_priv;\n\tret = reg_read(state, 0xc3, &reg, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*status = 0;\n\tif (reg & 0x80)  \n\t\treturn 0;\n\t*status |= FE_HAS_SIGNAL;\n\n\tif (reg & 0x60)  \n\t\treturn 0;\n\t*status |= FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC;\n\n\tif (reg & 0x10)\n\t\treturn 0;\n\tif (reg_read(state, 0xc5, &reg, 1) < 0 || !(reg & 0x03))\n\t\treturn 0;\n\t*status |= FE_HAS_LOCK;\n\treturn 0;\n}\n\nstatic int tc90522t_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct tc90522_state *state;\n\tint ret;\n\tu8 reg;\n\n\tstate = fe->demodulator_priv;\n\tret = reg_read(state, 0x96, &reg, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*status = 0;\n\tif (reg & 0xe0) {\n\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI\n\t\t\t\t| FE_HAS_SYNC | FE_HAS_LOCK;\n\t\treturn 0;\n\t}\n\n\tret = reg_read(state, 0x80, &reg, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (reg & 0xf0)\n\t\treturn 0;\n\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\n\tif (reg & 0x0c)\n\t\treturn 0;\n\t*status |= FE_HAS_SYNC | FE_HAS_VITERBI;\n\n\tif (reg & 0x02)\n\t\treturn 0;\n\t*status |= FE_HAS_LOCK;\n\treturn 0;\n}\n\nstatic const enum fe_code_rate fec_conv_sat[] = {\n\tFEC_NONE,  \n\tFEC_1_2,  \n\tFEC_1_2, FEC_2_3, FEC_3_4, FEC_5_6, FEC_7_8,  \n\tFEC_2_3,  \n};\n\nstatic int tc90522s_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t struct dtv_frontend_properties *c)\n{\n\tstruct tc90522_state *state;\n\tstruct dtv_fe_stats *stats;\n\tint ret, i;\n\tint layers;\n\tu8 val[10];\n\tu32 cndat;\n\n\tstate = fe->demodulator_priv;\n\tc->delivery_system = SYS_ISDBS;\n\tc->symbol_rate = 28860000;\n\n\tlayers = 0;\n\tret = reg_read(state, 0xe6, val, 5);\n\tif (ret == 0) {\n\t\tu8 v;\n\n\t\tc->stream_id = val[0] << 8 | val[1];\n\n\t\t \n\t\tv = (val[2] & 0x70) >> 4;\n\t\tc->modulation = (v == 7) ? PSK_8 : QPSK;\n\t\tc->fec_inner = fec_conv_sat[v];\n\t\tc->layer[0].fec = c->fec_inner;\n\t\tc->layer[0].modulation = c->modulation;\n\t\tc->layer[0].segment_count = val[3] & 0x3f;  \n\n\t\t \n\t\tv = (val[2] & 0x07);\n\t\tc->layer[1].fec = fec_conv_sat[v];\n\t\tif (v == 0)   \n\t\t\tc->layer[1].segment_count = 0;\n\t\telse\n\t\t\tc->layer[1].segment_count = val[4] & 0x3f;  \n\t\t \n\t\tc->layer[1].modulation = QPSK;\n\t\tlayers = (v > 0) ? 2 : 1;\n\t}\n\n\t \n\n\tstats = &c->strength;\n\tstats->len = 0;\n\t \n\tif (fe->ops.tuner_ops.get_rf_strength) {\n\t\tu16 dummy;\n\n\t\tfe->ops.tuner_ops.get_rf_strength(fe, &dummy);\n\t}\n\n\tstats = &c->cnr;\n\tstats->len = 1;\n\tstats->stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tcndat = 0;\n\tret = reg_read(state, 0xbc, val, 2);\n\tif (ret == 0)\n\t\tcndat = val[0] << 8 | val[1];\n\tif (cndat >= 3000) {\n\t\tu32 p, p4;\n\t\ts64 cn;\n\n\t\tcndat -= 3000;   \n\t\t \n\t\t \n\t\t \n\t\tp = int_sqrt(cndat << 16);\n\t\tp4 = cndat * cndat;\n\t\tcn = div64_s64(-16346LL * p4 * p, 10) >> 35;\n\t\tcn += (14341LL * p4) >> 21;\n\t\tcn -= (50259LL * cndat * p) >> 23;\n\t\tcn += (88977LL * cndat) >> 9;\n\t\tcn -= (89565LL * p) >> 11;\n\t\tcn += 58857  << 3;\n\t\tstats->stat[0].svalue = cn >> 3;\n\t\tstats->stat[0].scale = FE_SCALE_DECIBEL;\n\t}\n\n\t \n\tstats = &c->post_bit_error;\n\tmemset(stats, 0, sizeof(*stats));\n\tstats->len = layers;\n\tret = reg_read(state, 0xeb, val, 10);\n\tif (ret < 0)\n\t\tfor (i = 0; i < layers; i++)\n\t\t\tstats->stat[i].scale = FE_SCALE_NOT_AVAILABLE;\n\telse {\n\t\tfor (i = 0; i < layers; i++) {\n\t\t\tstats->stat[i].scale = FE_SCALE_COUNTER;\n\t\t\tstats->stat[i].uvalue = val[i * 5] << 16\n\t\t\t\t| val[i * 5 + 1] << 8 | val[i * 5 + 2];\n\t\t}\n\t}\n\tstats = &c->post_bit_count;\n\tmemset(stats, 0, sizeof(*stats));\n\tstats->len = layers;\n\tif (ret < 0)\n\t\tfor (i = 0; i < layers; i++)\n\t\t\tstats->stat[i].scale = FE_SCALE_NOT_AVAILABLE;\n\telse {\n\t\tfor (i = 0; i < layers; i++) {\n\t\t\tstats->stat[i].scale = FE_SCALE_COUNTER;\n\t\t\tstats->stat[i].uvalue =\n\t\t\t\tval[i * 5 + 3] << 8 | val[i * 5 + 4];\n\t\t\tstats->stat[i].uvalue *= 204 * 8;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic const enum fe_transmit_mode tm_conv[] = {\n\tTRANSMISSION_MODE_2K,\n\tTRANSMISSION_MODE_4K,\n\tTRANSMISSION_MODE_8K,\n\t0\n};\n\nstatic const enum fe_code_rate fec_conv_ter[] = {\n\tFEC_1_2, FEC_2_3, FEC_3_4, FEC_5_6, FEC_7_8, 0, 0, 0\n};\n\nstatic const enum fe_modulation mod_conv[] = {\n\tDQPSK, QPSK, QAM_16, QAM_64, 0, 0, 0, 0\n};\n\nstatic int tc90522t_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t struct dtv_frontend_properties *c)\n{\n\tstruct tc90522_state *state;\n\tstruct dtv_fe_stats *stats;\n\tint ret, i;\n\tint layers;\n\tu8 val[15], mode;\n\tu32 cndat;\n\n\tstate = fe->demodulator_priv;\n\tc->delivery_system = SYS_ISDBT;\n\tc->bandwidth_hz = 6000000;\n\tmode = 1;\n\tret = reg_read(state, 0xb0, val, 1);\n\tif (ret == 0) {\n\t\tmode = (val[0] & 0xc0) >> 6;\n\t\tc->transmission_mode = tm_conv[mode];\n\t\tc->guard_interval = (val[0] & 0x30) >> 4;\n\t}\n\n\tret = reg_read(state, 0xb2, val, 6);\n\tlayers = 0;\n\tif (ret == 0) {\n\t\tu8 v;\n\n\t\tc->isdbt_partial_reception = val[0] & 0x01;\n\t\tc->isdbt_sb_mode = (val[0] & 0xc0) == 0x40;\n\n\t\t \n\t\tv = (val[2] & 0x78) >> 3;\n\t\tif (v == 0x0f)\n\t\t\tc->layer[0].segment_count = 0;\n\t\telse {\n\t\t\tlayers++;\n\t\t\tc->layer[0].segment_count = v;\n\t\t\tc->layer[0].fec = fec_conv_ter[(val[1] & 0x1c) >> 2];\n\t\t\tc->layer[0].modulation = mod_conv[(val[1] & 0xe0) >> 5];\n\t\t\tv = (val[1] & 0x03) << 1 | (val[2] & 0x80) >> 7;\n\t\t\tc->layer[0].interleaving = v;\n\t\t}\n\n\t\t \n\t\tv = (val[3] & 0x03) << 2 | (val[4] & 0xc0) >> 6;\n\t\tif (v == 0x0f)\n\t\t\tc->layer[1].segment_count = 0;\n\t\telse {\n\t\t\tlayers++;\n\t\t\tc->layer[1].segment_count = v;\n\t\t\tc->layer[1].fec = fec_conv_ter[(val[3] & 0xe0) >> 5];\n\t\t\tc->layer[1].modulation = mod_conv[(val[2] & 0x07)];\n\t\t\tc->layer[1].interleaving = (val[3] & 0x1c) >> 2;\n\t\t}\n\n\t\t \n\t\tv = (val[5] & 0x1e) >> 1;\n\t\tif (v == 0x0f)\n\t\t\tc->layer[2].segment_count = 0;\n\t\telse {\n\t\t\tlayers++;\n\t\t\tc->layer[2].segment_count = v;\n\t\t\tc->layer[2].fec = fec_conv_ter[(val[4] & 0x07)];\n\t\t\tc->layer[2].modulation = mod_conv[(val[4] & 0x38) >> 3];\n\t\t\tc->layer[2].interleaving = (val[5] & 0xe0) >> 5;\n\t\t}\n\t}\n\n\t \n\n\tstats = &c->strength;\n\tstats->len = 0;\n\t \n\tif (fe->ops.tuner_ops.get_rf_strength) {\n\t\tu16 dummy;\n\n\t\tfe->ops.tuner_ops.get_rf_strength(fe, &dummy);\n\t}\n\n\tstats = &c->cnr;\n\tstats->len = 1;\n\tstats->stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tcndat = 0;\n\tret = reg_read(state, 0x8b, val, 3);\n\tif (ret == 0)\n\t\tcndat = val[0] << 16 | val[1] << 8 | val[2];\n\tif (cndat != 0) {\n\t\tu32 p, tmp;\n\t\ts64 cn;\n\n\t\t \n\t\t \n\t\t \n\t\tp = intlog10(5505024) - intlog10(cndat);\n\t\tp *= 10;\n\n\t\tcn = 24772;\n\t\tcn += div64_s64(43827LL * p, 10) >> 24;\n\t\ttmp = p >> 8;\n\t\tcn += div64_s64(3184LL * tmp * tmp, 10) >> 32;\n\t\ttmp = p >> 13;\n\t\tcn -= div64_s64(128LL * tmp * tmp * tmp, 10) >> 33;\n\t\ttmp = p >> 18;\n\t\tcn += div64_s64(192LL * tmp * tmp * tmp * tmp, 1000) >> 24;\n\n\t\tstats->stat[0].svalue = cn >> 3;\n\t\tstats->stat[0].scale = FE_SCALE_DECIBEL;\n\t}\n\n\t \n\tstats = &c->post_bit_error;\n\tmemset(stats, 0, sizeof(*stats));\n\tstats->len = layers;\n\tret = reg_read(state, 0x9d, val, 15);\n\tif (ret < 0)\n\t\tfor (i = 0; i < layers; i++)\n\t\t\tstats->stat[i].scale = FE_SCALE_NOT_AVAILABLE;\n\telse {\n\t\tfor (i = 0; i < layers; i++) {\n\t\t\tstats->stat[i].scale = FE_SCALE_COUNTER;\n\t\t\tstats->stat[i].uvalue = val[i * 3] << 16\n\t\t\t\t| val[i * 3 + 1] << 8 | val[i * 3 + 2];\n\t\t}\n\t}\n\tstats = &c->post_bit_count;\n\tmemset(stats, 0, sizeof(*stats));\n\tstats->len = layers;\n\tif (ret < 0)\n\t\tfor (i = 0; i < layers; i++)\n\t\t\tstats->stat[i].scale = FE_SCALE_NOT_AVAILABLE;\n\telse {\n\t\tfor (i = 0; i < layers; i++) {\n\t\t\tstats->stat[i].scale = FE_SCALE_COUNTER;\n\t\t\tstats->stat[i].uvalue =\n\t\t\t\tval[9 + i * 2] << 8 | val[9 + i * 2 + 1];\n\t\t\tstats->stat[i].uvalue *= 204 * 8;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct reg_val reset_sat = { 0x03, 0x01 };\nstatic const struct reg_val reset_ter = { 0x01, 0x40 };\n\nstatic int tc90522_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct tc90522_state *state;\n\tint ret;\n\n\tstate = fe->demodulator_priv;\n\n\tif (fe->ops.tuner_ops.set_params)\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\telse\n\t\tret = -ENODEV;\n\tif (ret < 0)\n\t\tgoto failed;\n\n\tif (fe->ops.delsys[0] == SYS_ISDBS) {\n\t\tret = tc90522s_set_tsid(fe);\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t\tret = reg_write(state, &reset_sat, 1);\n\t} else {\n\t\tret = tc90522t_set_layers(fe);\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t\tret = reg_write(state, &reset_ter, 1);\n\t}\n\tif (ret < 0)\n\t\tgoto failed;\n\n\treturn 0;\n\nfailed:\n\tdev_warn(&state->tuner_i2c.dev, \"(%s) failed. [adap%d-fe%d]\\n\",\n\t\t\t__func__, fe->dvb->num, fe->id);\n\treturn ret;\n}\n\nstatic int tc90522_get_tune_settings(struct dvb_frontend *fe,\n\tstruct dvb_frontend_tune_settings *settings)\n{\n\tif (fe->ops.delsys[0] == SYS_ISDBS) {\n\t\tsettings->min_delay_ms = 250;\n\t\tsettings->step_size = 1000;\n\t\tsettings->max_drift = settings->step_size * 2;\n\t} else {\n\t\tsettings->min_delay_ms = 400;\n\t\tsettings->step_size = 142857;\n\t\tsettings->max_drift = settings->step_size;\n\t}\n\treturn 0;\n}\n\nstatic int tc90522_set_if_agc(struct dvb_frontend *fe, bool on)\n{\n\tstruct reg_val agc_sat[] = {\n\t\t{ 0x0a, 0x00 },\n\t\t{ 0x10, 0x30 },\n\t\t{ 0x11, 0x00 },\n\t\t{ 0x03, 0x01 },\n\t};\n\tstruct reg_val agc_ter[] = {\n\t\t{ 0x25, 0x00 },\n\t\t{ 0x23, 0x4c },\n\t\t{ 0x01, 0x40 },\n\t};\n\tstruct tc90522_state *state;\n\tstruct reg_val *rv;\n\tint num;\n\n\tstate = fe->demodulator_priv;\n\tif (fe->ops.delsys[0] == SYS_ISDBS) {\n\t\tagc_sat[0].val = on ? 0xff : 0x00;\n\t\tagc_sat[1].val |= 0x80;\n\t\tagc_sat[1].val |= on ? 0x01 : 0x00;\n\t\tagc_sat[2].val |= on ? 0x40 : 0x00;\n\t\trv = agc_sat;\n\t\tnum = ARRAY_SIZE(agc_sat);\n\t} else {\n\t\tagc_ter[0].val = on ? 0x40 : 0x00;\n\t\tagc_ter[1].val |= on ? 0x00 : 0x01;\n\t\trv = agc_ter;\n\t\tnum = ARRAY_SIZE(agc_ter);\n\t}\n\treturn reg_write(state, rv, num);\n}\n\nstatic const struct reg_val sleep_sat = { 0x17, 0x01 };\nstatic const struct reg_val sleep_ter = { 0x03, 0x90 };\n\nstatic int tc90522_sleep(struct dvb_frontend *fe)\n{\n\tstruct tc90522_state *state;\n\tint ret;\n\n\tstate = fe->demodulator_priv;\n\tif (fe->ops.delsys[0] == SYS_ISDBS)\n\t\tret = reg_write(state, &sleep_sat, 1);\n\telse {\n\t\tret = reg_write(state, &sleep_ter, 1);\n\t\tif (ret == 0 && fe->ops.set_lna &&\n\t\t    fe->dtv_property_cache.lna == LNA_AUTO) {\n\t\t\tfe->dtv_property_cache.lna = 0;\n\t\t\tret = fe->ops.set_lna(fe);\n\t\t\tfe->dtv_property_cache.lna = LNA_AUTO;\n\t\t}\n\t}\n\tif (ret < 0)\n\t\tdev_warn(&state->tuner_i2c.dev,\n\t\t\t\"(%s) failed. [adap%d-fe%d]\\n\",\n\t\t\t__func__, fe->dvb->num, fe->id);\n\treturn ret;\n}\n\nstatic const struct reg_val wakeup_sat = { 0x17, 0x00 };\nstatic const struct reg_val wakeup_ter = { 0x03, 0x80 };\n\nstatic int tc90522_init(struct dvb_frontend *fe)\n{\n\tstruct tc90522_state *state;\n\tint ret;\n\n\t \n\n\tstate = fe->demodulator_priv;\n\tif (fe->ops.delsys[0] == SYS_ISDBS)\n\t\tret = reg_write(state, &wakeup_sat, 1);\n\telse {\n\t\tret = reg_write(state, &wakeup_ter, 1);\n\t\tif (ret == 0 && fe->ops.set_lna &&\n\t\t    fe->dtv_property_cache.lna == LNA_AUTO) {\n\t\t\tfe->dtv_property_cache.lna = 1;\n\t\t\tret = fe->ops.set_lna(fe);\n\t\t\tfe->dtv_property_cache.lna = LNA_AUTO;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\tdev_warn(&state->tuner_i2c.dev,\n\t\t\t\"(%s) failed. [adap%d-fe%d]\\n\",\n\t\t\t__func__, fe->dvb->num, fe->id);\n\t\treturn ret;\n\t}\n\n\t \n\tif (fe->dtv_property_cache.isdbt_layer_enabled == 0)\n\t\tfe->dtv_property_cache.isdbt_layer_enabled = 7;\n\treturn tc90522_set_if_agc(fe, true);\n}\n\n\n \n\nstatic int\ntc90522_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct tc90522_state *state;\n\tstruct i2c_msg *new_msgs;\n\tint i, j;\n\tint ret, rd_num;\n\tu8 wbuf[256];\n\tu8 *p, *bufend;\n\n\tif (num <= 0)\n\t\treturn -EINVAL;\n\n\trd_num = 0;\n\tfor (i = 0; i < num; i++)\n\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\trd_num++;\n\tnew_msgs = kmalloc_array(num + rd_num, sizeof(*new_msgs), GFP_KERNEL);\n\tif (!new_msgs)\n\t\treturn -ENOMEM;\n\n\tstate = i2c_get_adapdata(adap);\n\tp = wbuf;\n\tbufend = wbuf + sizeof(wbuf);\n\tfor (i = 0, j = 0; i < num; i++, j++) {\n\t\tnew_msgs[j].addr = state->i2c_client->addr;\n\t\tnew_msgs[j].flags = msgs[i].flags;\n\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\tnew_msgs[j].flags &= ~I2C_M_RD;\n\t\t\tif (p + 2 > bufend)\n\t\t\t\tbreak;\n\t\t\tp[0] = TC90522_I2C_THRU_REG;\n\t\t\tp[1] = msgs[i].addr << 1 | 0x01;\n\t\t\tnew_msgs[j].buf = p;\n\t\t\tnew_msgs[j].len = 2;\n\t\t\tp += 2;\n\t\t\tj++;\n\t\t\tnew_msgs[j].addr = state->i2c_client->addr;\n\t\t\tnew_msgs[j].flags = msgs[i].flags;\n\t\t\tnew_msgs[j].buf = msgs[i].buf;\n\t\t\tnew_msgs[j].len = msgs[i].len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (p + msgs[i].len + 2 > bufend)\n\t\t\tbreak;\n\t\tp[0] = TC90522_I2C_THRU_REG;\n\t\tp[1] = msgs[i].addr << 1;\n\t\tmemcpy(p + 2, msgs[i].buf, msgs[i].len);\n\t\tnew_msgs[j].buf = p;\n\t\tnew_msgs[j].len = msgs[i].len + 2;\n\t\tp += new_msgs[j].len;\n\t}\n\n\tif (i < num) {\n\t\tret = -ENOMEM;\n\t} else if (!state->cfg.split_tuner_read_i2c || rd_num == 0) {\n\t\tret = i2c_transfer(state->i2c_client->adapter, new_msgs, j);\n\t} else {\n\t\t \n\t\tint from, to;\n\n\t\tret = 0;\n\t\tfrom = 0;\n\t\tdo {\n\t\t\tint r;\n\n\t\t\tto = from + 1;\n\t\t\twhile (to < j && !(new_msgs[to].flags & I2C_M_RD))\n\t\t\t\tto++;\n\t\t\tr = i2c_transfer(state->i2c_client->adapter,\n\t\t\t\t\t &new_msgs[from], to - from);\n\t\t\tret = (r <= 0) ? r : ret + r;\n\t\t\tfrom = to;\n\t\t} while (from < j && ret > 0);\n\t}\n\n\tif (ret >= 0 && ret < j)\n\t\tret = -EIO;\n\tkfree(new_msgs);\n\treturn (ret == j) ? num : ret;\n}\n\nstatic u32 tc90522_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm tc90522_tuner_i2c_algo = {\n\t.master_xfer   = &tc90522_master_xfer,\n\t.functionality = &tc90522_functionality,\n};\n\n\n \n\nstatic const struct dvb_frontend_ops tc90522_ops_sat = {\n\t.delsys = { SYS_ISDBS },\n\t.info = {\n\t\t.name = \"Toshiba TC90522 ISDB-S module\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t\t.caps = FE_CAN_INVERSION_AUTO | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO,\n\t},\n\n\t.init = tc90522_init,\n\t.sleep = tc90522_sleep,\n\t.set_frontend = tc90522_set_frontend,\n\t.get_tune_settings = tc90522_get_tune_settings,\n\n\t.get_frontend = tc90522s_get_frontend,\n\t.read_status = tc90522s_read_status,\n};\n\nstatic const struct dvb_frontend_ops tc90522_ops_ter = {\n\t.delsys = { SYS_ISDBT },\n\t.info = {\n\t\t.name = \"Toshiba TC90522 ISDB-T module\",\n\t\t.frequency_min_hz = 470 * MHz,\n\t\t.frequency_max_hz = 770 * MHz,\n\t\t.frequency_stepsize_hz = 142857,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2  | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6  | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK     | FE_CAN_QAM_16 | FE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_RECOVER |\n\t\t\tFE_CAN_HIERARCHY_AUTO,\n\t},\n\n\t.init = tc90522_init,\n\t.sleep = tc90522_sleep,\n\t.set_frontend = tc90522_set_frontend,\n\t.get_tune_settings = tc90522_get_tune_settings,\n\n\t.get_frontend = tc90522t_get_frontend,\n\t.read_status = tc90522t_read_status,\n};\n\n\nstatic int tc90522_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct tc90522_state *state;\n\tstruct tc90522_config *cfg;\n\tconst struct dvb_frontend_ops *ops;\n\tstruct i2c_adapter *adap;\n\tint ret;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\tstate->i2c_client = client;\n\n\tcfg = client->dev.platform_data;\n\tmemcpy(&state->cfg, cfg, sizeof(state->cfg));\n\tcfg->fe = state->cfg.fe = &state->fe;\n\tops =  id->driver_data == 0 ? &tc90522_ops_sat : &tc90522_ops_ter;\n\tmemcpy(&state->fe.ops, ops, sizeof(*ops));\n\tstate->fe.demodulator_priv = state;\n\n\tadap = &state->tuner_i2c;\n\tadap->owner = THIS_MODULE;\n\tadap->algo = &tc90522_tuner_i2c_algo;\n\tadap->dev.parent = &client->dev;\n\tstrscpy(adap->name, \"tc90522_sub\", sizeof(adap->name));\n\ti2c_set_adapdata(adap, state);\n\tret = i2c_add_adapter(adap);\n\tif (ret < 0)\n\t\tgoto free_state;\n\tcfg->tuner_i2c = state->cfg.tuner_i2c = adap;\n\n\ti2c_set_clientdata(client, &state->cfg);\n\tdev_info(&client->dev, \"Toshiba TC90522 attached.\\n\");\n\treturn 0;\nfree_state:\n\tkfree(state);\n\treturn ret;\n}\n\nstatic void tc90522_remove(struct i2c_client *client)\n{\n\tstruct tc90522_state *state;\n\n\tstate = cfg_to_state(i2c_get_clientdata(client));\n\ti2c_del_adapter(&state->tuner_i2c);\n\tkfree(state);\n}\n\n\nstatic const struct i2c_device_id tc90522_id[] = {\n\t{ TC90522_I2C_DEV_SAT, 0 },\n\t{ TC90522_I2C_DEV_TER, 1 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, tc90522_id);\n\nstatic struct i2c_driver tc90522_driver = {\n\t.driver = {\n\t\t.name\t= \"tc90522\",\n\t},\n\t.probe\t\t= tc90522_probe,\n\t.remove\t\t= tc90522_remove,\n\t.id_table\t= tc90522_id,\n};\n\nmodule_i2c_driver(tc90522_driver);\n\nMODULE_DESCRIPTION(\"Toshiba TC90522 frontend\");\nMODULE_AUTHOR(\"Akihiro TSUKADA\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}