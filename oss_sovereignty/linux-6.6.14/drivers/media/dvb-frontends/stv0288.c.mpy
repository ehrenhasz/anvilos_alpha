{
  "module_name": "stv0288.c",
  "hash_id": "6f3c956266ec98c4c7e6e9b937018f22c4c3ea3bc71212ba0001e5173c01e74b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stv0288.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"stv0288.h\"\n\nstruct stv0288_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct stv0288_config *config;\n\tstruct dvb_frontend frontend;\n\n\tu8 initialised:1;\n\tu32 tuner_frequency;\n\tu32 symbol_rate;\n\tenum fe_code_rate fec_inner;\n\tint errmode;\n};\n\n#define STATUS_BER 0\n#define STATUS_UCBLOCKS 1\n\nstatic int debug;\nstatic int debug_legacy_dish_switch;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_DEBUG \"stv0288: \" args); \\\n\t} while (0)\n\n\nstatic int stv0288_writeregI(struct stv0288_state *state, u8 reg, u8 data)\n{\n\tint ret;\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = {\n\t\t.addr = state->config->demod_address,\n\t\t.flags = 0,\n\t\t.buf = buf,\n\t\t.len = 2\n\t};\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tdprintk(\"%s: writereg error (reg == 0x%02x, val == 0x%02x, ret == %i)\\n\",\n\t\t\t__func__, reg, data, ret);\n\n\treturn (ret != 1) ? -EREMOTEIO : 0;\n}\n\nstatic int stv0288_write(struct dvb_frontend *fe, const u8 buf[], int len)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\treturn stv0288_writeregI(state, buf[0], buf[1]);\n}\n\nstatic u8 stv0288_readreg(struct stv0288_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = state->config->demod_address,\n\t\t\t.flags = 0,\n\t\t\t.buf = b0,\n\t\t\t.len = 1\n\t\t}, {\n\t\t\t.addr = state->config->demod_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = b1,\n\t\t\t.len = 1\n\t\t}\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tdprintk(\"%s: readreg error (reg == 0x%02x, ret == %i)\\n\",\n\t\t\t\t__func__, reg, ret);\n\n\treturn b1[0];\n}\n\nstatic int stv0288_set_symbolrate(struct dvb_frontend *fe, u32 srate)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\tunsigned int temp;\n\tunsigned char b[3];\n\n\tif ((srate < 1000000) || (srate > 45000000))\n\t\treturn -EINVAL;\n\n\tstv0288_writeregI(state, 0x22, 0);\n\tstv0288_writeregI(state, 0x23, 0);\n\tstv0288_writeregI(state, 0x2b, 0xff);\n\tstv0288_writeregI(state, 0x2c, 0xf7);\n\n\ttemp = (unsigned int)srate / 1000;\n\n\ttemp = temp * 32768;\n\ttemp = temp / 25;\n\ttemp = temp / 125;\n\tb[0] = (unsigned char)((temp >> 12) & 0xff);\n\tb[1] = (unsigned char)((temp >> 4) & 0xff);\n\tb[2] = (unsigned char)((temp << 4) & 0xf0);\n\tstv0288_writeregI(state, 0x28, 0x80);  \n\tstv0288_writeregI(state, 0x29, 0);  \n\tstv0288_writeregI(state, 0x2a, 0);  \n\n\tstv0288_writeregI(state, 0x28, b[0]);\n\tstv0288_writeregI(state, 0x29, b[1]);\n\tstv0288_writeregI(state, 0x2a, b[2]);\n\tdprintk(\"stv0288: stv0288_set_symbolrate\\n\");\n\n\treturn 0;\n}\n\nstatic int stv0288_send_diseqc_msg(struct dvb_frontend *fe,\n\t\t\t\t    struct dvb_diseqc_master_cmd *m)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\n\tint i;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tstv0288_writeregI(state, 0x09, 0);\n\tmsleep(30);\n\tstv0288_writeregI(state, 0x05, 0x12); \n\n\tfor (i = 0; i < m->msg_len; i++) {\n\t\tif (stv0288_writeregI(state, 0x06, m->msg[i]))\n\t\t\treturn -EREMOTEIO;\n\t}\n\tmsleep(m->msg_len*12);\n\treturn 0;\n}\n\nstatic int stv0288_send_diseqc_burst(struct dvb_frontend *fe,\n\t\t\t\t     enum fe_sec_mini_cmd burst)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (stv0288_writeregI(state, 0x05, 0x03)) \n\t\treturn -EREMOTEIO;\n\n\tif (stv0288_writeregI(state, 0x06, burst == SEC_MINI_A ? 0x00 : 0xff))\n\t\treturn -EREMOTEIO;\n\n\tmsleep(15);\n\tif (stv0288_writeregI(state, 0x05, 0x12))\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic int stv0288_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\tif (stv0288_writeregI(state, 0x05, 0x10)) \n\t\t\treturn -EREMOTEIO;\n\tbreak;\n\n\tcase SEC_TONE_OFF:\n\t\tif (stv0288_writeregI(state, 0x05, 0x12)) \n\t\t\treturn -EREMOTEIO;\n\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic u8 stv0288_inittab[] = {\n\t0x01, 0x15,\n\t0x02, 0x20,\n\t0x09, 0x0,\n\t0x0a, 0x4,\n\t0x0b, 0x0,\n\t0x0c, 0x0,\n\t0x0d, 0x0,\n\t0x0e, 0xd4,\n\t0x0f, 0x30,\n\t0x11, 0x80,\n\t0x12, 0x03,\n\t0x13, 0x48,\n\t0x14, 0x84,\n\t0x15, 0x45,\n\t0x16, 0xb7,\n\t0x17, 0x9c,\n\t0x18, 0x0,\n\t0x19, 0xa6,\n\t0x1a, 0x88,\n\t0x1b, 0x8f,\n\t0x1c, 0xf0,\n\t0x20, 0x0b,\n\t0x21, 0x54,\n\t0x22, 0x0,\n\t0x23, 0x0,\n\t0x2b, 0xff,\n\t0x2c, 0xf7,\n\t0x30, 0x0,\n\t0x31, 0x1e,\n\t0x32, 0x14,\n\t0x33, 0x0f,\n\t0x34, 0x09,\n\t0x35, 0x0c,\n\t0x36, 0x05,\n\t0x37, 0x2f,\n\t0x38, 0x16,\n\t0x39, 0xbe,\n\t0x3a, 0x0,\n\t0x3b, 0x13,\n\t0x3c, 0x11,\n\t0x3d, 0x30,\n\t0x40, 0x63,\n\t0x41, 0x04,\n\t0x42, 0x20,\n\t0x43, 0x00,\n\t0x44, 0x00,\n\t0x45, 0x00,\n\t0x46, 0x00,\n\t0x47, 0x00,\n\t0x4a, 0x00,\n\t0x50, 0x10,\n\t0x51, 0x38,\n\t0x52, 0x21,\n\t0x58, 0x54,\n\t0x59, 0x86,\n\t0x5a, 0x0,\n\t0x5b, 0x9b,\n\t0x5c, 0x08,\n\t0x5d, 0x7f,\n\t0x5e, 0x0,\n\t0x5f, 0xff,\n\t0x70, 0x0,\n\t0x71, 0x0,\n\t0x72, 0x0,\n\t0x74, 0x0,\n\t0x75, 0x0,\n\t0x76, 0x0,\n\t0x81, 0x0,\n\t0x82, 0x3f,\n\t0x83, 0x3f,\n\t0x84, 0x0,\n\t0x85, 0x0,\n\t0x88, 0x0,\n\t0x89, 0x0,\n\t0x8a, 0x0,\n\t0x8b, 0x0,\n\t0x8c, 0x0,\n\t0x90, 0x0,\n\t0x91, 0x0,\n\t0x92, 0x0,\n\t0x93, 0x0,\n\t0x94, 0x1c,\n\t0x97, 0x0,\n\t0xa0, 0x48,\n\t0xa1, 0x0,\n\t0xb0, 0xb8,\n\t0xb1, 0x3a,\n\t0xb2, 0x10,\n\t0xb3, 0x82,\n\t0xb4, 0x80,\n\t0xb5, 0x82,\n\t0xb6, 0x82,\n\t0xb7, 0x82,\n\t0xb8, 0x20,\n\t0xb9, 0x0,\n\t0xf0, 0x0,\n\t0xf1, 0x0,\n\t0xf2, 0xc0,\n\t0x51, 0x36,\n\t0x52, 0x09,\n\t0x53, 0x94,\n\t0x54, 0x62,\n\t0x55, 0x29,\n\t0x56, 0x64,\n\t0x57, 0x2b,\n\t0xff, 0xff,\n};\n\nstatic int stv0288_set_voltage(struct dvb_frontend *fe,\n\t\t\t       enum fe_sec_voltage volt)\n{\n\tdprintk(\"%s: %s\\n\", __func__,\n\t\tvolt == SEC_VOLTAGE_13 ? \"SEC_VOLTAGE_13\" :\n\t\tvolt == SEC_VOLTAGE_18 ? \"SEC_VOLTAGE_18\" : \"??\");\n\n\treturn 0;\n}\n\nstatic int stv0288_init(struct dvb_frontend *fe)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\tint i;\n\tu8 reg;\n\tu8 val;\n\n\tdprintk(\"stv0288: init chip\\n\");\n\tstv0288_writeregI(state, 0x41, 0x04);\n\tmsleep(50);\n\n\t \n\tif (state->config->inittab == NULL) {\n\t\tfor (i = 0; !(stv0288_inittab[i] == 0xff &&\n\t\t\t\tstv0288_inittab[i + 1] == 0xff); i += 2)\n\t\t\tstv0288_writeregI(state, stv0288_inittab[i],\n\t\t\t\t\tstv0288_inittab[i + 1]);\n\t} else {\n\t\tfor (i = 0; ; i += 2)  {\n\t\t\treg = state->config->inittab[i];\n\t\t\tval = state->config->inittab[i+1];\n\t\t\tif (reg == 0xff && val == 0xff)\n\t\t\t\tbreak;\n\t\t\tstv0288_writeregI(state, reg, val);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int stv0288_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\n\tu8 sync = stv0288_readreg(state, 0x24);\n\tif (sync == 255)\n\t\tsync = 0;\n\n\tdprintk(\"%s : FE_READ_STATUS : VSTATUS: 0x%02x\\n\", __func__, sync);\n\n\t*status = 0;\n\tif (sync & 0x80)\n\t\t*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\n\tif (sync & 0x10)\n\t\t*status |= FE_HAS_VITERBI;\n\tif (sync & 0x08) {\n\t\t*status |= FE_HAS_LOCK;\n\t\tdprintk(\"stv0288 has locked\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int stv0288_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\n\tif (state->errmode != STATUS_BER)\n\t\treturn 0;\n\t*ber = (stv0288_readreg(state, 0x26) << 8) |\n\t\t\t\t\tstv0288_readreg(state, 0x27);\n\tdprintk(\"stv0288_read_ber %d\\n\", *ber);\n\n\treturn 0;\n}\n\n\nstatic int stv0288_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\n\ts32 signal =  0xffff - ((stv0288_readreg(state, 0x10) << 8));\n\n\n\tsignal = signal * 5 / 4;\n\t*strength = (signal > 0xffff) ? 0xffff : (signal < 0) ? 0 : signal;\n\tdprintk(\"stv0288_read_signal_strength %d\\n\", *strength);\n\n\treturn 0;\n}\nstatic int stv0288_sleep(struct dvb_frontend *fe)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\n\tstv0288_writeregI(state, 0x41, 0x84);\n\tstate->initialised = 0;\n\n\treturn 0;\n}\nstatic int stv0288_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\n\ts32 xsnr = 0xffff - ((stv0288_readreg(state, 0x2d) << 8)\n\t\t\t   | stv0288_readreg(state, 0x2e));\n\txsnr = 3 * (xsnr - 0xa100);\n\t*snr = (xsnr > 0xffff) ? 0xffff : (xsnr < 0) ? 0 : xsnr;\n\tdprintk(\"stv0288_read_snr %d\\n\", *snr);\n\n\treturn 0;\n}\n\nstatic int stv0288_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\n\tif (state->errmode != STATUS_BER)\n\t\treturn 0;\n\t*ucblocks = (stv0288_readreg(state, 0x26) << 8) |\n\t\t\t\t\tstv0288_readreg(state, 0x27);\n\tdprintk(\"stv0288_read_ber %d\\n\", *ucblocks);\n\n\treturn 0;\n}\n\nstatic int stv0288_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tu8 tda[3], reg, time_out = 0;\n\ts8 tm;\n\n\tdprintk(\"%s : FE_SET_FRONTEND\\n\", __func__);\n\n\tif (c->delivery_system != SYS_DVBS) {\n\t\tdprintk(\"%s: unsupported delivery system selected (%d)\\n\",\n\t\t\t__func__, c->delivery_system);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (state->config->set_ts_params)\n\t\tstate->config->set_ts_params(fe, 0);\n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tudelay(10);\n\tstv0288_set_symbolrate(fe, c->symbol_rate);\n\t \n\tstv0288_writeregI(state, 0x15, 0xc5);\n\n\ttda[2] = 0x0;  \n\tfor (tm = -9; tm < 7;) {\n\t\t \n\t\treg = stv0288_readreg(state, 0x24);\n\t\tif (reg & 0x8)\n\t\t\t\tbreak;\n\t\tif (reg & 0x80) {\n\t\t\ttime_out++;\n\t\t\tif (time_out > 10)\n\t\t\t\tbreak;\n\t\t\ttda[2] += 40;\n\t\t\tif (tda[2] < 40)\n\t\t\t\ttm++;\n\t\t} else {\n\t\t\ttm++;\n\t\t\ttda[2] = 0;\n\t\t\ttime_out = 0;\n\t\t}\n\t\ttda[1] = (unsigned char)tm;\n\t\tstv0288_writeregI(state, 0x2b, tda[1]);\n\t\tstv0288_writeregI(state, 0x2c, tda[2]);\n\t\tmsleep(30);\n\t}\n\tstate->tuner_frequency = c->frequency;\n\tstate->fec_inner = FEC_AUTO;\n\tstate->symbol_rate = c->symbol_rate;\n\n\treturn 0;\n}\n\nstatic int stv0288_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\n\tif (enable)\n\t\tstv0288_writeregI(state, 0x01, 0xb5);\n\telse\n\t\tstv0288_writeregI(state, 0x01, 0x35);\n\n\tudelay(1);\n\n\treturn 0;\n}\n\nstatic void stv0288_release(struct dvb_frontend *fe)\n{\n\tstruct stv0288_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops stv0288_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name\t\t\t= \"ST STV0288 DVB-S\",\n\t\t.frequency_min_hz\t=  950 * MHz,\n\t\t.frequency_max_hz\t= 2150 * MHz,\n\t\t.frequency_stepsize_hz\t=    1 * MHz,\n\t\t.symbol_rate_min\t= 1000000,\n\t\t.symbol_rate_max\t= 45000000,\n\t\t.symbol_rate_tolerance\t= 500,\t \n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t      FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |\n\t\t      FE_CAN_QPSK |\n\t\t      FE_CAN_FEC_AUTO\n\t},\n\n\t.release = stv0288_release,\n\t.init = stv0288_init,\n\t.sleep = stv0288_sleep,\n\t.write = stv0288_write,\n\t.i2c_gate_ctrl = stv0288_i2c_gate_ctrl,\n\t.read_status = stv0288_read_status,\n\t.read_ber = stv0288_read_ber,\n\t.read_signal_strength = stv0288_read_signal_strength,\n\t.read_snr = stv0288_read_snr,\n\t.read_ucblocks = stv0288_read_ucblocks,\n\t.diseqc_send_master_cmd = stv0288_send_diseqc_msg,\n\t.diseqc_send_burst = stv0288_send_diseqc_burst,\n\t.set_tone = stv0288_set_tone,\n\t.set_voltage = stv0288_set_voltage,\n\n\t.set_frontend = stv0288_set_frontend,\n};\n\nstruct dvb_frontend *stv0288_attach(const struct stv0288_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct stv0288_state *state = NULL;\n\tint id;\n\n\t \n\tstate = kzalloc(sizeof(struct stv0288_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->initialised = 0;\n\tstate->tuner_frequency = 0;\n\tstate->symbol_rate = 0;\n\tstate->fec_inner = 0;\n\tstate->errmode = STATUS_BER;\n\n\tstv0288_writeregI(state, 0x41, 0x04);\n\tmsleep(200);\n\tid = stv0288_readreg(state, 0x00);\n\tdprintk(\"stv0288 id %x\\n\", id);\n\n\t \n\tif (id != 0x11)\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &stv0288_ops,\n\t\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(stv0288_attach);\n\nmodule_param(debug_legacy_dish_switch, int, 0444);\nMODULE_PARM_DESC(debug_legacy_dish_switch,\n\t\t\"Enable timing analysis for Dish Network legacy switches\");\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"ST STV0288 DVB Demodulator driver\");\nMODULE_AUTHOR(\"Georg Acher, Bob Liu, Igor liplianin\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}