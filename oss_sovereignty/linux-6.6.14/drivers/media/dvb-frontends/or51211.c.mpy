{
  "module_name": "or51211.c",
  "hash_id": "cb60e11f90f4a68e1e19e56218aacbcc7017e60b59191a50fc91ba74549c11f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/or51211.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": %s: \" fmt, __func__\n\n \n#define OR51211_DEFAULT_FIRMWARE \"dvb-fe-or51211.fw\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <asm/byteorder.h>\n\n#include <linux/int_log.h>\n#include <media/dvb_frontend.h>\n#include \"or51211.h\"\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { if (debug) pr_debug(args); } while (0)\n\nstatic u8 run_buf[] = {0x7f,0x01};\nstatic u8 cmd_buf[] = {0x04,0x01,0x50,0x80,0x06}; \n\nstruct or51211_state {\n\n\tstruct i2c_adapter* i2c;\n\n\t \n\tconst struct or51211_config* config;\n\n\tstruct dvb_frontend frontend;\n\tstruct bt878* bt;\n\n\t \n\tu8 initialized:1;\n\tu32 snr;  \n\n\t \n\tu32 current_frequency;\n};\n\nstatic int i2c_writebytes (struct or51211_state* state, u8 reg, const u8 *buf,\n\t\t\t   int len)\n{\n\tint err;\n\tstruct i2c_msg msg;\n\tmsg.addr\t= reg;\n\tmsg.flags\t= 0;\n\tmsg.len\t\t= len;\n\tmsg.buf\t\t= (u8 *)buf;\n\n\tif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\n\t\tpr_warn(\"error (addr %02x, err == %i)\\n\", reg, err);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int i2c_readbytes(struct or51211_state *state, u8 reg, u8 *buf, int len)\n{\n\tint err;\n\tstruct i2c_msg msg;\n\tmsg.addr\t= reg;\n\tmsg.flags\t= I2C_M_RD;\n\tmsg.len\t\t= len;\n\tmsg.buf\t\t= buf;\n\n\tif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\n\t\tpr_warn(\"error (addr %02x, err == %i)\\n\", reg, err);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int or51211_load_firmware (struct dvb_frontend* fe,\n\t\t\t\t  const struct firmware *fw)\n{\n\tstruct or51211_state* state = fe->demodulator_priv;\n\tu8 tudata[585];\n\tint i;\n\n\tdprintk(\"Firmware is %zu bytes\\n\", fw->size);\n\n\t \n\ttudata[0] = 17;\n\tif (i2c_writebytes(state,0x50,tudata,1)) {\n\t\tpr_warn(\"error eprom addr\\n\");\n\t\treturn -1;\n\t}\n\tif (i2c_readbytes(state,0x50,&tudata[145],192)) {\n\t\tpr_warn(\"error eprom\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 0; i < 145; i++)\n\t\ttudata[i] = fw->data[i];\n\n\tfor (i = 0; i < 248; i++)\n\t\ttudata[i+337] = fw->data[145+i];\n\n\tstate->config->reset(fe);\n\n\tif (i2c_writebytes(state,state->config->demod_address,tudata,585)) {\n\t\tpr_warn(\"error 1\\n\");\n\t\treturn -1;\n\t}\n\tmsleep(1);\n\n\tif (i2c_writebytes(state,state->config->demod_address,\n\t\t\t   &fw->data[393],8125)) {\n\t\tpr_warn(\"error 2\\n\");\n\t\treturn -1;\n\t}\n\tmsleep(1);\n\n\tif (i2c_writebytes(state,state->config->demod_address,run_buf,2)) {\n\t\tpr_warn(\"error 3\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tmsleep(10);\n\tif (i2c_writebytes(state,state->config->demod_address,run_buf,2)) {\n\t\tpr_warn(\"error 4\\n\");\n\t\treturn -1;\n\t}\n\tmsleep(10);\n\n\tpr_info(\"Done.\\n\");\n\treturn 0;\n};\n\nstatic int or51211_setmode(struct dvb_frontend* fe, int mode)\n{\n\tstruct or51211_state* state = fe->demodulator_priv;\n\tu8 rec_buf[14];\n\n\tstate->config->setmode(fe, mode);\n\n\tif (i2c_writebytes(state,state->config->demod_address,run_buf,2)) {\n\t\tpr_warn(\"error 1\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tmsleep(10);\n\tif (i2c_writebytes(state,state->config->demod_address,run_buf,2)) {\n\t\tpr_warn(\"error 2\\n\");\n\t\treturn -1;\n\t}\n\n\tmsleep(10);\n\n\t \n\tif (i2c_writebytes(state,state->config->demod_address,cmd_buf,3)) {\n\t\tpr_warn(\"error 3\\n\");\n\t\treturn -1;\n\t}\n\n\trec_buf[0] = 0x04;\n\trec_buf[1] = 0x00;\n\trec_buf[2] = 0x03;\n\trec_buf[3] = 0x00;\n\tmsleep(20);\n\tif (i2c_writebytes(state,state->config->demod_address,rec_buf,3)) {\n\t\tpr_warn(\"error 5\\n\");\n\t}\n\tmsleep(3);\n\tif (i2c_readbytes(state,state->config->demod_address,&rec_buf[10],2)) {\n\t\tpr_warn(\"error 6\\n\");\n\t\treturn -1;\n\t}\n\tdprintk(\"rec status %02x %02x\\n\", rec_buf[10], rec_buf[11]);\n\n\treturn 0;\n}\n\nstatic int or51211_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct or51211_state* state = fe->demodulator_priv;\n\n\t \n\tif (state->current_frequency != p->frequency) {\n\t\tif (fe->ops.tuner_ops.set_params) {\n\t\t\tfe->ops.tuner_ops.set_params(fe);\n\t\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t\t}\n\n\t\t \n\t\tor51211_setmode(fe,0);\n\n\t\t \n\t\tstate->current_frequency = p->frequency;\n\t}\n\treturn 0;\n}\n\nstatic int or51211_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct or51211_state* state = fe->demodulator_priv;\n\tunsigned char rec_buf[2];\n\tunsigned char snd_buf[] = {0x04,0x00,0x03,0x00};\n\t*status = 0;\n\n\t \n\tif (i2c_writebytes(state,state->config->demod_address,snd_buf,3)) {\n\t\tpr_warn(\"write error\\n\");\n\t\treturn -1;\n\t}\n\tmsleep(3);\n\tif (i2c_readbytes(state,state->config->demod_address,rec_buf,2)) {\n\t\tpr_warn(\"read error\\n\");\n\t\treturn -1;\n\t}\n\tdprintk(\"%x %x\\n\", rec_buf[0], rec_buf[1]);\n\n\tif (rec_buf[0] &  0x01) {  \n\t\t*status |= FE_HAS_SIGNAL;\n\t\t*status |= FE_HAS_CARRIER;\n\t\t*status |= FE_HAS_VITERBI;\n\t\t*status |= FE_HAS_SYNC;\n\t\t*status |= FE_HAS_LOCK;\n\t}\n\treturn 0;\n}\n\n \n\nstatic u32 calculate_snr(u32 mse, u32 c)\n{\n\tif (mse == 0)  \n\t\treturn 0;\n\n\tmse = 2*intlog10(mse);\n\tif (mse > c) {\n\t\t \n\t\treturn 0;\n\t}\n\treturn 10*(c - mse);\n}\n\nstatic int or51211_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct or51211_state* state = fe->demodulator_priv;\n\tu8 rec_buf[2];\n\tu8 snd_buf[3];\n\n\t \n\tsnd_buf[0] = 0x04;\n\tsnd_buf[1] = 0x00;\n\tsnd_buf[2] = 0x04;\n\n\tif (i2c_writebytes(state,state->config->demod_address,snd_buf,3)) {\n\t\tpr_warn(\"error writing snr reg\\n\");\n\t\treturn -1;\n\t}\n\tif (i2c_readbytes(state,state->config->demod_address,rec_buf,2)) {\n\t\tpr_warn(\"read_status read error\\n\");\n\t\treturn -1;\n\t}\n\n\tstate->snr = calculate_snr(rec_buf[0], 89599047);\n\t*snr = (state->snr) >> 16;\n\n\tdprintk(\"noise = 0x%02x, snr = %d.%02d dB\\n\", rec_buf[0],\n\t\tstate->snr >> 24, (((state->snr>>8) & 0xffff) * 100) >> 16);\n\n\treturn 0;\n}\n\nstatic int or51211_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\t \n\t \n\t \n\tstruct or51211_state* state = (struct or51211_state*)fe->demodulator_priv;\n\tu16 snr;\n\tint ret;\n\n\tret = fe->ops.read_snr(fe, &snr);\n\tif (ret != 0)\n\t\treturn ret;\n\t \n\t \n\tif (state->snr >= 8960 * 0x10000)\n\t\t*strength = 0xffff;\n\telse\n\t\t*strength = state->snr / 8960;\n\n\treturn 0;\n}\n\nstatic int or51211_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\t*ber = -ENOSYS;\n\treturn 0;\n}\n\nstatic int or51211_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\t*ucblocks = -ENOSYS;\n\treturn 0;\n}\n\nstatic int or51211_sleep(struct dvb_frontend* fe)\n{\n\treturn 0;\n}\n\nstatic int or51211_init(struct dvb_frontend* fe)\n{\n\tstruct or51211_state* state = fe->demodulator_priv;\n\tconst struct or51211_config* config = state->config;\n\tconst struct firmware* fw;\n\tunsigned char get_ver_buf[] = {0x04,0x00,0x30,0x00,0x00};\n\tunsigned char rec_buf[14];\n\tint ret,i;\n\n\tif (!state->initialized) {\n\t\t \n\t\tpr_info(\"Waiting for firmware upload (%s)...\\n\",\n\t\t\tOR51211_DEFAULT_FIRMWARE);\n\t\tret = config->request_firmware(fe, &fw,\n\t\t\t\t\t       OR51211_DEFAULT_FIRMWARE);\n\t\tpr_info(\"Got Hotplug firmware\\n\");\n\t\tif (ret) {\n\t\t\tpr_warn(\"No firmware uploaded (timeout or file not found?)\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = or51211_load_firmware(fe, fw);\n\t\trelease_firmware(fw);\n\t\tif (ret) {\n\t\t\tpr_warn(\"Writing firmware to device failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tpr_info(\"Firmware upload complete.\\n\");\n\n\t\t \n\t\tif (i2c_writebytes(state,state->config->demod_address,\n\t\t\t\t   cmd_buf,3)) {\n\t\t\tpr_warn(\"Load DVR Error 5\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\t \n\t\trec_buf[0] = 0x04;\n\t\trec_buf[1] = 0x00;\n\t\trec_buf[2] = 0x03;\n\t\trec_buf[3] = 0x00;\n\t\tmsleep(30);\n\t\tif (i2c_writebytes(state,state->config->demod_address,\n\t\t\t\t   rec_buf,3)) {\n\t\t\tpr_warn(\"Load DVR Error A\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmsleep(3);\n\t\tif (i2c_readbytes(state,state->config->demod_address,\n\t\t\t\t  &rec_buf[10],2)) {\n\t\t\tpr_warn(\"Load DVR Error B\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\trec_buf[0] = 0x04;\n\t\trec_buf[1] = 0x00;\n\t\trec_buf[2] = 0x01;\n\t\trec_buf[3] = 0x00;\n\t\tmsleep(20);\n\t\tif (i2c_writebytes(state,state->config->demod_address,\n\t\t\t\t   rec_buf,3)) {\n\t\t\tpr_warn(\"Load DVR Error C\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmsleep(3);\n\t\tif (i2c_readbytes(state,state->config->demod_address,\n\t\t\t\t  &rec_buf[12],2)) {\n\t\t\tpr_warn(\"Load DVR Error D\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\trec_buf[i]=0xed;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tmsleep(30);\n\t\t\tget_ver_buf[4] = i+1;\n\t\t\tif (i2c_writebytes(state,state->config->demod_address,\n\t\t\t\t\t   get_ver_buf,5)) {\n\t\t\t\tpr_warn(\"Load DVR Error 6 - %d\\n\", i);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmsleep(3);\n\n\t\t\tif (i2c_readbytes(state,state->config->demod_address,\n\t\t\t\t\t  &rec_buf[i*2],2)) {\n\t\t\t\tpr_warn(\"Load DVR Error 7 - %d\\n\", i);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t \n\t\t\tif ((int)rec_buf[i*2+1]!=i+1){\n\t\t\t  i--;\n\t\t\t}\n\t\t}\n\t\tdprintk(\"read_fwbits %10ph\\n\", rec_buf);\n\n\t\tpr_info(\"ver TU%02x%02x%02x VSB mode %02x Status %02x\\n\",\n\t\t\trec_buf[2], rec_buf[4], rec_buf[6], rec_buf[12],\n\t\t\trec_buf[10]);\n\n\t\trec_buf[0] = 0x04;\n\t\trec_buf[1] = 0x00;\n\t\trec_buf[2] = 0x03;\n\t\trec_buf[3] = 0x00;\n\t\tmsleep(20);\n\t\tif (i2c_writebytes(state,state->config->demod_address,\n\t\t\t\t   rec_buf,3)) {\n\t\t\tpr_warn(\"Load DVR Error 8\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmsleep(20);\n\t\tif (i2c_readbytes(state,state->config->demod_address,\n\t\t\t\t  &rec_buf[8],2)) {\n\t\t\tpr_warn(\"Load DVR Error 9\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tstate->initialized = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int or51211_get_tune_settings(struct dvb_frontend* fe,\n\t\t\t\t     struct dvb_frontend_tune_settings* fesettings)\n{\n\tfesettings->min_delay_ms = 500;\n\tfesettings->step_size = 0;\n\tfesettings->max_drift = 0;\n\treturn 0;\n}\n\nstatic void or51211_release(struct dvb_frontend* fe)\n{\n\tstruct or51211_state* state = fe->demodulator_priv;\n\tstate->config->sleep(fe);\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops or51211_ops;\n\nstruct dvb_frontend* or51211_attach(const struct or51211_config* config,\n\t\t\t\t    struct i2c_adapter* i2c)\n{\n\tstruct or51211_state* state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct or51211_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn NULL;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->initialized = 0;\n\tstate->current_frequency = 0;\n\n\t \n\tmemcpy(&state->frontend.ops, &or51211_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n}\n\nstatic const struct dvb_frontend_ops or51211_ops = {\n\t.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },\n\t.info = {\n\t\t.name                  = \"Oren OR51211 VSB Frontend\",\n\t\t.frequency_min_hz      =  44 * MHz,\n\t\t.frequency_max_hz      = 958 * MHz,\n\t\t.frequency_stepsize_hz = 166666,\n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_8VSB\n\t},\n\n\t.release = or51211_release,\n\n\t.init = or51211_init,\n\t.sleep = or51211_sleep,\n\n\t.set_frontend = or51211_set_parameters,\n\t.get_tune_settings = or51211_get_tune_settings,\n\n\t.read_status = or51211_read_status,\n\t.read_ber = or51211_read_ber,\n\t.read_signal_strength = or51211_read_signal_strength,\n\t.read_snr = or51211_read_snr,\n\t.read_ucblocks = or51211_read_ucblocks,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"Oren OR51211 VSB [pcHDTV HD-2000] Demodulator Driver\");\nMODULE_AUTHOR(\"Kirk Lapray\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(or51211_attach);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}