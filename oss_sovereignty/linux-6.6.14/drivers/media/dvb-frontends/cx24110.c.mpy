{
  "module_name": "cx24110.c",
  "hash_id": "f663d3c00c05fce40d36f906eced2ff58a8411a878fc3acd8a74f6fb5d406a9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cx24110.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#include <media/dvb_frontend.h>\n#include \"cx24110.h\"\n\n\nstruct cx24110_state {\n\n\tstruct i2c_adapter* i2c;\n\n\tconst struct cx24110_config* config;\n\n\tstruct dvb_frontend frontend;\n\n\tu32 lastber;\n\tu32 lastbler;\n\tu32 lastesn0;\n};\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) printk(KERN_DEBUG \"cx24110: \" args); \\\n\t} while (0)\n\nstatic struct {u8 reg; u8 data;} cx24110_regdata[]=\n\t\t       \n\t{{0x09,0x01},  \n\t {0x09,0x00},  \n\t {0x01,0xe8},  \n\t {0x02,0x17},  \n\t {0x03,0x29},  \n\t {0x05,0x03},  \n\t {0x06,0xa5},  \n\t {0x07,0x01},  \n\t {0x0a,0x00},  \n\t {0x0b,0x01},  \n\t {0x0c,0x11},  \n\t {0x0d,0x6f},  \n\t {0x10,0x40},  \n\t {0x15,0xff},  \n\t {0x16,0x00},  \n\t {0x17,0x04},  \n\t {0x18,0xae},  \n\t\t       \n\t {0x21,0x10},  \n\t {0x23,0x18},  \n\t {0x24,0x24},  \n\t\t       \n\t\t       \n\t {0x35,0x40},  \n\t {0x36,0xff},  \n\t {0x37,0x00},  \n\t {0x38,0x07},  \n\t\t       \n\t\t       \n\t {0x41,0x00},  \n\t {0x42,0x00},  \n\t {0x43,0x00},  \n\t\t       \n\t\t       \n\t {0x56,0x4d},  \n\t\t       \n\t {0x57,0x00},  \n\t {0x61,0x95},  \n\t {0x62,0x05},  \n\t {0x63,0x00},  \n\t {0x64,0x20},  \n\t {0x6d,0x30},  \n\t {0x70,0x15},  \n\t {0x73,0x00},  \n\t {0x74,0x00},  \n\t {0x75,0x00}   \n\t\t       \n\t};\n\n\nstatic int cx24110_writereg (struct cx24110_state* state, int reg, int data)\n{\n\tu8 buf [] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\n\tint err;\n\n\tif ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {\n\t\tdprintk(\"%s: writereg error (err == %i, reg == 0x%02x, data == 0x%02x)\\n\",\n\t\t\t__func__, err, reg, data);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cx24110_readreg (struct cx24110_state* state, u8 reg)\n{\n\tint ret;\n\tu8 b0 [] = { reg };\n\tu8 b1 [] = { 0 };\n\tstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },\n\t\t\t   { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) return ret;\n\n\treturn b1[0];\n}\n\nstatic int cx24110_set_inversion(struct cx24110_state *state,\n\t\t\t\t enum fe_spectral_inversion inversion)\n{\n \n\n\tswitch (inversion) {\n\tcase INVERSION_OFF:\n\t\tcx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x1);\n\t\t \n\t\tcx24110_writereg(state,0x5,cx24110_readreg(state,0x5)&0xf7);\n\t\t \n\t\tcx24110_writereg(state,0x22,cx24110_readreg(state,0x22)&0xef);\n\t\t \n\t\t \n\t\tbreak;\n\tcase INVERSION_ON:\n\t\tcx24110_writereg(state,0x37,cx24110_readreg(state,0x37)|0x1);\n\t\t \n\t\tcx24110_writereg(state,0x5,cx24110_readreg(state,0x5)|0x08);\n\t\t \n\t\tcx24110_writereg(state,0x22,cx24110_readreg(state,0x22)|0x10);\n\t\t \n\t\tbreak;\n\tcase INVERSION_AUTO:\n\t\tcx24110_writereg(state,0x37,cx24110_readreg(state,0x37)&0xfe);\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cx24110_set_fec(struct cx24110_state *state, enum fe_code_rate fec)\n{\n\tstatic const int rate[FEC_AUTO] = {-1,    1,    2,    3,    5,    7, -1};\n\tstatic const int g1[FEC_AUTO]   = {-1, 0x01, 0x02, 0x05, 0x15, 0x45, -1};\n\tstatic const int g2[FEC_AUTO]   = {-1, 0x01, 0x03, 0x06, 0x1a, 0x7a, -1};\n\n\t \n\n\tif (fec > FEC_AUTO)\n\t\tfec = FEC_AUTO;\n\n\tif (fec == FEC_AUTO) {  \n\t\tcx24110_writereg(state, 0x37, cx24110_readreg(state, 0x37) & 0xdf);\n\t\t \n\t\tcx24110_writereg(state, 0x18, 0xae);\n\t\t \n\t\tcx24110_writereg(state, 0x05, (cx24110_readreg(state, 0x05) & 0xf0) | 0x3);\n\t\t \n\t\tcx24110_writereg(state, 0x22, (cx24110_readreg(state, 0x22) & 0xf0) | 0x3);\n\t\t \n\t\tcx24110_writereg(state, 0x1a, 0x05);\n\t\tcx24110_writereg(state, 0x1b, 0x06);\n\t\t \n\t\treturn 0;\n\t} else {\n\t\tcx24110_writereg(state, 0x37, cx24110_readreg(state, 0x37) | 0x20);\n\t\t \n\t\tif (rate[fec] < 0)\n\t\t\treturn -EINVAL;\n\n\t\tcx24110_writereg(state, 0x05, (cx24110_readreg(state, 0x05) & 0xf0) | rate[fec]);\n\t\t \n\t\tcx24110_writereg(state, 0x22, (cx24110_readreg(state, 0x22) & 0xf0) | rate[fec]);\n\t\t \n\t\tcx24110_writereg(state, 0x1a, g1[fec]);\n\t\tcx24110_writereg(state, 0x1b, g2[fec]);\n\t\t \n\t}\n\treturn 0;\n}\n\nstatic enum fe_code_rate cx24110_get_fec(struct cx24110_state *state)\n{\n\tint i;\n\n\ti=cx24110_readreg(state,0x22)&0x0f;\n\tif(!(i&0x08)) {\n\t\treturn FEC_1_2 + i - 1;\n\t} else {\n \n\t   return FEC_NONE;\n\t}\n}\n\nstatic int cx24110_set_symbolrate (struct cx24110_state* state, u32 srate)\n{\n \n\tu32 ratio;\n\tu32 tmp, fclk, BDRI;\n\n\tstatic const u32 bands[]={5000000UL,15000000UL,90999000UL/2};\n\tint i;\n\n\tdprintk(\"cx24110 debug: entering %s(%d)\\n\",__func__,srate);\n\tif (srate>90999000UL/2)\n\t\tsrate=90999000UL/2;\n\tif (srate<500000)\n\t\tsrate=500000;\n\n\tfor(i = 0; (i < ARRAY_SIZE(bands)) && (srate>bands[i]); i++)\n\t\t;\n\t \n\ttmp=cx24110_readreg(state,0x07)&0xfc;\n\tif(srate<90999000UL/4) {  \n\t\tcx24110_writereg(state,0x07,tmp);\n\t\tcx24110_writereg(state,0x06,0x78);\n\t\tfclk=90999000UL/2;\n\t} else if(srate<60666000UL/2) {  \n\t\tcx24110_writereg(state,0x07,tmp|0x1);\n\t\tcx24110_writereg(state,0x06,0xa5);\n\t\tfclk=60666000UL;\n\t} else if(srate<80888000UL/2) {  \n\t\tcx24110_writereg(state,0x07,tmp|0x2);\n\t\tcx24110_writereg(state,0x06,0x87);\n\t\tfclk=80888000UL;\n\t} else {  \n\t\tcx24110_writereg(state,0x07,tmp|0x3);\n\t\tcx24110_writereg(state,0x06,0x78);\n\t\tfclk=90999000UL;\n\t}\n\tdprintk(\"cx24110 debug: fclk %d Hz\\n\",fclk);\n\t \n\t \n\n\ttmp=srate<<6;\n\tBDRI=fclk>>2;\n\tratio=(tmp/BDRI);\n\n\ttmp=(tmp%BDRI)<<8;\n\tratio=(ratio<<8)+(tmp/BDRI);\n\n\ttmp=(tmp%BDRI)<<8;\n\tratio=(ratio<<8)+(tmp/BDRI);\n\n\ttmp=(tmp%BDRI)<<1;\n\tratio=(ratio<<1)+(tmp/BDRI);\n\n\tdprintk(\"srate= %d (range %d, up to %d)\\n\", srate,i,bands[i]);\n\tdprintk(\"fclk = %d\\n\", fclk);\n\tdprintk(\"ratio= %08x\\n\", ratio);\n\n\tcx24110_writereg(state, 0x1, (ratio>>16)&0xff);\n\tcx24110_writereg(state, 0x2, (ratio>>8)&0xff);\n\tcx24110_writereg(state, 0x3, (ratio)&0xff);\n\n\treturn 0;\n\n}\n\nstatic int _cx24110_pll_write (struct dvb_frontend* fe, const u8 buf[], int len)\n{\n\tstruct cx24110_state *state = fe->demodulator_priv;\n\n\tif (len != 3)\n\t\treturn -EINVAL;\n\n \n \n \n\n\tcx24110_writereg(state,0x6d,0x30);  \n\tcx24110_writereg(state,0x70,0x15);  \n\n\t \n\twhile (cx24110_readreg(state,0x6d)&0x80)\n\t\tcx24110_writereg(state,0x72,0);\n\n\t \n\tcx24110_writereg(state,0x72,buf[0]);\n\n\t \n\twhile ((cx24110_readreg(state,0x6d)&0xc0)==0x80)\n\t\t;\n\n\t \n\tcx24110_writereg(state,0x72,buf[1]);\n\twhile ((cx24110_readreg(state,0x6d)&0xc0)==0x80)\n\t\t;\n\n\t \n\tcx24110_writereg(state,0x72,buf[2]);\n\twhile ((cx24110_readreg(state,0x6d)&0xc0)==0x80)\n\t\t;\n\n\t \n\tcx24110_writereg(state,0x6d,0x32);\n\tcx24110_writereg(state,0x6d,0x30);\n\n\treturn 0;\n}\n\nstatic int cx24110_initfe(struct dvb_frontend* fe)\n{\n\tstruct cx24110_state *state = fe->demodulator_priv;\n \n\tint i;\n\n\tdprintk(\"%s: init chip\\n\", __func__);\n\n\tfor(i = 0; i < ARRAY_SIZE(cx24110_regdata); i++) {\n\t\tcx24110_writereg(state, cx24110_regdata[i].reg, cx24110_regdata[i].data);\n\t}\n\n\treturn 0;\n}\n\nstatic int cx24110_set_voltage(struct dvb_frontend *fe,\n\t\t\t       enum fe_sec_voltage voltage)\n{\n\tstruct cx24110_state *state = fe->demodulator_priv;\n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_13:\n\t\treturn cx24110_writereg(state,0x76,(cx24110_readreg(state,0x76)&0x3b)|0xc0);\n\tcase SEC_VOLTAGE_18:\n\t\treturn cx24110_writereg(state,0x76,(cx24110_readreg(state,0x76)&0x3b)|0x40);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int cx24110_diseqc_send_burst(struct dvb_frontend *fe,\n\t\t\t\t     enum fe_sec_mini_cmd burst)\n{\n\tint rv, bit;\n\tstruct cx24110_state *state = fe->demodulator_priv;\n\tunsigned long timeout;\n\n\tif (burst == SEC_MINI_A)\n\t\tbit = 0x00;\n\telse if (burst == SEC_MINI_B)\n\t\tbit = 0x08;\n\telse\n\t\treturn -EINVAL;\n\n\trv = cx24110_readreg(state, 0x77);\n\tif (!(rv & 0x04))\n\t\tcx24110_writereg(state, 0x77, rv | 0x04);\n\n\trv = cx24110_readreg(state, 0x76);\n\tcx24110_writereg(state, 0x76, ((rv & 0x90) | 0x40 | bit));\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\twhile (!time_after(jiffies, timeout) && !(cx24110_readreg(state, 0x76) & 0x40))\n\t\t;  \n\n\treturn 0;\n}\n\nstatic int cx24110_send_diseqc_msg(struct dvb_frontend* fe,\n\t\t\t\t   struct dvb_diseqc_master_cmd *cmd)\n{\n\tint i, rv;\n\tstruct cx24110_state *state = fe->demodulator_priv;\n\tunsigned long timeout;\n\n\tif (cmd->msg_len < 3 || cmd->msg_len > 6)\n\t\treturn -EINVAL;   \n\n\tfor (i = 0; i < cmd->msg_len; i++)\n\t\tcx24110_writereg(state, 0x79 + i, cmd->msg[i]);\n\n\trv = cx24110_readreg(state, 0x77);\n\tif (rv & 0x04) {\n\t\tcx24110_writereg(state, 0x77, rv & ~0x04);\n\t\tmsleep(30);  \n\t}\n\n\trv = cx24110_readreg(state, 0x76);\n\n\tcx24110_writereg(state, 0x76, ((rv & 0x90) | 0x40) | ((cmd->msg_len-3) & 3));\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\twhile (!time_after(jiffies, timeout) && !(cx24110_readreg(state, 0x76) & 0x40))\n\t\t;  \n\n\treturn 0;\n}\n\nstatic int cx24110_read_status(struct dvb_frontend *fe,\n\t\t\t       enum fe_status *status)\n{\n\tstruct cx24110_state *state = fe->demodulator_priv;\n\n\tint sync = cx24110_readreg (state, 0x55);\n\n\t*status = 0;\n\n\tif (sync & 0x10)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (sync & 0x08)\n\t\t*status |= FE_HAS_CARRIER;\n\n\tsync = cx24110_readreg (state, 0x08);\n\n\tif (sync & 0x40)\n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (sync & 0x20)\n\t\t*status |= FE_HAS_SYNC;\n\n\tif ((sync & 0x60) == 0x60)\n\t\t*status |= FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int cx24110_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct cx24110_state *state = fe->demodulator_priv;\n\n\t \n\tif(cx24110_readreg(state,0x24)&0x10) {\n\t\t \n\t\tcx24110_writereg(state,0x24,0x04);  \n\t\tstate->lastber=cx24110_readreg(state,0x25)|\n\t\t\t(cx24110_readreg(state,0x26)<<8);\n\t\tcx24110_writereg(state,0x24,0x04);  \n\t\tcx24110_writereg(state,0x24,0x14);\n\t}\n\t*ber = state->lastber;\n\n\treturn 0;\n}\n\nstatic int cx24110_read_signal_strength(struct dvb_frontend* fe, u16* signal_strength)\n{\n\tstruct cx24110_state *state = fe->demodulator_priv;\n\n \n\tu8 signal = cx24110_readreg (state, 0x27)+128;\n\t*signal_strength = (signal << 8) | signal;\n\n\treturn 0;\n}\n\nstatic int cx24110_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct cx24110_state *state = fe->demodulator_priv;\n\n\t \n\tif(cx24110_readreg(state,0x6a)&0x80) {\n\t\t \n\t\tstate->lastesn0=cx24110_readreg(state,0x69)|\n\t\t\t(cx24110_readreg(state,0x68)<<8);\n\t\tcx24110_writereg(state,0x6a,0x84);  \n\t}\n\t*snr = state->lastesn0;\n\n\treturn 0;\n}\n\nstatic int cx24110_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct cx24110_state *state = fe->demodulator_priv;\n\n\tif(cx24110_readreg(state,0x10)&0x40) {\n\t\t \n\t\tcx24110_writereg(state,0x10,0x60);  \n\t\t(void)(cx24110_readreg(state, 0x12) |\n\t\t\t(cx24110_readreg(state, 0x13) << 8) |\n\t\t\t(cx24110_readreg(state, 0x14) << 16));\n\t\tcx24110_writereg(state,0x10,0x70);  \n\t\tstate->lastbler=cx24110_readreg(state,0x12)|\n\t\t\t(cx24110_readreg(state,0x13)<<8)|\n\t\t\t(cx24110_readreg(state,0x14)<<16);\n\t\tcx24110_writereg(state,0x10,0x20);  \n\t}\n\t*ucblocks = state->lastbler;\n\n\treturn 0;\n}\n\nstatic int cx24110_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct cx24110_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tcx24110_set_inversion(state, p->inversion);\n\tcx24110_set_fec(state, p->fec_inner);\n\tcx24110_set_symbolrate(state, p->symbol_rate);\n\tcx24110_writereg(state,0x04,0x05);  \n\n\treturn 0;\n}\n\nstatic int cx24110_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct cx24110_state *state = fe->demodulator_priv;\n\ts32 afc; unsigned sclk;\n\n \n\n\tsclk = cx24110_readreg (state, 0x07) & 0x03;\n \n\tif (sclk==0) sclk=90999000L/2L;\n\telse if (sclk==1) sclk=60666000L;\n\telse if (sclk==2) sclk=80888000L;\n\telse sclk=90999000L;\n\tsclk>>=8;\n\tafc = sclk*(cx24110_readreg (state, 0x44)&0x1f)+\n\t      ((sclk*cx24110_readreg (state, 0x45))>>8)+\n\t      ((sclk*cx24110_readreg (state, 0x46))>>16);\n\n\tp->frequency += afc;\n\tp->inversion = (cx24110_readreg (state, 0x22) & 0x10) ?\n\t\t\t\tINVERSION_ON : INVERSION_OFF;\n\tp->fec_inner = cx24110_get_fec(state);\n\n\treturn 0;\n}\n\nstatic int cx24110_set_tone(struct dvb_frontend *fe,\n\t\t\t    enum fe_sec_tone_mode tone)\n{\n\tstruct cx24110_state *state = fe->demodulator_priv;\n\n\treturn cx24110_writereg(state,0x76,(cx24110_readreg(state,0x76)&~0x10)|(((tone==SEC_TONE_ON))?0x10:0));\n}\n\nstatic void cx24110_release(struct dvb_frontend* fe)\n{\n\tstruct cx24110_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops cx24110_ops;\n\nstruct dvb_frontend* cx24110_attach(const struct cx24110_config* config,\n\t\t\t\t    struct i2c_adapter* i2c)\n{\n\tstruct cx24110_state* state = NULL;\n\tint ret;\n\n\t \n\tstate = kzalloc(sizeof(struct cx24110_state), GFP_KERNEL);\n\tif (state == NULL) goto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->lastber = 0;\n\tstate->lastbler = 0;\n\tstate->lastesn0 = 0;\n\n\t \n\tret = cx24110_readreg(state, 0x00);\n\tif ((ret != 0x5a) && (ret != 0x69)) goto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &cx24110_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops cx24110_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name = \"Conexant CX24110 DVB-S\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t\t.frequency_stepsize_hz = 1011 * kHz,\n\t\t.frequency_tolerance_hz = 29500 * kHz,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_RECOVER\n\t},\n\n\t.release = cx24110_release,\n\n\t.init = cx24110_initfe,\n\t.write = _cx24110_pll_write,\n\t.set_frontend = cx24110_set_frontend,\n\t.get_frontend = cx24110_get_frontend,\n\t.read_status = cx24110_read_status,\n\t.read_ber = cx24110_read_ber,\n\t.read_signal_strength = cx24110_read_signal_strength,\n\t.read_snr = cx24110_read_snr,\n\t.read_ucblocks = cx24110_read_ucblocks,\n\n\t.diseqc_send_master_cmd = cx24110_send_diseqc_msg,\n\t.set_tone = cx24110_set_tone,\n\t.set_voltage = cx24110_set_voltage,\n\t.diseqc_send_burst = cx24110_diseqc_send_burst,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"Conexant CX24110 DVB-S Demodulator driver\");\nMODULE_AUTHOR(\"Peter Hettkamp\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(cx24110_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}