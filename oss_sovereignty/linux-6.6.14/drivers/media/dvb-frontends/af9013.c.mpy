{
  "module_name": "af9013.c",
  "hash_id": "e5c9b233871ddd242086386255fed4138cd873652ddc46d8b99d844efb5ece79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/af9013.c",
  "human_readable_source": "\n \n\n#include \"af9013_priv.h\"\n\nstruct af9013_state {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct i2c_mux_core *muxc;\n\tstruct dvb_frontend fe;\n\tu32 clk;\n\tu8 tuner;\n\tu32 if_frequency;\n\tu8 ts_mode;\n\tu8 ts_output_pin;\n\tbool spec_inv;\n\tu8 api_version[4];\n\tu8 gpio[4];\n\n\tu32 bandwidth_hz;\n\tenum fe_status fe_status;\n\t \n\tu8 strength_en, rf_agc_50, rf_agc_80, if_agc_50, if_agc_80;\n\tunsigned long set_frontend_jiffies;\n\tunsigned long read_status_jiffies;\n\tunsigned long strength_jiffies;\n\tunsigned long cnr_jiffies;\n\tunsigned long ber_ucb_jiffies;\n\tu16 dvbv3_snr;\n\tu16 dvbv3_strength;\n\tu32 dvbv3_ber;\n\tu32 dvbv3_ucblocks;\n\tbool first_tune;\n};\n\nstatic int af9013_set_gpio(struct af9013_state *state, u8 gpio, u8 gpioval)\n{\n\tstruct i2c_client *client = state->client;\n\tint ret;\n\tu8 pos;\n\tu16 addr;\n\n\tdev_dbg(&client->dev, \"gpio %u, gpioval %02x\\n\", gpio, gpioval);\n\n\t \n\n\tswitch (gpio) {\n\tcase 0:\n\tcase 1:\n\t\taddr = 0xd735;\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\taddr = 0xd736;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tswitch (gpio) {\n\tcase 0:\n\tcase 2:\n\t\tpos = 0;\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\tdefault:\n\t\tpos = 4;\n\t\tbreak;\n\t}\n\n\tret = regmap_update_bits(state->regmap, addr, 0x0f << pos,\n\t\t\t\t gpioval << pos);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9013_get_tune_settings(struct dvb_frontend *fe,\n\tstruct dvb_frontend_tune_settings *fesettings)\n{\n\tfesettings->min_delay_ms = 800;\n\tfesettings->step_size = 0;\n\tfesettings->max_drift = 0;\n\n\treturn 0;\n}\n\nstatic int af9013_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct af9013_state *state = fe->demodulator_priv;\n\tstruct i2c_client *client = state->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i, sampling_freq;\n\tbool auto_mode, spec_inv;\n\tu8 buf[6];\n\tu32 if_frequency, freq_cw;\n\n\tdev_dbg(&client->dev, \"frequency %u, bandwidth_hz %u\\n\",\n\t\tc->frequency, c->bandwidth_hz);\n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (c->bandwidth_hz != state->bandwidth_hz) {\n\t\tfor (i = 0; i < ARRAY_SIZE(coeff_lut); i++) {\n\t\t\tif (coeff_lut[i].clock == state->clk &&\n\t\t\t\tcoeff_lut[i].bandwidth_hz == c->bandwidth_hz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (i == ARRAY_SIZE(coeff_lut)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = regmap_bulk_write(state->regmap, 0xae00, coeff_lut[i].val,\n\t\t\t\t\tsizeof(coeff_lut[i].val));\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (c->bandwidth_hz != state->bandwidth_hz || state->first_tune) {\n\t\t \n\t\tif (fe->ops.tuner_ops.get_if_frequency) {\n\t\t\tret = fe->ops.tuner_ops.get_if_frequency(fe,\n\t\t\t\t\t\t\t\t &if_frequency);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\tif_frequency = state->if_frequency;\n\t\t}\n\n\t\tdev_dbg(&client->dev, \"if_frequency %u\\n\", if_frequency);\n\n\t\tsampling_freq = if_frequency;\n\n\t\twhile (sampling_freq > (state->clk / 2))\n\t\t\tsampling_freq -= state->clk;\n\n\t\tif (sampling_freq < 0) {\n\t\t\tsampling_freq *= -1;\n\t\t\tspec_inv = state->spec_inv;\n\t\t} else {\n\t\t\tspec_inv = !state->spec_inv;\n\t\t}\n\n\t\tfreq_cw = DIV_ROUND_CLOSEST_ULL((u64)sampling_freq * 0x800000,\n\t\t\t\t\t\tstate->clk);\n\n\t\tif (spec_inv)\n\t\t\tfreq_cw = 0x800000 - freq_cw;\n\n\t\tbuf[0] = (freq_cw >>  0) & 0xff;\n\t\tbuf[1] = (freq_cw >>  8) & 0xff;\n\t\tbuf[2] = (freq_cw >> 16) & 0x7f;\n\n\t\tfreq_cw = 0x800000 - freq_cw;\n\n\t\tbuf[3] = (freq_cw >>  0) & 0xff;\n\t\tbuf[4] = (freq_cw >>  8) & 0xff;\n\t\tbuf[5] = (freq_cw >> 16) & 0x7f;\n\n\t\tret = regmap_bulk_write(state->regmap, 0xd140, buf, 3);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = regmap_bulk_write(state->regmap, 0x9be7, buf, 6);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tret = regmap_update_bits(state->regmap, 0xd330, 0x08, 0x08);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_update_bits(state->regmap, 0xd507, 0x40, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_update_bits(state->regmap, 0x9bfe, 0x01, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_update_bits(state->regmap, 0x9bc2, 0x01, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tauto_mode = false;\n\tmemset(buf, 0, 3);\n\n\tswitch (c->transmission_mode) {\n\tcase TRANSMISSION_MODE_AUTO:\n\t\tauto_mode = true;\n\t\tbreak;\n\tcase TRANSMISSION_MODE_2K:\n\t\tbreak;\n\tcase TRANSMISSION_MODE_8K:\n\t\tbuf[0] |= (1 << 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid transmission_mode\\n\");\n\t\tauto_mode = true;\n\t}\n\n\tswitch (c->guard_interval) {\n\tcase GUARD_INTERVAL_AUTO:\n\t\tauto_mode = true;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_32:\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_16:\n\t\tbuf[0] |= (1 << 2);\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_8:\n\t\tbuf[0] |= (2 << 2);\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_4:\n\t\tbuf[0] |= (3 << 2);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid guard_interval\\n\");\n\t\tauto_mode = true;\n\t}\n\n\tswitch (c->hierarchy) {\n\tcase HIERARCHY_AUTO:\n\t\tauto_mode = true;\n\t\tbreak;\n\tcase HIERARCHY_NONE:\n\t\tbreak;\n\tcase HIERARCHY_1:\n\t\tbuf[0] |= (1 << 4);\n\t\tbreak;\n\tcase HIERARCHY_2:\n\t\tbuf[0] |= (2 << 4);\n\t\tbreak;\n\tcase HIERARCHY_4:\n\t\tbuf[0] |= (3 << 4);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid hierarchy\\n\");\n\t\tauto_mode = true;\n\t}\n\n\tswitch (c->modulation) {\n\tcase QAM_AUTO:\n\t\tauto_mode = true;\n\t\tbreak;\n\tcase QPSK:\n\t\tbreak;\n\tcase QAM_16:\n\t\tbuf[1] |= (1 << 6);\n\t\tbreak;\n\tcase QAM_64:\n\t\tbuf[1] |= (2 << 6);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid modulation\\n\");\n\t\tauto_mode = true;\n\t}\n\n\t \n\tbuf[1] |= (1 << 4);\n\n\tswitch (c->code_rate_HP) {\n\tcase FEC_AUTO:\n\t\tauto_mode = true;\n\t\tbreak;\n\tcase FEC_1_2:\n\t\tbreak;\n\tcase FEC_2_3:\n\t\tbuf[2] |= (1 << 0);\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tbuf[2] |= (2 << 0);\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tbuf[2] |= (3 << 0);\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tbuf[2] |= (4 << 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid code_rate_HP\\n\");\n\t\tauto_mode = true;\n\t}\n\n\tswitch (c->code_rate_LP) {\n\tcase FEC_AUTO:\n\t\tauto_mode = true;\n\t\tbreak;\n\tcase FEC_1_2:\n\t\tbreak;\n\tcase FEC_2_3:\n\t\tbuf[2] |= (1 << 3);\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tbuf[2] |= (2 << 3);\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tbuf[2] |= (3 << 3);\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tbuf[2] |= (4 << 3);\n\t\tbreak;\n\tcase FEC_NONE:\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid code_rate_LP\\n\");\n\t\tauto_mode = true;\n\t}\n\n\tswitch (c->bandwidth_hz) {\n\tcase 6000000:\n\t\tbreak;\n\tcase 7000000:\n\t\tbuf[1] |= (1 << 2);\n\t\tbreak;\n\tcase 8000000:\n\t\tbuf[1] |= (2 << 2);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid bandwidth_hz\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = regmap_bulk_write(state->regmap, 0xd3c0, buf, 3);\n\tif (ret)\n\t\tgoto err;\n\n\tif (auto_mode) {\n\t\t \n\t\tret = regmap_write(state->regmap, 0xaefd, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdev_dbg(&client->dev, \"auto params\\n\");\n\t} else {\n\t\t \n\t\tret = regmap_write(state->regmap, 0xaefd, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = regmap_write(state->regmap, 0xaefe, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdev_dbg(&client->dev, \"manual params\\n\");\n\t}\n\n\t \n\tret = regmap_write(state->regmap, 0xffff, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tstate->bandwidth_hz = c->bandwidth_hz;\n\tstate->set_frontend_jiffies = jiffies;\n\tstate->first_tune = false;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9013_get_frontend(struct dvb_frontend *fe,\n\t\t\t       struct dtv_frontend_properties *c)\n{\n\tstruct af9013_state *state = fe->demodulator_priv;\n\tstruct i2c_client *client = state->client;\n\tint ret;\n\tu8 buf[3];\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tret = regmap_bulk_read(state->regmap, 0xd3c0, buf, 3);\n\tif (ret)\n\t\tgoto err;\n\n\tswitch ((buf[1] >> 6) & 3) {\n\tcase 0:\n\t\tc->modulation = QPSK;\n\t\tbreak;\n\tcase 1:\n\t\tc->modulation = QAM_16;\n\t\tbreak;\n\tcase 2:\n\t\tc->modulation = QAM_64;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[0] >> 0) & 3) {\n\tcase 0:\n\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n\tcase 1:\n\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t}\n\n\tswitch ((buf[0] >> 2) & 3) {\n\tcase 0:\n\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\tc->guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tc->guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[0] >> 4) & 7) {\n\tcase 0:\n\t\tc->hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tc->hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tcase 2:\n\t\tc->hierarchy = HIERARCHY_2;\n\t\tbreak;\n\tcase 3:\n\t\tc->hierarchy = HIERARCHY_4;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[2] >> 0) & 7) {\n\tcase 0:\n\t\tc->code_rate_HP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tc->code_rate_HP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tc->code_rate_HP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tc->code_rate_HP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tc->code_rate_HP = FEC_7_8;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[2] >> 3) & 7) {\n\tcase 0:\n\t\tc->code_rate_LP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tc->code_rate_LP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tc->code_rate_LP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tc->code_rate_LP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tc->code_rate_LP = FEC_7_8;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[1] >> 2) & 3) {\n\tcase 0:\n\t\tc->bandwidth_hz = 6000000;\n\t\tbreak;\n\tcase 1:\n\t\tc->bandwidth_hz = 7000000;\n\t\tbreak;\n\tcase 2:\n\t\tc->bandwidth_hz = 8000000;\n\t\tbreak;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9013_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct af9013_state *state = fe->demodulator_priv;\n\tstruct i2c_client *client = state->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, stmp1;\n\tunsigned int utmp, utmp1, utmp2, utmp3, utmp4;\n\tu8 buf[7];\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tif (time_is_after_jiffies(state->read_status_jiffies + msecs_to_jiffies(2000)) &&\n\t    time_is_before_jiffies(state->set_frontend_jiffies + msecs_to_jiffies(4000))) {\n\t\t*status = state->fe_status;\n\t} else {\n\t\t \n\t\tret = regmap_read(state->regmap, 0xd507, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif ((utmp >> 6) & 0x01) {\n\t\t\tutmp1 = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\tFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\t\t} else {\n\t\t\t \n\t\t\tret = regmap_read(state->regmap, 0xd330, &utmp);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tif ((utmp >> 3) & 0x01)\n\t\t\t\tutmp1 = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t\tFE_HAS_VITERBI;\n\t\t\telse\n\t\t\t\tutmp1 = 0;\n\t\t}\n\n\t\tdev_dbg(&client->dev, \"fe_status %02x\\n\", utmp1);\n\n\t\tstate->read_status_jiffies = jiffies;\n\n\t\tstate->fe_status = utmp1;\n\t\t*status = utmp1;\n\t}\n\n\t \n\tswitch (state->strength_en) {\n\tcase 0:\n\t\t \n\t\tret = regmap_read(state->regmap, 0x9bee, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif ((utmp >> 0) & 0x01) {\n\t\t\t \n\t\t\tret = regmap_read(state->regmap, 0x9bbd, &utmp1);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tret = regmap_read(state->regmap, 0x9bd0, &utmp2);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tret = regmap_read(state->regmap, 0x9be2, &utmp3);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tret = regmap_read(state->regmap, 0x9be4, &utmp4);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tstate->rf_agc_50 = utmp1;\n\t\t\tstate->rf_agc_80 = utmp2;\n\t\t\tstate->if_agc_50 = utmp3;\n\t\t\tstate->if_agc_80 = utmp4;\n\t\t\tdev_dbg(&client->dev,\n\t\t\t\t\"rf_agc_50 %u, rf_agc_80 %u, if_agc_50 %u, if_agc_80 %u\\n\",\n\t\t\t\tutmp1, utmp2, utmp3, utmp4);\n\n\t\t\tstate->strength_en = 1;\n\t\t} else {\n\t\t\t \n\t\t\tstate->strength_en = 2;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase 1:\n\t\tif (time_is_after_jiffies(state->strength_jiffies + msecs_to_jiffies(2000)))\n\t\t\tbreak;\n\n\t\t \n\t\tret = regmap_bulk_read(state->regmap, 0xd07c, buf, 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\t#define agc_gain (buf[0] + buf[1])\n\t\t#define agc_gain_50dbm (state->rf_agc_50 + state->if_agc_50)\n\t\t#define agc_gain_80dbm (state->rf_agc_80 + state->if_agc_80)\n\t\tstmp1 = 30000 * (agc_gain - agc_gain_80dbm) /\n\t\t\t(agc_gain_50dbm - agc_gain_80dbm) - 80000;\n\n\t\tdev_dbg(&client->dev,\n\t\t\t\"strength %d, agc_gain %d, agc_gain_50dbm %d, agc_gain_80dbm %d\\n\",\n\t\t\tstmp1, agc_gain, agc_gain_50dbm, agc_gain_80dbm);\n\n\t\tstate->strength_jiffies = jiffies;\n\t\t \n\t\tutmp1 = clamp(stmp1 + 90000, 0, 60000);\n\t\tstate->dvbv3_strength = div_u64((u64)utmp1 * 0xffff, 60000);\n\n\t\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->strength.stat[0].svalue = stmp1;\n\t\tbreak;\n\tdefault:\n\t\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (state->fe_status & FE_HAS_VITERBI) {\n\tcase FE_HAS_VITERBI:\n\t\tif (time_is_after_jiffies(state->cnr_jiffies + msecs_to_jiffies(2000)))\n\t\t\tbreak;\n\n\t\t \n\t\tret = regmap_read(state->regmap, 0xd2e1, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!((utmp >> 3) & 0x01)) {\n\t\t\tdev_dbg(&client->dev, \"cnr not ready\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = regmap_bulk_read(state->regmap, 0xd2e3, buf, 3);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp1 = buf[2] << 16 | buf[1] << 8 | buf[0] << 0;\n\n\t\t \n\t\tret = regmap_read(state->regmap, 0xd3c1, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tswitch ((utmp >> 6) & 3) {\n\t\tcase 0:\n\t\t\t \n\t\t\tutmp1 = clamp(utmp1, 653799U, 1689999U);\n\t\t\tutmp1 = ((u64)(intlog10(utmp1)\n\t\t\t\t- intlog10(1690000 - utmp1)\n\t\t\t\t+ 3355443) * 13 * 1000) >> 24;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tutmp1 = clamp(utmp1, 371105U, 827999U);\n\t\t\tutmp1 = ((u64)(intlog10(utmp1 - 370000)\n\t\t\t\t- intlog10(828000 - utmp1)\n\t\t\t\t+ 43900382) * 6 * 1000) >> 24;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tutmp1 = clamp(utmp1, 193246U, 424999U);\n\t\t\tutmp1 = ((u64)(intlog10(utmp1 - 193000)\n\t\t\t\t- intlog10(425000 - utmp1)\n\t\t\t\t+ 49912218) * 8 * 1000) >> 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&client->dev, \"invalid modulation %u\\n\",\n\t\t\t\t(utmp >> 6) & 3);\n\t\t\tutmp1 = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(&client->dev, \"cnr %u\\n\", utmp1);\n\n\t\tstate->cnr_jiffies = jiffies;\n\t\tstate->dvbv3_snr = utmp1 / 100;\n\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[0].svalue = utmp1;\n\t\tbreak;\n\tdefault:\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (state->fe_status & FE_HAS_SYNC) {\n\tcase FE_HAS_SYNC:\n\t\tif (time_is_after_jiffies(state->ber_ucb_jiffies + msecs_to_jiffies(2000)))\n\t\t\tbreak;\n\n\t\t \n\t\tret = regmap_read(state->regmap, 0xd391, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!((utmp >> 4) & 0x01)) {\n\t\t\tdev_dbg(&client->dev, \"ber not ready\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = regmap_bulk_read(state->regmap, 0xd385, buf, 7);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp1 = buf[4] << 16 | buf[3] << 8 | buf[2] << 0;\n\t\tutmp2 = (buf[1] << 8 | buf[0] << 0) * 204 * 8;\n\t\tutmp3 = buf[6] << 8 | buf[5] << 0;\n\t\tutmp4 = buf[1] << 8 | buf[0] << 0;\n\n\t\t \n\t\tif (utmp4 != 10000) {\n\t\t\tbuf[0] = (10000 >> 0) & 0xff;\n\t\t\tbuf[1] = (10000 >> 8) & 0xff;\n\t\t\tret = regmap_bulk_write(state->regmap, 0xd385, buf, 2);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tret = regmap_update_bits(state->regmap, 0xd391, 0x20, 0x20);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdev_dbg(&client->dev, \"post_bit_error %u, post_bit_count %u\\n\",\n\t\t\tutmp1, utmp2);\n\t\tdev_dbg(&client->dev, \"block_error %u, block_count %u\\n\",\n\t\t\tutmp3, utmp4);\n\n\t\tstate->ber_ucb_jiffies = jiffies;\n\t\tstate->dvbv3_ber = utmp1;\n\t\tstate->dvbv3_ucblocks += utmp3;\n\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[0].uvalue += utmp1;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[0].uvalue += utmp2;\n\n\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_error.stat[0].uvalue += utmp3;\n\t\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_count.stat[0].uvalue += utmp4;\n\t\tbreak;\n\tdefault:\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tbreak;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9013_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct af9013_state *state = fe->demodulator_priv;\n\n\t*snr = state->dvbv3_snr;\n\n\treturn 0;\n}\n\nstatic int af9013_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct af9013_state *state = fe->demodulator_priv;\n\n\t*strength = state->dvbv3_strength;\n\n\treturn 0;\n}\n\nstatic int af9013_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct af9013_state *state = fe->demodulator_priv;\n\n\t*ber = state->dvbv3_ber;\n\n\treturn 0;\n}\n\nstatic int af9013_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct af9013_state *state = fe->demodulator_priv;\n\n\t*ucblocks = state->dvbv3_ucblocks;\n\n\treturn 0;\n}\n\nstatic int af9013_init(struct dvb_frontend *fe)\n{\n\tstruct af9013_state *state = fe->demodulator_priv;\n\tstruct i2c_client *client = state->client;\n\tint ret, i, len;\n\tunsigned int utmp;\n\tu8 buf[3];\n\tconst struct af9013_reg_mask_val *tab;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tret = regmap_update_bits(state->regmap, 0xd73a, 0x08, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_update_bits(state->regmap, 0xd417, 0x02, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_update_bits(state->regmap, 0xd417, 0x10, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_bulk_write(state->regmap, 0x9bf2, state->api_version, 4);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tswitch (state->clk) {\n\tcase 28800000:  \n\t\tutmp = 0;\n\t\tbreak;\n\tcase 20480000:  \n\t\tutmp = 1;\n\t\tbreak;\n\tcase 28000000:  \n\t\tutmp = 2;\n\t\tbreak;\n\tcase 25000000:  \n\t\tutmp = 3;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = regmap_update_bits(state->regmap, 0x9bd2, 0x0f, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tutmp = div_u64((u64)state->clk * 0x80000, 1000000);\n\tbuf[0] = (utmp >>  0) & 0xff;\n\tbuf[1] = (utmp >>  8) & 0xff;\n\tbuf[2] = (utmp >> 16) & 0xff;\n\tret = regmap_bulk_write(state->regmap, 0xd180, buf, 3);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tdev_dbg(&client->dev, \"load demod core settings\\n\");\n\tlen = ARRAY_SIZE(demod_init_tab);\n\ttab = demod_init_tab;\n\tfor (i = 0; i < len; i++) {\n\t\tret = regmap_update_bits(state->regmap, tab[i].reg, tab[i].mask,\n\t\t\t\t\t tab[i].val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tdev_dbg(&client->dev, \"load tuner specific settings\\n\");\n\tswitch (state->tuner) {\n\tcase AF9013_TUNER_MXL5003D:\n\t\tlen = ARRAY_SIZE(tuner_init_tab_mxl5003d);\n\t\ttab = tuner_init_tab_mxl5003d;\n\t\tbreak;\n\tcase AF9013_TUNER_MXL5005D:\n\tcase AF9013_TUNER_MXL5005R:\n\tcase AF9013_TUNER_MXL5007T:\n\t\tlen = ARRAY_SIZE(tuner_init_tab_mxl5005);\n\t\ttab = tuner_init_tab_mxl5005;\n\t\tbreak;\n\tcase AF9013_TUNER_ENV77H11D5:\n\t\tlen = ARRAY_SIZE(tuner_init_tab_env77h11d5);\n\t\ttab = tuner_init_tab_env77h11d5;\n\t\tbreak;\n\tcase AF9013_TUNER_MT2060:\n\t\tlen = ARRAY_SIZE(tuner_init_tab_mt2060);\n\t\ttab = tuner_init_tab_mt2060;\n\t\tbreak;\n\tcase AF9013_TUNER_MC44S803:\n\t\tlen = ARRAY_SIZE(tuner_init_tab_mc44s803);\n\t\ttab = tuner_init_tab_mc44s803;\n\t\tbreak;\n\tcase AF9013_TUNER_QT1010:\n\tcase AF9013_TUNER_QT1010A:\n\t\tlen = ARRAY_SIZE(tuner_init_tab_qt1010);\n\t\ttab = tuner_init_tab_qt1010;\n\t\tbreak;\n\tcase AF9013_TUNER_MT2060_2:\n\t\tlen = ARRAY_SIZE(tuner_init_tab_mt2060_2);\n\t\ttab = tuner_init_tab_mt2060_2;\n\t\tbreak;\n\tcase AF9013_TUNER_TDA18271:\n\tcase AF9013_TUNER_TDA18218:\n\t\tlen = ARRAY_SIZE(tuner_init_tab_tda18271);\n\t\ttab = tuner_init_tab_tda18271;\n\t\tbreak;\n\tcase AF9013_TUNER_UNKNOWN:\n\tdefault:\n\t\tlen = ARRAY_SIZE(tuner_init_tab_unknown);\n\t\ttab = tuner_init_tab_unknown;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tret = regmap_update_bits(state->regmap, tab[i].reg, tab[i].mask,\n\t\t\t\t\t tab[i].val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (state->ts_output_pin == 7)\n\t\tutmp = 1 << 3 | state->ts_mode << 1;\n\telse\n\t\tutmp = 0 << 3 | state->ts_mode << 1;\n\tret = regmap_update_bits(state->regmap, 0xd500, 0x0e, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_update_bits(state->regmap, 0xd730, 0x01, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\tstate->first_tune = true;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9013_sleep(struct dvb_frontend *fe)\n{\n\tstruct af9013_state *state = fe->demodulator_priv;\n\tstruct i2c_client *client = state->client;\n\tint ret;\n\tunsigned int utmp;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tret = regmap_update_bits(state->regmap, 0xd730, 0x01, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_update_bits(state->regmap, 0xd417, 0x10, 0x10);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_write(state->regmap, 0xaeff, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_read_poll_timeout(state->regmap, 0xd417, utmp,\n\t\t\t\t       (utmp >> 1) & 0x01, 5000, 1000000);\n\tif (ret)\n\t\tgoto err;\n\n\tif (!((utmp >> 1) & 0x01)) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\n\t \n\tret = regmap_update_bits(state->regmap, 0xd73a, 0x08, 0x08);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dvb_frontend_ops af9013_ops;\n\nstatic int af9013_download_firmware(struct af9013_state *state)\n{\n\tstruct i2c_client *client = state->client;\n\tint ret, i, len, rem;\n\tunsigned int utmp;\n\tu8 buf[4];\n\tu16 checksum = 0;\n\tconst struct firmware *firmware;\n\tconst char *name = AF9013_FIRMWARE;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tret = regmap_read(state->regmap, 0x98be, &utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_dbg(&client->dev, \"firmware status %02x\\n\", utmp);\n\n\tif (utmp == 0x0c)\n\t\treturn 0;\n\n\tdev_info(&client->dev, \"found a '%s' in cold state, will try to load a firmware\\n\",\n\t\t af9013_ops.info.name);\n\n\t \n\tret = request_firmware(&firmware, name, &client->dev);\n\tif (ret) {\n\t\tdev_info(&client->dev, \"firmware file '%s' not found %d\\n\",\n\t\t\t name, ret);\n\t\tgoto err;\n\t}\n\n\tdev_info(&client->dev, \"downloading firmware from file '%s'\\n\",\n\t\t name);\n\n\t \n\tfor (i = 0; i < firmware->size; i++)\n\t\tchecksum += firmware->data[i];\n\n\tbuf[0] = (checksum >> 8) & 0xff;\n\tbuf[1] = (checksum >> 0) & 0xff;\n\tbuf[2] = (firmware->size >> 8) & 0xff;\n\tbuf[3] = (firmware->size >> 0) & 0xff;\n\tret = regmap_bulk_write(state->regmap, 0x50fc, buf, 4);\n\tif (ret)\n\t\tgoto err_release_firmware;\n\n\t \n\t#define LEN_MAX 16\n\tfor (rem = firmware->size; rem > 0; rem -= LEN_MAX) {\n\t\tlen = min(LEN_MAX, rem);\n\t\tret = regmap_bulk_write(state->regmap,\n\t\t\t\t\t0x5100 + firmware->size - rem,\n\t\t\t\t\t&firmware->data[firmware->size - rem],\n\t\t\t\t\tlen);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"firmware download failed %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_release_firmware;\n\t\t}\n\t}\n\n\trelease_firmware(firmware);\n\n\t \n\tret = regmap_write(state->regmap, 0xe205, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_read_poll_timeout(state->regmap, 0x98be, utmp,\n\t\t\t\t       (utmp == 0x0c || utmp == 0x04),\n\t\t\t\t       5000, 1000000);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_dbg(&client->dev, \"firmware status %02x\\n\", utmp);\n\n\tif (utmp == 0x04) {\n\t\tret = -ENODEV;\n\t\tdev_err(&client->dev, \"firmware did not run\\n\");\n\t\tgoto err;\n\t} else if (utmp != 0x0c) {\n\t\tret = -ENODEV;\n\t\tdev_err(&client->dev, \"firmware boot timeout\\n\");\n\t\tgoto err;\n\t}\n\n\tdev_info(&client->dev, \"found a '%s' in warm state\\n\",\n\t\t af9013_ops.info.name);\n\n\treturn 0;\nerr_release_firmware:\n\trelease_firmware(firmware);\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dvb_frontend_ops af9013_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name = \"Afatech AF9013\",\n\t\t.frequency_min_hz = 174 * MHz,\n\t\t.frequency_max_hz = 862 * MHz,\n\t\t.frequency_stepsize_hz = 250 * kHz,\n\t\t.caps =\tFE_CAN_FEC_1_2 |\n\t\t\tFE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 |\n\t\t\tFE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK |\n\t\t\tFE_CAN_QAM_16 |\n\t\t\tFE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO |\n\t\t\tFE_CAN_RECOVER |\n\t\t\tFE_CAN_MUTE_TS\n\t},\n\n\t.init = af9013_init,\n\t.sleep = af9013_sleep,\n\n\t.get_tune_settings = af9013_get_tune_settings,\n\t.set_frontend = af9013_set_frontend,\n\t.get_frontend = af9013_get_frontend,\n\n\t.read_status = af9013_read_status,\n\t.read_snr = af9013_read_snr,\n\t.read_signal_strength = af9013_read_signal_strength,\n\t.read_ber = af9013_read_ber,\n\t.read_ucblocks = af9013_read_ucblocks,\n};\n\nstatic int af9013_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct af9013_state *state = fe->demodulator_priv;\n\tstruct i2c_client *client = state->client;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"onoff %d\\n\", onoff);\n\n\tret = regmap_update_bits(state->regmap, 0xd503, 0x01, onoff);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9013_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid,\n\t\t\t     int onoff)\n{\n\tstruct af9013_state *state = fe->demodulator_priv;\n\tstruct i2c_client *client = state->client;\n\tint ret;\n\tu8 buf[2];\n\n\tdev_dbg(&client->dev, \"index %d, pid %04x, onoff %d\\n\",\n\t\tindex, pid, onoff);\n\n\tif (pid > 0x1fff) {\n\t\t \n\t\tret = 0;\n\t\tgoto err;\n\t}\n\n\tbuf[0] = (pid >> 0) & 0xff;\n\tbuf[1] = (pid >> 8) & 0xff;\n\tret = regmap_bulk_write(state->regmap, 0xd505, buf, 2);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(state->regmap, 0xd504, onoff << 5 | index << 0);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic struct dvb_frontend *af9013_get_dvb_frontend(struct i2c_client *client)\n{\n\tstruct af9013_state *state = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\treturn &state->fe;\n}\n\nstatic struct i2c_adapter *af9013_get_i2c_adapter(struct i2c_client *client)\n{\n\tstruct af9013_state *state = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\treturn state->muxc->adapter[0];\n}\n\n \nstatic int af9013_select(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct af9013_state *state = i2c_mux_priv(muxc);\n\tstruct i2c_client *client = state->client;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tif (state->ts_mode == AF9013_TS_MODE_USB)\n\t\tret = regmap_update_bits(state->regmap, 0x1d417, 0x08, 0x08);\n\telse\n\t\tret = regmap_update_bits(state->regmap, 0x1d607, 0x04, 0x04);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9013_deselect(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct af9013_state *state = i2c_mux_priv(muxc);\n\tstruct i2c_client *client = state->client;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tif (state->ts_mode == AF9013_TS_MODE_USB)\n\t\tret = regmap_update_bits(state->regmap, 0x1d417, 0x08, 0x00);\n\telse\n\t\tret = regmap_update_bits(state->regmap, 0x1d607, 0x04, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\n \nstatic int af9013_wregs(struct i2c_client *client, u8 cmd, u16 reg,\n\t\t\tconst u8 *val, int len, u8 lock)\n{\n\tint ret;\n\tu8 buf[21];\n\tstruct i2c_msg msg[1] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 3 + len,\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\n\tif (3 + len > sizeof(buf)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tbuf[0] = (reg >> 8) & 0xff;\n\tbuf[1] = (reg >> 0) & 0xff;\n\tbuf[2] = cmd;\n\tmemcpy(&buf[3], val, len);\n\n\tif (lock)\n\t\ti2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tret = __i2c_transfer(client->adapter, msg, 1);\n\tif (lock)\n\t\ti2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tif (ret < 0) {\n\t\tgoto err;\n\t} else if (ret != 1) {\n\t\tret = -EREMOTEIO;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9013_rregs(struct i2c_client *client, u8 cmd, u16 reg,\n\t\t\tu8 *val, int len, u8 lock)\n{\n\tint ret;\n\tu8 buf[3];\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 3,\n\t\t\t.buf = buf,\n\t\t}, {\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = val,\n\t\t}\n\t};\n\n\tbuf[0] = (reg >> 8) & 0xff;\n\tbuf[1] = (reg >> 0) & 0xff;\n\tbuf[2] = cmd;\n\n\tif (lock)\n\t\ti2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tret = __i2c_transfer(client->adapter, msg, 2);\n\tif (lock)\n\t\ti2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\tif (ret < 0) {\n\t\tgoto err;\n\t} else if (ret != 2) {\n\t\tret = -EREMOTEIO;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9013_regmap_write(void *context, const void *data, size_t count)\n{\n\tstruct i2c_client *client = context;\n\tstruct af9013_state *state = i2c_get_clientdata(client);\n\tint ret, i;\n\tu8 cmd;\n\tu8 lock = !((u8 *)data)[0];\n\tu16 reg = ((u8 *)data)[1] << 8 | ((u8 *)data)[2] << 0;\n\tu8 *val = &((u8 *)data)[3];\n\tconst unsigned int len = count - 3;\n\n\tif (state->ts_mode == AF9013_TS_MODE_USB && (reg & 0xff00) != 0xae00) {\n\t\tcmd = 0 << 7|0 << 6|(len - 1) << 2|1 << 1|1 << 0;\n\t\tret = af9013_wregs(client, cmd, reg, val, len, lock);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (reg >= 0x5100 && reg < 0x8fff) {\n\t\t \n\t\tcmd = 1 << 7|1 << 6|(len - 1) << 2|1 << 1|1 << 0;\n\t\tret = af9013_wregs(client, cmd, reg, val, len, lock);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tcmd = 0 << 7|0 << 6|(1 - 1) << 2|1 << 1|1 << 0;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tret = af9013_wregs(client, cmd, reg + i, val + i, 1,\n\t\t\t\t\t   lock);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9013_regmap_read(void *context, const void *reg_buf,\n\t\t\t      size_t reg_size, void *val_buf, size_t val_size)\n{\n\tstruct i2c_client *client = context;\n\tstruct af9013_state *state = i2c_get_clientdata(client);\n\tint ret, i;\n\tu8 cmd;\n\tu8 lock = !((u8 *)reg_buf)[0];\n\tu16 reg = ((u8 *)reg_buf)[1] << 8 | ((u8 *)reg_buf)[2] << 0;\n\tu8 *val = &((u8 *)val_buf)[0];\n\tconst unsigned int len = val_size;\n\n\tif (state->ts_mode == AF9013_TS_MODE_USB && (reg & 0xff00) != 0xae00) {\n\t\tcmd = 0 << 7|0 << 6|(len - 1) << 2|1 << 1|0 << 0;\n\t\tret = af9013_rregs(client, cmd, reg, val_buf, len, lock);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tcmd = 0 << 7|0 << 6|(1 - 1) << 2|1 << 1|0 << 0;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tret = af9013_rregs(client, cmd, reg + i, val + i, 1,\n\t\t\t\t\t   lock);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9013_probe(struct i2c_client *client)\n{\n\tstruct af9013_state *state;\n\tstruct af9013_platform_data *pdata = client->dev.platform_data;\n\tstruct dtv_frontend_properties *c;\n\tint ret, i;\n\tu8 firmware_version[4];\n\tstatic const struct regmap_bus regmap_bus = {\n\t\t.read = af9013_regmap_read,\n\t\t.write = af9013_regmap_write,\n\t};\n\tstatic const struct regmap_config regmap_config = {\n\t\t \n\t\t.reg_bits = 24,\n\t\t.val_bits = 8,\n\t};\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tstate->client = client;\n\ti2c_set_clientdata(client, state);\n\tstate->clk = pdata->clk;\n\tstate->tuner = pdata->tuner;\n\tstate->if_frequency = pdata->if_frequency;\n\tstate->ts_mode = pdata->ts_mode;\n\tstate->ts_output_pin = pdata->ts_output_pin;\n\tstate->spec_inv = pdata->spec_inv;\n\tmemcpy(&state->api_version, pdata->api_version, sizeof(state->api_version));\n\tmemcpy(&state->gpio, pdata->gpio, sizeof(state->gpio));\n\tstate->regmap = regmap_init(&client->dev, &regmap_bus, client,\n\t\t\t\t  &regmap_config);\n\tif (IS_ERR(state->regmap)) {\n\t\tret = PTR_ERR(state->regmap);\n\t\tgoto err_kfree;\n\t}\n\t \n\tstate->muxc = i2c_mux_alloc(client->adapter, &client->dev, 1, 0, 0,\n\t\t\t\t    af9013_select, af9013_deselect);\n\tif (!state->muxc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_regmap_exit;\n\t}\n\tstate->muxc->priv = state;\n\tret = i2c_mux_add_adapter(state->muxc, 0, 0, 0);\n\tif (ret)\n\t\tgoto err_regmap_exit;\n\n\t \n\tif (state->ts_mode != AF9013_TS_MODE_USB) {\n\t\tret = af9013_download_firmware(state);\n\t\tif (ret)\n\t\t\tgoto err_i2c_mux_del_adapters;\n\t}\n\n\t \n\tret = regmap_bulk_read(state->regmap, 0x5103, firmware_version,\n\t\t\t       sizeof(firmware_version));\n\tif (ret)\n\t\tgoto err_i2c_mux_del_adapters;\n\n\t \n\tfor (i = 0; i < sizeof(state->gpio); i++) {\n\t\tret = af9013_set_gpio(state, i, state->gpio[i]);\n\t\tif (ret)\n\t\t\tgoto err_i2c_mux_del_adapters;\n\t}\n\n\t \n\tmemcpy(&state->fe.ops, &af9013_ops, sizeof(state->fe.ops));\n\tstate->fe.demodulator_priv = state;\n\n\t \n\tpdata->get_dvb_frontend = af9013_get_dvb_frontend;\n\tpdata->get_i2c_adapter = af9013_get_i2c_adapter;\n\tpdata->pid_filter = af9013_pid_filter;\n\tpdata->pid_filter_ctrl = af9013_pid_filter_ctrl;\n\n\t \n\tc = &state->fe.dtv_property_cache;\n\tc->strength.len = 1;\n\tc->cnr.len = 1;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_count.len = 1;\n\tc->block_error.len = 1;\n\tc->block_count.len = 1;\n\n\tdev_info(&client->dev, \"Afatech AF9013 successfully attached\\n\");\n\tdev_info(&client->dev, \"firmware version: %d.%d.%d.%d\\n\",\n\t\t firmware_version[0], firmware_version[1],\n\t\t firmware_version[2], firmware_version[3]);\n\treturn 0;\nerr_i2c_mux_del_adapters:\n\ti2c_mux_del_adapters(state->muxc);\nerr_regmap_exit:\n\tregmap_exit(state->regmap);\nerr_kfree:\n\tkfree(state);\nerr:\n\tdev_dbg(&client->dev, \"failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void af9013_remove(struct i2c_client *client)\n{\n\tstruct af9013_state *state = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\ti2c_mux_del_adapters(state->muxc);\n\n\tregmap_exit(state->regmap);\n\n\tkfree(state);\n}\n\nstatic const struct i2c_device_id af9013_id_table[] = {\n\t{\"af9013\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, af9013_id_table);\n\nstatic struct i2c_driver af9013_driver = {\n\t.driver = {\n\t\t.name\t= \"af9013\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= af9013_probe,\n\t.remove\t\t= af9013_remove,\n\t.id_table\t= af9013_id_table,\n};\n\nmodule_i2c_driver(af9013_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Afatech AF9013 DVB-T demodulator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(AF9013_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}