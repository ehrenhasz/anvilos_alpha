{
  "module_name": "af9033.c",
  "hash_id": "f15cd3b1102aa8f26af4e54c5dd8e39ce6703352804a517576d7124346a809e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/af9033.c",
  "human_readable_source": "\n \n\n#include \"af9033_priv.h\"\n\nstruct af9033_dev {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct dvb_frontend fe;\n\tstruct af9033_config cfg;\n\tbool is_af9035;\n\tbool is_it9135;\n\n\tu32 bandwidth_hz;\n\tbool ts_mode_parallel;\n\tbool ts_mode_serial;\n\n\tenum fe_status fe_status;\n\tu64 post_bit_error_prev;  \n\tu64 post_bit_error;\n\tu64 post_bit_count;\n\tu64 error_block_count;\n\tu64 total_block_count;\n};\n\n \nstatic int af9033_wr_reg_val_tab(struct af9033_dev *dev,\n\t\t\t\t const struct reg_val *tab, int tab_len)\n{\n\tstruct i2c_client *client = dev->client;\n#define MAX_TAB_LEN 212\n\tint ret, i, j;\n\tu8 buf[1 + MAX_TAB_LEN];\n\n\tdev_dbg(&client->dev, \"tab_len=%d\\n\", tab_len);\n\n\tif (tab_len > sizeof(buf)) {\n\t\tdev_warn(&client->dev, \"tab len %d is too big\\n\", tab_len);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, j = 0; i < tab_len; i++) {\n\t\tbuf[j] = tab[i].val;\n\n\t\tif (i == tab_len - 1 || tab[i].reg != tab[i + 1].reg - 1) {\n\t\t\tret = regmap_bulk_write(dev->regmap, tab[i].reg - j,\n\t\t\t\t\t\tbuf, j + 1);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tj = 0;\n\t\t} else {\n\t\t\tj++;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9033_init(struct dvb_frontend *fe)\n{\n\tstruct af9033_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i, len;\n\tunsigned int utmp;\n\tconst struct reg_val *init;\n\tu8 buf[4];\n\tstruct reg_val_mask tab[] = {\n\t\t{ 0x80fb24, 0x00, 0x08 },\n\t\t{ 0x80004c, 0x00, 0xff },\n\t\t{ 0x00f641, dev->cfg.tuner, 0xff },\n\t\t{ 0x80f5ca, 0x01, 0x01 },\n\t\t{ 0x80f715, 0x01, 0x01 },\n\t\t{ 0x00f41f, 0x04, 0x04 },\n\t\t{ 0x00f41a, 0x01, 0x01 },\n\t\t{ 0x80f731, 0x00, 0x01 },\n\t\t{ 0x00d91e, 0x00, 0x01 },\n\t\t{ 0x00d919, 0x00, 0x01 },\n\t\t{ 0x80f732, 0x00, 0x01 },\n\t\t{ 0x00d91f, 0x00, 0x01 },\n\t\t{ 0x00d91a, 0x00, 0x01 },\n\t\t{ 0x80f730, 0x00, 0x01 },\n\t\t{ 0x80f778, 0x00, 0xff },\n\t\t{ 0x80f73c, 0x01, 0x01 },\n\t\t{ 0x80f776, 0x00, 0x01 },\n\t\t{ 0x00d8fd, 0x01, 0xff },\n\t\t{ 0x00d830, 0x01, 0xff },\n\t\t{ 0x00d831, 0x00, 0xff },\n\t\t{ 0x00d832, 0x00, 0xff },\n\t\t{ 0x80f985, dev->ts_mode_serial, 0x01 },\n\t\t{ 0x80f986, dev->ts_mode_parallel, 0x01 },\n\t\t{ 0x00d827, 0x00, 0xff },\n\t\t{ 0x00d829, 0x00, 0xff },\n\t\t{ 0x800045, dev->cfg.adc_multiplier, 0xff },\n\t};\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tutmp = div_u64((u64)dev->cfg.clock * 0x80000, 1000000);\n\tbuf[0] = (utmp >>  0) & 0xff;\n\tbuf[1] = (utmp >>  8) & 0xff;\n\tbuf[2] = (utmp >> 16) & 0xff;\n\tbuf[3] = (utmp >> 24) & 0xff;\n\tret = regmap_bulk_write(dev->regmap, 0x800025, buf, 4);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_dbg(&client->dev, \"clk=%u clk_cw=%08x\\n\", dev->cfg.clock, utmp);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(clock_adc_lut); i++) {\n\t\tif (clock_adc_lut[i].clock == dev->cfg.clock)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(clock_adc_lut)) {\n\t\tdev_err(&client->dev, \"Couldn't find ADC config for clock %d\\n\",\n\t\t\tdev->cfg.clock);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tutmp = div_u64((u64)clock_adc_lut[i].adc * 0x80000, 1000000);\n\tbuf[0] = (utmp >>  0) & 0xff;\n\tbuf[1] = (utmp >>  8) & 0xff;\n\tbuf[2] = (utmp >> 16) & 0xff;\n\tret = regmap_bulk_write(dev->regmap, 0x80f1cd, buf, 3);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_dbg(&client->dev, \"adc=%u adc_cw=%06x\\n\",\n\t\tclock_adc_lut[i].adc, utmp);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(tab); i++) {\n\t\tret = regmap_update_bits(dev->regmap, tab[i].reg, tab[i].mask,\n\t\t\t\t\t tab[i].val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (dev->cfg.dyn0_clk) {\n\t\tret = regmap_write(dev->regmap, 0x80fba8, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (dev->cfg.ts_mode == AF9033_TS_MODE_USB) {\n\t\tret = regmap_update_bits(dev->regmap, 0x80f9a5, 0x01, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(dev->regmap, 0x80f9b5, 0x01, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tret = regmap_update_bits(dev->regmap, 0x80f990, 0x01, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(dev->regmap, 0x80f9b5, 0x01, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tdev_dbg(&client->dev, \"load ofsm settings\\n\");\n\tswitch (dev->cfg.tuner) {\n\tcase AF9033_TUNER_IT9135_38:\n\tcase AF9033_TUNER_IT9135_51:\n\tcase AF9033_TUNER_IT9135_52:\n\t\tlen = ARRAY_SIZE(ofsm_init_it9135_v1);\n\t\tinit = ofsm_init_it9135_v1;\n\t\tbreak;\n\tcase AF9033_TUNER_IT9135_60:\n\tcase AF9033_TUNER_IT9135_61:\n\tcase AF9033_TUNER_IT9135_62:\n\t\tlen = ARRAY_SIZE(ofsm_init_it9135_v2);\n\t\tinit = ofsm_init_it9135_v2;\n\t\tbreak;\n\tdefault:\n\t\tlen = ARRAY_SIZE(ofsm_init);\n\t\tinit = ofsm_init;\n\t\tbreak;\n\t}\n\n\tret = af9033_wr_reg_val_tab(dev, init, len);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tdev_dbg(&client->dev, \"load tuner specific settings\\n\");\n\tswitch (dev->cfg.tuner) {\n\tcase AF9033_TUNER_TUA9001:\n\t\tlen = ARRAY_SIZE(tuner_init_tua9001);\n\t\tinit = tuner_init_tua9001;\n\t\tbreak;\n\tcase AF9033_TUNER_FC0011:\n\t\tlen = ARRAY_SIZE(tuner_init_fc0011);\n\t\tinit = tuner_init_fc0011;\n\t\tbreak;\n\tcase AF9033_TUNER_MXL5007T:\n\t\tlen = ARRAY_SIZE(tuner_init_mxl5007t);\n\t\tinit = tuner_init_mxl5007t;\n\t\tbreak;\n\tcase AF9033_TUNER_TDA18218:\n\t\tlen = ARRAY_SIZE(tuner_init_tda18218);\n\t\tinit = tuner_init_tda18218;\n\t\tbreak;\n\tcase AF9033_TUNER_FC2580:\n\t\tlen = ARRAY_SIZE(tuner_init_fc2580);\n\t\tinit = tuner_init_fc2580;\n\t\tbreak;\n\tcase AF9033_TUNER_FC0012:\n\t\tlen = ARRAY_SIZE(tuner_init_fc0012);\n\t\tinit = tuner_init_fc0012;\n\t\tbreak;\n\tcase AF9033_TUNER_IT9135_38:\n\t\tlen = ARRAY_SIZE(tuner_init_it9135_38);\n\t\tinit = tuner_init_it9135_38;\n\t\tbreak;\n\tcase AF9033_TUNER_IT9135_51:\n\t\tlen = ARRAY_SIZE(tuner_init_it9135_51);\n\t\tinit = tuner_init_it9135_51;\n\t\tbreak;\n\tcase AF9033_TUNER_IT9135_52:\n\t\tlen = ARRAY_SIZE(tuner_init_it9135_52);\n\t\tinit = tuner_init_it9135_52;\n\t\tbreak;\n\tcase AF9033_TUNER_IT9135_60:\n\t\tlen = ARRAY_SIZE(tuner_init_it9135_60);\n\t\tinit = tuner_init_it9135_60;\n\t\tbreak;\n\tcase AF9033_TUNER_IT9135_61:\n\t\tlen = ARRAY_SIZE(tuner_init_it9135_61);\n\t\tinit = tuner_init_it9135_61;\n\t\tbreak;\n\tcase AF9033_TUNER_IT9135_62:\n\t\tlen = ARRAY_SIZE(tuner_init_it9135_62);\n\t\tinit = tuner_init_it9135_62;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"unsupported tuner ID=%d\\n\",\n\t\t\tdev->cfg.tuner);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tret = af9033_wr_reg_val_tab(dev, init, len);\n\tif (ret)\n\t\tgoto err;\n\n\tif (dev->cfg.ts_mode == AF9033_TS_MODE_SERIAL) {\n\t\tret = regmap_update_bits(dev->regmap, 0x00d91c, 0x01, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(dev->regmap, 0x00d917, 0x01, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(dev->regmap, 0x00d916, 0x01, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tswitch (dev->cfg.tuner) {\n\tcase AF9033_TUNER_IT9135_60:\n\tcase AF9033_TUNER_IT9135_61:\n\tcase AF9033_TUNER_IT9135_62:\n\t\tret = regmap_write(dev->regmap, 0x800000, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tdev->bandwidth_hz = 0;  \n\t \n\tc->strength.len = 1;\n\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->cnr.len = 1;\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_count.len = 1;\n\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_error.len = 1;\n\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.len = 1;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9033_sleep(struct dvb_frontend *fe)\n{\n\tstruct af9033_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tunsigned int utmp;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tret = regmap_write(dev->regmap, 0x80004c, 0x01);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x800000, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_read_poll_timeout(dev->regmap, 0x80004c, utmp, utmp == 0,\n\t\t\t\t       5000, 1000000);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_update_bits(dev->regmap, 0x80fb24, 0x08, 0x08);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (dev->cfg.ts_mode == AF9033_TS_MODE_SERIAL) {\n\t\t \n\t\tret = regmap_update_bits(dev->regmap, 0x00d917, 0x01, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_update_bits(dev->regmap, 0x00d916, 0x01, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9033_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t    struct dvb_frontend_tune_settings *fesettings)\n{\n\t \n\tfesettings->min_delay_ms = 2000;\n\tfesettings->step_size = 0;\n\tfesettings->max_drift = 0;\n\n\treturn 0;\n}\n\nstatic int af9033_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct af9033_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i;\n\tunsigned int utmp, adc_freq;\n\tu8 tmp, buf[3], bandwidth_reg_val;\n\tu32 if_frequency;\n\n\tdev_dbg(&client->dev, \"frequency=%u bandwidth_hz=%u\\n\",\n\t\tc->frequency, c->bandwidth_hz);\n\n\t \n\tswitch (c->bandwidth_hz) {\n\tcase 6000000:\n\t\tbandwidth_reg_val = 0x00;\n\t\tbreak;\n\tcase 7000000:\n\t\tbandwidth_reg_val = 0x01;\n\t\tbreak;\n\tcase 8000000:\n\t\tbandwidth_reg_val = 0x02;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid bandwidth_hz\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\n\t \n\tif (c->bandwidth_hz != dev->bandwidth_hz) {\n\t\tfor (i = 0; i < ARRAY_SIZE(coeff_lut); i++) {\n\t\t\tif (coeff_lut[i].clock == dev->cfg.clock &&\n\t\t\t    coeff_lut[i].bandwidth_hz == c->bandwidth_hz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ARRAY_SIZE(coeff_lut)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Couldn't find config for clock %u\\n\",\n\t\t\t\tdev->cfg.clock);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = regmap_bulk_write(dev->regmap, 0x800001, coeff_lut[i].val,\n\t\t\t\t\tsizeof(coeff_lut[i].val));\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (c->bandwidth_hz != dev->bandwidth_hz) {\n\t\tfor (i = 0; i < ARRAY_SIZE(clock_adc_lut); i++) {\n\t\t\tif (clock_adc_lut[i].clock == dev->cfg.clock)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ARRAY_SIZE(clock_adc_lut)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Couldn't find ADC clock for clock %u\\n\",\n\t\t\t\tdev->cfg.clock);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tadc_freq = clock_adc_lut[i].adc;\n\n\t\tif (dev->cfg.adc_multiplier == AF9033_ADC_MULTIPLIER_2X)\n\t\t\tadc_freq = 2 * adc_freq;\n\n\t\t \n\t\tif (fe->ops.tuner_ops.get_if_frequency)\n\t\t\tfe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\n\t\telse\n\t\t\tif_frequency = 0;\n\n\t\tutmp = DIV_ROUND_CLOSEST_ULL((u64)if_frequency * 0x800000,\n\t\t\t\t\t     adc_freq);\n\n\t\tif (!dev->cfg.spec_inv && if_frequency)\n\t\t\tutmp = 0x800000 - utmp;\n\n\t\tbuf[0] = (utmp >>  0) & 0xff;\n\t\tbuf[1] = (utmp >>  8) & 0xff;\n\t\tbuf[2] = (utmp >> 16) & 0xff;\n\t\tret = regmap_bulk_write(dev->regmap, 0x800029, buf, 3);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdev_dbg(&client->dev, \"if_frequency_cw=%06x\\n\", utmp);\n\n\t\tdev->bandwidth_hz = c->bandwidth_hz;\n\t}\n\n\tret = regmap_update_bits(dev->regmap, 0x80f904, 0x03,\n\t\t\t\t bandwidth_reg_val);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x800040, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x800047, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_update_bits(dev->regmap, 0x80f999, 0x01, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tif (c->frequency <= 230000000)\n\t\ttmp = 0x00;  \n\telse\n\t\ttmp = 0x01;  \n\n\tret = regmap_write(dev->regmap, 0x80004b, tmp);\n\tif (ret)\n\t\tgoto err;\n\t \n\tret = regmap_write(dev->regmap, 0x800000, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9033_get_frontend(struct dvb_frontend *fe,\n\t\t\t       struct dtv_frontend_properties *c)\n{\n\tstruct af9033_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu8 buf[8];\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tret = regmap_bulk_read(dev->regmap, 0x80f900, buf, 8);\n\tif (ret)\n\t\tgoto err;\n\n\tswitch ((buf[0] >> 0) & 3) {\n\tcase 0:\n\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n\tcase 1:\n\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[1] >> 0) & 3) {\n\tcase 0:\n\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\tc->guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tc->guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[2] >> 0) & 7) {\n\tcase 0:\n\t\tc->hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tc->hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tcase 2:\n\t\tc->hierarchy = HIERARCHY_2;\n\t\tbreak;\n\tcase 3:\n\t\tc->hierarchy = HIERARCHY_4;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[3] >> 0) & 3) {\n\tcase 0:\n\t\tc->modulation = QPSK;\n\t\tbreak;\n\tcase 1:\n\t\tc->modulation = QAM_16;\n\t\tbreak;\n\tcase 2:\n\t\tc->modulation = QAM_64;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[4] >> 0) & 3) {\n\tcase 0:\n\t\tc->bandwidth_hz = 6000000;\n\t\tbreak;\n\tcase 1:\n\t\tc->bandwidth_hz = 7000000;\n\t\tbreak;\n\tcase 2:\n\t\tc->bandwidth_hz = 8000000;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[6] >> 0) & 7) {\n\tcase 0:\n\t\tc->code_rate_HP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tc->code_rate_HP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tc->code_rate_HP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tc->code_rate_HP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tc->code_rate_HP = FEC_7_8;\n\t\tbreak;\n\tcase 5:\n\t\tc->code_rate_HP = FEC_NONE;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[7] >> 0) & 7) {\n\tcase 0:\n\t\tc->code_rate_LP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tc->code_rate_LP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tc->code_rate_LP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tc->code_rate_LP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tc->code_rate_LP = FEC_7_8;\n\t\tbreak;\n\tcase 5:\n\t\tc->code_rate_LP = FEC_NONE;\n\t\tbreak;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9033_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct af9033_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, tmp = 0;\n\tu8 buf[7];\n\tunsigned int utmp, utmp1;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t*status = 0;\n\n\t \n\tret = regmap_read(dev->regmap, 0x800047, &utmp);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (utmp == 0x01)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (utmp != 0x02) {\n\t\t \n\t\tret = regmap_read(dev->regmap, 0x80f5a9, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif ((utmp >> 0) & 0x01)\n\t\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t\tFE_HAS_VITERBI;\n\n\t\t \n\t\tret = regmap_read(dev->regmap, 0x80f999, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif ((utmp >> 0) & 0x01)\n\t\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t\tFE_HAS_VITERBI | FE_HAS_SYNC |\n\t\t\t\t\tFE_HAS_LOCK;\n\t}\n\n\tdev->fe_status = *status;\n\n\t \n\tif (dev->fe_status & FE_HAS_SIGNAL) {\n\t\tif (dev->is_af9035) {\n\t\t\tret = regmap_read(dev->regmap, 0x80004a, &utmp);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\ttmp = -utmp * 1000;\n\t\t} else {\n\t\t\tret = regmap_read(dev->regmap, 0x8000f7, &utmp);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\ttmp = (utmp - 100) * 1000;\n\t\t}\n\n\t\tc->strength.len = 1;\n\t\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->strength.stat[0].svalue = tmp;\n\t} else {\n\t\tc->strength.len = 1;\n\t\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (dev->fe_status & FE_HAS_VITERBI) {\n\t\t \n\t\tret = regmap_bulk_read(dev->regmap, 0x80002c, buf, 3);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tutmp1 = buf[2] << 16 | buf[1] << 8 | buf[0] << 0;\n\n\t\t \n\t\tret = regmap_read(dev->regmap, 0x80f78b, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (utmp)\n\t\t\tutmp1 /= utmp;\n\n\t\t \n\t\tret = regmap_read(dev->regmap, 0x80f900, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tswitch ((utmp >> 0) & 3) {\n\t\tcase 0:\n\t\t\t \n\t\t\tutmp1 *= 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tutmp1 *= 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tutmp1 *= 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tutmp1 *= 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = regmap_read(dev->regmap, 0x80f903, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tswitch ((utmp >> 0) & 3) {\n\t\tcase 0:\n\t\t\t \n\t\t\tutmp1 = clamp(utmp1, 653799U, 1689999U);\n\t\t\tutmp1 = ((u64)(intlog10(utmp1)\n\t\t\t\t - intlog10(1690000 - utmp1)\n\t\t\t\t + 3355443) * 13 * 1000) >> 24;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tutmp1 = clamp(utmp1, 371105U, 827999U);\n\t\t\tutmp1 = ((u64)(intlog10(utmp1 - 370000)\n\t\t\t\t - intlog10(828000 - utmp1)\n\t\t\t\t + 43900382) * 6 * 1000) >> 24;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tutmp1 = clamp(utmp1, 193246U, 424999U);\n\t\t\tutmp1 = ((u64)(intlog10(utmp1 - 193000)\n\t\t\t\t - intlog10(425000 - utmp1)\n\t\t\t\t + 49912218) * 8 * 1000) >> 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tutmp1 = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(&client->dev, \"cnr=%u\\n\", utmp1);\n\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[0].svalue = utmp1;\n\t} else {\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (dev->fe_status & FE_HAS_LOCK) {\n\t\t \n\t\tu16 abort_packet_count, rsd_packet_count;\n\t\t \n\t\tu32 rsd_bit_err_count;\n\n\t\t \n\n\t\tret = regmap_bulk_read(dev->regmap, 0x800032, buf, 7);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tabort_packet_count = (buf[1] << 8) | (buf[0] << 0);\n\t\trsd_bit_err_count = (buf[4] << 16) | (buf[3] << 8) | buf[2];\n\t\trsd_packet_count = (buf[6] << 8) | (buf[5] << 0);\n\n\t\tdev->error_block_count += abort_packet_count;\n\t\tdev->total_block_count += rsd_packet_count;\n\t\tdev->post_bit_error += rsd_bit_err_count;\n\t\tdev->post_bit_count += rsd_packet_count * 204 * 8;\n\n\t\tc->block_count.len = 1;\n\t\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_count.stat[0].uvalue = dev->total_block_count;\n\n\t\tc->block_error.len = 1;\n\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_error.stat[0].uvalue = dev->error_block_count;\n\n\t\tc->post_bit_count.len = 1;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[0].uvalue = dev->post_bit_count;\n\n\t\tc->post_bit_error.len = 1;\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9033_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct af9033_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\n\tint ret;\n\tunsigned int utmp;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL) {\n\t\t \n\t\tif (dev->is_af9035) {\n\t\t\t \n\t\t\t*snr = div_s64(c->cnr.stat[0].svalue, 100);\n\t\t} else {\n\t\t\t \n\t\t\t*snr = div_s64(c->cnr.stat[0].svalue, 1000);\n\n\t\t\t \n\t\t\tret = regmap_read(dev->regmap, 0x80f903, &utmp);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\t \n\t\t\tswitch ((utmp >> 0) & 3) {\n\t\t\tcase 0:\n\t\t\t\t*snr = *snr * 0xffff / 23;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t*snr = *snr * 0xffff / 26;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t*snr = *snr * 0xffff / 32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t*snr = 0;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9033_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct af9033_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\n\tint ret, tmp, power_real;\n\tunsigned int utmp;\n\tu8 gain_offset, buf[7];\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tif (dev->is_af9035) {\n\t\t \n\t\tret = regmap_read(dev->regmap, 0x800048, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\t*strength = utmp * 0xffff / 100;\n\t} else {\n\t\tret = regmap_read(dev->regmap, 0x8000f7, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = regmap_bulk_read(dev->regmap, 0x80f900, buf, 7);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (c->frequency <= 300000000)\n\t\t\tgain_offset = 7;  \n\t\telse\n\t\t\tgain_offset = 4;  \n\n\t\tpower_real = (utmp - 100 - gain_offset) -\n\t\t\tpower_reference[((buf[3] >> 0) & 3)][((buf[6] >> 0) & 7)];\n\n\t\tif (power_real < -15)\n\t\t\ttmp = 0;\n\t\telse if ((power_real >= -15) && (power_real < 0))\n\t\t\ttmp = (2 * (power_real + 15)) / 3;\n\t\telse if ((power_real >= 0) && (power_real < 20))\n\t\t\ttmp = 4 * power_real + 10;\n\t\telse if ((power_real >= 20) && (power_real < 35))\n\t\t\ttmp = (2 * (power_real - 20)) / 3 + 90;\n\t\telse\n\t\t\ttmp = 100;\n\n\t\t \n\t\t*strength = tmp * 0xffff / 100;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9033_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct af9033_dev *dev = fe->demodulator_priv;\n\n\t*ber = (dev->post_bit_error - dev->post_bit_error_prev);\n\tdev->post_bit_error_prev = dev->post_bit_error;\n\n\treturn 0;\n}\n\nstatic int af9033_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct af9033_dev *dev = fe->demodulator_priv;\n\n\t*ucblocks = dev->error_block_count;\n\n\treturn 0;\n}\n\nstatic int af9033_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct af9033_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"enable=%d\\n\", enable);\n\n\tret = regmap_update_bits(dev->regmap, 0x00fa04, 0x01, enable);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9033_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct af9033_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"onoff=%d\\n\", onoff);\n\n\tret = regmap_update_bits(dev->regmap, 0x80f993, 0x01, onoff);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int af9033_pid_filter(struct dvb_frontend *fe, int index, u16 pid,\n\t\t\t     int onoff)\n{\n\tstruct af9033_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu8 wbuf[2] = {(pid >> 0) & 0xff, (pid >> 8) & 0xff};\n\n\tdev_dbg(&client->dev, \"index=%d pid=%04x onoff=%d\\n\",\n\t\tindex, pid, onoff);\n\n\tif (pid > 0x1fff)\n\t\treturn 0;\n\n\tret = regmap_bulk_write(dev->regmap, 0x80f996, wbuf, 2);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x80f994, onoff);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x80f995, index);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dvb_frontend_ops af9033_ops = {\n\t.delsys = {SYS_DVBT},\n\t.info = {\n\t\t.name = \"Afatech AF9033 (DVB-T)\",\n\t\t.frequency_min_hz = 174 * MHz,\n\t\t.frequency_max_hz = 862 * MHz,\n\t\t.frequency_stepsize_hz = 250 * kHz,\n\t\t.caps =\tFE_CAN_FEC_1_2 |\n\t\t\tFE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 |\n\t\t\tFE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK |\n\t\t\tFE_CAN_QAM_16 |\n\t\t\tFE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO |\n\t\t\tFE_CAN_RECOVER |\n\t\t\tFE_CAN_MUTE_TS\n\t},\n\n\t.init = af9033_init,\n\t.sleep = af9033_sleep,\n\n\t.get_tune_settings = af9033_get_tune_settings,\n\t.set_frontend = af9033_set_frontend,\n\t.get_frontend = af9033_get_frontend,\n\n\t.read_status = af9033_read_status,\n\t.read_snr = af9033_read_snr,\n\t.read_signal_strength = af9033_read_signal_strength,\n\t.read_ber = af9033_read_ber,\n\t.read_ucblocks = af9033_read_ucblocks,\n\n\t.i2c_gate_ctrl = af9033_i2c_gate_ctrl,\n};\n\nstatic int af9033_probe(struct i2c_client *client)\n{\n\tstruct af9033_config *cfg = client->dev.platform_data;\n\tstruct af9033_dev *dev;\n\tint ret;\n\tu8 buf[8];\n\tu32 reg;\n\tstatic const struct regmap_config regmap_config = {\n\t\t.reg_bits    =  24,\n\t\t.val_bits    =  8,\n\t};\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tdev->client = client;\n\tmemcpy(&dev->cfg, cfg, sizeof(dev->cfg));\n\tswitch (dev->cfg.ts_mode) {\n\tcase AF9033_TS_MODE_PARALLEL:\n\t\tdev->ts_mode_parallel = true;\n\t\tbreak;\n\tcase AF9033_TS_MODE_SERIAL:\n\t\tdev->ts_mode_serial = true;\n\t\tbreak;\n\tcase AF9033_TS_MODE_USB:\n\t\t \n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (dev->cfg.clock != 12000000) {\n\t\tret = -ENODEV;\n\t\tdev_err(&client->dev,\n\t\t\t\"Unsupported clock %u Hz. Only 12000000 Hz is supported currently\\n\",\n\t\t\tdev->cfg.clock);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tdev->regmap = regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tswitch (dev->cfg.tuner) {\n\tcase AF9033_TUNER_IT9135_38:\n\tcase AF9033_TUNER_IT9135_51:\n\tcase AF9033_TUNER_IT9135_52:\n\tcase AF9033_TUNER_IT9135_60:\n\tcase AF9033_TUNER_IT9135_61:\n\tcase AF9033_TUNER_IT9135_62:\n\t\tdev->is_it9135 = true;\n\t\treg = 0x004bfc;\n\t\tbreak;\n\tdefault:\n\t\tdev->is_af9035 = true;\n\t\treg = 0x0083e9;\n\t\tbreak;\n\t}\n\n\tret = regmap_bulk_read(dev->regmap, reg, &buf[0], 4);\n\tif (ret)\n\t\tgoto err_regmap_exit;\n\tret = regmap_bulk_read(dev->regmap, 0x804191, &buf[4], 4);\n\tif (ret)\n\t\tgoto err_regmap_exit;\n\n\tdev_info(&client->dev,\n\t\t \"firmware version: LINK %d.%d.%d.%d - OFDM %d.%d.%d.%d\\n\",\n\t\t buf[0], buf[1], buf[2], buf[3],\n\t\t buf[4], buf[5], buf[6], buf[7]);\n\n\t \n\t \n\tif (dev->is_af9035) {\n\t\tret = regmap_write(dev->regmap, 0x80004c, 0x01);\n\t\tif (ret)\n\t\t\tgoto err_regmap_exit;\n\t\tret = regmap_write(dev->regmap, 0x800000, 0x00);\n\t\tif (ret)\n\t\t\tgoto err_regmap_exit;\n\t}\n\n\t \n\tmemcpy(&dev->fe.ops, &af9033_ops, sizeof(dev->fe.ops));\n\tdev->fe.demodulator_priv = dev;\n\t*cfg->fe = &dev->fe;\n\tif (cfg->ops) {\n\t\tcfg->ops->pid_filter = af9033_pid_filter;\n\t\tcfg->ops->pid_filter_ctrl = af9033_pid_filter_ctrl;\n\t}\n\tcfg->regmap = dev->regmap;\n\ti2c_set_clientdata(client, dev);\n\n\tdev_info(&client->dev, \"Afatech AF9033 successfully attached\\n\");\n\n\treturn 0;\nerr_regmap_exit:\n\tregmap_exit(dev->regmap);\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void af9033_remove(struct i2c_client *client)\n{\n\tstruct af9033_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tregmap_exit(dev->regmap);\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id af9033_id_table[] = {\n\t{\"af9033\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, af9033_id_table);\n\nstatic struct i2c_driver af9033_driver = {\n\t.driver = {\n\t\t.name\t= \"af9033\",\n\t\t.suppress_bind_attrs\t= true,\n\t},\n\t.probe\t\t= af9033_probe,\n\t.remove\t\t= af9033_remove,\n\t.id_table\t= af9033_id_table,\n};\n\nmodule_i2c_driver(af9033_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Afatech AF9033 DVB-T demodulator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}