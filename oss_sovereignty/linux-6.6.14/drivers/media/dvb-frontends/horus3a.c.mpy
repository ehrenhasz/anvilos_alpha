{
  "module_name": "horus3a.c",
  "hash_id": "1c426b94fb3ad26332d3a46cbf57939e7a4df85eef84f13a19a333b54a522a8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/horus3a.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/dvb/frontend.h>\n#include <linux/types.h>\n#include \"horus3a.h\"\n#include <media/dvb_frontend.h>\n\n#define MAX_WRITE_REGSIZE      5\n\nenum horus3a_state {\n\tSTATE_UNKNOWN,\n\tSTATE_SLEEP,\n\tSTATE_ACTIVE\n};\n\nstruct horus3a_priv {\n\tu32\t\t\tfrequency;\n\tu8\t\t\ti2c_address;\n\tstruct i2c_adapter\t*i2c;\n\tenum horus3a_state\tstate;\n\tvoid\t\t\t*set_tuner_data;\n\tint\t\t\t(*set_tuner)(void *, int);\n};\n\nstatic void horus3a_i2c_debug(struct horus3a_priv *priv,\n\t\t\t      u8 reg, u8 write, const u8 *data, u32 len)\n{\n\tdev_dbg(&priv->i2c->dev, \"horus3a: I2C %s reg 0x%02x size %d\\n\",\n\t\t(write == 0 ? \"read\" : \"write\"), reg, len);\n\tprint_hex_dump_bytes(\"horus3a: I2C data: \",\n\t\tDUMP_PREFIX_OFFSET, data, len);\n}\n\nstatic int horus3a_write_regs(struct horus3a_priv *priv,\n\t\t\t      u8 reg, const u8 *data, u32 len)\n{\n\tint ret;\n\tu8 buf[MAX_WRITE_REGSIZE + 1];\n\tstruct i2c_msg msg[1] = {\n\t\t{\n\t\t\t.addr = priv->i2c_address,\n\t\t\t.flags = 0,\n\t\t\t.len = len + 1,\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\n\tif (len + 1 > sizeof(buf)) {\n\t\tdev_warn(&priv->i2c->dev,\"wr reg=%04x: len=%d is too big!\\n\",\n\t\t\t reg, len + 1);\n\t\treturn -E2BIG;\n\t}\n\n\thorus3a_i2c_debug(priv, reg, 1, data, len);\n\tbuf[0] = reg;\n\tmemcpy(&buf[1], data, len);\n\tret = i2c_transfer(priv->i2c, msg, 1);\n\tif (ret >= 0 && ret != 1)\n\t\tret = -EREMOTEIO;\n\tif (ret < 0) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t\"%s: i2c wr failed=%d reg=%02x len=%d\\n\",\n\t\t\tKBUILD_MODNAME, ret, reg, len);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int horus3a_write_reg(struct horus3a_priv *priv, u8 reg, u8 val)\n{\n\tu8 tmp = val;  \n\n\treturn horus3a_write_regs(priv, reg, &tmp, 1);\n}\n\nstatic int horus3a_enter_power_save(struct horus3a_priv *priv)\n{\n\tu8 data[2];\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state == STATE_SLEEP)\n\t\treturn 0;\n\t \n\thorus3a_write_reg(priv, 0x2a, 0x79);\n\t \n\thorus3a_write_reg(priv, 0x29, 0x70);\n\t \n\thorus3a_write_reg(priv, 0x28, 0x3e);\n\t \n\thorus3a_write_reg(priv, 0x2a, 0x19);\n\t \n\thorus3a_write_reg(priv, 0x1c, 0x00);\n\t \n\tdata[0] = 0xC0;\n\t \n\tdata[1] = 0xA7;\n\t \n\thorus3a_write_regs(priv, 0x11, data, sizeof(data));\n\tpriv->state = STATE_SLEEP;\n\treturn 0;\n}\n\nstatic int horus3a_leave_power_save(struct horus3a_priv *priv)\n{\n\tu8 data[2];\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state == STATE_ACTIVE)\n\t\treturn 0;\n\t \n\tdata[0] = 0x00;\n\t \n\tdata[1] = 0xa7;\n\t \n\thorus3a_write_regs(priv, 0x11, data, sizeof(data));\n\t \n\thorus3a_write_reg(priv, 0x2a, 0x79);\n\t \n\thorus3a_write_reg(priv, 0x1c, 0xc0);\n\t \n\thorus3a_write_reg(priv, 0x29, 0x71);\n\tusleep_range(5000, 7000);\n\tpriv->state = STATE_ACTIVE;\n\treturn 0;\n}\n\nstatic int horus3a_init(struct dvb_frontend *fe)\n{\n\tstruct horus3a_priv *priv = fe->tuner_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\treturn 0;\n}\n\nstatic void horus3a_release(struct dvb_frontend *fe)\n{\n\tstruct horus3a_priv *priv = fe->tuner_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int horus3a_sleep(struct dvb_frontend *fe)\n{\n\tstruct horus3a_priv *priv = fe->tuner_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\thorus3a_enter_power_save(priv);\n\treturn 0;\n}\n\nstatic int horus3a_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct horus3a_priv *priv = fe->tuner_priv;\n\tu32 frequency = p->frequency;\n\tu32 symbol_rate = p->symbol_rate/1000;\n\tu8 mixdiv = 0;\n\tu8 mdiv = 0;\n\tu32 ms = 0;\n\tu8 f_ctl = 0;\n\tu8 g_ctl = 0;\n\tu8 fc_lpf = 0;\n\tu8 data[5];\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): frequency %dkHz symbol_rate %dksps\\n\",\n\t\t__func__, frequency, symbol_rate);\n\tif (priv->set_tuner)\n\t\tpriv->set_tuner(priv->set_tuner_data, 0);\n\tif (priv->state == STATE_SLEEP)\n\t\thorus3a_leave_power_save(priv);\n\n\t \n\tfrequency = DIV_ROUND_CLOSEST(frequency, 1000) * 1000;\n\tif (frequency <= 1155000) {\n\t\tmixdiv = 4;\n\t\tmdiv = 1;\n\t} else {\n\t\tmixdiv = 2;\n\t\tmdiv = 0;\n\t}\n\t \n\tms = DIV_ROUND_CLOSEST((frequency * mixdiv) / 2, 1000);\n\tif (ms > 0x7FFF) {  \n\t\tdev_err(&priv->i2c->dev, \"horus3a: invalid frequency %d\\n\",\n\t\t\tfrequency);\n\t\treturn -EINVAL;\n\t}\n\tif (frequency < 975000) {\n\t\t \n\t\tf_ctl = 0x1C;\n\t\tg_ctl = 0x01;\n\t} else if (frequency < 1050000) {\n\t\t \n\t\tf_ctl = 0x18;\n\t\tg_ctl = 0x02;\n\t} else if (frequency < 1150000) {\n\t\t \n\t\tf_ctl = 0x14;\n\t\tg_ctl = 0x02;\n\t} else if (frequency < 1250000) {\n\t\t \n\t\tf_ctl = 0x10;\n\t\tg_ctl = 0x03;\n\t} else if (frequency < 1350000) {\n\t\t \n\t\tf_ctl = 0x0C;\n\t\tg_ctl = 0x04;\n\t} else if (frequency < 1450000) {\n\t\t \n\t\tf_ctl = 0x0A;\n\t\tg_ctl = 0x04;\n\t} else if (frequency < 1600000) {\n\t\t \n\t\tf_ctl = 0x07;\n\t\tg_ctl = 0x05;\n\t} else if (frequency < 1800000) {\n\t\t \n\t\tf_ctl = 0x04;\n\t\tg_ctl = 0x02;\n\t} else if (frequency < 2000000) {\n\t\t \n\t\tf_ctl = 0x02;\n\t\tg_ctl = 0x01;\n\t} else {\n\t\t \n\t\tf_ctl = 0x00;\n\t\tg_ctl = 0x00;\n\t}\n\t \n\tif (p->delivery_system == SYS_DVBS) {\n\t\t \n\t\tif (symbol_rate <= 4300)\n\t\t\tfc_lpf = 5;\n\t\telse if (symbol_rate <= 10000)\n\t\t\tfc_lpf = (u8)DIV_ROUND_UP(symbol_rate * 47, 40000);\n\t\telse\n\t\t\tfc_lpf = (u8)DIV_ROUND_UP(symbol_rate * 27, 40000) + 5;\n\t\t \n\t\tif (fc_lpf > 36)\n\t\t\tfc_lpf = 36;\n\t} else if (p->delivery_system == SYS_DVBS2) {\n\t\t \n\t\tif (symbol_rate <= 4500)\n\t\t\tfc_lpf = 5;\n\t\telse if (symbol_rate <= 10000)\n\t\t\tfc_lpf = (u8)((symbol_rate * 11 + (10000-1)) / 10000);\n\t\telse\n\t\t\tfc_lpf = (u8)((symbol_rate * 3 + (5000-1)) / 5000 + 5);\n\t\t \n\t\tif (fc_lpf > 36)\n\t\t\tfc_lpf = 36;\n\t} else {\n\t\tdev_err(&priv->i2c->dev,\n\t\t\t\"horus3a: invalid delivery system %d\\n\",\n\t\t\tp->delivery_system);\n\t\treturn -EINVAL;\n\t}\n\t \n\tdata[0] = (u8)((ms >> 7) & 0xFF);\n\tdata[1] = (u8)((ms << 1) & 0xFF);\n\tdata[2] = 0x00;\n\tdata[3] = 0x00;\n\tdata[4] = (u8)(mdiv << 7);\n\thorus3a_write_regs(priv, 0x00, data, sizeof(data));\n\t \n\thorus3a_write_reg(priv, 0x09, (u8)((g_ctl << 5) | f_ctl));\n\t \n\thorus3a_write_reg(priv, 0x37, (u8)(0x80 | (fc_lpf << 1)));\n\t \n\thorus3a_write_reg(priv, 0x05, 0x80);\n\t \n\thorus3a_write_reg(priv, 0x2a, 0x7b);\n\t \n\tmsleep(60);\n\t \n\tpriv->frequency = ms * 2 * 1000 / mixdiv;\n\treturn 0;\n}\n\nstatic int horus3a_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct horus3a_priv *priv = fe->tuner_priv;\n\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops horus3a_tuner_ops = {\n\t.info = {\n\t\t.name = \"Sony Horus3a\",\n\t\t.frequency_min_hz  =  950 * MHz,\n\t\t.frequency_max_hz  = 2150 * MHz,\n\t\t.frequency_step_hz =    1 * MHz,\n\t},\n\t.init = horus3a_init,\n\t.release = horus3a_release,\n\t.sleep = horus3a_sleep,\n\t.set_params = horus3a_set_params,\n\t.get_frequency = horus3a_get_frequency,\n};\n\nstruct dvb_frontend *horus3a_attach(struct dvb_frontend *fe,\n\t\t\t\t    const struct horus3a_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tu8 buf[3], val;\n\tstruct horus3a_priv *priv = NULL;\n\n\tpriv = kzalloc(sizeof(struct horus3a_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\tpriv->i2c_address = (config->i2c_address >> 1);\n\tpriv->i2c = i2c;\n\tpriv->set_tuner_data = config->set_tuner_priv;\n\tpriv->set_tuner = config->set_tuner_callback;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t \n\tusleep_range(4000, 6000);\n\t \n\thorus3a_write_reg(priv, 0x2a, 0x79);\n\t \n\tbuf[0] = config->xtal_freq_mhz;\n\tbuf[1] = config->xtal_freq_mhz;\n\tbuf[2] = 0;\n\t \n\thorus3a_write_regs(priv, 0x6, buf, 3);\n\t \n\thorus3a_write_reg(priv, 0x0a, 0x40);\n\tswitch (config->xtal_freq_mhz) {\n\tcase 27:\n\t\tval = 0x1f;\n\t\tbreak;\n\tcase 24:\n\t\tval = 0x10;\n\t\tbreak;\n\tcase 16:\n\t\tval = 0xc;\n\t\tbreak;\n\tdefault:\n\t\tval = 0;\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t\"horus3a: invalid xtal frequency %dMHz\\n\",\n\t\t\tconfig->xtal_freq_mhz);\n\t\tbreak;\n\t}\n\tval <<= 2;\n\thorus3a_write_reg(priv, 0x0e, val);\n\thorus3a_enter_power_save(priv);\n\tusleep_range(3000, 5000);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tmemcpy(&fe->ops.tuner_ops, &horus3a_tuner_ops,\n\t\t\t\tsizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = priv;\n\tdev_info(&priv->i2c->dev,\n\t\t\"Sony HORUS3A attached on addr=%x at I2C adapter %p\\n\",\n\t\tpriv->i2c_address, priv->i2c);\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(horus3a_attach);\n\nMODULE_DESCRIPTION(\"Sony HORUS3A satellite tuner driver\");\nMODULE_AUTHOR(\"Sergey Kozlov <serjk@netup.ru>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}