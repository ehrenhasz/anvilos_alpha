{
  "module_name": "tda826x.c",
  "hash_id": "cbe44eab6227ea1dd64ade4aabc44c342b0216f9c155ef0ab160f4f8bfca0556",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tda826x.c",
  "human_readable_source": "\n   \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/dvb/frontend.h>\n#include <asm/types.h>\n\n#include \"tda826x.h\"\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) printk(KERN_DEBUG \"tda826x: \" args); \\\n\t} while (0)\n\nstruct tda826x_priv {\n\t \n\tint i2c_address;\n\tstruct i2c_adapter *i2c;\n\tu8 has_loopthrough:1;\n\tu32 frequency;\n};\n\nstatic void tda826x_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int tda826x_sleep(struct dvb_frontend *fe)\n{\n\tstruct tda826x_priv *priv = fe->tuner_priv;\n\tint ret;\n\tu8 buf [] = { 0x00, 0x8d };\n\tstruct i2c_msg msg = { .addr = priv->i2c_address, .flags = 0, .buf = buf, .len = 2 };\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tif (!priv->has_loopthrough)\n\t\tbuf[1] = 0xad;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif ((ret = i2c_transfer (priv->i2c, &msg, 1)) != 1) {\n\t\tdprintk(\"%s: i2c error\\n\", __func__);\n\t}\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn (ret == 1) ? 0 : ret;\n}\n\nstatic int tda826x_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct tda826x_priv *priv = fe->tuner_priv;\n\tint ret;\n\tu32 div;\n\tu32 ksyms;\n\tu32 bandwidth;\n\tu8 buf [11];\n\tstruct i2c_msg msg = { .addr = priv->i2c_address, .flags = 0, .buf = buf, .len = 11 };\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tdiv = (p->frequency + (1000-1)) / 1000;\n\n\t \n\t \n\tksyms = p->symbol_rate / 1000;\n\tbandwidth = (878 * ksyms + 6500000) / 1000000 + 1;\n\tif (bandwidth < 5)\n\t\tbandwidth = 5;\n\telse if (bandwidth > 36)\n\t\tbandwidth = 36;\n\n\tbuf[0] = 0x00; \n\tbuf[1] = 0x09; \n\tif (!priv->has_loopthrough)\n\t\tbuf[1] |= 0x20; \n\tbuf[2] = (1<<5) | 0x0b; \n\tbuf[3] = div >> 7;\n\tbuf[4] = div << 1;\n\tbuf[5] = ((bandwidth - 5) << 3) | 7;  \n\tbuf[6] = 0xfe; \n\tbuf[7] = 0x83; \n\tbuf[8] = 0x80; \n\tbuf[9] = 0x1a; \n\tbuf[10] = 0xd4; \n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif ((ret = i2c_transfer (priv->i2c, &msg, 1)) != 1) {\n\t\tdprintk(\"%s: i2c error\\n\", __func__);\n\t}\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tpriv->frequency = div * 1000;\n\n\treturn (ret == 1) ? 0 : ret;\n}\n\nstatic int tda826x_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct tda826x_priv *priv = fe->tuner_priv;\n\t*frequency = priv->frequency;\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops tda826x_tuner_ops = {\n\t.info = {\n\t\t.name = \"Philips TDA826X\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2175 * MHz\n\t},\n\t.release = tda826x_release,\n\t.sleep = tda826x_sleep,\n\t.set_params = tda826x_set_params,\n\t.get_frequency = tda826x_get_frequency,\n};\n\nstruct dvb_frontend *tda826x_attach(struct dvb_frontend *fe, int addr, struct i2c_adapter *i2c, int has_loopthrough)\n{\n\tstruct tda826x_priv *priv = NULL;\n\tu8 b1 [] = { 0, 0 };\n\tstruct i2c_msg msg[2] = {\n\t\t{ .addr = addr, .flags = 0,        .buf = NULL, .len = 0 },\n\t\t{ .addr = addr, .flags = I2C_M_RD, .buf = b1, .len = 2 }\n\t};\n\tint ret;\n\n\tdprintk(\"%s:\\n\", __func__);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tret = i2c_transfer (i2c, msg, 2);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tif (ret != 2)\n\t\treturn NULL;\n\tif (!(b1[1] & 0x80))\n\t\treturn NULL;\n\n\tpriv = kzalloc(sizeof(struct tda826x_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\n\tpriv->i2c_address = addr;\n\tpriv->i2c = i2c;\n\tpriv->has_loopthrough = has_loopthrough;\n\n\tmemcpy(&fe->ops.tuner_ops, &tda826x_tuner_ops, sizeof(struct dvb_tuner_ops));\n\n\tfe->tuner_priv = priv;\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(tda826x_attach);\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"DVB TDA826x driver\");\nMODULE_AUTHOR(\"Andrew de Quincey\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}