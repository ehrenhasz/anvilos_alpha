{
  "module_name": "mb86a20s.c",
  "hash_id": "ee28022e6c0b981c1910e574b6263c2122858ce03eeddc7210fe913fdf13d858",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/mb86a20s.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"mb86a20s.h\"\n\n#define NUM_LAYERS 3\n\nenum mb86a20s_bandwidth {\n\tMB86A20S_13SEG = 0,\n\tMB86A20S_13SEG_PARTIAL = 1,\n\tMB86A20S_1SEG = 2,\n\tMB86A20S_3SEG = 3,\n};\n\nstatic u8 mb86a20s_subchannel[] = {\n\t0xb0, 0xc0, 0xd0, 0xe0,\n\t0xf0, 0x00, 0x10, 0x20,\n};\n\nstruct mb86a20s_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct mb86a20s_config *config;\n\tu32 last_frequency;\n\n\tstruct dvb_frontend frontend;\n\n\tu32 if_freq;\n\tenum mb86a20s_bandwidth bw;\n\tbool inversion;\n\tu32 subchannel;\n\n\tu32 estimated_rate[NUM_LAYERS];\n\tunsigned long get_strength_time;\n\n\tbool need_init;\n};\n\nstruct regdata {\n\tu8 reg;\n\tu8 data;\n};\n\n#define BER_SAMPLING_RATE\t1\t \n\n \nstatic struct regdata mb86a20s_init1[] = {\n\t{ 0x70, 0x0f },\n\t{ 0x70, 0xff },\n\t{ 0x08, 0x01 },\n\t{ 0x50, 0xd1 }, { 0x51, 0x20 },\n};\n\nstatic struct regdata mb86a20s_init2[] = {\n\t{ 0x50, 0xd1 }, { 0x51, 0x22 },\n\t{ 0x39, 0x01 },\n\t{ 0x71, 0x00 },\n\t{ 0x3b, 0x21 },\n\t{ 0x3c, 0x3a },\n\t{ 0x01, 0x0d },\n\t{ 0x04, 0x08 }, { 0x05, 0x05 },\n\t{ 0x04, 0x0e }, { 0x05, 0x00 },\n\t{ 0x04, 0x0f }, { 0x05, 0x14 },\n\t{ 0x04, 0x0b }, { 0x05, 0x8c },\n\t{ 0x04, 0x00 }, { 0x05, 0x00 },\n\t{ 0x04, 0x01 }, { 0x05, 0x07 },\n\t{ 0x04, 0x02 }, { 0x05, 0x0f },\n\t{ 0x04, 0x03 }, { 0x05, 0xa0 },\n\t{ 0x04, 0x09 }, { 0x05, 0x00 },\n\t{ 0x04, 0x0a }, { 0x05, 0xff },\n\t{ 0x04, 0x27 }, { 0x05, 0x64 },\n\t{ 0x04, 0x28 }, { 0x05, 0x00 },\n\t{ 0x04, 0x1e }, { 0x05, 0xff },\n\t{ 0x04, 0x29 }, { 0x05, 0x0a },\n\t{ 0x04, 0x32 }, { 0x05, 0x0a },\n\t{ 0x04, 0x14 }, { 0x05, 0x02 },\n\t{ 0x04, 0x04 }, { 0x05, 0x00 },\n\t{ 0x04, 0x05 }, { 0x05, 0x22 },\n\t{ 0x04, 0x06 }, { 0x05, 0x0e },\n\t{ 0x04, 0x07 }, { 0x05, 0xd8 },\n\t{ 0x04, 0x12 }, { 0x05, 0x00 },\n\t{ 0x04, 0x13 }, { 0x05, 0xff },\n\n\t \n\t{ 0x52, 0x01 },\t\t\t\t \n\t{ 0x50, 0xa7 }, { 0x51, 0x00 },\n\t{ 0x50, 0xa8 }, { 0x51, 0xff },\n\t{ 0x50, 0xa9 }, { 0x51, 0xff },\n\t{ 0x50, 0xaa }, { 0x51, 0x00 },\n\t{ 0x50, 0xab }, { 0x51, 0xff },\n\t{ 0x50, 0xac }, { 0x51, 0xff },\n\t{ 0x50, 0xad }, { 0x51, 0x00 },\n\t{ 0x50, 0xae }, { 0x51, 0xff },\n\t{ 0x50, 0xaf }, { 0x51, 0xff },\n\n\t \n\t{ 0x5e, 0x07 },\t\t\t\t \n\t{ 0x50, 0xdc }, { 0x51, 0x00 },\n\t{ 0x50, 0xdd }, { 0x51, 0x7f },\n\t{ 0x50, 0xde }, { 0x51, 0x00 },\n\t{ 0x50, 0xdf }, { 0x51, 0x7f },\n\t{ 0x50, 0xe0 }, { 0x51, 0x00 },\n\t{ 0x50, 0xe1 }, { 0x51, 0x7f },\n\n\t \n\t{ 0x50, 0xb0 }, { 0x51, 0x07 },\t\t \n\t{ 0x50, 0xb2 }, { 0x51, 0x00 },\n\t{ 0x50, 0xb3 }, { 0x51, 0x7f },\n\t{ 0x50, 0xb4 }, { 0x51, 0x00 },\n\t{ 0x50, 0xb5 }, { 0x51, 0x7f },\n\t{ 0x50, 0xb6 }, { 0x51, 0x00 },\n\t{ 0x50, 0xb7 }, { 0x51, 0x7f },\n\n\t{ 0x50, 0x50 }, { 0x51, 0x02 },\t\t \n\t{ 0x50, 0x51 }, { 0x51, 0x04 },\t\t \n\t{ 0x45, 0x04 },\t\t\t\t \n\t{ 0x48, 0x04 },\t\t\t\t \n\t{ 0x50, 0xd5 }, { 0x51, 0x01 },\n\t{ 0x50, 0xd6 }, { 0x51, 0x1f },\n\t{ 0x50, 0xd2 }, { 0x51, 0x03 },\n\t{ 0x50, 0xd7 }, { 0x51, 0x3f },\n\t{ 0x1c, 0x01 },\n\t{ 0x28, 0x06 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x03 },\n\t{ 0x28, 0x07 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0d },\n\t{ 0x28, 0x08 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x02 },\n\t{ 0x28, 0x09 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x01 },\n\t{ 0x28, 0x0a }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x21 },\n\t{ 0x28, 0x0b }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x29 },\n\t{ 0x28, 0x0c }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x16 },\n\t{ 0x28, 0x0d }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x31 },\n\t{ 0x28, 0x0e }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0e },\n\t{ 0x28, 0x0f }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x4e },\n\t{ 0x28, 0x10 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x46 },\n\t{ 0x28, 0x11 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0f },\n\t{ 0x28, 0x12 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x56 },\n\t{ 0x28, 0x13 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x35 },\n\t{ 0x28, 0x14 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xbe },\n\t{ 0x28, 0x15 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0x84 },\n\t{ 0x28, 0x16 }, { 0x29, 0x00 }, { 0x2a, 0x03 }, { 0x2b, 0xee },\n\t{ 0x28, 0x17 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x98 },\n\t{ 0x28, 0x18 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x9f },\n\t{ 0x28, 0x19 }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xb2 },\n\t{ 0x28, 0x1a }, { 0x29, 0x00 }, { 0x2a, 0x06 }, { 0x2b, 0xc2 },\n\t{ 0x28, 0x1b }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0x4a },\n\t{ 0x28, 0x1c }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xbc },\n\t{ 0x28, 0x1d }, { 0x29, 0x00 }, { 0x2a, 0x04 }, { 0x2b, 0xba },\n\t{ 0x28, 0x1e }, { 0x29, 0x00 }, { 0x2a, 0x06 }, { 0x2b, 0x14 },\n\t{ 0x50, 0x1e }, { 0x51, 0x5d },\n\t{ 0x50, 0x22 }, { 0x51, 0x00 },\n\t{ 0x50, 0x23 }, { 0x51, 0xc8 },\n\t{ 0x50, 0x24 }, { 0x51, 0x00 },\n\t{ 0x50, 0x25 }, { 0x51, 0xf0 },\n\t{ 0x50, 0x26 }, { 0x51, 0x00 },\n\t{ 0x50, 0x27 }, { 0x51, 0xc3 },\n\t{ 0x50, 0x39 }, { 0x51, 0x02 },\n\t{ 0x50, 0xd5 }, { 0x51, 0x01 },\n\t{ 0xd0, 0x00 },\n};\n\nstatic struct regdata mb86a20s_reset_reception[] = {\n\t{ 0x70, 0xf0 },\n\t{ 0x70, 0xff },\n\t{ 0x08, 0x01 },\n\t{ 0x08, 0x00 },\n};\n\nstatic struct regdata mb86a20s_per_ber_reset[] = {\n\t{ 0x53, 0x00 },\t \n\t{ 0x53, 0x07 },\n\n\t{ 0x5f, 0x00 },\t \n\t{ 0x5f, 0x07 },\n\n\t{ 0x50, 0xb1 },\t \n\t{ 0x51, 0x07 },\n\t{ 0x51, 0x00 },\n};\n\n \n\nstatic int mb86a20s_i2c_writereg(struct mb86a20s_state *state,\n\t\t\t     u8 i2c_addr, u8 reg, u8 data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = {\n\t\t.addr = i2c_addr, .flags = 0, .buf = buf, .len = 2\n\t};\n\tint rc;\n\n\trc = i2c_transfer(state->i2c, &msg, 1);\n\tif (rc != 1) {\n\t\tdev_err(&state->i2c->dev,\n\t\t\t\"%s: writereg error (rc == %i, reg == 0x%02x, data == 0x%02x)\\n\",\n\t\t\t__func__, rc, reg, data);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int mb86a20s_i2c_writeregdata(struct mb86a20s_state *state,\n\t\t\t\t     u8 i2c_addr, struct regdata *rd, int size)\n{\n\tint i, rc;\n\n\tfor (i = 0; i < size; i++) {\n\t\trc = mb86a20s_i2c_writereg(state, i2c_addr, rd[i].reg,\n\t\t\t\t\t   rd[i].data);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int mb86a20s_i2c_readreg(struct mb86a20s_state *state,\n\t\t\t\tu8 i2c_addr, u8 reg)\n{\n\tu8 val;\n\tint rc;\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = i2c_addr, .flags = 0, .buf = &reg, .len = 1 },\n\t\t{ .addr = i2c_addr, .flags = I2C_M_RD, .buf = &val, .len = 1 }\n\t};\n\n\trc = i2c_transfer(state->i2c, msg, 2);\n\n\tif (rc != 2) {\n\t\tdev_err(&state->i2c->dev, \"%s: reg=0x%x (error=%d)\\n\",\n\t\t\t__func__, reg, rc);\n\t\treturn (rc < 0) ? rc : -EIO;\n\t}\n\n\treturn val;\n}\n\n#define mb86a20s_readreg(state, reg) \\\n\tmb86a20s_i2c_readreg(state, state->config->demod_address, reg)\n#define mb86a20s_writereg(state, reg, val) \\\n\tmb86a20s_i2c_writereg(state, state->config->demod_address, reg, val)\n#define mb86a20s_writeregdata(state, regdata) \\\n\tmb86a20s_i2c_writeregdata(state, state->config->demod_address, \\\n\tregdata, ARRAY_SIZE(regdata))\n\n \n\nstatic int mb86a20s_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tint val;\n\n\t*status = 0;\n\n\tval = mb86a20s_readreg(state, 0x0a);\n\tif (val < 0)\n\t\treturn val;\n\n\tval &= 0xf;\n\tif (val >= 2)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (val >= 4)\n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (val >= 5)\n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (val >= 7)\n\t\t*status |= FE_HAS_SYNC;\n\n\t \n\tif (val >= 9)\n\t\t*status |= FE_HAS_LOCK;\n\n\tdev_dbg(&state->i2c->dev, \"%s: Status = 0x%02x (state = %d)\\n\",\n\t\t __func__, *status, val);\n\n\treturn val;\n}\n\nstatic int mb86a20s_read_signal_strength(struct dvb_frontend *fe)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint rc;\n\tunsigned rf_max, rf_min, rf;\n\n\tif (state->get_strength_time &&\n\t   (!time_after(jiffies, state->get_strength_time)))\n\t\treturn c->strength.stat[0].uvalue;\n\n\t \n\tc->strength.stat[0].uvalue = 0;\n\n\t \n\trf_max = 0xfff;\n\trf_min = 0;\n\tdo {\n\t\trf = (rf_max + rf_min) / 2;\n\t\trc = mb86a20s_writereg(state, 0x04, 0x1f);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x05, rf >> 8);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x04, 0x20);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x05, rf);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = mb86a20s_readreg(state, 0x02);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (rc & 0x08)\n\t\t\trf_min = (rf_max + rf_min) / 2;\n\t\telse\n\t\t\trf_max = (rf_max + rf_min) / 2;\n\t\tif (rf_max - rf_min < 4) {\n\t\t\trf = (rf_max + rf_min) / 2;\n\n\t\t\t \n\t\t\trf = rf << (16 - 12);\n\t\t\tif (rf)\n\t\t\t\trf |= (1 << 12) - 1;\n\n\t\t\tdev_dbg(&state->i2c->dev,\n\t\t\t\t\"%s: signal strength = %d (%d < RF=%d < %d)\\n\",\n\t\t\t\t__func__, rf, rf_min, rf >> 4, rf_max);\n\t\t\tc->strength.stat[0].uvalue = rf;\n\t\t\tstate->get_strength_time = jiffies +\n\t\t\t\t\t\t   msecs_to_jiffies(1000);\n\t\t\treturn 0;\n\t\t}\n\t} while (1);\n}\n\nstatic int mb86a20s_get_modulation(struct mb86a20s_state *state,\n\t\t\t\t   unsigned layer)\n{\n\tint rc;\n\tstatic unsigned char reg[] = {\n\t\t[0] = 0x86,\t \n\t\t[1] = 0x8a,\t \n\t\t[2] = 0x8e,\t \n\t};\n\n\tif (layer >= ARRAY_SIZE(reg))\n\t\treturn -EINVAL;\n\trc = mb86a20s_writereg(state, 0x6d, reg[layer]);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x6e);\n\tif (rc < 0)\n\t\treturn rc;\n\tswitch ((rc >> 4) & 0x07) {\n\tcase 0:\n\t\treturn DQPSK;\n\tcase 1:\n\t\treturn QPSK;\n\tcase 2:\n\t\treturn QAM_16;\n\tcase 3:\n\t\treturn QAM_64;\n\tdefault:\n\t\treturn QAM_AUTO;\n\t}\n}\n\nstatic int mb86a20s_get_fec(struct mb86a20s_state *state,\n\t\t\t    unsigned layer)\n{\n\tint rc;\n\n\tstatic unsigned char reg[] = {\n\t\t[0] = 0x87,\t \n\t\t[1] = 0x8b,\t \n\t\t[2] = 0x8f,\t \n\t};\n\n\tif (layer >= ARRAY_SIZE(reg))\n\t\treturn -EINVAL;\n\trc = mb86a20s_writereg(state, 0x6d, reg[layer]);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x6e);\n\tif (rc < 0)\n\t\treturn rc;\n\tswitch ((rc >> 4) & 0x07) {\n\tcase 0:\n\t\treturn FEC_1_2;\n\tcase 1:\n\t\treturn FEC_2_3;\n\tcase 2:\n\t\treturn FEC_3_4;\n\tcase 3:\n\t\treturn FEC_5_6;\n\tcase 4:\n\t\treturn FEC_7_8;\n\tdefault:\n\t\treturn FEC_AUTO;\n\t}\n}\n\nstatic int mb86a20s_get_interleaving(struct mb86a20s_state *state,\n\t\t\t\t     unsigned layer)\n{\n\tint rc;\n\tstatic const int interleaving[] = {\n\t\t0, 1, 2, 4, 8\n\t};\n\n\tstatic const unsigned char reg[] = {\n\t\t[0] = 0x88,\t \n\t\t[1] = 0x8c,\t \n\t\t[2] = 0x90,\t \n\t};\n\n\tif (layer >= ARRAY_SIZE(reg))\n\t\treturn -EINVAL;\n\trc = mb86a20s_writereg(state, 0x6d, reg[layer]);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x6e);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn interleaving[(rc >> 4) & 0x07];\n}\n\nstatic int mb86a20s_get_segment_count(struct mb86a20s_state *state,\n\t\t\t\t      unsigned layer)\n{\n\tint rc, count;\n\tstatic unsigned char reg[] = {\n\t\t[0] = 0x89,\t \n\t\t[1] = 0x8d,\t \n\t\t[2] = 0x91,\t \n\t};\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\tif (layer >= ARRAY_SIZE(reg))\n\t\treturn -EINVAL;\n\n\trc = mb86a20s_writereg(state, 0x6d, reg[layer]);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x6e);\n\tif (rc < 0)\n\t\treturn rc;\n\tcount = (rc >> 4) & 0x0f;\n\n\tdev_dbg(&state->i2c->dev, \"%s: segments: %d.\\n\", __func__, count);\n\n\treturn count;\n}\n\nstatic void mb86a20s_reset_frontend_cache(struct dvb_frontend *fe)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\t \n\tc->delivery_system = SYS_ISDBT;\n\tc->bandwidth_hz = 6000000;\n\n\t \n\tc->isdbt_layer_enabled = 0;\n\tc->transmission_mode = TRANSMISSION_MODE_AUTO;\n\tc->guard_interval = GUARD_INTERVAL_AUTO;\n\tc->isdbt_sb_mode = 0;\n\tc->isdbt_sb_segment_count = 0;\n}\n\n \nstatic const u32 isdbt_rate[3][5][4] = {\n\t{\t \n\t\t{  280850,  312060,  330420,  340430 },\t \n\t\t{  374470,  416080,  440560,  453910 },\t \n\t\t{  421280,  468090,  495630,  510650 },\t \n\t\t{  468090,  520100,  550700,  567390 },\t \n\t\t{  491500,  546110,  578230,  595760 },\t \n\t}, {\t \n\t\t{  561710,  624130,  660840,  680870 },\t \n\t\t{  748950,  832170,  881120,  907820 },\t \n\t\t{  842570,  936190,  991260, 1021300 },\t \n\t\t{  936190, 1040210, 1101400, 1134780 },\t \n\t\t{  983000, 1092220, 1156470, 1191520 },\t \n\t}, {\t \n\t\t{  842570,  936190,  991260, 1021300 },\t \n\t\t{ 1123430, 1248260, 1321680, 1361740 },\t \n\t\t{ 1263860, 1404290, 1486900, 1531950 },\t \n\t\t{ 1404290, 1560320, 1652110, 1702170 },\t \n\t\t{ 1474500, 1638340, 1734710, 1787280 },\t \n\t}\n};\n\nstatic u32 isdbt_layer_min_bitrate(struct dtv_frontend_properties *c,\n\t\t\t\t   u32 layer)\n{\n\tint mod, fec, guard;\n\n\t \n\tswitch (c->layer[layer].modulation) {\n\tcase DQPSK:\n\tcase QPSK:\n\tdefault:\n\t\tmod = 0;\n\t\tbreak;\n\tcase QAM_16:\n\t\tmod = 1;\n\t\tbreak;\n\tcase QAM_64:\n\t\tmod = 2;\n\t\tbreak;\n\t}\n\n\tswitch (c->layer[layer].fec) {\n\tdefault:\n\tcase FEC_1_2:\n\tcase FEC_AUTO:\n\t\tfec = 0;\n\t\tbreak;\n\tcase FEC_2_3:\n\t\tfec = 1;\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tfec = 2;\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tfec = 3;\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tfec = 4;\n\t\tbreak;\n\t}\n\n\tswitch (c->guard_interval) {\n\tdefault:\n\tcase GUARD_INTERVAL_1_4:\n\t\tguard = 0;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_8:\n\t\tguard = 1;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_16:\n\t\tguard = 2;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_32:\n\t\tguard = 3;\n\t\tbreak;\n\t}\n\n\treturn isdbt_rate[mod][fec][guard] * c->layer[layer].segment_count;\n}\n\nstatic int mb86a20s_get_frontend(struct dvb_frontend *fe)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint layer, rc, rate, counter;\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\t \n\tmb86a20s_reset_frontend_cache(fe);\n\n\t \n\trc = mb86a20s_writereg(state, 0x6d, 0x85);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x6e);\n\tif (rc < 0)\n\t\treturn rc;\n\tc->isdbt_partial_reception = (rc & 0x10) ? 1 : 0;\n\n\t \n\n\tfor (layer = 0; layer < NUM_LAYERS; layer++) {\n\t\tdev_dbg(&state->i2c->dev, \"%s: getting data for layer %c.\\n\",\n\t\t\t__func__, 'A' + layer);\n\n\t\trc = mb86a20s_get_segment_count(state, layer);\n\t\tif (rc < 0)\n\t\t\tgoto noperlayer_error;\n\t\tif (rc >= 0 && rc < 14) {\n\t\t\tc->layer[layer].segment_count = rc;\n\t\t} else {\n\t\t\tc->layer[layer].segment_count = 0;\n\t\t\tstate->estimated_rate[layer] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tc->isdbt_layer_enabled |= 1 << layer;\n\t\trc = mb86a20s_get_modulation(state, layer);\n\t\tif (rc < 0)\n\t\t\tgoto noperlayer_error;\n\t\tdev_dbg(&state->i2c->dev, \"%s: modulation %d.\\n\",\n\t\t\t__func__, rc);\n\t\tc->layer[layer].modulation = rc;\n\t\trc = mb86a20s_get_fec(state, layer);\n\t\tif (rc < 0)\n\t\t\tgoto noperlayer_error;\n\t\tdev_dbg(&state->i2c->dev, \"%s: FEC %d.\\n\",\n\t\t\t__func__, rc);\n\t\tc->layer[layer].fec = rc;\n\t\trc = mb86a20s_get_interleaving(state, layer);\n\t\tif (rc < 0)\n\t\t\tgoto noperlayer_error;\n\t\tdev_dbg(&state->i2c->dev, \"%s: interleaving %d.\\n\",\n\t\t\t__func__, rc);\n\t\tc->layer[layer].interleaving = rc;\n\n\t\trate = isdbt_layer_min_bitrate(c, layer);\n\t\tcounter = rate * BER_SAMPLING_RATE;\n\n\t\t \n\t\tif (counter < 256)\n\t\t\tcounter = 256;\n\t\telse if (counter > (1 << 24) - 1)\n\t\t\tcounter = (1 << 24) - 1;\n\n\t\tdev_dbg(&state->i2c->dev,\n\t\t\t\"%s: layer %c bitrate: %d kbps; counter = %d (0x%06x)\\n\",\n\t\t\t__func__, 'A' + layer, rate / 1000, counter, counter);\n\n\t\tstate->estimated_rate[layer] = counter;\n\t}\n\n\trc = mb86a20s_writereg(state, 0x6d, 0x84);\n\tif (rc < 0)\n\t\treturn rc;\n\tif ((rc & 0x60) == 0x20) {\n\t\tc->isdbt_sb_mode = 1;\n\t\t \n\t\tif (!c->isdbt_sb_segment_count)\n\t\t\tc->isdbt_sb_segment_count = 1;\n\t}\n\n\t \n\trc = mb86a20s_readreg(state, 0x07);\n\tif (rc < 0)\n\t\treturn rc;\n\tc->transmission_mode = TRANSMISSION_MODE_AUTO;\n\tif ((rc & 0x60) == 0x20) {\n\t\t \n\t\tswitch ((rc >> 2) & 0x03) {\n\t\tcase 1:\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_4K;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t\t\tbreak;\n\t\t}\n\t}\n\tc->guard_interval = GUARD_INTERVAL_AUTO;\n\tif (!(rc & 0x10)) {\n\t\t \n\t\tswitch (rc & 0x3) {\n\t\tcase 0:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_16;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\nnoperlayer_error:\n\n\t \n\tc->isdbt_layer_enabled = 0;\n\n\treturn rc;\n}\n\nstatic int mb86a20s_reset_counters(struct dvb_frontend *fe)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint rc, val;\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\t \n\tif (state->last_frequency != c->frequency) {\n\t\tmemset(&c->cnr, 0, sizeof(c->cnr));\n\t\tmemset(&c->pre_bit_error, 0, sizeof(c->pre_bit_error));\n\t\tmemset(&c->pre_bit_count, 0, sizeof(c->pre_bit_count));\n\t\tmemset(&c->post_bit_error, 0, sizeof(c->post_bit_error));\n\t\tmemset(&c->post_bit_count, 0, sizeof(c->post_bit_count));\n\t\tmemset(&c->block_error, 0, sizeof(c->block_error));\n\t\tmemset(&c->block_count, 0, sizeof(c->block_count));\n\n\t\tstate->last_frequency = c->frequency;\n\t}\n\n\t \n\n\t \n\trc = mb86a20s_writeregdata(state, mb86a20s_per_ber_reset);\n\tif (rc < 0)\n\t\tgoto err;\n\n\t \n\trc = mb86a20s_readreg(state, 0x45);\n\tif (rc < 0)\n\t\tgoto err;\n\tval = rc;\n\trc = mb86a20s_writereg(state, 0x45, val | 0x10);\n\tif (rc < 0)\n\t\tgoto err;\n\trc = mb86a20s_writereg(state, 0x45, val & 0x6f);\n\tif (rc < 0)\n\t\tgoto err;\n\n\t \n\trc = mb86a20s_writereg(state, 0x50, 0x50);\n\tif (rc < 0)\n\t\tgoto err;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\tgoto err;\n\tval = rc;\n\trc = mb86a20s_writereg(state, 0x51, val | 0x01);\n\tif (rc < 0)\n\t\tgoto err;\n\trc = mb86a20s_writereg(state, 0x51, val & 0x06);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tgoto ok;\nerr:\n\tdev_err(&state->i2c->dev,\n\t\t\"%s: Can't reset FE statistics (error %d).\\n\",\n\t\t__func__, rc);\nok:\n\treturn rc;\n}\n\nstatic int mb86a20s_get_pre_ber(struct dvb_frontend *fe,\n\t\t\t\tunsigned layer,\n\t\t\t\tu32 *error, u32 *count)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tint rc, val;\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\tif (layer >= NUM_LAYERS)\n\t\treturn -EINVAL;\n\n\t \n\trc = mb86a20s_readreg(state, 0x54);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (!(rc & (1 << layer))) {\n\t\tdev_dbg(&state->i2c->dev,\n\t\t\t\"%s: preBER for layer %c is not available yet.\\n\",\n\t\t\t__func__, 'A' + layer);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\trc = mb86a20s_readreg(state, 0x55 + layer * 3);\n\tif (rc < 0)\n\t\treturn rc;\n\t*error = rc << 16;\n\trc = mb86a20s_readreg(state, 0x56 + layer * 3);\n\tif (rc < 0)\n\t\treturn rc;\n\t*error |= rc << 8;\n\trc = mb86a20s_readreg(state, 0x57 + layer * 3);\n\tif (rc < 0)\n\t\treturn rc;\n\t*error |= rc;\n\n\tdev_dbg(&state->i2c->dev,\n\t\t\"%s: bit error before Viterbi for layer %c: %d.\\n\",\n\t\t__func__, 'A' + layer, *error);\n\n\t \n\trc = mb86a20s_writereg(state, 0x50, 0xa7 + layer * 3);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\t*count = rc << 16;\n\trc = mb86a20s_writereg(state, 0x50, 0xa8 + layer * 3);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\t*count |= rc << 8;\n\trc = mb86a20s_writereg(state, 0x50, 0xa9 + layer * 3);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\t*count |= rc;\n\n\tdev_dbg(&state->i2c->dev,\n\t\t\"%s: bit count before Viterbi for layer %c: %d.\\n\",\n\t\t__func__, 'A' + layer, *count);\n\n\n\t \n\n\tif (state->estimated_rate[layer]\n\t    && state->estimated_rate[layer] != *count) {\n\t\tdev_dbg(&state->i2c->dev,\n\t\t\t\"%s: updating layer %c preBER counter to %d.\\n\",\n\t\t\t__func__, 'A' + layer, state->estimated_rate[layer]);\n\n\t\t \n\t\trc = mb86a20s_writereg(state, 0x52, 0x00);\n\n\t\t \n\t\trc = mb86a20s_writereg(state, 0x50, 0xa7 + layer * 3);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x51,\n\t\t\t\t       state->estimated_rate[layer] >> 16);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x50, 0xa8 + layer * 3);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x51,\n\t\t\t\t       state->estimated_rate[layer] >> 8);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x50, 0xa9 + layer * 3);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x51,\n\t\t\t\t       state->estimated_rate[layer]);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = mb86a20s_writereg(state, 0x52, 0x01);\n\n\t\t \n\t\trc = mb86a20s_writereg(state, 0x53, 0x00);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x53, 0x07);\n\t} else {\n\t\t \n\t\trc = mb86a20s_readreg(state, 0x53);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tval = rc;\n\t\trc = mb86a20s_writereg(state, 0x53, val & ~(1 << layer));\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x53, val | (1 << layer));\n\t}\n\n\treturn rc;\n}\n\nstatic int mb86a20s_get_post_ber(struct dvb_frontend *fe,\n\t\t\t\t unsigned layer,\n\t\t\t\t  u32 *error, u32 *count)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tu32 counter, collect_rate;\n\tint rc, val;\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\tif (layer >= NUM_LAYERS)\n\t\treturn -EINVAL;\n\n\t \n\trc = mb86a20s_readreg(state, 0x60);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (!(rc & (1 << layer))) {\n\t\tdev_dbg(&state->i2c->dev,\n\t\t\t\"%s: post BER for layer %c is not available yet.\\n\",\n\t\t\t__func__, 'A' + layer);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\trc = mb86a20s_readreg(state, 0x64 + layer * 3);\n\tif (rc < 0)\n\t\treturn rc;\n\t*error = rc << 16;\n\trc = mb86a20s_readreg(state, 0x65 + layer * 3);\n\tif (rc < 0)\n\t\treturn rc;\n\t*error |= rc << 8;\n\trc = mb86a20s_readreg(state, 0x66 + layer * 3);\n\tif (rc < 0)\n\t\treturn rc;\n\t*error |= rc;\n\n\tdev_dbg(&state->i2c->dev,\n\t\t\"%s: post bit error for layer %c: %d.\\n\",\n\t\t__func__, 'A' + layer, *error);\n\n\t \n\trc = mb86a20s_writereg(state, 0x50, 0xdc + layer * 2);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\tcounter = rc << 8;\n\trc = mb86a20s_writereg(state, 0x50, 0xdd + layer * 2);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\tcounter |= rc;\n\t*count = counter * 204 * 8;\n\n\tdev_dbg(&state->i2c->dev,\n\t\t\"%s: post bit count for layer %c: %d.\\n\",\n\t\t__func__, 'A' + layer, *count);\n\n\t \n\n\tif (!state->estimated_rate[layer])\n\t\tgoto reset_measurement;\n\n\tcollect_rate = state->estimated_rate[layer] / 204 / 8;\n\tif (collect_rate < 32)\n\t\tcollect_rate = 32;\n\tif (collect_rate > 65535)\n\t\tcollect_rate = 65535;\n\tif (collect_rate != counter) {\n\t\tdev_dbg(&state->i2c->dev,\n\t\t\t\"%s: updating postBER counter on layer %c to %d.\\n\",\n\t\t\t__func__, 'A' + layer, collect_rate);\n\n\t\t \n\t\trc = mb86a20s_writereg(state, 0x5e, 0x00);\n\n\t\t \n\t\trc = mb86a20s_writereg(state, 0x50, 0xdc + layer * 2);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x51, collect_rate >> 8);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x50, 0xdd + layer * 2);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x51, collect_rate & 0xff);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = mb86a20s_writereg(state, 0x5e, 0x07);\n\n\t\t \n\t\trc = mb86a20s_writereg(state, 0x5f, 0x00);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x5f, 0x07);\n\n\t\treturn rc;\n\t}\n\nreset_measurement:\n\t \n\trc = mb86a20s_readreg(state, 0x5f);\n\tif (rc < 0)\n\t\treturn rc;\n\tval = rc;\n\trc = mb86a20s_writereg(state, 0x5f, val & ~(1 << layer));\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_writereg(state, 0x5f, val | (1 << layer));\n\n\treturn rc;\n}\n\nstatic int mb86a20s_get_blk_error(struct dvb_frontend *fe,\n\t\t\t    unsigned layer,\n\t\t\t    u32 *error, u32 *count)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tint rc, val;\n\tu32 collect_rate;\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\tif (layer >= NUM_LAYERS)\n\t\treturn -EINVAL;\n\n\t \n\trc = mb86a20s_writereg(state, 0x50, 0xb8);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\n\tif (!(rc & (1 << layer))) {\n\t\tdev_dbg(&state->i2c->dev,\n\t\t\t\"%s: block counts for layer %c aren't available yet.\\n\",\n\t\t\t__func__, 'A' + layer);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\trc = mb86a20s_writereg(state, 0x50, 0xb9 + layer * 2);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\t*error = rc << 8;\n\trc = mb86a20s_writereg(state, 0x50, 0xba + layer * 2);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\t*error |= rc;\n\tdev_dbg(&state->i2c->dev, \"%s: block error for layer %c: %d.\\n\",\n\t\t__func__, 'A' + layer, *error);\n\n\t \n\trc = mb86a20s_writereg(state, 0x50, 0xb2 + layer * 2);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\t*count = rc << 8;\n\trc = mb86a20s_writereg(state, 0x50, 0xb3 + layer * 2);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\t*count |= rc;\n\n\tdev_dbg(&state->i2c->dev,\n\t\t\"%s: block count for layer %c: %d.\\n\",\n\t\t__func__, 'A' + layer, *count);\n\n\t \n\n\tif (!state->estimated_rate[layer])\n\t\tgoto reset_measurement;\n\n\tcollect_rate = state->estimated_rate[layer] / 204 / 8;\n\tif (collect_rate < 32)\n\t\tcollect_rate = 32;\n\tif (collect_rate > 65535)\n\t\tcollect_rate = 65535;\n\n\tif (collect_rate != *count) {\n\t\tdev_dbg(&state->i2c->dev,\n\t\t\t\"%s: updating PER counter on layer %c to %d.\\n\",\n\t\t\t__func__, 'A' + layer, collect_rate);\n\n\t\t \n\t\trc = mb86a20s_writereg(state, 0x50, 0xb0);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x51, 0x00);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = mb86a20s_writereg(state, 0x50, 0xb2 + layer * 2);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x51, collect_rate >> 8);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x50, 0xb3 + layer * 2);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x51, collect_rate & 0xff);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = mb86a20s_writereg(state, 0x50, 0xb0);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x51, 0x07);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = mb86a20s_writereg(state, 0x50, 0xb1);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x51, 0x07);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_writereg(state, 0x51, 0x00);\n\n\t\treturn rc;\n\t}\n\nreset_measurement:\n\t \n\trc = mb86a20s_writereg(state, 0x50, 0xb1);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\tval = rc;\n\trc = mb86a20s_writereg(state, 0x51, val | (1 << layer));\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_writereg(state, 0x51, val & ~(1 << layer));\n\n\treturn rc;\n}\n\nstruct linear_segments {\n\tunsigned x, y;\n};\n\n \n\nstatic const struct linear_segments cnr_to_db_table[] = {\n\t{ 19648,     0},\n\t{ 18187,  1000},\n\t{ 16534,  2000},\n\t{ 14823,  3000},\n\t{ 13161,  4000},\n\t{ 11622,  5000},\n\t{ 10279,  6000},\n\t{  9089,  7000},\n\t{  8042,  8000},\n\t{  7137,  9000},\n\t{  6342, 10000},\n\t{  5641, 11000},\n\t{  5030, 12000},\n\t{  4474, 13000},\n\t{  3988, 14000},\n\t{  3556, 15000},\n\t{  3180, 16000},\n\t{  2841, 17000},\n\t{  2541, 18000},\n\t{  2276, 19000},\n\t{  2038, 20000},\n\t{  1800, 21000},\n\t{  1625, 22000},\n\t{  1462, 23000},\n\t{  1324, 24000},\n\t{  1175, 25000},\n\t{  1063, 26000},\n\t{   980, 27000},\n\t{   907, 28000},\n\t{   840, 29000},\n\t{   788, 30000},\n};\n\nstatic const struct linear_segments cnr_64qam_table[] = {\n\t{ 3922688,     0},\n\t{ 3920384,  1000},\n\t{ 3902720,  2000},\n\t{ 3894784,  3000},\n\t{ 3882496,  4000},\n\t{ 3872768,  5000},\n\t{ 3858944,  6000},\n\t{ 3851520,  7000},\n\t{ 3838976,  8000},\n\t{ 3829248,  9000},\n\t{ 3818240, 10000},\n\t{ 3806976, 11000},\n\t{ 3791872, 12000},\n\t{ 3767040, 13000},\n\t{ 3720960, 14000},\n\t{ 3637504, 15000},\n\t{ 3498496, 16000},\n\t{ 3296000, 17000},\n\t{ 3031040, 18000},\n\t{ 2715392, 19000},\n\t{ 2362624, 20000},\n\t{ 1963264, 21000},\n\t{ 1649664, 22000},\n\t{ 1366784, 23000},\n\t{ 1120768, 24000},\n\t{  890880, 25000},\n\t{  723456, 26000},\n\t{  612096, 27000},\n\t{  518912, 28000},\n\t{  448256, 29000},\n\t{  388864, 30000},\n};\n\nstatic const struct linear_segments cnr_16qam_table[] = {\n\t{ 5314816,     0},\n\t{ 5219072,  1000},\n\t{ 5118720,  2000},\n\t{ 4998912,  3000},\n\t{ 4875520,  4000},\n\t{ 4736000,  5000},\n\t{ 4604160,  6000},\n\t{ 4458752,  7000},\n\t{ 4300288,  8000},\n\t{ 4092928,  9000},\n\t{ 3836160, 10000},\n\t{ 3521024, 11000},\n\t{ 3155968, 12000},\n\t{ 2756864, 13000},\n\t{ 2347008, 14000},\n\t{ 1955072, 15000},\n\t{ 1593600, 16000},\n\t{ 1297920, 17000},\n\t{ 1043968, 18000},\n\t{  839680, 19000},\n\t{  672256, 20000},\n\t{  523008, 21000},\n\t{  424704, 22000},\n\t{  345088, 23000},\n\t{  280064, 24000},\n\t{  221440, 25000},\n\t{  179712, 26000},\n\t{  151040, 27000},\n\t{  128512, 28000},\n\t{  110080, 29000},\n\t{   95744, 30000},\n};\n\nstatic const struct linear_segments cnr_qpsk_table[] = {\n\t{ 2834176,     0},\n\t{ 2683648,  1000},\n\t{ 2536960,  2000},\n\t{ 2391808,  3000},\n\t{ 2133248,  4000},\n\t{ 1906176,  5000},\n\t{ 1666560,  6000},\n\t{ 1422080,  7000},\n\t{ 1189632,  8000},\n\t{  976384,  9000},\n\t{  790272, 10000},\n\t{  633344, 11000},\n\t{  505600, 12000},\n\t{  402944, 13000},\n\t{  320768, 14000},\n\t{  255488, 15000},\n\t{  204032, 16000},\n\t{  163072, 17000},\n\t{  130304, 18000},\n\t{  105216, 19000},\n\t{   83456, 20000},\n\t{   65024, 21000},\n\t{   52480, 22000},\n\t{   42752, 23000},\n\t{   34560, 24000},\n\t{   27136, 25000},\n\t{   22016, 26000},\n\t{   18432, 27000},\n\t{   15616, 28000},\n\t{   13312, 29000},\n\t{   11520, 30000},\n};\n\nstatic u32 interpolate_value(u32 value, const struct linear_segments *segments,\n\t\t\t     unsigned len)\n{\n\tu64 tmp64;\n\tu32 dx, dy;\n\tint i, ret;\n\n\tif (value >= segments[0].x)\n\t\treturn segments[0].y;\n\tif (value < segments[len-1].x)\n\t\treturn segments[len-1].y;\n\n\tfor (i = 1; i < len - 1; i++) {\n\t\t \n\t\tif (value == segments[i].x)\n\t\t\treturn segments[i].y;\n\t\tif (value > segments[i].x)\n\t\t\tbreak;\n\t}\n\n\t \n\tdy = segments[i].y - segments[i - 1].y;\n\tdx = segments[i - 1].x - segments[i].x;\n\ttmp64 = value - segments[i].x;\n\ttmp64 *= dy;\n\tdo_div(tmp64, dx);\n\tret = segments[i].y - tmp64;\n\n\treturn ret;\n}\n\nstatic int mb86a20s_get_main_CNR(struct dvb_frontend *fe)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 cnr_linear, cnr;\n\tint rc, val;\n\n\t \n\trc = mb86a20s_readreg(state, 0x45);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (!(rc & 0x40)) {\n\t\tdev_dbg(&state->i2c->dev, \"%s: CNR is not available yet.\\n\",\n\t\t\t __func__);\n\t\treturn -EBUSY;\n\t}\n\tval = rc;\n\n\trc = mb86a20s_readreg(state, 0x46);\n\tif (rc < 0)\n\t\treturn rc;\n\tcnr_linear = rc << 8;\n\n\trc = mb86a20s_readreg(state, 0x46);\n\tif (rc < 0)\n\t\treturn rc;\n\tcnr_linear |= rc;\n\n\tcnr = interpolate_value(cnr_linear,\n\t\t\t\tcnr_to_db_table, ARRAY_SIZE(cnr_to_db_table));\n\n\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\tc->cnr.stat[0].svalue = cnr;\n\n\tdev_dbg(&state->i2c->dev, \"%s: CNR is %d.%03d dB (%d)\\n\",\n\t\t__func__, cnr / 1000, cnr % 1000, cnr_linear);\n\n\t \n\trc = mb86a20s_writereg(state, 0x45, val | 0x10);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_writereg(state, 0x45, val & 0x6f);\n\n\treturn rc;\n}\n\nstatic int mb86a20s_get_blk_error_layer_CNR(struct dvb_frontend *fe)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 mer, cnr;\n\tint rc, val, layer;\n\tconst struct linear_segments *segs;\n\tunsigned segs_len;\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\t \n\trc = mb86a20s_writereg(state, 0x50, 0x5b);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (!(rc & 0x01)) {\n\t\tdev_dbg(&state->i2c->dev,\n\t\t\t\"%s: MER measures aren't available yet.\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tfor (layer = 0; layer < NUM_LAYERS; layer++) {\n\t\tif (!(c->isdbt_layer_enabled & (1 << layer))) {\n\t\t\tc->cnr.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = mb86a20s_writereg(state, 0x50, 0x52 + layer * 3);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_readreg(state, 0x51);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tmer = rc << 16;\n\t\trc = mb86a20s_writereg(state, 0x50, 0x53 + layer * 3);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_readreg(state, 0x51);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tmer |= rc << 8;\n\t\trc = mb86a20s_writereg(state, 0x50, 0x54 + layer * 3);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = mb86a20s_readreg(state, 0x51);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tmer |= rc;\n\n\t\tswitch (c->layer[layer].modulation) {\n\t\tcase DQPSK:\n\t\tcase QPSK:\n\t\t\tsegs = cnr_qpsk_table;\n\t\t\tsegs_len = ARRAY_SIZE(cnr_qpsk_table);\n\t\t\tbreak;\n\t\tcase QAM_16:\n\t\t\tsegs = cnr_16qam_table;\n\t\t\tsegs_len = ARRAY_SIZE(cnr_16qam_table);\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase QAM_64:\n\t\t\tsegs = cnr_64qam_table;\n\t\t\tsegs_len = ARRAY_SIZE(cnr_64qam_table);\n\t\t\tbreak;\n\t\t}\n\t\tcnr = interpolate_value(mer, segs, segs_len);\n\n\t\tc->cnr.stat[1 + layer].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[1 + layer].svalue = cnr;\n\n\t\tdev_dbg(&state->i2c->dev,\n\t\t\t\"%s: CNR for layer %c is %d.%03d dB (MER = %d).\\n\",\n\t\t\t__func__, 'A' + layer, cnr / 1000, cnr % 1000, mer);\n\n\t}\n\n\t \n\t \n\trc = mb86a20s_writereg(state, 0x50, 0x50);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x51);\n\tif (rc < 0)\n\t\treturn rc;\n\tval = rc;\n\n\trc = mb86a20s_writereg(state, 0x51, val | 0x01);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_writereg(state, 0x51, val & 0x06);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic void mb86a20s_stats_not_ready(struct dvb_frontend *fe)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint layer;\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\t \n\n\t \n\tc->strength.len = 1;\n\n\t \n\tc->cnr.len = NUM_LAYERS + 1;\n\tc->pre_bit_error.len = NUM_LAYERS + 1;\n\tc->pre_bit_count.len = NUM_LAYERS + 1;\n\tc->post_bit_error.len = NUM_LAYERS + 1;\n\tc->post_bit_count.len = NUM_LAYERS + 1;\n\tc->block_error.len = NUM_LAYERS + 1;\n\tc->block_count.len = NUM_LAYERS + 1;\n\n\t \n\tc->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\tc->strength.stat[0].uvalue = 0;\n\n\t \n\tfor (layer = 0; layer < NUM_LAYERS + 1; layer++) {\n\t\tc->cnr.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->pre_bit_error.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->pre_bit_count.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_error.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_error.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_count.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n}\n\nstatic int mb86a20s_get_stats(struct dvb_frontend *fe, int status_nr)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint rc = 0, layer;\n\tu32 bit_error = 0, bit_count = 0;\n\tu32 t_pre_bit_error = 0, t_pre_bit_count = 0;\n\tu32 t_post_bit_error = 0, t_post_bit_count = 0;\n\tu32 block_error = 0, block_count = 0;\n\tu32 t_block_error = 0, t_block_count = 0;\n\tint pre_ber_layers = 0, post_ber_layers = 0;\n\tint per_layers = 0;\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\tmb86a20s_get_main_CNR(fe);\n\n\t \n\tmb86a20s_get_blk_error_layer_CNR(fe);\n\n\t \n\tif (status_nr < 9)\n\t\treturn 0;\n\n\tfor (layer = 0; layer < NUM_LAYERS; layer++) {\n\t\tif (c->isdbt_layer_enabled & (1 << layer)) {\n\t\t\t \n\t\t\trc = mb86a20s_get_pre_ber(fe, layer,\n\t\t\t\t\t\t  &bit_error, &bit_count);\n\t\t\tif (rc >= 0) {\n\t\t\t\tc->pre_bit_error.stat[1 + layer].scale = FE_SCALE_COUNTER;\n\t\t\t\tc->pre_bit_error.stat[1 + layer].uvalue += bit_error;\n\t\t\t\tc->pre_bit_count.stat[1 + layer].scale = FE_SCALE_COUNTER;\n\t\t\t\tc->pre_bit_count.stat[1 + layer].uvalue += bit_count;\n\t\t\t} else if (rc != -EBUSY) {\n\t\t\t\t \n\t\t\t\tc->pre_bit_error.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t\t\tc->pre_bit_count.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t\t\tdev_err(&state->i2c->dev,\n\t\t\t\t\t\"%s: Can't get BER for layer %c (error %d).\\n\",\n\t\t\t\t\t__func__, 'A' + layer, rc);\n\t\t\t}\n\t\t\tif (c->block_error.stat[1 + layer].scale != FE_SCALE_NOT_AVAILABLE)\n\t\t\t\tpre_ber_layers++;\n\n\t\t\t \n\t\t\trc = mb86a20s_get_post_ber(fe, layer,\n\t\t\t\t\t\t   &bit_error, &bit_count);\n\t\t\tif (rc >= 0) {\n\t\t\t\tc->post_bit_error.stat[1 + layer].scale = FE_SCALE_COUNTER;\n\t\t\t\tc->post_bit_error.stat[1 + layer].uvalue += bit_error;\n\t\t\t\tc->post_bit_count.stat[1 + layer].scale = FE_SCALE_COUNTER;\n\t\t\t\tc->post_bit_count.stat[1 + layer].uvalue += bit_count;\n\t\t\t} else if (rc != -EBUSY) {\n\t\t\t\t \n\t\t\t\tc->post_bit_error.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t\t\tc->post_bit_count.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t\t\tdev_err(&state->i2c->dev,\n\t\t\t\t\t\"%s: Can't get BER for layer %c (error %d).\\n\",\n\t\t\t\t\t__func__, 'A' + layer, rc);\n\t\t\t}\n\t\t\tif (c->block_error.stat[1 + layer].scale != FE_SCALE_NOT_AVAILABLE)\n\t\t\t\tpost_ber_layers++;\n\n\t\t\t \n\t\t\trc = mb86a20s_get_blk_error(fe, layer,\n\t\t\t\t\t\t&block_error,\n\t\t\t\t\t\t&block_count);\n\t\t\tif (rc >= 0) {\n\t\t\t\tc->block_error.stat[1 + layer].scale = FE_SCALE_COUNTER;\n\t\t\t\tc->block_error.stat[1 + layer].uvalue += block_error;\n\t\t\t\tc->block_count.stat[1 + layer].scale = FE_SCALE_COUNTER;\n\t\t\t\tc->block_count.stat[1 + layer].uvalue += block_count;\n\t\t\t} else if (rc != -EBUSY) {\n\t\t\t\t \n\t\t\t\tc->block_error.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t\t\tc->block_count.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t\t\tdev_err(&state->i2c->dev,\n\t\t\t\t\t\"%s: Can't get PER for layer %c (error %d).\\n\",\n\t\t\t\t\t__func__, 'A' + layer, rc);\n\n\t\t\t}\n\t\t\tif (c->block_error.stat[1 + layer].scale != FE_SCALE_NOT_AVAILABLE)\n\t\t\t\tper_layers++;\n\n\t\t\t \n\t\t\tt_pre_bit_error += c->pre_bit_error.stat[1 + layer].uvalue;\n\t\t\tt_pre_bit_count += c->pre_bit_count.stat[1 + layer].uvalue;\n\n\t\t\t \n\t\t\tt_post_bit_error += c->post_bit_error.stat[1 + layer].uvalue;\n\t\t\tt_post_bit_count += c->post_bit_count.stat[1 + layer].uvalue;\n\n\t\t\t \n\t\t\tt_block_error += c->block_error.stat[1 + layer].uvalue;\n\t\t\tt_block_count += c->block_count.stat[1 + layer].uvalue;\n\t\t}\n\t}\n\n\t \n\tif (pre_ber_layers) {\n\t\t \n\t\tc->pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->pre_bit_error.stat[0].uvalue = t_pre_bit_error;\n\t\tc->pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->pre_bit_count.stat[0].uvalue = t_pre_bit_count;\n\t} else {\n\t\tc->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t}\n\n\t \n\tif (post_ber_layers) {\n\t\t \n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[0].uvalue = t_post_bit_error;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[0].uvalue = t_post_bit_count;\n\t} else {\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t}\n\n\tif (per_layers) {\n\t\t \n\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_error.stat[0].uvalue = t_block_error;\n\t\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_count.stat[0].uvalue = t_block_count;\n\t} else {\n\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t}\n\n\treturn rc;\n}\n\n \n\nstatic int mb86a20s_initfe(struct dvb_frontend *fe)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tu64 pll;\n\tu32 fclk;\n\tint rc;\n\tu8  regD5 = 1, reg71, reg09 = 0x3a;\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\t \n\trc = mb86a20s_writeregdata(state, mb86a20s_init1);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tif (!state->inversion)\n\t\treg09 |= 0x04;\n\trc = mb86a20s_writereg(state, 0x09, reg09);\n\tif (rc < 0)\n\t\tgoto err;\n\tif (!state->bw)\n\t\treg71 = 1;\n\telse\n\t\treg71 = 0;\n\trc = mb86a20s_writereg(state, 0x39, reg71);\n\tif (rc < 0)\n\t\tgoto err;\n\trc = mb86a20s_writereg(state, 0x71, state->bw);\n\tif (rc < 0)\n\t\tgoto err;\n\tif (state->subchannel) {\n\t\trc = mb86a20s_writereg(state, 0x44, state->subchannel);\n\t\tif (rc < 0)\n\t\t\tgoto err;\n\t}\n\n\tfclk = state->config->fclk;\n\tif (!fclk)\n\t\tfclk = 32571428;\n\n\t \n\tif (fe->ops.tuner_ops.get_if_frequency)\n\t\tfe->ops.tuner_ops.get_if_frequency(fe, &state->if_freq);\n\n\tif (!state->if_freq)\n\t\tstate->if_freq = 3300000;\n\n\tpll = (((u64)1) << 34) * state->if_freq;\n\tdo_div(pll, 63 * fclk);\n\tpll = (1 << 25) - pll;\n\trc = mb86a20s_writereg(state, 0x28, 0x2a);\n\tif (rc < 0)\n\t\tgoto err;\n\trc = mb86a20s_writereg(state, 0x29, (pll >> 16) & 0xff);\n\tif (rc < 0)\n\t\tgoto err;\n\trc = mb86a20s_writereg(state, 0x2a, (pll >> 8) & 0xff);\n\tif (rc < 0)\n\t\tgoto err;\n\trc = mb86a20s_writereg(state, 0x2b, pll & 0xff);\n\tif (rc < 0)\n\t\tgoto err;\n\tdev_dbg(&state->i2c->dev, \"%s: fclk=%d, IF=%d, clock reg=0x%06llx\\n\",\n\t\t__func__, fclk, state->if_freq, (long long)pll);\n\n\t \n\tpll = state->if_freq * 1677721600L;\n\tdo_div(pll, 1628571429L);\n\trc = mb86a20s_writereg(state, 0x28, 0x20);\n\tif (rc < 0)\n\t\tgoto err;\n\trc = mb86a20s_writereg(state, 0x29, (pll >> 16) & 0xff);\n\tif (rc < 0)\n\t\tgoto err;\n\trc = mb86a20s_writereg(state, 0x2a, (pll >> 8) & 0xff);\n\tif (rc < 0)\n\t\tgoto err;\n\trc = mb86a20s_writereg(state, 0x2b, pll & 0xff);\n\tif (rc < 0)\n\t\tgoto err;\n\tdev_dbg(&state->i2c->dev, \"%s: IF=%d, IF reg=0x%06llx\\n\",\n\t\t__func__, state->if_freq, (long long)pll);\n\n\tif (!state->config->is_serial)\n\t\tregD5 &= ~1;\n\n\trc = mb86a20s_writereg(state, 0x50, 0xd5);\n\tif (rc < 0)\n\t\tgoto err;\n\trc = mb86a20s_writereg(state, 0x51, regD5);\n\tif (rc < 0)\n\t\tgoto err;\n\n\trc = mb86a20s_writeregdata(state, mb86a20s_init2);\n\tif (rc < 0)\n\t\tgoto err;\n\n\nerr:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tif (rc < 0) {\n\t\tstate->need_init = true;\n\t\tdev_info(&state->i2c->dev,\n\t\t\t \"mb86a20s: Init failed. Will try again later\\n\");\n\t} else {\n\t\tstate->need_init = false;\n\t\tdev_dbg(&state->i2c->dev, \"Initialization succeeded.\\n\");\n\t}\n\treturn rc;\n}\n\nstatic int mb86a20s_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint rc, if_freq;\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\tif (!c->isdbt_layer_enabled)\n\t\tc->isdbt_layer_enabled = 7;\n\n\tif (c->isdbt_layer_enabled == 1)\n\t\tstate->bw = MB86A20S_1SEG;\n\telse if (c->isdbt_partial_reception)\n\t\tstate->bw = MB86A20S_13SEG_PARTIAL;\n\telse\n\t\tstate->bw = MB86A20S_13SEG;\n\n\tif (c->inversion == INVERSION_ON)\n\t\tstate->inversion = true;\n\telse\n\t\tstate->inversion = false;\n\n\tif (!c->isdbt_sb_mode) {\n\t\tstate->subchannel = 0;\n\t} else {\n\t\tif (c->isdbt_sb_subchannel >= ARRAY_SIZE(mb86a20s_subchannel))\n\t\t\tc->isdbt_sb_subchannel = 0;\n\n\t\tstate->subchannel = mb86a20s_subchannel[c->isdbt_sb_subchannel];\n\t}\n\n\t \n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tfe->ops.tuner_ops.set_params(fe);\n\n\tif (fe->ops.tuner_ops.get_if_frequency)\n\t\tfe->ops.tuner_ops.get_if_frequency(fe, &if_freq);\n\n\t \n\tmb86a20s_initfe(fe);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\trc = mb86a20s_writeregdata(state, mb86a20s_reset_reception);\n\tmb86a20s_reset_counters(fe);\n\tmb86a20s_stats_not_ready(fe);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\treturn rc;\n}\n\nstatic int mb86a20s_read_status_and_stats(struct dvb_frontend *fe,\n\t\t\t\t\t  enum fe_status *status)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tint rc, status_nr;\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\t \n\tstatus_nr = mb86a20s_read_status(fe, status);\n\tif (status_nr < 7) {\n\t\tmb86a20s_stats_not_ready(fe);\n\t\tmb86a20s_reset_frontend_cache(fe);\n\t}\n\tif (status_nr < 0) {\n\t\tdev_err(&state->i2c->dev,\n\t\t\t\"%s: Can't read frontend lock status\\n\", __func__);\n\t\trc = status_nr;\n\t\tgoto error;\n\t}\n\n\t \n\trc = mb86a20s_read_signal_strength(fe);\n\tif (rc < 0) {\n\t\tdev_err(&state->i2c->dev,\n\t\t\t\"%s: Can't reset VBER registers.\\n\", __func__);\n\t\tmb86a20s_stats_not_ready(fe);\n\t\tmb86a20s_reset_frontend_cache(fe);\n\n\t\trc = 0;\t\t \n\t\tgoto error;\n\t}\n\n\tif (status_nr >= 7) {\n\t\t \n\t\trc = mb86a20s_get_frontend(fe);\n\t\tif (rc < 0) {\n\t\t\tdev_err(&state->i2c->dev,\n\t\t\t\t\"%s: Can't get FE TMCC data.\\n\", __func__);\n\t\t\trc = 0;\t\t \n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\trc = mb86a20s_get_stats(fe, status_nr);\n\t\tif (rc < 0 && rc != -EBUSY) {\n\t\t\tdev_err(&state->i2c->dev,\n\t\t\t\t\"%s: Can't get FE statistics.\\n\", __func__);\n\t\t\trc = 0;\n\t\t\tgoto error;\n\t\t}\n\t\trc = 0;\t \n\t}\n\tgoto ok;\n\nerror:\n\tmb86a20s_stats_not_ready(fe);\n\nok:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\treturn rc;\n}\n\nstatic int mb86a20s_read_signal_strength_from_cache(struct dvb_frontend *fe,\n\t\t\t\t\t\t    u16 *strength)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\n\t*strength = c->strength.stat[0].uvalue;\n\n\treturn 0;\n}\n\nstatic int mb86a20s_tune(struct dvb_frontend *fe,\n\t\t\tbool re_tune,\n\t\t\tunsigned int mode_flags,\n\t\t\tunsigned int *delay,\n\t\t\tenum fe_status *status)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tint rc = 0;\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\tif (re_tune)\n\t\trc = mb86a20s_set_frontend(fe);\n\n\tif (!(mode_flags & FE_TUNE_MODE_ONESHOT))\n\t\tmb86a20s_read_status_and_stats(fe, status);\n\n\treturn rc;\n}\n\nstatic void mb86a20s_release(struct dvb_frontend *fe)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\tkfree(state);\n}\n\nstatic enum dvbfe_algo mb86a20s_get_frontend_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic const struct dvb_frontend_ops mb86a20s_ops;\n\nstruct dvb_frontend *mb86a20s_attach(const struct mb86a20s_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct mb86a20s_state *state;\n\tu8\trev;\n\n\tdev_dbg(&i2c->dev, \"%s called.\\n\", __func__);\n\n\t \n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t \n\tmemcpy(&state->frontend.ops, &mb86a20s_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\t \n\trev = mb86a20s_readreg(state, 0);\n\tif (rev != 0x13) {\n\t\tkfree(state);\n\t\tdev_dbg(&i2c->dev,\n\t\t\t\"Frontend revision %d is unknown - aborting.\\n\",\n\t\t       rev);\n\t\treturn NULL;\n\t}\n\n\tdev_info(&i2c->dev, \"Detected a Fujitsu mb86a20s frontend\\n\");\n\treturn &state->frontend;\n}\nEXPORT_SYMBOL_GPL(mb86a20s_attach);\n\nstatic const struct dvb_frontend_ops mb86a20s_ops = {\n\t.delsys = { SYS_ISDBT },\n\t \n\t.info = {\n\t\t.name = \"Fujitsu mb86A20s\",\n\t\t.caps = FE_CAN_RECOVER  |\n\t\t\tFE_CAN_FEC_1_2  | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6  | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK     | FE_CAN_QAM_16  | FE_CAN_QAM_64 |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO    | FE_CAN_HIERARCHY_AUTO,\n\t\t \n\t\t.frequency_min_hz =  45 * MHz,\n\t\t.frequency_max_hz = 864 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t},\n\n\t.release = mb86a20s_release,\n\n\t.init = mb86a20s_initfe,\n\t.set_frontend = mb86a20s_set_frontend,\n\t.read_status = mb86a20s_read_status_and_stats,\n\t.read_signal_strength = mb86a20s_read_signal_strength_from_cache,\n\t.tune = mb86a20s_tune,\n\t.get_frontend_algo = mb86a20s_get_frontend_algo,\n};\n\nMODULE_DESCRIPTION(\"DVB Frontend module for Fujitsu mb86A20s hardware\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}