{
  "module_name": "drxk_hard.c",
  "hash_id": "41d5cfd2f087a753bf3f9d7d6ef574d610cc6398d7ecb77a0d9acd789c41bef4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/drxk_hard.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/hardirq.h>\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"drxk.h\"\n#include \"drxk_hard.h\"\n#include <linux/int_log.h>\n\nstatic int power_down_dvbt(struct drxk_state *state, bool set_power_mode);\nstatic int power_down_qam(struct drxk_state *state);\nstatic int set_dvbt_standard(struct drxk_state *state,\n\t\t\t   enum operation_mode o_mode);\nstatic int set_qam_standard(struct drxk_state *state,\n\t\t\t  enum operation_mode o_mode);\nstatic int set_qam(struct drxk_state *state, u16 intermediate_freqk_hz,\n\t\t  s32 tuner_freq_offset);\nstatic int set_dvbt_standard(struct drxk_state *state,\n\t\t\t   enum operation_mode o_mode);\nstatic int dvbt_start(struct drxk_state *state);\nstatic int set_dvbt(struct drxk_state *state, u16 intermediate_freqk_hz,\n\t\t   s32 tuner_freq_offset);\nstatic int get_qam_lock_status(struct drxk_state *state, u32 *p_lock_status);\nstatic int get_dvbt_lock_status(struct drxk_state *state, u32 *p_lock_status);\nstatic int switch_antenna_to_qam(struct drxk_state *state);\nstatic int switch_antenna_to_dvbt(struct drxk_state *state);\n\nstatic bool is_dvbt(struct drxk_state *state)\n{\n\treturn state->m_operation_mode == OM_DVBT;\n}\n\nstatic bool is_qam(struct drxk_state *state)\n{\n\treturn state->m_operation_mode == OM_QAM_ITU_A ||\n\t    state->m_operation_mode == OM_QAM_ITU_B ||\n\t    state->m_operation_mode == OM_QAM_ITU_C;\n}\n\n#define NOA1ROM 0\n\n#define DRXDAP_FASI_SHORT_FORMAT(addr) (((addr) & 0xFC30FF80) == 0)\n#define DRXDAP_FASI_LONG_FORMAT(addr)  (((addr) & 0xFC30FF80) != 0)\n\n#define DEFAULT_MER_83  165\n#define DEFAULT_MER_93  250\n\n#ifndef DRXK_MPEG_SERIAL_OUTPUT_PIN_DRIVE_STRENGTH\n#define DRXK_MPEG_SERIAL_OUTPUT_PIN_DRIVE_STRENGTH (0x02)\n#endif\n\n#ifndef DRXK_MPEG_PARALLEL_OUTPUT_PIN_DRIVE_STRENGTH\n#define DRXK_MPEG_PARALLEL_OUTPUT_PIN_DRIVE_STRENGTH (0x03)\n#endif\n\n#define DEFAULT_DRXK_MPEG_LOCK_TIMEOUT 700\n#define DEFAULT_DRXK_DEMOD_LOCK_TIMEOUT 500\n\n#ifndef DRXK_KI_RAGC_ATV\n#define DRXK_KI_RAGC_ATV   4\n#endif\n#ifndef DRXK_KI_IAGC_ATV\n#define DRXK_KI_IAGC_ATV   6\n#endif\n#ifndef DRXK_KI_DAGC_ATV\n#define DRXK_KI_DAGC_ATV   7\n#endif\n\n#ifndef DRXK_KI_RAGC_QAM\n#define DRXK_KI_RAGC_QAM   3\n#endif\n#ifndef DRXK_KI_IAGC_QAM\n#define DRXK_KI_IAGC_QAM   4\n#endif\n#ifndef DRXK_KI_DAGC_QAM\n#define DRXK_KI_DAGC_QAM   7\n#endif\n#ifndef DRXK_KI_RAGC_DVBT\n#define DRXK_KI_RAGC_DVBT  (IsA1WithPatchCode(state) ? 3 : 2)\n#endif\n#ifndef DRXK_KI_IAGC_DVBT\n#define DRXK_KI_IAGC_DVBT  (IsA1WithPatchCode(state) ? 4 : 2)\n#endif\n#ifndef DRXK_KI_DAGC_DVBT\n#define DRXK_KI_DAGC_DVBT  (IsA1WithPatchCode(state) ? 10 : 7)\n#endif\n\n#ifndef DRXK_AGC_DAC_OFFSET\n#define DRXK_AGC_DAC_OFFSET (0x800)\n#endif\n\n#ifndef DRXK_BANDWIDTH_8MHZ_IN_HZ\n#define DRXK_BANDWIDTH_8MHZ_IN_HZ  (0x8B8249L)\n#endif\n\n#ifndef DRXK_BANDWIDTH_7MHZ_IN_HZ\n#define DRXK_BANDWIDTH_7MHZ_IN_HZ  (0x7A1200L)\n#endif\n\n#ifndef DRXK_BANDWIDTH_6MHZ_IN_HZ\n#define DRXK_BANDWIDTH_6MHZ_IN_HZ  (0x68A1B6L)\n#endif\n\n#ifndef DRXK_QAM_SYMBOLRATE_MAX\n#define DRXK_QAM_SYMBOLRATE_MAX         (7233000)\n#endif\n\n#define DRXK_BL_ROM_OFFSET_TAPS_DVBT    56\n#define DRXK_BL_ROM_OFFSET_TAPS_ITU_A   64\n#define DRXK_BL_ROM_OFFSET_TAPS_ITU_C   0x5FE0\n#define DRXK_BL_ROM_OFFSET_TAPS_BG      24\n#define DRXK_BL_ROM_OFFSET_TAPS_DKILLP  32\n#define DRXK_BL_ROM_OFFSET_TAPS_NTSC    40\n#define DRXK_BL_ROM_OFFSET_TAPS_FM      48\n#define DRXK_BL_ROM_OFFSET_UCODE        0\n\n#define DRXK_BLC_TIMEOUT                100\n\n#define DRXK_BLCC_NR_ELEMENTS_TAPS      2\n#define DRXK_BLCC_NR_ELEMENTS_UCODE     6\n\n#define DRXK_BLDC_NR_ELEMENTS_TAPS      28\n\n#ifndef DRXK_OFDM_NE_NOTCH_WIDTH\n#define DRXK_OFDM_NE_NOTCH_WIDTH             (4)\n#endif\n\n#define DRXK_QAM_SL_SIG_POWER_QAM16       (40960)\n#define DRXK_QAM_SL_SIG_POWER_QAM32       (20480)\n#define DRXK_QAM_SL_SIG_POWER_QAM64       (43008)\n#define DRXK_QAM_SL_SIG_POWER_QAM128      (20992)\n#define DRXK_QAM_SL_SIG_POWER_QAM256      (43520)\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debug messages\");\n\n#define dprintk(level, fmt, arg...) do {\t\t\t\t\\\nif (debug >= level)\t\t\t\t\t\t\t\\\n\tprintk(KERN_DEBUG KBUILD_MODNAME \": %s \" fmt, __func__, ##arg);\t\\\n} while (0)\n\nstatic inline u32 Frac28a(u32 a, u32 c)\n{\n\tint i = 0;\n\tu32 Q1 = 0;\n\tu32 R0 = 0;\n\n\tR0 = (a % c) << 4;\t \n\tQ1 = a / c;\t\t \n\n\t \n\tfor (i = 0; i < 7; i++) {\n\t\tQ1 = (Q1 << 4) | (R0 / c);\n\t\tR0 = (R0 % c) << 4;\n\t}\n\t \n\tif ((R0 >> 3) >= c)\n\t\tQ1++;\n\n\treturn Q1;\n}\n\nstatic inline u32 log10times100(u32 value)\n{\n\treturn (100L * intlog10(value)) >> 24;\n}\n\n \n \n \n\nstatic int drxk_i2c_lock(struct drxk_state *state)\n{\n\ti2c_lock_bus(state->i2c, I2C_LOCK_SEGMENT);\n\tstate->drxk_i2c_exclusive_lock = true;\n\n\treturn 0;\n}\n\nstatic void drxk_i2c_unlock(struct drxk_state *state)\n{\n\tif (!state->drxk_i2c_exclusive_lock)\n\t\treturn;\n\n\ti2c_unlock_bus(state->i2c, I2C_LOCK_SEGMENT);\n\tstate->drxk_i2c_exclusive_lock = false;\n}\n\nstatic int drxk_i2c_transfer(struct drxk_state *state, struct i2c_msg *msgs,\n\t\t\t     unsigned len)\n{\n\tif (state->drxk_i2c_exclusive_lock)\n\t\treturn __i2c_transfer(state->i2c, msgs, len);\n\telse\n\t\treturn i2c_transfer(state->i2c, msgs, len);\n}\n\nstatic int i2c_read1(struct drxk_state *state, u8 adr, u8 *val)\n{\n\tstruct i2c_msg msgs[1] = { {.addr = adr, .flags = I2C_M_RD,\n\t\t\t\t    .buf = val, .len = 1}\n\t};\n\n\treturn drxk_i2c_transfer(state, msgs, 1);\n}\n\nstatic int i2c_write(struct drxk_state *state, u8 adr, u8 *data, int len)\n{\n\tint status;\n\tstruct i2c_msg msg = {\n\t    .addr = adr, .flags = 0, .buf = data, .len = len };\n\n\tdprintk(3, \": %*ph\\n\", len, data);\n\n\tstatus = drxk_i2c_transfer(state, &msg, 1);\n\tif (status >= 0 && status != 1)\n\t\tstatus = -EIO;\n\n\tif (status < 0)\n\t\tpr_err(\"i2c write error at addr 0x%02x\\n\", adr);\n\n\treturn status;\n}\n\nstatic int i2c_read(struct drxk_state *state,\n\t\t    u8 adr, u8 *msg, int len, u8 *answ, int alen)\n{\n\tint status;\n\tstruct i2c_msg msgs[2] = {\n\t\t{.addr = adr, .flags = 0,\n\t\t\t\t    .buf = msg, .len = len},\n\t\t{.addr = adr, .flags = I2C_M_RD,\n\t\t .buf = answ, .len = alen}\n\t};\n\n\tstatus = drxk_i2c_transfer(state, msgs, 2);\n\tif (status != 2) {\n\t\tif (debug > 2)\n\t\t\tpr_cont(\": ERROR!\\n\");\n\t\tif (status >= 0)\n\t\t\tstatus = -EIO;\n\n\t\tpr_err(\"i2c read error at addr 0x%02x\\n\", adr);\n\t\treturn status;\n\t}\n\tdprintk(3, \": read from %*ph, value = %*ph\\n\", len, msg, alen, answ);\n\treturn 0;\n}\n\nstatic int read16_flags(struct drxk_state *state, u32 reg, u16 *data, u8 flags)\n{\n\tint status;\n\tu8 adr = state->demod_address, mm1[4], mm2[2], len;\n\n\tif (state->single_master)\n\t\tflags |= 0xC0;\n\n\tif (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {\n\t\tmm1[0] = (((reg << 1) & 0xFF) | 0x01);\n\t\tmm1[1] = ((reg >> 16) & 0xFF);\n\t\tmm1[2] = ((reg >> 24) & 0xFF) | flags;\n\t\tmm1[3] = ((reg >> 7) & 0xFF);\n\t\tlen = 4;\n\t} else {\n\t\tmm1[0] = ((reg << 1) & 0xFF);\n\t\tmm1[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));\n\t\tlen = 2;\n\t}\n\tdprintk(2, \"(0x%08x, 0x%02x)\\n\", reg, flags);\n\tstatus = i2c_read(state, adr, mm1, len, mm2, 2);\n\tif (status < 0)\n\t\treturn status;\n\tif (data)\n\t\t*data = mm2[0] | (mm2[1] << 8);\n\n\treturn 0;\n}\n\nstatic int read16(struct drxk_state *state, u32 reg, u16 *data)\n{\n\treturn read16_flags(state, reg, data, 0);\n}\n\nstatic int read32_flags(struct drxk_state *state, u32 reg, u32 *data, u8 flags)\n{\n\tint status;\n\tu8 adr = state->demod_address, mm1[4], mm2[4], len;\n\n\tif (state->single_master)\n\t\tflags |= 0xC0;\n\n\tif (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {\n\t\tmm1[0] = (((reg << 1) & 0xFF) | 0x01);\n\t\tmm1[1] = ((reg >> 16) & 0xFF);\n\t\tmm1[2] = ((reg >> 24) & 0xFF) | flags;\n\t\tmm1[3] = ((reg >> 7) & 0xFF);\n\t\tlen = 4;\n\t} else {\n\t\tmm1[0] = ((reg << 1) & 0xFF);\n\t\tmm1[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));\n\t\tlen = 2;\n\t}\n\tdprintk(2, \"(0x%08x, 0x%02x)\\n\", reg, flags);\n\tstatus = i2c_read(state, adr, mm1, len, mm2, 4);\n\tif (status < 0)\n\t\treturn status;\n\tif (data)\n\t\t*data = mm2[0] | (mm2[1] << 8) |\n\t\t    (mm2[2] << 16) | (mm2[3] << 24);\n\n\treturn 0;\n}\n\nstatic int read32(struct drxk_state *state, u32 reg, u32 *data)\n{\n\treturn read32_flags(state, reg, data, 0);\n}\n\nstatic int write16_flags(struct drxk_state *state, u32 reg, u16 data, u8 flags)\n{\n\tu8 adr = state->demod_address, mm[6], len;\n\n\tif (state->single_master)\n\t\tflags |= 0xC0;\n\tif (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {\n\t\tmm[0] = (((reg << 1) & 0xFF) | 0x01);\n\t\tmm[1] = ((reg >> 16) & 0xFF);\n\t\tmm[2] = ((reg >> 24) & 0xFF) | flags;\n\t\tmm[3] = ((reg >> 7) & 0xFF);\n\t\tlen = 4;\n\t} else {\n\t\tmm[0] = ((reg << 1) & 0xFF);\n\t\tmm[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));\n\t\tlen = 2;\n\t}\n\tmm[len] = data & 0xff;\n\tmm[len + 1] = (data >> 8) & 0xff;\n\n\tdprintk(2, \"(0x%08x, 0x%04x, 0x%02x)\\n\", reg, data, flags);\n\treturn i2c_write(state, adr, mm, len + 2);\n}\n\nstatic int write16(struct drxk_state *state, u32 reg, u16 data)\n{\n\treturn write16_flags(state, reg, data, 0);\n}\n\nstatic int write32_flags(struct drxk_state *state, u32 reg, u32 data, u8 flags)\n{\n\tu8 adr = state->demod_address, mm[8], len;\n\n\tif (state->single_master)\n\t\tflags |= 0xC0;\n\tif (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {\n\t\tmm[0] = (((reg << 1) & 0xFF) | 0x01);\n\t\tmm[1] = ((reg >> 16) & 0xFF);\n\t\tmm[2] = ((reg >> 24) & 0xFF) | flags;\n\t\tmm[3] = ((reg >> 7) & 0xFF);\n\t\tlen = 4;\n\t} else {\n\t\tmm[0] = ((reg << 1) & 0xFF);\n\t\tmm[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));\n\t\tlen = 2;\n\t}\n\tmm[len] = data & 0xff;\n\tmm[len + 1] = (data >> 8) & 0xff;\n\tmm[len + 2] = (data >> 16) & 0xff;\n\tmm[len + 3] = (data >> 24) & 0xff;\n\tdprintk(2, \"(0x%08x, 0x%08x, 0x%02x)\\n\", reg, data, flags);\n\n\treturn i2c_write(state, adr, mm, len + 4);\n}\n\nstatic int write32(struct drxk_state *state, u32 reg, u32 data)\n{\n\treturn write32_flags(state, reg, data, 0);\n}\n\nstatic int write_block(struct drxk_state *state, u32 address,\n\t\t      const int block_size, const u8 p_block[])\n{\n\tint status = 0, blk_size = block_size;\n\tu8 flags = 0;\n\n\tif (state->single_master)\n\t\tflags |= 0xC0;\n\n\twhile (blk_size > 0) {\n\t\tint chunk = blk_size > state->m_chunk_size ?\n\t\t    state->m_chunk_size : blk_size;\n\t\tu8 *adr_buf = &state->chunk[0];\n\t\tu32 adr_length = 0;\n\n\t\tif (DRXDAP_FASI_LONG_FORMAT(address) || (flags != 0)) {\n\t\t\tadr_buf[0] = (((address << 1) & 0xFF) | 0x01);\n\t\t\tadr_buf[1] = ((address >> 16) & 0xFF);\n\t\t\tadr_buf[2] = ((address >> 24) & 0xFF);\n\t\t\tadr_buf[3] = ((address >> 7) & 0xFF);\n\t\t\tadr_buf[2] |= flags;\n\t\t\tadr_length = 4;\n\t\t\tif (chunk == state->m_chunk_size)\n\t\t\t\tchunk -= 2;\n\t\t} else {\n\t\t\tadr_buf[0] = ((address << 1) & 0xFF);\n\t\t\tadr_buf[1] = (((address >> 16) & 0x0F) |\n\t\t\t\t     ((address >> 18) & 0xF0));\n\t\t\tadr_length = 2;\n\t\t}\n\t\tmemcpy(&state->chunk[adr_length], p_block, chunk);\n\t\tdprintk(2, \"(0x%08x, 0x%02x)\\n\", address, flags);\n\t\tif (p_block)\n\t\t\tdprintk(2, \"%*ph\\n\", chunk, p_block);\n\t\tstatus = i2c_write(state, state->demod_address,\n\t\t\t\t   &state->chunk[0], chunk + adr_length);\n\t\tif (status < 0) {\n\t\t\tpr_err(\"%s: i2c write error at addr 0x%02x\\n\",\n\t\t\t       __func__, address);\n\t\t\tbreak;\n\t\t}\n\t\tp_block += chunk;\n\t\taddress += (chunk >> 1);\n\t\tblk_size -= chunk;\n\t}\n\treturn status;\n}\n\n#ifndef DRXK_MAX_RETRIES_POWERUP\n#define DRXK_MAX_RETRIES_POWERUP 20\n#endif\n\nstatic int power_up_device(struct drxk_state *state)\n{\n\tint status;\n\tu8 data = 0;\n\tu16 retry_count = 0;\n\n\tdprintk(1, \"\\n\");\n\n\tstatus = i2c_read1(state, state->demod_address, &data);\n\tif (status < 0) {\n\t\tdo {\n\t\t\tdata = 0;\n\t\t\tstatus = i2c_write(state, state->demod_address,\n\t\t\t\t\t   &data, 1);\n\t\t\tusleep_range(10000, 11000);\n\t\t\tretry_count++;\n\t\t\tif (status < 0)\n\t\t\t\tcontinue;\n\t\t\tstatus = i2c_read1(state, state->demod_address,\n\t\t\t\t\t   &data);\n\t\t} while (status < 0 &&\n\t\t\t (retry_count < DRXK_MAX_RETRIES_POWERUP));\n\t\tif (status < 0 && retry_count >= DRXK_MAX_RETRIES_POWERUP)\n\t\t\tgoto error;\n\t}\n\n\t \n\tstatus = write16(state, SIO_CC_PWD_MODE__A, SIO_CC_PWD_MODE_LEVEL_NONE);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\tstatus = write16(state, SIO_CC_PLL_LOCK__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstate->m_current_power_mode = DRX_POWER_UP;\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\n\nstatic int init_state(struct drxk_state *state)\n{\n\t \n\tu32 ul_vsb_if_agc_mode = DRXK_AGC_CTRL_AUTO;\n\tu32 ul_vsb_if_agc_output_level = 0;\n\tu32 ul_vsb_if_agc_min_level = 0;\n\tu32 ul_vsb_if_agc_max_level = 0x7FFF;\n\tu32 ul_vsb_if_agc_speed = 3;\n\n\tu32 ul_vsb_rf_agc_mode = DRXK_AGC_CTRL_AUTO;\n\tu32 ul_vsb_rf_agc_output_level = 0;\n\tu32 ul_vsb_rf_agc_min_level = 0;\n\tu32 ul_vsb_rf_agc_max_level = 0x7FFF;\n\tu32 ul_vsb_rf_agc_speed = 3;\n\tu32 ul_vsb_rf_agc_top = 9500;\n\tu32 ul_vsb_rf_agc_cut_off_current = 4000;\n\n\tu32 ul_atv_if_agc_mode = DRXK_AGC_CTRL_AUTO;\n\tu32 ul_atv_if_agc_output_level = 0;\n\tu32 ul_atv_if_agc_min_level = 0;\n\tu32 ul_atv_if_agc_max_level = 0;\n\tu32 ul_atv_if_agc_speed = 3;\n\n\tu32 ul_atv_rf_agc_mode = DRXK_AGC_CTRL_OFF;\n\tu32 ul_atv_rf_agc_output_level = 0;\n\tu32 ul_atv_rf_agc_min_level = 0;\n\tu32 ul_atv_rf_agc_max_level = 0;\n\tu32 ul_atv_rf_agc_top = 9500;\n\tu32 ul_atv_rf_agc_cut_off_current = 4000;\n\tu32 ul_atv_rf_agc_speed = 3;\n\n\tu32 ulQual83 = DEFAULT_MER_83;\n\tu32 ulQual93 = DEFAULT_MER_93;\n\n\tu32 ul_mpeg_lock_time_out = DEFAULT_DRXK_MPEG_LOCK_TIMEOUT;\n\tu32 ul_demod_lock_time_out = DEFAULT_DRXK_DEMOD_LOCK_TIMEOUT;\n\n\t \n\t \n\t \n\tu32 ul_gpio_cfg = 0x0113;\n\tu32 ul_invert_ts_clock = 0;\n\tu32 ul_ts_data_strength = DRXK_MPEG_SERIAL_OUTPUT_PIN_DRIVE_STRENGTH;\n\tu32 ul_dvbt_bitrate = 50000000;\n\tu32 ul_dvbc_bitrate = DRXK_QAM_SYMBOLRATE_MAX * 8;\n\n\tu32 ul_insert_rs_byte = 0;\n\n\tu32 ul_rf_mirror = 1;\n\tu32 ul_power_down = 0;\n\n\tdprintk(1, \"\\n\");\n\n\tstate->m_has_lna = false;\n\tstate->m_has_dvbt = false;\n\tstate->m_has_dvbc = false;\n\tstate->m_has_atv = false;\n\tstate->m_has_oob = false;\n\tstate->m_has_audio = false;\n\n\tif (!state->m_chunk_size)\n\t\tstate->m_chunk_size = 124;\n\n\tstate->m_osc_clock_freq = 0;\n\tstate->m_smart_ant_inverted = false;\n\tstate->m_b_p_down_open_bridge = false;\n\n\t \n\tstate->m_sys_clock_freq = 151875;\n\t \n\t \n\tstate->m_hi_cfg_timing_div = ((state->m_sys_clock_freq / 1000) *\n\t\t\t\t   HI_I2C_DELAY) / 1000;\n\t \n\tif (state->m_hi_cfg_timing_div > SIO_HI_RA_RAM_PAR_2_CFG_DIV__M)\n\t\tstate->m_hi_cfg_timing_div = SIO_HI_RA_RAM_PAR_2_CFG_DIV__M;\n\tstate->m_hi_cfg_wake_up_key = (state->demod_address << 1);\n\t \n\tstate->m_hi_cfg_ctrl = SIO_HI_RA_RAM_PAR_5_CFG_SLV0_SLAVE;\n\n\tstate->m_b_power_down = (ul_power_down != 0);\n\n\tstate->m_drxk_a3_patch_code = false;\n\n\t \n\t \n\tstate->m_vsb_if_agc_cfg.ctrl_mode = ul_vsb_if_agc_mode;\n\tstate->m_vsb_if_agc_cfg.output_level = ul_vsb_if_agc_output_level;\n\tstate->m_vsb_if_agc_cfg.min_output_level = ul_vsb_if_agc_min_level;\n\tstate->m_vsb_if_agc_cfg.max_output_level = ul_vsb_if_agc_max_level;\n\tstate->m_vsb_if_agc_cfg.speed = ul_vsb_if_agc_speed;\n\tstate->m_vsb_pga_cfg = 140;\n\n\t \n\tstate->m_vsb_rf_agc_cfg.ctrl_mode = ul_vsb_rf_agc_mode;\n\tstate->m_vsb_rf_agc_cfg.output_level = ul_vsb_rf_agc_output_level;\n\tstate->m_vsb_rf_agc_cfg.min_output_level = ul_vsb_rf_agc_min_level;\n\tstate->m_vsb_rf_agc_cfg.max_output_level = ul_vsb_rf_agc_max_level;\n\tstate->m_vsb_rf_agc_cfg.speed = ul_vsb_rf_agc_speed;\n\tstate->m_vsb_rf_agc_cfg.top = ul_vsb_rf_agc_top;\n\tstate->m_vsb_rf_agc_cfg.cut_off_current = ul_vsb_rf_agc_cut_off_current;\n\tstate->m_vsb_pre_saw_cfg.reference = 0x07;\n\tstate->m_vsb_pre_saw_cfg.use_pre_saw = true;\n\n\tstate->m_Quality83percent = DEFAULT_MER_83;\n\tstate->m_Quality93percent = DEFAULT_MER_93;\n\tif (ulQual93 <= 500 && ulQual83 < ulQual93) {\n\t\tstate->m_Quality83percent = ulQual83;\n\t\tstate->m_Quality93percent = ulQual93;\n\t}\n\n\t \n\tstate->m_atv_if_agc_cfg.ctrl_mode = ul_atv_if_agc_mode;\n\tstate->m_atv_if_agc_cfg.output_level = ul_atv_if_agc_output_level;\n\tstate->m_atv_if_agc_cfg.min_output_level = ul_atv_if_agc_min_level;\n\tstate->m_atv_if_agc_cfg.max_output_level = ul_atv_if_agc_max_level;\n\tstate->m_atv_if_agc_cfg.speed = ul_atv_if_agc_speed;\n\n\t \n\tstate->m_atv_rf_agc_cfg.ctrl_mode = ul_atv_rf_agc_mode;\n\tstate->m_atv_rf_agc_cfg.output_level = ul_atv_rf_agc_output_level;\n\tstate->m_atv_rf_agc_cfg.min_output_level = ul_atv_rf_agc_min_level;\n\tstate->m_atv_rf_agc_cfg.max_output_level = ul_atv_rf_agc_max_level;\n\tstate->m_atv_rf_agc_cfg.speed = ul_atv_rf_agc_speed;\n\tstate->m_atv_rf_agc_cfg.top = ul_atv_rf_agc_top;\n\tstate->m_atv_rf_agc_cfg.cut_off_current = ul_atv_rf_agc_cut_off_current;\n\tstate->m_atv_pre_saw_cfg.reference = 0x04;\n\tstate->m_atv_pre_saw_cfg.use_pre_saw = true;\n\n\n\t \n\tstate->m_dvbt_rf_agc_cfg.ctrl_mode = DRXK_AGC_CTRL_OFF;\n\tstate->m_dvbt_rf_agc_cfg.output_level = 0;\n\tstate->m_dvbt_rf_agc_cfg.min_output_level = 0;\n\tstate->m_dvbt_rf_agc_cfg.max_output_level = 0xFFFF;\n\tstate->m_dvbt_rf_agc_cfg.top = 0x2100;\n\tstate->m_dvbt_rf_agc_cfg.cut_off_current = 4000;\n\tstate->m_dvbt_rf_agc_cfg.speed = 1;\n\n\n\t \n\tstate->m_dvbt_if_agc_cfg.ctrl_mode = DRXK_AGC_CTRL_AUTO;\n\tstate->m_dvbt_if_agc_cfg.output_level = 0;\n\tstate->m_dvbt_if_agc_cfg.min_output_level = 0;\n\tstate->m_dvbt_if_agc_cfg.max_output_level = 9000;\n\tstate->m_dvbt_if_agc_cfg.top = 13424;\n\tstate->m_dvbt_if_agc_cfg.cut_off_current = 0;\n\tstate->m_dvbt_if_agc_cfg.speed = 3;\n\tstate->m_dvbt_if_agc_cfg.fast_clip_ctrl_delay = 30;\n\tstate->m_dvbt_if_agc_cfg.ingain_tgt_max = 30000;\n\t \n\n\tstate->m_dvbt_pre_saw_cfg.reference = 4;\n\tstate->m_dvbt_pre_saw_cfg.use_pre_saw = false;\n\n\t \n\tstate->m_qam_rf_agc_cfg.ctrl_mode = DRXK_AGC_CTRL_OFF;\n\tstate->m_qam_rf_agc_cfg.output_level = 0;\n\tstate->m_qam_rf_agc_cfg.min_output_level = 6023;\n\tstate->m_qam_rf_agc_cfg.max_output_level = 27000;\n\tstate->m_qam_rf_agc_cfg.top = 0x2380;\n\tstate->m_qam_rf_agc_cfg.cut_off_current = 4000;\n\tstate->m_qam_rf_agc_cfg.speed = 3;\n\n\t \n\tstate->m_qam_if_agc_cfg.ctrl_mode = DRXK_AGC_CTRL_AUTO;\n\tstate->m_qam_if_agc_cfg.output_level = 0;\n\tstate->m_qam_if_agc_cfg.min_output_level = 0;\n\tstate->m_qam_if_agc_cfg.max_output_level = 9000;\n\tstate->m_qam_if_agc_cfg.top = 0x0511;\n\tstate->m_qam_if_agc_cfg.cut_off_current = 0;\n\tstate->m_qam_if_agc_cfg.speed = 3;\n\tstate->m_qam_if_agc_cfg.ingain_tgt_max = 5119;\n\tstate->m_qam_if_agc_cfg.fast_clip_ctrl_delay = 50;\n\n\tstate->m_qam_pga_cfg = 140;\n\tstate->m_qam_pre_saw_cfg.reference = 4;\n\tstate->m_qam_pre_saw_cfg.use_pre_saw = false;\n\n\tstate->m_operation_mode = OM_NONE;\n\tstate->m_drxk_state = DRXK_UNINITIALIZED;\n\n\t \n\tstate->m_enable_mpeg_output = true;\t \n\tstate->m_insert_rs_byte = false;\t \n\tstate->m_invert_data = false;\t \n\tstate->m_invert_err = false;\t \n\tstate->m_invert_str = false;\t \n\tstate->m_invert_val = false;\t \n\tstate->m_invert_clk = (ul_invert_ts_clock != 0);\t \n\n\t \n\n\tstate->m_dvbt_bitrate = ul_dvbt_bitrate;\n\tstate->m_dvbc_bitrate = ul_dvbc_bitrate;\n\n\tstate->m_ts_data_strength = (ul_ts_data_strength & 0x07);\n\n\t \n\tstate->m_mpeg_ts_static_bitrate = 19392658;\n\tstate->m_disable_te_ihandling = false;\n\n\tif (ul_insert_rs_byte)\n\t\tstate->m_insert_rs_byte = true;\n\n\tstate->m_mpeg_lock_time_out = DEFAULT_DRXK_MPEG_LOCK_TIMEOUT;\n\tif (ul_mpeg_lock_time_out < 10000)\n\t\tstate->m_mpeg_lock_time_out = ul_mpeg_lock_time_out;\n\tstate->m_demod_lock_time_out = DEFAULT_DRXK_DEMOD_LOCK_TIMEOUT;\n\tif (ul_demod_lock_time_out < 10000)\n\t\tstate->m_demod_lock_time_out = ul_demod_lock_time_out;\n\n\t \n\tstate->m_constellation = DRX_CONSTELLATION_AUTO;\n\tstate->m_qam_interleave_mode = DRXK_QAM_I12_J17;\n\tstate->m_fec_rs_plen = 204 * 8;\t \n\tstate->m_fec_rs_prescale = 1;\n\n\tstate->m_sqi_speed = DRXK_DVBT_SQI_SPEED_MEDIUM;\n\tstate->m_agcfast_clip_ctrl_delay = 0;\n\n\tstate->m_gpio_cfg = ul_gpio_cfg;\n\n\tstate->m_b_power_down = false;\n\tstate->m_current_power_mode = DRX_POWER_DOWN;\n\n\tstate->m_rfmirror = (ul_rf_mirror == 0);\n\tstate->m_if_agc_pol = false;\n\treturn 0;\n}\n\nstatic int drxx_open(struct drxk_state *state)\n{\n\tint status = 0;\n\tu32 jtag = 0;\n\tu16 bid = 0;\n\tu16 key = 0;\n\n\tdprintk(1, \"\\n\");\n\t \n\tstatus = write16(state, SCU_RAM_GPIO__A,\n\t\t\t SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\tstatus = read16(state, SIO_TOP_COMM_KEY__A, &key);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_TOP_COMM_KEY__A, SIO_TOP_COMM_KEY_KEY);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = read32(state, SIO_TOP_JTAGID_LO__A, &jtag);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = read16(state, SIO_PDR_UIO_IN_HI__A, &bid);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_TOP_COMM_KEY__A, key);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int get_device_capabilities(struct drxk_state *state)\n{\n\tu16 sio_pdr_ohw_cfg = 0;\n\tu32 sio_top_jtagid_lo = 0;\n\tint status;\n\tconst char *spin = \"\";\n\n\tdprintk(1, \"\\n\");\n\n\t \n\t \n\tstatus = write16(state, SCU_RAM_GPIO__A,\n\t\t\t SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_TOP_COMM_KEY__A, SIO_TOP_COMM_KEY_KEY);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = read16(state, SIO_PDR_OHW_CFG__A, &sio_pdr_ohw_cfg);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_TOP_COMM_KEY__A, 0x0000);\n\tif (status < 0)\n\t\tgoto error;\n\n\tswitch ((sio_pdr_ohw_cfg & SIO_PDR_OHW_CFG_FREF_SEL__M)) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tstate->m_osc_clock_freq = 27000;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tstate->m_osc_clock_freq = 20250;\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tstate->m_osc_clock_freq = 20250;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Clock Frequency is unknown\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tstatus = read32(state, SIO_TOP_JTAGID_LO__A, &sio_top_jtagid_lo);\n\tif (status < 0)\n\t\tgoto error;\n\n\tpr_info(\"status = 0x%08x\\n\", sio_top_jtagid_lo);\n\n\t \n\tswitch ((sio_top_jtagid_lo >> 29) & 0xF) {\n\tcase 0:\n\t\tstate->m_device_spin = DRXK_SPIN_A1;\n\t\tspin = \"A1\";\n\t\tbreak;\n\tcase 2:\n\t\tstate->m_device_spin = DRXK_SPIN_A2;\n\t\tspin = \"A2\";\n\t\tbreak;\n\tcase 3:\n\t\tstate->m_device_spin = DRXK_SPIN_A3;\n\t\tspin = \"A3\";\n\t\tbreak;\n\tdefault:\n\t\tstate->m_device_spin = DRXK_SPIN_UNKNOWN;\n\t\tstatus = -EINVAL;\n\t\tpr_err(\"Spin %d unknown\\n\", (sio_top_jtagid_lo >> 29) & 0xF);\n\t\tgoto error2;\n\t}\n\tswitch ((sio_top_jtagid_lo >> 12) & 0xFF) {\n\tcase 0x13:\n\t\t \n\t\tstate->m_has_lna = false;\n\t\tstate->m_has_oob = false;\n\t\tstate->m_has_atv = false;\n\t\tstate->m_has_audio = false;\n\t\tstate->m_has_dvbt = true;\n\t\tstate->m_has_dvbc = true;\n\t\tstate->m_has_sawsw = true;\n\t\tstate->m_has_gpio2 = false;\n\t\tstate->m_has_gpio1 = false;\n\t\tstate->m_has_irqn = false;\n\t\tbreak;\n\tcase 0x15:\n\t\t \n\t\tstate->m_has_lna = false;\n\t\tstate->m_has_oob = false;\n\t\tstate->m_has_atv = true;\n\t\tstate->m_has_audio = false;\n\t\tstate->m_has_dvbt = true;\n\t\tstate->m_has_dvbc = false;\n\t\tstate->m_has_sawsw = true;\n\t\tstate->m_has_gpio2 = true;\n\t\tstate->m_has_gpio1 = true;\n\t\tstate->m_has_irqn = false;\n\t\tbreak;\n\tcase 0x16:\n\t\t \n\t\tstate->m_has_lna = false;\n\t\tstate->m_has_oob = false;\n\t\tstate->m_has_atv = true;\n\t\tstate->m_has_audio = false;\n\t\tstate->m_has_dvbt = true;\n\t\tstate->m_has_dvbc = false;\n\t\tstate->m_has_sawsw = true;\n\t\tstate->m_has_gpio2 = true;\n\t\tstate->m_has_gpio1 = true;\n\t\tstate->m_has_irqn = false;\n\t\tbreak;\n\tcase 0x18:\n\t\t \n\t\tstate->m_has_lna = false;\n\t\tstate->m_has_oob = false;\n\t\tstate->m_has_atv = true;\n\t\tstate->m_has_audio = true;\n\t\tstate->m_has_dvbt = true;\n\t\tstate->m_has_dvbc = false;\n\t\tstate->m_has_sawsw = true;\n\t\tstate->m_has_gpio2 = true;\n\t\tstate->m_has_gpio1 = true;\n\t\tstate->m_has_irqn = false;\n\t\tbreak;\n\tcase 0x21:\n\t\t \n\t\tstate->m_has_lna = false;\n\t\tstate->m_has_oob = false;\n\t\tstate->m_has_atv = true;\n\t\tstate->m_has_audio = true;\n\t\tstate->m_has_dvbt = true;\n\t\tstate->m_has_dvbc = true;\n\t\tstate->m_has_sawsw = true;\n\t\tstate->m_has_gpio2 = true;\n\t\tstate->m_has_gpio1 = true;\n\t\tstate->m_has_irqn = false;\n\t\tbreak;\n\tcase 0x23:\n\t\t \n\t\tstate->m_has_lna = false;\n\t\tstate->m_has_oob = false;\n\t\tstate->m_has_atv = true;\n\t\tstate->m_has_audio = true;\n\t\tstate->m_has_dvbt = true;\n\t\tstate->m_has_dvbc = true;\n\t\tstate->m_has_sawsw = true;\n\t\tstate->m_has_gpio2 = true;\n\t\tstate->m_has_gpio1 = true;\n\t\tstate->m_has_irqn = false;\n\t\tbreak;\n\tcase 0x25:\n\t\t \n\t\tstate->m_has_lna = false;\n\t\tstate->m_has_oob = false;\n\t\tstate->m_has_atv = true;\n\t\tstate->m_has_audio = true;\n\t\tstate->m_has_dvbt = true;\n\t\tstate->m_has_dvbc = true;\n\t\tstate->m_has_sawsw = true;\n\t\tstate->m_has_gpio2 = true;\n\t\tstate->m_has_gpio1 = true;\n\t\tstate->m_has_irqn = false;\n\t\tbreak;\n\tcase 0x26:\n\t\t \n\t\tstate->m_has_lna = false;\n\t\tstate->m_has_oob = false;\n\t\tstate->m_has_atv = true;\n\t\tstate->m_has_audio = false;\n\t\tstate->m_has_dvbt = true;\n\t\tstate->m_has_dvbc = true;\n\t\tstate->m_has_sawsw = true;\n\t\tstate->m_has_gpio2 = true;\n\t\tstate->m_has_gpio1 = true;\n\t\tstate->m_has_irqn = false;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"DeviceID 0x%02x not supported\\n\",\n\t\t\t((sio_top_jtagid_lo >> 12) & 0xFF));\n\t\tstatus = -EINVAL;\n\t\tgoto error2;\n\t}\n\n\tpr_info(\"detected a drx-39%02xk, spin %s, xtal %d.%03d MHz\\n\",\n\t       ((sio_top_jtagid_lo >> 12) & 0xFF), spin,\n\t       state->m_osc_clock_freq / 1000,\n\t       state->m_osc_clock_freq % 1000);\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\nerror2:\n\treturn status;\n}\n\nstatic int hi_command(struct drxk_state *state, u16 cmd, u16 *p_result)\n{\n\tint status;\n\tbool powerdown_cmd;\n\n\tdprintk(1, \"\\n\");\n\n\t \n\tstatus = write16(state, SIO_HI_RA_RAM_CMD__A, cmd);\n\tif (status < 0)\n\t\tgoto error;\n\tif (cmd == SIO_HI_RA_RAM_CMD_RESET)\n\t\tusleep_range(1000, 2000);\n\n\tpowerdown_cmd =\n\t    (bool) ((cmd == SIO_HI_RA_RAM_CMD_CONFIG) &&\n\t\t    ((state->m_hi_cfg_ctrl) &\n\t\t     SIO_HI_RA_RAM_PAR_5_CFG_SLEEP__M) ==\n\t\t    SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ);\n\tif (!powerdown_cmd) {\n\t\t \n\t\tu32 retry_count = 0;\n\t\tu16 wait_cmd;\n\n\t\tdo {\n\t\t\tusleep_range(1000, 2000);\n\t\t\tretry_count += 1;\n\t\t\tstatus = read16(state, SIO_HI_RA_RAM_CMD__A,\n\t\t\t\t\t  &wait_cmd);\n\t\t} while ((status < 0 || wait_cmd) && (retry_count < DRXK_MAX_RETRIES));\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = read16(state, SIO_HI_RA_RAM_RES__A, p_result);\n\t}\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\nstatic int hi_cfg_command(struct drxk_state *state)\n{\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\n\tmutex_lock(&state->mutex);\n\n\tstatus = write16(state, SIO_HI_RA_RAM_PAR_6__A,\n\t\t\t state->m_hi_cfg_timeout);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_HI_RA_RAM_PAR_5__A,\n\t\t\t state->m_hi_cfg_ctrl);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_HI_RA_RAM_PAR_4__A,\n\t\t\t state->m_hi_cfg_wake_up_key);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_HI_RA_RAM_PAR_3__A,\n\t\t\t state->m_hi_cfg_bridge_delay);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_HI_RA_RAM_PAR_2__A,\n\t\t\t state->m_hi_cfg_timing_div);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_HI_RA_RAM_PAR_1__A,\n\t\t\t SIO_HI_RA_RAM_PAR_1_PAR1_SEC_KEY);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = hi_command(state, SIO_HI_RA_RAM_CMD_CONFIG, NULL);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstate->m_hi_cfg_ctrl &= ~SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ;\nerror:\n\tmutex_unlock(&state->mutex);\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int init_hi(struct drxk_state *state)\n{\n\tdprintk(1, \"\\n\");\n\n\tstate->m_hi_cfg_wake_up_key = (state->demod_address << 1);\n\tstate->m_hi_cfg_timeout = 0x96FF;\n\t \n\tstate->m_hi_cfg_ctrl = SIO_HI_RA_RAM_PAR_5_CFG_SLV0_SLAVE;\n\n\treturn hi_cfg_command(state);\n}\n\nstatic int mpegts_configure_pins(struct drxk_state *state, bool mpeg_enable)\n{\n\tint status;\n\tu16 sio_pdr_mclk_cfg = 0;\n\tu16 sio_pdr_mdx_cfg = 0;\n\tu16 err_cfg = 0;\n\n\tdprintk(1, \": mpeg %s, %s mode\\n\",\n\t\tmpeg_enable ? \"enable\" : \"disable\",\n\t\tstate->m_enable_parallel ? \"parallel\" : \"serial\");\n\n\t \n\tstatus = write16(state, SCU_RAM_GPIO__A,\n\t\t\t SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SIO_TOP_COMM_KEY__A, SIO_TOP_COMM_KEY_KEY);\n\tif (status < 0)\n\t\tgoto error;\n\n\tif (!mpeg_enable) {\n\t\t \n\t\tstatus = write16(state, SIO_PDR_MSTRT_CFG__A, 0x0000);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MERR_CFG__A, 0x0000);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MCLK_CFG__A, 0x0000);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MVAL_CFG__A, 0x0000);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MD0_CFG__A, 0x0000);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MD1_CFG__A, 0x0000);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MD2_CFG__A, 0x0000);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MD3_CFG__A, 0x0000);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MD4_CFG__A, 0x0000);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MD5_CFG__A, 0x0000);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MD6_CFG__A, 0x0000);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MD7_CFG__A, 0x0000);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t} else {\n\t\t \n\t\tsio_pdr_mdx_cfg =\n\t\t\t((state->m_ts_data_strength <<\n\t\t\tSIO_PDR_MD0_CFG_DRIVE__B) | 0x0003);\n\t\tsio_pdr_mclk_cfg = ((state->m_ts_clockk_strength <<\n\t\t\t\t\tSIO_PDR_MCLK_CFG_DRIVE__B) |\n\t\t\t\t\t0x0003);\n\n\t\tstatus = write16(state, SIO_PDR_MSTRT_CFG__A, sio_pdr_mdx_cfg);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tif (state->enable_merr_cfg)\n\t\t\terr_cfg = sio_pdr_mdx_cfg;\n\n\t\tstatus = write16(state, SIO_PDR_MERR_CFG__A, err_cfg);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MVAL_CFG__A, err_cfg);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tif (state->m_enable_parallel) {\n\t\t\t \n\t\t\tstatus = write16(state, SIO_PDR_MD1_CFG__A,\n\t\t\t\t\t sio_pdr_mdx_cfg);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = write16(state, SIO_PDR_MD2_CFG__A,\n\t\t\t\t\t sio_pdr_mdx_cfg);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = write16(state, SIO_PDR_MD3_CFG__A,\n\t\t\t\t\t sio_pdr_mdx_cfg);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = write16(state, SIO_PDR_MD4_CFG__A,\n\t\t\t\t\t sio_pdr_mdx_cfg);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = write16(state, SIO_PDR_MD5_CFG__A,\n\t\t\t\t\t sio_pdr_mdx_cfg);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = write16(state, SIO_PDR_MD6_CFG__A,\n\t\t\t\t\t sio_pdr_mdx_cfg);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = write16(state, SIO_PDR_MD7_CFG__A,\n\t\t\t\t\t sio_pdr_mdx_cfg);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tsio_pdr_mdx_cfg = ((state->m_ts_data_strength <<\n\t\t\t\t\t\tSIO_PDR_MD0_CFG_DRIVE__B)\n\t\t\t\t\t| 0x0003);\n\t\t\t \n\t\t\tstatus = write16(state, SIO_PDR_MD1_CFG__A, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = write16(state, SIO_PDR_MD2_CFG__A, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = write16(state, SIO_PDR_MD3_CFG__A, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = write16(state, SIO_PDR_MD4_CFG__A, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = write16(state, SIO_PDR_MD5_CFG__A, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = write16(state, SIO_PDR_MD6_CFG__A, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = write16(state, SIO_PDR_MD7_CFG__A, 0x0000);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t\tstatus = write16(state, SIO_PDR_MCLK_CFG__A, sio_pdr_mclk_cfg);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_PDR_MD0_CFG__A, sio_pdr_mdx_cfg);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t}\n\t \n\tstatus = write16(state, SIO_PDR_MON_CFG__A, 0x0000);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\tstatus = write16(state, SIO_TOP_COMM_KEY__A, 0x0000);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int mpegts_disable(struct drxk_state *state)\n{\n\tdprintk(1, \"\\n\");\n\n\treturn mpegts_configure_pins(state, false);\n}\n\nstatic int bl_chain_cmd(struct drxk_state *state,\n\t\t      u16 rom_offset, u16 nr_of_elements, u32 time_out)\n{\n\tu16 bl_status = 0;\n\tint status;\n\tunsigned long end;\n\n\tdprintk(1, \"\\n\");\n\tmutex_lock(&state->mutex);\n\tstatus = write16(state, SIO_BL_MODE__A, SIO_BL_MODE_CHAIN);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_BL_CHAIN_ADDR__A, rom_offset);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_BL_CHAIN_LEN__A, nr_of_elements);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_BL_ENABLE__A, SIO_BL_ENABLE_ON);\n\tif (status < 0)\n\t\tgoto error;\n\n\tend = jiffies + msecs_to_jiffies(time_out);\n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\tstatus = read16(state, SIO_BL_STATUS__A, &bl_status);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t} while ((bl_status == 0x1) &&\n\t\t\t((time_is_after_jiffies(end))));\n\n\tif (bl_status == 0x1) {\n\t\tpr_err(\"SIO not ready\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto error2;\n\t}\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\nerror2:\n\tmutex_unlock(&state->mutex);\n\treturn status;\n}\n\n\nstatic int download_microcode(struct drxk_state *state,\n\t\t\t     const u8 p_mc_image[], u32 length)\n{\n\tconst u8 *p_src = p_mc_image;\n\tu32 address;\n\tu16 n_blocks;\n\tu16 block_size;\n\tu32 offset = 0;\n\tu32 i;\n\tint status = 0;\n\n\tdprintk(1, \"\\n\");\n\n\t \n#if 0\n\t \n\tdrain = (p_src[0] << 8) | p_src[1];\n#endif\n\tp_src += sizeof(u16);\n\toffset += sizeof(u16);\n\tn_blocks = (p_src[0] << 8) | p_src[1];\n\tp_src += sizeof(u16);\n\toffset += sizeof(u16);\n\n\tfor (i = 0; i < n_blocks; i += 1) {\n\t\taddress = (p_src[0] << 24) | (p_src[1] << 16) |\n\t\t    (p_src[2] << 8) | p_src[3];\n\t\tp_src += sizeof(u32);\n\t\toffset += sizeof(u32);\n\n\t\tblock_size = ((p_src[0] << 8) | p_src[1]) * sizeof(u16);\n\t\tp_src += sizeof(u16);\n\t\toffset += sizeof(u16);\n\n#if 0\n\t\t \n\t\tflags = (p_src[0] << 8) | p_src[1];\n#endif\n\t\tp_src += sizeof(u16);\n\t\toffset += sizeof(u16);\n\n#if 0\n\t\t \n\t\tblock_crc = (p_src[0] << 8) | p_src[1];\n#endif\n\t\tp_src += sizeof(u16);\n\t\toffset += sizeof(u16);\n\n\t\tif (offset + block_size > length) {\n\t\t\tpr_err(\"Firmware is corrupted.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tstatus = write_block(state, address, block_size, p_src);\n\t\tif (status < 0) {\n\t\t\tpr_err(\"Error %d while loading firmware\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t\tp_src += block_size;\n\t\toffset += block_size;\n\t}\n\treturn status;\n}\n\nstatic int dvbt_enable_ofdm_token_ring(struct drxk_state *state, bool enable)\n{\n\tint status;\n\tu16 data = 0;\n\tu16 desired_ctrl = SIO_OFDM_SH_OFDM_RING_ENABLE_ON;\n\tu16 desired_status = SIO_OFDM_SH_OFDM_RING_STATUS_ENABLED;\n\tunsigned long end;\n\n\tdprintk(1, \"\\n\");\n\n\tif (!enable) {\n\t\tdesired_ctrl = SIO_OFDM_SH_OFDM_RING_ENABLE_OFF;\n\t\tdesired_status = SIO_OFDM_SH_OFDM_RING_STATUS_DOWN;\n\t}\n\n\tstatus = read16(state, SIO_OFDM_SH_OFDM_RING_STATUS__A, &data);\n\tif (status >= 0 && data == desired_status) {\n\t\t \n\t\treturn status;\n\t}\n\t \n\tstatus = write16(state, SIO_OFDM_SH_OFDM_RING_ENABLE__A, desired_ctrl);\n\n\tend = jiffies + msecs_to_jiffies(DRXK_OFDM_TR_SHUTDOWN_TIMEOUT);\n\tdo {\n\t\tstatus = read16(state, SIO_OFDM_SH_OFDM_RING_STATUS__A, &data);\n\t\tif ((status >= 0 && data == desired_status)\n\t\t    || time_is_after_jiffies(end))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t} while (1);\n\tif (data != desired_status) {\n\t\tpr_err(\"SIO not ready\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn status;\n}\n\nstatic int mpegts_stop(struct drxk_state *state)\n{\n\tint status = 0;\n\tu16 fec_oc_snc_mode = 0;\n\tu16 fec_oc_ipr_mode = 0;\n\n\tdprintk(1, \"\\n\");\n\n\t \n\tstatus = read16(state, FEC_OC_SNC_MODE__A, &fec_oc_snc_mode);\n\tif (status < 0)\n\t\tgoto error;\n\tfec_oc_snc_mode |= FEC_OC_SNC_MODE_SHUTDOWN__M;\n\tstatus = write16(state, FEC_OC_SNC_MODE__A, fec_oc_snc_mode);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = read16(state, FEC_OC_IPR_MODE__A, &fec_oc_ipr_mode);\n\tif (status < 0)\n\t\tgoto error;\n\tfec_oc_ipr_mode |= FEC_OC_IPR_MODE_MCLK_DIS_DAT_ABS__M;\n\tstatus = write16(state, FEC_OC_IPR_MODE__A, fec_oc_ipr_mode);\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\nstatic int scu_command(struct drxk_state *state,\n\t\t       u16 cmd, u8 parameter_len,\n\t\t       u16 *parameter, u8 result_len, u16 *result)\n{\n#if (SCU_RAM_PARAM_0__A - SCU_RAM_PARAM_15__A) != 15\n#error DRXK register mapping no longer compatible with this routine!\n#endif\n\tu16 cur_cmd = 0;\n\tint status = -EINVAL;\n\tunsigned long end;\n\tu8 buffer[34];\n\tint cnt = 0, ii;\n\tconst char *p;\n\tchar errname[30];\n\n\tdprintk(1, \"\\n\");\n\n\tif ((cmd == 0) || ((parameter_len > 0) && (parameter == NULL)) ||\n\t    ((result_len > 0) && (result == NULL))) {\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\t\treturn status;\n\t}\n\n\tmutex_lock(&state->mutex);\n\n\t \n\tif (parameter) {\n\t\tfor (ii = parameter_len - 1; ii >= 0; ii -= 1) {\n\t\t\tbuffer[cnt++] = (parameter[ii] & 0xFF);\n\t\t\tbuffer[cnt++] = ((parameter[ii] >> 8) & 0xFF);\n\t\t}\n\t}\n\tbuffer[cnt++] = (cmd & 0xFF);\n\tbuffer[cnt++] = ((cmd >> 8) & 0xFF);\n\n\twrite_block(state, SCU_RAM_PARAM_0__A -\n\t\t\t(parameter_len - 1), cnt, buffer);\n\t \n\tend = jiffies + msecs_to_jiffies(DRXK_MAX_WAITTIME);\n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\tstatus = read16(state, SCU_RAM_COMMAND__A, &cur_cmd);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t} while (!(cur_cmd == DRX_SCU_READY) && (time_is_after_jiffies(end)));\n\tif (cur_cmd != DRX_SCU_READY) {\n\t\tpr_err(\"SCU not ready\\n\");\n\t\tstatus = -EIO;\n\t\tgoto error2;\n\t}\n\t \n\tif ((result_len > 0) && (result != NULL)) {\n\t\ts16 err;\n\t\tint ii;\n\n\t\tfor (ii = result_len - 1; ii >= 0; ii -= 1) {\n\t\t\tstatus = read16(state, SCU_RAM_PARAM_0__A - ii,\n\t\t\t\t\t&result[ii]);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\terr = (s16)result[0];\n\t\tif (err >= 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tswitch (err) {\n\t\tcase SCU_RESULT_UNKCMD:\n\t\t\tp = \"SCU_RESULT_UNKCMD\";\n\t\t\tbreak;\n\t\tcase SCU_RESULT_UNKSTD:\n\t\t\tp = \"SCU_RESULT_UNKSTD\";\n\t\t\tbreak;\n\t\tcase SCU_RESULT_SIZE:\n\t\t\tp = \"SCU_RESULT_SIZE\";\n\t\t\tbreak;\n\t\tcase SCU_RESULT_INVPAR:\n\t\t\tp = \"SCU_RESULT_INVPAR\";\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tsprintf(errname, \"ERROR: %d\\n\", err);\n\t\t\tp = errname;\n\t\t}\n\t\tpr_err(\"%s while sending cmd 0x%04x with params:\", p, cmd);\n\t\tprint_hex_dump_bytes(\"drxk: \", DUMP_PREFIX_NONE, buffer, cnt);\n\t\tstatus = -EINVAL;\n\t\tgoto error2;\n\t}\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\nerror2:\n\tmutex_unlock(&state->mutex);\n\treturn status;\n}\n\nstatic int set_iqm_af(struct drxk_state *state, bool active)\n{\n\tu16 data = 0;\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\n\t \n\tstatus = read16(state, IQM_AF_STDBY__A, &data);\n\tif (status < 0)\n\t\tgoto error;\n\n\tif (!active) {\n\t\tdata |= (IQM_AF_STDBY_STDBY_ADC_STANDBY\n\t\t\t\t| IQM_AF_STDBY_STDBY_AMP_STANDBY\n\t\t\t\t| IQM_AF_STDBY_STDBY_PD_STANDBY\n\t\t\t\t| IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY\n\t\t\t\t| IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY);\n\t} else {\n\t\tdata &= ((~IQM_AF_STDBY_STDBY_ADC_STANDBY)\n\t\t\t\t& (~IQM_AF_STDBY_STDBY_AMP_STANDBY)\n\t\t\t\t& (~IQM_AF_STDBY_STDBY_PD_STANDBY)\n\t\t\t\t& (~IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY)\n\t\t\t\t& (~IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY)\n\t\t\t);\n\t}\n\tstatus = write16(state, IQM_AF_STDBY__A, data);\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int ctrl_power_mode(struct drxk_state *state, enum drx_power_mode *mode)\n{\n\tint status = 0;\n\tu16 sio_cc_pwd_mode = 0;\n\n\tdprintk(1, \"\\n\");\n\n\t \n\tif (mode == NULL)\n\t\treturn -EINVAL;\n\n\tswitch (*mode) {\n\tcase DRX_POWER_UP:\n\t\tsio_cc_pwd_mode = SIO_CC_PWD_MODE_LEVEL_NONE;\n\t\tbreak;\n\tcase DRXK_POWER_DOWN_OFDM:\n\t\tsio_cc_pwd_mode = SIO_CC_PWD_MODE_LEVEL_OFDM;\n\t\tbreak;\n\tcase DRXK_POWER_DOWN_CORE:\n\t\tsio_cc_pwd_mode = SIO_CC_PWD_MODE_LEVEL_CLOCK;\n\t\tbreak;\n\tcase DRXK_POWER_DOWN_PLL:\n\t\tsio_cc_pwd_mode = SIO_CC_PWD_MODE_LEVEL_PLL;\n\t\tbreak;\n\tcase DRX_POWER_DOWN:\n\t\tsio_cc_pwd_mode = SIO_CC_PWD_MODE_LEVEL_OSC;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (state->m_current_power_mode == *mode)\n\t\treturn 0;\n\n\t \n\tif (state->m_current_power_mode != DRX_POWER_UP) {\n\t\tstatus = power_up_device(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = dvbt_enable_ofdm_token_ring(state, true);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (*mode == DRX_POWER_UP) {\n\t\t \n\t} else {\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tswitch (state->m_operation_mode) {\n\t\tcase OM_DVBT:\n\t\t\tstatus = mpegts_stop(state);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = power_down_dvbt(state, false);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase OM_QAM_ITU_A:\n\t\tcase OM_QAM_ITU_C:\n\t\t\tstatus = mpegts_stop(state);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstatus = power_down_qam(state);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tstatus = dvbt_enable_ofdm_token_ring(state, false);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_CC_PWD_MODE__A, sio_cc_pwd_mode);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tif (*mode != DRXK_POWER_DOWN_OFDM) {\n\t\t\tstate->m_hi_cfg_ctrl |=\n\t\t\t\tSIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ;\n\t\t\tstatus = hi_cfg_command(state);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tstate->m_current_power_mode = *mode;\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\nstatic int power_down_dvbt(struct drxk_state *state, bool set_power_mode)\n{\n\tenum drx_power_mode power_mode = DRXK_POWER_DOWN_OFDM;\n\tu16 cmd_result = 0;\n\tu16 data = 0;\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\n\tstatus = read16(state, SCU_COMM_EXEC__A, &data);\n\tif (status < 0)\n\t\tgoto error;\n\tif (data == SCU_COMM_EXEC_ACTIVE) {\n\t\t \n\t\tstatus = scu_command(state,\n\t\t\t\t     SCU_RAM_COMMAND_STANDARD_OFDM\n\t\t\t\t     | SCU_RAM_COMMAND_CMD_DEMOD_STOP,\n\t\t\t\t     0, NULL, 1, &cmd_result);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\t \n\t\tstatus = scu_command(state,\n\t\t\t\t     SCU_RAM_COMMAND_STANDARD_OFDM\n\t\t\t\t     | SCU_RAM_COMMAND_CMD_DEMOD_RESET,\n\t\t\t\t     0, NULL, 1, &cmd_result);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t}\n\n\t \n\tstatus = write16(state, OFDM_SC_COMM_EXEC__A, OFDM_SC_COMM_EXEC_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, OFDM_LC_COMM_EXEC__A, OFDM_LC_COMM_EXEC_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = set_iqm_af(state, false);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tif (set_power_mode) {\n\t\tstatus = ctrl_power_mode(state, &power_mode);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t}\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int setoperation_mode(struct drxk_state *state,\n\t\t\t    enum operation_mode o_mode)\n{\n\tint status = 0;\n\n\tdprintk(1, \"\\n\");\n\t \n\n\t \n\tstatus = write16(state, SCU_RAM_GPIO__A,\n\t\t\t SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tif (state->m_operation_mode == o_mode)\n\t\treturn 0;\n\n\tswitch (state->m_operation_mode) {\n\t\t \n\tcase OM_NONE:\n\t\tbreak;\n\tcase OM_DVBT:\n\t\tstatus = mpegts_stop(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = power_down_dvbt(state, true);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstate->m_operation_mode = OM_NONE;\n\t\tbreak;\n\tcase OM_QAM_ITU_A:\n\tcase OM_QAM_ITU_C:\n\t\tstatus = mpegts_stop(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = power_down_qam(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstate->m_operation_mode = OM_NONE;\n\t\tbreak;\n\tcase OM_QAM_ITU_B:\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tswitch (o_mode) {\n\tcase OM_DVBT:\n\t\tdprintk(1, \": DVB-T\\n\");\n\t\tstate->m_operation_mode = o_mode;\n\t\tstatus = set_dvbt_standard(state, o_mode);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase OM_QAM_ITU_A:\n\tcase OM_QAM_ITU_C:\n\t\tdprintk(1, \": DVB-C Annex %c\\n\",\n\t\t\t(state->m_operation_mode == OM_QAM_ITU_A) ? 'A' : 'C');\n\t\tstate->m_operation_mode = o_mode;\n\t\tstatus = set_qam_standard(state, o_mode);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase OM_QAM_ITU_B:\n\tdefault:\n\t\tstatus = -EINVAL;\n\t}\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int start(struct drxk_state *state, s32 offset_freq,\n\t\t s32 intermediate_frequency)\n{\n\tint status = -EINVAL;\n\n\tu16 i_freqk_hz;\n\ts32 offsetk_hz = offset_freq / 1000;\n\n\tdprintk(1, \"\\n\");\n\tif (state->m_drxk_state != DRXK_STOPPED &&\n\t\tstate->m_drxk_state != DRXK_DTV_STARTED)\n\t\tgoto error;\n\n\tstate->m_b_mirror_freq_spect = (state->props.inversion == INVERSION_ON);\n\n\tif (intermediate_frequency < 0) {\n\t\tstate->m_b_mirror_freq_spect = !state->m_b_mirror_freq_spect;\n\t\tintermediate_frequency = -intermediate_frequency;\n\t}\n\n\tswitch (state->m_operation_mode) {\n\tcase OM_QAM_ITU_A:\n\tcase OM_QAM_ITU_C:\n\t\ti_freqk_hz = (intermediate_frequency / 1000);\n\t\tstatus = set_qam(state, i_freqk_hz, offsetk_hz);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstate->m_drxk_state = DRXK_DTV_STARTED;\n\t\tbreak;\n\tcase OM_DVBT:\n\t\ti_freqk_hz = (intermediate_frequency / 1000);\n\t\tstatus = mpegts_stop(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = set_dvbt(state, i_freqk_hz, offsetk_hz);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = dvbt_start(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstate->m_drxk_state = DRXK_DTV_STARTED;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int shut_down(struct drxk_state *state)\n{\n\tdprintk(1, \"\\n\");\n\n\tmpegts_stop(state);\n\treturn 0;\n}\n\nstatic int get_lock_status(struct drxk_state *state, u32 *p_lock_status)\n{\n\tint status = -EINVAL;\n\n\tdprintk(1, \"\\n\");\n\n\tif (p_lock_status == NULL)\n\t\tgoto error;\n\n\t*p_lock_status = NOT_LOCKED;\n\n\t \n\tswitch (state->m_operation_mode) {\n\tcase OM_QAM_ITU_A:\n\tcase OM_QAM_ITU_B:\n\tcase OM_QAM_ITU_C:\n\t\tstatus = get_qam_lock_status(state, p_lock_status);\n\t\tbreak;\n\tcase OM_DVBT:\n\t\tstatus = get_dvbt_lock_status(state, p_lock_status);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Unsupported operation mode %d in %s\\n\",\n\t\t\tstate->m_operation_mode, __func__);\n\t\treturn 0;\n\t}\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int mpegts_start(struct drxk_state *state)\n{\n\tint status;\n\n\tu16 fec_oc_snc_mode = 0;\n\n\t \n\tstatus = read16(state, FEC_OC_SNC_MODE__A, &fec_oc_snc_mode);\n\tif (status < 0)\n\t\tgoto error;\n\tfec_oc_snc_mode &= ~FEC_OC_SNC_MODE_SHUTDOWN__M;\n\tstatus = write16(state, FEC_OC_SNC_MODE__A, fec_oc_snc_mode);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_SNC_UNLOCK__A, 1);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int mpegts_dto_init(struct drxk_state *state)\n{\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\n\t \n\tstatus = write16(state, FEC_OC_RCN_CTL_STEP_LO__A, 0x0000);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_RCN_CTL_STEP_HI__A, 0x000C);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_RCN_GAIN__A, 0x000A);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_AVR_PARM_A__A, 0x0008);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_AVR_PARM_B__A, 0x0006);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_TMD_HI_MARGIN__A, 0x0680);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_TMD_LO_MARGIN__A, 0x0080);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_TMD_COUNT__A, 0x03F4);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, FEC_OC_OCR_INVERT__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_SNC_LWM__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_SNC_HWM__A, 12);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\nstatic int mpegts_dto_setup(struct drxk_state *state,\n\t\t\t  enum operation_mode o_mode)\n{\n\tint status;\n\n\tu16 fec_oc_reg_mode = 0;\t \n\tu16 fec_oc_reg_ipr_mode = 0;\t \n\tu16 fec_oc_dto_mode = 0;\t \n\tu16 fec_oc_fct_mode = 0;\t \n\tu16 fec_oc_dto_period = 2;\t \n\tu16 fec_oc_dto_burst_len = 188;\t \n\tu32 fec_oc_rcn_ctl_rate = 0;\t \n\tu16 fec_oc_tmd_mode = 0;\n\tu16 fec_oc_tmd_int_upd_rate = 0;\n\tu32 max_bit_rate = 0;\n\tbool static_clk = false;\n\n\tdprintk(1, \"\\n\");\n\n\t \n\tstatus = read16(state, FEC_OC_MODE__A, &fec_oc_reg_mode);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = read16(state, FEC_OC_IPR_MODE__A, &fec_oc_reg_ipr_mode);\n\tif (status < 0)\n\t\tgoto error;\n\tfec_oc_reg_mode &= (~FEC_OC_MODE_PARITY__M);\n\tfec_oc_reg_ipr_mode &= (~FEC_OC_IPR_MODE_MVAL_DIS_PAR__M);\n\tif (state->m_insert_rs_byte) {\n\t\t \n\t\tfec_oc_reg_mode |= FEC_OC_MODE_PARITY__M;\n\t\t \n\t\tfec_oc_reg_ipr_mode |= FEC_OC_IPR_MODE_MVAL_DIS_PAR__M;\n\t\t \n\t\tfec_oc_dto_burst_len = 204;\n\t}\n\n\t \n\tfec_oc_reg_ipr_mode &= (~(FEC_OC_IPR_MODE_SERIAL__M));\n\tif (!state->m_enable_parallel) {\n\t\t \n\t\tfec_oc_reg_ipr_mode |= FEC_OC_IPR_MODE_SERIAL__M;\n\t}\n\n\tswitch (o_mode) {\n\tcase OM_DVBT:\n\t\tmax_bit_rate = state->m_dvbt_bitrate;\n\t\tfec_oc_tmd_mode = 3;\n\t\tfec_oc_rcn_ctl_rate = 0xC00000;\n\t\tstatic_clk = state->m_dvbt_static_clk;\n\t\tbreak;\n\tcase OM_QAM_ITU_A:\n\tcase OM_QAM_ITU_C:\n\t\tfec_oc_tmd_mode = 0x0004;\n\t\tfec_oc_rcn_ctl_rate = 0xD2B4EE;\t \n\t\tmax_bit_rate = state->m_dvbc_bitrate;\n\t\tstatic_clk = state->m_dvbc_static_clk;\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t}\t\t \n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tif (static_clk) {\n\t\tu32 bit_rate = 0;\n\n\t\t \n\t\tfec_oc_dto_mode = (FEC_OC_DTO_MODE_DYNAMIC__M |\n\t\t\t\tFEC_OC_DTO_MODE_OFFSET_ENABLE__M);\n\t\tfec_oc_fct_mode = (FEC_OC_FCT_MODE_RAT_ENA__M |\n\t\t\t\tFEC_OC_FCT_MODE_VIRT_ENA__M);\n\n\t\t \n\t\tbit_rate = max_bit_rate;\n\t\tif (bit_rate > 75900000UL) {\t \n\t\t\tbit_rate = 75900000UL;\n\t\t}\n\t\t \n\t\tfec_oc_dto_period = (u16) (((state->m_sys_clock_freq)\n\t\t\t\t\t\t* 1000) / bit_rate);\n\t\tif (fec_oc_dto_period <= 2)\n\t\t\tfec_oc_dto_period = 0;\n\t\telse\n\t\t\tfec_oc_dto_period -= 2;\n\t\tfec_oc_tmd_int_upd_rate = 8;\n\t} else {\n\t\t \n\t\tfec_oc_dto_mode = FEC_OC_DTO_MODE_DYNAMIC__M;\n\t\tfec_oc_fct_mode = FEC_OC_FCT_MODE__PRE;\n\t\tfec_oc_tmd_int_upd_rate = 5;\n\t}\n\n\t \n\tstatus = write16(state, FEC_OC_DTO_BURST_LEN__A, fec_oc_dto_burst_len);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_DTO_PERIOD__A, fec_oc_dto_period);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_DTO_MODE__A, fec_oc_dto_mode);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_FCT_MODE__A, fec_oc_fct_mode);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_MODE__A, fec_oc_reg_mode);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_IPR_MODE__A, fec_oc_reg_ipr_mode);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write32(state, FEC_OC_RCN_CTL_RATE_LO__A, fec_oc_rcn_ctl_rate);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_TMD_INT_UPD_RATE__A,\n\t\t\t fec_oc_tmd_int_upd_rate);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_TMD_MODE__A, fec_oc_tmd_mode);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int mpegts_configure_polarity(struct drxk_state *state)\n{\n\tu16 fec_oc_reg_ipr_invert = 0;\n\n\t \n\tu16 invert_data_mask =\n\t    FEC_OC_IPR_INVERT_MD7__M | FEC_OC_IPR_INVERT_MD6__M |\n\t    FEC_OC_IPR_INVERT_MD5__M | FEC_OC_IPR_INVERT_MD4__M |\n\t    FEC_OC_IPR_INVERT_MD3__M | FEC_OC_IPR_INVERT_MD2__M |\n\t    FEC_OC_IPR_INVERT_MD1__M | FEC_OC_IPR_INVERT_MD0__M;\n\n\tdprintk(1, \"\\n\");\n\n\t \n\tfec_oc_reg_ipr_invert &= (~(invert_data_mask));\n\tif (state->m_invert_data)\n\t\tfec_oc_reg_ipr_invert |= invert_data_mask;\n\tfec_oc_reg_ipr_invert &= (~(FEC_OC_IPR_INVERT_MERR__M));\n\tif (state->m_invert_err)\n\t\tfec_oc_reg_ipr_invert |= FEC_OC_IPR_INVERT_MERR__M;\n\tfec_oc_reg_ipr_invert &= (~(FEC_OC_IPR_INVERT_MSTRT__M));\n\tif (state->m_invert_str)\n\t\tfec_oc_reg_ipr_invert |= FEC_OC_IPR_INVERT_MSTRT__M;\n\tfec_oc_reg_ipr_invert &= (~(FEC_OC_IPR_INVERT_MVAL__M));\n\tif (state->m_invert_val)\n\t\tfec_oc_reg_ipr_invert |= FEC_OC_IPR_INVERT_MVAL__M;\n\tfec_oc_reg_ipr_invert &= (~(FEC_OC_IPR_INVERT_MCLK__M));\n\tif (state->m_invert_clk)\n\t\tfec_oc_reg_ipr_invert |= FEC_OC_IPR_INVERT_MCLK__M;\n\n\treturn write16(state, FEC_OC_IPR_INVERT__A, fec_oc_reg_ipr_invert);\n}\n\n#define   SCU_RAM_AGC_KI_INV_RF_POL__M 0x4000\n\nstatic int set_agc_rf(struct drxk_state *state,\n\t\t    struct s_cfg_agc *p_agc_cfg, bool is_dtv)\n{\n\tint status = -EINVAL;\n\tu16 data = 0;\n\tstruct s_cfg_agc *p_if_agc_settings;\n\n\tdprintk(1, \"\\n\");\n\n\tif (p_agc_cfg == NULL)\n\t\tgoto error;\n\n\tswitch (p_agc_cfg->ctrl_mode) {\n\tcase DRXK_AGC_CTRL_AUTO:\n\t\t \n\t\tstatus = read16(state, IQM_AF_STDBY__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tdata &= ~IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY;\n\t\tstatus = write16(state, IQM_AF_STDBY__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = read16(state, SCU_RAM_AGC_CONFIG__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tdata &= ~SCU_RAM_AGC_CONFIG_DISABLE_RF_AGC__M;\n\n\t\t \n\t\tif (state->m_rf_agc_pol)\n\t\t\tdata |= SCU_RAM_AGC_CONFIG_INV_RF_POL__M;\n\t\telse\n\t\t\tdata &= ~SCU_RAM_AGC_CONFIG_INV_RF_POL__M;\n\t\tstatus = write16(state, SCU_RAM_AGC_CONFIG__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = read16(state, SCU_RAM_AGC_KI_RED__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tdata &= ~SCU_RAM_AGC_KI_RED_RAGC_RED__M;\n\t\tdata |= (~(p_agc_cfg->speed <<\n\t\t\t\tSCU_RAM_AGC_KI_RED_RAGC_RED__B)\n\t\t\t\t& SCU_RAM_AGC_KI_RED_RAGC_RED__M);\n\n\t\tstatus = write16(state, SCU_RAM_AGC_KI_RED__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tif (is_dvbt(state))\n\t\t\tp_if_agc_settings = &state->m_dvbt_if_agc_cfg;\n\t\telse if (is_qam(state))\n\t\t\tp_if_agc_settings = &state->m_qam_if_agc_cfg;\n\t\telse\n\t\t\tp_if_agc_settings = &state->m_atv_if_agc_cfg;\n\t\tif (p_if_agc_settings == NULL) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (p_if_agc_settings->ctrl_mode == DRXK_AGC_CTRL_AUTO) {\n\t\t\tstatus = write16(state,\n\t\t\t\t\t SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A,\n\t\t\t\t\t p_agc_cfg->top);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tstatus = write16(state, SCU_RAM_AGC_RF_IACCU_HI_CO__A,\n\t\t\t\t p_agc_cfg->cut_off_current);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = write16(state, SCU_RAM_AGC_RF_MAX__A,\n\t\t\t\t p_agc_cfg->max_output_level);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tbreak;\n\n\tcase DRXK_AGC_CTRL_USER:\n\t\t \n\t\tstatus = read16(state, IQM_AF_STDBY__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tdata &= ~IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY;\n\t\tstatus = write16(state, IQM_AF_STDBY__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = read16(state, SCU_RAM_AGC_CONFIG__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tdata |= SCU_RAM_AGC_CONFIG_DISABLE_RF_AGC__M;\n\t\tif (state->m_rf_agc_pol)\n\t\t\tdata |= SCU_RAM_AGC_CONFIG_INV_RF_POL__M;\n\t\telse\n\t\t\tdata &= ~SCU_RAM_AGC_CONFIG_INV_RF_POL__M;\n\t\tstatus = write16(state, SCU_RAM_AGC_CONFIG__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = write16(state, SCU_RAM_AGC_RF_IACCU_HI_CO__A, 0);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = write16(state, SCU_RAM_AGC_RF_IACCU_HI__A,\n\t\t\t\t p_agc_cfg->output_level);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tbreak;\n\n\tcase DRXK_AGC_CTRL_OFF:\n\t\t \n\t\tstatus = read16(state, IQM_AF_STDBY__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tdata |= IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY;\n\t\tstatus = write16(state, IQM_AF_STDBY__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = read16(state, SCU_RAM_AGC_CONFIG__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tdata |= SCU_RAM_AGC_CONFIG_DISABLE_RF_AGC__M;\n\t\tstatus = write16(state, SCU_RAM_AGC_CONFIG__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\n\t}\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\n#define SCU_RAM_AGC_KI_INV_IF_POL__M 0x2000\n\nstatic int set_agc_if(struct drxk_state *state,\n\t\t    struct s_cfg_agc *p_agc_cfg, bool is_dtv)\n{\n\tu16 data = 0;\n\tint status = 0;\n\tstruct s_cfg_agc *p_rf_agc_settings;\n\n\tdprintk(1, \"\\n\");\n\n\tswitch (p_agc_cfg->ctrl_mode) {\n\tcase DRXK_AGC_CTRL_AUTO:\n\n\t\t \n\t\tstatus = read16(state, IQM_AF_STDBY__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tdata &= ~IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY;\n\t\tstatus = write16(state, IQM_AF_STDBY__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tstatus = read16(state, SCU_RAM_AGC_CONFIG__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tdata &= ~SCU_RAM_AGC_CONFIG_DISABLE_IF_AGC__M;\n\n\t\t \n\t\tif (state->m_if_agc_pol)\n\t\t\tdata |= SCU_RAM_AGC_CONFIG_INV_IF_POL__M;\n\t\telse\n\t\t\tdata &= ~SCU_RAM_AGC_CONFIG_INV_IF_POL__M;\n\t\tstatus = write16(state, SCU_RAM_AGC_CONFIG__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = read16(state, SCU_RAM_AGC_KI_RED__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tdata &= ~SCU_RAM_AGC_KI_RED_IAGC_RED__M;\n\t\tdata |= (~(p_agc_cfg->speed <<\n\t\t\t\tSCU_RAM_AGC_KI_RED_IAGC_RED__B)\n\t\t\t\t& SCU_RAM_AGC_KI_RED_IAGC_RED__M);\n\n\t\tstatus = write16(state, SCU_RAM_AGC_KI_RED__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tif (is_qam(state))\n\t\t\tp_rf_agc_settings = &state->m_qam_rf_agc_cfg;\n\t\telse\n\t\t\tp_rf_agc_settings = &state->m_atv_rf_agc_cfg;\n\t\tif (p_rf_agc_settings == NULL)\n\t\t\treturn -1;\n\t\t \n\t\tstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A,\n\t\t\t\t p_rf_agc_settings->top);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tbreak;\n\n\tcase DRXK_AGC_CTRL_USER:\n\n\t\t \n\t\tstatus = read16(state, IQM_AF_STDBY__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tdata &= ~IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY;\n\t\tstatus = write16(state, IQM_AF_STDBY__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tstatus = read16(state, SCU_RAM_AGC_CONFIG__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tdata |= SCU_RAM_AGC_CONFIG_DISABLE_IF_AGC__M;\n\n\t\t \n\t\tif (state->m_if_agc_pol)\n\t\t\tdata |= SCU_RAM_AGC_CONFIG_INV_IF_POL__M;\n\t\telse\n\t\t\tdata &= ~SCU_RAM_AGC_CONFIG_INV_IF_POL__M;\n\t\tstatus = write16(state, SCU_RAM_AGC_CONFIG__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A,\n\t\t\t\t p_agc_cfg->output_level);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tbreak;\n\n\tcase DRXK_AGC_CTRL_OFF:\n\n\t\t \n\t\tstatus = read16(state, IQM_AF_STDBY__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tdata |= IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY;\n\t\tstatus = write16(state, IQM_AF_STDBY__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = read16(state, SCU_RAM_AGC_CONFIG__A, &data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tdata |= SCU_RAM_AGC_CONFIG_DISABLE_IF_AGC__M;\n\t\tstatus = write16(state, SCU_RAM_AGC_CONFIG__A, data);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tbreak;\n\t}\t\t \n\n\t \n\tstatus = write16(state, SCU_RAM_AGC_INGAIN_TGT_MIN__A, p_agc_cfg->top);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int get_qam_signal_to_noise(struct drxk_state *state,\n\t\t\t       s32 *p_signal_to_noise)\n{\n\tint status = 0;\n\tu16 qam_sl_err_power = 0;\t \n\tu32 qam_sl_sig_power = 0;\t \n\tu32 qam_sl_mer = 0;\t \n\n\tdprintk(1, \"\\n\");\n\n\t \n\n\t \n\tstatus = read16(state, QAM_SL_ERR_POWER__A, &qam_sl_err_power);\n\tif (status < 0) {\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (state->props.modulation) {\n\tcase QAM_16:\n\t\tqam_sl_sig_power = DRXK_QAM_SL_SIG_POWER_QAM16 << 2;\n\t\tbreak;\n\tcase QAM_32:\n\t\tqam_sl_sig_power = DRXK_QAM_SL_SIG_POWER_QAM32 << 2;\n\t\tbreak;\n\tcase QAM_64:\n\t\tqam_sl_sig_power = DRXK_QAM_SL_SIG_POWER_QAM64 << 2;\n\t\tbreak;\n\tcase QAM_128:\n\t\tqam_sl_sig_power = DRXK_QAM_SL_SIG_POWER_QAM128 << 2;\n\t\tbreak;\n\tdefault:\n\tcase QAM_256:\n\t\tqam_sl_sig_power = DRXK_QAM_SL_SIG_POWER_QAM256 << 2;\n\t\tbreak;\n\t}\n\n\tif (qam_sl_err_power > 0) {\n\t\tqam_sl_mer = log10times100(qam_sl_sig_power) -\n\t\t\tlog10times100((u32) qam_sl_err_power);\n\t}\n\t*p_signal_to_noise = qam_sl_mer;\n\n\treturn status;\n}\n\nstatic int get_dvbt_signal_to_noise(struct drxk_state *state,\n\t\t\t\ts32 *p_signal_to_noise)\n{\n\tint status;\n\tu16 reg_data = 0;\n\tu32 eq_reg_td_sqr_err_i = 0;\n\tu32 eq_reg_td_sqr_err_q = 0;\n\tu16 eq_reg_td_sqr_err_exp = 0;\n\tu16 eq_reg_td_tps_pwr_ofs = 0;\n\tu16 eq_reg_td_req_smb_cnt = 0;\n\tu32 tps_cnt = 0;\n\tu32 sqr_err_iq = 0;\n\tu32 a = 0;\n\tu32 b = 0;\n\tu32 c = 0;\n\tu32 i_mer = 0;\n\tu16 transmission_params = 0;\n\n\tdprintk(1, \"\\n\");\n\n\tstatus = read16(state, OFDM_EQ_TOP_TD_TPS_PWR_OFS__A,\n\t\t\t&eq_reg_td_tps_pwr_ofs);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = read16(state, OFDM_EQ_TOP_TD_REQ_SMB_CNT__A,\n\t\t\t&eq_reg_td_req_smb_cnt);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = read16(state, OFDM_EQ_TOP_TD_SQR_ERR_EXP__A,\n\t\t\t&eq_reg_td_sqr_err_exp);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = read16(state, OFDM_EQ_TOP_TD_SQR_ERR_I__A,\n\t\t\t&reg_data);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\teq_reg_td_sqr_err_i = (u32) reg_data;\n\tif ((eq_reg_td_sqr_err_exp > 11) &&\n\t\t(eq_reg_td_sqr_err_i < 0x00000FFFUL)) {\n\t\teq_reg_td_sqr_err_i += 0x00010000UL;\n\t}\n\tstatus = read16(state, OFDM_EQ_TOP_TD_SQR_ERR_Q__A, &reg_data);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\teq_reg_td_sqr_err_q = (u32) reg_data;\n\tif ((eq_reg_td_sqr_err_exp > 11) &&\n\t\t(eq_reg_td_sqr_err_q < 0x00000FFFUL))\n\t\teq_reg_td_sqr_err_q += 0x00010000UL;\n\n\tstatus = read16(state, OFDM_SC_RA_RAM_OP_PARAM__A,\n\t\t\t&transmission_params);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\n\t \n\tif ((eq_reg_td_tps_pwr_ofs == 0) || (eq_reg_td_req_smb_cnt == 0))\n\t\ti_mer = 0;\n\telse if ((eq_reg_td_sqr_err_i + eq_reg_td_sqr_err_q) == 0) {\n\t\t \n\t\ti_mer = 0;\n\t} else {\n\t\tsqr_err_iq = (eq_reg_td_sqr_err_i + eq_reg_td_sqr_err_q) <<\n\t\t\teq_reg_td_sqr_err_exp;\n\t\tif ((transmission_params &\n\t\t\tOFDM_SC_RA_RAM_OP_PARAM_MODE__M)\n\t\t\t== OFDM_SC_RA_RAM_OP_PARAM_MODE_2K)\n\t\t\ttps_cnt = 17;\n\t\telse\n\t\t\ttps_cnt = 68;\n\n\t\t \n\n\t\t \n\t\ta = log10times100(eq_reg_td_tps_pwr_ofs *\n\t\t\t\t\teq_reg_td_tps_pwr_ofs);\n\t\t \n\t\tb = log10times100(eq_reg_td_req_smb_cnt * tps_cnt);\n\t\t \n\t\tc = log10times100(sqr_err_iq);\n\n\t\ti_mer = a + b - c;\n\t}\n\t*p_signal_to_noise = i_mer;\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int get_signal_to_noise(struct drxk_state *state, s32 *p_signal_to_noise)\n{\n\tdprintk(1, \"\\n\");\n\n\t*p_signal_to_noise = 0;\n\tswitch (state->m_operation_mode) {\n\tcase OM_DVBT:\n\t\treturn get_dvbt_signal_to_noise(state, p_signal_to_noise);\n\tcase OM_QAM_ITU_A:\n\tcase OM_QAM_ITU_C:\n\t\treturn get_qam_signal_to_noise(state, p_signal_to_noise);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#if 0\nstatic int get_dvbt_quality(struct drxk_state *state, s32 *p_quality)\n{\n\t \n\tint status = 0;\n\n\tdprintk(1, \"\\n\");\n\n\tstatic s32 QE_SN[] = {\n\t\t51,\t\t \n\t\t69,\t\t \n\t\t79,\t\t \n\t\t89,\t\t \n\t\t97,\t\t \n\t\t108,\t\t \n\t\t131,\t\t \n\t\t146,\t\t \n\t\t156,\t\t \n\t\t160,\t\t \n\t\t165,\t\t \n\t\t187,\t\t \n\t\t202,\t\t \n\t\t216,\t\t \n\t\t225,\t\t \n\t};\n\n\t*p_quality = 0;\n\n\tdo {\n\t\ts32 signal_to_noise = 0;\n\t\tu16 constellation = 0;\n\t\tu16 code_rate = 0;\n\t\tu32 signal_to_noise_rel;\n\t\tu32 ber_quality;\n\n\t\tstatus = get_dvbt_signal_to_noise(state, &signal_to_noise);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = read16(state, OFDM_EQ_TOP_TD_TPS_CONST__A,\n\t\t\t\t&constellation);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tconstellation &= OFDM_EQ_TOP_TD_TPS_CONST__M;\n\n\t\tstatus = read16(state, OFDM_EQ_TOP_TD_TPS_CODE_HP__A,\n\t\t\t\t&code_rate);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tcode_rate &= OFDM_EQ_TOP_TD_TPS_CODE_HP__M;\n\n\t\tif (constellation > OFDM_EQ_TOP_TD_TPS_CONST_64QAM ||\n\t\t    code_rate > OFDM_EQ_TOP_TD_TPS_CODE_LP_7_8)\n\t\t\tbreak;\n\t\tsignal_to_noise_rel = signal_to_noise -\n\t\t    QE_SN[constellation * 5 + code_rate];\n\t\tber_quality = 100;\n\n\t\tif (signal_to_noise_rel < -70)\n\t\t\t*p_quality = 0;\n\t\telse if (signal_to_noise_rel < 30)\n\t\t\t*p_quality = ((signal_to_noise_rel + 70) *\n\t\t\t\t     ber_quality) / 100;\n\t\telse\n\t\t\t*p_quality = ber_quality;\n\t} while (0);\n\treturn 0;\n};\n\nstatic int get_dvbc_quality(struct drxk_state *state, s32 *p_quality)\n{\n\tint status = 0;\n\t*p_quality = 0;\n\n\tdprintk(1, \"\\n\");\n\n\tdo {\n\t\tu32 signal_to_noise = 0;\n\t\tu32 ber_quality = 100;\n\t\tu32 signal_to_noise_rel = 0;\n\n\t\tstatus = get_qam_signal_to_noise(state, &signal_to_noise);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tswitch (state->props.modulation) {\n\t\tcase QAM_16:\n\t\t\tsignal_to_noise_rel = signal_to_noise - 200;\n\t\t\tbreak;\n\t\tcase QAM_32:\n\t\t\tsignal_to_noise_rel = signal_to_noise - 230;\n\t\t\tbreak;\t \n\t\tcase QAM_64:\n\t\t\tsignal_to_noise_rel = signal_to_noise - 260;\n\t\t\tbreak;\n\t\tcase QAM_128:\n\t\t\tsignal_to_noise_rel = signal_to_noise - 290;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase QAM_256:\n\t\t\tsignal_to_noise_rel = signal_to_noise - 320;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_to_noise_rel < -70)\n\t\t\t*p_quality = 0;\n\t\telse if (signal_to_noise_rel < 30)\n\t\t\t*p_quality = ((signal_to_noise_rel + 70) *\n\t\t\t\t     ber_quality) / 100;\n\t\telse\n\t\t\t*p_quality = ber_quality;\n\t} while (0);\n\n\treturn status;\n}\n\nstatic int get_quality(struct drxk_state *state, s32 *p_quality)\n{\n\tdprintk(1, \"\\n\");\n\n\tswitch (state->m_operation_mode) {\n\tcase OM_DVBT:\n\t\treturn get_dvbt_quality(state, p_quality);\n\tcase OM_QAM_ITU_A:\n\t\treturn get_dvbc_quality(state, p_quality);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n#endif\n\n \n#define SIO_HI_RA_RAM_USR_BEGIN__A 0x420040\n#define SIO_HI_RA_RAM_USR_END__A   0x420060\n\n#define DRXK_HI_ATOMIC_BUF_START (SIO_HI_RA_RAM_USR_BEGIN__A)\n#define DRXK_HI_ATOMIC_BUF_END   (SIO_HI_RA_RAM_USR_BEGIN__A + 7)\n#define DRXK_HI_ATOMIC_READ      SIO_HI_RA_RAM_PAR_3_ACP_RW_READ\n#define DRXK_HI_ATOMIC_WRITE     SIO_HI_RA_RAM_PAR_3_ACP_RW_WRITE\n\n#define DRXDAP_FASI_ADDR2BLOCK(addr)  (((addr) >> 22) & 0x3F)\n#define DRXDAP_FASI_ADDR2BANK(addr)   (((addr) >> 16) & 0x3F)\n#define DRXDAP_FASI_ADDR2OFFSET(addr) ((addr) & 0x7FFF)\n\nstatic int ConfigureI2CBridge(struct drxk_state *state, bool b_enable_bridge)\n{\n\tint status = -EINVAL;\n\n\tdprintk(1, \"\\n\");\n\n\tif (state->m_drxk_state == DRXK_UNINITIALIZED)\n\t\treturn 0;\n\tif (state->m_drxk_state == DRXK_POWERED_DOWN)\n\t\tgoto error;\n\n\tif (state->no_i2c_bridge)\n\t\treturn 0;\n\n\tstatus = write16(state, SIO_HI_RA_RAM_PAR_1__A,\n\t\t\t SIO_HI_RA_RAM_PAR_1_PAR1_SEC_KEY);\n\tif (status < 0)\n\t\tgoto error;\n\tif (b_enable_bridge) {\n\t\tstatus = write16(state, SIO_HI_RA_RAM_PAR_2__A,\n\t\t\t\t SIO_HI_RA_RAM_PAR_2_BRD_CFG_CLOSED);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t} else {\n\t\tstatus = write16(state, SIO_HI_RA_RAM_PAR_2__A,\n\t\t\t\t SIO_HI_RA_RAM_PAR_2_BRD_CFG_OPEN);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t}\n\n\tstatus = hi_command(state, SIO_HI_RA_RAM_CMD_BRDCTRL, NULL);\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int set_pre_saw(struct drxk_state *state,\n\t\t     struct s_cfg_pre_saw *p_pre_saw_cfg)\n{\n\tint status = -EINVAL;\n\n\tdprintk(1, \"\\n\");\n\n\tif ((p_pre_saw_cfg == NULL)\n\t    || (p_pre_saw_cfg->reference > IQM_AF_PDREF__M))\n\t\tgoto error;\n\n\tstatus = write16(state, IQM_AF_PDREF__A, p_pre_saw_cfg->reference);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int bl_direct_cmd(struct drxk_state *state, u32 target_addr,\n\t\t       u16 rom_offset, u16 nr_of_elements, u32 time_out)\n{\n\tu16 bl_status = 0;\n\tu16 offset = (u16) ((target_addr >> 0) & 0x00FFFF);\n\tu16 blockbank = (u16) ((target_addr >> 16) & 0x000FFF);\n\tint status;\n\tunsigned long end;\n\n\tdprintk(1, \"\\n\");\n\n\tmutex_lock(&state->mutex);\n\tstatus = write16(state, SIO_BL_MODE__A, SIO_BL_MODE_DIRECT);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_BL_TGT_HDR__A, blockbank);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_BL_TGT_ADDR__A, offset);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_BL_SRC_ADDR__A, rom_offset);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_BL_SRC_LEN__A, nr_of_elements);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_BL_ENABLE__A, SIO_BL_ENABLE_ON);\n\tif (status < 0)\n\t\tgoto error;\n\n\tend = jiffies + msecs_to_jiffies(time_out);\n\tdo {\n\t\tstatus = read16(state, SIO_BL_STATUS__A, &bl_status);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t} while ((bl_status == 0x1) && time_is_after_jiffies(end));\n\tif (bl_status == 0x1) {\n\t\tpr_err(\"SIO not ready\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto error2;\n\t}\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\nerror2:\n\tmutex_unlock(&state->mutex);\n\treturn status;\n\n}\n\nstatic int adc_sync_measurement(struct drxk_state *state, u16 *count)\n{\n\tu16 data = 0;\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\n\t \n\tstatus = write16(state, IQM_AF_COMM_EXEC__A, IQM_AF_COMM_EXEC_ACTIVE);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_AF_START_LOCK__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\n\t*count = 0;\n\tstatus = read16(state, IQM_AF_PHASE0__A, &data);\n\tif (status < 0)\n\t\tgoto error;\n\tif (data == 127)\n\t\t*count = *count + 1;\n\tstatus = read16(state, IQM_AF_PHASE1__A, &data);\n\tif (status < 0)\n\t\tgoto error;\n\tif (data == 127)\n\t\t*count = *count + 1;\n\tstatus = read16(state, IQM_AF_PHASE2__A, &data);\n\tif (status < 0)\n\t\tgoto error;\n\tif (data == 127)\n\t\t*count = *count + 1;\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int adc_synchronization(struct drxk_state *state)\n{\n\tu16 count = 0;\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\n\tstatus = adc_sync_measurement(state, &count);\n\tif (status < 0)\n\t\tgoto error;\n\n\tif (count == 1) {\n\t\t \n\t\tu16 clk_neg = 0;\n\n\t\tstatus = read16(state, IQM_AF_CLKNEG__A, &clk_neg);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tif ((clk_neg & IQM_AF_CLKNEG_CLKNEGDATA__M) ==\n\t\t\tIQM_AF_CLKNEG_CLKNEGDATA_CLK_ADC_DATA_POS) {\n\t\t\tclk_neg &= (~(IQM_AF_CLKNEG_CLKNEGDATA__M));\n\t\t\tclk_neg |=\n\t\t\t\tIQM_AF_CLKNEG_CLKNEGDATA_CLK_ADC_DATA_NEG;\n\t\t} else {\n\t\t\tclk_neg &= (~(IQM_AF_CLKNEG_CLKNEGDATA__M));\n\t\t\tclk_neg |=\n\t\t\t\tIQM_AF_CLKNEG_CLKNEGDATA_CLK_ADC_DATA_POS;\n\t\t}\n\t\tstatus = write16(state, IQM_AF_CLKNEG__A, clk_neg);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = adc_sync_measurement(state, &count);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (count < 2)\n\t\tstatus = -EINVAL;\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int set_frequency_shifter(struct drxk_state *state,\n\t\t\t       u16 intermediate_freqk_hz,\n\t\t\t       s32 tuner_freq_offset, bool is_dtv)\n{\n\tbool select_pos_image = false;\n\tu32 rf_freq_residual = tuner_freq_offset;\n\tu32 fm_frequency_shift = 0;\n\tbool tuner_mirror = !state->m_b_mirror_freq_spect;\n\tu32 adc_freq;\n\tbool adc_flip;\n\tint status;\n\tu32 if_freq_actual;\n\tu32 sampling_frequency = (u32) (state->m_sys_clock_freq / 3);\n\tu32 frequency_shift;\n\tbool image_to_select;\n\n\tdprintk(1, \"\\n\");\n\n\t \n\tif (is_dtv) {\n\t\tif ((state->m_operation_mode == OM_QAM_ITU_A) ||\n\t\t    (state->m_operation_mode == OM_QAM_ITU_C) ||\n\t\t    (state->m_operation_mode == OM_DVBT))\n\t\t\tselect_pos_image = true;\n\t\telse\n\t\t\tselect_pos_image = false;\n\t}\n\tif (tuner_mirror)\n\t\t \n\t\tif_freq_actual = intermediate_freqk_hz +\n\t\t    rf_freq_residual + fm_frequency_shift;\n\telse\n\t\t \n\t\tif_freq_actual = intermediate_freqk_hz -\n\t\t    rf_freq_residual - fm_frequency_shift;\n\tif (if_freq_actual > sampling_frequency / 2) {\n\t\t \n\t\tadc_freq = sampling_frequency - if_freq_actual;\n\t\tadc_flip = true;\n\t} else {\n\t\t \n\t\tadc_freq = if_freq_actual;\n\t\tadc_flip = false;\n\t}\n\n\tfrequency_shift = adc_freq;\n\timage_to_select = state->m_rfmirror ^ tuner_mirror ^\n\t    adc_flip ^ select_pos_image;\n\tstate->m_iqm_fs_rate_ofs =\n\t    Frac28a((frequency_shift), sampling_frequency);\n\n\tif (image_to_select)\n\t\tstate->m_iqm_fs_rate_ofs = ~state->m_iqm_fs_rate_ofs + 1;\n\n\t \n\t \n\tstatus = write32(state, IQM_FS_RATE_OFS_LO__A,\n\t\t\t state->m_iqm_fs_rate_ofs);\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int init_agc(struct drxk_state *state, bool is_dtv)\n{\n\tu16 ingain_tgt = 0;\n\tu16 ingain_tgt_min = 0;\n\tu16 ingain_tgt_max = 0;\n\tu16 clp_cyclen = 0;\n\tu16 clp_sum_min = 0;\n\tu16 clp_dir_to = 0;\n\tu16 sns_sum_min = 0;\n\tu16 sns_sum_max = 0;\n\tu16 clp_sum_max = 0;\n\tu16 sns_dir_to = 0;\n\tu16 ki_innergain_min = 0;\n\tu16 if_iaccu_hi_tgt = 0;\n\tu16 if_iaccu_hi_tgt_min = 0;\n\tu16 if_iaccu_hi_tgt_max = 0;\n\tu16 data = 0;\n\tu16 fast_clp_ctrl_delay = 0;\n\tu16 clp_ctrl_mode = 0;\n\tint status = 0;\n\n\tdprintk(1, \"\\n\");\n\n\t \n\tsns_sum_max = 1023;\n\tif_iaccu_hi_tgt_min = 2047;\n\tclp_cyclen = 500;\n\tclp_sum_max = 1023;\n\n\t \n\tif (!is_qam(state)) {\n\t\tpr_err(\"%s: mode %d is not DVB-C\\n\",\n\t\t       __func__, state->m_operation_mode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\t \n\tclp_sum_min = 8;\n\tclp_dir_to = (u16) -9;\n\tclp_ctrl_mode = 0;\n\tsns_sum_min = 8;\n\tsns_dir_to = (u16) -9;\n\tki_innergain_min = (u16) -1030;\n\tif_iaccu_hi_tgt_max = 0x2380;\n\tif_iaccu_hi_tgt = 0x2380;\n\tingain_tgt_min = 0x0511;\n\tingain_tgt = 0x0511;\n\tingain_tgt_max = 5119;\n\tfast_clp_ctrl_delay = state->m_qam_if_agc_cfg.fast_clip_ctrl_delay;\n\n\tstatus = write16(state, SCU_RAM_AGC_FAST_CLP_CTRL_DELAY__A,\n\t\t\t fast_clp_ctrl_delay);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_AGC_CLP_CTRL_MODE__A, clp_ctrl_mode);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_INGAIN_TGT__A, ingain_tgt);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_INGAIN_TGT_MIN__A, ingain_tgt_min);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_INGAIN_TGT_MAX__A, ingain_tgt_max);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MIN__A,\n\t\t\t if_iaccu_hi_tgt_min);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A,\n\t\t\t if_iaccu_hi_tgt_max);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_IF_IACCU_LO__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_RF_IACCU_HI__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_RF_IACCU_LO__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_CLP_SUM_MAX__A, clp_sum_max);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_SNS_SUM_MAX__A, sns_sum_max);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_AGC_KI_INNERGAIN_MIN__A,\n\t\t\t ki_innergain_min);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT__A,\n\t\t\t if_iaccu_hi_tgt);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_CLP_CYCLEN__A, clp_cyclen);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_AGC_RF_SNS_DEV_MAX__A, 1023);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_RF_SNS_DEV_MIN__A, (u16) -1023);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_FAST_SNS_CTRL_DELAY__A, 50);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_AGC_KI_MAXMINGAIN_TH__A, 20);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_CLP_SUM_MIN__A, clp_sum_min);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_SNS_SUM_MIN__A, sns_sum_min);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_CLP_DIR_TO__A, clp_dir_to);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_SNS_DIR_TO__A, sns_dir_to);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_KI_MINGAIN__A, 0x7fff);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_KI_MAXGAIN__A, 0x0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_KI_MIN__A, 0x0117);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_KI_MAX__A, 0x0657);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_CLP_SUM__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_CLP_CYCCNT__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_CLP_DIR_WD__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_CLP_DIR_STP__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_SNS_SUM__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_SNS_CYCCNT__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_SNS_DIR_WD__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_SNS_DIR_STP__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_SNS_CYCLEN__A, 500);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_KI_CYCLEN__A, 500);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = read16(state, SCU_RAM_AGC_KI__A, &data);\n\tif (status < 0)\n\t\tgoto error;\n\n\tdata = 0x0657;\n\tdata &= ~SCU_RAM_AGC_KI_RF__M;\n\tdata |= (DRXK_KI_RAGC_QAM << SCU_RAM_AGC_KI_RF__B);\n\tdata &= ~SCU_RAM_AGC_KI_IF__M;\n\tdata |= (DRXK_KI_IAGC_QAM << SCU_RAM_AGC_KI_IF__B);\n\n\tstatus = write16(state, SCU_RAM_AGC_KI__A, data);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int dvbtqam_get_acc_pkt_err(struct drxk_state *state, u16 *packet_err)\n{\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\tif (packet_err == NULL)\n\t\tstatus = write16(state, SCU_RAM_FEC_ACCUM_PKT_FAILURES__A, 0);\n\telse\n\t\tstatus = read16(state, SCU_RAM_FEC_ACCUM_PKT_FAILURES__A,\n\t\t\t\tpacket_err);\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int dvbt_sc_command(struct drxk_state *state,\n\t\t\t u16 cmd, u16 subcmd,\n\t\t\t u16 param0, u16 param1, u16 param2,\n\t\t\t u16 param3, u16 param4)\n{\n\tu16 cur_cmd = 0;\n\tu16 err_code = 0;\n\tu16 retry_cnt = 0;\n\tu16 sc_exec = 0;\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\tstatus = read16(state, OFDM_SC_COMM_EXEC__A, &sc_exec);\n\tif (sc_exec != 1) {\n\t\t \n\t\tstatus = -EINVAL;\n\t}\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tretry_cnt = 0;\n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\tstatus = read16(state, OFDM_SC_RA_RAM_CMD__A, &cur_cmd);\n\t\tretry_cnt++;\n\t} while ((cur_cmd != 0) && (retry_cnt < DRXK_MAX_RETRIES));\n\tif (retry_cnt >= DRXK_MAX_RETRIES && (status < 0))\n\t\tgoto error;\n\n\t \n\tswitch (cmd) {\n\t\t \n\tcase OFDM_SC_RA_RAM_CMD_PROC_START:\n\tcase OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:\n\tcase OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_CMD_ADDR__A, subcmd);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tstatus = 0;\n\tswitch (cmd) {\n\t\t \n\t\t \n\t\t \n\t\t \n\tcase OFDM_SC_RA_RAM_CMD_PROC_START:\n\tcase OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:\n\tcase OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:\n\t\tstatus |= write16(state, OFDM_SC_RA_RAM_PARAM1__A, param1);\n\t\tfallthrough;\t \n\tcase OFDM_SC_RA_RAM_CMD_SET_ECHO_TIMING:\n\tcase OFDM_SC_RA_RAM_CMD_USER_IO:\n\t\tstatus |= write16(state, OFDM_SC_RA_RAM_PARAM0__A, param0);\n\t\tfallthrough;\t \n\tcase OFDM_SC_RA_RAM_CMD_GET_OP_PARAM:\n\tcase OFDM_SC_RA_RAM_CMD_NULL:\n\t\t \n\t\tstatus |= write16(state, OFDM_SC_RA_RAM_CMD__A, cmd);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tstatus = -EINVAL;\n\t}\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tretry_cnt = 0;\n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\tstatus = read16(state, OFDM_SC_RA_RAM_CMD__A, &cur_cmd);\n\t\tretry_cnt++;\n\t} while ((cur_cmd != 0) && (retry_cnt < DRXK_MAX_RETRIES));\n\tif (retry_cnt >= DRXK_MAX_RETRIES && (status < 0))\n\t\tgoto error;\n\n\t \n\tstatus = read16(state, OFDM_SC_RA_RAM_CMD_ADDR__A, &err_code);\n\tif (err_code == 0xFFFF) {\n\t\t \n\t\tstatus = -EINVAL;\n\t}\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tswitch (cmd) {\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\tcase OFDM_SC_RA_RAM_CMD_USER_IO:\n\tcase OFDM_SC_RA_RAM_CMD_GET_OP_PARAM:\n\t\tstatus = read16(state, OFDM_SC_RA_RAM_PARAM0__A, &(param0));\n\t\tbreak;\n\t\t \n\tcase OFDM_SC_RA_RAM_CMD_SET_ECHO_TIMING:\n\tcase OFDM_SC_RA_RAM_CMD_SET_TIMER:\n\tcase OFDM_SC_RA_RAM_CMD_PROC_START:\n\tcase OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:\n\tcase OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:\n\tcase OFDM_SC_RA_RAM_CMD_NULL:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tstatus = -EINVAL;\n\t\tbreak;\n\t}\t\t\t \nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int power_up_dvbt(struct drxk_state *state)\n{\n\tenum drx_power_mode power_mode = DRX_POWER_UP;\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\tstatus = ctrl_power_mode(state, &power_mode);\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int dvbt_ctrl_set_inc_enable(struct drxk_state *state, bool *enabled)\n{\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\tif (*enabled)\n\t\tstatus = write16(state, IQM_CF_BYPASSDET__A, 0);\n\telse\n\t\tstatus = write16(state, IQM_CF_BYPASSDET__A, 1);\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\n#define DEFAULT_FR_THRES_8K     4000\nstatic int dvbt_ctrl_set_fr_enable(struct drxk_state *state, bool *enabled)\n{\n\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\tif (*enabled) {\n\t\t \n\t\tstatus = write16(state, OFDM_SC_RA_RAM_FR_THRES_8K__A,\n\t\t\t\t   DEFAULT_FR_THRES_8K);\n\t} else {\n\t\t \n\t\tstatus = write16(state, OFDM_SC_RA_RAM_FR_THRES_8K__A, 0);\n\t}\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\nstatic int dvbt_ctrl_set_echo_threshold(struct drxk_state *state,\n\t\t\t\tstruct drxk_cfg_dvbt_echo_thres_t *echo_thres)\n{\n\tu16 data = 0;\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\tstatus = read16(state, OFDM_SC_RA_RAM_ECHO_THRES__A, &data);\n\tif (status < 0)\n\t\tgoto error;\n\n\tswitch (echo_thres->fft_mode) {\n\tcase DRX_FFTMODE_2K:\n\t\tdata &= ~OFDM_SC_RA_RAM_ECHO_THRES_2K__M;\n\t\tdata |= ((echo_thres->threshold <<\n\t\t\tOFDM_SC_RA_RAM_ECHO_THRES_2K__B)\n\t\t\t& (OFDM_SC_RA_RAM_ECHO_THRES_2K__M));\n\t\tbreak;\n\tcase DRX_FFTMODE_8K:\n\t\tdata &= ~OFDM_SC_RA_RAM_ECHO_THRES_8K__M;\n\t\tdata |= ((echo_thres->threshold <<\n\t\t\tOFDM_SC_RA_RAM_ECHO_THRES_8K__B)\n\t\t\t& (OFDM_SC_RA_RAM_ECHO_THRES_8K__M));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = write16(state, OFDM_SC_RA_RAM_ECHO_THRES__A, data);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int dvbt_ctrl_set_sqi_speed(struct drxk_state *state,\n\t\t\t       enum drxk_cfg_dvbt_sqi_speed *speed)\n{\n\tint status = -EINVAL;\n\n\tdprintk(1, \"\\n\");\n\n\tswitch (*speed) {\n\tcase DRXK_DVBT_SQI_SPEED_FAST:\n\tcase DRXK_DVBT_SQI_SPEED_MEDIUM:\n\tcase DRXK_DVBT_SQI_SPEED_SLOW:\n\t\tbreak;\n\tdefault:\n\t\tgoto error;\n\t}\n\tstatus = write16(state, SCU_RAM_FEC_PRE_RS_BER_FILTER_SH__A,\n\t\t\t   (u16) *speed);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\n \n\n \nstatic int dvbt_activate_presets(struct drxk_state *state)\n{\n\tint status;\n\tbool setincenable = false;\n\tbool setfrenable = true;\n\n\tstruct drxk_cfg_dvbt_echo_thres_t echo_thres2k = { 0, DRX_FFTMODE_2K };\n\tstruct drxk_cfg_dvbt_echo_thres_t echo_thres8k = { 0, DRX_FFTMODE_8K };\n\n\tdprintk(1, \"\\n\");\n\tstatus = dvbt_ctrl_set_inc_enable(state, &setincenable);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = dvbt_ctrl_set_fr_enable(state, &setfrenable);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = dvbt_ctrl_set_echo_threshold(state, &echo_thres2k);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = dvbt_ctrl_set_echo_threshold(state, &echo_thres8k);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_AGC_INGAIN_TGT_MAX__A,\n\t\t\t state->m_dvbt_if_agc_cfg.ingain_tgt_max);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\n \n\n \nstatic int set_dvbt_standard(struct drxk_state *state,\n\t\t\t   enum operation_mode o_mode)\n{\n\tu16 cmd_result = 0;\n\tu16 data = 0;\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\n\tpower_up_dvbt(state);\n\t \n\tswitch_antenna_to_dvbt(state);\n\t \n\tstatus = scu_command(state,\n\t\t\t     SCU_RAM_COMMAND_STANDARD_OFDM\n\t\t\t     | SCU_RAM_COMMAND_CMD_DEMOD_RESET,\n\t\t\t     0, NULL, 1, &cmd_result);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM\n\t\t\t     | SCU_RAM_COMMAND_CMD_DEMOD_SET_ENV,\n\t\t\t     0, NULL, 1, &cmd_result);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, OFDM_SC_COMM_EXEC__A, OFDM_SC_COMM_EXEC_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, OFDM_LC_COMM_EXEC__A, OFDM_LC_COMM_EXEC_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\t \n\tstatus = write16(state, IQM_AF_UPD_SEL__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\tstatus = write16(state, IQM_AF_CLP_LEN__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\tstatus = write16(state, IQM_AF_SNS_LEN__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\tstatus = write16(state, IQM_AF_AMUX__A, IQM_AF_AMUX_SIGNAL2ADC);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = set_iqm_af(state, true);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, IQM_AF_AGC_RF__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, IQM_AF_INC_LCT__A, 0);\t \n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_DET_LCT__A, 0);\t \n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_WND_LEN__A, 3);\t \n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, IQM_RC_STRETCH__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_OUT_ENA__A, 0x4);  \n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_DS_ENA__A, 0x4);\t \n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_SCALE__A, 1600);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_SCALE_SH__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, IQM_AF_CLP_TH__A, 448);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_DATATH__A, 495);\t \n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = bl_chain_cmd(state, DRXK_BL_ROM_OFFSET_TAPS_DVBT,\n\t\t\t      DRXK_BLCC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, IQM_CF_PKDTH__A, 2);\t \n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_POW_MEAS_LEN__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\tstatus = write16(state, IQM_CF_COMM_INT_MSK__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_ACTIVE);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = adc_synchronization(state);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = set_pre_saw(state, &state->m_dvbt_pre_saw_cfg);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = set_agc_rf(state, &state->m_dvbt_rf_agc_cfg, true);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = set_agc_if(state, &state->m_dvbt_if_agc_cfg, true);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = read16(state, OFDM_SC_RA_RAM_CONFIG__A, &data);\n\tif (status < 0)\n\t\tgoto error;\n\tdata |= OFDM_SC_RA_RAM_CONFIG_NE_FIX_ENABLE__M;\n\tstatus = write16(state, OFDM_SC_RA_RAM_CONFIG__A, data);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);\n\tif (status < 0)\n\t\tgoto error;\n\n\tif (!state->m_drxk_a3_rom_code) {\n\t\t \n\t\tstatus = write16(state, SCU_RAM_AGC_FAST_CLP_CTRL_DELAY__A,\n\t\t\t\t state->m_dvbt_if_agc_cfg.fast_clip_ctrl_delay);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t}\n\n\t \n#ifdef COMPILE_FOR_NONRT\n\tstatus = write16(state, OFDM_SC_RA_RAM_BE_OPT_DELAY__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, OFDM_SC_RA_RAM_BE_OPT_INIT_DELAY__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n#endif\n\n\t \n\tstatus = write16(state, FEC_DI_INPUT_CTL__A, 1);\t \n\tif (status < 0)\n\t\tgoto error;\n\n\n#ifdef COMPILE_FOR_NONRT\n\tstatus = write16(state, FEC_RS_MEASUREMENT_PERIOD__A, 0x400);\n\tif (status < 0)\n\t\tgoto error;\n#else\n\tstatus = write16(state, FEC_RS_MEASUREMENT_PERIOD__A, 0x1000);\n\tif (status < 0)\n\t\tgoto error;\n#endif\n\tstatus = write16(state, FEC_RS_MEASUREMENT_PRESCALE__A, 0x0001);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = mpegts_dto_setup(state, OM_DVBT);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\tstatus = dvbt_activate_presets(state);\n\tif (status < 0)\n\t\tgoto error;\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\n \n \nstatic int dvbt_start(struct drxk_state *state)\n{\n\tu16 param1;\n\tint status;\n\t \n\n\tdprintk(1, \"\\n\");\n\t \n\t \n\tparam1 = OFDM_SC_RA_RAM_LOCKTRACK_MIN;\n\tstatus = dvbt_sc_command(state, OFDM_SC_RA_RAM_CMD_PROC_START, 0,\n\t\t\t\t OFDM_SC_RA_RAM_SW_EVENT_RUN_NMASK__M, param1,\n\t\t\t\t 0, 0, 0);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\tstatus = mpegts_start(state);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_COMM_EXEC__A, FEC_COMM_EXEC_ACTIVE);\n\tif (status < 0)\n\t\tgoto error;\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\n\n \n\n \nstatic int set_dvbt(struct drxk_state *state, u16 intermediate_freqk_hz,\n\t\t   s32 tuner_freq_offset)\n{\n\tu16 cmd_result = 0;\n\tu16 transmission_params = 0;\n\tu32 iqm_rc_rate_ofs = 0;\n\tu32 bandwidth = 0;\n\tu16 param1;\n\tint status;\n\n\tdprintk(1, \"IF =%d, TFO = %d\\n\",\n\t\tintermediate_freqk_hz, tuner_freq_offset);\n\n\tstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM\n\t\t\t    | SCU_RAM_COMMAND_CMD_DEMOD_STOP,\n\t\t\t    0, NULL, 1, &cmd_result);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, OFDM_SC_COMM_EXEC__A, OFDM_SC_COMM_EXEC_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, OFDM_LC_COMM_EXEC__A, OFDM_LC_COMM_EXEC_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, OFDM_CP_COMM_EXEC__A, OFDM_CP_COMM_EXEC_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\n\t \n\tswitch (state->props.transmission_mode) {\n\tcase TRANSMISSION_MODE_AUTO:\n\tcase TRANSMISSION_MODE_8K:\n\tdefault:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_MODE_8K;\n\t\tbreak;\n\tcase TRANSMISSION_MODE_2K:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_MODE_2K;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (state->props.guard_interval) {\n\tdefault:\n\tcase GUARD_INTERVAL_AUTO:  \n\tcase GUARD_INTERVAL_1_4:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_4;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_32:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_32;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_16:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_16;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_8:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_8;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (state->props.hierarchy) {\n\tcase HIERARCHY_AUTO:\n\tcase HIERARCHY_NONE:\n\tdefault:\t \n\tcase HIERARCHY_1:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_HIER_A1;\n\t\tbreak;\n\tcase HIERARCHY_2:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_HIER_A2;\n\t\tbreak;\n\tcase HIERARCHY_4:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_HIER_A4;\n\t\tbreak;\n\t}\n\n\n\t \n\tswitch (state->props.modulation) {\n\tcase QAM_AUTO:\n\tdefault:\t \n\tcase QAM_64:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QAM64;\n\t\tbreak;\n\tcase QPSK:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QPSK;\n\t\tbreak;\n\tcase QAM_16:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QAM16;\n\t\tbreak;\n\t}\n#if 0\n\t \n\t \n\tswitch (channel->priority) {\n\tcase DRX_PRIORITY_LOW:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_PRIO_LO;\n\t\tWR16(dev_addr, OFDM_EC_SB_PRIOR__A,\n\t\t\tOFDM_EC_SB_PRIOR_LO);\n\t\tbreak;\n\tcase DRX_PRIORITY_HIGH:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_PRIO_HI;\n\t\tWR16(dev_addr, OFDM_EC_SB_PRIOR__A,\n\t\t\tOFDM_EC_SB_PRIOR_HI));\n\t\tbreak;\n\tcase DRX_PRIORITY_UNKNOWN:\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tgoto error;\n\t}\n#else\n\t \n\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_PRIO_HI;\n\tstatus = write16(state, OFDM_EC_SB_PRIOR__A, OFDM_EC_SB_PRIOR_HI);\n\tif (status < 0)\n\t\tgoto error;\n#endif\n\n\t \n\tswitch (state->props.code_rate_HP) {\n\tcase FEC_AUTO:\n\tdefault:\t \n\tcase FEC_2_3:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_RATE_2_3;\n\t\tbreak;\n\tcase FEC_1_2:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_RATE_1_2;\n\t\tbreak;\n\tcase FEC_3_4:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_RATE_3_4;\n\t\tbreak;\n\tcase FEC_5_6:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_RATE_5_6;\n\t\tbreak;\n\tcase FEC_7_8:\n\t\ttransmission_params |= OFDM_SC_RA_RAM_OP_PARAM_RATE_7_8;\n\t\tbreak;\n\t}\n\n\t \n\n\t \n\t \n\t \n\tswitch (state->props.bandwidth_hz) {\n\tcase 0:\n\t\tstate->props.bandwidth_hz = 8000000;\n\t\tfallthrough;\n\tcase 8000000:\n\t\tbandwidth = DRXK_BANDWIDTH_8MHZ_IN_HZ;\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A,\n\t\t\t\t 3052);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\t \n\t\tstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A,\n\t\t\t\t 7);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A,\n\t\t\t\t 7);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A,\n\t\t\t\t 7);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A,\n\t\t\t\t 1);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase 7000000:\n\t\tbandwidth = DRXK_BANDWIDTH_7MHZ_IN_HZ;\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A,\n\t\t\t\t 3491);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\t \n\t\tstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A,\n\t\t\t\t 8);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A,\n\t\t\t\t 8);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A,\n\t\t\t\t 4);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A,\n\t\t\t\t 1);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase 6000000:\n\t\tbandwidth = DRXK_BANDWIDTH_6MHZ_IN_HZ;\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A,\n\t\t\t\t 4073);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\t \n\t\tstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A,\n\t\t\t\t 19);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A,\n\t\t\t\t 19);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A,\n\t\t\t\t 14);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A,\n\t\t\t\t 1);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (iqm_rc_rate_ofs == 0) {\n\t\t \n\t\t \n\t\t \n\t\tiqm_rc_rate_ofs = Frac28a((u32)\n\t\t\t\t\t((state->m_sys_clock_freq *\n\t\t\t\t\t\t1000) / 3), bandwidth);\n\t\t \n\t\tif ((iqm_rc_rate_ofs & 0x7fL) >= 0x40)\n\t\t\tiqm_rc_rate_ofs += 0x80L;\n\t\tiqm_rc_rate_ofs = iqm_rc_rate_ofs >> 7;\n\t\t \n\t\tiqm_rc_rate_ofs = iqm_rc_rate_ofs - (1 << 23);\n\t}\n\n\tiqm_rc_rate_ofs &=\n\t\t((((u32) IQM_RC_RATE_OFS_HI__M) <<\n\t\tIQM_RC_RATE_OFS_LO__W) | IQM_RC_RATE_OFS_LO__M);\n\tstatus = write32(state, IQM_RC_RATE_OFS_LO__A, iqm_rc_rate_ofs);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\n#if 0\n\tstatus = dvbt_set_frequency_shift(demod, channel, tuner_offset);\n\tif (status < 0)\n\t\tgoto error;\n#endif\n\tstatus = set_frequency_shifter(state, intermediate_freqk_hz,\n\t\t\t\t       tuner_freq_offset, true);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\n\t \n\tstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, OFDM_SC_COMM_STATE__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, OFDM_SC_COMM_EXEC__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\tstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM\n\t\t\t     | SCU_RAM_COMMAND_CMD_DEMOD_START,\n\t\t\t     0, NULL, 1, &cmd_result);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tparam1 = (OFDM_SC_RA_RAM_OP_AUTO_MODE__M |\n\t\t\tOFDM_SC_RA_RAM_OP_AUTO_GUARD__M |\n\t\t\tOFDM_SC_RA_RAM_OP_AUTO_CONST__M |\n\t\t\tOFDM_SC_RA_RAM_OP_AUTO_HIER__M |\n\t\t\tOFDM_SC_RA_RAM_OP_AUTO_RATE__M);\n\tstatus = dvbt_sc_command(state, OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM,\n\t\t\t\t0, transmission_params, param1, 0, 0, 0);\n\tif (status < 0)\n\t\tgoto error;\n\n\tif (!state->m_drxk_a3_rom_code)\n\t\tstatus = dvbt_ctrl_set_sqi_speed(state, &state->m_sqi_speed);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\n\n \n\n \nstatic int get_dvbt_lock_status(struct drxk_state *state, u32 *p_lock_status)\n{\n\tint status;\n\tconst u16 mpeg_lock_mask = (OFDM_SC_RA_RAM_LOCK_MPEG__M |\n\t\t\t\t    OFDM_SC_RA_RAM_LOCK_FEC__M);\n\tconst u16 fec_lock_mask = (OFDM_SC_RA_RAM_LOCK_FEC__M);\n\tconst u16 demod_lock_mask = OFDM_SC_RA_RAM_LOCK_DEMOD__M;\n\n\tu16 sc_ra_ram_lock = 0;\n\tu16 sc_comm_exec = 0;\n\n\tdprintk(1, \"\\n\");\n\n\t*p_lock_status = NOT_LOCKED;\n\t \n\t \n\tstatus = read16(state, OFDM_SC_COMM_EXEC__A, &sc_comm_exec);\n\tif (status < 0)\n\t\tgoto end;\n\tif (sc_comm_exec == OFDM_SC_COMM_EXEC_STOP)\n\t\tgoto end;\n\n\tstatus = read16(state, OFDM_SC_RA_RAM_LOCK__A, &sc_ra_ram_lock);\n\tif (status < 0)\n\t\tgoto end;\n\n\tif ((sc_ra_ram_lock & mpeg_lock_mask) == mpeg_lock_mask)\n\t\t*p_lock_status = MPEG_LOCK;\n\telse if ((sc_ra_ram_lock & fec_lock_mask) == fec_lock_mask)\n\t\t*p_lock_status = FEC_LOCK;\n\telse if ((sc_ra_ram_lock & demod_lock_mask) == demod_lock_mask)\n\t\t*p_lock_status = DEMOD_LOCK;\n\telse if (sc_ra_ram_lock & OFDM_SC_RA_RAM_LOCK_NODVBT__M)\n\t\t*p_lock_status = NEVER_LOCK;\nend:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\nstatic int power_up_qam(struct drxk_state *state)\n{\n\tenum drx_power_mode power_mode = DRXK_POWER_DOWN_OFDM;\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\tstatus = ctrl_power_mode(state, &power_mode);\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\n\n \nstatic int power_down_qam(struct drxk_state *state)\n{\n\tu16 data = 0;\n\tu16 cmd_result;\n\tint status = 0;\n\n\tdprintk(1, \"\\n\");\n\tstatus = read16(state, SCU_COMM_EXEC__A, &data);\n\tif (status < 0)\n\t\tgoto error;\n\tif (data == SCU_COMM_EXEC_ACTIVE) {\n\t\t \n\t\t \n\t\tstatus = write16(state, QAM_COMM_EXEC__A, QAM_COMM_EXEC_STOP);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM\n\t\t\t\t     | SCU_RAM_COMMAND_CMD_DEMOD_STOP,\n\t\t\t\t     0, NULL, 1, &cmd_result);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t}\n\t \n\tstatus = set_iqm_af(state, false);\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\n \n\n \nstatic int set_qam_measurement(struct drxk_state *state,\n\t\t\t     enum e_drxk_constellation modulation,\n\t\t\t     u32 symbol_rate)\n{\n\tu32 fec_bits_desired = 0;\t \n\tu32 fec_rs_period_total = 0;\t \n\tu16 fec_rs_prescale = 0;\t \n\tu16 fec_rs_period = 0;\t \n\tint status = 0;\n\n\tdprintk(1, \"\\n\");\n\n\tfec_rs_prescale = 1;\n\t \n\tswitch (modulation) {\n\tcase DRX_CONSTELLATION_QAM16:\n\t\tfec_bits_desired = 4 * symbol_rate;\n\t\tbreak;\n\tcase DRX_CONSTELLATION_QAM32:\n\t\tfec_bits_desired = 5 * symbol_rate;\n\t\tbreak;\n\tcase DRX_CONSTELLATION_QAM64:\n\t\tfec_bits_desired = 6 * symbol_rate;\n\t\tbreak;\n\tcase DRX_CONSTELLATION_QAM128:\n\t\tfec_bits_desired = 7 * symbol_rate;\n\t\tbreak;\n\tcase DRX_CONSTELLATION_QAM256:\n\t\tfec_bits_desired = 8 * symbol_rate;\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t}\n\tif (status < 0)\n\t\tgoto error;\n\n\tfec_bits_desired /= 1000;\t \n\tfec_bits_desired *= 500;\t \n\n\t \n\t \n\tfec_rs_period_total = (fec_bits_desired / 1632UL) + 1;\t \n\n\t \n\tfec_rs_prescale = 1 + (u16) (fec_rs_period_total >> 16);\n\tif (fec_rs_prescale == 0) {\n\t\t \n\t\tstatus = -EINVAL;\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t}\n\tfec_rs_period =\n\t\t((u16) fec_rs_period_total +\n\t\t(fec_rs_prescale >> 1)) / fec_rs_prescale;\n\n\t \n\tstatus = write16(state, FEC_RS_MEASUREMENT_PERIOD__A, fec_rs_period);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_RS_MEASUREMENT_PRESCALE__A,\n\t\t\t fec_rs_prescale);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_OC_SNC_FAIL_PERIOD__A, fec_rs_period);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int set_qam16(struct drxk_state *state)\n{\n\tint status = 0;\n\n\tdprintk(1, \"\\n\");\n\t \n\t \n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 13517);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 13517);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 13517);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 13517);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 13517);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 13517);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\tstatus = write16(state, QAM_DQ_QUAL_FUN0__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN1__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN2__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN3__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN4__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN5__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, QAM_SY_SYNC_HWM__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_SY_SYNC_AWM__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_SY_SYNC_LWM__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A,\n\t\t\t DRXK_QAM_SL_SIG_POWER_QAM16);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 20);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 80);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 20);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 50);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 32);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 10);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RTH__A, 140);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_FTH__A, 50);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_CTH__A, 95);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_PTH__A, 120);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_QTH__A, 230);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_MTH__A, 105);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 24);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 220);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 25);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 6);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -24);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -65);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -127);\n\tif (status < 0)\n\t\tgoto error;\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\n \n\n \nstatic int set_qam32(struct drxk_state *state)\n{\n\tint status = 0;\n\n\tdprintk(1, \"\\n\");\n\n\t \n\t \n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 6707);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 6707);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 6707);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 6707);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 6707);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 6707);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, QAM_DQ_QUAL_FUN0__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN1__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN2__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN3__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN4__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN5__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, QAM_SY_SYNC_HWM__A, 6);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_SY_SYNC_AWM__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_SY_SYNC_LWM__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A,\n\t\t\t DRXK_QAM_SL_SIG_POWER_QAM32);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 20);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 80);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 20);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 50);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RTH__A, 90);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_FTH__A, 50);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_PTH__A, 100);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_QTH__A, 170);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_MTH__A, 100);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 10);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 140);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) -8);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) -16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -26);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -56);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -86);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\n \n\n \nstatic int set_qam64(struct drxk_state *state)\n{\n\tint status = 0;\n\n\tdprintk(1, \"\\n\");\n\t \n\t \n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 13336);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 12618);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 11988);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 13809);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 13809);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 15609);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, QAM_DQ_QUAL_FUN0__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN1__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN2__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN3__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN4__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN5__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, QAM_SY_SYNC_HWM__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_SY_SYNC_AWM__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_SY_SYNC_LWM__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A,\n\t\t\t DRXK_QAM_SL_SIG_POWER_QAM64);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 30);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 100);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 30);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 50);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 25);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 48);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 10);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RTH__A, 100);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_FTH__A, 60);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_PTH__A, 110);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_QTH__A, 200);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_MTH__A, 95);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 15);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 141);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 7);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -15);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -45);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -80);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\n \n\n \nstatic int set_qam128(struct drxk_state *state)\n{\n\tint status = 0;\n\n\tdprintk(1, \"\\n\");\n\t \n\t \n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 6564);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 6598);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 6394);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 6409);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 6656);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 7238);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, QAM_DQ_QUAL_FUN0__A, 6);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN1__A, 6);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN2__A, 6);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN3__A, 6);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN4__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN5__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, QAM_SY_SYNC_HWM__A, 6);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_SY_SYNC_AWM__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_SY_SYNC_LWM__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A,\n\t\t\t DRXK_QAM_SL_SIG_POWER_QAM128);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 40);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 120);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 40);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 60);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 25);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 64);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RTH__A, 50);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_FTH__A, 60);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_PTH__A, 100);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_QTH__A, 140);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_MTH__A, 100);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 12);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 8);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 65);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 3);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -23);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\n \n\n \nstatic int set_qam256(struct drxk_state *state)\n{\n\tint status = 0;\n\n\tdprintk(1, \"\\n\");\n\t \n\t \n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 11502);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 12084);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 12543);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 12931);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 13629);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 15385);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, QAM_DQ_QUAL_FUN0__A, 8);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN1__A, 8);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN2__A, 8);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN3__A, 8);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN4__A, 6);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_DQ_QUAL_FUN5__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, QAM_SY_SYNC_HWM__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_SY_SYNC_AWM__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_SY_SYNC_LWM__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A,\n\t\t\t DRXK_QAM_SL_SIG_POWER_QAM256);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 50);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 250);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 50);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 125);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 25);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 48);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 10);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RTH__A, 50);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_FTH__A, 60);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_PTH__A, 100);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_QTH__A, 150);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_MTH__A, 110);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 12);\n\tif (status < 0)\n\t\tgoto error;\n\n\n\t \n\n\tstatus = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 8);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 74);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 18);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 13);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) 7);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -8);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\n\n \n \nstatic int qam_reset_qam(struct drxk_state *state)\n{\n\tint status;\n\tu16 cmd_result;\n\n\tdprintk(1, \"\\n\");\n\t \n\tstatus = write16(state, QAM_COMM_EXEC__A, QAM_COMM_EXEC_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM\n\t\t\t     | SCU_RAM_COMMAND_CMD_DEMOD_RESET,\n\t\t\t     0, NULL, 1, &cmd_result);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\n \n\n \nstatic int qam_set_symbolrate(struct drxk_state *state)\n{\n\tu32 adc_frequency = 0;\n\tu32 symb_freq = 0;\n\tu32 iqm_rc_rate = 0;\n\tu16 ratesel = 0;\n\tu32 lc_symb_rate = 0;\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\t \n\tadc_frequency = (state->m_sys_clock_freq * 1000) / 3;\n\tratesel = 0;\n\tif (state->props.symbol_rate <= 1188750)\n\t\tratesel = 3;\n\telse if (state->props.symbol_rate <= 2377500)\n\t\tratesel = 2;\n\telse if (state->props.symbol_rate <= 4755000)\n\t\tratesel = 1;\n\tstatus = write16(state, IQM_FD_RATESEL__A, ratesel);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tsymb_freq = state->props.symbol_rate * (1 << ratesel);\n\tif (symb_freq == 0) {\n\t\t \n\t\tstatus = -EINVAL;\n\t\tgoto error;\n\t}\n\tiqm_rc_rate = (adc_frequency / symb_freq) * (1 << 21) +\n\t\t(Frac28a((adc_frequency % symb_freq), symb_freq) >> 7) -\n\t\t(1 << 23);\n\tstatus = write32(state, IQM_RC_RATE_OFS_LO__A, iqm_rc_rate);\n\tif (status < 0)\n\t\tgoto error;\n\tstate->m_iqm_rc_rate = iqm_rc_rate;\n\t \n\tsymb_freq = state->props.symbol_rate;\n\tif (adc_frequency == 0) {\n\t\t \n\t\tstatus = -EINVAL;\n\t\tgoto error;\n\t}\n\tlc_symb_rate = (symb_freq / adc_frequency) * (1 << 12) +\n\t\t(Frac28a((symb_freq % adc_frequency), adc_frequency) >>\n\t\t16);\n\tif (lc_symb_rate > 511)\n\t\tlc_symb_rate = 511;\n\tstatus = write16(state, QAM_LC_SYMBOL_FREQ__A, (u16) lc_symb_rate);\n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\n \n\n \n\nstatic int get_qam_lock_status(struct drxk_state *state, u32 *p_lock_status)\n{\n\tint status;\n\tu16 result[2] = { 0, 0 };\n\n\tdprintk(1, \"\\n\");\n\t*p_lock_status = NOT_LOCKED;\n\tstatus = scu_command(state,\n\t\t\tSCU_RAM_COMMAND_STANDARD_QAM |\n\t\t\tSCU_RAM_COMMAND_CMD_DEMOD_GET_LOCK, 0, NULL, 2,\n\t\t\tresult);\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\tif (result[1] < SCU_RAM_QAM_LOCKED_LOCKED_DEMOD_LOCKED) {\n\t\t \n\t} else if (result[1] < SCU_RAM_QAM_LOCKED_LOCKED_LOCKED) {\n\t\t \n\t\t*p_lock_status = DEMOD_LOCK;\n\t} else if (result[1] < SCU_RAM_QAM_LOCKED_LOCKED_NEVER_LOCK) {\n\t\t \n\t\t*p_lock_status = MPEG_LOCK;\n\t} else {\n\t\t \n\t\t \n\t\t \n\t\t*p_lock_status = NEVER_LOCK;\n\t}\n\treturn status;\n}\n\n#define QAM_MIRROR__M         0x03\n#define QAM_MIRROR_NORMAL     0x00\n#define QAM_MIRRORED          0x01\n#define QAM_MIRROR_AUTO_ON    0x02\n#define QAM_LOCKRANGE__M      0x10\n#define QAM_LOCKRANGE_NORMAL  0x10\n\nstatic int qam_demodulator_command(struct drxk_state *state,\n\t\t\t\t int number_of_parameters)\n{\n\tint status;\n\tu16 cmd_result;\n\tu16 set_param_parameters[4] = { 0, 0, 0, 0 };\n\n\tset_param_parameters[0] = state->m_constellation;\t \n\tset_param_parameters[1] = DRXK_QAM_I12_J17;\t \n\n\tif (number_of_parameters == 2) {\n\t\tu16 set_env_parameters[1] = { 0 };\n\n\t\tif (state->m_operation_mode == OM_QAM_ITU_C)\n\t\t\tset_env_parameters[0] = QAM_TOP_ANNEX_C;\n\t\telse\n\t\t\tset_env_parameters[0] = QAM_TOP_ANNEX_A;\n\n\t\tstatus = scu_command(state,\n\t\t\t\t     SCU_RAM_COMMAND_STANDARD_QAM\n\t\t\t\t     | SCU_RAM_COMMAND_CMD_DEMOD_SET_ENV,\n\t\t\t\t     1, set_env_parameters, 1, &cmd_result);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tstatus = scu_command(state,\n\t\t\t\t     SCU_RAM_COMMAND_STANDARD_QAM\n\t\t\t\t     | SCU_RAM_COMMAND_CMD_DEMOD_SET_PARAM,\n\t\t\t\t     number_of_parameters, set_param_parameters,\n\t\t\t\t     1, &cmd_result);\n\t} else if (number_of_parameters == 4) {\n\t\tif (state->m_operation_mode == OM_QAM_ITU_C)\n\t\t\tset_param_parameters[2] = QAM_TOP_ANNEX_C;\n\t\telse\n\t\t\tset_param_parameters[2] = QAM_TOP_ANNEX_A;\n\n\t\tset_param_parameters[3] |= (QAM_MIRROR_AUTO_ON);\n\t\t \n\t\t \n\t\t \n\n\t\tstatus = scu_command(state,\n\t\t\t\t     SCU_RAM_COMMAND_STANDARD_QAM\n\t\t\t\t     | SCU_RAM_COMMAND_CMD_DEMOD_SET_PARAM,\n\t\t\t\t     number_of_parameters, set_param_parameters,\n\t\t\t\t     1, &cmd_result);\n\t} else {\n\t\tpr_warn(\"Unknown QAM demodulator parameter count %d\\n\",\n\t\t\tnumber_of_parameters);\n\t\tstatus = -EINVAL;\n\t}\n\nerror:\n\tif (status < 0)\n\t\tpr_warn(\"Warning %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int set_qam(struct drxk_state *state, u16 intermediate_freqk_hz,\n\t\t  s32 tuner_freq_offset)\n{\n\tint status;\n\tu16 cmd_result;\n\tint qam_demod_param_count = state->qam_demod_parameter_count;\n\n\tdprintk(1, \"\\n\");\n\t \n\tstatus = write16(state, FEC_DI_COMM_EXEC__A, FEC_DI_COMM_EXEC_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_RS_COMM_EXEC__A, FEC_RS_COMM_EXEC_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = qam_reset_qam(state);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = qam_set_symbolrate(state);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tswitch (state->props.modulation) {\n\tcase QAM_256:\n\t\tstate->m_constellation = DRX_CONSTELLATION_QAM256;\n\t\tbreak;\n\tcase QAM_AUTO:\n\tcase QAM_64:\n\t\tstate->m_constellation = DRX_CONSTELLATION_QAM64;\n\t\tbreak;\n\tcase QAM_16:\n\t\tstate->m_constellation = DRX_CONSTELLATION_QAM16;\n\t\tbreak;\n\tcase QAM_32:\n\t\tstate->m_constellation = DRX_CONSTELLATION_QAM32;\n\t\tbreak;\n\tcase QAM_128:\n\t\tstate->m_constellation = DRX_CONSTELLATION_QAM128;\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tif (state->qam_demod_parameter_count == 4\n\t\t|| !state->qam_demod_parameter_count) {\n\t\tqam_demod_param_count = 4;\n\t\tstatus = qam_demodulator_command(state, qam_demod_param_count);\n\t}\n\n\t \n\tif (state->qam_demod_parameter_count == 2\n\t\t|| (!state->qam_demod_parameter_count && status < 0)) {\n\t\tqam_demod_param_count = 2;\n\t\tstatus = qam_demodulator_command(state, qam_demod_param_count);\n\t}\n\n\tif (status < 0) {\n\t\tdprintk(1, \"Could not set demodulator parameters.\\n\");\n\t\tdprintk(1,\n\t\t\t\"Make sure qam_demod_parameter_count (%d) is correct for your firmware (%s).\\n\",\n\t\t\tstate->qam_demod_parameter_count,\n\t\t\tstate->microcode_name);\n\t\tgoto error;\n\t} else if (!state->qam_demod_parameter_count) {\n\t\tdprintk(1,\n\t\t\t\"Auto-probing the QAM command parameters was successful - using %d parameters.\\n\",\n\t\t\tqam_demod_param_count);\n\n\t\t \n\t\tstate->qam_demod_parameter_count = qam_demod_param_count;\n\t}\n\n\t \n#if 0\n\tstatus = set_frequency(channel, tuner_freq_offset));\n\tif (status < 0)\n\t\tgoto error;\n#endif\n\tstatus = set_frequency_shifter(state, intermediate_freqk_hz,\n\t\t\t\t       tuner_freq_offset, true);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = set_qam_measurement(state, state->m_constellation,\n\t\t\t\t     state->props.symbol_rate);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, IQM_CF_SCALE_SH__A, IQM_CF_SCALE_SH__PRE);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_SY_TIMEOUT__A, QAM_SY_TIMEOUT__PRE);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, QAM_LC_RATE_LIMIT__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_LPF_FACTORP__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_LPF_FACTORI__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_MODE__A, 7);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, QAM_LC_QUAL_TAB0__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB1__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB2__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB3__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB4__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB5__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB6__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB8__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB9__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB10__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB12__A, 2);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB15__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB16__A, 3);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB20__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_LC_QUAL_TAB25__A, 4);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, QAM_SY_SP_INV__A,\n\t\t\t QAM_SY_SP_INV_SPECTRUM_INV_DIS);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tswitch (state->props.modulation) {\n\tcase QAM_16:\n\t\tstatus = set_qam16(state);\n\t\tbreak;\n\tcase QAM_32:\n\t\tstatus = set_qam32(state);\n\t\tbreak;\n\tcase QAM_AUTO:\n\tcase QAM_64:\n\t\tstatus = set_qam64(state);\n\t\tbreak;\n\tcase QAM_128:\n\t\tstatus = set_qam128(state);\n\t\tbreak;\n\tcase QAM_256:\n\t\tstatus = set_qam256(state);\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\t \n\t \n\tstatus = mpegts_dto_setup(state, state->m_operation_mode);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = mpegts_start(state);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, FEC_COMM_EXEC__A, FEC_COMM_EXEC_ACTIVE);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, QAM_COMM_EXEC__A, QAM_COMM_EXEC_ACTIVE);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_ACTIVE);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM\n\t\t\t     | SCU_RAM_COMMAND_CMD_DEMOD_START,\n\t\t\t     0, NULL, 1, &cmd_result);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n \n\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int set_qam_standard(struct drxk_state *state,\n\t\t\t  enum operation_mode o_mode)\n{\n\tint status;\n#ifdef DRXK_QAM_TAPS\n#define DRXK_QAMA_TAPS_SELECT\n#include \"drxk_filters.h\"\n#undef DRXK_QAMA_TAPS_SELECT\n#endif\n\n\tdprintk(1, \"\\n\");\n\n\t \n\tswitch_antenna_to_qam(state);\n\n\t \n\tstatus = power_up_qam(state);\n\tif (status < 0)\n\t\tgoto error;\n\t \n\tstatus = qam_reset_qam(state);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\n\tstatus = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_STOP);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_AF_AMUX__A, IQM_AF_AMUX_SIGNAL2ADC);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tswitch (o_mode) {\n\tcase OM_QAM_ITU_A:\n\t\tstatus = bl_chain_cmd(state, DRXK_BL_ROM_OFFSET_TAPS_ITU_A,\n\t\t\t\t      DRXK_BLCC_NR_ELEMENTS_TAPS,\n\t\t\tDRXK_BLC_TIMEOUT);\n\t\tbreak;\n\tcase OM_QAM_ITU_C:\n\t\tstatus = bl_direct_cmd(state, IQM_CF_TAP_RE0__A,\n\t\t\t\t       DRXK_BL_ROM_OFFSET_TAPS_ITU_C,\n\t\t\t\t       DRXK_BLDC_NR_ELEMENTS_TAPS,\n\t\t\t\t       DRXK_BLC_TIMEOUT);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = bl_direct_cmd(state,\n\t\t\t\t       IQM_CF_TAP_IM0__A,\n\t\t\t\t       DRXK_BL_ROM_OFFSET_TAPS_ITU_C,\n\t\t\t\t       DRXK_BLDC_NR_ELEMENTS_TAPS,\n\t\t\t\t       DRXK_BLC_TIMEOUT);\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t}\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, IQM_CF_OUT_ENA__A, 1 << IQM_CF_OUT_ENA_QAM__B);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_SYMMETRIC__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_MIDTAP__A,\n\t\t     ((1 << IQM_CF_MIDTAP_RE__B) | (1 << IQM_CF_MIDTAP_IM__B)));\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, IQM_RC_STRETCH__A, 21);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_AF_CLP_LEN__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_AF_CLP_TH__A, 448);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_AF_SNS_LEN__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_POW_MEAS_LEN__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, IQM_FS_ADJ_SEL__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_RC_ADJ_SEL__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_ADJ_SEL__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_AF_UPD_SEL__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, IQM_CF_CLP_VAL__A, 500);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_DATATH__A, 1000);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_BYPASSDET__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_DET_LCT__A, 0);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_WND_LEN__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_CF_PKDTH__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_AF_INC_BYPASS__A, 1);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = set_iqm_af(state, true);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, IQM_AF_START_LOCK__A, 0x01);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = adc_synchronization(state);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SCU_RAM_QAM_FSM_STEP_PERIOD__A, 2000);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\n\tstatus = init_agc(state, true);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = set_pre_saw(state, &(state->m_qam_pre_saw_cfg));\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = set_agc_rf(state, &(state->m_qam_rf_agc_cfg), true);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = set_agc_if(state, &(state->m_qam_if_agc_cfg), true);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int write_gpio(struct drxk_state *state)\n{\n\tint status;\n\tu16 value = 0;\n\n\tdprintk(1, \"\\n\");\n\t \n\tstatus = write16(state, SCU_RAM_GPIO__A,\n\t\t\t SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);\n\tif (status < 0)\n\t\tgoto error;\n\n\t \n\tstatus = write16(state, SIO_TOP_COMM_KEY__A, SIO_TOP_COMM_KEY_KEY);\n\tif (status < 0)\n\t\tgoto error;\n\n\tif (state->m_has_sawsw) {\n\t\tif (state->uio_mask & 0x0001) {  \n\t\t\t \n\t\t\tstatus = write16(state, SIO_PDR_SMA_TX_CFG__A,\n\t\t\t\t\t state->m_gpio_cfg);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tstatus = read16(state, SIO_PDR_UIO_OUT_LO__A, &value);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tif ((state->m_gpio & 0x0001) == 0)\n\t\t\t\tvalue &= 0x7FFF;\t \n\t\t\telse\n\t\t\t\tvalue |= 0x8000;\t \n\t\t\t \n\t\t\tstatus = write16(state, SIO_PDR_UIO_OUT_LO__A, value);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t\tif (state->uio_mask & 0x0002) {  \n\t\t\t \n\t\t\tstatus = write16(state, SIO_PDR_SMA_RX_CFG__A,\n\t\t\t\t\t state->m_gpio_cfg);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tstatus = read16(state, SIO_PDR_UIO_OUT_LO__A, &value);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tif ((state->m_gpio & 0x0002) == 0)\n\t\t\t\tvalue &= 0xBFFF;\t \n\t\t\telse\n\t\t\t\tvalue |= 0x4000;\t \n\t\t\t \n\t\t\tstatus = write16(state, SIO_PDR_UIO_OUT_LO__A, value);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t\tif (state->uio_mask & 0x0004) {  \n\t\t\t \n\t\t\tstatus = write16(state, SIO_PDR_GPIO_CFG__A,\n\t\t\t\t\t state->m_gpio_cfg);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tstatus = read16(state, SIO_PDR_UIO_OUT_LO__A, &value);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tif ((state->m_gpio & 0x0004) == 0)\n\t\t\t\tvalue &= 0xFFFB;             \n\t\t\telse\n\t\t\t\tvalue |= 0x0004;             \n\t\t\t \n\t\t\tstatus = write16(state, SIO_PDR_UIO_OUT_LO__A, value);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\t \n\tstatus = write16(state, SIO_TOP_COMM_KEY__A, 0x0000);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int switch_antenna_to_qam(struct drxk_state *state)\n{\n\tint status = 0;\n\tbool gpio_state;\n\n\tdprintk(1, \"\\n\");\n\n\tif (!state->antenna_gpio)\n\t\treturn 0;\n\n\tgpio_state = state->m_gpio & state->antenna_gpio;\n\n\tif (state->antenna_dvbt ^ gpio_state) {\n\t\t \n\t\tif (state->antenna_dvbt)\n\t\t\tstate->m_gpio &= ~state->antenna_gpio;\n\t\telse\n\t\t\tstate->m_gpio |= state->antenna_gpio;\n\t\tstatus = write_gpio(state);\n\t}\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\nstatic int switch_antenna_to_dvbt(struct drxk_state *state)\n{\n\tint status = 0;\n\tbool gpio_state;\n\n\tdprintk(1, \"\\n\");\n\n\tif (!state->antenna_gpio)\n\t\treturn 0;\n\n\tgpio_state = state->m_gpio & state->antenna_gpio;\n\n\tif (!(state->antenna_dvbt ^ gpio_state)) {\n\t\t \n\t\tif (state->antenna_dvbt)\n\t\t\tstate->m_gpio |= state->antenna_gpio;\n\t\telse\n\t\t\tstate->m_gpio &= ~state->antenna_gpio;\n\t\tstatus = write_gpio(state);\n\t}\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\treturn status;\n}\n\n\nstatic int power_down_device(struct drxk_state *state)\n{\n\t \n\t \n\t \n\t \n\t \n\t \n\tint status;\n\n\tdprintk(1, \"\\n\");\n\tif (state->m_b_p_down_open_bridge) {\n\t\t \n\t\tstatus = ConfigureI2CBridge(state, true);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t}\n\t \n\tstatus = dvbt_enable_ofdm_token_ring(state, false);\n\tif (status < 0)\n\t\tgoto error;\n\n\tstatus = write16(state, SIO_CC_PWD_MODE__A,\n\t\t\t SIO_CC_PWD_MODE_LEVEL_CLOCK);\n\tif (status < 0)\n\t\tgoto error;\n\tstatus = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);\n\tif (status < 0)\n\t\tgoto error;\n\tstate->m_hi_cfg_ctrl |= SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ;\n\tstatus = hi_cfg_command(state);\nerror:\n\tif (status < 0)\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\n\treturn status;\n}\n\nstatic int init_drxk(struct drxk_state *state)\n{\n\tint status = 0, n = 0;\n\tenum drx_power_mode power_mode = DRXK_POWER_DOWN_OFDM;\n\tu16 driver_version;\n\n\tdprintk(1, \"\\n\");\n\tif (state->m_drxk_state == DRXK_UNINITIALIZED) {\n\t\tdrxk_i2c_lock(state);\n\t\tstatus = power_up_device(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = drxx_open(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\t \n\t\tstatus = write16(state, SIO_CC_SOFT_RST__A,\n\t\t\t\t SIO_CC_SOFT_RST_OFDM__M\n\t\t\t\t | SIO_CC_SOFT_RST_SYS__M\n\t\t\t\t | SIO_CC_SOFT_RST_OSC__M);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\t \n\t\tusleep_range(1000, 2000);\n\t\tstate->m_drxk_a3_patch_code = true;\n\t\tstatus = get_device_capabilities(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\t \n\t\t \n\t\tstate->m_hi_cfg_bridge_delay =\n\t\t\t(u16) ((state->m_osc_clock_freq / 1000) *\n\t\t\t\tHI_I2C_BRIDGE_DELAY) / 1000;\n\t\t \n\t\tif (state->m_hi_cfg_bridge_delay >\n\t\t\tSIO_HI_RA_RAM_PAR_3_CFG_DBL_SDA__M) {\n\t\t\tstate->m_hi_cfg_bridge_delay =\n\t\t\t\tSIO_HI_RA_RAM_PAR_3_CFG_DBL_SDA__M;\n\t\t}\n\t\t \n\t\tstate->m_hi_cfg_bridge_delay +=\n\t\t\tstate->m_hi_cfg_bridge_delay <<\n\t\t\tSIO_HI_RA_RAM_PAR_3_CFG_DBL_SCL__B;\n\n\t\tstatus = init_hi(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\t \n#if NOA1ROM\n\t\tif (!(state->m_DRXK_A1_ROM_CODE)\n\t\t\t&& !(state->m_DRXK_A2_ROM_CODE))\n#endif\n\t\t{\n\t\t\tstatus = write16(state, SCU_RAM_GPIO__A,\n\t\t\t\t\t SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tstatus = mpegts_disable(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = write16(state, AUD_COMM_EXEC__A, AUD_COMM_EXEC_STOP);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_STOP);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = write16(state, SIO_OFDM_SH_OFDM_RING_ENABLE__A,\n\t\t\t\t SIO_OFDM_SH_OFDM_RING_ENABLE_ON);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = write16(state, SIO_BL_COMM_EXEC__A,\n\t\t\t\t SIO_BL_COMM_EXEC_ACTIVE);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = bl_chain_cmd(state, 0, 6, 100);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tif (state->fw) {\n\t\t\tstatus = download_microcode(state, state->fw->data,\n\t\t\t\t\t\t   state->fw->size);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tstatus = write16(state, SIO_OFDM_SH_OFDM_RING_ENABLE__A,\n\t\t\t\t SIO_OFDM_SH_OFDM_RING_ENABLE_OFF);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = drxx_open(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\t \n\t\tmsleep(30);\n\n\t\tpower_mode = DRXK_POWER_DOWN_OFDM;\n\t\tstatus = ctrl_power_mode(state, &power_mode);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tdriver_version =\n\t\t\t(((DRXK_VERSION_MAJOR / 100) % 10) << 12) +\n\t\t\t(((DRXK_VERSION_MAJOR / 10) % 10) << 8) +\n\t\t\t((DRXK_VERSION_MAJOR % 10) << 4) +\n\t\t\t(DRXK_VERSION_MINOR % 10);\n\t\tstatus = write16(state, SCU_RAM_DRIVER_VER_HI__A,\n\t\t\t\t driver_version);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tdriver_version =\n\t\t\t(((DRXK_VERSION_PATCH / 1000) % 10) << 12) +\n\t\t\t(((DRXK_VERSION_PATCH / 100) % 10) << 8) +\n\t\t\t(((DRXK_VERSION_PATCH / 10) % 10) << 4) +\n\t\t\t(DRXK_VERSION_PATCH % 10);\n\t\tstatus = write16(state, SCU_RAM_DRIVER_VER_LO__A,\n\t\t\t\t driver_version);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tpr_info(\"DRXK driver version %d.%d.%d\\n\",\n\t\t\tDRXK_VERSION_MAJOR, DRXK_VERSION_MINOR,\n\t\t\tDRXK_VERSION_PATCH);\n\n\t\t \n\n\t\t \n\n\t\t \n\t\tstatus = write16(state, SCU_RAM_DRIVER_DEBUG__A, 0);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\t \n\t\t \n\t\tstatus = write16(state, FEC_COMM_EXEC__A, FEC_COMM_EXEC_STOP);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\t \n\t\tstatus = mpegts_dto_init(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = mpegts_stop(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = mpegts_configure_polarity(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\tstatus = mpegts_configure_pins(state, state->m_enable_mpeg_output);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\t\t \n\t\tstatus = write_gpio(state);\n\t\tif (status < 0)\n\t\t\tgoto error;\n\n\t\tstate->m_drxk_state = DRXK_STOPPED;\n\n\t\tif (state->m_b_power_down) {\n\t\t\tstatus = power_down_device(state);\n\t\t\tif (status < 0)\n\t\t\t\tgoto error;\n\t\t\tstate->m_drxk_state = DRXK_POWERED_DOWN;\n\t\t} else\n\t\t\tstate->m_drxk_state = DRXK_STOPPED;\n\n\t\t \n\t\tn = 0;\n\t\tif (state->m_has_dvbc) {\n\t\t\tstate->frontend.ops.delsys[n++] = SYS_DVBC_ANNEX_A;\n\t\t\tstate->frontend.ops.delsys[n++] = SYS_DVBC_ANNEX_C;\n\t\t\tstrlcat(state->frontend.ops.info.name, \" DVB-C\",\n\t\t\t\tsizeof(state->frontend.ops.info.name));\n\t\t}\n\t\tif (state->m_has_dvbt) {\n\t\t\tstate->frontend.ops.delsys[n++] = SYS_DVBT;\n\t\t\tstrlcat(state->frontend.ops.info.name, \" DVB-T\",\n\t\t\t\tsizeof(state->frontend.ops.info.name));\n\t\t}\n\t\tdrxk_i2c_unlock(state);\n\t}\nerror:\n\tif (status < 0) {\n\t\tstate->m_drxk_state = DRXK_NO_DEV;\n\t\tdrxk_i2c_unlock(state);\n\t\tpr_err(\"Error %d on %s\\n\", status, __func__);\n\t}\n\n\treturn status;\n}\n\nstatic void load_firmware_cb(const struct firmware *fw,\n\t\t\t     void *context)\n{\n\tstruct drxk_state *state = context;\n\n\tdprintk(1, \": %s\\n\", fw ? \"firmware loaded\" : \"firmware not loaded\");\n\tif (!fw) {\n\t\tpr_err(\"Could not load firmware file %s.\\n\",\n\t\t\tstate->microcode_name);\n\t\tpr_info(\"Copy %s to your hotplug directory!\\n\",\n\t\t\tstate->microcode_name);\n\t\tstate->microcode_name = NULL;\n\n\t\t \n\t}\n\tstate->fw = fw;\n\n\tinit_drxk(state);\n}\n\nstatic void drxk_release(struct dvb_frontend *fe)\n{\n\tstruct drxk_state *state = fe->demodulator_priv;\n\n\tdprintk(1, \"\\n\");\n\trelease_firmware(state->fw);\n\n\tkfree(state);\n}\n\nstatic int drxk_sleep(struct dvb_frontend *fe)\n{\n\tstruct drxk_state *state = fe->demodulator_priv;\n\n\tdprintk(1, \"\\n\");\n\n\tif (state->m_drxk_state == DRXK_NO_DEV)\n\t\treturn -ENODEV;\n\tif (state->m_drxk_state == DRXK_UNINITIALIZED)\n\t\treturn 0;\n\n\tshut_down(state);\n\treturn 0;\n}\n\nstatic int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct drxk_state *state = fe->demodulator_priv;\n\n\tdprintk(1, \": %s\\n\", enable ? \"enable\" : \"disable\");\n\n\tif (state->m_drxk_state == DRXK_NO_DEV)\n\t\treturn -ENODEV;\n\n\treturn ConfigureI2CBridge(state, enable ? true : false);\n}\n\nstatic int drxk_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 delsys  = p->delivery_system, old_delsys;\n\tstruct drxk_state *state = fe->demodulator_priv;\n\tu32 IF;\n\n\tdprintk(1, \"\\n\");\n\n\tif (state->m_drxk_state == DRXK_NO_DEV)\n\t\treturn -ENODEV;\n\n\tif (state->m_drxk_state == DRXK_UNINITIALIZED)\n\t\treturn -EAGAIN;\n\n\tif (!fe->ops.tuner_ops.get_if_frequency) {\n\t\tpr_err(\"Error: get_if_frequency() not defined at tuner. Can't work without it!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\told_delsys = state->props.delivery_system;\n\tstate->props = *p;\n\n\tif (old_delsys != delsys) {\n\t\tshut_down(state);\n\t\tswitch (delsys) {\n\t\tcase SYS_DVBC_ANNEX_A:\n\t\tcase SYS_DVBC_ANNEX_C:\n\t\t\tif (!state->m_has_dvbc)\n\t\t\t\treturn -EINVAL;\n\t\t\tstate->m_itut_annex_c = (delsys == SYS_DVBC_ANNEX_C) ?\n\t\t\t\t\t\ttrue : false;\n\t\t\tif (state->m_itut_annex_c)\n\t\t\t\tsetoperation_mode(state, OM_QAM_ITU_C);\n\t\t\telse\n\t\t\t\tsetoperation_mode(state, OM_QAM_ITU_A);\n\t\t\tbreak;\n\t\tcase SYS_DVBT:\n\t\t\tif (!state->m_has_dvbt)\n\t\t\t\treturn -EINVAL;\n\t\t\tsetoperation_mode(state, OM_DVBT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfe->ops.tuner_ops.get_if_frequency(fe, &IF);\n\tstart(state, 0, IF);\n\n\t \n\tp->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\t \n\n\treturn 0;\n}\n\nstatic int get_strength(struct drxk_state *state, u64 *strength)\n{\n\tint status;\n\tstruct s_cfg_agc   rf_agc, if_agc;\n\tu32          total_gain  = 0;\n\tu32          atten      = 0;\n\tu32          agc_range   = 0;\n\tu16            scu_lvl  = 0;\n\tu16            scu_coc  = 0;\n\t \n\tu16 tuner_rf_gain         = 50;  \n\tu16 tuner_if_gain         = 40;  \n\n\t*strength = 0;\n\n\tif (is_dvbt(state)) {\n\t\trf_agc = state->m_dvbt_rf_agc_cfg;\n\t\tif_agc = state->m_dvbt_if_agc_cfg;\n\t} else if (is_qam(state)) {\n\t\trf_agc = state->m_qam_rf_agc_cfg;\n\t\tif_agc = state->m_qam_if_agc_cfg;\n\t} else {\n\t\trf_agc = state->m_atv_rf_agc_cfg;\n\t\tif_agc = state->m_atv_if_agc_cfg;\n\t}\n\n\tif (rf_agc.ctrl_mode == DRXK_AGC_CTRL_AUTO) {\n\t\t \n\t\tstatus = read16(state, SCU_RAM_AGC_RF_IACCU_HI__A, &scu_lvl);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\t \n\t\tstatus = read16(state, SCU_RAM_AGC_RF_IACCU_HI_CO__A, &scu_coc);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tif (((u32) scu_lvl + (u32) scu_coc) < 0xffff)\n\t\t\trf_agc.output_level = scu_lvl + scu_coc;\n\t\telse\n\t\t\trf_agc.output_level = 0xffff;\n\n\t\t \n\t\ttotal_gain += tuner_rf_gain;\n\n\t\t \n\t\tif (rf_agc.output_level < rf_agc.min_output_level)\n\t\t\trf_agc.output_level = rf_agc.min_output_level;\n\t\tif (rf_agc.output_level > rf_agc.max_output_level)\n\t\t\trf_agc.output_level = rf_agc.max_output_level;\n\n\t\tagc_range = (u32) (rf_agc.max_output_level - rf_agc.min_output_level);\n\t\tif (agc_range > 0) {\n\t\t\tatten += 100UL *\n\t\t\t\t((u32)(tuner_rf_gain)) *\n\t\t\t\t((u32)(rf_agc.output_level - rf_agc.min_output_level))\n\t\t\t\t/ agc_range;\n\t\t}\n\t}\n\n\tif (if_agc.ctrl_mode == DRXK_AGC_CTRL_AUTO) {\n\t\tstatus = read16(state, SCU_RAM_AGC_IF_IACCU_HI__A,\n\t\t\t\t&if_agc.output_level);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tstatus = read16(state, SCU_RAM_AGC_INGAIN_TGT_MIN__A,\n\t\t\t\t&if_agc.top);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\t \n\t\ttotal_gain += (u32) tuner_if_gain;\n\n\t\t \n\t\tif (if_agc.output_level < if_agc.min_output_level)\n\t\t\tif_agc.output_level = if_agc.min_output_level;\n\t\tif (if_agc.output_level > if_agc.max_output_level)\n\t\t\tif_agc.output_level = if_agc.max_output_level;\n\n\t\tagc_range  = (u32)(if_agc.max_output_level - if_agc.min_output_level);\n\t\tif (agc_range > 0) {\n\t\t\tatten += 100UL *\n\t\t\t\t((u32)(tuner_if_gain)) *\n\t\t\t\t((u32)(if_agc.output_level - if_agc.min_output_level))\n\t\t\t\t/ agc_range;\n\t\t}\n\t}\n\n\t \n\tif (total_gain > 0)\n\t\t*strength = (65535UL * atten / total_gain / 100);\n\telse\n\t\t*strength = 65535;\n\n\treturn 0;\n}\n\nstatic int drxk_get_stats(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct drxk_state *state = fe->demodulator_priv;\n\tint status;\n\tu32 stat;\n\tu16 reg16;\n\tu32 post_bit_count;\n\tu32 post_bit_err_count;\n\tu32 post_bit_error_scale;\n\tu32 pre_bit_err_count;\n\tu32 pre_bit_count;\n\tu32 pkt_count;\n\tu32 pkt_error_count;\n\ts32 cnr;\n\n\tif (state->m_drxk_state == DRXK_NO_DEV)\n\t\treturn -ENODEV;\n\tif (state->m_drxk_state == DRXK_UNINITIALIZED)\n\t\treturn -EAGAIN;\n\n\t \n\tstate->fe_status = 0;\n\tget_lock_status(state, &stat);\n\tif (stat == MPEG_LOCK)\n\t\tstate->fe_status |= 0x1f;\n\tif (stat == FEC_LOCK)\n\t\tstate->fe_status |= 0x0f;\n\tif (stat == DEMOD_LOCK)\n\t\tstate->fe_status |= 0x07;\n\n\t \n\tget_strength(state, &c->strength.stat[0].uvalue);\n\tc->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\n\n\tif (stat >= DEMOD_LOCK) {\n\t\tget_signal_to_noise(state, &cnr);\n\t\tc->cnr.stat[0].svalue = cnr * 100;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t} else {\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\tif (stat < FEC_LOCK) {\n\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\n\t \n\n\t \n\tstatus = read16(state, OFDM_EC_VD_ERR_BIT_CNT__A, &reg16);\n\tif (status < 0)\n\t\tgoto error;\n\tpre_bit_err_count = reg16;\n\n\tstatus = read16(state, OFDM_EC_VD_IN_BIT_CNT__A , &reg16);\n\tif (status < 0)\n\t\tgoto error;\n\tpre_bit_count = reg16;\n\n\t \n\tstatus = read16(state, FEC_RS_NR_BIT_ERRORS__A, &reg16);\n\tif (status < 0)\n\t\tgoto error;\n\tpost_bit_err_count = reg16;\n\n\tstatus = read16(state, FEC_RS_MEASUREMENT_PRESCALE__A, &reg16);\n\tif (status < 0)\n\t\tgoto error;\n\tpost_bit_error_scale = reg16;\n\n\tstatus = read16(state, FEC_RS_MEASUREMENT_PERIOD__A, &reg16);\n\tif (status < 0)\n\t\tgoto error;\n\tpkt_count = reg16;\n\n\tstatus = read16(state, SCU_RAM_FEC_ACCUM_PKT_FAILURES__A, &reg16);\n\tif (status < 0)\n\t\tgoto error;\n\tpkt_error_count = reg16;\n\twrite16(state, SCU_RAM_FEC_ACCUM_PKT_FAILURES__A, 0);\n\n\tpost_bit_err_count *= post_bit_error_scale;\n\n\tpost_bit_count = pkt_count * 204 * 8;\n\n\t \n\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\tc->block_error.stat[0].uvalue += pkt_error_count;\n\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\tc->block_count.stat[0].uvalue += pkt_count;\n\n\tc->pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\tc->pre_bit_error.stat[0].uvalue += pre_bit_err_count;\n\tc->pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\tc->pre_bit_count.stat[0].uvalue += pre_bit_count;\n\n\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\tc->post_bit_error.stat[0].uvalue += post_bit_err_count;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\tc->post_bit_count.stat[0].uvalue += post_bit_count;\n\nerror:\n\treturn status;\n}\n\n\nstatic int drxk_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct drxk_state *state = fe->demodulator_priv;\n\tint rc;\n\n\tdprintk(1, \"\\n\");\n\n\trc = drxk_get_stats(fe);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*status = state->fe_status;\n\n\treturn 0;\n}\n\nstatic int drxk_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t     u16 *strength)\n{\n\tstruct drxk_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tdprintk(1, \"\\n\");\n\n\tif (state->m_drxk_state == DRXK_NO_DEV)\n\t\treturn -ENODEV;\n\tif (state->m_drxk_state == DRXK_UNINITIALIZED)\n\t\treturn -EAGAIN;\n\n\t*strength = c->strength.stat[0].uvalue;\n\treturn 0;\n}\n\nstatic int drxk_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct drxk_state *state = fe->demodulator_priv;\n\ts32 snr2;\n\n\tdprintk(1, \"\\n\");\n\n\tif (state->m_drxk_state == DRXK_NO_DEV)\n\t\treturn -ENODEV;\n\tif (state->m_drxk_state == DRXK_UNINITIALIZED)\n\t\treturn -EAGAIN;\n\n\tget_signal_to_noise(state, &snr2);\n\n\t \n\tif (snr2 < 0)\n\t\tsnr2 = 0;\n\t*snr = snr2 & 0xffff;\n\treturn 0;\n}\n\nstatic int drxk_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct drxk_state *state = fe->demodulator_priv;\n\tu16 err = 0;\n\n\tdprintk(1, \"\\n\");\n\n\tif (state->m_drxk_state == DRXK_NO_DEV)\n\t\treturn -ENODEV;\n\tif (state->m_drxk_state == DRXK_UNINITIALIZED)\n\t\treturn -EAGAIN;\n\n\tdvbtqam_get_acc_pkt_err(state, &err);\n\t*ucblocks = (u32) err;\n\treturn 0;\n}\n\nstatic int drxk_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t  struct dvb_frontend_tune_settings *sets)\n{\n\tstruct drxk_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tdprintk(1, \"\\n\");\n\n\tif (state->m_drxk_state == DRXK_NO_DEV)\n\t\treturn -ENODEV;\n\tif (state->m_drxk_state == DRXK_UNINITIALIZED)\n\t\treturn -EAGAIN;\n\n\tswitch (p->delivery_system) {\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_C:\n\tcase SYS_DVBT:\n\t\tsets->min_delay_ms = 3000;\n\t\tsets->max_drift = 0;\n\t\tsets->step_size = 0;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct dvb_frontend_ops drxk_ops = {\n\t \n\t.info = {\n\t\t.name = \"DRXK\",\n\t\t.frequency_min_hz =  47 * MHz,\n\t\t.frequency_max_hz = 865 * MHz,\n\t\t  \n\t\t.symbol_rate_min =   870000,\n\t\t.symbol_rate_max = 11700000,\n\t\t \n\t\t.frequency_stepsize_hz = 166667,\n\n\t\t.caps = FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_128 | FE_CAN_QAM_256 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_MUTE_TS |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_RECOVER |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO\n\t},\n\n\t.release = drxk_release,\n\t.sleep = drxk_sleep,\n\t.i2c_gate_ctrl = drxk_gate_ctrl,\n\n\t.set_frontend = drxk_set_parameters,\n\t.get_tune_settings = drxk_get_tune_settings,\n\n\t.read_status = drxk_read_status,\n\t.read_signal_strength = drxk_read_signal_strength,\n\t.read_snr = drxk_read_snr,\n\t.read_ucblocks = drxk_read_ucblocks,\n};\n\nstruct dvb_frontend *drxk_attach(const struct drxk_config *config,\n\t\t\t\t struct i2c_adapter *i2c)\n{\n\tstruct dtv_frontend_properties *p;\n\tstruct drxk_state *state = NULL;\n\tu8 adr = config->adr;\n\tint status;\n\n\tdprintk(1, \"\\n\");\n\tstate = kzalloc(sizeof(struct drxk_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tstate->i2c = i2c;\n\tstate->demod_address = adr;\n\tstate->single_master = config->single_master;\n\tstate->microcode_name = config->microcode_name;\n\tstate->qam_demod_parameter_count = config->qam_demod_parameter_count;\n\tstate->no_i2c_bridge = config->no_i2c_bridge;\n\tstate->antenna_gpio = config->antenna_gpio;\n\tstate->antenna_dvbt = config->antenna_dvbt;\n\tstate->m_chunk_size = config->chunk_size;\n\tstate->enable_merr_cfg = config->enable_merr_cfg;\n\n\tif (config->dynamic_clk) {\n\t\tstate->m_dvbt_static_clk = false;\n\t\tstate->m_dvbc_static_clk = false;\n\t} else {\n\t\tstate->m_dvbt_static_clk = true;\n\t\tstate->m_dvbc_static_clk = true;\n\t}\n\n\n\tif (config->mpeg_out_clk_strength)\n\t\tstate->m_ts_clockk_strength = config->mpeg_out_clk_strength & 0x07;\n\telse\n\t\tstate->m_ts_clockk_strength = 0x06;\n\n\tif (config->parallel_ts)\n\t\tstate->m_enable_parallel = true;\n\telse\n\t\tstate->m_enable_parallel = false;\n\n\t \n\tstate->uio_mask = config->antenna_gpio;\n\n\t \n\tif (!state->antenna_dvbt && state->antenna_gpio)\n\t\tstate->m_gpio |= state->antenna_gpio;\n\telse\n\t\tstate->m_gpio &= ~state->antenna_gpio;\n\n\tmutex_init(&state->mutex);\n\n\tmemcpy(&state->frontend.ops, &drxk_ops, sizeof(drxk_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\tinit_state(state);\n\n\t \n\tif (state->microcode_name) {\n\t\tconst struct firmware *fw = NULL;\n\n\t\tstatus = request_firmware(&fw, state->microcode_name,\n\t\t\t\t\t  state->i2c->dev.parent);\n\t\tif (status < 0)\n\t\t\tfw = NULL;\n\t\tload_firmware_cb(fw, state);\n\t} else if (init_drxk(state) < 0)\n\t\tgoto error;\n\n\n\t \n\tp = &state->frontend.dtv_property_cache;\n\tp->strength.len = 1;\n\tp->cnr.len = 1;\n\tp->block_error.len = 1;\n\tp->block_count.len = 1;\n\tp->pre_bit_error.len = 1;\n\tp->pre_bit_count.len = 1;\n\tp->post_bit_error.len = 1;\n\tp->post_bit_count.len = 1;\n\n\tp->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tpr_info(\"frontend initialized.\\n\");\n\treturn &state->frontend;\n\nerror:\n\tpr_err(\"not found\\n\");\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(drxk_attach);\n\nMODULE_DESCRIPTION(\"DRX-K driver\");\nMODULE_AUTHOR(\"Ralph Metzler\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}