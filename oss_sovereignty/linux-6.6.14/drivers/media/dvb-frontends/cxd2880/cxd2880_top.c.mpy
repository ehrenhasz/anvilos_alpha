{
  "module_name": "cxd2880_top.c",
  "hash_id": "68dd20fa71b8388e918e353b3f8791f5806b7622d6ae4bb11535cc9a85f87ea4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cxd2880/cxd2880_top.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <linux/spi/spi.h>\n\n#include <media/dvb_frontend.h>\n#include <linux/int_log.h>\n\n#include \"cxd2880.h\"\n#include \"cxd2880_tnrdmd_mon.h\"\n#include \"cxd2880_tnrdmd_dvbt2_mon.h\"\n#include \"cxd2880_tnrdmd_dvbt_mon.h\"\n#include \"cxd2880_integ.h\"\n#include \"cxd2880_tnrdmd_dvbt2.h\"\n#include \"cxd2880_tnrdmd_dvbt.h\"\n#include \"cxd2880_devio_spi.h\"\n#include \"cxd2880_spi_device.h\"\n#include \"cxd2880_tnrdmd_driver_version.h\"\n\nstruct cxd2880_priv {\n\tstruct cxd2880_tnrdmd tnrdmd;\n\tstruct spi_device *spi;\n\tstruct cxd2880_io regio;\n\tstruct cxd2880_spi_device spi_device;\n\tstruct cxd2880_spi cxd2880_spi;\n\tstruct cxd2880_dvbt_tune_param dvbt_tune_param;\n\tstruct cxd2880_dvbt2_tune_param dvbt2_tune_param;\n\tstruct mutex *spi_mutex;  \n\tunsigned long pre_ber_update;\n\tunsigned long pre_ber_interval;\n\tunsigned long post_ber_update;\n\tunsigned long post_ber_interval;\n\tunsigned long ucblock_update;\n\tunsigned long ucblock_interval;\n\tenum fe_status s;\n};\n\nstatic int cxd2880_pre_bit_err_t(struct cxd2880_tnrdmd *tnrdmd,\n\t\t\t\t u32 *pre_bit_err, u32 *pre_bit_count)\n{\n\tu8 rdata[2];\n\tint ret;\n\n\tif (!tnrdmd || !pre_bit_err || !pre_bit_count)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->diver_mode == CXD2880_TNRDMD_DIVERMODE_SUB)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->state != CXD2880_TNRDMD_STATE_ACTIVE)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->sys != CXD2880_DTV_SYS_DVBT)\n\t\treturn -EINVAL;\n\n\tret = slvt_freeze_reg(tnrdmd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tnrdmd->io->write_reg(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x00, 0x10);\n\tif (ret) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn ret;\n\t}\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x39, rdata, 1);\n\tif (ret) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn ret;\n\t}\n\n\tif ((rdata[0] & 0x01) == 0) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn -EAGAIN;\n\t}\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x22, rdata, 2);\n\tif (ret) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn ret;\n\t}\n\n\t*pre_bit_err = (rdata[0] << 8) | rdata[1];\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x6f, rdata, 1);\n\tif (ret) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn ret;\n\t}\n\n\tslvt_unfreeze_reg(tnrdmd);\n\n\t*pre_bit_count = ((rdata[0] & 0x07) == 0) ?\n\t\t\t 256 : (0x1000 << (rdata[0] & 0x07));\n\n\treturn 0;\n}\n\nstatic int cxd2880_pre_bit_err_t2(struct cxd2880_tnrdmd *tnrdmd,\n\t\t\t\t  u32 *pre_bit_err,\n\t\t\t\t  u32 *pre_bit_count)\n{\n\tu32 period_exp = 0;\n\tu32 n_ldpc = 0;\n\tu8 data[5];\n\tint ret;\n\n\tif (!tnrdmd || !pre_bit_err || !pre_bit_count)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->diver_mode == CXD2880_TNRDMD_DIVERMODE_SUB)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->state != CXD2880_TNRDMD_STATE_ACTIVE)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->sys != CXD2880_DTV_SYS_DVBT2)\n\t\treturn -EINVAL;\n\n\tret = slvt_freeze_reg(tnrdmd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tnrdmd->io->write_reg(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x00, 0x0b);\n\tif (ret) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn ret;\n\t}\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x3c, data, sizeof(data));\n\tif (ret) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn ret;\n\t}\n\n\tif (!(data[0] & 0x01)) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn -EAGAIN;\n\t}\n\t*pre_bit_err =\n\t((data[1] & 0x0f) << 24) | (data[2] << 16) | (data[3] << 8) | data[4];\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0xa0, data, 1);\n\tif (ret) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn ret;\n\t}\n\n\tif (((enum cxd2880_dvbt2_plp_fec)(data[0] & 0x03)) ==\n\t    CXD2880_DVBT2_FEC_LDPC_16K)\n\t\tn_ldpc = 16200;\n\telse\n\t\tn_ldpc = 64800;\n\tslvt_unfreeze_reg(tnrdmd);\n\n\tret = tnrdmd->io->write_reg(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x00, 0x20);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x6f, data, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tperiod_exp = data[0] & 0x0f;\n\n\t*pre_bit_count = (1U << period_exp) * n_ldpc;\n\n\treturn 0;\n}\n\nstatic int cxd2880_post_bit_err_t(struct cxd2880_tnrdmd *tnrdmd,\n\t\t\t\t  u32 *post_bit_err,\n\t\t\t\t  u32 *post_bit_count)\n{\n\tu8 rdata[3];\n\tu32 bit_error = 0;\n\tu32 period_exp = 0;\n\tint ret;\n\n\tif (!tnrdmd || !post_bit_err || !post_bit_count)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->diver_mode == CXD2880_TNRDMD_DIVERMODE_SUB)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->state != CXD2880_TNRDMD_STATE_ACTIVE)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->sys != CXD2880_DTV_SYS_DVBT)\n\t\treturn -EINVAL;\n\n\tret = tnrdmd->io->write_reg(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x00, 0x0d);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x15, rdata, 3);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((rdata[0] & 0x40) == 0)\n\t\treturn -EAGAIN;\n\n\t*post_bit_err = ((rdata[0] & 0x3f) << 16) | (rdata[1] << 8) | rdata[2];\n\n\tret = tnrdmd->io->write_reg(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x00, 0x10);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x60, rdata, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tperiod_exp = (rdata[0] & 0x1f);\n\n\tif (period_exp <= 11 && (bit_error > (1U << period_exp) * 204 * 8))\n\t\treturn -EAGAIN;\n\n\t*post_bit_count = (1U << period_exp) * 204 * 8;\n\n\treturn 0;\n}\n\nstatic int cxd2880_post_bit_err_t2(struct cxd2880_tnrdmd *tnrdmd,\n\t\t\t\t   u32 *post_bit_err,\n\t\t\t\t   u32 *post_bit_count)\n{\n\tu32 period_exp = 0;\n\tu32 n_bch = 0;\n\tu8 data[3];\n\tenum cxd2880_dvbt2_plp_fec plp_fec_type =\n\t\tCXD2880_DVBT2_FEC_LDPC_16K;\n\tenum cxd2880_dvbt2_plp_code_rate plp_code_rate =\n\t\tCXD2880_DVBT2_R1_2;\n\tint ret;\n\tstatic const u16 n_bch_bits_lookup[2][8] = {\n\t\t{7200, 9720, 10800, 11880, 12600, 13320, 5400, 6480},\n\t\t{32400, 38880, 43200, 48600, 51840, 54000, 21600, 25920}\n\t};\n\n\tif (!tnrdmd || !post_bit_err || !post_bit_count)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->diver_mode == CXD2880_TNRDMD_DIVERMODE_SUB)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->state != CXD2880_TNRDMD_STATE_ACTIVE)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->sys != CXD2880_DTV_SYS_DVBT2)\n\t\treturn -EINVAL;\n\n\tret = slvt_freeze_reg(tnrdmd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tnrdmd->io->write_reg(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x00, 0x0b);\n\tif (ret) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn ret;\n\t}\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x15, data, 3);\n\tif (ret) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn ret;\n\t}\n\n\tif (!(data[0] & 0x40)) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn -EAGAIN;\n\t}\n\n\t*post_bit_err =\n\t\t((data[0] & 0x3f) << 16) | (data[1] << 8) | data[2];\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x9d, data, 1);\n\tif (ret) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn ret;\n\t}\n\n\tplp_code_rate =\n\t(enum cxd2880_dvbt2_plp_code_rate)(data[0] & 0x07);\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0xa0, data, 1);\n\tif (ret) {\n\t\tslvt_unfreeze_reg(tnrdmd);\n\t\treturn ret;\n\t}\n\n\tplp_fec_type = (enum cxd2880_dvbt2_plp_fec)(data[0] & 0x03);\n\n\tslvt_unfreeze_reg(tnrdmd);\n\n\tret = tnrdmd->io->write_reg(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x00, 0x20);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x72, data, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tperiod_exp = data[0] & 0x0f;\n\n\tif (plp_fec_type > CXD2880_DVBT2_FEC_LDPC_64K ||\n\t    plp_code_rate > CXD2880_DVBT2_R2_5)\n\t\treturn -EAGAIN;\n\n\tn_bch = n_bch_bits_lookup[plp_fec_type][plp_code_rate];\n\n\tif (*post_bit_err > ((1U << period_exp) * n_bch))\n\t\treturn -EAGAIN;\n\n\t*post_bit_count = (1U << period_exp) * n_bch;\n\n\treturn 0;\n}\n\nstatic int cxd2880_read_block_err_t(struct cxd2880_tnrdmd *tnrdmd,\n\t\t\t\t    u32 *block_err,\n\t\t\t\t    u32 *block_count)\n{\n\tu8 rdata[3];\n\tint ret;\n\n\tif (!tnrdmd || !block_err || !block_count)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->diver_mode == CXD2880_TNRDMD_DIVERMODE_SUB)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->state != CXD2880_TNRDMD_STATE_ACTIVE)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->sys != CXD2880_DTV_SYS_DVBT)\n\t\treturn -EINVAL;\n\n\tret = tnrdmd->io->write_reg(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x00, 0x0d);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x18, rdata, 3);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((rdata[0] & 0x01) == 0)\n\t\treturn -EAGAIN;\n\n\t*block_err = (rdata[1] << 8) | rdata[2];\n\n\tret = tnrdmd->io->write_reg(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x00, 0x10);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x5c, rdata, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t*block_count = 1U << (rdata[0] & 0x0f);\n\n\tif ((*block_count == 0) || (*block_err > *block_count))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int cxd2880_read_block_err_t2(struct cxd2880_tnrdmd *tnrdmd,\n\t\t\t\t     u32 *block_err,\n\t\t\t\t     u32 *block_count)\n{\n\tu8 rdata[3];\n\tint ret;\n\n\tif (!tnrdmd || !block_err || !block_count)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->diver_mode == CXD2880_TNRDMD_DIVERMODE_SUB)\n\t\treturn -EINVAL;\n\n\tif (tnrdmd->state != CXD2880_TNRDMD_STATE_ACTIVE)\n\t\treturn -EINVAL;\n\tif (tnrdmd->sys != CXD2880_DTV_SYS_DVBT2)\n\t\treturn -EINVAL;\n\n\tret = tnrdmd->io->write_reg(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x00, 0x0b);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x18, rdata, 3);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((rdata[0] & 0x01) == 0)\n\t\treturn -EAGAIN;\n\n\t*block_err = (rdata[1] << 8) | rdata[2];\n\n\tret = tnrdmd->io->write_reg(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0x00, 0x24);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t    0xdc, rdata, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t*block_count = 1U << (rdata[0] & 0x0f);\n\n\tif ((*block_count == 0) || (*block_err > *block_count))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic void cxd2880_release(struct dvb_frontend *fe)\n{\n\tstruct cxd2880_priv *priv = NULL;\n\n\tif (!fe) {\n\t\tpr_err(\"invalid arg.\\n\");\n\t\treturn;\n\t}\n\tpriv = fe->demodulator_priv;\n\tkfree(priv);\n}\n\nstatic int cxd2880_init(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct cxd2880_priv *priv = NULL;\n\tstruct cxd2880_tnrdmd_create_param create_param;\n\n\tif (!fe) {\n\t\tpr_err(\"invalid arg.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\n\tcreate_param.ts_output_if = CXD2880_TNRDMD_TSOUT_IF_SPI;\n\tcreate_param.xtal_share_type = CXD2880_TNRDMD_XTAL_SHARE_NONE;\n\tcreate_param.en_internal_ldo = 1;\n\tcreate_param.xosc_cap = 18;\n\tcreate_param.xosc_i = 8;\n\tcreate_param.stationary_use = 1;\n\n\tmutex_lock(priv->spi_mutex);\n\tif (priv->tnrdmd.io != &priv->regio) {\n\t\tret = cxd2880_tnrdmd_create(&priv->tnrdmd,\n\t\t\t\t\t    &priv->regio, &create_param);\n\t\tif (ret) {\n\t\t\tmutex_unlock(priv->spi_mutex);\n\t\t\tpr_info(\"cxd2880 tnrdmd create failed %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = cxd2880_integ_init(&priv->tnrdmd);\n\tif (ret) {\n\t\tmutex_unlock(priv->spi_mutex);\n\t\tpr_err(\"cxd2880 integ init failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cxd2880_tnrdmd_set_cfg(&priv->tnrdmd,\n\t\t\t\t     CXD2880_TNRDMD_CFG_TSPIN_CURRENT,\n\t\t\t\t     0x00);\n\tif (ret) {\n\t\tmutex_unlock(priv->spi_mutex);\n\t\tpr_err(\"cxd2880 set config failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmutex_unlock(priv->spi_mutex);\n\n\tpr_debug(\"OK.\\n\");\n\n\treturn ret;\n}\n\nstatic int cxd2880_sleep(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct cxd2880_priv *priv = NULL;\n\n\tif (!fe) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\n\tmutex_lock(priv->spi_mutex);\n\tret = cxd2880_tnrdmd_sleep(&priv->tnrdmd);\n\tmutex_unlock(priv->spi_mutex);\n\n\tpr_debug(\"tnrdmd_sleep ret %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int cxd2880_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t\tu16 *strength)\n{\n\tint ret;\n\tstruct cxd2880_priv *priv = NULL;\n\tstruct dtv_frontend_properties *c = NULL;\n\tint level = 0;\n\n\tif (!fe || !strength) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\tc = &fe->dtv_property_cache;\n\n\tmutex_lock(priv->spi_mutex);\n\tif (c->delivery_system == SYS_DVBT ||\n\t    c->delivery_system == SYS_DVBT2) {\n\t\tret = cxd2880_tnrdmd_mon_rf_lvl(&priv->tnrdmd, &level);\n\t} else {\n\t\tpr_debug(\"invalid system\\n\");\n\t\tmutex_unlock(priv->spi_mutex);\n\t\treturn -EINVAL;\n\t}\n\tmutex_unlock(priv->spi_mutex);\n\n\tlevel /= 125;\n\t \n\tlevel = clamp(level, -840, -240);\n\t \n\t*strength = ((level + 840) * 0xffff) / (-240 + 840);\n\n\tif (ret)\n\t\tpr_debug(\"ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int cxd2880_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tint ret;\n\tint snrvalue = 0;\n\tstruct cxd2880_priv *priv = NULL;\n\tstruct dtv_frontend_properties *c = NULL;\n\n\tif (!fe || !snr) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\tc = &fe->dtv_property_cache;\n\n\tmutex_lock(priv->spi_mutex);\n\tif (c->delivery_system == SYS_DVBT) {\n\t\tret = cxd2880_tnrdmd_dvbt_mon_snr(&priv->tnrdmd,\n\t\t\t\t\t\t  &snrvalue);\n\t} else if (c->delivery_system == SYS_DVBT2) {\n\t\tret = cxd2880_tnrdmd_dvbt2_mon_snr(&priv->tnrdmd,\n\t\t\t\t\t\t   &snrvalue);\n\t} else {\n\t\tpr_err(\"invalid system\\n\");\n\t\tmutex_unlock(priv->spi_mutex);\n\t\treturn -EINVAL;\n\t}\n\tmutex_unlock(priv->spi_mutex);\n\n\tif (snrvalue < 0)\n\t\tsnrvalue = 0;\n\t*snr = snrvalue;\n\n\tif (ret)\n\t\tpr_debug(\"ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int cxd2880_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tint ret;\n\tstruct cxd2880_priv *priv = NULL;\n\tstruct dtv_frontend_properties *c = NULL;\n\n\tif (!fe || !ucblocks) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\tc = &fe->dtv_property_cache;\n\n\tmutex_lock(priv->spi_mutex);\n\tif (c->delivery_system == SYS_DVBT) {\n\t\tret = cxd2880_tnrdmd_dvbt_mon_packet_error_number(&priv->tnrdmd,\n\t\t\t\t\t\t\t\t  ucblocks);\n\t} else if (c->delivery_system == SYS_DVBT2) {\n\t\tret = cxd2880_tnrdmd_dvbt2_mon_packet_error_number(&priv->tnrdmd,\n\t\t\t\t\t\t\t\t   ucblocks);\n\t} else {\n\t\tpr_err(\"invalid system\\n\");\n\t\tmutex_unlock(priv->spi_mutex);\n\t\treturn -EINVAL;\n\t}\n\tmutex_unlock(priv->spi_mutex);\n\n\tif (ret)\n\t\tpr_debug(\"ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int cxd2880_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\t*ber = 0;\n\n\treturn 0;\n}\n\nstatic int cxd2880_set_ber_per_period_t(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct cxd2880_priv *priv;\n\tstruct cxd2880_dvbt_tpsinfo info;\n\tenum cxd2880_dtv_bandwidth bw;\n\tu32 pre_ber_rate = 0;\n\tu32 post_ber_rate = 0;\n\tu32 ucblock_rate = 0;\n\tu32 mes_exp = 0;\n\tstatic const int cr_table[5] = {31500, 42000, 47250, 52500, 55125};\n\tstatic const int denominator_tbl[4] = {125664, 129472, 137088, 152320};\n\n\tif (!fe) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\tbw = priv->dvbt_tune_param.bandwidth;\n\n\tret = cxd2880_tnrdmd_dvbt_mon_tps_info(&priv->tnrdmd,\n\t\t\t\t\t       &info);\n\tif (ret) {\n\t\tpr_err(\"tps monitor error ret = %d\\n\", ret);\n\t\tinfo.hierarchy = CXD2880_DVBT_HIERARCHY_NON;\n\t\tinfo.constellation = CXD2880_DVBT_CONSTELLATION_QPSK;\n\t\tinfo.guard = CXD2880_DVBT_GUARD_1_4;\n\t\tinfo.rate_hp = CXD2880_DVBT_CODERATE_1_2;\n\t\tinfo.rate_lp = CXD2880_DVBT_CODERATE_1_2;\n\t}\n\n\tif (info.hierarchy == CXD2880_DVBT_HIERARCHY_NON) {\n\t\tpre_ber_rate = 63000000 * bw * (info.constellation * 2 + 2) /\n\t\t\t       denominator_tbl[info.guard];\n\n\t\tpost_ber_rate =\t1000 * cr_table[info.rate_hp] * bw *\n\t\t\t\t(info.constellation * 2 + 2) /\n\t\t\t\tdenominator_tbl[info.guard];\n\n\t\tucblock_rate = 875 * cr_table[info.rate_hp] * bw *\n\t\t\t       (info.constellation * 2 + 2) /\n\t\t\t       denominator_tbl[info.guard];\n\t} else {\n\t\tu8 data = 0;\n\t\tstruct cxd2880_tnrdmd *tnrdmd = &priv->tnrdmd;\n\n\t\tret = tnrdmd->io->write_reg(tnrdmd->io,\n\t\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t\t    0x00, 0x10);\n\t\tif (!ret) {\n\t\t\tret = tnrdmd->io->read_regs(tnrdmd->io,\n\t\t\t\t\t\t    CXD2880_IO_TGT_DMD,\n\t\t\t\t\t\t    0x67, &data, 1);\n\t\t\tif (ret)\n\t\t\t\tdata = 0x00;\n\t\t} else {\n\t\t\tdata = 0x00;\n\t\t}\n\n\t\tif (data & 0x01) {  \n\t\t\tpre_ber_rate =\n\t\t\t\t63000000 * bw * (info.constellation * 2 + 2) /\n\t\t\t\tdenominator_tbl[info.guard];\n\n\t\t\tpost_ber_rate = 1000 * cr_table[info.rate_lp] * bw *\n\t\t\t\t\t(info.constellation * 2 + 2) /\n\t\t\t\t\tdenominator_tbl[info.guard];\n\n\t\t\tucblock_rate = (1000 * 7 / 8) *\tcr_table[info.rate_lp] *\n\t\t\t\t       bw * (info.constellation * 2 + 2) /\n\t\t\t\t       denominator_tbl[info.guard];\n\t\t} else {  \n\t\t\tpre_ber_rate =\n\t\t\t\t63000000 * bw * 2 / denominator_tbl[info.guard];\n\n\t\t\tpost_ber_rate = 1000 * cr_table[info.rate_hp] * bw * 2 /\n\t\t\t\t\tdenominator_tbl[info.guard];\n\n\t\t\tucblock_rate = (1000 * 7 / 8) * cr_table[info.rate_hp] *\n\t\t\t\t\tbw * 2 / denominator_tbl[info.guard];\n\t\t}\n\t}\n\n\tmes_exp = pre_ber_rate < 8192 ? 8 : intlog2(pre_ber_rate) >> 24;\n\tpriv->pre_ber_interval =\n\t\t((1U << mes_exp) * 1000 + (pre_ber_rate / 2)) /\n\t\tpre_ber_rate;\n\tcxd2880_tnrdmd_set_cfg(&priv->tnrdmd,\n\t\t\t       CXD2880_TNRDMD_CFG_DVBT_VBER_PERIOD,\n\t\t\t       mes_exp == 8 ? 0 : mes_exp - 12);\n\n\tmes_exp = intlog2(post_ber_rate) >> 24;\n\tpriv->post_ber_interval =\n\t\t((1U << mes_exp) * 1000 + (post_ber_rate / 2)) /\n\t\tpost_ber_rate;\n\tcxd2880_tnrdmd_set_cfg(&priv->tnrdmd,\n\t\t\t       CXD2880_TNRDMD_CFG_DVBT_BERN_PERIOD,\n\t\t\t       mes_exp);\n\n\tmes_exp = intlog2(ucblock_rate) >> 24;\n\tpriv->ucblock_interval =\n\t\t((1U << mes_exp) * 1000 + (ucblock_rate / 2)) /\n\t\tucblock_rate;\n\tcxd2880_tnrdmd_set_cfg(&priv->tnrdmd,\n\t\t\t       CXD2880_TNRDMD_CFG_DVBT_PER_MES,\n\t\t\t       mes_exp);\n\n\treturn 0;\n}\n\nstatic int cxd2880_set_ber_per_period_t2(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct cxd2880_priv *priv;\n\tstruct cxd2880_dvbt2_l1pre l1pre;\n\tstruct cxd2880_dvbt2_l1post l1post;\n\tstruct cxd2880_dvbt2_plp plp;\n\tstruct cxd2880_dvbt2_bbheader bbheader;\n\tenum cxd2880_dtv_bandwidth bw = CXD2880_DTV_BW_1_7_MHZ;\n\tu32 pre_ber_rate = 0;\n\tu32 post_ber_rate = 0;\n\tu32 ucblock_rate = 0;\n\tu32 mes_exp = 0;\n\tu32 term_a = 0;\n\tu32 term_b = 0;\n\tu32 denominator = 0;\n\tstatic const u32 gi_tbl[7] = {32, 64, 128, 256, 8, 152, 76};\n\tstatic const u8 n_tbl[6] = {8, 2, 4, 16, 1, 1};\n\tstatic const u8 mode_tbl[6] = {2, 8, 4, 1, 16, 32};\n\tstatic const u32 kbch_tbl[2][8] = {\n\t\t{6952, 9472, 10552, 11632, 12352, 13072, 5152, 6232},\n\t\t{32128, 38608, 42960, 48328, 51568, 53760, 0, 0}\n\t};\n\n\tif (!fe) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\tbw = priv->dvbt2_tune_param.bandwidth;\n\n\tret = cxd2880_tnrdmd_dvbt2_mon_l1_pre(&priv->tnrdmd, &l1pre);\n\tif (ret) {\n\t\tpr_info(\"l1 pre error\\n\");\n\t\tgoto error_ber_setting;\n\t}\n\n\tret = cxd2880_tnrdmd_dvbt2_mon_active_plp(&priv->tnrdmd,\n\t\t\t\t\t\t  CXD2880_DVBT2_PLP_DATA, &plp);\n\tif (ret) {\n\t\tpr_info(\"plp info error\\n\");\n\t\tgoto error_ber_setting;\n\t}\n\n\tret = cxd2880_tnrdmd_dvbt2_mon_l1_post(&priv->tnrdmd, &l1post);\n\tif (ret) {\n\t\tpr_info(\"l1 post error\\n\");\n\t\tgoto error_ber_setting;\n\t}\n\n\tterm_a =\n\t\t(mode_tbl[l1pre.fft_mode] * (1024 + gi_tbl[l1pre.gi])) *\n\t\t(l1pre.num_symbols + n_tbl[l1pre.fft_mode]) + 2048;\n\n\tif (l1pre.mixed && l1post.fef_intvl) {\n\t\tterm_b = (l1post.fef_length + (l1post.fef_intvl / 2)) /\n\t\t\t l1post.fef_intvl;\n\t} else {\n\t\tterm_b = 0;\n\t}\n\n\tswitch (bw) {\n\tcase CXD2880_DTV_BW_1_7_MHZ:\n\t\tdenominator = ((term_a + term_b) * 71 + (131 / 2)) / 131;\n\t\tbreak;\n\tcase CXD2880_DTV_BW_5_MHZ:\n\t\tdenominator = ((term_a + term_b) * 7 + 20) / 40;\n\t\tbreak;\n\tcase CXD2880_DTV_BW_6_MHZ:\n\t\tdenominator = ((term_a + term_b) * 7 + 24) / 48;\n\t\tbreak;\n\tcase CXD2880_DTV_BW_7_MHZ:\n\t\tdenominator = ((term_a + term_b) + 4) / 8;\n\t\tbreak;\n\tcase CXD2880_DTV_BW_8_MHZ:\n\tdefault:\n\t\tdenominator = ((term_a + term_b) * 7 + 32) / 64;\n\t\tbreak;\n\t}\n\n\tif (plp.til_type && plp.til_len) {\n\t\tpre_ber_rate =\n\t\t\t(plp.num_blocks_max * 1000000 + (denominator / 2)) /\n\t\t\tdenominator;\n\t\tpre_ber_rate = (pre_ber_rate + (plp.til_len / 2)) /\n\t\t\t       plp.til_len;\n\t} else {\n\t\tpre_ber_rate =\n\t\t\t(plp.num_blocks_max * 1000000 + (denominator / 2)) /\n\t\t\tdenominator;\n\t}\n\n\tpost_ber_rate = pre_ber_rate;\n\n\tmes_exp = intlog2(pre_ber_rate) >> 24;\n\tpriv->pre_ber_interval =\n\t\t((1U << mes_exp) * 1000 + (pre_ber_rate / 2)) /\n\t\tpre_ber_rate;\n\tcxd2880_tnrdmd_set_cfg(&priv->tnrdmd,\n\t\t\t       CXD2880_TNRDMD_CFG_DVBT2_LBER_MES,\n\t\t\t       mes_exp);\n\n\tmes_exp = intlog2(post_ber_rate) >> 24;\n\tpriv->post_ber_interval =\n\t\t((1U << mes_exp) * 1000 + (post_ber_rate / 2)) /\n\t\tpost_ber_rate;\n\tcxd2880_tnrdmd_set_cfg(&priv->tnrdmd,\n\t\t\t       CXD2880_TNRDMD_CFG_DVBT2_BBER_MES,\n\t\t\t       mes_exp);\n\n\tret = cxd2880_tnrdmd_dvbt2_mon_bbheader(&priv->tnrdmd,\n\t\t\t\t\t\tCXD2880_DVBT2_PLP_DATA,\n\t\t\t\t\t\t&bbheader);\n\tif (ret) {\n\t\tpr_info(\"bb header error\\n\");\n\t\tgoto error_ucblock_setting;\n\t}\n\n\tif (bbheader.plp_mode == CXD2880_DVBT2_PLP_MODE_NM) {\n\t\tif (!bbheader.issy_indicator) {\n\t\t\tucblock_rate =\n\t\t\t\t(pre_ber_rate * kbch_tbl[plp.fec][plp.plp_cr] +\n\t\t\t\t752) / 1504;\n\t\t} else {\n\t\t\tucblock_rate =\n\t\t\t\t(pre_ber_rate * kbch_tbl[plp.fec][plp.plp_cr] +\n\t\t\t\t764) / 1528;\n\t\t}\n\t} else if (bbheader.plp_mode == CXD2880_DVBT2_PLP_MODE_HEM) {\n\t\tucblock_rate =\n\t\t\t(pre_ber_rate * kbch_tbl[plp.fec][plp.plp_cr] + 748) /\n\t\t\t1496;\n\t} else {\n\t\tpr_info(\"plp mode is not Normal or HEM\\n\");\n\t\tgoto error_ucblock_setting;\n\t}\n\n\tmes_exp = intlog2(ucblock_rate) >> 24;\n\tpriv->ucblock_interval =\n\t\t((1U << mes_exp) * 1000 + (ucblock_rate / 2)) /\n\t\tucblock_rate;\n\tcxd2880_tnrdmd_set_cfg(&priv->tnrdmd,\n\t\t\t       CXD2880_TNRDMD_CFG_DVBT2_PER_MES,\n\t\t\t       mes_exp);\n\n\treturn 0;\n\nerror_ber_setting:\n\tpriv->pre_ber_interval = 1000;\n\tcxd2880_tnrdmd_set_cfg(&priv->tnrdmd,\n\t\t\t\t     CXD2880_TNRDMD_CFG_DVBT2_LBER_MES, 0);\n\n\tpriv->post_ber_interval = 1000;\n\tcxd2880_tnrdmd_set_cfg(&priv->tnrdmd,\n\t\t\t       CXD2880_TNRDMD_CFG_DVBT2_BBER_MES, 0);\n\nerror_ucblock_setting:\n\tpriv->ucblock_interval = 1000;\n\tcxd2880_tnrdmd_set_cfg(&priv->tnrdmd,\n\t\t\t       CXD2880_TNRDMD_CFG_DVBT2_PER_MES, 8);\n\n\treturn 0;\n}\n\nstatic int cxd2880_dvbt_tune(struct cxd2880_tnrdmd *tnr_dmd,\n\t\t\t     struct cxd2880_dvbt_tune_param\n\t\t\t     *tune_param)\n{\n\tint ret;\n\n\tif (!tnr_dmd || !tune_param)\n\t\treturn -EINVAL;\n\n\tif (tnr_dmd->diver_mode == CXD2880_TNRDMD_DIVERMODE_SUB)\n\t\treturn -EINVAL;\n\n\tif (tnr_dmd->state != CXD2880_TNRDMD_STATE_SLEEP &&\n\t    tnr_dmd->state != CXD2880_TNRDMD_STATE_ACTIVE)\n\t\treturn -EINVAL;\n\n\tatomic_set(&tnr_dmd->cancel, 0);\n\n\tif (tune_param->bandwidth != CXD2880_DTV_BW_5_MHZ &&\n\t    tune_param->bandwidth != CXD2880_DTV_BW_6_MHZ &&\n\t    tune_param->bandwidth != CXD2880_DTV_BW_7_MHZ &&\n\t    tune_param->bandwidth != CXD2880_DTV_BW_8_MHZ) {\n\t\treturn -ENOTTY;\n\t}\n\n\tret = cxd2880_tnrdmd_dvbt_tune1(tnr_dmd, tune_param);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(CXD2880_TNRDMD_WAIT_AGC_STABLE * 10000,\n\t\t     CXD2880_TNRDMD_WAIT_AGC_STABLE * 10000 + 1000);\n\n\treturn cxd2880_tnrdmd_dvbt_tune2(tnr_dmd, tune_param);\n}\n\nstatic int cxd2880_dvbt2_tune(struct cxd2880_tnrdmd *tnr_dmd,\n\t\t\t      struct cxd2880_dvbt2_tune_param\n\t\t\t      *tune_param)\n{\n\tint ret;\n\n\tif (!tnr_dmd || !tune_param)\n\t\treturn -EINVAL;\n\n\tif (tnr_dmd->diver_mode == CXD2880_TNRDMD_DIVERMODE_SUB)\n\t\treturn -EINVAL;\n\n\tif (tnr_dmd->state != CXD2880_TNRDMD_STATE_SLEEP &&\n\t    tnr_dmd->state != CXD2880_TNRDMD_STATE_ACTIVE)\n\t\treturn -EINVAL;\n\n\tatomic_set(&tnr_dmd->cancel, 0);\n\n\tif (tune_param->bandwidth != CXD2880_DTV_BW_1_7_MHZ &&\n\t    tune_param->bandwidth != CXD2880_DTV_BW_5_MHZ &&\n\t    tune_param->bandwidth != CXD2880_DTV_BW_6_MHZ &&\n\t    tune_param->bandwidth != CXD2880_DTV_BW_7_MHZ &&\n\t    tune_param->bandwidth != CXD2880_DTV_BW_8_MHZ) {\n\t\treturn -ENOTTY;\n\t}\n\n\tif (tune_param->profile != CXD2880_DVBT2_PROFILE_BASE &&\n\t    tune_param->profile != CXD2880_DVBT2_PROFILE_LITE)\n\t\treturn -EINVAL;\n\n\tret = cxd2880_tnrdmd_dvbt2_tune1(tnr_dmd, tune_param);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(CXD2880_TNRDMD_WAIT_AGC_STABLE * 10000,\n\t\t     CXD2880_TNRDMD_WAIT_AGC_STABLE * 10000 + 1000);\n\n\treturn cxd2880_tnrdmd_dvbt2_tune2(tnr_dmd, tune_param);\n}\n\nstatic int cxd2880_set_frontend(struct dvb_frontend *fe)\n{\n\tint ret;\n\tstruct dtv_frontend_properties *c;\n\tstruct cxd2880_priv *priv;\n\tenum cxd2880_dtv_bandwidth bw = CXD2880_DTV_BW_1_7_MHZ;\n\n\tif (!fe) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\tc = &fe->dtv_property_cache;\n\n\tc->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->pre_bit_error.stat[0].uvalue = 0;\n\tc->pre_bit_error.len = 1;\n\tc->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->pre_bit_count.stat[0].uvalue = 0;\n\tc->pre_bit_count.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.stat[0].uvalue = 0;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.stat[0].uvalue = 0;\n\tc->post_bit_count.len = 1;\n\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_error.stat[0].uvalue = 0;\n\tc->block_error.len = 1;\n\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_count.stat[0].uvalue = 0;\n\tc->block_count.len = 1;\n\n\tswitch (c->bandwidth_hz) {\n\tcase 1712000:\n\t\tbw = CXD2880_DTV_BW_1_7_MHZ;\n\t\tbreak;\n\tcase 5000000:\n\t\tbw = CXD2880_DTV_BW_5_MHZ;\n\t\tbreak;\n\tcase 6000000:\n\t\tbw = CXD2880_DTV_BW_6_MHZ;\n\t\tbreak;\n\tcase 7000000:\n\t\tbw = CXD2880_DTV_BW_7_MHZ;\n\t\tbreak;\n\tcase 8000000:\n\t\tbw = CXD2880_DTV_BW_8_MHZ;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->s = 0;\n\n\tpr_info(\"sys:%d freq:%d bw:%d\\n\",\n\t\tc->delivery_system, c->frequency, bw);\n\tmutex_lock(priv->spi_mutex);\n\tif (c->delivery_system == SYS_DVBT) {\n\t\tpriv->tnrdmd.sys = CXD2880_DTV_SYS_DVBT;\n\t\tpriv->dvbt_tune_param.center_freq_khz = c->frequency / 1000;\n\t\tpriv->dvbt_tune_param.bandwidth = bw;\n\t\tpriv->dvbt_tune_param.profile = CXD2880_DVBT_PROFILE_HP;\n\t\tret = cxd2880_dvbt_tune(&priv->tnrdmd,\n\t\t\t\t\t&priv->dvbt_tune_param);\n\t} else if (c->delivery_system == SYS_DVBT2) {\n\t\tpriv->tnrdmd.sys = CXD2880_DTV_SYS_DVBT2;\n\t\tpriv->dvbt2_tune_param.center_freq_khz = c->frequency / 1000;\n\t\tpriv->dvbt2_tune_param.bandwidth = bw;\n\t\tpriv->dvbt2_tune_param.data_plp_id = (u16)c->stream_id;\n\t\tpriv->dvbt2_tune_param.profile = CXD2880_DVBT2_PROFILE_BASE;\n\t\tret = cxd2880_dvbt2_tune(&priv->tnrdmd,\n\t\t\t\t\t &priv->dvbt2_tune_param);\n\t} else {\n\t\tpr_err(\"invalid system\\n\");\n\t\tmutex_unlock(priv->spi_mutex);\n\t\treturn -EINVAL;\n\t}\n\tmutex_unlock(priv->spi_mutex);\n\n\tpr_info(\"tune result %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int cxd2880_get_stats(struct dvb_frontend *fe,\n\t\t\t     enum fe_status status)\n{\n\tstruct cxd2880_priv *priv = NULL;\n\tstruct dtv_frontend_properties *c = NULL;\n\tu32 pre_bit_err = 0, pre_bit_count = 0;\n\tu32 post_bit_err = 0, post_bit_count = 0;\n\tu32 block_err = 0, block_count = 0;\n\tint ret;\n\n\tif (!fe) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\tc = &fe->dtv_property_cache;\n\n\tif (!(status & FE_HAS_LOCK) || !(status & FE_HAS_CARRIER)) {\n\t\tc->pre_bit_error.len = 1;\n\t\tc->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->pre_bit_count.len = 1;\n\t\tc->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_error.len = 1;\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.len = 1;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_error.len = 1;\n\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_count.len = 1;\n\t\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\t\treturn 0;\n\t}\n\n\tif (time_after(jiffies, priv->pre_ber_update)) {\n\t\tpriv->pre_ber_update =\n\t\t\t jiffies + msecs_to_jiffies(priv->pre_ber_interval);\n\t\tif (c->delivery_system == SYS_DVBT) {\n\t\t\tmutex_lock(priv->spi_mutex);\n\t\t\tret = cxd2880_pre_bit_err_t(&priv->tnrdmd,\n\t\t\t\t\t\t    &pre_bit_err,\n\t\t\t\t\t\t    &pre_bit_count);\n\t\t\tmutex_unlock(priv->spi_mutex);\n\t\t} else if (c->delivery_system == SYS_DVBT2) {\n\t\t\tmutex_lock(priv->spi_mutex);\n\t\t\tret = cxd2880_pre_bit_err_t2(&priv->tnrdmd,\n\t\t\t\t\t\t     &pre_bit_err,\n\t\t\t\t\t\t     &pre_bit_count);\n\t\t\tmutex_unlock(priv->spi_mutex);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!ret) {\n\t\t\tc->pre_bit_error.len = 1;\n\t\t\tc->pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->pre_bit_error.stat[0].uvalue += pre_bit_err;\n\t\t\tc->pre_bit_count.len = 1;\n\t\t\tc->pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->pre_bit_count.stat[0].uvalue += pre_bit_count;\n\t\t} else {\n\t\t\tc->pre_bit_error.len = 1;\n\t\t\tc->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t\tc->pre_bit_count.len = 1;\n\t\t\tc->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t\tpr_debug(\"pre_bit_error_t failed %d\\n\", ret);\n\t\t}\n\t}\n\n\tif (time_after(jiffies, priv->post_ber_update)) {\n\t\tpriv->post_ber_update =\n\t\t\tjiffies + msecs_to_jiffies(priv->post_ber_interval);\n\t\tif (c->delivery_system == SYS_DVBT) {\n\t\t\tmutex_lock(priv->spi_mutex);\n\t\t\tret = cxd2880_post_bit_err_t(&priv->tnrdmd,\n\t\t\t\t\t\t     &post_bit_err,\n\t\t\t\t\t\t     &post_bit_count);\n\t\t\tmutex_unlock(priv->spi_mutex);\n\t\t} else if (c->delivery_system == SYS_DVBT2) {\n\t\t\tmutex_lock(priv->spi_mutex);\n\t\t\tret = cxd2880_post_bit_err_t2(&priv->tnrdmd,\n\t\t\t\t\t\t      &post_bit_err,\n\t\t\t\t\t\t      &post_bit_count);\n\t\t\tmutex_unlock(priv->spi_mutex);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!ret) {\n\t\t\tc->post_bit_error.len = 1;\n\t\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_error.stat[0].uvalue += post_bit_err;\n\t\t\tc->post_bit_count.len = 1;\n\t\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->post_bit_count.stat[0].uvalue += post_bit_count;\n\t\t} else {\n\t\t\tc->post_bit_error.len = 1;\n\t\t\tc->post_bit_error.stat[0].scale =\n\t\t\t\t\t\t\tFE_SCALE_NOT_AVAILABLE;\n\t\t\tc->post_bit_count.len = 1;\n\t\t\tc->post_bit_count.stat[0].scale =\n\t\t\t\t\t\t\tFE_SCALE_NOT_AVAILABLE;\n\t\t\tpr_debug(\"post_bit_err_t %d\\n\", ret);\n\t\t}\n\t}\n\n\tif (time_after(jiffies, priv->ucblock_update)) {\n\t\tpriv->ucblock_update =\n\t\t\tjiffies + msecs_to_jiffies(priv->ucblock_interval);\n\t\tif (c->delivery_system == SYS_DVBT) {\n\t\t\tmutex_lock(priv->spi_mutex);\n\t\t\tret = cxd2880_read_block_err_t(&priv->tnrdmd,\n\t\t\t\t\t\t       &block_err,\n\t\t\t\t\t\t       &block_count);\n\t\t\tmutex_unlock(priv->spi_mutex);\n\t\t} else if (c->delivery_system == SYS_DVBT2) {\n\t\t\tmutex_lock(priv->spi_mutex);\n\t\t\tret = cxd2880_read_block_err_t2(&priv->tnrdmd,\n\t\t\t\t\t\t\t&block_err,\n\t\t\t\t\t\t\t&block_count);\n\t\t\tmutex_unlock(priv->spi_mutex);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!ret) {\n\t\t\tc->block_error.len = 1;\n\t\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->block_error.stat[0].uvalue += block_err;\n\t\t\tc->block_count.len = 1;\n\t\t\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->block_count.stat[0].uvalue += block_count;\n\t\t} else {\n\t\t\tc->block_error.len = 1;\n\t\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t\tc->block_count.len = 1;\n\t\t\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t\tpr_debug(\"read_block_err_t  %d\\n\", ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cxd2880_check_l1post_plp(struct dvb_frontend *fe)\n{\n\tu8 valid = 0;\n\tu8 plp_not_found;\n\tint ret;\n\tstruct cxd2880_priv *priv = NULL;\n\n\tif (!fe) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\n\tret = cxd2880_tnrdmd_dvbt2_check_l1post_valid(&priv->tnrdmd,\n\t\t\t\t\t\t      &valid);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!valid)\n\t\treturn -EAGAIN;\n\n\tret = cxd2880_tnrdmd_dvbt2_mon_data_plp_error(&priv->tnrdmd,\n\t\t\t\t\t\t      &plp_not_found);\n\tif (ret)\n\t\treturn ret;\n\n\tif (plp_not_found) {\n\t\tpriv->dvbt2_tune_param.tune_info =\n\t\t\tCXD2880_TNRDMD_DVBT2_TUNE_INFO_INVALID_PLP_ID;\n\t} else {\n\t\tpriv->dvbt2_tune_param.tune_info =\n\t\t\tCXD2880_TNRDMD_DVBT2_TUNE_INFO_OK;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxd2880_read_status(struct dvb_frontend *fe,\n\t\t\t       enum fe_status *status)\n{\n\tint ret;\n\tu8 sync = 0;\n\tu8 lock = 0;\n\tu8 unlock = 0;\n\tstruct cxd2880_priv *priv = NULL;\n\tstruct dtv_frontend_properties *c = NULL;\n\n\tif (!fe || !status) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\tc = &fe->dtv_property_cache;\n\t*status = 0;\n\n\tif (priv->tnrdmd.state == CXD2880_TNRDMD_STATE_ACTIVE) {\n\t\tmutex_lock(priv->spi_mutex);\n\t\tif (c->delivery_system == SYS_DVBT) {\n\t\t\tret = cxd2880_tnrdmd_dvbt_mon_sync_stat(&priv->tnrdmd,\n\t\t\t\t\t\t\t\t&sync,\n\t\t\t\t\t\t\t\t&lock,\n\t\t\t\t\t\t\t\t&unlock);\n\t\t} else if (c->delivery_system == SYS_DVBT2) {\n\t\t\tret = cxd2880_tnrdmd_dvbt2_mon_sync_stat(&priv->tnrdmd,\n\t\t\t\t\t\t\t\t &sync,\n\t\t\t\t\t\t\t\t &lock,\n\t\t\t\t\t\t\t\t &unlock);\n\t\t} else {\n\t\t\tpr_err(\"invalid system\");\n\t\t\tmutex_unlock(priv->spi_mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmutex_unlock(priv->spi_mutex);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed. sys = %d\\n\", priv->tnrdmd.sys);\n\t\t\treturn  ret;\n\t\t}\n\n\t\tif (sync == 6) {\n\t\t\t*status = FE_HAS_SIGNAL |\n\t\t\t\t  FE_HAS_CARRIER;\n\t\t}\n\t\tif (lock)\n\t\t\t*status |= FE_HAS_VITERBI |\n\t\t\t\t   FE_HAS_SYNC |\n\t\t\t\t   FE_HAS_LOCK;\n\t}\n\n\tpr_debug(\"status %d\\n\", *status);\n\n\tif (priv->s == 0 && (*status & FE_HAS_LOCK) &&\n\t    (*status & FE_HAS_CARRIER)) {\n\t\tmutex_lock(priv->spi_mutex);\n\t\tif (c->delivery_system == SYS_DVBT) {\n\t\t\tret = cxd2880_set_ber_per_period_t(fe);\n\t\t\tpriv->s = *status;\n\t\t} else if (c->delivery_system == SYS_DVBT2) {\n\t\t\tret = cxd2880_check_l1post_plp(fe);\n\t\t\tif (!ret) {\n\t\t\t\tret = cxd2880_set_ber_per_period_t2(fe);\n\t\t\t\tpriv->s = *status;\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err(\"invalid system\\n\");\n\t\t\tmutex_unlock(priv->spi_mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmutex_unlock(priv->spi_mutex);\n\t}\n\n\tcxd2880_get_stats(fe, *status);\n\treturn  0;\n}\n\nstatic int cxd2880_tune(struct dvb_frontend *fe,\n\t\t\tbool retune,\n\t\t\tunsigned int mode_flags,\n\t\t\tunsigned int *delay,\n\t\t\tenum fe_status *status)\n{\n\tint ret;\n\n\tif (!fe || !delay || !status) {\n\t\tpr_err(\"invalid arg.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (retune) {\n\t\tret = cxd2880_set_frontend(fe);\n\t\tif (ret) {\n\t\t\tpr_err(\"cxd2880_set_frontend failed %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t*delay = HZ / 5;\n\n\treturn cxd2880_read_status(fe, status);\n}\n\nstatic int cxd2880_get_frontend_t(struct dvb_frontend *fe,\n\t\t\t\t  struct dtv_frontend_properties *c)\n{\n\tint ret;\n\tstruct cxd2880_priv *priv = NULL;\n\tenum cxd2880_dvbt_mode mode = CXD2880_DVBT_MODE_2K;\n\tenum cxd2880_dvbt_guard guard = CXD2880_DVBT_GUARD_1_32;\n\tstruct cxd2880_dvbt_tpsinfo tps;\n\tenum cxd2880_tnrdmd_spectrum_sense sense;\n\tu16 snr = 0;\n\tint strength = 0;\n\n\tif (!fe || !c) {\n\t\tpr_err(\"invalid arg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\n\tmutex_lock(priv->spi_mutex);\n\tret = cxd2880_tnrdmd_dvbt_mon_mode_guard(&priv->tnrdmd,\n\t\t\t\t\t\t &mode, &guard);\n\tmutex_unlock(priv->spi_mutex);\n\tif (!ret) {\n\t\tswitch (mode) {\n\t\tcase CXD2880_DVBT_MODE_2K:\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_MODE_8K:\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\t\tpr_debug(\"transmission mode is invalid %d\\n\", mode);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (guard) {\n\t\tcase CXD2880_DVBT_GUARD_1_32:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_GUARD_1_16:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_16;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_GUARD_1_8:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_GUARD_1_4:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\t\tpr_debug(\"guard interval is invalid %d\\n\",\n\t\t\t\t guard);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\tpr_debug(\"ModeGuard err %d\\n\", ret);\n\t}\n\n\tmutex_lock(priv->spi_mutex);\n\tret = cxd2880_tnrdmd_dvbt_mon_tps_info(&priv->tnrdmd, &tps);\n\tmutex_unlock(priv->spi_mutex);\n\tif (!ret) {\n\t\tswitch (tps.hierarchy) {\n\t\tcase CXD2880_DVBT_HIERARCHY_NON:\n\t\t\tc->hierarchy = HIERARCHY_NONE;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_HIERARCHY_1:\n\t\t\tc->hierarchy = HIERARCHY_1;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_HIERARCHY_2:\n\t\t\tc->hierarchy = HIERARCHY_2;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_HIERARCHY_4:\n\t\t\tc->hierarchy = HIERARCHY_4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->hierarchy = HIERARCHY_NONE;\n\t\t\tpr_debug(\"TPSInfo hierarchy is invalid %d\\n\",\n\t\t\t\t tps.hierarchy);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (tps.rate_hp) {\n\t\tcase CXD2880_DVBT_CODERATE_1_2:\n\t\t\tc->code_rate_HP = FEC_1_2;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_CODERATE_2_3:\n\t\t\tc->code_rate_HP = FEC_2_3;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_CODERATE_3_4:\n\t\t\tc->code_rate_HP = FEC_3_4;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_CODERATE_5_6:\n\t\t\tc->code_rate_HP = FEC_5_6;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_CODERATE_7_8:\n\t\t\tc->code_rate_HP = FEC_7_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->code_rate_HP = FEC_NONE;\n\t\t\tpr_debug(\"TPSInfo rateHP is invalid %d\\n\",\n\t\t\t\t tps.rate_hp);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (tps.rate_lp) {\n\t\tcase CXD2880_DVBT_CODERATE_1_2:\n\t\t\tc->code_rate_LP = FEC_1_2;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_CODERATE_2_3:\n\t\t\tc->code_rate_LP = FEC_2_3;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_CODERATE_3_4:\n\t\t\tc->code_rate_LP = FEC_3_4;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_CODERATE_5_6:\n\t\t\tc->code_rate_LP = FEC_5_6;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_CODERATE_7_8:\n\t\t\tc->code_rate_LP = FEC_7_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->code_rate_LP = FEC_NONE;\n\t\t\tpr_debug(\"TPSInfo rateLP is invalid %d\\n\",\n\t\t\t\t tps.rate_lp);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (tps.constellation) {\n\t\tcase CXD2880_DVBT_CONSTELLATION_QPSK:\n\t\t\tc->modulation = QPSK;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_CONSTELLATION_16QAM:\n\t\t\tc->modulation = QAM_16;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT_CONSTELLATION_64QAM:\n\t\t\tc->modulation = QAM_64;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->modulation = QPSK;\n\t\t\tpr_debug(\"TPSInfo constellation is invalid %d\\n\",\n\t\t\t\t tps.constellation);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tc->hierarchy = HIERARCHY_NONE;\n\t\tc->code_rate_HP = FEC_NONE;\n\t\tc->code_rate_LP = FEC_NONE;\n\t\tc->modulation = QPSK;\n\t\tpr_debug(\"TPS info err %d\\n\", ret);\n\t}\n\n\tmutex_lock(priv->spi_mutex);\n\tret = cxd2880_tnrdmd_dvbt_mon_spectrum_sense(&priv->tnrdmd, &sense);\n\tmutex_unlock(priv->spi_mutex);\n\tif (!ret) {\n\t\tswitch (sense) {\n\t\tcase CXD2880_TNRDMD_SPECTRUM_NORMAL:\n\t\t\tc->inversion = INVERSION_OFF;\n\t\t\tbreak;\n\t\tcase CXD2880_TNRDMD_SPECTRUM_INV:\n\t\t\tc->inversion = INVERSION_ON;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->inversion = INVERSION_OFF;\n\t\t\tpr_debug(\"spectrum sense is invalid %d\\n\", sense);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tc->inversion = INVERSION_OFF;\n\t\tpr_debug(\"spectrum_sense %d\\n\", ret);\n\t}\n\n\tmutex_lock(priv->spi_mutex);\n\tret = cxd2880_tnrdmd_mon_rf_lvl(&priv->tnrdmd, &strength);\n\tmutex_unlock(priv->spi_mutex);\n\tif (!ret) {\n\t\tc->strength.len = 1;\n\t\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->strength.stat[0].svalue = strength;\n\t} else {\n\t\tc->strength.len = 1;\n\t\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tpr_debug(\"mon_rf_lvl %d\\n\", ret);\n\t}\n\n\tret = cxd2880_read_snr(fe, &snr);\n\tif (!ret) {\n\t\tc->cnr.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[0].svalue = snr;\n\t} else {\n\t\tc->cnr.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tpr_debug(\"read_snr %d\\n\", ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int cxd2880_get_frontend_t2(struct dvb_frontend *fe,\n\t\t\t\t   struct dtv_frontend_properties *c)\n{\n\tint ret;\n\tstruct cxd2880_priv *priv = NULL;\n\tstruct cxd2880_dvbt2_l1pre l1pre;\n\tenum cxd2880_dvbt2_plp_code_rate coderate;\n\tenum cxd2880_dvbt2_plp_constell qam;\n\tenum cxd2880_tnrdmd_spectrum_sense sense;\n\tu16 snr = 0;\n\tint strength = 0;\n\n\tif (!fe || !c) {\n\t\tpr_err(\"invalid arg.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = fe->demodulator_priv;\n\n\tmutex_lock(priv->spi_mutex);\n\tret = cxd2880_tnrdmd_dvbt2_mon_l1_pre(&priv->tnrdmd, &l1pre);\n\tmutex_unlock(priv->spi_mutex);\n\tif (!ret) {\n\t\tswitch (l1pre.fft_mode) {\n\t\tcase CXD2880_DVBT2_M2K:\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_M8K:\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_M4K:\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_4K;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_M1K:\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_1K;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_M16K:\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_16K;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_M32K:\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_32K;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\t\tpr_debug(\"L1Pre fft_mode is invalid %d\\n\",\n\t\t\t\t l1pre.fft_mode);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (l1pre.gi) {\n\t\tcase CXD2880_DVBT2_G1_32:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_G1_16:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_16;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_G1_8:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_G1_4:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_4;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_G1_128:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_128;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_G19_128:\n\t\t\tc->guard_interval = GUARD_INTERVAL_19_128;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_G19_256:\n\t\t\tc->guard_interval = GUARD_INTERVAL_19_256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\t\tpr_debug(\"L1Pre guard interval is invalid %d\\n\",\n\t\t\t\t l1pre.gi);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\tpr_debug(\"L1Pre err %d\\n\", ret);\n\t}\n\n\tmutex_lock(priv->spi_mutex);\n\tret = cxd2880_tnrdmd_dvbt2_mon_code_rate(&priv->tnrdmd,\n\t\t\t\t\t\t CXD2880_DVBT2_PLP_DATA,\n\t\t\t\t\t\t &coderate);\n\tmutex_unlock(priv->spi_mutex);\n\tif (!ret) {\n\t\tswitch (coderate) {\n\t\tcase CXD2880_DVBT2_R1_2:\n\t\t\tc->fec_inner = FEC_1_2;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_R3_5:\n\t\t\tc->fec_inner = FEC_3_5;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_R2_3:\n\t\t\tc->fec_inner = FEC_2_3;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_R3_4:\n\t\t\tc->fec_inner = FEC_3_4;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_R4_5:\n\t\t\tc->fec_inner = FEC_4_5;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_R5_6:\n\t\t\tc->fec_inner = FEC_5_6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->fec_inner = FEC_NONE;\n\t\t\tpr_debug(\"CodeRate is invalid %d\\n\", coderate);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tc->fec_inner = FEC_NONE;\n\t\tpr_debug(\"CodeRate %d\\n\", ret);\n\t}\n\n\tmutex_lock(priv->spi_mutex);\n\tret = cxd2880_tnrdmd_dvbt2_mon_qam(&priv->tnrdmd,\n\t\t\t\t\t   CXD2880_DVBT2_PLP_DATA,\n\t\t\t\t\t   &qam);\n\tmutex_unlock(priv->spi_mutex);\n\tif (!ret) {\n\t\tswitch (qam) {\n\t\tcase CXD2880_DVBT2_QPSK:\n\t\t\tc->modulation = QPSK;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_QAM16:\n\t\t\tc->modulation = QAM_16;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_QAM64:\n\t\t\tc->modulation = QAM_64;\n\t\t\tbreak;\n\t\tcase CXD2880_DVBT2_QAM256:\n\t\t\tc->modulation = QAM_256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->modulation = QPSK;\n\t\t\tpr_debug(\"QAM is invalid %d\\n\", qam);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tc->modulation = QPSK;\n\t\tpr_debug(\"QAM %d\\n\", ret);\n\t}\n\n\tmutex_lock(priv->spi_mutex);\n\tret = cxd2880_tnrdmd_dvbt2_mon_spectrum_sense(&priv->tnrdmd, &sense);\n\tmutex_unlock(priv->spi_mutex);\n\tif (!ret) {\n\t\tswitch (sense) {\n\t\tcase CXD2880_TNRDMD_SPECTRUM_NORMAL:\n\t\t\tc->inversion = INVERSION_OFF;\n\t\t\tbreak;\n\t\tcase CXD2880_TNRDMD_SPECTRUM_INV:\n\t\t\tc->inversion = INVERSION_ON;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc->inversion = INVERSION_OFF;\n\t\t\tpr_debug(\"spectrum sense is invalid %d\\n\", sense);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tc->inversion = INVERSION_OFF;\n\t\tpr_debug(\"SpectrumSense %d\\n\", ret);\n\t}\n\n\tmutex_lock(priv->spi_mutex);\n\tret = cxd2880_tnrdmd_mon_rf_lvl(&priv->tnrdmd, &strength);\n\tmutex_unlock(priv->spi_mutex);\n\tif (!ret) {\n\t\tc->strength.len = 1;\n\t\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->strength.stat[0].svalue = strength;\n\t} else {\n\t\tc->strength.len = 1;\n\t\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tpr_debug(\"mon_rf_lvl %d\\n\", ret);\n\t}\n\n\tret = cxd2880_read_snr(fe, &snr);\n\tif (!ret) {\n\t\tc->cnr.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[0].svalue = snr;\n\t} else {\n\t\tc->cnr.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tpr_debug(\"read_snr %d\\n\", ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int cxd2880_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *props)\n{\n\tint ret;\n\n\tif (!fe || !props) {\n\t\tpr_err(\"invalid arg.\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"system=%d\\n\", fe->dtv_property_cache.delivery_system);\n\tswitch (fe->dtv_property_cache.delivery_system) {\n\tcase SYS_DVBT:\n\t\tret = cxd2880_get_frontend_t(fe, props);\n\t\tbreak;\n\tcase SYS_DVBT2:\n\t\tret = cxd2880_get_frontend_t2(fe, props);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic enum dvbfe_algo cxd2880_get_frontend_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic struct dvb_frontend_ops cxd2880_dvbt_t2_ops = {\n\t.info = {\n\t\t.name = \"Sony CXD2880\",\n\t\t.frequency_min_hz = 174 * MHz,\n\t\t.frequency_max_hz = 862 * MHz,\n\t\t.frequency_stepsize_hz = 1 * kHz,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\t\tFE_CAN_FEC_1_2 |\n\t\t\t\tFE_CAN_FEC_2_3 |\n\t\t\t\tFE_CAN_FEC_3_4 |\n\t\t\t\tFE_CAN_FEC_4_5 |\n\t\t\t\tFE_CAN_FEC_5_6\t|\n\t\t\t\tFE_CAN_FEC_7_8\t|\n\t\t\t\tFE_CAN_FEC_AUTO |\n\t\t\t\tFE_CAN_QPSK |\n\t\t\t\tFE_CAN_QAM_16 |\n\t\t\t\tFE_CAN_QAM_32 |\n\t\t\t\tFE_CAN_QAM_64 |\n\t\t\t\tFE_CAN_QAM_128 |\n\t\t\t\tFE_CAN_QAM_256 |\n\t\t\t\tFE_CAN_QAM_AUTO |\n\t\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\t\tFE_CAN_2G_MODULATION |\n\t\t\t\tFE_CAN_RECOVER |\n\t\t\t\tFE_CAN_MUTE_TS,\n\t},\n\t.delsys = { SYS_DVBT, SYS_DVBT2 },\n\n\t.release = cxd2880_release,\n\t.init = cxd2880_init,\n\t.sleep = cxd2880_sleep,\n\t.tune = cxd2880_tune,\n\t.set_frontend = cxd2880_set_frontend,\n\t.get_frontend = cxd2880_get_frontend,\n\t.read_status = cxd2880_read_status,\n\t.read_ber = cxd2880_read_ber,\n\t.read_signal_strength = cxd2880_read_signal_strength,\n\t.read_snr = cxd2880_read_snr,\n\t.read_ucblocks = cxd2880_read_ucblocks,\n\t.get_frontend_algo = cxd2880_get_frontend_algo,\n};\n\nstruct dvb_frontend *cxd2880_attach(struct dvb_frontend *fe,\n\t\t\t\t    struct cxd2880_config *cfg)\n{\n\tint ret;\n\tenum cxd2880_tnrdmd_chip_id chipid =\n\t\t\t\t\tCXD2880_TNRDMD_CHIP_ID_UNKNOWN;\n\tstatic struct cxd2880_priv *priv;\n\tu8 data = 0;\n\n\tif (!fe) {\n\t\tpr_err(\"invalid arg.\\n\");\n\t\treturn NULL;\n\t}\n\n\tpriv = kzalloc(sizeof(struct cxd2880_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn NULL;\n\n\tpriv->spi = cfg->spi;\n\tpriv->spi_mutex = cfg->spi_mutex;\n\tpriv->spi_device.spi = cfg->spi;\n\n\tmemcpy(&fe->ops, &cxd2880_dvbt_t2_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\n\tret = cxd2880_spi_device_initialize(&priv->spi_device,\n\t\t\t\t\t    CXD2880_SPI_MODE_0,\n\t\t\t\t\t    55000000);\n\tif (ret) {\n\t\tpr_err(\"spi_device_initialize failed. %d\\n\", ret);\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\n\tret = cxd2880_spi_device_create_spi(&priv->cxd2880_spi,\n\t\t\t\t\t    &priv->spi_device);\n\tif (ret) {\n\t\tpr_err(\"spi_device_create_spi failed. %d\\n\", ret);\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\n\tret = cxd2880_io_spi_create(&priv->regio, &priv->cxd2880_spi, 0);\n\tif (ret) {\n\t\tpr_err(\"io_spi_create failed. %d\\n\", ret);\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\tret = priv->regio.write_reg(&priv->regio,\n\t\t\t\t    CXD2880_IO_TGT_SYS, 0x00, 0x00);\n\tif (ret) {\n\t\tpr_err(\"set bank to 0x00 failed.\\n\");\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\tret = priv->regio.read_regs(&priv->regio,\n\t\t\t\t    CXD2880_IO_TGT_SYS, 0xfd, &data, 1);\n\tif (ret) {\n\t\tpr_err(\"read chip id failed.\\n\");\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\n\tchipid = (enum cxd2880_tnrdmd_chip_id)data;\n\tif (chipid != CXD2880_TNRDMD_CHIP_ID_CXD2880_ES1_0X &&\n\t    chipid != CXD2880_TNRDMD_CHIP_ID_CXD2880_ES1_11) {\n\t\tpr_err(\"chip id invalid.\\n\");\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\n\tfe->demodulator_priv = priv;\n\tpr_info(\"CXD2880 driver version: Ver %s\\n\",\n\t\tCXD2880_TNRDMD_DRIVER_VERSION);\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(cxd2880_attach);\n\nMODULE_DESCRIPTION(\"Sony CXD2880 DVB-T2/T tuner + demod driver\");\nMODULE_AUTHOR(\"Sony Semiconductor Solutions Corporation\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}