{
  "module_name": "cxd2880_io.c",
  "hash_id": "a811d47300197f66eb18250977960ea3bbcbf71713da0eee3d2ebc53c9887cb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cxd2880/cxd2880_io.c",
  "human_readable_source": "\n \n\n#include \"cxd2880_io.h\"\n\nint cxd2880_io_common_write_one_reg(struct cxd2880_io *io,\n\t\t\t\t    enum cxd2880_io_tgt tgt,\n\t\t\t\t    u8 sub_address, u8 data)\n{\n\tif (!io)\n\t\treturn -EINVAL;\n\n\treturn io->write_regs(io, tgt, sub_address, &data, 1);\n}\n\nint cxd2880_io_set_reg_bits(struct cxd2880_io *io,\n\t\t\t    enum cxd2880_io_tgt tgt,\n\t\t\t    u8 sub_address, u8 data, u8 mask)\n{\n\tint ret;\n\n\tif (!io)\n\t\treturn -EINVAL;\n\n\tif (mask == 0x00)\n\t\treturn 0;\n\n\tif (mask != 0xff) {\n\t\tu8 rdata = 0x00;\n\n\t\tret = io->read_regs(io, tgt, sub_address, &rdata, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata = (data & mask) | (rdata & (mask ^ 0xff));\n\t}\n\n\treturn io->write_reg(io, tgt, sub_address, data);\n}\n\nint cxd2880_io_write_multi_regs(struct cxd2880_io *io,\n\t\t\t     enum cxd2880_io_tgt tgt,\n\t\t\t     const struct cxd2880_reg_value reg_value[],\n\t\t\t     u8 size)\n{\n\tint ret;\n\tint i;\n\n\tif (!io)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < size ; i++) {\n\t\tret = io->write_reg(io, tgt, reg_value[i].addr,\n\t\t\t\t    reg_value[i].value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}