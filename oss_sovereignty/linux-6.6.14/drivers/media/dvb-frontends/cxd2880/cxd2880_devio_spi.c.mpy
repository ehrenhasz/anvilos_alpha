{
  "module_name": "cxd2880_devio_spi.c",
  "hash_id": "3d00c75a5d1c067ec655a1bcd723937dbbdff71fd6211641ff9774d0bb9813a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cxd2880/cxd2880_devio_spi.c",
  "human_readable_source": "\n \n\n#include \"cxd2880_devio_spi.h\"\n\n#define BURST_WRITE_MAX 128\n\nstatic int cxd2880_io_spi_read_reg(struct cxd2880_io *io,\n\t\t\t\t   enum cxd2880_io_tgt tgt,\n\t\t\t\t   u8 sub_address, u8 *data,\n\t\t\t\t   u32 size)\n{\n\tint ret = 0;\n\tstruct cxd2880_spi *spi = NULL;\n\tu8 send_data[6];\n\tu8 *read_data_top = data;\n\n\tif (!io || !io->if_object || !data)\n\t\treturn -EINVAL;\n\n\tif (sub_address + size > 0x100)\n\t\treturn -EINVAL;\n\n\tspi = io->if_object;\n\n\tif (tgt == CXD2880_IO_TGT_SYS)\n\t\tsend_data[0] = 0x0b;\n\telse\n\t\tsend_data[0] = 0x0a;\n\n\tsend_data[3] = 0;\n\tsend_data[4] = 0;\n\tsend_data[5] = 0;\n\n\twhile (size > 0) {\n\t\tsend_data[1] = sub_address;\n\t\tif (size > 255)\n\t\t\tsend_data[2] = 255;\n\t\telse\n\t\t\tsend_data[2] = size;\n\n\t\tret =\n\t\t    spi->write_read(spi, send_data, sizeof(send_data),\n\t\t\t\t    read_data_top, send_data[2]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsub_address += send_data[2];\n\t\tread_data_top += send_data[2];\n\t\tsize -= send_data[2];\n\t}\n\n\treturn ret;\n}\n\nstatic int cxd2880_io_spi_write_reg(struct cxd2880_io *io,\n\t\t\t\t    enum cxd2880_io_tgt tgt,\n\t\t\t\t    u8 sub_address,\n\t\t\t\t    const u8 *data, u32 size)\n{\n\tint ret = 0;\n\tstruct cxd2880_spi *spi = NULL;\n\tu8 send_data[BURST_WRITE_MAX + 4];\n\tconst u8 *write_data_top = data;\n\n\tif (!io || !io->if_object || !data)\n\t\treturn -EINVAL;\n\n\tif (size > BURST_WRITE_MAX)\n\t\treturn -EINVAL;\n\n\tif (sub_address + size > 0x100)\n\t\treturn -EINVAL;\n\n\tspi = io->if_object;\n\n\tif (tgt == CXD2880_IO_TGT_SYS)\n\t\tsend_data[0] = 0x0f;\n\telse\n\t\tsend_data[0] = 0x0e;\n\n\twhile (size > 0) {\n\t\tsend_data[1] = sub_address;\n\t\tif (size > 255)\n\t\t\tsend_data[2] = 255;\n\t\telse\n\t\t\tsend_data[2] = size;\n\n\t\tmemcpy(&send_data[3], write_data_top, send_data[2]);\n\n\t\tif (tgt == CXD2880_IO_TGT_SYS) {\n\t\t\tsend_data[3 + send_data[2]] = 0x00;\n\t\t\tret = spi->write(spi, send_data, send_data[2] + 4);\n\t\t} else {\n\t\t\tret = spi->write(spi, send_data, send_data[2] + 3);\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsub_address += send_data[2];\n\t\twrite_data_top += send_data[2];\n\t\tsize -= send_data[2];\n\t}\n\n\treturn ret;\n}\n\nint cxd2880_io_spi_create(struct cxd2880_io *io,\n\t\t\t  struct cxd2880_spi *spi, u8 slave_select)\n{\n\tif (!io || !spi)\n\t\treturn -EINVAL;\n\n\tio->read_regs = cxd2880_io_spi_read_reg;\n\tio->write_regs = cxd2880_io_spi_write_reg;\n\tio->write_reg = cxd2880_io_common_write_one_reg;\n\tio->if_object = spi;\n\tio->i2c_address_sys = 0;\n\tio->i2c_address_demod = 0;\n\tio->slave_select = slave_select;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}