{
  "module_name": "lgdt3305.c",
  "hash_id": "3638f4ee6c49c1a94133f5ea10152605ebbf21ced9bd9632070b65e5fa94ccae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/lgdt3305.c",
  "human_readable_source": "\n \n\n#include <asm/div64.h>\n#include <linux/dvb/frontend.h>\n#include <linux/slab.h>\n#include <linux/int_log.h>\n#include \"lgdt3305.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debug level (info=1, reg=2 (or-able))\");\n\n#define DBG_INFO 1\n#define DBG_REG  2\n\n#define lg_printk(kern, fmt, arg...)\t\t\t\t\t\\\n\tprintk(kern \"%s: \" fmt, __func__, ##arg)\n\n#define lg_info(fmt, arg...)\tprintk(KERN_INFO \"lgdt3305: \" fmt, ##arg)\n#define lg_warn(fmt, arg...)\tlg_printk(KERN_WARNING,       fmt, ##arg)\n#define lg_err(fmt, arg...)\tlg_printk(KERN_ERR,           fmt, ##arg)\n#define lg_dbg(fmt, arg...) if (debug & DBG_INFO)\t\t\t\\\n\t\t\t\tlg_printk(KERN_DEBUG,         fmt, ##arg)\n#define lg_reg(fmt, arg...) if (debug & DBG_REG)\t\t\t\\\n\t\t\t\tlg_printk(KERN_DEBUG,         fmt, ##arg)\n\n#define lg_fail(ret)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __ret;\t\t\t\t\t\t\t\\\n\t__ret = (ret < 0);\t\t\t\t\t\t\\\n\tif (__ret)\t\t\t\t\t\t\t\\\n\t\tlg_err(\"error %d on line %d\\n\",\tret, __LINE__);\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\nstruct lgdt3305_state {\n\tstruct i2c_adapter *i2c_adap;\n\tconst struct lgdt3305_config *cfg;\n\n\tstruct dvb_frontend frontend;\n\n\tenum fe_modulation current_modulation;\n\tu32 current_frequency;\n\tu32 snr;\n};\n\n \n\n \n\n#define LGDT3305_GEN_CTRL_1                   0x0000\n#define LGDT3305_GEN_CTRL_2                   0x0001\n#define LGDT3305_GEN_CTRL_3                   0x0002\n#define LGDT3305_GEN_STATUS                   0x0003\n#define LGDT3305_GEN_CONTROL                  0x0007\n#define LGDT3305_GEN_CTRL_4                   0x000a\n#define LGDT3305_DGTL_AGC_REF_1               0x0012\n#define LGDT3305_DGTL_AGC_REF_2               0x0013\n#define LGDT3305_CR_CTR_FREQ_1                0x0106\n#define LGDT3305_CR_CTR_FREQ_2                0x0107\n#define LGDT3305_CR_CTR_FREQ_3                0x0108\n#define LGDT3305_CR_CTR_FREQ_4                0x0109\n#define LGDT3305_CR_MSE_1                     0x011b\n#define LGDT3305_CR_MSE_2                     0x011c\n#define LGDT3305_CR_LOCK_STATUS               0x011d\n#define LGDT3305_CR_CTRL_7                    0x0126\n#define LGDT3305_AGC_POWER_REF_1              0x0300\n#define LGDT3305_AGC_POWER_REF_2              0x0301\n#define LGDT3305_AGC_DELAY_PT_1               0x0302\n#define LGDT3305_AGC_DELAY_PT_2               0x0303\n#define LGDT3305_RFAGC_LOOP_FLTR_BW_1         0x0306\n#define LGDT3305_RFAGC_LOOP_FLTR_BW_2         0x0307\n#define LGDT3305_IFBW_1                       0x0308\n#define LGDT3305_IFBW_2                       0x0309\n#define LGDT3305_AGC_CTRL_1                   0x030c\n#define LGDT3305_AGC_CTRL_4                   0x0314\n#define LGDT3305_EQ_MSE_1                     0x0413\n#define LGDT3305_EQ_MSE_2                     0x0414\n#define LGDT3305_EQ_MSE_3                     0x0415\n#define LGDT3305_PT_MSE_1                     0x0417\n#define LGDT3305_PT_MSE_2                     0x0418\n#define LGDT3305_PT_MSE_3                     0x0419\n#define LGDT3305_FEC_BLOCK_CTRL               0x0504\n#define LGDT3305_FEC_LOCK_STATUS              0x050a\n#define LGDT3305_FEC_PKT_ERR_1                0x050c\n#define LGDT3305_FEC_PKT_ERR_2                0x050d\n#define LGDT3305_TP_CTRL_1                    0x050e\n#define LGDT3305_BERT_PERIOD                  0x0801\n#define LGDT3305_BERT_ERROR_COUNT_1           0x080a\n#define LGDT3305_BERT_ERROR_COUNT_2           0x080b\n#define LGDT3305_BERT_ERROR_COUNT_3           0x080c\n#define LGDT3305_BERT_ERROR_COUNT_4           0x080d\n\nstatic int lgdt3305_write_reg(struct lgdt3305_state *state, u16 reg, u8 val)\n{\n\tint ret;\n\tu8 buf[] = { reg >> 8, reg & 0xff, val };\n\tstruct i2c_msg msg = {\n\t\t.addr = state->cfg->i2c_addr, .flags = 0,\n\t\t.buf = buf, .len = 3,\n\t};\n\n\tlg_reg(\"reg: 0x%04x, val: 0x%02x\\n\", reg, val);\n\n\tret = i2c_transfer(state->i2c_adap, &msg, 1);\n\n\tif (ret != 1) {\n\t\tlg_err(\"error (addr %02x %02x <- %02x, err = %i)\\n\",\n\t\t       msg.buf[0], msg.buf[1], msg.buf[2], ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int lgdt3305_read_reg(struct lgdt3305_state *state, u16 reg, u8 *val)\n{\n\tint ret;\n\tu8 reg_buf[] = { reg >> 8, reg & 0xff };\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->cfg->i2c_addr,\n\t\t  .flags = 0, .buf = reg_buf, .len = 2 },\n\t\t{ .addr = state->cfg->i2c_addr,\n\t\t  .flags = I2C_M_RD, .buf = val, .len = 1 },\n\t};\n\n\tlg_reg(\"reg: 0x%04x\\n\", reg);\n\n\tret = i2c_transfer(state->i2c_adap, msg, 2);\n\n\tif (ret != 2) {\n\t\tlg_err(\"error (addr %02x reg %04x error (ret == %i)\\n\",\n\t\t       state->cfg->i2c_addr, reg, ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\n#define read_reg(state, reg)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tu8 __val;\t\t\t\t\t\t\t\\\n\tint ret = lgdt3305_read_reg(state, reg, &__val);\t\t\\\n\tif (lg_fail(ret))\t\t\t\t\t\t\\\n\t\t__val = 0;\t\t\t\t\t\t\\\n\t__val;\t\t\t\t\t\t\t\t\\\n})\n\nstatic int lgdt3305_set_reg_bit(struct lgdt3305_state *state,\n\t\t\t\tu16 reg, int bit, int onoff)\n{\n\tu8 val;\n\tint ret;\n\n\tlg_reg(\"reg: 0x%04x, bit: %d, level: %d\\n\", reg, bit, onoff);\n\n\tret = lgdt3305_read_reg(state, reg, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= ~(1 << bit);\n\tval |= (onoff & 1) << bit;\n\n\tret = lgdt3305_write_reg(state, reg, val);\nfail:\n\treturn ret;\n}\n\nstruct lgdt3305_reg {\n\tu16 reg;\n\tu8 val;\n};\n\nstatic int lgdt3305_write_regs(struct lgdt3305_state *state,\n\t\t\t       struct lgdt3305_reg *regs, int len)\n{\n\tint i, ret;\n\n\tlg_reg(\"writing %d registers...\\n\", len);\n\n\tfor (i = 0; i < len - 1; i++) {\n\t\tret = lgdt3305_write_reg(state, regs[i].reg, regs[i].val);\n\t\tif (lg_fail(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int lgdt3305_soft_reset(struct lgdt3305_state *state)\n{\n\tint ret;\n\n\tlg_dbg(\"\\n\");\n\n\tret = lgdt3305_set_reg_bit(state, LGDT3305_GEN_CTRL_3, 0, 0);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tmsleep(20);\n\tret = lgdt3305_set_reg_bit(state, LGDT3305_GEN_CTRL_3, 0, 1);\nfail:\n\treturn ret;\n}\n\nstatic inline int lgdt3305_mpeg_mode(struct lgdt3305_state *state,\n\t\t\t\t     enum lgdt3305_mpeg_mode mode)\n{\n\tlg_dbg(\"(%d)\\n\", mode);\n\treturn lgdt3305_set_reg_bit(state, LGDT3305_TP_CTRL_1, 5, mode);\n}\n\nstatic int lgdt3305_mpeg_mode_polarity(struct lgdt3305_state *state)\n{\n\tu8 val;\n\tint ret;\n\tenum lgdt3305_tp_clock_edge edge = state->cfg->tpclk_edge;\n\tenum lgdt3305_tp_clock_mode mode = state->cfg->tpclk_mode;\n\tenum lgdt3305_tp_valid_polarity valid = state->cfg->tpvalid_polarity;\n\n\tlg_dbg(\"edge = %d, valid = %d\\n\", edge, valid);\n\n\tret = lgdt3305_read_reg(state, LGDT3305_TP_CTRL_1, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tval &= ~0x09;\n\n\tif (edge)\n\t\tval |= 0x08;\n\tif (mode)\n\t\tval |= 0x40;\n\tif (valid)\n\t\tval |= 0x01;\n\n\tret = lgdt3305_write_reg(state, LGDT3305_TP_CTRL_1, val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lgdt3305_soft_reset(state);\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3305_set_modulation(struct lgdt3305_state *state,\n\t\t\t\t   struct dtv_frontend_properties *p)\n{\n\tu8 opermode;\n\tint ret;\n\n\tlg_dbg(\"\\n\");\n\n\tret = lgdt3305_read_reg(state, LGDT3305_GEN_CTRL_1, &opermode);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\topermode &= ~0x03;\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\topermode |= 0x03;\n\t\tbreak;\n\tcase QAM_64:\n\t\topermode |= 0x00;\n\t\tbreak;\n\tcase QAM_256:\n\t\topermode |= 0x01;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tret = lgdt3305_write_reg(state, LGDT3305_GEN_CTRL_1, opermode);\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3305_set_filter_extension(struct lgdt3305_state *state,\n\t\t\t\t\t struct dtv_frontend_properties *p)\n{\n\tint val;\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tval = 0;\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\t\tval = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tlg_dbg(\"val = %d\\n\", val);\n\n\treturn lgdt3305_set_reg_bit(state, 0x043f, 2, val);\n}\n\n \n\nstatic int lgdt3305_passband_digital_agc(struct lgdt3305_state *state,\n\t\t\t\t\t struct dtv_frontend_properties *p)\n{\n\tu16 agc_ref;\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tagc_ref = 0x32c4;\n\t\tbreak;\n\tcase QAM_64:\n\t\tagc_ref = 0x2a00;\n\t\tbreak;\n\tcase QAM_256:\n\t\tagc_ref = 0x2a80;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlg_dbg(\"agc ref: 0x%04x\\n\", agc_ref);\n\n\tlgdt3305_write_reg(state, LGDT3305_DGTL_AGC_REF_1, agc_ref >> 8);\n\tlgdt3305_write_reg(state, LGDT3305_DGTL_AGC_REF_2, agc_ref & 0xff);\n\n\treturn 0;\n}\n\nstatic int lgdt3305_rfagc_loop(struct lgdt3305_state *state,\n\t\t\t       struct dtv_frontend_properties *p)\n{\n\tu16 ifbw, rfbw, agcdelay;\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tagcdelay = 0x04c0;\n\t\trfbw     = 0x8000;\n\t\tifbw     = 0x8000;\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\t\tagcdelay = 0x046b;\n\t\trfbw     = 0x8889;\n\t\t \n\t\tif (state->cfg->demod_chip == LGDT3304)\n\t\t\tifbw = 0x6666;\n\t\telse  \n\t\t\tifbw = 0x8888;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (state->cfg->rf_agc_loop) {\n\t\tlg_dbg(\"agcdelay: 0x%04x, rfbw: 0x%04x\\n\", agcdelay, rfbw);\n\n\t\t \n\t\tlgdt3305_write_reg(state, LGDT3305_AGC_DELAY_PT_1,\n\t\t\t\t   agcdelay >> 8);\n\t\tlgdt3305_write_reg(state, LGDT3305_AGC_DELAY_PT_2,\n\t\t\t\t   agcdelay & 0xff);\n\n\t\tlgdt3305_write_reg(state, LGDT3305_RFAGC_LOOP_FLTR_BW_1,\n\t\t\t\t   rfbw >> 8);\n\t\tlgdt3305_write_reg(state, LGDT3305_RFAGC_LOOP_FLTR_BW_2,\n\t\t\t\t   rfbw & 0xff);\n\t} else {\n\t\tlg_dbg(\"ifbw: 0x%04x\\n\", ifbw);\n\n\t\t \n\t\tlgdt3305_write_reg(state, LGDT3305_IFBW_1, ifbw >> 8);\n\t\tlgdt3305_write_reg(state, LGDT3305_IFBW_2, ifbw & 0xff);\n\t}\n\n\treturn 0;\n}\n\nstatic int lgdt3305_agc_setup(struct lgdt3305_state *state,\n\t\t\t      struct dtv_frontend_properties *p)\n{\n\tint lockdten, acqen;\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tlockdten = 0;\n\t\tacqen = 0;\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\t\tlockdten = 1;\n\t\tacqen = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlg_dbg(\"lockdten = %d, acqen = %d\\n\", lockdten, acqen);\n\n\t \n\tswitch (state->cfg->demod_chip) {\n\tcase LGDT3304:\n\t\tlgdt3305_write_reg(state, 0x0314, 0xe1 | lockdten << 1);\n\t\tlgdt3305_set_reg_bit(state, 0x030e, 2, acqen);\n\t\tbreak;\n\tcase LGDT3305:\n\t\tlgdt3305_write_reg(state, LGDT3305_AGC_CTRL_4, 0xe1 | lockdten << 1);\n\t\tlgdt3305_set_reg_bit(state, LGDT3305_AGC_CTRL_1, 2, acqen);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn lgdt3305_rfagc_loop(state, p);\n}\n\nstatic int lgdt3305_set_agc_power_ref(struct lgdt3305_state *state,\n\t\t\t\t      struct dtv_frontend_properties *p)\n{\n\tu16 usref = 0;\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tif (state->cfg->usref_8vsb)\n\t\t\tusref = state->cfg->usref_8vsb;\n\t\tbreak;\n\tcase QAM_64:\n\t\tif (state->cfg->usref_qam64)\n\t\t\tusref = state->cfg->usref_qam64;\n\t\tbreak;\n\tcase QAM_256:\n\t\tif (state->cfg->usref_qam256)\n\t\t\tusref = state->cfg->usref_qam256;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (usref) {\n\t\tlg_dbg(\"set manual mode: 0x%04x\\n\", usref);\n\n\t\tlgdt3305_set_reg_bit(state, LGDT3305_AGC_CTRL_1, 3, 1);\n\n\t\tlgdt3305_write_reg(state, LGDT3305_AGC_POWER_REF_1,\n\t\t\t\t   0xff & (usref >> 8));\n\t\tlgdt3305_write_reg(state, LGDT3305_AGC_POWER_REF_2,\n\t\t\t\t   0xff & (usref >> 0));\n\t}\n\treturn 0;\n}\n\n \n\nstatic int lgdt3305_spectral_inversion(struct lgdt3305_state *state,\n\t\t\t\t       struct dtv_frontend_properties *p,\n\t\t\t\t       int inversion)\n{\n\tint ret;\n\n\tlg_dbg(\"(%d)\\n\", inversion);\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tret = lgdt3305_write_reg(state, LGDT3305_CR_CTRL_7,\n\t\t\t\t\t inversion ? 0xf9 : 0x79);\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\t\tret = lgdt3305_write_reg(state, LGDT3305_FEC_BLOCK_CTRL,\n\t\t\t\t\t inversion ? 0xfd : 0xff);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int lgdt3305_set_if(struct lgdt3305_state *state,\n\t\t\t   struct dtv_frontend_properties *p)\n{\n\tu16 if_freq_khz;\n\tu8 nco1, nco2, nco3, nco4;\n\tu64 nco;\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tif_freq_khz = state->cfg->vsb_if_khz;\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\t\tif_freq_khz = state->cfg->qam_if_khz;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnco = if_freq_khz / 10;\n\n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tnco <<= 24;\n\t\tdo_div(nco, 625);\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\t\tnco <<= 28;\n\t\tdo_div(nco, 625);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnco1 = (nco >> 24) & 0x3f;\n\tnco1 |= 0x40;\n\tnco2 = (nco >> 16) & 0xff;\n\tnco3 = (nco >> 8) & 0xff;\n\tnco4 = nco & 0xff;\n\n\tlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_1, nco1);\n\tlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_2, nco2);\n\tlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_3, nco3);\n\tlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_4, nco4);\n\n\tlg_dbg(\"%d KHz -> [%02x%02x%02x%02x]\\n\",\n\t       if_freq_khz, nco1, nco2, nco3, nco4);\n\n\treturn 0;\n}\n\n \n\nstatic int lgdt3305_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct lgdt3305_state *state = fe->demodulator_priv;\n\n\tif (state->cfg->deny_i2c_rptr)\n\t\treturn 0;\n\n\tlg_dbg(\"(%d)\\n\", enable);\n\n\treturn lgdt3305_set_reg_bit(state, LGDT3305_GEN_CTRL_2, 5,\n\t\t\t\t    enable ? 0 : 1);\n}\n\nstatic int lgdt3305_sleep(struct dvb_frontend *fe)\n{\n\tstruct lgdt3305_state *state = fe->demodulator_priv;\n\tu8 gen_ctrl_3, gen_ctrl_4;\n\n\tlg_dbg(\"\\n\");\n\n\tgen_ctrl_3 = read_reg(state, LGDT3305_GEN_CTRL_3);\n\tgen_ctrl_4 = read_reg(state, LGDT3305_GEN_CTRL_4);\n\n\t \n\tgen_ctrl_3 &= ~0x01;\n\t \n\tgen_ctrl_3 |=  0x02;\n\t \n\tgen_ctrl_3 |=  0x04;\n\n\t \n\tgen_ctrl_4 &= ~0x01;\n\t \n\tgen_ctrl_4 &= ~0x02;\n\n\tlgdt3305_write_reg(state, LGDT3305_GEN_CTRL_3, gen_ctrl_3);\n\tlgdt3305_write_reg(state, LGDT3305_GEN_CTRL_4, gen_ctrl_4);\n\n\treturn 0;\n}\n\nstatic int lgdt3305_init(struct dvb_frontend *fe)\n{\n\tstruct lgdt3305_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tstatic struct lgdt3305_reg lgdt3304_init_data[] = {\n\t\t{ .reg = LGDT3305_GEN_CTRL_1,           .val = 0x03, },\n\t\t{ .reg = 0x000d,                        .val = 0x02, },\n\t\t{ .reg = 0x000e,                        .val = 0x02, },\n\t\t{ .reg = LGDT3305_DGTL_AGC_REF_1,       .val = 0x32, },\n\t\t{ .reg = LGDT3305_DGTL_AGC_REF_2,       .val = 0xc4, },\n\t\t{ .reg = LGDT3305_CR_CTR_FREQ_1,        .val = 0x00, },\n\t\t{ .reg = LGDT3305_CR_CTR_FREQ_2,        .val = 0x00, },\n\t\t{ .reg = LGDT3305_CR_CTR_FREQ_3,        .val = 0x00, },\n\t\t{ .reg = LGDT3305_CR_CTR_FREQ_4,        .val = 0x00, },\n\t\t{ .reg = LGDT3305_CR_CTRL_7,            .val = 0xf9, },\n\t\t{ .reg = 0x0112,                        .val = 0x17, },\n\t\t{ .reg = 0x0113,                        .val = 0x15, },\n\t\t{ .reg = 0x0114,                        .val = 0x18, },\n\t\t{ .reg = 0x0115,                        .val = 0xff, },\n\t\t{ .reg = 0x0116,                        .val = 0x3c, },\n\t\t{ .reg = 0x0214,                        .val = 0x67, },\n\t\t{ .reg = 0x0424,                        .val = 0x8d, },\n\t\t{ .reg = 0x0427,                        .val = 0x12, },\n\t\t{ .reg = 0x0428,                        .val = 0x4f, },\n\t\t{ .reg = LGDT3305_IFBW_1,               .val = 0x80, },\n\t\t{ .reg = LGDT3305_IFBW_2,               .val = 0x00, },\n\t\t{ .reg = 0x030a,                        .val = 0x08, },\n\t\t{ .reg = 0x030b,                        .val = 0x9b, },\n\t\t{ .reg = 0x030d,                        .val = 0x00, },\n\t\t{ .reg = 0x030e,                        .val = 0x1c, },\n\t\t{ .reg = 0x0314,                        .val = 0xe1, },\n\t\t{ .reg = 0x000d,                        .val = 0x82, },\n\t\t{ .reg = LGDT3305_TP_CTRL_1,            .val = 0x5b, },\n\t\t{ .reg = LGDT3305_TP_CTRL_1,            .val = 0x5b, },\n\t};\n\n\tstatic struct lgdt3305_reg lgdt3305_init_data[] = {\n\t\t{ .reg = LGDT3305_GEN_CTRL_1,           .val = 0x03, },\n\t\t{ .reg = LGDT3305_GEN_CTRL_2,           .val = 0xb0, },\n\t\t{ .reg = LGDT3305_GEN_CTRL_3,           .val = 0x01, },\n\t\t{ .reg = LGDT3305_GEN_CONTROL,          .val = 0x6f, },\n\t\t{ .reg = LGDT3305_GEN_CTRL_4,           .val = 0x03, },\n\t\t{ .reg = LGDT3305_DGTL_AGC_REF_1,       .val = 0x32, },\n\t\t{ .reg = LGDT3305_DGTL_AGC_REF_2,       .val = 0xc4, },\n\t\t{ .reg = LGDT3305_CR_CTR_FREQ_1,        .val = 0x00, },\n\t\t{ .reg = LGDT3305_CR_CTR_FREQ_2,        .val = 0x00, },\n\t\t{ .reg = LGDT3305_CR_CTR_FREQ_3,        .val = 0x00, },\n\t\t{ .reg = LGDT3305_CR_CTR_FREQ_4,        .val = 0x00, },\n\t\t{ .reg = LGDT3305_CR_CTRL_7,            .val = 0x79, },\n\t\t{ .reg = LGDT3305_AGC_POWER_REF_1,      .val = 0x32, },\n\t\t{ .reg = LGDT3305_AGC_POWER_REF_2,      .val = 0xc4, },\n\t\t{ .reg = LGDT3305_AGC_DELAY_PT_1,       .val = 0x0d, },\n\t\t{ .reg = LGDT3305_AGC_DELAY_PT_2,       .val = 0x30, },\n\t\t{ .reg = LGDT3305_RFAGC_LOOP_FLTR_BW_1, .val = 0x80, },\n\t\t{ .reg = LGDT3305_RFAGC_LOOP_FLTR_BW_2, .val = 0x00, },\n\t\t{ .reg = LGDT3305_IFBW_1,               .val = 0x80, },\n\t\t{ .reg = LGDT3305_IFBW_2,               .val = 0x00, },\n\t\t{ .reg = LGDT3305_AGC_CTRL_1,           .val = 0x30, },\n\t\t{ .reg = LGDT3305_AGC_CTRL_4,           .val = 0x61, },\n\t\t{ .reg = LGDT3305_FEC_BLOCK_CTRL,       .val = 0xff, },\n\t\t{ .reg = LGDT3305_TP_CTRL_1,            .val = 0x1b, },\n\t};\n\n\tlg_dbg(\"\\n\");\n\n\tswitch (state->cfg->demod_chip) {\n\tcase LGDT3304:\n\t\tret = lgdt3305_write_regs(state, lgdt3304_init_data,\n\t\t\t\t\t  ARRAY_SIZE(lgdt3304_init_data));\n\t\tbreak;\n\tcase LGDT3305:\n\t\tret = lgdt3305_write_regs(state, lgdt3305_init_data,\n\t\t\t\t\t  ARRAY_SIZE(lgdt3305_init_data));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lgdt3305_soft_reset(state);\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3304_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct lgdt3305_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tlg_dbg(\"(%d, %d)\\n\", p->frequency, p->modulation);\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tstate->current_frequency = p->frequency;\n\t}\n\n\tret = lgdt3305_set_modulation(state, p);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lgdt3305_passband_digital_agc(state, p);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lgdt3305_agc_setup(state, p);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t \n\tswitch (p->modulation) {\n\tcase VSB_8:\n\t\tlgdt3305_write_reg(state, 0x030d, 0x00);\n\t\tlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_1, 0x4f);\n\t\tlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_2, 0x0c);\n\t\tlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_3, 0xac);\n\t\tlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_4, 0xba);\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\t\tlgdt3305_write_reg(state, 0x030d, 0x14);\n\t\tret = lgdt3305_set_if(state, p);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\n\tret = lgdt3305_spectral_inversion(state, p,\n\t\t\t\t\t  state->cfg->spectral_inversion\n\t\t\t\t\t  ? 1 : 0);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tstate->current_modulation = p->modulation;\n\n\tret = lgdt3305_mpeg_mode(state, state->cfg->mpeg_mode);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3305_mpeg_mode_polarity(state);\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3305_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct lgdt3305_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tlg_dbg(\"(%d, %d)\\n\", p->frequency, p->modulation);\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\t\tstate->current_frequency = p->frequency;\n\t}\n\n\tret = lgdt3305_set_modulation(state, p);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lgdt3305_passband_digital_agc(state, p);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\tret = lgdt3305_set_agc_power_ref(state, p);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\tret = lgdt3305_agc_setup(state, p);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3305_write_reg(state, LGDT3305_GEN_CONTROL, 0x2f);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\tret = lgdt3305_set_reg_bit(state, LGDT3305_CR_CTR_FREQ_1, 6, 1);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lgdt3305_set_if(state, p);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\tret = lgdt3305_spectral_inversion(state, p,\n\t\t\t\t\t  state->cfg->spectral_inversion\n\t\t\t\t\t  ? 1 : 0);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tret = lgdt3305_set_filter_extension(state, p);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tstate->current_modulation = p->modulation;\n\n\tret = lgdt3305_mpeg_mode(state, state->cfg->mpeg_mode);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\t \n\tret = lgdt3305_mpeg_mode_polarity(state);\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3305_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t struct dtv_frontend_properties *p)\n{\n\tstruct lgdt3305_state *state = fe->demodulator_priv;\n\n\tlg_dbg(\"\\n\");\n\n\tp->modulation = state->current_modulation;\n\tp->frequency = state->current_frequency;\n\treturn 0;\n}\n\n \n\nstatic int lgdt3305_read_cr_lock_status(struct lgdt3305_state *state,\n\t\t\t\t\tint *locked)\n{\n\tu8 val;\n\tint ret;\n\tchar *cr_lock_state = \"\";\n\n\t*locked = 0;\n\n\tret = lgdt3305_read_reg(state, LGDT3305_CR_LOCK_STATUS, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tswitch (state->current_modulation) {\n\tcase QAM_256:\n\tcase QAM_64:\n\t\tif (val & (1 << 1))\n\t\t\t*locked = 1;\n\n\t\tswitch (val & 0x07) {\n\t\tcase 0:\n\t\t\tcr_lock_state = \"QAM UNLOCK\";\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcr_lock_state = \"QAM 1stLock\";\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tcr_lock_state = \"QAM 2ndLock\";\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tcr_lock_state = \"QAM FinalLock\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcr_lock_state = \"CLOCKQAM-INVALID!\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VSB_8:\n\t\tif (val & (1 << 7)) {\n\t\t\t*locked = 1;\n\t\t\tcr_lock_state = \"CLOCKVSB\";\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tlg_dbg(\"(%d) %s\\n\", *locked, cr_lock_state);\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3305_read_fec_lock_status(struct lgdt3305_state *state,\n\t\t\t\t\t int *locked)\n{\n\tu8 val;\n\tint ret, mpeg_lock, fec_lock, viterbi_lock;\n\n\t*locked = 0;\n\n\tswitch (state->current_modulation) {\n\tcase QAM_256:\n\tcase QAM_64:\n\t\tret = lgdt3305_read_reg(state,\n\t\t\t\t\tLGDT3305_FEC_LOCK_STATUS, &val);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\n\t\tmpeg_lock    = (val & (1 << 0)) ? 1 : 0;\n\t\tfec_lock     = (val & (1 << 2)) ? 1 : 0;\n\t\tviterbi_lock = (val & (1 << 3)) ? 1 : 0;\n\n\t\t*locked = mpeg_lock && fec_lock && viterbi_lock;\n\n\t\tlg_dbg(\"(%d) %s%s%s\\n\", *locked,\n\t\t       mpeg_lock    ? \"mpeg lock  \"  : \"\",\n\t\t       fec_lock     ? \"fec lock  \"   : \"\",\n\t\t       viterbi_lock ? \"viterbi lock\" : \"\");\n\t\tbreak;\n\tcase VSB_8:\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nfail:\n\treturn ret;\n}\n\nstatic int lgdt3305_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct lgdt3305_state *state = fe->demodulator_priv;\n\tu8 val;\n\tint ret, signal, inlock, nofecerr, snrgood,\n\t\tcr_lock, fec_lock, sync_lock;\n\n\t*status = 0;\n\n\tret = lgdt3305_read_reg(state, LGDT3305_GEN_STATUS, &val);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tsignal    = (val & (1 << 4)) ? 1 : 0;\n\tinlock    = (val & (1 << 3)) ? 0 : 1;\n\tsync_lock = (val & (1 << 2)) ? 1 : 0;\n\tnofecerr  = (val & (1 << 1)) ? 1 : 0;\n\tsnrgood   = (val & (1 << 0)) ? 1 : 0;\n\n\tlg_dbg(\"%s%s%s%s%s\\n\",\n\t       signal    ? \"SIGNALEXIST \" : \"\",\n\t       inlock    ? \"INLOCK \"      : \"\",\n\t       sync_lock ? \"SYNCLOCK \"    : \"\",\n\t       nofecerr  ? \"NOFECERR \"    : \"\",\n\t       snrgood   ? \"SNRGOOD \"     : \"\");\n\n\tret = lgdt3305_read_cr_lock_status(state, &cr_lock);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tif (signal)\n\t\t*status |= FE_HAS_SIGNAL;\n\tif (cr_lock)\n\t\t*status |= FE_HAS_CARRIER;\n\tif (nofecerr)\n\t\t*status |= FE_HAS_VITERBI;\n\tif (sync_lock)\n\t\t*status |= FE_HAS_SYNC;\n\n\tswitch (state->current_modulation) {\n\tcase QAM_256:\n\tcase QAM_64:\n\t\t \n\t\tif (((LGDT3304 == state->cfg->demod_chip)) && (cr_lock))\n\t\t\t*status |= FE_HAS_SIGNAL;\n\n\t\tret = lgdt3305_read_fec_lock_status(state, &fec_lock);\n\t\tif (lg_fail(ret))\n\t\t\tgoto fail;\n\n\t\tif (fec_lock)\n\t\t\t*status |= FE_HAS_LOCK;\n\t\tbreak;\n\tcase VSB_8:\n\t\tif (inlock)\n\t\t\t*status |= FE_HAS_LOCK;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nfail:\n\treturn ret;\n}\n\n \n\n \nstatic u32 calculate_snr(u32 mse, u32 c)\n{\n\tif (mse == 0)  \n\t\treturn 0;\n\n\tmse = intlog10(mse);\n\tif (mse > c) {\n\t\t \n\t\treturn 0;\n\t}\n\treturn 10*(c - mse);\n}\n\nstatic int lgdt3305_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct lgdt3305_state *state = fe->demodulator_priv;\n\tu32 noise;\t \n\tu32 c;\t\t \n\n\tswitch (state->current_modulation) {\n\tcase VSB_8:\n#ifdef USE_PTMSE\n\t\t \n\t\t \n\t\tnoise =\t((read_reg(state, LGDT3305_PT_MSE_1) & 0x07) << 16) |\n\t\t\t(read_reg(state, LGDT3305_PT_MSE_2) << 8) |\n\t\t\t(read_reg(state, LGDT3305_PT_MSE_3) & 0xff);\n\t\tc = 73957994;  \n#else\n\t\t \n\t\t \n\t\tnoise =\t((read_reg(state, LGDT3305_EQ_MSE_1) & 0x0f) << 16) |\n\t\t\t(read_reg(state, LGDT3305_EQ_MSE_2) << 8) |\n\t\t\t(read_reg(state, LGDT3305_EQ_MSE_3) & 0xff);\n\t\tc = 73957994;  \n#endif\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\t\tnoise = (read_reg(state, LGDT3305_CR_MSE_1) << 8) |\n\t\t\t(read_reg(state, LGDT3305_CR_MSE_2) & 0xff);\n\n\t\tc = (state->current_modulation == QAM_64) ?\n\t\t\t97939837 : 98026066;\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tstate->snr = calculate_snr(noise, c);\n\t \n\t*snr = (state->snr / ((1 << 24) / 10));\n\tlg_dbg(\"noise = 0x%08x, snr = %d.%02d dB\\n\", noise,\n\t       state->snr >> 24, (((state->snr >> 8) & 0xffff) * 100) >> 16);\n\n\treturn 0;\n}\n\nstatic int lgdt3305_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t\t u16 *strength)\n{\n\t \n\tstruct lgdt3305_state *state = fe->demodulator_priv;\n\tu16 snr;\n\tint ret;\n\n\t*strength = 0;\n\n\tret = fe->ops.read_snr(fe, &snr);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\t \n\t \n\tif (state->snr >= 8960 * 0x10000)\n\t\t*strength = 0xffff;\n\telse\n\t\t*strength = state->snr / 8960;\nfail:\n\treturn ret;\n}\n\n \n\nstatic int lgdt3305_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\t*ber = 0;\n\treturn 0;\n}\n\nstatic int lgdt3305_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct lgdt3305_state *state = fe->demodulator_priv;\n\n\t*ucblocks =\n\t\t(read_reg(state, LGDT3305_FEC_PKT_ERR_1) << 8) |\n\t\t(read_reg(state, LGDT3305_FEC_PKT_ERR_2) & 0xff);\n\n\treturn 0;\n}\n\nstatic int lgdt3305_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t      struct dvb_frontend_tune_settings\n\t\t\t\t\t*fe_tune_settings)\n{\n\tfe_tune_settings->min_delay_ms = 500;\n\tlg_dbg(\"\\n\");\n\treturn 0;\n}\n\nstatic void lgdt3305_release(struct dvb_frontend *fe)\n{\n\tstruct lgdt3305_state *state = fe->demodulator_priv;\n\tlg_dbg(\"\\n\");\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops lgdt3304_ops;\nstatic const struct dvb_frontend_ops lgdt3305_ops;\n\nstruct dvb_frontend *lgdt3305_attach(const struct lgdt3305_config *config,\n\t\t\t\t     struct i2c_adapter *i2c_adap)\n{\n\tstruct lgdt3305_state *state = NULL;\n\tint ret;\n\tu8 val;\n\n\tlg_dbg(\"(%d-%04x)\\n\",\n\t       i2c_adap ? i2c_adapter_id(i2c_adap) : 0,\n\t       config ? config->i2c_addr : 0);\n\n\tstate = kzalloc(sizeof(struct lgdt3305_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto fail;\n\n\tstate->cfg = config;\n\tstate->i2c_adap = i2c_adap;\n\n\tswitch (config->demod_chip) {\n\tcase LGDT3304:\n\t\tmemcpy(&state->frontend.ops, &lgdt3304_ops,\n\t\t       sizeof(struct dvb_frontend_ops));\n\t\tbreak;\n\tcase LGDT3305:\n\t\tmemcpy(&state->frontend.ops, &lgdt3305_ops,\n\t\t       sizeof(struct dvb_frontend_ops));\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\tstate->frontend.demodulator_priv = state;\n\n\t \n\tret = lgdt3305_read_reg(state, LGDT3305_GEN_CTRL_2, &val);\n\tif ((lg_fail(ret)) | (val == 0))\n\t\tgoto fail;\n\tret = lgdt3305_write_reg(state, 0x0808, 0x80);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\tret = lgdt3305_read_reg(state, 0x0808, &val);\n\tif ((lg_fail(ret)) | (val != 0x80))\n\t\tgoto fail;\n\tret = lgdt3305_write_reg(state, 0x0808, 0x00);\n\tif (lg_fail(ret))\n\t\tgoto fail;\n\n\tstate->current_frequency = -1;\n\tstate->current_modulation = -1;\n\n\treturn &state->frontend;\nfail:\n\tlg_warn(\"unable to detect %s hardware\\n\",\n\t\tconfig->demod_chip ? \"LGDT3304\" : \"LGDT3305\");\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(lgdt3305_attach);\n\nstatic const struct dvb_frontend_ops lgdt3304_ops = {\n\t.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },\n\t.info = {\n\t\t.name = \"LG Electronics LGDT3304 VSB/QAM Frontend\",\n\t\t.frequency_min_hz      =  54 * MHz,\n\t\t.frequency_max_hz      = 858 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.caps = FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB\n\t},\n\t.i2c_gate_ctrl        = lgdt3305_i2c_gate_ctrl,\n\t.init                 = lgdt3305_init,\n\t.sleep                = lgdt3305_sleep,\n\t.set_frontend         = lgdt3304_set_parameters,\n\t.get_frontend         = lgdt3305_get_frontend,\n\t.get_tune_settings    = lgdt3305_get_tune_settings,\n\t.read_status          = lgdt3305_read_status,\n\t.read_ber             = lgdt3305_read_ber,\n\t.read_signal_strength = lgdt3305_read_signal_strength,\n\t.read_snr             = lgdt3305_read_snr,\n\t.read_ucblocks        = lgdt3305_read_ucblocks,\n\t.release              = lgdt3305_release,\n};\n\nstatic const struct dvb_frontend_ops lgdt3305_ops = {\n\t.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },\n\t.info = {\n\t\t.name = \"LG Electronics LGDT3305 VSB/QAM Frontend\",\n\t\t.frequency_min_hz      =  54 * MHz,\n\t\t.frequency_max_hz      = 858 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.caps = FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB\n\t},\n\t.i2c_gate_ctrl        = lgdt3305_i2c_gate_ctrl,\n\t.init                 = lgdt3305_init,\n\t.sleep                = lgdt3305_sleep,\n\t.set_frontend         = lgdt3305_set_parameters,\n\t.get_frontend         = lgdt3305_get_frontend,\n\t.get_tune_settings    = lgdt3305_get_tune_settings,\n\t.read_status          = lgdt3305_read_status,\n\t.read_ber             = lgdt3305_read_ber,\n\t.read_signal_strength = lgdt3305_read_signal_strength,\n\t.read_snr             = lgdt3305_read_snr,\n\t.read_ucblocks        = lgdt3305_read_ucblocks,\n\t.release              = lgdt3305_release,\n};\n\nMODULE_DESCRIPTION(\"LG Electronics LGDT3304/5 ATSC/QAM-B Demodulator Driver\");\nMODULE_AUTHOR(\"Michael Krufky <mkrufky@linuxtv.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}