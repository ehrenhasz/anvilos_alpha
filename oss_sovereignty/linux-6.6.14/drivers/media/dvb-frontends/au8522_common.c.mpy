{
  "module_name": "au8522_common.c",
  "hash_id": "d60af951d63ccbe4ad25da2bcb5e709b39b6ee8c65dc3a379a5edd2084c3b75a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/au8522_common.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <media/dvb_frontend.h>\n#include \"au8522_priv.h\"\n\nstatic int debug;\n\n#define dprintk(arg...)\\\n  do { if (debug)\\\n\t printk(arg);\\\n  } while (0)\n\n \nstatic LIST_HEAD(hybrid_tuner_instance_list);\nstatic DEFINE_MUTEX(au8522_list_mutex);\n\n \nint au8522_writereg(struct au8522_state *state, u16 reg, u8 data)\n{\n\tint ret;\n\tu8 buf[] = { (reg >> 8) | 0x80, reg & 0xff, data };\n\n\tstruct i2c_msg msg = { .addr = state->config.demod_address,\n\t\t\t       .flags = 0, .buf = buf, .len = 3 };\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tprintk(\"%s: writereg error (reg == 0x%02x, val == 0x%04x, ret == %i)\\n\",\n\t\t       __func__, reg, data, ret);\n\n\treturn (ret != 1) ? -1 : 0;\n}\nEXPORT_SYMBOL(au8522_writereg);\n\nu8 au8522_readreg(struct au8522_state *state, u16 reg)\n{\n\tint ret;\n\tu8 b0[] = { (reg >> 8) | 0x40, reg & 0xff };\n\tu8 b1[] = { 0 };\n\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->config.demod_address, .flags = 0,\n\t\t  .buf = b0, .len = 2 },\n\t\t{ .addr = state->config.demod_address, .flags = I2C_M_RD,\n\t\t  .buf = b1, .len = 1 } };\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tprintk(KERN_ERR \"%s: readreg error (ret == %i)\\n\",\n\t\t       __func__, ret);\n\treturn b1[0];\n}\nEXPORT_SYMBOL(au8522_readreg);\n\nint au8522_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct au8522_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(%d)\\n\", __func__, enable);\n\n\tif (state->operational_mode == AU8522_ANALOG_MODE) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (enable)\n\t\treturn au8522_writereg(state, 0x106, 1);\n\telse\n\t\treturn au8522_writereg(state, 0x106, 0);\n}\nEXPORT_SYMBOL(au8522_i2c_gate_ctrl);\n\nint au8522_analog_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct au8522_state *state = fe->demodulator_priv;\n\n\tdprintk(\"%s(%d)\\n\", __func__, enable);\n\n\tif (enable)\n\t\treturn au8522_writereg(state, 0x106, 1);\n\telse\n\t\treturn au8522_writereg(state, 0x106, 0);\n}\nEXPORT_SYMBOL(au8522_analog_i2c_gate_ctrl);\n\n \nint au8522_get_state(struct au8522_state **state, struct i2c_adapter *i2c,\n\t\t     u8 client_address)\n{\n\tint ret;\n\n\tmutex_lock(&au8522_list_mutex);\n\tret = hybrid_tuner_request_state(struct au8522_state, (*state),\n\t\t\t\t\t hybrid_tuner_instance_list,\n\t\t\t\t\t i2c, client_address, \"au8522\");\n\tmutex_unlock(&au8522_list_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(au8522_get_state);\n\nvoid au8522_release_state(struct au8522_state *state)\n{\n\tmutex_lock(&au8522_list_mutex);\n\tif (state != NULL)\n\t\thybrid_tuner_release_state(state);\n\tmutex_unlock(&au8522_list_mutex);\n}\nEXPORT_SYMBOL(au8522_release_state);\n\nstatic int au8522_led_gpio_enable(struct au8522_state *state, int onoff)\n{\n\tstruct au8522_led_config *led_config = state->config.led_cfg;\n\tu8 val;\n\n\t \n\tif (!led_config || !led_config->gpio_output ||\n\t    !led_config->gpio_output_enable || !led_config->gpio_output_disable)\n\t\treturn 0;\n\n\tval = au8522_readreg(state, 0x4000 |\n\t\t\t     (led_config->gpio_output & ~0xc000));\n\tif (onoff) {\n\t\t \n\t\tval &= ~((led_config->gpio_output_enable >> 8) & 0xff);\n\t\tval |=  (led_config->gpio_output_enable & 0xff);\n\t} else {\n\t\t \n\t\tval &= ~((led_config->gpio_output_disable >> 8) & 0xff);\n\t\tval |=  (led_config->gpio_output_disable & 0xff);\n\t}\n\treturn au8522_writereg(state, 0x8000 |\n\t\t\t       (led_config->gpio_output & ~0xc000), val);\n}\n\n \nint au8522_led_ctrl(struct au8522_state *state, int led)\n{\n\tstruct au8522_led_config *led_config = state->config.led_cfg;\n\tint i, ret = 0;\n\n\t \n\tif (!led_config || !led_config->gpio_leds ||\n\t    !led_config->num_led_states || !led_config->led_states)\n\t\treturn 0;\n\n\tif (led < 0) {\n\t\t \n\t\tif (state->led_state)\n\t\t\treturn 0;\n\t\telse\n\t\t\tled *= -1;\n\t}\n\n\t \n\tif (state->led_state != led) {\n\t\tu8 val;\n\n\t\tdprintk(\"%s: %d\\n\", __func__, led);\n\n\t\tau8522_led_gpio_enable(state, 1);\n\n\t\tval = au8522_readreg(state, 0x4000 |\n\t\t\t\t     (led_config->gpio_leds & ~0xc000));\n\n\t\t \n\t\tfor (i = 0; i < led_config->num_led_states; i++)\n\t\t\tval &= ~led_config->led_states[i];\n\n\t\t \n\t\tif (led < led_config->num_led_states)\n\t\t\tval |= led_config->led_states[led];\n\t\telse if (led_config->num_led_states)\n\t\t\tval |=\n\t\t\tled_config->led_states[led_config->num_led_states - 1];\n\n\t\tret = au8522_writereg(state, 0x8000 |\n\t\t\t\t      (led_config->gpio_leds & ~0xc000), val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tstate->led_state = led;\n\n\t\tif (led == 0)\n\t\t\tau8522_led_gpio_enable(state, 0);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(au8522_led_ctrl);\n\nint au8522_init(struct dvb_frontend *fe)\n{\n\tstruct au8522_state *state = fe->demodulator_priv;\n\tdprintk(\"%s()\\n\", __func__);\n\n\tstate->operational_mode = AU8522_DIGITAL_MODE;\n\n\t \n\tstate->current_frequency = 0;\n\tstate->current_modulation = VSB_8;\n\n\tau8522_writereg(state, 0xa4, 1 << 5);\n\n\tau8522_i2c_gate_ctrl(fe, 1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(au8522_init);\n\nint au8522_sleep(struct dvb_frontend *fe)\n{\n\tstruct au8522_state *state = fe->demodulator_priv;\n\tdprintk(\"%s()\\n\", __func__);\n\n\t \n\tif (state->operational_mode == AU8522_ANALOG_MODE) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tau8522_led_ctrl(state, 0);\n\n\t \n\tau8522_writereg(state, 0xa4, 1 << 5);\n\n\tstate->current_frequency = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(au8522_sleep);\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Enable verbose debug messages\");\n\nMODULE_DESCRIPTION(\"Auvitek AU8522 QAM-B/ATSC Demodulator driver\");\nMODULE_AUTHOR(\"Steven Toth\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}