{
  "module_name": "mxl5xx.c",
  "hash_id": "de805029d7405b5d48e44bb2f6e5f8cc1badc1a3c4b09601cea7a658b2650a34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/mxl5xx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <asm/div64.h>\n#include <asm/unaligned.h>\n\n#include <media/dvb_frontend.h>\n#include \"mxl5xx.h\"\n#include \"mxl5xx_regs.h\"\n#include \"mxl5xx_defs.h\"\n\n#define BYTE0(v) ((v >>  0) & 0xff)\n#define BYTE1(v) ((v >>  8) & 0xff)\n#define BYTE2(v) ((v >> 16) & 0xff)\n#define BYTE3(v) ((v >> 24) & 0xff)\n\nstatic LIST_HEAD(mxllist);\n\nstruct mxl_base {\n\tstruct list_head     mxllist;\n\tstruct list_head     mxls;\n\n\tu8                   adr;\n\tstruct i2c_adapter  *i2c;\n\n\tu32                  count;\n\tu32                  type;\n\tu32                  sku_type;\n\tu32                  chipversion;\n\tu32                  clock;\n\tu32                  fwversion;\n\n\tu8                  *ts_map;\n\tu8                   can_clkout;\n\tu8                   chan_bond;\n\tu8                   demod_num;\n\tu8                   tuner_num;\n\n\tunsigned long        next_tune;\n\n\tstruct mutex         i2c_lock;\n\tstruct mutex         status_lock;\n\tstruct mutex         tune_lock;\n\n\tu8                   buf[MXL_HYDRA_OEM_MAX_CMD_BUFF_LEN];\n\n\tu32                  cmd_size;\n\tu8                   cmd_data[MAX_CMD_DATA];\n};\n\nstruct mxl {\n\tstruct list_head     mxl;\n\n\tstruct mxl_base     *base;\n\tstruct dvb_frontend  fe;\n\tstruct device       *i2cdev;\n\tu32                  demod;\n\tu32                  tuner;\n\tu32                  tuner_in_use;\n\tu8                   xbar[3];\n\n\tunsigned long        tune_time;\n};\n\nstatic void convert_endian(u8 flag, u32 size, u8 *d)\n{\n\tu32 i;\n\n\tif (!flag)\n\t\treturn;\n\tfor (i = 0; i < (size & ~3); i += 4) {\n\t\td[i + 0] ^= d[i + 3];\n\t\td[i + 3] ^= d[i + 0];\n\t\td[i + 0] ^= d[i + 3];\n\n\t\td[i + 1] ^= d[i + 2];\n\t\td[i + 2] ^= d[i + 1];\n\t\td[i + 1] ^= d[i + 2];\n\t}\n\n\tswitch (size & 3) {\n\tcase 0:\n\tcase 1:\n\t\t \n\t\tbreak;\n\tcase 2:\n\t\td[i + 0] ^= d[i + 1];\n\t\td[i + 1] ^= d[i + 0];\n\t\td[i + 0] ^= d[i + 1];\n\t\tbreak;\n\n\tcase 3:\n\t\td[i + 0] ^= d[i + 2];\n\t\td[i + 2] ^= d[i + 0];\n\t\td[i + 0] ^= d[i + 2];\n\t\tbreak;\n\t}\n\n}\n\nstatic int i2c_write(struct i2c_adapter *adap, u8 adr,\n\t\t\t    u8 *data, u32 len)\n{\n\tstruct i2c_msg msg = {.addr = adr, .flags = 0,\n\t\t\t      .buf = data, .len = len};\n\n\treturn (i2c_transfer(adap, &msg, 1) == 1) ? 0 : -1;\n}\n\nstatic int i2c_read(struct i2c_adapter *adap, u8 adr,\n\t\t\t   u8 *data, u32 len)\n{\n\tstruct i2c_msg msg = {.addr = adr, .flags = I2C_M_RD,\n\t\t\t      .buf = data, .len = len};\n\n\treturn (i2c_transfer(adap, &msg, 1) == 1) ? 0 : -1;\n}\n\nstatic int i2cread(struct mxl *state, u8 *data, int len)\n{\n\treturn i2c_read(state->base->i2c, state->base->adr, data, len);\n}\n\nstatic int i2cwrite(struct mxl *state, u8 *data, int len)\n{\n\treturn i2c_write(state->base->i2c, state->base->adr, data, len);\n}\n\nstatic int read_register_unlocked(struct mxl *state, u32 reg, u32 *val)\n{\n\tint stat;\n\tu8 data[MXL_HYDRA_REG_SIZE_IN_BYTES + MXL_HYDRA_I2C_HDR_SIZE] = {\n\t\tMXL_HYDRA_PLID_REG_READ, 0x04,\n\t\tGET_BYTE(reg, 0), GET_BYTE(reg, 1),\n\t\tGET_BYTE(reg, 2), GET_BYTE(reg, 3),\n\t};\n\n\tstat = i2cwrite(state, data,\n\t\t\tMXL_HYDRA_REG_SIZE_IN_BYTES + MXL_HYDRA_I2C_HDR_SIZE);\n\tif (stat)\n\t\tdev_err(state->i2cdev, \"i2c read error 1\\n\");\n\tif (!stat)\n\t\tstat = i2cread(state, (u8 *) val,\n\t\t\t       MXL_HYDRA_REG_SIZE_IN_BYTES);\n\tle32_to_cpus(val);\n\tif (stat)\n\t\tdev_err(state->i2cdev, \"i2c read error 2\\n\");\n\treturn stat;\n}\n\n#define DMA_I2C_INTERRUPT_ADDR 0x8000011C\n#define DMA_INTR_PROT_WR_CMP 0x08\n\nstatic int send_command(struct mxl *state, u32 size, u8 *buf)\n{\n\tint stat;\n\tu32 val, count = 10;\n\n\tmutex_lock(&state->base->i2c_lock);\n\tif (state->base->fwversion > 0x02010109)  {\n\t\tread_register_unlocked(state, DMA_I2C_INTERRUPT_ADDR, &val);\n\t\tif (DMA_INTR_PROT_WR_CMP & val)\n\t\t\tdev_info(state->i2cdev, \"%s busy\\n\", __func__);\n\t\twhile ((DMA_INTR_PROT_WR_CMP & val) && --count) {\n\t\t\tmutex_unlock(&state->base->i2c_lock);\n\t\t\tusleep_range(1000, 2000);\n\t\t\tmutex_lock(&state->base->i2c_lock);\n\t\t\tread_register_unlocked(state, DMA_I2C_INTERRUPT_ADDR,\n\t\t\t\t\t       &val);\n\t\t}\n\t\tif (!count) {\n\t\t\tdev_info(state->i2cdev, \"%s busy\\n\", __func__);\n\t\t\tmutex_unlock(&state->base->i2c_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tstat = i2cwrite(state, buf, size);\n\tmutex_unlock(&state->base->i2c_lock);\n\treturn stat;\n}\n\nstatic int write_register(struct mxl *state, u32 reg, u32 val)\n{\n\tint stat;\n\tu8 data[MXL_HYDRA_REG_WRITE_LEN] = {\n\t\tMXL_HYDRA_PLID_REG_WRITE, 0x08,\n\t\tBYTE0(reg), BYTE1(reg), BYTE2(reg), BYTE3(reg),\n\t\tBYTE0(val), BYTE1(val), BYTE2(val), BYTE3(val),\n\t};\n\tmutex_lock(&state->base->i2c_lock);\n\tstat = i2cwrite(state, data, sizeof(data));\n\tmutex_unlock(&state->base->i2c_lock);\n\tif (stat)\n\t\tdev_err(state->i2cdev, \"i2c write error\\n\");\n\treturn stat;\n}\n\nstatic int write_firmware_block(struct mxl *state,\n\t\t\t\tu32 reg, u32 size, u8 *reg_data_ptr)\n{\n\tint stat;\n\tu8 *buf = state->base->buf;\n\n\tmutex_lock(&state->base->i2c_lock);\n\tbuf[0] = MXL_HYDRA_PLID_REG_WRITE;\n\tbuf[1] = size + 4;\n\tbuf[2] = GET_BYTE(reg, 0);\n\tbuf[3] = GET_BYTE(reg, 1);\n\tbuf[4] = GET_BYTE(reg, 2);\n\tbuf[5] = GET_BYTE(reg, 3);\n\tmemcpy(&buf[6], reg_data_ptr, size);\n\tstat = i2cwrite(state, buf,\n\t\t\tMXL_HYDRA_I2C_HDR_SIZE +\n\t\t\tMXL_HYDRA_REG_SIZE_IN_BYTES + size);\n\tmutex_unlock(&state->base->i2c_lock);\n\tif (stat)\n\t\tdev_err(state->i2cdev, \"fw block write failed\\n\");\n\treturn stat;\n}\n\nstatic int read_register(struct mxl *state, u32 reg, u32 *val)\n{\n\tint stat;\n\tu8 data[MXL_HYDRA_REG_SIZE_IN_BYTES + MXL_HYDRA_I2C_HDR_SIZE] = {\n\t\tMXL_HYDRA_PLID_REG_READ, 0x04,\n\t\tGET_BYTE(reg, 0), GET_BYTE(reg, 1),\n\t\tGET_BYTE(reg, 2), GET_BYTE(reg, 3),\n\t};\n\n\tmutex_lock(&state->base->i2c_lock);\n\tstat = i2cwrite(state, data,\n\t\t\tMXL_HYDRA_REG_SIZE_IN_BYTES + MXL_HYDRA_I2C_HDR_SIZE);\n\tif (stat)\n\t\tdev_err(state->i2cdev, \"i2c read error 1\\n\");\n\tif (!stat)\n\t\tstat = i2cread(state, (u8 *) val,\n\t\t\t       MXL_HYDRA_REG_SIZE_IN_BYTES);\n\tmutex_unlock(&state->base->i2c_lock);\n\tle32_to_cpus(val);\n\tif (stat)\n\t\tdev_err(state->i2cdev, \"i2c read error 2\\n\");\n\treturn stat;\n}\n\nstatic int read_register_block(struct mxl *state, u32 reg, u32 size, u8 *data)\n{\n\tint stat;\n\tu8 *buf = state->base->buf;\n\n\tmutex_lock(&state->base->i2c_lock);\n\n\tbuf[0] = MXL_HYDRA_PLID_REG_READ;\n\tbuf[1] = size + 4;\n\tbuf[2] = GET_BYTE(reg, 0);\n\tbuf[3] = GET_BYTE(reg, 1);\n\tbuf[4] = GET_BYTE(reg, 2);\n\tbuf[5] = GET_BYTE(reg, 3);\n\tstat = i2cwrite(state, buf,\n\t\t\tMXL_HYDRA_I2C_HDR_SIZE + MXL_HYDRA_REG_SIZE_IN_BYTES);\n\tif (!stat) {\n\t\tstat = i2cread(state, data, size);\n\t\tconvert_endian(MXL_ENABLE_BIG_ENDIAN, size, data);\n\t}\n\tmutex_unlock(&state->base->i2c_lock);\n\treturn stat;\n}\n\nstatic int read_by_mnemonic(struct mxl *state,\n\t\t\t    u32 reg, u8 lsbloc, u8 numofbits, u32 *val)\n{\n\tu32 data = 0, mask = 0;\n\tint stat;\n\n\tstat = read_register(state, reg, &data);\n\tif (stat)\n\t\treturn stat;\n\tmask = MXL_GET_REG_MASK_32(lsbloc, numofbits);\n\tdata &= mask;\n\tdata >>= lsbloc;\n\t*val = data;\n\treturn 0;\n}\n\n\nstatic int update_by_mnemonic(struct mxl *state,\n\t\t\t      u32 reg, u8 lsbloc, u8 numofbits, u32 val)\n{\n\tu32 data, mask;\n\tint stat;\n\n\tstat = read_register(state, reg, &data);\n\tif (stat)\n\t\treturn stat;\n\tmask = MXL_GET_REG_MASK_32(lsbloc, numofbits);\n\tdata = (data & ~mask) | ((val << lsbloc) & mask);\n\tstat = write_register(state, reg, data);\n\treturn stat;\n}\n\nstatic int firmware_is_alive(struct mxl *state)\n{\n\tu32 hb0, hb1;\n\n\tif (read_register(state, HYDRA_HEAR_BEAT, &hb0))\n\t\treturn 0;\n\tmsleep(20);\n\tif (read_register(state, HYDRA_HEAR_BEAT, &hb1))\n\t\treturn 0;\n\tif (hb1 == hb0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int init(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\t \n\tp->strength.len = 1;\n\tp->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->cnr.len = 1;\n\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->pre_bit_error.len = 1;\n\tp->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->pre_bit_count.len = 1;\n\tp->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->post_bit_error.len = 1;\n\tp->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->post_bit_count.len = 1;\n\tp->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\treturn 0;\n}\n\nstatic void release(struct dvb_frontend *fe)\n{\n\tstruct mxl *state = fe->demodulator_priv;\n\n\tlist_del(&state->mxl);\n\t \n\tstate->base->count--;\n\tif (state->base->count == 0) {\n\t\tlist_del(&state->base->mxllist);\n\t\tkfree(state->base);\n\t}\n\tkfree(state);\n}\n\nstatic enum dvbfe_algo get_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic u32 gold2root(u32 gold)\n{\n\tu32 x, g, tmp = gold;\n\n\tif (tmp >= 0x3ffff)\n\t\ttmp = 0;\n\tfor (g = 0, x = 1; g < tmp; g++)\n\t\tx = (((x ^ (x >> 7)) & 1) << 17) | (x >> 1);\n\treturn x;\n}\n\nstatic int cfg_scrambler(struct mxl *state, u32 gold)\n{\n\tu32 root;\n\tu8 buf[26] = {\n\t\tMXL_HYDRA_PLID_CMD_WRITE, 24,\n\t\t0, MXL_HYDRA_DEMOD_SCRAMBLE_CODE_CMD, 0, 0,\n\t\tstate->demod, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 1, 0, 0, 0,\n\t};\n\n\troot = gold2root(gold);\n\n\tbuf[25] = (root >> 24) & 0xff;\n\tbuf[24] = (root >> 16) & 0xff;\n\tbuf[23] = (root >> 8) & 0xff;\n\tbuf[22] = root & 0xff;\n\n\treturn send_command(state, sizeof(buf), buf);\n}\n\nstatic int cfg_demod_abort_tune(struct mxl *state)\n{\n\tstruct MXL_HYDRA_DEMOD_ABORT_TUNE_T abort_tune_cmd;\n\tu8 cmd_size = sizeof(abort_tune_cmd);\n\tu8 cmd_buff[MXL_HYDRA_OEM_MAX_CMD_BUFF_LEN];\n\n\tabort_tune_cmd.demod_id = state->demod;\n\tBUILD_HYDRA_CMD(MXL_HYDRA_ABORT_TUNE_CMD, MXL_CMD_WRITE,\n\t\t\tcmd_size, &abort_tune_cmd, cmd_buff);\n\treturn send_command(state, cmd_size + MXL_HYDRA_CMD_HEADER_SIZE,\n\t\t\t    &cmd_buff[0]);\n}\n\nstatic int send_master_cmd(struct dvb_frontend *fe,\n\t\t\t   struct dvb_diseqc_master_cmd *cmd)\n{\n\t \n\n\treturn 0;  \n}\n\nstatic int set_parameters(struct dvb_frontend *fe)\n{\n\tstruct mxl *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct MXL_HYDRA_DEMOD_PARAM_T demod_chan_cfg;\n\tu8 cmd_size = sizeof(demod_chan_cfg);\n\tu8 cmd_buff[MXL_HYDRA_OEM_MAX_CMD_BUFF_LEN];\n\tu32 srange = 10;\n\tint stat;\n\n\tif (p->frequency < 950000 || p->frequency > 2150000)\n\t\treturn -EINVAL;\n\tif (p->symbol_rate < 1000000 || p->symbol_rate > 45000000)\n\t\treturn -EINVAL;\n\n\t \n\n\tswitch (p->delivery_system) {\n\tcase SYS_DSS:\n\t\tdemod_chan_cfg.standard = MXL_HYDRA_DSS;\n\t\tdemod_chan_cfg.roll_off = MXL_HYDRA_ROLLOFF_AUTO;\n\t\tbreak;\n\tcase SYS_DVBS:\n\t\tsrange = p->symbol_rate / 1000000;\n\t\tif (srange > 10)\n\t\t\tsrange = 10;\n\t\tdemod_chan_cfg.standard = MXL_HYDRA_DVBS;\n\t\tdemod_chan_cfg.roll_off = MXL_HYDRA_ROLLOFF_0_35;\n\t\tdemod_chan_cfg.modulation_scheme = MXL_HYDRA_MOD_QPSK;\n\t\tdemod_chan_cfg.pilots = MXL_HYDRA_PILOTS_OFF;\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tdemod_chan_cfg.standard = MXL_HYDRA_DVBS2;\n\t\tdemod_chan_cfg.roll_off = MXL_HYDRA_ROLLOFF_AUTO;\n\t\tdemod_chan_cfg.modulation_scheme = MXL_HYDRA_MOD_AUTO;\n\t\tdemod_chan_cfg.pilots = MXL_HYDRA_PILOTS_AUTO;\n\t\tcfg_scrambler(state, p->scrambling_sequence_index);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tdemod_chan_cfg.tuner_index = state->tuner;\n\tdemod_chan_cfg.demod_index = state->demod;\n\tdemod_chan_cfg.frequency_in_hz = p->frequency * 1000;\n\tdemod_chan_cfg.symbol_rate_in_hz = p->symbol_rate;\n\tdemod_chan_cfg.max_carrier_offset_in_mhz = srange;\n\tdemod_chan_cfg.spectrum_inversion = MXL_HYDRA_SPECTRUM_AUTO;\n\tdemod_chan_cfg.fec_code_rate = MXL_HYDRA_FEC_AUTO;\n\n\tmutex_lock(&state->base->tune_lock);\n\tif (time_after(jiffies + msecs_to_jiffies(200),\n\t\t       state->base->next_tune))\n\t\twhile (time_before(jiffies, state->base->next_tune))\n\t\t\tusleep_range(10000, 11000);\n\tstate->base->next_tune = jiffies + msecs_to_jiffies(100);\n\tstate->tuner_in_use = state->tuner;\n\tBUILD_HYDRA_CMD(MXL_HYDRA_DEMOD_SET_PARAM_CMD, MXL_CMD_WRITE,\n\t\t\tcmd_size, &demod_chan_cfg, cmd_buff);\n\tstat = send_command(state, cmd_size + MXL_HYDRA_CMD_HEADER_SIZE,\n\t\t\t    &cmd_buff[0]);\n\tmutex_unlock(&state->base->tune_lock);\n\treturn stat;\n}\n\nstatic int enable_tuner(struct mxl *state, u32 tuner, u32 enable);\n\nstatic int sleep(struct dvb_frontend *fe)\n{\n\tstruct mxl *state = fe->demodulator_priv;\n\tstruct mxl *p;\n\n\tcfg_demod_abort_tune(state);\n\tif (state->tuner_in_use != 0xffffffff) {\n\t\tmutex_lock(&state->base->tune_lock);\n\t\tstate->tuner_in_use = 0xffffffff;\n\t\tlist_for_each_entry(p, &state->base->mxls, mxl) {\n\t\t\tif (p->tuner_in_use == state->tuner)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (&p->mxl == &state->base->mxls)\n\t\t\tenable_tuner(state, state->tuner, 0);\n\t\tmutex_unlock(&state->base->tune_lock);\n\t}\n\treturn 0;\n}\n\nstatic int read_snr(struct dvb_frontend *fe)\n{\n\tstruct mxl *state = fe->demodulator_priv;\n\tint stat;\n\tu32 reg_data = 0;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tmutex_lock(&state->base->status_lock);\n\tHYDRA_DEMOD_STATUS_LOCK(state, state->demod);\n\tstat = read_register(state, (HYDRA_DMD_SNR_ADDR_OFFSET +\n\t\t\t\t     HYDRA_DMD_STATUS_OFFSET(state->demod)),\n\t\t\t     &reg_data);\n\tHYDRA_DEMOD_STATUS_UNLOCK(state, state->demod);\n\tmutex_unlock(&state->base->status_lock);\n\n\tp->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\tp->cnr.stat[0].svalue = (s16)reg_data * 10;\n\n\treturn stat;\n}\n\nstatic int read_ber(struct dvb_frontend *fe)\n{\n\tstruct mxl *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 reg[8];\n\n\tmutex_lock(&state->base->status_lock);\n\tHYDRA_DEMOD_STATUS_LOCK(state, state->demod);\n\tread_register_block(state,\n\t\t(HYDRA_DMD_DVBS_1ST_CORR_RS_ERRORS_ADDR_OFFSET +\n\t\t HYDRA_DMD_STATUS_OFFSET(state->demod)),\n\t\t(4 * sizeof(u32)),\n\t\t(u8 *) &reg[0]);\n\tHYDRA_DEMOD_STATUS_UNLOCK(state, state->demod);\n\n\tswitch (p->delivery_system) {\n\tcase SYS_DSS:\n\tcase SYS_DVBS:\n\t\tp->pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tp->pre_bit_error.stat[0].uvalue = reg[2];\n\t\tp->pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tp->pre_bit_count.stat[0].uvalue = reg[3];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tread_register_block(state,\n\t\t(HYDRA_DMD_DVBS2_CRC_ERRORS_ADDR_OFFSET +\n\t\t HYDRA_DMD_STATUS_OFFSET(state->demod)),\n\t\t(7 * sizeof(u32)),\n\t\t(u8 *) &reg[0]);\n\n\tswitch (p->delivery_system) {\n\tcase SYS_DSS:\n\tcase SYS_DVBS:\n\t\tp->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tp->post_bit_error.stat[0].uvalue = reg[5];\n\t\tp->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tp->post_bit_count.stat[0].uvalue = reg[6];\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tp->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tp->post_bit_error.stat[0].uvalue = reg[1];\n\t\tp->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tp->post_bit_count.stat[0].uvalue = reg[2];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&state->base->status_lock);\n\n\treturn 0;\n}\n\nstatic int read_signal_strength(struct dvb_frontend *fe)\n{\n\tstruct mxl *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tint stat;\n\tu32 reg_data = 0;\n\n\tmutex_lock(&state->base->status_lock);\n\tHYDRA_DEMOD_STATUS_LOCK(state, state->demod);\n\tstat = read_register(state, (HYDRA_DMD_STATUS_INPUT_POWER_ADDR +\n\t\t\t\t     HYDRA_DMD_STATUS_OFFSET(state->demod)),\n\t\t\t     &reg_data);\n\tHYDRA_DEMOD_STATUS_UNLOCK(state, state->demod);\n\tmutex_unlock(&state->base->status_lock);\n\n\tp->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\tp->strength.stat[0].svalue = (s16) reg_data * 10;  \n\n\treturn stat;\n}\n\nstatic int read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct mxl *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 reg_data = 0;\n\n\tmutex_lock(&state->base->status_lock);\n\tHYDRA_DEMOD_STATUS_LOCK(state, state->demod);\n\tread_register(state, (HYDRA_DMD_LOCK_STATUS_ADDR_OFFSET +\n\t\t\t     HYDRA_DMD_STATUS_OFFSET(state->demod)),\n\t\t\t     &reg_data);\n\tHYDRA_DEMOD_STATUS_UNLOCK(state, state->demod);\n\tmutex_unlock(&state->base->status_lock);\n\n\t*status = (reg_data == 1) ? 0x1f : 0;\n\n\t \n\n\t \n\tread_signal_strength(fe);\n\n\tif (*status & FE_HAS_CARRIER)\n\t\tread_snr(fe);\n\telse\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tif (*status & FE_HAS_SYNC)\n\t\tread_ber(fe);\n\telse {\n\t\tp->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn 0;\n}\n\nstatic int tune(struct dvb_frontend *fe, bool re_tune,\n\t\tunsigned int mode_flags,\n\t\tunsigned int *delay, enum fe_status *status)\n{\n\tstruct mxl *state = fe->demodulator_priv;\n\tint r = 0;\n\n\t*delay = HZ / 2;\n\tif (re_tune) {\n\t\tr = set_parameters(fe);\n\t\tif (r)\n\t\t\treturn r;\n\t\tstate->tune_time = jiffies;\n\t}\n\n\treturn read_status(fe, status);\n}\n\nstatic enum fe_code_rate conv_fec(enum MXL_HYDRA_FEC_E fec)\n{\n\tenum fe_code_rate fec2fec[11] = {\n\t\tFEC_NONE, FEC_1_2, FEC_3_5, FEC_2_3,\n\t\tFEC_3_4, FEC_4_5, FEC_5_6, FEC_6_7,\n\t\tFEC_7_8, FEC_8_9, FEC_9_10\n\t};\n\n\tif (fec > MXL_HYDRA_FEC_9_10)\n\t\treturn FEC_NONE;\n\treturn fec2fec[fec];\n}\n\nstatic int get_frontend(struct dvb_frontend *fe,\n\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct mxl *state = fe->demodulator_priv;\n\tu32 reg_data[MXL_DEMOD_CHAN_PARAMS_BUFF_SIZE];\n\tu32 freq;\n\n\tmutex_lock(&state->base->status_lock);\n\tHYDRA_DEMOD_STATUS_LOCK(state, state->demod);\n\tread_register_block(state,\n\t\t(HYDRA_DMD_STANDARD_ADDR_OFFSET +\n\t\tHYDRA_DMD_STATUS_OFFSET(state->demod)),\n\t\t(MXL_DEMOD_CHAN_PARAMS_BUFF_SIZE * 4),  \n\t\t(u8 *) &reg_data[0]);\n\t \n\tread_register_block(state,\n\t\t(HYDRA_DMD_STATUS_CENTER_FREQ_IN_KHZ_ADDR +\n\t\tHYDRA_DMD_STATUS_OFFSET(state->demod)),\n\t\t(4),  \n\t\t(u8 *) &freq);\n\tHYDRA_DEMOD_STATUS_UNLOCK(state, state->demod);\n\tmutex_unlock(&state->base->status_lock);\n\n\tdev_dbg(state->i2cdev, \"freq=%u delsys=%u srate=%u\\n\",\n\t\tfreq * 1000, reg_data[DMD_STANDARD_ADDR],\n\t\treg_data[DMD_SYMBOL_RATE_ADDR]);\n\tp->symbol_rate = reg_data[DMD_SYMBOL_RATE_ADDR];\n\tp->frequency = freq;\n\t \n\n\tp->fec_inner = conv_fec(reg_data[DMD_FEC_CODE_RATE_ADDR]);\n\tswitch (p->delivery_system) {\n\tcase SYS_DSS:\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tswitch ((enum MXL_HYDRA_PILOTS_E)\n\t\t\treg_data[DMD_DVBS2_PILOT_ON_OFF_ADDR]) {\n\t\tcase MXL_HYDRA_PILOTS_OFF:\n\t\t\tp->pilot = PILOT_OFF;\n\t\t\tbreak;\n\t\tcase MXL_HYDRA_PILOTS_ON:\n\t\t\tp->pilot = PILOT_ON;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase SYS_DVBS:\n\t\tswitch ((enum MXL_HYDRA_MODULATION_E)\n\t\t\treg_data[DMD_MODULATION_SCHEME_ADDR]) {\n\t\tcase MXL_HYDRA_MOD_QPSK:\n\t\t\tp->modulation = QPSK;\n\t\t\tbreak;\n\t\tcase MXL_HYDRA_MOD_8PSK:\n\t\t\tp->modulation = PSK_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tswitch ((enum MXL_HYDRA_ROLLOFF_E)\n\t\t\treg_data[DMD_SPECTRUM_ROLL_OFF_ADDR]) {\n\t\tcase MXL_HYDRA_ROLLOFF_0_20:\n\t\t\tp->rolloff = ROLLOFF_20;\n\t\t\tbreak;\n\t\tcase MXL_HYDRA_ROLLOFF_0_35:\n\t\t\tp->rolloff = ROLLOFF_35;\n\t\t\tbreak;\n\t\tcase MXL_HYDRA_ROLLOFF_0_25:\n\t\t\tp->rolloff = ROLLOFF_25;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int set_input(struct dvb_frontend *fe, int input)\n{\n\tstruct mxl *state = fe->demodulator_priv;\n\n\tstate->tuner = input;\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops mxl_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2, SYS_DSS },\n\t.info = {\n\t\t.name\t\t\t= \"MaxLinear MxL5xx DVB-S/S2 tuner-demodulator\",\n\t\t.frequency_min_hz\t=  300 * MHz,\n\t\t.frequency_max_hz\t= 2350 * MHz,\n\t\t.symbol_rate_min\t= 1000000,\n\t\t.symbol_rate_max\t= 45000000,\n\t\t.caps\t\t\t= FE_CAN_INVERSION_AUTO |\n\t\t\t\t\t  FE_CAN_FEC_AUTO       |\n\t\t\t\t\t  FE_CAN_QPSK           |\n\t\t\t\t\t  FE_CAN_2G_MODULATION\n\t},\n\t.init\t\t\t\t= init,\n\t.release                        = release,\n\t.get_frontend_algo              = get_algo,\n\t.tune                           = tune,\n\t.read_status\t\t\t= read_status,\n\t.sleep\t\t\t\t= sleep,\n\t.get_frontend                   = get_frontend,\n\t.diseqc_send_master_cmd\t\t= send_master_cmd,\n};\n\nstatic struct mxl_base *match_base(struct i2c_adapter  *i2c, u8 adr)\n{\n\tstruct mxl_base *p;\n\n\tlist_for_each_entry(p, &mxllist, mxllist)\n\t\tif (p->i2c == i2c && p->adr == adr)\n\t\t\treturn p;\n\treturn NULL;\n}\n\nstatic void cfg_dev_xtal(struct mxl *state, u32 freq, u32 cap, u32 enable)\n{\n\tif (state->base->can_clkout || !enable)\n\t\tupdate_by_mnemonic(state, 0x90200054, 23, 1, enable);\n\n\tif (freq == 24000000)\n\t\twrite_register(state, HYDRA_CRYSTAL_SETTING, 0);\n\telse\n\t\twrite_register(state, HYDRA_CRYSTAL_SETTING, 1);\n\n\twrite_register(state, HYDRA_CRYSTAL_CAP, cap);\n}\n\nstatic u32 get_big_endian(u8 num_of_bits, const u8 buf[])\n{\n\tu32 ret_value = 0;\n\n\tswitch (num_of_bits) {\n\tcase 24:\n\t\tret_value = (((u32) buf[0]) << 16) |\n\t\t\t(((u32) buf[1]) << 8) | buf[2];\n\t\tbreak;\n\tcase 32:\n\t\tret_value = (((u32) buf[0]) << 24) |\n\t\t\t(((u32) buf[1]) << 16) |\n\t\t\t(((u32) buf[2]) << 8) | buf[3];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret_value;\n}\n\nstatic int write_fw_segment(struct mxl *state,\n\t\t\t    u32 mem_addr, u32 total_size, u8 *data_ptr)\n{\n\tint status;\n\tu32 data_count = 0;\n\tu32 size = 0;\n\tu32 orig_size = 0;\n\tu8 *w_buf_ptr = NULL;\n\tu32 block_size = ((MXL_HYDRA_OEM_MAX_BLOCK_WRITE_LENGTH -\n\t\t\t (MXL_HYDRA_I2C_HDR_SIZE +\n\t\t\t  MXL_HYDRA_REG_SIZE_IN_BYTES)) / 4) * 4;\n\tu8 w_msg_buffer[MXL_HYDRA_OEM_MAX_BLOCK_WRITE_LENGTH -\n\t\t      (MXL_HYDRA_I2C_HDR_SIZE + MXL_HYDRA_REG_SIZE_IN_BYTES)];\n\n\tdo {\n\t\tsize = orig_size = (((u32)(data_count + block_size)) > total_size) ?\n\t\t\t(total_size - data_count) : block_size;\n\n\t\tif (orig_size & 3)\n\t\t\tsize = (orig_size + 4) & ~3;\n\t\tw_buf_ptr = &w_msg_buffer[0];\n\t\tmemset((void *) w_buf_ptr, 0, size);\n\t\tmemcpy((void *) w_buf_ptr, (void *) data_ptr, orig_size);\n\t\tconvert_endian(1, size, w_buf_ptr);\n\t\tstatus  = write_firmware_block(state, mem_addr, size, w_buf_ptr);\n\t\tif (status)\n\t\t\treturn status;\n\t\tdata_count += size;\n\t\tmem_addr   += size;\n\t\tdata_ptr   += size;\n\t} while (data_count < total_size);\n\n\treturn status;\n}\n\nstatic int do_firmware_download(struct mxl *state, u8 *mbin_buffer_ptr,\n\t\t\t\tu32 mbin_buffer_size)\n\n{\n\tint status;\n\tu32 index = 0;\n\tu32 seg_length = 0;\n\tu32 seg_address = 0;\n\tstruct MBIN_FILE_T *mbin_ptr  = (struct MBIN_FILE_T *)mbin_buffer_ptr;\n\tstruct MBIN_SEGMENT_T *segment_ptr;\n\tenum MXL_BOOL_E xcpu_fw_flag = MXL_FALSE;\n\n\tif (mbin_ptr->header.id != MBIN_FILE_HEADER_ID) {\n\t\tdev_err(state->i2cdev, \"%s: Invalid file header ID (%c)\\n\",\n\t\t       __func__, mbin_ptr->header.id);\n\t\treturn -EINVAL;\n\t}\n\tstatus = write_register(state, FW_DL_SIGN_ADDR, 0);\n\tif (status)\n\t\treturn status;\n\tsegment_ptr = (struct MBIN_SEGMENT_T *) (&mbin_ptr->data[0]);\n\tfor (index = 0; index < mbin_ptr->header.num_segments; index++) {\n\t\tif (segment_ptr->header.id != MBIN_SEGMENT_HEADER_ID) {\n\t\t\tdev_err(state->i2cdev, \"%s: Invalid segment header ID (%c)\\n\",\n\t\t\t       __func__, segment_ptr->header.id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tseg_length  = get_big_endian(24,\n\t\t\t\t\t    &(segment_ptr->header.len24[0]));\n\t\tseg_address = get_big_endian(32,\n\t\t\t\t\t    &(segment_ptr->header.address[0]));\n\n\t\tif (state->base->type == MXL_HYDRA_DEVICE_568) {\n\t\t\tif ((((seg_address & 0x90760000) == 0x90760000) ||\n\t\t\t     ((seg_address & 0x90740000) == 0x90740000)) &&\n\t\t\t    (xcpu_fw_flag == MXL_FALSE)) {\n\t\t\t\tupdate_by_mnemonic(state, 0x8003003C, 0, 1, 1);\n\t\t\t\tmsleep(200);\n\t\t\t\twrite_register(state, 0x90720000, 0);\n\t\t\t\tusleep_range(10000, 11000);\n\t\t\t\txcpu_fw_flag = MXL_TRUE;\n\t\t\t}\n\t\t\tstatus = write_fw_segment(state, seg_address,\n\t\t\t\t\t\t  seg_length,\n\t\t\t\t\t\t  (u8 *) segment_ptr->data);\n\t\t} else {\n\t\t\tif (((seg_address & 0x90760000) != 0x90760000) &&\n\t\t\t    ((seg_address & 0x90740000) != 0x90740000))\n\t\t\t\tstatus = write_fw_segment(state, seg_address,\n\t\t\t\t\tseg_length, (u8 *) segment_ptr->data);\n\t\t}\n\t\tif (status)\n\t\t\treturn status;\n\t\tsegment_ptr = (struct MBIN_SEGMENT_T *)\n\t\t\t&(segment_ptr->data[((seg_length + 3) / 4) * 4]);\n\t}\n\treturn status;\n}\n\nstatic int check_fw(struct mxl *state, u8 *mbin, u32 mbin_len)\n{\n\tstruct MBIN_FILE_HEADER_T *fh = (struct MBIN_FILE_HEADER_T *) mbin;\n\tu32 flen = (fh->image_size24[0] << 16) |\n\t\t(fh->image_size24[1] <<  8) | fh->image_size24[2];\n\tu8 *fw, cs = 0;\n\tu32 i;\n\n\tif (fh->id != 'M' || fh->fmt_version != '1' || flen > 0x3FFF0) {\n\t\tdev_info(state->i2cdev, \"Invalid FW Header\\n\");\n\t\treturn -1;\n\t}\n\tfw = mbin + sizeof(struct MBIN_FILE_HEADER_T);\n\tfor (i = 0; i < flen; i += 1)\n\t\tcs += fw[i];\n\tif (cs != fh->image_checksum) {\n\t\tdev_info(state->i2cdev, \"Invalid FW Checksum\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int firmware_download(struct mxl *state, u8 *mbin, u32 mbin_len)\n{\n\tint status;\n\tu32 reg_data = 0;\n\tstruct MXL_HYDRA_SKU_COMMAND_T dev_sku_cfg;\n\tu8 cmd_size = sizeof(struct MXL_HYDRA_SKU_COMMAND_T);\n\tu8 cmd_buff[sizeof(struct MXL_HYDRA_SKU_COMMAND_T) + 6];\n\n\tif (check_fw(state, mbin, mbin_len))\n\t\treturn -1;\n\n\t \n\tstatus = update_by_mnemonic(state, 0x8003003C, 0, 1, 0);\n\tif (status)\n\t\treturn status;\n\tusleep_range(1000, 2000);\n\n\t \n\tstatus = write_register(state, HYDRA_RESET_TRANSPORT_FIFO_REG,\n\t\t\t\tHYDRA_RESET_TRANSPORT_FIFO_DATA);\n\tif (status)\n\t\treturn status;\n\tstatus = write_register(state, HYDRA_RESET_BBAND_REG,\n\t\t\t\tHYDRA_RESET_BBAND_DATA);\n\tif (status)\n\t\treturn status;\n\tstatus = write_register(state, HYDRA_RESET_XBAR_REG,\n\t\t\t\tHYDRA_RESET_XBAR_DATA);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = write_register(state, HYDRA_MODULES_CLK_2_REG,\n\t\t\t\tHYDRA_DISABLE_CLK_2);\n\tif (status)\n\t\treturn status;\n\t \n\tstatus = read_register(state, HYDRA_PRCM_ROOT_CLK_REG, &reg_data);\n\tif (status)\n\t\treturn status;\n\tstatus = do_firmware_download(state, mbin, mbin_len);\n\tif (status)\n\t\treturn status;\n\n\tif (state->base->type == MXL_HYDRA_DEVICE_568) {\n\t\tusleep_range(10000, 11000);\n\n\t\t \n\t\tstatus = write_register(state, 0x90720000, 1);\n\t\tif (status)\n\t\t\treturn status;\n\t\tmsleep(500);\n\n\t\t \n\t\tstatus = write_register(state, 0x9076B510, 1);\n\t\tif (status)\n\t\t\treturn status;\n\t} else {\n\t\t \n\t\tstatus = update_by_mnemonic(state, 0x8003003C, 0, 1, 1);\n\t\tif (status)\n\t\t\treturn status;\n\t\t \n\t\tmsleep(150);\n\t}\n\n\t \n\tstatus = write_register(state, XPT_DMD0_BASEADDR, 0x76543210);\n\tif (status)\n\t\treturn status;\n\n\tif (!firmware_is_alive(state))\n\t\treturn -1;\n\n\tdev_info(state->i2cdev, \"Hydra FW alive. Hail!\\n\");\n\n\t \n\tmsleep(50);\n\n\tdev_sku_cfg.sku_type = state->base->sku_type;\n\tBUILD_HYDRA_CMD(MXL_HYDRA_DEV_CFG_SKU_CMD, MXL_CMD_WRITE,\n\t\t\tcmd_size, &dev_sku_cfg, cmd_buff);\n\tstatus = send_command(state, cmd_size + MXL_HYDRA_CMD_HEADER_SIZE,\n\t\t\t      &cmd_buff[0]);\n\n\treturn status;\n}\n\nstatic int cfg_ts_pad_mux(struct mxl *state, enum MXL_BOOL_E enable_serial_ts)\n{\n\tint status = 0;\n\tu32 pad_mux_value = 0;\n\n\tif (enable_serial_ts == MXL_TRUE) {\n\t\tpad_mux_value = 0;\n\t\tif ((state->base->type == MXL_HYDRA_DEVICE_541) ||\n\t\t    (state->base->type == MXL_HYDRA_DEVICE_541S))\n\t\t\tpad_mux_value = 2;\n\t} else {\n\t\tif ((state->base->type == MXL_HYDRA_DEVICE_581) ||\n\t\t    (state->base->type == MXL_HYDRA_DEVICE_581S))\n\t\t\tpad_mux_value = 2;\n\t\telse\n\t\t\tpad_mux_value = 3;\n\t}\n\n\tswitch (state->base->type) {\n\tcase MXL_HYDRA_DEVICE_561:\n\tcase MXL_HYDRA_DEVICE_581:\n\tcase MXL_HYDRA_DEVICE_541:\n\tcase MXL_HYDRA_DEVICE_541S:\n\tcase MXL_HYDRA_DEVICE_561S:\n\tcase MXL_HYDRA_DEVICE_581S:\n\t\tstatus |= update_by_mnemonic(state, 0x90000170, 24, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state, 0x90000170, 28, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state, 0x90000174, 0, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state, 0x90000174, 4, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state, 0x90000174, 8, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state, 0x90000174, 12, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state, 0x90000174, 16, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state, 0x90000174, 20, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state, 0x90000174, 24, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state, 0x90000174, 28, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state, 0x90000178, 0, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state, 0x90000178, 4, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state, 0x90000178, 8, 3,\n\t\t\t\t\t     pad_mux_value);\n\t\tbreak;\n\n\tcase MXL_HYDRA_DEVICE_544:\n\tcase MXL_HYDRA_DEVICE_542:\n\t\tstatus |= update_by_mnemonic(state, 0x9000016C, 4, 3, 1);\n\t\tstatus |= update_by_mnemonic(state, 0x9000016C, 8, 3, 0);\n\t\tstatus |= update_by_mnemonic(state, 0x9000016C, 12, 3, 0);\n\t\tstatus |= update_by_mnemonic(state, 0x9000016C, 16, 3, 0);\n\t\tstatus |= update_by_mnemonic(state, 0x90000170, 0, 3, 0);\n\t\tstatus |= update_by_mnemonic(state, 0x90000178, 12, 3, 1);\n\t\tstatus |= update_by_mnemonic(state, 0x90000178, 16, 3, 1);\n\t\tstatus |= update_by_mnemonic(state, 0x90000178, 20, 3, 1);\n\t\tstatus |= update_by_mnemonic(state, 0x90000178, 24, 3, 1);\n\t\tstatus |= update_by_mnemonic(state, 0x9000017C, 0, 3, 1);\n\t\tstatus |= update_by_mnemonic(state, 0x9000017C, 4, 3, 1);\n\t\tif (enable_serial_ts == MXL_ENABLE) {\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 4, 3, 0);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 8, 3, 0);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 12, 3, 0);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 16, 3, 0);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 20, 3, 1);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 24, 3, 1);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 28, 3, 2);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 0, 3, 2);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 4, 3, 2);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 8, 3, 2);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 12, 3, 2);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 16, 3, 2);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 20, 3, 2);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 24, 3, 2);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 28, 3, 2);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 0, 3, 2);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 4, 3, 2);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 8, 3, 2);\n\t\t} else {\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 4, 3, 3);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 8, 3, 3);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 12, 3, 3);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 16, 3, 3);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 20, 3, 3);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 24, 3, 3);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 28, 3, 3);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 0, 3, 3);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 4, 3, 3);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 8, 3, 3);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 12, 3, 3);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 16, 3, 3);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 20, 3, 1);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 24, 3, 1);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 28, 3, 1);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 0, 3, 1);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 4, 3, 1);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 8, 3, 1);\n\t\t}\n\t\tbreak;\n\n\tcase MXL_HYDRA_DEVICE_568:\n\t\tif (enable_serial_ts == MXL_FALSE) {\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x9000016C, 8, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x9000016C, 12, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x9000016C, 16, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x9000016C, 20, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x9000016C, 24, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x9000016C, 28, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 0, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 4, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 8, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 12, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 16, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 20, 3, 5);\n\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 24, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 0, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 4, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 8, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 12, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 16, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 20, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 24, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 28, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 0, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 4, 3, pad_mux_value);\n\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 8, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 12, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 16, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 20, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 24, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000178, 28, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x9000017C, 0, 3, 5);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x9000017C, 4, 3, 5);\n\t\t} else {\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 4, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 8, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 12, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 16, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 20, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 24, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000170, 28, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 0, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 4, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 8, 3, pad_mux_value);\n\t\t\tstatus |= update_by_mnemonic(state,\n\t\t\t\t0x90000174, 12, 3, pad_mux_value);\n\t\t}\n\t\tbreak;\n\n\n\tcase MXL_HYDRA_DEVICE_584:\n\tdefault:\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\t0x90000170, 4, 3, pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\t0x90000170, 8, 3, pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\t0x90000170, 12, 3, pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\t0x90000170, 16, 3, pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\t0x90000170, 20, 3, pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\t0x90000170, 24, 3, pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\t0x90000170, 28, 3, pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\t0x90000174, 0, 3, pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\t0x90000174, 4, 3, pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\t0x90000174, 8, 3, pad_mux_value);\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\t0x90000174, 12, 3, pad_mux_value);\n\t\tbreak;\n\t}\n\treturn status;\n}\n\nstatic int set_drive_strength(struct mxl *state,\n\t\tenum MXL_HYDRA_TS_DRIVE_STRENGTH_E ts_drive_strength)\n{\n\tint stat = 0;\n\tu32 val;\n\n\tread_register(state, 0x90000194, &val);\n\tdev_info(state->i2cdev, \"DIGIO = %08x\\n\", val);\n\tdev_info(state->i2cdev, \"set drive_strength = %u\\n\", ts_drive_strength);\n\n\n\tstat |= update_by_mnemonic(state, 0x90000194, 0, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x90000194, 20, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x90000194, 24, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x90000198, 12, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x90000198, 16, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x90000198, 20, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x90000198, 24, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x9000019C, 0, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x9000019C, 4, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x9000019C, 8, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x9000019C, 24, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x9000019C, 28, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x900001A0, 0, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x900001A0, 4, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x900001A0, 20, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x900001A0, 24, 3, ts_drive_strength);\n\tstat |= update_by_mnemonic(state, 0x900001A0, 28, 3, ts_drive_strength);\n\n\treturn stat;\n}\n\nstatic int enable_tuner(struct mxl *state, u32 tuner, u32 enable)\n{\n\tint stat = 0;\n\tstruct MXL_HYDRA_TUNER_CMD ctrl_tuner_cmd;\n\tu8 cmd_size = sizeof(ctrl_tuner_cmd);\n\tu8 cmd_buff[MXL_HYDRA_OEM_MAX_CMD_BUFF_LEN];\n\tu32 val, count = 10;\n\n\tctrl_tuner_cmd.tuner_id = tuner;\n\tctrl_tuner_cmd.enable = enable;\n\tBUILD_HYDRA_CMD(MXL_HYDRA_TUNER_ACTIVATE_CMD, MXL_CMD_WRITE,\n\t\t\tcmd_size, &ctrl_tuner_cmd, cmd_buff);\n\tstat = send_command(state, cmd_size + MXL_HYDRA_CMD_HEADER_SIZE,\n\t\t\t    &cmd_buff[0]);\n\tif (stat)\n\t\treturn stat;\n\tread_register(state, HYDRA_TUNER_ENABLE_COMPLETE, &val);\n\twhile (--count && ((val >> tuner) & 1) != enable) {\n\t\tmsleep(20);\n\t\tread_register(state, HYDRA_TUNER_ENABLE_COMPLETE, &val);\n\t}\n\tif (!count)\n\t\treturn -1;\n\tread_register(state, HYDRA_TUNER_ENABLE_COMPLETE, &val);\n\tdev_dbg(state->i2cdev, \"tuner %u ready = %u\\n\",\n\t\ttuner, (val >> tuner) & 1);\n\n\treturn 0;\n}\n\n\nstatic int config_ts(struct mxl *state, enum MXL_HYDRA_DEMOD_ID_E demod_id,\n\t\t     struct MXL_HYDRA_MPEGOUT_PARAM_T *mpeg_out_param_ptr)\n{\n\tint status = 0;\n\tu32 nco_count_min = 0;\n\tu32 clk_type = 0;\n\n\tstruct MXL_REG_FIELD_T xpt_sync_polarity[MXL_HYDRA_DEMOD_MAX] = {\n\t\t{0x90700010, 8, 1}, {0x90700010, 9, 1},\n\t\t{0x90700010, 10, 1}, {0x90700010, 11, 1},\n\t\t{0x90700010, 12, 1}, {0x90700010, 13, 1},\n\t\t{0x90700010, 14, 1}, {0x90700010, 15, 1} };\n\tstruct MXL_REG_FIELD_T xpt_clock_polarity[MXL_HYDRA_DEMOD_MAX] = {\n\t\t{0x90700010, 16, 1}, {0x90700010, 17, 1},\n\t\t{0x90700010, 18, 1}, {0x90700010, 19, 1},\n\t\t{0x90700010, 20, 1}, {0x90700010, 21, 1},\n\t\t{0x90700010, 22, 1}, {0x90700010, 23, 1} };\n\tstruct MXL_REG_FIELD_T xpt_valid_polarity[MXL_HYDRA_DEMOD_MAX] = {\n\t\t{0x90700014, 0, 1}, {0x90700014, 1, 1},\n\t\t{0x90700014, 2, 1}, {0x90700014, 3, 1},\n\t\t{0x90700014, 4, 1}, {0x90700014, 5, 1},\n\t\t{0x90700014, 6, 1}, {0x90700014, 7, 1} };\n\tstruct MXL_REG_FIELD_T xpt_ts_clock_phase[MXL_HYDRA_DEMOD_MAX] = {\n\t\t{0x90700018, 0, 3}, {0x90700018, 4, 3},\n\t\t{0x90700018, 8, 3}, {0x90700018, 12, 3},\n\t\t{0x90700018, 16, 3}, {0x90700018, 20, 3},\n\t\t{0x90700018, 24, 3}, {0x90700018, 28, 3} };\n\tstruct MXL_REG_FIELD_T xpt_lsb_first[MXL_HYDRA_DEMOD_MAX] = {\n\t\t{0x9070000C, 16, 1}, {0x9070000C, 17, 1},\n\t\t{0x9070000C, 18, 1}, {0x9070000C, 19, 1},\n\t\t{0x9070000C, 20, 1}, {0x9070000C, 21, 1},\n\t\t{0x9070000C, 22, 1}, {0x9070000C, 23, 1} };\n\tstruct MXL_REG_FIELD_T xpt_sync_byte[MXL_HYDRA_DEMOD_MAX] = {\n\t\t{0x90700010, 0, 1}, {0x90700010, 1, 1},\n\t\t{0x90700010, 2, 1}, {0x90700010, 3, 1},\n\t\t{0x90700010, 4, 1}, {0x90700010, 5, 1},\n\t\t{0x90700010, 6, 1}, {0x90700010, 7, 1} };\n\tstruct MXL_REG_FIELD_T xpt_enable_output[MXL_HYDRA_DEMOD_MAX] = {\n\t\t{0x9070000C, 0, 1}, {0x9070000C, 1, 1},\n\t\t{0x9070000C, 2, 1}, {0x9070000C, 3, 1},\n\t\t{0x9070000C, 4, 1}, {0x9070000C, 5, 1},\n\t\t{0x9070000C, 6, 1}, {0x9070000C, 7, 1} };\n\tstruct MXL_REG_FIELD_T xpt_err_replace_sync[MXL_HYDRA_DEMOD_MAX] = {\n\t\t{0x9070000C, 24, 1}, {0x9070000C, 25, 1},\n\t\t{0x9070000C, 26, 1}, {0x9070000C, 27, 1},\n\t\t{0x9070000C, 28, 1}, {0x9070000C, 29, 1},\n\t\t{0x9070000C, 30, 1}, {0x9070000C, 31, 1} };\n\tstruct MXL_REG_FIELD_T xpt_err_replace_valid[MXL_HYDRA_DEMOD_MAX] = {\n\t\t{0x90700014, 8, 1}, {0x90700014, 9, 1},\n\t\t{0x90700014, 10, 1}, {0x90700014, 11, 1},\n\t\t{0x90700014, 12, 1}, {0x90700014, 13, 1},\n\t\t{0x90700014, 14, 1}, {0x90700014, 15, 1} };\n\tstruct MXL_REG_FIELD_T xpt_continuous_clock[MXL_HYDRA_DEMOD_MAX] = {\n\t\t{0x907001D4, 0, 1}, {0x907001D4, 1, 1},\n\t\t{0x907001D4, 2, 1}, {0x907001D4, 3, 1},\n\t\t{0x907001D4, 4, 1}, {0x907001D4, 5, 1},\n\t\t{0x907001D4, 6, 1}, {0x907001D4, 7, 1} };\n\tstruct MXL_REG_FIELD_T xpt_nco_clock_rate[MXL_HYDRA_DEMOD_MAX] = {\n\t\t{0x90700044, 16, 80}, {0x90700044, 16, 81},\n\t\t{0x90700044, 16, 82}, {0x90700044, 16, 83},\n\t\t{0x90700044, 16, 84}, {0x90700044, 16, 85},\n\t\t{0x90700044, 16, 86}, {0x90700044, 16, 87} };\n\n\tdemod_id = state->base->ts_map[demod_id];\n\n\tif (mpeg_out_param_ptr->enable == MXL_ENABLE) {\n\t\tif (mpeg_out_param_ptr->mpeg_mode ==\n\t\t    MXL_HYDRA_MPEG_MODE_PARALLEL) {\n\t\t} else {\n\t\t\tcfg_ts_pad_mux(state, MXL_TRUE);\n\t\t\tupdate_by_mnemonic(state,\n\t\t\t\t0x90700010, 27, 1, MXL_FALSE);\n\t\t}\n\t}\n\n\tnco_count_min =\n\t\t(u32)(MXL_HYDRA_NCO_CLK / mpeg_out_param_ptr->max_mpeg_clk_rate);\n\n\tif (state->base->chipversion >= 2) {\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\txpt_nco_clock_rate[demod_id].reg_addr,  \n\t\t\txpt_nco_clock_rate[demod_id].lsb_pos,  \n\t\t\txpt_nco_clock_rate[demod_id].num_of_bits,  \n\t\t\tnco_count_min);  \n\t} else\n\t\tupdate_by_mnemonic(state, 0x90700044, 16, 8, nco_count_min);\n\n\tif (mpeg_out_param_ptr->mpeg_clk_type == MXL_HYDRA_MPEG_CLK_CONTINUOUS)\n\t\tclk_type = 1;\n\n\tif (mpeg_out_param_ptr->mpeg_mode < MXL_HYDRA_MPEG_MODE_PARALLEL) {\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\txpt_continuous_clock[demod_id].reg_addr,\n\t\t\txpt_continuous_clock[demod_id].lsb_pos,\n\t\t\txpt_continuous_clock[demod_id].num_of_bits,\n\t\t\tclk_type);\n\t} else\n\t\tupdate_by_mnemonic(state, 0x907001D4, 8, 1, clk_type);\n\n\tstatus |= update_by_mnemonic(state,\n\t\txpt_sync_polarity[demod_id].reg_addr,\n\t\txpt_sync_polarity[demod_id].lsb_pos,\n\t\txpt_sync_polarity[demod_id].num_of_bits,\n\t\tmpeg_out_param_ptr->mpeg_sync_pol);\n\n\tstatus |= update_by_mnemonic(state,\n\t\txpt_valid_polarity[demod_id].reg_addr,\n\t\txpt_valid_polarity[demod_id].lsb_pos,\n\t\txpt_valid_polarity[demod_id].num_of_bits,\n\t\tmpeg_out_param_ptr->mpeg_valid_pol);\n\n\tstatus |= update_by_mnemonic(state,\n\t\txpt_clock_polarity[demod_id].reg_addr,\n\t\txpt_clock_polarity[demod_id].lsb_pos,\n\t\txpt_clock_polarity[demod_id].num_of_bits,\n\t\tmpeg_out_param_ptr->mpeg_clk_pol);\n\n\tstatus |= update_by_mnemonic(state,\n\t\txpt_sync_byte[demod_id].reg_addr,\n\t\txpt_sync_byte[demod_id].lsb_pos,\n\t\txpt_sync_byte[demod_id].num_of_bits,\n\t\tmpeg_out_param_ptr->mpeg_sync_pulse_width);\n\n\tstatus |= update_by_mnemonic(state,\n\t\txpt_ts_clock_phase[demod_id].reg_addr,\n\t\txpt_ts_clock_phase[demod_id].lsb_pos,\n\t\txpt_ts_clock_phase[demod_id].num_of_bits,\n\t\tmpeg_out_param_ptr->mpeg_clk_phase);\n\n\tstatus |= update_by_mnemonic(state,\n\t\txpt_lsb_first[demod_id].reg_addr,\n\t\txpt_lsb_first[demod_id].lsb_pos,\n\t\txpt_lsb_first[demod_id].num_of_bits,\n\t\tmpeg_out_param_ptr->lsb_or_msb_first);\n\n\tswitch (mpeg_out_param_ptr->mpeg_error_indication) {\n\tcase MXL_HYDRA_MPEG_ERR_REPLACE_SYNC:\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\txpt_err_replace_sync[demod_id].reg_addr,\n\t\t\txpt_err_replace_sync[demod_id].lsb_pos,\n\t\t\txpt_err_replace_sync[demod_id].num_of_bits,\n\t\t\tMXL_TRUE);\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\txpt_err_replace_valid[demod_id].reg_addr,\n\t\t\txpt_err_replace_valid[demod_id].lsb_pos,\n\t\t\txpt_err_replace_valid[demod_id].num_of_bits,\n\t\t\tMXL_FALSE);\n\t\tbreak;\n\n\tcase MXL_HYDRA_MPEG_ERR_REPLACE_VALID:\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\txpt_err_replace_sync[demod_id].reg_addr,\n\t\t\txpt_err_replace_sync[demod_id].lsb_pos,\n\t\t\txpt_err_replace_sync[demod_id].num_of_bits,\n\t\t\tMXL_FALSE);\n\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\txpt_err_replace_valid[demod_id].reg_addr,\n\t\t\txpt_err_replace_valid[demod_id].lsb_pos,\n\t\t\txpt_err_replace_valid[demod_id].num_of_bits,\n\t\t\tMXL_TRUE);\n\t\tbreak;\n\n\tcase MXL_HYDRA_MPEG_ERR_INDICATION_DISABLED:\n\tdefault:\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\txpt_err_replace_sync[demod_id].reg_addr,\n\t\t\txpt_err_replace_sync[demod_id].lsb_pos,\n\t\t\txpt_err_replace_sync[demod_id].num_of_bits,\n\t\t\tMXL_FALSE);\n\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\txpt_err_replace_valid[demod_id].reg_addr,\n\t\t\txpt_err_replace_valid[demod_id].lsb_pos,\n\t\t\txpt_err_replace_valid[demod_id].num_of_bits,\n\t\t\tMXL_FALSE);\n\n\t\tbreak;\n\n\t}\n\n\tif (mpeg_out_param_ptr->mpeg_mode != MXL_HYDRA_MPEG_MODE_PARALLEL) {\n\t\tstatus |= update_by_mnemonic(state,\n\t\t\txpt_enable_output[demod_id].reg_addr,\n\t\t\txpt_enable_output[demod_id].lsb_pos,\n\t\t\txpt_enable_output[demod_id].num_of_bits,\n\t\t\tmpeg_out_param_ptr->enable);\n\t}\n\treturn status;\n}\n\nstatic int config_mux(struct mxl *state)\n{\n\tupdate_by_mnemonic(state, 0x9070000C, 0, 1, 0);\n\tupdate_by_mnemonic(state, 0x9070000C, 1, 1, 0);\n\tupdate_by_mnemonic(state, 0x9070000C, 2, 1, 0);\n\tupdate_by_mnemonic(state, 0x9070000C, 3, 1, 0);\n\tupdate_by_mnemonic(state, 0x9070000C, 4, 1, 0);\n\tupdate_by_mnemonic(state, 0x9070000C, 5, 1, 0);\n\tupdate_by_mnemonic(state, 0x9070000C, 6, 1, 0);\n\tupdate_by_mnemonic(state, 0x9070000C, 7, 1, 0);\n\tupdate_by_mnemonic(state, 0x90700008, 0, 2, 1);\n\tupdate_by_mnemonic(state, 0x90700008, 2, 2, 1);\n\treturn 0;\n}\n\nstatic int load_fw(struct mxl *state, struct mxl5xx_cfg *cfg)\n{\n\tint stat = 0;\n\tu8 *buf;\n\n\tif (cfg->fw)\n\t\treturn firmware_download(state, cfg->fw, cfg->fw_len);\n\n\tif (!cfg->fw_read)\n\t\treturn -1;\n\n\tbuf = vmalloc(0x40000);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tcfg->fw_read(cfg->fw_priv, buf, 0x40000);\n\tstat = firmware_download(state, buf, 0x40000);\n\tvfree(buf);\n\n\treturn stat;\n}\n\nstatic int validate_sku(struct mxl *state)\n{\n\tu32 pad_mux_bond = 0, prcm_chip_id = 0, prcm_so_cid = 0;\n\tint status;\n\tu32 type = state->base->type;\n\n\tstatus = read_by_mnemonic(state, 0x90000190, 0, 3, &pad_mux_bond);\n\tstatus |= read_by_mnemonic(state, 0x80030000, 0, 12, &prcm_chip_id);\n\tstatus |= read_by_mnemonic(state, 0x80030004, 24, 8, &prcm_so_cid);\n\tif (status)\n\t\treturn -1;\n\n\tdev_info(state->i2cdev, \"padMuxBond=%08x, prcmChipId=%08x, prcmSoCId=%08x\\n\",\n\t\tpad_mux_bond, prcm_chip_id, prcm_so_cid);\n\n\tif (prcm_chip_id != 0x560) {\n\t\tswitch (pad_mux_bond) {\n\t\tcase MXL_HYDRA_SKU_ID_581:\n\t\t\tif (type == MXL_HYDRA_DEVICE_581)\n\t\t\t\treturn 0;\n\t\t\tif (type == MXL_HYDRA_DEVICE_581S) {\n\t\t\t\tstate->base->type = MXL_HYDRA_DEVICE_581;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MXL_HYDRA_SKU_ID_584:\n\t\t\tif (type == MXL_HYDRA_DEVICE_584)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase MXL_HYDRA_SKU_ID_544:\n\t\t\tif (type == MXL_HYDRA_DEVICE_544)\n\t\t\t\treturn 0;\n\t\t\tif (type == MXL_HYDRA_DEVICE_542)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase MXL_HYDRA_SKU_ID_582:\n\t\t\tif (type == MXL_HYDRA_DEVICE_582)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int get_fwinfo(struct mxl *state)\n{\n\tint status;\n\tu32 val = 0;\n\n\tstatus = read_by_mnemonic(state, 0x90000190, 0, 3, &val);\n\tif (status)\n\t\treturn status;\n\tdev_info(state->i2cdev, \"chipID=%08x\\n\", val);\n\n\tstatus = read_by_mnemonic(state, 0x80030004, 8, 8, &val);\n\tif (status)\n\t\treturn status;\n\tdev_info(state->i2cdev, \"chipVer=%08x\\n\", val);\n\n\tstatus = read_register(state, HYDRA_FIRMWARE_VERSION, &val);\n\tif (status)\n\t\treturn status;\n\tdev_info(state->i2cdev, \"FWVer=%08x\\n\", val);\n\n\tstate->base->fwversion = val;\n\treturn status;\n}\n\n\nstatic u8 ts_map1_to_1[MXL_HYDRA_DEMOD_MAX] = {\n\tMXL_HYDRA_DEMOD_ID_0,\n\tMXL_HYDRA_DEMOD_ID_1,\n\tMXL_HYDRA_DEMOD_ID_2,\n\tMXL_HYDRA_DEMOD_ID_3,\n\tMXL_HYDRA_DEMOD_ID_4,\n\tMXL_HYDRA_DEMOD_ID_5,\n\tMXL_HYDRA_DEMOD_ID_6,\n\tMXL_HYDRA_DEMOD_ID_7,\n};\n\nstatic u8 ts_map54x[MXL_HYDRA_DEMOD_MAX] = {\n\tMXL_HYDRA_DEMOD_ID_2,\n\tMXL_HYDRA_DEMOD_ID_3,\n\tMXL_HYDRA_DEMOD_ID_4,\n\tMXL_HYDRA_DEMOD_ID_5,\n\tMXL_HYDRA_DEMOD_MAX,\n\tMXL_HYDRA_DEMOD_MAX,\n\tMXL_HYDRA_DEMOD_MAX,\n\tMXL_HYDRA_DEMOD_MAX,\n};\n\nstatic int probe(struct mxl *state, struct mxl5xx_cfg *cfg)\n{\n\tu32 chipver;\n\tint fw, status, j;\n\tstruct MXL_HYDRA_MPEGOUT_PARAM_T mpeg_interface_cfg;\n\n\tstate->base->ts_map = ts_map1_to_1;\n\n\tswitch (state->base->type) {\n\tcase MXL_HYDRA_DEVICE_581:\n\tcase MXL_HYDRA_DEVICE_581S:\n\t\tstate->base->can_clkout = 1;\n\t\tstate->base->demod_num = 8;\n\t\tstate->base->tuner_num = 1;\n\t\tstate->base->sku_type = MXL_HYDRA_SKU_TYPE_581;\n\t\tbreak;\n\tcase MXL_HYDRA_DEVICE_582:\n\t\tstate->base->can_clkout = 1;\n\t\tstate->base->demod_num = 8;\n\t\tstate->base->tuner_num = 3;\n\t\tstate->base->sku_type = MXL_HYDRA_SKU_TYPE_582;\n\t\tbreak;\n\tcase MXL_HYDRA_DEVICE_585:\n\t\tstate->base->can_clkout = 0;\n\t\tstate->base->demod_num = 8;\n\t\tstate->base->tuner_num = 4;\n\t\tstate->base->sku_type = MXL_HYDRA_SKU_TYPE_585;\n\t\tbreak;\n\tcase MXL_HYDRA_DEVICE_544:\n\t\tstate->base->can_clkout = 0;\n\t\tstate->base->demod_num = 4;\n\t\tstate->base->tuner_num = 4;\n\t\tstate->base->sku_type = MXL_HYDRA_SKU_TYPE_544;\n\t\tstate->base->ts_map = ts_map54x;\n\t\tbreak;\n\tcase MXL_HYDRA_DEVICE_541:\n\tcase MXL_HYDRA_DEVICE_541S:\n\t\tstate->base->can_clkout = 0;\n\t\tstate->base->demod_num = 4;\n\t\tstate->base->tuner_num = 1;\n\t\tstate->base->sku_type = MXL_HYDRA_SKU_TYPE_541;\n\t\tstate->base->ts_map = ts_map54x;\n\t\tbreak;\n\tcase MXL_HYDRA_DEVICE_561:\n\tcase MXL_HYDRA_DEVICE_561S:\n\t\tstate->base->can_clkout = 0;\n\t\tstate->base->demod_num = 6;\n\t\tstate->base->tuner_num = 1;\n\t\tstate->base->sku_type = MXL_HYDRA_SKU_TYPE_561;\n\t\tbreak;\n\tcase MXL_HYDRA_DEVICE_568:\n\t\tstate->base->can_clkout = 0;\n\t\tstate->base->demod_num = 8;\n\t\tstate->base->tuner_num = 1;\n\t\tstate->base->chan_bond = 1;\n\t\tstate->base->sku_type = MXL_HYDRA_SKU_TYPE_568;\n\t\tbreak;\n\tcase MXL_HYDRA_DEVICE_542:\n\t\tstate->base->can_clkout = 1;\n\t\tstate->base->demod_num = 4;\n\t\tstate->base->tuner_num = 3;\n\t\tstate->base->sku_type = MXL_HYDRA_SKU_TYPE_542;\n\t\tstate->base->ts_map = ts_map54x;\n\t\tbreak;\n\tcase MXL_HYDRA_DEVICE_TEST:\n\tcase MXL_HYDRA_DEVICE_584:\n\tdefault:\n\t\tstate->base->can_clkout = 0;\n\t\tstate->base->demod_num = 8;\n\t\tstate->base->tuner_num = 4;\n\t\tstate->base->sku_type = MXL_HYDRA_SKU_TYPE_584;\n\t\tbreak;\n\t}\n\n\tstatus = validate_sku(state);\n\tif (status)\n\t\treturn status;\n\n\tupdate_by_mnemonic(state, 0x80030014, 9, 1, 1);\n\tupdate_by_mnemonic(state, 0x8003003C, 12, 1, 1);\n\tstatus = read_by_mnemonic(state, 0x80030000, 12, 4, &chipver);\n\tif (status)\n\t\tstate->base->chipversion = 0;\n\telse\n\t\tstate->base->chipversion = (chipver == 2) ? 2 : 1;\n\tdev_info(state->i2cdev, \"Hydra chip version %u\\n\",\n\t\tstate->base->chipversion);\n\n\tcfg_dev_xtal(state, cfg->clk, cfg->cap, 0);\n\n\tfw = firmware_is_alive(state);\n\tif (!fw) {\n\t\tstatus = load_fw(state, cfg);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\tget_fwinfo(state);\n\n\tconfig_mux(state);\n\tmpeg_interface_cfg.enable = MXL_ENABLE;\n\tmpeg_interface_cfg.lsb_or_msb_first = MXL_HYDRA_MPEG_SERIAL_MSB_1ST;\n\t \n\tif (cfg->ts_clk)\n\t\tmpeg_interface_cfg.max_mpeg_clk_rate = cfg->ts_clk;\n\telse\n\t\tmpeg_interface_cfg.max_mpeg_clk_rate = 69;  \n\tmpeg_interface_cfg.mpeg_clk_phase = MXL_HYDRA_MPEG_CLK_PHASE_SHIFT_0_DEG;\n\tmpeg_interface_cfg.mpeg_clk_pol = MXL_HYDRA_MPEG_CLK_IN_PHASE;\n\t \n\tmpeg_interface_cfg.mpeg_clk_type = MXL_HYDRA_MPEG_CLK_CONTINUOUS;\n\tmpeg_interface_cfg.mpeg_error_indication =\n\t\tMXL_HYDRA_MPEG_ERR_INDICATION_DISABLED;\n\tmpeg_interface_cfg.mpeg_mode = MXL_HYDRA_MPEG_MODE_SERIAL_3_WIRE;\n\tmpeg_interface_cfg.mpeg_sync_pol  = MXL_HYDRA_MPEG_ACTIVE_HIGH;\n\tmpeg_interface_cfg.mpeg_sync_pulse_width  = MXL_HYDRA_MPEG_SYNC_WIDTH_BIT;\n\tmpeg_interface_cfg.mpeg_valid_pol  = MXL_HYDRA_MPEG_ACTIVE_HIGH;\n\n\tfor (j = 0; j < state->base->demod_num; j++) {\n\t\tstatus = config_ts(state, (enum MXL_HYDRA_DEMOD_ID_E) j,\n\t\t\t\t   &mpeg_interface_cfg);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\tset_drive_strength(state, 1);\n\treturn 0;\n}\n\nstruct dvb_frontend *mxl5xx_attach(struct i2c_adapter *i2c,\n\tstruct mxl5xx_cfg *cfg, u32 demod, u32 tuner,\n\tint (**fn_set_input)(struct dvb_frontend *, int))\n{\n\tstruct mxl *state;\n\tstruct mxl_base *base;\n\n\tstate = kzalloc(sizeof(struct mxl), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tstate->demod = demod;\n\tstate->tuner = tuner;\n\tstate->tuner_in_use = 0xffffffff;\n\tstate->i2cdev = &i2c->dev;\n\n\tbase = match_base(i2c, cfg->adr);\n\tif (base) {\n\t\tbase->count++;\n\t\tif (base->count > base->demod_num)\n\t\t\tgoto fail;\n\t\tstate->base = base;\n\t} else {\n\t\tbase = kzalloc(sizeof(struct mxl_base), GFP_KERNEL);\n\t\tif (!base)\n\t\t\tgoto fail;\n\t\tbase->i2c = i2c;\n\t\tbase->adr = cfg->adr;\n\t\tbase->type = cfg->type;\n\t\tbase->count = 1;\n\t\tmutex_init(&base->i2c_lock);\n\t\tmutex_init(&base->status_lock);\n\t\tmutex_init(&base->tune_lock);\n\t\tINIT_LIST_HEAD(&base->mxls);\n\n\t\tstate->base = base;\n\t\tif (probe(state, cfg) < 0) {\n\t\t\tkfree(base);\n\t\t\tgoto fail;\n\t\t}\n\t\tlist_add(&base->mxllist, &mxllist);\n\t}\n\tstate->fe.ops               = mxl_ops;\n\tstate->xbar[0]              = 4;\n\tstate->xbar[1]              = demod;\n\tstate->xbar[2]              = 8;\n\tstate->fe.demodulator_priv  = state;\n\t*fn_set_input               = set_input;\n\n\tlist_add(&state->mxl, &base->mxls);\n\treturn &state->fe;\n\nfail:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(mxl5xx_attach);\n\nMODULE_DESCRIPTION(\"MaxLinear MxL5xx DVB-S/S2 tuner-demodulator driver\");\nMODULE_AUTHOR(\"Ralph and Marcus Metzler, Metzler Brothers Systementwicklung GbR\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}