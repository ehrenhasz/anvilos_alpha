{
  "module_name": "tda8261.c",
  "hash_id": "f42d25d8f6ff5513ff2cb8fb9a5690163d96805fe9e491d7ace52f3057036a4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tda8261.c",
  "human_readable_source": "\n \n\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"tda8261.h\"\n\nstruct tda8261_state {\n\tstruct dvb_frontend\t\t*fe;\n\tstruct i2c_adapter\t\t*i2c;\n\tconst struct tda8261_config\t*config;\n\n\t \n\tu32 frequency;\n\tu32 bandwidth;\n};\n\nstatic int tda8261_read(struct tda8261_state *state, u8 *buf)\n{\n\tconst struct tda8261_config *config = state->config;\n\tint err = 0;\n\tstruct i2c_msg msg = { .addr\t= config->addr, .flags = I2C_M_RD,.buf = buf,  .len = 1 };\n\n\tif ((err = i2c_transfer(state->i2c, &msg, 1)) != 1)\n\t\tpr_err(\"%s: read error, err=%d\\n\", __func__, err);\n\n\treturn err;\n}\n\nstatic int tda8261_write(struct tda8261_state *state, u8 *buf)\n{\n\tconst struct tda8261_config *config = state->config;\n\tint err = 0;\n\tstruct i2c_msg msg = { .addr = config->addr, .flags = 0, .buf = buf, .len = 4 };\n\n\tif ((err = i2c_transfer(state->i2c, &msg, 1)) != 1)\n\t\tpr_err(\"%s: write error, err=%d\\n\", __func__, err);\n\n\treturn err;\n}\n\nstatic int tda8261_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tstruct tda8261_state *state = fe->tuner_priv;\n\tu8 result = 0;\n\tint err = 0;\n\n\t*status = 0;\n\n\tif ((err = tda8261_read(state, &result)) < 0) {\n\t\tpr_err(\"%s: I/O Error\\n\", __func__);\n\t\treturn err;\n\t}\n\tif ((result >> 6) & 0x01) {\n\t\tpr_debug(\"%s: Tuner Phase Locked\\n\", __func__);\n\t\t*status = 1;\n\t}\n\n\treturn err;\n}\n\nstatic const u32 div_tab[] = { 2000, 1000,  500,  250,  125 };  \nstatic const u8  ref_div[] = { 0x00, 0x01, 0x02, 0x05, 0x07 };\n\nstatic int tda8261_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct tda8261_state *state = fe->tuner_priv;\n\n\t*frequency = state->frequency;\n\n\treturn 0;\n}\n\nstatic int tda8261_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct tda8261_state *state = fe->tuner_priv;\n\tconst struct tda8261_config *config = state->config;\n\tu32 frequency, N, status = 0;\n\tu8 buf[4];\n\tint err = 0;\n\n\t \n\tfrequency = c->frequency;\n\tif ((frequency < 950000) || (frequency > 2150000)) {\n\t\tpr_warn(\"%s: Frequency beyond limits, frequency=%d\\n\",\n\t\t\t__func__, frequency);\n\t\treturn -EINVAL;\n\t}\n\tN = (frequency + (div_tab[config->step_size] - 1)) / div_tab[config->step_size];\n\tpr_debug(\"%s: Step size=%d, Divider=%d, PG=0x%02x (%d)\\n\",\n\t\t__func__, config->step_size, div_tab[config->step_size], N, N);\n\n\tbuf[0] = (N >> 8) & 0xff;\n\tbuf[1] = N & 0xff;\n\tbuf[2] = (0x01 << 7) | ((ref_div[config->step_size] & 0x07) << 1);\n\n\tif (frequency < 1450000)\n\t\tbuf[3] = 0x00;\n\telse if (frequency < 2000000)\n\t\tbuf[3] = 0x40;\n\telse if (frequency < 2150000)\n\t\tbuf[3] = 0x80;\n\n\t \n\terr = tda8261_write(state, buf);\n\tif (err < 0) {\n\t\tpr_err(\"%s: I/O Error\\n\", __func__);\n\t\treturn err;\n\t}\n\t \n\tpr_debug(\"%s: Waiting to Phase LOCK\\n\", __func__);\n\tmsleep(20);\n\t \n\tif ((err = tda8261_get_status(fe, &status)) < 0) {\n\t\tpr_err(\"%s: I/O Error\\n\", __func__);\n\t\treturn err;\n\t}\n\tif (status == 1) {\n\t\tpr_debug(\"%s: Tuner Phase locked: status=%d\\n\", __func__,\n\t\t\t status);\n\t\tstate->frequency = frequency;  \n\t} else {\n\t\tpr_debug(\"%s: No Phase lock: status=%d\\n\", __func__, status);\n\t}\n\n\treturn 0;\n}\n\nstatic void tda8261_release(struct dvb_frontend *fe)\n{\n\tstruct tda8261_state *state = fe->tuner_priv;\n\n\tfe->tuner_priv = NULL;\n\tkfree(state);\n}\n\nstatic const struct dvb_tuner_ops tda8261_ops = {\n\n\t.info = {\n\t\t.name\t\t   = \"TDA8261\",\n\t\t.frequency_min_hz  =  950 * MHz,\n\t\t.frequency_max_hz  = 2150 * MHz,\n\t},\n\n\t.set_params\t= tda8261_set_params,\n\t.get_frequency\t= tda8261_get_frequency,\n\t.get_status\t= tda8261_get_status,\n\t.release\t= tda8261_release\n};\n\nstruct dvb_frontend *tda8261_attach(struct dvb_frontend *fe,\n\t\t\t\t    const struct tda8261_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct tda8261_state *state = NULL;\n\n\tif ((state = kzalloc(sizeof (struct tda8261_state), GFP_KERNEL)) == NULL)\n\t\tgoto exit;\n\n\tstate->config\t\t= config;\n\tstate->i2c\t\t= i2c;\n\tstate->fe\t\t= fe;\n\tfe->tuner_priv\t\t= state;\n\tfe->ops.tuner_ops\t= tda8261_ops;\n\n\tfe->ops.tuner_ops.info.frequency_step_hz = div_tab[config->step_size] * kHz;\n\n\tpr_info(\"%s: Attaching TDA8261 8PSK/QPSK tuner\\n\", __func__);\n\n\treturn fe;\n\nexit:\n\tkfree(state);\n\treturn NULL;\n}\n\nEXPORT_SYMBOL_GPL(tda8261_attach);\n\nMODULE_AUTHOR(\"Manu Abraham\");\nMODULE_DESCRIPTION(\"TDA8261 8PSK/QPSK Tuner\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}