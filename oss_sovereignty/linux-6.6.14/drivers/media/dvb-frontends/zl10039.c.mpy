{
  "module_name": "zl10039.c",
  "hash_id": "73a2bbb4818e5ed27abb0f78e70cde19330c984227f966576bf5fd3d1bc463d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/zl10039.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/dvb/frontend.h>\n\n#include <media/dvb_frontend.h>\n#include \"zl10039.h\"\n\nstatic int debug;\n\n \n#define MAX_XFER_SIZE  64\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_DEBUG args); \\\n\t} while (0)\n\nenum zl10039_model_id {\n\tID_ZL10039 = 1\n};\n\nstruct zl10039_state {\n\tstruct i2c_adapter *i2c;\n\tu8 i2c_addr;\n\tu8 id;\n};\n\nenum zl10039_reg_addr {\n\tPLL0 = 0,\n\tPLL1,\n\tPLL2,\n\tPLL3,\n\tRFFE,\n\tBASE0,\n\tBASE1,\n\tBASE2,\n\tLO0,\n\tLO1,\n\tLO2,\n\tLO3,\n\tLO4,\n\tLO5,\n\tLO6,\n\tGENERAL\n};\n\nstatic int zl10039_read(const struct zl10039_state *state,\n\t\t\tconst enum zl10039_reg_addr reg, u8 *buf,\n\t\t\tconst size_t count)\n{\n\tu8 regbuf[] = { reg };\n\tstruct i2c_msg msg[] = {\n\t\t{ \n\t\t\t.addr = state->i2c_addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = regbuf,\n\t\t\t.len = 1,\n\t\t}, { \n\t\t\t.addr = state->i2c_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = buf,\n\t\t\t.len = count,\n\t\t},\n\t};\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (i2c_transfer(state->i2c, msg, 2) != 2) {\n\t\tdprintk(\"%s: i2c read error\\n\", __func__);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;  \n}\n\nstatic int zl10039_write(struct zl10039_state *state,\n\t\t\tconst enum zl10039_reg_addr reg, const u8 *src,\n\t\t\tconst size_t count)\n{\n\tu8 buf[MAX_XFER_SIZE];\n\tstruct i2c_msg msg = {\n\t\t.addr = state->i2c_addr,\n\t\t.flags = 0,\n\t\t.buf = buf,\n\t\t.len = count + 1,\n\t};\n\n\tif (1 + count > sizeof(buf)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: i2c wr reg=%04x: len=%zu is too big!\\n\",\n\t\t       KBUILD_MODNAME, reg, count);\n\t\treturn -EINVAL;\n\t}\n\n\tdprintk(\"%s\\n\", __func__);\n\t \n\tbuf[0] = reg;\n\tmemcpy(&buf[1], src, count);\n\tif (i2c_transfer(state->i2c, &msg, 1) != 1) {\n\t\tdprintk(\"%s: i2c write error\\n\", __func__);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;  \n}\n\nstatic inline int zl10039_readreg(struct zl10039_state *state,\n\t\t\t\tconst enum zl10039_reg_addr reg, u8 *val)\n{\n\treturn zl10039_read(state, reg, val, 1);\n}\n\nstatic inline int zl10039_writereg(struct zl10039_state *state,\n\t\t\t\tconst enum zl10039_reg_addr reg,\n\t\t\t\tconst u8 val)\n{\n\tconst u8 tmp = val;  \n\n\treturn zl10039_write(state, reg, &tmp, 1);\n}\n\nstatic int zl10039_init(struct dvb_frontend *fe)\n{\n\tstruct zl10039_state *state = fe->tuner_priv;\n\tint ret;\n\n\tdprintk(\"%s\\n\", __func__);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t \n\tret = zl10039_writereg(state, GENERAL, 0x40);\n\tif (ret < 0) {\n\t\tdprintk(\"Note: i2c write error normal when resetting the tuner\\n\");\n\t}\n\t \n\tret = zl10039_writereg(state, GENERAL, 0x01);\n\tif (ret < 0) {\n\t\tdprintk(\"Tuner power up failed\\n\");\n\t\treturn ret;\n\t}\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\nstatic int zl10039_sleep(struct dvb_frontend *fe)\n{\n\tstruct zl10039_state *state = fe->tuner_priv;\n\tint ret;\n\n\tdprintk(\"%s\\n\", __func__);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tret = zl10039_writereg(state, GENERAL, 0x80);\n\tif (ret < 0) {\n\t\tdprintk(\"Tuner sleep failed\\n\");\n\t\treturn ret;\n\t}\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\nstatic int zl10039_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct zl10039_state *state = fe->tuner_priv;\n\tu8 buf[6];\n\tu8 bf;\n\tu32 fbw;\n\tu32 div;\n\tint ret;\n\n\tdprintk(\"%s\\n\", __func__);\n\tdprintk(\"Set frequency = %d, symbol rate = %d\\n\",\n\t\t\tc->frequency, c->symbol_rate);\n\n\t \n\t \n\tdiv = (c->frequency * 1000) / 126387;\n\tfbw = (c->symbol_rate * 27) / 32000;\n\t \n\tbf = ((fbw * 5088) / 1011100) - 1;\n\n\t \n\tbuf[0] = (div >> 8) & 0x7f;\n\tbuf[1] = (div >> 0) & 0xff;\n\t \n\t \n\tbuf[2] = 0x1D;\n\t \n\tbuf[3] = 0x40;\n\t \n\tbuf[4] = 0x6E;  \n\t \n\tbuf[5] = bf;\n\n\t \n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t \n\tret = zl10039_writereg(state, BASE1, 0x0A);\n\tif (ret < 0)\n\t\tgoto error;\n\t \n\tret = zl10039_write(state, PLL0, buf, sizeof(buf));\n\tif (ret < 0)\n\t\tgoto error;\n\t \n\tret = zl10039_writereg(state, BASE1, 0x6A);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\treturn 0;\nerror:\n\tdprintk(\"Error setting tuner\\n\");\n\treturn ret;\n}\n\nstatic void zl10039_release(struct dvb_frontend *fe)\n{\n\tstruct zl10039_state *state = fe->tuner_priv;\n\n\tdprintk(\"%s\\n\", __func__);\n\tkfree(state);\n\tfe->tuner_priv = NULL;\n}\n\nstatic const struct dvb_tuner_ops zl10039_ops = {\n\t.release = zl10039_release,\n\t.init = zl10039_init,\n\t.sleep = zl10039_sleep,\n\t.set_params = zl10039_set_params,\n};\n\nstruct dvb_frontend *zl10039_attach(struct dvb_frontend *fe,\n\t\tu8 i2c_addr, struct i2c_adapter *i2c)\n{\n\tstruct zl10039_state *state = NULL;\n\n\tdprintk(\"%s\\n\", __func__);\n\tstate = kmalloc(sizeof(struct zl10039_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\tstate->i2c = i2c;\n\tstate->i2c_addr = i2c_addr;\n\n\t \n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t \n\tif (zl10039_readreg(state, GENERAL, &state->id) < 0) {\n\t\t \n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t\tgoto error;\n\t}\n\t \n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tstate->id = state->id & 0x0f;\n\tswitch (state->id) {\n\tcase ID_ZL10039:\n\t\tstrscpy(fe->ops.tuner_ops.info.name,\n\t\t\t\"Zarlink ZL10039 DVB-S tuner\",\n\t\t\tsizeof(fe->ops.tuner_ops.info.name));\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"Chip ID=%x does not match a known type\\n\", state->id);\n\t\tgoto error;\n\t}\n\n\tmemcpy(&fe->ops.tuner_ops, &zl10039_ops, sizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = state;\n\tdprintk(\"Tuner attached @ i2c address 0x%02x\\n\", i2c_addr);\n\treturn fe;\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(zl10039_attach);\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\nMODULE_DESCRIPTION(\"Zarlink ZL10039 DVB-S tuner driver\");\nMODULE_AUTHOR(\"Jan D. Louw <jd.louw@mweb.co.za>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}