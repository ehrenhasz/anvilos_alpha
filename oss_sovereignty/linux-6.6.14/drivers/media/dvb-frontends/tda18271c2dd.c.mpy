{
  "module_name": "tda18271c2dd.c",
  "hash_id": "43828ddb47f804afa176f831b2c7d53a3d36bdb4364f6dd122f3b6f887dbd38d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tda18271c2dd.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"tda18271c2dd.h\"\n\n \n#define MAX_XFER_SIZE  64\n\nstruct SStandardParam {\n\ts32   m_IFFrequency;\n\tu32   m_BandWidth;\n\tu8    m_EP3_4_0;\n\tu8    m_EB22;\n};\n\nstruct SMap {\n\tu32   m_Frequency;\n\tu8    m_Param;\n};\n\nstruct SMapI {\n\tu32   m_Frequency;\n\ts32    m_Param;\n};\n\nstruct SMap2 {\n\tu32   m_Frequency;\n\tu8    m_Param1;\n\tu8    m_Param2;\n};\n\nstruct SRFBandMap {\n\tu32   m_RF_max;\n\tu32   m_RF1_Default;\n\tu32   m_RF2_Default;\n\tu32   m_RF3_Default;\n};\n\nenum ERegister {\n\tID = 0,\n\tTM,\n\tPL,\n\tEP1, EP2, EP3, EP4, EP5,\n\tCPD, CD1, CD2, CD3,\n\tMPD, MD1, MD2, MD3,\n\tEB1, EB2, EB3, EB4, EB5, EB6, EB7, EB8, EB9, EB10,\n\tEB11, EB12, EB13, EB14, EB15, EB16, EB17, EB18, EB19, EB20,\n\tEB21, EB22, EB23,\n\tNUM_REGS\n};\n\nstruct tda_state {\n\tstruct i2c_adapter *i2c;\n\tu8 adr;\n\n\tu32   m_Frequency;\n\tu32   IF;\n\n\tu8    m_IFLevelAnalog;\n\tu8    m_IFLevelDigital;\n\tu8    m_IFLevelDVBC;\n\tu8    m_IFLevelDVBT;\n\n\tu8    m_EP4;\n\tu8    m_EP3_Standby;\n\n\tbool  m_bMaster;\n\n\ts32   m_SettlingTime;\n\n\tu8    m_Regs[NUM_REGS];\n\n\t \n\tu32   m_RF1[7];\n\ts32   m_RF_A1[7];\n\ts32   m_RF_B1[7];\n\tu32   m_RF2[7];\n\ts32   m_RF_A2[7];\n\ts32   m_RF_B2[7];\n\tu32   m_RF3[7];\n\n\tu8    m_TMValue_RFCal;     \n\n\tbool  m_bFMInput;          \n\n};\n\nstatic int PowerScan(struct tda_state *state,\n\t\t     u8 RFBand, u32 RF_in,\n\t\t     u32 *pRF_Out, bool *pbcal);\n\nstatic int i2c_readn(struct i2c_adapter *adapter, u8 adr, u8 *data, int len)\n{\n\tstruct i2c_msg msgs[1] = {{.addr = adr,  .flags = I2C_M_RD,\n\t\t\t\t   .buf  = data, .len   = len} };\n\treturn (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;\n}\n\nstatic int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)\n{\n\tstruct i2c_msg msg = {.addr = adr, .flags = 0,\n\t\t\t      .buf = data, .len = len};\n\n\tif (i2c_transfer(adap, &msg, 1) != 1) {\n\t\tprintk(KERN_ERR \"tda18271c2dd: i2c write error at addr %i\\n\", adr);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int WriteRegs(struct tda_state *state,\n\t\t     u8 SubAddr, u8 *Regs, u16 nRegs)\n{\n\tu8 data[MAX_XFER_SIZE];\n\n\tif (1 + nRegs > sizeof(data)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: i2c wr: len=%d is too big!\\n\",\n\t\t       KBUILD_MODNAME, nRegs);\n\t\treturn -EINVAL;\n\t}\n\n\tdata[0] = SubAddr;\n\tmemcpy(data + 1, Regs, nRegs);\n\treturn i2c_write(state->i2c, state->adr, data, nRegs + 1);\n}\n\nstatic int WriteReg(struct tda_state *state, u8 SubAddr, u8 Reg)\n{\n\tu8 msg[2] = {SubAddr, Reg};\n\n\treturn i2c_write(state->i2c, state->adr, msg, 2);\n}\n\nstatic int Read(struct tda_state *state, u8 * Regs)\n{\n\treturn i2c_readn(state->i2c, state->adr, Regs, 16);\n}\n\nstatic int ReadExtented(struct tda_state *state, u8 * Regs)\n{\n\treturn i2c_readn(state->i2c, state->adr, Regs, NUM_REGS);\n}\n\nstatic int UpdateRegs(struct tda_state *state, u8 RegFrom, u8 RegTo)\n{\n\treturn WriteRegs(state, RegFrom,\n\t\t\t &state->m_Regs[RegFrom], RegTo-RegFrom+1);\n}\nstatic int UpdateReg(struct tda_state *state, u8 Reg)\n{\n\treturn WriteReg(state, Reg, state->m_Regs[Reg]);\n}\n\n#include \"tda18271c2dd_maps.h\"\n\nstatic void reset(struct tda_state *state)\n{\n\tu32   ulIFLevelAnalog = 0;\n\tu32   ulIFLevelDigital = 2;\n\tu32   ulIFLevelDVBC = 7;\n\tu32   ulIFLevelDVBT = 6;\n\tu32   ulXTOut = 0;\n\tu32   ulStandbyMode = 0x06;     \n\tu32   ulSlave = 0;\n\tu32   ulFMInput = 0;\n\tu32   ulSettlingTime = 100;\n\n\tstate->m_Frequency         = 0;\n\tstate->m_SettlingTime = 100;\n\tstate->m_IFLevelAnalog = (ulIFLevelAnalog & 0x07) << 2;\n\tstate->m_IFLevelDigital = (ulIFLevelDigital & 0x07) << 2;\n\tstate->m_IFLevelDVBC = (ulIFLevelDVBC & 0x07) << 2;\n\tstate->m_IFLevelDVBT = (ulIFLevelDVBT & 0x07) << 2;\n\n\tstate->m_EP4 = 0x20;\n\tif (ulXTOut != 0)\n\t\tstate->m_EP4 |= 0x40;\n\n\tstate->m_EP3_Standby = ((ulStandbyMode & 0x07) << 5) | 0x0F;\n\tstate->m_bMaster = (ulSlave == 0);\n\n\tstate->m_SettlingTime = ulSettlingTime;\n\n\tstate->m_bFMInput = (ulFMInput == 2);\n}\n\nstatic bool SearchMap1(const struct SMap map[], u32 frequency, u8 *param)\n{\n\tint i = 0;\n\n\twhile ((map[i].m_Frequency != 0) && (frequency > map[i].m_Frequency))\n\t\ti += 1;\n\tif (map[i].m_Frequency == 0)\n\t\treturn false;\n\t*param = map[i].m_Param;\n\treturn true;\n}\n\nstatic bool SearchMap2(const struct SMapI map[], u32 frequency, s32 *param)\n{\n\tint i = 0;\n\n\twhile ((map[i].m_Frequency != 0) &&\n\t       (frequency > map[i].m_Frequency))\n\t\ti += 1;\n\tif (map[i].m_Frequency == 0)\n\t\treturn false;\n\t*param = map[i].m_Param;\n\treturn true;\n}\n\nstatic bool SearchMap3(const struct SMap2 map[], u32 frequency, u8 *param1,\n\t\t       u8 *param2)\n{\n\tint i = 0;\n\n\twhile ((map[i].m_Frequency != 0) &&\n\t       (frequency > map[i].m_Frequency))\n\t\ti += 1;\n\tif (map[i].m_Frequency == 0)\n\t\treturn false;\n\t*param1 = map[i].m_Param1;\n\t*param2 = map[i].m_Param2;\n\treturn true;\n}\n\nstatic bool SearchMap4(const struct SRFBandMap map[], u32 frequency, u8 *rfband)\n{\n\tint i = 0;\n\n\twhile (i < 7 && (frequency > map[i].m_RF_max))\n\t\ti += 1;\n\tif (i == 7)\n\t\treturn false;\n\t*rfband = i;\n\treturn true;\n}\n\nstatic int ThermometerRead(struct tda_state *state, u8 *pTM_Value)\n{\n\tint status = 0;\n\n\tdo {\n\t\tu8 Regs[16];\n\t\tstate->m_Regs[TM] |= 0x10;\n\t\tstatus = UpdateReg(state, TM);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = Read(state, Regs);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (((Regs[TM] & 0x0F) == 0 && (Regs[TM] & 0x20) == 0x20) ||\n\t\t    ((Regs[TM] & 0x0F) == 8 && (Regs[TM] & 0x20) == 0x00)) {\n\t\t\tstate->m_Regs[TM] ^= 0x20;\n\t\t\tstatus = UpdateReg(state, TM);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tmsleep(10);\n\t\t\tstatus = Read(state, Regs);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t*pTM_Value = (Regs[TM] & 0x20)\n\t\t\t\t? m_Thermometer_Map_2[Regs[TM] & 0x0F]\n\t\t\t\t: m_Thermometer_Map_1[Regs[TM] & 0x0F] ;\n\t\tstate->m_Regs[TM] &= ~0x10;         \n\t\tstatus = UpdateReg(state, TM);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstate->m_Regs[EP4] &= ~0x03;        \n\t\tstatus = UpdateReg(state, EP4);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t} while (0);\n\n\treturn status;\n}\n\nstatic int StandBy(struct tda_state *state)\n{\n\tint status = 0;\n\tdo {\n\t\tstate->m_Regs[EB12] &= ~0x20;   \n\t\tstatus = UpdateReg(state, EB12);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstate->m_Regs[EB18] &= ~0x83;   \n\t\tstatus = UpdateReg(state, EB18);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstate->m_Regs[EB21] |= 0x03;  \n\t\tstate->m_Regs[EP3] = state->m_EP3_Standby;\n\t\tstatus = UpdateReg(state, EP3);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstate->m_Regs[EB23] &= ~0x06;  \n\t\tstatus = UpdateRegs(state, EB21, EB23);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t} while (0);\n\treturn status;\n}\n\nstatic int CalcMainPLL(struct tda_state *state, u32 freq)\n{\n\n\tu8  PostDiv;\n\tu8  Div;\n\tu64 OscFreq;\n\tu32 MainDiv;\n\n\tif (!SearchMap3(m_Main_PLL_Map, freq, &PostDiv, &Div))\n\t\treturn -EINVAL;\n\n\tOscFreq = (u64) freq * (u64) Div;\n\tOscFreq *= (u64) 16384;\n\tdo_div(OscFreq, (u64)16000000);\n\tMainDiv = OscFreq;\n\n\tstate->m_Regs[MPD] = PostDiv & 0x77;\n\tstate->m_Regs[MD1] = ((MainDiv >> 16) & 0x7F);\n\tstate->m_Regs[MD2] = ((MainDiv >>  8) & 0xFF);\n\tstate->m_Regs[MD3] = (MainDiv & 0xFF);\n\n\treturn UpdateRegs(state, MPD, MD3);\n}\n\nstatic int CalcCalPLL(struct tda_state *state, u32 freq)\n{\n\tu8 PostDiv;\n\tu8 Div;\n\tu64 OscFreq;\n\tu32 CalDiv;\n\n\tif (!SearchMap3(m_Cal_PLL_Map, freq, &PostDiv, &Div))\n\t\treturn -EINVAL;\n\n\tOscFreq = (u64)freq * (u64)Div;\n\t \n\tOscFreq *= (u64)16384;\n\tdo_div(OscFreq, (u64)16000000);\n\tCalDiv = OscFreq;\n\n\tstate->m_Regs[CPD] = PostDiv;\n\tstate->m_Regs[CD1] = ((CalDiv >> 16) & 0xFF);\n\tstate->m_Regs[CD2] = ((CalDiv >>  8) & 0xFF);\n\tstate->m_Regs[CD3] = (CalDiv & 0xFF);\n\n\treturn UpdateRegs(state, CPD, CD3);\n}\n\nstatic int CalibrateRF(struct tda_state *state,\n\t\t       u8 RFBand, u32 freq, s32 *pCprog)\n{\n\tint status = 0;\n\tu8 Regs[NUM_REGS];\n\tdo {\n\t\tu8 BP_Filter = 0;\n\t\tu8 GainTaper = 0;\n\t\tu8 RFC_K = 0;\n\t\tu8 RFC_M = 0;\n\n\t\tstate->m_Regs[EP4] &= ~0x03;  \n\t\tstatus = UpdateReg(state, EP4);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstate->m_Regs[EB18] |= 0x03;   \n\t\tstatus = UpdateReg(state, EB18);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\t\t \n\t\tif (state->m_Regs[ID] != 0x83)     \n\t\t\tstate->m_Regs[EP3] |= 0x40;  \n\n\t\tif (!(SearchMap1(m_BP_Filter_Map, freq, &BP_Filter) &&\n\t\t\tSearchMap1(m_GainTaper_Map, freq, &GainTaper) &&\n\t\t\tSearchMap3(m_KM_Map, freq, &RFC_K, &RFC_M)))\n\t\t\treturn -EINVAL;\n\n\t\tstate->m_Regs[EP1] = (state->m_Regs[EP1] & ~0x07) | BP_Filter;\n\t\tstate->m_Regs[EP2] = (RFBand << 5) | GainTaper;\n\n\t\tstate->m_Regs[EB13] = (state->m_Regs[EB13] & ~0x7C) | (RFC_K << 4) | (RFC_M << 2);\n\n\t\tstatus = UpdateRegs(state, EP1, EP3);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = UpdateReg(state, EB13);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstate->m_Regs[EB4] |= 0x20;     \n\t\tstatus = UpdateReg(state, EB4);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstate->m_Regs[EB7] |= 0x20;     \n\t\tstatus = UpdateReg(state, EB7);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstate->m_Regs[EB14] = 0;  \n\t\tstatus = UpdateReg(state, EB14);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstate->m_Regs[EB20] &= ~0x20;   \n\t\tstatus = UpdateReg(state, EB20);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstate->m_Regs[EP4] |= 0x03;   \n\t\tstatus = UpdateRegs(state, EP4, EP5);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = CalcCalPLL(state, freq);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = CalcMainPLL(state, freq + 1000000);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tmsleep(5);\n\t\tstatus = UpdateReg(state, EP2);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = UpdateReg(state, EP1);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = UpdateReg(state, EP2);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = UpdateReg(state, EP1);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstate->m_Regs[EB4] &= ~0x20;     \n\t\tstatus = UpdateReg(state, EB4);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstate->m_Regs[EB7] &= ~0x20;     \n\t\tstatus = UpdateReg(state, EB7);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(10);\n\n\t\tstate->m_Regs[EB20] |= 0x20;   \n\t\tstatus = UpdateReg(state, EB20);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(60);\n\n\t\tstate->m_Regs[EP4] &= ~0x03;   \n\t\tstate->m_Regs[EP3] &= ~0x40;  \n\t\tstate->m_Regs[EB18] &= ~0x03;   \n\t\tstatus = UpdateReg(state, EB18);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = UpdateRegs(state, EP3, EP4);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = UpdateReg(state, EP1);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = ReadExtented(state, Regs);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t*pCprog = Regs[EB14];\n\n\t} while (0);\n\treturn status;\n}\n\nstatic int RFTrackingFiltersInit(struct tda_state *state,\n\t\t\t\t u8 RFBand)\n{\n\tint status = 0;\n\n\tu32   RF1 = m_RF_Band_Map[RFBand].m_RF1_Default;\n\tu32   RF2 = m_RF_Band_Map[RFBand].m_RF2_Default;\n\tu32   RF3 = m_RF_Band_Map[RFBand].m_RF3_Default;\n\tbool    bcal = false;\n\n\ts32    Cprog_cal1 = 0;\n\ts32    Cprog_table1 = 0;\n\ts32    Cprog_cal2 = 0;\n\ts32    Cprog_table2 = 0;\n\ts32    Cprog_cal3 = 0;\n\ts32    Cprog_table3 = 0;\n\n\tstate->m_RF_A1[RFBand] = 0;\n\tstate->m_RF_B1[RFBand] = 0;\n\tstate->m_RF_A2[RFBand] = 0;\n\tstate->m_RF_B2[RFBand] = 0;\n\n\tdo {\n\t\tstatus = PowerScan(state, RFBand, RF1, &RF1, &bcal);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (bcal) {\n\t\t\tstatus = CalibrateRF(state, RFBand, RF1, &Cprog_cal1);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tSearchMap2(m_RF_Cal_Map, RF1, &Cprog_table1);\n\t\tif (!bcal)\n\t\t\tCprog_cal1 = Cprog_table1;\n\t\tstate->m_RF_B1[RFBand] = Cprog_cal1 - Cprog_table1;\n\t\t \n\n\t\tif (RF2 == 0)\n\t\t\tbreak;\n\n\t\tstatus = PowerScan(state, RFBand, RF2, &RF2, &bcal);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (bcal) {\n\t\t\tstatus = CalibrateRF(state, RFBand, RF2, &Cprog_cal2);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tSearchMap2(m_RF_Cal_Map, RF2, &Cprog_table2);\n\t\tif (!bcal)\n\t\t\tCprog_cal2 = Cprog_table2;\n\n\t\tstate->m_RF_A1[RFBand] =\n\t\t\t(Cprog_cal2 - Cprog_table2 - Cprog_cal1 + Cprog_table1) /\n\t\t\t((s32)(RF2) - (s32)(RF1));\n\n\t\tif (RF3 == 0)\n\t\t\tbreak;\n\n\t\tstatus = PowerScan(state, RFBand, RF3, &RF3, &bcal);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (bcal) {\n\t\t\tstatus = CalibrateRF(state, RFBand, RF3, &Cprog_cal3);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tSearchMap2(m_RF_Cal_Map, RF3, &Cprog_table3);\n\t\tif (!bcal)\n\t\t\tCprog_cal3 = Cprog_table3;\n\t\tstate->m_RF_A2[RFBand] = (Cprog_cal3 - Cprog_table3 - Cprog_cal2 + Cprog_table2) / ((s32)(RF3) - (s32)(RF2));\n\t\tstate->m_RF_B2[RFBand] = Cprog_cal2 - Cprog_table2;\n\n\t} while (0);\n\n\tstate->m_RF1[RFBand] = RF1;\n\tstate->m_RF2[RFBand] = RF2;\n\tstate->m_RF3[RFBand] = RF3;\n\n#if 0\n\tprintk(KERN_ERR \"tda18271c2dd: %s %d RF1 = %d A1 = %d B1 = %d RF2 = %d A2 = %d B2 = %d RF3 = %d\\n\", __func__,\n\t       RFBand, RF1, state->m_RF_A1[RFBand], state->m_RF_B1[RFBand], RF2,\n\t       state->m_RF_A2[RFBand], state->m_RF_B2[RFBand], RF3);\n#endif\n\n\treturn status;\n}\n\nstatic int PowerScan(struct tda_state *state,\n\t\t     u8 RFBand, u32 RF_in, u32 *pRF_Out, bool *pbcal)\n{\n\tint status = 0;\n\tdo {\n\t\tu8   Gain_Taper = 0;\n\t\ts32  RFC_Cprog = 0;\n\t\tu8   CID_Target = 0;\n\t\tu8   CountLimit = 0;\n\t\tu32  freq_MainPLL;\n\t\tu8   Regs[NUM_REGS];\n\t\tu8   CID_Gain;\n\t\ts32  Count = 0;\n\t\tint  sign  = 1;\n\t\tbool wait = false;\n\n\t\tif (!(SearchMap2(m_RF_Cal_Map, RF_in, &RFC_Cprog) &&\n\t\t      SearchMap1(m_GainTaper_Map, RF_in, &Gain_Taper) &&\n\t\t      SearchMap3(m_CID_Target_Map, RF_in, &CID_Target, &CountLimit))) {\n\n\t\t\tprintk(KERN_ERR \"tda18271c2dd: %s Search map failed\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tstate->m_Regs[EP2] = (RFBand << 5) | Gain_Taper;\n\t\tstate->m_Regs[EB14] = (RFC_Cprog);\n\t\tstatus = UpdateReg(state, EP2);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = UpdateReg(state, EB14);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tfreq_MainPLL = RF_in + 1000000;\n\t\tstatus = CalcMainPLL(state, freq_MainPLL);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(5);\n\t\tstate->m_Regs[EP4] = (state->m_Regs[EP4] & ~0x03) | 1;     \n\t\tstatus = UpdateReg(state, EP4);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = UpdateReg(state, EP2);   \n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = ReadExtented(state, Regs);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tCID_Gain = Regs[EB10] & 0x3F;\n\t\tstate->m_Regs[ID] = Regs[ID];   \n\n\t\t*pRF_Out = RF_in;\n\n\t\twhile (CID_Gain < CID_Target) {\n\t\t\tfreq_MainPLL = RF_in + sign * Count + 1000000;\n\t\t\tstatus = CalcMainPLL(state, freq_MainPLL);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tmsleep(wait ? 5 : 1);\n\t\t\twait = false;\n\t\t\tstatus = UpdateReg(state, EP2);   \n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = ReadExtented(state, Regs);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tCID_Gain = Regs[EB10] & 0x3F;\n\t\t\tCount += 200000;\n\n\t\t\tif (Count < CountLimit * 100000)\n\t\t\t\tcontinue;\n\t\t\tif (sign < 0)\n\t\t\t\tbreak;\n\n\t\t\tsign = -sign;\n\t\t\tCount = 200000;\n\t\t\twait = true;\n\t\t}\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (CID_Gain >= CID_Target) {\n\t\t\t*pbcal = true;\n\t\t\t*pRF_Out = freq_MainPLL - 1000000;\n\t\t} else\n\t\t\t*pbcal = false;\n\t} while (0);\n\n\treturn status;\n}\n\nstatic int PowerScanInit(struct tda_state *state)\n{\n\tint status = 0;\n\tdo {\n\t\tstate->m_Regs[EP3] = (state->m_Regs[EP3] & ~0x1F) | 0x12;\n\t\tstate->m_Regs[EP4] = (state->m_Regs[EP4] & ~0x1F);  \n\t\tstatus = UpdateRegs(state, EP3, EP4);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstate->m_Regs[EB18] = (state->m_Regs[EB18] & ~0x03);  \n\t\tstatus = UpdateReg(state, EB18);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstate->m_Regs[EB21] = (state->m_Regs[EB21] & ~0x03);  \n\t\tstate->m_Regs[EB23] = (state->m_Regs[EB23] | 0x06);  \n\t\tstatus = UpdateRegs(state, EB21, EB23);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t} while (0);\n\treturn status;\n}\n\nstatic int CalcRFFilterCurve(struct tda_state *state)\n{\n\tint status = 0;\n\tdo {\n\t\tmsleep(200);       \n\t\tstatus = PowerScanInit(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = RFTrackingFiltersInit(state, 0);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = RFTrackingFiltersInit(state, 1);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = RFTrackingFiltersInit(state, 2);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = RFTrackingFiltersInit(state, 3);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = RFTrackingFiltersInit(state, 4);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = RFTrackingFiltersInit(state, 5);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = RFTrackingFiltersInit(state, 6);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = ThermometerRead(state, &state->m_TMValue_RFCal);  \n\t\tif (status < 0)\n\t\t\tbreak;\n\t} while (0);\n\n\treturn status;\n}\n\nstatic int FixedContentsI2CUpdate(struct tda_state *state)\n{\n\tstatic u8 InitRegs[] = {\n\t\t0x08, 0x80, 0xC6,\n\t\t0xDF, 0x16, 0x60, 0x80,\n\t\t0x80, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00,\n\t\t0xFC, 0x01, 0x84, 0x41,\n\t\t0x01, 0x84, 0x40, 0x07,\n\t\t0x00, 0x00, 0x96, 0x3F,\n\t\t0xC1, 0x00, 0x8F, 0x00,\n\t\t0x00, 0x8C, 0x00, 0x20,\n\t\t0xB3, 0x48, 0xB0,\n\t};\n\tint status = 0;\n\tmemcpy(&state->m_Regs[TM], InitRegs, EB23 - TM + 1);\n\tdo {\n\t\tstatus = UpdateRegs(state, TM, EB23);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tstate->m_Regs[EB17] = 0x00;\n\t\tstatus = UpdateReg(state, EB17);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstate->m_Regs[EB17] = 0x03;\n\t\tstatus = UpdateReg(state, EB17);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstate->m_Regs[EB17] = 0x43;\n\t\tstatus = UpdateReg(state, EB17);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstate->m_Regs[EB17] = 0x4C;\n\t\tstatus = UpdateReg(state, EB17);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tstate->m_Regs[EP3] = 0x1F;\n\t\tstate->m_Regs[EP4] = 0x66;\n\t\tstate->m_Regs[EP5] = 0x81;\n\t\tstate->m_Regs[CPD] = 0xCC;\n\t\tstate->m_Regs[CD1] = 0x6C;\n\t\tstate->m_Regs[CD2] = 0x00;\n\t\tstate->m_Regs[CD3] = 0x00;\n\t\tstate->m_Regs[MPD] = 0xC5;\n\t\tstate->m_Regs[MD1] = 0x77;\n\t\tstate->m_Regs[MD2] = 0x08;\n\t\tstate->m_Regs[MD3] = 0x00;\n\t\tstatus = UpdateRegs(state, EP2, MD3);  \n\t\tif (status < 0)\n\t\t\tbreak;\n\n#if 0\n\t\tstate->m_Regs[EB4] = 0x61;           \n\t\tstatus = UpdateReg(state, EB4);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t\tstate->m_Regs[EB4] = 0x41;\n\t\tstatus = UpdateReg(state, EB4);\n\t\tif (status < 0)\n\t\t\tbreak;\n#endif\n\n\t\tmsleep(5);\n\t\tstatus = UpdateReg(state, EP1);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(5);\n\n\t\tstate->m_Regs[EP5] = 0x85;\n\t\tstate->m_Regs[CPD] = 0xCB;\n\t\tstate->m_Regs[CD1] = 0x66;\n\t\tstate->m_Regs[CD2] = 0x70;\n\t\tstatus = UpdateRegs(state, EP3, CD3);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(5);\n\t\tstatus = UpdateReg(state, EP2);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(30);\n\n\t\t \n\t\tstate->m_Regs[EP5] = 0x82;\n\t\tstate->m_Regs[CPD] = 0xA8;\n\t\tstate->m_Regs[CD2] = 0x00;\n\t\tstate->m_Regs[MPD] = 0xA1;  \n\t\tstate->m_Regs[MD1] = 0x73;\n\t\tstate->m_Regs[MD2] = 0x1A;\n\t\tstatus = UpdateRegs(state, EP3, MD3);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tmsleep(5);\n\t\tstatus = UpdateReg(state, EP1);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(5);\n\n\t\tstate->m_Regs[EP5] = 0x86;\n\t\tstate->m_Regs[CPD] = 0xA8;\n\t\tstate->m_Regs[CD1] = 0x66;\n\t\tstate->m_Regs[CD2] = 0xA0;\n\t\tstatus = UpdateRegs(state, EP3, CD3);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(5);\n\t\tstatus = UpdateReg(state, EP2);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(30);\n\n\t\t \n\t\tstate->m_Regs[EP5] = 0x83;\n\t\tstate->m_Regs[CPD] = 0x98;\n\t\tstate->m_Regs[CD1] = 0x65;\n\t\tstate->m_Regs[CD2] = 0x00;\n\t\tstate->m_Regs[MPD] = 0x91;   \n\t\tstate->m_Regs[MD1] = 0x71;\n\t\tstate->m_Regs[MD2] = 0xCD;\n\t\tstatus = UpdateRegs(state, EP3, MD3);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(5);\n\t\tstatus = UpdateReg(state, EP1);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(5);\n\t\tstate->m_Regs[EP5] = 0x87;\n\t\tstate->m_Regs[CD1] = 0x65;\n\t\tstate->m_Regs[CD2] = 0x50;\n\t\tstatus = UpdateRegs(state, EP3, CD3);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(5);\n\t\tstatus = UpdateReg(state, EP2);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tmsleep(30);\n\n\t\t \n\t\tstate->m_Regs[EP4] = 0x64;\n\t\tstatus = UpdateReg(state, EP4);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = UpdateReg(state, EP1);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t} while (0);\n\treturn status;\n}\n\nstatic int InitCal(struct tda_state *state)\n{\n\tint status = 0;\n\n\tdo {\n\t\tstatus = FixedContentsI2CUpdate(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = CalcRFFilterCurve(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = StandBy(state);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\t \n\t} while (0);\n\treturn status;\n};\n\nstatic int RFTrackingFiltersCorrection(struct tda_state *state,\n\t\t\t\t       u32 Frequency)\n{\n\tint status = 0;\n\ts32 Cprog_table;\n\tu8 RFBand;\n\tu8 dCoverdT;\n\n\tif (!SearchMap2(m_RF_Cal_Map, Frequency, &Cprog_table) ||\n\t    !SearchMap4(m_RF_Band_Map, Frequency, &RFBand) ||\n\t    !SearchMap1(m_RF_Cal_DC_Over_DT_Map, Frequency, &dCoverdT))\n\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tu8 TMValue_Current;\n\t\tu32   RF1 = state->m_RF1[RFBand];\n\t\tu32   RF2 = state->m_RF1[RFBand];\n\t\tu32   RF3 = state->m_RF1[RFBand];\n\t\ts32    RF_A1 = state->m_RF_A1[RFBand];\n\t\ts32    RF_B1 = state->m_RF_B1[RFBand];\n\t\ts32    RF_A2 = state->m_RF_A2[RFBand];\n\t\ts32    RF_B2 = state->m_RF_B2[RFBand];\n\t\ts32 Capprox = 0;\n\t\tint TComp;\n\n\t\tstate->m_Regs[EP3] &= ~0xE0;   \n\t\tstatus = UpdateReg(state, EP3);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = ThermometerRead(state, &TMValue_Current);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tif (RF3 == 0 || Frequency < RF2)\n\t\t\tCapprox = RF_A1 * ((s32)(Frequency) - (s32)(RF1)) + RF_B1 + Cprog_table;\n\t\telse\n\t\t\tCapprox = RF_A2 * ((s32)(Frequency) - (s32)(RF2)) + RF_B2 + Cprog_table;\n\n\t\tTComp = (int)(dCoverdT) * ((int)(TMValue_Current) - (int)(state->m_TMValue_RFCal))/1000;\n\n\t\tCapprox += TComp;\n\n\t\tif (Capprox < 0)\n\t\t\tCapprox = 0;\n\t\telse if (Capprox > 255)\n\t\t\tCapprox = 255;\n\n\n\t\t \n\t\t \n\t\tstate->m_Regs[EB14] = Capprox;\n\n\t\tstatus = UpdateReg(state, EB14);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t} while (0);\n\treturn status;\n}\n\nstatic int ChannelConfiguration(struct tda_state *state,\n\t\t\t\tu32 Frequency, int Standard)\n{\n\n\ts32 IntermediateFrequency = m_StandardTable[Standard].m_IFFrequency;\n\tint status = 0;\n\n\tu8 BP_Filter = 0;\n\tu8 RF_Band = 0;\n\tu8 GainTaper = 0;\n\tu8 IR_Meas = 0;\n\n\tstate->IF = IntermediateFrequency;\n\t \n\t \n\n\tif (!(SearchMap1(m_BP_Filter_Map, Frequency, &BP_Filter) &&\n\t       SearchMap1(m_GainTaper_Map, Frequency, &GainTaper) &&\n\t       SearchMap1(m_IR_Meas_Map, Frequency, &IR_Meas) &&\n\t       SearchMap4(m_RF_Band_Map, Frequency, &RF_Band))) {\n\n\t\tprintk(KERN_ERR \"tda18271c2dd: %s SearchMap failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tstate->m_Regs[EP3] = (state->m_Regs[EP3] & ~0x1F) | m_StandardTable[Standard].m_EP3_4_0;\n\t\tstate->m_Regs[EP3] &= ~0x04;    \n\n\t\t \n\t\tstate->m_Regs[EP4] = state->m_EP4 | ((Standard > HF_AnalogMax) ? state->m_IFLevelDigital : state->m_IFLevelAnalog);\n\t\t \n\t\tif (Standard <= HF_AnalogMax)\n\t\t\tstate->m_Regs[EP4] = state->m_EP4 | state->m_IFLevelAnalog;\n\t\telse if (Standard <= HF_ATSC)\n\t\t\tstate->m_Regs[EP4] = state->m_EP4 | state->m_IFLevelDVBT;\n\t\telse if (Standard <= HF_DVBC)\n\t\t\tstate->m_Regs[EP4] = state->m_EP4 | state->m_IFLevelDVBC;\n\t\telse\n\t\t\tstate->m_Regs[EP4] = state->m_EP4 | state->m_IFLevelDigital;\n\n\t\tif ((Standard == HF_FM_Radio) && state->m_bFMInput)\n\t\t\tstate->m_Regs[EP4] |= 0x80;\n\n\t\tstate->m_Regs[MPD] &= ~0x80;\n\t\tif (Standard > HF_AnalogMax)\n\t\t\tstate->m_Regs[MPD] |= 0x80;  \n\n\t\tstate->m_Regs[EB22] = m_StandardTable[Standard].m_EB22;\n\n\t\t \n\t\tif (Standard == HF_FM_Radio)\n\t\t\tstate->m_Regs[EB23] |=  0x06;  \n\t\telse\n\t\t\tstate->m_Regs[EB23] &= ~0x06;  \n\n\t\tstatus = UpdateRegs(state, EB22, EB23);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstate->m_Regs[EP1] = (state->m_Regs[EP1] & ~0x07) | 0x40 | BP_Filter;    \n\t\tstate->m_Regs[EP5] = (state->m_Regs[EP5] & ~0x07) | IR_Meas;\n\t\tstate->m_Regs[EP2] = (RF_Band << 5) | GainTaper;\n\n\t\tstate->m_Regs[EB1] = (state->m_Regs[EB1] & ~0x07) |\n\t\t\t(state->m_bMaster ? 0x04 : 0x00);  \n\t\t \n\t\t \n\t\tstatus = UpdateReg(state, EB1);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tif (state->m_bMaster) {\n\t\t\tstatus = CalcMainPLL(state, Frequency + IntermediateFrequency);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = UpdateRegs(state, TM, EP5);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstate->m_Regs[EB4] |= 0x20;     \n\t\t\tstatus = UpdateReg(state, EB4);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tmsleep(1);\n\t\t\tstate->m_Regs[EB4] &= ~0x20;    \n\t\t\tstatus = UpdateReg(state, EB4);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tu8 PostDiv = 0;\n\t\t\tu8 Div;\n\t\t\tstatus = CalcCalPLL(state, Frequency + IntermediateFrequency);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\tSearchMap3(m_Cal_PLL_Map, Frequency + IntermediateFrequency, &PostDiv, &Div);\n\t\t\tstate->m_Regs[MPD] = (state->m_Regs[MPD] & ~0x7F) | (PostDiv & 0x77);\n\t\t\tstatus = UpdateReg(state, MPD);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = UpdateRegs(state, TM, EP5);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\tstate->m_Regs[EB7] |= 0x20;     \n\t\t\tstatus = UpdateReg(state, EB7);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tmsleep(1);\n\t\t\tstate->m_Regs[EB7] &= ~0x20;    \n\t\t\tstatus = UpdateReg(state, EB7);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tmsleep(20);\n\t\tif (Standard != HF_FM_Radio)\n\t\t\tstate->m_Regs[EP3] |= 0x04;     \n\t\tstatus = UpdateReg(state, EP3);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t} while (0);\n\treturn status;\n}\n\nstatic int sleep(struct dvb_frontend *fe)\n{\n\tstruct tda_state *state = fe->tuner_priv;\n\n\tStandBy(state);\n\treturn 0;\n}\n\nstatic int init(struct dvb_frontend *fe)\n{\n\treturn 0;\n}\n\nstatic void release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\n\nstatic int set_params(struct dvb_frontend *fe)\n{\n\tstruct tda_state *state = fe->tuner_priv;\n\tint status = 0;\n\tint Standard;\n\tu32 bw = fe->dtv_property_cache.bandwidth_hz;\n\tu32 delsys  = fe->dtv_property_cache.delivery_system;\n\n\tstate->m_Frequency = fe->dtv_property_cache.frequency;\n\n\tswitch (delsys) {\n\tcase  SYS_DVBT:\n\tcase  SYS_DVBT2:\n\t\tswitch (bw) {\n\t\tcase 6000000:\n\t\t\tStandard = HF_DVBT_6MHZ;\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\tStandard = HF_DVBT_7MHZ;\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\t\tStandard = HF_DVBT_8MHZ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_A:\n\tcase SYS_DVBC_ANNEX_C:\n\t\tif (bw <= 6000000)\n\t\t\tStandard = HF_DVBC_6MHZ;\n\t\telse if (bw <= 7000000)\n\t\t\tStandard = HF_DVBC_7MHZ;\n\t\telse\n\t\t\tStandard = HF_DVBC_8MHZ;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tdo {\n\t\tstatus = RFTrackingFiltersCorrection(state, state->m_Frequency);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = ChannelConfiguration(state, state->m_Frequency,\n\t\t\t\t\t      Standard);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tmsleep(state->m_SettlingTime);   \n\t} while (0);\n\treturn status;\n}\n\n#if 0\nstatic int GetSignalStrength(s32 *pSignalStrength, u32 RFAgc, u32 IFAgc)\n{\n\tif (IFAgc < 500) {\n\t\t \n\t\t*pSignalStrength = IFAgc * 100;\n\t} else {\n\t\t \n\t\t*pSignalStrength = 50000 + (IFAgc - 500) * 30;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct tda_state *state = fe->tuner_priv;\n\n\t*frequency = state->IF;\n\treturn 0;\n}\n\nstatic int get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\t \n\t \n\treturn 0;\n}\n\n\nstatic const struct dvb_tuner_ops tuner_ops = {\n\t.info = {\n\t\t.name = \"NXP TDA18271C2D\",\n\t\t.frequency_min_hz  =  47125 * kHz,\n\t\t.frequency_max_hz  =    865 * MHz,\n\t\t.frequency_step_hz =  62500\n\t},\n\t.init              = init,\n\t.sleep             = sleep,\n\t.set_params        = set_params,\n\t.release           = release,\n\t.get_if_frequency  = get_if_frequency,\n\t.get_bandwidth     = get_bandwidth,\n};\n\nstruct dvb_frontend *tda18271c2dd_attach(struct dvb_frontend *fe,\n\t\t\t\t\t struct i2c_adapter *i2c, u8 adr)\n{\n\tstruct tda_state *state;\n\n\tstate = kzalloc(sizeof(struct tda_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tfe->tuner_priv = state;\n\tstate->adr = adr;\n\tstate->i2c = i2c;\n\tmemcpy(&fe->ops.tuner_ops, &tuner_ops, sizeof(struct dvb_tuner_ops));\n\treset(state);\n\tInitCal(state);\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(tda18271c2dd_attach);\n\nMODULE_DESCRIPTION(\"TDA18271C2 driver\");\nMODULE_AUTHOR(\"DD\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}