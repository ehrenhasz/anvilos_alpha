{
  "module_name": "helene.c",
  "hash_id": "781e3939ab14f415d3435fa66904d6e3e765267ce0605aa61e75e2395617e135",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/helene.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/dvb/frontend.h>\n#include <linux/types.h>\n#include \"helene.h\"\n#include <media/dvb_frontend.h>\n\n#define MAX_WRITE_REGSIZE 20\n\nenum helene_state {\n\tSTATE_UNKNOWN,\n\tSTATE_SLEEP,\n\tSTATE_ACTIVE\n};\n\nstruct helene_priv {\n\tu32\t\t\tfrequency;\n\tu8\t\t\ti2c_address;\n\tstruct i2c_adapter\t*i2c;\n\tenum helene_state\tstate;\n\tvoid\t\t\t*set_tuner_data;\n\tint\t\t\t(*set_tuner)(void *, int);\n\tenum helene_xtal xtal;\n};\n\n#define TERR_INTERNAL_LOOPFILTER_AVAILABLE(tv_system) \\\n\t(((tv_system) != SONY_HELENE_DTV_DVBC_6) && \\\n\t ((tv_system) != SONY_HELENE_DTV_DVBC_8)\\\n\t && ((tv_system) != SONY_HELENE_DTV_DVBC2_6) && \\\n\t ((tv_system) != SONY_HELENE_DTV_DVBC2_8))\n\n#define HELENE_AUTO\t\t0xff\n#define HELENE_OFFSET(ofs)\t((u8)(ofs) & 0x1F)\n#define HELENE_BW_6\t\t0x00\n#define HELENE_BW_7\t\t0x01\n#define HELENE_BW_8\t\t0x02\n#define HELENE_BW_1_7\t\t0x03\n\nenum helene_tv_system_t {\n\tSONY_HELENE_TV_SYSTEM_UNKNOWN,\n\t \n\tSONY_HELENE_ATV_MN_EIAJ,\n\t \n\tSONY_HELENE_ATV_MN_SAP,\n\t \n\tSONY_HELENE_ATV_MN_A2,\n\t \n\tSONY_HELENE_ATV_BG,\n\t \n\tSONY_HELENE_ATV_I,\n\t \n\tSONY_HELENE_ATV_DK,\n\t \n\tSONY_HELENE_ATV_L,\n\t \n\tSONY_HELENE_ATV_L_DASH,\n\t \n\t \n\tSONY_HELENE_DTV_8VSB,\n\t \n\tSONY_HELENE_DTV_QAM,\n\t \n\tSONY_HELENE_DTV_ISDBT_6,\n\t \n\tSONY_HELENE_DTV_ISDBT_7,\n\t \n\tSONY_HELENE_DTV_ISDBT_8,\n\t \n\tSONY_HELENE_DTV_DVBT_5,\n\t \n\tSONY_HELENE_DTV_DVBT_6,\n\t \n\tSONY_HELENE_DTV_DVBT_7,\n\t \n\tSONY_HELENE_DTV_DVBT_8,\n\t \n\tSONY_HELENE_DTV_DVBT2_1_7,\n\t \n\tSONY_HELENE_DTV_DVBT2_5,\n\t \n\tSONY_HELENE_DTV_DVBT2_6,\n\t \n\tSONY_HELENE_DTV_DVBT2_7,\n\t \n\tSONY_HELENE_DTV_DVBT2_8,\n\t \n\tSONY_HELENE_DTV_DVBC_6,\n\t \n\tSONY_HELENE_DTV_DVBC_8,\n\t \n\tSONY_HELENE_DTV_DVBC2_6,\n\t \n\tSONY_HELENE_DTV_DVBC2_8,\n\t \n\tSONY_HELENE_DTV_DTMB,\n\t \n\t \n\tSONY_HELENE_STV_ISDBS,\n\t \n\tSONY_HELENE_STV_DVBS,\n\t \n\tSONY_HELENE_STV_DVBS2,\n\t \n\n\tSONY_HELENE_ATV_MIN = SONY_HELENE_ATV_MN_EIAJ,\n\t \n\tSONY_HELENE_ATV_MAX = SONY_HELENE_ATV_L_DASH,\n\t \n\tSONY_HELENE_DTV_MIN = SONY_HELENE_DTV_8VSB,\n\t \n\tSONY_HELENE_DTV_MAX = SONY_HELENE_DTV_DTMB,\n\t \n\tSONY_HELENE_TERR_TV_SYSTEM_NUM,\n\t \n\tSONY_HELENE_STV_MIN = SONY_HELENE_STV_ISDBS,\n\t \n\tSONY_HELENE_STV_MAX = SONY_HELENE_STV_DVBS2\n\t \n};\n\nstruct helene_terr_adjust_param_t {\n\t \n\tuint8_t RF_GAIN;\n\t \n\tuint8_t IF_BPF_GC;\n\t \n\tuint8_t RFOVLD_DET_LV1_VL;\n\t \n\tuint8_t RFOVLD_DET_LV1_VH;\n\t \n\tuint8_t RFOVLD_DET_LV1_U;\n\t \n\tuint8_t IFOVLD_DET_LV_VL;\n\t \n\tuint8_t IFOVLD_DET_LV_VH;\n\t \n\tuint8_t IFOVLD_DET_LV_U;\n\t \n\tuint8_t IF_BPF_F0;\n\t \n\tuint8_t BW;\n\t \n\tuint8_t FIF_OFFSET;\n\t \n\tuint8_t BW_OFFSET;\n\t \n\tuint8_t IS_LOWERLOCAL;\n};\n\nstatic const struct helene_terr_adjust_param_t\nterr_params[SONY_HELENE_TERR_TV_SYSTEM_NUM] = {\n\t \n\t{HELENE_AUTO, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\tHELENE_BW_6, HELENE_OFFSET(0),  HELENE_OFFSET(0),  0x00},\n\t \n\t \n\t{HELENE_AUTO, 0x05, 0x03, 0x06, 0x03, 0x01, 0x01, 0x01, 0x00,\n\t\tHELENE_BW_6,  HELENE_OFFSET(0),  HELENE_OFFSET(1),  0x00},\n\t \n\t{HELENE_AUTO, 0x05, 0x03, 0x06, 0x03, 0x01, 0x01, 0x01, 0x00,\n\t\tHELENE_BW_6,  HELENE_OFFSET(0),  HELENE_OFFSET(1),  0x00},\n\t{HELENE_AUTO, 0x05, 0x03, 0x06, 0x03, 0x01, 0x01, 0x01, 0x00,\n\t\tHELENE_BW_6,  HELENE_OFFSET(3),  HELENE_OFFSET(1),  0x00},\n\t \n\t{HELENE_AUTO, 0x05, 0x03, 0x06, 0x03, 0x01, 0x01, 0x01, 0x00,\n\t\tHELENE_BW_7,  HELENE_OFFSET(11), HELENE_OFFSET(5),  0x00},\n\t \n\t{HELENE_AUTO, 0x05, 0x03, 0x06, 0x03, 0x01, 0x01, 0x01, 0x00,\n\t\tHELENE_BW_8,  HELENE_OFFSET(2),  HELENE_OFFSET(-3), 0x00},\n\t \n\t{HELENE_AUTO, 0x05, 0x03, 0x06, 0x03, 0x01, 0x01, 0x01, 0x00,\n\t\tHELENE_BW_8,  HELENE_OFFSET(2),  HELENE_OFFSET(-3), 0x00},\n\t \n\t{HELENE_AUTO, 0x03, 0x04, 0x0A, 0x04, 0x04, 0x04, 0x04, 0x00,\n\t\tHELENE_BW_8,  HELENE_OFFSET(2),  HELENE_OFFSET(-3), 0x00},\n\t \n\t{HELENE_AUTO, 0x03, 0x04, 0x0A, 0x04, 0x04, 0x04, 0x04, 0x00,\n\t\tHELENE_BW_8,  HELENE_OFFSET(-1), HELENE_OFFSET(4),  0x00},\n\t \n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x00,\n\t\tHELENE_BW_6,  HELENE_OFFSET(-6), HELENE_OFFSET(-3), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_6,  HELENE_OFFSET(-6), HELENE_OFFSET(-3), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_6,  HELENE_OFFSET(-9), HELENE_OFFSET(-5), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_7,  HELENE_OFFSET(-7), HELENE_OFFSET(-6), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_8,  HELENE_OFFSET(-5), HELENE_OFFSET(-7), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_6,  HELENE_OFFSET(-8), HELENE_OFFSET(-3), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_6,  HELENE_OFFSET(-8), HELENE_OFFSET(-3), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_7,  HELENE_OFFSET(-6), HELENE_OFFSET(-5), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_8,  HELENE_OFFSET(-4), HELENE_OFFSET(-6), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_1_7, HELENE_OFFSET(-10), HELENE_OFFSET(-10), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_6,  HELENE_OFFSET(-8), HELENE_OFFSET(-3), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_6,  HELENE_OFFSET(-8), HELENE_OFFSET(-3), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_7,  HELENE_OFFSET(-6), HELENE_OFFSET(-5), 0x00},\n\t \n\t{HELENE_AUTO, 0x09, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_8,  HELENE_OFFSET(-4), HELENE_OFFSET(-6), 0x00},\n\t \n\t{HELENE_AUTO, 0x05, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x00,\n\t\tHELENE_BW_6,  HELENE_OFFSET(-6), HELENE_OFFSET(-4), 0x00},\n\t \n\t{HELENE_AUTO, 0x05, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x00,\n\t\tHELENE_BW_8,  HELENE_OFFSET(-2), HELENE_OFFSET(-3), 0x00},\n\t \n\t{HELENE_AUTO, 0x03, 0x09, 0x09, 0x09, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_6,  HELENE_OFFSET(-6), HELENE_OFFSET(-2), 0x00},\n\t \n\t{HELENE_AUTO, 0x03, 0x09, 0x09, 0x09, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_8,  HELENE_OFFSET(-2), HELENE_OFFSET(0),  0x00},\n\t \n\t{HELENE_AUTO, 0x04, 0x0B, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x00,\n\t\tHELENE_BW_8,  HELENE_OFFSET(2),  HELENE_OFFSET(1),  0x00}\n\t \n};\n\nstatic void helene_i2c_debug(struct helene_priv *priv,\n\t\tu8 reg, u8 write, const u8 *data, u32 len)\n{\n\tdev_dbg(&priv->i2c->dev, \"helene: I2C %s reg 0x%02x size %d\\n\",\n\t\t\t(write == 0 ? \"read\" : \"write\"), reg, len);\n\tprint_hex_dump_bytes(\"helene: I2C data: \",\n\t\t\tDUMP_PREFIX_OFFSET, data, len);\n}\n\nstatic int helene_write_regs(struct helene_priv *priv,\n\t\tu8 reg, const u8 *data, u32 len)\n{\n\tint ret;\n\tu8 buf[MAX_WRITE_REGSIZE + 1];\n\tstruct i2c_msg msg[1] = {\n\t\t{\n\t\t\t.addr = priv->i2c_address,\n\t\t\t.flags = 0,\n\t\t\t.len = len + 1,\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\n\tif (len + 1 > sizeof(buf)) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t\t\"wr reg=%04x: len=%d vs %zu is too big!\\n\",\n\t\t\t\treg, len + 1, sizeof(buf));\n\t\treturn -E2BIG;\n\t}\n\n\thelene_i2c_debug(priv, reg, 1, data, len);\n\tbuf[0] = reg;\n\tmemcpy(&buf[1], data, len);\n\tret = i2c_transfer(priv->i2c, msg, 1);\n\tif (ret >= 0 && ret != 1)\n\t\tret = -EREMOTEIO;\n\tif (ret < 0) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t\t\"%s: i2c wr failed=%d reg=%02x len=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret, reg, len);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int helene_write_reg(struct helene_priv *priv, u8 reg, u8 val)\n{\n\tu8 tmp = val;  \n\n\treturn helene_write_regs(priv, reg, &tmp, 1);\n}\n\nstatic int helene_read_regs(struct helene_priv *priv,\n\t\tu8 reg, u8 *val, u32 len)\n{\n\tint ret;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = priv->i2c_address,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &reg,\n\t\t}, {\n\t\t\t.addr = priv->i2c_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = val,\n\t\t}\n\t};\n\n\tret = i2c_transfer(priv->i2c, &msg[0], 1);\n\tif (ret >= 0 && ret != 1)\n\t\tret = -EREMOTEIO;\n\tif (ret < 0) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t\t\"%s: I2C rw failed=%d addr=%02x reg=%02x\\n\",\n\t\t\t\tKBUILD_MODNAME, ret, priv->i2c_address, reg);\n\t\treturn ret;\n\t}\n\tret = i2c_transfer(priv->i2c, &msg[1], 1);\n\tif (ret >= 0 && ret != 1)\n\t\tret = -EREMOTEIO;\n\tif (ret < 0) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t\t\"%s: i2c rd failed=%d addr=%02x reg=%02x\\n\",\n\t\t\t\tKBUILD_MODNAME, ret, priv->i2c_address, reg);\n\t\treturn ret;\n\t}\n\thelene_i2c_debug(priv, reg, 0, val, len);\n\treturn 0;\n}\n\nstatic int helene_read_reg(struct helene_priv *priv, u8 reg, u8 *val)\n{\n\treturn helene_read_regs(priv, reg, val, 1);\n}\n\nstatic int helene_set_reg_bits(struct helene_priv *priv,\n\t\tu8 reg, u8 data, u8 mask)\n{\n\tint res;\n\tu8 rdata;\n\n\tif (mask != 0xff) {\n\t\tres = helene_read_reg(priv, reg, &rdata);\n\t\tif (res != 0)\n\t\t\treturn res;\n\t\tdata = ((data & mask) | (rdata & (mask ^ 0xFF)));\n\t}\n\treturn helene_write_reg(priv, reg, data);\n}\n\nstatic int helene_enter_power_save(struct helene_priv *priv)\n{\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state == STATE_SLEEP)\n\t\treturn 0;\n\n\t \n\thelene_write_reg(priv, 0x88, 0x0);\n\n\t \n\thelene_write_reg(priv, 0x87, 0xC0);\n\n\tpriv->state = STATE_SLEEP;\n\treturn 0;\n}\n\nstatic int helene_leave_power_save(struct helene_priv *priv)\n{\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state == STATE_ACTIVE)\n\t\treturn 0;\n\n\t \n\thelene_write_reg(priv, 0x87, 0xC4);\n\n\t \n\thelene_write_reg(priv, 0x88, 0x40);\n\n\tpriv->state = STATE_ACTIVE;\n\treturn 0;\n}\n\nstatic int helene_init(struct dvb_frontend *fe)\n{\n\tstruct helene_priv *priv = fe->tuner_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\treturn helene_leave_power_save(priv);\n}\n\nstatic void helene_release(struct dvb_frontend *fe)\n{\n\tstruct helene_priv *priv = fe->tuner_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int helene_sleep(struct dvb_frontend *fe)\n{\n\tstruct helene_priv *priv = fe->tuner_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\thelene_enter_power_save(priv);\n\treturn 0;\n}\n\nstatic enum helene_tv_system_t helene_get_tv_system(struct dvb_frontend *fe)\n{\n\tenum helene_tv_system_t system = SONY_HELENE_TV_SYSTEM_UNKNOWN;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct helene_priv *priv = fe->tuner_priv;\n\n\tif (p->delivery_system == SYS_DVBT) {\n\t\tif (p->bandwidth_hz <= 5000000)\n\t\t\tsystem = SONY_HELENE_DTV_DVBT_5;\n\t\telse if (p->bandwidth_hz <= 6000000)\n\t\t\tsystem = SONY_HELENE_DTV_DVBT_6;\n\t\telse if (p->bandwidth_hz <= 7000000)\n\t\t\tsystem = SONY_HELENE_DTV_DVBT_7;\n\t\telse if (p->bandwidth_hz <= 8000000)\n\t\t\tsystem = SONY_HELENE_DTV_DVBT_8;\n\t\telse {\n\t\t\tsystem = SONY_HELENE_DTV_DVBT_8;\n\t\t\tp->bandwidth_hz = 8000000;\n\t\t}\n\t} else if (p->delivery_system == SYS_DVBT2) {\n\t\tif (p->bandwidth_hz <= 5000000)\n\t\t\tsystem = SONY_HELENE_DTV_DVBT2_5;\n\t\telse if (p->bandwidth_hz <= 6000000)\n\t\t\tsystem = SONY_HELENE_DTV_DVBT2_6;\n\t\telse if (p->bandwidth_hz <= 7000000)\n\t\t\tsystem = SONY_HELENE_DTV_DVBT2_7;\n\t\telse if (p->bandwidth_hz <= 8000000)\n\t\t\tsystem = SONY_HELENE_DTV_DVBT2_8;\n\t\telse {\n\t\t\tsystem = SONY_HELENE_DTV_DVBT2_8;\n\t\t\tp->bandwidth_hz = 8000000;\n\t\t}\n\t} else if (p->delivery_system == SYS_DVBS) {\n\t\tsystem = SONY_HELENE_STV_DVBS;\n\t} else if (p->delivery_system == SYS_DVBS2) {\n\t\tsystem = SONY_HELENE_STV_DVBS2;\n\t} else if (p->delivery_system == SYS_ISDBS) {\n\t\tsystem = SONY_HELENE_STV_ISDBS;\n\t} else if (p->delivery_system == SYS_ISDBT) {\n\t\tif (p->bandwidth_hz <= 6000000)\n\t\t\tsystem = SONY_HELENE_DTV_ISDBT_6;\n\t\telse if (p->bandwidth_hz <= 7000000)\n\t\t\tsystem = SONY_HELENE_DTV_ISDBT_7;\n\t\telse if (p->bandwidth_hz <= 8000000)\n\t\t\tsystem = SONY_HELENE_DTV_ISDBT_8;\n\t\telse {\n\t\t\tsystem = SONY_HELENE_DTV_ISDBT_8;\n\t\t\tp->bandwidth_hz = 8000000;\n\t\t}\n\t} else if (p->delivery_system == SYS_DVBC_ANNEX_A) {\n\t\tif (p->bandwidth_hz <= 6000000)\n\t\t\tsystem = SONY_HELENE_DTV_DVBC_6;\n\t\telse if (p->bandwidth_hz <= 8000000)\n\t\t\tsystem = SONY_HELENE_DTV_DVBC_8;\n\t}\n\tdev_dbg(&priv->i2c->dev,\n\t\t\t\"%s(): HELENE DTV system %d (delsys %d, bandwidth %d)\\n\",\n\t\t\t__func__, (int)system, p->delivery_system,\n\t\t\tp->bandwidth_hz);\n\treturn system;\n}\n\nstatic int helene_set_params_s(struct dvb_frontend *fe)\n{\n\tu8 data[MAX_WRITE_REGSIZE];\n\tu32 frequency;\n\tenum helene_tv_system_t tv_system;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct helene_priv *priv = fe->tuner_priv;\n\tint frequencykHz = p->frequency;\n\tuint32_t frequency4kHz = 0;\n\tu32 symbol_rate = p->symbol_rate/1000;\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): tune frequency %dkHz sr=%uKsps\\n\",\n\t\t\t__func__, frequencykHz, symbol_rate);\n\ttv_system = helene_get_tv_system(fe);\n\n\tif (tv_system == SONY_HELENE_TV_SYSTEM_UNKNOWN) {\n\t\tdev_err(&priv->i2c->dev, \"%s(): unknown DTV system\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (priv->set_tuner)\n\t\tpriv->set_tuner(priv->set_tuner_data, 0);\n\tfrequency = roundup(p->frequency / 1000, 1);\n\n\t \n\thelene_write_reg(priv, 0x15, 0x02);\n\n\t \n\thelene_write_reg(priv, 0x43, 0x06);\n\n\t \n\tdata[0] = 0x00;\n\tdata[1] = 0x00;\n\thelene_write_regs(priv, 0x6A, data, 2);\n\thelene_write_reg(priv, 0x75, 0x99);\n\thelene_write_reg(priv, 0x9D, 0x00);\n\n\t \n\thelene_write_reg(priv, 0x61, 0x07);\n\n\t \n\thelene_write_reg(priv, 0x01, 0x01);\n\n\t \n\tdata[0] = 0xC4;\n\tdata[1] = 0x40;\n\n\tswitch (priv->xtal) {\n\tcase SONY_HELENE_XTAL_16000:\n\t\tdata[2] = 0x02;\n\t\tbreak;\n\tcase SONY_HELENE_XTAL_20500:\n\t\tdata[2] = 0x02;\n\t\tbreak;\n\tcase SONY_HELENE_XTAL_24000:\n\t\tdata[2] = 0x03;\n\t\tbreak;\n\tcase SONY_HELENE_XTAL_41000:\n\t\tdata[2] = 0x05;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&priv->i2c->dev, \"%s(): unknown xtal %d\\n\",\n\t\t\t\t__func__, priv->xtal);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdata[3] = 0x80;\n\n\t \n\tif (priv->xtal == SONY_HELENE_XTAL_20500)\n\t\tdata[4] = 0x58;\n\telse\n\t\tdata[4] = 0x70;\n\n\tdata[5] = 0x1E;\n\tdata[6] = 0x02;\n\tdata[7] = 0x24;\n\n\t \n\tdata[8] = 0x0F;\n\tdata[8] |= 0xE0;  \n\tdata[9]  = 0x02;\n\tdata[10] = 0x1E;\n\n\t \n\tswitch (tv_system) {\n\tcase SONY_HELENE_STV_ISDBS:\n\t\tdata[11] = 0x22;  \n\t\tbreak;\n\tcase SONY_HELENE_STV_DVBS:\n\t\tif (symbol_rate <= 4000)\n\t\t\tdata[11] = 0x05;\n\t\telse if (symbol_rate <= 10000)\n\t\t\tdata[11] = (uint8_t)((symbol_rate * 47\n\t\t\t\t\t\t+ (40000-1)) / 40000);\n\t\telse\n\t\t\tdata[11] = (uint8_t)((symbol_rate * 27\n\t\t\t\t\t\t+ (40000-1)) / 40000 + 5);\n\n\t\tif (data[11] > 36)\n\t\t\tdata[11] = 36;  \n\t\tbreak;\n\tcase SONY_HELENE_STV_DVBS2:\n\t\tif (symbol_rate <= 4000)\n\t\t\tdata[11] = 0x05;\n\t\telse if (symbol_rate <= 10000)\n\t\t\tdata[11] = (uint8_t)((symbol_rate * 11\n\t\t\t\t\t\t+ (10000-1)) / 10000);\n\t\telse\n\t\t\tdata[11] = (uint8_t)((symbol_rate * 3\n\t\t\t\t\t\t+ (5000-1)) / 5000 + 5);\n\n\t\tif (data[11] > 36)\n\t\t\tdata[11] = 36;  \n\t\tbreak;\n\tdefault:\n\t\tdev_err(&priv->i2c->dev, \"%s(): unknown standard %d\\n\",\n\t\t\t\t__func__, tv_system);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfrequency4kHz = (frequencykHz + 2) / 4;\n\tdata[12] = (uint8_t)(frequency4kHz & 0xFF);          \n\tdata[13] = (uint8_t)((frequency4kHz >> 8) & 0xFF);   \n\t \n\tdata[14] = (uint8_t)((frequency4kHz >> 16) & 0x0F);\n\n\t \n\tdata[15] = 0xFF;\n\n\t \n\tdata[16] = 0x00;\n\n\t \n\tdata[17] = 0x01;\n\n\thelene_write_regs(priv, 0x04, data, 18);\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): tune done\\n\",\n\t\t\t__func__);\n\n\tpriv->frequency = frequency;\n\treturn 0;\n}\n\nstatic int helene_set_params_t(struct dvb_frontend *fe)\n{\n\tu8 data[MAX_WRITE_REGSIZE];\n\tu32 frequency;\n\tenum helene_tv_system_t tv_system;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct helene_priv *priv = fe->tuner_priv;\n\tint frequencykHz = p->frequency / 1000;\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): tune frequency %dkHz\\n\",\n\t\t\t__func__, frequencykHz);\n\ttv_system = helene_get_tv_system(fe);\n\n\tif (tv_system == SONY_HELENE_TV_SYSTEM_UNKNOWN) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): unknown DTV system\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tif (priv->set_tuner)\n\t\tpriv->set_tuner(priv->set_tuner_data, 1);\n\tfrequency = roundup(p->frequency / 1000, 25);\n\n\t \n\thelene_write_reg(priv, 0x01, 0x00);\n\n\t \n\thelene_write_reg(priv, 0x74, 0x02);\n\n\tif (priv->state == STATE_SLEEP)\n\t\thelene_leave_power_save(priv);\n\n\t \n\tif ((tv_system == SONY_HELENE_DTV_DVBC_6) ||\n\t\t\t(tv_system == SONY_HELENE_DTV_DVBC_8)) {\n\t\tdata[0] = 0x16;\n\t\tdata[1] = 0x26;\n\t} else {\n\t\tdata[0] = 0x10;\n\t\tdata[1] = 0x20;\n\t}\n\thelene_write_regs(priv, 0x91, data, 2);\n\n\t \n\tif (TERR_INTERNAL_LOOPFILTER_AVAILABLE(tv_system))\n\t\tdata[0] = 0x90;\n\telse\n\t\tdata[0] = 0x00;\n\n\t \n\tdata[1] = (uint8_t)(terr_params[tv_system].IS_LOWERLOCAL & 0x01);\n\thelene_write_regs(priv, 0x9C, data, 2);\n\n\t \n\tdata[0] = 0xEE;\n\tdata[1] = 0x02;\n\tdata[2] = 0x1E;\n\tdata[3] = 0x67;  \n\n\t \n\tif ((tv_system == SONY_HELENE_DTV_DVBC_6) ||\n\t\t\t(tv_system == SONY_HELENE_DTV_DVBC_8))\n\t\tdata[4] = 0x18;\n\telse\n\t\tdata[4] = 0x03;\n\n\t \n\tif (TERR_INTERNAL_LOOPFILTER_AVAILABLE(tv_system)) {\n\t\tdata[5] = 0x38;\n\t\tdata[6] = 0x1E;\n\t\tdata[7] = 0x02;\n\t\tdata[8] = 0x24;\n\t} else if ((tv_system == SONY_HELENE_DTV_DVBC_6) ||\n\t\t\t(tv_system == SONY_HELENE_DTV_DVBC_8)) {\n\t\tdata[5] = 0x1C;\n\t\tdata[6] = 0x78;\n\t\tdata[7] = 0x08;\n\t\tdata[8] = 0x1C;\n\t} else {\n\t\tdata[5] = 0xB4;\n\t\tdata[6] = 0x78;\n\t\tdata[7] = 0x08;\n\t\tdata[8] = 0x30;\n\t}\n\thelene_write_regs(priv, 0x5E, data, 9);\n\n\t \n\thelene_set_reg_bits(priv, 0x67, 0x0, 0x02);\n\n\t \n\tdata[0] = 0x00;  \n\n\t \n\tif (terr_params[tv_system].RF_GAIN == HELENE_AUTO)\n\t\tdata[1] = 0x80;  \n\telse\n\t\tdata[1] = (uint8_t)((terr_params[tv_system].RF_GAIN\n\t\t\t\t\t<< 4) & 0x70);\n\n\t \n\tdata[1] |= (uint8_t)(terr_params[tv_system].IF_BPF_GC & 0x0F);\n\n\t \n\tdata[2] = 0x00;\n\tif (frequencykHz <= 172000) {\n\t\tdata[3] = (uint8_t)(terr_params[tv_system].RFOVLD_DET_LV1_VL\n\t\t\t\t& 0x0F);\n\t\tdata[4] = (uint8_t)(terr_params[tv_system].IFOVLD_DET_LV_VL\n\t\t\t\t& 0x07);\n\t} else if (frequencykHz <= 464000) {\n\t\tdata[3] = (uint8_t)(terr_params[tv_system].RFOVLD_DET_LV1_VH\n\t\t\t\t& 0x0F);\n\t\tdata[4] = (uint8_t)(terr_params[tv_system].IFOVLD_DET_LV_VH\n\t\t\t\t& 0x07);\n\t} else {\n\t\tdata[3] = (uint8_t)(terr_params[tv_system].RFOVLD_DET_LV1_U\n\t\t\t\t& 0x0F);\n\t\tdata[4] = (uint8_t)(terr_params[tv_system].IFOVLD_DET_LV_U\n\t\t\t\t& 0x07);\n\t}\n\tdata[4] |= 0x20;\n\n\t \n\n\t \n\tdata[5] = (uint8_t)((terr_params[tv_system].IF_BPF_F0 << 4) & 0x30);\n\n\t \n\tdata[5] |= (uint8_t)(terr_params[tv_system].BW & 0x03);\n\n\t \n\tdata[6] = (uint8_t)(terr_params[tv_system].FIF_OFFSET & 0x1F);\n\n\t \n\tdata[7] = (uint8_t)(terr_params[tv_system].BW_OFFSET & 0x1F);\n\n\t \n\tdata[8]  = (uint8_t)(frequencykHz & 0xFF);          \n\tdata[9]  = (uint8_t)((frequencykHz >> 8) & 0xFF);   \n\tdata[10] = (uint8_t)((frequencykHz >> 16)\n\t\t\t& 0x0F);  \n\n\t \n\tdata[11] = 0xFF;\n\n\t \n\tdata[12] = 0x01;\n\n\tif ((tv_system == SONY_HELENE_DTV_DVBC_6) ||\n\t\t\t(tv_system == SONY_HELENE_DTV_DVBC_8)) {\n\t\tdata[13] = 0xD9;\n\t\tdata[14] = 0x0F;\n\t\tdata[15] = 0x24;\n\t\tdata[16] = 0x87;\n\t} else {\n\t\tdata[13] = 0x99;\n\t\tdata[14] = 0x00;\n\t\tdata[15] = 0x24;\n\t\tdata[16] = 0x87;\n\t}\n\n\thelene_write_regs(priv, 0x68, data, 17);\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): tune done\\n\",\n\t\t\t__func__);\n\n\tpriv->frequency = frequency;\n\treturn 0;\n}\n\nstatic int helene_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tif (p->delivery_system == SYS_DVBT ||\n\t    p->delivery_system == SYS_DVBT2 ||\n\t    p->delivery_system == SYS_ISDBT ||\n\t    p->delivery_system == SYS_DVBC_ANNEX_A)\n\t\treturn helene_set_params_t(fe);\n\n\treturn helene_set_params_s(fe);\n}\n\nstatic int helene_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct helene_priv *priv = fe->tuner_priv;\n\n\t*frequency = priv->frequency * 1000;\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops helene_tuner_ops_t = {\n\t.info = {\n\t\t.name = \"Sony HELENE Ter tuner\",\n\t\t.frequency_min_hz  =    1 * MHz,\n\t\t.frequency_max_hz  = 1200 * MHz,\n\t\t.frequency_step_hz =   25 * kHz,\n\t},\n\t.init = helene_init,\n\t.release = helene_release,\n\t.sleep = helene_sleep,\n\t.set_params = helene_set_params_t,\n\t.get_frequency = helene_get_frequency,\n};\n\nstatic const struct dvb_tuner_ops helene_tuner_ops_s = {\n\t.info = {\n\t\t.name = \"Sony HELENE Sat tuner\",\n\t\t.frequency_min_hz  =  500 * MHz,\n\t\t.frequency_max_hz  = 2500 * MHz,\n\t\t.frequency_step_hz =    1 * MHz,\n\t},\n\t.init = helene_init,\n\t.release = helene_release,\n\t.sleep = helene_sleep,\n\t.set_params = helene_set_params_s,\n\t.get_frequency = helene_get_frequency,\n};\n\nstatic const struct dvb_tuner_ops helene_tuner_ops = {\n\t.info = {\n\t\t.name = \"Sony HELENE Sat/Ter tuner\",\n\t\t.frequency_min_hz  =    1 * MHz,\n\t\t.frequency_max_hz  = 2500 * MHz,\n\t\t.frequency_step_hz =   25 * kHz,\n\t},\n\t.init = helene_init,\n\t.release = helene_release,\n\t.sleep = helene_sleep,\n\t.set_params = helene_set_params,\n\t.get_frequency = helene_get_frequency,\n};\n\n \nstatic int helene_x_pon(struct helene_priv *priv)\n{\n\t \n\t \n\tu8 dataT[] = { 0x06, 0x00, 0x02, 0x00 };\n\t \n\tu8 dataS[] = { 0x05, 0x06 };\n\tu8 cdata[] = {0x7A, 0x01};\n\tu8 data[20];\n\tu8 rdata[2];\n\n\t \n\thelene_write_reg(priv, 0x01, 0x00);\n\n\thelene_write_reg(priv, 0x67, dataT[3]);\n\thelene_write_reg(priv, 0x43, dataS[1]);\n\thelene_write_regs(priv, 0x5E, dataT, 3);\n\thelene_write_reg(priv, 0x0C, dataS[0]);\n\n\t \n\thelene_write_regs(priv, 0x99, cdata, sizeof(cdata));\n\n\t \n\tif (priv->xtal == SONY_HELENE_XTAL_16000)\n\t\tdata[0] = 0x10;  \n\telse\n\t\tdata[0] = 0x18;  \n\tdata[1] = (uint8_t)(0x80 | (0x04 & 0x1F));  \n\tdata[2] = (uint8_t)(0x80 | (0x26 & 0x7F));  \n\tdata[3] = 0x80;  \n\tdata[4] = 0x00;  \n\tdata[5] = 0x00;  \n\tdata[6] = 0xC4;  \n\tdata[7] = 0x40;  \n\tdata[8] = 0x10;  \n\n\t \n\tdata[9] = 0x00;\n\tdata[10] = 0x45;\n\tdata[11] = 0x75;\n\n\tdata[12] = 0x07;  \n\n\t \n\tdata[13] = 0x1C;\n\tdata[14] = 0x3F;\n\tdata[15] = 0x02;\n\tdata[16] = 0x10;\n\tdata[17] = 0x20;\n\tdata[18] = 0x0A;\n\tdata[19] = 0x00;\n\n\thelene_write_regs(priv, 0x81, data, sizeof(data));\n\n\t \n\thelene_write_reg(priv, 0x9B, 0x00);\n\n\tmsleep(20);\n\n\t \n\thelene_read_regs(priv, 0x1A, rdata, sizeof(rdata));\n\n\tif (rdata[0] != 0x00) {\n\t\tdev_err(&priv->i2c->dev,\n\t\t\t\t\"HELENE tuner CPU error 0x%x\\n\", rdata[0]);\n\t\treturn -EIO;\n\t}\n\n\t \n\tcdata[0] = 0x90;\n\tcdata[1] = 0x06;\n\thelene_write_regs(priv, 0x17, cdata, sizeof(cdata));\n\tmsleep(20);\n\thelene_read_reg(priv, 0x19, data);\n\thelene_write_reg(priv, 0x95, (uint8_t)((data[0] >> 4) & 0x0F));\n\n\t \n\thelene_write_reg(priv, 0x74, 0x02);\n\n\t \n\thelene_write_reg(priv, 0x88, 0x00);\n\n\t \n\thelene_write_reg(priv, 0x87, 0xC0);\n\n\t \n\thelene_write_reg(priv, 0x80, 0x01);\n\n\t \n\tcdata[0] = 0x07;\n\tcdata[1] = 0x00;\n\thelene_write_regs(priv, 0x41, cdata, sizeof(cdata));\n\n\tdev_info(&priv->i2c->dev,\n\t\t\t\"HELENE tuner x_pon done\\n\");\n\n\treturn 0;\n}\n\nstruct dvb_frontend *helene_attach_s(struct dvb_frontend *fe,\n\t\tconst struct helene_config *config,\n\t\tstruct i2c_adapter *i2c)\n{\n\tstruct helene_priv *priv = NULL;\n\n\tpriv = kzalloc(sizeof(struct helene_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\tpriv->i2c_address = (config->i2c_address >> 1);\n\tpriv->i2c = i2c;\n\tpriv->set_tuner_data = config->set_tuner_priv;\n\tpriv->set_tuner = config->set_tuner_callback;\n\tpriv->xtal = config->xtal;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tif (helene_x_pon(priv) != 0) {\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tmemcpy(&fe->ops.tuner_ops, &helene_tuner_ops_s,\n\t\t\tsizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = priv;\n\tdev_info(&priv->i2c->dev,\n\t\t\t\"Sony HELENE Sat attached on addr=%x at I2C adapter %p\\n\",\n\t\t\tpriv->i2c_address, priv->i2c);\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(helene_attach_s);\n\nstruct dvb_frontend *helene_attach(struct dvb_frontend *fe,\n\t\tconst struct helene_config *config,\n\t\tstruct i2c_adapter *i2c)\n{\n\tstruct helene_priv *priv = NULL;\n\n\tpriv = kzalloc(sizeof(struct helene_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\tpriv->i2c_address = (config->i2c_address >> 1);\n\tpriv->i2c = i2c;\n\tpriv->set_tuner_data = config->set_tuner_priv;\n\tpriv->set_tuner = config->set_tuner_callback;\n\tpriv->xtal = config->xtal;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tif (helene_x_pon(priv) != 0) {\n\t\tkfree(priv);\n\t\treturn NULL;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tmemcpy(&fe->ops.tuner_ops, &helene_tuner_ops_t,\n\t\t\tsizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = priv;\n\tdev_info(&priv->i2c->dev,\n\t\t\t\"Sony HELENE Ter attached on addr=%x at I2C adapter %p\\n\",\n\t\t\tpriv->i2c_address, priv->i2c);\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(helene_attach);\n\nstatic int helene_probe(struct i2c_client *client)\n{\n\tstruct helene_config *config = client->dev.platform_data;\n\tstruct dvb_frontend *fe = config->fe;\n\tstruct device *dev = &client->dev;\n\tstruct helene_priv *priv;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->i2c_address = client->addr;\n\tpriv->i2c = client->adapter;\n\tpriv->set_tuner_data = config->set_tuner_priv;\n\tpriv->set_tuner = config->set_tuner_callback;\n\tpriv->xtal = config->xtal;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tif (helene_x_pon(priv) != 0)\n\t\treturn -EINVAL;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tmemcpy(&fe->ops.tuner_ops, &helene_tuner_ops,\n\t       sizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = priv;\n\ti2c_set_clientdata(client, priv);\n\n\tdev_info(dev, \"Sony HELENE attached on addr=%x at I2C adapter %p\\n\",\n\t\t priv->i2c_address, priv->i2c);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id helene_id[] = {\n\t{ \"helene\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, helene_id);\n\nstatic struct i2c_driver helene_driver = {\n\t.driver = {\n\t\t.name = \"helene\",\n\t},\n\t.probe = helene_probe,\n\t.id_table = helene_id,\n};\nmodule_i2c_driver(helene_driver);\n\nMODULE_DESCRIPTION(\"Sony HELENE Sat/Ter tuner driver\");\nMODULE_AUTHOR(\"Abylay Ospan <aospan@netup.ru>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}