{
  "module_name": "s5h1432.c",
  "hash_id": "e61abf36dde02cad2fa1061354d395eb941f2e9d598b3168b4fab90ad4735cdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/s5h1432.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <media/dvb_frontend.h>\n#include \"s5h1432.h\"\n\nstruct s5h1432_state {\n\n\tstruct i2c_adapter *i2c;\n\n\t \n\tconst struct s5h1432_config *config;\n\n\tstruct dvb_frontend frontend;\n\n\tenum fe_modulation current_modulation;\n\tunsigned int first_tune:1;\n\n\tu32 current_frequency;\n\tint if_freq;\n\n\tu8 inversion;\n};\n\nstatic int debug;\n\n#define dprintk(arg...) do {\t\\\n\tif (debug)\t\t\\\n\t\tprintk(arg);\t\\\n\t} while (0)\n\nstatic int s5h1432_writereg(struct s5h1432_state *state,\n\t\t\t    u8 addr, u8 reg, u8 data)\n{\n\tint ret;\n\tu8 buf[] = { reg, data };\n\n\tstruct i2c_msg msg = {.addr = addr, .flags = 0, .buf = buf, .len = 2 };\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tprintk(KERN_ERR \"%s: writereg error 0x%02x 0x%02x 0x%04x, ret == %i)\\n\",\n\t\t       __func__, addr, reg, data, ret);\n\n\treturn (ret != 1) ? -1 : 0;\n}\n\nstatic u8 s5h1432_readreg(struct s5h1432_state *state, u8 addr, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\n\tstruct i2c_msg msg[] = {\n\t\t{.addr = addr, .flags = 0, .buf = b0, .len = 1},\n\t\t{.addr = addr, .flags = I2C_M_RD, .buf = b1, .len = 1}\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tprintk(KERN_ERR \"%s: readreg error (ret == %i)\\n\",\n\t\t       __func__, ret);\n\treturn b1[0];\n}\n\nstatic int s5h1432_sleep(struct dvb_frontend *fe)\n{\n\treturn 0;\n}\n\nstatic int s5h1432_set_channel_bandwidth(struct dvb_frontend *fe,\n\t\t\t\t\t u32 bandwidth)\n{\n\tstruct s5h1432_state *state = fe->demodulator_priv;\n\n\tu8 reg = 0;\n\n\t \n\treg = s5h1432_readreg(state, S5H1432_I2C_TOP_ADDR, 0x2E);\n\treg &= ~(0x0C);\n\tswitch (bandwidth) {\n\tcase 6:\n\t\treg |= 0x08;\n\t\tbreak;\n\tcase 7:\n\t\treg |= 0x04;\n\t\tbreak;\n\tcase 8:\n\t\treg |= 0x00;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x2E, reg);\n\treturn 1;\n}\n\nstatic int s5h1432_set_IF(struct dvb_frontend *fe, u32 ifFreqHz)\n{\n\tstruct s5h1432_state *state = fe->demodulator_priv;\n\n\tswitch (ifFreqHz) {\n\tcase TAIWAN_HI_IF_FREQ_44_MHZ:\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0x55);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0x55);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0x15);\n\t\tbreak;\n\tcase EUROPE_HI_IF_FREQ_36_MHZ:\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0x00);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0x00);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0x40);\n\t\tbreak;\n\tcase IF_FREQ_6_MHZ:\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0x00);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0x00);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0xe0);\n\t\tbreak;\n\tcase IF_FREQ_3point3_MHZ:\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0x66);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0x66);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0xEE);\n\t\tbreak;\n\tcase IF_FREQ_3point5_MHZ:\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0x55);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0x55);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0xED);\n\t\tbreak;\n\tcase IF_FREQ_4_MHZ:\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0xAA);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0xAA);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0xEA);\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tu32 value = 0;\n\t\t\tvalue = (u32) (((48000 - (ifFreqHz / 1000)) * 512 *\n\t\t\t\t\t(u32) 32768) / (48 * 1000));\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Default IFFreq %d :reg value = 0x%x\\n\",\n\t\t\t       ifFreqHz, value);\n\t\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4,\n\t\t\t\t\t (u8) value & 0xFF);\n\t\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5,\n\t\t\t\t\t (u8) (value >> 8) & 0xFF);\n\t\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7,\n\t\t\t\t\t (u8) (value >> 16) & 0xFF);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 1;\n}\n\n \nstatic int s5h1432_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 dvb_bandwidth = 8;\n\tstruct s5h1432_state *state = fe->demodulator_priv;\n\n\tif (p->frequency == state->current_frequency) {\n\t\t \n\t\t \n\t} else {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tmsleep(300);\n\t\ts5h1432_set_channel_bandwidth(fe, dvb_bandwidth);\n\t\tswitch (p->bandwidth_hz) {\n\t\tcase 6000000:\n\t\t\tdvb_bandwidth = 6;\n\t\t\ts5h1432_set_IF(fe, IF_FREQ_4_MHZ);\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\tdvb_bandwidth = 7;\n\t\t\ts5h1432_set_IF(fe, IF_FREQ_4_MHZ);\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\t\tdvb_bandwidth = 8;\n\t\t\ts5h1432_set_IF(fe, IF_FREQ_4_MHZ);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\t \n \n\t\tmsleep(30);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x09, 0x1a);\n\t\tmsleep(30);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x09, 0x1b);\n\n\t\ts5h1432_set_channel_bandwidth(fe, dvb_bandwidth);\n\t\tswitch (p->bandwidth_hz) {\n\t\tcase 6000000:\n\t\t\tdvb_bandwidth = 6;\n\t\t\ts5h1432_set_IF(fe, IF_FREQ_4_MHZ);\n\t\t\tbreak;\n\t\tcase 7000000:\n\t\t\tdvb_bandwidth = 7;\n\t\t\ts5h1432_set_IF(fe, IF_FREQ_4_MHZ);\n\t\t\tbreak;\n\t\tcase 8000000:\n\t\t\tdvb_bandwidth = 8;\n\t\t\ts5h1432_set_IF(fe, IF_FREQ_4_MHZ);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\t \n\t\tmsleep(30);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x09, 0x1a);\n\t\tmsleep(30);\n\t\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x09, 0x1b);\n\n\t}\n\n\tstate->current_frequency = p->frequency;\n\n\treturn 0;\n}\n\nstatic int s5h1432_init(struct dvb_frontend *fe)\n{\n\tstruct s5h1432_state *state = fe->demodulator_priv;\n\n\tu8 reg = 0;\n\tstate->current_frequency = 0;\n\tprintk(KERN_INFO \" s5h1432_init().\\n\");\n\n\t \n\t \n\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x04, 0xa8);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x05, 0x01);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x07, 0x70);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x19, 0x80);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x1b, 0x9D);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x1c, 0x30);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x1d, 0x20);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x1e, 0x1B);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x2e, 0x40);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x42, 0x84);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x50, 0x5a);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x5a, 0xd3);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x68, 0x50);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xb8, 0x3c);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xc4, 0x10);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xcc, 0x9c);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xDA, 0x00);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe1, 0x94);\n\t \n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xf9, 0x00);\n\n\t \n\n\t \n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe4, 0x66);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe5, 0x66);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0xe7, 0xEE);\n\t \n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x1e, 0x31);\n\n\t \n\treg = s5h1432_readreg(state, S5H1432_I2C_TOP_ADDR, 0x42);\n\treg |= 0x80;\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x42, reg);\n\t \n\n\t \n\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x09, 0x1a);\n\tmsleep(30);\n\ts5h1432_writereg(state, S5H1432_I2C_TOP_ADDR, 0x09, 0x1b);\n\n\n\treturn 0;\n}\n\nstatic int s5h1432_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\treturn 0;\n}\n\nstatic int s5h1432_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t\tu16 *signal_strength)\n{\n\treturn 0;\n}\n\nstatic int s5h1432_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\treturn 0;\n}\n\nstatic int s5h1432_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\n\treturn 0;\n}\n\nstatic int s5h1432_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\treturn 0;\n}\n\nstatic int s5h1432_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t     struct dvb_frontend_tune_settings *tune)\n{\n\treturn 0;\n}\n\nstatic void s5h1432_release(struct dvb_frontend *fe)\n{\n\tstruct s5h1432_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops s5h1432_ops;\n\nstruct dvb_frontend *s5h1432_attach(const struct s5h1432_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct s5h1432_state *state = NULL;\n\n\tprintk(KERN_INFO \" Enter s5h1432_attach(). attach success!\\n\");\n\t \n\tstate = kmalloc(sizeof(struct s5h1432_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->current_modulation = QAM_16;\n\tstate->inversion = state->config->inversion;\n\n\t \n\tmemcpy(&state->frontend.ops, &s5h1432_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\n\tstate->frontend.demodulator_priv = state;\n\n\treturn &state->frontend;\n}\nEXPORT_SYMBOL_GPL(s5h1432_attach);\n\nstatic const struct dvb_frontend_ops s5h1432_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t .name = \"Samsung s5h1432 DVB-T Frontend\",\n\t\t .frequency_min_hz = 177 * MHz,\n\t\t .frequency_max_hz = 858 * MHz,\n\t\t .frequency_stepsize_hz = 166666,\n\t\t .caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t FE_CAN_HIERARCHY_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |\n\t\t FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_RECOVER},\n\n\t.init = s5h1432_init,\n\t.sleep = s5h1432_sleep,\n\t.set_frontend = s5h1432_set_frontend,\n\t.get_tune_settings = s5h1432_get_tune_settings,\n\t.read_status = s5h1432_read_status,\n\t.read_ber = s5h1432_read_ber,\n\t.read_signal_strength = s5h1432_read_signal_strength,\n\t.read_snr = s5h1432_read_snr,\n\t.read_ucblocks = s5h1432_read_ucblocks,\n\t.release = s5h1432_release,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Enable verbose debug messages\");\n\nMODULE_DESCRIPTION(\"Samsung s5h1432 DVB-T Demodulator driver\");\nMODULE_AUTHOR(\"Bill Liu\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}