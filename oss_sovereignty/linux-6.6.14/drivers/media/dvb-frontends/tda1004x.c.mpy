{
  "module_name": "tda1004x.c",
  "hash_id": "f8a7a9a76b38d91d6ebacd8a53ed0c5955d4e7c9620f47f4bff49ce0e3251a1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tda1004x.c",
  "human_readable_source": "\n   \n \n#define TDA10045_DEFAULT_FIRMWARE \"dvb-fe-tda10045.fw\"\n#define TDA10046_DEFAULT_FIRMWARE \"dvb-fe-tda10046.fw\"\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"tda1004x.h\"\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) printk(KERN_DEBUG \"tda1004x: \" args); \\\n\t} while (0)\n\n#define TDA1004X_CHIPID\t\t 0x00\n#define TDA1004X_AUTO\t\t 0x01\n#define TDA1004X_IN_CONF1\t 0x02\n#define TDA1004X_IN_CONF2\t 0x03\n#define TDA1004X_OUT_CONF1\t 0x04\n#define TDA1004X_OUT_CONF2\t 0x05\n#define TDA1004X_STATUS_CD\t 0x06\n#define TDA1004X_CONFC4\t\t 0x07\n#define TDA1004X_DSSPARE2\t 0x0C\n#define TDA10045H_CODE_IN\t 0x0D\n#define TDA10045H_FWPAGE\t 0x0E\n#define TDA1004X_SCAN_CPT\t 0x10\n#define TDA1004X_DSP_CMD\t 0x11\n#define TDA1004X_DSP_ARG\t 0x12\n#define TDA1004X_DSP_DATA1\t 0x13\n#define TDA1004X_DSP_DATA2\t 0x14\n#define TDA1004X_CONFADC1\t 0x15\n#define TDA1004X_CONFC1\t\t 0x16\n#define TDA10045H_S_AGC\t\t 0x1a\n#define TDA10046H_AGC_TUN_LEVEL\t 0x1a\n#define TDA1004X_SNR\t\t 0x1c\n#define TDA1004X_CONF_TS1\t 0x1e\n#define TDA1004X_CONF_TS2\t 0x1f\n#define TDA1004X_CBER_RESET\t 0x20\n#define TDA1004X_CBER_MSB\t 0x21\n#define TDA1004X_CBER_LSB\t 0x22\n#define TDA1004X_CVBER_LUT\t 0x23\n#define TDA1004X_VBER_MSB\t 0x24\n#define TDA1004X_VBER_MID\t 0x25\n#define TDA1004X_VBER_LSB\t 0x26\n#define TDA1004X_UNCOR\t\t 0x27\n\n#define TDA10045H_CONFPLL_P\t 0x2D\n#define TDA10045H_CONFPLL_M_MSB\t 0x2E\n#define TDA10045H_CONFPLL_M_LSB\t 0x2F\n#define TDA10045H_CONFPLL_N\t 0x30\n\n#define TDA10046H_CONFPLL1\t 0x2D\n#define TDA10046H_CONFPLL2\t 0x2F\n#define TDA10046H_CONFPLL3\t 0x30\n#define TDA10046H_TIME_WREF1\t 0x31\n#define TDA10046H_TIME_WREF2\t 0x32\n#define TDA10046H_TIME_WREF3\t 0x33\n#define TDA10046H_TIME_WREF4\t 0x34\n#define TDA10046H_TIME_WREF5\t 0x35\n\n#define TDA10045H_UNSURW_MSB\t 0x31\n#define TDA10045H_UNSURW_LSB\t 0x32\n#define TDA10045H_WREF_MSB\t 0x33\n#define TDA10045H_WREF_MID\t 0x34\n#define TDA10045H_WREF_LSB\t 0x35\n#define TDA10045H_MUXOUT\t 0x36\n#define TDA1004X_CONFADC2\t 0x37\n\n#define TDA10045H_IOFFSET\t 0x38\n\n#define TDA10046H_CONF_TRISTATE1 0x3B\n#define TDA10046H_CONF_TRISTATE2 0x3C\n#define TDA10046H_CONF_POLARITY\t 0x3D\n#define TDA10046H_FREQ_OFFSET\t 0x3E\n#define TDA10046H_GPIO_OUT_SEL\t 0x41\n#define TDA10046H_GPIO_SELECT\t 0x42\n#define TDA10046H_AGC_CONF\t 0x43\n#define TDA10046H_AGC_THR\t 0x44\n#define TDA10046H_AGC_RENORM\t 0x45\n#define TDA10046H_AGC_GAINS\t 0x46\n#define TDA10046H_AGC_TUN_MIN\t 0x47\n#define TDA10046H_AGC_TUN_MAX\t 0x48\n#define TDA10046H_AGC_IF_MIN\t 0x49\n#define TDA10046H_AGC_IF_MAX\t 0x4A\n\n#define TDA10046H_FREQ_PHY2_MSB\t 0x4D\n#define TDA10046H_FREQ_PHY2_LSB\t 0x4E\n\n#define TDA10046H_CVBER_CTRL\t 0x4F\n#define TDA10046H_AGC_IF_LEVEL\t 0x52\n#define TDA10046H_CODE_CPT\t 0x57\n#define TDA10046H_CODE_IN\t 0x58\n\n\nstatic int tda1004x_write_byteI(struct tda1004x_state *state, int reg, int data)\n{\n\tint ret;\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = { .flags = 0, .buf = buf, .len = 2 };\n\n\tdprintk(\"%s: reg=0x%x, data=0x%x\\n\", __func__, reg, data);\n\n\tmsg.addr = state->config->demod_address;\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tdprintk(\"%s: error reg=0x%x, data=0x%x, ret=%i\\n\",\n\t\t\t__func__, reg, data, ret);\n\n\tdprintk(\"%s: success reg=0x%x, data=0x%x, ret=%i\\n\", __func__,\n\t\treg, data, ret);\n\treturn (ret != 1) ? -1 : 0;\n}\n\nstatic int tda1004x_read_byte(struct tda1004x_state *state, int reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {{ .flags = 0, .buf = b0, .len = 1 },\n\t\t\t\t{ .flags = I2C_M_RD, .buf = b1, .len = 1 }};\n\n\tdprintk(\"%s: reg=0x%x\\n\", __func__, reg);\n\n\tmsg[0].addr = state->config->demod_address;\n\tmsg[1].addr = state->config->demod_address;\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\tdprintk(\"%s: error reg=0x%x, ret=%i\\n\", __func__, reg,\n\t\t\tret);\n\t\treturn -EINVAL;\n\t}\n\n\tdprintk(\"%s: success reg=0x%x, data=0x%x, ret=%i\\n\", __func__,\n\t\treg, b1[0], ret);\n\treturn b1[0];\n}\n\nstatic int tda1004x_write_mask(struct tda1004x_state *state, int reg, int mask, int data)\n{\n\tint val;\n\tdprintk(\"%s: reg=0x%x, mask=0x%x, data=0x%x\\n\", __func__, reg,\n\t\tmask, data);\n\n\t\n\tval = tda1004x_read_byte(state, reg);\n\tif (val < 0)\n\t\treturn val;\n\n\t\n\tval = val & ~mask;\n\tval |= data & 0xff;\n\n\t\n\treturn tda1004x_write_byteI(state, reg, val);\n}\n\nstatic int tda1004x_write_buf(struct tda1004x_state *state, int reg, unsigned char *buf, int len)\n{\n\tint i;\n\tint result;\n\n\tdprintk(\"%s: reg=0x%x, len=0x%x\\n\", __func__, reg, len);\n\n\tresult = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tresult = tda1004x_write_byteI(state, reg + i, buf[i]);\n\t\tif (result != 0)\n\t\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic int tda1004x_enable_tuner_i2c(struct tda1004x_state *state)\n{\n\tint result;\n\tdprintk(\"%s\\n\", __func__);\n\n\tresult = tda1004x_write_mask(state, TDA1004X_CONFC4, 2, 2);\n\tmsleep(20);\n\treturn result;\n}\n\nstatic int tda1004x_disable_tuner_i2c(struct tda1004x_state *state)\n{\n\tdprintk(\"%s\\n\", __func__);\n\n\treturn tda1004x_write_mask(state, TDA1004X_CONFC4, 2, 0);\n}\n\nstatic int tda10045h_set_bandwidth(struct tda1004x_state *state,\n\t\t\t\t   u32 bandwidth)\n{\n\tstatic u8 bandwidth_6mhz[] = { 0x02, 0x00, 0x3d, 0x00, 0x60, 0x1e, 0xa7, 0x45, 0x4f };\n\tstatic u8 bandwidth_7mhz[] = { 0x02, 0x00, 0x37, 0x00, 0x4a, 0x2f, 0x6d, 0x76, 0xdb };\n\tstatic u8 bandwidth_8mhz[] = { 0x02, 0x00, 0x3d, 0x00, 0x48, 0x17, 0x89, 0xc7, 0x14 };\n\n\tswitch (bandwidth) {\n\tcase 6000000:\n\t\ttda1004x_write_buf(state, TDA10045H_CONFPLL_P, bandwidth_6mhz, sizeof(bandwidth_6mhz));\n\t\tbreak;\n\n\tcase 7000000:\n\t\ttda1004x_write_buf(state, TDA10045H_CONFPLL_P, bandwidth_7mhz, sizeof(bandwidth_7mhz));\n\t\tbreak;\n\n\tcase 8000000:\n\t\ttda1004x_write_buf(state, TDA10045H_CONFPLL_P, bandwidth_8mhz, sizeof(bandwidth_8mhz));\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttda1004x_write_byteI(state, TDA10045H_IOFFSET, 0);\n\n\treturn 0;\n}\n\nstatic int tda10046h_set_bandwidth(struct tda1004x_state *state,\n\t\t\t\t   u32 bandwidth)\n{\n\tstatic u8 bandwidth_6mhz_53M[] = { 0x7b, 0x2e, 0x11, 0xf0, 0xd2 };\n\tstatic u8 bandwidth_7mhz_53M[] = { 0x6a, 0x02, 0x6a, 0x43, 0x9f };\n\tstatic u8 bandwidth_8mhz_53M[] = { 0x5c, 0x32, 0xc2, 0x96, 0x6d };\n\n\tstatic u8 bandwidth_6mhz_48M[] = { 0x70, 0x02, 0x49, 0x24, 0x92 };\n\tstatic u8 bandwidth_7mhz_48M[] = { 0x60, 0x02, 0xaa, 0xaa, 0xab };\n\tstatic u8 bandwidth_8mhz_48M[] = { 0x54, 0x03, 0x0c, 0x30, 0xc3 };\n\tint tda10046_clk53m;\n\n\tif ((state->config->if_freq == TDA10046_FREQ_045) ||\n\t    (state->config->if_freq == TDA10046_FREQ_052))\n\t\ttda10046_clk53m = 0;\n\telse\n\t\ttda10046_clk53m = 1;\n\tswitch (bandwidth) {\n\tcase 6000000:\n\t\tif (tda10046_clk53m)\n\t\t\ttda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_6mhz_53M,\n\t\t\t\t\t\t  sizeof(bandwidth_6mhz_53M));\n\t\telse\n\t\t\ttda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_6mhz_48M,\n\t\t\t\t\t\t  sizeof(bandwidth_6mhz_48M));\n\t\tif (state->config->if_freq == TDA10046_FREQ_045) {\n\t\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0a);\n\t\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0xab);\n\t\t}\n\t\tbreak;\n\n\tcase 7000000:\n\t\tif (tda10046_clk53m)\n\t\t\ttda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_7mhz_53M,\n\t\t\t\t\t\t  sizeof(bandwidth_7mhz_53M));\n\t\telse\n\t\t\ttda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_7mhz_48M,\n\t\t\t\t\t\t  sizeof(bandwidth_7mhz_48M));\n\t\tif (state->config->if_freq == TDA10046_FREQ_045) {\n\t\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0c);\n\t\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x00);\n\t\t}\n\t\tbreak;\n\n\tcase 8000000:\n\t\tif (tda10046_clk53m)\n\t\t\ttda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_8mhz_53M,\n\t\t\t\t\t\t  sizeof(bandwidth_8mhz_53M));\n\t\telse\n\t\t\ttda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_8mhz_48M,\n\t\t\t\t\t\t  sizeof(bandwidth_8mhz_48M));\n\t\tif (state->config->if_freq == TDA10046_FREQ_045) {\n\t\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0d);\n\t\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x55);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tda1004x_do_upload(struct tda1004x_state *state,\n\t\t\t      const unsigned char *mem, unsigned int len,\n\t\t\t      u8 dspCodeCounterReg, u8 dspCodeInReg)\n{\n\tu8 buf[65];\n\tstruct i2c_msg fw_msg = { .flags = 0, .buf = buf, .len = 0 };\n\tint tx_size;\n\tint pos = 0;\n\n\t \n\ttda1004x_write_byteI(state, dspCodeCounterReg, 0);\n\tfw_msg.addr = state->config->demod_address;\n\n\ti2c_lock_bus(state->i2c, I2C_LOCK_SEGMENT);\n\tbuf[0] = dspCodeInReg;\n\twhile (pos != len) {\n\t\t\n\t\ttx_size = len - pos;\n\t\tif (tx_size > 0x10)\n\t\t\ttx_size = 0x10;\n\n\t\t\n\t\tmemcpy(buf + 1, mem + pos, tx_size);\n\t\tfw_msg.len = tx_size + 1;\n\t\tif (__i2c_transfer(state->i2c, &fw_msg, 1) != 1) {\n\t\t\tprintk(KERN_ERR \"tda1004x: Error during firmware upload\\n\");\n\t\t\ti2c_unlock_bus(state->i2c, I2C_LOCK_SEGMENT);\n\t\t\treturn -EIO;\n\t\t}\n\t\tpos += tx_size;\n\n\t\tdprintk(\"%s: fw_pos=0x%x\\n\", __func__, pos);\n\t}\n\ti2c_unlock_bus(state->i2c, I2C_LOCK_SEGMENT);\n\n\t \n\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic int tda1004x_check_upload_ok(struct tda1004x_state *state)\n{\n\tu8 data1, data2;\n\tunsigned long timeout;\n\n\tif (state->demod_type == TDA1004X_DEMOD_TDA10046) {\n\t\ttimeout = jiffies + 2 * HZ;\n\t\twhile(!(tda1004x_read_byte(state, TDA1004X_STATUS_CD) & 0x20)) {\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tprintk(KERN_ERR \"tda1004x: timeout waiting for DSP ready\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(1);\n\t\t}\n\t} else\n\t\tmsleep(100);\n\n\t\n\ttda1004x_write_mask(state, TDA1004X_CONFC4, 0x10, 0); \n\ttda1004x_write_byteI(state, TDA1004X_DSP_CMD, 0x67);\n\n\tdata1 = tda1004x_read_byte(state, TDA1004X_DSP_DATA1);\n\tdata2 = tda1004x_read_byte(state, TDA1004X_DSP_DATA2);\n\tif (data1 != 0x67 || data2 < 0x20 || data2 > 0x2e) {\n\t\tprintk(KERN_INFO \"tda1004x: found firmware revision %x -- invalid\\n\", data2);\n\t\treturn -EIO;\n\t}\n\tprintk(KERN_INFO \"tda1004x: found firmware revision %x -- ok\\n\", data2);\n\treturn 0;\n}\n\nstatic int tda10045_fwupload(struct dvb_frontend* fe)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\tint ret;\n\tconst struct firmware *fw;\n\n\t \n\tif (tda1004x_check_upload_ok(state) == 0)\n\t\treturn 0;\n\n\t \n\tprintk(KERN_INFO \"tda1004x: waiting for firmware upload (%s)...\\n\", TDA10045_DEFAULT_FIRMWARE);\n\tret = state->config->request_firmware(fe, &fw, TDA10045_DEFAULT_FIRMWARE);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"tda1004x: no firmware upload (timeout or file not found?)\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\ttda1004x_write_mask(state, TDA1004X_CONFC4, 0x10, 0);\n\ttda1004x_write_mask(state, TDA1004X_CONFC4, 8, 8);\n\ttda1004x_write_mask(state, TDA1004X_CONFC4, 8, 0);\n\tmsleep(10);\n\n\t \n\ttda10045h_set_bandwidth(state, 8000000);\n\n\tret = tda1004x_do_upload(state, fw->data, fw->size, TDA10045H_FWPAGE, TDA10045H_CODE_IN);\n\trelease_firmware(fw);\n\tif (ret)\n\t\treturn ret;\n\tprintk(KERN_INFO \"tda1004x: firmware upload complete\\n\");\n\n\t \n\t \n\tmsleep(100);\n\n\treturn tda1004x_check_upload_ok(state);\n}\n\nstatic void tda10046_init_plls(struct dvb_frontend* fe)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\tint tda10046_clk53m;\n\n\tif ((state->config->if_freq == TDA10046_FREQ_045) ||\n\t    (state->config->if_freq == TDA10046_FREQ_052))\n\t\ttda10046_clk53m = 0;\n\telse\n\t\ttda10046_clk53m = 1;\n\n\ttda1004x_write_byteI(state, TDA10046H_CONFPLL1, 0xf0);\n\tif(tda10046_clk53m) {\n\t\tprintk(KERN_INFO \"tda1004x: setting up plls for 53MHz sampling clock\\n\");\n\t\ttda1004x_write_byteI(state, TDA10046H_CONFPLL2, 0x08); \n\t} else {\n\t\tprintk(KERN_INFO \"tda1004x: setting up plls for 48MHz sampling clock\\n\");\n\t\ttda1004x_write_byteI(state, TDA10046H_CONFPLL2, 0x03); \n\t}\n\tif (state->config->xtal_freq == TDA10046_XTAL_4M ) {\n\t\tdprintk(\"%s: setting up PLLs for a 4 MHz Xtal\\n\", __func__);\n\t\ttda1004x_write_byteI(state, TDA10046H_CONFPLL3, 0); \n\t} else {\n\t\tdprintk(\"%s: setting up PLLs for a 16 MHz Xtal\\n\", __func__);\n\t\ttda1004x_write_byteI(state, TDA10046H_CONFPLL3, 3); \n\t}\n\tif(tda10046_clk53m)\n\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_OFFSET, 0x67);\n\telse\n\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_OFFSET, 0x72);\n\t \n\tswitch (state->config->if_freq) {\n\tcase TDA10046_FREQ_045:\n\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0c);\n\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x00);\n\t\tbreak;\n\tcase TDA10046_FREQ_052:\n\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0d);\n\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0xc7);\n\t\tbreak;\n\tcase TDA10046_FREQ_3617:\n\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0xd7);\n\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x59);\n\t\tbreak;\n\tcase TDA10046_FREQ_3613:\n\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0xd7);\n\t\ttda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x3f);\n\t\tbreak;\n\t}\n\ttda10046h_set_bandwidth(state, 8000000);  \n\t \n\tmsleep(120);\n}\n\nstatic int tda10046_fwupload(struct dvb_frontend* fe)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\tint ret, confc4;\n\tconst struct firmware *fw;\n\n\t \n\tif (state->config->xtal_freq == TDA10046_XTAL_4M) {\n\t\tconfc4 = 0;\n\t} else {\n\t\tdprintk(\"%s: 16MHz Xtal, reducing I2C speed\\n\", __func__);\n\t\tconfc4 = 0x80;\n\t}\n\ttda1004x_write_byteI(state, TDA1004X_CONFC4, confc4);\n\n\ttda1004x_write_mask(state, TDA10046H_CONF_TRISTATE1, 1, 0);\n\t \n\tif (state->config->gpio_config != TDA10046_GPTRI) {\n\t\ttda1004x_write_byteI(state, TDA10046H_CONF_TRISTATE2, 0x33);\n\t\ttda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0x0f, state->config->gpio_config &0x0f);\n\t}\n\t \n\tmsleep(10);\n\n\t \n\ttda10046_init_plls(fe);\n\ttda1004x_write_mask(state, TDA1004X_CONFADC2, 0xc0, 0);\n\n\t \n\tif (tda1004x_check_upload_ok(state) == 0)\n\t\treturn 0;\n\n\t \n\tprintk(KERN_INFO \"tda1004x: trying to boot from eeprom\\n\");\n\ttda1004x_write_byteI(state, TDA1004X_CONFC4, 4);\n\tmsleep(300);\n\ttda1004x_write_byteI(state, TDA1004X_CONFC4, confc4);\n\n\t \n\tif (tda1004x_check_upload_ok(state) == 0)\n\t\treturn 0;\n\n\t \n\n\tif (state->config->request_firmware != NULL) {\n\t\t \n\t\tprintk(KERN_INFO \"tda1004x: waiting for firmware upload...\\n\");\n\t\tret = state->config->request_firmware(fe, &fw, TDA10046_DEFAULT_FIRMWARE);\n\t\tif (ret) {\n\t\t\t \n\t\t\tret = state->config->request_firmware(fe, &fw, TDA10045_DEFAULT_FIRMWARE);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_ERR \"tda1004x: no firmware upload (timeout or file not found?)\\n\");\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_INFO \"tda1004x: please rename the firmware file to %s\\n\",\n\t\t\t\t\t\t  TDA10046_DEFAULT_FIRMWARE);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprintk(KERN_ERR \"tda1004x: no request function defined, can't upload from file\\n\");\n\t\treturn -EIO;\n\t}\n\ttda1004x_write_mask(state, TDA1004X_CONFC4, 8, 8); \n\tret = tda1004x_do_upload(state, fw->data, fw->size, TDA10046H_CODE_CPT, TDA10046H_CODE_IN);\n\trelease_firmware(fw);\n\treturn tda1004x_check_upload_ok(state);\n}\n\nstatic int tda1004x_encode_fec(int fec)\n{\n\t\n\tswitch (fec) {\n\tcase FEC_1_2:\n\t\treturn 0;\n\tcase FEC_2_3:\n\t\treturn 1;\n\tcase FEC_3_4:\n\t\treturn 2;\n\tcase FEC_5_6:\n\t\treturn 3;\n\tcase FEC_7_8:\n\t\treturn 4;\n\t}\n\n\t\n\treturn -EINVAL;\n}\n\nstatic int tda1004x_decode_fec(int tdafec)\n{\n\t\n\tswitch (tdafec) {\n\tcase 0:\n\t\treturn FEC_1_2;\n\tcase 1:\n\t\treturn FEC_2_3;\n\tcase 2:\n\t\treturn FEC_3_4;\n\tcase 3:\n\t\treturn FEC_5_6;\n\tcase 4:\n\t\treturn FEC_7_8;\n\t}\n\n\t\n\treturn -1;\n}\n\nstatic int tda1004x_write(struct dvb_frontend* fe, const u8 buf[], int len)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\treturn tda1004x_write_byteI(state, buf[0], buf[1]);\n}\n\nstatic int tda10045_init(struct dvb_frontend* fe)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (tda10045_fwupload(fe)) {\n\t\tprintk(\"tda1004x: firmware upload failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttda1004x_write_mask(state, TDA1004X_CONFADC1, 0x10, 0); \n\n\t\n\ttda1004x_write_mask(state, TDA1004X_CONFC4, 0x20, 0); \n\ttda1004x_write_mask(state, TDA1004X_AUTO, 8, 0); \n\ttda1004x_write_mask(state, TDA1004X_CONFC1, 0x40, 0); \n\ttda1004x_write_mask(state, TDA1004X_CONFC1, 0x80, 0x80); \n\ttda1004x_write_mask(state, TDA1004X_AUTO, 0x10, 0x10); \n\ttda1004x_write_mask(state, TDA1004X_IN_CONF2, 0xC0, 0x0); \n\ttda1004x_write_byteI(state, TDA1004X_CONF_TS1, 0); \n\ttda1004x_write_byteI(state, TDA1004X_CONF_TS2, 0); \n\ttda1004x_write_mask(state, TDA1004X_VBER_MSB, 0xe0, 0xa0); \n\ttda1004x_write_mask(state, TDA1004X_CONFC1, 0x10, 0); \n\ttda1004x_write_byteI(state, TDA1004X_CONFADC1, 0x2e);\n\n\ttda1004x_write_mask(state, 0x1f, 0x01, state->config->invert_oclk);\n\n\treturn 0;\n}\n\nstatic int tda10046_init(struct dvb_frontend* fe)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (tda10046_fwupload(fe)) {\n\t\tprintk(\"tda1004x: firmware upload failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\t\n\ttda1004x_write_mask(state, TDA1004X_CONFC4, 0x20, 0); \n\ttda1004x_write_byteI(state, TDA1004X_AUTO, 0x87);    \n\ttda1004x_write_byteI(state, TDA1004X_CONFC1, 0x88);      \n\n\tswitch (state->config->agc_config) {\n\tcase TDA10046_AGC_DEFAULT:\n\t\ttda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0x00); \n\t\ttda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0xf0, 0x60);  \n\t\tbreak;\n\tcase TDA10046_AGC_IFO_AUTO_NEG:\n\t\ttda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0x0a); \n\t\ttda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0xf0, 0x60);  \n\t\tbreak;\n\tcase TDA10046_AGC_IFO_AUTO_POS:\n\t\ttda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0x0a); \n\t\ttda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0xf0, 0x00);  \n\t\tbreak;\n\tcase TDA10046_AGC_TDA827X:\n\t\ttda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0x02);   \n\t\ttda1004x_write_byteI(state, TDA10046H_AGC_THR, 0x70);    \n\t\ttda1004x_write_byteI(state, TDA10046H_AGC_RENORM, 0x08); \n\t\ttda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0xf0, 0x60);  \n\t\tbreak;\n\t}\n\tif (state->config->ts_mode == 0) {\n\t\ttda1004x_write_mask(state, TDA10046H_CONF_TRISTATE1, 0xc0, 0x40);\n\t\ttda1004x_write_mask(state, 0x3a, 0x80, state->config->invert_oclk << 7);\n\t} else {\n\t\ttda1004x_write_mask(state, TDA10046H_CONF_TRISTATE1, 0xc0, 0x80);\n\t\ttda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0x10,\n\t\t\t\t\t\t\tstate->config->invert_oclk << 4);\n\t}\n\ttda1004x_write_byteI(state, TDA1004X_CONFADC2, 0x38);\n\ttda1004x_write_mask (state, TDA10046H_CONF_TRISTATE1, 0x3e, 0x38); \n\ttda1004x_write_byteI(state, TDA10046H_AGC_TUN_MIN, 0);\t  \n\ttda1004x_write_byteI(state, TDA10046H_AGC_TUN_MAX, 0xff); \n\ttda1004x_write_byteI(state, TDA10046H_AGC_IF_MIN, 0);\t  \n\ttda1004x_write_byteI(state, TDA10046H_AGC_IF_MAX, 0xff);  \n\ttda1004x_write_byteI(state, TDA10046H_AGC_GAINS, 0x12); \n\ttda1004x_write_byteI(state, TDA10046H_CVBER_CTRL, 0x1a); \n\ttda1004x_write_byteI(state, TDA1004X_CONF_TS1, 7); \n\ttda1004x_write_byteI(state, TDA1004X_CONF_TS2, 0xc0); \n\t\n\n\treturn 0;\n}\n\nstatic int tda1004x_set_fe(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *fe_params = &fe->dtv_property_cache;\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\tint tmp;\n\tint inversion;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (state->demod_type == TDA1004X_DEMOD_TDA10046) {\n\t\t\n\t\ttda1004x_write_mask(state, TDA1004X_AUTO, 0x10, 0x10);\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x80, 0);\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF2, 0xC0, 0);\n\n\t\t\n\t\ttda1004x_write_mask(state, TDA10046H_AGC_CONF, 4, 0);\n\t}\n\n\t\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t\n\t\n\tif (state->demod_type == TDA1004X_DEMOD_TDA10045) {\n\t\tfe_params->code_rate_HP = FEC_AUTO;\n\t\tfe_params->guard_interval = GUARD_INTERVAL_AUTO;\n\t\tfe_params->transmission_mode = TRANSMISSION_MODE_AUTO;\n\t}\n\n\t\n\tif ((fe_params->code_rate_HP == FEC_AUTO) ||\n\t\t(fe_params->code_rate_LP == FEC_AUTO) ||\n\t\t(fe_params->modulation == QAM_AUTO) ||\n\t\t(fe_params->hierarchy == HIERARCHY_AUTO)) {\n\t\ttda1004x_write_mask(state, TDA1004X_AUTO, 1, 1);\t\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x03, 0);\t \n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x60, 0);\t\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF2, 0x3f, 0);\t\n\t} else {\n\t\ttda1004x_write_mask(state, TDA1004X_AUTO, 1, 0);\t\n\n\t\t\n\t\ttmp = tda1004x_encode_fec(fe_params->code_rate_HP);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF2, 7, tmp);\n\n\t\t\n\t\ttmp = tda1004x_encode_fec(fe_params->code_rate_LP);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF2, 0x38, tmp << 3);\n\n\t\t \n\t\tswitch (fe_params->modulation) {\n\t\tcase QPSK:\n\t\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 3, 0);\n\t\t\tbreak;\n\n\t\tcase QAM_16:\n\t\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 3, 1);\n\t\t\tbreak;\n\n\t\tcase QAM_64:\n\t\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 3, 2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t\n\t\tswitch (fe_params->hierarchy) {\n\t\tcase HIERARCHY_NONE:\n\t\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x60, 0 << 5);\n\t\t\tbreak;\n\n\t\tcase HIERARCHY_1:\n\t\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x60, 1 << 5);\n\t\t\tbreak;\n\n\t\tcase HIERARCHY_2:\n\t\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x60, 2 << 5);\n\t\t\tbreak;\n\n\t\tcase HIERARCHY_4:\n\t\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x60, 3 << 5);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t\n\tswitch (state->demod_type) {\n\tcase TDA1004X_DEMOD_TDA10045:\n\t\ttda10045h_set_bandwidth(state, fe_params->bandwidth_hz);\n\t\tbreak;\n\n\tcase TDA1004X_DEMOD_TDA10046:\n\t\ttda10046h_set_bandwidth(state, fe_params->bandwidth_hz);\n\t\tbreak;\n\t}\n\n\t\n\tinversion = fe_params->inversion;\n\tif (state->config->invert)\n\t\tinversion = inversion ? INVERSION_OFF : INVERSION_ON;\n\tswitch (inversion) {\n\tcase INVERSION_OFF:\n\t\ttda1004x_write_mask(state, TDA1004X_CONFC1, 0x20, 0);\n\t\tbreak;\n\n\tcase INVERSION_ON:\n\t\ttda1004x_write_mask(state, TDA1004X_CONFC1, 0x20, 0x20);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tswitch (fe_params->guard_interval) {\n\tcase GUARD_INTERVAL_1_32:\n\t\ttda1004x_write_mask(state, TDA1004X_AUTO, 2, 0);\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x0c, 0 << 2);\n\t\tbreak;\n\n\tcase GUARD_INTERVAL_1_16:\n\t\ttda1004x_write_mask(state, TDA1004X_AUTO, 2, 0);\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x0c, 1 << 2);\n\t\tbreak;\n\n\tcase GUARD_INTERVAL_1_8:\n\t\ttda1004x_write_mask(state, TDA1004X_AUTO, 2, 0);\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x0c, 2 << 2);\n\t\tbreak;\n\n\tcase GUARD_INTERVAL_1_4:\n\t\ttda1004x_write_mask(state, TDA1004X_AUTO, 2, 0);\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x0c, 3 << 2);\n\t\tbreak;\n\n\tcase GUARD_INTERVAL_AUTO:\n\t\ttda1004x_write_mask(state, TDA1004X_AUTO, 2, 2);\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x0c, 0 << 2);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tswitch (fe_params->transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\t\ttda1004x_write_mask(state, TDA1004X_AUTO, 4, 0);\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x10, 0 << 4);\n\t\tbreak;\n\n\tcase TRANSMISSION_MODE_8K:\n\t\ttda1004x_write_mask(state, TDA1004X_AUTO, 4, 0);\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x10, 1 << 4);\n\t\tbreak;\n\n\tcase TRANSMISSION_MODE_AUTO:\n\t\ttda1004x_write_mask(state, TDA1004X_AUTO, 4, 4);\n\t\ttda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x10, 0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tswitch (state->demod_type) {\n\tcase TDA1004X_DEMOD_TDA10045:\n\t\ttda1004x_write_mask(state, TDA1004X_CONFC4, 8, 8);\n\t\ttda1004x_write_mask(state, TDA1004X_CONFC4, 8, 0);\n\t\tbreak;\n\n\tcase TDA1004X_DEMOD_TDA10046:\n\t\ttda1004x_write_mask(state, TDA1004X_AUTO, 0x40, 0x40);\n\t\tmsleep(1);\n\t\ttda1004x_write_mask(state, TDA10046H_AGC_CONF, 4, 1);\n\t\tbreak;\n\t}\n\n\tmsleep(10);\n\n\treturn 0;\n}\n\nstatic int tda1004x_get_fe(struct dvb_frontend *fe,\n\t\t\t   struct dtv_frontend_properties *fe_params)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\tint status;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tstatus = tda1004x_read_byte(state, TDA1004X_STATUS_CD);\n\tif (status == -1)\n\t\treturn -EIO;\n\n\t \n\tif (!(status & 8))\n\t\treturn 0;\n\n\t\n\tfe_params->inversion = INVERSION_OFF;\n\tif (tda1004x_read_byte(state, TDA1004X_CONFC1) & 0x20)\n\t\tfe_params->inversion = INVERSION_ON;\n\tif (state->config->invert)\n\t\tfe_params->inversion = fe_params->inversion ? INVERSION_OFF : INVERSION_ON;\n\n\t\n\tswitch (state->demod_type) {\n\tcase TDA1004X_DEMOD_TDA10045:\n\t\tswitch (tda1004x_read_byte(state, TDA10045H_WREF_LSB)) {\n\t\tcase 0x14:\n\t\t\tfe_params->bandwidth_hz = 8000000;\n\t\t\tbreak;\n\t\tcase 0xdb:\n\t\t\tfe_params->bandwidth_hz = 7000000;\n\t\t\tbreak;\n\t\tcase 0x4f:\n\t\t\tfe_params->bandwidth_hz = 6000000;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TDA1004X_DEMOD_TDA10046:\n\t\tswitch (tda1004x_read_byte(state, TDA10046H_TIME_WREF1)) {\n\t\tcase 0x5c:\n\t\tcase 0x54:\n\t\t\tfe_params->bandwidth_hz = 8000000;\n\t\t\tbreak;\n\t\tcase 0x6a:\n\t\tcase 0x60:\n\t\t\tfe_params->bandwidth_hz = 7000000;\n\t\t\tbreak;\n\t\tcase 0x7b:\n\t\tcase 0x70:\n\t\t\tfe_params->bandwidth_hz = 6000000;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t\n\tfe_params->code_rate_HP =\n\t    tda1004x_decode_fec(tda1004x_read_byte(state, TDA1004X_OUT_CONF2) & 7);\n\tfe_params->code_rate_LP =\n\t    tda1004x_decode_fec((tda1004x_read_byte(state, TDA1004X_OUT_CONF2) >> 3) & 7);\n\n\t \n\tswitch (tda1004x_read_byte(state, TDA1004X_OUT_CONF1) & 3) {\n\tcase 0:\n\t\tfe_params->modulation = QPSK;\n\t\tbreak;\n\tcase 1:\n\t\tfe_params->modulation = QAM_16;\n\t\tbreak;\n\tcase 2:\n\t\tfe_params->modulation = QAM_64;\n\t\tbreak;\n\t}\n\n\t\n\tfe_params->transmission_mode = TRANSMISSION_MODE_2K;\n\tif (tda1004x_read_byte(state, TDA1004X_OUT_CONF1) & 0x10)\n\t\tfe_params->transmission_mode = TRANSMISSION_MODE_8K;\n\n\t\n\tswitch ((tda1004x_read_byte(state, TDA1004X_OUT_CONF1) & 0x0c) >> 2) {\n\tcase 0:\n\t\tfe_params->guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\tfe_params->guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\tfe_params->guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tfe_params->guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\t}\n\n\t\n\tswitch ((tda1004x_read_byte(state, TDA1004X_OUT_CONF1) & 0x60) >> 5) {\n\tcase 0:\n\t\tfe_params->hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tfe_params->hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tcase 2:\n\t\tfe_params->hierarchy = HIERARCHY_2;\n\t\tbreak;\n\tcase 3:\n\t\tfe_params->hierarchy = HIERARCHY_4;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tda1004x_read_status(struct dvb_frontend *fe,\n\t\t\t\tenum fe_status *fe_status)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\tint status;\n\tint cber;\n\tint vber;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t\n\tstatus = tda1004x_read_byte(state, TDA1004X_STATUS_CD);\n\tif (status == -1)\n\t\treturn -EIO;\n\n\t\n\t*fe_status = 0;\n\tif (status & 4)\n\t\t*fe_status |= FE_HAS_SIGNAL;\n\tif (status & 2)\n\t\t*fe_status |= FE_HAS_CARRIER;\n\tif (status & 8)\n\t\t*fe_status |= FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\n\t\n\t\n\tif (!(*fe_status & FE_HAS_VITERBI)) {\n\t\t\n\t\tcber = tda1004x_read_byte(state, TDA1004X_CBER_LSB);\n\t\tif (cber == -1)\n\t\t\treturn -EIO;\n\t\tstatus = tda1004x_read_byte(state, TDA1004X_CBER_MSB);\n\t\tif (status == -1)\n\t\t\treturn -EIO;\n\t\tcber |= (status << 8);\n\t\t\n\t\ttda1004x_read_byte(state, TDA1004X_CBER_RESET);\n\n\t\tif (cber != 65535)\n\t\t\t*fe_status |= FE_HAS_VITERBI;\n\t}\n\n\t\n\t\n\tif ((*fe_status & FE_HAS_VITERBI) && (!(*fe_status & FE_HAS_SYNC))) {\n\t\t\n\t\tvber = tda1004x_read_byte(state, TDA1004X_VBER_LSB);\n\t\tif (vber == -1)\n\t\t\treturn -EIO;\n\t\tstatus = tda1004x_read_byte(state, TDA1004X_VBER_MID);\n\t\tif (status == -1)\n\t\t\treturn -EIO;\n\t\tvber |= (status << 8);\n\t\tstatus = tda1004x_read_byte(state, TDA1004X_VBER_MSB);\n\t\tif (status == -1)\n\t\t\treturn -EIO;\n\t\tvber |= (status & 0x0f) << 16;\n\t\t\n\t\ttda1004x_read_byte(state, TDA1004X_CVBER_LUT);\n\n\t\t\n\t\t\n\t\tif (vber < 16632)\n\t\t\t*fe_status |= FE_HAS_SYNC;\n\t}\n\n\t\n\tdprintk(\"%s: fe_status=0x%x\\n\", __func__, *fe_status);\n\treturn 0;\n}\n\nstatic int tda1004x_read_signal_strength(struct dvb_frontend* fe, u16 * signal)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\tint tmp;\n\tint reg = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t\n\tswitch (state->demod_type) {\n\tcase TDA1004X_DEMOD_TDA10045:\n\t\treg = TDA10045H_S_AGC;\n\t\tbreak;\n\n\tcase TDA1004X_DEMOD_TDA10046:\n\t\treg = TDA10046H_AGC_IF_LEVEL;\n\t\tbreak;\n\t}\n\n\t\n\ttmp = tda1004x_read_byte(state, reg);\n\tif (tmp < 0)\n\t\treturn -EIO;\n\n\t*signal = (tmp << 8) | tmp;\n\tdprintk(\"%s: signal=0x%x\\n\", __func__, *signal);\n\treturn 0;\n}\n\nstatic int tda1004x_read_snr(struct dvb_frontend* fe, u16 * snr)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\tint tmp;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t\n\ttmp = tda1004x_read_byte(state, TDA1004X_SNR);\n\tif (tmp < 0)\n\t\treturn -EIO;\n\ttmp = 255 - tmp;\n\n\t*snr = ((tmp << 8) | tmp);\n\tdprintk(\"%s: snr=0x%x\\n\", __func__, *snr);\n\treturn 0;\n}\n\nstatic int tda1004x_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\tint tmp;\n\tint tmp2;\n\tint counter;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t\n\tcounter = 0;\n\ttmp = tda1004x_read_byte(state, TDA1004X_UNCOR);\n\tif (tmp < 0)\n\t\treturn -EIO;\n\ttmp &= 0x7f;\n\twhile (counter++ < 5) {\n\t\ttda1004x_write_mask(state, TDA1004X_UNCOR, 0x80, 0);\n\t\ttda1004x_write_mask(state, TDA1004X_UNCOR, 0x80, 0);\n\t\ttda1004x_write_mask(state, TDA1004X_UNCOR, 0x80, 0);\n\n\t\ttmp2 = tda1004x_read_byte(state, TDA1004X_UNCOR);\n\t\tif (tmp2 < 0)\n\t\t\treturn -EIO;\n\t\ttmp2 &= 0x7f;\n\t\tif ((tmp2 < tmp) || (tmp2 == 0))\n\t\t\tbreak;\n\t}\n\n\tif (tmp != 0x7f)\n\t\t*ucblocks = tmp;\n\telse\n\t\t*ucblocks = 0xffffffff;\n\n\tdprintk(\"%s: ucblocks=0x%x\\n\", __func__, *ucblocks);\n\treturn 0;\n}\n\nstatic int tda1004x_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\tint tmp;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t\n\ttmp = tda1004x_read_byte(state, TDA1004X_CBER_LSB);\n\tif (tmp < 0)\n\t\treturn -EIO;\n\t*ber = tmp << 1;\n\ttmp = tda1004x_read_byte(state, TDA1004X_CBER_MSB);\n\tif (tmp < 0)\n\t\treturn -EIO;\n\t*ber |= (tmp << 9);\n\t\n\ttda1004x_read_byte(state, TDA1004X_CBER_RESET);\n\n\tdprintk(\"%s: ber=0x%x\\n\", __func__, *ber);\n\treturn 0;\n}\n\nstatic int tda1004x_sleep(struct dvb_frontend* fe)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\tint gpio_conf;\n\n\tswitch (state->demod_type) {\n\tcase TDA1004X_DEMOD_TDA10045:\n\t\ttda1004x_write_mask(state, TDA1004X_CONFADC1, 0x10, 0x10);\n\t\tbreak;\n\n\tcase TDA1004X_DEMOD_TDA10046:\n\t\t \n\t\ttda1004x_write_byteI(state, TDA10046H_CONF_TRISTATE1, 0xff);\n\t\t \n\t\tgpio_conf = state->config->gpio_config;\n\t\tif (gpio_conf >= TDA10046_GP00_I)\n\t\t\ttda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0x0f,\n\t\t\t\t\t\t\t(gpio_conf & 0x0f) ^ 0x0a);\n\n\t\ttda1004x_write_mask(state, TDA1004X_CONFADC2, 0xc0, 0xc0);\n\t\ttda1004x_write_mask(state, TDA1004X_CONFC4, 1, 1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tda1004x_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\n{\n\tstruct tda1004x_state* state = fe->demodulator_priv;\n\n\tif (enable) {\n\t\treturn tda1004x_enable_tuner_i2c(state);\n\t} else {\n\t\treturn tda1004x_disable_tuner_i2c(state);\n\t}\n}\n\nstatic int tda1004x_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\n{\n\tfesettings->min_delay_ms = 800;\n\t \n\tfesettings->step_size = 0;\n\tfesettings->max_drift = 0;\n\treturn 0;\n}\n\nstatic void tda1004x_release(struct dvb_frontend* fe)\n{\n\tstruct tda1004x_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops tda10045_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name = \"Philips TDA10045H DVB-T\",\n\t\t.frequency_min_hz =  51 * MHz,\n\t\t.frequency_max_hz = 858 * MHz,\n\t\t.frequency_stepsize_hz = 166667,\n\t\t.caps =\n\t\t    FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t    FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t    FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t    FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO\n\t},\n\n\t.release = tda1004x_release,\n\n\t.init = tda10045_init,\n\t.sleep = tda1004x_sleep,\n\t.write = tda1004x_write,\n\t.i2c_gate_ctrl = tda1004x_i2c_gate_ctrl,\n\n\t.set_frontend = tda1004x_set_fe,\n\t.get_frontend = tda1004x_get_fe,\n\t.get_tune_settings = tda1004x_get_tune_settings,\n\n\t.read_status = tda1004x_read_status,\n\t.read_ber = tda1004x_read_ber,\n\t.read_signal_strength = tda1004x_read_signal_strength,\n\t.read_snr = tda1004x_read_snr,\n\t.read_ucblocks = tda1004x_read_ucblocks,\n};\n\nstruct dvb_frontend* tda10045_attach(const struct tda1004x_config* config,\n\t\t\t\t     struct i2c_adapter* i2c)\n{\n\tstruct tda1004x_state *state;\n\tint id;\n\n\t \n\tstate = kzalloc(sizeof(struct tda1004x_state), GFP_KERNEL);\n\tif (!state) {\n\t\tprintk(KERN_ERR \"Can't allocate memory for tda10045 state\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->demod_type = TDA1004X_DEMOD_TDA10045;\n\n\t \n\tid = tda1004x_read_byte(state, TDA1004X_CHIPID);\n\tif (id < 0) {\n\t\tprintk(KERN_ERR \"tda10045: chip is not answering. Giving up.\\n\");\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\n\tif (id != 0x25) {\n\t\tprintk(KERN_ERR \"Invalid tda1004x ID = 0x%02x. Can't proceed\\n\", id);\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\n\t \n\tmemcpy(&state->frontend.ops, &tda10045_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n}\n\nstatic const struct dvb_frontend_ops tda10046_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name = \"Philips TDA10046H DVB-T\",\n\t\t.frequency_min_hz =  51 * MHz,\n\t\t.frequency_max_hz = 858 * MHz,\n\t\t.frequency_stepsize_hz = 166667,\n\t\t.caps =\n\t\t    FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t    FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t    FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t    FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO\n\t},\n\n\t.release = tda1004x_release,\n\n\t.init = tda10046_init,\n\t.sleep = tda1004x_sleep,\n\t.write = tda1004x_write,\n\t.i2c_gate_ctrl = tda1004x_i2c_gate_ctrl,\n\n\t.set_frontend = tda1004x_set_fe,\n\t.get_frontend = tda1004x_get_fe,\n\t.get_tune_settings = tda1004x_get_tune_settings,\n\n\t.read_status = tda1004x_read_status,\n\t.read_ber = tda1004x_read_ber,\n\t.read_signal_strength = tda1004x_read_signal_strength,\n\t.read_snr = tda1004x_read_snr,\n\t.read_ucblocks = tda1004x_read_ucblocks,\n};\n\nstruct dvb_frontend* tda10046_attach(const struct tda1004x_config* config,\n\t\t\t\t     struct i2c_adapter* i2c)\n{\n\tstruct tda1004x_state *state;\n\tint id;\n\n\t \n\tstate = kzalloc(sizeof(struct tda1004x_state), GFP_KERNEL);\n\tif (!state) {\n\t\tprintk(KERN_ERR \"Can't allocate memory for tda10046 state\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->demod_type = TDA1004X_DEMOD_TDA10046;\n\n\t \n\tid = tda1004x_read_byte(state, TDA1004X_CHIPID);\n\tif (id < 0) {\n\t\tprintk(KERN_ERR \"tda10046: chip is not answering. Giving up.\\n\");\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\tif (id != 0x46) {\n\t\tprintk(KERN_ERR \"Invalid tda1004x ID = 0x%02x. Can't proceed\\n\", id);\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\n\t \n\tmemcpy(&state->frontend.ops, &tda10046_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n}\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"Philips TDA10045H & TDA10046H DVB-T Demodulator\");\nMODULE_AUTHOR(\"Andrew de Quincey & Robert Schlabbach\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(tda10045_attach);\nEXPORT_SYMBOL_GPL(tda10046_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}