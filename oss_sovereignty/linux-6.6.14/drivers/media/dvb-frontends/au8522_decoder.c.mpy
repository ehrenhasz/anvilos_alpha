{
  "module_name": "au8522_decoder.c",
  "hash_id": "b965fae881264b32c87a48b2fe1c97741a645893fcd597cb14e9c4a6c3bedb7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/au8522_decoder.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/videodev2.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include \"au8522.h\"\n#include \"au8522_priv.h\"\n\nMODULE_AUTHOR(\"Devin Heitmueller\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int au8522_analog_debug;\n\n\nmodule_param_named(analog_debug, au8522_analog_debug, int, 0644);\n\nMODULE_PARM_DESC(analog_debug,\n\t\t \"Analog debugging messages [0=Off (default) 1=On]\");\n\nstruct au8522_register_config {\n\tu16 reg_name;\n\tu8 reg_val[8];\n};\n\n\n \nstatic const struct au8522_register_config filter_coef[] = {\n\t{AU8522_FILTER_COEF_R410, {0x25, 0x00, 0x25, 0x25, 0x00, 0x00, 0x00} },\n\t{AU8522_FILTER_COEF_R411, {0x20, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00} },\n\t{AU8522_FILTER_COEF_R412, {0x03, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00} },\n\t{AU8522_FILTER_COEF_R413, {0xe6, 0x00, 0xe6, 0xe6, 0x00, 0x00, 0x00} },\n\t{AU8522_FILTER_COEF_R414, {0x40, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00} },\n\t{AU8522_FILTER_COEF_R415, {0x1b, 0x00, 0x1b, 0x1b, 0x00, 0x00, 0x00} },\n\t{AU8522_FILTER_COEF_R416, {0xc0, 0x00, 0xc0, 0x04, 0x00, 0x00, 0x00} },\n\t{AU8522_FILTER_COEF_R417, {0x04, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00} },\n\t{AU8522_FILTER_COEF_R418, {0x8c, 0x00, 0x8c, 0x8c, 0x00, 0x00, 0x00} },\n\t{AU8522_FILTER_COEF_R419, {0xa0, 0x40, 0xa0, 0xa0, 0x40, 0x40, 0x40} },\n\t{AU8522_FILTER_COEF_R41A, {0x21, 0x09, 0x21, 0x21, 0x09, 0x09, 0x09} },\n\t{AU8522_FILTER_COEF_R41B, {0x6c, 0x38, 0x6c, 0x6c, 0x38, 0x38, 0x38} },\n\t{AU8522_FILTER_COEF_R41C, {0x03, 0xff, 0x03, 0x03, 0xff, 0xff, 0xff} },\n\t{AU8522_FILTER_COEF_R41D, {0xbf, 0xc7, 0xbf, 0xbf, 0xc7, 0xc7, 0xc7} },\n\t{AU8522_FILTER_COEF_R41E, {0xa0, 0xdf, 0xa0, 0xa0, 0xdf, 0xdf, 0xdf} },\n\t{AU8522_FILTER_COEF_R41F, {0x10, 0x06, 0x10, 0x10, 0x06, 0x06, 0x06} },\n\t{AU8522_FILTER_COEF_R420, {0xae, 0x30, 0xae, 0xae, 0x30, 0x30, 0x30} },\n\t{AU8522_FILTER_COEF_R421, {0xc4, 0x01, 0xc4, 0xc4, 0x01, 0x01, 0x01} },\n\t{AU8522_FILTER_COEF_R422, {0x54, 0xdd, 0x54, 0x54, 0xdd, 0xdd, 0xdd} },\n\t{AU8522_FILTER_COEF_R423, {0xd0, 0xaf, 0xd0, 0xd0, 0xaf, 0xaf, 0xaf} },\n\t{AU8522_FILTER_COEF_R424, {0x1c, 0xf7, 0x1c, 0x1c, 0xf7, 0xf7, 0xf7} },\n\t{AU8522_FILTER_COEF_R425, {0x76, 0xdb, 0x76, 0x76, 0xdb, 0xdb, 0xdb} },\n\t{AU8522_FILTER_COEF_R426, {0x61, 0xc0, 0x61, 0x61, 0xc0, 0xc0, 0xc0} },\n\t{AU8522_FILTER_COEF_R427, {0xd1, 0x2f, 0xd1, 0xd1, 0x2f, 0x2f, 0x2f} },\n\t{AU8522_FILTER_COEF_R428, {0x84, 0xd8, 0x84, 0x84, 0xd8, 0xd8, 0xd8} },\n\t{AU8522_FILTER_COEF_R429, {0x06, 0xfb, 0x06, 0x06, 0xfb, 0xfb, 0xfb} },\n\t{AU8522_FILTER_COEF_R42A, {0x21, 0xd5, 0x21, 0x21, 0xd5, 0xd5, 0xd5} },\n\t{AU8522_FILTER_COEF_R42B, {0x0a, 0x3e, 0x0a, 0x0a, 0x3e, 0x3e, 0x3e} },\n\t{AU8522_FILTER_COEF_R42C, {0xe6, 0x15, 0xe6, 0xe6, 0x15, 0x15, 0x15} },\n\t{AU8522_FILTER_COEF_R42D, {0x01, 0x34, 0x01, 0x01, 0x34, 0x34, 0x34} },\n\n};\n#define NUM_FILTER_COEF (sizeof(filter_coef)\\\n\t\t\t / sizeof(struct au8522_register_config))\n\n\n \nstatic const struct au8522_register_config lpfilter_coef[] = {\n\t{0x060b, {0x21, 0x0b} },\n\t{0x060c, {0xad, 0xad} },\n\t{0x060d, {0x70, 0xf0} },\n\t{0x060e, {0xea, 0xe9} },\n\t{0x060f, {0xdd, 0xdd} },\n\t{0x0610, {0x08, 0x64} },\n\t{0x0611, {0x60, 0x60} },\n\t{0x0612, {0xf8, 0xb2} },\n\t{0x0613, {0x01, 0x02} },\n\t{0x0614, {0xe4, 0xb4} },\n\t{0x0615, {0x19, 0x02} },\n\t{0x0616, {0xae, 0x2e} },\n\t{0x0617, {0xee, 0xc5} },\n\t{0x0618, {0x56, 0x56} },\n\t{0x0619, {0x30, 0x58} },\n\t{0x061a, {0xf9, 0xf8} },\n\t{0x061b, {0x24, 0x64} },\n\t{0x061c, {0x07, 0x07} },\n\t{0x061d, {0x30, 0x30} },\n\t{0x061e, {0xa9, 0xed} },\n\t{0x061f, {0x09, 0x0b} },\n\t{0x0620, {0x42, 0xc2} },\n\t{0x0621, {0x1d, 0x2a} },\n\t{0x0622, {0xd6, 0x56} },\n\t{0x0623, {0x95, 0x8b} },\n\t{0x0624, {0x2b, 0x2b} },\n\t{0x0625, {0x30, 0x24} },\n\t{0x0626, {0x3e, 0x3e} },\n\t{0x0627, {0x62, 0xe2} },\n\t{0x0628, {0xe9, 0xf5} },\n\t{0x0629, {0x99, 0x19} },\n\t{0x062a, {0xd4, 0x11} },\n\t{0x062b, {0x03, 0x04} },\n\t{0x062c, {0xb5, 0x85} },\n\t{0x062d, {0x1e, 0x20} },\n\t{0x062e, {0x2a, 0xea} },\n\t{0x062f, {0xd7, 0xd2} },\n\t{0x0630, {0x15, 0x15} },\n\t{0x0631, {0xa3, 0xa9} },\n\t{0x0632, {0x1f, 0x1f} },\n\t{0x0633, {0xf9, 0xd1} },\n\t{0x0634, {0xc0, 0xc3} },\n\t{0x0635, {0x4d, 0x8d} },\n\t{0x0636, {0x21, 0x31} },\n\t{0x0637, {0x83, 0x83} },\n\t{0x0638, {0x08, 0x8c} },\n\t{0x0639, {0x19, 0x19} },\n\t{0x063a, {0x45, 0xa5} },\n\t{0x063b, {0xef, 0xec} },\n\t{0x063c, {0x8a, 0x8a} },\n\t{0x063d, {0xf4, 0xf6} },\n\t{0x063e, {0x8f, 0x8f} },\n\t{0x063f, {0x44, 0x0c} },\n\t{0x0640, {0xef, 0xf0} },\n\t{0x0641, {0x66, 0x66} },\n\t{0x0642, {0xcc, 0xd2} },\n\t{0x0643, {0x41, 0x41} },\n\t{0x0644, {0x63, 0x93} },\n\t{0x0645, {0x8e, 0x8e} },\n\t{0x0646, {0xa2, 0x42} },\n\t{0x0647, {0x7b, 0x7b} },\n\t{0x0648, {0x04, 0x04} },\n\t{0x0649, {0x00, 0x00} },\n\t{0x064a, {0x40, 0x40} },\n\t{0x064b, {0x8c, 0x98} },\n\t{0x064c, {0x00, 0x00} },\n\t{0x064d, {0x63, 0xc3} },\n\t{0x064e, {0x04, 0x04} },\n\t{0x064f, {0x20, 0x20} },\n\t{0x0650, {0x00, 0x00} },\n\t{0x0651, {0x40, 0x40} },\n\t{0x0652, {0x01, 0x01} },\n};\n#define NUM_LPFILTER_COEF (sizeof(lpfilter_coef)\\\n\t\t\t   / sizeof(struct au8522_register_config))\n\nstatic inline struct au8522_state *to_state(struct v4l2_subdev *sd)\n{\n\treturn container_of(sd, struct au8522_state, sd);\n}\n\nstatic void setup_decoder_defaults(struct au8522_state *state, bool is_svideo)\n{\n\tint i;\n\tint filter_coef_type;\n\n\t \n\tau8522_writereg(state, AU8522_TVDEC_SHARPNESSREG009H, 0x07);\n\tau8522_writereg(state, AU8522_TVDEC_BRIGHTNESS_REG00AH, 0xed);\n\tau8522_writereg(state, AU8522_TVDEC_CONTRAST_REG00BH, 0x79);\n\tau8522_writereg(state, AU8522_TVDEC_SATURATION_CB_REG00CH, 0x80);\n\tau8522_writereg(state, AU8522_TVDEC_SATURATION_CR_REG00DH, 0x80);\n\tau8522_writereg(state, AU8522_TVDEC_HUE_H_REG00EH, 0x00);\n\tau8522_writereg(state, AU8522_TVDEC_HUE_L_REG00FH, 0x00);\n\n\t \n\tau8522_writereg(state, AU8522_TVDEC_INT_MASK_REG010H, 0x00);\n\n\tif (is_svideo)\n\t\tau8522_writereg(state, AU8522_VIDEO_MODE_REG011H, 0x04);\n\telse\n\t\tau8522_writereg(state, AU8522_VIDEO_MODE_REG011H, 0x00);\n\n\tau8522_writereg(state, AU8522_TVDEC_PGA_REG012H,\n\t\t\tAU8522_TVDEC_PGA_REG012H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_COMB_MODE_REG015H,\n\t\t\tAU8522_TVDEC_COMB_MODE_REG015H_CVBS);\n\tau8522_writereg(state, AU8522_TVDED_DBG_MODE_REG060H,\n\t\t\tAU8522_TVDED_DBG_MODE_REG060H_CVBS);\n\n\tif (state->std == V4L2_STD_PAL_M) {\n\t\tau8522_writereg(state, AU8522_TVDEC_FORMAT_CTRL1_REG061H,\n\t\t\t\tAU8522_TVDEC_FORMAT_CTRL1_REG061H_FIELD_LEN_525 |\n\t\t\t\tAU8522_TVDEC_FORMAT_CTRL1_REG061H_LINE_LEN_63_492 |\n\t\t\t\tAU8522_TVDEC_FORMAT_CTRL1_REG061H_SUBCARRIER_NTSC_AUTO);\n\t\tau8522_writereg(state, AU8522_TVDEC_FORMAT_CTRL2_REG062H,\n\t\t\t\tAU8522_TVDEC_FORMAT_CTRL2_REG062H_STD_PAL_M);\n\t} else {\n\t\t \n\t\tau8522_writereg(state, AU8522_TVDEC_FORMAT_CTRL1_REG061H,\n\t\t\t\tAU8522_TVDEC_FORMAT_CTRL1_REG061H_FIELD_LEN_525 |\n\t\t\t\tAU8522_TVDEC_FORMAT_CTRL1_REG061H_LINE_LEN_63_492 |\n\t\t\t\tAU8522_TVDEC_FORMAT_CTRL1_REG061H_SUBCARRIER_NTSC_MN);\n\t\tau8522_writereg(state, AU8522_TVDEC_FORMAT_CTRL2_REG062H,\n\t\t\t\tAU8522_TVDEC_FORMAT_CTRL2_REG062H_STD_NTSC);\n\t}\n\tau8522_writereg(state, AU8522_TVDEC_VCR_DET_LLIM_REG063H,\n\t\t\tAU8522_TVDEC_VCR_DET_LLIM_REG063H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_VCR_DET_HLIM_REG064H,\n\t\t\tAU8522_TVDEC_VCR_DET_HLIM_REG064H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_COMB_VDIF_THR1_REG065H,\n\t\t\tAU8522_TVDEC_COMB_VDIF_THR1_REG065H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_COMB_VDIF_THR2_REG066H,\n\t\t\tAU8522_TVDEC_COMB_VDIF_THR2_REG066H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_COMB_VDIF_THR3_REG067H,\n\t\t\tAU8522_TVDEC_COMB_VDIF_THR3_REG067H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_COMB_NOTCH_THR_REG068H,\n\t\t\tAU8522_TVDEC_COMB_NOTCH_THR_REG068H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_COMB_HDIF_THR1_REG069H,\n\t\t\tAU8522_TVDEC_COMB_HDIF_THR1_REG069H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_COMB_HDIF_THR2_REG06AH,\n\t\t\tAU8522_TVDEC_COMB_HDIF_THR2_REG06AH_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_COMB_HDIF_THR3_REG06BH,\n\t\t\tAU8522_TVDEC_COMB_HDIF_THR3_REG06BH_CVBS);\n\tif (is_svideo) {\n\t\tau8522_writereg(state, AU8522_TVDEC_COMB_DCDIF_THR1_REG06CH,\n\t\t\t\tAU8522_TVDEC_COMB_DCDIF_THR1_REG06CH_SVIDEO);\n\t\tau8522_writereg(state, AU8522_TVDEC_COMB_DCDIF_THR2_REG06DH,\n\t\t\t\tAU8522_TVDEC_COMB_DCDIF_THR2_REG06DH_SVIDEO);\n\t} else {\n\t\tau8522_writereg(state, AU8522_TVDEC_COMB_DCDIF_THR1_REG06CH,\n\t\t\t\tAU8522_TVDEC_COMB_DCDIF_THR1_REG06CH_CVBS);\n\t\tau8522_writereg(state, AU8522_TVDEC_COMB_DCDIF_THR2_REG06DH,\n\t\t\t\tAU8522_TVDEC_COMB_DCDIF_THR2_REG06DH_CVBS);\n\t}\n\tau8522_writereg(state, AU8522_TVDEC_COMB_DCDIF_THR3_REG06EH,\n\t\t\tAU8522_TVDEC_COMB_DCDIF_THR3_REG06EH_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_UV_SEP_THR_REG06FH,\n\t\t\tAU8522_TVDEC_UV_SEP_THR_REG06FH_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_COMB_DC_THR1_NTSC_REG070H,\n\t\t\tAU8522_TVDEC_COMB_DC_THR1_NTSC_REG070H_CVBS);\n\tau8522_writereg(state, AU8522_REG071H, AU8522_REG071H_CVBS);\n\tau8522_writereg(state, AU8522_REG072H, AU8522_REG072H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_COMB_DC_THR2_NTSC_REG073H,\n\t\t\tAU8522_TVDEC_COMB_DC_THR2_NTSC_REG073H_CVBS);\n\tau8522_writereg(state, AU8522_REG074H, AU8522_REG074H_CVBS);\n\tau8522_writereg(state, AU8522_REG075H, AU8522_REG075H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_DCAGC_CTRL_REG077H,\n\t\t\tAU8522_TVDEC_DCAGC_CTRL_REG077H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_PIC_START_ADJ_REG078H,\n\t\t\tAU8522_TVDEC_PIC_START_ADJ_REG078H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_AGC_HIGH_LIMIT_REG079H,\n\t\t\tAU8522_TVDEC_AGC_HIGH_LIMIT_REG079H_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_MACROVISION_SYNC_THR_REG07AH,\n\t\t\tAU8522_TVDEC_MACROVISION_SYNC_THR_REG07AH_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_INTRP_CTRL_REG07BH,\n\t\t\tAU8522_TVDEC_INTRP_CTRL_REG07BH_CVBS);\n\tau8522_writereg(state, AU8522_TVDEC_AGC_LOW_LIMIT_REG0E4H,\n\t\t\tAU8522_TVDEC_AGC_LOW_LIMIT_REG0E4H_CVBS);\n\tau8522_writereg(state, AU8522_TOREGAAGC_REG0E5H,\n\t\t\tAU8522_TOREGAAGC_REG0E5H_CVBS);\n\tau8522_writereg(state, AU8522_REG016H, AU8522_REG016H_CVBS);\n\n\t \n\t \n\tfilter_coef_type = 5;\n\n\t \n\tfor (i = 0; i < NUM_FILTER_COEF; i++) {\n\t\tau8522_writereg(state, filter_coef[i].reg_name,\n\t\t\t\tfilter_coef[i].reg_val[filter_coef_type]);\n\t}\n\n\t \n\tau8522_writereg(state, AU8522_REG42EH, 0x87);\n\tau8522_writereg(state, AU8522_REG42FH, 0xa2);\n\tau8522_writereg(state, AU8522_REG430H, 0xbf);\n\tau8522_writereg(state, AU8522_REG431H, 0xcb);\n\tau8522_writereg(state, AU8522_REG432H, 0xa1);\n\tau8522_writereg(state, AU8522_REG433H, 0x41);\n\tau8522_writereg(state, AU8522_REG434H, 0x88);\n\tau8522_writereg(state, AU8522_REG435H, 0xc2);\n\tau8522_writereg(state, AU8522_REG436H, 0x3c);\n}\n\nstatic void au8522_setup_cvbs_mode(struct au8522_state *state, u8 input_mode)\n{\n\t \n\tau8522_writereg(state, AU8522_MODULE_CLOCK_CONTROL_REG0A3H,\n\t\t\tAU8522_MODULE_CLOCK_CONTROL_REG0A3H_CVBS);\n\n\t \n\tau8522_writereg(state, AU8522_PGA_CONTROL_REG082H, 0x00);\n\n\t \n\tau8522_writereg(state, AU8522_CLAMPING_CONTROL_REG083H, 0x00);\n\n\tau8522_writereg(state, AU8522_INPUT_CONTROL_REG081H, input_mode);\n\n\tsetup_decoder_defaults(state, false);\n\n\tau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\n\t\t\tAU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H_CVBS);\n}\n\nstatic void au8522_setup_cvbs_tuner_mode(struct au8522_state *state,\n\t\t\t\t\t u8 input_mode)\n{\n\t \n\tau8522_writereg(state, AU8522_MODULE_CLOCK_CONTROL_REG0A3H,\n\t\t\tAU8522_MODULE_CLOCK_CONTROL_REG0A3H_CVBS);\n\n\t \n\tau8522_writereg(state, AU8522_PGA_CONTROL_REG082H, 0x00);\n\n\t \n\tau8522_writereg(state, AU8522_CLAMPING_CONTROL_REG083H, 0x0e);\n\n\t \n\tau8522_writereg(state, AU8522_PGA_CONTROL_REG082H, 0x10);\n\n\t \n\tau8522_writereg(state, AU8522_INPUT_CONTROL_REG081H, input_mode);\n\n\tsetup_decoder_defaults(state, false);\n\n\tau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\n\t\t\tAU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H_CVBS);\n}\n\nstatic void au8522_setup_svideo_mode(struct au8522_state *state,\n\t\t\t\t     u8 input_mode)\n{\n\tau8522_writereg(state, AU8522_MODULE_CLOCK_CONTROL_REG0A3H,\n\t\t\tAU8522_MODULE_CLOCK_CONTROL_REG0A3H_SVIDEO);\n\n\t \n\tau8522_writereg(state, AU8522_INPUT_CONTROL_REG081H, input_mode);\n\n\t \n\tau8522_writereg(state, AU8522_PGA_CONTROL_REG082H, 0x00);\n\n\t \n\tau8522_writereg(state, AU8522_CLAMPING_CONTROL_REG083H, 0x00);\n\n\tsetup_decoder_defaults(state, true);\n\n\tau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\n\t\t\tAU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H_CVBS);\n}\n\n \n\nstatic void disable_audio_input(struct au8522_state *state)\n{\n\tau8522_writereg(state, AU8522_AUDIO_VOLUME_L_REG0F2H, 0x00);\n\tau8522_writereg(state, AU8522_AUDIO_VOLUME_R_REG0F3H, 0x00);\n\tau8522_writereg(state, AU8522_AUDIO_VOLUME_REG0F4H, 0x00);\n\n\tau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_1_REG0A5H, 0x04);\n\tau8522_writereg(state, AU8522_I2S_CTRL_2_REG112H, 0x02);\n\n\tau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\n\t\t\tAU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H_SVIDEO);\n}\n\n \nstatic void set_audio_input(struct au8522_state *state)\n{\n\tint aud_input = state->aud_input;\n\tint i;\n\n\t \n\n\tif (aud_input == AU8522_AUDIO_NONE) {\n\t\tdisable_audio_input(state);\n\t\treturn;\n\t}\n\n\tif (aud_input != AU8522_AUDIO_SIF) {\n\t\t \n\t\tprintk(KERN_ERR \"Unsupported audio mode requested! mode=%d\\n\",\n\t\t       aud_input);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_LPFILTER_COEF; i++) {\n\t\tau8522_writereg(state, lpfilter_coef[i].reg_name,\n\t\t\t\tlpfilter_coef[i].reg_val[0]);\n\t}\n\n\t \n\tau8522_writereg(state, AU8522_AUDIO_VOLUME_L_REG0F2H, 0x7F);\n\tau8522_writereg(state, AU8522_AUDIO_VOLUME_R_REG0F3H, 0x7F);\n\tau8522_writereg(state, AU8522_AUDIO_VOLUME_REG0F4H, 0xff);\n\n\t \n\tau8522_writereg(state, AU8522_REG0F9H, AU8522_REG0F9H_AUDIO);\n\n\t \n\tau8522_writereg(state, AU8522_AUDIO_MODE_REG0F1H, 0x82);\n\tmsleep(70);\n\n\t \n\tau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H, 0x9d);\n\n\t \n\tau8522_writereg(state, AU8522_AUDIOFREQ_REG606H, 0x03);\n\n\t \n\tau8522_writereg(state, AU8522_I2S_CTRL_2_REG112H, 0xc2);\n\n\t \n\tau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_1_REG0A5H, 0x09);\n}\n\n \n\nstatic int au8522_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct au8522_state *state =\n\t\tcontainer_of(ctrl->handler, struct au8522_state, hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tau8522_writereg(state, AU8522_TVDEC_BRIGHTNESS_REG00AH,\n\t\t\t\tctrl->val - 128);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tau8522_writereg(state, AU8522_TVDEC_CONTRAST_REG00BH,\n\t\t\t\tctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\tau8522_writereg(state, AU8522_TVDEC_SATURATION_CB_REG00CH,\n\t\t\t\tctrl->val);\n\t\tau8522_writereg(state, AU8522_TVDEC_SATURATION_CR_REG00DH,\n\t\t\t\tctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\tau8522_writereg(state, AU8522_TVDEC_HUE_H_REG00EH,\n\t\t\t\tctrl->val >> 8);\n\t\tau8522_writereg(state, AU8522_TVDEC_HUE_L_REG00FH,\n\t\t\t\tctrl->val & 0xFF);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int au8522_g_register(struct v4l2_subdev *sd,\n\t\t\t     struct v4l2_dbg_register *reg)\n{\n\tstruct au8522_state *state = to_state(sd);\n\n\treg->val = au8522_readreg(state, reg->reg & 0xffff);\n\treturn 0;\n}\n\nstatic int au8522_s_register(struct v4l2_subdev *sd,\n\t\t\t     const struct v4l2_dbg_register *reg)\n{\n\tstruct au8522_state *state = to_state(sd);\n\n\tau8522_writereg(state, reg->reg, reg->val & 0xff);\n\treturn 0;\n}\n#endif\n\nstatic void au8522_video_set(struct au8522_state *state)\n{\n\tu8 input_mode;\n\n\tau8522_writereg(state, 0xa4, 1 << 5);\n\n\tswitch (state->vid_input) {\n\tcase AU8522_COMPOSITE_CH1:\n\t\tinput_mode = AU8522_INPUT_CONTROL_REG081H_CVBS_CH1;\n\t\tau8522_setup_cvbs_mode(state, input_mode);\n\t\tbreak;\n\tcase AU8522_COMPOSITE_CH2:\n\t\tinput_mode = AU8522_INPUT_CONTROL_REG081H_CVBS_CH2;\n\t\tau8522_setup_cvbs_mode(state, input_mode);\n\t\tbreak;\n\tcase AU8522_COMPOSITE_CH3:\n\t\tinput_mode = AU8522_INPUT_CONTROL_REG081H_CVBS_CH3;\n\t\tau8522_setup_cvbs_mode(state, input_mode);\n\t\tbreak;\n\tcase AU8522_COMPOSITE_CH4:\n\t\tinput_mode = AU8522_INPUT_CONTROL_REG081H_CVBS_CH4;\n\t\tau8522_setup_cvbs_mode(state, input_mode);\n\t\tbreak;\n\tcase AU8522_SVIDEO_CH13:\n\t\tinput_mode = AU8522_INPUT_CONTROL_REG081H_SVIDEO_CH13;\n\t\tau8522_setup_svideo_mode(state, input_mode);\n\t\tbreak;\n\tcase AU8522_SVIDEO_CH24:\n\t\tinput_mode = AU8522_INPUT_CONTROL_REG081H_SVIDEO_CH24;\n\t\tau8522_setup_svideo_mode(state, input_mode);\n\t\tbreak;\n\tdefault:\n\tcase AU8522_COMPOSITE_CH4_SIF:\n\t\tinput_mode = AU8522_INPUT_CONTROL_REG081H_CVBS_CH4_SIF;\n\t\tau8522_setup_cvbs_tuner_mode(state, input_mode);\n\t\tbreak;\n\t}\n}\n\nstatic int au8522_s_stream(struct v4l2_subdev *sd, int enable)\n{\n\tstruct au8522_state *state = to_state(sd);\n\n\tif (enable) {\n\t\t \n\t\tstate->current_frequency = 0;\n\n\t\tau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\n\t\t\t\t0x01);\n\t\tmsleep(10);\n\n\t\tau8522_video_set(state);\n\t\tset_audio_input(state);\n\n\t\tstate->operational_mode = AU8522_ANALOG_MODE;\n\t} else {\n\t\t \n\t\tau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\n\t\t\t\t1 << 5);\n\t\tstate->operational_mode = AU8522_SUSPEND_MODE;\n\t}\n\treturn 0;\n}\n\nstatic int au8522_s_video_routing(struct v4l2_subdev *sd,\n\t\t\t\t\tu32 input, u32 output, u32 config)\n{\n\tstruct au8522_state *state = to_state(sd);\n\n\tswitch (input) {\n\tcase AU8522_COMPOSITE_CH1:\n\tcase AU8522_SVIDEO_CH13:\n\tcase AU8522_COMPOSITE_CH4_SIF:\n\t\tstate->vid_input = input;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"au8522 mode not currently supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (state->operational_mode == AU8522_ANALOG_MODE)\n\t\tau8522_video_set(state);\n\n\treturn 0;\n}\n\nstatic int au8522_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\n{\n\tstruct au8522_state *state = to_state(sd);\n\n\tif ((std & (V4L2_STD_PAL_M | V4L2_STD_NTSC_M)) == 0)\n\t\treturn -EINVAL;\n\n\tstate->std = std;\n\n\tif (state->operational_mode == AU8522_ANALOG_MODE)\n\t\tau8522_video_set(state);\n\n\treturn 0;\n}\n\nstatic int au8522_s_audio_routing(struct v4l2_subdev *sd,\n\t\t\t\t\tu32 input, u32 output, u32 config)\n{\n\tstruct au8522_state *state = to_state(sd);\n\n\tstate->aud_input = input;\n\n\tif (state->operational_mode == AU8522_ANALOG_MODE)\n\t\tset_audio_input(state);\n\n\treturn 0;\n}\n\nstatic int au8522_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\n{\n\tint val = 0;\n\tstruct au8522_state *state = to_state(sd);\n\tu8 lock_status;\n\tu8 pll_status;\n\n\t \n\tlock_status = au8522_readreg(state, 0x00);\n\tpll_status = au8522_readreg(state, 0x7e);\n\tif ((lock_status == 0xa2) && (pll_status & 0x10))\n\t\tvt->signal = 0xffff;\n\telse\n\t\tvt->signal = 0x00;\n\n\tvt->capability |=\n\t\tV4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LANG1 |\n\t\tV4L2_TUNER_CAP_LANG2 | V4L2_TUNER_CAP_SAP;\n\n\tval = V4L2_TUNER_SUB_MONO;\n\tvt->rxsubchans = val;\n\tvt->audmode = V4L2_TUNER_MODE_STEREO;\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_subdev_core_ops au8522_core_ops = {\n\t.log_status = v4l2_ctrl_subdev_log_status,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.g_register = au8522_g_register,\n\t.s_register = au8522_s_register,\n#endif\n};\n\nstatic const struct v4l2_subdev_tuner_ops au8522_tuner_ops = {\n\t.g_tuner = au8522_g_tuner,\n};\n\nstatic const struct v4l2_subdev_audio_ops au8522_audio_ops = {\n\t.s_routing = au8522_s_audio_routing,\n};\n\nstatic const struct v4l2_subdev_video_ops au8522_video_ops = {\n\t.s_routing = au8522_s_video_routing,\n\t.s_stream = au8522_s_stream,\n\t.s_std = au8522_s_std,\n};\n\nstatic const struct v4l2_subdev_ops au8522_ops = {\n\t.core = &au8522_core_ops,\n\t.tuner = &au8522_tuner_ops,\n\t.audio = &au8522_audio_ops,\n\t.video = &au8522_video_ops,\n};\n\nstatic const struct v4l2_ctrl_ops au8522_ctrl_ops = {\n\t.s_ctrl = au8522_s_ctrl,\n};\n\n \n\nstatic int au8522_probe(struct i2c_client *client)\n{\n\tstruct au8522_state *state;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2_subdev *sd;\n\tint instance;\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tint ret;\n#endif\n\n\t \n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\treturn -EIO;\n\t}\n\n\t \n\tinstance = au8522_get_state(&state, client->adapter, client->addr);\n\tswitch (instance) {\n\tcase 0:\n\t\tprintk(KERN_ERR \"au8522_decoder allocation failed\\n\");\n\t\treturn -EIO;\n\tcase 1:\n\t\t \n\t\tprintk(KERN_INFO \"au8522_decoder creating new instance...\\n\");\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tprintk(KERN_INFO \"au8522_decoder attach existing instance.\\n\");\n\t\tbreak;\n\t}\n\n\tstate->config.demod_address = 0x8e >> 1;\n\tstate->i2c = client->adapter;\n\n\tsd = &state->sd;\n\tv4l2_i2c_subdev_init(sd, client, &au8522_ops);\n#if defined(CONFIG_MEDIA_CONTROLLER)\n\n\tstate->pads[AU8522_PAD_IF_INPUT].flags = MEDIA_PAD_FL_SINK;\n\tstate->pads[AU8522_PAD_IF_INPUT].sig_type = PAD_SIGNAL_ANALOG;\n\tstate->pads[AU8522_PAD_VID_OUT].flags = MEDIA_PAD_FL_SOURCE;\n\tstate->pads[AU8522_PAD_VID_OUT].sig_type = PAD_SIGNAL_DV;\n\tstate->pads[AU8522_PAD_AUDIO_OUT].flags = MEDIA_PAD_FL_SOURCE;\n\tstate->pads[AU8522_PAD_AUDIO_OUT].sig_type = PAD_SIGNAL_AUDIO;\n\tsd->entity.function = MEDIA_ENT_F_ATV_DECODER;\n\n\tret = media_entity_pads_init(&sd->entity, ARRAY_SIZE(state->pads),\n\t\t\t\tstate->pads);\n\tif (ret < 0) {\n\t\tv4l_info(client, \"failed to initialize media entity!\\n\");\n\t\treturn ret;\n\t}\n#endif\n\n\thdl = &state->hdl;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tv4l2_ctrl_new_std(hdl, &au8522_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 109);\n\tv4l2_ctrl_new_std(hdl, &au8522_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 255, 1,\n\t\t\tAU8522_TVDEC_CONTRAST_REG00BH_CVBS);\n\tv4l2_ctrl_new_std(hdl, &au8522_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &au8522_ctrl_ops,\n\t\t\tV4L2_CID_HUE, -32768, 32767, 1, 0);\n\tsd->ctrl_handler = hdl;\n\tif (hdl->error) {\n\t\tint err = hdl->error;\n\n\t\tv4l2_ctrl_handler_free(hdl);\n\t\tau8522_release_state(state);\n\t\treturn err;\n\t}\n\n\tstate->c = client;\n\tstate->std = V4L2_STD_NTSC_M;\n\tstate->vid_input = AU8522_COMPOSITE_CH1;\n\tstate->aud_input = AU8522_AUDIO_NONE;\n\tstate->id = 8522;\n\tstate->rev = 0;\n\n\t \n\tau8522_writereg(state, 0x106, 1);\n\n\treturn 0;\n}\n\nstatic void au8522_remove(struct i2c_client *client)\n{\n\tstruct v4l2_subdev *sd = i2c_get_clientdata(client);\n\tv4l2_device_unregister_subdev(sd);\n\tv4l2_ctrl_handler_free(sd->ctrl_handler);\n\tau8522_release_state(to_state(sd));\n}\n\nstatic const struct i2c_device_id au8522_id[] = {\n\t{\"au8522\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, au8522_id);\n\nstatic struct i2c_driver au8522_driver = {\n\t.driver = {\n\t\t.name\t= \"au8522\",\n\t},\n\t.probe\t\t= au8522_probe,\n\t.remove\t\t= au8522_remove,\n\t.id_table\t= au8522_id,\n};\n\nmodule_i2c_driver(au8522_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}