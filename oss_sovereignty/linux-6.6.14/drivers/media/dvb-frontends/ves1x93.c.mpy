{
  "module_name": "ves1x93.c",
  "hash_id": "56afcfffbff75dab5542f66021f9d23d92468e2455de4fc338184d1306e27457",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/ves1x93.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n\n#include <media/dvb_frontend.h>\n#include \"ves1x93.h\"\n\n\nstruct ves1x93_state {\n\tstruct i2c_adapter* i2c;\n\t \n\tconst struct ves1x93_config* config;\n\tstruct dvb_frontend frontend;\n\n\t \n\tenum fe_spectral_inversion inversion;\n\tu8 *init_1x93_tab;\n\tu8 *init_1x93_wtab;\n\tu8 tab_size;\n\tu8 demod_type;\n\tu32 frequency;\n};\n\nstatic int debug;\n#define dprintk\tif (debug) printk\n\n#define DEMOD_VES1893\t\t0\n#define DEMOD_VES1993\t\t1\n\nstatic u8 init_1893_tab [] = {\n\t0x01, 0xa4, 0x35, 0x80, 0x2a, 0x0b, 0x55, 0xc4,\n\t0x09, 0x69, 0x00, 0x86, 0x4c, 0x28, 0x7f, 0x00,\n\t0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x80, 0x00, 0x21, 0xb0, 0x14, 0x00, 0xdc, 0x00,\n\t0x81, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x55, 0x00, 0x00, 0x7f, 0x00\n};\n\nstatic u8 init_1993_tab [] = {\n\t0x00, 0x9c, 0x35, 0x80, 0x6a, 0x09, 0x72, 0x8c,\n\t0x09, 0x6b, 0x00, 0x00, 0x4c, 0x08, 0x00, 0x00,\n\t0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x80, 0x40, 0x21, 0xb0, 0x00, 0x00, 0x00, 0x10,\n\t0x81, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x55, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03,\n\t0x00, 0x00, 0x0e, 0x80, 0x00\n};\n\nstatic u8 init_1893_wtab[] =\n{\n\t1,1,1,1,1,1,1,1, 1,1,0,0,1,1,0,0,\n\t0,1,0,0,0,0,0,0, 1,0,1,1,0,0,0,1,\n\t1,1,1,0,0,0,0,0, 0,0,1,1,0,0,0,0,\n\t1,1,1,0,1,1\n};\n\nstatic u8 init_1993_wtab[] =\n{\n\t1,1,1,1,1,1,1,1, 1,1,0,0,1,1,0,0,\n\t0,1,0,0,0,0,0,0, 1,1,1,1,0,0,0,1,\n\t1,1,1,0,0,0,0,0, 0,0,1,1,0,0,0,0,\n\t1,1,1,0,1,1,1,1, 1,1,1,1,1\n};\n\nstatic int ves1x93_writereg (struct ves1x93_state* state, u8 reg, u8 data)\n{\n\tu8 buf [] = { 0x00, reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 3 };\n\tint err;\n\n\tif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\n\t\tdprintk (\"%s: writereg error (err == %i, reg == 0x%02x, data == 0x%02x)\\n\", __func__, err, reg, data);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 ves1x93_readreg (struct ves1x93_state* state, u8 reg)\n{\n\tint ret;\n\tu8 b0 [] = { 0x00, reg };\n\tu8 b1 [] = { 0 };\n\tstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 2 },\n\t\t\t   { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\n\n\tret = i2c_transfer (state->i2c, msg, 2);\n\n\tif (ret != 2) return ret;\n\n\treturn b1[0];\n}\n\nstatic int ves1x93_clr_bit (struct ves1x93_state* state)\n{\n\tmsleep(10);\n\tves1x93_writereg (state, 0, state->init_1x93_tab[0] & 0xfe);\n\tves1x93_writereg (state, 0, state->init_1x93_tab[0]);\n\tmsleep(50);\n\treturn 0;\n}\n\nstatic int ves1x93_set_inversion(struct ves1x93_state *state,\n\t\t\t\t enum fe_spectral_inversion inversion)\n{\n\tu8 val;\n\n\t \n\n\tswitch (inversion) {\n\tcase INVERSION_OFF:\n\t\tval = 0xc0;\n\t\tbreak;\n\tcase INVERSION_ON:\n\t\tval = 0x80;\n\t\tbreak;\n\tcase INVERSION_AUTO:\n\t\tval = 0x00;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ves1x93_writereg (state, 0x0c, (state->init_1x93_tab[0x0c] & 0x3f) | val);\n}\n\nstatic int ves1x93_set_fec(struct ves1x93_state *state, enum fe_code_rate fec)\n{\n\tif (fec == FEC_AUTO)\n\t\treturn ves1x93_writereg (state, 0x0d, 0x08);\n\telse if (fec < FEC_1_2 || fec > FEC_8_9)\n\t\treturn -EINVAL;\n\telse\n\t\treturn ves1x93_writereg (state, 0x0d, fec - FEC_1_2);\n}\n\nstatic enum fe_code_rate ves1x93_get_fec(struct ves1x93_state *state)\n{\n\treturn FEC_1_2 + ((ves1x93_readreg (state, 0x0d) >> 4) & 0x7);\n}\n\nstatic int ves1x93_set_symbolrate (struct ves1x93_state* state, u32 srate)\n{\n\tu32 BDR;\n\tu32 ratio;\n\tu8  ADCONF, FCONF, FNR, AGCR;\n\tu32 BDRI;\n\tu32 tmp;\n\tu32 FIN;\n\n\tdprintk(\"%s: srate == %d\\n\", __func__, (unsigned int) srate);\n\n\tif (srate > state->config->xin/2)\n\t\tsrate = state->config->xin/2;\n\n\tif (srate < 500000)\n\t\tsrate = 500000;\n\n#define MUL (1UL<<26)\n\n\tFIN = (state->config->xin + 6000) >> 4;\n\n\ttmp = srate << 6;\n\tratio = tmp / FIN;\n\n\ttmp = (tmp % FIN) << 8;\n\tratio = (ratio << 8) + tmp / FIN;\n\n\ttmp = (tmp % FIN) << 8;\n\tratio = (ratio << 8) + tmp / FIN;\n\n\tFNR = 0xff;\n\n\tif (ratio < MUL/3)\t     FNR = 0;\n\tif (ratio < (MUL*11)/50)     FNR = 1;\n\tif (ratio < MUL/6)\t     FNR = 2;\n\tif (ratio < MUL/9)\t     FNR = 3;\n\tif (ratio < MUL/12)\t     FNR = 4;\n\tif (ratio < (MUL*11)/200)    FNR = 5;\n\tif (ratio < MUL/24)\t     FNR = 6;\n\tif (ratio < (MUL*27)/1000)   FNR = 7;\n\tif (ratio < MUL/48)\t     FNR = 8;\n\tif (ratio < (MUL*137)/10000) FNR = 9;\n\n\tif (FNR == 0xff) {\n\t\tADCONF = 0x89;\n\t\tFCONF  = 0x80;\n\t\tFNR\t= 0;\n\t} else {\n\t\tADCONF = 0x81;\n\t\tFCONF  = 0x88 | (FNR >> 1) | ((FNR & 0x01) << 5);\n\t\t \n\t}\n\n\tBDR = (( (ratio << (FNR >> 1)) >> 4) + 1) >> 1;\n\tBDRI = ( ((FIN << 8) / ((srate << (FNR >> 1)) >> 2)) + 1) >> 1;\n\n\tdprintk(\"FNR= %d\\n\", FNR);\n\tdprintk(\"ratio= %08x\\n\", (unsigned int) ratio);\n\tdprintk(\"BDR= %08x\\n\", (unsigned int) BDR);\n\tdprintk(\"BDRI= %02x\\n\", (unsigned int) BDRI);\n\n\tif (BDRI > 0xff)\n\t\tBDRI = 0xff;\n\n\tves1x93_writereg (state, 0x06, 0xff & BDR);\n\tves1x93_writereg (state, 0x07, 0xff & (BDR >> 8));\n\tves1x93_writereg (state, 0x08, 0x0f & (BDR >> 16));\n\n\tves1x93_writereg (state, 0x09, BDRI);\n\tves1x93_writereg (state, 0x20, ADCONF);\n\tves1x93_writereg (state, 0x21, FCONF);\n\n\tAGCR = state->init_1x93_tab[0x05];\n\tif (state->config->invert_pwm)\n\t\tAGCR |= 0x20;\n\n\tif (srate < 6000000)\n\t\tAGCR |= 0x80;\n\telse\n\t\tAGCR &= ~0x80;\n\n\tves1x93_writereg (state, 0x05, AGCR);\n\n\t \n\tif (state->demod_type != DEMOD_VES1993)\n\t\tves1x93_clr_bit (state);\n\n\treturn 0;\n}\n\nstatic int ves1x93_init (struct dvb_frontend* fe)\n{\n\tstruct ves1x93_state* state = fe->demodulator_priv;\n\tint i;\n\tint val;\n\n\tdprintk(\"%s: init chip\\n\", __func__);\n\n\tfor (i = 0; i < state->tab_size; i++) {\n\t\tif (state->init_1x93_wtab[i]) {\n\t\t\tval = state->init_1x93_tab[i];\n\n\t\t\tif (state->config->invert_pwm && (i == 0x05)) val |= 0x20;  \n\t\t\tves1x93_writereg (state, i, val);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ves1x93_set_voltage(struct dvb_frontend *fe,\n\t\t\t       enum fe_sec_voltage voltage)\n{\n\tstruct ves1x93_state* state = fe->demodulator_priv;\n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_13:\n\t\treturn ves1x93_writereg (state, 0x1f, 0x20);\n\tcase SEC_VOLTAGE_18:\n\t\treturn ves1x93_writereg (state, 0x1f, 0x30);\n\tcase SEC_VOLTAGE_OFF:\n\t\treturn ves1x93_writereg (state, 0x1f, 0x00);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ves1x93_read_status(struct dvb_frontend *fe,\n\t\t\t       enum fe_status *status)\n{\n\tstruct ves1x93_state* state = fe->demodulator_priv;\n\n\tu8 sync = ves1x93_readreg (state, 0x0e);\n\n\t \n\tint maxtry = 10;  \n\twhile ((sync & 0x03) != 0x03 && (sync & 0x0c) && maxtry--) {\n\t\tmsleep(10);\n\t\tsync = ves1x93_readreg (state, 0x0e);\n\t}\n\n\t*status = 0;\n\n\tif (sync & 1)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (sync & 2)\n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (sync & 4)\n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (sync & 8)\n\t\t*status |= FE_HAS_SYNC;\n\n\tif ((sync & 0x1f) == 0x1f)\n\t\t*status |= FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int ves1x93_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct ves1x93_state* state = fe->demodulator_priv;\n\n\t*ber = ves1x93_readreg (state, 0x15);\n\t*ber |= (ves1x93_readreg (state, 0x16) << 8);\n\t*ber |= ((ves1x93_readreg (state, 0x17) & 0x0F) << 16);\n\t*ber *= 10;\n\n\treturn 0;\n}\n\nstatic int ves1x93_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\tstruct ves1x93_state* state = fe->demodulator_priv;\n\n\tu8 signal = ~ves1x93_readreg (state, 0x0b);\n\t*strength = (signal << 8) | signal;\n\n\treturn 0;\n}\n\nstatic int ves1x93_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct ves1x93_state* state = fe->demodulator_priv;\n\n\tu8 _snr = ~ves1x93_readreg (state, 0x1c);\n\t*snr = (_snr << 8) | _snr;\n\n\treturn 0;\n}\n\nstatic int ves1x93_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct ves1x93_state* state = fe->demodulator_priv;\n\n\t*ucblocks = ves1x93_readreg (state, 0x18) & 0x7f;\n\n\tif (*ucblocks == 0x7f)\n\t\t*ucblocks = 0xffffffff;    \n\n\tves1x93_writereg (state, 0x18, 0x00);   \n\tves1x93_writereg (state, 0x18, 0x80);   \n\n\treturn 0;\n}\n\nstatic int ves1x93_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct ves1x93_state* state = fe->demodulator_priv;\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\tves1x93_set_inversion (state, p->inversion);\n\tves1x93_set_fec(state, p->fec_inner);\n\tves1x93_set_symbolrate(state, p->symbol_rate);\n\tstate->inversion = p->inversion;\n\tstate->frequency = p->frequency;\n\n\treturn 0;\n}\n\nstatic int ves1x93_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct ves1x93_state* state = fe->demodulator_priv;\n\tint afc;\n\n\tafc = ((int)((char)(ves1x93_readreg (state, 0x0a) << 1)))/2;\n\tafc = (afc * (int)(p->symbol_rate/1000/8))/16;\n\n\tp->frequency = state->frequency - afc;\n\n\t \n\tif (state->inversion == INVERSION_AUTO)\n\t\tp->inversion = (ves1x93_readreg (state, 0x0f) & 2) ?\n\t\t\t\tINVERSION_OFF : INVERSION_ON;\n\tp->fec_inner = ves1x93_get_fec(state);\n\t \n\n\treturn 0;\n}\n\nstatic int ves1x93_sleep(struct dvb_frontend* fe)\n{\n\tstruct ves1x93_state* state = fe->demodulator_priv;\n\n\treturn ves1x93_writereg (state, 0x00, 0x08);\n}\n\nstatic void ves1x93_release(struct dvb_frontend* fe)\n{\n\tstruct ves1x93_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic int ves1x93_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\n{\n\tstruct ves1x93_state* state = fe->demodulator_priv;\n\n\tif (enable) {\n\t\treturn ves1x93_writereg(state, 0x00, 0x11);\n\t} else {\n\t\treturn ves1x93_writereg(state, 0x00, 0x01);\n\t}\n}\n\nstatic const struct dvb_frontend_ops ves1x93_ops;\n\nstruct dvb_frontend* ves1x93_attach(const struct ves1x93_config* config,\n\t\t\t\t    struct i2c_adapter* i2c)\n{\n\tstruct ves1x93_state* state = NULL;\n\tu8 identity;\n\n\t \n\tstate = kzalloc(sizeof(struct ves1x93_state), GFP_KERNEL);\n\tif (state == NULL) goto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->inversion = INVERSION_OFF;\n\n\t \n\tidentity = ves1x93_readreg(state, 0x1e);\n\tswitch (identity) {\n\tcase 0xdc:  \n\t\tprintk(\"ves1x93: Detected ves1893a rev1\\n\");\n\t\tstate->demod_type = DEMOD_VES1893;\n\t\tstate->init_1x93_tab = init_1893_tab;\n\t\tstate->init_1x93_wtab = init_1893_wtab;\n\t\tstate->tab_size = sizeof(init_1893_tab);\n\t\tbreak;\n\n\tcase 0xdd:  \n\t\tprintk(\"ves1x93: Detected ves1893a rev2\\n\");\n\t\tstate->demod_type = DEMOD_VES1893;\n\t\tstate->init_1x93_tab = init_1893_tab;\n\t\tstate->init_1x93_wtab = init_1893_wtab;\n\t\tstate->tab_size = sizeof(init_1893_tab);\n\t\tbreak;\n\n\tcase 0xde:  \n\t\tprintk(\"ves1x93: Detected ves1993\\n\");\n\t\tstate->demod_type = DEMOD_VES1993;\n\t\tstate->init_1x93_tab = init_1993_tab;\n\t\tstate->init_1x93_wtab = init_1993_wtab;\n\t\tstate->tab_size = sizeof(init_1993_tab);\n\t\tbreak;\n\n\tdefault:\n\t\tgoto error;\n\t}\n\n\t \n\tmemcpy(&state->frontend.ops, &ves1x93_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops ves1x93_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name\t\t\t= \"VLSI VES1x93 DVB-S\",\n\t\t.frequency_min_hz\t=   950 * MHz,\n\t\t.frequency_max_hz\t=  2150 * MHz,\n\t\t.frequency_stepsize_hz\t=   125 * kHz,\n\t\t.frequency_tolerance_hz\t= 29500 * kHz,\n\t\t.symbol_rate_min\t= 1000000,\n\t\t.symbol_rate_max\t= 45000000,\n\t \n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK\n\t},\n\n\t.release = ves1x93_release,\n\n\t.init = ves1x93_init,\n\t.sleep = ves1x93_sleep,\n\t.i2c_gate_ctrl = ves1x93_i2c_gate_ctrl,\n\n\t.set_frontend = ves1x93_set_frontend,\n\t.get_frontend = ves1x93_get_frontend,\n\n\t.read_status = ves1x93_read_status,\n\t.read_ber = ves1x93_read_ber,\n\t.read_signal_strength = ves1x93_read_signal_strength,\n\t.read_snr = ves1x93_read_snr,\n\t.read_ucblocks = ves1x93_read_ucblocks,\n\n\t.set_voltage = ves1x93_set_voltage,\n};\n\nmodule_param(debug, int, 0644);\n\nMODULE_DESCRIPTION(\"VLSI VES1x93 DVB-S Demodulator driver\");\nMODULE_AUTHOR(\"Ralph Metzler\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(ves1x93_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}