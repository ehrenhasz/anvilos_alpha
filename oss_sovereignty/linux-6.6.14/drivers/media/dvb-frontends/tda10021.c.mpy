{
  "module_name": "tda10021.c",
  "hash_id": "d7204ac78aa3f2196e08d7e975cd2013a0b8c71855b960e9ab3b32cb7f6e75f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tda10021.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"tda1002x.h\"\n\n\nstruct tda10021_state {\n\tstruct i2c_adapter* i2c;\n\t \n\tconst struct tda1002x_config* config;\n\tstruct dvb_frontend frontend;\n\n\tu8 pwm;\n\tu8 reg0;\n};\n\n\n#if 0\n#define dprintk(x...) printk(x)\n#else\n#define dprintk(x...)\n#endif\n\nstatic int verbose;\n\n#define XIN 57840000UL\n\n#define FIN (XIN >> 4)\n\nstatic int tda10021_inittab_size = 0x40;\nstatic u8 tda10021_inittab[0x40]=\n{\n\t0x73, 0x6a, 0x23, 0x0a, 0x02, 0x37, 0x77, 0x1a,\n\t0x37, 0x6a, 0x17, 0x8a, 0x1e, 0x86, 0x43, 0x40,\n\t0xb8, 0x3f, 0xa1, 0x00, 0xcd, 0x01, 0x00, 0xff,\n\t0x11, 0x00, 0x7c, 0x31, 0x30, 0x20, 0x00, 0x00,\n\t0x02, 0x00, 0x00, 0x7d, 0x00, 0x00, 0x00, 0x00,\n\t0x07, 0x00, 0x33, 0x11, 0x0d, 0x95, 0x08, 0x58,\n\t0x00, 0x00, 0x80, 0x00, 0x80, 0xff, 0x00, 0x00,\n\t0x04, 0x2d, 0x2f, 0xff, 0x00, 0x00, 0x00, 0x00,\n};\n\nstatic int _tda10021_writereg (struct tda10021_state* state, u8 reg, u8 data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\n\tint ret;\n\n\tret = i2c_transfer (state->i2c, &msg, 1);\n\tif (ret != 1)\n\t\tprintk(\"DVB: TDA10021(%d): %s, writereg error (reg == 0x%02x, val == 0x%02x, ret == %i)\\n\",\n\t\t\tstate->frontend.dvb->num, __func__, reg, data, ret);\n\n\tmsleep(10);\n\treturn (ret != 1) ? -EREMOTEIO : 0;\n}\n\nstatic u8 tda10021_readreg (struct tda10021_state* state, u8 reg)\n{\n\tu8 b0 [] = { reg };\n\tu8 b1 [] = { 0 };\n\tstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },\n\t\t\t\t  { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\n\tint ret;\n\n\tret = i2c_transfer (state->i2c, msg, 2);\n\t\n\tif (ret != 2 && reg != 0x1a)\n\t\tprintk(\"DVB: TDA10021: %s: readreg error (ret == %i)\\n\",\n\t\t\t\t__func__, ret);\n\treturn b1[0];\n}\n\n\nstatic int lock_tuner(struct tda10021_state* state)\n{\n\tu8 buf[2] = { 0x0f, tda10021_inittab[0x0f] | 0x80 };\n\tstruct i2c_msg msg = {.addr=state->config->demod_address, .flags=0, .buf=buf, .len=2};\n\n\tif(i2c_transfer(state->i2c, &msg, 1) != 1)\n\t{\n\t\tprintk(\"tda10021: lock tuner fails\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\n\nstatic int unlock_tuner(struct tda10021_state* state)\n{\n\tu8 buf[2] = { 0x0f, tda10021_inittab[0x0f] & 0x7f };\n\tstruct i2c_msg msg_post={.addr=state->config->demod_address, .flags=0, .buf=buf, .len=2};\n\n\tif(i2c_transfer(state->i2c, &msg_post, 1) != 1)\n\t{\n\t\tprintk(\"tda10021: unlock tuner fails\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int tda10021_setup_reg0(struct tda10021_state *state, u8 reg0,\n\t\t\t       enum fe_spectral_inversion inversion)\n{\n\treg0 |= state->reg0 & 0x63;\n\n\tif ((INVERSION_ON == inversion) ^ (state->config->invert == 0))\n\t\treg0 &= ~0x20;\n\telse\n\t\treg0 |= 0x20;\n\n\t_tda10021_writereg (state, 0x00, reg0 & 0xfe);\n\t_tda10021_writereg (state, 0x00, reg0 | 0x01);\n\n\tstate->reg0 = reg0;\n\treturn 0;\n}\n\nstatic int tda10021_set_symbolrate (struct tda10021_state* state, u32 symbolrate)\n{\n\ts32 BDR;\n\ts32 BDRI;\n\ts16 SFIL = 0;\n\tu16 NDEC = 0;\n\tu32 tmp, ratio;\n\n\tif (symbolrate > XIN / 2)\n\t\tsymbolrate = XIN / 2;\n\telse if (symbolrate < 500000)\n\t\tsymbolrate = 500000;\n\n\tif (symbolrate < XIN / 16)\n\t\tNDEC = 1;\n\tif (symbolrate < XIN / 32)\n\t\tNDEC = 2;\n\tif (symbolrate < XIN / 64)\n\t\tNDEC = 3;\n\n\tif (symbolrate < XIN * 10 / 123)\n\t\tSFIL = 1;\n\tif (symbolrate < XIN * 10 / 160)\n\t\tSFIL = 0;\n\tif (symbolrate < XIN * 10 / 246)\n\t\tSFIL = 1;\n\tif (symbolrate < XIN * 10 / 320)\n\t\tSFIL = 0;\n\tif (symbolrate < XIN * 10 / 492)\n\t\tSFIL = 1;\n\tif (symbolrate < XIN * 10 / 640)\n\t\tSFIL = 0;\n\tif (symbolrate < XIN * 10 / 984)\n\t\tSFIL = 1;\n\n\tsymbolrate <<= NDEC;\n\tratio = (symbolrate << 4) / FIN;\n\ttmp =  ((symbolrate << 4) % FIN) << 8;\n\tratio = (ratio << 8) + tmp / FIN;\n\ttmp = (tmp % FIN) << 8;\n\tratio = (ratio << 8) + DIV_ROUND_CLOSEST(tmp, FIN);\n\n\tBDR = ratio;\n\tBDRI = (((XIN << 5) / symbolrate) + 1) / 2;\n\n\tif (BDRI > 0xFF)\n\t\tBDRI = 0xFF;\n\n\tSFIL = (SFIL << 4) | tda10021_inittab[0x0E];\n\n\tNDEC = (NDEC << 6) | tda10021_inittab[0x03];\n\n\t_tda10021_writereg (state, 0x03, NDEC);\n\t_tda10021_writereg (state, 0x0a, BDR&0xff);\n\t_tda10021_writereg (state, 0x0b, (BDR>> 8)&0xff);\n\t_tda10021_writereg (state, 0x0c, (BDR>>16)&0x3f);\n\n\t_tda10021_writereg (state, 0x0d, BDRI);\n\t_tda10021_writereg (state, 0x0e, SFIL);\n\n\treturn 0;\n}\n\nstatic int tda10021_init (struct dvb_frontend *fe)\n{\n\tstruct tda10021_state* state = fe->demodulator_priv;\n\tint i;\n\n\tdprintk(\"DVB: TDA10021(%d): init chip\\n\", fe->adapter->num);\n\n\t\n\n\tfor (i=0; i<tda10021_inittab_size; i++)\n\t\t_tda10021_writereg (state, i, tda10021_inittab[i]);\n\n\t_tda10021_writereg (state, 0x34, state->pwm);\n\n\t\n\t\n\t\n\t\n\t\n\n\t\n\t_tda10021_writereg(state, 0x2a, tda10021_inittab[0x2a] & 0xef);\n\treturn 0;\n}\n\nstruct qam_params {\n\tu8 conf, agcref, lthr, mseth, aref;\n};\n\nstatic int tda10021_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 delsys  = c->delivery_system;\n\tunsigned qam = c->modulation;\n\tbool is_annex_c;\n\tu32 reg0x3d;\n\tstruct tda10021_state* state = fe->demodulator_priv;\n\tstatic const struct qam_params qam_params[] = {\n\t\t \n\t\t[QPSK]\t   = { 0x14, 0x78,   0x78, 0x8c,  0x96 },\n\t\t[QAM_16]   = { 0x00, 0x8c,   0x87, 0xa2,  0x91 },\n\t\t[QAM_32]   = { 0x04, 0x8c,   0x64, 0x74,  0x96 },\n\t\t[QAM_64]   = { 0x08, 0x6a,   0x46, 0x43,  0x6a },\n\t\t[QAM_128]  = { 0x0c, 0x78,   0x36, 0x34,  0x7e },\n\t\t[QAM_256]  = { 0x10, 0x5c,   0x26, 0x23,  0x6b },\n\t};\n\n\tswitch (delsys) {\n\tcase SYS_DVBC_ANNEX_A:\n\t\tis_annex_c = false;\n\t\tbreak;\n\tcase SYS_DVBC_ANNEX_C:\n\t\tis_annex_c = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (qam) {\n\tcase QPSK:\n\tcase QAM_16:\n\tcase QAM_32:\n\tcase QAM_64:\n\tcase QAM_128:\n\tcase QAM_256:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (c->inversion != INVERSION_ON && c->inversion != INVERSION_OFF)\n\t\treturn -EINVAL;\n\n\t \n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\ttda10021_set_symbolrate(state, c->symbol_rate);\n\t_tda10021_writereg(state, 0x34, state->pwm);\n\n\t_tda10021_writereg(state, 0x01, qam_params[qam].agcref);\n\t_tda10021_writereg(state, 0x05, qam_params[qam].lthr);\n\t_tda10021_writereg(state, 0x08, qam_params[qam].mseth);\n\t_tda10021_writereg(state, 0x09, qam_params[qam].aref);\n\n\t \n\treg0x3d = tda10021_readreg (state, 0x3d);\n\tif (is_annex_c)\n\t\t_tda10021_writereg (state, 0x3d, 0x01 | reg0x3d);\n\telse\n\t\t_tda10021_writereg (state, 0x3d, 0xfe & reg0x3d);\n\ttda10021_setup_reg0(state, qam_params[qam].conf, c->inversion);\n\n\treturn 0;\n}\n\nstatic int tda10021_read_status(struct dvb_frontend *fe,\n\t\t\t\tenum fe_status *status)\n{\n\tstruct tda10021_state* state = fe->demodulator_priv;\n\tint sync;\n\n\t*status = 0;\n\t\n\t\n\t\n\t\n\t\n\tsync = tda10021_readreg (state, 0x11);\n\n\tif (sync & 2)\n\t\t*status |= FE_HAS_SIGNAL|FE_HAS_CARRIER;\n\n\tif (sync & 4)\n\t\t*status |= FE_HAS_SYNC|FE_HAS_VITERBI;\n\n\tif (sync & 8)\n\t\t*status |= FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int tda10021_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct tda10021_state* state = fe->demodulator_priv;\n\n\tu32 _ber = tda10021_readreg(state, 0x14) |\n\t\t(tda10021_readreg(state, 0x15) << 8) |\n\t\t((tda10021_readreg(state, 0x16) & 0x0f) << 16);\n\t_tda10021_writereg(state, 0x10, (tda10021_readreg(state, 0x10) & ~0xc0)\n\t\t\t\t\t| (tda10021_inittab[0x10] & 0xc0));\n\t*ber = 10 * _ber;\n\n\treturn 0;\n}\n\nstatic int tda10021_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\tstruct tda10021_state* state = fe->demodulator_priv;\n\n\tu8 config = tda10021_readreg(state, 0x02);\n\tu8 gain = tda10021_readreg(state, 0x17);\n\tif (config & 0x02)\n\t\t \n\t\tgain = ~gain;\n\t*strength = (gain << 8) | gain;\n\n\treturn 0;\n}\n\nstatic int tda10021_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct tda10021_state* state = fe->demodulator_priv;\n\n\tu8 quality = ~tda10021_readreg(state, 0x18);\n\t*snr = (quality << 8) | quality;\n\n\treturn 0;\n}\n\nstatic int tda10021_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct tda10021_state* state = fe->demodulator_priv;\n\n\t*ucblocks = tda10021_readreg (state, 0x13) & 0x7f;\n\tif (*ucblocks == 0x7f)\n\t\t*ucblocks = 0xffffffff;\n\n\t \n\t_tda10021_writereg (state, 0x10, tda10021_inittab[0x10] & 0xdf);\n\t_tda10021_writereg (state, 0x10, tda10021_inittab[0x10]);\n\n\treturn 0;\n}\n\nstatic int tda10021_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t struct dtv_frontend_properties *p)\n{\n\tstruct tda10021_state* state = fe->demodulator_priv;\n\tint sync;\n\ts8 afc = 0;\n\n\tsync = tda10021_readreg(state, 0x11);\n\tafc = tda10021_readreg(state, 0x19);\n\tif (verbose) {\n\t\t \n\t\tprintk(sync & 2 ? \"DVB: TDA10021(%d): AFC (%d) %dHz\\n\" :\n\t\t\t\t  \"DVB: TDA10021(%d): [AFC (%d) %dHz]\\n\",\n\t\t\tstate->frontend.dvb->num, afc,\n\t\t       -((s32)p->symbol_rate * afc) >> 10);\n\t}\n\n\tp->inversion = ((state->reg0 & 0x20) == 0x20) ^ (state->config->invert != 0) ? INVERSION_ON : INVERSION_OFF;\n\tp->modulation = ((state->reg0 >> 2) & 7) + QAM_16;\n\n\tp->fec_inner = FEC_NONE;\n\tp->frequency = ((p->frequency + 31250) / 62500) * 62500;\n\n\tif (sync & 2)\n\t\tp->frequency -= ((s32)p->symbol_rate * afc) >> 10;\n\n\treturn 0;\n}\n\nstatic int tda10021_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\n{\n\tstruct tda10021_state* state = fe->demodulator_priv;\n\n\tif (enable) {\n\t\tlock_tuner(state);\n\t} else {\n\t\tunlock_tuner(state);\n\t}\n\treturn 0;\n}\n\nstatic int tda10021_sleep(struct dvb_frontend* fe)\n{\n\tstruct tda10021_state* state = fe->demodulator_priv;\n\n\t_tda10021_writereg (state, 0x1b, 0x02);   \n\t_tda10021_writereg (state, 0x00, 0x80);   \n\n\treturn 0;\n}\n\nstatic void tda10021_release(struct dvb_frontend* fe)\n{\n\tstruct tda10021_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops tda10021_ops;\n\nstruct dvb_frontend* tda10021_attach(const struct tda1002x_config* config,\n\t\t\t\t     struct i2c_adapter* i2c,\n\t\t\t\t     u8 pwm)\n{\n\tstruct tda10021_state* state = NULL;\n\tu8 id;\n\n\t \n\tstate = kzalloc(sizeof(struct tda10021_state), GFP_KERNEL);\n\tif (state == NULL) goto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->pwm = pwm;\n\tstate->reg0 = tda10021_inittab[0];\n\n\t \n\tid = tda10021_readreg(state, 0x1a);\n\tif ((id & 0xf0) != 0x70) goto error;\n\n\t \n\tif (id == 0x7d)\n\t\tgoto error;\n\n\tprintk(\"TDA10021: i2c-addr = 0x%02x, id = 0x%02x\\n\",\n\t       state->config->demod_address, id);\n\n\t \n\tmemcpy(&state->frontend.ops, &tda10021_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops tda10021_ops = {\n\t.delsys = { SYS_DVBC_ANNEX_A, SYS_DVBC_ANNEX_C },\n\t.info = {\n\t\t.name = \"Philips TDA10021 DVB-C\",\n\t\t.frequency_min_hz =  47 * MHz,\n\t\t.frequency_max_hz = 862 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.symbol_rate_min = (XIN / 2) / 64,      \n\t\t.symbol_rate_max = (XIN / 2) / 4,       \n\t#if 0\n\t\t.frequency_tolerance = ???,\n\t\t.symbol_rate_tolerance = ???,      \n\t#endif\n\t\t.caps = 0x400 | \n\t\t\tFE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_128 | FE_CAN_QAM_256 |\n\t\t\tFE_CAN_FEC_AUTO\n\t},\n\n\t.release = tda10021_release,\n\n\t.init = tda10021_init,\n\t.sleep = tda10021_sleep,\n\t.i2c_gate_ctrl = tda10021_i2c_gate_ctrl,\n\n\t.set_frontend = tda10021_set_parameters,\n\t.get_frontend = tda10021_get_frontend,\n\n\t.read_status = tda10021_read_status,\n\t.read_ber = tda10021_read_ber,\n\t.read_signal_strength = tda10021_read_signal_strength,\n\t.read_snr = tda10021_read_snr,\n\t.read_ucblocks = tda10021_read_ucblocks,\n};\n\nmodule_param(verbose, int, 0644);\nMODULE_PARM_DESC(verbose, \"print AFC offset after tuning for debugging the PWM setting\");\n\nMODULE_DESCRIPTION(\"Philips TDA10021 DVB-C demodulator driver\");\nMODULE_AUTHOR(\"Ralph Metzler, Holger Waechtler, Markus Schulz\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(tda10021_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}