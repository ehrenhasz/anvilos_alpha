{
  "module_name": "sp2.c",
  "hash_id": "40d05f6760c2d35ec07dd6ce6674cae20c80b7571dc8942c770eff0f9f954900",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/sp2.c",
  "human_readable_source": "\n \n\n#include \"sp2_priv.h\"\n\nstatic int sp2_read_i2c(struct sp2 *s, u8 reg, u8 *buf, int len)\n{\n\tint ret;\n\tstruct i2c_client *client = s->client;\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = &reg,\n\t\t\t.len = 1\n\t\t}, {\n\t\t\t.addr = client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.buf = buf,\n\t\t\t.len = len\n\t\t}\n\t};\n\n\tret = i2c_transfer(adap, msg, 2);\n\n\tif (ret != 2) {\n\t\tdev_err(&client->dev, \"i2c read error, reg = 0x%02x, status = %d\\n\",\n\t\t\t\treg, ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&s->client->dev, \"addr=0x%04x, reg = 0x%02x, data = %02x\\n\",\n\t\t\t\tclient->addr, reg, buf[0]);\n\n\treturn 0;\n}\n\nstatic int sp2_write_i2c(struct sp2 *s, u8 reg, u8 *buf, int len)\n{\n\tint ret;\n\tu8 buffer[35];\n\tstruct i2c_client *client = s->client;\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct i2c_msg msg = {\n\t\t.addr = client->addr,\n\t\t.flags = 0,\n\t\t.buf = &buffer[0],\n\t\t.len = len + 1\n\t};\n\n\tif ((len + 1) > sizeof(buffer)) {\n\t\tdev_err(&client->dev, \"i2c wr reg=%02x: len=%d is too big!\\n\",\n\t\t\t\treg, len);\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer[0] = reg;\n\tmemcpy(&buffer[1], buf, len);\n\n\tret = i2c_transfer(adap, &msg, 1);\n\n\tif (ret != 1) {\n\t\tdev_err(&client->dev, \"i2c write error, reg = 0x%02x, status = %d\\n\",\n\t\t\t\treg, ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&s->client->dev, \"addr=0x%04x, reg = 0x%02x, data = %*ph\\n\",\n\t\t\t\tclient->addr, reg, len, buf);\n\n\treturn 0;\n}\n\nstatic int sp2_ci_op_cam(struct dvb_ca_en50221 *en50221, int slot, u8 acs,\n\t\t\tu8 read, int addr, u8 data)\n{\n\tstruct sp2 *s = en50221->data;\n\tu8 store;\n\tint mem, ret;\n\tint (*ci_op_cam)(void*, u8, int, u8, int*) = s->ci_control;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (s->module_access_type != acs) {\n\t\tret = sp2_read_i2c(s, 0x00, &store, 1);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstore &= ~(SP2_MOD_CTL_ACS1 | SP2_MOD_CTL_ACS0);\n\t\tstore |= acs;\n\n\t\tret = sp2_write_i2c(s, 0x00, &store, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\ts->module_access_type = acs;\n\n\t \n\tif (ci_op_cam) {\n\t\tret = ci_op_cam(s->priv, read, addr, data, &mem);\n\t} else {\n\t\tdev_err(&s->client->dev, \"callback not defined\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(&s->client->dev, \"%s: slot=%d, addr=0x%04x, %s, data=%x\",\n\t\t\t(read) ? \"read\" : \"write\", slot, addr,\n\t\t\t(acs == SP2_CI_ATTR_ACS) ? \"attr\" : \"io\",\n\t\t\t(read) ? mem : data);\n\n\tif (read)\n\t\treturn mem;\n\telse\n\t\treturn 0;\n\n}\n\nint sp2_ci_read_attribute_mem(struct dvb_ca_en50221 *en50221,\n\t\t\t\tint slot, int addr)\n{\n\treturn sp2_ci_op_cam(en50221, slot, SP2_CI_ATTR_ACS,\n\t\t\tSP2_CI_RD, addr, 0);\n}\n\nint sp2_ci_write_attribute_mem(struct dvb_ca_en50221 *en50221,\n\t\t\t\tint slot, int addr, u8 data)\n{\n\treturn sp2_ci_op_cam(en50221, slot, SP2_CI_ATTR_ACS,\n\t\t\tSP2_CI_WR, addr, data);\n}\n\nint sp2_ci_read_cam_control(struct dvb_ca_en50221 *en50221,\n\t\t\t\tint slot, u8 addr)\n{\n\treturn sp2_ci_op_cam(en50221, slot, SP2_CI_IO_ACS,\n\t\t\tSP2_CI_RD, addr, 0);\n}\n\nint sp2_ci_write_cam_control(struct dvb_ca_en50221 *en50221,\n\t\t\t\tint slot, u8 addr, u8 data)\n{\n\treturn sp2_ci_op_cam(en50221, slot, SP2_CI_IO_ACS,\n\t\t\tSP2_CI_WR, addr, data);\n}\n\nint sp2_ci_slot_reset(struct dvb_ca_en50221 *en50221, int slot)\n{\n\tstruct sp2 *s = en50221->data;\n\tu8 buf;\n\tint ret;\n\n\tdev_dbg(&s->client->dev, \"slot: %d\\n\", slot);\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\t \n\tbuf = SP2_MOD_CTL_RST;\n\tret = sp2_write_i2c(s, 0x00, &buf, 1);\n\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(500, 600);\n\n\t \n\tbuf = 0x00;\n\tret = sp2_write_i2c(s, 0x00, &buf, 1);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(1000);\n\n\treturn 0;\n}\n\nint sp2_ci_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)\n{\n\tstruct sp2 *s = en50221->data;\n\n\tdev_dbg(&s->client->dev, \"slot:%d\\n\", slot);\n\n\t \n\treturn 0;\n}\n\nint sp2_ci_slot_ts_enable(struct dvb_ca_en50221 *en50221, int slot)\n{\n\tstruct sp2 *s = en50221->data;\n\tu8 buf;\n\n\tdev_dbg(&s->client->dev, \"slot:%d\\n\", slot);\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tsp2_read_i2c(s, 0x00, &buf, 1);\n\n\t \n\tbuf |= (SP2_MOD_CTL_TSOEN | SP2_MOD_CTL_TSIEN);\n\treturn sp2_write_i2c(s, 0, &buf, 1);\n}\n\nint sp2_ci_poll_slot_status(struct dvb_ca_en50221 *en50221,\n\t\t\t\tint slot, int open)\n{\n\tstruct sp2 *s = en50221->data;\n\tu8 buf[2];\n\tint ret;\n\n\tdev_dbg(&s->client->dev, \"slot:%d open:%d\\n\", slot, open);\n\n\t \n\tif (time_after(jiffies, s->next_status_checked_time)) {\n\t\tret = sp2_read_i2c(s, 0x00, buf, 1);\n\t\ts->next_status_checked_time = jiffies +\tmsecs_to_jiffies(1000);\n\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tif (buf[0] & SP2_MOD_CTL_DET)\n\t\t\ts->status = DVB_CA_EN50221_POLL_CAM_PRESENT |\n\t\t\t\t\tDVB_CA_EN50221_POLL_CAM_READY;\n\t\telse\n\t\t\ts->status = 0;\n\t}\n\n\treturn s->status;\n}\n\nstatic int sp2_init(struct sp2 *s)\n{\n\tint ret = 0;\n\tu8 buf;\n\tu8 cimax_init[34] = {\n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x44,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x44,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x02,  \n\t\t0x01,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x05,  \n\t\t0x00,  \n\t\t0x04,  \n\t\t0x00,  \n\t\t0x22,  \n\t\t0x00,  \n\t};\n\n\tdev_dbg(&s->client->dev, \"\\n\");\n\n\ts->ca.owner = THIS_MODULE;\n\ts->ca.read_attribute_mem = sp2_ci_read_attribute_mem;\n\ts->ca.write_attribute_mem = sp2_ci_write_attribute_mem;\n\ts->ca.read_cam_control = sp2_ci_read_cam_control;\n\ts->ca.write_cam_control = sp2_ci_write_cam_control;\n\ts->ca.slot_reset = sp2_ci_slot_reset;\n\ts->ca.slot_shutdown = sp2_ci_slot_shutdown;\n\ts->ca.slot_ts_enable = sp2_ci_slot_ts_enable;\n\ts->ca.poll_slot_status = sp2_ci_poll_slot_status;\n\ts->ca.data = s;\n\ts->module_access_type = 0;\n\n\t \n\tret = sp2_write_i2c(s, 0x00, &cimax_init[0], 34);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tbuf = 1;\n\tret = sp2_write_i2c(s, 0x1f, &buf, 1);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = sp2_write_i2c(s, 0x18, &buf, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tret = dvb_ca_en50221_init(s->dvb_adap, &s->ca, 0, 1);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdev_dbg(&s->client->dev, \"init failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int sp2_exit(struct i2c_client *client)\n{\n\tstruct sp2 *s;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tif (!client)\n\t\treturn 0;\n\n\ts = i2c_get_clientdata(client);\n\tif (!s)\n\t\treturn 0;\n\n\tif (!s->ca.data)\n\t\treturn 0;\n\n\tdvb_ca_en50221_release(&s->ca);\n\n\treturn 0;\n}\n\nstatic int sp2_probe(struct i2c_client *client)\n{\n\tstruct sp2_config *cfg = client->dev.platform_data;\n\tstruct sp2 *s;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\ts = kzalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\ts->client = client;\n\ts->dvb_adap = cfg->dvb_adap;\n\ts->priv = cfg->priv;\n\ts->ci_control = cfg->ci_control;\n\n\ti2c_set_clientdata(client, s);\n\n\tret = sp2_init(s);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_info(&s->client->dev, \"CIMaX SP2 successfully attached\\n\");\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"init failed=%d\\n\", ret);\n\tkfree(s);\n\n\treturn ret;\n}\n\nstatic void sp2_remove(struct i2c_client *client)\n{\n\tstruct sp2 *s = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\tsp2_exit(client);\n\tkfree(s);\n}\n\nstatic const struct i2c_device_id sp2_id[] = {\n\t{\"sp2\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, sp2_id);\n\nstatic struct i2c_driver sp2_driver = {\n\t.driver = {\n\t\t.name\t= \"sp2\",\n\t},\n\t.probe\t\t= sp2_probe,\n\t.remove\t\t= sp2_remove,\n\t.id_table\t= sp2_id,\n};\n\nmodule_i2c_driver(sp2_driver);\n\nMODULE_DESCRIPTION(\"CIMaX SP2/HF CI driver\");\nMODULE_AUTHOR(\"Olli Salonen <olli.salonen@iki.fi>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}