{
  "module_name": "lgdt330x.c",
  "hash_id": "4ca793fa4d0b89af1b38b8ce15f53e5e67fa279524e9e46c39fdab0c765f0e19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/lgdt330x.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <asm/byteorder.h>\n\n#include <media/dvb_frontend.h>\n#include <linux/int_log.h>\n#include \"lgdt330x_priv.h\"\n#include \"lgdt330x.h\"\n\n \n \n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off lgdt330x frontend debugging (default:off).\");\n\n#define dprintk(state, fmt, arg...) do {\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tdev_printk(KERN_DEBUG, &state->client->dev, fmt, ##arg);\\\n} while (0)\n\nstruct lgdt330x_state {\n\tstruct i2c_client *client;\n\n\t \n\tstruct lgdt330x_config config;\n\n\tstruct dvb_frontend frontend;\n\n\t \n\tenum fe_modulation current_modulation;\n\tu32 snr;\t \n\tu16 ucblocks;\n\tunsigned long last_stats_time;\n\n\t \n\tu32 current_frequency;\n};\n\nstatic int i2c_write_demod_bytes(struct lgdt330x_state *state,\n\t\t\t\t const u8 *buf,  \n\t\t\t\t int len   )\n{\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < len - 1; i += 2) {\n\t\terr = i2c_master_send(state->client, buf, 2);\n\t\tif (err != 2) {\n\t\t\tdev_warn(&state->client->dev,\n\t\t\t\t \"%s: error (addr %02x <- %02x, err = %i)\\n\",\n\t\t\t\t__func__, buf[0], buf[1], err);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\telse\n\t\t\t\treturn -EREMOTEIO;\n\t\t}\n\t\tbuf += 2;\n\t}\n\treturn 0;\n}\n\n \nstatic int i2c_read_demod_bytes(struct lgdt330x_state *state,\n\t\t\t\tenum I2C_REG reg, u8 *buf, int len)\n{\n\tu8 wr[] = { reg };\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = state->client->addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = wr,\n\t\t\t.len = 1\n\t\t}, {\n\t\t\t.addr = state->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = buf,\n\t\t\t.len = len\n\t\t},\n\t};\n\tint ret;\n\n\tret = i2c_transfer(state->client->adapter, msg, 2);\n\tif (ret != 2) {\n\t\tdev_warn(&state->client->dev,\n\t\t\t \"%s: addr 0x%02x select 0x%02x error (ret == %i)\\n\",\n\t\t\t __func__, state->client->addr, reg, ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t} else {\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n \nstatic int lgdt3302_sw_reset(struct lgdt330x_state *state)\n{\n\tu8 ret;\n\tu8 reset[] = {\n\t\tIRQ_MASK,\n\t\t \n\t\t0x00\n\t};\n\n\tret = i2c_write_demod_bytes(state,\n\t\t\t\t    reset, sizeof(reset));\n\tif (ret == 0) {\n\t\t \n\t\treset[1] = 0x7f;\n\t\tret = i2c_write_demod_bytes(state,\n\t\t\t\t\t    reset, sizeof(reset));\n\t}\n\treturn ret;\n}\n\nstatic int lgdt3303_sw_reset(struct lgdt330x_state *state)\n{\n\tu8 ret;\n\tu8 reset[] = {\n\t\t0x02,\n\t\t0x00  \n\t};\n\n\tret = i2c_write_demod_bytes(state,\n\t\t\t\t    reset, sizeof(reset));\n\tif (ret == 0) {\n\t\t \n\t\treset[1] = 0x01;\n\t\tret = i2c_write_demod_bytes(state,\n\t\t\t\t\t    reset, sizeof(reset));\n\t}\n\treturn ret;\n}\n\nstatic int lgdt330x_sw_reset(struct lgdt330x_state *state)\n{\n\tswitch (state->config.demod_chip) {\n\tcase LGDT3302:\n\t\treturn lgdt3302_sw_reset(state);\n\tcase LGDT3303:\n\t\treturn lgdt3303_sw_reset(state);\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic int lgdt330x_init(struct dvb_frontend *fe)\n{\n\tstruct lgdt330x_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tchar  *chip_name;\n\tint    err;\n\t \n\tstatic const u8 lgdt3302_init_data[] = {\n\t\t \n\t\t \n\t\tVSB_CARRIER_FREQ0, 0x00,\n\t\tVSB_CARRIER_FREQ1, 0x87,\n\t\tVSB_CARRIER_FREQ2, 0x8e,\n\t\tVSB_CARRIER_FREQ3, 0x01,\n\t\t \n\t\tDEMUX_CONTROL, 0xfb,\n\t\t \n\t\tAGC_RF_BANDWIDTH0, 0x40,\n\t\tAGC_RF_BANDWIDTH1, 0x93,\n\t\tAGC_RF_BANDWIDTH2, 0x00,\n\t\t \n\t\tAGC_FUNC_CTRL2, 0xc6,\n\t\t \n\t\tAGC_FUNC_CTRL3, 0x40,\n\t\t \n\t\tAGC_DELAY0, 0x07,\n\t\tAGC_DELAY2, 0xfe,\n\t\t \n\t\tAGC_LOOP_BANDWIDTH0, 0x08,\n\t\tAGC_LOOP_BANDWIDTH1, 0x9a\n\t};\n\tstatic const u8 lgdt3303_init_data[] = {\n\t\t0x4c, 0x14\n\t};\n\tstatic const u8 flip_1_lgdt3303_init_data[] = {\n\t\t0x4c, 0x14,\n\t\t0x87, 0xf3\n\t};\n\tstatic const u8 flip_2_lgdt3303_init_data[] = {\n\t\t0x4c, 0x14,\n\t\t0x87, 0xda\n\t};\n\n\t \n\n\tswitch (state->config.demod_chip) {\n\tcase LGDT3302:\n\t\tchip_name = \"LGDT3302\";\n\t\terr = i2c_write_demod_bytes(state, lgdt3302_init_data,\n\t\t\t\t\t    sizeof(lgdt3302_init_data));\n\t\tbreak;\n\tcase LGDT3303:\n\t\tchip_name = \"LGDT3303\";\n\t\tswitch (state->config.clock_polarity_flip) {\n\t\tcase 2:\n\t\t\terr = i2c_write_demod_bytes(state,\n\t\t\t\t\t\t    flip_2_lgdt3303_init_data,\n\t\t\t\t\t\t    sizeof(flip_2_lgdt3303_init_data));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\terr = i2c_write_demod_bytes(state,\n\t\t\t\t\t\t    flip_1_lgdt3303_init_data,\n\t\t\t\t\t\t    sizeof(flip_1_lgdt3303_init_data));\n\t\t\tbreak;\n\t\tcase 0:\n\t\tdefault:\n\t\t\terr = i2c_write_demod_bytes(state, lgdt3303_init_data,\n\t\t\t\t\t\t    sizeof(lgdt3303_init_data));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tchip_name = \"undefined\";\n\t\tdev_warn(&state->client->dev,\n\t\t\t \"Only LGDT3302 and LGDT3303 are supported chips.\\n\");\n\t\terr = -ENODEV;\n\t}\n\tdprintk(state, \"Initialized the %s chip\\n\", chip_name);\n\tif (err < 0)\n\t\treturn err;\n\n\tp->cnr.len = 1;\n\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->block_error.len = 1;\n\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->block_count.len = 1;\n\tp->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tstate->last_stats_time = 0;\n\n\treturn lgdt330x_sw_reset(state);\n}\n\nstatic int lgdt330x_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct lgdt330x_state *state = fe->demodulator_priv;\n\n\t*ucblocks = state->ucblocks;\n\n\treturn 0;\n}\n\nstatic int lgdt330x_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct lgdt330x_state *state = fe->demodulator_priv;\n\t \n\tstatic const u8 lgdt3303_8vsb_44_data[] = {\n\t\t0x04, 0x00,\n\t\t0x0d, 0x40,\n\t\t0x0e, 0x87,\n\t\t0x0f, 0x8e,\n\t\t0x10, 0x01,\n\t\t0x47, 0x8b\n\t};\n\t \n\tstatic const u8 lgdt3303_qam_data[] = {\n\t\t0x04, 0x00,\n\t\t0x0d, 0x00,\n\t\t0x0e, 0x00,\n\t\t0x0f, 0x00,\n\t\t0x10, 0x00,\n\t\t0x51, 0x63,\n\t\t0x47, 0x66,\n\t\t0x48, 0x66,\n\t\t0x4d, 0x1a,\n\t\t0x49, 0x08,\n\t\t0x4a, 0x9b\n\t};\n\tu8 top_ctrl_cfg[]   = { TOP_CONTROL, 0x03 };\n\n\tint err = 0;\n\t \n\tif (state->current_modulation != p->modulation) {\n\t\tswitch (p->modulation) {\n\t\tcase VSB_8:\n\t\t\tdprintk(state, \"VSB_8 MODE\\n\");\n\n\t\t\t \n\t\t\ttop_ctrl_cfg[1] = 0x03;\n\n\t\t\t \n\t\t\tif (state->config.pll_rf_set)\n\t\t\t\tstate->config.pll_rf_set(fe, 1);\n\n\t\t\tif (state->config.demod_chip == LGDT3303) {\n\t\t\t\terr = i2c_write_demod_bytes(state,\n\t\t\t\t\t\t\t    lgdt3303_8vsb_44_data,\n\t\t\t\t\t\t\t    sizeof(lgdt3303_8vsb_44_data));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase QAM_64:\n\t\t\tdprintk(state, \"QAM_64 MODE\\n\");\n\n\t\t\t \n\t\t\ttop_ctrl_cfg[1] = 0x00;\n\n\t\t\t \n\t\t\tif (state->config.pll_rf_set)\n\t\t\t\tstate->config.pll_rf_set(fe, 0);\n\n\t\t\tif (state->config.demod_chip == LGDT3303) {\n\t\t\t\terr = i2c_write_demod_bytes(state,\n\t\t\t\t\t\t\t    lgdt3303_qam_data,\n\t\t\t\t\t\t\t    sizeof(lgdt3303_qam_data));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase QAM_256:\n\t\t\tdprintk(state, \"QAM_256 MODE\\n\");\n\n\t\t\t \n\t\t\ttop_ctrl_cfg[1] = 0x01;\n\n\t\t\t \n\t\t\tif (state->config.pll_rf_set)\n\t\t\t\tstate->config.pll_rf_set(fe, 0);\n\n\t\t\tif (state->config.demod_chip == LGDT3303) {\n\t\t\t\terr = i2c_write_demod_bytes(state,\n\t\t\t\t\t\t\t    lgdt3303_qam_data,\n\t\t\t\t\t\t\t    sizeof(lgdt3303_qam_data));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&state->client->dev,\n\t\t\t\t \"%s: Modulation type(%d) UNSUPPORTED\\n\",\n\t\t\t\t __func__, p->modulation);\n\t\t\treturn -1;\n\t\t}\n\t\tif (err < 0)\n\t\t\tdev_warn(&state->client->dev,\n\t\t\t\t \"%s: error blasting bytes to lgdt3303 for modulation type(%d)\\n\",\n\t\t\t\t __func__, p->modulation);\n\n\t\t \n\t\ttop_ctrl_cfg[1] |= state->config.serial_mpeg;\n\n\t\t \n\t\ti2c_write_demod_bytes(state, top_ctrl_cfg,\n\t\t\t\t      sizeof(top_ctrl_cfg));\n\t\tif (state->config.set_ts_params)\n\t\t\tstate->config.set_ts_params(fe, 0);\n\t\tstate->current_modulation = p->modulation;\n\t}\n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t \n\t \n\tstate->current_frequency = p->frequency;\n\n\tlgdt330x_sw_reset(state);\n\treturn 0;\n}\n\nstatic int lgdt330x_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t struct dtv_frontend_properties *p)\n{\n\tstruct lgdt330x_state *state = fe->demodulator_priv;\n\n\tp->frequency = state->current_frequency;\n\treturn 0;\n}\n\n \nstatic u32 calculate_snr(u32 mse, u32 c)\n{\n\tif (mse == 0)  \n\t\treturn 0;\n\n\tmse = intlog10(mse);\n\tif (mse > c) {\n\t\t \n\t\treturn 0;\n\t}\n\treturn 10 * (c - mse);\n}\n\nstatic int lgdt3302_read_snr(struct dvb_frontend *fe)\n{\n\tstruct lgdt330x_state *state = fe->demodulator_priv;\n\tu8 buf[5];\t \n\tu32 noise;\t \n\tu32 c;\t\t \n\n\tswitch (state->current_modulation) {\n\tcase VSB_8:\n\t\ti2c_read_demod_bytes(state, LGDT3302_EQPH_ERR0, buf, 5);\n#ifdef USE_EQMSE\n\t\t \n\t\t \n\t\tnoise = ((buf[0] & 7) << 16) | (buf[1] << 8) | buf[2];\n\t\tc = 69765745;  \n#else\n\t\t \n\t\t \n\t\tnoise = ((buf[0] & 7 << 3) << 13) | (buf[3] << 8) | buf[4];\n\t\tc = 73957994;  \n#endif\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\t\ti2c_read_demod_bytes(state, CARRIER_MSEQAM1, buf, 2);\n\t\tnoise = ((buf[0] & 3) << 8) | buf[1];\n\t\tc = state->current_modulation == QAM_64 ? 97939837 : 98026066;\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(&state->client->dev,\n\t\t\t\"%s: Modulation set to unsupported value\\n\",\n\t\t\t__func__);\n\n\t\tstate->snr = 0;\n\n\t\treturn -EREMOTEIO;  \n\t}\n\n\tstate->snr = calculate_snr(noise, c);\n\n\tdprintk(state, \"noise = 0x%08x, snr = %d.%02d dB\\n\", noise,\n\t\tstate->snr >> 24, (((state->snr >> 8) & 0xffff) * 100) >> 16);\n\n\treturn 0;\n}\n\nstatic int lgdt3303_read_snr(struct dvb_frontend *fe)\n{\n\tstruct lgdt330x_state *state = fe->demodulator_priv;\n\tu8 buf[5];\t \n\tu32 noise;\t \n\tu32 c;\t\t \n\n\tswitch (state->current_modulation) {\n\tcase VSB_8:\n\t\ti2c_read_demod_bytes(state, LGDT3303_EQPH_ERR0, buf, 5);\n#ifdef USE_EQMSE\n\t\t \n\t\t \n\t\tnoise = ((buf[0] & 0x78) << 13) | (buf[1] << 8) | buf[2];\n\t\tc = 73957994;  \n#else\n\t\t \n\t\t \n\t\tnoise = ((buf[0] & 7) << 16) | (buf[3] << 8) | buf[4];\n\t\tc = 73957994;  \n#endif\n\t\tbreak;\n\tcase QAM_64:\n\tcase QAM_256:\n\t\ti2c_read_demod_bytes(state, CARRIER_MSEQAM1, buf, 2);\n\t\tnoise = (buf[0] << 8) | buf[1];\n\t\tc = state->current_modulation == QAM_64 ? 97939837 : 98026066;\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(&state->client->dev,\n\t\t\t\"%s: Modulation set to unsupported value\\n\",\n\t\t\t__func__);\n\t\tstate->snr = 0;\n\t\treturn -EREMOTEIO;  \n\t}\n\n\tstate->snr = calculate_snr(noise, c);\n\n\tdprintk(state, \"noise = 0x%08x, snr = %d.%02d dB\\n\", noise,\n\t\tstate->snr >> 24, (((state->snr >> 8) & 0xffff) * 100) >> 16);\n\n\treturn 0;\n}\n\nstatic int lgdt330x_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct lgdt330x_state *state = fe->demodulator_priv;\n\n\t*snr = (state->snr) >> 16;  \n\n\treturn 0;\n}\n\nstatic int lgdt330x_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\n{\n\t \n\t \n\tstruct lgdt330x_state *state = fe->demodulator_priv;\n\tu16 snr;\n\tint ret;\n\n\tret = fe->ops.read_snr(fe, &snr);\n\tif (ret != 0)\n\t\treturn ret;\n\t \n\t \n\tif (state->snr >= 8960 * 0x10000)\n\t\t*strength = 0xffff;\n\telse\n\t\t*strength = state->snr / 8960;\n\n\treturn 0;\n}\n\n\nstatic int lgdt3302_read_status(struct dvb_frontend *fe,\n\t\t\t\tenum fe_status *status)\n{\n\tstruct lgdt330x_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu8 buf[3];\n\tint err;\n\n\t*status = 0;  \n\n\t \n\ti2c_read_demod_bytes(state, AGC_STATUS, buf, 1);\n\tdprintk(state, \"AGC_STATUS = 0x%02x\\n\", buf[0]);\n\tif ((buf[0] & 0x0c) == 0x8) {\n\t\t \n\t\t*status |= FE_HAS_SIGNAL;\n\t}\n\n\t \n\n\t \n\ti2c_read_demod_bytes(state, TOP_CONTROL, buf, sizeof(buf));\n\tdprintk(state,\n\t\t\"TOP_CONTROL = 0x%02x, IRO_MASK = 0x%02x, IRQ_STATUS = 0x%02x\\n\",\n\t\tbuf[0], buf[1], buf[2]);\n\n\t \n\tif ((buf[2] & 0x03) == 0x01)\n\t\t*status |= FE_HAS_SYNC;\n\n\t \n\tif ((buf[2] & 0x0c) == 0x08)\n\t\t*status |= FE_HAS_LOCK | FE_HAS_VITERBI;\n\n\t \n\ti2c_read_demod_bytes(state, CARRIER_LOCK, buf, 1);\n\tdprintk(state, \"CARRIER_LOCK = 0x%02x\\n\", buf[0]);\n\tswitch (state->current_modulation) {\n\tcase QAM_256:\n\tcase QAM_64:\n\t\t \n\t\tif ((buf[0] & 0x07) == 0x07)\n\t\t\t*status |= FE_HAS_CARRIER;\n\t\tbreak;\n\tcase VSB_8:\n\t\tif ((buf[0] & 0x80) == 0x80)\n\t\t\t*status |= FE_HAS_CARRIER;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&state->client->dev,\n\t\t\t \"%s: Modulation set to unsupported value\\n\",\n\t\t\t __func__);\n\t}\n\n\tif (!(*status & FE_HAS_LOCK)) {\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn 0;\n\t}\n\n\tif (state->last_stats_time &&\n\t    time_is_after_jiffies(state->last_stats_time))\n\t\treturn 0;\n\n\tstate->last_stats_time = jiffies + msecs_to_jiffies(1000);\n\n\terr = lgdt3302_read_snr(fe);\n\tif (!err) {\n\t\tp->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tp->cnr.stat[0].svalue = (((u64)state->snr) * 1000) >> 24;\n\t} else {\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\terr = i2c_read_demod_bytes(state, LGDT3302_PACKET_ERR_COUNTER1,\n\t\t\t\t\t   buf, sizeof(buf));\n\tif (!err) {\n\t\tstate->ucblocks = (buf[0] << 8) | buf[1];\n\n\t\tdprintk(state, \"UCB = 0x%02x\\n\", state->ucblocks);\n\n\t\tp->block_error.stat[0].uvalue += state->ucblocks;\n\t\t \n\t\tp->block_count.stat[0].uvalue += 10000;\n\n\t\tp->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tp->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t} else {\n\t\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn 0;\n}\n\nstatic int lgdt3303_read_status(struct dvb_frontend *fe,\n\t\t\t\tenum fe_status *status)\n{\n\tstruct lgdt330x_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu8 buf[3];\n\tint err;\n\n\t*status = 0;  \n\n\t \n\terr = i2c_read_demod_bytes(state, 0x58, buf, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\tdprintk(state, \"AGC_STATUS = 0x%02x\\n\", buf[0]);\n\tif ((buf[0] & 0x21) == 0x01) {\n\t\t \n\t\t*status |= FE_HAS_SIGNAL;\n\t}\n\n\t \n\ti2c_read_demod_bytes(state, CARRIER_LOCK, buf, 1);\n\tdprintk(state, \"CARRIER_LOCK = 0x%02x\\n\", buf[0]);\n\tswitch (state->current_modulation) {\n\tcase QAM_256:\n\tcase QAM_64:\n\t\t \n\t\tif ((buf[0] & 0x07) == 0x07)\n\t\t\t*status |= FE_HAS_CARRIER;\n\t\telse\n\t\t\tbreak;\n\t\ti2c_read_demod_bytes(state, 0x8a, buf, 1);\n\t\tdprintk(state, \"QAM LOCK = 0x%02x\\n\", buf[0]);\n\n\t\tif ((buf[0] & 0x04) == 0x04)\n\t\t\t*status |= FE_HAS_SYNC;\n\t\tif ((buf[0] & 0x01) == 0x01)\n\t\t\t*status |= FE_HAS_LOCK;\n\t\tif ((buf[0] & 0x08) == 0x08)\n\t\t\t*status |= FE_HAS_VITERBI;\n\t\tbreak;\n\tcase VSB_8:\n\t\tif ((buf[0] & 0x80) == 0x80)\n\t\t\t*status |= FE_HAS_CARRIER;\n\t\telse\n\t\t\tbreak;\n\t\ti2c_read_demod_bytes(state, 0x38, buf, 1);\n\t\tdprintk(state, \"8-VSB LOCK = 0x%02x\\n\", buf[0]);\n\n\t\tif ((buf[0] & 0x02) == 0x00)\n\t\t\t*status |= FE_HAS_SYNC;\n\t\tif ((buf[0] & 0x01) == 0x01)\n\t\t\t*status |= FE_HAS_VITERBI | FE_HAS_LOCK;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&state->client->dev,\n\t\t\t \"%s: Modulation set to unsupported value\\n\",\n\t\t\t __func__);\n\t}\n\n\tif (!(*status & FE_HAS_LOCK)) {\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn 0;\n\t}\n\n\tif (state->last_stats_time &&\n\t    time_is_after_jiffies(state->last_stats_time))\n\t\treturn 0;\n\n\tstate->last_stats_time = jiffies + msecs_to_jiffies(1000);\n\n\terr = lgdt3303_read_snr(fe);\n\tif (!err) {\n\t\tp->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tp->cnr.stat[0].svalue = (((u64)state->snr) * 1000) >> 24;\n\t} else {\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\terr = i2c_read_demod_bytes(state, LGDT3303_PACKET_ERR_COUNTER1,\n\t\t\t\t\t   buf, sizeof(buf));\n\tif (!err) {\n\t\tstate->ucblocks = (buf[0] << 8) | buf[1];\n\n\t\tdprintk(state, \"UCB = 0x%02x\\n\", state->ucblocks);\n\n\t\tp->block_error.stat[0].uvalue += state->ucblocks;\n\t\t \n\t\tp->block_count.stat[0].uvalue += 10000;\n\n\t\tp->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tp->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t} else {\n\t\tp->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nlgdt330x_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t   struct dvb_frontend_tune_settings *fe_tune_settings)\n{\n\t \n\tfe_tune_settings->min_delay_ms = 500;\n\tfe_tune_settings->step_size = 0;\n\tfe_tune_settings->max_drift = 0;\n\treturn 0;\n}\n\nstatic void lgdt330x_release(struct dvb_frontend *fe)\n{\n\tstruct lgdt330x_state *state = fe->demodulator_priv;\n\tstruct i2c_client *client = state->client;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\ti2c_unregister_device(client);\n}\n\nstatic struct dvb_frontend *lgdt330x_get_dvb_frontend(struct i2c_client *client)\n{\n\tstruct lgdt330x_state *state = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\treturn &state->frontend;\n}\n\nstatic const struct dvb_frontend_ops lgdt3302_ops;\nstatic const struct dvb_frontend_ops lgdt3303_ops;\n\nstatic int lgdt330x_probe(struct i2c_client *client)\n{\n\tstruct lgdt330x_state *state = NULL;\n\tu8 buf[1];\n\n\t \n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\tgoto error;\n\n\t \n\tmemcpy(&state->config, client->dev.platform_data,\n\t       sizeof(state->config));\n\ti2c_set_clientdata(client, state);\n\tstate->client = client;\n\n\t \n\tswitch (state->config.demod_chip) {\n\tcase LGDT3302:\n\t\tmemcpy(&state->frontend.ops, &lgdt3302_ops,\n\t\t       sizeof(struct dvb_frontend_ops));\n\t\tbreak;\n\tcase LGDT3303:\n\t\tmemcpy(&state->frontend.ops, &lgdt3303_ops,\n\t\t       sizeof(struct dvb_frontend_ops));\n\t\tbreak;\n\tdefault:\n\t\tgoto error;\n\t}\n\tstate->frontend.demodulator_priv = state;\n\n\t \n\tstate->config.get_dvb_frontend = lgdt330x_get_dvb_frontend;\n\n\t \n\tif (i2c_read_demod_bytes(state, 2, buf, 1))\n\t\tgoto error;\n\n\tstate->current_frequency = -1;\n\tstate->current_modulation = -1;\n\n\tdev_info(&state->client->dev,\n\t\t\"Demod loaded for LGDT330%s chip\\n\",\n\t\tstate->config.demod_chip == LGDT3302 ? \"2\" : \"3\");\n\n\treturn 0;\n\nerror:\n\tkfree(state);\n\tif (debug)\n\t\tdev_printk(KERN_DEBUG, &client->dev, \"Error loading lgdt330x driver\\n\");\n\treturn -ENODEV;\n}\nstruct dvb_frontend *lgdt330x_attach(const struct lgdt330x_config *_config,\n\t\t\t\t     u8 demod_address,\n\t\t\t\t     struct i2c_adapter *i2c)\n{\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info = {};\n\tstruct lgdt330x_config config = *_config;\n\n\tstrscpy(board_info.type, \"lgdt330x\", sizeof(board_info.type));\n\tboard_info.addr = demod_address;\n\tboard_info.platform_data = &config;\n\tclient = i2c_new_client_device(i2c, &board_info);\n\tif (!i2c_client_has_driver(client))\n\t\treturn NULL;\n\n\treturn lgdt330x_get_dvb_frontend(client);\n}\nEXPORT_SYMBOL_GPL(lgdt330x_attach);\n\nstatic const struct dvb_frontend_ops lgdt3302_ops = {\n\t.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },\n\t.info = {\n\t\t.name = \"LG Electronics LGDT3302 VSB/QAM Frontend\",\n\t\t.frequency_min_hz =  54 * MHz,\n\t\t.frequency_max_hz = 858 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.symbol_rate_min    = 5056941,\t \n\t\t.symbol_rate_max    = 10762000,\t \n\t\t.caps = FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB\n\t},\n\t.init                 = lgdt330x_init,\n\t.set_frontend         = lgdt330x_set_parameters,\n\t.get_frontend         = lgdt330x_get_frontend,\n\t.get_tune_settings    = lgdt330x_get_tune_settings,\n\t.read_status          = lgdt3302_read_status,\n\t.read_signal_strength = lgdt330x_read_signal_strength,\n\t.read_snr             = lgdt330x_read_snr,\n\t.read_ucblocks        = lgdt330x_read_ucblocks,\n\t.release              = lgdt330x_release,\n};\n\nstatic const struct dvb_frontend_ops lgdt3303_ops = {\n\t.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },\n\t.info = {\n\t\t.name = \"LG Electronics LGDT3303 VSB/QAM Frontend\",\n\t\t.frequency_min_hz =  54 * MHz,\n\t\t.frequency_max_hz = 858 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.symbol_rate_min    = 5056941,\t \n\t\t.symbol_rate_max    = 10762000,\t \n\t\t.caps = FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB\n\t},\n\t.init                 = lgdt330x_init,\n\t.set_frontend         = lgdt330x_set_parameters,\n\t.get_frontend         = lgdt330x_get_frontend,\n\t.get_tune_settings    = lgdt330x_get_tune_settings,\n\t.read_status          = lgdt3303_read_status,\n\t.read_signal_strength = lgdt330x_read_signal_strength,\n\t.read_snr             = lgdt330x_read_snr,\n\t.read_ucblocks        = lgdt330x_read_ucblocks,\n\t.release              = lgdt330x_release,\n};\n\nstatic void lgdt330x_remove(struct i2c_client *client)\n{\n\tstruct lgdt330x_state *state = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tkfree(state);\n}\n\nstatic const struct i2c_device_id lgdt330x_id_table[] = {\n\t{\"lgdt330x\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, lgdt330x_id_table);\n\nstatic struct i2c_driver lgdt330x_driver = {\n\t.driver = {\n\t\t.name\t= \"lgdt330x\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= lgdt330x_probe,\n\t.remove\t\t= lgdt330x_remove,\n\t.id_table\t= lgdt330x_id_table,\n};\n\nmodule_i2c_driver(lgdt330x_driver);\n\n\nMODULE_DESCRIPTION(\"LGDT330X (ATSC 8VSB & ITU-T J.83 AnnexB 64/256 QAM) Demodulator Driver\");\nMODULE_AUTHOR(\"Wilson Michaels\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}