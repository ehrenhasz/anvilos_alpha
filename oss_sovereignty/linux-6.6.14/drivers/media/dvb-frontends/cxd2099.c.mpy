{
  "module_name": "cxd2099.c",
  "hash_id": "c2d7b91fd3eb3ff67fcc487d725a19644ec824d4021b594f14e29b90b96d454f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cxd2099.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n\n#include \"cxd2099.h\"\n\nstatic int buffermode;\nmodule_param(buffermode, int, 0444);\nMODULE_PARM_DESC(buffermode, \"Enable CXD2099AR buffer mode (default: disabled)\");\n\nstatic int read_data(struct dvb_ca_en50221 *ca, int slot, u8 *ebuf, int ecount);\n\nstruct cxd {\n\tstruct dvb_ca_en50221 en;\n\n\tstruct cxd2099_cfg cfg;\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\n\tu8     regs[0x23];\n\tu8     lastaddress;\n\tu8     clk_reg_f;\n\tu8     clk_reg_b;\n\tint    mode;\n\tint    ready;\n\tint    dr;\n\tint    write_busy;\n\tint    slot_stat;\n\n\tu8     amem[1024];\n\tint    amem_read;\n\n\tint    cammode;\n\tstruct mutex lock;  \n\n\tu8     rbuf[1028];\n\tu8     wbuf[1028];\n};\n\nstatic int read_block(struct cxd *ci, u8 adr, u8 *data, u16 n)\n{\n\tint status = 0;\n\n\tif (ci->lastaddress != adr)\n\t\tstatus = regmap_write(ci->regmap, 0, adr);\n\tif (!status) {\n\t\tci->lastaddress = adr;\n\n\t\twhile (n) {\n\t\t\tint len = n;\n\n\t\t\tif (ci->cfg.max_i2c && len > ci->cfg.max_i2c)\n\t\t\t\tlen = ci->cfg.max_i2c;\n\t\t\tstatus = regmap_raw_read(ci->regmap, 1, data, len);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tdata += len;\n\t\t\tn -= len;\n\t\t}\n\t}\n\treturn status;\n}\n\nstatic int read_reg(struct cxd *ci, u8 reg, u8 *val)\n{\n\treturn read_block(ci, reg, val, 1);\n}\n\nstatic int read_pccard(struct cxd *ci, u16 address, u8 *data, u8 n)\n{\n\tint status;\n\tu8 addr[2] = {address & 0xff, address >> 8};\n\n\tstatus = regmap_raw_write(ci->regmap, 2, addr, 2);\n\tif (!status)\n\t\tstatus = regmap_raw_read(ci->regmap, 3, data, n);\n\treturn status;\n}\n\nstatic int write_pccard(struct cxd *ci, u16 address, u8 *data, u8 n)\n{\n\tint status;\n\tu8 addr[2] = {address & 0xff, address >> 8};\n\n\tstatus = regmap_raw_write(ci->regmap, 2, addr, 2);\n\tif (!status) {\n\t\tu8 buf[256];\n\n\t\tmemcpy(buf, data, n);\n\t\tstatus = regmap_raw_write(ci->regmap, 3, buf, n);\n\t}\n\treturn status;\n}\n\nstatic int read_io(struct cxd *ci, u16 address, unsigned int *val)\n{\n\tint status;\n\tu8 addr[2] = {address & 0xff, address >> 8};\n\n\tstatus = regmap_raw_write(ci->regmap, 2, addr, 2);\n\tif (!status)\n\t\tstatus = regmap_read(ci->regmap, 3, val);\n\treturn status;\n}\n\nstatic int write_io(struct cxd *ci, u16 address, u8 val)\n{\n\tint status;\n\tu8 addr[2] = {address & 0xff, address >> 8};\n\n\tstatus = regmap_raw_write(ci->regmap, 2, addr, 2);\n\tif (!status)\n\t\tstatus = regmap_write(ci->regmap, 3, val);\n\treturn status;\n}\n\nstatic int write_regm(struct cxd *ci, u8 reg, u8 val, u8 mask)\n{\n\tint status = 0;\n\tunsigned int regval;\n\n\tif (ci->lastaddress != reg)\n\t\tstatus = regmap_write(ci->regmap, 0, reg);\n\tif (!status && reg >= 6 && reg <= 8 && mask != 0xff) {\n\t\tstatus = regmap_read(ci->regmap, 1, &regval);\n\t\tci->regs[reg] = regval;\n\t}\n\tci->lastaddress = reg;\n\tci->regs[reg] = (ci->regs[reg] & (~mask)) | val;\n\tif (!status)\n\t\tstatus = regmap_write(ci->regmap, 1, ci->regs[reg]);\n\tif (reg == 0x20)\n\t\tci->regs[reg] &= 0x7f;\n\treturn status;\n}\n\nstatic int write_reg(struct cxd *ci, u8 reg, u8 val)\n{\n\treturn write_regm(ci, reg, val, 0xff);\n}\n\nstatic int write_block(struct cxd *ci, u8 adr, u8 *data, u16 n)\n{\n\tint status = 0;\n\tu8 *buf = ci->wbuf;\n\n\tif (ci->lastaddress != adr)\n\t\tstatus = regmap_write(ci->regmap, 0, adr);\n\tif (status)\n\t\treturn status;\n\n\tci->lastaddress = adr;\n\twhile (n) {\n\t\tint len = n;\n\n\t\tif (ci->cfg.max_i2c && (len + 1 > ci->cfg.max_i2c))\n\t\t\tlen = ci->cfg.max_i2c - 1;\n\t\tmemcpy(buf, data, len);\n\t\tstatus = regmap_raw_write(ci->regmap, 1, buf, len);\n\t\tif (status)\n\t\t\treturn status;\n\t\tn -= len;\n\t\tdata += len;\n\t}\n\treturn status;\n}\n\nstatic void set_mode(struct cxd *ci, int mode)\n{\n\tif (mode == ci->mode)\n\t\treturn;\n\n\tswitch (mode) {\n\tcase 0x00:  \n\t\twrite_regm(ci, 0x06, 0x00, 0x07);\n\t\tbreak;\n\tcase 0x01:  \n\t\twrite_regm(ci, 0x06, 0x02, 0x07);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tci->mode = mode;\n}\n\nstatic void cam_mode(struct cxd *ci, int mode)\n{\n\tu8 dummy;\n\n\tif (mode == ci->cammode)\n\t\treturn;\n\n\tswitch (mode) {\n\tcase 0x00:\n\t\twrite_regm(ci, 0x20, 0x80, 0x80);\n\t\tbreak;\n\tcase 0x01:\n\t\tif (!ci->en.read_data)\n\t\t\treturn;\n\t\tci->write_busy = 0;\n\t\tdev_info(&ci->client->dev, \"enable cam buffer mode\\n\");\n\t\twrite_reg(ci, 0x0d, 0x00);\n\t\twrite_reg(ci, 0x0e, 0x01);\n\t\twrite_regm(ci, 0x08, 0x40, 0x40);\n\t\tread_reg(ci, 0x12, &dummy);\n\t\twrite_regm(ci, 0x08, 0x80, 0x80);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tci->cammode = mode;\n}\n\nstatic int init(struct cxd *ci)\n{\n\tint status;\n\n\tmutex_lock(&ci->lock);\n\tci->mode = -1;\n\tdo {\n\t\tstatus = write_reg(ci, 0x00, 0x00);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x01, 0x00);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x02, 0x10);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x03, 0x00);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x05, 0xFF);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x06, 0x1F);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x07, 0x1F);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x08, 0x28);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x14, 0x20);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tstatus = write_reg(ci, 0x0A, 0xA7);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = write_reg(ci, 0x0B, 0x33);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x0C, 0x33);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tstatus = write_regm(ci, 0x14, 0x00, 0x0F);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x15, ci->clk_reg_b);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_regm(ci, 0x16, 0x00, 0x0F);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x17, ci->clk_reg_f);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tif (ci->cfg.clock_mode == 2) {\n\t\t\t \n\t\t\tu32 reg = ((ci->cfg.bitrate << 13) + 71999) / 72000;\n\n\t\t\tif (ci->cfg.polarity) {\n\t\t\t\tstatus = write_reg(ci, 0x09, 0x6f);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tstatus = write_reg(ci, 0x09, 0x6d);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = write_reg(ci, 0x20, 0x08);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = write_reg(ci, 0x21, (reg >> 8) & 0xff);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = write_reg(ci, 0x22, reg & 0xff);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else if (ci->cfg.clock_mode == 1) {\n\t\t\tif (ci->cfg.polarity) {\n\t\t\t\tstatus = write_reg(ci, 0x09, 0x6f);  \n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tstatus = write_reg(ci, 0x09, 0x6d);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = write_reg(ci, 0x20, 0x68);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = write_reg(ci, 0x21, 0x00);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = write_reg(ci, 0x22, 0x02);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (ci->cfg.polarity) {\n\t\t\t\tstatus = write_reg(ci, 0x09, 0x4f);  \n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tstatus = write_reg(ci, 0x09, 0x4d);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = write_reg(ci, 0x20, 0x28);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = write_reg(ci, 0x21, 0x00);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = write_reg(ci, 0x22, 0x07);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstatus = write_regm(ci, 0x20, 0x80, 0x80);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_regm(ci, 0x03, 0x02, 0x02);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x01, 0x04);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus = write_reg(ci, 0x00, 0x31);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tstatus = write_regm(ci, 0x09, 0x08, 0x08);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tci->cammode = -1;\n\t\tcam_mode(ci, 0);\n\t} while (0);\n\tmutex_unlock(&ci->lock);\n\n\treturn 0;\n}\n\nstatic int read_attribute_mem(struct dvb_ca_en50221 *ca,\n\t\t\t      int slot, int address)\n{\n\tstruct cxd *ci = ca->data;\n\tu8 val;\n\n\tmutex_lock(&ci->lock);\n\tset_mode(ci, 1);\n\tread_pccard(ci, address, &val, 1);\n\tmutex_unlock(&ci->lock);\n\treturn val;\n}\n\nstatic int write_attribute_mem(struct dvb_ca_en50221 *ca, int slot,\n\t\t\t       int address, u8 value)\n{\n\tstruct cxd *ci = ca->data;\n\n\tmutex_lock(&ci->lock);\n\tset_mode(ci, 1);\n\twrite_pccard(ci, address, &value, 1);\n\tmutex_unlock(&ci->lock);\n\treturn 0;\n}\n\nstatic int read_cam_control(struct dvb_ca_en50221 *ca,\n\t\t\t    int slot, u8 address)\n{\n\tstruct cxd *ci = ca->data;\n\tunsigned int val;\n\n\tmutex_lock(&ci->lock);\n\tset_mode(ci, 0);\n\tread_io(ci, address, &val);\n\tmutex_unlock(&ci->lock);\n\treturn val;\n}\n\nstatic int write_cam_control(struct dvb_ca_en50221 *ca, int slot,\n\t\t\t     u8 address, u8 value)\n{\n\tstruct cxd *ci = ca->data;\n\n\tmutex_lock(&ci->lock);\n\tset_mode(ci, 0);\n\twrite_io(ci, address, value);\n\tmutex_unlock(&ci->lock);\n\treturn 0;\n}\n\nstatic int slot_reset(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct cxd *ci = ca->data;\n\n\tif (ci->cammode)\n\t\tread_data(ca, slot, ci->rbuf, 0);\n\n\tmutex_lock(&ci->lock);\n\tcam_mode(ci, 0);\n\twrite_reg(ci, 0x00, 0x21);\n\twrite_reg(ci, 0x06, 0x1F);\n\twrite_reg(ci, 0x00, 0x31);\n\twrite_regm(ci, 0x20, 0x80, 0x80);\n\twrite_reg(ci, 0x03, 0x02);\n\tci->ready = 0;\n\tci->mode = -1;\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tusleep_range(10000, 11000);\n\t\t\tif (ci->ready)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ci->lock);\n\treturn 0;\n}\n\nstatic int slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct cxd *ci = ca->data;\n\n\tdev_dbg(&ci->client->dev, \"%s\\n\", __func__);\n\tif (ci->cammode)\n\t\tread_data(ca, slot, ci->rbuf, 0);\n\tmutex_lock(&ci->lock);\n\twrite_reg(ci, 0x00, 0x21);\n\twrite_reg(ci, 0x06, 0x1F);\n\tmsleep(300);\n\n\twrite_regm(ci, 0x09, 0x08, 0x08);\n\twrite_regm(ci, 0x20, 0x80, 0x80);  \n\twrite_regm(ci, 0x06, 0x07, 0x07);  \n\n\tci->mode = -1;\n\tci->write_busy = 0;\n\tmutex_unlock(&ci->lock);\n\treturn 0;\n}\n\nstatic int slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct cxd *ci = ca->data;\n\n\tmutex_lock(&ci->lock);\n\twrite_regm(ci, 0x09, 0x00, 0x08);\n\tset_mode(ci, 0);\n\tcam_mode(ci, 1);\n\tmutex_unlock(&ci->lock);\n\treturn 0;\n}\n\nstatic int campoll(struct cxd *ci)\n{\n\tu8 istat;\n\n\tread_reg(ci, 0x04, &istat);\n\tif (!istat)\n\t\treturn 0;\n\twrite_reg(ci, 0x05, istat);\n\n\tif (istat & 0x40)\n\t\tci->dr = 1;\n\tif (istat & 0x20)\n\t\tci->write_busy = 0;\n\n\tif (istat & 2) {\n\t\tu8 slotstat;\n\n\t\tread_reg(ci, 0x01, &slotstat);\n\t\tif (!(2 & slotstat)) {\n\t\t\tif (!ci->slot_stat) {\n\t\t\t\tci->slot_stat |=\n\t\t\t\t\t      DVB_CA_EN50221_POLL_CAM_PRESENT;\n\t\t\t\twrite_regm(ci, 0x03, 0x08, 0x08);\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (ci->slot_stat) {\n\t\t\t\tci->slot_stat = 0;\n\t\t\t\twrite_regm(ci, 0x03, 0x00, 0x08);\n\t\t\t\tdev_info(&ci->client->dev, \"NO CAM\\n\");\n\t\t\t\tci->ready = 0;\n\t\t\t}\n\t\t}\n\t\tif ((istat & 8) &&\n\t\t    ci->slot_stat == DVB_CA_EN50221_POLL_CAM_PRESENT) {\n\t\t\tci->ready = 1;\n\t\t\tci->slot_stat |= DVB_CA_EN50221_POLL_CAM_READY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\n{\n\tstruct cxd *ci = ca->data;\n\tu8 slotstat;\n\n\tmutex_lock(&ci->lock);\n\tcampoll(ci);\n\tread_reg(ci, 0x01, &slotstat);\n\tmutex_unlock(&ci->lock);\n\n\treturn ci->slot_stat;\n}\n\nstatic int read_data(struct dvb_ca_en50221 *ca, int slot, u8 *ebuf, int ecount)\n{\n\tstruct cxd *ci = ca->data;\n\tu8 msb, lsb;\n\tu16 len;\n\n\tmutex_lock(&ci->lock);\n\tcampoll(ci);\n\tmutex_unlock(&ci->lock);\n\n\tif (!ci->dr)\n\t\treturn 0;\n\n\tmutex_lock(&ci->lock);\n\tread_reg(ci, 0x0f, &msb);\n\tread_reg(ci, 0x10, &lsb);\n\tlen = ((u16)msb << 8) | lsb;\n\tif (len > ecount || len < 2) {\n\t\t \n\t\tread_block(ci, 0x12, ci->rbuf, len);\n\t\tmutex_unlock(&ci->lock);\n\t\treturn -EIO;\n\t}\n\tread_block(ci, 0x12, ebuf, len);\n\tci->dr = 0;\n\tmutex_unlock(&ci->lock);\n\treturn len;\n}\n\nstatic int write_data(struct dvb_ca_en50221 *ca, int slot, u8 *ebuf, int ecount)\n{\n\tstruct cxd *ci = ca->data;\n\n\tif (ci->write_busy)\n\t\treturn -EAGAIN;\n\tmutex_lock(&ci->lock);\n\twrite_reg(ci, 0x0d, ecount >> 8);\n\twrite_reg(ci, 0x0e, ecount & 0xff);\n\twrite_block(ci, 0x11, ebuf, ecount);\n\tci->write_busy = 1;\n\tmutex_unlock(&ci->lock);\n\treturn ecount;\n}\n\nstatic const struct dvb_ca_en50221 en_templ = {\n\t.read_attribute_mem  = read_attribute_mem,\n\t.write_attribute_mem = write_attribute_mem,\n\t.read_cam_control    = read_cam_control,\n\t.write_cam_control   = write_cam_control,\n\t.slot_reset          = slot_reset,\n\t.slot_shutdown       = slot_shutdown,\n\t.slot_ts_enable      = slot_ts_enable,\n\t.poll_slot_status    = poll_slot_status,\n\t.read_data           = read_data,\n\t.write_data          = write_data,\n};\n\nstatic int cxd2099_probe(struct i2c_client *client)\n{\n\tstruct cxd *ci;\n\tstruct cxd2099_cfg *cfg = client->dev.platform_data;\n\tstatic const struct regmap_config rm_cfg = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t};\n\tunsigned int val;\n\tint ret;\n\n\tci = kzalloc(sizeof(*ci), GFP_KERNEL);\n\tif (!ci) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tci->client = client;\n\tmemcpy(&ci->cfg, cfg, sizeof(ci->cfg));\n\n\tci->regmap = regmap_init_i2c(client, &rm_cfg);\n\tif (IS_ERR(ci->regmap)) {\n\t\tret = PTR_ERR(ci->regmap);\n\t\tgoto err_kfree;\n\t}\n\n\tret = regmap_read(ci->regmap, 0x00, &val);\n\tif (ret < 0) {\n\t\tdev_info(&client->dev, \"No CXD2099AR detected at 0x%02x\\n\",\n\t\t\t client->addr);\n\t\tgoto err_rmexit;\n\t}\n\n\tmutex_init(&ci->lock);\n\tci->lastaddress = 0xff;\n\tci->clk_reg_b = 0x4a;\n\tci->clk_reg_f = 0x1b;\n\n\tci->en = en_templ;\n\tci->en.data = ci;\n\tinit(ci);\n\tdev_info(&client->dev, \"Attached CXD2099AR at 0x%02x\\n\", client->addr);\n\n\t*cfg->en = &ci->en;\n\n\tif (!buffermode) {\n\t\tci->en.read_data = NULL;\n\t\tci->en.write_data = NULL;\n\t} else {\n\t\tdev_info(&client->dev, \"Using CXD2099AR buffer mode\");\n\t}\n\n\ti2c_set_clientdata(client, ci);\n\n\treturn 0;\n\nerr_rmexit:\n\tregmap_exit(ci->regmap);\nerr_kfree:\n\tkfree(ci);\nerr:\n\n\treturn ret;\n}\n\nstatic void cxd2099_remove(struct i2c_client *client)\n{\n\tstruct cxd *ci = i2c_get_clientdata(client);\n\n\tregmap_exit(ci->regmap);\n\tkfree(ci);\n}\n\nstatic const struct i2c_device_id cxd2099_id[] = {\n\t{\"cxd2099\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, cxd2099_id);\n\nstatic struct i2c_driver cxd2099_driver = {\n\t.driver = {\n\t\t.name\t= \"cxd2099\",\n\t},\n\t.probe\t\t= cxd2099_probe,\n\t.remove\t\t= cxd2099_remove,\n\t.id_table\t= cxd2099_id,\n};\n\nmodule_i2c_driver(cxd2099_driver);\n\nMODULE_DESCRIPTION(\"Sony CXD2099AR Common Interface controller driver\");\nMODULE_AUTHOR(\"Ralph Metzler\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}