{
  "module_name": "atbm8830.c",
  "hash_id": "824538245da7969c7c4becb2c5ea4cc04392df5dde563cb5d1ae134c6d01cee8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/atbm8830.c",
  "human_readable_source": "\n \n\n#include <asm/div64.h>\n#include <media/dvb_frontend.h>\n\n#include \"atbm8830.h\"\n#include \"atbm8830_priv.h\"\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_DEBUG \"atbm8830: \" args); \\\n\t} while (0)\n\nstatic int debug;\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nstatic int atbm8830_write_reg(struct atbm_state *priv, u16 reg, u8 data)\n{\n\tint ret = 0;\n\tu8 dev_addr;\n\tu8 buf1[] = { reg >> 8, reg & 0xFF };\n\tu8 buf2[] = { data };\n\tstruct i2c_msg msg1 = { .flags = 0, .buf = buf1, .len = 2 };\n\tstruct i2c_msg msg2 = { .flags = 0, .buf = buf2, .len = 1 };\n\n\tdev_addr = priv->config->demod_address;\n\tmsg1.addr = dev_addr;\n\tmsg2.addr = dev_addr;\n\n\tif (debug >= 2)\n\t\tdprintk(\"%s: reg=0x%04X, data=0x%02X\\n\", __func__, reg, data);\n\n\tret = i2c_transfer(priv->i2c, &msg1, 1);\n\tif (ret != 1)\n\t\treturn -EIO;\n\n\tret = i2c_transfer(priv->i2c, &msg2, 1);\n\treturn (ret != 1) ? -EIO : 0;\n}\n\nstatic int atbm8830_read_reg(struct atbm_state *priv, u16 reg, u8 *p_data)\n{\n\tint ret;\n\tu8 dev_addr;\n\n\tu8 buf1[] = { reg >> 8, reg & 0xFF };\n\tu8 buf2[] = { 0 };\n\tstruct i2c_msg msg1 = { .flags = 0, .buf = buf1, .len = 2 };\n\tstruct i2c_msg msg2 = { .flags = I2C_M_RD, .buf = buf2, .len = 1 };\n\n\tdev_addr = priv->config->demod_address;\n\tmsg1.addr = dev_addr;\n\tmsg2.addr = dev_addr;\n\n\tret = i2c_transfer(priv->i2c, &msg1, 1);\n\tif (ret != 1) {\n\t\tdprintk(\"%s: error reg=0x%04x, ret=%i\\n\", __func__, reg, ret);\n\t\treturn -EIO;\n\t}\n\n\tret = i2c_transfer(priv->i2c, &msg2, 1);\n\tif (ret != 1)\n\t\treturn -EIO;\n\n\t*p_data = buf2[0];\n\tif (debug >= 2)\n\t\tdprintk(\"%s: reg=0x%04X, data=0x%02X\\n\",\n\t\t\t__func__, reg, buf2[0]);\n\n\treturn 0;\n}\n\n \nstatic inline int atbm8830_reglatch_lock(struct atbm_state *priv, int lock)\n{\n\treturn atbm8830_write_reg(priv, REG_READ_LATCH, lock ? 1 : 0);\n}\n\nstatic int set_osc_freq(struct atbm_state *priv, u32 freq  )\n{\n\tu32 val;\n\tu64 t;\n\n\t \n\tt = (u64)0x100000 * freq;\n\tdo_div(t, 30400);\n\tval = t;\n\n\tatbm8830_write_reg(priv, REG_OSC_CLK, val);\n\tatbm8830_write_reg(priv, REG_OSC_CLK + 1, val >> 8);\n\tatbm8830_write_reg(priv, REG_OSC_CLK + 2, val >> 16);\n\n\treturn 0;\n}\n\nstatic int set_if_freq(struct atbm_state *priv, u32 freq  )\n{\n\n\tu32 fs = priv->config->osc_clk_freq;\n\tu64 t;\n\tu32 val;\n\tu8 dat;\n\n\tif (freq != 0) {\n\t\t \n\t\tt = (u64) 2 * 31416 * (freq - fs);\n\t\tt <<= 22;\n\t\tdo_div(t, fs);\n\t\tdo_div(t, 1000);\n\t\tval = t;\n\n\t\tatbm8830_write_reg(priv, REG_TUNER_BASEBAND, 1);\n\t\tatbm8830_write_reg(priv, REG_IF_FREQ, val);\n\t\tatbm8830_write_reg(priv, REG_IF_FREQ+1, val >> 8);\n\t\tatbm8830_write_reg(priv, REG_IF_FREQ+2, val >> 16);\n\n\t\tatbm8830_read_reg(priv, REG_ADC_CONFIG, &dat);\n\t\tdat &= 0xFC;\n\t\tatbm8830_write_reg(priv, REG_ADC_CONFIG, dat);\n\t} else {\n\t\t \n\t\tatbm8830_write_reg(priv, REG_TUNER_BASEBAND, 0);\n\n\t\tatbm8830_read_reg(priv, REG_ADC_CONFIG, &dat);\n\t\tdat &= 0xFC;\n\t\tdat |= 0x02;\n\t\tatbm8830_write_reg(priv, REG_ADC_CONFIG, dat);\n\n\t\tif (priv->config->zif_swap_iq)\n\t\t\tatbm8830_write_reg(priv, REG_SWAP_I_Q, 0x03);\n\t\telse\n\t\t\tatbm8830_write_reg(priv, REG_SWAP_I_Q, 0x01);\n\t}\n\n\treturn 0;\n}\n\nstatic int is_locked(struct atbm_state *priv, u8 *locked)\n{\n\tu8 status;\n\n\tatbm8830_read_reg(priv, REG_LOCK_STATUS, &status);\n\n\tif (locked != NULL)\n\t\t*locked = (status == 1);\n\treturn 0;\n}\n\nstatic int set_agc_config(struct atbm_state *priv,\n\tu8 min, u8 max, u8 hold_loop)\n{\n\t \n\tif (!min && !max)\n\t    return 0;\n\n\tatbm8830_write_reg(priv, REG_AGC_MIN, min);\n\tatbm8830_write_reg(priv, REG_AGC_MAX, max);\n\tatbm8830_write_reg(priv, REG_AGC_HOLD_LOOP, hold_loop);\n\n\treturn 0;\n}\n\nstatic int set_static_channel_mode(struct atbm_state *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < 5; i++)\n\t\tatbm8830_write_reg(priv, 0x099B + i, 0x08);\n\n\tatbm8830_write_reg(priv, 0x095B, 0x7F);\n\tatbm8830_write_reg(priv, 0x09CB, 0x01);\n\tatbm8830_write_reg(priv, 0x09CC, 0x7F);\n\tatbm8830_write_reg(priv, 0x09CD, 0x7F);\n\tatbm8830_write_reg(priv, 0x0E01, 0x20);\n\n\t \n\tatbm8830_write_reg(priv, 0x0B03, 0x0A);\n\tatbm8830_write_reg(priv, 0x0935, 0x10);\n\tatbm8830_write_reg(priv, 0x0936, 0x08);\n\tatbm8830_write_reg(priv, 0x093E, 0x08);\n\tatbm8830_write_reg(priv, 0x096E, 0x06);\n\n\t \n\tatbm8830_write_reg(priv, 0x0B09, 0x00);\n\t \n\tatbm8830_write_reg(priv, 0x0B0A, 0x08);\n\n\treturn 0;\n}\n\nstatic int set_ts_config(struct atbm_state *priv)\n{\n\tconst struct atbm8830_config *cfg = priv->config;\n\n\t \n\tatbm8830_write_reg(priv, REG_TS_SERIAL, cfg->serial_ts ? 1 : 0);\n\tatbm8830_write_reg(priv, REG_TS_CLK_MODE, cfg->serial_ts ? 1 : 0);\n\t \n\tatbm8830_write_reg(priv, REG_TS_SAMPLE_EDGE,\n\t\tcfg->ts_sampling_edge ? 1 : 0);\n\t \n\tatbm8830_write_reg(priv, REG_TS_CLK_FREERUN,\n\t\tcfg->ts_clk_gated ? 0 : 1);\n\n\treturn 0;\n}\n\nstatic int atbm8830_init(struct dvb_frontend *fe)\n{\n\tstruct atbm_state *priv = fe->demodulator_priv;\n\tconst struct atbm8830_config *cfg = priv->config;\n\n\t \n\tset_osc_freq(priv, cfg->osc_clk_freq);\n\n\t \n\tset_if_freq(priv, cfg->if_freq);\n\n\t \n\tset_agc_config(priv, cfg->agc_min, cfg->agc_max,\n\t\tcfg->agc_hold_loop);\n\n\t \n\tset_static_channel_mode(priv);\n\n\tset_ts_config(priv);\n\t \n\tatbm8830_write_reg(priv, 0x000A, 0);\n\n\t \n\tatbm8830_write_reg(priv, 0x020C, 11);\n\n\t \n\tatbm8830_write_reg(priv, REG_DEMOD_RUN, 1);\n\n\treturn 0;\n}\n\n\nstatic void atbm8830_release(struct dvb_frontend *fe)\n{\n\tstruct atbm_state *state = fe->demodulator_priv;\n\tdprintk(\"%s\\n\", __func__);\n\n\tkfree(state);\n}\n\nstatic int atbm8830_set_fe(struct dvb_frontend *fe)\n{\n\tstruct atbm_state *priv = fe->demodulator_priv;\n\tint i;\n\tu8 locked = 0;\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tmdelay(100);\n\t\tdprintk(\"Try %d\\n\", i);\n\t\tis_locked(priv, &locked);\n\t\tif (locked != 0) {\n\t\t\tdprintk(\"ATBM8830 locked!\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int atbm8830_get_fe(struct dvb_frontend *fe,\n\t\t\t   struct dtv_frontend_properties *c)\n{\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\t \n\tc->inversion = INVERSION_OFF;\n\n\t \n\tc->bandwidth_hz = 8000000;\n\n\tc->code_rate_HP = FEC_AUTO;\n\tc->code_rate_LP = FEC_AUTO;\n\n\tc->modulation = QAM_AUTO;\n\n\t \n\tc->transmission_mode = TRANSMISSION_MODE_AUTO;\n\n\t \n\tc->guard_interval = GUARD_INTERVAL_AUTO;\n\n\t \n\tc->hierarchy = HIERARCHY_NONE;\n\n\treturn 0;\n}\n\nstatic int atbm8830_get_tune_settings(struct dvb_frontend *fe,\n\tstruct dvb_frontend_tune_settings *fesettings)\n{\n\tfesettings->min_delay_ms = 0;\n\tfesettings->step_size = 0;\n\tfesettings->max_drift = 0;\n\treturn 0;\n}\n\nstatic int atbm8830_read_status(struct dvb_frontend *fe,\n\t\t\t\tenum fe_status *fe_status)\n{\n\tstruct atbm_state *priv = fe->demodulator_priv;\n\tu8 locked = 0;\n\tu8 agc_locked = 0;\n\n\tdprintk(\"%s\\n\", __func__);\n\t*fe_status = 0;\n\n\tis_locked(priv, &locked);\n\tif (locked) {\n\t\t*fe_status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\tFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\t}\n\tdprintk(\"%s: fe_status=0x%x\\n\", __func__, *fe_status);\n\n\tatbm8830_read_reg(priv, REG_AGC_LOCK, &agc_locked);\n\tdprintk(\"AGC Lock: %d\\n\", agc_locked);\n\n\treturn 0;\n}\n\nstatic int atbm8830_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct atbm_state *priv = fe->demodulator_priv;\n\tu32 frame_err;\n\tu8 t;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tatbm8830_reglatch_lock(priv, 1);\n\n\tatbm8830_read_reg(priv, REG_FRAME_ERR_CNT + 1, &t);\n\tframe_err = t & 0x7F;\n\tframe_err <<= 8;\n\tatbm8830_read_reg(priv, REG_FRAME_ERR_CNT, &t);\n\tframe_err |= t;\n\n\tatbm8830_reglatch_lock(priv, 0);\n\n\t*ber = frame_err * 100 / 32767;\n\n\tdprintk(\"%s: ber=0x%x\\n\", __func__, *ber);\n\treturn 0;\n}\n\nstatic int atbm8830_read_signal_strength(struct dvb_frontend *fe, u16 *signal)\n{\n\tstruct atbm_state *priv = fe->demodulator_priv;\n\tu32 pwm;\n\tu8 t;\n\n\tdprintk(\"%s\\n\", __func__);\n\tatbm8830_reglatch_lock(priv, 1);\n\n\tatbm8830_read_reg(priv, REG_AGC_PWM_VAL + 1, &t);\n\tpwm = t & 0x03;\n\tpwm <<= 8;\n\tatbm8830_read_reg(priv, REG_AGC_PWM_VAL, &t);\n\tpwm |= t;\n\n\tatbm8830_reglatch_lock(priv, 0);\n\n\tdprintk(\"AGC PWM = 0x%02X\\n\", pwm);\n\tpwm = 0x400 - pwm;\n\n\t*signal = pwm * 0x10000 / 0x400;\n\n\treturn 0;\n}\n\nstatic int atbm8830_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tdprintk(\"%s\\n\", __func__);\n\t*snr = 0;\n\treturn 0;\n}\n\nstatic int atbm8830_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tdprintk(\"%s\\n\", __func__);\n\t*ucblocks = 0;\n\treturn 0;\n}\n\nstatic int atbm8830_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct atbm_state *priv = fe->demodulator_priv;\n\n\treturn atbm8830_write_reg(priv, REG_I2C_GATE, enable ? 1 : 0);\n}\n\nstatic const struct dvb_frontend_ops atbm8830_ops = {\n\t.delsys = { SYS_DTMB },\n\t.info = {\n\t\t.name = \"AltoBeam ATBM8830/8831 DMB-TH\",\n\t\t.frequency_min_hz = 474 * MHz,\n\t\t.frequency_max_hz = 858 * MHz,\n\t\t.frequency_stepsize_hz = 10 * kHz,\n\t\t.caps =\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO\n\t},\n\n\t.release = atbm8830_release,\n\n\t.init = atbm8830_init,\n\t.sleep = NULL,\n\t.write = NULL,\n\t.i2c_gate_ctrl = atbm8830_i2c_gate_ctrl,\n\n\t.set_frontend = atbm8830_set_fe,\n\t.get_frontend = atbm8830_get_fe,\n\t.get_tune_settings = atbm8830_get_tune_settings,\n\n\t.read_status = atbm8830_read_status,\n\t.read_ber = atbm8830_read_ber,\n\t.read_signal_strength = atbm8830_read_signal_strength,\n\t.read_snr = atbm8830_read_snr,\n\t.read_ucblocks = atbm8830_read_ucblocks,\n};\n\nstruct dvb_frontend *atbm8830_attach(const struct atbm8830_config *config,\n\tstruct i2c_adapter *i2c)\n{\n\tstruct atbm_state *priv = NULL;\n\tu8 data = 0;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tif (config == NULL || i2c == NULL)\n\t\treturn NULL;\n\n\tpriv = kzalloc(sizeof(struct atbm_state), GFP_KERNEL);\n\tif (priv == NULL)\n\t\tgoto error_out;\n\n\tpriv->config = config;\n\tpriv->i2c = i2c;\n\n\t \n\tif (atbm8830_read_reg(priv, REG_CHIP_ID, &data) != 0) {\n\t\tdprintk(\"%s atbm8830/8831 not found at i2c addr 0x%02X\\n\",\n\t\t\t__func__, priv->config->demod_address);\n\t\tgoto error_out;\n\t}\n\tdprintk(\"atbm8830 chip id: 0x%02X\\n\", data);\n\n\tmemcpy(&priv->frontend.ops, &atbm8830_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\tpriv->frontend.demodulator_priv = priv;\n\n\tatbm8830_init(&priv->frontend);\n\n\tatbm8830_i2c_gate_ctrl(&priv->frontend, 1);\n\n\treturn &priv->frontend;\n\nerror_out:\n\tdprintk(\"%s() error_out\\n\", __func__);\n\tkfree(priv);\n\treturn NULL;\n\n}\nEXPORT_SYMBOL_GPL(atbm8830_attach);\n\nMODULE_DESCRIPTION(\"AltoBeam ATBM8830/8831 GB20600 demodulator driver\");\nMODULE_AUTHOR(\"David T. L. Wong <davidtlwong@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}