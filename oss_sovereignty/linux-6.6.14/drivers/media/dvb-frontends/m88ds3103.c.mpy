{
  "module_name": "m88ds3103.c",
  "hash_id": "40a2661a8004d1dea97e5b43a476e9f815045d14a2980af0e6225691c3f62c0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/m88ds3103.c",
  "human_readable_source": "\n \n\n#include \"m88ds3103_priv.h\"\n\nstatic const struct dvb_frontend_ops m88ds3103_ops;\n\n \nstatic int m88ds3103_update_bits(struct m88ds3103_dev *dev,\n\t\t\t\tu8 reg, u8 mask, u8 val)\n{\n\tint ret;\n\tu8 tmp;\n\n\t \n\tif (mask != 0xff) {\n\t\tret = regmap_bulk_read(dev->regmap, reg, &tmp, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval &= mask;\n\t\ttmp &= ~mask;\n\t\tval |= tmp;\n\t}\n\n\treturn regmap_bulk_write(dev->regmap, reg, &val, 1);\n}\n\n \nstatic int m88ds3103_wr_reg_val_tab(struct m88ds3103_dev *dev,\n\t\tconst struct m88ds3103_reg_val *tab, int tab_len)\n{\n\tstruct i2c_client *client = dev->client;\n\tint ret, i, j;\n\tu8 buf[83];\n\n\tdev_dbg(&client->dev, \"tab_len=%d\\n\", tab_len);\n\n\tif (tab_len > 86) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0, j = 0; i < tab_len; i++, j++) {\n\t\tbuf[j] = tab[i].val;\n\n\t\tif (i == tab_len - 1 || tab[i].reg != tab[i + 1].reg - 1 ||\n\t\t\t\t!((j + 1) % (dev->cfg->i2c_wr_max - 1))) {\n\t\t\tret = regmap_bulk_write(dev->regmap, tab[i].reg - j, buf, j + 1);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tj = -1;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\n \nstatic int m88ds3103b_dt_write(struct m88ds3103_dev *dev, int reg, int data)\n{\n\tstruct i2c_client *client = dev->client;\n\tu8 buf[] = {reg, data};\n\tu8 val;\n\tint ret;\n\tstruct i2c_msg msg = {\n\t\t.addr = dev->dt_addr, .flags = 0, .buf = buf, .len = 2\n\t};\n\n\tm88ds3103_update_bits(dev, 0x11, 0x01, 0x00);\n\n\tval = 0x11;\n\tret = regmap_write(dev->regmap, 0x03, val);\n\tif (ret)\n\t\tdev_dbg(&client->dev, \"fail=%d\\n\", ret);\n\n\tret = i2c_transfer(dev->dt_client->adapter, &msg, 1);\n\tif (ret != 1) {\n\t\tdev_err(&client->dev, \"0x%02x (ret=%i, reg=0x%02x, value=0x%02x)\\n\",\n\t\t\tdev->dt_addr, ret, reg, data);\n\n\t\tm88ds3103_update_bits(dev, 0x11, 0x01, 0x01);\n\t\treturn -EREMOTEIO;\n\t}\n\tm88ds3103_update_bits(dev, 0x11, 0x01, 0x01);\n\n\tdev_dbg(&client->dev, \"0x%02x reg 0x%02x, value 0x%02x\\n\",\n\t\tdev->dt_addr, reg, data);\n\n\treturn 0;\n}\n\n \nstatic int m88ds3103b_dt_read(struct m88ds3103_dev *dev, u8 reg)\n{\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu8 val;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = dev->dt_addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = b0,\n\t\t\t.len = 1\n\t\t},\n\t\t{\n\t\t\t.addr = dev->dt_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = b1,\n\t\t\t.len = 1\n\t\t}\n\t};\n\n\tm88ds3103_update_bits(dev, 0x11, 0x01, 0x00);\n\n\tval = 0x12;\n\tret = regmap_write(dev->regmap, 0x03, val);\n\tif (ret)\n\t\tdev_dbg(&client->dev, \"fail=%d\\n\", ret);\n\n\tret = i2c_transfer(dev->dt_client->adapter, msg, 2);\n\tif (ret != 2) {\n\t\tdev_err(&client->dev, \"0x%02x (ret=%d, reg=0x%02x)\\n\",\n\t\t\tdev->dt_addr, ret, reg);\n\n\t\tm88ds3103_update_bits(dev, 0x11, 0x01, 0x01);\n\t\treturn -EREMOTEIO;\n\t}\n\tm88ds3103_update_bits(dev, 0x11, 0x01, 0x01);\n\n\tdev_dbg(&client->dev, \"0x%02x reg 0x%02x, value 0x%02x\\n\",\n\t\tdev->dt_addr, reg, b1[0]);\n\n\treturn b1[0];\n}\n\n \nint m88ds3103_get_agc_pwm(struct dvb_frontend *fe, u8 *_agc_pwm)\n{\n\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\tunsigned tmp;\n\tint ret;\n\n\tret = regmap_read(dev->regmap, 0x3f, &tmp);\n\tif (ret == 0)\n\t\t*_agc_pwm = tmp;\n\treturn ret;\n}\nEXPORT_SYMBOL(m88ds3103_get_agc_pwm);\n\nstatic int m88ds3103_read_status(struct dvb_frontend *fe,\n\t\t\t\t enum fe_status *status)\n{\n\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i, itmp;\n\tunsigned int utmp;\n\tu8 buf[3];\n\n\t*status = 0;\n\n\tif (!dev->warm) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\tret = regmap_read(dev->regmap, 0xd1, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif ((utmp & 0x07) == 0x07)\n\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t\tFE_HAS_VITERBI | FE_HAS_SYNC |\n\t\t\t\t\tFE_HAS_LOCK;\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tret = regmap_read(dev->regmap, 0x0d, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif ((utmp & 0x8f) == 0x8f)\n\t\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\t\tFE_HAS_VITERBI | FE_HAS_SYNC |\n\t\t\t\t\tFE_HAS_LOCK;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid delivery_system\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdev->fe_status = *status;\n\tdev_dbg(&client->dev, \"lock=%02x status=%02x\\n\", utmp, *status);\n\n\t \n\tif (dev->fe_status & FE_HAS_VITERBI) {\n\t\tunsigned int cnr, noise, signal, noise_tot, signal_tot;\n\n\t\tcnr = 0;\n\t\t \n\t\t#define M88DS3103_SNR_ITERATIONS 3\n\n\t\tswitch (c->delivery_system) {\n\t\tcase SYS_DVBS:\n\t\t\titmp = 0;\n\n\t\t\tfor (i = 0; i < M88DS3103_SNR_ITERATIONS; i++) {\n\t\t\t\tret = regmap_read(dev->regmap, 0xff, &utmp);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err;\n\n\t\t\t\titmp += utmp;\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\titmp = DIV_ROUND_CLOSEST(itmp, 8 * M88DS3103_SNR_ITERATIONS);\n\t\t\tif (itmp)\n\t\t\t\tcnr = div_u64((u64) 10000 * intlog2(itmp), intlog2(10));\n\t\t\tbreak;\n\t\tcase SYS_DVBS2:\n\t\t\tnoise_tot = 0;\n\t\t\tsignal_tot = 0;\n\n\t\t\tfor (i = 0; i < M88DS3103_SNR_ITERATIONS; i++) {\n\t\t\t\tret = regmap_bulk_read(dev->regmap, 0x8c, buf, 3);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tnoise = buf[1] << 6;     \n\t\t\t\tnoise |= buf[0] & 0x3f;  \n\t\t\t\tnoise >>= 2;\n\t\t\t\tsignal = buf[2] * buf[2];\n\t\t\t\tsignal >>= 1;\n\n\t\t\t\tnoise_tot += noise;\n\t\t\t\tsignal_tot += signal;\n\t\t\t}\n\n\t\t\tnoise = noise_tot / M88DS3103_SNR_ITERATIONS;\n\t\t\tsignal = signal_tot / M88DS3103_SNR_ITERATIONS;\n\n\t\t\t \n\t\t\tif (signal > noise) {\n\t\t\t\titmp = signal / noise;\n\t\t\t\tcnr = div_u64((u64) 10000 * intlog10(itmp), (1 << 24));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&client->dev, \"invalid delivery_system\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (cnr) {\n\t\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\t\tc->cnr.stat[0].svalue = cnr;\n\t\t} else {\n\t\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\t}\n\t} else {\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (dev->fe_status & FE_HAS_LOCK) {\n\t\tunsigned int utmp, post_bit_error, post_bit_count;\n\n\t\tswitch (c->delivery_system) {\n\t\tcase SYS_DVBS:\n\t\t\tret = regmap_write(dev->regmap, 0xf9, 0x04);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tret = regmap_read(dev->regmap, 0xf8, &utmp);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\t \n\t\t\tif (!(utmp & 0x10)) {\n\t\t\t\tret = regmap_bulk_read(dev->regmap, 0xf6, buf, 2);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tpost_bit_error = buf[1] << 8 | buf[0] << 0;\n\t\t\t\tpost_bit_count = 0x800000;\n\t\t\t\tdev->post_bit_error += post_bit_error;\n\t\t\t\tdev->post_bit_count += post_bit_count;\n\t\t\t\tdev->dvbv3_ber = post_bit_error;\n\n\t\t\t\t \n\t\t\t\tutmp |= 0x10;\n\t\t\t\tret = regmap_write(dev->regmap, 0xf8, utmp);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SYS_DVBS2:\n\t\t\tret = regmap_bulk_read(dev->regmap, 0xd5, buf, 3);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tutmp = buf[2] << 16 | buf[1] << 8 | buf[0] << 0;\n\n\t\t\t \n\t\t\tif (utmp > 4000) {\n\t\t\t\tret = regmap_bulk_read(dev->regmap, 0xf7, buf, 2);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tpost_bit_error = buf[1] << 8 | buf[0] << 0;\n\t\t\t\tpost_bit_count = 32 * utmp;  \n\t\t\t\tdev->post_bit_error += post_bit_error;\n\t\t\t\tdev->post_bit_count += post_bit_count;\n\t\t\t\tdev->dvbv3_ber = post_bit_error;\n\n\t\t\t\t \n\t\t\t\tret = regmap_write(dev->regmap, 0xd1, 0x01);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tret = regmap_write(dev->regmap, 0xf9, 0x01);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tret = regmap_write(dev->regmap, 0xf9, 0x00);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tret = regmap_write(dev->regmap, 0xd1, 0x00);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&client->dev, \"invalid delivery_system\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[0].uvalue = dev->post_bit_count;\n\t} else {\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88ds3103b_select_mclk(struct m88ds3103_dev *dev)\n{\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\n\tu32 adc_Freq_MHz[3] = {96, 93, 99};\n\tu8  reg16_list[3] = {96, 92, 100}, reg16, reg15;\n\tu32 offset_MHz[3];\n\tu32 max_offset = 0;\n\tu32 old_setting = dev->mclk;\n\tu32 tuner_freq_MHz = c->frequency / 1000;\n\tu8 i;\n\tchar big_symbol = 0;\n\n\tbig_symbol = (c->symbol_rate > 45010000) ? 1 : 0;\n\n\tif (big_symbol) {\n\t\treg16 = 115;\n\t} else {\n\t\treg16 = 96;\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\toffset_MHz[i] = tuner_freq_MHz % adc_Freq_MHz[i];\n\n\t\t\tif (offset_MHz[i] > (adc_Freq_MHz[i] / 2))\n\t\t\t\toffset_MHz[i] = adc_Freq_MHz[i] - offset_MHz[i];\n\n\t\t\tif (offset_MHz[i] > max_offset) {\n\t\t\t\tmax_offset = offset_MHz[i];\n\t\t\t\treg16 = reg16_list[i];\n\t\t\t\tdev->mclk = adc_Freq_MHz[i] * 1000 * 1000;\n\n\t\t\t\tif (big_symbol)\n\t\t\t\t\tdev->mclk /= 2;\n\n\t\t\t\tdev_dbg(&client->dev, \"modifying mclk %u -> %u\\n\",\n\t\t\t\t\told_setting, dev->mclk);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dev->mclk == 93000000)\n\t\tregmap_write(dev->regmap, 0xA0, 0x42);\n\telse if (dev->mclk == 96000000)\n\t\tregmap_write(dev->regmap, 0xA0, 0x44);\n\telse if (dev->mclk == 99000000)\n\t\tregmap_write(dev->regmap, 0xA0, 0x46);\n\telse if (dev->mclk == 110250000)\n\t\tregmap_write(dev->regmap, 0xA0, 0x4E);\n\telse\n\t\tregmap_write(dev->regmap, 0xA0, 0x44);\n\n\treg15 = m88ds3103b_dt_read(dev, 0x15);\n\n\tm88ds3103b_dt_write(dev, 0x05, 0x40);\n\tm88ds3103b_dt_write(dev, 0x11, 0x08);\n\n\tif (big_symbol)\n\t\treg15 |= 0x02;\n\telse\n\t\treg15 &= ~0x02;\n\n\tm88ds3103b_dt_write(dev, 0x15, reg15);\n\tm88ds3103b_dt_write(dev, 0x16, reg16);\n\n\tusleep_range(5000, 5500);\n\n\tm88ds3103b_dt_write(dev, 0x05, 0x00);\n\tm88ds3103b_dt_write(dev, 0x11, (u8)(big_symbol ? 0x0E : 0x0A));\n\n\tusleep_range(5000, 5500);\n\n\treturn 0;\n}\n\nstatic int m88ds3103b_set_mclk(struct m88ds3103_dev *dev, u32 mclk_khz)\n{\n\tu8 reg15, reg16, reg1D, reg1E, reg1F, tmp;\n\tu8 sm, f0 = 0, f1 = 0, f2 = 0, f3 = 0;\n\tu16 pll_div_fb, N;\n\tu32 div;\n\n\treg15 = m88ds3103b_dt_read(dev, 0x15);\n\treg16 = m88ds3103b_dt_read(dev, 0x16);\n\treg1D = m88ds3103b_dt_read(dev, 0x1D);\n\n\tif (dev->cfg->ts_mode != M88DS3103_TS_SERIAL) {\n\t\tif (reg16 == 92)\n\t\t\ttmp = 93;\n\t\telse if (reg16 == 100)\n\t\t\ttmp = 99;\n\t\telse\n\t\t\ttmp = 96;\n\n\t\tmclk_khz *= tmp;\n\t\tmclk_khz /= 96;\n\t}\n\n\tpll_div_fb = (reg15 & 0x01) << 8;\n\tpll_div_fb += reg16;\n\tpll_div_fb += 32;\n\n\tdiv = 9000 * pll_div_fb * 4;\n\tdiv /= mclk_khz;\n\n\tif (dev->cfg->ts_mode == M88DS3103_TS_SERIAL) {\n\t\tif (div <= 32) {\n\t\t\tN = 2;\n\n\t\t\tf0 = 0;\n\t\t\tf1 = div / N;\n\t\t\tf2 = div - f1;\n\t\t\tf3 = 0;\n\t\t} else if (div <= 34) {\n\t\t\tN = 3;\n\n\t\t\tf0 = div / N;\n\t\t\tf1 = (div - f0) / (N - 1);\n\t\t\tf2 = div - f0 - f1;\n\t\t\tf3 = 0;\n\t\t} else if (div <= 64) {\n\t\t\tN = 4;\n\n\t\t\tf0 = div / N;\n\t\t\tf1 = (div - f0) / (N - 1);\n\t\t\tf2 = (div - f0 - f1) / (N - 2);\n\t\t\tf3 = div - f0 - f1 - f2;\n\t\t} else {\n\t\t\tN = 4;\n\n\t\t\tf0 = 16;\n\t\t\tf1 = 16;\n\t\t\tf2 = 16;\n\t\t\tf3 = 16;\n\t\t}\n\n\t\tif (f0 == 16)\n\t\t\tf0 = 0;\n\t\telse if ((f0 < 8) && (f0 != 0))\n\t\t\tf0 = 8;\n\n\t\tif (f1 == 16)\n\t\t\tf1 = 0;\n\t\telse if ((f1 < 8) && (f1 != 0))\n\t\t\tf1 = 8;\n\n\t\tif (f2 == 16)\n\t\t\tf2 = 0;\n\t\telse if ((f2 < 8) && (f2 != 0))\n\t\t\tf2 = 8;\n\n\t\tif (f3 == 16)\n\t\t\tf3 = 0;\n\t\telse if ((f3 < 8) && (f3 != 0))\n\t\t\tf3 = 8;\n\t} else {\n\t\tif (div <= 32) {\n\t\t\tN = 2;\n\n\t\t\tf0 = 0;\n\t\t\tf1 = div / N;\n\t\t\tf2 = div - f1;\n\t\t\tf3 = 0;\n\t\t} else if (div <= 48) {\n\t\t\tN = 3;\n\n\t\t\tf0 = div / N;\n\t\t\tf1 = (div - f0) / (N - 1);\n\t\t\tf2 = div - f0 - f1;\n\t\t\tf3 = 0;\n\t\t} else if (div <= 64) {\n\t\t\tN = 4;\n\n\t\t\tf0 = div / N;\n\t\t\tf1 = (div - f0) / (N - 1);\n\t\t\tf2 = (div - f0 - f1) / (N - 2);\n\t\t\tf3 = div - f0 - f1 - f2;\n\t\t} else {\n\t\t\tN = 4;\n\n\t\t\tf0 = 16;\n\t\t\tf1 = 16;\n\t\t\tf2 = 16;\n\t\t\tf3 = 16;\n\t\t}\n\n\t\tif (f0 == 16)\n\t\t\tf0 = 0;\n\t\telse if ((f0 < 9) && (f0 != 0))\n\t\t\tf0 = 9;\n\n\t\tif (f1 == 16)\n\t\t\tf1 = 0;\n\t\telse if ((f1 < 9) && (f1 != 0))\n\t\t\tf1 = 9;\n\n\t\tif (f2 == 16)\n\t\t\tf2 = 0;\n\t\telse if ((f2 < 9) && (f2 != 0))\n\t\t\tf2 = 9;\n\n\t\tif (f3 == 16)\n\t\t\tf3 = 0;\n\t\telse if ((f3 < 9) && (f3 != 0))\n\t\t\tf3 = 9;\n\t}\n\n\tsm = N - 1;\n\n\t \n\t\n\t\n\n\t\n\n\treg1D &= ~0x03;\n\treg1D |= sm;\n\treg1D |= 0x80;\n\n\treg1E = ((f3 << 4) + f2) & 0xFF;\n\treg1F = ((f1 << 4) + f0) & 0xFF;\n\n\tm88ds3103b_dt_write(dev, 0x05, 0x40);\n\tm88ds3103b_dt_write(dev, 0x11, 0x08);\n\tm88ds3103b_dt_write(dev, 0x1D, reg1D);\n\tm88ds3103b_dt_write(dev, 0x1E, reg1E);\n\tm88ds3103b_dt_write(dev, 0x1F, reg1F);\n\n\tm88ds3103b_dt_write(dev, 0x17, 0xc1);\n\tm88ds3103b_dt_write(dev, 0x17, 0x81);\n\n\tusleep_range(5000, 5500);\n\n\tm88ds3103b_dt_write(dev, 0x05, 0x00);\n\tm88ds3103b_dt_write(dev, 0x11, 0x0A);\n\n\tusleep_range(5000, 5500);\n\n\treturn 0;\n}\n\nstatic int m88ds3103_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, len;\n\tconst struct m88ds3103_reg_val *init;\n\tu8 u8tmp, u8tmp1 = 0, u8tmp2 = 0;  \n\tu8 buf[3];\n\tu16 u16tmp;\n\tu32 tuner_frequency_khz, target_mclk, u32tmp;\n\ts32 s32tmp;\n\tstatic const struct reg_sequence reset_buf[] = {\n\t\t{0x07, 0x80}, {0x07, 0x00}\n\t};\n\n\tdev_dbg(&client->dev,\n\t\t\"delivery_system=%d modulation=%d frequency=%u symbol_rate=%d inversion=%d pilot=%d rolloff=%d\\n\",\n\t\tc->delivery_system, c->modulation, c->frequency, c->symbol_rate,\n\t\tc->inversion, c->pilot, c->rolloff);\n\n\tif (!dev->warm) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\t \n\tret = regmap_multi_reg_write(dev->regmap, reset_buf, 2);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (dev->chip_id == M88RS6000_CHIP_ID) {\n\t\tif (dev->chiptype == M88DS3103_CHIPTYPE_3103B) {\n\t\t\tret = regmap_read(dev->regmap, 0xb2, &u32tmp);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tif (u32tmp == 0x01) {\n\t\t\t\tret = regmap_write(dev->regmap, 0x00, 0x00);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err;\n\t\t\t\tret = regmap_write(dev->regmap, 0xb2, 0x00);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tret = regmap_write(dev->regmap, 0x06, 0xe0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (fe->ops.tuner_ops.get_frequency) {\n\t\tret = fe->ops.tuner_ops.get_frequency(fe, &tuner_frequency_khz);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\t \n\t\ttuner_frequency_khz = c->frequency;\n\t}\n\n\t \n\tif (dev->chip_id == M88RS6000_CHIP_ID) {\n\t\tif (c->symbol_rate > 45010000)\n\t\t\tdev->mclk = 110250000;\n\t\telse\n\t\t\tdev->mclk = 96000000;\n\n\t\tif (c->delivery_system == SYS_DVBS)\n\t\t\ttarget_mclk = 96000000;\n\t\telse\n\t\t\ttarget_mclk = 144000000;\n\n\t\tif (dev->chiptype == M88DS3103_CHIPTYPE_3103B) {\n\t\t\tm88ds3103b_select_mclk(dev);\n\t\t\tm88ds3103b_set_mclk(dev, target_mclk / 1000);\n\t\t}\n\n\t\t \n\t\tret = regmap_write(dev->regmap, 0x06, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tusleep_range(10000, 20000);\n\t} else {\n\t \n\t\tdev->mclk = 96000000;\n\n\t\tswitch (dev->cfg->ts_mode) {\n\t\tcase M88DS3103_TS_SERIAL:\n\t\tcase M88DS3103_TS_SERIAL_D7:\n\t\t\ttarget_mclk = dev->cfg->ts_clk;\n\t\t\tbreak;\n\t\tcase M88DS3103_TS_PARALLEL:\n\t\tcase M88DS3103_TS_CI:\n\t\t\tif (c->delivery_system == SYS_DVBS)\n\t\t\t\ttarget_mclk = 96000000;\n\t\t\telse {\n\t\t\t\tif (c->symbol_rate < 18000000)\n\t\t\t\t\ttarget_mclk = 96000000;\n\t\t\t\telse if (c->symbol_rate < 28000000)\n\t\t\t\t\ttarget_mclk = 144000000;\n\t\t\t\telse\n\t\t\t\t\ttarget_mclk = 192000000;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&client->dev, \"invalid ts_mode\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tswitch (target_mclk) {\n\t\tcase 96000000:\n\t\t\tu8tmp1 = 0x02;  \n\t\t\tu8tmp2 = 0x01;  \n\t\t\tbreak;\n\t\tcase 144000000:\n\t\t\tu8tmp1 = 0x00;  \n\t\t\tu8tmp2 = 0x01;  \n\t\t\tbreak;\n\t\tcase 192000000:\n\t\t\tu8tmp1 = 0x03;  \n\t\t\tu8tmp2 = 0x00;  \n\t\t\tbreak;\n\t\t}\n\t\tret = m88ds3103_update_bits(dev, 0x22, 0xc0, u8tmp1 << 6);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = m88ds3103_update_bits(dev, 0x24, 0xc0, u8tmp2 << 6);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = regmap_write(dev->regmap, 0xb2, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x00, 0x01);\n\tif (ret)\n\t\tgoto err;\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\tif (dev->chip_id == M88RS6000_CHIP_ID) {\n\t\t\tlen = ARRAY_SIZE(m88rs6000_dvbs_init_reg_vals);\n\t\t\tinit = m88rs6000_dvbs_init_reg_vals;\n\t\t} else {\n\t\t\tlen = ARRAY_SIZE(m88ds3103_dvbs_init_reg_vals);\n\t\t\tinit = m88ds3103_dvbs_init_reg_vals;\n\t\t}\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tif (dev->chip_id == M88RS6000_CHIP_ID) {\n\t\t\tlen = ARRAY_SIZE(m88rs6000_dvbs2_init_reg_vals);\n\t\t\tinit = m88rs6000_dvbs2_init_reg_vals;\n\t\t} else {\n\t\t\tlen = ARRAY_SIZE(m88ds3103_dvbs2_init_reg_vals);\n\t\t\tinit = m88ds3103_dvbs2_init_reg_vals;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid delivery_system\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif (c->delivery_system != dev->delivery_system) {\n\t\tret = m88ds3103_wr_reg_val_tab(dev, init, len);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (dev->chip_id == M88RS6000_CHIP_ID) {\n\t\tif (c->delivery_system == SYS_DVBS2 &&\n\t\t    c->symbol_rate <= 5000000) {\n\t\t\tret = regmap_write(dev->regmap, 0xc0, 0x04);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tbuf[0] = 0x09;\n\t\t\tbuf[1] = 0x22;\n\t\t\tbuf[2] = 0x88;\n\t\t\tret = regmap_bulk_write(dev->regmap, 0x8a, buf, 3);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t\tret = m88ds3103_update_bits(dev, 0x9d, 0x08, 0x08);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (dev->chiptype == M88DS3103_CHIPTYPE_3103B) {\n\t\t\tbuf[0] = m88ds3103b_dt_read(dev, 0x15);\n\t\t\tbuf[1] = m88ds3103b_dt_read(dev, 0x16);\n\n\t\t\tif (c->symbol_rate > 45010000) {\n\t\t\t\tbuf[0] &= ~0x03;\n\t\t\t\tbuf[0] |= 0x02;\n\t\t\t\tbuf[0] |= ((147 - 32) >> 8) & 0x01;\n\t\t\t\tbuf[1] = (147 - 32) & 0xFF;\n\n\t\t\t\tdev->mclk = 110250 * 1000;\n\t\t\t} else {\n\t\t\t\tbuf[0] &= ~0x03;\n\t\t\t\tbuf[0] |= ((128 - 32) >> 8) & 0x01;\n\t\t\t\tbuf[1] = (128 - 32) & 0xFF;\n\n\t\t\t\tdev->mclk = 96000 * 1000;\n\t\t\t}\n\t\t\tm88ds3103b_dt_write(dev, 0x15, buf[0]);\n\t\t\tm88ds3103b_dt_write(dev, 0x16, buf[1]);\n\n\t\t\tregmap_read(dev->regmap, 0x30, &u32tmp);\n\t\t\tu32tmp &= ~0x80;\n\t\t\tregmap_write(dev->regmap, 0x30, u32tmp & 0xff);\n\t\t}\n\n\t\tret = regmap_write(dev->regmap, 0xf1, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (dev->chiptype != M88DS3103_CHIPTYPE_3103B) {\n\t\t\tret = m88ds3103_update_bits(dev, 0x30, 0x80, 0x80);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tswitch (dev->cfg->ts_mode) {\n\tcase M88DS3103_TS_SERIAL:\n\t\tu8tmp1 = 0x00;\n\t\tu8tmp = 0x06;\n\t\tbreak;\n\tcase M88DS3103_TS_SERIAL_D7:\n\t\tu8tmp1 = 0x20;\n\t\tu8tmp = 0x06;\n\t\tbreak;\n\tcase M88DS3103_TS_PARALLEL:\n\t\tu8tmp = 0x02;\n\t\tif (dev->chiptype == M88DS3103_CHIPTYPE_3103B) {\n\t\t\tu8tmp = 0x01;\n\t\t\tu8tmp1 = 0x01;\n\t\t}\n\t\tbreak;\n\tcase M88DS3103_TS_CI:\n\t\tu8tmp = 0x03;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid ts_mode\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (dev->cfg->ts_clk_pol)\n\t\tu8tmp |= 0x40;\n\n\t \n\tret = regmap_write(dev->regmap, 0xfd, u8tmp);\n\tif (ret)\n\t\tgoto err;\n\n\tswitch (dev->cfg->ts_mode) {\n\tcase M88DS3103_TS_SERIAL:\n\tcase M88DS3103_TS_SERIAL_D7:\n\t\tret = m88ds3103_update_bits(dev, 0x29, 0x20, u8tmp1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tu16tmp = 0;\n\t\tu8tmp1 = 0x3f;\n\t\tu8tmp2 = 0x3f;\n\t\tbreak;\n\tcase M88DS3103_TS_PARALLEL:\n\t\tif (dev->chiptype == M88DS3103_CHIPTYPE_3103B) {\n\t\t\tret = m88ds3103_update_bits(dev, 0x29, 0x01, u8tmp1);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tu16tmp = DIV_ROUND_UP(target_mclk, dev->cfg->ts_clk);\n\t\tu8tmp1 = u16tmp / 2 - 1;\n\t\tu8tmp2 = DIV_ROUND_UP(u16tmp, 2) - 1;\n\t}\n\n\tdev_dbg(&client->dev, \"target_mclk=%u ts_clk=%u ts_clk_divide_ratio=%u\\n\",\n\t\ttarget_mclk, dev->cfg->ts_clk, u16tmp);\n\n\t \n\t \n\tu8tmp = (u8tmp1 >> 2) & 0x0f;\n\tret = regmap_update_bits(dev->regmap, 0xfe, 0x0f, u8tmp);\n\tif (ret)\n\t\tgoto err;\n\tu8tmp = ((u8tmp1 & 0x03) << 6) | u8tmp2 >> 0;\n\tret = regmap_write(dev->regmap, 0xea, u8tmp);\n\tif (ret)\n\t\tgoto err;\n\n\tif (c->symbol_rate <= 3000000)\n\t\tu8tmp = 0x20;\n\telse if (c->symbol_rate <= 10000000)\n\t\tu8tmp = 0x10;\n\telse\n\t\tu8tmp = 0x06;\n\n\tif (dev->chiptype == M88DS3103_CHIPTYPE_3103B)\n\t\tm88ds3103b_set_mclk(dev, target_mclk / 1000);\n\n\tret = regmap_write(dev->regmap, 0xc3, 0x08);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0xc8, u8tmp);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0xc4, 0x08);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0xc7, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tu16tmp = DIV_ROUND_CLOSEST_ULL((u64)c->symbol_rate * 0x10000, dev->mclk);\n\tbuf[0] = (u16tmp >> 0) & 0xff;\n\tbuf[1] = (u16tmp >> 8) & 0xff;\n\tret = regmap_bulk_write(dev->regmap, 0x61, buf, 2);\n\tif (ret)\n\t\tgoto err;\n\n\tret = m88ds3103_update_bits(dev, 0x4d, 0x02, dev->cfg->spec_inv << 1);\n\tif (ret)\n\t\tgoto err;\n\n\tret = m88ds3103_update_bits(dev, 0x30, 0x10, dev->cfg->agc_inv << 4);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x33, dev->cfg->agc);\n\tif (ret)\n\t\tgoto err;\n\n\tif (dev->chiptype == M88DS3103_CHIPTYPE_3103B) {\n\t\t \n\t\tret = m88ds3103_update_bits(dev, 0x29, 0x10,\n\t\t\t\t(c->delivery_system == SYS_DVBS) ? 0x10 : 0x0);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = m88ds3103_update_bits(dev, 0xc9, 0x08, 0x08);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tdev_dbg(&client->dev, \"carrier offset=%d\\n\",\n\t\t(tuner_frequency_khz - c->frequency));\n\n\t \n\ts32tmp = 0x10000 * (tuner_frequency_khz - c->frequency);\n\ts32tmp = DIV_ROUND_CLOSEST(s32tmp, dev->mclk / 1000);\n\tbuf[0] = (s32tmp >> 0) & 0xff;\n\tbuf[1] = (s32tmp >> 8) & 0xff;\n\tret = regmap_bulk_write(dev->regmap, 0x5e, buf, 2);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0x00, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0xb2, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\tdev->delivery_system = c->delivery_system;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88ds3103_init(struct dvb_frontend *fe)\n{\n\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, len, rem;\n\tunsigned int utmp;\n\tconst struct firmware *firmware;\n\tconst char *name;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tdev->warm = false;\n\n\t \n\tret = m88ds3103_update_bits(dev, 0x08, 0x01, 0x01);\n\tif (ret)\n\t\tgoto err;\n\tret = m88ds3103_update_bits(dev, 0x04, 0x01, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = m88ds3103_update_bits(dev, 0x23, 0x10, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_read(dev->regmap, 0xb9, &utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_dbg(&client->dev, \"firmware=%02x\\n\", utmp);\n\n\tif (utmp)\n\t\tgoto warm;\n\n\t \n\tret = regmap_write(dev->regmap, 0x07, 0xe0);\n\tif (ret)\n\t\tgoto err;\n\tret = regmap_write(dev->regmap, 0x07, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tdev_info(&client->dev, \"found a '%s' in cold state\\n\",\n\t\t dev->fe.ops.info.name);\n\n\tif (dev->chiptype == M88DS3103_CHIPTYPE_3103B)\n\t\tname = M88DS3103B_FIRMWARE;\n\telse if (dev->chip_id == M88RS6000_CHIP_ID)\n\t\tname = M88RS6000_FIRMWARE;\n\telse\n\t\tname = M88DS3103_FIRMWARE;\n\n\t \n\tret = request_firmware(&firmware, name, &client->dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"firmware file '%s' not found\\n\", name);\n\t\tgoto err;\n\t}\n\n\tdev_info(&client->dev, \"downloading firmware from file '%s'\\n\", name);\n\n\tret = regmap_write(dev->regmap, 0xb2, 0x01);\n\tif (ret)\n\t\tgoto err_release_firmware;\n\n\tfor (rem = firmware->size; rem > 0; rem -= (dev->cfg->i2c_wr_max - 1)) {\n\t\tlen = min(dev->cfg->i2c_wr_max - 1, rem);\n\t\tret = regmap_bulk_write(dev->regmap, 0xb0,\n\t\t\t\t\t&firmware->data[firmware->size - rem],\n\t\t\t\t\tlen);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"firmware download failed %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_release_firmware;\n\t\t}\n\t}\n\n\tret = regmap_write(dev->regmap, 0xb2, 0x00);\n\tif (ret)\n\t\tgoto err_release_firmware;\n\n\trelease_firmware(firmware);\n\n\tret = regmap_read(dev->regmap, 0xb9, &utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tif (!utmp) {\n\t\tret = -EINVAL;\n\t\tdev_info(&client->dev, \"firmware did not run\\n\");\n\t\tgoto err;\n\t}\n\n\tdev_info(&client->dev, \"found a '%s' in warm state\\n\",\n\t\t dev->fe.ops.info.name);\n\tdev_info(&client->dev, \"firmware version: %X.%X\\n\",\n\t\t (utmp >> 4) & 0xf, (utmp >> 0 & 0xf));\n\n\tif (dev->chiptype == M88DS3103_CHIPTYPE_3103B) {\n\t\tm88ds3103b_dt_write(dev, 0x21, 0x92);\n\t\tm88ds3103b_dt_write(dev, 0x15, 0x6C);\n\t\tm88ds3103b_dt_write(dev, 0x17, 0xC1);\n\t\tm88ds3103b_dt_write(dev, 0x17, 0x81);\n\t}\nwarm:\n\t \n\tdev->warm = true;\n\n\t \n\tc->cnr.len = 1;\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.len = 1;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\treturn 0;\nerr_release_firmware:\n\trelease_firmware(firmware);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88ds3103_sleep(struct dvb_frontend *fe)\n{\n\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tunsigned int utmp;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tdev->fe_status = 0;\n\tdev->delivery_system = SYS_UNDEFINED;\n\n\t \n\tif (dev->chip_id == M88RS6000_CHIP_ID)\n\t\tutmp = 0x29;\n\telse\n\t\tutmp = 0x27;\n\tret = m88ds3103_update_bits(dev, utmp, 0x01, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = m88ds3103_update_bits(dev, 0x08, 0x01, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = m88ds3103_update_bits(dev, 0x04, 0x01, 0x01);\n\tif (ret)\n\t\tgoto err;\n\tret = m88ds3103_update_bits(dev, 0x23, 0x10, 0x10);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88ds3103_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t  struct dtv_frontend_properties *c)\n{\n\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu8 buf[3];\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tif (!dev->warm || !(dev->fe_status & FE_HAS_LOCK)) {\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\tret = regmap_bulk_read(dev->regmap, 0xe0, &buf[0], 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = regmap_bulk_read(dev->regmap, 0xe6, &buf[1], 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tswitch ((buf[0] >> 2) & 0x01) {\n\t\tcase 0:\n\t\t\tc->inversion = INVERSION_OFF;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tc->inversion = INVERSION_ON;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch ((buf[1] >> 5) & 0x07) {\n\t\tcase 0:\n\t\t\tc->fec_inner = FEC_7_8;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tc->fec_inner = FEC_5_6;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tc->fec_inner = FEC_3_4;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tc->fec_inner = FEC_2_3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tc->fec_inner = FEC_1_2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&client->dev, \"invalid fec_inner\\n\");\n\t\t}\n\n\t\tc->modulation = QPSK;\n\n\t\tbreak;\n\tcase SYS_DVBS2:\n\t\tret = regmap_bulk_read(dev->regmap, 0x7e, &buf[0], 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = regmap_bulk_read(dev->regmap, 0x89, &buf[1], 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = regmap_bulk_read(dev->regmap, 0xf2, &buf[2], 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tswitch ((buf[0] >> 0) & 0x0f) {\n\t\tcase 2:\n\t\t\tc->fec_inner = FEC_2_5;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tc->fec_inner = FEC_1_2;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tc->fec_inner = FEC_3_5;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tc->fec_inner = FEC_2_3;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tc->fec_inner = FEC_3_4;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tc->fec_inner = FEC_4_5;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tc->fec_inner = FEC_5_6;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tc->fec_inner = FEC_8_9;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tc->fec_inner = FEC_9_10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&client->dev, \"invalid fec_inner\\n\");\n\t\t}\n\n\t\tswitch ((buf[0] >> 5) & 0x01) {\n\t\tcase 0:\n\t\t\tc->pilot = PILOT_OFF;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tc->pilot = PILOT_ON;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch ((buf[0] >> 6) & 0x07) {\n\t\tcase 0:\n\t\t\tc->modulation = QPSK;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tc->modulation = PSK_8;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tc->modulation = APSK_16;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tc->modulation = APSK_32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&client->dev, \"invalid modulation\\n\");\n\t\t}\n\n\t\tswitch ((buf[1] >> 7) & 0x01) {\n\t\tcase 0:\n\t\t\tc->inversion = INVERSION_OFF;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tc->inversion = INVERSION_ON;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch ((buf[2] >> 0) & 0x03) {\n\t\tcase 0:\n\t\t\tc->rolloff = ROLLOFF_35;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tc->rolloff = ROLLOFF_25;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tc->rolloff = ROLLOFF_20;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&client->dev, \"invalid rolloff\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid delivery_system\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = regmap_bulk_read(dev->regmap, 0x6d, buf, 2);\n\tif (ret)\n\t\tgoto err;\n\n\tc->symbol_rate = DIV_ROUND_CLOSEST_ULL((u64)(buf[1] << 8 | buf[0] << 0) * dev->mclk, 0x10000);\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88ds3103_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL)\n\t\t*snr = div_s64(c->cnr.stat[0].svalue, 100);\n\telse\n\t\t*snr = 0;\n\n\treturn 0;\n}\n\nstatic int m88ds3103_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\n\t*ber = dev->dvbv3_ber;\n\n\treturn 0;\n}\n\nstatic int m88ds3103_set_tone(struct dvb_frontend *fe,\n\tenum fe_sec_tone_mode fe_sec_tone_mode)\n{\n\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tunsigned int utmp, tone, reg_a1_mask;\n\n\tdev_dbg(&client->dev, \"fe_sec_tone_mode=%d\\n\", fe_sec_tone_mode);\n\n\tif (!dev->warm) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tswitch (fe_sec_tone_mode) {\n\tcase SEC_TONE_ON:\n\t\ttone = 0;\n\t\treg_a1_mask = 0x47;\n\t\tbreak;\n\tcase SEC_TONE_OFF:\n\t\ttone = 1;\n\t\treg_a1_mask = 0x00;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid fe_sec_tone_mode\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tutmp = tone << 7 | dev->cfg->envelope_mode << 5;\n\tret = m88ds3103_update_bits(dev, 0xa2, 0xe0, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tutmp = 1 << 2;\n\tret = m88ds3103_update_bits(dev, 0xa1, reg_a1_mask, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88ds3103_set_voltage(struct dvb_frontend *fe,\n\tenum fe_sec_voltage fe_sec_voltage)\n{\n\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tunsigned int utmp;\n\tbool voltage_sel, voltage_dis;\n\n\tdev_dbg(&client->dev, \"fe_sec_voltage=%d\\n\", fe_sec_voltage);\n\n\tif (!dev->warm) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tswitch (fe_sec_voltage) {\n\tcase SEC_VOLTAGE_18:\n\t\tvoltage_sel = true;\n\t\tvoltage_dis = false;\n\t\tbreak;\n\tcase SEC_VOLTAGE_13:\n\t\tvoltage_sel = false;\n\t\tvoltage_dis = false;\n\t\tbreak;\n\tcase SEC_VOLTAGE_OFF:\n\t\tvoltage_sel = false;\n\t\tvoltage_dis = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid fe_sec_voltage\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tvoltage_sel ^= dev->cfg->lnb_hv_pol;\n\tvoltage_dis ^= dev->cfg->lnb_en_pol;\n\n\tutmp = voltage_dis << 1 | voltage_sel << 0;\n\tret = m88ds3103_update_bits(dev, 0xa2, 0x03, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88ds3103_diseqc_send_master_cmd(struct dvb_frontend *fe,\n\t\tstruct dvb_diseqc_master_cmd *diseqc_cmd)\n{\n\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tunsigned int utmp;\n\tunsigned long timeout;\n\n\tdev_dbg(&client->dev, \"msg=%*ph\\n\",\n\t\tdiseqc_cmd->msg_len, diseqc_cmd->msg);\n\n\tif (!dev->warm) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tif (diseqc_cmd->msg_len < 3 || diseqc_cmd->msg_len > 6) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tutmp = dev->cfg->envelope_mode << 5;\n\tret = m88ds3103_update_bits(dev, 0xa2, 0xe0, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_write(dev->regmap, 0xa3, diseqc_cmd->msg,\n\t\t\tdiseqc_cmd->msg_len);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(dev->regmap, 0xa1,\n\t\t\t(diseqc_cmd->msg_len - 1) << 3 | 0x07);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\t#define SEND_MASTER_CMD_TIMEOUT 120\n\ttimeout = jiffies + msecs_to_jiffies(SEND_MASTER_CMD_TIMEOUT);\n\n\t \n\tutmp = diseqc_cmd->msg_len * 13500;\n\tusleep_range(utmp - 4000, utmp);\n\n\tfor (utmp = 1; !time_after(jiffies, timeout) && utmp;) {\n\t\tret = regmap_read(dev->regmap, 0xa1, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tutmp = (utmp >> 6) & 0x1;\n\t}\n\n\tif (utmp == 0) {\n\t\tdev_dbg(&client->dev, \"diseqc tx took %u ms\\n\",\n\t\t\tjiffies_to_msecs(jiffies) -\n\t\t\t(jiffies_to_msecs(timeout) - SEND_MASTER_CMD_TIMEOUT));\n\t} else {\n\t\tdev_dbg(&client->dev, \"diseqc tx timeout\\n\");\n\n\t\tret = m88ds3103_update_bits(dev, 0xa1, 0xc0, 0x40);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = m88ds3103_update_bits(dev, 0xa2, 0xc0, 0x80);\n\tif (ret)\n\t\tgoto err;\n\n\tif (utmp == 1) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88ds3103_diseqc_send_burst(struct dvb_frontend *fe,\n\tenum fe_sec_mini_cmd fe_sec_mini_cmd)\n{\n\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tunsigned int utmp, burst;\n\tunsigned long timeout;\n\n\tdev_dbg(&client->dev, \"fe_sec_mini_cmd=%d\\n\", fe_sec_mini_cmd);\n\n\tif (!dev->warm) {\n\t\tret = -EAGAIN;\n\t\tgoto err;\n\t}\n\n\tutmp = dev->cfg->envelope_mode << 5;\n\tret = m88ds3103_update_bits(dev, 0xa2, 0xe0, utmp);\n\tif (ret)\n\t\tgoto err;\n\n\tswitch (fe_sec_mini_cmd) {\n\tcase SEC_MINI_A:\n\t\tburst = 0x02;\n\t\tbreak;\n\tcase SEC_MINI_B:\n\t\tburst = 0x01;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&client->dev, \"invalid fe_sec_mini_cmd\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = regmap_write(dev->regmap, 0xa1, burst);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\t#define SEND_BURST_TIMEOUT 40\n\ttimeout = jiffies + msecs_to_jiffies(SEND_BURST_TIMEOUT);\n\n\t \n\tusleep_range(8500, 12500);\n\n\tfor (utmp = 1; !time_after(jiffies, timeout) && utmp;) {\n\t\tret = regmap_read(dev->regmap, 0xa1, &utmp);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tutmp = (utmp >> 6) & 0x1;\n\t}\n\n\tif (utmp == 0) {\n\t\tdev_dbg(&client->dev, \"diseqc tx took %u ms\\n\",\n\t\t\tjiffies_to_msecs(jiffies) -\n\t\t\t(jiffies_to_msecs(timeout) - SEND_BURST_TIMEOUT));\n\t} else {\n\t\tdev_dbg(&client->dev, \"diseqc tx timeout\\n\");\n\n\t\tret = m88ds3103_update_bits(dev, 0xa1, 0xc0, 0x40);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = m88ds3103_update_bits(dev, 0xa2, 0xc0, 0x80);\n\tif (ret)\n\t\tgoto err;\n\n\tif (utmp == 1) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int m88ds3103_get_tune_settings(struct dvb_frontend *fe,\n\tstruct dvb_frontend_tune_settings *s)\n{\n\ts->min_delay_ms = 3000;\n\n\treturn 0;\n}\n\nstatic void m88ds3103_release(struct dvb_frontend *fe)\n{\n\tstruct m88ds3103_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\n\ti2c_unregister_device(client);\n}\n\nstatic int m88ds3103_select(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct m88ds3103_dev *dev = i2c_mux_priv(muxc);\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tstruct i2c_msg msg = {\n\t\t.addr = client->addr,\n\t\t.flags = 0,\n\t\t.len = 2,\n\t\t.buf = \"\\x03\\x11\",\n\t};\n\n\t \n\tret = __i2c_transfer(client->adapter, &msg, 1);\n\tif (ret != 1) {\n\t\tdev_warn(&client->dev, \"i2c wr failed=%d\\n\", ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EREMOTEIO;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstruct dvb_frontend *m88ds3103_attach(const struct m88ds3103_config *cfg,\n\t\t\t\t      struct i2c_adapter *i2c,\n\t\t\t\t      struct i2c_adapter **tuner_i2c_adapter)\n{\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\tstruct m88ds3103_platform_data pdata = {};\n\n\tpdata.clk = cfg->clock;\n\tpdata.i2c_wr_max = cfg->i2c_wr_max;\n\tpdata.ts_mode = cfg->ts_mode;\n\tpdata.ts_clk = cfg->ts_clk;\n\tpdata.ts_clk_pol = cfg->ts_clk_pol;\n\tpdata.spec_inv = cfg->spec_inv;\n\tpdata.agc = cfg->agc;\n\tpdata.agc_inv = cfg->agc_inv;\n\tpdata.clk_out = cfg->clock_out;\n\tpdata.envelope_mode = cfg->envelope_mode;\n\tpdata.lnb_hv_pol = cfg->lnb_hv_pol;\n\tpdata.lnb_en_pol = cfg->lnb_en_pol;\n\tpdata.attach_in_use = true;\n\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrscpy(board_info.type, \"m88ds3103\", I2C_NAME_SIZE);\n\tboard_info.addr = cfg->i2c_addr;\n\tboard_info.platform_data = &pdata;\n\tclient = i2c_new_client_device(i2c, &board_info);\n\tif (!i2c_client_has_driver(client))\n\t\treturn NULL;\n\n\t*tuner_i2c_adapter = pdata.get_i2c_adapter(client);\n\treturn pdata.get_dvb_frontend(client);\n}\nEXPORT_SYMBOL_GPL(m88ds3103_attach);\n\nstatic const struct dvb_frontend_ops m88ds3103_ops = {\n\t.delsys = {SYS_DVBS, SYS_DVBS2},\n\t.info = {\n\t\t.name = \"Montage Technology M88DS3103\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t\t.frequency_tolerance_hz = 5 * MHz,\n\t\t.symbol_rate_min =  1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 |\n\t\t\tFE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_4_5 |\n\t\t\tFE_CAN_FEC_5_6 |\n\t\t\tFE_CAN_FEC_6_7 |\n\t\t\tFE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_8_9 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK |\n\t\t\tFE_CAN_RECOVER |\n\t\t\tFE_CAN_2G_MODULATION\n\t},\n\n\t.release = m88ds3103_release,\n\n\t.get_tune_settings = m88ds3103_get_tune_settings,\n\n\t.init = m88ds3103_init,\n\t.sleep = m88ds3103_sleep,\n\n\t.set_frontend = m88ds3103_set_frontend,\n\t.get_frontend = m88ds3103_get_frontend,\n\n\t.read_status = m88ds3103_read_status,\n\t.read_snr = m88ds3103_read_snr,\n\t.read_ber = m88ds3103_read_ber,\n\n\t.diseqc_send_master_cmd = m88ds3103_diseqc_send_master_cmd,\n\t.diseqc_send_burst = m88ds3103_diseqc_send_burst,\n\n\t.set_tone = m88ds3103_set_tone,\n\t.set_voltage = m88ds3103_set_voltage,\n};\n\nstatic struct dvb_frontend *m88ds3103_get_dvb_frontend(struct i2c_client *client)\n{\n\tstruct m88ds3103_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\treturn &dev->fe;\n}\n\nstatic struct i2c_adapter *m88ds3103_get_i2c_adapter(struct i2c_client *client)\n{\n\tstruct m88ds3103_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\treturn dev->muxc->adapter[0];\n}\n\nstatic int m88ds3103_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct m88ds3103_dev *dev;\n\tstruct m88ds3103_platform_data *pdata = client->dev.platform_data;\n\tint ret;\n\tunsigned int utmp;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev->client = client;\n\tdev->config.clock = pdata->clk;\n\tdev->config.i2c_wr_max = pdata->i2c_wr_max;\n\tdev->config.ts_mode = pdata->ts_mode;\n\tdev->config.ts_clk = pdata->ts_clk * 1000;\n\tdev->config.ts_clk_pol = pdata->ts_clk_pol;\n\tdev->config.spec_inv = pdata->spec_inv;\n\tdev->config.agc_inv = pdata->agc_inv;\n\tdev->config.clock_out = pdata->clk_out;\n\tdev->config.envelope_mode = pdata->envelope_mode;\n\tdev->config.agc = pdata->agc;\n\tdev->config.lnb_hv_pol = pdata->lnb_hv_pol;\n\tdev->config.lnb_en_pol = pdata->lnb_en_pol;\n\tdev->cfg = &dev->config;\n\t \n\tdev->regmap_config.reg_bits = 8;\n\tdev->regmap_config.val_bits = 8;\n\tdev->regmap_config.lock_arg = dev;\n\tdev->regmap = devm_regmap_init_i2c(client, &dev->regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tret = regmap_read(dev->regmap, 0x00, &utmp);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\tdev->chip_id = utmp >> 1;\n\tdev->chiptype = (u8)id->driver_data;\n\n\tdev_dbg(&client->dev, \"chip_id=%02x\\n\", dev->chip_id);\n\n\tswitch (dev->chip_id) {\n\tcase M88RS6000_CHIP_ID:\n\tcase M88DS3103_CHIP_ID:\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t\tdev_err(&client->dev, \"Unknown device. Chip_id=%02x\\n\", dev->chip_id);\n\t\tgoto err_kfree;\n\t}\n\n\tswitch (dev->cfg->clock_out) {\n\tcase M88DS3103_CLOCK_OUT_DISABLED:\n\t\tutmp = 0x80;\n\t\tbreak;\n\tcase M88DS3103_CLOCK_OUT_ENABLED:\n\t\tutmp = 0x00;\n\t\tbreak;\n\tcase M88DS3103_CLOCK_OUT_ENABLED_DIV2:\n\t\tutmp = 0x10;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_kfree;\n\t}\n\n\tif (!pdata->ts_clk) {\n\t\tret = -EINVAL;\n\t\tgoto err_kfree;\n\t}\n\n\t \n\t \n\tif (dev->chip_id == M88RS6000_CHIP_ID)\n\t\tutmp = 0x00;\n\n\tret = regmap_write(dev->regmap, 0x29, utmp);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\t \n\tret = m88ds3103_update_bits(dev, 0x08, 0x01, 0x00);\n\tif (ret)\n\t\tgoto err_kfree;\n\tret = m88ds3103_update_bits(dev, 0x04, 0x01, 0x01);\n\tif (ret)\n\t\tgoto err_kfree;\n\tret = m88ds3103_update_bits(dev, 0x23, 0x10, 0x10);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\t \n\tdev->muxc = i2c_mux_alloc(client->adapter, &client->dev, 1, 0, 0,\n\t\t\t\t  m88ds3103_select, NULL);\n\tif (!dev->muxc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_kfree;\n\t}\n\tdev->muxc->priv = dev;\n\tret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\t \n\tmemcpy(&dev->fe.ops, &m88ds3103_ops, sizeof(struct dvb_frontend_ops));\n\tif (dev->chiptype == M88DS3103_CHIPTYPE_3103B)\n\t\tstrscpy(dev->fe.ops.info.name, \"Montage Technology M88DS3103B\",\n\t\t\tsizeof(dev->fe.ops.info.name));\n\telse if (dev->chip_id == M88RS6000_CHIP_ID)\n\t\tstrscpy(dev->fe.ops.info.name, \"Montage Technology M88RS6000\",\n\t\t\tsizeof(dev->fe.ops.info.name));\n\tif (!pdata->attach_in_use)\n\t\tdev->fe.ops.release = NULL;\n\tdev->fe.demodulator_priv = dev;\n\ti2c_set_clientdata(client, dev);\n\n\t \n\tpdata->get_dvb_frontend = m88ds3103_get_dvb_frontend;\n\tpdata->get_i2c_adapter = m88ds3103_get_i2c_adapter;\n\n\tif (dev->chiptype == M88DS3103_CHIPTYPE_3103B) {\n\t\t \n\t\tm88ds3103_update_bits(dev, 0x11, 0x01, 0x01);\n\n\t\t \n\t\tret = regmap_read(dev->regmap, 0x29, &utmp);\n\t\tif (ret)\n\t\t\tgoto err_del_adapters;\n\t\tdev->dt_addr = ((utmp & 0x80) == 0) ? 0x42 >> 1 : 0x40 >> 1;\n\t\tdev_dbg(&client->dev, \"dt addr is 0x%02x\\n\", dev->dt_addr);\n\n\t\tdev->dt_client = i2c_new_dummy_device(client->adapter,\n\t\t\t\t\t\t      dev->dt_addr);\n\t\tif (IS_ERR(dev->dt_client)) {\n\t\t\tret = PTR_ERR(dev->dt_client);\n\t\t\tgoto err_del_adapters;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_del_adapters:\n\ti2c_mux_del_adapters(dev->muxc);\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void m88ds3103_remove(struct i2c_client *client)\n{\n\tstruct m88ds3103_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tif (dev->dt_client)\n\t\ti2c_unregister_device(dev->dt_client);\n\n\ti2c_mux_del_adapters(dev->muxc);\n\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id m88ds3103_id_table[] = {\n\t{\"m88ds3103\",  M88DS3103_CHIPTYPE_3103},\n\t{\"m88rs6000\",  M88DS3103_CHIPTYPE_RS6000},\n\t{\"m88ds3103b\", M88DS3103_CHIPTYPE_3103B},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, m88ds3103_id_table);\n\nstatic struct i2c_driver m88ds3103_driver = {\n\t.driver = {\n\t\t.name\t= \"m88ds3103\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= m88ds3103_probe,\n\t.remove\t\t= m88ds3103_remove,\n\t.id_table\t= m88ds3103_id_table,\n};\n\nmodule_i2c_driver(m88ds3103_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Montage Technology M88DS3103 DVB-S/S2 demodulator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(M88DS3103_FIRMWARE);\nMODULE_FIRMWARE(M88RS6000_FIRMWARE);\nMODULE_FIRMWARE(M88DS3103B_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}