{
  "module_name": "cx24123.c",
  "hash_id": "e8a2e71cd00b89d3c639c263b6389e0be35f6fbd1e9c028ee2f19b1444955784",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/cx24123.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"cx24123.h\"\n\n#define XTAL 10111000\n\nstatic int force_band;\nmodule_param(force_band, int, 0644);\nMODULE_PARM_DESC(force_band, \"Force a specific band select \"\\\n\t\"(1-9, default:off).\");\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Activates frontend debugging (default:0)\");\n\n#define info(args...) do { printk(KERN_INFO \"CX24123: \" args); } while (0)\n#define err(args...)  do { printk(KERN_ERR  \"CX24123: \" args); } while (0)\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) { \\\n\t\t\tprintk(KERN_DEBUG \"CX24123: %s: \", __func__); \\\n\t\t\tprintk(args); \\\n\t\t} \\\n\t} while (0)\n\nstruct cx24123_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct cx24123_config *config;\n\n\tstruct dvb_frontend frontend;\n\n\t \n\tu32 VCAarg;\n\tu32 VGAarg;\n\tu32 bandselectarg;\n\tu32 pllarg;\n\tu32 FILTune;\n\n\tstruct i2c_adapter tuner_i2c_adapter;\n\n\tu8 demod_rev;\n\n\t \n\tu32 currentfreq;\n\tu32 currentsymbolrate;\n};\n\n \nstatic struct cx24123_AGC_val {\n\tu32 symbolrate_low;\n\tu32 symbolrate_high;\n\tu32 VCAprogdata;\n\tu32 VGAprogdata;\n\tu32 FILTune;\n} cx24123_AGC_vals[] =\n{\n\t{\n\t\t.symbolrate_low\t\t= 1000000,\n\t\t.symbolrate_high\t= 4999999,\n\t\t \n\t\t.VGAprogdata\t\t= (1 << 19) | (0x180 << 9) | 0x1e0,\n\t\t.VCAprogdata\t\t= (2 << 19) | (0x07 << 9) | 0x07,\n\t\t.FILTune\t\t= 0x27f  \n\t},\n\t{\n\t\t.symbolrate_low\t\t=  5000000,\n\t\t.symbolrate_high\t= 14999999,\n\t\t.VGAprogdata\t\t= (1 << 19) | (0x180 << 9) | 0x1e0,\n\t\t.VCAprogdata\t\t= (2 << 19) | (0x07 << 9) | 0x1f,\n\t\t.FILTune\t\t= 0x317  \n\t},\n\t{\n\t\t.symbolrate_low\t\t= 15000000,\n\t\t.symbolrate_high\t= 45000000,\n\t\t.VGAprogdata\t\t= (1 << 19) | (0x100 << 9) | 0x180,\n\t\t.VCAprogdata\t\t= (2 << 19) | (0x07 << 9) | 0x3f,\n\t\t.FILTune\t\t= 0x145  \n\t},\n};\n\n \nstatic struct cx24123_bandselect_val {\n\tu32 freq_low;\n\tu32 freq_high;\n\tu32 VCOdivider;\n\tu32 progdata;\n} cx24123_bandselect_vals[] =\n{\n\t \n\t{\n\t\t.freq_low\t= 950000,\n\t\t.freq_high\t= 1074999,\n\t\t.VCOdivider\t= 4,\n\t\t.progdata\t= (0 << 19) | (0 << 9) | 0x40,\n\t},\n\n\t \n\t{\n\t\t.freq_low\t= 1075000,\n\t\t.freq_high\t= 1177999,\n\t\t.VCOdivider\t= 4,\n\t\t.progdata\t= (0 << 19) | (0 << 9) | 0x80,\n\t},\n\n\t \n\t{\n\t\t.freq_low\t= 1178000,\n\t\t.freq_high\t= 1295999,\n\t\t.VCOdivider\t= 2,\n\t\t.progdata\t= (0 << 19) | (1 << 9) | 0x01,\n\t},\n\n\t \n\t{\n\t\t.freq_low\t= 1296000,\n\t\t.freq_high\t= 1431999,\n\t\t.VCOdivider\t= 2,\n\t\t.progdata\t= (0 << 19) | (1 << 9) | 0x02,\n\t},\n\n\t \n\t{\n\t\t.freq_low\t= 1432000,\n\t\t.freq_high\t= 1575999,\n\t\t.VCOdivider\t= 2,\n\t\t.progdata\t= (0 << 19) | (1 << 9) | 0x04,\n\t},\n\n\t \n\t{\n\t\t.freq_low\t= 1576000,\n\t\t.freq_high\t= 1717999,\n\t\t.VCOdivider\t= 2,\n\t\t.progdata\t= (0 << 19) | (1 << 9) | 0x08,\n\t},\n\n\t \n\t{\n\t\t.freq_low\t= 1718000,\n\t\t.freq_high\t= 1855999,\n\t\t.VCOdivider\t= 2,\n\t\t.progdata\t= (0 << 19) | (1 << 9) | 0x10,\n\t},\n\n\t \n\t{\n\t\t.freq_low\t= 1856000,\n\t\t.freq_high\t= 2035999,\n\t\t.VCOdivider\t= 2,\n\t\t.progdata\t= (0 << 19) | (1 << 9) | 0x20,\n\t},\n\n\t \n\t{\n\t\t.freq_low\t= 2036000,\n\t\t.freq_high\t= 2150000,\n\t\t.VCOdivider\t= 2,\n\t\t.progdata\t= (0 << 19) | (1 << 9) | 0x40,\n\t},\n};\n\nstatic struct {\n\tu8 reg;\n\tu8 data;\n} cx24123_regdata[] =\n{\n\t{0x00, 0x03},  \n\t{0x00, 0x00},  \n\t{0x03, 0x07},  \n\t{0x04, 0x10},  \n\t{0x05, 0x04},  \n\t{0x06, 0x31},  \n\t{0x0b, 0x00},  \n\t{0x0c, 0x00},  \n\t{0x0d, 0x7f},  \n\t{0x0e, 0x03},  \n\t{0x0f, 0xfe},  \n\t{0x10, 0x01},  \n\t{0x16, 0x00},  \n\t{0x17, 0x01},  \n\t{0x1c, 0x80},  \n\t{0x20, 0x00},  \n\t{0x21, 0x15},  \n\t{0x28, 0x00},  \n\t{0x29, 0x00},  \n\t{0x2a, 0xb0},  \n\t{0x2b, 0x73},  \n\t{0x2c, 0x00},  \n\t{0x2d, 0x00},\n\t{0x2e, 0x00},\n\t{0x2f, 0x00},\n\t{0x30, 0x00},\n\t{0x31, 0x00},\n\t{0x32, 0x8c},  \n\t{0x33, 0x00},  \n\t{0x34, 0x00},\n\t{0x35, 0x03},  \n\t{0x36, 0x02},  \n\t{0x37, 0x3a},  \n\t{0x3a, 0x00},  \n\t{0x44, 0x00},  \n\t{0x45, 0x00},  \n\t{0x46, 0x0d},  \n\t{0x56, 0xc1},  \n\t{0x57, 0xff},  \n\t{0x5c, 0x20},  \n\t{0x67, 0x83},  \n};\n\nstatic int cx24123_i2c_writereg(struct cx24123_state *state,\n\tu8 i2c_addr, int reg, int data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = {\n\t\t.addr = i2c_addr, .flags = 0, .buf = buf, .len = 2\n\t};\n\tint err;\n\n\t \n\n\terr = i2c_transfer(state->i2c, &msg, 1);\n\tif (err != 1) {\n\t\tprintk(\"%s: writereg error(err == %i, reg == 0x%02x, data == 0x%02x)\\n\",\n\t\t       __func__, err, reg, data);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int cx24123_i2c_readreg(struct cx24123_state *state, u8 i2c_addr, u8 reg)\n{\n\tint ret;\n\tu8 b = 0;\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = i2c_addr, .flags = 0, .buf = &reg, .len = 1 },\n\t\t{ .addr = i2c_addr, .flags = I2C_M_RD, .buf = &b, .len = 1 }\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\terr(\"%s: reg=0x%x (error=%d)\\n\", __func__, reg, ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\treturn b;\n}\n\n#define cx24123_readreg(state, reg) \\\n\tcx24123_i2c_readreg(state, state->config->demod_address, reg)\n#define cx24123_writereg(state, reg, val) \\\n\tcx24123_i2c_writereg(state, state->config->demod_address, reg, val)\n\nstatic int cx24123_set_inversion(struct cx24123_state *state,\n\t\t\t\t enum fe_spectral_inversion inversion)\n{\n\tu8 nom_reg = cx24123_readreg(state, 0x0e);\n\tu8 auto_reg = cx24123_readreg(state, 0x10);\n\n\tswitch (inversion) {\n\tcase INVERSION_OFF:\n\t\tdprintk(\"inversion off\\n\");\n\t\tcx24123_writereg(state, 0x0e, nom_reg & ~0x80);\n\t\tcx24123_writereg(state, 0x10, auto_reg | 0x80);\n\t\tbreak;\n\tcase INVERSION_ON:\n\t\tdprintk(\"inversion on\\n\");\n\t\tcx24123_writereg(state, 0x0e, nom_reg | 0x80);\n\t\tcx24123_writereg(state, 0x10, auto_reg | 0x80);\n\t\tbreak;\n\tcase INVERSION_AUTO:\n\t\tdprintk(\"inversion auto\\n\");\n\t\tcx24123_writereg(state, 0x10, auto_reg & ~0x80);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cx24123_get_inversion(struct cx24123_state *state,\n\t\t\t\t enum fe_spectral_inversion *inversion)\n{\n\tu8 val;\n\n\tval = cx24123_readreg(state, 0x1b) >> 7;\n\n\tif (val == 0) {\n\t\tdprintk(\"read inversion off\\n\");\n\t\t*inversion = INVERSION_OFF;\n\t} else {\n\t\tdprintk(\"read inversion on\\n\");\n\t\t*inversion = INVERSION_ON;\n\t}\n\n\treturn 0;\n}\n\nstatic int cx24123_set_fec(struct cx24123_state *state, enum fe_code_rate fec)\n{\n\tu8 nom_reg = cx24123_readreg(state, 0x0e) & ~0x07;\n\n\tif (((int)fec < FEC_NONE) || (fec > FEC_AUTO))\n\t\tfec = FEC_AUTO;\n\n\t \n\tif (fec == FEC_1_2)\n\t\tcx24123_writereg(state, 0x43,\n\t\t\tcx24123_readreg(state, 0x43) | 0x01);\n\telse\n\t\tcx24123_writereg(state, 0x43,\n\t\t\tcx24123_readreg(state, 0x43) & ~0x01);\n\n\tswitch (fec) {\n\tcase FEC_1_2:\n\t\tdprintk(\"set FEC to 1/2\\n\");\n\t\tcx24123_writereg(state, 0x0e, nom_reg | 0x01);\n\t\tcx24123_writereg(state, 0x0f, 0x02);\n\t\tbreak;\n\tcase FEC_2_3:\n\t\tdprintk(\"set FEC to 2/3\\n\");\n\t\tcx24123_writereg(state, 0x0e, nom_reg | 0x02);\n\t\tcx24123_writereg(state, 0x0f, 0x04);\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tdprintk(\"set FEC to 3/4\\n\");\n\t\tcx24123_writereg(state, 0x0e, nom_reg | 0x03);\n\t\tcx24123_writereg(state, 0x0f, 0x08);\n\t\tbreak;\n\tcase FEC_4_5:\n\t\tdprintk(\"set FEC to 4/5\\n\");\n\t\tcx24123_writereg(state, 0x0e, nom_reg | 0x04);\n\t\tcx24123_writereg(state, 0x0f, 0x10);\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tdprintk(\"set FEC to 5/6\\n\");\n\t\tcx24123_writereg(state, 0x0e, nom_reg | 0x05);\n\t\tcx24123_writereg(state, 0x0f, 0x20);\n\t\tbreak;\n\tcase FEC_6_7:\n\t\tdprintk(\"set FEC to 6/7\\n\");\n\t\tcx24123_writereg(state, 0x0e, nom_reg | 0x06);\n\t\tcx24123_writereg(state, 0x0f, 0x40);\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tdprintk(\"set FEC to 7/8\\n\");\n\t\tcx24123_writereg(state, 0x0e, nom_reg | 0x07);\n\t\tcx24123_writereg(state, 0x0f, 0x80);\n\t\tbreak;\n\tcase FEC_AUTO:\n\t\tdprintk(\"set FEC to auto\\n\");\n\t\tcx24123_writereg(state, 0x0f, 0xfe);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int cx24123_get_fec(struct cx24123_state *state, enum fe_code_rate *fec)\n{\n\tint ret;\n\n\tret = cx24123_readreg(state, 0x1b);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ret & 0x07;\n\n\tswitch (ret) {\n\tcase 1:\n\t\t*fec = FEC_1_2;\n\t\tbreak;\n\tcase 2:\n\t\t*fec = FEC_2_3;\n\t\tbreak;\n\tcase 3:\n\t\t*fec = FEC_3_4;\n\t\tbreak;\n\tcase 4:\n\t\t*fec = FEC_4_5;\n\t\tbreak;\n\tcase 5:\n\t\t*fec = FEC_5_6;\n\t\tbreak;\n\tcase 6:\n\t\t*fec = FEC_6_7;\n\t\tbreak;\n\tcase 7:\n\t\t*fec = FEC_7_8;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\t*fec = FEC_NONE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic u32 cx24123_int_log2(u32 a, u32 b)\n{\n\tu32 exp, nearest = 0;\n\tu32 div = a / b;\n\tif (a % b >= b / 2)\n\t\t++div;\n\tif (div < (1UL << 31)) {\n\t\tfor (exp = 1; div > exp; nearest++)\n\t\t\texp += exp;\n\t}\n\treturn nearest;\n}\n\nstatic int cx24123_set_symbolrate(struct cx24123_state *state, u32 srate)\n{\n\tu64 tmp;\n\tu32 sample_rate, ratio, sample_gain;\n\tu8 pll_mult;\n\n\t \n\tif ((srate > state->frontend.ops.info.symbol_rate_max) ||\n\t    (srate < state->frontend.ops.info.symbol_rate_min))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (srate < (XTAL*2)/2)\n\t\tpll_mult = 2;\n\telse if (srate < (XTAL*3)/2)\n\t\tpll_mult = 3;\n\telse if (srate < (XTAL*4)/2)\n\t\tpll_mult = 4;\n\telse if (srate < (XTAL*5)/2)\n\t\tpll_mult = 5;\n\telse if (srate < (XTAL*6)/2)\n\t\tpll_mult = 6;\n\telse if (srate < (XTAL*7)/2)\n\t\tpll_mult = 7;\n\telse if (srate < (XTAL*8)/2)\n\t\tpll_mult = 8;\n\telse\n\t\tpll_mult = 9;\n\n\n\tsample_rate = pll_mult * XTAL;\n\n\t \n\n\ttmp = ((u64)srate) << 23;\n\tdo_div(tmp, sample_rate);\n\tratio = (u32) tmp;\n\n\tcx24123_writereg(state, 0x01, pll_mult * 6);\n\n\tcx24123_writereg(state, 0x08, (ratio >> 16) & 0x3f);\n\tcx24123_writereg(state, 0x09, (ratio >> 8) & 0xff);\n\tcx24123_writereg(state, 0x0a, ratio & 0xff);\n\n\t \n\tsample_gain = cx24123_int_log2(sample_rate, srate);\n\ttmp = cx24123_readreg(state, 0x0c) & ~0xe0;\n\tcx24123_writereg(state, 0x0c, tmp | sample_gain << 5);\n\n\tdprintk(\"srate=%d, ratio=0x%08x, sample_rate=%i sample_gain=%d\\n\",\n\t\tsrate, ratio, sample_rate, sample_gain);\n\n\treturn 0;\n}\n\n \nstatic int cx24123_pll_calculate(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\tu32 ndiv = 0, adiv = 0, vco_div = 0;\n\tint i = 0;\n\tint pump = 2;\n\tint band = 0;\n\tint num_bands = ARRAY_SIZE(cx24123_bandselect_vals);\n\tstruct cx24123_bandselect_val *bsv = NULL;\n\tstruct cx24123_AGC_val *agcv = NULL;\n\n\t \n\tstate->VCAarg = cx24123_AGC_vals[0].VCAprogdata;\n\tstate->VGAarg = cx24123_AGC_vals[0].VGAprogdata;\n\tstate->bandselectarg = cx24123_bandselect_vals[0].progdata;\n\tvco_div = cx24123_bandselect_vals[0].VCOdivider;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cx24123_AGC_vals); i++) {\n\t\tagcv = &cx24123_AGC_vals[i];\n\t\tif ((agcv->symbolrate_low <= p->symbol_rate) &&\n\t\t    (agcv->symbolrate_high >= p->symbol_rate)) {\n\t\t\tstate->VCAarg = agcv->VCAprogdata;\n\t\t\tstate->VGAarg = agcv->VGAprogdata;\n\t\t\tstate->FILTune = agcv->FILTune;\n\t\t}\n\t}\n\n\t \n\tif (force_band < 1 || force_band > num_bands) {\n\t\tfor (i = 0; i < num_bands; i++) {\n\t\t\tbsv = &cx24123_bandselect_vals[i];\n\t\t\tif ((bsv->freq_low <= p->frequency) &&\n\t\t\t\t(bsv->freq_high >= p->frequency))\n\t\t\t\tband = i;\n\t\t}\n\t} else\n\t\tband = force_band - 1;\n\n\tstate->bandselectarg = cx24123_bandselect_vals[band].progdata;\n\tvco_div = cx24123_bandselect_vals[band].VCOdivider;\n\n\t \n\tif (p->frequency < (cx24123_bandselect_vals[band].freq_low +\n\t\tcx24123_bandselect_vals[band].freq_high) / 2)\n\t\tpump = 0x01;\n\telse\n\t\tpump = 0x02;\n\n\t \n\t \n\tndiv = (((p->frequency * vco_div * 10) /\n\t\t(2 * XTAL / 1000)) / 32) & 0x1ff;\n\tadiv = (((p->frequency * vco_div * 10) /\n\t\t(2 * XTAL / 1000)) % 32) & 0x1f;\n\n\tif (adiv == 0 && ndiv > 0)\n\t\tndiv--;\n\n\t \n\tstate->pllarg = (3 << 19) | (3 << 17) | (1 << 16) |\n\t\t(pump << 14) | (ndiv << 5) | adiv;\n\n\treturn 0;\n}\n\n \nstatic int cx24123_pll_writereg(struct dvb_frontend *fe, u32 data)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\tunsigned long timeout;\n\n\tdprintk(\"pll writereg called, data=0x%08x\\n\", data);\n\n\t \n\tdata = data << 3;\n\n\t \n\tcx24123_writereg(state, 0x21, 0x15);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(40);\n\tcx24123_writereg(state, 0x22, (data >> 16) & 0xff);\n\twhile ((cx24123_readreg(state, 0x20) & 0x40) == 0) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\terr(\"%s:  demodulator is not responding, \"\\\n\t\t\t\t\"possibly hung, aborting.\\n\", __func__);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t\tmsleep(10);\n\t}\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(40);\n\tcx24123_writereg(state, 0x22, (data >> 8) & 0xff);\n\twhile ((cx24123_readreg(state, 0x20) & 0x40) == 0) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\terr(\"%s:  demodulator is not responding, \"\\\n\t\t\t\t\"possibly hung, aborting.\\n\", __func__);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t\tmsleep(10);\n\t}\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(40);\n\tcx24123_writereg(state, 0x22, (data) & 0xff);\n\twhile ((cx24123_readreg(state, 0x20) & 0x80)) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\terr(\"%s:  demodulator is not responding,\" \\\n\t\t\t\t\"possibly hung, aborting.\\n\", __func__);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t\tmsleep(10);\n\t}\n\n\t \n\tcx24123_writereg(state, 0x20, cx24123_readreg(state, 0x20) | 2);\n\tcx24123_writereg(state, 0x20, cx24123_readreg(state, 0x20) & 0xfd);\n\n\treturn 0;\n}\n\nstatic int cx24123_pll_tune(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\tu8 val;\n\n\tdprintk(\"frequency=%i\\n\", p->frequency);\n\n\tif (cx24123_pll_calculate(fe) != 0) {\n\t\terr(\"%s: cx24123_pll_calculate failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcx24123_pll_writereg(fe, state->VCAarg);\n\tcx24123_pll_writereg(fe, state->VGAarg);\n\n\t \n\tcx24123_pll_writereg(fe, state->bandselectarg);\n\tcx24123_pll_writereg(fe, state->pllarg);\n\n\t \n\tval = cx24123_readreg(state, 0x28) & ~0x3;\n\tcx24123_writereg(state, 0x27, state->FILTune >> 2);\n\tcx24123_writereg(state, 0x28, val | (state->FILTune & 0x3));\n\n\tdprintk(\"pll tune VCA=%d, band=%d, pll=%d\\n\", state->VCAarg,\n\t\t\tstate->bandselectarg, state->pllarg);\n\n\treturn 0;\n}\n\n\n \n\n \nstatic int cx24123_repeater_mode(struct cx24123_state *state, u8 mode, u8 start)\n{\n\tu8 r = cx24123_readreg(state, 0x23) & 0x1e;\n\tif (mode)\n\t\tr |= (1 << 6) | (start << 5);\n\telse\n\t\tr |= (1 << 7) | (start);\n\treturn cx24123_writereg(state, 0x23, r);\n}\n\nstatic int cx24123_initfe(struct dvb_frontend *fe)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\tint i;\n\n\tdprintk(\"init frontend\\n\");\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cx24123_regdata); i++)\n\t\tcx24123_writereg(state, cx24123_regdata[i].reg,\n\t\t\tcx24123_regdata[i].data);\n\n\t \n\tif (state->config->lnb_polarity)\n\t\tcx24123_writereg(state, 0x32,\n\t\t\tcx24123_readreg(state, 0x32) | 0x02);\n\n\tif (state->config->dont_use_pll)\n\t\tcx24123_repeater_mode(state, 1, 0);\n\n\treturn 0;\n}\n\nstatic int cx24123_set_voltage(struct dvb_frontend *fe,\n\t\t\t       enum fe_sec_voltage voltage)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\tu8 val;\n\n\tval = cx24123_readreg(state, 0x29) & ~0x40;\n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_13:\n\t\tdprintk(\"setting voltage 13V\\n\");\n\t\treturn cx24123_writereg(state, 0x29, val & 0x7f);\n\tcase SEC_VOLTAGE_18:\n\t\tdprintk(\"setting voltage 18V\\n\");\n\t\treturn cx24123_writereg(state, 0x29, val | 0x80);\n\tcase SEC_VOLTAGE_OFF:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void cx24123_wait_for_diseqc(struct cx24123_state *state)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(200);\n\twhile (!(cx24123_readreg(state, 0x29) & 0x40)) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\terr(\"%s: diseqc queue not ready, \" \\\n\t\t\t\t\"command may be lost.\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(10);\n\t}\n}\n\nstatic int cx24123_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\tint i, val, tone;\n\n\tdprintk(\"\\n\");\n\n\t \n\ttone = cx24123_readreg(state, 0x29);\n\tif (tone & 0x10)\n\t\tcx24123_writereg(state, 0x29, tone & ~0x50);\n\n\t \n\tcx24123_wait_for_diseqc(state);\n\n\t \n\tcx24123_writereg(state, 0x2a, cx24123_readreg(state, 0x2a) & 0xfb);\n\n\tfor (i = 0; i < cmd->msg_len; i++)\n\t\tcx24123_writereg(state, 0x2C + i, cmd->msg[i]);\n\n\tval = cx24123_readreg(state, 0x29);\n\tcx24123_writereg(state, 0x29, ((val & 0x90) | 0x40) |\n\t\t((cmd->msg_len-3) & 3));\n\n\t \n\tcx24123_wait_for_diseqc(state);\n\n\t \n\tif (tone & 0x10)\n\t\tcx24123_writereg(state, 0x29, tone & ~0x40);\n\n\treturn 0;\n}\n\nstatic int cx24123_diseqc_send_burst(struct dvb_frontend *fe,\n\t\t\t\t     enum fe_sec_mini_cmd burst)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\tint val, tone;\n\n\tdprintk(\"\\n\");\n\n\t \n\ttone = cx24123_readreg(state, 0x29);\n\tif (tone & 0x10)\n\t\tcx24123_writereg(state, 0x29, tone & ~0x50);\n\n\t \n\tcx24123_wait_for_diseqc(state);\n\n\t \n\tcx24123_writereg(state, 0x2a, cx24123_readreg(state, 0x2a) | 0x4);\n\tmsleep(30);\n\tval = cx24123_readreg(state, 0x29);\n\tif (burst == SEC_MINI_A)\n\t\tcx24123_writereg(state, 0x29, ((val & 0x90) | 0x40 | 0x00));\n\telse if (burst == SEC_MINI_B)\n\t\tcx24123_writereg(state, 0x29, ((val & 0x90) | 0x40 | 0x08));\n\telse\n\t\treturn -EINVAL;\n\n\tcx24123_wait_for_diseqc(state);\n\tcx24123_writereg(state, 0x2a, cx24123_readreg(state, 0x2a) & 0xfb);\n\n\t \n\tif (tone & 0x10)\n\t\tcx24123_writereg(state, 0x29, tone & ~0x40);\n\n\treturn 0;\n}\n\nstatic int cx24123_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\tint sync = cx24123_readreg(state, 0x14);\n\n\t*status = 0;\n\tif (state->config->dont_use_pll) {\n\t\tu32 tun_status = 0;\n\t\tif (fe->ops.tuner_ops.get_status)\n\t\t\tfe->ops.tuner_ops.get_status(fe, &tun_status);\n\t\tif (tun_status & TUNER_STATUS_LOCKED)\n\t\t\t*status |= FE_HAS_SIGNAL;\n\t} else {\n\t\tint lock = cx24123_readreg(state, 0x20);\n\t\tif (lock & 0x01)\n\t\t\t*status |= FE_HAS_SIGNAL;\n\t}\n\n\tif (sync & 0x02)\n\t\t*status |= FE_HAS_CARRIER;\t \n\tif (sync & 0x04)\n\t\t*status |= FE_HAS_VITERBI;\n\n\t \n\tif (sync & 0x08)\n\t\t*status |= FE_HAS_SYNC;\n\tif (sync & 0x80)\n\t\t*status |= FE_HAS_LOCK;\t\t \n\n\treturn 0;\n}\n\n \nstatic int cx24123_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\n\t \n\t*ber = ((cx24123_readreg(state, 0x1c) & 0x3f) << 16) |\n\t\t(cx24123_readreg(state, 0x1d) << 8 |\n\t\t cx24123_readreg(state, 0x1e));\n\n\tdprintk(\"BER = %d\\n\", *ber);\n\n\treturn 0;\n}\n\nstatic int cx24123_read_signal_strength(struct dvb_frontend *fe,\n\tu16 *signal_strength)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\n\t \n\t*signal_strength = cx24123_readreg(state, 0x3b) << 8;\n\n\tdprintk(\"Signal strength = %d\\n\", *signal_strength);\n\n\treturn 0;\n}\n\nstatic int cx24123_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\n\t \n\t*snr = 65535 - (((u16)cx24123_readreg(state, 0x18) << 8) |\n\t\t\t (u16)cx24123_readreg(state, 0x19));\n\n\tdprintk(\"read S/N index = %d\\n\", *snr);\n\n\treturn 0;\n}\n\nstatic int cx24123_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tdprintk(\"\\n\");\n\n\tif (state->config->set_ts_params)\n\t\tstate->config->set_ts_params(fe, 0);\n\n\tstate->currentfreq = p->frequency;\n\tstate->currentsymbolrate = p->symbol_rate;\n\n\tcx24123_set_inversion(state, p->inversion);\n\tcx24123_set_fec(state, p->fec_inner);\n\tcx24123_set_symbolrate(state, p->symbol_rate);\n\n\tif (!state->config->dont_use_pll)\n\t\tcx24123_pll_tune(fe);\n\telse if (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\telse\n\t\terr(\"it seems I don't have a tuner...\");\n\n\t \n\tcx24123_writereg(state, 0x03, (cx24123_readreg(state, 0x03) | 0x07));\n\tcx24123_writereg(state, 0x00, 0x10);\n\tcx24123_writereg(state, 0x00, 0);\n\n\tif (state->config->agc_callback)\n\t\tstate->config->agc_callback(fe);\n\n\treturn 0;\n}\n\nstatic int cx24123_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\n\tdprintk(\"\\n\");\n\n\tif (cx24123_get_inversion(state, &p->inversion) != 0) {\n\t\terr(\"%s: Failed to get inversion status\\n\", __func__);\n\t\treturn -EREMOTEIO;\n\t}\n\tif (cx24123_get_fec(state, &p->fec_inner) != 0) {\n\t\terr(\"%s: Failed to get fec status\\n\", __func__);\n\t\treturn -EREMOTEIO;\n\t}\n\tp->frequency = state->currentfreq;\n\tp->symbol_rate = state->currentsymbolrate;\n\n\treturn 0;\n}\n\nstatic int cx24123_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\tu8 val;\n\n\t \n\tcx24123_wait_for_diseqc(state);\n\n\tval = cx24123_readreg(state, 0x29) & ~0x40;\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\tdprintk(\"setting tone on\\n\");\n\t\treturn cx24123_writereg(state, 0x29, val | 0x10);\n\tcase SEC_TONE_OFF:\n\t\tdprintk(\"setting tone off\\n\");\n\t\treturn cx24123_writereg(state, 0x29, val & 0xef);\n\tdefault:\n\t\terr(\"CASE reached default with tone=%d\\n\", tone);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cx24123_tune(struct dvb_frontend *fe,\n\t\t\tbool re_tune,\n\t\t\tunsigned int mode_flags,\n\t\t\tunsigned int *delay,\n\t\t\tenum fe_status *status)\n{\n\tint retval = 0;\n\n\tif (re_tune)\n\t\tretval = cx24123_set_frontend(fe);\n\n\tif (!(mode_flags & FE_TUNE_MODE_ONESHOT))\n\t\tcx24123_read_status(fe, status);\n\t*delay = HZ/10;\n\n\treturn retval;\n}\n\nstatic enum dvbfe_algo cx24123_get_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic void cx24123_release(struct dvb_frontend *fe)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\tdprintk(\"\\n\");\n\ti2c_del_adapter(&state->tuner_i2c_adapter);\n\tkfree(state);\n}\n\nstatic int cx24123_tuner_i2c_tuner_xfer(struct i2c_adapter *i2c_adap,\n\tstruct i2c_msg msg[], int num)\n{\n\tstruct cx24123_state *state = i2c_get_adapdata(i2c_adap);\n\t \n\tcx24123_repeater_mode(state, 1, 1);\n\treturn i2c_transfer(state->i2c, msg, num);\n}\n\nstatic u32 cx24123_tuner_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm cx24123_tuner_i2c_algo = {\n\t.master_xfer   = cx24123_tuner_i2c_tuner_xfer,\n\t.functionality = cx24123_tuner_i2c_func,\n};\n\nstruct i2c_adapter *\n\tcx24123_get_tuner_i2c_adapter(struct dvb_frontend *fe)\n{\n\tstruct cx24123_state *state = fe->demodulator_priv;\n\treturn &state->tuner_i2c_adapter;\n}\nEXPORT_SYMBOL(cx24123_get_tuner_i2c_adapter);\n\nstatic const struct dvb_frontend_ops cx24123_ops;\n\nstruct dvb_frontend *cx24123_attach(const struct cx24123_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\t \n\tstruct cx24123_state *state =\n\t\tkzalloc(sizeof(struct cx24123_state), GFP_KERNEL);\n\n\tdprintk(\"\\n\");\n\tif (state == NULL) {\n\t\terr(\"Unable to kzalloc\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t \n\tstate->demod_rev = cx24123_readreg(state, 0x00);\n\tswitch (state->demod_rev) {\n\tcase 0xe1:\n\t\tinfo(\"detected CX24123C\\n\");\n\t\tbreak;\n\tcase 0xd1:\n\t\tinfo(\"detected CX24123\\n\");\n\t\tbreak;\n\tdefault:\n\t\terr(\"wrong demod revision: %x\\n\", state->demod_rev);\n\t\tgoto error;\n\t}\n\n\t \n\tmemcpy(&state->frontend.ops, &cx24123_ops,\n\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\t \n\tif (config->dont_use_pll)\n\t\tcx24123_repeater_mode(state, 1, 0);\n\n\tstrscpy(state->tuner_i2c_adapter.name, \"CX24123 tuner I2C bus\",\n\t\tsizeof(state->tuner_i2c_adapter.name));\n\tstate->tuner_i2c_adapter.algo      = &cx24123_tuner_i2c_algo;\n\tstate->tuner_i2c_adapter.algo_data = NULL;\n\tstate->tuner_i2c_adapter.dev.parent = i2c->dev.parent;\n\ti2c_set_adapdata(&state->tuner_i2c_adapter, state);\n\tif (i2c_add_adapter(&state->tuner_i2c_adapter) < 0) {\n\t\terr(\"tuner i2c bus could not be initialized\\n\");\n\t\tgoto error;\n\t}\n\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cx24123_attach);\n\nstatic const struct dvb_frontend_ops cx24123_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name = \"Conexant CX24123/CX24109\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t\t.frequency_stepsize_hz = 1011 * kHz,\n\t\t.frequency_tolerance_hz = 5 * MHz,\n\t\t.symbol_rate_min = 1000000,\n\t\t.symbol_rate_max = 45000000,\n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |\n\t\t\tFE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_RECOVER\n\t},\n\n\t.release = cx24123_release,\n\n\t.init = cx24123_initfe,\n\t.set_frontend = cx24123_set_frontend,\n\t.get_frontend = cx24123_get_frontend,\n\t.read_status = cx24123_read_status,\n\t.read_ber = cx24123_read_ber,\n\t.read_signal_strength = cx24123_read_signal_strength,\n\t.read_snr = cx24123_read_snr,\n\t.diseqc_send_master_cmd = cx24123_send_diseqc_msg,\n\t.diseqc_send_burst = cx24123_diseqc_send_burst,\n\t.set_tone = cx24123_set_tone,\n\t.set_voltage = cx24123_set_voltage,\n\t.tune = cx24123_tune,\n\t.get_frontend_algo = cx24123_get_algo,\n};\n\nMODULE_DESCRIPTION(\"DVB Frontend module for Conexant \" \\\n\t\"CX24123/CX24109/CX24113 hardware\");\nMODULE_AUTHOR(\"Steven Toth\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}