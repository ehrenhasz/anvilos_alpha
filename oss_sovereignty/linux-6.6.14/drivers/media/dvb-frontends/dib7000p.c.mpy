{
  "module_name": "dib7000p.c",
  "hash_id": "d53b40bfe1576099241e7ab5e63cfdd556d73d83ff951db29cee60d0acfc7fe2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/dib7000p.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <asm/div64.h>\n\n#include <linux/int_log.h>\n#include <media/dvb_frontend.h>\n\n#include \"dib7000p.h\"\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"turn on debugging (default: 0)\");\n\nstatic int buggy_sfn_workaround;\nmodule_param(buggy_sfn_workaround, int, 0644);\nMODULE_PARM_DESC(buggy_sfn_workaround, \"Enable work-around for buggy SFNs (default: 0)\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\nstruct i2c_device {\n\tstruct i2c_adapter *i2c_adap;\n\tu8 i2c_addr;\n};\n\nstruct dib7000p_state {\n\tstruct dvb_frontend demod;\n\tstruct dib7000p_config cfg;\n\n\tu8 i2c_addr;\n\tstruct i2c_adapter *i2c_adap;\n\n\tstruct dibx000_i2c_master i2c_master;\n\n\tu16 wbd_ref;\n\n\tu8 current_band;\n\tu32 current_bandwidth;\n\tstruct dibx000_agc_config *current_agc;\n\tu32 timf;\n\n\tu8 div_force_off:1;\n\tu8 div_state:1;\n\tu16 div_sync_wait;\n\n\tu8 agc_state;\n\n\tu16 gpio_dir;\n\tu16 gpio_val;\n\n\tu8 sfn_workaround_active:1;\n\n#define SOC7090 0x7090\n\tu16 version;\n\n\tu16 tuner_enable;\n\tstruct i2c_adapter dib7090_tuner_adap;\n\n\t \n\tstruct i2c_msg msg[2];\n\tu8 i2c_write_buffer[4];\n\tu8 i2c_read_buffer[2];\n\tstruct mutex i2c_buffer_lock;\n\n\tu8 input_mode_mpeg;\n\n\t \n\ts64 old_ucb;\n\tunsigned long per_jiffies_stats;\n\tunsigned long ber_jiffies_stats;\n\tunsigned long get_stats_time;\n};\n\nenum dib7000p_power_mode {\n\tDIB7000P_POWER_ALL = 0,\n\tDIB7000P_POWER_ANALOG_ADC,\n\tDIB7000P_POWER_INTERFACE_ONLY,\n};\n\n \nstatic int dib7090_set_output_mode(struct dvb_frontend *fe, int mode);\nstatic int dib7090_set_diversity_in(struct dvb_frontend *fe, int onoff);\nstatic void dib7090_setDibTxMux(struct dib7000p_state *state, int mode);\nstatic void dib7090_setHostBusMux(struct dib7000p_state *state, int mode);\n\nstatic u16 dib7000p_read_word(struct dib7000p_state *state, u16 reg)\n{\n\tu16 ret;\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn 0;\n\t}\n\n\tstate->i2c_write_buffer[0] = reg >> 8;\n\tstate->i2c_write_buffer[1] = reg & 0xff;\n\n\tmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\n\tstate->msg[0].addr = state->i2c_addr >> 1;\n\tstate->msg[0].flags = 0;\n\tstate->msg[0].buf = state->i2c_write_buffer;\n\tstate->msg[0].len = 2;\n\tstate->msg[1].addr = state->i2c_addr >> 1;\n\tstate->msg[1].flags = I2C_M_RD;\n\tstate->msg[1].buf = state->i2c_read_buffer;\n\tstate->msg[1].len = 2;\n\n\tif (i2c_transfer(state->i2c_adap, state->msg, 2) != 2)\n\t\tdprintk(\"i2c read error on %d\\n\", reg);\n\n\tret = (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];\n\tmutex_unlock(&state->i2c_buffer_lock);\n\treturn ret;\n}\n\nstatic int dib7000p_write_word(struct dib7000p_state *state, u16 reg, u16 val)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\n\t\tdprintk(\"could not acquire lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstate->i2c_write_buffer[0] = (reg >> 8) & 0xff;\n\tstate->i2c_write_buffer[1] = reg & 0xff;\n\tstate->i2c_write_buffer[2] = (val >> 8) & 0xff;\n\tstate->i2c_write_buffer[3] = val & 0xff;\n\n\tmemset(&state->msg[0], 0, sizeof(struct i2c_msg));\n\tstate->msg[0].addr = state->i2c_addr >> 1;\n\tstate->msg[0].flags = 0;\n\tstate->msg[0].buf = state->i2c_write_buffer;\n\tstate->msg[0].len = 4;\n\n\tret = (i2c_transfer(state->i2c_adap, state->msg, 1) != 1 ?\n\t\t\t-EREMOTEIO : 0);\n\tmutex_unlock(&state->i2c_buffer_lock);\n\treturn ret;\n}\n\nstatic void dib7000p_write_tab(struct dib7000p_state *state, u16 * buf)\n{\n\tu16 l = 0, r, *n;\n\tn = buf;\n\tl = *n++;\n\twhile (l) {\n\t\tr = *n++;\n\n\t\tdo {\n\t\t\tdib7000p_write_word(state, r, *n++);\n\t\t\tr++;\n\t\t} while (--l);\n\t\tl = *n++;\n\t}\n}\n\nstatic int dib7000p_set_output_mode(struct dib7000p_state *state, int mode)\n{\n\tint ret = 0;\n\tu16 outreg, fifo_threshold, smo_mode;\n\n\toutreg = 0;\n\tfifo_threshold = 1792;\n\tsmo_mode = (dib7000p_read_word(state, 235) & 0x0050) | (1 << 1);\n\n\tdprintk(\"setting output mode for demod %p to %d\\n\", &state->demod, mode);\n\n\tswitch (mode) {\n\tcase OUTMODE_MPEG2_PAR_GATED_CLK:\n\t\toutreg = (1 << 10);\t \n\t\tbreak;\n\tcase OUTMODE_MPEG2_PAR_CONT_CLK:\n\t\toutreg = (1 << 10) | (1 << 6);\t \n\t\tbreak;\n\tcase OUTMODE_MPEG2_SERIAL:\n\t\toutreg = (1 << 10) | (2 << 6) | (0 << 1);\t \n\t\tbreak;\n\tcase OUTMODE_DIVERSITY:\n\t\tif (state->cfg.hostbus_diversity)\n\t\t\toutreg = (1 << 10) | (4 << 6);\t \n\t\telse\n\t\t\toutreg = (1 << 11);\n\t\tbreak;\n\tcase OUTMODE_MPEG2_FIFO:\n\t\tsmo_mode |= (3 << 1);\n\t\tfifo_threshold = 512;\n\t\toutreg = (1 << 10) | (5 << 6);\n\t\tbreak;\n\tcase OUTMODE_ANALOG_ADC:\n\t\toutreg = (1 << 10) | (3 << 6);\n\t\tbreak;\n\tcase OUTMODE_HIGH_Z:\n\t\toutreg = 0;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"Unhandled output_mode passed to be set for demod %p\\n\", &state->demod);\n\t\tbreak;\n\t}\n\n\tif (state->cfg.output_mpeg2_in_188_bytes)\n\t\tsmo_mode |= (1 << 5);\n\n\tret |= dib7000p_write_word(state, 235, smo_mode);\n\tret |= dib7000p_write_word(state, 236, fifo_threshold);\t \n\tif (state->version != SOC7090)\n\t\tret |= dib7000p_write_word(state, 1286, outreg);\t \n\n\treturn ret;\n}\n\nstatic int dib7000p_set_diversity_in(struct dvb_frontend *demod, int onoff)\n{\n\tstruct dib7000p_state *state = demod->demodulator_priv;\n\n\tif (state->div_force_off) {\n\t\tdprintk(\"diversity combination deactivated - forced by COFDM parameters\\n\");\n\t\tonoff = 0;\n\t\tdib7000p_write_word(state, 207, 0);\n\t} else\n\t\tdib7000p_write_word(state, 207, (state->div_sync_wait << 4) | (1 << 2) | (2 << 0));\n\n\tstate->div_state = (u8) onoff;\n\n\tif (onoff) {\n\t\tdib7000p_write_word(state, 204, 6);\n\t\tdib7000p_write_word(state, 205, 16);\n\t\t \n\t} else {\n\t\tdib7000p_write_word(state, 204, 1);\n\t\tdib7000p_write_word(state, 205, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int dib7000p_set_power_mode(struct dib7000p_state *state, enum dib7000p_power_mode mode)\n{\n\t \n\tu16 reg_774 = 0x3fff, reg_775 = 0xffff, reg_776 = 0x0007, reg_899 = 0x0003, reg_1280 = (0xfe00) | (dib7000p_read_word(state, 1280) & 0x01ff);\n\n\t \n\tswitch (mode) {\n\t\t \n\tcase DIB7000P_POWER_ALL:\n\t\treg_774 = 0x0000;\n\t\treg_775 = 0x0000;\n\t\treg_776 = 0x0;\n\t\treg_899 = 0x0;\n\t\tif (state->version == SOC7090)\n\t\t\treg_1280 &= 0x001f;\n\t\telse\n\t\t\treg_1280 &= 0x01ff;\n\t\tbreak;\n\n\tcase DIB7000P_POWER_ANALOG_ADC:\n\t\t \n\t\treg_774 &= ~((1 << 15) | (1 << 14) | (1 << 11) | (1 << 10) | (1 << 9));\n\t\t \n\t\treg_776 &= ~((1 << 0));\n\t\t \n\t\tif (state->version != SOC7090)\n\t\t\treg_1280 &= ~((1 << 11));\n\t\treg_1280 &= ~(1 << 6);\n\t\tfallthrough;\n\tcase DIB7000P_POWER_INTERFACE_ONLY:\n\t\t \n\t\t \n\t\tif (state->version == SOC7090)\n\t\t\treg_1280 &= ~((1 << 7) | (1 << 5));\n\t\telse\n\t\t\treg_1280 &= ~((1 << 14) | (1 << 13) | (1 << 12) | (1 << 10));\n\t\tbreak;\n\n \n\t}\n\n\tdib7000p_write_word(state, 774, reg_774);\n\tdib7000p_write_word(state, 775, reg_775);\n\tdib7000p_write_word(state, 776, reg_776);\n\tdib7000p_write_word(state, 1280, reg_1280);\n\tif (state->version != SOC7090)\n\t\tdib7000p_write_word(state, 899, reg_899);\n\n\treturn 0;\n}\n\nstatic void dib7000p_set_adc_state(struct dib7000p_state *state, enum dibx000_adc_states no)\n{\n\tu16 reg_908 = 0, reg_909 = 0;\n\tu16 reg;\n\n\tif (state->version != SOC7090) {\n\t\treg_908 = dib7000p_read_word(state, 908);\n\t\treg_909 = dib7000p_read_word(state, 909);\n\t}\n\n\tswitch (no) {\n\tcase DIBX000_SLOW_ADC_ON:\n\t\tif (state->version == SOC7090) {\n\t\t\treg = dib7000p_read_word(state, 1925);\n\n\t\t\tdib7000p_write_word(state, 1925, reg | (1 << 4) | (1 << 2));\t \n\n\t\t\treg = dib7000p_read_word(state, 1925);\t \n\t\t\tmsleep(200);\n\t\t\tdib7000p_write_word(state, 1925, reg & ~(1 << 4));\t \n\n\t\t\treg = dib7000p_read_word(state, 72) & ~((0x3 << 14) | (0x3 << 12));\n\t\t\tdib7000p_write_word(state, 72, reg | (1 << 14) | (3 << 12) | 524);\t \n\t\t} else {\n\t\t\treg_909 |= (1 << 1) | (1 << 0);\n\t\t\tdib7000p_write_word(state, 909, reg_909);\n\t\t\treg_909 &= ~(1 << 1);\n\t\t}\n\t\tbreak;\n\n\tcase DIBX000_SLOW_ADC_OFF:\n\t\tif (state->version == SOC7090) {\n\t\t\treg = dib7000p_read_word(state, 1925);\n\t\t\tdib7000p_write_word(state, 1925, (reg & ~(1 << 2)) | (1 << 4));\t \n\t\t} else\n\t\t\treg_909 |= (1 << 1) | (1 << 0);\n\t\tbreak;\n\n\tcase DIBX000_ADC_ON:\n\t\treg_908 &= 0x0fff;\n\t\treg_909 &= 0x0003;\n\t\tbreak;\n\n\tcase DIBX000_ADC_OFF:\n\t\treg_908 |= (1 << 14) | (1 << 13) | (1 << 12);\n\t\treg_909 |= (1 << 5) | (1 << 4) | (1 << 3) | (1 << 2);\n\t\tbreak;\n\n\tcase DIBX000_VBG_ENABLE:\n\t\treg_908 &= ~(1 << 15);\n\t\tbreak;\n\n\tcase DIBX000_VBG_DISABLE:\n\t\treg_908 |= (1 << 15);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\n\n\treg_909 |= (state->cfg.disable_sample_and_hold & 1) << 4;\n\treg_908 |= (state->cfg.enable_current_mirror & 1) << 7;\n\n\tif (state->version != SOC7090) {\n\t\tdib7000p_write_word(state, 908, reg_908);\n\t\tdib7000p_write_word(state, 909, reg_909);\n\t}\n}\n\nstatic int dib7000p_set_bandwidth(struct dib7000p_state *state, u32 bw)\n{\n\tu32 timf;\n\n\t\n\tstate->current_bandwidth = bw;\n\n\tif (state->timf == 0) {\n\t\tdprintk(\"using default timf\\n\");\n\t\ttimf = state->cfg.bw->timf;\n\t} else {\n\t\tdprintk(\"using updated timf\\n\");\n\t\ttimf = state->timf;\n\t}\n\n\ttimf = timf * (bw / 50) / 160;\n\n\tdib7000p_write_word(state, 23, (u16) ((timf >> 16) & 0xffff));\n\tdib7000p_write_word(state, 24, (u16) ((timf) & 0xffff));\n\n\treturn 0;\n}\n\nstatic int dib7000p_sad_calib(struct dib7000p_state *state)\n{\n \n\tdib7000p_write_word(state, 73, (0 << 1) | (0 << 0));\n\n\tif (state->version == SOC7090)\n\t\tdib7000p_write_word(state, 74, 2048);\n\telse\n\t\tdib7000p_write_word(state, 74, 776);\n\n\t \n\tdib7000p_write_word(state, 73, (1 << 0));\n\tdib7000p_write_word(state, 73, (0 << 0));\n\n\tmsleep(1);\n\n\treturn 0;\n}\n\nstatic int dib7000p_set_wbd_ref(struct dvb_frontend *demod, u16 value)\n{\n\tstruct dib7000p_state *state = demod->demodulator_priv;\n\tif (value > 4095)\n\t\tvalue = 4095;\n\tstate->wbd_ref = value;\n\treturn dib7000p_write_word(state, 105, (dib7000p_read_word(state, 105) & 0xf000) | value);\n}\n\nstatic int dib7000p_get_agc_values(struct dvb_frontend *fe,\n\t\tu16 *agc_global, u16 *agc1, u16 *agc2, u16 *wbd)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\n\tif (agc_global != NULL)\n\t\t*agc_global = dib7000p_read_word(state, 394);\n\tif (agc1 != NULL)\n\t\t*agc1 = dib7000p_read_word(state, 392);\n\tif (agc2 != NULL)\n\t\t*agc2 = dib7000p_read_word(state, 393);\n\tif (wbd != NULL)\n\t\t*wbd = dib7000p_read_word(state, 397);\n\n\treturn 0;\n}\n\nstatic int dib7000p_set_agc1_min(struct dvb_frontend *fe, u16 v)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\treturn dib7000p_write_word(state, 108,  v);\n}\n\nstatic void dib7000p_reset_pll(struct dib7000p_state *state)\n{\n\tstruct dibx000_bandwidth_config *bw = &state->cfg.bw[0];\n\tu16 clk_cfg0;\n\n\tif (state->version == SOC7090) {\n\t\tdib7000p_write_word(state, 1856, (!bw->pll_reset << 13) | (bw->pll_range << 12) | (bw->pll_ratio << 6) | (bw->pll_prediv));\n\n\t\twhile (((dib7000p_read_word(state, 1856) >> 15) & 0x1) != 1)\n\t\t\t;\n\n\t\tdib7000p_write_word(state, 1857, dib7000p_read_word(state, 1857) | (!bw->pll_bypass << 15));\n\t} else {\n\t\t \n\t\tclk_cfg0 = (1 << 15) | ((bw->pll_ratio & 0x3f) << 9) |\n\t\t\t(bw->modulo << 7) | (bw->ADClkSrc << 6) | (bw->IO_CLK_en_core << 5) | (bw->bypclk_div << 2) | (bw->enable_refdiv << 1) | (0 << 0);\n\n\t\tdib7000p_write_word(state, 900, clk_cfg0);\n\n\t\t \n\t\tdib7000p_write_word(state, 903, (bw->pll_prediv << 5) | (((bw->pll_ratio >> 6) & 0x3) << 3) | (bw->pll_range << 1) | bw->pll_reset);\n\t\tclk_cfg0 = (bw->pll_bypass << 15) | (clk_cfg0 & 0x7fff);\n\t\tdib7000p_write_word(state, 900, clk_cfg0);\n\t}\n\n\tdib7000p_write_word(state, 18, (u16) (((bw->internal * 1000) >> 16) & 0xffff));\n\tdib7000p_write_word(state, 19, (u16) ((bw->internal * 1000) & 0xffff));\n\tdib7000p_write_word(state, 21, (u16) ((bw->ifreq >> 16) & 0xffff));\n\tdib7000p_write_word(state, 22, (u16) ((bw->ifreq) & 0xffff));\n\n\tdib7000p_write_word(state, 72, bw->sad_cfg);\n}\n\nstatic u32 dib7000p_get_internal_freq(struct dib7000p_state *state)\n{\n\tu32 internal = (u32) dib7000p_read_word(state, 18) << 16;\n\tinternal |= (u32) dib7000p_read_word(state, 19);\n\tinternal /= 1000;\n\n\treturn internal;\n}\n\nstatic int dib7000p_update_pll(struct dvb_frontend *fe, struct dibx000_bandwidth_config *bw)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tu16 reg_1857, reg_1856 = dib7000p_read_word(state, 1856);\n\tu8 loopdiv, prediv;\n\tu32 internal, xtal;\n\n\t \n\tprediv = reg_1856 & 0x3f;\n\tloopdiv = (reg_1856 >> 6) & 0x3f;\n\n\tif (loopdiv && bw && (bw->pll_prediv != prediv || bw->pll_ratio != loopdiv)) {\n\t\tdprintk(\"Updating pll (prediv: old =  %d new = %d ; loopdiv : old = %d new = %d)\\n\", prediv, bw->pll_prediv, loopdiv, bw->pll_ratio);\n\t\treg_1856 &= 0xf000;\n\t\treg_1857 = dib7000p_read_word(state, 1857);\n\t\tdib7000p_write_word(state, 1857, reg_1857 & ~(1 << 15));\n\n\t\tdib7000p_write_word(state, 1856, reg_1856 | ((bw->pll_ratio & 0x3f) << 6) | (bw->pll_prediv & 0x3f));\n\n\t\t \n\t\tinternal = dib7000p_get_internal_freq(state);\n\t\txtal = (internal / loopdiv) * prediv;\n\t\tinternal = 1000 * (xtal / bw->pll_prediv) * bw->pll_ratio;\t \n\t\tdib7000p_write_word(state, 18, (u16) ((internal >> 16) & 0xffff));\n\t\tdib7000p_write_word(state, 19, (u16) (internal & 0xffff));\n\n\t\tdib7000p_write_word(state, 1857, reg_1857 | (1 << 15));\n\n\t\twhile (((dib7000p_read_word(state, 1856) >> 15) & 0x1) != 1)\n\t\t\tdprintk(\"Waiting for PLL to lock\\n\");\n\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\nstatic int dib7000p_reset_gpio(struct dib7000p_state *st)\n{\n\t \n\tdprintk(\"gpio dir: %x: val: %x, pwm_pos: %x\\n\", st->gpio_dir, st->gpio_val, st->cfg.gpio_pwm_pos);\n\n\tdib7000p_write_word(st, 1029, st->gpio_dir);\n\tdib7000p_write_word(st, 1030, st->gpio_val);\n\n\t \n\n\tdib7000p_write_word(st, 1032, st->cfg.gpio_pwm_pos);\n\n\tdib7000p_write_word(st, 1037, st->cfg.pwm_freq_div);\n\treturn 0;\n}\n\nstatic int dib7000p_cfg_gpio(struct dib7000p_state *st, u8 num, u8 dir, u8 val)\n{\n\tst->gpio_dir = dib7000p_read_word(st, 1029);\n\tst->gpio_dir &= ~(1 << num);\t \n\tst->gpio_dir |= (dir & 0x1) << num;\t \n\tdib7000p_write_word(st, 1029, st->gpio_dir);\n\n\tst->gpio_val = dib7000p_read_word(st, 1030);\n\tst->gpio_val &= ~(1 << num);\t \n\tst->gpio_val |= (val & 0x01) << num;\t \n\tdib7000p_write_word(st, 1030, st->gpio_val);\n\n\treturn 0;\n}\n\nstatic int dib7000p_set_gpio(struct dvb_frontend *demod, u8 num, u8 dir, u8 val)\n{\n\tstruct dib7000p_state *state = demod->demodulator_priv;\n\treturn dib7000p_cfg_gpio(state, num, dir, val);\n}\n\nstatic u16 dib7000p_defaults[] = {\n\t\n\t3, 2,\n\t0x0004,\n\t(1<<3)|(1<<11)|(1<<12)|(1<<13),\n\t0x0814,\t\t\t \n\n\t12, 6,\n\t0x001b,\n\t0x7740,\n\t0x005b,\n\t0x8d80,\n\t0x01c9,\n\t0xc380,\n\t0x0000,\n\t0x0080,\n\t0x0000,\n\t0x0090,\n\t0x0001,\n\t0xd4c0,\n\n\t1, 26,\n\t0x6680,\n\n\t \n\t11, 79,\n\t(1 << 13) - 825 - 117,\n\t(1 << 13) - 837 - 117,\n\t(1 << 13) - 811 - 117,\n\t(1 << 13) - 766 - 117,\n\t(1 << 13) - 737 - 117,\n\t(1 << 13) - 693 - 117,\n\t(1 << 13) - 648 - 117,\n\t(1 << 13) - 619 - 117,\n\t(1 << 13) - 575 - 117,\n\t(1 << 13) - 531 - 117,\n\t(1 << 13) - 501 - 117,\n\n\t1, 142,\n\t0x0410,\n\n\t \n\t8, 145,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\n\t1, 154,\n\t1 << 13,\n\n\t1, 168,\n\t0x0ccd,\n\n\t1, 183,\n\t0x200f,\n\n\t1, 212,\n\t\t0x169,\n\n\t5, 187,\n\t0x023d,\n\t0x00a4,\n\t0x00a4,\n\t0x7ff0,\n\t0x3ccc,\n\n\t1, 198,\n\t0x800,\n\n\t1, 222,\n\t0x0010,\n\n\t1, 235,\n\t0x0062,\n\n\t0,\n};\n\nstatic void dib7000p_reset_stats(struct dvb_frontend *fe);\n\nstatic int dib7000p_demod_reset(struct dib7000p_state *state)\n{\n\tdib7000p_set_power_mode(state, DIB7000P_POWER_ALL);\n\n\tif (state->version == SOC7090)\n\t\tdibx000_reset_i2c_master(&state->i2c_master);\n\n\tdib7000p_set_adc_state(state, DIBX000_VBG_ENABLE);\n\n\t \n\tdib7000p_write_word(state, 770, 0xffff);\n\tdib7000p_write_word(state, 771, 0xffff);\n\tdib7000p_write_word(state, 772, 0x001f);\n\tdib7000p_write_word(state, 1280, 0x001f - ((1 << 4) | (1 << 3)));\n\n\tdib7000p_write_word(state, 770, 0);\n\tdib7000p_write_word(state, 771, 0);\n\tdib7000p_write_word(state, 772, 0);\n\tdib7000p_write_word(state, 1280, 0);\n\n\tif (state->version != SOC7090) {\n\t\tdib7000p_write_word(state,  898, 0x0003);\n\t\tdib7000p_write_word(state,  898, 0);\n\t}\n\n\t \n\tdib7000p_reset_pll(state);\n\n\tif (dib7000p_reset_gpio(state) != 0)\n\t\tdprintk(\"GPIO reset was not successful.\\n\");\n\n\tif (state->version == SOC7090) {\n\t\tdib7000p_write_word(state, 899, 0);\n\n\t\t \n\t\tdib7000p_write_word(state, 42, (1<<5) | 3);  \n\t\tdib7000p_write_word(state, 43, 0x2d4);  \n\t\tdib7000p_write_word(state, 44, 300);  \n\t\tdib7000p_write_word(state, 273, (0<<6) | 30);\n\t}\n\tif (dib7000p_set_output_mode(state, OUTMODE_HIGH_Z) != 0)\n\t\tdprintk(\"OUTPUT_MODE could not be reset.\\n\");\n\n\tdib7000p_set_adc_state(state, DIBX000_SLOW_ADC_ON);\n\tdib7000p_sad_calib(state);\n\tdib7000p_set_adc_state(state, DIBX000_SLOW_ADC_OFF);\n\n\t \n\tdib7000p_write_word(state, 1285, dib7000p_read_word(state, 1285) & ~(1 << 1));\n\n\tdib7000p_set_bandwidth(state, 8000);\n\n\tif (state->version == SOC7090) {\n\t\tdib7000p_write_word(state, 36, 0x0755); \n\t} else {\n\t\tif (state->cfg.tuner_is_baseband)\n\t\t\tdib7000p_write_word(state, 36, 0x0755);\n\t\telse\n\t\t\tdib7000p_write_word(state, 36, 0x1f55);\n\t}\n\n\tdib7000p_write_tab(state, dib7000p_defaults);\n\tif (state->version != SOC7090) {\n\t\tdib7000p_write_word(state, 901, 0x0006);\n\t\tdib7000p_write_word(state, 902, (3 << 10) | (1 << 6));\n\t\tdib7000p_write_word(state, 905, 0x2c8e);\n\t}\n\n\tdib7000p_set_power_mode(state, DIB7000P_POWER_INTERFACE_ONLY);\n\n\treturn 0;\n}\n\nstatic void dib7000p_pll_clk_cfg(struct dib7000p_state *state)\n{\n\tu16 tmp = 0;\n\ttmp = dib7000p_read_word(state, 903);\n\tdib7000p_write_word(state, 903, (tmp | 0x1));\n\ttmp = dib7000p_read_word(state, 900);\n\tdib7000p_write_word(state, 900, (tmp & 0x7fff) | (1 << 6));\n}\n\nstatic void dib7000p_restart_agc(struct dib7000p_state *state)\n{\n\t\n\tdib7000p_write_word(state, 770, (1 << 11) | (1 << 9));\n\tdib7000p_write_word(state, 770, 0x0000);\n}\n\nstatic int dib7000p_update_lna(struct dib7000p_state *state)\n{\n\tu16 dyn_gain;\n\n\tif (state->cfg.update_lna) {\n\t\tdyn_gain = dib7000p_read_word(state, 394);\n\t\tif (state->cfg.update_lna(&state->demod, dyn_gain)) {\n\t\t\tdib7000p_restart_agc(state);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dib7000p_set_agc_config(struct dib7000p_state *state, u8 band)\n{\n\tstruct dibx000_agc_config *agc = NULL;\n\tint i;\n\tif (state->current_band == band && state->current_agc != NULL)\n\t\treturn 0;\n\tstate->current_band = band;\n\n\tfor (i = 0; i < state->cfg.agc_config_count; i++)\n\t\tif (state->cfg.agc[i].band_caps & band) {\n\t\t\tagc = &state->cfg.agc[i];\n\t\t\tbreak;\n\t\t}\n\n\tif (agc == NULL) {\n\t\tdprintk(\"no valid AGC configuration found for band 0x%02x\\n\", band);\n\t\treturn -EINVAL;\n\t}\n\n\tstate->current_agc = agc;\n\n\t \n\tdib7000p_write_word(state, 75, agc->setup);\n\tdib7000p_write_word(state, 76, agc->inv_gain);\n\tdib7000p_write_word(state, 77, agc->time_stabiliz);\n\tdib7000p_write_word(state, 100, (agc->alpha_level << 12) | agc->thlock);\n\n\t\n\tdib7000p_write_word(state, 101, (agc->alpha_mant << 5) | agc->alpha_exp);\n\tdib7000p_write_word(state, 102, (agc->beta_mant << 6) | agc->beta_exp);\n\n\t \n\tdprintk(\"WBD: ref: %d, sel: %d, active: %d, alpha: %d\\n\",\n\t\tstate->wbd_ref != 0 ? state->wbd_ref : agc->wbd_ref, agc->wbd_sel, !agc->perform_agc_softsplit, agc->wbd_sel);\n\n\tif (state->wbd_ref != 0)\n\t\tdib7000p_write_word(state, 105, (agc->wbd_inv << 12) | state->wbd_ref);\n\telse\n\t\tdib7000p_write_word(state, 105, (agc->wbd_inv << 12) | agc->wbd_ref);\n\n\tdib7000p_write_word(state, 106, (agc->wbd_sel << 13) | (agc->wbd_alpha << 9) | (agc->perform_agc_softsplit << 8));\n\n\tdib7000p_write_word(state, 107, agc->agc1_max);\n\tdib7000p_write_word(state, 108, agc->agc1_min);\n\tdib7000p_write_word(state, 109, agc->agc2_max);\n\tdib7000p_write_word(state, 110, agc->agc2_min);\n\tdib7000p_write_word(state, 111, (agc->agc1_pt1 << 8) | agc->agc1_pt2);\n\tdib7000p_write_word(state, 112, agc->agc1_pt3);\n\tdib7000p_write_word(state, 113, (agc->agc1_slope1 << 8) | agc->agc1_slope2);\n\tdib7000p_write_word(state, 114, (agc->agc2_pt1 << 8) | agc->agc2_pt2);\n\tdib7000p_write_word(state, 115, (agc->agc2_slope1 << 8) | agc->agc2_slope2);\n\treturn 0;\n}\n\nstatic int dib7000p_set_dds(struct dib7000p_state *state, s32 offset_khz)\n{\n\tu32 internal = dib7000p_get_internal_freq(state);\n\ts32 unit_khz_dds_val;\n\tu32 abs_offset_khz = abs(offset_khz);\n\tu32 dds = state->cfg.bw->ifreq & 0x1ffffff;\n\tu8 invert = !!(state->cfg.bw->ifreq & (1 << 25));\n\tif (internal == 0) {\n\t\tpr_warn(\"DIB7000P: dib7000p_get_internal_freq returned 0\\n\");\n\t\treturn -1;\n\t}\n\t \n\tunit_khz_dds_val = 67108864 / (internal);\n\n\tdprintk(\"setting a frequency offset of %dkHz internal freq = %d invert = %d\\n\", offset_khz, internal, invert);\n\n\tif (offset_khz < 0)\n\t\tunit_khz_dds_val *= -1;\n\n\t \n\tif (invert)\n\t\tdds -= (abs_offset_khz * unit_khz_dds_val);\t \n\telse\n\t\tdds += (abs_offset_khz * unit_khz_dds_val);\n\n\tif (abs_offset_khz <= (internal / 2)) {\t \n\t\tdib7000p_write_word(state, 21, (u16) (((dds >> 16) & 0x1ff) | (0 << 10) | (invert << 9)));\n\t\tdib7000p_write_word(state, 22, (u16) (dds & 0xffff));\n\t}\n\treturn 0;\n}\n\nstatic int dib7000p_agc_startup(struct dvb_frontend *demod)\n{\n\tstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\n\tstruct dib7000p_state *state = demod->demodulator_priv;\n\tint ret = -1;\n\tu8 *agc_state = &state->agc_state;\n\tu8 agc_split;\n\tu16 reg;\n\tu32 upd_demod_gain_period = 0x1000;\n\ts32 frequency_offset = 0;\n\n\tswitch (state->agc_state) {\n\tcase 0:\n\t\tdib7000p_set_power_mode(state, DIB7000P_POWER_ALL);\n\t\tif (state->version == SOC7090) {\n\t\t\treg = dib7000p_read_word(state, 0x79b) & 0xff00;\n\t\t\tdib7000p_write_word(state, 0x79a, upd_demod_gain_period & 0xFFFF);\t \n\t\t\tdib7000p_write_word(state, 0x79b, reg | (1 << 14) | ((upd_demod_gain_period >> 16) & 0xFF));\n\n\t\t\t \n\t\t\treg = dib7000p_read_word(state, 0x780);\n\t\t\tdib7000p_write_word(state, 0x780, (reg | (0x3)) & (~(1 << 7)));\n\t\t} else {\n\t\t\tdib7000p_set_adc_state(state, DIBX000_ADC_ON);\n\t\t\tdib7000p_pll_clk_cfg(state);\n\t\t}\n\n\t\tif (dib7000p_set_agc_config(state, BAND_OF_FREQUENCY(ch->frequency / 1000)) != 0)\n\t\t\treturn -1;\n\n\t\tif (demod->ops.tuner_ops.get_frequency) {\n\t\t\tu32 frequency_tuner;\n\n\t\t\tdemod->ops.tuner_ops.get_frequency(demod, &frequency_tuner);\n\t\t\tfrequency_offset = (s32)frequency_tuner / 1000 - ch->frequency / 1000;\n\t\t}\n\n\t\tif (dib7000p_set_dds(state, frequency_offset) < 0)\n\t\t\treturn -1;\n\n\t\tret = 7;\n\t\t(*agc_state)++;\n\t\tbreak;\n\n\tcase 1:\n\t\tif (state->cfg.agc_control)\n\t\t\tstate->cfg.agc_control(&state->demod, 1);\n\n\t\tdib7000p_write_word(state, 78, 32768);\n\t\tif (!state->current_agc->perform_agc_softsplit) {\n\t\t\t \n\t\t\t \n\t\t\tdib7000p_write_word(state, 106, (state->current_agc->wbd_sel << 13) | (state->current_agc->wbd_alpha << 9) | (1 << 8));\n\t\t\t(*agc_state)++;\n\t\t\tret = 5;\n\t\t} else {\n\t\t\t \n\t\t\t(*agc_state) = 4;\n\t\t\t \n\t\t\tret = 7;\n\t\t}\n\n\t\tdib7000p_restart_agc(state);\n\t\tbreak;\n\n\tcase 2:\t\t \n\t\tdib7000p_write_word(state, 75, state->current_agc->setup | (1 << 4));\t \n\t\tdib7000p_write_word(state, 106, (state->current_agc->wbd_sel << 13) | (2 << 9) | (0 << 8));\t \n\t\t(*agc_state)++;\n\t\tret = 14;\n\t\tbreak;\n\n\tcase 3:\t\t \n\t\tagc_split = (u8) dib7000p_read_word(state, 396);\t \n\t\tdib7000p_write_word(state, 78, dib7000p_read_word(state, 394));\t \n\n\t\tdib7000p_write_word(state, 75, state->current_agc->setup);\t \n\t\tdib7000p_write_word(state, 106, (state->current_agc->wbd_sel << 13) | (state->current_agc->wbd_alpha << 9) | agc_split);\t \n\n\t\tdib7000p_restart_agc(state);\n\n\t\tdprintk(\"SPLIT %p: %u\\n\", demod, agc_split);\n\n\t\t(*agc_state)++;\n\t\tret = 5;\n\t\tbreak;\n\n\tcase 4:\t\t \n\t\tret = 7;\n\n\t\tif (dib7000p_update_lna(state))\n\t\t\tret = 5;\n\t\telse\n\t\t\t(*agc_state)++;\n\t\tbreak;\n\n\tcase 5:\n\t\tif (state->cfg.agc_control)\n\t\t\tstate->cfg.agc_control(&state->demod, 0);\n\t\t(*agc_state)++;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void dib7000p_update_timf(struct dib7000p_state *state)\n{\n\tu32 timf = (dib7000p_read_word(state, 427) << 16) | dib7000p_read_word(state, 428);\n\tstate->timf = timf * 160 / (state->current_bandwidth / 50);\n\tdib7000p_write_word(state, 23, (u16) (timf >> 16));\n\tdib7000p_write_word(state, 24, (u16) (timf & 0xffff));\n\tdprintk(\"updated timf_frequency: %d (default: %d)\\n\", state->timf, state->cfg.bw->timf);\n\n}\n\nstatic u32 dib7000p_ctrl_timf(struct dvb_frontend *fe, u8 op, u32 timf)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tswitch (op) {\n\tcase DEMOD_TIMF_SET:\n\t\tstate->timf = timf;\n\t\tbreak;\n\tcase DEMOD_TIMF_UPDATE:\n\t\tdib7000p_update_timf(state);\n\t\tbreak;\n\tcase DEMOD_TIMF_GET:\n\t\tbreak;\n\t}\n\tdib7000p_set_bandwidth(state, state->current_bandwidth);\n\treturn state->timf;\n}\n\nstatic void dib7000p_set_channel(struct dib7000p_state *state,\n\t\t\t\t struct dtv_frontend_properties *ch, u8 seq)\n{\n\tu16 value, est[4];\n\n\tdib7000p_set_bandwidth(state, BANDWIDTH_TO_KHZ(ch->bandwidth_hz));\n\n\t \n\tvalue = 0;\n\tswitch (ch->transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\t\tvalue |= (0 << 7);\n\t\tbreak;\n\tcase TRANSMISSION_MODE_4K:\n\t\tvalue |= (2 << 7);\n\t\tbreak;\n\tdefault:\n\tcase TRANSMISSION_MODE_8K:\n\t\tvalue |= (1 << 7);\n\t\tbreak;\n\t}\n\tswitch (ch->guard_interval) {\n\tcase GUARD_INTERVAL_1_32:\n\t\tvalue |= (0 << 5);\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_16:\n\t\tvalue |= (1 << 5);\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_4:\n\t\tvalue |= (3 << 5);\n\t\tbreak;\n\tdefault:\n\tcase GUARD_INTERVAL_1_8:\n\t\tvalue |= (2 << 5);\n\t\tbreak;\n\t}\n\tswitch (ch->modulation) {\n\tcase QPSK:\n\t\tvalue |= (0 << 3);\n\t\tbreak;\n\tcase QAM_16:\n\t\tvalue |= (1 << 3);\n\t\tbreak;\n\tdefault:\n\tcase QAM_64:\n\t\tvalue |= (2 << 3);\n\t\tbreak;\n\t}\n\tswitch (HIERARCHY_1) {\n\tcase HIERARCHY_2:\n\t\tvalue |= 2;\n\t\tbreak;\n\tcase HIERARCHY_4:\n\t\tvalue |= 4;\n\t\tbreak;\n\tdefault:\n\tcase HIERARCHY_1:\n\t\tvalue |= 1;\n\t\tbreak;\n\t}\n\tdib7000p_write_word(state, 0, value);\n\tdib7000p_write_word(state, 5, (seq << 4) | 1);\t \n\n\t \n\tvalue = 0;\n\tif (1 != 0)\n\t\tvalue |= (1 << 6);\n\tif (ch->hierarchy == 1)\n\t\tvalue |= (1 << 4);\n\tif (1 == 1)\n\t\tvalue |= 1;\n\tswitch ((ch->hierarchy == 0 || 1 == 1) ? ch->code_rate_HP : ch->code_rate_LP) {\n\tcase FEC_2_3:\n\t\tvalue |= (2 << 1);\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tvalue |= (3 << 1);\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tvalue |= (5 << 1);\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tvalue |= (7 << 1);\n\t\tbreak;\n\tdefault:\n\tcase FEC_1_2:\n\t\tvalue |= (1 << 1);\n\t\tbreak;\n\t}\n\tdib7000p_write_word(state, 208, value);\n\n\t \n\tdib7000p_write_word(state, 26, 0x6680);\n\tdib7000p_write_word(state, 32, 0x0003);\n\tdib7000p_write_word(state, 29, 0x1273);\n\tdib7000p_write_word(state, 33, 0x0005);\n\n\t \n\tswitch (ch->transmission_mode) {\n\tcase TRANSMISSION_MODE_8K:\n\t\tvalue = 256;\n\t\tbreak;\n\tcase TRANSMISSION_MODE_4K:\n\t\tvalue = 128;\n\t\tbreak;\n\tcase TRANSMISSION_MODE_2K:\n\tdefault:\n\t\tvalue = 64;\n\t\tbreak;\n\t}\n\tswitch (ch->guard_interval) {\n\tcase GUARD_INTERVAL_1_16:\n\t\tvalue *= 2;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_8:\n\t\tvalue *= 4;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_4:\n\t\tvalue *= 8;\n\t\tbreak;\n\tdefault:\n\tcase GUARD_INTERVAL_1_32:\n\t\tvalue *= 1;\n\t\tbreak;\n\t}\n\tif (state->cfg.diversity_delay == 0)\n\t\tstate->div_sync_wait = (value * 3) / 2 + 48;\n\telse\n\t\tstate->div_sync_wait = (value * 3) / 2 + state->cfg.diversity_delay;\n\n\t \n\tstate->div_force_off = !1 && ch->transmission_mode != TRANSMISSION_MODE_8K;\n\tdib7000p_set_diversity_in(&state->demod, state->div_state);\n\n\t \n\tswitch (ch->modulation) {\n\tcase QAM_64:\n\t\test[0] = 0x0148;\t \n\t\test[1] = 0xfff0;\t \n\t\test[2] = 0x00a4;\t \n\t\test[3] = 0xfff8;\t \n\t\tbreak;\n\tcase QAM_16:\n\t\test[0] = 0x023d;\t \n\t\test[1] = 0xffdf;\t \n\t\test[2] = 0x00a4;\t \n\t\test[3] = 0xfff0;\t \n\t\tbreak;\n\tdefault:\n\t\test[0] = 0x099a;\t \n\t\test[1] = 0xffae;\t \n\t\test[2] = 0x0333;\t \n\t\test[3] = 0xfff8;\t \n\t\tbreak;\n\t}\n\tfor (value = 0; value < 4; value++)\n\t\tdib7000p_write_word(state, 187 + value, est[value]);\n}\n\nstatic int dib7000p_autosearch_start(struct dvb_frontend *demod)\n{\n\tstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\n\tstruct dib7000p_state *state = demod->demodulator_priv;\n\tstruct dtv_frontend_properties schan;\n\tu32 value, factor;\n\tu32 internal = dib7000p_get_internal_freq(state);\n\n\tschan = *ch;\n\tschan.modulation = QAM_64;\n\tschan.guard_interval = GUARD_INTERVAL_1_32;\n\tschan.transmission_mode = TRANSMISSION_MODE_8K;\n\tschan.code_rate_HP = FEC_2_3;\n\tschan.code_rate_LP = FEC_3_4;\n\tschan.hierarchy = 0;\n\n\tdib7000p_set_channel(state, &schan, 7);\n\n\tfactor = BANDWIDTH_TO_KHZ(ch->bandwidth_hz);\n\tif (factor >= 5000) {\n\t\tif (state->version == SOC7090)\n\t\t\tfactor = 2;\n\t\telse\n\t\t\tfactor = 1;\n\t} else\n\t\tfactor = 6;\n\n\tvalue = 30 * internal * factor;\n\tdib7000p_write_word(state, 6, (u16) ((value >> 16) & 0xffff));\n\tdib7000p_write_word(state, 7, (u16) (value & 0xffff));\n\tvalue = 100 * internal * factor;\n\tdib7000p_write_word(state, 8, (u16) ((value >> 16) & 0xffff));\n\tdib7000p_write_word(state, 9, (u16) (value & 0xffff));\n\tvalue = 500 * internal * factor;\n\tdib7000p_write_word(state, 10, (u16) ((value >> 16) & 0xffff));\n\tdib7000p_write_word(state, 11, (u16) (value & 0xffff));\n\n\tvalue = dib7000p_read_word(state, 0);\n\tdib7000p_write_word(state, 0, (u16) ((1 << 9) | value));\n\tdib7000p_read_word(state, 1284);\n\tdib7000p_write_word(state, 0, (u16) value);\n\n\treturn 0;\n}\n\nstatic int dib7000p_autosearch_is_irq(struct dvb_frontend *demod)\n{\n\tstruct dib7000p_state *state = demod->demodulator_priv;\n\tu16 irq_pending = dib7000p_read_word(state, 1284);\n\n\tif (irq_pending & 0x1)\n\t\treturn 1;\n\n\tif (irq_pending & 0x2)\n\t\treturn 2;\n\n\treturn 0;\n}\n\nstatic void dib7000p_spur_protect(struct dib7000p_state *state, u32 rf_khz, u32 bw)\n{\n\tstatic const s16 notch[] = { 16143, 14402, 12238, 9713, 6902, 3888, 759, -2392 };\n\tstatic const u8 sine[] = { 0, 2, 3, 5, 6, 8, 9, 11, 13, 14, 16, 17, 19, 20, 22,\n\t\t24, 25, 27, 28, 30, 31, 33, 34, 36, 38, 39, 41, 42, 44, 45, 47, 48, 50, 51,\n\t\t53, 55, 56, 58, 59, 61, 62, 64, 65, 67, 68, 70, 71, 73, 74, 76, 77, 79, 80,\n\t\t82, 83, 85, 86, 88, 89, 91, 92, 94, 95, 97, 98, 99, 101, 102, 104, 105,\n\t\t107, 108, 109, 111, 112, 114, 115, 117, 118, 119, 121, 122, 123, 125, 126,\n\t\t128, 129, 130, 132, 133, 134, 136, 137, 138, 140, 141, 142, 144, 145, 146,\n\t\t147, 149, 150, 151, 152, 154, 155, 156, 157, 159, 160, 161, 162, 164, 165,\n\t\t166, 167, 168, 170, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 182,\n\t\t183, 184, 185, 186, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198,\n\t\t199, 200, 201, 202, 203, 204, 205, 206, 207, 207, 208, 209, 210, 211, 212,\n\t\t213, 214, 215, 215, 216, 217, 218, 219, 220, 220, 221, 222, 223, 224, 224,\n\t\t225, 226, 227, 227, 228, 229, 229, 230, 231, 231, 232, 233, 233, 234, 235,\n\t\t235, 236, 237, 237, 238, 238, 239, 239, 240, 241, 241, 242, 242, 243, 243,\n\t\t244, 244, 245, 245, 245, 246, 246, 247, 247, 248, 248, 248, 249, 249, 249,\n\t\t250, 250, 250, 251, 251, 251, 252, 252, 252, 252, 253, 253, 253, 253, 254,\n\t\t254, 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t\t255, 255, 255, 255, 255, 255\n\t};\n\n\tu32 xtal = state->cfg.bw->xtal_hz / 1000;\n\tint f_rel = DIV_ROUND_CLOSEST(rf_khz, xtal) * xtal - rf_khz;\n\tint k;\n\tint coef_re[8], coef_im[8];\n\tint bw_khz = bw;\n\tu32 pha;\n\n\tdprintk(\"relative position of the Spur: %dk (RF: %dk, XTAL: %dk)\\n\", f_rel, rf_khz, xtal);\n\n\tif (f_rel < -bw_khz / 2 || f_rel > bw_khz / 2)\n\t\treturn;\n\n\tbw_khz /= 100;\n\n\tdib7000p_write_word(state, 142, 0x0610);\n\n\tfor (k = 0; k < 8; k++) {\n\t\tpha = ((f_rel * (k + 1) * 112 * 80 / bw_khz) / 1000) & 0x3ff;\n\n\t\tif (pha == 0) {\n\t\t\tcoef_re[k] = 256;\n\t\t\tcoef_im[k] = 0;\n\t\t} else if (pha < 256) {\n\t\t\tcoef_re[k] = sine[256 - (pha & 0xff)];\n\t\t\tcoef_im[k] = sine[pha & 0xff];\n\t\t} else if (pha == 256) {\n\t\t\tcoef_re[k] = 0;\n\t\t\tcoef_im[k] = 256;\n\t\t} else if (pha < 512) {\n\t\t\tcoef_re[k] = -sine[pha & 0xff];\n\t\t\tcoef_im[k] = sine[256 - (pha & 0xff)];\n\t\t} else if (pha == 512) {\n\t\t\tcoef_re[k] = -256;\n\t\t\tcoef_im[k] = 0;\n\t\t} else if (pha < 768) {\n\t\t\tcoef_re[k] = -sine[256 - (pha & 0xff)];\n\t\t\tcoef_im[k] = -sine[pha & 0xff];\n\t\t} else if (pha == 768) {\n\t\t\tcoef_re[k] = 0;\n\t\t\tcoef_im[k] = -256;\n\t\t} else {\n\t\t\tcoef_re[k] = sine[pha & 0xff];\n\t\t\tcoef_im[k] = -sine[256 - (pha & 0xff)];\n\t\t}\n\n\t\tcoef_re[k] *= notch[k];\n\t\tcoef_re[k] += (1 << 14);\n\t\tif (coef_re[k] >= (1 << 24))\n\t\t\tcoef_re[k] = (1 << 24) - 1;\n\t\tcoef_re[k] /= (1 << 15);\n\n\t\tcoef_im[k] *= notch[k];\n\t\tcoef_im[k] += (1 << 14);\n\t\tif (coef_im[k] >= (1 << 24))\n\t\t\tcoef_im[k] = (1 << 24) - 1;\n\t\tcoef_im[k] /= (1 << 15);\n\n\t\tdprintk(\"PALF COEF: %d re: %d im: %d\\n\", k, coef_re[k], coef_im[k]);\n\n\t\tdib7000p_write_word(state, 143, (0 << 14) | (k << 10) | (coef_re[k] & 0x3ff));\n\t\tdib7000p_write_word(state, 144, coef_im[k] & 0x3ff);\n\t\tdib7000p_write_word(state, 143, (1 << 14) | (k << 10) | (coef_re[k] & 0x3ff));\n\t}\n\tdib7000p_write_word(state, 143, 0);\n}\n\nstatic int dib7000p_tune(struct dvb_frontend *demod)\n{\n\tstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\n\tstruct dib7000p_state *state = demod->demodulator_priv;\n\tu16 tmp = 0;\n\n\tif (ch != NULL)\n\t\tdib7000p_set_channel(state, ch, 0);\n\telse\n\t\treturn -EINVAL;\n\n\t\n\tdib7000p_write_word(state, 770, 0x4000);\n\tdib7000p_write_word(state, 770, 0x0000);\n\tmsleep(45);\n\n\t \n\ttmp = (0 << 14) | (4 << 10) | (0 << 9) | (3 << 5) | (1 << 4) | (0x3);\n\tif (state->sfn_workaround_active) {\n\t\tdprintk(\"SFN workaround is active\\n\");\n\t\ttmp |= (1 << 9);\n\t\tdib7000p_write_word(state, 166, 0x4000);\n\t} else {\n\t\tdib7000p_write_word(state, 166, 0x0000);\n\t}\n\tdib7000p_write_word(state, 29, tmp);\n\n\t\n\tif (state->timf == 0)\n\t\tmsleep(200);\n\n\t \n\n\t \n\ttmp = (6 << 8) | 0x80;\n\tswitch (ch->transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\t\ttmp |= (2 << 12);\n\t\tbreak;\n\tcase TRANSMISSION_MODE_4K:\n\t\ttmp |= (3 << 12);\n\t\tbreak;\n\tdefault:\n\tcase TRANSMISSION_MODE_8K:\n\t\ttmp |= (4 << 12);\n\t\tbreak;\n\t}\n\tdib7000p_write_word(state, 26, tmp);\t \n\n\t \n\ttmp = (0 << 4);\n\tswitch (ch->transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\t\ttmp |= 0x6;\n\t\tbreak;\n\tcase TRANSMISSION_MODE_4K:\n\t\ttmp |= 0x7;\n\t\tbreak;\n\tdefault:\n\tcase TRANSMISSION_MODE_8K:\n\t\ttmp |= 0x8;\n\t\tbreak;\n\t}\n\tdib7000p_write_word(state, 32, tmp);\n\n\t \n\ttmp = (0 << 4);\n\tswitch (ch->transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\t\ttmp |= 0x6;\n\t\tbreak;\n\tcase TRANSMISSION_MODE_4K:\n\t\ttmp |= 0x7;\n\t\tbreak;\n\tdefault:\n\tcase TRANSMISSION_MODE_8K:\n\t\ttmp |= 0x8;\n\t\tbreak;\n\t}\n\tdib7000p_write_word(state, 33, tmp);\n\n\ttmp = dib7000p_read_word(state, 509);\n\tif (!((tmp >> 6) & 0x1)) {\n\t\t \n\t\ttmp = dib7000p_read_word(state, 771);\n\t\tdib7000p_write_word(state, 771, tmp | (1 << 1));\n\t\tdib7000p_write_word(state, 771, tmp);\n\t\tmsleep(40);\n\t\ttmp = dib7000p_read_word(state, 509);\n\t}\n\t\n\tif ((tmp >> 6) & 0x1) {\n\t\tdib7000p_update_timf(state);\n\t\t \n\t\ttmp = dib7000p_read_word(state, 26);\n\t\tdib7000p_write_word(state, 26, (tmp & ~(0xf << 12)) | ((((tmp >> 12) & 0xf) + 5) << 12));\n\t}\n\n\tif (state->cfg.spur_protect)\n\t\tdib7000p_spur_protect(state, ch->frequency / 1000, BANDWIDTH_TO_KHZ(ch->bandwidth_hz));\n\n\tdib7000p_set_bandwidth(state, BANDWIDTH_TO_KHZ(ch->bandwidth_hz));\n\n\tdib7000p_reset_stats(demod);\n\n\treturn 0;\n}\n\nstatic int dib7000p_wakeup(struct dvb_frontend *demod)\n{\n\tstruct dib7000p_state *state = demod->demodulator_priv;\n\tdib7000p_set_power_mode(state, DIB7000P_POWER_ALL);\n\tdib7000p_set_adc_state(state, DIBX000_SLOW_ADC_ON);\n\tif (state->version == SOC7090)\n\t\tdib7000p_sad_calib(state);\n\treturn 0;\n}\n\nstatic int dib7000p_sleep(struct dvb_frontend *demod)\n{\n\tstruct dib7000p_state *state = demod->demodulator_priv;\n\tif (state->version == SOC7090)\n\t\treturn dib7000p_set_power_mode(state, DIB7000P_POWER_INTERFACE_ONLY);\n\treturn dib7000p_set_output_mode(state, OUTMODE_HIGH_Z) | dib7000p_set_power_mode(state, DIB7000P_POWER_INTERFACE_ONLY);\n}\n\nstatic int dib7000p_identify(struct dib7000p_state *st)\n{\n\tu16 value;\n\tdprintk(\"checking demod on I2C address: %d (%x)\\n\", st->i2c_addr, st->i2c_addr);\n\n\tif ((value = dib7000p_read_word(st, 768)) != 0x01b3) {\n\t\tdprintk(\"wrong Vendor ID (read=0x%x)\\n\", value);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif ((value = dib7000p_read_word(st, 769)) != 0x4000) {\n\t\tdprintk(\"wrong Device ID (%x)\\n\", value);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int dib7000p_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t struct dtv_frontend_properties *fep)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tu16 tps = dib7000p_read_word(state, 463);\n\n\tfep->inversion = INVERSION_AUTO;\n\n\tfep->bandwidth_hz = BANDWIDTH_TO_HZ(state->current_bandwidth);\n\n\tswitch ((tps >> 8) & 0x3) {\n\tcase 0:\n\t\tfep->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n\tcase 1:\n\t\tfep->transmission_mode = TRANSMISSION_MODE_8K;\n\t\tbreak;\n\t \n\t}\n\n\tswitch (tps & 0x3) {\n\tcase 0:\n\t\tfep->guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\tfep->guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\tfep->guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tfep->guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\t}\n\n\tswitch ((tps >> 14) & 0x3) {\n\tcase 0:\n\t\tfep->modulation = QPSK;\n\t\tbreak;\n\tcase 1:\n\t\tfep->modulation = QAM_16;\n\t\tbreak;\n\tcase 2:\n\tdefault:\n\t\tfep->modulation = QAM_64;\n\t\tbreak;\n\t}\n\n\t \n\t \n\n\tfep->hierarchy = HIERARCHY_NONE;\n\tswitch ((tps >> 5) & 0x7) {\n\tcase 1:\n\t\tfep->code_rate_HP = FEC_1_2;\n\t\tbreak;\n\tcase 2:\n\t\tfep->code_rate_HP = FEC_2_3;\n\t\tbreak;\n\tcase 3:\n\t\tfep->code_rate_HP = FEC_3_4;\n\t\tbreak;\n\tcase 5:\n\t\tfep->code_rate_HP = FEC_5_6;\n\t\tbreak;\n\tcase 7:\n\tdefault:\n\t\tfep->code_rate_HP = FEC_7_8;\n\t\tbreak;\n\n\t}\n\n\tswitch ((tps >> 2) & 0x7) {\n\tcase 1:\n\t\tfep->code_rate_LP = FEC_1_2;\n\t\tbreak;\n\tcase 2:\n\t\tfep->code_rate_LP = FEC_2_3;\n\t\tbreak;\n\tcase 3:\n\t\tfep->code_rate_LP = FEC_3_4;\n\t\tbreak;\n\tcase 5:\n\t\tfep->code_rate_LP = FEC_5_6;\n\t\tbreak;\n\tcase 7:\n\tdefault:\n\t\tfep->code_rate_LP = FEC_7_8;\n\t\tbreak;\n\t}\n\n\t \n\n\treturn 0;\n}\n\nstatic int dib7000p_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *fep = &fe->dtv_property_cache;\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tint time, ret;\n\n\tif (state->version == SOC7090)\n\t\tdib7090_set_diversity_in(fe, 0);\n\telse\n\t\tdib7000p_set_output_mode(state, OUTMODE_HIGH_Z);\n\n\t \n\tstate->sfn_workaround_active = buggy_sfn_workaround;\n\n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\n\t \n\tstate->agc_state = 0;\n\tdo {\n\t\ttime = dib7000p_agc_startup(fe);\n\t\tif (time != -1)\n\t\t\tmsleep(time);\n\t} while (time != -1);\n\n\tif (fep->transmission_mode == TRANSMISSION_MODE_AUTO ||\n\t\tfep->guard_interval == GUARD_INTERVAL_AUTO || fep->modulation == QAM_AUTO || fep->code_rate_HP == FEC_AUTO) {\n\t\tint i = 800, found;\n\n\t\tdib7000p_autosearch_start(fe);\n\t\tdo {\n\t\t\tmsleep(1);\n\t\t\tfound = dib7000p_autosearch_is_irq(fe);\n\t\t} while (found == 0 && i--);\n\n\t\tdprintk(\"autosearch returns: %d\\n\", found);\n\t\tif (found == 0 || found == 1)\n\t\t\treturn 0;\n\n\t\tdib7000p_get_frontend(fe, fep);\n\t}\n\n\tret = dib7000p_tune(fe);\n\n\t \n\tif (state->version == SOC7090) {\n\t\tdib7090_set_output_mode(fe, state->cfg.output_mode);\n\t\tif (state->cfg.enMpegOutput == 0) {\n\t\t\tdib7090_setDibTxMux(state, MPEG_ON_DIBTX);\n\t\t\tdib7090_setHostBusMux(state, DIBTX_ON_HOSTBUS);\n\t\t}\n\t} else\n\t\tdib7000p_set_output_mode(state, state->cfg.output_mode);\n\n\treturn ret;\n}\n\nstatic int dib7000p_get_stats(struct dvb_frontend *fe, enum fe_status stat);\n\nstatic int dib7000p_read_status(struct dvb_frontend *fe, enum fe_status *stat)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tu16 lock = dib7000p_read_word(state, 509);\n\n\t*stat = 0;\n\n\tif (lock & 0x8000)\n\t\t*stat |= FE_HAS_SIGNAL;\n\tif (lock & 0x3000)\n\t\t*stat |= FE_HAS_CARRIER;\n\tif (lock & 0x0100)\n\t\t*stat |= FE_HAS_VITERBI;\n\tif (lock & 0x0010)\n\t\t*stat |= FE_HAS_SYNC;\n\tif ((lock & 0x0038) == 0x38)\n\t\t*stat |= FE_HAS_LOCK;\n\n\tdib7000p_get_stats(fe, *stat);\n\n\treturn 0;\n}\n\nstatic int dib7000p_read_ber(struct dvb_frontend *fe, u32 * ber)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\t*ber = (dib7000p_read_word(state, 500) << 16) | dib7000p_read_word(state, 501);\n\treturn 0;\n}\n\nstatic int dib7000p_read_unc_blocks(struct dvb_frontend *fe, u32 * unc)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\t*unc = dib7000p_read_word(state, 506);\n\treturn 0;\n}\n\nstatic int dib7000p_read_signal_strength(struct dvb_frontend *fe, u16 * strength)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tu16 val = dib7000p_read_word(state, 394);\n\t*strength = 65535 - val;\n\treturn 0;\n}\n\nstatic u32 dib7000p_get_snr(struct dvb_frontend *fe)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tu16 val;\n\ts32 signal_mant, signal_exp, noise_mant, noise_exp;\n\tu32 result = 0;\n\n\tval = dib7000p_read_word(state, 479);\n\tnoise_mant = (val >> 4) & 0xff;\n\tnoise_exp = ((val & 0xf) << 2);\n\tval = dib7000p_read_word(state, 480);\n\tnoise_exp += ((val >> 14) & 0x3);\n\tif ((noise_exp & 0x20) != 0)\n\t\tnoise_exp -= 0x40;\n\n\tsignal_mant = (val >> 6) & 0xFF;\n\tsignal_exp = (val & 0x3F);\n\tif ((signal_exp & 0x20) != 0)\n\t\tsignal_exp -= 0x40;\n\n\tif (signal_mant != 0)\n\t\tresult = intlog10(2) * 10 * signal_exp + 10 * intlog10(signal_mant);\n\telse\n\t\tresult = intlog10(2) * 10 * signal_exp - 100;\n\n\tif (noise_mant != 0)\n\t\tresult -= intlog10(2) * 10 * noise_exp + 10 * intlog10(noise_mant);\n\telse\n\t\tresult -= intlog10(2) * 10 * noise_exp - 100;\n\n\treturn result;\n}\n\nstatic int dib7000p_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tu32 result;\n\n\tresult = dib7000p_get_snr(fe);\n\n\t*snr = result / ((1 << 24) / 10);\n\treturn 0;\n}\n\nstatic void dib7000p_reset_stats(struct dvb_frontend *demod)\n{\n\tstruct dib7000p_state *state = demod->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &demod->dtv_property_cache;\n\tu32 ucb;\n\n\tmemset(&c->strength, 0, sizeof(c->strength));\n\tmemset(&c->cnr, 0, sizeof(c->cnr));\n\tmemset(&c->post_bit_error, 0, sizeof(c->post_bit_error));\n\tmemset(&c->post_bit_count, 0, sizeof(c->post_bit_count));\n\tmemset(&c->block_error, 0, sizeof(c->block_error));\n\n\tc->strength.len = 1;\n\tc->cnr.len = 1;\n\tc->block_error.len = 1;\n\tc->block_count.len = 1;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_count.len = 1;\n\n\tc->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\tc->strength.stat[0].uvalue = 0;\n\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\tdib7000p_read_unc_blocks(demod, &ucb);\n\n\tstate->old_ucb = ucb;\n\tstate->ber_jiffies_stats = 0;\n\tstate->per_jiffies_stats = 0;\n}\n\nstruct linear_segments {\n\tunsigned x;\n\tsigned y;\n};\n\n \n#define DB_OFFSET 131000\n\nstatic struct linear_segments strength_to_db_table[] = {\n\t{ 63630, DB_OFFSET - 20500},\n\t{ 62273, DB_OFFSET - 21000},\n\t{ 60162, DB_OFFSET - 22000},\n\t{ 58730, DB_OFFSET - 23000},\n\t{ 58294, DB_OFFSET - 24000},\n\t{ 57778, DB_OFFSET - 25000},\n\t{ 57320, DB_OFFSET - 26000},\n\t{ 56779, DB_OFFSET - 27000},\n\t{ 56293, DB_OFFSET - 28000},\n\t{ 55724, DB_OFFSET - 29000},\n\t{ 55145, DB_OFFSET - 30000},\n\t{ 54680, DB_OFFSET - 31000},\n\t{ 54293, DB_OFFSET - 32000},\n\t{ 53813, DB_OFFSET - 33000},\n\t{ 53427, DB_OFFSET - 34000},\n\t{ 52981, DB_OFFSET - 35000},\n\n\t{ 52636, DB_OFFSET - 36000},\n\t{ 52014, DB_OFFSET - 37000},\n\t{ 51674, DB_OFFSET - 38000},\n\t{ 50692, DB_OFFSET - 39000},\n\t{ 49824, DB_OFFSET - 40000},\n\t{ 49052, DB_OFFSET - 41000},\n\t{ 48436, DB_OFFSET - 42000},\n\t{ 47836, DB_OFFSET - 43000},\n\t{ 47368, DB_OFFSET - 44000},\n\t{ 46468, DB_OFFSET - 45000},\n\t{ 45597, DB_OFFSET - 46000},\n\t{ 44586, DB_OFFSET - 47000},\n\t{ 43667, DB_OFFSET - 48000},\n\t{ 42673, DB_OFFSET - 49000},\n\t{ 41816, DB_OFFSET - 50000},\n\t{ 40876, DB_OFFSET - 51000},\n\t{     0,      0},\n};\n\nstatic u32 interpolate_value(u32 value, struct linear_segments *segments,\n\t\t\t     unsigned len)\n{\n\tu64 tmp64;\n\tu32 dx;\n\ts32 dy;\n\tint i, ret;\n\n\tif (value >= segments[0].x)\n\t\treturn segments[0].y;\n\tif (value < segments[len-1].x)\n\t\treturn segments[len-1].y;\n\n\tfor (i = 1; i < len - 1; i++) {\n\t\t \n\t\tif (value == segments[i].x)\n\t\t\treturn segments[i].y;\n\t\tif (value > segments[i].x)\n\t\t\tbreak;\n\t}\n\n\t \n\tdy = segments[i - 1].y - segments[i].y;\n\tdx = segments[i - 1].x - segments[i].x;\n\n\ttmp64 = value - segments[i].x;\n\ttmp64 *= dy;\n\tdo_div(tmp64, dx);\n\tret = segments[i].y + tmp64;\n\n\treturn ret;\n}\n\n \nstatic u32 dib7000p_get_time_us(struct dvb_frontend *demod)\n{\n\tstruct dtv_frontend_properties *c = &demod->dtv_property_cache;\n\tu64 time_us, tmp64;\n\tu32 tmp, denom;\n\tint guard, rate_num, rate_denum = 1, bits_per_symbol;\n\tint interleaving = 0, fft_div;\n\n\tswitch (c->guard_interval) {\n\tcase GUARD_INTERVAL_1_4:\n\t\tguard = 4;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_8:\n\t\tguard = 8;\n\t\tbreak;\n\tcase GUARD_INTERVAL_1_16:\n\t\tguard = 16;\n\t\tbreak;\n\tdefault:\n\tcase GUARD_INTERVAL_1_32:\n\t\tguard = 32;\n\t\tbreak;\n\t}\n\n\tswitch (c->transmission_mode) {\n\tcase TRANSMISSION_MODE_2K:\n\t\tfft_div = 4;\n\t\tbreak;\n\tcase TRANSMISSION_MODE_4K:\n\t\tfft_div = 2;\n\t\tbreak;\n\tdefault:\n\tcase TRANSMISSION_MODE_8K:\n\t\tfft_div = 1;\n\t\tbreak;\n\t}\n\n\tswitch (c->modulation) {\n\tcase DQPSK:\n\tcase QPSK:\n\t\tbits_per_symbol = 2;\n\t\tbreak;\n\tcase QAM_16:\n\t\tbits_per_symbol = 4;\n\t\tbreak;\n\tdefault:\n\tcase QAM_64:\n\t\tbits_per_symbol = 6;\n\t\tbreak;\n\t}\n\n\tswitch ((c->hierarchy == 0 || 1 == 1) ? c->code_rate_HP : c->code_rate_LP) {\n\tcase FEC_1_2:\n\t\trate_num = 1;\n\t\trate_denum = 2;\n\t\tbreak;\n\tcase FEC_2_3:\n\t\trate_num = 2;\n\t\trate_denum = 3;\n\t\tbreak;\n\tcase FEC_3_4:\n\t\trate_num = 3;\n\t\trate_denum = 4;\n\t\tbreak;\n\tcase FEC_5_6:\n\t\trate_num = 5;\n\t\trate_denum = 6;\n\t\tbreak;\n\tdefault:\n\tcase FEC_7_8:\n\t\trate_num = 7;\n\t\trate_denum = 8;\n\t\tbreak;\n\t}\n\n\tdenom = bits_per_symbol * rate_num * fft_div * 384;\n\n\t \n\n\t \n\tif (!denom)\n\t\treturn 0;\n\n\t \n\ttime_us = rate_denum * (1008 * 1562500L);\n\ttmp64 = time_us;\n\tdo_div(tmp64, guard);\n\ttime_us = time_us + tmp64;\n\ttime_us += denom / 2;\n\tdo_div(time_us, denom);\n\n\ttmp = 1008 * 96 * interleaving;\n\ttime_us += tmp + tmp / guard;\n\n\treturn time_us;\n}\n\nstatic int dib7000p_get_stats(struct dvb_frontend *demod, enum fe_status stat)\n{\n\tstruct dib7000p_state *state = demod->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &demod->dtv_property_cache;\n\tint show_per_stats = 0;\n\tu32 time_us = 0, val, snr;\n\tu64 blocks, ucb;\n\ts32 db;\n\tu16 strength;\n\n\t \n\tdib7000p_read_signal_strength(demod, &strength);\n\tval = strength;\n\tdb = interpolate_value(val,\n\t\t\t       strength_to_db_table,\n\t\t\t       ARRAY_SIZE(strength_to_db_table)) - DB_OFFSET;\n\tc->strength.stat[0].svalue = db;\n\n\t \n\tif (!(stat & FE_HAS_LOCK)) {\n\t\tc->cnr.len = 1;\n\t\tc->block_count.len = 1;\n\t\tc->block_error.len = 1;\n\t\tc->post_bit_error.len = 1;\n\t\tc->post_bit_count.len = 1;\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\treturn 0;\n\t}\n\n\t \n\tif (time_after(jiffies, state->per_jiffies_stats)) {\n\t\tstate->per_jiffies_stats = jiffies + msecs_to_jiffies(1000);\n\n\t\t \n\t\tsnr = dib7000p_get_snr(demod);\n\t\tif (snr)\n\t\t\tsnr = (1000L * snr) >> 24;\n\t\telse\n\t\t\tsnr = 0;\n\t\tc->cnr.stat[0].svalue = snr;\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\n\t\t \n\t\tdib7000p_read_unc_blocks(demod, &val);\n\t\tucb = val - state->old_ucb;\n\t\tif (val < state->old_ucb)\n\t\t\tucb += 0x100000000LL;\n\n\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_error.stat[0].uvalue = ucb;\n\n\t\t \n\t\tif (!time_us)\n\t\t\ttime_us = dib7000p_get_time_us(demod);\n\n\t\tif (time_us) {\n\t\t\tblocks = 1250000ULL * 1000000ULL;\n\t\t\tdo_div(blocks, time_us * 8 * 204);\n\t\t\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->block_count.stat[0].uvalue += blocks;\n\t\t}\n\n\t\tshow_per_stats = 1;\n\t}\n\n\t \n\tif (time_after(jiffies, state->ber_jiffies_stats)) {\n\t\ttime_us = dib7000p_get_time_us(demod);\n\t\tstate->ber_jiffies_stats = jiffies + msecs_to_jiffies((time_us + 500) / 1000);\n\n\t\tdprintk(\"Next all layers stats available in %u us.\\n\", time_us);\n\n\t\tdib7000p_read_ber(demod, &val);\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[0].uvalue += val;\n\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[0].uvalue += 100000000;\n\t}\n\n\t \n\tif (show_per_stats) {\n\t\tdib7000p_read_unc_blocks(demod, &val);\n\n\t\tc->block_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->block_error.stat[0].uvalue += val;\n\n\t\ttime_us = dib7000p_get_time_us(demod);\n\t\tif (time_us) {\n\t\t\tblocks = 1250000ULL * 1000000ULL;\n\t\t\tdo_div(blocks, time_us * 8 * 204);\n\t\t\tc->block_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\t\tc->block_count.stat[0].uvalue += blocks;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dib7000p_fe_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic void dib7000p_release(struct dvb_frontend *demod)\n{\n\tstruct dib7000p_state *st = demod->demodulator_priv;\n\tdibx000_exit_i2c_master(&st->i2c_master);\n\ti2c_del_adapter(&st->dib7090_tuner_adap);\n\tkfree(st);\n}\n\nstatic int dib7000pc_detection(struct i2c_adapter *i2c_adap)\n{\n\tu8 *tx, *rx;\n\tstruct i2c_msg msg[2] = {\n\t\t{.addr = 18 >> 1, .flags = 0, .len = 2},\n\t\t{.addr = 18 >> 1, .flags = I2C_M_RD, .len = 2},\n\t};\n\tint ret = 0;\n\n\ttx = kzalloc(2, GFP_KERNEL);\n\tif (!tx)\n\t\treturn -ENOMEM;\n\trx = kzalloc(2, GFP_KERNEL);\n\tif (!rx) {\n\t\tret = -ENOMEM;\n\t\tgoto rx_memory_error;\n\t}\n\n\tmsg[0].buf = tx;\n\tmsg[1].buf = rx;\n\n\ttx[0] = 0x03;\n\ttx[1] = 0x00;\n\n\tif (i2c_transfer(i2c_adap, msg, 2) == 2)\n\t\tif (rx[0] == 0x01 && rx[1] == 0xb3) {\n\t\t\tdprintk(\"-D-  DiB7000PC detected\\n\");\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\tmsg[0].addr = msg[1].addr = 0x40;\n\n\tif (i2c_transfer(i2c_adap, msg, 2) == 2)\n\t\tif (rx[0] == 0x01 && rx[1] == 0xb3) {\n\t\t\tdprintk(\"-D-  DiB7000PC detected\\n\");\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\tdprintk(\"-D-  DiB7000PC not detected\\n\");\n\nout:\n\tkfree(rx);\nrx_memory_error:\n\tkfree(tx);\n\treturn ret;\n}\n\nstatic struct i2c_adapter *dib7000p_get_i2c_master(struct dvb_frontend *demod, enum dibx000_i2c_interface intf, int gating)\n{\n\tstruct dib7000p_state *st = demod->demodulator_priv;\n\treturn dibx000_get_i2c_adapter(&st->i2c_master, intf, gating);\n}\n\nstatic int dib7000p_pid_filter_ctrl(struct dvb_frontend *fe, u8 onoff)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tu16 val = dib7000p_read_word(state, 235) & 0xffef;\n\tval |= (onoff & 0x1) << 4;\n\tdprintk(\"PID filter enabled %d\\n\", onoff);\n\treturn dib7000p_write_word(state, 235, val);\n}\n\nstatic int dib7000p_pid_filter(struct dvb_frontend *fe, u8 id, u16 pid, u8 onoff)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tdprintk(\"PID filter: index %x, PID %d, OnOff %d\\n\", id, pid, onoff);\n\treturn dib7000p_write_word(state, 241 + id, onoff ? (1 << 13) | pid : 0);\n}\n\nstatic int dib7000p_i2c_enumeration(struct i2c_adapter *i2c, int no_of_demods, u8 default_addr, struct dib7000p_config cfg[])\n{\n\tstruct dib7000p_state *dpst;\n\tint k = 0;\n\tu8 new_addr = 0;\n\n\tdpst = kzalloc(sizeof(struct dib7000p_state), GFP_KERNEL);\n\tif (!dpst)\n\t\treturn -ENOMEM;\n\n\tdpst->i2c_adap = i2c;\n\tmutex_init(&dpst->i2c_buffer_lock);\n\n\tfor (k = no_of_demods - 1; k >= 0; k--) {\n\t\tdpst->cfg = cfg[k];\n\n\t\t \n\t\tif (cfg[k].default_i2c_addr != 0)\n\t\t\tnew_addr = cfg[k].default_i2c_addr + (k << 1);\n\t\telse\n\t\t\tnew_addr = (0x40 + k) << 1;\n\t\tdpst->i2c_addr = new_addr;\n\t\tdib7000p_write_word(dpst, 1287, 0x0003);\t \n\t\tif (dib7000p_identify(dpst) != 0) {\n\t\t\tdpst->i2c_addr = default_addr;\n\t\t\tdib7000p_write_word(dpst, 1287, 0x0003);\t \n\t\t\tif (dib7000p_identify(dpst) != 0) {\n\t\t\t\tdprintk(\"DiB7000P #%d: not identified\\n\", k);\n\t\t\t\tkfree(dpst);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdib7000p_set_output_mode(dpst, OUTMODE_DIVERSITY);\n\n\t\t \n\t\tdib7000p_write_word(dpst, 1285, (new_addr << 2) | 0x2);\n\n\t\tdprintk(\"IC %d initialized (to i2c_address 0x%x)\\n\", k, new_addr);\n\t}\n\n\tfor (k = 0; k < no_of_demods; k++) {\n\t\tdpst->cfg = cfg[k];\n\t\tif (cfg[k].default_i2c_addr != 0)\n\t\t\tdpst->i2c_addr = (cfg[k].default_i2c_addr + k) << 1;\n\t\telse\n\t\t\tdpst->i2c_addr = (0x40 + k) << 1;\n\n\t\t\n\t\tdib7000p_write_word(dpst, 1285, dpst->i2c_addr << 2);\n\n\t\t \n\t\tdib7000p_set_output_mode(dpst, OUTMODE_HIGH_Z);\n\t}\n\n\tkfree(dpst);\n\treturn 0;\n}\n\nstatic const s32 lut_1000ln_mant[] = {\n\t6908, 6956, 7003, 7047, 7090, 7131, 7170, 7208, 7244, 7279, 7313, 7346, 7377, 7408, 7438, 7467, 7495, 7523, 7549, 7575, 7600\n};\n\nstatic s32 dib7000p_get_adc_power(struct dvb_frontend *fe)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tu32 tmp_val = 0, exp = 0, mant = 0;\n\ts32 pow_i;\n\tu16 buf[2];\n\tu8 ix = 0;\n\n\tbuf[0] = dib7000p_read_word(state, 0x184);\n\tbuf[1] = dib7000p_read_word(state, 0x185);\n\tpow_i = (buf[0] << 16) | buf[1];\n\tdprintk(\"raw pow_i = %d\\n\", pow_i);\n\n\ttmp_val = pow_i;\n\twhile (tmp_val >>= 1)\n\t\texp++;\n\n\tmant = (pow_i * 1000 / (1 << exp));\n\tdprintk(\" mant = %d exp = %d\\n\", mant / 1000, exp);\n\n\tix = (u8) ((mant - 1000) / 100);\t \n\tdprintk(\" ix = %d\\n\", ix);\n\n\tpow_i = (lut_1000ln_mant[ix] + 693 * (exp - 20) - 6908);\n\tpow_i = (pow_i << 8) / 1000;\n\tdprintk(\" pow_i = %d\\n\", pow_i);\n\n\treturn pow_i;\n}\n\nstatic int map_addr_to_serpar_number(struct i2c_msg *msg)\n{\n\tif ((msg->buf[0] <= 15))\n\t\tmsg->buf[0] -= 1;\n\telse if (msg->buf[0] == 17)\n\t\tmsg->buf[0] = 15;\n\telse if (msg->buf[0] == 16)\n\t\tmsg->buf[0] = 17;\n\telse if (msg->buf[0] == 19)\n\t\tmsg->buf[0] = 16;\n\telse if (msg->buf[0] >= 21 && msg->buf[0] <= 25)\n\t\tmsg->buf[0] -= 3;\n\telse if (msg->buf[0] == 28)\n\t\tmsg->buf[0] = 23;\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int w7090p_tuner_write_serpar(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\n{\n\tstruct dib7000p_state *state = i2c_get_adapdata(i2c_adap);\n\tu8 n_overflow = 1;\n\tu16 i = 1000;\n\tu16 serpar_num = msg[0].buf[0];\n\n\twhile (n_overflow == 1 && i) {\n\t\tn_overflow = (dib7000p_read_word(state, 1984) >> 1) & 0x1;\n\t\ti--;\n\t\tif (i == 0)\n\t\t\tdprintk(\"Tuner ITF: write busy (overflow)\\n\");\n\t}\n\tdib7000p_write_word(state, 1985, (1 << 6) | (serpar_num & 0x3f));\n\tdib7000p_write_word(state, 1986, (msg[0].buf[1] << 8) | msg[0].buf[2]);\n\n\treturn num;\n}\n\nstatic int w7090p_tuner_read_serpar(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\n{\n\tstruct dib7000p_state *state = i2c_get_adapdata(i2c_adap);\n\tu8 n_overflow = 1, n_empty = 1;\n\tu16 i = 1000;\n\tu16 serpar_num = msg[0].buf[0];\n\tu16 read_word;\n\n\twhile (n_overflow == 1 && i) {\n\t\tn_overflow = (dib7000p_read_word(state, 1984) >> 1) & 0x1;\n\t\ti--;\n\t\tif (i == 0)\n\t\t\tdprintk(\"TunerITF: read busy (overflow)\\n\");\n\t}\n\tdib7000p_write_word(state, 1985, (0 << 6) | (serpar_num & 0x3f));\n\n\ti = 1000;\n\twhile (n_empty == 1 && i) {\n\t\tn_empty = dib7000p_read_word(state, 1984) & 0x1;\n\t\ti--;\n\t\tif (i == 0)\n\t\t\tdprintk(\"TunerITF: read busy (empty)\\n\");\n\t}\n\tread_word = dib7000p_read_word(state, 1987);\n\tmsg[1].buf[0] = (read_word >> 8) & 0xff;\n\tmsg[1].buf[1] = (read_word) & 0xff;\n\n\treturn num;\n}\n\nstatic int w7090p_tuner_rw_serpar(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\n{\n\tif (map_addr_to_serpar_number(&msg[0]) == 0) {\t \n\t\tif (num == 1) {\t \n\t\t\treturn w7090p_tuner_write_serpar(i2c_adap, msg, 1);\n\t\t} else {\t \n\t\t\treturn w7090p_tuner_read_serpar(i2c_adap, msg, 2);\n\t\t}\n\t}\n\treturn num;\n}\n\nstatic int dib7090p_rw_on_apb(struct i2c_adapter *i2c_adap,\n\t\tstruct i2c_msg msg[], int num, u16 apb_address)\n{\n\tstruct dib7000p_state *state = i2c_get_adapdata(i2c_adap);\n\tu16 word;\n\n\tif (num == 1) {\t\t \n\t\tdib7000p_write_word(state, apb_address, ((msg[0].buf[1] << 8) | (msg[0].buf[2])));\n\t} else {\n\t\tword = dib7000p_read_word(state, apb_address);\n\t\tmsg[1].buf[0] = (word >> 8) & 0xff;\n\t\tmsg[1].buf[1] = (word) & 0xff;\n\t}\n\n\treturn num;\n}\n\nstatic int dib7090_tuner_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\n{\n\tstruct dib7000p_state *state = i2c_get_adapdata(i2c_adap);\n\n\tu16 apb_address = 0, word;\n\tint i = 0;\n\tswitch (msg[0].buf[0]) {\n\tcase 0x12:\n\t\tapb_address = 1920;\n\t\tbreak;\n\tcase 0x14:\n\t\tapb_address = 1921;\n\t\tbreak;\n\tcase 0x24:\n\t\tapb_address = 1922;\n\t\tbreak;\n\tcase 0x1a:\n\t\tapb_address = 1923;\n\t\tbreak;\n\tcase 0x22:\n\t\tapb_address = 1924;\n\t\tbreak;\n\tcase 0x33:\n\t\tapb_address = 1926;\n\t\tbreak;\n\tcase 0x34:\n\t\tapb_address = 1927;\n\t\tbreak;\n\tcase 0x35:\n\t\tapb_address = 1928;\n\t\tbreak;\n\tcase 0x36:\n\t\tapb_address = 1929;\n\t\tbreak;\n\tcase 0x37:\n\t\tapb_address = 1930;\n\t\tbreak;\n\tcase 0x38:\n\t\tapb_address = 1931;\n\t\tbreak;\n\tcase 0x39:\n\t\tapb_address = 1932;\n\t\tbreak;\n\tcase 0x2a:\n\t\tapb_address = 1935;\n\t\tbreak;\n\tcase 0x2b:\n\t\tapb_address = 1936;\n\t\tbreak;\n\tcase 0x2c:\n\t\tapb_address = 1937;\n\t\tbreak;\n\tcase 0x2d:\n\t\tapb_address = 1938;\n\t\tbreak;\n\tcase 0x2e:\n\t\tapb_address = 1939;\n\t\tbreak;\n\tcase 0x2f:\n\t\tapb_address = 1940;\n\t\tbreak;\n\tcase 0x30:\n\t\tapb_address = 1941;\n\t\tbreak;\n\tcase 0x31:\n\t\tapb_address = 1942;\n\t\tbreak;\n\tcase 0x32:\n\t\tapb_address = 1943;\n\t\tbreak;\n\tcase 0x3e:\n\t\tapb_address = 1944;\n\t\tbreak;\n\tcase 0x3f:\n\t\tapb_address = 1945;\n\t\tbreak;\n\tcase 0x40:\n\t\tapb_address = 1948;\n\t\tbreak;\n\tcase 0x25:\n\t\tapb_address = 914;\n\t\tbreak;\n\tcase 0x26:\n\t\tapb_address = 915;\n\t\tbreak;\n\tcase 0x27:\n\t\tapb_address = 917;\n\t\tbreak;\n\tcase 0x28:\n\t\tapb_address = 916;\n\t\tbreak;\n\tcase 0x1d:\n\t\ti = ((dib7000p_read_word(state, 72) >> 12) & 0x3);\n\t\tword = dib7000p_read_word(state, 384 + i);\n\t\tmsg[1].buf[0] = (word >> 8) & 0xff;\n\t\tmsg[1].buf[1] = (word) & 0xff;\n\t\treturn num;\n\tcase 0x1f:\n\t\tif (num == 1) {\t \n\t\t\tword = (u16) ((msg[0].buf[1] << 8) | msg[0].buf[2]);\n\t\t\tword &= 0x3;\n\t\t\tword = (dib7000p_read_word(state, 72) & ~(3 << 12)) | (word << 12);\n\t\t\tdib7000p_write_word(state, 72, word);\t \n\t\t\treturn num;\n\t\t}\n\t}\n\n\tif (apb_address != 0)\t \n\t\treturn dib7090p_rw_on_apb(i2c_adap, msg, num, apb_address);\n\telse\t\t\t \n\t\treturn w7090p_tuner_rw_serpar(i2c_adap, msg, num);\n\n\treturn 0;\n}\n\nstatic u32 dib7000p_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm dib7090_tuner_xfer_algo = {\n\t.master_xfer = dib7090_tuner_xfer,\n\t.functionality = dib7000p_i2c_func,\n};\n\nstatic struct i2c_adapter *dib7090_get_i2c_tuner(struct dvb_frontend *fe)\n{\n\tstruct dib7000p_state *st = fe->demodulator_priv;\n\treturn &st->dib7090_tuner_adap;\n}\n\nstatic int dib7090_host_bus_drive(struct dib7000p_state *state, u8 drive)\n{\n\tu16 reg;\n\n\t \n\treg = dib7000p_read_word(state, 1798) & ~((0x7) | (0x7 << 6) | (0x7 << 12));\n\treg |= (drive << 12) | (drive << 6) | drive;\n\tdib7000p_write_word(state, 1798, reg);\n\n\t \n\treg = dib7000p_read_word(state, 1799) & ~((0x7 << 2) | (0x7 << 8));\n\treg |= (drive << 8) | (drive << 2);\n\tdib7000p_write_word(state, 1799, reg);\n\n\t \n\treg = dib7000p_read_word(state, 1800) & ~((0x7) | (0x7 << 6) | (0x7 << 12));\n\treg |= (drive << 12) | (drive << 6) | drive;\n\tdib7000p_write_word(state, 1800, reg);\n\n\t \n\treg = dib7000p_read_word(state, 1801) & ~((0x7 << 2) | (0x7 << 8));\n\treg |= (drive << 8) | (drive << 2);\n\tdib7000p_write_word(state, 1801, reg);\n\n\t \n\treg = dib7000p_read_word(state, 1802) & ~((0x7) | (0x7 << 6) | (0x7 << 12));\n\treg |= (drive << 12) | (drive << 6) | drive;\n\tdib7000p_write_word(state, 1802, reg);\n\n\treturn 0;\n}\n\nstatic u32 dib7090_calcSyncFreq(u32 P_Kin, u32 P_Kout, u32 insertExtSynchro, u32 syncSize)\n{\n\tu32 quantif = 3;\n\tu32 nom = (insertExtSynchro * P_Kin + syncSize);\n\tu32 denom = P_Kout;\n\tu32 syncFreq = ((nom << quantif) / denom);\n\n\tif ((syncFreq & ((1 << quantif) - 1)) != 0)\n\t\tsyncFreq = (syncFreq >> quantif) + 1;\n\telse\n\t\tsyncFreq = (syncFreq >> quantif);\n\n\tif (syncFreq != 0)\n\t\tsyncFreq = syncFreq - 1;\n\n\treturn syncFreq;\n}\n\nstatic int dib7090_cfg_DibTx(struct dib7000p_state *state, u32 P_Kin, u32 P_Kout, u32 insertExtSynchro, u32 synchroMode, u32 syncWord, u32 syncSize)\n{\n\tdprintk(\"Configure DibStream Tx\\n\");\n\n\tdib7000p_write_word(state, 1615, 1);\n\tdib7000p_write_word(state, 1603, P_Kin);\n\tdib7000p_write_word(state, 1605, P_Kout);\n\tdib7000p_write_word(state, 1606, insertExtSynchro);\n\tdib7000p_write_word(state, 1608, synchroMode);\n\tdib7000p_write_word(state, 1609, (syncWord >> 16) & 0xffff);\n\tdib7000p_write_word(state, 1610, syncWord & 0xffff);\n\tdib7000p_write_word(state, 1612, syncSize);\n\tdib7000p_write_word(state, 1615, 0);\n\n\treturn 0;\n}\n\nstatic int dib7090_cfg_DibRx(struct dib7000p_state *state, u32 P_Kin, u32 P_Kout, u32 synchroMode, u32 insertExtSynchro, u32 syncWord, u32 syncSize,\n\t\tu32 dataOutRate)\n{\n\tu32 syncFreq;\n\n\tdprintk(\"Configure DibStream Rx\\n\");\n\tif ((P_Kin != 0) && (P_Kout != 0)) {\n\t\tsyncFreq = dib7090_calcSyncFreq(P_Kin, P_Kout, insertExtSynchro, syncSize);\n\t\tdib7000p_write_word(state, 1542, syncFreq);\n\t}\n\tdib7000p_write_word(state, 1554, 1);\n\tdib7000p_write_word(state, 1536, P_Kin);\n\tdib7000p_write_word(state, 1537, P_Kout);\n\tdib7000p_write_word(state, 1539, synchroMode);\n\tdib7000p_write_word(state, 1540, (syncWord >> 16) & 0xffff);\n\tdib7000p_write_word(state, 1541, syncWord & 0xffff);\n\tdib7000p_write_word(state, 1543, syncSize);\n\tdib7000p_write_word(state, 1544, dataOutRate);\n\tdib7000p_write_word(state, 1554, 0);\n\n\treturn 0;\n}\n\nstatic void dib7090_enMpegMux(struct dib7000p_state *state, int onoff)\n{\n\tu16 reg_1287 = dib7000p_read_word(state, 1287);\n\n\tswitch (onoff) {\n\tcase 1:\n\t\t\treg_1287 &= ~(1<<7);\n\t\t\tbreak;\n\tcase 0:\n\t\t\treg_1287 |= (1<<7);\n\t\t\tbreak;\n\t}\n\n\tdib7000p_write_word(state, 1287, reg_1287);\n}\n\nstatic void dib7090_configMpegMux(struct dib7000p_state *state,\n\t\tu16 pulseWidth, u16 enSerialMode, u16 enSerialClkDiv2)\n{\n\tdprintk(\"Enable Mpeg mux\\n\");\n\n\tdib7090_enMpegMux(state, 0);\n\n\t \n\tif ((enSerialMode == 1) && (state->input_mode_mpeg == 1))\n\t\tenSerialClkDiv2 = 0;\n\n\tdib7000p_write_word(state, 1287, ((pulseWidth & 0x1f) << 2)\n\t\t\t| ((enSerialMode & 0x1) << 1)\n\t\t\t| (enSerialClkDiv2 & 0x1));\n\n\tdib7090_enMpegMux(state, 1);\n}\n\nstatic void dib7090_setDibTxMux(struct dib7000p_state *state, int mode)\n{\n\tu16 reg_1288 = dib7000p_read_word(state, 1288) & ~(0x7 << 7);\n\n\tswitch (mode) {\n\tcase MPEG_ON_DIBTX:\n\t\t\tdprintk(\"SET MPEG ON DIBSTREAM TX\\n\");\n\t\t\tdib7090_cfg_DibTx(state, 8, 5, 0, 0, 0, 0);\n\t\t\treg_1288 |= (1<<9);\n\t\t\tbreak;\n\tcase DIV_ON_DIBTX:\n\t\t\tdprintk(\"SET DIV_OUT ON DIBSTREAM TX\\n\");\n\t\t\tdib7090_cfg_DibTx(state, 5, 5, 0, 0, 0, 0);\n\t\t\treg_1288 |= (1<<8);\n\t\t\tbreak;\n\tcase ADC_ON_DIBTX:\n\t\t\tdprintk(\"SET ADC_OUT ON DIBSTREAM TX\\n\");\n\t\t\tdib7090_cfg_DibTx(state, 20, 5, 10, 0, 0, 0);\n\t\t\treg_1288 |= (1<<7);\n\t\t\tbreak;\n\tdefault:\n\t\t\tbreak;\n\t}\n\tdib7000p_write_word(state, 1288, reg_1288);\n}\n\nstatic void dib7090_setHostBusMux(struct dib7000p_state *state, int mode)\n{\n\tu16 reg_1288 = dib7000p_read_word(state, 1288) & ~(0x7 << 4);\n\n\tswitch (mode) {\n\tcase DEMOUT_ON_HOSTBUS:\n\t\t\tdprintk(\"SET DEM OUT OLD INTERF ON HOST BUS\\n\");\n\t\t\tdib7090_enMpegMux(state, 0);\n\t\t\treg_1288 |= (1<<6);\n\t\t\tbreak;\n\tcase DIBTX_ON_HOSTBUS:\n\t\t\tdprintk(\"SET DIBSTREAM TX ON HOST BUS\\n\");\n\t\t\tdib7090_enMpegMux(state, 0);\n\t\t\treg_1288 |= (1<<5);\n\t\t\tbreak;\n\tcase MPEG_ON_HOSTBUS:\n\t\t\tdprintk(\"SET MPEG MUX ON HOST BUS\\n\");\n\t\t\treg_1288 |= (1<<4);\n\t\t\tbreak;\n\tdefault:\n\t\t\tbreak;\n\t}\n\tdib7000p_write_word(state, 1288, reg_1288);\n}\n\nstatic int dib7090_set_diversity_in(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tu16 reg_1287;\n\n\tswitch (onoff) {\n\tcase 0:  \n\t\t\tdprintk(\"%s mode OFF : by default Enable Mpeg INPUT\\n\", __func__);\n\t\t\tdib7090_cfg_DibRx(state, 8, 5, 0, 0, 0, 8, 0);\n\n\t\t\t \n\t\t\t \n\t\t\treg_1287 = dib7000p_read_word(state, 1287);\n\t\t\t \n\t\t\tif ((reg_1287 & 0x1) == 1) {\n\t\t\t\t \n\t\t\t\treg_1287 &= ~0x1;\n\t\t\t\tdib7000p_write_word(state, 1287, reg_1287);\n\t\t\t}\n\t\t\tstate->input_mode_mpeg = 1;\n\t\t\tbreak;\n\tcase 1:  \n\tcase 2:  \n\t\t\tdprintk(\"%s ON : Enable diversity INPUT\\n\", __func__);\n\t\t\tdib7090_cfg_DibRx(state, 5, 5, 0, 0, 0, 0, 0);\n\t\t\tstate->input_mode_mpeg = 0;\n\t\t\tbreak;\n\t}\n\n\tdib7000p_set_diversity_in(&state->demod, onoff);\n\treturn 0;\n}\n\nstatic int dib7090_set_output_mode(struct dvb_frontend *fe, int mode)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\n\tu16 outreg, smo_mode, fifo_threshold;\n\tu8 prefer_mpeg_mux_use = 1;\n\tint ret = 0;\n\n\tdib7090_host_bus_drive(state, 1);\n\n\tfifo_threshold = 1792;\n\tsmo_mode = (dib7000p_read_word(state, 235) & 0x0050) | (1 << 1);\n\toutreg = dib7000p_read_word(state, 1286) & ~((1 << 10) | (0x7 << 6) | (1 << 1));\n\n\tswitch (mode) {\n\tcase OUTMODE_HIGH_Z:\n\t\toutreg = 0;\n\t\tbreak;\n\n\tcase OUTMODE_MPEG2_SERIAL:\n\t\tif (prefer_mpeg_mux_use) {\n\t\t\tdprintk(\"setting output mode TS_SERIAL using Mpeg Mux\\n\");\n\t\t\tdib7090_configMpegMux(state, 3, 1, 1);\n\t\t\tdib7090_setHostBusMux(state, MPEG_ON_HOSTBUS);\n\t\t} else { \n\t\t\tdprintk(\"setting output mode TS_SERIAL using Smooth bloc\\n\");\n\t\t\tdib7090_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\n\t\t\toutreg |= (2<<6) | (0 << 1);\n\t\t}\n\t\tbreak;\n\n\tcase OUTMODE_MPEG2_PAR_GATED_CLK:\n\t\tif (prefer_mpeg_mux_use) {\n\t\t\tdprintk(\"setting output mode TS_PARALLEL_GATED using Mpeg Mux\\n\");\n\t\t\tdib7090_configMpegMux(state, 2, 0, 0);\n\t\t\tdib7090_setHostBusMux(state, MPEG_ON_HOSTBUS);\n\t\t} else {  \n\t\t\tdprintk(\"setting output mode TS_PARALLEL_GATED using Smooth block\\n\");\n\t\t\tdib7090_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\n\t\t\toutreg |= (0<<6);\n\t\t}\n\t\tbreak;\n\n\tcase OUTMODE_MPEG2_PAR_CONT_CLK:\t \n\t\tdprintk(\"setting output mode TS_PARALLEL_CONT using Smooth block\\n\");\n\t\tdib7090_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\n\t\toutreg |= (1<<6);\n\t\tbreak;\n\n\tcase OUTMODE_MPEG2_FIFO:\t \n\t\tdprintk(\"setting output mode TS_FIFO using Smooth block\\n\");\n\t\tdib7090_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\n\t\toutreg |= (5<<6);\n\t\tsmo_mode |= (3 << 1);\n\t\tfifo_threshold = 512;\n\t\tbreak;\n\n\tcase OUTMODE_DIVERSITY:\n\t\tdprintk(\"setting output mode MODE_DIVERSITY\\n\");\n\t\tdib7090_setDibTxMux(state, DIV_ON_DIBTX);\n\t\tdib7090_setHostBusMux(state, DIBTX_ON_HOSTBUS);\n\t\tbreak;\n\n\tcase OUTMODE_ANALOG_ADC:\n\t\tdprintk(\"setting output mode MODE_ANALOG_ADC\\n\");\n\t\tdib7090_setDibTxMux(state, ADC_ON_DIBTX);\n\t\tdib7090_setHostBusMux(state, DIBTX_ON_HOSTBUS);\n\t\tbreak;\n\t}\n\tif (mode != OUTMODE_HIGH_Z)\n\t\toutreg |= (1 << 10);\n\n\tif (state->cfg.output_mpeg2_in_188_bytes)\n\t\tsmo_mode |= (1 << 5);\n\n\tret |= dib7000p_write_word(state, 235, smo_mode);\n\tret |= dib7000p_write_word(state, 236, fifo_threshold);\t \n\tret |= dib7000p_write_word(state, 1286, outreg);\n\n\treturn ret;\n}\n\nstatic int dib7090_tuner_sleep(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tu16 en_cur_state;\n\n\tdprintk(\"sleep dib7090: %d\\n\", onoff);\n\n\ten_cur_state = dib7000p_read_word(state, 1922);\n\n\tif (en_cur_state > 0xff)\n\t\tstate->tuner_enable = en_cur_state;\n\n\tif (onoff)\n\t\ten_cur_state &= 0x00ff;\n\telse {\n\t\tif (state->tuner_enable != 0)\n\t\t\ten_cur_state = state->tuner_enable;\n\t}\n\n\tdib7000p_write_word(state, 1922, en_cur_state);\n\n\treturn 0;\n}\n\nstatic int dib7090_get_adc_power(struct dvb_frontend *fe)\n{\n\treturn dib7000p_get_adc_power(fe);\n}\n\nstatic int dib7090_slave_reset(struct dvb_frontend *fe)\n{\n\tstruct dib7000p_state *state = fe->demodulator_priv;\n\tu16 reg;\n\n\treg = dib7000p_read_word(state, 1794);\n\tdib7000p_write_word(state, 1794, reg | (4 << 12));\n\n\tdib7000p_write_word(state, 1032, 0xffff);\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops dib7000p_ops;\nstatic struct dvb_frontend *dib7000p_init(struct i2c_adapter *i2c_adap, u8 i2c_addr, struct dib7000p_config *cfg)\n{\n\tstruct dvb_frontend *demod;\n\tstruct dib7000p_state *st;\n\tst = kzalloc(sizeof(struct dib7000p_state), GFP_KERNEL);\n\tif (st == NULL)\n\t\treturn NULL;\n\n\tmemcpy(&st->cfg, cfg, sizeof(struct dib7000p_config));\n\tst->i2c_adap = i2c_adap;\n\tst->i2c_addr = i2c_addr;\n\tst->gpio_val = cfg->gpio_val;\n\tst->gpio_dir = cfg->gpio_dir;\n\n\t \n\tif ((st->cfg.output_mode != OUTMODE_MPEG2_SERIAL) && (st->cfg.output_mode != OUTMODE_MPEG2_PAR_GATED_CLK))\n\t\tst->cfg.output_mode = OUTMODE_MPEG2_FIFO;\n\n\tdemod = &st->demod;\n\tdemod->demodulator_priv = st;\n\tmemcpy(&st->demod.ops, &dib7000p_ops, sizeof(struct dvb_frontend_ops));\n\tmutex_init(&st->i2c_buffer_lock);\n\n\tdib7000p_write_word(st, 1287, 0x0003);\t \n\n\tif (dib7000p_identify(st) != 0)\n\t\tgoto error;\n\n\tst->version = dib7000p_read_word(st, 897);\n\n\t \n\tst->i2c_master.gated_tuner_i2c_adap.dev.parent = i2c_adap->dev.parent;\n\n\tdibx000_init_i2c_master(&st->i2c_master, DIB7000P, st->i2c_adap, st->i2c_addr);\n\n\t \n\tstrscpy(st->dib7090_tuner_adap.name, \"DiB7090 tuner interface\",\n\t\tsizeof(st->dib7090_tuner_adap.name));\n\tst->dib7090_tuner_adap.algo = &dib7090_tuner_xfer_algo;\n\tst->dib7090_tuner_adap.algo_data = NULL;\n\tst->dib7090_tuner_adap.dev.parent = st->i2c_adap->dev.parent;\n\ti2c_set_adapdata(&st->dib7090_tuner_adap, st);\n\ti2c_add_adapter(&st->dib7090_tuner_adap);\n\n\tdib7000p_demod_reset(st);\n\n\tdib7000p_reset_stats(demod);\n\n\tif (st->version == SOC7090) {\n\t\tdib7090_set_output_mode(demod, st->cfg.output_mode);\n\t\tdib7090_set_diversity_in(demod, 0);\n\t}\n\n\treturn demod;\n\nerror:\n\tkfree(st);\n\treturn NULL;\n}\n\nvoid *dib7000p_attach(struct dib7000p_ops *ops)\n{\n\tif (!ops)\n\t\treturn NULL;\n\n\tops->slave_reset = dib7090_slave_reset;\n\tops->get_adc_power = dib7090_get_adc_power;\n\tops->dib7000pc_detection = dib7000pc_detection;\n\tops->get_i2c_tuner = dib7090_get_i2c_tuner;\n\tops->tuner_sleep = dib7090_tuner_sleep;\n\tops->init = dib7000p_init;\n\tops->set_agc1_min = dib7000p_set_agc1_min;\n\tops->set_gpio = dib7000p_set_gpio;\n\tops->i2c_enumeration = dib7000p_i2c_enumeration;\n\tops->pid_filter = dib7000p_pid_filter;\n\tops->pid_filter_ctrl = dib7000p_pid_filter_ctrl;\n\tops->get_i2c_master = dib7000p_get_i2c_master;\n\tops->update_pll = dib7000p_update_pll;\n\tops->ctrl_timf = dib7000p_ctrl_timf;\n\tops->get_agc_values = dib7000p_get_agc_values;\n\tops->set_wbd_ref = dib7000p_set_wbd_ref;\n\n\treturn ops;\n}\nEXPORT_SYMBOL_GPL(dib7000p_attach);\n\nstatic const struct dvb_frontend_ops dib7000p_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t .name = \"DiBcom 7000PC\",\n\t\t .frequency_min_hz =  44250 * kHz,\n\t\t .frequency_max_hz = 867250 * kHz,\n\t\t .frequency_stepsize_hz = 62500,\n\t\t .caps = FE_CAN_INVERSION_AUTO |\n\t\t FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_RECOVER | FE_CAN_HIERARCHY_AUTO,\n\t\t },\n\n\t.release = dib7000p_release,\n\n\t.init = dib7000p_wakeup,\n\t.sleep = dib7000p_sleep,\n\n\t.set_frontend = dib7000p_set_frontend,\n\t.get_tune_settings = dib7000p_fe_get_tune_settings,\n\t.get_frontend = dib7000p_get_frontend,\n\n\t.read_status = dib7000p_read_status,\n\t.read_ber = dib7000p_read_ber,\n\t.read_signal_strength = dib7000p_read_signal_strength,\n\t.read_snr = dib7000p_read_snr,\n\t.read_ucblocks = dib7000p_read_unc_blocks,\n};\n\nMODULE_AUTHOR(\"Olivier Grenie <olivie.grenie@parrot.com>\");\nMODULE_AUTHOR(\"Patrick Boettcher <patrick.boettcher@posteo.de>\");\nMODULE_DESCRIPTION(\"Driver for the DiBcom 7000PC COFDM demodulator\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}