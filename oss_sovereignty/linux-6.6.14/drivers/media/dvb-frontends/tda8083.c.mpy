{
  "module_name": "tda8083.c",
  "hash_id": "68db47cf7185d86038cdb7e62590172b0633b44de160208816cbd6b70d748465",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/tda8083.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <media/dvb_frontend.h>\n#include \"tda8083.h\"\n\n\nstruct tda8083_state {\n\tstruct i2c_adapter* i2c;\n\t \n\tconst struct tda8083_config* config;\n\tstruct dvb_frontend frontend;\n};\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) printk(KERN_DEBUG \"tda8083: \" args); \\\n\t} while (0)\n\n\nstatic u8 tda8083_init_tab [] = {\n\t0x04, 0x00, 0x4a, 0x79, 0x04, 0x00, 0xff, 0xea,\n\t0x48, 0x42, 0x79, 0x60, 0x70, 0x52, 0x9a, 0x10,\n\t0x0e, 0x10, 0xf2, 0xa7, 0x93, 0x0b, 0x05, 0xc8,\n\t0x9d, 0x00, 0x42, 0x80, 0x00, 0x60, 0x40, 0x00,\n\t0x00, 0x75, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00\n};\n\n\nstatic int tda8083_writereg (struct tda8083_state* state, u8 reg, u8 data)\n{\n\tint ret;\n\tu8 buf [] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tdprintk (\"%s: writereg error (reg %02x, ret == %i)\\n\",\n\t\t\t__func__, reg, ret);\n\n\treturn (ret != 1) ? -1 : 0;\n}\n\nstatic int tda8083_readregs (struct tda8083_state* state, u8 reg1, u8 *b, u8 len)\n{\n\tint ret;\n\tstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = &reg1, .len = 1 },\n\t\t\t   { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b, .len = len } };\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tdprintk (\"%s: readreg error (reg %02x, ret == %i)\\n\",\n\t\t\t__func__, reg1, ret);\n\n\treturn ret == 2 ? 0 : -1;\n}\n\nstatic inline u8 tda8083_readreg (struct tda8083_state* state, u8 reg)\n{\n\tu8 val;\n\n\ttda8083_readregs (state, reg, &val, 1);\n\n\treturn val;\n}\n\nstatic int tda8083_set_inversion(struct tda8083_state *state,\n\t\t\t\t enum fe_spectral_inversion inversion)\n{\n\t \n\tif (inversion == INVERSION_AUTO)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int tda8083_set_fec(struct tda8083_state *state, enum fe_code_rate fec)\n{\n\tif (fec == FEC_AUTO)\n\t\treturn tda8083_writereg (state, 0x07, 0xff);\n\n\tif (fec >= FEC_1_2 && fec <= FEC_8_9)\n\t\treturn tda8083_writereg (state, 0x07, 1 << (FEC_8_9 - fec));\n\n\treturn -EINVAL;\n}\n\nstatic enum fe_code_rate tda8083_get_fec(struct tda8083_state *state)\n{\n\tu8 index;\n\tstatic enum fe_code_rate fec_tab[] = {\n\t\tFEC_8_9, FEC_1_2, FEC_2_3, FEC_3_4,\n\t\tFEC_4_5, FEC_5_6, FEC_6_7, FEC_7_8\n\t};\n\n\tindex = tda8083_readreg(state, 0x0e) & 0x07;\n\n\treturn fec_tab [index];\n}\n\nstatic int tda8083_set_symbolrate (struct tda8083_state* state, u32 srate)\n{\n\tu32 ratio;\n\tu32 tmp;\n\tu8 filter;\n\n\tif (srate > 32000000)\n\t\tsrate = 32000000;\n\tif (srate < 500000)\n\t\tsrate = 500000;\n\n\tfilter = 0;\n\tif (srate < 24000000)\n\t\tfilter = 2;\n\tif (srate < 16000000)\n\t\tfilter = 3;\n\n\ttmp = 31250 << 16;\n\tratio = tmp / srate;\n\n\ttmp = (tmp % srate) << 8;\n\tratio = (ratio << 8) + tmp / srate;\n\n\ttmp = (tmp % srate) << 8;\n\tratio = (ratio << 8) + tmp / srate;\n\n\tdprintk(\"tda8083: ratio == %08x\\n\", (unsigned int) ratio);\n\n\ttda8083_writereg (state, 0x05, filter);\n\ttda8083_writereg (state, 0x02, (ratio >> 16) & 0xff);\n\ttda8083_writereg (state, 0x03, (ratio >>  8) & 0xff);\n\ttda8083_writereg (state, 0x04, (ratio      ) & 0xff);\n\n\ttda8083_writereg (state, 0x00, 0x3c);\n\ttda8083_writereg (state, 0x00, 0x04);\n\n\treturn 1;\n}\n\nstatic void tda8083_wait_diseqc_fifo (struct tda8083_state* state, int timeout)\n{\n\tunsigned long start = jiffies;\n\n\twhile (time_is_after_jiffies(start + timeout) &&\n\t       !(tda8083_readreg(state, 0x02) & 0x80))\n\t{\n\t\tmsleep(50);\n\t}\n}\n\nstatic int tda8083_set_tone(struct tda8083_state *state,\n\t\t\t    enum fe_sec_tone_mode tone)\n{\n\ttda8083_writereg (state, 0x26, 0xf1);\n\n\tswitch (tone) {\n\tcase SEC_TONE_OFF:\n\t\treturn tda8083_writereg (state, 0x29, 0x00);\n\tcase SEC_TONE_ON:\n\t\treturn tda8083_writereg (state, 0x29, 0x80);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tda8083_set_voltage(struct tda8083_state *state,\n\t\t\t       enum fe_sec_voltage voltage)\n{\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_13:\n\t\treturn tda8083_writereg (state, 0x20, 0x00);\n\tcase SEC_VOLTAGE_18:\n\t\treturn tda8083_writereg (state, 0x20, 0x11);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tda8083_send_diseqc_burst(struct tda8083_state *state,\n\t\t\t\t     enum fe_sec_mini_cmd burst)\n{\n\tswitch (burst) {\n\tcase SEC_MINI_A:\n\t\ttda8083_writereg (state, 0x29, (5 << 2));   \n\t\tbreak;\n\tcase SEC_MINI_B:\n\t\ttda8083_writereg (state, 0x29, (7 << 2));   \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttda8083_wait_diseqc_fifo (state, 100);\n\n\treturn 0;\n}\n\nstatic int tda8083_send_diseqc_msg(struct dvb_frontend *fe,\n\t\t\t\t   struct dvb_diseqc_master_cmd *m)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\tint i;\n\n\ttda8083_writereg (state, 0x29, (m->msg_len - 3) | (1 << 2));  \n\n\tfor (i=0; i<m->msg_len; i++)\n\t\ttda8083_writereg (state, 0x23 + i, m->msg[i]);\n\n\ttda8083_writereg (state, 0x29, (m->msg_len - 3) | (3 << 2));  \n\n\ttda8083_wait_diseqc_fifo (state, 100);\n\n\treturn 0;\n}\n\nstatic int tda8083_read_status(struct dvb_frontend *fe,\n\t\t\t       enum fe_status *status)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\n\tu8 signal = ~tda8083_readreg (state, 0x01);\n\tu8 sync = tda8083_readreg (state, 0x02);\n\n\t*status = 0;\n\n\tif (signal > 10)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (sync & 0x01)\n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (sync & 0x02)\n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (sync & 0x10)\n\t\t*status |= FE_HAS_SYNC;\n\n\tif (sync & 0x20)  \n\t\t*status |= FE_TIMEDOUT;\n\n\tif ((sync & 0x1f) == 0x1f)\n\t\t*status |= FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int tda8083_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\tint ret;\n\tu8 buf[3];\n\n\tif ((ret = tda8083_readregs(state, 0x0b, buf, sizeof(buf))))\n\t\treturn ret;\n\n\t*ber = ((buf[0] & 0x1f) << 16) | (buf[1] << 8) | buf[2];\n\n\treturn 0;\n}\n\nstatic int tda8083_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\n\tu8 signal = ~tda8083_readreg (state, 0x01);\n\t*strength = (signal << 8) | signal;\n\n\treturn 0;\n}\n\nstatic int tda8083_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\n\tu8 _snr = tda8083_readreg (state, 0x08);\n\t*snr = (_snr << 8) | _snr;\n\n\treturn 0;\n}\n\nstatic int tda8083_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\n\t*ucblocks = tda8083_readreg(state, 0x0f);\n\tif (*ucblocks == 0xff)\n\t\t*ucblocks = 0xffffffff;\n\n\treturn 0;\n}\n\nstatic int tda8083_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\ttda8083_set_inversion (state, p->inversion);\n\ttda8083_set_fec(state, p->fec_inner);\n\ttda8083_set_symbolrate(state, p->symbol_rate);\n\n\ttda8083_writereg (state, 0x00, 0x3c);\n\ttda8083_writereg (state, 0x00, 0x04);\n\n\treturn 0;\n}\n\nstatic int tda8083_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\n\t \n\t \n\tp->inversion = (tda8083_readreg (state, 0x0e) & 0x80) ?\n\t\t\tINVERSION_ON : INVERSION_OFF;\n\tp->fec_inner = tda8083_get_fec(state);\n\t \n\n\treturn 0;\n}\n\nstatic int tda8083_sleep(struct dvb_frontend* fe)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\n\ttda8083_writereg (state, 0x00, 0x02);\n\treturn 0;\n}\n\nstatic int tda8083_init(struct dvb_frontend* fe)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\tint i;\n\n\tfor (i=0; i<44; i++)\n\t\ttda8083_writereg (state, i, tda8083_init_tab[i]);\n\n\ttda8083_writereg (state, 0x00, 0x3c);\n\ttda8083_writereg (state, 0x00, 0x04);\n\n\treturn 0;\n}\n\nstatic int tda8083_diseqc_send_burst(struct dvb_frontend *fe,\n\t\t\t\t     enum fe_sec_mini_cmd burst)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\n\ttda8083_send_diseqc_burst (state, burst);\n\ttda8083_writereg (state, 0x00, 0x3c);\n\ttda8083_writereg (state, 0x00, 0x04);\n\n\treturn 0;\n}\n\nstatic int tda8083_diseqc_set_tone(struct dvb_frontend *fe,\n\t\t\t\t   enum fe_sec_tone_mode tone)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\n\ttda8083_set_tone (state, tone);\n\ttda8083_writereg (state, 0x00, 0x3c);\n\ttda8083_writereg (state, 0x00, 0x04);\n\n\treturn 0;\n}\n\nstatic int tda8083_diseqc_set_voltage(struct dvb_frontend *fe,\n\t\t\t\t      enum fe_sec_voltage voltage)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\n\ttda8083_set_voltage (state, voltage);\n\ttda8083_writereg (state, 0x00, 0x3c);\n\ttda8083_writereg (state, 0x00, 0x04);\n\n\treturn 0;\n}\n\nstatic void tda8083_release(struct dvb_frontend* fe)\n{\n\tstruct tda8083_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops tda8083_ops;\n\nstruct dvb_frontend* tda8083_attach(const struct tda8083_config* config,\n\t\t\t\t    struct i2c_adapter* i2c)\n{\n\tstruct tda8083_state* state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct tda8083_state), GFP_KERNEL);\n\tif (state == NULL) goto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\t \n\tif ((tda8083_readreg(state, 0x00)) != 0x05) goto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &tda8083_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops tda8083_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name\t\t\t= \"Philips TDA8083 DVB-S\",\n\t\t.frequency_min_hz\t=  920 * MHz,      \n\t\t.frequency_max_hz\t= 2200 * MHz,     \n\t\t.frequency_stepsize_hz\t=  125 * kHz,\n\t\t.symbol_rate_min\t= 12000000,\n\t\t.symbol_rate_max\t= 30000000,\n\t \n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |\n\t\t\tFE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_MUTE_TS\n\t},\n\n\t.release = tda8083_release,\n\n\t.init = tda8083_init,\n\t.sleep = tda8083_sleep,\n\n\t.set_frontend = tda8083_set_frontend,\n\t.get_frontend = tda8083_get_frontend,\n\n\t.read_status = tda8083_read_status,\n\t.read_signal_strength = tda8083_read_signal_strength,\n\t.read_snr = tda8083_read_snr,\n\t.read_ber = tda8083_read_ber,\n\t.read_ucblocks = tda8083_read_ucblocks,\n\n\t.diseqc_send_master_cmd = tda8083_send_diseqc_msg,\n\t.diseqc_send_burst = tda8083_diseqc_send_burst,\n\t.set_tone = tda8083_diseqc_set_tone,\n\t.set_voltage = tda8083_diseqc_set_voltage,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"Philips TDA8083 DVB-S Demodulator\");\nMODULE_AUTHOR(\"Ralph Metzler, Holger Waechtler\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(tda8083_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}