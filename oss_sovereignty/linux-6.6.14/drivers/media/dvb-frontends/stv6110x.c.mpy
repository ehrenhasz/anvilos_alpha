{
  "module_name": "stv6110x.c",
  "hash_id": "92a085ef4963504284c1292a6bfa281ba66b287b0d1e5d15ec7a2139c63d1d08",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stv6110x.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <media/dvb_frontend.h>\n\n#include \"stv6110x_reg.h\"\n#include \"stv6110x.h\"\n#include \"stv6110x_priv.h\"\n\n \n#define MAX_XFER_SIZE  64\n\nstatic unsigned int verbose;\nmodule_param(verbose, int, 0644);\nMODULE_PARM_DESC(verbose, \"Set Verbosity level\");\n\nstatic int stv6110x_read_reg(struct stv6110x_state *stv6110x, u8 reg, u8 *data)\n{\n\tint ret;\n\tconst struct stv6110x_config *config = stv6110x->config;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = config->addr, .flags = 0,\t   .buf = b0, .len = 1 },\n\t\t{ .addr = config->addr, .flags = I2C_M_RD, .buf = b1, .len = 1 }\n\t};\n\n\tret = i2c_transfer(stv6110x->i2c, msg, 2);\n\tif (ret != 2) {\n\t\tdprintk(FE_ERROR, 1, \"I/O Error\");\n\t\treturn -EREMOTEIO;\n\t}\n\t*data = b1[0];\n\n\treturn 0;\n}\n\nstatic int stv6110x_write_regs(struct stv6110x_state *stv6110x, int start, u8 data[], int len)\n{\n\tint ret;\n\tconst struct stv6110x_config *config = stv6110x->config;\n\tu8 buf[MAX_XFER_SIZE];\n\n\tstruct i2c_msg msg = {\n\t\t.addr = config->addr,\n\t\t.flags = 0,\n\t\t.buf = buf,\n\t\t.len = len + 1\n\t};\n\n\tif (1 + len > sizeof(buf)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: i2c wr: len=%d is too big!\\n\",\n\t\t       KBUILD_MODNAME, len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (start + len > 8)\n\t\treturn -EINVAL;\n\n\tbuf[0] = start;\n\tmemcpy(&buf[1], data, len);\n\n\tret = i2c_transfer(stv6110x->i2c, &msg, 1);\n\tif (ret != 1) {\n\t\tdprintk(FE_ERROR, 1, \"I/O Error\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int stv6110x_write_reg(struct stv6110x_state *stv6110x, u8 reg, u8 data)\n{\n\tu8 tmp = data;  \n\n\treturn stv6110x_write_regs(stv6110x, reg, &tmp, 1);\n}\n\nstatic int stv6110x_init(struct dvb_frontend *fe)\n{\n\tstruct stv6110x_state *stv6110x = fe->tuner_priv;\n\tint ret;\n\n\tret = stv6110x_write_regs(stv6110x, 0, stv6110x->regs,\n\t\t\t\t  ARRAY_SIZE(stv6110x->regs));\n\tif (ret < 0) {\n\t\tdprintk(FE_ERROR, 1, \"Initialization failed\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int stv6110x_set_frequency(struct dvb_frontend *fe, u32 frequency)\n{\n\tstruct stv6110x_state *stv6110x = fe->tuner_priv;\n\tu32 rDiv, divider;\n\ts32 pVal, pCalc, rDivOpt = 0, pCalcOpt = 1000;\n\tu8 i;\n\n\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL1], CTRL1_K, (REFCLOCK_MHz - 16));\n\n\tif (frequency <= 1023000) {\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_TNG1], TNG1_DIV4SEL, 1);\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_TNG1], TNG1_PRESC32_ON, 0);\n\t\tpVal = 40;\n\t} else if (frequency <= 1300000) {\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_TNG1], TNG1_DIV4SEL, 1);\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_TNG1], TNG1_PRESC32_ON, 1);\n\t\tpVal = 40;\n\t} else if (frequency <= 2046000) {\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_TNG1], TNG1_DIV4SEL, 0);\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_TNG1], TNG1_PRESC32_ON, 0);\n\t\tpVal = 20;\n\t} else {\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_TNG1], TNG1_DIV4SEL, 0);\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_TNG1], TNG1_PRESC32_ON, 1);\n\t\tpVal = 20;\n\t}\n\n\tfor (rDiv = 0; rDiv <= 3; rDiv++) {\n\t\tpCalc = (REFCLOCK_kHz / 100) / R_DIV(rDiv);\n\n\t\tif ((abs((s32)(pCalc - pVal))) < (abs((s32)(pCalcOpt - pVal))))\n\t\t\trDivOpt = rDiv;\n\n\t\tpCalcOpt = (REFCLOCK_kHz / 100) / R_DIV(rDivOpt);\n\t}\n\n\tdivider = (frequency * R_DIV(rDivOpt) * pVal) / REFCLOCK_kHz;\n\tdivider = (divider + 5) / 10;\n\n\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_TNG1], TNG1_R_DIV, rDivOpt);\n\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_TNG1], TNG1_N_DIV_11_8, MSB(divider));\n\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_TNG0], TNG0_N_DIV_7_0, LSB(divider));\n\n\t \n\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_STAT1], STAT1_CALVCO_STRT, 1);\n\n\tstv6110x_write_reg(stv6110x, STV6110x_CTRL1, stv6110x->regs[STV6110x_CTRL1]);\n\tstv6110x_write_reg(stv6110x, STV6110x_TNG1, stv6110x->regs[STV6110x_TNG1]);\n\tstv6110x_write_reg(stv6110x, STV6110x_TNG0, stv6110x->regs[STV6110x_TNG0]);\n\tstv6110x_write_reg(stv6110x, STV6110x_STAT1, stv6110x->regs[STV6110x_STAT1]);\n\n\tfor (i = 0; i < TRIALS; i++) {\n\t\tstv6110x_read_reg(stv6110x, STV6110x_STAT1, &stv6110x->regs[STV6110x_STAT1]);\n\t\tif (!STV6110x_GETFIELD(STAT1_CALVCO_STRT, stv6110x->regs[STV6110x_STAT1]))\n\t\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\treturn 0;\n}\n\nstatic int stv6110x_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct stv6110x_state *stv6110x = fe->tuner_priv;\n\n\tstv6110x_read_reg(stv6110x, STV6110x_TNG1, &stv6110x->regs[STV6110x_TNG1]);\n\tstv6110x_read_reg(stv6110x, STV6110x_TNG0, &stv6110x->regs[STV6110x_TNG0]);\n\n\t*frequency = (MAKEWORD16(STV6110x_GETFIELD(TNG1_N_DIV_11_8, stv6110x->regs[STV6110x_TNG1]),\n\t\t\t\t STV6110x_GETFIELD(TNG0_N_DIV_7_0, stv6110x->regs[STV6110x_TNG0]))) * REFCLOCK_kHz;\n\n\t*frequency /= (1 << (STV6110x_GETFIELD(TNG1_R_DIV, stv6110x->regs[STV6110x_TNG1]) +\n\t\t\t     STV6110x_GETFIELD(TNG1_DIV4SEL, stv6110x->regs[STV6110x_TNG1])));\n\n\t*frequency >>= 2;\n\n\treturn 0;\n}\n\nstatic int stv6110x_set_bandwidth(struct dvb_frontend *fe, u32 bandwidth)\n{\n\tstruct stv6110x_state *stv6110x = fe->tuner_priv;\n\tu32 halfbw;\n\tu8 i;\n\n\thalfbw = bandwidth >> 1;\n\n\tif (halfbw > 36000000)\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL3], CTRL3_CF, 31);  \n\telse if (halfbw < 5000000)\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL3], CTRL3_CF, 0);  \n\telse\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL3], CTRL3_CF, ((halfbw / 1000000) - 5));  \n\n\n\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL3], CTRL3_RCCLK_OFF, 0x0);  \n\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_STAT1], STAT1_CALRC_STRT, 0x1);  \n\n\tstv6110x_write_reg(stv6110x, STV6110x_CTRL3, stv6110x->regs[STV6110x_CTRL3]);\n\tstv6110x_write_reg(stv6110x, STV6110x_STAT1, stv6110x->regs[STV6110x_STAT1]);\n\n\tfor (i = 0; i < TRIALS; i++) {\n\t\tstv6110x_read_reg(stv6110x, STV6110x_STAT1, &stv6110x->regs[STV6110x_STAT1]);\n\t\tif (!STV6110x_GETFIELD(STAT1_CALRC_STRT, stv6110x->regs[STV6110x_STAT1]))\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL3], CTRL3_RCCLK_OFF, 0x1);  \n\tstv6110x_write_reg(stv6110x, STV6110x_CTRL3, stv6110x->regs[STV6110x_CTRL3]);\n\n\treturn 0;\n}\n\nstatic int stv6110x_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct stv6110x_state *stv6110x = fe->tuner_priv;\n\n\tstv6110x_read_reg(stv6110x, STV6110x_CTRL3, &stv6110x->regs[STV6110x_CTRL3]);\n\t*bandwidth = (STV6110x_GETFIELD(CTRL3_CF, stv6110x->regs[STV6110x_CTRL3]) + 5) * 2000000;\n\n\treturn 0;\n}\n\nstatic int stv6110x_set_refclock(struct dvb_frontend *fe, u32 refclock)\n{\n\tstruct stv6110x_state *stv6110x = fe->tuner_priv;\n\n\t \n\tswitch (refclock) {\n\tdefault:\n\tcase 1:\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL2], CTRL2_CO_DIV, 0);\n\t\tbreak;\n\tcase 2:\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL2], CTRL2_CO_DIV, 1);\n\t\tbreak;\n\tcase 4:\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL2], CTRL2_CO_DIV, 2);\n\t\tbreak;\n\tcase 8:\n\tcase 0:\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL2], CTRL2_CO_DIV, 3);\n\t\tbreak;\n\t}\n\tstv6110x_write_reg(stv6110x, STV6110x_CTRL2, stv6110x->regs[STV6110x_CTRL2]);\n\n\treturn 0;\n}\n\nstatic int stv6110x_get_bbgain(struct dvb_frontend *fe, u32 *gain)\n{\n\tstruct stv6110x_state *stv6110x = fe->tuner_priv;\n\n\tstv6110x_read_reg(stv6110x, STV6110x_CTRL2, &stv6110x->regs[STV6110x_CTRL2]);\n\t*gain = 2 * STV6110x_GETFIELD(CTRL2_BBGAIN, stv6110x->regs[STV6110x_CTRL2]);\n\n\treturn 0;\n}\n\nstatic int stv6110x_set_bbgain(struct dvb_frontend *fe, u32 gain)\n{\n\tstruct stv6110x_state *stv6110x = fe->tuner_priv;\n\n\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL2], CTRL2_BBGAIN, gain / 2);\n\tstv6110x_write_reg(stv6110x, STV6110x_CTRL2, stv6110x->regs[STV6110x_CTRL2]);\n\n\treturn 0;\n}\n\nstatic int stv6110x_set_mode(struct dvb_frontend *fe, enum tuner_mode mode)\n{\n\tstruct stv6110x_state *stv6110x = fe->tuner_priv;\n\tint ret;\n\n\tswitch (mode) {\n\tcase TUNER_SLEEP:\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL1], CTRL1_SYN, 0);\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL1], CTRL1_RX, 0);\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL1], CTRL1_LPT, 0);\n\t\tbreak;\n\n\tcase TUNER_WAKE:\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL1], CTRL1_SYN, 1);\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL1], CTRL1_RX, 1);\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL1], CTRL1_LPT, 1);\n\t\tbreak;\n\t}\n\n\tret = stv6110x_write_reg(stv6110x, STV6110x_CTRL1, stv6110x->regs[STV6110x_CTRL1]);\n\tif (ret < 0) {\n\t\tdprintk(FE_ERROR, 1, \"I/O Error\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int stv6110x_sleep(struct dvb_frontend *fe)\n{\n\tif (fe->tuner_priv)\n\t\treturn stv6110x_set_mode(fe, TUNER_SLEEP);\n\n\treturn 0;\n}\n\nstatic int stv6110x_get_status(struct dvb_frontend *fe, u32 *status)\n{\n\tstruct stv6110x_state *stv6110x = fe->tuner_priv;\n\n\tstv6110x_read_reg(stv6110x, STV6110x_STAT1, &stv6110x->regs[STV6110x_STAT1]);\n\n\tif (STV6110x_GETFIELD(STAT1_LOCK, stv6110x->regs[STV6110x_STAT1]))\n\t\t*status = TUNER_PHASELOCKED;\n\telse\n\t\t*status = 0;\n\n\treturn 0;\n}\n\n\nstatic void stv6110x_release(struct dvb_frontend *fe)\n{\n\tstruct stv6110x_state *stv6110x = fe->tuner_priv;\n\n\tfe->tuner_priv = NULL;\n\tkfree(stv6110x);\n}\n\nstatic void st6110x_init_regs(struct stv6110x_state *stv6110x)\n{\n\tu8 default_regs[] = {0x07, 0x11, 0xdc, 0x85, 0x17, 0x01, 0xe6, 0x1e};\n\n\tmemcpy(stv6110x->regs, default_regs, 8);\n}\n\nstatic void stv6110x_setup_divider(struct stv6110x_state *stv6110x)\n{\n\tswitch (stv6110x->config->clk_div) {\n\tdefault:\n\tcase 1:\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL2],\n\t\t\t\t  CTRL2_CO_DIV,\n\t\t\t\t  0);\n\t\tbreak;\n\tcase 2:\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL2],\n\t\t\t\t  CTRL2_CO_DIV,\n\t\t\t\t  1);\n\t\tbreak;\n\tcase 4:\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL2],\n\t\t\t\t  CTRL2_CO_DIV,\n\t\t\t\t  2);\n\t\tbreak;\n\tcase 8:\n\tcase 0:\n\t\tSTV6110x_SETFIELD(stv6110x->regs[STV6110x_CTRL2],\n\t\t\t\t  CTRL2_CO_DIV,\n\t\t\t\t  3);\n\t\tbreak;\n\t}\n}\n\nstatic const struct dvb_tuner_ops stv6110x_ops = {\n\t.info = {\n\t\t.name\t\t  = \"STV6110(A) Silicon Tuner\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2150 * MHz,\n\t},\n\t.release\t\t= stv6110x_release\n};\n\nstatic struct stv6110x_devctl stv6110x_ctl = {\n\t.tuner_init\t\t= stv6110x_init,\n\t.tuner_sleep\t\t= stv6110x_sleep,\n\t.tuner_set_mode\t\t= stv6110x_set_mode,\n\t.tuner_set_frequency\t= stv6110x_set_frequency,\n\t.tuner_get_frequency\t= stv6110x_get_frequency,\n\t.tuner_set_bandwidth\t= stv6110x_set_bandwidth,\n\t.tuner_get_bandwidth\t= stv6110x_get_bandwidth,\n\t.tuner_set_bbgain\t= stv6110x_set_bbgain,\n\t.tuner_get_bbgain\t= stv6110x_get_bbgain,\n\t.tuner_set_refclk\t= stv6110x_set_refclock,\n\t.tuner_get_status\t= stv6110x_get_status,\n};\n\nstatic void stv6110x_set_frontend_opts(struct stv6110x_state *stv6110x)\n{\n\tstv6110x->frontend->tuner_priv\t\t= stv6110x;\n\tstv6110x->frontend->ops.tuner_ops\t= stv6110x_ops;\n}\n\nstatic struct stv6110x_devctl *stv6110x_get_devctl(struct i2c_client *client)\n{\n\tstruct stv6110x_state *stv6110x = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\treturn stv6110x->devctl;\n}\n\nstatic int stv6110x_probe(struct i2c_client *client)\n{\n\tstruct stv6110x_config *config = client->dev.platform_data;\n\n\tstruct stv6110x_state *stv6110x;\n\n\tstv6110x = kzalloc(sizeof(*stv6110x), GFP_KERNEL);\n\tif (!stv6110x)\n\t\treturn -ENOMEM;\n\n\tstv6110x->frontend\t= config->frontend;\n\tstv6110x->i2c\t\t= client->adapter;\n\tstv6110x->config\t= config;\n\tstv6110x->devctl\t= &stv6110x_ctl;\n\n\tst6110x_init_regs(stv6110x);\n\tstv6110x_setup_divider(stv6110x);\n\tstv6110x_set_frontend_opts(stv6110x);\n\n\tdev_info(&stv6110x->i2c->dev, \"Probed STV6110x\\n\");\n\n\ti2c_set_clientdata(client, stv6110x);\n\n\t \n\tconfig->get_devctl = stv6110x_get_devctl;\n\n\treturn 0;\n}\n\nstatic void stv6110x_remove(struct i2c_client *client)\n{\n\tstruct stv6110x_state *stv6110x = i2c_get_clientdata(client);\n\n\tstv6110x_release(stv6110x->frontend);\n}\n\nconst struct stv6110x_devctl *stv6110x_attach(struct dvb_frontend *fe,\n\t\t\t\t\tconst struct stv6110x_config *config,\n\t\t\t\t\tstruct i2c_adapter *i2c)\n{\n\tstruct stv6110x_state *stv6110x;\n\n\tstv6110x = kzalloc(sizeof(*stv6110x), GFP_KERNEL);\n\tif (!stv6110x)\n\t\treturn NULL;\n\n\tstv6110x->frontend\t= fe;\n\tstv6110x->i2c\t\t= i2c;\n\tstv6110x->config\t= config;\n\tstv6110x->devctl\t= &stv6110x_ctl;\n\n\tst6110x_init_regs(stv6110x);\n\tstv6110x_setup_divider(stv6110x);\n\tstv6110x_set_frontend_opts(stv6110x);\n\n\tfe->tuner_priv\t\t= stv6110x;\n\tfe->ops.tuner_ops\t= stv6110x_ops;\n\n\tdev_info(&stv6110x->i2c->dev, \"Attaching STV6110x\\n\");\n\treturn stv6110x->devctl;\n}\nEXPORT_SYMBOL_GPL(stv6110x_attach);\n\nstatic const struct i2c_device_id stv6110x_id_table[] = {\n\t{\"stv6110x\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, stv6110x_id_table);\n\nstatic struct i2c_driver stv6110x_driver = {\n\t.driver = {\n\t\t.name\t= \"stv6110x\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t\t= stv6110x_probe,\n\t.remove\t\t= stv6110x_remove,\n\t.id_table\t= stv6110x_id_table,\n};\n\nmodule_i2c_driver(stv6110x_driver);\n\nMODULE_AUTHOR(\"Manu Abraham\");\nMODULE_DESCRIPTION(\"STV6110x Silicon tuner\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}