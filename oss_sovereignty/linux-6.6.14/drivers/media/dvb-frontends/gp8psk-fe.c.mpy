{
  "module_name": "gp8psk-fe.c",
  "hash_id": "bb6cdfc3201eb5148ac1c76edfdd2343f52b669207d3cd363439df8c8d1af120",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/gp8psk-fe.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"gp8psk-fe.h\"\n#include <media/dvb_frontend.h>\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off debugging (default:off).\");\n\n#define dprintk(fmt, arg...) do {\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt),\t\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\nstruct gp8psk_fe_state {\n\tstruct dvb_frontend fe;\n\tvoid *priv;\n\tconst struct gp8psk_fe_ops *ops;\n\tbool is_rev1;\n\tu8 lock;\n\tu16 snr;\n\tunsigned long next_status_check;\n\tunsigned long status_check_interval;\n};\n\nstatic int gp8psk_tuned_to_DCII(struct dvb_frontend *fe)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\tu8 status;\n\n\tst->ops->in(st->priv, GET_8PSK_CONFIG, 0, 0, &status, 1);\n\treturn status & bmDCtuned;\n}\n\nstatic int gp8psk_set_tuner_mode(struct dvb_frontend *fe, int mode)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\n\treturn st->ops->out(st->priv, SET_8PSK_CONFIG, mode, 0, NULL, 0);\n}\n\nstatic int gp8psk_fe_update_status(struct gp8psk_fe_state *st)\n{\n\tu8 buf[6];\n\tif (time_after(jiffies,st->next_status_check)) {\n\t\tst->ops->in(st->priv, GET_SIGNAL_LOCK, 0, 0, &st->lock, 1);\n\t\tst->ops->in(st->priv, GET_SIGNAL_STRENGTH, 0, 0, buf, 6);\n\t\tst->snr = (buf[1]) << 8 | buf[0];\n\t\tst->next_status_check = jiffies + (st->status_check_interval*HZ)/1000;\n\t}\n\treturn 0;\n}\n\nstatic int gp8psk_fe_read_status(struct dvb_frontend *fe,\n\t\t\t\t enum fe_status *status)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\tgp8psk_fe_update_status(st);\n\n\tif (st->lock)\n\t\t*status = FE_HAS_LOCK | FE_HAS_SYNC | FE_HAS_VITERBI | FE_HAS_SIGNAL | FE_HAS_CARRIER;\n\telse\n\t\t*status = 0;\n\n\tif (*status & FE_HAS_LOCK)\n\t\tst->status_check_interval = 1000;\n\telse\n\t\tst->status_check_interval = 100;\n\treturn 0;\n}\n\n \nstatic int gp8psk_fe_read_ber(struct dvb_frontend* fe, u32 *ber)\n{\n\t(void) fe;\n\t*ber = 0;\n\treturn 0;\n}\n\n \nstatic int gp8psk_fe_read_unc_blocks(struct dvb_frontend* fe, u32 *unc)\n{\n\t(void) fe;\n\t*unc = 0;\n\treturn 0;\n}\n\nstatic int gp8psk_fe_read_snr(struct dvb_frontend* fe, u16 *snr)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\tgp8psk_fe_update_status(st);\n\t \n\t*snr = st->snr;\n\treturn 0;\n}\n\nstatic int gp8psk_fe_read_signal_strength(struct dvb_frontend* fe, u16 *strength)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\tgp8psk_fe_update_status(st);\n\t \n\t \n\t \n\tif (st->snr > 0xf00)\n\t\t*strength = 0xffff;\n\telse\n\t\t*strength = (st->snr << 4) + st->snr;  \n\treturn 0;\n}\n\nstatic int gp8psk_fe_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 800;\n\treturn 0;\n}\n\nstatic int gp8psk_fe_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu8 cmd[10];\n\tu32 freq = c->frequency * 1000;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tcmd[4] = freq         & 0xff;\n\tcmd[5] = (freq >> 8)  & 0xff;\n\tcmd[6] = (freq >> 16) & 0xff;\n\tcmd[7] = (freq >> 24) & 0xff;\n\n\t \n\tif (c->delivery_system == SYS_DVBS && c->modulation == PSK_8)\n\t\tc->delivery_system = SYS_TURBO;\n\n\tswitch (c->delivery_system) {\n\tcase SYS_DVBS:\n\t\tif (c->modulation != QPSK) {\n\t\t\tdprintk(\"%s: unsupported modulation selected (%d)\\n\",\n\t\t\t\t__func__, c->modulation);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tc->fec_inner = FEC_AUTO;\n\t\tbreak;\n\tcase SYS_DVBS2:  \n\t\tdprintk(\"%s: DVB-S2 delivery system selected\\n\", __func__);\n\t\tbreak;\n\tcase SYS_TURBO:\n\t\tdprintk(\"%s: Turbo-FEC delivery system selected\\n\", __func__);\n\t\tbreak;\n\n\tdefault:\n\t\tdprintk(\"%s: unsupported delivery system selected (%d)\\n\",\n\t\t\t__func__, c->delivery_system);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcmd[0] =  c->symbol_rate        & 0xff;\n\tcmd[1] = (c->symbol_rate >>  8) & 0xff;\n\tcmd[2] = (c->symbol_rate >> 16) & 0xff;\n\tcmd[3] = (c->symbol_rate >> 24) & 0xff;\n\tswitch (c->modulation) {\n\tcase QPSK:\n\t\tif (st->is_rev1)\n\t\t\tif (gp8psk_tuned_to_DCII(fe))\n\t\t\t\tst->ops->reload(st->priv);\n\t\tswitch (c->fec_inner) {\n\t\tcase FEC_1_2:\n\t\t\tcmd[9] = 0; break;\n\t\tcase FEC_2_3:\n\t\t\tcmd[9] = 1; break;\n\t\tcase FEC_3_4:\n\t\t\tcmd[9] = 2; break;\n\t\tcase FEC_5_6:\n\t\t\tcmd[9] = 3; break;\n\t\tcase FEC_7_8:\n\t\t\tcmd[9] = 4; break;\n\t\tcase FEC_AUTO:\n\t\t\tcmd[9] = 5; break;\n\t\tdefault:\n\t\t\tcmd[9] = 5; break;\n\t\t}\n\t\tif (c->delivery_system == SYS_TURBO)\n\t\t\tcmd[8] = ADV_MOD_TURBO_QPSK;\n\t\telse\n\t\t\tcmd[8] = ADV_MOD_DVB_QPSK;\n\t\tbreak;\n\tcase PSK_8:  \n\t\tcmd[8] = ADV_MOD_TURBO_8PSK;\n\t\tswitch (c->fec_inner) {\n\t\tcase FEC_2_3:\n\t\t\tcmd[9] = 0; break;\n\t\tcase FEC_3_4:\n\t\t\tcmd[9] = 1; break;\n\t\tcase FEC_3_5:\n\t\t\tcmd[9] = 2; break;\n\t\tcase FEC_5_6:\n\t\t\tcmd[9] = 3; break;\n\t\tcase FEC_8_9:\n\t\t\tcmd[9] = 4; break;\n\t\tdefault:\n\t\t\tcmd[9] = 0; break;\n\t\t}\n\t\tbreak;\n\tcase QAM_16:  \n\t\tcmd[8] = ADV_MOD_TURBO_16QAM;\n\t\tcmd[9] = 0;\n\t\tbreak;\n\tdefault:  \n\t\tdprintk(\"%s: unsupported modulation selected (%d)\\n\",\n\t\t\t__func__, c->modulation);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (st->is_rev1)\n\t\tgp8psk_set_tuner_mode(fe, 0);\n\tst->ops->out(st->priv, TUNE_8PSK, 0, 0, cmd, 10);\n\n\tst->lock = 0;\n\tst->next_status_check = jiffies;\n\tst->status_check_interval = 200;\n\n\treturn 0;\n}\n\nstatic int gp8psk_fe_send_diseqc_msg (struct dvb_frontend* fe,\n\t\t\t\t    struct dvb_diseqc_master_cmd *m)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (st->ops->out(st->priv, SEND_DISEQC_COMMAND, m->msg[0], 0,\n\t\t\tm->msg, m->msg_len)) {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int gp8psk_fe_send_diseqc_burst(struct dvb_frontend *fe,\n\t\t\t\t       enum fe_sec_mini_cmd burst)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\tu8 cmd;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tcmd = (burst == SEC_MINI_A) ? 0x00 : 0x01;\n\n\tif (st->ops->out(st->priv, SEND_DISEQC_COMMAND, cmd, 0,\n\t\t\t&cmd, 0)) {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int gp8psk_fe_set_tone(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_tone_mode tone)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\n\tif (st->ops->out(st->priv, SET_22KHZ_TONE,\n\t\t\t (tone == SEC_TONE_ON), 0, NULL, 0)) {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int gp8psk_fe_set_voltage(struct dvb_frontend *fe,\n\t\t\t\t enum fe_sec_voltage voltage)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\n\tif (st->ops->out(st->priv, SET_LNB_VOLTAGE,\n\t\t\t voltage == SEC_VOLTAGE_18, 0, NULL, 0)) {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int gp8psk_fe_enable_high_lnb_voltage(struct dvb_frontend* fe, long onoff)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\n\treturn st->ops->out(st->priv, USE_EXTRA_VOLT, onoff, 0, NULL, 0);\n}\n\nstatic int gp8psk_fe_send_legacy_dish_cmd (struct dvb_frontend* fe, unsigned long sw_cmd)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\tu8 cmd = sw_cmd & 0x7f;\n\n\tif (st->ops->out(st->priv, SET_DN_SWITCH, cmd, 0, NULL, 0))\n\t\treturn -EINVAL;\n\n\tif (st->ops->out(st->priv, SET_LNB_VOLTAGE, !!(sw_cmd & 0x80),\n\t\t\t0, NULL, 0))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void gp8psk_fe_release(struct dvb_frontend* fe)\n{\n\tstruct gp8psk_fe_state *st = fe->demodulator_priv;\n\n\tkfree(st);\n}\n\nstatic const struct dvb_frontend_ops gp8psk_fe_ops;\n\nstruct dvb_frontend *gp8psk_fe_attach(const struct gp8psk_fe_ops *ops,\n\t\t\t\t      void *priv, bool is_rev1)\n{\n\tstruct gp8psk_fe_state *st;\n\n\tif (!ops || !ops->in || !ops->out || !ops->reload) {\n\t\tpr_err(\"Error! gp8psk-fe ops not defined.\\n\");\n\t\treturn NULL;\n\t}\n\n\tst = kzalloc(sizeof(struct gp8psk_fe_state), GFP_KERNEL);\n\tif (!st)\n\t\treturn NULL;\n\n\tmemcpy(&st->fe.ops, &gp8psk_fe_ops, sizeof(struct dvb_frontend_ops));\n\tst->fe.demodulator_priv = st;\n\tst->ops = ops;\n\tst->priv = priv;\n\tst->is_rev1 = is_rev1;\n\n\tpr_info(\"Frontend %sattached\\n\", is_rev1 ? \"revision 1 \" : \"\");\n\n\treturn &st->fe;\n}\nEXPORT_SYMBOL_GPL(gp8psk_fe_attach);\n\nstatic const struct dvb_frontend_ops gp8psk_fe_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name\t\t\t= \"Genpix DVB-S\",\n\t\t.frequency_min_hz\t=  800 * MHz,\n\t\t.frequency_max_hz\t= 2250 * MHz,\n\t\t.frequency_stepsize_hz\t=  100 * kHz,\n\t\t.symbol_rate_min        = 1000000,\n\t\t.symbol_rate_max        = 45000000,\n\t\t.symbol_rate_tolerance  = 500,   \n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\t \n\t\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_TURBO_FEC\n\t},\n\n\t.release = gp8psk_fe_release,\n\n\t.init = NULL,\n\t.sleep = NULL,\n\n\t.set_frontend = gp8psk_fe_set_frontend,\n\n\t.get_tune_settings = gp8psk_fe_get_tune_settings,\n\n\t.read_status = gp8psk_fe_read_status,\n\t.read_ber = gp8psk_fe_read_ber,\n\t.read_signal_strength = gp8psk_fe_read_signal_strength,\n\t.read_snr = gp8psk_fe_read_snr,\n\t.read_ucblocks = gp8psk_fe_read_unc_blocks,\n\n\t.diseqc_send_master_cmd = gp8psk_fe_send_diseqc_msg,\n\t.diseqc_send_burst = gp8psk_fe_send_diseqc_burst,\n\t.set_tone = gp8psk_fe_set_tone,\n\t.set_voltage = gp8psk_fe_set_voltage,\n\t.dishnetwork_send_legacy_command = gp8psk_fe_send_legacy_dish_cmd,\n\t.enable_high_lnb_voltage = gp8psk_fe_enable_high_lnb_voltage\n};\n\nMODULE_AUTHOR(\"Alan Nisota <alannisota@gamil.com>\");\nMODULE_DESCRIPTION(\"Frontend Driver for Genpix DVB-S\");\nMODULE_VERSION(\"1.1\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}