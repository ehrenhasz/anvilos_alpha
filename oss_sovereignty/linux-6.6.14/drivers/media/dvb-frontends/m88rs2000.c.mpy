{
  "module_name": "m88rs2000.c",
  "hash_id": "cd54a7cbcc75cfd30074e0b91923d1ce065fec79af325dfb4b553a06eb343460",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/m88rs2000.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n\n#include <media/dvb_frontend.h>\n#include \"m88rs2000.h\"\n\nstruct m88rs2000_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct m88rs2000_config *config;\n\tstruct dvb_frontend frontend;\n\tu8 no_lock_count;\n\tu32 tuner_frequency;\n\tu32 symbol_rate;\n\tenum fe_code_rate fec_inner;\n\tu8 tuner_level;\n\tint errmode;\n};\n\nstatic int m88rs2000_debug;\n\nmodule_param_named(debug, m88rs2000_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"set debugging level (1=info (or-able)).\");\n\n#define dprintk(level, args...) do { \\\n\tif (level & m88rs2000_debug) \\\n\t\tprintk(KERN_DEBUG \"m88rs2000-fe: \" args); \\\n} while (0)\n\n#define deb_info(args...)  dprintk(0x01, args)\n#define info(format, arg...) \\\n\tprintk(KERN_INFO \"m88rs2000-fe: \" format \"\\n\" , ## arg)\n\nstatic int m88rs2000_writereg(struct m88rs2000_state *state,\n\tu8 reg, u8 data)\n{\n\tint ret;\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = {\n\t\t.addr = state->config->demod_addr,\n\t\t.flags = 0,\n\t\t.buf = buf,\n\t\t.len = 2\n\t};\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tdeb_info(\"%s: writereg error (reg == 0x%02x, val == 0x%02x, ret == %i)\\n\",\n\t\t\t __func__, reg, data, ret);\n\n\treturn (ret != 1) ? -EREMOTEIO : 0;\n}\n\nstatic u8 m88rs2000_readreg(struct m88rs2000_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b0[] = { reg };\n\tu8 b1[] = { 0 };\n\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = state->config->demod_addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = b0,\n\t\t\t.len = 1\n\t\t}, {\n\t\t\t.addr = state->config->demod_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = b1,\n\t\t\t.len = 1\n\t\t}\n\t};\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tdeb_info(\"%s: readreg error (reg == 0x%02x, ret == %i)\\n\",\n\t\t\t\t__func__, reg, ret);\n\n\treturn b1[0];\n}\n\nstatic u32 m88rs2000_get_mclk(struct dvb_frontend *fe)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tu32 mclk;\n\tu8 reg;\n\t \n\treg = m88rs2000_readreg(state, 0x86);\n\tif (!reg || reg == 0xff)\n\t\treturn 0;\n\n\treg /= 2;\n\treg += 1;\n\n\tmclk = (u32)(reg * RS2000_FE_CRYSTAL_KHZ + 28 / 2) / 28;\n\n\treturn mclk;\n}\n\nstatic int m88rs2000_set_carrieroffset(struct dvb_frontend *fe, s16 offset)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tu32 mclk;\n\ts32 tmp;\n\tu8 reg;\n\tint ret;\n\n\tmclk = m88rs2000_get_mclk(fe);\n\tif (!mclk)\n\t\treturn -EINVAL;\n\n\ttmp = (offset * 4096 + (s32)mclk / 2) / (s32)mclk;\n\tif (tmp < 0)\n\t\ttmp += 4096;\n\n\t \n\tret = m88rs2000_writereg(state, 0x9c, (u8)(tmp >> 4));\n\n\treg = m88rs2000_readreg(state, 0x9d);\n\treg &= 0xf;\n\treg |= (u8)(tmp & 0xf) << 4;\n\n\tret |= m88rs2000_writereg(state, 0x9d, reg);\n\n\treturn ret;\n}\n\nstatic int m88rs2000_set_symbolrate(struct dvb_frontend *fe, u32 srate)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tint ret;\n\tu64 temp;\n\tu32 mclk;\n\tu8 b[3];\n\n\tif ((srate < 1000000) || (srate > 45000000))\n\t\treturn -EINVAL;\n\n\tmclk = m88rs2000_get_mclk(fe);\n\tif (!mclk)\n\t\treturn -EINVAL;\n\n\ttemp = srate / 1000;\n\ttemp *= 1 << 24;\n\n\tdo_div(temp, mclk);\n\n\tb[0] = (u8) (temp >> 16) & 0xff;\n\tb[1] = (u8) (temp >> 8) & 0xff;\n\tb[2] = (u8) temp & 0xff;\n\n\tret = m88rs2000_writereg(state, 0x93, b[2]);\n\tret |= m88rs2000_writereg(state, 0x94, b[1]);\n\tret |= m88rs2000_writereg(state, 0x95, b[0]);\n\n\tif (srate > 10000000)\n\t\tret |= m88rs2000_writereg(state, 0xa0, 0x20);\n\telse\n\t\tret |= m88rs2000_writereg(state, 0xa0, 0x60);\n\n\tret |= m88rs2000_writereg(state, 0xa1, 0xe0);\n\n\tif (srate > 12000000)\n\t\tret |= m88rs2000_writereg(state, 0xa3, 0x20);\n\telse if (srate > 2800000)\n\t\tret |= m88rs2000_writereg(state, 0xa3, 0x98);\n\telse\n\t\tret |= m88rs2000_writereg(state, 0xa3, 0x90);\n\n\tdeb_info(\"m88rs2000: m88rs2000_set_symbolrate\\n\");\n\treturn ret;\n}\n\nstatic int m88rs2000_send_diseqc_msg(struct dvb_frontend *fe,\n\t\t\t\t    struct dvb_diseqc_master_cmd *m)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\n\tint i;\n\tu8 reg;\n\tdeb_info(\"%s\\n\", __func__);\n\tm88rs2000_writereg(state, 0x9a, 0x30);\n\treg = m88rs2000_readreg(state, 0xb2);\n\treg &= 0x3f;\n\tm88rs2000_writereg(state, 0xb2, reg);\n\tfor (i = 0; i <  m->msg_len; i++)\n\t\tm88rs2000_writereg(state, 0xb3 + i, m->msg[i]);\n\n\treg = m88rs2000_readreg(state, 0xb1);\n\treg &= 0x87;\n\treg |= ((m->msg_len - 1) << 3) | 0x07;\n\treg &= 0x7f;\n\tm88rs2000_writereg(state, 0xb1, reg);\n\n\tfor (i = 0; i < 15; i++) {\n\t\tif ((m88rs2000_readreg(state, 0xb1) & 0x40) == 0x0)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\n\treg = m88rs2000_readreg(state, 0xb1);\n\tif ((reg & 0x40) > 0x0) {\n\t\treg &= 0x7f;\n\t\treg |= 0x40;\n\t\tm88rs2000_writereg(state, 0xb1, reg);\n\t}\n\n\treg = m88rs2000_readreg(state, 0xb2);\n\treg &= 0x3f;\n\treg |= 0x80;\n\tm88rs2000_writereg(state, 0xb2, reg);\n\tm88rs2000_writereg(state, 0x9a, 0xb0);\n\n\n\treturn 0;\n}\n\nstatic int m88rs2000_send_diseqc_burst(struct dvb_frontend *fe,\n\t\t\t\t       enum fe_sec_mini_cmd burst)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tu8 reg0, reg1;\n\tdeb_info(\"%s\\n\", __func__);\n\tm88rs2000_writereg(state, 0x9a, 0x30);\n\tmsleep(50);\n\treg0 = m88rs2000_readreg(state, 0xb1);\n\treg1 = m88rs2000_readreg(state, 0xb2);\n\t \n\tm88rs2000_writereg(state, 0xb2, reg1);\n\tm88rs2000_writereg(state, 0xb1, reg0);\n\tm88rs2000_writereg(state, 0x9a, 0xb0);\n\n\treturn 0;\n}\n\nstatic int m88rs2000_set_tone(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_tone_mode tone)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tu8 reg0, reg1;\n\tm88rs2000_writereg(state, 0x9a, 0x30);\n\treg0 = m88rs2000_readreg(state, 0xb1);\n\treg1 = m88rs2000_readreg(state, 0xb2);\n\n\treg1 &= 0x3f;\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\treg0 |= 0x4;\n\t\treg0 &= 0xbc;\n\t\tbreak;\n\tcase SEC_TONE_OFF:\n\t\treg1 |= 0x80;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tm88rs2000_writereg(state, 0xb2, reg1);\n\tm88rs2000_writereg(state, 0xb1, reg0);\n\tm88rs2000_writereg(state, 0x9a, 0xb0);\n\treturn 0;\n}\n\nstruct inittab {\n\tu8 cmd;\n\tu8 reg;\n\tu8 val;\n};\n\nstatic struct inittab m88rs2000_setup[] = {\n\t{DEMOD_WRITE, 0x9a, 0x30},\n\t{DEMOD_WRITE, 0x00, 0x01},\n\t{WRITE_DELAY, 0x19, 0x00},\n\t{DEMOD_WRITE, 0x00, 0x00},\n\t{DEMOD_WRITE, 0x9a, 0xb0},\n\t{DEMOD_WRITE, 0x81, 0xc1},\n\t{DEMOD_WRITE, 0x81, 0x81},\n\t{DEMOD_WRITE, 0x86, 0xc6},\n\t{DEMOD_WRITE, 0x9a, 0x30},\n\t{DEMOD_WRITE, 0xf0, 0x22},\n\t{DEMOD_WRITE, 0xf1, 0xbf},\n\t{DEMOD_WRITE, 0xb0, 0x45},\n\t{DEMOD_WRITE, 0xb2, 0x01},  \n\t{DEMOD_WRITE, 0x9a, 0xb0},\n\t{0xff, 0xaa, 0xff}\n};\n\nstatic struct inittab m88rs2000_shutdown[] = {\n\t{DEMOD_WRITE, 0x9a, 0x30},\n\t{DEMOD_WRITE, 0xb0, 0x00},\n\t{DEMOD_WRITE, 0xf1, 0x89},\n\t{DEMOD_WRITE, 0x00, 0x01},\n\t{DEMOD_WRITE, 0x9a, 0xb0},\n\t{DEMOD_WRITE, 0x81, 0x81},\n\t{0xff, 0xaa, 0xff}\n};\n\nstatic struct inittab fe_reset[] = {\n\t{DEMOD_WRITE, 0x00, 0x01},\n\t{DEMOD_WRITE, 0x20, 0x81},\n\t{DEMOD_WRITE, 0x21, 0x80},\n\t{DEMOD_WRITE, 0x10, 0x33},\n\t{DEMOD_WRITE, 0x11, 0x44},\n\t{DEMOD_WRITE, 0x12, 0x07},\n\t{DEMOD_WRITE, 0x18, 0x20},\n\t{DEMOD_WRITE, 0x28, 0x04},\n\t{DEMOD_WRITE, 0x29, 0x8e},\n\t{DEMOD_WRITE, 0x3b, 0xff},\n\t{DEMOD_WRITE, 0x32, 0x10},\n\t{DEMOD_WRITE, 0x33, 0x02},\n\t{DEMOD_WRITE, 0x34, 0x30},\n\t{DEMOD_WRITE, 0x35, 0xff},\n\t{DEMOD_WRITE, 0x38, 0x50},\n\t{DEMOD_WRITE, 0x39, 0x68},\n\t{DEMOD_WRITE, 0x3c, 0x7f},\n\t{DEMOD_WRITE, 0x3d, 0x0f},\n\t{DEMOD_WRITE, 0x45, 0x20},\n\t{DEMOD_WRITE, 0x46, 0x24},\n\t{DEMOD_WRITE, 0x47, 0x7c},\n\t{DEMOD_WRITE, 0x48, 0x16},\n\t{DEMOD_WRITE, 0x49, 0x04},\n\t{DEMOD_WRITE, 0x4a, 0x01},\n\t{DEMOD_WRITE, 0x4b, 0x78},\n\t{DEMOD_WRITE, 0X4d, 0xd2},\n\t{DEMOD_WRITE, 0x4e, 0x6d},\n\t{DEMOD_WRITE, 0x50, 0x30},\n\t{DEMOD_WRITE, 0x51, 0x30},\n\t{DEMOD_WRITE, 0x54, 0x7b},\n\t{DEMOD_WRITE, 0x56, 0x09},\n\t{DEMOD_WRITE, 0x58, 0x59},\n\t{DEMOD_WRITE, 0x59, 0x37},\n\t{DEMOD_WRITE, 0x63, 0xfa},\n\t{0xff, 0xaa, 0xff}\n};\n\nstatic struct inittab fe_trigger[] = {\n\t{DEMOD_WRITE, 0x97, 0x04},\n\t{DEMOD_WRITE, 0x99, 0x77},\n\t{DEMOD_WRITE, 0x9b, 0x64},\n\t{DEMOD_WRITE, 0x9e, 0x00},\n\t{DEMOD_WRITE, 0x9f, 0xf8},\n\t{DEMOD_WRITE, 0x98, 0xff},\n\t{DEMOD_WRITE, 0xc0, 0x0f},\n\t{DEMOD_WRITE, 0x89, 0x01},\n\t{DEMOD_WRITE, 0x00, 0x00},\n\t{WRITE_DELAY, 0x0a, 0x00},\n\t{DEMOD_WRITE, 0x00, 0x01},\n\t{DEMOD_WRITE, 0x00, 0x00},\n\t{DEMOD_WRITE, 0x9a, 0xb0},\n\t{0xff, 0xaa, 0xff}\n};\n\nstatic int m88rs2000_tab_set(struct m88rs2000_state *state,\n\t\tstruct inittab *tab)\n{\n\tint ret = 0;\n\tu8 i;\n\tif (tab == NULL)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 255; i++) {\n\t\tswitch (tab[i].cmd) {\n\t\tcase 0x01:\n\t\t\tret = m88rs2000_writereg(state, tab[i].reg,\n\t\t\t\ttab[i].val);\n\t\t\tbreak;\n\t\tcase 0x10:\n\t\t\tif (tab[i].reg > 0)\n\t\t\t\tmdelay(tab[i].reg);\n\t\t\tbreak;\n\t\tcase 0xff:\n\t\t\tif (tab[i].reg == 0xaa && tab[i].val == 0xff)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase 0x00:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int m88rs2000_set_voltage(struct dvb_frontend *fe,\n\t\t\t\t enum fe_sec_voltage volt)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tu8 data;\n\n\tdata = m88rs2000_readreg(state, 0xb2);\n\tdata |= 0x03;  \n\n\tswitch (volt) {\n\tcase SEC_VOLTAGE_18:\n\t\tdata &= ~0x03;\n\t\tbreak;\n\tcase SEC_VOLTAGE_13:\n\t\tdata &= ~0x03;\n\t\tdata |= 0x01;\n\t\tbreak;\n\tcase SEC_VOLTAGE_OFF:\n\t\tbreak;\n\t}\n\n\tm88rs2000_writereg(state, 0xb2, data);\n\n\treturn 0;\n}\n\nstatic int m88rs2000_init(struct dvb_frontend *fe)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tint ret;\n\n\tdeb_info(\"m88rs2000: init chip\\n\");\n\t \n\tif (state->config->inittab)\n\t\tret = m88rs2000_tab_set(state,\n\t\t\t\t(struct inittab *)state->config->inittab);\n\telse\n\t\tret = m88rs2000_tab_set(state, m88rs2000_setup);\n\n\treturn ret;\n}\n\nstatic int m88rs2000_sleep(struct dvb_frontend *fe)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tint ret;\n\t \n\tret = m88rs2000_tab_set(state, m88rs2000_shutdown);\n\treturn ret;\n}\n\nstatic int m88rs2000_read_status(struct dvb_frontend *fe,\n\t\t\t\t enum fe_status *status)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tu8 reg = m88rs2000_readreg(state, 0x8c);\n\n\t*status = 0;\n\n\tif ((reg & 0xee) == 0xee) {\n\t\t*status = FE_HAS_CARRIER | FE_HAS_SIGNAL | FE_HAS_VITERBI\n\t\t\t| FE_HAS_SYNC | FE_HAS_LOCK;\n\t\tif (state->config->set_ts_params)\n\t\t\tstate->config->set_ts_params(fe, CALL_IS_READ);\n\t}\n\treturn 0;\n}\n\nstatic int m88rs2000_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tu8 tmp0, tmp1;\n\n\tm88rs2000_writereg(state, 0x9a, 0x30);\n\ttmp0 = m88rs2000_readreg(state, 0xd8);\n\tif ((tmp0 & 0x10) != 0) {\n\t\tm88rs2000_writereg(state, 0x9a, 0xb0);\n\t\t*ber = 0xffffffff;\n\t\treturn 0;\n\t}\n\n\t*ber = (m88rs2000_readreg(state, 0xd7) << 8) |\n\t\tm88rs2000_readreg(state, 0xd6);\n\n\ttmp1 = m88rs2000_readreg(state, 0xd9);\n\tm88rs2000_writereg(state, 0xd9, (tmp1 & ~7) | 4);\n\t \n\tm88rs2000_writereg(state, 0xd8, (tmp0 & ~8) | 0x30);\n\tm88rs2000_writereg(state, 0xd8, (tmp0 & ~8) | 0x30);\n\tm88rs2000_writereg(state, 0x9a, 0xb0);\n\n\treturn 0;\n}\n\nstatic int m88rs2000_read_signal_strength(struct dvb_frontend *fe,\n\tu16 *strength)\n{\n\tif (fe->ops.tuner_ops.get_rf_strength)\n\t\tfe->ops.tuner_ops.get_rf_strength(fe, strength);\n\n\treturn 0;\n}\n\nstatic int m88rs2000_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\n\t*snr = 512 * m88rs2000_readreg(state, 0x65);\n\n\treturn 0;\n}\n\nstatic int m88rs2000_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tu8 tmp;\n\n\t*ucblocks = (m88rs2000_readreg(state, 0xd5) << 8) |\n\t\t\tm88rs2000_readreg(state, 0xd4);\n\ttmp = m88rs2000_readreg(state, 0xd8);\n\tm88rs2000_writereg(state, 0xd8, tmp & ~0x20);\n\t \n\tm88rs2000_writereg(state, 0xd8, tmp | 0x20);\n\tm88rs2000_writereg(state, 0xd8, tmp | 0x20);\n\n\treturn 0;\n}\n\nstatic int m88rs2000_set_fec(struct m88rs2000_state *state,\n\t\t\t     enum fe_code_rate fec)\n{\n\tu8 fec_set, reg;\n\tint ret;\n\n\tswitch (fec) {\n\tcase FEC_1_2:\n\t\tfec_set = 0x8;\n\t\tbreak;\n\tcase FEC_2_3:\n\t\tfec_set = 0x10;\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tfec_set = 0x20;\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tfec_set = 0x40;\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tfec_set = 0x80;\n\t\tbreak;\n\tcase FEC_AUTO:\n\tdefault:\n\t\tfec_set = 0x0;\n\t}\n\n\treg = m88rs2000_readreg(state, 0x70);\n\treg &= 0x7;\n\tret = m88rs2000_writereg(state, 0x70, reg | fec_set);\n\n\tret |= m88rs2000_writereg(state, 0x76, 0x8);\n\n\treturn ret;\n}\n\nstatic enum fe_code_rate m88rs2000_get_fec(struct m88rs2000_state *state)\n{\n\tu8 reg;\n\tm88rs2000_writereg(state, 0x9a, 0x30);\n\treg = m88rs2000_readreg(state, 0x76);\n\tm88rs2000_writereg(state, 0x9a, 0xb0);\n\n\treg &= 0xf0;\n\treg >>= 5;\n\n\tswitch (reg) {\n\tcase 0x4:\n\t\treturn FEC_1_2;\n\tcase 0x3:\n\t\treturn FEC_2_3;\n\tcase 0x2:\n\t\treturn FEC_3_4;\n\tcase 0x1:\n\t\treturn FEC_5_6;\n\tcase 0x0:\n\t\treturn FEC_7_8;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn FEC_AUTO;\n}\n\nstatic int m88rs2000_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tenum fe_status status = 0;\n\tint i, ret = 0;\n\tu32 tuner_freq;\n\ts16 offset = 0;\n\tu8 reg;\n\n\tstate->no_lock_count = 0;\n\n\tif (c->delivery_system != SYS_DVBS) {\n\t\tdeb_info(\"%s: unsupported delivery system selected (%d)\\n\",\n\t\t\t __func__, c->delivery_system);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (fe->ops.tuner_ops.set_params)\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tif (fe->ops.tuner_ops.get_frequency) {\n\t\tret = fe->ops.tuner_ops.get_frequency(fe, &tuner_freq);\n\n\t\tif (ret < 0)\n\t\t\treturn -ENODEV;\n\n\t\toffset = (s16)((s32)tuner_freq - c->frequency);\n\t} else {\n\t\toffset = 0;\n\t}\n\n\t \n\tif (((c->frequency % 192857) >= (192857 - 3000)) ||\n\t\t\t\t(c->frequency % 192857) <= 3000)\n\t\tret = m88rs2000_writereg(state, 0x86, 0xc2);\n\telse\n\t\tret = m88rs2000_writereg(state, 0x86, 0xc6);\n\n\tret |= m88rs2000_set_carrieroffset(fe, offset);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\t \n\tif (c->symbol_rate > 27500000)\n\t\tret = m88rs2000_writereg(state, 0xf1, 0xa4);\n\telse\n\t\tret = m88rs2000_writereg(state, 0xf1, 0xbf);\n\n\tret |= m88rs2000_tab_set(state, fe_reset);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\t \n\tret = m88rs2000_set_fec(state, c->fec_inner);\n\tret |= m88rs2000_writereg(state, 0x85, 0x1);\n\tret |= m88rs2000_writereg(state, 0x8a, 0xbf);\n\tret |= m88rs2000_writereg(state, 0x8d, 0x1e);\n\tret |= m88rs2000_writereg(state, 0x90, 0xf1);\n\tret |= m88rs2000_writereg(state, 0x91, 0x08);\n\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\t \n\tret = m88rs2000_set_symbolrate(fe, c->symbol_rate);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\t \n\tret = m88rs2000_tab_set(state, fe_trigger);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < 25; i++) {\n\t\treg = m88rs2000_readreg(state, 0x8c);\n\t\tif ((reg & 0xee) == 0xee) {\n\t\t\tstatus = FE_HAS_LOCK;\n\t\t\tbreak;\n\t\t}\n\t\tstate->no_lock_count++;\n\t\tif (state->no_lock_count == 15) {\n\t\t\treg = m88rs2000_readreg(state, 0x70);\n\t\t\treg ^= 0x4;\n\t\t\tm88rs2000_writereg(state, 0x70, reg);\n\t\t\tstate->no_lock_count = 0;\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\tif (status & FE_HAS_LOCK) {\n\t\tstate->fec_inner = m88rs2000_get_fec(state);\n\t\t \n\t\treg = m88rs2000_readreg(state, 0x65);\n\t}\n\n\tstate->tuner_frequency = c->frequency;\n\tstate->symbol_rate = c->symbol_rate;\n\treturn 0;\n}\n\nstatic int m88rs2000_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t  struct dtv_frontend_properties *c)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\n\tc->fec_inner = state->fec_inner;\n\tc->frequency = state->tuner_frequency;\n\tc->symbol_rate = state->symbol_rate;\n\treturn 0;\n}\n\nstatic int m88rs2000_get_tune_settings(struct dvb_frontend *fe,\n\tstruct dvb_frontend_tune_settings *tune)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\tif (c->symbol_rate > 3000000)\n\t\ttune->min_delay_ms = 2000;\n\telse\n\t\ttune->min_delay_ms = 3000;\n\n\ttune->step_size = c->symbol_rate / 16000;\n\ttune->max_drift = c->symbol_rate / 2000;\n\n\treturn 0;\n}\n\nstatic int m88rs2000_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\n\tif (enable)\n\t\tm88rs2000_writereg(state, 0x81, 0x84);\n\telse\n\t\tm88rs2000_writereg(state, 0x81, 0x81);\n\tudelay(10);\n\treturn 0;\n}\n\nstatic void m88rs2000_release(struct dvb_frontend *fe)\n{\n\tstruct m88rs2000_state *state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops m88rs2000_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name\t\t\t= \"M88RS2000 DVB-S\",\n\t\t.frequency_min_hz\t=  950 * MHz,\n\t\t.frequency_max_hz\t= 2150 * MHz,\n\t\t.frequency_stepsize_hz\t= 1 * MHz,\n\t\t.frequency_tolerance_hz\t= 5 * MHz,\n\t\t.symbol_rate_min\t= 1000000,\n\t\t.symbol_rate_max\t= 45000000,\n\t\t.symbol_rate_tolerance\t= 500,\t \n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t      FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |\n\t\t      FE_CAN_QPSK | FE_CAN_INVERSION_AUTO |\n\t\t      FE_CAN_FEC_AUTO\n\t},\n\n\t.release = m88rs2000_release,\n\t.init = m88rs2000_init,\n\t.sleep = m88rs2000_sleep,\n\t.i2c_gate_ctrl = m88rs2000_i2c_gate_ctrl,\n\t.read_status = m88rs2000_read_status,\n\t.read_ber = m88rs2000_read_ber,\n\t.read_signal_strength = m88rs2000_read_signal_strength,\n\t.read_snr = m88rs2000_read_snr,\n\t.read_ucblocks = m88rs2000_read_ucblocks,\n\t.diseqc_send_master_cmd = m88rs2000_send_diseqc_msg,\n\t.diseqc_send_burst = m88rs2000_send_diseqc_burst,\n\t.set_tone = m88rs2000_set_tone,\n\t.set_voltage = m88rs2000_set_voltage,\n\n\t.set_frontend = m88rs2000_set_frontend,\n\t.get_frontend = m88rs2000_get_frontend,\n\t.get_tune_settings = m88rs2000_get_tune_settings,\n};\n\nstruct dvb_frontend *m88rs2000_attach(const struct m88rs2000_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct m88rs2000_state *state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct m88rs2000_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->tuner_frequency = 0;\n\tstate->symbol_rate = 0;\n\tstate->fec_inner = 0;\n\n\t \n\tmemcpy(&state->frontend.ops, &m88rs2000_ops,\n\t\t\tsizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(m88rs2000_attach);\n\nMODULE_DESCRIPTION(\"M88RS2000 DVB-S Demodulator driver\");\nMODULE_AUTHOR(\"Malcolm Priestley tvboxspy@gmail.com\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.13\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}