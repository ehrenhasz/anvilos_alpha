{
  "module_name": "au8522_dig.c",
  "hash_id": "d4934c9fcc988c5785d5b3f3283a46eb77c4d3a0bc0487f5c4e91e18f4b8399c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/au8522_dig.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <media/dvb_frontend.h>\n#include \"au8522.h\"\n#include \"au8522_priv.h\"\n\nstatic int debug;\nstatic int zv_mode = 1;  \n\n#define dprintk(arg...)\\\n\tdo { if (debug)\\\n\t\tprintk(arg);\\\n\t} while (0)\n\nstruct mse2snr_tab {\n\tu16 val;\n\tu16 data;\n};\n\n \nstatic struct mse2snr_tab vsb_mse2snr_tab[] = {\n\t{   0, 270 },\n\t{   2, 250 },\n\t{   3, 240 },\n\t{   5, 230 },\n\t{   7, 220 },\n\t{   9, 210 },\n\t{  12, 200 },\n\t{  13, 195 },\n\t{  15, 190 },\n\t{  17, 185 },\n\t{  19, 180 },\n\t{  21, 175 },\n\t{  24, 170 },\n\t{  27, 165 },\n\t{  31, 160 },\n\t{  32, 158 },\n\t{  33, 156 },\n\t{  36, 152 },\n\t{  37, 150 },\n\t{  39, 148 },\n\t{  40, 146 },\n\t{  41, 144 },\n\t{  43, 142 },\n\t{  44, 140 },\n\t{  48, 135 },\n\t{  50, 130 },\n\t{  43, 142 },\n\t{  53, 125 },\n\t{  56, 120 },\n\t{ 256, 115 },\n};\n\n \nstatic struct mse2snr_tab qam64_mse2snr_tab[] = {\n\t{  15,   0 },\n\t{  16, 290 },\n\t{  17, 288 },\n\t{  18, 286 },\n\t{  19, 284 },\n\t{  20, 282 },\n\t{  21, 281 },\n\t{  22, 279 },\n\t{  23, 277 },\n\t{  24, 275 },\n\t{  25, 273 },\n\t{  26, 271 },\n\t{  27, 269 },\n\t{  28, 268 },\n\t{  29, 266 },\n\t{  30, 264 },\n\t{  31, 262 },\n\t{  32, 260 },\n\t{  33, 259 },\n\t{  34, 258 },\n\t{  35, 256 },\n\t{  36, 255 },\n\t{  37, 254 },\n\t{  38, 252 },\n\t{  39, 251 },\n\t{  40, 250 },\n\t{  41, 249 },\n\t{  42, 248 },\n\t{  43, 246 },\n\t{  44, 245 },\n\t{  45, 244 },\n\t{  46, 242 },\n\t{  47, 241 },\n\t{  48, 240 },\n\t{  50, 239 },\n\t{  51, 238 },\n\t{  53, 237 },\n\t{  54, 236 },\n\t{  56, 235 },\n\t{  57, 234 },\n\t{  59, 233 },\n\t{  60, 232 },\n\t{  62, 231 },\n\t{  63, 230 },\n\t{  65, 229 },\n\t{  67, 228 },\n\t{  68, 227 },\n\t{  70, 226 },\n\t{  71, 225 },\n\t{  73, 224 },\n\t{  74, 223 },\n\t{  76, 222 },\n\t{  78, 221 },\n\t{  80, 220 },\n\t{  82, 219 },\n\t{  85, 218 },\n\t{  88, 217 },\n\t{  90, 216 },\n\t{  92, 215 },\n\t{  93, 214 },\n\t{  94, 212 },\n\t{  95, 211 },\n\t{  97, 210 },\n\t{  99, 209 },\n\t{ 101, 208 },\n\t{ 102, 207 },\n\t{ 104, 206 },\n\t{ 107, 205 },\n\t{ 111, 204 },\n\t{ 114, 203 },\n\t{ 118, 202 },\n\t{ 122, 201 },\n\t{ 125, 200 },\n\t{ 128, 199 },\n\t{ 130, 198 },\n\t{ 132, 197 },\n\t{ 256, 190 },\n};\n\n \nstatic struct mse2snr_tab qam256_mse2snr_tab[] = {\n\t{  15,   0 },\n\t{  16, 400 },\n\t{  17, 398 },\n\t{  18, 396 },\n\t{  19, 394 },\n\t{  20, 392 },\n\t{  21, 390 },\n\t{  22, 388 },\n\t{  23, 386 },\n\t{  24, 384 },\n\t{  25, 382 },\n\t{  26, 380 },\n\t{  27, 379 },\n\t{  28, 378 },\n\t{  29, 377 },\n\t{  30, 376 },\n\t{  31, 375 },\n\t{  32, 374 },\n\t{  33, 373 },\n\t{  34, 372 },\n\t{  35, 371 },\n\t{  36, 370 },\n\t{  37, 362 },\n\t{  38, 354 },\n\t{  39, 346 },\n\t{  40, 338 },\n\t{  41, 330 },\n\t{  42, 328 },\n\t{  43, 326 },\n\t{  44, 324 },\n\t{  45, 322 },\n\t{  46, 320 },\n\t{  47, 319 },\n\t{  48, 318 },\n\t{  49, 317 },\n\t{  50, 316 },\n\t{  51, 315 },\n\t{  52, 314 },\n\t{  53, 313 },\n\t{  54, 312 },\n\t{  55, 311 },\n\t{  56, 310 },\n\t{  57, 308 },\n\t{  58, 306 },\n\t{  59, 304 },\n\t{  60, 302 },\n\t{  61, 300 },\n\t{  62, 298 },\n\t{  65, 295 },\n\t{  68, 294 },\n\t{  70, 293 },\n\t{  73, 292 },\n\t{  76, 291 },\n\t{  78, 290 },\n\t{  79, 289 },\n\t{  81, 288 },\n\t{  82, 287 },\n\t{  83, 286 },\n\t{  84, 285 },\n\t{  85, 284 },\n\t{  86, 283 },\n\t{  88, 282 },\n\t{  89, 281 },\n\t{ 256, 280 },\n};\n\nstatic int au8522_mse2snr_lookup(struct mse2snr_tab *tab, int sz, int mse,\n\t\t\t\t u16 *snr)\n{\n\tint i, ret = -EINVAL;\n\tdprintk(\"%s()\\n\", __func__);\n\n\tfor (i = 0; i < sz; i++) {\n\t\tif (mse < tab[i].val) {\n\t\t\t*snr = tab[i].data;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdprintk(\"%s() snr=%d\\n\", __func__, *snr);\n\treturn ret;\n}\n\nstatic int au8522_set_if(struct dvb_frontend *fe, enum au8522_if_freq if_freq)\n{\n\tstruct au8522_state *state = fe->demodulator_priv;\n\tu8 r0b5, r0b6, r0b7;\n\tchar *ifmhz;\n\n\tswitch (if_freq) {\n\tcase AU8522_IF_3_25MHZ:\n\t\tifmhz = \"3.25\";\n\t\tr0b5 = 0x00;\n\t\tr0b6 = 0x3d;\n\t\tr0b7 = 0xa0;\n\t\tbreak;\n\tcase AU8522_IF_4MHZ:\n\t\tifmhz = \"4.00\";\n\t\tr0b5 = 0x00;\n\t\tr0b6 = 0x4b;\n\t\tr0b7 = 0xd9;\n\t\tbreak;\n\tcase AU8522_IF_6MHZ:\n\t\tifmhz = \"6.00\";\n\t\tr0b5 = 0xfb;\n\t\tr0b6 = 0x8e;\n\t\tr0b7 = 0x39;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s() IF Frequency not supported\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tdprintk(\"%s() %s MHz\\n\", __func__, ifmhz);\n\tau8522_writereg(state, 0x00b5, r0b5);\n\tau8522_writereg(state, 0x00b6, r0b6);\n\tau8522_writereg(state, 0x00b7, r0b7);\n\n\treturn 0;\n}\n\n \nstatic struct {\n\tu16 reg;\n\tu16 data;\n} VSB_mod_tab[] = {\n\t{ 0x0090, 0x84 },\n\t{ 0x2005, 0x00 },\n\t{ 0x0091, 0x80 },\n\t{ 0x00a3, 0x0c },\n\t{ 0x00a4, 0xe8 },\n\t{ 0x0081, 0xc4 },\n\t{ 0x00a5, 0x40 },\n\t{ 0x00a7, 0x40 },\n\t{ 0x00a6, 0x67 },\n\t{ 0x0262, 0x20 },\n\t{ 0x021c, 0x30 },\n\t{ 0x00d8, 0x1a },\n\t{ 0x0227, 0xa0 },\n\t{ 0x0121, 0xff },\n\t{ 0x00a8, 0xf0 },\n\t{ 0x00a9, 0x05 },\n\t{ 0x00aa, 0x77 },\n\t{ 0x00ab, 0xf0 },\n\t{ 0x00ac, 0x05 },\n\t{ 0x00ad, 0x77 },\n\t{ 0x00ae, 0x41 },\n\t{ 0x00af, 0x66 },\n\t{ 0x021b, 0xcc },\n\t{ 0x021d, 0x80 },\n\t{ 0x00a4, 0xe8 },\n\t{ 0x0231, 0x13 },\n};\n\n \nstatic struct {\n\tu16 reg;\n\tu16 data;\n} QAM64_mod_tab[] = {\n\t{ 0x00a3, 0x09 },\n\t{ 0x00a4, 0x00 },\n\t{ 0x0081, 0xc4 },\n\t{ 0x00a5, 0x40 },\n\t{ 0x00aa, 0x77 },\n\t{ 0x00ad, 0x77 },\n\t{ 0x00a6, 0x67 },\n\t{ 0x0262, 0x20 },\n\t{ 0x021c, 0x30 },\n\t{ 0x00b8, 0x3e },\n\t{ 0x00b9, 0xf0 },\n\t{ 0x00ba, 0x01 },\n\t{ 0x00bb, 0x18 },\n\t{ 0x00bc, 0x50 },\n\t{ 0x00bd, 0x00 },\n\t{ 0x00be, 0xea },\n\t{ 0x00bf, 0xef },\n\t{ 0x00c0, 0xfc },\n\t{ 0x00c1, 0xbd },\n\t{ 0x00c2, 0x1f },\n\t{ 0x00c3, 0xfc },\n\t{ 0x00c4, 0xdd },\n\t{ 0x00c5, 0xaf },\n\t{ 0x00c6, 0x00 },\n\t{ 0x00c7, 0x38 },\n\t{ 0x00c8, 0x30 },\n\t{ 0x00c9, 0x05 },\n\t{ 0x00ca, 0x4a },\n\t{ 0x00cb, 0xd0 },\n\t{ 0x00cc, 0x01 },\n\t{ 0x00cd, 0xd9 },\n\t{ 0x00ce, 0x6f },\n\t{ 0x00cf, 0xf9 },\n\t{ 0x00d0, 0x70 },\n\t{ 0x00d1, 0xdf },\n\t{ 0x00d2, 0xf7 },\n\t{ 0x00d3, 0xc2 },\n\t{ 0x00d4, 0xdf },\n\t{ 0x00d5, 0x02 },\n\t{ 0x00d6, 0x9a },\n\t{ 0x00d7, 0xd0 },\n\t{ 0x0250, 0x0d },\n\t{ 0x0251, 0xcd },\n\t{ 0x0252, 0xe0 },\n\t{ 0x0253, 0x05 },\n\t{ 0x0254, 0xa7 },\n\t{ 0x0255, 0xff },\n\t{ 0x0256, 0xed },\n\t{ 0x0257, 0x5b },\n\t{ 0x0258, 0xae },\n\t{ 0x0259, 0xe6 },\n\t{ 0x025a, 0x3d },\n\t{ 0x025b, 0x0f },\n\t{ 0x025c, 0x0d },\n\t{ 0x025d, 0xea },\n\t{ 0x025e, 0xf2 },\n\t{ 0x025f, 0x51 },\n\t{ 0x0260, 0xf5 },\n\t{ 0x0261, 0x06 },\n\t{ 0x021a, 0x00 },\n\t{ 0x0546, 0x40 },\n\t{ 0x0210, 0xc7 },\n\t{ 0x0211, 0xaa },\n\t{ 0x0212, 0xab },\n\t{ 0x0213, 0x02 },\n\t{ 0x0502, 0x00 },\n\t{ 0x0121, 0x04 },\n\t{ 0x0122, 0x04 },\n\t{ 0x052e, 0x10 },\n\t{ 0x00a4, 0xca },\n\t{ 0x00a7, 0x40 },\n\t{ 0x0526, 0x01 },\n};\n\n \nstatic struct {\n\tu16 reg;\n\tu16 data;\n} QAM256_mod_tab[] = {\n\t{ 0x00a3, 0x09 },\n\t{ 0x00a4, 0x00 },\n\t{ 0x0081, 0xc4 },\n\t{ 0x00a5, 0x40 },\n\t{ 0x00aa, 0x77 },\n\t{ 0x00ad, 0x77 },\n\t{ 0x00a6, 0x67 },\n\t{ 0x0262, 0x20 },\n\t{ 0x021c, 0x30 },\n\t{ 0x00b8, 0x3e },\n\t{ 0x00b9, 0xf0 },\n\t{ 0x00ba, 0x01 },\n\t{ 0x00bb, 0x18 },\n\t{ 0x00bc, 0x50 },\n\t{ 0x00bd, 0x00 },\n\t{ 0x00be, 0xea },\n\t{ 0x00bf, 0xef },\n\t{ 0x00c0, 0xfc },\n\t{ 0x00c1, 0xbd },\n\t{ 0x00c2, 0x1f },\n\t{ 0x00c3, 0xfc },\n\t{ 0x00c4, 0xdd },\n\t{ 0x00c5, 0xaf },\n\t{ 0x00c6, 0x00 },\n\t{ 0x00c7, 0x38 },\n\t{ 0x00c8, 0x30 },\n\t{ 0x00c9, 0x05 },\n\t{ 0x00ca, 0x4a },\n\t{ 0x00cb, 0xd0 },\n\t{ 0x00cc, 0x01 },\n\t{ 0x00cd, 0xd9 },\n\t{ 0x00ce, 0x6f },\n\t{ 0x00cf, 0xf9 },\n\t{ 0x00d0, 0x70 },\n\t{ 0x00d1, 0xdf },\n\t{ 0x00d2, 0xf7 },\n\t{ 0x00d3, 0xc2 },\n\t{ 0x00d4, 0xdf },\n\t{ 0x00d5, 0x02 },\n\t{ 0x00d6, 0x9a },\n\t{ 0x00d7, 0xd0 },\n\t{ 0x0250, 0x0d },\n\t{ 0x0251, 0xcd },\n\t{ 0x0252, 0xe0 },\n\t{ 0x0253, 0x05 },\n\t{ 0x0254, 0xa7 },\n\t{ 0x0255, 0xff },\n\t{ 0x0256, 0xed },\n\t{ 0x0257, 0x5b },\n\t{ 0x0258, 0xae },\n\t{ 0x0259, 0xe6 },\n\t{ 0x025a, 0x3d },\n\t{ 0x025b, 0x0f },\n\t{ 0x025c, 0x0d },\n\t{ 0x025d, 0xea },\n\t{ 0x025e, 0xf2 },\n\t{ 0x025f, 0x51 },\n\t{ 0x0260, 0xf5 },\n\t{ 0x0261, 0x06 },\n\t{ 0x021a, 0x00 },\n\t{ 0x0546, 0x40 },\n\t{ 0x0210, 0x26 },\n\t{ 0x0211, 0xf6 },\n\t{ 0x0212, 0x84 },\n\t{ 0x0213, 0x02 },\n\t{ 0x0502, 0x01 },\n\t{ 0x0121, 0x04 },\n\t{ 0x0122, 0x04 },\n\t{ 0x052e, 0x10 },\n\t{ 0x00a4, 0xca },\n\t{ 0x00a7, 0x40 },\n\t{ 0x0526, 0x01 },\n};\n\nstatic struct {\n\tu16 reg;\n\tu16 data;\n} QAM256_mod_tab_zv_mode[] = {\n\t{ 0x80a3, 0x09 },\n\t{ 0x80a4, 0x00 },\n\t{ 0x8081, 0xc4 },\n\t{ 0x80a5, 0x40 },\n\t{ 0x80b5, 0xfb },\n\t{ 0x80b6, 0x8e },\n\t{ 0x80b7, 0x39 },\n\t{ 0x80aa, 0x77 },\n\t{ 0x80ad, 0x77 },\n\t{ 0x80a6, 0x67 },\n\t{ 0x8262, 0x20 },\n\t{ 0x821c, 0x30 },\n\t{ 0x80b8, 0x3e },\n\t{ 0x80b9, 0xf0 },\n\t{ 0x80ba, 0x01 },\n\t{ 0x80bb, 0x18 },\n\t{ 0x80bc, 0x50 },\n\t{ 0x80bd, 0x00 },\n\t{ 0x80be, 0xea },\n\t{ 0x80bf, 0xef },\n\t{ 0x80c0, 0xfc },\n\t{ 0x80c1, 0xbd },\n\t{ 0x80c2, 0x1f },\n\t{ 0x80c3, 0xfc },\n\t{ 0x80c4, 0xdd },\n\t{ 0x80c5, 0xaf },\n\t{ 0x80c6, 0x00 },\n\t{ 0x80c7, 0x38 },\n\t{ 0x80c8, 0x30 },\n\t{ 0x80c9, 0x05 },\n\t{ 0x80ca, 0x4a },\n\t{ 0x80cb, 0xd0 },\n\t{ 0x80cc, 0x01 },\n\t{ 0x80cd, 0xd9 },\n\t{ 0x80ce, 0x6f },\n\t{ 0x80cf, 0xf9 },\n\t{ 0x80d0, 0x70 },\n\t{ 0x80d1, 0xdf },\n\t{ 0x80d2, 0xf7 },\n\t{ 0x80d3, 0xc2 },\n\t{ 0x80d4, 0xdf },\n\t{ 0x80d5, 0x02 },\n\t{ 0x80d6, 0x9a },\n\t{ 0x80d7, 0xd0 },\n\t{ 0x8250, 0x0d },\n\t{ 0x8251, 0xcd },\n\t{ 0x8252, 0xe0 },\n\t{ 0x8253, 0x05 },\n\t{ 0x8254, 0xa7 },\n\t{ 0x8255, 0xff },\n\t{ 0x8256, 0xed },\n\t{ 0x8257, 0x5b },\n\t{ 0x8258, 0xae },\n\t{ 0x8259, 0xe6 },\n\t{ 0x825a, 0x3d },\n\t{ 0x825b, 0x0f },\n\t{ 0x825c, 0x0d },\n\t{ 0x825d, 0xea },\n\t{ 0x825e, 0xf2 },\n\t{ 0x825f, 0x51 },\n\t{ 0x8260, 0xf5 },\n\t{ 0x8261, 0x06 },\n\t{ 0x821a, 0x01 },\n\t{ 0x8546, 0x40 },\n\t{ 0x8210, 0x26 },\n\t{ 0x8211, 0xf6 },\n\t{ 0x8212, 0x84 },\n\t{ 0x8213, 0x02 },\n\t{ 0x8502, 0x01 },\n\t{ 0x8121, 0x04 },\n\t{ 0x8122, 0x04 },\n\t{ 0x852e, 0x10 },\n\t{ 0x80a4, 0xca },\n\t{ 0x80a7, 0x40 },\n\t{ 0x8526, 0x01 },\n};\n\nstatic int au8522_enable_modulation(struct dvb_frontend *fe,\n\t\t\t\t    enum fe_modulation m)\n{\n\tstruct au8522_state *state = fe->demodulator_priv;\n\tint i;\n\n\tdprintk(\"%s(0x%08x)\\n\", __func__, m);\n\n\tswitch (m) {\n\tcase VSB_8:\n\t\tdprintk(\"%s() VSB_8\\n\", __func__);\n\t\tfor (i = 0; i < ARRAY_SIZE(VSB_mod_tab); i++)\n\t\t\tau8522_writereg(state,\n\t\t\t\tVSB_mod_tab[i].reg,\n\t\t\t\tVSB_mod_tab[i].data);\n\t\tau8522_set_if(fe, state->config.vsb_if);\n\t\tbreak;\n\tcase QAM_64:\n\t\tdprintk(\"%s() QAM 64\\n\", __func__);\n\t\tfor (i = 0; i < ARRAY_SIZE(QAM64_mod_tab); i++)\n\t\t\tau8522_writereg(state,\n\t\t\t\tQAM64_mod_tab[i].reg,\n\t\t\t\tQAM64_mod_tab[i].data);\n\t\tau8522_set_if(fe, state->config.qam_if);\n\t\tbreak;\n\tcase QAM_256:\n\t\tif (zv_mode) {\n\t\t\tdprintk(\"%s() QAM 256 (zv_mode)\\n\", __func__);\n\t\t\tfor (i = 0; i < ARRAY_SIZE(QAM256_mod_tab_zv_mode); i++)\n\t\t\t\tau8522_writereg(state,\n\t\t\t\t\tQAM256_mod_tab_zv_mode[i].reg,\n\t\t\t\t\tQAM256_mod_tab_zv_mode[i].data);\n\t\t\tau8522_set_if(fe, state->config.qam_if);\n\t\t\tmsleep(100);\n\t\t\tau8522_writereg(state, 0x821a, 0x00);\n\t\t} else {\n\t\t\tdprintk(\"%s() QAM 256\\n\", __func__);\n\t\t\tfor (i = 0; i < ARRAY_SIZE(QAM256_mod_tab); i++)\n\t\t\t\tau8522_writereg(state,\n\t\t\t\t\tQAM256_mod_tab[i].reg,\n\t\t\t\t\tQAM256_mod_tab[i].data);\n\t\t\tau8522_set_if(fe, state->config.qam_if);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s() Invalid modulation\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tstate->current_modulation = m;\n\n\treturn 0;\n}\n\n \nstatic int au8522_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct au8522_state *state = fe->demodulator_priv;\n\tint ret = -EINVAL;\n\n\tdprintk(\"%s(frequency=%d)\\n\", __func__, c->frequency);\n\n\tif ((state->current_frequency == c->frequency) &&\n\t    (state->current_modulation == c->modulation))\n\t\treturn 0;\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (zv_mode) {\n\t\tdprintk(\"%s() increase tuner settling time for zv_mode\\n\",\n\t\t\t__func__);\n\t\tmsleep(250);\n\t} else\n\t\tmsleep(100);\n\n\tau8522_enable_modulation(fe, c->modulation);\n\n\tstate->current_frequency = c->frequency;\n\n\treturn 0;\n}\n\nstatic int au8522_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct au8522_state *state = fe->demodulator_priv;\n\tu8 reg;\n\tu32 tuner_status = 0;\n\n\t*status = 0;\n\n\tif (state->current_modulation == VSB_8) {\n\t\tdprintk(\"%s() Checking VSB_8\\n\", __func__);\n\t\treg = au8522_readreg(state, 0x0088);\n\t\tif ((reg & 0x03) == 0x03)\n\t\t\t*status |= FE_HAS_LOCK | FE_HAS_SYNC | FE_HAS_VITERBI;\n\t} else {\n\t\tdprintk(\"%s() Checking QAM\\n\", __func__);\n\t\treg = au8522_readreg(state, 0x0541);\n\t\tif (reg & 0x80)\n\t\t\t*status |= FE_HAS_VITERBI;\n\t\tif (reg & 0x20)\n\t\t\t*status |= FE_HAS_LOCK | FE_HAS_SYNC;\n\t}\n\n\tswitch (state->config.status_mode) {\n\tcase AU8522_DEMODLOCKING:\n\t\tdprintk(\"%s() DEMODLOCKING\\n\", __func__);\n\t\tif (*status & FE_HAS_VITERBI)\n\t\t\t*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\n\t\tbreak;\n\tcase AU8522_TUNERLOCKING:\n\t\t \n\t\tdprintk(\"%s() TUNERLOCKING\\n\", __func__);\n\t\tif (fe->ops.tuner_ops.get_status) {\n\t\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t\t\tfe->ops.tuner_ops.get_status(fe, &tuner_status);\n\n\t\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t\t}\n\t\tif (tuner_status)\n\t\t\t*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\n\t\tbreak;\n\t}\n\tstate->fe_status = *status;\n\n\tif (*status & FE_HAS_LOCK)\n\t\t \n\t\tau8522_led_ctrl(state, -1);\n\telse\n\t\t \n\t\tau8522_led_ctrl(state, 0);\n\n\tdprintk(\"%s() status 0x%08x\\n\", __func__, *status);\n\n\treturn 0;\n}\n\nstatic int au8522_led_status(struct au8522_state *state, const u16 *snr)\n{\n\tstruct au8522_led_config *led_config = state->config.led_cfg;\n\tint led;\n\tu16 strong;\n\n\t \n\tif (!led_config)\n\t\treturn 0;\n\n\tif (0 == (state->fe_status & FE_HAS_LOCK))\n\t\treturn au8522_led_ctrl(state, 0);\n\telse if (state->current_modulation == QAM_256)\n\t\tstrong = led_config->qam256_strong;\n\telse if (state->current_modulation == QAM_64)\n\t\tstrong = led_config->qam64_strong;\n\telse  \n\t\tstrong = led_config->vsb8_strong;\n\n\tif (*snr >= strong)\n\t\tled = 2;\n\telse\n\t\tled = 1;\n\n\tif ((state->led_state) &&\n\t    (((strong < *snr) ? (*snr - strong) : (strong - *snr)) <= 10))\n\t\t \n\t\treturn 0;\n\n\treturn au8522_led_ctrl(state, led);\n}\n\nstatic int au8522_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct au8522_state *state = fe->demodulator_priv;\n\tint ret = -EINVAL;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\tif (state->current_modulation == QAM_256)\n\t\tret = au8522_mse2snr_lookup(qam256_mse2snr_tab,\n\t\t\t\t\t    ARRAY_SIZE(qam256_mse2snr_tab),\n\t\t\t\t\t    au8522_readreg(state, 0x0522),\n\t\t\t\t\t    snr);\n\telse if (state->current_modulation == QAM_64)\n\t\tret = au8522_mse2snr_lookup(qam64_mse2snr_tab,\n\t\t\t\t\t    ARRAY_SIZE(qam64_mse2snr_tab),\n\t\t\t\t\t    au8522_readreg(state, 0x0522),\n\t\t\t\t\t    snr);\n\telse  \n\t\tret = au8522_mse2snr_lookup(vsb_mse2snr_tab,\n\t\t\t\t\t    ARRAY_SIZE(vsb_mse2snr_tab),\n\t\t\t\t\t    au8522_readreg(state, 0x0311),\n\t\t\t\t\t    snr);\n\n\tif (state->config.led_cfg)\n\t\tau8522_led_status(state, snr);\n\n\treturn ret;\n}\n\nstatic int au8522_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t       u16 *signal_strength)\n{\n\t \n\tu16 snr;\n\tu32 tmp;\n\tint ret = au8522_read_snr(fe, &snr);\n\n\t*signal_strength = 0;\n\n\tif (0 == ret) {\n\t\t \n\n\t\t \n\t\ttmp = (snr * ((1 << 24) / 10));\n\n\t\t \n\t\tif (tmp >= 8960 * 0x10000)\n\t\t\t*signal_strength = 0xffff;\n\t\telse\n\t\t\t*signal_strength = tmp / 8960;\n\t}\n\n\treturn ret;\n}\n\nstatic int au8522_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\tstruct au8522_state *state = fe->demodulator_priv;\n\n\tif (state->current_modulation == VSB_8)\n\t\t*ucblocks = au8522_readreg(state, 0x0087);\n\telse\n\t\t*ucblocks = au8522_readreg(state, 0x0543);\n\n\treturn 0;\n}\n\nstatic int au8522_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\treturn au8522_read_ucblocks(fe, ber);\n}\n\nstatic int au8522_get_frontend(struct dvb_frontend *fe,\n\t\t\t       struct dtv_frontend_properties *c)\n{\n\tstruct au8522_state *state = fe->demodulator_priv;\n\n\tc->frequency = state->current_frequency;\n\tc->modulation = state->current_modulation;\n\n\treturn 0;\n}\n\nstatic int au8522_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t    struct dvb_frontend_tune_settings *tune)\n{\n\ttune->min_delay_ms = 1000;\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops au8522_ops;\n\n\nstatic void au8522_release(struct dvb_frontend *fe)\n{\n\tstruct au8522_state *state = fe->demodulator_priv;\n\tau8522_release_state(state);\n}\n\nstruct dvb_frontend *au8522_attach(const struct au8522_config *config,\n\t\t\t\t   struct i2c_adapter *i2c)\n{\n\tstruct au8522_state *state = NULL;\n\tint instance;\n\n\t \n\tinstance = au8522_get_state(&state, i2c, config->demod_address);\n\tswitch (instance) {\n\tcase 0:\n\t\tdprintk(\"%s state allocation failed\\n\", __func__);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tdprintk(\"%s using new instance\\n\", __func__);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdprintk(\"%s using existing instance\\n\", __func__);\n\t\tbreak;\n\t}\n\n\t \n\tstate->config = *config;\n\tstate->i2c = i2c;\n\tstate->operational_mode = AU8522_DIGITAL_MODE;\n\n\t \n\tmemcpy(&state->frontend.ops, &au8522_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\tstate->frontend.ops.analog_ops.i2c_gate_ctrl = au8522_analog_i2c_gate_ctrl;\n\n\tif (au8522_init(&state->frontend) != 0) {\n\t\tprintk(KERN_ERR \"%s: Failed to initialize correctly\\n\",\n\t\t\t__func__);\n\t\tgoto error;\n\t}\n\n\t \n\tau8522_i2c_gate_ctrl(&state->frontend, 1);\n\n\treturn &state->frontend;\n\nerror:\n\tau8522_release_state(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(au8522_attach);\n\nstatic const struct dvb_frontend_ops au8522_ops = {\n\t.delsys = { SYS_ATSC, SYS_DVBC_ANNEX_B },\n\t.info = {\n\t\t.name\t\t\t= \"Auvitek AU8522 QAM/8VSB Frontend\",\n\t\t.frequency_min_hz\t=  54 * MHz,\n\t\t.frequency_max_hz\t= 858 * MHz,\n\t\t.frequency_stepsize_hz\t= 62500,\n\t\t.caps = FE_CAN_QAM_64 | FE_CAN_QAM_256 | FE_CAN_8VSB\n\t},\n\n\t.init                 = au8522_init,\n\t.sleep                = au8522_sleep,\n\t.i2c_gate_ctrl        = au8522_i2c_gate_ctrl,\n\t.set_frontend         = au8522_set_frontend,\n\t.get_frontend         = au8522_get_frontend,\n\t.get_tune_settings    = au8522_get_tune_settings,\n\t.read_status          = au8522_read_status,\n\t.read_ber             = au8522_read_ber,\n\t.read_signal_strength = au8522_read_signal_strength,\n\t.read_snr             = au8522_read_snr,\n\t.read_ucblocks        = au8522_read_ucblocks,\n\t.release              = au8522_release,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Enable verbose debug messages\");\n\nmodule_param(zv_mode, int, 0644);\nMODULE_PARM_DESC(zv_mode, \"Turn on/off ZeeVee modulator compatibility mode (default:on).\\n\"\n\t\"\\t\\ton - modified AU8522 QAM256 initialization.\\n\"\n\t\"\\t\\tProvides faster lock when using ZeeVee modulator based sources\");\n\nMODULE_DESCRIPTION(\"Auvitek AU8522 QAM-B/ATSC Demodulator driver\");\nMODULE_AUTHOR(\"Steven Toth\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}