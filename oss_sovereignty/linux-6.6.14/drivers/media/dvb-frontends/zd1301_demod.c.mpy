{
  "module_name": "zd1301_demod.c",
  "hash_id": "ef796b1ba94ff7c83495eaef7ba74efb5915c316ba2e43600705966fd4e714e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/zd1301_demod.c",
  "human_readable_source": "\n \n\n#include \"zd1301_demod.h\"\n\nstatic u8 zd1301_demod_gain = 0x38;\nmodule_param_named(gain, zd1301_demod_gain, byte, 0644);\nMODULE_PARM_DESC(gain, \"gain (value: 0x00 - 0x70, default: 0x38)\");\n\nstruct zd1301_demod_dev {\n\tstruct platform_device *pdev;\n\tstruct dvb_frontend frontend;\n\tstruct i2c_adapter adapter;\n\tu8 gain;\n};\n\nstatic int zd1301_demod_wreg(struct zd1301_demod_dev *dev, u16 reg, u8 val)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct zd1301_demod_platform_data *pdata = pdev->dev.platform_data;\n\n\treturn pdata->reg_write(pdata->reg_priv, reg, val);\n}\n\nstatic int zd1301_demod_rreg(struct zd1301_demod_dev *dev, u16 reg, u8 *val)\n{\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct zd1301_demod_platform_data *pdata = pdev->dev.platform_data;\n\n\treturn pdata->reg_read(pdata->reg_priv, reg, val);\n}\n\nstatic int zd1301_demod_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct zd1301_demod_dev *dev = fe->demodulator_priv;\n\tstruct platform_device *pdev = dev->pdev;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\tu32 if_frequency;\n\tu8 r6a50_val;\n\n\tdev_dbg(&pdev->dev, \"frequency=%u bandwidth_hz=%u\\n\",\n\t\tc->frequency, c->bandwidth_hz);\n\n\t \n\tif (fe->ops.tuner_ops.set_params &&\n\t    fe->ops.tuner_ops.get_if_frequency) {\n\t\tret = fe->ops.tuner_ops.set_params(fe);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdev_dbg(&pdev->dev, \"if_frequency=%u\\n\", if_frequency);\n\tif (if_frequency != 36150000) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tswitch (c->bandwidth_hz) {\n\tcase 6000000:\n\t\tr6a50_val = 0x78;\n\t\tbreak;\n\tcase 7000000:\n\t\tr6a50_val = 0x68;\n\t\tbreak;\n\tcase 8000000:\n\t\tr6a50_val = 0x58;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = zd1301_demod_wreg(dev, 0x6a60, 0x11);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a47, 0x46);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a48, 0x46);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a4a, 0x15);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a4b, 0x63);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a5b, 0x99);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a3b, 0x10);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6806, 0x01);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a41, 0x08);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a42, 0x46);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a44, 0x14);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a45, 0x67);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a38, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a4c, 0x52);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a49, 0x2a);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6840, 0x2e);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a50, r6a50_val);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a38, 0x07);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&pdev->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int zd1301_demod_sleep(struct dvb_frontend *fe)\n{\n\tstruct zd1301_demod_dev *dev = fe->demodulator_priv;\n\tstruct platform_device *pdev = dev->pdev;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tret = zd1301_demod_wreg(dev, 0x6a43, 0x70);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x684e, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6849, 0x00);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x68e2, 0xd7);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x68e0, 0x39);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6840, 0x21);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&pdev->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int zd1301_demod_init(struct dvb_frontend *fe)\n{\n\tstruct zd1301_demod_dev *dev = fe->demodulator_priv;\n\tstruct platform_device *pdev = dev->pdev;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tret = zd1301_demod_wreg(dev, 0x6840, 0x26);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x68e0, 0xff);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x68e2, 0xd8);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6849, 0x4e);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x684e, 0x01);\n\tif (ret)\n\t\tgoto err;\n\tret = zd1301_demod_wreg(dev, 0x6a43, zd1301_demod_gain);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&pdev->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int zd1301_demod_get_tune_settings(struct dvb_frontend *fe,\n\t\t\t\t\t  struct dvb_frontend_tune_settings *settings)\n{\n\tstruct zd1301_demod_dev *dev = fe->demodulator_priv;\n\tstruct platform_device *pdev = dev->pdev;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\t \n\tsettings->min_delay_ms = 400;\n\n\treturn 0;\n}\n\nstatic int zd1301_demod_read_status(struct dvb_frontend *fe,\n\t\t\t\t    enum fe_status *status)\n{\n\tstruct zd1301_demod_dev *dev = fe->demodulator_priv;\n\tstruct platform_device *pdev = dev->pdev;\n\tint ret;\n\tu8 u8tmp;\n\n\tret = zd1301_demod_rreg(dev, 0x6a24, &u8tmp);\n\tif (ret)\n\t\tgoto err;\n\tif (u8tmp > 0x00 && u8tmp < 0x20)\n\t\t*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |\n\t\t\t  FE_HAS_SYNC | FE_HAS_LOCK;\n\telse\n\t\t*status = 0;\n\n\tdev_dbg(&pdev->dev, \"lock byte=%02x\\n\", u8tmp);\n\n\t \n\n\tif (dev->gain != zd1301_demod_gain) {\n\t\tdev->gain = zd1301_demod_gain;\n\n\t\tret = zd1301_demod_wreg(dev, 0x6a43, dev->gain);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&pdev->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dvb_frontend_ops zd1301_demod_ops = {\n\t.delsys = {SYS_DVBT},\n\t.info = {\n\t\t.name = \"ZyDAS ZD1301\",\n\t\t.caps = FE_CAN_FEC_1_2 |\n\t\t\tFE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 |\n\t\t\tFE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK |\n\t\t\tFE_CAN_QAM_16 |\n\t\t\tFE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO |\n\t\t\tFE_CAN_MUTE_TS\n\t},\n\n\t.sleep = zd1301_demod_sleep,\n\t.init = zd1301_demod_init,\n\t.set_frontend = zd1301_demod_set_frontend,\n\t.get_tune_settings = zd1301_demod_get_tune_settings,\n\t.read_status = zd1301_demod_read_status,\n};\n\nstruct dvb_frontend *zd1301_demod_get_dvb_frontend(struct platform_device *pdev)\n{\n\tstruct zd1301_demod_dev *dev = platform_get_drvdata(pdev);\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\treturn &dev->frontend;\n}\nEXPORT_SYMBOL(zd1301_demod_get_dvb_frontend);\n\nstatic int zd1301_demod_i2c_master_xfer(struct i2c_adapter *adapter,\n\t\t\t\t\tstruct i2c_msg msg[], int num)\n{\n\tstruct zd1301_demod_dev *dev = i2c_get_adapdata(adapter);\n\tstruct platform_device *pdev = dev->pdev;\n\tint ret, i;\n\tunsigned long timeout;\n\tu8 u8tmp;\n\n\t#define I2C_XFER_TIMEOUT 5\n\t#define ZD1301_IS_I2C_XFER_WRITE_READ(_msg, _num) \\\n\t\t(_num == 2 && !(_msg[0].flags & I2C_M_RD) && (_msg[1].flags & I2C_M_RD))\n\t#define ZD1301_IS_I2C_XFER_WRITE(_msg, _num) \\\n\t\t(_num == 1 && !(_msg[0].flags & I2C_M_RD))\n\t#define ZD1301_IS_I2C_XFER_READ(_msg, _num) \\\n\t\t(_num == 1 && (_msg[0].flags & I2C_M_RD))\n\tif (ZD1301_IS_I2C_XFER_WRITE_READ(msg, num)) {\n\t\tdev_dbg(&pdev->dev, \"write&read msg[0].len=%u msg[1].len=%u\\n\",\n\t\t\tmsg[0].len, msg[1].len);\n\t\tif (msg[0].len > 1 || msg[1].len > 8) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = zd1301_demod_wreg(dev, 0x6811, 0x80);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6812, 0x05);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6813, msg[1].addr << 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6801, msg[0].buf[0]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6802, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6803, 0x06);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6805, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6804, msg[1].len);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\ttimeout = jiffies + msecs_to_jiffies(I2C_XFER_TIMEOUT);\n\t\tfor (u8tmp = 1; !time_after(jiffies, timeout) && u8tmp;) {\n\t\t\tusleep_range(500, 800);\n\n\t\t\tret = zd1301_demod_rreg(dev, 0x6804, &u8tmp);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tfor (i = 0; i < msg[1].len; i++) {\n\t\t\tret = zd1301_demod_rreg(dev, 0x0600 + i, &msg[1].buf[i]);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t} else if (ZD1301_IS_I2C_XFER_WRITE(msg, num)) {\n\t\tdev_dbg(&pdev->dev, \"write msg[0].len=%u\\n\", msg[0].len);\n\t\tif (msg[0].len > 1 + 8) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = zd1301_demod_wreg(dev, 0x6811, 0x80);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6812, 0x01);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6813, msg[0].addr << 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6800, msg[0].buf[0]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6802, 0x00);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6803, 0x06);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tfor (i = 0; i < msg[0].len - 1; i++) {\n\t\t\tret = zd1301_demod_wreg(dev, 0x0600 + i, msg[0].buf[1 + i]);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tret = zd1301_demod_wreg(dev, 0x6805, 0x80);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = zd1301_demod_wreg(dev, 0x6804, msg[0].len - 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\ttimeout = jiffies + msecs_to_jiffies(I2C_XFER_TIMEOUT);\n\t\tfor (u8tmp = 1; !time_after(jiffies, timeout) && u8tmp;) {\n\t\t\tusleep_range(500, 800);\n\n\t\t\tret = zd1301_demod_rreg(dev, 0x6804, &u8tmp);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tdev_dbg(&pdev->dev, \"unknown msg[0].len=%u\\n\", msg[0].len);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\n\treturn num;\nerr:\n\tdev_dbg(&pdev->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic u32 zd1301_demod_i2c_functionality(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm zd1301_demod_i2c_algorithm = {\n\t.master_xfer   = zd1301_demod_i2c_master_xfer,\n\t.functionality = zd1301_demod_i2c_functionality,\n};\n\nstruct i2c_adapter *zd1301_demod_get_i2c_adapter(struct platform_device *pdev)\n{\n\tstruct zd1301_demod_dev *dev = platform_get_drvdata(pdev);\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\treturn &dev->adapter;\n}\nEXPORT_SYMBOL(zd1301_demod_get_i2c_adapter);\n\n \nstatic int zd1301_demod_probe(struct platform_device *pdev)\n{\n\tstruct zd1301_demod_dev *dev;\n\tstruct zd1301_demod_platform_data *pdata = pdev->dev.platform_data;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\tif (!pdata) {\n\t\tret = -EINVAL;\n\t\tdev_err(&pdev->dev, \"cannot proceed without platform data\\n\");\n\t\tgoto err;\n\t}\n\tif (!pdev->dev.parent->driver) {\n\t\tret = -EINVAL;\n\t\tdev_dbg(&pdev->dev, \"no parent device\\n\");\n\t\tgoto err;\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tdev->pdev = pdev;\n\tdev->gain = zd1301_demod_gain;\n\n\t \n\tret = zd1301_demod_wreg(dev, 0x6840, 0x21);\n\tif (ret)\n\t\tgoto err_kfree;\n\tret = zd1301_demod_wreg(dev, 0x6a38, 0x07);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\t \n\tstrscpy(dev->adapter.name, \"ZyDAS ZD1301 demod\",\n\t\tsizeof(dev->adapter.name));\n\tdev->adapter.algo = &zd1301_demod_i2c_algorithm;\n\tdev->adapter.algo_data = NULL;\n\tdev->adapter.dev.parent = pdev->dev.parent;\n\ti2c_set_adapdata(&dev->adapter, dev);\n\tret = i2c_add_adapter(&dev->adapter);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"I2C adapter add failed %d\\n\", ret);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tmemcpy(&dev->frontend.ops, &zd1301_demod_ops, sizeof(dev->frontend.ops));\n\tdev->frontend.demodulator_priv = dev;\n\tplatform_set_drvdata(pdev, dev);\n\tdev_info(&pdev->dev, \"ZyDAS ZD1301 demod attached\\n\");\n\n\treturn 0;\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&pdev->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void zd1301_demod_remove(struct platform_device *pdev)\n{\n\tstruct zd1301_demod_dev *dev = platform_get_drvdata(pdev);\n\n\tdev_dbg(&pdev->dev, \"\\n\");\n\n\ti2c_del_adapter(&dev->adapter);\n\tkfree(dev);\n}\n\nstatic struct platform_driver zd1301_demod_driver = {\n\t.driver = {\n\t\t.name                = \"zd1301_demod\",\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe          = zd1301_demod_probe,\n\t.remove_new     = zd1301_demod_remove,\n};\nmodule_platform_driver(zd1301_demod_driver);\n\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"ZyDAS ZD1301 demodulator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}