{
  "module_name": "stv6110.c",
  "hash_id": "a9de94a4d8218cae7bbab5e729fb8dc319439deb8cb49b50f965d93ab2b3f0db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stv6110.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/dvb/frontend.h>\n\n#include <linux/types.h>\n\n#include \"stv6110.h\"\n\n \n#define MAX_XFER_SIZE  64\n\nstatic int debug;\n\nstruct stv6110_priv {\n\tint i2c_address;\n\tstruct i2c_adapter *i2c;\n\n\tu32 mclk;\n\tu8 clk_div;\n\tu8 gain;\n\tu8 regs[8];\n};\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) \\\n\t\t\tprintk(KERN_DEBUG args); \\\n\t} while (0)\n\nstatic s32 abssub(s32 a, s32 b)\n{\n\tif (a > b)\n\t\treturn a - b;\n\telse\n\t\treturn b - a;\n};\n\nstatic void stv6110_release(struct dvb_frontend *fe)\n{\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int stv6110_write_regs(struct dvb_frontend *fe, u8 buf[],\n\t\t\t\t\t\t\tint start, int len)\n{\n\tstruct stv6110_priv *priv = fe->tuner_priv;\n\tint rc;\n\tu8 cmdbuf[MAX_XFER_SIZE];\n\tstruct i2c_msg msg = {\n\t\t.addr\t= priv->i2c_address,\n\t\t.flags\t= 0,\n\t\t.buf\t= cmdbuf,\n\t\t.len\t= len + 1\n\t};\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tif (1 + len > sizeof(cmdbuf)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: i2c wr: len=%d is too big!\\n\",\n\t\t       KBUILD_MODNAME, len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (start + len > 8)\n\t\treturn -EINVAL;\n\n\tmemcpy(&cmdbuf[1], buf, len);\n\tcmdbuf[0] = start;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\trc = i2c_transfer(priv->i2c, &msg, 1);\n\tif (rc != 1)\n\t\tdprintk(\"%s: i2c error\\n\", __func__);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn 0;\n}\n\nstatic int stv6110_read_regs(struct dvb_frontend *fe, u8 regs[],\n\t\t\t\t\t\t\tint start, int len)\n{\n\tstruct stv6110_priv *priv = fe->tuner_priv;\n\tint rc;\n\tu8 reg[] = { start };\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= priv->i2c_address,\n\t\t\t.flags\t= 0,\n\t\t\t.buf\t= reg,\n\t\t\t.len\t= 1,\n\t\t}, {\n\t\t\t.addr\t= priv->i2c_address,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.buf\t= regs,\n\t\t\t.len\t= len,\n\t\t},\n\t};\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\trc = i2c_transfer(priv->i2c, msg, 2);\n\tif (rc != 2)\n\t\tdprintk(\"%s: i2c error\\n\", __func__);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tmemcpy(&priv->regs[start], regs, len);\n\n\treturn 0;\n}\n\nstatic int stv6110_read_reg(struct dvb_frontend *fe, int start)\n{\n\tu8 buf[] = { 0 };\n\tstv6110_read_regs(fe, buf, start, 1);\n\n\treturn buf[0];\n}\n\nstatic int stv6110_sleep(struct dvb_frontend *fe)\n{\n\tu8 reg[] = { 0 };\n\tstv6110_write_regs(fe, reg, 0, 1);\n\n\treturn 0;\n}\n\nstatic u32 carrier_width(u32 symbol_rate, enum fe_rolloff rolloff)\n{\n\tu32 rlf;\n\n\tswitch (rolloff) {\n\tcase ROLLOFF_20:\n\t\trlf = 20;\n\t\tbreak;\n\tcase ROLLOFF_25:\n\t\trlf = 25;\n\t\tbreak;\n\tdefault:\n\t\trlf = 35;\n\t\tbreak;\n\t}\n\n\treturn symbol_rate  + ((symbol_rate * rlf) / 100);\n}\n\nstatic int stv6110_set_bandwidth(struct dvb_frontend *fe, u32 bandwidth)\n{\n\tstruct stv6110_priv *priv = fe->tuner_priv;\n\tu8 r8, ret = 0x04;\n\tint i;\n\n\tif ((bandwidth / 2) > 36000000)  \n\t\tr8 = 31;\n\telse if ((bandwidth / 2) < 5000000)  \n\t\tr8 = 0;\n\telse  \n\t\tr8 = (bandwidth / 2) / 1000000 - 5;\n\n\t \n\t \n\tpriv->regs[RSTV6110_CTRL3] &= ~((1 << 6) | 0x1f);\n\tpriv->regs[RSTV6110_CTRL3] |= (r8 & 0x1f);\n\tstv6110_write_regs(fe, &priv->regs[RSTV6110_CTRL3], RSTV6110_CTRL3, 1);\n\t \n\tpriv->regs[RSTV6110_STAT1] |= 0x02;\n\tstv6110_write_regs(fe, &priv->regs[RSTV6110_STAT1], RSTV6110_STAT1, 1);\n\n\ti = 0;\n\t \n\twhile ((i < 10) && (ret != 0)) {\n\t\tret = ((stv6110_read_reg(fe, RSTV6110_STAT1)) & 0x02);\n\t\tmdelay(1);\t \n\t\ti++;\n\t}\n\n\t \n\tpriv->regs[RSTV6110_CTRL3] |= (1 << 6);\n\tstv6110_write_regs(fe, &priv->regs[RSTV6110_CTRL3], RSTV6110_CTRL3, 1);\n\treturn 0;\n}\n\nstatic int stv6110_init(struct dvb_frontend *fe)\n{\n\tstruct stv6110_priv *priv = fe->tuner_priv;\n\tu8 buf0[] = { 0x07, 0x11, 0xdc, 0x85, 0x17, 0x01, 0xe6, 0x1e };\n\n\tmemcpy(priv->regs, buf0, 8);\n\t \n\tpriv->regs[RSTV6110_CTRL1] &= ~(0x1f << 3);\n\tpriv->regs[RSTV6110_CTRL1] |=\n\t\t\t\t((((priv->mclk / 1000000) - 16) & 0x1f) << 3);\n\n\t \n\tpriv->regs[RSTV6110_CTRL2] &= ~0xc0;\n\tpriv->regs[RSTV6110_CTRL2] |= (priv->clk_div << 6);\n\n\tstv6110_write_regs(fe, &priv->regs[RSTV6110_CTRL1], RSTV6110_CTRL1, 8);\n\tmsleep(1);\n\tstv6110_set_bandwidth(fe, 72000000);\n\n\treturn 0;\n}\n\nstatic int stv6110_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct stv6110_priv *priv = fe->tuner_priv;\n\tu32 nbsteps, divider, psd2, freq;\n\tu8 regs[] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\n\tstv6110_read_regs(fe, regs, 0, 8);\n\t \n\tdivider = (priv->regs[RSTV6110_TUNING2] & 0x0f) << 8;\n\tdivider += priv->regs[RSTV6110_TUNING1];\n\n\t \n\tnbsteps  = (priv->regs[RSTV6110_TUNING2] >> 6) & 3;\n\t \n\tpsd2  = (priv->regs[RSTV6110_TUNING2] >> 4) & 1;\n\n\tfreq = divider * (priv->mclk / 1000);\n\tfreq /= (1 << (nbsteps + psd2));\n\tfreq /= 4;\n\n\t*frequency = freq;\n\n\treturn 0;\n}\n\nstatic int stv6110_set_frequency(struct dvb_frontend *fe, u32 frequency)\n{\n\tstruct stv6110_priv *priv = fe->tuner_priv;\n\tu8 ret = 0x04;\n\tu32 divider, ref, p, presc, i, result_freq, vco_freq;\n\ts32 p_calc, p_calc_opt = 1000, r_div, r_div_opt = 0, p_val;\n\n\tdprintk(\"%s, freq=%d kHz, mclk=%d Hz\\n\", __func__,\n\t\t\t\t\t\tfrequency, priv->mclk);\n\n\t \n\tpriv->regs[RSTV6110_CTRL1] &= ~(0x1f << 3);\n\tpriv->regs[RSTV6110_CTRL1] |=\n\t\t\t\t((((priv->mclk / 1000000) - 16) & 0x1f) << 3);\n\n\t \n\tpriv->regs[RSTV6110_CTRL2] &= ~0x0f;\n\tpriv->regs[RSTV6110_CTRL2] |= (priv->gain & 0x0f);\n\n\tif (frequency <= 1023000) {\n\t\tp = 1;\n\t\tpresc = 0;\n\t} else if (frequency <= 1300000) {\n\t\tp = 1;\n\t\tpresc = 1;\n\t} else if (frequency <= 2046000) {\n\t\tp = 0;\n\t\tpresc = 0;\n\t} else {\n\t\tp = 0;\n\t\tpresc = 1;\n\t}\n\t \n\tpriv->regs[RSTV6110_TUNING2] &= ~(1 << 4);\n\tpriv->regs[RSTV6110_TUNING2] |= (p << 4);\n\n\t \n\tpriv->regs[RSTV6110_TUNING2] &= ~(1 << 5);\n\tpriv->regs[RSTV6110_TUNING2] |= (presc << 5);\n\n\tp_val = (int)(1 << (p + 1)) * 10; \n\tfor (r_div = 0; r_div <= 3; r_div++) {\n\t\tp_calc = (priv->mclk / 100000);\n\t\tp_calc /= (1 << (r_div + 1));\n\t\tif ((abssub(p_calc, p_val)) < (abssub(p_calc_opt, p_val)))\n\t\t\tr_div_opt = r_div;\n\n\t\tp_calc_opt = (priv->mclk / 100000);\n\t\tp_calc_opt /= (1 << (r_div_opt + 1));\n\t}\n\n\tref = priv->mclk / ((1 << (r_div_opt + 1))  * (1 << (p + 1)));\n\tdivider = (((frequency * 1000) + (ref >> 1)) / ref);\n\n\t \n\tpriv->regs[RSTV6110_TUNING2] &= ~(3 << 6);\n\tpriv->regs[RSTV6110_TUNING2] |= (((r_div_opt) & 3) << 6);\n\n\t \n\tpriv->regs[RSTV6110_TUNING2] &= ~0x0f;\n\tpriv->regs[RSTV6110_TUNING2] |= (((divider) >> 8) & 0x0f);\n\n\t \n\tpriv->regs[RSTV6110_TUNING1] = (divider & 0xff);\n\n\t \n\tpriv->regs[RSTV6110_STAT1] |= 0x04;\n\tstv6110_write_regs(fe, &priv->regs[RSTV6110_CTRL1],\n\t\t\t\t\t\tRSTV6110_CTRL1, 8);\n\n\ti = 0;\n\t \n\twhile ((i < 10) && (ret != 0)) {\n\t\tret = ((stv6110_read_reg(fe, RSTV6110_STAT1)) & 0x04);\n\t\tmsleep(1);  \n\t\ti++;\n\t}\n\n\tret = stv6110_read_reg(fe, RSTV6110_STAT1);\n\tstv6110_get_frequency(fe, &result_freq);\n\n\tvco_freq = divider * ((priv->mclk / 1000) / ((1 << (r_div_opt + 1))));\n\tdprintk(\"%s, stat1=%x, lo_freq=%d kHz, vco_frec=%d kHz\\n\", __func__,\n\t\t\t\t\t\tret, result_freq, vco_freq);\n\n\treturn 0;\n}\n\nstatic int stv6110_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 bandwidth = carrier_width(c->symbol_rate, c->rolloff);\n\n\tstv6110_set_frequency(fe, c->frequency);\n\tstv6110_set_bandwidth(fe, bandwidth);\n\n\treturn 0;\n}\n\nstatic int stv6110_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\n{\n\tstruct stv6110_priv *priv = fe->tuner_priv;\n\tu8 r8 = 0;\n\tu8 regs[] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\tstv6110_read_regs(fe, regs, 0, 8);\n\n\t \n\tr8 = priv->regs[RSTV6110_CTRL3] & 0x1f;\n\t*bandwidth = (r8 + 5) * 2000000; \n\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops stv6110_tuner_ops = {\n\t.info = {\n\t\t.name = \"ST STV6110\",\n\t\t.frequency_min_hz  =  950 * MHz,\n\t\t.frequency_max_hz  = 2150 * MHz,\n\t\t.frequency_step_hz =    1 * MHz,\n\t},\n\t.init = stv6110_init,\n\t.release = stv6110_release,\n\t.sleep = stv6110_sleep,\n\t.set_params = stv6110_set_params,\n\t.get_frequency = stv6110_get_frequency,\n\t.set_frequency = stv6110_set_frequency,\n\t.get_bandwidth = stv6110_get_bandwidth,\n\t.set_bandwidth = stv6110_set_bandwidth,\n\n};\n\nstruct dvb_frontend *stv6110_attach(struct dvb_frontend *fe,\n\t\t\t\t\tconst struct stv6110_config *config,\n\t\t\t\t\tstruct i2c_adapter *i2c)\n{\n\tstruct stv6110_priv *priv = NULL;\n\tu8 reg0[] = { 0x00, 0x07, 0x11, 0xdc, 0x85, 0x17, 0x01, 0xe6, 0x1e };\n\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = config->i2c_address,\n\t\t\t.flags = 0,\n\t\t\t.buf = reg0,\n\t\t\t.len = 9\n\t\t}\n\t};\n\tint ret;\n\n\t \n\treg0[2] &= ~0xc0;\n\treg0[2] |= (config->clk_div << 6);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tret = i2c_transfer(i2c, msg, 1);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tif (ret != 1)\n\t\treturn NULL;\n\n\tpriv = kzalloc(sizeof(struct stv6110_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\n\tpriv->i2c_address = config->i2c_address;\n\tpriv->i2c = i2c;\n\tpriv->mclk = config->mclk;\n\tpriv->clk_div = config->clk_div;\n\tpriv->gain = config->gain;\n\n\tmemcpy(&priv->regs, &reg0[1], 8);\n\n\tmemcpy(&fe->ops.tuner_ops, &stv6110_tuner_ops,\n\t\t\t\tsizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = priv;\n\tprintk(KERN_INFO \"STV6110 attached on addr=%x!\\n\", priv->i2c_address);\n\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(stv6110_attach);\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"ST STV6110 driver\");\nMODULE_AUTHOR(\"Igor M. Liplianin\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}