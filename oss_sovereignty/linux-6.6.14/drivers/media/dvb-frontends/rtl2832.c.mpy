{
  "module_name": "rtl2832.c",
  "hash_id": "9bb8ea412c3da573dbb6ed259d74bfb7f8d6cbcfa0dc02ff9e623d40d3504065",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/rtl2832.c",
  "human_readable_source": "\n \n\n#include \"rtl2832_priv.h\"\n\n#define REG_MASK(b) (BIT(b + 1) - 1)\n\nstatic const struct rtl2832_reg_entry registers[] = {\n\t[DVBT_SOFT_RST]\t\t= {0x101,  2, 2},\n\t[DVBT_IIC_REPEAT]\t= {0x101,  3, 3},\n\t[DVBT_TR_WAIT_MIN_8K]\t= {0x188, 11, 2},\n\t[DVBT_RSD_BER_FAIL_VAL]\t= {0x18f, 15, 0},\n\t[DVBT_EN_BK_TRK]\t= {0x1a6,  7, 7},\n\t[DVBT_AD_EN_REG]\t= {0x008,  7, 7},\n\t[DVBT_AD_EN_REG1]\t= {0x008,  6, 6},\n\t[DVBT_EN_BBIN]\t\t= {0x1b1,  0, 0},\n\t[DVBT_MGD_THD0]\t\t= {0x195,  7, 0},\n\t[DVBT_MGD_THD1]\t\t= {0x196,  7, 0},\n\t[DVBT_MGD_THD2]\t\t= {0x197,  7, 0},\n\t[DVBT_MGD_THD3]\t\t= {0x198,  7, 0},\n\t[DVBT_MGD_THD4]\t\t= {0x199,  7, 0},\n\t[DVBT_MGD_THD5]\t\t= {0x19a,  7, 0},\n\t[DVBT_MGD_THD6]\t\t= {0x19b,  7, 0},\n\t[DVBT_MGD_THD7]\t\t= {0x19c,  7, 0},\n\t[DVBT_EN_CACQ_NOTCH]\t= {0x161,  4, 4},\n\t[DVBT_AD_AV_REF]\t= {0x009,  6, 0},\n\t[DVBT_REG_PI]\t\t= {0x00a,  2, 0},\n\t[DVBT_PIP_ON]\t\t= {0x021,  3, 3},\n\t[DVBT_SCALE1_B92]\t= {0x292,  7, 0},\n\t[DVBT_SCALE1_B93]\t= {0x293,  7, 0},\n\t[DVBT_SCALE1_BA7]\t= {0x2a7,  7, 0},\n\t[DVBT_SCALE1_BA9]\t= {0x2a9,  7, 0},\n\t[DVBT_SCALE1_BAA]\t= {0x2aa,  7, 0},\n\t[DVBT_SCALE1_BAB]\t= {0x2ab,  7, 0},\n\t[DVBT_SCALE1_BAC]\t= {0x2ac,  7, 0},\n\t[DVBT_SCALE1_BB0]\t= {0x2b0,  7, 0},\n\t[DVBT_SCALE1_BB1]\t= {0x2b1,  7, 0},\n\t[DVBT_KB_P1]\t\t= {0x164,  3, 1},\n\t[DVBT_KB_P2]\t\t= {0x164,  6, 4},\n\t[DVBT_KB_P3]\t\t= {0x165,  2, 0},\n\t[DVBT_OPT_ADC_IQ]\t= {0x006,  5, 4},\n\t[DVBT_AD_AVI]\t\t= {0x009,  1, 0},\n\t[DVBT_AD_AVQ]\t\t= {0x009,  3, 2},\n\t[DVBT_K1_CR_STEP12]\t= {0x2ad,  9, 4},\n\t[DVBT_TRK_KS_P2]\t= {0x16f,  2, 0},\n\t[DVBT_TRK_KS_I2]\t= {0x170,  5, 3},\n\t[DVBT_TR_THD_SET2]\t= {0x172,  3, 0},\n\t[DVBT_TRK_KC_P2]\t= {0x173,  5, 3},\n\t[DVBT_TRK_KC_I2]\t= {0x175,  2, 0},\n\t[DVBT_CR_THD_SET2]\t= {0x176,  7, 6},\n\t[DVBT_PSET_IFFREQ]\t= {0x119, 21, 0},\n\t[DVBT_SPEC_INV]\t\t= {0x115,  0, 0},\n\t[DVBT_RSAMP_RATIO]\t= {0x19f, 27, 2},\n\t[DVBT_CFREQ_OFF_RATIO]\t= {0x19d, 23, 4},\n\t[DVBT_FSM_STAGE]\t= {0x351,  6, 3},\n\t[DVBT_RX_CONSTEL]\t= {0x33c,  3, 2},\n\t[DVBT_RX_HIER]\t\t= {0x33c,  6, 4},\n\t[DVBT_RX_C_RATE_LP]\t= {0x33d,  2, 0},\n\t[DVBT_RX_C_RATE_HP]\t= {0x33d,  5, 3},\n\t[DVBT_GI_IDX]\t\t= {0x351,  1, 0},\n\t[DVBT_FFT_MODE_IDX]\t= {0x351,  2, 2},\n\t[DVBT_RSD_BER_EST]\t= {0x34e, 15, 0},\n\t[DVBT_CE_EST_EVM]\t= {0x40c, 15, 0},\n\t[DVBT_RF_AGC_VAL]\t= {0x35b, 13, 0},\n\t[DVBT_IF_AGC_VAL]\t= {0x359, 13, 0},\n\t[DVBT_DAGC_VAL]\t\t= {0x305,  7, 0},\n\t[DVBT_SFREQ_OFF]\t= {0x318, 13, 0},\n\t[DVBT_CFREQ_OFF]\t= {0x35f, 17, 0},\n\t[DVBT_POLAR_RF_AGC]\t= {0x00e,  1, 1},\n\t[DVBT_POLAR_IF_AGC]\t= {0x00e,  0, 0},\n\t[DVBT_AAGC_HOLD]\t= {0x104,  5, 5},\n\t[DVBT_EN_RF_AGC]\t= {0x104,  6, 6},\n\t[DVBT_EN_IF_AGC]\t= {0x104,  7, 7},\n\t[DVBT_IF_AGC_MIN]\t= {0x108,  7, 0},\n\t[DVBT_IF_AGC_MAX]\t= {0x109,  7, 0},\n\t[DVBT_RF_AGC_MIN]\t= {0x10a,  7, 0},\n\t[DVBT_RF_AGC_MAX]\t= {0x10b,  7, 0},\n\t[DVBT_IF_AGC_MAN]\t= {0x10c,  6, 6},\n\t[DVBT_IF_AGC_MAN_VAL]\t= {0x10c, 13, 0},\n\t[DVBT_RF_AGC_MAN]\t= {0x10e,  6, 6},\n\t[DVBT_RF_AGC_MAN_VAL]\t= {0x10e, 13, 0},\n\t[DVBT_DAGC_TRG_VAL]\t= {0x112,  7, 0},\n\t[DVBT_AGC_TARG_VAL_0]\t= {0x102,  0, 0},\n\t[DVBT_AGC_TARG_VAL_8_1]\t= {0x103,  7, 0},\n\t[DVBT_AAGC_LOOP_GAIN]\t= {0x1c7,  5, 1},\n\t[DVBT_LOOP_GAIN2_3_0]\t= {0x104,  4, 1},\n\t[DVBT_LOOP_GAIN2_4]\t= {0x105,  7, 7},\n\t[DVBT_LOOP_GAIN3]\t= {0x1c8,  4, 0},\n\t[DVBT_VTOP1]\t\t= {0x106,  5, 0},\n\t[DVBT_VTOP2]\t\t= {0x1c9,  5, 0},\n\t[DVBT_VTOP3]\t\t= {0x1ca,  5, 0},\n\t[DVBT_KRF1]\t\t= {0x1cb,  7, 0},\n\t[DVBT_KRF2]\t\t= {0x107,  7, 0},\n\t[DVBT_KRF3]\t\t= {0x1cd,  7, 0},\n\t[DVBT_KRF4]\t\t= {0x1ce,  7, 0},\n\t[DVBT_EN_GI_PGA]\t= {0x1e5,  0, 0},\n\t[DVBT_THD_LOCK_UP]\t= {0x1d9,  8, 0},\n\t[DVBT_THD_LOCK_DW]\t= {0x1db,  8, 0},\n\t[DVBT_THD_UP1]\t\t= {0x1dd,  7, 0},\n\t[DVBT_THD_DW1]\t\t= {0x1de,  7, 0},\n\t[DVBT_INTER_CNT_LEN]\t= {0x1d8,  3, 0},\n\t[DVBT_GI_PGA_STATE]\t= {0x1e6,  3, 3},\n\t[DVBT_EN_AGC_PGA]\t= {0x1d7,  0, 0},\n\t[DVBT_CKOUTPAR]\t\t= {0x17b,  5, 5},\n\t[DVBT_CKOUT_PWR]\t= {0x17b,  6, 6},\n\t[DVBT_SYNC_DUR]\t\t= {0x17b,  7, 7},\n\t[DVBT_ERR_DUR]\t\t= {0x17c,  0, 0},\n\t[DVBT_SYNC_LVL]\t\t= {0x17c,  1, 1},\n\t[DVBT_ERR_LVL]\t\t= {0x17c,  2, 2},\n\t[DVBT_VAL_LVL]\t\t= {0x17c,  3, 3},\n\t[DVBT_SERIAL]\t\t= {0x17c,  4, 4},\n\t[DVBT_SER_LSB]\t\t= {0x17c,  5, 5},\n\t[DVBT_CDIV_PH0]\t\t= {0x17d,  3, 0},\n\t[DVBT_CDIV_PH1]\t\t= {0x17d,  7, 4},\n\t[DVBT_MPEG_IO_OPT_2_2]\t= {0x006,  7, 7},\n\t[DVBT_MPEG_IO_OPT_1_0]\t= {0x007,  7, 6},\n\t[DVBT_CKOUTPAR_PIP]\t= {0x0b7,  4, 4},\n\t[DVBT_CKOUT_PWR_PIP]\t= {0x0b7,  3, 3},\n\t[DVBT_SYNC_LVL_PIP]\t= {0x0b7,  2, 2},\n\t[DVBT_ERR_LVL_PIP]\t= {0x0b7,  1, 1},\n\t[DVBT_VAL_LVL_PIP]\t= {0x0b7,  0, 0},\n\t[DVBT_CKOUTPAR_PID]\t= {0x0b9,  4, 4},\n\t[DVBT_CKOUT_PWR_PID]\t= {0x0b9,  3, 3},\n\t[DVBT_SYNC_LVL_PID]\t= {0x0b9,  2, 2},\n\t[DVBT_ERR_LVL_PID]\t= {0x0b9,  1, 1},\n\t[DVBT_VAL_LVL_PID]\t= {0x0b9,  0, 0},\n\t[DVBT_SM_PASS]\t\t= {0x193, 11, 0},\n\t[DVBT_AD7_SETTING]\t= {0x011, 15, 0},\n\t[DVBT_RSSI_R]\t\t= {0x301,  6, 0},\n\t[DVBT_ACI_DET_IND]\t= {0x312,  0, 0},\n\t[DVBT_REG_MON]\t\t= {0x00d,  1, 0},\n\t[DVBT_REG_MONSEL]\t= {0x00d,  2, 2},\n\t[DVBT_REG_GPE]\t\t= {0x00d,  7, 7},\n\t[DVBT_REG_GPO]\t\t= {0x010,  0, 0},\n\t[DVBT_REG_4MSEL]\t= {0x013,  0, 0},\n};\n\nstatic int rtl2832_rd_demod_reg(struct rtl2832_dev *dev, int reg, u32 *val)\n{\n\tstruct i2c_client *client = dev->client;\n\tint ret, i;\n\tu16 reg_start_addr;\n\tu8 msb, lsb, reading[4], len;\n\tu32 reading_tmp, mask;\n\n\treg_start_addr = registers[reg].start_address;\n\tmsb = registers[reg].msb;\n\tlsb = registers[reg].lsb;\n\tlen = (msb >> 3) + 1;\n\tmask = REG_MASK(msb - lsb);\n\n\tret = regmap_bulk_read(dev->regmap, reg_start_addr, reading, len);\n\tif (ret)\n\t\tgoto err;\n\n\treading_tmp = 0;\n\tfor (i = 0; i < len; i++)\n\t\treading_tmp |= reading[i] << ((len - 1 - i) * 8);\n\n\t*val = (reading_tmp >> lsb) & mask;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832_wr_demod_reg(struct rtl2832_dev *dev, int reg, u32 val)\n{\n\tstruct i2c_client *client = dev->client;\n\tint ret, i;\n\tu16 reg_start_addr;\n\tu8 msb, lsb, reading[4], writing[4], len;\n\tu32 reading_tmp, writing_tmp, mask;\n\n\treg_start_addr = registers[reg].start_address;\n\tmsb = registers[reg].msb;\n\tlsb = registers[reg].lsb;\n\tlen = (msb >> 3) + 1;\n\tmask = REG_MASK(msb - lsb);\n\n\tret = regmap_bulk_read(dev->regmap, reg_start_addr, reading, len);\n\tif (ret)\n\t\tgoto err;\n\n\treading_tmp = 0;\n\tfor (i = 0; i < len; i++)\n\t\treading_tmp |= reading[i] << ((len - 1 - i) * 8);\n\n\twriting_tmp = reading_tmp & ~(mask << lsb);\n\twriting_tmp |= ((val & mask) << lsb);\n\n\tfor (i = 0; i < len; i++)\n\t\twriting[i] = (writing_tmp >> ((len - 1 - i) * 8)) & 0xff;\n\n\tret = regmap_bulk_write(dev->regmap, reg_start_addr, writing, len);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832_set_if(struct dvb_frontend *fe, u32 if_freq)\n{\n\tstruct rtl2832_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu64 pset_iffreq;\n\tu8 en_bbin = (if_freq == 0 ? 0x1 : 0x0);\n\n\t \n\tpset_iffreq = if_freq % dev->pdata->clk;\n\tpset_iffreq *= 0x400000;\n\tpset_iffreq = div_u64(pset_iffreq, dev->pdata->clk);\n\tpset_iffreq = -pset_iffreq;\n\tpset_iffreq = pset_iffreq & 0x3fffff;\n\tdev_dbg(&client->dev, \"if_frequency=%d pset_iffreq=%08x\\n\",\n\t\tif_freq, (unsigned)pset_iffreq);\n\n\tret = rtl2832_wr_demod_reg(dev, DVBT_EN_BBIN, en_bbin);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl2832_wr_demod_reg(dev, DVBT_PSET_IFFREQ, pset_iffreq);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832_init(struct dvb_frontend *fe)\n{\n\tstruct rtl2832_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\n\tconst struct rtl2832_reg_value *init;\n\tint i, ret, len;\n\t \n\tstruct rtl2832_reg_value rtl2832_initial_regs[] = {\n\t\t{DVBT_AD_EN_REG,\t\t0x1},\n\t\t{DVBT_AD_EN_REG1,\t\t0x1},\n\t\t{DVBT_RSD_BER_FAIL_VAL,\t\t0x2800},\n\t\t{DVBT_MGD_THD0,\t\t\t0x10},\n\t\t{DVBT_MGD_THD1,\t\t\t0x20},\n\t\t{DVBT_MGD_THD2,\t\t\t0x20},\n\t\t{DVBT_MGD_THD3,\t\t\t0x40},\n\t\t{DVBT_MGD_THD4,\t\t\t0x22},\n\t\t{DVBT_MGD_THD5,\t\t\t0x32},\n\t\t{DVBT_MGD_THD6,\t\t\t0x37},\n\t\t{DVBT_MGD_THD7,\t\t\t0x39},\n\t\t{DVBT_EN_BK_TRK,\t\t0x0},\n\t\t{DVBT_EN_CACQ_NOTCH,\t\t0x0},\n\t\t{DVBT_AD_AV_REF,\t\t0x2a},\n\t\t{DVBT_REG_PI,\t\t\t0x6},\n\t\t{DVBT_PIP_ON,\t\t\t0x0},\n\t\t{DVBT_CDIV_PH0,\t\t\t0x8},\n\t\t{DVBT_CDIV_PH1,\t\t\t0x8},\n\t\t{DVBT_SCALE1_B92,\t\t0x4},\n\t\t{DVBT_SCALE1_B93,\t\t0xb0},\n\t\t{DVBT_SCALE1_BA7,\t\t0x78},\n\t\t{DVBT_SCALE1_BA9,\t\t0x28},\n\t\t{DVBT_SCALE1_BAA,\t\t0x59},\n\t\t{DVBT_SCALE1_BAB,\t\t0x83},\n\t\t{DVBT_SCALE1_BAC,\t\t0xd4},\n\t\t{DVBT_SCALE1_BB0,\t\t0x65},\n\t\t{DVBT_SCALE1_BB1,\t\t0x43},\n\t\t{DVBT_KB_P1,\t\t\t0x1},\n\t\t{DVBT_KB_P2,\t\t\t0x4},\n\t\t{DVBT_KB_P3,\t\t\t0x7},\n\t\t{DVBT_K1_CR_STEP12,\t\t0xa},\n\t\t{DVBT_REG_GPE,\t\t\t0x1},\n\t\t{DVBT_SERIAL,\t\t\t0x0},\n\t\t{DVBT_CDIV_PH0,\t\t\t0x9},\n\t\t{DVBT_CDIV_PH1,\t\t\t0x9},\n\t\t{DVBT_MPEG_IO_OPT_2_2,\t\t0x0},\n\t\t{DVBT_MPEG_IO_OPT_1_0,\t\t0x0},\n\t\t{DVBT_TRK_KS_P2,\t\t0x4},\n\t\t{DVBT_TRK_KS_I2,\t\t0x7},\n\t\t{DVBT_TR_THD_SET2,\t\t0x6},\n\t\t{DVBT_TRK_KC_I2,\t\t0x5},\n\t\t{DVBT_CR_THD_SET2,\t\t0x1},\n\t};\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x0);\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = 0; i < ARRAY_SIZE(rtl2832_initial_regs); i++) {\n\t\tret = rtl2832_wr_demod_reg(dev, rtl2832_initial_regs[i].reg,\n\t\t\trtl2832_initial_regs[i].value);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tdev_dbg(&client->dev, \"load settings for tuner=%02x\\n\",\n\t\tdev->pdata->tuner);\n\tswitch (dev->pdata->tuner) {\n\tcase RTL2832_TUNER_FC2580:\n\t\tlen = ARRAY_SIZE(rtl2832_tuner_init_fc2580);\n\t\tinit = rtl2832_tuner_init_fc2580;\n\t\tbreak;\n\tcase RTL2832_TUNER_FC0012:\n\tcase RTL2832_TUNER_FC0013:\n\t\tlen = ARRAY_SIZE(rtl2832_tuner_init_fc0012);\n\t\tinit = rtl2832_tuner_init_fc0012;\n\t\tbreak;\n\tcase RTL2832_TUNER_TUA9001:\n\t\tlen = ARRAY_SIZE(rtl2832_tuner_init_tua9001);\n\t\tinit = rtl2832_tuner_init_tua9001;\n\t\tbreak;\n\tcase RTL2832_TUNER_E4000:\n\t\tlen = ARRAY_SIZE(rtl2832_tuner_init_e4000);\n\t\tinit = rtl2832_tuner_init_e4000;\n\t\tbreak;\n\tcase RTL2832_TUNER_R820T:\n\tcase RTL2832_TUNER_R828D:\n\t\tlen = ARRAY_SIZE(rtl2832_tuner_init_r820t);\n\t\tinit = rtl2832_tuner_init_r820t;\n\t\tbreak;\n\tcase RTL2832_TUNER_SI2157:\n\t\tlen = ARRAY_SIZE(rtl2832_tuner_init_si2157);\n\t\tinit = rtl2832_tuner_init_si2157;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tret = rtl2832_wr_demod_reg(dev, init[i].reg, init[i].value);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tc->strength.len = 1;\n\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->cnr.len = 1;\n\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_error.len = 1;\n\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tc->post_bit_count.len = 1;\n\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tdev->sleeping = false;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832_sleep(struct dvb_frontend *fe)\n{\n\tstruct rtl2832_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tdev->sleeping = true;\n\tdev->fe_status = 0;\n\n\tret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x1);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832_get_tune_settings(struct dvb_frontend *fe,\n\tstruct dvb_frontend_tune_settings *s)\n{\n\tstruct rtl2832_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\ts->min_delay_ms = 1000;\n\ts->step_size = fe->ops.info.frequency_stepsize_hz * 2;\n\ts->max_drift = (fe->ops.info.frequency_stepsize_hz * 2) + 1;\n\treturn 0;\n}\n\nstatic int rtl2832_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct rtl2832_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret, i, j;\n\tu64 bw_mode, num, num2;\n\tu32 resamp_ratio, cfreq_off_ratio;\n\tstatic u8 bw_params[3][32] = {\n\t \n\t\t{\n\t\t0xf5, 0xff, 0x15, 0x38, 0x5d, 0x6d, 0x52, 0x07, 0xfa, 0x2f,\n\t\t0x53, 0xf5, 0x3f, 0xca, 0x0b, 0x91, 0xea, 0x30, 0x63, 0xb2,\n\t\t0x13, 0xda, 0x0b, 0xc4, 0x18, 0x7e, 0x16, 0x66, 0x08, 0x67,\n\t\t0x19, 0xe0,\n\t\t},\n\n\t \n\t\t{\n\t\t0xe7, 0xcc, 0xb5, 0xba, 0xe8, 0x2f, 0x67, 0x61, 0x00, 0xaf,\n\t\t0x86, 0xf2, 0xbf, 0x59, 0x04, 0x11, 0xb6, 0x33, 0xa4, 0x30,\n\t\t0x15, 0x10, 0x0a, 0x42, 0x18, 0xf8, 0x17, 0xd9, 0x07, 0x22,\n\t\t0x19, 0x10,\n\t\t},\n\n\t \n\t\t{\n\t\t0x09, 0xf6, 0xd2, 0xa7, 0x9a, 0xc9, 0x27, 0x77, 0x06, 0xbf,\n\t\t0xec, 0xf4, 0x4f, 0x0b, 0xfc, 0x01, 0x63, 0x35, 0x54, 0xa7,\n\t\t0x16, 0x66, 0x08, 0xb4, 0x19, 0x6e, 0x19, 0x65, 0x05, 0xc8,\n\t\t0x19, 0xe0,\n\t\t},\n\t};\n\n\tdev_dbg(&client->dev, \"frequency=%u bandwidth_hz=%u inversion=%u\\n\",\n\t\tc->frequency, c->bandwidth_hz, c->inversion);\n\n\t \n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\n\t \n\tif (fe->ops.tuner_ops.get_if_frequency) {\n\t\tu32 if_freq;\n\n\t\tret = fe->ops.tuner_ops.get_if_frequency(fe, &if_freq);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = rtl2832_set_if(fe, if_freq);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tswitch (c->bandwidth_hz) {\n\tcase 6000000:\n\t\ti = 0;\n\t\tbw_mode = 48000000;\n\t\tbreak;\n\tcase 7000000:\n\t\ti = 1;\n\t\tbw_mode = 56000000;\n\t\tbreak;\n\tcase 8000000:\n\t\ti = 2;\n\t\tbw_mode = 64000000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"invalid bandwidth_hz %u\\n\",\n\t\t\tc->bandwidth_hz);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tfor (j = 0; j < sizeof(bw_params[0]); j++) {\n\t\tret = regmap_bulk_write(dev->regmap,\n\t\t\t\t\t0x11c + j, &bw_params[i][j], 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tnum = dev->pdata->clk * 7ULL;\n\tnum *= 0x400000;\n\tnum = div_u64(num, bw_mode);\n\tresamp_ratio =  num & 0x3ffffff;\n\tret = rtl2832_wr_demod_reg(dev, DVBT_RSAMP_RATIO, resamp_ratio);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tnum = bw_mode << 20;\n\tnum2 = dev->pdata->clk * 7ULL;\n\tnum = div_u64(num, num2);\n\tnum = -num;\n\tcfreq_off_ratio = num & 0xfffff;\n\tret = rtl2832_wr_demod_reg(dev, DVBT_CFREQ_OFF_RATIO, cfreq_off_ratio);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x1);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x0);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *c)\n{\n\tstruct rtl2832_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu8 buf[3];\n\n\tif (dev->sleeping)\n\t\treturn 0;\n\n\tret = regmap_bulk_read(dev->regmap, 0x33c, buf, 2);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_bulk_read(dev->regmap, 0x351, &buf[2], 1);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_dbg(&client->dev, \"TPS=%*ph\\n\", 3, buf);\n\n\tswitch ((buf[0] >> 2) & 3) {\n\tcase 0:\n\t\tc->modulation = QPSK;\n\t\tbreak;\n\tcase 1:\n\t\tc->modulation = QAM_16;\n\t\tbreak;\n\tcase 2:\n\t\tc->modulation = QAM_64;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[2] >> 2) & 1) {\n\tcase 0:\n\t\tc->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n\tcase 1:\n\t\tc->transmission_mode = TRANSMISSION_MODE_8K;\n\t}\n\n\tswitch ((buf[2] >> 0) & 3) {\n\tcase 0:\n\t\tc->guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\tc->guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\tc->guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tc->guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[0] >> 4) & 7) {\n\tcase 0:\n\t\tc->hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tc->hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tcase 2:\n\t\tc->hierarchy = HIERARCHY_2;\n\t\tbreak;\n\tcase 3:\n\t\tc->hierarchy = HIERARCHY_4;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[1] >> 3) & 7) {\n\tcase 0:\n\t\tc->code_rate_HP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tc->code_rate_HP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tc->code_rate_HP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tc->code_rate_HP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tc->code_rate_HP = FEC_7_8;\n\t\tbreak;\n\t}\n\n\tswitch ((buf[1] >> 0) & 7) {\n\tcase 0:\n\t\tc->code_rate_LP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tc->code_rate_LP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tc->code_rate_LP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tc->code_rate_LP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tc->code_rate_LP = FEC_7_8;\n\t\tbreak;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct rtl2832_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tint ret;\n\tu32 tmp;\n\tu8 u8tmp, buf[2];\n\tu16 u16tmp;\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t*status = 0;\n\tif (dev->sleeping)\n\t\treturn 0;\n\n\tret = rtl2832_rd_demod_reg(dev, DVBT_FSM_STAGE, &tmp);\n\tif (ret)\n\t\tgoto err;\n\n\tif (tmp == 11) {\n\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\tFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\n\t} else if (tmp == 10) {\n\t\t*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\n\t\t\t\tFE_HAS_VITERBI;\n\t}\n\n\tdev->fe_status = *status;\n\n\t \n\tif (dev->fe_status & FE_HAS_SIGNAL) {\n\t\t \n\t\tret = regmap_bulk_read(dev->regmap, 0x305, &u8tmp, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdev_dbg(&client->dev, \"digital agc=%02x\", u8tmp);\n\n\t\tu8tmp = ~u8tmp;\n\t\tu16tmp = u8tmp << 8 | u8tmp << 0;\n\n\t\tc->strength.stat[0].scale = FE_SCALE_RELATIVE;\n\t\tc->strength.stat[0].uvalue = u16tmp;\n\t} else {\n\t\tc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (dev->fe_status & FE_HAS_VITERBI) {\n\t\tunsigned hierarchy, constellation;\n\t\t#define CONSTELLATION_NUM 3\n\t\t#define HIERARCHY_NUM 4\n\t\tstatic const u32 constant[CONSTELLATION_NUM][HIERARCHY_NUM] = {\n\t\t\t{85387325, 85387325, 85387325, 85387325},\n\t\t\t{86676178, 86676178, 87167949, 87795660},\n\t\t\t{87659938, 87659938, 87885178, 88241743},\n\t\t};\n\n\t\tret = regmap_bulk_read(dev->regmap, 0x33c, &u8tmp, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tconstellation = (u8tmp >> 2) & 0x03;  \n\t\tret = -EINVAL;\n\t\tif (constellation > CONSTELLATION_NUM - 1)\n\t\t\tgoto err;\n\n\t\thierarchy = (u8tmp >> 4) & 0x07;  \n\t\tif (hierarchy > HIERARCHY_NUM - 1)\n\t\t\tgoto err;\n\n\t\tret = regmap_bulk_read(dev->regmap, 0x40c, buf, 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tu16tmp = buf[0] << 8 | buf[1] << 0;\n\t\tif (u16tmp)\n\t\t\ttmp = (constant[constellation][hierarchy] -\n\t\t\t       intlog10(u16tmp)) / ((1 << 24) / 10000);\n\t\telse\n\t\t\ttmp = 0;\n\n\t\tdev_dbg(&client->dev, \"cnr raw=%u\\n\", u16tmp);\n\n\t\tc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tc->cnr.stat[0].svalue = tmp;\n\t} else {\n\t\tc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\t \n\tif (dev->fe_status & FE_HAS_LOCK) {\n\t\tret = regmap_bulk_read(dev->regmap, 0x34e, buf, 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tu16tmp = buf[0] << 8 | buf[1] << 0;\n\t\tdev->post_bit_error += u16tmp;\n\t\tdev->post_bit_count += 1000000;\n\n\t\tdev_dbg(&client->dev, \"ber errors=%u total=1000000\\n\", u16tmp);\n\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\t\tc->post_bit_count.stat[0].uvalue = dev->post_bit_count;\n\t} else {\n\t\tc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\n\t \n\tif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL)\n\t\t*snr = div_s64(c->cnr.stat[0].svalue, 100);\n\telse\n\t\t*snr = 0;\n\n\treturn 0;\n}\n\nstatic int rtl2832_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\tstruct rtl2832_dev *dev = fe->demodulator_priv;\n\n\t*ber = (dev->post_bit_error - dev->post_bit_error_prev);\n\tdev->post_bit_error_prev = dev->post_bit_error;\n\n\treturn 0;\n}\n\n \nstatic void rtl2832_i2c_gate_work(struct work_struct *work)\n{\n\tstruct rtl2832_dev *dev = container_of(work, struct rtl2832_dev, i2c_gate_work.work);\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(dev->regmap, 0x101, 0x08, 0x00);\n\tif (ret)\n\t\tgoto err;\n\n\treturn;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n}\n\nstatic int rtl2832_select(struct i2c_mux_core *muxc, u32 chan_id)\n{\n\tstruct rtl2832_dev *dev = i2c_mux_priv(muxc);\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\n\t \n\tcancel_delayed_work(&dev->i2c_gate_work);\n\n\t \n\tret = regmap_update_bits(dev->regmap, 0x101, 0x08, 0x08);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832_deselect(struct i2c_mux_core *muxc, u32 chan_id)\n{\n\tstruct rtl2832_dev *dev = i2c_mux_priv(muxc);\n\n\tschedule_delayed_work(&dev->i2c_gate_work, usecs_to_jiffies(100));\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops rtl2832_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name = \"Realtek RTL2832 (DVB-T)\",\n\t\t.frequency_min_hz\t= 174 * MHz,\n\t\t.frequency_max_hz\t= 862 * MHz,\n\t\t.frequency_stepsize_hz\t= 166667,\n\t\t.caps = FE_CAN_FEC_1_2 |\n\t\t\tFE_CAN_FEC_2_3 |\n\t\t\tFE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 |\n\t\t\tFE_CAN_FEC_7_8 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK |\n\t\t\tFE_CAN_QAM_16 |\n\t\t\tFE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO |\n\t\t\tFE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO |\n\t\t\tFE_CAN_RECOVER |\n\t\t\tFE_CAN_MUTE_TS\n\t },\n\n\t.init = rtl2832_init,\n\t.sleep = rtl2832_sleep,\n\n\t.get_tune_settings = rtl2832_get_tune_settings,\n\n\t.set_frontend = rtl2832_set_frontend,\n\t.get_frontend = rtl2832_get_frontend,\n\n\t.read_status = rtl2832_read_status,\n\t.read_snr = rtl2832_read_snr,\n\t.read_ber = rtl2832_read_ber,\n};\n\nstatic bool rtl2832_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x305:\n\tcase 0x33c:\n\tcase 0x34e:\n\tcase 0x351:\n\tcase 0x40c ... 0x40d:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic struct dvb_frontend *rtl2832_get_dvb_frontend(struct i2c_client *client)\n{\n\tstruct rtl2832_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\treturn &dev->fe;\n}\n\nstatic struct i2c_adapter *rtl2832_get_i2c_adapter(struct i2c_client *client)\n{\n\tstruct rtl2832_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\treturn dev->muxc->adapter[0];\n}\n\nstatic int rtl2832_slave_ts_ctrl(struct i2c_client *client, bool enable)\n{\n\tstruct rtl2832_dev *dev = i2c_get_clientdata(client);\n\tint ret;\n\n\tdev_dbg(&client->dev, \"enable=%d\\n\", enable);\n\n\tif (enable) {\n\t\tret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_bulk_write(dev->regmap, 0x10c, \"\\x5f\\xff\", 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = rtl2832_wr_demod_reg(dev, DVBT_PIP_ON, 0x1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_bulk_write(dev->regmap, 0x0bc, \"\\x18\", 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_bulk_write(dev->regmap, 0x192, \"\\x7f\\xf7\\xff\", 3);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tret = regmap_bulk_write(dev->regmap, 0x192, \"\\x00\\x0f\\xff\", 3);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_bulk_write(dev->regmap, 0x0bc, \"\\x08\", 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = rtl2832_wr_demod_reg(dev, DVBT_PIP_ON, 0x0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_bulk_write(dev->regmap, 0x10c, \"\\x00\\x00\", 2);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tdev->slave_ts = enable;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)\n{\n\tstruct rtl2832_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu8 u8tmp;\n\n\tdev_dbg(&client->dev, \"onoff=%d, slave_ts=%d\\n\", onoff, dev->slave_ts);\n\n\t \n\tif (onoff)\n\t\tu8tmp = 0x80;\n\telse\n\t\tu8tmp = 0x00;\n\n\tif (dev->slave_ts)\n\t\tret = regmap_update_bits(dev->regmap, 0x021, 0xc0, u8tmp);\n\telse\n\t\tret = regmap_update_bits(dev->regmap, 0x061, 0xc0, u8tmp);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid,\n\t\t\t      int onoff)\n{\n\tstruct rtl2832_dev *dev = fe->demodulator_priv;\n\tstruct i2c_client *client = dev->client;\n\tint ret;\n\tu8 buf[4];\n\n\tdev_dbg(&client->dev, \"index=%d pid=%04x onoff=%d slave_ts=%d\\n\",\n\t\tindex, pid, onoff, dev->slave_ts);\n\n\t \n\tif (pid > 0x1fff || index > 32)\n\t\treturn 0;\n\n\tif (onoff)\n\t\tset_bit(index, &dev->filters);\n\telse\n\t\tclear_bit(index, &dev->filters);\n\n\t \n\tbuf[0] = (dev->filters >>  0) & 0xff;\n\tbuf[1] = (dev->filters >>  8) & 0xff;\n\tbuf[2] = (dev->filters >> 16) & 0xff;\n\tbuf[3] = (dev->filters >> 24) & 0xff;\n\n\tif (dev->slave_ts)\n\t\tret = regmap_bulk_write(dev->regmap, 0x022, buf, 4);\n\telse\n\t\tret = regmap_bulk_write(dev->regmap, 0x062, buf, 4);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tbuf[0] = (pid >> 8) & 0xff;\n\tbuf[1] = (pid >> 0) & 0xff;\n\n\tif (dev->slave_ts)\n\t\tret = regmap_bulk_write(dev->regmap, 0x026 + 2 * index, buf, 2);\n\telse\n\t\tret = regmap_bulk_write(dev->regmap, 0x066 + 2 * index, buf, 2);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int rtl2832_probe(struct i2c_client *client)\n{\n\tstruct rtl2832_platform_data *pdata = client->dev.platform_data;\n\tstruct i2c_adapter *i2c = client->adapter;\n\tstruct rtl2832_dev *dev;\n\tint ret;\n\tu8 tmp;\n\tstatic const struct regmap_range_cfg regmap_range_cfg[] = {\n\t\t{\n\t\t\t.selector_reg     = 0x00,\n\t\t\t.selector_mask    = 0xff,\n\t\t\t.selector_shift   = 0,\n\t\t\t.window_start     = 0,\n\t\t\t.window_len       = 0x100,\n\t\t\t.range_min        = 0 * 0x100,\n\t\t\t.range_max        = 5 * 0x100,\n\t\t},\n\t};\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\t \n\tdev = kzalloc(sizeof(struct rtl2832_dev), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\ti2c_set_clientdata(client, dev);\n\tdev->client = client;\n\tdev->pdata = client->dev.platform_data;\n\tdev->sleeping = true;\n\tINIT_DELAYED_WORK(&dev->i2c_gate_work, rtl2832_i2c_gate_work);\n\t \n\tdev->regmap_config.reg_bits =  8;\n\tdev->regmap_config.val_bits =  8;\n\tdev->regmap_config.volatile_reg = rtl2832_volatile_reg;\n\tdev->regmap_config.max_register = 5 * 0x100;\n\tdev->regmap_config.ranges = regmap_range_cfg;\n\tdev->regmap_config.num_ranges = ARRAY_SIZE(regmap_range_cfg);\n\tdev->regmap_config.cache_type = REGCACHE_NONE;\n\tdev->regmap = regmap_init_i2c(client, &dev->regmap_config);\n\tif (IS_ERR(dev->regmap)) {\n\t\tret = PTR_ERR(dev->regmap);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tret = regmap_bulk_read(dev->regmap, 0x000, &tmp, 1);\n\tif (ret)\n\t\tgoto err_regmap_exit;\n\n\t \n\tdev->muxc = i2c_mux_alloc(i2c, &i2c->dev, 1, 0, I2C_MUX_LOCKED,\n\t\t\t\t  rtl2832_select, rtl2832_deselect);\n\tif (!dev->muxc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_regmap_exit;\n\t}\n\tdev->muxc->priv = dev;\n\tret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);\n\tif (ret)\n\t\tgoto err_regmap_exit;\n\n\t \n\tmemcpy(&dev->fe.ops, &rtl2832_ops, sizeof(struct dvb_frontend_ops));\n\tdev->fe.demodulator_priv = dev;\n\n\t \n\tpdata->get_dvb_frontend = rtl2832_get_dvb_frontend;\n\tpdata->get_i2c_adapter = rtl2832_get_i2c_adapter;\n\tpdata->slave_ts_ctrl = rtl2832_slave_ts_ctrl;\n\tpdata->pid_filter = rtl2832_pid_filter;\n\tpdata->pid_filter_ctrl = rtl2832_pid_filter_ctrl;\n\tpdata->regmap = dev->regmap;\n\n\tdev_info(&client->dev, \"Realtek RTL2832 successfully attached\\n\");\n\treturn 0;\nerr_regmap_exit:\n\tregmap_exit(dev->regmap);\nerr_kfree:\n\tkfree(dev);\nerr:\n\tdev_dbg(&client->dev, \"failed=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void rtl2832_remove(struct i2c_client *client)\n{\n\tstruct rtl2832_dev *dev = i2c_get_clientdata(client);\n\n\tdev_dbg(&client->dev, \"\\n\");\n\n\tcancel_delayed_work_sync(&dev->i2c_gate_work);\n\n\ti2c_mux_del_adapters(dev->muxc);\n\n\tregmap_exit(dev->regmap);\n\n\tkfree(dev);\n}\n\nstatic const struct i2c_device_id rtl2832_id_table[] = {\n\t{\"rtl2832\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, rtl2832_id_table);\n\nstatic struct i2c_driver rtl2832_driver = {\n\t.driver = {\n\t\t.name\t= \"rtl2832\",\n\t\t.suppress_bind_attrs\t= true,\n\t},\n\t.probe\t\t= rtl2832_probe,\n\t.remove\t\t= rtl2832_remove,\n\t.id_table\t= rtl2832_id_table,\n};\n\nmodule_i2c_driver(rtl2832_driver);\n\nMODULE_AUTHOR(\"Thomas Mair <mair.thomas86@gmail.com>\");\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"Realtek RTL2832 DVB-T demodulator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}