{
  "module_name": "s5h1420.c",
  "hash_id": "634ffe50823bd8c27f0c9d87767938f9d2ff822045a712c009259a2d37ad639f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/s5h1420.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <asm/div64.h>\n\n#include <linux/i2c.h>\n\n\n#include <media/dvb_frontend.h>\n#include \"s5h1420.h\"\n#include \"s5h1420_priv.h\"\n\n#define TONE_FREQ 22000\n\nstruct s5h1420_state {\n\tstruct i2c_adapter* i2c;\n\tconst struct s5h1420_config* config;\n\n\tstruct dvb_frontend frontend;\n\tstruct i2c_adapter tuner_i2c_adapter;\n\n\tu8 CON_1_val;\n\n\tu8 postlocked:1;\n\tu32 fclk;\n\tu32 tunedfreq;\n\tenum fe_code_rate fec_inner;\n\tu32 symbol_rate;\n\n\t \n\tu8 shadow[256];\n};\n\nstatic u32 s5h1420_getsymbolrate(struct s5h1420_state* state);\nstatic int s5h1420_get_tune_settings(struct dvb_frontend* fe,\n\t\t\t\t     struct dvb_frontend_tune_settings* fesettings);\n\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debugging\");\n\n#define dprintk(x...) do { \\\n\tif (debug) \\\n\t\tprintk(KERN_DEBUG \"S5H1420: \" x); \\\n} while (0)\n\nstatic u8 s5h1420_readreg(struct s5h1420_state *state, u8 reg)\n{\n\tint ret;\n\tu8 b[2];\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = state->config->demod_address, .flags = 0, .buf = b, .len = 2 },\n\t\t{ .addr = state->config->demod_address, .flags = 0, .buf = &reg, .len = 1 },\n\t\t{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b, .len = 1 },\n\t};\n\n\tb[0] = (reg - 1) & 0xff;\n\tb[1] = state->shadow[(reg - 1) & 0xff];\n\n\tif (state->config->repeated_start_workaround) {\n\t\tret = i2c_transfer(state->i2c, msg, 3);\n\t\tif (ret != 3)\n\t\t\treturn ret;\n\t} else {\n\t\tret = i2c_transfer(state->i2c, &msg[1], 1);\n\t\tif (ret != 1)\n\t\t\treturn ret;\n\t\tret = i2c_transfer(state->i2c, &msg[2], 1);\n\t\tif (ret != 1)\n\t\t\treturn ret;\n\t}\n\n\t \n\n\treturn b[0];\n}\n\nstatic int s5h1420_writereg (struct s5h1420_state* state, u8 reg, u8 data)\n{\n\tu8 buf[] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\n\tint err;\n\n\t \n\terr = i2c_transfer(state->i2c, &msg, 1);\n\tif (err != 1) {\n\t\tdprintk(\"%s: writereg error (err == %i, reg == 0x%02x, data == 0x%02x)\\n\", __func__, err, reg, data);\n\t\treturn -EREMOTEIO;\n\t}\n\tstate->shadow[reg] = data;\n\n\treturn 0;\n}\n\nstatic int s5h1420_set_voltage(struct dvb_frontend *fe,\n\t\t\t       enum fe_sec_voltage voltage)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\n\tdprintk(\"enter %s\\n\", __func__);\n\n\tswitch(voltage) {\n\tcase SEC_VOLTAGE_13:\n\t\ts5h1420_writereg(state, 0x3c,\n\t\t\t\t (s5h1420_readreg(state, 0x3c) & 0xfe) | 0x02);\n\t\tbreak;\n\n\tcase SEC_VOLTAGE_18:\n\t\ts5h1420_writereg(state, 0x3c, s5h1420_readreg(state, 0x3c) | 0x03);\n\t\tbreak;\n\n\tcase SEC_VOLTAGE_OFF:\n\t\ts5h1420_writereg(state, 0x3c, s5h1420_readreg(state, 0x3c) & 0xfd);\n\t\tbreak;\n\t}\n\n\tdprintk(\"leave %s\\n\", __func__);\n\treturn 0;\n}\n\nstatic int s5h1420_set_tone(struct dvb_frontend *fe,\n\t\t\t    enum fe_sec_tone_mode tone)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\n\tdprintk(\"enter %s\\n\", __func__);\n\tswitch(tone) {\n\tcase SEC_TONE_ON:\n\t\ts5h1420_writereg(state, 0x3b,\n\t\t\t\t (s5h1420_readreg(state, 0x3b) & 0x74) | 0x08);\n\t\tbreak;\n\n\tcase SEC_TONE_OFF:\n\t\ts5h1420_writereg(state, 0x3b,\n\t\t\t\t (s5h1420_readreg(state, 0x3b) & 0x74) | 0x01);\n\t\tbreak;\n\t}\n\tdprintk(\"leave %s\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic int s5h1420_send_master_cmd (struct dvb_frontend* fe,\n\t\t\t\t    struct dvb_diseqc_master_cmd* cmd)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\tu8 val;\n\tint i;\n\tunsigned long timeout;\n\tint result = 0;\n\n\tdprintk(\"enter %s\\n\", __func__);\n\tif (cmd->msg_len > sizeof(cmd->msg))\n\t\treturn -EINVAL;\n\n\t \n\tval = s5h1420_readreg(state, 0x3b);\n\ts5h1420_writereg(state, 0x3b, 0x02);\n\tmsleep(15);\n\n\t \n\tfor(i=0; i< cmd->msg_len; i++) {\n\t\ts5h1420_writereg(state, 0x3d + i, cmd->msg[i]);\n\t}\n\n\t \n\ts5h1420_writereg(state, 0x3b, s5h1420_readreg(state, 0x3b) |\n\t\t\t\t      ((cmd->msg_len-1) << 4) | 0x08);\n\n\t \n\ttimeout = jiffies + ((100*HZ) / 1000);\n\twhile(time_before(jiffies, timeout)) {\n\t\tif (!(s5h1420_readreg(state, 0x3b) & 0x08))\n\t\t\tbreak;\n\n\t\tmsleep(5);\n\t}\n\tif (time_after(jiffies, timeout))\n\t\tresult = -ETIMEDOUT;\n\n\t \n\ts5h1420_writereg(state, 0x3b, val);\n\tmsleep(15);\n\tdprintk(\"leave %s\\n\", __func__);\n\treturn result;\n}\n\nstatic int s5h1420_recv_slave_reply (struct dvb_frontend* fe,\n\t\t\t\t     struct dvb_diseqc_slave_reply* reply)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\tu8 val;\n\tint i;\n\tint length;\n\tunsigned long timeout;\n\tint result = 0;\n\n\t \n\tval = s5h1420_readreg(state, 0x3b);\n\ts5h1420_writereg(state, 0x3b, 0x82);  \n\tmsleep(15);\n\n\t \n\ttimeout = jiffies + ((reply->timeout*HZ) / 1000);\n\twhile(time_before(jiffies, timeout)) {\n\t\tif (!(s5h1420_readreg(state, 0x3b) & 0x80))  \n\t\t\tbreak;\n\n\t\tmsleep(5);\n\t}\n\tif (time_after(jiffies, timeout)) {\n\t\tresult = -ETIMEDOUT;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (s5h1420_readreg(state, 0x49)) {\n\t\tresult = -EIO;\n\t\tgoto exit;\n\t}\n\n\t \n\tlength = (s5h1420_readreg(state, 0x3b) & 0x70) >> 4;\n\tif (length > sizeof(reply->msg)) {\n\t\tresult = -EOVERFLOW;\n\t\tgoto exit;\n\t}\n\treply->msg_len = length;\n\n\t \n\tfor(i=0; i< length; i++) {\n\t\treply->msg[i] = s5h1420_readreg(state, 0x3d + i);\n\t}\n\nexit:\n\t \n\ts5h1420_writereg(state, 0x3b, val);\n\tmsleep(15);\n\treturn result;\n}\n\nstatic int s5h1420_send_burst(struct dvb_frontend *fe,\n\t\t\t      enum fe_sec_mini_cmd minicmd)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\tu8 val;\n\tint result = 0;\n\tunsigned long timeout;\n\n\t \n\tval = s5h1420_readreg(state, 0x3b);\n\ts5h1420_writereg(state, 0x3b, (s5h1420_readreg(state, 0x3b) & 0x70) | 0x01);\n\n\t \n\tif (minicmd == SEC_MINI_B) {\n\t\ts5h1420_writereg(state, 0x3b, s5h1420_readreg(state, 0x3b) | 0x04);\n\t}\n\tmsleep(15);\n\n\t \n\ts5h1420_writereg(state, 0x3b, s5h1420_readreg(state, 0x3b) | 0x08);\n\n\t \n\ttimeout = jiffies + ((100*HZ) / 1000);\n\twhile(time_before(jiffies, timeout)) {\n\t\tif (!(s5h1420_readreg(state, 0x3b) & 0x08))\n\t\t\tbreak;\n\n\t\tmsleep(5);\n\t}\n\tif (time_after(jiffies, timeout))\n\t\tresult = -ETIMEDOUT;\n\n\t \n\ts5h1420_writereg(state, 0x3b, val);\n\tmsleep(15);\n\treturn result;\n}\n\nstatic enum fe_status s5h1420_get_status_bits(struct s5h1420_state *state)\n{\n\tu8 val;\n\tenum fe_status status = 0;\n\n\tval = s5h1420_readreg(state, 0x14);\n\tif (val & 0x02)\n\t\tstatus |=  FE_HAS_SIGNAL;\n\tif (val & 0x01)\n\t\tstatus |=  FE_HAS_CARRIER;\n\tval = s5h1420_readreg(state, 0x36);\n\tif (val & 0x01)\n\t\tstatus |=  FE_HAS_VITERBI;\n\tif (val & 0x20)\n\t\tstatus |=  FE_HAS_SYNC;\n\tif (status == (FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC))\n\t\tstatus |=  FE_HAS_LOCK;\n\n\treturn status;\n}\n\nstatic int s5h1420_read_status(struct dvb_frontend *fe,\n\t\t\t       enum fe_status *status)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\tu8 val;\n\n\tdprintk(\"enter %s\\n\", __func__);\n\n\tif (status == NULL)\n\t\treturn -EINVAL;\n\n\t \n\t*status = s5h1420_get_status_bits(state);\n\n\t \n\tif (*status == (FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI)) {\n\t\tval = s5h1420_readreg(state, Vit10);\n\t\tif ((val & 0x07) == 0x03) {\n\t\t\tif (val & 0x08)\n\t\t\t\ts5h1420_writereg(state, Vit09, 0x13);\n\t\t\telse\n\t\t\t\ts5h1420_writereg(state, Vit09, 0x1b);\n\n\t\t\t \n\t\t\tmdelay(200);\n\t\t\t*status = s5h1420_get_status_bits(state);\n\t\t}\n\t}\n\n\t \n\tif ((*status & FE_HAS_LOCK) && !state->postlocked) {\n\n\t\t \n\t\tu32 tmp = s5h1420_getsymbolrate(state);\n\t\tswitch (s5h1420_readreg(state, Vit10) & 0x07) {\n\t\tcase 0: tmp = (tmp * 2 * 1) / 2; break;\n\t\tcase 1: tmp = (tmp * 2 * 2) / 3; break;\n\t\tcase 2: tmp = (tmp * 2 * 3) / 4; break;\n\t\tcase 3: tmp = (tmp * 2 * 5) / 6; break;\n\t\tcase 4: tmp = (tmp * 2 * 6) / 7; break;\n\t\tcase 5: tmp = (tmp * 2 * 7) / 8; break;\n\t\t}\n\n\t\tif (tmp == 0) {\n\t\t\tprintk(KERN_ERR \"s5h1420: avoided division by 0\\n\");\n\t\t\ttmp = 1;\n\t\t}\n\t\ttmp = state->fclk / tmp;\n\n\n\t\t \n\t\tif (tmp < 2)\n\t\t\tval = 0x00;\n\t\telse if (tmp < 5)\n\t\t\tval = 0x01;\n\t\telse if (tmp < 9)\n\t\t\tval = 0x02;\n\t\telse if (tmp < 13)\n\t\t\tval = 0x03;\n\t\telse if (tmp < 17)\n\t\t\tval = 0x04;\n\t\telse if (tmp < 25)\n\t\t\tval = 0x05;\n\t\telse if (tmp < 33)\n\t\t\tval = 0x06;\n\t\telse\n\t\t\tval = 0x07;\n\t\tdprintk(\"for MPEG_CLK_INTL %d %x\\n\", tmp, val);\n\n\t\ts5h1420_writereg(state, FEC01, 0x18);\n\t\ts5h1420_writereg(state, FEC01, 0x10);\n\t\ts5h1420_writereg(state, FEC01, val);\n\n\t\t \n\t\tval = s5h1420_readreg(state, Mpeg02);\n\t\ts5h1420_writereg(state, Mpeg02, val | (1 << 6));\n\n\t\t \n\t\tval = s5h1420_readreg(state, QPSK01) & 0x7f;\n\t\ts5h1420_writereg(state, QPSK01, val);\n\n\t\t \n\n\t\tif (s5h1420_getsymbolrate(state) >= 20000000) {\n\t\t\ts5h1420_writereg(state, Loop04, 0x8a);\n\t\t\ts5h1420_writereg(state, Loop05, 0x6a);\n\t\t} else {\n\t\t\ts5h1420_writereg(state, Loop04, 0x58);\n\t\t\ts5h1420_writereg(state, Loop05, 0x27);\n\t\t}\n\n\t\t \n\t\tstate->postlocked = 1;\n\t}\n\n\tdprintk(\"leave %s\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic int s5h1420_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\n\ts5h1420_writereg(state, 0x46, 0x1d);\n\tmdelay(25);\n\n\t*ber = (s5h1420_readreg(state, 0x48) << 8) | s5h1420_readreg(state, 0x47);\n\n\treturn 0;\n}\n\nstatic int s5h1420_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\n\tu8 val = s5h1420_readreg(state, 0x15);\n\n\t*strength =  (u16) ((val << 8) | val);\n\n\treturn 0;\n}\n\nstatic int s5h1420_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\n\ts5h1420_writereg(state, 0x46, 0x1f);\n\tmdelay(25);\n\n\t*ucblocks = (s5h1420_readreg(state, 0x48) << 8) | s5h1420_readreg(state, 0x47);\n\n\treturn 0;\n}\n\nstatic void s5h1420_reset(struct s5h1420_state* state)\n{\n\tdprintk(\"%s\\n\", __func__);\n\ts5h1420_writereg (state, 0x01, 0x08);\n\ts5h1420_writereg (state, 0x01, 0x00);\n\tudelay(10);\n}\n\nstatic void s5h1420_setsymbolrate(struct s5h1420_state* state,\n\t\t\t\t  struct dtv_frontend_properties *p)\n{\n\tu8 v;\n\tu64 val;\n\n\tdprintk(\"enter %s\\n\", __func__);\n\n\tval = ((u64) p->symbol_rate / 1000ULL) * (1ULL<<24);\n\tif (p->symbol_rate < 29000000)\n\t\tval *= 2;\n\tdo_div(val, (state->fclk / 1000));\n\n\tdprintk(\"symbol rate register: %06llx\\n\", (unsigned long long)val);\n\n\tv = s5h1420_readreg(state, Loop01);\n\ts5h1420_writereg(state, Loop01, v & 0x7f);\n\ts5h1420_writereg(state, Tnco01, val >> 16);\n\ts5h1420_writereg(state, Tnco02, val >> 8);\n\ts5h1420_writereg(state, Tnco03, val & 0xff);\n\ts5h1420_writereg(state, Loop01,  v | 0x80);\n\tdprintk(\"leave %s\\n\", __func__);\n}\n\nstatic u32 s5h1420_getsymbolrate(struct s5h1420_state* state)\n{\n\treturn state->symbol_rate;\n}\n\nstatic void s5h1420_setfreqoffset(struct s5h1420_state* state, int freqoffset)\n{\n\tint val;\n\tu8 v;\n\n\tdprintk(\"enter %s\\n\", __func__);\n\n\t \n\tval = -(int) ((freqoffset * (1<<24)) / (state->fclk / 1000000));\n\n\tdprintk(\"phase rotator/freqoffset: %d %06x\\n\", freqoffset, val);\n\n\tv = s5h1420_readreg(state, Loop01);\n\ts5h1420_writereg(state, Loop01, v & 0xbf);\n\ts5h1420_writereg(state, Pnco01, val >> 16);\n\ts5h1420_writereg(state, Pnco02, val >> 8);\n\ts5h1420_writereg(state, Pnco03, val & 0xff);\n\ts5h1420_writereg(state, Loop01, v | 0x40);\n\tdprintk(\"leave %s\\n\", __func__);\n}\n\nstatic int s5h1420_getfreqoffset(struct s5h1420_state* state)\n{\n\tint val;\n\n\ts5h1420_writereg(state, 0x06, s5h1420_readreg(state, 0x06) | 0x08);\n\tval  = s5h1420_readreg(state, 0x0e) << 16;\n\tval |= s5h1420_readreg(state, 0x0f) << 8;\n\tval |= s5h1420_readreg(state, 0x10);\n\ts5h1420_writereg(state, 0x06, s5h1420_readreg(state, 0x06) & 0xf7);\n\n\tif (val & 0x800000)\n\t\tval |= 0xff000000;\n\n\t \n\tval = (((-val) * (state->fclk/1000000)) / (1<<24));\n\n\treturn val;\n}\n\nstatic void s5h1420_setfec_inversion(struct s5h1420_state* state,\n\t\t\t\t     struct dtv_frontend_properties *p)\n{\n\tu8 inversion = 0;\n\tu8 vit08, vit09;\n\n\tdprintk(\"enter %s\\n\", __func__);\n\n\tif (p->inversion == INVERSION_OFF)\n\t\tinversion = state->config->invert ? 0x08 : 0;\n\telse if (p->inversion == INVERSION_ON)\n\t\tinversion = state->config->invert ? 0 : 0x08;\n\n\tif ((p->fec_inner == FEC_AUTO) || (p->inversion == INVERSION_AUTO)) {\n\t\tvit08 = 0x3f;\n\t\tvit09 = 0;\n\t} else {\n\t\tswitch (p->fec_inner) {\n\t\tcase FEC_1_2:\n\t\t\tvit08 = 0x01;\n\t\t\tvit09 = 0x10;\n\t\t\tbreak;\n\n\t\tcase FEC_2_3:\n\t\t\tvit08 = 0x02;\n\t\t\tvit09 = 0x11;\n\t\t\tbreak;\n\n\t\tcase FEC_3_4:\n\t\t\tvit08 = 0x04;\n\t\t\tvit09 = 0x12;\n\t\t\tbreak;\n\n\t\tcase FEC_5_6:\n\t\t\tvit08 = 0x08;\n\t\t\tvit09 = 0x13;\n\t\t\tbreak;\n\n\t\tcase FEC_6_7:\n\t\t\tvit08 = 0x10;\n\t\t\tvit09 = 0x14;\n\t\t\tbreak;\n\n\t\tcase FEC_7_8:\n\t\t\tvit08 = 0x20;\n\t\t\tvit09 = 0x15;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t}\n\tvit09 |= inversion;\n\tdprintk(\"fec: %02x %02x\\n\", vit08, vit09);\n\ts5h1420_writereg(state, Vit08, vit08);\n\ts5h1420_writereg(state, Vit09, vit09);\n\tdprintk(\"leave %s\\n\", __func__);\n}\n\nstatic enum fe_code_rate s5h1420_getfec(struct s5h1420_state *state)\n{\n\tswitch(s5h1420_readreg(state, 0x32) & 0x07) {\n\tcase 0:\n\t\treturn FEC_1_2;\n\n\tcase 1:\n\t\treturn FEC_2_3;\n\n\tcase 2:\n\t\treturn FEC_3_4;\n\n\tcase 3:\n\t\treturn FEC_5_6;\n\n\tcase 4:\n\t\treturn FEC_6_7;\n\n\tcase 5:\n\t\treturn FEC_7_8;\n\t}\n\n\treturn FEC_NONE;\n}\n\nstatic enum fe_spectral_inversion\ns5h1420_getinversion(struct s5h1420_state *state)\n{\n\tif (s5h1420_readreg(state, 0x32) & 0x08)\n\t\treturn INVERSION_ON;\n\n\treturn INVERSION_OFF;\n}\n\nstatic int s5h1420_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\tint frequency_delta;\n\tstruct dvb_frontend_tune_settings fesettings;\n\n\tdprintk(\"enter %s\\n\", __func__);\n\n\t \n\ts5h1420_get_tune_settings(fe, &fesettings);\n\tfrequency_delta = p->frequency - state->tunedfreq;\n\tif ((frequency_delta > -fesettings.max_drift) &&\n\t\t\t(frequency_delta < fesettings.max_drift) &&\n\t\t\t(frequency_delta != 0) &&\n\t\t\t(state->fec_inner == p->fec_inner) &&\n\t\t\t(state->symbol_rate == p->symbol_rate)) {\n\n\t\tif (fe->ops.tuner_ops.set_params) {\n\t\t\tfe->ops.tuner_ops.set_params(fe);\n\t\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t\t}\n\t\tif (fe->ops.tuner_ops.get_frequency) {\n\t\t\tu32 tmp;\n\t\t\tfe->ops.tuner_ops.get_frequency(fe, &tmp);\n\t\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t\t\ts5h1420_setfreqoffset(state, p->frequency - tmp);\n\t\t} else {\n\t\t\ts5h1420_setfreqoffset(state, 0);\n\t\t}\n\t\tdprintk(\"simple tune\\n\");\n\t\treturn 0;\n\t}\n\tdprintk(\"tuning demod\\n\");\n\n\t \n\ts5h1420_reset(state);\n\n\t \n\tif (p->symbol_rate > 33000000)\n\t\tstate->fclk = 80000000;\n\telse if (p->symbol_rate > 28500000)\n\t\tstate->fclk = 59000000;\n\telse if (p->symbol_rate > 25000000)\n\t\tstate->fclk = 86000000;\n\telse if (p->symbol_rate > 1900000)\n\t\tstate->fclk = 88000000;\n\telse\n\t\tstate->fclk = 44000000;\n\n\tdprintk(\"pll01: %d, ToneFreq: %d\\n\", state->fclk/1000000 - 8, (state->fclk + (TONE_FREQ * 32) - 1) / (TONE_FREQ * 32));\n\ts5h1420_writereg(state, PLL01, state->fclk/1000000 - 8);\n\ts5h1420_writereg(state, PLL02, 0x40);\n\ts5h1420_writereg(state, DiS01, (state->fclk + (TONE_FREQ * 32) - 1) / (TONE_FREQ * 32));\n\n\t \n\tif (p->symbol_rate > 29000000)\n\t\ts5h1420_writereg(state, QPSK01, 0xae | 0x10);\n\telse\n\t\ts5h1420_writereg(state, QPSK01, 0xac | 0x10);\n\n\t \n\ts5h1420_writereg(state, CON_1, 0x00);\n\ts5h1420_writereg(state, QPSK02, 0x00);\n\ts5h1420_writereg(state, Pre01, 0xb0);\n\n\ts5h1420_writereg(state, Loop01, 0xF0);\n\ts5h1420_writereg(state, Loop02, 0x2a);  \n\ts5h1420_writereg(state, Loop03, 0x79);  \n\tif (p->symbol_rate > 20000000)\n\t\ts5h1420_writereg(state, Loop04, 0x79);\n\telse\n\t\ts5h1420_writereg(state, Loop04, 0x58);\n\ts5h1420_writereg(state, Loop05, 0x6b);\n\n\tif (p->symbol_rate >= 8000000)\n\t\ts5h1420_writereg(state, Post01, (0 << 6) | 0x10);\n\telse if (p->symbol_rate >= 4000000)\n\t\ts5h1420_writereg(state, Post01, (1 << 6) | 0x10);\n\telse\n\t\ts5h1420_writereg(state, Post01, (3 << 6) | 0x10);\n\n\ts5h1420_writereg(state, Monitor12, 0x00);  \n\n\ts5h1420_writereg(state, Sync01, 0x33);\n\ts5h1420_writereg(state, Mpeg01, state->config->cdclk_polarity);\n\ts5h1420_writereg(state, Mpeg02, 0x3d);  \n\ts5h1420_writereg(state, Err01, 0x03);  \n\n\ts5h1420_writereg(state, Vit06, 0x6e);  \n\ts5h1420_writereg(state, DiS03, 0x00);\n\ts5h1420_writereg(state, Rf01, 0x61);  \n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t\ts5h1420_setfreqoffset(state, 0);\n\t}\n\n\t \n\ts5h1420_setsymbolrate(state, p);\n\ts5h1420_setfec_inversion(state, p);\n\n\t \n\ts5h1420_writereg(state, QPSK01, s5h1420_readreg(state, QPSK01) | 1);\n\n\tstate->fec_inner = p->fec_inner;\n\tstate->symbol_rate = p->symbol_rate;\n\tstate->postlocked = 0;\n\tstate->tunedfreq = p->frequency;\n\n\tdprintk(\"leave %s\\n\", __func__);\n\treturn 0;\n}\n\nstatic int s5h1420_get_frontend(struct dvb_frontend* fe,\n\t\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\n\tp->frequency = state->tunedfreq + s5h1420_getfreqoffset(state);\n\tp->inversion = s5h1420_getinversion(state);\n\tp->symbol_rate = s5h1420_getsymbolrate(state);\n\tp->fec_inner = s5h1420_getfec(state);\n\n\treturn 0;\n}\n\nstatic int s5h1420_get_tune_settings(struct dvb_frontend* fe,\n\t\t\t\t     struct dvb_frontend_tune_settings* fesettings)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tif (p->symbol_rate > 20000000) {\n\t\tfesettings->min_delay_ms = 50;\n\t\tfesettings->step_size = 2000;\n\t\tfesettings->max_drift = 8000;\n\t} else if (p->symbol_rate > 12000000) {\n\t\tfesettings->min_delay_ms = 100;\n\t\tfesettings->step_size = 1500;\n\t\tfesettings->max_drift = 9000;\n\t} else if (p->symbol_rate > 8000000) {\n\t\tfesettings->min_delay_ms = 100;\n\t\tfesettings->step_size = 1000;\n\t\tfesettings->max_drift = 8000;\n\t} else if (p->symbol_rate > 4000000) {\n\t\tfesettings->min_delay_ms = 100;\n\t\tfesettings->step_size = 500;\n\t\tfesettings->max_drift = 7000;\n\t} else if (p->symbol_rate > 2000000) {\n\t\tfesettings->min_delay_ms = 200;\n\t\tfesettings->step_size = (p->symbol_rate / 8000);\n\t\tfesettings->max_drift = 14 * fesettings->step_size;\n\t} else {\n\t\tfesettings->min_delay_ms = 200;\n\t\tfesettings->step_size = (p->symbol_rate / 8000);\n\t\tfesettings->max_drift = 18 * fesettings->step_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int s5h1420_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\n\tif (enable)\n\t\treturn s5h1420_writereg(state, 0x02, state->CON_1_val | 1);\n\telse\n\t\treturn s5h1420_writereg(state, 0x02, state->CON_1_val & 0xfe);\n}\n\nstatic int s5h1420_init (struct dvb_frontend* fe)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\n\t \n\tstate->CON_1_val = state->config->serial_mpeg << 4;\n\ts5h1420_writereg(state, 0x02, state->CON_1_val);\n\tmsleep(10);\n\ts5h1420_reset(state);\n\n\treturn 0;\n}\n\nstatic int s5h1420_sleep(struct dvb_frontend* fe)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\tstate->CON_1_val = 0x12;\n\treturn s5h1420_writereg(state, 0x02, state->CON_1_val);\n}\n\nstatic void s5h1420_release(struct dvb_frontend* fe)\n{\n\tstruct s5h1420_state* state = fe->demodulator_priv;\n\ti2c_del_adapter(&state->tuner_i2c_adapter);\n\tkfree(state);\n}\n\nstatic u32 s5h1420_tuner_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic int s5h1420_tuner_i2c_tuner_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\n{\n\tstruct s5h1420_state *state = i2c_get_adapdata(i2c_adap);\n\tstruct i2c_msg m[3];\n\tu8 tx_open[2] = { CON_1, state->CON_1_val | 1 };  \n\n\tif (1 + num > ARRAY_SIZE(m)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: i2c xfer: num=%d is too big!\\n\",\n\t\t       KBUILD_MODNAME, num);\n\t\treturn  -EOPNOTSUPP;\n\t}\n\n\tmemset(m, 0, sizeof(struct i2c_msg) * (1 + num));\n\n\tm[0].addr = state->config->demod_address;\n\tm[0].buf  = tx_open;\n\tm[0].len  = 2;\n\n\tmemcpy(&m[1], msg, sizeof(struct i2c_msg) * num);\n\n\treturn i2c_transfer(state->i2c, m, 1 + num) == 1 + num ? num : -EIO;\n}\n\nstatic const struct i2c_algorithm s5h1420_tuner_i2c_algo = {\n\t.master_xfer   = s5h1420_tuner_i2c_tuner_xfer,\n\t.functionality = s5h1420_tuner_i2c_func,\n};\n\nstruct i2c_adapter *s5h1420_get_tuner_i2c_adapter(struct dvb_frontend *fe)\n{\n\tstruct s5h1420_state *state = fe->demodulator_priv;\n\treturn &state->tuner_i2c_adapter;\n}\nEXPORT_SYMBOL(s5h1420_get_tuner_i2c_adapter);\n\nstatic const struct dvb_frontend_ops s5h1420_ops;\n\nstruct dvb_frontend *s5h1420_attach(const struct s5h1420_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\t \n\tstruct s5h1420_state *state = kzalloc(sizeof(struct s5h1420_state), GFP_KERNEL);\n\tu8 i;\n\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->postlocked = 0;\n\tstate->fclk = 88000000;\n\tstate->tunedfreq = 0;\n\tstate->fec_inner = FEC_NONE;\n\tstate->symbol_rate = 0;\n\n\t \n\ti = s5h1420_readreg(state, ID01);\n\tif (i != 0x03)\n\t\tgoto error;\n\n\tmemset(state->shadow, 0xff, sizeof(state->shadow));\n\n\tfor (i = 0; i < 0x50; i++)\n\t\tstate->shadow[i] = s5h1420_readreg(state, i);\n\n\t \n\tmemcpy(&state->frontend.ops, &s5h1420_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\n\t \n\tstrscpy(state->tuner_i2c_adapter.name, \"S5H1420-PN1010 tuner I2C bus\",\n\t\tsizeof(state->tuner_i2c_adapter.name));\n\tstate->tuner_i2c_adapter.algo      = &s5h1420_tuner_i2c_algo;\n\tstate->tuner_i2c_adapter.algo_data = NULL;\n\ti2c_set_adapdata(&state->tuner_i2c_adapter, state);\n\tif (i2c_add_adapter(&state->tuner_i2c_adapter) < 0) {\n\t\tprintk(KERN_ERR \"S5H1420/PN1010: tuner i2c bus could not be initialized\\n\");\n\t\tgoto error;\n\t}\n\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(s5h1420_attach);\n\nstatic const struct dvb_frontend_ops s5h1420_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name     = \"Samsung S5H1420/PnpNetwork PN1010 DVB-S\",\n\t\t.frequency_min_hz    =  950 * MHz,\n\t\t.frequency_max_hz    = 2150 * MHz,\n\t\t.frequency_stepsize_hz = 125 * kHz,\n\t\t.frequency_tolerance_hz  = 29500 * kHz,\n\t\t.symbol_rate_min  = 1000000,\n\t\t.symbol_rate_max  = 45000000,\n\t\t \n\t\t.caps = FE_CAN_INVERSION_AUTO |\n\t\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\tFE_CAN_QPSK\n\t},\n\n\t.release = s5h1420_release,\n\n\t.init = s5h1420_init,\n\t.sleep = s5h1420_sleep,\n\t.i2c_gate_ctrl = s5h1420_i2c_gate_ctrl,\n\n\t.set_frontend = s5h1420_set_frontend,\n\t.get_frontend = s5h1420_get_frontend,\n\t.get_tune_settings = s5h1420_get_tune_settings,\n\n\t.read_status = s5h1420_read_status,\n\t.read_ber = s5h1420_read_ber,\n\t.read_signal_strength = s5h1420_read_signal_strength,\n\t.read_ucblocks = s5h1420_read_ucblocks,\n\n\t.diseqc_send_master_cmd = s5h1420_send_master_cmd,\n\t.diseqc_recv_slave_reply = s5h1420_recv_slave_reply,\n\t.diseqc_send_burst = s5h1420_send_burst,\n\t.set_tone = s5h1420_set_tone,\n\t.set_voltage = s5h1420_set_voltage,\n};\n\nMODULE_DESCRIPTION(\"Samsung S5H1420/PnpNetwork PN1010 DVB-S Demodulator driver\");\nMODULE_AUTHOR(\"Andrew de Quincey, Patrick Boettcher\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}