{
  "module_name": "l64781.c",
  "hash_id": "3b6006c17db7b8ddeb281149ff81e936b7f20aa0ea0b64b5dcd3f01bf6da476b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/l64781.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <media/dvb_frontend.h>\n#include \"l64781.h\"\n\n\nstruct l64781_state {\n\tstruct i2c_adapter* i2c;\n\tconst struct l64781_config* config;\n\tstruct dvb_frontend frontend;\n\n\t \n\tunsigned int first:1;\n};\n\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) printk(KERN_DEBUG \"l64781: \" args); \\\n\t} while (0)\n\nstatic int debug;\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\n\nstatic int l64781_writereg (struct l64781_state* state, u8 reg, u8 data)\n{\n\tint ret;\n\tu8 buf [] = { reg, data };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\n\n\tif ((ret = i2c_transfer(state->i2c, &msg, 1)) != 1)\n\t\tdprintk (\"%s: write_reg error (reg == %02x) = %02x!\\n\",\n\t\t\t __func__, reg, ret);\n\n\treturn (ret != 1) ? -1 : 0;\n}\n\nstatic int l64781_readreg (struct l64781_state* state, u8 reg)\n{\n\tint ret;\n\tu8 b0 [] = { reg };\n\tu8 b1 [] = { 0 };\n\tstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },\n\t\t\t   { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2) return ret;\n\n\treturn b1[0];\n}\n\nstatic void apply_tps (struct l64781_state* state)\n{\n\tl64781_writereg (state, 0x2a, 0x00);\n\tl64781_writereg (state, 0x2a, 0x01);\n\n\t \n\tl64781_writereg (state, 0x2a, 0x02);\n}\n\n\nstatic void reset_afc (struct l64781_state* state)\n{\n\t \n\tl64781_writereg (state, 0x07, 0x9e);  \n\tl64781_writereg (state, 0x08, 0);     \n\tl64781_writereg (state, 0x09, 0);\n\tl64781_writereg (state, 0x0a, 0);\n\tl64781_writereg (state, 0x07, 0x8e);\n\tl64781_writereg (state, 0x0e, 0);     \n\tl64781_writereg (state, 0x11, 0x80);  \n\tl64781_writereg (state, 0x10, 0);     \n\tl64781_writereg (state, 0x12, 0);\n\tl64781_writereg (state, 0x13, 0);\n\tl64781_writereg (state, 0x11, 0x00);\n}\n\nstatic int reset_and_configure (struct l64781_state* state)\n{\n\tu8 buf [] = { 0x06 };\n\tstruct i2c_msg msg = { .addr = 0x00, .flags = 0, .buf = buf, .len = 1 };\n\t \n\n\treturn (i2c_transfer(state->i2c, &msg, 1) == 1) ? 0 : -ENODEV;\n}\n\nstatic int apply_frontend_param(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct l64781_state* state = fe->demodulator_priv;\n\t \n\tstatic const u8 fec_tab[] = { 7, 0, 1, 2, 9, 3, 10, 4 };\n\t \n\tstatic const u8 qam_tab [] = { 2, 4, 0, 6 };\n\tstatic const u8 guard_tab [] = { 1, 2, 4, 8 };\n\t \n\tstatic const u32 ppm = 8000;\n\tu32 ddfs_offset_fixed;\n \n \n\tu32 init_freq;\n\tu32 spi_bias;\n\tu8 val0x04;\n\tu8 val0x05;\n\tu8 val0x06;\n\tint bw;\n\n\tswitch (p->bandwidth_hz) {\n\tcase 8000000:\n\t\tbw = 8;\n\t\tbreak;\n\tcase 7000000:\n\t\tbw = 7;\n\t\tbreak;\n\tcase 6000000:\n\t\tbw = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tif (p->inversion != INVERSION_ON &&\n\t    p->inversion != INVERSION_OFF)\n\t\treturn -EINVAL;\n\n\tif (p->code_rate_HP != FEC_1_2 && p->code_rate_HP != FEC_2_3 &&\n\t    p->code_rate_HP != FEC_3_4 && p->code_rate_HP != FEC_5_6 &&\n\t    p->code_rate_HP != FEC_7_8)\n\t\treturn -EINVAL;\n\n\tif (p->hierarchy != HIERARCHY_NONE &&\n\t    (p->code_rate_LP != FEC_1_2 && p->code_rate_LP != FEC_2_3 &&\n\t     p->code_rate_LP != FEC_3_4 && p->code_rate_LP != FEC_5_6 &&\n\t     p->code_rate_LP != FEC_7_8))\n\t\treturn -EINVAL;\n\n\tif (p->modulation != QPSK && p->modulation != QAM_16 &&\n\t    p->modulation != QAM_64)\n\t\treturn -EINVAL;\n\n\tif (p->transmission_mode != TRANSMISSION_MODE_2K &&\n\t    p->transmission_mode != TRANSMISSION_MODE_8K)\n\t\treturn -EINVAL;\n\n\tif ((int)p->guard_interval < GUARD_INTERVAL_1_32 ||\n\t    p->guard_interval > GUARD_INTERVAL_1_4)\n\t\treturn -EINVAL;\n\n\tif ((int)p->hierarchy < HIERARCHY_NONE ||\n\t    p->hierarchy > HIERARCHY_4)\n\t\treturn -EINVAL;\n\n\tddfs_offset_fixed = 0x4000-(ppm<<16)/bw/1000000;\n\n\t \n\tinit_freq = (((8UL<<25) + (8UL<<19) / 25*ppm / (15625/25)) /\n\t\t\tbw & 0xFFFFFF);\n\n\t \n\t \n\tspi_bias = 378 * (1 << 10);\n\tspi_bias *= 16;\n\tspi_bias *= bw;\n\tspi_bias *= qam_tab[p->modulation];\n\tspi_bias /= p->code_rate_HP + 1;\n\tspi_bias /= (guard_tab[p->guard_interval] + 32);\n\tspi_bias *= 1000;\n\tspi_bias /= 1000 + ppm/1000;\n\tspi_bias *= p->code_rate_HP;\n\n\tval0x04 = (p->transmission_mode << 2) | p->guard_interval;\n\tval0x05 = fec_tab[p->code_rate_HP];\n\n\tif (p->hierarchy != HIERARCHY_NONE)\n\t\tval0x05 |= (p->code_rate_LP - FEC_1_2) << 3;\n\n\tval0x06 = (p->hierarchy << 2) | p->modulation;\n\n\tl64781_writereg (state, 0x04, val0x04);\n\tl64781_writereg (state, 0x05, val0x05);\n\tl64781_writereg (state, 0x06, val0x06);\n\n\treset_afc (state);\n\n\t \n\tl64781_writereg (state, 0x15,\n\t\t\t p->transmission_mode == TRANSMISSION_MODE_2K ? 1 : 3);\n\tl64781_writereg (state, 0x16, init_freq & 0xff);\n\tl64781_writereg (state, 0x17, (init_freq >> 8) & 0xff);\n\tl64781_writereg (state, 0x18, (init_freq >> 16) & 0xff);\n\n\tl64781_writereg (state, 0x1b, spi_bias & 0xff);\n\tl64781_writereg (state, 0x1c, (spi_bias >> 8) & 0xff);\n\tl64781_writereg (state, 0x1d, ((spi_bias >> 16) & 0x7f) |\n\t\t(p->inversion == INVERSION_ON ? 0x80 : 0x00));\n\n\tl64781_writereg (state, 0x22, ddfs_offset_fixed & 0xff);\n\tl64781_writereg (state, 0x23, (ddfs_offset_fixed >> 8) & 0x3f);\n\n\tl64781_readreg (state, 0x00);   \n\tl64781_readreg (state, 0x01);   \n\n\tapply_tps (state);\n\n\treturn 0;\n}\n\nstatic int get_frontend(struct dvb_frontend *fe,\n\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct l64781_state* state = fe->demodulator_priv;\n\tint tmp;\n\n\n\ttmp = l64781_readreg(state, 0x04);\n\tswitch(tmp & 3) {\n\tcase 0:\n\t\tp->guard_interval = GUARD_INTERVAL_1_32;\n\t\tbreak;\n\tcase 1:\n\t\tp->guard_interval = GUARD_INTERVAL_1_16;\n\t\tbreak;\n\tcase 2:\n\t\tp->guard_interval = GUARD_INTERVAL_1_8;\n\t\tbreak;\n\tcase 3:\n\t\tp->guard_interval = GUARD_INTERVAL_1_4;\n\t\tbreak;\n\t}\n\tswitch((tmp >> 2) & 3) {\n\tcase 0:\n\t\tp->transmission_mode = TRANSMISSION_MODE_2K;\n\t\tbreak;\n\tcase 1:\n\t\tp->transmission_mode = TRANSMISSION_MODE_8K;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"Unexpected value for transmission_mode\\n\");\n\t}\n\n\ttmp = l64781_readreg(state, 0x05);\n\tswitch(tmp & 7) {\n\tcase 0:\n\t\tp->code_rate_HP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tp->code_rate_HP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tp->code_rate_HP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tp->code_rate_HP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tp->code_rate_HP = FEC_7_8;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"Unexpected value for code_rate_HP\\n\");\n\t}\n\tswitch((tmp >> 3) & 7) {\n\tcase 0:\n\t\tp->code_rate_LP = FEC_1_2;\n\t\tbreak;\n\tcase 1:\n\t\tp->code_rate_LP = FEC_2_3;\n\t\tbreak;\n\tcase 2:\n\t\tp->code_rate_LP = FEC_3_4;\n\t\tbreak;\n\tcase 3:\n\t\tp->code_rate_LP = FEC_5_6;\n\t\tbreak;\n\tcase 4:\n\t\tp->code_rate_LP = FEC_7_8;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"Unexpected value for code_rate_LP\\n\");\n\t}\n\n\ttmp = l64781_readreg(state, 0x06);\n\tswitch(tmp & 3) {\n\tcase 0:\n\t\tp->modulation = QPSK;\n\t\tbreak;\n\tcase 1:\n\t\tp->modulation = QAM_16;\n\t\tbreak;\n\tcase 2:\n\t\tp->modulation = QAM_64;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"Unexpected value for modulation\\n\");\n\t}\n\tswitch((tmp >> 2) & 7) {\n\tcase 0:\n\t\tp->hierarchy = HIERARCHY_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tp->hierarchy = HIERARCHY_1;\n\t\tbreak;\n\tcase 2:\n\t\tp->hierarchy = HIERARCHY_2;\n\t\tbreak;\n\tcase 3:\n\t\tp->hierarchy = HIERARCHY_4;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"Unexpected value for hierarchy\\n\");\n\t}\n\n\n\ttmp = l64781_readreg (state, 0x1d);\n\tp->inversion = (tmp & 0x80) ? INVERSION_ON : INVERSION_OFF;\n\n\ttmp = (int) (l64781_readreg (state, 0x08) |\n\t\t     (l64781_readreg (state, 0x09) << 8) |\n\t\t     (l64781_readreg (state, 0x0a) << 16));\n\tp->frequency += tmp;\n\n\treturn 0;\n}\n\nstatic int l64781_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct l64781_state* state = fe->demodulator_priv;\n\tint sync = l64781_readreg (state, 0x32);\n\tint gain = l64781_readreg (state, 0x0e);\n\n\tl64781_readreg (state, 0x00);   \n\tl64781_readreg (state, 0x01);   \n\n\t*status = 0;\n\n\tif (gain > 5)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (sync & 0x02)  \n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (sync & 0x20)\n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (sync & 0x40)\n\t\t*status |= FE_HAS_SYNC;\n\n\tif (sync == 0x7f)\n\t\t*status |= FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int l64781_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct l64781_state* state = fe->demodulator_priv;\n\n\t \n\t*ber = l64781_readreg (state, 0x39)\n\t    | (l64781_readreg (state, 0x3a) << 8);\n\n\treturn 0;\n}\n\nstatic int l64781_read_signal_strength(struct dvb_frontend* fe, u16* signal_strength)\n{\n\tstruct l64781_state* state = fe->demodulator_priv;\n\n\tu8 gain = l64781_readreg (state, 0x0e);\n\t*signal_strength = (gain << 8) | gain;\n\n\treturn 0;\n}\n\nstatic int l64781_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct l64781_state* state = fe->demodulator_priv;\n\n\tu8 avg_quality = 0xff - l64781_readreg (state, 0x33);\n\t*snr = (avg_quality << 8) | avg_quality;  \n\n\treturn 0;\n}\n\nstatic int l64781_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct l64781_state* state = fe->demodulator_priv;\n\n\t*ucblocks = l64781_readreg (state, 0x37)\n\t   | (l64781_readreg (state, 0x38) << 8);\n\n\treturn 0;\n}\n\nstatic int l64781_sleep(struct dvb_frontend* fe)\n{\n\tstruct l64781_state* state = fe->demodulator_priv;\n\n\t \n\treturn l64781_writereg (state, 0x3e, 0x5a);\n}\n\nstatic int l64781_init(struct dvb_frontend* fe)\n{\n\tstruct l64781_state* state = fe->demodulator_priv;\n\n\treset_and_configure (state);\n\n\t \n\tl64781_writereg (state, 0x3e, 0xa5);\n\n\t \n\tl64781_writereg (state, 0x2a, 0x04);\n\tl64781_writereg (state, 0x2a, 0x00);\n\n\t \n\t \n\tl64781_writereg (state, 0x07, 0x8e);\n\n\t \n\tl64781_writereg (state, 0x0b, 0x81);\n\n\t \n\tl64781_writereg (state, 0x0c, 0x84);\n\n\t \n\tl64781_writereg (state, 0x0d, 0x8c);\n\n\t \n\t \n\n\t \n\tl64781_writereg (state, 0x1e, 0x09);\n\n\t \n\tif (state->first) {\n\t\tstate->first = 0;\n\t\tmsleep(200);\n\t}\n\n\treturn 0;\n}\n\nstatic int l64781_get_tune_settings(struct dvb_frontend* fe,\n\t\t\t\t    struct dvb_frontend_tune_settings* fesettings)\n{\n\tfesettings->min_delay_ms = 4000;\n\tfesettings->step_size = 0;\n\tfesettings->max_drift = 0;\n\treturn 0;\n}\n\nstatic void l64781_release(struct dvb_frontend* fe)\n{\n\tstruct l64781_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops l64781_ops;\n\nstruct dvb_frontend* l64781_attach(const struct l64781_config* config,\n\t\t\t\t   struct i2c_adapter* i2c)\n{\n\tstruct l64781_state* state = NULL;\n\tint reg0x3e = -1;\n\tu8 b0 [] = { 0x1a };\n\tu8 b1 [] = { 0x00 };\n\tstruct i2c_msg msg [] = { { .addr = config->demod_address, .flags = 0, .buf = b0, .len = 1 },\n\t\t\t   { .addr = config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\n\n\t \n\tstate = kzalloc(sizeof(struct l64781_state), GFP_KERNEL);\n\tif (state == NULL) goto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->first = 1;\n\n\t \n\tif (reset_and_configure(state) < 0) {\n\t\tdprintk(\"No response to reset and configure broadcast...\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tif (i2c_transfer(state->i2c, msg, 2) != 2) {\n\t\tdprintk(\"No response to read on I2C bus\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\treg0x3e = l64781_readreg(state, 0x3e);\n\n\t \n\tif (reg0x3e != 0) {\n\t\tdprintk(\"Device doesn't look like L64781\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tl64781_writereg (state, 0x3e, 0x5a);\n\n\t \n\tif (l64781_readreg(state, 0x1a) != 0) {\n\t\tdprintk(\"Read 1 returned unexpected value\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tl64781_writereg (state, 0x3e, 0xa5);\n\n\t \n\tif (l64781_readreg(state, 0x1a) != 0xa1) {\n\t\tdprintk(\"Read 2 returned unexpected value\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tmemcpy(&state->frontend.ops, &l64781_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tif (reg0x3e >= 0)\n\t\tl64781_writereg (state, 0x3e, reg0x3e);   \n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops l64781_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name = \"LSI L64781 DVB-T\",\n\t \n\t \n\t\t.frequency_stepsize_hz = 166666,\n\t \n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t      FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |\n\t\t      FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |\n\t\t      FE_CAN_MUTE_TS\n\t},\n\n\t.release = l64781_release,\n\n\t.init = l64781_init,\n\t.sleep = l64781_sleep,\n\n\t.set_frontend = apply_frontend_param,\n\t.get_frontend = get_frontend,\n\t.get_tune_settings = l64781_get_tune_settings,\n\n\t.read_status = l64781_read_status,\n\t.read_ber = l64781_read_ber,\n\t.read_signal_strength = l64781_read_signal_strength,\n\t.read_snr = l64781_read_snr,\n\t.read_ucblocks = l64781_read_ucblocks,\n};\n\nMODULE_DESCRIPTION(\"LSI L64781 DVB-T Demodulator driver\");\nMODULE_AUTHOR(\"Holger Waechtler, Marko Kohtala\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(l64781_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}