{
  "module_name": "sp887x.c",
  "hash_id": "b3f6acf34883dfd6fd4ab3bfaccbca6195faf4eac0b6eeac0c88b139150daa00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/sp887x.c",
  "human_readable_source": "\n \n\n \n#define SP887X_DEFAULT_FIRMWARE \"dvb-fe-sp887x.fw\"\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"sp887x.h\"\n\n\nstruct sp887x_state {\n\tstruct i2c_adapter* i2c;\n\tconst struct sp887x_config* config;\n\tstruct dvb_frontend frontend;\n\n\t \n\tu8 initialised:1;\n};\n\nstatic int debug;\n#define dprintk(args...) \\\n\tdo { \\\n\t\tif (debug) printk(KERN_DEBUG \"sp887x: \" args); \\\n\t} while (0)\n\nstatic int i2c_writebytes (struct sp887x_state* state, u8 *buf, u8 len)\n{\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = len };\n\tint err;\n\n\tif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\n\t\tprintk (\"%s: i2c write error (addr %02x, err == %i)\\n\",\n\t\t\t__func__, state->config->demod_address, err);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int sp887x_writereg (struct sp887x_state* state, u16 reg, u16 data)\n{\n\tu8 b0 [] = { reg >> 8 , reg & 0xff, data >> 8, data & 0xff };\n\tstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 4 };\n\tint ret;\n\n\tif ((ret = i2c_transfer(state->i2c, &msg, 1)) != 1) {\n\t\t \n\t\tif (!(reg == 0xf1a && data == 0x000 &&\n\t\t\t(ret == -EREMOTEIO || ret == -EFAULT)))\n\t\t{\n\t\t\tprintk(\"%s: writereg error (reg %03x, data %03x, ret == %i)\\n\",\n\t\t\t       __func__, reg & 0xffff, data & 0xffff, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sp887x_readreg (struct sp887x_state* state, u16 reg)\n{\n\tu8 b0 [] = { reg >> 8 , reg & 0xff };\n\tu8 b1 [2];\n\tint ret;\n\tstruct i2c_msg msg[] = {{ .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 2 },\n\t\t\t { .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 2 }};\n\n\tif ((ret = i2c_transfer(state->i2c, msg, 2)) != 2) {\n\t\tprintk(\"%s: readreg error (ret == %i)\\n\", __func__, ret);\n\t\treturn -1;\n\t}\n\n\treturn (((b1[0] << 8) | b1[1]) & 0xfff);\n}\n\nstatic void sp887x_microcontroller_stop (struct sp887x_state* state)\n{\n\tdprintk(\"%s\\n\", __func__);\n\tsp887x_writereg(state, 0xf08, 0x000);\n\tsp887x_writereg(state, 0xf09, 0x000);\n\n\t \n\tsp887x_writereg(state, 0xf00, 0x000);\n}\n\nstatic void sp887x_microcontroller_start (struct sp887x_state* state)\n{\n\tdprintk(\"%s\\n\", __func__);\n\tsp887x_writereg(state, 0xf08, 0x000);\n\tsp887x_writereg(state, 0xf09, 0x000);\n\n\t \n\tsp887x_writereg(state, 0xf00, 0x001);\n}\n\nstatic void sp887x_setup_agc (struct sp887x_state* state)\n{\n\t \n\tdprintk(\"%s\\n\", __func__);\n\tsp887x_writereg(state, 0x33c, 0x054);\n\tsp887x_writereg(state, 0x33b, 0x04c);\n\tsp887x_writereg(state, 0x328, 0x000);\n\tsp887x_writereg(state, 0x327, 0x005);\n\tsp887x_writereg(state, 0x326, 0x001);\n\tsp887x_writereg(state, 0x325, 0x001);\n\tsp887x_writereg(state, 0x324, 0x001);\n\tsp887x_writereg(state, 0x318, 0x050);\n\tsp887x_writereg(state, 0x317, 0x3fe);\n\tsp887x_writereg(state, 0x316, 0x001);\n\tsp887x_writereg(state, 0x313, 0x005);\n\tsp887x_writereg(state, 0x312, 0x002);\n\tsp887x_writereg(state, 0x306, 0x000);\n\tsp887x_writereg(state, 0x303, 0x000);\n}\n\n#define BLOCKSIZE 30\n#define FW_SIZE 0x4000\n \nstatic int sp887x_initial_setup (struct dvb_frontend* fe, const struct firmware *fw)\n{\n\tstruct sp887x_state* state = fe->demodulator_priv;\n\tu8 buf [BLOCKSIZE + 2];\n\tint i;\n\tint fw_size = fw->size;\n\tconst unsigned char *mem = fw->data + 10;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\t \n\tif (fw_size < FW_SIZE + 10)\n\t\treturn -ENODEV;\n\n\t \n\tsp887x_writereg(state, 0xf1a, 0x000);\n\n\tsp887x_microcontroller_stop (state);\n\n\tprintk (\"%s: firmware upload... \", __func__);\n\n\t \n\t \n\tsp887x_writereg(state, 0x8f08, 0x1fff);\n\n\t \n\tsp887x_writereg(state, 0x8f0a, 0x0000);\n\n\tfor (i = 0; i < FW_SIZE; i += BLOCKSIZE) {\n\t\tint c = BLOCKSIZE;\n\t\tint err;\n\n\t\tif (c > FW_SIZE - i)\n\t\t\tc = FW_SIZE - i;\n\n\t\t \n\t\t \n\t\t \n\t\tbuf[0] = 0xcf;\n\t\tbuf[1] = 0x0a;\n\n\t\tmemcpy(&buf[2], mem + i, c);\n\n\t\tif ((err = i2c_writebytes (state, buf, c+2)) < 0) {\n\t\t\tprintk (\"failed.\\n\");\n\t\t\tprintk (\"%s: i2c error (err == %i)\\n\", __func__, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tsp887x_writereg(state, 0xc13, 0x001);\n\n\t \n\tsp887x_writereg(state, 0xc14, 0x000);\n\n\t \n\tsp887x_writereg(state, 0xc1a, 0x872);\n\tsp887x_writereg(state, 0xc1b, 0x001);\n\tsp887x_writereg(state, 0xc1c, 0x000);  \n\tsp887x_writereg(state, 0xc1a, 0x871);\n\n\t \n\tsp887x_writereg(state, 0x301, 0x002);\n\n\tsp887x_setup_agc(state);\n\n\t \n\tsp887x_writereg(state, 0xd00, 0x010);\n\tsp887x_writereg(state, 0x0d1, 0x000);\n\treturn 0;\n};\n\nstatic int configure_reg0xc05(struct dtv_frontend_properties *p, u16 *reg0xc05)\n{\n\tint known_parameters = 1;\n\n\t*reg0xc05 = 0x000;\n\n\tswitch (p->modulation) {\n\tcase QPSK:\n\t\tbreak;\n\tcase QAM_16:\n\t\t*reg0xc05 |= (1 << 10);\n\t\tbreak;\n\tcase QAM_64:\n\t\t*reg0xc05 |= (2 << 10);\n\t\tbreak;\n\tcase QAM_AUTO:\n\t\tknown_parameters = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->hierarchy) {\n\tcase HIERARCHY_NONE:\n\t\tbreak;\n\tcase HIERARCHY_1:\n\t\t*reg0xc05 |= (1 << 7);\n\t\tbreak;\n\tcase HIERARCHY_2:\n\t\t*reg0xc05 |= (2 << 7);\n\t\tbreak;\n\tcase HIERARCHY_4:\n\t\t*reg0xc05 |= (3 << 7);\n\t\tbreak;\n\tcase HIERARCHY_AUTO:\n\t\tknown_parameters = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->code_rate_HP) {\n\tcase FEC_1_2:\n\t\tbreak;\n\tcase FEC_2_3:\n\t\t*reg0xc05 |= (1 << 3);\n\t\tbreak;\n\tcase FEC_3_4:\n\t\t*reg0xc05 |= (2 << 3);\n\t\tbreak;\n\tcase FEC_5_6:\n\t\t*reg0xc05 |= (3 << 3);\n\t\tbreak;\n\tcase FEC_7_8:\n\t\t*reg0xc05 |= (4 << 3);\n\t\tbreak;\n\tcase FEC_AUTO:\n\t\tknown_parameters = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (known_parameters)\n\t\t*reg0xc05 |= (2 << 1);\t \n\telse\n\t\t*reg0xc05 |= (1 << 1);\t \n\n\treturn 0;\n}\n\n \nstatic void divide (int n, int d, int *quotient_i, int *quotient_f)\n{\n\tunsigned int q, r;\n\n\tr = (n % d) << 8;\n\tq = (r / d);\n\n\tif (quotient_i)\n\t\t*quotient_i = q;\n\n\tif (quotient_f) {\n\t\tr = (r % d) << 8;\n\t\tq = (q << 8) | (r / d);\n\t\tr = (r % d) << 8;\n\t\t*quotient_f = (q << 8) | (r / d);\n\t}\n}\n\nstatic void sp887x_correct_offsets (struct sp887x_state* state,\n\t\t\t\t    struct dtv_frontend_properties *p,\n\t\t\t\t    int actual_freq)\n{\n\tstatic const u32 srate_correction [] = { 1879617, 4544878, 8098561 };\n\tint bw_index;\n\tint freq_offset = actual_freq - p->frequency;\n\tint sysclock = 61003; \n\tint ifreq = 36000000;\n\tint freq;\n\tint frequency_shift;\n\n\tswitch (p->bandwidth_hz) {\n\tdefault:\n\tcase 8000000:\n\t\tbw_index = 0;\n\t\tbreak;\n\tcase 7000000:\n\t\tbw_index = 1;\n\t\tbreak;\n\tcase 6000000:\n\t\tbw_index = 2;\n\t\tbreak;\n\t}\n\n\tif (p->inversion == INVERSION_ON)\n\t\tfreq = ifreq - freq_offset;\n\telse\n\t\tfreq = ifreq + freq_offset;\n\n\tdivide(freq / 333, sysclock, NULL, &frequency_shift);\n\n\tif (p->inversion == INVERSION_ON)\n\t\tfrequency_shift = -frequency_shift;\n\n\t \n\tsp887x_writereg(state, 0x319, srate_correction[bw_index] >> 12);\n\tsp887x_writereg(state, 0x31a, srate_correction[bw_index] & 0xfff);\n\n\t \n\tsp887x_writereg(state, 0x309, frequency_shift >> 12);\n\tsp887x_writereg(state, 0x30a, frequency_shift & 0xfff);\n}\n\nstatic int sp887x_setup_frontend_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct sp887x_state* state = fe->demodulator_priv;\n\tunsigned actual_freq;\n\tint err;\n\tu16 val, reg0xc05;\n\n\tif (p->bandwidth_hz != 8000000 &&\n\t    p->bandwidth_hz != 7000000 &&\n\t    p->bandwidth_hz != 6000000)\n\t\treturn -EINVAL;\n\n\tif ((err = configure_reg0xc05(p, &reg0xc05)))\n\t\treturn err;\n\n\tsp887x_microcontroller_stop(state);\n\n\t \n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\tif (fe->ops.tuner_ops.get_frequency) {\n\t\tfe->ops.tuner_ops.get_frequency(fe, &actual_freq);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t} else {\n\t\tactual_freq = p->frequency;\n\t}\n\n\t \n\tsp887x_readreg(state, 0x200);\n\n\tsp887x_correct_offsets(state, p, actual_freq);\n\n\t \n\tif (p->bandwidth_hz == 6000000)\n\t\tval = 2;\n\telse if (p->bandwidth_hz == 7000000)\n\t\tval = 1;\n\telse\n\t\tval = 0;\n\n\tsp887x_writereg(state, 0x311, val);\n\n\t \n\tif (p->transmission_mode == TRANSMISSION_MODE_2K)\n\t\tsp887x_writereg(state, 0x338, 0x000);\n\telse\n\t\tsp887x_writereg(state, 0x338, 0x001);\n\n\tsp887x_writereg(state, 0xc05, reg0xc05);\n\n\tif (p->bandwidth_hz == 6000000)\n\t\tval = 2 << 3;\n\telse if (p->bandwidth_hz == 7000000)\n\t\tval = 3 << 3;\n\telse\n\t\tval = 0 << 3;\n\n\t \n\tsp887x_writereg(state, 0xf14, 0x160 | val);\n\tsp887x_writereg(state, 0xf15, 0x000);\n\n\tsp887x_microcontroller_start(state);\n\treturn 0;\n}\n\nstatic int sp887x_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct sp887x_state* state = fe->demodulator_priv;\n\tu16 snr12 = sp887x_readreg(state, 0xf16);\n\tu16 sync0x200 = sp887x_readreg(state, 0x200);\n\tu16 sync0xf17 = sp887x_readreg(state, 0xf17);\n\n\t*status = 0;\n\n\tif (snr12 > 0x00f)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\t\n\t\n\n\t\n\t\n\n\tif ((sync0xf17 & 0x00f) == 0x002) {\n\t\t*status |= FE_HAS_LOCK;\n\t\t*status |= FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_CARRIER;\n\t}\n\n\tif (sync0x200 & 0x001) {\t \n\t\tint steps = (sync0x200 >> 4) & 0x00f;\n\t\tif (steps & 0x008)\n\t\t\tsteps = -steps;\n\t\tdprintk(\"sp887x: implement tuner adjustment (%+i steps)!!\\n\",\n\t\t       steps);\n\t}\n\n\treturn 0;\n}\n\nstatic int sp887x_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct sp887x_state* state = fe->demodulator_priv;\n\n\t*ber = (sp887x_readreg(state, 0xc08) & 0x3f) |\n\t       (sp887x_readreg(state, 0xc07) << 6);\n\tsp887x_writereg(state, 0xc08, 0x000);\n\tsp887x_writereg(state, 0xc07, 0x000);\n\tif (*ber >= 0x3fff0)\n\t\t*ber = ~0;\n\n\treturn 0;\n}\n\nstatic int sp887x_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\tstruct sp887x_state* state = fe->demodulator_priv;\n\n\tu16 snr12 = sp887x_readreg(state, 0xf16);\n\tu32 signal = 3 * (snr12 << 4);\n\t*strength = (signal < 0xffff) ? signal : 0xffff;\n\n\treturn 0;\n}\n\nstatic int sp887x_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct sp887x_state* state = fe->demodulator_priv;\n\n\tu16 snr12 = sp887x_readreg(state, 0xf16);\n\t*snr = (snr12 << 4) | (snr12 >> 8);\n\n\treturn 0;\n}\n\nstatic int sp887x_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct sp887x_state* state = fe->demodulator_priv;\n\n\t*ucblocks = sp887x_readreg(state, 0xc0c);\n\tif (*ucblocks == 0xfff)\n\t\t*ucblocks = ~0;\n\n\treturn 0;\n}\n\nstatic int sp887x_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\n{\n\tstruct sp887x_state* state = fe->demodulator_priv;\n\n\tif (enable) {\n\t\treturn sp887x_writereg(state, 0x206, 0x001);\n\t} else {\n\t\treturn sp887x_writereg(state, 0x206, 0x000);\n\t}\n}\n\nstatic int sp887x_sleep(struct dvb_frontend* fe)\n{\n\tstruct sp887x_state* state = fe->demodulator_priv;\n\n\t \n\tsp887x_writereg(state, 0xc18, 0x000);\n\n\treturn 0;\n}\n\nstatic int sp887x_init(struct dvb_frontend* fe)\n{\n\tstruct sp887x_state* state = fe->demodulator_priv;\n\tconst struct firmware *fw = NULL;\n\tint ret;\n\n\tif (!state->initialised) {\n\t\t \n\t\tprintk(\"sp887x: waiting for firmware upload (%s)...\\n\", SP887X_DEFAULT_FIRMWARE);\n\t\tret = state->config->request_firmware(fe, &fw, SP887X_DEFAULT_FIRMWARE);\n\t\tif (ret) {\n\t\t\tprintk(\"sp887x: no firmware upload (timeout or file not found?)\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = sp887x_initial_setup(fe, fw);\n\t\trelease_firmware(fw);\n\t\tif (ret) {\n\t\t\tprintk(\"sp887x: writing firmware to device failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tprintk(\"sp887x: firmware upload complete\\n\");\n\t\tstate->initialised = 1;\n\t}\n\n\t \n\tsp887x_writereg(state, 0xc18, 0x00d);\n\n\treturn 0;\n}\n\nstatic int sp887x_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\n{\n\tfesettings->min_delay_ms = 350;\n\tfesettings->step_size = 166666*2;\n\tfesettings->max_drift = (166666*2)+1;\n\treturn 0;\n}\n\nstatic void sp887x_release(struct dvb_frontend* fe)\n{\n\tstruct sp887x_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops sp887x_ops;\n\nstruct dvb_frontend* sp887x_attach(const struct sp887x_config* config,\n\t\t\t\t   struct i2c_adapter* i2c)\n{\n\tstruct sp887x_state* state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct sp887x_state), GFP_KERNEL);\n\tif (state == NULL) goto error;\n\n\t \n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->initialised = 0;\n\n\t \n\tif (sp887x_readreg(state, 0x0200) < 0) goto error;\n\n\t \n\tmemcpy(&state->frontend.ops, &sp887x_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops sp887x_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name = \"Spase SP887x DVB-T\",\n\t\t.frequency_min_hz =  50500 * kHz,\n\t\t.frequency_max_hz = 858000 * kHz,\n\t\t.frequency_stepsize_hz = 166666,\n\t\t.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |\n\t\t\tFE_CAN_RECOVER\n\t},\n\n\t.release = sp887x_release,\n\n\t.init = sp887x_init,\n\t.sleep = sp887x_sleep,\n\t.i2c_gate_ctrl = sp887x_i2c_gate_ctrl,\n\n\t.set_frontend = sp887x_setup_frontend_parameters,\n\t.get_tune_settings = sp887x_get_tune_settings,\n\n\t.read_status = sp887x_read_status,\n\t.read_ber = sp887x_read_ber,\n\t.read_signal_strength = sp887x_read_signal_strength,\n\t.read_snr = sp887x_read_snr,\n\t.read_ucblocks = sp887x_read_ucblocks,\n};\n\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\n\nMODULE_DESCRIPTION(\"Spase sp887x DVB-T demodulator driver\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(sp887x_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}