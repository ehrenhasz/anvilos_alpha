{
  "module_name": "ves1820.c",
  "hash_id": "4aa97bee032a3693f40982879166a21362d3e12cf81c7b8f7d1f4bc062a23a94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/ves1820.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"ves1820.h\"\n\n\n\nstruct ves1820_state {\n\tstruct i2c_adapter* i2c;\n\t \n\tconst struct ves1820_config* config;\n\tstruct dvb_frontend frontend;\n\n\t \n\tu8 reg0;\n\tu8 pwm;\n};\n\n\nstatic int verbose;\n\nstatic u8 ves1820_inittab[] = {\n\t0x69, 0x6A, 0x93, 0x1A, 0x12, 0x46, 0x26, 0x1A,\n\t0x43, 0x6A, 0xAA, 0xAA, 0x1E, 0x85, 0x43, 0x20,\n\t0xE0, 0x00, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n\t0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x40\n};\n\nstatic int ves1820_writereg(struct ves1820_state *state, u8 reg, u8 data)\n{\n\tu8 buf[] = { 0x00, reg, data };\n\tstruct i2c_msg msg = {.addr = state->config->demod_address,.flags = 0,.buf = buf,.len = 3 };\n\tint ret;\n\n\tret = i2c_transfer(state->i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tprintk(\"ves1820: %s(): writereg error (reg == 0x%02x, val == 0x%02x, ret == %i)\\n\",\n\t\t       __func__, reg, data, ret);\n\n\treturn (ret != 1) ? -EREMOTEIO : 0;\n}\n\nstatic u8 ves1820_readreg(struct ves1820_state *state, u8 reg)\n{\n\tu8 b0[] = { 0x00, reg };\n\tu8 b1[] = { 0 };\n\tstruct i2c_msg msg[] = {\n\t\t{.addr = state->config->demod_address,.flags = 0,.buf = b0,.len = 2},\n\t\t{.addr = state->config->demod_address,.flags = I2C_M_RD,.buf = b1,.len = 1}\n\t};\n\tint ret;\n\n\tret = i2c_transfer(state->i2c, msg, 2);\n\n\tif (ret != 2)\n\t\tprintk(\"ves1820: %s(): readreg error (reg == 0x%02x, ret == %i)\\n\",\n\t\t       __func__, reg, ret);\n\n\treturn b1[0];\n}\n\nstatic int ves1820_setup_reg0(struct ves1820_state *state,\n\t\t\t      u8 reg0, enum fe_spectral_inversion inversion)\n{\n\treg0 |= state->reg0 & 0x62;\n\n\tif (INVERSION_ON == inversion) {\n\t\tif (!state->config->invert) reg0 |= 0x20;\n\t\telse reg0 &= ~0x20;\n\t} else if (INVERSION_OFF == inversion) {\n\t\tif (!state->config->invert) reg0 &= ~0x20;\n\t\telse reg0 |= 0x20;\n\t}\n\n\tves1820_writereg(state, 0x00, reg0 & 0xfe);\n\tves1820_writereg(state, 0x00, reg0 | 0x01);\n\n\tstate->reg0 = reg0;\n\n\treturn 0;\n}\n\nstatic int ves1820_set_symbolrate(struct ves1820_state *state, u32 symbolrate)\n{\n\ts32 BDR;\n\ts32 BDRI;\n\ts16 SFIL = 0;\n\tu16 NDEC = 0;\n\tu32 ratio;\n\tu32 fin;\n\tu32 tmp;\n\tu64 fptmp;\n\tu64 fpxin;\n\n\tif (symbolrate > state->config->xin / 2)\n\t\tsymbolrate = state->config->xin / 2;\n\n\tif (symbolrate < 500000)\n\t\tsymbolrate = 500000;\n\n\tif (symbolrate < state->config->xin / 16)\n\t\tNDEC = 1;\n\tif (symbolrate < state->config->xin / 32)\n\t\tNDEC = 2;\n\tif (symbolrate < state->config->xin / 64)\n\t\tNDEC = 3;\n\n\t \n\tfpxin = state->config->xin * 10ULL;\n\tfptmp = fpxin; do_div(fptmp, 123);\n\tif (symbolrate < fptmp)\n\t\tSFIL = 1;\n\tfptmp = fpxin; do_div(fptmp, 160);\n\tif (symbolrate < fptmp)\n\t\tSFIL = 0;\n\tfptmp = fpxin; do_div(fptmp, 246);\n\tif (symbolrate < fptmp)\n\t\tSFIL = 1;\n\tfptmp = fpxin; do_div(fptmp, 320);\n\tif (symbolrate < fptmp)\n\t\tSFIL = 0;\n\tfptmp = fpxin; do_div(fptmp, 492);\n\tif (symbolrate < fptmp)\n\t\tSFIL = 1;\n\tfptmp = fpxin; do_div(fptmp, 640);\n\tif (symbolrate < fptmp)\n\t\tSFIL = 0;\n\tfptmp = fpxin; do_div(fptmp, 984);\n\tif (symbolrate < fptmp)\n\t\tSFIL = 1;\n\n\tfin = state->config->xin >> 4;\n\tsymbolrate <<= NDEC;\n\tratio = (symbolrate << 4) / fin;\n\ttmp = ((symbolrate << 4) % fin) << 8;\n\tratio = (ratio << 8) + tmp / fin;\n\ttmp = (tmp % fin) << 8;\n\tratio = (ratio << 8) + DIV_ROUND_CLOSEST(tmp, fin);\n\n\tBDR = ratio;\n\tBDRI = (((state->config->xin << 5) / symbolrate) + 1) / 2;\n\n\tif (BDRI > 0xFF)\n\t\tBDRI = 0xFF;\n\n\tSFIL = (SFIL << 4) | ves1820_inittab[0x0E];\n\n\tNDEC = (NDEC << 6) | ves1820_inittab[0x03];\n\n\tves1820_writereg(state, 0x03, NDEC);\n\tves1820_writereg(state, 0x0a, BDR & 0xff);\n\tves1820_writereg(state, 0x0b, (BDR >> 8) & 0xff);\n\tves1820_writereg(state, 0x0c, (BDR >> 16) & 0x3f);\n\n\tves1820_writereg(state, 0x0d, BDRI);\n\tves1820_writereg(state, 0x0e, SFIL);\n\n\treturn 0;\n}\n\nstatic int ves1820_init(struct dvb_frontend* fe)\n{\n\tstruct ves1820_state* state = fe->demodulator_priv;\n\tint i;\n\n\tves1820_writereg(state, 0, 0);\n\n\tfor (i = 0; i < sizeof(ves1820_inittab); i++)\n\t\tves1820_writereg(state, i, ves1820_inittab[i]);\n\tif (state->config->selagc)\n\t\tves1820_writereg(state, 2, ves1820_inittab[2] | 0x08);\n\n\tves1820_writereg(state, 0x34, state->pwm);\n\n\treturn 0;\n}\n\nstatic int ves1820_set_parameters(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct ves1820_state* state = fe->demodulator_priv;\n\tstatic const u8 reg0x00[] = { 0x00, 0x04, 0x08, 0x0c, 0x10 };\n\tstatic const u8 reg0x01[] = { 140, 140, 106, 100, 92 };\n\tstatic const u8 reg0x05[] = { 135, 100, 70, 54, 38 };\n\tstatic const u8 reg0x08[] = { 162, 116, 67, 52, 35 };\n\tstatic const u8 reg0x09[] = { 145, 150, 106, 126, 107 };\n\tint real_qam = p->modulation - QAM_16;\n\n\tif (real_qam < 0 || real_qam > 4)\n\t\treturn -EINVAL;\n\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\tves1820_set_symbolrate(state, p->symbol_rate);\n\tves1820_writereg(state, 0x34, state->pwm);\n\n\tves1820_writereg(state, 0x01, reg0x01[real_qam]);\n\tves1820_writereg(state, 0x05, reg0x05[real_qam]);\n\tves1820_writereg(state, 0x08, reg0x08[real_qam]);\n\tves1820_writereg(state, 0x09, reg0x09[real_qam]);\n\n\tves1820_setup_reg0(state, reg0x00[real_qam], p->inversion);\n\tves1820_writereg(state, 2, ves1820_inittab[2] | (state->config->selagc ? 0x08 : 0));\n\treturn 0;\n}\n\nstatic int ves1820_read_status(struct dvb_frontend *fe,\n\t\t\t       enum fe_status *status)\n{\n\tstruct ves1820_state* state = fe->demodulator_priv;\n\tint sync;\n\n\t*status = 0;\n\tsync = ves1820_readreg(state, 0x11);\n\n\tif (sync & 1)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (sync & 2)\n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (sync & 2)\t \n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (sync & 4)\n\t\t*status |= FE_HAS_SYNC;\n\n\tif (sync & 8)\n\t\t*status |= FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int ves1820_read_ber(struct dvb_frontend* fe, u32* ber)\n{\n\tstruct ves1820_state* state = fe->demodulator_priv;\n\n\tu32 _ber = ves1820_readreg(state, 0x14) |\n\t\t\t(ves1820_readreg(state, 0x15) << 8) |\n\t\t\t((ves1820_readreg(state, 0x16) & 0x0f) << 16);\n\t*ber = 10 * _ber;\n\n\treturn 0;\n}\n\nstatic int ves1820_read_signal_strength(struct dvb_frontend* fe, u16* strength)\n{\n\tstruct ves1820_state* state = fe->demodulator_priv;\n\n\tu8 gain = ves1820_readreg(state, 0x17);\n\t*strength = (gain << 8) | gain;\n\n\treturn 0;\n}\n\nstatic int ves1820_read_snr(struct dvb_frontend* fe, u16* snr)\n{\n\tstruct ves1820_state* state = fe->demodulator_priv;\n\n\tu8 quality = ~ves1820_readreg(state, 0x18);\n\t*snr = (quality << 8) | quality;\n\n\treturn 0;\n}\n\nstatic int ves1820_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\n{\n\tstruct ves1820_state* state = fe->demodulator_priv;\n\n\t*ucblocks = ves1820_readreg(state, 0x13) & 0x7f;\n\tif (*ucblocks == 0x7f)\n\t\t*ucblocks = 0xffffffff;\n\n\t \n\tves1820_writereg(state, 0x10, ves1820_inittab[0x10] & 0xdf);\n\tves1820_writereg(state, 0x10, ves1820_inittab[0x10]);\n\n\treturn 0;\n}\n\nstatic int ves1820_get_frontend(struct dvb_frontend *fe,\n\t\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct ves1820_state* state = fe->demodulator_priv;\n\tint sync;\n\ts8 afc = 0;\n\n\tsync = ves1820_readreg(state, 0x11);\n\tafc = ves1820_readreg(state, 0x19);\n\tif (verbose) {\n\t\t \n\t\tprintk(sync & 2 ? \"ves1820: AFC (%d) %dHz\\n\" :\n\t\t\t\"ves1820: [AFC (%d) %dHz]\\n\", afc, -((s32) p->symbol_rate * afc) >> 10);\n\t}\n\n\tif (!state->config->invert) {\n\t\tp->inversion = (state->reg0 & 0x20) ? INVERSION_ON : INVERSION_OFF;\n\t} else {\n\t\tp->inversion = (!(state->reg0 & 0x20)) ? INVERSION_ON : INVERSION_OFF;\n\t}\n\n\tp->modulation = ((state->reg0 >> 2) & 7) + QAM_16;\n\n\tp->fec_inner = FEC_NONE;\n\n\tp->frequency = ((p->frequency + 31250) / 62500) * 62500;\n\tif (sync & 2)\n\t\tp->frequency -= ((s32) p->symbol_rate * afc) >> 10;\n\n\treturn 0;\n}\n\nstatic int ves1820_sleep(struct dvb_frontend* fe)\n{\n\tstruct ves1820_state* state = fe->demodulator_priv;\n\n\tves1820_writereg(state, 0x1b, 0x02);\t \n\tves1820_writereg(state, 0x00, 0x80);\t \n\n\treturn 0;\n}\n\nstatic int ves1820_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\n{\n\n\tfesettings->min_delay_ms = 200;\n\tfesettings->step_size = 0;\n\tfesettings->max_drift = 0;\n\treturn 0;\n}\n\nstatic void ves1820_release(struct dvb_frontend* fe)\n{\n\tstruct ves1820_state* state = fe->demodulator_priv;\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops ves1820_ops;\n\nstruct dvb_frontend* ves1820_attach(const struct ves1820_config* config,\n\t\t\t\t    struct i2c_adapter* i2c,\n\t\t\t\t    u8 pwm)\n{\n\tstruct ves1820_state* state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct ves1820_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto error;\n\n\t \n\tstate->reg0 = ves1820_inittab[0];\n\tstate->config = config;\n\tstate->i2c = i2c;\n\tstate->pwm = pwm;\n\n\t \n\tif ((ves1820_readreg(state, 0x1a) & 0xf0) != 0x70)\n\t\tgoto error;\n\n\tif (verbose)\n\t\tprintk(\"ves1820: pwm=0x%02x\\n\", state->pwm);\n\n\t \n\tmemcpy(&state->frontend.ops, &ves1820_ops, sizeof(struct dvb_frontend_ops));\n\tstate->frontend.ops.info.symbol_rate_min = (state->config->xin / 2) / 64;       \n\tstate->frontend.ops.info.symbol_rate_max = (state->config->xin / 2) / 4;        \n\tstate->frontend.demodulator_priv = state;\n\n\treturn &state->frontend;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\n\nstatic const struct dvb_frontend_ops ves1820_ops = {\n\t.delsys = { SYS_DVBC_ANNEX_A },\n\t.info = {\n\t\t.name = \"VLSI VES1820 DVB-C\",\n\t\t.frequency_min_hz =  47 * MHz,\n\t\t.frequency_max_hz = 862 * MHz,\n\t\t.frequency_stepsize_hz = 62500,\n\t\t.caps = FE_CAN_QAM_16 |\n\t\t\tFE_CAN_QAM_32 |\n\t\t\tFE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_128 |\n\t\t\tFE_CAN_QAM_256 |\n\t\t\tFE_CAN_FEC_AUTO\n\t},\n\n\t.release = ves1820_release,\n\n\t.init = ves1820_init,\n\t.sleep = ves1820_sleep,\n\n\t.set_frontend = ves1820_set_parameters,\n\t.get_frontend = ves1820_get_frontend,\n\t.get_tune_settings = ves1820_get_tune_settings,\n\n\t.read_status = ves1820_read_status,\n\t.read_ber = ves1820_read_ber,\n\t.read_signal_strength = ves1820_read_signal_strength,\n\t.read_snr = ves1820_read_snr,\n\t.read_ucblocks = ves1820_read_ucblocks,\n};\n\nmodule_param(verbose, int, 0644);\nMODULE_PARM_DESC(verbose, \"print AFC offset after tuning for debugging the PWM setting\");\n\nMODULE_DESCRIPTION(\"VLSI VES1820 DVB-C Demodulator driver\");\nMODULE_AUTHOR(\"Ralph Metzler, Holger Waechtler\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL_GPL(ves1820_attach);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}