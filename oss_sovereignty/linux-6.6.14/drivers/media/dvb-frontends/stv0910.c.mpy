{
  "module_name": "stv0910.c",
  "hash_id": "6c9398a9e8f370a68858df318581f472214961ee8fa8daa88392cf18d237334a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/stv0910.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <asm/div64.h>\n\n#include <media/dvb_frontend.h>\n#include \"stv0910.h\"\n#include \"stv0910_regs.h\"\n\n#define EXT_CLOCK    30000000\n#define TUNING_DELAY 200\n#define BER_SRC_S    0x20\n#define BER_SRC_S2   0x20\n\nstatic LIST_HEAD(stvlist);\n\nenum receive_mode { RCVMODE_NONE, RCVMODE_DVBS, RCVMODE_DVBS2, RCVMODE_AUTO };\n\nenum dvbs2_fectype { DVBS2_64K, DVBS2_16K };\n\nenum dvbs2_mod_cod {\n\tDVBS2_DUMMY_PLF, DVBS2_QPSK_1_4, DVBS2_QPSK_1_3, DVBS2_QPSK_2_5,\n\tDVBS2_QPSK_1_2, DVBS2_QPSK_3_5, DVBS2_QPSK_2_3,\tDVBS2_QPSK_3_4,\n\tDVBS2_QPSK_4_5,\tDVBS2_QPSK_5_6,\tDVBS2_QPSK_8_9,\tDVBS2_QPSK_9_10,\n\tDVBS2_8PSK_3_5,\tDVBS2_8PSK_2_3,\tDVBS2_8PSK_3_4,\tDVBS2_8PSK_5_6,\n\tDVBS2_8PSK_8_9,\tDVBS2_8PSK_9_10, DVBS2_16APSK_2_3, DVBS2_16APSK_3_4,\n\tDVBS2_16APSK_4_5, DVBS2_16APSK_5_6, DVBS2_16APSK_8_9, DVBS2_16APSK_9_10,\n\tDVBS2_32APSK_3_4, DVBS2_32APSK_4_5, DVBS2_32APSK_5_6, DVBS2_32APSK_8_9,\n\tDVBS2_32APSK_9_10\n};\n\nenum fe_stv0910_mod_cod {\n\tFE_DUMMY_PLF, FE_QPSK_14, FE_QPSK_13, FE_QPSK_25,\n\tFE_QPSK_12, FE_QPSK_35, FE_QPSK_23, FE_QPSK_34,\n\tFE_QPSK_45, FE_QPSK_56, FE_QPSK_89, FE_QPSK_910,\n\tFE_8PSK_35, FE_8PSK_23, FE_8PSK_34, FE_8PSK_56,\n\tFE_8PSK_89, FE_8PSK_910, FE_16APSK_23, FE_16APSK_34,\n\tFE_16APSK_45, FE_16APSK_56, FE_16APSK_89, FE_16APSK_910,\n\tFE_32APSK_34, FE_32APSK_45, FE_32APSK_56, FE_32APSK_89,\n\tFE_32APSK_910\n};\n\nenum fe_stv0910_roll_off { FE_SAT_35, FE_SAT_25, FE_SAT_20, FE_SAT_15 };\n\nstatic inline u32 muldiv32(u32 a, u32 b, u32 c)\n{\n\tu64 tmp64;\n\n\ttmp64 = (u64)a * (u64)b;\n\tdo_div(tmp64, c);\n\n\treturn (u32)tmp64;\n}\n\nstruct stv_base {\n\tstruct list_head     stvlist;\n\n\tu8                   adr;\n\tstruct i2c_adapter  *i2c;\n\tstruct mutex         i2c_lock;  \n\tstruct mutex         reg_lock;  \n\tint                  count;\n\n\tu32                  extclk;\n\tu32                  mclk;\n};\n\nstruct stv {\n\tstruct stv_base     *base;\n\tstruct dvb_frontend  fe;\n\tint                  nr;\n\tu16                  regoff;\n\tu8                   i2crpt;\n\tu8                   tscfgh;\n\tu8                   tsgeneral;\n\tu8                   tsspeed;\n\tu8                   single;\n\tunsigned long        tune_time;\n\n\ts32                  search_range;\n\tu32                  started;\n\tu32                  demod_lock_time;\n\tenum receive_mode    receive_mode;\n\tu32                  demod_timeout;\n\tu32                  fec_timeout;\n\tu32                  first_time_lock;\n\tu8                   demod_bits;\n\tu32                  symbol_rate;\n\n\tu8                       last_viterbi_rate;\n\tenum fe_code_rate        puncture_rate;\n\tenum fe_stv0910_mod_cod  mod_cod;\n\tenum dvbs2_fectype       fectype;\n\tu32                      pilots;\n\tenum fe_stv0910_roll_off feroll_off;\n\n\tint   is_standard_broadcast;\n\tint   is_vcm;\n\n\tu32   cur_scrambling_code;\n\n\tu32   last_bernumerator;\n\tu32   last_berdenominator;\n\tu8    berscale;\n\n\tu8    vth[6];\n};\n\nstruct sinit_table {\n\tu16  address;\n\tu8   data;\n};\n\nstruct slookup {\n\ts16  value;\n\tu32  reg_value;\n};\n\nstatic int write_reg(struct stv *state, u16 reg, u8 val)\n{\n\tstruct i2c_adapter *adap = state->base->i2c;\n\tu8 data[3] = {reg >> 8, reg & 0xff, val};\n\tstruct i2c_msg msg = {.addr = state->base->adr, .flags = 0,\n\t\t\t      .buf = data, .len = 3};\n\n\tif (i2c_transfer(adap, &msg, 1) != 1) {\n\t\tdev_warn(&adap->dev, \"i2c write error ([%02x] %04x: %02x)\\n\",\n\t\t\t state->base->adr, reg, val);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic inline int i2c_read_regs16(struct i2c_adapter *adapter, u8 adr,\n\t\t\t\t  u16 reg, u8 *val, int count)\n{\n\tu8 msg[2] = {reg >> 8, reg & 0xff};\n\tstruct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,\n\t\t\t\t   .buf  = msg, .len   = 2},\n\t\t\t\t  {.addr = adr, .flags = I2C_M_RD,\n\t\t\t\t   .buf  = val, .len   = count } };\n\n\tif (i2c_transfer(adapter, msgs, 2) != 2) {\n\t\tdev_warn(&adapter->dev, \"i2c read error ([%02x] %04x)\\n\",\n\t\t\t adr, reg);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int read_reg(struct stv *state, u16 reg, u8 *val)\n{\n\treturn i2c_read_regs16(state->base->i2c, state->base->adr,\n\t\t\t       reg, val, 1);\n}\n\nstatic int read_regs(struct stv *state, u16 reg, u8 *val, int len)\n{\n\treturn i2c_read_regs16(state->base->i2c, state->base->adr,\n\t\t\t       reg, val, len);\n}\n\nstatic int write_shared_reg(struct stv *state, u16 reg, u8 mask, u8 val)\n{\n\tint status;\n\tu8 tmp;\n\n\tmutex_lock(&state->base->reg_lock);\n\tstatus = read_reg(state, reg, &tmp);\n\tif (!status)\n\t\tstatus = write_reg(state, reg, (tmp & ~mask) | (val & mask));\n\tmutex_unlock(&state->base->reg_lock);\n\treturn status;\n}\n\nstatic int write_field(struct stv *state, u32 field, u8 val)\n{\n\tint status;\n\tu8 shift, mask, old, new;\n\n\tstatus = read_reg(state, field >> 16, &old);\n\tif (status)\n\t\treturn status;\n\tmask = field & 0xff;\n\tshift = (field >> 12) & 0xf;\n\tnew = ((val << shift) & mask) | (old & ~mask);\n\tif (new == old)\n\t\treturn 0;\n\treturn write_reg(state, field >> 16, new);\n}\n\n#define SET_FIELD(_reg, _val)\t\t\t\t\t\\\n\twrite_field(state, state->nr ? FSTV0910_P2_##_reg :\t\\\n\t\t    FSTV0910_P1_##_reg, _val)\n\n#define SET_REG(_reg, _val)\t\t\t\t\t\\\n\twrite_reg(state, state->nr ? RSTV0910_P2_##_reg :\t\\\n\t\t  RSTV0910_P1_##_reg, _val)\n\n#define GET_REG(_reg, _val)\t\t\t\t\t\\\n\tread_reg(state, state->nr ? RSTV0910_P2_##_reg :\t\\\n\t\t RSTV0910_P1_##_reg, _val)\n\nstatic const struct slookup s1_sn_lookup[] = {\n\t{   0,    9242  },  \n\t{   5,    9105  },  \n\t{  10,    8950  },  \n\t{  15,    8780  },  \n\t{  20,    8566  },  \n\t{  25,    8366  },  \n\t{  30,    8146  },  \n\t{  35,    7908  },  \n\t{  40,    7666  },  \n\t{  45,    7405  },  \n\t{  50,    7136  },  \n\t{  55,    6861  },  \n\t{  60,    6576  },  \n\t{  65,    6330  },  \n\t{  70,    6048  },  \n\t{  75,    5768  },  \n\t{  80,    5492  },  \n\t{  85,    5224  },  \n\t{  90,    4959  },  \n\t{  95,    4709  },  \n\t{  100,   4467  },  \n\t{  105,   4236  },  \n\t{  110,   4013  },  \n\t{  115,   3800  },  \n\t{  120,   3598  },  \n\t{  125,   3406  },  \n\t{  130,   3225  },  \n\t{  135,   3052  },  \n\t{  140,   2889  },  \n\t{  145,   2733  },  \n\t{  150,   2587  },  \n\t{  160,   2318  },  \n\t{  170,   2077  },  \n\t{  180,   1862  },  \n\t{  190,   1670  },  \n\t{  200,   1499  },  \n\t{  210,   1347  },  \n\t{  220,   1213  },  \n\t{  230,   1095  },  \n\t{  240,    992  },  \n\t{  250,    900  },  \n\t{  260,    826  },  \n\t{  270,    758  },  \n\t{  280,    702  },  \n\t{  290,    653  },  \n\t{  300,    613  },  \n\t{  310,    579  },  \n\t{  320,    550  },  \n\t{  330,    526  },  \n\t{  350,    490  },  \n\t{  400,    445  },  \n\t{  450,    430  },  \n\t{  500,    426  },  \n\t{  510,    425  }   \n};\n\nstatic const struct slookup s2_sn_lookup[] = {\n\t{  -30,  13950  },  \n\t{  -25,  13580  },  \n\t{  -20,  13150  },  \n\t{  -15,  12760  },  \n\t{  -10,  12345  },  \n\t{   -5,  11900  },  \n\t{    0,  11520  },  \n\t{    5,  11080  },  \n\t{   10,  10630  },  \n\t{   15,  10210  },  \n\t{   20,   9790  },  \n\t{   25,   9390  },  \n\t{   30,   8970  },  \n\t{   35,   8575  },  \n\t{   40,   8180  },  \n\t{   45,   7800  },  \n\t{   50,   7430  },  \n\t{   55,   7080  },  \n\t{   60,   6720  },  \n\t{   65,   6320  },  \n\t{   70,   6060  },  \n\t{   75,   5760  },  \n\t{   80,   5480  },  \n\t{   85,   5200  },  \n\t{   90,   4930  },  \n\t{   95,   4680  },  \n\t{  100,   4425  },  \n\t{  105,   4210  },  \n\t{  110,   3980  },  \n\t{  115,   3765  },  \n\t{  120,   3570  },  \n\t{  125,   3315  },  \n\t{  130,   3140  },  \n\t{  135,   2980  },  \n\t{  140,   2820  },  \n\t{  145,   2670  },  \n\t{  150,   2535  },  \n\t{  160,   2270  },  \n\t{  170,   2035  },  \n\t{  180,   1825  },  \n\t{  190,   1650  },  \n\t{  200,   1485  },  \n\t{  210,   1340  },  \n\t{  220,   1212  },  \n\t{  230,   1100  },  \n\t{  240,   1000  },  \n\t{  250,    910  },  \n\t{  260,    836  },  \n\t{  270,    772  },  \n\t{  280,    718  },  \n\t{  290,    671  },  \n\t{  300,    635  },  \n\t{  310,    602  },  \n\t{  320,    575  },  \n\t{  330,    550  },  \n\t{  350,    517  },  \n\t{  400,    480  },  \n\t{  450,    466  },  \n\t{  500,    464  },  \n\t{  510,    463  },  \n};\n\nstatic const struct slookup padc_lookup[] = {\n\t{    0,  118000 },  \n\t{ -100,  93600  },  \n\t{ -200,  74500  },  \n\t{ -300,  59100  },  \n\t{ -400,  47000  },  \n\t{ -500,  37300  },  \n\t{ -600,  29650  },  \n\t{ -700,  23520  },  \n\t{ -900,  14850  },  \n\t{ -1100, 9380   },  \n\t{ -1300, 5910   },  \n\t{ -1500, 3730   },  \n\t{ -1700, 2354   },  \n\t{ -1900, 1485   },  \n\t{ -2000, 1179   },  \n\t{ -2100, 1000   },  \n};\n\n \nstatic const u8 s2car_loop[] =\t{\n\t \n\n\t \n\t0x0C,  0x3C,  0x0B,  0x3C,  0x2A,  0x2C,  0x2A,  0x1C,  0x3A,  0x3B,\n\t \n\t0x0C,  0x3C,  0x0B,  0x3C,  0x2A,  0x2C,  0x3A,  0x0C,  0x3A,  0x2B,\n\t \n\t0x1C,  0x3C,  0x1B,  0x3C,  0x3A,  0x1C,  0x3A,  0x3B,  0x3A,  0x2B,\n\t \n\t0x0C,  0x1C,  0x2B,  0x1C,  0x0B,  0x2C,  0x0B,  0x0C,  0x2A,  0x2B,\n\t \n\t0x1C,  0x1C,  0x2B,  0x1C,  0x0B,  0x2C,  0x0B,  0x0C,  0x2A,  0x2B,\n\t \n\t0x2C,  0x2C,  0x2B,  0x1C,  0x0B,  0x2C,  0x0B,  0x0C,  0x2A,  0x2B,\n\t \n\t0x3C,  0x2C,  0x3B,  0x2C,  0x1B,  0x1C,  0x1B,  0x3B,  0x3A,  0x1B,\n\t \n\t0x0D,  0x3C,  0x3B,  0x2C,  0x1B,  0x1C,  0x1B,  0x3B,  0x3A,  0x1B,\n\t \n\t0x1D,  0x3C,  0x0C,  0x2C,  0x2B,  0x1C,  0x1B,  0x3B,  0x0B,  0x1B,\n\t \n\t0x3D,  0x0D,  0x0C,  0x2C,  0x2B,  0x0C,  0x2B,  0x2B,  0x0B,  0x0B,\n\t \n\t0x1E,  0x0D,  0x1C,  0x2C,  0x3B,  0x0C,  0x2B,  0x2B,  0x1B,  0x0B,\n\t \n\t0x28,  0x09,  0x28,  0x09,  0x28,  0x09,  0x28,  0x08,  0x28,  0x27,\n\t \n\t0x19,  0x29,  0x19,  0x29,  0x19,  0x29,  0x38,  0x19,  0x28,  0x09,\n\t \n\t0x1A,  0x0B,  0x1A,  0x3A,  0x0A,  0x2A,  0x39,  0x2A,  0x39,  0x1A,\n\t \n\t0x2B,  0x2B,  0x1B,  0x1B,  0x0B,  0x1B,  0x1A,  0x0B,  0x1A,  0x1A,\n\t \n\t0x0C,  0x0C,  0x3B,  0x3B,  0x1B,  0x1B,  0x2A,  0x0B,  0x2A,  0x2A,\n\t \n\t0x0C,  0x1C,  0x0C,  0x3B,  0x2B,  0x1B,  0x3A,  0x0B,  0x2A,  0x2A,\n\n\t \n\n\t \n\n\t \n\t0x0A,  0x0A,  0x0A,  0x0A,  0x1A,  0x0A,  0x39,  0x0A,  0x29,  0x0A,\n\t \n\t0x0A,  0x0A,  0x0A,  0x0A,  0x0B,  0x0A,  0x2A,  0x0A,  0x1A,  0x0A,\n\t \n\t0x0A,  0x0A,  0x0A,  0x0A,  0x1B,  0x0A,  0x3A,  0x0A,  0x2A,  0x0A,\n\t \n\t0x0A,  0x0A,  0x0A,  0x0A,  0x1B,  0x0A,  0x3A,  0x0A,  0x2A,  0x0A,\n\t \n\t0x0A,  0x0A,  0x0A,  0x0A,  0x2B,  0x0A,  0x0B,  0x0A,  0x3A,  0x0A,\n\t \n\t0x0A,  0x0A,  0x0A,  0x0A,  0x2B,  0x0A,  0x0B,  0x0A,  0x3A,  0x0A,\n\t \n\t0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,\n\t \n\t0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,\n\t \n\t0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,\n\t \n\t0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,\n\t \n\t0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,\n};\n\nstatic u8 get_optim_cloop(struct stv *state,\n\t\t\t  enum fe_stv0910_mod_cod mod_cod, u32 pilots)\n{\n\tint i = 0;\n\n\tif (mod_cod >= FE_32APSK_910)\n\t\ti = ((int)FE_32APSK_910 - (int)FE_QPSK_14) * 10;\n\telse if (mod_cod >= FE_QPSK_14)\n\t\ti = ((int)mod_cod - (int)FE_QPSK_14) * 10;\n\n\tif (state->symbol_rate <= 3000000)\n\t\ti += 0;\n\telse if (state->symbol_rate <=  7000000)\n\t\ti += 2;\n\telse if (state->symbol_rate <= 15000000)\n\t\ti += 4;\n\telse if (state->symbol_rate <= 25000000)\n\t\ti += 6;\n\telse\n\t\ti += 8;\n\n\tif (!pilots)\n\t\ti += 1;\n\n\treturn s2car_loop[i];\n}\n\nstatic int get_cur_symbol_rate(struct stv *state, u32 *p_symbol_rate)\n{\n\tint status = 0;\n\tu8 symb_freq0;\n\tu8 symb_freq1;\n\tu8 symb_freq2;\n\tu8 symb_freq3;\n\tu8 tim_offs0;\n\tu8 tim_offs1;\n\tu8 tim_offs2;\n\tu32 symbol_rate;\n\ts32 timing_offset;\n\n\t*p_symbol_rate = 0;\n\tif (!state->started)\n\t\treturn status;\n\n\tread_reg(state, RSTV0910_P2_SFR3 + state->regoff, &symb_freq3);\n\tread_reg(state, RSTV0910_P2_SFR2 + state->regoff, &symb_freq2);\n\tread_reg(state, RSTV0910_P2_SFR1 + state->regoff, &symb_freq1);\n\tread_reg(state, RSTV0910_P2_SFR0 + state->regoff, &symb_freq0);\n\tread_reg(state, RSTV0910_P2_TMGREG2 + state->regoff, &tim_offs2);\n\tread_reg(state, RSTV0910_P2_TMGREG1 + state->regoff, &tim_offs1);\n\tread_reg(state, RSTV0910_P2_TMGREG0 + state->regoff, &tim_offs0);\n\n\tsymbol_rate = ((u32)symb_freq3 << 24) | ((u32)symb_freq2 << 16) |\n\t\t((u32)symb_freq1 << 8) | (u32)symb_freq0;\n\ttiming_offset = ((u32)tim_offs2 << 16) | ((u32)tim_offs1 << 8) |\n\t\t(u32)tim_offs0;\n\n\tif ((timing_offset & (1 << 23)) != 0)\n\t\ttiming_offset |= 0xFF000000;  \n\n\tsymbol_rate = (u32)(((u64)symbol_rate * state->base->mclk) >> 32);\n\ttiming_offset = (s32)(((s64)symbol_rate * (s64)timing_offset) >> 29);\n\n\t*p_symbol_rate = symbol_rate + timing_offset;\n\n\treturn 0;\n}\n\nstatic int get_signal_parameters(struct stv *state)\n{\n\tu8 tmp;\n\n\tif (!state->started)\n\t\treturn -EINVAL;\n\n\tif (state->receive_mode == RCVMODE_DVBS2) {\n\t\tread_reg(state, RSTV0910_P2_DMDMODCOD + state->regoff, &tmp);\n\t\tstate->mod_cod = (enum fe_stv0910_mod_cod)((tmp & 0x7c) >> 2);\n\t\tstate->pilots = (tmp & 0x01) != 0;\n\t\tstate->fectype = (enum dvbs2_fectype)((tmp & 0x02) >> 1);\n\n\t} else if (state->receive_mode == RCVMODE_DVBS) {\n\t\tread_reg(state, RSTV0910_P2_VITCURPUN + state->regoff, &tmp);\n\t\tstate->puncture_rate = FEC_NONE;\n\t\tswitch (tmp & 0x1F) {\n\t\tcase 0x0d:\n\t\t\tstate->puncture_rate = FEC_1_2;\n\t\t\tbreak;\n\t\tcase 0x12:\n\t\t\tstate->puncture_rate = FEC_2_3;\n\t\t\tbreak;\n\t\tcase 0x15:\n\t\t\tstate->puncture_rate = FEC_3_4;\n\t\t\tbreak;\n\t\tcase 0x18:\n\t\t\tstate->puncture_rate = FEC_5_6;\n\t\t\tbreak;\n\t\tcase 0x1a:\n\t\t\tstate->puncture_rate = FEC_7_8;\n\t\t\tbreak;\n\t\t}\n\t\tstate->is_vcm = 0;\n\t\tstate->is_standard_broadcast = 1;\n\t\tstate->feroll_off = FE_SAT_35;\n\t}\n\treturn 0;\n}\n\nstatic int tracking_optimization(struct stv *state)\n{\n\tu8 tmp;\n\n\tread_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff, &tmp);\n\ttmp &= ~0xC0;\n\n\tswitch (state->receive_mode) {\n\tcase RCVMODE_DVBS:\n\t\ttmp |= 0x40;\n\t\tbreak;\n\tcase RCVMODE_DVBS2:\n\t\ttmp |= 0x80;\n\t\tbreak;\n\tdefault:\n\t\ttmp |= 0xC0;\n\t\tbreak;\n\t}\n\twrite_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff, tmp);\n\n\tif (state->receive_mode == RCVMODE_DVBS2) {\n\t\t \n\t\twrite_shared_reg(state,\n\t\t\t\t RSTV0910_TSTTSRS, state->nr ? 0x02 : 0x01,\n\t\t\t\t 0x03);\n\n\t\tif (state->fectype == DVBS2_64K) {\n\t\t\tu8 aclc = get_optim_cloop(state, state->mod_cod,\n\t\t\t\t\t\t  state->pilots);\n\n\t\t\tif (state->mod_cod <= FE_QPSK_910) {\n\t\t\t\twrite_reg(state, RSTV0910_P2_ACLC2S2Q +\n\t\t\t\t\t  state->regoff, aclc);\n\t\t\t} else if (state->mod_cod <= FE_8PSK_910) {\n\t\t\t\twrite_reg(state, RSTV0910_P2_ACLC2S2Q +\n\t\t\t\t\t  state->regoff, 0x2a);\n\t\t\t\twrite_reg(state, RSTV0910_P2_ACLC2S28 +\n\t\t\t\t\t  state->regoff, aclc);\n\t\t\t} else if (state->mod_cod <= FE_16APSK_910) {\n\t\t\t\twrite_reg(state, RSTV0910_P2_ACLC2S2Q +\n\t\t\t\t\t  state->regoff, 0x2a);\n\t\t\t\twrite_reg(state, RSTV0910_P2_ACLC2S216A +\n\t\t\t\t\t  state->regoff, aclc);\n\t\t\t} else if (state->mod_cod <= FE_32APSK_910) {\n\t\t\t\twrite_reg(state, RSTV0910_P2_ACLC2S2Q +\n\t\t\t\t\t  state->regoff, 0x2a);\n\t\t\t\twrite_reg(state, RSTV0910_P2_ACLC2S232A +\n\t\t\t\t\t  state->regoff, aclc);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic s32 table_lookup(const struct slookup *table,\n\t\t\tint table_size, u32 reg_value)\n{\n\ts32 value;\n\tint imin = 0;\n\tint imax = table_size - 1;\n\tint i;\n\ts32 reg_diff;\n\n\t \n\tif (reg_value >= table[0].reg_value) {\n\t\tvalue = table[0].value;\n\t} else if (reg_value <= table[imax].reg_value) {\n\t\tvalue = table[imax].value;\n\t} else {\n\t\twhile ((imax - imin) > 1) {\n\t\t\ti = (imax + imin) / 2;\n\t\t\tif ((table[imin].reg_value >= reg_value) &&\n\t\t\t    (reg_value >= table[i].reg_value))\n\t\t\t\timax = i;\n\t\t\telse\n\t\t\t\timin = i;\n\t\t}\n\n\t\treg_diff = table[imax].reg_value - table[imin].reg_value;\n\t\tvalue = table[imin].value;\n\t\tif (reg_diff != 0)\n\t\t\tvalue += ((s32)(reg_value - table[imin].reg_value) *\n\t\t\t\t  (s32)(table[imax].value\n\t\t\t\t\t- table[imin].value))\n\t\t\t\t\t/ (reg_diff);\n\t}\n\n\treturn value;\n}\n\nstatic int get_signal_to_noise(struct stv *state, s32 *signal_to_noise)\n{\n\tu8 data0;\n\tu8 data1;\n\tu16 data;\n\tint n_lookup;\n\tconst struct slookup *lookup;\n\n\t*signal_to_noise = 0;\n\n\tif (!state->started)\n\t\treturn -EINVAL;\n\n\tif (state->receive_mode == RCVMODE_DVBS2) {\n\t\tread_reg(state, RSTV0910_P2_NNOSPLHT1 + state->regoff,\n\t\t\t &data1);\n\t\tread_reg(state, RSTV0910_P2_NNOSPLHT0 + state->regoff,\n\t\t\t &data0);\n\t\tn_lookup = ARRAY_SIZE(s2_sn_lookup);\n\t\tlookup = s2_sn_lookup;\n\t} else {\n\t\tread_reg(state, RSTV0910_P2_NNOSDATAT1 + state->regoff,\n\t\t\t &data1);\n\t\tread_reg(state, RSTV0910_P2_NNOSDATAT0 + state->regoff,\n\t\t\t &data0);\n\t\tn_lookup = ARRAY_SIZE(s1_sn_lookup);\n\t\tlookup = s1_sn_lookup;\n\t}\n\tdata = (((u16)data1) << 8) | (u16)data0;\n\t*signal_to_noise = table_lookup(lookup, n_lookup, data);\n\treturn 0;\n}\n\nstatic int get_bit_error_rate_s(struct stv *state, u32 *bernumerator,\n\t\t\t\tu32 *berdenominator)\n{\n\tu8 regs[3];\n\n\tint status = read_regs(state,\n\t\t\t       RSTV0910_P2_ERRCNT12 + state->regoff,\n\t\t\t       regs, 3);\n\n\tif (status)\n\t\treturn -EINVAL;\n\n\tif ((regs[0] & 0x80) == 0) {\n\t\tstate->last_berdenominator = 1ULL << ((state->berscale * 2) +\n\t\t\t\t\t\t     10 + 3);\n\t\tstate->last_bernumerator = ((u32)(regs[0] & 0x7F) << 16) |\n\t\t\t((u32)regs[1] << 8) | regs[2];\n\t\tif (state->last_bernumerator < 256 && state->berscale < 6) {\n\t\t\tstate->berscale += 1;\n\t\t\tstatus = write_reg(state, RSTV0910_P2_ERRCTRL1 +\n\t\t\t\t\t   state->regoff,\n\t\t\t\t\t   0x20 | state->berscale);\n\t\t} else if (state->last_bernumerator > 1024 &&\n\t\t\t   state->berscale > 2) {\n\t\t\tstate->berscale -= 1;\n\t\t\tstatus = write_reg(state, RSTV0910_P2_ERRCTRL1 +\n\t\t\t\t\t   state->regoff, 0x20 |\n\t\t\t\t\t   state->berscale);\n\t\t}\n\t}\n\t*bernumerator = state->last_bernumerator;\n\t*berdenominator = state->last_berdenominator;\n\treturn 0;\n}\n\nstatic u32 dvbs2_nbch(enum dvbs2_mod_cod mod_cod, enum dvbs2_fectype fectype)\n{\n\tstatic const u32 nbch[][2] = {\n\t\t{    0,     0},  \n\t\t{16200,  3240},  \n\t\t{21600,  5400},  \n\t\t{25920,  6480},  \n\t\t{32400,  7200},  \n\t\t{38880,  9720},  \n\t\t{43200, 10800},  \n\t\t{48600, 11880},  \n\t\t{51840, 12600},  \n\t\t{54000, 13320},  \n\t\t{57600, 14400},  \n\t\t{58320, 16000},  \n\t\t{43200,  9720},  \n\t\t{48600, 10800},  \n\t\t{51840, 11880},  \n\t\t{54000, 13320},  \n\t\t{57600, 14400},  \n\t\t{58320, 16000},  \n\t\t{43200, 10800},  \n\t\t{48600, 11880},  \n\t\t{51840, 12600},  \n\t\t{54000, 13320},  \n\t\t{57600, 14400},  \n\t\t{58320, 16000},  \n\t\t{48600, 11880},  \n\t\t{51840, 12600},  \n\t\t{54000, 13320},  \n\t\t{57600, 14400},  \n\t\t{58320, 16000},  \n\t};\n\n\tif (mod_cod >= DVBS2_QPSK_1_4 &&\n\t    mod_cod <= DVBS2_32APSK_9_10 && fectype <= DVBS2_16K)\n\t\treturn nbch[mod_cod][fectype];\n\treturn 64800;\n}\n\nstatic int get_bit_error_rate_s2(struct stv *state, u32 *bernumerator,\n\t\t\t\t u32 *berdenominator)\n{\n\tu8 regs[3];\n\n\tint status = read_regs(state, RSTV0910_P2_ERRCNT12 + state->regoff,\n\t\t\t       regs, 3);\n\n\tif (status)\n\t\treturn -EINVAL;\n\n\tif ((regs[0] & 0x80) == 0) {\n\t\tstate->last_berdenominator =\n\t\t\tdvbs2_nbch((enum dvbs2_mod_cod)state->mod_cod,\n\t\t\t\t   state->fectype) <<\n\t\t\t(state->berscale * 2);\n\t\tstate->last_bernumerator = (((u32)regs[0] & 0x7F) << 16) |\n\t\t\t((u32)regs[1] << 8) | regs[2];\n\t\tif (state->last_bernumerator < 256 && state->berscale < 6) {\n\t\t\tstate->berscale += 1;\n\t\t\twrite_reg(state, RSTV0910_P2_ERRCTRL1 + state->regoff,\n\t\t\t\t  0x20 | state->berscale);\n\t\t} else if (state->last_bernumerator > 1024 &&\n\t\t\t   state->berscale > 2) {\n\t\t\tstate->berscale -= 1;\n\t\t\twrite_reg(state, RSTV0910_P2_ERRCTRL1 + state->regoff,\n\t\t\t\t  0x20 | state->berscale);\n\t\t}\n\t}\n\t*bernumerator = state->last_bernumerator;\n\t*berdenominator = state->last_berdenominator;\n\treturn status;\n}\n\nstatic int get_bit_error_rate(struct stv *state, u32 *bernumerator,\n\t\t\t      u32 *berdenominator)\n{\n\t*bernumerator = 0;\n\t*berdenominator = 1;\n\n\tswitch (state->receive_mode) {\n\tcase RCVMODE_DVBS:\n\t\treturn get_bit_error_rate_s(state,\n\t\t\t\t\t    bernumerator, berdenominator);\n\tcase RCVMODE_DVBS2:\n\t\treturn get_bit_error_rate_s2(state,\n\t\t\t\t\t     bernumerator, berdenominator);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int set_mclock(struct stv *state, u32 master_clock)\n{\n\tu32 idf = 1;\n\tu32 odf = 4;\n\tu32 quartz = state->base->extclk / 1000000;\n\tu32 fphi = master_clock / 1000000;\n\tu32 ndiv = (fphi * odf * idf) / quartz;\n\tu32 cp = 7;\n\tu32 fvco;\n\n\tif (ndiv >= 7 && ndiv <= 71)\n\t\tcp = 7;\n\telse if (ndiv >=  72 && ndiv <=  79)\n\t\tcp = 8;\n\telse if (ndiv >=  80 && ndiv <=  87)\n\t\tcp = 9;\n\telse if (ndiv >=  88 && ndiv <=  95)\n\t\tcp = 10;\n\telse if (ndiv >=  96 && ndiv <= 103)\n\t\tcp = 11;\n\telse if (ndiv >= 104 && ndiv <= 111)\n\t\tcp = 12;\n\telse if (ndiv >= 112 && ndiv <= 119)\n\t\tcp = 13;\n\telse if (ndiv >= 120 && ndiv <= 127)\n\t\tcp = 14;\n\telse if (ndiv >= 128 && ndiv <= 135)\n\t\tcp = 15;\n\telse if (ndiv >= 136 && ndiv <= 143)\n\t\tcp = 16;\n\telse if (ndiv >= 144 && ndiv <= 151)\n\t\tcp = 17;\n\telse if (ndiv >= 152 && ndiv <= 159)\n\t\tcp = 18;\n\telse if (ndiv >= 160 && ndiv <= 167)\n\t\tcp = 19;\n\telse if (ndiv >= 168 && ndiv <= 175)\n\t\tcp = 20;\n\telse if (ndiv >= 176 && ndiv <= 183)\n\t\tcp = 21;\n\telse if (ndiv >= 184 && ndiv <= 191)\n\t\tcp = 22;\n\telse if (ndiv >= 192 && ndiv <= 199)\n\t\tcp = 23;\n\telse if (ndiv >= 200 && ndiv <= 207)\n\t\tcp = 24;\n\telse if (ndiv >= 208 && ndiv <= 215)\n\t\tcp = 25;\n\telse if (ndiv >= 216 && ndiv <= 223)\n\t\tcp = 26;\n\telse if (ndiv >= 224 && ndiv <= 225)\n\t\tcp = 27;\n\n\twrite_reg(state, RSTV0910_NCOARSE, (cp << 3) | idf);\n\twrite_reg(state, RSTV0910_NCOARSE2, odf);\n\twrite_reg(state, RSTV0910_NCOARSE1, ndiv);\n\n\tfvco = (quartz * 2 * ndiv) / idf;\n\tstate->base->mclk = fvco / (2 * odf) * 1000000;\n\n\treturn 0;\n}\n\nstatic int stop(struct stv *state)\n{\n\tif (state->started) {\n\t\tu8 tmp;\n\n\t\twrite_reg(state, RSTV0910_P2_TSCFGH + state->regoff,\n\t\t\t  state->tscfgh | 0x01);\n\t\tread_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, &tmp);\n\t\ttmp &= ~0x01;  \n\t\twrite_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, tmp);\n\t\t \n\t\twrite_reg(state, RSTV0910_P2_AGC2O + state->regoff, 0x5B);\n\t\t \n\t\twrite_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x5c);\n\t\tstate->started = 0;\n\t}\n\tstate->receive_mode = RCVMODE_NONE;\n\treturn 0;\n}\n\nstatic void set_pls(struct stv *state, u32 pls_code)\n{\n\tif (pls_code == state->cur_scrambling_code)\n\t\treturn;\n\n\t \n\twrite_reg(state, RSTV0910_P2_PLROOT0 + state->regoff,\n\t\t  pls_code & 0xff);\n\twrite_reg(state, RSTV0910_P2_PLROOT1 + state->regoff,\n\t\t  (pls_code >> 8) & 0xff);\n\twrite_reg(state, RSTV0910_P2_PLROOT2 + state->regoff,\n\t\t  0x04 | ((pls_code >> 16) & 0x03));\n\tstate->cur_scrambling_code = pls_code;\n}\n\nstatic void set_isi(struct stv *state, u32 isi)\n{\n\tif (isi == NO_STREAM_ID_FILTER)\n\t\treturn;\n\tif (isi == 0x80000000) {\n\t\tSET_FIELD(FORCE_CONTINUOUS, 1);\n\t\tSET_FIELD(TSOUT_NOSYNC, 1);\n\t} else {\n\t\tSET_FIELD(FILTER_EN, 1);\n\t\twrite_reg(state, RSTV0910_P2_ISIENTRY + state->regoff,\n\t\t\t  isi & 0xff);\n\t\twrite_reg(state, RSTV0910_P2_ISIBITENA + state->regoff, 0xff);\n\t}\n\tSET_FIELD(ALGOSWRST, 1);\n\tSET_FIELD(ALGOSWRST, 0);\n}\n\nstatic void set_stream_modes(struct stv *state,\n\t\t\t     struct dtv_frontend_properties *p)\n{\n\tset_isi(state, p->stream_id);\n\tset_pls(state, p->scrambling_sequence_index);\n}\n\nstatic int init_search_param(struct stv *state,\n\t\t\t     struct dtv_frontend_properties *p)\n{\n\tSET_FIELD(FORCE_CONTINUOUS, 0);\n\tSET_FIELD(FRAME_MODE, 0);\n\tSET_FIELD(FILTER_EN, 0);\n\tSET_FIELD(TSOUT_NOSYNC, 0);\n\tSET_FIELD(TSFIFO_EMBINDVB, 0);\n\tSET_FIELD(TSDEL_SYNCBYTE, 0);\n\tSET_REG(UPLCCST0, 0xe0);\n\tSET_FIELD(TSINS_TOKEN, 0);\n\tSET_FIELD(HYSTERESIS_THRESHOLD, 0);\n\tSET_FIELD(ISIOBS_MODE, 1);\n\n\tset_stream_modes(state, p);\n\treturn 0;\n}\n\nstatic int enable_puncture_rate(struct stv *state, enum fe_code_rate rate)\n{\n\tu8 val;\n\n\tswitch (rate) {\n\tcase FEC_1_2:\n\t\tval = 0x01;\n\t\tbreak;\n\tcase FEC_2_3:\n\t\tval = 0x02;\n\t\tbreak;\n\tcase FEC_3_4:\n\t\tval = 0x04;\n\t\tbreak;\n\tcase FEC_5_6:\n\t\tval = 0x08;\n\t\tbreak;\n\tcase FEC_7_8:\n\t\tval = 0x20;\n\t\tbreak;\n\tcase FEC_NONE:\n\tdefault:\n\t\tval = 0x2f;\n\t\tbreak;\n\t}\n\n\treturn write_reg(state, RSTV0910_P2_PRVIT + state->regoff, val);\n}\n\nstatic int set_vth_default(struct stv *state)\n{\n\tstate->vth[0] = 0xd7;\n\tstate->vth[1] = 0x85;\n\tstate->vth[2] = 0x58;\n\tstate->vth[3] = 0x3a;\n\tstate->vth[4] = 0x34;\n\tstate->vth[5] = 0x28;\n\twrite_reg(state, RSTV0910_P2_VTH12 + state->regoff + 0, state->vth[0]);\n\twrite_reg(state, RSTV0910_P2_VTH12 + state->regoff + 1, state->vth[1]);\n\twrite_reg(state, RSTV0910_P2_VTH12 + state->regoff + 2, state->vth[2]);\n\twrite_reg(state, RSTV0910_P2_VTH12 + state->regoff + 3, state->vth[3]);\n\twrite_reg(state, RSTV0910_P2_VTH12 + state->regoff + 4, state->vth[4]);\n\twrite_reg(state, RSTV0910_P2_VTH12 + state->regoff + 5, state->vth[5]);\n\treturn 0;\n}\n\nstatic int set_vth(struct stv *state)\n{\n\tstatic const struct slookup vthlookup_table[] = {\n\t\t{250,\t8780},  \n\t\t{100,\t7405},  \n\t\t{40,\t6330},  \n\t\t{12,\t5224},  \n\t\t{5,\t4236}   \n\t};\n\n\tint i;\n\tu8 tmp[2];\n\tint status = read_regs(state,\n\t\t\t       RSTV0910_P2_NNOSDATAT1 + state->regoff,\n\t\t\t       tmp, 2);\n\tu16 reg_value = (tmp[0] << 8) | tmp[1];\n\ts32 vth = table_lookup(vthlookup_table, ARRAY_SIZE(vthlookup_table),\n\t\t\t      reg_value);\n\n\tfor (i = 0; i < 6; i += 1)\n\t\tif (state->vth[i] > vth)\n\t\t\tstate->vth[i] = vth;\n\n\twrite_reg(state, RSTV0910_P2_VTH12 + state->regoff + 0, state->vth[0]);\n\twrite_reg(state, RSTV0910_P2_VTH12 + state->regoff + 1, state->vth[1]);\n\twrite_reg(state, RSTV0910_P2_VTH12 + state->regoff + 2, state->vth[2]);\n\twrite_reg(state, RSTV0910_P2_VTH12 + state->regoff + 3, state->vth[3]);\n\twrite_reg(state, RSTV0910_P2_VTH12 + state->regoff + 4, state->vth[4]);\n\twrite_reg(state, RSTV0910_P2_VTH12 + state->regoff + 5, state->vth[5]);\n\treturn status;\n}\n\nstatic int start(struct stv *state, struct dtv_frontend_properties *p)\n{\n\ts32 freq;\n\tu8  reg_dmdcfgmd;\n\tu16 symb;\n\n\tif (p->symbol_rate < 100000 || p->symbol_rate > 70000000)\n\t\treturn -EINVAL;\n\n\tstate->receive_mode = RCVMODE_NONE;\n\tstate->demod_lock_time = 0;\n\n\t \n\tif (state->started)\n\t\twrite_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x5C);\n\n\tinit_search_param(state, p);\n\n\tif (p->symbol_rate <= 1000000) {  \n\t\tstate->demod_timeout = 3000;\n\t\tstate->fec_timeout = 2000;\n\t} else if (p->symbol_rate <= 2000000) {  \n\t\tstate->demod_timeout = 2500;\n\t\tstate->fec_timeout = 1300;\n\t} else if (p->symbol_rate <= 5000000) {  \n\t\tstate->demod_timeout = 1000;\n\t\tstate->fec_timeout = 650;\n\t} else if (p->symbol_rate <= 10000000) {  \n\t\tstate->demod_timeout = 700;\n\t\tstate->fec_timeout = 350;\n\t} else if (p->symbol_rate < 20000000) {  \n\t\tstate->demod_timeout = 400;\n\t\tstate->fec_timeout = 200;\n\t} else {  \n\t\tstate->demod_timeout = 300;\n\t\tstate->fec_timeout = 200;\n\t}\n\n\t \n\tsymb = muldiv32(p->symbol_rate, 65536, state->base->mclk);\n\twrite_reg(state, RSTV0910_P2_SFRINIT1 + state->regoff,\n\t\t  ((symb >> 8) & 0x7F));\n\twrite_reg(state, RSTV0910_P2_SFRINIT0 + state->regoff, (symb & 0xFF));\n\n\tstate->demod_bits |= 0x80;\n\twrite_reg(state, RSTV0910_P2_DEMOD + state->regoff, state->demod_bits);\n\n\t \n\tread_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff, &reg_dmdcfgmd);\n\twrite_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff,\n\t\t  reg_dmdcfgmd |= 0xC0);\n\n\twrite_shared_reg(state,\n\t\t\t RSTV0910_TSTTSRS, state->nr ? 0x02 : 0x01, 0x00);\n\n\t \n\twrite_reg(state, RSTV0910_P2_FECM  + state->regoff, 0x00);\n\twrite_reg(state, RSTV0910_P2_PRVIT + state->regoff, 0x2F);\n\n\tenable_puncture_rate(state, FEC_NONE);\n\n\t \n\twrite_reg(state, RSTV0910_P2_ACLC2S2Q + state->regoff, 0x0B);\n\twrite_reg(state, RSTV0910_P2_ACLC2S28 + state->regoff, 0x0A);\n\twrite_reg(state, RSTV0910_P2_BCLC2S2Q + state->regoff, 0x84);\n\twrite_reg(state, RSTV0910_P2_BCLC2S28 + state->regoff, 0x84);\n\twrite_reg(state, RSTV0910_P2_CARHDR + state->regoff, 0x1C);\n\twrite_reg(state, RSTV0910_P2_CARFREQ + state->regoff, 0x79);\n\n\twrite_reg(state, RSTV0910_P2_ACLC2S216A + state->regoff, 0x29);\n\twrite_reg(state, RSTV0910_P2_ACLC2S232A + state->regoff, 0x09);\n\twrite_reg(state, RSTV0910_P2_BCLC2S216A + state->regoff, 0x84);\n\twrite_reg(state, RSTV0910_P2_BCLC2S232A + state->regoff, 0x84);\n\n\t \n\twrite_reg(state, RSTV0910_TSTRES0, state->nr ? 0x04 : 0x08);\n\twrite_reg(state, RSTV0910_TSTRES0, 0);\n\n\tset_vth_default(state);\n\t \n\twrite_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x1F);\n\n\twrite_reg(state, RSTV0910_P2_CARCFG + state->regoff, 0x46);\n\n\tif (p->symbol_rate <= 5000000)\n\t\tfreq = (state->search_range / 2000) + 80;\n\telse\n\t\tfreq = (state->search_range / 2000) + 1600;\n\tfreq = (freq << 16) / (state->base->mclk / 1000);\n\n\twrite_reg(state, RSTV0910_P2_CFRUP1 + state->regoff,\n\t\t  (freq >> 8) & 0xff);\n\twrite_reg(state, RSTV0910_P2_CFRUP0 + state->regoff, (freq & 0xff));\n\t \n\tfreq = -freq;\n\twrite_reg(state, RSTV0910_P2_CFRLOW1 + state->regoff,\n\t\t  (freq >> 8) & 0xff);\n\twrite_reg(state, RSTV0910_P2_CFRLOW0 + state->regoff, (freq & 0xff));\n\n\t \n\twrite_reg(state, RSTV0910_P2_CFRINIT1 + state->regoff, 0);\n\twrite_reg(state, RSTV0910_P2_CFRINIT0 + state->regoff, 0);\n\n\twrite_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x1F);\n\t \n\twrite_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x15);\n\n\tstate->demod_lock_time += TUNING_DELAY;\n\tstate->started = 1;\n\n\treturn 0;\n}\n\nstatic int init_diseqc(struct stv *state)\n{\n\tu16 offs = state->nr ? 0x40 : 0;  \n\tu8 freq = ((state->base->mclk + 11000 * 32) / (22000 * 32));\n\n\t \n\twrite_reg(state, RSTV0910_P1_DISRXCFG + offs, 0x00);\n\twrite_reg(state, RSTV0910_P1_DISTXCFG + offs, 0xBA);  \n\twrite_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3A);  \n\twrite_reg(state, RSTV0910_P1_DISTXF22 + offs, freq);\n\treturn 0;\n}\n\nstatic int probe(struct stv *state)\n{\n\tu8 id;\n\n\tstate->receive_mode = RCVMODE_NONE;\n\tstate->started = 0;\n\n\tif (read_reg(state, RSTV0910_MID, &id) < 0)\n\t\treturn -ENODEV;\n\n\tif (id != 0x51)\n\t\treturn -EINVAL;\n\n\t \n\twrite_reg(state, RSTV0910_P1_I2CRPT, 0x24);\n\t \n\twrite_reg(state, RSTV0910_P2_I2CRPT, 0x24);\n\t \n\twrite_reg(state, RSTV0910_I2CCFG, 0x88);  \n\n\twrite_reg(state, RSTV0910_OUTCFG,    0x00);  \n\twrite_reg(state, RSTV0910_PADCFG,    0x05);  \n\twrite_reg(state, RSTV0910_SYNTCTRL,  0x02);  \n\twrite_reg(state, RSTV0910_TSGENERAL, state->tsgeneral);  \n\twrite_reg(state, RSTV0910_CFGEXT,    0x02);  \n\n\tif (state->single)\n\t\twrite_reg(state, RSTV0910_GENCFG, 0x14);  \n\telse\n\t\twrite_reg(state, RSTV0910_GENCFG, 0x15);  \n\n\twrite_reg(state, RSTV0910_P1_TNRCFG2, 0x02);  \n\twrite_reg(state, RSTV0910_P2_TNRCFG2, 0x82);  \n\n\twrite_reg(state, RSTV0910_P1_CAR3CFG, 0x02);\n\twrite_reg(state, RSTV0910_P2_CAR3CFG, 0x02);\n\twrite_reg(state, RSTV0910_P1_DMDCFG4, 0x04);\n\twrite_reg(state, RSTV0910_P2_DMDCFG4, 0x04);\n\n\twrite_reg(state, RSTV0910_TSTRES0, 0x80);  \n\twrite_reg(state, RSTV0910_TSTRES0, 0x00);\n\n\twrite_reg(state, RSTV0910_P1_TSPIDFLT1, 0x00);\n\twrite_reg(state, RSTV0910_P2_TSPIDFLT1, 0x00);\n\n\twrite_reg(state, RSTV0910_P1_TMGCFG2, 0x80);\n\twrite_reg(state, RSTV0910_P2_TMGCFG2, 0x80);\n\n\tset_mclock(state, 135000000);\n\n\t \n\twrite_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh | 0x01);\n\twrite_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh);\n\twrite_reg(state, RSTV0910_P1_TSCFGM, 0xC0);  \n\twrite_reg(state, RSTV0910_P1_TSCFGL, 0x20);\n\n\twrite_reg(state, RSTV0910_P1_TSSPEED, state->tsspeed);\n\n\twrite_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh | 0x01);\n\twrite_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh);\n\twrite_reg(state, RSTV0910_P2_TSCFGM, 0xC0);  \n\twrite_reg(state, RSTV0910_P2_TSCFGL, 0x20);\n\n\twrite_reg(state, RSTV0910_P2_TSSPEED, state->tsspeed);\n\n\t \n\twrite_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh | 0x01);\n\twrite_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh | 0x01);\n\twrite_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh);\n\twrite_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh);\n\n\twrite_reg(state, RSTV0910_P1_I2CRPT, state->i2crpt);\n\twrite_reg(state, RSTV0910_P2_I2CRPT, state->i2crpt);\n\n\twrite_reg(state, RSTV0910_P1_TSINSDELM, 0x17);\n\twrite_reg(state, RSTV0910_P1_TSINSDELL, 0xff);\n\n\twrite_reg(state, RSTV0910_P2_TSINSDELM, 0x17);\n\twrite_reg(state, RSTV0910_P2_TSINSDELL, 0xff);\n\n\tinit_diseqc(state);\n\treturn 0;\n}\n\nstatic int gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct stv *state = fe->demodulator_priv;\n\tu8 i2crpt = state->i2crpt & ~0x86;\n\n\t \n\n\tif (enable) {\n\t\tmutex_lock(&state->base->i2c_lock);\n\t\ti2crpt |= 0x80;\n\t} else {\n\t\ti2crpt |= 0x02;\n\t}\n\n\tif (write_reg(state, state->nr ? RSTV0910_P2_I2CRPT :\n\t\t      RSTV0910_P1_I2CRPT, i2crpt) < 0) {\n\t\t \n\t\tif (!WARN_ON(!mutex_is_locked(&state->base->i2c_lock)))\n\t\t\tmutex_unlock(&state->base->i2c_lock);\n\t\tdev_err(&state->base->i2c->dev,\n\t\t\t\"%s() write_reg failure (enable=%d)\\n\",\n\t\t\t__func__, enable);\n\t\treturn -EIO;\n\t}\n\n\tstate->i2crpt = i2crpt;\n\n\tif (!enable)\n\t\tif (!WARN_ON(!mutex_is_locked(&state->base->i2c_lock)))\n\t\t\tmutex_unlock(&state->base->i2c_lock);\n\treturn 0;\n}\n\nstatic void release(struct dvb_frontend *fe)\n{\n\tstruct stv *state = fe->demodulator_priv;\n\n\tstate->base->count--;\n\tif (state->base->count == 0) {\n\t\tlist_del(&state->base->stvlist);\n\t\tkfree(state->base);\n\t}\n\tkfree(state);\n}\n\nstatic int set_parameters(struct dvb_frontend *fe)\n{\n\tint stat = 0;\n\tstruct stv *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tstop(state);\n\tif (fe->ops.tuner_ops.set_params)\n\t\tfe->ops.tuner_ops.set_params(fe);\n\tstate->symbol_rate = p->symbol_rate;\n\tstat = start(state, p);\n\treturn stat;\n}\n\nstatic int manage_matype_info(struct stv *state)\n{\n\tif (!state->started)\n\t\treturn -EINVAL;\n\tif (state->receive_mode == RCVMODE_DVBS2) {\n\t\tu8 bbheader[2];\n\n\t\tread_regs(state, RSTV0910_P2_MATSTR1 + state->regoff,\n\t\t\t  bbheader, 2);\n\t\tstate->feroll_off =\n\t\t\t(enum fe_stv0910_roll_off)(bbheader[0] & 0x03);\n\t\tstate->is_vcm = (bbheader[0] & 0x10) == 0;\n\t\tstate->is_standard_broadcast = (bbheader[0] & 0xFC) == 0xF0;\n\t} else if (state->receive_mode == RCVMODE_DVBS) {\n\t\tstate->is_vcm = 0;\n\t\tstate->is_standard_broadcast = 1;\n\t\tstate->feroll_off = FE_SAT_35;\n\t}\n\treturn 0;\n}\n\nstatic int read_snr(struct dvb_frontend *fe)\n{\n\tstruct stv *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\ts32 snrval;\n\n\tif (!get_signal_to_noise(state, &snrval)) {\n\t\tp->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\t\tp->cnr.stat[0].svalue = 100 * snrval;  \n\t} else {\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_ber(struct dvb_frontend *fe)\n{\n\tstruct stv *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 n, d;\n\n\tget_bit_error_rate(state, &n, &d);\n\n\tp->pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;\n\tp->pre_bit_error.stat[0].uvalue = n;\n\tp->pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;\n\tp->pre_bit_count.stat[0].uvalue = d;\n\n\treturn 0;\n}\n\nstatic void read_signal_strength(struct dvb_frontend *fe)\n{\n\tstruct stv *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &state->fe.dtv_property_cache;\n\tu8 reg[2];\n\tu16 agc;\n\ts32 padc, power = 0;\n\tint i;\n\n\tread_regs(state, RSTV0910_P2_AGCIQIN1 + state->regoff, reg, 2);\n\n\tagc = (((u32)reg[0]) << 8) | reg[1];\n\n\tfor (i = 0; i < 5; i += 1) {\n\t\tread_regs(state, RSTV0910_P2_POWERI + state->regoff, reg, 2);\n\t\tpower += (u32)reg[0] * (u32)reg[0]\n\t\t\t+ (u32)reg[1] * (u32)reg[1];\n\t\tusleep_range(3000, 4000);\n\t}\n\tpower /= 5;\n\n\tpadc = table_lookup(padc_lookup, ARRAY_SIZE(padc_lookup), power) + 352;\n\n\tp->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\tp->strength.stat[0].svalue = (padc - agc);\n}\n\nstatic int read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct stv *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu8 dmd_state = 0;\n\tu8 dstatus  = 0;\n\tenum receive_mode cur_receive_mode = RCVMODE_NONE;\n\tu32 feclock = 0;\n\n\t*status = 0;\n\n\tread_reg(state, RSTV0910_P2_DMDSTATE + state->regoff, &dmd_state);\n\n\tif (dmd_state & 0x40) {\n\t\tread_reg(state, RSTV0910_P2_DSTATUS + state->regoff, &dstatus);\n\t\tif (dstatus & 0x08)\n\t\t\tcur_receive_mode = (dmd_state & 0x20) ?\n\t\t\t\tRCVMODE_DVBS : RCVMODE_DVBS2;\n\t}\n\tif (cur_receive_mode == RCVMODE_NONE) {\n\t\tset_vth(state);\n\n\t\t \n\t\tp->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\t\treturn 0;\n\t}\n\n\t*status |= (FE_HAS_SIGNAL\n\t\t| FE_HAS_CARRIER\n\t\t| FE_HAS_VITERBI\n\t\t| FE_HAS_SYNC);\n\n\tif (state->receive_mode == RCVMODE_NONE) {\n\t\tstate->receive_mode = cur_receive_mode;\n\t\tstate->demod_lock_time = jiffies;\n\t\tstate->first_time_lock = 1;\n\n\t\tget_signal_parameters(state);\n\t\ttracking_optimization(state);\n\n\t\twrite_reg(state, RSTV0910_P2_TSCFGH + state->regoff,\n\t\t\t  state->tscfgh);\n\t\tusleep_range(3000, 4000);\n\t\twrite_reg(state, RSTV0910_P2_TSCFGH + state->regoff,\n\t\t\t  state->tscfgh | 0x01);\n\t\twrite_reg(state, RSTV0910_P2_TSCFGH + state->regoff,\n\t\t\t  state->tscfgh);\n\t}\n\tif (dmd_state & 0x40) {\n\t\tif (state->receive_mode == RCVMODE_DVBS2) {\n\t\t\tu8 pdelstatus;\n\n\t\t\tread_reg(state,\n\t\t\t\t RSTV0910_P2_PDELSTATUS1 + state->regoff,\n\t\t\t\t &pdelstatus);\n\t\t\tfeclock = (pdelstatus & 0x02) != 0;\n\t\t} else {\n\t\t\tu8 vstatus;\n\n\t\t\tread_reg(state,\n\t\t\t\t RSTV0910_P2_VSTATUSVIT + state->regoff,\n\t\t\t\t &vstatus);\n\t\t\tfeclock = (vstatus & 0x08) != 0;\n\t\t}\n\t}\n\n\tif (feclock) {\n\t\t*status |= FE_HAS_LOCK;\n\n\t\tif (state->first_time_lock) {\n\t\t\tu8 tmp;\n\n\t\t\tstate->first_time_lock = 0;\n\n\t\t\tmanage_matype_info(state);\n\n\t\t\tif (state->receive_mode == RCVMODE_DVBS2) {\n\t\t\t\t \n\t\t\t\tstate->demod_bits &= ~0x84;\n\t\t\t\twrite_reg(state,\n\t\t\t\t\t  RSTV0910_P2_DEMOD + state->regoff,\n\t\t\t\t\t  state->demod_bits);\n\t\t\t\tread_reg(state,\n\t\t\t\t\t RSTV0910_P2_PDELCTRL2 + state->regoff,\n\t\t\t\t\t &tmp);\n\t\t\t\t \n\t\t\t\ttmp |= 0x40;\n\t\t\t\twrite_reg(state,\n\t\t\t\t\t  RSTV0910_P2_PDELCTRL2 + state->regoff,\n\t\t\t\t\t  tmp);\n\t\t\t\t \n\t\t\t\ttmp &= ~0x40;\n\t\t\t\twrite_reg(state,\n\t\t\t\t\t  RSTV0910_P2_PDELCTRL2 + state->regoff,\n\t\t\t\t\t  tmp);\n\n\t\t\t\tstate->berscale = 2;\n\t\t\t\tstate->last_bernumerator = 0;\n\t\t\t\tstate->last_berdenominator = 1;\n\t\t\t\t \n\t\t\t\twrite_reg(state,\n\t\t\t\t\t  RSTV0910_P2_ERRCTRL1 + state->regoff,\n\t\t\t\t\t  BER_SRC_S2 | state->berscale);\n\t\t\t} else {\n\t\t\t\tstate->berscale = 2;\n\t\t\t\tstate->last_bernumerator = 0;\n\t\t\t\tstate->last_berdenominator = 1;\n\t\t\t\t \n\t\t\t\twrite_reg(state,\n\t\t\t\t\t  RSTV0910_P2_ERRCTRL1 + state->regoff,\n\t\t\t\t\t  BER_SRC_S | state->berscale);\n\t\t\t}\n\t\t\t \n\t\t\twrite_reg(state,\n\t\t\t\t  RSTV0910_P2_FBERCPT4 + state->regoff, 0x00);\n\t\t\t \n\t\t\twrite_reg(state,\n\t\t\t\t  RSTV0910_P2_ERRCTRL2 + state->regoff, 0xc1);\n\n\t\t\tset_vth_default(state);\n\t\t\tif (state->receive_mode == RCVMODE_DVBS)\n\t\t\t\tenable_puncture_rate(state,\n\t\t\t\t\t\t     state->puncture_rate);\n\t\t}\n\n\t\t \n\t\tif (state->is_vcm) {\n\t\t\tu8 tmp;\n\t\t\tenum fe_stv0910_mod_cod mod_cod;\n\n\t\t\tread_reg(state, RSTV0910_P2_DMDMODCOD + state->regoff,\n\t\t\t\t &tmp);\n\t\t\tmod_cod = (enum fe_stv0910_mod_cod)((tmp & 0x7c) >> 2);\n\n\t\t\tif (mod_cod > state->mod_cod)\n\t\t\t\tstate->mod_cod = mod_cod;\n\t\t}\n\t}\n\n\t \n\n\t \n\tread_signal_strength(fe);\n\n\t \n\tif (*status & FE_HAS_CARRIER)\n\t\tread_snr(fe);\n\telse\n\t\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\n\t \n\tif (*status & FE_HAS_VITERBI) {\n\t\tread_ber(fe);\n\t} else {\n\t\tp->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t\tp->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_frontend(struct dvb_frontend *fe,\n\t\t\tstruct dtv_frontend_properties *p)\n{\n\tstruct stv *state = fe->demodulator_priv;\n\tu8 tmp;\n\tu32 symbolrate;\n\n\tif (state->receive_mode == RCVMODE_DVBS2) {\n\t\tu32 mc;\n\t\tconst enum fe_modulation modcod2mod[0x20] = {\n\t\t\tQPSK, QPSK, QPSK, QPSK,\n\t\t\tQPSK, QPSK, QPSK, QPSK,\n\t\t\tQPSK, QPSK, QPSK, QPSK,\n\t\t\tPSK_8, PSK_8, PSK_8, PSK_8,\n\t\t\tPSK_8, PSK_8, APSK_16, APSK_16,\n\t\t\tAPSK_16, APSK_16, APSK_16, APSK_16,\n\t\t\tAPSK_32, APSK_32, APSK_32, APSK_32,\n\t\t\tAPSK_32,\n\t\t};\n\t\tconst enum fe_code_rate modcod2fec[0x20] = {\n\t\t\tFEC_NONE, FEC_NONE, FEC_NONE, FEC_2_5,\n\t\t\tFEC_1_2, FEC_3_5, FEC_2_3, FEC_3_4,\n\t\t\tFEC_4_5, FEC_5_6, FEC_8_9, FEC_9_10,\n\t\t\tFEC_3_5, FEC_2_3, FEC_3_4, FEC_5_6,\n\t\t\tFEC_8_9, FEC_9_10, FEC_2_3, FEC_3_4,\n\t\t\tFEC_4_5, FEC_5_6, FEC_8_9, FEC_9_10,\n\t\t\tFEC_3_4, FEC_4_5, FEC_5_6, FEC_8_9,\n\t\t\tFEC_9_10\n\t\t};\n\t\tread_reg(state, RSTV0910_P2_DMDMODCOD + state->regoff, &tmp);\n\t\tmc = ((tmp & 0x7c) >> 2);\n\t\tp->pilot = (tmp & 0x01) ? PILOT_ON : PILOT_OFF;\n\t\tp->modulation = modcod2mod[mc];\n\t\tp->fec_inner = modcod2fec[mc];\n\t} else if (state->receive_mode == RCVMODE_DVBS) {\n\t\tread_reg(state, RSTV0910_P2_VITCURPUN + state->regoff, &tmp);\n\t\tswitch (tmp & 0x1F) {\n\t\tcase 0x0d:\n\t\t\tp->fec_inner = FEC_1_2;\n\t\t\tbreak;\n\t\tcase 0x12:\n\t\t\tp->fec_inner = FEC_2_3;\n\t\t\tbreak;\n\t\tcase 0x15:\n\t\t\tp->fec_inner = FEC_3_4;\n\t\t\tbreak;\n\t\tcase 0x18:\n\t\t\tp->fec_inner = FEC_5_6;\n\t\t\tbreak;\n\t\tcase 0x1a:\n\t\t\tp->fec_inner = FEC_7_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp->fec_inner = FEC_NONE;\n\t\t\tbreak;\n\t\t}\n\t\tp->rolloff = ROLLOFF_35;\n\t}\n\n\tif (state->receive_mode != RCVMODE_NONE) {\n\t\tget_cur_symbol_rate(state, &symbolrate);\n\t\tp->symbol_rate = symbolrate;\n\t}\n\treturn 0;\n}\n\nstatic int tune(struct dvb_frontend *fe, bool re_tune,\n\t\tunsigned int mode_flags,\n\t\tunsigned int *delay, enum fe_status *status)\n{\n\tstruct stv *state = fe->demodulator_priv;\n\tint r;\n\n\tif (re_tune) {\n\t\tr = set_parameters(fe);\n\t\tif (r)\n\t\t\treturn r;\n\t\tstate->tune_time = jiffies;\n\t}\n\n\tr = read_status(fe, status);\n\tif (r)\n\t\treturn r;\n\n\tif (*status & FE_HAS_LOCK)\n\t\treturn 0;\n\t*delay = HZ;\n\n\treturn 0;\n}\n\nstatic enum dvbfe_algo get_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic int set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\n{\n\tstruct stv *state = fe->demodulator_priv;\n\tu16 offs = state->nr ? 0x40 : 0;\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\treturn write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x38);\n\tcase SEC_TONE_OFF:\n\t\treturn write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3a);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int wait_dis(struct stv *state, u8 flag, u8 val)\n{\n\tint i;\n\tu8 stat;\n\tu16 offs = state->nr ? 0x40 : 0;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tread_reg(state, RSTV0910_P1_DISTXSTATUS + offs, &stat);\n\t\tif ((stat & flag) == val)\n\t\t\treturn 0;\n\t\tusleep_range(10000, 11000);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int send_master_cmd(struct dvb_frontend *fe,\n\t\t\t   struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct stv *state = fe->demodulator_priv;\n\tint i;\n\n\tSET_FIELD(DISEQC_MODE, 2);\n\tSET_FIELD(DIS_PRECHARGE, 1);\n\tfor (i = 0; i < cmd->msg_len; i++) {\n\t\twait_dis(state, 0x40, 0x00);\n\t\tSET_REG(DISTXFIFO, cmd->msg[i]);\n\t}\n\tSET_FIELD(DIS_PRECHARGE, 0);\n\twait_dis(state, 0x20, 0x20);\n\treturn 0;\n}\n\nstatic int send_burst(struct dvb_frontend *fe, enum fe_sec_mini_cmd burst)\n{\n\tstruct stv *state = fe->demodulator_priv;\n\tu8 value;\n\n\tif (burst == SEC_MINI_A) {\n\t\tSET_FIELD(DISEQC_MODE, 3);\n\t\tvalue = 0x00;\n\t} else {\n\t\tSET_FIELD(DISEQC_MODE, 2);\n\t\tvalue = 0xFF;\n\t}\n\n\tSET_FIELD(DIS_PRECHARGE, 1);\n\twait_dis(state, 0x40, 0x00);\n\tSET_REG(DISTXFIFO, value);\n\tSET_FIELD(DIS_PRECHARGE, 0);\n\twait_dis(state, 0x20, 0x20);\n\n\treturn 0;\n}\n\nstatic int sleep(struct dvb_frontend *fe)\n{\n\tstruct stv *state = fe->demodulator_priv;\n\n\tstop(state);\n\treturn 0;\n}\n\nstatic const struct dvb_frontend_ops stv0910_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2, SYS_DSS },\n\t.info = {\n\t\t.name\t\t\t= \"ST STV0910\",\n\t\t.frequency_min_hz\t=  950 * MHz,\n\t\t.frequency_max_hz\t= 2150 * MHz,\n\t\t.symbol_rate_min\t= 100000,\n\t\t.symbol_rate_max\t= 70000000,\n\t\t.caps\t\t\t= FE_CAN_INVERSION_AUTO |\n\t\t\t\t\t  FE_CAN_FEC_AUTO       |\n\t\t\t\t\t  FE_CAN_QPSK           |\n\t\t\t\t\t  FE_CAN_2G_MODULATION  |\n\t\t\t\t\t  FE_CAN_MULTISTREAM\n\t},\n\t.sleep\t\t\t\t= sleep,\n\t.release\t\t\t= release,\n\t.i2c_gate_ctrl\t\t\t= gate_ctrl,\n\t.set_frontend\t\t\t= set_parameters,\n\t.get_frontend_algo\t\t= get_algo,\n\t.get_frontend\t\t\t= get_frontend,\n\t.tune\t\t\t\t= tune,\n\t.read_status\t\t\t= read_status,\n\t.set_tone\t\t\t= set_tone,\n\n\t.diseqc_send_master_cmd\t\t= send_master_cmd,\n\t.diseqc_send_burst\t\t= send_burst,\n};\n\nstatic struct stv_base *match_base(struct i2c_adapter *i2c, u8 adr)\n{\n\tstruct stv_base *p;\n\n\tlist_for_each_entry(p, &stvlist, stvlist)\n\t\tif (p->i2c == i2c && p->adr == adr)\n\t\t\treturn p;\n\treturn NULL;\n}\n\nstatic void stv0910_init_stats(struct stv *state)\n{\n\tstruct dtv_frontend_properties *p = &state->fe.dtv_property_cache;\n\n\tp->strength.len = 1;\n\tp->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->cnr.len = 1;\n\tp->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->pre_bit_error.len = 1;\n\tp->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n\tp->pre_bit_count.len = 1;\n\tp->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\n}\n\nstruct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,\n\t\t\t\t    struct stv0910_cfg *cfg,\n\t\t\t\t    int nr)\n{\n\tstruct stv *state;\n\tstruct stv_base *base;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tstate->tscfgh = 0x20 | (cfg->parallel ? 0 : 0x40);\n\tstate->tsgeneral = (cfg->parallel == 2) ? 0x02 : 0x00;\n\tstate->i2crpt = 0x0A | ((cfg->rptlvl & 0x07) << 4);\n\t \n\tstate->tsspeed = (cfg->tsspeed ? cfg->tsspeed : 0x28);\n\tstate->nr = nr;\n\tstate->regoff = state->nr ? 0 : 0x200;\n\tstate->search_range = 16000000;\n\tstate->demod_bits = 0x10;  \n\tstate->receive_mode = RCVMODE_NONE;\n\tstate->cur_scrambling_code = (~0U);\n\tstate->single = cfg->single ? 1 : 0;\n\n\tbase = match_base(i2c, cfg->adr);\n\tif (base) {\n\t\tbase->count++;\n\t\tstate->base = base;\n\t} else {\n\t\tbase = kzalloc(sizeof(*base), GFP_KERNEL);\n\t\tif (!base)\n\t\t\tgoto fail;\n\t\tbase->i2c = i2c;\n\t\tbase->adr = cfg->adr;\n\t\tbase->count = 1;\n\t\tbase->extclk = cfg->clk ? cfg->clk : 30000000;\n\n\t\tmutex_init(&base->i2c_lock);\n\t\tmutex_init(&base->reg_lock);\n\t\tstate->base = base;\n\t\tif (probe(state) < 0) {\n\t\t\tdev_info(&i2c->dev, \"No demod found at adr %02X on %s\\n\",\n\t\t\t\t cfg->adr, dev_name(&i2c->dev));\n\t\t\tkfree(base);\n\t\t\tgoto fail;\n\t\t}\n\t\tlist_add(&base->stvlist, &stvlist);\n\t}\n\tstate->fe.ops = stv0910_ops;\n\tstate->fe.demodulator_priv = state;\n\tstate->nr = nr;\n\n\tdev_info(&i2c->dev, \"%s demod found at adr %02X on %s\\n\",\n\t\t state->fe.ops.info.name, cfg->adr, dev_name(&i2c->dev));\n\n\tstv0910_init_stats(state);\n\n\treturn &state->fe;\n\nfail:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(stv0910_attach);\n\nMODULE_DESCRIPTION(\"ST STV0910 multistandard frontend driver\");\nMODULE_AUTHOR(\"Ralph and Marcus Metzler, Manfred Voelkel\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}