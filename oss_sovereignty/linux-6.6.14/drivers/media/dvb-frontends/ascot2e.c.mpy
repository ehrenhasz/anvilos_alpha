{
  "module_name": "ascot2e.c",
  "hash_id": "e1a768911ed1a9c059f934ecd425874fd7f8d045c9f6166170fab479d98028b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/ascot2e.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/dvb/frontend.h>\n#include <linux/types.h>\n#include \"ascot2e.h\"\n#include <media/dvb_frontend.h>\n\n#define MAX_WRITE_REGSIZE 10\n\nenum ascot2e_state {\n\tSTATE_UNKNOWN,\n\tSTATE_SLEEP,\n\tSTATE_ACTIVE\n};\n\nstruct ascot2e_priv {\n\tu32\t\t\tfrequency;\n\tu8\t\t\ti2c_address;\n\tstruct i2c_adapter\t*i2c;\n\tenum ascot2e_state\tstate;\n\tvoid\t\t\t*set_tuner_data;\n\tint\t\t\t(*set_tuner)(void *, int);\n};\n\nenum ascot2e_tv_system_t {\n\tASCOT2E_DTV_DVBT_5,\n\tASCOT2E_DTV_DVBT_6,\n\tASCOT2E_DTV_DVBT_7,\n\tASCOT2E_DTV_DVBT_8,\n\tASCOT2E_DTV_DVBT2_1_7,\n\tASCOT2E_DTV_DVBT2_5,\n\tASCOT2E_DTV_DVBT2_6,\n\tASCOT2E_DTV_DVBT2_7,\n\tASCOT2E_DTV_DVBT2_8,\n\tASCOT2E_DTV_DVBC_6,\n\tASCOT2E_DTV_DVBC_8,\n\tASCOT2E_DTV_DVBC2_6,\n\tASCOT2E_DTV_DVBC2_8,\n\tASCOT2E_DTV_UNKNOWN\n};\n\nstruct ascot2e_band_sett {\n\tu8\tif_out_sel;\n\tu8\tagc_sel;\n\tu8\tmix_oll;\n\tu8\trf_gain;\n\tu8\tif_bpf_gc;\n\tu8\tfif_offset;\n\tu8\tbw_offset;\n\tu8\tbw;\n\tu8\trf_oldet;\n\tu8\tif_bpf_f0;\n};\n\n#define ASCOT2E_AUTO\t\t0xff\n#define ASCOT2E_OFFSET(ofs)\t((u8)(ofs) & 0x1F)\n#define ASCOT2E_BW_6\t\t0x00\n#define ASCOT2E_BW_7\t\t0x01\n#define ASCOT2E_BW_8\t\t0x02\n#define ASCOT2E_BW_1_7\t\t0x03\n\nstatic struct ascot2e_band_sett ascot2e_sett[] = {\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x03, ASCOT2E_AUTO, 0x06,\n\t  ASCOT2E_OFFSET(-8), ASCOT2E_OFFSET(-6), ASCOT2E_BW_6,  0x0B, 0x00 },\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x03, ASCOT2E_AUTO, 0x06,\n\t  ASCOT2E_OFFSET(-8), ASCOT2E_OFFSET(-6), ASCOT2E_BW_6,  0x0B, 0x00 },\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x03, ASCOT2E_AUTO, 0x06,\n\t  ASCOT2E_OFFSET(-6), ASCOT2E_OFFSET(-4), ASCOT2E_BW_7,  0x0B, 0x00 },\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x03, ASCOT2E_AUTO, 0x06,\n\t  ASCOT2E_OFFSET(-4), ASCOT2E_OFFSET(-2), ASCOT2E_BW_8,  0x0B, 0x00 },\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x03, ASCOT2E_AUTO, 0x06,\n\tASCOT2E_OFFSET(-10), ASCOT2E_OFFSET(-16), ASCOT2E_BW_1_7, 0x0B, 0x00 },\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x03, ASCOT2E_AUTO, 0x06,\n\t  ASCOT2E_OFFSET(-8), ASCOT2E_OFFSET(-6), ASCOT2E_BW_6,  0x0B, 0x00 },\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x03, ASCOT2E_AUTO, 0x06,\n\t  ASCOT2E_OFFSET(-8), ASCOT2E_OFFSET(-6), ASCOT2E_BW_6,  0x0B, 0x00 },\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x03, ASCOT2E_AUTO, 0x06,\n\t  ASCOT2E_OFFSET(-6), ASCOT2E_OFFSET(-4), ASCOT2E_BW_7,  0x0B, 0x00 },\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x03, ASCOT2E_AUTO, 0x06,\n\t  ASCOT2E_OFFSET(-4), ASCOT2E_OFFSET(-2), ASCOT2E_BW_8,  0x0B, 0x00 },\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x02, ASCOT2E_AUTO, 0x03,\n\t  ASCOT2E_OFFSET(-6), ASCOT2E_OFFSET(-8), ASCOT2E_BW_6,  0x09, 0x00 },\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x02, ASCOT2E_AUTO, 0x03,\n\t  ASCOT2E_OFFSET(-2), ASCOT2E_OFFSET(-1), ASCOT2E_BW_8,  0x09, 0x00 },\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x03, ASCOT2E_AUTO, 0x01,\n\t  ASCOT2E_OFFSET(-6), ASCOT2E_OFFSET(-4), ASCOT2E_BW_6,  0x09, 0x00 },\n\t{ ASCOT2E_AUTO, ASCOT2E_AUTO, 0x03, ASCOT2E_AUTO, 0x01,\n\t  ASCOT2E_OFFSET(-2), ASCOT2E_OFFSET(2),  ASCOT2E_BW_8,  0x09, 0x00 }\n};\n\nstatic void ascot2e_i2c_debug(struct ascot2e_priv *priv,\n\t\t\t      u8 reg, u8 write, const u8 *data, u32 len)\n{\n\tdev_dbg(&priv->i2c->dev, \"ascot2e: I2C %s reg 0x%02x size %d\\n\",\n\t\t(write == 0 ? \"read\" : \"write\"), reg, len);\n\tprint_hex_dump_bytes(\"ascot2e: I2C data: \",\n\t\tDUMP_PREFIX_OFFSET, data, len);\n}\n\nstatic int ascot2e_write_regs(struct ascot2e_priv *priv,\n\t\t\t      u8 reg, const u8 *data, u32 len)\n{\n\tint ret;\n\tu8 buf[MAX_WRITE_REGSIZE + 1];\n\tstruct i2c_msg msg[1] = {\n\t\t{\n\t\t\t.addr = priv->i2c_address,\n\t\t\t.flags = 0,\n\t\t\t.len = len + 1,\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\n\tif (len + 1 > sizeof(buf)) {\n\t\tdev_warn(&priv->i2c->dev,\"wr reg=%04x: len=%d is too big!\\n\",\n\t\t\t reg, len + 1);\n\t\treturn -E2BIG;\n\t}\n\n\tascot2e_i2c_debug(priv, reg, 1, data, len);\n\tbuf[0] = reg;\n\tmemcpy(&buf[1], data, len);\n\tret = i2c_transfer(priv->i2c, msg, 1);\n\tif (ret >= 0 && ret != 1)\n\t\tret = -EREMOTEIO;\n\tif (ret < 0) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t\"%s: i2c wr failed=%d reg=%02x len=%d\\n\",\n\t\t\tKBUILD_MODNAME, ret, reg, len);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int ascot2e_write_reg(struct ascot2e_priv *priv, u8 reg, u8 val)\n{\n\tu8 tmp = val;  \n\n\treturn ascot2e_write_regs(priv, reg, &tmp, 1);\n}\n\nstatic int ascot2e_read_regs(struct ascot2e_priv *priv,\n\t\t\t     u8 reg, u8 *val, u32 len)\n{\n\tint ret;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = priv->i2c_address,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &reg,\n\t\t}, {\n\t\t\t.addr = priv->i2c_address,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = val,\n\t\t}\n\t};\n\n\tret = i2c_transfer(priv->i2c, &msg[0], 1);\n\tif (ret >= 0 && ret != 1)\n\t\tret = -EREMOTEIO;\n\tif (ret < 0) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t\"%s: I2C rw failed=%d addr=%02x reg=%02x\\n\",\n\t\t\tKBUILD_MODNAME, ret, priv->i2c_address, reg);\n\t\treturn ret;\n\t}\n\tret = i2c_transfer(priv->i2c, &msg[1], 1);\n\tif (ret >= 0 && ret != 1)\n\t\tret = -EREMOTEIO;\n\tif (ret < 0) {\n\t\tdev_warn(&priv->i2c->dev,\n\t\t\t\"%s: i2c rd failed=%d addr=%02x reg=%02x\\n\",\n\t\t\tKBUILD_MODNAME, ret, priv->i2c_address, reg);\n\t\treturn ret;\n\t}\n\tascot2e_i2c_debug(priv, reg, 0, val, len);\n\treturn 0;\n}\n\nstatic int ascot2e_read_reg(struct ascot2e_priv *priv, u8 reg, u8 *val)\n{\n\treturn ascot2e_read_regs(priv, reg, val, 1);\n}\n\nstatic int ascot2e_set_reg_bits(struct ascot2e_priv *priv,\n\t\t\t\tu8 reg, u8 data, u8 mask)\n{\n\tint res;\n\tu8 rdata;\n\n\tif (mask != 0xff) {\n\t\tres = ascot2e_read_reg(priv, reg, &rdata);\n\t\tif (res != 0)\n\t\t\treturn res;\n\t\tdata = ((data & mask) | (rdata & (mask ^ 0xFF)));\n\t}\n\treturn ascot2e_write_reg(priv, reg, data);\n}\n\nstatic int ascot2e_enter_power_save(struct ascot2e_priv *priv)\n{\n\tu8 data[2];\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state == STATE_SLEEP)\n\t\treturn 0;\n\tdata[0] = 0x00;\n\tdata[1] = 0x04;\n\tascot2e_write_regs(priv, 0x14, data, 2);\n\tascot2e_write_reg(priv, 0x50, 0x01);\n\tpriv->state = STATE_SLEEP;\n\treturn 0;\n}\n\nstatic int ascot2e_leave_power_save(struct ascot2e_priv *priv)\n{\n\tu8 data[2] = { 0xFB, 0x0F };\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tif (priv->state == STATE_ACTIVE)\n\t\treturn 0;\n\tascot2e_write_regs(priv, 0x14, data, 2);\n\tascot2e_write_reg(priv, 0x50, 0x00);\n\tpriv->state = STATE_ACTIVE;\n\treturn 0;\n}\n\nstatic int ascot2e_init(struct dvb_frontend *fe)\n{\n\tstruct ascot2e_priv *priv = fe->tuner_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\treturn ascot2e_leave_power_save(priv);\n}\n\nstatic void ascot2e_release(struct dvb_frontend *fe)\n{\n\tstruct ascot2e_priv *priv = fe->tuner_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tkfree(fe->tuner_priv);\n\tfe->tuner_priv = NULL;\n}\n\nstatic int ascot2e_sleep(struct dvb_frontend *fe)\n{\n\tstruct ascot2e_priv *priv = fe->tuner_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s()\\n\", __func__);\n\tascot2e_enter_power_save(priv);\n\treturn 0;\n}\n\nstatic enum ascot2e_tv_system_t ascot2e_get_tv_system(struct dvb_frontend *fe)\n{\n\tenum ascot2e_tv_system_t system = ASCOT2E_DTV_UNKNOWN;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct ascot2e_priv *priv = fe->tuner_priv;\n\n\tif (p->delivery_system == SYS_DVBT) {\n\t\tif (p->bandwidth_hz <= 5000000)\n\t\t\tsystem = ASCOT2E_DTV_DVBT_5;\n\t\telse if (p->bandwidth_hz <= 6000000)\n\t\t\tsystem = ASCOT2E_DTV_DVBT_6;\n\t\telse if (p->bandwidth_hz <= 7000000)\n\t\t\tsystem = ASCOT2E_DTV_DVBT_7;\n\t\telse if (p->bandwidth_hz <= 8000000)\n\t\t\tsystem = ASCOT2E_DTV_DVBT_8;\n\t\telse {\n\t\t\tsystem = ASCOT2E_DTV_DVBT_8;\n\t\t\tp->bandwidth_hz = 8000000;\n\t\t}\n\t} else if (p->delivery_system == SYS_DVBT2) {\n\t\tif (p->bandwidth_hz <= 5000000)\n\t\t\tsystem = ASCOT2E_DTV_DVBT2_5;\n\t\telse if (p->bandwidth_hz <= 6000000)\n\t\t\tsystem = ASCOT2E_DTV_DVBT2_6;\n\t\telse if (p->bandwidth_hz <= 7000000)\n\t\t\tsystem = ASCOT2E_DTV_DVBT2_7;\n\t\telse if (p->bandwidth_hz <= 8000000)\n\t\t\tsystem = ASCOT2E_DTV_DVBT2_8;\n\t\telse {\n\t\t\tsystem = ASCOT2E_DTV_DVBT2_8;\n\t\t\tp->bandwidth_hz = 8000000;\n\t\t}\n\t} else if (p->delivery_system == SYS_DVBC_ANNEX_A) {\n\t\tif (p->bandwidth_hz <= 6000000)\n\t\t\tsystem = ASCOT2E_DTV_DVBC_6;\n\t\telse if (p->bandwidth_hz <= 8000000)\n\t\t\tsystem = ASCOT2E_DTV_DVBC_8;\n\t}\n\tdev_dbg(&priv->i2c->dev,\n\t\t\"%s(): ASCOT2E DTV system %d (delsys %d, bandwidth %d)\\n\",\n\t\t__func__, (int)system, p->delivery_system, p->bandwidth_hz);\n\treturn system;\n}\n\nstatic int ascot2e_set_params(struct dvb_frontend *fe)\n{\n\tu8 data[10];\n\tu32 frequency;\n\tenum ascot2e_tv_system_t tv_system;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct ascot2e_priv *priv = fe->tuner_priv;\n\n\tdev_dbg(&priv->i2c->dev, \"%s(): tune frequency %dkHz\\n\",\n\t\t__func__, p->frequency / 1000);\n\ttv_system = ascot2e_get_tv_system(fe);\n\n\tif (tv_system == ASCOT2E_DTV_UNKNOWN) {\n\t\tdev_dbg(&priv->i2c->dev, \"%s(): unknown DTV system\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tif (priv->set_tuner)\n\t\tpriv->set_tuner(priv->set_tuner_data, 1);\n\tfrequency = roundup(p->frequency / 1000, 25);\n\tif (priv->state == STATE_SLEEP)\n\t\tascot2e_leave_power_save(priv);\n\n\t \n\tdata[0] = 0x00;\n\tif (ascot2e_sett[tv_system].agc_sel != ASCOT2E_AUTO) {\n\t\t \n\t\tdata[0] |= (u8)(\n\t\t\t(ascot2e_sett[tv_system].agc_sel & 0x03) << 3);\n\t}\n\tif (ascot2e_sett[tv_system].if_out_sel != ASCOT2E_AUTO) {\n\t\t \n\t\tdata[0] |= (u8)(\n\t\t\t(ascot2e_sett[tv_system].if_out_sel & 0x01) << 2);\n\t}\n\t \n\tascot2e_set_reg_bits(priv, 0x05, data[0], 0x1c);\n\t \n\t \n\tif (tv_system == ASCOT2E_DTV_DVBC_6 ||\n\t\t\ttv_system == ASCOT2E_DTV_DVBC_8) {\n\t\t \n\t\tdata[0] = (frequency > 500000) ? 16 : 32;\n\t} else {\n\t\t \n\t\tdata[0] = (frequency > 500000) ? 2 : 4;\n\t}\n\t \n\tdata[1] = 0x04;\n\t \n\tif (tv_system == ASCOT2E_DTV_DVBC_6 ||\n\t\t\ttv_system == ASCOT2E_DTV_DVBC_8) {\n\t\tdata[2] = 18;\n\t\tdata[3] = 120;\n\t\tdata[4] = 20;\n\t} else {\n\t\tdata[2] = 48;\n\t\tdata[3] = 10;\n\t\tdata[4] = 30;\n\t}\n\t \n\tif (tv_system == ASCOT2E_DTV_DVBC_6 ||\n\t\t\ttv_system == ASCOT2E_DTV_DVBC_8)\n\t\tdata[5] = (frequency > 500000) ? 0x08 : 0x0c;\n\telse\n\t\tdata[5] = (frequency > 500000) ? 0x30 : 0x38;\n\t \n\tdata[6] = ascot2e_sett[tv_system].mix_oll;\n\t \n\tif (ascot2e_sett[tv_system].rf_gain == ASCOT2E_AUTO) {\n\t\t \n\t\tascot2e_write_reg(priv, 0x4E, 0x01);\n\t\t \n\t\tdata[7] = 0x00;\n\t} else {\n\t\t \n\t\tascot2e_write_reg(priv, 0x4E, 0x00);\n\t\tdata[7] = ascot2e_sett[tv_system].rf_gain;\n\t}\n\t \n\tdata[8] = (u8)((ascot2e_sett[tv_system].fif_offset << 3) |\n\t\t(ascot2e_sett[tv_system].if_bpf_gc & 0x07));\n\t \n\tdata[9] = ascot2e_sett[tv_system].bw_offset;\n\tascot2e_write_regs(priv, 0x06, data, 10);\n\t \n\tif (tv_system == ASCOT2E_DTV_DVBC_6 ||\n\t\t\ttv_system == ASCOT2E_DTV_DVBC_8) {\n\t\tdata[0] = 0x0F;\n\t\tdata[1] = 0x00;\n\t\tdata[2] = 0x01;\n\t} else {\n\t\tdata[0] = 0x0F;\n\t\tdata[1] = 0x00;\n\t\tdata[2] = 0x03;\n\t}\n\tascot2e_write_regs(priv, 0x45, data, 3);\n\t \n\tdata[0] = ascot2e_sett[tv_system].rf_oldet;\n\t \n\tdata[1] = ascot2e_sett[tv_system].if_bpf_f0;\n\tascot2e_write_regs(priv, 0x49, data, 2);\n\t \n\tascot2e_set_reg_bits(priv, 0x0c, 0x90, 0xb0);\n\t \n\tdata[0] = 0xc4;\n\tdata[1] = 0x40;\n\tascot2e_write_regs(priv, 0x03, data, 2);\n\t \n\tdata[0] = (u8)(frequency & 0xFF);          \n\tdata[1] = (u8)((frequency >> 8) & 0xFF);   \n\tdata[2] = (u8)((frequency >> 16) & 0x0F);  \n\t \n\tdata[2] |= (u8)(ascot2e_sett[tv_system].bw << 4);\n\tdata[3] = 0xFF;  \n\tdata[4] = 0xFF;  \n\t \n\tascot2e_write_regs(priv, 0x10, data, 5);\n\tmsleep(50);\n\t \n\tascot2e_write_reg(priv, 0x04, 0x00);\n\t \n\tascot2e_write_reg(priv, 0x03, 0xC0);\n\t \n\tascot2e_set_reg_bits(priv, 0x0C, 0x00, 0x30);\n\tpriv->frequency = frequency;\n\treturn 0;\n}\n\nstatic int ascot2e_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct ascot2e_priv *priv = fe->tuner_priv;\n\n\t*frequency = priv->frequency * 1000;\n\treturn 0;\n}\n\nstatic const struct dvb_tuner_ops ascot2e_tuner_ops = {\n\t.info = {\n\t\t.name = \"Sony ASCOT2E\",\n\t\t.frequency_min_hz  =    1 * MHz,\n\t\t.frequency_max_hz  = 1200 * MHz,\n\t\t.frequency_step_hz =   25 * kHz,\n\t},\n\t.init = ascot2e_init,\n\t.release = ascot2e_release,\n\t.sleep = ascot2e_sleep,\n\t.set_params = ascot2e_set_params,\n\t.get_frequency = ascot2e_get_frequency,\n};\n\nstruct dvb_frontend *ascot2e_attach(struct dvb_frontend *fe,\n\t\t\t\t    const struct ascot2e_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tu8 data[4];\n\tstruct ascot2e_priv *priv = NULL;\n\n\tpriv = kzalloc(sizeof(struct ascot2e_priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn NULL;\n\tpriv->i2c_address = (config->i2c_address >> 1);\n\tpriv->i2c = i2c;\n\tpriv->set_tuner_data = config->set_tuner_priv;\n\tpriv->set_tuner = config->set_tuner_callback;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\t \n\tdata[0] = 16;\n\t \n\tdata[1] = 0x06;\n\t \n\tdata[2] = 0xC4;\n\tdata[3] = 0x40;\n\tascot2e_write_regs(priv, 0x01, data, 4);\n\t \n\tdata[0] = 0x10;\n\tdata[1] = 0x3F;\n\tdata[2] = 0x25;\n\tascot2e_write_regs(priv, 0x22, data, 3);\n\t \n\tascot2e_write_reg(priv, 0x28, 0x1e);\n\t \n\tascot2e_write_reg(priv, 0x59, 0x04);\n\t \n\tmsleep(80);\n\t \n\tascot2e_write_reg(priv, 0x4c, 0x01);\n\t \n\tascot2e_write_reg(priv, 0x07, 0x04);\n\t \n\tascot2e_write_reg(priv, 0x04, 0x00);\n\t \n\tascot2e_write_reg(priv, 0x03, 0xc0);\n\t \n\tdata[0] = 0x00;\n\tdata[1] = 0x04;\n\tascot2e_write_regs(priv, 0x14, data, 2);\n\tascot2e_write_reg(priv, 0x50, 0x01);\n\tpriv->state = STATE_SLEEP;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\tmemcpy(&fe->ops.tuner_ops, &ascot2e_tuner_ops,\n\t\t\t\tsizeof(struct dvb_tuner_ops));\n\tfe->tuner_priv = priv;\n\tdev_info(&priv->i2c->dev,\n\t\t\"Sony ASCOT2E attached on addr=%x at I2C adapter %p\\n\",\n\t\tpriv->i2c_address, priv->i2c);\n\treturn fe;\n}\nEXPORT_SYMBOL_GPL(ascot2e_attach);\n\nMODULE_DESCRIPTION(\"Sony ASCOT2E terr/cab tuner driver\");\nMODULE_AUTHOR(\"info@netup.ru\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}