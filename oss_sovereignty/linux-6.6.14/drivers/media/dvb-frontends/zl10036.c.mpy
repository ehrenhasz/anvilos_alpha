{
  "module_name": "zl10036.c",
  "hash_id": "d7e592c9c55efe017fcf873aa1f4e05c053f624eec5329ae8cff833b8a2764e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/dvb-frontends/zl10036.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/dvb/frontend.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"zl10036.h\"\n\nstatic int zl10036_debug;\n#define dprintk(level, args...) \\\n\tdo { if (zl10036_debug & level) printk(KERN_DEBUG \"zl10036: \" args); \\\n\t} while (0)\n\n#define deb_info(args...)  dprintk(0x01, args)\n#define deb_i2c(args...)  dprintk(0x02, args)\n\nstruct zl10036_state {\n\tstruct i2c_adapter *i2c;\n\tconst struct zl10036_config *config;\n\tu32 frequency;\n\tu8 br, bf;\n};\n\n\n \n#define _XTAL 10111\n\n \n\n#define _RDIV 10\n#define _RDIV_REG 0x0a\n#define _FR   (_XTAL/_RDIV)\n\n#define STATUS_POR 0x80  \n#define STATUS_FL  0x40  \n\n \n\nstatic int zl10036_read_status_reg(struct zl10036_state *state)\n{\n\tu8 status;\n\tstruct i2c_msg msg[1] = {\n\t\t{ .addr = state->config->tuner_address, .flags = I2C_M_RD,\n\t\t  .buf = &status, .len = sizeof(status) },\n\t};\n\n\tif (i2c_transfer(state->i2c, msg, 1) != 1) {\n\t\tprintk(KERN_ERR \"%s: i2c read failed at addr=%02x\\n\",\n\t\t\t__func__, state->config->tuner_address);\n\t\treturn -EIO;\n\t}\n\n\tdeb_i2c(\"R(status): %02x  [FL=%d]\\n\", status,\n\t\t(status & STATUS_FL) ? 1 : 0);\n\tif (status & STATUS_POR)\n\t\tdeb_info(\"%s: Power-On-Reset bit enabled - need to initialize the tuner\\n\",\n\t\t\t __func__);\n\n\treturn status;\n}\n\nstatic int zl10036_write(struct zl10036_state *state, u8 buf[], u8 count)\n{\n\tstruct i2c_msg msg[1] = {\n\t\t{ .addr = state->config->tuner_address, .flags = 0,\n\t\t  .buf = buf, .len = count },\n\t};\n\tu8 reg = 0;\n\tint ret;\n\n\tif (zl10036_debug & 0x02) {\n\t\t \n\t\tif ((buf[0] & 0x80) == 0x00)\n\t\t\treg = 2;\n\t\telse if ((buf[0] & 0xc0) == 0x80)\n\t\t\treg = 4;\n\t\telse if ((buf[0] & 0xf0) == 0xc0)\n\t\t\treg = 6;\n\t\telse if ((buf[0] & 0xf0) == 0xd0)\n\t\t\treg = 8;\n\t\telse if ((buf[0] & 0xf0) == 0xe0)\n\t\t\treg = 10;\n\t\telse if ((buf[0] & 0xf0) == 0xf0)\n\t\t\treg = 12;\n\n\t\tdeb_i2c(\"W(%d):\", reg);\n\t\t{\n\t\t\tint i;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tprintk(KERN_CONT \" %02x\", buf[i]);\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t}\n\t}\n\n\tret = i2c_transfer(state->i2c, msg, 1);\n\tif (ret != 1) {\n\t\tprintk(KERN_ERR \"%s: i2c error, ret=%d\\n\", __func__, ret);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void zl10036_release(struct dvb_frontend *fe)\n{\n\tstruct zl10036_state *state = fe->tuner_priv;\n\n\tfe->tuner_priv = NULL;\n\tkfree(state);\n}\n\nstatic int zl10036_sleep(struct dvb_frontend *fe)\n{\n\tstruct zl10036_state *state = fe->tuner_priv;\n\tu8 buf[] = { 0xf0, 0x80 };  \n\tint ret;\n\n\tdeb_info(\"%s\\n\", __func__);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tret = zl10036_write(state, buf, sizeof(buf));\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\treturn ret;\n}\n\n \n\nstatic int zl10036_set_frequency(struct zl10036_state *state, u32 frequency)\n{\n\tu8 buf[2];\n\tu32 div, foffset;\n\n\tdiv = (frequency + _FR/2) / _FR;\n\tstate->frequency = div * _FR;\n\n\tfoffset = frequency - state->frequency;\n\n\tbuf[0] = (div >> 8) & 0x7f;\n\tbuf[1] = (div >> 0) & 0xff;\n\n\tdeb_info(\"%s: ftodo=%u fpriv=%u ferr=%d div=%u\\n\", __func__,\n\t\tfrequency, state->frequency, foffset, div);\n\n\treturn zl10036_write(state, buf, sizeof(buf));\n}\n\nstatic int zl10036_set_bandwidth(struct zl10036_state *state, u32 fbw)\n{\n\t \n\tu8 br, bf;\n\tint ret;\n\tu8 buf_bf[] = {\n\t\t0xc0, 0x00,  \n\t};\n\tu8 buf_br[] = {\n\t\t0xf0, 0x00,  \n\t};\n\tu8 zl10036_rsd_off[] = { 0xc8 };  \n\n\t \n\tif (fbw > 35000)\n\t\tfbw = 35000;\n\tif (fbw <  8000)\n\t\tfbw =  8000;\n\n#define _BR_MAXIMUM (_XTAL/575)  \n\n\t \n\tif (fbw <= 28820) {\n\t\tbr = _BR_MAXIMUM;\n\t} else {\n\t\t \n\t\tbr = ((_XTAL * 21 * 1000) / (fbw * 419));\n\t}\n\n\t \n\tif (br < 4)\n\t\tbr = 4;\n\tif (br > _BR_MAXIMUM)\n\t\tbr = _BR_MAXIMUM;\n\n\t \n\n\tbf = (fbw * br * 1257) / (_XTAL * 1000) - 1;\n\n\t \n\tif (bf > 62)\n\t\tbf = 62;\n\n\tbuf_bf[1] = (bf << 1) & 0x7e;\n\tbuf_br[1] = (br << 2) & 0x7c;\n\tdeb_info(\"%s: BW=%d br=%u bf=%u\\n\", __func__, fbw, br, bf);\n\n\tif (br != state->br) {\n\t\tret = zl10036_write(state, buf_br, sizeof(buf_br));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (bf != state->bf) {\n\t\tret = zl10036_write(state, buf_bf, sizeof(buf_bf));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\t \n\t\tmsleep(1);\n\n\t\tret = zl10036_write(state, zl10036_rsd_off,\n\t\t\tsizeof(zl10036_rsd_off));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tstate->br = br;\n\tstate->bf = bf;\n\n\treturn 0;\n}\n\nstatic int zl10036_set_gain_params(struct zl10036_state *state,\n\tint c)\n{\n\tu8 buf[2];\n\tu8 rfg, ba, bg;\n\n\t \n\trfg = 0;  \n\tba = 1;\n\tbg = 1;\n\n\t \n\tbuf[0] = 0x80 | ((rfg << 5) & 0x20)\n\t\t| ((ba  << 3) & 0x18) | ((bg  << 1) & 0x06);\n\n\tif (!state->config->rf_loop_enable)\n\t\tbuf[0] |= 0x01;\n\n\t \n\tbuf[1] = _RDIV_REG | ((c << 5) & 0x60);\n\n\tdeb_info(\"%s: c=%u rfg=%u ba=%u bg=%u\\n\", __func__, c, rfg, ba, bg);\n\treturn zl10036_write(state, buf, sizeof(buf));\n}\n\nstatic int zl10036_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct zl10036_state *state = fe->tuner_priv;\n\tint ret = 0;\n\tu32 frequency = p->frequency;\n\tu32 fbw;\n\tint i;\n\tu8 c;\n\n\t \n\tif ((frequency < fe->ops.info.frequency_min_hz / kHz)\n\t||  (frequency > fe->ops.info.frequency_max_hz / kHz))\n\t\treturn -EINVAL;\n\n\t \n\tfbw = (27 * p->symbol_rate) / 32;\n\n\t \n\tfbw /= 1000;\n\n\t \n\tfbw += 3000;\n\n\t \n\tif (frequency < 950000)\n\t\treturn -EINVAL;\n\telse if (frequency < 1250000)\n\t\tc = 0;\n\telse if (frequency < 1750000)\n\t\tc = 1;\n\telse if (frequency < 2175000)\n\t\tc = 2;\n\telse\n\t\treturn -EINVAL;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tret = zl10036_set_gain_params(state, c);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = zl10036_set_frequency(state, p->frequency);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = zl10036_set_bandwidth(state, fbw);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tfor (i = 0; i < 20; i++) {\n\t\tret = zl10036_read_status_reg(state);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tif (ret & STATUS_FL)\n\t\t\tbreak;\n\n\t\tmsleep(10);\n\t}\n\nerror:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\treturn ret;\n}\n\nstatic int zl10036_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct zl10036_state *state = fe->tuner_priv;\n\n\t*frequency = state->frequency;\n\n\treturn 0;\n}\n\nstatic int zl10036_init_regs(struct zl10036_state *state)\n{\n\tint ret;\n\tint i;\n\n\t \n\tu8 zl10036_init_tab[][2] = {\n\t\t{ 0x04, 0x00 },\t\t \n\t\t{ 0x8b, _RDIV_REG },\t \n\t\t\t\t\t \n\t\t{ 0xc0, 0x20 },\t\t \n\t\t{ 0xd3, 0x40 },\t\t \n\t\t{ 0xe3, 0x5b },\t\t \n\t\t{ 0xf0, 0x28 },\t\t \n\t\t{ 0xe3, 0xf9 },\t\t \n\t};\n\n\t \n\tstate->br = 0xff;\n\tstate->bf = 0xff;\n\n\tif (!state->config->rf_loop_enable)\n\t\tzl10036_init_tab[1][0] |= 0x01;\n\n\tdeb_info(\"%s\\n\", __func__);\n\n\tfor (i = 0; i < ARRAY_SIZE(zl10036_init_tab); i++) {\n\t\tret = zl10036_write(state, zl10036_init_tab[i], 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int zl10036_init(struct dvb_frontend *fe)\n{\n\tstruct zl10036_state *state = fe->tuner_priv;\n\tint ret = 0;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tret = zl10036_read_status_reg(state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = zl10036_init_regs(state);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\treturn ret;\n}\n\nstatic const struct dvb_tuner_ops zl10036_tuner_ops = {\n\t.info = {\n\t\t.name = \"Zarlink ZL10036\",\n\t\t.frequency_min_hz =  950 * MHz,\n\t\t.frequency_max_hz = 2175 * MHz\n\t},\n\t.init = zl10036_init,\n\t.release = zl10036_release,\n\t.sleep = zl10036_sleep,\n\t.set_params = zl10036_set_params,\n\t.get_frequency = zl10036_get_frequency,\n};\n\nstruct dvb_frontend *zl10036_attach(struct dvb_frontend *fe,\n\t\t\t\t    const struct zl10036_config *config,\n\t\t\t\t    struct i2c_adapter *i2c)\n{\n\tstruct zl10036_state *state;\n\tint ret;\n\n\tif (!config) {\n\t\tprintk(KERN_ERR \"%s: no config specified\", __func__);\n\t\treturn NULL;\n\t}\n\n\tstate = kzalloc(sizeof(struct zl10036_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tstate->config = config;\n\tstate->i2c = i2c;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);  \n\n\tret = zl10036_read_status_reg(state);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"%s: No zl10036 found\\n\", __func__);\n\t\tgoto error;\n\t}\n\n\tret = zl10036_init_regs(state);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"%s: tuner initialization failed\\n\",\n\t\t\t__func__);\n\t\tgoto error;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);  \n\n\tfe->tuner_priv = state;\n\n\tmemcpy(&fe->ops.tuner_ops, &zl10036_tuner_ops,\n\t\tsizeof(struct dvb_tuner_ops));\n\tprintk(KERN_INFO \"%s: tuner initialization (%s addr=0x%02x) ok\\n\",\n\t\t__func__, fe->ops.tuner_ops.info.name, config->tuner_address);\n\n\treturn fe;\n\nerror:\n\tkfree(state);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(zl10036_attach);\n\nmodule_param_named(debug, zl10036_debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off frontend debugging (default:off).\");\nMODULE_DESCRIPTION(\"DVB ZL10036 driver\");\nMODULE_AUTHOR(\"Tino Reichardt\");\nMODULE_AUTHOR(\"Matthias Schwarzott\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}