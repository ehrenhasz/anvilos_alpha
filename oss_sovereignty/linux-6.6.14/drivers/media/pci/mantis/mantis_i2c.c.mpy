{
  "module_name": "mantis_i2c.c",
  "hash_id": "1ae568267f58196bd0c871b95bd22436fc2e2346b7b433dfceb327f0b737ced9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/mantis/mantis_i2c.c",
  "human_readable_source": "\n \n\n#include <asm/io.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/i2c.h>\n\n#include <media/dmxdev.h>\n#include <media/dvbdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n#include <media/dvb_net.h>\n\n#include \"mantis_common.h\"\n#include \"mantis_reg.h\"\n#include \"mantis_i2c.h\"\n\n#define TRIALS\t\t\t10000\n\nstatic int mantis_i2c_read(struct mantis_pci *mantis, const struct i2c_msg *msg)\n{\n\tu32 rxd, i, stat, trials;\n\n\tdprintk(MANTIS_INFO, 0, \"        %s:  Address=[0x%02x] <R>[ \",\n\t\t__func__, msg->addr);\n\n\tfor (i = 0; i < msg->len; i++) {\n\t\trxd = (msg->addr << 25) | (1 << 24)\n\t\t\t\t\t| MANTIS_I2C_RATE_3\n\t\t\t\t\t| MANTIS_I2C_STOP\n\t\t\t\t\t| MANTIS_I2C_PGMODE;\n\n\t\tif (i == (msg->len - 1))\n\t\t\trxd &= ~MANTIS_I2C_STOP;\n\n\t\tmmwrite(MANTIS_INT_I2CDONE, MANTIS_INT_STAT);\n\t\tmmwrite(rxd, MANTIS_I2CDATA_CTL);\n\n\t\t \n\t\tfor (trials = 0; trials < TRIALS; trials++) {\n\t\t\tstat = mmread(MANTIS_INT_STAT);\n\t\t\tif (stat & MANTIS_INT_I2CDONE)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdprintk(MANTIS_TMG, 0, \"I2CDONE: trials=%d\\n\", trials);\n\n\t\t \n\t\tfor (trials = 0; trials < TRIALS; trials++) {\n\t\t\tstat = mmread(MANTIS_INT_STAT);\n\t\t\tif (stat & MANTIS_INT_I2CRACK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdprintk(MANTIS_TMG, 0, \"I2CRACK: trials=%d\\n\", trials);\n\n\t\trxd = mmread(MANTIS_I2CDATA_CTL);\n\t\tmsg->buf[i] = (u8)((rxd >> 8) & 0xFF);\n\t\tdprintk(MANTIS_INFO, 0, \"%02x \", msg->buf[i]);\n\t}\n\tdprintk(MANTIS_INFO, 0, \"]\\n\");\n\n\treturn 0;\n}\n\nstatic int mantis_i2c_write(struct mantis_pci *mantis, const struct i2c_msg *msg)\n{\n\tint i;\n\tu32 txd = 0, stat, trials;\n\n\tdprintk(MANTIS_INFO, 0, \"        %s: Address=[0x%02x] <W>[ \",\n\t\t__func__, msg->addr);\n\n\tfor (i = 0; i < msg->len; i++) {\n\t\tdprintk(MANTIS_INFO, 0, \"%02x \", msg->buf[i]);\n\t\ttxd = (msg->addr << 25) | (msg->buf[i] << 8)\n\t\t\t\t\t| MANTIS_I2C_RATE_3\n\t\t\t\t\t| MANTIS_I2C_STOP\n\t\t\t\t\t| MANTIS_I2C_PGMODE;\n\n\t\tif (i == (msg->len - 1))\n\t\t\ttxd &= ~MANTIS_I2C_STOP;\n\n\t\tmmwrite(MANTIS_INT_I2CDONE, MANTIS_INT_STAT);\n\t\tmmwrite(txd, MANTIS_I2CDATA_CTL);\n\n\t\t \n\t\tfor (trials = 0; trials < TRIALS; trials++) {\n\t\t\tstat = mmread(MANTIS_INT_STAT);\n\t\t\tif (stat & MANTIS_INT_I2CDONE)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdprintk(MANTIS_TMG, 0, \"I2CDONE: trials=%d\\n\", trials);\n\n\t\t \n\t\tfor (trials = 0; trials < TRIALS; trials++) {\n\t\t\tstat = mmread(MANTIS_INT_STAT);\n\t\t\tif (stat & MANTIS_INT_I2CRACK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdprintk(MANTIS_TMG, 0, \"I2CRACK: trials=%d\\n\", trials);\n\t}\n\tdprintk(MANTIS_INFO, 0, \"]\\n\");\n\n\treturn 0;\n}\n\nstatic int mantis_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)\n{\n\tint ret = 0, i = 0, trials;\n\tu32 stat, data, txd;\n\tstruct mantis_pci *mantis;\n\tstruct mantis_hwconfig *config;\n\n\tmantis = i2c_get_adapdata(adapter);\n\tBUG_ON(!mantis);\n\tconfig = mantis->hwconfig;\n\tBUG_ON(!config);\n\n\tdprintk(MANTIS_DEBUG, 1, \"Messages:%d\", num);\n\tmutex_lock(&mantis->i2c_lock);\n\n\twhile (i < num) {\n\t\t \n\t\tif ((config->i2c_mode & MANTIS_BYTE_MODE) &&\n\t\t    ((i + 1) < num)\t\t\t&&\n\t\t    (msgs[i].len < 2)\t\t\t&&\n\t\t    (msgs[i + 1].len < 2)\t\t&&\n\t\t    (msgs[i + 1].flags & I2C_M_RD)) {\n\n\t\t\tdprintk(MANTIS_DEBUG, 0, \"        Byte MODE:\\n\");\n\n\t\t\t \n\t\t\ttxd = msgs[i].addr << 25 | (0x1 << 24)\n\t\t\t\t\t\t | (msgs[i].buf[0] << 16)\n\t\t\t\t\t\t | MANTIS_I2C_RATE_3;\n\n\t\t\tmmwrite(txd, MANTIS_I2CDATA_CTL);\n\t\t\t \n\t\t\tfor (trials = 0; trials < TRIALS; trials++) {\n\t\t\t\tstat = mmread(MANTIS_INT_STAT);\n\t\t\t\tif (stat & MANTIS_INT_I2CDONE)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (stat & MANTIS_INT_I2CDONE) {\n\t\t\t\t \n\t\t\t\tif (stat & MANTIS_INT_I2CRACK) {\n\t\t\t\t\tdata = mmread(MANTIS_I2CDATA_CTL);\n\t\t\t\t\tmsgs[i + 1].buf[0] = (data >> 8) & 0xff;\n\t\t\t\t\tdprintk(MANTIS_DEBUG, 0, \"        Byte <%d> RXD=0x%02x  [%02x]\\n\", 0x0, data, msgs[i + 1].buf[0]);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tdprintk(MANTIS_ERROR, 1, \"        I/O error, LINE:%d\", __LINE__);\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdprintk(MANTIS_ERROR, 1, \"        I/O error, LINE:%d\", __LINE__);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += 2;  \n\t\t}\n\n\t\tif (i < num) {\n\t\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\t\tret = mantis_i2c_read(mantis, &msgs[i]);\n\t\t\telse\n\t\t\t\tret = mantis_i2c_write(mantis, &msgs[i]);\n\n\t\t\ti++;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto bail_out;\n\t\t}\n\n\t}\n\n\tmutex_unlock(&mantis->i2c_lock);\n\n\treturn num;\n\nbail_out:\n\tmutex_unlock(&mantis->i2c_lock);\n\treturn ret;\n}\n\nstatic u32 mantis_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm mantis_algo = {\n\t.master_xfer\t\t= mantis_i2c_xfer,\n\t.functionality\t\t= mantis_i2c_func,\n};\n\nint mantis_i2c_init(struct mantis_pci *mantis)\n{\n\tu32 intstat;\n\tstruct i2c_adapter *i2c_adapter = &mantis->adapter;\n\tstruct pci_dev *pdev\t\t= mantis->pdev;\n\n\tinit_waitqueue_head(&mantis->i2c_wq);\n\tmutex_init(&mantis->i2c_lock);\n\tstrscpy(i2c_adapter->name, \"Mantis I2C\", sizeof(i2c_adapter->name));\n\ti2c_set_adapdata(i2c_adapter, mantis);\n\n\ti2c_adapter->owner\t= THIS_MODULE;\n\ti2c_adapter->algo\t= &mantis_algo;\n\ti2c_adapter->algo_data\t= NULL;\n\ti2c_adapter->timeout\t= 500;\n\ti2c_adapter->retries\t= 3;\n\ti2c_adapter->dev.parent\t= &pdev->dev;\n\n\tmantis->i2c_rc\t\t= i2c_add_adapter(i2c_adapter);\n\tif (mantis->i2c_rc < 0)\n\t\treturn mantis->i2c_rc;\n\n\tdprintk(MANTIS_DEBUG, 1, \"Initializing I2C ..\");\n\n\tintstat = mmread(MANTIS_INT_STAT);\n\tmmread(MANTIS_INT_MASK);\n\tmmwrite(intstat, MANTIS_INT_STAT);\n\tdprintk(MANTIS_DEBUG, 1, \"Disabling I2C interrupt\");\n\tmantis_mask_ints(mantis, MANTIS_INT_I2CDONE);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mantis_i2c_init);\n\nint mantis_i2c_exit(struct mantis_pci *mantis)\n{\n\tdprintk(MANTIS_DEBUG, 1, \"Disabling I2C interrupt\");\n\tmantis_mask_ints(mantis, MANTIS_INT_I2CDONE);\n\n\tdprintk(MANTIS_DEBUG, 1, \"Removing I2C adapter\");\n\ti2c_del_adapter(&mantis->adapter);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mantis_i2c_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}