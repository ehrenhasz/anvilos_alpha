{
  "module_name": "mantis_ca.c",
  "hash_id": "156fad7755cfa72c963252ef0050815f4aee3da4b7bd2e57b172bb1891a6afb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/mantis/mantis_ca.c",
  "human_readable_source": "\n \n\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <asm/io.h>\n\n#include <media/dmxdev.h>\n#include <media/dvbdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n#include <media/dvb_net.h>\n\n#include \"mantis_common.h\"\n#include \"mantis_link.h\"\n#include \"mantis_hif.h\"\n#include \"mantis_reg.h\"\n\n#include \"mantis_ca.h\"\n\nstatic int mantis_ca_read_attr_mem(struct dvb_ca_en50221 *en50221, int slot, int addr)\n{\n\tstruct mantis_ca *ca = en50221->data;\n\tstruct mantis_pci *mantis = ca->ca_priv;\n\n\tdprintk(MANTIS_DEBUG, 1, \"Slot(%d): Request Attribute Mem Read\", slot);\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\treturn mantis_hif_read_mem(ca, addr);\n}\n\nstatic int mantis_ca_write_attr_mem(struct dvb_ca_en50221 *en50221, int slot, int addr, u8 data)\n{\n\tstruct mantis_ca *ca = en50221->data;\n\tstruct mantis_pci *mantis = ca->ca_priv;\n\n\tdprintk(MANTIS_DEBUG, 1, \"Slot(%d): Request Attribute Mem Write\", slot);\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\treturn mantis_hif_write_mem(ca, addr, data);\n}\n\nstatic int mantis_ca_read_cam_ctl(struct dvb_ca_en50221 *en50221, int slot, u8 addr)\n{\n\tstruct mantis_ca *ca = en50221->data;\n\tstruct mantis_pci *mantis = ca->ca_priv;\n\n\tdprintk(MANTIS_DEBUG, 1, \"Slot(%d): Request CAM control Read\", slot);\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\treturn mantis_hif_read_iom(ca, addr);\n}\n\nstatic int mantis_ca_write_cam_ctl(struct dvb_ca_en50221 *en50221, int slot, u8 addr, u8 data)\n{\n\tstruct mantis_ca *ca = en50221->data;\n\tstruct mantis_pci *mantis = ca->ca_priv;\n\n\tdprintk(MANTIS_DEBUG, 1, \"Slot(%d): Request CAM control Write\", slot);\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\treturn mantis_hif_write_iom(ca, addr, data);\n}\n\nstatic int mantis_ca_slot_reset(struct dvb_ca_en50221 *en50221, int slot)\n{\n\tstruct mantis_ca *ca = en50221->data;\n\tstruct mantis_pci *mantis = ca->ca_priv;\n\n\tdprintk(MANTIS_DEBUG, 1, \"Slot(%d): Slot RESET\", slot);\n\tudelay(500);  \n\tmmwrite(0xda, MANTIS_PCMCIA_RESET);  \n\tudelay(500);\n\tmmwrite(0x00, MANTIS_PCMCIA_RESET);  \n\tmsleep(1000);\n\tdvb_ca_en50221_camready_irq(&ca->en50221, 0);\n\n\treturn 0;\n}\n\nstatic int mantis_ca_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)\n{\n\tstruct mantis_ca *ca = en50221->data;\n\tstruct mantis_pci *mantis = ca->ca_priv;\n\n\tdprintk(MANTIS_DEBUG, 1, \"Slot(%d): Slot shutdown\", slot);\n\n\treturn 0;\n}\n\nstatic int mantis_ts_control(struct dvb_ca_en50221 *en50221, int slot)\n{\n\tstruct mantis_ca *ca = en50221->data;\n\tstruct mantis_pci *mantis = ca->ca_priv;\n\n\tdprintk(MANTIS_DEBUG, 1, \"Slot(%d): TS control\", slot);\n\n\treturn 0;\n}\n\nstatic int mantis_slot_status(struct dvb_ca_en50221 *en50221, int slot, int open)\n{\n\tstruct mantis_ca *ca = en50221->data;\n\tstruct mantis_pci *mantis = ca->ca_priv;\n\n\tdprintk(MANTIS_DEBUG, 1, \"Slot(%d): Poll Slot status\", slot);\n\n\tif (ca->slot_state == MODULE_INSERTED) {\n\t\tdprintk(MANTIS_DEBUG, 1, \"CA Module present and ready\");\n\t\treturn DVB_CA_EN50221_POLL_CAM_PRESENT | DVB_CA_EN50221_POLL_CAM_READY;\n\t} else {\n\t\tdprintk(MANTIS_DEBUG, 1, \"CA Module not present or not ready\");\n\t}\n\n\treturn 0;\n}\n\nint mantis_ca_init(struct mantis_pci *mantis)\n{\n\tstruct dvb_adapter *dvb_adapter\t= &mantis->dvb_adapter;\n\tstruct mantis_ca *ca;\n\tint ca_flags = 0, result;\n\n\tdprintk(MANTIS_DEBUG, 1, \"Initializing Mantis CA\");\n\tca = kzalloc(sizeof(struct mantis_ca), GFP_KERNEL);\n\tif (!ca) {\n\t\tdprintk(MANTIS_ERROR, 1, \"Out of memory!, exiting ..\");\n\t\tresult = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tca->ca_priv\t\t= mantis;\n\tmantis->mantis_ca\t= ca;\n\tca_flags\t\t= DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE;\n\t \n\tca->en50221.owner\t\t= THIS_MODULE;\n\tca->en50221.read_attribute_mem\t= mantis_ca_read_attr_mem;\n\tca->en50221.write_attribute_mem\t= mantis_ca_write_attr_mem;\n\tca->en50221.read_cam_control\t= mantis_ca_read_cam_ctl;\n\tca->en50221.write_cam_control\t= mantis_ca_write_cam_ctl;\n\tca->en50221.slot_reset\t\t= mantis_ca_slot_reset;\n\tca->en50221.slot_shutdown\t= mantis_ca_slot_shutdown;\n\tca->en50221.slot_ts_enable\t= mantis_ts_control;\n\tca->en50221.poll_slot_status\t= mantis_slot_status;\n\tca->en50221.data\t\t= ca;\n\n\tmutex_init(&ca->ca_lock);\n\n\tinit_waitqueue_head(&ca->hif_data_wq);\n\tinit_waitqueue_head(&ca->hif_opdone_wq);\n\tinit_waitqueue_head(&ca->hif_write_wq);\n\n\tdprintk(MANTIS_ERROR, 1, \"Registering EN50221 device\");\n\tresult = dvb_ca_en50221_init(dvb_adapter, &ca->en50221, ca_flags, 1);\n\tif (result != 0) {\n\t\tdprintk(MANTIS_ERROR, 1, \"EN50221: Initialization failed <%d>\", result);\n\t\tgoto err;\n\t}\n\tdprintk(MANTIS_ERROR, 1, \"Registered EN50221 device\");\n\tmantis_evmgr_init(ca);\n\treturn 0;\nerr:\n\tkfree(ca);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(mantis_ca_init);\n\nvoid mantis_ca_exit(struct mantis_pci *mantis)\n{\n\tstruct mantis_ca *ca = mantis->mantis_ca;\n\n\tdprintk(MANTIS_DEBUG, 1, \"Mantis CA exit\");\n\tif (!ca)\n\t\treturn;\n\n\tmantis_evmgr_exit(ca);\n\tdprintk(MANTIS_ERROR, 1, \"Unregistering EN50221 device\");\n\tdvb_ca_en50221_release(&ca->en50221);\n\n\tkfree(ca);\n}\nEXPORT_SYMBOL_GPL(mantis_ca_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}