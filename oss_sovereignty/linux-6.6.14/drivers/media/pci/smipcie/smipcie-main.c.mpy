{
  "module_name": "smipcie-main.c",
  "hash_id": "2f2c444b7ce6a7466508bb9c8253a2953615890dda36c4f7b2d24d075a1828cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/smipcie/smipcie-main.c",
  "human_readable_source": "\n \n\n#include \"smipcie.h\"\n#include \"m88ds3103.h\"\n#include \"ts2020.h\"\n#include \"m88rs6000t.h\"\n#include \"si2168.h\"\n#include \"si2157.h\"\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int smi_hw_init(struct smi_dev *dev)\n{\n\tu32 port_mux, port_ctrl, int_stat;\n\n\t \n\tport_mux = smi_read(MUX_MODE_CTRL);\n\tport_mux &= ~(rbPaMSMask);\n\tport_mux |= rbPaMSDtvNoGpio;\n\tport_mux &= ~(rbPbMSMask);\n\tport_mux |= rbPbMSDtvNoGpio;\n\tport_mux &= ~(0x0f0000);\n\tport_mux |= 0x50000;\n\tsmi_write(MUX_MODE_CTRL, port_mux);\n\n\t \n\t \n\tport_ctrl = smi_read(VIDEO_CTRL_STATUS_A);\n\tport_ctrl &= ~0x01;\n\tsmi_write(VIDEO_CTRL_STATUS_A, port_ctrl);\n\tport_ctrl = smi_read(MPEG2_CTRL_A);\n\tport_ctrl &= ~0x40;\n\tport_ctrl |= 0x80;\n\tsmi_write(MPEG2_CTRL_A, port_ctrl);\n\t \n\tport_ctrl = smi_read(VIDEO_CTRL_STATUS_B);\n\tport_ctrl &= ~0x01;\n\tsmi_write(VIDEO_CTRL_STATUS_B, port_ctrl);\n\tport_ctrl = smi_read(MPEG2_CTRL_B);\n\tport_ctrl &= ~0x40;\n\tport_ctrl |= 0x80;\n\tsmi_write(MPEG2_CTRL_B, port_ctrl);\n\n\t \n\tsmi_write(MSI_INT_ENA_CLR, ALL_INT);\n\tint_stat = smi_read(MSI_INT_STATUS);\n\tsmi_write(MSI_INT_STATUS_CLR, int_stat);\n\n\t \n\tsmi_clear(PERIPHERAL_CTRL, 0x0303);\n\tmsleep(50);\n\tsmi_set(PERIPHERAL_CTRL, 0x0101);\n\treturn 0;\n}\n\n \nstatic void smi_i2c_cfg(struct smi_dev *dev, u32 sw_ctl)\n{\n\tu32 dwCtrl;\n\n\tdwCtrl = smi_read(sw_ctl);\n\tdwCtrl &= ~0x18;  \n\tdwCtrl |= 0x21;  \n\tdwCtrl &= ~0xff00;\n\tdwCtrl |= 0x6400;\n\tsmi_write(sw_ctl, dwCtrl);\n\tmsleep(20);\n\tdwCtrl = smi_read(sw_ctl);\n\tdwCtrl &= ~0x20;\n\tsmi_write(sw_ctl, dwCtrl);\n}\n\nstatic void smi_i2c_setsda(struct smi_dev *dev, int state, u32 sw_ctl)\n{\n\tif (state) {\n\t\t \n\t\tsmi_clear(sw_ctl, SW_I2C_MSK_DAT_EN);\n\t} else {\n\t\tsmi_clear(sw_ctl, SW_I2C_MSK_DAT_OUT);\n\t\t \n\t\tsmi_set(sw_ctl, SW_I2C_MSK_DAT_EN);\n\t}\n}\n\nstatic void smi_i2c_setscl(void *data, int state, u32 sw_ctl)\n{\n\tstruct smi_dev *dev = data;\n\n\tif (state) {\n\t\t \n\t\tsmi_clear(sw_ctl, SW_I2C_MSK_CLK_EN);\n\t} else {\n\t\tsmi_clear(sw_ctl, SW_I2C_MSK_CLK_OUT);\n\t\t \n\t\tsmi_set(sw_ctl, SW_I2C_MSK_CLK_EN);\n\t}\n}\n\nstatic int smi_i2c_getsda(void *data, u32 sw_ctl)\n{\n\tstruct smi_dev *dev = data;\n\t \n\tsmi_clear(sw_ctl, SW_I2C_MSK_DAT_EN);\n\tudelay(1);\n\treturn (smi_read(sw_ctl) & SW_I2C_MSK_DAT_IN) ? 1 : 0;\n}\n\nstatic int smi_i2c_getscl(void *data, u32 sw_ctl)\n{\n\tstruct smi_dev *dev = data;\n\t \n\tsmi_clear(sw_ctl, SW_I2C_MSK_CLK_EN);\n\tudelay(1);\n\treturn (smi_read(sw_ctl) & SW_I2C_MSK_CLK_IN) ? 1 : 0;\n}\n \nstatic void smi_i2c0_setsda(void *data, int state)\n{\n\tstruct smi_dev *dev = data;\n\n\tsmi_i2c_setsda(dev, state, I2C_A_SW_CTL);\n}\n\nstatic void smi_i2c0_setscl(void *data, int state)\n{\n\tstruct smi_dev *dev = data;\n\n\tsmi_i2c_setscl(dev, state, I2C_A_SW_CTL);\n}\n\nstatic int smi_i2c0_getsda(void *data)\n{\n\tstruct smi_dev *dev = data;\n\n\treturn\tsmi_i2c_getsda(dev, I2C_A_SW_CTL);\n}\n\nstatic int smi_i2c0_getscl(void *data)\n{\n\tstruct smi_dev *dev = data;\n\n\treturn\tsmi_i2c_getscl(dev, I2C_A_SW_CTL);\n}\n \nstatic void smi_i2c1_setsda(void *data, int state)\n{\n\tstruct smi_dev *dev = data;\n\n\tsmi_i2c_setsda(dev, state, I2C_B_SW_CTL);\n}\n\nstatic void smi_i2c1_setscl(void *data, int state)\n{\n\tstruct smi_dev *dev = data;\n\n\tsmi_i2c_setscl(dev, state, I2C_B_SW_CTL);\n}\n\nstatic int smi_i2c1_getsda(void *data)\n{\n\tstruct smi_dev *dev = data;\n\n\treturn\tsmi_i2c_getsda(dev, I2C_B_SW_CTL);\n}\n\nstatic int smi_i2c1_getscl(void *data)\n{\n\tstruct smi_dev *dev = data;\n\n\treturn\tsmi_i2c_getscl(dev, I2C_B_SW_CTL);\n}\n\nstatic int smi_i2c_init(struct smi_dev *dev)\n{\n\tint ret;\n\n\t \n\tsmi_i2c_cfg(dev, I2C_A_SW_CTL);\n\ti2c_set_adapdata(&dev->i2c_bus[0], dev);\n\tstrscpy(dev->i2c_bus[0].name, \"SMI-I2C0\", sizeof(dev->i2c_bus[0].name));\n\tdev->i2c_bus[0].owner = THIS_MODULE;\n\tdev->i2c_bus[0].dev.parent = &dev->pci_dev->dev;\n\tdev->i2c_bus[0].algo_data = &dev->i2c_bit[0];\n\tdev->i2c_bit[0].data = dev;\n\tdev->i2c_bit[0].setsda = smi_i2c0_setsda;\n\tdev->i2c_bit[0].setscl = smi_i2c0_setscl;\n\tdev->i2c_bit[0].getsda = smi_i2c0_getsda;\n\tdev->i2c_bit[0].getscl = smi_i2c0_getscl;\n\tdev->i2c_bit[0].udelay = 12;\n\tdev->i2c_bit[0].timeout = 10;\n\t \n\tsmi_i2c0_setsda(dev, 1);\n\tsmi_i2c0_setscl(dev, 1);\n\n\tret = i2c_bit_add_bus(&dev->i2c_bus[0]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsmi_i2c_cfg(dev, I2C_B_SW_CTL);\n\ti2c_set_adapdata(&dev->i2c_bus[1], dev);\n\tstrscpy(dev->i2c_bus[1].name, \"SMI-I2C1\", sizeof(dev->i2c_bus[1].name));\n\tdev->i2c_bus[1].owner = THIS_MODULE;\n\tdev->i2c_bus[1].dev.parent = &dev->pci_dev->dev;\n\tdev->i2c_bus[1].algo_data = &dev->i2c_bit[1];\n\tdev->i2c_bit[1].data = dev;\n\tdev->i2c_bit[1].setsda = smi_i2c1_setsda;\n\tdev->i2c_bit[1].setscl = smi_i2c1_setscl;\n\tdev->i2c_bit[1].getsda = smi_i2c1_getsda;\n\tdev->i2c_bit[1].getscl = smi_i2c1_getscl;\n\tdev->i2c_bit[1].udelay = 12;\n\tdev->i2c_bit[1].timeout = 10;\n\t \n\tsmi_i2c1_setsda(dev, 1);\n\tsmi_i2c1_setscl(dev, 1);\n\n\tret = i2c_bit_add_bus(&dev->i2c_bus[1]);\n\tif (ret < 0)\n\t\ti2c_del_adapter(&dev->i2c_bus[0]);\n\n\treturn ret;\n}\n\nstatic void smi_i2c_exit(struct smi_dev *dev)\n{\n\ti2c_del_adapter(&dev->i2c_bus[0]);\n\ti2c_del_adapter(&dev->i2c_bus[1]);\n}\n\nstatic int smi_read_eeprom(struct i2c_adapter *i2c, u16 reg, u8 *data, u16 size)\n{\n\tint ret;\n\tu8 b0[2] = { (reg >> 8) & 0xff, reg & 0xff };\n\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = 0x50, .flags = 0,\n\t\t\t.buf = b0, .len = 2 },\n\t\t{ .addr = 0x50, .flags = I2C_M_RD,\n\t\t\t.buf = data, .len = size }\n\t};\n\n\tret = i2c_transfer(i2c, msg, 2);\n\n\tif (ret != 2) {\n\t\tdev_err(&i2c->dev, \"%s: reg=0x%x (error=%d)\\n\",\n\t\t\t__func__, reg, ret);\n\t\treturn ret;\n\t}\n\treturn ret;\n}\n\n \nstatic void smi_port_disableInterrupt(struct smi_port *port)\n{\n\tstruct smi_dev *dev = port->dev;\n\n\tsmi_write(MSI_INT_ENA_CLR,\n\t\t(port->_dmaInterruptCH0 | port->_dmaInterruptCH1));\n}\n\nstatic void smi_port_enableInterrupt(struct smi_port *port)\n{\n\tstruct smi_dev *dev = port->dev;\n\n\tsmi_write(MSI_INT_ENA_SET,\n\t\t(port->_dmaInterruptCH0 | port->_dmaInterruptCH1));\n}\n\nstatic void smi_port_clearInterrupt(struct smi_port *port)\n{\n\tstruct smi_dev *dev = port->dev;\n\n\tsmi_write(MSI_INT_STATUS_CLR,\n\t\t(port->_dmaInterruptCH0 | port->_dmaInterruptCH1));\n}\n\n \nstatic void smi_dma_xfer(struct tasklet_struct *t)\n{\n\tstruct smi_port *port = from_tasklet(port, t, tasklet);\n\tstruct smi_dev *dev = port->dev;\n\tu32 intr_status, finishedData, dmaManagement;\n\tu8 dmaChan0State, dmaChan1State;\n\n\tintr_status = port->_int_status;\n\tdmaManagement = smi_read(port->DMA_MANAGEMENT);\n\tdmaChan0State = (u8)((dmaManagement & 0x00000030) >> 4);\n\tdmaChan1State = (u8)((dmaManagement & 0x00300000) >> 20);\n\n\t \n\tif ((intr_status & port->_dmaInterruptCH0) && (dmaChan0State == 0x01)) {\n\t\tdev_dbg(&dev->pci_dev->dev,\n\t\t\t\"Port[%d]-DMA CH0 engine complete successful !\\n\",\n\t\t\tport->idx);\n\t\tfinishedData = smi_read(port->DMA_CHAN0_TRANS_STATE);\n\t\tfinishedData &= 0x003FFFFF;\n\t\t \n\t\tif (finishedData == 0)\n\t\t\tfinishedData = 0x00400000;\n\t\tif (finishedData != SMI_TS_DMA_BUF_SIZE) {\n\t\t\tdev_dbg(&dev->pci_dev->dev,\n\t\t\t\t\"DMA CH0 engine complete length mismatched, finish data=%d !\\n\",\n\t\t\t\tfinishedData);\n\t\t}\n\t\tdvb_dmx_swfilter_packets(&port->demux,\n\t\t\tport->cpu_addr[0], (finishedData / 188));\n\t\t \n\t}\n\t \n\tif ((intr_status & port->_dmaInterruptCH1) && (dmaChan1State == 0x01)) {\n\t\tdev_dbg(&dev->pci_dev->dev,\n\t\t\t\"Port[%d]-DMA CH1 engine complete successful !\\n\",\n\t\t\tport->idx);\n\t\tfinishedData = smi_read(port->DMA_CHAN1_TRANS_STATE);\n\t\tfinishedData &= 0x003FFFFF;\n\t\t \n\t\tif (finishedData == 0)\n\t\t\tfinishedData = 0x00400000;\n\t\tif (finishedData != SMI_TS_DMA_BUF_SIZE) {\n\t\t\tdev_dbg(&dev->pci_dev->dev,\n\t\t\t\t\"DMA CH1 engine complete length mismatched, finish data=%d !\\n\",\n\t\t\t\tfinishedData);\n\t\t}\n\t\tdvb_dmx_swfilter_packets(&port->demux,\n\t\t\tport->cpu_addr[1], (finishedData / 188));\n\t\t \n\t}\n\t \n\tif (intr_status & port->_dmaInterruptCH0)\n\t\tdmaManagement |= 0x00000002;\n\tif (intr_status & port->_dmaInterruptCH1)\n\t\tdmaManagement |= 0x00020000;\n\tsmi_write(port->DMA_MANAGEMENT, dmaManagement);\n\t \n\tsmi_port_enableInterrupt(port);\n}\n\nstatic void smi_port_dma_free(struct smi_port *port)\n{\n\tif (port->cpu_addr[0]) {\n\t\tdma_free_coherent(&port->dev->pci_dev->dev,\n\t\t\t\t  SMI_TS_DMA_BUF_SIZE, port->cpu_addr[0],\n\t\t\t\t  port->dma_addr[0]);\n\t\tport->cpu_addr[0] = NULL;\n\t}\n\tif (port->cpu_addr[1]) {\n\t\tdma_free_coherent(&port->dev->pci_dev->dev,\n\t\t\t\t  SMI_TS_DMA_BUF_SIZE, port->cpu_addr[1],\n\t\t\t\t  port->dma_addr[1]);\n\t\tport->cpu_addr[1] = NULL;\n\t}\n}\n\nstatic int smi_port_init(struct smi_port *port, int dmaChanUsed)\n{\n\tdev_dbg(&port->dev->pci_dev->dev,\n\t\t\"%s, port %d, dmaused %d\\n\", __func__, port->idx, dmaChanUsed);\n\tport->enable = 0;\n\tif (port->idx == 0) {\n\t\t \n\t\tport->_dmaInterruptCH0 = dmaChanUsed & 0x01;\n\t\tport->_dmaInterruptCH1 = dmaChanUsed & 0x02;\n\n\t\tport->DMA_CHAN0_ADDR_LOW\t= DMA_PORTA_CHAN0_ADDR_LOW;\n\t\tport->DMA_CHAN0_ADDR_HI\t\t= DMA_PORTA_CHAN0_ADDR_HI;\n\t\tport->DMA_CHAN0_TRANS_STATE\t= DMA_PORTA_CHAN0_TRANS_STATE;\n\t\tport->DMA_CHAN0_CONTROL\t\t= DMA_PORTA_CHAN0_CONTROL;\n\t\tport->DMA_CHAN1_ADDR_LOW\t= DMA_PORTA_CHAN1_ADDR_LOW;\n\t\tport->DMA_CHAN1_ADDR_HI\t\t= DMA_PORTA_CHAN1_ADDR_HI;\n\t\tport->DMA_CHAN1_TRANS_STATE\t= DMA_PORTA_CHAN1_TRANS_STATE;\n\t\tport->DMA_CHAN1_CONTROL\t\t= DMA_PORTA_CHAN1_CONTROL;\n\t\tport->DMA_MANAGEMENT\t\t= DMA_PORTA_MANAGEMENT;\n\t} else {\n\t\t \n\t\tport->_dmaInterruptCH0 = (dmaChanUsed << 2) & 0x04;\n\t\tport->_dmaInterruptCH1 = (dmaChanUsed << 2) & 0x08;\n\n\t\tport->DMA_CHAN0_ADDR_LOW\t= DMA_PORTB_CHAN0_ADDR_LOW;\n\t\tport->DMA_CHAN0_ADDR_HI\t\t= DMA_PORTB_CHAN0_ADDR_HI;\n\t\tport->DMA_CHAN0_TRANS_STATE\t= DMA_PORTB_CHAN0_TRANS_STATE;\n\t\tport->DMA_CHAN0_CONTROL\t\t= DMA_PORTB_CHAN0_CONTROL;\n\t\tport->DMA_CHAN1_ADDR_LOW\t= DMA_PORTB_CHAN1_ADDR_LOW;\n\t\tport->DMA_CHAN1_ADDR_HI\t\t= DMA_PORTB_CHAN1_ADDR_HI;\n\t\tport->DMA_CHAN1_TRANS_STATE\t= DMA_PORTB_CHAN1_TRANS_STATE;\n\t\tport->DMA_CHAN1_CONTROL\t\t= DMA_PORTB_CHAN1_CONTROL;\n\t\tport->DMA_MANAGEMENT\t\t= DMA_PORTB_MANAGEMENT;\n\t}\n\n\tif (port->_dmaInterruptCH0) {\n\t\tport->cpu_addr[0] = dma_alloc_coherent(&port->dev->pci_dev->dev,\n\t\t\t\t\t\t       SMI_TS_DMA_BUF_SIZE,\n\t\t\t\t\t\t       &port->dma_addr[0],\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!port->cpu_addr[0]) {\n\t\t\tdev_err(&port->dev->pci_dev->dev,\n\t\t\t\t\"Port[%d] DMA CH0 memory allocation failed!\\n\",\n\t\t\t\tport->idx);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (port->_dmaInterruptCH1) {\n\t\tport->cpu_addr[1] = dma_alloc_coherent(&port->dev->pci_dev->dev,\n\t\t\t\t\t\t       SMI_TS_DMA_BUF_SIZE,\n\t\t\t\t\t\t       &port->dma_addr[1],\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!port->cpu_addr[1]) {\n\t\t\tdev_err(&port->dev->pci_dev->dev,\n\t\t\t\t\"Port[%d] DMA CH1 memory allocation failed!\\n\",\n\t\t\t\tport->idx);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tsmi_port_disableInterrupt(port);\n\ttasklet_setup(&port->tasklet, smi_dma_xfer);\n\ttasklet_disable(&port->tasklet);\n\tport->enable = 1;\n\treturn 0;\nerr:\n\tsmi_port_dma_free(port);\n\treturn -ENOMEM;\n}\n\nstatic void smi_port_exit(struct smi_port *port)\n{\n\tsmi_port_disableInterrupt(port);\n\ttasklet_kill(&port->tasklet);\n\tsmi_port_dma_free(port);\n\tport->enable = 0;\n}\n\nstatic int smi_port_irq(struct smi_port *port, u32 int_status)\n{\n\tu32 port_req_irq = port->_dmaInterruptCH0 | port->_dmaInterruptCH1;\n\tint handled = 0;\n\n\tif (int_status & port_req_irq) {\n\t\tsmi_port_disableInterrupt(port);\n\t\tport->_int_status = int_status;\n\t\tsmi_port_clearInterrupt(port);\n\t\ttasklet_schedule(&port->tasklet);\n\t\thandled = 1;\n\t}\n\treturn handled;\n}\n\nstatic irqreturn_t smi_irq_handler(int irq, void *dev_id)\n{\n\tstruct smi_dev *dev = dev_id;\n\tstruct smi_port *port0 = &dev->ts_port[0];\n\tstruct smi_port *port1 = &dev->ts_port[1];\n\tstruct smi_rc *ir = &dev->ir;\n\tint handled = 0;\n\n\tu32 intr_status = smi_read(MSI_INT_STATUS);\n\n\t \n\tif (dev->info->ts_0)\n\t\thandled += smi_port_irq(port0, intr_status);\n\n\t \n\tif (dev->info->ts_1)\n\t\thandled += smi_port_irq(port1, intr_status);\n\n\t \n\thandled += smi_ir_irq(ir, intr_status);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic struct i2c_client *smi_add_i2c_client(struct i2c_adapter *adapter,\n\t\t\tstruct i2c_board_info *info)\n{\n\tstruct i2c_client *client;\n\n\trequest_module(info->type);\n\tclient = i2c_new_client_device(adapter, info);\n\tif (!i2c_client_has_driver(client))\n\t\tgoto err_add_i2c_client;\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tgoto err_add_i2c_client;\n\t}\n\treturn client;\n\nerr_add_i2c_client:\n\tclient = NULL;\n\treturn client;\n}\n\nstatic void smi_del_i2c_client(struct i2c_client *client)\n{\n\tmodule_put(client->dev.driver->owner);\n\ti2c_unregister_device(client);\n}\n\nstatic const struct m88ds3103_config smi_dvbsky_m88ds3103_cfg = {\n\t.i2c_addr = 0x68,\n\t.clock = 27000000,\n\t.i2c_wr_max = 33,\n\t.clock_out = 0,\n\t.ts_mode = M88DS3103_TS_PARALLEL,\n\t.ts_clk = 16000,\n\t.ts_clk_pol = 1,\n\t.agc = 0x99,\n\t.lnb_hv_pol = 0,\n\t.lnb_en_pol = 1,\n};\n\nstatic int smi_dvbsky_m88ds3103_fe_attach(struct smi_port *port)\n{\n\tint ret = 0;\n\tstruct smi_dev *dev = port->dev;\n\tstruct i2c_adapter *i2c;\n\t \n\tstruct i2c_adapter *tuner_i2c_adapter;\n\tstruct i2c_client *tuner_client;\n\tstruct i2c_board_info tuner_info;\n\tstruct ts2020_config ts2020_config = {};\n\tmemset(&tuner_info, 0, sizeof(struct i2c_board_info));\n\ti2c = (port->idx == 0) ? &dev->i2c_bus[0] : &dev->i2c_bus[1];\n\n\t \n\tport->fe = dvb_attach(m88ds3103_attach,\n\t\t\t&smi_dvbsky_m88ds3103_cfg, i2c, &tuner_i2c_adapter);\n\tif (!port->fe) {\n\t\tret = -ENODEV;\n\t\treturn ret;\n\t}\n\t \n\tts2020_config.fe = port->fe;\n\tstrscpy(tuner_info.type, \"ts2020\", I2C_NAME_SIZE);\n\ttuner_info.addr = 0x60;\n\ttuner_info.platform_data = &ts2020_config;\n\ttuner_client = smi_add_i2c_client(tuner_i2c_adapter, &tuner_info);\n\tif (!tuner_client) {\n\t\tret = -ENODEV;\n\t\tgoto err_tuner_i2c_device;\n\t}\n\n\t \n\tport->fe->ops.read_signal_strength =\n\t\t\tport->fe->ops.tuner_ops.get_rf_strength;\n\n\tport->i2c_client_tuner = tuner_client;\n\treturn ret;\n\nerr_tuner_i2c_device:\n\tdvb_frontend_detach(port->fe);\n\treturn ret;\n}\n\nstatic const struct m88ds3103_config smi_dvbsky_m88rs6000_cfg = {\n\t.i2c_addr = 0x69,\n\t.clock = 27000000,\n\t.i2c_wr_max = 33,\n\t.ts_mode = M88DS3103_TS_PARALLEL,\n\t.ts_clk = 16000,\n\t.ts_clk_pol = 1,\n\t.agc = 0x99,\n\t.lnb_hv_pol = 0,\n\t.lnb_en_pol = 1,\n};\n\nstatic int smi_dvbsky_m88rs6000_fe_attach(struct smi_port *port)\n{\n\tint ret = 0;\n\tstruct smi_dev *dev = port->dev;\n\tstruct i2c_adapter *i2c;\n\t \n\tstruct i2c_adapter *tuner_i2c_adapter;\n\tstruct i2c_client *tuner_client;\n\tstruct i2c_board_info tuner_info;\n\tstruct m88rs6000t_config m88rs6000t_config;\n\n\tmemset(&tuner_info, 0, sizeof(struct i2c_board_info));\n\ti2c = (port->idx == 0) ? &dev->i2c_bus[0] : &dev->i2c_bus[1];\n\n\t \n\tport->fe = dvb_attach(m88ds3103_attach,\n\t\t\t&smi_dvbsky_m88rs6000_cfg, i2c, &tuner_i2c_adapter);\n\tif (!port->fe) {\n\t\tret = -ENODEV;\n\t\treturn ret;\n\t}\n\t \n\tm88rs6000t_config.fe = port->fe;\n\tstrscpy(tuner_info.type, \"m88rs6000t\", I2C_NAME_SIZE);\n\ttuner_info.addr = 0x21;\n\ttuner_info.platform_data = &m88rs6000t_config;\n\ttuner_client = smi_add_i2c_client(tuner_i2c_adapter, &tuner_info);\n\tif (!tuner_client) {\n\t\tret = -ENODEV;\n\t\tgoto err_tuner_i2c_device;\n\t}\n\n\t \n\tport->fe->ops.read_signal_strength =\n\t\t\tport->fe->ops.tuner_ops.get_rf_strength;\n\n\tport->i2c_client_tuner = tuner_client;\n\treturn ret;\n\nerr_tuner_i2c_device:\n\tdvb_frontend_detach(port->fe);\n\treturn ret;\n}\n\nstatic int smi_dvbsky_sit2_fe_attach(struct smi_port *port)\n{\n\tint ret = 0;\n\tstruct smi_dev *dev = port->dev;\n\tstruct i2c_adapter *i2c;\n\tstruct i2c_adapter *tuner_i2c_adapter;\n\tstruct i2c_client *client_tuner, *client_demod;\n\tstruct i2c_board_info client_info;\n\tstruct si2168_config si2168_config;\n\tstruct si2157_config si2157_config;\n\n\t \n\ti2c = (port->idx == 0) ? &dev->i2c_bus[0] : &dev->i2c_bus[1];\n\n\t \n\tmemset(&si2168_config, 0, sizeof(si2168_config));\n\tsi2168_config.i2c_adapter = &tuner_i2c_adapter;\n\tsi2168_config.fe = &port->fe;\n\tsi2168_config.ts_mode = SI2168_TS_PARALLEL;\n\n\tmemset(&client_info, 0, sizeof(struct i2c_board_info));\n\tstrscpy(client_info.type, \"si2168\", I2C_NAME_SIZE);\n\tclient_info.addr = 0x64;\n\tclient_info.platform_data = &si2168_config;\n\n\tclient_demod = smi_add_i2c_client(i2c, &client_info);\n\tif (!client_demod) {\n\t\tret = -ENODEV;\n\t\treturn ret;\n\t}\n\tport->i2c_client_demod = client_demod;\n\n\t \n\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\tsi2157_config.fe = port->fe;\n\tsi2157_config.if_port = 1;\n\n\tmemset(&client_info, 0, sizeof(struct i2c_board_info));\n\tstrscpy(client_info.type, \"si2157\", I2C_NAME_SIZE);\n\tclient_info.addr = 0x60;\n\tclient_info.platform_data = &si2157_config;\n\n\tclient_tuner = smi_add_i2c_client(tuner_i2c_adapter, &client_info);\n\tif (!client_tuner) {\n\t\tsmi_del_i2c_client(port->i2c_client_demod);\n\t\tport->i2c_client_demod = NULL;\n\t\tret = -ENODEV;\n\t\treturn ret;\n\t}\n\tport->i2c_client_tuner = client_tuner;\n\treturn ret;\n}\n\nstatic int smi_fe_init(struct smi_port *port)\n{\n\tint ret = 0;\n\tstruct smi_dev *dev = port->dev;\n\tstruct dvb_adapter *adap = &port->dvb_adapter;\n\tu8 mac_ee[16];\n\n\tdev_dbg(&port->dev->pci_dev->dev,\n\t\t\"%s: port %d, fe_type = %d\\n\",\n\t\t__func__, port->idx, port->fe_type);\n\tswitch (port->fe_type) {\n\tcase DVBSKY_FE_M88DS3103:\n\t\tret = smi_dvbsky_m88ds3103_fe_attach(port);\n\t\tbreak;\n\tcase DVBSKY_FE_M88RS6000:\n\t\tret = smi_dvbsky_m88rs6000_fe_attach(port);\n\t\tbreak;\n\tcase DVBSKY_FE_SIT2:\n\t\tret = smi_dvbsky_sit2_fe_attach(port);\n\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = dvb_register_frontend(adap, port->fe);\n\tif (ret < 0) {\n\t\tif (port->i2c_client_tuner)\n\t\t\tsmi_del_i2c_client(port->i2c_client_tuner);\n\t\tif (port->i2c_client_demod)\n\t\t\tsmi_del_i2c_client(port->i2c_client_demod);\n\t\tdvb_frontend_detach(port->fe);\n\t\treturn ret;\n\t}\n\t \n\tret = smi_read_eeprom(&dev->i2c_bus[0], 0xc0, mac_ee, 16);\n\tdev_info(&port->dev->pci_dev->dev,\n\t\t\"%s port %d MAC: %pM\\n\", dev->info->name,\n\t\tport->idx, mac_ee + (port->idx)*8);\n\tmemcpy(adap->proposed_mac, mac_ee + (port->idx)*8, 6);\n\treturn ret;\n}\n\nstatic void smi_fe_exit(struct smi_port *port)\n{\n\tdvb_unregister_frontend(port->fe);\n\t \n\tif (port->i2c_client_tuner)\n\t\tsmi_del_i2c_client(port->i2c_client_tuner);\n\tif (port->i2c_client_demod)\n\t\tsmi_del_i2c_client(port->i2c_client_demod);\n\tdvb_frontend_detach(port->fe);\n}\n\nstatic int my_dvb_dmx_ts_card_init(struct dvb_demux *dvbdemux, char *id,\n\t\t\t    int (*start_feed)(struct dvb_demux_feed *),\n\t\t\t    int (*stop_feed)(struct dvb_demux_feed *),\n\t\t\t    void *priv)\n{\n\tdvbdemux->priv = priv;\n\n\tdvbdemux->filternum = 256;\n\tdvbdemux->feednum = 256;\n\tdvbdemux->start_feed = start_feed;\n\tdvbdemux->stop_feed = stop_feed;\n\tdvbdemux->write_to_decoder = NULL;\n\tdvbdemux->dmx.capabilities = (DMX_TS_FILTERING |\n\t\t\t\t      DMX_SECTION_FILTERING |\n\t\t\t\t      DMX_MEMORY_BASED_FILTERING);\n\treturn dvb_dmx_init(dvbdemux);\n}\n\nstatic int my_dvb_dmxdev_ts_card_init(struct dmxdev *dmxdev,\n\t\t\t       struct dvb_demux *dvbdemux,\n\t\t\t       struct dmx_frontend *hw_frontend,\n\t\t\t       struct dmx_frontend *mem_frontend,\n\t\t\t       struct dvb_adapter *dvb_adapter)\n{\n\tint ret;\n\n\tdmxdev->filternum = 256;\n\tdmxdev->demux = &dvbdemux->dmx;\n\tdmxdev->capabilities = 0;\n\tret = dvb_dmxdev_init(dmxdev, dvb_adapter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thw_frontend->source = DMX_FRONTEND_0;\n\tdvbdemux->dmx.add_frontend(&dvbdemux->dmx, hw_frontend);\n\tmem_frontend->source = DMX_MEMORY_FE;\n\tdvbdemux->dmx.add_frontend(&dvbdemux->dmx, mem_frontend);\n\treturn dvbdemux->dmx.connect_frontend(&dvbdemux->dmx, hw_frontend);\n}\n\nstatic u32 smi_config_DMA(struct smi_port *port)\n{\n\tstruct smi_dev *dev = port->dev;\n\tu32 totalLength = 0, dmaMemPtrLow, dmaMemPtrHi, dmaCtlReg;\n\tu8 chanLatencyTimer = 0, dmaChanEnable = 1, dmaTransStart = 1;\n\tu32 dmaManagement = 0, tlpTransUnit = DMA_TRANS_UNIT_188;\n\tu8 tlpTc = 0, tlpTd = 1, tlpEp = 0, tlpAttr = 0;\n\tu64 mem;\n\n\tdmaManagement = smi_read(port->DMA_MANAGEMENT);\n\t \n\tif (port->_dmaInterruptCH0) {\n\t\ttotalLength = SMI_TS_DMA_BUF_SIZE;\n\t\tmem = port->dma_addr[0];\n\t\tdmaMemPtrLow = mem & 0xffffffff;\n\t\tdmaMemPtrHi = mem >> 32;\n\t\tdmaCtlReg = (totalLength) | (tlpTransUnit << 22) | (tlpTc << 25)\n\t\t\t| (tlpTd << 28) | (tlpEp << 29) | (tlpAttr << 30);\n\t\tdmaManagement |= dmaChanEnable | (dmaTransStart << 1)\n\t\t\t| (chanLatencyTimer << 8);\n\t\t \n\t\tsmi_write(port->DMA_CHAN0_ADDR_LOW, dmaMemPtrLow);\n\t\tsmi_write(port->DMA_CHAN0_ADDR_HI, dmaMemPtrHi);\n\t\tsmi_write(port->DMA_CHAN0_CONTROL, dmaCtlReg);\n\t}\n\t \n\tif (port->_dmaInterruptCH1) {\n\t\ttotalLength = SMI_TS_DMA_BUF_SIZE;\n\t\tmem = port->dma_addr[1];\n\t\tdmaMemPtrLow = mem & 0xffffffff;\n\t\tdmaMemPtrHi = mem >> 32;\n\t\tdmaCtlReg = (totalLength) | (tlpTransUnit << 22) | (tlpTc << 25)\n\t\t\t| (tlpTd << 28) | (tlpEp << 29) | (tlpAttr << 30);\n\t\tdmaManagement |= (dmaChanEnable << 16) | (dmaTransStart << 17)\n\t\t\t| (chanLatencyTimer << 24);\n\t\t \n\t\tsmi_write(port->DMA_CHAN1_ADDR_LOW, dmaMemPtrLow);\n\t\tsmi_write(port->DMA_CHAN1_ADDR_HI, dmaMemPtrHi);\n\t\tsmi_write(port->DMA_CHAN1_CONTROL, dmaCtlReg);\n\t}\n\treturn dmaManagement;\n}\n\nstatic int smi_start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tstruct smi_port *port = dvbdmx->priv;\n\tstruct smi_dev *dev = port->dev;\n\tu32 dmaManagement;\n\n\tif (port->users++ == 0) {\n\t\tdmaManagement = smi_config_DMA(port);\n\t\tsmi_port_clearInterrupt(port);\n\t\tsmi_port_enableInterrupt(port);\n\t\tsmi_write(port->DMA_MANAGEMENT, dmaManagement);\n\t\ttasklet_enable(&port->tasklet);\n\t}\n\treturn port->users;\n}\n\nstatic int smi_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tstruct smi_port *port = dvbdmx->priv;\n\tstruct smi_dev *dev = port->dev;\n\n\tif (--port->users)\n\t\treturn port->users;\n\n\ttasklet_disable(&port->tasklet);\n\tsmi_port_disableInterrupt(port);\n\tsmi_clear(port->DMA_MANAGEMENT, 0x30003);\n\treturn 0;\n}\n\nstatic int smi_dvb_init(struct smi_port *port)\n{\n\tint ret;\n\tstruct dvb_adapter *adap = &port->dvb_adapter;\n\tstruct dvb_demux *dvbdemux = &port->demux;\n\n\tdev_dbg(&port->dev->pci_dev->dev,\n\t\t\"%s, port %d\\n\", __func__, port->idx);\n\n\tret = dvb_register_adapter(adap, \"SMI_DVB\", THIS_MODULE,\n\t\t\t\t   &port->dev->pci_dev->dev,\n\t\t\t\t   adapter_nr);\n\tif (ret < 0) {\n\t\tdev_err(&port->dev->pci_dev->dev, \"Fail to register DVB adapter.\\n\");\n\t\treturn ret;\n\t}\n\tret = my_dvb_dmx_ts_card_init(dvbdemux, \"SW demux\",\n\t\t\t\t      smi_start_feed,\n\t\t\t\t      smi_stop_feed, port);\n\tif (ret < 0)\n\t\tgoto err_del_dvb_register_adapter;\n\n\tret = my_dvb_dmxdev_ts_card_init(&port->dmxdev, &port->demux,\n\t\t\t\t\t &port->hw_frontend,\n\t\t\t\t\t &port->mem_frontend, adap);\n\tif (ret < 0)\n\t\tgoto err_del_dvb_dmx;\n\n\tret = dvb_net_init(adap, &port->dvbnet, port->dmxdev.demux);\n\tif (ret < 0)\n\t\tgoto err_del_dvb_dmxdev;\n\treturn 0;\nerr_del_dvb_dmxdev:\n\tdvbdemux->dmx.close(&dvbdemux->dmx);\n\tdvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &port->hw_frontend);\n\tdvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &port->mem_frontend);\n\tdvb_dmxdev_release(&port->dmxdev);\nerr_del_dvb_dmx:\n\tdvb_dmx_release(&port->demux);\nerr_del_dvb_register_adapter:\n\tdvb_unregister_adapter(&port->dvb_adapter);\n\treturn ret;\n}\n\nstatic void smi_dvb_exit(struct smi_port *port)\n{\n\tstruct dvb_demux *dvbdemux = &port->demux;\n\n\tdvb_net_release(&port->dvbnet);\n\n\tdvbdemux->dmx.close(&dvbdemux->dmx);\n\tdvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &port->hw_frontend);\n\tdvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &port->mem_frontend);\n\tdvb_dmxdev_release(&port->dmxdev);\n\tdvb_dmx_release(&port->demux);\n\n\tdvb_unregister_adapter(&port->dvb_adapter);\n}\n\nstatic int smi_port_attach(struct smi_dev *dev,\n\t\tstruct smi_port *port, int index)\n{\n\tint ret, dmachs;\n\n\tport->dev = dev;\n\tport->idx = index;\n\tport->fe_type = (index == 0) ? dev->info->fe_0 : dev->info->fe_1;\n\tdmachs = (index == 0) ? dev->info->ts_0 : dev->info->ts_1;\n\t \n\tret = smi_port_init(port, dmachs);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tret = smi_dvb_init(port);\n\tif (ret < 0)\n\t\tgoto err_del_port_init;\n\t \n\tret = smi_fe_init(port);\n\tif (ret < 0)\n\t\tgoto err_del_dvb_init;\n\treturn 0;\nerr_del_dvb_init:\n\tsmi_dvb_exit(port);\nerr_del_port_init:\n\tsmi_port_exit(port);\n\treturn ret;\n}\n\nstatic void smi_port_detach(struct smi_port *port)\n{\n\tsmi_fe_exit(port);\n\tsmi_dvb_exit(port);\n\tsmi_port_exit(port);\n}\n\nstatic int smi_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct smi_dev *dev;\n\tint ret = -ENOMEM;\n\n\tif (pci_enable_device(pdev) < 0)\n\t\treturn -ENODEV;\n\n\tdev = kzalloc(sizeof(struct smi_dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pci_disable_device;\n\t}\n\n\tdev->pci_dev = pdev;\n\tpci_set_drvdata(pdev, dev);\n\tdev->info = (struct smi_cfg_info *) id->driver_data;\n\tdev_info(&dev->pci_dev->dev,\n\t\t\"card detected: %s\\n\", dev->info->name);\n\n\tdev->nr = dev->info->type;\n\tdev->lmmio = ioremap(pci_resource_start(dev->pci_dev, 0),\n\t\t\t    pci_resource_len(dev->pci_dev, 0));\n\tif (!dev->lmmio) {\n\t\tret = -ENOMEM;\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret < 0)\n\t\tgoto err_pci_iounmap;\n\n\tpci_set_master(pdev);\n\n\tret = smi_hw_init(dev);\n\tif (ret < 0)\n\t\tgoto err_pci_iounmap;\n\n\tret = smi_i2c_init(dev);\n\tif (ret < 0)\n\t\tgoto err_pci_iounmap;\n\n\tif (dev->info->ts_0) {\n\t\tret = smi_port_attach(dev, &dev->ts_port[0], 0);\n\t\tif (ret < 0)\n\t\t\tgoto err_del_i2c_adaptor;\n\t}\n\n\tif (dev->info->ts_1) {\n\t\tret = smi_port_attach(dev, &dev->ts_port[1], 1);\n\t\tif (ret < 0)\n\t\t\tgoto err_del_port0_attach;\n\t}\n\n\tret = smi_ir_init(dev);\n\tif (ret < 0)\n\t\tgoto err_del_port1_attach;\n\n#ifdef CONFIG_PCI_MSI  \n\tif (pci_msi_enabled())\n\t\tret = pci_enable_msi(dev->pci_dev);\n\tif (ret)\n\t\tdev_info(&dev->pci_dev->dev, \"MSI not available.\\n\");\n#endif\n\n\tret = request_irq(dev->pci_dev->irq, smi_irq_handler,\n\t\t\t   IRQF_SHARED, \"SMI_PCIE\", dev);\n\tif (ret < 0)\n\t\tgoto err_del_ir;\n\n\tsmi_ir_start(&dev->ir);\n\treturn 0;\n\nerr_del_ir:\n\tsmi_ir_exit(dev);\nerr_del_port1_attach:\n\tif (dev->info->ts_1)\n\t\tsmi_port_detach(&dev->ts_port[1]);\nerr_del_port0_attach:\n\tif (dev->info->ts_0)\n\t\tsmi_port_detach(&dev->ts_port[0]);\nerr_del_i2c_adaptor:\n\tsmi_i2c_exit(dev);\nerr_pci_iounmap:\n\tiounmap(dev->lmmio);\nerr_kfree:\n\tpci_set_drvdata(pdev, NULL);\n\tkfree(dev);\nerr_pci_disable_device:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic void smi_remove(struct pci_dev *pdev)\n{\n\tstruct smi_dev *dev = pci_get_drvdata(pdev);\n\n\tsmi_write(MSI_INT_ENA_CLR, ALL_INT);\n\tfree_irq(dev->pci_dev->irq, dev);\n#ifdef CONFIG_PCI_MSI\n\tpci_disable_msi(dev->pci_dev);\n#endif\n\tif (dev->info->ts_1)\n\t\tsmi_port_detach(&dev->ts_port[1]);\n\tif (dev->info->ts_0)\n\t\tsmi_port_detach(&dev->ts_port[0]);\n\n\tsmi_ir_exit(dev);\n\tsmi_i2c_exit(dev);\n\tiounmap(dev->lmmio);\n\tpci_set_drvdata(pdev, NULL);\n\tpci_disable_device(pdev);\n\tkfree(dev);\n}\n\n \nstatic const struct smi_cfg_info dvbsky_s950_cfg = {\n\t.type = SMI_DVBSKY_S950,\n\t.name = \"DVBSky S950 V3\",\n\t.ts_0 = SMI_TS_NULL,\n\t.ts_1 = SMI_TS_DMA_BOTH,\n\t.fe_0 = DVBSKY_FE_NULL,\n\t.fe_1 = DVBSKY_FE_M88DS3103,\n\t.rc_map = RC_MAP_DVBSKY,\n};\n\nstatic const struct smi_cfg_info dvbsky_s952_cfg = {\n\t.type = SMI_DVBSKY_S952,\n\t.name = \"DVBSky S952 V3\",\n\t.ts_0 = SMI_TS_DMA_BOTH,\n\t.ts_1 = SMI_TS_DMA_BOTH,\n\t.fe_0 = DVBSKY_FE_M88RS6000,\n\t.fe_1 = DVBSKY_FE_M88RS6000,\n\t.rc_map = RC_MAP_DVBSKY,\n};\n\nstatic const struct smi_cfg_info dvbsky_t9580_cfg = {\n\t.type = SMI_DVBSKY_T9580,\n\t.name = \"DVBSky T9580 V3\",\n\t.ts_0 = SMI_TS_DMA_BOTH,\n\t.ts_1 = SMI_TS_DMA_BOTH,\n\t.fe_0 = DVBSKY_FE_SIT2,\n\t.fe_1 = DVBSKY_FE_M88DS3103,\n\t.rc_map = RC_MAP_DVBSKY,\n};\n\nstatic const struct smi_cfg_info technotrend_s2_4200_cfg = {\n\t.type = SMI_TECHNOTREND_S2_4200,\n\t.name = \"TechnoTrend TT-budget S2-4200 Twin\",\n\t.ts_0 = SMI_TS_DMA_BOTH,\n\t.ts_1 = SMI_TS_DMA_BOTH,\n\t.fe_0 = DVBSKY_FE_M88RS6000,\n\t.fe_1 = DVBSKY_FE_M88RS6000,\n\t.rc_map = RC_MAP_TT_1500,\n};\n\n \n#define SMI_ID(_subvend, _subdev, _driverdata) {\t\\\n\t.vendor      = SMI_VID,    .device    = SMI_PID, \\\n\t.subvendor   = _subvend, .subdevice = _subdev, \\\n\t.driver_data = (unsigned long)&_driverdata }\n\nstatic const struct pci_device_id smi_id_table[] = {\n\tSMI_ID(0x4254, 0x0550, dvbsky_s950_cfg),\n\tSMI_ID(0x4254, 0x0552, dvbsky_s952_cfg),\n\tSMI_ID(0x4254, 0x5580, dvbsky_t9580_cfg),\n\tSMI_ID(0x13c2, 0x3016, technotrend_s2_4200_cfg),\n\t{0}\n};\nMODULE_DEVICE_TABLE(pci, smi_id_table);\n\nstatic struct pci_driver smipcie_driver = {\n\t.name = \"SMI PCIe driver\",\n\t.id_table = smi_id_table,\n\t.probe = smi_probe,\n\t.remove = smi_remove,\n};\n\nmodule_pci_driver(smipcie_driver);\n\nMODULE_AUTHOR(\"Max nibble <nibble.max@gmail.com>\");\nMODULE_DESCRIPTION(\"SMI PCIe driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}