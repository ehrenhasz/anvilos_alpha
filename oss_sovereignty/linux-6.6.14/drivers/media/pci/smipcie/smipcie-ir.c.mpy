{
  "module_name": "smipcie-ir.c",
  "hash_id": "ab3d83a53116a6b6135217f7d6ea48cf0d56a22b4307dee1681745595f680720",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/smipcie/smipcie-ir.c",
  "human_readable_source": "\n \n\n#include \"smipcie.h\"\n\n#define SMI_SAMPLE_PERIOD 83\n#define SMI_SAMPLE_IDLEMIN (10000 / SMI_SAMPLE_PERIOD)\n\nstatic void smi_ir_enableInterrupt(struct smi_rc *ir)\n{\n\tstruct smi_dev *dev = ir->dev;\n\n\tsmi_write(MSI_INT_ENA_SET, IR_X_INT);\n}\n\nstatic void smi_ir_disableInterrupt(struct smi_rc *ir)\n{\n\tstruct smi_dev *dev = ir->dev;\n\n\tsmi_write(MSI_INT_ENA_CLR, IR_X_INT);\n}\n\nstatic void smi_ir_clearInterrupt(struct smi_rc *ir)\n{\n\tstruct smi_dev *dev = ir->dev;\n\n\tsmi_write(MSI_INT_STATUS_CLR, IR_X_INT);\n}\n\nstatic void smi_ir_stop(struct smi_rc *ir)\n{\n\tstruct smi_dev *dev = ir->dev;\n\n\tsmi_ir_disableInterrupt(ir);\n\tsmi_clear(IR_Init_Reg, rbIRen);\n}\n\nstatic void smi_raw_process(struct rc_dev *rc_dev, const u8 *buffer,\n\t\t\t    const u8 length)\n{\n\tstruct ir_raw_event rawir = {};\n\tint cnt;\n\n\tfor (cnt = 0; cnt < length; cnt++) {\n\t\tif (buffer[cnt] & 0x7f) {\n\t\t\trawir.pulse = (buffer[cnt] & 0x80) == 0;\n\t\t\trawir.duration = ((buffer[cnt] & 0x7f) +\n\t\t\t\t\t (rawir.pulse ? 0 : -1)) *\n\t\t\t\t\t rc_dev->rx_resolution;\n\t\t\tir_raw_event_store_with_filter(rc_dev, &rawir);\n\t\t}\n\t}\n}\n\nstatic void smi_ir_decode(struct smi_rc *ir)\n{\n\tstruct smi_dev *dev = ir->dev;\n\tstruct rc_dev *rc_dev = ir->rc_dev;\n\tu32 control, data;\n\tu8 index, ir_count, read_loop;\n\n\tcontrol = smi_read(IR_Init_Reg);\n\n\tdev_dbg(&rc_dev->dev, \"ircontrol: 0x%08x\\n\", control);\n\n\tif (control & rbIRVld) {\n\t\tir_count = (u8)smi_read(IR_Data_Cnt);\n\n\t\tdev_dbg(&rc_dev->dev, \"ircount %d\\n\", ir_count);\n\n\t\tread_loop = ir_count / 4;\n\t\tif (ir_count % 4)\n\t\t\tread_loop += 1;\n\t\tfor (index = 0; index < read_loop; index++) {\n\t\t\tdata = smi_read(IR_DATA_BUFFER_BASE + (index * 4));\n\t\t\tdev_dbg(&rc_dev->dev, \"IRData 0x%08x\\n\", data);\n\n\t\t\tir->irData[index * 4 + 0] = (u8)(data);\n\t\t\tir->irData[index * 4 + 1] = (u8)(data >> 8);\n\t\t\tir->irData[index * 4 + 2] = (u8)(data >> 16);\n\t\t\tir->irData[index * 4 + 3] = (u8)(data >> 24);\n\t\t}\n\t\tsmi_raw_process(rc_dev, ir->irData, ir_count);\n\t}\n\n\tif (control & rbIRhighidle) {\n\t\tstruct ir_raw_event rawir = {};\n\n\t\tdev_dbg(&rc_dev->dev, \"high idle\\n\");\n\n\t\trawir.pulse = 0;\n\t\trawir.duration = SMI_SAMPLE_PERIOD * SMI_SAMPLE_IDLEMIN;\n\t\tir_raw_event_store_with_filter(rc_dev, &rawir);\n\t}\n\n\tsmi_set(IR_Init_Reg, rbIRVld);\n\tir_raw_event_handle(rc_dev);\n}\n\n \nint smi_ir_irq(struct smi_rc *ir, u32 int_status)\n{\n\tint handled = 0;\n\n\tif (int_status & IR_X_INT) {\n\t\tsmi_ir_disableInterrupt(ir);\n\t\tsmi_ir_clearInterrupt(ir);\n\t\tsmi_ir_decode(ir);\n\t\tsmi_ir_enableInterrupt(ir);\n\t\thandled = 1;\n\t}\n\treturn handled;\n}\n\nvoid smi_ir_start(struct smi_rc *ir)\n{\n\tstruct smi_dev *dev = ir->dev;\n\n\tsmi_write(IR_Idle_Cnt_Low,\n\t\t  (((SMI_SAMPLE_PERIOD - 1) & 0xFFFF) << 16) |\n\t\t  (SMI_SAMPLE_IDLEMIN & 0xFFFF));\n\tmsleep(20);\n\tsmi_set(IR_Init_Reg, rbIRen | rbIRhighidle);\n\n\tsmi_ir_enableInterrupt(ir);\n}\n\nint smi_ir_init(struct smi_dev *dev)\n{\n\tint ret;\n\tstruct rc_dev *rc_dev;\n\tstruct smi_rc *ir = &dev->ir;\n\n\trc_dev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!rc_dev)\n\t\treturn -ENOMEM;\n\n\t \n\tsnprintf(ir->device_name, sizeof(ir->device_name), \"IR (%s)\",\n\t\t dev->info->name);\n\tsnprintf(ir->input_phys, sizeof(ir->input_phys), \"pci-%s/ir0\",\n\t\t pci_name(dev->pci_dev));\n\n\trc_dev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trc_dev->driver_name = \"SMI_PCIe\";\n\trc_dev->input_phys = ir->input_phys;\n\trc_dev->device_name = ir->device_name;\n\trc_dev->input_id.bustype = BUS_PCI;\n\trc_dev->input_id.version = 1;\n\trc_dev->input_id.vendor = dev->pci_dev->subsystem_vendor;\n\trc_dev->input_id.product = dev->pci_dev->subsystem_device;\n\trc_dev->dev.parent = &dev->pci_dev->dev;\n\n\trc_dev->map_name = dev->info->rc_map;\n\trc_dev->timeout = SMI_SAMPLE_PERIOD * SMI_SAMPLE_IDLEMIN;\n\trc_dev->rx_resolution = SMI_SAMPLE_PERIOD;\n\n\tir->rc_dev = rc_dev;\n\tir->dev = dev;\n\n\tsmi_ir_disableInterrupt(ir);\n\n\tret = rc_register_device(rc_dev);\n\tif (ret)\n\t\tgoto ir_err;\n\n\treturn 0;\nir_err:\n\trc_free_device(rc_dev);\n\treturn ret;\n}\n\nvoid smi_ir_exit(struct smi_dev *dev)\n{\n\tstruct smi_rc *ir = &dev->ir;\n\tstruct rc_dev *rc_dev = ir->rc_dev;\n\n\trc_unregister_device(rc_dev);\n\tsmi_ir_stop(ir);\n\tir->rc_dev = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}