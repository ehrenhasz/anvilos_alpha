{
  "module_name": "solo6x10-core.c",
  "hash_id": "4cbc5928f280b8d36d1f740c08e5b0048a077ed9411672a158237e1409f28b18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/solo6x10/solo6x10-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/videodev2.h>\n#include <linux/delay.h>\n#include <linux/sysfs.h>\n#include <linux/ktime.h>\n#include <linux/slab.h>\n\n#include \"solo6x10.h\"\n#include \"solo6x10-tw28.h\"\n\nMODULE_DESCRIPTION(\"Softlogic 6x10 MPEG4/H.264/G.723 CODEC V4L2/ALSA Driver\");\nMODULE_AUTHOR(\"Bluecherry <maintainers@bluecherrydvr.com>\");\nMODULE_VERSION(SOLO6X10_VERSION);\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned video_nr = -1;\nmodule_param(video_nr, uint, 0644);\nMODULE_PARM_DESC(video_nr, \"videoX start number, -1 is autodetect (default)\");\n\nstatic int full_eeprom;  \nmodule_param(full_eeprom, uint, 0644);\nMODULE_PARM_DESC(full_eeprom, \"Allow access to full 128B EEPROM (dangerous)\");\n\n\nstatic void solo_set_time(struct solo_dev *solo_dev)\n{\n\tstruct timespec64 ts;\n\n\tktime_get_ts64(&ts);\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_TIMER_SEC, (u32)ts.tv_sec);\n\tsolo_reg_write(solo_dev, SOLO_TIMER_USEC, (u32)ts.tv_nsec / NSEC_PER_USEC);\n}\n\nstatic void solo_timer_sync(struct solo_dev *solo_dev)\n{\n\tu32 sec, usec;\n\tstruct timespec64 ts;\n\tlong diff;\n\n\tif (solo_dev->type != SOLO_DEV_6110)\n\t\treturn;\n\n\tif (++solo_dev->time_sync < 60)\n\t\treturn;\n\n\tsolo_dev->time_sync = 0;\n\n\tsec = solo_reg_read(solo_dev, SOLO_TIMER_SEC);\n\tusec = solo_reg_read(solo_dev, SOLO_TIMER_USEC);\n\n\tktime_get_ts64(&ts);\n\n\tdiff = (s32)ts.tv_sec - (s32)sec;\n\tdiff = (diff * 1000000)\n\t\t+ ((s32)(ts.tv_nsec / NSEC_PER_USEC) - (s32)usec);\n\n\tif (diff > 1000 || diff < -1000) {\n\t\tsolo_set_time(solo_dev);\n\t} else if (diff) {\n\t\tlong usec_lsb = solo_dev->usec_lsb;\n\n\t\tusec_lsb -= diff / 4;\n\t\tif (usec_lsb < 0)\n\t\t\tusec_lsb = 0;\n\t\telse if (usec_lsb > 255)\n\t\t\tusec_lsb = 255;\n\n\t\tsolo_dev->usec_lsb = usec_lsb;\n\t\tsolo_reg_write(solo_dev, SOLO_TIMER_USEC_LSB,\n\t\t\t       solo_dev->usec_lsb);\n\t}\n}\n\nstatic irqreturn_t solo_isr(int irq, void *data)\n{\n\tstruct solo_dev *solo_dev = data;\n\tu32 status;\n\tint i;\n\n\tstatus = solo_reg_read(solo_dev, SOLO_IRQ_STAT);\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_IRQ_STAT, status);\n\n\tif (status & SOLO_IRQ_PCI_ERR)\n\t\tsolo_p2m_error_isr(solo_dev);\n\n\tfor (i = 0; i < SOLO_NR_P2M; i++)\n\t\tif (status & SOLO_IRQ_P2M(i))\n\t\t\tsolo_p2m_isr(solo_dev, i);\n\n\tif (status & SOLO_IRQ_IIC)\n\t\tsolo_i2c_isr(solo_dev);\n\n\tif (status & SOLO_IRQ_VIDEO_IN) {\n\t\tsolo_video_in_isr(solo_dev);\n\t\tsolo_timer_sync(solo_dev);\n\t}\n\n\tif (status & SOLO_IRQ_ENCODER)\n\t\tsolo_enc_v4l2_isr(solo_dev);\n\n\tif (status & SOLO_IRQ_G723)\n\t\tsolo_g723_isr(solo_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void free_solo_dev(struct solo_dev *solo_dev)\n{\n\tstruct pci_dev *pdev = solo_dev->pdev;\n\n\tif (solo_dev->dev.parent)\n\t\tdevice_unregister(&solo_dev->dev);\n\n\tif (solo_dev->reg_base) {\n\t\t \n\t\tsolo_g723_exit(solo_dev);\n\t\tsolo_enc_v4l2_exit(solo_dev);\n\t\tsolo_enc_exit(solo_dev);\n\t\tsolo_v4l2_exit(solo_dev);\n\t\tsolo_disp_exit(solo_dev);\n\t\tsolo_gpio_exit(solo_dev);\n\t\tsolo_p2m_exit(solo_dev);\n\t\tsolo_i2c_exit(solo_dev);\n\n\t\t \n\t\tsolo_irq_off(solo_dev, ~0);\n\t\tfree_irq(pdev->irq, solo_dev);\n\t\tpci_iounmap(pdev, solo_dev->reg_base);\n\t}\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tv4l2_device_unregister(&solo_dev->v4l2_dev);\n\tpci_set_drvdata(pdev, NULL);\n\n\tkfree(solo_dev);\n}\n\nstatic ssize_t eeprom_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct solo_dev *solo_dev =\n\t\tcontainer_of(dev, struct solo_dev, dev);\n\tu16 *p = (u16 *)buf;\n\tint i;\n\n\tif (count & 0x1)\n\t\tdev_warn(dev, \"EEPROM Write not aligned (truncating)\\n\");\n\n\tif (!full_eeprom && count > 64) {\n\t\tdev_warn(dev, \"EEPROM Write truncated to 64 bytes\\n\");\n\t\tcount = 64;\n\t} else if (full_eeprom && count > 128) {\n\t\tdev_warn(dev, \"EEPROM Write truncated to 128 bytes\\n\");\n\t\tcount = 128;\n\t}\n\n\tsolo_eeprom_ewen(solo_dev, 1);\n\n\tfor (i = full_eeprom ? 0 : 32; i < min((int)(full_eeprom ? 64 : 32),\n\t\t\t\t\t       (int)(count / 2)); i++)\n\t\tsolo_eeprom_write(solo_dev, i, cpu_to_be16(p[i]));\n\n\tsolo_eeprom_ewen(solo_dev, 0);\n\n\treturn count;\n}\n\nstatic ssize_t eeprom_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct solo_dev *solo_dev =\n\t\tcontainer_of(dev, struct solo_dev, dev);\n\tu16 *p = (u16 *)buf;\n\tint count = (full_eeprom ? 128 : 64);\n\tint i;\n\n\tfor (i = (full_eeprom ? 0 : 32); i < (count / 2); i++)\n\t\tp[i] = be16_to_cpu(solo_eeprom_read(solo_dev, i));\n\n\treturn count;\n}\n\nstatic ssize_t p2m_timeouts_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct solo_dev *solo_dev =\n\t\tcontainer_of(dev, struct solo_dev, dev);\n\n\treturn sprintf(buf, \"%d\\n\", solo_dev->p2m_timeouts);\n}\n\nstatic ssize_t sdram_size_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct solo_dev *solo_dev =\n\t\tcontainer_of(dev, struct solo_dev, dev);\n\n\treturn sprintf(buf, \"%dMegs\\n\", solo_dev->sdram_size >> 20);\n}\n\nstatic ssize_t tw28xx_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct solo_dev *solo_dev =\n\t\tcontainer_of(dev, struct solo_dev, dev);\n\n\treturn sprintf(buf, \"tw2815[%d] tw2864[%d] tw2865[%d]\\n\",\n\t\t       hweight32(solo_dev->tw2815),\n\t\t       hweight32(solo_dev->tw2864),\n\t\t       hweight32(solo_dev->tw2865));\n}\n\nstatic ssize_t input_map_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct solo_dev *solo_dev =\n\t\tcontainer_of(dev, struct solo_dev, dev);\n\tunsigned int val;\n\tchar *out = buf;\n\n\tval = solo_reg_read(solo_dev, SOLO_VI_CH_SWITCH_0);\n\tout += sprintf(out, \"Channel 0   => Input %d\\n\", val & 0x1f);\n\tout += sprintf(out, \"Channel 1   => Input %d\\n\", (val >> 5) & 0x1f);\n\tout += sprintf(out, \"Channel 2   => Input %d\\n\", (val >> 10) & 0x1f);\n\tout += sprintf(out, \"Channel 3   => Input %d\\n\", (val >> 15) & 0x1f);\n\tout += sprintf(out, \"Channel 4   => Input %d\\n\", (val >> 20) & 0x1f);\n\tout += sprintf(out, \"Channel 5   => Input %d\\n\", (val >> 25) & 0x1f);\n\n\tval = solo_reg_read(solo_dev, SOLO_VI_CH_SWITCH_1);\n\tout += sprintf(out, \"Channel 6   => Input %d\\n\", val & 0x1f);\n\tout += sprintf(out, \"Channel 7   => Input %d\\n\", (val >> 5) & 0x1f);\n\tout += sprintf(out, \"Channel 8   => Input %d\\n\", (val >> 10) & 0x1f);\n\tout += sprintf(out, \"Channel 9   => Input %d\\n\", (val >> 15) & 0x1f);\n\tout += sprintf(out, \"Channel 10  => Input %d\\n\", (val >> 20) & 0x1f);\n\tout += sprintf(out, \"Channel 11  => Input %d\\n\", (val >> 25) & 0x1f);\n\n\tval = solo_reg_read(solo_dev, SOLO_VI_CH_SWITCH_2);\n\tout += sprintf(out, \"Channel 12  => Input %d\\n\", val & 0x1f);\n\tout += sprintf(out, \"Channel 13  => Input %d\\n\", (val >> 5) & 0x1f);\n\tout += sprintf(out, \"Channel 14  => Input %d\\n\", (val >> 10) & 0x1f);\n\tout += sprintf(out, \"Channel 15  => Input %d\\n\", (val >> 15) & 0x1f);\n\tout += sprintf(out, \"Spot Output => Input %d\\n\", (val >> 20) & 0x1f);\n\n\treturn out - buf;\n}\n\nstatic ssize_t p2m_timeout_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct solo_dev *solo_dev =\n\t\tcontainer_of(dev, struct solo_dev, dev);\n\tunsigned long ms;\n\tint ret = kstrtoul(buf, 10, &ms);\n\n\tif (ret < 0 || ms > 200)\n\t\treturn -EINVAL;\n\tsolo_dev->p2m_jiffies = msecs_to_jiffies(ms);\n\n\treturn count;\n}\n\nstatic ssize_t p2m_timeout_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct solo_dev *solo_dev =\n\t\tcontainer_of(dev, struct solo_dev, dev);\n\n\treturn sprintf(buf, \"%ums\\n\", jiffies_to_msecs(solo_dev->p2m_jiffies));\n}\n\nstatic ssize_t intervals_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct solo_dev *solo_dev =\n\t\tcontainer_of(dev, struct solo_dev, dev);\n\tchar *out = buf;\n\tint fps = solo_dev->fps;\n\tint i;\n\n\tfor (i = 0; i < solo_dev->nr_chans; i++) {\n\t\tout += sprintf(out, \"Channel %d: %d/%d (0x%08x)\\n\",\n\t\t\t       i, solo_dev->v4l2_enc[i]->interval, fps,\n\t\t\t       solo_reg_read(solo_dev, SOLO_CAP_CH_INTV(i)));\n\t}\n\n\treturn out - buf;\n}\n\nstatic ssize_t sdram_offsets_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct solo_dev *solo_dev =\n\t\tcontainer_of(dev, struct solo_dev, dev);\n\tchar *out = buf;\n\n\tout += sprintf(out, \"DISP: 0x%08x @ 0x%08x\\n\",\n\t\t       SOLO_DISP_EXT_ADDR,\n\t\t       SOLO_DISP_EXT_SIZE);\n\n\tout += sprintf(out, \"EOSD: 0x%08x @ 0x%08x (0x%08x * %d)\\n\",\n\t\t       SOLO_EOSD_EXT_ADDR,\n\t\t       SOLO_EOSD_EXT_AREA(solo_dev),\n\t\t       SOLO_EOSD_EXT_SIZE(solo_dev),\n\t\t       SOLO_EOSD_EXT_AREA(solo_dev) /\n\t\t       SOLO_EOSD_EXT_SIZE(solo_dev));\n\n\tout += sprintf(out, \"MOTI: 0x%08x @ 0x%08x\\n\",\n\t\t       SOLO_MOTION_EXT_ADDR(solo_dev),\n\t\t       SOLO_MOTION_EXT_SIZE);\n\n\tout += sprintf(out, \"G723: 0x%08x @ 0x%08x\\n\",\n\t\t       SOLO_G723_EXT_ADDR(solo_dev),\n\t\t       SOLO_G723_EXT_SIZE);\n\n\tout += sprintf(out, \"CAPT: 0x%08x @ 0x%08x (0x%08x * %d)\\n\",\n\t\t       SOLO_CAP_EXT_ADDR(solo_dev),\n\t\t       SOLO_CAP_EXT_SIZE(solo_dev),\n\t\t       SOLO_CAP_PAGE_SIZE,\n\t\t       SOLO_CAP_EXT_SIZE(solo_dev) / SOLO_CAP_PAGE_SIZE);\n\n\tout += sprintf(out, \"EREF: 0x%08x @ 0x%08x (0x%08x * %d)\\n\",\n\t\t       SOLO_EREF_EXT_ADDR(solo_dev),\n\t\t       SOLO_EREF_EXT_AREA(solo_dev),\n\t\t       SOLO_EREF_EXT_SIZE,\n\t\t       SOLO_EREF_EXT_AREA(solo_dev) / SOLO_EREF_EXT_SIZE);\n\n\tout += sprintf(out, \"MPEG: 0x%08x @ 0x%08x\\n\",\n\t\t       SOLO_MP4E_EXT_ADDR(solo_dev),\n\t\t       SOLO_MP4E_EXT_SIZE(solo_dev));\n\n\tout += sprintf(out, \"JPEG: 0x%08x @ 0x%08x\\n\",\n\t\t       SOLO_JPEG_EXT_ADDR(solo_dev),\n\t\t       SOLO_JPEG_EXT_SIZE(solo_dev));\n\n\treturn out - buf;\n}\n\nstatic ssize_t sdram_show(struct file *file, struct kobject *kobj,\n\t\t\t  struct bin_attribute *a, char *buf,\n\t\t\t  loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct solo_dev *solo_dev =\n\t\tcontainer_of(dev, struct solo_dev, dev);\n\tconst int size = solo_dev->sdram_size;\n\n\tif (off >= size)\n\t\treturn 0;\n\n\tif (off + count > size)\n\t\tcount = size - off;\n\n\tif (solo_p2m_dma(solo_dev, 0, buf, off, count, 0, 0))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic const struct device_attribute solo_dev_attrs[] = {\n\t__ATTR(eeprom, 0640, eeprom_show, eeprom_store),\n\t__ATTR(p2m_timeout, 0644, p2m_timeout_show, p2m_timeout_store),\n\t__ATTR_RO(p2m_timeouts),\n\t__ATTR_RO(sdram_size),\n\t__ATTR_RO(tw28xx),\n\t__ATTR_RO(input_map),\n\t__ATTR_RO(intervals),\n\t__ATTR_RO(sdram_offsets),\n};\n\nstatic void solo_device_release(struct device *dev)\n{\n\t \n}\n\nstatic int solo_sysfs_init(struct solo_dev *solo_dev)\n{\n\tstruct bin_attribute *sdram_attr = &solo_dev->sdram_attr;\n\tstruct device *dev = &solo_dev->dev;\n\tconst char *driver;\n\tint i;\n\n\tif (solo_dev->type == SOLO_DEV_6110)\n\t\tdriver = \"solo6110\";\n\telse\n\t\tdriver = \"solo6010\";\n\n\tdev->release = solo_device_release;\n\tdev->parent = &solo_dev->pdev->dev;\n\tset_dev_node(dev, dev_to_node(&solo_dev->pdev->dev));\n\tdev_set_name(dev, \"%s-%d-%d\", driver, solo_dev->vfd->num,\n\t\t     solo_dev->nr_chans);\n\n\tif (device_register(dev)) {\n\t\tput_device(dev);\n\t\tdev->parent = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(solo_dev_attrs); i++) {\n\t\tif (device_create_file(dev, &solo_dev_attrs[i])) {\n\t\t\tdevice_unregister(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tsysfs_attr_init(&sdram_attr->attr);\n\tsdram_attr->attr.name = \"sdram\";\n\tsdram_attr->attr.mode = 0440;\n\tsdram_attr->read = sdram_show;\n\tsdram_attr->size = solo_dev->sdram_size;\n\n\tif (device_create_bin_file(dev, sdram_attr)) {\n\t\tdevice_unregister(dev);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int solo_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct solo_dev *solo_dev;\n\tint ret;\n\tu8 chip_id;\n\n\tsolo_dev = kzalloc(sizeof(*solo_dev), GFP_KERNEL);\n\tif (solo_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tif (id->driver_data == SOLO_DEV_6010)\n\t\tdev_info(&pdev->dev, \"Probing Softlogic 6010\\n\");\n\telse\n\t\tdev_info(&pdev->dev, \"Probing Softlogic 6110\\n\");\n\n\tsolo_dev->type = id->driver_data;\n\tsolo_dev->pdev = pdev;\n\tret = v4l2_device_register(&pdev->dev, &solo_dev->v4l2_dev);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\t \n\tsolo_dev->p2m_jiffies = msecs_to_jiffies(100);\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\tpci_set_master(pdev);\n\n\t \n\tpci_write_config_byte(pdev, 0x40, 0x00);\n\tpci_write_config_byte(pdev, 0x41, 0x00);\n\n\tret = pci_request_regions(pdev, SOLO6X10_NAME);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\tsolo_dev->reg_base = pci_ioremap_bar(pdev, 0);\n\tif (solo_dev->reg_base == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_probe;\n\t}\n\n\tchip_id = solo_reg_read(solo_dev, SOLO_CHIP_OPTION) &\n\t\t\t\tSOLO_CHIP_ID_MASK;\n\tswitch (chip_id) {\n\tcase 7:\n\t\tsolo_dev->nr_chans = 16;\n\t\tsolo_dev->nr_ext = 5;\n\t\tbreak;\n\tcase 6:\n\t\tsolo_dev->nr_chans = 8;\n\t\tsolo_dev->nr_ext = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&pdev->dev, \"Invalid chip_id 0x%02x, assuming 4 ch\\n\",\n\t\t\t chip_id);\n\t\tfallthrough;\n\tcase 5:\n\t\tsolo_dev->nr_chans = 4;\n\t\tsolo_dev->nr_ext = 1;\n\t}\n\n\t \n\tsolo_irq_off(solo_dev, ~0);\n\n\t \n\tif (solo_dev->type == SOLO_DEV_6010) {\n\t\tsolo_dev->clock_mhz = 108;\n\t\tsolo_dev->sys_config = SOLO_SYS_CFG_SDRAM64BIT\n\t\t\t| SOLO_SYS_CFG_INPUTDIV(25)\n\t\t\t| SOLO_SYS_CFG_FEEDBACKDIV(solo_dev->clock_mhz * 2 - 2)\n\t\t\t| SOLO_SYS_CFG_OUTDIV(3);\n\t\tsolo_reg_write(solo_dev, SOLO_SYS_CFG, solo_dev->sys_config);\n\t} else {\n\t\tu32 divq, divf;\n\n\t\tsolo_dev->clock_mhz = 135;\n\n\t\tif (solo_dev->clock_mhz < 125) {\n\t\t\tdivq = 3;\n\t\t\tdivf = (solo_dev->clock_mhz * 4) / 3 - 1;\n\t\t} else {\n\t\t\tdivq = 2;\n\t\t\tdivf = (solo_dev->clock_mhz * 2) / 3 - 1;\n\t\t}\n\n\t\tsolo_reg_write(solo_dev, SOLO_PLL_CONFIG,\n\t\t\t       (1 << 20) |  \n\t\t\t       (8 << 15) |  \n\t\t\t       (divq << 12) |\n\t\t\t       (divf <<  4) |\n\t\t\t       (1 <<  1)    );\n\n\t\tsolo_dev->sys_config = SOLO_SYS_CFG_SDRAM64BIT;\n\t}\n\n\tsolo_reg_write(solo_dev, SOLO_SYS_CFG, solo_dev->sys_config);\n\tsolo_reg_write(solo_dev, SOLO_TIMER_CLOCK_NUM,\n\t\t       solo_dev->clock_mhz - 1);\n\n\t \n\tmdelay(1);\n\n\tret = request_irq(pdev->irq, solo_isr, IRQF_SHARED, SOLO6X10_NAME,\n\t\t\t  solo_dev);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\t \n\tsolo_irq_on(solo_dev, SOLO_IRQ_PCI_ERR);\n\n\tret = solo_i2c_init(solo_dev);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_DMA_CTRL,\n\t\t       SOLO_DMA_CTRL_REFRESH_CYCLE(1) |\n\t\t       SOLO_DMA_CTRL_SDRAM_SIZE(2) |\n\t\t       SOLO_DMA_CTRL_SDRAM_CLK_INVERT |\n\t\t       SOLO_DMA_CTRL_READ_CLK_SELECT |\n\t\t       SOLO_DMA_CTRL_LATENCY(1));\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_DMA_CTRL1,\n\t\t       solo_dev->type == SOLO_DEV_6010 ? 0x100 : 0x300);\n\n\tif (solo_dev->type != SOLO_DEV_6010) {\n\t\tsolo_dev->usec_lsb = 0x3f;\n\t\tsolo_set_time(solo_dev);\n\t}\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_WATCHDOG, 0);\n\n\t \n\n\tret = solo_p2m_init(solo_dev);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\tret = solo_disp_init(solo_dev);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\tret = solo_gpio_init(solo_dev);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\tret = solo_tw28_init(solo_dev);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\tret = solo_v4l2_init(solo_dev, video_nr);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\tret = solo_enc_init(solo_dev);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\tret = solo_enc_v4l2_init(solo_dev, video_nr);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\tret = solo_g723_init(solo_dev);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\tret = solo_sysfs_init(solo_dev);\n\tif (ret)\n\t\tgoto fail_probe;\n\n\t \n\tsolo_dev->p2m_jiffies = msecs_to_jiffies(20);\n\n\treturn 0;\n\nfail_probe:\n\tfree_solo_dev(solo_dev);\n\treturn ret;\n}\n\nstatic void solo_pci_remove(struct pci_dev *pdev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\n\tstruct solo_dev *solo_dev = container_of(v4l2_dev, struct solo_dev, v4l2_dev);\n\n\tfree_solo_dev(solo_dev);\n}\n\nstatic const struct pci_device_id solo_id_table[] = {\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_SOFTLOGIC, PCI_DEVICE_ID_SOLO6010),\n\t  .driver_data = SOLO_DEV_6010 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BLUECHERRY, PCI_DEVICE_ID_NEUSOLO_4),\n\t  .driver_data = SOLO_DEV_6010 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BLUECHERRY, PCI_DEVICE_ID_NEUSOLO_9),\n\t  .driver_data = SOLO_DEV_6010 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BLUECHERRY, PCI_DEVICE_ID_NEUSOLO_16),\n\t  .driver_data = SOLO_DEV_6010 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BLUECHERRY, PCI_DEVICE_ID_BC_SOLO_4),\n\t  .driver_data = SOLO_DEV_6010 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BLUECHERRY, PCI_DEVICE_ID_BC_SOLO_9),\n\t  .driver_data = SOLO_DEV_6010 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BLUECHERRY, PCI_DEVICE_ID_BC_SOLO_16),\n\t  .driver_data = SOLO_DEV_6010 },\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_SOFTLOGIC, PCI_DEVICE_ID_SOLO6110),\n\t  .driver_data = SOLO_DEV_6110 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BLUECHERRY, PCI_DEVICE_ID_BC_6110_4),\n\t  .driver_data = SOLO_DEV_6110 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BLUECHERRY, PCI_DEVICE_ID_BC_6110_8),\n\t  .driver_data = SOLO_DEV_6110 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BLUECHERRY, PCI_DEVICE_ID_BC_6110_16),\n\t  .driver_data = SOLO_DEV_6110 },\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, solo_id_table);\n\nstatic struct pci_driver solo_pci_driver = {\n\t.name = SOLO6X10_NAME,\n\t.id_table = solo_id_table,\n\t.probe = solo_pci_probe,\n\t.remove = solo_pci_remove,\n};\n\nmodule_pci_driver(solo_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}