{
  "module_name": "solo6x10-g723.c",
  "hash_id": "20a6c3c001cd480207ae3ab51fdfc2905e98b8b3a62eeb02ab7c2a90bd09b459",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/solo6x10/solo6x10-g723.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/mempool.h>\n#include <linux/poll.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/control.h>\n\n#include \"solo6x10.h\"\n#include \"solo6x10-tw28.h\"\n\n#define G723_FDMA_PAGES\t\t32\n#define G723_PERIOD_BYTES\t48\n#define G723_PERIOD_BLOCK\t1024\n#define G723_FRAMES_PER_PAGE\t48\n\n \n#define OUTMODE_MASK\t\t0x300\n\n#define SAMPLERATE\t\t8000\n#define BITRATE\t\t\t25\n\n \n#define PERIODS\t\t\tG723_FDMA_PAGES\n#define G723_INTR_ORDER\t\t4  \n\nstruct solo_snd_pcm {\n\tint\t\t\t\ton;\n\tspinlock_t\t\t\tlock;\n\tstruct solo_dev\t\t\t*solo_dev;\n\tu8\t\t\t\t*g723_buf;\n\tdma_addr_t\t\t\tg723_dma;\n};\n\nstatic void solo_g723_config(struct solo_dev *solo_dev)\n{\n\tint clk_div;\n\n\tclk_div = (solo_dev->clock_mhz * 1000000)\n\t\t/ (SAMPLERATE * (BITRATE * 2) * 2);\n\n\tsolo_reg_write(solo_dev, SOLO_AUDIO_SAMPLE,\n\t\t       SOLO_AUDIO_BITRATE(BITRATE)\n\t\t       | SOLO_AUDIO_CLK_DIV(clk_div));\n\n\tsolo_reg_write(solo_dev, SOLO_AUDIO_FDMA_INTR,\n\t\t       SOLO_AUDIO_FDMA_INTERVAL(1)\n\t\t       | SOLO_AUDIO_INTR_ORDER(G723_INTR_ORDER)\n\t\t       | SOLO_AUDIO_FDMA_BASE(SOLO_G723_EXT_ADDR(solo_dev) >> 16));\n\n\tsolo_reg_write(solo_dev, SOLO_AUDIO_CONTROL,\n\t\t       SOLO_AUDIO_ENABLE\n\t\t       | SOLO_AUDIO_I2S_MODE\n\t\t       | SOLO_AUDIO_I2S_MULTI(3)\n\t\t       | SOLO_AUDIO_MODE(OUTMODE_MASK));\n}\n\nvoid solo_g723_isr(struct solo_dev *solo_dev)\n{\n\tstruct snd_pcm_str *pstr =\n\t\t&solo_dev->snd_pcm->streams[SNDRV_PCM_STREAM_CAPTURE];\n\tstruct snd_pcm_substream *ss;\n\tstruct solo_snd_pcm *solo_pcm;\n\n\tfor (ss = pstr->substream; ss != NULL; ss = ss->next) {\n\t\tif (snd_pcm_substream_chip(ss) == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (snd_pcm_substream_chip(ss) == solo_dev)\n\t\t\tcontinue;\n\n\t\t \n\t\tsolo_pcm = snd_pcm_substream_chip(ss);\n\t\tif (!solo_pcm->on)\n\t\t\tcontinue;\n\n\t\tsnd_pcm_period_elapsed(ss);\n\t}\n}\n\nstatic const struct snd_pcm_hardware snd_solo_pcm_hw = {\n\t.info\t\t\t= (SNDRV_PCM_INFO_MMAP |\n\t\t\t\t   SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t   SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t   SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats\t\t= SNDRV_PCM_FMTBIT_U8,\n\t.rates\t\t\t= SNDRV_PCM_RATE_8000,\n\t.rate_min\t\t= SAMPLERATE,\n\t.rate_max\t\t= SAMPLERATE,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 1,\n\t.buffer_bytes_max\t= G723_PERIOD_BYTES * PERIODS,\n\t.period_bytes_min\t= G723_PERIOD_BYTES,\n\t.period_bytes_max\t= G723_PERIOD_BYTES,\n\t.periods_min\t\t= PERIODS,\n\t.periods_max\t\t= PERIODS,\n};\n\nstatic int snd_solo_pcm_open(struct snd_pcm_substream *ss)\n{\n\tstruct solo_dev *solo_dev = snd_pcm_substream_chip(ss);\n\tstruct solo_snd_pcm *solo_pcm;\n\n\tsolo_pcm = kzalloc(sizeof(*solo_pcm), GFP_KERNEL);\n\tif (solo_pcm == NULL)\n\t\tgoto oom;\n\n\tsolo_pcm->g723_buf = dma_alloc_coherent(&solo_dev->pdev->dev,\n\t\t\t\t\t\tG723_PERIOD_BYTES,\n\t\t\t\t\t\t&solo_pcm->g723_dma,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (solo_pcm->g723_buf == NULL)\n\t\tgoto oom;\n\n\tspin_lock_init(&solo_pcm->lock);\n\tsolo_pcm->solo_dev = solo_dev;\n\tss->runtime->hw = snd_solo_pcm_hw;\n\n\tsnd_pcm_substream_chip(ss) = solo_pcm;\n\n\treturn 0;\n\noom:\n\tkfree(solo_pcm);\n\treturn -ENOMEM;\n}\n\nstatic int snd_solo_pcm_close(struct snd_pcm_substream *ss)\n{\n\tstruct solo_snd_pcm *solo_pcm = snd_pcm_substream_chip(ss);\n\n\tsnd_pcm_substream_chip(ss) = solo_pcm->solo_dev;\n\tdma_free_coherent(&solo_pcm->solo_dev->pdev->dev, G723_PERIOD_BYTES,\n\t\t\t  solo_pcm->g723_buf, solo_pcm->g723_dma);\n\tkfree(solo_pcm);\n\n\treturn 0;\n}\n\nstatic int snd_solo_pcm_trigger(struct snd_pcm_substream *ss, int cmd)\n{\n\tstruct solo_snd_pcm *solo_pcm = snd_pcm_substream_chip(ss);\n\tstruct solo_dev *solo_dev = solo_pcm->solo_dev;\n\tint ret = 0;\n\n\tspin_lock(&solo_pcm->lock);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (solo_pcm->on == 0) {\n\t\t\t \n\t\t\tif (atomic_inc_return(&solo_dev->snd_users) == 1)\n\t\t\t\tsolo_irq_on(solo_dev, SOLO_IRQ_G723);\n\t\t\tsolo_pcm->on = 1;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (solo_pcm->on) {\n\t\t\t \n\t\t\tif (atomic_dec_return(&solo_dev->snd_users) == 0)\n\t\t\t\tsolo_irq_off(solo_dev, SOLO_IRQ_G723);\n\t\t\tsolo_pcm->on = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tspin_unlock(&solo_pcm->lock);\n\n\treturn ret;\n}\n\nstatic int snd_solo_pcm_prepare(struct snd_pcm_substream *ss)\n{\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_solo_pcm_pointer(struct snd_pcm_substream *ss)\n{\n\tstruct solo_snd_pcm *solo_pcm = snd_pcm_substream_chip(ss);\n\tstruct solo_dev *solo_dev = solo_pcm->solo_dev;\n\tsnd_pcm_uframes_t idx = solo_reg_read(solo_dev, SOLO_AUDIO_STA) & 0x1f;\n\n\treturn idx * G723_FRAMES_PER_PAGE;\n}\n\nstatic int snd_solo_pcm_copy(struct snd_pcm_substream *ss, int channel,\n\t\t\t     unsigned long pos, struct iov_iter *dst,\n\t\t\t     unsigned long count)\n{\n\tstruct solo_snd_pcm *solo_pcm = snd_pcm_substream_chip(ss);\n\tstruct solo_dev *solo_dev = solo_pcm->solo_dev;\n\tint err, i;\n\n\tfor (i = 0; i < (count / G723_FRAMES_PER_PAGE); i++) {\n\t\tint page = (pos / G723_FRAMES_PER_PAGE) + i;\n\n\t\terr = solo_p2m_dma_t(solo_dev, 0, solo_pcm->g723_dma,\n\t\t\t\t     SOLO_G723_EXT_ADDR(solo_dev) +\n\t\t\t\t     (page * G723_PERIOD_BLOCK) +\n\t\t\t\t     (ss->number * G723_PERIOD_BYTES),\n\t\t\t\t     G723_PERIOD_BYTES, 0, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (copy_to_iter(solo_pcm->g723_buf, G723_PERIOD_BYTES, dst) !=\n\t\t    G723_PERIOD_BYTES)\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_solo_pcm_ops = {\n\t.open = snd_solo_pcm_open,\n\t.close = snd_solo_pcm_close,\n\t.prepare = snd_solo_pcm_prepare,\n\t.trigger = snd_solo_pcm_trigger,\n\t.pointer = snd_solo_pcm_pointer,\n\t.copy = snd_solo_pcm_copy,\n};\n\nstatic int snd_solo_capture_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_info *info)\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = 1;\n\tinfo->value.integer.min = 0;\n\tinfo->value.integer.max = 15;\n\tinfo->value.integer.step = 1;\n\n\treturn 0;\n}\n\nstatic int snd_solo_capture_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct solo_dev *solo_dev = snd_kcontrol_chip(kcontrol);\n\tu8 ch = value->id.numid - 1;\n\n\tvalue->value.integer.value[0] = tw28_get_audio_gain(solo_dev, ch);\n\n\treturn 0;\n}\n\nstatic int snd_solo_capture_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct solo_dev *solo_dev = snd_kcontrol_chip(kcontrol);\n\tu8 ch = value->id.numid - 1;\n\tu8 old_val;\n\n\told_val = tw28_get_audio_gain(solo_dev, ch);\n\tif (old_val == value->value.integer.value[0])\n\t\treturn 0;\n\n\ttw28_set_audio_gain(solo_dev, ch, value->value.integer.value[0]);\n\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new snd_solo_capture_volume = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Capture Volume\",\n\t.info = snd_solo_capture_volume_info,\n\t.get = snd_solo_capture_volume_get,\n\t.put = snd_solo_capture_volume_put,\n};\n\nstatic int solo_snd_pcm_init(struct solo_dev *solo_dev)\n{\n\tstruct snd_card *card = solo_dev->snd_card;\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *ss;\n\tint ret;\n\tint i;\n\n\tret = snd_pcm_new(card, card->driver, 0, 0, solo_dev->nr_chans,\n\t\t\t  &pcm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_solo_pcm_ops);\n\n\tsnd_pcm_chip(pcm) = solo_dev;\n\tpcm->info_flags = 0;\n\tstrscpy(pcm->name, card->shortname, sizeof(pcm->name));\n\n\tfor (i = 0, ss = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\n\t     ss; ss = ss->next, i++)\n\t\tsprintf(ss->name, \"Camera #%d Audio\", i);\n\n\tsnd_pcm_set_managed_buffer_all(pcm,\n\t\t\t\t       SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t       NULL,\n\t\t\t\t       G723_PERIOD_BYTES * PERIODS,\n\t\t\t\t       G723_PERIOD_BYTES * PERIODS);\n\n\tsolo_dev->snd_pcm = pcm;\n\n\treturn 0;\n}\n\nint solo_g723_init(struct solo_dev *solo_dev)\n{\n\tstatic struct snd_device_ops ops = { };\n\tstruct snd_card *card;\n\tstruct snd_kcontrol_new kctl;\n\tchar name[32];\n\tint ret;\n\n\tatomic_set(&solo_dev->snd_users, 0);\n\n\t \n\tsprintf(name, \"Softlogic%d\", solo_dev->vfd->num);\n\n\tret = snd_card_new(&solo_dev->pdev->dev,\n\t\t\t   SNDRV_DEFAULT_IDX1, name, THIS_MODULE, 0,\n\t\t\t   &solo_dev->snd_card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcard = solo_dev->snd_card;\n\n\tstrscpy(card->driver, SOLO6X10_NAME, sizeof(card->driver));\n\tstrscpy(card->shortname, \"SOLO-6x10 Audio\", sizeof(card->shortname));\n\tsprintf(card->longname, \"%s on %s IRQ %d\", card->shortname,\n\t\tpci_name(solo_dev->pdev), solo_dev->pdev->irq);\n\n\tret = snd_device_new(card, SNDRV_DEV_LOWLEVEL, solo_dev, &ops);\n\tif (ret < 0)\n\t\tgoto snd_error;\n\n\t \n\tstrscpy(card->mixername, \"SOLO-6x10\", sizeof(card->mixername));\n\tkctl = snd_solo_capture_volume;\n\tkctl.count = solo_dev->nr_chans;\n\n\tret = snd_ctl_add(card, snd_ctl_new1(&kctl, solo_dev));\n\tif (ret < 0)\n\t\tgoto snd_error;\n\n\tret = solo_snd_pcm_init(solo_dev);\n\tif (ret < 0)\n\t\tgoto snd_error;\n\n\tret = snd_card_register(card);\n\tif (ret < 0)\n\t\tgoto snd_error;\n\n\tsolo_g723_config(solo_dev);\n\n\tdev_info(&solo_dev->pdev->dev, \"Alsa sound card as %s\\n\", name);\n\n\treturn 0;\n\nsnd_error:\n\tsnd_card_free(card);\n\treturn ret;\n}\n\nvoid solo_g723_exit(struct solo_dev *solo_dev)\n{\n\tif (!solo_dev->snd_card)\n\t\treturn;\n\n\tsolo_reg_write(solo_dev, SOLO_AUDIO_CONTROL, 0);\n\tsolo_irq_off(solo_dev, SOLO_IRQ_G723);\n\n\tsnd_card_free(solo_dev->snd_card);\n\tsolo_dev->snd_card = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}