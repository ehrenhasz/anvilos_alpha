{
  "module_name": "solo6x10-enc.c",
  "hash_id": "9161ffea457014a36eb5cf04e992eb61876407eff145f4a0cf1956c91247a3ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/solo6x10/solo6x10-enc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/font.h>\n#include <linux/bitrev.h>\n#include <linux/slab.h>\n\n#include \"solo6x10.h\"\n\n#define VI_PROG_HSIZE\t\t\t(1280 - 16)\n#define VI_PROG_VSIZE\t\t\t(1024 - 16)\n\n#define IRQ_LEVEL\t\t\t2\n\nstatic void solo_capture_config(struct solo_dev *solo_dev)\n{\n\tunsigned long height;\n\tunsigned long width;\n\tvoid *buf;\n\tint i;\n\n\tsolo_reg_write(solo_dev, SOLO_CAP_BASE,\n\t\t       SOLO_CAP_MAX_PAGE((SOLO_CAP_EXT_SIZE(solo_dev)\n\t\t\t\t\t  - SOLO_CAP_PAGE_SIZE) >> 16)\n\t\t       | SOLO_CAP_BASE_ADDR(SOLO_CAP_EXT_ADDR(solo_dev) >> 16));\n\n\t \n\tif (solo_dev->type == SOLO_DEV_6110) {\n\t\t \n\t\tsolo_reg_write(solo_dev, SOLO_CAP_BTW,\n\t\t\t       (1 << 17) | SOLO_CAP_PROG_BANDWIDTH(2) |\n\t\t\t       SOLO_CAP_MAX_BANDWIDTH(36));\n\t} else {\n\t\tsolo_reg_write(solo_dev, SOLO_CAP_BTW,\n\t\t\t       (1 << 17) | SOLO_CAP_PROG_BANDWIDTH(2) |\n\t\t\t       SOLO_CAP_MAX_BANDWIDTH(32));\n\t}\n\n\t \n\twidth = solo_dev->video_hsize;\n\theight = solo_dev->video_vsize;\n\tsolo_reg_write(solo_dev, SOLO_DIM_SCALE1,\n\t\t       SOLO_DIM_H_MB_NUM(width / 16) |\n\t\t       SOLO_DIM_V_MB_NUM_FRAME(height / 8) |\n\t\t       SOLO_DIM_V_MB_NUM_FIELD(height / 16));\n\n\t \n\twidth = solo_dev->video_hsize / 2;\n\theight = solo_dev->video_vsize;\n\tsolo_reg_write(solo_dev, SOLO_DIM_SCALE2,\n\t\t       SOLO_DIM_H_MB_NUM(width / 16) |\n\t\t       SOLO_DIM_V_MB_NUM_FRAME(height / 8) |\n\t\t       SOLO_DIM_V_MB_NUM_FIELD(height / 16));\n\n\t \n\twidth = solo_dev->video_hsize / 2;\n\theight = solo_dev->video_vsize / 2;\n\tsolo_reg_write(solo_dev, SOLO_DIM_SCALE3,\n\t\t       SOLO_DIM_H_MB_NUM(width / 16) |\n\t\t       SOLO_DIM_V_MB_NUM_FRAME(height / 8) |\n\t\t       SOLO_DIM_V_MB_NUM_FIELD(height / 16));\n\n\t \n\twidth = solo_dev->video_hsize / 3;\n\theight = solo_dev->video_vsize / 3;\n\tsolo_reg_write(solo_dev, SOLO_DIM_SCALE4,\n\t\t       SOLO_DIM_H_MB_NUM(width / 16) |\n\t\t       SOLO_DIM_V_MB_NUM_FRAME(height / 8) |\n\t\t       SOLO_DIM_V_MB_NUM_FIELD(height / 16));\n\n\t \n\twidth = solo_dev->video_hsize / 4;\n\theight = solo_dev->video_vsize / 2;\n\tsolo_reg_write(solo_dev, SOLO_DIM_SCALE5,\n\t\t       SOLO_DIM_H_MB_NUM(width / 16) |\n\t\t       SOLO_DIM_V_MB_NUM_FRAME(height / 8) |\n\t\t       SOLO_DIM_V_MB_NUM_FIELD(height / 16));\n\n\t \n\twidth = VI_PROG_HSIZE;\n\theight = VI_PROG_VSIZE;\n\tsolo_reg_write(solo_dev, SOLO_DIM_PROG,\n\t\t       SOLO_DIM_H_MB_NUM(width / 16) |\n\t\t       SOLO_DIM_V_MB_NUM_FRAME(height / 16) |\n\t\t       SOLO_DIM_V_MB_NUM_FIELD(height / 16));\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_VE_OSD_CH, 0);\n\tsolo_reg_write(solo_dev, SOLO_VE_OSD_BASE, SOLO_EOSD_EXT_ADDR >> 16);\n\tsolo_reg_write(solo_dev, SOLO_VE_OSD_CLR,\n\t\t       0xF0 << 16 | 0x80 << 8 | 0x80);\n\n\tif (solo_dev->type == SOLO_DEV_6010)\n\t\tsolo_reg_write(solo_dev, SOLO_VE_OSD_OPT,\n\t\t\t       SOLO_VE_OSD_H_SHADOW | SOLO_VE_OSD_V_SHADOW);\n\telse\n\t\tsolo_reg_write(solo_dev, SOLO_VE_OSD_OPT, SOLO_VE_OSD_V_DOUBLE\n\t\t\t       | SOLO_VE_OSD_H_SHADOW | SOLO_VE_OSD_V_SHADOW);\n\n\t \n\tbuf = kzalloc(SOLO_EOSD_EXT_SIZE(solo_dev), GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tfor (i = 0; i < solo_dev->nr_chans; i++) {\n\t\tsolo_p2m_dma(solo_dev, 1, buf,\n\t\t\t     SOLO_EOSD_EXT_ADDR +\n\t\t\t     (SOLO_EOSD_EXT_SIZE(solo_dev) * i),\n\t\t\t     SOLO_EOSD_EXT_SIZE(solo_dev), 0, 0);\n\t}\n\tkfree(buf);\n}\n\n#define SOLO_OSD_WRITE_SIZE (16 * OSD_TEXT_MAX)\n\n \nint solo_osd_print(struct solo_enc_dev *solo_enc)\n{\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\tu8 *str = solo_enc->osd_text;\n\tu8 *buf = solo_enc->osd_buf;\n\tu32 reg;\n\tconst struct font_desc *vga = find_font(\"VGA8x16\");\n\tconst u8 *vga_data;\n\tint i, j;\n\n\tif (WARN_ON_ONCE(!vga))\n\t\treturn -ENODEV;\n\n\treg = solo_reg_read(solo_dev, SOLO_VE_OSD_CH);\n\tif (!*str) {\n\t\t \n\t\treg &= ~(1 << solo_enc->ch);\n\t\tgoto out;\n\t}\n\n\tmemset(buf, 0, SOLO_OSD_WRITE_SIZE);\n\tvga_data = (const u8 *)vga->data;\n\n\tfor (i = 0; *str; i++, str++) {\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tbuf[(j << 1) | (i & 1) | ((i & ~1) << 4)] =\n\t\t\t    bitrev8(vga_data[(*str << 4) | j]);\n\t\t}\n\t}\n\n\tsolo_p2m_dma(solo_dev, 1, buf,\n\t\t     SOLO_EOSD_EXT_ADDR_CHAN(solo_dev, solo_enc->ch),\n\t\t     SOLO_OSD_WRITE_SIZE, 0, 0);\n\n\t \n\treg |= (1 << solo_enc->ch);\n\nout:\n\tsolo_reg_write(solo_dev, SOLO_VE_OSD_CH, reg);\n\treturn 0;\n}\n\n \nvoid solo_s_jpeg_qp(struct solo_dev *solo_dev, unsigned int ch,\n\t\t    unsigned int qp)\n{\n\tunsigned long flags;\n\tunsigned int idx, reg;\n\n\tif ((ch > 31) || (qp > 3))\n\t\treturn;\n\n\tif (solo_dev->type == SOLO_DEV_6010)\n\t\treturn;\n\n\tif (ch < 16) {\n\t\tidx = 0;\n\t\treg = SOLO_VE_JPEG_QP_CH_L;\n\t} else {\n\t\tch -= 16;\n\t\tidx = 1;\n\t\treg = SOLO_VE_JPEG_QP_CH_H;\n\t}\n\tch *= 2;\n\n\tspin_lock_irqsave(&solo_dev->jpeg_qp_lock, flags);\n\n\tsolo_dev->jpeg_qp[idx] &= ~(3 << ch);\n\tsolo_dev->jpeg_qp[idx] |= (qp & 3) << ch;\n\n\tsolo_reg_write(solo_dev, reg, solo_dev->jpeg_qp[idx]);\n\n\tspin_unlock_irqrestore(&solo_dev->jpeg_qp_lock, flags);\n}\n\nint solo_g_jpeg_qp(struct solo_dev *solo_dev, unsigned int ch)\n{\n\tint idx;\n\n\tif (solo_dev->type == SOLO_DEV_6010)\n\t\treturn 2;\n\n\tif (WARN_ON_ONCE(ch > 31))\n\t\treturn 2;\n\n\tif (ch < 16) {\n\t\tidx = 0;\n\t} else {\n\t\tch -= 16;\n\t\tidx = 1;\n\t}\n\tch *= 2;\n\n\treturn (solo_dev->jpeg_qp[idx] >> ch) & 3;\n}\n\n#define SOLO_QP_INIT 0xaaaaaaaa\n\nstatic void solo_jpeg_config(struct solo_dev *solo_dev)\n{\n\tif (solo_dev->type == SOLO_DEV_6010) {\n\t\tsolo_reg_write(solo_dev, SOLO_VE_JPEG_QP_TBL,\n\t\t\t       (2 << 24) | (2 << 16) | (2 << 8) | 2);\n\t} else {\n\t\tsolo_reg_write(solo_dev, SOLO_VE_JPEG_QP_TBL,\n\t\t\t       (4 << 24) | (3 << 16) | (2 << 8) | 1);\n\t}\n\n\tspin_lock_init(&solo_dev->jpeg_qp_lock);\n\n\t \n\tsolo_dev->jpeg_qp[0] = solo_dev->jpeg_qp[1] = SOLO_QP_INIT;\n\tsolo_reg_write(solo_dev, SOLO_VE_JPEG_QP_CH_L, SOLO_QP_INIT);\n\tsolo_reg_write(solo_dev, SOLO_VE_JPEG_QP_CH_H, SOLO_QP_INIT);\n\n\tsolo_reg_write(solo_dev, SOLO_VE_JPEG_CFG,\n\t\t(SOLO_JPEG_EXT_SIZE(solo_dev) & 0xffff0000) |\n\t\t((SOLO_JPEG_EXT_ADDR(solo_dev) >> 16) & 0x0000ffff));\n\tsolo_reg_write(solo_dev, SOLO_VE_JPEG_CTRL, 0xffffffff);\n\tif (solo_dev->type == SOLO_DEV_6110) {\n\t\tsolo_reg_write(solo_dev, SOLO_VE_JPEG_CFG1,\n\t\t\t       (0 << 16) | (30 << 8) | 60);\n\t}\n}\n\nstatic void solo_mp4e_config(struct solo_dev *solo_dev)\n{\n\tint i;\n\tu32 cfg;\n\n\tsolo_reg_write(solo_dev, SOLO_VE_CFG0,\n\t\t       SOLO_VE_INTR_CTRL(IRQ_LEVEL) |\n\t\t       SOLO_VE_BLOCK_SIZE(SOLO_MP4E_EXT_SIZE(solo_dev) >> 16) |\n\t\t       SOLO_VE_BLOCK_BASE(SOLO_MP4E_EXT_ADDR(solo_dev) >> 16));\n\n\n\tcfg = SOLO_VE_BYTE_ALIGN(2) | SOLO_VE_INSERT_INDEX\n\t\t| SOLO_VE_MOTION_MODE(0);\n\tif (solo_dev->type != SOLO_DEV_6010) {\n\t\tcfg |= SOLO_VE_MPEG_SIZE_H(\n\t\t\t(SOLO_MP4E_EXT_SIZE(solo_dev) >> 24) & 0x0f);\n\t\tcfg |= SOLO_VE_JPEG_SIZE_H(\n\t\t\t(SOLO_JPEG_EXT_SIZE(solo_dev) >> 24) & 0x0f);\n\t}\n\tsolo_reg_write(solo_dev, SOLO_VE_CFG1, cfg);\n\n\tsolo_reg_write(solo_dev, SOLO_VE_WMRK_POLY, 0);\n\tsolo_reg_write(solo_dev, SOLO_VE_VMRK_INIT_KEY, 0);\n\tsolo_reg_write(solo_dev, SOLO_VE_WMRK_STRL, 0);\n\tif (solo_dev->type == SOLO_DEV_6110)\n\t\tsolo_reg_write(solo_dev, SOLO_VE_WMRK_ENABLE, 0);\n\tsolo_reg_write(solo_dev, SOLO_VE_ENCRYP_POLY, 0);\n\tsolo_reg_write(solo_dev, SOLO_VE_ENCRYP_INIT, 0);\n\n\tsolo_reg_write(solo_dev, SOLO_VE_ATTR,\n\t\t       SOLO_VE_LITTLE_ENDIAN |\n\t\t       SOLO_COMP_ATTR_FCODE(1) |\n\t\t       SOLO_COMP_TIME_INC(0) |\n\t\t       SOLO_COMP_TIME_WIDTH(15) |\n\t\t       SOLO_DCT_INTERVAL(solo_dev->type == SOLO_DEV_6010 ? 9 : 10));\n\n\tfor (i = 0; i < solo_dev->nr_chans; i++) {\n\t\tsolo_reg_write(solo_dev, SOLO_VE_CH_REF_BASE(i),\n\t\t\t       (SOLO_EREF_EXT_ADDR(solo_dev) +\n\t\t\t       (i * SOLO_EREF_EXT_SIZE)) >> 16);\n\t\tsolo_reg_write(solo_dev, SOLO_VE_CH_REF_BASE_E(i),\n\t\t\t       (SOLO_EREF_EXT_ADDR(solo_dev) +\n\t\t\t       ((i + 16) * SOLO_EREF_EXT_SIZE)) >> 16);\n\t}\n\n\tif (solo_dev->type == SOLO_DEV_6110) {\n\t\tsolo_reg_write(solo_dev, SOLO_VE_COMPT_MOT, 0x00040008);\n\t} else {\n\t\tfor (i = 0; i < solo_dev->nr_chans; i++)\n\t\t\tsolo_reg_write(solo_dev, SOLO_VE_CH_MOT(i), 0x100);\n\t}\n}\n\nint solo_enc_init(struct solo_dev *solo_dev)\n{\n\tint i;\n\n\tsolo_capture_config(solo_dev);\n\tsolo_mp4e_config(solo_dev);\n\tsolo_jpeg_config(solo_dev);\n\n\tfor (i = 0; i < solo_dev->nr_chans; i++) {\n\t\tsolo_reg_write(solo_dev, SOLO_CAP_CH_SCALE(i), 0);\n\t\tsolo_reg_write(solo_dev, SOLO_CAP_CH_COMP_ENA_E(i), 0);\n\t}\n\n\treturn 0;\n}\n\nvoid solo_enc_exit(struct solo_dev *solo_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < solo_dev->nr_chans; i++) {\n\t\tsolo_reg_write(solo_dev, SOLO_CAP_CH_SCALE(i), 0);\n\t\tsolo_reg_write(solo_dev, SOLO_CAP_CH_COMP_ENA_E(i), 0);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}