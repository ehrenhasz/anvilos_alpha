{
  "module_name": "solo6x10-v4l2-enc.c",
  "hash_id": "04454137e0bcfb210706199f518ebcb069e8d249797bd0a099c5ac3ca45db895",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/solo6x10/solo6x10-v4l2-enc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-dma-sg.h>\n\n#include \"solo6x10.h\"\n#include \"solo6x10-tw28.h\"\n#include \"solo6x10-jpeg.h\"\n\n#define MIN_VID_BUFFERS\t\t2\n#define FRAME_BUF_SIZE\t\t(400 * 1024)\n#define MP4_QS\t\t\t16\n#define DMA_ALIGN\t\t4096\n\n \nstatic u8 vop_6010_ntsc_d1[] = {\n\t0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x20,\n\t0x02, 0x48, 0x1d, 0xc0, 0x00, 0x40, 0x00, 0x40,\n\t0x00, 0x40, 0x00, 0x80, 0x00, 0x97, 0x53, 0x04,\n\t0x1f, 0x4c, 0x58, 0x10, 0xf0, 0x71, 0x18, 0x3f,\n};\n\nstatic u8 vop_6010_ntsc_cif[] = {\n\t0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x20,\n\t0x02, 0x48, 0x1d, 0xc0, 0x00, 0x40, 0x00, 0x40,\n\t0x00, 0x40, 0x00, 0x80, 0x00, 0x97, 0x53, 0x04,\n\t0x1f, 0x4c, 0x2c, 0x10, 0x78, 0x51, 0x18, 0x3f,\n};\n\nstatic u8 vop_6010_pal_d1[] = {\n\t0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x20,\n\t0x02, 0x48, 0x15, 0xc0, 0x00, 0x40, 0x00, 0x40,\n\t0x00, 0x40, 0x00, 0x80, 0x00, 0x97, 0x53, 0x04,\n\t0x1f, 0x4c, 0x58, 0x11, 0x20, 0x71, 0x18, 0x3f,\n};\n\nstatic u8 vop_6010_pal_cif[] = {\n\t0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x20,\n\t0x02, 0x48, 0x15, 0xc0, 0x00, 0x40, 0x00, 0x40,\n\t0x00, 0x40, 0x00, 0x80, 0x00, 0x97, 0x53, 0x04,\n\t0x1f, 0x4c, 0x2c, 0x10, 0x90, 0x51, 0x18, 0x3f,\n};\n\n \nstatic u8 vop_6110_ntsc_d1[] = {\n\t0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1e,\n\t0x9a, 0x74, 0x05, 0x81, 0xec, 0x80, 0x00, 0x00,\n\t0x00, 0x01, 0x68, 0xce, 0x32, 0x28, 0x00, 0x00,\n};\n\nstatic u8 vop_6110_ntsc_cif[] = {\n\t0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1e,\n\t0x9a, 0x74, 0x0b, 0x0f, 0xc8, 0x00, 0x00, 0x00,\n\t0x01, 0x68, 0xce, 0x32, 0x28, 0x00, 0x00, 0x00,\n};\n\nstatic u8 vop_6110_pal_d1[] = {\n\t0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1e,\n\t0x9a, 0x74, 0x05, 0x80, 0x93, 0x20, 0x00, 0x00,\n\t0x00, 0x01, 0x68, 0xce, 0x32, 0x28, 0x00, 0x00,\n};\n\nstatic u8 vop_6110_pal_cif[] = {\n\t0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1e,\n\t0x9a, 0x74, 0x0b, 0x04, 0xb2, 0x00, 0x00, 0x00,\n\t0x01, 0x68, 0xce, 0x32, 0x28, 0x00, 0x00, 0x00,\n};\n\ntypedef __le32 vop_header[16];\n\nstruct solo_enc_buf {\n\tenum solo_enc_types\ttype;\n\tconst vop_header\t*vh;\n\tint\t\t\tmotion;\n};\n\nstatic int solo_is_motion_on(struct solo_enc_dev *solo_enc)\n{\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\n\treturn (solo_dev->motion_mask >> solo_enc->ch) & 1;\n}\n\nstatic int solo_motion_detected(struct solo_enc_dev *solo_enc)\n{\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\tunsigned long flags;\n\tu32 ch_mask = 1 << solo_enc->ch;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&solo_enc->motion_lock, flags);\n\tif (solo_reg_read(solo_dev, SOLO_VI_MOT_STATUS) & ch_mask) {\n\t\tsolo_reg_write(solo_dev, SOLO_VI_MOT_CLEAR, ch_mask);\n\t\tret = 1;\n\t}\n\tspin_unlock_irqrestore(&solo_enc->motion_lock, flags);\n\n\treturn ret;\n}\n\nstatic void solo_motion_toggle(struct solo_enc_dev *solo_enc, int on)\n{\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\tu32 mask = 1 << solo_enc->ch;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&solo_enc->motion_lock, flags);\n\n\tif (on)\n\t\tsolo_dev->motion_mask |= mask;\n\telse\n\t\tsolo_dev->motion_mask &= ~mask;\n\n\tsolo_reg_write(solo_dev, SOLO_VI_MOT_CLEAR, mask);\n\n\tsolo_reg_write(solo_dev, SOLO_VI_MOT_ADR,\n\t\t       SOLO_VI_MOTION_EN(solo_dev->motion_mask) |\n\t\t       (SOLO_MOTION_EXT_ADDR(solo_dev) >> 16));\n\n\tspin_unlock_irqrestore(&solo_enc->motion_lock, flags);\n}\n\nvoid solo_update_mode(struct solo_enc_dev *solo_enc)\n{\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\tint vop_len;\n\tu8 *vop;\n\n\tsolo_enc->interlaced = (solo_enc->mode & 0x08) ? 1 : 0;\n\tsolo_enc->bw_weight = max(solo_dev->fps / solo_enc->interval, 1);\n\n\tif (solo_enc->mode == SOLO_ENC_MODE_CIF) {\n\t\tsolo_enc->width = solo_dev->video_hsize >> 1;\n\t\tsolo_enc->height = solo_dev->video_vsize;\n\t\tif (solo_dev->type == SOLO_DEV_6110) {\n\t\t\tif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC) {\n\t\t\t\tvop = vop_6110_ntsc_cif;\n\t\t\t\tvop_len = sizeof(vop_6110_ntsc_cif);\n\t\t\t} else {\n\t\t\t\tvop = vop_6110_pal_cif;\n\t\t\t\tvop_len = sizeof(vop_6110_pal_cif);\n\t\t\t}\n\t\t} else {\n\t\t\tif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC) {\n\t\t\t\tvop = vop_6010_ntsc_cif;\n\t\t\t\tvop_len = sizeof(vop_6010_ntsc_cif);\n\t\t\t} else {\n\t\t\t\tvop = vop_6010_pal_cif;\n\t\t\t\tvop_len = sizeof(vop_6010_pal_cif);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsolo_enc->width = solo_dev->video_hsize;\n\t\tsolo_enc->height = solo_dev->video_vsize << 1;\n\t\tsolo_enc->bw_weight <<= 2;\n\t\tif (solo_dev->type == SOLO_DEV_6110) {\n\t\t\tif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC) {\n\t\t\t\tvop = vop_6110_ntsc_d1;\n\t\t\t\tvop_len = sizeof(vop_6110_ntsc_d1);\n\t\t\t} else {\n\t\t\t\tvop = vop_6110_pal_d1;\n\t\t\t\tvop_len = sizeof(vop_6110_pal_d1);\n\t\t\t}\n\t\t} else {\n\t\t\tif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC) {\n\t\t\t\tvop = vop_6010_ntsc_d1;\n\t\t\t\tvop_len = sizeof(vop_6010_ntsc_d1);\n\t\t\t} else {\n\t\t\t\tvop = vop_6010_pal_d1;\n\t\t\t\tvop_len = sizeof(vop_6010_pal_d1);\n\t\t\t}\n\t\t}\n\t}\n\n\tmemcpy(solo_enc->vop, vop, vop_len);\n\n\t \n\tif (solo_dev->type == SOLO_DEV_6010) {\n\t\tu16 fps = solo_dev->fps * 1000;\n\t\tu16 interval = solo_enc->interval * 1000;\n\n\t\tvop = solo_enc->vop;\n\n\t\t \n\t\tvop[22] = fps >> 4;\n\t\tvop[23] = ((fps << 4) & 0xf0) | 0x0c\n\t\t\t| ((interval >> 13) & 0x3);\n\t\tvop[24] = (interval >> 5) & 0xff;\n\t\tvop[25] = ((interval << 3) & 0xf8) | 0x04;\n\t}\n\n\tsolo_enc->vop_len = vop_len;\n\n\t \n\tvop = solo_enc->jpeg_header;\n\tvop[SOF0_START + 5] = 0xff & (solo_enc->height >> 8);\n\tvop[SOF0_START + 6] = 0xff & solo_enc->height;\n\tvop[SOF0_START + 7] = 0xff & (solo_enc->width >> 8);\n\tvop[SOF0_START + 8] = 0xff & solo_enc->width;\n\n\tmemcpy(vop + DQT_START,\n\t       jpeg_dqt[solo_g_jpeg_qp(solo_dev, solo_enc->ch)], DQT_LEN);\n}\n\nstatic int solo_enc_on(struct solo_enc_dev *solo_enc)\n{\n\tu8 ch = solo_enc->ch;\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\tu8 interval;\n\n\tsolo_update_mode(solo_enc);\n\n\t \n\tif (solo_enc->bw_weight > solo_dev->enc_bw_remain)\n\t\treturn -EBUSY;\n\tsolo_enc->sequence = 0;\n\tsolo_dev->enc_bw_remain -= solo_enc->bw_weight;\n\n\tif (solo_enc->type == SOLO_ENC_TYPE_EXT)\n\t\tsolo_reg_write(solo_dev, SOLO_CAP_CH_COMP_ENA_E(ch), 1);\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_CAP_CH_SCALE(ch), 0);\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_VE_CH_INTL(ch),\n\t\t       solo_enc->interlaced ? 1 : 0);\n\n\tif (solo_enc->interlaced)\n\t\tinterval = solo_enc->interval - 1;\n\telse\n\t\tinterval = solo_enc->interval;\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_VE_CH_GOP(ch), solo_enc->gop);\n\tsolo_reg_write(solo_dev, SOLO_VE_CH_QP(ch), solo_enc->qp);\n\tsolo_reg_write(solo_dev, SOLO_CAP_CH_INTV(ch), interval);\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_VE_CH_GOP_E(ch), solo_enc->gop);\n\tsolo_reg_write(solo_dev, SOLO_VE_CH_QP_E(ch), solo_enc->qp);\n\tsolo_reg_write(solo_dev, SOLO_CAP_CH_INTV_E(ch), interval);\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_CAP_CH_SCALE(ch), solo_enc->mode);\n\n\treturn 0;\n}\n\nstatic void solo_enc_off(struct solo_enc_dev *solo_enc)\n{\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\n\tsolo_dev->enc_bw_remain += solo_enc->bw_weight;\n\n\tsolo_reg_write(solo_dev, SOLO_CAP_CH_SCALE(solo_enc->ch), 0);\n\tsolo_reg_write(solo_dev, SOLO_CAP_CH_COMP_ENA_E(solo_enc->ch), 0);\n}\n\nstatic int enc_get_mpeg_dma(struct solo_dev *solo_dev, dma_addr_t dma,\n\t\t\t      unsigned int off, unsigned int size)\n{\n\tint ret;\n\n\tif (off > SOLO_MP4E_EXT_SIZE(solo_dev))\n\t\treturn -EINVAL;\n\n\t \n\tif (off + size <= SOLO_MP4E_EXT_SIZE(solo_dev)) {\n\t\treturn solo_p2m_dma_t(solo_dev, 0, dma,\n\t\t\t\t      SOLO_MP4E_EXT_ADDR(solo_dev) + off, size,\n\t\t\t\t      0, 0);\n\t}\n\n\t \n\tret = solo_p2m_dma_t(solo_dev, 0, dma,\n\t\t\t     SOLO_MP4E_EXT_ADDR(solo_dev) + off,\n\t\t\t     SOLO_MP4E_EXT_SIZE(solo_dev) - off, 0, 0);\n\n\tif (!ret) {\n\t\tret = solo_p2m_dma_t(solo_dev, 0,\n\t\t\t     dma + SOLO_MP4E_EXT_SIZE(solo_dev) - off,\n\t\t\t     SOLO_MP4E_EXT_ADDR(solo_dev),\n\t\t\t     size + off - SOLO_MP4E_EXT_SIZE(solo_dev), 0, 0);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int solo_send_desc(struct solo_enc_dev *solo_enc, int skip,\n\t\t\t  struct sg_table *vbuf, int off, int size,\n\t\t\t  unsigned int base, unsigned int base_size)\n{\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\tstruct scatterlist *sg;\n\tint i;\n\tint ret;\n\n\tif (WARN_ON_ONCE(size > FRAME_BUF_SIZE))\n\t\treturn -EINVAL;\n\n\tsolo_enc->desc_count = 1;\n\n\tfor_each_sg(vbuf->sgl, sg, vbuf->nents, i) {\n\t\tstruct solo_p2m_desc *desc;\n\t\tdma_addr_t dma;\n\t\tint len;\n\t\tint left = base_size - off;\n\n\t\tdesc = &solo_enc->desc_items[solo_enc->desc_count++];\n\t\tdma = sg_dma_address(sg);\n\t\tlen = sg_dma_len(sg);\n\n\t\t \n\t\tBUG_ON(skip >= len);\n\t\tif (skip) {\n\t\t\tlen -= skip;\n\t\t\tdma += skip;\n\t\t\tsize -= skip;\n\t\t\tskip = 0;\n\t\t}\n\n\t\tlen = min(len, size);\n\n\t\tif (len <= left) {\n\t\t\t \n\t\t\tsolo_p2m_fill_desc(desc, 0, dma, base + off,\n\t\t\t\t\t   len, 0, 0);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tret = solo_p2m_dma_t(solo_dev, 0, dma, base + off,\n\t\t\t\t\t     left, 0, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = solo_p2m_dma_t(solo_dev, 0, dma + left, base,\n\t\t\t\t\t     len - left, 0, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsolo_enc->desc_count--;\n\t\t}\n\n\t\tsize -= len;\n\t\tif (size <= 0)\n\t\t\tbreak;\n\n\t\toff += len;\n\t\tif (off >= base_size)\n\t\t\toff -= base_size;\n\n\t\t \n\t\tif (solo_enc->desc_count >= (solo_enc->desc_nelts - 1)) {\n\t\t\tret = solo_p2m_dma_desc(solo_dev, solo_enc->desc_items,\n\t\t\t\t\t\tsolo_enc->desc_dma,\n\t\t\t\t\t\tsolo_enc->desc_count - 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tsolo_enc->desc_count = 1;\n\t\t}\n\t}\n\n\tif (solo_enc->desc_count <= 1)\n\t\treturn 0;\n\n\treturn solo_p2m_dma_desc(solo_dev, solo_enc->desc_items,\n\t\t\tsolo_enc->desc_dma, solo_enc->desc_count - 1);\n}\n\n \nstatic inline __always_unused int vop_interlaced(const vop_header *vh)\n{\n\treturn (__le32_to_cpu((*vh)[0]) >> 30) & 1;\n}\n\nstatic inline __always_unused u8 vop_channel(const vop_header *vh)\n{\n\treturn (__le32_to_cpu((*vh)[0]) >> 24) & 0x1F;\n}\n\nstatic inline u8 vop_type(const vop_header *vh)\n{\n\treturn (__le32_to_cpu((*vh)[0]) >> 22) & 3;\n}\n\nstatic inline u32 vop_mpeg_size(const vop_header *vh)\n{\n\treturn __le32_to_cpu((*vh)[0]) & 0xFFFFF;\n}\n\nstatic inline u8 __always_unused vop_hsize(const vop_header *vh)\n{\n\treturn (__le32_to_cpu((*vh)[1]) >> 8) & 0xFF;\n}\n\nstatic inline u8 __always_unused vop_vsize(const vop_header *vh)\n{\n\treturn __le32_to_cpu((*vh)[1]) & 0xFF;\n}\n\nstatic inline u32 vop_mpeg_offset(const vop_header *vh)\n{\n\treturn __le32_to_cpu((*vh)[2]);\n}\n\nstatic inline u32 vop_jpeg_offset(const vop_header *vh)\n{\n\treturn __le32_to_cpu((*vh)[3]);\n}\n\nstatic inline u32 vop_jpeg_size(const vop_header *vh)\n{\n\treturn __le32_to_cpu((*vh)[4]) & 0xFFFFF;\n}\n\nstatic inline u32 __always_unused vop_sec(const vop_header *vh)\n{\n\treturn __le32_to_cpu((*vh)[5]);\n}\n\nstatic inline __always_unused u32 vop_usec(const vop_header *vh)\n{\n\treturn __le32_to_cpu((*vh)[6]);\n}\n\nstatic int solo_fill_jpeg(struct solo_enc_dev *solo_enc,\n\t\t\t  struct vb2_buffer *vb, const vop_header *vh)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(vb, 0);\n\tint frame_size;\n\n\tvbuf->flags |= V4L2_BUF_FLAG_KEYFRAME;\n\n\tif (vb2_plane_size(vb, 0) < vop_jpeg_size(vh) + solo_enc->jpeg_len)\n\t\treturn -EIO;\n\n\tframe_size = ALIGN(vop_jpeg_size(vh) + solo_enc->jpeg_len, DMA_ALIGN);\n\tvb2_set_plane_payload(vb, 0, vop_jpeg_size(vh) + solo_enc->jpeg_len);\n\n\treturn solo_send_desc(solo_enc, solo_enc->jpeg_len, sgt,\n\t\t\t     vop_jpeg_offset(vh) - SOLO_JPEG_EXT_ADDR(solo_dev),\n\t\t\t     frame_size, SOLO_JPEG_EXT_ADDR(solo_dev),\n\t\t\t     SOLO_JPEG_EXT_SIZE(solo_dev));\n}\n\nstatic int solo_fill_mpeg(struct solo_enc_dev *solo_enc,\n\t\tstruct vb2_buffer *vb, const vop_header *vh)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(vb, 0);\n\tint frame_off, frame_size;\n\tint skip = 0;\n\n\tif (vb2_plane_size(vb, 0) < vop_mpeg_size(vh))\n\t\treturn -EIO;\n\n\t \n\tvbuf->flags &= ~(V4L2_BUF_FLAG_KEYFRAME | V4L2_BUF_FLAG_PFRAME |\n\t\tV4L2_BUF_FLAG_BFRAME);\n\tif (!vop_type(vh)) {\n\t\tskip = solo_enc->vop_len;\n\t\tvbuf->flags |= V4L2_BUF_FLAG_KEYFRAME;\n\t\tvb2_set_plane_payload(vb, 0, vop_mpeg_size(vh) +\n\t\t\tsolo_enc->vop_len);\n\t} else {\n\t\tvbuf->flags |= V4L2_BUF_FLAG_PFRAME;\n\t\tvb2_set_plane_payload(vb, 0, vop_mpeg_size(vh));\n\t}\n\n\t \n\tframe_off = (vop_mpeg_offset(vh) - SOLO_MP4E_EXT_ADDR(solo_dev) +\n\t\tsizeof(*vh)) % SOLO_MP4E_EXT_SIZE(solo_dev);\n\tframe_size = ALIGN(vop_mpeg_size(vh) + skip, DMA_ALIGN);\n\n\treturn solo_send_desc(solo_enc, skip, sgt, frame_off, frame_size,\n\t\t\tSOLO_MP4E_EXT_ADDR(solo_dev),\n\t\t\tSOLO_MP4E_EXT_SIZE(solo_dev));\n}\n\nstatic int solo_enc_fillbuf(struct solo_enc_dev *solo_enc,\n\t\t\t    struct vb2_buffer *vb, struct solo_enc_buf *enc_buf)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tconst vop_header *vh = enc_buf->vh;\n\tint ret;\n\n\tswitch (solo_enc->fmt) {\n\tcase V4L2_PIX_FMT_MPEG4:\n\tcase V4L2_PIX_FMT_H264:\n\t\tret = solo_fill_mpeg(solo_enc, vb, vh);\n\t\tbreak;\n\tdefault:  \n\t\tret = solo_fill_jpeg(solo_enc, vb, vh);\n\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\tvbuf->sequence = solo_enc->sequence++;\n\t\tvb->timestamp = ktime_get_ns();\n\n\t\t \n\t\tif (solo_is_motion_on(solo_enc) && enc_buf->motion) {\n\t\t\tstruct v4l2_event ev = {\n\t\t\t\t.type = V4L2_EVENT_MOTION_DET,\n\t\t\t\t.u.motion_det = {\n\t\t\t\t\t.flags\n\t\t\t\t\t= V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\n\t\t\t\t\t.frame_sequence = vbuf->sequence,\n\t\t\t\t\t.region_mask = enc_buf->motion ? 1 : 0,\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tv4l2_event_queue(solo_enc->vfd, &ev);\n\t\t}\n\t}\n\n\tvb2_buffer_done(vb, ret ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n\n\treturn ret;\n}\n\nstatic void solo_enc_handle_one(struct solo_enc_dev *solo_enc,\n\t\t\t\tstruct solo_enc_buf *enc_buf)\n{\n\tstruct solo_vb2_buf *vb;\n\tunsigned long flags;\n\n\tmutex_lock(&solo_enc->lock);\n\tif (solo_enc->type != enc_buf->type)\n\t\tgoto unlock;\n\n\tspin_lock_irqsave(&solo_enc->av_lock, flags);\n\tif (list_empty(&solo_enc->vidq_active)) {\n\t\tspin_unlock_irqrestore(&solo_enc->av_lock, flags);\n\t\tgoto unlock;\n\t}\n\tvb = list_first_entry(&solo_enc->vidq_active, struct solo_vb2_buf,\n\t\tlist);\n\tlist_del(&vb->list);\n\tspin_unlock_irqrestore(&solo_enc->av_lock, flags);\n\n\tsolo_enc_fillbuf(solo_enc, &vb->vb.vb2_buf, enc_buf);\nunlock:\n\tmutex_unlock(&solo_enc->lock);\n}\n\nvoid solo_enc_v4l2_isr(struct solo_dev *solo_dev)\n{\n\twake_up_interruptible_all(&solo_dev->ring_thread_wait);\n}\n\nstatic void solo_handle_ring(struct solo_dev *solo_dev)\n{\n\tfor (;;) {\n\t\tstruct solo_enc_dev *solo_enc;\n\t\tstruct solo_enc_buf enc_buf;\n\t\tu32 mpeg_current, off;\n\t\tu8 ch;\n\t\tu8 cur_q;\n\n\t\t \n\t\tcur_q = solo_reg_read(solo_dev, SOLO_VE_STATE(11)) & 0xff;\n\t\tif (cur_q == solo_dev->enc_idx)\n\t\t\tbreak;\n\n\t\tmpeg_current = solo_reg_read(solo_dev,\n\t\t\t\t\tSOLO_VE_MPEG4_QUE(solo_dev->enc_idx));\n\t\tsolo_dev->enc_idx = (solo_dev->enc_idx + 1) % MP4_QS;\n\n\t\tch = (mpeg_current >> 24) & 0x1f;\n\t\toff = mpeg_current & 0x00ffffff;\n\n\t\tif (ch >= SOLO_MAX_CHANNELS) {\n\t\t\tch -= SOLO_MAX_CHANNELS;\n\t\t\tenc_buf.type = SOLO_ENC_TYPE_EXT;\n\t\t} else\n\t\t\tenc_buf.type = SOLO_ENC_TYPE_STD;\n\n\t\tsolo_enc = solo_dev->v4l2_enc[ch];\n\t\tif (solo_enc == NULL) {\n\t\t\tdev_err(&solo_dev->pdev->dev,\n\t\t\t\t\"Got spurious packet for channel %d\\n\", ch);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (enc_get_mpeg_dma(solo_dev, solo_dev->vh_dma, off,\n\t\t\t\t     sizeof(vop_header)))\n\t\t\tcontinue;\n\n\t\tenc_buf.vh = solo_dev->vh_buf;\n\n\t\t \n\t\tif (vop_mpeg_offset(enc_buf.vh) !=\n\t\t\tSOLO_MP4E_EXT_ADDR(solo_dev) + off)\n\t\t\tcontinue;\n\n\t\tif (solo_motion_detected(solo_enc))\n\t\t\tenc_buf.motion = 1;\n\t\telse\n\t\t\tenc_buf.motion = 0;\n\n\t\tsolo_enc_handle_one(solo_enc, &enc_buf);\n\t}\n}\n\nstatic int solo_ring_thread(void *data)\n{\n\tstruct solo_dev *solo_dev = data;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tset_freezable();\n\tadd_wait_queue(&solo_dev->ring_thread_wait, &wait);\n\n\tfor (;;) {\n\t\tlong timeout = schedule_timeout_interruptible(HZ);\n\n\t\tif (timeout == -ERESTARTSYS || kthread_should_stop())\n\t\t\tbreak;\n\t\tsolo_handle_ring(solo_dev);\n\t\ttry_to_freeze();\n\t}\n\n\tremove_wait_queue(&solo_dev->ring_thread_wait, &wait);\n\n\treturn 0;\n}\n\nstatic int solo_enc_queue_setup(struct vb2_queue *q,\n\t\t\t\tunsigned int *num_buffers,\n\t\t\t\tunsigned int *num_planes, unsigned int sizes[],\n\t\t\t\tstruct device *alloc_devs[])\n{\n\tsizes[0] = FRAME_BUF_SIZE;\n\t*num_planes = 1;\n\n\tif (*num_buffers < MIN_VID_BUFFERS)\n\t\t*num_buffers = MIN_VID_BUFFERS;\n\n\treturn 0;\n}\n\nstatic void solo_enc_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct solo_enc_dev *solo_enc = vb2_get_drv_priv(vq);\n\tstruct solo_vb2_buf *solo_vb =\n\t\tcontainer_of(vbuf, struct solo_vb2_buf, vb);\n\n\tspin_lock(&solo_enc->av_lock);\n\tlist_add_tail(&solo_vb->list, &solo_enc->vidq_active);\n\tspin_unlock(&solo_enc->av_lock);\n}\n\nstatic int solo_ring_start(struct solo_dev *solo_dev)\n{\n\tsolo_dev->ring_thread = kthread_run(solo_ring_thread, solo_dev,\n\t\t\t\t\t    SOLO6X10_NAME \"_ring\");\n\tif (IS_ERR(solo_dev->ring_thread)) {\n\t\tint err = PTR_ERR(solo_dev->ring_thread);\n\n\t\tsolo_dev->ring_thread = NULL;\n\t\treturn err;\n\t}\n\n\tsolo_irq_on(solo_dev, SOLO_IRQ_ENCODER);\n\n\treturn 0;\n}\n\nstatic void solo_ring_stop(struct solo_dev *solo_dev)\n{\n\tif (solo_dev->ring_thread) {\n\t\tkthread_stop(solo_dev->ring_thread);\n\t\tsolo_dev->ring_thread = NULL;\n\t}\n\n\tsolo_irq_off(solo_dev, SOLO_IRQ_ENCODER);\n}\n\nstatic int solo_enc_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct solo_enc_dev *solo_enc = vb2_get_drv_priv(q);\n\n\treturn solo_enc_on(solo_enc);\n}\n\nstatic void solo_enc_stop_streaming(struct vb2_queue *q)\n{\n\tstruct solo_enc_dev *solo_enc = vb2_get_drv_priv(q);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&solo_enc->av_lock, flags);\n\tsolo_enc_off(solo_enc);\n\twhile (!list_empty(&solo_enc->vidq_active)) {\n\t\tstruct solo_vb2_buf *buf = list_entry(\n\t\t\t\tsolo_enc->vidq_active.next,\n\t\t\t\tstruct solo_vb2_buf, list);\n\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&solo_enc->av_lock, flags);\n}\n\nstatic void solo_enc_buf_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct solo_enc_dev *solo_enc = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(vb, 0);\n\n\tswitch (solo_enc->fmt) {\n\tcase V4L2_PIX_FMT_MPEG4:\n\tcase V4L2_PIX_FMT_H264:\n\t\tif (vbuf->flags & V4L2_BUF_FLAG_KEYFRAME)\n\t\t\tsg_copy_from_buffer(sgt->sgl, sgt->nents,\n\t\t\t\t\tsolo_enc->vop, solo_enc->vop_len);\n\t\tbreak;\n\tdefault:  \n\t\tsg_copy_from_buffer(sgt->sgl, sgt->nents,\n\t\t\t\tsolo_enc->jpeg_header, solo_enc->jpeg_len);\n\t\tbreak;\n\t}\n}\n\nstatic const struct vb2_ops solo_enc_video_qops = {\n\t.queue_setup\t= solo_enc_queue_setup,\n\t.buf_queue\t= solo_enc_buf_queue,\n\t.buf_finish\t= solo_enc_buf_finish,\n\t.start_streaming = solo_enc_start_streaming,\n\t.stop_streaming = solo_enc_stop_streaming,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n};\n\nstatic int solo_enc_querycap(struct file *file, void  *priv,\n\t\t\t     struct v4l2_capability *cap)\n{\n\tstruct solo_enc_dev *solo_enc = video_drvdata(file);\n\n\tstrscpy(cap->driver, SOLO6X10_NAME, sizeof(cap->driver));\n\tsnprintf(cap->card, sizeof(cap->card), \"Softlogic 6x10 Enc %d\",\n\t\t solo_enc->ch);\n\treturn 0;\n}\n\nstatic int solo_enc_enum_input(struct file *file, void *priv,\n\t\t\t       struct v4l2_input *input)\n{\n\tstruct solo_enc_dev *solo_enc = video_drvdata(file);\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\n\tif (input->index)\n\t\treturn -EINVAL;\n\n\tsnprintf(input->name, sizeof(input->name), \"Encoder %d\",\n\t\t solo_enc->ch + 1);\n\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\tinput->std = solo_enc->vfd->tvnorms;\n\n\tif (!tw28_get_video_status(solo_dev, solo_enc->ch))\n\t\tinput->status = V4L2_IN_ST_NO_SIGNAL;\n\n\treturn 0;\n}\n\nstatic int solo_enc_set_input(struct file *file, void *priv,\n\t\t\t      unsigned int index)\n{\n\tif (index)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int solo_enc_get_input(struct file *file, void *priv,\n\t\t\t      unsigned int *index)\n{\n\t*index = 0;\n\n\treturn 0;\n}\n\nstatic int solo_enc_enum_fmt_cap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_fmtdesc *f)\n{\n\tstruct solo_enc_dev *solo_enc = video_drvdata(file);\n\tint dev_type = solo_enc->solo_dev->type;\n\n\tswitch (f->index) {\n\tcase 0:\n\t\tswitch (dev_type) {\n\t\tcase SOLO_DEV_6010:\n\t\t\tf->pixelformat = V4L2_PIX_FMT_MPEG4;\n\t\t\tbreak;\n\t\tcase SOLO_DEV_6110:\n\t\t\tf->pixelformat = V4L2_PIX_FMT_H264;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tf->pixelformat = V4L2_PIX_FMT_MJPEG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic inline int solo_valid_pixfmt(u32 pixfmt, int dev_type)\n{\n\treturn (pixfmt == V4L2_PIX_FMT_H264 && dev_type == SOLO_DEV_6110)\n\t\t|| (pixfmt == V4L2_PIX_FMT_MPEG4 && dev_type == SOLO_DEV_6010)\n\t\t|| pixfmt == V4L2_PIX_FMT_MJPEG ? 0 : -EINVAL;\n}\n\nstatic int solo_enc_try_fmt_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *f)\n{\n\tstruct solo_enc_dev *solo_enc = video_drvdata(file);\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\n\tif (solo_valid_pixfmt(pix->pixelformat, solo_dev->type))\n\t\treturn -EINVAL;\n\n\tif (pix->width < solo_dev->video_hsize ||\n\t    pix->height < solo_dev->video_vsize << 1) {\n\t\t \n\t\tpix->width = solo_dev->video_hsize >> 1;\n\t\tpix->height = solo_dev->video_vsize;\n\t} else {\n\t\t \n\t\tpix->width = solo_dev->video_hsize;\n\t\tpix->height = solo_dev->video_vsize << 1;\n\t}\n\n\tswitch (pix->field) {\n\tcase V4L2_FIELD_NONE:\n\tcase V4L2_FIELD_INTERLACED:\n\t\tbreak;\n\tcase V4L2_FIELD_ANY:\n\tdefault:\n\t\tpix->field = V4L2_FIELD_INTERLACED;\n\t\tbreak;\n\t}\n\n\t \n\tpix->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tpix->sizeimage = FRAME_BUF_SIZE;\n\tpix->bytesperline = 0;\n\n\treturn 0;\n}\n\nstatic int solo_enc_set_fmt_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct solo_enc_dev *solo_enc = video_drvdata(file);\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tint ret;\n\n\tif (vb2_is_busy(&solo_enc->vidq))\n\t\treturn -EBUSY;\n\n\tret = solo_enc_try_fmt_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pix->width == solo_dev->video_hsize)\n\t\tsolo_enc->mode = SOLO_ENC_MODE_D1;\n\telse\n\t\tsolo_enc->mode = SOLO_ENC_MODE_CIF;\n\n\t \n\tsolo_enc->fmt = pix->pixelformat;\n\n\t \n\tsolo_update_mode(solo_enc);\n\treturn 0;\n}\n\nstatic int solo_enc_get_fmt_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct solo_enc_dev *solo_enc = video_drvdata(file);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\n\tpix->width = solo_enc->width;\n\tpix->height = solo_enc->height;\n\tpix->pixelformat = solo_enc->fmt;\n\tpix->field = solo_enc->interlaced ? V4L2_FIELD_INTERLACED :\n\t\t     V4L2_FIELD_NONE;\n\tpix->sizeimage = FRAME_BUF_SIZE;\n\tpix->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\n\treturn 0;\n}\n\nstatic int solo_enc_g_std(struct file *file, void *priv, v4l2_std_id *i)\n{\n\tstruct solo_enc_dev *solo_enc = video_drvdata(file);\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\n\tif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC)\n\t\t*i = V4L2_STD_NTSC_M;\n\telse\n\t\t*i = V4L2_STD_PAL;\n\treturn 0;\n}\n\nstatic int solo_enc_s_std(struct file *file, void *priv, v4l2_std_id std)\n{\n\tstruct solo_enc_dev *solo_enc = video_drvdata(file);\n\n\treturn solo_set_video_type(solo_enc->solo_dev, std & V4L2_STD_625_50);\n}\n\nstatic int solo_enum_framesizes(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frmsizeenum *fsize)\n{\n\tstruct solo_enc_dev *solo_enc = video_drvdata(file);\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\n\tif (solo_valid_pixfmt(fsize->pixel_format, solo_dev->type))\n\t\treturn -EINVAL;\n\n\tswitch (fsize->index) {\n\tcase 0:\n\t\tfsize->discrete.width = solo_dev->video_hsize >> 1;\n\t\tfsize->discrete.height = solo_dev->video_vsize;\n\t\tbreak;\n\tcase 1:\n\t\tfsize->discrete.width = solo_dev->video_hsize;\n\t\tfsize->discrete.height = solo_dev->video_vsize << 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\n\treturn 0;\n}\n\nstatic int solo_enum_frameintervals(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_frmivalenum *fintv)\n{\n\tstruct solo_enc_dev *solo_enc = video_drvdata(file);\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\n\tif (solo_valid_pixfmt(fintv->pixel_format, solo_dev->type))\n\t\treturn -EINVAL;\n\tif (fintv->index)\n\t\treturn -EINVAL;\n\tif ((fintv->width != solo_dev->video_hsize >> 1 ||\n\t     fintv->height != solo_dev->video_vsize) &&\n\t    (fintv->width != solo_dev->video_hsize ||\n\t     fintv->height != solo_dev->video_vsize << 1))\n\t\treturn -EINVAL;\n\n\tfintv->type = V4L2_FRMIVAL_TYPE_STEPWISE;\n\n\tfintv->stepwise.min.numerator = 1;\n\tfintv->stepwise.min.denominator = solo_dev->fps;\n\n\tfintv->stepwise.max.numerator = 15;\n\tfintv->stepwise.max.denominator = solo_dev->fps;\n\n\tfintv->stepwise.step.numerator = 1;\n\tfintv->stepwise.step.denominator = solo_dev->fps;\n\n\treturn 0;\n}\n\nstatic int solo_g_parm(struct file *file, void *priv,\n\t\t       struct v4l2_streamparm *sp)\n{\n\tstruct solo_enc_dev *solo_enc = video_drvdata(file);\n\tstruct v4l2_captureparm *cp = &sp->parm.capture;\n\n\tcp->capability = V4L2_CAP_TIMEPERFRAME;\n\tcp->timeperframe.numerator = solo_enc->interval;\n\tcp->timeperframe.denominator = solo_enc->solo_dev->fps;\n\tcp->capturemode = 0;\n\t \n\tcp->readbuffers = 2;\n\n\treturn 0;\n}\n\nstatic inline int calc_interval(u8 fps, u32 n, u32 d)\n{\n\tif (!n || !d)\n\t\treturn 1;\n\tif (d == fps)\n\t\treturn n;\n\tn *= fps;\n\treturn min(15U, n / d + (n % d >= (fps >> 1)));\n}\n\nstatic int solo_s_parm(struct file *file, void *priv,\n\t\t       struct v4l2_streamparm *sp)\n{\n\tstruct solo_enc_dev *solo_enc = video_drvdata(file);\n\tstruct v4l2_fract *t = &sp->parm.capture.timeperframe;\n\tu8 fps = solo_enc->solo_dev->fps;\n\n\tif (vb2_is_streaming(&solo_enc->vidq))\n\t\treturn -EBUSY;\n\n\tsolo_enc->interval = calc_interval(fps, t->numerator, t->denominator);\n\tsolo_update_mode(solo_enc);\n\treturn solo_g_parm(file, priv, sp);\n}\n\nstatic int solo_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct solo_enc_dev *solo_enc =\n\t\tcontainer_of(ctrl->handler, struct solo_enc_dev, hdl);\n\tstruct solo_dev *solo_dev = solo_enc->solo_dev;\n\tint err;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\tcase V4L2_CID_CONTRAST:\n\tcase V4L2_CID_SATURATION:\n\tcase V4L2_CID_HUE:\n\tcase V4L2_CID_SHARPNESS:\n\t\treturn tw28_set_ctrl_val(solo_dev, ctrl->id, solo_enc->ch,\n\t\t\t\t\t ctrl->val);\n\tcase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\n\t\tsolo_enc->gop = ctrl->val;\n\t\tsolo_reg_write(solo_dev, SOLO_VE_CH_GOP(solo_enc->ch), solo_enc->gop);\n\t\tsolo_reg_write(solo_dev, SOLO_VE_CH_GOP_E(solo_enc->ch), solo_enc->gop);\n\t\treturn 0;\n\tcase V4L2_CID_MPEG_VIDEO_H264_MIN_QP:\n\t\tsolo_enc->qp = ctrl->val;\n\t\tsolo_reg_write(solo_dev, SOLO_VE_CH_QP(solo_enc->ch), solo_enc->qp);\n\t\tsolo_reg_write(solo_dev, SOLO_VE_CH_QP_E(solo_enc->ch), solo_enc->qp);\n\t\treturn 0;\n\tcase V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD:\n\t\tsolo_enc->motion_thresh = ctrl->val << 8;\n\t\tif (!solo_enc->motion_global || !solo_enc->motion_enabled)\n\t\t\treturn 0;\n\t\treturn solo_set_motion_threshold(solo_dev, solo_enc->ch,\n\t\t\t\tsolo_enc->motion_thresh);\n\tcase V4L2_CID_DETECT_MD_MODE:\n\t\tsolo_enc->motion_global = ctrl->val == V4L2_DETECT_MD_MODE_GLOBAL;\n\t\tsolo_enc->motion_enabled = ctrl->val > V4L2_DETECT_MD_MODE_DISABLED;\n\t\tif (ctrl->val) {\n\t\t\tif (solo_enc->motion_global)\n\t\t\t\terr = solo_set_motion_threshold(solo_dev, solo_enc->ch,\n\t\t\t\t\tsolo_enc->motion_thresh);\n\t\t\telse\n\t\t\t\terr = solo_set_motion_block(solo_dev, solo_enc->ch,\n\t\t\t\t\tsolo_enc->md_thresholds->p_cur.p_u16);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsolo_motion_toggle(solo_enc, ctrl->val);\n\t\treturn 0;\n\tcase V4L2_CID_DETECT_MD_THRESHOLD_GRID:\n\t\tif (solo_enc->motion_enabled && !solo_enc->motion_global)\n\t\t\treturn solo_set_motion_block(solo_dev, solo_enc->ch,\n\t\t\t\t\tsolo_enc->md_thresholds->p_new.p_u16);\n\t\tbreak;\n\tcase V4L2_CID_OSD_TEXT:\n\t\tstrscpy(solo_enc->osd_text, ctrl->p_new.p_char,\n\t\t\tsizeof(solo_enc->osd_text));\n\t\treturn solo_osd_print(solo_enc);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int solo_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\tconst struct v4l2_event_subscription *sub)\n{\n\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_MOTION_DET:\n\t\t \n\t\treturn v4l2_event_subscribe(fh, sub, 30, NULL);\n\tdefault:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\t}\n}\n\nstatic const struct v4l2_file_operations solo_enc_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= v4l2_fh_open,\n\t.release\t\t= vb2_fop_release,\n\t.read\t\t\t= vb2_fop_read,\n\t.poll\t\t\t= vb2_fop_poll,\n\t.mmap\t\t\t= vb2_fop_mmap,\n\t.unlocked_ioctl\t\t= video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops solo_enc_ioctl_ops = {\n\t.vidioc_querycap\t\t= solo_enc_querycap,\n\t.vidioc_s_std\t\t\t= solo_enc_s_std,\n\t.vidioc_g_std\t\t\t= solo_enc_g_std,\n\t \n\t.vidioc_enum_input\t\t= solo_enc_enum_input,\n\t.vidioc_s_input\t\t\t= solo_enc_set_input,\n\t.vidioc_g_input\t\t\t= solo_enc_get_input,\n\t \n\t.vidioc_enum_fmt_vid_cap\t= solo_enc_enum_fmt_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= solo_enc_try_fmt_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= solo_enc_set_fmt_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= solo_enc_get_fmt_cap,\n\t \n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\t \n\t.vidioc_enum_framesizes\t\t= solo_enum_framesizes,\n\t.vidioc_enum_frameintervals\t= solo_enum_frameintervals,\n\t \n\t.vidioc_s_parm\t\t\t= solo_s_parm,\n\t.vidioc_g_parm\t\t\t= solo_g_parm,\n\t \n\t.vidioc_log_status\t\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event\t\t= solo_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nstatic const struct video_device solo_enc_template = {\n\t.name\t\t\t= SOLO6X10_NAME,\n\t.fops\t\t\t= &solo_enc_fops,\n\t.ioctl_ops\t\t= &solo_enc_ioctl_ops,\n\t.minor\t\t\t= -1,\n\t.release\t\t= video_device_release,\n\t.tvnorms\t\t= V4L2_STD_NTSC_M | V4L2_STD_PAL,\n\t.device_caps\t\t= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t\t\t  V4L2_CAP_STREAMING,\n};\n\nstatic const struct v4l2_ctrl_ops solo_ctrl_ops = {\n\t.s_ctrl = solo_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config solo_osd_text_ctrl = {\n\t.ops = &solo_ctrl_ops,\n\t.id = V4L2_CID_OSD_TEXT,\n\t.name = \"OSD Text\",\n\t.type = V4L2_CTRL_TYPE_STRING,\n\t.max = OSD_TEXT_MAX,\n\t.step = 1,\n};\n\n \nstatic const struct v4l2_ctrl_config solo_md_thresholds = {\n\t.ops = &solo_ctrl_ops,\n\t.id = V4L2_CID_DETECT_MD_THRESHOLD_GRID,\n\t.dims = { SOLO_MOTION_SZ, SOLO_MOTION_SZ },\n\t.def = SOLO_DEF_MOT_THRESH,\n\t.max = 65535,\n\t.step = 1,\n};\n\nstatic struct solo_enc_dev *solo_enc_alloc(struct solo_dev *solo_dev,\n\t\t\t\t\t   u8 ch, unsigned nr)\n{\n\tstruct solo_enc_dev *solo_enc;\n\tstruct v4l2_ctrl_handler *hdl;\n\tint ret;\n\n\tsolo_enc = kzalloc(sizeof(*solo_enc), GFP_KERNEL);\n\tif (!solo_enc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thdl = &solo_enc->hdl;\n\tv4l2_ctrl_handler_init(hdl, 10);\n\tv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\n\t\t\tV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\n\t\t\tV4L2_CID_CONTRAST, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\n\t\t\tV4L2_CID_SATURATION, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\n\t\t\tV4L2_CID_HUE, 0, 255, 1, 128);\n\tif (tw28_has_sharpness(solo_dev, ch))\n\t\tv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\n\t\t\tV4L2_CID_SHARPNESS, 0, 15, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_GOP_SIZE, 1, 255, 1, solo_dev->fps);\n\tv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\n\t\t\tV4L2_CID_MPEG_VIDEO_H264_MIN_QP, 0, 31, 1, SOLO_DEFAULT_QP);\n\tv4l2_ctrl_new_std_menu(hdl, &solo_ctrl_ops,\n\t\t\tV4L2_CID_DETECT_MD_MODE,\n\t\t\tV4L2_DETECT_MD_MODE_THRESHOLD_GRID, 0,\n\t\t\tV4L2_DETECT_MD_MODE_DISABLED);\n\tv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\n\t\t\tV4L2_CID_DETECT_MD_GLOBAL_THRESHOLD, 0, 0xff, 1,\n\t\t\tSOLO_DEF_MOT_THRESH >> 8);\n\tv4l2_ctrl_new_custom(hdl, &solo_osd_text_ctrl, NULL);\n\tsolo_enc->md_thresholds =\n\t\tv4l2_ctrl_new_custom(hdl, &solo_md_thresholds, NULL);\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\t\tgoto hdl_free;\n\t}\n\n\tsolo_enc->solo_dev = solo_dev;\n\tsolo_enc->ch = ch;\n\tmutex_init(&solo_enc->lock);\n\tspin_lock_init(&solo_enc->av_lock);\n\tINIT_LIST_HEAD(&solo_enc->vidq_active);\n\tsolo_enc->fmt = (solo_dev->type == SOLO_DEV_6010) ?\n\t\tV4L2_PIX_FMT_MPEG4 : V4L2_PIX_FMT_H264;\n\tsolo_enc->type = SOLO_ENC_TYPE_STD;\n\n\tsolo_enc->qp = SOLO_DEFAULT_QP;\n\tsolo_enc->gop = solo_dev->fps;\n\tsolo_enc->interval = 1;\n\tsolo_enc->mode = SOLO_ENC_MODE_CIF;\n\tsolo_enc->motion_global = true;\n\tsolo_enc->motion_thresh = SOLO_DEF_MOT_THRESH;\n\tsolo_enc->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tsolo_enc->vidq.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\tsolo_enc->vidq.ops = &solo_enc_video_qops;\n\tsolo_enc->vidq.mem_ops = &vb2_dma_sg_memops;\n\tsolo_enc->vidq.drv_priv = solo_enc;\n\tsolo_enc->vidq.gfp_flags = __GFP_DMA32 | __GFP_KSWAPD_RECLAIM;\n\tsolo_enc->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tsolo_enc->vidq.buf_struct_size = sizeof(struct solo_vb2_buf);\n\tsolo_enc->vidq.lock = &solo_enc->lock;\n\tsolo_enc->vidq.dev = &solo_dev->pdev->dev;\n\tret = vb2_queue_init(&solo_enc->vidq);\n\tif (ret)\n\t\tgoto hdl_free;\n\tsolo_update_mode(solo_enc);\n\n\tspin_lock_init(&solo_enc->motion_lock);\n\n\t \n\tsolo_enc->jpeg_len = sizeof(jpeg_header);\n\tmemcpy(solo_enc->jpeg_header, jpeg_header, solo_enc->jpeg_len);\n\n\tsolo_enc->desc_nelts = 32;\n\tsolo_enc->desc_items = dma_alloc_coherent(&solo_dev->pdev->dev,\n\t\t\t\t\t\t  sizeof(struct solo_p2m_desc) *\n\t\t\t\t\t\t  solo_enc->desc_nelts,\n\t\t\t\t\t\t  &solo_enc->desc_dma,\n\t\t\t\t\t\t  GFP_KERNEL);\n\tret = -ENOMEM;\n\tif (solo_enc->desc_items == NULL)\n\t\tgoto hdl_free;\n\n\tsolo_enc->vfd = video_device_alloc();\n\tif (!solo_enc->vfd)\n\t\tgoto pci_free;\n\n\t*solo_enc->vfd = solo_enc_template;\n\tsolo_enc->vfd->v4l2_dev = &solo_dev->v4l2_dev;\n\tsolo_enc->vfd->ctrl_handler = hdl;\n\tsolo_enc->vfd->queue = &solo_enc->vidq;\n\tsolo_enc->vfd->lock = &solo_enc->lock;\n\tvideo_set_drvdata(solo_enc->vfd, solo_enc);\n\tret = video_register_device(solo_enc->vfd, VFL_TYPE_VIDEO, nr);\n\tif (ret < 0)\n\t\tgoto vdev_release;\n\n\tsnprintf(solo_enc->vfd->name, sizeof(solo_enc->vfd->name),\n\t\t \"%s-enc (%i/%i)\", SOLO6X10_NAME, solo_dev->vfd->num,\n\t\t solo_enc->vfd->num);\n\n\treturn solo_enc;\n\nvdev_release:\n\tvideo_device_release(solo_enc->vfd);\npci_free:\n\tdma_free_coherent(&solo_enc->solo_dev->pdev->dev,\n\t\t\t  sizeof(struct solo_p2m_desc) * solo_enc->desc_nelts,\n\t\t\t  solo_enc->desc_items, solo_enc->desc_dma);\nhdl_free:\n\tv4l2_ctrl_handler_free(hdl);\n\tkfree(solo_enc);\n\treturn ERR_PTR(ret);\n}\n\nstatic void solo_enc_free(struct solo_enc_dev *solo_enc)\n{\n\tif (solo_enc == NULL)\n\t\treturn;\n\n\tdma_free_coherent(&solo_enc->solo_dev->pdev->dev,\n\t\t\t  sizeof(struct solo_p2m_desc) * solo_enc->desc_nelts,\n\t\t\t  solo_enc->desc_items, solo_enc->desc_dma);\n\tvideo_unregister_device(solo_enc->vfd);\n\tv4l2_ctrl_handler_free(&solo_enc->hdl);\n\tkfree(solo_enc);\n}\n\nint solo_enc_v4l2_init(struct solo_dev *solo_dev, unsigned nr)\n{\n\tint i;\n\n\tinit_waitqueue_head(&solo_dev->ring_thread_wait);\n\n\tsolo_dev->vh_size = sizeof(vop_header);\n\tsolo_dev->vh_buf = dma_alloc_coherent(&solo_dev->pdev->dev,\n\t\t\t\t\t      solo_dev->vh_size,\n\t\t\t\t\t      &solo_dev->vh_dma, GFP_KERNEL);\n\tif (solo_dev->vh_buf == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < solo_dev->nr_chans; i++) {\n\t\tsolo_dev->v4l2_enc[i] = solo_enc_alloc(solo_dev, i, nr);\n\t\tif (IS_ERR(solo_dev->v4l2_enc[i]))\n\t\t\tbreak;\n\t}\n\n\tif (i != solo_dev->nr_chans) {\n\t\tint ret = PTR_ERR(solo_dev->v4l2_enc[i]);\n\n\t\twhile (i--)\n\t\t\tsolo_enc_free(solo_dev->v4l2_enc[i]);\n\t\tdma_free_coherent(&solo_dev->pdev->dev, solo_dev->vh_size,\n\t\t\t\t  solo_dev->vh_buf, solo_dev->vh_dma);\n\t\tsolo_dev->vh_buf = NULL;\n\t\treturn ret;\n\t}\n\n\tif (solo_dev->type == SOLO_DEV_6010)\n\t\tsolo_dev->enc_bw_remain = solo_dev->fps * 4 * 4;\n\telse\n\t\tsolo_dev->enc_bw_remain = solo_dev->fps * 4 * 5;\n\n\tdev_info(&solo_dev->pdev->dev, \"Encoders as /dev/video%d-%d\\n\",\n\t\t solo_dev->v4l2_enc[0]->vfd->num,\n\t\t solo_dev->v4l2_enc[solo_dev->nr_chans - 1]->vfd->num);\n\n\treturn solo_ring_start(solo_dev);\n}\n\nvoid solo_enc_v4l2_exit(struct solo_dev *solo_dev)\n{\n\tint i;\n\n\tsolo_ring_stop(solo_dev);\n\n\tfor (i = 0; i < solo_dev->nr_chans; i++)\n\t\tsolo_enc_free(solo_dev->v4l2_enc[i]);\n\n\tif (solo_dev->vh_buf)\n\t\tdma_free_coherent(&solo_dev->pdev->dev, solo_dev->vh_size,\n\t\t\t\t  solo_dev->vh_buf, solo_dev->vh_dma);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}