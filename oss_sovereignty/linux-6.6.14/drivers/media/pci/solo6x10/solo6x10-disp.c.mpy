{
  "module_name": "solo6x10-disp.c",
  "hash_id": "c7c8e4305b75bfc8b270565f1d2f733fdcd96c8d98b3e806c2e4a09ee359b06c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/solo6x10/solo6x10-disp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"solo6x10.h\"\n\n#define SOLO_VCLK_DELAY\t\t\t3\n#define SOLO_PROGRESSIVE_VSIZE\t\t1024\n\n#define SOLO_MOT_THRESH_W\t\t64\n#define SOLO_MOT_THRESH_H\t\t64\n#define SOLO_MOT_THRESH_SIZE\t\t8192\n#define SOLO_MOT_THRESH_REAL\t\t(SOLO_MOT_THRESH_W * SOLO_MOT_THRESH_H)\n#define SOLO_MOT_FLAG_SIZE\t\t1024\n#define SOLO_MOT_FLAG_AREA\t\t(SOLO_MOT_FLAG_SIZE * 16)\n\nstatic void solo_vin_config(struct solo_dev *solo_dev)\n{\n\tsolo_dev->vin_hstart = 8;\n\tsolo_dev->vin_vstart = 2;\n\n\tsolo_reg_write(solo_dev, SOLO_SYS_VCLK,\n\t\t       SOLO_VCLK_SELECT(2) |\n\t\t       SOLO_VCLK_VIN1415_DELAY(SOLO_VCLK_DELAY) |\n\t\t       SOLO_VCLK_VIN1213_DELAY(SOLO_VCLK_DELAY) |\n\t\t       SOLO_VCLK_VIN1011_DELAY(SOLO_VCLK_DELAY) |\n\t\t       SOLO_VCLK_VIN0809_DELAY(SOLO_VCLK_DELAY) |\n\t\t       SOLO_VCLK_VIN0607_DELAY(SOLO_VCLK_DELAY) |\n\t\t       SOLO_VCLK_VIN0405_DELAY(SOLO_VCLK_DELAY) |\n\t\t       SOLO_VCLK_VIN0203_DELAY(SOLO_VCLK_DELAY) |\n\t\t       SOLO_VCLK_VIN0001_DELAY(SOLO_VCLK_DELAY));\n\n\tsolo_reg_write(solo_dev, SOLO_VI_ACT_I_P,\n\t\t       SOLO_VI_H_START(solo_dev->vin_hstart) |\n\t\t       SOLO_VI_V_START(solo_dev->vin_vstart) |\n\t\t       SOLO_VI_V_STOP(solo_dev->vin_vstart +\n\t\t\t\t      solo_dev->video_vsize));\n\n\tsolo_reg_write(solo_dev, SOLO_VI_ACT_I_S,\n\t\t       SOLO_VI_H_START(solo_dev->vout_hstart) |\n\t\t       SOLO_VI_V_START(solo_dev->vout_vstart) |\n\t\t       SOLO_VI_V_STOP(solo_dev->vout_vstart +\n\t\t\t\t      solo_dev->video_vsize));\n\n\tsolo_reg_write(solo_dev, SOLO_VI_ACT_P,\n\t\t       SOLO_VI_H_START(0) |\n\t\t       SOLO_VI_V_START(1) |\n\t\t       SOLO_VI_V_STOP(SOLO_PROGRESSIVE_VSIZE));\n\n\tsolo_reg_write(solo_dev, SOLO_VI_CH_FORMAT,\n\t\t       SOLO_VI_FD_SEL_MASK(0) | SOLO_VI_PROG_MASK(0));\n\n\t \n\tif (solo_dev->type == SOLO_DEV_6010)\n\t\tsolo_reg_write(solo_dev, SOLO_VI_FMT_CFG, 0);\n\telse\n\t\tsolo_reg_write(solo_dev, SOLO_VI_FMT_CFG, 16 << 22);\n\n\tsolo_reg_write(solo_dev, SOLO_VI_PAGE_SW, 2);\n\n\tif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC) {\n\t\tsolo_reg_write(solo_dev, SOLO_VI_PB_CONFIG,\n\t\t\t       SOLO_VI_PB_USER_MODE);\n\t\tsolo_reg_write(solo_dev, SOLO_VI_PB_RANGE_HV,\n\t\t\t       SOLO_VI_PB_HSIZE(858) | SOLO_VI_PB_VSIZE(246));\n\t\tsolo_reg_write(solo_dev, SOLO_VI_PB_ACT_V,\n\t\t\t       SOLO_VI_PB_VSTART(4) |\n\t\t\t       SOLO_VI_PB_VSTOP(4 + 240));\n\t} else {\n\t\tsolo_reg_write(solo_dev, SOLO_VI_PB_CONFIG,\n\t\t\t       SOLO_VI_PB_USER_MODE | SOLO_VI_PB_PAL);\n\t\tsolo_reg_write(solo_dev, SOLO_VI_PB_RANGE_HV,\n\t\t\t       SOLO_VI_PB_HSIZE(864) | SOLO_VI_PB_VSIZE(294));\n\t\tsolo_reg_write(solo_dev, SOLO_VI_PB_ACT_V,\n\t\t\t       SOLO_VI_PB_VSTART(4) |\n\t\t\t       SOLO_VI_PB_VSTOP(4 + 288));\n\t}\n\tsolo_reg_write(solo_dev, SOLO_VI_PB_ACT_H, SOLO_VI_PB_HSTART(16) |\n\t\t       SOLO_VI_PB_HSTOP(16 + 720));\n}\n\nstatic void solo_vout_config_cursor(struct solo_dev *dev)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 20; i++)\n\t\tsolo_reg_write(dev, SOLO_VO_CURSOR_MASK(i), 0);\n\n\tsolo_reg_write(dev, SOLO_VO_CURSOR_POS, 0);\n\n\tsolo_reg_write(dev, SOLO_VO_CURSOR_CLR,\n\t\t       (0x80 << 24) | (0x80 << 16) | (0x10 << 8) | 0x80);\n\tsolo_reg_write(dev, SOLO_VO_CURSOR_CLR2, (0xe0 << 8) | 0x80);\n}\n\nstatic void solo_vout_config(struct solo_dev *solo_dev)\n{\n\tsolo_dev->vout_hstart = 6;\n\tsolo_dev->vout_vstart = 8;\n\n\tsolo_reg_write(solo_dev, SOLO_VO_FMT_ENC,\n\t\t       solo_dev->video_type |\n\t\t       SOLO_VO_USER_COLOR_SET_NAV |\n\t\t       SOLO_VO_USER_COLOR_SET_NAH |\n\t\t       SOLO_VO_NA_COLOR_Y(0) |\n\t\t       SOLO_VO_NA_COLOR_CB(0) |\n\t\t       SOLO_VO_NA_COLOR_CR(0));\n\n\tsolo_reg_write(solo_dev, SOLO_VO_ACT_H,\n\t\t       SOLO_VO_H_START(solo_dev->vout_hstart) |\n\t\t       SOLO_VO_H_STOP(solo_dev->vout_hstart +\n\t\t\t\t      solo_dev->video_hsize));\n\n\tsolo_reg_write(solo_dev, SOLO_VO_ACT_V,\n\t\t       SOLO_VO_V_START(solo_dev->vout_vstart) |\n\t\t       SOLO_VO_V_STOP(solo_dev->vout_vstart +\n\t\t\t\t      solo_dev->video_vsize));\n\n\tsolo_reg_write(solo_dev, SOLO_VO_RANGE_HV,\n\t\t       SOLO_VO_H_LEN(solo_dev->video_hsize) |\n\t\t       SOLO_VO_V_LEN(solo_dev->video_vsize));\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_VO_BORDER_LINE_COLOR,\n\t\t       (0xa0 << 24) | (0x88 << 16) | (0xa0 << 8) | 0x88);\n\tsolo_reg_write(solo_dev, SOLO_VO_BORDER_FILL_COLOR,\n\t\t       (0x10 << 24) | (0x8f << 16) | (0x10 << 8) | 0x8f);\n\tsolo_reg_write(solo_dev, SOLO_VO_BKG_COLOR,\n\t\t       (16 << 24) | (128 << 16) | (16 << 8) | 128);\n\n\tsolo_reg_write(solo_dev, SOLO_VO_DISP_ERASE, SOLO_VO_DISP_ERASE_ON);\n\n\tsolo_reg_write(solo_dev, SOLO_VI_WIN_SW, 0);\n\n\tsolo_reg_write(solo_dev, SOLO_VO_ZOOM_CTRL, 0);\n\tsolo_reg_write(solo_dev, SOLO_VO_FREEZE_CTRL, 0);\n\n\tsolo_reg_write(solo_dev, SOLO_VO_DISP_CTRL, SOLO_VO_DISP_ON |\n\t\t       SOLO_VO_DISP_ERASE_COUNT(8) |\n\t\t       SOLO_VO_DISP_BASE(SOLO_DISP_EXT_ADDR));\n\n\n\tsolo_vout_config_cursor(solo_dev);\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_VI_CH_ENA,\n\t\t       (1 << solo_dev->nr_chans) - 1);\n}\n\nstatic int solo_dma_vin_region(struct solo_dev *solo_dev, u32 off,\n\t\t\t       u16 val, int reg_size)\n{\n\t__le16 *buf;\n\tconst int n = 64, size = n * sizeof(*buf);\n\tint i, ret = 0;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < n; i++)\n\t\tbuf[i] = cpu_to_le16(val);\n\n\tfor (i = 0; i < reg_size; i += size) {\n\t\tret = solo_p2m_dma(solo_dev, 1, buf,\n\t\t\t\t   SOLO_MOTION_EXT_ADDR(solo_dev) + off + i,\n\t\t\t\t   size, 0, 0);\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tkfree(buf);\n\treturn ret;\n}\n\nint solo_set_motion_threshold(struct solo_dev *solo_dev, u8 ch, u16 val)\n{\n\tif (ch > solo_dev->nr_chans)\n\t\treturn -EINVAL;\n\n\treturn solo_dma_vin_region(solo_dev, SOLO_MOT_FLAG_AREA +\n\t\t\t\t   (ch * SOLO_MOT_THRESH_SIZE * 2),\n\t\t\t\t   val, SOLO_MOT_THRESH_SIZE);\n}\n\nint solo_set_motion_block(struct solo_dev *solo_dev, u8 ch,\n\t\tconst u16 *thresholds)\n{\n\tconst unsigned size = sizeof(u16) * 64;\n\tu32 off = SOLO_MOT_FLAG_AREA + ch * SOLO_MOT_THRESH_SIZE * 2;\n\t__le16 *buf;\n\tint x, y;\n\tint ret = 0;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\tfor (y = 0; y < SOLO_MOTION_SZ; y++) {\n\t\tfor (x = 0; x < SOLO_MOTION_SZ; x++)\n\t\t\tbuf[x] = cpu_to_le16(thresholds[y * SOLO_MOTION_SZ + x]);\n\t\tret |= solo_p2m_dma(solo_dev, 1, buf,\n\t\t\tSOLO_MOTION_EXT_ADDR(solo_dev) + off + y * size,\n\t\t\tsize, 0, 0);\n\t}\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic void solo_motion_config(struct solo_dev *solo_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < solo_dev->nr_chans; i++) {\n\t\t \n\t\tsolo_dma_vin_region(solo_dev, i * SOLO_MOT_FLAG_SIZE, 0x0000,\n\t\t\t\t    SOLO_MOT_FLAG_SIZE);\n\n\t\t \n\t\tsolo_dma_vin_region(solo_dev, SOLO_MOT_FLAG_AREA +\n\t\t\t\t    (i * SOLO_MOT_THRESH_SIZE * 2) +\n\t\t\t\t    SOLO_MOT_THRESH_SIZE, 0x0000,\n\t\t\t\t    SOLO_MOT_THRESH_SIZE);\n\n\t\t \n\t\tsolo_set_motion_threshold(solo_dev, i, SOLO_DEF_MOT_THRESH);\n\t}\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_VI_MOT_ADR, SOLO_VI_MOTION_EN(0) |\n\t\t       (SOLO_MOTION_EXT_ADDR(solo_dev) >> 16));\n\tsolo_reg_write(solo_dev, SOLO_VI_MOT_CTRL,\n\t\t       SOLO_VI_MOTION_FRAME_COUNT(3) |\n\t\t       SOLO_VI_MOTION_SAMPLE_LENGTH(solo_dev->video_hsize / 16)\n\t\t        \n\t\t       | SOLO_VI_MOTION_SAMPLE_COUNT(10));\n\n\tsolo_reg_write(solo_dev, SOLO_VI_MOTION_BORDER, 0);\n\tsolo_reg_write(solo_dev, SOLO_VI_MOTION_BAR, 0);\n}\n\nint solo_disp_init(struct solo_dev *solo_dev)\n{\n\tint i;\n\n\tsolo_dev->video_hsize = 704;\n\tif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC) {\n\t\tsolo_dev->video_vsize = 240;\n\t\tsolo_dev->fps = 30;\n\t} else {\n\t\tsolo_dev->video_vsize = 288;\n\t\tsolo_dev->fps = 25;\n\t}\n\n\tsolo_vin_config(solo_dev);\n\tsolo_motion_config(solo_dev);\n\tsolo_vout_config(solo_dev);\n\n\tfor (i = 0; i < solo_dev->nr_chans; i++)\n\t\tsolo_reg_write(solo_dev, SOLO_VI_WIN_ON(i), 1);\n\n\treturn 0;\n}\n\nvoid solo_disp_exit(struct solo_dev *solo_dev)\n{\n\tint i;\n\n\tsolo_reg_write(solo_dev, SOLO_VO_DISP_CTRL, 0);\n\tsolo_reg_write(solo_dev, SOLO_VO_ZOOM_CTRL, 0);\n\tsolo_reg_write(solo_dev, SOLO_VO_FREEZE_CTRL, 0);\n\n\tfor (i = 0; i < solo_dev->nr_chans; i++) {\n\t\tsolo_reg_write(solo_dev, SOLO_VI_WIN_CTRL0(i), 0);\n\t\tsolo_reg_write(solo_dev, SOLO_VI_WIN_CTRL1(i), 0);\n\t\tsolo_reg_write(solo_dev, SOLO_VI_WIN_ON(i), 0);\n\t}\n\n\t \n\tfor (i = 0; i < 5; i++)\n\t\tsolo_reg_write(solo_dev, SOLO_VO_BORDER_X(i), 0);\n\n\tfor (i = 0; i < 5; i++)\n\t\tsolo_reg_write(solo_dev, SOLO_VO_BORDER_Y(i), 0);\n\n\tsolo_reg_write(solo_dev, SOLO_VO_BORDER_LINE_MASK, 0);\n\tsolo_reg_write(solo_dev, SOLO_VO_BORDER_FILL_MASK, 0);\n\n\tsolo_reg_write(solo_dev, SOLO_VO_RECTANGLE_CTRL(0), 0);\n\tsolo_reg_write(solo_dev, SOLO_VO_RECTANGLE_START(0), 0);\n\tsolo_reg_write(solo_dev, SOLO_VO_RECTANGLE_STOP(0), 0);\n\n\tsolo_reg_write(solo_dev, SOLO_VO_RECTANGLE_CTRL(1), 0);\n\tsolo_reg_write(solo_dev, SOLO_VO_RECTANGLE_START(1), 0);\n\tsolo_reg_write(solo_dev, SOLO_VO_RECTANGLE_STOP(1), 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}