{
  "module_name": "solo6x10-p2m.c",
  "hash_id": "07894dda63b79af96b86030be14c0360c70c1605ff3bcda10a780fae4fa07ba0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/solo6x10/solo6x10-p2m.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"solo6x10.h\"\n\nstatic int multi_p2m;\nmodule_param(multi_p2m, uint, 0644);\nMODULE_PARM_DESC(multi_p2m,\n\t\t \"Use multiple P2M DMA channels (default: no, 6010-only)\");\n\nstatic int desc_mode;\nmodule_param(desc_mode, uint, 0644);\nMODULE_PARM_DESC(desc_mode,\n\t\t \"Allow use of descriptor mode DMA (default: no, 6010-only)\");\n\nint solo_p2m_dma(struct solo_dev *solo_dev, int wr,\n\t\t void *sys_addr, u32 ext_addr, u32 size,\n\t\t int repeat, u32 ext_size)\n{\n\tdma_addr_t dma_addr;\n\tint ret;\n\n\tif (WARN_ON_ONCE((unsigned long)sys_addr & 0x03))\n\t\treturn -EINVAL;\n\tif (WARN_ON_ONCE(!size))\n\t\treturn -EINVAL;\n\n\tdma_addr = dma_map_single(&solo_dev->pdev->dev, sys_addr, size,\n\t\t\t\t  wr ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&solo_dev->pdev->dev, dma_addr))\n\t\treturn -ENOMEM;\n\n\tret = solo_p2m_dma_t(solo_dev, wr, dma_addr, ext_addr, size,\n\t\t\t     repeat, ext_size);\n\n\tdma_unmap_single(&solo_dev->pdev->dev, dma_addr, size,\n\t\t\t wr ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\n\treturn ret;\n}\n\n \nint solo_p2m_dma_desc(struct solo_dev *solo_dev,\n\t\t      struct solo_p2m_desc *desc, dma_addr_t desc_dma,\n\t\t      int desc_cnt)\n{\n\tstruct solo_p2m_dev *p2m_dev;\n\tunsigned int timeout;\n\tunsigned int config = 0;\n\tint ret = 0;\n\tunsigned int p2m_id = 0;\n\n\t \n\tif (solo_dev->type != SOLO_DEV_6110 && multi_p2m)\n\t\tp2m_id = atomic_inc_return(&solo_dev->p2m_count) % SOLO_NR_P2M;\n\n\tp2m_dev = &solo_dev->p2m_dev[p2m_id];\n\n\tif (mutex_lock_interruptible(&p2m_dev->mutex))\n\t\treturn -EINTR;\n\n\treinit_completion(&p2m_dev->completion);\n\tp2m_dev->error = 0;\n\n\tif (desc_cnt > 1 && solo_dev->type != SOLO_DEV_6110 && desc_mode) {\n\t\t \n\t\tp2m_dev->desc_count = p2m_dev->desc_idx = 0;\n\t\tconfig = solo_reg_read(solo_dev, SOLO_P2M_CONFIG(p2m_id));\n\n\t\tsolo_reg_write(solo_dev, SOLO_P2M_DES_ADR(p2m_id), desc_dma);\n\t\tsolo_reg_write(solo_dev, SOLO_P2M_DESC_ID(p2m_id), desc_cnt);\n\t\tsolo_reg_write(solo_dev, SOLO_P2M_CONFIG(p2m_id), config |\n\t\t\t       SOLO_P2M_DESC_MODE);\n\t} else {\n\t\t \n\t\tp2m_dev->desc_count = desc_cnt;\n\t\tp2m_dev->desc_idx = 1;\n\t\tp2m_dev->descs = desc;\n\n\t\tsolo_reg_write(solo_dev, SOLO_P2M_TAR_ADR(p2m_id),\n\t\t\t       desc[1].dma_addr);\n\t\tsolo_reg_write(solo_dev, SOLO_P2M_EXT_ADR(p2m_id),\n\t\t\t       desc[1].ext_addr);\n\t\tsolo_reg_write(solo_dev, SOLO_P2M_EXT_CFG(p2m_id),\n\t\t\t       desc[1].cfg);\n\t\tsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(p2m_id),\n\t\t\t       desc[1].ctrl);\n\t}\n\n\ttimeout = wait_for_completion_timeout(&p2m_dev->completion,\n\t\t\t\t\t      solo_dev->p2m_jiffies);\n\n\tif (WARN_ON_ONCE(p2m_dev->error))\n\t\tret = -EIO;\n\telse if (timeout == 0) {\n\t\tsolo_dev->p2m_timeouts++;\n\t\tret = -EAGAIN;\n\t}\n\n\tsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(p2m_id), 0);\n\n\t \n\tif (desc_cnt > 1 && solo_dev->type != SOLO_DEV_6110 && config)\n\t\tsolo_reg_write(solo_dev, SOLO_P2M_CONFIG(p2m_id), config);\n\n\tmutex_unlock(&p2m_dev->mutex);\n\n\treturn ret;\n}\n\nvoid solo_p2m_fill_desc(struct solo_p2m_desc *desc, int wr,\n\t\t\tdma_addr_t dma_addr, u32 ext_addr, u32 size,\n\t\t\tint repeat, u32 ext_size)\n{\n\tWARN_ON_ONCE(dma_addr & 0x03);\n\tWARN_ON_ONCE(!size);\n\n\tdesc->cfg = SOLO_P2M_COPY_SIZE(size >> 2);\n\tdesc->ctrl = SOLO_P2M_BURST_SIZE(SOLO_P2M_BURST_256) |\n\t\t(wr ? SOLO_P2M_WRITE : 0) | SOLO_P2M_TRANS_ON;\n\n\tif (repeat) {\n\t\tdesc->cfg |= SOLO_P2M_EXT_INC(ext_size >> 2);\n\t\tdesc->ctrl |=  SOLO_P2M_PCI_INC(size >> 2) |\n\t\t\t SOLO_P2M_REPEAT(repeat);\n\t}\n\n\tdesc->dma_addr = dma_addr;\n\tdesc->ext_addr = ext_addr;\n}\n\nint solo_p2m_dma_t(struct solo_dev *solo_dev, int wr,\n\t\t   dma_addr_t dma_addr, u32 ext_addr, u32 size,\n\t\t   int repeat, u32 ext_size)\n{\n\tstruct solo_p2m_desc desc[2];\n\n\tsolo_p2m_fill_desc(&desc[1], wr, dma_addr, ext_addr, size, repeat,\n\t\t\t   ext_size);\n\n\t \n\treturn solo_p2m_dma_desc(solo_dev, desc, 0, 1);\n}\n\nvoid solo_p2m_isr(struct solo_dev *solo_dev, int id)\n{\n\tstruct solo_p2m_dev *p2m_dev = &solo_dev->p2m_dev[id];\n\tstruct solo_p2m_desc *desc;\n\n\tif (p2m_dev->desc_count <= p2m_dev->desc_idx) {\n\t\tcomplete(&p2m_dev->completion);\n\t\treturn;\n\t}\n\n\t \n\tp2m_dev->desc_idx++;\n\tdesc = &p2m_dev->descs[p2m_dev->desc_idx];\n\n\tsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(id), 0);\n\tsolo_reg_write(solo_dev, SOLO_P2M_TAR_ADR(id), desc->dma_addr);\n\tsolo_reg_write(solo_dev, SOLO_P2M_EXT_ADR(id), desc->ext_addr);\n\tsolo_reg_write(solo_dev, SOLO_P2M_EXT_CFG(id), desc->cfg);\n\tsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(id), desc->ctrl);\n}\n\nvoid solo_p2m_error_isr(struct solo_dev *solo_dev)\n{\n\tunsigned int err = solo_reg_read(solo_dev, SOLO_PCI_ERR);\n\tstruct solo_p2m_dev *p2m_dev;\n\tint i;\n\n\tif (!(err & (SOLO_PCI_ERR_P2M | SOLO_PCI_ERR_P2M_DESC)))\n\t\treturn;\n\n\tfor (i = 0; i < SOLO_NR_P2M; i++) {\n\t\tp2m_dev = &solo_dev->p2m_dev[i];\n\t\tp2m_dev->error = 1;\n\t\tsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(i), 0);\n\t\tcomplete(&p2m_dev->completion);\n\t}\n}\n\nvoid solo_p2m_exit(struct solo_dev *solo_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < SOLO_NR_P2M; i++)\n\t\tsolo_irq_off(solo_dev, SOLO_IRQ_P2M(i));\n}\n\nstatic int solo_p2m_test(struct solo_dev *solo_dev, int base, int size)\n{\n\tu32 *wr_buf;\n\tu32 *rd_buf;\n\tint i;\n\tint ret = -EIO;\n\tint order = get_order(size);\n\n\twr_buf = (u32 *)__get_free_pages(GFP_KERNEL, order);\n\tif (wr_buf == NULL)\n\t\treturn -1;\n\n\trd_buf = (u32 *)__get_free_pages(GFP_KERNEL, order);\n\tif (rd_buf == NULL) {\n\t\tfree_pages((unsigned long)wr_buf, order);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < (size >> 3); i++)\n\t\t*(wr_buf + i) = (i << 16) | (i + 1);\n\n\tfor (i = (size >> 3); i < (size >> 2); i++)\n\t\t*(wr_buf + i) = ~((i << 16) | (i + 1));\n\n\tmemset(rd_buf, 0x55, size);\n\n\tif (solo_p2m_dma(solo_dev, 1, wr_buf, base, size, 0, 0))\n\t\tgoto test_fail;\n\n\tif (solo_p2m_dma(solo_dev, 0, rd_buf, base, size, 0, 0))\n\t\tgoto test_fail;\n\n\tfor (i = 0; i < (size >> 2); i++) {\n\t\tif (*(wr_buf + i) != *(rd_buf + i))\n\t\t\tgoto test_fail;\n\t}\n\n\tret = 0;\n\ntest_fail:\n\tfree_pages((unsigned long)wr_buf, order);\n\tfree_pages((unsigned long)rd_buf, order);\n\n\treturn ret;\n}\n\nint solo_p2m_init(struct solo_dev *solo_dev)\n{\n\tstruct solo_p2m_dev *p2m_dev;\n\tint i;\n\n\tfor (i = 0; i < SOLO_NR_P2M; i++) {\n\t\tp2m_dev = &solo_dev->p2m_dev[i];\n\n\t\tmutex_init(&p2m_dev->mutex);\n\t\tinit_completion(&p2m_dev->completion);\n\n\t\tsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(i), 0);\n\t\tsolo_reg_write(solo_dev, SOLO_P2M_CONFIG(i),\n\t\t\t       SOLO_P2M_CSC_16BIT_565 |\n\t\t\t       SOLO_P2M_DESC_INTR_OPT |\n\t\t\t       SOLO_P2M_DMA_INTERVAL(0) |\n\t\t\t       SOLO_P2M_PCI_MASTER_MODE);\n\t\tsolo_irq_on(solo_dev, SOLO_IRQ_P2M(i));\n\t}\n\n\t \n\tfor (solo_dev->sdram_size = 0, i = 2; i >= 0; i--) {\n\t\tsolo_reg_write(solo_dev, SOLO_DMA_CTRL,\n\t\t\t       SOLO_DMA_CTRL_REFRESH_CYCLE(1) |\n\t\t\t       SOLO_DMA_CTRL_SDRAM_SIZE(i) |\n\t\t\t       SOLO_DMA_CTRL_SDRAM_CLK_INVERT |\n\t\t\t       SOLO_DMA_CTRL_READ_CLK_SELECT |\n\t\t\t       SOLO_DMA_CTRL_LATENCY(1));\n\n\t\tsolo_reg_write(solo_dev, SOLO_SYS_CFG, solo_dev->sys_config |\n\t\t\t       SOLO_SYS_CFG_RESET);\n\t\tsolo_reg_write(solo_dev, SOLO_SYS_CFG, solo_dev->sys_config);\n\n\t\tswitch (i) {\n\t\tcase 2:\n\t\t\tif (solo_p2m_test(solo_dev, 0x07ff0000, 0x00010000) ||\n\t\t\t    solo_p2m_test(solo_dev, 0x05ff0000, 0x00010000))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif (solo_p2m_test(solo_dev, 0x03ff0000, 0x00010000))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (solo_p2m_test(solo_dev, 0x01ff0000, 0x00010000))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tsolo_dev->sdram_size = (32 << 20) << i;\n\t\tbreak;\n\t}\n\n\tif (!solo_dev->sdram_size) {\n\t\tdev_err(&solo_dev->pdev->dev, \"Error detecting SDRAM size\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (SOLO_SDRAM_END(solo_dev) > solo_dev->sdram_size) {\n\t\tdev_err(&solo_dev->pdev->dev,\n\t\t\t\"SDRAM is not large enough (%u < %u)\\n\",\n\t\t\tsolo_dev->sdram_size, SOLO_SDRAM_END(solo_dev));\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}