{
  "module_name": "solo6x10-eeprom.c",
  "hash_id": "1345294782120a6580eee089960a11f3023d5cb869bf8c5b06810477e28525d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/solo6x10/solo6x10-eeprom.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n\n#include \"solo6x10.h\"\n\n \n#define EE_SHIFT_CLK\t0x04\n#define EE_CS\t\t0x08\n#define EE_DATA_WRITE\t0x02\n#define EE_DATA_READ\t0x01\n#define EE_ENB\t\t(0x80 | EE_CS)\n\n#define eeprom_delay()\tudelay(100)\n#if 0\n#define eeprom_delay()\tsolo_reg_read(solo_dev, SOLO_EEPROM_CTRL)\n#define eeprom_delay()\t({\t\t\t\t\\\n\tint i, ret;\t\t\t\t\t\\\n\tudelay(100);\t\t\t\t\t\\\n\tfor (i = ret = 0; i < 1000 && !ret; i++)\t\\\n\t\tret = solo_eeprom_reg_read(solo_dev);\t\\\n})\n#endif\n#define ADDR_LEN\t6\n\n \n#define EE_EWEN_CMD\t4\n#define EE_EWDS_CMD\t4\n#define EE_WRITE_CMD\t5\n#define EE_READ_CMD\t6\n#define EE_ERASE_CMD\t7\n\nstatic unsigned int solo_eeprom_reg_read(struct solo_dev *solo_dev)\n{\n\treturn solo_reg_read(solo_dev, SOLO_EEPROM_CTRL) & EE_DATA_READ;\n}\n\nstatic void solo_eeprom_reg_write(struct solo_dev *solo_dev, u32 data)\n{\n\tsolo_reg_write(solo_dev, SOLO_EEPROM_CTRL, data);\n\teeprom_delay();\n}\n\nstatic void solo_eeprom_cmd(struct solo_dev *solo_dev, int cmd)\n{\n\tint i;\n\n\tsolo_eeprom_reg_write(solo_dev, SOLO_EEPROM_ACCESS_EN);\n\tsolo_eeprom_reg_write(solo_dev, SOLO_EEPROM_ENABLE);\n\n\tfor (i = 4 + ADDR_LEN; i >= 0; i--) {\n\t\tint dataval = (cmd & (1 << i)) ? EE_DATA_WRITE : 0;\n\n\t\tsolo_eeprom_reg_write(solo_dev, SOLO_EEPROM_ENABLE | dataval);\n\t\tsolo_eeprom_reg_write(solo_dev, SOLO_EEPROM_ENABLE |\n\t\t\t\t      EE_SHIFT_CLK | dataval);\n\t}\n\n\tsolo_eeprom_reg_write(solo_dev, SOLO_EEPROM_ENABLE);\n}\n\nunsigned int solo_eeprom_ewen(struct solo_dev *solo_dev, int w_en)\n{\n\tint ewen_cmd = (w_en ? 0x3f : 0) | (EE_EWEN_CMD << ADDR_LEN);\n\tunsigned int retval = 0;\n\tint i;\n\n\tsolo_eeprom_cmd(solo_dev, ewen_cmd);\n\n\tfor (i = 0; i < 16; i++) {\n\t\tsolo_eeprom_reg_write(solo_dev, SOLO_EEPROM_ENABLE |\n\t\t\t\t      EE_SHIFT_CLK);\n\t\tretval = (retval << 1) | solo_eeprom_reg_read(solo_dev);\n\t\tsolo_eeprom_reg_write(solo_dev, SOLO_EEPROM_ENABLE);\n\t\tretval = (retval << 1) | solo_eeprom_reg_read(solo_dev);\n\t}\n\n\tsolo_eeprom_reg_write(solo_dev, ~EE_CS);\n\tretval = (retval << 1) | solo_eeprom_reg_read(solo_dev);\n\n\treturn retval;\n}\n\n__be16 solo_eeprom_read(struct solo_dev *solo_dev, int loc)\n{\n\tint read_cmd = loc | (EE_READ_CMD << ADDR_LEN);\n\tu16 retval = 0;\n\tint i;\n\n\tsolo_eeprom_cmd(solo_dev, read_cmd);\n\n\tfor (i = 0; i < 16; i++) {\n\t\tsolo_eeprom_reg_write(solo_dev, SOLO_EEPROM_ENABLE |\n\t\t\t\t      EE_SHIFT_CLK);\n\t\tretval = (retval << 1) | solo_eeprom_reg_read(solo_dev);\n\t\tsolo_eeprom_reg_write(solo_dev, SOLO_EEPROM_ENABLE);\n\t}\n\n\tsolo_eeprom_reg_write(solo_dev, ~EE_CS);\n\n\treturn (__force __be16)retval;\n}\n\nint solo_eeprom_write(struct solo_dev *solo_dev, int loc,\n\t\t      __be16 data)\n{\n\tint write_cmd = loc | (EE_WRITE_CMD << ADDR_LEN);\n\tunsigned int retval;\n\tint i;\n\n\tsolo_eeprom_cmd(solo_dev, write_cmd);\n\n\tfor (i = 15; i >= 0; i--) {\n\t\tunsigned int dataval = ((__force unsigned)data >> i) & 1;\n\n\t\tsolo_eeprom_reg_write(solo_dev, EE_ENB);\n\t\tsolo_eeprom_reg_write(solo_dev,\n\t\t\t\t      EE_ENB | (dataval << 1) | EE_SHIFT_CLK);\n\t}\n\n\tsolo_eeprom_reg_write(solo_dev, EE_ENB);\n\tsolo_eeprom_reg_write(solo_dev, ~EE_CS);\n\tsolo_eeprom_reg_write(solo_dev, EE_ENB);\n\n\tfor (i = retval = 0; i < 10000 && !retval; i++)\n\t\tretval = solo_eeprom_reg_read(solo_dev);\n\n\tsolo_eeprom_reg_write(solo_dev, ~EE_CS);\n\n\treturn !retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}