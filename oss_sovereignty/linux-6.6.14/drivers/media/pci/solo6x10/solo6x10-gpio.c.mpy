{
  "module_name": "solo6x10-gpio.c",
  "hash_id": "95f189a9ae65cf73195f7935b0ea6e8de353146a2f0d70883afe8c2838481009",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/solo6x10/solo6x10-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n\n#include \"solo6x10.h\"\n\nstatic void solo_gpio_mode(struct solo_dev *solo_dev,\n\t\t\t   unsigned int port_mask, unsigned int mode)\n{\n\tint port;\n\tunsigned int ret;\n\n\tret = solo_reg_read(solo_dev, SOLO_GPIO_CONFIG_0);\n\n\t \n\tfor (port = 0; port < 16; port++) {\n\t\tif (!((1 << port) & port_mask))\n\t\t\tcontinue;\n\n\t\tret &= (~(3 << (port << 1)));\n\t\tret |= ((mode & 3) << (port << 1));\n\t}\n\n\tsolo_reg_write(solo_dev, SOLO_GPIO_CONFIG_0, ret);\n\n\t \n\tret = solo_reg_read(solo_dev, SOLO_GPIO_CONFIG_1);\n\n\tfor (port = 0; port < 16; port++) {\n\t\tif (!((1UL << (port + 16)) & port_mask))\n\t\t\tcontinue;\n\n\t\tif (!mode)\n\t\t\tret &= ~(1UL << port);\n\t\telse\n\t\t\tret |= 1UL << port;\n\t}\n\n\t \n\tret |= 0xffff0000;\n\n\tsolo_reg_write(solo_dev, SOLO_GPIO_CONFIG_1, ret);\n}\n\nstatic void solo_gpio_set(struct solo_dev *solo_dev, unsigned int value)\n{\n\tsolo_reg_write(solo_dev, SOLO_GPIO_DATA_OUT,\n\t\t       solo_reg_read(solo_dev, SOLO_GPIO_DATA_OUT) | value);\n}\n\nstatic void solo_gpio_clear(struct solo_dev *solo_dev, unsigned int value)\n{\n\tsolo_reg_write(solo_dev, SOLO_GPIO_DATA_OUT,\n\t\t       solo_reg_read(solo_dev, SOLO_GPIO_DATA_OUT) & ~value);\n}\n\nstatic void solo_gpio_config(struct solo_dev *solo_dev)\n{\n\t \n\tsolo_gpio_mode(solo_dev, 0x30, 1);\n\tsolo_gpio_clear(solo_dev, 0x30);\n\tudelay(100);\n\tsolo_gpio_set(solo_dev, 0x30);\n\tudelay(100);\n\n\t \n\tsolo_gpio_mode(solo_dev, 0x0f, 2);\n\n\t \n\tsolo_gpio_mode(solo_dev, 0xff00, 1);\n\n\t \n\tsolo_gpio_clear(solo_dev, 0xff00);\n\n\t \n\tsolo_gpio_mode(solo_dev, 0xffff0000, 0);\n}\n\n#ifdef CONFIG_GPIOLIB\n \nstatic int solo_gpiochip_get_direction(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset)\n{\n\tint ret, mode;\n\tstruct solo_dev *solo_dev = gpiochip_get_data(chip);\n\n\tif (offset < 8) {\n\t\tret = solo_reg_read(solo_dev, SOLO_GPIO_CONFIG_0);\n\t\tmode = 3 & (ret >> ((offset + 8) * 2));\n\t} else {\n\t\tret = solo_reg_read(solo_dev, SOLO_GPIO_CONFIG_1);\n\t\tmode =  1 & (ret >> (offset - 8));\n\t}\n\n\tif (!mode)\n\t\treturn 1;\n\telse if (mode == 1)\n\t\treturn 0;\n\n\treturn -1;\n}\n\nstatic int solo_gpiochip_direction_input(struct gpio_chip *chip,\n\t\t\t\t\t unsigned int offset)\n{\n\treturn -1;\n}\n\nstatic int solo_gpiochip_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t  unsigned int offset, int value)\n{\n\treturn -1;\n}\n\nstatic int solo_gpiochip_get(struct gpio_chip *chip,\n\t\t\t\t\t\tunsigned int offset)\n{\n\tint ret;\n\tstruct solo_dev *solo_dev = gpiochip_get_data(chip);\n\n\tret = solo_reg_read(solo_dev, SOLO_GPIO_DATA_IN);\n\n\treturn 1 & (ret >> (offset + 8));\n}\n\nstatic void solo_gpiochip_set(struct gpio_chip *chip,\n\t\t\t\t\t\tunsigned int offset, int value)\n{\n\tstruct solo_dev *solo_dev = gpiochip_get_data(chip);\n\n\tif (value)\n\t\tsolo_gpio_set(solo_dev, 1 << (offset + 8));\n\telse\n\t\tsolo_gpio_clear(solo_dev, 1 << (offset + 8));\n}\n#endif\n\nint solo_gpio_init(struct solo_dev *solo_dev)\n{\n#ifdef CONFIG_GPIOLIB\n\tint ret;\n#endif\n\n\tsolo_gpio_config(solo_dev);\n#ifdef CONFIG_GPIOLIB\n\tsolo_dev->gpio_dev.label = SOLO6X10_NAME\"_gpio\";\n\tsolo_dev->gpio_dev.parent = &solo_dev->pdev->dev;\n\tsolo_dev->gpio_dev.owner = THIS_MODULE;\n\tsolo_dev->gpio_dev.base = -1;\n\tsolo_dev->gpio_dev.ngpio = 24;\n\tsolo_dev->gpio_dev.can_sleep = 0;\n\n\tsolo_dev->gpio_dev.get_direction = solo_gpiochip_get_direction;\n\tsolo_dev->gpio_dev.direction_input = solo_gpiochip_direction_input;\n\tsolo_dev->gpio_dev.direction_output = solo_gpiochip_direction_output;\n\tsolo_dev->gpio_dev.get = solo_gpiochip_get;\n\tsolo_dev->gpio_dev.set = solo_gpiochip_set;\n\n\tret = gpiochip_add_data(&solo_dev->gpio_dev, solo_dev);\n\n\tif (ret) {\n\t\tsolo_dev->gpio_dev.label = NULL;\n\t\treturn -1;\n\t}\n#endif\n\treturn 0;\n}\n\nvoid solo_gpio_exit(struct solo_dev *solo_dev)\n{\n#ifdef CONFIG_GPIOLIB\n\tif (solo_dev->gpio_dev.label) {\n\t\tgpiochip_remove(&solo_dev->gpio_dev);\n\t\tsolo_dev->gpio_dev.label = NULL;\n\t}\n#endif\n\tsolo_gpio_clear(solo_dev, 0x30);\n\tsolo_gpio_config(solo_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}