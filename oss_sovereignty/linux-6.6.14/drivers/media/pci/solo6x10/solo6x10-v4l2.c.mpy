{
  "module_name": "solo6x10-v4l2.c",
  "hash_id": "4330406573b47a0379b3ab1281e13c6a8681c789d8e3ca81026d5d764acd063f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/solo6x10/solo6x10-v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"solo6x10.h\"\n#include \"solo6x10-tw28.h\"\n\n \n#define SOLO_HW_BPL\t\t2048\n#define solo_vlines(__solo)\t(__solo->video_vsize * 2)\n#define solo_image_size(__solo) (solo_bytesperline(__solo) * \\\n\t\t\t\t solo_vlines(__solo))\n#define solo_bytesperline(__solo) (__solo->video_hsize * 2)\n\n#define MIN_VID_BUFFERS\t\t2\n\nstatic inline void erase_on(struct solo_dev *solo_dev)\n{\n\tsolo_reg_write(solo_dev, SOLO_VO_DISP_ERASE, SOLO_VO_DISP_ERASE_ON);\n\tsolo_dev->erasing = 1;\n\tsolo_dev->frame_blank = 0;\n}\n\nstatic inline int erase_off(struct solo_dev *solo_dev)\n{\n\tif (!solo_dev->erasing)\n\t\treturn 0;\n\n\t \n\tif (!solo_dev->frame_blank)\n\t\tsolo_reg_write(solo_dev, SOLO_VO_DISP_ERASE, 0);\n\t \n\tif (solo_dev->frame_blank++ >= 8)\n\t\tsolo_dev->erasing = 0;\n\n\treturn 1;\n}\n\nvoid solo_video_in_isr(struct solo_dev *solo_dev)\n{\n\twake_up_interruptible_all(&solo_dev->disp_thread_wait);\n}\n\nstatic void solo_win_setup(struct solo_dev *solo_dev, u8 ch,\n\t\t\t   int sx, int sy, int ex, int ey, int scale)\n{\n\tif (ch >= solo_dev->nr_chans)\n\t\treturn;\n\n\t \n\tsolo_reg_write(solo_dev, SOLO_VI_WIN_CTRL0(ch),\n\t\t       SOLO_VI_WIN_CHANNEL(ch) |\n\t\t       SOLO_VI_WIN_SX(sx) |\n\t\t       SOLO_VI_WIN_EX(ex) |\n\t\t       SOLO_VI_WIN_SCALE(scale));\n\n\tsolo_reg_write(solo_dev, SOLO_VI_WIN_CTRL1(ch),\n\t\t       SOLO_VI_WIN_SY(sy) |\n\t\t       SOLO_VI_WIN_EY(ey));\n}\n\nstatic int solo_v4l2_ch_ext_4up(struct solo_dev *solo_dev, u8 idx, int on)\n{\n\tu8 ch = idx * 4;\n\n\tif (ch >= solo_dev->nr_chans)\n\t\treturn -EINVAL;\n\n\tif (!on) {\n\t\tu8 i;\n\n\t\tfor (i = ch; i < ch + 4; i++)\n\t\t\tsolo_win_setup(solo_dev, i, solo_dev->video_hsize,\n\t\t\t\t       solo_vlines(solo_dev),\n\t\t\t\t       solo_dev->video_hsize,\n\t\t\t\t       solo_vlines(solo_dev), 0);\n\t\treturn 0;\n\t}\n\n\t \n\tsolo_win_setup(solo_dev, ch, 0, 0, solo_dev->video_hsize / 2,\n\t\t       solo_vlines(solo_dev) / 2, 3);\n\tsolo_win_setup(solo_dev, ch + 1, solo_dev->video_hsize / 2, 0,\n\t\t       solo_dev->video_hsize, solo_vlines(solo_dev) / 2, 3);\n\t \n\tsolo_win_setup(solo_dev, ch + 2, 0, solo_vlines(solo_dev) / 2,\n\t\t       solo_dev->video_hsize / 2, solo_vlines(solo_dev), 3);\n\tsolo_win_setup(solo_dev, ch + 3, solo_dev->video_hsize / 2,\n\t\t       solo_vlines(solo_dev) / 2, solo_dev->video_hsize,\n\t\t       solo_vlines(solo_dev), 3);\n\n\treturn 0;\n}\n\nstatic int solo_v4l2_ch_ext_16up(struct solo_dev *solo_dev, int on)\n{\n\tint sy, ysize, hsize, i;\n\n\tif (!on) {\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tsolo_win_setup(solo_dev, i, solo_dev->video_hsize,\n\t\t\t\t       solo_vlines(solo_dev),\n\t\t\t\t       solo_dev->video_hsize,\n\t\t\t\t       solo_vlines(solo_dev), 0);\n\t\treturn 0;\n\t}\n\n\tysize = solo_vlines(solo_dev) / 4;\n\thsize = solo_dev->video_hsize / 4;\n\n\tfor (sy = 0, i = 0; i < 4; i++, sy += ysize) {\n\t\tsolo_win_setup(solo_dev, i * 4, 0, sy, hsize,\n\t\t\t       sy + ysize, 5);\n\t\tsolo_win_setup(solo_dev, (i * 4) + 1, hsize, sy,\n\t\t\t       hsize * 2, sy + ysize, 5);\n\t\tsolo_win_setup(solo_dev, (i * 4) + 2, hsize * 2, sy,\n\t\t\t       hsize * 3, sy + ysize, 5);\n\t\tsolo_win_setup(solo_dev, (i * 4) + 3, hsize * 3, sy,\n\t\t\t       solo_dev->video_hsize, sy + ysize, 5);\n\t}\n\n\treturn 0;\n}\n\nstatic int solo_v4l2_ch(struct solo_dev *solo_dev, u8 ch, int on)\n{\n\tu8 ext_ch;\n\n\tif (ch < solo_dev->nr_chans) {\n\t\tsolo_win_setup(solo_dev, ch, on ? 0 : solo_dev->video_hsize,\n\t\t\t       on ? 0 : solo_vlines(solo_dev),\n\t\t\t       solo_dev->video_hsize, solo_vlines(solo_dev),\n\t\t\t       on ? 1 : 0);\n\t\treturn 0;\n\t}\n\n\tif (ch >= solo_dev->nr_chans + solo_dev->nr_ext)\n\t\treturn -EINVAL;\n\n\text_ch = ch - solo_dev->nr_chans;\n\n\t \n\tif (ext_ch < 4)\n\t\treturn solo_v4l2_ch_ext_4up(solo_dev, ext_ch, on);\n\n\t \n\treturn solo_v4l2_ch_ext_16up(solo_dev, on);\n}\n\nstatic int solo_v4l2_set_ch(struct solo_dev *solo_dev, u8 ch)\n{\n\tif (ch >= solo_dev->nr_chans + solo_dev->nr_ext)\n\t\treturn -EINVAL;\n\n\terase_on(solo_dev);\n\n\tsolo_v4l2_ch(solo_dev, solo_dev->cur_disp_ch, 0);\n\tsolo_v4l2_ch(solo_dev, ch, 1);\n\n\tsolo_dev->cur_disp_ch = ch;\n\n\treturn 0;\n}\n\nstatic void solo_fillbuf(struct solo_dev *solo_dev,\n\t\t\t struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tdma_addr_t addr;\n\tunsigned int fdma_addr;\n\tint error = -1;\n\tint i;\n\n\taddr = vb2_dma_contig_plane_dma_addr(vb, 0);\n\tif (!addr)\n\t\tgoto finish_buf;\n\n\tif (erase_off(solo_dev)) {\n\t\tvoid *p = vb2_plane_vaddr(vb, 0);\n\t\tint image_size = solo_image_size(solo_dev);\n\n\t\tfor (i = 0; i < image_size; i += 2) {\n\t\t\t((u8 *)p)[i] = 0x80;\n\t\t\t((u8 *)p)[i + 1] = 0x00;\n\t\t}\n\t\terror = 0;\n\t} else {\n\t\tfdma_addr = SOLO_DISP_EXT_ADDR + (solo_dev->old_write *\n\t\t\t\t(SOLO_HW_BPL * solo_vlines(solo_dev)));\n\n\t\terror = solo_p2m_dma_t(solo_dev, 0, addr, fdma_addr,\n\t\t\t\t       solo_bytesperline(solo_dev),\n\t\t\t\t       solo_vlines(solo_dev), SOLO_HW_BPL);\n\t}\n\nfinish_buf:\n\tif (!error) {\n\t\tvb2_set_plane_payload(vb, 0,\n\t\t\tsolo_vlines(solo_dev) * solo_bytesperline(solo_dev));\n\t\tvbuf->sequence = solo_dev->sequence++;\n\t\tvb->timestamp = ktime_get_ns();\n\t}\n\n\tvb2_buffer_done(vb, error ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\n}\n\nstatic void solo_thread_try(struct solo_dev *solo_dev)\n{\n\tstruct solo_vb2_buf *vb;\n\n\t \n\tfor (;;) {\n\t\tunsigned int cur_write;\n\n\t\tcur_write = SOLO_VI_STATUS0_PAGE(\n\t\t\tsolo_reg_read(solo_dev, SOLO_VI_STATUS0));\n\t\tif (cur_write == solo_dev->old_write)\n\t\t\treturn;\n\n\t\tspin_lock(&solo_dev->slock);\n\n\t\tif (list_empty(&solo_dev->vidq_active))\n\t\t\tbreak;\n\n\t\tvb = list_first_entry(&solo_dev->vidq_active, struct solo_vb2_buf,\n\t\t\t\t      list);\n\n\t\tsolo_dev->old_write = cur_write;\n\t\tlist_del(&vb->list);\n\n\t\tspin_unlock(&solo_dev->slock);\n\n\t\tsolo_fillbuf(solo_dev, &vb->vb.vb2_buf);\n\t}\n\n\tassert_spin_locked(&solo_dev->slock);\n\tspin_unlock(&solo_dev->slock);\n}\n\nstatic int solo_thread(void *data)\n{\n\tstruct solo_dev *solo_dev = data;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tset_freezable();\n\tadd_wait_queue(&solo_dev->disp_thread_wait, &wait);\n\n\tfor (;;) {\n\t\tlong timeout = schedule_timeout_interruptible(HZ);\n\n\t\tif (timeout == -ERESTARTSYS || kthread_should_stop())\n\t\t\tbreak;\n\t\tsolo_thread_try(solo_dev);\n\t\ttry_to_freeze();\n\t}\n\n\tremove_wait_queue(&solo_dev->disp_thread_wait, &wait);\n\n\treturn 0;\n}\n\nstatic int solo_start_thread(struct solo_dev *solo_dev)\n{\n\tint ret = 0;\n\n\tsolo_dev->kthread = kthread_run(solo_thread, solo_dev, SOLO6X10_NAME \"_disp\");\n\n\tif (IS_ERR(solo_dev->kthread)) {\n\t\tret = PTR_ERR(solo_dev->kthread);\n\t\tsolo_dev->kthread = NULL;\n\t\treturn ret;\n\t}\n\tsolo_irq_on(solo_dev, SOLO_IRQ_VIDEO_IN);\n\n\treturn ret;\n}\n\nstatic void solo_stop_thread(struct solo_dev *solo_dev)\n{\n\tif (!solo_dev->kthread)\n\t\treturn;\n\n\tsolo_irq_off(solo_dev, SOLO_IRQ_VIDEO_IN);\n\tkthread_stop(solo_dev->kthread);\n\tsolo_dev->kthread = NULL;\n}\n\nstatic int solo_queue_setup(struct vb2_queue *q,\n\t\t\t   unsigned int *num_buffers, unsigned int *num_planes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct solo_dev *solo_dev = vb2_get_drv_priv(q);\n\n\tsizes[0] = solo_image_size(solo_dev);\n\t*num_planes = 1;\n\n\tif (*num_buffers < MIN_VID_BUFFERS)\n\t\t*num_buffers = MIN_VID_BUFFERS;\n\n\treturn 0;\n}\n\nstatic int solo_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct solo_dev *solo_dev = vb2_get_drv_priv(q);\n\n\tsolo_dev->sequence = 0;\n\treturn solo_start_thread(solo_dev);\n}\n\nstatic void solo_stop_streaming(struct vb2_queue *q)\n{\n\tstruct solo_dev *solo_dev = vb2_get_drv_priv(q);\n\n\tsolo_stop_thread(solo_dev);\n\n\tspin_lock(&solo_dev->slock);\n\twhile (!list_empty(&solo_dev->vidq_active)) {\n\t\tstruct solo_vb2_buf *buf = list_entry(\n\t\t\t\tsolo_dev->vidq_active.next,\n\t\t\t\tstruct solo_vb2_buf, list);\n\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock(&solo_dev->slock);\n\tINIT_LIST_HEAD(&solo_dev->vidq_active);\n}\n\nstatic void solo_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct solo_dev *solo_dev = vb2_get_drv_priv(vq);\n\tstruct solo_vb2_buf *solo_vb =\n\t\tcontainer_of(vbuf, struct solo_vb2_buf, vb);\n\n\tspin_lock(&solo_dev->slock);\n\tlist_add_tail(&solo_vb->list, &solo_dev->vidq_active);\n\tspin_unlock(&solo_dev->slock);\n\twake_up_interruptible(&solo_dev->disp_thread_wait);\n}\n\nstatic const struct vb2_ops solo_video_qops = {\n\t.queue_setup\t= solo_queue_setup,\n\t.buf_queue\t= solo_buf_queue,\n\t.start_streaming = solo_start_streaming,\n\t.stop_streaming = solo_stop_streaming,\n\t.wait_prepare\t= vb2_ops_wait_prepare,\n\t.wait_finish\t= vb2_ops_wait_finish,\n};\n\nstatic int solo_querycap(struct file *file, void  *priv,\n\t\t\t struct v4l2_capability *cap)\n{\n\tstrscpy(cap->driver, SOLO6X10_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, \"Softlogic 6x10\", sizeof(cap->card));\n\treturn 0;\n}\n\nstatic int solo_enum_ext_input(struct solo_dev *solo_dev,\n\t\t\t       struct v4l2_input *input)\n{\n\tint ext = input->index - solo_dev->nr_chans;\n\tunsigned int nup, first;\n\n\tif (ext >= solo_dev->nr_ext)\n\t\treturn -EINVAL;\n\n\tnup   = (ext == 4) ? 16 : 4;\n\tfirst = (ext & 3) << 2;  \n\tsnprintf(input->name, sizeof(input->name),\n\t\t \"Multi %d-up (cameras %d-%d)\",\n\t\t nup, first + 1, first + nup);\n\t \n\treturn 0;\n}\n\nstatic int solo_enum_input(struct file *file, void *priv,\n\t\t\t   struct v4l2_input *input)\n{\n\tstruct solo_dev *solo_dev = video_drvdata(file);\n\n\tif (input->index >= solo_dev->nr_chans) {\n\t\tint ret = solo_enum_ext_input(solo_dev, input);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tsnprintf(input->name, sizeof(input->name), \"Camera %d\",\n\t\t\t input->index + 1);\n\n\t\t \n\t\tif (!tw28_get_video_status(solo_dev, input->index))\n\t\t\tinput->status = V4L2_IN_ST_NO_SIGNAL;\n\t}\n\n\tinput->type = V4L2_INPUT_TYPE_CAMERA;\n\tinput->std = solo_dev->vfd->tvnorms;\n\treturn 0;\n}\n\nstatic int solo_set_input(struct file *file, void *priv, unsigned int index)\n{\n\tstruct solo_dev *solo_dev = video_drvdata(file);\n\tint ret = solo_v4l2_set_ch(solo_dev, index);\n\n\tif (!ret) {\n\t\twhile (erase_off(solo_dev))\n\t\t\t ;\n\t}\n\n\treturn ret;\n}\n\nstatic int solo_get_input(struct file *file, void *priv, unsigned int *index)\n{\n\tstruct solo_dev *solo_dev = video_drvdata(file);\n\n\t*index = solo_dev->cur_disp_ch;\n\n\treturn 0;\n}\n\nstatic int solo_enum_fmt_cap(struct file *file, void *priv,\n\t\t\t     struct v4l2_fmtdesc *f)\n{\n\tif (f->index)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_UYVY;\n\treturn 0;\n}\n\nstatic int solo_try_fmt_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *f)\n{\n\tstruct solo_dev *solo_dev = video_drvdata(file);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tint image_size = solo_image_size(solo_dev);\n\n\tif (pix->pixelformat != V4L2_PIX_FMT_UYVY)\n\t\treturn -EINVAL;\n\n\tpix->width = solo_dev->video_hsize;\n\tpix->height = solo_vlines(solo_dev);\n\tpix->sizeimage = image_size;\n\tpix->field = V4L2_FIELD_INTERLACED;\n\tpix->pixelformat = V4L2_PIX_FMT_UYVY;\n\tpix->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\treturn 0;\n}\n\nstatic int solo_set_fmt_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *f)\n{\n\tstruct solo_dev *solo_dev = video_drvdata(file);\n\n\tif (vb2_is_busy(&solo_dev->vidq))\n\t\treturn -EBUSY;\n\n\t \n\treturn solo_try_fmt_cap(file, priv, f);\n}\n\nstatic int solo_get_fmt_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *f)\n{\n\tstruct solo_dev *solo_dev = video_drvdata(file);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\n\tpix->width = solo_dev->video_hsize;\n\tpix->height = solo_vlines(solo_dev);\n\tpix->pixelformat = V4L2_PIX_FMT_UYVY;\n\tpix->field = V4L2_FIELD_INTERLACED;\n\tpix->sizeimage = solo_image_size(solo_dev);\n\tpix->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\tpix->bytesperline = solo_bytesperline(solo_dev);\n\n\treturn 0;\n}\n\nstatic int solo_g_std(struct file *file, void *priv, v4l2_std_id *i)\n{\n\tstruct solo_dev *solo_dev = video_drvdata(file);\n\n\tif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC)\n\t\t*i = V4L2_STD_NTSC_M;\n\telse\n\t\t*i = V4L2_STD_PAL;\n\treturn 0;\n}\n\nint solo_set_video_type(struct solo_dev *solo_dev, bool is_50hz)\n{\n\tint i;\n\n\t \n\tif (vb2_is_busy(&solo_dev->vidq))\n\t\treturn -EBUSY;\n\tfor (i = 0; i < solo_dev->nr_chans; i++)\n\t\tif (vb2_is_busy(&solo_dev->v4l2_enc[i]->vidq))\n\t\t\treturn -EBUSY;\n\tsolo_dev->video_type = is_50hz ? SOLO_VO_FMT_TYPE_PAL :\n\t\t\t\t\t SOLO_VO_FMT_TYPE_NTSC;\n\t \n\tsolo_disp_init(solo_dev);\n\tsolo_enc_init(solo_dev);\n\tsolo_tw28_init(solo_dev);\n\tfor (i = 0; i < solo_dev->nr_chans; i++)\n\t\tsolo_update_mode(solo_dev->v4l2_enc[i]);\n\treturn solo_v4l2_set_ch(solo_dev, solo_dev->cur_disp_ch);\n}\n\nstatic int solo_s_std(struct file *file, void *priv, v4l2_std_id std)\n{\n\tstruct solo_dev *solo_dev = video_drvdata(file);\n\n\treturn solo_set_video_type(solo_dev, std & V4L2_STD_625_50);\n}\n\nstatic int solo_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct solo_dev *solo_dev =\n\t\tcontainer_of(ctrl->handler, struct solo_dev, disp_hdl);\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_MOTION_TRACE:\n\t\tif (ctrl->val) {\n\t\t\tsolo_reg_write(solo_dev, SOLO_VI_MOTION_BORDER,\n\t\t\t\t\tSOLO_VI_MOTION_Y_ADD |\n\t\t\t\t\tSOLO_VI_MOTION_Y_VALUE(0x20) |\n\t\t\t\t\tSOLO_VI_MOTION_CB_VALUE(0x10) |\n\t\t\t\t\tSOLO_VI_MOTION_CR_VALUE(0x10));\n\t\t\tsolo_reg_write(solo_dev, SOLO_VI_MOTION_BAR,\n\t\t\t\t\tSOLO_VI_MOTION_CR_ADD |\n\t\t\t\t\tSOLO_VI_MOTION_Y_VALUE(0x10) |\n\t\t\t\t\tSOLO_VI_MOTION_CB_VALUE(0x80) |\n\t\t\t\t\tSOLO_VI_MOTION_CR_VALUE(0x10));\n\t\t} else {\n\t\t\tsolo_reg_write(solo_dev, SOLO_VI_MOTION_BORDER, 0);\n\t\t\tsolo_reg_write(solo_dev, SOLO_VI_MOTION_BAR, 0);\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct v4l2_file_operations solo_v4l2_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= v4l2_fh_open,\n\t.release\t\t= vb2_fop_release,\n\t.read\t\t\t= vb2_fop_read,\n\t.poll\t\t\t= vb2_fop_poll,\n\t.mmap\t\t\t= vb2_fop_mmap,\n\t.unlocked_ioctl\t\t= video_ioctl2,\n};\n\nstatic const struct v4l2_ioctl_ops solo_v4l2_ioctl_ops = {\n\t.vidioc_querycap\t\t= solo_querycap,\n\t.vidioc_s_std\t\t\t= solo_s_std,\n\t.vidioc_g_std\t\t\t= solo_g_std,\n\t \n\t.vidioc_enum_input\t\t= solo_enum_input,\n\t.vidioc_s_input\t\t\t= solo_set_input,\n\t.vidioc_g_input\t\t\t= solo_get_input,\n\t \n\t.vidioc_enum_fmt_vid_cap\t= solo_enum_fmt_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= solo_try_fmt_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= solo_set_fmt_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= solo_get_fmt_cap,\n\t \n\t.vidioc_reqbufs\t\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_querybuf\t\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_streamon\t\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t\t= vb2_ioctl_streamoff,\n\t \n\t.vidioc_log_status\t\t= v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event\t\t= v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event\t= v4l2_event_unsubscribe,\n};\n\nstatic const struct video_device solo_v4l2_template = {\n\t.name\t\t\t= SOLO6X10_NAME,\n\t.fops\t\t\t= &solo_v4l2_fops,\n\t.ioctl_ops\t\t= &solo_v4l2_ioctl_ops,\n\t.minor\t\t\t= -1,\n\t.release\t\t= video_device_release,\n\t.tvnorms\t\t= V4L2_STD_NTSC_M | V4L2_STD_PAL,\n\t.device_caps\t\t= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t\t\t  V4L2_CAP_STREAMING,\n};\n\nstatic const struct v4l2_ctrl_ops solo_ctrl_ops = {\n\t.s_ctrl = solo_s_ctrl,\n};\n\nstatic const struct v4l2_ctrl_config solo_motion_trace_ctrl = {\n\t.ops = &solo_ctrl_ops,\n\t.id = V4L2_CID_MOTION_TRACE,\n\t.name = \"Motion Detection Trace\",\n\t.type = V4L2_CTRL_TYPE_BOOLEAN,\n\t.max = 1,\n\t.step = 1,\n};\n\nint solo_v4l2_init(struct solo_dev *solo_dev, unsigned nr)\n{\n\tint ret;\n\tint i;\n\n\tinit_waitqueue_head(&solo_dev->disp_thread_wait);\n\tspin_lock_init(&solo_dev->slock);\n\tmutex_init(&solo_dev->lock);\n\tINIT_LIST_HEAD(&solo_dev->vidq_active);\n\n\tsolo_dev->vfd = video_device_alloc();\n\tif (!solo_dev->vfd)\n\t\treturn -ENOMEM;\n\n\t*solo_dev->vfd = solo_v4l2_template;\n\tsolo_dev->vfd->v4l2_dev = &solo_dev->v4l2_dev;\n\tsolo_dev->vfd->queue = &solo_dev->vidq;\n\tsolo_dev->vfd->lock = &solo_dev->lock;\n\tv4l2_ctrl_handler_init(&solo_dev->disp_hdl, 1);\n\tv4l2_ctrl_new_custom(&solo_dev->disp_hdl, &solo_motion_trace_ctrl, NULL);\n\tif (solo_dev->disp_hdl.error) {\n\t\tret = solo_dev->disp_hdl.error;\n\t\tgoto fail;\n\t}\n\tsolo_dev->vfd->ctrl_handler = &solo_dev->disp_hdl;\n\n\tvideo_set_drvdata(solo_dev->vfd, solo_dev);\n\n\tsolo_dev->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tsolo_dev->vidq.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\tsolo_dev->vidq.ops = &solo_video_qops;\n\tsolo_dev->vidq.mem_ops = &vb2_dma_contig_memops;\n\tsolo_dev->vidq.drv_priv = solo_dev;\n\tsolo_dev->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tsolo_dev->vidq.gfp_flags = __GFP_DMA32 | __GFP_KSWAPD_RECLAIM;\n\tsolo_dev->vidq.buf_struct_size = sizeof(struct solo_vb2_buf);\n\tsolo_dev->vidq.lock = &solo_dev->lock;\n\tsolo_dev->vidq.dev = &solo_dev->pdev->dev;\n\tret = vb2_queue_init(&solo_dev->vidq);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t \n\tfor (i = 0; i < solo_dev->nr_chans; i++) {\n\t\tsolo_v4l2_set_ch(solo_dev, i);\n\t\twhile (erase_off(solo_dev))\n\t\t\t ;\n\t}\n\n\t \n\tsolo_v4l2_set_ch(solo_dev, 0);\n\twhile (erase_off(solo_dev))\n\t\t ;\n\n\tret = video_register_device(solo_dev->vfd, VFL_TYPE_VIDEO, nr);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tsnprintf(solo_dev->vfd->name, sizeof(solo_dev->vfd->name), \"%s (%i)\",\n\t\t SOLO6X10_NAME, solo_dev->vfd->num);\n\n\tdev_info(&solo_dev->pdev->dev, \"Display as /dev/video%d with %d inputs (%d extended)\\n\",\n\t\t solo_dev->vfd->num,\n\t\t solo_dev->nr_chans, solo_dev->nr_ext);\n\n\treturn 0;\n\nfail:\n\tvideo_device_release(solo_dev->vfd);\n\tv4l2_ctrl_handler_free(&solo_dev->disp_hdl);\n\tsolo_dev->vfd = NULL;\n\treturn ret;\n}\n\nvoid solo_v4l2_exit(struct solo_dev *solo_dev)\n{\n\tif (solo_dev->vfd == NULL)\n\t\treturn;\n\n\tvideo_unregister_device(solo_dev->vfd);\n\tv4l2_ctrl_handler_free(&solo_dev->disp_hdl);\n\tsolo_dev->vfd = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}