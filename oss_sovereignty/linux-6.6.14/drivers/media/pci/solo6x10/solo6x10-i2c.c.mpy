{
  "module_name": "solo6x10-i2c.c",
  "hash_id": "8b93eecc4315eff9959265e86c3bdea312d8b4ebf4b6b123c0914dcfc2988005",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/solo6x10/solo6x10-i2c.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n\n#include \"solo6x10.h\"\n\nu8 solo_i2c_readbyte(struct solo_dev *solo_dev, int id, u8 addr, u8 off)\n{\n\tstruct i2c_msg msgs[2];\n\tu8 data;\n\n\tmsgs[0].flags = 0;\n\tmsgs[0].addr = addr;\n\tmsgs[0].len = 1;\n\tmsgs[0].buf = &off;\n\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].addr = addr;\n\tmsgs[1].len = 1;\n\tmsgs[1].buf = &data;\n\n\ti2c_transfer(&solo_dev->i2c_adap[id], msgs, 2);\n\n\treturn data;\n}\n\nvoid solo_i2c_writebyte(struct solo_dev *solo_dev, int id, u8 addr,\n\t\t\tu8 off, u8 data)\n{\n\tstruct i2c_msg msgs;\n\tu8 buf[2];\n\n\tbuf[0] = off;\n\tbuf[1] = data;\n\tmsgs.flags = 0;\n\tmsgs.addr = addr;\n\tmsgs.len = 2;\n\tmsgs.buf = buf;\n\n\ti2c_transfer(&solo_dev->i2c_adap[id], &msgs, 1);\n}\n\nstatic void solo_i2c_flush(struct solo_dev *solo_dev, int wr)\n{\n\tu32 ctrl;\n\n\tctrl = SOLO_IIC_CH_SET(solo_dev->i2c_id);\n\n\tif (solo_dev->i2c_state == IIC_STATE_START)\n\t\tctrl |= SOLO_IIC_START;\n\n\tif (wr) {\n\t\tctrl |= SOLO_IIC_WRITE;\n\t} else {\n\t\tctrl |= SOLO_IIC_READ;\n\t\tif (!(solo_dev->i2c_msg->flags & I2C_M_NO_RD_ACK))\n\t\t\tctrl |= SOLO_IIC_ACK_EN;\n\t}\n\n\tif (solo_dev->i2c_msg_ptr == solo_dev->i2c_msg->len)\n\t\tctrl |= SOLO_IIC_STOP;\n\n\tsolo_reg_write(solo_dev, SOLO_IIC_CTRL, ctrl);\n}\n\nstatic void solo_i2c_start(struct solo_dev *solo_dev)\n{\n\tu32 addr = solo_dev->i2c_msg->addr << 1;\n\n\tif (solo_dev->i2c_msg->flags & I2C_M_RD)\n\t\taddr |= 1;\n\n\tsolo_dev->i2c_state = IIC_STATE_START;\n\tsolo_reg_write(solo_dev, SOLO_IIC_TXD, addr);\n\tsolo_i2c_flush(solo_dev, 1);\n}\n\nstatic void solo_i2c_stop(struct solo_dev *solo_dev)\n{\n\tsolo_irq_off(solo_dev, SOLO_IRQ_IIC);\n\tsolo_reg_write(solo_dev, SOLO_IIC_CTRL, 0);\n\tsolo_dev->i2c_state = IIC_STATE_STOP;\n\twake_up(&solo_dev->i2c_wait);\n}\n\nstatic int solo_i2c_handle_read(struct solo_dev *solo_dev)\n{\nprepare_read:\n\tif (solo_dev->i2c_msg_ptr != solo_dev->i2c_msg->len) {\n\t\tsolo_i2c_flush(solo_dev, 0);\n\t\treturn 0;\n\t}\n\n\tsolo_dev->i2c_msg_ptr = 0;\n\tsolo_dev->i2c_msg++;\n\tsolo_dev->i2c_msg_num--;\n\n\tif (solo_dev->i2c_msg_num == 0) {\n\t\tsolo_i2c_stop(solo_dev);\n\t\treturn 0;\n\t}\n\n\tif (!(solo_dev->i2c_msg->flags & I2C_M_NOSTART)) {\n\t\tsolo_i2c_start(solo_dev);\n\t} else {\n\t\tif (solo_dev->i2c_msg->flags & I2C_M_RD)\n\t\t\tgoto prepare_read;\n\t\telse\n\t\t\tsolo_i2c_stop(solo_dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int solo_i2c_handle_write(struct solo_dev *solo_dev)\n{\nretry_write:\n\tif (solo_dev->i2c_msg_ptr != solo_dev->i2c_msg->len) {\n\t\tsolo_reg_write(solo_dev, SOLO_IIC_TXD,\n\t\t\t       solo_dev->i2c_msg->buf[solo_dev->i2c_msg_ptr]);\n\t\tsolo_dev->i2c_msg_ptr++;\n\t\tsolo_i2c_flush(solo_dev, 1);\n\t\treturn 0;\n\t}\n\n\tsolo_dev->i2c_msg_ptr = 0;\n\tsolo_dev->i2c_msg++;\n\tsolo_dev->i2c_msg_num--;\n\n\tif (solo_dev->i2c_msg_num == 0) {\n\t\tsolo_i2c_stop(solo_dev);\n\t\treturn 0;\n\t}\n\n\tif (!(solo_dev->i2c_msg->flags & I2C_M_NOSTART)) {\n\t\tsolo_i2c_start(solo_dev);\n\t} else {\n\t\tif (solo_dev->i2c_msg->flags & I2C_M_RD)\n\t\t\tsolo_i2c_stop(solo_dev);\n\t\telse\n\t\t\tgoto retry_write;\n\t}\n\n\treturn 0;\n}\n\nint solo_i2c_isr(struct solo_dev *solo_dev)\n{\n\tu32 status = solo_reg_read(solo_dev, SOLO_IIC_CTRL);\n\tint ret = -EINVAL;\n\n\n\tif (CHK_FLAGS(status, SOLO_IIC_STATE_TRNS | SOLO_IIC_STATE_SIG_ERR)\n\t    || solo_dev->i2c_id < 0) {\n\t\tsolo_i2c_stop(solo_dev);\n\t\treturn -ENXIO;\n\t}\n\n\tswitch (solo_dev->i2c_state) {\n\tcase IIC_STATE_START:\n\t\tif (solo_dev->i2c_msg->flags & I2C_M_RD) {\n\t\t\tsolo_dev->i2c_state = IIC_STATE_READ;\n\t\t\tret = solo_i2c_handle_read(solo_dev);\n\t\t\tbreak;\n\t\t}\n\n\t\tsolo_dev->i2c_state = IIC_STATE_WRITE;\n\t\tfallthrough;\n\tcase IIC_STATE_WRITE:\n\t\tret = solo_i2c_handle_write(solo_dev);\n\t\tbreak;\n\n\tcase IIC_STATE_READ:\n\t\tsolo_dev->i2c_msg->buf[solo_dev->i2c_msg_ptr] =\n\t\t\tsolo_reg_read(solo_dev, SOLO_IIC_RXD);\n\t\tsolo_dev->i2c_msg_ptr++;\n\n\t\tret = solo_i2c_handle_read(solo_dev);\n\t\tbreak;\n\n\tdefault:\n\t\tsolo_i2c_stop(solo_dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int solo_i2c_master_xfer(struct i2c_adapter *adap,\n\t\t\t\tstruct i2c_msg msgs[], int num)\n{\n\tstruct solo_dev *solo_dev = adap->algo_data;\n\tunsigned long timeout;\n\tint ret;\n\tint i;\n\tDEFINE_WAIT(wait);\n\n\tfor (i = 0; i < SOLO_I2C_ADAPTERS; i++) {\n\t\tif (&solo_dev->i2c_adap[i] == adap)\n\t\t\tbreak;\n\t}\n\n\tif (i == SOLO_I2C_ADAPTERS)\n\t\treturn num;  \n\n\tmutex_lock(&solo_dev->i2c_mutex);\n\tsolo_dev->i2c_id = i;\n\tsolo_dev->i2c_msg = msgs;\n\tsolo_dev->i2c_msg_num = num;\n\tsolo_dev->i2c_msg_ptr = 0;\n\n\tsolo_reg_write(solo_dev, SOLO_IIC_CTRL, 0);\n\tsolo_irq_on(solo_dev, SOLO_IRQ_IIC);\n\tsolo_i2c_start(solo_dev);\n\n\ttimeout = HZ / 2;\n\n\tfor (;;) {\n\t\tprepare_to_wait(&solo_dev->i2c_wait, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\n\t\tif (solo_dev->i2c_state == IIC_STATE_STOP)\n\t\t\tbreak;\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\tfinish_wait(&solo_dev->i2c_wait, &wait);\n\tret = num - solo_dev->i2c_msg_num;\n\tsolo_dev->i2c_state = IIC_STATE_IDLE;\n\tsolo_dev->i2c_id = -1;\n\n\tmutex_unlock(&solo_dev->i2c_mutex);\n\n\treturn ret;\n}\n\nstatic u32 solo_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm solo_i2c_algo = {\n\t.master_xfer\t= solo_i2c_master_xfer,\n\t.functionality\t= solo_i2c_functionality,\n};\n\nint solo_i2c_init(struct solo_dev *solo_dev)\n{\n\tint i;\n\tint ret;\n\n\tsolo_reg_write(solo_dev, SOLO_IIC_CFG,\n\t\t       SOLO_IIC_PRESCALE(8) | SOLO_IIC_ENABLE);\n\n\tsolo_dev->i2c_id = -1;\n\tsolo_dev->i2c_state = IIC_STATE_IDLE;\n\tinit_waitqueue_head(&solo_dev->i2c_wait);\n\tmutex_init(&solo_dev->i2c_mutex);\n\n\tfor (i = 0; i < SOLO_I2C_ADAPTERS; i++) {\n\t\tstruct i2c_adapter *adap = &solo_dev->i2c_adap[i];\n\n\t\tsnprintf(adap->name, I2C_NAME_SIZE, \"%s I2C %d\",\n\t\t\t SOLO6X10_NAME, i);\n\t\tadap->algo = &solo_i2c_algo;\n\t\tadap->algo_data = solo_dev;\n\t\tadap->retries = 1;\n\t\tadap->dev.parent = &solo_dev->pdev->dev;\n\n\t\tret = i2c_add_adapter(adap);\n\t\tif (ret) {\n\t\t\tadap->algo_data = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tfor (i = 0; i < SOLO_I2C_ADAPTERS; i++) {\n\t\t\tif (!solo_dev->i2c_adap[i].algo_data)\n\t\t\t\tbreak;\n\t\t\ti2c_del_adapter(&solo_dev->i2c_adap[i]);\n\t\t\tsolo_dev->i2c_adap[i].algo_data = NULL;\n\t\t}\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid solo_i2c_exit(struct solo_dev *solo_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < SOLO_I2C_ADAPTERS; i++) {\n\t\tif (!solo_dev->i2c_adap[i].algo_data)\n\t\t\tcontinue;\n\t\ti2c_del_adapter(&solo_dev->i2c_adap[i]);\n\t\tsolo_dev->i2c_adap[i].algo_data = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}