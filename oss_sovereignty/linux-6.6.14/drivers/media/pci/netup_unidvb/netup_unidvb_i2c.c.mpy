{
  "module_name": "netup_unidvb_i2c.c",
  "hash_id": "364e9201f57e616170cbcbdf543c146faef4a15ad2aa840a6001b61da19c2ac3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/netup_unidvb/netup_unidvb_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include \"netup_unidvb.h\"\n\n#define NETUP_I2C_BUS0_ADDR\t\t0x4800\n#define NETUP_I2C_BUS1_ADDR\t\t0x4840\n#define NETUP_I2C_TIMEOUT\t\t1000\n\n \n#define TWI_IRQEN_COMPL\t0x1\n#define TWI_IRQEN_ANACK 0x2\n#define TWI_IRQEN_DNACK 0x4\n#define TWI_IRQ_COMPL\t(TWI_IRQEN_COMPL << 8)\n#define TWI_IRQ_ANACK\t(TWI_IRQEN_ANACK << 8)\n#define TWI_IRQ_DNACK\t(TWI_IRQEN_DNACK << 8)\n#define TWI_IRQ_TX\t0x800\n#define TWI_IRQ_RX\t0x1000\n#define TWI_IRQEN\t(TWI_IRQEN_COMPL | TWI_IRQEN_ANACK | TWI_IRQEN_DNACK)\n \n#define TWI_TRANSFER\t0x100\n#define TWI_NOSTOP\t0x200\n#define TWI_SOFT_RESET\t0x2000\n \n#define TWI_CLKDIV\t156\n \n#define FIFO_IRQEN\t0x8000\n#define FIFO_RESET\t0x4000\n \n#define FIFO_SIZE\t16\n\nstruct netup_i2c_fifo_regs {\n\tunion {\n\t\t__u8\tdata8;\n\t\t__le16\tdata16;\n\t\t__le32\tdata32;\n\t};\n\t__u8\t\tpadding[4];\n\t__le16\t\tstat_ctrl;\n} __packed __aligned(1);\n\nstruct netup_i2c_regs {\n\t__le16\t\t\t\tclkdiv;\n\t__le16\t\t\t\ttwi_ctrl0_stat;\n\t__le16\t\t\t\ttwi_addr_ctrl1;\n\t__le16\t\t\t\tlength;\n\t__u8\t\t\t\tpadding1[8];\n\tstruct netup_i2c_fifo_regs\ttx_fifo;\n\t__u8\t\t\t\tpadding2[6];\n\tstruct netup_i2c_fifo_regs\trx_fifo;\n} __packed __aligned(1);\n\nirqreturn_t netup_i2c_interrupt(struct netup_i2c *i2c)\n{\n\tu16 reg, tmp;\n\tunsigned long flags;\n\tirqreturn_t iret = IRQ_HANDLED;\n\n\tspin_lock_irqsave(&i2c->lock, flags);\n\treg = readw(&i2c->regs->twi_ctrl0_stat);\n\twritew(reg & ~TWI_IRQEN, &i2c->regs->twi_ctrl0_stat);\n\tdev_dbg(i2c->adap.dev.parent,\n\t\t\"%s(): twi_ctrl0_state 0x%x\\n\", __func__, reg);\n\tif ((reg & TWI_IRQEN_COMPL) != 0 && (reg & TWI_IRQ_COMPL)) {\n\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\"%s(): TWI_IRQEN_COMPL\\n\", __func__);\n\t\ti2c->state = STATE_DONE;\n\t\tgoto irq_ok;\n\t}\n\tif ((reg & TWI_IRQEN_ANACK) != 0 && (reg & TWI_IRQ_ANACK)) {\n\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\"%s(): TWI_IRQEN_ANACK\\n\", __func__);\n\t\ti2c->state = STATE_ERROR;\n\t\tgoto irq_ok;\n\t}\n\tif ((reg & TWI_IRQEN_DNACK) != 0 && (reg & TWI_IRQ_DNACK)) {\n\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\"%s(): TWI_IRQEN_DNACK\\n\", __func__);\n\t\ti2c->state = STATE_ERROR;\n\t\tgoto irq_ok;\n\t}\n\tif ((reg & TWI_IRQ_RX) != 0) {\n\t\ttmp = readw(&i2c->regs->rx_fifo.stat_ctrl);\n\t\twritew(tmp & ~FIFO_IRQEN, &i2c->regs->rx_fifo.stat_ctrl);\n\t\ti2c->state = STATE_WANT_READ;\n\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\"%s(): want read\\n\", __func__);\n\t\tgoto irq_ok;\n\t}\n\tif ((reg & TWI_IRQ_TX) != 0) {\n\t\ttmp = readw(&i2c->regs->tx_fifo.stat_ctrl);\n\t\twritew(tmp & ~FIFO_IRQEN, &i2c->regs->tx_fifo.stat_ctrl);\n\t\ti2c->state = STATE_WANT_WRITE;\n\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\"%s(): want write\\n\", __func__);\n\t\tgoto irq_ok;\n\t}\n\tdev_warn(&i2c->adap.dev, \"%s(): not mine interrupt\\n\", __func__);\n\tiret = IRQ_NONE;\nirq_ok:\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n\tif (iret == IRQ_HANDLED)\n\t\twake_up(&i2c->wq);\n\treturn iret;\n}\n\nstatic void netup_i2c_reset(struct netup_i2c *i2c)\n{\n\tdev_dbg(i2c->adap.dev.parent, \"%s()\\n\", __func__);\n\ti2c->state = STATE_DONE;\n\twritew(TWI_SOFT_RESET, &i2c->regs->twi_addr_ctrl1);\n\twritew(TWI_CLKDIV, &i2c->regs->clkdiv);\n\twritew(FIFO_RESET, &i2c->regs->tx_fifo.stat_ctrl);\n\twritew(FIFO_RESET, &i2c->regs->rx_fifo.stat_ctrl);\n\twritew(0x800, &i2c->regs->tx_fifo.stat_ctrl);\n\twritew(0x800, &i2c->regs->rx_fifo.stat_ctrl);\n}\n\nstatic void netup_i2c_fifo_tx(struct netup_i2c *i2c)\n{\n\tu8 data;\n\tu32 fifo_space = FIFO_SIZE -\n\t\t(readw(&i2c->regs->tx_fifo.stat_ctrl) & 0x3f);\n\tu32 msg_length = i2c->msg->len - i2c->xmit_size;\n\n\tmsg_length = (msg_length < fifo_space ? msg_length : fifo_space);\n\twhile (msg_length--) {\n\t\tdata = i2c->msg->buf[i2c->xmit_size++];\n\t\twriteb(data, &i2c->regs->tx_fifo.data8);\n\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\"%s(): write 0x%02x\\n\", __func__, data);\n\t}\n\tif (i2c->xmit_size < i2c->msg->len) {\n\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\"%s(): TX IRQ enabled\\n\", __func__);\n\t\twritew(readw(&i2c->regs->tx_fifo.stat_ctrl) | FIFO_IRQEN,\n\t\t\t&i2c->regs->tx_fifo.stat_ctrl);\n\t}\n}\n\nstatic void netup_i2c_fifo_rx(struct netup_i2c *i2c)\n{\n\tu8 data;\n\tu32 fifo_size = readw(&i2c->regs->rx_fifo.stat_ctrl) & 0x3f;\n\n\tdev_dbg(i2c->adap.dev.parent,\n\t\t\"%s(): RX fifo size %d\\n\", __func__, fifo_size);\n\twhile (fifo_size--) {\n\t\tdata = readb(&i2c->regs->rx_fifo.data8);\n\t\tif ((i2c->msg->flags & I2C_M_RD) != 0 &&\n\t\t\t\t\ti2c->xmit_size < i2c->msg->len) {\n\t\t\ti2c->msg->buf[i2c->xmit_size++] = data;\n\t\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\t\"%s(): read 0x%02x\\n\", __func__, data);\n\t\t}\n\t}\n\tif (i2c->xmit_size < i2c->msg->len) {\n\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\"%s(): RX IRQ enabled\\n\", __func__);\n\t\twritew(readw(&i2c->regs->rx_fifo.stat_ctrl) | FIFO_IRQEN,\n\t\t\t&i2c->regs->rx_fifo.stat_ctrl);\n\t}\n}\n\nstatic void netup_i2c_start_xfer(struct netup_i2c *i2c)\n{\n\tu16 rdflag = ((i2c->msg->flags & I2C_M_RD) ? 1 : 0);\n\tu16 reg = readw(&i2c->regs->twi_ctrl0_stat);\n\n\twritew(TWI_IRQEN | reg, &i2c->regs->twi_ctrl0_stat);\n\twritew(i2c->msg->len, &i2c->regs->length);\n\twritew(TWI_TRANSFER | (i2c->msg->addr << 1) | rdflag,\n\t\t&i2c->regs->twi_addr_ctrl1);\n\tdev_dbg(i2c->adap.dev.parent,\n\t\t\"%s(): length %d twi_addr_ctrl1 0x%x twi_ctrl0_stat 0x%x\\n\",\n\t\t__func__, readw(&i2c->regs->length),\n\t\treadw(&i2c->regs->twi_addr_ctrl1),\n\t\treadw(&i2c->regs->twi_ctrl0_stat));\n\ti2c->state = STATE_WAIT;\n\ti2c->xmit_size = 0;\n\tif (!rdflag)\n\t\tnetup_i2c_fifo_tx(i2c);\n\telse\n\t\twritew(FIFO_IRQEN | readw(&i2c->regs->rx_fifo.stat_ctrl),\n\t\t\t&i2c->regs->rx_fifo.stat_ctrl);\n}\n\nstatic int netup_i2c_xfer(struct i2c_adapter *adap,\n\t\t\t  struct i2c_msg *msgs, int num)\n{\n\tunsigned long flags;\n\tint i, trans_done, res = num;\n\tstruct netup_i2c *i2c = i2c_get_adapdata(adap);\n\tu16 reg;\n\n\tspin_lock_irqsave(&i2c->lock, flags);\n\tif (i2c->state != STATE_DONE) {\n\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\"%s(): i2c->state == %d, resetting I2C\\n\",\n\t\t\t__func__, i2c->state);\n\t\tnetup_i2c_reset(i2c);\n\t}\n\tdev_dbg(i2c->adap.dev.parent, \"%s() num %d\\n\", __func__, num);\n\tfor (i = 0; i < num; i++) {\n\t\ti2c->msg = &msgs[i];\n\t\tnetup_i2c_start_xfer(i2c);\n\t\ttrans_done = 0;\n\t\twhile (!trans_done) {\n\t\t\tspin_unlock_irqrestore(&i2c->lock, flags);\n\t\t\tif (wait_event_timeout(i2c->wq,\n\t\t\t\t\ti2c->state != STATE_WAIT,\n\t\t\t\t\tmsecs_to_jiffies(NETUP_I2C_TIMEOUT))) {\n\t\t\t\tspin_lock_irqsave(&i2c->lock, flags);\n\t\t\t\tswitch (i2c->state) {\n\t\t\t\tcase STATE_WANT_READ:\n\t\t\t\t\tnetup_i2c_fifo_rx(i2c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATE_WANT_WRITE:\n\t\t\t\t\tnetup_i2c_fifo_tx(i2c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATE_DONE:\n\t\t\t\t\tif ((i2c->msg->flags & I2C_M_RD) != 0 &&\n\t\t\t\t\t\ti2c->xmit_size != i2c->msg->len)\n\t\t\t\t\t\tnetup_i2c_fifo_rx(i2c);\n\t\t\t\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\t\t\t\"%s(): msg %d OK\\n\",\n\t\t\t\t\t\t__func__, i);\n\t\t\t\t\ttrans_done = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATE_ERROR:\n\t\t\t\t\tres = -EIO;\n\t\t\t\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\t\t\t\"%s(): error state\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\t\tgoto done;\n\t\t\t\tdefault:\n\t\t\t\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\t\t\t\"%s(): invalid state %d\\n\",\n\t\t\t\t\t\t__func__, i2c->state);\n\t\t\t\t\tres = -EINVAL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (!trans_done) {\n\t\t\t\t\ti2c->state = STATE_WAIT;\n\t\t\t\t\treg = readw(\n\t\t\t\t\t\t&i2c->regs->twi_ctrl0_stat);\n\t\t\t\t\twritew(TWI_IRQEN | reg,\n\t\t\t\t\t\t&i2c->regs->twi_ctrl0_stat);\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&i2c->lock, flags);\n\t\t\t} else {\n\t\t\t\tspin_lock_irqsave(&i2c->lock, flags);\n\t\t\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\t\t\"%s(): wait timeout\\n\", __func__);\n\t\t\t\tres = -ETIMEDOUT;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&i2c->lock, flags);\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n\tdev_dbg(i2c->adap.dev.parent, \"%s(): result %d\\n\", __func__, res);\n\treturn res;\n}\n\nstatic u32 netup_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm netup_i2c_algorithm = {\n\t.master_xfer\t= netup_i2c_xfer,\n\t.functionality\t= netup_i2c_func,\n};\n\nstatic const struct i2c_adapter netup_i2c_adapter = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= NETUP_UNIDVB_NAME,\n\t.class\t\t= I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t.algo\t\t= &netup_i2c_algorithm,\n};\n\nstatic int netup_i2c_init(struct netup_unidvb_dev *ndev, int bus_num)\n{\n\tint ret;\n\tstruct netup_i2c *i2c;\n\n\tif (bus_num < 0 || bus_num > 1) {\n\t\tdev_err(&ndev->pci_dev->dev,\n\t\t\t\"%s(): invalid bus_num %d\\n\", __func__, bus_num);\n\t\treturn -EINVAL;\n\t}\n\ti2c = &ndev->i2c[bus_num];\n\tspin_lock_init(&i2c->lock);\n\tinit_waitqueue_head(&i2c->wq);\n\ti2c->regs = (struct netup_i2c_regs __iomem *)(ndev->bmmio0 +\n\t\t(bus_num == 0 ? NETUP_I2C_BUS0_ADDR : NETUP_I2C_BUS1_ADDR));\n\tnetup_i2c_reset(i2c);\n\ti2c->adap = netup_i2c_adapter;\n\ti2c->adap.dev.parent = &ndev->pci_dev->dev;\n\ti2c_set_adapdata(&i2c->adap, i2c);\n\tret = i2c_add_adapter(&i2c->adap);\n\tif (ret)\n\t\treturn ret;\n\tdev_info(&ndev->pci_dev->dev,\n\t\t\"%s(): registered I2C bus %d at 0x%x\\n\",\n\t\t__func__,\n\t\tbus_num, (bus_num == 0 ?\n\t\t\tNETUP_I2C_BUS0_ADDR :\n\t\t\tNETUP_I2C_BUS1_ADDR));\n\treturn 0;\n}\n\nstatic void netup_i2c_remove(struct netup_unidvb_dev *ndev, int bus_num)\n{\n\tstruct netup_i2c *i2c;\n\n\tif (bus_num < 0 || bus_num > 1) {\n\t\tdev_err(&ndev->pci_dev->dev,\n\t\t\t\"%s(): invalid bus number %d\\n\", __func__, bus_num);\n\t\treturn;\n\t}\n\ti2c = &ndev->i2c[bus_num];\n\tnetup_i2c_reset(i2c);\n\t \n\ti2c_del_adapter(&i2c->adap);\n\tdev_info(&ndev->pci_dev->dev,\n\t\t\"netup_i2c_remove: unregistered I2C bus %d\\n\", bus_num);\n}\n\nint netup_i2c_register(struct netup_unidvb_dev *ndev)\n{\n\tint ret;\n\n\tret = netup_i2c_init(ndev, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = netup_i2c_init(ndev, 1);\n\tif (ret) {\n\t\tnetup_i2c_remove(ndev, 0);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nvoid netup_i2c_unregister(struct netup_unidvb_dev *ndev)\n{\n\tnetup_i2c_remove(ndev, 0);\n\tnetup_i2c_remove(ndev, 1);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}