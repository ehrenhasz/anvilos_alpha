{
  "module_name": "netup_unidvb_core.c",
  "hash_id": "a84ae1cf11b82351c76cac44c672dc6d001a92554bfa00f79364de11646ad3ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/netup_unidvb/netup_unidvb_core.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/list.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"netup_unidvb.h\"\n#include \"cxd2841er.h\"\n#include \"horus3a.h\"\n#include \"ascot2e.h\"\n#include \"helene.h\"\n#include \"lnbh25.h\"\n\nstatic int spi_enable;\nmodule_param(spi_enable, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\nMODULE_DESCRIPTION(\"Driver for NetUP Dual Universal DVB CI PCIe card\");\nMODULE_AUTHOR(\"info@netup.ru\");\nMODULE_VERSION(NETUP_UNIDVB_VERSION);\nMODULE_LICENSE(\"GPL\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n \n#define\tAVL_PCIE_IENR\t\t0x50\n#define AVL_PCIE_ISR\t\t0x40\n#define AVL_IRQ_ENABLE\t\t0x80\n#define AVL_IRQ_ASSERTED\t0x80\n \n#define GPIO_REG_IO\t\t0x4880\n#define GPIO_REG_IO_TOGGLE\t0x4882\n#define GPIO_REG_IO_SET\t\t0x4884\n#define GPIO_REG_IO_CLEAR\t0x4886\n \n#define GPIO_FEA_RESET\t\t(1 << 0)\n#define GPIO_FEB_RESET\t\t(1 << 1)\n#define GPIO_RFA_CTL\t\t(1 << 2)\n#define GPIO_RFB_CTL\t\t(1 << 3)\n#define GPIO_FEA_TU_RESET\t(1 << 4)\n#define GPIO_FEB_TU_RESET\t(1 << 5)\n \n#define NETUP_DMA0_ADDR\t\t0x4900\n#define NETUP_DMA1_ADDR\t\t0x4940\n \n#define NETUP_DMA_BLOCKS_COUNT\t8\n#define NETUP_DMA_PACKETS_COUNT\t128\n \n#define BIT_DMA_RUN\t\t1\n#define BIT_DMA_ERROR\t\t2\n#define BIT_DMA_IRQ\t\t0x200\n\n \nstruct netup_dma_regs {\n\t__le32\tctrlstat_set;\n\t__le32\tctrlstat_clear;\n\t__le32\tstart_addr_lo;\n\t__le32\tstart_addr_hi;\n\t__le32\tsize;\n\t__le32\ttimeout;\n\t__le32\tcurr_addr_lo;\n\t__le32\tcurr_addr_hi;\n\t__le32\tstat_pkt_received;\n\t__le32\tstat_pkt_accepted;\n\t__le32\tstat_pkt_overruns;\n\t__le32\tstat_pkt_underruns;\n\t__le32\tstat_fifo_overruns;\n} __packed __aligned(1);\n\nstruct netup_unidvb_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head\tlist;\n\tu32\t\t\tsize;\n};\n\nstatic int netup_unidvb_tuner_ctrl(void *priv, int is_dvb_tc);\nstatic void netup_unidvb_queue_cleanup(struct netup_dma *dma);\n\nstatic struct cxd2841er_config demod_config = {\n\t.i2c_addr = 0xc8,\n\t.xtal = SONY_XTAL_24000,\n\t.flags = CXD2841ER_USE_GATECTRL | CXD2841ER_ASCOT\n};\n\nstatic struct horus3a_config horus3a_conf = {\n\t.i2c_address = 0xc0,\n\t.xtal_freq_mhz = 16,\n\t.set_tuner_callback = netup_unidvb_tuner_ctrl\n};\n\nstatic struct ascot2e_config ascot2e_conf = {\n\t.i2c_address = 0xc2,\n\t.set_tuner_callback = netup_unidvb_tuner_ctrl\n};\n\nstatic struct helene_config helene_conf = {\n\t.i2c_address = 0xc0,\n\t.xtal = SONY_HELENE_XTAL_24000,\n\t.set_tuner_callback = netup_unidvb_tuner_ctrl\n};\n\nstatic struct lnbh25_config lnbh25_conf = {\n\t.i2c_address = 0x10,\n\t.data2_config = LNBH25_TEN | LNBH25_EXTM\n};\n\nstatic int netup_unidvb_tuner_ctrl(void *priv, int is_dvb_tc)\n{\n\tu8 reg, mask;\n\tstruct netup_dma *dma = priv;\n\tstruct netup_unidvb_dev *ndev;\n\n\tif (!priv)\n\t\treturn -EINVAL;\n\tndev = dma->ndev;\n\tdev_dbg(&ndev->pci_dev->dev, \"%s(): num %d is_dvb_tc %d\\n\",\n\t\t__func__, dma->num, is_dvb_tc);\n\treg = readb(ndev->bmmio0 + GPIO_REG_IO);\n\tmask = (dma->num == 0) ? GPIO_RFA_CTL : GPIO_RFB_CTL;\n\n\t \n\tif (ndev->rev == NETUP_HW_REV_1_4)\n\t\tis_dvb_tc = !is_dvb_tc;\n\n\tif (!is_dvb_tc)\n\t\treg |= mask;\n\telse\n\t\treg &= ~mask;\n\twriteb(reg, ndev->bmmio0 + GPIO_REG_IO);\n\treturn 0;\n}\n\nstatic void netup_unidvb_dev_enable(struct netup_unidvb_dev *ndev)\n{\n\tu16 gpio_reg;\n\n\t \n\twritel(AVL_IRQ_ENABLE, ndev->bmmio0 + AVL_PCIE_IENR);\n\t \n\twriteb(0x00, ndev->bmmio0 + GPIO_REG_IO);\n\tmsleep(100);\n\tgpio_reg =\n\t\tGPIO_FEA_RESET | GPIO_FEB_RESET |\n\t\tGPIO_FEA_TU_RESET | GPIO_FEB_TU_RESET |\n\t\tGPIO_RFA_CTL | GPIO_RFB_CTL;\n\twriteb(gpio_reg, ndev->bmmio0 + GPIO_REG_IO);\n\tdev_dbg(&ndev->pci_dev->dev,\n\t\t\"%s(): AVL_PCIE_IENR 0x%x GPIO_REG_IO 0x%x\\n\",\n\t\t__func__, readl(ndev->bmmio0 + AVL_PCIE_IENR),\n\t\t(int)readb(ndev->bmmio0 + GPIO_REG_IO));\n\n}\n\nstatic void netup_unidvb_dma_enable(struct netup_dma *dma, int enable)\n{\n\tu32 irq_mask = (dma->num == 0 ?\n\t\tNETUP_UNIDVB_IRQ_DMA1 : NETUP_UNIDVB_IRQ_DMA2);\n\n\tdev_dbg(&dma->ndev->pci_dev->dev,\n\t\t\"%s(): DMA%d enable %d\\n\", __func__, dma->num, enable);\n\tif (enable) {\n\t\twritel(BIT_DMA_RUN, &dma->regs->ctrlstat_set);\n\t\twritew(irq_mask, dma->ndev->bmmio0 + REG_IMASK_SET);\n\t} else {\n\t\twritel(BIT_DMA_RUN, &dma->regs->ctrlstat_clear);\n\t\twritew(irq_mask, dma->ndev->bmmio0 + REG_IMASK_CLEAR);\n\t}\n}\n\nstatic irqreturn_t netup_dma_interrupt(struct netup_dma *dma)\n{\n\tu64 addr_curr;\n\tu32 size;\n\tunsigned long flags;\n\tstruct device *dev = &dma->ndev->pci_dev->dev;\n\n\tspin_lock_irqsave(&dma->lock, flags);\n\taddr_curr = ((u64)readl(&dma->regs->curr_addr_hi) << 32) |\n\t\t(u64)readl(&dma->regs->curr_addr_lo) | dma->high_addr;\n\t \n\twritel(BIT_DMA_IRQ, &dma->regs->ctrlstat_clear);\n\t \n\tif (addr_curr < dma->addr_phys ||\n\t\t\taddr_curr > dma->addr_phys +  dma->ring_buffer_size) {\n\t\tif (addr_curr != 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s(): addr 0x%llx not from 0x%llx:0x%llx\\n\",\n\t\t\t\t__func__, addr_curr, (u64)dma->addr_phys,\n\t\t\t\t(u64)(dma->addr_phys + dma->ring_buffer_size));\n\t\t}\n\t\tgoto irq_handled;\n\t}\n\tsize = (addr_curr >= dma->addr_last) ?\n\t\t(u32)(addr_curr - dma->addr_last) :\n\t\t(u32)(dma->ring_buffer_size - (dma->addr_last - addr_curr));\n\tif (dma->data_size != 0) {\n\t\tprintk_ratelimited(\"%s(): lost interrupt, data size %d\\n\",\n\t\t\t__func__, dma->data_size);\n\t\tdma->data_size += size;\n\t}\n\tif (dma->data_size == 0 || dma->data_size > dma->ring_buffer_size) {\n\t\tdma->data_size = size;\n\t\tdma->data_offset = (u32)(dma->addr_last - dma->addr_phys);\n\t}\n\tdma->addr_last = addr_curr;\n\tqueue_work(dma->ndev->wq, &dma->work);\nirq_handled:\n\tspin_unlock_irqrestore(&dma->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t netup_unidvb_isr(int irq, void *dev_id)\n{\n\tstruct pci_dev *pci_dev = (struct pci_dev *)dev_id;\n\tstruct netup_unidvb_dev *ndev = pci_get_drvdata(pci_dev);\n\tu32 reg40, reg_isr;\n\tirqreturn_t iret = IRQ_NONE;\n\n\t \n\twritel(0, ndev->bmmio0 + AVL_PCIE_IENR);\n\t \n\treg40 = readl(ndev->bmmio0 + AVL_PCIE_ISR);\n\tif ((reg40 & AVL_IRQ_ASSERTED) != 0) {\n\t\t \n\t\treg_isr = readw(ndev->bmmio0 + REG_ISR);\n\t\tif (reg_isr & NETUP_UNIDVB_IRQ_SPI)\n\t\t\tiret = netup_spi_interrupt(ndev->spi);\n\t\telse if (!ndev->old_fw) {\n\t\t\tif (reg_isr & NETUP_UNIDVB_IRQ_I2C0) {\n\t\t\t\tiret = netup_i2c_interrupt(&ndev->i2c[0]);\n\t\t\t} else if (reg_isr & NETUP_UNIDVB_IRQ_I2C1) {\n\t\t\t\tiret = netup_i2c_interrupt(&ndev->i2c[1]);\n\t\t\t} else if (reg_isr & NETUP_UNIDVB_IRQ_DMA1) {\n\t\t\t\tiret = netup_dma_interrupt(&ndev->dma[0]);\n\t\t\t} else if (reg_isr & NETUP_UNIDVB_IRQ_DMA2) {\n\t\t\t\tiret = netup_dma_interrupt(&ndev->dma[1]);\n\t\t\t} else if (reg_isr & NETUP_UNIDVB_IRQ_CI) {\n\t\t\t\tiret = netup_ci_interrupt(ndev);\n\t\t\t} else {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\nerr:\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"%s(): unknown interrupt 0x%x\\n\",\n\t\t\t\t__func__, reg_isr);\n\t\t}\n\t}\n\t \n\twritel(AVL_IRQ_ENABLE, ndev->bmmio0 + AVL_PCIE_IENR);\n\treturn iret;\n}\n\nstatic int netup_unidvb_queue_setup(struct vb2_queue *vq,\n\t\t\t\t    unsigned int *nbuffers,\n\t\t\t\t    unsigned int *nplanes,\n\t\t\t\t    unsigned int sizes[],\n\t\t\t\t    struct device *alloc_devs[])\n{\n\tstruct netup_dma *dma = vb2_get_drv_priv(vq);\n\n\tdev_dbg(&dma->ndev->pci_dev->dev, \"%s()\\n\", __func__);\n\n\t*nplanes = 1;\n\tif (vq->num_buffers + *nbuffers < VIDEO_MAX_FRAME)\n\t\t*nbuffers = VIDEO_MAX_FRAME - vq->num_buffers;\n\tsizes[0] = PAGE_ALIGN(NETUP_DMA_PACKETS_COUNT * 188);\n\tdev_dbg(&dma->ndev->pci_dev->dev, \"%s() nbuffers=%d sizes[0]=%d\\n\",\n\t\t__func__, *nbuffers, sizes[0]);\n\treturn 0;\n}\n\nstatic int netup_unidvb_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct netup_dma *dma = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct netup_unidvb_buffer *buf = container_of(vbuf,\n\t\t\t\tstruct netup_unidvb_buffer, vb);\n\n\tdev_dbg(&dma->ndev->pci_dev->dev, \"%s(): buf 0x%p\\n\", __func__, buf);\n\tbuf->size = 0;\n\treturn 0;\n}\n\nstatic void netup_unidvb_buf_queue(struct vb2_buffer *vb)\n{\n\tunsigned long flags;\n\tstruct netup_dma *dma = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct netup_unidvb_buffer *buf = container_of(vbuf,\n\t\t\t\tstruct netup_unidvb_buffer, vb);\n\n\tdev_dbg(&dma->ndev->pci_dev->dev, \"%s(): %p\\n\", __func__, buf);\n\tspin_lock_irqsave(&dma->lock, flags);\n\tlist_add_tail(&buf->list, &dma->free_buffers);\n\tspin_unlock_irqrestore(&dma->lock, flags);\n\tmod_timer(&dma->timeout, jiffies + msecs_to_jiffies(1000));\n}\n\nstatic int netup_unidvb_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct netup_dma *dma = vb2_get_drv_priv(q);\n\n\tdev_dbg(&dma->ndev->pci_dev->dev, \"%s()\\n\", __func__);\n\tnetup_unidvb_dma_enable(dma, 1);\n\treturn 0;\n}\n\nstatic void netup_unidvb_stop_streaming(struct vb2_queue *q)\n{\n\tstruct netup_dma *dma = vb2_get_drv_priv(q);\n\n\tdev_dbg(&dma->ndev->pci_dev->dev, \"%s()\\n\", __func__);\n\tnetup_unidvb_dma_enable(dma, 0);\n\tnetup_unidvb_queue_cleanup(dma);\n}\n\nstatic const struct vb2_ops dvb_qops = {\n\t.queue_setup\t\t= netup_unidvb_queue_setup,\n\t.buf_prepare\t\t= netup_unidvb_buf_prepare,\n\t.buf_queue\t\t= netup_unidvb_buf_queue,\n\t.start_streaming\t= netup_unidvb_start_streaming,\n\t.stop_streaming\t\t= netup_unidvb_stop_streaming,\n};\n\nstatic int netup_unidvb_queue_init(struct netup_dma *dma,\n\t\t\t\t   struct vb2_queue *vb_queue)\n{\n\tint res;\n\n\t \n\tvb_queue->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tvb_queue->io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\tvb_queue->drv_priv = dma;\n\tvb_queue->buf_struct_size = sizeof(struct netup_unidvb_buffer);\n\tvb_queue->ops = &dvb_qops;\n\tvb_queue->mem_ops = &vb2_vmalloc_memops;\n\tvb_queue->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tres = vb2_queue_init(vb_queue);\n\tif (res != 0) {\n\t\tdev_err(&dma->ndev->pci_dev->dev,\n\t\t\t\"%s(): vb2_queue_init failed (%d)\\n\", __func__, res);\n\t}\n\treturn res;\n}\n\nstatic int netup_unidvb_dvb_init(struct netup_unidvb_dev *ndev,\n\t\t\t\t int num)\n{\n\tint fe_count = 2;\n\tint i = 0;\n\tstruct vb2_dvb_frontend *fes[2];\n\tu8 fe_name[32];\n\n\tif (ndev->rev == NETUP_HW_REV_1_3)\n\t\tdemod_config.xtal = SONY_XTAL_20500;\n\telse\n\t\tdemod_config.xtal = SONY_XTAL_24000;\n\n\tif (num < 0 || num > 1) {\n\t\tdev_dbg(&ndev->pci_dev->dev,\n\t\t\t\"%s(): unable to init DVB bus %d\\n\", __func__, num);\n\t\treturn -ENODEV;\n\t}\n\tmutex_init(&ndev->frontends[num].lock);\n\tINIT_LIST_HEAD(&ndev->frontends[num].felist);\n\n\tfor (i = 0; i < fe_count; i++) {\n\t\tif (vb2_dvb_alloc_frontend(&ndev->frontends[num], i+1)\n\t\t\t\t== NULL) {\n\t\t\tdev_err(&ndev->pci_dev->dev,\n\t\t\t\t\t\"%s(): unable to allocate vb2_dvb_frontend\\n\",\n\t\t\t\t\t__func__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < fe_count; i++) {\n\t\tfes[i] = vb2_dvb_get_frontend(&ndev->frontends[num], i+1);\n\t\tif (fes[i] == NULL) {\n\t\t\tdev_err(&ndev->pci_dev->dev,\n\t\t\t\t\"%s(): frontends has not been allocated\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < fe_count; i++) {\n\t\tnetup_unidvb_queue_init(&ndev->dma[num], &fes[i]->dvb.dvbq);\n\t\tsnprintf(fe_name, sizeof(fe_name), \"netup_fe%d\", i);\n\t\tfes[i]->dvb.name = fe_name;\n\t}\n\n\tfes[0]->dvb.frontend = dvb_attach(cxd2841er_attach_s,\n\t\t&demod_config, &ndev->i2c[num].adap);\n\tif (fes[0]->dvb.frontend == NULL) {\n\t\tdev_dbg(&ndev->pci_dev->dev,\n\t\t\t\"%s(): unable to attach DVB-S/S2 frontend\\n\",\n\t\t\t__func__);\n\t\tgoto frontend_detach;\n\t}\n\n\tif (ndev->rev == NETUP_HW_REV_1_3) {\n\t\thorus3a_conf.set_tuner_priv = &ndev->dma[num];\n\t\tif (!dvb_attach(horus3a_attach, fes[0]->dvb.frontend,\n\t\t\t\t\t&horus3a_conf, &ndev->i2c[num].adap)) {\n\t\t\tdev_dbg(&ndev->pci_dev->dev,\n\t\t\t\t\t\"%s(): unable to attach HORUS3A DVB-S/S2 tuner frontend\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto frontend_detach;\n\t\t}\n\t} else {\n\t\thelene_conf.set_tuner_priv = &ndev->dma[num];\n\t\tif (!dvb_attach(helene_attach_s, fes[0]->dvb.frontend,\n\t\t\t\t\t&helene_conf, &ndev->i2c[num].adap)) {\n\t\t\tdev_err(&ndev->pci_dev->dev,\n\t\t\t\t\t\"%s(): unable to attach HELENE DVB-S/S2 tuner frontend\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto frontend_detach;\n\t\t}\n\t}\n\n\tif (!dvb_attach(lnbh25_attach, fes[0]->dvb.frontend,\n\t\t\t&lnbh25_conf, &ndev->i2c[num].adap)) {\n\t\tdev_dbg(&ndev->pci_dev->dev,\n\t\t\t\"%s(): unable to attach SEC frontend\\n\", __func__);\n\t\tgoto frontend_detach;\n\t}\n\n\t \n\tfes[1]->dvb.frontend = dvb_attach(cxd2841er_attach_t_c,\n\t\t&demod_config, &ndev->i2c[num].adap);\n\tif (fes[1]->dvb.frontend == NULL) {\n\t\tdev_dbg(&ndev->pci_dev->dev,\n\t\t\t\"%s(): unable to attach Ter frontend\\n\", __func__);\n\t\tgoto frontend_detach;\n\t}\n\tfes[1]->dvb.frontend->id = 1;\n\tif (ndev->rev == NETUP_HW_REV_1_3) {\n\t\tascot2e_conf.set_tuner_priv = &ndev->dma[num];\n\t\tif (!dvb_attach(ascot2e_attach, fes[1]->dvb.frontend,\n\t\t\t\t\t&ascot2e_conf, &ndev->i2c[num].adap)) {\n\t\t\tdev_dbg(&ndev->pci_dev->dev,\n\t\t\t\t\t\"%s(): unable to attach Ter tuner frontend\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto frontend_detach;\n\t\t}\n\t} else {\n\t\thelene_conf.set_tuner_priv = &ndev->dma[num];\n\t\tif (!dvb_attach(helene_attach, fes[1]->dvb.frontend,\n\t\t\t\t\t&helene_conf, &ndev->i2c[num].adap)) {\n\t\t\tdev_err(&ndev->pci_dev->dev,\n\t\t\t\t\t\"%s(): unable to attach HELENE Ter tuner frontend\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto frontend_detach;\n\t\t}\n\t}\n\n\tif (vb2_dvb_register_bus(&ndev->frontends[num],\n\t\t\t\t THIS_MODULE, NULL,\n\t\t\t\t &ndev->pci_dev->dev, NULL, adapter_nr, 1)) {\n\t\tdev_dbg(&ndev->pci_dev->dev,\n\t\t\t\"%s(): unable to register DVB bus %d\\n\",\n\t\t\t__func__, num);\n\t\tgoto frontend_detach;\n\t}\n\tdev_info(&ndev->pci_dev->dev, \"DVB init done, num=%d\\n\", num);\n\treturn 0;\nfrontend_detach:\n\tvb2_dvb_dealloc_frontends(&ndev->frontends[num]);\n\treturn -EINVAL;\n}\n\nstatic void netup_unidvb_dvb_fini(struct netup_unidvb_dev *ndev, int num)\n{\n\tif (num < 0 || num > 1) {\n\t\tdev_err(&ndev->pci_dev->dev,\n\t\t\t\"%s(): unable to unregister DVB bus %d\\n\",\n\t\t\t__func__, num);\n\t\treturn;\n\t}\n\tvb2_dvb_unregister_bus(&ndev->frontends[num]);\n\tdev_info(&ndev->pci_dev->dev,\n\t\t\"%s(): DVB bus %d unregistered\\n\", __func__, num);\n}\n\nstatic int netup_unidvb_dvb_setup(struct netup_unidvb_dev *ndev)\n{\n\tint res;\n\n\tres = netup_unidvb_dvb_init(ndev, 0);\n\tif (res)\n\t\treturn res;\n\tres = netup_unidvb_dvb_init(ndev, 1);\n\tif (res) {\n\t\tnetup_unidvb_dvb_fini(ndev, 0);\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\nstatic int netup_unidvb_ring_copy(struct netup_dma *dma,\n\t\t\t\t  struct netup_unidvb_buffer *buf)\n{\n\tu32 copy_bytes, ring_bytes;\n\tu32 buff_bytes = NETUP_DMA_PACKETS_COUNT * 188 - buf->size;\n\tu8 *p = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\n\tstruct netup_unidvb_dev *ndev = dma->ndev;\n\n\tif (p == NULL) {\n\t\tdev_err(&ndev->pci_dev->dev,\n\t\t\t\"%s(): buffer is NULL\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tp += buf->size;\n\tif (dma->data_offset + dma->data_size > dma->ring_buffer_size) {\n\t\tring_bytes = dma->ring_buffer_size - dma->data_offset;\n\t\tcopy_bytes = (ring_bytes > buff_bytes) ?\n\t\t\tbuff_bytes : ring_bytes;\n\t\tmemcpy_fromio(p, (u8 __iomem *)(dma->addr_virt + dma->data_offset), copy_bytes);\n\t\tp += copy_bytes;\n\t\tbuf->size += copy_bytes;\n\t\tbuff_bytes -= copy_bytes;\n\t\tdma->data_size -= copy_bytes;\n\t\tdma->data_offset += copy_bytes;\n\t\tif (dma->data_offset == dma->ring_buffer_size)\n\t\t\tdma->data_offset = 0;\n\t}\n\tif (buff_bytes > 0) {\n\t\tring_bytes = dma->data_size;\n\t\tcopy_bytes = (ring_bytes > buff_bytes) ?\n\t\t\t\tbuff_bytes : ring_bytes;\n\t\tmemcpy_fromio(p, (u8 __iomem *)(dma->addr_virt + dma->data_offset), copy_bytes);\n\t\tbuf->size += copy_bytes;\n\t\tdma->data_size -= copy_bytes;\n\t\tdma->data_offset += copy_bytes;\n\t\tif (dma->data_offset == dma->ring_buffer_size)\n\t\t\tdma->data_offset = 0;\n\t}\n\treturn 0;\n}\n\nstatic void netup_unidvb_dma_worker(struct work_struct *work)\n{\n\tstruct netup_dma *dma = container_of(work, struct netup_dma, work);\n\tstruct netup_unidvb_dev *ndev = dma->ndev;\n\tstruct netup_unidvb_buffer *buf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dma->lock, flags);\n\tif (dma->data_size == 0) {\n\t\tdev_dbg(&ndev->pci_dev->dev,\n\t\t\t\"%s(): data_size == 0\\n\", __func__);\n\t\tgoto work_done;\n\t}\n\twhile (dma->data_size > 0) {\n\t\tif (list_empty(&dma->free_buffers)) {\n\t\t\tdev_dbg(&ndev->pci_dev->dev,\n\t\t\t\t\"%s(): no free buffers\\n\", __func__);\n\t\t\tgoto work_done;\n\t\t}\n\t\tbuf = list_first_entry(&dma->free_buffers,\n\t\t\tstruct netup_unidvb_buffer, list);\n\t\tif (buf->size >= NETUP_DMA_PACKETS_COUNT * 188) {\n\t\t\tdev_dbg(&ndev->pci_dev->dev,\n\t\t\t\t\"%s(): buffer overflow, size %d\\n\",\n\t\t\t\t__func__, buf->size);\n\t\t\tgoto work_done;\n\t\t}\n\t\tif (netup_unidvb_ring_copy(dma, buf))\n\t\t\tgoto work_done;\n\t\tif (buf->size == NETUP_DMA_PACKETS_COUNT * 188) {\n\t\t\tlist_del(&buf->list);\n\t\t\tdev_dbg(&ndev->pci_dev->dev,\n\t\t\t\t\"%s(): buffer %p done, size %d\\n\",\n\t\t\t\t__func__, buf, buf->size);\n\t\t\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\t\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t\t}\n\t}\nwork_done:\n\tdma->data_size = 0;\n\tspin_unlock_irqrestore(&dma->lock, flags);\n}\n\nstatic void netup_unidvb_queue_cleanup(struct netup_dma *dma)\n{\n\tstruct netup_unidvb_buffer *buf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dma->lock, flags);\n\twhile (!list_empty(&dma->free_buffers)) {\n\t\tbuf = list_first_entry(&dma->free_buffers,\n\t\t\tstruct netup_unidvb_buffer, list);\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&dma->lock, flags);\n}\n\nstatic void netup_unidvb_dma_timeout(struct timer_list *t)\n{\n\tstruct netup_dma *dma = from_timer(dma, t, timeout);\n\tstruct netup_unidvb_dev *ndev = dma->ndev;\n\n\tdev_dbg(&ndev->pci_dev->dev, \"%s()\\n\", __func__);\n\tnetup_unidvb_queue_cleanup(dma);\n}\n\nstatic int netup_unidvb_dma_init(struct netup_unidvb_dev *ndev, int num)\n{\n\tstruct netup_dma *dma;\n\tstruct device *dev = &ndev->pci_dev->dev;\n\n\tif (num < 0 || num > 1) {\n\t\tdev_err(dev, \"%s(): unable to register DMA%d\\n\",\n\t\t\t__func__, num);\n\t\treturn -ENODEV;\n\t}\n\tdma = &ndev->dma[num];\n\tdev_info(dev, \"%s(): starting DMA%d\\n\", __func__, num);\n\tdma->num = num;\n\tdma->ndev = ndev;\n\tspin_lock_init(&dma->lock);\n\tINIT_WORK(&dma->work, netup_unidvb_dma_worker);\n\tINIT_LIST_HEAD(&dma->free_buffers);\n\ttimer_setup(&dma->timeout, netup_unidvb_dma_timeout, 0);\n\tdma->ring_buffer_size = ndev->dma_size / 2;\n\tdma->addr_virt = ndev->dma_virt + dma->ring_buffer_size * num;\n\tdma->addr_phys = (dma_addr_t)((u64)ndev->dma_phys +\n\t\tdma->ring_buffer_size * num);\n\tdev_info(dev, \"%s(): DMA%d buffer virt/phys 0x%p/0x%llx size %d\\n\",\n\t\t__func__, num, dma->addr_virt,\n\t\t(unsigned long long)dma->addr_phys,\n\t\tdma->ring_buffer_size);\n\tmemset_io((u8 __iomem *)dma->addr_virt, 0, dma->ring_buffer_size);\n\tdma->addr_last = dma->addr_phys;\n\tdma->high_addr = (u32)(dma->addr_phys & 0xC0000000);\n\tdma->regs = (struct netup_dma_regs __iomem *)(num == 0 ?\n\t\tndev->bmmio0 + NETUP_DMA0_ADDR :\n\t\tndev->bmmio0 + NETUP_DMA1_ADDR);\n\twritel((NETUP_DMA_BLOCKS_COUNT << 24) |\n\t\t(NETUP_DMA_PACKETS_COUNT << 8) | 188, &dma->regs->size);\n\twritel((u32)(dma->addr_phys & 0x3FFFFFFF), &dma->regs->start_addr_lo);\n\twritel(0, &dma->regs->start_addr_hi);\n\twritel(dma->high_addr, ndev->bmmio0 + 0x1000);\n\twritel(375000000, &dma->regs->timeout);\n\tmsleep(1000);\n\twritel(BIT_DMA_IRQ, &dma->regs->ctrlstat_clear);\n\treturn 0;\n}\n\nstatic void netup_unidvb_dma_fini(struct netup_unidvb_dev *ndev, int num)\n{\n\tstruct netup_dma *dma;\n\n\tif (num < 0 || num > 1)\n\t\treturn;\n\tdev_dbg(&ndev->pci_dev->dev, \"%s(): num %d\\n\", __func__, num);\n\tdma = &ndev->dma[num];\n\tnetup_unidvb_dma_enable(dma, 0);\n\tmsleep(50);\n\tcancel_work_sync(&dma->work);\n\tdel_timer_sync(&dma->timeout);\n}\n\nstatic int netup_unidvb_dma_setup(struct netup_unidvb_dev *ndev)\n{\n\tint res;\n\n\tres = netup_unidvb_dma_init(ndev, 0);\n\tif (res)\n\t\treturn res;\n\tres = netup_unidvb_dma_init(ndev, 1);\n\tif (res) {\n\t\tnetup_unidvb_dma_fini(ndev, 0);\n\t\treturn res;\n\t}\n\tnetup_unidvb_dma_enable(&ndev->dma[0], 0);\n\tnetup_unidvb_dma_enable(&ndev->dma[1], 0);\n\treturn 0;\n}\n\nstatic int netup_unidvb_ci_setup(struct netup_unidvb_dev *ndev,\n\t\t\t\t struct pci_dev *pci_dev)\n{\n\tint res;\n\n\twritew(NETUP_UNIDVB_IRQ_CI, ndev->bmmio0 + REG_IMASK_SET);\n\tres = netup_unidvb_ci_register(ndev, 0, pci_dev);\n\tif (res)\n\t\treturn res;\n\tres = netup_unidvb_ci_register(ndev, 1, pci_dev);\n\tif (res)\n\t\tnetup_unidvb_ci_unregister(ndev, 0);\n\treturn res;\n}\n\nstatic int netup_unidvb_request_mmio(struct pci_dev *pci_dev)\n{\n\tif (!request_mem_region(pci_resource_start(pci_dev, 0),\n\t\t\tpci_resource_len(pci_dev, 0), NETUP_UNIDVB_NAME)) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"%s(): unable to request MMIO bar 0 at 0x%llx\\n\",\n\t\t\t__func__,\n\t\t\t(unsigned long long)pci_resource_start(pci_dev, 0));\n\t\treturn -EBUSY;\n\t}\n\tif (!request_mem_region(pci_resource_start(pci_dev, 1),\n\t\t\tpci_resource_len(pci_dev, 1), NETUP_UNIDVB_NAME)) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"%s(): unable to request MMIO bar 1 at 0x%llx\\n\",\n\t\t\t__func__,\n\t\t\t(unsigned long long)pci_resource_start(pci_dev, 1));\n\t\trelease_mem_region(pci_resource_start(pci_dev, 0),\n\t\t\tpci_resource_len(pci_dev, 0));\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int netup_unidvb_request_modules(struct device *dev)\n{\n\tstatic const char * const modules[] = {\n\t\t\"lnbh25\", \"ascot2e\", \"horus3a\", \"cxd2841er\", \"helene\", NULL\n\t};\n\tconst char * const *curr_mod = modules;\n\tint err;\n\n\twhile (*curr_mod != NULL) {\n\t\terr = request_module(*curr_mod);\n\t\tif (err) {\n\t\t\tdev_warn(dev, \"request_module(%s) failed: %d\\n\",\n\t\t\t\t*curr_mod, err);\n\t\t}\n\t\t++curr_mod;\n\t}\n\treturn 0;\n}\n\nstatic int netup_unidvb_initdev(struct pci_dev *pci_dev,\n\t\t\t\tconst struct pci_device_id *pci_id)\n{\n\tu8 board_revision;\n\tu16 board_vendor;\n\tstruct netup_unidvb_dev *ndev;\n\tint old_firmware = 0;\n\n\tnetup_unidvb_request_modules(&pci_dev->dev);\n\n\t \n\tif (pci_dev->revision != NETUP_PCI_DEV_REVISION) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"netup_unidvb: expected card revision %d, got %d\\n\",\n\t\t\tNETUP_PCI_DEV_REVISION, pci_dev->revision);\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"Please upgrade firmware!\\n\");\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"Instructions on http://www.netup.tv\\n\");\n\t\told_firmware = 1;\n\t\tspi_enable = 1;\n\t}\n\n\t \n\tndev = kzalloc(sizeof(*ndev), GFP_KERNEL);\n\tif (!ndev)\n\t\tgoto dev_alloc_err;\n\n\t \n\tif (pci_dev->device == NETUP_HW_REV_1_3)\n\t\tndev->rev = NETUP_HW_REV_1_3;\n\telse\n\t\tndev->rev = NETUP_HW_REV_1_4;\n\n\tdev_info(&pci_dev->dev,\n\t\t\"%s(): board (0x%x) hardware revision 0x%x\\n\",\n\t\t__func__, pci_dev->device, ndev->rev);\n\n\tndev->old_fw = old_firmware;\n\tndev->wq = create_singlethread_workqueue(NETUP_UNIDVB_NAME);\n\tif (!ndev->wq) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"%s(): unable to create workqueue\\n\", __func__);\n\t\tgoto wq_create_err;\n\t}\n\tndev->pci_dev = pci_dev;\n\tndev->pci_bus = pci_dev->bus->number;\n\tndev->pci_slot = PCI_SLOT(pci_dev->devfn);\n\tndev->pci_func = PCI_FUNC(pci_dev->devfn);\n\tndev->board_num = ndev->pci_bus*10 + ndev->pci_slot;\n\tpci_set_drvdata(pci_dev, ndev);\n\t \n\tdev_info(&pci_dev->dev, \"%s(): PCI device (%d). Bus:0x%x Slot:0x%x\\n\",\n\t\t__func__, ndev->board_num, ndev->pci_bus, ndev->pci_slot);\n\n\tif (pci_enable_device(pci_dev)) {\n\t\tdev_err(&pci_dev->dev, \"%s(): pci_enable_device failed\\n\",\n\t\t\t__func__);\n\t\tgoto pci_enable_err;\n\t}\n\t \n\tpci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &board_revision);\n\tpci_read_config_word(pci_dev, PCI_VENDOR_ID, &board_vendor);\n\tif (board_vendor != NETUP_VENDOR_ID) {\n\t\tdev_err(&pci_dev->dev, \"%s(): unknown board vendor 0x%x\",\n\t\t\t__func__, board_vendor);\n\t\tgoto pci_detect_err;\n\t}\n\tdev_info(&pci_dev->dev,\n\t\t\"%s(): board vendor 0x%x, revision 0x%x\\n\",\n\t\t__func__, board_vendor, board_revision);\n\tpci_set_master(pci_dev);\n\tif (dma_set_mask(&pci_dev->dev, 0xffffffff) < 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"%s(): 32bit PCI DMA is not supported\\n\", __func__);\n\t\tgoto pci_detect_err;\n\t}\n\tdev_info(&pci_dev->dev, \"%s(): using 32bit PCI DMA\\n\", __func__);\n\t \n\tpcie_capability_clear_and_set_word(pci_dev, PCI_EXP_DEVCTL,\n\t\tPCI_EXP_DEVCTL_READRQ | PCI_EXP_DEVCTL_RELAX_EN |\n\t\tPCI_EXP_DEVCTL_NOSNOOP_EN, 0);\n\t \n\tpcie_capability_clear_and_set_word(pci_dev,\n\t\tPCI_EXP_DEVCTL2, PCI_EXP_DEVCTL2_COMP_TIMEOUT, 0x2);\n\n\tif (netup_unidvb_request_mmio(pci_dev)) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"%s(): unable to request MMIO regions\\n\", __func__);\n\t\tgoto pci_detect_err;\n\t}\n\tndev->lmmio0 = ioremap(pci_resource_start(pci_dev, 0),\n\t\tpci_resource_len(pci_dev, 0));\n\tif (!ndev->lmmio0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"%s(): unable to remap MMIO bar 0\\n\", __func__);\n\t\tgoto pci_bar0_error;\n\t}\n\tndev->lmmio1 = ioremap(pci_resource_start(pci_dev, 1),\n\t\tpci_resource_len(pci_dev, 1));\n\tif (!ndev->lmmio1) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"%s(): unable to remap MMIO bar 1\\n\", __func__);\n\t\tgoto pci_bar1_error;\n\t}\n\tndev->bmmio0 = (u8 __iomem *)ndev->lmmio0;\n\tndev->bmmio1 = (u8 __iomem *)ndev->lmmio1;\n\tdev_info(&pci_dev->dev,\n\t\t\"%s(): PCI MMIO at 0x%p (%d); 0x%p (%d); IRQ %d\",\n\t\t__func__,\n\t\tndev->lmmio0, (u32)pci_resource_len(pci_dev, 0),\n\t\tndev->lmmio1, (u32)pci_resource_len(pci_dev, 1),\n\t\tpci_dev->irq);\n\n\tndev->dma_size = 2 * 188 *\n\t\tNETUP_DMA_BLOCKS_COUNT * NETUP_DMA_PACKETS_COUNT;\n\tndev->dma_virt = dma_alloc_coherent(&pci_dev->dev,\n\t\tndev->dma_size, &ndev->dma_phys, GFP_KERNEL);\n\tif (!ndev->dma_virt) {\n\t\tdev_err(&pci_dev->dev, \"%s(): unable to allocate DMA buffer\\n\",\n\t\t\t__func__);\n\t\tgoto dma_alloc_err;\n\t}\n\tnetup_unidvb_dev_enable(ndev);\n\tif (spi_enable && netup_spi_init(ndev)) {\n\t\tdev_warn(&pci_dev->dev,\n\t\t\t\"netup_unidvb: SPI flash setup failed\\n\");\n\t\tgoto spi_setup_err;\n\t}\n\tif (old_firmware) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"netup_unidvb: card initialization was incomplete\\n\");\n\t\treturn 0;\n\t}\n\tif (netup_i2c_register(ndev)) {\n\t\tdev_err(&pci_dev->dev, \"netup_unidvb: I2C setup failed\\n\");\n\t\tgoto i2c_setup_err;\n\t}\n\t \n\twritew(NETUP_UNIDVB_IRQ_I2C0 | NETUP_UNIDVB_IRQ_I2C1,\n\t\tndev->bmmio0 + REG_IMASK_SET);\n\tusleep_range(5000, 10000);\n\tif (netup_unidvb_dvb_setup(ndev)) {\n\t\tdev_err(&pci_dev->dev, \"netup_unidvb: DVB setup failed\\n\");\n\t\tgoto dvb_setup_err;\n\t}\n\tif (netup_unidvb_ci_setup(ndev, pci_dev)) {\n\t\tdev_err(&pci_dev->dev, \"netup_unidvb: CI setup failed\\n\");\n\t\tgoto ci_setup_err;\n\t}\n\tif (netup_unidvb_dma_setup(ndev)) {\n\t\tdev_err(&pci_dev->dev, \"netup_unidvb: DMA setup failed\\n\");\n\t\tgoto dma_setup_err;\n\t}\n\n\tif (request_irq(pci_dev->irq, netup_unidvb_isr, IRQF_SHARED,\n\t\t\t\"netup_unidvb\", pci_dev) < 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"%s(): can't get IRQ %d\\n\", __func__, pci_dev->irq);\n\t\tgoto dma_setup_err;\n\t}\n\n\tdev_info(&pci_dev->dev,\n\t\t\"netup_unidvb: device has been initialized\\n\");\n\treturn 0;\ndma_setup_err:\n\tnetup_unidvb_ci_unregister(ndev, 0);\n\tnetup_unidvb_ci_unregister(ndev, 1);\nci_setup_err:\n\tnetup_unidvb_dvb_fini(ndev, 0);\n\tnetup_unidvb_dvb_fini(ndev, 1);\ndvb_setup_err:\n\tnetup_i2c_unregister(ndev);\ni2c_setup_err:\n\tif (ndev->spi)\n\t\tnetup_spi_release(ndev);\nspi_setup_err:\n\tdma_free_coherent(&pci_dev->dev, ndev->dma_size,\n\t\t\tndev->dma_virt, ndev->dma_phys);\ndma_alloc_err:\n\tiounmap(ndev->lmmio1);\npci_bar1_error:\n\tiounmap(ndev->lmmio0);\npci_bar0_error:\n\trelease_mem_region(pci_resource_start(pci_dev, 0),\n\t\tpci_resource_len(pci_dev, 0));\n\trelease_mem_region(pci_resource_start(pci_dev, 1),\n\t\tpci_resource_len(pci_dev, 1));\npci_detect_err:\n\tpci_disable_device(pci_dev);\npci_enable_err:\n\tpci_set_drvdata(pci_dev, NULL);\n\tdestroy_workqueue(ndev->wq);\nwq_create_err:\n\tkfree(ndev);\ndev_alloc_err:\n\tdev_err(&pci_dev->dev,\n\t\t\"%s(): failed to initialize device\\n\", __func__);\n\treturn -EIO;\n}\n\nstatic void netup_unidvb_finidev(struct pci_dev *pci_dev)\n{\n\tstruct netup_unidvb_dev *ndev = pci_get_drvdata(pci_dev);\n\n\tdev_info(&pci_dev->dev, \"%s(): trying to stop device\\n\", __func__);\n\tif (!ndev->old_fw) {\n\t\tnetup_unidvb_dma_fini(ndev, 0);\n\t\tnetup_unidvb_dma_fini(ndev, 1);\n\t\tnetup_unidvb_ci_unregister(ndev, 0);\n\t\tnetup_unidvb_ci_unregister(ndev, 1);\n\t\tnetup_unidvb_dvb_fini(ndev, 0);\n\t\tnetup_unidvb_dvb_fini(ndev, 1);\n\t\tnetup_i2c_unregister(ndev);\n\t}\n\tif (ndev->spi)\n\t\tnetup_spi_release(ndev);\n\twritew(0xffff, ndev->bmmio0 + REG_IMASK_CLEAR);\n\tdma_free_coherent(&ndev->pci_dev->dev, ndev->dma_size,\n\t\t\tndev->dma_virt, ndev->dma_phys);\n\tfree_irq(pci_dev->irq, pci_dev);\n\tiounmap(ndev->lmmio0);\n\tiounmap(ndev->lmmio1);\n\trelease_mem_region(pci_resource_start(pci_dev, 0),\n\t\tpci_resource_len(pci_dev, 0));\n\trelease_mem_region(pci_resource_start(pci_dev, 1),\n\t\tpci_resource_len(pci_dev, 1));\n\tpci_disable_device(pci_dev);\n\tpci_set_drvdata(pci_dev, NULL);\n\tdestroy_workqueue(ndev->wq);\n\tkfree(ndev);\n\tdev_info(&pci_dev->dev,\n\t\t\"%s(): device has been successfully stopped\\n\", __func__);\n}\n\n\nstatic const struct pci_device_id netup_unidvb_pci_tbl[] = {\n\t{ PCI_DEVICE(0x1b55, 0x18f6) },  \n\t{ PCI_DEVICE(0x1b55, 0x18f7) },  \n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, netup_unidvb_pci_tbl);\n\nstatic struct pci_driver netup_unidvb_pci_driver = {\n\t.name     = \"netup_unidvb\",\n\t.id_table = netup_unidvb_pci_tbl,\n\t.probe    = netup_unidvb_initdev,\n\t.remove   = netup_unidvb_finidev,\n};\n\nmodule_pci_driver(netup_unidvb_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}