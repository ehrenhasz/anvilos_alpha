{
  "module_name": "netup_unidvb_ci.c",
  "hash_id": "a4795d88f8fb3c42c171b0465884ae5af56ec0db8429e4f6be7e7d35251e29a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/netup_unidvb/netup_unidvb_ci.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include \"netup_unidvb.h\"\n\n \n#define CAM0_CONFIG\t\t0x0\n#define CAM0_IO\t\t\t0x8000\n#define CAM0_MEM\t\t0x10000\n#define CAM0_SZ\t\t\t32\n \n#define CAM1_CONFIG\t\t0x20000\n#define CAM1_IO\t\t\t0x28000\n#define CAM1_MEM\t\t0x30000\n#define CAM1_SZ\t\t\t32\n \n#define CAM_CTRLSTAT_READ_SET\t0x4980\n#define CAM_CTRLSTAT_CLR\t0x4982\n \n#define BIT_CAM_STCHG\t\t(1<<0)\n#define BIT_CAM_PRESENT\t\t(1<<1)\n#define BIT_CAM_RESET\t\t(1<<2)\n#define BIT_CAM_BYPASS\t\t(1<<3)\n#define BIT_CAM_READY\t\t(1<<4)\n#define BIT_CAM_ERROR\t\t(1<<5)\n#define BIT_CAM_OVERCURR\t(1<<6)\n \n#define CAM1_SHIFT 8\n\nirqreturn_t netup_ci_interrupt(struct netup_unidvb_dev *ndev)\n{\n\twritew(0x101, ndev->bmmio0 + CAM_CTRLSTAT_CLR);\n\treturn IRQ_HANDLED;\n}\n\nstatic int netup_unidvb_ci_slot_ts_ctl(struct dvb_ca_en50221 *en50221,\n\t\t\t\t       int slot)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\tstruct netup_unidvb_dev *dev = state->dev;\n\tu16 shift = (state->nr == 1) ? CAM1_SHIFT : 0;\n\n\tdev_dbg(&dev->pci_dev->dev, \"%s(): CAM_CTRLSTAT=0x%x\\n\",\n\t\t__func__, readw(dev->bmmio0 + CAM_CTRLSTAT_READ_SET));\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\t \n\twritew(BIT_CAM_BYPASS << shift, dev->bmmio0 + CAM_CTRLSTAT_CLR);\n\tdev_dbg(&dev->pci_dev->dev, \"%s(): CAM_CTRLSTAT=0x%x done\\n\",\n\t\t__func__, readw(dev->bmmio0 + CAM_CTRLSTAT_READ_SET));\n\treturn 0;\n}\n\nstatic int netup_unidvb_ci_slot_shutdown(struct dvb_ca_en50221 *en50221,\n\t\t\t\t\t int slot)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\tstruct netup_unidvb_dev *dev = state->dev;\n\n\tdev_dbg(&dev->pci_dev->dev, \"%s()\\n\", __func__);\n\treturn 0;\n}\n\nstatic int netup_unidvb_ci_slot_reset(struct dvb_ca_en50221 *en50221,\n\t\t\t\t      int slot)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\tstruct netup_unidvb_dev *dev = state->dev;\n\tunsigned long timeout = 0;\n\tu16 shift = (state->nr == 1) ? CAM1_SHIFT : 0;\n\tu16 ci_stat = 0;\n\tint reset_counter = 3;\n\n\tdev_dbg(&dev->pci_dev->dev, \"%s(): CAM_CTRLSTAT_READ_SET=0x%x\\n\",\n\t\t__func__, readw(dev->bmmio0 + CAM_CTRLSTAT_READ_SET));\nreset:\n\ttimeout = jiffies + msecs_to_jiffies(5000);\n\t \n\twritew(BIT_CAM_RESET << shift, dev->bmmio0 + CAM_CTRLSTAT_READ_SET);\n\tdev_dbg(&dev->pci_dev->dev, \"%s(): waiting for reset\\n\", __func__);\n\t \n\twhile (time_before(jiffies, timeout)) {\n\t\tci_stat = readw(dev->bmmio0 + CAM_CTRLSTAT_READ_SET);\n\t\tif (ci_stat & (BIT_CAM_READY << shift))\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n\tif (!(ci_stat & (BIT_CAM_READY << shift)) && reset_counter > 0) {\n\t\tdev_dbg(&dev->pci_dev->dev,\n\t\t\t\"%s(): CAMP reset timeout! Will try again..\\n\",\n\t\t\t __func__);\n\t\treset_counter--;\n\t\tgoto reset;\n\t}\n\treturn 0;\n}\n\nstatic int netup_unidvb_poll_ci_slot_status(struct dvb_ca_en50221 *en50221,\n\t\t\t\t\t    int slot, int open)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\tstruct netup_unidvb_dev *dev = state->dev;\n\tu16 shift = (state->nr == 1) ? CAM1_SHIFT : 0;\n\tu16 ci_stat = 0;\n\n\tdev_dbg(&dev->pci_dev->dev, \"%s(): CAM_CTRLSTAT_READ_SET=0x%x\\n\",\n\t\t__func__, readw(dev->bmmio0 + CAM_CTRLSTAT_READ_SET));\n\tci_stat = readw(dev->bmmio0 + CAM_CTRLSTAT_READ_SET);\n\tif (ci_stat & (BIT_CAM_READY << shift)) {\n\t\tstate->status = DVB_CA_EN50221_POLL_CAM_PRESENT |\n\t\t\tDVB_CA_EN50221_POLL_CAM_READY;\n\t} else if (ci_stat & (BIT_CAM_PRESENT << shift)) {\n\t\tstate->status = DVB_CA_EN50221_POLL_CAM_PRESENT;\n\t} else {\n\t\tstate->status = 0;\n\t}\n\treturn state->status;\n}\n\nstatic int netup_unidvb_ci_read_attribute_mem(struct dvb_ca_en50221 *en50221,\n\t\t\t\t\t      int slot, int addr)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\tstruct netup_unidvb_dev *dev = state->dev;\n\tu8 val = *((u8 __force *)state->membase8_config + addr);\n\n\tdev_dbg(&dev->pci_dev->dev,\n\t\t\"%s(): addr=0x%x val=0x%x\\n\", __func__, addr, val);\n\treturn val;\n}\n\nstatic int netup_unidvb_ci_write_attribute_mem(struct dvb_ca_en50221 *en50221,\n\t\t\t\t\t       int slot, int addr, u8 data)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\tstruct netup_unidvb_dev *dev = state->dev;\n\n\tdev_dbg(&dev->pci_dev->dev,\n\t\t\"%s(): addr=0x%x data=0x%x\\n\", __func__, addr, data);\n\t*((u8 __force *)state->membase8_config + addr) = data;\n\treturn 0;\n}\n\nstatic int netup_unidvb_ci_read_cam_ctl(struct dvb_ca_en50221 *en50221,\n\t\t\t\t\tint slot, u8 addr)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\tstruct netup_unidvb_dev *dev = state->dev;\n\tu8 val = *((u8 __force *)state->membase8_io + addr);\n\n\tdev_dbg(&dev->pci_dev->dev,\n\t\t\"%s(): addr=0x%x val=0x%x\\n\", __func__, addr, val);\n\treturn val;\n}\n\nstatic int netup_unidvb_ci_write_cam_ctl(struct dvb_ca_en50221 *en50221,\n\t\t\t\t\t int slot, u8 addr, u8 data)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\tstruct netup_unidvb_dev *dev = state->dev;\n\n\tdev_dbg(&dev->pci_dev->dev,\n\t\t\"%s(): addr=0x%x data=0x%x\\n\", __func__, addr, data);\n\t*((u8 __force *)state->membase8_io + addr) = data;\n\treturn 0;\n}\n\nint netup_unidvb_ci_register(struct netup_unidvb_dev *dev,\n\t\t\t     int num, struct pci_dev *pci_dev)\n{\n\tint result;\n\tstruct netup_ci_state *state;\n\n\tif (num < 0 || num > 1) {\n\t\tdev_err(&pci_dev->dev, \"%s(): invalid CI adapter %d\\n\",\n\t\t\t__func__, num);\n\t\treturn -EINVAL;\n\t}\n\tstate = &dev->ci[num];\n\tstate->nr = num;\n\tstate->membase8_config = dev->bmmio1 +\n\t\t((num == 0) ? CAM0_CONFIG : CAM1_CONFIG);\n\tstate->membase8_io = dev->bmmio1 +\n\t\t((num == 0) ? CAM0_IO : CAM1_IO);\n\tstate->dev = dev;\n\tstate->ca.owner = THIS_MODULE;\n\tstate->ca.read_attribute_mem = netup_unidvb_ci_read_attribute_mem;\n\tstate->ca.write_attribute_mem = netup_unidvb_ci_write_attribute_mem;\n\tstate->ca.read_cam_control = netup_unidvb_ci_read_cam_ctl;\n\tstate->ca.write_cam_control = netup_unidvb_ci_write_cam_ctl;\n\tstate->ca.slot_reset = netup_unidvb_ci_slot_reset;\n\tstate->ca.slot_shutdown = netup_unidvb_ci_slot_shutdown;\n\tstate->ca.slot_ts_enable = netup_unidvb_ci_slot_ts_ctl;\n\tstate->ca.poll_slot_status = netup_unidvb_poll_ci_slot_status;\n\tstate->ca.data = state;\n\tresult = dvb_ca_en50221_init(&dev->frontends[num].adapter,\n\t\t&state->ca, 0, 1);\n\tif (result < 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"%s(): dvb_ca_en50221_init result %d\\n\",\n\t\t\t__func__, result);\n\t\treturn result;\n\t}\n\twritew(NETUP_UNIDVB_IRQ_CI, dev->bmmio0 + REG_IMASK_SET);\n\tdev_info(&pci_dev->dev,\n\t\t\"%s(): CI adapter %d init done\\n\", __func__, num);\n\treturn 0;\n}\n\nvoid netup_unidvb_ci_unregister(struct netup_unidvb_dev *dev, int num)\n{\n\tstruct netup_ci_state *state;\n\n\tdev_dbg(&dev->pci_dev->dev, \"%s()\\n\", __func__);\n\tif (num < 0 || num > 1) {\n\t\tdev_err(&dev->pci_dev->dev, \"%s(): invalid CI adapter %d\\n\",\n\t\t\t\t__func__, num);\n\t\treturn;\n\t}\n\tstate = &dev->ci[num];\n\tdvb_ca_en50221_release(&state->ca);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}