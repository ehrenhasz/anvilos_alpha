{
  "module_name": "netup_unidvb_spi.c",
  "hash_id": "466c9e928a1bd51d0e8d933934344eac9902410d840954d7e751501a0be68778",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/netup_unidvb/netup_unidvb_spi.c",
  "human_readable_source": "\n \n\n#include \"netup_unidvb.h\"\n#include <linux/spi/spi.h>\n#include <linux/spi/flash.h>\n#include <linux/mtd/partitions.h>\n#include <mtd/mtd-abi.h>\n\n#define NETUP_SPI_CTRL_IRQ\t0x1000\n#define NETUP_SPI_CTRL_IMASK\t0x2000\n#define NETUP_SPI_CTRL_START\t0x8000\n#define NETUP_SPI_CTRL_LAST_CS\t0x4000\n\n#define NETUP_SPI_TIMEOUT\t6000\n\nenum netup_spi_state {\n\tSPI_STATE_START,\n\tSPI_STATE_DONE,\n};\n\nstruct netup_spi_regs {\n\t__u8\tdata[1024];\n\t__le16\tcontrol_stat;\n\t__le16\tclock_divider;\n} __packed __aligned(1);\n\nstruct netup_spi {\n\tstruct device\t\t\t*dev;\n\tstruct spi_master\t\t*master;\n\tstruct netup_spi_regs __iomem\t*regs;\n\tu8 __iomem\t\t\t*mmio;\n\tspinlock_t\t\t\tlock;\n\twait_queue_head_t\t\twaitq;\n\tenum netup_spi_state\t\tstate;\n};\n\nstatic char netup_spi_name[64] = \"fpga\";\n\nstatic struct mtd_partition netup_spi_flash_partitions = {\n\t.name = netup_spi_name,\n\t.size = 0x1000000,  \n\t.offset = 0,\n\t.mask_flags = MTD_CAP_ROM\n};\n\nstatic struct flash_platform_data spi_flash_data = {\n\t.name = \"netup0_m25p128\",\n\t.parts = &netup_spi_flash_partitions,\n\t.nr_parts = 1,\n};\n\nstatic struct spi_board_info netup_spi_board = {\n\t.modalias = \"m25p128\",\n\t.max_speed_hz = 11000000,\n\t.chip_select = 0,\n\t.mode = SPI_MODE_0,\n\t.platform_data = &spi_flash_data,\n};\n\nirqreturn_t netup_spi_interrupt(struct netup_spi *spi)\n{\n\tu16 reg;\n\tunsigned long flags;\n\n\tif (!spi)\n\t\treturn IRQ_NONE;\n\n\tspin_lock_irqsave(&spi->lock, flags);\n\treg = readw(&spi->regs->control_stat);\n\tif (!(reg & NETUP_SPI_CTRL_IRQ)) {\n\t\tspin_unlock_irqrestore(&spi->lock, flags);\n\t\tdev_dbg(&spi->master->dev,\n\t\t\t\"%s(): not mine interrupt\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\twritew(reg | NETUP_SPI_CTRL_IRQ, &spi->regs->control_stat);\n\treg = readw(&spi->regs->control_stat);\n\twritew(reg & ~NETUP_SPI_CTRL_IMASK, &spi->regs->control_stat);\n\tspi->state = SPI_STATE_DONE;\n\twake_up(&spi->waitq);\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\tdev_dbg(&spi->master->dev,\n\t\t\"%s(): SPI interrupt handled\\n\", __func__);\n\treturn IRQ_HANDLED;\n}\n\nstatic int netup_spi_transfer(struct spi_master *master,\n\t\t\t      struct spi_message *msg)\n{\n\tstruct netup_spi *spi = spi_master_get_devdata(master);\n\tstruct spi_transfer *t;\n\tint result = 0;\n\tu32 tr_size;\n\n\t \n\twritew(NETUP_SPI_CTRL_LAST_CS, &spi->regs->control_stat);\n\twritew(0, &spi->regs->control_stat);\n\tlist_for_each_entry(t, &msg->transfers, transfer_list) {\n\t\ttr_size = t->len;\n\t\twhile (tr_size) {\n\t\t\tu32 frag_offset = t->len - tr_size;\n\t\t\tu32 frag_size = (tr_size > sizeof(spi->regs->data)) ?\n\t\t\t\t\tsizeof(spi->regs->data) : tr_size;\n\t\t\tint frag_last = 0;\n\n\t\t\tif (list_is_last(&t->transfer_list,\n\t\t\t\t\t&msg->transfers) &&\n\t\t\t\t\tfrag_offset + frag_size == t->len) {\n\t\t\t\tfrag_last = 1;\n\t\t\t}\n\t\t\tif (t->tx_buf) {\n\t\t\t\tmemcpy_toio(spi->regs->data,\n\t\t\t\t\tt->tx_buf + frag_offset,\n\t\t\t\t\tfrag_size);\n\t\t\t} else {\n\t\t\t\tmemset_io(spi->regs->data,\n\t\t\t\t\t0, frag_size);\n\t\t\t}\n\t\t\tspi->state = SPI_STATE_START;\n\t\t\twritew((frag_size & 0x3ff) |\n\t\t\t\tNETUP_SPI_CTRL_IMASK |\n\t\t\t\tNETUP_SPI_CTRL_START |\n\t\t\t\t(frag_last ? NETUP_SPI_CTRL_LAST_CS : 0),\n\t\t\t\t&spi->regs->control_stat);\n\t\t\tdev_dbg(&spi->master->dev,\n\t\t\t\t\"%s(): control_stat 0x%04x\\n\",\n\t\t\t\t__func__, readw(&spi->regs->control_stat));\n\t\t\twait_event_timeout(spi->waitq,\n\t\t\t\tspi->state != SPI_STATE_START,\n\t\t\t\tmsecs_to_jiffies(NETUP_SPI_TIMEOUT));\n\t\t\tif (spi->state == SPI_STATE_DONE) {\n\t\t\t\tif (t->rx_buf) {\n\t\t\t\t\tmemcpy_fromio(t->rx_buf + frag_offset,\n\t\t\t\t\t\tspi->regs->data, frag_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (spi->state == SPI_STATE_START) {\n\t\t\t\t\tdev_dbg(&spi->master->dev,\n\t\t\t\t\t\t\"%s(): transfer timeout\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\t} else {\n\t\t\t\t\tdev_dbg(&spi->master->dev,\n\t\t\t\t\t\t\"%s(): invalid state %d\\n\",\n\t\t\t\t\t\t__func__, spi->state);\n\t\t\t\t}\n\t\t\t\tresult = -EIO;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\ttr_size -= frag_size;\n\t\t\tmsg->actual_length += frag_size;\n\t\t}\n\t}\ndone:\n\tmsg->status = result;\n\tspi_finalize_current_message(master);\n\treturn result;\n}\n\nstatic int netup_spi_setup(struct spi_device *spi)\n{\n\treturn 0;\n}\n\nint netup_spi_init(struct netup_unidvb_dev *ndev)\n{\n\tstruct spi_master *master;\n\tstruct netup_spi *nspi;\n\n\tmaster = devm_spi_alloc_master(&ndev->pci_dev->dev,\n\t\tsizeof(struct netup_spi));\n\tif (!master) {\n\t\tdev_err(&ndev->pci_dev->dev,\n\t\t\t\"%s(): unable to alloc SPI master\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tnspi = spi_master_get_devdata(master);\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;\n\tmaster->bus_num = -1;\n\tmaster->num_chipselect = 1;\n\tmaster->transfer_one_message = netup_spi_transfer;\n\tmaster->setup = netup_spi_setup;\n\tspin_lock_init(&nspi->lock);\n\tinit_waitqueue_head(&nspi->waitq);\n\tnspi->master = master;\n\tnspi->regs = (struct netup_spi_regs __iomem *)(ndev->bmmio0 + 0x4000);\n\twritew(2, &nspi->regs->clock_divider);\n\twritew(NETUP_UNIDVB_IRQ_SPI, ndev->bmmio0 + REG_IMASK_SET);\n\tndev->spi = nspi;\n\tif (spi_register_master(master)) {\n\t\tndev->spi = NULL;\n\t\tdev_err(&ndev->pci_dev->dev,\n\t\t\t\"%s(): unable to register SPI bus\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tsnprintf(netup_spi_name,\n\t\tsizeof(netup_spi_name),\n\t\t\"fpga_%02x:%02x.%01x\",\n\t\tndev->pci_bus,\n\t\tndev->pci_slot,\n\t\tndev->pci_func);\n\tif (!spi_new_device(master, &netup_spi_board)) {\n\t\tspi_unregister_master(master);\n\t\tndev->spi = NULL;\n\t\tdev_err(&ndev->pci_dev->dev,\n\t\t\t\"%s(): unable to create SPI device\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(&ndev->pci_dev->dev, \"%s(): SPI init OK\\n\", __func__);\n\treturn 0;\n}\n\nvoid netup_spi_release(struct netup_unidvb_dev *ndev)\n{\n\tu16 reg;\n\tunsigned long flags;\n\tstruct netup_spi *spi = ndev->spi;\n\n\tif (!spi)\n\t\treturn;\n\n\tspi_unregister_master(spi->master);\n\tspin_lock_irqsave(&spi->lock, flags);\n\treg = readw(&spi->regs->control_stat);\n\twritew(reg | NETUP_SPI_CTRL_IRQ, &spi->regs->control_stat);\n\treg = readw(&spi->regs->control_stat);\n\twritew(reg & ~NETUP_SPI_CTRL_IMASK, &spi->regs->control_stat);\n\tspin_unlock_irqrestore(&spi->lock, flags);\n\tndev->spi = NULL;\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}