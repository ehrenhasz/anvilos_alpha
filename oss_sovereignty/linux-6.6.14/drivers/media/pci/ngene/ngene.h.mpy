{
  "module_name": "ngene.h",
  "hash_id": "d9640bae6fcbe114190054b308f1b8ef64b4219414968380c361f37241c0b982",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ngene/ngene.h",
  "human_readable_source": " \n \n\n#ifndef _NGENE_H_\n#define _NGENE_H_\n\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <asm/dma.h>\n#include <linux/scatterlist.h>\n\n#include <linux/dvb/frontend.h>\n\n#include <media/dmxdev.h>\n#include <media/dvbdev.h>\n#include <media/dvb_demux.h>\n#include <media/dvb_ca_en50221.h>\n#include <media/dvb_frontend.h>\n#include <media/dvb_ringbuffer.h>\n#include <media/dvb_net.h>\n#include \"cxd2099.h\"\n\n#define DEVICE_NAME \"ngene\"\n\n#define NGENE_VID       0x18c3\n#define NGENE_PID       0x0720\n\n#ifndef VIDEO_CAP_VC1\n#define VIDEO_CAP_AVC   128\n#define VIDEO_CAP_H264  128\n#define VIDEO_CAP_VC1   256\n#define VIDEO_CAP_WMV9  256\n#define VIDEO_CAP_MPEG4 512\n#endif\n\n#define DEMOD_TYPE_STV090X\t0\n#define DEMOD_TYPE_DRXK\t\t1\n#define DEMOD_TYPE_STV0367\t2\n\n#define DEMOD_TYPE_XO2\t\t32\n#define DEMOD_TYPE_STV0910\t(DEMOD_TYPE_XO2 + 0)\n#define DEMOD_TYPE_SONY_CT2\t(DEMOD_TYPE_XO2 + 1)\n#define DEMOD_TYPE_SONY_ISDBT\t(DEMOD_TYPE_XO2 + 2)\n#define DEMOD_TYPE_SONY_C2T2\t(DEMOD_TYPE_XO2 + 3)\n#define DEMOD_TYPE_ST_ATSC\t(DEMOD_TYPE_XO2 + 4)\n#define DEMOD_TYPE_SONY_C2T2I\t(DEMOD_TYPE_XO2 + 5)\n\n#define NGENE_XO2_TYPE_NONE\t0\n#define NGENE_XO2_TYPE_DUOFLEX\t1\n#define NGENE_XO2_TYPE_CI\t2\n\nenum STREAM {\n\tSTREAM_VIDEOIN1 = 0,         \n\tSTREAM_VIDEOIN2,\n\tSTREAM_AUDIOIN1,             \n\tSTREAM_AUDIOIN2,\n\tSTREAM_AUDIOOUT,\n\tMAX_STREAM\n};\n\nenum SMODE_BITS {\n\tSMODE_AUDIO_SPDIF = 0x20,\n\tSMODE_AVSYNC = 0x10,\n\tSMODE_TRANSPORT_STREAM = 0x08,\n\tSMODE_AUDIO_CAPTURE = 0x04,\n\tSMODE_VBI_CAPTURE = 0x02,\n\tSMODE_VIDEO_CAPTURE = 0x01\n};\n\nenum STREAM_FLAG_BITS {\n\tSFLAG_CHROMA_FORMAT_2COMP  = 0x01,  \n\tSFLAG_CHROMA_FORMAT_OFFSET = 0x00,  \n\tSFLAG_ORDER_LUMA_CHROMA    = 0x02,  \n\tSFLAG_ORDER_CHROMA_LUMA    = 0x00,  \n\tSFLAG_COLORBAR             = 0x04,  \n};\n\n#define PROGRAM_ROM     0x0000\n#define PROGRAM_SRAM    0x1000\n#define PERIPHERALS0    0x8000\n#define PERIPHERALS1    0x9000\n#define SHARED_BUFFER   0xC000\n\n#define HOST_TO_NGENE    (SHARED_BUFFER+0x0000)\n#define NGENE_TO_HOST    (SHARED_BUFFER+0x0100)\n#define NGENE_COMMAND    (SHARED_BUFFER+0x0200)\n#define NGENE_COMMAND_HI (SHARED_BUFFER+0x0204)\n#define NGENE_STATUS     (SHARED_BUFFER+0x0208)\n#define NGENE_STATUS_HI  (SHARED_BUFFER+0x020C)\n#define NGENE_EVENT      (SHARED_BUFFER+0x0210)\n#define NGENE_EVENT_HI   (SHARED_BUFFER+0x0214)\n#define VARIABLES        (SHARED_BUFFER+0x0210)\n\n#define NGENE_INT_COUNTS       (SHARED_BUFFER+0x0260)\n#define NGENE_INT_ENABLE       (SHARED_BUFFER+0x0264)\n#define NGENE_VBI_LINE_COUNT   (SHARED_BUFFER+0x0268)\n\n#define BUFFER_GP_XMIT  (SHARED_BUFFER+0x0800)\n#define BUFFER_GP_RECV  (SHARED_BUFFER+0x0900)\n#define EEPROM_AREA     (SHARED_BUFFER+0x0A00)\n\n#define SG_V_IN_1       (SHARED_BUFFER+0x0A80)\n#define SG_VBI_1        (SHARED_BUFFER+0x0B00)\n#define SG_A_IN_1       (SHARED_BUFFER+0x0B80)\n#define SG_V_IN_2       (SHARED_BUFFER+0x0C00)\n#define SG_VBI_2        (SHARED_BUFFER+0x0C80)\n#define SG_A_IN_2       (SHARED_BUFFER+0x0D00)\n#define SG_V_OUT        (SHARED_BUFFER+0x0D80)\n#define SG_A_OUT2       (SHARED_BUFFER+0x0E00)\n\n#define DATA_A_IN_1     (SHARED_BUFFER+0x0E80)\n#define DATA_A_IN_2     (SHARED_BUFFER+0x0F00)\n#define DATA_A_OUT      (SHARED_BUFFER+0x0F80)\n#define DATA_V_IN_1     (SHARED_BUFFER+0x1000)\n#define DATA_V_IN_2     (SHARED_BUFFER+0x2000)\n#define DATA_V_OUT      (SHARED_BUFFER+0x3000)\n\n#define DATA_FIFO_AREA  (SHARED_BUFFER+0x1000)\n\n#define TIMESTAMPS      0xA000\n#define SCRATCHPAD      0xA080\n#define FORCE_INT       0xA088\n#define FORCE_NMI       0xA090\n#define INT_STATUS      0xA0A0\n\n#define DEV_VER         0x9004\n\n#define FW_DEBUG_DEFAULT (PROGRAM_SRAM+0x00FF)\n\nstruct SG_ADDR {\n\tu64 start;\n\tu64 curr;\n\tu16 curr_ptr;\n\tu16 elements;\n\tu32 pad[3];\n} __attribute__ ((__packed__));\n\nstruct SHARED_MEMORY {\n\t \n\tu32 HostToNgene[64];\n\n\t \n\tu32 NgeneToHost[64];\n\n\t \n\tu64 NgeneCommand;\n\tu64 NgeneStatus;\n\tu64 NgeneEvent;\n\n\t \n\tu8 pad1[0xc260 - 0xc218];\n\n\t \n\tu32 IntCounts;\n\tu32 IntEnable;\n\n\t \n\tu8 pad2[0xd000 - 0xc268];\n\n} __attribute__ ((__packed__));\n\nstruct BUFFER_STREAM_RESULTS {\n\tu32 Clock;            \n\tu16 RemainingLines;   \n\tu8  FieldCount;       \n\tu8  Flags;            \n\tu16 BlockCount;       \n\tu8  Reserved[2];\n\tu32 DTOUpdate;\n} __attribute__ ((__packed__));\n\nstruct HW_SCATTER_GATHER_ELEMENT {\n\tu64 Address;\n\tu32 Length;\n\tu32 Reserved;\n} __attribute__ ((__packed__));\n\nstruct BUFFER_HEADER {\n\tu64    Next;\n\tstruct BUFFER_STREAM_RESULTS SR;\n\n\tu32    Number_of_entries_1;\n\tu32    Reserved5;\n\tu64    Address_of_first_entry_1;\n\n\tu32    Number_of_entries_2;\n\tu32    Reserved7;\n\tu64    Address_of_first_entry_2;\n} __attribute__ ((__packed__));\n\nstruct EVENT_BUFFER {\n\tu32    TimeStamp;\n\tu8     GPIOStatus;\n\tu8     UARTStatus;\n\tu8     RXCharacter;\n\tu8     EventStatus;\n\tu32    Reserved[2];\n} __attribute__ ((__packed__));\n\n \n\nenum OPCODES {\n\tCMD_NOP = 0,\n\tCMD_FWLOAD_PREPARE  = 0x01,\n\tCMD_FWLOAD_FINISH   = 0x02,\n\tCMD_I2C_READ        = 0x03,\n\tCMD_I2C_WRITE       = 0x04,\n\n\tCMD_I2C_WRITE_NOSTOP = 0x05,\n\tCMD_I2C_CONTINUE_WRITE = 0x06,\n\tCMD_I2C_CONTINUE_WRITE_NOSTOP = 0x07,\n\n\tCMD_DEBUG_OUTPUT    = 0x09,\n\n\tCMD_CONTROL         = 0x10,\n\tCMD_CONFIGURE_BUFFER = 0x11,\n\tCMD_CONFIGURE_FREE_BUFFER = 0x12,\n\n\tCMD_SPI_READ        = 0x13,\n\tCMD_SPI_WRITE       = 0x14,\n\n\tCMD_MEM_READ        = 0x20,\n\tCMD_MEM_WRITE\t    = 0x21,\n\tCMD_SFR_READ\t    = 0x22,\n\tCMD_SFR_WRITE\t    = 0x23,\n\tCMD_IRAM_READ\t    = 0x24,\n\tCMD_IRAM_WRITE\t    = 0x25,\n\tCMD_SET_GPIO_PIN    = 0x26,\n\tCMD_SET_GPIO_INT    = 0x27,\n\tCMD_CONFIGURE_UART  = 0x28,\n\tCMD_WRITE_UART      = 0x29,\n\tMAX_CMD\n};\n\nenum RESPONSES {\n\tOK = 0,\n\tERROR = 1\n};\n\nstruct FW_HEADER {\n\tu8 Opcode;\n\tu8 Length;\n} __attribute__ ((__packed__));\n\nstruct FW_I2C_WRITE {\n\tstruct FW_HEADER hdr;\n\tu8 Device;\n\tu8 Data[250];\n} __attribute__ ((__packed__));\n\nstruct FW_I2C_CONTINUE_WRITE {\n\tstruct FW_HEADER hdr;\n\tu8 Data[250];\n} __attribute__ ((__packed__));\n\nstruct FW_I2C_READ {\n\tstruct FW_HEADER hdr;\n\tu8 Device;\n\tu8 Data[252];     \n} __attribute__ ((__packed__));\n\nstruct FW_SPI_WRITE {\n\tstruct FW_HEADER hdr;\n\tu8 ModeSelect;\n\tu8 Data[250];\n} __attribute__ ((__packed__));\n\nstruct FW_SPI_READ {\n\tstruct FW_HEADER hdr;\n\tu8 ModeSelect;\n\tu8 Data[252];     \n} __attribute__ ((__packed__));\n\nstruct FW_FWLOAD_PREPARE {\n\tstruct FW_HEADER hdr;\n} __attribute__ ((__packed__));\n\nstruct FW_FWLOAD_FINISH {\n\tstruct FW_HEADER hdr;\n\tu16 Address;      \n\tu16 Length;\n} __attribute__ ((__packed__));\n\n \n\nenum FSC_MODE_BITS {\n\tSMODE_LOOPBACK          = 0x80,\n\tSMODE_AVLOOP            = 0x40,\n\t_SMODE_AUDIO_SPDIF      = 0x20,\n\t_SMODE_AVSYNC           = 0x10,\n\t_SMODE_TRANSPORT_STREAM = 0x08,\n\t_SMODE_AUDIO_CAPTURE    = 0x04,\n\t_SMODE_VBI_CAPTURE      = 0x02,\n\t_SMODE_VIDEO_CAPTURE    = 0x01\n};\n\n\n \n\nstruct FW_STREAM_CONTROL {\n\tstruct FW_HEADER hdr;\n\tu8     Stream;              \n\tu8     Control;             \n\tu8     Mode;                \n\tu8     SetupDataLen;\t    \n\tu16    CaptureBlockCount;   \n\tu64    Buffer_Address;\t    \n\tu16    BytesPerVideoLine;\n\tu16    MaxLinesPerField;\n\tu16    MinLinesPerField;\n\tu16    Reserved_1;\n\tu16    BytesPerVBILine;\n\tu16    MaxVBILinesPerField;\n\tu16    MinVBILinesPerField;\n\tu16    SetupDataAddr;       \n\tu8     SetupData[32];       \n} __attribute__((__packed__));\n\n#define AUDIO_BLOCK_SIZE    256\n#define TS_BLOCK_SIZE       256\n\nstruct FW_MEM_READ {\n\tstruct FW_HEADER hdr;\n\tu16   address;\n} __attribute__ ((__packed__));\n\nstruct FW_MEM_WRITE {\n\tstruct FW_HEADER hdr;\n\tu16   address;\n\tu8    data;\n} __attribute__ ((__packed__));\n\nstruct FW_SFR_IRAM_READ {\n\tstruct FW_HEADER hdr;\n\tu8    address;\n} __attribute__ ((__packed__));\n\nstruct FW_SFR_IRAM_WRITE {\n\tstruct FW_HEADER hdr;\n\tu8    address;\n\tu8    data;\n} __attribute__ ((__packed__));\n\nstruct FW_SET_GPIO_PIN {\n\tstruct FW_HEADER hdr;\n\tu8    select;\n} __attribute__ ((__packed__));\n\nstruct FW_SET_GPIO_INT {\n\tstruct FW_HEADER hdr;\n\tu8    select;\n} __attribute__ ((__packed__));\n\nstruct FW_SET_DEBUGMODE {\n\tstruct FW_HEADER hdr;\n\tu8   debug_flags;\n} __attribute__ ((__packed__));\n\nstruct FW_CONFIGURE_BUFFERS {\n\tstruct FW_HEADER hdr;\n\tu8   config;\n} __attribute__ ((__packed__));\n\nenum _BUFFER_CONFIGS {\n\t \n\tBUFFER_CONFIG_4422 = 0,\n\t \n\tBUFFER_CONFIG_3333 = 1,\n\t \n\tBUFFER_CONFIG_8022 = 2,\n\tBUFFER_CONFIG_FW17 = 255,  \n};\n\nstruct FW_CONFIGURE_FREE_BUFFERS {\n\tstruct FW_HEADER hdr;\n\tstruct {\n\t\tu8   UVI1_BufferLength;\n\t\tu8   UVI2_BufferLength;\n\t\tu8   TVO_BufferLength;\n\t\tu8   AUD1_BufferLength;\n\t\tu8   AUD2_BufferLength;\n\t\tu8   TVA_BufferLength;\n\t} __packed config;\n} __attribute__ ((__packed__));\n\nstruct FW_CONFIGURE_UART {\n\tstruct FW_HEADER hdr;\n\tu8 UartControl;\n} __attribute__ ((__packed__));\n\nenum _UART_CONFIG {\n\t_UART_BAUDRATE_19200 = 0,\n\t_UART_BAUDRATE_9600  = 1,\n\t_UART_BAUDRATE_4800  = 2,\n\t_UART_BAUDRATE_2400  = 3,\n\t_UART_RX_ENABLE      = 0x40,\n\t_UART_TX_ENABLE      = 0x80,\n};\n\nstruct FW_WRITE_UART {\n\tstruct FW_HEADER hdr;\n\tu8 Data[252];\n} __attribute__ ((__packed__));\n\n\nstruct ngene_command {\n\tu32 in_len;\n\tu32 out_len;\n\tunion {\n\t\tu32                              raw[64];\n\t\tu8                               raw8[256];\n\t\tstruct FW_HEADER                 hdr;\n\t\tstruct FW_I2C_WRITE              I2CWrite;\n\t\tstruct FW_I2C_CONTINUE_WRITE     I2CContinueWrite;\n\t\tstruct FW_I2C_READ               I2CRead;\n\t\tstruct FW_STREAM_CONTROL         StreamControl;\n\t\tstruct FW_FWLOAD_PREPARE         FWLoadPrepare;\n\t\tstruct FW_FWLOAD_FINISH          FWLoadFinish;\n\t\tstruct FW_MEM_READ\t\t MemoryRead;\n\t\tstruct FW_MEM_WRITE\t\t MemoryWrite;\n\t\tstruct FW_SFR_IRAM_READ\t\t SfrIramRead;\n\t\tstruct FW_SFR_IRAM_WRITE         SfrIramWrite;\n\t\tstruct FW_SPI_WRITE              SPIWrite;\n\t\tstruct FW_SPI_READ               SPIRead;\n\t\tstruct FW_SET_GPIO_PIN           SetGpioPin;\n\t\tstruct FW_SET_GPIO_INT           SetGpioInt;\n\t\tstruct FW_SET_DEBUGMODE          SetDebugMode;\n\t\tstruct FW_CONFIGURE_BUFFERS      ConfigureBuffers;\n\t\tstruct FW_CONFIGURE_FREE_BUFFERS ConfigureFreeBuffers;\n\t\tstruct FW_CONFIGURE_UART         ConfigureUart;\n\t\tstruct FW_WRITE_UART             WriteUart;\n\t} cmd;\n} __attribute__ ((__packed__));\n\n#define NGENE_INTERFACE_VERSION 0x103\n#define MAX_VIDEO_BUFFER_SIZE   (417792)  \n#define MAX_AUDIO_BUFFER_SIZE     (8192)  \n#define MAX_VBI_BUFFER_SIZE      (28672)  \n#define MAX_TS_BUFFER_SIZE       (98304)  \n#define MAX_HDTV_BUFFER_SIZE   (2080768)  \n\n#define OVERFLOW_BUFFER_SIZE    (8192)\n\n#define RING_SIZE_VIDEO     4\n#define RING_SIZE_AUDIO     8\n#define RING_SIZE_TS        8\n\n#define NUM_SCATTER_GATHER_ENTRIES  8\n\n#define MAX_DMA_LENGTH (((MAX_VIDEO_BUFFER_SIZE + MAX_VBI_BUFFER_SIZE) * \\\n\t\t\tRING_SIZE_VIDEO * 2) + \\\n\t\t\t(MAX_AUDIO_BUFFER_SIZE * RING_SIZE_AUDIO * 2) + \\\n\t\t\t(MAX_TS_BUFFER_SIZE * RING_SIZE_TS * 4) + \\\n\t\t\t(RING_SIZE_VIDEO * PAGE_SIZE * 2) + \\\n\t\t\t(RING_SIZE_AUDIO * PAGE_SIZE * 2) + \\\n\t\t\t(RING_SIZE_TS    * PAGE_SIZE * 4) + \\\n\t\t\t 8 * PAGE_SIZE + OVERFLOW_BUFFER_SIZE + PAGE_SIZE)\n\n#define EVENT_QUEUE_SIZE    16\n\n \n\nstruct SBufferHeader {\n\tstruct BUFFER_HEADER   ngeneBuffer;  \n\tstruct SBufferHeader  *Next;\n\tvoid                  *Buffer1;\n\tstruct HW_SCATTER_GATHER_ELEMENT *scList1;\n\tvoid                  *Buffer2;\n\tstruct HW_SCATTER_GATHER_ELEMENT *scList2;\n};\n\n \n#define SIZEOF_SBufferHeader ((sizeof(struct SBufferHeader) + 63) & ~63)\n\nenum HWSTATE {\n\tHWSTATE_STOP,\n\tHWSTATE_STARTUP,\n\tHWSTATE_RUN,\n\tHWSTATE_PAUSE,\n};\n\nenum KSSTATE {\n\tKSSTATE_STOP,\n\tKSSTATE_ACQUIRE,\n\tKSSTATE_PAUSE,\n\tKSSTATE_RUN,\n};\n\nstruct SRingBufferDescriptor {\n\tstruct SBufferHeader *Head;  \n\tu64   PAHead;          \n\tu32   MemSize;         \n\tu32   NumBuffers;      \n\tu32   Buffer1Length;   \n\tu32   Buffer2Length;   \n\tvoid *SCListMem;       \n\tu64   PASCListMem;     \n\tu32   SCListMemSize;   \n};\n\nenum STREAMMODEFLAGS {\n\tStreamMode_NONE   = 0,  \n\tStreamMode_ANALOG = 1,  \n\tStreamMode_TSIN   = 2,  \n\tStreamMode_HDTV   = 4,  \n\tStreamMode_TSOUT  = 8,  \n};\n\n\nenum BufferExchangeFlags {\n\tBEF_EVEN_FIELD   = 0x00000001,\n\tBEF_CONTINUATION = 0x00000002,\n\tBEF_MORE_DATA    = 0x00000004,\n\tBEF_OVERFLOW     = 0x00000008,\n\tDF_SWAP32        = 0x00010000,\n};\n\ntypedef void *(IBufferExchange)(void *, void *, u32, u32, u32);\n\nstruct MICI_STREAMINFO {\n\tIBufferExchange    *pExchange;\n\tIBufferExchange    *pExchangeVBI;      \n\tu8  Stream;\n\tu8  Flags;\n\tu8  Mode;\n\tu8  Reserved;\n\tu16 nLinesVideo;\n\tu16 nBytesPerLineVideo;\n\tu16 nLinesVBI;\n\tu16 nBytesPerLineVBI;\n\tu32 CaptureLength;     \n};\n\n \n \n \n\n \n#define MIXER_ADDR_TVTUNER      0\n#define MIXER_ADDR_LAST         0\n\nstruct ngene_channel;\n\n \n\nstruct mychip {\n\tstruct ngene_channel *chan;\n\tstruct snd_card *card;\n\tstruct pci_dev *pci;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm *pcm;\n\tunsigned long port;\n\tint irq;\n\tspinlock_t mixer_lock;\n\tspinlock_t lock;\n\tint mixer_volume[MIXER_ADDR_LAST + 1][2];\n\tint capture_source[MIXER_ADDR_LAST + 1][2];\n};\n\nstruct ngene_channel {\n\tstruct device         device;\n\tstruct i2c_adapter    i2c_adapter;\n\tstruct i2c_client    *i2c_client[1];\n\tint                   i2c_client_fe;\n\n\tstruct ngene         *dev;\n\tint                   number;\n\tint                   type;\n\tint                   mode;\n\tbool                  has_adapter;\n\tbool                  has_demux;\n\tint                   demod_type;\n\tint (*gate_ctrl)(struct dvb_frontend *, int);\n\n\tstruct dvb_frontend  *fe;\n\tstruct dvb_frontend  *fe2;\n\tstruct dmxdev         dmxdev;\n\tstruct dvb_demux      demux;\n\tstruct dvb_net        dvbnet;\n\tstruct dmx_frontend   hw_frontend;\n\tstruct dmx_frontend   mem_frontend;\n\tint                   users;\n\tstruct video_device  *v4l_dev;\n\tstruct dvb_device    *ci_dev;\n\tstruct tasklet_struct demux_tasklet;\n\n\tstruct SBufferHeader *nextBuffer;\n\tenum KSSTATE          State;\n\tenum HWSTATE          HWState;\n\tu8                    Stream;\n\tu8                    Flags;\n\tu8                    Mode;\n\tIBufferExchange      *pBufferExchange;\n\tIBufferExchange      *pBufferExchange2;\n\n\tspinlock_t            state_lock;\n\tu16                   nLines;\n\tu16                   nBytesPerLine;\n\tu16                   nVBILines;\n\tu16                   nBytesPerVBILine;\n\tu16                   itumode;\n\tu32                   Capture1Length;\n\tu32                   Capture2Length;\n\tstruct SRingBufferDescriptor RingBuffer;\n\tstruct SRingBufferDescriptor TSRingBuffer;\n\tstruct SRingBufferDescriptor TSIdleBuffer;\n\n\tu32                   DataFormatFlags;\n\n\tint                   AudioDTOUpdated;\n\tu32                   AudioDTOValue;\n\n\tint (*set_tone)(struct dvb_frontend *, enum fe_sec_tone_mode);\n\tu8 lnbh;\n\n\t \n\n\tint minor;\n\tstruct mychip        *mychip;\n\tstruct snd_card      *soundcard;\n\tu8                   *evenbuffer;\n\tu8                    dma_on;\n\tint                   soundstreamon;\n\tint                   audiomute;\n\tint                   soundbuffisallocated;\n\tint                   sndbuffflag;\n\tint                   tun_rdy;\n\tint                   dec_rdy;\n\tint                   tun_dec_rdy;\n\tint                   lastbufferflag;\n\n\tstruct ngene_tvnorm  *tvnorms;\n\tint                   tvnorm_num;\n\tint                   tvnorm;\n\n\tint running;\n\n\tint tsin_offset;\n\tu8  tsin_buffer[188];\n};\n\n\nstruct ngene_ci {\n\tstruct device         device;\n\tstruct i2c_adapter    i2c_adapter;\n\n\tstruct ngene         *dev;\n\tstruct dvb_ca_en50221 *en;\n};\n\nstruct ngene;\n\ntypedef void (rx_cb_t)(struct ngene *, u32, u8);\ntypedef void (tx_cb_t)(struct ngene *, u32);\n\nstruct ngene {\n\tint                   nr;\n\tstruct pci_dev       *pci_dev;\n\tunsigned char __iomem *iomem;\n\n\t \n\n\tu32                   device_version;\n\tu32                   fw_interface_version;\n\tu32                   icounts;\n\tbool                  msi_enabled;\n\tbool                  cmd_timeout_workaround;\n\n\tu8                   *CmdDoneByte;\n\tint                   BootFirmware;\n\tvoid                 *OverflowBuffer;\n\tdma_addr_t            PAOverflowBuffer;\n\tvoid                 *FWInterfaceBuffer;\n\tdma_addr_t            PAFWInterfaceBuffer;\n\tu8                   *ngenetohost;\n\tu8                   *hosttongene;\n\n\tstruct EVENT_BUFFER   EventQueue[EVENT_QUEUE_SIZE];\n\tint                   EventQueueOverflowCount;\n\tint                   EventQueueOverflowFlag;\n\tstruct tasklet_struct event_tasklet;\n\tstruct EVENT_BUFFER  *EventBuffer;\n\tint                   EventQueueWriteIndex;\n\tint                   EventQueueReadIndex;\n\n\twait_queue_head_t     cmd_wq;\n\tint                   cmd_done;\n\tstruct mutex          cmd_mutex;\n\tstruct mutex          stream_mutex;\n\tstruct semaphore      pll_mutex;\n\tstruct mutex          i2c_switch_mutex;\n\tint                   i2c_current_channel;\n\tint                   i2c_current_bus;\n\tspinlock_t            cmd_lock;\n\n\tstruct dvb_adapter    adapter[MAX_STREAM];\n\tstruct dvb_adapter    *first_adapter;  \n\tstruct ngene_channel  channel[MAX_STREAM];\n\n\tstruct ngene_info    *card_info;\n\n\ttx_cb_t              *TxEventNotify;\n\trx_cb_t              *RxEventNotify;\n\tint                   tx_busy;\n\twait_queue_head_t     tx_wq;\n\twait_queue_head_t     rx_wq;\n#define UART_RBUF_LEN 4096\n\tu8                    uart_rbuf[UART_RBUF_LEN];\n\tint                   uart_rp, uart_wp;\n\n#define TS_FILLER  0x6f\n\n\tu8                   *tsout_buf;\n#define TSOUT_BUF_SIZE (512*188*8)\n\tstruct dvb_ringbuffer tsout_rbuf;\n\n\tu8                   *tsin_buf;\n#define TSIN_BUF_SIZE (512*188*8)\n\tstruct dvb_ringbuffer tsin_rbuf;\n\n\tu8                   *ain_buf;\n#define AIN_BUF_SIZE (128*1024)\n\tstruct dvb_ringbuffer ain_rbuf;\n\n\n\tu8                   *vin_buf;\n#define VIN_BUF_SIZE (4*1920*1080)\n\tstruct dvb_ringbuffer vin_rbuf;\n\n\tunsigned long         exp_val;\n\tint prev_cmd;\n\n\tstruct ngene_ci       ci;\n};\n\nstruct ngene_info {\n\tint   type;\n#define NGENE_APP        0\n#define NGENE_TERRATEC   1\n#define NGENE_SIDEWINDER 2\n#define NGENE_RACER      3\n#define NGENE_VIPER      4\n#define NGENE_PYTHON     5\n#define NGENE_VBOX_V1\t 6\n#define NGENE_VBOX_V2\t 7\n\n\tint   fw_version;\n\tbool  msi_supported;\n\tchar *name;\n\n\tint   io_type[MAX_STREAM];\n#define NGENE_IO_NONE    0\n#define NGENE_IO_TV      1\n#define NGENE_IO_HDTV    2\n#define NGENE_IO_TSIN    4\n#define NGENE_IO_TSOUT   8\n#define NGENE_IO_AIN     16\n\n\tvoid *fe_config[4];\n\tvoid *tuner_config[4];\n\n\tint (*demod_attach[4])(struct ngene_channel *);\n\tint (*tuner_attach[4])(struct ngene_channel *);\n\n\tu8    avf[4];\n\tu8    msp[4];\n\tu8    demoda[4];\n\tu8    lnb[4];\n\tint   i2c_access;\n\tu8    ntsc;\n\tu8    tsf[4];\n\tu8    i2s[4];\n\n\tint (*gate_ctrl)(struct dvb_frontend *, int);\n\tint (*switch_ctrl)(struct ngene_channel *, int, int);\n};\n\n\n \nint ngene_probe(struct pci_dev *pci_dev, const struct pci_device_id *id);\nvoid ngene_remove(struct pci_dev *pdev);\nvoid ngene_shutdown(struct pci_dev *pdev);\nint ngene_command(struct ngene *dev, struct ngene_command *com);\nint ngene_command_gpio_set(struct ngene *dev, u8 select, u8 level);\nvoid set_transfer(struct ngene_channel *chan, int state);\nvoid FillTSBuffer(void *Buffer, int Length, u32 Flags);\n\n \nint ngene_port_has_cxd2099(struct i2c_adapter *i2c, u8 *type);\n\n \nint ngene_i2c_init(struct ngene *dev, int dev_nr);\n\n \nextern struct dvb_device ngene_dvbdev_ci;\nvoid *tsout_exchange(void *priv, void *buf, u32 len, u32 clock, u32 flags);\nvoid *tsin_exchange(void *priv, void *buf, u32 len, u32 clock, u32 flags);\nint ngene_start_feed(struct dvb_demux_feed *dvbdmxfeed);\nint ngene_stop_feed(struct dvb_demux_feed *dvbdmxfeed);\nint my_dvb_dmx_ts_card_init(struct dvb_demux *dvbdemux, char *id,\n\t\t\t    int (*start_feed)(struct dvb_demux_feed *),\n\t\t\t    int (*stop_feed)(struct dvb_demux_feed *),\n\t\t\t    void *priv);\nint my_dvb_dmxdev_ts_card_init(struct dmxdev *dmxdev,\n\t\t\t       struct dvb_demux *dvbdemux,\n\t\t\t       struct dmx_frontend *hw_frontend,\n\t\t\t       struct dmx_frontend *mem_frontend,\n\t\t\t       struct dvb_adapter *dvb_adapter);\n\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}