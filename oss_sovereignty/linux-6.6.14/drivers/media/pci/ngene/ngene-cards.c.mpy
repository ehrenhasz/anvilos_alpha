{
  "module_name": "ngene-cards.c",
  "hash_id": "ceab069e41fa04306b4f0d91026cb1c2b405691f4d7627587f51ded1ce46fdb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ngene/ngene-cards.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n\n#include \"ngene.h\"\n\n \n#include \"stv6110x.h\"\n#include \"stv090x.h\"\n#include \"lnbh24.h\"\n#include \"lgdt330x.h\"\n#include \"mt2131.h\"\n#include \"tda18271c2dd.h\"\n#include \"drxk.h\"\n#include \"drxd.h\"\n#include \"dvb-pll.h\"\n#include \"stv0367.h\"\n#include \"stv0367_priv.h\"\n#include \"tda18212.h\"\n#include \"cxd2841er.h\"\n#include \"stv0910.h\"\n#include \"stv6111.h\"\n#include \"lnbh25.h\"\n\n \n \n \n\nstatic int i2c_io(struct i2c_adapter *adapter, u8 adr,\n\t\t  u8 *wbuf, u32 wlen, u8 *rbuf, u32 rlen)\n{\n\tstruct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,\n\t\t\t\t   .buf  = wbuf, .len   = wlen },\n\t\t\t\t  {.addr = adr,  .flags = I2C_M_RD,\n\t\t\t\t   .buf  = rbuf,  .len   = rlen } };\n\treturn (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;\n}\n\nstatic int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)\n{\n\tstruct i2c_msg msg = {.addr = adr, .flags = 0,\n\t\t\t      .buf = data, .len = len};\n\n\treturn (i2c_transfer(adap, &msg, 1) == 1) ? 0 : -1;\n}\n\nstatic int i2c_write_reg(struct i2c_adapter *adap, u8 adr,\n\t\t\t u8 reg, u8 val)\n{\n\tu8 msg[2] = {reg, val};\n\n\treturn i2c_write(adap, adr, msg, 2);\n}\n\nstatic int i2c_read(struct i2c_adapter *adapter, u8 adr, u8 *val)\n{\n\tstruct i2c_msg msgs[1] = {{.addr = adr,  .flags = I2C_M_RD,\n\t\t\t\t   .buf  = val,  .len   = 1 } };\n\treturn (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;\n}\n\nstatic int i2c_read_reg16(struct i2c_adapter *adapter, u8 adr,\n\t\t\t  u16 reg, u8 *val)\n{\n\tu8 msg[2] = {reg >> 8, reg & 0xff};\n\tstruct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,\n\t\t\t\t   .buf  = msg, .len   = 2},\n\t\t\t\t  {.addr = adr, .flags = I2C_M_RD,\n\t\t\t\t   .buf  = val, .len   = 1} };\n\treturn (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;\n}\n\nstatic int i2c_read_regs(struct i2c_adapter *adapter,\n\t\t\t u8 adr, u8 reg, u8 *val, u8 len)\n{\n\tstruct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,\n\t\t\t\t   .buf  = &reg, .len   = 1},\n\t\t\t\t  {.addr = adr,  .flags = I2C_M_RD,\n\t\t\t\t   .buf  = val,  .len   = len} };\n\n\treturn (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;\n}\n\nstatic int i2c_read_reg(struct i2c_adapter *adapter, u8 adr, u8 reg, u8 *val)\n{\n\treturn i2c_read_regs(adapter, adr, reg, val, 1);\n}\n\n \n \n \n\nstatic struct i2c_adapter *i2c_adapter_from_chan(struct ngene_channel *chan)\n{\n\t \n\tif (chan->number < 2)\n\t\treturn &chan->dev->channel[0].i2c_adapter;\n\n\treturn &chan->dev->channel[1].i2c_adapter;\n}\n\nstatic int tuner_attach_stv6110(struct ngene_channel *chan)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct i2c_adapter *i2c = i2c_adapter_from_chan(chan);\n\tstruct stv090x_config *feconf = (struct stv090x_config *)\n\t\tchan->dev->card_info->fe_config[chan->number];\n\tstruct stv6110x_config *tunerconf = (struct stv6110x_config *)\n\t\tchan->dev->card_info->tuner_config[chan->number];\n\tconst struct stv6110x_devctl *ctl;\n\n\tctl = dvb_attach(stv6110x_attach, chan->fe, tunerconf, i2c);\n\tif (ctl == NULL) {\n\t\tdev_err(pdev, \"No STV6110X found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfeconf->tuner_init          = ctl->tuner_init;\n\tfeconf->tuner_sleep         = ctl->tuner_sleep;\n\tfeconf->tuner_set_mode      = ctl->tuner_set_mode;\n\tfeconf->tuner_set_frequency = ctl->tuner_set_frequency;\n\tfeconf->tuner_get_frequency = ctl->tuner_get_frequency;\n\tfeconf->tuner_set_bandwidth = ctl->tuner_set_bandwidth;\n\tfeconf->tuner_get_bandwidth = ctl->tuner_get_bandwidth;\n\tfeconf->tuner_set_bbgain    = ctl->tuner_set_bbgain;\n\tfeconf->tuner_get_bbgain    = ctl->tuner_get_bbgain;\n\tfeconf->tuner_set_refclk    = ctl->tuner_set_refclk;\n\tfeconf->tuner_get_status    = ctl->tuner_get_status;\n\n\treturn 0;\n}\n\nstatic int tuner_attach_stv6111(struct ngene_channel *chan)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct i2c_adapter *i2c = i2c_adapter_from_chan(chan);\n\tstruct dvb_frontend *fe;\n\tu8 adr = 4 + ((chan->number & 1) ? 0x63 : 0x60);\n\n\tfe = dvb_attach(stv6111_attach, chan->fe, i2c, adr);\n\tif (!fe) {\n\t\tfe = dvb_attach(stv6111_attach, chan->fe, i2c, adr & ~4);\n\t\tif (!fe) {\n\t\t\tdev_err(pdev, \"stv6111_attach() failed!\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct ngene_channel *chan = fe->sec_priv;\n\tint status;\n\n\tif (enable) {\n\t\tdown(&chan->dev->pll_mutex);\n\t\tstatus = chan->gate_ctrl(fe, 1);\n\t} else {\n\t\tstatus = chan->gate_ctrl(fe, 0);\n\t\tup(&chan->dev->pll_mutex);\n\t}\n\treturn status;\n}\n\nstatic int tuner_attach_tda18271(struct ngene_channel *chan)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct i2c_adapter *i2c = i2c_adapter_from_chan(chan);\n\tstruct dvb_frontend *fe;\n\n\tif (chan->fe->ops.i2c_gate_ctrl)\n\t\tchan->fe->ops.i2c_gate_ctrl(chan->fe, 1);\n\tfe = dvb_attach(tda18271c2dd_attach, chan->fe, i2c, 0x60);\n\tif (chan->fe->ops.i2c_gate_ctrl)\n\t\tchan->fe->ops.i2c_gate_ctrl(chan->fe, 0);\n\tif (!fe) {\n\t\tdev_err(pdev, \"No TDA18271 found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int tuner_tda18212_ping(struct ngene_channel *chan,\n\t\t\t       struct i2c_adapter *i2c,\n\t\t\t       unsigned short adr)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tu8 tda_id[2];\n\tu8 subaddr = 0x00;\n\n\tdev_dbg(pdev, \"stv0367-tda18212 tuner ping\\n\");\n\tif (chan->fe->ops.i2c_gate_ctrl)\n\t\tchan->fe->ops.i2c_gate_ctrl(chan->fe, 1);\n\n\tif (i2c_read_regs(i2c, adr, subaddr, tda_id, sizeof(tda_id)) < 0)\n\t\tdev_dbg(pdev, \"tda18212 ping 1 fail\\n\");\n\tif (i2c_read_regs(i2c, adr, subaddr, tda_id, sizeof(tda_id)) < 0)\n\t\tdev_warn(pdev, \"tda18212 ping failed, expect problems\\n\");\n\n\tif (chan->fe->ops.i2c_gate_ctrl)\n\t\tchan->fe->ops.i2c_gate_ctrl(chan->fe, 0);\n\n\treturn 0;\n}\n\nstatic int tuner_attach_tda18212(struct ngene_channel *chan, u32 dmdtype)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct i2c_adapter *i2c = i2c_adapter_from_chan(chan);\n\tstruct i2c_client *client;\n\tstruct tda18212_config config = {\n\t\t.fe = chan->fe,\n\t\t.if_dvbt_6 = 3550,\n\t\t.if_dvbt_7 = 3700,\n\t\t.if_dvbt_8 = 4150,\n\t\t.if_dvbt2_6 = 3250,\n\t\t.if_dvbt2_7 = 4000,\n\t\t.if_dvbt2_8 = 4000,\n\t\t.if_dvbc = 5000,\n\t};\n\tu8 addr = (chan->number & 1) ? 0x63 : 0x60;\n\n\t \n\tif (dmdtype == DEMOD_TYPE_STV0367)\n\t\ttuner_tda18212_ping(chan, i2c, addr);\n\n\t \n\tclient = dvb_module_probe(\"tda18212\", NULL, i2c, addr, &config);\n\tif (!client)\n\t\tgoto err;\n\n\tchan->i2c_client[0] = client;\n\tchan->i2c_client_fe = 1;\n\n\treturn 0;\nerr:\n\tdev_err(pdev, \"TDA18212 tuner not found. Device is not fully operational.\\n\");\n\treturn -ENODEV;\n}\n\nstatic int tuner_attach_probe(struct ngene_channel *chan)\n{\n\tswitch (chan->demod_type) {\n\tcase DEMOD_TYPE_STV090X:\n\t\treturn tuner_attach_stv6110(chan);\n\tcase DEMOD_TYPE_DRXK:\n\t\treturn tuner_attach_tda18271(chan);\n\tcase DEMOD_TYPE_STV0367:\n\tcase DEMOD_TYPE_SONY_CT2:\n\tcase DEMOD_TYPE_SONY_ISDBT:\n\tcase DEMOD_TYPE_SONY_C2T2:\n\tcase DEMOD_TYPE_SONY_C2T2I:\n\t\treturn tuner_attach_tda18212(chan, chan->demod_type);\n\tcase DEMOD_TYPE_STV0910:\n\t\treturn tuner_attach_stv6111(chan);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int demod_attach_stv0900(struct ngene_channel *chan)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct i2c_adapter *i2c = i2c_adapter_from_chan(chan);\n\tstruct stv090x_config *feconf = (struct stv090x_config *)\n\t\tchan->dev->card_info->fe_config[chan->number];\n\n\tchan->fe = dvb_attach(stv090x_attach, feconf, i2c,\n\t\t\t(chan->number & 1) == 0 ? STV090x_DEMODULATOR_0\n\t\t\t\t\t\t: STV090x_DEMODULATOR_1);\n\tif (chan->fe == NULL) {\n\t\tdev_err(pdev, \"No STV0900 found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (feconf->tuner_i2c_lock)\n\t\tchan->fe->analog_demod_priv = chan;\n\n\tif (!dvb_attach(lnbh24_attach, chan->fe, i2c, 0,\n\t\t\t0, chan->dev->card_info->lnb[chan->number])) {\n\t\tdev_err(pdev, \"No LNBH24 found!\\n\");\n\t\tdvb_frontend_detach(chan->fe);\n\t\tchan->fe = NULL;\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic struct stv0910_cfg stv0910_p = {\n\t.adr      = 0x68,\n\t.parallel = 1,\n\t.rptlvl   = 4,\n\t.clk      = 30000000,\n\t.tsspeed  = 0x28,\n};\n\nstatic struct lnbh25_config lnbh25_cfg = {\n\t.i2c_address = 0x0c << 1,\n\t.data2_config = LNBH25_TEN\n};\n\nstatic int demod_attach_stv0910(struct ngene_channel *chan,\n\t\t\t\tstruct i2c_adapter *i2c)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct stv0910_cfg cfg = stv0910_p;\n\tstruct lnbh25_config lnbcfg = lnbh25_cfg;\n\n\tchan->fe = dvb_attach(stv0910_attach, i2c, &cfg, (chan->number & 1));\n\tif (!chan->fe) {\n\t\tcfg.adr = 0x6c;\n\t\tchan->fe = dvb_attach(stv0910_attach, i2c,\n\t\t\t\t      &cfg, (chan->number & 1));\n\t}\n\tif (!chan->fe) {\n\t\tdev_err(pdev, \"stv0910_attach() failed!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tlnbcfg.i2c_address = (((chan->number & 1) ? 0x0d : 0x0c) << 1);\n\tif (!dvb_attach(lnbh25_attach, chan->fe, &lnbcfg, i2c)) {\n\t\tlnbcfg.i2c_address = (((chan->number & 1) ? 0x09 : 0x08) << 1);\n\t\tif (!dvb_attach(lnbh25_attach, chan->fe, &lnbcfg, i2c)) {\n\t\t\tdev_err(pdev, \"lnbh25_attach() failed!\\n\");\n\t\t\tdvb_frontend_detach(chan->fe);\n\t\t\tchan->fe = NULL;\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct stv0367_config ddb_stv0367_config[] = {\n\t{\n\t\t.demod_address = 0x1f,\n\t\t.xtal = 27000000,\n\t\t.if_khz = 0,\n\t\t.if_iq_mode = FE_TER_NORMAL_IF_TUNER,\n\t\t.ts_mode = STV0367_SERIAL_PUNCT_CLOCK,\n\t\t.clk_pol = STV0367_CLOCKPOLARITY_DEFAULT,\n\t}, {\n\t\t.demod_address = 0x1e,\n\t\t.xtal = 27000000,\n\t\t.if_khz = 0,\n\t\t.if_iq_mode = FE_TER_NORMAL_IF_TUNER,\n\t\t.ts_mode = STV0367_SERIAL_PUNCT_CLOCK,\n\t\t.clk_pol = STV0367_CLOCKPOLARITY_DEFAULT,\n\t},\n};\n\nstatic int demod_attach_stv0367(struct ngene_channel *chan,\n\t\t\t\tstruct i2c_adapter *i2c)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\n\tchan->fe = dvb_attach(stv0367ddb_attach,\n\t\t\t      &ddb_stv0367_config[(chan->number & 1)], i2c);\n\n\tif (!chan->fe) {\n\t\tdev_err(pdev, \"stv0367ddb_attach() failed!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tchan->fe->sec_priv = chan;\n\tchan->gate_ctrl = chan->fe->ops.i2c_gate_ctrl;\n\tchan->fe->ops.i2c_gate_ctrl = drxk_gate_ctrl;\n\treturn 0;\n}\n\nstatic int demod_attach_cxd28xx(struct ngene_channel *chan,\n\t\t\t\tstruct i2c_adapter *i2c, int osc24)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct cxd2841er_config cfg;\n\n\t \n\tcfg.i2c_addr = ((chan->number & 1) ? 0x6d : 0x6c) << 1;\n\n\tcfg.xtal = osc24 ? SONY_XTAL_24000 : SONY_XTAL_20500;\n\tcfg.flags = CXD2841ER_AUTO_IFHZ | CXD2841ER_EARLY_TUNE |\n\t\tCXD2841ER_NO_WAIT_LOCK | CXD2841ER_NO_AGCNEG |\n\t\tCXD2841ER_TSBITS | CXD2841ER_TS_SERIAL;\n\n\t \n\tchan->fe = dvb_attach(cxd2841er_attach_t_c, &cfg, i2c);\n\n\tif (!chan->fe) {\n\t\tdev_err(pdev, \"CXD28XX attach failed!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tchan->fe->sec_priv = chan;\n\tchan->gate_ctrl = chan->fe->ops.i2c_gate_ctrl;\n\tchan->fe->ops.i2c_gate_ctrl = drxk_gate_ctrl;\n\treturn 0;\n}\n\nstatic void cineS2_tuner_i2c_lock(struct dvb_frontend *fe, int lock)\n{\n\tstruct ngene_channel *chan = fe->analog_demod_priv;\n\n\tif (lock)\n\t\tdown(&chan->dev->pll_mutex);\n\telse\n\t\tup(&chan->dev->pll_mutex);\n}\n\nstatic int port_has_stv0900(struct i2c_adapter *i2c, int port)\n{\n\tu8 val;\n\tif (i2c_read_reg16(i2c, 0x68+port/2, 0xf100, &val) < 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int port_has_drxk(struct i2c_adapter *i2c, int port)\n{\n\tu8 val;\n\n\tif (i2c_read(i2c, 0x29+port, &val) < 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int port_has_stv0367(struct i2c_adapter *i2c)\n{\n\tu8 val;\n\n\tif (i2c_read_reg16(i2c, 0x1e, 0xf000, &val) < 0)\n\t\treturn 0;\n\tif (val != 0x60)\n\t\treturn 0;\n\tif (i2c_read_reg16(i2c, 0x1f, 0xf000, &val) < 0)\n\t\treturn 0;\n\tif (val != 0x60)\n\t\treturn 0;\n\treturn 1;\n}\n\nint ngene_port_has_cxd2099(struct i2c_adapter *i2c, u8 *type)\n{\n\tu8 val;\n\tu8 probe[4] = { 0xe0, 0x00, 0x00, 0x00 }, data[4];\n\tstruct i2c_msg msgs[2] = {{ .addr = 0x40,  .flags = 0,\n\t\t\t\t    .buf  = probe, .len   = 4 },\n\t\t\t\t  { .addr = 0x40,  .flags = I2C_M_RD,\n\t\t\t\t    .buf  = data,  .len   = 4 } };\n\tval = i2c_transfer(i2c, msgs, 2);\n\tif (val != 2)\n\t\treturn 0;\n\n\tif (data[0] == 0x02 && data[1] == 0x2b && data[3] == 0x43)\n\t\t*type = 2;\n\telse\n\t\t*type = 1;\n\treturn 1;\n}\n\nstatic int demod_attach_drxk(struct ngene_channel *chan,\n\t\t\t     struct i2c_adapter *i2c)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct drxk_config config;\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.microcode_name = \"drxk_a3.mc\";\n\tconfig.qam_demod_parameter_count = 4;\n\tconfig.adr = 0x29 + (chan->number ^ 2);\n\n\tchan->fe = dvb_attach(drxk_attach, &config, i2c);\n\tif (!chan->fe) {\n\t\tdev_err(pdev, \"No DRXK found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\tchan->fe->sec_priv = chan;\n\tchan->gate_ctrl = chan->fe->ops.i2c_gate_ctrl;\n\tchan->fe->ops.i2c_gate_ctrl = drxk_gate_ctrl;\n\treturn 0;\n}\n\n \n \n \n\nstatic char *xo2names[] = {\n\t\"DUAL DVB-S2\",\n\t\"DUAL DVB-C/T/T2\",\n\t\"DUAL DVB-ISDBT\",\n\t\"DUAL DVB-C/C2/T/T2\",\n\t\"DUAL ATSC\",\n\t\"DUAL DVB-C/C2/T/T2/I\",\n};\n\nstatic int init_xo2(struct ngene_channel *chan, struct i2c_adapter *i2c)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tu8 addr = 0x10;\n\tu8 val, data[2];\n\tint res;\n\n\tres = i2c_read_regs(i2c, addr, 0x04, data, 2);\n\tif (res < 0)\n\t\treturn res;\n\n\tif (data[0] != 0x01)  {\n\t\tdev_info(pdev, \"Invalid XO2 on channel %d\\n\", chan->number);\n\t\treturn -1;\n\t}\n\n\ti2c_read_reg(i2c, addr, 0x08, &val);\n\tif (val != 0) {\n\t\ti2c_write_reg(i2c, addr, 0x08, 0x00);\n\t\tmsleep(100);\n\t}\n\t \n\ti2c_write_reg(i2c, addr, 0x08, 0x04);\n\tusleep_range(2000, 3000);\n\t \n\ti2c_write_reg(i2c, addr, 0x08, 0x07);\n\n\t \n\ti2c_write_reg(i2c, addr, 0x09, 1);\n\n\ti2c_write_reg(i2c, addr, 0x0a, 0x01);\n\ti2c_write_reg(i2c, addr, 0x0b, 0x01);\n\n\tusleep_range(2000, 3000);\n\t \n\ti2c_write_reg(i2c, addr, 0x08, 0x87);\n\n\treturn 0;\n}\n\nstatic int port_has_xo2(struct i2c_adapter *i2c, u8 *type, u8 *id)\n{\n\tu8 probe[1] = { 0x00 }, data[4];\n\tu8 addr = 0x10;\n\n\t*type = NGENE_XO2_TYPE_NONE;\n\n\tif (i2c_io(i2c, addr, probe, 1, data, 4))\n\t\treturn 0;\n\tif (data[0] == 'D' && data[1] == 'F') {\n\t\t*id = data[2];\n\t\t*type = NGENE_XO2_TYPE_DUOFLEX;\n\t\treturn 1;\n\t}\n\tif (data[0] == 'C' && data[1] == 'I') {\n\t\t*id = data[2];\n\t\t*type = NGENE_XO2_TYPE_CI;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n \n \n\nstatic int cineS2_probe(struct ngene_channel *chan)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct i2c_adapter *i2c = i2c_adapter_from_chan(chan);\n\tstruct stv090x_config *fe_conf;\n\tu8 buf[3];\n\tu8 xo2_type, xo2_id, xo2_demodtype;\n\tu8 sony_osc24 = 0;\n\tstruct i2c_msg i2c_msg = { .flags = 0, .buf = buf };\n\tint rc;\n\n\tif (port_has_xo2(i2c, &xo2_type, &xo2_id)) {\n\t\txo2_id >>= 2;\n\t\tdev_dbg(pdev, \"XO2 on channel %d (type %d, id %d)\\n\",\n\t\t\tchan->number, xo2_type, xo2_id);\n\n\t\tswitch (xo2_type) {\n\t\tcase NGENE_XO2_TYPE_DUOFLEX:\n\t\t\tif (chan->number & 1)\n\t\t\t\tdev_dbg(pdev,\n\t\t\t\t\t\"skipping XO2 init on odd channel %d\",\n\t\t\t\t\tchan->number);\n\t\t\telse\n\t\t\t\tinit_xo2(chan, i2c);\n\n\t\t\txo2_demodtype = DEMOD_TYPE_XO2 + xo2_id;\n\n\t\t\tswitch (xo2_demodtype) {\n\t\t\tcase DEMOD_TYPE_SONY_CT2:\n\t\t\tcase DEMOD_TYPE_SONY_ISDBT:\n\t\t\tcase DEMOD_TYPE_SONY_C2T2:\n\t\t\tcase DEMOD_TYPE_SONY_C2T2I:\n\t\t\t\tdev_info(pdev, \"%s (XO2) on channel %d\\n\",\n\t\t\t\t\t xo2names[xo2_id], chan->number);\n\t\t\t\tchan->demod_type = xo2_demodtype;\n\t\t\t\tif (xo2_demodtype == DEMOD_TYPE_SONY_C2T2I)\n\t\t\t\t\tsony_osc24 = 1;\n\n\t\t\t\tdemod_attach_cxd28xx(chan, i2c, sony_osc24);\n\t\t\t\tbreak;\n\t\t\tcase DEMOD_TYPE_STV0910:\n\t\t\t\tdev_info(pdev, \"%s (XO2) on channel %d\\n\",\n\t\t\t\t\t xo2names[xo2_id], chan->number);\n\t\t\t\tchan->demod_type = xo2_demodtype;\n\t\t\t\tdemod_attach_stv0910(chan, i2c);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_warn(pdev,\n\t\t\t\t\t \"Unsupported XO2 module on channel %d\\n\",\n\t\t\t\t\t chan->number);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NGENE_XO2_TYPE_CI:\n\t\t\tdev_info(pdev, \"DuoFlex CI modules not supported\\n\");\n\t\t\treturn -ENODEV;\n\t\tdefault:\n\t\t\tdev_info(pdev, \"Unsupported XO2 module type\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else if (port_has_stv0900(i2c, chan->number)) {\n\t\tchan->demod_type = DEMOD_TYPE_STV090X;\n\t\tfe_conf = chan->dev->card_info->fe_config[chan->number];\n\t\t \n\t\trc = demod_attach_stv0900(chan);\n\t\tif (rc < 0 || chan->number < 2)\n\t\t\treturn rc;\n\n\t\t \n\t\ti2c_msg.addr = fe_conf->address;\n\t\ti2c_msg.len = 3;\n\t\tbuf[0] = 0xf1;\n\t\tswitch (chan->number) {\n\t\tcase 2:\n\t\t\tbuf[1] = 0x5c;\n\t\t\tbuf[2] = 0xc2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbuf[1] = 0x61;\n\t\t\tbuf[2] = 0xcc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t\trc = i2c_transfer(i2c, &i2c_msg, 1);\n\t\tif (rc != 1) {\n\t\t\tdev_err(pdev, \"Could not setup DPNx\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else if (port_has_drxk(i2c, chan->number^2)) {\n\t\tchan->demod_type = DEMOD_TYPE_DRXK;\n\t\tdemod_attach_drxk(chan, i2c);\n\t} else if (port_has_stv0367(i2c)) {\n\t\tchan->demod_type = DEMOD_TYPE_STV0367;\n\t\tdev_info(pdev, \"STV0367 on channel %d\\n\", chan->number);\n\t\tdemod_attach_stv0367(chan, i2c);\n\t} else {\n\t\tdev_info(pdev, \"No demod found on chan %d\\n\", chan->number);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n\nstatic struct lgdt330x_config aver_m780 = {\n\t.demod_chip    = LGDT3303,\n\t.serial_mpeg   = 0x00,  \n\t.clock_polarity_flip = 1,\n};\n\nstatic struct mt2131_config m780_tunerconfig = {\n\t0xc0 >> 1\n};\n\n \nstatic int demod_attach_lg330x(struct ngene_channel *chan)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\n\tchan->fe = dvb_attach(lgdt330x_attach, &aver_m780,\n\t\t\t      0xb2 >> 1, &chan->i2c_adapter);\n\tif (chan->fe == NULL) {\n\t\tdev_err(pdev, \"No LGDT330x found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdvb_attach(mt2131_attach, chan->fe, &chan->i2c_adapter,\n\t\t   &m780_tunerconfig, 0);\n\n\treturn (chan->fe) ? 0 : -ENODEV;\n}\n\nstatic int demod_attach_drxd(struct ngene_channel *chan)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct drxd_config *feconf;\n\n\tfeconf = chan->dev->card_info->fe_config[chan->number];\n\n\tchan->fe = dvb_attach(drxd_attach, feconf, chan,\n\t\t\t&chan->i2c_adapter, &chan->dev->pci_dev->dev);\n\tif (!chan->fe) {\n\t\tdev_err(pdev, \"No DRXD found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int tuner_attach_dtt7520x(struct ngene_channel *chan)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct drxd_config *feconf;\n\n\tfeconf = chan->dev->card_info->fe_config[chan->number];\n\n\tif (!dvb_attach(dvb_pll_attach, chan->fe, feconf->pll_address,\n\t\t\t&chan->i2c_adapter,\n\t\t\tfeconf->pll_type)) {\n\t\tdev_err(pdev, \"No pll(%d) found!\\n\", feconf->pll_type);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n \n \n \n\n#define MICNG_EE_START      0x0100\n#define MICNG_EE_END        0x0FF0\n\n#define MICNG_EETAG_END0    0x0000\n#define MICNG_EETAG_END1    0xFFFF\n\n \n \n\n \n\n#define MICNG_EETAG_DRXD1_OSCDEVIATION  0x1000   \n#define MICNG_EETAG_DRXD2_OSCDEVIATION  0x1001   \n\n#define MICNG_EETAG_MT2060_1_1STIF      0x1100   \n#define MICNG_EETAG_MT2060_2_1STIF      0x1101   \n\n \n\n#define MICNG_EETAG_OEM_FIRST  0xC000\n#define MICNG_EETAG_OEM_LAST   0xFFEF\n\nstatic int i2c_write_eeprom(struct i2c_adapter *adapter,\n\t\t\t    u8 adr, u16 reg, u8 data)\n{\n\tstruct device *pdev = adapter->dev.parent;\n\tu8 m[3] = {(reg >> 8), (reg & 0xff), data};\n\tstruct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m,\n\t\t\t      .len = sizeof(m)};\n\n\tif (i2c_transfer(adapter, &msg, 1) != 1) {\n\t\tdev_err(pdev, \"Error writing EEPROM!\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int i2c_read_eeprom(struct i2c_adapter *adapter,\n\t\t\t   u8 adr, u16 reg, u8 *data, int len)\n{\n\tstruct device *pdev = adapter->dev.parent;\n\tu8 msg[2] = {(reg >> 8), (reg & 0xff)};\n\tstruct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,\n\t\t\t\t   .buf = msg, .len = 2 },\n\t\t\t\t  {.addr = adr, .flags = I2C_M_RD,\n\t\t\t\t   .buf = data, .len = len} };\n\n\tif (i2c_transfer(adapter, msgs, 2) != 2) {\n\t\tdev_err(pdev, \"Error reading EEPROM\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int ReadEEProm(struct i2c_adapter *adapter,\n\t\t      u16 Tag, u32 MaxLen, u8 *data, u32 *pLength)\n{\n\tstruct device *pdev = adapter->dev.parent;\n\tint status = 0;\n\tu16 Addr = MICNG_EE_START, Length, tag = 0;\n\tu8  EETag[3];\n\n\twhile (Addr + sizeof(u16) + 1 < MICNG_EE_END) {\n\t\tif (i2c_read_eeprom(adapter, 0x50, Addr, EETag, sizeof(EETag)))\n\t\t\treturn -1;\n\t\ttag = (EETag[0] << 8) | EETag[1];\n\t\tif (tag == MICNG_EETAG_END0 || tag == MICNG_EETAG_END1)\n\t\t\treturn -1;\n\t\tif (tag == Tag)\n\t\t\tbreak;\n\t\tAddr += sizeof(u16) + 1 + EETag[2];\n\t}\n\tif (Addr + sizeof(u16) + 1 + EETag[2] > MICNG_EE_END) {\n\t\tdev_err(pdev, \"Reached EOEE @ Tag = %04x Length = %3d\\n\",\n\t\t\ttag, EETag[2]);\n\t\treturn -1;\n\t}\n\tLength = EETag[2];\n\tif (Length > MaxLen)\n\t\tLength = (u16) MaxLen;\n\tif (Length > 0) {\n\t\tAddr += sizeof(u16) + 1;\n\t\tstatus = i2c_read_eeprom(adapter, 0x50, Addr, data, Length);\n\t\tif (!status) {\n\t\t\t*pLength = EETag[2];\n#if 0\n\t\t\tif (Length < EETag[2])\n\t\t\t\tstatus = STATUS_BUFFER_OVERFLOW;\n#endif\n\t\t}\n\t}\n\treturn status;\n}\n\nstatic int WriteEEProm(struct i2c_adapter *adapter,\n\t\t       u16 Tag, u32 Length, u8 *data)\n{\n\tstruct device *pdev = adapter->dev.parent;\n\tint status = 0;\n\tu16 Addr = MICNG_EE_START;\n\tu8 EETag[3];\n\tu16 tag = 0;\n\tint retry, i;\n\n\twhile (Addr + sizeof(u16) + 1 < MICNG_EE_END) {\n\t\tif (i2c_read_eeprom(adapter, 0x50, Addr, EETag, sizeof(EETag)))\n\t\t\treturn -1;\n\t\ttag = (EETag[0] << 8) | EETag[1];\n\t\tif (tag == MICNG_EETAG_END0 || tag == MICNG_EETAG_END1)\n\t\t\treturn -1;\n\t\tif (tag == Tag)\n\t\t\tbreak;\n\t\tAddr += sizeof(u16) + 1 + EETag[2];\n\t}\n\tif (Addr + sizeof(u16) + 1 + EETag[2] > MICNG_EE_END) {\n\t\tdev_err(pdev, \"Reached EOEE @ Tag = %04x Length = %3d\\n\",\n\t\t\ttag, EETag[2]);\n\t\treturn -1;\n\t}\n\n\tif (Length > EETag[2])\n\t\treturn -EINVAL;\n\t \n\tAddr += sizeof(u16) + 1;\n\tfor (i = 0; i < Length; i++, Addr++) {\n\t\tstatus = i2c_write_eeprom(adapter, 0x50, Addr, data[i]);\n\n\t\tif (status)\n\t\t\tbreak;\n\n\t\t \n\t\tretry = 10;\n\t\twhile (retry) {\n\t\t\tu8 Tmp;\n\n\t\t\tmsleep(50);\n\t\t\tstatus = i2c_read_eeprom(adapter, 0x50, Addr, &Tmp, 1);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t\tif (Tmp != data[i])\n\t\t\t\tdev_err(pdev, \"eeprom write error\\n\");\n\t\t\tretry -= 1;\n\t\t}\n\t\tif (status) {\n\t\t\tdev_err(pdev, \"Timeout polling eeprom\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn status;\n}\n\nstatic int eeprom_read_ushort(struct i2c_adapter *adapter, u16 tag, u16 *data)\n{\n\tint stat;\n\tu8 buf[2];\n\tu32 len = 0;\n\n\tstat = ReadEEProm(adapter, tag, 2, buf, &len);\n\tif (stat)\n\t\treturn stat;\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\t*data = (buf[0] << 8) | buf[1];\n\treturn 0;\n}\n\nstatic int eeprom_write_ushort(struct i2c_adapter *adapter, u16 tag, u16 data)\n{\n\tu8 buf[2];\n\n\tbuf[0] = data >> 8;\n\tbuf[1] = data & 0xff;\n\treturn WriteEEProm(adapter, tag, 2, buf);\n}\n\nstatic s16 osc_deviation(void *priv, s16 deviation, int flag)\n{\n\tstruct ngene_channel *chan = priv;\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct i2c_adapter *adap = &chan->i2c_adapter;\n\tu16 data = 0;\n\n\tif (flag) {\n\t\tdata = (u16) deviation;\n\t\tdev_info(pdev, \"write deviation %d\\n\",\n\t\t\t deviation);\n\t\teeprom_write_ushort(adap, 0x1000 + chan->number, data);\n\t} else {\n\t\tif (eeprom_read_ushort(adap, 0x1000 + chan->number, &data))\n\t\t\tdata = 0;\n\t\tdev_info(pdev, \"read deviation %d\\n\",\n\t\t\t (s16)data);\n\t}\n\n\treturn (s16) data;\n}\n\n \n \n \n\n\nstatic struct stv090x_config fe_cineS2 = {\n\t.device         = STV0900,\n\t.demod_mode     = STV090x_DUAL,\n\t.clk_mode       = STV090x_CLK_EXT,\n\n\t.xtal           = 27000000,\n\t.address        = 0x68,\n\n\t.ts1_mode       = STV090x_TSMODE_SERIAL_PUNCTURED,\n\t.ts2_mode       = STV090x_TSMODE_SERIAL_PUNCTURED,\n\n\t.repeater_level = STV090x_RPTLEVEL_16,\n\n\t.adc1_range\t= STV090x_ADC_1Vpp,\n\t.adc2_range\t= STV090x_ADC_1Vpp,\n\n\t.diseqc_envelope_mode = true,\n\n\t.tuner_i2c_lock = cineS2_tuner_i2c_lock,\n};\n\nstatic struct stv090x_config fe_cineS2_2 = {\n\t.device         = STV0900,\n\t.demod_mode     = STV090x_DUAL,\n\t.clk_mode       = STV090x_CLK_EXT,\n\n\t.xtal           = 27000000,\n\t.address        = 0x69,\n\n\t.ts1_mode       = STV090x_TSMODE_SERIAL_PUNCTURED,\n\t.ts2_mode       = STV090x_TSMODE_SERIAL_PUNCTURED,\n\n\t.repeater_level = STV090x_RPTLEVEL_16,\n\n\t.adc1_range\t= STV090x_ADC_1Vpp,\n\t.adc2_range\t= STV090x_ADC_1Vpp,\n\n\t.diseqc_envelope_mode = true,\n\n\t.tuner_i2c_lock = cineS2_tuner_i2c_lock,\n};\n\nstatic struct stv6110x_config tuner_cineS2_0 = {\n\t.addr\t= 0x60,\n\t.refclk\t= 27000000,\n\t.clk_div = 1,\n};\n\nstatic struct stv6110x_config tuner_cineS2_1 = {\n\t.addr\t= 0x63,\n\t.refclk\t= 27000000,\n\t.clk_div = 1,\n};\n\nstatic const struct ngene_info ngene_info_cineS2 = {\n\t.type\t\t= NGENE_SIDEWINDER,\n\t.name\t\t= \"Linux4Media cineS2 DVB-S2 Twin Tuner\",\n\t.io_type\t= {NGENE_IO_TSIN, NGENE_IO_TSIN},\n\t.demod_attach\t= {demod_attach_stv0900, demod_attach_stv0900},\n\t.tuner_attach\t= {tuner_attach_stv6110, tuner_attach_stv6110},\n\t.fe_config\t= {&fe_cineS2, &fe_cineS2},\n\t.tuner_config\t= {&tuner_cineS2_0, &tuner_cineS2_1},\n\t.lnb\t\t= {0x0b, 0x08},\n\t.tsf\t\t= {3, 3},\n\t.fw_version\t= 18,\n\t.msi_supported\t= true,\n};\n\nstatic const struct ngene_info ngene_info_satixS2 = {\n\t.type\t\t= NGENE_SIDEWINDER,\n\t.name\t\t= \"Mystique SaTiX-S2 Dual\",\n\t.io_type\t= {NGENE_IO_TSIN, NGENE_IO_TSIN},\n\t.demod_attach\t= {demod_attach_stv0900, demod_attach_stv0900},\n\t.tuner_attach\t= {tuner_attach_stv6110, tuner_attach_stv6110},\n\t.fe_config\t= {&fe_cineS2, &fe_cineS2},\n\t.tuner_config\t= {&tuner_cineS2_0, &tuner_cineS2_1},\n\t.lnb\t\t= {0x0b, 0x08},\n\t.tsf\t\t= {3, 3},\n\t.fw_version\t= 18,\n\t.msi_supported\t= true,\n};\n\nstatic const struct ngene_info ngene_info_satixS2v2 = {\n\t.type\t\t= NGENE_SIDEWINDER,\n\t.name\t\t= \"Mystique SaTiX-S2 Dual (v2)\",\n\t.io_type\t= {NGENE_IO_TSIN, NGENE_IO_TSIN, NGENE_IO_TSIN, NGENE_IO_TSIN,\n\t\t\t   NGENE_IO_TSOUT},\n\t.demod_attach\t= {demod_attach_stv0900, demod_attach_stv0900, cineS2_probe, cineS2_probe},\n\t.tuner_attach\t= {tuner_attach_stv6110, tuner_attach_stv6110, tuner_attach_probe, tuner_attach_probe},\n\t.fe_config\t= {&fe_cineS2, &fe_cineS2, &fe_cineS2_2, &fe_cineS2_2},\n\t.tuner_config\t= {&tuner_cineS2_0, &tuner_cineS2_1, &tuner_cineS2_0, &tuner_cineS2_1},\n\t.lnb\t\t= {0x0a, 0x08, 0x0b, 0x09},\n\t.tsf\t\t= {3, 3},\n\t.fw_version\t= 18,\n\t.msi_supported\t= true,\n};\n\nstatic const struct ngene_info ngene_info_cineS2v5 = {\n\t.type\t\t= NGENE_SIDEWINDER,\n\t.name\t\t= \"Linux4Media cineS2 DVB-S2 Twin Tuner (v5)\",\n\t.io_type\t= {NGENE_IO_TSIN, NGENE_IO_TSIN, NGENE_IO_TSIN, NGENE_IO_TSIN,\n\t\t\t   NGENE_IO_TSOUT},\n\t.demod_attach\t= {demod_attach_stv0900, demod_attach_stv0900, cineS2_probe, cineS2_probe},\n\t.tuner_attach\t= {tuner_attach_stv6110, tuner_attach_stv6110, tuner_attach_probe, tuner_attach_probe},\n\t.fe_config\t= {&fe_cineS2, &fe_cineS2, &fe_cineS2_2, &fe_cineS2_2},\n\t.tuner_config\t= {&tuner_cineS2_0, &tuner_cineS2_1, &tuner_cineS2_0, &tuner_cineS2_1},\n\t.lnb\t\t= {0x0a, 0x08, 0x0b, 0x09},\n\t.tsf\t\t= {3, 3},\n\t.fw_version\t= 18,\n\t.msi_supported\t= true,\n};\n\n\nstatic const struct ngene_info ngene_info_duoFlex = {\n\t.type           = NGENE_SIDEWINDER,\n\t.name           = \"Digital Devices DuoFlex PCIe or miniPCIe\",\n\t.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN, NGENE_IO_TSIN, NGENE_IO_TSIN,\n\t\t\t   NGENE_IO_TSOUT},\n\t.demod_attach   = {cineS2_probe, cineS2_probe, cineS2_probe, cineS2_probe},\n\t.tuner_attach   = {tuner_attach_probe, tuner_attach_probe, tuner_attach_probe, tuner_attach_probe},\n\t.fe_config      = {&fe_cineS2, &fe_cineS2, &fe_cineS2_2, &fe_cineS2_2},\n\t.tuner_config   = {&tuner_cineS2_0, &tuner_cineS2_1, &tuner_cineS2_0, &tuner_cineS2_1},\n\t.lnb            = {0x0a, 0x08, 0x0b, 0x09},\n\t.tsf            = {3, 3},\n\t.fw_version     = 18,\n\t.msi_supported\t= true,\n};\n\nstatic const struct ngene_info ngene_info_m780 = {\n\t.type           = NGENE_APP,\n\t.name           = \"Aver M780 ATSC/QAM-B\",\n\n\t \n\t.io_type        = { NGENE_IO_NONE, NGENE_IO_TSIN },\n\t.demod_attach   = { NULL, demod_attach_lg330x },\n\n\t \n\t.tuner_attach   = { NULL, NULL, NULL, NULL },\n\t.fe_config      = { NULL, &aver_m780 },\n\t.avf            = { 0 },\n\n\t \n\t.tsf\t\t= { 4, 4 },\n\t.fw_version\t= 15,\n};\n\nstatic struct drxd_config fe_terratec_dvbt_0 = {\n\t.index          = 0,\n\t.demod_address  = 0x70,\n\t.demod_revision = 0xa2,\n\t.demoda_address = 0x00,\n\t.pll_address    = 0x60,\n\t.pll_type       = DVB_PLL_THOMSON_DTT7520X,\n\t.clock          = 20000,\n\t.osc_deviation  = osc_deviation,\n};\n\nstatic struct drxd_config fe_terratec_dvbt_1 = {\n\t.index          = 1,\n\t.demod_address  = 0x71,\n\t.demod_revision = 0xa2,\n\t.demoda_address = 0x00,\n\t.pll_address    = 0x60,\n\t.pll_type       = DVB_PLL_THOMSON_DTT7520X,\n\t.clock          = 20000,\n\t.osc_deviation  = osc_deviation,\n};\n\nstatic const struct ngene_info ngene_info_terratec = {\n\t.type           = NGENE_TERRATEC,\n\t.name           = \"Terratec Integra/Cinergy2400i Dual DVB-T\",\n\t.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN},\n\t.demod_attach   = {demod_attach_drxd, demod_attach_drxd},\n\t.tuner_attach\t= {tuner_attach_dtt7520x, tuner_attach_dtt7520x},\n\t.fe_config      = {&fe_terratec_dvbt_0, &fe_terratec_dvbt_1},\n\t.i2c_access     = 1,\n};\n\n \n\n\n\n \n \n \n\n#define NGENE_ID(_subvend, _subdev, _driverdata) { \\\n\t.vendor = NGENE_VID, .device = NGENE_PID, \\\n\t.subvendor = _subvend, .subdevice = _subdev, \\\n\t.driver_data = (unsigned long) &_driverdata }\n\n \n\nstatic const struct pci_device_id ngene_id_tbl[] = {\n\tNGENE_ID(0x18c3, 0xab04, ngene_info_cineS2),\n\tNGENE_ID(0x18c3, 0xab05, ngene_info_cineS2v5),\n\tNGENE_ID(0x18c3, 0xabc3, ngene_info_cineS2),\n\tNGENE_ID(0x18c3, 0xabc4, ngene_info_cineS2),\n\tNGENE_ID(0x18c3, 0xdb01, ngene_info_satixS2),\n\tNGENE_ID(0x18c3, 0xdb02, ngene_info_satixS2v2),\n\tNGENE_ID(0x18c3, 0xdd00, ngene_info_cineS2v5),\n\tNGENE_ID(0x18c3, 0xdd10, ngene_info_duoFlex),\n\tNGENE_ID(0x18c3, 0xdd20, ngene_info_duoFlex),\n\tNGENE_ID(0x1461, 0x062e, ngene_info_m780),\n\tNGENE_ID(0x153b, 0x1167, ngene_info_terratec),\n\t{0}\n};\nMODULE_DEVICE_TABLE(pci, ngene_id_tbl);\n\n \n \n \n\nstatic pci_ers_result_t ngene_error_detected(struct pci_dev *dev,\n\t\t\t\t\t     pci_channel_state_t state)\n{\n\tdev_err(&dev->dev, \"PCI error\\n\");\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\tif (state == pci_channel_io_frozen)\n\t\treturn PCI_ERS_RESULT_NEED_RESET;\n\treturn PCI_ERS_RESULT_CAN_RECOVER;\n}\n\nstatic pci_ers_result_t ngene_slot_reset(struct pci_dev *dev)\n{\n\tdev_info(&dev->dev, \"slot reset\\n\");\n\treturn 0;\n}\n\nstatic void ngene_resume(struct pci_dev *dev)\n{\n\tdev_info(&dev->dev, \"resume\\n\");\n}\n\nstatic const struct pci_error_handlers ngene_errors = {\n\t.error_detected = ngene_error_detected,\n\t.slot_reset = ngene_slot_reset,\n\t.resume = ngene_resume,\n};\n\nstatic struct pci_driver ngene_pci_driver = {\n\t.name        = \"ngene\",\n\t.id_table    = ngene_id_tbl,\n\t.probe       = ngene_probe,\n\t.remove      = ngene_remove,\n\t.err_handler = &ngene_errors,\n\t.shutdown    = ngene_shutdown,\n};\n\nstatic __init int module_init_ngene(void)\n{\n\t \n\tpr_info(\"nGene PCIE bridge driver, Copyright (C) 2005-2007 Micronas\\n\");\n\n\treturn pci_register_driver(&ngene_pci_driver);\n}\n\nstatic __exit void module_exit_ngene(void)\n{\n\tpci_unregister_driver(&ngene_pci_driver);\n}\n\nmodule_init(module_init_ngene);\nmodule_exit(module_exit_ngene);\n\nMODULE_DESCRIPTION(\"nGene\");\nMODULE_AUTHOR(\"Micronas, Ralph Metzler, Manfred Voelkel\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}