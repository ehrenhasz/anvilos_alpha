{
  "module_name": "ngene-core.c",
  "hash_id": "a154b875a8533989db2a1ec648063c283ed6bbc1b864d208de77ff4ebca61450",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ngene/ngene-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/poll.h>\n#include <linux/io.h>\n#include <asm/div64.h>\n#include <linux/pci.h>\n#include <linux/timer.h>\n#include <linux/byteorder/generic.h>\n#include <linux/firmware.h>\n#include <linux/vmalloc.h>\n\n#include \"ngene.h\"\n\nstatic int one_adapter;\nmodule_param(one_adapter, int, 0444);\nMODULE_PARM_DESC(one_adapter, \"Use only one adapter.\");\n\nstatic int shutdown_workaround;\nmodule_param(shutdown_workaround, int, 0644);\nMODULE_PARM_DESC(shutdown_workaround, \"Activate workaround for shutdown problem with some chipsets.\");\n\nstatic int debug;\nmodule_param(debug, int, 0444);\nMODULE_PARM_DESC(debug, \"Print debugging information.\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define ngwriteb(dat, adr)         writeb((dat), dev->iomem + (adr))\n#define ngwritel(dat, adr)         writel((dat), dev->iomem + (adr))\n#define ngwriteb(dat, adr)         writeb((dat), dev->iomem + (adr))\n#define ngreadl(adr)               readl(dev->iomem + (adr))\n#define ngreadb(adr)               readb(dev->iomem + (adr))\n#define ngcpyto(adr, src, count)   memcpy_toio(dev->iomem + (adr), (src), (count))\n#define ngcpyfrom(dst, adr, count) memcpy_fromio((dst), dev->iomem + (adr), (count))\n\n \n \n \n\nstatic void event_tasklet(struct tasklet_struct *t)\n{\n\tstruct ngene *dev = from_tasklet(dev, t, event_tasklet);\n\n\twhile (dev->EventQueueReadIndex != dev->EventQueueWriteIndex) {\n\t\tstruct EVENT_BUFFER Event =\n\t\t\tdev->EventQueue[dev->EventQueueReadIndex];\n\t\tdev->EventQueueReadIndex =\n\t\t\t(dev->EventQueueReadIndex + 1) & (EVENT_QUEUE_SIZE - 1);\n\n\t\tif ((Event.UARTStatus & 0x01) && (dev->TxEventNotify))\n\t\t\tdev->TxEventNotify(dev, Event.TimeStamp);\n\t\tif ((Event.UARTStatus & 0x02) && (dev->RxEventNotify))\n\t\t\tdev->RxEventNotify(dev, Event.TimeStamp,\n\t\t\t\t\t   Event.RXCharacter);\n\t}\n}\n\nstatic void demux_tasklet(struct tasklet_struct *t)\n{\n\tstruct ngene_channel *chan = from_tasklet(chan, t, demux_tasklet);\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tstruct SBufferHeader *Cur = chan->nextBuffer;\n\n\tspin_lock_irq(&chan->state_lock);\n\n\twhile (Cur->ngeneBuffer.SR.Flags & 0x80) {\n\t\tif (chan->mode & NGENE_IO_TSOUT) {\n\t\t\tu32 Flags = chan->DataFormatFlags;\n\t\t\tif (Cur->ngeneBuffer.SR.Flags & 0x20)\n\t\t\t\tFlags |= BEF_OVERFLOW;\n\t\t\tif (chan->pBufferExchange) {\n\t\t\t\tif (!chan->pBufferExchange(chan,\n\t\t\t\t\t\t\t   Cur->Buffer1,\n\t\t\t\t\t\t\t   chan->Capture1Length,\n\t\t\t\t\t\t\t   Cur->ngeneBuffer.SR.\n\t\t\t\t\t\t\t   Clock, Flags)) {\n\t\t\t\t\t \n\n\t\t\t\t\tif (chan->HWState == HWSTATE_RUN) {\n\t\t\t\t\t\tCur->ngeneBuffer.SR.Flags &=\n\t\t\t\t\t\t\t~0x40;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t \n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tchan->HWState = HWSTATE_RUN;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev_err(pdev, \"OOPS\\n\");\n\t\t\t\tif (chan->HWState == HWSTATE_RUN) {\n\t\t\t\t\tCur->ngeneBuffer.SR.Flags &= ~0x40;\n\t\t\t\t\tbreak;\t \n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chan->AudioDTOUpdated) {\n\t\t\t\tdev_info(pdev, \"Update AudioDTO = %d\\n\",\n\t\t\t\t\t chan->AudioDTOValue);\n\t\t\t\tCur->ngeneBuffer.SR.DTOUpdate =\n\t\t\t\t\tchan->AudioDTOValue;\n\t\t\t\tchan->AudioDTOUpdated = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (chan->HWState == HWSTATE_RUN) {\n\t\t\t\tu32 Flags = chan->DataFormatFlags;\n\t\t\t\tIBufferExchange *exch1 = chan->pBufferExchange;\n\t\t\t\tIBufferExchange *exch2 = chan->pBufferExchange2;\n\t\t\t\tif (Cur->ngeneBuffer.SR.Flags & 0x01)\n\t\t\t\t\tFlags |= BEF_EVEN_FIELD;\n\t\t\t\tif (Cur->ngeneBuffer.SR.Flags & 0x20)\n\t\t\t\t\tFlags |= BEF_OVERFLOW;\n\t\t\t\tspin_unlock_irq(&chan->state_lock);\n\t\t\t\tif (exch1)\n\t\t\t\t\texch1(chan, Cur->Buffer1,\n\t\t\t\t\t\tchan->Capture1Length,\n\t\t\t\t\t\tCur->ngeneBuffer.SR.Clock,\n\t\t\t\t\t\tFlags);\n\t\t\t\tif (exch2)\n\t\t\t\t\texch2(chan, Cur->Buffer2,\n\t\t\t\t\t\tchan->Capture2Length,\n\t\t\t\t\t\tCur->ngeneBuffer.SR.Clock,\n\t\t\t\t\t\tFlags);\n\t\t\t\tspin_lock_irq(&chan->state_lock);\n\t\t\t} else if (chan->HWState != HWSTATE_STOP)\n\t\t\t\tchan->HWState = HWSTATE_RUN;\n\t\t}\n\t\tCur->ngeneBuffer.SR.Flags = 0x00;\n\t\tCur = Cur->Next;\n\t}\n\tchan->nextBuffer = Cur;\n\n\tspin_unlock_irq(&chan->state_lock);\n}\n\nstatic irqreturn_t irq_handler(int irq, void *dev_id)\n{\n\tstruct ngene *dev = (struct ngene *)dev_id;\n\tstruct device *pdev = &dev->pci_dev->dev;\n\tu32 icounts = 0;\n\tirqreturn_t rc = IRQ_NONE;\n\tu32 i = MAX_STREAM;\n\tu8 *tmpCmdDoneByte;\n\n\tif (dev->BootFirmware) {\n\t\ticounts = ngreadl(NGENE_INT_COUNTS);\n\t\tif (icounts != dev->icounts) {\n\t\t\tngwritel(0, FORCE_NMI);\n\t\t\tdev->cmd_done = 1;\n\t\t\twake_up(&dev->cmd_wq);\n\t\t\tdev->icounts = icounts;\n\t\t\trc = IRQ_HANDLED;\n\t\t}\n\t\treturn rc;\n\t}\n\n\tngwritel(0, FORCE_NMI);\n\n\tspin_lock(&dev->cmd_lock);\n\ttmpCmdDoneByte = dev->CmdDoneByte;\n\tif (tmpCmdDoneByte &&\n\t    (*tmpCmdDoneByte ||\n\t    (dev->ngenetohost[0] == 1 && dev->ngenetohost[1] != 0))) {\n\t\tdev->CmdDoneByte = NULL;\n\t\tdev->cmd_done = 1;\n\t\twake_up(&dev->cmd_wq);\n\t\trc = IRQ_HANDLED;\n\t}\n\tspin_unlock(&dev->cmd_lock);\n\n\tif (dev->EventBuffer->EventStatus & 0x80) {\n\t\tu8 nextWriteIndex =\n\t\t\t(dev->EventQueueWriteIndex + 1) &\n\t\t\t(EVENT_QUEUE_SIZE - 1);\n\t\tif (nextWriteIndex != dev->EventQueueReadIndex) {\n\t\t\tdev->EventQueue[dev->EventQueueWriteIndex] =\n\t\t\t\t*(dev->EventBuffer);\n\t\t\tdev->EventQueueWriteIndex = nextWriteIndex;\n\t\t} else {\n\t\t\tdev_err(pdev, \"event overflow\\n\");\n\t\t\tdev->EventQueueOverflowCount += 1;\n\t\t\tdev->EventQueueOverflowFlag = 1;\n\t\t}\n\t\tdev->EventBuffer->EventStatus &= ~0x80;\n\t\ttasklet_schedule(&dev->event_tasklet);\n\t\trc = IRQ_HANDLED;\n\t}\n\n\twhile (i > 0) {\n\t\ti--;\n\t\tspin_lock(&dev->channel[i].state_lock);\n\t\t \n\t\tif (dev->channel[i].nextBuffer) {\n\t\t\tif ((dev->channel[i].nextBuffer->\n\t\t\t     ngeneBuffer.SR.Flags & 0xC0) == 0x80) {\n\t\t\t\tdev->channel[i].nextBuffer->\n\t\t\t\t\tngeneBuffer.SR.Flags |= 0x40;\n\t\t\t\ttasklet_schedule(\n\t\t\t\t\t&dev->channel[i].demux_tasklet);\n\t\t\t\trc = IRQ_HANDLED;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dev->channel[i].state_lock);\n\t}\n\n\t \n\treturn IRQ_HANDLED;\n}\n\n \n \n \n\nstatic void dump_command_io(struct ngene *dev)\n{\n\tstruct device *pdev = &dev->pci_dev->dev;\n\tu8 buf[8], *b;\n\n\tngcpyfrom(buf, HOST_TO_NGENE, 8);\n\tdev_err(pdev, \"host_to_ngene (%04x): %*ph\\n\", HOST_TO_NGENE, 8, buf);\n\n\tngcpyfrom(buf, NGENE_TO_HOST, 8);\n\tdev_err(pdev, \"ngene_to_host (%04x): %*ph\\n\", NGENE_TO_HOST, 8, buf);\n\n\tb = dev->hosttongene;\n\tdev_err(pdev, \"dev->hosttongene (%p): %*ph\\n\", b, 8, b);\n\n\tb = dev->ngenetohost;\n\tdev_err(pdev, \"dev->ngenetohost (%p): %*ph\\n\", b, 8, b);\n}\n\nstatic int ngene_command_mutex(struct ngene *dev, struct ngene_command *com)\n{\n\tstruct device *pdev = &dev->pci_dev->dev;\n\tint ret;\n\tu8 *tmpCmdDoneByte;\n\n\tdev->cmd_done = 0;\n\n\tif (com->cmd.hdr.Opcode == CMD_FWLOAD_PREPARE) {\n\t\tdev->BootFirmware = 1;\n\t\tdev->icounts = ngreadl(NGENE_INT_COUNTS);\n\t\tngwritel(0, NGENE_COMMAND);\n\t\tngwritel(0, NGENE_COMMAND_HI);\n\t\tngwritel(0, NGENE_STATUS);\n\t\tngwritel(0, NGENE_STATUS_HI);\n\t\tngwritel(0, NGENE_EVENT);\n\t\tngwritel(0, NGENE_EVENT_HI);\n\t} else if (com->cmd.hdr.Opcode == CMD_FWLOAD_FINISH) {\n\t\tu64 fwio = dev->PAFWInterfaceBuffer;\n\n\t\tngwritel(fwio & 0xffffffff, NGENE_COMMAND);\n\t\tngwritel(fwio >> 32, NGENE_COMMAND_HI);\n\t\tngwritel((fwio + 256) & 0xffffffff, NGENE_STATUS);\n\t\tngwritel((fwio + 256) >> 32, NGENE_STATUS_HI);\n\t\tngwritel((fwio + 512) & 0xffffffff, NGENE_EVENT);\n\t\tngwritel((fwio + 512) >> 32, NGENE_EVENT_HI);\n\t}\n\n\tmemcpy(dev->FWInterfaceBuffer, com->cmd.raw8, com->in_len + 2);\n\n\tif (dev->BootFirmware)\n\t\tngcpyto(HOST_TO_NGENE, com->cmd.raw8, com->in_len + 2);\n\n\tspin_lock_irq(&dev->cmd_lock);\n\ttmpCmdDoneByte = dev->ngenetohost + com->out_len;\n\tif (!com->out_len)\n\t\ttmpCmdDoneByte++;\n\t*tmpCmdDoneByte = 0;\n\tdev->ngenetohost[0] = 0;\n\tdev->ngenetohost[1] = 0;\n\tdev->CmdDoneByte = tmpCmdDoneByte;\n\tspin_unlock_irq(&dev->cmd_lock);\n\n\t \n\tngwritel(1, FORCE_INT);\n\n\tret = wait_event_timeout(dev->cmd_wq, dev->cmd_done == 1, 2 * HZ);\n\tif (!ret) {\n\t\t \n\n\t\tdev_err(pdev, \"Command timeout cmd=%02x prev=%02x\\n\",\n\t\t\tcom->cmd.hdr.Opcode, dev->prev_cmd);\n\t\tdump_command_io(dev);\n\t\treturn -1;\n\t}\n\tif (com->cmd.hdr.Opcode == CMD_FWLOAD_FINISH)\n\t\tdev->BootFirmware = 0;\n\n\tdev->prev_cmd = com->cmd.hdr.Opcode;\n\n\tif (!com->out_len)\n\t\treturn 0;\n\n\tmemcpy(com->cmd.raw8, dev->ngenetohost, com->out_len);\n\n\treturn 0;\n}\n\nint ngene_command(struct ngene *dev, struct ngene_command *com)\n{\n\tint result;\n\n\tmutex_lock(&dev->cmd_mutex);\n\tresult = ngene_command_mutex(dev, com);\n\tmutex_unlock(&dev->cmd_mutex);\n\treturn result;\n}\n\n\nstatic int ngene_command_load_firmware(struct ngene *dev,\n\t\t\t\t       u8 *ngene_fw, u32 size)\n{\n#define FIRSTCHUNK (1024)\n\tu32 cleft;\n\tstruct ngene_command com;\n\n\tcom.cmd.hdr.Opcode = CMD_FWLOAD_PREPARE;\n\tcom.cmd.hdr.Length = 0;\n\tcom.in_len = 0;\n\tcom.out_len = 0;\n\n\tngene_command(dev, &com);\n\n\tcleft = (size + 3) & ~3;\n\tif (cleft > FIRSTCHUNK) {\n\t\tngcpyto(PROGRAM_SRAM + FIRSTCHUNK, ngene_fw + FIRSTCHUNK,\n\t\t\tcleft - FIRSTCHUNK);\n\t\tcleft = FIRSTCHUNK;\n\t}\n\tngcpyto(DATA_FIFO_AREA, ngene_fw, cleft);\n\n\tmemset(&com, 0, sizeof(struct ngene_command));\n\tcom.cmd.hdr.Opcode = CMD_FWLOAD_FINISH;\n\tcom.cmd.hdr.Length = 4;\n\tcom.cmd.FWLoadFinish.Address = DATA_FIFO_AREA;\n\tcom.cmd.FWLoadFinish.Length = (unsigned short)cleft;\n\tcom.in_len = 4;\n\tcom.out_len = 0;\n\n\treturn ngene_command(dev, &com);\n}\n\n\nstatic int ngene_command_config_buf(struct ngene *dev, u8 config)\n{\n\tstruct ngene_command com;\n\n\tcom.cmd.hdr.Opcode = CMD_CONFIGURE_BUFFER;\n\tcom.cmd.hdr.Length = 1;\n\tcom.cmd.ConfigureBuffers.config = config;\n\tcom.in_len = 1;\n\tcom.out_len = 0;\n\n\tif (ngene_command(dev, &com) < 0)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int ngene_command_config_free_buf(struct ngene *dev, u8 *config)\n{\n\tstruct ngene_command com;\n\n\tcom.cmd.hdr.Opcode = CMD_CONFIGURE_FREE_BUFFER;\n\tcom.cmd.hdr.Length = 6;\n\tmemcpy(&com.cmd.ConfigureFreeBuffers.config, config, 6);\n\tcom.in_len = 6;\n\tcom.out_len = 0;\n\n\tif (ngene_command(dev, &com) < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint ngene_command_gpio_set(struct ngene *dev, u8 select, u8 level)\n{\n\tstruct ngene_command com;\n\n\tcom.cmd.hdr.Opcode = CMD_SET_GPIO_PIN;\n\tcom.cmd.hdr.Length = 1;\n\tcom.cmd.SetGpioPin.select = select | (level << 7);\n\tcom.in_len = 1;\n\tcom.out_len = 0;\n\n\treturn ngene_command(dev, &com);\n}\n\n\n \n\n \n\nstatic u8 TSFeatureDecoderSetup[8 * 5] = {\n\t0x42, 0x00, 0x00, 0x02, 0x02, 0xbc, 0x00, 0x00,\n\t0x40, 0x06, 0x00, 0x02, 0x02, 0xbc, 0x00, 0x00,\t \n\t0x71, 0x07, 0x00, 0x02, 0x02, 0xbc, 0x00, 0x00,\t \n\t0x72, 0x00, 0x00, 0x02, 0x02, 0xbc, 0x00, 0x00,\t \n\t0x40, 0x07, 0x00, 0x02, 0x02, 0xbc, 0x00, 0x00,  \n};\n\n \nstatic u8 I2SConfiguration[] = {\n\t0x00, 0x10, 0x00, 0x00,\n\t0x80, 0x10, 0x00, 0x00,\n};\n\nstatic u8 SPDIFConfiguration[10] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\n \n\nstatic u8 TS_I2SConfiguration[4] = { 0x3E, 0x18, 0x00, 0x00 };\n\nstatic u8 TS_I2SOutConfiguration[4] = { 0x80, 0x04, 0x00, 0x00 };\n\nstatic u8 ITUDecoderSetup[4][16] = {\n\t{0x1c, 0x13, 0x01, 0x68, 0x3d, 0x90, 0x14, 0x20,   \n\t 0x00, 0x00, 0x01, 0xb0, 0x9c, 0x00, 0x00, 0x00},\n\t{0x9c, 0x03, 0x23, 0xC0, 0x60, 0x0E, 0x13, 0x00,\n\t 0x00, 0x00, 0x00, 0x01, 0xB0, 0x00, 0x00, 0x00},\n\t{0x9f, 0x00, 0x23, 0xC0, 0x60, 0x0F, 0x13, 0x00,   \n\t 0x00, 0x00, 0x00, 0x01, 0xB0, 0x00, 0x00, 0x00},\n\t{0x9c, 0x01, 0x23, 0xC0, 0x60, 0x0E, 0x13, 0x00,   \n\t 0x00, 0x00, 0x00, 0x01, 0xB0, 0x00, 0x00, 0x00},\n};\n\n \n\n \nstatic u8 ITUFeatureDecoderSetup[8] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x04, 0x00\n};\n\nvoid FillTSBuffer(void *Buffer, int Length, u32 Flags)\n{\n\tu32 *ptr = Buffer;\n\n\tmemset(Buffer, TS_FILLER, Length);\n\twhile (Length > 0) {\n\t\tif (Flags & DF_SWAP32)\n\t\t\t*ptr = 0x471FFF10;\n\t\telse\n\t\t\t*ptr = 0x10FF1F47;\n\t\tptr += (188 / 4);\n\t\tLength -= 188;\n\t}\n}\n\n\nstatic void flush_buffers(struct ngene_channel *chan)\n{\n\tu8 val;\n\n\tdo {\n\t\tmsleep(1);\n\t\tspin_lock_irq(&chan->state_lock);\n\t\tval = chan->nextBuffer->ngeneBuffer.SR.Flags & 0x80;\n\t\tspin_unlock_irq(&chan->state_lock);\n\t} while (val);\n}\n\nstatic void clear_buffers(struct ngene_channel *chan)\n{\n\tstruct SBufferHeader *Cur = chan->nextBuffer;\n\n\tdo {\n\t\tmemset(&Cur->ngeneBuffer.SR, 0, sizeof(Cur->ngeneBuffer.SR));\n\t\tif (chan->mode & NGENE_IO_TSOUT)\n\t\t\tFillTSBuffer(Cur->Buffer1,\n\t\t\t\t     chan->Capture1Length,\n\t\t\t\t     chan->DataFormatFlags);\n\t\tCur = Cur->Next;\n\t} while (Cur != chan->nextBuffer);\n\n\tif (chan->mode & NGENE_IO_TSOUT) {\n\t\tchan->nextBuffer->ngeneBuffer.SR.DTOUpdate =\n\t\t\tchan->AudioDTOValue;\n\t\tchan->AudioDTOUpdated = 0;\n\n\t\tCur = chan->TSIdleBuffer.Head;\n\n\t\tdo {\n\t\t\tmemset(&Cur->ngeneBuffer.SR, 0,\n\t\t\t       sizeof(Cur->ngeneBuffer.SR));\n\t\t\tFillTSBuffer(Cur->Buffer1,\n\t\t\t\t     chan->Capture1Length,\n\t\t\t\t     chan->DataFormatFlags);\n\t\t\tCur = Cur->Next;\n\t\t} while (Cur != chan->TSIdleBuffer.Head);\n\t}\n}\n\nstatic int ngene_command_stream_control(struct ngene *dev, u8 stream,\n\t\t\t\t\tu8 control, u8 mode, u8 flags)\n{\n\tstruct device *pdev = &dev->pci_dev->dev;\n\tstruct ngene_channel *chan = &dev->channel[stream];\n\tstruct ngene_command com;\n\tu16 BsUVI = ((stream & 1) ? 0x9400 : 0x9300);\n\tu16 BsSDI = ((stream & 1) ? 0x9600 : 0x9500);\n\tu16 BsSPI = ((stream & 1) ? 0x9800 : 0x9700);\n\tu16 BsSDO = 0x9B00;\n\n\tmemset(&com, 0, sizeof(com));\n\tcom.cmd.hdr.Opcode = CMD_CONTROL;\n\tcom.cmd.hdr.Length = sizeof(struct FW_STREAM_CONTROL) - 2;\n\tcom.cmd.StreamControl.Stream = stream | (control ? 8 : 0);\n\tif (chan->mode & NGENE_IO_TSOUT)\n\t\tcom.cmd.StreamControl.Stream |= 0x07;\n\tcom.cmd.StreamControl.Control = control |\n\t\t(flags & SFLAG_ORDER_LUMA_CHROMA);\n\tcom.cmd.StreamControl.Mode = mode;\n\tcom.in_len = sizeof(struct FW_STREAM_CONTROL);\n\tcom.out_len = 0;\n\n\tdev_dbg(pdev, \"Stream=%02x, Control=%02x, Mode=%02x\\n\",\n\t\tcom.cmd.StreamControl.Stream, com.cmd.StreamControl.Control,\n\t\tcom.cmd.StreamControl.Mode);\n\n\tchan->Mode = mode;\n\n\tif (!(control & 0x80)) {\n\t\tspin_lock_irq(&chan->state_lock);\n\t\tif (chan->State == KSSTATE_RUN) {\n\t\t\tchan->State = KSSTATE_ACQUIRE;\n\t\t\tchan->HWState = HWSTATE_STOP;\n\t\t\tspin_unlock_irq(&chan->state_lock);\n\t\t\tif (ngene_command(dev, &com) < 0)\n\t\t\t\treturn -1;\n\t\t\t \n\t\t\tflush_buffers(chan);\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock_irq(&chan->state_lock);\n\t\treturn 0;\n\t}\n\n\tif (mode & SMODE_AUDIO_CAPTURE) {\n\t\tcom.cmd.StreamControl.CaptureBlockCount =\n\t\t\tchan->Capture1Length / AUDIO_BLOCK_SIZE;\n\t\tcom.cmd.StreamControl.Buffer_Address = chan->RingBuffer.PAHead;\n\t} else if (mode & SMODE_TRANSPORT_STREAM) {\n\t\tcom.cmd.StreamControl.CaptureBlockCount =\n\t\t\tchan->Capture1Length / TS_BLOCK_SIZE;\n\t\tcom.cmd.StreamControl.MaxLinesPerField =\n\t\t\tchan->Capture1Length / TS_BLOCK_SIZE;\n\t\tcom.cmd.StreamControl.Buffer_Address =\n\t\t\tchan->TSRingBuffer.PAHead;\n\t\tif (chan->mode & NGENE_IO_TSOUT) {\n\t\t\tcom.cmd.StreamControl.BytesPerVBILine =\n\t\t\t\tchan->Capture1Length / TS_BLOCK_SIZE;\n\t\t\tcom.cmd.StreamControl.Stream |= 0x07;\n\t\t}\n\t} else {\n\t\tcom.cmd.StreamControl.BytesPerVideoLine = chan->nBytesPerLine;\n\t\tcom.cmd.StreamControl.MaxLinesPerField = chan->nLines;\n\t\tcom.cmd.StreamControl.MinLinesPerField = 100;\n\t\tcom.cmd.StreamControl.Buffer_Address = chan->RingBuffer.PAHead;\n\n\t\tif (mode & SMODE_VBI_CAPTURE) {\n\t\t\tcom.cmd.StreamControl.MaxVBILinesPerField =\n\t\t\t\tchan->nVBILines;\n\t\t\tcom.cmd.StreamControl.MinVBILinesPerField = 0;\n\t\t\tcom.cmd.StreamControl.BytesPerVBILine =\n\t\t\t\tchan->nBytesPerVBILine;\n\t\t}\n\t\tif (flags & SFLAG_COLORBAR)\n\t\t\tcom.cmd.StreamControl.Stream |= 0x04;\n\t}\n\n\tspin_lock_irq(&chan->state_lock);\n\tif (mode & SMODE_AUDIO_CAPTURE) {\n\t\tchan->nextBuffer = chan->RingBuffer.Head;\n\t\tif (mode & SMODE_AUDIO_SPDIF) {\n\t\t\tcom.cmd.StreamControl.SetupDataLen =\n\t\t\t\tsizeof(SPDIFConfiguration);\n\t\t\tcom.cmd.StreamControl.SetupDataAddr = BsSPI;\n\t\t\tmemcpy(com.cmd.StreamControl.SetupData,\n\t\t\t       SPDIFConfiguration, sizeof(SPDIFConfiguration));\n\t\t} else {\n\t\t\tcom.cmd.StreamControl.SetupDataLen = 4;\n\t\t\tcom.cmd.StreamControl.SetupDataAddr = BsSDI;\n\t\t\tmemcpy(com.cmd.StreamControl.SetupData,\n\t\t\t       I2SConfiguration +\n\t\t\t       4 * dev->card_info->i2s[stream], 4);\n\t\t}\n\t} else if (mode & SMODE_TRANSPORT_STREAM) {\n\t\tchan->nextBuffer = chan->TSRingBuffer.Head;\n\t\tif (stream >= STREAM_AUDIOIN1) {\n\t\t\tif (chan->mode & NGENE_IO_TSOUT) {\n\t\t\t\tcom.cmd.StreamControl.SetupDataLen =\n\t\t\t\t\tsizeof(TS_I2SOutConfiguration);\n\t\t\t\tcom.cmd.StreamControl.SetupDataAddr = BsSDO;\n\t\t\t\tmemcpy(com.cmd.StreamControl.SetupData,\n\t\t\t\t       TS_I2SOutConfiguration,\n\t\t\t\t       sizeof(TS_I2SOutConfiguration));\n\t\t\t} else {\n\t\t\t\tcom.cmd.StreamControl.SetupDataLen =\n\t\t\t\t\tsizeof(TS_I2SConfiguration);\n\t\t\t\tcom.cmd.StreamControl.SetupDataAddr = BsSDI;\n\t\t\t\tmemcpy(com.cmd.StreamControl.SetupData,\n\t\t\t\t       TS_I2SConfiguration,\n\t\t\t\t       sizeof(TS_I2SConfiguration));\n\t\t\t}\n\t\t} else {\n\t\t\tcom.cmd.StreamControl.SetupDataLen = 8;\n\t\t\tcom.cmd.StreamControl.SetupDataAddr = BsUVI + 0x10;\n\t\t\tmemcpy(com.cmd.StreamControl.SetupData,\n\t\t\t       TSFeatureDecoderSetup +\n\t\t\t       8 * dev->card_info->tsf[stream], 8);\n\t\t}\n\t} else {\n\t\tchan->nextBuffer = chan->RingBuffer.Head;\n\t\tcom.cmd.StreamControl.SetupDataLen =\n\t\t\t16 + sizeof(ITUFeatureDecoderSetup);\n\t\tcom.cmd.StreamControl.SetupDataAddr = BsUVI;\n\t\tmemcpy(com.cmd.StreamControl.SetupData,\n\t\t       ITUDecoderSetup[chan->itumode], 16);\n\t\tmemcpy(com.cmd.StreamControl.SetupData + 16,\n\t\t       ITUFeatureDecoderSetup, sizeof(ITUFeatureDecoderSetup));\n\t}\n\tclear_buffers(chan);\n\tchan->State = KSSTATE_RUN;\n\tif (mode & SMODE_TRANSPORT_STREAM)\n\t\tchan->HWState = HWSTATE_RUN;\n\telse\n\t\tchan->HWState = HWSTATE_STARTUP;\n\tspin_unlock_irq(&chan->state_lock);\n\n\tif (ngene_command(dev, &com) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nvoid set_transfer(struct ngene_channel *chan, int state)\n{\n\tstruct device *pdev = &chan->dev->pci_dev->dev;\n\tu8 control = 0, mode = 0, flags = 0;\n\tstruct ngene *dev = chan->dev;\n\tint ret;\n\n\t \n\n\tif (state) {\n\t\tif (chan->running) {\n\t\t\tdev_info(pdev, \"already running\\n\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (!chan->running) {\n\t\t\tdev_info(pdev, \"already stopped\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dev->card_info->switch_ctrl)\n\t\tdev->card_info->switch_ctrl(chan, 1, state ^ 1);\n\n\tif (state) {\n\t\tspin_lock_irq(&chan->state_lock);\n\n\t\t \n\t\tdvb_ringbuffer_flush(&dev->tsout_rbuf);\n\t\tcontrol = 0x80;\n\t\tif (chan->mode & (NGENE_IO_TSIN | NGENE_IO_TSOUT)) {\n\t\t\tchan->Capture1Length = 512 * 188;\n\t\t\tmode = SMODE_TRANSPORT_STREAM;\n\t\t}\n\t\tif (chan->mode & NGENE_IO_TSOUT) {\n\t\t\tchan->pBufferExchange = tsout_exchange;\n\t\t\t \n\t\t\tchan->AudioDTOValue = 0x80000000;\n\t\t\tchan->AudioDTOUpdated = 1;\n\t\t}\n\t\tif (chan->mode & NGENE_IO_TSIN)\n\t\t\tchan->pBufferExchange = tsin_exchange;\n\t\tspin_unlock_irq(&chan->state_lock);\n\t}\n\t\t \n\n\tmutex_lock(&dev->stream_mutex);\n\tret = ngene_command_stream_control(dev, chan->number,\n\t\t\t\t\t   control, mode, flags);\n\tmutex_unlock(&dev->stream_mutex);\n\n\tif (!ret)\n\t\tchan->running = state;\n\telse\n\t\tdev_err(pdev, \"%s %d failed\\n\", __func__, state);\n\tif (!state) {\n\t\tspin_lock_irq(&chan->state_lock);\n\t\tchan->pBufferExchange = NULL;\n\t\tdvb_ringbuffer_flush(&dev->tsout_rbuf);\n\t\tspin_unlock_irq(&chan->state_lock);\n\t}\n}\n\n\n \n \n \n\nstatic void free_ringbuffer(struct ngene *dev, struct SRingBufferDescriptor *rb)\n{\n\tstruct SBufferHeader *Cur = rb->Head;\n\tu32 j;\n\n\tif (!Cur)\n\t\treturn;\n\n\tfor (j = 0; j < rb->NumBuffers; j++, Cur = Cur->Next) {\n\t\tif (Cur->Buffer1)\n\t\t\tdma_free_coherent(&dev->pci_dev->dev,\n\t\t\t\t\t  rb->Buffer1Length, Cur->Buffer1,\n\t\t\t\t\t  Cur->scList1->Address);\n\n\t\tif (Cur->Buffer2)\n\t\t\tdma_free_coherent(&dev->pci_dev->dev,\n\t\t\t\t\t  rb->Buffer2Length, Cur->Buffer2,\n\t\t\t\t\t  Cur->scList2->Address);\n\t}\n\n\tif (rb->SCListMem)\n\t\tdma_free_coherent(&dev->pci_dev->dev, rb->SCListMemSize,\n\t\t\t\t  rb->SCListMem, rb->PASCListMem);\n\n\tdma_free_coherent(&dev->pci_dev->dev, rb->MemSize, rb->Head,\n\t\t\t  rb->PAHead);\n}\n\nstatic void free_idlebuffer(struct ngene *dev,\n\t\t     struct SRingBufferDescriptor *rb,\n\t\t     struct SRingBufferDescriptor *tb)\n{\n\tint j;\n\tstruct SBufferHeader *Cur = tb->Head;\n\n\tif (!rb->Head)\n\t\treturn;\n\tfree_ringbuffer(dev, rb);\n\tfor (j = 0; j < tb->NumBuffers; j++, Cur = Cur->Next) {\n\t\tCur->Buffer2 = NULL;\n\t\tCur->scList2 = NULL;\n\t\tCur->ngeneBuffer.Address_of_first_entry_2 = 0;\n\t\tCur->ngeneBuffer.Number_of_entries_2 = 0;\n\t}\n}\n\nstatic void free_common_buffers(struct ngene *dev)\n{\n\tu32 i;\n\tstruct ngene_channel *chan;\n\n\tfor (i = STREAM_VIDEOIN1; i < MAX_STREAM; i++) {\n\t\tchan = &dev->channel[i];\n\t\tfree_idlebuffer(dev, &chan->TSIdleBuffer, &chan->TSRingBuffer);\n\t\tfree_ringbuffer(dev, &chan->RingBuffer);\n\t\tfree_ringbuffer(dev, &chan->TSRingBuffer);\n\t}\n\n\tif (dev->OverflowBuffer)\n\t\tdma_free_coherent(&dev->pci_dev->dev, OVERFLOW_BUFFER_SIZE,\n\t\t\t\t  dev->OverflowBuffer, dev->PAOverflowBuffer);\n\n\tif (dev->FWInterfaceBuffer)\n\t\tdma_free_coherent(&dev->pci_dev->dev, 4096,\n\t\t\t\t  dev->FWInterfaceBuffer,\n\t\t\t\t  dev->PAFWInterfaceBuffer);\n}\n\n \n \n \n\nstatic int create_ring_buffer(struct pci_dev *pci_dev,\n\t\t       struct SRingBufferDescriptor *descr, u32 NumBuffers)\n{\n\tdma_addr_t tmp;\n\tstruct SBufferHeader *Head;\n\tu32 i;\n\tu32 MemSize = SIZEOF_SBufferHeader * NumBuffers;\n\tu64 PARingBufferHead;\n\tu64 PARingBufferCur;\n\tu64 PARingBufferNext;\n\tstruct SBufferHeader *Cur, *Next;\n\n\tdescr->Head = NULL;\n\tdescr->MemSize = 0;\n\tdescr->PAHead = 0;\n\tdescr->NumBuffers = 0;\n\n\tif (MemSize < 4096)\n\t\tMemSize = 4096;\n\n\tHead = dma_alloc_coherent(&pci_dev->dev, MemSize, &tmp, GFP_KERNEL);\n\tPARingBufferHead = tmp;\n\n\tif (!Head)\n\t\treturn -ENOMEM;\n\n\tPARingBufferCur = PARingBufferHead;\n\tCur = Head;\n\n\tfor (i = 0; i < NumBuffers - 1; i++) {\n\t\tNext = (struct SBufferHeader *)\n\t\t\t(((u8 *) Cur) + SIZEOF_SBufferHeader);\n\t\tPARingBufferNext = PARingBufferCur + SIZEOF_SBufferHeader;\n\t\tCur->Next = Next;\n\t\tCur->ngeneBuffer.Next = PARingBufferNext;\n\t\tCur = Next;\n\t\tPARingBufferCur = PARingBufferNext;\n\t}\n\t \n\tCur->Next = Head;\n\tCur->ngeneBuffer.Next = PARingBufferHead;\n\n\tdescr->Head       = Head;\n\tdescr->MemSize    = MemSize;\n\tdescr->PAHead     = PARingBufferHead;\n\tdescr->NumBuffers = NumBuffers;\n\n\treturn 0;\n}\n\nstatic int AllocateRingBuffers(struct pci_dev *pci_dev,\n\t\t\t       dma_addr_t of,\n\t\t\t       struct SRingBufferDescriptor *pRingBuffer,\n\t\t\t       u32 Buffer1Length, u32 Buffer2Length)\n{\n\tdma_addr_t tmp;\n\tu32 i, j;\n\tu32 SCListMemSize = pRingBuffer->NumBuffers\n\t\t* ((Buffer2Length != 0) ? (NUM_SCATTER_GATHER_ENTRIES * 2) :\n\t\t    NUM_SCATTER_GATHER_ENTRIES)\n\t\t* sizeof(struct HW_SCATTER_GATHER_ELEMENT);\n\n\tu64 PASCListMem;\n\tstruct HW_SCATTER_GATHER_ELEMENT *SCListEntry;\n\tu64 PASCListEntry;\n\tstruct SBufferHeader *Cur;\n\tvoid *SCListMem;\n\n\tif (SCListMemSize < 4096)\n\t\tSCListMemSize = 4096;\n\n\tSCListMem = dma_alloc_coherent(&pci_dev->dev, SCListMemSize, &tmp,\n\t\t\t\t       GFP_KERNEL);\n\n\tPASCListMem = tmp;\n\tif (SCListMem == NULL)\n\t\treturn -ENOMEM;\n\n\tpRingBuffer->SCListMem = SCListMem;\n\tpRingBuffer->PASCListMem = PASCListMem;\n\tpRingBuffer->SCListMemSize = SCListMemSize;\n\tpRingBuffer->Buffer1Length = Buffer1Length;\n\tpRingBuffer->Buffer2Length = Buffer2Length;\n\n\tSCListEntry = SCListMem;\n\tPASCListEntry = PASCListMem;\n\tCur = pRingBuffer->Head;\n\n\tfor (i = 0; i < pRingBuffer->NumBuffers; i += 1, Cur = Cur->Next) {\n\t\tu64 PABuffer;\n\n\t\tvoid *Buffer = dma_alloc_coherent(&pci_dev->dev,\n\t\t\t\t\t\t  Buffer1Length, &tmp, GFP_KERNEL);\n\t\tPABuffer = tmp;\n\n\t\tif (Buffer == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tCur->Buffer1 = Buffer;\n\n\t\tSCListEntry->Address = PABuffer;\n\t\tSCListEntry->Length  = Buffer1Length;\n\n\t\tCur->scList1 = SCListEntry;\n\t\tCur->ngeneBuffer.Address_of_first_entry_1 = PASCListEntry;\n\t\tCur->ngeneBuffer.Number_of_entries_1 =\n\t\t\tNUM_SCATTER_GATHER_ENTRIES;\n\n\t\tSCListEntry += 1;\n\t\tPASCListEntry += sizeof(struct HW_SCATTER_GATHER_ELEMENT);\n\n#if NUM_SCATTER_GATHER_ENTRIES > 1\n\t\tfor (j = 0; j < NUM_SCATTER_GATHER_ENTRIES - 1; j += 1) {\n\t\t\tSCListEntry->Address = of;\n\t\t\tSCListEntry->Length = OVERFLOW_BUFFER_SIZE;\n\t\t\tSCListEntry += 1;\n\t\t\tPASCListEntry +=\n\t\t\t\tsizeof(struct HW_SCATTER_GATHER_ELEMENT);\n\t\t}\n#endif\n\n\t\tif (!Buffer2Length)\n\t\t\tcontinue;\n\n\t\tBuffer = dma_alloc_coherent(&pci_dev->dev, Buffer2Length,\n\t\t\t\t\t    &tmp, GFP_KERNEL);\n\t\tPABuffer = tmp;\n\n\t\tif (Buffer == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tCur->Buffer2 = Buffer;\n\n\t\tSCListEntry->Address = PABuffer;\n\t\tSCListEntry->Length  = Buffer2Length;\n\n\t\tCur->scList2 = SCListEntry;\n\t\tCur->ngeneBuffer.Address_of_first_entry_2 = PASCListEntry;\n\t\tCur->ngeneBuffer.Number_of_entries_2 =\n\t\t\tNUM_SCATTER_GATHER_ENTRIES;\n\n\t\tSCListEntry   += 1;\n\t\tPASCListEntry += sizeof(struct HW_SCATTER_GATHER_ELEMENT);\n\n#if NUM_SCATTER_GATHER_ENTRIES > 1\n\t\tfor (j = 0; j < NUM_SCATTER_GATHER_ENTRIES - 1; j++) {\n\t\t\tSCListEntry->Address = of;\n\t\t\tSCListEntry->Length = OVERFLOW_BUFFER_SIZE;\n\t\t\tSCListEntry += 1;\n\t\t\tPASCListEntry +=\n\t\t\t\tsizeof(struct HW_SCATTER_GATHER_ELEMENT);\n\t\t}\n#endif\n\n\t}\n\n\treturn 0;\n}\n\nstatic int FillTSIdleBuffer(struct SRingBufferDescriptor *pIdleBuffer,\n\t\t\t    struct SRingBufferDescriptor *pRingBuffer)\n{\n\t \n\tu32 n = pRingBuffer->NumBuffers;\n\n\t \n\tstruct SBufferHeader *Cur = pRingBuffer->Head;\n\tint i;\n\t \n\tfor (i = 0; i < n; i++) {\n\t\tCur->Buffer2 = pIdleBuffer->Head->Buffer1;\n\t\tCur->scList2 = pIdleBuffer->Head->scList1;\n\t\tCur->ngeneBuffer.Address_of_first_entry_2 =\n\t\t\tpIdleBuffer->Head->ngeneBuffer.\n\t\t\tAddress_of_first_entry_1;\n\t\tCur->ngeneBuffer.Number_of_entries_2 =\n\t\t\tpIdleBuffer->Head->ngeneBuffer.Number_of_entries_1;\n\t\tCur = Cur->Next;\n\t}\n\treturn 0;\n}\n\nstatic u32 RingBufferSizes[MAX_STREAM] = {\n\tRING_SIZE_VIDEO,\n\tRING_SIZE_VIDEO,\n\tRING_SIZE_AUDIO,\n\tRING_SIZE_AUDIO,\n\tRING_SIZE_AUDIO,\n};\n\nstatic u32 Buffer1Sizes[MAX_STREAM] = {\n\tMAX_VIDEO_BUFFER_SIZE,\n\tMAX_VIDEO_BUFFER_SIZE,\n\tMAX_AUDIO_BUFFER_SIZE,\n\tMAX_AUDIO_BUFFER_SIZE,\n\tMAX_AUDIO_BUFFER_SIZE\n};\n\nstatic u32 Buffer2Sizes[MAX_STREAM] = {\n\tMAX_VBI_BUFFER_SIZE,\n\tMAX_VBI_BUFFER_SIZE,\n\t0,\n\t0,\n\t0\n};\n\n\nstatic int AllocCommonBuffers(struct ngene *dev)\n{\n\tint status = 0, i;\n\n\tdev->FWInterfaceBuffer = dma_alloc_coherent(&dev->pci_dev->dev, 4096,\n\t\t\t\t\t\t    &dev->PAFWInterfaceBuffer,\n\t\t\t\t\t\t    GFP_KERNEL);\n\tif (!dev->FWInterfaceBuffer)\n\t\treturn -ENOMEM;\n\tdev->hosttongene = dev->FWInterfaceBuffer;\n\tdev->ngenetohost = dev->FWInterfaceBuffer + 256;\n\tdev->EventBuffer = dev->FWInterfaceBuffer + 512;\n\n\tdev->OverflowBuffer = dma_alloc_coherent(&dev->pci_dev->dev,\n\t\t\t\t\t\t OVERFLOW_BUFFER_SIZE,\n\t\t\t\t\t\t &dev->PAOverflowBuffer, GFP_KERNEL);\n\tif (!dev->OverflowBuffer)\n\t\treturn -ENOMEM;\n\n\tfor (i = STREAM_VIDEOIN1; i < MAX_STREAM; i++) {\n\t\tint type = dev->card_info->io_type[i];\n\n\t\tdev->channel[i].State = KSSTATE_STOP;\n\n\t\tif (type & (NGENE_IO_TV | NGENE_IO_HDTV | NGENE_IO_AIN)) {\n\t\t\tstatus = create_ring_buffer(dev->pci_dev,\n\t\t\t\t\t\t    &dev->channel[i].RingBuffer,\n\t\t\t\t\t\t    RingBufferSizes[i]);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\tif (type & (NGENE_IO_TV | NGENE_IO_AIN)) {\n\t\t\t\tstatus = AllocateRingBuffers(dev->pci_dev,\n\t\t\t\t\t\t\t     dev->\n\t\t\t\t\t\t\t     PAOverflowBuffer,\n\t\t\t\t\t\t\t     &dev->channel[i].\n\t\t\t\t\t\t\t     RingBuffer,\n\t\t\t\t\t\t\t     Buffer1Sizes[i],\n\t\t\t\t\t\t\t     Buffer2Sizes[i]);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t} else if (type & NGENE_IO_HDTV) {\n\t\t\t\tstatus = AllocateRingBuffers(dev->pci_dev,\n\t\t\t\t\t\t\t     dev->\n\t\t\t\t\t\t\t     PAOverflowBuffer,\n\t\t\t\t\t\t\t     &dev->channel[i].\n\t\t\t\t\t\t\t     RingBuffer,\n\t\t\t\t\t\t\t   MAX_HDTV_BUFFER_SIZE,\n\t\t\t\t\t\t\t     0);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (type & (NGENE_IO_TSIN | NGENE_IO_TSOUT)) {\n\n\t\t\tstatus = create_ring_buffer(dev->pci_dev,\n\t\t\t\t\t\t    &dev->channel[i].\n\t\t\t\t\t\t    TSRingBuffer, RING_SIZE_TS);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\tstatus = AllocateRingBuffers(dev->pci_dev,\n\t\t\t\t\t\t     dev->PAOverflowBuffer,\n\t\t\t\t\t\t     &dev->channel[i].\n\t\t\t\t\t\t     TSRingBuffer,\n\t\t\t\t\t\t     MAX_TS_BUFFER_SIZE, 0);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (type & NGENE_IO_TSOUT) {\n\t\t\tstatus = create_ring_buffer(dev->pci_dev,\n\t\t\t\t\t\t    &dev->channel[i].\n\t\t\t\t\t\t    TSIdleBuffer, 1);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tstatus = AllocateRingBuffers(dev->pci_dev,\n\t\t\t\t\t\t     dev->PAOverflowBuffer,\n\t\t\t\t\t\t     &dev->channel[i].\n\t\t\t\t\t\t     TSIdleBuffer,\n\t\t\t\t\t\t     MAX_TS_BUFFER_SIZE, 0);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t\tFillTSIdleBuffer(&dev->channel[i].TSIdleBuffer,\n\t\t\t\t\t &dev->channel[i].TSRingBuffer);\n\t\t}\n\t}\n\treturn status;\n}\n\nstatic void ngene_release_buffers(struct ngene *dev)\n{\n\tif (dev->iomem)\n\t\tiounmap(dev->iomem);\n\tfree_common_buffers(dev);\n\tvfree(dev->tsout_buf);\n\tvfree(dev->tsin_buf);\n\tvfree(dev->ain_buf);\n\tvfree(dev->vin_buf);\n\tvfree(dev);\n}\n\nstatic int ngene_get_buffers(struct ngene *dev)\n{\n\tif (AllocCommonBuffers(dev))\n\t\treturn -ENOMEM;\n\tif (dev->card_info->io_type[4] & NGENE_IO_TSOUT) {\n\t\tdev->tsout_buf = vmalloc(TSOUT_BUF_SIZE);\n\t\tif (!dev->tsout_buf)\n\t\t\treturn -ENOMEM;\n\t\tdvb_ringbuffer_init(&dev->tsout_rbuf,\n\t\t\t\t    dev->tsout_buf, TSOUT_BUF_SIZE);\n\t}\n\tif (dev->card_info->io_type[2]&NGENE_IO_TSIN) {\n\t\tdev->tsin_buf = vmalloc(TSIN_BUF_SIZE);\n\t\tif (!dev->tsin_buf)\n\t\t\treturn -ENOMEM;\n\t\tdvb_ringbuffer_init(&dev->tsin_rbuf,\n\t\t\t\t    dev->tsin_buf, TSIN_BUF_SIZE);\n\t}\n\tif (dev->card_info->io_type[2] & NGENE_IO_AIN) {\n\t\tdev->ain_buf = vmalloc(AIN_BUF_SIZE);\n\t\tif (!dev->ain_buf)\n\t\t\treturn -ENOMEM;\n\t\tdvb_ringbuffer_init(&dev->ain_rbuf, dev->ain_buf, AIN_BUF_SIZE);\n\t}\n\tif (dev->card_info->io_type[0] & NGENE_IO_HDTV) {\n\t\tdev->vin_buf = vmalloc(VIN_BUF_SIZE);\n\t\tif (!dev->vin_buf)\n\t\t\treturn -ENOMEM;\n\t\tdvb_ringbuffer_init(&dev->vin_rbuf, dev->vin_buf, VIN_BUF_SIZE);\n\t}\n\tdev->iomem = ioremap(pci_resource_start(dev->pci_dev, 0),\n\t\t\t     pci_resource_len(dev->pci_dev, 0));\n\tif (!dev->iomem)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void ngene_init(struct ngene *dev)\n{\n\tstruct device *pdev = &dev->pci_dev->dev;\n\tint i;\n\n\ttasklet_setup(&dev->event_tasklet, event_tasklet);\n\n\tmemset_io(dev->iomem + 0xc000, 0x00, 0x220);\n\tmemset_io(dev->iomem + 0xc400, 0x00, 0x100);\n\n\tfor (i = 0; i < MAX_STREAM; i++) {\n\t\tdev->channel[i].dev = dev;\n\t\tdev->channel[i].number = i;\n\t}\n\n\tdev->fw_interface_version = 0;\n\n\tngwritel(0, NGENE_INT_ENABLE);\n\n\tdev->icounts = ngreadl(NGENE_INT_COUNTS);\n\n\tdev->device_version = ngreadl(DEV_VER) & 0x0f;\n\tdev_info(pdev, \"Device version %d\\n\", dev->device_version);\n}\n\nstatic int ngene_load_firm(struct ngene *dev)\n{\n\tstruct device *pdev = &dev->pci_dev->dev;\n\tu32 size;\n\tconst struct firmware *fw = NULL;\n\tu8 *ngene_fw;\n\tchar *fw_name;\n\tint err, version;\n\n\tversion = dev->card_info->fw_version;\n\n\tswitch (version) {\n\tdefault:\n\tcase 15:\n\t\tversion = 15;\n\t\tsize = 23466;\n\t\tfw_name = \"ngene_15.fw\";\n\t\tdev->cmd_timeout_workaround = true;\n\t\tbreak;\n\tcase 16:\n\t\tsize = 23498;\n\t\tfw_name = \"ngene_16.fw\";\n\t\tdev->cmd_timeout_workaround = true;\n\t\tbreak;\n\tcase 17:\n\t\tsize = 24446;\n\t\tfw_name = \"ngene_17.fw\";\n\t\tdev->cmd_timeout_workaround = true;\n\t\tbreak;\n\tcase 18:\n\t\tsize = 0;\n\t\tfw_name = \"ngene_18.fw\";\n\t\tbreak;\n\t}\n\n\tif (request_firmware(&fw, fw_name, &dev->pci_dev->dev) < 0) {\n\t\tdev_err(pdev, \"Could not load firmware file %s.\\n\", fw_name);\n\t\tdev_info(pdev, \"Copy %s to your hotplug directory!\\n\",\n\t\t\t fw_name);\n\t\treturn -1;\n\t}\n\tif (size == 0)\n\t\tsize = fw->size;\n\tif (size != fw->size) {\n\t\tdev_err(pdev, \"Firmware %s has invalid size!\", fw_name);\n\t\terr = -1;\n\t} else {\n\t\tdev_info(pdev, \"Loading firmware file %s.\\n\", fw_name);\n\t\tngene_fw = (u8 *) fw->data;\n\t\terr = ngene_command_load_firmware(dev, ngene_fw, size);\n\t}\n\n\trelease_firmware(fw);\n\n\treturn err;\n}\n\nstatic void ngene_stop(struct ngene *dev)\n{\n\tmutex_destroy(&dev->cmd_mutex);\n\ti2c_del_adapter(&(dev->channel[0].i2c_adapter));\n\ti2c_del_adapter(&(dev->channel[1].i2c_adapter));\n\tngwritel(0, NGENE_INT_ENABLE);\n\tngwritel(0, NGENE_COMMAND);\n\tngwritel(0, NGENE_COMMAND_HI);\n\tngwritel(0, NGENE_STATUS);\n\tngwritel(0, NGENE_STATUS_HI);\n\tngwritel(0, NGENE_EVENT);\n\tngwritel(0, NGENE_EVENT_HI);\n\tfree_irq(dev->pci_dev->irq, dev);\n#ifdef CONFIG_PCI_MSI\n\tif (dev->msi_enabled)\n\t\tpci_disable_msi(dev->pci_dev);\n#endif\n}\n\nstatic int ngene_buffer_config(struct ngene *dev)\n{\n\tint stat;\n\n\tif (dev->card_info->fw_version >= 17) {\n\t\tu8 tsin12_config[6]   = { 0x60, 0x60, 0x00, 0x00, 0x00, 0x00 };\n\t\tu8 tsin1234_config[6] = { 0x30, 0x30, 0x00, 0x30, 0x30, 0x00 };\n\t\tu8 tsio1235_config[6] = { 0x30, 0x30, 0x00, 0x28, 0x00, 0x38 };\n\t\tu8 *bconf = tsin12_config;\n\n\t\tif (dev->card_info->io_type[2]&NGENE_IO_TSIN &&\n\t\t    dev->card_info->io_type[3]&NGENE_IO_TSIN) {\n\t\t\tbconf = tsin1234_config;\n\t\t\tif (dev->card_info->io_type[4]&NGENE_IO_TSOUT &&\n\t\t\t    dev->ci.en)\n\t\t\t\tbconf = tsio1235_config;\n\t\t}\n\t\tstat = ngene_command_config_free_buf(dev, bconf);\n\t} else {\n\t\tint bconf = BUFFER_CONFIG_4422;\n\n\t\tif (dev->card_info->io_type[3] == NGENE_IO_TSIN)\n\t\t\tbconf = BUFFER_CONFIG_3333;\n\t\tstat = ngene_command_config_buf(dev, bconf);\n\t}\n\treturn stat;\n}\n\n\nstatic int ngene_start(struct ngene *dev)\n{\n\tint stat;\n\tint i;\n\n\tpci_set_master(dev->pci_dev);\n\tngene_init(dev);\n\n\tstat = request_irq(dev->pci_dev->irq, irq_handler,\n\t\t\t   IRQF_SHARED, \"nGene\",\n\t\t\t   (void *)dev);\n\tif (stat < 0)\n\t\treturn stat;\n\n\tinit_waitqueue_head(&dev->cmd_wq);\n\tinit_waitqueue_head(&dev->tx_wq);\n\tinit_waitqueue_head(&dev->rx_wq);\n\tmutex_init(&dev->cmd_mutex);\n\tmutex_init(&dev->stream_mutex);\n\tsema_init(&dev->pll_mutex, 1);\n\tmutex_init(&dev->i2c_switch_mutex);\n\tspin_lock_init(&dev->cmd_lock);\n\tfor (i = 0; i < MAX_STREAM; i++)\n\t\tspin_lock_init(&dev->channel[i].state_lock);\n\tngwritel(1, TIMESTAMPS);\n\n\tngwritel(1, NGENE_INT_ENABLE);\n\n\tstat = ngene_load_firm(dev);\n\tif (stat < 0)\n\t\tgoto fail;\n\n#ifdef CONFIG_PCI_MSI\n\t \n\tif (pci_msi_enabled() && dev->card_info->msi_supported) {\n\t\tstruct device *pdev = &dev->pci_dev->dev;\n\t\tunsigned long flags;\n\n\t\tngwritel(0, NGENE_INT_ENABLE);\n\t\tfree_irq(dev->pci_dev->irq, dev);\n\t\tstat = pci_enable_msi(dev->pci_dev);\n\t\tif (stat) {\n\t\t\tdev_info(pdev, \"MSI not available\\n\");\n\t\t\tflags = IRQF_SHARED;\n\t\t} else {\n\t\t\tflags = 0;\n\t\t\tdev->msi_enabled = true;\n\t\t}\n\t\tstat = request_irq(dev->pci_dev->irq, irq_handler,\n\t\t\t\t\tflags, \"nGene\", dev);\n\t\tif (stat < 0)\n\t\t\tgoto fail2;\n\t\tngwritel(1, NGENE_INT_ENABLE);\n\t}\n#endif\n\n\tstat = ngene_i2c_init(dev, 0);\n\tif (stat < 0)\n\t\tgoto fail;\n\n\tstat = ngene_i2c_init(dev, 1);\n\tif (stat < 0)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tngwritel(0, NGENE_INT_ENABLE);\n\tfree_irq(dev->pci_dev->irq, dev);\n#ifdef CONFIG_PCI_MSI\nfail2:\n\tif (dev->msi_enabled)\n\t\tpci_disable_msi(dev->pci_dev);\n#endif\n\treturn stat;\n}\n\n \n \n \n\nstatic void release_channel(struct ngene_channel *chan)\n{\n\tstruct dvb_demux *dvbdemux = &chan->demux;\n\tstruct ngene *dev = chan->dev;\n\n\tif (chan->running)\n\t\tset_transfer(chan, 0);\n\n\ttasklet_kill(&chan->demux_tasklet);\n\n\tif (chan->ci_dev) {\n\t\tdvb_unregister_device(chan->ci_dev);\n\t\tchan->ci_dev = NULL;\n\t}\n\n\tif (chan->fe2)\n\t\tdvb_unregister_frontend(chan->fe2);\n\n\tif (chan->fe) {\n\t\tdvb_unregister_frontend(chan->fe);\n\n\t\t \n\t\tif (chan->i2c_client_fe) {\n\t\t\tdvb_module_release(chan->i2c_client[0]);\n\t\t\tchan->i2c_client[0] = NULL;\n\t\t}\n\n\t\tdvb_frontend_detach(chan->fe);\n\t\tchan->fe = NULL;\n\t}\n\n\tif (chan->has_demux) {\n\t\tdvb_net_release(&chan->dvbnet);\n\t\tdvbdemux->dmx.close(&dvbdemux->dmx);\n\t\tdvbdemux->dmx.remove_frontend(&dvbdemux->dmx,\n\t\t\t\t\t      &chan->hw_frontend);\n\t\tdvbdemux->dmx.remove_frontend(&dvbdemux->dmx,\n\t\t\t\t\t      &chan->mem_frontend);\n\t\tdvb_dmxdev_release(&chan->dmxdev);\n\t\tdvb_dmx_release(&chan->demux);\n\t\tchan->has_demux = false;\n\t}\n\n\tif (chan->has_adapter) {\n\t\tdvb_unregister_adapter(&dev->adapter[chan->number]);\n\t\tchan->has_adapter = false;\n\t}\n}\n\nstatic int init_channel(struct ngene_channel *chan)\n{\n\tint ret = 0, nr = chan->number;\n\tstruct dvb_adapter *adapter = NULL;\n\tstruct dvb_demux *dvbdemux = &chan->demux;\n\tstruct ngene *dev = chan->dev;\n\tstruct ngene_info *ni = dev->card_info;\n\tint io = ni->io_type[nr];\n\n\ttasklet_setup(&chan->demux_tasklet, demux_tasklet);\n\tchan->users = 0;\n\tchan->type = io;\n\tchan->mode = chan->type;\t \n\tchan->i2c_client_fe = 0;\t \n\n\tif (io & NGENE_IO_TSIN) {\n\t\tchan->fe = NULL;\n\t\tif (ni->demod_attach[nr]) {\n\t\t\tret = ni->demod_attach[nr](chan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (chan->fe && ni->tuner_attach[nr]) {\n\t\t\tret = ni->tuner_attach[nr](chan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (!dev->ci.en && (io & NGENE_IO_TSOUT))\n\t\treturn 0;\n\n\tif (io & (NGENE_IO_TSIN | NGENE_IO_TSOUT)) {\n\t\tif (nr >= STREAM_AUDIOIN1)\n\t\t\tchan->DataFormatFlags = DF_SWAP32;\n\n\t\tif (nr == 0 || !one_adapter || dev->first_adapter == NULL) {\n\t\t\tadapter = &dev->adapter[nr];\n\t\t\tret = dvb_register_adapter(adapter, \"nGene\",\n\t\t\t\t\t\t   THIS_MODULE,\n\t\t\t\t\t\t   &chan->dev->pci_dev->dev,\n\t\t\t\t\t\t   adapter_nr);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t\tif (dev->first_adapter == NULL)\n\t\t\t\tdev->first_adapter = adapter;\n\t\t\tchan->has_adapter = true;\n\t\t} else\n\t\t\tadapter = dev->first_adapter;\n\t}\n\n\tif (dev->ci.en && (io & NGENE_IO_TSOUT)) {\n\t\tdvb_ca_en50221_init(adapter, dev->ci.en, 0, 1);\n\t\tset_transfer(chan, 1);\n\t\tchan->dev->channel[2].DataFormatFlags = DF_SWAP32;\n\t\tset_transfer(&chan->dev->channel[2], 1);\n\t\tdvb_register_device(adapter, &chan->ci_dev,\n\t\t\t\t    &ngene_dvbdev_ci, (void *) chan,\n\t\t\t\t    DVB_DEVICE_SEC, 0);\n\t\tif (!chan->ci_dev)\n\t\t\tgoto err;\n\t}\n\n\tif (chan->fe) {\n\t\tif (dvb_register_frontend(adapter, chan->fe) < 0)\n\t\t\tgoto err;\n\t\tchan->has_demux = true;\n\t}\n\tif (chan->fe2) {\n\t\tif (dvb_register_frontend(adapter, chan->fe2) < 0)\n\t\t\tgoto err;\n\t\tif (chan->fe) {\n\t\t\tchan->fe2->tuner_priv = chan->fe->tuner_priv;\n\t\t\tmemcpy(&chan->fe2->ops.tuner_ops,\n\t\t\t       &chan->fe->ops.tuner_ops,\n\t\t\t       sizeof(struct dvb_tuner_ops));\n\t\t}\n\t}\n\n\tif (chan->has_demux) {\n\t\tret = my_dvb_dmx_ts_card_init(dvbdemux, \"SW demux\",\n\t\t\t\t\t      ngene_start_feed,\n\t\t\t\t\t      ngene_stop_feed, chan);\n\t\tret = my_dvb_dmxdev_ts_card_init(&chan->dmxdev, &chan->demux,\n\t\t\t\t\t\t &chan->hw_frontend,\n\t\t\t\t\t\t &chan->mem_frontend, adapter);\n\t\tret = dvb_net_init(adapter, &chan->dvbnet, &chan->demux.dmx);\n\t}\n\n\treturn ret;\n\nerr:\n\tif (chan->fe) {\n\t\tdvb_frontend_detach(chan->fe);\n\t\tchan->fe = NULL;\n\t}\n\trelease_channel(chan);\n\treturn 0;\n}\n\nstatic int init_channels(struct ngene *dev)\n{\n\tint i, j;\n\n\tfor (i = 0; i < MAX_STREAM; i++) {\n\t\tdev->channel[i].number = i;\n\t\tif (init_channel(&dev->channel[i]) < 0) {\n\t\t\tfor (j = i - 1; j >= 0; j--)\n\t\t\t\trelease_channel(&dev->channel[j]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct cxd2099_cfg cxd_cfgtmpl = {\n\t.bitrate = 62000,\n\t.polarity = 0,\n\t.clock_mode = 0,\n};\n\nstatic void cxd_attach(struct ngene *dev)\n{\n\tstruct device *pdev = &dev->pci_dev->dev;\n\tstruct ngene_ci *ci = &dev->ci;\n\tstruct cxd2099_cfg cxd_cfg = cxd_cfgtmpl;\n\tstruct i2c_client *client;\n\tint ret;\n\tu8 type;\n\n\t \n\tret = ngene_port_has_cxd2099(&dev->channel[0].i2c_adapter, &type);\n\tif (!ret) {\n\t\tdev_dbg(pdev, \"No CXD2099AR found\\n\");\n\t\treturn;\n\t}\n\n\tif (type != 1) {\n\t\tdev_warn(pdev, \"CXD2099AR is uninitialized!\\n\");\n\t\treturn;\n\t}\n\n\tcxd_cfg.en = &ci->en;\n\tclient = dvb_module_probe(\"cxd2099\", NULL,\n\t\t\t\t  &dev->channel[0].i2c_adapter,\n\t\t\t\t  0x40, &cxd_cfg);\n\tif (!client)\n\t\tgoto err;\n\n\tci->dev = dev;\n\tdev->channel[0].i2c_client[0] = client;\n\treturn;\n\nerr:\n\tdev_err(pdev, \"CXD2099AR attach failed\\n\");\n\treturn;\n}\n\nstatic void cxd_detach(struct ngene *dev)\n{\n\tstruct ngene_ci *ci = &dev->ci;\n\n\tdvb_ca_en50221_release(ci->en);\n\n\tdvb_module_release(dev->channel[0].i2c_client[0]);\n\tdev->channel[0].i2c_client[0] = NULL;\n\tci->en = NULL;\n}\n\n \n \n \n\nstatic void ngene_unlink(struct ngene *dev)\n{\n\tstruct ngene_command com;\n\n\tcom.cmd.hdr.Opcode = CMD_MEM_WRITE;\n\tcom.cmd.hdr.Length = 3;\n\tcom.cmd.MemoryWrite.address = 0x910c;\n\tcom.cmd.MemoryWrite.data = 0xff;\n\tcom.in_len = 3;\n\tcom.out_len = 1;\n\n\tmutex_lock(&dev->cmd_mutex);\n\tngwritel(0, NGENE_INT_ENABLE);\n\tngene_command_mutex(dev, &com);\n\tmutex_unlock(&dev->cmd_mutex);\n}\n\nvoid ngene_shutdown(struct pci_dev *pdev)\n{\n\tstruct ngene *dev = pci_get_drvdata(pdev);\n\n\tif (!dev || !shutdown_workaround)\n\t\treturn;\n\n\tdev_info(&pdev->dev, \"shutdown workaround...\\n\");\n\tngene_unlink(dev);\n\tpci_disable_device(pdev);\n}\n\n \n \n \n\nvoid ngene_remove(struct pci_dev *pdev)\n{\n\tstruct ngene *dev = pci_get_drvdata(pdev);\n\tint i;\n\n\ttasklet_kill(&dev->event_tasklet);\n\tfor (i = MAX_STREAM - 1; i >= 0; i--)\n\t\trelease_channel(&dev->channel[i]);\n\tif (dev->ci.en)\n\t\tcxd_detach(dev);\n\tngene_stop(dev);\n\tngene_release_buffers(dev);\n\tpci_disable_device(pdev);\n}\n\nint ngene_probe(struct pci_dev *pci_dev, const struct pci_device_id *id)\n{\n\tstruct ngene *dev;\n\tint stat = 0;\n\n\tif (pci_enable_device(pci_dev) < 0)\n\t\treturn -ENODEV;\n\n\tdev = vzalloc(sizeof(struct ngene));\n\tif (dev == NULL) {\n\t\tstat = -ENOMEM;\n\t\tgoto fail0;\n\t}\n\n\tdev->pci_dev = pci_dev;\n\tdev->card_info = (struct ngene_info *)id->driver_data;\n\tdev_info(&pci_dev->dev, \"Found %s\\n\", dev->card_info->name);\n\n\tpci_set_drvdata(pci_dev, dev);\n\n\t \n\tstat = ngene_get_buffers(dev);\n\tif (stat < 0)\n\t\tgoto fail1;\n\tstat = ngene_start(dev);\n\tif (stat < 0)\n\t\tgoto fail1;\n\n\tcxd_attach(dev);\n\n\tstat = ngene_buffer_config(dev);\n\tif (stat < 0)\n\t\tgoto fail1;\n\n\n\tdev->i2c_current_bus = -1;\n\n\t \n\tstat = init_channels(dev);\n\tif (stat < 0)\n\t\tgoto fail2;\n\n\treturn 0;\n\nfail2:\n\tngene_stop(dev);\nfail1:\n\tngene_release_buffers(dev);\nfail0:\n\tpci_disable_device(pci_dev);\n\treturn stat;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}