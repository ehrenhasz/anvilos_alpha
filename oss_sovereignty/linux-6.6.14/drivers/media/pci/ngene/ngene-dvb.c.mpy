{
  "module_name": "ngene-dvb.c",
  "hash_id": "1ee424988f5baea871f13075d3f4ee088480c2daf43f7d5ce7bf6a8467a30ec0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ngene/ngene-dvb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/io.h>\n#include <asm/div64.h>\n#include <linux/pci.h>\n#include <linux/timer.h>\n#include <linux/byteorder/generic.h>\n#include <linux/firmware.h>\n#include <linux/vmalloc.h>\n\n#include \"ngene.h\"\n\nstatic int ci_tsfix = 1;\nmodule_param(ci_tsfix, int, 0444);\nMODULE_PARM_DESC(ci_tsfix, \"Detect and fix TS buffer offset shifts in conjunction with CI expansions (default: 1/enabled)\");\n\n \n \n \n\nstatic ssize_t ts_write(struct file *file, const char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct ngene_channel *chan = dvbdev->priv;\n\tstruct ngene *dev = chan->dev;\n\n\tif (wait_event_interruptible(dev->tsout_rbuf.queue,\n\t\t\t\t     dvb_ringbuffer_free\n\t\t\t\t     (&dev->tsout_rbuf) >= count) < 0)\n\t\treturn 0;\n\n\tdvb_ringbuffer_write_user(&dev->tsout_rbuf, buf, count);\n\n\treturn count;\n}\n\nstatic ssize_t ts_read(struct file *file, char __user *buf,\n\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct ngene_channel *chan = dvbdev->priv;\n\tstruct ngene *dev = chan->dev;\n\tint left, avail;\n\n\tleft = count;\n\twhile (left) {\n\t\tif (wait_event_interruptible(\n\t\t\t    dev->tsin_rbuf.queue,\n\t\t\t    dvb_ringbuffer_avail(&dev->tsin_rbuf) > 0) < 0)\n\t\t\treturn -EAGAIN;\n\t\tavail = dvb_ringbuffer_avail(&dev->tsin_rbuf);\n\t\tif (avail > left)\n\t\t\tavail = left;\n\t\tdvb_ringbuffer_read_user(&dev->tsin_rbuf, buf, avail);\n\t\tleft -= avail;\n\t\tbuf += avail;\n\t}\n\treturn count;\n}\n\nstatic __poll_t ts_poll(struct file *file, poll_table *wait)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct ngene_channel *chan = dvbdev->priv;\n\tstruct ngene *dev = chan->dev;\n\tstruct dvb_ringbuffer *rbuf = &dev->tsin_rbuf;\n\tstruct dvb_ringbuffer *wbuf = &dev->tsout_rbuf;\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &rbuf->queue, wait);\n\tpoll_wait(file, &wbuf->queue, wait);\n\n\tif (!dvb_ringbuffer_empty(rbuf))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (dvb_ringbuffer_free(wbuf) >= 188)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\n\treturn mask;\n}\n\nstatic const struct file_operations ci_fops = {\n\t.owner   = THIS_MODULE,\n\t.read    = ts_read,\n\t.write   = ts_write,\n\t.open    = dvb_generic_open,\n\t.release = dvb_generic_release,\n\t.poll    = ts_poll,\n\t.mmap    = NULL,\n};\n\nstruct dvb_device ngene_dvbdev_ci = {\n\t.priv    = NULL,\n\t.readers = 1,\n\t.writers = 1,\n\t.users   = 2,\n\t.fops    = &ci_fops,\n};\n\n\n \n \n \n\nstatic void swap_buffer(u32 *p, u32 len)\n{\n\twhile (len) {\n\t\t*p = swab32(*p);\n\t\tp++;\n\t\tlen -= 4;\n\t}\n}\n\n \nstatic u8 fill_ts[] = { 0x47, 0x1f, 0xff, 0x10, TS_FILLER };\n\nstatic int tsin_find_offset(void *buf, u32 len)\n{\n\tint i, l;\n\n\tl = len - sizeof(fill_ts);\n\tif (l <= 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < l; i++) {\n\t\tif (((char *)buf)[i] == 0x47) {\n\t\t\tif (!memcmp(buf + i, fill_ts, sizeof(fill_ts)))\n\t\t\t\treturn i % 188;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic inline void tsin_copy_stripped(struct ngene *dev, void *buf)\n{\n\tif (memcmp(buf, fill_ts, sizeof(fill_ts)) != 0) {\n\t\tif (dvb_ringbuffer_free(&dev->tsin_rbuf) >= 188) {\n\t\t\tdvb_ringbuffer_write(&dev->tsin_rbuf, buf, 188);\n\t\t\twake_up(&dev->tsin_rbuf.queue);\n\t\t}\n\t}\n}\n\nvoid *tsin_exchange(void *priv, void *buf, u32 len, u32 clock, u32 flags)\n{\n\tstruct ngene_channel *chan = priv;\n\tstruct ngene *dev = chan->dev;\n\tint tsoff;\n\n\tif (flags & DF_SWAP32)\n\t\tswap_buffer(buf, len);\n\n\tif (dev->ci.en && chan->number == 2) {\n\t\t \n\t\tif (!ci_tsfix) {\n\t\t\twhile (len >= 188) {\n\t\t\t\ttsin_copy_stripped(dev, buf);\n\n\t\t\t\tbuf += 188;\n\t\t\t\tlen -= 188;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (chan->tsin_offset) {\n\t\t\tmemcpy(&chan->tsin_buffer[(188 - chan->tsin_offset)],\n\t\t\t       buf, chan->tsin_offset);\n\t\t\ttsin_copy_stripped(dev, &chan->tsin_buffer);\n\n\t\t\tbuf += chan->tsin_offset;\n\t\t\tlen -= chan->tsin_offset;\n\t\t}\n\n\t\t \n\t\twhile (len >= 188) {\n\t\t\tif (*((char *)buf) != 0x47) {\n\t\t\t\t \n\t\t\t\ttsoff = tsin_find_offset(buf, len);\n\t\t\t\tif (tsoff > 0) {\n\t\t\t\t\tchan->tsin_offset += tsoff;\n\t\t\t\t\tchan->tsin_offset %= 188;\n\n\t\t\t\t\tbuf += tsoff;\n\t\t\t\t\tlen -= tsoff;\n\n\t\t\t\t\tdev_info(&dev->pci_dev->dev,\n\t\t\t\t\t\t \"%s(): tsin_offset shift by %d on channel %d\\n\",\n\t\t\t\t\t\t __func__, tsoff,\n\t\t\t\t\t\t chan->number);\n\n\t\t\t\t\t \n\t\t\t\t\tif (len < 188)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttsin_copy_stripped(dev, buf);\n\n\t\t\tbuf += 188;\n\t\t\tlen -= 188;\n\t\t}\n\n\t\t \n\t\tif (len > 0 && len < 188)\n\t\t\tmemcpy(&chan->tsin_buffer, buf, len);\n\n\t\treturn NULL;\n\t}\n\n\tif (chan->users > 0)\n\t\tdvb_dmx_swfilter(&chan->demux, buf, len);\n\n\treturn NULL;\n}\n\nvoid *tsout_exchange(void *priv, void *buf, u32 len, u32 clock, u32 flags)\n{\n\tstruct ngene_channel *chan = priv;\n\tstruct ngene *dev = chan->dev;\n\tu32 alen;\n\n\talen = dvb_ringbuffer_avail(&dev->tsout_rbuf);\n\talen -= alen % 188;\n\n\tif (alen < len)\n\t\tFillTSBuffer(buf + alen, len - alen, flags);\n\telse\n\t\talen = len;\n\tdvb_ringbuffer_read(&dev->tsout_rbuf, buf, alen);\n\tif (flags & DF_SWAP32)\n\t\tswap_buffer((u32 *)buf, alen);\n\twake_up_interruptible(&dev->tsout_rbuf.queue);\n\treturn buf;\n}\n\n\n\nint ngene_start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tstruct ngene_channel *chan = dvbdmx->priv;\n\n\tif (chan->users == 0) {\n\t\tif (!chan->dev->cmd_timeout_workaround || !chan->running)\n\t\t\tset_transfer(chan, 1);\n\t}\n\n\treturn ++chan->users;\n}\n\nint ngene_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tstruct ngene_channel *chan = dvbdmx->priv;\n\n\tif (--chan->users)\n\t\treturn chan->users;\n\n\tif (!chan->dev->cmd_timeout_workaround)\n\t\tset_transfer(chan, 0);\n\n\treturn 0;\n}\n\nint my_dvb_dmx_ts_card_init(struct dvb_demux *dvbdemux, char *id,\n\t\t\t    int (*start_feed)(struct dvb_demux_feed *),\n\t\t\t    int (*stop_feed)(struct dvb_demux_feed *),\n\t\t\t    void *priv)\n{\n\tdvbdemux->priv = priv;\n\n\tdvbdemux->filternum = 256;\n\tdvbdemux->feednum = 256;\n\tdvbdemux->start_feed = start_feed;\n\tdvbdemux->stop_feed = stop_feed;\n\tdvbdemux->write_to_decoder = NULL;\n\tdvbdemux->dmx.capabilities = (DMX_TS_FILTERING |\n\t\t\t\t      DMX_SECTION_FILTERING |\n\t\t\t\t      DMX_MEMORY_BASED_FILTERING);\n\treturn dvb_dmx_init(dvbdemux);\n}\n\nint my_dvb_dmxdev_ts_card_init(struct dmxdev *dmxdev,\n\t\t\t       struct dvb_demux *dvbdemux,\n\t\t\t       struct dmx_frontend *hw_frontend,\n\t\t\t       struct dmx_frontend *mem_frontend,\n\t\t\t       struct dvb_adapter *dvb_adapter)\n{\n\tint ret;\n\n\tdmxdev->filternum = 256;\n\tdmxdev->demux = &dvbdemux->dmx;\n\tdmxdev->capabilities = 0;\n\tret = dvb_dmxdev_init(dmxdev, dvb_adapter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thw_frontend->source = DMX_FRONTEND_0;\n\tdvbdemux->dmx.add_frontend(&dvbdemux->dmx, hw_frontend);\n\tmem_frontend->source = DMX_MEMORY_FE;\n\tdvbdemux->dmx.add_frontend(&dvbdemux->dmx, mem_frontend);\n\treturn dvbdemux->dmx.connect_frontend(&dvbdemux->dmx, hw_frontend);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}