{
  "module_name": "ngene-i2c.c",
  "hash_id": "f58d12e5ea8d78f94d102b0cf969e8d8833752eb1e71f7f019afab911567dc68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ngene/ngene-i2c.c",
  "human_readable_source": "\n \n\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/io.h>\n#include <asm/div64.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/timer.h>\n#include <linux/byteorder/generic.h>\n#include <linux/firmware.h>\n#include <linux/vmalloc.h>\n\n#include \"ngene.h\"\n\n \nstatic int ngene_command_i2c_read(struct ngene *dev, u8 adr,\n\t\t\t   u8 *out, u8 outlen, u8 *in, u8 inlen, int flag)\n{\n\tstruct ngene_command com;\n\n\tcom.cmd.hdr.Opcode = CMD_I2C_READ;\n\tcom.cmd.hdr.Length = outlen + 3;\n\tcom.cmd.I2CRead.Device = adr << 1;\n\tmemcpy(com.cmd.I2CRead.Data, out, outlen);\n\tcom.cmd.I2CRead.Data[outlen] = inlen;\n\tcom.cmd.I2CRead.Data[outlen + 1] = 0;\n\tcom.in_len = outlen + 3;\n\tcom.out_len = inlen + 1;\n\n\tif (ngene_command(dev, &com) < 0)\n\t\treturn -EIO;\n\n\tif ((com.cmd.raw8[0] >> 1) != adr)\n\t\treturn -EIO;\n\n\tif (flag)\n\t\tmemcpy(in, com.cmd.raw8, inlen + 1);\n\telse\n\t\tmemcpy(in, com.cmd.raw8 + 1, inlen);\n\treturn 0;\n}\n\nstatic int ngene_command_i2c_write(struct ngene *dev, u8 adr,\n\t\t\t\t   u8 *out, u8 outlen)\n{\n\tstruct ngene_command com;\n\n\n\tcom.cmd.hdr.Opcode = CMD_I2C_WRITE;\n\tcom.cmd.hdr.Length = outlen + 1;\n\tcom.cmd.I2CRead.Device = adr << 1;\n\tmemcpy(com.cmd.I2CRead.Data, out, outlen);\n\tcom.in_len = outlen + 1;\n\tcom.out_len = 1;\n\n\tif (ngene_command(dev, &com) < 0)\n\t\treturn -EIO;\n\n\tif (com.cmd.raw8[0] == 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void ngene_i2c_set_bus(struct ngene *dev, int bus)\n{\n\tif (!(dev->card_info->i2c_access & 2))\n\t\treturn;\n\tif (dev->i2c_current_bus == bus)\n\t\treturn;\n\n\tswitch (bus) {\n\tcase 0:\n\t\tngene_command_gpio_set(dev, 3, 0);\n\t\tngene_command_gpio_set(dev, 2, 1);\n\t\tbreak;\n\n\tcase 1:\n\t\tngene_command_gpio_set(dev, 2, 0);\n\t\tngene_command_gpio_set(dev, 3, 1);\n\t\tbreak;\n\t}\n\tdev->i2c_current_bus = bus;\n}\n\nstatic int ngene_i2c_master_xfer(struct i2c_adapter *adapter,\n\t\t\t\t struct i2c_msg msg[], int num)\n{\n\tstruct ngene_channel *chan =\n\t\t(struct ngene_channel *)i2c_get_adapdata(adapter);\n\tstruct ngene *dev = chan->dev;\n\n\tmutex_lock(&dev->i2c_switch_mutex);\n\tngene_i2c_set_bus(dev, chan->number);\n\n\tif (num == 2 && msg[1].flags & I2C_M_RD && !(msg[0].flags & I2C_M_RD))\n\t\tif (!ngene_command_i2c_read(dev, msg[0].addr,\n\t\t\t\t\t    msg[0].buf, msg[0].len,\n\t\t\t\t\t    msg[1].buf, msg[1].len, 0))\n\t\t\tgoto done;\n\n\tif (num == 1 && !(msg[0].flags & I2C_M_RD))\n\t\tif (!ngene_command_i2c_write(dev, msg[0].addr,\n\t\t\t\t\t     msg[0].buf, msg[0].len))\n\t\t\tgoto done;\n\tif (num == 1 && (msg[0].flags & I2C_M_RD))\n\t\tif (!ngene_command_i2c_read(dev, msg[0].addr, NULL, 0,\n\t\t\t\t\t    msg[0].buf, msg[0].len, 0))\n\t\t\tgoto done;\n\n\tmutex_unlock(&dev->i2c_switch_mutex);\n\treturn -EIO;\n\ndone:\n\tmutex_unlock(&dev->i2c_switch_mutex);\n\treturn num;\n}\n\n\nstatic u32 ngene_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm ngene_i2c_algo = {\n\t.master_xfer = ngene_i2c_master_xfer,\n\t.functionality = ngene_i2c_functionality,\n};\n\nint ngene_i2c_init(struct ngene *dev, int dev_nr)\n{\n\tstruct i2c_adapter *adap = &(dev->channel[dev_nr].i2c_adapter);\n\n\ti2c_set_adapdata(adap, &(dev->channel[dev_nr]));\n\n\tstrscpy(adap->name, \"nGene\", sizeof(adap->name));\n\n\tadap->algo = &ngene_i2c_algo;\n\tadap->algo_data = (void *)&(dev->channel[dev_nr]);\n\tadap->dev.parent = &dev->pci_dev->dev;\n\n\treturn i2c_add_adapter(adap);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}