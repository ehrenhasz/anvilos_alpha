{
  "module_name": "budget-av.c",
  "hash_id": "6c55576d9c1e3c8bc51ba552071070f08b74c5334e3a72931004e27d7799322a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ttpci/budget-av.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"budget.h\"\n#include \"stv0299.h\"\n#include \"stb0899_drv.h\"\n#include \"stb0899_reg.h\"\n#include \"stb0899_cfg.h\"\n#include \"tda8261.h\"\n#include \"tda8261_cfg.h\"\n#include \"tda1002x.h\"\n#include \"tda1004x.h\"\n#include \"tua6100.h\"\n#include \"dvb-pll.h\"\n#include <media/drv-intf/saa7146_vv.h>\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/spinlock.h>\n\n#include <media/dvb_ca_en50221.h>\n\n#define DEBICICAM\t\t0x02420000\n\n#define SLOTSTATUS_NONE         1\n#define SLOTSTATUS_PRESENT      2\n#define SLOTSTATUS_RESET        4\n#define SLOTSTATUS_READY        8\n#define SLOTSTATUS_OCCUPIED     (SLOTSTATUS_PRESENT|SLOTSTATUS_RESET|SLOTSTATUS_READY)\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstruct budget_av {\n\tstruct budget budget;\n\tstruct video_device vd;\n\tint cur_input;\n\tint has_saa7113;\n\tstruct tasklet_struct ciintf_irq_tasklet;\n\tint slot_status;\n\tstruct dvb_ca_en50221 ca;\n\tu8 reinitialise_demod:1;\n};\n\nstatic int ciintf_slot_shutdown(struct dvb_ca_en50221 *ca, int slot);\n\n\n \n\n \n\nstatic u8 i2c_readreg(struct i2c_adapter *i2c, u8 id, u8 reg)\n{\n\tu8 mm1[] = { 0x00 };\n\tu8 mm2[] = { 0x00 };\n\tstruct i2c_msg msgs[2];\n\n\tmsgs[0].flags = 0;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[0].addr = msgs[1].addr = id / 2;\n\tmm1[0] = reg;\n\tmsgs[0].len = 1;\n\tmsgs[1].len = 1;\n\tmsgs[0].buf = mm1;\n\tmsgs[1].buf = mm2;\n\n\ti2c_transfer(i2c, msgs, 2);\n\n\treturn mm2[0];\n}\n\nstatic int i2c_readregs(struct i2c_adapter *i2c, u8 id, u8 reg, u8 * buf, u8 len)\n{\n\tu8 mm1[] = { reg };\n\tstruct i2c_msg msgs[2] = {\n\t\t{.addr = id / 2,.flags = 0,.buf = mm1,.len = 1},\n\t\t{.addr = id / 2,.flags = I2C_M_RD,.buf = buf,.len = len}\n\t};\n\n\tif (i2c_transfer(i2c, msgs, 2) != 2)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int i2c_writereg(struct i2c_adapter *i2c, u8 id, u8 reg, u8 val)\n{\n\tu8 msg[2] = { reg, val };\n\tstruct i2c_msg msgs;\n\n\tmsgs.flags = 0;\n\tmsgs.addr = id / 2;\n\tmsgs.len = 2;\n\tmsgs.buf = msg;\n\treturn i2c_transfer(i2c, &msgs, 1);\n}\n\nstatic int ciintf_read_attribute_mem(struct dvb_ca_en50221 *ca, int slot, int address)\n{\n\tstruct budget_av *budget_av = ca->data;\n\tint result;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tsaa7146_setgpio(budget_av->budget.dev, 1, SAA7146_GPIO_OUTHI);\n\tudelay(1);\n\n\tresult = ttpci_budget_debiread(&budget_av->budget, DEBICICAM, address & 0xfff, 1, 0, 1);\n\tif (result == -ETIMEDOUT) {\n\t\tciintf_slot_shutdown(ca, slot);\n\t\tpr_info(\"cam ejected 1\\n\");\n\t}\n\treturn result;\n}\n\nstatic int ciintf_write_attribute_mem(struct dvb_ca_en50221 *ca, int slot, int address, u8 value)\n{\n\tstruct budget_av *budget_av = ca->data;\n\tint result;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tsaa7146_setgpio(budget_av->budget.dev, 1, SAA7146_GPIO_OUTHI);\n\tudelay(1);\n\n\tresult = ttpci_budget_debiwrite(&budget_av->budget, DEBICICAM, address & 0xfff, 1, value, 0, 1);\n\tif (result == -ETIMEDOUT) {\n\t\tciintf_slot_shutdown(ca, slot);\n\t\tpr_info(\"cam ejected 2\\n\");\n\t}\n\treturn result;\n}\n\nstatic int ciintf_read_cam_control(struct dvb_ca_en50221 *ca, int slot, u8 address)\n{\n\tstruct budget_av *budget_av = ca->data;\n\tint result;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tsaa7146_setgpio(budget_av->budget.dev, 1, SAA7146_GPIO_OUTLO);\n\tudelay(1);\n\n\tresult = ttpci_budget_debiread(&budget_av->budget, DEBICICAM, address & 3, 1, 0, 0);\n\tif (result == -ETIMEDOUT) {\n\t\tciintf_slot_shutdown(ca, slot);\n\t\tpr_info(\"cam ejected 3\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn result;\n}\n\nstatic int ciintf_write_cam_control(struct dvb_ca_en50221 *ca, int slot, u8 address, u8 value)\n{\n\tstruct budget_av *budget_av = ca->data;\n\tint result;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tsaa7146_setgpio(budget_av->budget.dev, 1, SAA7146_GPIO_OUTLO);\n\tudelay(1);\n\n\tresult = ttpci_budget_debiwrite(&budget_av->budget, DEBICICAM, address & 3, 1, value, 0, 0);\n\tif (result == -ETIMEDOUT) {\n\t\tciintf_slot_shutdown(ca, slot);\n\t\tpr_info(\"cam ejected 5\\n\");\n\t}\n\treturn result;\n}\n\nstatic int ciintf_slot_reset(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct budget_av *budget_av = ca->data;\n\tstruct saa7146_dev *saa = budget_av->budget.dev;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tdprintk(1, \"ciintf_slot_reset\\n\");\n\tbudget_av->slot_status = SLOTSTATUS_RESET;\n\n\tsaa7146_setgpio(saa, 2, SAA7146_GPIO_OUTHI);  \n\n\tsaa7146_setgpio(saa, 0, SAA7146_GPIO_OUTHI);  \n\tmsleep(2);\n\tsaa7146_setgpio(saa, 0, SAA7146_GPIO_OUTLO);  \n\tmsleep(20);  \n\n\tsaa7146_setgpio(saa, 2, SAA7146_GPIO_OUTLO);  \n\tttpci_budget_set_video_port(saa, BUDGET_VIDEO_PORTB);\n\tmsleep(20);\n\n\t \n\tif (budget_av->reinitialise_demod)\n\t\tdvb_frontend_reinitialise(budget_av->budget.dvb_frontend);\n\n\treturn 0;\n}\n\nstatic int ciintf_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct budget_av *budget_av = ca->data;\n\tstruct saa7146_dev *saa = budget_av->budget.dev;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tdprintk(1, \"ciintf_slot_shutdown\\n\");\n\n\tttpci_budget_set_video_port(saa, BUDGET_VIDEO_PORTB);\n\tbudget_av->slot_status = SLOTSTATUS_NONE;\n\n\treturn 0;\n}\n\nstatic int ciintf_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct budget_av *budget_av = ca->data;\n\tstruct saa7146_dev *saa = budget_av->budget.dev;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tdprintk(1, \"ciintf_slot_ts_enable: %d\\n\", budget_av->slot_status);\n\n\tttpci_budget_set_video_port(saa, BUDGET_VIDEO_PORTA);\n\n\treturn 0;\n}\n\nstatic int ciintf_poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\n{\n\tstruct budget_av *budget_av = ca->data;\n\tstruct saa7146_dev *saa = budget_av->budget.dev;\n\tint result;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (budget_av->slot_status == SLOTSTATUS_NONE) {\n\t\tsaa7146_setgpio(saa, 3, SAA7146_GPIO_INPUT);\n\t\tudelay(1);\n\t\tif (saa7146_read(saa, PSR) & MASK_06) {\n\t\t\tif (budget_av->slot_status == SLOTSTATUS_NONE) {\n\t\t\t\tbudget_av->slot_status = SLOTSTATUS_PRESENT;\n\t\t\t\tpr_info(\"cam inserted A\\n\");\n\t\t\t}\n\t\t}\n\t\tsaa7146_setgpio(saa, 3, SAA7146_GPIO_OUTLO);\n\t}\n\n\t \n\tif ((budget_av->slot_status == SLOTSTATUS_NONE) || (!open)) {\n\t\tsaa7146_setgpio(budget_av->budget.dev, 1, SAA7146_GPIO_OUTLO);\n\t\tresult = ttpci_budget_debiread(&budget_av->budget, DEBICICAM, 0, 1, 0, 1);\n\t\tif ((result >= 0) && (budget_av->slot_status == SLOTSTATUS_NONE)) {\n\t\t\tbudget_av->slot_status = SLOTSTATUS_PRESENT;\n\t\t\tpr_info(\"cam inserted B\\n\");\n\t\t} else if (result < 0) {\n\t\t\tif (budget_av->slot_status != SLOTSTATUS_NONE) {\n\t\t\t\tciintf_slot_shutdown(ca, slot);\n\t\t\t\tpr_info(\"cam ejected 5\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (budget_av->slot_status == SLOTSTATUS_RESET) {\n\t\tresult = ciintf_read_attribute_mem(ca, slot, 0);\n\t\tif (result == 0x1d) {\n\t\t\tbudget_av->slot_status = SLOTSTATUS_READY;\n\t\t}\n\t}\n\n\t \n\tif (budget_av->slot_status != SLOTSTATUS_NONE) {\n\t\tif (budget_av->slot_status & SLOTSTATUS_READY) {\n\t\t\treturn DVB_CA_EN50221_POLL_CAM_PRESENT | DVB_CA_EN50221_POLL_CAM_READY;\n\t\t}\n\t\treturn DVB_CA_EN50221_POLL_CAM_PRESENT;\n\t}\n\treturn 0;\n}\n\nstatic int ciintf_init(struct budget_av *budget_av)\n{\n\tstruct saa7146_dev *saa = budget_av->budget.dev;\n\tint result;\n\n\tmemset(&budget_av->ca, 0, sizeof(struct dvb_ca_en50221));\n\n\tsaa7146_setgpio(saa, 0, SAA7146_GPIO_OUTLO);\n\tsaa7146_setgpio(saa, 1, SAA7146_GPIO_OUTLO);\n\tsaa7146_setgpio(saa, 2, SAA7146_GPIO_OUTLO);\n\tsaa7146_setgpio(saa, 3, SAA7146_GPIO_OUTLO);\n\n\t \n\tsaa7146_write(saa, MC1, MASK_27 | MASK_11);\n\n\t \n\tbudget_av->ca.owner = THIS_MODULE;\n\tbudget_av->ca.read_attribute_mem = ciintf_read_attribute_mem;\n\tbudget_av->ca.write_attribute_mem = ciintf_write_attribute_mem;\n\tbudget_av->ca.read_cam_control = ciintf_read_cam_control;\n\tbudget_av->ca.write_cam_control = ciintf_write_cam_control;\n\tbudget_av->ca.slot_reset = ciintf_slot_reset;\n\tbudget_av->ca.slot_shutdown = ciintf_slot_shutdown;\n\tbudget_av->ca.slot_ts_enable = ciintf_slot_ts_enable;\n\tbudget_av->ca.poll_slot_status = ciintf_poll_slot_status;\n\tbudget_av->ca.data = budget_av;\n\tbudget_av->budget.ci_present = 1;\n\tbudget_av->slot_status = SLOTSTATUS_NONE;\n\n\tif ((result = dvb_ca_en50221_init(&budget_av->budget.dvb_adapter,\n\t\t\t\t\t  &budget_av->ca, 0, 1)) != 0) {\n\t\tpr_err(\"ci initialisation failed\\n\");\n\t\tgoto error;\n\t}\n\n\tpr_info(\"ci interface initialised\\n\");\n\treturn 0;\n\nerror:\n\tsaa7146_write(saa, MC1, MASK_27);\n\treturn result;\n}\n\nstatic void ciintf_deinit(struct budget_av *budget_av)\n{\n\tstruct saa7146_dev *saa = budget_av->budget.dev;\n\n\tsaa7146_setgpio(saa, 0, SAA7146_GPIO_INPUT);\n\tsaa7146_setgpio(saa, 1, SAA7146_GPIO_INPUT);\n\tsaa7146_setgpio(saa, 2, SAA7146_GPIO_INPUT);\n\tsaa7146_setgpio(saa, 3, SAA7146_GPIO_INPUT);\n\n\t \n\tdvb_ca_en50221_release(&budget_av->ca);\n\n\t \n\tsaa7146_write(saa, MC1, MASK_27);\n}\n\n\nstatic const u8 saa7113_tab[] = {\n\t0x01, 0x08,\n\t0x02, 0xc0,\n\t0x03, 0x33,\n\t0x04, 0x00,\n\t0x05, 0x00,\n\t0x06, 0xeb,\n\t0x07, 0xe0,\n\t0x08, 0x28,\n\t0x09, 0x00,\n\t0x0a, 0x80,\n\t0x0b, 0x47,\n\t0x0c, 0x40,\n\t0x0d, 0x00,\n\t0x0e, 0x01,\n\t0x0f, 0x44,\n\n\t0x10, 0x08,\n\t0x11, 0x0c,\n\t0x12, 0x7b,\n\t0x13, 0x00,\n\t0x15, 0x00, 0x16, 0x00, 0x17, 0x00,\n\n\t0x57, 0xff,\n\t0x40, 0x82, 0x58, 0x00, 0x59, 0x54, 0x5a, 0x07,\n\t0x5b, 0x83, 0x5e, 0x00,\n\t0xff\n};\n\nstatic int saa7113_init(struct budget_av *budget_av)\n{\n\tstruct budget *budget = &budget_av->budget;\n\tstruct saa7146_dev *saa = budget->dev;\n\tconst u8 *data = saa7113_tab;\n\n\tsaa7146_setgpio(saa, 0, SAA7146_GPIO_OUTHI);\n\tmsleep(200);\n\n\tif (i2c_writereg(&budget->i2c_adap, 0x4a, 0x01, 0x08) != 1) {\n\t\tdprintk(1, \"saa7113 not found on KNC card\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdprintk(1, \"saa7113 detected and initializing\\n\");\n\n\twhile (*data != 0xff) {\n\t\ti2c_writereg(&budget->i2c_adap, 0x4a, *data, *(data + 1));\n\t\tdata += 2;\n\t}\n\n\tdprintk(1, \"saa7113  status=%02x\\n\", i2c_readreg(&budget->i2c_adap, 0x4a, 0x1f));\n\n\treturn 0;\n}\n\nstatic int saa7113_setinput(struct budget_av *budget_av, int input)\n{\n\tstruct budget *budget = &budget_av->budget;\n\n\tif (1 != budget_av->has_saa7113)\n\t\treturn -ENODEV;\n\n\tif (input == 1) {\n\t\ti2c_writereg(&budget->i2c_adap, 0x4a, 0x02, 0xc7);\n\t\ti2c_writereg(&budget->i2c_adap, 0x4a, 0x09, 0x80);\n\t} else if (input == 0) {\n\t\ti2c_writereg(&budget->i2c_adap, 0x4a, 0x02, 0xc0);\n\t\ti2c_writereg(&budget->i2c_adap, 0x4a, 0x09, 0x00);\n\t} else\n\t\treturn -EINVAL;\n\n\tbudget_av->cur_input = input;\n\treturn 0;\n}\n\n\nstatic int philips_su1278_ty_ci_set_symbol_rate(struct dvb_frontend *fe, u32 srate, u32 ratio)\n{\n\tu8 aclk = 0;\n\tu8 bclk = 0;\n\tu8 m1;\n\n\taclk = 0xb5;\n\tif (srate < 2000000)\n\t\tbclk = 0x86;\n\telse if (srate < 5000000)\n\t\tbclk = 0x89;\n\telse if (srate < 15000000)\n\t\tbclk = 0x8f;\n\telse if (srate < 45000000)\n\t\tbclk = 0x95;\n\n\tm1 = 0x14;\n\tif (srate < 4000000)\n\t\tm1 = 0x10;\n\n\tstv0299_writereg(fe, 0x13, aclk);\n\tstv0299_writereg(fe, 0x14, bclk);\n\tstv0299_writereg(fe, 0x1f, (ratio >> 16) & 0xff);\n\tstv0299_writereg(fe, 0x20, (ratio >> 8) & 0xff);\n\tstv0299_writereg(fe, 0x21, (ratio) & 0xf0);\n\tstv0299_writereg(fe, 0x0f, 0x80 | m1);\n\n\treturn 0;\n}\n\nstatic int philips_su1278_ty_ci_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tu32 div;\n\tu8 buf[4];\n\tstruct budget *budget = fe->dvb->priv;\n\tstruct i2c_msg msg = {.addr = 0x61,.flags = 0,.buf = buf,.len = sizeof(buf) };\n\n\tif ((c->frequency < 950000) || (c->frequency > 2150000))\n\t\treturn -EINVAL;\n\n\tdiv = (c->frequency + (125 - 1)) / 125;\t \n\tbuf[0] = (div >> 8) & 0x7f;\n\tbuf[1] = div & 0xff;\n\tbuf[2] = 0x80 | ((div & 0x18000) >> 10) | 4;\n\tbuf[3] = 0x20;\n\n\tif (c->symbol_rate < 4000000)\n\t\tbuf[3] |= 1;\n\n\tif (c->frequency < 1250000)\n\t\tbuf[3] |= 0;\n\telse if (c->frequency < 1550000)\n\t\tbuf[3] |= 0x40;\n\telse if (c->frequency < 2050000)\n\t\tbuf[3] |= 0x80;\n\telse if (c->frequency < 2150000)\n\t\tbuf[3] |= 0xC0;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&budget->i2c_adap, &msg, 1) != 1)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic u8 typhoon_cinergy1200s_inittab[] = {\n\t0x01, 0x15,\n\t0x02, 0x30,\n\t0x03, 0x00,\n\t0x04, 0x7d,\t\t \n\t0x05, 0x35,\t\t \n\t0x06, 0x40,\t\t \n\t0x07, 0x00,\t\t \n\t0x08, 0x40,\t\t \n\t0x09, 0x00,\t\t \n\t0x0c, 0x51,\t\t \n\t0x0d, 0x82,\t\t \n\t0x0e, 0x23,\t\t \n\t0x10, 0x3f,\t\t\n\t0x11, 0x84,\n\t0x12, 0xb9,\n\t0x15, 0xc9,\t\t\n\t0x16, 0x00,\n\t0x17, 0x00,\n\t0x18, 0x00,\n\t0x19, 0x00,\n\t0x1a, 0x00,\n\t0x1f, 0x50,\n\t0x20, 0x00,\n\t0x21, 0x00,\n\t0x22, 0x00,\n\t0x23, 0x00,\n\t0x28, 0x00,\t\t\n\t0x29, 0x1e,\t\t\n\t0x2a, 0x14,\t\t\n\t0x2b, 0x0f,\t\t\n\t0x2c, 0x09,\t\t\n\t0x2d, 0x05,\t\t\n\t0x2e, 0x01,\n\t0x31, 0x1f,\t\t\n\t0x32, 0x19,\t\t\n\t0x33, 0xfc,\t\t\n\t0x34, 0x93,\t\t\n\t0x0f, 0x92,\n\t0xff, 0xff\n};\n\nstatic const struct stv0299_config typhoon_config = {\n\t.demod_address = 0x68,\n\t.inittab = typhoon_cinergy1200s_inittab,\n\t.mclk = 88000000UL,\n\t.invert = 0,\n\t.skip_reinit = 0,\n\t.lock_output = STV0299_LOCKOUTPUT_1,\n\t.volt13_op0_op1 = STV0299_VOLT13_OP0,\n\t.min_delay_ms = 100,\n\t.set_symbol_rate = philips_su1278_ty_ci_set_symbol_rate,\n};\n\n\nstatic const struct stv0299_config cinergy_1200s_config = {\n\t.demod_address = 0x68,\n\t.inittab = typhoon_cinergy1200s_inittab,\n\t.mclk = 88000000UL,\n\t.invert = 0,\n\t.skip_reinit = 0,\n\t.lock_output = STV0299_LOCKOUTPUT_0,\n\t.volt13_op0_op1 = STV0299_VOLT13_OP0,\n\t.min_delay_ms = 100,\n\t.set_symbol_rate = philips_su1278_ty_ci_set_symbol_rate,\n};\n\nstatic const struct stv0299_config cinergy_1200s_1894_0010_config = {\n\t.demod_address = 0x68,\n\t.inittab = typhoon_cinergy1200s_inittab,\n\t.mclk = 88000000UL,\n\t.invert = 1,\n\t.skip_reinit = 0,\n\t.lock_output = STV0299_LOCKOUTPUT_1,\n\t.volt13_op0_op1 = STV0299_VOLT13_OP0,\n\t.min_delay_ms = 100,\n\t.set_symbol_rate = philips_su1278_ty_ci_set_symbol_rate,\n};\n\nstatic int philips_cu1216_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct budget *budget = fe->dvb->priv;\n\tu8 buf[6];\n\tstruct i2c_msg msg = {.addr = 0x60,.flags = 0,.buf = buf,.len = sizeof(buf) };\n\tint i;\n\n#define CU1216_IF 36125000\n#define TUNER_MUL 62500\n\n\tu32 div = (c->frequency + CU1216_IF + TUNER_MUL / 2) / TUNER_MUL;\n\n\tbuf[0] = (div >> 8) & 0x7f;\n\tbuf[1] = div & 0xff;\n\tbuf[2] = 0xce;\n\tbuf[3] = (c->frequency < 150000000 ? 0x01 :\n\t\t  c->frequency < 445000000 ? 0x02 : 0x04);\n\tbuf[4] = 0xde;\n\tbuf[5] = 0x20;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&budget->i2c_adap, &msg, 1) != 1)\n\t\treturn -EIO;\n\n\t \n\tmsg.flags = I2C_M_RD;\n\tmsg.len = 1;\n\tfor (i = 0; i < 20; i++) {\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\tif (i2c_transfer(&budget->i2c_adap, &msg, 1) == 1 && (buf[0] & 0x40))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\n\t \n\tmsg.flags = 0;\n\tmsg.len = 2;\n\tmsg.buf = &buf[2];\n\tbuf[2] &= ~0x40;\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&budget->i2c_adap, &msg, 1) != 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic struct tda1002x_config philips_cu1216_config = {\n\t.demod_address = 0x0c,\n\t.invert = 1,\n};\n\nstatic struct tda1002x_config philips_cu1216_config_altaddress = {\n\t.demod_address = 0x0d,\n\t.invert = 0,\n};\n\nstatic struct tda10023_config philips_cu1216_tda10023_config = {\n\t.demod_address = 0x0c,\n\t.invert = 1,\n};\n\nstatic int philips_tu1216_tuner_init(struct dvb_frontend *fe)\n{\n\tstruct budget *budget = fe->dvb->priv;\n\tstatic u8 tu1216_init[] = { 0x0b, 0xf5, 0x85, 0xab };\n\tstruct i2c_msg tuner_msg = {.addr = 0x60,.flags = 0,.buf = tu1216_init,.len = sizeof(tu1216_init) };\n\n\t\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&budget->i2c_adap, &tuner_msg, 1) != 1)\n\t\treturn -EIO;\n\tmsleep(1);\n\n\treturn 0;\n}\n\nstatic int philips_tu1216_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct budget *budget = fe->dvb->priv;\n\tu8 tuner_buf[4];\n\tstruct i2c_msg tuner_msg = {.addr = 0x60,.flags = 0,.buf = tuner_buf,.len =\n\t\t\tsizeof(tuner_buf) };\n\tint tuner_frequency = 0;\n\tu8 band, cp, filter;\n\n\t\n\ttuner_frequency = c->frequency + 36166000;\n\tif (tuner_frequency < 87000000)\n\t\treturn -EINVAL;\n\telse if (tuner_frequency < 130000000)\n\t\tcp = 3;\n\telse if (tuner_frequency < 160000000)\n\t\tcp = 5;\n\telse if (tuner_frequency < 200000000)\n\t\tcp = 6;\n\telse if (tuner_frequency < 290000000)\n\t\tcp = 3;\n\telse if (tuner_frequency < 420000000)\n\t\tcp = 5;\n\telse if (tuner_frequency < 480000000)\n\t\tcp = 6;\n\telse if (tuner_frequency < 620000000)\n\t\tcp = 3;\n\telse if (tuner_frequency < 830000000)\n\t\tcp = 5;\n\telse if (tuner_frequency < 895000000)\n\t\tcp = 7;\n\telse\n\t\treturn -EINVAL;\n\n\t\n\tif (c->frequency < 49000000)\n\t\treturn -EINVAL;\n\telse if (c->frequency < 161000000)\n\t\tband = 1;\n\telse if (c->frequency < 444000000)\n\t\tband = 2;\n\telse if (c->frequency < 861000000)\n\t\tband = 4;\n\telse\n\t\treturn -EINVAL;\n\n\t\n\tswitch (c->bandwidth_hz) {\n\tcase 6000000:\n\t\tfilter = 0;\n\t\tbreak;\n\n\tcase 7000000:\n\t\tfilter = 0;\n\t\tbreak;\n\n\tcase 8000000:\n\t\tfilter = 1;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t\n\t\n\ttuner_frequency = (((c->frequency / 1000) * 6) + 217496) / 1000;\n\n\t\n\ttuner_buf[0] = (tuner_frequency >> 8) & 0x7f;\n\ttuner_buf[1] = tuner_frequency & 0xff;\n\ttuner_buf[2] = 0xca;\n\ttuner_buf[3] = (cp << 5) | (filter << 3) | band;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&budget->i2c_adap, &tuner_msg, 1) != 1)\n\t\treturn -EIO;\n\n\tmsleep(1);\n\treturn 0;\n}\n\nstatic int philips_tu1216_request_firmware(struct dvb_frontend *fe,\n\t\t\t\t\t   const struct firmware **fw, char *name)\n{\n\tstruct budget *budget = fe->dvb->priv;\n\n\treturn request_firmware(fw, name, &budget->dev->pci->dev);\n}\n\nstatic struct tda1004x_config philips_tu1216_config = {\n\n\t.demod_address = 0x8,\n\t.invert = 1,\n\t.invert_oclk = 1,\n\t.xtal_freq = TDA10046_XTAL_4M,\n\t.agc_config = TDA10046_AGC_DEFAULT,\n\t.if_freq = TDA10046_FREQ_3617,\n\t.request_firmware = philips_tu1216_request_firmware,\n};\n\nstatic u8 philips_sd1878_inittab[] = {\n\t0x01, 0x15,\n\t0x02, 0x30,\n\t0x03, 0x00,\n\t0x04, 0x7d,\n\t0x05, 0x35,\n\t0x06, 0x40,\n\t0x07, 0x00,\n\t0x08, 0x43,\n\t0x09, 0x02,\n\t0x0C, 0x51,\n\t0x0D, 0x82,\n\t0x0E, 0x23,\n\t0x10, 0x3f,\n\t0x11, 0x84,\n\t0x12, 0xb9,\n\t0x15, 0xc9,\n\t0x16, 0x19,\n\t0x17, 0x8c,\n\t0x18, 0x59,\n\t0x19, 0xf8,\n\t0x1a, 0xfe,\n\t0x1c, 0x7f,\n\t0x1d, 0x00,\n\t0x1e, 0x00,\n\t0x1f, 0x50,\n\t0x20, 0x00,\n\t0x21, 0x00,\n\t0x22, 0x00,\n\t0x23, 0x00,\n\t0x28, 0x00,\n\t0x29, 0x28,\n\t0x2a, 0x14,\n\t0x2b, 0x0f,\n\t0x2c, 0x09,\n\t0x2d, 0x09,\n\t0x31, 0x1f,\n\t0x32, 0x19,\n\t0x33, 0xfc,\n\t0x34, 0x93,\n\t0xff, 0xff\n};\n\nstatic int philips_sd1878_ci_set_symbol_rate(struct dvb_frontend *fe,\n\t\tu32 srate, u32 ratio)\n{\n\tu8 aclk = 0;\n\tu8 bclk = 0;\n\tu8 m1;\n\n\taclk = 0xb5;\n\tif (srate < 2000000)\n\t\tbclk = 0x86;\n\telse if (srate < 5000000)\n\t\tbclk = 0x89;\n\telse if (srate < 15000000)\n\t\tbclk = 0x8f;\n\telse if (srate < 45000000)\n\t\tbclk = 0x95;\n\n\tm1 = 0x14;\n\tif (srate < 4000000)\n\t\tm1 = 0x10;\n\n\tstv0299_writereg(fe, 0x0e, 0x23);\n\tstv0299_writereg(fe, 0x0f, 0x94);\n\tstv0299_writereg(fe, 0x10, 0x39);\n\tstv0299_writereg(fe, 0x13, aclk);\n\tstv0299_writereg(fe, 0x14, bclk);\n\tstv0299_writereg(fe, 0x15, 0xc9);\n\tstv0299_writereg(fe, 0x1f, (ratio >> 16) & 0xff);\n\tstv0299_writereg(fe, 0x20, (ratio >> 8) & 0xff);\n\tstv0299_writereg(fe, 0x21, (ratio) & 0xf0);\n\tstv0299_writereg(fe, 0x0f, 0x80 | m1);\n\n\treturn 0;\n}\n\nstatic const struct stv0299_config philips_sd1878_config = {\n\t.demod_address = 0x68,\n     .inittab = philips_sd1878_inittab,\n\t.mclk = 88000000UL,\n\t.invert = 0,\n\t.skip_reinit = 0,\n\t.lock_output = STV0299_LOCKOUTPUT_1,\n\t.volt13_op0_op1 = STV0299_VOLT13_OP0,\n\t.min_delay_ms = 100,\n\t.set_symbol_rate = philips_sd1878_ci_set_symbol_rate,\n};\n\n \nstatic const struct stb0899_s1_reg knc1_stb0899_s1_init_1[] = {\n\n\t{ STB0899_DEV_ID\t\t, 0x81 },\n\t{ STB0899_DISCNTRL1\t\t, 0x32 },\n\t{ STB0899_DISCNTRL2\t\t, 0x80 },\n\t{ STB0899_DISRX_ST0\t\t, 0x04 },\n\t{ STB0899_DISRX_ST1\t\t, 0x00 },\n\t{ STB0899_DISPARITY\t\t, 0x00 },\n\t{ STB0899_DISSTATUS\t\t, 0x20 },\n\t{ STB0899_DISF22\t\t, 0x8c },\n\t{ STB0899_DISF22RX\t\t, 0x9a },\n\t{ STB0899_SYSREG\t\t, 0x0b },\n\t{ STB0899_ACRPRESC\t\t, 0x11 },\n\t{ STB0899_ACRDIV1\t\t, 0x0a },\n\t{ STB0899_ACRDIV2\t\t, 0x05 },\n\t{ STB0899_DACR1\t\t\t, 0x00 },\n\t{ STB0899_DACR2\t\t\t, 0x00 },\n\t{ STB0899_OUTCFG\t\t, 0x00 },\n\t{ STB0899_MODECFG\t\t, 0x00 },\n\t{ STB0899_IRQSTATUS_3\t\t, 0x30 },\n\t{ STB0899_IRQSTATUS_2\t\t, 0x00 },\n\t{ STB0899_IRQSTATUS_1\t\t, 0x00 },\n\t{ STB0899_IRQSTATUS_0\t\t, 0x00 },\n\t{ STB0899_IRQMSK_3\t\t, 0xf3 },\n\t{ STB0899_IRQMSK_2\t\t, 0xfc },\n\t{ STB0899_IRQMSK_1\t\t, 0xff },\n\t{ STB0899_IRQMSK_0\t\t, 0xff },\n\t{ STB0899_IRQCFG\t\t, 0x00 },\n\t{ STB0899_I2CCFG\t\t, 0x88 },\n\t{ STB0899_I2CRPT\t\t, 0x58 },  \n\t{ STB0899_IOPVALUE5\t\t, 0x00 },\n\t{ STB0899_IOPVALUE4\t\t, 0x20 },\n\t{ STB0899_IOPVALUE3\t\t, 0xc9 },\n\t{ STB0899_IOPVALUE2\t\t, 0x90 },\n\t{ STB0899_IOPVALUE1\t\t, 0x40 },\n\t{ STB0899_IOPVALUE0\t\t, 0x00 },\n\t{ STB0899_GPIO00CFG\t\t, 0x82 },\n\t{ STB0899_GPIO01CFG\t\t, 0x82 },\n\t{ STB0899_GPIO02CFG\t\t, 0x82 },\n\t{ STB0899_GPIO03CFG\t\t, 0x82 },\n\t{ STB0899_GPIO04CFG\t\t, 0x82 },\n\t{ STB0899_GPIO05CFG\t\t, 0x82 },\n\t{ STB0899_GPIO06CFG\t\t, 0x82 },\n\t{ STB0899_GPIO07CFG\t\t, 0x82 },\n\t{ STB0899_GPIO08CFG\t\t, 0x82 },\n\t{ STB0899_GPIO09CFG\t\t, 0x82 },\n\t{ STB0899_GPIO10CFG\t\t, 0x82 },\n\t{ STB0899_GPIO11CFG\t\t, 0x82 },\n\t{ STB0899_GPIO12CFG\t\t, 0x82 },\n\t{ STB0899_GPIO13CFG\t\t, 0x82 },\n\t{ STB0899_GPIO14CFG\t\t, 0x82 },\n\t{ STB0899_GPIO15CFG\t\t, 0x82 },\n\t{ STB0899_GPIO16CFG\t\t, 0x82 },\n\t{ STB0899_GPIO17CFG\t\t, 0x82 },\n\t{ STB0899_GPIO18CFG\t\t, 0x82 },\n\t{ STB0899_GPIO19CFG\t\t, 0x82 },\n\t{ STB0899_GPIO20CFG\t\t, 0x82 },\n\t{ STB0899_SDATCFG\t\t, 0xb8 },\n\t{ STB0899_SCLTCFG\t\t, 0xba },\n\t{ STB0899_AGCRFCFG\t\t, 0x08 },  \n\t{ STB0899_GPIO22\t\t, 0x82 },  \n\t{ STB0899_GPIO21\t\t, 0x91 },  \n\t{ STB0899_DIRCLKCFG\t\t, 0x82 },\n\t{ STB0899_CLKOUT27CFG\t\t, 0x7e },\n\t{ STB0899_STDBYCFG\t\t, 0x82 },\n\t{ STB0899_CS0CFG\t\t, 0x82 },\n\t{ STB0899_CS1CFG\t\t, 0x82 },\n\t{ STB0899_DISEQCOCFG\t\t, 0x20 },\n\t{ STB0899_GPIO32CFG\t\t, 0x82 },\n\t{ STB0899_GPIO33CFG\t\t, 0x82 },\n\t{ STB0899_GPIO34CFG\t\t, 0x82 },\n\t{ STB0899_GPIO35CFG\t\t, 0x82 },\n\t{ STB0899_GPIO36CFG\t\t, 0x82 },\n\t{ STB0899_GPIO37CFG\t\t, 0x82 },\n\t{ STB0899_GPIO38CFG\t\t, 0x82 },\n\t{ STB0899_GPIO39CFG\t\t, 0x82 },\n\t{ STB0899_NCOARSE\t\t, 0x15 },  \n\t{ STB0899_SYNTCTRL\t\t, 0x02 },  \n\t{ STB0899_FILTCTRL\t\t, 0x00 },\n\t{ STB0899_SYSCTRL\t\t, 0x00 },\n\t{ STB0899_STOPCLK1\t\t, 0x20 },\n\t{ STB0899_STOPCLK2\t\t, 0x00 },\n\t{ STB0899_INTBUFSTATUS\t\t, 0x00 },\n\t{ STB0899_INTBUFCTRL\t\t, 0x0a },\n\t{ 0xffff\t\t\t, 0xff },\n};\n\nstatic const struct stb0899_s1_reg knc1_stb0899_s1_init_3[] = {\n\t{ STB0899_DEMOD\t\t\t, 0x00 },\n\t{ STB0899_RCOMPC\t\t, 0xc9 },\n\t{ STB0899_AGC1CN\t\t, 0x41 },\n\t{ STB0899_AGC1REF\t\t, 0x08 },\n\t{ STB0899_RTC\t\t\t, 0x7a },\n\t{ STB0899_TMGCFG\t\t, 0x4e },\n\t{ STB0899_AGC2REF\t\t, 0x33 },\n\t{ STB0899_TLSR\t\t\t, 0x84 },\n\t{ STB0899_CFD\t\t\t, 0xee },\n\t{ STB0899_ACLC\t\t\t, 0x87 },\n\t{ STB0899_BCLC\t\t\t, 0x94 },\n\t{ STB0899_EQON\t\t\t, 0x41 },\n\t{ STB0899_LDT\t\t\t, 0xdd },\n\t{ STB0899_LDT2\t\t\t, 0xc9 },\n\t{ STB0899_EQUALREF\t\t, 0xb4 },\n\t{ STB0899_TMGRAMP\t\t, 0x10 },\n\t{ STB0899_TMGTHD\t\t, 0x30 },\n\t{ STB0899_IDCCOMP\t\t, 0xfb },\n\t{ STB0899_QDCCOMP\t\t, 0x03 },\n\t{ STB0899_POWERI\t\t, 0x3b },\n\t{ STB0899_POWERQ\t\t, 0x3d },\n\t{ STB0899_RCOMP\t\t\t, 0x81 },\n\t{ STB0899_AGCIQIN\t\t, 0x80 },\n\t{ STB0899_AGC2I1\t\t, 0x04 },\n\t{ STB0899_AGC2I2\t\t, 0xf5 },\n\t{ STB0899_TLIR\t\t\t, 0x25 },\n\t{ STB0899_RTF\t\t\t, 0x80 },\n\t{ STB0899_DSTATUS\t\t, 0x00 },\n\t{ STB0899_LDI\t\t\t, 0xca },\n\t{ STB0899_CFRM\t\t\t, 0xf1 },\n\t{ STB0899_CFRL\t\t\t, 0xf3 },\n\t{ STB0899_NIRM\t\t\t, 0x2a },\n\t{ STB0899_NIRL\t\t\t, 0x05 },\n\t{ STB0899_ISYMB\t\t\t, 0x17 },\n\t{ STB0899_QSYMB\t\t\t, 0xfa },\n\t{ STB0899_SFRH\t\t\t, 0x2f },\n\t{ STB0899_SFRM\t\t\t, 0x68 },\n\t{ STB0899_SFRL\t\t\t, 0x40 },\n\t{ STB0899_SFRUPH\t\t, 0x2f },\n\t{ STB0899_SFRUPM\t\t, 0x68 },\n\t{ STB0899_SFRUPL\t\t, 0x40 },\n\t{ STB0899_EQUAI1\t\t, 0xfd },\n\t{ STB0899_EQUAQ1\t\t, 0x04 },\n\t{ STB0899_EQUAI2\t\t, 0x0f },\n\t{ STB0899_EQUAQ2\t\t, 0xff },\n\t{ STB0899_EQUAI3\t\t, 0xdf },\n\t{ STB0899_EQUAQ3\t\t, 0xfa },\n\t{ STB0899_EQUAI4\t\t, 0x37 },\n\t{ STB0899_EQUAQ4\t\t, 0x0d },\n\t{ STB0899_EQUAI5\t\t, 0xbd },\n\t{ STB0899_EQUAQ5\t\t, 0xf7 },\n\t{ STB0899_DSTATUS2\t\t, 0x00 },\n\t{ STB0899_VSTATUS\t\t, 0x00 },\n\t{ STB0899_VERROR\t\t, 0xff },\n\t{ STB0899_IQSWAP\t\t, 0x2a },\n\t{ STB0899_ECNT1M\t\t, 0x00 },\n\t{ STB0899_ECNT1L\t\t, 0x00 },\n\t{ STB0899_ECNT2M\t\t, 0x00 },\n\t{ STB0899_ECNT2L\t\t, 0x00 },\n\t{ STB0899_ECNT3M\t\t, 0x00 },\n\t{ STB0899_ECNT3L\t\t, 0x00 },\n\t{ STB0899_FECAUTO1\t\t, 0x06 },\n\t{ STB0899_FECM\t\t\t, 0x01 },\n\t{ STB0899_VTH12\t\t\t, 0xf0 },\n\t{ STB0899_VTH23\t\t\t, 0xa0 },\n\t{ STB0899_VTH34\t\t\t, 0x78 },\n\t{ STB0899_VTH56\t\t\t, 0x4e },\n\t{ STB0899_VTH67\t\t\t, 0x48 },\n\t{ STB0899_VTH78\t\t\t, 0x38 },\n\t{ STB0899_PRVIT\t\t\t, 0xff },\n\t{ STB0899_VITSYNC\t\t, 0x19 },\n\t{ STB0899_RSULC\t\t\t, 0xb1 },  \n\t{ STB0899_TSULC\t\t\t, 0x42 },\n\t{ STB0899_RSLLC\t\t\t, 0x40 },\n\t{ STB0899_TSLPL\t\t\t, 0x12 },\n\t{ STB0899_TSCFGH\t\t, 0x0c },\n\t{ STB0899_TSCFGM\t\t, 0x00 },\n\t{ STB0899_TSCFGL\t\t, 0x0c },\n\t{ STB0899_TSOUT\t\t\t, 0x4d },  \n\t{ STB0899_RSSYNCDEL\t\t, 0x00 },\n\t{ STB0899_TSINHDELH\t\t, 0x02 },\n\t{ STB0899_TSINHDELM\t\t, 0x00 },\n\t{ STB0899_TSINHDELL\t\t, 0x00 },\n\t{ STB0899_TSLLSTKM\t\t, 0x00 },\n\t{ STB0899_TSLLSTKL\t\t, 0x00 },\n\t{ STB0899_TSULSTKM\t\t, 0x00 },\n\t{ STB0899_TSULSTKL\t\t, 0xab },\n\t{ STB0899_PCKLENUL\t\t, 0x00 },\n\t{ STB0899_PCKLENLL\t\t, 0xcc },\n\t{ STB0899_RSPCKLEN\t\t, 0xcc },\n\t{ STB0899_TSSTATUS\t\t, 0x80 },\n\t{ STB0899_ERRCTRL1\t\t, 0xb6 },\n\t{ STB0899_ERRCTRL2\t\t, 0x96 },\n\t{ STB0899_ERRCTRL3\t\t, 0x89 },\n\t{ STB0899_DMONMSK1\t\t, 0x27 },\n\t{ STB0899_DMONMSK0\t\t, 0x03 },\n\t{ STB0899_DEMAPVIT\t\t, 0x5c },\n\t{ STB0899_PLPARM\t\t, 0x1f },\n\t{ STB0899_PDELCTRL\t\t, 0x48 },\n\t{ STB0899_PDELCTRL2\t\t, 0x00 },\n\t{ STB0899_BBHCTRL1\t\t, 0x00 },\n\t{ STB0899_BBHCTRL2\t\t, 0x00 },\n\t{ STB0899_HYSTTHRESH\t\t, 0x77 },\n\t{ STB0899_MATCSTM\t\t, 0x00 },\n\t{ STB0899_MATCSTL\t\t, 0x00 },\n\t{ STB0899_UPLCSTM\t\t, 0x00 },\n\t{ STB0899_UPLCSTL\t\t, 0x00 },\n\t{ STB0899_DFLCSTM\t\t, 0x00 },\n\t{ STB0899_DFLCSTL\t\t, 0x00 },\n\t{ STB0899_SYNCCST\t\t, 0x00 },\n\t{ STB0899_SYNCDCSTM\t\t, 0x00 },\n\t{ STB0899_SYNCDCSTL\t\t, 0x00 },\n\t{ STB0899_ISI_ENTRY\t\t, 0x00 },\n\t{ STB0899_ISI_BIT_EN\t\t, 0x00 },\n\t{ STB0899_MATSTRM\t\t, 0x00 },\n\t{ STB0899_MATSTRL\t\t, 0x00 },\n\t{ STB0899_UPLSTRM\t\t, 0x00 },\n\t{ STB0899_UPLSTRL\t\t, 0x00 },\n\t{ STB0899_DFLSTRM\t\t, 0x00 },\n\t{ STB0899_DFLSTRL\t\t, 0x00 },\n\t{ STB0899_SYNCSTR\t\t, 0x00 },\n\t{ STB0899_SYNCDSTRM\t\t, 0x00 },\n\t{ STB0899_SYNCDSTRL\t\t, 0x00 },\n\t{ STB0899_CFGPDELSTATUS1\t, 0x10 },\n\t{ STB0899_CFGPDELSTATUS2\t, 0x00 },\n\t{ STB0899_BBFERRORM\t\t, 0x00 },\n\t{ STB0899_BBFERRORL\t\t, 0x00 },\n\t{ STB0899_UPKTERRORM\t\t, 0x00 },\n\t{ STB0899_UPKTERRORL\t\t, 0x00 },\n\t{ 0xffff\t\t\t, 0xff },\n};\n\n \nstatic struct stb0899_config knc1_dvbs2_config = {\n\t.init_dev\t\t= knc1_stb0899_s1_init_1,\n\t.init_s2_demod\t\t= stb0899_s2_init_2,\n\t.init_s1_demod\t\t= knc1_stb0899_s1_init_3,\n\t.init_s2_fec\t\t= stb0899_s2_init_4,\n\t.init_tst\t\t= stb0899_s1_init_5,\n\n\t.postproc\t\t= NULL,\n\n\t.demod_address\t\t= 0x68,\n\n\t.block_sync_mode\t= STB0899_SYNC_FORCED,\t \n\n\n\t.xtal_freq\t\t= 27000000,\n\t.inversion\t\t= IQ_SWAP_OFF,\n\n\t.lo_clk\t\t\t= 76500000,\n\t.hi_clk\t\t\t= 90000000,\n\n\t.esno_ave\t\t= STB0899_DVBS2_ESNO_AVE,\n\t.esno_quant\t\t= STB0899_DVBS2_ESNO_QUANT,\n\t.avframes_coarse\t= STB0899_DVBS2_AVFRAMES_COARSE,\n\t.avframes_fine\t\t= STB0899_DVBS2_AVFRAMES_FINE,\n\t.miss_threshold\t\t= STB0899_DVBS2_MISS_THRESHOLD,\n\t.uwp_threshold_acq\t= STB0899_DVBS2_UWP_THRESHOLD_ACQ,\n\t.uwp_threshold_track\t= STB0899_DVBS2_UWP_THRESHOLD_TRACK,\n\t.uwp_threshold_sof\t= STB0899_DVBS2_UWP_THRESHOLD_SOF,\n\t.sof_search_timeout\t= STB0899_DVBS2_SOF_SEARCH_TIMEOUT,\n\n\t.btr_nco_bits\t\t= STB0899_DVBS2_BTR_NCO_BITS,\n\t.btr_gain_shift_offset\t= STB0899_DVBS2_BTR_GAIN_SHIFT_OFFSET,\n\t.crl_nco_bits\t\t= STB0899_DVBS2_CRL_NCO_BITS,\n\t.ldpc_max_iter\t\t= STB0899_DVBS2_LDPC_MAX_ITER,\n\n\t.tuner_get_frequency\t= tda8261_get_frequency,\n\t.tuner_set_frequency\t= tda8261_set_frequency,\n\t.tuner_set_bandwidth\t= NULL,\n\t.tuner_get_bandwidth\t= tda8261_get_bandwidth,\n\t.tuner_set_rfsiggain\t= NULL\n};\n\n \nstatic const struct tda8261_config sd1878c_config = {\n\n\t.addr\t\t= 0x60,\n\t.step_size\t= TDA8261_STEP_1000  \n};\n\nstatic u8 read_pwm(struct budget_av *budget_av)\n{\n\tu8 b = 0xff;\n\tu8 pwm;\n\tstruct i2c_msg msg[] = { {.addr = 0x50,.flags = 0,.buf = &b,.len = 1},\n\t{.addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1}\n\t};\n\n\tif ((i2c_transfer(&budget_av->budget.i2c_adap, msg, 2) != 2)\n\t    || (pwm == 0xff))\n\t\tpwm = 0x48;\n\n\treturn pwm;\n}\n\n#define SUBID_DVBS_KNC1\t\t\t0x0010\n#define SUBID_DVBS_KNC1_PLUS\t\t0x0011\n#define SUBID_DVBS_TYPHOON\t\t0x4f56\n#define SUBID_DVBS_CINERGY1200\t\t0x1154\n#define SUBID_DVBS_CYNERGY1200N\t\t0x1155\n#define SUBID_DVBS_TV_STAR\t\t0x0014\n#define SUBID_DVBS_TV_STAR_PLUS_X4\t0x0015\n#define SUBID_DVBS_TV_STAR_CI\t\t0x0016\n#define SUBID_DVBS2_KNC1\t\t0x0018\n#define SUBID_DVBS2_KNC1_OEM\t\t0x0019\n#define SUBID_DVBS_EASYWATCH_1\t\t0x001a\n#define SUBID_DVBS_EASYWATCH_2\t\t0x001b\n#define SUBID_DVBS2_EASYWATCH\t\t0x001d\n#define SUBID_DVBS_EASYWATCH\t\t0x001e\n\n#define SUBID_DVBC_EASYWATCH\t\t0x002a\n#define SUBID_DVBC_EASYWATCH_MK3\t0x002c\n#define SUBID_DVBC_KNC1\t\t\t0x0020\n#define SUBID_DVBC_KNC1_PLUS\t\t0x0021\n#define SUBID_DVBC_KNC1_MK3\t\t0x0022\n#define SUBID_DVBC_KNC1_TDA10024\t0x0028\n#define SUBID_DVBC_KNC1_PLUS_MK3\t0x0023\n#define SUBID_DVBC_CINERGY1200\t\t0x1156\n#define SUBID_DVBC_CINERGY1200_MK3\t0x1176\n\n#define SUBID_DVBT_EASYWATCH\t\t0x003a\n#define SUBID_DVBT_KNC1_PLUS\t\t0x0031\n#define SUBID_DVBT_KNC1\t\t\t0x0030\n#define SUBID_DVBT_CINERGY1200\t\t0x1157\n\nstatic void frontend_init(struct budget_av *budget_av)\n{\n\tstruct saa7146_dev * saa = budget_av->budget.dev;\n\tstruct dvb_frontend * fe = NULL;\n\n\t \n\tsaa7146_setgpio(saa, 0, SAA7146_GPIO_OUTLO);\n\n\t \n\tmsleep(100);\n\n\t \n\tswitch (saa->pci->subsystem_device) {\n\t\tcase SUBID_DVBS_KNC1_PLUS:\n\t\tcase SUBID_DVBC_KNC1_PLUS:\n\t\tcase SUBID_DVBT_KNC1_PLUS:\n\t\tcase SUBID_DVBC_EASYWATCH:\n\t\tcase SUBID_DVBC_KNC1_PLUS_MK3:\n\t\tcase SUBID_DVBS2_KNC1:\n\t\tcase SUBID_DVBS2_KNC1_OEM:\n\t\tcase SUBID_DVBS2_EASYWATCH:\n\t\t\tsaa7146_setgpio(saa, 3, SAA7146_GPIO_OUTHI);\n\t\t\tbreak;\n\t}\n\n\tswitch (saa->pci->subsystem_device) {\n\n\tcase SUBID_DVBS_KNC1:\n\t\t \n\t\tbudget_av->reinitialise_demod = 1;\n\t\tfallthrough;\n\tcase SUBID_DVBS_KNC1_PLUS:\n\tcase SUBID_DVBS_EASYWATCH_1:\n\t\tif (saa->pci->subsystem_vendor == 0x1894) {\n\t\t\tfe = dvb_attach(stv0299_attach, &cinergy_1200s_1894_0010_config,\n\t\t\t\t\t     &budget_av->budget.i2c_adap);\n\t\t\tif (fe) {\n\t\t\t\tdvb_attach(tua6100_attach, fe, 0x60, &budget_av->budget.i2c_adap);\n\t\t\t}\n\t\t} else {\n\t\t\tfe = dvb_attach(stv0299_attach, &typhoon_config,\n\t\t\t\t\t     &budget_av->budget.i2c_adap);\n\t\t\tif (fe) {\n\t\t\t\tfe->ops.tuner_ops.set_params = philips_su1278_ty_ci_tuner_set_params;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase SUBID_DVBS_TV_STAR:\n\tcase SUBID_DVBS_TV_STAR_PLUS_X4:\n\tcase SUBID_DVBS_TV_STAR_CI:\n\tcase SUBID_DVBS_CYNERGY1200N:\n\tcase SUBID_DVBS_EASYWATCH:\n\tcase SUBID_DVBS_EASYWATCH_2:\n\t\tfe = dvb_attach(stv0299_attach, &philips_sd1878_config,\n\t\t\t\t&budget_av->budget.i2c_adap);\n\t\tif (fe) {\n\t\t\tdvb_attach(dvb_pll_attach, fe, 0x60,\n\t\t\t\t   &budget_av->budget.i2c_adap,\n\t\t\t\t   DVB_PLL_PHILIPS_SD1878_TDA8261);\n\t\t}\n\t\tbreak;\n\n\tcase SUBID_DVBS_TYPHOON:\n\t\tfe = dvb_attach(stv0299_attach, &typhoon_config,\n\t\t\t\t    &budget_av->budget.i2c_adap);\n\t\tif (fe) {\n\t\t\tfe->ops.tuner_ops.set_params = philips_su1278_ty_ci_tuner_set_params;\n\t\t}\n\t\tbreak;\n\tcase SUBID_DVBS2_KNC1:\n\tcase SUBID_DVBS2_KNC1_OEM:\n\tcase SUBID_DVBS2_EASYWATCH:\n\t\tbudget_av->reinitialise_demod = 1;\n\t\tif ((fe = dvb_attach(stb0899_attach, &knc1_dvbs2_config, &budget_av->budget.i2c_adap)))\n\t\t\tdvb_attach(tda8261_attach, fe, &sd1878c_config, &budget_av->budget.i2c_adap);\n\n\t\tbreak;\n\tcase SUBID_DVBS_CINERGY1200:\n\t\tfe = dvb_attach(stv0299_attach, &cinergy_1200s_config,\n\t\t\t\t    &budget_av->budget.i2c_adap);\n\t\tif (fe) {\n\t\t\tfe->ops.tuner_ops.set_params = philips_su1278_ty_ci_tuner_set_params;\n\t\t}\n\t\tbreak;\n\n\tcase SUBID_DVBC_KNC1:\n\tcase SUBID_DVBC_KNC1_PLUS:\n\tcase SUBID_DVBC_CINERGY1200:\n\tcase SUBID_DVBC_EASYWATCH:\n\t\tbudget_av->reinitialise_demod = 1;\n\t\tbudget_av->budget.dev->i2c_bitrate = SAA7146_I2C_BUS_BIT_RATE_240;\n\t\tfe = dvb_attach(tda10021_attach, &philips_cu1216_config,\n\t\t\t\t     &budget_av->budget.i2c_adap,\n\t\t\t\t     read_pwm(budget_av));\n\t\tif (fe == NULL)\n\t\t\tfe = dvb_attach(tda10021_attach, &philips_cu1216_config_altaddress,\n\t\t\t\t\t     &budget_av->budget.i2c_adap,\n\t\t\t\t\t     read_pwm(budget_av));\n\t\tif (fe) {\n\t\t\tfe->ops.tuner_ops.set_params = philips_cu1216_tuner_set_params;\n\t\t}\n\t\tbreak;\n\n\tcase SUBID_DVBC_EASYWATCH_MK3:\n\tcase SUBID_DVBC_CINERGY1200_MK3:\n\tcase SUBID_DVBC_KNC1_MK3:\n\tcase SUBID_DVBC_KNC1_TDA10024:\n\tcase SUBID_DVBC_KNC1_PLUS_MK3:\n\t\tbudget_av->reinitialise_demod = 1;\n\t\tbudget_av->budget.dev->i2c_bitrate = SAA7146_I2C_BUS_BIT_RATE_240;\n\t\tfe = dvb_attach(tda10023_attach,\n\t\t\t&philips_cu1216_tda10023_config,\n\t\t\t&budget_av->budget.i2c_adap,\n\t\t\tread_pwm(budget_av));\n\t\tif (fe) {\n\t\t\tfe->ops.tuner_ops.set_params = philips_cu1216_tuner_set_params;\n\t\t}\n\t\tbreak;\n\n\tcase SUBID_DVBT_EASYWATCH:\n\tcase SUBID_DVBT_KNC1:\n\tcase SUBID_DVBT_KNC1_PLUS:\n\tcase SUBID_DVBT_CINERGY1200:\n\t\tbudget_av->reinitialise_demod = 1;\n\t\tfe = dvb_attach(tda10046_attach, &philips_tu1216_config,\n\t\t\t\t     &budget_av->budget.i2c_adap);\n\t\tif (fe) {\n\t\t\tfe->ops.tuner_ops.init = philips_tu1216_tuner_init;\n\t\t\tfe->ops.tuner_ops.set_params = philips_tu1216_tuner_set_params;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (fe == NULL) {\n\t\tpr_err(\"A frontend driver was not found for device [%04x:%04x] subsystem [%04x:%04x]\\n\",\n\t\t       saa->pci->vendor,\n\t\t       saa->pci->device,\n\t\t       saa->pci->subsystem_vendor,\n\t\t       saa->pci->subsystem_device);\n\t\treturn;\n\t}\n\n\tbudget_av->budget.dvb_frontend = fe;\n\n\tif (dvb_register_frontend(&budget_av->budget.dvb_adapter,\n\t\t\t\t  budget_av->budget.dvb_frontend)) {\n\t\tpr_err(\"Frontend registration failed!\\n\");\n\t\tdvb_frontend_detach(budget_av->budget.dvb_frontend);\n\t\tbudget_av->budget.dvb_frontend = NULL;\n\t}\n}\n\n\nstatic void budget_av_irq(struct saa7146_dev *dev, u32 * isr)\n{\n\tstruct budget_av *budget_av = dev->ext_priv;\n\n\tdprintk(8, \"dev: %p, budget_av: %p\\n\", dev, budget_av);\n\n\tif (*isr & MASK_10)\n\t\tttpci_budget_irq10_handler(dev, isr);\n}\n\nstatic int budget_av_detach(struct saa7146_dev *dev)\n{\n\tstruct budget_av *budget_av = dev->ext_priv;\n\tint err;\n\n\tdprintk(2, \"dev: %p\\n\", dev);\n\n\tif (1 == budget_av->has_saa7113) {\n\t\tsaa7146_setgpio(dev, 0, SAA7146_GPIO_OUTLO);\n\n\t\tmsleep(200);\n\n\t\tsaa7146_unregister_device(&budget_av->vd, dev);\n\n\t\tsaa7146_vv_release(dev);\n\t}\n\n\tif (budget_av->budget.ci_present)\n\t\tciintf_deinit(budget_av);\n\n\tif (budget_av->budget.dvb_frontend != NULL) {\n\t\tdvb_unregister_frontend(budget_av->budget.dvb_frontend);\n\t\tdvb_frontend_detach(budget_av->budget.dvb_frontend);\n\t}\n\terr = ttpci_budget_deinit(&budget_av->budget);\n\n\tkfree(budget_av);\n\n\treturn err;\n}\n\n#define KNC1_INPUTS 2\nstatic struct v4l2_input knc1_inputs[KNC1_INPUTS] = {\n\t{ 0, \"Composite\", V4L2_INPUT_TYPE_TUNER, 1, 0,\n\t\tV4L2_STD_PAL_BG | V4L2_STD_NTSC_M, 0, V4L2_IN_CAP_STD },\n\t{ 1, \"S-Video\", V4L2_INPUT_TYPE_CAMERA, 2, 0,\n\t\tV4L2_STD_PAL_BG | V4L2_STD_NTSC_M, 0, V4L2_IN_CAP_STD },\n};\n\nstatic int vidioc_enum_input(struct file *file, void *fh, struct v4l2_input *i)\n{\n\tdprintk(1, \"VIDIOC_ENUMINPUT %d\\n\", i->index);\n\tif (i->index >= KNC1_INPUTS)\n\t\treturn -EINVAL;\n\tmemcpy(i, &knc1_inputs[i->index], sizeof(struct v4l2_input));\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *i)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct budget_av *budget_av = dev->ext_priv;\n\n\t*i = budget_av->cur_input;\n\n\tdprintk(1, \"VIDIOC_G_INPUT %d\\n\", *i);\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int input)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct budget_av *budget_av = dev->ext_priv;\n\n\tdprintk(1, \"VIDIOC_S_INPUT %d\\n\", input);\n\treturn saa7113_setinput(budget_av, input);\n}\n\nstatic struct saa7146_ext_vv vv_data;\n\nstatic int budget_av_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_data *info)\n{\n\tstruct budget_av *budget_av;\n\tu8 *mac;\n\tint err;\n\n\tdprintk(2, \"dev: %p\\n\", dev);\n\n\tif (!(budget_av = kzalloc(sizeof(struct budget_av), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tbudget_av->has_saa7113 = 0;\n\tbudget_av->budget.ci_present = 0;\n\n\tdev->ext_priv = budget_av;\n\n\terr = ttpci_budget_init(&budget_av->budget, dev, info, THIS_MODULE,\n\t\t\t\tadapter_nr);\n\tif (err) {\n\t\tkfree(budget_av);\n\t\treturn err;\n\t}\n\n\t \n\tsaa7146_write(dev, DD1_STREAM_B, 0x04000000);\n\tsaa7146_write(dev, DD1_INIT, 0x07000600);\n\tsaa7146_write(dev, MC2, MASK_09 | MASK_25 | MASK_10 | MASK_26);\n\n\tif (saa7113_init(budget_av) == 0) {\n\t\tbudget_av->has_saa7113 = 1;\n\t\terr = saa7146_vv_init(dev, &vv_data);\n\t\tif (err != 0) {\n\t\t\t \n\t\t\tERR(\"cannot init vv subsystem\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tvv_data.vid_ops.vidioc_enum_input = vidioc_enum_input;\n\t\tvv_data.vid_ops.vidioc_g_input = vidioc_g_input;\n\t\tvv_data.vid_ops.vidioc_s_input = vidioc_s_input;\n\n\t\tif ((err = saa7146_register_device(&budget_av->vd, dev, \"knc1\", VFL_TYPE_VIDEO))) {\n\t\t\t \n\t\t\tERR(\"cannot register capture v4l2 device\\n\");\n\t\t\tsaa7146_vv_release(dev);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tsaa7146_set_hps_source_and_sync(dev, SAA7146_HPS_SOURCE_PORT_A,\n\t\t\t\t\t\tSAA7146_HPS_SYNC_PORT_A);\n\n\t\tsaa7113_setinput(budget_av, 0);\n\t}\n\n\t \n\tsaa7146_write(dev, PCI_BT_V1, 0x1c00101f);\n\n\tmac = budget_av->budget.dvb_adapter.proposed_mac;\n\tif (i2c_readregs(&budget_av->budget.i2c_adap, 0xa0, 0x30, mac, 6)) {\n\t\tpr_err(\"KNC1-%d: Could not read MAC from KNC1 card\\n\",\n\t\t       budget_av->budget.dvb_adapter.num);\n\t\teth_zero_addr(mac);\n\t} else {\n\t\tpr_info(\"KNC1-%d: MAC addr = %pM\\n\",\n\t\t\tbudget_av->budget.dvb_adapter.num, mac);\n\t}\n\n\tbudget_av->budget.dvb_adapter.priv = budget_av;\n\tfrontend_init(budget_av);\n\tciintf_init(budget_av);\n\n\tttpci_budget_init_hooks(&budget_av->budget);\n\n\treturn 0;\n}\n\nstatic struct saa7146_standard standard[] = {\n\t{.name = \"PAL\",.id = V4L2_STD_PAL,\n\t .v_offset = 0x17,.v_field = 288,\n\t .h_offset = 0x14,.h_pixels = 680,\n\t .v_max_out = 576,.h_max_out = 768 },\n\n\t{.name = \"NTSC\",.id = V4L2_STD_NTSC,\n\t .v_offset = 0x16,.v_field = 240,\n\t .h_offset = 0x06,.h_pixels = 708,\n\t .v_max_out = 480,.h_max_out = 640, },\n};\n\nstatic struct saa7146_ext_vv vv_data = {\n\t.inputs = 2,\n\t.capabilities = 0,\t\n\t.flags = 0,\n\t.stds = &standard[0],\n\t.num_stds = ARRAY_SIZE(standard),\n};\n\nstatic struct saa7146_extension budget_extension;\n\nMAKE_BUDGET_INFO(knc1s, \"KNC1 DVB-S\", BUDGET_KNC1S);\nMAKE_BUDGET_INFO(knc1s2,\"KNC1 DVB-S2\", BUDGET_KNC1S2);\nMAKE_BUDGET_INFO(sates2,\"Satelco EasyWatch DVB-S2\", BUDGET_KNC1S2);\nMAKE_BUDGET_INFO(knc1c, \"KNC1 DVB-C\", BUDGET_KNC1C);\nMAKE_BUDGET_INFO(knc1t, \"KNC1 DVB-T\", BUDGET_KNC1T);\nMAKE_BUDGET_INFO(kncxs, \"KNC TV STAR DVB-S\", BUDGET_TVSTAR);\nMAKE_BUDGET_INFO(satewpls, \"Satelco EasyWatch DVB-S light\", BUDGET_TVSTAR);\nMAKE_BUDGET_INFO(satewpls1, \"Satelco EasyWatch DVB-S light\", BUDGET_KNC1S);\nMAKE_BUDGET_INFO(satewps, \"Satelco EasyWatch DVB-S\", BUDGET_KNC1S);\nMAKE_BUDGET_INFO(satewplc, \"Satelco EasyWatch DVB-C\", BUDGET_KNC1CP);\nMAKE_BUDGET_INFO(satewcmk3, \"Satelco EasyWatch DVB-C MK3\", BUDGET_KNC1C_MK3);\nMAKE_BUDGET_INFO(satewt, \"Satelco EasyWatch DVB-T\", BUDGET_KNC1T);\nMAKE_BUDGET_INFO(knc1sp, \"KNC1 DVB-S Plus\", BUDGET_KNC1SP);\nMAKE_BUDGET_INFO(knc1spx4, \"KNC1 DVB-S Plus X4\", BUDGET_KNC1SP);\nMAKE_BUDGET_INFO(knc1cp, \"KNC1 DVB-C Plus\", BUDGET_KNC1CP);\nMAKE_BUDGET_INFO(knc1cmk3, \"KNC1 DVB-C MK3\", BUDGET_KNC1C_MK3);\nMAKE_BUDGET_INFO(knc1ctda10024, \"KNC1 DVB-C TDA10024\", BUDGET_KNC1C_TDA10024);\nMAKE_BUDGET_INFO(knc1cpmk3, \"KNC1 DVB-C Plus MK3\", BUDGET_KNC1CP_MK3);\nMAKE_BUDGET_INFO(knc1tp, \"KNC1 DVB-T Plus\", BUDGET_KNC1TP);\nMAKE_BUDGET_INFO(cin1200s, \"TerraTec Cinergy 1200 DVB-S\", BUDGET_CIN1200S);\nMAKE_BUDGET_INFO(cin1200sn, \"TerraTec Cinergy 1200 DVB-S\", BUDGET_CIN1200S);\nMAKE_BUDGET_INFO(cin1200c, \"Terratec Cinergy 1200 DVB-C\", BUDGET_CIN1200C);\nMAKE_BUDGET_INFO(cin1200cmk3, \"Terratec Cinergy 1200 DVB-C MK3\", BUDGET_CIN1200C_MK3);\nMAKE_BUDGET_INFO(cin1200t, \"Terratec Cinergy 1200 DVB-T\", BUDGET_CIN1200T);\n\nstatic const struct pci_device_id pci_tbl[] = {\n\tMAKE_EXTENSION_PCI(knc1s, 0x1131, 0x4f56),\n\tMAKE_EXTENSION_PCI(knc1s, 0x1131, 0x0010),\n\tMAKE_EXTENSION_PCI(knc1s, 0x1894, 0x0010),\n\tMAKE_EXTENSION_PCI(knc1sp, 0x1131, 0x0011),\n\tMAKE_EXTENSION_PCI(knc1sp, 0x1894, 0x0011),\n\tMAKE_EXTENSION_PCI(kncxs, 0x1894, 0x0014),\n\tMAKE_EXTENSION_PCI(knc1spx4, 0x1894, 0x0015),\n\tMAKE_EXTENSION_PCI(kncxs, 0x1894, 0x0016),\n\tMAKE_EXTENSION_PCI(knc1s2, 0x1894, 0x0018),\n\tMAKE_EXTENSION_PCI(knc1s2, 0x1894, 0x0019),\n\tMAKE_EXTENSION_PCI(sates2, 0x1894, 0x001d),\n\tMAKE_EXTENSION_PCI(satewpls, 0x1894, 0x001e),\n\tMAKE_EXTENSION_PCI(satewpls1, 0x1894, 0x001a),\n\tMAKE_EXTENSION_PCI(satewps, 0x1894, 0x001b),\n\tMAKE_EXTENSION_PCI(satewplc, 0x1894, 0x002a),\n\tMAKE_EXTENSION_PCI(satewcmk3, 0x1894, 0x002c),\n\tMAKE_EXTENSION_PCI(satewt, 0x1894, 0x003a),\n\tMAKE_EXTENSION_PCI(knc1c, 0x1894, 0x0020),\n\tMAKE_EXTENSION_PCI(knc1cp, 0x1894, 0x0021),\n\tMAKE_EXTENSION_PCI(knc1cmk3, 0x1894, 0x0022),\n\tMAKE_EXTENSION_PCI(knc1ctda10024, 0x1894, 0x0028),\n\tMAKE_EXTENSION_PCI(knc1cpmk3, 0x1894, 0x0023),\n\tMAKE_EXTENSION_PCI(knc1t, 0x1894, 0x0030),\n\tMAKE_EXTENSION_PCI(knc1tp, 0x1894, 0x0031),\n\tMAKE_EXTENSION_PCI(cin1200s, 0x153b, 0x1154),\n\tMAKE_EXTENSION_PCI(cin1200sn, 0x153b, 0x1155),\n\tMAKE_EXTENSION_PCI(cin1200c, 0x153b, 0x1156),\n\tMAKE_EXTENSION_PCI(cin1200cmk3, 0x153b, 0x1176),\n\tMAKE_EXTENSION_PCI(cin1200t, 0x153b, 0x1157),\n\t{\n\t .vendor = 0,\n\t}\n};\n\nMODULE_DEVICE_TABLE(pci, pci_tbl);\n\nstatic struct saa7146_extension budget_extension = {\n\t.name = \"budget_av\",\n\t.flags = SAA7146_USE_I2C_IRQ,\n\n\t.pci_tbl = pci_tbl,\n\n\t.module = THIS_MODULE,\n\t.attach = budget_av_attach,\n\t.detach = budget_av_detach,\n\n\t.irq_mask = MASK_10,\n\t.irq_func = budget_av_irq,\n};\n\nstatic int __init budget_av_init(void)\n{\n\treturn saa7146_register_extension(&budget_extension);\n}\n\nstatic void __exit budget_av_exit(void)\n{\n\tsaa7146_unregister_extension(&budget_extension);\n}\n\nmodule_init(budget_av_init);\nmodule_exit(budget_av_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ralph Metzler, Marcus Metzler, Michael Hunold, others\");\nMODULE_DESCRIPTION(\"driver for the SAA7146 based so-called budget PCI DVB w/ analog input and CI-module (e.g. the KNC cards)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}