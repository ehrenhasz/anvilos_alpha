{
  "module_name": "budget-ci.c",
  "hash_id": "bdf6b4f9637bbce1d0106c601b3f375e538bb33f5839afdd1c1787e09649c69d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ttpci/budget-ci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <media/rc-core.h>\n\n#include \"budget.h\"\n\n#include <media/dvb_ca_en50221.h>\n#include \"stv0299.h\"\n#include \"stv0297.h\"\n#include \"tda1004x.h\"\n#include \"stb0899_drv.h\"\n#include \"stb0899_reg.h\"\n#include \"stb0899_cfg.h\"\n#include \"stb6100.h\"\n#include \"stb6100_cfg.h\"\n#include \"lnbp21.h\"\n#include \"bsbe1.h\"\n#include \"bsru6.h\"\n#include \"tda1002x.h\"\n#include \"tda827x.h\"\n#include \"bsbe1-d01a.h\"\n\n#define MODULE_NAME \"budget_ci\"\n\n \n#define DEBIADDR_IR\t\t0x4000\n#define DEBIADDR_CICONTROL\t0x0000\n#define DEBIADDR_CIVERSION\t0x4000\n#define DEBIADDR_IO\t\t0x1000\n#define DEBIADDR_ATTR\t\t0x3000\n\n#define CICONTROL_RESET\t\t0x01\n#define CICONTROL_ENABLETS\t0x02\n#define CICONTROL_CAMDETECT\t0x08\n\n#define DEBICICTL\t\t0x00420000\n#define DEBICICAM\t\t0x02420000\n\n#define SLOTSTATUS_NONE\t\t1\n#define SLOTSTATUS_PRESENT\t2\n#define SLOTSTATUS_RESET\t4\n#define SLOTSTATUS_READY\t8\n#define SLOTSTATUS_OCCUPIED\t(SLOTSTATUS_PRESENT|SLOTSTATUS_RESET|SLOTSTATUS_READY)\n\n \n#define IR_DEVICE_ANY\t\t255\n\nstatic int rc5_device = -1;\nmodule_param(rc5_device, int, 0644);\nMODULE_PARM_DESC(rc5_device, \"only IR commands to given RC5 device (device = 0 - 31, any device = 255, default: autodetect)\");\n\nstatic int ir_debug;\nmodule_param(ir_debug, int, 0644);\nMODULE_PARM_DESC(ir_debug, \"enable debugging information for IR decoding\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstruct budget_ci_ir {\n\tstruct rc_dev *dev;\n\tstruct tasklet_struct msp430_irq_tasklet;\n\tchar name[72];  \n\tchar phys[32];\n\tint rc5_device;\n\tu32 ir_key;\n\tbool have_command;\n\tbool full_rc5;\t\t \n};\n\nstruct budget_ci {\n\tstruct budget budget;\n\tstruct tasklet_struct ciintf_irq_tasklet;\n\tint slot_status;\n\tint ci_irq;\n\tstruct dvb_ca_en50221 ca;\n\tstruct budget_ci_ir ir;\n\tu8 tuner_pll_address;  \n};\n\nstatic void msp430_ir_interrupt(struct tasklet_struct *t)\n{\n\tstruct budget_ci_ir *ir = from_tasklet(ir, t, msp430_irq_tasklet);\n\tstruct budget_ci *budget_ci = container_of(ir, typeof(*budget_ci), ir);\n\tstruct rc_dev *dev = budget_ci->ir.dev;\n\tu32 command = ttpci_budget_debiread(&budget_ci->budget, DEBINOSWAP, DEBIADDR_IR, 2, 1, 0) >> 8;\n\n\t \n\n\tif (ir_debug)\n\t\tprintk(\"budget_ci: received byte 0x%02x\\n\", command);\n\n\t \n\tcommand = command & 0x7f;\n\n\t \n\tif (command & 0x40) {\n\t\tbudget_ci->ir.have_command = true;\n\t\tbudget_ci->ir.ir_key = command & 0x3f;\n\t\treturn;\n\t}\n\n\t \n\tif (!budget_ci->ir.have_command)\n\t\treturn;\n\tbudget_ci->ir.have_command = false;\n\n\tif (budget_ci->ir.rc5_device != IR_DEVICE_ANY &&\n\t    budget_ci->ir.rc5_device != (command & 0x1f))\n\t\treturn;\n\n\tif (budget_ci->ir.full_rc5) {\n\t\trc_keydown(dev, RC_PROTO_RC5,\n\t\t\t   RC_SCANCODE_RC5(budget_ci->ir.rc5_device, budget_ci->ir.ir_key),\n\t\t\t   !!(command & 0x20));\n\t\treturn;\n\t}\n\n\t \n\trc_keydown(dev, RC_PROTO_UNKNOWN, budget_ci->ir.ir_key,\n\t\t   !!(command & 0x20));\n}\n\nstatic int msp430_ir_init(struct budget_ci *budget_ci)\n{\n\tstruct saa7146_dev *saa = budget_ci->budget.dev;\n\tstruct rc_dev *dev;\n\tint error;\n\n\tdev = rc_allocate_device(RC_DRIVER_SCANCODE);\n\tif (!dev) {\n\t\tprintk(KERN_ERR \"budget_ci: IR interface initialisation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsnprintf(budget_ci->ir.name, sizeof(budget_ci->ir.name),\n\t\t \"Budget-CI dvb ir receiver %s\", saa->name);\n\tsnprintf(budget_ci->ir.phys, sizeof(budget_ci->ir.phys),\n\t\t \"pci-%s/ir0\", pci_name(saa->pci));\n\n\tdev->driver_name = MODULE_NAME;\n\tdev->device_name = budget_ci->ir.name;\n\tdev->input_phys = budget_ci->ir.phys;\n\tdev->input_id.bustype = BUS_PCI;\n\tdev->input_id.version = 1;\n\tif (saa->pci->subsystem_vendor) {\n\t\tdev->input_id.vendor = saa->pci->subsystem_vendor;\n\t\tdev->input_id.product = saa->pci->subsystem_device;\n\t} else {\n\t\tdev->input_id.vendor = saa->pci->vendor;\n\t\tdev->input_id.product = saa->pci->device;\n\t}\n\tdev->dev.parent = &saa->pci->dev;\n\n\tif (rc5_device < 0)\n\t\tbudget_ci->ir.rc5_device = IR_DEVICE_ANY;\n\telse\n\t\tbudget_ci->ir.rc5_device = rc5_device;\n\n\t \n\tswitch (budget_ci->budget.dev->pci->subsystem_device) {\n\tcase 0x100c:\n\tcase 0x100f:\n\tcase 0x1011:\n\tcase 0x1012:\n\t\t \n\t\tdev->map_name = RC_MAP_HAUPPAUGE;\n\t\tbudget_ci->ir.full_rc5 = true;\n\n\t\tif (rc5_device < 0)\n\t\t\tbudget_ci->ir.rc5_device = 0x1f;\n\t\tbreak;\n\tcase 0x1010:\n\tcase 0x1017:\n\tcase 0x1019:\n\tcase 0x101a:\n\tcase 0x101b:\n\t\t \n\t\tdev->map_name = RC_MAP_TT_1500;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev->map_name = RC_MAP_BUDGET_CI_OLD;\n\t\tbreak;\n\t}\n\tif (!budget_ci->ir.full_rc5)\n\t\tdev->scancode_mask = 0xff;\n\n\terror = rc_register_device(dev);\n\tif (error) {\n\t\tprintk(KERN_ERR \"budget_ci: could not init driver for IR device (code %d)\\n\", error);\n\t\trc_free_device(dev);\n\t\treturn error;\n\t}\n\n\tbudget_ci->ir.dev = dev;\n\n\ttasklet_setup(&budget_ci->ir.msp430_irq_tasklet, msp430_ir_interrupt);\n\n\tSAA7146_IER_ENABLE(saa, MASK_06);\n\tsaa7146_setgpio(saa, 3, SAA7146_GPIO_IRQHI);\n\n\treturn 0;\n}\n\nstatic void msp430_ir_deinit(struct budget_ci *budget_ci)\n{\n\tstruct saa7146_dev *saa = budget_ci->budget.dev;\n\n\tSAA7146_IER_DISABLE(saa, MASK_06);\n\tsaa7146_setgpio(saa, 3, SAA7146_GPIO_INPUT);\n\ttasklet_kill(&budget_ci->ir.msp430_irq_tasklet);\n\n\trc_unregister_device(budget_ci->ir.dev);\n}\n\nstatic int ciintf_read_attribute_mem(struct dvb_ca_en50221 *ca, int slot, int address)\n{\n\tstruct budget_ci *budget_ci = ca->data;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\treturn ttpci_budget_debiread(&budget_ci->budget, DEBICICAM,\n\t\t\t\t     DEBIADDR_ATTR | (address & 0xfff), 1, 1, 0);\n}\n\nstatic int ciintf_write_attribute_mem(struct dvb_ca_en50221 *ca, int slot, int address, u8 value)\n{\n\tstruct budget_ci *budget_ci = ca->data;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\treturn ttpci_budget_debiwrite(&budget_ci->budget, DEBICICAM,\n\t\t\t\t      DEBIADDR_ATTR | (address & 0xfff), 1, value, 1, 0);\n}\n\nstatic int ciintf_read_cam_control(struct dvb_ca_en50221 *ca, int slot, u8 address)\n{\n\tstruct budget_ci *budget_ci = ca->data;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\treturn ttpci_budget_debiread(&budget_ci->budget, DEBICICAM,\n\t\t\t\t     DEBIADDR_IO | (address & 3), 1, 1, 0);\n}\n\nstatic int ciintf_write_cam_control(struct dvb_ca_en50221 *ca, int slot, u8 address, u8 value)\n{\n\tstruct budget_ci *budget_ci = ca->data;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\treturn ttpci_budget_debiwrite(&budget_ci->budget, DEBICICAM,\n\t\t\t\t      DEBIADDR_IO | (address & 3), 1, value, 1, 0);\n}\n\nstatic int ciintf_slot_reset(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct budget_ci *budget_ci = ca->data;\n\tstruct saa7146_dev *saa = budget_ci->budget.dev;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tif (budget_ci->ci_irq) {\n\t\t\n\t\tsaa7146_setgpio(saa, 0, SAA7146_GPIO_IRQHI);\n\t}\n\tbudget_ci->slot_status = SLOTSTATUS_RESET;\n\tttpci_budget_debiwrite(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1, 0, 1, 0);\n\tmsleep(1);\n\tttpci_budget_debiwrite(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1,\n\t\t\t       CICONTROL_RESET, 1, 0);\n\n\tsaa7146_setgpio(saa, 1, SAA7146_GPIO_OUTHI);\n\tttpci_budget_set_video_port(saa, BUDGET_VIDEO_PORTB);\n\treturn 0;\n}\n\nstatic int ciintf_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct budget_ci *budget_ci = ca->data;\n\tstruct saa7146_dev *saa = budget_ci->budget.dev;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tsaa7146_setgpio(saa, 1, SAA7146_GPIO_OUTHI);\n\tttpci_budget_set_video_port(saa, BUDGET_VIDEO_PORTB);\n\treturn 0;\n}\n\nstatic int ciintf_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct budget_ci *budget_ci = ca->data;\n\tstruct saa7146_dev *saa = budget_ci->budget.dev;\n\tint tmp;\n\n\tif (slot != 0)\n\t\treturn -EINVAL;\n\n\tsaa7146_setgpio(saa, 1, SAA7146_GPIO_OUTLO);\n\n\ttmp = ttpci_budget_debiread(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1, 1, 0);\n\tttpci_budget_debiwrite(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1,\n\t\t\t       tmp | CICONTROL_ENABLETS, 1, 0);\n\n\tttpci_budget_set_video_port(saa, BUDGET_VIDEO_PORTA);\n\treturn 0;\n}\n\nstatic void ciintf_interrupt(struct tasklet_struct *t)\n{\n\tstruct budget_ci *budget_ci = from_tasklet(budget_ci, t,\n\t\t\t\t\t\t   ciintf_irq_tasklet);\n\tstruct saa7146_dev *saa = budget_ci->budget.dev;\n\tunsigned int flags;\n\n\t\n\tif (!budget_ci->budget.ci_present)\n\t\treturn;\n\n\t\n\tflags = ttpci_budget_debiread(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1, 1, 0);\n\tif (flags & CICONTROL_CAMDETECT) {\n\n\t\t\n\t\tsaa7146_setgpio(saa, 0, SAA7146_GPIO_IRQLO);\n\n\t\tif (budget_ci->slot_status & SLOTSTATUS_NONE) {\n\t\t\t\n\t\t\tbudget_ci->slot_status = SLOTSTATUS_PRESENT;\n\t\t\tdvb_ca_en50221_camchange_irq(&budget_ci->ca, 0,\n\t\t\t\t\t\t     DVB_CA_EN50221_CAMCHANGE_INSERTED);\n\n\t\t} else if (budget_ci->slot_status & SLOTSTATUS_RESET) {\n\t\t\t\n\t\t\tbudget_ci->slot_status = SLOTSTATUS_READY;\n\t\t\tdvb_ca_en50221_camready_irq(&budget_ci->ca, 0);\n\n\t\t} else if (budget_ci->slot_status & SLOTSTATUS_READY) {\n\t\t\t\n\t\t\tdvb_ca_en50221_frda_irq(&budget_ci->ca, 0);\n\t\t}\n\t} else {\n\n\t\t\n\t\t\n\t\t\n\t\tsaa7146_setgpio(saa, 0, SAA7146_GPIO_IRQHI);\n\n\t\t\n\t\tif (budget_ci->slot_status & SLOTSTATUS_OCCUPIED) {\n\t\t\t\n\t\t\tbudget_ci->slot_status = SLOTSTATUS_NONE;\n\t\t\tdvb_ca_en50221_camchange_irq(&budget_ci->ca, 0,\n\t\t\t\t\t\t     DVB_CA_EN50221_CAMCHANGE_REMOVED);\n\t\t}\n\t}\n}\n\nstatic int ciintf_poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\n{\n\tstruct budget_ci *budget_ci = ca->data;\n\tunsigned int flags;\n\n\t\n\tif (!budget_ci->budget.ci_present)\n\t\treturn -EINVAL;\n\n\t\n\tflags = ttpci_budget_debiread(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1, 1, 0);\n\tif (flags & CICONTROL_CAMDETECT) {\n\t\t\n\t\tif (budget_ci->slot_status & SLOTSTATUS_NONE) {\n\t\t\tbudget_ci->slot_status = SLOTSTATUS_PRESENT;\n\t\t}\n\n\t\t\n\t\tif (budget_ci->slot_status & SLOTSTATUS_RESET) {\n\t\t\tif (ciintf_read_attribute_mem(ca, slot, 0) == 0x1d) {\n\t\t\t\tbudget_ci->slot_status = SLOTSTATUS_READY;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbudget_ci->slot_status = SLOTSTATUS_NONE;\n\t}\n\n\tif (budget_ci->slot_status != SLOTSTATUS_NONE) {\n\t\tif (budget_ci->slot_status & SLOTSTATUS_READY) {\n\t\t\treturn DVB_CA_EN50221_POLL_CAM_PRESENT | DVB_CA_EN50221_POLL_CAM_READY;\n\t\t}\n\t\treturn DVB_CA_EN50221_POLL_CAM_PRESENT;\n\t}\n\n\treturn 0;\n}\n\nstatic int ciintf_init(struct budget_ci *budget_ci)\n{\n\tstruct saa7146_dev *saa = budget_ci->budget.dev;\n\tint flags;\n\tint result;\n\tint ci_version;\n\tint ca_flags;\n\n\tmemset(&budget_ci->ca, 0, sizeof(struct dvb_ca_en50221));\n\n\t\n\tsaa7146_write(saa, MC1, MASK_27 | MASK_11);\n\n\t\n\tci_version = ttpci_budget_debiread(&budget_ci->budget, DEBICICTL, DEBIADDR_CIVERSION, 1, 1, 0);\n\tif ((ci_version & 0xa0) != 0xa0) {\n\t\tresult = -ENODEV;\n\t\tgoto error;\n\t}\n\n\t\n\tflags = ttpci_budget_debiread(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1, 1, 0);\n\tbudget_ci->slot_status = SLOTSTATUS_NONE;\n\tif (flags & CICONTROL_CAMDETECT)\n\t\tbudget_ci->slot_status = SLOTSTATUS_PRESENT;\n\n\t\n\tif (ci_version == 0xa2) {\n\t\tca_flags = 0;\n\t\tbudget_ci->ci_irq = 0;\n\t} else {\n\t\tca_flags = DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE |\n\t\t\t\tDVB_CA_EN50221_FLAG_IRQ_FR |\n\t\t\t\tDVB_CA_EN50221_FLAG_IRQ_DA;\n\t\tbudget_ci->ci_irq = 1;\n\t}\n\n\t\n\tbudget_ci->ca.owner = THIS_MODULE;\n\tbudget_ci->ca.read_attribute_mem = ciintf_read_attribute_mem;\n\tbudget_ci->ca.write_attribute_mem = ciintf_write_attribute_mem;\n\tbudget_ci->ca.read_cam_control = ciintf_read_cam_control;\n\tbudget_ci->ca.write_cam_control = ciintf_write_cam_control;\n\tbudget_ci->ca.slot_reset = ciintf_slot_reset;\n\tbudget_ci->ca.slot_shutdown = ciintf_slot_shutdown;\n\tbudget_ci->ca.slot_ts_enable = ciintf_slot_ts_enable;\n\tbudget_ci->ca.poll_slot_status = ciintf_poll_slot_status;\n\tbudget_ci->ca.data = budget_ci;\n\tif ((result = dvb_ca_en50221_init(&budget_ci->budget.dvb_adapter,\n\t\t\t\t\t  &budget_ci->ca,\n\t\t\t\t\t  ca_flags, 1)) != 0) {\n\t\tprintk(\"budget_ci: CI interface detected, but initialisation failed.\\n\");\n\t\tgoto error;\n\t}\n\n\t\n\tif (budget_ci->ci_irq) {\n\t\ttasklet_setup(&budget_ci->ciintf_irq_tasklet, ciintf_interrupt);\n\t\tif (budget_ci->slot_status != SLOTSTATUS_NONE) {\n\t\t\tsaa7146_setgpio(saa, 0, SAA7146_GPIO_IRQLO);\n\t\t} else {\n\t\t\tsaa7146_setgpio(saa, 0, SAA7146_GPIO_IRQHI);\n\t\t}\n\t\tSAA7146_IER_ENABLE(saa, MASK_03);\n\t}\n\n\t\n\tttpci_budget_debiwrite(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1,\n\t\t\t       CICONTROL_RESET, 1, 0);\n\n\t\n\tprintk(\"budget_ci: CI interface initialised\\n\");\n\tbudget_ci->budget.ci_present = 1;\n\n\t\n\tif (budget_ci->ci_irq) {\n\t\tflags = DVB_CA_EN50221_CAMCHANGE_REMOVED;\n\t\tif (budget_ci->slot_status != SLOTSTATUS_NONE)\n\t\t\tflags = DVB_CA_EN50221_CAMCHANGE_INSERTED;\n\t\tdvb_ca_en50221_camchange_irq(&budget_ci->ca, 0, flags);\n\t}\n\n\treturn 0;\n\nerror:\n\tsaa7146_write(saa, MC1, MASK_27);\n\treturn result;\n}\n\nstatic void ciintf_deinit(struct budget_ci *budget_ci)\n{\n\tstruct saa7146_dev *saa = budget_ci->budget.dev;\n\n\t\n\tif (budget_ci->ci_irq) {\n\t\tSAA7146_IER_DISABLE(saa, MASK_03);\n\t\tsaa7146_setgpio(saa, 0, SAA7146_GPIO_INPUT);\n\t\ttasklet_kill(&budget_ci->ciintf_irq_tasklet);\n\t}\n\n\t\n\tttpci_budget_debiwrite(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1, 0, 1, 0);\n\tmsleep(1);\n\tttpci_budget_debiwrite(&budget_ci->budget, DEBICICTL, DEBIADDR_CICONTROL, 1,\n\t\t\t       CICONTROL_RESET, 1, 0);\n\n\t\n\tsaa7146_setgpio(saa, 1, SAA7146_GPIO_INPUT);\n\n\t\n\tdvb_ca_en50221_release(&budget_ci->ca);\n\n\t\n\tsaa7146_write(saa, MC1, MASK_27);\n}\n\nstatic void budget_ci_irq(struct saa7146_dev *dev, u32 * isr)\n{\n\tstruct budget_ci *budget_ci = dev->ext_priv;\n\n\tdprintk(8, \"dev: %p, budget_ci: %p\\n\", dev, budget_ci);\n\n\tif (*isr & MASK_06)\n\t\ttasklet_schedule(&budget_ci->ir.msp430_irq_tasklet);\n\n\tif (*isr & MASK_10)\n\t\tttpci_budget_irq10_handler(dev, isr);\n\n\tif ((*isr & MASK_03) && (budget_ci->budget.ci_present) && (budget_ci->ci_irq))\n\t\ttasklet_schedule(&budget_ci->ciintf_irq_tasklet);\n}\n\nstatic u8 philips_su1278_tt_inittab[] = {\n\t0x01, 0x0f,\n\t0x02, 0x30,\n\t0x03, 0x00,\n\t0x04, 0x5b,\n\t0x05, 0x85,\n\t0x06, 0x02,\n\t0x07, 0x00,\n\t0x08, 0x02,\n\t0x09, 0x00,\n\t0x0C, 0x01,\n\t0x0D, 0x81,\n\t0x0E, 0x44,\n\t0x0f, 0x14,\n\t0x10, 0x3c,\n\t0x11, 0x84,\n\t0x12, 0xda,\n\t0x13, 0x97,\n\t0x14, 0x95,\n\t0x15, 0xc9,\n\t0x16, 0x19,\n\t0x17, 0x8c,\n\t0x18, 0x59,\n\t0x19, 0xf8,\n\t0x1a, 0xfe,\n\t0x1c, 0x7f,\n\t0x1d, 0x00,\n\t0x1e, 0x00,\n\t0x1f, 0x50,\n\t0x20, 0x00,\n\t0x21, 0x00,\n\t0x22, 0x00,\n\t0x23, 0x00,\n\t0x28, 0x00,\n\t0x29, 0x28,\n\t0x2a, 0x14,\n\t0x2b, 0x0f,\n\t0x2c, 0x09,\n\t0x2d, 0x09,\n\t0x31, 0x1f,\n\t0x32, 0x19,\n\t0x33, 0xfc,\n\t0x34, 0x93,\n\t0xff, 0xff\n};\n\nstatic int philips_su1278_tt_set_symbol_rate(struct dvb_frontend *fe, u32 srate, u32 ratio)\n{\n\tstv0299_writereg(fe, 0x0e, 0x44);\n\tif (srate >= 10000000) {\n\t\tstv0299_writereg(fe, 0x13, 0x97);\n\t\tstv0299_writereg(fe, 0x14, 0x95);\n\t\tstv0299_writereg(fe, 0x15, 0xc9);\n\t\tstv0299_writereg(fe, 0x17, 0x8c);\n\t\tstv0299_writereg(fe, 0x1a, 0xfe);\n\t\tstv0299_writereg(fe, 0x1c, 0x7f);\n\t\tstv0299_writereg(fe, 0x2d, 0x09);\n\t} else {\n\t\tstv0299_writereg(fe, 0x13, 0x99);\n\t\tstv0299_writereg(fe, 0x14, 0x8d);\n\t\tstv0299_writereg(fe, 0x15, 0xce);\n\t\tstv0299_writereg(fe, 0x17, 0x43);\n\t\tstv0299_writereg(fe, 0x1a, 0x1d);\n\t\tstv0299_writereg(fe, 0x1c, 0x12);\n\t\tstv0299_writereg(fe, 0x2d, 0x05);\n\t}\n\tstv0299_writereg(fe, 0x0e, 0x23);\n\tstv0299_writereg(fe, 0x0f, 0x94);\n\tstv0299_writereg(fe, 0x10, 0x39);\n\tstv0299_writereg(fe, 0x15, 0xc9);\n\n\tstv0299_writereg(fe, 0x1f, (ratio >> 16) & 0xff);\n\tstv0299_writereg(fe, 0x20, (ratio >> 8) & 0xff);\n\tstv0299_writereg(fe, 0x21, (ratio) & 0xf0);\n\n\treturn 0;\n}\n\nstatic int philips_su1278_tt_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct budget_ci *budget_ci = fe->dvb->priv;\n\tu32 div;\n\tu8 buf[4];\n\tstruct i2c_msg msg = {.addr = 0x60,.flags = 0,.buf = buf,.len = sizeof(buf) };\n\n\tif ((p->frequency < 950000) || (p->frequency > 2150000))\n\t\treturn -EINVAL;\n\n\tdiv = (p->frequency + (500 - 1)) / 500;\t \n\tbuf[0] = (div >> 8) & 0x7f;\n\tbuf[1] = div & 0xff;\n\tbuf[2] = 0x80 | ((div & 0x18000) >> 10) | 2;\n\tbuf[3] = 0x20;\n\n\tif (p->symbol_rate < 4000000)\n\t\tbuf[3] |= 1;\n\n\tif (p->frequency < 1250000)\n\t\tbuf[3] |= 0;\n\telse if (p->frequency < 1550000)\n\t\tbuf[3] |= 0x40;\n\telse if (p->frequency < 2050000)\n\t\tbuf[3] |= 0x80;\n\telse if (p->frequency < 2150000)\n\t\tbuf[3] |= 0xC0;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&budget_ci->budget.i2c_adap, &msg, 1) != 1)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic const struct stv0299_config philips_su1278_tt_config = {\n\n\t.demod_address = 0x68,\n\t.inittab = philips_su1278_tt_inittab,\n\t.mclk = 64000000UL,\n\t.invert = 0,\n\t.skip_reinit = 1,\n\t.lock_output = STV0299_LOCKOUTPUT_1,\n\t.volt13_op0_op1 = STV0299_VOLT13_OP1,\n\t.min_delay_ms = 50,\n\t.set_symbol_rate = philips_su1278_tt_set_symbol_rate,\n};\n\n\n\nstatic int philips_tdm1316l_tuner_init(struct dvb_frontend *fe)\n{\n\tstruct budget_ci *budget_ci = fe->dvb->priv;\n\tstatic u8 td1316_init[] = { 0x0b, 0xf5, 0x85, 0xab };\n\tstatic u8 disable_mc44BC374c[] = { 0x1d, 0x74, 0xa0, 0x68 };\n\tstruct i2c_msg tuner_msg = {.addr = budget_ci->tuner_pll_address,.flags = 0,.buf = td1316_init,.len =\n\t\t\tsizeof(td1316_init) };\n\n\t\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&budget_ci->budget.i2c_adap, &tuner_msg, 1) != 1)\n\t\treturn -EIO;\n\tmsleep(1);\n\n\t\n\ttuner_msg.addr = 0x65;\n\ttuner_msg.buf = disable_mc44BC374c;\n\ttuner_msg.len = sizeof(disable_mc44BC374c);\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&budget_ci->budget.i2c_adap, &tuner_msg, 1) != 1) {\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\t\ti2c_transfer(&budget_ci->budget.i2c_adap, &tuner_msg, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int philips_tdm1316l_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct budget_ci *budget_ci = fe->dvb->priv;\n\tu8 tuner_buf[4];\n\tstruct i2c_msg tuner_msg = {.addr = budget_ci->tuner_pll_address,.flags = 0,.buf = tuner_buf,.len = sizeof(tuner_buf) };\n\tint tuner_frequency = 0;\n\tu8 band, cp, filter;\n\n\t\n\ttuner_frequency = p->frequency + 36130000;\n\tif (tuner_frequency < 87000000)\n\t\treturn -EINVAL;\n\telse if (tuner_frequency < 130000000)\n\t\tcp = 3;\n\telse if (tuner_frequency < 160000000)\n\t\tcp = 5;\n\telse if (tuner_frequency < 200000000)\n\t\tcp = 6;\n\telse if (tuner_frequency < 290000000)\n\t\tcp = 3;\n\telse if (tuner_frequency < 420000000)\n\t\tcp = 5;\n\telse if (tuner_frequency < 480000000)\n\t\tcp = 6;\n\telse if (tuner_frequency < 620000000)\n\t\tcp = 3;\n\telse if (tuner_frequency < 830000000)\n\t\tcp = 5;\n\telse if (tuner_frequency < 895000000)\n\t\tcp = 7;\n\telse\n\t\treturn -EINVAL;\n\n\t\n\tif (p->frequency < 49000000)\n\t\treturn -EINVAL;\n\telse if (p->frequency < 159000000)\n\t\tband = 1;\n\telse if (p->frequency < 444000000)\n\t\tband = 2;\n\telse if (p->frequency < 861000000)\n\t\tband = 4;\n\telse\n\t\treturn -EINVAL;\n\n\t\n\tswitch (p->bandwidth_hz) {\n\tcase 6000000:\n\t\ttda1004x_writereg(fe, 0x0C, 0x14);\n\t\tfilter = 0;\n\t\tbreak;\n\n\tcase 7000000:\n\t\ttda1004x_writereg(fe, 0x0C, 0x80);\n\t\tfilter = 0;\n\t\tbreak;\n\n\tcase 8000000:\n\t\ttda1004x_writereg(fe, 0x0C, 0x14);\n\t\tfilter = 1;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t\n\t\n\ttuner_frequency = (((p->frequency / 1000) * 6) + 217280) / 1000;\n\n\t\n\ttuner_buf[0] = tuner_frequency >> 8;\n\ttuner_buf[1] = tuner_frequency & 0xff;\n\ttuner_buf[2] = 0xca;\n\ttuner_buf[3] = (cp << 5) | (filter << 3) | band;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&budget_ci->budget.i2c_adap, &tuner_msg, 1) != 1)\n\t\treturn -EIO;\n\n\tmsleep(1);\n\treturn 0;\n}\n\nstatic int philips_tdm1316l_request_firmware(struct dvb_frontend *fe,\n\t\t\t\t\t     const struct firmware **fw, char *name)\n{\n\tstruct budget_ci *budget_ci = fe->dvb->priv;\n\n\treturn request_firmware(fw, name, &budget_ci->budget.dev->pci->dev);\n}\n\nstatic struct tda1004x_config philips_tdm1316l_config = {\n\n\t.demod_address = 0x8,\n\t.invert = 0,\n\t.invert_oclk = 0,\n\t.xtal_freq = TDA10046_XTAL_4M,\n\t.agc_config = TDA10046_AGC_DEFAULT,\n\t.if_freq = TDA10046_FREQ_3617,\n\t.request_firmware = philips_tdm1316l_request_firmware,\n};\n\nstatic struct tda1004x_config philips_tdm1316l_config_invert = {\n\n\t.demod_address = 0x8,\n\t.invert = 1,\n\t.invert_oclk = 0,\n\t.xtal_freq = TDA10046_XTAL_4M,\n\t.agc_config = TDA10046_AGC_DEFAULT,\n\t.if_freq = TDA10046_FREQ_3617,\n\t.request_firmware = philips_tdm1316l_request_firmware,\n};\n\nstatic int dvbc_philips_tdm1316l_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct budget_ci *budget_ci = fe->dvb->priv;\n\tu8 tuner_buf[5];\n\tstruct i2c_msg tuner_msg = {.addr = budget_ci->tuner_pll_address,\n\t\t\t\t    .flags = 0,\n\t\t\t\t    .buf = tuner_buf,\n\t\t\t\t    .len = sizeof(tuner_buf) };\n\tint tuner_frequency = 0;\n\tu8 band, cp, filter;\n\n\t\n\ttuner_frequency = p->frequency + 36125000;\n\tif (tuner_frequency < 87000000)\n\t\treturn -EINVAL;\n\telse if (tuner_frequency < 130000000) {\n\t\tcp = 3;\n\t\tband = 1;\n\t} else if (tuner_frequency < 160000000) {\n\t\tcp = 5;\n\t\tband = 1;\n\t} else if (tuner_frequency < 200000000) {\n\t\tcp = 6;\n\t\tband = 1;\n\t} else if (tuner_frequency < 290000000) {\n\t\tcp = 3;\n\t\tband = 2;\n\t} else if (tuner_frequency < 420000000) {\n\t\tcp = 5;\n\t\tband = 2;\n\t} else if (tuner_frequency < 480000000) {\n\t\tcp = 6;\n\t\tband = 2;\n\t} else if (tuner_frequency < 620000000) {\n\t\tcp = 3;\n\t\tband = 4;\n\t} else if (tuner_frequency < 830000000) {\n\t\tcp = 5;\n\t\tband = 4;\n\t} else if (tuner_frequency < 895000000) {\n\t\tcp = 7;\n\t\tband = 4;\n\t} else\n\t\treturn -EINVAL;\n\n\t\n\tfilter = 1;\n\n\t\n\ttuner_frequency = (p->frequency + 36125000 + (62500/2)) / 62500;\n\n\t\n\ttuner_buf[0] = tuner_frequency >> 8;\n\ttuner_buf[1] = tuner_frequency & 0xff;\n\ttuner_buf[2] = 0xc8;\n\ttuner_buf[3] = (cp << 5) | (filter << 3) | band;\n\ttuner_buf[4] = 0x80;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&budget_ci->budget.i2c_adap, &tuner_msg, 1) != 1)\n\t\treturn -EIO;\n\n\tmsleep(50);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer(&budget_ci->budget.i2c_adap, &tuner_msg, 1) != 1)\n\t\treturn -EIO;\n\n\tmsleep(1);\n\n\treturn 0;\n}\n\nstatic u8 dvbc_philips_tdm1316l_inittab[] = {\n\t0x80, 0x01,\n\t0x80, 0x00,\n\t0x81, 0x01,\n\t0x81, 0x00,\n\t0x00, 0x09,\n\t0x01, 0x69,\n\t0x03, 0x00,\n\t0x04, 0x00,\n\t0x07, 0x00,\n\t0x08, 0x00,\n\t0x20, 0x00,\n\t0x21, 0x40,\n\t0x22, 0x00,\n\t0x23, 0x00,\n\t0x24, 0x40,\n\t0x25, 0x88,\n\t0x30, 0xff,\n\t0x31, 0x00,\n\t0x32, 0xff,\n\t0x33, 0x00,\n\t0x34, 0x50,\n\t0x35, 0x7f,\n\t0x36, 0x00,\n\t0x37, 0x20,\n\t0x38, 0x00,\n\t0x40, 0x1c,\n\t0x41, 0xff,\n\t0x42, 0x29,\n\t0x43, 0x20,\n\t0x44, 0xff,\n\t0x45, 0x00,\n\t0x46, 0x00,\n\t0x49, 0x04,\n\t0x4a, 0x00,\n\t0x4b, 0x7b,\n\t0x52, 0x30,\n\t0x55, 0xae,\n\t0x56, 0x47,\n\t0x57, 0xe1,\n\t0x58, 0x3a,\n\t0x5a, 0x1e,\n\t0x5b, 0x34,\n\t0x60, 0x00,\n\t0x63, 0x00,\n\t0x64, 0x00,\n\t0x65, 0x00,\n\t0x66, 0x00,\n\t0x67, 0x00,\n\t0x68, 0x00,\n\t0x69, 0x00,\n\t0x6a, 0x02,\n\t0x6b, 0x00,\n\t0x70, 0xff,\n\t0x71, 0x00,\n\t0x72, 0x00,\n\t0x73, 0x00,\n\t0x74, 0x0c,\n\t0x80, 0x00,\n\t0x81, 0x00,\n\t0x82, 0x00,\n\t0x83, 0x00,\n\t0x84, 0x04,\n\t0x85, 0x80,\n\t0x86, 0x24,\n\t0x87, 0x78,\n\t0x88, 0x10,\n\t0x89, 0x00,\n\t0x90, 0x01,\n\t0x91, 0x01,\n\t0xa0, 0x04,\n\t0xa1, 0x00,\n\t0xa2, 0x00,\n\t0xb0, 0x91,\n\t0xb1, 0x0b,\n\t0xc0, 0x53,\n\t0xc1, 0x70,\n\t0xc2, 0x12,\n\t0xd0, 0x00,\n\t0xd1, 0x00,\n\t0xd2, 0x00,\n\t0xd3, 0x00,\n\t0xd4, 0x00,\n\t0xd5, 0x00,\n\t0xde, 0x00,\n\t0xdf, 0x00,\n\t0x61, 0x38,\n\t0x62, 0x0a,\n\t0x53, 0x13,\n\t0x59, 0x08,\n\t0xff, 0xff,\n};\n\nstatic struct stv0297_config dvbc_philips_tdm1316l_config = {\n\t.demod_address = 0x1c,\n\t.inittab = dvbc_philips_tdm1316l_inittab,\n\t.invert = 0,\n\t.stop_during_read = 1,\n};\n\nstatic struct tda10023_config tda10023_config = {\n\t.demod_address = 0xc,\n\t.invert = 0,\n\t.xtal = 16000000,\n\t.pll_m = 11,\n\t.pll_p = 3,\n\t.pll_n = 1,\n\t.deltaf = 0xa511,\n};\n\nstatic struct tda827x_config tda827x_config = {\n\t.config = 0,\n};\n\n \nstatic const struct stb0899_s1_reg tt3200_stb0899_s1_init_1[] = {\n\n\t{ STB0899_DEV_ID\t\t, 0x81 },\n\t{ STB0899_DISCNTRL1\t\t, 0x32 },\n\t{ STB0899_DISCNTRL2\t\t, 0x80 },\n\t{ STB0899_DISRX_ST0\t\t, 0x04 },\n\t{ STB0899_DISRX_ST1\t\t, 0x00 },\n\t{ STB0899_DISPARITY\t\t, 0x00 },\n\t{ STB0899_DISSTATUS\t\t, 0x20 },\n\t{ STB0899_DISF22\t\t, 0x8c },\n\t{ STB0899_DISF22RX\t\t, 0x9a },\n\t{ STB0899_SYSREG\t\t, 0x0b },\n\t{ STB0899_ACRPRESC\t\t, 0x11 },\n\t{ STB0899_ACRDIV1\t\t, 0x0a },\n\t{ STB0899_ACRDIV2\t\t, 0x05 },\n\t{ STB0899_DACR1\t\t\t, 0x00 },\n\t{ STB0899_DACR2\t\t\t, 0x00 },\n\t{ STB0899_OUTCFG\t\t, 0x00 },\n\t{ STB0899_MODECFG\t\t, 0x00 },\n\t{ STB0899_IRQSTATUS_3\t\t, 0x30 },\n\t{ STB0899_IRQSTATUS_2\t\t, 0x00 },\n\t{ STB0899_IRQSTATUS_1\t\t, 0x00 },\n\t{ STB0899_IRQSTATUS_0\t\t, 0x00 },\n\t{ STB0899_IRQMSK_3\t\t, 0xf3 },\n\t{ STB0899_IRQMSK_2\t\t, 0xfc },\n\t{ STB0899_IRQMSK_1\t\t, 0xff },\n\t{ STB0899_IRQMSK_0\t\t, 0xff },\n\t{ STB0899_IRQCFG\t\t, 0x00 },\n\t{ STB0899_I2CCFG\t\t, 0x88 },\n\t{ STB0899_I2CRPT\t\t, 0x48 },  \n\t{ STB0899_IOPVALUE5\t\t, 0x00 },\n\t{ STB0899_IOPVALUE4\t\t, 0x20 },\n\t{ STB0899_IOPVALUE3\t\t, 0xc9 },\n\t{ STB0899_IOPVALUE2\t\t, 0x90 },\n\t{ STB0899_IOPVALUE1\t\t, 0x40 },\n\t{ STB0899_IOPVALUE0\t\t, 0x00 },\n\t{ STB0899_GPIO00CFG\t\t, 0x82 },\n\t{ STB0899_GPIO01CFG\t\t, 0x82 },\n\t{ STB0899_GPIO02CFG\t\t, 0x82 },\n\t{ STB0899_GPIO03CFG\t\t, 0x82 },\n\t{ STB0899_GPIO04CFG\t\t, 0x82 },\n\t{ STB0899_GPIO05CFG\t\t, 0x82 },\n\t{ STB0899_GPIO06CFG\t\t, 0x82 },\n\t{ STB0899_GPIO07CFG\t\t, 0x82 },\n\t{ STB0899_GPIO08CFG\t\t, 0x82 },\n\t{ STB0899_GPIO09CFG\t\t, 0x82 },\n\t{ STB0899_GPIO10CFG\t\t, 0x82 },\n\t{ STB0899_GPIO11CFG\t\t, 0x82 },\n\t{ STB0899_GPIO12CFG\t\t, 0x82 },\n\t{ STB0899_GPIO13CFG\t\t, 0x82 },\n\t{ STB0899_GPIO14CFG\t\t, 0x82 },\n\t{ STB0899_GPIO15CFG\t\t, 0x82 },\n\t{ STB0899_GPIO16CFG\t\t, 0x82 },\n\t{ STB0899_GPIO17CFG\t\t, 0x82 },\n\t{ STB0899_GPIO18CFG\t\t, 0x82 },\n\t{ STB0899_GPIO19CFG\t\t, 0x82 },\n\t{ STB0899_GPIO20CFG\t\t, 0x82 },\n\t{ STB0899_SDATCFG\t\t, 0xb8 },\n\t{ STB0899_SCLTCFG\t\t, 0xba },\n\t{ STB0899_AGCRFCFG\t\t, 0x1c },  \n\t{ STB0899_GPIO22\t\t, 0x82 },  \n\t{ STB0899_GPIO21\t\t, 0x91 },  \n\t{ STB0899_DIRCLKCFG\t\t, 0x82 },\n\t{ STB0899_CLKOUT27CFG\t\t, 0x7e },\n\t{ STB0899_STDBYCFG\t\t, 0x82 },\n\t{ STB0899_CS0CFG\t\t, 0x82 },\n\t{ STB0899_CS1CFG\t\t, 0x82 },\n\t{ STB0899_DISEQCOCFG\t\t, 0x20 },\n\t{ STB0899_GPIO32CFG\t\t, 0x82 },\n\t{ STB0899_GPIO33CFG\t\t, 0x82 },\n\t{ STB0899_GPIO34CFG\t\t, 0x82 },\n\t{ STB0899_GPIO35CFG\t\t, 0x82 },\n\t{ STB0899_GPIO36CFG\t\t, 0x82 },\n\t{ STB0899_GPIO37CFG\t\t, 0x82 },\n\t{ STB0899_GPIO38CFG\t\t, 0x82 },\n\t{ STB0899_GPIO39CFG\t\t, 0x82 },\n\t{ STB0899_NCOARSE\t\t, 0x15 },  \n\t{ STB0899_SYNTCTRL\t\t, 0x02 },  \n\t{ STB0899_FILTCTRL\t\t, 0x00 },\n\t{ STB0899_SYSCTRL\t\t, 0x00 },\n\t{ STB0899_STOPCLK1\t\t, 0x20 },\n\t{ STB0899_STOPCLK2\t\t, 0x00 },\n\t{ STB0899_INTBUFSTATUS\t\t, 0x00 },\n\t{ STB0899_INTBUFCTRL\t\t, 0x0a },\n\t{ 0xffff\t\t\t, 0xff },\n};\n\nstatic const struct stb0899_s1_reg tt3200_stb0899_s1_init_3[] = {\n\t{ STB0899_DEMOD\t\t\t, 0x00 },\n\t{ STB0899_RCOMPC\t\t, 0xc9 },\n\t{ STB0899_AGC1CN\t\t, 0x41 },\n\t{ STB0899_AGC1REF\t\t, 0x10 },\n\t{ STB0899_RTC\t\t\t, 0x7a },\n\t{ STB0899_TMGCFG\t\t, 0x4e },\n\t{ STB0899_AGC2REF\t\t, 0x34 },\n\t{ STB0899_TLSR\t\t\t, 0x84 },\n\t{ STB0899_CFD\t\t\t, 0xc7 },\n\t{ STB0899_ACLC\t\t\t, 0x87 },\n\t{ STB0899_BCLC\t\t\t, 0x94 },\n\t{ STB0899_EQON\t\t\t, 0x41 },\n\t{ STB0899_LDT\t\t\t, 0xdd },\n\t{ STB0899_LDT2\t\t\t, 0xc9 },\n\t{ STB0899_EQUALREF\t\t, 0xb4 },\n\t{ STB0899_TMGRAMP\t\t, 0x10 },\n\t{ STB0899_TMGTHD\t\t, 0x30 },\n\t{ STB0899_IDCCOMP\t\t, 0xfb },\n\t{ STB0899_QDCCOMP\t\t, 0x03 },\n\t{ STB0899_POWERI\t\t, 0x3b },\n\t{ STB0899_POWERQ\t\t, 0x3d },\n\t{ STB0899_RCOMP\t\t\t, 0x81 },\n\t{ STB0899_AGCIQIN\t\t, 0x80 },\n\t{ STB0899_AGC2I1\t\t, 0x04 },\n\t{ STB0899_AGC2I2\t\t, 0xf5 },\n\t{ STB0899_TLIR\t\t\t, 0x25 },\n\t{ STB0899_RTF\t\t\t, 0x80 },\n\t{ STB0899_DSTATUS\t\t, 0x00 },\n\t{ STB0899_LDI\t\t\t, 0xca },\n\t{ STB0899_CFRM\t\t\t, 0xf1 },\n\t{ STB0899_CFRL\t\t\t, 0xf3 },\n\t{ STB0899_NIRM\t\t\t, 0x2a },\n\t{ STB0899_NIRL\t\t\t, 0x05 },\n\t{ STB0899_ISYMB\t\t\t, 0x17 },\n\t{ STB0899_QSYMB\t\t\t, 0xfa },\n\t{ STB0899_SFRH\t\t\t, 0x2f },\n\t{ STB0899_SFRM\t\t\t, 0x68 },\n\t{ STB0899_SFRL\t\t\t, 0x40 },\n\t{ STB0899_SFRUPH\t\t, 0x2f },\n\t{ STB0899_SFRUPM\t\t, 0x68 },\n\t{ STB0899_SFRUPL\t\t, 0x40 },\n\t{ STB0899_EQUAI1\t\t, 0xfd },\n\t{ STB0899_EQUAQ1\t\t, 0x04 },\n\t{ STB0899_EQUAI2\t\t, 0x0f },\n\t{ STB0899_EQUAQ2\t\t, 0xff },\n\t{ STB0899_EQUAI3\t\t, 0xdf },\n\t{ STB0899_EQUAQ3\t\t, 0xfa },\n\t{ STB0899_EQUAI4\t\t, 0x37 },\n\t{ STB0899_EQUAQ4\t\t, 0x0d },\n\t{ STB0899_EQUAI5\t\t, 0xbd },\n\t{ STB0899_EQUAQ5\t\t, 0xf7 },\n\t{ STB0899_DSTATUS2\t\t, 0x00 },\n\t{ STB0899_VSTATUS\t\t, 0x00 },\n\t{ STB0899_VERROR\t\t, 0xff },\n\t{ STB0899_IQSWAP\t\t, 0x2a },\n\t{ STB0899_ECNT1M\t\t, 0x00 },\n\t{ STB0899_ECNT1L\t\t, 0x00 },\n\t{ STB0899_ECNT2M\t\t, 0x00 },\n\t{ STB0899_ECNT2L\t\t, 0x00 },\n\t{ STB0899_ECNT3M\t\t, 0x00 },\n\t{ STB0899_ECNT3L\t\t, 0x00 },\n\t{ STB0899_FECAUTO1\t\t, 0x06 },\n\t{ STB0899_FECM\t\t\t, 0x01 },\n\t{ STB0899_VTH12\t\t\t, 0xf0 },\n\t{ STB0899_VTH23\t\t\t, 0xa0 },\n\t{ STB0899_VTH34\t\t\t, 0x78 },\n\t{ STB0899_VTH56\t\t\t, 0x4e },\n\t{ STB0899_VTH67\t\t\t, 0x48 },\n\t{ STB0899_VTH78\t\t\t, 0x38 },\n\t{ STB0899_PRVIT\t\t\t, 0xff },\n\t{ STB0899_VITSYNC\t\t, 0x19 },\n\t{ STB0899_RSULC\t\t\t, 0xb1 },  \n\t{ STB0899_TSULC\t\t\t, 0x42 },\n\t{ STB0899_RSLLC\t\t\t, 0x40 },\n\t{ STB0899_TSLPL\t\t\t, 0x12 },\n\t{ STB0899_TSCFGH\t\t, 0x0c },\n\t{ STB0899_TSCFGM\t\t, 0x00 },\n\t{ STB0899_TSCFGL\t\t, 0x0c },\n\t{ STB0899_TSOUT\t\t\t, 0x4d },  \n\t{ STB0899_RSSYNCDEL\t\t, 0x00 },\n\t{ STB0899_TSINHDELH\t\t, 0x02 },\n\t{ STB0899_TSINHDELM\t\t, 0x00 },\n\t{ STB0899_TSINHDELL\t\t, 0x00 },\n\t{ STB0899_TSLLSTKM\t\t, 0x00 },\n\t{ STB0899_TSLLSTKL\t\t, 0x00 },\n\t{ STB0899_TSULSTKM\t\t, 0x00 },\n\t{ STB0899_TSULSTKL\t\t, 0xab },\n\t{ STB0899_PCKLENUL\t\t, 0x00 },\n\t{ STB0899_PCKLENLL\t\t, 0xcc },\n\t{ STB0899_RSPCKLEN\t\t, 0xcc },\n\t{ STB0899_TSSTATUS\t\t, 0x80 },\n\t{ STB0899_ERRCTRL1\t\t, 0xb6 },\n\t{ STB0899_ERRCTRL2\t\t, 0x96 },\n\t{ STB0899_ERRCTRL3\t\t, 0x89 },\n\t{ STB0899_DMONMSK1\t\t, 0x27 },\n\t{ STB0899_DMONMSK0\t\t, 0x03 },\n\t{ STB0899_DEMAPVIT\t\t, 0x5c },\n\t{ STB0899_PLPARM\t\t, 0x1f },\n\t{ STB0899_PDELCTRL\t\t, 0x48 },\n\t{ STB0899_PDELCTRL2\t\t, 0x00 },\n\t{ STB0899_BBHCTRL1\t\t, 0x00 },\n\t{ STB0899_BBHCTRL2\t\t, 0x00 },\n\t{ STB0899_HYSTTHRESH\t\t, 0x77 },\n\t{ STB0899_MATCSTM\t\t, 0x00 },\n\t{ STB0899_MATCSTL\t\t, 0x00 },\n\t{ STB0899_UPLCSTM\t\t, 0x00 },\n\t{ STB0899_UPLCSTL\t\t, 0x00 },\n\t{ STB0899_DFLCSTM\t\t, 0x00 },\n\t{ STB0899_DFLCSTL\t\t, 0x00 },\n\t{ STB0899_SYNCCST\t\t, 0x00 },\n\t{ STB0899_SYNCDCSTM\t\t, 0x00 },\n\t{ STB0899_SYNCDCSTL\t\t, 0x00 },\n\t{ STB0899_ISI_ENTRY\t\t, 0x00 },\n\t{ STB0899_ISI_BIT_EN\t\t, 0x00 },\n\t{ STB0899_MATSTRM\t\t, 0x00 },\n\t{ STB0899_MATSTRL\t\t, 0x00 },\n\t{ STB0899_UPLSTRM\t\t, 0x00 },\n\t{ STB0899_UPLSTRL\t\t, 0x00 },\n\t{ STB0899_DFLSTRM\t\t, 0x00 },\n\t{ STB0899_DFLSTRL\t\t, 0x00 },\n\t{ STB0899_SYNCSTR\t\t, 0x00 },\n\t{ STB0899_SYNCDSTRM\t\t, 0x00 },\n\t{ STB0899_SYNCDSTRL\t\t, 0x00 },\n\t{ STB0899_CFGPDELSTATUS1\t, 0x10 },\n\t{ STB0899_CFGPDELSTATUS2\t, 0x00 },\n\t{ STB0899_BBFERRORM\t\t, 0x00 },\n\t{ STB0899_BBFERRORL\t\t, 0x00 },\n\t{ STB0899_UPKTERRORM\t\t, 0x00 },\n\t{ STB0899_UPKTERRORL\t\t, 0x00 },\n\t{ 0xffff\t\t\t, 0xff },\n};\n\nstatic struct stb0899_config tt3200_config = {\n\t.init_dev\t\t= tt3200_stb0899_s1_init_1,\n\t.init_s2_demod\t\t= stb0899_s2_init_2,\n\t.init_s1_demod\t\t= tt3200_stb0899_s1_init_3,\n\t.init_s2_fec\t\t= stb0899_s2_init_4,\n\t.init_tst\t\t= stb0899_s1_init_5,\n\n\t.postproc\t\t= NULL,\n\n\t.demod_address\t\t= 0x68,\n\n\t.xtal_freq\t\t= 27000000,\n\t.inversion\t\t= IQ_SWAP_ON,\n\n\t.lo_clk\t\t\t= 76500000,\n\t.hi_clk\t\t\t= 99000000,\n\n\t.esno_ave\t\t= STB0899_DVBS2_ESNO_AVE,\n\t.esno_quant\t\t= STB0899_DVBS2_ESNO_QUANT,\n\t.avframes_coarse\t= STB0899_DVBS2_AVFRAMES_COARSE,\n\t.avframes_fine\t\t= STB0899_DVBS2_AVFRAMES_FINE,\n\t.miss_threshold\t\t= STB0899_DVBS2_MISS_THRESHOLD,\n\t.uwp_threshold_acq\t= STB0899_DVBS2_UWP_THRESHOLD_ACQ,\n\t.uwp_threshold_track\t= STB0899_DVBS2_UWP_THRESHOLD_TRACK,\n\t.uwp_threshold_sof\t= STB0899_DVBS2_UWP_THRESHOLD_SOF,\n\t.sof_search_timeout\t= STB0899_DVBS2_SOF_SEARCH_TIMEOUT,\n\n\t.btr_nco_bits\t\t= STB0899_DVBS2_BTR_NCO_BITS,\n\t.btr_gain_shift_offset\t= STB0899_DVBS2_BTR_GAIN_SHIFT_OFFSET,\n\t.crl_nco_bits\t\t= STB0899_DVBS2_CRL_NCO_BITS,\n\t.ldpc_max_iter\t\t= STB0899_DVBS2_LDPC_MAX_ITER,\n\n\t.tuner_get_frequency\t= stb6100_get_frequency,\n\t.tuner_set_frequency\t= stb6100_set_frequency,\n\t.tuner_set_bandwidth\t= stb6100_set_bandwidth,\n\t.tuner_get_bandwidth\t= stb6100_get_bandwidth,\n\t.tuner_set_rfsiggain\t= NULL\n};\n\nstatic struct stb6100_config tt3200_stb6100_config = {\n\t.tuner_address\t= 0x60,\n\t.refclock\t= 27000000,\n};\n\nstatic void frontend_init(struct budget_ci *budget_ci)\n{\n\tswitch (budget_ci->budget.dev->pci->subsystem_device) {\n\tcase 0x100c:\t\t\n\t\tbudget_ci->budget.dvb_frontend =\n\t\t\tdvb_attach(stv0299_attach, &alps_bsru6_config, &budget_ci->budget.i2c_adap);\n\t\tif (budget_ci->budget.dvb_frontend) {\n\t\t\tbudget_ci->budget.dvb_frontend->ops.tuner_ops.set_params = alps_bsru6_tuner_set_params;\n\t\t\tbudget_ci->budget.dvb_frontend->tuner_priv = &budget_ci->budget.i2c_adap;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x100f:\t\t\n\t\tbudget_ci->budget.dvb_frontend =\n\t\t\tdvb_attach(stv0299_attach, &philips_su1278_tt_config, &budget_ci->budget.i2c_adap);\n\t\tif (budget_ci->budget.dvb_frontend) {\n\t\t\tbudget_ci->budget.dvb_frontend->ops.tuner_ops.set_params = philips_su1278_tt_tuner_set_params;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1010:\t\t\n\t\tbudget_ci->tuner_pll_address = 0x61;\n\t\tbudget_ci->budget.dvb_frontend =\n\t\t\tdvb_attach(stv0297_attach, &dvbc_philips_tdm1316l_config, &budget_ci->budget.i2c_adap);\n\t\tif (budget_ci->budget.dvb_frontend) {\n\t\t\tbudget_ci->budget.dvb_frontend->ops.tuner_ops.set_params = dvbc_philips_tdm1316l_tuner_set_params;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1011:\t\t\n\t\tbudget_ci->tuner_pll_address = 0x63;\n\t\tbudget_ci->budget.dvb_frontend =\n\t\t\tdvb_attach(tda10045_attach, &philips_tdm1316l_config, &budget_ci->budget.i2c_adap);\n\t\tif (budget_ci->budget.dvb_frontend) {\n\t\t\tbudget_ci->budget.dvb_frontend->ops.tuner_ops.init = philips_tdm1316l_tuner_init;\n\t\t\tbudget_ci->budget.dvb_frontend->ops.tuner_ops.set_params = philips_tdm1316l_tuner_set_params;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1012:\t\t\n\t\tbudget_ci->tuner_pll_address = 0x60;\n\t\tbudget_ci->budget.dvb_frontend =\n\t\t\tdvb_attach(tda10046_attach, &philips_tdm1316l_config_invert, &budget_ci->budget.i2c_adap);\n\t\tif (budget_ci->budget.dvb_frontend) {\n\t\t\tbudget_ci->budget.dvb_frontend->ops.tuner_ops.init = philips_tdm1316l_tuner_init;\n\t\t\tbudget_ci->budget.dvb_frontend->ops.tuner_ops.set_params = philips_tdm1316l_tuner_set_params;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1017:\t\t\n\t\tbudget_ci->budget.dvb_frontend = dvb_attach(stv0299_attach, &alps_bsbe1_config, &budget_ci->budget.i2c_adap);\n\t\tif (budget_ci->budget.dvb_frontend) {\n\t\t\tbudget_ci->budget.dvb_frontend->ops.tuner_ops.set_params = alps_bsbe1_tuner_set_params;\n\t\t\tbudget_ci->budget.dvb_frontend->tuner_priv = &budget_ci->budget.i2c_adap;\n\n\t\t\tbudget_ci->budget.dvb_frontend->ops.dishnetwork_send_legacy_command = NULL;\n\t\t\tif (dvb_attach(lnbp21_attach, budget_ci->budget.dvb_frontend, &budget_ci->budget.i2c_adap, LNBP21_LLC, 0) == NULL) {\n\t\t\t\tprintk(\"%s: No LNBP21 found!\\n\", __func__);\n\t\t\t\tdvb_frontend_detach(budget_ci->budget.dvb_frontend);\n\t\t\t\tbudget_ci->budget.dvb_frontend = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 0x101a:  \n\t\tbudget_ci->budget.dvb_frontend = dvb_attach(tda10023_attach, &tda10023_config, &budget_ci->budget.i2c_adap, 0x48);\n\t\tif (budget_ci->budget.dvb_frontend) {\n\t\t\tif (dvb_attach(tda827x_attach, budget_ci->budget.dvb_frontend, 0x61, &budget_ci->budget.i2c_adap, &tda827x_config) == NULL) {\n\t\t\t\tprintk(KERN_ERR \"%s: No tda827x found!\\n\", __func__);\n\t\t\t\tdvb_frontend_detach(budget_ci->budget.dvb_frontend);\n\t\t\t\tbudget_ci->budget.dvb_frontend = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 0x101b:  \n\t\tbudget_ci->budget.dvb_frontend = dvb_attach(stv0288_attach, &stv0288_bsbe1_d01a_config, &budget_ci->budget.i2c_adap);\n\t\tif (budget_ci->budget.dvb_frontend) {\n\t\t\tif (dvb_attach(stb6000_attach, budget_ci->budget.dvb_frontend, 0x63, &budget_ci->budget.i2c_adap)) {\n\t\t\t\tif (!dvb_attach(lnbp21_attach, budget_ci->budget.dvb_frontend, &budget_ci->budget.i2c_adap, 0, 0)) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: No LNBP21 found!\\n\", __func__);\n\t\t\t\t\tdvb_frontend_detach(budget_ci->budget.dvb_frontend);\n\t\t\t\t\tbudget_ci->budget.dvb_frontend = NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_ERR \"%s: No STB6000 found!\\n\", __func__);\n\t\t\t\tdvb_frontend_detach(budget_ci->budget.dvb_frontend);\n\t\t\t\tbudget_ci->budget.dvb_frontend = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 0x1019:\t\t\n\t\t \n\t\t \n\t\tsaa7146_setgpio(budget_ci->budget.dev, 2, SAA7146_GPIO_OUTLO);\n\t\t \n\t\tmsleep(50);\n\t\t \n\t\tsaa7146_setgpio(budget_ci->budget.dev, 2, SAA7146_GPIO_OUTHI);\n\t\t \n\t\tmsleep(250);\n\t\t \n\t\tbudget_ci->budget.dvb_frontend = dvb_attach(stb0899_attach, &tt3200_config, &budget_ci->budget.i2c_adap);\n\t\tif (budget_ci->budget.dvb_frontend) {\n\t\t\tif (dvb_attach(stb6100_attach, budget_ci->budget.dvb_frontend, &tt3200_stb6100_config, &budget_ci->budget.i2c_adap)) {\n\t\t\t\tif (!dvb_attach(lnbp21_attach, budget_ci->budget.dvb_frontend, &budget_ci->budget.i2c_adap, 0, 0)) {\n\t\t\t\t\tprintk(\"%s: No LNBP21 found!\\n\", __func__);\n\t\t\t\t\tdvb_frontend_detach(budget_ci->budget.dvb_frontend);\n\t\t\t\t\tbudget_ci->budget.dvb_frontend = NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t\tdvb_frontend_detach(budget_ci->budget.dvb_frontend);\n\t\t\t\t\tbudget_ci->budget.dvb_frontend = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t}\n\n\tif (budget_ci->budget.dvb_frontend == NULL) {\n\t\tprintk(\"budget-ci: A frontend driver was not found for device [%04x:%04x] subsystem [%04x:%04x]\\n\",\n\t\t       budget_ci->budget.dev->pci->vendor,\n\t\t       budget_ci->budget.dev->pci->device,\n\t\t       budget_ci->budget.dev->pci->subsystem_vendor,\n\t\t       budget_ci->budget.dev->pci->subsystem_device);\n\t} else {\n\t\tif (dvb_register_frontend\n\t\t    (&budget_ci->budget.dvb_adapter, budget_ci->budget.dvb_frontend)) {\n\t\t\tprintk(\"budget-ci: Frontend registration failed!\\n\");\n\t\t\tdvb_frontend_detach(budget_ci->budget.dvb_frontend);\n\t\t\tbudget_ci->budget.dvb_frontend = NULL;\n\t\t}\n\t}\n}\n\nstatic int budget_ci_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_data *info)\n{\n\tstruct budget_ci *budget_ci;\n\tint err;\n\n\tbudget_ci = kzalloc(sizeof(struct budget_ci), GFP_KERNEL);\n\tif (!budget_ci) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tdprintk(2, \"budget_ci: %p\\n\", budget_ci);\n\n\tdev->ext_priv = budget_ci;\n\n\terr = ttpci_budget_init(&budget_ci->budget, dev, info, THIS_MODULE,\n\t\t\t\tadapter_nr);\n\tif (err)\n\t\tgoto out2;\n\n\terr = msp430_ir_init(budget_ci);\n\tif (err)\n\t\tgoto out3;\n\n\tciintf_init(budget_ci);\n\n\tbudget_ci->budget.dvb_adapter.priv = budget_ci;\n\tfrontend_init(budget_ci);\n\n\tttpci_budget_init_hooks(&budget_ci->budget);\n\n\treturn 0;\n\nout3:\n\tttpci_budget_deinit(&budget_ci->budget);\nout2:\n\tkfree(budget_ci);\nout1:\n\treturn err;\n}\n\nstatic int budget_ci_detach(struct saa7146_dev *dev)\n{\n\tstruct budget_ci *budget_ci = dev->ext_priv;\n\tstruct saa7146_dev *saa = budget_ci->budget.dev;\n\tint err;\n\n\tif (budget_ci->budget.ci_present)\n\t\tciintf_deinit(budget_ci);\n\tmsp430_ir_deinit(budget_ci);\n\tif (budget_ci->budget.dvb_frontend) {\n\t\tdvb_unregister_frontend(budget_ci->budget.dvb_frontend);\n\t\tdvb_frontend_detach(budget_ci->budget.dvb_frontend);\n\t}\n\terr = ttpci_budget_deinit(&budget_ci->budget);\n\n\t\n\tsaa7146_setgpio(saa, 2, SAA7146_GPIO_INPUT);\n\n\tkfree(budget_ci);\n\n\treturn err;\n}\n\nstatic struct saa7146_extension budget_extension;\n\nMAKE_BUDGET_INFO(ttbs2, \"TT-Budget/S-1500 PCI\", BUDGET_TT);\nMAKE_BUDGET_INFO(ttbci, \"TT-Budget/WinTV-NOVA-CI PCI\", BUDGET_TT_HW_DISEQC);\nMAKE_BUDGET_INFO(ttbt2, \"TT-Budget/WinTV-NOVA-T\t PCI\", BUDGET_TT);\nMAKE_BUDGET_INFO(ttbtci, \"TT-Budget-T-CI PCI\", BUDGET_TT);\nMAKE_BUDGET_INFO(ttbcci, \"TT-Budget-C-CI PCI\", BUDGET_TT);\nMAKE_BUDGET_INFO(ttc1501, \"TT-Budget C-1501 PCI\", BUDGET_TT);\nMAKE_BUDGET_INFO(tt3200, \"TT-Budget S2-3200 PCI\", BUDGET_TT);\nMAKE_BUDGET_INFO(ttbs1500b, \"TT-Budget S-1500B PCI\", BUDGET_TT);\n\nstatic const struct pci_device_id pci_tbl[] = {\n\tMAKE_EXTENSION_PCI(ttbci, 0x13c2, 0x100c),\n\tMAKE_EXTENSION_PCI(ttbci, 0x13c2, 0x100f),\n\tMAKE_EXTENSION_PCI(ttbcci, 0x13c2, 0x1010),\n\tMAKE_EXTENSION_PCI(ttbt2, 0x13c2, 0x1011),\n\tMAKE_EXTENSION_PCI(ttbtci, 0x13c2, 0x1012),\n\tMAKE_EXTENSION_PCI(ttbs2, 0x13c2, 0x1017),\n\tMAKE_EXTENSION_PCI(ttc1501, 0x13c2, 0x101a),\n\tMAKE_EXTENSION_PCI(tt3200, 0x13c2, 0x1019),\n\tMAKE_EXTENSION_PCI(ttbs1500b, 0x13c2, 0x101b),\n\t{\n\t .vendor = 0,\n\t }\n};\n\nMODULE_DEVICE_TABLE(pci, pci_tbl);\n\nstatic struct saa7146_extension budget_extension = {\n\t.name = \"budget_ci dvb\",\n\t.flags = SAA7146_USE_I2C_IRQ,\n\n\t.module = THIS_MODULE,\n\t.pci_tbl = &pci_tbl[0],\n\t.attach = budget_ci_attach,\n\t.detach = budget_ci_detach,\n\n\t.irq_mask = MASK_03 | MASK_06 | MASK_10,\n\t.irq_func = budget_ci_irq,\n};\n\nstatic int __init budget_ci_init(void)\n{\n\treturn saa7146_register_extension(&budget_extension);\n}\n\nstatic void __exit budget_ci_exit(void)\n{\n\tsaa7146_unregister_extension(&budget_extension);\n}\n\nmodule_init(budget_ci_init);\nmodule_exit(budget_ci_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michael Hunold, Jack Thomasson, Andrew de Quincey, others\");\nMODULE_DESCRIPTION(\"driver for the SAA7146 based so-called budget PCI DVB cards w/ CI-module produced by Siemens, Technotrend, Hauppauge\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}