{
  "module_name": "budget.c",
  "hash_id": "1c568528c84bbf59c0bb85b2a65f0e6d3f42277df57585255ea9291f890905d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ttpci/budget.c",
  "human_readable_source": "\n \n\n#include \"budget.h\"\n#include \"stv0299.h\"\n#include \"ves1x93.h\"\n#include \"ves1820.h\"\n#include \"l64781.h\"\n#include \"tda8083.h\"\n#include \"s5h1420.h\"\n#include \"tda10086.h\"\n#include \"tda826x.h\"\n#include \"lnbp21.h\"\n#include \"bsru6.h\"\n#include \"bsbe1.h\"\n#include \"tdhd1.h\"\n#include \"stv6110x.h\"\n#include \"stv090x.h\"\n#include \"isl6423.h\"\n#include \"lnbh24.h\"\n\n\nstatic int diseqc_method;\nmodule_param(diseqc_method, int, 0444);\nMODULE_PARM_DESC(diseqc_method, \"Select DiSEqC method for subsystem id 13c2:1003, 0: default, 1: more reliable (for newer revisions only)\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic void Set22K (struct budget *budget, int state)\n{\n\tstruct saa7146_dev *dev=budget->dev;\n\tdprintk(2, \"budget: %p\\n\", budget);\n\tsaa7146_setgpio(dev, 3, (state ? SAA7146_GPIO_OUTHI : SAA7146_GPIO_OUTLO));\n}\n\n \n \n\nstatic void DiseqcSendBit (struct budget *budget, int data)\n{\n\tstruct saa7146_dev *dev=budget->dev;\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTHI);\n\tudelay(data ? 500 : 1000);\n\tsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);\n\tudelay(data ? 1000 : 500);\n}\n\nstatic void DiseqcSendByte (struct budget *budget, int data)\n{\n\tint i, par=1, d;\n\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tfor (i=7; i>=0; i--) {\n\t\td = (data>>i)&1;\n\t\tpar ^= d;\n\t\tDiseqcSendBit(budget, d);\n\t}\n\n\tDiseqcSendBit(budget, par);\n}\n\nstatic int SendDiSEqCMsg (struct budget *budget, int len, u8 *msg, unsigned long burst)\n{\n\tstruct saa7146_dev *dev=budget->dev;\n\tint i;\n\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);\n\tmdelay(16);\n\n\tfor (i=0; i<len; i++)\n\t\tDiseqcSendByte(budget, msg[i]);\n\n\tmdelay(16);\n\n\tif (burst!=-1) {\n\t\tif (burst)\n\t\t\tDiseqcSendByte(budget, 0xff);\n\t\telse {\n\t\t\tsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTHI);\n\t\t\tmdelay(12);\n\t\t\tudelay(500);\n\t\t\tsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int SetVoltage_Activy(struct budget *budget,\n\t\t\t     enum fe_sec_voltage voltage)\n{\n\tstruct saa7146_dev *dev=budget->dev;\n\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tswitch (voltage) {\n\t\tcase SEC_VOLTAGE_13:\n\t\t\tsaa7146_setgpio(dev, 1, SAA7146_GPIO_OUTHI);\n\t\t\tsaa7146_setgpio(dev, 2, SAA7146_GPIO_OUTLO);\n\t\t\tbreak;\n\t\tcase SEC_VOLTAGE_18:\n\t\t\tsaa7146_setgpio(dev, 1, SAA7146_GPIO_OUTHI);\n\t\t\tsaa7146_setgpio(dev, 2, SAA7146_GPIO_OUTHI);\n\t\t\tbreak;\n\t\tcase SEC_VOLTAGE_OFF:\n\t\t\tsaa7146_setgpio(dev, 1, SAA7146_GPIO_OUTLO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int siemens_budget_set_voltage(struct dvb_frontend *fe,\n\t\t\t\t      enum fe_sec_voltage voltage)\n{\n\tstruct budget *budget = fe->dvb->priv;\n\n\treturn SetVoltage_Activy (budget, voltage);\n}\n\nstatic int budget_set_tone(struct dvb_frontend *fe,\n\t\t\t   enum fe_sec_tone_mode tone)\n{\n\tstruct budget *budget = fe->dvb->priv;\n\n\tswitch (tone) {\n\tcase SEC_TONE_ON:\n\t\tSet22K (budget, 1);\n\t\tbreak;\n\n\tcase SEC_TONE_OFF:\n\t\tSet22K (budget, 0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int budget_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd* cmd)\n{\n\tstruct budget *budget = fe->dvb->priv;\n\n\tSendDiSEqCMsg (budget, cmd->msg_len, cmd->msg, 0);\n\n\treturn 0;\n}\n\nstatic int budget_diseqc_send_burst(struct dvb_frontend *fe,\n\t\t\t\t    enum fe_sec_mini_cmd minicmd)\n{\n\tstruct budget *budget = fe->dvb->priv;\n\n\tSendDiSEqCMsg (budget, 0, NULL, minicmd);\n\n\treturn 0;\n}\n\nstatic int alps_bsrv2_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct budget *budget = fe->dvb->priv;\n\tu8 pwr = 0;\n\tu8 buf[4];\n\tstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = buf, .len = sizeof(buf) };\n\tu32 div = (c->frequency + 479500) / 125;\n\n\tif (c->frequency > 2000000)\n\t\tpwr = 3;\n\telse if (c->frequency > 1800000)\n\t\tpwr = 2;\n\telse if (c->frequency > 1600000)\n\t\tpwr = 1;\n\telse if (c->frequency > 1200000)\n\t\tpwr = 0;\n\telse if (c->frequency >= 1100000)\n\t\tpwr = 1;\n\telse pwr = 2;\n\n\tbuf[0] = (div >> 8) & 0x7f;\n\tbuf[1] = div & 0xff;\n\tbuf[2] = ((div & 0x18000) >> 10) | 0x95;\n\tbuf[3] = (pwr << 6) | 0x30;\n\n\t \n\t\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;\n\treturn 0;\n}\n\nstatic struct ves1x93_config alps_bsrv2_config =\n{\n\t.demod_address = 0x08,\n\t.xin = 90100000UL,\n\t.invert_pwm = 0,\n};\n\nstatic int alps_tdbe2_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct budget *budget = fe->dvb->priv;\n\tu32 div;\n\tu8 data[4];\n\tstruct i2c_msg msg = { .addr = 0x62, .flags = 0, .buf = data, .len = sizeof(data) };\n\n\tdiv = (c->frequency + 35937500 + 31250) / 62500;\n\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = 0x85 | ((div >> 10) & 0x60);\n\tdata[3] = (c->frequency < 174000000 ? 0x88 : c->frequency < 470000000 ? 0x84 : 0x81);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;\n\treturn 0;\n}\n\nstatic struct ves1820_config alps_tdbe2_config = {\n\t.demod_address = 0x09,\n\t.xin = 57840000UL,\n\t.invert = 1,\n\t.selagc = VES1820_SELAGC_SIGNAMPERR,\n};\n\nstatic int grundig_29504_401_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct budget *budget = fe->dvb->priv;\n\tu8 *tuner_addr = fe->tuner_priv;\n\tu32 div;\n\tu8 cfg, cpump, band_select;\n\tu8 data[4];\n\tstruct i2c_msg msg = { .flags = 0, .buf = data, .len = sizeof(data) };\n\n\tif (tuner_addr)\n\t\tmsg.addr = *tuner_addr;\n\telse\n\t\tmsg.addr = 0x61;\n\n\tdiv = (36125000 + c->frequency) / 166666;\n\n\tcfg = 0x88;\n\n\tif (c->frequency < 175000000)\n\t\tcpump = 2;\n\telse if (c->frequency < 390000000)\n\t\tcpump = 1;\n\telse if (c->frequency < 470000000)\n\t\tcpump = 2;\n\telse if (c->frequency < 750000000)\n\t\tcpump = 1;\n\telse\n\t\tcpump = 3;\n\n\tif (c->frequency < 175000000)\n\t\tband_select = 0x0e;\n\telse if (c->frequency < 470000000)\n\t\tband_select = 0x05;\n\telse\n\t\tband_select = 0x03;\n\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = ((div >> 10) & 0x60) | cfg;\n\tdata[3] = (cpump << 6) | band_select;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;\n\treturn 0;\n}\n\nstatic struct l64781_config grundig_29504_401_config = {\n\t.demod_address = 0x55,\n};\n\nstatic struct l64781_config grundig_29504_401_config_activy = {\n\t.demod_address = 0x54,\n};\n\nstatic u8 tuner_address_grundig_29504_401_activy = 0x60;\n\nstatic int grundig_29504_451_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct budget *budget = fe->dvb->priv;\n\tu32 div;\n\tu8 data[4];\n\tstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = sizeof(data) };\n\n\tdiv = c->frequency / 125;\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = 0x8e;\n\tdata[3] = 0x00;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;\n\treturn 0;\n}\n\nstatic struct tda8083_config grundig_29504_451_config = {\n\t.demod_address = 0x68,\n};\n\nstatic int s5h1420_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\n\tstruct budget *budget = fe->dvb->priv;\n\tu32 div;\n\tu8 data[4];\n\tstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = sizeof(data) };\n\n\tdiv = c->frequency / 1000;\n\tdata[0] = (div >> 8) & 0x7f;\n\tdata[1] = div & 0xff;\n\tdata[2] = 0xc2;\n\n\tif (div < 1450)\n\t\tdata[3] = 0x00;\n\telse if (div < 1850)\n\t\tdata[3] = 0x40;\n\telse if (div < 2000)\n\t\tdata[3] = 0x80;\n\telse\n\t\tdata[3] = 0xc0;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tif (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;\n\n\treturn 0;\n}\n\nstatic struct s5h1420_config s5h1420_config = {\n\t.demod_address = 0x53,\n\t.invert = 1,\n\t.cdclk_polarity = 1,\n};\n\nstatic struct tda10086_config tda10086_config = {\n\t.demod_address = 0x0e,\n\t.invert = 0,\n\t.diseqc_tone = 1,\n\t.xtal_freq = TDA10086_XTAL_16M,\n};\n\nstatic const struct stv0299_config alps_bsru6_config_activy = {\n\t.demod_address = 0x68,\n\t.inittab = alps_bsru6_inittab,\n\t.mclk = 88000000UL,\n\t.invert = 1,\n\t.op0_off = 1,\n\t.min_delay_ms = 100,\n\t.set_symbol_rate = alps_bsru6_set_symbol_rate,\n};\n\nstatic const struct stv0299_config alps_bsbe1_config_activy = {\n\t.demod_address = 0x68,\n\t.inittab = alps_bsbe1_inittab,\n\t.mclk = 88000000UL,\n\t.invert = 1,\n\t.op0_off = 1,\n\t.min_delay_ms = 100,\n\t.set_symbol_rate = alps_bsbe1_set_symbol_rate,\n};\n\nstatic int alps_tdhd1_204_request_firmware(struct dvb_frontend *fe, const struct firmware **fw, char *name)\n{\n\tstruct budget *budget = fe->dvb->priv;\n\n\treturn request_firmware(fw, name, &budget->dev->pci->dev);\n}\n\n\nstatic int i2c_readreg(struct i2c_adapter *i2c, u8 adr, u8 reg)\n{\n\tu8 val;\n\tstruct i2c_msg msg[] = {\n\t\t{ .addr = adr, .flags = 0, .buf = &reg, .len = 1 },\n\t\t{ .addr = adr, .flags = I2C_M_RD, .buf = &val, .len = 1 }\n\t};\n\n\treturn (i2c_transfer(i2c, msg, 2) != 2) ? -EIO : val;\n}\n\nstatic u8 read_pwm(struct budget* budget)\n{\n\tu8 b = 0xff;\n\tu8 pwm;\n\tstruct i2c_msg msg[] = { { .addr = 0x50,.flags = 0,.buf = &b,.len = 1 },\n\t\t\t\t { .addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1} };\n\n\tif ((i2c_transfer(&budget->i2c_adap, msg, 2) != 2) || (pwm == 0xff))\n\t\tpwm = 0x48;\n\n\treturn pwm;\n}\n\nstatic struct stv090x_config tt1600_stv090x_config = {\n\t.device\t\t\t= STV0903,\n\t.demod_mode\t\t= STV090x_SINGLE,\n\t.clk_mode\t\t= STV090x_CLK_EXT,\n\n\t.xtal\t\t\t= 13500000,\n\t.address\t\t= 0x68,\n\n\t.ts1_mode\t\t= STV090x_TSMODE_DVBCI,\n\t.ts2_mode\t\t= STV090x_TSMODE_SERIAL_CONTINUOUS,\n\n\t.repeater_level\t\t= STV090x_RPTLEVEL_16,\n\n\t.tuner_init\t\t= NULL,\n\t.tuner_sleep\t\t= NULL,\n\t.tuner_set_mode\t\t= NULL,\n\t.tuner_set_frequency\t= NULL,\n\t.tuner_get_frequency\t= NULL,\n\t.tuner_set_bandwidth\t= NULL,\n\t.tuner_get_bandwidth\t= NULL,\n\t.tuner_set_bbgain\t= NULL,\n\t.tuner_get_bbgain\t= NULL,\n\t.tuner_set_refclk\t= NULL,\n\t.tuner_get_status\t= NULL,\n};\n\nstatic struct stv6110x_config tt1600_stv6110x_config = {\n\t.addr\t\t\t= 0x60,\n\t.refclk\t\t\t= 27000000,\n\t.clk_div\t\t= 2,\n};\n\nstatic struct isl6423_config tt1600_isl6423_config = {\n\t.current_max\t\t= SEC_CURRENT_515m,\n\t.curlim\t\t\t= SEC_CURRENT_LIM_ON,\n\t.mod_extern\t\t= 1,\n\t.addr\t\t\t= 0x08,\n};\n\nstatic void frontend_init(struct budget *budget)\n{\n\t(void)alps_bsbe1_config;  \n\n\tswitch(budget->dev->pci->subsystem_device) {\n\tcase 0x1003: \n\tcase 0x1013:\n\t\t\n\t\tbudget->dvb_frontend = dvb_attach(ves1x93_attach, &alps_bsrv2_config, &budget->i2c_adap);\n\t\tif (budget->dvb_frontend) {\n\t\t\tbudget->dvb_frontend->ops.tuner_ops.set_params = alps_bsrv2_tuner_set_params;\n\t\t\tbudget->dvb_frontend->ops.diseqc_send_master_cmd = budget_diseqc_send_master_cmd;\n\t\t\tbudget->dvb_frontend->ops.diseqc_send_burst = budget_diseqc_send_burst;\n\t\t\tbudget->dvb_frontend->ops.set_tone = budget_set_tone;\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tbudget->dvb_frontend = dvb_attach(stv0299_attach, &alps_bsru6_config, &budget->i2c_adap);\n\t\tif (budget->dvb_frontend) {\n\t\t\tbudget->dvb_frontend->ops.tuner_ops.set_params = alps_bsru6_tuner_set_params;\n\t\t\tbudget->dvb_frontend->tuner_priv = &budget->i2c_adap;\n\t\t\tif (budget->dev->pci->subsystem_device == 0x1003 && diseqc_method == 0) {\n\t\t\t\tbudget->dvb_frontend->ops.diseqc_send_master_cmd = budget_diseqc_send_master_cmd;\n\t\t\t\tbudget->dvb_frontend->ops.diseqc_send_burst = budget_diseqc_send_burst;\n\t\t\t\tbudget->dvb_frontend->ops.set_tone = budget_set_tone;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1004: \n\n\t\tbudget->dvb_frontend = dvb_attach(ves1820_attach, &alps_tdbe2_config, &budget->i2c_adap, read_pwm(budget));\n\t\tif (budget->dvb_frontend) {\n\t\t\tbudget->dvb_frontend->ops.tuner_ops.set_params = alps_tdbe2_tuner_set_params;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1005: \n\n\t\tbudget->dvb_frontend = dvb_attach(l64781_attach, &grundig_29504_401_config, &budget->i2c_adap);\n\t\tif (budget->dvb_frontend) {\n\t\t\tbudget->dvb_frontend->ops.tuner_ops.set_params = grundig_29504_401_tuner_set_params;\n\t\t\tbudget->dvb_frontend->tuner_priv = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x4f52:  \n\t\tbudget->dvb_frontend = dvb_attach(stv0299_attach, &alps_bsru6_config, &budget->i2c_adap);\n\t\tif (budget->dvb_frontend) {\n\t\t\tprintk(KERN_INFO \"budget: tuner ALPS BSRU6 in Philips Semi. Sylt detected\\n\");\n\t\t\tbudget->dvb_frontend->ops.tuner_ops.set_params = alps_bsru6_tuner_set_params;\n\t\t\tbudget->dvb_frontend->tuner_priv = &budget->i2c_adap;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x4f60:  \n\t{\n\t\tint subtype = i2c_readreg(&budget->i2c_adap, 0x50, 0x67);\n\n\t\tif (subtype < 0)\n\t\t\tbreak;\n\t\t \n\t\tif (subtype < 0x36) {\n\t\t\t \n\t\t\tbudget->dvb_frontend = dvb_attach(stv0299_attach, &alps_bsru6_config_activy, &budget->i2c_adap);\n\t\t\tif (budget->dvb_frontend) {\n\t\t\t\tprintk(KERN_INFO \"budget: tuner ALPS BSRU6 detected\\n\");\n\t\t\t\tbudget->dvb_frontend->ops.tuner_ops.set_params = alps_bsru6_tuner_set_params;\n\t\t\t\tbudget->dvb_frontend->tuner_priv = &budget->i2c_adap;\n\t\t\t\tbudget->dvb_frontend->ops.set_voltage = siemens_budget_set_voltage;\n\t\t\t\tbudget->dvb_frontend->ops.dishnetwork_send_legacy_command = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tsaa7146_setgpio(budget->dev, 3, SAA7146_GPIO_OUTLO);\n\t\t\tmsleep(50);\n\t\t\tsaa7146_setgpio(budget->dev, 3, SAA7146_GPIO_OUTHI);\n\t\t\tmsleep(250);\n\t\t\tbudget->dvb_frontend = dvb_attach(stv0299_attach, &alps_bsbe1_config_activy, &budget->i2c_adap);\n\t\t\tif (budget->dvb_frontend) {\n\t\t\t\tprintk(KERN_INFO \"budget: tuner ALPS BSBE1 detected\\n\");\n\t\t\t\tbudget->dvb_frontend->ops.tuner_ops.set_params = alps_bsbe1_tuner_set_params;\n\t\t\t\tbudget->dvb_frontend->tuner_priv = &budget->i2c_adap;\n\t\t\t\tbudget->dvb_frontend->ops.set_voltage = siemens_budget_set_voltage;\n\t\t\t\tbudget->dvb_frontend->ops.dishnetwork_send_legacy_command = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase 0x4f61: \n\t\tbudget->dvb_frontend = dvb_attach(tda8083_attach, &grundig_29504_451_config, &budget->i2c_adap);\n\t\tif (budget->dvb_frontend) {\n\t\t\tbudget->dvb_frontend->ops.tuner_ops.set_params = grundig_29504_451_tuner_set_params;\n\t\t\tbudget->dvb_frontend->ops.set_voltage = siemens_budget_set_voltage;\n\t\t\tbudget->dvb_frontend->ops.dishnetwork_send_legacy_command = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase 0x5f60:  \n\t\tbudget->dvb_frontend = dvb_attach(tda10046_attach, &alps_tdhd1_204a_config, &budget->i2c_adap);\n\t\tif (budget->dvb_frontend) {\n\t\t\tbudget->dvb_frontend->ops.tuner_ops.set_params = alps_tdhd1_204a_tuner_set_params;\n\t\t\tbudget->dvb_frontend->tuner_priv = &budget->i2c_adap;\n\t\t}\n\t\tbreak;\n\n\tcase 0x5f61:  \n\t\tbudget->dvb_frontend = dvb_attach(l64781_attach, &grundig_29504_401_config_activy, &budget->i2c_adap);\n\t\tif (budget->dvb_frontend) {\n\t\t\tbudget->dvb_frontend->tuner_priv = &tuner_address_grundig_29504_401_activy;\n\t\t\tbudget->dvb_frontend->ops.tuner_ops.set_params = grundig_29504_401_tuner_set_params;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1016: \n\t{\n\t\tstruct dvb_frontend *fe;\n\n\t\tfe = dvb_attach(s5h1420_attach, &s5h1420_config, &budget->i2c_adap);\n\t\tif (fe) {\n\t\t\tfe->ops.tuner_ops.set_params = s5h1420_tuner_set_params;\n\t\t\tbudget->dvb_frontend = fe;\n\t\t\tif (dvb_attach(lnbp21_attach, fe, &budget->i2c_adap,\n\t\t\t\t       0, 0) == NULL) {\n\t\t\t\tprintk(\"%s: No LNBP21 found!\\n\", __func__);\n\t\t\t\tgoto error_out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\tfallthrough;\n\tcase 0x1018: \n\t{\n\t\tstruct dvb_frontend *fe;\n\n\t\t\n\t\tsaa7146_setgpio(budget->dev, 2, SAA7146_GPIO_OUTLO);\n\t\tmsleep(1);\n\t\tsaa7146_setgpio(budget->dev, 2, SAA7146_GPIO_OUTHI);\n\t\tmsleep(1);\n\n\t\tfe = dvb_attach(tda10086_attach, &tda10086_config, &budget->i2c_adap);\n\t\tif (fe) {\n\t\t\tbudget->dvb_frontend = fe;\n\t\t\tif (dvb_attach(tda826x_attach, fe, 0x60,\n\t\t\t\t       &budget->i2c_adap, 0) == NULL)\n\t\t\t\tprintk(\"%s: No tda826x found!\\n\", __func__);\n\t\t\tif (dvb_attach(lnbp21_attach, fe,\n\t\t\t\t       &budget->i2c_adap, 0, 0) == NULL) {\n\t\t\t\tprintk(\"%s: No LNBP21 found!\\n\", __func__);\n\t\t\t\tgoto error_out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\tfallthrough;\n\n\tcase 0x101c: {  \n\t\t\tconst struct stv6110x_devctl *ctl;\n\t\t\tsaa7146_setgpio(budget->dev, 2, SAA7146_GPIO_OUTLO);\n\t\t\tmsleep(50);\n\t\t\tsaa7146_setgpio(budget->dev, 2, SAA7146_GPIO_OUTHI);\n\t\t\tmsleep(250);\n\n\t\t\tbudget->dvb_frontend = dvb_attach(stv090x_attach,\n\t\t\t\t\t\t\t  &tt1600_stv090x_config,\n\t\t\t\t\t\t\t  &budget->i2c_adap,\n\t\t\t\t\t\t\t  STV090x_DEMODULATOR_0);\n\n\t\t\tif (budget->dvb_frontend) {\n\n\t\t\t\tctl = dvb_attach(stv6110x_attach,\n\t\t\t\t\t\t budget->dvb_frontend,\n\t\t\t\t\t\t &tt1600_stv6110x_config,\n\t\t\t\t\t\t &budget->i2c_adap);\n\n\t\t\t\tif (ctl) {\n\t\t\t\t\ttt1600_stv090x_config.tuner_init\t  = ctl->tuner_init;\n\t\t\t\t\ttt1600_stv090x_config.tuner_sleep\t  = ctl->tuner_sleep;\n\t\t\t\t\ttt1600_stv090x_config.tuner_set_mode\t  = ctl->tuner_set_mode;\n\t\t\t\t\ttt1600_stv090x_config.tuner_set_frequency = ctl->tuner_set_frequency;\n\t\t\t\t\ttt1600_stv090x_config.tuner_get_frequency = ctl->tuner_get_frequency;\n\t\t\t\t\ttt1600_stv090x_config.tuner_set_bandwidth = ctl->tuner_set_bandwidth;\n\t\t\t\t\ttt1600_stv090x_config.tuner_get_bandwidth = ctl->tuner_get_bandwidth;\n\t\t\t\t\ttt1600_stv090x_config.tuner_set_bbgain\t  = ctl->tuner_set_bbgain;\n\t\t\t\t\ttt1600_stv090x_config.tuner_get_bbgain\t  = ctl->tuner_get_bbgain;\n\t\t\t\t\ttt1600_stv090x_config.tuner_set_refclk\t  = ctl->tuner_set_refclk;\n\t\t\t\t\ttt1600_stv090x_config.tuner_get_status\t  = ctl->tuner_get_status;\n\n\t\t\t\t\t \n\t\t\t\t\tif (budget->dvb_frontend->ops.init)\n\t\t\t\t\t\tbudget->dvb_frontend->ops.init(budget->dvb_frontend);\n\n\t\t\t\t\tif (dvb_attach(isl6423_attach,\n\t\t\t\t\t\t       budget->dvb_frontend,\n\t\t\t\t\t\t       &budget->i2c_adap,\n\t\t\t\t\t\t       &tt1600_isl6423_config) == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR \"%s: No Intersil ISL6423 found!\\n\", __func__);\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintk(KERN_ERR \"%s: No STV6110(A) Silicon Tuner found!\\n\", __func__);\n\t\t\t\t\tgoto error_out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 0x1020: {  \n\t\t\tconst struct stv6110x_devctl *ctl;\n\t\t\tsaa7146_setgpio(budget->dev, 2, SAA7146_GPIO_OUTLO);\n\t\t\tmsleep(50);\n\t\t\tsaa7146_setgpio(budget->dev, 2, SAA7146_GPIO_OUTHI);\n\t\t\tmsleep(250);\n\n\t\t\tbudget->dvb_frontend = dvb_attach(stv090x_attach,\n\t\t\t\t\t\t\t  &tt1600_stv090x_config,\n\t\t\t\t\t\t\t  &budget->i2c_adap,\n\t\t\t\t\t\t\t  STV090x_DEMODULATOR_0);\n\n\t\t\tif (budget->dvb_frontend) {\n\t\t\t\tprintk(KERN_INFO \"budget: Omicom S2 detected\\n\");\n\n\t\t\t\tctl = dvb_attach(stv6110x_attach,\n\t\t\t\t\t\t budget->dvb_frontend,\n\t\t\t\t\t\t &tt1600_stv6110x_config,\n\t\t\t\t\t\t &budget->i2c_adap);\n\n\t\t\t\tif (ctl) {\n\t\t\t\t\ttt1600_stv090x_config.tuner_init\t  = ctl->tuner_init;\n\t\t\t\t\ttt1600_stv090x_config.tuner_sleep\t  = ctl->tuner_sleep;\n\t\t\t\t\ttt1600_stv090x_config.tuner_set_mode\t  = ctl->tuner_set_mode;\n\t\t\t\t\ttt1600_stv090x_config.tuner_set_frequency = ctl->tuner_set_frequency;\n\t\t\t\t\ttt1600_stv090x_config.tuner_get_frequency = ctl->tuner_get_frequency;\n\t\t\t\t\ttt1600_stv090x_config.tuner_set_bandwidth = ctl->tuner_set_bandwidth;\n\t\t\t\t\ttt1600_stv090x_config.tuner_get_bandwidth = ctl->tuner_get_bandwidth;\n\t\t\t\t\ttt1600_stv090x_config.tuner_set_bbgain\t  = ctl->tuner_set_bbgain;\n\t\t\t\t\ttt1600_stv090x_config.tuner_get_bbgain\t  = ctl->tuner_get_bbgain;\n\t\t\t\t\ttt1600_stv090x_config.tuner_set_refclk\t  = ctl->tuner_set_refclk;\n\t\t\t\t\ttt1600_stv090x_config.tuner_get_status\t  = ctl->tuner_get_status;\n\n\t\t\t\t\t \n\t\t\t\t\tif (budget->dvb_frontend->ops.init)\n\t\t\t\t\t\tbudget->dvb_frontend->ops.init(budget->dvb_frontend);\n\n\t\t\t\t\tif (dvb_attach(lnbh24_attach,\n\t\t\t\t\t\t\tbudget->dvb_frontend,\n\t\t\t\t\t\t\t&budget->i2c_adap,\n\t\t\t\t\t\t\tLNBH24_PCL | LNBH24_TTX,\n\t\t\t\t\t\t\tLNBH24_TEN, 0x14>>1) == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t\"No LNBH24 found!\\n\");\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintk(KERN_ERR \"%s: No STV6110(A) Silicon Tuner found!\\n\", __func__);\n\t\t\t\t\tgoto error_out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (budget->dvb_frontend == NULL) {\n\t\tprintk(\"budget: A frontend driver was not found for device [%04x:%04x] subsystem [%04x:%04x]\\n\",\n\t\t       budget->dev->pci->vendor,\n\t\t       budget->dev->pci->device,\n\t\t       budget->dev->pci->subsystem_vendor,\n\t\t       budget->dev->pci->subsystem_device);\n\t} else {\n\t\tif (dvb_register_frontend(&budget->dvb_adapter, budget->dvb_frontend))\n\t\t\tgoto error_out;\n\t}\n\treturn;\n\nerror_out:\n\tprintk(\"budget: Frontend registration failed!\\n\");\n\tdvb_frontend_detach(budget->dvb_frontend);\n\tbudget->dvb_frontend = NULL;\n\treturn;\n}\n\nstatic int budget_attach (struct saa7146_dev* dev, struct saa7146_pci_extension_data *info)\n{\n\tstruct budget *budget = NULL;\n\tint err;\n\n\tbudget = kmalloc(sizeof(struct budget), GFP_KERNEL);\n\tif( NULL == budget ) {\n\t\treturn -ENOMEM;\n\t}\n\n\tdprintk(2, \"dev:%p, info:%p, budget:%p\\n\", dev, info, budget);\n\n\tdev->ext_priv = budget;\n\n\terr = ttpci_budget_init(budget, dev, info, THIS_MODULE, adapter_nr);\n\tif (err) {\n\t\tprintk(\"==> failed\\n\");\n\t\tkfree (budget);\n\t\treturn err;\n\t}\n\n\tbudget->dvb_adapter.priv = budget;\n\tfrontend_init(budget);\n\n\tttpci_budget_init_hooks(budget);\n\n\treturn 0;\n}\n\nstatic int budget_detach (struct saa7146_dev* dev)\n{\n\tstruct budget *budget = dev->ext_priv;\n\tint err;\n\n\tif (budget->dvb_frontend) {\n\t\tdvb_unregister_frontend(budget->dvb_frontend);\n\t\tdvb_frontend_detach(budget->dvb_frontend);\n\t}\n\n\terr = ttpci_budget_deinit (budget);\n\n\tkfree (budget);\n\tdev->ext_priv = NULL;\n\n\treturn err;\n}\n\nstatic struct saa7146_extension budget_extension;\n\nMAKE_BUDGET_INFO(ttbs,\t\"TT-Budget/WinTV-NOVA-S  PCI\",\tBUDGET_TT);\nMAKE_BUDGET_INFO(ttbc,\t\"TT-Budget/WinTV-NOVA-C  PCI\",\tBUDGET_TT);\nMAKE_BUDGET_INFO(ttbt,\t\"TT-Budget/WinTV-NOVA-T  PCI\",\tBUDGET_TT);\nMAKE_BUDGET_INFO(satel,\t\"SATELCO Multimedia PCI\",\tBUDGET_TT_HW_DISEQC);\nMAKE_BUDGET_INFO(ttbs1401, \"TT-Budget-S-1401 PCI\", BUDGET_TT);\nMAKE_BUDGET_INFO(tt1600, \"TT-Budget S2-1600 PCI\", BUDGET_TT);\nMAKE_BUDGET_INFO(fsacs0, \"Fujitsu Siemens Activy Budget-S PCI (rev GR/grundig frontend)\", BUDGET_FS_ACTIVY);\nMAKE_BUDGET_INFO(fsacs1, \"Fujitsu Siemens Activy Budget-S PCI (rev AL/alps frontend)\", BUDGET_FS_ACTIVY);\nMAKE_BUDGET_INFO(fsact,\t \"Fujitsu Siemens Activy Budget-T PCI (rev GR/Grundig frontend)\", BUDGET_FS_ACTIVY);\nMAKE_BUDGET_INFO(fsact1, \"Fujitsu Siemens Activy Budget-T PCI (rev AL/ALPS TDHD1-204A)\", BUDGET_FS_ACTIVY);\nMAKE_BUDGET_INFO(omicom, \"Omicom S2 PCI\", BUDGET_TT);\nMAKE_BUDGET_INFO(sylt,   \"Philips Semi Sylt PCI\", BUDGET_TT_HW_DISEQC);\n\nstatic const struct pci_device_id pci_tbl[] = {\n\tMAKE_EXTENSION_PCI(ttbs,  0x13c2, 0x1003),\n\tMAKE_EXTENSION_PCI(ttbc,  0x13c2, 0x1004),\n\tMAKE_EXTENSION_PCI(ttbt,  0x13c2, 0x1005),\n\tMAKE_EXTENSION_PCI(satel, 0x13c2, 0x1013),\n\tMAKE_EXTENSION_PCI(ttbs,  0x13c2, 0x1016),\n\tMAKE_EXTENSION_PCI(ttbs1401, 0x13c2, 0x1018),\n\tMAKE_EXTENSION_PCI(tt1600, 0x13c2, 0x101c),\n\tMAKE_EXTENSION_PCI(fsacs1,0x1131, 0x4f60),\n\tMAKE_EXTENSION_PCI(fsacs0,0x1131, 0x4f61),\n\tMAKE_EXTENSION_PCI(fsact1, 0x1131, 0x5f60),\n\tMAKE_EXTENSION_PCI(fsact, 0x1131, 0x5f61),\n\tMAKE_EXTENSION_PCI(omicom, 0x14c4, 0x1020),\n\tMAKE_EXTENSION_PCI(sylt, 0x1131, 0x4f52),\n\t{\n\t\t.vendor    = 0,\n\t}\n};\n\nMODULE_DEVICE_TABLE(pci, pci_tbl);\n\nstatic struct saa7146_extension budget_extension = {\n\t.name\t\t= \"budget dvb\",\n\t.flags\t\t= SAA7146_USE_I2C_IRQ,\n\n\t.module\t\t= THIS_MODULE,\n\t.pci_tbl\t= pci_tbl,\n\t.attach\t\t= budget_attach,\n\t.detach\t\t= budget_detach,\n\n\t.irq_mask\t= MASK_10,\n\t.irq_func\t= ttpci_budget_irq10_handler,\n};\n\nstatic int __init budget_init(void)\n{\n\treturn saa7146_register_extension(&budget_extension);\n}\n\nstatic void __exit budget_exit(void)\n{\n\tsaa7146_unregister_extension(&budget_extension);\n}\n\nmodule_init(budget_init);\nmodule_exit(budget_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ralph Metzler, Marcus Metzler, Michael Hunold, others\");\nMODULE_DESCRIPTION(\"driver for the SAA7146 based so-called budget PCI DVB cards by Siemens, Technotrend, Hauppauge\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}