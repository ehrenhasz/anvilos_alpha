{
  "module_name": "budget-core.c",
  "hash_id": "36deb45e81e9b2190bbb61c797ef088c31472a661eee40735582e6b18b53a463",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ttpci/budget-core.c",
  "human_readable_source": "\n \n\n\n#include \"budget.h\"\n#include \"ttpci-eeprom.h\"\n\n#define TS_WIDTH\t\t(2 * TS_SIZE)\n#define TS_WIDTH_ACTIVY\t\tTS_SIZE\n#define TS_WIDTH_DVBC\t\tTS_SIZE\n#define TS_HEIGHT_MASK\t\t0xf00\n#define TS_HEIGHT_MASK_ACTIVY\t0xc00\n#define TS_HEIGHT_MASK_DVBC\t0xe00\n#define TS_MIN_BUFSIZE_K\t188\n#define TS_MAX_BUFSIZE_K\t1410\n#define TS_MAX_BUFSIZE_K_ACTIVY\t564\n#define TS_MAX_BUFSIZE_K_DVBC\t1316\n#define BUFFER_WARNING_WAIT\t(30*HZ)\n\nint budget_debug;\nstatic int dma_buffer_size = TS_MIN_BUFSIZE_K;\nmodule_param_named(debug, budget_debug, int, 0644);\nmodule_param_named(bufsize, dma_buffer_size, int, 0444);\nMODULE_PARM_DESC(debug, \"Turn on/off budget debugging (default:off).\");\nMODULE_PARM_DESC(bufsize, \"DMA buffer size in KB, default: 188, min: 188, max: 1410 (Activy: 564)\");\n\n \n\nstatic int stop_ts_capture(struct budget *budget)\n{\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tsaa7146_write(budget->dev, MC1, MASK_20);\t\n\tSAA7146_IER_DISABLE(budget->dev, MASK_10);\n\treturn 0;\n}\n\nstatic int start_ts_capture(struct budget *budget)\n{\n\tstruct saa7146_dev *dev = budget->dev;\n\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tif (!budget->feeding || !budget->fe_synced)\n\t\treturn 0;\n\n\tsaa7146_write(dev, MC1, MASK_20);\t\n\n\tmemset(budget->grabbing, 0x00, budget->buffer_size);\n\n\tsaa7146_write(dev, PCI_BT_V1, 0x001c0000 | (saa7146_read(dev, PCI_BT_V1) & ~0x001f0000));\n\n\tbudget->ttbp = 0;\n\n\t \n\n\tswitch(budget->card->type) {\n\tcase BUDGET_FS_ACTIVY:\n\t\tsaa7146_write(dev, DD1_INIT, 0x04000000);\n\t\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25));\n\t\tsaa7146_write(dev, BRS_CTRL, 0x00000000);\n\t\tbreak;\n\tcase BUDGET_PATCH:\n\t\tsaa7146_write(dev, DD1_INIT, 0x00000200);\n\t\tsaa7146_write(dev, MC2, (MASK_10 | MASK_26));\n\t\tsaa7146_write(dev, BRS_CTRL, 0x60000000);\n\t\tbreak;\n\tcase BUDGET_CIN1200C_MK3:\n\tcase BUDGET_KNC1C_MK3:\n\tcase BUDGET_KNC1C_TDA10024:\n\tcase BUDGET_KNC1CP_MK3:\n\t\tif (budget->video_port == BUDGET_VIDEO_PORTA) {\n\t\t\tsaa7146_write(dev, DD1_INIT, 0x06000200);\n\t\t\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\t\t\tsaa7146_write(dev, BRS_CTRL, 0x00000000);\n\t\t} else {\n\t\t\tsaa7146_write(dev, DD1_INIT, 0x00000600);\n\t\t\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\t\t\tsaa7146_write(dev, BRS_CTRL, 0x60000000);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (budget->video_port == BUDGET_VIDEO_PORTA) {\n\t\t\tsaa7146_write(dev, DD1_INIT, 0x06000200);\n\t\t\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\t\t\tsaa7146_write(dev, BRS_CTRL, 0x00000000);\n\t\t} else {\n\t\t\tsaa7146_write(dev, DD1_INIT, 0x02000600);\n\t\t\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\t\t\tsaa7146_write(dev, BRS_CTRL, 0x60000000);\n\t\t}\n\t}\n\n\tsaa7146_write(dev, MC2, (MASK_08 | MASK_24));\n\tmdelay(10);\n\n\tsaa7146_write(dev, BASE_ODD3, 0);\n\tif (budget->buffer_size > budget->buffer_height * budget->buffer_width) {\n\t\t\n\t\tsaa7146_write(dev, BASE_EVEN3, budget->buffer_height * budget->buffer_width);\n\t} else {\n\t\t\n\t\tsaa7146_write(dev, BASE_EVEN3, 0);\n\t}\n\tsaa7146_write(dev, PROT_ADDR3, budget->buffer_size);\n\tsaa7146_write(dev, BASE_PAGE3, budget->pt.dma | ME1 | 0x90);\n\n\tsaa7146_write(dev, PITCH3, budget->buffer_width);\n\tsaa7146_write(dev, NUM_LINE_BYTE3,\n\t\t\t(budget->buffer_height << 16) | budget->buffer_width);\n\n\tsaa7146_write(dev, MC2, (MASK_04 | MASK_20));\n\n\tSAA7146_ISR_CLEAR(budget->dev, MASK_10);\t \n\tSAA7146_IER_ENABLE(budget->dev, MASK_10);\t \n\tsaa7146_write(dev, MC1, (MASK_04 | MASK_20));\t \n\n\treturn 0;\n}\n\nstatic int budget_read_fe_status(struct dvb_frontend *fe,\n\t\t\t\t enum fe_status *status)\n{\n\tstruct budget *budget = fe->dvb->priv;\n\tint synced;\n\tint ret;\n\n\tif (budget->read_fe_status)\n\t\tret = budget->read_fe_status(fe, status);\n\telse\n\t\tret = -EINVAL;\n\n\tif (!ret) {\n\t\tsynced = (*status & FE_HAS_LOCK);\n\t\tif (synced != budget->fe_synced) {\n\t\t\tbudget->fe_synced = synced;\n\t\t\tspin_lock(&budget->feedlock);\n\t\t\tif (synced)\n\t\t\t\tstart_ts_capture(budget);\n\t\t\telse\n\t\t\t\tstop_ts_capture(budget);\n\t\t\tspin_unlock(&budget->feedlock);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void vpeirq(struct tasklet_struct *t)\n{\n\tstruct budget *budget = from_tasklet(budget, t, vpe_tasklet);\n\tu8 *mem = (u8 *) (budget->grabbing);\n\tu32 olddma = budget->ttbp;\n\tu32 newdma = saa7146_read(budget->dev, PCI_VDP3);\n\tu32 count;\n\n\t \n\tdma_sync_sg_for_cpu(&budget->dev->pci->dev, budget->pt.slist,\n\t\t\t    budget->pt.nents, DMA_FROM_DEVICE);\n\n\t \n\tnewdma -= newdma % 188;\n\n\tif (newdma >= budget->buffer_size)\n\t\treturn;\n\n\tbudget->ttbp = newdma;\n\n\tif (budget->feeding == 0 || newdma == olddma)\n\t\treturn;\n\n\tif (newdma > olddma) {\t \n\t\tcount = newdma - olddma;\n\t\tdvb_dmx_swfilter_packets(&budget->demux, mem + olddma, count / 188);\n\t} else {\t\t \n\t\tcount = budget->buffer_size - olddma;\n\t\tdvb_dmx_swfilter_packets(&budget->demux, mem + olddma, count / 188);\n\t\tcount += newdma;\n\t\tdvb_dmx_swfilter_packets(&budget->demux, mem, newdma / 188);\n\t}\n\n\tif (count > budget->buffer_warning_threshold)\n\t\tbudget->buffer_warnings++;\n\n\tif (budget->buffer_warnings && time_after(jiffies, budget->buffer_warning_time)) {\n\t\tprintk(\"%s %s: used %d times >80%% of buffer (%u bytes now)\\n\",\n\t\t\tbudget->dev->name, __func__, budget->buffer_warnings, count);\n\t\tbudget->buffer_warning_time = jiffies + BUFFER_WARNING_WAIT;\n\t\tbudget->buffer_warnings = 0;\n\t}\n}\n\n\nstatic int ttpci_budget_debiread_nolock(struct budget *budget, u32 config,\n\t\tint addr, int count, int nobusyloop)\n{\n\tstruct saa7146_dev *saa = budget->dev;\n\tint result;\n\n\tresult = saa7146_wait_for_debi_done(saa, nobusyloop);\n\tif (result < 0)\n\t\treturn result;\n\n\tsaa7146_write(saa, DEBI_COMMAND, (count << 17) | 0x10000 | (addr & 0xffff));\n\tsaa7146_write(saa, DEBI_CONFIG, config);\n\tsaa7146_write(saa, DEBI_PAGE, 0);\n\tsaa7146_write(saa, MC2, (2 << 16) | 2);\n\n\tresult = saa7146_wait_for_debi_done(saa, nobusyloop);\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = saa7146_read(saa, DEBI_AD);\n\tresult &= (0xffffffffUL >> ((4 - count) * 8));\n\treturn result;\n}\n\nint ttpci_budget_debiread(struct budget *budget, u32 config, int addr, int count,\n\t\t\t  int uselocks, int nobusyloop)\n{\n\tif (count > 4 || count <= 0)\n\t\treturn 0;\n\n\tif (uselocks) {\n\t\tunsigned long flags;\n\t\tint result;\n\n\t\tspin_lock_irqsave(&budget->debilock, flags);\n\t\tresult = ttpci_budget_debiread_nolock(budget, config, addr,\n\t\t\t\t\t\t      count, nobusyloop);\n\t\tspin_unlock_irqrestore(&budget->debilock, flags);\n\t\treturn result;\n\t}\n\treturn ttpci_budget_debiread_nolock(budget, config, addr,\n\t\t\t\t\t    count, nobusyloop);\n}\n\nstatic int ttpci_budget_debiwrite_nolock(struct budget *budget, u32 config,\n\t\tint addr, int count, u32 value, int nobusyloop)\n{\n\tstruct saa7146_dev *saa = budget->dev;\n\tint result;\n\n\tresult = saa7146_wait_for_debi_done(saa, nobusyloop);\n\tif (result < 0)\n\t\treturn result;\n\n\tsaa7146_write(saa, DEBI_COMMAND, (count << 17) | 0x00000 | (addr & 0xffff));\n\tsaa7146_write(saa, DEBI_CONFIG, config);\n\tsaa7146_write(saa, DEBI_PAGE, 0);\n\tsaa7146_write(saa, DEBI_AD, value);\n\tsaa7146_write(saa, MC2, (2 << 16) | 2);\n\n\tresult = saa7146_wait_for_debi_done(saa, nobusyloop);\n\treturn result < 0 ? result : 0;\n}\n\nint ttpci_budget_debiwrite(struct budget *budget, u32 config, int addr,\n\t\t\t   int count, u32 value, int uselocks, int nobusyloop)\n{\n\tif (count > 4 || count <= 0)\n\t\treturn 0;\n\n\tif (uselocks) {\n\t\tunsigned long flags;\n\t\tint result;\n\n\t\tspin_lock_irqsave(&budget->debilock, flags);\n\t\tresult = ttpci_budget_debiwrite_nolock(budget, config, addr,\n\t\t\t\t\t\tcount, value, nobusyloop);\n\t\tspin_unlock_irqrestore(&budget->debilock, flags);\n\t\treturn result;\n\t}\n\treturn ttpci_budget_debiwrite_nolock(budget, config, addr,\n\t\t\t\t\t     count, value, nobusyloop);\n}\n\n\n \n\nstatic int budget_start_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct budget *budget = demux->priv;\n\tint status = 0;\n\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tif (!demux->dmx.frontend)\n\t\treturn -EINVAL;\n\n\tspin_lock(&budget->feedlock);\n\tfeed->pusi_seen = false;  \n\tif (budget->feeding++ == 0)\n\t\tstatus = start_ts_capture(budget);\n\tspin_unlock(&budget->feedlock);\n\treturn status;\n}\n\nstatic int budget_stop_feed(struct dvb_demux_feed *feed)\n{\n\tstruct dvb_demux *demux = feed->demux;\n\tstruct budget *budget = demux->priv;\n\tint status = 0;\n\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tspin_lock(&budget->feedlock);\n\tif (--budget->feeding == 0)\n\t\tstatus = stop_ts_capture(budget);\n\tspin_unlock(&budget->feedlock);\n\treturn status;\n}\n\nstatic int budget_register(struct budget *budget)\n{\n\tstruct dvb_demux *dvbdemux = &budget->demux;\n\tint ret;\n\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tdvbdemux->priv = (void *) budget;\n\n\tdvbdemux->filternum = 256;\n\tdvbdemux->feednum = 256;\n\tdvbdemux->start_feed = budget_start_feed;\n\tdvbdemux->stop_feed = budget_stop_feed;\n\tdvbdemux->write_to_decoder = NULL;\n\n\tdvbdemux->dmx.capabilities = (DMX_TS_FILTERING | DMX_SECTION_FILTERING |\n\t\t\t\t      DMX_MEMORY_BASED_FILTERING);\n\n\tdvb_dmx_init(&budget->demux);\n\n\tbudget->dmxdev.filternum = 256;\n\tbudget->dmxdev.demux = &dvbdemux->dmx;\n\tbudget->dmxdev.capabilities = 0;\n\n\tdvb_dmxdev_init(&budget->dmxdev, &budget->dvb_adapter);\n\n\tbudget->hw_frontend.source = DMX_FRONTEND_0;\n\n\tret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &budget->hw_frontend);\n\n\tif (ret < 0)\n\t\tgoto err_release_dmx;\n\n\tbudget->mem_frontend.source = DMX_MEMORY_FE;\n\tret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &budget->mem_frontend);\n\tif (ret < 0)\n\t\tgoto err_release_dmx;\n\n\tret = dvbdemux->dmx.connect_frontend(&dvbdemux->dmx, &budget->hw_frontend);\n\tif (ret < 0)\n\t\tgoto err_release_dmx;\n\n\tdvb_net_init(&budget->dvb_adapter, &budget->dvb_net, &dvbdemux->dmx);\n\n\treturn 0;\n\nerr_release_dmx:\n\tdvb_dmxdev_release(&budget->dmxdev);\n\tdvb_dmx_release(&budget->demux);\n\treturn ret;\n}\n\nstatic void budget_unregister(struct budget *budget)\n{\n\tstruct dvb_demux *dvbdemux = &budget->demux;\n\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tdvb_net_release(&budget->dvb_net);\n\n\tdvbdemux->dmx.close(&dvbdemux->dmx);\n\tdvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &budget->hw_frontend);\n\tdvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &budget->mem_frontend);\n\n\tdvb_dmxdev_release(&budget->dmxdev);\n\tdvb_dmx_release(&budget->demux);\n}\n\nint ttpci_budget_init(struct budget *budget, struct saa7146_dev *dev,\n\t\t      struct saa7146_pci_extension_data *info,\n\t\t      struct module *owner, short *adapter_nums)\n{\n\tint ret = 0;\n\tstruct budget_info *bi = info->ext_priv;\n\tint max_bufsize;\n\tint height_mask;\n\n\tmemset(budget, 0, sizeof(struct budget));\n\n\tdprintk(2, \"dev: %p, budget: %p\\n\", dev, budget);\n\n\tbudget->card = bi;\n\tbudget->dev = (struct saa7146_dev *) dev;\n\n\tswitch(budget->card->type) {\n\tcase BUDGET_FS_ACTIVY:\n\t\tbudget->buffer_width = TS_WIDTH_ACTIVY;\n\t\tmax_bufsize = TS_MAX_BUFSIZE_K_ACTIVY;\n\t\theight_mask = TS_HEIGHT_MASK_ACTIVY;\n\t\tbreak;\n\n\tcase BUDGET_KNC1C:\n\tcase BUDGET_KNC1CP:\n\tcase BUDGET_CIN1200C:\n\tcase BUDGET_KNC1C_MK3:\n\tcase BUDGET_KNC1C_TDA10024:\n\tcase BUDGET_KNC1CP_MK3:\n\tcase BUDGET_CIN1200C_MK3:\n\t\tbudget->buffer_width = TS_WIDTH_DVBC;\n\t\tmax_bufsize = TS_MAX_BUFSIZE_K_DVBC;\n\t\theight_mask = TS_HEIGHT_MASK_DVBC;\n\t\tbreak;\n\n\tdefault:\n\t\tbudget->buffer_width = TS_WIDTH;\n\t\tmax_bufsize = TS_MAX_BUFSIZE_K;\n\t\theight_mask = TS_HEIGHT_MASK;\n\t}\n\n\tif (dma_buffer_size < TS_MIN_BUFSIZE_K)\n\t\tdma_buffer_size = TS_MIN_BUFSIZE_K;\n\telse if (dma_buffer_size > max_bufsize)\n\t\tdma_buffer_size = max_bufsize;\n\n\tbudget->buffer_height = dma_buffer_size * 1024 / budget->buffer_width;\n\tif (budget->buffer_height > 0xfff) {\n\t\tbudget->buffer_height /= 2;\n\t\tbudget->buffer_height &= height_mask;\n\t\tbudget->buffer_size = 2 * budget->buffer_height * budget->buffer_width;\n\t} else {\n\t\tbudget->buffer_height &= height_mask;\n\t\tbudget->buffer_size = budget->buffer_height * budget->buffer_width;\n\t}\n\tbudget->buffer_warning_threshold = budget->buffer_size * 80/100;\n\tbudget->buffer_warnings = 0;\n\tbudget->buffer_warning_time = jiffies;\n\n\tdprintk(2, \"%s: buffer type = %s, width = %d, height = %d\\n\",\n\t\tbudget->dev->name,\n\t\tbudget->buffer_size > budget->buffer_width * budget->buffer_height ? \"odd/even\" : \"single\",\n\t\tbudget->buffer_width, budget->buffer_height);\n\tprintk(\"%s: dma buffer size %u\\n\", budget->dev->name, budget->buffer_size);\n\n\tret = dvb_register_adapter(&budget->dvb_adapter, budget->card->name,\n\t\t\t\t   owner, &budget->dev->pci->dev, adapter_nums);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\n\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25));\n\tsaa7146_write(dev, MC2, (MASK_10 | MASK_26));\n\tsaa7146_write(dev, DD1_INIT, 0x02000000);\n\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\n\tif (bi->type != BUDGET_FS_ACTIVY)\n\t\tbudget->video_port = BUDGET_VIDEO_PORTB;\n\telse\n\t\tbudget->video_port = BUDGET_VIDEO_PORTA;\n\tspin_lock_init(&budget->feedlock);\n\tspin_lock_init(&budget->debilock);\n\n\t \n\tif (bi->type != BUDGET_FS_ACTIVY)\n\t\tsaa7146_write(dev, GPIO_CTRL, 0x500000);\t \n\n\tstrscpy(budget->i2c_adap.name, budget->card->name,\n\t\tsizeof(budget->i2c_adap.name));\n\n\tsaa7146_i2c_adapter_prepare(dev, &budget->i2c_adap, SAA7146_I2C_BUS_BIT_RATE_120);\n\tstrscpy(budget->i2c_adap.name, budget->card->name,\n\t\tsizeof(budget->i2c_adap.name));\n\n\tif (i2c_add_adapter(&budget->i2c_adap) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dvb_unregister;\n\t}\n\n\tttpci_eeprom_parse_mac(&budget->i2c_adap, budget->dvb_adapter.proposed_mac);\n\n\tbudget->grabbing = saa7146_vmalloc_build_pgtable(dev->pci, budget->buffer_size, &budget->pt);\n\tif (NULL == budget->grabbing) {\n\t\tret = -ENOMEM;\n\t\tgoto err_del_i2c;\n\t}\n\n\tsaa7146_write(dev, PCI_BT_V1, 0x001c0000);\n\t \n\tsaa7146_write(dev, GPIO_CTRL, 0x000000);\n\n\ttasklet_setup(&budget->vpe_tasklet, vpeirq);\n\n\t \n\tif (bi->type != BUDGET_FS_ACTIVY)\n\t\tsaa7146_setgpio(dev, 2, SAA7146_GPIO_OUTHI);\n\n\tif ((ret = budget_register(budget)) == 0)\n\t\treturn 0;  \n\n\t \n\tsaa7146_vfree_destroy_pgtable(dev->pci, budget->grabbing, &budget->pt);\n\nerr_del_i2c:\n\ti2c_del_adapter(&budget->i2c_adap);\n\nerr_dvb_unregister:\n\tdvb_unregister_adapter(&budget->dvb_adapter);\n\n\treturn ret;\n}\n\nvoid ttpci_budget_init_hooks(struct budget *budget)\n{\n\tif (budget->dvb_frontend && !budget->read_fe_status) {\n\t\tbudget->read_fe_status = budget->dvb_frontend->ops.read_status;\n\t\tbudget->dvb_frontend->ops.read_status = budget_read_fe_status;\n\t}\n}\n\nint ttpci_budget_deinit(struct budget *budget)\n{\n\tstruct saa7146_dev *dev = budget->dev;\n\n\tdprintk(2, \"budget: %p\\n\", budget);\n\n\tbudget_unregister(budget);\n\n\ttasklet_kill(&budget->vpe_tasklet);\n\n\tsaa7146_vfree_destroy_pgtable(dev->pci, budget->grabbing, &budget->pt);\n\n\ti2c_del_adapter(&budget->i2c_adap);\n\n\tdvb_unregister_adapter(&budget->dvb_adapter);\n\n\treturn 0;\n}\n\nvoid ttpci_budget_irq10_handler(struct saa7146_dev *dev, u32 * isr)\n{\n\tstruct budget *budget = dev->ext_priv;\n\n\tdprintk(8, \"dev: %p, budget: %p\\n\", dev, budget);\n\n\tif (*isr & MASK_10)\n\t\ttasklet_schedule(&budget->vpe_tasklet);\n}\n\nvoid ttpci_budget_set_video_port(struct saa7146_dev *dev, int video_port)\n{\n\tstruct budget *budget = dev->ext_priv;\n\n\tspin_lock(&budget->feedlock);\n\tbudget->video_port = video_port;\n\tif (budget->feeding) {\n\t\tstop_ts_capture(budget);\n\t\tstart_ts_capture(budget);\n\t}\n\tspin_unlock(&budget->feedlock);\n}\n\nEXPORT_SYMBOL_GPL(ttpci_budget_debiread);\nEXPORT_SYMBOL_GPL(ttpci_budget_debiwrite);\nEXPORT_SYMBOL_GPL(ttpci_budget_init);\nEXPORT_SYMBOL_GPL(ttpci_budget_init_hooks);\nEXPORT_SYMBOL_GPL(ttpci_budget_deinit);\nEXPORT_SYMBOL_GPL(ttpci_budget_irq10_handler);\nEXPORT_SYMBOL_GPL(ttpci_budget_set_video_port);\nEXPORT_SYMBOL_GPL(budget_debug);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}