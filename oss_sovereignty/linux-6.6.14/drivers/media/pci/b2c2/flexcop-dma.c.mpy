{
  "module_name": "flexcop-dma.c",
  "hash_id": "60115fff1a7a53426ece1796ca99daf5816ae6789b2de3221c742e8987131f83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/b2c2/flexcop-dma.c",
  "human_readable_source": "\n \n#include \"flexcop.h\"\n\nint flexcop_dma_allocate(struct pci_dev *pdev,\n\t\tstruct flexcop_dma *dma, u32 size)\n{\n\tu8 *tcpu;\n\tdma_addr_t tdma = 0;\n\n\tif (size % 2) {\n\t\terr(\"dma buffersize has to be even.\");\n\t\treturn -EINVAL;\n\t}\n\n\ttcpu = dma_alloc_coherent(&pdev->dev, size, &tdma, GFP_KERNEL);\n\tif (tcpu != NULL) {\n\t\tdma->pdev = pdev;\n\t\tdma->cpu_addr0 = tcpu;\n\t\tdma->dma_addr0 = tdma;\n\t\tdma->cpu_addr1 = tcpu + size/2;\n\t\tdma->dma_addr1 = tdma + size/2;\n\t\tdma->size = size/2;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(flexcop_dma_allocate);\n\nvoid flexcop_dma_free(struct flexcop_dma *dma)\n{\n\tdma_free_coherent(&dma->pdev->dev, dma->size * 2, dma->cpu_addr0,\n\t\t\t  dma->dma_addr0);\n\tmemset(dma, 0, sizeof(struct flexcop_dma));\n}\nEXPORT_SYMBOL(flexcop_dma_free);\n\nint flexcop_dma_config(struct flexcop_device *fc,\n\t\tstruct flexcop_dma *dma,\n\t\tflexcop_dma_index_t dma_idx)\n{\n\tflexcop_ibi_value v0x0, v0x4, v0xc;\n\n\tv0x0.raw = v0x4.raw = v0xc.raw = 0;\n\tv0x0.dma_0x0.dma_address0 = dma->dma_addr0 >> 2;\n\tv0xc.dma_0xc.dma_address1 = dma->dma_addr1 >> 2;\n\tv0x4.dma_0x4_write.dma_addr_size = dma->size / 4;\n\n\tif ((dma_idx & FC_DMA_1) == dma_idx) {\n\t\tfc->write_ibi_reg(fc, dma1_000, v0x0);\n\t\tfc->write_ibi_reg(fc, dma1_004, v0x4);\n\t\tfc->write_ibi_reg(fc, dma1_00c, v0xc);\n\t} else if ((dma_idx & FC_DMA_2) == dma_idx) {\n\t\tfc->write_ibi_reg(fc, dma2_010, v0x0);\n\t\tfc->write_ibi_reg(fc, dma2_014, v0x4);\n\t\tfc->write_ibi_reg(fc, dma2_01c, v0xc);\n\t} else {\n\t\terr(\"either DMA1 or DMA2 can be configured within one %s call.\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(flexcop_dma_config);\n\n \nint flexcop_dma_xfer_control(struct flexcop_device *fc,\n\t\tflexcop_dma_index_t dma_idx,\n\t\tflexcop_dma_addr_index_t index,\n\t\tint onoff)\n{\n\tflexcop_ibi_value v0x0, v0xc;\n\tflexcop_ibi_register r0x0, r0xc;\n\n\tif ((dma_idx & FC_DMA_1) == dma_idx) {\n\t\tr0x0 = dma1_000;\n\t\tr0xc = dma1_00c;\n\t} else if ((dma_idx & FC_DMA_2) == dma_idx) {\n\t\tr0x0 = dma2_010;\n\t\tr0xc = dma2_01c;\n\t} else {\n\t\terr(\"transfer DMA1 or DMA2 can be started within one %s call.\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tv0x0 = fc->read_ibi_reg(fc, r0x0);\n\tv0xc = fc->read_ibi_reg(fc, r0xc);\n\n\tdeb_rdump(\"reg: %03x: %x\\n\", r0x0, v0x0.raw);\n\tdeb_rdump(\"reg: %03x: %x\\n\", r0xc, v0xc.raw);\n\n\tif (index & FC_DMA_SUBADDR_0)\n\t\tv0x0.dma_0x0.dma_0start = onoff;\n\n\tif (index & FC_DMA_SUBADDR_1)\n\t\tv0xc.dma_0xc.dma_1start = onoff;\n\n\tfc->write_ibi_reg(fc, r0x0, v0x0);\n\tfc->write_ibi_reg(fc, r0xc, v0xc);\n\n\tdeb_rdump(\"reg: %03x: %x\\n\", r0x0, v0x0.raw);\n\tdeb_rdump(\"reg: %03x: %x\\n\", r0xc, v0xc.raw);\n\treturn 0;\n}\nEXPORT_SYMBOL(flexcop_dma_xfer_control);\n\nstatic int flexcop_dma_remap(struct flexcop_device *fc,\n\t\tflexcop_dma_index_t dma_idx,\n\t\tint onoff)\n{\n\tflexcop_ibi_register r = (dma_idx & FC_DMA_1) ? dma1_00c : dma2_01c;\n\tflexcop_ibi_value v = fc->read_ibi_reg(fc, r);\n\n\tdeb_info(\"%s\\n\", __func__);\n\tv.dma_0xc.remap_enable = onoff;\n\tfc->write_ibi_reg(fc, r, v);\n\treturn 0;\n}\n\nint flexcop_dma_control_size_irq(struct flexcop_device *fc,\n\t\tflexcop_dma_index_t no,\n\t\tint onoff)\n{\n\tflexcop_ibi_value v = fc->read_ibi_reg(fc, ctrl_208);\n\n\tif (no & FC_DMA_1)\n\t\tv.ctrl_208.DMA1_IRQ_Enable_sig = onoff;\n\n\tif (no & FC_DMA_2)\n\t\tv.ctrl_208.DMA2_IRQ_Enable_sig = onoff;\n\n\tfc->write_ibi_reg(fc, ctrl_208, v);\n\treturn 0;\n}\nEXPORT_SYMBOL(flexcop_dma_control_size_irq);\n\nint flexcop_dma_control_timer_irq(struct flexcop_device *fc,\n\t\tflexcop_dma_index_t no,\n\t\tint onoff)\n{\n\tflexcop_ibi_value v = fc->read_ibi_reg(fc, ctrl_208);\n\n\tif (no & FC_DMA_1)\n\t\tv.ctrl_208.DMA1_Timer_Enable_sig = onoff;\n\n\tif (no & FC_DMA_2)\n\t\tv.ctrl_208.DMA2_Timer_Enable_sig = onoff;\n\n\tfc->write_ibi_reg(fc, ctrl_208, v);\n\treturn 0;\n}\nEXPORT_SYMBOL(flexcop_dma_control_timer_irq);\n\n \nint flexcop_dma_config_timer(struct flexcop_device *fc,\n\t\tflexcop_dma_index_t dma_idx, u8 cycles)\n{\n\tflexcop_ibi_register r = (dma_idx & FC_DMA_1) ? dma1_004 : dma2_014;\n\tflexcop_ibi_value v = fc->read_ibi_reg(fc, r);\n\n\tflexcop_dma_remap(fc, dma_idx, 0);\n\n\tdeb_info(\"%s\\n\", __func__);\n\tv.dma_0x4_write.dmatimer = cycles;\n\tfc->write_ibi_reg(fc, r, v);\n\treturn 0;\n}\nEXPORT_SYMBOL(flexcop_dma_config_timer);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}