{
  "module_name": "flexcop-pci.c",
  "hash_id": "d838465d8bf0c477258265396ebb89a09cb7d3c7f2a33917f689bb79c9249321",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/b2c2/flexcop-pci.c",
  "human_readable_source": "\n \n\n#define FC_LOG_PREFIX \"flexcop-pci\"\n#include \"flexcop-common.h\"\n\nstatic int enable_pid_filtering = 1;\nmodule_param(enable_pid_filtering, int, 0444);\nMODULE_PARM_DESC(enable_pid_filtering,\n\t\"enable hardware pid filtering: supported values: 0 (fullts), 1\");\n\nstatic int irq_chk_intv = 100;\nmodule_param(irq_chk_intv, int, 0644);\nMODULE_PARM_DESC(irq_chk_intv, \"set the interval for IRQ streaming watchdog.\");\n\n#ifdef CONFIG_DVB_B2C2_FLEXCOP_DEBUG\n#define dprintk(level, args...) \\\n\tdo { if ((debug & (level))) printk(args); } while (0)\n#define DEBSTATUS \"\"\n#else\n#define dprintk(level, args...) no_printk(args)\n#define DEBSTATUS \" (debugging is not enabled)\"\n#endif\n\n#define deb_info(args...) dprintk(0x01, args)\n#define deb_reg(args...) dprintk(0x02, args)\n#define deb_ts(args...) dprintk(0x04, args)\n#define deb_irq(args...) dprintk(0x08, args)\n#define deb_chk(args...) dprintk(0x10, args)\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug,\n\t\"set debug level (1=info,2=regs,4=TS,8=irqdma,16=check (|-able)).\"\n\tDEBSTATUS);\n\n#define DRIVER_VERSION \"0.1\"\n#define DRIVER_NAME \"flexcop-pci\"\n#define DRIVER_AUTHOR \"Patrick Boettcher <patrick.boettcher@posteo.de>\"\n\nstruct flexcop_pci {\n\tstruct pci_dev *pdev;\n\n#define FC_PCI_INIT     0x01\n#define FC_PCI_DMA_INIT 0x02\n\tint init_state;\n\n\tvoid __iomem *io_mem;\n\tu32 irq;\n\t \n#define FC_DEFAULT_DMA1_BUFSIZE (1280 * 188)\n#define FC_DEFAULT_DMA2_BUFSIZE (10 * 188)\n\tstruct flexcop_dma dma[2];\n\n\tint active_dma1_addr;  \n\tu32 last_dma1_cur_pos;\n\t \n\tint count;\n\tint count_prev;\n\tint stream_problem;\n\n\tspinlock_t irq_lock;\n\tunsigned long last_irq;\n\n\tstruct delayed_work irq_check_work;\n\tstruct flexcop_device *fc_dev;\n};\n\nstatic int lastwreg, lastwval, lastrreg, lastrval;\n\nstatic flexcop_ibi_value flexcop_pci_read_ibi_reg(struct flexcop_device *fc,\n\t\tflexcop_ibi_register r)\n{\n\tstruct flexcop_pci *fc_pci = fc->bus_specific;\n\tflexcop_ibi_value v;\n\tv.raw = readl(fc_pci->io_mem + r);\n\n\tif (lastrreg != r || lastrval != v.raw) {\n\t\tlastrreg = r; lastrval = v.raw;\n\t\tdeb_reg(\"new rd: %3x: %08x\\n\", r, v.raw);\n\t}\n\n\treturn v;\n}\n\nstatic int flexcop_pci_write_ibi_reg(struct flexcop_device *fc,\n\t\tflexcop_ibi_register r, flexcop_ibi_value v)\n{\n\tstruct flexcop_pci *fc_pci = fc->bus_specific;\n\n\tif (lastwreg != r || lastwval != v.raw) {\n\t\tlastwreg = r; lastwval = v.raw;\n\t\tdeb_reg(\"new wr: %3x: %08x\\n\", r, v.raw);\n\t}\n\n\twritel(v.raw, fc_pci->io_mem + r);\n\treturn 0;\n}\n\nstatic void flexcop_pci_irq_check_work(struct work_struct *work)\n{\n\tstruct flexcop_pci *fc_pci =\n\t\tcontainer_of(work, struct flexcop_pci, irq_check_work.work);\n\tstruct flexcop_device *fc = fc_pci->fc_dev;\n\n\tif (fc->feedcount) {\n\n\t\tif (fc_pci->count == fc_pci->count_prev) {\n\t\t\tdeb_chk(\"no IRQ since the last check\\n\");\n\t\t\tif (fc_pci->stream_problem++ == 3) {\n\t\t\t\tstruct dvb_demux_feed *feed;\n\t\t\t\tdeb_info(\"flexcop-pci: stream problem, resetting pid filter\\n\");\n\n\t\t\t\tspin_lock_irq(&fc->demux.lock);\n\t\t\t\tlist_for_each_entry(feed, &fc->demux.feed_list,\n\t\t\t\t\t\tlist_head) {\n\t\t\t\t\tflexcop_pid_feed_control(fc, feed, 0);\n\t\t\t\t}\n\n\t\t\t\tlist_for_each_entry(feed, &fc->demux.feed_list,\n\t\t\t\t\t\tlist_head) {\n\t\t\t\t\tflexcop_pid_feed_control(fc, feed, 1);\n\t\t\t\t}\n\t\t\t\tspin_unlock_irq(&fc->demux.lock);\n\n\t\t\t\tfc_pci->stream_problem = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tfc_pci->stream_problem = 0;\n\t\t\tfc_pci->count_prev = fc_pci->count;\n\t\t}\n\t}\n\n\tschedule_delayed_work(&fc_pci->irq_check_work,\n\t\t\tmsecs_to_jiffies(irq_chk_intv < 100 ? 100 : irq_chk_intv));\n}\n\n \nstatic irqreturn_t flexcop_pci_isr(int irq, void *dev_id)\n{\n\tstruct flexcop_pci *fc_pci = dev_id;\n\tstruct flexcop_device *fc = fc_pci->fc_dev;\n\tunsigned long flags;\n\tflexcop_ibi_value v;\n\tirqreturn_t ret = IRQ_HANDLED;\n\n\tspin_lock_irqsave(&fc_pci->irq_lock, flags);\n\tv = fc->read_ibi_reg(fc, irq_20c);\n\n\t \n\tif (v.irq_20c.Data_receiver_error)\n\t\tdeb_chk(\"data receiver error\\n\");\n\tif (v.irq_20c.Continuity_error_flag)\n\t\tdeb_chk(\"Continuity error flag is set\\n\");\n\tif (v.irq_20c.LLC_SNAP_FLAG_set)\n\t\tdeb_chk(\"LLC_SNAP_FLAG_set is set\\n\");\n\tif (v.irq_20c.Transport_Error)\n\t\tdeb_chk(\"Transport error\\n\");\n\n\tif ((fc_pci->count % 1000) == 0)\n\t\tdeb_chk(\"%d valid irq took place so far\\n\", fc_pci->count);\n\n\tif (v.irq_20c.DMA1_IRQ_Status == 1) {\n\t\tif (fc_pci->active_dma1_addr == 0)\n\t\t\tflexcop_pass_dmx_packets(fc_pci->fc_dev,\n\t\t\t\t\tfc_pci->dma[0].cpu_addr0,\n\t\t\t\t\tfc_pci->dma[0].size / 188);\n\t\telse\n\t\t\tflexcop_pass_dmx_packets(fc_pci->fc_dev,\n\t\t\t\t\tfc_pci->dma[0].cpu_addr1,\n\t\t\t\t\tfc_pci->dma[0].size / 188);\n\n\t\tdeb_irq(\"page change to page: %d\\n\",!fc_pci->active_dma1_addr);\n\t\tfc_pci->active_dma1_addr = !fc_pci->active_dma1_addr;\n\t\t \n\t} else if (v.irq_20c.DMA1_Timer_Status == 1) {\n\t\tdma_addr_t cur_addr =\n\t\t\tfc->read_ibi_reg(fc,dma1_008).dma_0x8.dma_cur_addr << 2;\n\t\tu32 cur_pos = cur_addr - fc_pci->dma[0].dma_addr0;\n\t\tif (cur_pos > fc_pci->dma[0].size * 2)\n\t\t\tgoto error;\n\n\t\tdeb_irq(\"%u irq: %08x cur_addr: %llx: cur_pos: %08x, last_cur_pos: %08x \",\n\t\t\t\tjiffies_to_usecs(jiffies - fc_pci->last_irq),\n\t\t\t\tv.raw, (unsigned long long)cur_addr, cur_pos,\n\t\t\t\tfc_pci->last_dma1_cur_pos);\n\t\tfc_pci->last_irq = jiffies;\n\n\t\t \n\t\tif (cur_pos < fc_pci->last_dma1_cur_pos) {\n\t\t\tdeb_irq(\" end was reached: passing %d bytes \",\n\t\t\t\t(fc_pci->dma[0].size*2 - 1) -\n\t\t\t\tfc_pci->last_dma1_cur_pos);\n\t\t\tflexcop_pass_dmx_data(fc_pci->fc_dev,\n\t\t\t\tfc_pci->dma[0].cpu_addr0 +\n\t\t\t\t\tfc_pci->last_dma1_cur_pos,\n\t\t\t\t(fc_pci->dma[0].size*2) -\n\t\t\t\t\tfc_pci->last_dma1_cur_pos);\n\t\t\tfc_pci->last_dma1_cur_pos = 0;\n\t\t}\n\n\t\tif (cur_pos > fc_pci->last_dma1_cur_pos) {\n\t\t\tdeb_irq(\" passing %d bytes \",\n\t\t\t\tcur_pos - fc_pci->last_dma1_cur_pos);\n\t\t\tflexcop_pass_dmx_data(fc_pci->fc_dev,\n\t\t\t\tfc_pci->dma[0].cpu_addr0 +\n\t\t\t\t\tfc_pci->last_dma1_cur_pos,\n\t\t\t\tcur_pos - fc_pci->last_dma1_cur_pos);\n\t\t}\n\t\tdeb_irq(\"\\n\");\n\n\t\tfc_pci->last_dma1_cur_pos = cur_pos;\n\t\tfc_pci->count++;\n\t} else {\n\t\tdeb_irq(\"isr for flexcop called, apparently without reason (%08x)\\n\",\n\t\t\tv.raw);\n\t\tret = IRQ_NONE;\n\t}\n\nerror:\n\tspin_unlock_irqrestore(&fc_pci->irq_lock, flags);\n\treturn ret;\n}\n\nstatic int flexcop_pci_stream_control(struct flexcop_device *fc, int onoff)\n{\n\tstruct flexcop_pci *fc_pci = fc->bus_specific;\n\tif (onoff) {\n\t\tflexcop_dma_config(fc, &fc_pci->dma[0], FC_DMA_1);\n\t\tflexcop_dma_config(fc, &fc_pci->dma[1], FC_DMA_2);\n\t\tflexcop_dma_config_timer(fc, FC_DMA_1, 0);\n\t\tflexcop_dma_xfer_control(fc, FC_DMA_1,\n\t\t\t\tFC_DMA_SUBADDR_0 | FC_DMA_SUBADDR_1, 1);\n\t\tdeb_irq(\"DMA xfer enabled\\n\");\n\n\t\tfc_pci->last_dma1_cur_pos = 0;\n\t\tflexcop_dma_control_timer_irq(fc, FC_DMA_1, 1);\n\t\tdeb_irq(\"IRQ enabled\\n\");\n\t\tfc_pci->count_prev = fc_pci->count;\n\t} else {\n\t\tflexcop_dma_control_timer_irq(fc, FC_DMA_1, 0);\n\t\tdeb_irq(\"IRQ disabled\\n\");\n\n\t\tflexcop_dma_xfer_control(fc, FC_DMA_1,\n\t\t\t FC_DMA_SUBADDR_0 | FC_DMA_SUBADDR_1, 0);\n\t\tdeb_irq(\"DMA xfer disabled\\n\");\n\t}\n\treturn 0;\n}\n\nstatic int flexcop_pci_dma_init(struct flexcop_pci *fc_pci)\n{\n\tint ret;\n\tret = flexcop_dma_allocate(fc_pci->pdev, &fc_pci->dma[0],\n\t\t\tFC_DEFAULT_DMA1_BUFSIZE);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = flexcop_dma_allocate(fc_pci->pdev, &fc_pci->dma[1],\n\t\t\tFC_DEFAULT_DMA2_BUFSIZE);\n\tif (ret != 0) {\n\t\tflexcop_dma_free(&fc_pci->dma[0]);\n\t\treturn ret;\n\t}\n\n\tflexcop_sram_set_dest(fc_pci->fc_dev, FC_SRAM_DEST_MEDIA |\n\t\t\tFC_SRAM_DEST_NET, FC_SRAM_DEST_TARGET_DMA1);\n\tflexcop_sram_set_dest(fc_pci->fc_dev, FC_SRAM_DEST_CAO |\n\t\t\tFC_SRAM_DEST_CAI, FC_SRAM_DEST_TARGET_DMA2);\n\tfc_pci->init_state |= FC_PCI_DMA_INIT;\n\treturn ret;\n}\n\nstatic void flexcop_pci_dma_exit(struct flexcop_pci *fc_pci)\n{\n\tif (fc_pci->init_state & FC_PCI_DMA_INIT) {\n\t\tflexcop_dma_free(&fc_pci->dma[0]);\n\t\tflexcop_dma_free(&fc_pci->dma[1]);\n\t}\n\tfc_pci->init_state &= ~FC_PCI_DMA_INIT;\n}\n\nstatic int flexcop_pci_init(struct flexcop_pci *fc_pci)\n{\n\tint ret;\n\n\tinfo(\"card revision %x\", fc_pci->pdev->revision);\n\n\tif ((ret = pci_enable_device(fc_pci->pdev)) != 0)\n\t\treturn ret;\n\tpci_set_master(fc_pci->pdev);\n\n\tif ((ret = pci_request_regions(fc_pci->pdev, DRIVER_NAME)) != 0)\n\t\tgoto err_pci_disable_device;\n\n\tfc_pci->io_mem = pci_iomap(fc_pci->pdev, 0, 0x800);\n\n\tif (!fc_pci->io_mem) {\n\t\terr(\"cannot map io memory\\n\");\n\t\tret = -EIO;\n\t\tgoto err_pci_release_regions;\n\t}\n\n\tpci_set_drvdata(fc_pci->pdev, fc_pci);\n\tspin_lock_init(&fc_pci->irq_lock);\n\tif ((ret = request_irq(fc_pci->pdev->irq, flexcop_pci_isr,\n\t\t\t\t\tIRQF_SHARED, DRIVER_NAME, fc_pci)) != 0)\n\t\tgoto err_pci_iounmap;\n\n\tfc_pci->init_state |= FC_PCI_INIT;\n\treturn ret;\n\nerr_pci_iounmap:\n\tpci_iounmap(fc_pci->pdev, fc_pci->io_mem);\nerr_pci_release_regions:\n\tpci_release_regions(fc_pci->pdev);\nerr_pci_disable_device:\n\tpci_disable_device(fc_pci->pdev);\n\treturn ret;\n}\n\nstatic void flexcop_pci_exit(struct flexcop_pci *fc_pci)\n{\n\tif (fc_pci->init_state & FC_PCI_INIT) {\n\t\tfree_irq(fc_pci->pdev->irq, fc_pci);\n\t\tpci_iounmap(fc_pci->pdev, fc_pci->io_mem);\n\t\tpci_release_regions(fc_pci->pdev);\n\t\tpci_disable_device(fc_pci->pdev);\n\t}\n\tfc_pci->init_state &= ~FC_PCI_INIT;\n}\n\nstatic int flexcop_pci_probe(struct pci_dev *pdev,\n\t\tconst struct pci_device_id *ent)\n{\n\tstruct flexcop_device *fc;\n\tstruct flexcop_pci *fc_pci;\n\tint ret = -ENOMEM;\n\n\tif ((fc = flexcop_device_kmalloc(sizeof(struct flexcop_pci))) == NULL) {\n\t\terr(\"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfc_pci = fc->bus_specific;\n\tfc_pci->fc_dev = fc;\n\n\tfc->read_ibi_reg = flexcop_pci_read_ibi_reg;\n\tfc->write_ibi_reg = flexcop_pci_write_ibi_reg;\n\tfc->i2c_request = flexcop_i2c_request;\n\tfc->get_mac_addr = flexcop_eeprom_check_mac_addr;\n\tfc->stream_control = flexcop_pci_stream_control;\n\n\tif (enable_pid_filtering)\n\t\tinfo(\"will use the HW PID filter.\");\n\telse\n\t\tinfo(\"will pass the complete TS to the demuxer.\");\n\n\tfc->pid_filtering = enable_pid_filtering;\n\tfc->bus_type = FC_PCI;\n\tfc->dev = &pdev->dev;\n\tfc->owner = THIS_MODULE;\n\n\t \n\tfc_pci->pdev = pdev;\n\tif ((ret = flexcop_pci_init(fc_pci)) != 0)\n\t\tgoto err_kfree;\n\n\t \n\tif ((ret = flexcop_device_initialize(fc)) != 0)\n\t\tgoto err_pci_exit;\n\n\t \n\tif ((ret = flexcop_pci_dma_init(fc_pci)) != 0)\n\t\tgoto err_fc_exit;\n\n\tINIT_DELAYED_WORK(&fc_pci->irq_check_work, flexcop_pci_irq_check_work);\n\n\tif (irq_chk_intv > 0)\n\t\tschedule_delayed_work(&fc_pci->irq_check_work,\n\t\t\t\tmsecs_to_jiffies(irq_chk_intv < 100 ?\n\t\t\t\t\t100 :\n\t\t\t\t\tirq_chk_intv));\n\treturn ret;\n\nerr_fc_exit:\n\tflexcop_device_exit(fc);\nerr_pci_exit:\n\tflexcop_pci_exit(fc_pci);\nerr_kfree:\n\tflexcop_device_kfree(fc);\n\treturn ret;\n}\n\n \nstatic void flexcop_pci_remove(struct pci_dev *pdev)\n{\n\tstruct flexcop_pci *fc_pci = pci_get_drvdata(pdev);\n\n\tif (irq_chk_intv > 0)\n\t\tcancel_delayed_work(&fc_pci->irq_check_work);\n\n\tflexcop_pci_dma_exit(fc_pci);\n\tflexcop_device_exit(fc_pci->fc_dev);\n\tflexcop_pci_exit(fc_pci);\n\tflexcop_device_kfree(fc_pci->fc_dev);\n}\n\nstatic const struct pci_device_id flexcop_pci_tbl[] = {\n\t{ PCI_DEVICE(0x13d0, 0x2103) },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(pci, flexcop_pci_tbl);\n\nstatic struct pci_driver flexcop_pci_driver = {\n\t.name     = \"b2c2_flexcop_pci\",\n\t.id_table = flexcop_pci_tbl,\n\t.probe    = flexcop_pci_probe,\n\t.remove   = flexcop_pci_remove,\n};\n\nmodule_pci_driver(flexcop_pci_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_NAME);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}