{
  "module_name": "ddbridge-i2c.h",
  "hash_id": "8eb329a904742448a7d52c0ea64f9da88e78727e468827a85a30633e8363bbee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ddbridge/ddbridge-i2c.h",
  "human_readable_source": " \n \n\n#ifndef __DDBRIDGE_I2C_H__\n#define __DDBRIDGE_I2C_H__\n\n#include <linux/i2c.h>\n\n#include \"ddbridge.h\"\n\n \n\nvoid ddb_i2c_release(struct ddb *dev);\nint ddb_i2c_init(struct ddb *dev);\n\n \n\nstatic int __maybe_unused i2c_io(struct i2c_adapter *adapter, u8 adr,\n\t\t\t\t u8 *wbuf, u32 wlen, u8 *rbuf, u32 rlen)\n{\n\tstruct i2c_msg msgs[2] = { { .addr = adr,  .flags = 0,\n\t\t\t\t     .buf  = wbuf, .len   = wlen },\n\t\t\t\t   { .addr = adr,  .flags = I2C_M_RD,\n\t\t\t\t     .buf  = rbuf, .len   = rlen } };\n\n\treturn (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;\n}\n\nstatic int __maybe_unused i2c_write(struct i2c_adapter *adap, u8 adr,\n\t\t\t\t    u8 *data, int len)\n{\n\tstruct i2c_msg msg = { .addr = adr, .flags = 0,\n\t\t\t       .buf = data, .len = len };\n\n\treturn (i2c_transfer(adap, &msg, 1) == 1) ? 0 : -1;\n}\n\nstatic int __maybe_unused i2c_read(struct i2c_adapter *adapter, u8 adr, u8 *val)\n{\n\tstruct i2c_msg msgs[1] = { { .addr = adr, .flags = I2C_M_RD,\n\t\t\t\t     .buf  = val, .len   = 1 } };\n\n\treturn (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;\n}\n\nstatic int __maybe_unused i2c_read_regs(struct i2c_adapter *adapter,\n\t\t\t\t\tu8 adr, u8 reg, u8 *val, u8 len)\n{\n\tstruct i2c_msg msgs[2] = { { .addr = adr,  .flags = 0,\n\t\t\t\t     .buf  = &reg, .len   = 1 },\n\t\t\t\t   { .addr = adr,  .flags = I2C_M_RD,\n\t\t\t\t     .buf  = val,  .len   = len } };\n\n\treturn (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;\n}\n\nstatic int __maybe_unused i2c_read_regs16(struct i2c_adapter *adapter,\n\t\t\t\t\t  u8 adr, u16 reg, u8 *val, u8 len)\n{\n\tu8 msg[2] = { reg >> 8, reg & 0xff };\n\tstruct i2c_msg msgs[2] = { { .addr = adr, .flags = 0,\n\t\t\t\t     .buf  = msg, .len   = 2 },\n\t\t\t\t   { .addr = adr, .flags = I2C_M_RD,\n\t\t\t\t     .buf  = val, .len   = len } };\n\n\treturn (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;\n}\n\nstatic int __maybe_unused i2c_write_reg16(struct i2c_adapter *adap,\n\t\t\t\t\t  u8 adr, u16 reg, u8 val)\n{\n\tu8 msg[3] = { reg >> 8, reg & 0xff, val };\n\n\treturn i2c_write(adap, adr, msg, 3);\n}\n\nstatic int __maybe_unused i2c_write_reg(struct i2c_adapter *adap,\n\t\t\t\t\tu8 adr, u8 reg, u8 val)\n{\n\tu8 msg[2] = { reg, val };\n\n\treturn i2c_write(adap, adr, msg, 2);\n}\n\nstatic int __maybe_unused i2c_read_reg16(struct i2c_adapter *adapter,\n\t\t\t\t\t u8 adr, u16 reg, u8 *val)\n{\n\treturn i2c_read_regs16(adapter, adr, reg, val, 1);\n}\n\nstatic int __maybe_unused i2c_read_reg(struct i2c_adapter *adapter,\n\t\t\t\t       u8 adr, u8 reg, u8 *val)\n{\n\treturn i2c_read_regs(adapter, adr, reg, val, 1);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}