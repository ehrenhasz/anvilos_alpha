{
  "module_name": "ddbridge-i2c.c",
  "hash_id": "ea603057bf87b75dad09e21392f35f26384dc33843f4a65cc353deb76caba9f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ddbridge/ddbridge-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/timer.h>\n#include <linux/i2c.h>\n#include <linux/swab.h>\n#include <linux/vmalloc.h>\n\n#include \"ddbridge.h\"\n#include \"ddbridge-i2c.h\"\n#include \"ddbridge-regs.h\"\n#include \"ddbridge-io.h\"\n\n \n\nstatic int ddb_i2c_cmd(struct ddb_i2c *i2c, u32 adr, u32 cmd)\n{\n\tstruct ddb *dev = i2c->dev;\n\tunsigned long stat;\n\tu32 val;\n\n\tddbwritel(dev, (adr << 9) | cmd, i2c->regs + I2C_COMMAND);\n\tstat = wait_for_completion_timeout(&i2c->completion, HZ);\n\tval = ddbreadl(dev, i2c->regs + I2C_COMMAND);\n\tif (stat == 0) {\n\t\tdev_err(dev->dev, \"I2C timeout, card %d, port %d, link %u\\n\",\n\t\t\tdev->nr, i2c->nr, i2c->link);\n\t\t{\n\t\t\tu32 istat = ddbreadl(dev, INTERRUPT_STATUS);\n\n\t\t\tdev_err(dev->dev, \"DDBridge IRS %08x\\n\", istat);\n\t\t\tif (i2c->link) {\n\t\t\t\tu32 listat = ddbreadl(dev,\n\t\t\t\t\tDDB_LINK_TAG(i2c->link) |\n\t\t\t\t\tINTERRUPT_STATUS);\n\n\t\t\t\tdev_err(dev->dev, \"DDBridge link %u IRS %08x\\n\",\n\t\t\t\t\ti2c->link, listat);\n\t\t\t}\n\t\t\tif (istat & 1) {\n\t\t\t\tddbwritel(dev, istat & 1, INTERRUPT_ACK);\n\t\t\t} else {\n\t\t\t\tu32 mon = ddbreadl(dev,\n\t\t\t\t\ti2c->regs + I2C_MONITOR);\n\n\t\t\t\tdev_err(dev->dev, \"I2C cmd=%08x mon=%08x\\n\",\n\t\t\t\t\tval, mon);\n\t\t\t}\n\t\t}\n\t\treturn -EIO;\n\t}\n\tval &= 0x70000;\n\tif (val == 0x20000)\n\t\tdev_err(dev->dev, \"I2C bus error\\n\");\n\tif (val)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int ddb_i2c_master_xfer(struct i2c_adapter *adapter,\n\t\t\t       struct i2c_msg msg[], int num)\n{\n\tstruct ddb_i2c *i2c = (struct ddb_i2c *)i2c_get_adapdata(adapter);\n\tstruct ddb *dev = i2c->dev;\n\tu8 addr = 0;\n\n\taddr = msg[0].addr;\n\tif (msg[0].len > i2c->bsize)\n\t\treturn -EIO;\n\tswitch (num) {\n\tcase 1:\n\t\tif (msg[0].flags & I2C_M_RD) {\n\t\t\tddbwritel(dev, msg[0].len << 16,\n\t\t\t\t  i2c->regs + I2C_TASKLENGTH);\n\t\t\tif (ddb_i2c_cmd(i2c, addr, 3))\n\t\t\t\tbreak;\n\t\t\tddbcpyfrom(dev, msg[0].buf,\n\t\t\t\t   i2c->rbuf, msg[0].len);\n\t\t\treturn num;\n\t\t}\n\t\tddbcpyto(dev, i2c->wbuf, msg[0].buf, msg[0].len);\n\t\tddbwritel(dev, msg[0].len, i2c->regs + I2C_TASKLENGTH);\n\t\tif (ddb_i2c_cmd(i2c, addr, 2))\n\t\t\tbreak;\n\t\treturn num;\n\tcase 2:\n\t\tif ((msg[0].flags & I2C_M_RD) == I2C_M_RD)\n\t\t\tbreak;\n\t\tif ((msg[1].flags & I2C_M_RD) != I2C_M_RD)\n\t\t\tbreak;\n\t\tif (msg[1].len > i2c->bsize)\n\t\t\tbreak;\n\t\tddbcpyto(dev, i2c->wbuf, msg[0].buf, msg[0].len);\n\t\tddbwritel(dev, msg[0].len | (msg[1].len << 16),\n\t\t\t  i2c->regs + I2C_TASKLENGTH);\n\t\tif (ddb_i2c_cmd(i2c, addr, 1))\n\t\t\tbreak;\n\t\tddbcpyfrom(dev, msg[1].buf,\n\t\t\t   i2c->rbuf,\n\t\t\t   msg[1].len);\n\t\treturn num;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EIO;\n}\n\nstatic u32 ddb_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm ddb_i2c_algo = {\n\t.master_xfer   = ddb_i2c_master_xfer,\n\t.functionality = ddb_i2c_functionality,\n};\n\nvoid ddb_i2c_release(struct ddb *dev)\n{\n\tint i;\n\tstruct ddb_i2c *i2c;\n\n\tfor (i = 0; i < dev->i2c_num; i++) {\n\t\ti2c = &dev->i2c[i];\n\t\ti2c_del_adapter(&i2c->adap);\n\t}\n}\n\nstatic void i2c_handler(void *priv)\n{\n\tstruct ddb_i2c *i2c = (struct ddb_i2c *)priv;\n\n\tcomplete(&i2c->completion);\n}\n\nstatic int ddb_i2c_add(struct ddb *dev, struct ddb_i2c *i2c,\n\t\t       const struct ddb_regmap *regmap, int link,\n\t\t       int i, int num)\n{\n\tstruct i2c_adapter *adap;\n\n\ti2c->nr = i;\n\ti2c->dev = dev;\n\ti2c->link = link;\n\ti2c->bsize = regmap->i2c_buf->size;\n\ti2c->wbuf = DDB_LINK_TAG(link) |\n\t\t(regmap->i2c_buf->base + i2c->bsize * i);\n\ti2c->rbuf = i2c->wbuf;  \n\ti2c->regs = DDB_LINK_TAG(link) |\n\t\t(regmap->i2c->base + regmap->i2c->size * i);\n\tddbwritel(dev, I2C_SPEED_100, i2c->regs + I2C_TIMING);\n\tddbwritel(dev, ((i2c->rbuf & 0xffff) << 16) | (i2c->wbuf & 0xffff),\n\t\t  i2c->regs + I2C_TASKADDRESS);\n\tinit_completion(&i2c->completion);\n\n\tadap = &i2c->adap;\n\ti2c_set_adapdata(adap, i2c);\n#ifdef I2C_ADAP_CLASS_TV_DIGITAL\n\tadap->class = I2C_ADAP_CLASS_TV_DIGITAL | I2C_CLASS_TV_ANALOG;\n#else\n#ifdef I2C_CLASS_TV_ANALOG\n\tadap->class = I2C_CLASS_TV_ANALOG;\n#endif\n#endif\n\tsnprintf(adap->name, I2C_NAME_SIZE, \"ddbridge_%02x.%x.%x\",\n\t\t dev->nr, i2c->link, i);\n\tadap->algo = &ddb_i2c_algo;\n\tadap->algo_data = (void *)i2c;\n\tadap->dev.parent = dev->dev;\n\treturn i2c_add_adapter(adap);\n}\n\nint ddb_i2c_init(struct ddb *dev)\n{\n\tint stat = 0;\n\tu32 i, j, num = 0, l, base;\n\tstruct ddb_i2c *i2c;\n\tstruct i2c_adapter *adap;\n\tconst struct ddb_regmap *regmap;\n\n\tfor (l = 0; l < DDB_MAX_LINK; l++) {\n\t\tif (!dev->link[l].info)\n\t\t\tcontinue;\n\t\tregmap = dev->link[l].info->regmap;\n\t\tif (!regmap || !regmap->i2c)\n\t\t\tcontinue;\n\t\tbase = regmap->irq_base_i2c;\n\t\tfor (i = 0; i < regmap->i2c->num; i++) {\n\t\t\tif (!(dev->link[l].info->i2c_mask & (1 << i)))\n\t\t\t\tcontinue;\n\t\t\ti2c = &dev->i2c[num];\n\t\t\tddb_irq_set(dev, l, i + base, i2c_handler, i2c);\n\t\t\tstat = ddb_i2c_add(dev, i2c, regmap, l, i, num);\n\t\t\tif (stat)\n\t\t\t\tbreak;\n\t\t\tnum++;\n\t\t}\n\t}\n\tif (stat) {\n\t\tfor (j = 0; j < num; j++) {\n\t\t\ti2c = &dev->i2c[j];\n\t\t\tadap = &i2c->adap;\n\t\t\ti2c_del_adapter(adap);\n\t\t}\n\t} else {\n\t\tdev->i2c_num = num;\n\t}\n\n\treturn stat;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}