{
  "module_name": "ddbridge-dummy-fe.c",
  "hash_id": "e4c4cada48023e61be9f4cafe04f8e75d0f57422f65536a3100be6054aad76db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ddbridge/ddbridge-dummy-fe.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <media/dvb_frontend.h>\n#include \"ddbridge-dummy-fe.h\"\n\nstruct ddbridge_dummy_fe_state {\n\tstruct dvb_frontend frontend;\n};\n\nstatic int ddbridge_dummy_fe_read_status(struct dvb_frontend *fe,\n\t\t\t\t    enum fe_status *status)\n{\n\t*status = FE_HAS_SIGNAL\n\t\t| FE_HAS_CARRIER\n\t\t| FE_HAS_VITERBI\n\t\t| FE_HAS_SYNC\n\t\t| FE_HAS_LOCK;\n\n\treturn 0;\n}\n\nstatic int ddbridge_dummy_fe_read_ber(struct dvb_frontend *fe, u32 *ber)\n{\n\t*ber = 0;\n\treturn 0;\n}\n\nstatic int ddbridge_dummy_fe_read_signal_strength(struct dvb_frontend *fe,\n\t\t\t\t\t     u16 *strength)\n{\n\t*strength = 0;\n\treturn 0;\n}\n\nstatic int ddbridge_dummy_fe_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\t*snr = 0;\n\treturn 0;\n}\n\nstatic int ddbridge_dummy_fe_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\n{\n\t*ucblocks = 0;\n\treturn 0;\n}\n\n \nstatic int ddbridge_dummy_fe_get_frontend(struct dvb_frontend *fe,\n\t\t\t\t     struct dtv_frontend_properties *p)\n{\n\treturn 0;\n}\n\nstatic int ddbridge_dummy_fe_set_frontend(struct dvb_frontend *fe)\n{\n\tif (fe->ops.tuner_ops.set_params) {\n\t\tfe->ops.tuner_ops.set_params(fe);\n\t\tif (fe->ops.i2c_gate_ctrl)\n\t\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int ddbridge_dummy_fe_sleep(struct dvb_frontend *fe)\n{\n\treturn 0;\n}\n\nstatic int ddbridge_dummy_fe_init(struct dvb_frontend *fe)\n{\n\treturn 0;\n}\n\nstatic void ddbridge_dummy_fe_release(struct dvb_frontend *fe)\n{\n\tstruct ddbridge_dummy_fe_state *state = fe->demodulator_priv;\n\n\tkfree(state);\n}\n\nstatic const struct dvb_frontend_ops ddbridge_dummy_fe_qam_ops;\n\nstruct dvb_frontend *ddbridge_dummy_fe_qam_attach(void)\n{\n\tstruct ddbridge_dummy_fe_state *state = NULL;\n\n\t \n\tstate = kzalloc(sizeof(struct ddbridge_dummy_fe_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t \n\tmemcpy(&state->frontend.ops,\n\t       &ddbridge_dummy_fe_qam_ops,\n\t       sizeof(struct dvb_frontend_ops));\n\n\tstate->frontend.demodulator_priv = state;\n\treturn &state->frontend;\n}\nEXPORT_SYMBOL_GPL(ddbridge_dummy_fe_qam_attach);\n\nstatic const struct dvb_frontend_ops ddbridge_dummy_fe_qam_ops = {\n\t.delsys = { SYS_DVBC_ANNEX_A },\n\t.info = {\n\t\t.name\t\t\t= \"ddbridge dummy DVB-C\",\n\t\t.frequency_min_hz\t=  51 * MHz,\n\t\t.frequency_max_hz\t= 858 * MHz,\n\t\t.frequency_stepsize_hz\t= 62500,\n\t\t \n\t\t.symbol_rate_min\t= (57840000 / 2) / 64,\n\t\t.symbol_rate_max\t= (57840000 / 2) / 4,    \n\t\t.caps = FE_CAN_QAM_16 |\n\t\t\tFE_CAN_QAM_32 |\n\t\t\tFE_CAN_QAM_64 |\n\t\t\tFE_CAN_QAM_128 |\n\t\t\tFE_CAN_QAM_256 |\n\t\t\tFE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_INVERSION_AUTO\n\t},\n\n\t.release = ddbridge_dummy_fe_release,\n\n\t.init = ddbridge_dummy_fe_init,\n\t.sleep = ddbridge_dummy_fe_sleep,\n\n\t.set_frontend = ddbridge_dummy_fe_set_frontend,\n\t.get_frontend = ddbridge_dummy_fe_get_frontend,\n\n\t.read_status = ddbridge_dummy_fe_read_status,\n\t.read_ber = ddbridge_dummy_fe_read_ber,\n\t.read_signal_strength = ddbridge_dummy_fe_read_signal_strength,\n\t.read_snr = ddbridge_dummy_fe_read_snr,\n\t.read_ucblocks = ddbridge_dummy_fe_read_ucblocks,\n};\n\nMODULE_DESCRIPTION(\"ddbridge dummy Frontend\");\nMODULE_AUTHOR(\"Emard\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}