{
  "module_name": "ddbridge-ci.c",
  "hash_id": "e6a8244634b3ee805246ea5e01ccc2d3cbc6db012925182fd019a23c6306a9ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ddbridge/ddbridge-ci.c",
  "human_readable_source": "\n \n\n#include \"ddbridge.h\"\n#include \"ddbridge-regs.h\"\n#include \"ddbridge-ci.h\"\n#include \"ddbridge-io.h\"\n#include \"ddbridge-i2c.h\"\n\n#include \"cxd2099.h\"\n\n \n\nstatic int wait_ci_ready(struct ddb_ci *ci)\n{\n\tu32 count = 10;\n\n\tndelay(500);\n\tdo {\n\t\tif (ddbreadl(ci->port->dev,\n\t\t\t     CI_CONTROL(ci->nr)) & CI_READY)\n\t\t\tbreak;\n\t\tusleep_range(1, 2);\n\t\tif ((--count) == 0)\n\t\t\treturn -1;\n\t} while (1);\n\treturn 0;\n}\n\nstatic int read_attribute_mem(struct dvb_ca_en50221 *ca,\n\t\t\t      int slot, int address)\n{\n\tstruct ddb_ci *ci = ca->data;\n\tu32 val, off = (address >> 1) & (CI_BUFFER_SIZE - 1);\n\n\tif (address > CI_BUFFER_SIZE)\n\t\treturn -1;\n\tddbwritel(ci->port->dev, CI_READ_CMD | (1 << 16) | address,\n\t\t  CI_DO_READ_ATTRIBUTES(ci->nr));\n\twait_ci_ready(ci);\n\tval = 0xff & ddbreadl(ci->port->dev, CI_BUFFER(ci->nr) + off);\n\treturn val;\n}\n\nstatic int write_attribute_mem(struct dvb_ca_en50221 *ca, int slot,\n\t\t\t       int address, u8 value)\n{\n\tstruct ddb_ci *ci = ca->data;\n\n\tddbwritel(ci->port->dev, CI_WRITE_CMD | (value << 16) | address,\n\t\t  CI_DO_ATTRIBUTE_RW(ci->nr));\n\twait_ci_ready(ci);\n\treturn 0;\n}\n\nstatic int read_cam_control(struct dvb_ca_en50221 *ca,\n\t\t\t    int slot, u8 address)\n{\n\tu32 count = 100;\n\tstruct ddb_ci *ci = ca->data;\n\tu32 res;\n\n\tddbwritel(ci->port->dev, CI_READ_CMD | address,\n\t\t  CI_DO_IO_RW(ci->nr));\n\tndelay(500);\n\tdo {\n\t\tres = ddbreadl(ci->port->dev, CI_READDATA(ci->nr));\n\t\tif (res & CI_READY)\n\t\t\tbreak;\n\t\tusleep_range(1, 2);\n\t\tif ((--count) == 0)\n\t\t\treturn -1;\n\t} while (1);\n\treturn 0xff & res;\n}\n\nstatic int write_cam_control(struct dvb_ca_en50221 *ca, int slot,\n\t\t\t     u8 address, u8 value)\n{\n\tstruct ddb_ci *ci = ca->data;\n\n\tddbwritel(ci->port->dev, CI_WRITE_CMD | (value << 16) | address,\n\t\t  CI_DO_IO_RW(ci->nr));\n\twait_ci_ready(ci);\n\treturn 0;\n}\n\nstatic int slot_reset(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct ddb_ci *ci = ca->data;\n\n\tddbwritel(ci->port->dev, CI_POWER_ON,\n\t\t  CI_CONTROL(ci->nr));\n\tmsleep(100);\n\tddbwritel(ci->port->dev, CI_POWER_ON | CI_RESET_CAM,\n\t\t  CI_CONTROL(ci->nr));\n\tddbwritel(ci->port->dev, CI_ENABLE | CI_POWER_ON | CI_RESET_CAM,\n\t\t  CI_CONTROL(ci->nr));\n\tusleep_range(20, 25);\n\tddbwritel(ci->port->dev, CI_ENABLE | CI_POWER_ON,\n\t\t  CI_CONTROL(ci->nr));\n\treturn 0;\n}\n\nstatic int slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct ddb_ci *ci = ca->data;\n\n\tddbwritel(ci->port->dev, 0, CI_CONTROL(ci->nr));\n\tmsleep(300);\n\treturn 0;\n}\n\nstatic int slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct ddb_ci *ci = ca->data;\n\tu32 val = ddbreadl(ci->port->dev, CI_CONTROL(ci->nr));\n\n\tddbwritel(ci->port->dev, val | CI_BYPASS_DISABLE,\n\t\t  CI_CONTROL(ci->nr));\n\treturn 0;\n}\n\nstatic int poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\n{\n\tstruct ddb_ci *ci = ca->data;\n\tu32 val = ddbreadl(ci->port->dev, CI_CONTROL(ci->nr));\n\tint stat = 0;\n\n\tif (val & CI_CAM_DETECT)\n\t\tstat |= DVB_CA_EN50221_POLL_CAM_PRESENT;\n\tif (val & CI_CAM_READY)\n\t\tstat |= DVB_CA_EN50221_POLL_CAM_READY;\n\treturn stat;\n}\n\nstatic struct dvb_ca_en50221 en_templ = {\n\t.read_attribute_mem  = read_attribute_mem,\n\t.write_attribute_mem = write_attribute_mem,\n\t.read_cam_control    = read_cam_control,\n\t.write_cam_control   = write_cam_control,\n\t.slot_reset          = slot_reset,\n\t.slot_shutdown       = slot_shutdown,\n\t.slot_ts_enable      = slot_ts_enable,\n\t.poll_slot_status    = poll_slot_status,\n};\n\nstatic void ci_attach(struct ddb_port *port)\n{\n\tstruct ddb_ci *ci;\n\n\tci = kzalloc(sizeof(*ci), GFP_KERNEL);\n\tif (!ci)\n\t\treturn;\n\tmemcpy(&ci->en, &en_templ, sizeof(en_templ));\n\tci->en.data = ci;\n\tport->en = &ci->en;\n\tport->en_freedata = 1;\n\tci->port = port;\n\tci->nr = port->nr - 2;\n}\n\n \n\nstatic int write_creg(struct ddb_ci *ci, u8 data, u8 mask)\n{\n\tstruct i2c_adapter *i2c = &ci->port->i2c->adap;\n\tu8 adr = (ci->port->type == DDB_CI_EXTERNAL_XO2) ? 0x12 : 0x13;\n\n\tci->port->creg = (ci->port->creg & ~mask) | data;\n\treturn i2c_write_reg(i2c, adr, 0x02, ci->port->creg);\n}\n\nstatic int read_attribute_mem_xo2(struct dvb_ca_en50221 *ca,\n\t\t\t\t  int slot, int address)\n{\n\tstruct ddb_ci *ci = ca->data;\n\tstruct i2c_adapter *i2c = &ci->port->i2c->adap;\n\tu8 adr = (ci->port->type == DDB_CI_EXTERNAL_XO2) ? 0x12 : 0x13;\n\tint res;\n\tu8 val;\n\n\tres = i2c_read_reg16(i2c, adr, 0x8000 | address, &val);\n\treturn res ? res : val;\n}\n\nstatic int write_attribute_mem_xo2(struct dvb_ca_en50221 *ca, int slot,\n\t\t\t\t   int address, u8 value)\n{\n\tstruct ddb_ci *ci = ca->data;\n\tstruct i2c_adapter *i2c = &ci->port->i2c->adap;\n\tu8 adr = (ci->port->type == DDB_CI_EXTERNAL_XO2) ? 0x12 : 0x13;\n\n\treturn i2c_write_reg16(i2c, adr, 0x8000 | address, value);\n}\n\nstatic int read_cam_control_xo2(struct dvb_ca_en50221 *ca,\n\t\t\t\tint slot, u8 address)\n{\n\tstruct ddb_ci *ci = ca->data;\n\tstruct i2c_adapter *i2c = &ci->port->i2c->adap;\n\tu8 adr = (ci->port->type == DDB_CI_EXTERNAL_XO2) ? 0x12 : 0x13;\n\tu8 val;\n\tint res;\n\n\tres = i2c_read_reg(i2c, adr, 0x20 | (address & 3), &val);\n\treturn res ? res : val;\n}\n\nstatic int write_cam_control_xo2(struct dvb_ca_en50221 *ca, int slot,\n\t\t\t\t u8 address, u8 value)\n{\n\tstruct ddb_ci *ci = ca->data;\n\tstruct i2c_adapter *i2c = &ci->port->i2c->adap;\n\tu8 adr = (ci->port->type == DDB_CI_EXTERNAL_XO2) ? 0x12 : 0x13;\n\n\treturn i2c_write_reg(i2c, adr, 0x20 | (address & 3), value);\n}\n\nstatic int slot_reset_xo2(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct ddb_ci *ci = ca->data;\n\n\tdev_dbg(ci->port->dev->dev, \"%s\\n\", __func__);\n\twrite_creg(ci, 0x01, 0x01);\n\twrite_creg(ci, 0x04, 0x04);\n\tmsleep(20);\n\twrite_creg(ci, 0x02, 0x02);\n\twrite_creg(ci, 0x00, 0x04);\n\twrite_creg(ci, 0x18, 0x18);\n\treturn 0;\n}\n\nstatic int slot_shutdown_xo2(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct ddb_ci *ci = ca->data;\n\n\tdev_dbg(ci->port->dev->dev, \"%s\\n\", __func__);\n\twrite_creg(ci, 0x10, 0xff);\n\twrite_creg(ci, 0x08, 0x08);\n\treturn 0;\n}\n\nstatic int slot_ts_enable_xo2(struct dvb_ca_en50221 *ca, int slot)\n{\n\tstruct ddb_ci *ci = ca->data;\n\n\tdev_dbg(ci->port->dev->dev, \"%s\\n\", __func__);\n\twrite_creg(ci, 0x00, 0x10);\n\treturn 0;\n}\n\nstatic int poll_slot_status_xo2(struct dvb_ca_en50221 *ca, int slot, int open)\n{\n\tstruct ddb_ci *ci = ca->data;\n\tstruct i2c_adapter *i2c = &ci->port->i2c->adap;\n\tu8 adr = (ci->port->type == DDB_CI_EXTERNAL_XO2) ? 0x12 : 0x13;\n\tu8 val = 0;\n\tint stat = 0;\n\n\ti2c_read_reg(i2c, adr, 0x01, &val);\n\n\tif (val & 2)\n\t\tstat |= DVB_CA_EN50221_POLL_CAM_PRESENT;\n\tif (val & 1)\n\t\tstat |= DVB_CA_EN50221_POLL_CAM_READY;\n\treturn stat;\n}\n\nstatic struct dvb_ca_en50221 en_xo2_templ = {\n\t.read_attribute_mem  = read_attribute_mem_xo2,\n\t.write_attribute_mem = write_attribute_mem_xo2,\n\t.read_cam_control    = read_cam_control_xo2,\n\t.write_cam_control   = write_cam_control_xo2,\n\t.slot_reset          = slot_reset_xo2,\n\t.slot_shutdown       = slot_shutdown_xo2,\n\t.slot_ts_enable      = slot_ts_enable_xo2,\n\t.poll_slot_status    = poll_slot_status_xo2,\n};\n\nstatic void ci_xo2_attach(struct ddb_port *port)\n{\n\tstruct ddb_ci *ci;\n\n\tci = kzalloc(sizeof(*ci), GFP_KERNEL);\n\tif (!ci)\n\t\treturn;\n\tmemcpy(&ci->en, &en_xo2_templ, sizeof(en_xo2_templ));\n\tci->en.data = ci;\n\tport->en = &ci->en;\n\tport->en_freedata = 1;\n\tci->port = port;\n\tci->nr = port->nr - 2;\n\tci->port->creg = 0;\n\twrite_creg(ci, 0x10, 0xff);\n\twrite_creg(ci, 0x08, 0x08);\n}\n\nstatic const struct cxd2099_cfg cxd_cfgtmpl = {\n\t.bitrate =  72000,\n\t.polarity = 1,\n\t.clock_mode = 1,\n\t.max_i2c = 512,\n};\n\nstatic int ci_cxd2099_attach(struct ddb_port *port, u32 bitrate)\n{\n\tstruct cxd2099_cfg cxd_cfg = cxd_cfgtmpl;\n\tstruct i2c_client *client;\n\n\tcxd_cfg.bitrate = bitrate;\n\tcxd_cfg.en = &port->en;\n\n\tclient = dvb_module_probe(\"cxd2099\", NULL, &port->i2c->adap,\n\t\t\t\t  0x40, &cxd_cfg);\n\tif (!client)\n\t\tgoto err;\n\n\tport->dvb[0].i2c_client[0] = client;\n\tport->en_freedata = 0;\n\treturn 0;\n\nerr:\n\tdev_err(port->dev->dev, \"CXD2099AR attach failed\\n\");\n\treturn -ENODEV;\n}\n\nint ddb_ci_attach(struct ddb_port *port, u32 bitrate)\n{\n\tint ret;\n\n\tswitch (port->type) {\n\tcase DDB_CI_EXTERNAL_SONY:\n\t\tret = ci_cxd2099_attach(port, bitrate);\n\t\tif (ret)\n\t\t\treturn -ENODEV;\n\t\tbreak;\n\tcase DDB_CI_EXTERNAL_XO2:\n\tcase DDB_CI_EXTERNAL_XO2_B:\n\t\tci_xo2_attach(port);\n\t\tbreak;\n\tcase DDB_CI_INTERNAL:\n\t\tci_attach(port);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tif (!port->en)\n\t\treturn -ENODEV;\n\tdvb_ca_en50221_init(port->dvb[0].adap, port->en, 0, 1);\n\treturn 0;\n}\n\nvoid ddb_ci_detach(struct ddb_port *port)\n{\n\tif (port->dvb[0].dev)\n\t\tdvb_unregister_device(port->dvb[0].dev);\n\tif (port->en) {\n\t\tdvb_ca_en50221_release(port->en);\n\n\t\tdvb_module_release(port->dvb[0].i2c_client[0]);\n\t\tport->dvb[0].i2c_client[0] = NULL;\n\n\t\t \n\t\tif (port->en_freedata)\n\t\t\tkfree(port->en->data);\n\n\t\tport->en = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}