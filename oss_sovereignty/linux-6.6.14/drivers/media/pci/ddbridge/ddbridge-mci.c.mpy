{
  "module_name": "ddbridge-mci.c",
  "hash_id": "91b00cf14cfdfb07dff90bb4d90cfa949c7fe58e4b5b3154c7f3e2f4bd757762",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ddbridge/ddbridge-mci.c",
  "human_readable_source": "\n \n\n#include \"ddbridge.h\"\n#include \"ddbridge-io.h\"\n#include \"ddbridge-mci.h\"\n\nstatic LIST_HEAD(mci_list);\n\nstatic int mci_reset(struct mci *state)\n{\n\tstruct ddb_link *link = state->base->link;\n\tu32 status = 0;\n\tu32 timeout = 40;\n\n\tddblwritel(link, MCI_CONTROL_RESET, MCI_CONTROL);\n\tddblwritel(link, 0, MCI_CONTROL + 4);  \n\tmsleep(300);\n\tddblwritel(link, 0, MCI_CONTROL);\n\n\twhile (1) {\n\t\tstatus = ddblreadl(link, MCI_CONTROL);\n\t\tif ((status & MCI_CONTROL_READY) == MCI_CONTROL_READY)\n\t\t\tbreak;\n\t\tif (--timeout == 0)\n\t\t\tbreak;\n\t\tmsleep(50);\n\t}\n\tif ((status & MCI_CONTROL_READY) == 0)\n\t\treturn -1;\n\tif (link->ids.device == 0x0009)\n\t\tddblwritel(link, SX8_TSCONFIG_MODE_NORMAL, SX8_TSCONFIG);\n\treturn 0;\n}\n\nint ddb_mci_config(struct mci *state, u32 config)\n{\n\tstruct ddb_link *link = state->base->link;\n\n\tif (link->ids.device != 0x0009)\n\t\treturn -EINVAL;\n\tddblwritel(link, config, SX8_TSCONFIG);\n\treturn 0;\n}\n\nstatic int _mci_cmd_unlocked(struct mci *state,\n\t\t\t     u32 *cmd, u32 cmd_len,\n\t\t\t     u32 *res, u32 res_len)\n{\n\tstruct ddb_link *link = state->base->link;\n\tu32 i, val;\n\tunsigned long stat;\n\n\tval = ddblreadl(link, MCI_CONTROL);\n\tif (val & (MCI_CONTROL_RESET | MCI_CONTROL_START_COMMAND))\n\t\treturn -EIO;\n\tif (cmd && cmd_len)\n\t\tfor (i = 0; i < cmd_len; i++)\n\t\t\tddblwritel(link, cmd[i], MCI_COMMAND + i * 4);\n\tval |= (MCI_CONTROL_START_COMMAND | MCI_CONTROL_ENABLE_DONE_INTERRUPT);\n\tddblwritel(link, val, MCI_CONTROL);\n\n\tstat = wait_for_completion_timeout(&state->base->completion, HZ);\n\tif (stat == 0) {\n\t\tdev_warn(state->base->dev, \"MCI-%d: MCI timeout\\n\", state->nr);\n\t\treturn -EIO;\n\t}\n\tif (res && res_len)\n\t\tfor (i = 0; i < res_len; i++)\n\t\t\tres[i] = ddblreadl(link, MCI_RESULT + i * 4);\n\treturn 0;\n}\n\nint ddb_mci_cmd(struct mci *state,\n\t\tstruct mci_command *command,\n\t\tstruct mci_result *result)\n{\n\tint stat;\n\n\tmutex_lock(&state->base->mci_lock);\n\tstat = _mci_cmd_unlocked(state,\n\t\t\t\t (u32 *)command, sizeof(*command) / sizeof(u32),\n\t\t\t\t (u32 *)result,\tsizeof(*result) / sizeof(u32));\n\tmutex_unlock(&state->base->mci_lock);\n\treturn stat;\n}\n\nstatic void mci_handler(void *priv)\n{\n\tstruct mci_base *base = (struct mci_base *)priv;\n\n\tcomplete(&base->completion);\n}\n\nstatic struct mci_base *match_base(void *key)\n{\n\tstruct mci_base *p;\n\n\tlist_for_each_entry(p, &mci_list, mci_list)\n\t\tif (p->key == key)\n\t\t\treturn p;\n\treturn NULL;\n}\n\nstatic int probe(struct mci *state)\n{\n\tmci_reset(state);\n\treturn 0;\n}\n\nstruct dvb_frontend\n*ddb_mci_attach(struct ddb_input *input, struct mci_cfg *cfg, int nr,\n\t\tint (**fn_set_input)(struct dvb_frontend *fe, int input))\n{\n\tstruct ddb_port *port = input->port;\n\tstruct ddb *dev = port->dev;\n\tstruct ddb_link *link = &dev->link[port->lnr];\n\tstruct mci_base *base;\n\tstruct mci *state;\n\tvoid *key = cfg->type ? (void *)port : (void *)link;\n\n\tstate = kzalloc(cfg->state_size, GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tbase = match_base(key);\n\tif (base) {\n\t\tbase->count++;\n\t\tstate->base = base;\n\t} else {\n\t\tbase = kzalloc(cfg->base_size, GFP_KERNEL);\n\t\tif (!base)\n\t\t\tgoto fail;\n\t\tbase->key = key;\n\t\tbase->count = 1;\n\t\tbase->link = link;\n\t\tbase->dev = dev->dev;\n\t\tmutex_init(&base->mci_lock);\n\t\tmutex_init(&base->tuner_lock);\n\t\tddb_irq_set(dev, link->nr, 0, mci_handler, base);\n\t\tinit_completion(&base->completion);\n\t\tstate->base = base;\n\t\tif (probe(state) < 0) {\n\t\t\tkfree(base);\n\t\t\tgoto fail;\n\t\t}\n\t\tlist_add(&base->mci_list, &mci_list);\n\t\tif (cfg->base_init)\n\t\t\tcfg->base_init(base);\n\t}\n\tmemcpy(&state->fe.ops, cfg->fe_ops, sizeof(struct dvb_frontend_ops));\n\tstate->fe.demodulator_priv = state;\n\tstate->nr = nr;\n\t*fn_set_input = cfg->set_input;\n\tstate->tuner = nr;\n\tstate->demod = nr;\n\tif (cfg->init)\n\t\tcfg->init(state);\n\treturn &state->fe;\nfail:\n\tkfree(state);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}