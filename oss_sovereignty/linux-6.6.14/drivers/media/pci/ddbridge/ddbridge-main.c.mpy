{
  "module_name": "ddbridge-main.c",
  "hash_id": "eefb9b3ff1bf09a3ceefe21a24169654d3eead14c7ca8badf314b6e5d736939e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ddbridge/ddbridge-main.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/timer.h>\n#include <linux/i2c.h>\n#include <linux/swab.h>\n#include <linux/vmalloc.h>\n\n#include \"ddbridge.h\"\n#include \"ddbridge-i2c.h\"\n#include \"ddbridge-regs.h\"\n#include \"ddbridge-hw.h\"\n#include \"ddbridge-io.h\"\n\n \n \n\n#ifdef CONFIG_PCI_MSI\n#ifdef CONFIG_DVB_DDBRIDGE_MSIENABLE\nstatic int msi = 1;\n#else\nstatic int msi;\n#endif\nmodule_param(msi, int, 0444);\n#ifdef CONFIG_DVB_DDBRIDGE_MSIENABLE\nMODULE_PARM_DESC(msi, \"Control MSI interrupts: 0-disable, 1-enable (default)\");\n#else\nMODULE_PARM_DESC(msi, \"Control MSI interrupts: 0-disable (default), 1-enable\");\n#endif\n#endif\n\n \n \n \n\nstatic void ddb_irq_disable(struct ddb *dev)\n{\n\tddbwritel(dev, 0, INTERRUPT_ENABLE);\n\tddbwritel(dev, 0, MSI1_ENABLE);\n}\n\nstatic void ddb_msi_exit(struct ddb *dev)\n{\n#ifdef CONFIG_PCI_MSI\n\tif (dev->msi)\n\t\tpci_free_irq_vectors(dev->pdev);\n#endif\n}\n\nstatic void ddb_irq_exit(struct ddb *dev)\n{\n\tddb_irq_disable(dev);\n\tif (dev->msi == 2)\n\t\tfree_irq(pci_irq_vector(dev->pdev, 1), dev);\n\tfree_irq(pci_irq_vector(dev->pdev, 0), dev);\n}\n\nstatic void ddb_remove(struct pci_dev *pdev)\n{\n\tstruct ddb *dev = (struct ddb *)pci_get_drvdata(pdev);\n\n\tddb_device_destroy(dev);\n\tddb_ports_detach(dev);\n\tddb_i2c_release(dev);\n\n\tddb_irq_exit(dev);\n\tddb_msi_exit(dev);\n\tddb_ports_release(dev);\n\tddb_buffers_free(dev);\n\n\tddb_unmap(dev);\n\tpci_set_drvdata(pdev, NULL);\n\tpci_disable_device(pdev);\n}\n\n#ifdef CONFIG_PCI_MSI\nstatic void ddb_irq_msi(struct ddb *dev, int nr)\n{\n\tint stat;\n\n\tif (msi && pci_msi_enabled()) {\n\t\tstat = pci_alloc_irq_vectors(dev->pdev, 1, nr,\n\t\t\t\t\t     PCI_IRQ_MSI | PCI_IRQ_MSIX);\n\t\tif (stat >= 1) {\n\t\t\tdev->msi = stat;\n\t\t\tdev_info(dev->dev, \"using %d MSI interrupt(s)\\n\",\n\t\t\t\t dev->msi);\n\t\t} else {\n\t\t\tdev_info(dev->dev, \"MSI not available.\\n\");\n\t\t}\n\t}\n}\n#endif\n\nstatic int ddb_irq_init(struct ddb *dev)\n{\n\tint stat;\n\tint irq_flag = IRQF_SHARED;\n\n\tddbwritel(dev, 0x00000000, INTERRUPT_ENABLE);\n\tddbwritel(dev, 0x00000000, MSI1_ENABLE);\n\tddbwritel(dev, 0x00000000, MSI2_ENABLE);\n\tddbwritel(dev, 0x00000000, MSI3_ENABLE);\n\tddbwritel(dev, 0x00000000, MSI4_ENABLE);\n\tddbwritel(dev, 0x00000000, MSI5_ENABLE);\n\tddbwritel(dev, 0x00000000, MSI6_ENABLE);\n\tddbwritel(dev, 0x00000000, MSI7_ENABLE);\n\n#ifdef CONFIG_PCI_MSI\n\tddb_irq_msi(dev, 2);\n\n\tif (dev->msi)\n\t\tirq_flag = 0;\n\tif (dev->msi == 2) {\n\t\tstat = request_irq(pci_irq_vector(dev->pdev, 0),\n\t\t\t\t   ddb_irq_handler0, irq_flag, \"ddbridge\",\n\t\t\t\t   (void *)dev);\n\t\tif (stat < 0)\n\t\t\treturn stat;\n\t\tstat = request_irq(pci_irq_vector(dev->pdev, 1),\n\t\t\t\t   ddb_irq_handler1, irq_flag, \"ddbridge\",\n\t\t\t\t   (void *)dev);\n\t\tif (stat < 0) {\n\t\t\tfree_irq(pci_irq_vector(dev->pdev, 0), dev);\n\t\t\treturn stat;\n\t\t}\n\t} else\n#endif\n\t{\n\t\tstat = request_irq(pci_irq_vector(dev->pdev, 0),\n\t\t\t\t   ddb_irq_handler, irq_flag, \"ddbridge\",\n\t\t\t\t   (void *)dev);\n\t\tif (stat < 0)\n\t\t\treturn stat;\n\t}\n\tif (dev->msi == 2) {\n\t\tddbwritel(dev, 0x0fffff00, INTERRUPT_ENABLE);\n\t\tddbwritel(dev, 0x0000000f, MSI1_ENABLE);\n\t} else {\n\t\tddbwritel(dev, 0x0fffff0f, INTERRUPT_ENABLE);\n\t\tddbwritel(dev, 0x00000000, MSI1_ENABLE);\n\t}\n\treturn stat;\n}\n\nstatic int ddb_probe(struct pci_dev *pdev,\n\t\t     const struct pci_device_id *id)\n{\n\tstruct ddb *dev;\n\tint stat = 0;\n\n\tif (pci_enable_device(pdev) < 0)\n\t\treturn -ENODEV;\n\n\tpci_set_master(pdev);\n\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(64)))\n\t\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32)))\n\t\t\treturn -ENODEV;\n\n\tdev = vzalloc(sizeof(*dev));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->mutex);\n\tdev->has_dma = 1;\n\tdev->pdev = pdev;\n\tdev->dev = &pdev->dev;\n\tpci_set_drvdata(pdev, dev);\n\n\tdev->link[0].ids.vendor = id->vendor;\n\tdev->link[0].ids.device = id->device;\n\tdev->link[0].ids.subvendor = id->subvendor;\n\tdev->link[0].ids.subdevice = pdev->subsystem_device;\n\tdev->link[0].ids.devid = (id->device << 16) | id->vendor;\n\n\tdev->link[0].dev = dev;\n\tdev->link[0].info = get_ddb_info(id->vendor, id->device,\n\t\t\t\t\t id->subvendor, pdev->subsystem_device);\n\n\tdev_info(&pdev->dev, \"detected %s\\n\", dev->link[0].info->name);\n\n\tdev->regs_len = pci_resource_len(dev->pdev, 0);\n\tdev->regs = ioremap(pci_resource_start(dev->pdev, 0),\n\t\t\t    pci_resource_len(dev->pdev, 0));\n\n\tif (!dev->regs) {\n\t\tdev_err(&pdev->dev, \"not enough memory for register map\\n\");\n\t\tstat = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tif (ddbreadl(dev, 0) == 0xffffffff) {\n\t\tdev_err(&pdev->dev, \"cannot read registers\\n\");\n\t\tstat = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tdev->link[0].ids.hwid = ddbreadl(dev, 0);\n\tdev->link[0].ids.regmapid = ddbreadl(dev, 4);\n\n\tdev_info(&pdev->dev, \"HW %08x REGMAP %08x\\n\",\n\t\t dev->link[0].ids.hwid, dev->link[0].ids.regmapid);\n\n\tddbwritel(dev, 0, DMA_BASE_READ);\n\tddbwritel(dev, 0, DMA_BASE_WRITE);\n\n\tstat = ddb_irq_init(dev);\n\tif (stat < 0)\n\t\tgoto fail0;\n\n\tif (ddb_init(dev) == 0)\n\t\treturn 0;\n\n\tddb_irq_exit(dev);\nfail0:\n\tdev_err(&pdev->dev, \"fail0\\n\");\n\tddb_msi_exit(dev);\nfail:\n\tdev_err(&pdev->dev, \"fail\\n\");\n\n\tddb_unmap(dev);\n\tpci_set_drvdata(pdev, NULL);\n\tpci_disable_device(pdev);\n\treturn -1;\n}\n\n \n \n \n\n#define DDB_DEVICE_ANY(_device) \\\n\t\t{ PCI_DEVICE_SUB(DDVID, _device, DDVID, PCI_ANY_ID) }\n\nstatic const struct pci_device_id ddb_id_table[] = {\n\tDDB_DEVICE_ANY(0x0002),\n\tDDB_DEVICE_ANY(0x0003),\n\tDDB_DEVICE_ANY(0x0005),\n\tDDB_DEVICE_ANY(0x0006),\n\tDDB_DEVICE_ANY(0x0007),\n\tDDB_DEVICE_ANY(0x0008),\n\tDDB_DEVICE_ANY(0x0009),\n\tDDB_DEVICE_ANY(0x0011),\n\tDDB_DEVICE_ANY(0x0012),\n\tDDB_DEVICE_ANY(0x0013),\n\tDDB_DEVICE_ANY(0x0201),\n\tDDB_DEVICE_ANY(0x0203),\n\tDDB_DEVICE_ANY(0x0210),\n\tDDB_DEVICE_ANY(0x0220),\n\tDDB_DEVICE_ANY(0x0320),\n\tDDB_DEVICE_ANY(0x0321),\n\tDDB_DEVICE_ANY(0x0322),\n\tDDB_DEVICE_ANY(0x0323),\n\tDDB_DEVICE_ANY(0x0328),\n\tDDB_DEVICE_ANY(0x0329),\n\t{0}\n};\n\nMODULE_DEVICE_TABLE(pci, ddb_id_table);\n\nstatic struct pci_driver ddb_pci_driver = {\n\t.name        = \"ddbridge\",\n\t.id_table    = ddb_id_table,\n\t.probe       = ddb_probe,\n\t.remove      = ddb_remove,\n};\n\nstatic __init int module_init_ddbridge(void)\n{\n\tint stat;\n\n\tpr_info(\"Digital Devices PCIE bridge driver \"\n\t\tDDBRIDGE_VERSION\n\t\t\", Copyright (C) 2010-17 Digital Devices GmbH\\n\");\n\tstat = ddb_init_ddbridge();\n\tif (stat < 0)\n\t\treturn stat;\n\tstat = pci_register_driver(&ddb_pci_driver);\n\tif (stat < 0)\n\t\tddb_exit_ddbridge(0, stat);\n\n\treturn stat;\n}\n\nstatic __exit void module_exit_ddbridge(void)\n{\n\tpci_unregister_driver(&ddb_pci_driver);\n\tddb_exit_ddbridge(0, 0);\n}\n\nmodule_init(module_init_ddbridge);\nmodule_exit(module_exit_ddbridge);\n\nMODULE_DESCRIPTION(\"Digital Devices PCIe Bridge\");\nMODULE_AUTHOR(\"Ralph and Marcus Metzler, Metzler Brothers Systementwicklung GbR\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(DDBRIDGE_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}