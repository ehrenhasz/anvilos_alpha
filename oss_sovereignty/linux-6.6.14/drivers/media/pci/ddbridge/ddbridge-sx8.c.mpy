{
  "module_name": "ddbridge-sx8.c",
  "hash_id": "f9ebf24f069c52ebaf1c21e8fa521b23ef54bb850a6bcd51c459bb47d1c38379",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ddbridge/ddbridge-sx8.c",
  "human_readable_source": "\n \n\n#include \"ddbridge.h\"\n#include \"ddbridge-io.h\"\n#include \"ddbridge-mci.h\"\n\nstatic const u32 MCLK = (1550000000 / 12);\nstatic const u32 MAX_LDPC_BITRATE = (720000000);\nstatic const u32 MAX_DEMOD_LDPC_BITRATE = (1550000000 / 6);\n\n#define SX8_TUNER_NUM 4\n#define SX8_DEMOD_NUM 8\n#define SX8_DEMOD_NONE 0xff\n\nstruct sx8_base {\n\tstruct mci_base      mci_base;\n\n\tu8                   tuner_use_count[SX8_TUNER_NUM];\n\tu32                  gain_mode[SX8_TUNER_NUM];\n\n\tu32                  used_ldpc_bitrate[SX8_DEMOD_NUM];\n\tu8                   demod_in_use[SX8_DEMOD_NUM];\n\tu32                  iq_mode;\n\tu32                  burst_size;\n\tu32                  direct_mode;\n};\n\nstruct sx8 {\n\tstruct mci           mci;\n\n\tint                  first_time_lock;\n\tint                  started;\n\tstruct mci_result    signal_info;\n\n\tu32                  bb_mode;\n\tu32                  local_frequency;\n};\n\nstatic void release(struct dvb_frontend *fe)\n{\n\tstruct sx8 *state = fe->demodulator_priv;\n\tstruct mci_base *mci_base = state->mci.base;\n\n\tmci_base->count--;\n\tif (mci_base->count == 0) {\n\t\tlist_del(&mci_base->mci_list);\n\t\tkfree(mci_base);\n\t}\n\tkfree(state);\n}\n\nstatic int get_info(struct dvb_frontend *fe)\n{\n\tint stat;\n\tstruct sx8 *state = fe->demodulator_priv;\n\tstruct mci_command cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.command = MCI_CMD_GETSIGNALINFO;\n\tcmd.demod = state->mci.demod;\n\tstat = ddb_mci_cmd(&state->mci, &cmd, &state->signal_info);\n\treturn stat;\n}\n\nstatic int get_snr(struct dvb_frontend *fe)\n{\n\tstruct sx8 *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\n\tp->cnr.len = 1;\n\tp->cnr.stat[0].scale = FE_SCALE_DECIBEL;\n\tp->cnr.stat[0].svalue =\n\t\t(s64)state->signal_info.dvbs2_signal_info.signal_to_noise\n\t\t     * 10;\n\treturn 0;\n}\n\nstatic int get_strength(struct dvb_frontend *fe)\n{\n\tstruct sx8 *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\ts32 str;\n\n\tstr = 100000 -\n\t      (state->signal_info.dvbs2_signal_info.channel_power\n\t       * 10 + 108750);\n\tp->strength.len = 1;\n\tp->strength.stat[0].scale = FE_SCALE_DECIBEL;\n\tp->strength.stat[0].svalue = str;\n\treturn 0;\n}\n\nstatic int read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tint stat;\n\tstruct sx8 *state = fe->demodulator_priv;\n\tstruct mci_command cmd;\n\tstruct mci_result res;\n\n\tcmd.command = MCI_CMD_GETSTATUS;\n\tcmd.demod = state->mci.demod;\n\tstat = ddb_mci_cmd(&state->mci, &cmd, &res);\n\tif (stat)\n\t\treturn stat;\n\t*status = 0x00;\n\tget_info(fe);\n\tget_strength(fe);\n\tif (res.status == SX8_DEMOD_WAIT_MATYPE)\n\t\t*status = 0x0f;\n\tif (res.status == SX8_DEMOD_LOCKED) {\n\t\t*status = 0x1f;\n\t\tget_snr(fe);\n\t}\n\treturn stat;\n}\n\nstatic int mci_set_tuner(struct dvb_frontend *fe, u32 tuner, u32 on)\n{\n\tstruct sx8 *state = fe->demodulator_priv;\n\tstruct mci_base *mci_base = state->mci.base;\n\tstruct sx8_base *sx8_base = (struct sx8_base *)mci_base;\n\tstruct mci_command cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.tuner = state->mci.tuner;\n\tcmd.command = on ? SX8_CMD_INPUT_ENABLE : SX8_CMD_INPUT_DISABLE;\n\tcmd.sx8_input_enable.flags = sx8_base->gain_mode[state->mci.tuner];\n\treturn ddb_mci_cmd(&state->mci, &cmd, NULL);\n}\n\nstatic int stop(struct dvb_frontend *fe)\n{\n\tstruct sx8 *state = fe->demodulator_priv;\n\tstruct mci_base *mci_base = state->mci.base;\n\tstruct sx8_base *sx8_base = (struct sx8_base *)mci_base;\n\tstruct mci_command cmd;\n\tu32 input = state->mci.tuner;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tif (state->mci.demod != SX8_DEMOD_NONE) {\n\t\tcmd.command = MCI_CMD_STOP;\n\t\tcmd.demod = state->mci.demod;\n\t\tddb_mci_cmd(&state->mci, &cmd, NULL);\n\t\tif (sx8_base->iq_mode) {\n\t\t\tcmd.command = SX8_CMD_DISABLE_IQOUTPUT;\n\t\t\tcmd.demod = state->mci.demod;\n\t\t\tcmd.output = 0;\n\t\t\tddb_mci_cmd(&state->mci, &cmd, NULL);\n\t\t\tddb_mci_config(&state->mci, SX8_TSCONFIG_MODE_NORMAL);\n\t\t}\n\t}\n\tmutex_lock(&mci_base->tuner_lock);\n\tsx8_base->tuner_use_count[input]--;\n\tif (!sx8_base->tuner_use_count[input])\n\t\tmci_set_tuner(fe, input, 0);\n\tif (state->mci.demod < SX8_DEMOD_NUM) {\n\t\tsx8_base->demod_in_use[state->mci.demod] = 0;\n\t\tstate->mci.demod = SX8_DEMOD_NONE;\n\t}\n\tsx8_base->used_ldpc_bitrate[state->mci.nr] = 0;\n\tsx8_base->iq_mode = 0;\n\tmutex_unlock(&mci_base->tuner_lock);\n\tstate->started = 0;\n\treturn 0;\n}\n\nstatic int start(struct dvb_frontend *fe, u32 flags, u32 modmask, u32 ts_config)\n{\n\tstruct sx8 *state = fe->demodulator_priv;\n\tstruct mci_base *mci_base = state->mci.base;\n\tstruct sx8_base *sx8_base = (struct sx8_base *)mci_base;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 used_ldpc_bitrate = 0, free_ldpc_bitrate;\n\tu32 used_demods = 0;\n\tstruct mci_command cmd;\n\tu32 input = state->mci.tuner;\n\tu32 bits_per_symbol = 0;\n\tint i = -1, stat = 0;\n\n\tif (p->symbol_rate >= (MCLK / 2))\n\t\tflags &= ~1;\n\tif ((flags & 3) == 0)\n\t\treturn -EINVAL;\n\n\tif (flags & 2) {\n\t\tu32 tmp = modmask;\n\n\t\tbits_per_symbol = 1;\n\t\twhile (tmp & 1) {\n\t\t\ttmp >>= 1;\n\t\t\tbits_per_symbol++;\n\t\t}\n\t}\n\n\tmutex_lock(&mci_base->tuner_lock);\n\tif (sx8_base->iq_mode) {\n\t\tstat = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (sx8_base->direct_mode) {\n\t\tif (p->symbol_rate >= MCLK / 2) {\n\t\t\tif (state->mci.nr < 4)\n\t\t\t\ti = state->mci.nr;\n\t\t} else {\n\t\t\ti = state->mci.nr;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < SX8_DEMOD_NUM; i++) {\n\t\t\tused_ldpc_bitrate += sx8_base->used_ldpc_bitrate[i];\n\t\t\tif (sx8_base->demod_in_use[i])\n\t\t\t\tused_demods++;\n\t\t}\n\t\tif (used_ldpc_bitrate >= MAX_LDPC_BITRATE ||\n\t\t    ((ts_config & SX8_TSCONFIG_MODE_MASK) >\n\t\t     SX8_TSCONFIG_MODE_NORMAL && used_demods > 0)) {\n\t\t\tstat = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\t\tfree_ldpc_bitrate = MAX_LDPC_BITRATE - used_ldpc_bitrate;\n\t\tif (free_ldpc_bitrate > MAX_DEMOD_LDPC_BITRATE)\n\t\t\tfree_ldpc_bitrate = MAX_DEMOD_LDPC_BITRATE;\n\n\t\twhile (p->symbol_rate * bits_per_symbol > free_ldpc_bitrate)\n\t\t\tbits_per_symbol--;\n\t\tif (bits_per_symbol < 2) {\n\t\t\tstat = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tmodmask &= ((1 << (bits_per_symbol - 1)) - 1);\n\t\tif (((flags & 0x02) != 0) && modmask == 0) {\n\t\t\tstat = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\ti = (p->symbol_rate > (MCLK / 2)) ? 3 : 7;\n\t\twhile (i >= 0 && sx8_base->demod_in_use[i])\n\t\t\ti--;\n\t}\n\n\tif (i < 0) {\n\t\tstat = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tsx8_base->demod_in_use[i] = 1;\n\tsx8_base->used_ldpc_bitrate[state->mci.nr] = p->symbol_rate\n\t\t\t\t\t\t     * bits_per_symbol;\n\tstate->mci.demod = i;\n\n\tif (!sx8_base->tuner_use_count[input])\n\t\tmci_set_tuner(fe, input, 1);\n\tsx8_base->tuner_use_count[input]++;\n\tsx8_base->iq_mode = (ts_config > 1);\nunlock:\n\tmutex_unlock(&mci_base->tuner_lock);\n\tif (stat)\n\t\treturn stat;\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tif (sx8_base->iq_mode) {\n\t\tcmd.command = SX8_CMD_ENABLE_IQOUTPUT;\n\t\tcmd.demod = state->mci.demod;\n\t\tcmd.output = 0;\n\t\tddb_mci_cmd(&state->mci, &cmd, NULL);\n\t\tddb_mci_config(&state->mci, ts_config);\n\t}\n\tif (p->stream_id != NO_STREAM_ID_FILTER && p->stream_id != 0x80000000)\n\t\tflags |= 0x80;\n\tdev_dbg(mci_base->dev, \"MCI-%d: tuner=%d demod=%d\\n\",\n\t\tstate->mci.nr, state->mci.tuner, state->mci.demod);\n\tcmd.command = MCI_CMD_SEARCH_DVBS;\n\tcmd.dvbs2_search.flags = flags;\n\tcmd.dvbs2_search.s2_modulation_mask = modmask;\n\tcmd.dvbs2_search.retry = 2;\n\tcmd.dvbs2_search.frequency = p->frequency * 1000;\n\tcmd.dvbs2_search.symbol_rate = p->symbol_rate;\n\tcmd.dvbs2_search.scrambling_sequence_index =\n\t\tp->scrambling_sequence_index | 0x80000000;\n\tcmd.dvbs2_search.input_stream_id =\n\t\t(p->stream_id != NO_STREAM_ID_FILTER) ? p->stream_id : 0;\n\tcmd.tuner = state->mci.tuner;\n\tcmd.demod = state->mci.demod;\n\tcmd.output = state->mci.nr;\n\tif (p->stream_id == 0x80000000)\n\t\tcmd.output |= 0x80;\n\tstat = ddb_mci_cmd(&state->mci, &cmd, NULL);\n\tif (stat)\n\t\tstop(fe);\n\treturn stat;\n}\n\nstatic int start_iq(struct dvb_frontend *fe, u32 flags, u32 roll_off,\n\t\t    u32 ts_config)\n{\n\tstruct sx8 *state = fe->demodulator_priv;\n\tstruct mci_base *mci_base = state->mci.base;\n\tstruct sx8_base *sx8_base = (struct sx8_base *)mci_base;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 used_demods = 0;\n\tstruct mci_command cmd;\n\tu32 input = state->mci.tuner;\n\tint i, stat = 0;\n\n\tmutex_lock(&mci_base->tuner_lock);\n\tif (sx8_base->iq_mode) {\n\t\tstat = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tfor (i = 0; i < SX8_DEMOD_NUM; i++)\n\t\tif (sx8_base->demod_in_use[i])\n\t\t\tused_demods++;\n\tif (used_demods > 0) {\n\t\tstat = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tstate->mci.demod = 0;\n\tif (!sx8_base->tuner_use_count[input])\n\t\tmci_set_tuner(fe, input, 1);\n\tsx8_base->tuner_use_count[input]++;\n\tsx8_base->iq_mode = (ts_config > 1);\nunlock:\n\tmutex_unlock(&mci_base->tuner_lock);\n\tif (stat)\n\t\treturn stat;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.command = SX8_CMD_START_IQ;\n\tcmd.sx8_start_iq.flags = flags;\n\tcmd.sx8_start_iq.roll_off = roll_off;\n\tcmd.sx8_start_iq.frequency = p->frequency * 1000;\n\tcmd.sx8_start_iq.symbol_rate = p->symbol_rate;\n\tcmd.tuner = state->mci.tuner;\n\tcmd.demod = state->mci.demod;\n\tstat = ddb_mci_cmd(&state->mci, &cmd, NULL);\n\tif (stat)\n\t\tstop(fe);\n\tddb_mci_config(&state->mci, ts_config);\n\treturn stat;\n}\n\nstatic int set_parameters(struct dvb_frontend *fe)\n{\n\tint stat = 0;\n\tstruct sx8 *state = fe->demodulator_priv;\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu32 ts_config = SX8_TSCONFIG_MODE_NORMAL, iq_mode = 0, isi;\n\n\tif (state->started)\n\t\tstop(fe);\n\n\tisi = p->stream_id;\n\tif (isi != NO_STREAM_ID_FILTER)\n\t\tiq_mode = (isi & 0x30000000) >> 28;\n\n\tif (iq_mode)\n\t\tts_config = (SX8_TSCONFIG_TSHEADER | SX8_TSCONFIG_MODE_IQ);\n\tif (iq_mode < 3) {\n\t\tu32 mask;\n\n\t\tswitch (p->modulation) {\n\t\t \n\t\tcase APSK_32:\n\t\t\tmask = 0x0f;\n\t\t\tbreak;\n\t\tcase APSK_16:\n\t\t\tmask = 0x07;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmask = 0x03;\n\t\t\tbreak;\n\t\t}\n\t\tstat = start(fe, 3, mask, ts_config);\n\t} else {\n\t\tstat = start_iq(fe, 0, 4, ts_config);\n\t}\n\tif (!stat) {\n\t\tstate->started = 1;\n\t\tstate->first_time_lock = 1;\n\t\tstate->signal_info.status = SX8_DEMOD_WAIT_SIGNAL;\n\t}\n\n\treturn stat;\n}\n\nstatic int tune(struct dvb_frontend *fe, bool re_tune,\n\t\tunsigned int mode_flags,\n\t\tunsigned int *delay, enum fe_status *status)\n{\n\tint r;\n\n\tif (re_tune) {\n\t\tr = set_parameters(fe);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tr = read_status(fe, status);\n\tif (r)\n\t\treturn r;\n\n\tif (*status & FE_HAS_LOCK)\n\t\treturn 0;\n\t*delay = HZ / 10;\n\treturn 0;\n}\n\nstatic enum dvbfe_algo get_algo(struct dvb_frontend *fe)\n{\n\treturn DVBFE_ALGO_HW;\n}\n\nstatic int set_input(struct dvb_frontend *fe, int input)\n{\n\tstruct sx8 *state = fe->demodulator_priv;\n\tstruct mci_base *mci_base = state->mci.base;\n\n\tif (input >= SX8_TUNER_NUM)\n\t\treturn -EINVAL;\n\n\tstate->mci.tuner = input;\n\tdev_dbg(mci_base->dev, \"MCI-%d: input=%d\\n\", state->mci.nr, input);\n\treturn 0;\n}\n\nstatic struct dvb_frontend_ops sx8_ops = {\n\t.delsys = { SYS_DVBS, SYS_DVBS2 },\n\t.info = {\n\t\t.name\t\t\t= \"Digital Devices MaxSX8 MCI DVB-S/S2/S2X\",\n\t\t.frequency_min_hz\t=  950 * MHz,\n\t\t.frequency_max_hz\t= 2150 * MHz,\n\t\t.symbol_rate_min\t= 100000,\n\t\t.symbol_rate_max\t= 100000000,\n\t\t.caps\t\t\t= FE_CAN_INVERSION_AUTO |\n\t\t\t\t\t  FE_CAN_FEC_AUTO       |\n\t\t\t\t\t  FE_CAN_QPSK           |\n\t\t\t\t\t  FE_CAN_2G_MODULATION  |\n\t\t\t\t\t  FE_CAN_MULTISTREAM,\n\t},\n\t.get_frontend_algo\t\t= get_algo,\n\t.tune\t\t\t\t= tune,\n\t.release\t\t\t= release,\n\t.read_status\t\t\t= read_status,\n};\n\nstatic int init(struct mci *mci)\n{\n\tstruct sx8 *state = (struct sx8 *)mci;\n\n\tstate->mci.demod = SX8_DEMOD_NONE;\n\treturn 0;\n}\n\nconst struct mci_cfg ddb_max_sx8_cfg = {\n\t.type = 0,\n\t.fe_ops = &sx8_ops,\n\t.base_size = sizeof(struct sx8_base),\n\t.state_size = sizeof(struct sx8),\n\t.init = init,\n\t.set_input = set_input,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}