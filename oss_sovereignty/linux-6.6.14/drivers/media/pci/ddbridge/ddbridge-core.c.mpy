{
  "module_name": "ddbridge-core.c",
  "hash_id": "377174e696346364996b87312a4e706a8e26196b3db5f39d93ba5ce741d205f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/ddbridge/ddbridge-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/timer.h>\n#include <linux/i2c.h>\n#include <linux/swab.h>\n#include <linux/vmalloc.h>\n\n#include \"ddbridge.h\"\n#include \"ddbridge-i2c.h\"\n#include \"ddbridge-regs.h\"\n#include \"ddbridge-max.h\"\n#include \"ddbridge-ci.h\"\n#include \"ddbridge-io.h\"\n\n#include \"tda18271c2dd.h\"\n#include \"stv6110x.h\"\n#include \"stv090x.h\"\n#include \"lnbh24.h\"\n#include \"drxk.h\"\n#include \"stv0367.h\"\n#include \"stv0367_priv.h\"\n#include \"cxd2841er.h\"\n#include \"tda18212.h\"\n#include \"stv0910.h\"\n#include \"stv6111.h\"\n#include \"lnbh25.h\"\n#include \"cxd2099.h\"\n#include \"ddbridge-dummy-fe.h\"\n\n \n\n#define DDB_MAX_ADAPTER 64\n\n \n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\nstatic int adapter_alloc;\nmodule_param(adapter_alloc, int, 0444);\nMODULE_PARM_DESC(adapter_alloc,\n\t\t \"0-one adapter per io, 1-one per tab with io, 2-one per tab, 3-one for all\");\n\nstatic int ci_bitrate = 70000;\nmodule_param(ci_bitrate, int, 0444);\nMODULE_PARM_DESC(ci_bitrate, \" Bitrate in KHz for output to CI.\");\n\nstatic int ts_loop = -1;\nmodule_param(ts_loop, int, 0444);\nMODULE_PARM_DESC(ts_loop, \"TS in/out test loop on port ts_loop\");\n\nstatic int xo2_speed = 2;\nmodule_param(xo2_speed, int, 0444);\nMODULE_PARM_DESC(xo2_speed, \"default transfer speed for xo2 based duoflex, 0=55,1=75,2=90,3=104 MBit/s, default=2, use attribute to change for individual cards\");\n\n#ifdef __arm__\nstatic int alt_dma = 1;\n#else\nstatic int alt_dma;\n#endif\nmodule_param(alt_dma, int, 0444);\nMODULE_PARM_DESC(alt_dma, \"use alternative DMA buffer handling\");\n\nstatic int no_init;\nmodule_param(no_init, int, 0444);\nMODULE_PARM_DESC(no_init, \"do not initialize most devices\");\n\nstatic int stv0910_single;\nmodule_param(stv0910_single, int, 0444);\nMODULE_PARM_DESC(stv0910_single, \"use stv0910 cards as single demods\");\n\nstatic int dma_buf_num = 8;\nmodule_param(dma_buf_num, int, 0444);\nMODULE_PARM_DESC(dma_buf_num, \"Number of DMA buffers, possible values: 8-32\");\n\nstatic int dma_buf_size = 21;\nmodule_param(dma_buf_size, int, 0444);\nMODULE_PARM_DESC(dma_buf_size,\n\t\t \"DMA buffer size as multiple of 128*47, possible values: 1-43\");\n\nstatic int dummy_tuner;\nmodule_param(dummy_tuner, int, 0444);\nMODULE_PARM_DESC(dummy_tuner,\n\t\t \"attach dummy tuner to port 0 on Octopus V3 or Octopus Mini cards\");\n\n \n\nstatic DEFINE_MUTEX(redirect_lock);\n\nstatic struct workqueue_struct *ddb_wq;\n\nstatic struct ddb *ddbs[DDB_MAX_ADAPTER];\n\n \n \n \n\nstruct ddb_irq *ddb_irq_set(struct ddb *dev, u32 link, u32 nr,\n\t\t\t    void (*handler)(void *), void *data)\n{\n\tstruct ddb_irq *irq = &dev->link[link].irq[nr];\n\n\tirq->handler = handler;\n\tirq->data = data;\n\treturn irq;\n}\n\nstatic void ddb_set_dma_table(struct ddb_io *io)\n{\n\tstruct ddb *dev = io->port->dev;\n\tstruct ddb_dma *dma = io->dma;\n\tu32 i;\n\tu64 mem;\n\n\tif (!dma)\n\t\treturn;\n\tfor (i = 0; i < dma->num; i++) {\n\t\tmem = dma->pbuf[i];\n\t\tddbwritel(dev, mem & 0xffffffff, dma->bufregs + i * 8);\n\t\tddbwritel(dev, mem >> 32, dma->bufregs + i * 8 + 4);\n\t}\n\tdma->bufval = ((dma->div & 0x0f) << 16) |\n\t\t((dma->num & 0x1f) << 11) |\n\t\t((dma->size >> 7) & 0x7ff);\n}\n\nstatic void ddb_set_dma_tables(struct ddb *dev)\n{\n\tu32 i;\n\n\tfor (i = 0; i < DDB_MAX_PORT; i++) {\n\t\tif (dev->port[i].input[0])\n\t\t\tddb_set_dma_table(dev->port[i].input[0]);\n\t\tif (dev->port[i].input[1])\n\t\t\tddb_set_dma_table(dev->port[i].input[1]);\n\t\tif (dev->port[i].output)\n\t\t\tddb_set_dma_table(dev->port[i].output);\n\t}\n}\n\n \n \n \n\nstatic void ddb_redirect_dma(struct ddb *dev,\n\t\t\t     struct ddb_dma *sdma,\n\t\t\t     struct ddb_dma *ddma)\n{\n\tu32 i, base;\n\tu64 mem;\n\n\tsdma->bufval = ddma->bufval;\n\tbase = sdma->bufregs;\n\tfor (i = 0; i < ddma->num; i++) {\n\t\tmem = ddma->pbuf[i];\n\t\tddbwritel(dev, mem & 0xffffffff, base + i * 8);\n\t\tddbwritel(dev, mem >> 32, base + i * 8 + 4);\n\t}\n}\n\nstatic int ddb_unredirect(struct ddb_port *port)\n{\n\tstruct ddb_input *oredi, *iredi = NULL;\n\tstruct ddb_output *iredo = NULL;\n\n\t \n\tmutex_lock(&redirect_lock);\n\tif (port->output->dma->running) {\n\t\tmutex_unlock(&redirect_lock);\n\t\treturn -EBUSY;\n\t}\n\toredi = port->output->redi;\n\tif (!oredi)\n\t\tgoto done;\n\tif (port->input[0]) {\n\t\tiredi = port->input[0]->redi;\n\t\tiredo = port->input[0]->redo;\n\n\t\tif (iredo) {\n\t\t\tiredo->port->output->redi = oredi;\n\t\t\tif (iredo->port->input[0]) {\n\t\t\t\tiredo->port->input[0]->redi = iredi;\n\t\t\t\tddb_redirect_dma(oredi->port->dev,\n\t\t\t\t\t\t oredi->dma, iredo->dma);\n\t\t\t}\n\t\t\tport->input[0]->redo = NULL;\n\t\t\tddb_set_dma_table(port->input[0]);\n\t\t}\n\t\toredi->redi = iredi;\n\t\tport->input[0]->redi = NULL;\n\t}\n\toredi->redo = NULL;\n\tport->output->redi = NULL;\n\n\tddb_set_dma_table(oredi);\ndone:\n\tmutex_unlock(&redirect_lock);\n\treturn 0;\n}\n\nstatic int ddb_redirect(u32 i, u32 p)\n{\n\tstruct ddb *idev = ddbs[(i >> 4) & 0x3f];\n\tstruct ddb_input *input, *input2;\n\tstruct ddb *pdev = ddbs[(p >> 4) & 0x3f];\n\tstruct ddb_port *port;\n\n\tif (!idev || !pdev)\n\t\treturn -EINVAL;\n\tif (!idev->has_dma || !pdev->has_dma)\n\t\treturn -EINVAL;\n\n\tport = &pdev->port[p & 0x0f];\n\tif (!port->output)\n\t\treturn -EINVAL;\n\tif (ddb_unredirect(port))\n\t\treturn -EBUSY;\n\n\tif (i == 8)\n\t\treturn 0;\n\n\tinput = &idev->input[i & 7];\n\tif (!input)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&redirect_lock);\n\tif (port->output->dma->running || input->dma->running) {\n\t\tmutex_unlock(&redirect_lock);\n\t\treturn -EBUSY;\n\t}\n\tinput2 = port->input[0];\n\tif (input2) {\n\t\tif (input->redi) {\n\t\t\tinput2->redi = input->redi;\n\t\t\tinput->redi = NULL;\n\t\t} else {\n\t\t\tinput2->redi = input;\n\t\t}\n\t}\n\tinput->redo = port->output;\n\tport->output->redi = input;\n\n\tddb_redirect_dma(input->port->dev, input->dma, port->output->dma);\n\tmutex_unlock(&redirect_lock);\n\treturn 0;\n}\n\n \n \n \n\nstatic void dma_free(struct pci_dev *pdev, struct ddb_dma *dma, int dir)\n{\n\tint i;\n\n\tif (!dma)\n\t\treturn;\n\tfor (i = 0; i < dma->num; i++) {\n\t\tif (dma->vbuf[i]) {\n\t\t\tif (alt_dma) {\n\t\t\t\tdma_unmap_single(&pdev->dev, dma->pbuf[i],\n\t\t\t\t\t\t dma->size,\n\t\t\t\t\t\t dir ? DMA_TO_DEVICE :\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tkfree(dma->vbuf[i]);\n\t\t\t\tdma->vbuf[i] = NULL;\n\t\t\t} else {\n\t\t\t\tdma_free_coherent(&pdev->dev, dma->size,\n\t\t\t\t\t\t  dma->vbuf[i], dma->pbuf[i]);\n\t\t\t}\n\n\t\t\tdma->vbuf[i] = NULL;\n\t\t}\n\t}\n}\n\nstatic int dma_alloc(struct pci_dev *pdev, struct ddb_dma *dma, int dir)\n{\n\tint i;\n\n\tif (!dma)\n\t\treturn 0;\n\tfor (i = 0; i < dma->num; i++) {\n\t\tif (alt_dma) {\n\t\t\tdma->vbuf[i] = kmalloc(dma->size, __GFP_RETRY_MAYFAIL);\n\t\t\tif (!dma->vbuf[i])\n\t\t\t\treturn -ENOMEM;\n\t\t\tdma->pbuf[i] = dma_map_single(&pdev->dev,\n\t\t\t\t\t\t      dma->vbuf[i],\n\t\t\t\t\t\t      dma->size,\n\t\t\t\t\t\t      dir ? DMA_TO_DEVICE :\n\t\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&pdev->dev, dma->pbuf[i])) {\n\t\t\t\tkfree(dma->vbuf[i]);\n\t\t\t\tdma->vbuf[i] = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\tdma->vbuf[i] = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t\t  dma->size,\n\t\t\t\t\t\t\t  &dma->pbuf[i],\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!dma->vbuf[i])\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint ddb_buffers_alloc(struct ddb *dev)\n{\n\tint i;\n\tstruct ddb_port *port;\n\n\tfor (i = 0; i < dev->port_num; i++) {\n\t\tport = &dev->port[i];\n\t\tswitch (port->class) {\n\t\tcase DDB_PORT_TUNER:\n\t\t\tif (port->input[0]->dma)\n\t\t\t\tif (dma_alloc(dev->pdev, port->input[0]->dma, 0)\n\t\t\t\t\t< 0)\n\t\t\t\t\treturn -1;\n\t\t\tif (port->input[1]->dma)\n\t\t\t\tif (dma_alloc(dev->pdev, port->input[1]->dma, 0)\n\t\t\t\t\t< 0)\n\t\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase DDB_PORT_CI:\n\t\tcase DDB_PORT_LOOP:\n\t\t\tif (port->input[0]->dma)\n\t\t\t\tif (dma_alloc(dev->pdev, port->input[0]->dma, 0)\n\t\t\t\t\t< 0)\n\t\t\t\t\treturn -1;\n\t\t\tif (port->output->dma)\n\t\t\t\tif (dma_alloc(dev->pdev, port->output->dma, 1)\n\t\t\t\t\t< 0)\n\t\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tddb_set_dma_tables(dev);\n\treturn 0;\n}\n\nvoid ddb_buffers_free(struct ddb *dev)\n{\n\tint i;\n\tstruct ddb_port *port;\n\n\tfor (i = 0; i < dev->port_num; i++) {\n\t\tport = &dev->port[i];\n\n\t\tif (port->input[0] && port->input[0]->dma)\n\t\t\tdma_free(dev->pdev, port->input[0]->dma, 0);\n\t\tif (port->input[1] && port->input[1]->dma)\n\t\t\tdma_free(dev->pdev, port->input[1]->dma, 0);\n\t\tif (port->output && port->output->dma)\n\t\t\tdma_free(dev->pdev, port->output->dma, 1);\n\t}\n}\n\nstatic void calc_con(struct ddb_output *output, u32 *con, u32 *con2, u32 flags)\n{\n\tstruct ddb *dev = output->port->dev;\n\tu32 bitrate = output->port->obr, max_bitrate = 72000;\n\tu32 gap = 4, nco = 0;\n\n\t*con = 0x1c;\n\tif (output->port->gap != 0xffffffff) {\n\t\tflags |= 1;\n\t\tgap = output->port->gap;\n\t\tmax_bitrate = 0;\n\t}\n\tif (dev->link[0].info->type == DDB_OCTOPUS_CI && output->port->nr > 1) {\n\t\t*con = 0x10c;\n\t\tif (dev->link[0].ids.regmapid >= 0x10003 && !(flags & 1)) {\n\t\t\tif (!(flags & 2)) {\n\t\t\t\t \n\t\t\t\tmax_bitrate = 0;\n\t\t\t\tgap = 0;\n\t\t\t\tif (bitrate != 72000) {\n\t\t\t\t\tif (bitrate >= 96000) {\n\t\t\t\t\t\t*con |= 0x800;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*con |= 0x1000;\n\t\t\t\t\t\tnco = (bitrate * 8192 + 71999)\n\t\t\t\t\t\t\t/ 72000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t*con |= 0x1810;\n\t\t\t\tif (bitrate <= 64000) {\n\t\t\t\t\tmax_bitrate = 64000;\n\t\t\t\t\tnco = 8;\n\t\t\t\t} else if (bitrate <= 72000) {\n\t\t\t\t\tmax_bitrate = 72000;\n\t\t\t\t\tnco = 7;\n\t\t\t\t} else {\n\t\t\t\t\tmax_bitrate = 96000;\n\t\t\t\t\tnco = 5;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (bitrate > 72000) {\n\t\t\t\t*con |= 0x810;  \n\t\t\t\tmax_bitrate = 96000;\n\t\t\t}\n\t\t\t*con |= 0x10;  \n\t\t}\n\t}\n\tif (max_bitrate > 0) {\n\t\tif (bitrate > max_bitrate)\n\t\t\tbitrate = max_bitrate;\n\t\tif (bitrate < 31000)\n\t\t\tbitrate = 31000;\n\t\tgap = ((max_bitrate - bitrate) * 94) / bitrate;\n\t\tif (gap < 2)\n\t\t\t*con &= ~0x10;  \n\t\telse\n\t\t\tgap -= 2;\n\t\tif (gap > 127)\n\t\t\tgap = 127;\n\t}\n\n\t*con2 = (nco << 16) | gap;\n}\n\nstatic void ddb_output_start(struct ddb_output *output)\n{\n\tstruct ddb *dev = output->port->dev;\n\tu32 con = 0x11c, con2 = 0;\n\n\tspin_lock_irq(&output->dma->lock);\n\toutput->dma->cbuf = 0;\n\toutput->dma->coff = 0;\n\toutput->dma->stat = 0;\n\tddbwritel(dev, 0, DMA_BUFFER_CONTROL(output->dma));\n\n\tif (output->port->input[0]->port->class == DDB_PORT_LOOP)\n\t\tcon = (1UL << 13) | 0x14;\n\telse\n\t\tcalc_con(output, &con, &con2, 0);\n\n\tddbwritel(dev, 0, TS_CONTROL(output));\n\tddbwritel(dev, 2, TS_CONTROL(output));\n\tddbwritel(dev, 0, TS_CONTROL(output));\n\tddbwritel(dev, con, TS_CONTROL(output));\n\tddbwritel(dev, con2, TS_CONTROL2(output));\n\n\tddbwritel(dev, output->dma->bufval,\n\t\t  DMA_BUFFER_SIZE(output->dma));\n\tddbwritel(dev, 0, DMA_BUFFER_ACK(output->dma));\n\tddbwritel(dev, 1, DMA_BASE_READ);\n\tddbwritel(dev, 7, DMA_BUFFER_CONTROL(output->dma));\n\n\tddbwritel(dev, con | 1, TS_CONTROL(output));\n\n\toutput->dma->running = 1;\n\tspin_unlock_irq(&output->dma->lock);\n}\n\nstatic void ddb_output_stop(struct ddb_output *output)\n{\n\tstruct ddb *dev = output->port->dev;\n\n\tspin_lock_irq(&output->dma->lock);\n\n\tddbwritel(dev, 0, TS_CONTROL(output));\n\n\tddbwritel(dev, 0, DMA_BUFFER_CONTROL(output->dma));\n\toutput->dma->running = 0;\n\tspin_unlock_irq(&output->dma->lock);\n}\n\nstatic void ddb_input_stop(struct ddb_input *input)\n{\n\tstruct ddb *dev = input->port->dev;\n\tu32 tag = DDB_LINK_TAG(input->port->lnr);\n\n\tspin_lock_irq(&input->dma->lock);\n\n\tddbwritel(dev, 0, tag | TS_CONTROL(input));\n\n\tddbwritel(dev, 0, DMA_BUFFER_CONTROL(input->dma));\n\tinput->dma->running = 0;\n\tspin_unlock_irq(&input->dma->lock);\n}\n\nstatic void ddb_input_start(struct ddb_input *input)\n{\n\tstruct ddb *dev = input->port->dev;\n\n\tspin_lock_irq(&input->dma->lock);\n\tinput->dma->cbuf = 0;\n\tinput->dma->coff = 0;\n\tinput->dma->stat = 0;\n\tddbwritel(dev, 0, DMA_BUFFER_CONTROL(input->dma));\n\n\tddbwritel(dev, 0, TS_CONTROL(input));\n\tddbwritel(dev, 2, TS_CONTROL(input));\n\tddbwritel(dev, 0, TS_CONTROL(input));\n\n\tddbwritel(dev, input->dma->bufval,\n\t\t  DMA_BUFFER_SIZE(input->dma));\n\tddbwritel(dev, 0, DMA_BUFFER_ACK(input->dma));\n\tddbwritel(dev, 1, DMA_BASE_WRITE);\n\tddbwritel(dev, 3, DMA_BUFFER_CONTROL(input->dma));\n\n\tddbwritel(dev, 0x09, TS_CONTROL(input));\n\n\tif (input->port->type == DDB_TUNER_DUMMY)\n\t\tddbwritel(dev, 0x000fff01, TS_CONTROL2(input));\n\n\tinput->dma->running = 1;\n\tspin_unlock_irq(&input->dma->lock);\n}\n\nstatic void ddb_input_start_all(struct ddb_input *input)\n{\n\tstruct ddb_input *i = input;\n\tstruct ddb_output *o;\n\n\tmutex_lock(&redirect_lock);\n\twhile (i && (o = i->redo)) {\n\t\tddb_output_start(o);\n\t\ti = o->port->input[0];\n\t\tif (i)\n\t\t\tddb_input_start(i);\n\t}\n\tddb_input_start(input);\n\tmutex_unlock(&redirect_lock);\n}\n\nstatic void ddb_input_stop_all(struct ddb_input *input)\n{\n\tstruct ddb_input *i = input;\n\tstruct ddb_output *o;\n\n\tmutex_lock(&redirect_lock);\n\tddb_input_stop(input);\n\twhile (i && (o = i->redo)) {\n\t\tddb_output_stop(o);\n\t\ti = o->port->input[0];\n\t\tif (i)\n\t\t\tddb_input_stop(i);\n\t}\n\tmutex_unlock(&redirect_lock);\n}\n\nstatic u32 ddb_output_free(struct ddb_output *output)\n{\n\tu32 idx, off, stat = output->dma->stat;\n\ts32 diff;\n\n\tidx = (stat >> 11) & 0x1f;\n\toff = (stat & 0x7ff) << 7;\n\n\tif (output->dma->cbuf != idx) {\n\t\tif ((((output->dma->cbuf + 1) % output->dma->num) == idx) &&\n\t\t    (output->dma->size - output->dma->coff <= (2 * 188)))\n\t\t\treturn 0;\n\t\treturn 188;\n\t}\n\tdiff = off - output->dma->coff;\n\tif (diff <= 0 || diff > (2 * 188))\n\t\treturn 188;\n\treturn 0;\n}\n\nstatic ssize_t ddb_output_write(struct ddb_output *output,\n\t\t\t\tconst __user u8 *buf, size_t count)\n{\n\tstruct ddb *dev = output->port->dev;\n\tu32 idx, off, stat = output->dma->stat;\n\tu32 left = count, len;\n\n\tidx = (stat >> 11) & 0x1f;\n\toff = (stat & 0x7ff) << 7;\n\n\twhile (left) {\n\t\tlen = output->dma->size - output->dma->coff;\n\t\tif ((((output->dma->cbuf + 1) % output->dma->num) == idx) &&\n\t\t    off == 0) {\n\t\t\tif (len <= 188)\n\t\t\t\tbreak;\n\t\t\tlen -= 188;\n\t\t}\n\t\tif (output->dma->cbuf == idx) {\n\t\t\tif (off > output->dma->coff) {\n\t\t\t\tlen = off - output->dma->coff;\n\t\t\t\tlen -= (len % 188);\n\t\t\t\tif (len <= 188)\n\t\t\t\t\tbreak;\n\t\t\t\tlen -= 188;\n\t\t\t}\n\t\t}\n\t\tif (len > left)\n\t\t\tlen = left;\n\t\tif (copy_from_user(output->dma->vbuf[output->dma->cbuf] +\n\t\t\t\t   output->dma->coff,\n\t\t\t\t   buf, len))\n\t\t\treturn -EIO;\n\t\tif (alt_dma)\n\t\t\tdma_sync_single_for_device(\n\t\t\t\tdev->dev,\n\t\t\t\toutput->dma->pbuf[output->dma->cbuf],\n\t\t\t\toutput->dma->size, DMA_TO_DEVICE);\n\t\tleft -= len;\n\t\tbuf += len;\n\t\toutput->dma->coff += len;\n\t\tif (output->dma->coff == output->dma->size) {\n\t\t\toutput->dma->coff = 0;\n\t\t\toutput->dma->cbuf = ((output->dma->cbuf + 1) %\n\t\t\t\t\t     output->dma->num);\n\t\t}\n\t\tddbwritel(dev,\n\t\t\t  (output->dma->cbuf << 11) |\n\t\t\t  (output->dma->coff >> 7),\n\t\t\t  DMA_BUFFER_ACK(output->dma));\n\t}\n\treturn count - left;\n}\n\nstatic u32 ddb_input_avail(struct ddb_input *input)\n{\n\tstruct ddb *dev = input->port->dev;\n\tu32 idx, off, stat = input->dma->stat;\n\tu32 ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(input->dma));\n\n\tidx = (stat >> 11) & 0x1f;\n\toff = (stat & 0x7ff) << 7;\n\n\tif (ctrl & 4) {\n\t\tdev_err(dev->dev, \"IA %d %d %08x\\n\", idx, off, ctrl);\n\t\tddbwritel(dev, stat, DMA_BUFFER_ACK(input->dma));\n\t\treturn 0;\n\t}\n\tif (input->dma->cbuf != idx)\n\t\treturn 188;\n\treturn 0;\n}\n\nstatic ssize_t ddb_input_read(struct ddb_input *input,\n\t\t\t      __user u8 *buf, size_t count)\n{\n\tstruct ddb *dev = input->port->dev;\n\tu32 left = count;\n\tu32 idx, free, stat = input->dma->stat;\n\tint ret;\n\n\tidx = (stat >> 11) & 0x1f;\n\n\twhile (left) {\n\t\tif (input->dma->cbuf == idx)\n\t\t\treturn count - left;\n\t\tfree = input->dma->size - input->dma->coff;\n\t\tif (free > left)\n\t\t\tfree = left;\n\t\tif (alt_dma)\n\t\t\tdma_sync_single_for_cpu(\n\t\t\t\tdev->dev,\n\t\t\t\tinput->dma->pbuf[input->dma->cbuf],\n\t\t\t\tinput->dma->size, DMA_FROM_DEVICE);\n\t\tret = copy_to_user(buf, input->dma->vbuf[input->dma->cbuf] +\n\t\t\t\t   input->dma->coff, free);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tinput->dma->coff += free;\n\t\tif (input->dma->coff == input->dma->size) {\n\t\t\tinput->dma->coff = 0;\n\t\t\tinput->dma->cbuf = (input->dma->cbuf + 1) %\n\t\t\t\tinput->dma->num;\n\t\t}\n\t\tleft -= free;\n\t\tbuf += free;\n\t\tddbwritel(dev,\n\t\t\t  (input->dma->cbuf << 11) | (input->dma->coff >> 7),\n\t\t\t  DMA_BUFFER_ACK(input->dma));\n\t}\n\treturn count;\n}\n\n \n \n\nstatic ssize_t ts_write(struct file *file, const __user char *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct ddb_output *output = dvbdev->priv;\n\tstruct ddb *dev = output->port->dev;\n\tsize_t left = count;\n\tint stat;\n\n\tif (!dev->has_dma)\n\t\treturn -EINVAL;\n\twhile (left) {\n\t\tif (ddb_output_free(output) < 188) {\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (wait_event_interruptible(\n\t\t\t\t    output->dma->wq,\n\t\t\t\t    ddb_output_free(output) >= 188) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tstat = ddb_output_write(output, buf, left);\n\t\tif (stat < 0)\n\t\t\treturn stat;\n\t\tbuf += stat;\n\t\tleft -= stat;\n\t}\n\treturn (left == count) ? -EAGAIN : (count - left);\n}\n\nstatic ssize_t ts_read(struct file *file, __user char *buf,\n\t\t       size_t count, loff_t *ppos)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct ddb_output *output = dvbdev->priv;\n\tstruct ddb_input *input = output->port->input[0];\n\tstruct ddb *dev = output->port->dev;\n\tsize_t left = count;\n\tint stat;\n\n\tif (!dev->has_dma)\n\t\treturn -EINVAL;\n\twhile (left) {\n\t\tif (ddb_input_avail(input) < 188) {\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (wait_event_interruptible(\n\t\t\t\t    input->dma->wq,\n\t\t\t\t    ddb_input_avail(input) >= 188) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tstat = ddb_input_read(input, buf, left);\n\t\tif (stat < 0)\n\t\t\treturn stat;\n\t\tleft -= stat;\n\t\tbuf += stat;\n\t}\n\treturn (count && (left == count)) ? -EAGAIN : (count - left);\n}\n\nstatic __poll_t ts_poll(struct file *file, poll_table *wait)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct ddb_output *output = dvbdev->priv;\n\tstruct ddb_input *input = output->port->input[0];\n\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &input->dma->wq, wait);\n\tpoll_wait(file, &output->dma->wq, wait);\n\tif (ddb_input_avail(input) >= 188)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (ddb_output_free(output) >= 188)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\treturn mask;\n}\n\nstatic int ts_release(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct ddb_output *output = NULL;\n\tstruct ddb_input *input = NULL;\n\n\tif (dvbdev) {\n\t\toutput = dvbdev->priv;\n\t\tinput = output->port->input[0];\n\t}\n\n\tif ((file->f_flags & O_ACCMODE) == O_RDONLY) {\n\t\tif (!input)\n\t\t\treturn -EINVAL;\n\t\tddb_input_stop(input);\n\t} else if ((file->f_flags & O_ACCMODE) == O_WRONLY) {\n\t\tif (!output)\n\t\t\treturn -EINVAL;\n\t\tddb_output_stop(output);\n\t}\n\treturn dvb_generic_release(inode, file);\n}\n\nstatic int ts_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct ddb_output *output = NULL;\n\tstruct ddb_input *input = NULL;\n\n\tif (dvbdev) {\n\t\toutput = dvbdev->priv;\n\t\tinput = output->port->input[0];\n\t}\n\n\tif ((file->f_flags & O_ACCMODE) == O_RDONLY) {\n\t\tif (!input)\n\t\t\treturn -EINVAL;\n\t\tif (input->redo || input->redi)\n\t\t\treturn -EBUSY;\n\t} else if ((file->f_flags & O_ACCMODE) == O_WRONLY) {\n\t\tif (!output)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\terr = dvb_generic_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\tif ((file->f_flags & O_ACCMODE) == O_RDONLY)\n\t\tddb_input_start(input);\n\telse if ((file->f_flags & O_ACCMODE) == O_WRONLY)\n\t\tddb_output_start(output);\n\treturn err;\n}\n\nstatic const struct file_operations ci_fops = {\n\t.owner   = THIS_MODULE,\n\t.read    = ts_read,\n\t.write   = ts_write,\n\t.open    = ts_open,\n\t.release = ts_release,\n\t.poll    = ts_poll,\n\t.mmap    = NULL,\n};\n\nstatic struct dvb_device dvbdev_ci = {\n\t.priv    = NULL,\n\t.readers = 1,\n\t.writers = 1,\n\t.users   = 2,\n\t.fops    = &ci_fops,\n};\n\n \n \n\nstatic int locked_gate_ctrl(struct dvb_frontend *fe, int enable)\n{\n\tstruct ddb_input *input = fe->sec_priv;\n\tstruct ddb_port *port = input->port;\n\tstruct ddb_dvb *dvb = &port->dvb[input->nr & 1];\n\tint status;\n\n\tif (enable) {\n\t\tmutex_lock(&port->i2c_gate_lock);\n\t\tstatus = dvb->i2c_gate_ctrl(fe, 1);\n\t} else {\n\t\tstatus = dvb->i2c_gate_ctrl(fe, 0);\n\t\tmutex_unlock(&port->i2c_gate_lock);\n\t}\n\treturn status;\n}\n\nstatic int demod_attach_drxk(struct ddb_input *input)\n{\n\tstruct i2c_adapter *i2c = &input->port->i2c->adap;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct device *dev = input->port->dev->dev;\n\tstruct drxk_config config;\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.adr = 0x29 + (input->nr & 1);\n\tconfig.microcode_name = \"drxk_a3.mc\";\n\n\tdvb->fe = dvb_attach(drxk_attach, &config, i2c);\n\tif (!dvb->fe) {\n\t\tdev_err(dev, \"No DRXK found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdvb->fe->sec_priv = input;\n\tdvb->i2c_gate_ctrl = dvb->fe->ops.i2c_gate_ctrl;\n\tdvb->fe->ops.i2c_gate_ctrl = locked_gate_ctrl;\n\treturn 0;\n}\n\nstatic int tuner_attach_tda18271(struct ddb_input *input)\n{\n\tstruct i2c_adapter *i2c = &input->port->i2c->adap;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct device *dev = input->port->dev->dev;\n\tstruct dvb_frontend *fe;\n\n\tif (dvb->fe->ops.i2c_gate_ctrl)\n\t\tdvb->fe->ops.i2c_gate_ctrl(dvb->fe, 1);\n\tfe = dvb_attach(tda18271c2dd_attach, dvb->fe, i2c, 0x60);\n\tif (dvb->fe->ops.i2c_gate_ctrl)\n\t\tdvb->fe->ops.i2c_gate_ctrl(dvb->fe, 0);\n\tif (!fe) {\n\t\tdev_err(dev, \"No TDA18271 found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n \n \n \n\nstatic struct stv0367_config ddb_stv0367_config[] = {\n\t{\n\t\t.demod_address = 0x1f,\n\t\t.xtal = 27000000,\n\t\t.if_khz = 0,\n\t\t.if_iq_mode = FE_TER_NORMAL_IF_TUNER,\n\t\t.ts_mode = STV0367_SERIAL_PUNCT_CLOCK,\n\t\t.clk_pol = STV0367_CLOCKPOLARITY_DEFAULT,\n\t}, {\n\t\t.demod_address = 0x1e,\n\t\t.xtal = 27000000,\n\t\t.if_khz = 0,\n\t\t.if_iq_mode = FE_TER_NORMAL_IF_TUNER,\n\t\t.ts_mode = STV0367_SERIAL_PUNCT_CLOCK,\n\t\t.clk_pol = STV0367_CLOCKPOLARITY_DEFAULT,\n\t},\n};\n\nstatic int demod_attach_stv0367(struct ddb_input *input)\n{\n\tstruct i2c_adapter *i2c = &input->port->i2c->adap;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct device *dev = input->port->dev->dev;\n\n\t \n\tdvb->fe = dvb_attach(stv0367ddb_attach,\n\t\t\t     &ddb_stv0367_config[(input->nr & 1)], i2c);\n\n\tif (!dvb->fe) {\n\t\tdev_err(dev, \"No stv0367 found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdvb->fe->sec_priv = input;\n\tdvb->i2c_gate_ctrl = dvb->fe->ops.i2c_gate_ctrl;\n\tdvb->fe->ops.i2c_gate_ctrl = locked_gate_ctrl;\n\treturn 0;\n}\n\nstatic int tuner_tda18212_ping(struct ddb_input *input, unsigned short adr)\n{\n\tstruct i2c_adapter *adapter = &input->port->i2c->adap;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct device *dev = input->port->dev->dev;\n\tu8 tda_id[2];\n\tu8 subaddr = 0x00;\n\n\tdev_dbg(dev, \"stv0367-tda18212 tuner ping\\n\");\n\tif (dvb->fe->ops.i2c_gate_ctrl)\n\t\tdvb->fe->ops.i2c_gate_ctrl(dvb->fe, 1);\n\n\tif (i2c_read_regs(adapter, adr, subaddr, tda_id, sizeof(tda_id)) < 0)\n\t\tdev_dbg(dev, \"tda18212 ping 1 fail\\n\");\n\tif (i2c_read_regs(adapter, adr, subaddr, tda_id, sizeof(tda_id)) < 0)\n\t\tdev_warn(dev, \"tda18212 ping failed, expect problems\\n\");\n\n\tif (dvb->fe->ops.i2c_gate_ctrl)\n\t\tdvb->fe->ops.i2c_gate_ctrl(dvb->fe, 0);\n\n\treturn 0;\n}\n\nstatic int demod_attach_cxd28xx(struct ddb_input *input, int par, int osc24)\n{\n\tstruct i2c_adapter *i2c = &input->port->i2c->adap;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct device *dev = input->port->dev->dev;\n\tstruct cxd2841er_config cfg;\n\n\t \n\tcfg.i2c_addr = ((input->nr & 1) ? 0x6d : 0x6c) << 1;\n\n\tcfg.xtal = osc24 ? SONY_XTAL_24000 : SONY_XTAL_20500;\n\tcfg.flags = CXD2841ER_AUTO_IFHZ | CXD2841ER_EARLY_TUNE |\n\t\tCXD2841ER_NO_WAIT_LOCK | CXD2841ER_NO_AGCNEG |\n\t\tCXD2841ER_TSBITS;\n\n\tif (!par)\n\t\tcfg.flags |= CXD2841ER_TS_SERIAL;\n\n\t \n\tdvb->fe = dvb_attach(cxd2841er_attach_t_c, &cfg, i2c);\n\n\tif (!dvb->fe) {\n\t\tdev_err(dev, \"No cxd2837/38/43/54 found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdvb->fe->sec_priv = input;\n\tdvb->i2c_gate_ctrl = dvb->fe->ops.i2c_gate_ctrl;\n\tdvb->fe->ops.i2c_gate_ctrl = locked_gate_ctrl;\n\treturn 0;\n}\n\nstatic int tuner_attach_tda18212(struct ddb_input *input, u32 porttype)\n{\n\tstruct i2c_adapter *adapter = &input->port->i2c->adap;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct device *dev = input->port->dev->dev;\n\tstruct i2c_client *client;\n\tstruct tda18212_config config = {\n\t\t.fe = dvb->fe,\n\t\t.if_dvbt_6 = 3550,\n\t\t.if_dvbt_7 = 3700,\n\t\t.if_dvbt_8 = 4150,\n\t\t.if_dvbt2_6 = 3250,\n\t\t.if_dvbt2_7 = 4000,\n\t\t.if_dvbt2_8 = 4000,\n\t\t.if_dvbc = 5000,\n\t};\n\tu8 addr = (input->nr & 1) ? 0x63 : 0x60;\n\n\t \n\tif (porttype == DDB_TUNER_DVBCT_ST)\n\t\ttuner_tda18212_ping(input, addr);\n\n\t \n\tclient = dvb_module_probe(\"tda18212\", NULL, adapter, addr, &config);\n\tif (!client)\n\t\tgoto err;\n\n\tdvb->i2c_client[0] = client;\n\treturn 0;\nerr:\n\tdev_err(dev, \"TDA18212 tuner not found. Device is not fully operational.\\n\");\n\treturn -ENODEV;\n}\n\n \n \n \n\nstatic struct stv090x_config stv0900 = {\n\t.device         = STV0900,\n\t.demod_mode     = STV090x_DUAL,\n\t.clk_mode       = STV090x_CLK_EXT,\n\n\t.xtal           = 27000000,\n\t.address        = 0x69,\n\n\t.ts1_mode       = STV090x_TSMODE_SERIAL_PUNCTURED,\n\t.ts2_mode       = STV090x_TSMODE_SERIAL_PUNCTURED,\n\n\t.ts1_tei        = 1,\n\t.ts2_tei        = 1,\n\n\t.repeater_level = STV090x_RPTLEVEL_16,\n\n\t.adc1_range\t= STV090x_ADC_1Vpp,\n\t.adc2_range\t= STV090x_ADC_1Vpp,\n\n\t.diseqc_envelope_mode = true,\n};\n\nstatic struct stv090x_config stv0900_aa = {\n\t.device         = STV0900,\n\t.demod_mode     = STV090x_DUAL,\n\t.clk_mode       = STV090x_CLK_EXT,\n\n\t.xtal           = 27000000,\n\t.address        = 0x68,\n\n\t.ts1_mode       = STV090x_TSMODE_SERIAL_PUNCTURED,\n\t.ts2_mode       = STV090x_TSMODE_SERIAL_PUNCTURED,\n\n\t.ts1_tei        = 1,\n\t.ts2_tei        = 1,\n\n\t.repeater_level = STV090x_RPTLEVEL_16,\n\n\t.adc1_range\t= STV090x_ADC_1Vpp,\n\t.adc2_range\t= STV090x_ADC_1Vpp,\n\n\t.diseqc_envelope_mode = true,\n};\n\nstatic struct stv6110x_config stv6110a = {\n\t.addr    = 0x60,\n\t.refclk\t = 27000000,\n\t.clk_div = 1,\n};\n\nstatic struct stv6110x_config stv6110b = {\n\t.addr    = 0x63,\n\t.refclk\t = 27000000,\n\t.clk_div = 1,\n};\n\nstatic int demod_attach_stv0900(struct ddb_input *input, int type)\n{\n\tstruct i2c_adapter *i2c = &input->port->i2c->adap;\n\tstruct stv090x_config *feconf = type ? &stv0900_aa : &stv0900;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct device *dev = input->port->dev->dev;\n\n\tdvb->fe = dvb_attach(stv090x_attach, feconf, i2c,\n\t\t\t     (input->nr & 1) ? STV090x_DEMODULATOR_1\n\t\t\t     : STV090x_DEMODULATOR_0);\n\tif (!dvb->fe) {\n\t\tdev_err(dev, \"No STV0900 found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!dvb_attach(lnbh24_attach, dvb->fe, i2c, 0,\n\t\t\t0, (input->nr & 1) ?\n\t\t\t(0x09 - type) : (0x0b - type))) {\n\t\tdev_err(dev, \"No LNBH24 found!\\n\");\n\t\tdvb_frontend_detach(dvb->fe);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int tuner_attach_stv6110(struct ddb_input *input, int type)\n{\n\tstruct i2c_adapter *i2c = &input->port->i2c->adap;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct device *dev = input->port->dev->dev;\n\tstruct stv090x_config *feconf = type ? &stv0900_aa : &stv0900;\n\tstruct stv6110x_config *tunerconf = (input->nr & 1) ?\n\t\t&stv6110b : &stv6110a;\n\tconst struct stv6110x_devctl *ctl;\n\n\tctl = dvb_attach(stv6110x_attach, dvb->fe, tunerconf, i2c);\n\tif (!ctl) {\n\t\tdev_err(dev, \"No STV6110X found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdev_info(dev, \"attach tuner input %d adr %02x\\n\",\n\t\t input->nr, tunerconf->addr);\n\n\tfeconf->tuner_init          = ctl->tuner_init;\n\tfeconf->tuner_sleep         = ctl->tuner_sleep;\n\tfeconf->tuner_set_mode      = ctl->tuner_set_mode;\n\tfeconf->tuner_set_frequency = ctl->tuner_set_frequency;\n\tfeconf->tuner_get_frequency = ctl->tuner_get_frequency;\n\tfeconf->tuner_set_bandwidth = ctl->tuner_set_bandwidth;\n\tfeconf->tuner_get_bandwidth = ctl->tuner_get_bandwidth;\n\tfeconf->tuner_set_bbgain    = ctl->tuner_set_bbgain;\n\tfeconf->tuner_get_bbgain    = ctl->tuner_get_bbgain;\n\tfeconf->tuner_set_refclk    = ctl->tuner_set_refclk;\n\tfeconf->tuner_get_status    = ctl->tuner_get_status;\n\n\treturn 0;\n}\n\nstatic const struct stv0910_cfg stv0910_p = {\n\t.adr      = 0x68,\n\t.parallel = 1,\n\t.rptlvl   = 4,\n\t.clk      = 30000000,\n\t.tsspeed  = 0x28,\n};\n\nstatic const struct lnbh25_config lnbh25_cfg = {\n\t.i2c_address = 0x0c << 1,\n\t.data2_config = LNBH25_TEN\n};\n\nstatic int has_lnbh25(struct i2c_adapter *i2c, u8 adr)\n{\n\tu8 val;\n\n\treturn i2c_read_reg(i2c, adr, 0, &val) ? 0 : 1;\n}\n\nstatic int demod_attach_stv0910(struct ddb_input *input, int type, int tsfast)\n{\n\tstruct i2c_adapter *i2c = &input->port->i2c->adap;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct device *dev = input->port->dev->dev;\n\tstruct stv0910_cfg cfg = stv0910_p;\n\tstruct lnbh25_config lnbcfg = lnbh25_cfg;\n\n\tif (stv0910_single)\n\t\tcfg.single = 1;\n\n\tif (type)\n\t\tcfg.parallel = 2;\n\n\tif (tsfast) {\n\t\tdev_info(dev, \"Enabling stv0910 higher speed TS\\n\");\n\t\tcfg.tsspeed = 0x10;\n\t}\n\n\tdvb->fe = dvb_attach(stv0910_attach, i2c, &cfg, (input->nr & 1));\n\tif (!dvb->fe) {\n\t\tcfg.adr = 0x6c;\n\t\tdvb->fe = dvb_attach(stv0910_attach, i2c,\n\t\t\t\t     &cfg, (input->nr & 1));\n\t}\n\tif (!dvb->fe) {\n\t\tdev_err(dev, \"No STV0910 found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (has_lnbh25(i2c, 0x0d))\n\t\tlnbcfg.i2c_address = (((input->nr & 1) ? 0x0d : 0x0c) << 1);\n\telse\n\t\tlnbcfg.i2c_address = (((input->nr & 1) ? 0x09 : 0x08) << 1);\n\n\tif (!dvb_attach(lnbh25_attach, dvb->fe, &lnbcfg, i2c)) {\n\t\tdev_err(dev, \"No LNBH25 found!\\n\");\n\t\tdvb_frontend_detach(dvb->fe);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int tuner_attach_stv6111(struct ddb_input *input, int type)\n{\n\tstruct i2c_adapter *i2c = &input->port->i2c->adap;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct device *dev = input->port->dev->dev;\n\tstruct dvb_frontend *fe;\n\tu8 adr = (type ? 0 : 4) + ((input->nr & 1) ? 0x63 : 0x60);\n\n\tfe = dvb_attach(stv6111_attach, dvb->fe, i2c, adr);\n\tif (!fe) {\n\t\tfe = dvb_attach(stv6111_attach, dvb->fe, i2c, adr & ~4);\n\t\tif (!fe) {\n\t\t\tdev_err(dev, \"No STV6111 found at 0x%02x!\\n\", adr);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int demod_attach_dummy(struct ddb_input *input)\n{\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct device *dev = input->port->dev->dev;\n\n\tdvb->fe = dvb_attach(ddbridge_dummy_fe_qam_attach);\n\tif (!dvb->fe) {\n\t\tdev_err(dev, \"QAM dummy attach failed!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int start_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tstruct ddb_input *input = dvbdmx->priv;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\n\tif (!dvb->users)\n\t\tddb_input_start_all(input);\n\n\treturn ++dvb->users;\n}\n\nstatic int stop_feed(struct dvb_demux_feed *dvbdmxfeed)\n{\n\tstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\n\tstruct ddb_input *input = dvbdmx->priv;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\n\tif (--dvb->users)\n\t\treturn dvb->users;\n\n\tddb_input_stop_all(input);\n\treturn 0;\n}\n\nstatic void dvb_input_detach(struct ddb_input *input)\n{\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct dvb_demux *dvbdemux = &dvb->demux;\n\n\tswitch (dvb->attached) {\n\tcase 0x31:\n\t\tif (dvb->fe2)\n\t\t\tdvb_unregister_frontend(dvb->fe2);\n\t\tif (dvb->fe)\n\t\t\tdvb_unregister_frontend(dvb->fe);\n\t\tfallthrough;\n\tcase 0x30:\n\t\tdvb_module_release(dvb->i2c_client[0]);\n\t\tdvb->i2c_client[0] = NULL;\n\n\t\tif (dvb->fe2)\n\t\t\tdvb_frontend_detach(dvb->fe2);\n\t\tif (dvb->fe)\n\t\t\tdvb_frontend_detach(dvb->fe);\n\t\tdvb->fe = NULL;\n\t\tdvb->fe2 = NULL;\n\t\tfallthrough;\n\tcase 0x20:\n\t\tdvb_net_release(&dvb->dvbnet);\n\t\tfallthrough;\n\tcase 0x12:\n\t\tdvbdemux->dmx.remove_frontend(&dvbdemux->dmx,\n\t\t\t\t\t      &dvb->hw_frontend);\n\t\tdvbdemux->dmx.remove_frontend(&dvbdemux->dmx,\n\t\t\t\t\t      &dvb->mem_frontend);\n\t\tfallthrough;\n\tcase 0x11:\n\t\tdvb_dmxdev_release(&dvb->dmxdev);\n\t\tfallthrough;\n\tcase 0x10:\n\t\tdvb_dmx_release(&dvb->demux);\n\t\tfallthrough;\n\tcase 0x01:\n\t\tbreak;\n\t}\n\tdvb->attached = 0x00;\n}\n\nstatic int dvb_register_adapters(struct ddb *dev)\n{\n\tint i, ret = 0;\n\tstruct ddb_port *port;\n\tstruct dvb_adapter *adap;\n\n\tif (adapter_alloc == 3) {\n\t\tport = &dev->port[0];\n\t\tadap = port->dvb[0].adap;\n\t\tret = dvb_register_adapter(adap, \"DDBridge\", THIS_MODULE,\n\t\t\t\t\t   port->dev->dev,\n\t\t\t\t\t   adapter_nr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tport->dvb[0].adap_registered = 1;\n\t\tfor (i = 0; i < dev->port_num; i++) {\n\t\t\tport = &dev->port[i];\n\t\t\tport->dvb[0].adap = adap;\n\t\t\tport->dvb[1].adap = adap;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < dev->port_num; i++) {\n\t\tport = &dev->port[i];\n\t\tswitch (port->class) {\n\t\tcase DDB_PORT_TUNER:\n\t\t\tadap = port->dvb[0].adap;\n\t\t\tret = dvb_register_adapter(adap, \"DDBridge\",\n\t\t\t\t\t\t   THIS_MODULE,\n\t\t\t\t\t\t   port->dev->dev,\n\t\t\t\t\t\t   adapter_nr);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tport->dvb[0].adap_registered = 1;\n\n\t\t\tif (adapter_alloc > 0) {\n\t\t\t\tport->dvb[1].adap = port->dvb[0].adap;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadap = port->dvb[1].adap;\n\t\t\tret = dvb_register_adapter(adap, \"DDBridge\",\n\t\t\t\t\t\t   THIS_MODULE,\n\t\t\t\t\t\t   port->dev->dev,\n\t\t\t\t\t\t   adapter_nr);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tport->dvb[1].adap_registered = 1;\n\t\t\tbreak;\n\n\t\tcase DDB_PORT_CI:\n\t\tcase DDB_PORT_LOOP:\n\t\t\tadap = port->dvb[0].adap;\n\t\t\tret = dvb_register_adapter(adap, \"DDBridge\",\n\t\t\t\t\t\t   THIS_MODULE,\n\t\t\t\t\t\t   port->dev->dev,\n\t\t\t\t\t\t   adapter_nr);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tport->dvb[0].adap_registered = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (adapter_alloc < 2)\n\t\t\t\tbreak;\n\t\t\tadap = port->dvb[0].adap;\n\t\t\tret = dvb_register_adapter(adap, \"DDBridge\",\n\t\t\t\t\t\t   THIS_MODULE,\n\t\t\t\t\t\t   port->dev->dev,\n\t\t\t\t\t\t   adapter_nr);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tport->dvb[0].adap_registered = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void dvb_unregister_adapters(struct ddb *dev)\n{\n\tint i;\n\tstruct ddb_port *port;\n\tstruct ddb_dvb *dvb;\n\n\tfor (i = 0; i < dev->link[0].info->port_num; i++) {\n\t\tport = &dev->port[i];\n\n\t\tdvb = &port->dvb[0];\n\t\tif (dvb->adap_registered)\n\t\t\tdvb_unregister_adapter(dvb->adap);\n\t\tdvb->adap_registered = 0;\n\n\t\tdvb = &port->dvb[1];\n\t\tif (dvb->adap_registered)\n\t\t\tdvb_unregister_adapter(dvb->adap);\n\t\tdvb->adap_registered = 0;\n\t}\n}\n\nstatic int dvb_input_attach(struct ddb_input *input)\n{\n\tint ret = 0;\n\tstruct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];\n\tstruct ddb_port *port = input->port;\n\tstruct dvb_adapter *adap = dvb->adap;\n\tstruct dvb_demux *dvbdemux = &dvb->demux;\n\tstruct ddb_ids *devids = &input->port->dev->link[input->port->lnr].ids;\n\tint par = 0, osc24 = 0, tsfast = 0;\n\n\t \n\tif (port->nr == 0 &&\n\t    (port->type == DDB_TUNER_DVBS_STV0910_PR ||\n\t     port->type == DDB_TUNER_DVBS_STV0910_P)) {\n\t\t \n\t\tif ((devids->hwid & 0x00ffffff) >= 0x00010007)\n\t\t\ttsfast = 1;\n\t}\n\n\tdvb->attached = 0x01;\n\n\tdvbdemux->priv = input;\n\tdvbdemux->dmx.capabilities = DMX_TS_FILTERING |\n\t\tDMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING;\n\tdvbdemux->start_feed = start_feed;\n\tdvbdemux->stop_feed = stop_feed;\n\tdvbdemux->filternum = 256;\n\tdvbdemux->feednum = 256;\n\tret = dvb_dmx_init(dvbdemux);\n\tif (ret < 0)\n\t\treturn ret;\n\tdvb->attached = 0x10;\n\n\tdvb->dmxdev.filternum = 256;\n\tdvb->dmxdev.demux = &dvbdemux->dmx;\n\tret = dvb_dmxdev_init(&dvb->dmxdev, adap);\n\tif (ret < 0)\n\t\tgoto err_detach;\n\tdvb->attached = 0x11;\n\n\tdvb->mem_frontend.source = DMX_MEMORY_FE;\n\tdvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->mem_frontend);\n\tdvb->hw_frontend.source = DMX_FRONTEND_0;\n\tdvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->hw_frontend);\n\tret = dvbdemux->dmx.connect_frontend(&dvbdemux->dmx, &dvb->hw_frontend);\n\tif (ret < 0)\n\t\tgoto err_detach;\n\tdvb->attached = 0x12;\n\n\tret = dvb_net_init(adap, &dvb->dvbnet, dvb->dmxdev.demux);\n\tif (ret < 0)\n\t\tgoto err_detach;\n\tdvb->attached = 0x20;\n\n\tdvb->fe = NULL;\n\tdvb->fe2 = NULL;\n\tswitch (port->type) {\n\tcase DDB_TUNER_MXL5XX:\n\t\tif (ddb_fe_attach_mxl5xx(input) < 0)\n\t\t\tgoto err_detach;\n\t\tbreak;\n\tcase DDB_TUNER_DVBS_ST:\n\t\tif (demod_attach_stv0900(input, 0) < 0)\n\t\t\tgoto err_detach;\n\t\tif (tuner_attach_stv6110(input, 0) < 0)\n\t\t\tgoto err_tuner;\n\t\tbreak;\n\tcase DDB_TUNER_DVBS_ST_AA:\n\t\tif (demod_attach_stv0900(input, 1) < 0)\n\t\t\tgoto err_detach;\n\t\tif (tuner_attach_stv6110(input, 1) < 0)\n\t\t\tgoto err_tuner;\n\t\tbreak;\n\tcase DDB_TUNER_DVBS_STV0910:\n\t\tif (demod_attach_stv0910(input, 0, tsfast) < 0)\n\t\t\tgoto err_detach;\n\t\tif (tuner_attach_stv6111(input, 0) < 0)\n\t\t\tgoto err_tuner;\n\t\tbreak;\n\tcase DDB_TUNER_DVBS_STV0910_PR:\n\t\tif (demod_attach_stv0910(input, 1, tsfast) < 0)\n\t\t\tgoto err_detach;\n\t\tif (tuner_attach_stv6111(input, 1) < 0)\n\t\t\tgoto err_tuner;\n\t\tbreak;\n\tcase DDB_TUNER_DVBS_STV0910_P:\n\t\tif (demod_attach_stv0910(input, 0, tsfast) < 0)\n\t\t\tgoto err_detach;\n\t\tif (tuner_attach_stv6111(input, 1) < 0)\n\t\t\tgoto err_tuner;\n\t\tbreak;\n\tcase DDB_TUNER_DVBCT_TR:\n\t\tif (demod_attach_drxk(input) < 0)\n\t\t\tgoto err_detach;\n\t\tif (tuner_attach_tda18271(input) < 0)\n\t\t\tgoto err_tuner;\n\t\tbreak;\n\tcase DDB_TUNER_DVBCT_ST:\n\t\tif (demod_attach_stv0367(input) < 0)\n\t\t\tgoto err_detach;\n\t\tif (tuner_attach_tda18212(input, port->type) < 0)\n\t\t\tgoto err_tuner;\n\t\tbreak;\n\tcase DDB_TUNER_DVBC2T2I_SONY_P:\n\t\tif (input->port->dev->link[input->port->lnr].info->ts_quirks &\n\t\t    TS_QUIRK_ALT_OSC)\n\t\t\tosc24 = 0;\n\t\telse\n\t\t\tosc24 = 1;\n\t\tfallthrough;\n\tcase DDB_TUNER_DVBCT2_SONY_P:\n\tcase DDB_TUNER_DVBC2T2_SONY_P:\n\tcase DDB_TUNER_ISDBT_SONY_P:\n\t\tif (input->port->dev->link[input->port->lnr].info->ts_quirks\n\t\t\t& TS_QUIRK_SERIAL)\n\t\t\tpar = 0;\n\t\telse\n\t\t\tpar = 1;\n\t\tif (demod_attach_cxd28xx(input, par, osc24) < 0)\n\t\t\tgoto err_detach;\n\t\tif (tuner_attach_tda18212(input, port->type) < 0)\n\t\t\tgoto err_tuner;\n\t\tbreak;\n\tcase DDB_TUNER_DVBC2T2I_SONY:\n\t\tosc24 = 1;\n\t\tfallthrough;\n\tcase DDB_TUNER_DVBCT2_SONY:\n\tcase DDB_TUNER_DVBC2T2_SONY:\n\tcase DDB_TUNER_ISDBT_SONY:\n\t\tif (demod_attach_cxd28xx(input, 0, osc24) < 0)\n\t\t\tgoto err_detach;\n\t\tif (tuner_attach_tda18212(input, port->type) < 0)\n\t\t\tgoto err_tuner;\n\t\tbreak;\n\tcase DDB_TUNER_DUMMY:\n\t\tif (demod_attach_dummy(input) < 0)\n\t\t\tgoto err_detach;\n\t\tbreak;\n\tcase DDB_TUNER_MCI_SX8:\n\t\tif (ddb_fe_attach_mci(input, port->type) < 0)\n\t\t\tgoto err_detach;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tdvb->attached = 0x30;\n\n\tif (dvb->fe) {\n\t\tif (dvb_register_frontend(adap, dvb->fe) < 0)\n\t\t\tgoto err_detach;\n\n\t\tif (dvb->fe2) {\n\t\t\tif (dvb_register_frontend(adap, dvb->fe2) < 0) {\n\t\t\t\tdvb_unregister_frontend(dvb->fe);\n\t\t\t\tgoto err_detach;\n\t\t\t}\n\t\t\tdvb->fe2->tuner_priv = dvb->fe->tuner_priv;\n\t\t\tmemcpy(&dvb->fe2->ops.tuner_ops,\n\t\t\t       &dvb->fe->ops.tuner_ops,\n\t\t\t       sizeof(struct dvb_tuner_ops));\n\t\t}\n\t}\n\n\tdvb->attached = 0x31;\n\treturn 0;\n\nerr_tuner:\n\tdev_err(port->dev->dev, \"tuner attach failed!\\n\");\n\n\tif (dvb->fe2)\n\t\tdvb_frontend_detach(dvb->fe2);\n\tif (dvb->fe)\n\t\tdvb_frontend_detach(dvb->fe);\nerr_detach:\n\tdvb_input_detach(input);\n\n\t \n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn -ENODEV;\n}\n\nstatic int port_has_encti(struct ddb_port *port)\n{\n\tstruct device *dev = port->dev->dev;\n\tu8 val;\n\tint ret = i2c_read_reg(&port->i2c->adap, 0x20, 0, &val);\n\n\tif (!ret)\n\t\tdev_info(dev, \"[0x20]=0x%02x\\n\", val);\n\treturn ret ? 0 : 1;\n}\n\nstatic int port_has_cxd(struct ddb_port *port, u8 *type)\n{\n\tu8 val;\n\tu8 probe[4] = { 0xe0, 0x00, 0x00, 0x00 }, data[4];\n\tstruct i2c_msg msgs[2] = {{ .addr = 0x40,  .flags = 0,\n\t\t\t\t    .buf  = probe, .len   = 4 },\n\t\t\t\t  { .addr = 0x40,  .flags = I2C_M_RD,\n\t\t\t\t    .buf  = data,  .len   = 4 } };\n\tval = i2c_transfer(&port->i2c->adap, msgs, 2);\n\tif (val != 2)\n\t\treturn 0;\n\n\tif (data[0] == 0x02 && data[1] == 0x2b && data[3] == 0x43)\n\t\t*type = 2;\n\telse\n\t\t*type = 1;\n\treturn 1;\n}\n\nstatic int port_has_xo2(struct ddb_port *port, u8 *type, u8 *id)\n{\n\tu8 probe[1] = { 0x00 }, data[4];\n\n\tif (i2c_io(&port->i2c->adap, 0x10, probe, 1, data, 4))\n\t\treturn 0;\n\tif (data[0] == 'D' && data[1] == 'F') {\n\t\t*id = data[2];\n\t\t*type = 1;\n\t\treturn 1;\n\t}\n\tif (data[0] == 'C' && data[1] == 'I') {\n\t\t*id = data[2];\n\t\t*type = 2;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int port_has_stv0900(struct ddb_port *port)\n{\n\tu8 val;\n\n\tif (i2c_read_reg16(&port->i2c->adap, 0x69, 0xf100, &val) < 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int port_has_stv0900_aa(struct ddb_port *port, u8 *id)\n{\n\tif (i2c_read_reg16(&port->i2c->adap, 0x68, 0xf100, id) < 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int port_has_drxks(struct ddb_port *port)\n{\n\tu8 val;\n\n\tif (i2c_read(&port->i2c->adap, 0x29, &val) < 0)\n\t\treturn 0;\n\tif (i2c_read(&port->i2c->adap, 0x2a, &val) < 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int port_has_stv0367(struct ddb_port *port)\n{\n\tu8 val;\n\n\tif (i2c_read_reg16(&port->i2c->adap, 0x1e, 0xf000, &val) < 0)\n\t\treturn 0;\n\tif (val != 0x60)\n\t\treturn 0;\n\tif (i2c_read_reg16(&port->i2c->adap, 0x1f, 0xf000, &val) < 0)\n\t\treturn 0;\n\tif (val != 0x60)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int init_xo2(struct ddb_port *port)\n{\n\tstruct i2c_adapter *i2c = &port->i2c->adap;\n\tstruct ddb *dev = port->dev;\n\tu8 val, data[2];\n\tint res;\n\n\tres = i2c_read_regs(i2c, 0x10, 0x04, data, 2);\n\tif (res < 0)\n\t\treturn res;\n\n\tif (data[0] != 0x01)  {\n\t\tdev_info(dev->dev, \"Port %d: invalid XO2\\n\", port->nr);\n\t\treturn -1;\n\t}\n\n\ti2c_read_reg(i2c, 0x10, 0x08, &val);\n\tif (val != 0) {\n\t\ti2c_write_reg(i2c, 0x10, 0x08, 0x00);\n\t\tmsleep(100);\n\t}\n\t \n\ti2c_write_reg(i2c, 0x10, 0x08, 0x04);\n\tusleep_range(2000, 3000);\n\t \n\ti2c_write_reg(i2c, 0x10, 0x08, 0x07);\n\n\t \n\ti2c_write_reg(i2c, 0x10, 0x09, xo2_speed);\n\n\tif (dev->link[port->lnr].info->con_clock) {\n\t\tdev_info(dev->dev, \"Setting continuous clock for XO2\\n\");\n\t\ti2c_write_reg(i2c, 0x10, 0x0a, 0x03);\n\t\ti2c_write_reg(i2c, 0x10, 0x0b, 0x03);\n\t} else {\n\t\ti2c_write_reg(i2c, 0x10, 0x0a, 0x01);\n\t\ti2c_write_reg(i2c, 0x10, 0x0b, 0x01);\n\t}\n\n\tusleep_range(2000, 3000);\n\t \n\ti2c_write_reg(i2c, 0x10, 0x08, 0x87);\n\n\treturn 0;\n}\n\nstatic int init_xo2_ci(struct ddb_port *port)\n{\n\tstruct i2c_adapter *i2c = &port->i2c->adap;\n\tstruct ddb *dev = port->dev;\n\tu8 val, data[2];\n\tint res;\n\n\tres = i2c_read_regs(i2c, 0x10, 0x04, data, 2);\n\tif (res < 0)\n\t\treturn res;\n\n\tif (data[0] > 1)  {\n\t\tdev_info(dev->dev, \"Port %d: invalid XO2 CI %02x\\n\",\n\t\t\t port->nr, data[0]);\n\t\treturn -1;\n\t}\n\tdev_info(dev->dev, \"Port %d: DuoFlex CI %u.%u\\n\",\n\t\t port->nr, data[0], data[1]);\n\n\ti2c_read_reg(i2c, 0x10, 0x08, &val);\n\tif (val != 0) {\n\t\ti2c_write_reg(i2c, 0x10, 0x08, 0x00);\n\t\tmsleep(100);\n\t}\n\t \n\ti2c_write_reg(i2c, 0x10, 0x08, 3);\n\tusleep_range(2000, 3000);\n\n\t \n\ti2c_write_reg(i2c, 0x10, 0x09, 1);\n\n\ti2c_write_reg(i2c, 0x10, 0x08, 0x83);\n\tusleep_range(2000, 3000);\n\n\tif (dev->link[port->lnr].info->con_clock) {\n\t\tdev_info(dev->dev, \"Setting continuous clock for DuoFlex CI\\n\");\n\t\ti2c_write_reg(i2c, 0x10, 0x0a, 0x03);\n\t\ti2c_write_reg(i2c, 0x10, 0x0b, 0x03);\n\t} else {\n\t\ti2c_write_reg(i2c, 0x10, 0x0a, 0x01);\n\t\ti2c_write_reg(i2c, 0x10, 0x0b, 0x01);\n\t}\n\treturn 0;\n}\n\nstatic int port_has_cxd28xx(struct ddb_port *port, u8 *id)\n{\n\tstruct i2c_adapter *i2c = &port->i2c->adap;\n\tint status;\n\n\tstatus = i2c_write_reg(&port->i2c->adap, 0x6e, 0, 0);\n\tif (status)\n\t\treturn 0;\n\tstatus = i2c_read_reg(i2c, 0x6e, 0xfd, id);\n\tif (status)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic char *xo2names[] = {\n\t\"DUAL DVB-S2\", \"DUAL DVB-C/T/T2\",\n\t\"DUAL DVB-ISDBT\", \"DUAL DVB-C/C2/T/T2\",\n\t\"DUAL ATSC\", \"DUAL DVB-C/C2/T/T2,ISDB-T\",\n\t\"\", \"\"\n};\n\nstatic char *xo2types[] = {\n\t\"DVBS_ST\", \"DVBCT2_SONY\",\n\t\"ISDBT_SONY\", \"DVBC2T2_SONY\",\n\t\"ATSC_ST\", \"DVBC2T2I_SONY\"\n};\n\nstatic void ddb_port_probe(struct ddb_port *port)\n{\n\tstruct ddb *dev = port->dev;\n\tu32 l = port->lnr;\n\tstruct ddb_link *link = &dev->link[l];\n\tu8 id, type;\n\n\tport->name = \"NO MODULE\";\n\tport->type_name = \"NONE\";\n\tport->class = DDB_PORT_NONE;\n\n\t \n\n\tif (dummy_tuner && !port->nr &&\n\t    link->ids.device == 0x0005) {\n\t\tport->name = \"DUMMY\";\n\t\tport->class = DDB_PORT_TUNER;\n\t\tport->type = DDB_TUNER_DUMMY;\n\t\tport->type_name = \"DUMMY\";\n\t\treturn;\n\t}\n\n\tif (port->nr == ts_loop) {\n\t\tport->name = \"TS LOOP\";\n\t\tport->class = DDB_PORT_LOOP;\n\t\treturn;\n\t}\n\n\tif (port->nr == 1 && link->info->type == DDB_OCTOPUS_CI &&\n\t    link->info->i2c_mask == 1) {\n\t\tport->name = \"NO TAB\";\n\t\tport->class = DDB_PORT_NONE;\n\t\treturn;\n\t}\n\n\tif (link->info->type == DDB_OCTOPUS_MAX) {\n\t\tport->name = \"DUAL DVB-S2 MAX\";\n\t\tport->type_name = \"MXL5XX\";\n\t\tport->class = DDB_PORT_TUNER;\n\t\tport->type = DDB_TUNER_MXL5XX;\n\t\tif (port->i2c)\n\t\t\tddbwritel(dev, I2C_SPEED_400,\n\t\t\t\t  port->i2c->regs + I2C_TIMING);\n\t\treturn;\n\t}\n\n\tif (link->info->type == DDB_OCTOPUS_MCI) {\n\t\tif (port->nr >= link->info->mci_ports)\n\t\t\treturn;\n\t\tport->name = \"DUAL MCI\";\n\t\tport->type_name = \"MCI\";\n\t\tport->class = DDB_PORT_TUNER;\n\t\tport->type = DDB_TUNER_MCI + link->info->mci_type;\n\t\treturn;\n\t}\n\n\tif (port->nr > 1 && link->info->type == DDB_OCTOPUS_CI) {\n\t\tport->name = \"CI internal\";\n\t\tport->type_name = \"INTERNAL\";\n\t\tport->class = DDB_PORT_CI;\n\t\tport->type = DDB_CI_INTERNAL;\n\t}\n\n\tif (!port->i2c)\n\t\treturn;\n\n\t \n\n\tif (port_has_cxd(port, &id)) {\n\t\tif (id == 1) {\n\t\t\tport->name = \"CI\";\n\t\t\tport->type_name = \"CXD2099\";\n\t\t\tport->class = DDB_PORT_CI;\n\t\t\tport->type = DDB_CI_EXTERNAL_SONY;\n\t\t\tddbwritel(dev, I2C_SPEED_400,\n\t\t\t\t  port->i2c->regs + I2C_TIMING);\n\t\t} else {\n\t\t\tdev_info(dev->dev, \"Port %d: Uninitialized DuoFlex\\n\",\n\t\t\t\t port->nr);\n\t\t\treturn;\n\t\t}\n\t} else if (port_has_xo2(port, &type, &id)) {\n\t\tddbwritel(dev, I2C_SPEED_400, port->i2c->regs + I2C_TIMING);\n\t\t \n\t\tif (type == 2) {\n\t\t\tport->name = \"DuoFlex CI\";\n\t\t\tport->class = DDB_PORT_CI;\n\t\t\tport->type = DDB_CI_EXTERNAL_XO2;\n\t\t\tport->type_name = \"CI_XO2\";\n\t\t\tinit_xo2_ci(port);\n\t\t\treturn;\n\t\t}\n\t\tid >>= 2;\n\t\tif (id > 5) {\n\t\t\tport->name = \"unknown XO2 DuoFlex\";\n\t\t\tport->type_name = \"UNKNOWN\";\n\t\t} else {\n\t\t\tport->name = xo2names[id];\n\t\t\tport->class = DDB_PORT_TUNER;\n\t\t\tport->type = DDB_TUNER_XO2 + id;\n\t\t\tport->type_name = xo2types[id];\n\t\t\tinit_xo2(port);\n\t\t}\n\t} else if (port_has_cxd28xx(port, &id)) {\n\t\tswitch (id) {\n\t\tcase 0xa4:\n\t\t\tport->name = \"DUAL DVB-C2T2 CXD2843\";\n\t\t\tport->type = DDB_TUNER_DVBC2T2_SONY_P;\n\t\t\tport->type_name = \"DVBC2T2_SONY\";\n\t\t\tbreak;\n\t\tcase 0xb1:\n\t\t\tport->name = \"DUAL DVB-CT2 CXD2837\";\n\t\t\tport->type = DDB_TUNER_DVBCT2_SONY_P;\n\t\t\tport->type_name = \"DVBCT2_SONY\";\n\t\t\tbreak;\n\t\tcase 0xb0:\n\t\t\tport->name = \"DUAL ISDB-T CXD2838\";\n\t\t\tport->type = DDB_TUNER_ISDBT_SONY_P;\n\t\t\tport->type_name = \"ISDBT_SONY\";\n\t\t\tbreak;\n\t\tcase 0xc1:\n\t\t\tport->name = \"DUAL DVB-C2T2 ISDB-T CXD2854\";\n\t\t\tport->type = DDB_TUNER_DVBC2T2I_SONY_P;\n\t\t\tport->type_name = \"DVBC2T2I_ISDBT_SONY\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tport->class = DDB_PORT_TUNER;\n\t\tddbwritel(dev, I2C_SPEED_400, port->i2c->regs + I2C_TIMING);\n\t} else if (port_has_stv0900(port)) {\n\t\tport->name = \"DUAL DVB-S2\";\n\t\tport->class = DDB_PORT_TUNER;\n\t\tport->type = DDB_TUNER_DVBS_ST;\n\t\tport->type_name = \"DVBS_ST\";\n\t\tddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);\n\t} else if (port_has_stv0900_aa(port, &id)) {\n\t\tport->name = \"DUAL DVB-S2\";\n\t\tport->class = DDB_PORT_TUNER;\n\t\tif (id == 0x51) {\n\t\t\tif (port->nr == 0 &&\n\t\t\t    link->info->ts_quirks & TS_QUIRK_REVERSED)\n\t\t\t\tport->type = DDB_TUNER_DVBS_STV0910_PR;\n\t\t\telse\n\t\t\t\tport->type = DDB_TUNER_DVBS_STV0910_P;\n\t\t\tport->type_name = \"DVBS_ST_0910\";\n\t\t} else {\n\t\t\tport->type = DDB_TUNER_DVBS_ST_AA;\n\t\t\tport->type_name = \"DVBS_ST_AA\";\n\t\t}\n\t\tddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);\n\t} else if (port_has_drxks(port)) {\n\t\tport->name = \"DUAL DVB-C/T\";\n\t\tport->class = DDB_PORT_TUNER;\n\t\tport->type = DDB_TUNER_DVBCT_TR;\n\t\tport->type_name = \"DVBCT_TR\";\n\t\tddbwritel(dev, I2C_SPEED_400, port->i2c->regs + I2C_TIMING);\n\t} else if (port_has_stv0367(port)) {\n\t\tport->name = \"DUAL DVB-C/T\";\n\t\tport->class = DDB_PORT_TUNER;\n\t\tport->type = DDB_TUNER_DVBCT_ST;\n\t\tport->type_name = \"DVBCT_ST\";\n\t\tddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);\n\t} else if (port_has_encti(port)) {\n\t\tport->name = \"ENCTI\";\n\t\tport->class = DDB_PORT_LOOP;\n\t}\n}\n\n \n \n \n\nstatic int ddb_port_attach(struct ddb_port *port)\n{\n\tint ret = 0;\n\n\tswitch (port->class) {\n\tcase DDB_PORT_TUNER:\n\t\tret = dvb_input_attach(port->input[0]);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = dvb_input_attach(port->input[1]);\n\t\tif (ret < 0) {\n\t\t\tdvb_input_detach(port->input[0]);\n\t\t\tbreak;\n\t\t}\n\t\tport->input[0]->redi = port->input[0];\n\t\tport->input[1]->redi = port->input[1];\n\t\tbreak;\n\tcase DDB_PORT_CI:\n\t\tret = ddb_ci_attach(port, ci_bitrate);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase DDB_PORT_LOOP:\n\t\tret = dvb_register_device(port->dvb[0].adap,\n\t\t\t\t\t  &port->dvb[0].dev,\n\t\t\t\t\t  &dvbdev_ci, (void *)port->output,\n\t\t\t\t\t  DVB_DEVICE_SEC, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\tdev_err(port->dev->dev, \"port_attach on port %d failed\\n\",\n\t\t\tport->nr);\n\treturn ret;\n}\n\nint ddb_ports_attach(struct ddb *dev)\n{\n\tint i, numports, err_ports = 0, ret = 0;\n\tstruct ddb_port *port;\n\n\tif (dev->port_num) {\n\t\tret = dvb_register_adapters(dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->dev, \"Registering adapters failed. Check DVB_MAX_ADAPTERS in config.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tnumports = dev->port_num;\n\n\tfor (i = 0; i < dev->port_num; i++) {\n\t\tport = &dev->port[i];\n\t\tif (port->class != DDB_PORT_NONE) {\n\t\t\tret = ddb_port_attach(port);\n\t\t\tif (ret)\n\t\t\t\terr_ports++;\n\t\t} else {\n\t\t\tnumports--;\n\t\t}\n\t}\n\n\tif (err_ports) {\n\t\tif (err_ports == numports) {\n\t\t\tdev_err(dev->dev, \"All connected ports failed to initialise!\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tdev_warn(dev->dev, \"%d of %d connected ports failed to initialise!\\n\",\n\t\t\t err_ports, numports);\n\t}\n\n\treturn 0;\n}\n\nvoid ddb_ports_detach(struct ddb *dev)\n{\n\tint i;\n\tstruct ddb_port *port;\n\n\tfor (i = 0; i < dev->port_num; i++) {\n\t\tport = &dev->port[i];\n\n\t\tswitch (port->class) {\n\t\tcase DDB_PORT_TUNER:\n\t\t\tdvb_input_detach(port->input[1]);\n\t\t\tdvb_input_detach(port->input[0]);\n\t\t\tbreak;\n\t\tcase DDB_PORT_CI:\n\t\tcase DDB_PORT_LOOP:\n\t\t\tddb_ci_detach(port);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdvb_unregister_adapters(dev);\n}\n\n \n\nstatic void input_write_output(struct ddb_input *input,\n\t\t\t       struct ddb_output *output)\n{\n\tddbwritel(output->port->dev,\n\t\t  input->dma->stat, DMA_BUFFER_ACK(output->dma));\n\toutput->dma->cbuf = (input->dma->stat >> 11) & 0x1f;\n\toutput->dma->coff = (input->dma->stat & 0x7ff) << 7;\n}\n\nstatic void output_ack_input(struct ddb_output *output,\n\t\t\t     struct ddb_input *input)\n{\n\tddbwritel(input->port->dev,\n\t\t  output->dma->stat, DMA_BUFFER_ACK(input->dma));\n}\n\nstatic void input_write_dvb(struct ddb_input *input,\n\t\t\t    struct ddb_input *input2)\n{\n\tstruct ddb_dvb *dvb = &input2->port->dvb[input2->nr & 1];\n\tstruct ddb_dma *dma, *dma2;\n\tstruct ddb *dev = input->port->dev;\n\tint ack = 1;\n\n\tdma = input->dma;\n\tdma2 = input->dma;\n\t \n\tif (input->redo) {\n\t\tdma2 = input->redo->dma;\n\t\tack = 0;\n\t}\n\twhile (dma->cbuf != ((dma->stat >> 11) & 0x1f) ||\n\t       (4 & dma->ctrl)) {\n\t\tif (4 & dma->ctrl) {\n\t\t\t \n\t\t\tack = 1;\n\t\t}\n\t\tif (alt_dma)\n\t\t\tdma_sync_single_for_cpu(dev->dev, dma2->pbuf[dma->cbuf],\n\t\t\t\t\t\tdma2->size, DMA_FROM_DEVICE);\n\t\tdvb_dmx_swfilter_packets(&dvb->demux,\n\t\t\t\t\t dma2->vbuf[dma->cbuf],\n\t\t\t\t\t dma2->size / 188);\n\t\tdma->cbuf = (dma->cbuf + 1) % dma2->num;\n\t\tif (ack)\n\t\t\tddbwritel(dev, (dma->cbuf << 11),\n\t\t\t\t  DMA_BUFFER_ACK(dma));\n\t\tdma->stat = safe_ddbreadl(dev, DMA_BUFFER_CURRENT(dma));\n\t\tdma->ctrl = safe_ddbreadl(dev, DMA_BUFFER_CONTROL(dma));\n\t}\n}\n\nstatic void input_work(struct work_struct *work)\n{\n\tstruct ddb_dma *dma = container_of(work, struct ddb_dma, work);\n\tstruct ddb_input *input = (struct ddb_input *)dma->io;\n\tstruct ddb *dev = input->port->dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dma->lock, flags);\n\tif (!dma->running) {\n\t\tspin_unlock_irqrestore(&dma->lock, flags);\n\t\treturn;\n\t}\n\tdma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma));\n\tdma->ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(dma));\n\n\tif (input->redi)\n\t\tinput_write_dvb(input, input->redi);\n\tif (input->redo)\n\t\tinput_write_output(input, input->redo);\n\twake_up(&dma->wq);\n\tspin_unlock_irqrestore(&dma->lock, flags);\n}\n\nstatic void input_handler(void *data)\n{\n\tstruct ddb_input *input = (struct ddb_input *)data;\n\tstruct ddb_dma *dma = input->dma;\n\n\tqueue_work(ddb_wq, &dma->work);\n}\n\nstatic void output_work(struct work_struct *work)\n{\n\tstruct ddb_dma *dma = container_of(work, struct ddb_dma, work);\n\tstruct ddb_output *output = (struct ddb_output *)dma->io;\n\tstruct ddb *dev = output->port->dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dma->lock, flags);\n\tif (!dma->running)\n\t\tgoto unlock_exit;\n\tdma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma));\n\tdma->ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(dma));\n\tif (output->redi)\n\t\toutput_ack_input(output, output->redi);\n\twake_up(&dma->wq);\nunlock_exit:\n\tspin_unlock_irqrestore(&dma->lock, flags);\n}\n\nstatic void output_handler(void *data)\n{\n\tstruct ddb_output *output = (struct ddb_output *)data;\n\tstruct ddb_dma *dma = output->dma;\n\n\tqueue_work(ddb_wq, &dma->work);\n}\n\n \n \n\nstatic const struct ddb_regmap *io_regmap(struct ddb_io *io, int link)\n{\n\tconst struct ddb_info *info;\n\n\tif (link)\n\t\tinfo = io->port->dev->link[io->port->lnr].info;\n\telse\n\t\tinfo = io->port->dev->link[0].info;\n\n\tif (!info)\n\t\treturn NULL;\n\n\treturn info->regmap;\n}\n\nstatic void ddb_dma_init(struct ddb_io *io, int nr, int out)\n{\n\tstruct ddb_dma *dma;\n\tconst struct ddb_regmap *rm = io_regmap(io, 0);\n\n\tdma = out ? &io->port->dev->odma[nr] : &io->port->dev->idma[nr];\n\tio->dma = dma;\n\tdma->io = io;\n\n\tspin_lock_init(&dma->lock);\n\tinit_waitqueue_head(&dma->wq);\n\tif (out) {\n\t\tINIT_WORK(&dma->work, output_work);\n\t\tdma->regs = rm->odma->base + rm->odma->size * nr;\n\t\tdma->bufregs = rm->odma_buf->base + rm->odma_buf->size * nr;\n\t\tdma->num = dma_buf_num;\n\t\tdma->size = dma_buf_size * 128 * 47;\n\t\tdma->div = 1;\n\t} else {\n\t\tINIT_WORK(&dma->work, input_work);\n\t\tdma->regs = rm->idma->base + rm->idma->size * nr;\n\t\tdma->bufregs = rm->idma_buf->base + rm->idma_buf->size * nr;\n\t\tdma->num = dma_buf_num;\n\t\tdma->size = dma_buf_size * 128 * 47;\n\t\tdma->div = 1;\n\t}\n\tddbwritel(io->port->dev, 0, DMA_BUFFER_ACK(dma));\n\tdev_dbg(io->port->dev->dev, \"init link %u, io %u, dma %u, dmaregs %08x bufregs %08x\\n\",\n\t\tio->port->lnr, io->nr, nr, dma->regs, dma->bufregs);\n}\n\nstatic void ddb_input_init(struct ddb_port *port, int nr, int pnr, int anr)\n{\n\tstruct ddb *dev = port->dev;\n\tstruct ddb_input *input = &dev->input[anr];\n\tconst struct ddb_regmap *rm;\n\n\tport->input[pnr] = input;\n\tinput->nr = nr;\n\tinput->port = port;\n\trm = io_regmap(input, 1);\n\tinput->regs = DDB_LINK_TAG(port->lnr) |\n\t\t(rm->input->base + rm->input->size * nr);\n\tdev_dbg(dev->dev, \"init link %u, input %u, regs %08x\\n\",\n\t\tport->lnr, nr, input->regs);\n\n\tif (dev->has_dma) {\n\t\tconst struct ddb_regmap *rm0 = io_regmap(input, 0);\n\t\tu32 base = rm0->irq_base_idma;\n\t\tu32 dma_nr = nr;\n\n\t\tif (port->lnr)\n\t\t\tdma_nr += 32 + (port->lnr - 1) * 8;\n\n\t\tdev_dbg(dev->dev, \"init link %u, input %u, handler %u\\n\",\n\t\t\tport->lnr, nr, dma_nr + base);\n\n\t\tddb_irq_set(dev, 0, dma_nr + base, &input_handler, input);\n\t\tddb_dma_init(input, dma_nr, 0);\n\t}\n}\n\nstatic void ddb_output_init(struct ddb_port *port, int nr)\n{\n\tstruct ddb *dev = port->dev;\n\tstruct ddb_output *output = &dev->output[nr];\n\tconst struct ddb_regmap *rm;\n\n\tport->output = output;\n\toutput->nr = nr;\n\toutput->port = port;\n\trm = io_regmap(output, 1);\n\toutput->regs = DDB_LINK_TAG(port->lnr) |\n\t\t(rm->output->base + rm->output->size * nr);\n\n\tdev_dbg(dev->dev, \"init link %u, output %u, regs %08x\\n\",\n\t\tport->lnr, nr, output->regs);\n\n\tif (dev->has_dma) {\n\t\tconst struct ddb_regmap *rm0 = io_regmap(output, 0);\n\t\tu32 base = rm0->irq_base_odma;\n\n\t\tddb_irq_set(dev, 0, nr + base, &output_handler, output);\n\t\tddb_dma_init(output, nr, 1);\n\t}\n}\n\nstatic int ddb_port_match_i2c(struct ddb_port *port)\n{\n\tstruct ddb *dev = port->dev;\n\tu32 i;\n\n\tfor (i = 0; i < dev->i2c_num; i++) {\n\t\tif (dev->i2c[i].link == port->lnr &&\n\t\t    dev->i2c[i].nr == port->nr) {\n\t\t\tport->i2c = &dev->i2c[i];\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ddb_port_match_link_i2c(struct ddb_port *port)\n{\n\tstruct ddb *dev = port->dev;\n\tu32 i;\n\n\tfor (i = 0; i < dev->i2c_num; i++) {\n\t\tif (dev->i2c[i].link == port->lnr) {\n\t\t\tport->i2c = &dev->i2c[i];\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid ddb_ports_init(struct ddb *dev)\n{\n\tu32 i, l, p;\n\tstruct ddb_port *port;\n\tconst struct ddb_info *info;\n\tconst struct ddb_regmap *rm;\n\n\tfor (p = l = 0; l < DDB_MAX_LINK; l++) {\n\t\tinfo = dev->link[l].info;\n\t\tif (!info)\n\t\t\tcontinue;\n\t\trm = info->regmap;\n\t\tif (!rm)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < info->port_num; i++, p++) {\n\t\t\tport = &dev->port[p];\n\t\t\tport->dev = dev;\n\t\t\tport->nr = i;\n\t\t\tport->lnr = l;\n\t\t\tport->pnr = p;\n\t\t\tport->gap = 0xffffffff;\n\t\t\tport->obr = ci_bitrate;\n\t\t\tmutex_init(&port->i2c_gate_lock);\n\n\t\t\tif (!ddb_port_match_i2c(port)) {\n\t\t\t\tif (info->type == DDB_OCTOPUS_MAX)\n\t\t\t\t\tddb_port_match_link_i2c(port);\n\t\t\t}\n\n\t\t\tddb_port_probe(port);\n\n\t\t\tport->dvb[0].adap = &dev->adap[2 * p];\n\t\t\tport->dvb[1].adap = &dev->adap[2 * p + 1];\n\n\t\t\tif (port->class == DDB_PORT_NONE && i && p &&\n\t\t\t    dev->port[p - 1].type == DDB_CI_EXTERNAL_XO2) {\n\t\t\t\tport->class = DDB_PORT_CI;\n\t\t\t\tport->type = DDB_CI_EXTERNAL_XO2_B;\n\t\t\t\tport->name = \"DuoFlex CI_B\";\n\t\t\t\tport->i2c = dev->port[p - 1].i2c;\n\t\t\t}\n\n\t\t\tdev_info(dev->dev, \"Port %u: Link %u, Link Port %u (TAB %u): %s\\n\",\n\t\t\t\t port->pnr, port->lnr, port->nr, port->nr + 1,\n\t\t\t\t port->name);\n\n\t\t\tif (port->class == DDB_PORT_CI &&\n\t\t\t    port->type == DDB_CI_EXTERNAL_XO2) {\n\t\t\t\tddb_input_init(port, 2 * i, 0, 2 * i);\n\t\t\t\tddb_output_init(port, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (port->class == DDB_PORT_CI &&\n\t\t\t    port->type == DDB_CI_EXTERNAL_XO2_B) {\n\t\t\t\tddb_input_init(port, 2 * i - 1, 0, 2 * i - 1);\n\t\t\t\tddb_output_init(port, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (port->class == DDB_PORT_NONE)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (dev->link[l].info->type) {\n\t\t\tcase DDB_OCTOPUS_CI:\n\t\t\t\tif (i >= 2) {\n\t\t\t\t\tddb_input_init(port, 2 + i, 0, 2 + i);\n\t\t\t\t\tddb_input_init(port, 4 + i, 1, 4 + i);\n\t\t\t\t\tddb_output_init(port, i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase DDB_OCTOPUS:\n\t\t\t\tddb_input_init(port, 2 * i, 0, 2 * i);\n\t\t\t\tddb_input_init(port, 2 * i + 1, 1, 2 * i + 1);\n\t\t\t\tddb_output_init(port, i);\n\t\t\t\tbreak;\n\t\t\tcase DDB_OCTOPUS_MAX:\n\t\t\tcase DDB_OCTOPUS_MAX_CT:\n\t\t\tcase DDB_OCTOPUS_MCI:\n\t\t\t\tddb_input_init(port, 2 * i, 0, 2 * p);\n\t\t\t\tddb_input_init(port, 2 * i + 1, 1, 2 * p + 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdev->port_num = p;\n}\n\nvoid ddb_ports_release(struct ddb *dev)\n{\n\tint i;\n\tstruct ddb_port *port;\n\n\tfor (i = 0; i < dev->port_num; i++) {\n\t\tport = &dev->port[i];\n\t\tif (port->input[0] && port->input[0]->dma)\n\t\t\tcancel_work_sync(&port->input[0]->dma->work);\n\t\tif (port->input[1] && port->input[1]->dma)\n\t\t\tcancel_work_sync(&port->input[1]->dma->work);\n\t\tif (port->output && port->output->dma)\n\t\t\tcancel_work_sync(&port->output->dma->work);\n\t}\n}\n\n \n \n \n\n#define IRQ_HANDLE(_nr) \\\n\tdo { if ((s & (1UL << ((_nr) & 0x1f))) && \\\n\t\t dev->link[0].irq[_nr].handler) \\\n\t\tdev->link[0].irq[_nr].handler(dev->link[0].irq[_nr].data); } \\\n\twhile (0)\n\n#define IRQ_HANDLE_NIBBLE(_shift) {\t\t     \\\n\tif (s & (0x0000000f << ((_shift) & 0x1f))) { \\\n\t\tIRQ_HANDLE(0 + (_shift));\t     \\\n\t\tIRQ_HANDLE(1 + (_shift));\t     \\\n\t\tIRQ_HANDLE(2 + (_shift));\t     \\\n\t\tIRQ_HANDLE(3 + (_shift));\t     \\\n\t}\t\t\t\t\t     \\\n}\n\n#define IRQ_HANDLE_BYTE(_shift) {\t\t     \\\n\tif (s & (0x000000ff << ((_shift) & 0x1f))) { \\\n\t\tIRQ_HANDLE(0 + (_shift));\t     \\\n\t\tIRQ_HANDLE(1 + (_shift));\t     \\\n\t\tIRQ_HANDLE(2 + (_shift));\t     \\\n\t\tIRQ_HANDLE(3 + (_shift));\t     \\\n\t\tIRQ_HANDLE(4 + (_shift));\t     \\\n\t\tIRQ_HANDLE(5 + (_shift));\t     \\\n\t\tIRQ_HANDLE(6 + (_shift));\t     \\\n\t\tIRQ_HANDLE(7 + (_shift));\t     \\\n\t}\t\t\t\t\t     \\\n}\n\nstatic void irq_handle_msg(struct ddb *dev, u32 s)\n{\n\tdev->i2c_irq++;\n\tIRQ_HANDLE_NIBBLE(0);\n}\n\nstatic void irq_handle_io(struct ddb *dev, u32 s)\n{\n\tdev->ts_irq++;\n\tIRQ_HANDLE_NIBBLE(4);\n\tIRQ_HANDLE_BYTE(8);\n\tIRQ_HANDLE_BYTE(16);\n\tIRQ_HANDLE_BYTE(24);\n}\n\nirqreturn_t ddb_irq_handler0(int irq, void *dev_id)\n{\n\tstruct ddb *dev = (struct ddb *)dev_id;\n\tu32 mask = 0x8fffff00;\n\tu32 s = mask & ddbreadl(dev, INTERRUPT_STATUS);\n\n\tif (!s)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\tif (s & 0x80000000)\n\t\t\treturn IRQ_NONE;\n\t\tddbwritel(dev, s, INTERRUPT_ACK);\n\t\tirq_handle_io(dev, s);\n\t} while ((s = mask & ddbreadl(dev, INTERRUPT_STATUS)));\n\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t ddb_irq_handler1(int irq, void *dev_id)\n{\n\tstruct ddb *dev = (struct ddb *)dev_id;\n\tu32 mask = 0x8000000f;\n\tu32 s = mask & ddbreadl(dev, INTERRUPT_STATUS);\n\n\tif (!s)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\tif (s & 0x80000000)\n\t\t\treturn IRQ_NONE;\n\t\tddbwritel(dev, s, INTERRUPT_ACK);\n\t\tirq_handle_msg(dev, s);\n\t} while ((s = mask & ddbreadl(dev, INTERRUPT_STATUS)));\n\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t ddb_irq_handler(int irq, void *dev_id)\n{\n\tstruct ddb *dev = (struct ddb *)dev_id;\n\tu32 s = ddbreadl(dev, INTERRUPT_STATUS);\n\tint ret = IRQ_HANDLED;\n\n\tif (!s)\n\t\treturn IRQ_NONE;\n\tdo {\n\t\tif (s & 0x80000000)\n\t\t\treturn IRQ_NONE;\n\t\tddbwritel(dev, s, INTERRUPT_ACK);\n\n\t\tif (s & 0x0000000f)\n\t\t\tirq_handle_msg(dev, s);\n\t\tif (s & 0x0fffff00)\n\t\t\tirq_handle_io(dev, s);\n\t} while ((s = ddbreadl(dev, INTERRUPT_STATUS)));\n\n\treturn ret;\n}\n\n \n \n \n\nstatic int reg_wait(struct ddb *dev, u32 reg, u32 bit)\n{\n\tu32 count = 0;\n\n\twhile (safe_ddbreadl(dev, reg) & bit) {\n\t\tndelay(10);\n\t\tif (++count == 100)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int flashio(struct ddb *dev, u32 lnr, u8 *wbuf, u32 wlen, u8 *rbuf,\n\t\t   u32 rlen)\n{\n\tu32 data, shift;\n\tu32 tag = DDB_LINK_TAG(lnr);\n\tstruct ddb_link *link = &dev->link[lnr];\n\n\tmutex_lock(&link->flash_mutex);\n\tif (wlen > 4)\n\t\tddbwritel(dev, 1, tag | SPI_CONTROL);\n\twhile (wlen > 4) {\n\t\t \n\t\tdata = swab32(*(u32 *)wbuf);\n\t\twbuf += 4;\n\t\twlen -= 4;\n\t\tddbwritel(dev, data, tag | SPI_DATA);\n\t\tif (reg_wait(dev, tag | SPI_CONTROL, 4))\n\t\t\tgoto fail;\n\t}\n\tif (rlen)\n\t\tddbwritel(dev, 0x0001 | ((wlen << (8 + 3)) & 0x1f00),\n\t\t\t  tag | SPI_CONTROL);\n\telse\n\t\tddbwritel(dev, 0x0003 | ((wlen << (8 + 3)) & 0x1f00),\n\t\t\t  tag | SPI_CONTROL);\n\n\tdata = 0;\n\tshift = ((4 - wlen) * 8);\n\twhile (wlen) {\n\t\tdata <<= 8;\n\t\tdata |= *wbuf;\n\t\twlen--;\n\t\twbuf++;\n\t}\n\tif (shift)\n\t\tdata <<= shift;\n\tddbwritel(dev, data, tag | SPI_DATA);\n\tif (reg_wait(dev, tag | SPI_CONTROL, 4))\n\t\tgoto fail;\n\n\tif (!rlen) {\n\t\tddbwritel(dev, 0, tag | SPI_CONTROL);\n\t\tgoto exit;\n\t}\n\tif (rlen > 4)\n\t\tddbwritel(dev, 1, tag | SPI_CONTROL);\n\n\twhile (rlen > 4) {\n\t\tddbwritel(dev, 0xffffffff, tag | SPI_DATA);\n\t\tif (reg_wait(dev, tag | SPI_CONTROL, 4))\n\t\t\tgoto fail;\n\t\tdata = ddbreadl(dev, tag | SPI_DATA);\n\t\t*(u32 *)rbuf = swab32(data);\n\t\trbuf += 4;\n\t\trlen -= 4;\n\t}\n\tddbwritel(dev, 0x0003 | ((rlen << (8 + 3)) & 0x1F00),\n\t\t  tag | SPI_CONTROL);\n\tddbwritel(dev, 0xffffffff, tag | SPI_DATA);\n\tif (reg_wait(dev, tag | SPI_CONTROL, 4))\n\t\tgoto fail;\n\n\tdata = ddbreadl(dev, tag | SPI_DATA);\n\tddbwritel(dev, 0, tag | SPI_CONTROL);\n\n\tif (rlen < 4)\n\t\tdata <<= ((4 - rlen) * 8);\n\n\twhile (rlen > 0) {\n\t\t*rbuf = ((data >> 24) & 0xff);\n\t\tdata <<= 8;\n\t\trbuf++;\n\t\trlen--;\n\t}\nexit:\n\tmutex_unlock(&link->flash_mutex);\n\treturn 0;\nfail:\n\tmutex_unlock(&link->flash_mutex);\n\treturn -1;\n}\n\nint ddbridge_flashread(struct ddb *dev, u32 link, u8 *buf, u32 addr, u32 len)\n{\n\tu8 cmd[4] = {0x03, (addr >> 16) & 0xff,\n\t\t     (addr >> 8) & 0xff, addr & 0xff};\n\n\treturn flashio(dev, link, cmd, 4, buf, len);\n}\n\n \n\n#define DDB_NAME \"ddbridge\"\n\nstatic u32 ddb_num;\nstatic int ddb_major;\nstatic DEFINE_MUTEX(ddb_mutex);\n\nstatic int ddb_release(struct inode *inode, struct file *file)\n{\n\tstruct ddb *dev = file->private_data;\n\n\tdev->ddb_dev_users--;\n\treturn 0;\n}\n\nstatic int ddb_open(struct inode *inode, struct file *file)\n{\n\tstruct ddb *dev = ddbs[iminor(inode)];\n\n\tif (dev->ddb_dev_users)\n\t\treturn -EBUSY;\n\tdev->ddb_dev_users++;\n\tfile->private_data = dev;\n\treturn 0;\n}\n\nstatic long ddb_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct ddb *dev = file->private_data;\n\n\tdev_warn(dev->dev, \"DDB IOCTLs unsupported (cmd: %d, arg: %lu)\\n\",\n\t\t cmd, arg);\n\n\treturn -ENOTTY;\n}\n\nstatic const struct file_operations ddb_fops = {\n\t.unlocked_ioctl = ddb_ioctl,\n\t.open           = ddb_open,\n\t.release        = ddb_release,\n};\n\nstatic char *ddb_devnode(const struct device *device, umode_t *mode)\n{\n\tconst struct ddb *dev = dev_get_drvdata(device);\n\n\treturn kasprintf(GFP_KERNEL, \"ddbridge/card%d\", dev->nr);\n}\n\n#define __ATTR_MRO(_name, _show) {\t\t\t\t\\\n\t.attr\t= { .name = __stringify(_name), .mode = 0444 },\t\\\n\t.show\t= _show,\t\t\t\t\t\\\n}\n\n#define __ATTR_MWO(_name, _store) {\t\t\t\t\\\n\t.attr\t= { .name = __stringify(_name), .mode = 0222 },\t\\\n\t.store\t= _store,\t\t\t\t\t\\\n}\n\nstatic ssize_t ports_show(struct device *device,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\n\treturn sprintf(buf, \"%d\\n\", dev->port_num);\n}\n\nstatic ssize_t ts_irq_show(struct device *device,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\n\treturn sprintf(buf, \"%d\\n\", dev->ts_irq);\n}\n\nstatic ssize_t i2c_irq_show(struct device *device,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\n\treturn sprintf(buf, \"%d\\n\", dev->i2c_irq);\n}\n\nstatic ssize_t fan_show(struct device *device,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tu32 val;\n\n\tval = ddbreadl(dev, GPIO_OUTPUT) & 1;\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t fan_store(struct device *device, struct device_attribute *d,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tu32 val;\n\n\tif (sscanf(buf, \"%u\\n\", &val) != 1)\n\t\treturn -EINVAL;\n\tddbwritel(dev, 1, GPIO_DIRECTION);\n\tddbwritel(dev, val & 1, GPIO_OUTPUT);\n\treturn count;\n}\n\nstatic ssize_t fanspeed_show(struct device *device,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tint num = attr->attr.name[8] - 0x30;\n\tstruct ddb_link *link = &dev->link[num];\n\tu32 spd;\n\n\tspd = ddblreadl(link, TEMPMON_FANCONTROL) & 0xff;\n\treturn sprintf(buf, \"%u\\n\", spd * 100);\n}\n\nstatic ssize_t temp_show(struct device *device,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tstruct ddb_link *link = &dev->link[0];\n\tstruct i2c_adapter *adap;\n\tint temp, temp2;\n\tu8 tmp[2];\n\n\tif (!link->info->temp_num)\n\t\treturn sprintf(buf, \"no sensor\\n\");\n\tadap = &dev->i2c[link->info->temp_bus].adap;\n\tif (i2c_read_regs(adap, 0x48, 0, tmp, 2) < 0)\n\t\treturn sprintf(buf, \"read_error\\n\");\n\ttemp = (tmp[0] << 3) | (tmp[1] >> 5);\n\ttemp *= 125;\n\tif (link->info->temp_num == 2) {\n\t\tif (i2c_read_regs(adap, 0x49, 0, tmp, 2) < 0)\n\t\t\treturn sprintf(buf, \"read_error\\n\");\n\t\ttemp2 = (tmp[0] << 3) | (tmp[1] >> 5);\n\t\ttemp2 *= 125;\n\t\treturn sprintf(buf, \"%d %d\\n\", temp, temp2);\n\t}\n\treturn sprintf(buf, \"%d\\n\", temp);\n}\n\nstatic ssize_t ctemp_show(struct device *device,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tstruct i2c_adapter *adap;\n\tint temp;\n\tu8 tmp[2];\n\tint num = attr->attr.name[4] - 0x30;\n\n\tadap = &dev->i2c[num].adap;\n\tif (!adap)\n\t\treturn 0;\n\tif (i2c_read_regs(adap, 0x49, 0, tmp, 2) < 0)\n\t\tif (i2c_read_regs(adap, 0x4d, 0, tmp, 2) < 0)\n\t\t\treturn sprintf(buf, \"no sensor\\n\");\n\ttemp = tmp[0] * 1000;\n\treturn sprintf(buf, \"%d\\n\", temp);\n}\n\nstatic ssize_t led_show(struct device *device,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tint num = attr->attr.name[3] - 0x30;\n\n\treturn sprintf(buf, \"%d\\n\", dev->leds & (1 << num) ? 1 : 0);\n}\n\nstatic void ddb_set_led(struct ddb *dev, int num, int val)\n{\n\tif (!dev->link[0].info->led_num)\n\t\treturn;\n\tswitch (dev->port[num].class) {\n\tcase DDB_PORT_TUNER:\n\t\tswitch (dev->port[num].type) {\n\t\tcase DDB_TUNER_DVBS_ST:\n\t\t\ti2c_write_reg16(&dev->i2c[num].adap,\n\t\t\t\t\t0x69, 0xf14c, val ? 2 : 0);\n\t\t\tbreak;\n\t\tcase DDB_TUNER_DVBCT_ST:\n\t\t\ti2c_write_reg16(&dev->i2c[num].adap,\n\t\t\t\t\t0x1f, 0xf00e, 0);\n\t\t\ti2c_write_reg16(&dev->i2c[num].adap,\n\t\t\t\t\t0x1f, 0xf00f, val ? 1 : 0);\n\t\t\tbreak;\n\t\tcase DDB_TUNER_XO2 ... DDB_TUNER_DVBC2T2I_SONY:\n\t\t{\n\t\t\tu8 v;\n\n\t\t\ti2c_read_reg(&dev->i2c[num].adap, 0x10, 0x08, &v);\n\t\t\tv = (v & ~0x10) | (val ? 0x10 : 0);\n\t\t\ti2c_write_reg(&dev->i2c[num].adap, 0x10, 0x08, v);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic ssize_t led_store(struct device *device,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tint num = attr->attr.name[3] - 0x30;\n\tu32 val;\n\n\tif (sscanf(buf, \"%u\\n\", &val) != 1)\n\t\treturn -EINVAL;\n\tif (val)\n\t\tdev->leds |= (1 << num);\n\telse\n\t\tdev->leds &= ~(1 << num);\n\tddb_set_led(dev, num, val);\n\treturn count;\n}\n\nstatic ssize_t snr_show(struct device *device,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tchar snr[32];\n\tint num = attr->attr.name[3] - 0x30;\n\n\tif (dev->port[num].type >= DDB_TUNER_XO2) {\n\t\tif (i2c_read_regs(&dev->i2c[num].adap, 0x10, 0x10, snr, 16) < 0)\n\t\t\treturn sprintf(buf, \"NO SNR\\n\");\n\t\tsnr[16] = 0;\n\t} else {\n\t\t \n\t\tif (i2c_read_regs16(&dev->i2c[num].adap,\n\t\t\t\t    0x57, 0x100, snr, 32) < 0)\n\t\t\tif (i2c_read_regs16(&dev->i2c[num].adap,\n\t\t\t\t\t    0x50, 0x100, snr, 32) < 0)\n\t\t\t\treturn sprintf(buf, \"NO SNR\\n\");\n\t\tsnr[31] = 0;  \n\t}\n\treturn sprintf(buf, \"%s\\n\", snr);\n}\n\nstatic ssize_t bsnr_show(struct device *device,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tchar snr[16];\n\n\tddbridge_flashread(dev, 0, snr, 0x10, 15);\n\tsnr[15] = 0;  \n\treturn sprintf(buf, \"%s\\n\", snr);\n}\n\nstatic ssize_t bpsnr_show(struct device *device,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tunsigned char snr[32];\n\n\tif (!dev->i2c_num)\n\t\treturn 0;\n\n\tif (i2c_read_regs16(&dev->i2c[0].adap,\n\t\t\t    0x50, 0x0000, snr, 32) < 0 ||\n\t    snr[0] == 0xff)\n\t\treturn sprintf(buf, \"NO SNR\\n\");\n\tsnr[31] = 0;  \n\treturn sprintf(buf, \"%s\\n\", snr);\n}\n\nstatic ssize_t redirect_show(struct device *device,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn 0;\n}\n\nstatic ssize_t redirect_store(struct device *device,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tunsigned int i, p;\n\tint res;\n\n\tif (sscanf(buf, \"%x %x\\n\", &i, &p) != 2)\n\t\treturn -EINVAL;\n\tres = ddb_redirect(i, p);\n\tif (res < 0)\n\t\treturn res;\n\tdev_info(device, \"redirect: %02x, %02x\\n\", i, p);\n\treturn count;\n}\n\nstatic ssize_t gap_show(struct device *device,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tint num = attr->attr.name[3] - 0x30;\n\n\treturn sprintf(buf, \"%d\\n\", dev->port[num].gap);\n}\n\nstatic ssize_t gap_store(struct device *device, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tint num = attr->attr.name[3] - 0x30;\n\tunsigned int val;\n\n\tif (sscanf(buf, \"%u\\n\", &val) != 1)\n\t\treturn -EINVAL;\n\tif (val > 128)\n\t\treturn -EINVAL;\n\tif (val == 128)\n\t\tval = 0xffffffff;\n\tdev->port[num].gap = val;\n\treturn count;\n}\n\nstatic ssize_t version_show(struct device *device,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\n\treturn sprintf(buf, \"%08x %08x\\n\",\n\t\t       dev->link[0].ids.hwid, dev->link[0].ids.regmapid);\n}\n\nstatic ssize_t hwid_show(struct device *device,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\n\treturn sprintf(buf, \"0x%08X\\n\", dev->link[0].ids.hwid);\n}\n\nstatic ssize_t regmap_show(struct device *device,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\n\treturn sprintf(buf, \"0x%08X\\n\", dev->link[0].ids.regmapid);\n}\n\nstatic ssize_t fmode_show(struct device *device,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tint num = attr->attr.name[5] - 0x30;\n\tstruct ddb *dev = dev_get_drvdata(device);\n\n\treturn sprintf(buf, \"%u\\n\", dev->link[num].lnb.fmode);\n}\n\nstatic ssize_t devid_show(struct device *device,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tint num = attr->attr.name[5] - 0x30;\n\tstruct ddb *dev = dev_get_drvdata(device);\n\n\treturn sprintf(buf, \"%08x\\n\", dev->link[num].ids.devid);\n}\n\nstatic ssize_t fmode_store(struct device *device, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct ddb *dev = dev_get_drvdata(device);\n\tint num = attr->attr.name[5] - 0x30;\n\tunsigned int val;\n\n\tif (sscanf(buf, \"%u\\n\", &val) != 1)\n\t\treturn -EINVAL;\n\tif (val > 3)\n\t\treturn -EINVAL;\n\tddb_lnb_init_fmode(dev, &dev->link[num], val);\n\treturn count;\n}\n\nstatic struct device_attribute ddb_attrs[] = {\n\t__ATTR_RO(version),\n\t__ATTR_RO(ports),\n\t__ATTR_RO(ts_irq),\n\t__ATTR_RO(i2c_irq),\n\t__ATTR(gap0, 0664, gap_show, gap_store),\n\t__ATTR(gap1, 0664, gap_show, gap_store),\n\t__ATTR(gap2, 0664, gap_show, gap_store),\n\t__ATTR(gap3, 0664, gap_show, gap_store),\n\t__ATTR(fmode0, 0664, fmode_show, fmode_store),\n\t__ATTR(fmode1, 0664, fmode_show, fmode_store),\n\t__ATTR(fmode2, 0664, fmode_show, fmode_store),\n\t__ATTR(fmode3, 0664, fmode_show, fmode_store),\n\t__ATTR_MRO(devid0, devid_show),\n\t__ATTR_MRO(devid1, devid_show),\n\t__ATTR_MRO(devid2, devid_show),\n\t__ATTR_MRO(devid3, devid_show),\n\t__ATTR_RO(hwid),\n\t__ATTR_RO(regmap),\n\t__ATTR(redirect, 0664, redirect_show, redirect_store),\n\t__ATTR_MRO(snr,  bsnr_show),\n\t__ATTR_RO(bpsnr),\n\t__ATTR_NULL,\n};\n\nstatic struct device_attribute ddb_attrs_temp[] = {\n\t__ATTR_RO(temp),\n};\n\nstatic struct device_attribute ddb_attrs_fan[] = {\n\t__ATTR(fan, 0664, fan_show, fan_store),\n};\n\nstatic struct device_attribute ddb_attrs_snr[] = {\n\t__ATTR_MRO(snr0, snr_show),\n\t__ATTR_MRO(snr1, snr_show),\n\t__ATTR_MRO(snr2, snr_show),\n\t__ATTR_MRO(snr3, snr_show),\n};\n\nstatic struct device_attribute ddb_attrs_ctemp[] = {\n\t__ATTR_MRO(temp0, ctemp_show),\n\t__ATTR_MRO(temp1, ctemp_show),\n\t__ATTR_MRO(temp2, ctemp_show),\n\t__ATTR_MRO(temp3, ctemp_show),\n};\n\nstatic struct device_attribute ddb_attrs_led[] = {\n\t__ATTR(led0, 0664, led_show, led_store),\n\t__ATTR(led1, 0664, led_show, led_store),\n\t__ATTR(led2, 0664, led_show, led_store),\n\t__ATTR(led3, 0664, led_show, led_store),\n};\n\nstatic struct device_attribute ddb_attrs_fanspeed[] = {\n\t__ATTR_MRO(fanspeed0, fanspeed_show),\n\t__ATTR_MRO(fanspeed1, fanspeed_show),\n\t__ATTR_MRO(fanspeed2, fanspeed_show),\n\t__ATTR_MRO(fanspeed3, fanspeed_show),\n};\n\nstatic struct class ddb_class = {\n\t.name\t\t= \"ddbridge\",\n\t.devnode        = ddb_devnode,\n};\n\nstatic int ddb_class_create(void)\n{\n\tddb_major = register_chrdev(0, DDB_NAME, &ddb_fops);\n\tif (ddb_major < 0)\n\t\treturn ddb_major;\n\tif (class_register(&ddb_class) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void ddb_class_destroy(void)\n{\n\tclass_unregister(&ddb_class);\n\tunregister_chrdev(ddb_major, DDB_NAME);\n}\n\nstatic void ddb_device_attrs_del(struct ddb *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (dev->link[i].info && dev->link[i].info->tempmon_irq)\n\t\t\tdevice_remove_file(dev->ddb_dev,\n\t\t\t\t\t   &ddb_attrs_fanspeed[i]);\n\tfor (i = 0; i < dev->link[0].info->temp_num; i++)\n\t\tdevice_remove_file(dev->ddb_dev, &ddb_attrs_temp[i]);\n\tfor (i = 0; i < dev->link[0].info->fan_num; i++)\n\t\tdevice_remove_file(dev->ddb_dev, &ddb_attrs_fan[i]);\n\tfor (i = 0; i < dev->i2c_num && i < 4; i++) {\n\t\tif (dev->link[0].info->led_num)\n\t\t\tdevice_remove_file(dev->ddb_dev, &ddb_attrs_led[i]);\n\t\tdevice_remove_file(dev->ddb_dev, &ddb_attrs_snr[i]);\n\t\tdevice_remove_file(dev->ddb_dev, &ddb_attrs_ctemp[i]);\n\t}\n\tfor (i = 0; ddb_attrs[i].attr.name; i++)\n\t\tdevice_remove_file(dev->ddb_dev, &ddb_attrs[i]);\n}\n\nstatic int ddb_device_attrs_add(struct ddb *dev)\n{\n\tint i;\n\n\tfor (i = 0; ddb_attrs[i].attr.name; i++)\n\t\tif (device_create_file(dev->ddb_dev, &ddb_attrs[i]))\n\t\t\tgoto fail;\n\tfor (i = 0; i < dev->link[0].info->temp_num; i++)\n\t\tif (device_create_file(dev->ddb_dev, &ddb_attrs_temp[i]))\n\t\t\tgoto fail;\n\tfor (i = 0; i < dev->link[0].info->fan_num; i++)\n\t\tif (device_create_file(dev->ddb_dev, &ddb_attrs_fan[i]))\n\t\t\tgoto fail;\n\tfor (i = 0; (i < dev->i2c_num) && (i < 4); i++) {\n\t\tif (device_create_file(dev->ddb_dev, &ddb_attrs_snr[i]))\n\t\t\tgoto fail;\n\t\tif (device_create_file(dev->ddb_dev, &ddb_attrs_ctemp[i]))\n\t\t\tgoto fail;\n\t\tif (dev->link[0].info->led_num)\n\t\t\tif (device_create_file(dev->ddb_dev,\n\t\t\t\t\t       &ddb_attrs_led[i]))\n\t\t\t\tgoto fail;\n\t}\n\tfor (i = 0; i < 4; i++)\n\t\tif (dev->link[i].info && dev->link[i].info->tempmon_irq)\n\t\t\tif (device_create_file(dev->ddb_dev,\n\t\t\t\t\t       &ddb_attrs_fanspeed[i]))\n\t\t\t\tgoto fail;\n\treturn 0;\nfail:\n\treturn -1;\n}\n\nint ddb_device_create(struct ddb *dev)\n{\n\tint res = 0;\n\n\tif (ddb_num == DDB_MAX_ADAPTER)\n\t\treturn -ENOMEM;\n\tmutex_lock(&ddb_mutex);\n\tdev->nr = ddb_num;\n\tddbs[dev->nr] = dev;\n\tdev->ddb_dev = device_create(&ddb_class, dev->dev,\n\t\t\t\t     MKDEV(ddb_major, dev->nr),\n\t\t\t\t     dev, \"ddbridge%d\", dev->nr);\n\tif (IS_ERR(dev->ddb_dev)) {\n\t\tres = PTR_ERR(dev->ddb_dev);\n\t\tdev_info(dev->dev, \"Could not create ddbridge%d\\n\", dev->nr);\n\t\tgoto fail;\n\t}\n\tres = ddb_device_attrs_add(dev);\n\tif (res) {\n\t\tddb_device_attrs_del(dev);\n\t\tdevice_destroy(&ddb_class, MKDEV(ddb_major, dev->nr));\n\t\tddbs[dev->nr] = NULL;\n\t\tdev->ddb_dev = ERR_PTR(-ENODEV);\n\t} else {\n\t\tddb_num++;\n\t}\nfail:\n\tmutex_unlock(&ddb_mutex);\n\treturn res;\n}\n\nvoid ddb_device_destroy(struct ddb *dev)\n{\n\tif (IS_ERR(dev->ddb_dev))\n\t\treturn;\n\tddb_device_attrs_del(dev);\n\tdevice_destroy(&ddb_class, MKDEV(ddb_major, dev->nr));\n}\n\n \n \n \n\nstatic void tempmon_setfan(struct ddb_link *link)\n{\n\tu32 temp, temp2, pwm;\n\n\tif ((ddblreadl(link, TEMPMON_CONTROL) &\n\t    TEMPMON_CONTROL_OVERTEMP) != 0) {\n\t\tdev_info(link->dev->dev, \"Over temperature condition\\n\");\n\t\tlink->overtemperature_error = 1;\n\t}\n\ttemp  = (ddblreadl(link, TEMPMON_SENSOR0) >> 8) & 0xFF;\n\tif (temp & 0x80)\n\t\ttemp = 0;\n\ttemp2  = (ddblreadl(link, TEMPMON_SENSOR1) >> 8) & 0xFF;\n\tif (temp2 & 0x80)\n\t\ttemp2 = 0;\n\tif (temp2 > temp)\n\t\ttemp = temp2;\n\n\tpwm = (ddblreadl(link, TEMPMON_FANCONTROL) >> 8) & 0x0F;\n\tif (pwm > 10)\n\t\tpwm = 10;\n\n\tif (temp >= link->temp_tab[pwm]) {\n\t\twhile (pwm < 10 && temp >= link->temp_tab[pwm + 1])\n\t\t\tpwm += 1;\n\t} else {\n\t\twhile (pwm > 1 && temp < link->temp_tab[pwm - 2])\n\t\t\tpwm -= 1;\n\t}\n\tddblwritel(link, (pwm << 8), TEMPMON_FANCONTROL);\n}\n\nstatic void temp_handler(void *data)\n{\n\tstruct ddb_link *link = (struct ddb_link *)data;\n\n\tspin_lock(&link->temp_lock);\n\ttempmon_setfan(link);\n\tspin_unlock(&link->temp_lock);\n}\n\nstatic int tempmon_init(struct ddb_link *link, int first_time)\n{\n\tstruct ddb *dev = link->dev;\n\tint status = 0;\n\tu32 l = link->nr;\n\n\tspin_lock_irq(&link->temp_lock);\n\tif (first_time) {\n\t\tstatic u8 temperature_table[11] = {\n\t\t\t30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80 };\n\n\t\tmemcpy(link->temp_tab, temperature_table,\n\t\t       sizeof(temperature_table));\n\t}\n\tddb_irq_set(dev, l, link->info->tempmon_irq, temp_handler, link);\n\tddblwritel(link, (TEMPMON_CONTROL_OVERTEMP | TEMPMON_CONTROL_AUTOSCAN |\n\t\t\t  TEMPMON_CONTROL_INTENABLE),\n\t\t   TEMPMON_CONTROL);\n\tddblwritel(link, (3 << 8), TEMPMON_FANCONTROL);\n\n\tlink->overtemperature_error =\n\t\t((ddblreadl(link, TEMPMON_CONTROL) &\n\t\t\tTEMPMON_CONTROL_OVERTEMP) != 0);\n\tif (link->overtemperature_error) {\n\t\tdev_info(link->dev->dev, \"Over temperature condition\\n\");\n\t\tstatus = -1;\n\t}\n\ttempmon_setfan(link);\n\tspin_unlock_irq(&link->temp_lock);\n\treturn status;\n}\n\nstatic int ddb_init_tempmon(struct ddb_link *link)\n{\n\tconst struct ddb_info *info = link->info;\n\n\tif (!info->tempmon_irq)\n\t\treturn 0;\n\tif (info->type == DDB_OCTOPUS_MAX_CT)\n\t\tif (link->ids.regmapid < 0x00010002)\n\t\t\treturn 0;\n\tspin_lock_init(&link->temp_lock);\n\tdev_dbg(link->dev->dev, \"init_tempmon\\n\");\n\treturn tempmon_init(link, 1);\n}\n\n \n \n \n\nstatic int ddb_init_boards(struct ddb *dev)\n{\n\tconst struct ddb_info *info;\n\tstruct ddb_link *link;\n\tu32 l;\n\n\tfor (l = 0; l < DDB_MAX_LINK; l++) {\n\t\tlink = &dev->link[l];\n\t\tinfo = link->info;\n\n\t\tif (!info)\n\t\t\tcontinue;\n\t\tif (info->board_control) {\n\t\t\tddbwritel(dev, 0, DDB_LINK_TAG(l) | BOARD_CONTROL);\n\t\t\tmsleep(100);\n\t\t\tddbwritel(dev, info->board_control_2,\n\t\t\t\t  DDB_LINK_TAG(l) | BOARD_CONTROL);\n\t\t\tusleep_range(2000, 3000);\n\t\t\tddbwritel(dev,\n\t\t\t\t  info->board_control_2 | info->board_control,\n\t\t\t\t  DDB_LINK_TAG(l) | BOARD_CONTROL);\n\t\t\tusleep_range(2000, 3000);\n\t\t}\n\t\tddb_init_tempmon(link);\n\t}\n\treturn 0;\n}\n\nint ddb_init(struct ddb *dev)\n{\n\tmutex_init(&dev->link[0].lnb.lock);\n\tmutex_init(&dev->link[0].flash_mutex);\n\tif (no_init) {\n\t\tddb_device_create(dev);\n\t\treturn 0;\n\t}\n\n\tddb_init_boards(dev);\n\n\tif (ddb_i2c_init(dev) < 0)\n\t\tgoto fail1;\n\tddb_ports_init(dev);\n\tif (ddb_buffers_alloc(dev) < 0) {\n\t\tdev_info(dev->dev, \"Could not allocate buffer memory\\n\");\n\t\tgoto fail2;\n\t}\n\tif (ddb_ports_attach(dev) < 0)\n\t\tgoto fail3;\n\n\tddb_device_create(dev);\n\n\tif (dev->link[0].info->fan_num)\t{\n\t\tddbwritel(dev, 1, GPIO_DIRECTION);\n\t\tddbwritel(dev, 1, GPIO_OUTPUT);\n\t}\n\treturn 0;\n\nfail3:\n\tdev_err(dev->dev, \"fail3\\n\");\n\tddb_ports_detach(dev);\n\tddb_buffers_free(dev);\nfail2:\n\tdev_err(dev->dev, \"fail2\\n\");\n\tddb_ports_release(dev);\n\tddb_i2c_release(dev);\nfail1:\n\tdev_err(dev->dev, \"fail1\\n\");\n\treturn -1;\n}\n\nvoid ddb_unmap(struct ddb *dev)\n{\n\tif (dev->regs)\n\t\tiounmap(dev->regs);\n\tvfree(dev);\n}\n\nint ddb_exit_ddbridge(int stage, int error)\n{\n\tswitch (stage) {\n\tdefault:\n\tcase 2:\n\t\tdestroy_workqueue(ddb_wq);\n\t\tfallthrough;\n\tcase 1:\n\t\tddb_class_destroy();\n\t\tbreak;\n\t}\n\n\treturn error;\n}\n\nint ddb_init_ddbridge(void)\n{\n\tif (dma_buf_num < 8)\n\t\tdma_buf_num = 8;\n\tif (dma_buf_num > 32)\n\t\tdma_buf_num = 32;\n\tif (dma_buf_size < 1)\n\t\tdma_buf_size = 1;\n\tif (dma_buf_size > 43)\n\t\tdma_buf_size = 43;\n\n\tif (ddb_class_create() < 0)\n\t\treturn -1;\n\tddb_wq = alloc_workqueue(\"ddbridge\", 0, 0);\n\tif (!ddb_wq)\n\t\treturn ddb_exit_ddbridge(1, -1);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}