{
  "module_name": "hexium_orion.c",
  "hash_id": "dd335b1fbc16f53232c9b89c499dd405e39b39b23fc559465951beff2d0377c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7146/hexium_orion.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DEBUG_VARIABLE debug\n\n#include <media/drv-intf/saa7146_vv.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int debug;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"debug verbosity\");\n\n \nstatic int hexium_num;\n\n#define HEXIUM_HV_PCI6_ORION\t\t1\n#define HEXIUM_ORION_1SVHS_3BNC\t\t2\n#define HEXIUM_ORION_4BNC\t\t3\n\n#define HEXIUM_STD (V4L2_STD_PAL | V4L2_STD_SECAM | V4L2_STD_NTSC)\n#define HEXIUM_INPUTS\t9\nstatic struct v4l2_input hexium_inputs[HEXIUM_INPUTS] = {\n\t{ 0, \"CVBS 1\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 1, \"CVBS 2\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 2, \"CVBS 3\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 3, \"CVBS 4\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 4, \"CVBS 5\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 5, \"CVBS 6\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 6, \"Y/C 1\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 7, \"Y/C 2\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 8, \"Y/C 3\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n};\n\n#define HEXIUM_AUDIOS\t0\n\nstruct hexium_data\n{\n\ts8 adr;\n\tu8 byte;\n};\n\nstruct hexium\n{\n\tint type;\n\tstruct video_device\tvideo_dev;\n\tstruct i2c_adapter\ti2c_adapter;\n\n\tint cur_input;\t \n};\n\n \nstatic u8 hexium_saa7110[53]={\n  0x4C,0x3C,0x0D,0xEF,0xBD,0xF0,0x00,0x00,\n  0xF8,0xF8,0x60,0x60,0x40,0x86,0x18,0x90,\n  0x00,0x2C,0x40,0x46,0x42,0x1A,0xFF,0xDA,\n  0xF0,0x8B,0x00,0x00,0x00,0x00,0x00,0x00,\n  0xD9,0x17,0x40,0x41,0x80,0x41,0x80,0x4F,\n  0xFE,0x01,0x0F,0x0F,0x03,0x01,0x81,0x03,\n  0x44,0x75,0x01,0x8C,0x03\n};\n\nstatic struct {\n\tstruct hexium_data data[8];\n} hexium_input_select[] = {\n{\n\t{  \n\t\t{ 0x06, 0x00 },\n\t\t{ 0x20, 0xD9 },\n\t\t{ 0x21, 0x17 }, \n\t\t{ 0x22, 0x40 },\n\t\t{ 0x2C, 0x03 },\n\t\t{ 0x30, 0x44 },\n\t\t{ 0x31, 0x75 }, \n\t\t{ 0x21, 0x16 }, \n\t}\n}, {\n\t{  \n\t\t{ 0x06, 0x00 },\n\t\t{ 0x20, 0x78 },\n\t\t{ 0x21, 0x07 }, \n\t\t{ 0x22, 0xD2 },\n\t\t{ 0x2C, 0x83 },\n\t\t{ 0x30, 0x60 },\n\t\t{ 0x31, 0xB5 }, \n\t\t{ 0x21, 0x03 },\n\t}\n}, {\n\t{  \n\t\t{ 0x06, 0x00 },\n\t\t{ 0x20, 0xBA },\n\t\t{ 0x21, 0x07 }, \n\t\t{ 0x22, 0x91 },\n\t\t{ 0x2C, 0x03 },\n\t\t{ 0x30, 0x60 },\n\t\t{ 0x31, 0xB5 }, \n\t\t{ 0x21, 0x05 }, \n\t}\n}, {\n\t{  \n\t\t{ 0x06, 0x00 },\n\t\t{ 0x20, 0xD8 },\n\t\t{ 0x21, 0x17 }, \n\t\t{ 0x22, 0x40 },\n\t\t{ 0x2C, 0x03 },\n\t\t{ 0x30, 0x44 },\n\t\t{ 0x31, 0x75 }, \n\t\t{ 0x21, 0x16 }, \n\t}\n}, {\n\t{  \n\t\t{ 0x06, 0x00 },\n\t\t{ 0x20, 0xB8 },\n\t\t{ 0x21, 0x07 }, \n\t\t{ 0x22, 0x91 },\n\t\t{ 0x2C, 0x03 },\n\t\t{ 0x30, 0x60 },\n\t\t{ 0x31, 0xB5 }, \n\t\t{ 0x21, 0x05 }, \n\t}\n}, {\n\t{  \n\t\t{ 0x06, 0x00 },\n\t\t{ 0x20, 0x7C },\n\t\t{ 0x21, 0x07 }, \n\t\t{ 0x22, 0xD2 },\n\t\t{ 0x2C, 0x83 },\n\t\t{ 0x30, 0x60 },\n\t\t{ 0x31, 0xB5 }, \n\t\t{ 0x21, 0x03 },\n\t}\n}, {\n\t{  \n\t\t{ 0x06, 0x80 },\n\t\t{ 0x20, 0x59 },\n\t\t{ 0x21, 0x17 },\n\t\t{ 0x22, 0x42 },\n\t\t{ 0x2C, 0xA3 },\n\t\t{ 0x30, 0x44 },\n\t\t{ 0x31, 0x75 },\n\t\t{ 0x21, 0x12 },\n\t}\n}, {\n\t{  \n\t\t{ 0x06, 0x80 },\n\t\t{ 0x20, 0x9A },\n\t\t{ 0x21, 0x17 },\n\t\t{ 0x22, 0xB1 },\n\t\t{ 0x2C, 0x13 },\n\t\t{ 0x30, 0x60 },\n\t\t{ 0x31, 0xB5 },\n\t\t{ 0x21, 0x14 },\n\t}\n}, {\n\t{  \n\t\t{ 0x06, 0x80 },\n\t\t{ 0x20, 0x3C },\n\t\t{ 0x21, 0x27 },\n\t\t{ 0x22, 0xC1 },\n\t\t{ 0x2C, 0x23 },\n\t\t{ 0x30, 0x44 },\n\t\t{ 0x31, 0x75 },\n\t\t{ 0x21, 0x21 },\n\t}\n}\n};\n\nstatic struct saa7146_standard hexium_standards[] = {\n\t{\n\t\t.name\t= \"PAL\",\t.id\t= V4L2_STD_PAL,\n\t\t.v_offset\t= 16,\t.v_field\t= 288,\n\t\t.h_offset\t= 1,\t.h_pixels\t= 680,\n\t\t.v_max_out\t= 576,\t.h_max_out\t= 768,\n\t}, {\n\t\t.name\t= \"NTSC\",\t.id\t= V4L2_STD_NTSC,\n\t\t.v_offset\t= 16,\t.v_field\t= 240,\n\t\t.h_offset\t= 1,\t.h_pixels\t= 640,\n\t\t.v_max_out\t= 480,\t.h_max_out\t= 640,\n\t}, {\n\t\t.name\t= \"SECAM\",\t.id\t= V4L2_STD_SECAM,\n\t\t.v_offset\t= 16,\t.v_field\t= 288,\n\t\t.h_offset\t= 1,\t.h_pixels\t= 720,\n\t\t.v_max_out\t= 576,\t.h_max_out\t= 768,\n\t}\n};\n\n \nstatic int hexium_probe(struct saa7146_dev *dev)\n{\n\tstruct hexium *hexium = NULL;\n\tunion i2c_smbus_data data;\n\tint err = 0;\n\n\tDEB_EE(\"\\n\");\n\n\t \n\tif (0 == dev->revision) {\n\t\treturn -EFAULT;\n\t}\n\n\thexium = kzalloc(sizeof(*hexium), GFP_KERNEL);\n\tif (!hexium)\n\t\treturn -ENOMEM;\n\n\t \n\tsaa7146_write(dev, MC1, (MASK_08 | MASK_24 | MASK_10 | MASK_26));\n\n\tsaa7146_write(dev, DD1_INIT, 0x01000100);\n\tsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\n\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\n\tstrscpy(hexium->i2c_adapter.name, \"hexium orion\",\n\t\tsizeof(hexium->i2c_adapter.name));\n\tsaa7146_i2c_adapter_prepare(dev, &hexium->i2c_adapter, SAA7146_I2C_BUS_BIT_RATE_480);\n\tif (i2c_add_adapter(&hexium->i2c_adapter) < 0) {\n\t\tDEB_S(\"cannot register i2c-device. skipping.\\n\");\n\t\tkfree(hexium);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tsaa7146_setgpio(dev, 0, SAA7146_GPIO_OUTHI);\n\t \n\tsaa7146_setgpio(dev, 2, SAA7146_GPIO_OUTHI);\n\n\tmdelay(10);\n\n\t \n\tif (0x17c8 == dev->pci->subsystem_vendor && 0x0101 == dev->pci->subsystem_device) {\n\t\tpr_info(\"device is a Hexium Orion w/ 1 SVHS + 3 BNC inputs\\n\");\n\t\t \n\t\tdev->ext_priv = hexium;\n\t\thexium->type = HEXIUM_ORION_1SVHS_3BNC;\n\t\treturn 0;\n\t}\n\n\tif (0x17c8 == dev->pci->subsystem_vendor && 0x2101 == dev->pci->subsystem_device) {\n\t\tpr_info(\"device is a Hexium Orion w/ 4 BNC inputs\\n\");\n\t\t \n\t\tdev->ext_priv = hexium;\n\t\thexium->type = HEXIUM_ORION_4BNC;\n\t\treturn 0;\n\t}\n\n\t \n\terr = i2c_smbus_xfer(&hexium->i2c_adapter, 0x4e, 0, I2C_SMBUS_READ,\n\t\t\t     0x00, I2C_SMBUS_BYTE_DATA, &data);\n\tif (err == 0) {\n\t\tpr_info(\"device is a Hexium HV-PCI6/Orion (old)\\n\");\n\t\t \n\t\tdev->ext_priv = hexium;\n\t\thexium->type = HEXIUM_HV_PCI6_ORION;\n\t\treturn 0;\n\t}\n\n\ti2c_del_adapter(&hexium->i2c_adapter);\n\tkfree(hexium);\n\treturn -EFAULT;\n}\n\n \nstatic int hexium_init_done(struct saa7146_dev *dev)\n{\n\tstruct hexium *hexium = (struct hexium *) dev->ext_priv;\n\tunion i2c_smbus_data data;\n\tint i = 0;\n\n\tDEB_D(\"hexium_init_done called\\n\");\n\n\t \n\tfor (i = 0; i < sizeof(hexium_saa7110); i++) {\n\t\tdata.byte = hexium_saa7110[i];\n\t\tif (0 != i2c_smbus_xfer(&hexium->i2c_adapter, 0x4e, 0, I2C_SMBUS_WRITE, i, I2C_SMBUS_BYTE_DATA, &data)) {\n\t\t\tpr_err(\"failed for address 0x%02x\\n\", i);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hexium_set_input(struct hexium *hexium, int input)\n{\n\tunion i2c_smbus_data data;\n\tint i = 0;\n\n\tDEB_D(\"\\n\");\n\n\tfor (i = 0; i < 8; i++) {\n\t\tint adr = hexium_input_select[input].data[i].adr;\n\t\tdata.byte = hexium_input_select[input].data[i].byte;\n\t\tif (0 != i2c_smbus_xfer(&hexium->i2c_adapter, 0x4e, 0, I2C_SMBUS_WRITE, adr, I2C_SMBUS_BYTE_DATA, &data)) {\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\"%d: 0x%02x => 0x%02x\\n\", input, adr, data.byte);\n\t}\n\n\treturn 0;\n}\n\nstatic int vidioc_enum_input(struct file *file, void *fh, struct v4l2_input *i)\n{\n\tDEB_EE(\"VIDIOC_ENUMINPUT %d\\n\", i->index);\n\n\tif (i->index >= HEXIUM_INPUTS)\n\t\treturn -EINVAL;\n\n\tmemcpy(i, &hexium_inputs[i->index], sizeof(struct v4l2_input));\n\n\tDEB_D(\"v4l2_ioctl: VIDIOC_ENUMINPUT %d\\n\", i->index);\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *input)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct hexium *hexium = (struct hexium *) dev->ext_priv;\n\n\t*input = hexium->cur_input;\n\n\tDEB_D(\"VIDIOC_G_INPUT: %d\\n\", *input);\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int input)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct hexium *hexium = (struct hexium *) dev->ext_priv;\n\n\tif (input >= HEXIUM_INPUTS)\n\t\treturn -EINVAL;\n\n\thexium->cur_input = input;\n\thexium_set_input(hexium, input);\n\n\treturn 0;\n}\n\nstatic struct saa7146_ext_vv vv_data;\n\n \nstatic int hexium_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_data *info)\n{\n\tstruct hexium *hexium = (struct hexium *) dev->ext_priv;\n\tint ret;\n\n\tDEB_EE(\"\\n\");\n\n\tret = saa7146_vv_init(dev, &vv_data);\n\tif (ret) {\n\t\tpr_err(\"Error in saa7146_vv_init()\\n\");\n\t\treturn ret;\n\t}\n\n\tvv_data.vid_ops.vidioc_enum_input = vidioc_enum_input;\n\tvv_data.vid_ops.vidioc_g_input = vidioc_g_input;\n\tvv_data.vid_ops.vidioc_s_input = vidioc_s_input;\n\tif (0 != saa7146_register_device(&hexium->video_dev, dev, \"hexium orion\", VFL_TYPE_VIDEO)) {\n\t\tpr_err(\"cannot register capture v4l2 device. skipping.\\n\");\n\t\treturn -1;\n\t}\n\n\tpr_err(\"found 'hexium orion' frame grabber-%d\\n\", hexium_num);\n\thexium_num++;\n\n\t \n\thexium->cur_input = 0;\n\thexium_init_done(dev);\n\thexium_set_input(hexium, 0);\n\n\treturn 0;\n}\n\nstatic int hexium_detach(struct saa7146_dev *dev)\n{\n\tstruct hexium *hexium = (struct hexium *) dev->ext_priv;\n\n\tDEB_EE(\"dev:%p\\n\", dev);\n\n\tsaa7146_unregister_device(&hexium->video_dev, dev);\n\tsaa7146_vv_release(dev);\n\n\thexium_num--;\n\n\ti2c_del_adapter(&hexium->i2c_adapter);\n\tkfree(hexium);\n\treturn 0;\n}\n\nstatic int std_callback(struct saa7146_dev *dev, struct saa7146_standard *std)\n{\n\treturn 0;\n}\n\nstatic struct saa7146_extension extension;\n\nstatic struct saa7146_pci_extension_data hexium_hv_pci6 = {\n\t.ext_priv = \"Hexium HV-PCI6 / Orion\",\n\t.ext = &extension,\n};\n\nstatic struct saa7146_pci_extension_data hexium_orion_1svhs_3bnc = {\n\t.ext_priv = \"Hexium HV-PCI6 / Orion (1 SVHS/3 BNC)\",\n\t.ext = &extension,\n};\n\nstatic struct saa7146_pci_extension_data hexium_orion_4bnc = {\n\t.ext_priv = \"Hexium HV-PCI6 / Orion (4 BNC)\",\n\t.ext = &extension,\n};\n\nstatic const struct pci_device_id pci_tbl[] = {\n\t{\n\t .vendor = PCI_VENDOR_ID_PHILIPS,\n\t .device = PCI_DEVICE_ID_PHILIPS_SAA7146,\n\t .subvendor = 0x0000,\n\t .subdevice = 0x0000,\n\t .driver_data = (unsigned long) &hexium_hv_pci6,\n\t },\n\t{\n\t .vendor = PCI_VENDOR_ID_PHILIPS,\n\t .device = PCI_DEVICE_ID_PHILIPS_SAA7146,\n\t .subvendor = 0x17c8,\n\t .subdevice = 0x0101,\n\t .driver_data = (unsigned long) &hexium_orion_1svhs_3bnc,\n\t },\n\t{\n\t .vendor = PCI_VENDOR_ID_PHILIPS,\n\t .device = PCI_DEVICE_ID_PHILIPS_SAA7146,\n\t .subvendor = 0x17c8,\n\t .subdevice = 0x2101,\n\t .driver_data = (unsigned long) &hexium_orion_4bnc,\n\t },\n\t{\n\t .vendor = 0,\n\t }\n};\n\nMODULE_DEVICE_TABLE(pci, pci_tbl);\n\nstatic struct saa7146_ext_vv vv_data = {\n\t.inputs = HEXIUM_INPUTS,\n\t.capabilities = 0,\n\t.stds = &hexium_standards[0],\n\t.num_stds = ARRAY_SIZE(hexium_standards),\n\t.std_callback = &std_callback,\n};\n\nstatic struct saa7146_extension extension = {\n\t.name = \"hexium HV-PCI6 Orion\",\n\t.flags = 0,\t\t\n\n\t.pci_tbl = &pci_tbl[0],\n\t.module = THIS_MODULE,\n\n\t.probe = hexium_probe,\n\t.attach = hexium_attach,\n\t.detach = hexium_detach,\n\n\t.irq_mask = 0,\n\t.irq_func = NULL,\n};\n\nstatic int __init hexium_init_module(void)\n{\n\tif (0 != saa7146_register_extension(&extension)) {\n\t\tDEB_S(\"failed to register extension\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit hexium_cleanup_module(void)\n{\n\tsaa7146_unregister_extension(&extension);\n}\n\nmodule_init(hexium_init_module);\nmodule_exit(hexium_cleanup_module);\n\nMODULE_DESCRIPTION(\"video4linux-2 driver for Hexium Orion frame grabber cards\");\nMODULE_AUTHOR(\"Michael Hunold <michael@mihu.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}