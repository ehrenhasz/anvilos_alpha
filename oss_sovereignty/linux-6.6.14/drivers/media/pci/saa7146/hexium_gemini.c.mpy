{
  "module_name": "hexium_gemini.c",
  "hash_id": "0f8ea7e48ab432112f9853e9561aa564fc1301890b7ba3c736439a0692c6877a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7146/hexium_gemini.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DEBUG_VARIABLE debug\n\n#include <media/drv-intf/saa7146_vv.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int debug;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"debug verbosity\");\n\n \nstatic int hexium_num;\n\n#define HEXIUM_GEMINI\t\t\t4\n#define HEXIUM_GEMINI_DUAL\t\t5\n\n#define HEXIUM_STD (V4L2_STD_PAL | V4L2_STD_SECAM | V4L2_STD_NTSC)\n#define HEXIUM_INPUTS\t9\nstatic struct v4l2_input hexium_inputs[HEXIUM_INPUTS] = {\n\t{ 0, \"CVBS 1\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 1, \"CVBS 2\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 2, \"CVBS 3\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 3, \"CVBS 4\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 4, \"CVBS 5\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 5, \"CVBS 6\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 6, \"Y/C 1\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 7, \"Y/C 2\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n\t{ 8, \"Y/C 3\",\tV4L2_INPUT_TYPE_CAMERA,\t0, 0, HEXIUM_STD, 0, V4L2_IN_CAP_STD },\n};\n\n#define HEXIUM_AUDIOS\t0\n\nstruct hexium_data\n{\n\ts8 adr;\n\tu8 byte;\n};\n\n#define HEXIUM_GEMINI_V_1_0\t\t1\n#define HEXIUM_GEMINI_DUAL_V_1_0\t2\n\nstruct hexium\n{\n\tint type;\n\n\tstruct video_device\tvideo_dev;\n\tstruct i2c_adapter\ti2c_adapter;\n\n\tint\t\tcur_input;\t \n\tv4l2_std_id\tcur_std;\t \n};\n\n \nstatic u8 hexium_ks0127b[0x100]={\n  0x00,0x52,0x30,0x40,0x01,0x0C,0x2A,0x10,\n  0x00,0x00,0x00,0x60,0x00,0x00,0x0F,0x06,\n  0x00,0x00,0xE4,0xC0,0x00,0x00,0x00,0x00,\n  0x14,0x9B,0xFE,0xFF,0xFC,0xFF,0x03,0x22,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x2C,0x9B,0x00,\n  0x00,0x00,0x10,0x80,0x80,0x10,0x80,0x80,\n  0x01,0x04,0x00,0x00,0x00,0x29,0xC0,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n};\n\nstatic struct hexium_data hexium_pal[] = {\n\t{ 0x01, 0x52 }, { 0x12, 0x64 }, { 0x2D, 0x2C }, { 0x2E, 0x9B }, { -1 , 0xFF }\n};\n\nstatic struct hexium_data hexium_ntsc[] = {\n\t{ 0x01, 0x53 }, { 0x12, 0x04 }, { 0x2D, 0x23 }, { 0x2E, 0x81 }, { -1 , 0xFF }\n};\n\nstatic struct hexium_data hexium_secam[] = {\n\t{ 0x01, 0x52 }, { 0x12, 0x64 }, { 0x2D, 0x2C }, { 0x2E, 0x9B }, { -1 , 0xFF }\n};\n\nstatic struct hexium_data hexium_input_select[] = {\n\t{ 0x02, 0x60 },\n\t{ 0x02, 0x64 },\n\t{ 0x02, 0x61 },\n\t{ 0x02, 0x65 },\n\t{ 0x02, 0x62 },\n\t{ 0x02, 0x66 },\n\t{ 0x02, 0x68 },\n\t{ 0x02, 0x69 },\n\t{ 0x02, 0x6A },\n};\n\n \nstatic struct saa7146_standard hexium_standards[] = {\n\t{\n\t\t.name\t= \"PAL\",\t.id\t= V4L2_STD_PAL,\n\t\t.v_offset\t= 28,\t.v_field\t= 288,\n\t\t.h_offset\t= 1,\t.h_pixels\t= 680,\n\t\t.v_max_out\t= 576,\t.h_max_out\t= 768,\n\t}, {\n\t\t.name\t= \"NTSC\",\t.id\t= V4L2_STD_NTSC,\n\t\t.v_offset\t= 28,\t.v_field\t= 240,\n\t\t.h_offset\t= 1,\t.h_pixels\t= 640,\n\t\t.v_max_out\t= 480,\t.h_max_out\t= 640,\n\t}, {\n\t\t.name\t= \"SECAM\",\t.id\t= V4L2_STD_SECAM,\n\t\t.v_offset\t= 28,\t.v_field\t= 288,\n\t\t.h_offset\t= 1,\t.h_pixels\t= 720,\n\t\t.v_max_out\t= 576,\t.h_max_out\t= 768,\n\t}\n};\n\n \nstatic int hexium_init_done(struct saa7146_dev *dev)\n{\n\tstruct hexium *hexium = (struct hexium *) dev->ext_priv;\n\tunion i2c_smbus_data data;\n\tint i = 0;\n\n\tDEB_D(\"hexium_init_done called\\n\");\n\n\t \n\tfor (i = 0; i < sizeof(hexium_ks0127b); i++) {\n\t\tdata.byte = hexium_ks0127b[i];\n\t\tif (0 != i2c_smbus_xfer(&hexium->i2c_adapter, 0x6c, 0, I2C_SMBUS_WRITE, i, I2C_SMBUS_BYTE_DATA, &data)) {\n\t\t\tpr_err(\"hexium_init_done() failed for address 0x%02x\\n\",\n\t\t\t       i);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hexium_set_input(struct hexium *hexium, int input)\n{\n\tunion i2c_smbus_data data;\n\n\tDEB_D(\"\\n\");\n\n\tdata.byte = hexium_input_select[input].byte;\n\tif (0 != i2c_smbus_xfer(&hexium->i2c_adapter, 0x6c, 0, I2C_SMBUS_WRITE, hexium_input_select[input].adr, I2C_SMBUS_BYTE_DATA, &data)) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int hexium_set_standard(struct hexium *hexium, struct hexium_data *vdec)\n{\n\tunion i2c_smbus_data data;\n\tint i = 0;\n\n\tDEB_D(\"\\n\");\n\n\twhile (vdec[i].adr != -1) {\n\t\tdata.byte = vdec[i].byte;\n\t\tif (0 != i2c_smbus_xfer(&hexium->i2c_adapter, 0x6c, 0, I2C_SMBUS_WRITE, vdec[i].adr, I2C_SMBUS_BYTE_DATA, &data)) {\n\t\t\tpr_err(\"hexium_init_done: hexium_set_standard() failed for address 0x%02x\\n\",\n\t\t\t       i);\n\t\t\treturn -1;\n\t\t}\n\t\ti++;\n\t}\n\treturn 0;\n}\n\nstatic int vidioc_enum_input(struct file *file, void *fh, struct v4l2_input *i)\n{\n\tDEB_EE(\"VIDIOC_ENUMINPUT %d\\n\", i->index);\n\n\tif (i->index >= HEXIUM_INPUTS)\n\t\treturn -EINVAL;\n\n\tmemcpy(i, &hexium_inputs[i->index], sizeof(struct v4l2_input));\n\n\tDEB_D(\"v4l2_ioctl: VIDIOC_ENUMINPUT %d\\n\", i->index);\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *input)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct hexium *hexium = (struct hexium *) dev->ext_priv;\n\n\t*input = hexium->cur_input;\n\n\tDEB_D(\"VIDIOC_G_INPUT: %d\\n\", *input);\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int input)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct hexium *hexium = (struct hexium *) dev->ext_priv;\n\n\tDEB_EE(\"VIDIOC_S_INPUT %d\\n\", input);\n\n\tif (input >= HEXIUM_INPUTS)\n\t\treturn -EINVAL;\n\n\thexium->cur_input = input;\n\thexium_set_input(hexium, input);\n\treturn 0;\n}\n\nstatic struct saa7146_ext_vv vv_data;\n\n \nstatic int hexium_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_data *info)\n{\n\tstruct hexium *hexium;\n\tint ret;\n\n\tDEB_EE(\"\\n\");\n\n\thexium = kzalloc(sizeof(*hexium), GFP_KERNEL);\n\tif (!hexium)\n\t\treturn -ENOMEM;\n\n\tdev->ext_priv = hexium;\n\n\t \n\tsaa7146_write(dev, MC1, (MASK_08 | MASK_24 | MASK_10 | MASK_26));\n\n\tstrscpy(hexium->i2c_adapter.name, \"hexium gemini\",\n\t\tsizeof(hexium->i2c_adapter.name));\n\tsaa7146_i2c_adapter_prepare(dev, &hexium->i2c_adapter, SAA7146_I2C_BUS_BIT_RATE_480);\n\tif (i2c_add_adapter(&hexium->i2c_adapter) < 0) {\n\t\tDEB_S(\"cannot register i2c-device. skipping.\\n\");\n\t\tkfree(hexium);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tsaa7146_setgpio(dev, 2, SAA7146_GPIO_OUTHI);\n\n\tsaa7146_write(dev, DD1_INIT, 0x07000700);\n\tsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\n\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\n\t \n\thexium->cur_input = 0;\n\thexium_init_done(dev);\n\n\thexium_set_standard(hexium, hexium_pal);\n\thexium->cur_std = V4L2_STD_PAL;\n\n\thexium_set_input(hexium, 0);\n\thexium->cur_input = 0;\n\n\tret = saa7146_vv_init(dev, &vv_data);\n\tif (ret) {\n\t\ti2c_del_adapter(&hexium->i2c_adapter);\n\t\tkfree(hexium);\n\t\treturn ret;\n\t}\n\n\tvv_data.vid_ops.vidioc_enum_input = vidioc_enum_input;\n\tvv_data.vid_ops.vidioc_g_input = vidioc_g_input;\n\tvv_data.vid_ops.vidioc_s_input = vidioc_s_input;\n\tret = saa7146_register_device(&hexium->video_dev, dev, \"hexium gemini\", VFL_TYPE_VIDEO);\n\tif (ret < 0) {\n\t\tpr_err(\"cannot register capture v4l2 device. skipping.\\n\");\n\t\tsaa7146_vv_release(dev);\n\t\ti2c_del_adapter(&hexium->i2c_adapter);\n\t\tkfree(hexium);\n\t\treturn ret;\n\t}\n\n\tpr_info(\"found 'hexium gemini' frame grabber-%d\\n\", hexium_num);\n\thexium_num++;\n\n\treturn 0;\n}\n\nstatic int hexium_detach(struct saa7146_dev *dev)\n{\n\tstruct hexium *hexium = (struct hexium *) dev->ext_priv;\n\n\tDEB_EE(\"dev:%p\\n\", dev);\n\n\tsaa7146_unregister_device(&hexium->video_dev, dev);\n\tsaa7146_vv_release(dev);\n\n\thexium_num--;\n\n\ti2c_del_adapter(&hexium->i2c_adapter);\n\tkfree(hexium);\n\treturn 0;\n}\n\nstatic int std_callback(struct saa7146_dev *dev, struct saa7146_standard *std)\n{\n\tstruct hexium *hexium = (struct hexium *) dev->ext_priv;\n\n\tif (V4L2_STD_PAL == std->id) {\n\t\thexium_set_standard(hexium, hexium_pal);\n\t\thexium->cur_std = V4L2_STD_PAL;\n\t\treturn 0;\n\t} else if (V4L2_STD_NTSC == std->id) {\n\t\thexium_set_standard(hexium, hexium_ntsc);\n\t\thexium->cur_std = V4L2_STD_NTSC;\n\t\treturn 0;\n\t} else if (V4L2_STD_SECAM == std->id) {\n\t\thexium_set_standard(hexium, hexium_secam);\n\t\thexium->cur_std = V4L2_STD_SECAM;\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic struct saa7146_extension hexium_extension;\n\nstatic struct saa7146_pci_extension_data hexium_gemini_4bnc = {\n\t.ext_priv = \"Hexium Gemini (4 BNC)\",\n\t.ext = &hexium_extension,\n};\n\nstatic struct saa7146_pci_extension_data hexium_gemini_dual_4bnc = {\n\t.ext_priv = \"Hexium Gemini Dual (4 BNC)\",\n\t.ext = &hexium_extension,\n};\n\nstatic const struct pci_device_id pci_tbl[] = {\n\t{\n\t .vendor = PCI_VENDOR_ID_PHILIPS,\n\t .device = PCI_DEVICE_ID_PHILIPS_SAA7146,\n\t .subvendor = 0x17c8,\n\t .subdevice = 0x2401,\n\t .driver_data = (unsigned long) &hexium_gemini_4bnc,\n\t },\n\t{\n\t .vendor = PCI_VENDOR_ID_PHILIPS,\n\t .device = PCI_DEVICE_ID_PHILIPS_SAA7146,\n\t .subvendor = 0x17c8,\n\t .subdevice = 0x2402,\n\t .driver_data = (unsigned long) &hexium_gemini_dual_4bnc,\n\t },\n\t{\n\t .vendor = 0,\n\t }\n};\n\nMODULE_DEVICE_TABLE(pci, pci_tbl);\n\nstatic struct saa7146_ext_vv vv_data = {\n\t.inputs = HEXIUM_INPUTS,\n\t.capabilities = 0,\n\t.stds = &hexium_standards[0],\n\t.num_stds = ARRAY_SIZE(hexium_standards),\n\t.std_callback = &std_callback,\n};\n\nstatic struct saa7146_extension hexium_extension = {\n\t.name = \"hexium gemini\",\n\t.flags = SAA7146_USE_I2C_IRQ,\n\n\t.pci_tbl = &pci_tbl[0],\n\t.module = THIS_MODULE,\n\n\t.attach = hexium_attach,\n\t.detach = hexium_detach,\n\n\t.irq_mask = 0,\n\t.irq_func = NULL,\n};\n\nstatic int __init hexium_init_module(void)\n{\n\tif (0 != saa7146_register_extension(&hexium_extension)) {\n\t\tDEB_S(\"failed to register extension\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit hexium_cleanup_module(void)\n{\n\tsaa7146_unregister_extension(&hexium_extension);\n}\n\nmodule_init(hexium_init_module);\nmodule_exit(hexium_cleanup_module);\n\nMODULE_DESCRIPTION(\"video4linux-2 driver for Hexium Gemini frame grabber cards\");\nMODULE_AUTHOR(\"Michael Hunold <michael@mihu.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}