{
  "module_name": "mxb.c",
  "hash_id": "1fbec6ece3db7873d7cb0e203883ce9e260bbd6bcd175729aa738b2c9413e6da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/saa7146/mxb.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DEBUG_VARIABLE debug\n\n#include <media/drv-intf/saa7146_vv.h>\n#include <media/tuner.h>\n#include <media/v4l2-common.h>\n#include <media/i2c/saa7115.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include \"tea6415c.h\"\n#include \"tea6420.h\"\n\n#define MXB_AUDIOS\t6\n\n#define I2C_SAA7111A  0x24\n#define\tI2C_TDA9840   0x42\n#define\tI2C_TEA6415C  0x43\n#define\tI2C_TEA6420_1 0x4c\n#define\tI2C_TEA6420_2 0x4d\n#define\tI2C_TUNER     0x60\n\n#define MXB_BOARD_CAN_DO_VBI(dev)   (dev->revision != 0)\n\n \nstatic int mxb_num;\n\n \nstatic int freq = 4148;\nmodule_param(freq, int, 0644);\nMODULE_PARM_DESC(freq, \"initial frequency the tuner will be tuned to while setup\");\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Turn on/off device debugging (default:off).\");\n\n#define MXB_STD (V4L2_STD_PAL_BG | V4L2_STD_PAL_I | V4L2_STD_SECAM | V4L2_STD_NTSC)\n#define MXB_INPUTS 4\nenum { TUNER, AUX1, AUX3, AUX3_YC };\n\nstatic struct v4l2_input mxb_inputs[MXB_INPUTS] = {\n\t{ TUNER,   \"Tuner\",          V4L2_INPUT_TYPE_TUNER,  0x3f, 0,\n\t\tV4L2_STD_PAL_BG | V4L2_STD_PAL_I, 0, V4L2_IN_CAP_STD },\n\t{ AUX1,\t   \"AUX1\",           V4L2_INPUT_TYPE_CAMERA, 0x3f, 0,\n\t\tMXB_STD, 0, V4L2_IN_CAP_STD },\n\t{ AUX3,\t   \"AUX3 Composite\", V4L2_INPUT_TYPE_CAMERA, 0x3f, 0,\n\t\tMXB_STD, 0, V4L2_IN_CAP_STD },\n\t{ AUX3_YC, \"AUX3 S-Video\",   V4L2_INPUT_TYPE_CAMERA, 0x3f, 0,\n\t\tMXB_STD, 0, V4L2_IN_CAP_STD },\n};\n\n \nstatic struct {\n\tint hps_source;\n\tint hps_sync;\n} input_port_selection[MXB_INPUTS] = {\n\t{ SAA7146_HPS_SOURCE_PORT_A, SAA7146_HPS_SYNC_PORT_A },\n\t{ SAA7146_HPS_SOURCE_PORT_A, SAA7146_HPS_SYNC_PORT_A },\n\t{ SAA7146_HPS_SOURCE_PORT_A, SAA7146_HPS_SYNC_PORT_A },\n\t{ SAA7146_HPS_SOURCE_PORT_A, SAA7146_HPS_SYNC_PORT_A },\n};\n\n \nstatic int video_audio_connect[MXB_INPUTS] =\n\t{ 0, 1, 3, 3 };\n\nstruct mxb_routing {\n\tu32 input;\n\tu32 output;\n};\n\n \nstatic struct v4l2_audio mxb_audios[MXB_AUDIOS] = {\n\t    {\n\t\t.index\t= 0,\n\t\t.name\t= \"Tuner\",\n\t\t.capability = V4L2_AUDCAP_STEREO,\n\t} , {\n\t\t.index\t= 1,\n\t\t.name\t= \"AUX1\",\n\t\t.capability = V4L2_AUDCAP_STEREO,\n\t} , {\n\t\t.index\t= 2,\n\t\t.name\t= \"AUX2\",\n\t\t.capability = V4L2_AUDCAP_STEREO,\n\t} , {\n\t\t.index\t= 3,\n\t\t.name\t= \"AUX3\",\n\t\t.capability = V4L2_AUDCAP_STEREO,\n\t} , {\n\t\t.index\t= 4,\n\t\t.name\t= \"Radio (X9)\",\n\t\t.capability = V4L2_AUDCAP_STEREO,\n\t} , {\n\t\t.index\t= 5,\n\t\t.name\t= \"CD-ROM (X10)\",\n\t\t.capability = V4L2_AUDCAP_STEREO,\n\t}\n};\n\n \nstatic struct mxb_routing TEA6420_cd[MXB_AUDIOS + 1][2] = {\n\t{ { 1, 1 }, { 1, 1 } },\t \n\t{ { 5, 1 }, { 6, 1 } },\t \n\t{ { 4, 1 }, { 6, 1 } },\t \n\t{ { 3, 1 }, { 6, 1 } },\t \n\t{ { 1, 1 }, { 3, 1 } },\t \n\t{ { 1, 1 }, { 2, 1 } },\t \n\t{ { 6, 1 }, { 6, 1 } }\t \n};\n\n \nstatic struct mxb_routing TEA6420_line[MXB_AUDIOS + 1][2] = {\n\t{ { 2, 3 }, { 1, 2 } },\n\t{ { 5, 3 }, { 6, 2 } },\n\t{ { 4, 3 }, { 6, 2 } },\n\t{ { 3, 3 }, { 6, 2 } },\n\t{ { 2, 3 }, { 3, 2 } },\n\t{ { 2, 3 }, { 2, 2 } },\n\t{ { 6, 3 }, { 6, 2 } }\t \n};\n\nstruct mxb\n{\n\tstruct video_device\tvideo_dev;\n\tstruct video_device\tvbi_dev;\n\n\tstruct i2c_adapter\ti2c_adapter;\n\n\tstruct v4l2_subdev\t*saa7111a;\n\tstruct v4l2_subdev\t*tda9840;\n\tstruct v4l2_subdev\t*tea6415c;\n\tstruct v4l2_subdev\t*tuner;\n\tstruct v4l2_subdev\t*tea6420_1;\n\tstruct v4l2_subdev\t*tea6420_2;\n\n\tint\tcur_mode;\t \n\tint\tcur_input;\t \n\tint\tcur_audinput;\t \n\tint\tcur_mute;\t \n\tstruct v4l2_frequency\tcur_freq;\t \n};\n\n#define saa7111a_call(mxb, o, f, args...) \\\n\tv4l2_subdev_call(mxb->saa7111a, o, f, ##args)\n#define tda9840_call(mxb, o, f, args...) \\\n\tv4l2_subdev_call(mxb->tda9840, o, f, ##args)\n#define tea6415c_call(mxb, o, f, args...) \\\n\tv4l2_subdev_call(mxb->tea6415c, o, f, ##args)\n#define tuner_call(mxb, o, f, args...) \\\n\tv4l2_subdev_call(mxb->tuner, o, f, ##args)\n#define call_all(dev, o, f, args...) \\\n\tv4l2_device_call_until_err(&dev->v4l2_dev, 0, o, f, ##args)\n\nstatic void mxb_update_audmode(struct mxb *mxb)\n{\n\tstruct v4l2_tuner t = {\n\t\t.audmode = mxb->cur_mode,\n\t};\n\n\ttda9840_call(mxb, tuner, s_tuner, &t);\n}\n\nstatic inline void tea6420_route(struct mxb *mxb, int idx)\n{\n\tv4l2_subdev_call(mxb->tea6420_1, audio, s_routing,\n\t\tTEA6420_cd[idx][0].input, TEA6420_cd[idx][0].output, 0);\n\tv4l2_subdev_call(mxb->tea6420_2, audio, s_routing,\n\t\tTEA6420_cd[idx][1].input, TEA6420_cd[idx][1].output, 0);\n\tv4l2_subdev_call(mxb->tea6420_1, audio, s_routing,\n\t\tTEA6420_line[idx][0].input, TEA6420_line[idx][0].output, 0);\n\tv4l2_subdev_call(mxb->tea6420_2, audio, s_routing,\n\t\tTEA6420_line[idx][1].input, TEA6420_line[idx][1].output, 0);\n}\n\nstatic struct saa7146_extension extension;\n\nstatic int mxb_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct saa7146_dev *dev = container_of(ctrl->handler,\n\t\t\t\tstruct saa7146_dev, ctrl_handler);\n\tstruct mxb *mxb = dev->ext_priv;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tmxb->cur_mute = ctrl->val;\n\t\t \n\t\ttea6420_route(mxb, ctrl->val ? 6 :\n\t\t\t\tvideo_audio_connect[mxb->cur_input]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct v4l2_ctrl_ops mxb_ctrl_ops = {\n\t.s_ctrl = mxb_s_ctrl,\n};\n\nstatic int mxb_probe(struct saa7146_dev *dev)\n{\n\tstruct v4l2_ctrl_handler *hdl = &dev->ctrl_handler;\n\tstruct mxb *mxb = NULL;\n\n\tv4l2_ctrl_new_std(hdl, &mxb_ctrl_ops,\n\t\t\tV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\n\tif (hdl->error)\n\t\treturn hdl->error;\n\tmxb = kzalloc(sizeof(struct mxb), GFP_KERNEL);\n\tif (mxb == NULL) {\n\t\tDEB_D(\"not enough kernel memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\n\tsnprintf(mxb->i2c_adapter.name, sizeof(mxb->i2c_adapter.name), \"mxb%d\", mxb_num);\n\n\tsaa7146_i2c_adapter_prepare(dev, &mxb->i2c_adapter, SAA7146_I2C_BUS_BIT_RATE_480);\n\tif (i2c_add_adapter(&mxb->i2c_adapter) < 0) {\n\t\tDEB_S(\"cannot register i2c-device. skipping.\\n\");\n\t\tkfree(mxb);\n\t\treturn -EFAULT;\n\t}\n\n\tmxb->saa7111a = v4l2_i2c_new_subdev(&dev->v4l2_dev, &mxb->i2c_adapter,\n\t\t\t\"saa7111\", I2C_SAA7111A, NULL);\n\tmxb->tea6420_1 = v4l2_i2c_new_subdev(&dev->v4l2_dev, &mxb->i2c_adapter,\n\t\t\t\"tea6420\", I2C_TEA6420_1, NULL);\n\tmxb->tea6420_2 = v4l2_i2c_new_subdev(&dev->v4l2_dev, &mxb->i2c_adapter,\n\t\t\t\"tea6420\", I2C_TEA6420_2, NULL);\n\tmxb->tea6415c = v4l2_i2c_new_subdev(&dev->v4l2_dev, &mxb->i2c_adapter,\n\t\t\t\"tea6415c\", I2C_TEA6415C, NULL);\n\tmxb->tda9840 = v4l2_i2c_new_subdev(&dev->v4l2_dev, &mxb->i2c_adapter,\n\t\t\t\"tda9840\", I2C_TDA9840, NULL);\n\tmxb->tuner = v4l2_i2c_new_subdev(&dev->v4l2_dev, &mxb->i2c_adapter,\n\t\t\t\"tuner\", I2C_TUNER, NULL);\n\n\t \n\tif (!mxb->tea6420_1 || !mxb->tea6420_2 || !mxb->tea6415c ||\n\t    !mxb->tda9840 || !mxb->saa7111a || !mxb->tuner) {\n\t\tpr_err(\"did not find all i2c devices. aborting\\n\");\n\t\ti2c_del_adapter(&mxb->i2c_adapter);\n\t\tkfree(mxb);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\t \n\tdev->ext_priv = mxb;\n\n\tv4l2_ctrl_handler_setup(hdl);\n\n\treturn 0;\n}\n\n \nstatic struct {\n\tint\tlength;\n\tchar\tdata[9];\n} mxb_saa7740_init[] = {\n\t{ 3, { 0x80, 0x00, 0x00 } },{ 3, { 0x80, 0x89, 0x00 } },\n\t{ 3, { 0x80, 0xb0, 0x0a } },{ 3, { 0x00, 0x00, 0x00 } },\n\t{ 3, { 0x49, 0x00, 0x00 } },{ 3, { 0x4a, 0x00, 0x00 } },\n\t{ 3, { 0x4b, 0x00, 0x00 } },{ 3, { 0x4c, 0x00, 0x00 } },\n\t{ 3, { 0x4d, 0x00, 0x00 } },{ 3, { 0x4e, 0x00, 0x00 } },\n\t{ 3, { 0x4f, 0x00, 0x00 } },{ 3, { 0x50, 0x00, 0x00 } },\n\t{ 3, { 0x51, 0x00, 0x00 } },{ 3, { 0x52, 0x00, 0x00 } },\n\t{ 3, { 0x53, 0x00, 0x00 } },{ 3, { 0x54, 0x00, 0x00 } },\n\t{ 3, { 0x55, 0x00, 0x00 } },{ 3, { 0x56, 0x00, 0x00 } },\n\t{ 3, { 0x57, 0x00, 0x00 } },{ 3, { 0x58, 0x00, 0x00 } },\n\t{ 3, { 0x59, 0x00, 0x00 } },{ 3, { 0x5a, 0x00, 0x00 } },\n\t{ 3, { 0x5b, 0x00, 0x00 } },{ 3, { 0x5c, 0x00, 0x00 } },\n\t{ 3, { 0x5d, 0x00, 0x00 } },{ 3, { 0x5e, 0x00, 0x00 } },\n\t{ 3, { 0x5f, 0x00, 0x00 } },{ 3, { 0x60, 0x00, 0x00 } },\n\t{ 3, { 0x61, 0x00, 0x00 } },{ 3, { 0x62, 0x00, 0x00 } },\n\t{ 3, { 0x63, 0x00, 0x00 } },{ 3, { 0x64, 0x00, 0x00 } },\n\t{ 3, { 0x65, 0x00, 0x00 } },{ 3, { 0x66, 0x00, 0x00 } },\n\t{ 3, { 0x67, 0x00, 0x00 } },{ 3, { 0x68, 0x00, 0x00 } },\n\t{ 3, { 0x69, 0x00, 0x00 } },{ 3, { 0x6a, 0x00, 0x00 } },\n\t{ 3, { 0x6b, 0x00, 0x00 } },{ 3, { 0x6c, 0x00, 0x00 } },\n\t{ 3, { 0x6d, 0x00, 0x00 } },{ 3, { 0x6e, 0x00, 0x00 } },\n\t{ 3, { 0x6f, 0x00, 0x00 } },{ 3, { 0x70, 0x00, 0x00 } },\n\t{ 3, { 0x71, 0x00, 0x00 } },{ 3, { 0x72, 0x00, 0x00 } },\n\t{ 3, { 0x73, 0x00, 0x00 } },{ 3, { 0x74, 0x00, 0x00 } },\n\t{ 3, { 0x75, 0x00, 0x00 } },{ 3, { 0x76, 0x00, 0x00 } },\n\t{ 3, { 0x77, 0x00, 0x00 } },{ 3, { 0x41, 0x00, 0x42 } },\n\t{ 3, { 0x42, 0x10, 0x42 } },{ 3, { 0x43, 0x20, 0x42 } },\n\t{ 3, { 0x44, 0x30, 0x42 } },{ 3, { 0x45, 0x00, 0x01 } },\n\t{ 3, { 0x46, 0x00, 0x01 } },{ 3, { 0x47, 0x00, 0x01 } },\n\t{ 3, { 0x48, 0x00, 0x01 } },\n\t{ 9, { 0x01, 0x03, 0xc5, 0x5c, 0x7a, 0x85, 0x01, 0x00, 0x54 } },\n\t{ 9, { 0x21, 0x03, 0xc5, 0x5c, 0x7a, 0x85, 0x01, 0x00, 0x54 } },\n\t{ 9, { 0x09, 0x0b, 0xb4, 0x6b, 0x74, 0x85, 0x95, 0x00, 0x34 } },\n\t{ 9, { 0x29, 0x0b, 0xb4, 0x6b, 0x74, 0x85, 0x95, 0x00, 0x34 } },\n\t{ 9, { 0x11, 0x17, 0x43, 0x62, 0x68, 0x89, 0xd1, 0xff, 0xb0 } },\n\t{ 9, { 0x31, 0x17, 0x43, 0x62, 0x68, 0x89, 0xd1, 0xff, 0xb0 } },\n\t{ 9, { 0x19, 0x20, 0x62, 0x51, 0x5a, 0x95, 0x19, 0x01, 0x50 } },\n\t{ 9, { 0x39, 0x20, 0x62, 0x51, 0x5a, 0x95, 0x19, 0x01, 0x50 } },\n\t{ 9, { 0x05, 0x3e, 0xd2, 0x69, 0x4e, 0x9a, 0x51, 0x00, 0xf0 } },\n\t{ 9, { 0x25, 0x3e, 0xd2, 0x69, 0x4e, 0x9a, 0x51, 0x00, 0xf0 } },\n\t{ 9, { 0x0d, 0x3d, 0xa1, 0x40, 0x7d, 0x9f, 0x29, 0xfe, 0x14 } },\n\t{ 9, { 0x2d, 0x3d, 0xa1, 0x40, 0x7d, 0x9f, 0x29, 0xfe, 0x14 } },\n\t{ 9, { 0x15, 0x73, 0xa1, 0x50, 0x5d, 0xa6, 0xf5, 0xfe, 0x38 } },\n\t{ 9, { 0x35, 0x73, 0xa1, 0x50, 0x5d, 0xa6, 0xf5, 0xfe, 0x38 } },\n\t{ 9, { 0x1d, 0xed, 0xd0, 0x68, 0x29, 0xb4, 0xe1, 0x00, 0xb8 } },\n\t{ 9, { 0x3d, 0xed, 0xd0, 0x68, 0x29, 0xb4, 0xe1, 0x00, 0xb8 } },\n\t{ 3, { 0x80, 0xb3, 0x0a } },\n\t{-1, { 0 } }\n};\n\n \nstatic int mxb_init_done(struct saa7146_dev* dev)\n{\n\tstruct mxb* mxb = (struct mxb*)dev->ext_priv;\n\tstruct i2c_msg msg;\n\tstruct tuner_setup tun_setup;\n\tv4l2_std_id std = V4L2_STD_PAL_BG;\n\n\tint i, err = 0;\n\n\t \n\ttea6420_route(mxb, 6);\n\n\t \n\tsaa7111a_call(mxb, video, s_std, std);\n\n\t \n\tsaa7111a_call(mxb, video, s_routing, SAA7115_COMPOSITE0,\n\t\tSAA7111_FMT_CCIR, 0);\n\n\t \n\ttun_setup.mode_mask = T_ANALOG_TV;\n\ttun_setup.addr = ADDR_UNSET;\n\ttun_setup.type = TUNER_PHILIPS_PAL;\n\ttuner_call(mxb, tuner, s_type_addr, &tun_setup);\n\t \n\tmxb->cur_freq.tuner = 0;\n\tmxb->cur_freq.type = V4L2_TUNER_ANALOG_TV;\n\tmxb->cur_freq.frequency = freq;\n\ttuner_call(mxb, tuner, s_frequency, &mxb->cur_freq);\n\n\t \n\t \n\tsaa7146_write(dev, GPIO_CTRL, 0x00404050);\n\tsaa7111a_call(mxb, core, s_gpio, 1);\n\tsaa7111a_call(mxb, video, s_std, std);\n\ttuner_call(mxb, video, s_std, std);\n\n\t \n\ttea6415c_call(mxb, video, s_routing, 3, 17, 0);\n\n\t \n\ttea6415c_call(mxb, video, s_routing, 3, 13, 0);\n\n\t \n\tmxb->cur_input = 0;\n\tmxb->cur_audinput = video_audio_connect[mxb->cur_input];\n\tmxb->cur_mute = 1;\n\n\tmxb->cur_mode = V4L2_TUNER_MODE_STEREO;\n\tmxb_update_audmode(mxb);\n\n\t \n\tmsg.addr = 0x1b;\n\tmsg.flags = 0;\n\tmsg.len = mxb_saa7740_init[0].length;\n\tmsg.buf = &mxb_saa7740_init[0].data[0];\n\n\terr = i2c_transfer(&mxb->i2c_adapter, &msg, 1);\n\tif (err == 1) {\n\t\t \n\t\textension.flags &= ~SAA7146_USE_I2C_IRQ;\n\t\tfor (i = 1; ; i++) {\n\t\t\tif (-1 == mxb_saa7740_init[i].length)\n\t\t\t\tbreak;\n\n\t\t\tmsg.len = mxb_saa7740_init[i].length;\n\t\t\tmsg.buf = &mxb_saa7740_init[i].data[0];\n\t\t\terr = i2c_transfer(&mxb->i2c_adapter, &msg, 1);\n\t\t\tif (err != 1) {\n\t\t\t\tDEB_D(\"failed to initialize 'sound arena module'\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t\tpr_info(\"'sound arena module' detected\\n\");\n\t}\nerr:\n\t \n\n\t \n\n\t \n\tsaa7146_set_hps_source_and_sync(dev, input_port_selection[mxb->cur_input].hps_source,\n\t\t\tinput_port_selection[mxb->cur_input].hps_sync);\n\n\t \n\n\t \n\tsaa7146_write(dev, DD1_STREAM_B,\t0x00000000);\n\tsaa7146_write(dev, DD1_INIT,\t\t0x02000200);\n\tsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\n\n\treturn 0;\n}\n\n \n \n\nstatic int vidioc_enum_input(struct file *file, void *fh, struct v4l2_input *i)\n{\n\tDEB_EE(\"VIDIOC_ENUMINPUT %d\\n\", i->index);\n\tif (i->index >= MXB_INPUTS)\n\t\treturn -EINVAL;\n\tmemcpy(i, &mxb_inputs[i->index], sizeof(struct v4l2_input));\n\treturn 0;\n}\n\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *i)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct mxb *mxb = (struct mxb *)dev->ext_priv;\n\t*i = mxb->cur_input;\n\n\tDEB_EE(\"VIDIOC_G_INPUT %d\\n\", *i);\n\treturn 0;\n}\n\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int input)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct mxb *mxb = (struct mxb *)dev->ext_priv;\n\tint err = 0;\n\tint i = 0;\n\n\tDEB_EE(\"VIDIOC_S_INPUT %d\\n\", input);\n\n\tif (input >= MXB_INPUTS)\n\t\treturn -EINVAL;\n\n\tmxb->cur_input = input;\n\n\tsaa7146_set_hps_source_and_sync(dev, input_port_selection[input].hps_source,\n\t\t\tinput_port_selection[input].hps_sync);\n\n\t \n\tswitch (input) {\n\tcase TUNER:\n\t\ti = SAA7115_COMPOSITE0;\n\n\t\terr = tea6415c_call(mxb, video, s_routing, 3, 17, 0);\n\n\t\t \n\t\tif (!err)\n\t\t\terr = tea6415c_call(mxb, video, s_routing, 3, 13, 0);\n\t\tbreak;\n\tcase AUX3_YC:\n\t\t \n\t\ti = SAA7115_SVIDEO1;\n\t\tbreak;\n\tcase AUX3:\n\t\t \n\t\ti = SAA7115_COMPOSITE1;\n\t\tbreak;\n\tcase AUX1:\n\t\ti = SAA7115_COMPOSITE0;\n\t\terr = tea6415c_call(mxb, video, s_routing, 1, 17, 0);\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tmxb->video_dev.tvnorms = mxb_inputs[input].std;\n\tmxb->vbi_dev.tvnorms = mxb_inputs[input].std;\n\n\t \n\tif (saa7111a_call(mxb, video, s_routing, i, SAA7111_FMT_CCIR, 0))\n\t\tpr_err(\"VIDIOC_S_INPUT: could not address saa7111a\\n\");\n\n\tmxb->cur_audinput = video_audio_connect[input];\n\t \n\tif (0 == mxb->cur_mute)\n\t\ttea6420_route(mxb, mxb->cur_audinput);\n\tif (mxb->cur_audinput == 0)\n\t\tmxb_update_audmode(mxb);\n\n\treturn 0;\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *fh, struct v4l2_tuner *t)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct mxb *mxb = (struct mxb *)dev->ext_priv;\n\n\tif (t->index) {\n\t\tDEB_D(\"VIDIOC_G_TUNER: channel %d does not have a tuner attached\\n\",\n\t\t      t->index);\n\t\treturn -EINVAL;\n\t}\n\n\tDEB_EE(\"VIDIOC_G_TUNER: %d\\n\", t->index);\n\n\tmemset(t, 0, sizeof(*t));\n\tstrscpy(t->name, \"TV Tuner\", sizeof(t->name));\n\tt->type = V4L2_TUNER_ANALOG_TV;\n\tt->capability = V4L2_TUNER_CAP_NORM | V4L2_TUNER_CAP_STEREO |\n\t\t\tV4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2 | V4L2_TUNER_CAP_SAP;\n\tt->audmode = mxb->cur_mode;\n\treturn call_all(dev, tuner, g_tuner, t);\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *fh, const struct v4l2_tuner *t)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct mxb *mxb = (struct mxb *)dev->ext_priv;\n\n\tif (t->index) {\n\t\tDEB_D(\"VIDIOC_S_TUNER: channel %d does not have a tuner attached\\n\",\n\t\t      t->index);\n\t\treturn -EINVAL;\n\t}\n\n\tmxb->cur_mode = t->audmode;\n\treturn call_all(dev, tuner, s_tuner, t);\n}\n\nstatic int vidioc_querystd(struct file *file, void *fh, v4l2_std_id *norm)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\n\treturn call_all(dev, video, querystd, norm);\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *fh, struct v4l2_frequency *f)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct mxb *mxb = (struct mxb *)dev->ext_priv;\n\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\t*f = mxb->cur_freq;\n\n\tDEB_EE(\"VIDIOC_G_FREQ: freq:0x%08x\\n\", mxb->cur_freq.frequency);\n\treturn 0;\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *fh, const struct v4l2_frequency *f)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct mxb *mxb = (struct mxb *)dev->ext_priv;\n\n\tif (f->tuner)\n\t\treturn -EINVAL;\n\n\tif (V4L2_TUNER_ANALOG_TV != f->type)\n\t\treturn -EINVAL;\n\n\tDEB_EE(\"VIDIOC_S_FREQUENCY: freq:0x%08x\\n\", mxb->cur_freq.frequency);\n\n\t \n\ttuner_call(mxb, tuner, s_frequency, f);\n\t \n\tmxb->cur_freq = *f;\n\ttuner_call(mxb, tuner, g_frequency, &mxb->cur_freq);\n\tif (mxb->cur_audinput == 0)\n\t\tmxb_update_audmode(mxb);\n\treturn 0;\n}\n\nstatic int vidioc_enumaudio(struct file *file, void *fh, struct v4l2_audio *a)\n{\n\tif (a->index >= MXB_AUDIOS)\n\t\treturn -EINVAL;\n\t*a = mxb_audios[a->index];\n\treturn 0;\n}\n\nstatic int vidioc_g_audio(struct file *file, void *fh, struct v4l2_audio *a)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct mxb *mxb = (struct mxb *)dev->ext_priv;\n\n\tDEB_EE(\"VIDIOC_G_AUDIO\\n\");\n\t*a = mxb_audios[mxb->cur_audinput];\n\treturn 0;\n}\n\nstatic int vidioc_s_audio(struct file *file, void *fh, const struct v4l2_audio *a)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\tstruct mxb *mxb = (struct mxb *)dev->ext_priv;\n\n\tDEB_D(\"VIDIOC_S_AUDIO %d\\n\", a->index);\n\tif (a->index >= 32 ||\n\t    !(mxb_inputs[mxb->cur_input].audioset & (1 << a->index)))\n\t\treturn -EINVAL;\n\n\tif (mxb->cur_audinput != a->index) {\n\t\tmxb->cur_audinput = a->index;\n\t\ttea6420_route(mxb, a->index);\n\t\tif (mxb->cur_audinput == 0)\n\t\t\tmxb_update_audmode(mxb);\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\nstatic int vidioc_g_register(struct file *file, void *fh, struct v4l2_dbg_register *reg)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\n\tif (reg->reg > pci_resource_len(dev->pci, 0) - 4)\n\t\treturn -EINVAL;\n\treg->val = saa7146_read(dev, reg->reg);\n\treg->size = 4;\n\treturn 0;\n}\n\nstatic int vidioc_s_register(struct file *file, void *fh, const struct v4l2_dbg_register *reg)\n{\n\tstruct saa7146_dev *dev = video_drvdata(file);\n\n\tif (reg->reg > pci_resource_len(dev->pci, 0) - 4)\n\t\treturn -EINVAL;\n\tsaa7146_write(dev, reg->reg, reg->val);\n\treturn 0;\n}\n#endif\n\nstatic struct saa7146_ext_vv vv_data;\n\n \nstatic int mxb_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_data *info)\n{\n\tstruct mxb *mxb;\n\tint ret;\n\n\tDEB_EE(\"dev:%p\\n\", dev);\n\n\tret = saa7146_vv_init(dev, &vv_data);\n\tif (ret) {\n\t\tERR(\"Error in saa7146_vv_init()\");\n\t\treturn ret;\n\t}\n\n\tif (mxb_probe(dev)) {\n\t\tsaa7146_vv_release(dev);\n\t\treturn -1;\n\t}\n\tmxb = (struct mxb *)dev->ext_priv;\n\n\tvv_data.vid_ops.vidioc_enum_input = vidioc_enum_input;\n\tvv_data.vid_ops.vidioc_g_input = vidioc_g_input;\n\tvv_data.vid_ops.vidioc_s_input = vidioc_s_input;\n\tvv_data.vid_ops.vidioc_querystd = vidioc_querystd;\n\tvv_data.vid_ops.vidioc_g_tuner = vidioc_g_tuner;\n\tvv_data.vid_ops.vidioc_s_tuner = vidioc_s_tuner;\n\tvv_data.vid_ops.vidioc_g_frequency = vidioc_g_frequency;\n\tvv_data.vid_ops.vidioc_s_frequency = vidioc_s_frequency;\n\tvv_data.vid_ops.vidioc_enumaudio = vidioc_enumaudio;\n\tvv_data.vid_ops.vidioc_g_audio = vidioc_g_audio;\n\tvv_data.vid_ops.vidioc_s_audio = vidioc_s_audio;\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\tvv_data.vid_ops.vidioc_g_register = vidioc_g_register;\n\tvv_data.vid_ops.vidioc_s_register = vidioc_s_register;\n#endif\n\tvv_data.vbi_ops.vidioc_enum_input = vidioc_enum_input;\n\tvv_data.vbi_ops.vidioc_g_input = vidioc_g_input;\n\tvv_data.vbi_ops.vidioc_s_input = vidioc_s_input;\n\tvv_data.vbi_ops.vidioc_querystd = vidioc_querystd;\n\tvv_data.vbi_ops.vidioc_g_tuner = vidioc_g_tuner;\n\tvv_data.vbi_ops.vidioc_s_tuner = vidioc_s_tuner;\n\tvv_data.vbi_ops.vidioc_g_frequency = vidioc_g_frequency;\n\tvv_data.vbi_ops.vidioc_s_frequency = vidioc_s_frequency;\n\tvv_data.vbi_ops.vidioc_enumaudio = vidioc_enumaudio;\n\tvv_data.vbi_ops.vidioc_g_audio = vidioc_g_audio;\n\tvv_data.vbi_ops.vidioc_s_audio = vidioc_s_audio;\n\tif (saa7146_register_device(&mxb->video_dev, dev, \"mxb\", VFL_TYPE_VIDEO)) {\n\t\tERR(\"cannot register capture v4l2 device. skipping.\\n\");\n\t\tsaa7146_vv_release(dev);\n\t\treturn -1;\n\t}\n\n\t \n\tif (MXB_BOARD_CAN_DO_VBI(dev)) {\n\t\tif (saa7146_register_device(&mxb->vbi_dev, dev, \"mxb\", VFL_TYPE_VBI)) {\n\t\t\tERR(\"cannot register vbi v4l2 device. skipping.\\n\");\n\t\t}\n\t}\n\n\tpr_info(\"found Multimedia eXtension Board #%d\\n\", mxb_num);\n\n\tmxb_num++;\n\tmxb_init_done(dev);\n\treturn 0;\n}\n\nstatic int mxb_detach(struct saa7146_dev *dev)\n{\n\tstruct mxb *mxb = (struct mxb *)dev->ext_priv;\n\n\tDEB_EE(\"dev:%p\\n\", dev);\n\n\t \n\ttea6420_route(mxb, 6);\n\n\tsaa7146_unregister_device(&mxb->video_dev,dev);\n\tif (MXB_BOARD_CAN_DO_VBI(dev))\n\t\tsaa7146_unregister_device(&mxb->vbi_dev, dev);\n\tsaa7146_vv_release(dev);\n\n\tmxb_num--;\n\n\ti2c_del_adapter(&mxb->i2c_adapter);\n\tkfree(mxb);\n\n\treturn 0;\n}\n\nstatic int std_callback(struct saa7146_dev *dev, struct saa7146_standard *standard)\n{\n\tstruct mxb *mxb = (struct mxb *)dev->ext_priv;\n\n\tif (V4L2_STD_PAL_I == standard->id) {\n\t\tv4l2_std_id std = V4L2_STD_PAL_I;\n\n\t\tDEB_D(\"VIDIOC_S_STD: setting mxb for PAL_I\\n\");\n\t\t \n\t\tsaa7146_write(dev, GPIO_CTRL, 0x00404050);\n\t\tsaa7111a_call(mxb, core, s_gpio, 0);\n\t\tsaa7111a_call(mxb, video, s_std, std);\n\t\tif (mxb->cur_input == 0)\n\t\t\ttuner_call(mxb, video, s_std, std);\n\t} else {\n\t\tv4l2_std_id std = V4L2_STD_PAL_BG;\n\n\t\tif (mxb->cur_input)\n\t\t\tstd = standard->id;\n\t\tDEB_D(\"VIDIOC_S_STD: setting mxb for PAL/NTSC/SECAM\\n\");\n\t\t \n\t\tsaa7146_write(dev, GPIO_CTRL, 0x00404050);\n\t\tsaa7111a_call(mxb, core, s_gpio, 1);\n\t\tsaa7111a_call(mxb, video, s_std, std);\n\t\tif (mxb->cur_input == 0)\n\t\t\ttuner_call(mxb, video, s_std, std);\n\t}\n\treturn 0;\n}\n\nstatic struct saa7146_standard standard[] = {\n\t{\n\t\t.name\t= \"PAL-BG\",\t.id\t= V4L2_STD_PAL_BG,\n\t\t.v_offset\t= 0x17,\t.v_field\t= 288,\n\t\t.h_offset\t= 0x14,\t.h_pixels\t= 680,\n\t\t.v_max_out\t= 576,\t.h_max_out\t= 768,\n\t}, {\n\t\t.name\t= \"PAL-I\",\t.id\t= V4L2_STD_PAL_I,\n\t\t.v_offset\t= 0x17,\t.v_field\t= 288,\n\t\t.h_offset\t= 0x14,\t.h_pixels\t= 680,\n\t\t.v_max_out\t= 576,\t.h_max_out\t= 768,\n\t}, {\n\t\t.name\t= \"NTSC\",\t.id\t= V4L2_STD_NTSC,\n\t\t.v_offset\t= 0x16,\t.v_field\t= 240,\n\t\t.h_offset\t= 0x06,\t.h_pixels\t= 708,\n\t\t.v_max_out\t= 480,\t.h_max_out\t= 640,\n\t}, {\n\t\t.name\t= \"SECAM\",\t.id\t= V4L2_STD_SECAM,\n\t\t.v_offset\t= 0x14,\t.v_field\t= 288,\n\t\t.h_offset\t= 0x14,\t.h_pixels\t= 720,\n\t\t.v_max_out\t= 576,\t.h_max_out\t= 768,\n\t}\n};\n\nstatic struct saa7146_pci_extension_data mxb = {\n\t.ext_priv = \"Multimedia eXtension Board\",\n\t.ext = &extension,\n};\n\nstatic const struct pci_device_id pci_tbl[] = {\n\t{\n\t\t.vendor    = PCI_VENDOR_ID_PHILIPS,\n\t\t.device\t   = PCI_DEVICE_ID_PHILIPS_SAA7146,\n\t\t.subvendor = 0x0000,\n\t\t.subdevice = 0x0000,\n\t\t.driver_data = (unsigned long)&mxb,\n\t}, {\n\t\t.vendor\t= 0,\n\t}\n};\n\nMODULE_DEVICE_TABLE(pci, pci_tbl);\n\nstatic struct saa7146_ext_vv vv_data = {\n\t.inputs\t\t= MXB_INPUTS,\n\t.capabilities\t= V4L2_CAP_TUNER | V4L2_CAP_VBI_CAPTURE | V4L2_CAP_AUDIO,\n\t.stds\t\t= &standard[0],\n\t.num_stds\t= ARRAY_SIZE(standard),\n\t.std_callback\t= &std_callback,\n};\n\nstatic struct saa7146_extension extension = {\n\t.name\t\t= \"Multimedia eXtension Board\",\n\t.flags\t\t= SAA7146_USE_I2C_IRQ,\n\n\t.pci_tbl\t= &pci_tbl[0],\n\t.module\t\t= THIS_MODULE,\n\n\t.attach\t\t= mxb_attach,\n\t.detach\t\t= mxb_detach,\n\n\t.irq_mask\t= 0,\n\t.irq_func\t= NULL,\n};\n\nstatic int __init mxb_init_module(void)\n{\n\tif (saa7146_register_extension(&extension)) {\n\t\tDEB_S(\"failed to register extension\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit mxb_cleanup_module(void)\n{\n\tsaa7146_unregister_extension(&extension);\n}\n\nmodule_init(mxb_init_module);\nmodule_exit(mxb_cleanup_module);\n\nMODULE_DESCRIPTION(\"video4linux-2 driver for the Siemens-Nixdorf 'Multimedia eXtension board'\");\nMODULE_AUTHOR(\"Michael Hunold <michael@mihu.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}