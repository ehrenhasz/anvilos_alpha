{
  "module_name": "cx23885-dvb.c",
  "hash_id": "d2263426d94e577b9b58b1b6f9c51b3b763a601feee8470fc46d772254bc1057",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx23885/cx23885-dvb.c",
  "human_readable_source": "\n \n\n#include \"cx23885.h\"\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/suspend.h>\n\n#include <media/v4l2-common.h>\n\n#include <media/dvb_ca_en50221.h>\n#include \"s5h1409.h\"\n#include \"s5h1411.h\"\n#include \"mt2131.h\"\n#include \"tda8290.h\"\n#include \"tda18271.h\"\n#include \"lgdt330x.h\"\n#include \"xc4000.h\"\n#include \"xc5000.h\"\n#include \"max2165.h\"\n#include \"tda10048.h\"\n#include \"xc2028.h\"\n#include \"tuner-simple.h\"\n#include \"dib7000p.h\"\n#include \"dib0070.h\"\n#include \"dibx000_common.h\"\n#include \"zl10353.h\"\n#include \"stv0900.h\"\n#include \"stv0900_reg.h\"\n#include \"stv6110.h\"\n#include \"lnbh24.h\"\n#include \"cx24116.h\"\n#include \"cx24117.h\"\n#include \"cimax2.h\"\n#include \"lgs8gxx.h\"\n#include \"netup-eeprom.h\"\n#include \"netup-init.h\"\n#include \"lgdt3305.h\"\n#include \"atbm8830.h\"\n#include \"ts2020.h\"\n#include \"ds3000.h\"\n#include \"cx23885-f300.h\"\n#include \"altera-ci.h\"\n#include \"stv0367.h\"\n#include \"drxk.h\"\n#include \"mt2063.h\"\n#include \"stv090x.h\"\n#include \"stb6100.h\"\n#include \"stb6100_cfg.h\"\n#include \"tda10071.h\"\n#include \"a8293.h\"\n#include \"mb86a20s.h\"\n#include \"si2165.h\"\n#include \"si2168.h\"\n#include \"si2157.h\"\n#include \"sp2.h\"\n#include \"m88ds3103.h\"\n#include \"m88rs6000t.h\"\n#include \"lgdt3306a.h\"\n\nstatic unsigned int debug;\n\n#define dprintk(level, fmt, arg...)\\\n\tdo { if (debug >= level)\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s dvb: \" fmt), \\\n\t\t\t__func__, ##arg); \\\n\t} while (0)\n\n \n\nstatic unsigned int alt_tuner;\nmodule_param(alt_tuner, int, 0644);\nMODULE_PARM_DESC(alt_tuner, \"Enable alternate tuner configuration\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n \n\nstatic int queue_setup(struct vb2_queue *q,\n\t\t\t   unsigned int *num_buffers, unsigned int *num_planes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct cx23885_tsport *port = q->drv_priv;\n\n\tport->ts_packet_size  = 188 * 4;\n\tport->ts_packet_count = 32;\n\t*num_planes = 1;\n\tsizes[0] = port->ts_packet_size * port->ts_packet_count;\n\t*num_buffers = 32;\n\treturn 0;\n}\n\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx23885_tsport *port = vb->vb2_queue->drv_priv;\n\tstruct cx23885_buffer *buf =\n\t\tcontainer_of(vbuf, struct cx23885_buffer, vb);\n\n\treturn cx23885_buf_prepare(buf, port);\n}\n\nstatic void buffer_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx23885_tsport *port = vb->vb2_queue->drv_priv;\n\tstruct cx23885_dev *dev = port->dev;\n\tstruct cx23885_buffer *buf = container_of(vbuf,\n\t\tstruct cx23885_buffer, vb);\n\n\tcx23885_free_buffer(dev, buf);\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx23885_tsport *port = vb->vb2_queue->drv_priv;\n\tstruct cx23885_buffer   *buf = container_of(vbuf,\n\t\tstruct cx23885_buffer, vb);\n\n\tcx23885_buf_queue(port, buf);\n}\n\nstatic void cx23885_dvb_gate_ctrl(struct cx23885_tsport  *port, int open)\n{\n\tstruct vb2_dvb_frontends *f;\n\tstruct vb2_dvb_frontend *fe;\n\n\tf = &port->frontends;\n\n\tif (f->gate <= 1)  \n\t\tfe = vb2_dvb_get_frontend(f, 1);\n\telse\n\t\tfe = vb2_dvb_get_frontend(f, f->gate);\n\n\tif (fe && fe->dvb.frontend && fe->dvb.frontend->ops.i2c_gate_ctrl)\n\t\tfe->dvb.frontend->ops.i2c_gate_ctrl(fe->dvb.frontend, open);\n}\n\nstatic int cx23885_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct cx23885_tsport *port = q->drv_priv;\n\tstruct cx23885_dmaqueue *dmaq = &port->mpegq;\n\tstruct cx23885_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx23885_buffer, queue);\n\n\tcx23885_start_dma(port, dmaq, buf);\n\treturn 0;\n}\n\nstatic void cx23885_stop_streaming(struct vb2_queue *q)\n{\n\tstruct cx23885_tsport *port = q->drv_priv;\n\n\tcx23885_cancel_buffers(port);\n}\n\nstatic const struct vb2_ops dvb_qops = {\n\t.queue_setup    = queue_setup,\n\t.buf_prepare  = buffer_prepare,\n\t.buf_finish = buffer_finish,\n\t.buf_queue    = buffer_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = cx23885_start_streaming,\n\t.stop_streaming = cx23885_stop_streaming,\n};\n\nstatic struct s5h1409_config hauppauge_generic_config = {\n\t.demod_address = 0x32 >> 1,\n\t.output_mode   = S5H1409_SERIAL_OUTPUT,\n\t.gpio          = S5H1409_GPIO_ON,\n\t.qam_if        = 44000,\n\t.inversion     = S5H1409_INVERSION_OFF,\n\t.status_mode   = S5H1409_DEMODLOCKING,\n\t.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\n\nstatic struct tda10048_config hauppauge_hvr1200_config = {\n\t.demod_address    = 0x10 >> 1,\n\t.output_mode      = TDA10048_SERIAL_OUTPUT,\n\t.fwbulkwritelen   = TDA10048_BULKWRITE_200,\n\t.inversion        = TDA10048_INVERSION_ON,\n\t.dtv6_if_freq_khz = TDA10048_IF_3300,\n\t.dtv7_if_freq_khz = TDA10048_IF_3800,\n\t.dtv8_if_freq_khz = TDA10048_IF_4300,\n\t.clk_freq_khz     = TDA10048_CLK_16000,\n};\n\nstatic struct tda10048_config hauppauge_hvr1210_config = {\n\t.demod_address    = 0x10 >> 1,\n\t.output_mode      = TDA10048_SERIAL_OUTPUT,\n\t.fwbulkwritelen   = TDA10048_BULKWRITE_200,\n\t.inversion        = TDA10048_INVERSION_ON,\n\t.dtv6_if_freq_khz = TDA10048_IF_3300,\n\t.dtv7_if_freq_khz = TDA10048_IF_3500,\n\t.dtv8_if_freq_khz = TDA10048_IF_4000,\n\t.clk_freq_khz     = TDA10048_CLK_16000,\n};\n\nstatic struct s5h1409_config hauppauge_ezqam_config = {\n\t.demod_address = 0x32 >> 1,\n\t.output_mode   = S5H1409_SERIAL_OUTPUT,\n\t.gpio          = S5H1409_GPIO_OFF,\n\t.qam_if        = 4000,\n\t.inversion     = S5H1409_INVERSION_ON,\n\t.status_mode   = S5H1409_DEMODLOCKING,\n\t.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\n\nstatic struct s5h1409_config hauppauge_hvr1800lp_config = {\n\t.demod_address = 0x32 >> 1,\n\t.output_mode   = S5H1409_SERIAL_OUTPUT,\n\t.gpio          = S5H1409_GPIO_OFF,\n\t.qam_if        = 44000,\n\t.inversion     = S5H1409_INVERSION_OFF,\n\t.status_mode   = S5H1409_DEMODLOCKING,\n\t.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\n\nstatic struct s5h1409_config hauppauge_hvr1500_config = {\n\t.demod_address = 0x32 >> 1,\n\t.output_mode   = S5H1409_SERIAL_OUTPUT,\n\t.gpio          = S5H1409_GPIO_OFF,\n\t.inversion     = S5H1409_INVERSION_OFF,\n\t.status_mode   = S5H1409_DEMODLOCKING,\n\t.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\n\nstatic struct mt2131_config hauppauge_generic_tunerconfig = {\n\t0x61\n};\n\nstatic struct lgdt330x_config fusionhdtv_5_express = {\n\t.demod_chip = LGDT3303,\n\t.serial_mpeg = 0x40,\n};\n\nstatic struct s5h1409_config hauppauge_hvr1500q_config = {\n\t.demod_address = 0x32 >> 1,\n\t.output_mode   = S5H1409_SERIAL_OUTPUT,\n\t.gpio          = S5H1409_GPIO_ON,\n\t.qam_if        = 44000,\n\t.inversion     = S5H1409_INVERSION_OFF,\n\t.status_mode   = S5H1409_DEMODLOCKING,\n\t.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\n\nstatic struct s5h1409_config dvico_s5h1409_config = {\n\t.demod_address = 0x32 >> 1,\n\t.output_mode   = S5H1409_SERIAL_OUTPUT,\n\t.gpio          = S5H1409_GPIO_ON,\n\t.qam_if        = 44000,\n\t.inversion     = S5H1409_INVERSION_OFF,\n\t.status_mode   = S5H1409_DEMODLOCKING,\n\t.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\n\nstatic struct s5h1411_config dvico_s5h1411_config = {\n\t.output_mode   = S5H1411_SERIAL_OUTPUT,\n\t.gpio          = S5H1411_GPIO_ON,\n\t.qam_if        = S5H1411_IF_44000,\n\t.vsb_if        = S5H1411_IF_44000,\n\t.inversion     = S5H1411_INVERSION_OFF,\n\t.status_mode   = S5H1411_DEMODLOCKING,\n\t.mpeg_timing   = S5H1411_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\n\nstatic struct s5h1411_config hcw_s5h1411_config = {\n\t.output_mode   = S5H1411_SERIAL_OUTPUT,\n\t.gpio          = S5H1411_GPIO_OFF,\n\t.vsb_if        = S5H1411_IF_44000,\n\t.qam_if        = S5H1411_IF_4000,\n\t.inversion     = S5H1411_INVERSION_ON,\n\t.status_mode   = S5H1411_DEMODLOCKING,\n\t.mpeg_timing   = S5H1411_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,\n};\n\nstatic struct xc5000_config hauppauge_hvr1500q_tunerconfig = {\n\t.i2c_address      = 0x61,\n\t.if_khz           = 5380,\n};\n\nstatic struct xc5000_config dvico_xc5000_tunerconfig = {\n\t.i2c_address      = 0x64,\n\t.if_khz           = 5380,\n};\n\nstatic struct tda829x_config tda829x_no_probe = {\n\t.probe_tuner = TDA829X_DONT_PROBE,\n};\n\nstatic struct tda18271_std_map hauppauge_tda18271_std_map = {\n\t.atsc_6   = { .if_freq = 5380, .agc_mode = 3, .std = 3,\n\t\t      .if_lvl = 6, .rfagc_top = 0x37 },\n\t.qam_6    = { .if_freq = 4000, .agc_mode = 3, .std = 0,\n\t\t      .if_lvl = 6, .rfagc_top = 0x37 },\n};\n\nstatic struct tda18271_std_map hauppauge_hvr1200_tda18271_std_map = {\n\t.dvbt_6   = { .if_freq = 3300, .agc_mode = 3, .std = 4,\n\t\t      .if_lvl = 1, .rfagc_top = 0x37, },\n\t.dvbt_7   = { .if_freq = 3800, .agc_mode = 3, .std = 5,\n\t\t      .if_lvl = 1, .rfagc_top = 0x37, },\n\t.dvbt_8   = { .if_freq = 4300, .agc_mode = 3, .std = 6,\n\t\t      .if_lvl = 1, .rfagc_top = 0x37, },\n};\n\nstatic struct tda18271_config hauppauge_tda18271_config = {\n\t.std_map = &hauppauge_tda18271_std_map,\n\t.gate    = TDA18271_GATE_ANALOG,\n\t.output_opt = TDA18271_OUTPUT_LT_OFF,\n};\n\nstatic struct tda18271_config hauppauge_hvr1200_tuner_config = {\n\t.std_map = &hauppauge_hvr1200_tda18271_std_map,\n\t.gate    = TDA18271_GATE_ANALOG,\n\t.output_opt = TDA18271_OUTPUT_LT_OFF,\n};\n\nstatic struct tda18271_config hauppauge_hvr1210_tuner_config = {\n\t.gate    = TDA18271_GATE_DIGITAL,\n\t.output_opt = TDA18271_OUTPUT_LT_OFF,\n};\n\nstatic struct tda18271_config hauppauge_hvr4400_tuner_config = {\n\t.gate    = TDA18271_GATE_DIGITAL,\n\t.output_opt = TDA18271_OUTPUT_LT_OFF,\n};\n\nstatic struct tda18271_std_map hauppauge_hvr127x_std_map = {\n\t.atsc_6   = { .if_freq = 3250, .agc_mode = 3, .std = 4,\n\t\t      .if_lvl = 1, .rfagc_top = 0x58 },\n\t.qam_6    = { .if_freq = 4000, .agc_mode = 3, .std = 5,\n\t\t      .if_lvl = 1, .rfagc_top = 0x58 },\n};\n\nstatic struct tda18271_config hauppauge_hvr127x_config = {\n\t.std_map = &hauppauge_hvr127x_std_map,\n\t.output_opt = TDA18271_OUTPUT_LT_OFF,\n};\n\nstatic struct lgdt3305_config hauppauge_lgdt3305_config = {\n\t.i2c_addr           = 0x0e,\n\t.mpeg_mode          = LGDT3305_MPEG_SERIAL,\n\t.tpclk_edge         = LGDT3305_TPCLK_FALLING_EDGE,\n\t.tpvalid_polarity   = LGDT3305_TP_VALID_HIGH,\n\t.deny_i2c_rptr      = 1,\n\t.spectral_inversion = 1,\n\t.qam_if_khz         = 4000,\n\t.vsb_if_khz         = 3250,\n};\n\nstatic struct dibx000_agc_config xc3028_agc_config = {\n\tBAND_VHF | BAND_UHF,\t \n\n\t \n\t(0 << 15) | (0 << 14) | (0 << 11) | (0 << 10) | (0 << 9) | (0 << 8) |\n\t\t(3 << 5) | (0 << 4) | (2 << 1) | (0 << 0),  \n\n\t712,\t \n\t21,\t \n\n\t0,\t \n\t118,\t \n\n\t0,\t \n\t2867,\t \n\t0,\t \n\t2,\t \n\n\t0,\t \n\t0,\t \n\t39718,\t \n\t9930,\t \n\t0,\t \n\t0,\t \n\t0,\t \n\t0,\t \n\t0,\t \n\t0,\t \n\t128,\t \n\t29,\t \n\t29,\t \n\n\t17,\t \n\t27,\t \n\t23,\t \n\t51,\t \n\n\t1,\t \n};\n\n \nstatic struct dibx000_bandwidth_config xc3028_bw_config = {\n\t60000,\t \n\t30000,\t \n\t1,\t \n\t8,\t \n\t3,\t \n\t1,\t \n\t0,\t \n\t0,\t \n\t0,\t \n\t1,\t \n\t1,\t \n\t0,\t \n\t(3 << 14) | (1 << 12) | (524 << 0),  \n\t(1 << 25) | 5816102,  \n\t20452225,  \n\t30000000   \n};\n\nstatic struct dib7000p_config hauppauge_hvr1400_dib7000_config = {\n\t.output_mpeg2_in_188_bytes = 1,\n\t.hostbus_diversity = 1,\n\t.tuner_is_baseband = 0,\n\t.update_lna  = NULL,\n\n\t.agc_config_count = 1,\n\t.agc = &xc3028_agc_config,\n\t.bw  = &xc3028_bw_config,\n\n\t.gpio_dir = DIB7000P_GPIO_DEFAULT_DIRECTIONS,\n\t.gpio_val = DIB7000P_GPIO_DEFAULT_VALUES,\n\t.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,\n\n\t.pwm_freq_div = 0,\n\t.agc_control  = NULL,\n\t.spur_protect = 0,\n\n\t.output_mode = OUTMODE_MPEG2_SERIAL,\n};\n\nstatic struct zl10353_config dvico_fusionhdtv_xc3028 = {\n\t.demod_address = 0x0f,\n\t.if2           = 45600,\n\t.no_tuner      = 1,\n\t.disable_i2c_gate_ctrl = 1,\n};\n\nstatic struct stv0900_reg stv0900_ts_regs[] = {\n\t{ R0900_TSGENERAL, 0x00 },\n\t{ R0900_P1_TSSPEED, 0x40 },\n\t{ R0900_P2_TSSPEED, 0x40 },\n\t{ R0900_P1_TSCFGM, 0xc0 },\n\t{ R0900_P2_TSCFGM, 0xc0 },\n\t{ R0900_P1_TSCFGH, 0xe0 },\n\t{ R0900_P2_TSCFGH, 0xe0 },\n\t{ R0900_P1_TSCFGL, 0x20 },\n\t{ R0900_P2_TSCFGL, 0x20 },\n\t{ 0xffff, 0xff },  \n};\n\nstatic struct stv0900_config netup_stv0900_config = {\n\t.demod_address = 0x68,\n\t.demod_mode = 1,  \n\t.xtal = 8000000,\n\t.clkmode = 3, \n\t.diseqc_mode = 2, \n\t.ts_config_regs = stv0900_ts_regs,\n\t.tun1_maddress = 0, \n\t.tun2_maddress = 3, \n\t.tun1_adc = 1, \n\t.tun2_adc = 1, \n};\n\nstatic struct stv6110_config netup_stv6110_tunerconfig_a = {\n\t.i2c_address = 0x60,\n\t.mclk = 16000000,\n\t.clk_div = 1,\n\t.gain = 8,  \n};\n\nstatic struct stv6110_config netup_stv6110_tunerconfig_b = {\n\t.i2c_address = 0x63,\n\t.mclk = 16000000,\n\t.clk_div = 1,\n\t.gain = 8,  \n};\n\nstatic struct cx24116_config tbs_cx24116_config = {\n\t.demod_address = 0x55,\n};\n\nstatic struct cx24117_config tbs_cx24117_config = {\n\t.demod_address = 0x55,\n};\n\nstatic struct ds3000_config tevii_ds3000_config = {\n\t.demod_address = 0x68,\n};\n\nstatic struct ts2020_config tevii_ts2020_config  = {\n\t.tuner_address = 0x60,\n\t.clk_out_div = 1,\n\t.frequency_div = 1146000,\n};\n\nstatic struct cx24116_config dvbworld_cx24116_config = {\n\t.demod_address = 0x05,\n};\n\nstatic struct lgs8gxx_config mygica_x8506_lgs8gl5_config = {\n\t.prod = LGS8GXX_PROD_LGS8GL5,\n\t.demod_address = 0x19,\n\t.serial_ts = 0,\n\t.ts_clk_pol = 1,\n\t.ts_clk_gated = 1,\n\t.if_clk_freq = 30400,  \n\t.if_freq = 5380,  \n\t.if_neg_center = 1,\n\t.ext_adc = 0,\n\t.adc_signed = 0,\n\t.if_neg_edge = 0,\n};\n\nstatic struct xc5000_config mygica_x8506_xc5000_config = {\n\t.i2c_address = 0x61,\n\t.if_khz = 5380,\n};\n\nstatic struct mb86a20s_config mygica_x8507_mb86a20s_config = {\n\t.demod_address = 0x10,\n};\n\nstatic struct xc5000_config mygica_x8507_xc5000_config = {\n\t.i2c_address = 0x61,\n\t.if_khz = 4000,\n};\n\nstatic struct stv090x_config prof_8000_stv090x_config = {\n\t.device                 = STV0903,\n\t.demod_mode             = STV090x_SINGLE,\n\t.clk_mode               = STV090x_CLK_EXT,\n\t.xtal                   = 27000000,\n\t.address                = 0x6A,\n\t.ts1_mode               = STV090x_TSMODE_PARALLEL_PUNCTURED,\n\t.repeater_level         = STV090x_RPTLEVEL_64,\n\t.adc1_range             = STV090x_ADC_2Vpp,\n\t.diseqc_envelope_mode   = false,\n\n\t.tuner_get_frequency    = stb6100_get_frequency,\n\t.tuner_set_frequency    = stb6100_set_frequency,\n\t.tuner_set_bandwidth    = stb6100_set_bandwidth,\n\t.tuner_get_bandwidth    = stb6100_get_bandwidth,\n};\n\nstatic struct stb6100_config prof_8000_stb6100_config = {\n\t.tuner_address = 0x60,\n\t.refclock = 27000000,\n};\n\nstatic struct lgdt3306a_config hauppauge_quadHD_ATSC_a_config = {\n\t.i2c_addr               = 0x59,\n\t.qam_if_khz             = 4000,\n\t.vsb_if_khz             = 3250,\n\t.deny_i2c_rptr          = 1,  \n\t.spectral_inversion     = 0,  \n\t.mpeg_mode              = LGDT3306A_MPEG_SERIAL,\n\t.tpclk_edge             = LGDT3306A_TPCLK_RISING_EDGE,\n\t.tpvalid_polarity       = LGDT3306A_TP_VALID_HIGH,\n\t.xtalMHz                = 25,  \n};\n\nstatic struct lgdt3306a_config hauppauge_quadHD_ATSC_b_config = {\n\t.i2c_addr               = 0x0e,\n\t.qam_if_khz             = 4000,\n\t.vsb_if_khz             = 3250,\n\t.deny_i2c_rptr          = 1,  \n\t.spectral_inversion     = 0,  \n\t.mpeg_mode              = LGDT3306A_MPEG_SERIAL,\n\t.tpclk_edge             = LGDT3306A_TPCLK_RISING_EDGE,\n\t.tpvalid_polarity       = LGDT3306A_TP_VALID_HIGH,\n\t.xtalMHz                = 25,  \n};\n\nstatic int p8000_set_voltage(struct dvb_frontend *fe,\n\t\t\t     enum fe_sec_voltage voltage)\n{\n\tstruct cx23885_tsport *port = fe->dvb->priv;\n\tstruct cx23885_dev *dev = port->dev;\n\n\tif (voltage == SEC_VOLTAGE_18)\n\t\tcx_write(MC417_RWD, 0x00001e00);\n\telse if (voltage == SEC_VOLTAGE_13)\n\t\tcx_write(MC417_RWD, 0x00001a00);\n\telse\n\t\tcx_write(MC417_RWD, 0x00001800);\n\treturn 0;\n}\n\nstatic int dvbsky_t9580_set_voltage(struct dvb_frontend *fe,\n\t\t\t\t\tenum fe_sec_voltage voltage)\n{\n\tstruct cx23885_tsport *port = fe->dvb->priv;\n\tstruct cx23885_dev *dev = port->dev;\n\n\tcx23885_gpio_enable(dev, GPIO_0 | GPIO_1, 1);\n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_13:\n\t\tcx23885_gpio_set(dev, GPIO_1);\n\t\tcx23885_gpio_clear(dev, GPIO_0);\n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\n\t\tcx23885_gpio_set(dev, GPIO_1);\n\t\tcx23885_gpio_set(dev, GPIO_0);\n\t\tbreak;\n\tcase SEC_VOLTAGE_OFF:\n\t\tcx23885_gpio_clear(dev, GPIO_1);\n\t\tcx23885_gpio_clear(dev, GPIO_0);\n\t\tbreak;\n\t}\n\n\t \n\tport->fe_set_voltage(fe, voltage);\n\n\treturn 0;\n}\n\nstatic int dvbsky_s952_portc_set_voltage(struct dvb_frontend *fe,\n\t\t\t\t\tenum fe_sec_voltage voltage)\n{\n\tstruct cx23885_tsport *port = fe->dvb->priv;\n\tstruct cx23885_dev *dev = port->dev;\n\n\tcx23885_gpio_enable(dev, GPIO_12 | GPIO_13, 1);\n\n\tswitch (voltage) {\n\tcase SEC_VOLTAGE_13:\n\t\tcx23885_gpio_set(dev, GPIO_13);\n\t\tcx23885_gpio_clear(dev, GPIO_12);\n\t\tbreak;\n\tcase SEC_VOLTAGE_18:\n\t\tcx23885_gpio_set(dev, GPIO_13);\n\t\tcx23885_gpio_set(dev, GPIO_12);\n\t\tbreak;\n\tcase SEC_VOLTAGE_OFF:\n\t\tcx23885_gpio_clear(dev, GPIO_13);\n\t\tcx23885_gpio_clear(dev, GPIO_12);\n\t\tbreak;\n\t}\n\t \n\treturn port->fe_set_voltage(fe, voltage);\n}\n\nstatic int cx23885_sp2_ci_ctrl(void *priv, u8 read, int addr,\n\t\t\t\tu8 data, int *mem)\n{\n\t \n\t#define SP2_DATA              0x000000ff\n\t#define SP2_WR                0x00008000\n\t#define SP2_RD                0x00004000\n\t#define SP2_ACK               0x00001000\n\t#define SP2_ADHI              0x00000800\n\t#define SP2_ADLO              0x00000400\n\t#define SP2_CS1               0x00000200\n\t#define SP2_CS0               0x00000100\n\t#define SP2_EN_ALL            0x00001000\n\t#define SP2_CTRL_OFF          (SP2_CS1 | SP2_CS0 | SP2_WR | SP2_RD)\n\n\tstruct cx23885_tsport *port = priv;\n\tstruct cx23885_dev *dev = port->dev;\n\tint ret;\n\tint tmp = 0;\n\tunsigned long timeout;\n\n\tmutex_lock(&dev->gpio_lock);\n\n\t \n\tcx_write(MC417_OEN, SP2_EN_ALL);\n\tcx_write(MC417_RWD, SP2_CTRL_OFF |\n\t\t\t\tSP2_ADLO | (0xff & addr));\n\tcx_clear(MC417_RWD, SP2_ADLO);\n\tcx_write(MC417_RWD, SP2_CTRL_OFF |\n\t\t\t\tSP2_ADHI | (0xff & (addr >> 8)));\n\tcx_clear(MC417_RWD, SP2_ADHI);\n\n\tif (read)\n\t\t \n\t\tcx_write(MC417_OEN, SP2_EN_ALL | SP2_DATA);\n\telse\n\t\t \n\t\tcx_write(MC417_RWD, SP2_CTRL_OFF | data);\n\n\t \n\tcx_clear(MC417_RWD, SP2_CS0);\n\n\t \n\tcx_clear(MC417_RWD, (read) ? SP2_RD : SP2_WR);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(1);\n\twhile (!time_after(jiffies, timeout)) {\n\t\ttmp = cx_read(MC417_RWD);\n\t\tif ((tmp & SP2_ACK) == 0)\n\t\t\tbreak;\n\t\tusleep_range(50, 100);\n\t}\n\n\tcx_set(MC417_RWD, SP2_CTRL_OFF);\n\t*mem = tmp & 0xff;\n\n\tmutex_unlock(&dev->gpio_lock);\n\n\tif (!read) {\n\t\tif (*mem < 0) {\n\t\t\tret = -EREMOTEIO;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int cx23885_dvb_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct cx23885_tsport *port = fe->dvb->priv;\n\tstruct cx23885_dev *dev = port->dev;\n\n\tswitch (dev->board) {\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1275:\n\t\tswitch (p->modulation) {\n\t\tcase VSB_8:\n\t\t\tcx23885_gpio_clear(dev, GPIO_5);\n\t\t\tbreak;\n\t\tcase QAM_64:\n\t\tcase QAM_256:\n\t\tdefault:\n\t\t\tcx23885_gpio_set(dev, GPIO_5);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_MYGICA_X8506:\n\tcase CX23885_BOARD_MYGICA_X8507:\n\tcase CX23885_BOARD_MAGICPRO_PROHDTVE2:\n\t\t \n\t\tcx23885_gpio_set(dev, GPIO_0);\n\t\tbreak;\n\t}\n\n\t \n\tif (port->set_frontend)\n\t\treturn port->set_frontend(fe);\n\n\treturn 0;\n}\n\nstatic void cx23885_set_frontend_hook(struct cx23885_tsport *port,\n\t\t\t\t     struct dvb_frontend *fe)\n{\n\tport->set_frontend = fe->ops.set_frontend;\n\tfe->ops.set_frontend = cx23885_dvb_set_frontend;\n}\n\nstatic struct lgs8gxx_config magicpro_prohdtve2_lgs8g75_config = {\n\t.prod = LGS8GXX_PROD_LGS8G75,\n\t.demod_address = 0x19,\n\t.serial_ts = 0,\n\t.ts_clk_pol = 1,\n\t.ts_clk_gated = 1,\n\t.if_clk_freq = 30400,  \n\t.if_freq = 6500,  \n\t.if_neg_center = 1,\n\t.ext_adc = 0,\n\t.adc_signed = 1,\n\t.adc_vpp = 2,  \n\t.if_neg_edge = 1,\n};\n\nstatic struct xc5000_config magicpro_prohdtve2_xc5000_config = {\n\t.i2c_address = 0x61,\n\t.if_khz = 6500,\n};\n\nstatic struct atbm8830_config mygica_x8558pro_atbm8830_cfg1 = {\n\t.prod = ATBM8830_PROD_8830,\n\t.demod_address = 0x44,\n\t.serial_ts = 0,\n\t.ts_sampling_edge = 1,\n\t.ts_clk_gated = 0,\n\t.osc_clk_freq = 30400,  \n\t.if_freq = 0,  \n\t.zif_swap_iq = 1,\n\t.agc_min = 0x2E,\n\t.agc_max = 0xFF,\n\t.agc_hold_loop = 0,\n};\n\nstatic struct max2165_config mygic_x8558pro_max2165_cfg1 = {\n\t.i2c_address = 0x60,\n\t.osc_clk = 20\n};\n\nstatic struct atbm8830_config mygica_x8558pro_atbm8830_cfg2 = {\n\t.prod = ATBM8830_PROD_8830,\n\t.demod_address = 0x44,\n\t.serial_ts = 1,\n\t.ts_sampling_edge = 1,\n\t.ts_clk_gated = 0,\n\t.osc_clk_freq = 30400,  \n\t.if_freq = 0,  \n\t.zif_swap_iq = 1,\n\t.agc_min = 0x2E,\n\t.agc_max = 0xFF,\n\t.agc_hold_loop = 0,\n};\n\nstatic struct max2165_config mygic_x8558pro_max2165_cfg2 = {\n\t.i2c_address = 0x60,\n\t.osc_clk = 20\n};\nstatic struct stv0367_config netup_stv0367_config[] = {\n\t{\n\t\t.demod_address = 0x1c,\n\t\t.xtal = 27000000,\n\t\t.if_khz = 4500,\n\t\t.if_iq_mode = 0,\n\t\t.ts_mode = 1,\n\t\t.clk_pol = 0,\n\t}, {\n\t\t.demod_address = 0x1d,\n\t\t.xtal = 27000000,\n\t\t.if_khz = 4500,\n\t\t.if_iq_mode = 0,\n\t\t.ts_mode = 1,\n\t\t.clk_pol = 0,\n\t},\n};\n\nstatic struct xc5000_config netup_xc5000_config[] = {\n\t{\n\t\t.i2c_address = 0x61,\n\t\t.if_khz = 4500,\n\t}, {\n\t\t.i2c_address = 0x64,\n\t\t.if_khz = 4500,\n\t},\n};\n\nstatic struct drxk_config terratec_drxk_config[] = {\n\t{\n\t\t.adr = 0x29,\n\t\t.no_i2c_bridge = 1,\n\t}, {\n\t\t.adr = 0x2a,\n\t\t.no_i2c_bridge = 1,\n\t},\n};\n\nstatic struct mt2063_config terratec_mt2063_config[] = {\n\t{\n\t\t.tuner_address = 0x60,\n\t}, {\n\t\t.tuner_address = 0x67,\n\t},\n};\n\nstatic const struct tda10071_platform_data hauppauge_tda10071_pdata = {\n\t.clk = 40444000,  \n\t.i2c_wr_max = 64,\n\t.ts_mode = TDA10071_TS_SERIAL,\n\t.pll_multiplier = 20,\n\t.tuner_i2c_addr = 0x54,\n};\n\nstatic const struct m88ds3103_config dvbsky_t9580_m88ds3103_config = {\n\t.i2c_addr = 0x68,\n\t.clock = 27000000,\n\t.i2c_wr_max = 33,\n\t.clock_out = 0,\n\t.ts_mode = M88DS3103_TS_PARALLEL,\n\t.ts_clk = 16000,\n\t.ts_clk_pol = 1,\n\t.lnb_en_pol = 1,\n\t.lnb_hv_pol = 0,\n\t.agc = 0x99,\n};\n\nstatic const struct m88ds3103_config dvbsky_s950c_m88ds3103_config = {\n\t.i2c_addr = 0x68,\n\t.clock = 27000000,\n\t.i2c_wr_max = 33,\n\t.clock_out = 0,\n\t.ts_mode = M88DS3103_TS_CI,\n\t.ts_clk = 10000,\n\t.ts_clk_pol = 1,\n\t.lnb_en_pol = 1,\n\t.lnb_hv_pol = 0,\n\t.agc = 0x99,\n};\n\nstatic const struct m88ds3103_config hauppauge_hvr5525_m88ds3103_config = {\n\t.i2c_addr = 0x69,\n\t.clock = 27000000,\n\t.i2c_wr_max = 33,\n\t.ts_mode = M88DS3103_TS_PARALLEL,\n\t.ts_clk = 16000,\n\t.ts_clk_pol = 1,\n\t.agc = 0x99,\n};\n\nstatic struct lgdt3306a_config hauppauge_hvr1265k4_config = {\n\t.i2c_addr               = 0x59,\n\t.qam_if_khz             = 4000,\n\t.vsb_if_khz             = 3250,\n\t.deny_i2c_rptr          = 1,  \n\t.spectral_inversion     = 0,  \n\t.mpeg_mode              = LGDT3306A_MPEG_SERIAL,\n\t.tpclk_edge             = LGDT3306A_TPCLK_RISING_EDGE,\n\t.tpvalid_polarity       = LGDT3306A_TP_VALID_HIGH,\n\t.xtalMHz                = 25,  \n};\n\nstatic int netup_altera_fpga_rw(void *device, int flag, int data, int read)\n{\n\tstruct cx23885_dev *dev = (struct cx23885_dev *)device;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1);\n\tuint32_t mem = 0;\n\n\tmem = cx_read(MC417_RWD);\n\tif (read)\n\t\tcx_set(MC417_OEN, ALT_DATA);\n\telse {\n\t\tcx_clear(MC417_OEN, ALT_DATA); \n\t\tmem &= ~ALT_DATA;\n\t\tmem |= (data & ALT_DATA);\n\t}\n\n\tif (flag)\n\t\tmem |= ALT_AD_RG;\n\telse\n\t\tmem &= ~ALT_AD_RG;\n\n\tmem &= ~ALT_CS;\n\tif (read)\n\t\tmem = (mem & ~ALT_RD) | ALT_WR;\n\telse\n\t\tmem = (mem & ~ALT_WR) | ALT_RD;\n\n\tcx_write(MC417_RWD, mem);   \n\n\tfor (;;) {\n\t\tmem = cx_read(MC417_RWD);\n\t\tif ((mem & ALT_RDY) == 0)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tcx_set(MC417_RWD, ALT_RD | ALT_WR | ALT_CS);\n\tif (read)\n\t\treturn mem & ALT_DATA;\n\n\treturn 0;\n};\n\nstatic int dib7070_tuner_reset(struct dvb_frontend *fe, int onoff)\n{\n\tstruct dib7000p_ops *dib7000p_ops = fe->sec_priv;\n\n\treturn dib7000p_ops->set_gpio(fe, 8, 0, !onoff);\n}\n\nstatic int dib7070_tuner_sleep(struct dvb_frontend *fe, int onoff)\n{\n\treturn 0;\n}\n\nstatic struct dib0070_config dib7070p_dib0070_config = {\n\t.i2c_address = DEFAULT_DIB0070_I2C_ADDRESS,\n\t.reset = dib7070_tuner_reset,\n\t.sleep = dib7070_tuner_sleep,\n\t.clock_khz = 12000,\n\t.freq_offset_khz_vhf = 550,\n\t \n};\n\n \nstatic struct dibx000_agc_config dib7070_agc_config = {\n\t.band_caps = BAND_UHF | BAND_VHF | BAND_LBAND | BAND_SBAND,\n\n\t \n\t.setup = (0 << 15) | (0 << 14) | (5 << 11) | (0 << 10) | (0 << 9) |\n\t\t (0 << 8) | (3 << 5) | (0 << 4) | (5 << 1) | (0 << 0),\n\t.inv_gain = 600,\n\t.time_stabiliz = 10,\n\t.alpha_level = 0,\n\t.thlock = 118,\n\t.wbd_inv = 0,\n\t.wbd_ref = 3530,\n\t.wbd_sel = 1,\n\t.wbd_alpha = 5,\n\t.agc1_max = 65535,\n\t.agc1_min = 0,\n\t.agc2_max = 65535,\n\t.agc2_min = 0,\n\t.agc1_pt1 = 0,\n\t.agc1_pt2 = 40,\n\t.agc1_pt3 = 183,\n\t.agc1_slope1 = 206,\n\t.agc1_slope2 = 255,\n\t.agc2_pt1 = 72,\n\t.agc2_pt2 = 152,\n\t.agc2_slope1 = 88,\n\t.agc2_slope2 = 90,\n\t.alpha_mant = 17,\n\t.alpha_exp = 27,\n\t.beta_mant = 23,\n\t.beta_exp = 51,\n\t.perform_agc_softsplit = 0,\n};\n\nstatic struct dibx000_bandwidth_config dib7070_bw_config_12_mhz = {\n\t.internal = 60000,\n\t.sampling = 15000,\n\t.pll_prediv = 1,\n\t.pll_ratio = 20,\n\t.pll_range = 3,\n\t.pll_reset = 1,\n\t.pll_bypass = 0,\n\t.enable_refdiv = 0,\n\t.bypclk_div = 0,\n\t.IO_CLK_en_core = 1,\n\t.ADClkSrc = 1,\n\t.modulo = 2,\n\t \n\t.sad_cfg = (3 << 14) | (1 << 12) | (524 << 0),\n\t.ifreq = (0 << 25) | 0,\n\t.timf = 20452225,\n\t.xtal_hz = 12000000,\n};\n\nstatic struct dib7000p_config dib7070p_dib7000p_config = {\n\t \n\t.output_mode = OUTMODE_MPEG2_SERIAL,\n\t \n\t.output_mpeg2_in_188_bytes = 1,\n\n\t.agc_config_count = 1,\n\t.agc = &dib7070_agc_config,\n\t.bw  = &dib7070_bw_config_12_mhz,\n\t.tuner_is_baseband = 1,\n\t.spur_protect = 1,\n\n\t.gpio_dir = 0xfcef,  \n\t.gpio_val = 0x0110,  \n\t.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,\n\n\t.hostbus_diversity = 1,\n};\n\nstatic int dvb_register_ci_mac(struct cx23885_tsport *port)\n{\n\tstruct cx23885_dev *dev = port->dev;\n\tstruct i2c_client *client_ci = NULL;\n\tstruct vb2_dvb_frontend *fe0;\n\n\tfe0 = vb2_dvb_get_frontend(&port->frontends, 1);\n\tif (!fe0)\n\t\treturn -EINVAL;\n\n\tswitch (dev->board) {\n\tcase CX23885_BOARD_NETUP_DUAL_DVBS2_CI: {\n\t\tstatic struct netup_card_info cinfo;\n\n\t\tnetup_get_card_info(&dev->i2c_bus[0].i2c_adap, &cinfo);\n\t\tmemcpy(port->frontends.adapter.proposed_mac,\n\t\t\t\tcinfo.port[port->nr - 1].mac, 6);\n\t\tpr_info(\"NetUP Dual DVB-S2 CI card port%d MAC=%pM\\n\",\n\t\t\tport->nr, port->frontends.adapter.proposed_mac);\n\n\t\tnetup_ci_init(port);\n\t\treturn 0;\n\t\t}\n\tcase CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF: {\n\t\tstruct altera_ci_config netup_ci_cfg = {\n\t\t\t.dev = dev, \n\t\t\t.adapter = &port->frontends.adapter, \n\t\t\t.demux = &fe0->dvb.demux, \n\t\t\t.fpga_rw = netup_altera_fpga_rw,\n\t\t};\n\n\t\taltera_ci_init(&netup_ci_cfg, port->nr);\n\t\treturn 0;\n\t\t}\n\tcase CX23885_BOARD_TEVII_S470: {\n\t\tu8 eeprom[256];  \n\n\t\tif (port->nr != 1)\n\t\t\treturn 0;\n\n\t\t \n\t\tdev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;\n\t\ttveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom, sizeof(eeprom));\n\t\tpr_info(\"TeVii S470 MAC= %pM\\n\", eeprom + 0xa0);\n\t\tmemcpy(port->frontends.adapter.proposed_mac, eeprom + 0xa0, 6);\n\t\treturn 0;\n\t\t}\n\tcase CX23885_BOARD_DVBSKY_T9580:\n\tcase CX23885_BOARD_DVBSKY_S950:\n\tcase CX23885_BOARD_DVBSKY_S952:\n\tcase CX23885_BOARD_DVBSKY_T982: {\n\t\tu8 eeprom[256];  \n\n\t\tif (port->nr > 2)\n\t\t\treturn 0;\n\n\t\t \n\t\tdev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;\n\t\ttveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom,\n\t\t\t\tsizeof(eeprom));\n\t\tpr_info(\"%s port %d MAC address: %pM\\n\",\n\t\t\tcx23885_boards[dev->board].name, port->nr,\n\t\t\teeprom + 0xc0 + (port->nr-1) * 8);\n\t\tmemcpy(port->frontends.adapter.proposed_mac, eeprom + 0xc0 +\n\t\t\t(port->nr-1) * 8, 6);\n\t\treturn 0;\n\t\t}\n\tcase CX23885_BOARD_DVBSKY_S950C:\n\tcase CX23885_BOARD_DVBSKY_T980C:\n\tcase CX23885_BOARD_TT_CT2_4500_CI: {\n\t\tu8 eeprom[256];  \n\t\tstruct sp2_config sp2_config;\n\t\tstruct i2c_board_info info;\n\t\tstruct cx23885_i2c *i2c_bus = &dev->i2c_bus[0];\n\n\t\t \n\t\tmemset(&sp2_config, 0, sizeof(sp2_config));\n\t\tsp2_config.dvb_adap = &port->frontends.adapter;\n\t\tsp2_config.priv = port;\n\t\tsp2_config.ci_control = cx23885_sp2_ci_ctrl;\n\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\tstrscpy(info.type, \"sp2\", I2C_NAME_SIZE);\n\t\tinfo.addr = 0x40;\n\t\tinfo.platform_data = &sp2_config;\n\t\trequest_module(info.type);\n\t\tclient_ci = i2c_new_client_device(&i2c_bus->i2c_adap, &info);\n\t\tif (!i2c_client_has_driver(client_ci))\n\t\t\treturn -ENODEV;\n\t\tif (!try_module_get(client_ci->dev.driver->owner)) {\n\t\t\ti2c_unregister_device(client_ci);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tport->i2c_client_ci = client_ci;\n\n\t\tif (port->nr != 1)\n\t\t\treturn 0;\n\n\t\t \n\t\tdev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;\n\t\ttveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom,\n\t\t\t\tsizeof(eeprom));\n\t\tpr_info(\"%s MAC address: %pM\\n\",\n\t\t\tcx23885_boards[dev->board].name, eeprom + 0xc0);\n\t\tmemcpy(port->frontends.adapter.proposed_mac, eeprom + 0xc0, 6);\n\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dvb_register(struct cx23885_tsport *port)\n{\n\tstruct dib7000p_ops dib7000p_ops;\n\tstruct cx23885_dev *dev = port->dev;\n\tstruct cx23885_i2c *i2c_bus = NULL, *i2c_bus2 = NULL;\n\tstruct vb2_dvb_frontend *fe0, *fe1 = NULL;\n\tstruct si2168_config si2168_config;\n\tstruct si2165_platform_data si2165_pdata;\n\tstruct si2157_config si2157_config;\n\tstruct ts2020_config ts2020_config;\n\tstruct m88ds3103_platform_data m88ds3103_pdata;\n\tstruct m88rs6000t_config m88rs6000t_config = {};\n\tstruct a8293_platform_data a8293_pdata = {};\n\tstruct i2c_board_info info;\n\tstruct i2c_adapter *adapter;\n\tstruct i2c_client *client_demod = NULL, *client_tuner = NULL;\n\tstruct i2c_client *client_sec = NULL;\n\tint (*p_set_voltage)(struct dvb_frontend *fe,\n\t\t\t     enum fe_sec_voltage voltage) = NULL;\n\tint mfe_shared = 0;  \n\tint ret;\n\n\t \n\tfe0 = vb2_dvb_get_frontend(&port->frontends, 1);\n\tif (!fe0)\n\t\treturn -EINVAL;\n\n\t \n\tfe0->dvb.name = dev->name;\n\n\t \n\tport->frontends.gate = 0;\n\n\t \n\tport->gate_ctrl = cx23885_dvb_gate_ctrl;\n\n\t \n\tswitch (dev->board) {\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1250:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\tfe0->dvb.frontend = dvb_attach(s5h1409_attach,\n\t\t\t\t\t\t&hauppauge_generic_config,\n\t\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tdvb_attach(mt2131_attach, fe0->dvb.frontend,\n\t\t\t   &i2c_bus->i2c_adap,\n\t\t\t   &hauppauge_generic_tunerconfig, 0);\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1270:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1275:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\tfe0->dvb.frontend = dvb_attach(lgdt3305_attach,\n\t\t\t\t\t       &hauppauge_lgdt3305_config,\n\t\t\t\t\t       &i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tdvb_attach(tda18271_attach, fe0->dvb.frontend,\n\t\t\t   0x60, &dev->i2c_bus[1].i2c_adap,\n\t\t\t   &hauppauge_hvr127x_config);\n\t\tif (dev->board == CX23885_BOARD_HAUPPAUGE_HVR1275)\n\t\t\tcx23885_set_frontend_hook(port, fe0->dvb.frontend);\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1255:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1255_22111:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\tfe0->dvb.frontend = dvb_attach(s5h1411_attach,\n\t\t\t\t\t       &hcw_s5h1411_config,\n\t\t\t\t\t       &i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\n\t\tdvb_attach(tda18271_attach, fe0->dvb.frontend,\n\t\t\t   0x60, &dev->i2c_bus[1].i2c_adap,\n\t\t\t   &hauppauge_tda18271_config);\n\n\t\ttda18271_attach(&dev->ts1.analog_fe,\n\t\t\t0x60, &dev->i2c_bus[1].i2c_adap,\n\t\t\t&hauppauge_tda18271_config);\n\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1800:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\tswitch (alt_tuner) {\n\t\tcase 1:\n\t\t\tfe0->dvb.frontend =\n\t\t\t\tdvb_attach(s5h1409_attach,\n\t\t\t\t\t   &hauppauge_ezqam_config,\n\t\t\t\t\t   &i2c_bus->i2c_adap);\n\t\t\tif (fe0->dvb.frontend == NULL)\n\t\t\t\tbreak;\n\n\t\t\tdvb_attach(tda829x_attach, fe0->dvb.frontend,\n\t\t\t\t   &dev->i2c_bus[1].i2c_adap, 0x42,\n\t\t\t\t   &tda829x_no_probe);\n\t\t\tdvb_attach(tda18271_attach, fe0->dvb.frontend,\n\t\t\t\t   0x60, &dev->i2c_bus[1].i2c_adap,\n\t\t\t\t   &hauppauge_tda18271_config);\n\t\t\tbreak;\n\t\tcase 0:\n\t\tdefault:\n\t\t\tfe0->dvb.frontend =\n\t\t\t\tdvb_attach(s5h1409_attach,\n\t\t\t\t\t   &hauppauge_generic_config,\n\t\t\t\t\t   &i2c_bus->i2c_adap);\n\t\t\tif (fe0->dvb.frontend == NULL)\n\t\t\t\tbreak;\n\t\t\tdvb_attach(mt2131_attach, fe0->dvb.frontend,\n\t\t\t\t   &i2c_bus->i2c_adap,\n\t\t\t\t   &hauppauge_generic_tunerconfig, 0);\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1800lp:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\tfe0->dvb.frontend = dvb_attach(s5h1409_attach,\n\t\t\t\t\t\t&hauppauge_hvr1800lp_config,\n\t\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tdvb_attach(mt2131_attach, fe0->dvb.frontend,\n\t\t\t   &i2c_bus->i2c_adap,\n\t\t\t   &hauppauge_generic_tunerconfig, 0);\n\t\tbreak;\n\tcase CX23885_BOARD_DVICO_FUSIONHDTV_5_EXP:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\tfe0->dvb.frontend = dvb_attach(lgdt330x_attach,\n\t\t\t\t\t       &fusionhdtv_5_express,\n\t\t\t\t\t       0x0e,\n\t\t\t\t\t       &i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tdvb_attach(simple_tuner_attach, fe0->dvb.frontend,\n\t\t\t   &i2c_bus->i2c_adap, 0x61,\n\t\t\t   TUNER_LG_TDVS_H06XF);\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1500Q:\n\t\ti2c_bus = &dev->i2c_bus[1];\n\t\tfe0->dvb.frontend = dvb_attach(s5h1409_attach,\n\t\t\t\t\t\t&hauppauge_hvr1500q_config,\n\t\t\t\t\t\t&dev->i2c_bus[0].i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tdvb_attach(xc5000_attach, fe0->dvb.frontend,\n\t\t\t   &i2c_bus->i2c_adap,\n\t\t\t   &hauppauge_hvr1500q_tunerconfig);\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1500:\n\t\ti2c_bus = &dev->i2c_bus[1];\n\t\tfe0->dvb.frontend = dvb_attach(s5h1409_attach,\n\t\t\t\t\t\t&hauppauge_hvr1500_config,\n\t\t\t\t\t\t&dev->i2c_bus[0].i2c_adap);\n\t\tif (fe0->dvb.frontend != NULL) {\n\t\t\tstruct dvb_frontend *fe;\n\t\t\tstruct xc2028_config cfg = {\n\t\t\t\t.i2c_adap  = &i2c_bus->i2c_adap,\n\t\t\t\t.i2c_addr  = 0x61,\n\t\t\t};\n\t\t\tstatic struct xc2028_ctrl ctl = {\n\t\t\t\t.fname       = XC2028_DEFAULT_FIRMWARE,\n\t\t\t\t.max_len     = 64,\n\t\t\t\t.demod       = XC3028_FE_OREN538,\n\t\t\t};\n\n\t\t\tfe = dvb_attach(xc2028_attach,\n\t\t\t\t\tfe0->dvb.frontend, &cfg);\n\t\t\tif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\n\t\t\t\tfe->ops.tuner_ops.set_config(fe, &ctl);\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1200:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1700:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\tfe0->dvb.frontend = dvb_attach(tda10048_attach,\n\t\t\t&hauppauge_hvr1200_config,\n\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tdvb_attach(tda829x_attach, fe0->dvb.frontend,\n\t\t\t   &dev->i2c_bus[1].i2c_adap, 0x42,\n\t\t\t   &tda829x_no_probe);\n\t\tdvb_attach(tda18271_attach, fe0->dvb.frontend,\n\t\t\t   0x60, &dev->i2c_bus[1].i2c_adap,\n\t\t\t   &hauppauge_hvr1200_tuner_config);\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1210:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\tfe0->dvb.frontend = dvb_attach(tda10048_attach,\n\t\t\t&hauppauge_hvr1210_config,\n\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend != NULL) {\n\t\t\tdvb_attach(tda18271_attach, fe0->dvb.frontend,\n\t\t\t\t0x60, &dev->i2c_bus[1].i2c_adap,\n\t\t\t\t&hauppauge_hvr1210_tuner_config);\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1400:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\n\t\tif (!dvb_attach(dib7000p_attach, &dib7000p_ops))\n\t\t\treturn -ENODEV;\n\n\t\tfe0->dvb.frontend = dib7000p_ops.init(&i2c_bus->i2c_adap,\n\t\t\t0x12, &hauppauge_hvr1400_dib7000_config);\n\t\tif (fe0->dvb.frontend != NULL) {\n\t\t\tstruct dvb_frontend *fe;\n\t\t\tstruct xc2028_config cfg = {\n\t\t\t\t.i2c_adap  = &dev->i2c_bus[1].i2c_adap,\n\t\t\t\t.i2c_addr  = 0x64,\n\t\t\t};\n\t\t\tstatic struct xc2028_ctrl ctl = {\n\t\t\t\t.fname   = XC3028L_DEFAULT_FIRMWARE,\n\t\t\t\t.max_len = 64,\n\t\t\t\t.demod   = XC3028_FE_DIBCOM52,\n\t\t\t\t \n\t\t\t\t.type    = XC2028_D2633,\n\t\t\t};\n\n\t\t\tfe = dvb_attach(xc2028_attach,\n\t\t\t\t\tfe0->dvb.frontend, &cfg);\n\t\t\tif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\n\t\t\t\tfe->ops.tuner_ops.set_config(fe, &ctl);\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_DVICO_FUSIONHDTV_7_DUAL_EXP:\n\t\ti2c_bus = &dev->i2c_bus[port->nr - 1];\n\n\t\tfe0->dvb.frontend = dvb_attach(s5h1409_attach,\n\t\t\t\t\t\t&dvico_s5h1409_config,\n\t\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tfe0->dvb.frontend = dvb_attach(s5h1411_attach,\n\t\t\t\t\t\t\t&dvico_s5h1411_config,\n\t\t\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend != NULL)\n\t\t\tdvb_attach(xc5000_attach, fe0->dvb.frontend,\n\t\t\t\t   &i2c_bus->i2c_adap,\n\t\t\t\t   &dvico_xc5000_tunerconfig);\n\t\tbreak;\n\tcase CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP: {\n\t\ti2c_bus = &dev->i2c_bus[port->nr - 1];\n\n\t\tfe0->dvb.frontend = dvb_attach(zl10353_attach,\n\t\t\t\t\t       &dvico_fusionhdtv_xc3028,\n\t\t\t\t\t       &i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend != NULL) {\n\t\t\tstruct dvb_frontend      *fe;\n\t\t\tstruct xc2028_config\t  cfg = {\n\t\t\t\t.i2c_adap  = &i2c_bus->i2c_adap,\n\t\t\t\t.i2c_addr  = 0x61,\n\t\t\t};\n\t\t\tstatic struct xc2028_ctrl ctl = {\n\t\t\t\t.fname       = XC2028_DEFAULT_FIRMWARE,\n\t\t\t\t.max_len     = 64,\n\t\t\t\t.demod       = XC3028_FE_ZARLINK456,\n\t\t\t};\n\n\t\t\tfe = dvb_attach(xc2028_attach, fe0->dvb.frontend,\n\t\t\t\t\t&cfg);\n\t\t\tif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\n\t\t\t\tfe->ops.tuner_ops.set_config(fe, &ctl);\n\t\t}\n\t\tbreak;\n\t}\n\tcase CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP2: {\n\t\ti2c_bus = &dev->i2c_bus[port->nr - 1];\n\t\t \n\t\t \n\n\t\tif (!dvb_attach(dib7000p_attach, &dib7000p_ops))\n\t\t\treturn -ENODEV;\n\n\t\tif (dib7000p_ops.i2c_enumeration(&i2c_bus->i2c_adap, 1, 0x12, &dib7070p_dib7000p_config) < 0) {\n\t\t\tpr_warn(\"Unable to enumerate dib7000p\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tfe0->dvb.frontend = dib7000p_ops.init(&i2c_bus->i2c_adap, 0x80, &dib7070p_dib7000p_config);\n\t\tif (fe0->dvb.frontend != NULL) {\n\t\t\tstruct i2c_adapter *tun_i2c;\n\n\t\t\tfe0->dvb.frontend->sec_priv = kmemdup(&dib7000p_ops, sizeof(dib7000p_ops), GFP_KERNEL);\n\t\t\tif (!fe0->dvb.frontend->sec_priv)\n\t\t\t\treturn -ENOMEM;\n\t\t\ttun_i2c = dib7000p_ops.get_i2c_master(fe0->dvb.frontend, DIBX000_I2C_INTERFACE_TUNER, 1);\n\t\t\tif (!dvb_attach(dib0070_attach, fe0->dvb.frontend, tun_i2c, &dib7070p_dib0070_config))\n\t\t\t\treturn -ENODEV;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H:\n\tcase CX23885_BOARD_COMPRO_VIDEOMATE_E650F:\n\tcase CX23885_BOARD_COMPRO_VIDEOMATE_E800:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\n\t\tfe0->dvb.frontend = dvb_attach(zl10353_attach,\n\t\t\t&dvico_fusionhdtv_xc3028,\n\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend != NULL) {\n\t\t\tstruct dvb_frontend      *fe;\n\t\t\tstruct xc2028_config\t  cfg = {\n\t\t\t\t.i2c_adap  = &dev->i2c_bus[1].i2c_adap,\n\t\t\t\t.i2c_addr  = 0x61,\n\t\t\t};\n\t\t\tstatic struct xc2028_ctrl ctl = {\n\t\t\t\t.fname       = XC2028_DEFAULT_FIRMWARE,\n\t\t\t\t.max_len     = 64,\n\t\t\t\t.demod       = XC3028_FE_ZARLINK456,\n\t\t\t};\n\n\t\t\tfe = dvb_attach(xc2028_attach, fe0->dvb.frontend,\n\t\t\t\t&cfg);\n\t\t\tif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\n\t\t\t\tfe->ops.tuner_ops.set_config(fe, &ctl);\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H_XC4000:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\n\t\tfe0->dvb.frontend = dvb_attach(zl10353_attach,\n\t\t\t\t\t       &dvico_fusionhdtv_xc3028,\n\t\t\t\t\t       &i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend != NULL) {\n\t\t\tstruct dvb_frontend\t*fe;\n\t\t\tstruct xc4000_config\tcfg = {\n\t\t\t\t.i2c_address\t  = 0x61,\n\t\t\t\t.default_pm\t  = 0,\n\t\t\t\t.dvb_amplitude\t  = 134,\n\t\t\t\t.set_smoothedcvbs = 1,\n\t\t\t\t.if_khz\t\t  = 4560\n\t\t\t};\n\n\t\t\tfe = dvb_attach(xc4000_attach, fe0->dvb.frontend,\n\t\t\t\t\t&dev->i2c_bus[1].i2c_adap, &cfg);\n\t\t\tif (!fe) {\n\t\t\t\tpr_err(\"%s/2: xc4000 attach failed\\n\",\n\t\t\t\t       dev->name);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_TBS_6920:\n\t\ti2c_bus = &dev->i2c_bus[1];\n\n\t\tfe0->dvb.frontend = dvb_attach(cx24116_attach,\n\t\t\t\t\t&tbs_cx24116_config,\n\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend != NULL)\n\t\t\tfe0->dvb.frontend->ops.set_voltage = f300_set_voltage;\n\n\t\tbreak;\n\tcase CX23885_BOARD_TBS_6980:\n\tcase CX23885_BOARD_TBS_6981:\n\t\ti2c_bus = &dev->i2c_bus[1];\n\n\t\tswitch (port->nr) {\n\t\t \n\t\tcase 1:\n\t\t\tfe0->dvb.frontend = dvb_attach(cx24117_attach,\n\t\t\t\t\t&tbs_cx24117_config,\n\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\t\tbreak;\n\t\t \n\t\tcase 2:\n\t\t\tfe0->dvb.frontend = dvb_attach(cx24117_attach,\n\t\t\t\t\t&tbs_cx24117_config,\n\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_TEVII_S470:\n\t\ti2c_bus = &dev->i2c_bus[1];\n\n\t\tfe0->dvb.frontend = dvb_attach(ds3000_attach,\n\t\t\t\t\t&tevii_ds3000_config,\n\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend != NULL) {\n\t\t\tdvb_attach(ts2020_attach, fe0->dvb.frontend,\n\t\t\t\t&tevii_ts2020_config, &i2c_bus->i2c_adap);\n\t\t\tfe0->dvb.frontend->ops.set_voltage = f300_set_voltage;\n\t\t}\n\n\t\tbreak;\n\tcase CX23885_BOARD_DVBWORLD_2005:\n\t\ti2c_bus = &dev->i2c_bus[1];\n\n\t\tfe0->dvb.frontend = dvb_attach(cx24116_attach,\n\t\t\t&dvbworld_cx24116_config,\n\t\t\t&i2c_bus->i2c_adap);\n\t\tbreak;\n\tcase CX23885_BOARD_NETUP_DUAL_DVBS2_CI:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\tswitch (port->nr) {\n\t\t \n\t\tcase 1:\n\t\t\tfe0->dvb.frontend = dvb_attach(stv0900_attach,\n\t\t\t\t\t\t\t&netup_stv0900_config,\n\t\t\t\t\t\t\t&i2c_bus->i2c_adap, 0);\n\t\t\tif (fe0->dvb.frontend != NULL) {\n\t\t\t\tif (dvb_attach(stv6110_attach,\n\t\t\t\t\t\tfe0->dvb.frontend,\n\t\t\t\t\t\t&netup_stv6110_tunerconfig_a,\n\t\t\t\t\t\t&i2c_bus->i2c_adap)) {\n\t\t\t\t\tif (!dvb_attach(lnbh24_attach,\n\t\t\t\t\t\t\tfe0->dvb.frontend,\n\t\t\t\t\t\t\t&i2c_bus->i2c_adap,\n\t\t\t\t\t\t\tLNBH24_PCL | LNBH24_TTX,\n\t\t\t\t\t\t\tLNBH24_TEN, 0x09))\n\t\t\t\t\t\tpr_err(\"No LNBH24 found!\\n\");\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t \n\t\tcase 2:\n\t\t\tfe0->dvb.frontend = dvb_attach(stv0900_attach,\n\t\t\t\t\t\t\t&netup_stv0900_config,\n\t\t\t\t\t\t\t&i2c_bus->i2c_adap, 1);\n\t\t\tif (fe0->dvb.frontend != NULL) {\n\t\t\t\tif (dvb_attach(stv6110_attach,\n\t\t\t\t\t\tfe0->dvb.frontend,\n\t\t\t\t\t\t&netup_stv6110_tunerconfig_b,\n\t\t\t\t\t\t&i2c_bus->i2c_adap)) {\n\t\t\t\t\tif (!dvb_attach(lnbh24_attach,\n\t\t\t\t\t\t\tfe0->dvb.frontend,\n\t\t\t\t\t\t\t&i2c_bus->i2c_adap,\n\t\t\t\t\t\t\tLNBH24_PCL | LNBH24_TTX,\n\t\t\t\t\t\t\tLNBH24_TEN, 0x0a))\n\t\t\t\t\t\tpr_err(\"No LNBH24 found!\\n\");\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_MYGICA_X8506:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\ti2c_bus2 = &dev->i2c_bus[1];\n\t\tfe0->dvb.frontend = dvb_attach(lgs8gxx_attach,\n\t\t\t&mygica_x8506_lgs8gl5_config,\n\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tdvb_attach(xc5000_attach, fe0->dvb.frontend,\n\t\t\t   &i2c_bus2->i2c_adap, &mygica_x8506_xc5000_config);\n\t\tcx23885_set_frontend_hook(port, fe0->dvb.frontend);\n\t\tbreak;\n\tcase CX23885_BOARD_MYGICA_X8507:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\ti2c_bus2 = &dev->i2c_bus[1];\n\t\tfe0->dvb.frontend = dvb_attach(mb86a20s_attach,\n\t\t\t&mygica_x8507_mb86a20s_config,\n\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\n\t\tdvb_attach(xc5000_attach, fe0->dvb.frontend,\n\t\t\t   &i2c_bus2->i2c_adap,\n\t\t\t   &mygica_x8507_xc5000_config);\n\t\tcx23885_set_frontend_hook(port, fe0->dvb.frontend);\n\t\tbreak;\n\tcase CX23885_BOARD_MAGICPRO_PROHDTVE2:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\ti2c_bus2 = &dev->i2c_bus[1];\n\t\tfe0->dvb.frontend = dvb_attach(lgs8gxx_attach,\n\t\t\t&magicpro_prohdtve2_lgs8g75_config,\n\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tdvb_attach(xc5000_attach, fe0->dvb.frontend,\n\t\t\t   &i2c_bus2->i2c_adap,\n\t\t\t   &magicpro_prohdtve2_xc5000_config);\n\t\tcx23885_set_frontend_hook(port, fe0->dvb.frontend);\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1850:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\tfe0->dvb.frontend = dvb_attach(s5h1411_attach,\n\t\t\t&hcw_s5h1411_config,\n\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tdvb_attach(tda18271_attach, fe0->dvb.frontend,\n\t\t\t   0x60, &dev->i2c_bus[0].i2c_adap,\n\t\t\t   &hauppauge_tda18271_config);\n\n\t\ttda18271_attach(&dev->ts1.analog_fe,\n\t\t\t0x60, &dev->i2c_bus[1].i2c_adap,\n\t\t\t&hauppauge_tda18271_config);\n\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1290:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\tfe0->dvb.frontend = dvb_attach(s5h1411_attach,\n\t\t\t&hcw_s5h1411_config,\n\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tdvb_attach(tda18271_attach, fe0->dvb.frontend,\n\t\t\t   0x60, &dev->i2c_bus[0].i2c_adap,\n\t\t\t   &hauppauge_tda18271_config);\n\t\tbreak;\n\tcase CX23885_BOARD_MYGICA_X8558PRO:\n\t\tswitch (port->nr) {\n\t\t \n\t\tcase 1:\n\t\t\ti2c_bus = &dev->i2c_bus[0];\n\t\t\tfe0->dvb.frontend = dvb_attach(atbm8830_attach,\n\t\t\t\t&mygica_x8558pro_atbm8830_cfg1,\n\t\t\t\t&i2c_bus->i2c_adap);\n\t\t\tif (fe0->dvb.frontend == NULL)\n\t\t\t\tbreak;\n\t\t\tdvb_attach(max2165_attach, fe0->dvb.frontend,\n\t\t\t\t   &i2c_bus->i2c_adap,\n\t\t\t\t   &mygic_x8558pro_max2165_cfg1);\n\t\t\tbreak;\n\t\t \n\t\tcase 2:\n\t\t\ti2c_bus = &dev->i2c_bus[1];\n\t\t\tfe0->dvb.frontend = dvb_attach(atbm8830_attach,\n\t\t\t\t&mygica_x8558pro_atbm8830_cfg2,\n\t\t\t\t&i2c_bus->i2c_adap);\n\t\t\tif (fe0->dvb.frontend == NULL)\n\t\t\t\tbreak;\n\t\t\tdvb_attach(max2165_attach, fe0->dvb.frontend,\n\t\t\t\t   &i2c_bus->i2c_adap,\n\t\t\t\t   &mygic_x8558pro_max2165_cfg2);\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:\n\t\tif (port->nr > 2)\n\t\t\treturn 0;\n\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\tmfe_shared = 1; \n\t\tport->frontends.gate = 0; \n\t\t \n\t\t \n\t\tfe0->dvb.frontend = dvb_attach(stv0367ter_attach,\n\t\t\t\t\t&netup_stv0367_config[port->nr - 1],\n\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tif (NULL == dvb_attach(xc5000_attach, fe0->dvb.frontend,\n\t\t\t\t\t&i2c_bus->i2c_adap,\n\t\t\t\t\t&netup_xc5000_config[port->nr - 1]))\n\t\t\tgoto frontend_detach;\n\t\t \n\t\tfe0->dvb.frontend->ops.tuner_ops.init(fe0->dvb.frontend);\n\n\t\t \n\t\tfe1 = vb2_dvb_get_frontend(&port->frontends, 2);\n\t\tif (fe1 == NULL)\n\t\t\tgoto frontend_detach;\n\t\t \n\t\tfe1->dvb.frontend = dvb_attach(stv0367cab_attach,\n\t\t\t\t\t&netup_stv0367_config[port->nr - 1],\n\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe1->dvb.frontend == NULL)\n\t\t\tbreak;\n\n\t\tfe1->dvb.frontend->id = 1;\n\t\tif (NULL == dvb_attach(xc5000_attach,\n\t\t\t\t       fe1->dvb.frontend,\n\t\t\t\t       &i2c_bus->i2c_adap,\n\t\t\t\t       &netup_xc5000_config[port->nr - 1]))\n\t\t\tgoto frontend_detach;\n\t\tbreak;\n\tcase CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\ti2c_bus2 = &dev->i2c_bus[1];\n\n\t\tswitch (port->nr) {\n\t\t \n\t\tcase 1:\n\t\t\tfe0->dvb.frontend = dvb_attach(drxk_attach,\n\t\t\t\t\t&terratec_drxk_config[0],\n\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\t\tif (fe0->dvb.frontend == NULL)\n\t\t\t\tbreak;\n\t\t\tif (!dvb_attach(mt2063_attach,\n\t\t\t\t\tfe0->dvb.frontend,\n\t\t\t\t\t&terratec_mt2063_config[0],\n\t\t\t\t\t&i2c_bus2->i2c_adap))\n\t\t\t\tgoto frontend_detach;\n\t\t\tbreak;\n\t\t \n\t\tcase 2:\n\t\t\tfe0->dvb.frontend = dvb_attach(drxk_attach,\n\t\t\t\t\t&terratec_drxk_config[1],\n\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\t\tif (fe0->dvb.frontend == NULL)\n\t\t\t\tbreak;\n\t\t\tif (!dvb_attach(mt2063_attach,\n\t\t\t\t\tfe0->dvb.frontend,\n\t\t\t\t\t&terratec_mt2063_config[1],\n\t\t\t\t\t&i2c_bus2->i2c_adap))\n\t\t\t\tgoto frontend_detach;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_TEVII_S471:\n\t\ti2c_bus = &dev->i2c_bus[1];\n\n\t\tfe0->dvb.frontend = dvb_attach(ds3000_attach,\n\t\t\t\t\t&tevii_ds3000_config,\n\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tdvb_attach(ts2020_attach, fe0->dvb.frontend,\n\t\t\t   &tevii_ts2020_config, &i2c_bus->i2c_adap);\n\t\tbreak;\n\tcase CX23885_BOARD_PROF_8000:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\n\t\tfe0->dvb.frontend = dvb_attach(stv090x_attach,\n\t\t\t\t\t\t&prof_8000_stv090x_config,\n\t\t\t\t\t\t&i2c_bus->i2c_adap,\n\t\t\t\t\t\tSTV090x_DEMODULATOR_0);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\t\tif (!dvb_attach(stb6100_attach,\n\t\t\t\tfe0->dvb.frontend,\n\t\t\t\t&prof_8000_stb6100_config,\n\t\t\t\t&i2c_bus->i2c_adap))\n\t\t\tgoto frontend_detach;\n\n\t\tfe0->dvb.frontend->ops.set_voltage = p8000_set_voltage;\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR4400: {\n\t\tstruct tda10071_platform_data tda10071_pdata = hauppauge_tda10071_pdata;\n\t\tstruct a8293_platform_data a8293_pdata = {};\n\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\ti2c_bus2 = &dev->i2c_bus[1];\n\t\tswitch (port->nr) {\n\t\t \n\t\tcase 1:\n\t\t\t \n\t\t\tmemset(&info, 0, sizeof(info));\n\t\t\tstrscpy(info.type, \"tda10071_cx24118\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x05;\n\t\t\tinfo.platform_data = &tda10071_pdata;\n\t\t\trequest_module(\"tda10071\");\n\t\t\tclient_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_demod))\n\t\t\t\tgoto frontend_detach;\n\t\t\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tfe0->dvb.frontend = tda10071_pdata.get_dvb_frontend(client_demod);\n\t\t\tport->i2c_client_demod = client_demod;\n\n\t\t\t \n\t\t\ta8293_pdata.dvb_frontend = fe0->dvb.frontend;\n\t\t\tmemset(&info, 0, sizeof(info));\n\t\t\tstrscpy(info.type, \"a8293\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x0b;\n\t\t\tinfo.platform_data = &a8293_pdata;\n\t\t\trequest_module(\"a8293\");\n\t\t\tclient_sec = i2c_new_client_device(&i2c_bus->i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_sec))\n\t\t\t\tgoto frontend_detach;\n\t\t\tif (!try_module_get(client_sec->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_sec);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_sec = client_sec;\n\t\t\tbreak;\n\t\t \n\t\tcase 2:\n\t\t\t \n\t\t\tmemset(&si2165_pdata, 0, sizeof(si2165_pdata));\n\t\t\tsi2165_pdata.fe = &fe0->dvb.frontend;\n\t\t\tsi2165_pdata.chip_mode = SI2165_MODE_PLL_XTAL;\n\t\t\tsi2165_pdata.ref_freq_hz = 16000000;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2165\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x64;\n\t\t\tinfo.platform_data = &si2165_pdata;\n\t\t\trequest_module(info.type);\n\t\t\tclient_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_demod))\n\t\t\t\tgoto frontend_detach;\n\t\t\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_demod = client_demod;\n\n\t\t\tif (fe0->dvb.frontend == NULL)\n\t\t\t\tbreak;\n\t\t\tfe0->dvb.frontend->ops.i2c_gate_ctrl = NULL;\n\t\t\tif (!dvb_attach(tda18271_attach,\n\t\t\t\t\tfe0->dvb.frontend,\n\t\t\t\t\t0x60, &i2c_bus2->i2c_adap,\n\t\t\t\t  &hauppauge_hvr4400_tuner_config))\n\t\t\t\tgoto frontend_detach;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CX23885_BOARD_HAUPPAUGE_STARBURST: {\n\t\tstruct tda10071_platform_data tda10071_pdata = hauppauge_tda10071_pdata;\n\t\tstruct a8293_platform_data a8293_pdata = {};\n\n\t\ti2c_bus = &dev->i2c_bus[0];\n\n\t\t \n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrscpy(info.type, \"tda10071_cx24118\", I2C_NAME_SIZE);\n\t\tinfo.addr = 0x05;\n\t\tinfo.platform_data = &tda10071_pdata;\n\t\trequest_module(\"tda10071\");\n\t\tclient_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);\n\t\tif (!i2c_client_has_driver(client_demod))\n\t\t\tgoto frontend_detach;\n\t\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\t\ti2c_unregister_device(client_demod);\n\t\t\tgoto frontend_detach;\n\t\t}\n\t\tfe0->dvb.frontend = tda10071_pdata.get_dvb_frontend(client_demod);\n\t\tport->i2c_client_demod = client_demod;\n\n\t\t \n\t\ta8293_pdata.dvb_frontend = fe0->dvb.frontend;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrscpy(info.type, \"a8293\", I2C_NAME_SIZE);\n\t\tinfo.addr = 0x0b;\n\t\tinfo.platform_data = &a8293_pdata;\n\t\trequest_module(\"a8293\");\n\t\tclient_sec = i2c_new_client_device(&i2c_bus->i2c_adap, &info);\n\t\tif (!i2c_client_has_driver(client_sec))\n\t\t\tgoto frontend_detach;\n\t\tif (!try_module_get(client_sec->dev.driver->owner)) {\n\t\t\ti2c_unregister_device(client_sec);\n\t\t\tgoto frontend_detach;\n\t\t}\n\t\tport->i2c_client_sec = client_sec;\n\t\tbreak;\n\t}\n\tcase CX23885_BOARD_DVBSKY_T9580:\n\tcase CX23885_BOARD_DVBSKY_S950:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\ti2c_bus2 = &dev->i2c_bus[1];\n\t\tswitch (port->nr) {\n\t\t \n\t\tcase 1:\n\t\t\t \n\t\t\tfe0->dvb.frontend = dvb_attach(m88ds3103_attach,\n\t\t\t\t\t&dvbsky_t9580_m88ds3103_config,\n\t\t\t\t\t&i2c_bus2->i2c_adap, &adapter);\n\t\t\tif (fe0->dvb.frontend == NULL)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tmemset(&ts2020_config, 0, sizeof(ts2020_config));\n\t\t\tts2020_config.fe = fe0->dvb.frontend;\n\t\t\tts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"ts2020\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x60;\n\t\t\tinfo.platform_data = &ts2020_config;\n\t\t\trequest_module(info.type);\n\t\t\tclient_tuner = i2c_new_client_device(adapter, &info);\n\t\t\tif (!i2c_client_has_driver(client_tuner))\n\t\t\t\tgoto frontend_detach;\n\t\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_tuner);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\n\t\t\t \n\t\t\tfe0->dvb.frontend->ops.read_signal_strength =\n\t\t\t\tfe0->dvb.frontend->ops.tuner_ops.get_rf_strength;\n\n\t\t\t \n\t\t\tport->fe_set_voltage =\n\t\t\t\tfe0->dvb.frontend->ops.set_voltage;\n\t\t\tfe0->dvb.frontend->ops.set_voltage =\n\t\t\t\tdvbsky_t9580_set_voltage;\n\n\t\t\tport->i2c_client_tuner = client_tuner;\n\n\t\t\tbreak;\n\t\t \n\t\tcase 2:\n\t\t\t \n\t\t\tmemset(&si2168_config, 0, sizeof(si2168_config));\n\t\t\tsi2168_config.i2c_adapter = &adapter;\n\t\t\tsi2168_config.fe = &fe0->dvb.frontend;\n\t\t\tsi2168_config.ts_mode = SI2168_TS_SERIAL;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2168\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x64;\n\t\t\tinfo.platform_data = &si2168_config;\n\t\t\trequest_module(info.type);\n\t\t\tclient_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_demod))\n\t\t\t\tgoto frontend_detach;\n\t\t\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_demod = client_demod;\n\n\t\t\t \n\t\t\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\t\t\tsi2157_config.fe = fe0->dvb.frontend;\n\t\t\tsi2157_config.if_port = 1;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x60;\n\t\t\tinfo.platform_data = &si2157_config;\n\t\t\trequest_module(info.type);\n\t\t\tclient_tuner = i2c_new_client_device(adapter, &info);\n\t\t\tif (!i2c_client_has_driver(client_tuner))\n\t\t\t\tgoto frontend_detach;\n\n\t\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_tuner);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_tuner = client_tuner;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_DVBSKY_T980C:\n\tcase CX23885_BOARD_TT_CT2_4500_CI:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\ti2c_bus2 = &dev->i2c_bus[1];\n\n\t\t \n\t\tmemset(&si2168_config, 0, sizeof(si2168_config));\n\t\tsi2168_config.i2c_adapter = &adapter;\n\t\tsi2168_config.fe = &fe0->dvb.frontend;\n\t\tsi2168_config.ts_mode = SI2168_TS_PARALLEL;\n\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\tstrscpy(info.type, \"si2168\", I2C_NAME_SIZE);\n\t\tinfo.addr = 0x64;\n\t\tinfo.platform_data = &si2168_config;\n\t\trequest_module(info.type);\n\t\tclient_demod = i2c_new_client_device(&i2c_bus2->i2c_adap, &info);\n\t\tif (!i2c_client_has_driver(client_demod))\n\t\t\tgoto frontend_detach;\n\t\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\t\ti2c_unregister_device(client_demod);\n\t\t\tgoto frontend_detach;\n\t\t}\n\t\tport->i2c_client_demod = client_demod;\n\n\t\t \n\t\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\t\tsi2157_config.fe = fe0->dvb.frontend;\n\t\tsi2157_config.if_port = 1;\n\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\tstrscpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\t\tinfo.addr = 0x60;\n\t\tinfo.platform_data = &si2157_config;\n\t\trequest_module(info.type);\n\t\tclient_tuner = i2c_new_client_device(adapter, &info);\n\t\tif (!i2c_client_has_driver(client_tuner))\n\t\t\tgoto frontend_detach;\n\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\ti2c_unregister_device(client_tuner);\n\t\t\tgoto frontend_detach;\n\t\t}\n\t\tport->i2c_client_tuner = client_tuner;\n\t\tbreak;\n\tcase CX23885_BOARD_DVBSKY_S950C:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\ti2c_bus2 = &dev->i2c_bus[1];\n\n\t\t \n\t\tfe0->dvb.frontend = dvb_attach(m88ds3103_attach,\n\t\t\t\t&dvbsky_s950c_m88ds3103_config,\n\t\t\t\t&i2c_bus2->i2c_adap, &adapter);\n\t\tif (fe0->dvb.frontend == NULL)\n\t\t\tbreak;\n\n\t\t \n\t\tmemset(&ts2020_config, 0, sizeof(ts2020_config));\n\t\tts2020_config.fe = fe0->dvb.frontend;\n\t\tts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;\n\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\tstrscpy(info.type, \"ts2020\", I2C_NAME_SIZE);\n\t\tinfo.addr = 0x60;\n\t\tinfo.platform_data = &ts2020_config;\n\t\trequest_module(info.type);\n\t\tclient_tuner = i2c_new_client_device(adapter, &info);\n\t\tif (!i2c_client_has_driver(client_tuner))\n\t\t\tgoto frontend_detach;\n\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\ti2c_unregister_device(client_tuner);\n\t\t\tgoto frontend_detach;\n\t\t}\n\n\t\t \n\t\tfe0->dvb.frontend->ops.read_signal_strength =\n\t\t\tfe0->dvb.frontend->ops.tuner_ops.get_rf_strength;\n\n\t\tport->i2c_client_tuner = client_tuner;\n\t\tbreak;\n\tcase CX23885_BOARD_DVBSKY_S952:\n\t\t \n\t\tmemset(&m88ds3103_pdata, 0, sizeof(m88ds3103_pdata));\n\t\tm88ds3103_pdata.clk = 27000000;\n\t\tm88ds3103_pdata.i2c_wr_max = 33;\n\t\tm88ds3103_pdata.agc = 0x99;\n\t\tm88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_DISABLED;\n\t\tm88ds3103_pdata.lnb_en_pol = 1;\n\n\t\tswitch (port->nr) {\n\t\t \n\t\tcase 1:\n\t\t\ti2c_bus = &dev->i2c_bus[1];\n\t\t\tm88ds3103_pdata.ts_mode = M88DS3103_TS_PARALLEL;\n\t\t\tm88ds3103_pdata.ts_clk = 16000;\n\t\t\tm88ds3103_pdata.ts_clk_pol = 1;\n\t\t\tp_set_voltage = dvbsky_t9580_set_voltage;\n\t\t\tbreak;\n\t\t \n\t\tcase 2:\n\t\t\ti2c_bus = &dev->i2c_bus[0];\n\t\t\tm88ds3103_pdata.ts_mode = M88DS3103_TS_SERIAL;\n\t\t\tm88ds3103_pdata.ts_clk = 96000;\n\t\t\tm88ds3103_pdata.ts_clk_pol = 0;\n\t\t\tp_set_voltage = dvbsky_s952_portc_set_voltage;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tstrscpy(info.type, \"m88ds3103\", I2C_NAME_SIZE);\n\t\tinfo.addr = 0x68;\n\t\tinfo.platform_data = &m88ds3103_pdata;\n\t\trequest_module(info.type);\n\t\tclient_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);\n\t\tif (!i2c_client_has_driver(client_demod))\n\t\t\tgoto frontend_detach;\n\t\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\t\ti2c_unregister_device(client_demod);\n\t\t\tgoto frontend_detach;\n\t\t}\n\t\tport->i2c_client_demod = client_demod;\n\t\tadapter = m88ds3103_pdata.get_i2c_adapter(client_demod);\n\t\tfe0->dvb.frontend = m88ds3103_pdata.get_dvb_frontend(client_demod);\n\n\t\t \n\t\tmemset(&ts2020_config, 0, sizeof(ts2020_config));\n\t\tts2020_config.fe = fe0->dvb.frontend;\n\t\tts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;\n\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\tstrscpy(info.type, \"ts2020\", I2C_NAME_SIZE);\n\t\tinfo.addr = 0x60;\n\t\tinfo.platform_data = &ts2020_config;\n\t\trequest_module(info.type);\n\t\tclient_tuner = i2c_new_client_device(adapter, &info);\n\t\tif (!i2c_client_has_driver(client_tuner))\n\t\t\tgoto frontend_detach;\n\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\ti2c_unregister_device(client_tuner);\n\t\t\tgoto frontend_detach;\n\t\t}\n\n\t\t \n\t\tfe0->dvb.frontend->ops.read_signal_strength =\n\t\t\tfe0->dvb.frontend->ops.tuner_ops.get_rf_strength;\n\n\t\t \n\t\tport->fe_set_voltage =\n\t\t\tfe0->dvb.frontend->ops.set_voltage;\n\t\tfe0->dvb.frontend->ops.set_voltage = p_set_voltage;\n\n\t\tport->i2c_client_tuner = client_tuner;\n\t\tbreak;\n\tcase CX23885_BOARD_DVBSKY_T982:\n\t\tmemset(&si2168_config, 0, sizeof(si2168_config));\n\t\tswitch (port->nr) {\n\t\t \n\t\tcase 1:\n\t\t\ti2c_bus = &dev->i2c_bus[1];\n\t\t\tsi2168_config.ts_mode = SI2168_TS_PARALLEL;\n\t\t\tbreak;\n\t\t \n\t\tcase 2:\n\t\t\ti2c_bus = &dev->i2c_bus[0];\n\t\t\tsi2168_config.ts_mode = SI2168_TS_SERIAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsi2168_config.i2c_adapter = &adapter;\n\t\tsi2168_config.fe = &fe0->dvb.frontend;\n\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\tstrscpy(info.type, \"si2168\", I2C_NAME_SIZE);\n\t\tinfo.addr = 0x64;\n\t\tinfo.platform_data = &si2168_config;\n\t\trequest_module(info.type);\n\t\tclient_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);\n\t\tif (!i2c_client_has_driver(client_demod))\n\t\t\tgoto frontend_detach;\n\t\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\t\ti2c_unregister_device(client_demod);\n\t\t\tgoto frontend_detach;\n\t\t}\n\t\tport->i2c_client_demod = client_demod;\n\n\t\t \n\t\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\t\tsi2157_config.fe = fe0->dvb.frontend;\n\t\tsi2157_config.if_port = 1;\n\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\tstrscpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\t\tinfo.addr = 0x60;\n\t\tinfo.platform_data = &si2157_config;\n\t\trequest_module(info.type);\n\t\tclient_tuner = i2c_new_client_device(adapter, &info);\n\t\tif (!i2c_client_has_driver(client_tuner))\n\t\t\tgoto frontend_detach;\n\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\ti2c_unregister_device(client_tuner);\n\t\t\tgoto frontend_detach;\n\t\t}\n\t\tport->i2c_client_tuner = client_tuner;\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_STARBURST2:\n\tcase CX23885_BOARD_HAUPPAUGE_HVR5525:\n\t\ti2c_bus = &dev->i2c_bus[0];\n\t\ti2c_bus2 = &dev->i2c_bus[1];\n\n\t\tswitch (port->nr) {\n\n\t\t \n\t\tcase 1:\n\t\t\t \n\t\t\tfe0->dvb.frontend = dvb_attach(m88ds3103_attach,\n\t\t\t\t\t&hauppauge_hvr5525_m88ds3103_config,\n\t\t\t\t\t&i2c_bus->i2c_adap, &adapter);\n\t\t\tif (fe0->dvb.frontend == NULL)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\ta8293_pdata.dvb_frontend = fe0->dvb.frontend;\n\t\t\tmemset(&info, 0, sizeof(info));\n\t\t\tstrscpy(info.type, \"a8293\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x0b;\n\t\t\tinfo.platform_data = &a8293_pdata;\n\t\t\trequest_module(\"a8293\");\n\t\t\tclient_sec = i2c_new_client_device(&i2c_bus->i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_sec))\n\t\t\t\tgoto frontend_detach;\n\t\t\tif (!try_module_get(client_sec->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_sec);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_sec = client_sec;\n\n\t\t\t \n\t\t\tmemset(&m88rs6000t_config, 0, sizeof(m88rs6000t_config));\n\t\t\tm88rs6000t_config.fe = fe0->dvb.frontend;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"m88rs6000t\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x21;\n\t\t\tinfo.platform_data = &m88rs6000t_config;\n\t\t\trequest_module(\"%s\", info.type);\n\t\t\tclient_tuner = i2c_new_client_device(adapter, &info);\n\t\t\tif (!i2c_client_has_driver(client_tuner))\n\t\t\t\tgoto frontend_detach;\n\t\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_tuner);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_tuner = client_tuner;\n\n\t\t\t \n\t\t\tfe0->dvb.frontend->ops.read_signal_strength =\n\t\t\t\tfe0->dvb.frontend->ops.tuner_ops.get_rf_strength;\n\t\t\tbreak;\n\t\t \n\t\tcase 2:\n\t\t\t \n\t\t\tmemset(&si2168_config, 0, sizeof(si2168_config));\n\t\t\tsi2168_config.i2c_adapter = &adapter;\n\t\t\tsi2168_config.fe = &fe0->dvb.frontend;\n\t\t\tsi2168_config.ts_mode = SI2168_TS_SERIAL;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2168\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x64;\n\t\t\tinfo.platform_data = &si2168_config;\n\t\t\trequest_module(\"%s\", info.type);\n\t\t\tclient_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_demod))\n\t\t\t\tgoto frontend_detach;\n\t\t\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_demod = client_demod;\n\n\t\t\t \n\t\t\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\t\t\tsi2157_config.fe = fe0->dvb.frontend;\n\t\t\tsi2157_config.if_port = 1;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x60;\n\t\t\tinfo.platform_data = &si2157_config;\n\t\t\trequest_module(\"%s\", info.type);\n\t\t\tclient_tuner = i2c_new_client_device(&i2c_bus2->i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_tuner)) {\n\t\t\t\tmodule_put(client_demod->dev.driver->owner);\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tport->i2c_client_demod = NULL;\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_tuner);\n\t\t\t\tmodule_put(client_demod->dev.driver->owner);\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tport->i2c_client_demod = NULL;\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_tuner = client_tuner;\n\n\t\t\tdev->ts1.analog_fe.tuner_priv = client_tuner;\n\t\t\tmemcpy(&dev->ts1.analog_fe.ops.tuner_ops,\n\t\t\t       &fe0->dvb.frontend->ops.tuner_ops,\n\t\t\t       sizeof(struct dvb_tuner_ops));\n\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_DVB_885:\n\t\tpr_info(\"%s(): board=%d port=%d\\n\", __func__,\n\t\t\tdev->board, port->nr);\n\t\tswitch (port->nr) {\n\t\t \n\t\tcase 1:\n\t\t\t \n\t\t\tmemset(&si2168_config, 0, sizeof(si2168_config));\n\t\t\tsi2168_config.i2c_adapter = &adapter;\n\t\t\tsi2168_config.fe = &fe0->dvb.frontend;\n\t\t\tsi2168_config.ts_mode = SI2168_TS_SERIAL;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2168\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x64;\n\t\t\tinfo.platform_data = &si2168_config;\n\t\t\trequest_module(\"%s\", info.type);\n\t\t\tclient_demod = i2c_new_client_device(&dev->i2c_bus[0].i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_demod))\n\t\t\t\tgoto frontend_detach;\n\t\t\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_demod = client_demod;\n\n\t\t\t \n\t\t\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\t\t\tsi2157_config.fe = fe0->dvb.frontend;\n\t\t\tsi2157_config.if_port = 1;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x60;\n\t\t\tinfo.platform_data = &si2157_config;\n\t\t\trequest_module(\"%s\", info.type);\n\t\t\tclient_tuner = i2c_new_client_device(&dev->i2c_bus[1].i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_tuner)) {\n\t\t\t\tmodule_put(client_demod->dev.driver->owner);\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tport->i2c_client_demod = NULL;\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_tuner);\n\t\t\t\tmodule_put(client_demod->dev.driver->owner);\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tport->i2c_client_demod = NULL;\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_tuner = client_tuner;\n\n\t\t\t \n\t\t\tif (dev->board == CX23885_BOARD_HAUPPAUGE_QUADHD_DVB) {\n\t\t\t\tpr_info(\"%s(): QUADHD_DVB analog setup\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tdev->ts1.analog_fe.tuner_priv = client_tuner;\n\t\t\t\tmemcpy(&dev->ts1.analog_fe.ops.tuner_ops,\n\t\t\t\t       &fe0->dvb.frontend->ops.tuner_ops,\n\t\t\t\t       sizeof(struct dvb_tuner_ops));\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\tcase 2:\n\t\t\t \n\t\t\tmemset(&si2168_config, 0, sizeof(si2168_config));\n\t\t\tsi2168_config.i2c_adapter = &adapter;\n\t\t\tsi2168_config.fe = &fe0->dvb.frontend;\n\t\t\tsi2168_config.ts_mode = SI2168_TS_SERIAL;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2168\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x66;\n\t\t\tinfo.platform_data = &si2168_config;\n\t\t\trequest_module(\"%s\", info.type);\n\t\t\tclient_demod = i2c_new_client_device(&dev->i2c_bus[0].i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_demod))\n\t\t\t\tgoto frontend_detach;\n\t\t\tif (!try_module_get(client_demod->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_demod = client_demod;\n\n\t\t\t \n\t\t\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\t\t\tsi2157_config.fe = fe0->dvb.frontend;\n\t\t\tsi2157_config.if_port = 1;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x62;\n\t\t\tinfo.platform_data = &si2157_config;\n\t\t\trequest_module(\"%s\", info.type);\n\t\t\tclient_tuner = i2c_new_client_device(&dev->i2c_bus[1].i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_tuner)) {\n\t\t\t\tmodule_put(client_demod->dev.driver->owner);\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tport->i2c_client_demod = NULL;\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_tuner);\n\t\t\t\tmodule_put(client_demod->dev.driver->owner);\n\t\t\t\ti2c_unregister_device(client_demod);\n\t\t\t\tport->i2c_client_demod = NULL;\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_tuner = client_tuner;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:\n\tcase CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC_885:\n\t\tpr_info(\"%s(): board=%d port=%d\\n\", __func__,\n\t\t\tdev->board, port->nr);\n\t\tswitch (port->nr) {\n\t\t \n\t\tcase 1:\n\t\t\t \n\t\t\ti2c_bus = &dev->i2c_bus[0];\n\t\t\tfe0->dvb.frontend = dvb_attach(lgdt3306a_attach,\n\t\t\t\t&hauppauge_quadHD_ATSC_a_config, &i2c_bus->i2c_adap);\n\t\t\tif (fe0->dvb.frontend == NULL)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\t\t\tsi2157_config.fe = fe0->dvb.frontend;\n\t\t\tsi2157_config.if_port = 1;\n\t\t\tsi2157_config.inversion = 1;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x60;\n\t\t\tinfo.platform_data = &si2157_config;\n\t\t\trequest_module(\"%s\", info.type);\n\t\t\tclient_tuner = i2c_new_client_device(&dev->i2c_bus[1].i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_tuner)) {\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_tuner);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_tuner = client_tuner;\n\n\t\t\t \n\t\t\tif (dev->board == CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC) {\n\t\t\t\tpr_info(\"%s(): QUADHD_ATSC analog setup\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tdev->ts1.analog_fe.tuner_priv = client_tuner;\n\t\t\t\tmemcpy(&dev->ts1.analog_fe.ops.tuner_ops,\n\t\t\t\t       &fe0->dvb.frontend->ops.tuner_ops,\n\t\t\t\t       sizeof(struct dvb_tuner_ops));\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\tcase 2:\n\t\t\t \n\t\t\ti2c_bus = &dev->i2c_bus[0];\n\t\t\tfe0->dvb.frontend = dvb_attach(lgdt3306a_attach,\n\t\t\t\t&hauppauge_quadHD_ATSC_b_config, &i2c_bus->i2c_adap);\n\t\t\tif (fe0->dvb.frontend == NULL)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\t\t\tsi2157_config.fe = fe0->dvb.frontend;\n\t\t\tsi2157_config.if_port = 1;\n\t\t\tsi2157_config.inversion = 1;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x62;\n\t\t\tinfo.platform_data = &si2157_config;\n\t\t\trequest_module(\"%s\", info.type);\n\t\t\tclient_tuner = i2c_new_client_device(&dev->i2c_bus[1].i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_tuner)) {\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_tuner);\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_tuner = client_tuner;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CX23885_BOARD_HAUPPAUGE_HVR1265_K4:\n\t\tswitch (port->nr) {\n\t\t \n\t\tcase 2:\n\t\t\t \n\t\t\ti2c_bus = &dev->i2c_bus[0];\n\t\t\tfe0->dvb.frontend = dvb_attach(lgdt3306a_attach,\n\t\t\t\t\t&hauppauge_hvr1265k4_config,\n\t\t\t\t\t&i2c_bus->i2c_adap);\n\t\t\tif (fe0->dvb.frontend == NULL)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tmemset(&si2157_config, 0, sizeof(si2157_config));\n\t\t\tsi2157_config.fe = fe0->dvb.frontend;\n\t\t\tsi2157_config.if_port = 1;\n\t\t\tsi2157_config.inversion = 1;\n\t\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\t\tstrscpy(info.type, \"si2157\", I2C_NAME_SIZE);\n\t\t\tinfo.addr = 0x60;\n\t\t\tinfo.platform_data = &si2157_config;\n\t\t\trequest_module(\"%s\", info.type);\n\t\t\tclient_tuner = i2c_new_client_device(&dev->i2c_bus[1].i2c_adap, &info);\n\t\t\tif (!i2c_client_has_driver(client_tuner))\n\t\t\t\tgoto frontend_detach;\n\n\t\t\tif (!try_module_get(client_tuner->dev.driver->owner)) {\n\t\t\t\ti2c_unregister_device(client_tuner);\n\t\t\t\tclient_tuner = NULL;\n\t\t\t\tgoto frontend_detach;\n\t\t\t}\n\t\t\tport->i2c_client_tuner = client_tuner;\n\n\t\t\tdev->ts1.analog_fe.tuner_priv = client_tuner;\n\t\t\tmemcpy(&dev->ts1.analog_fe.ops.tuner_ops,\n\t\t\t       &fe0->dvb.frontend->ops.tuner_ops,\n\t\t\t       sizeof(struct dvb_tuner_ops));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: The frontend of your DVB/ATSC card  isn't supported yet\\n\",\n\t\t\tdev->name);\n\t\tbreak;\n\t}\n\n\tif ((NULL == fe0->dvb.frontend) || (fe1 && NULL == fe1->dvb.frontend)) {\n\t\tpr_err(\"%s: frontend initialization failed\\n\",\n\t\t       dev->name);\n\t\tgoto frontend_detach;\n\t}\n\n\t \n\tfe0->dvb.frontend->callback = cx23885_tuner_callback;\n\tif (fe1)\n\t\tfe1->dvb.frontend->callback = cx23885_tuner_callback;\n#if 0\n\t \n\tfe0->dvb.frontend->ops.ts_bus_ctrl = cx23885_dvb_bus_ctrl;\n\tif (fe1)\n\t\tfe1->dvb.frontend->ops.ts_bus_ctrl = cx23885_dvb_bus_ctrl;\n#endif\n\n\t \n\tcall_all(dev, tuner, standby);\n\n\tif (fe0->dvb.frontend->ops.analog_ops.standby)\n\t\tfe0->dvb.frontend->ops.analog_ops.standby(fe0->dvb.frontend);\n\n\t \n\tret = vb2_dvb_register_bus(&port->frontends, THIS_MODULE, port,\n\t\t\t\t   &dev->pci->dev, NULL,\n\t\t\t\t   adapter_nr, mfe_shared);\n\tif (ret)\n\t\tgoto frontend_detach;\n\n\tret = dvb_register_ci_mac(port);\n\tif (ret)\n\t\tgoto frontend_detach;\n\n\treturn 0;\n\nfrontend_detach:\n\t \n\tclient_sec = port->i2c_client_sec;\n\tif (client_sec) {\n\t\tmodule_put(client_sec->dev.driver->owner);\n\t\ti2c_unregister_device(client_sec);\n\t\tport->i2c_client_sec = NULL;\n\t}\n\n\t \n\tclient_tuner = port->i2c_client_tuner;\n\tif (client_tuner) {\n\t\tmodule_put(client_tuner->dev.driver->owner);\n\t\ti2c_unregister_device(client_tuner);\n\t\tport->i2c_client_tuner = NULL;\n\t}\n\n\t \n\tclient_demod = port->i2c_client_demod;\n\tif (client_demod) {\n\t\tmodule_put(client_demod->dev.driver->owner);\n\t\ti2c_unregister_device(client_demod);\n\t\tport->i2c_client_demod = NULL;\n\t}\n\n\tport->gate_ctrl = NULL;\n\tvb2_dvb_dealloc_frontends(&port->frontends);\n\treturn -EINVAL;\n}\n\nint cx23885_dvb_register(struct cx23885_tsport *port)\n{\n\n\tstruct vb2_dvb_frontend *fe0;\n\tstruct cx23885_dev *dev = port->dev;\n\tint err, i;\n\n\t \n\tpr_info(\"%s() allocating %d frontend(s)\\n\", __func__,\n\t\tport->num_frontends);\n\n\tfor (i = 1; i <= port->num_frontends; i++) {\n\t\tstruct vb2_queue *q;\n\n\t\tif (vb2_dvb_alloc_frontend(\n\t\t\t&port->frontends, i) == NULL) {\n\t\t\tpr_err(\"%s() failed to alloc\\n\", __func__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfe0 = vb2_dvb_get_frontend(&port->frontends, i);\n\t\tif (!fe0)\n\t\t\treturn -EINVAL;\n\n\t\tdprintk(1, \"%s\\n\", __func__);\n\t\tdprintk(1, \" ->probed by Card=%d Name=%s, PCI %02x:%02x\\n\",\n\t\t\tdev->board,\n\t\t\tdev->name,\n\t\t\tdev->pci_bus,\n\t\t\tdev->pci_slot);\n\n\t\t \n\t\t \n\t\tpr_info(\"%s: cx23885 based dvb card\\n\", dev->name);\n\t\tq = &fe0->dvb.dvbq;\n\t\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\n\t\tq->gfp_flags = GFP_DMA32;\n\t\tq->min_buffers_needed = 2;\n\t\tq->drv_priv = port;\n\t\tq->buf_struct_size = sizeof(struct cx23885_buffer);\n\t\tq->ops = &dvb_qops;\n\t\tq->mem_ops = &vb2_dma_sg_memops;\n\t\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\t\tq->lock = &dev->lock;\n\t\tq->dev = &dev->pci->dev;\n\n\t\terr = vb2_queue_init(q);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = dvb_register(port);\n\tif (err != 0)\n\t\tpr_err(\"%s() dvb_register failed err = %d\\n\",\n\t\t       __func__, err);\n\n\treturn err;\n}\n\nint cx23885_dvb_unregister(struct cx23885_tsport *port)\n{\n\tstruct vb2_dvb_frontend *fe0;\n\tstruct i2c_client *client;\n\n\tfe0 = vb2_dvb_get_frontend(&port->frontends, 1);\n\n\tif (fe0 && fe0->dvb.frontend)\n\t\tvb2_dvb_unregister_bus(&port->frontends);\n\n\t \n\tclient = port->i2c_client_ci;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\t \n\tclient = port->i2c_client_sec;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\t \n\tclient = port->i2c_client_tuner;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\t \n\tclient = port->i2c_client_demod;\n\tif (client) {\n\t\tmodule_put(client->dev.driver->owner);\n\t\ti2c_unregister_device(client);\n\t}\n\n\tswitch (port->dev->board) {\n\tcase CX23885_BOARD_NETUP_DUAL_DVBS2_CI:\n\t\tnetup_ci_exit(port);\n\t\tbreak;\n\tcase CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:\n\t\taltera_ci_release(port->dev, port->nr);\n\t\tbreak;\n\t}\n\n\tport->gate_ctrl = NULL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}