{
  "module_name": "cx23885-417.c",
  "hash_id": "48c9a1a5ffc0454a08e37e3cd7d5d8083910a07f3424cb35dbf2e6d9f3e501ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx23885/cx23885-417.c",
  "human_readable_source": "\n \n\n#include \"cx23885.h\"\n#include \"cx23885-ioctl.h\"\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/drv-intf/cx2341x.h>\n\n#define CX23885_FIRM_IMAGE_SIZE 376836\n#define CX23885_FIRM_IMAGE_NAME \"v4l-cx23885-enc.fw\"\n\nstatic unsigned int mpegbufs = 32;\nmodule_param(mpegbufs, int, 0644);\nMODULE_PARM_DESC(mpegbufs, \"number of mpeg buffers, range 2-32\");\nstatic unsigned int mpeglines = 32;\nmodule_param(mpeglines, int, 0644);\nMODULE_PARM_DESC(mpeglines, \"number of lines in an MPEG buffer, range 2-32\");\nstatic unsigned int mpeglinesize = 512;\nmodule_param(mpeglinesize, int, 0644);\nMODULE_PARM_DESC(mpeglinesize,\n\t\"number of bytes in each line of an MPEG buffer, range 512-1024\");\n\nstatic unsigned int v4l_debug;\nmodule_param(v4l_debug, int, 0644);\nMODULE_PARM_DESC(v4l_debug, \"enable V4L debug messages\");\n\n#define dprintk(level, fmt, arg...)\\\n\tdo { if (v4l_debug >= level) \\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: 417:\" fmt), \\\n\t\t\t__func__, ##arg); \\\n\t} while (0)\n\nstatic struct cx23885_tvnorm cx23885_tvnorms[] = {\n\t{\n\t\t.name      = \"NTSC-M\",\n\t\t.id        = V4L2_STD_NTSC_M,\n\t}, {\n\t\t.name      = \"NTSC-JP\",\n\t\t.id        = V4L2_STD_NTSC_M_JP,\n\t}, {\n\t\t.name      = \"PAL-BG\",\n\t\t.id        = V4L2_STD_PAL_BG,\n\t}, {\n\t\t.name      = \"PAL-DK\",\n\t\t.id        = V4L2_STD_PAL_DK,\n\t}, {\n\t\t.name      = \"PAL-I\",\n\t\t.id        = V4L2_STD_PAL_I,\n\t}, {\n\t\t.name      = \"PAL-M\",\n\t\t.id        = V4L2_STD_PAL_M,\n\t}, {\n\t\t.name      = \"PAL-N\",\n\t\t.id        = V4L2_STD_PAL_N,\n\t}, {\n\t\t.name      = \"PAL-Nc\",\n\t\t.id        = V4L2_STD_PAL_Nc,\n\t}, {\n\t\t.name      = \"PAL-60\",\n\t\t.id        = V4L2_STD_PAL_60,\n\t}, {\n\t\t.name      = \"SECAM-L\",\n\t\t.id        = V4L2_STD_SECAM_L,\n\t}, {\n\t\t.name      = \"SECAM-DK\",\n\t\t.id        = V4L2_STD_SECAM_DK,\n\t}\n};\n\n \nenum cx23885_capture_type {\n\tCX23885_MPEG_CAPTURE,\n\tCX23885_RAW_CAPTURE,\n\tCX23885_RAW_PASSTHRU_CAPTURE\n};\nenum cx23885_capture_bits {\n\tCX23885_RAW_BITS_NONE             = 0x00,\n\tCX23885_RAW_BITS_YUV_CAPTURE      = 0x01,\n\tCX23885_RAW_BITS_PCM_CAPTURE      = 0x02,\n\tCX23885_RAW_BITS_VBI_CAPTURE      = 0x04,\n\tCX23885_RAW_BITS_PASSTHRU_CAPTURE = 0x08,\n\tCX23885_RAW_BITS_TO_HOST_CAPTURE  = 0x10\n};\nenum cx23885_capture_end {\n\tCX23885_END_AT_GOP,  \n\tCX23885_END_NOW,  \n};\nenum cx23885_framerate {\n\tCX23885_FRAMERATE_NTSC_30,  \n\tCX23885_FRAMERATE_PAL_25    \n};\nenum cx23885_stream_port {\n\tCX23885_OUTPUT_PORT_MEMORY,\n\tCX23885_OUTPUT_PORT_STREAMING,\n\tCX23885_OUTPUT_PORT_SERIAL\n};\nenum cx23885_data_xfer_status {\n\tCX23885_MORE_BUFFERS_FOLLOW,\n\tCX23885_LAST_BUFFER,\n};\nenum cx23885_picture_mask {\n\tCX23885_PICTURE_MASK_NONE,\n\tCX23885_PICTURE_MASK_I_FRAMES,\n\tCX23885_PICTURE_MASK_I_P_FRAMES = 0x3,\n\tCX23885_PICTURE_MASK_ALL_FRAMES = 0x7,\n};\nenum cx23885_vbi_mode_bits {\n\tCX23885_VBI_BITS_SLICED,\n\tCX23885_VBI_BITS_RAW,\n};\nenum cx23885_vbi_insertion_bits {\n\tCX23885_VBI_BITS_INSERT_IN_XTENSION_USR_DATA,\n\tCX23885_VBI_BITS_INSERT_IN_PRIVATE_PACKETS = 0x1 << 1,\n\tCX23885_VBI_BITS_SEPARATE_STREAM = 0x2 << 1,\n\tCX23885_VBI_BITS_SEPARATE_STREAM_USR_DATA = 0x4 << 1,\n\tCX23885_VBI_BITS_SEPARATE_STREAM_PRV_DATA = 0x5 << 1,\n};\nenum cx23885_dma_unit {\n\tCX23885_DMA_BYTES,\n\tCX23885_DMA_FRAMES,\n};\nenum cx23885_dma_transfer_status_bits {\n\tCX23885_DMA_TRANSFER_BITS_DONE = 0x01,\n\tCX23885_DMA_TRANSFER_BITS_ERROR = 0x04,\n\tCX23885_DMA_TRANSFER_BITS_LL_ERROR = 0x10,\n};\nenum cx23885_pause {\n\tCX23885_PAUSE_ENCODING,\n\tCX23885_RESUME_ENCODING,\n};\nenum cx23885_copyright {\n\tCX23885_COPYRIGHT_OFF,\n\tCX23885_COPYRIGHT_ON,\n};\nenum cx23885_notification_type {\n\tCX23885_NOTIFICATION_REFRESH,\n};\nenum cx23885_notification_status {\n\tCX23885_NOTIFICATION_OFF,\n\tCX23885_NOTIFICATION_ON,\n};\nenum cx23885_notification_mailbox {\n\tCX23885_NOTIFICATION_NO_MAILBOX = -1,\n};\nenum cx23885_field1_lines {\n\tCX23885_FIELD1_SAA7114 = 0x00EF,  \n\tCX23885_FIELD1_SAA7115 = 0x00F0,  \n\tCX23885_FIELD1_MICRONAS = 0x0105,  \n};\nenum cx23885_field2_lines {\n\tCX23885_FIELD2_SAA7114 = 0x00EF,  \n\tCX23885_FIELD2_SAA7115 = 0x00F0,  \n\tCX23885_FIELD2_MICRONAS = 0x0106,  \n};\nenum cx23885_custom_data_type {\n\tCX23885_CUSTOM_EXTENSION_USR_DATA,\n\tCX23885_CUSTOM_PRIVATE_PACKET,\n};\nenum cx23885_mute {\n\tCX23885_UNMUTE,\n\tCX23885_MUTE,\n};\nenum cx23885_mute_video_mask {\n\tCX23885_MUTE_VIDEO_V_MASK = 0x0000FF00,\n\tCX23885_MUTE_VIDEO_U_MASK = 0x00FF0000,\n\tCX23885_MUTE_VIDEO_Y_MASK = 0xFF000000,\n};\nenum cx23885_mute_video_shift {\n\tCX23885_MUTE_VIDEO_V_SHIFT = 8,\n\tCX23885_MUTE_VIDEO_U_SHIFT = 16,\n\tCX23885_MUTE_VIDEO_Y_SHIFT = 24,\n};\n\n \n#define IVTV_CMD_HW_BLOCKS_RST 0xFFFFFFFF\n\n \n#define IVTV_API_STD_TIMEOUT 500\n\n \n \n#define IVTV_REG_ENC_SDRAM_REFRESH (0x07F8)\n#define IVTV_REG_ENC_SDRAM_PRECHARGE (0x07FC)\n#define IVTV_REG_SPU (0x9050)\n#define IVTV_REG_HW_BLOCKS (0x9054)\n#define IVTV_REG_VPU (0x9058)\n#define IVTV_REG_APU (0xA064)\n\n \n#define MC417_MIWR\t0x8000\n#define MC417_MIRD\t0x4000\n#define MC417_MICS\t0x2000\n#define MC417_MIRDY\t0x1000\n#define MC417_MIADDR\t0x0F00\n#define MC417_MIDATA\t0x00FF\n\n \n#define  MCI_MEMORY_DATA_BYTE0          0x000\n#define  MCI_MEMORY_DATA_BYTE1          0x100\n#define  MCI_MEMORY_DATA_BYTE2          0x200\n#define  MCI_MEMORY_DATA_BYTE3          0x300\n#define  MCI_MEMORY_ADDRESS_BYTE2       0x400\n#define  MCI_MEMORY_ADDRESS_BYTE1       0x500\n#define  MCI_MEMORY_ADDRESS_BYTE0       0x600\n#define  MCI_REGISTER_DATA_BYTE0        0x800\n#define  MCI_REGISTER_DATA_BYTE1        0x900\n#define  MCI_REGISTER_DATA_BYTE2        0xA00\n#define  MCI_REGISTER_DATA_BYTE3        0xB00\n#define  MCI_REGISTER_ADDRESS_BYTE0     0xC00\n#define  MCI_REGISTER_ADDRESS_BYTE1     0xD00\n#define  MCI_REGISTER_MODE              0xE00\n\n \n#define  MCI_MODE_REGISTER_READ         0\n#define  MCI_MODE_REGISTER_WRITE        1\n#define  MCI_MODE_MEMORY_READ           0\n#define  MCI_MODE_MEMORY_WRITE          0x40\n\n \n#define MC417_SPD_CTL(x)\t(((x) << 4) & 0x00000030)\n#define MC417_GPIO_SEL(x)\t(((x) << 1) & 0x00000006)\n#define MC417_UART_GPIO_EN\t0x00000001\n\n \n#define MC417_SPD_CTL_SLOW\t0x1\n#define MC417_SPD_CTL_MEDIUM\t0x0\n#define MC417_SPD_CTL_FAST\t0x3      \n\n \n#define MC417_GPIO_SEL_GPIO3\t0x3\n#define MC417_GPIO_SEL_GPIO2\t0x2\n#define MC417_GPIO_SEL_GPIO1\t0x1\n#define MC417_GPIO_SEL_GPIO0\t0x0\n\nvoid cx23885_mc417_init(struct cx23885_dev *dev)\n{\n\tu32 regval;\n\n\tdprintk(2, \"%s()\\n\", __func__);\n\n\t \n\tregval = MC417_SPD_CTL(MC417_SPD_CTL_FAST)\t|\n\t\t MC417_GPIO_SEL(MC417_GPIO_SEL_GPIO3)\t|\n\t\t MC417_UART_GPIO_EN;\n\tcx_write(MC417_CTL, regval);\n\n\t \n\tregval = MC417_MIRDY;\n\tcx_write(MC417_OEN, regval);\n\n\t \n\tregval = MC417_MIWR | MC417_MIRD | MC417_MICS;\n\tcx_write(MC417_RWD, regval);\n}\n\nstatic int mc417_wait_ready(struct cx23885_dev *dev)\n{\n\tu32 mi_ready;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1);\n\n\tfor (;;) {\n\t\tmi_ready = cx_read(MC417_RWD) & MC417_MIRDY;\n\t\tif (mi_ready != 0)\n\t\t\treturn 0;\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -1;\n\t\tudelay(1);\n\t}\n}\n\nint mc417_register_write(struct cx23885_dev *dev, u16 address, u32 value)\n{\n\tu32 regval;\n\n\t \n\tcx_write(MC417_OEN, MC417_MIRDY);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE0 |\n\t\t(value & 0x000000FF);\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE1 |\n\t\t((value >> 8) & 0x000000FF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE2 |\n\t\t((value >> 16) & 0x000000FF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE3 |\n\t\t((value >> 24) & 0x000000FF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_ADDRESS_BYTE0 |\n\t\t(address & 0xFF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_ADDRESS_BYTE1 |\n\t\t((address >> 8) & 0xFF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_MODE |\n\t\tMCI_MODE_REGISTER_WRITE;\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\treturn mc417_wait_ready(dev);\n}\n\nint mc417_register_read(struct cx23885_dev *dev, u16 address, u32 *value)\n{\n\tint retval;\n\tu32 regval;\n\tu32 tempval;\n\tu32 dataval;\n\n\t \n\tcx_write(MC417_OEN, MC417_MIRDY);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_ADDRESS_BYTE0 |\n\t\t((address & 0x00FF));\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_ADDRESS_BYTE1 |\n\t\t((address >> 8) & 0xFF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_MODE |\n\t\tMCI_MODE_REGISTER_READ;\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tretval = mc417_wait_ready(dev);\n\n\t \n\tcx_write(MC417_OEN, MC417_MIRDY | MC417_MIDATA);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE0;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIWR | MC417_MIRDY | MCI_REGISTER_DATA_BYTE0;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\ttempval = cx_read(MC417_RWD);\n\tdataval = tempval & 0x000000FF;\n\n\t \n\tregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE1;\n\tcx_write(MC417_RWD, regval);\n\tregval = MC417_MIWR | MC417_MIRDY | MCI_REGISTER_DATA_BYTE1;\n\tcx_write(MC417_RWD, regval);\n\ttempval = cx_read(MC417_RWD);\n\tdataval |= ((tempval & 0x000000FF) << 8);\n\tregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE2;\n\tcx_write(MC417_RWD, regval);\n\tregval = MC417_MIWR | MC417_MIRDY | MCI_REGISTER_DATA_BYTE2;\n\tcx_write(MC417_RWD, regval);\n\ttempval = cx_read(MC417_RWD);\n\tdataval |= ((tempval & 0x000000FF) << 16);\n\tregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE3;\n\tcx_write(MC417_RWD, regval);\n\tregval = MC417_MIWR | MC417_MIRDY | MCI_REGISTER_DATA_BYTE3;\n\tcx_write(MC417_RWD, regval);\n\ttempval = cx_read(MC417_RWD);\n\tdataval |= ((tempval & 0x000000FF) << 24);\n\tregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\n\tcx_write(MC417_RWD, regval);\n\n\t*value  = dataval;\n\n\treturn retval;\n}\n\nint mc417_memory_write(struct cx23885_dev *dev, u32 address, u32 value)\n{\n\tu32 regval;\n\n\t \n\tcx_write(MC417_OEN, MC417_MIRDY);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE0 |\n\t\t(value & 0x000000FF);\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE1 |\n\t\t((value >> 8) & 0x000000FF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE2 |\n\t\t((value >> 16) & 0x000000FF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE3 |\n\t\t((value >> 24) & 0x000000FF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE2 |\n\t\tMCI_MODE_MEMORY_WRITE | ((address >> 16) & 0x3F);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE1 |\n\t\t((address >> 8) & 0xFF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE0 |\n\t\t(address & 0xFF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\treturn mc417_wait_ready(dev);\n}\n\nint mc417_memory_read(struct cx23885_dev *dev, u32 address, u32 *value)\n{\n\tint retval;\n\tu32 regval;\n\tu32 tempval;\n\tu32 dataval;\n\n\t \n\tcx_write(MC417_OEN, MC417_MIRDY);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE2 |\n\t\tMCI_MODE_MEMORY_READ | ((address >> 16) & 0x3F);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE1 |\n\t\t((address >> 8) & 0xFF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE0 |\n\t\t(address & 0xFF);\n\tcx_write(MC417_RWD, regval);\n\tregval |= MC417_MICS | MC417_MIWR;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tretval = mc417_wait_ready(dev);\n\n\t \n\tcx_write(MC417_OEN, MC417_MIRDY | MC417_MIDATA);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE3;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIWR | MC417_MIRDY | MCI_MEMORY_DATA_BYTE3;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\ttempval = cx_read(MC417_RWD);\n\tdataval = ((tempval & 0x000000FF) << 24);\n\n\t \n\tregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE2;\n\tcx_write(MC417_RWD, regval);\n\tregval = MC417_MIWR | MC417_MIRDY | MCI_MEMORY_DATA_BYTE2;\n\tcx_write(MC417_RWD, regval);\n\ttempval = cx_read(MC417_RWD);\n\tdataval |= ((tempval & 0x000000FF) << 16);\n\tregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE1;\n\tcx_write(MC417_RWD, regval);\n\tregval = MC417_MIWR | MC417_MIRDY | MCI_MEMORY_DATA_BYTE1;\n\tcx_write(MC417_RWD, regval);\n\ttempval = cx_read(MC417_RWD);\n\tdataval |= ((tempval & 0x000000FF) << 8);\n\tregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\n\tcx_write(MC417_RWD, regval);\n\n\t \n\tregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE0;\n\tcx_write(MC417_RWD, regval);\n\tregval = MC417_MIWR | MC417_MIRDY | MCI_MEMORY_DATA_BYTE0;\n\tcx_write(MC417_RWD, regval);\n\ttempval = cx_read(MC417_RWD);\n\tdataval |= (tempval & 0x000000FF);\n\tregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\n\tcx_write(MC417_RWD, regval);\n\n\t*value  = dataval;\n\n\treturn retval;\n}\n\nvoid mc417_gpio_set(struct cx23885_dev *dev, u32 mask)\n{\n\tu32 val;\n\n\t \n\tmc417_register_read(dev, 0x900C, &val);\n\tval |= (mask & 0x000ffff);\n\tmc417_register_write(dev, 0x900C, val);\n}\n\nvoid mc417_gpio_clear(struct cx23885_dev *dev, u32 mask)\n{\n\tu32 val;\n\n\t \n\tmc417_register_read(dev, 0x900C, &val);\n\tval &= ~(mask & 0x0000ffff);\n\tmc417_register_write(dev, 0x900C, val);\n}\n\nvoid mc417_gpio_enable(struct cx23885_dev *dev, u32 mask, int asoutput)\n{\n\tu32 val;\n\n\t \n\tmc417_register_read(dev, 0x9020, &val);\n\tif (asoutput)\n\t\tval |= (mask & 0x0000ffff);\n\telse\n\t\tval &= ~(mask & 0x0000ffff);\n\n\tmc417_register_write(dev, 0x9020, val);\n}\n \n\n \nstatic char *cmd_to_str(int cmd)\n{\n\tswitch (cmd) {\n\tcase CX2341X_ENC_PING_FW:\n\t\treturn  \"PING_FW\";\n\tcase CX2341X_ENC_START_CAPTURE:\n\t\treturn  \"START_CAPTURE\";\n\tcase CX2341X_ENC_STOP_CAPTURE:\n\t\treturn  \"STOP_CAPTURE\";\n\tcase CX2341X_ENC_SET_AUDIO_ID:\n\t\treturn  \"SET_AUDIO_ID\";\n\tcase CX2341X_ENC_SET_VIDEO_ID:\n\t\treturn  \"SET_VIDEO_ID\";\n\tcase CX2341X_ENC_SET_PCR_ID:\n\t\treturn  \"SET_PCR_ID\";\n\tcase CX2341X_ENC_SET_FRAME_RATE:\n\t\treturn  \"SET_FRAME_RATE\";\n\tcase CX2341X_ENC_SET_FRAME_SIZE:\n\t\treturn  \"SET_FRAME_SIZE\";\n\tcase CX2341X_ENC_SET_BIT_RATE:\n\t\treturn  \"SET_BIT_RATE\";\n\tcase CX2341X_ENC_SET_GOP_PROPERTIES:\n\t\treturn  \"SET_GOP_PROPERTIES\";\n\tcase CX2341X_ENC_SET_ASPECT_RATIO:\n\t\treturn  \"SET_ASPECT_RATIO\";\n\tcase CX2341X_ENC_SET_DNR_FILTER_MODE:\n\t\treturn  \"SET_DNR_FILTER_MODE\";\n\tcase CX2341X_ENC_SET_DNR_FILTER_PROPS:\n\t\treturn  \"SET_DNR_FILTER_PROPS\";\n\tcase CX2341X_ENC_SET_CORING_LEVELS:\n\t\treturn  \"SET_CORING_LEVELS\";\n\tcase CX2341X_ENC_SET_SPATIAL_FILTER_TYPE:\n\t\treturn  \"SET_SPATIAL_FILTER_TYPE\";\n\tcase CX2341X_ENC_SET_VBI_LINE:\n\t\treturn  \"SET_VBI_LINE\";\n\tcase CX2341X_ENC_SET_STREAM_TYPE:\n\t\treturn  \"SET_STREAM_TYPE\";\n\tcase CX2341X_ENC_SET_OUTPUT_PORT:\n\t\treturn  \"SET_OUTPUT_PORT\";\n\tcase CX2341X_ENC_SET_AUDIO_PROPERTIES:\n\t\treturn  \"SET_AUDIO_PROPERTIES\";\n\tcase CX2341X_ENC_HALT_FW:\n\t\treturn  \"HALT_FW\";\n\tcase CX2341X_ENC_GET_VERSION:\n\t\treturn  \"GET_VERSION\";\n\tcase CX2341X_ENC_SET_GOP_CLOSURE:\n\t\treturn  \"SET_GOP_CLOSURE\";\n\tcase CX2341X_ENC_GET_SEQ_END:\n\t\treturn  \"GET_SEQ_END\";\n\tcase CX2341X_ENC_SET_PGM_INDEX_INFO:\n\t\treturn  \"SET_PGM_INDEX_INFO\";\n\tcase CX2341X_ENC_SET_VBI_CONFIG:\n\t\treturn  \"SET_VBI_CONFIG\";\n\tcase CX2341X_ENC_SET_DMA_BLOCK_SIZE:\n\t\treturn  \"SET_DMA_BLOCK_SIZE\";\n\tcase CX2341X_ENC_GET_PREV_DMA_INFO_MB_10:\n\t\treturn  \"GET_PREV_DMA_INFO_MB_10\";\n\tcase CX2341X_ENC_GET_PREV_DMA_INFO_MB_9:\n\t\treturn  \"GET_PREV_DMA_INFO_MB_9\";\n\tcase CX2341X_ENC_SCHED_DMA_TO_HOST:\n\t\treturn  \"SCHED_DMA_TO_HOST\";\n\tcase CX2341X_ENC_INITIALIZE_INPUT:\n\t\treturn  \"INITIALIZE_INPUT\";\n\tcase CX2341X_ENC_SET_FRAME_DROP_RATE:\n\t\treturn  \"SET_FRAME_DROP_RATE\";\n\tcase CX2341X_ENC_PAUSE_ENCODER:\n\t\treturn  \"PAUSE_ENCODER\";\n\tcase CX2341X_ENC_REFRESH_INPUT:\n\t\treturn  \"REFRESH_INPUT\";\n\tcase CX2341X_ENC_SET_COPYRIGHT:\n\t\treturn  \"SET_COPYRIGHT\";\n\tcase CX2341X_ENC_SET_EVENT_NOTIFICATION:\n\t\treturn  \"SET_EVENT_NOTIFICATION\";\n\tcase CX2341X_ENC_SET_NUM_VSYNC_LINES:\n\t\treturn  \"SET_NUM_VSYNC_LINES\";\n\tcase CX2341X_ENC_SET_PLACEHOLDER:\n\t\treturn  \"SET_PLACEHOLDER\";\n\tcase CX2341X_ENC_MUTE_VIDEO:\n\t\treturn  \"MUTE_VIDEO\";\n\tcase CX2341X_ENC_MUTE_AUDIO:\n\t\treturn  \"MUTE_AUDIO\";\n\tcase CX2341X_ENC_MISC:\n\t\treturn  \"MISC\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic int cx23885_mbox_func(void *priv,\n\t\t\t     u32 command,\n\t\t\t     int in,\n\t\t\t     int out,\n\t\t\t     u32 data[CX2341X_MBOX_MAX_DATA])\n{\n\tstruct cx23885_dev *dev = priv;\n\tunsigned long timeout;\n\tu32 value, flag, retval = 0;\n\tint i;\n\n\tdprintk(3, \"%s: command(0x%X) = %s\\n\", __func__, command,\n\t\tcmd_to_str(command));\n\n\t \n\tmc417_memory_read(dev, dev->cx23417_mailbox - 4, &value);\n\tif (value != 0x12345678) {\n\t\tpr_err(\"Firmware and/or mailbox pointer not initialized or corrupted, signature = 0x%x, cmd = %s\\n\",\n\t\t\tvalue, cmd_to_str(command));\n\t\treturn -1;\n\t}\n\n\t \n\tmc417_memory_read(dev, dev->cx23417_mailbox, &flag);\n\tif (flag) {\n\t\tpr_err(\"ERROR: Mailbox appears to be in use (%x), cmd = %s\\n\",\n\t\t       flag, cmd_to_str(command));\n\t\treturn -1;\n\t}\n\n\tflag |= 1;  \n\tmc417_memory_write(dev, dev->cx23417_mailbox, flag);\n\n\t \n\t \n\tmc417_memory_write(dev, dev->cx23417_mailbox + 1, command);\n\tmc417_memory_write(dev, dev->cx23417_mailbox + 3,\n\t\tIVTV_API_STD_TIMEOUT);  \n\tfor (i = 0; i < in; i++) {\n\t\tmc417_memory_write(dev, dev->cx23417_mailbox + 4 + i, data[i]);\n\t\tdprintk(3, \"API Input %d = %d\\n\", i, data[i]);\n\t}\n\tfor (; i < CX2341X_MBOX_MAX_DATA; i++)\n\t\tmc417_memory_write(dev, dev->cx23417_mailbox + 4 + i, 0);\n\n\tflag |= 3;  \n\tmc417_memory_write(dev, dev->cx23417_mailbox, flag);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(10);\n\tfor (;;) {\n\t\tmc417_memory_read(dev, dev->cx23417_mailbox, &flag);\n\t\tif (0 != (flag & 4))\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tpr_err(\"ERROR: API Mailbox timeout\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\t \n\tfor (i = 0; i < out; i++) {\n\t\tmc417_memory_read(dev, dev->cx23417_mailbox + 4 + i, data + i);\n\t\tdprintk(3, \"API Output %d = %d\\n\", i, data[i]);\n\t}\n\n\tmc417_memory_read(dev, dev->cx23417_mailbox + 2, &retval);\n\tdprintk(3, \"API result = %d\\n\", retval);\n\n\tflag = 0;\n\tmc417_memory_write(dev, dev->cx23417_mailbox, flag);\n\n\treturn retval;\n}\n\n \nstatic int cx23885_api_cmd(struct cx23885_dev *dev,\n\t\t\t   u32 command,\n\t\t\t   u32 inputcnt,\n\t\t\t   u32 outputcnt,\n\t\t\t   ...)\n{\n\tu32 data[CX2341X_MBOX_MAX_DATA];\n\tva_list vargs;\n\tint i, err;\n\n\tdprintk(3, \"%s() cmds = 0x%08x\\n\", __func__, command);\n\n\tva_start(vargs, outputcnt);\n\tfor (i = 0; i < inputcnt; i++)\n\t\tdata[i] = va_arg(vargs, int);\n\n\terr = cx23885_mbox_func(dev, command, inputcnt, outputcnt, data);\n\tfor (i = 0; i < outputcnt; i++) {\n\t\tint *vptr = va_arg(vargs, int *);\n\t\t*vptr = data[i];\n\t}\n\tva_end(vargs);\n\n\treturn err;\n}\n\nstatic int cx23885_api_func(void *priv, u32 cmd, int in, int out, u32 data[CX2341X_MBOX_MAX_DATA])\n{\n\treturn cx23885_mbox_func(priv, cmd, in, out, data);\n}\n\nstatic int cx23885_find_mailbox(struct cx23885_dev *dev)\n{\n\tu32 signature[4] = {\n\t\t0x12345678, 0x34567812, 0x56781234, 0x78123456\n\t};\n\tint signaturecnt = 0;\n\tu32 value;\n\tint i;\n\n\tdprintk(2, \"%s()\\n\", __func__);\n\n\tfor (i = 0; i < CX23885_FIRM_IMAGE_SIZE; i++) {\n\t\tmc417_memory_read(dev, i, &value);\n\t\tif (value == signature[signaturecnt])\n\t\t\tsignaturecnt++;\n\t\telse\n\t\t\tsignaturecnt = 0;\n\t\tif (4 == signaturecnt) {\n\t\t\tdprintk(1, \"Mailbox signature found at 0x%x\\n\", i+1);\n\t\t\treturn i+1;\n\t\t}\n\t}\n\tpr_err(\"Mailbox signature values not found!\\n\");\n\treturn -1;\n}\n\nstatic int cx23885_load_firmware(struct cx23885_dev *dev)\n{\n\tstatic const unsigned char magic[8] = {\n\t\t0xa7, 0x0d, 0x00, 0x00, 0x66, 0xbb, 0x55, 0xaa\n\t};\n\tconst struct firmware *firmware;\n\tint i, retval = 0;\n\tu32 value = 0;\n\tu32 gpio_output = 0;\n\tu32 gpio_value;\n\tu32 checksum = 0;\n\tu32 *dataptr;\n\n\tdprintk(2, \"%s()\\n\", __func__);\n\n\t \n\tretval |= mc417_memory_read(dev, 0x9020, &gpio_output);\n\tretval |= mc417_memory_read(dev, 0x900C, &gpio_value);\n\n\tretval  = mc417_register_write(dev,\n\t\tIVTV_REG_VPU, 0xFFFFFFED);\n\tretval |= mc417_register_write(dev,\n\t\tIVTV_REG_HW_BLOCKS, IVTV_CMD_HW_BLOCKS_RST);\n\tretval |= mc417_register_write(dev,\n\t\tIVTV_REG_ENC_SDRAM_REFRESH, 0x80000800);\n\tretval |= mc417_register_write(dev,\n\t\tIVTV_REG_ENC_SDRAM_PRECHARGE, 0x1A);\n\tretval |= mc417_register_write(dev,\n\t\tIVTV_REG_APU, 0);\n\n\tif (retval != 0) {\n\t\tpr_err(\"%s: Error with mc417_register_write\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n\n\tretval = request_firmware(&firmware, CX23885_FIRM_IMAGE_NAME,\n\t\t\t\t  &dev->pci->dev);\n\n\tif (retval != 0) {\n\t\tpr_err(\"ERROR: Hotplug firmware request failed (%s).\\n\",\n\t\t       CX23885_FIRM_IMAGE_NAME);\n\t\tpr_err(\"Please fix your hotplug setup, the board will not work without firmware loaded!\\n\");\n\t\treturn -1;\n\t}\n\n\tif (firmware->size != CX23885_FIRM_IMAGE_SIZE) {\n\t\tpr_err(\"ERROR: Firmware size mismatch (have %zu, expected %d)\\n\",\n\t\t       firmware->size, CX23885_FIRM_IMAGE_SIZE);\n\t\trelease_firmware(firmware);\n\t\treturn -1;\n\t}\n\n\tif (0 != memcmp(firmware->data, magic, 8)) {\n\t\tpr_err(\"ERROR: Firmware magic mismatch, wrong file?\\n\");\n\t\trelease_firmware(firmware);\n\t\treturn -1;\n\t}\n\n\t \n\tdprintk(2, \"Loading firmware ...\\n\");\n\tdataptr = (u32 *)firmware->data;\n\tfor (i = 0; i < (firmware->size >> 2); i++) {\n\t\tvalue = *dataptr;\n\t\tchecksum += ~value;\n\t\tif (mc417_memory_write(dev, i, value) != 0) {\n\t\t\tpr_err(\"ERROR: Loading firmware failed!\\n\");\n\t\t\trelease_firmware(firmware);\n\t\t\treturn -1;\n\t\t}\n\t\tdataptr++;\n\t}\n\n\t \n\tdprintk(1, \"Verifying firmware ...\\n\");\n\tfor (i--; i >= 0; i--) {\n\t\tif (mc417_memory_read(dev, i, &value) != 0) {\n\t\t\tpr_err(\"ERROR: Reading firmware failed!\\n\");\n\t\t\trelease_firmware(firmware);\n\t\t\treturn -1;\n\t\t}\n\t\tchecksum -= ~value;\n\t}\n\tif (checksum) {\n\t\tpr_err(\"ERROR: Firmware load failed (checksum mismatch).\\n\");\n\t\trelease_firmware(firmware);\n\t\treturn -1;\n\t}\n\trelease_firmware(firmware);\n\tdprintk(1, \"Firmware upload successful.\\n\");\n\n\tretval |= mc417_register_write(dev, IVTV_REG_HW_BLOCKS,\n\t\tIVTV_CMD_HW_BLOCKS_RST);\n\n\t \n\tretval |= mc417_register_write(dev, 0x9020, gpio_output);\n\tretval |= mc417_register_write(dev, 0x900C, gpio_value);\n\n\tretval |= mc417_register_read(dev, IVTV_REG_VPU, &value);\n\tretval |= mc417_register_write(dev, IVTV_REG_VPU, value & 0xFFFFFFE8);\n\n\t \n\tretval |= mc417_register_write(dev, 0x9020, 0x4000);\n\tretval |= mc417_register_write(dev, 0x900C, 0x4000);\n\n\tmc417_register_read(dev, 0x9020, &gpio_output);\n\tmc417_register_read(dev, 0x900C, &gpio_value);\n\n\tif (retval < 0)\n\t\tpr_err(\"%s: Error with mc417_register_write\\n\",\n\t\t\t__func__);\n\treturn 0;\n}\n\nvoid cx23885_417_check_encoder(struct cx23885_dev *dev)\n{\n\tu32 status, seq;\n\n\tstatus = seq = 0;\n\tcx23885_api_cmd(dev, CX2341X_ENC_GET_SEQ_END, 0, 2, &status, &seq);\n\tdprintk(1, \"%s() status = %d, seq = %d\\n\", __func__, status, seq);\n}\n\nstatic void cx23885_codec_settings(struct cx23885_dev *dev)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tif (dev->encodernorm.id & V4L2_STD_525_60)\n\t\tdev->ts1.height = 480;\n\telse\n\t\tdev->ts1.height = 576;\n\n\t \n\tcx23885_api_cmd(dev, CX2341X_ENC_SET_FRAME_SIZE, 2, 0,\n\t\t\t\tdev->ts1.height, dev->ts1.width);\n\n\tdev->cxhdl.width = dev->ts1.width;\n\tdev->cxhdl.height = dev->ts1.height;\n\tdev->cxhdl.is_50hz =\n\t\t(dev->encodernorm.id & V4L2_STD_625_50) != 0;\n\n\tcx2341x_handler_setup(&dev->cxhdl);\n\n\tcx23885_api_cmd(dev, CX2341X_ENC_MISC, 2, 0, 3, 1);\n\tcx23885_api_cmd(dev, CX2341X_ENC_MISC, 2, 0, 4, 1);\n}\n\nstatic int cx23885_initialize_codec(struct cx23885_dev *dev, int startencoder)\n{\n\tint version;\n\tint retval;\n\tu32 i, data[7];\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tretval = cx23885_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);  \n\tif (retval < 0) {\n\t\tdprintk(2, \"%s() PING OK\\n\", __func__);\n\t\tretval = cx23885_load_firmware(dev);\n\t\tif (retval < 0) {\n\t\t\tpr_err(\"%s() f/w load failed\\n\", __func__);\n\t\t\treturn retval;\n\t\t}\n\t\tretval = cx23885_find_mailbox(dev);\n\t\tif (retval < 0) {\n\t\t\tpr_err(\"%s() mailbox < 0, error\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -1;\n\t\t}\n\t\tdev->cx23417_mailbox = retval;\n\t\tretval = cx23885_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\n\t\tif (retval < 0) {\n\t\t\tpr_err(\"ERROR: cx23417 firmware ping failed!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tretval = cx23885_api_cmd(dev, CX2341X_ENC_GET_VERSION, 0, 1,\n\t\t\t&version);\n\t\tif (retval < 0) {\n\t\t\tpr_err(\"ERROR: cx23417 firmware get encoder :version failed!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tdprintk(1, \"cx23417 firmware version is 0x%08x\\n\", version);\n\t\tmsleep(200);\n\t}\n\n\tcx23885_codec_settings(dev);\n\tmsleep(60);\n\n\tcx23885_api_cmd(dev, CX2341X_ENC_SET_NUM_VSYNC_LINES, 2, 0,\n\t\tCX23885_FIELD1_SAA7115, CX23885_FIELD2_SAA7115);\n\tcx23885_api_cmd(dev, CX2341X_ENC_SET_PLACEHOLDER, 12, 0,\n\t\tCX23885_CUSTOM_EXTENSION_USR_DATA, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0);\n\n\t \n\tdata[0] = 0x0001BD00;\n\tdata[1] = 1;           \n\tdata[2] = 4;           \n\tdata[3] = 0x91559155;  \n\tdata[4] = 0x206080C0;  \n\tdata[5] = 6;           \n\tdata[6] = 64;          \n\n\tcx23885_api_cmd(dev, CX2341X_ENC_SET_VBI_CONFIG, 7, 0, data[0], data[1],\n\t\tdata[2], data[3], data[4], data[5], data[6]);\n\n\tfor (i = 2; i <= 24; i++) {\n\t\tint valid;\n\n\t\tvalid = ((i >= 19) && (i <= 21));\n\t\tcx23885_api_cmd(dev, CX2341X_ENC_SET_VBI_LINE, 5, 0, i,\n\t\t\t\tvalid, 0 , 0, 0);\n\t\tcx23885_api_cmd(dev, CX2341X_ENC_SET_VBI_LINE, 5, 0,\n\t\t\t\ti | 0x80000000, valid, 0, 0, 0);\n\t}\n\n\tcx23885_api_cmd(dev, CX2341X_ENC_MUTE_AUDIO, 1, 0, CX23885_UNMUTE);\n\tmsleep(60);\n\n\t \n\tcx23885_api_cmd(dev, CX2341X_ENC_INITIALIZE_INPUT, 0, 0);\n\tmsleep(60);\n\n\t \n\tmc417_memory_write(dev, 2120, 0x00000080);\n\n\t \n\tif (startencoder) {\n\t\tcx23885_api_cmd(dev, CX2341X_ENC_START_CAPTURE, 2, 0,\n\t\t\tCX23885_MPEG_CAPTURE, CX23885_RAW_BITS_NONE);\n\t\tmsleep(10);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int queue_setup(struct vb2_queue *q,\n\t\t\t   unsigned int *num_buffers, unsigned int *num_planes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct cx23885_dev *dev = q->drv_priv;\n\n\tdev->ts1.ts_packet_size  = mpeglinesize;\n\tdev->ts1.ts_packet_count = mpeglines;\n\t*num_planes = 1;\n\tsizes[0] = mpeglinesize * mpeglines;\n\t*num_buffers = mpegbufs;\n\treturn 0;\n}\n\nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx23885_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx23885_buffer *buf =\n\t\tcontainer_of(vbuf, struct cx23885_buffer, vb);\n\n\treturn cx23885_buf_prepare(buf, &dev->ts1);\n}\n\nstatic void buffer_finish(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx23885_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx23885_buffer *buf = container_of(vbuf,\n\t\tstruct cx23885_buffer, vb);\n\n\tcx23885_free_buffer(dev, buf);\n}\n\nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct cx23885_dev *dev = vb->vb2_queue->drv_priv;\n\tstruct cx23885_buffer   *buf = container_of(vbuf,\n\t\tstruct cx23885_buffer, vb);\n\n\tcx23885_buf_queue(&dev->ts1, buf);\n}\n\nstatic int cx23885_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct cx23885_dev *dev = q->drv_priv;\n\tstruct cx23885_dmaqueue *dmaq = &dev->ts1.mpegq;\n\tunsigned long flags;\n\tint ret;\n\n\tret = cx23885_initialize_codec(dev, 1);\n\tif (ret == 0) {\n\t\tstruct cx23885_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx23885_buffer, queue);\n\n\t\tcx23885_start_dma(&dev->ts1, dmaq, buf);\n\t\treturn 0;\n\t}\n\tspin_lock_irqsave(&dev->slock, flags);\n\twhile (!list_empty(&dmaq->active)) {\n\t\tstruct cx23885_buffer *buf = list_entry(dmaq->active.next,\n\t\t\tstruct cx23885_buffer, queue);\n\n\t\tlist_del(&buf->queue);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\treturn ret;\n}\n\nstatic void cx23885_stop_streaming(struct vb2_queue *q)\n{\n\tstruct cx23885_dev *dev = q->drv_priv;\n\n\t \n\tcx23885_api_cmd(dev, CX2341X_ENC_STOP_CAPTURE, 3, 0,\n\t\t\tCX23885_END_NOW, CX23885_MPEG_CAPTURE,\n\t\t\tCX23885_RAW_BITS_NONE);\n\n\tmsleep(500);\n\tcx23885_417_check_encoder(dev);\n\tcx23885_cancel_buffers(&dev->ts1);\n}\n\nstatic const struct vb2_ops cx23885_qops = {\n\t.queue_setup    = queue_setup,\n\t.buf_prepare  = buffer_prepare,\n\t.buf_finish = buffer_finish,\n\t.buf_queue    = buffer_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n\t.start_streaming = cx23885_start_streaming,\n\t.stop_streaming = cx23885_stop_streaming,\n};\n\n \n\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *id)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\t*id = dev->tvnorm;\n\treturn 0;\n}\n\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id id)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(cx23885_tvnorms); i++)\n\t\tif (id & cx23885_tvnorms[i].id)\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(cx23885_tvnorms))\n\t\treturn -EINVAL;\n\n\tret = cx23885_set_tvnorm(dev, id);\n\tif (!ret)\n\t\tdev->encodernorm = cx23885_tvnorms[i];\n\treturn ret;\n}\n\nstatic int vidioc_enum_input(struct file *file, void *priv,\n\tstruct v4l2_input *i)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\tdprintk(1, \"%s()\\n\", __func__);\n\treturn cx23885_enum_input(dev, i);\n}\n\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\treturn cx23885_get_input(file, priv, i);\n}\n\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\treturn cx23885_set_input(file, priv, i);\n}\n\nstatic int vidioc_g_tuner(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_tuner *t)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tif (dev->tuner_type == TUNER_ABSENT)\n\t\treturn -EINVAL;\n\tif (0 != t->index)\n\t\treturn -EINVAL;\n\tstrscpy(t->name, \"Television\", sizeof(t->name));\n\tcall_all(dev, tuner, g_tuner, t);\n\n\tdprintk(1, \"VIDIOC_G_TUNER: tuner type %d\\n\", t->type);\n\n\treturn 0;\n}\n\nstatic int vidioc_s_tuner(struct file *file, void *priv,\n\t\t\t\tconst struct v4l2_tuner *t)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tif (dev->tuner_type == TUNER_ABSENT)\n\t\treturn -EINVAL;\n\n\t \n\tcall_all(dev, tuner, s_tuner, t);\n\n\treturn 0;\n}\n\nstatic int vidioc_g_frequency(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_frequency *f)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tif (dev->tuner_type == TUNER_ABSENT)\n\t\treturn -EINVAL;\n\tf->type = V4L2_TUNER_ANALOG_TV;\n\tf->frequency = dev->freq;\n\n\tcall_all(dev, tuner, g_frequency, f);\n\n\treturn 0;\n}\n\nstatic int vidioc_s_frequency(struct file *file, void *priv,\n\tconst struct v4l2_frequency *f)\n{\n\treturn cx23885_set_frequency(file, priv, f);\n}\n\nstatic int vidioc_querycap(struct file *file, void  *priv,\n\t\t\t\tstruct v4l2_capability *cap)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\tstruct cx23885_tsport  *tsport = &dev->ts1;\n\n\tstrscpy(cap->driver, dev->name, sizeof(cap->driver));\n\tstrscpy(cap->card, cx23885_boards[tsport->dev->board].name,\n\t\tsizeof(cap->card));\n\tsprintf(cap->bus_info, \"PCIe:%s\", pci_name(dev->pci));\n\tcap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_STREAMING | V4L2_CAP_VBI_CAPTURE |\n\t\t\t    V4L2_CAP_AUDIO | V4L2_CAP_DEVICE_CAPS;\n\tif (dev->tuner_type != TUNER_ABSENT)\n\t\tcap->capabilities |= V4L2_CAP_TUNER;\n\n\treturn 0;\n}\n\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,\n\t\t\t\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index != 0)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_MPEG;\n\n\treturn 0;\n}\n\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tf->fmt.pix.pixelformat  = V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.bytesperline = 0;\n\tf->fmt.pix.sizeimage    =\n\t\tdev->ts1.ts_packet_size * dev->ts1.ts_packet_count;\n\tf->fmt.pix.colorspace   = 0;\n\tf->fmt.pix.width        = dev->ts1.width;\n\tf->fmt.pix.height       = dev->ts1.height;\n\tf->fmt.pix.field        = V4L2_FIELD_INTERLACED;\n\tdprintk(1, \"VIDIOC_G_FMT: w: %d, h: %d\\n\",\n\t\tdev->ts1.width, dev->ts1.height);\n\treturn 0;\n}\n\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tf->fmt.pix.pixelformat  = V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.bytesperline = 0;\n\tf->fmt.pix.sizeimage    =\n\t\tdev->ts1.ts_packet_size * dev->ts1.ts_packet_count;\n\tf->fmt.pix.colorspace   = 0;\n\tf->fmt.pix.field        = V4L2_FIELD_INTERLACED;\n\tdprintk(1, \"VIDIOC_TRY_FMT: w: %d, h: %d\\n\",\n\t\tdev->ts1.width, dev->ts1.height);\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *f)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\n\tf->fmt.pix.pixelformat  = V4L2_PIX_FMT_MPEG;\n\tf->fmt.pix.bytesperline = 0;\n\tf->fmt.pix.sizeimage    =\n\t\tdev->ts1.ts_packet_size * dev->ts1.ts_packet_count;\n\tf->fmt.pix.colorspace   = 0;\n\tf->fmt.pix.field        = V4L2_FIELD_INTERLACED;\n\tdprintk(1, \"VIDIOC_S_FMT: w: %d, h: %d, f: %d\\n\",\n\t\tf->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.field);\n\treturn 0;\n}\n\nstatic int vidioc_log_status(struct file *file, void *priv)\n{\n\tstruct cx23885_dev *dev = video_drvdata(file);\n\tchar name[32 + 2];\n\n\tsnprintf(name, sizeof(name), \"%s/2\", dev->name);\n\tcall_all(dev, core, log_status);\n\tv4l2_ctrl_handler_log_status(&dev->cxhdl.hdl, name);\n\treturn 0;\n}\n\nstatic const struct v4l2_file_operations mpeg_fops = {\n\t.owner\t       = THIS_MODULE,\n\t.open           = v4l2_fh_open,\n\t.release        = vb2_fop_release,\n\t.read           = vb2_fop_read,\n\t.poll\t\t= vb2_fop_poll,\n\t.unlocked_ioctl = video_ioctl2,\n\t.mmap           = vb2_fop_mmap,\n};\n\nstatic const struct v4l2_ioctl_ops mpeg_ioctl_ops = {\n\t.vidioc_g_std\t\t = vidioc_g_std,\n\t.vidioc_s_std\t\t = vidioc_s_std,\n\t.vidioc_enum_input\t = vidioc_enum_input,\n\t.vidioc_g_input\t\t = vidioc_g_input,\n\t.vidioc_s_input\t\t = vidioc_s_input,\n\t.vidioc_g_tuner\t\t = vidioc_g_tuner,\n\t.vidioc_s_tuner\t\t = vidioc_s_tuner,\n\t.vidioc_g_frequency\t = vidioc_g_frequency,\n\t.vidioc_s_frequency\t = vidioc_s_frequency,\n\t.vidioc_querycap\t = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap\t = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap\t = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap\t = vidioc_s_fmt_vid_cap,\n\t.vidioc_reqbufs       = vb2_ioctl_reqbufs,\n\t.vidioc_prepare_buf   = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf      = vb2_ioctl_querybuf,\n\t.vidioc_qbuf          = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf         = vb2_ioctl_dqbuf,\n\t.vidioc_streamon      = vb2_ioctl_streamon,\n\t.vidioc_streamoff     = vb2_ioctl_streamoff,\n\t.vidioc_log_status\t = vidioc_log_status,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_chip_info\t = cx23885_g_chip_info,\n\t.vidioc_g_register\t = cx23885_g_register,\n\t.vidioc_s_register\t = cx23885_s_register,\n#endif\n};\n\nstatic struct video_device cx23885_mpeg_template = {\n\t.name          = \"cx23885\",\n\t.fops          = &mpeg_fops,\n\t.ioctl_ops     = &mpeg_ioctl_ops,\n\t.tvnorms       = CX23885_NORMS,\n};\n\nvoid cx23885_417_unregister(struct cx23885_dev *dev)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (dev->v4l_device) {\n\t\tif (video_is_registered(dev->v4l_device))\n\t\t\tvideo_unregister_device(dev->v4l_device);\n\t\telse\n\t\t\tvideo_device_release(dev->v4l_device);\n\t\tv4l2_ctrl_handler_free(&dev->cxhdl.hdl);\n\t\tdev->v4l_device = NULL;\n\t}\n}\n\nstatic struct video_device *cx23885_video_dev_alloc(\n\tstruct cx23885_tsport *tsport,\n\tstruct pci_dev *pci,\n\tstruct video_device *template,\n\tchar *type)\n{\n\tstruct video_device *vfd;\n\tstruct cx23885_dev *dev = tsport->dev;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tvfd = video_device_alloc();\n\tif (NULL == vfd)\n\t\treturn NULL;\n\t*vfd = *template;\n\tsnprintf(vfd->name, sizeof(vfd->name), \"%s (%s)\",\n\t\tcx23885_boards[tsport->dev->board].name, type);\n\tvfd->v4l2_dev = &dev->v4l2_dev;\n\tvfd->release = video_device_release;\n\treturn vfd;\n}\n\nint cx23885_417_register(struct cx23885_dev *dev)\n{\n\t \n\tint err = -ENODEV;\n\tstruct cx23885_tsport *tsport = &dev->ts1;\n\tstruct vb2_queue *q;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tif (cx23885_boards[dev->board].portb != CX23885_MPEG_ENCODER)\n\t\treturn err;\n\n\t \n\tdev->encodernorm = cx23885_tvnorms[0];\n\n\tif (dev->encodernorm.id & V4L2_STD_525_60)\n\t\ttsport->height = 480;\n\telse\n\t\ttsport->height = 576;\n\n\ttsport->width = 720;\n\tdev->cxhdl.port = CX2341X_PORT_SERIAL;\n\terr = cx2341x_handler_init(&dev->cxhdl, 50);\n\tif (err)\n\t\treturn err;\n\tdev->cxhdl.priv = dev;\n\tdev->cxhdl.func = cx23885_api_func;\n\tcx2341x_handler_set_50hz(&dev->cxhdl, tsport->height == 576);\n\tv4l2_ctrl_add_handler(&dev->ctrl_handler, &dev->cxhdl.hdl, NULL, false);\n\n\t \n\tdev->v4l_device = cx23885_video_dev_alloc(tsport,\n\t\tdev->pci, &cx23885_mpeg_template, \"mpeg\");\n\tq = &dev->vb2_mpegq;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\n\tq->gfp_flags = GFP_DMA32;\n\tq->min_buffers_needed = 2;\n\tq->drv_priv = dev;\n\tq->buf_struct_size = sizeof(struct cx23885_buffer);\n\tq->ops = &cx23885_qops;\n\tq->mem_ops = &vb2_dma_sg_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tq->lock = &dev->lock;\n\tq->dev = &dev->pci->dev;\n\n\terr = vb2_queue_init(q);\n\tif (err < 0)\n\t\treturn err;\n\tvideo_set_drvdata(dev->v4l_device, dev);\n\tdev->v4l_device->lock = &dev->lock;\n\tdev->v4l_device->queue = q;\n\tdev->v4l_device->device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t\t       V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\n\tif (dev->tuner_type != TUNER_ABSENT)\n\t\tdev->v4l_device->device_caps |= V4L2_CAP_TUNER;\n\terr = video_register_device(dev->v4l_device,\n\t\tVFL_TYPE_VIDEO, -1);\n\tif (err < 0) {\n\t\tpr_info(\"%s: can't register mpeg device\\n\", dev->name);\n\t\treturn err;\n\t}\n\n\tpr_info(\"%s: registered device %s [mpeg]\\n\",\n\t       dev->name, video_device_node_name(dev->v4l_device));\n\n\t \n\tcx23885_initialize_codec(dev, 0);\n\n\treturn 0;\n}\n\nMODULE_FIRMWARE(CX23885_FIRM_IMAGE_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}