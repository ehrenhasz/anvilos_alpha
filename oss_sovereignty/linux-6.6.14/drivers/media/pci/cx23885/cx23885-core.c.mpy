{
  "module_name": "cx23885-core.c",
  "hash_id": "0ece70a150ae1e44435390b7ccbac6a9b851d37dcb3d2776b9586cf7d60bde6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx23885/cx23885-core.c",
  "human_readable_source": "\n \n\n#include \"cx23885.h\"\n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <asm/div64.h>\n#include <linux/firmware.h>\n\n#include \"cimax2.h\"\n#include \"altera-ci.h\"\n#include \"cx23888-ir.h\"\n#include \"cx23885-ir.h\"\n#include \"cx23885-av.h\"\n#include \"cx23885-input.h\"\n\nMODULE_DESCRIPTION(\"Driver for cx23885 based TV cards\");\nMODULE_AUTHOR(\"Steven Toth <stoth@linuxtv.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(CX23885_VERSION);\n\n \nstatic unsigned int dma_reset_workaround = 1;\nmodule_param(dma_reset_workaround, int, 0644);\nMODULE_PARM_DESC(dma_reset_workaround, \"periodic RiSC dma engine reset; 0-force disable, 1-driver detect (default), 2-force enable\");\n\nstatic unsigned int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"enable debug messages\");\n\nstatic unsigned int card[]  = {[0 ... (CX23885_MAXBOARDS - 1)] = UNSET };\nmodule_param_array(card,  int, NULL, 0444);\nMODULE_PARM_DESC(card, \"card type\");\n\n#define dprintk(level, fmt, arg...)\\\n\tdo { if (debug >= level)\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt), \\\n\t\t       __func__, ##arg); \\\n\t} while (0)\n\nstatic unsigned int cx23885_devcount;\n\n#define NO_SYNC_LINE (-1U)\n\n \n\nstatic struct sram_channel cx23885_sram_channels[] = {\n\t[SRAM_CH01] = {\n\t\t.name\t\t= \"VID A\",\n\t\t.cmds_start\t= 0x10000,\n\t\t.ctrl_start\t= 0x10380,\n\t\t.cdt\t\t= 0x104c0,\n\t\t.fifo_start\t= 0x40,\n\t\t.fifo_size\t= 0x2800,\n\t\t.ptr1_reg\t= DMA1_PTR1,\n\t\t.ptr2_reg\t= DMA1_PTR2,\n\t\t.cnt1_reg\t= DMA1_CNT1,\n\t\t.cnt2_reg\t= DMA1_CNT2,\n\t},\n\t[SRAM_CH02] = {\n\t\t.name\t\t= \"ch2\",\n\t\t.cmds_start\t= 0x0,\n\t\t.ctrl_start\t= 0x0,\n\t\t.cdt\t\t= 0x0,\n\t\t.fifo_start\t= 0x0,\n\t\t.fifo_size\t= 0x0,\n\t\t.ptr1_reg\t= DMA2_PTR1,\n\t\t.ptr2_reg\t= DMA2_PTR2,\n\t\t.cnt1_reg\t= DMA2_CNT1,\n\t\t.cnt2_reg\t= DMA2_CNT2,\n\t},\n\t[SRAM_CH03] = {\n\t\t.name\t\t= \"TS1 B\",\n\t\t.cmds_start\t= 0x100A0,\n\t\t.ctrl_start\t= 0x10400,\n\t\t.cdt\t\t= 0x10580,\n\t\t.fifo_start\t= 0x5000,\n\t\t.fifo_size\t= 0x1000,\n\t\t.ptr1_reg\t= DMA3_PTR1,\n\t\t.ptr2_reg\t= DMA3_PTR2,\n\t\t.cnt1_reg\t= DMA3_CNT1,\n\t\t.cnt2_reg\t= DMA3_CNT2,\n\t},\n\t[SRAM_CH04] = {\n\t\t.name\t\t= \"ch4\",\n\t\t.cmds_start\t= 0x0,\n\t\t.ctrl_start\t= 0x0,\n\t\t.cdt\t\t= 0x0,\n\t\t.fifo_start\t= 0x0,\n\t\t.fifo_size\t= 0x0,\n\t\t.ptr1_reg\t= DMA4_PTR1,\n\t\t.ptr2_reg\t= DMA4_PTR2,\n\t\t.cnt1_reg\t= DMA4_CNT1,\n\t\t.cnt2_reg\t= DMA4_CNT2,\n\t},\n\t[SRAM_CH05] = {\n\t\t.name\t\t= \"ch5\",\n\t\t.cmds_start\t= 0x0,\n\t\t.ctrl_start\t= 0x0,\n\t\t.cdt\t\t= 0x0,\n\t\t.fifo_start\t= 0x0,\n\t\t.fifo_size\t= 0x0,\n\t\t.ptr1_reg\t= DMA5_PTR1,\n\t\t.ptr2_reg\t= DMA5_PTR2,\n\t\t.cnt1_reg\t= DMA5_CNT1,\n\t\t.cnt2_reg\t= DMA5_CNT2,\n\t},\n\t[SRAM_CH06] = {\n\t\t.name\t\t= \"TS2 C\",\n\t\t.cmds_start\t= 0x10140,\n\t\t.ctrl_start\t= 0x10440,\n\t\t.cdt\t\t= 0x105e0,\n\t\t.fifo_start\t= 0x6000,\n\t\t.fifo_size\t= 0x1000,\n\t\t.ptr1_reg\t= DMA5_PTR1,\n\t\t.ptr2_reg\t= DMA5_PTR2,\n\t\t.cnt1_reg\t= DMA5_CNT1,\n\t\t.cnt2_reg\t= DMA5_CNT2,\n\t},\n\t[SRAM_CH07] = {\n\t\t.name\t\t= \"TV Audio\",\n\t\t.cmds_start\t= 0x10190,\n\t\t.ctrl_start\t= 0x10480,\n\t\t.cdt\t\t= 0x10a00,\n\t\t.fifo_start\t= 0x7000,\n\t\t.fifo_size\t= 0x1000,\n\t\t.ptr1_reg\t= DMA6_PTR1,\n\t\t.ptr2_reg\t= DMA6_PTR2,\n\t\t.cnt1_reg\t= DMA6_CNT1,\n\t\t.cnt2_reg\t= DMA6_CNT2,\n\t},\n\t[SRAM_CH08] = {\n\t\t.name\t\t= \"ch8\",\n\t\t.cmds_start\t= 0x0,\n\t\t.ctrl_start\t= 0x0,\n\t\t.cdt\t\t= 0x0,\n\t\t.fifo_start\t= 0x0,\n\t\t.fifo_size\t= 0x0,\n\t\t.ptr1_reg\t= DMA7_PTR1,\n\t\t.ptr2_reg\t= DMA7_PTR2,\n\t\t.cnt1_reg\t= DMA7_CNT1,\n\t\t.cnt2_reg\t= DMA7_CNT2,\n\t},\n\t[SRAM_CH09] = {\n\t\t.name\t\t= \"ch9\",\n\t\t.cmds_start\t= 0x0,\n\t\t.ctrl_start\t= 0x0,\n\t\t.cdt\t\t= 0x0,\n\t\t.fifo_start\t= 0x0,\n\t\t.fifo_size\t= 0x0,\n\t\t.ptr1_reg\t= DMA8_PTR1,\n\t\t.ptr2_reg\t= DMA8_PTR2,\n\t\t.cnt1_reg\t= DMA8_CNT1,\n\t\t.cnt2_reg\t= DMA8_CNT2,\n\t},\n};\n\nstatic struct sram_channel cx23887_sram_channels[] = {\n\t[SRAM_CH01] = {\n\t\t.name\t\t= \"VID A\",\n\t\t.cmds_start\t= 0x10000,\n\t\t.ctrl_start\t= 0x105b0,\n\t\t.cdt\t\t= 0x107b0,\n\t\t.fifo_start\t= 0x40,\n\t\t.fifo_size\t= 0x2800,\n\t\t.ptr1_reg\t= DMA1_PTR1,\n\t\t.ptr2_reg\t= DMA1_PTR2,\n\t\t.cnt1_reg\t= DMA1_CNT1,\n\t\t.cnt2_reg\t= DMA1_CNT2,\n\t},\n\t[SRAM_CH02] = {\n\t\t.name\t\t= \"VID A (VBI)\",\n\t\t.cmds_start\t= 0x10050,\n\t\t.ctrl_start\t= 0x105F0,\n\t\t.cdt\t\t= 0x10810,\n\t\t.fifo_start\t= 0x3000,\n\t\t.fifo_size\t= 0x1000,\n\t\t.ptr1_reg\t= DMA2_PTR1,\n\t\t.ptr2_reg\t= DMA2_PTR2,\n\t\t.cnt1_reg\t= DMA2_CNT1,\n\t\t.cnt2_reg\t= DMA2_CNT2,\n\t},\n\t[SRAM_CH03] = {\n\t\t.name\t\t= \"TS1 B\",\n\t\t.cmds_start\t= 0x100A0,\n\t\t.ctrl_start\t= 0x10630,\n\t\t.cdt\t\t= 0x10870,\n\t\t.fifo_start\t= 0x5000,\n\t\t.fifo_size\t= 0x1000,\n\t\t.ptr1_reg\t= DMA3_PTR1,\n\t\t.ptr2_reg\t= DMA3_PTR2,\n\t\t.cnt1_reg\t= DMA3_CNT1,\n\t\t.cnt2_reg\t= DMA3_CNT2,\n\t},\n\t[SRAM_CH04] = {\n\t\t.name\t\t= \"ch4\",\n\t\t.cmds_start\t= 0x0,\n\t\t.ctrl_start\t= 0x0,\n\t\t.cdt\t\t= 0x0,\n\t\t.fifo_start\t= 0x0,\n\t\t.fifo_size\t= 0x0,\n\t\t.ptr1_reg\t= DMA4_PTR1,\n\t\t.ptr2_reg\t= DMA4_PTR2,\n\t\t.cnt1_reg\t= DMA4_CNT1,\n\t\t.cnt2_reg\t= DMA4_CNT2,\n\t},\n\t[SRAM_CH05] = {\n\t\t.name\t\t= \"ch5\",\n\t\t.cmds_start\t= 0x0,\n\t\t.ctrl_start\t= 0x0,\n\t\t.cdt\t\t= 0x0,\n\t\t.fifo_start\t= 0x0,\n\t\t.fifo_size\t= 0x0,\n\t\t.ptr1_reg\t= DMA5_PTR1,\n\t\t.ptr2_reg\t= DMA5_PTR2,\n\t\t.cnt1_reg\t= DMA5_CNT1,\n\t\t.cnt2_reg\t= DMA5_CNT2,\n\t},\n\t[SRAM_CH06] = {\n\t\t.name\t\t= \"TS2 C\",\n\t\t.cmds_start\t= 0x10140,\n\t\t.ctrl_start\t= 0x10670,\n\t\t.cdt\t\t= 0x108d0,\n\t\t.fifo_start\t= 0x6000,\n\t\t.fifo_size\t= 0x1000,\n\t\t.ptr1_reg\t= DMA5_PTR1,\n\t\t.ptr2_reg\t= DMA5_PTR2,\n\t\t.cnt1_reg\t= DMA5_CNT1,\n\t\t.cnt2_reg\t= DMA5_CNT2,\n\t},\n\t[SRAM_CH07] = {\n\t\t.name\t\t= \"TV Audio\",\n\t\t.cmds_start\t= 0x10190,\n\t\t.ctrl_start\t= 0x106B0,\n\t\t.cdt\t\t= 0x10930,\n\t\t.fifo_start\t= 0x7000,\n\t\t.fifo_size\t= 0x1000,\n\t\t.ptr1_reg\t= DMA6_PTR1,\n\t\t.ptr2_reg\t= DMA6_PTR2,\n\t\t.cnt1_reg\t= DMA6_CNT1,\n\t\t.cnt2_reg\t= DMA6_CNT2,\n\t},\n\t[SRAM_CH08] = {\n\t\t.name\t\t= \"ch8\",\n\t\t.cmds_start\t= 0x0,\n\t\t.ctrl_start\t= 0x0,\n\t\t.cdt\t\t= 0x0,\n\t\t.fifo_start\t= 0x0,\n\t\t.fifo_size\t= 0x0,\n\t\t.ptr1_reg\t= DMA7_PTR1,\n\t\t.ptr2_reg\t= DMA7_PTR2,\n\t\t.cnt1_reg\t= DMA7_CNT1,\n\t\t.cnt2_reg\t= DMA7_CNT2,\n\t},\n\t[SRAM_CH09] = {\n\t\t.name\t\t= \"ch9\",\n\t\t.cmds_start\t= 0x0,\n\t\t.ctrl_start\t= 0x0,\n\t\t.cdt\t\t= 0x0,\n\t\t.fifo_start\t= 0x0,\n\t\t.fifo_size\t= 0x0,\n\t\t.ptr1_reg\t= DMA8_PTR1,\n\t\t.ptr2_reg\t= DMA8_PTR2,\n\t\t.cnt1_reg\t= DMA8_CNT1,\n\t\t.cnt2_reg\t= DMA8_CNT2,\n\t},\n};\n\nstatic void cx23885_irq_add(struct cx23885_dev *dev, u32 mask)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->pci_irqmask_lock, flags);\n\n\tdev->pci_irqmask |= mask;\n\n\tspin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);\n}\n\nvoid cx23885_irq_add_enable(struct cx23885_dev *dev, u32 mask)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->pci_irqmask_lock, flags);\n\n\tdev->pci_irqmask |= mask;\n\tcx_set(PCI_INT_MSK, mask);\n\n\tspin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);\n}\n\nvoid cx23885_irq_enable(struct cx23885_dev *dev, u32 mask)\n{\n\tu32 v;\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->pci_irqmask_lock, flags);\n\n\tv = mask & dev->pci_irqmask;\n\tif (v)\n\t\tcx_set(PCI_INT_MSK, v);\n\n\tspin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);\n}\n\nstatic inline void cx23885_irq_enable_all(struct cx23885_dev *dev)\n{\n\tcx23885_irq_enable(dev, 0xffffffff);\n}\n\nvoid cx23885_irq_disable(struct cx23885_dev *dev, u32 mask)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->pci_irqmask_lock, flags);\n\n\tcx_clear(PCI_INT_MSK, mask);\n\n\tspin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);\n}\n\nstatic inline void cx23885_irq_disable_all(struct cx23885_dev *dev)\n{\n\tcx23885_irq_disable(dev, 0xffffffff);\n}\n\nvoid cx23885_irq_remove(struct cx23885_dev *dev, u32 mask)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->pci_irqmask_lock, flags);\n\n\tdev->pci_irqmask &= ~mask;\n\tcx_clear(PCI_INT_MSK, mask);\n\n\tspin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);\n}\n\nstatic u32 cx23885_irq_get_mask(struct cx23885_dev *dev)\n{\n\tu32 v;\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->pci_irqmask_lock, flags);\n\n\tv = cx_read(PCI_INT_MSK);\n\n\tspin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);\n\treturn v;\n}\n\nstatic int cx23885_risc_decode(u32 risc)\n{\n\tstatic char *instr[16] = {\n\t\t[RISC_SYNC    >> 28] = \"sync\",\n\t\t[RISC_WRITE   >> 28] = \"write\",\n\t\t[RISC_WRITEC  >> 28] = \"writec\",\n\t\t[RISC_READ    >> 28] = \"read\",\n\t\t[RISC_READC   >> 28] = \"readc\",\n\t\t[RISC_JUMP    >> 28] = \"jump\",\n\t\t[RISC_SKIP    >> 28] = \"skip\",\n\t\t[RISC_WRITERM >> 28] = \"writerm\",\n\t\t[RISC_WRITECM >> 28] = \"writecm\",\n\t\t[RISC_WRITECR >> 28] = \"writecr\",\n\t};\n\tstatic int incr[16] = {\n\t\t[RISC_WRITE   >> 28] = 3,\n\t\t[RISC_JUMP    >> 28] = 3,\n\t\t[RISC_SKIP    >> 28] = 1,\n\t\t[RISC_SYNC    >> 28] = 1,\n\t\t[RISC_WRITERM >> 28] = 3,\n\t\t[RISC_WRITECM >> 28] = 3,\n\t\t[RISC_WRITECR >> 28] = 4,\n\t};\n\tstatic char *bits[] = {\n\t\t\"12\",   \"13\",   \"14\",   \"resync\",\n\t\t\"cnt0\", \"cnt1\", \"18\",   \"19\",\n\t\t\"20\",   \"21\",   \"22\",   \"23\",\n\t\t\"irq1\", \"irq2\", \"eol\",  \"sol\",\n\t};\n\tint i;\n\n\tprintk(KERN_DEBUG \"0x%08x [ %s\", risc,\n\t       instr[risc >> 28] ? instr[risc >> 28] : \"INVALID\");\n\tfor (i = ARRAY_SIZE(bits) - 1; i >= 0; i--)\n\t\tif (risc & (1 << (i + 12)))\n\t\t\tpr_cont(\" %s\", bits[i]);\n\tpr_cont(\" count=%d ]\\n\", risc & 0xfff);\n\treturn incr[risc >> 28] ? incr[risc >> 28] : 1;\n}\n\nstatic void cx23885_wakeup(struct cx23885_tsport *port,\n\t\t\t   struct cx23885_dmaqueue *q, u32 count)\n{\n\tstruct cx23885_buffer *buf;\n\tint count_delta;\n\tint max_buf_done = 5;  \n\n\tdo {\n\t\tif (list_empty(&q->active))\n\t\t\treturn;\n\t\tbuf = list_entry(q->active.next,\n\t\t\t\t struct cx23885_buffer, queue);\n\n\t\tbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tbuf->vb.sequence = q->count++;\n\t\tif (count != (q->count % 65536)) {\n\t\t\tdprintk(1, \"[%p/%d] wakeup reg=%d buf=%d\\n\", buf,\n\t\t\t\tbuf->vb.vb2_buf.index, count, q->count);\n\t\t} else {\n\t\t\tdprintk(7, \"[%p/%d] wakeup reg=%d buf=%d\\n\", buf,\n\t\t\t\tbuf->vb.vb2_buf.index, count, q->count);\n\t\t}\n\t\tlist_del(&buf->queue);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t\tmax_buf_done--;\n\t\t \n\t\tcount_delta = ((int)count - (int)(q->count % 65536));\n\t} while ((count_delta > 0) && (max_buf_done > 0));\n}\n\nint cx23885_sram_channel_setup(struct cx23885_dev *dev,\n\t\t\t\t      struct sram_channel *ch,\n\t\t\t\t      unsigned int bpl, u32 risc)\n{\n\tunsigned int i, lines;\n\tu32 cdt;\n\n\tif (ch->cmds_start == 0) {\n\t\tdprintk(1, \"%s() Erasing channel [%s]\\n\", __func__,\n\t\t\tch->name);\n\t\tcx_write(ch->ptr1_reg, 0);\n\t\tcx_write(ch->ptr2_reg, 0);\n\t\tcx_write(ch->cnt2_reg, 0);\n\t\tcx_write(ch->cnt1_reg, 0);\n\t\treturn 0;\n\t} else {\n\t\tdprintk(1, \"%s() Configuring channel [%s]\\n\", __func__,\n\t\t\tch->name);\n\t}\n\n\tbpl   = (bpl + 7) & ~7;  \n\tcdt   = ch->cdt;\n\tlines = ch->fifo_size / bpl;\n\tif (lines > 6)\n\t\tlines = 6;\n\tBUG_ON(lines < 2);\n\n\tcx_write(8 + 0, RISC_JUMP | RISC_CNT_RESET);\n\tcx_write(8 + 4, 12);\n\tcx_write(8 + 8, 0);\n\n\t \n\tfor (i = 0; i < lines; i++) {\n\t\tdprintk(2, \"%s() 0x%08x <- 0x%08x\\n\", __func__, cdt + 16*i,\n\t\t\tch->fifo_start + bpl*i);\n\t\tcx_write(cdt + 16*i, ch->fifo_start + bpl*i);\n\t\tcx_write(cdt + 16*i +  4, 0);\n\t\tcx_write(cdt + 16*i +  8, 0);\n\t\tcx_write(cdt + 16*i + 12, 0);\n\t}\n\n\t \n\tif (ch->jumponly)\n\t\tcx_write(ch->cmds_start + 0, 8);\n\telse\n\t\tcx_write(ch->cmds_start + 0, risc);\n\tcx_write(ch->cmds_start +  4, 0);  \n\tcx_write(ch->cmds_start +  8, cdt);\n\tcx_write(ch->cmds_start + 12, (lines*16) >> 3);\n\tcx_write(ch->cmds_start + 16, ch->ctrl_start);\n\tif (ch->jumponly)\n\t\tcx_write(ch->cmds_start + 20, 0x80000000 | (64 >> 2));\n\telse\n\t\tcx_write(ch->cmds_start + 20, 64 >> 2);\n\tfor (i = 24; i < 80; i += 4)\n\t\tcx_write(ch->cmds_start + i, 0);\n\n\t \n\tcx_write(ch->ptr1_reg, ch->fifo_start);\n\tcx_write(ch->ptr2_reg, cdt);\n\tcx_write(ch->cnt2_reg, (lines*16) >> 3);\n\tcx_write(ch->cnt1_reg, (bpl >> 3) - 1);\n\n\tdprintk(2, \"[bridge %d] sram setup %s: bpl=%d lines=%d\\n\",\n\t\tdev->bridge,\n\t\tch->name,\n\t\tbpl,\n\t\tlines);\n\n\treturn 0;\n}\n\nvoid cx23885_sram_channel_dump(struct cx23885_dev *dev,\n\t\t\t\t      struct sram_channel *ch)\n{\n\tstatic char *name[] = {\n\t\t\"init risc lo\",\n\t\t\"init risc hi\",\n\t\t\"cdt base\",\n\t\t\"cdt size\",\n\t\t\"iq base\",\n\t\t\"iq size\",\n\t\t\"risc pc lo\",\n\t\t\"risc pc hi\",\n\t\t\"iq wr ptr\",\n\t\t\"iq rd ptr\",\n\t\t\"cdt current\",\n\t\t\"pci target lo\",\n\t\t\"pci target hi\",\n\t\t\"line / byte\",\n\t};\n\tu32 risc;\n\tunsigned int i, j, n;\n\n\tpr_warn(\"%s: %s - dma channel status dump\\n\",\n\t\tdev->name, ch->name);\n\tfor (i = 0; i < ARRAY_SIZE(name); i++)\n\t\tpr_warn(\"%s:   cmds: %-15s: 0x%08x\\n\",\n\t\t\tdev->name, name[i],\n\t\t\tcx_read(ch->cmds_start + 4*i));\n\n\tfor (i = 0; i < 4; i++) {\n\t\trisc = cx_read(ch->cmds_start + 4 * (i + 14));\n\t\tpr_warn(\"%s:   risc%d:\", dev->name, i);\n\t\tcx23885_risc_decode(risc);\n\t}\n\tfor (i = 0; i < (64 >> 2); i += n) {\n\t\trisc = cx_read(ch->ctrl_start + 4 * i);\n\t\t \n\n\t\tpr_warn(\"%s:   (0x%08x) iq %x:\", dev->name,\n\t\t\tch->ctrl_start + 4 * i, i);\n\t\tn = cx23885_risc_decode(risc);\n\t\tfor (j = 1; j < n; j++) {\n\t\t\trisc = cx_read(ch->ctrl_start + 4 * (i + j));\n\t\t\tpr_warn(\"%s:   iq %x: 0x%08x [ arg #%d ]\\n\",\n\t\t\t\tdev->name, i+j, risc, j);\n\t\t}\n\t}\n\n\tpr_warn(\"%s: fifo: 0x%08x -> 0x%x\\n\",\n\t\tdev->name, ch->fifo_start, ch->fifo_start+ch->fifo_size);\n\tpr_warn(\"%s: ctrl: 0x%08x -> 0x%x\\n\",\n\t\tdev->name, ch->ctrl_start, ch->ctrl_start + 6*16);\n\tpr_warn(\"%s:   ptr1_reg: 0x%08x\\n\",\n\t\tdev->name, cx_read(ch->ptr1_reg));\n\tpr_warn(\"%s:   ptr2_reg: 0x%08x\\n\",\n\t\tdev->name, cx_read(ch->ptr2_reg));\n\tpr_warn(\"%s:   cnt1_reg: 0x%08x\\n\",\n\t\tdev->name, cx_read(ch->cnt1_reg));\n\tpr_warn(\"%s:   cnt2_reg: 0x%08x\\n\",\n\t\tdev->name, cx_read(ch->cnt2_reg));\n}\n\nstatic void cx23885_risc_disasm(struct cx23885_tsport *port,\n\t\t\t\tstruct cx23885_riscmem *risc)\n{\n\tstruct cx23885_dev *dev = port->dev;\n\tunsigned int i, j, n;\n\n\tpr_info(\"%s: risc disasm: %p [dma=0x%08lx]\\n\",\n\t       dev->name, risc->cpu, (unsigned long)risc->dma);\n\tfor (i = 0; i < (risc->size >> 2); i += n) {\n\t\tpr_info(\"%s:   %04d:\", dev->name, i);\n\t\tn = cx23885_risc_decode(le32_to_cpu(risc->cpu[i]));\n\t\tfor (j = 1; j < n; j++)\n\t\t\tpr_info(\"%s:   %04d: 0x%08x [ arg #%d ]\\n\",\n\t\t\t\tdev->name, i + j, risc->cpu[i + j], j);\n\t\tif (risc->cpu[i] == cpu_to_le32(RISC_JUMP))\n\t\t\tbreak;\n\t}\n}\n\nstatic void cx23885_clear_bridge_error(struct cx23885_dev *dev)\n{\n\tuint32_t reg1_val, reg2_val;\n\n\tif (!dev->need_dma_reset)\n\t\treturn;\n\n\treg1_val = cx_read(TC_REQ);  \n\treg2_val = cx_read(TC_REQ_SET);\n\n\tif (reg1_val && reg2_val) {\n\t\tcx_write(TC_REQ, reg1_val);\n\t\tcx_write(TC_REQ_SET, reg2_val);\n\t\tcx_read(VID_B_DMA);\n\t\tcx_read(VBI_B_DMA);\n\t\tcx_read(VID_C_DMA);\n\t\tcx_read(VBI_C_DMA);\n\n\t\tdev_info(&dev->pci->dev,\n\t\t\t\"dma in progress detected 0x%08x 0x%08x, clearing\\n\",\n\t\t\treg1_val, reg2_val);\n\t}\n}\n\nstatic void cx23885_shutdown(struct cx23885_dev *dev)\n{\n\t \n\tcx_write(DEV_CNTRL2, 0);\n\n\t \n\tcx_write(IR_CNTRL_REG, 0);\n\n\t \n\tcx_write(VID_A_DMA_CTL, 0);\n\tcx_write(VID_B_DMA_CTL, 0);\n\tcx_write(VID_C_DMA_CTL, 0);\n\n\t \n\tcx_write(AUD_INT_DMA_CTL, 0);\n\tcx_write(AUD_EXT_DMA_CTL, 0);\n\n\t \n\tcx_write(UART_CTL, 0);\n\n\t \n\tcx23885_irq_disable_all(dev);\n\tcx_write(VID_A_INT_MSK, 0);\n\tcx_write(VID_B_INT_MSK, 0);\n\tcx_write(VID_C_INT_MSK, 0);\n\tcx_write(AUDIO_INT_INT_MSK, 0);\n\tcx_write(AUDIO_EXT_INT_MSK, 0);\n\n}\n\nstatic void cx23885_reset(struct cx23885_dev *dev)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\tcx23885_shutdown(dev);\n\n\tcx_write(PCI_INT_STAT, 0xffffffff);\n\tcx_write(VID_A_INT_STAT, 0xffffffff);\n\tcx_write(VID_B_INT_STAT, 0xffffffff);\n\tcx_write(VID_C_INT_STAT, 0xffffffff);\n\tcx_write(AUDIO_INT_INT_STAT, 0xffffffff);\n\tcx_write(AUDIO_EXT_INT_STAT, 0xffffffff);\n\tcx_write(CLK_DELAY, cx_read(CLK_DELAY) & 0x80000000);\n\tcx_write(PAD_CTRL, 0x00500300);\n\n\t \n\tcx23885_clear_bridge_error(dev);\n\tmsleep(100);\n\n\tcx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH01],\n\t\t720*4, 0);\n\tcx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH02], 128, 0);\n\tcx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH03],\n\t\t188*4, 0);\n\tcx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH04], 128, 0);\n\tcx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH05], 128, 0);\n\tcx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH06],\n\t\t188*4, 0);\n\tcx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH07], 128, 0);\n\tcx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH08], 128, 0);\n\tcx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH09], 128, 0);\n\n\tcx23885_gpio_setup(dev);\n\n\tcx23885_irq_get_mask(dev);\n\n\t \n\tcx23885_clear_bridge_error(dev);\n}\n\n\nstatic int cx23885_pci_quirks(struct cx23885_dev *dev)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tif (dev->bridge == CX23885_BRIDGE_885)\n\t\tcx_clear(RDR_TLCTL0, 1 << 4);\n\n\t \n\tcx23885_clear_bridge_error(dev);\n\treturn 0;\n}\n\nstatic int get_resources(struct cx23885_dev *dev)\n{\n\tif (request_mem_region(pci_resource_start(dev->pci, 0),\n\t\t\t       pci_resource_len(dev->pci, 0),\n\t\t\t       dev->name))\n\t\treturn 0;\n\n\tpr_err(\"%s: can't get MMIO memory @ 0x%llx\\n\",\n\t       dev->name, (unsigned long long)pci_resource_start(dev->pci, 0));\n\n\treturn -EBUSY;\n}\n\nstatic int cx23885_init_tsport(struct cx23885_dev *dev,\n\tstruct cx23885_tsport *port, int portno)\n{\n\tdprintk(1, \"%s(portno=%d)\\n\", __func__, portno);\n\n\t \n\tport->dma_ctl_val        = 0x11;  \n\tport->ts_int_msk_val     = 0x1111;  \n\tport->vld_misc_val       = 0x0;\n\tport->hw_sop_ctrl_val    = (0x47 << 16 | 188 << 4);\n\n\tspin_lock_init(&port->slock);\n\tport->dev = dev;\n\tport->nr = portno;\n\n\tINIT_LIST_HEAD(&port->mpegq.active);\n\tmutex_init(&port->frontends.lock);\n\tINIT_LIST_HEAD(&port->frontends.felist);\n\tport->frontends.active_fe_id = 0;\n\n\t \n\tif (!port->num_frontends)\n\t\tport->num_frontends = 1;\n\n\tswitch (portno) {\n\tcase 1:\n\t\tport->reg_gpcnt          = VID_B_GPCNT;\n\t\tport->reg_gpcnt_ctl      = VID_B_GPCNT_CTL;\n\t\tport->reg_dma_ctl        = VID_B_DMA_CTL;\n\t\tport->reg_lngth          = VID_B_LNGTH;\n\t\tport->reg_hw_sop_ctrl    = VID_B_HW_SOP_CTL;\n\t\tport->reg_gen_ctrl       = VID_B_GEN_CTL;\n\t\tport->reg_bd_pkt_status  = VID_B_BD_PKT_STATUS;\n\t\tport->reg_sop_status     = VID_B_SOP_STATUS;\n\t\tport->reg_fifo_ovfl_stat = VID_B_FIFO_OVFL_STAT;\n\t\tport->reg_vld_misc       = VID_B_VLD_MISC;\n\t\tport->reg_ts_clk_en      = VID_B_TS_CLK_EN;\n\t\tport->reg_src_sel        = VID_B_SRC_SEL;\n\t\tport->reg_ts_int_msk     = VID_B_INT_MSK;\n\t\tport->reg_ts_int_stat    = VID_B_INT_STAT;\n\t\tport->sram_chno          = SRAM_CH03;  \n\t\tport->pci_irqmask        = 0x02;  \n\t\tbreak;\n\tcase 2:\n\t\tport->reg_gpcnt          = VID_C_GPCNT;\n\t\tport->reg_gpcnt_ctl      = VID_C_GPCNT_CTL;\n\t\tport->reg_dma_ctl        = VID_C_DMA_CTL;\n\t\tport->reg_lngth          = VID_C_LNGTH;\n\t\tport->reg_hw_sop_ctrl    = VID_C_HW_SOP_CTL;\n\t\tport->reg_gen_ctrl       = VID_C_GEN_CTL;\n\t\tport->reg_bd_pkt_status  = VID_C_BD_PKT_STATUS;\n\t\tport->reg_sop_status     = VID_C_SOP_STATUS;\n\t\tport->reg_fifo_ovfl_stat = VID_C_FIFO_OVFL_STAT;\n\t\tport->reg_vld_misc       = VID_C_VLD_MISC;\n\t\tport->reg_ts_clk_en      = VID_C_TS_CLK_EN;\n\t\tport->reg_src_sel        = 0;\n\t\tport->reg_ts_int_msk     = VID_C_INT_MSK;\n\t\tport->reg_ts_int_stat    = VID_C_INT_STAT;\n\t\tport->sram_chno          = SRAM_CH06;  \n\t\tport->pci_irqmask        = 0x04;  \n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn 0;\n}\n\nstatic void cx23885_dev_checkrevision(struct cx23885_dev *dev)\n{\n\tswitch (cx_read(RDR_CFG2) & 0xff) {\n\tcase 0x00:\n\t\t \n\t\tdev->hwrevision = 0xa0;\n\t\tbreak;\n\tcase 0x01:\n\t\t \n\t\tdev->hwrevision = 0xa1;\n\t\tbreak;\n\tcase 0x02:\n\t\t \n\t\tdev->hwrevision = 0xb0;\n\t\tbreak;\n\tcase 0x03:\n\t\tif (dev->pci->device == 0x8880) {\n\t\t\t \n\t\t\tdev->hwrevision = 0xc0;\n\t\t} else {\n\t\t\t \n\t\t\tdev->hwrevision = 0xa4;\n\t\t}\n\t\tbreak;\n\tcase 0x04:\n\t\tif (dev->pci->device == 0x8880) {\n\t\t\t \n\t\t\tdev->hwrevision = 0xd0;\n\t\t} else {\n\t\t\t \n\t\t\tdev->hwrevision = 0xa5;\n\t\t}\n\t\tbreak;\n\tcase 0x0e:\n\t\t \n\t\tdev->hwrevision = 0xc0;\n\t\tbreak;\n\tcase 0x0f:\n\t\t \n\t\tdev->hwrevision = 0xb1;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s() New hardware revision found 0x%x\\n\",\n\t\t       __func__, dev->hwrevision);\n\t}\n\tif (dev->hwrevision)\n\t\tpr_info(\"%s() Hardware revision = 0x%02x\\n\",\n\t\t\t__func__, dev->hwrevision);\n\telse\n\t\tpr_err(\"%s() Hardware revision unknown 0x%x\\n\",\n\t\t       __func__, dev->hwrevision);\n}\n\n \nstruct v4l2_subdev *cx23885_find_hw(struct cx23885_dev *dev, u32 hw)\n{\n\tstruct v4l2_subdev *result = NULL;\n\tstruct v4l2_subdev *sd;\n\n\tspin_lock(&dev->v4l2_dev.lock);\n\tv4l2_device_for_each_subdev(sd, &dev->v4l2_dev) {\n\t\tif (sd->grp_id == hw) {\n\t\t\tresult = sd;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&dev->v4l2_dev.lock);\n\treturn result;\n}\n\nstatic int cx23885_dev_setup(struct cx23885_dev *dev)\n{\n\tint i;\n\n\tspin_lock_init(&dev->pci_irqmask_lock);\n\tspin_lock_init(&dev->slock);\n\n\tmutex_init(&dev->lock);\n\tmutex_init(&dev->gpio_lock);\n\n\tatomic_inc(&dev->refcount);\n\n\tdev->nr = cx23885_devcount++;\n\tsprintf(dev->name, \"cx23885[%d]\", dev->nr);\n\n\t \n\tif (dev->pci->device == 0x8880) {\n\t\t \n\t\tdev->bridge = CX23885_BRIDGE_888;\n\t\t \n\t\tdev->clk_freq = 50000000;\n\t\tdev->sram_channels = cx23887_sram_channels;\n\t} else\n\tif (dev->pci->device == 0x8852) {\n\t\tdev->bridge = CX23885_BRIDGE_885;\n\t\t \n\t\tdev->clk_freq = 28000000;\n\t\tdev->sram_channels = cx23885_sram_channels;\n\t} else\n\t\tBUG();\n\n\tdprintk(1, \"%s() Memory configured for PCIe bridge type %d\\n\",\n\t\t__func__, dev->bridge);\n\n\t \n\tdev->board = UNSET;\n\tif (card[dev->nr] < cx23885_bcount)\n\t\tdev->board = card[dev->nr];\n\tfor (i = 0; UNSET == dev->board  &&  i < cx23885_idcount; i++)\n\t\tif (dev->pci->subsystem_vendor == cx23885_subids[i].subvendor &&\n\t\t    dev->pci->subsystem_device == cx23885_subids[i].subdevice)\n\t\t\tdev->board = cx23885_subids[i].card;\n\tif (UNSET == dev->board) {\n\t\tdev->board = CX23885_BOARD_UNKNOWN;\n\t\tcx23885_card_list(dev);\n\t}\n\n\tif (dev->pci->device == 0x8852) {\n\t\t \n\t\tif (dev->board == CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC)\n\t\t\tdev->board = CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC_885;\n\t\telse if (dev->board == CX23885_BOARD_HAUPPAUGE_QUADHD_DVB)\n\t\t\tdev->board = CX23885_BOARD_HAUPPAUGE_QUADHD_DVB_885;\n\t}\n\n\t \n\tif (cx23885_boards[dev->board].clk_freq > 0)\n\t\tdev->clk_freq = cx23885_boards[dev->board].clk_freq;\n\n\tif (dev->board == CX23885_BOARD_HAUPPAUGE_IMPACTVCBE &&\n\t\tdev->pci->subsystem_device == 0x7137) {\n\t\t \n\t\tdev->clk_freq = 25000000;\n\t}\n\n\tdev->pci_bus  = dev->pci->bus->number;\n\tdev->pci_slot = PCI_SLOT(dev->pci->devfn);\n\tcx23885_irq_add(dev, 0x001f00);\n\n\t \n\tdev->i2c_bus[0].nr = 0;\n\tdev->i2c_bus[0].dev = dev;\n\tdev->i2c_bus[0].reg_stat  = I2C1_STAT;\n\tdev->i2c_bus[0].reg_ctrl  = I2C1_CTRL;\n\tdev->i2c_bus[0].reg_addr  = I2C1_ADDR;\n\tdev->i2c_bus[0].reg_rdata = I2C1_RDATA;\n\tdev->i2c_bus[0].reg_wdata = I2C1_WDATA;\n\tdev->i2c_bus[0].i2c_period = (0x9d << 24);  \n\n\t \n\tdev->i2c_bus[1].nr = 1;\n\tdev->i2c_bus[1].dev = dev;\n\tdev->i2c_bus[1].reg_stat  = I2C2_STAT;\n\tdev->i2c_bus[1].reg_ctrl  = I2C2_CTRL;\n\tdev->i2c_bus[1].reg_addr  = I2C2_ADDR;\n\tdev->i2c_bus[1].reg_rdata = I2C2_RDATA;\n\tdev->i2c_bus[1].reg_wdata = I2C2_WDATA;\n\tdev->i2c_bus[1].i2c_period = (0x9d << 24);  \n\n\t \n\tdev->i2c_bus[2].nr = 2;\n\tdev->i2c_bus[2].dev = dev;\n\tdev->i2c_bus[2].reg_stat  = I2C3_STAT;\n\tdev->i2c_bus[2].reg_ctrl  = I2C3_CTRL;\n\tdev->i2c_bus[2].reg_addr  = I2C3_ADDR;\n\tdev->i2c_bus[2].reg_rdata = I2C3_RDATA;\n\tdev->i2c_bus[2].reg_wdata = I2C3_WDATA;\n\tdev->i2c_bus[2].i2c_period = (0x07 << 24);  \n\n\tif ((cx23885_boards[dev->board].portb == CX23885_MPEG_DVB) ||\n\t\t(cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER))\n\t\tcx23885_init_tsport(dev, &dev->ts1, 1);\n\n\tif ((cx23885_boards[dev->board].portc == CX23885_MPEG_DVB) ||\n\t\t(cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER))\n\t\tcx23885_init_tsport(dev, &dev->ts2, 2);\n\n\tif (get_resources(dev) < 0) {\n\t\tpr_err(\"CORE %s No more PCIe resources for subsystem: %04x:%04x\\n\",\n\t\t       dev->name, dev->pci->subsystem_vendor,\n\t\t       dev->pci->subsystem_device);\n\n\t\tcx23885_devcount--;\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdev->lmmio = ioremap(pci_resource_start(dev->pci, 0),\n\t\t\t     pci_resource_len(dev->pci, 0));\n\n\tdev->bmmio = (u8 __iomem *)dev->lmmio;\n\n\tpr_info(\"CORE %s: subsystem: %04x:%04x, board: %s [card=%d,%s]\\n\",\n\t\tdev->name, dev->pci->subsystem_vendor,\n\t\tdev->pci->subsystem_device, cx23885_boards[dev->board].name,\n\t\tdev->board, card[dev->nr] == dev->board ?\n\t\t\"insmod option\" : \"autodetected\");\n\n\tcx23885_pci_quirks(dev);\n\n\t \n\tdev->tuner_type = cx23885_boards[dev->board].tuner_type;\n\tdev->tuner_addr = cx23885_boards[dev->board].tuner_addr;\n\tdev->tuner_bus = cx23885_boards[dev->board].tuner_bus;\n\tdev->radio_type = cx23885_boards[dev->board].radio_type;\n\tdev->radio_addr = cx23885_boards[dev->board].radio_addr;\n\n\tdprintk(1, \"%s() tuner_type = 0x%x tuner_addr = 0x%x tuner_bus = %d\\n\",\n\t\t__func__, dev->tuner_type, dev->tuner_addr, dev->tuner_bus);\n\tdprintk(1, \"%s() radio_type = 0x%x radio_addr = 0x%x\\n\",\n\t\t__func__, dev->radio_type, dev->radio_addr);\n\n\t \n\tif ((cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER) ||\n\t\t(cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER))\n\t\t\tcx23885_mc417_init(dev);\n\n\t \n\tcx23885_reset(dev);\n\n\tcx23885_i2c_register(&dev->i2c_bus[0]);\n\tcx23885_i2c_register(&dev->i2c_bus[1]);\n\tcx23885_i2c_register(&dev->i2c_bus[2]);\n\tcx23885_card_setup(dev);\n\tcall_all(dev, tuner, standby);\n\tcx23885_ir_init(dev);\n\n\tif (dev->board == CX23885_BOARD_VIEWCAST_460E) {\n\t\t \n\t\tcx23885_gpio_enable(dev, 0x300, 0);\n\t}\n\n\tif (cx23885_boards[dev->board].porta == CX23885_ANALOG_VIDEO) {\n\t\tif (cx23885_video_register(dev) < 0) {\n\t\t\tpr_err(\"%s() Failed to register analog video adapters on VID_A\\n\",\n\t\t\t       __func__);\n\t\t}\n\t}\n\n\tif (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB) {\n\t\tif (cx23885_boards[dev->board].num_fds_portb)\n\t\t\tdev->ts1.num_frontends =\n\t\t\t\tcx23885_boards[dev->board].num_fds_portb;\n\t\tif (cx23885_dvb_register(&dev->ts1) < 0) {\n\t\t\tpr_err(\"%s() Failed to register dvb adapters on VID_B\\n\",\n\t\t\t       __func__);\n\t\t}\n\t} else\n\tif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER) {\n\t\tif (cx23885_417_register(dev) < 0) {\n\t\t\tpr_err(\"%s() Failed to register 417 on VID_B\\n\",\n\t\t\t       __func__);\n\t\t}\n\t}\n\n\tif (cx23885_boards[dev->board].portc == CX23885_MPEG_DVB) {\n\t\tif (cx23885_boards[dev->board].num_fds_portc)\n\t\t\tdev->ts2.num_frontends =\n\t\t\t\tcx23885_boards[dev->board].num_fds_portc;\n\t\tif (cx23885_dvb_register(&dev->ts2) < 0) {\n\t\t\tpr_err(\"%s() Failed to register dvb on VID_C\\n\",\n\t\t\t       __func__);\n\t\t}\n\t} else\n\tif (cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER) {\n\t\tif (cx23885_417_register(dev) < 0) {\n\t\t\tpr_err(\"%s() Failed to register 417 on VID_C\\n\",\n\t\t\t       __func__);\n\t\t}\n\t}\n\n\tcx23885_dev_checkrevision(dev);\n\n\t \n\tif (cx23885_boards[dev->board].ci_type > 0)\n\t\tcx_clear(RDR_RDRCTL1, 1 << 8);\n\n\tswitch (dev->board) {\n\tcase CX23885_BOARD_TEVII_S470:\n\tcase CX23885_BOARD_TEVII_S471:\n\t\tcx_clear(RDR_RDRCTL1, 1 << 8);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void cx23885_dev_unregister(struct cx23885_dev *dev)\n{\n\trelease_mem_region(pci_resource_start(dev->pci, 0),\n\t\t\t   pci_resource_len(dev->pci, 0));\n\n\tif (!atomic_dec_and_test(&dev->refcount))\n\t\treturn;\n\n\tif (cx23885_boards[dev->board].porta == CX23885_ANALOG_VIDEO)\n\t\tcx23885_video_unregister(dev);\n\n\tif (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB)\n\t\tcx23885_dvb_unregister(&dev->ts1);\n\n\tif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)\n\t\tcx23885_417_unregister(dev);\n\n\tif (cx23885_boards[dev->board].portc == CX23885_MPEG_DVB)\n\t\tcx23885_dvb_unregister(&dev->ts2);\n\n\tif (cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER)\n\t\tcx23885_417_unregister(dev);\n\n\tcx23885_i2c_unregister(&dev->i2c_bus[2]);\n\tcx23885_i2c_unregister(&dev->i2c_bus[1]);\n\tcx23885_i2c_unregister(&dev->i2c_bus[0]);\n\n\tiounmap(dev->lmmio);\n}\n\nstatic __le32 *cx23885_risc_field(__le32 *rp, struct scatterlist *sglist,\n\t\t\t       unsigned int offset, u32 sync_line,\n\t\t\t       unsigned int bpl, unsigned int padding,\n\t\t\t       unsigned int lines,  unsigned int lpi, bool jump)\n{\n\tstruct scatterlist *sg;\n\tunsigned int line, todo, sol;\n\n\n\tif (jump) {\n\t\t*(rp++) = cpu_to_le32(RISC_JUMP);\n\t\t*(rp++) = cpu_to_le32(0);\n\t\t*(rp++) = cpu_to_le32(0);  \n\t}\n\n\t \n\tif (sync_line != NO_SYNC_LINE)\n\t\t*(rp++) = cpu_to_le32(RISC_RESYNC | sync_line);\n\n\t \n\tsg = sglist;\n\tfor (line = 0; line < lines; line++) {\n\t\twhile (offset && offset >= sg_dma_len(sg)) {\n\t\t\toffset -= sg_dma_len(sg);\n\t\t\tsg = sg_next(sg);\n\t\t}\n\n\t\tif (lpi && line > 0 && !(line % lpi))\n\t\t\tsol = RISC_SOL | RISC_IRQ1 | RISC_CNT_INC;\n\t\telse\n\t\t\tsol = RISC_SOL;\n\n\t\tif (bpl <= sg_dma_len(sg)-offset) {\n\t\t\t \n\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE|sol|RISC_EOL|bpl);\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg)+offset);\n\t\t\t*(rp++) = cpu_to_le32(0);  \n\t\t\toffset += bpl;\n\t\t} else {\n\t\t\t \n\t\t\ttodo = bpl;\n\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE|sol|\n\t\t\t\t\t    (sg_dma_len(sg)-offset));\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg)+offset);\n\t\t\t*(rp++) = cpu_to_le32(0);  \n\t\t\ttodo -= (sg_dma_len(sg)-offset);\n\t\t\toffset = 0;\n\t\t\tsg = sg_next(sg);\n\t\t\twhile (todo > sg_dma_len(sg)) {\n\t\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE|\n\t\t\t\t\t\t    sg_dma_len(sg));\n\t\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg));\n\t\t\t\t*(rp++) = cpu_to_le32(0);  \n\t\t\t\ttodo -= sg_dma_len(sg);\n\t\t\t\tsg = sg_next(sg);\n\t\t\t}\n\t\t\t*(rp++) = cpu_to_le32(RISC_WRITE|RISC_EOL|todo);\n\t\t\t*(rp++) = cpu_to_le32(sg_dma_address(sg));\n\t\t\t*(rp++) = cpu_to_le32(0);  \n\t\t\toffset += todo;\n\t\t}\n\t\toffset += padding;\n\t}\n\n\treturn rp;\n}\n\nint cx23885_risc_buffer(struct pci_dev *pci, struct cx23885_riscmem *risc,\n\t\t\tstruct scatterlist *sglist, unsigned int top_offset,\n\t\t\tunsigned int bottom_offset, unsigned int bpl,\n\t\t\tunsigned int padding, unsigned int lines)\n{\n\tu32 instructions, fields;\n\t__le32 *rp;\n\n\tfields = 0;\n\tif (UNSET != top_offset)\n\t\tfields++;\n\tif (UNSET != bottom_offset)\n\t\tfields++;\n\n\t \n\t \n\tinstructions  = fields * (1 + ((bpl + padding) * lines)\n\t\t/ PAGE_SIZE + lines);\n\tinstructions += 5;\n\trisc->size = instructions * 12;\n\trisc->cpu = dma_alloc_coherent(&pci->dev, risc->size, &risc->dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (risc->cpu == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\trp = risc->cpu;\n\tif (UNSET != top_offset)\n\t\trp = cx23885_risc_field(rp, sglist, top_offset, 0,\n\t\t\t\t\tbpl, padding, lines, 0, true);\n\tif (UNSET != bottom_offset)\n\t\trp = cx23885_risc_field(rp, sglist, bottom_offset, 0x200,\n\t\t\t\t\tbpl, padding, lines, 0, UNSET == top_offset);\n\n\t \n\trisc->jmp = rp;\n\tBUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\n\treturn 0;\n}\n\nint cx23885_risc_databuffer(struct pci_dev *pci,\n\t\t\t\t   struct cx23885_riscmem *risc,\n\t\t\t\t   struct scatterlist *sglist,\n\t\t\t\t   unsigned int bpl,\n\t\t\t\t   unsigned int lines, unsigned int lpi)\n{\n\tu32 instructions;\n\t__le32 *rp;\n\n\t \n\t \n\tinstructions  = 1 + (bpl * lines) / PAGE_SIZE + lines;\n\tinstructions += 4;\n\n\trisc->size = instructions * 12;\n\trisc->cpu = dma_alloc_coherent(&pci->dev, risc->size, &risc->dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (risc->cpu == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\trp = risc->cpu;\n\trp = cx23885_risc_field(rp, sglist, 0, NO_SYNC_LINE,\n\t\t\t\tbpl, 0, lines, lpi, lpi == 0);\n\n\t \n\trisc->jmp = rp;\n\tBUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\n\treturn 0;\n}\n\nint cx23885_risc_vbibuffer(struct pci_dev *pci, struct cx23885_riscmem *risc,\n\t\t\tstruct scatterlist *sglist, unsigned int top_offset,\n\t\t\tunsigned int bottom_offset, unsigned int bpl,\n\t\t\tunsigned int padding, unsigned int lines)\n{\n\tu32 instructions, fields;\n\t__le32 *rp;\n\n\tfields = 0;\n\tif (UNSET != top_offset)\n\t\tfields++;\n\tif (UNSET != bottom_offset)\n\t\tfields++;\n\n\t \n\t \n\tinstructions  = fields * (1 + ((bpl + padding) * lines)\n\t\t/ PAGE_SIZE + lines);\n\tinstructions += 5;\n\trisc->size = instructions * 12;\n\trisc->cpu = dma_alloc_coherent(&pci->dev, risc->size, &risc->dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (risc->cpu == NULL)\n\t\treturn -ENOMEM;\n\t \n\trp = risc->cpu;\n\n\t \n\tif (UNSET != top_offset)\n\t\trp = cx23885_risc_field(rp, sglist, top_offset, 0,\n\t\t\t\t\tbpl, padding, lines, 0, true);\n\n\tif (UNSET != bottom_offset)\n\t\trp = cx23885_risc_field(rp, sglist, bottom_offset, 0x200,\n\t\t\t\t\tbpl, padding, lines, 0, UNSET == top_offset);\n\n\n\n\t \n\trisc->jmp = rp;\n\tBUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\n\treturn 0;\n}\n\n\nvoid cx23885_free_buffer(struct cx23885_dev *dev, struct cx23885_buffer *buf)\n{\n\tstruct cx23885_riscmem *risc = &buf->risc;\n\n\tif (risc->cpu)\n\t\tdma_free_coherent(&dev->pci->dev, risc->size, risc->cpu, risc->dma);\n\tmemset(risc, 0, sizeof(*risc));\n}\n\nstatic void cx23885_tsport_reg_dump(struct cx23885_tsport *port)\n{\n\tstruct cx23885_dev *dev = port->dev;\n\n\tdprintk(1, \"%s() Register Dump\\n\", __func__);\n\tdprintk(1, \"%s() DEV_CNTRL2               0x%08X\\n\", __func__,\n\t\tcx_read(DEV_CNTRL2));\n\tdprintk(1, \"%s() PCI_INT_MSK              0x%08X\\n\", __func__,\n\t\tcx23885_irq_get_mask(dev));\n\tdprintk(1, \"%s() AUD_INT_INT_MSK          0x%08X\\n\", __func__,\n\t\tcx_read(AUDIO_INT_INT_MSK));\n\tdprintk(1, \"%s() AUD_INT_DMA_CTL          0x%08X\\n\", __func__,\n\t\tcx_read(AUD_INT_DMA_CTL));\n\tdprintk(1, \"%s() AUD_EXT_INT_MSK          0x%08X\\n\", __func__,\n\t\tcx_read(AUDIO_EXT_INT_MSK));\n\tdprintk(1, \"%s() AUD_EXT_DMA_CTL          0x%08X\\n\", __func__,\n\t\tcx_read(AUD_EXT_DMA_CTL));\n\tdprintk(1, \"%s() PAD_CTRL                 0x%08X\\n\", __func__,\n\t\tcx_read(PAD_CTRL));\n\tdprintk(1, \"%s() ALT_PIN_OUT_SEL          0x%08X\\n\", __func__,\n\t\tcx_read(ALT_PIN_OUT_SEL));\n\tdprintk(1, \"%s() GPIO2                    0x%08X\\n\", __func__,\n\t\tcx_read(GPIO2));\n\tdprintk(1, \"%s() gpcnt(0x%08X)          0x%08X\\n\", __func__,\n\t\tport->reg_gpcnt, cx_read(port->reg_gpcnt));\n\tdprintk(1, \"%s() gpcnt_ctl(0x%08X)      0x%08x\\n\", __func__,\n\t\tport->reg_gpcnt_ctl, cx_read(port->reg_gpcnt_ctl));\n\tdprintk(1, \"%s() dma_ctl(0x%08X)        0x%08x\\n\", __func__,\n\t\tport->reg_dma_ctl, cx_read(port->reg_dma_ctl));\n\tif (port->reg_src_sel)\n\t\tdprintk(1, \"%s() src_sel(0x%08X)        0x%08x\\n\", __func__,\n\t\t\tport->reg_src_sel, cx_read(port->reg_src_sel));\n\tdprintk(1, \"%s() lngth(0x%08X)          0x%08x\\n\", __func__,\n\t\tport->reg_lngth, cx_read(port->reg_lngth));\n\tdprintk(1, \"%s() hw_sop_ctrl(0x%08X)    0x%08x\\n\", __func__,\n\t\tport->reg_hw_sop_ctrl, cx_read(port->reg_hw_sop_ctrl));\n\tdprintk(1, \"%s() gen_ctrl(0x%08X)       0x%08x\\n\", __func__,\n\t\tport->reg_gen_ctrl, cx_read(port->reg_gen_ctrl));\n\tdprintk(1, \"%s() bd_pkt_status(0x%08X)  0x%08x\\n\", __func__,\n\t\tport->reg_bd_pkt_status, cx_read(port->reg_bd_pkt_status));\n\tdprintk(1, \"%s() sop_status(0x%08X)     0x%08x\\n\", __func__,\n\t\tport->reg_sop_status, cx_read(port->reg_sop_status));\n\tdprintk(1, \"%s() fifo_ovfl_stat(0x%08X) 0x%08x\\n\", __func__,\n\t\tport->reg_fifo_ovfl_stat, cx_read(port->reg_fifo_ovfl_stat));\n\tdprintk(1, \"%s() vld_misc(0x%08X)       0x%08x\\n\", __func__,\n\t\tport->reg_vld_misc, cx_read(port->reg_vld_misc));\n\tdprintk(1, \"%s() ts_clk_en(0x%08X)      0x%08x\\n\", __func__,\n\t\tport->reg_ts_clk_en, cx_read(port->reg_ts_clk_en));\n\tdprintk(1, \"%s() ts_int_msk(0x%08X)     0x%08x\\n\", __func__,\n\t\tport->reg_ts_int_msk, cx_read(port->reg_ts_int_msk));\n\tdprintk(1, \"%s() ts_int_status(0x%08X)  0x%08x\\n\", __func__,\n\t\tport->reg_ts_int_stat, cx_read(port->reg_ts_int_stat));\n\tdprintk(1, \"%s() PCI_INT_STAT           0x%08X\\n\", __func__,\n\t\tcx_read(PCI_INT_STAT));\n\tdprintk(1, \"%s() VID_B_INT_MSTAT        0x%08X\\n\", __func__,\n\t\tcx_read(VID_B_INT_MSTAT));\n\tdprintk(1, \"%s() VID_B_INT_SSTAT        0x%08X\\n\", __func__,\n\t\tcx_read(VID_B_INT_SSTAT));\n\tdprintk(1, \"%s() VID_C_INT_MSTAT        0x%08X\\n\", __func__,\n\t\tcx_read(VID_C_INT_MSTAT));\n\tdprintk(1, \"%s() VID_C_INT_SSTAT        0x%08X\\n\", __func__,\n\t\tcx_read(VID_C_INT_SSTAT));\n}\n\nint cx23885_start_dma(struct cx23885_tsport *port,\n\t\t\t     struct cx23885_dmaqueue *q,\n\t\t\t     struct cx23885_buffer   *buf)\n{\n\tstruct cx23885_dev *dev = port->dev;\n\tu32 reg;\n\n\tdprintk(1, \"%s() w: %d, h: %d, f: %d\\n\", __func__,\n\t\tdev->width, dev->height, dev->field);\n\n\t \n\tcx23885_clear_bridge_error(dev);\n\n\t \n\tcx_clear(port->reg_dma_ctl, port->dma_ctl_val);\n\n\t \n\tcx23885_sram_channel_setup(dev,\n\t\t\t\t   &dev->sram_channels[port->sram_chno],\n\t\t\t\t   port->ts_packet_size, buf->risc.dma);\n\tif (debug > 5) {\n\t\tcx23885_sram_channel_dump(dev,\n\t\t\t&dev->sram_channels[port->sram_chno]);\n\t\tcx23885_risc_disasm(port, &buf->risc);\n\t}\n\n\t \n\tcx_write(port->reg_lngth, port->ts_packet_size);\n\n\tif ((!(cx23885_boards[dev->board].portb & CX23885_MPEG_DVB)) &&\n\t\t(!(cx23885_boards[dev->board].portc & CX23885_MPEG_DVB))) {\n\t\tpr_err(\"%s() Unsupported .portb/c (0x%08x)/(0x%08x)\\n\",\n\t\t\t__func__,\n\t\t\tcx23885_boards[dev->board].portb,\n\t\t\tcx23885_boards[dev->board].portc);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)\n\t\tcx23885_av_clk(dev, 0);\n\n\tudelay(100);\n\n\t \n\tif (port->reg_src_sel)\n\t\tcx_write(port->reg_src_sel, port->src_sel_val);\n\n\tcx_write(port->reg_hw_sop_ctrl, port->hw_sop_ctrl_val);\n\tcx_write(port->reg_ts_clk_en, port->ts_clk_en_val);\n\tcx_write(port->reg_vld_misc, port->vld_misc_val);\n\tcx_write(port->reg_gen_ctrl, port->gen_ctrl_val);\n\tudelay(100);\n\n\t \n\t \n\tcx_write(port->reg_gpcnt_ctl, 3);\n\tq->count = 0;\n\n\t \n\tif (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB) {\n\t\treg = cx_read(PAD_CTRL);\n\t\treg &= ~0x3;  \n\t\tcx_write(PAD_CTRL, reg);\n\t}\n\n\t \n\tif (cx23885_boards[dev->board].portc == CX23885_MPEG_DVB) {\n\t\treg = cx_read(PAD_CTRL);\n\t\treg &= ~0x4;  \n\t\tcx_write(PAD_CTRL, reg);\n\t}\n\n\tif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER) {\n\n\t\treg = cx_read(PAD_CTRL);\n\t\treg = reg & ~0x1;     \n\n\t\t \n\t\t \n\t\treg = reg | 0xa;\n\t\tcx_write(PAD_CTRL, reg);\n\n\t\t \n\t\t \n\t\tcx_write(CLK_DELAY, cx_read(CLK_DELAY) | 0x80000011);\n\n\t\t \n\t\tcx_write(ALT_PIN_OUT_SEL, 0x10100045);\n\t}\n\n\tswitch (dev->bridge) {\n\tcase CX23885_BRIDGE_885:\n\tcase CX23885_BRIDGE_887:\n\tcase CX23885_BRIDGE_888:\n\t\t \n\t\tdprintk(1, \"%s() enabling TS int's and DMA\\n\", __func__);\n\t\t \n\t\tcx23885_clear_bridge_error(dev);\n\t\tcx_set(port->reg_ts_int_msk,  port->ts_int_msk_val);\n\t\tcx_set(port->reg_dma_ctl, port->dma_ctl_val);\n\n\t\t \n\t\tcx23885_clear_bridge_error(dev);\n\t\tcx23885_irq_add(dev, port->pci_irqmask);\n\t\tcx23885_irq_enable_all(dev);\n\n\t\t \n\t\tcx23885_clear_bridge_error(dev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tcx_set(DEV_CNTRL2, (1<<5));  \n\t \n\tcx23885_clear_bridge_error(dev);\n\n\tif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)\n\t\tcx23885_av_clk(dev, 1);\n\n\tif (debug > 4)\n\t\tcx23885_tsport_reg_dump(port);\n\n\tcx23885_irq_get_mask(dev);\n\n\t \n\tcx23885_clear_bridge_error(dev);\n\n\treturn 0;\n}\n\nstatic int cx23885_stop_dma(struct cx23885_tsport *port)\n{\n\tstruct cx23885_dev *dev = port->dev;\n\tu32 reg;\n\tint delay = 0;\n\tuint32_t reg1_val;\n\tuint32_t reg2_val;\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tcx_clear(port->reg_ts_int_msk, port->ts_int_msk_val);\n\tcx_clear(port->reg_dma_ctl, port->dma_ctl_val);\n\t \n\tmdelay(20);\n\tfor (delay = 0; delay < 100; delay++) {\n\t\treg1_val = cx_read(TC_REQ);\n\t\treg2_val = cx_read(TC_REQ_SET);\n\t\tif (reg1_val == 0 || reg2_val == 0)\n\t\t\tbreak;\n\t\tmdelay(1);\n\t}\n\tdev_dbg(&dev->pci->dev, \"delay=%d reg1=0x%08x reg2=0x%08x\\n\",\n\t\tdelay, reg1_val, reg2_val);\n\n\tif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER) {\n\t\treg = cx_read(PAD_CTRL);\n\n\t\t \n\t\treg = reg | 0x1;\n\n\t\t \n\t\treg = reg & ~0xa;\n\t\tcx_write(PAD_CTRL, reg);\n\t\tcx_write(port->reg_src_sel, 0);\n\t\tcx_write(port->reg_gen_ctrl, 8);\n\t}\n\n\tif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)\n\t\tcx23885_av_clk(dev, 0);\n\n\treturn 0;\n}\n\n \n\nint cx23885_buf_prepare(struct cx23885_buffer *buf, struct cx23885_tsport *port)\n{\n\tstruct cx23885_dev *dev = port->dev;\n\tint size = port->ts_packet_size * port->ts_packet_count;\n\tstruct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vb.vb2_buf, 0);\n\n\tdprintk(1, \"%s: %p\\n\", __func__, buf);\n\tif (vb2_plane_size(&buf->vb.vb2_buf, 0) < size)\n\t\treturn -EINVAL;\n\tvb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);\n\n\tcx23885_risc_databuffer(dev->pci, &buf->risc,\n\t\t\t\tsgt->sgl,\n\t\t\t\tport->ts_packet_size, port->ts_packet_count, 0);\n\treturn 0;\n}\n\n \nvoid cx23885_buf_queue(struct cx23885_tsport *port, struct cx23885_buffer *buf)\n{\n\tstruct cx23885_buffer    *prev;\n\tstruct cx23885_dev *dev = port->dev;\n\tstruct cx23885_dmaqueue  *cx88q = &port->mpegq;\n\tunsigned long flags;\n\n\tbuf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 12);\n\tbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);\n\tbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 12);\n\tbuf->risc.jmp[2] = cpu_to_le32(0);  \n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tif (list_empty(&cx88q->active)) {\n\t\tlist_add_tail(&buf->queue, &cx88q->active);\n\t\tdprintk(1, \"[%p/%d] %s - first active\\n\",\n\t\t\tbuf, buf->vb.vb2_buf.index, __func__);\n\t} else {\n\t\tbuf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);\n\t\tprev = list_entry(cx88q->active.prev, struct cx23885_buffer,\n\t\t\t\t  queue);\n\t\tlist_add_tail(&buf->queue, &cx88q->active);\n\t\tprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\n\t\tdprintk(1, \"[%p/%d] %s - append to active\\n\",\n\t\t\t buf, buf->vb.vb2_buf.index, __func__);\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\n \n\nstatic void do_cancel_buffers(struct cx23885_tsport *port, char *reason)\n{\n\tstruct cx23885_dmaqueue *q = &port->mpegq;\n\tstruct cx23885_buffer *buf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->slock, flags);\n\twhile (!list_empty(&q->active)) {\n\t\tbuf = list_entry(q->active.next, struct cx23885_buffer,\n\t\t\t\t queue);\n\t\tlist_del(&buf->queue);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tdprintk(1, \"[%p/%d] %s - dma=0x%08lx\\n\",\n\t\t\tbuf, buf->vb.vb2_buf.index, reason,\n\t\t\t(unsigned long)buf->risc.dma);\n\t}\n\tspin_unlock_irqrestore(&port->slock, flags);\n}\n\nvoid cx23885_cancel_buffers(struct cx23885_tsport *port)\n{\n\tdprintk(1, \"%s()\\n\", __func__);\n\tcx23885_stop_dma(port);\n\tdo_cancel_buffers(port, \"cancel\");\n}\n\nint cx23885_irq_417(struct cx23885_dev *dev, u32 status)\n{\n\t \n\tstruct cx23885_tsport *port = &dev->ts1;\n\tint count = 0;\n\tint handled = 0;\n\n\tif (status == 0)\n\t\treturn handled;\n\n\tcount = cx_read(port->reg_gpcnt);\n\tdprintk(7, \"status: 0x%08x  mask: 0x%08x count: 0x%x\\n\",\n\t\tstatus, cx_read(port->reg_ts_int_msk), count);\n\n\tif ((status & VID_B_MSK_BAD_PKT)         ||\n\t\t(status & VID_B_MSK_OPC_ERR)     ||\n\t\t(status & VID_B_MSK_VBI_OPC_ERR) ||\n\t\t(status & VID_B_MSK_SYNC)        ||\n\t\t(status & VID_B_MSK_VBI_SYNC)    ||\n\t\t(status & VID_B_MSK_OF)          ||\n\t\t(status & VID_B_MSK_VBI_OF)) {\n\t\tpr_err(\"%s: V4L mpeg risc op code error, status = 0x%x\\n\",\n\t\t       dev->name, status);\n\t\tif (status & VID_B_MSK_BAD_PKT)\n\t\t\tdprintk(1, \"        VID_B_MSK_BAD_PKT\\n\");\n\t\tif (status & VID_B_MSK_OPC_ERR)\n\t\t\tdprintk(1, \"        VID_B_MSK_OPC_ERR\\n\");\n\t\tif (status & VID_B_MSK_VBI_OPC_ERR)\n\t\t\tdprintk(1, \"        VID_B_MSK_VBI_OPC_ERR\\n\");\n\t\tif (status & VID_B_MSK_SYNC)\n\t\t\tdprintk(1, \"        VID_B_MSK_SYNC\\n\");\n\t\tif (status & VID_B_MSK_VBI_SYNC)\n\t\t\tdprintk(1, \"        VID_B_MSK_VBI_SYNC\\n\");\n\t\tif (status & VID_B_MSK_OF)\n\t\t\tdprintk(1, \"        VID_B_MSK_OF\\n\");\n\t\tif (status & VID_B_MSK_VBI_OF)\n\t\t\tdprintk(1, \"        VID_B_MSK_VBI_OF\\n\");\n\n\t\tcx_clear(port->reg_dma_ctl, port->dma_ctl_val);\n\t\tcx23885_sram_channel_dump(dev,\n\t\t\t&dev->sram_channels[port->sram_chno]);\n\t\tcx23885_417_check_encoder(dev);\n\t} else if (status & VID_B_MSK_RISCI1) {\n\t\tdprintk(7, \"        VID_B_MSK_RISCI1\\n\");\n\t\tspin_lock(&port->slock);\n\t\tcx23885_wakeup(port, &port->mpegq, count);\n\t\tspin_unlock(&port->slock);\n\t}\n\tif (status) {\n\t\tcx_write(port->reg_ts_int_stat, status);\n\t\thandled = 1;\n\t}\n\n\treturn handled;\n}\n\nstatic int cx23885_irq_ts(struct cx23885_tsport *port, u32 status)\n{\n\tstruct cx23885_dev *dev = port->dev;\n\tint handled = 0;\n\tu32 count;\n\n\tif ((status & VID_BC_MSK_OPC_ERR) ||\n\t\t(status & VID_BC_MSK_BAD_PKT) ||\n\t\t(status & VID_BC_MSK_SYNC) ||\n\t\t(status & VID_BC_MSK_OF)) {\n\n\t\tif (status & VID_BC_MSK_OPC_ERR)\n\t\t\tdprintk(7, \" (VID_BC_MSK_OPC_ERR 0x%08x)\\n\",\n\t\t\t\tVID_BC_MSK_OPC_ERR);\n\n\t\tif (status & VID_BC_MSK_BAD_PKT)\n\t\t\tdprintk(7, \" (VID_BC_MSK_BAD_PKT 0x%08x)\\n\",\n\t\t\t\tVID_BC_MSK_BAD_PKT);\n\n\t\tif (status & VID_BC_MSK_SYNC)\n\t\t\tdprintk(7, \" (VID_BC_MSK_SYNC    0x%08x)\\n\",\n\t\t\t\tVID_BC_MSK_SYNC);\n\n\t\tif (status & VID_BC_MSK_OF)\n\t\t\tdprintk(7, \" (VID_BC_MSK_OF      0x%08x)\\n\",\n\t\t\t\tVID_BC_MSK_OF);\n\n\t\tpr_err(\"%s: mpeg risc op code error\\n\", dev->name);\n\n\t\tcx_clear(port->reg_dma_ctl, port->dma_ctl_val);\n\t\tcx23885_sram_channel_dump(dev,\n\t\t\t&dev->sram_channels[port->sram_chno]);\n\n\t} else if (status & VID_BC_MSK_RISCI1) {\n\n\t\tdprintk(7, \" (RISCI1            0x%08x)\\n\", VID_BC_MSK_RISCI1);\n\n\t\tspin_lock(&port->slock);\n\t\tcount = cx_read(port->reg_gpcnt);\n\t\tcx23885_wakeup(port, &port->mpegq, count);\n\t\tspin_unlock(&port->slock);\n\n\t}\n\tif (status) {\n\t\tcx_write(port->reg_ts_int_stat, status);\n\t\thandled = 1;\n\t}\n\n\treturn handled;\n}\n\nstatic irqreturn_t cx23885_irq(int irq, void *dev_id)\n{\n\tstruct cx23885_dev *dev = dev_id;\n\tstruct cx23885_tsport *ts1 = &dev->ts1;\n\tstruct cx23885_tsport *ts2 = &dev->ts2;\n\tu32 pci_status, pci_mask;\n\tu32 vida_status, vida_mask;\n\tu32 audint_status, audint_mask;\n\tu32 ts1_status, ts1_mask;\n\tu32 ts2_status, ts2_mask;\n\tint vida_count = 0, ts1_count = 0, ts2_count = 0, handled = 0;\n\tint audint_count = 0;\n\tbool subdev_handled;\n\n\tpci_status = cx_read(PCI_INT_STAT);\n\tpci_mask = cx23885_irq_get_mask(dev);\n\tif ((pci_status & pci_mask) == 0) {\n\t\tdprintk(7, \"pci_status: 0x%08x  pci_mask: 0x%08x\\n\",\n\t\t\tpci_status, pci_mask);\n\t\tgoto out;\n\t}\n\n\tvida_status = cx_read(VID_A_INT_STAT);\n\tvida_mask = cx_read(VID_A_INT_MSK);\n\taudint_status = cx_read(AUDIO_INT_INT_STAT);\n\taudint_mask = cx_read(AUDIO_INT_INT_MSK);\n\tts1_status = cx_read(VID_B_INT_STAT);\n\tts1_mask = cx_read(VID_B_INT_MSK);\n\tts2_status = cx_read(VID_C_INT_STAT);\n\tts2_mask = cx_read(VID_C_INT_MSK);\n\n\tif (((pci_status & pci_mask) == 0) &&\n\t\t((ts2_status & ts2_mask) == 0) &&\n\t\t((ts1_status & ts1_mask) == 0))\n\t\tgoto out;\n\n\tvida_count = cx_read(VID_A_GPCNT);\n\taudint_count = cx_read(AUD_INT_A_GPCNT);\n\tts1_count = cx_read(ts1->reg_gpcnt);\n\tts2_count = cx_read(ts2->reg_gpcnt);\n\tdprintk(7, \"pci_status: 0x%08x  pci_mask: 0x%08x\\n\",\n\t\tpci_status, pci_mask);\n\tdprintk(7, \"vida_status: 0x%08x vida_mask: 0x%08x count: 0x%x\\n\",\n\t\tvida_status, vida_mask, vida_count);\n\tdprintk(7, \"audint_status: 0x%08x audint_mask: 0x%08x count: 0x%x\\n\",\n\t\taudint_status, audint_mask, audint_count);\n\tdprintk(7, \"ts1_status: 0x%08x  ts1_mask: 0x%08x count: 0x%x\\n\",\n\t\tts1_status, ts1_mask, ts1_count);\n\tdprintk(7, \"ts2_status: 0x%08x  ts2_mask: 0x%08x count: 0x%x\\n\",\n\t\tts2_status, ts2_mask, ts2_count);\n\n\tif (pci_status & (PCI_MSK_RISC_RD | PCI_MSK_RISC_WR |\n\t\t\t  PCI_MSK_AL_RD   | PCI_MSK_AL_WR   | PCI_MSK_APB_DMA |\n\t\t\t  PCI_MSK_VID_C   | PCI_MSK_VID_B   | PCI_MSK_VID_A   |\n\t\t\t  PCI_MSK_AUD_INT | PCI_MSK_AUD_EXT |\n\t\t\t  PCI_MSK_GPIO0   | PCI_MSK_GPIO1   |\n\t\t\t  PCI_MSK_AV_CORE | PCI_MSK_IR)) {\n\n\t\tif (pci_status & PCI_MSK_RISC_RD)\n\t\t\tdprintk(7, \" (PCI_MSK_RISC_RD   0x%08x)\\n\",\n\t\t\t\tPCI_MSK_RISC_RD);\n\n\t\tif (pci_status & PCI_MSK_RISC_WR)\n\t\t\tdprintk(7, \" (PCI_MSK_RISC_WR   0x%08x)\\n\",\n\t\t\t\tPCI_MSK_RISC_WR);\n\n\t\tif (pci_status & PCI_MSK_AL_RD)\n\t\t\tdprintk(7, \" (PCI_MSK_AL_RD     0x%08x)\\n\",\n\t\t\t\tPCI_MSK_AL_RD);\n\n\t\tif (pci_status & PCI_MSK_AL_WR)\n\t\t\tdprintk(7, \" (PCI_MSK_AL_WR     0x%08x)\\n\",\n\t\t\t\tPCI_MSK_AL_WR);\n\n\t\tif (pci_status & PCI_MSK_APB_DMA)\n\t\t\tdprintk(7, \" (PCI_MSK_APB_DMA   0x%08x)\\n\",\n\t\t\t\tPCI_MSK_APB_DMA);\n\n\t\tif (pci_status & PCI_MSK_VID_C)\n\t\t\tdprintk(7, \" (PCI_MSK_VID_C     0x%08x)\\n\",\n\t\t\t\tPCI_MSK_VID_C);\n\n\t\tif (pci_status & PCI_MSK_VID_B)\n\t\t\tdprintk(7, \" (PCI_MSK_VID_B     0x%08x)\\n\",\n\t\t\t\tPCI_MSK_VID_B);\n\n\t\tif (pci_status & PCI_MSK_VID_A)\n\t\t\tdprintk(7, \" (PCI_MSK_VID_A     0x%08x)\\n\",\n\t\t\t\tPCI_MSK_VID_A);\n\n\t\tif (pci_status & PCI_MSK_AUD_INT)\n\t\t\tdprintk(7, \" (PCI_MSK_AUD_INT   0x%08x)\\n\",\n\t\t\t\tPCI_MSK_AUD_INT);\n\n\t\tif (pci_status & PCI_MSK_AUD_EXT)\n\t\t\tdprintk(7, \" (PCI_MSK_AUD_EXT   0x%08x)\\n\",\n\t\t\t\tPCI_MSK_AUD_EXT);\n\n\t\tif (pci_status & PCI_MSK_GPIO0)\n\t\t\tdprintk(7, \" (PCI_MSK_GPIO0     0x%08x)\\n\",\n\t\t\t\tPCI_MSK_GPIO0);\n\n\t\tif (pci_status & PCI_MSK_GPIO1)\n\t\t\tdprintk(7, \" (PCI_MSK_GPIO1     0x%08x)\\n\",\n\t\t\t\tPCI_MSK_GPIO1);\n\n\t\tif (pci_status & PCI_MSK_AV_CORE)\n\t\t\tdprintk(7, \" (PCI_MSK_AV_CORE   0x%08x)\\n\",\n\t\t\t\tPCI_MSK_AV_CORE);\n\n\t\tif (pci_status & PCI_MSK_IR)\n\t\t\tdprintk(7, \" (PCI_MSK_IR        0x%08x)\\n\",\n\t\t\t\tPCI_MSK_IR);\n\t}\n\n\tif (cx23885_boards[dev->board].ci_type == 1 &&\n\t\t\t(pci_status & (PCI_MSK_GPIO1 | PCI_MSK_GPIO0)))\n\t\thandled += netup_ci_slot_status(dev, pci_status);\n\n\tif (cx23885_boards[dev->board].ci_type == 2 &&\n\t\t\t(pci_status & PCI_MSK_GPIO0))\n\t\thandled += altera_ci_irq(dev);\n\n\tif (ts1_status) {\n\t\tif (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB)\n\t\t\thandled += cx23885_irq_ts(ts1, ts1_status);\n\t\telse\n\t\tif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)\n\t\t\thandled += cx23885_irq_417(dev, ts1_status);\n\t}\n\n\tif (ts2_status) {\n\t\tif (cx23885_boards[dev->board].portc == CX23885_MPEG_DVB)\n\t\t\thandled += cx23885_irq_ts(ts2, ts2_status);\n\t\telse\n\t\tif (cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER)\n\t\t\thandled += cx23885_irq_417(dev, ts2_status);\n\t}\n\n\tif (vida_status)\n\t\thandled += cx23885_video_irq(dev, vida_status);\n\n\tif (audint_status)\n\t\thandled += cx23885_audio_irq(dev, audint_status, audint_mask);\n\n\tif (pci_status & PCI_MSK_IR) {\n\t\tsubdev_handled = false;\n\t\tv4l2_subdev_call(dev->sd_ir, core, interrupt_service_routine,\n\t\t\t\t pci_status, &subdev_handled);\n\t\tif (subdev_handled)\n\t\t\thandled++;\n\t}\n\n\tif ((pci_status & pci_mask) & PCI_MSK_AV_CORE) {\n\t\tcx23885_irq_disable(dev, PCI_MSK_AV_CORE);\n\t\tschedule_work(&dev->cx25840_work);\n\t\thandled++;\n\t}\n\n\tif (handled)\n\t\tcx_write(PCI_INT_STAT, pci_status & pci_mask);\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void cx23885_v4l2_dev_notify(struct v4l2_subdev *sd,\n\t\t\t\t    unsigned int notification, void *arg)\n{\n\tstruct cx23885_dev *dev;\n\n\tif (sd == NULL)\n\t\treturn;\n\n\tdev = to_cx23885(sd->v4l2_dev);\n\n\tswitch (notification) {\n\tcase V4L2_SUBDEV_IR_RX_NOTIFY:  \n\t\tif (sd == dev->sd_ir)\n\t\t\tcx23885_ir_rx_v4l2_dev_notify(sd, *(u32 *)arg);\n\t\tbreak;\n\tcase V4L2_SUBDEV_IR_TX_NOTIFY:  \n\t\tif (sd == dev->sd_ir)\n\t\t\tcx23885_ir_tx_v4l2_dev_notify(sd, *(u32 *)arg);\n\t\tbreak;\n\t}\n}\n\nstatic void cx23885_v4l2_dev_notify_init(struct cx23885_dev *dev)\n{\n\tINIT_WORK(&dev->cx25840_work, cx23885_av_work_handler);\n\tINIT_WORK(&dev->ir_rx_work, cx23885_ir_rx_work_handler);\n\tINIT_WORK(&dev->ir_tx_work, cx23885_ir_tx_work_handler);\n\tdev->v4l2_dev.notify = cx23885_v4l2_dev_notify;\n}\n\nstatic inline int encoder_on_portb(struct cx23885_dev *dev)\n{\n\treturn cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER;\n}\n\nstatic inline int encoder_on_portc(struct cx23885_dev *dev)\n{\n\treturn cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER;\n}\n\n \nvoid cx23885_gpio_set(struct cx23885_dev *dev, u32 mask)\n{\n\tif (mask & 0x7)\n\t\tcx_set(GP0_IO, mask & 0x7);\n\n\tif (mask & 0x0007fff8) {\n\t\tif (encoder_on_portb(dev) || encoder_on_portc(dev))\n\t\t\tpr_err(\"%s: Setting GPIO on encoder ports\\n\",\n\t\t\t\tdev->name);\n\t\tcx_set(MC417_RWD, (mask & 0x0007fff8) >> 3);\n\t}\n\n\t \n\tif (mask & 0x00f80000)\n\t\tpr_info(\"%s: Unsupported\\n\", dev->name);\n}\n\nvoid cx23885_gpio_clear(struct cx23885_dev *dev, u32 mask)\n{\n\tif (mask & 0x00000007)\n\t\tcx_clear(GP0_IO, mask & 0x7);\n\n\tif (mask & 0x0007fff8) {\n\t\tif (encoder_on_portb(dev) || encoder_on_portc(dev))\n\t\t\tpr_err(\"%s: Clearing GPIO moving on encoder ports\\n\",\n\t\t\t\tdev->name);\n\t\tcx_clear(MC417_RWD, (mask & 0x7fff8) >> 3);\n\t}\n\n\t \n\tif (mask & 0x00f80000)\n\t\tpr_info(\"%s: Unsupported\\n\", dev->name);\n}\n\nu32 cx23885_gpio_get(struct cx23885_dev *dev, u32 mask)\n{\n\tif (mask & 0x00000007)\n\t\treturn (cx_read(GP0_IO) >> 8) & mask & 0x7;\n\n\tif (mask & 0x0007fff8) {\n\t\tif (encoder_on_portb(dev) || encoder_on_portc(dev))\n\t\t\tpr_err(\"%s: Reading GPIO moving on encoder ports\\n\",\n\t\t\t\tdev->name);\n\t\treturn (cx_read(MC417_RWD) & ((mask & 0x7fff8) >> 3)) << 3;\n\t}\n\n\t \n\tif (mask & 0x00f80000)\n\t\tpr_info(\"%s: Unsupported\\n\", dev->name);\n\n\treturn 0;\n}\n\nvoid cx23885_gpio_enable(struct cx23885_dev *dev, u32 mask, int asoutput)\n{\n\tif ((mask & 0x00000007) && asoutput)\n\t\tcx_set(GP0_IO, (mask & 0x7) << 16);\n\telse if ((mask & 0x00000007) && !asoutput)\n\t\tcx_clear(GP0_IO, (mask & 0x7) << 16);\n\n\tif (mask & 0x0007fff8) {\n\t\tif (encoder_on_portb(dev) || encoder_on_portc(dev))\n\t\t\tpr_err(\"%s: Enabling GPIO on encoder ports\\n\",\n\t\t\t\tdev->name);\n\t}\n\n\t \n\tif ((mask & 0x0007fff8) && asoutput)\n\t\tcx_clear(MC417_OEN, (mask & 0x7fff8) >> 3);\n\n\telse if ((mask & 0x0007fff8) && !asoutput)\n\t\tcx_set(MC417_OEN, (mask & 0x7fff8) >> 3);\n\n\t \n}\n\nstatic struct {\n\tint vendor, dev;\n} const broken_dev_id[] = {\n\t \n\t{ PCI_VENDOR_ID_AMD, 0x1451 },\n\t \n\t{ PCI_VENDOR_ID_AMD, 0x1423 },\n\t \n\t{ PCI_VENDOR_ID_AMD, 0x1481 },\n\t \n\t{ PCI_VENDOR_ID_AMD, 0x1419 },\n\t \n\t{ PCI_VENDOR_ID_AMD, 0x1631 },\n\t \n\t{ PCI_VENDOR_ID_ATI, 0x5a23 },\n};\n\nstatic bool cx23885_does_need_dma_reset(void)\n{\n\tint i;\n\tstruct pci_dev *pdev = NULL;\n\n\tif (dma_reset_workaround == 0)\n\t\treturn false;\n\telse if (dma_reset_workaround == 2)\n\t\treturn true;\n\n\tfor (i = 0; i < ARRAY_SIZE(broken_dev_id); i++) {\n\t\tpdev = pci_get_device(broken_dev_id[i].vendor,\n\t\t\t\t      broken_dev_id[i].dev, NULL);\n\t\tif (pdev) {\n\t\t\tpci_dev_put(pdev);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int cx23885_initdev(struct pci_dev *pci_dev,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstruct cx23885_dev *dev;\n\tstruct v4l2_ctrl_handler *hdl;\n\tint err;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (NULL == dev)\n\t\treturn -ENOMEM;\n\n\tdev->need_dma_reset = cx23885_does_need_dma_reset();\n\n\terr = v4l2_device_register(&pci_dev->dev, &dev->v4l2_dev);\n\tif (err < 0)\n\t\tgoto fail_free;\n\n\thdl = &dev->ctrl_handler;\n\tv4l2_ctrl_handler_init(hdl, 6);\n\tif (hdl->error) {\n\t\terr = hdl->error;\n\t\tgoto fail_ctrl;\n\t}\n\tdev->v4l2_dev.ctrl_handler = hdl;\n\n\t \n\tcx23885_v4l2_dev_notify_init(dev);\n\n\t \n\tdev->pci = pci_dev;\n\tif (pci_enable_device(pci_dev)) {\n\t\terr = -EIO;\n\t\tgoto fail_ctrl;\n\t}\n\n\tif (cx23885_dev_setup(dev) < 0) {\n\t\terr = -EINVAL;\n\t\tgoto fail_ctrl;\n\t}\n\n\t \n\tdev->pci_rev = pci_dev->revision;\n\tpci_read_config_byte(pci_dev, PCI_LATENCY_TIMER,  &dev->pci_lat);\n\tpr_info(\"%s/0: found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\\n\",\n\t       dev->name,\n\t       pci_name(pci_dev), dev->pci_rev, pci_dev->irq,\n\t       dev->pci_lat,\n\t\t(unsigned long long)pci_resource_start(pci_dev, 0));\n\n\tpci_set_master(pci_dev);\n\terr = dma_set_mask(&pci_dev->dev, 0xffffffff);\n\tif (err) {\n\t\tpr_err(\"%s/0: Oops: no 32bit PCI DMA ???\\n\", dev->name);\n\t\tgoto fail_dma_set_mask;\n\t}\n\n\terr = request_irq(pci_dev->irq, cx23885_irq,\n\t\t\t  IRQF_SHARED, dev->name, dev);\n\tif (err < 0) {\n\t\tpr_err(\"%s: can't get IRQ %d\\n\",\n\t\t       dev->name, pci_dev->irq);\n\t\tgoto fail_dma_set_mask;\n\t}\n\n\tswitch (dev->board) {\n\tcase CX23885_BOARD_NETUP_DUAL_DVBS2_CI:\n\t\tcx23885_irq_add_enable(dev, PCI_MSK_GPIO1 | PCI_MSK_GPIO0);\n\t\tbreak;\n\tcase CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:\n\t\tcx23885_irq_add_enable(dev, PCI_MSK_GPIO0);\n\t\tbreak;\n\t}\n\n\t \n\tcx23885_ir_pci_int_enable(dev);\n\tcx23885_input_init(dev);\n\n\treturn 0;\n\nfail_dma_set_mask:\n\tcx23885_dev_unregister(dev);\nfail_ctrl:\n\tv4l2_ctrl_handler_free(hdl);\n\tv4l2_device_unregister(&dev->v4l2_dev);\nfail_free:\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void cx23885_finidev(struct pci_dev *pci_dev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\n\tstruct cx23885_dev *dev = to_cx23885(v4l2_dev);\n\n\tcx23885_input_fini(dev);\n\tcx23885_ir_fini(dev);\n\n\tcx23885_shutdown(dev);\n\n\t \n\tfree_irq(pci_dev->irq, dev);\n\n\tpci_disable_device(pci_dev);\n\n\tcx23885_dev_unregister(dev);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tv4l2_device_unregister(v4l2_dev);\n\tkfree(dev);\n}\n\nstatic const struct pci_device_id cx23885_pci_tbl[] = {\n\t{\n\t\t \n\t\t.vendor       = 0x14f1,\n\t\t.device       = 0x8852,\n\t\t.subvendor    = PCI_ANY_ID,\n\t\t.subdevice    = PCI_ANY_ID,\n\t}, {\n\t\t \n\t\t.vendor       = 0x14f1,\n\t\t.device       = 0x8880,\n\t\t.subvendor    = PCI_ANY_ID,\n\t\t.subdevice    = PCI_ANY_ID,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(pci, cx23885_pci_tbl);\n\nstatic struct pci_driver cx23885_pci_driver = {\n\t.name     = \"cx23885\",\n\t.id_table = cx23885_pci_tbl,\n\t.probe    = cx23885_initdev,\n\t.remove   = cx23885_finidev,\n};\n\nstatic int __init cx23885_init(void)\n{\n\tpr_info(\"cx23885 driver version %s loaded\\n\",\n\t\tCX23885_VERSION);\n\treturn pci_register_driver(&cx23885_pci_driver);\n}\n\nstatic void __exit cx23885_fini(void)\n{\n\tpci_unregister_driver(&cx23885_pci_driver);\n}\n\nmodule_init(cx23885_init);\nmodule_exit(cx23885_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}