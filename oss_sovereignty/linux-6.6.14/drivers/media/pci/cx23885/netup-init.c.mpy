{
  "module_name": "netup-init.c",
  "hash_id": "f908ae42d20fe46bcccc0918e6d70da6adfd82409060543bef305e1960467b76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx23885/netup-init.c",
  "human_readable_source": "\n \n\n#include \"cx23885.h\"\n#include \"netup-init.h\"\n\nstatic void i2c_av_write(struct i2c_adapter *i2c, u16 reg, u8 val)\n{\n\tint ret;\n\tu8 buf[3];\n\tstruct i2c_msg msg = {\n\t\t.addr\t= 0x88 >> 1,\n\t\t.flags\t= 0,\n\t\t.buf\t= buf,\n\t\t.len\t= 3\n\t};\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xff;\n\tbuf[2] = val;\n\n\tret = i2c_transfer(i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tpr_err(\"%s: i2c write error!\\n\", __func__);\n}\n\nstatic void i2c_av_write4(struct i2c_adapter *i2c, u16 reg, u32 val)\n{\n\tint ret;\n\tu8 buf[6];\n\tstruct i2c_msg msg = {\n\t\t.addr\t= 0x88 >> 1,\n\t\t.flags\t= 0,\n\t\t.buf\t= buf,\n\t\t.len\t= 6\n\t};\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xff;\n\tbuf[2] = val & 0xff;\n\tbuf[3] = (val >> 8) & 0xff;\n\tbuf[4] = (val >> 16) & 0xff;\n\tbuf[5] = val >> 24;\n\n\tret = i2c_transfer(i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tpr_err(\"%s: i2c write error!\\n\", __func__);\n}\n\nstatic u8 i2c_av_read(struct i2c_adapter *i2c, u16 reg)\n{\n\tint ret;\n\tu8 buf[2];\n\tstruct i2c_msg msg = {\n\t\t.addr\t= 0x88 >> 1,\n\t\t.flags\t= 0,\n\t\t.buf\t= buf,\n\t\t.len\t= 2\n\t};\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xff;\n\n\tret = i2c_transfer(i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tpr_err(\"%s: i2c write error!\\n\", __func__);\n\n\tmsg.flags = I2C_M_RD;\n\tmsg.len = 1;\n\n\tret = i2c_transfer(i2c, &msg, 1);\n\n\tif (ret != 1)\n\t\tpr_err(\"%s: i2c read error!\\n\", __func__);\n\n\treturn buf[0];\n}\n\nstatic void i2c_av_and_or(struct i2c_adapter *i2c, u16 reg, unsigned and_mask,\n\t\t\t\t\t\t\t\tu8 or_value)\n{\n\ti2c_av_write(i2c, reg, (i2c_av_read(i2c, reg) & and_mask) | or_value);\n}\n \nvoid netup_initialize(struct cx23885_dev *dev)\n{\n\tstruct cx23885_i2c *i2c_bus = &dev->i2c_bus[2];\n\tstruct i2c_adapter *i2c = &i2c_bus->i2c_adap;\n\n\t \n\ti2c_av_and_or(i2c, 0x803, ~0x10, 0x00);\n\n\t \n\ti2c_av_write4(i2c, 0x114, 0xea0eb3);\n\n\t \n\ti2c_av_write4(i2c, 0x110, 0x090319);\n\n\t \n\ti2c_av_and_or(i2c, 0x803, ~0x10, 0x10);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}