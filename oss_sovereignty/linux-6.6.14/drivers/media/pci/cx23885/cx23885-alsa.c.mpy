{
  "module_name": "cx23885-alsa.c",
  "hash_id": "df20784784f5446c03e2ff513f406814befafdc1f8a41a9c315c5548af84342d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx23885/cx23885-alsa.c",
  "human_readable_source": "\n \n\n#include \"cx23885.h\"\n#include \"cx23885-reg.h\"\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/vmalloc.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci.h>\n\n#include <asm/delay.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/control.h>\n#include <sound/initval.h>\n\n#include <sound/tlv.h>\n\n#define AUDIO_SRAM_CHANNEL\tSRAM_CH07\n\n#define dprintk(level, fmt, arg...) do {\t\t\t\t\\\n\tif (audio_debug + 1 > level)\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: alsa: \" fmt), \\\n\t\t\tchip->dev->name, ##arg); \\\n} while(0)\n\n \n\nstatic unsigned int disable_analog_audio;\nmodule_param(disable_analog_audio, int, 0644);\nMODULE_PARM_DESC(disable_analog_audio, \"disable analog audio ALSA driver\");\n\nstatic unsigned int audio_debug;\nmodule_param(audio_debug, int, 0644);\nMODULE_PARM_DESC(audio_debug, \"enable debug messages [analog audio]\");\n\n \n\n \n#define AUD_INT_DN_RISCI1       (1 <<  0)\n#define AUD_INT_UP_RISCI1       (1 <<  1)\n#define AUD_INT_RDS_DN_RISCI1   (1 <<  2)\n#define AUD_INT_DN_RISCI2       (1 <<  4)  \n#define AUD_INT_UP_RISCI2       (1 <<  5)\n#define AUD_INT_RDS_DN_RISCI2   (1 <<  6)\n#define AUD_INT_DN_SYNC         (1 << 12)\n#define AUD_INT_UP_SYNC         (1 << 13)\n#define AUD_INT_RDS_DN_SYNC     (1 << 14)\n#define AUD_INT_OPC_ERR         (1 << 16)\n#define AUD_INT_BER_IRQ         (1 << 20)\n#define AUD_INT_MCHG_IRQ        (1 << 21)\n#define GP_COUNT_CONTROL_RESET\t0x3\n\nstatic int cx23885_alsa_dma_init(struct cx23885_audio_dev *chip,\n\t\t\t\t unsigned long nr_pages)\n{\n\tstruct cx23885_audio_buffer *buf = chip->buf;\n\tstruct page *pg;\n\tint i;\n\n\tbuf->vaddr = vmalloc_32(nr_pages << PAGE_SHIFT);\n\tif (NULL == buf->vaddr) {\n\t\tdprintk(1, \"vmalloc_32(%lu pages) failed\\n\", nr_pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tdprintk(1, \"vmalloc is at addr %p, size=%lu\\n\",\n\t\tbuf->vaddr, nr_pages << PAGE_SHIFT);\n\n\tmemset(buf->vaddr, 0, nr_pages << PAGE_SHIFT);\n\tbuf->nr_pages = nr_pages;\n\n\tbuf->sglist = vzalloc(array_size(sizeof(*buf->sglist), buf->nr_pages));\n\tif (NULL == buf->sglist)\n\t\tgoto vzalloc_err;\n\n\tsg_init_table(buf->sglist, buf->nr_pages);\n\tfor (i = 0; i < buf->nr_pages; i++) {\n\t\tpg = vmalloc_to_page(buf->vaddr + i * PAGE_SIZE);\n\t\tif (NULL == pg)\n\t\t\tgoto vmalloc_to_page_err;\n\t\tsg_set_page(&buf->sglist[i], pg, PAGE_SIZE, 0);\n\t}\n\treturn 0;\n\nvmalloc_to_page_err:\n\tvfree(buf->sglist);\n\tbuf->sglist = NULL;\nvzalloc_err:\n\tvfree(buf->vaddr);\n\tbuf->vaddr = NULL;\n\treturn -ENOMEM;\n}\n\nstatic int cx23885_alsa_dma_map(struct cx23885_audio_dev *dev)\n{\n\tstruct cx23885_audio_buffer *buf = dev->buf;\n\n\tbuf->sglen = dma_map_sg(&dev->pci->dev, buf->sglist,\n\t\t\tbuf->nr_pages, DMA_FROM_DEVICE);\n\n\tif (0 == buf->sglen) {\n\t\tpr_warn(\"%s: cx23885_alsa_map_sg failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int cx23885_alsa_dma_unmap(struct cx23885_audio_dev *dev)\n{\n\tstruct cx23885_audio_buffer *buf = dev->buf;\n\n\tif (!buf->sglen)\n\t\treturn 0;\n\n\tdma_unmap_sg(&dev->pci->dev, buf->sglist, buf->nr_pages, DMA_FROM_DEVICE);\n\tbuf->sglen = 0;\n\treturn 0;\n}\n\nstatic int cx23885_alsa_dma_free(struct cx23885_audio_buffer *buf)\n{\n\tvfree(buf->sglist);\n\tbuf->sglist = NULL;\n\tvfree(buf->vaddr);\n\tbuf->vaddr = NULL;\n\treturn 0;\n}\n\n \n\nstatic int cx23885_start_audio_dma(struct cx23885_audio_dev *chip)\n{\n\tstruct cx23885_audio_buffer *buf = chip->buf;\n\tstruct cx23885_dev *dev  = chip->dev;\n\tstruct sram_channel *audio_ch =\n\t\t&dev->sram_channels[AUDIO_SRAM_CHANNEL];\n\n\tdprintk(1, \"%s()\\n\", __func__);\n\n\t \n\tcx_clear(AUD_INT_DMA_CTL, 0x11);\n\n\t \n\tcx23885_sram_channel_setup(chip->dev, audio_ch, buf->bpl,\n\t\tbuf->risc.dma);\n\n\t \n\tcx_write(AUD_INT_A_LNGTH, buf->bpl);\n\n\t \n\tcx_write(AUD_INT_A_MODE, 1);\n\n\t \n\tcx_write(AUD_INT_A_GPCNT_CTL, GP_COUNT_CONTROL_RESET);\n\tatomic_set(&chip->count, 0);\n\n\tdprintk(1, \"Start audio DMA, %d B/line, %d lines/FIFO, %d periods, %d byte buffer\\n\",\n\t\tbuf->bpl, cx_read(audio_ch->cmds_start+12)>>1,\n\t\tchip->num_periods, buf->bpl * chip->num_periods);\n\n\t \n\tcx_write(AUDIO_INT_INT_MSK, AUD_INT_OPC_ERR | AUD_INT_DN_SYNC |\n\t\t\t\t    AUD_INT_DN_RISCI1);\n\n\t \n\tcx_write(AUDIO_INT_INT_STAT, ~0);\n\n\t \n\tcx_set(PCI_INT_MSK, chip->dev->pci_irqmask | PCI_MSK_AUD_INT);\n\n\t \n\tcx_set(DEV_CNTRL2, (1<<5));  \n\tcx_set(AUD_INT_DMA_CTL, 0x11);  \n\tif (audio_debug)\n\t\tcx23885_sram_channel_dump(chip->dev, audio_ch);\n\n\treturn 0;\n}\n\n \nstatic int cx23885_stop_audio_dma(struct cx23885_audio_dev *chip)\n{\n\tstruct cx23885_dev *dev = chip->dev;\n\tdprintk(1, \"Stopping audio DMA\\n\");\n\n\t \n\tcx_clear(AUD_INT_DMA_CTL, 0x11);\n\n\t \n\tcx_clear(PCI_INT_MSK, PCI_MSK_AUD_INT);\n\tcx_clear(AUDIO_INT_INT_MSK, AUD_INT_OPC_ERR | AUD_INT_DN_SYNC |\n\t\t\t\t    AUD_INT_DN_RISCI1);\n\n\tif (audio_debug)\n\t\tcx23885_sram_channel_dump(chip->dev,\n\t\t\t&dev->sram_channels[AUDIO_SRAM_CHANNEL]);\n\n\treturn 0;\n}\n\n \nint cx23885_audio_irq(struct cx23885_dev *dev, u32 status, u32 mask)\n{\n\tstruct cx23885_audio_dev *chip = dev->audio_dev;\n\n\tif (0 == (status & mask))\n\t\treturn 0;\n\n\tcx_write(AUDIO_INT_INT_STAT, status);\n\n\t \n\tif (status & AUD_INT_OPC_ERR) {\n\t\tpr_warn(\"%s/1: Audio risc op code error\\n\",\n\t\t\tdev->name);\n\t\tcx_clear(AUD_INT_DMA_CTL, 0x11);\n\t\tcx23885_sram_channel_dump(dev,\n\t\t\t&dev->sram_channels[AUDIO_SRAM_CHANNEL]);\n\t}\n\tif (status & AUD_INT_DN_SYNC) {\n\t\tdprintk(1, \"Downstream sync error\\n\");\n\t\tcx_write(AUD_INT_A_GPCNT_CTL, GP_COUNT_CONTROL_RESET);\n\t\treturn 1;\n\t}\n\t \n\tif (status & AUD_INT_DN_RISCI1) {\n\t\tatomic_set(&chip->count, cx_read(AUD_INT_A_GPCNT));\n\t\tsnd_pcm_period_elapsed(chip->substream);\n\t}\n\t \n\n\treturn 1;\n}\n\nstatic int dsp_buffer_free(struct cx23885_audio_dev *chip)\n{\n\tstruct cx23885_riscmem *risc;\n\n\tBUG_ON(!chip->dma_size);\n\n\tdprintk(2, \"Freeing buffer\\n\");\n\tcx23885_alsa_dma_unmap(chip);\n\tcx23885_alsa_dma_free(chip->buf);\n\trisc = &chip->buf->risc;\n\tdma_free_coherent(&chip->pci->dev, risc->size, risc->cpu, risc->dma);\n\tkfree(chip->buf);\n\n\tchip->buf = NULL;\n\tchip->dma_size = 0;\n\n\treturn 0;\n}\n\n \n\n \n#define DEFAULT_FIFO_SIZE\t4096\n\nstatic const struct snd_pcm_hardware snd_cx23885_digital_hw = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t \n\t.period_bytes_min = DEFAULT_FIFO_SIZE/4,\n\t.period_bytes_max = DEFAULT_FIFO_SIZE/4,\n\t.periods_min = 1,\n\t.periods_max = 1024,\n\t.buffer_bytes_max = (1024*1024),\n};\n\n \nstatic int snd_cx23885_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tif (!chip) {\n\t\tpr_err(\"BUG: cx23885 can't find device struct. Can't proceed with open\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = snd_pcm_hw_constraint_pow2(runtime, 0,\n\t\tSNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\tgoto _error;\n\n\tchip->substream = substream;\n\n\truntime->hw = snd_cx23885_digital_hw;\n\n\tif (chip->dev->sram_channels[AUDIO_SRAM_CHANNEL].fifo_size !=\n\t\tDEFAULT_FIFO_SIZE) {\n\t\tunsigned int bpl = chip->dev->\n\t\t\tsram_channels[AUDIO_SRAM_CHANNEL].fifo_size / 4;\n\t\tbpl &= ~7;  \n\t\truntime->hw.period_bytes_min = bpl;\n\t\truntime->hw.period_bytes_max = bpl;\n\t}\n\n\treturn 0;\n_error:\n\tdprintk(1, \"Error opening PCM!\\n\");\n\treturn err;\n}\n\n \nstatic int snd_cx23885_close(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n\n \nstatic int snd_cx23885_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *hw_params)\n{\n\tstruct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);\n\tstruct cx23885_audio_buffer *buf;\n\tint ret;\n\n\tif (substream->runtime->dma_area) {\n\t\tdsp_buffer_free(chip);\n\t\tsubstream->runtime->dma_area = NULL;\n\t}\n\n\tchip->period_size = params_period_bytes(hw_params);\n\tchip->num_periods = params_periods(hw_params);\n\tchip->dma_size = chip->period_size * params_periods(hw_params);\n\n\tBUG_ON(!chip->dma_size);\n\tBUG_ON(chip->num_periods & (chip->num_periods-1));\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (NULL == buf)\n\t\treturn -ENOMEM;\n\n\tbuf->bpl = chip->period_size;\n\tchip->buf = buf;\n\n\tret = cx23885_alsa_dma_init(chip,\n\t\t\t(PAGE_ALIGN(chip->dma_size) >> PAGE_SHIFT));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = cx23885_alsa_dma_map(chip);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = cx23885_risc_databuffer(chip->pci, &buf->risc, buf->sglist,\n\t\t\t\t   chip->period_size, chip->num_periods, 1);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP|RISC_IRQ1|RISC_CNT_INC);\n\tbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\n\tbuf->risc.jmp[2] = cpu_to_le32(0);  \n\n\tsubstream->runtime->dma_area = chip->buf->vaddr;\n\tsubstream->runtime->dma_bytes = chip->dma_size;\n\tsubstream->runtime->dma_addr = 0;\n\n\treturn 0;\n\nerror:\n\tkfree(buf);\n\tchip->buf = NULL;\n\treturn ret;\n}\n\n \nstatic int snd_cx23885_hw_free(struct snd_pcm_substream *substream)\n{\n\n\tstruct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);\n\n\tif (substream->runtime->dma_area) {\n\t\tdsp_buffer_free(chip);\n\t\tsubstream->runtime->dma_area = NULL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_cx23885_prepare(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n \nstatic int snd_cx23885_card_trigger(struct snd_pcm_substream *substream,\n\tint cmd)\n{\n\tstruct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);\n\tint err;\n\n\t \n\tspin_lock(&chip->lock);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\terr = cx23885_start_audio_dma(chip);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\terr = cx23885_stop_audio_dma(chip);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_unlock(&chip->lock);\n\n\treturn err;\n}\n\n \nstatic snd_pcm_uframes_t snd_cx23885_pointer(\n\tstruct snd_pcm_substream *substream)\n{\n\tstruct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tu16 count;\n\n\tcount = atomic_read(&chip->count);\n\n\treturn runtime->period_size * (count & (runtime->periods-1));\n}\n\n \nstatic struct page *snd_cx23885_page(struct snd_pcm_substream *substream,\n\t\t\t\tunsigned long offset)\n{\n\tvoid *pageptr = substream->runtime->dma_area + offset;\n\treturn vmalloc_to_page(pageptr);\n}\n\n \nstatic const struct snd_pcm_ops snd_cx23885_pcm_ops = {\n\t.open = snd_cx23885_pcm_open,\n\t.close = snd_cx23885_close,\n\t.hw_params = snd_cx23885_hw_params,\n\t.hw_free = snd_cx23885_hw_free,\n\t.prepare = snd_cx23885_prepare,\n\t.trigger = snd_cx23885_card_trigger,\n\t.pointer = snd_cx23885_pointer,\n\t.page = snd_cx23885_page,\n};\n\n \nstatic int snd_cx23885_pcm(struct cx23885_audio_dev *chip, int device,\n\tchar *name)\n{\n\tint err;\n\tstruct snd_pcm *pcm;\n\n\terr = snd_pcm_new(chip->card, name, device, 0, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\tstrscpy(pcm->name, name, sizeof(pcm->name));\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cx23885_pcm_ops);\n\n\treturn 0;\n}\n\n \n\n \n\nstruct cx23885_audio_dev *cx23885_audio_register(struct cx23885_dev *dev)\n{\n\tstruct snd_card *card;\n\tstruct cx23885_audio_dev *chip;\n\tint err;\n\n\tif (disable_analog_audio)\n\t\treturn NULL;\n\n\tif (dev->sram_channels[AUDIO_SRAM_CHANNEL].cmds_start == 0) {\n\t\tpr_warn(\"%s(): Missing SRAM channel configuration for analog TV Audio\\n\",\n\t\t       __func__);\n\t\treturn NULL;\n\t}\n\n\terr = snd_card_new(&dev->pci->dev,\n\t\t\t   SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\n\t\t\tTHIS_MODULE, sizeof(struct cx23885_audio_dev), &card);\n\tif (err < 0)\n\t\tgoto error_msg;\n\n\tchip = (struct cx23885_audio_dev *) card->private_data;\n\tchip->dev = dev;\n\tchip->pci = dev->pci;\n\tchip->card = card;\n\tspin_lock_init(&chip->lock);\n\n\terr = snd_cx23885_pcm(chip, 0, \"CX23885 Digital\");\n\tif (err < 0)\n\t\tgoto error;\n\n\tstrscpy(card->driver, \"CX23885\", sizeof(card->driver));\n\tsprintf(card->shortname, \"Conexant CX23885\");\n\tsprintf(card->longname, \"%s at %s\", card->shortname, dev->name);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\tdprintk(0, \"registered ALSA audio device\\n\");\n\n\treturn chip;\n\nerror:\n\tsnd_card_free(card);\nerror_msg:\n\tpr_err(\"%s(): Failed to register analog audio adapter\\n\",\n\t       __func__);\n\n\treturn NULL;\n}\n\n \nvoid cx23885_audio_unregister(struct cx23885_dev *dev)\n{\n\tstruct cx23885_audio_dev *chip = dev->audio_dev;\n\n\tsnd_card_free(chip->card);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}