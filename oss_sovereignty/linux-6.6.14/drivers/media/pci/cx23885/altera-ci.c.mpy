{
  "module_name": "altera-ci.c",
  "hash_id": "db788c756a37ad060098fabc800f03b3885bb109f5e1911e8edf00aa192ccb67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx23885/altera-ci.c",
  "human_readable_source": "\n \n\n \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <media/dvb_demux.h>\n#include <media/dvb_frontend.h>\n#include \"altera-ci.h\"\n#include <media/dvb_ca_en50221.h>\n\n \n#define NETUP_CI_INT_CTRL\t0x00\n#define NETUP_CI_BUSCTRL2\t0x01\n#define NETUP_CI_ADDR0\t\t0x04\n#define NETUP_CI_ADDR1\t\t0x05\n#define NETUP_CI_DATA\t\t0x06\n#define NETUP_CI_BUSCTRL\t0x07\n#define NETUP_CI_PID_ADDR0\t0x08\n#define NETUP_CI_PID_ADDR1\t0x09\n#define NETUP_CI_PID_DATA\t0x0a\n#define NETUP_CI_TSA_DIV\t0x0c\n#define NETUP_CI_TSB_DIV\t0x0d\n#define NETUP_CI_REVISION\t0x0f\n\n \n#define NETUP_CI_FLG_CTL\t1\n#define NETUP_CI_FLG_RD\t\t1\n#define NETUP_CI_FLG_AD\t\t1\n\nstatic unsigned int ci_dbg;\nmodule_param(ci_dbg, int, 0644);\nMODULE_PARM_DESC(ci_dbg, \"Enable CI debugging\");\n\nstatic unsigned int pid_dbg;\nmodule_param(pid_dbg, int, 0644);\nMODULE_PARM_DESC(pid_dbg, \"Enable PID filtering debugging\");\n\nMODULE_DESCRIPTION(\"altera FPGA CI module\");\nMODULE_AUTHOR(\"Igor M. Liplianin  <liplianin@netup.ru>\");\nMODULE_LICENSE(\"GPL\");\n\n#define ci_dbg_print(fmt, args...) \\\n\tdo { \\\n\t\tif (ci_dbg) \\\n\t\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt), \\\n\t\t\t       __func__, ##args); \\\n\t} while (0)\n\n#define pid_dbg_print(fmt, args...) \\\n\tdo { \\\n\t\tif (pid_dbg) \\\n\t\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt), \\\n\t\t\t       __func__, ##args); \\\n\t} while (0)\n\nstruct altera_ci_state;\nstruct netup_hw_pid_filter;\n\nstruct fpga_internal {\n\tvoid *dev;\n\tstruct mutex fpga_mutex; \n\tstruct netup_hw_pid_filter *pid_filt[2];\n\tstruct altera_ci_state *state[2];\n\tstruct work_struct work;\n\tint (*fpga_rw) (void *dev, int flag, int data, int rw);\n\tint cis_used;\n\tint filts_used;\n\tint strt_wrk;\n};\n\n \nstruct altera_ci_state {\n\tstruct fpga_internal *internal;\n\tstruct dvb_ca_en50221 ca;\n\tint status;\n\tint nr;\n};\n\n \nstruct netup_hw_pid_filter {\n\tstruct fpga_internal *internal;\n\tstruct dvb_demux *demux;\n\t \n\tint (*start_feed)(struct dvb_demux_feed *feed);\n\tint (*stop_feed)(struct dvb_demux_feed *feed);\n\n\tint status;\n\tint nr;\n};\n\n \nstruct fpga_inode {\n\t \n\tstruct fpga_internal\t\t*internal;\n\tstruct fpga_inode\t\t*next_inode;\n};\n\n \nstatic struct fpga_inode *fpga_first_inode;\n\n \nstatic struct fpga_inode *find_inode(void *dev)\n{\n\tstruct fpga_inode *temp_chip = fpga_first_inode;\n\n\tif (temp_chip == NULL)\n\t\treturn temp_chip;\n\n\t \n\twhile ((temp_chip != NULL) &&\n\t\t\t\t(temp_chip->internal->dev != dev))\n\t\ttemp_chip = temp_chip->next_inode;\n\n\treturn temp_chip;\n}\n \nstatic struct fpga_internal *check_filter(struct fpga_internal *temp_int,\n\t\t\t\t\t\tvoid *demux_dev, int filt_nr)\n{\n\tif (temp_int == NULL)\n\t\treturn NULL;\n\n\tif ((temp_int->pid_filt[filt_nr]) == NULL)\n\t\treturn NULL;\n\n\tif (temp_int->pid_filt[filt_nr]->demux == demux_dev)\n\t\treturn temp_int;\n\n\treturn NULL;\n}\n\n \nstatic struct fpga_inode *find_dinode(void *demux_dev)\n{\n\tstruct fpga_inode *temp_chip = fpga_first_inode;\n\tstruct fpga_internal *temp_int;\n\n\t \n\twhile (temp_chip != NULL) {\n\t\tif (temp_chip->internal != NULL) {\n\t\t\ttemp_int = temp_chip->internal;\n\t\t\tif (check_filter(temp_int, demux_dev, 0))\n\t\t\t\tbreak;\n\t\t\tif (check_filter(temp_int, demux_dev, 1))\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttemp_chip = temp_chip->next_inode;\n\t}\n\n\treturn temp_chip;\n}\n\n \nstatic void remove_inode(struct fpga_internal *internal)\n{\n\tstruct fpga_inode *prev_node = fpga_first_inode;\n\tstruct fpga_inode *del_node = find_inode(internal->dev);\n\n\tif (del_node != NULL) {\n\t\tif (del_node == fpga_first_inode) {\n\t\t\tfpga_first_inode = del_node->next_inode;\n\t\t} else {\n\t\t\twhile (prev_node->next_inode != del_node)\n\t\t\t\tprev_node = prev_node->next_inode;\n\n\t\t\tif (del_node->next_inode == NULL)\n\t\t\t\tprev_node->next_inode = NULL;\n\t\t\telse\n\t\t\t\tprev_node->next_inode =\n\t\t\t\t\tprev_node->next_inode->next_inode;\n\t\t}\n\n\t\tkfree(del_node);\n\t}\n}\n\n \nstatic struct fpga_inode *append_internal(struct fpga_internal *internal)\n{\n\tstruct fpga_inode *new_node = fpga_first_inode;\n\n\tif (new_node == NULL) {\n\t\tnew_node = kmalloc(sizeof(struct fpga_inode), GFP_KERNEL);\n\t\tfpga_first_inode = new_node;\n\t} else {\n\t\twhile (new_node->next_inode != NULL)\n\t\t\tnew_node = new_node->next_inode;\n\n\t\tnew_node->next_inode =\n\t\t\t\tkmalloc(sizeof(struct fpga_inode), GFP_KERNEL);\n\t\tif (new_node->next_inode != NULL)\n\t\t\tnew_node = new_node->next_inode;\n\t\telse\n\t\t\tnew_node = NULL;\n\t}\n\n\tif (new_node != NULL) {\n\t\tnew_node->internal = internal;\n\t\tnew_node->next_inode = NULL;\n\t}\n\n\treturn new_node;\n}\n\nstatic int netup_fpga_op_rw(struct fpga_internal *inter, int addr,\n\t\t\t\t\t\t\tu8 val, u8 read)\n{\n\tinter->fpga_rw(inter->dev, NETUP_CI_FLG_AD, addr, 0);\n\treturn inter->fpga_rw(inter->dev, 0, val, read);\n}\n\n \nstatic int altera_ci_op_cam(struct dvb_ca_en50221 *en50221, int slot,\n\t\t\t\tu8 flag, u8 read, int addr, u8 val)\n{\n\n\tstruct altera_ci_state *state = en50221->data;\n\tstruct fpga_internal *inter = state->internal;\n\n\tu8 store;\n\tint mem = 0;\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&inter->fpga_mutex);\n\n\tnetup_fpga_op_rw(inter, NETUP_CI_ADDR0, ((addr << 1) & 0xfe), 0);\n\tnetup_fpga_op_rw(inter, NETUP_CI_ADDR1, ((addr >> 7) & 0x7f), 0);\n\tstore = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL, 0, NETUP_CI_FLG_RD);\n\n\tstore &= 0x0f;\n\tstore |= ((state->nr << 7) | (flag << 6));\n\n\tnetup_fpga_op_rw(inter, NETUP_CI_BUSCTRL, store, 0);\n\tmem = netup_fpga_op_rw(inter, NETUP_CI_DATA, val, read);\n\n\tmutex_unlock(&inter->fpga_mutex);\n\n\tci_dbg_print(\"%s: %s: addr=[0x%02x], %s=%x\\n\", __func__,\n\t\t\t(read) ? \"read\" : \"write\", addr,\n\t\t\t(flag == NETUP_CI_FLG_CTL) ? \"ctl\" : \"mem\",\n\t\t\t(read) ? mem : val);\n\n\treturn mem;\n}\n\nstatic int altera_ci_read_attribute_mem(struct dvb_ca_en50221 *en50221,\n\t\t\t\t\tint slot, int addr)\n{\n\treturn altera_ci_op_cam(en50221, slot, 0, NETUP_CI_FLG_RD, addr, 0);\n}\n\nstatic int altera_ci_write_attribute_mem(struct dvb_ca_en50221 *en50221,\n\t\t\t\t\t int slot, int addr, u8 data)\n{\n\treturn altera_ci_op_cam(en50221, slot, 0, 0, addr, data);\n}\n\nstatic int altera_ci_read_cam_ctl(struct dvb_ca_en50221 *en50221,\n\t\t\t\t  int slot, u8 addr)\n{\n\treturn altera_ci_op_cam(en50221, slot, NETUP_CI_FLG_CTL,\n\t\t\t\t\t\tNETUP_CI_FLG_RD, addr, 0);\n}\n\nstatic int altera_ci_write_cam_ctl(struct dvb_ca_en50221 *en50221, int slot,\n\t\t\t\t   u8 addr, u8 data)\n{\n\treturn altera_ci_op_cam(en50221, slot, NETUP_CI_FLG_CTL, 0, addr, data);\n}\n\nstatic int altera_ci_slot_reset(struct dvb_ca_en50221 *en50221, int slot)\n{\n\tstruct altera_ci_state *state = en50221->data;\n\tstruct fpga_internal *inter = state->internal;\n\t \n\tunsigned long t_out = jiffies + msecs_to_jiffies(9999);\n\tint ret;\n\n\tci_dbg_print(\"%s\\n\", __func__);\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&inter->fpga_mutex);\n\n\tret = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL, 0, NETUP_CI_FLG_RD);\n\tnetup_fpga_op_rw(inter, NETUP_CI_BUSCTRL,\n\t\t\t\t(ret & 0xcf) | (1 << (5 - state->nr)), 0);\n\n\tmutex_unlock(&inter->fpga_mutex);\n\n\tfor (;;) {\n\t\tmsleep(50);\n\n\t\tmutex_lock(&inter->fpga_mutex);\n\n\t\tret = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL,\n\t\t\t\t\t\t0, NETUP_CI_FLG_RD);\n\t\tmutex_unlock(&inter->fpga_mutex);\n\n\t\tif ((ret & (1 << (5 - state->nr))) == 0)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, t_out))\n\t\t\tbreak;\n\t}\n\n\n\tci_dbg_print(\"%s: %d msecs\\n\", __func__,\n\t\tjiffies_to_msecs(jiffies + msecs_to_jiffies(9999) - t_out));\n\n\treturn 0;\n}\n\nstatic int altera_ci_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)\n{\n\t \n\treturn 0;\n}\n\nstatic int altera_ci_slot_ts_ctl(struct dvb_ca_en50221 *en50221, int slot)\n{\n\tstruct altera_ci_state *state = en50221->data;\n\tstruct fpga_internal *inter = state->internal;\n\tint ret;\n\n\tci_dbg_print(\"%s\\n\", __func__);\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&inter->fpga_mutex);\n\n\tret = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL, 0, NETUP_CI_FLG_RD);\n\tnetup_fpga_op_rw(inter, NETUP_CI_BUSCTRL,\n\t\t\t\t(ret & 0x0f) | (1 << (3 - state->nr)), 0);\n\n\tmutex_unlock(&inter->fpga_mutex);\n\n\treturn 0;\n}\n\n \nstatic void netup_read_ci_status(struct work_struct *work)\n{\n\tstruct fpga_internal *inter =\n\t\t\tcontainer_of(work, struct fpga_internal, work);\n\tint ret;\n\n\tci_dbg_print(\"%s\\n\", __func__);\n\n\tmutex_lock(&inter->fpga_mutex);\n\t \n\tret = netup_fpga_op_rw(inter, NETUP_CI_INT_CTRL, 0, NETUP_CI_FLG_RD);\n\tret = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL, 0, NETUP_CI_FLG_RD);\n\n\tmutex_unlock(&inter->fpga_mutex);\n\n\tif (inter->state[1] != NULL) {\n\t\tinter->state[1]->status =\n\t\t\t\t((ret & 1) == 0 ?\n\t\t\t\tDVB_CA_EN50221_POLL_CAM_PRESENT |\n\t\t\t\tDVB_CA_EN50221_POLL_CAM_READY : 0);\n\t\tci_dbg_print(\"%s: setting CI[1] status = 0x%x\\n\",\n\t\t\t\t__func__, inter->state[1]->status);\n\t}\n\n\tif (inter->state[0] != NULL) {\n\t\tinter->state[0]->status =\n\t\t\t\t((ret & 2) == 0 ?\n\t\t\t\tDVB_CA_EN50221_POLL_CAM_PRESENT |\n\t\t\t\tDVB_CA_EN50221_POLL_CAM_READY : 0);\n\t\tci_dbg_print(\"%s: setting CI[0] status = 0x%x\\n\",\n\t\t\t\t__func__, inter->state[0]->status);\n\t}\n}\n\n \nint altera_ci_irq(void *dev)\n{\n\tstruct fpga_inode *temp_int = NULL;\n\tstruct fpga_internal *inter = NULL;\n\n\tci_dbg_print(\"%s\\n\", __func__);\n\n\tif (dev != NULL) {\n\t\ttemp_int = find_inode(dev);\n\t\tif (temp_int != NULL) {\n\t\t\tinter = temp_int->internal;\n\t\t\tschedule_work(&inter->work);\n\t\t}\n\t}\n\n\treturn 1;\n}\nEXPORT_SYMBOL(altera_ci_irq);\n\nstatic int altera_poll_ci_slot_status(struct dvb_ca_en50221 *en50221,\n\t\t\t\t      int slot, int open)\n{\n\tstruct altera_ci_state *state = en50221->data;\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\treturn state->status;\n}\n\nstatic void altera_hw_filt_release(void *main_dev, int filt_nr)\n{\n\tstruct fpga_inode *temp_int = find_inode(main_dev);\n\tstruct netup_hw_pid_filter *pid_filt = NULL;\n\n\tci_dbg_print(\"%s\\n\", __func__);\n\n\tif (temp_int != NULL) {\n\t\tpid_filt = temp_int->internal->pid_filt[filt_nr - 1];\n\t\t \n\t\tpid_filt->demux->start_feed = pid_filt->start_feed;\n\t\tpid_filt->demux->stop_feed = pid_filt->stop_feed;\n\n\t\tif (((--(temp_int->internal->filts_used)) <= 0) &&\n\t\t\t ((temp_int->internal->cis_used) <= 0)) {\n\n\t\t\tci_dbg_print(\"%s: Actually removing\\n\", __func__);\n\n\t\t\tremove_inode(temp_int->internal);\n\t\t\tkfree(pid_filt->internal);\n\t\t}\n\n\t\tkfree(pid_filt);\n\n\t}\n\n}\n\nvoid altera_ci_release(void *dev, int ci_nr)\n{\n\tstruct fpga_inode *temp_int = find_inode(dev);\n\tstruct altera_ci_state *state = NULL;\n\n\tci_dbg_print(\"%s\\n\", __func__);\n\n\tif (temp_int != NULL) {\n\t\tstate = temp_int->internal->state[ci_nr - 1];\n\t\taltera_hw_filt_release(dev, ci_nr);\n\n\n\t\tif (((temp_int->internal->filts_used) <= 0) &&\n\t\t\t\t((--(temp_int->internal->cis_used)) <= 0)) {\n\n\t\t\tci_dbg_print(\"%s: Actually removing\\n\", __func__);\n\n\t\t\tremove_inode(temp_int->internal);\n\t\t\tkfree(state->internal);\n\t\t}\n\n\t\tif (state != NULL) {\n\t\t\tif (state->ca.data != NULL)\n\t\t\t\tdvb_ca_en50221_release(&state->ca);\n\n\t\t\tkfree(state);\n\t\t}\n\t}\n\n}\nEXPORT_SYMBOL(altera_ci_release);\n\nstatic void altera_pid_control(struct netup_hw_pid_filter *pid_filt,\n\t\tu16 pid, int onoff)\n{\n\tstruct fpga_internal *inter = pid_filt->internal;\n\tu8 store = 0;\n\n\t \n\tif ((pid == 0x2000) || (pid < 0x20))\n\t\treturn;\n\n\tmutex_lock(&inter->fpga_mutex);\n\n\tnetup_fpga_op_rw(inter, NETUP_CI_PID_ADDR0, (pid >> 3) & 0xff, 0);\n\tnetup_fpga_op_rw(inter, NETUP_CI_PID_ADDR1,\n\t\t\t((pid >> 11) & 0x03) | (pid_filt->nr << 2), 0);\n\n\tstore = netup_fpga_op_rw(inter, NETUP_CI_PID_DATA, 0, NETUP_CI_FLG_RD);\n\n\tif (onoff) \n\t\tstore |= (1 << (pid & 7));\n\telse\n\t\tstore &= ~(1 << (pid & 7));\n\n\tnetup_fpga_op_rw(inter, NETUP_CI_PID_DATA, store, 0);\n\n\tmutex_unlock(&inter->fpga_mutex);\n\n\tpid_dbg_print(\"%s: (%d) set pid: %5d 0x%04x '%s'\\n\", __func__,\n\t\tpid_filt->nr, pid, pid, onoff ? \"off\" : \"on\");\n}\n\nstatic void altera_toggle_fullts_streaming(struct netup_hw_pid_filter *pid_filt,\n\t\t\t\t\tint filt_nr, int onoff)\n{\n\tstruct fpga_internal *inter = pid_filt->internal;\n\tu8 store = 0;\n\tint i;\n\n\tpid_dbg_print(\"%s: pid_filt->nr[%d]  now %s\\n\", __func__, pid_filt->nr,\n\t\t\tonoff ? \"off\" : \"on\");\n\n\tif (onoff) \n\t\tstore = 0xff; \n\telse\n\t\tstore = 0; \n\n\tmutex_lock(&inter->fpga_mutex);\n\n\tfor (i = 0; i < 1024; i++) {\n\t\tnetup_fpga_op_rw(inter, NETUP_CI_PID_ADDR0, i & 0xff, 0);\n\n\t\tnetup_fpga_op_rw(inter, NETUP_CI_PID_ADDR1,\n\t\t\t\t((i >> 8) & 0x03) | (pid_filt->nr << 2), 0);\n\t\t \n\t\tnetup_fpga_op_rw(inter, NETUP_CI_PID_DATA,\n\t\t\t\t(i > 3 ? store : 0), 0);\n\t}\n\n\tmutex_unlock(&inter->fpga_mutex);\n}\n\nstatic int altera_pid_feed_control(void *demux_dev, int filt_nr,\n\t\tstruct dvb_demux_feed *feed, int onoff)\n{\n\tstruct fpga_inode *temp_int = find_dinode(demux_dev);\n\tstruct fpga_internal *inter = temp_int->internal;\n\tstruct netup_hw_pid_filter *pid_filt = inter->pid_filt[filt_nr - 1];\n\n\taltera_pid_control(pid_filt, feed->pid, onoff ? 0 : 1);\n\t \n\tif (onoff)\n\t\tpid_filt->start_feed(feed);\n\telse\n\t\tpid_filt->stop_feed(feed);\n\n\tif (feed->pid == 0x2000)\n\t\taltera_toggle_fullts_streaming(pid_filt, filt_nr,\n\t\t\t\t\t\tonoff ? 0 : 1);\n\n\treturn 0;\n}\n\nstatic int altera_ci_start_feed(struct dvb_demux_feed *feed, int num)\n{\n\taltera_pid_feed_control(feed->demux, num, feed, 1);\n\n\treturn 0;\n}\n\nstatic int altera_ci_stop_feed(struct dvb_demux_feed *feed, int num)\n{\n\taltera_pid_feed_control(feed->demux, num, feed, 0);\n\n\treturn 0;\n}\n\nstatic int altera_ci_start_feed_1(struct dvb_demux_feed *feed)\n{\n\treturn altera_ci_start_feed(feed, 1);\n}\n\nstatic int altera_ci_stop_feed_1(struct dvb_demux_feed *feed)\n{\n\treturn altera_ci_stop_feed(feed, 1);\n}\n\nstatic int altera_ci_start_feed_2(struct dvb_demux_feed *feed)\n{\n\treturn altera_ci_start_feed(feed, 2);\n}\n\nstatic int altera_ci_stop_feed_2(struct dvb_demux_feed *feed)\n{\n\treturn altera_ci_stop_feed(feed, 2);\n}\n\nstatic int altera_hw_filt_init(struct altera_ci_config *config, int hw_filt_nr)\n{\n\tstruct netup_hw_pid_filter *pid_filt = NULL;\n\tstruct fpga_inode *temp_int = find_inode(config->dev);\n\tstruct fpga_internal *inter = NULL;\n\tint ret = 0;\n\n\tpid_filt = kzalloc(sizeof(struct netup_hw_pid_filter), GFP_KERNEL);\n\n\tci_dbg_print(\"%s\\n\", __func__);\n\n\tif (!pid_filt) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tif (temp_int != NULL) {\n\t\tinter = temp_int->internal;\n\t\t(inter->filts_used)++;\n\t\tci_dbg_print(\"%s: Find Internal Structure!\\n\", __func__);\n\t} else {\n\t\tinter = kzalloc(sizeof(struct fpga_internal), GFP_KERNEL);\n\t\tif (!inter) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\ttemp_int = append_internal(inter);\n\t\tif (!temp_int) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tinter->filts_used = 1;\n\t\tinter->dev = config->dev;\n\t\tinter->fpga_rw = config->fpga_rw;\n\t\tmutex_init(&inter->fpga_mutex);\n\t\tinter->strt_wrk = 1;\n\t\tci_dbg_print(\"%s: Create New Internal Structure!\\n\", __func__);\n\t}\n\n\tci_dbg_print(\"%s: setting hw pid filter = %p for ci = %d\\n\", __func__,\n\t\t\t\t\t\tpid_filt, hw_filt_nr - 1);\n\tinter->pid_filt[hw_filt_nr - 1] = pid_filt;\n\tpid_filt->demux = config->demux;\n\tpid_filt->internal = inter;\n\tpid_filt->nr = hw_filt_nr - 1;\n\t \n\tpid_filt->start_feed = config->demux->start_feed;\n\tpid_filt->stop_feed = config->demux->stop_feed;\n\t \n\tif (hw_filt_nr == 1) {\n\t\tpid_filt->demux->start_feed = altera_ci_start_feed_1;\n\t\tpid_filt->demux->stop_feed = altera_ci_stop_feed_1;\n\t} else if (hw_filt_nr == 2) {\n\t\tpid_filt->demux->start_feed = altera_ci_start_feed_2;\n\t\tpid_filt->demux->stop_feed = altera_ci_stop_feed_2;\n\t}\n\n\taltera_toggle_fullts_streaming(pid_filt, 0, 1);\n\n\treturn 0;\nerr:\n\tci_dbg_print(\"%s: Can't init hardware filter: Error %d\\n\",\n\t\t     __func__, ret);\n\n\tkfree(pid_filt);\n\tkfree(inter);\n\n\treturn ret;\n}\n\nint altera_ci_init(struct altera_ci_config *config, int ci_nr)\n{\n\tstruct altera_ci_state *state;\n\tstruct fpga_inode *temp_int = find_inode(config->dev);\n\tstruct fpga_internal *inter = NULL;\n\tint ret = 0;\n\tu8 store = 0;\n\n\tstate = kzalloc(sizeof(struct altera_ci_state), GFP_KERNEL);\n\n\tci_dbg_print(\"%s\\n\", __func__);\n\n\tif (!state) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tif (temp_int != NULL) {\n\t\tinter = temp_int->internal;\n\t\t(inter->cis_used)++;\n\t\tinter->fpga_rw = config->fpga_rw;\n\t\tci_dbg_print(\"%s: Find Internal Structure!\\n\", __func__);\n\t} else {\n\t\tinter = kzalloc(sizeof(struct fpga_internal), GFP_KERNEL);\n\t\tif (!inter) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\ttemp_int = append_internal(inter);\n\t\tif (!temp_int) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tinter->cis_used = 1;\n\t\tinter->dev = config->dev;\n\t\tinter->fpga_rw = config->fpga_rw;\n\t\tmutex_init(&inter->fpga_mutex);\n\t\tinter->strt_wrk = 1;\n\t\tci_dbg_print(\"%s: Create New Internal Structure!\\n\", __func__);\n\t}\n\n\tci_dbg_print(\"%s: setting state = %p for ci = %d\\n\", __func__,\n\t\t\t\t\t\tstate, ci_nr - 1);\n\tstate->internal = inter;\n\tstate->nr = ci_nr - 1;\n\n\tstate->ca.owner = THIS_MODULE;\n\tstate->ca.read_attribute_mem = altera_ci_read_attribute_mem;\n\tstate->ca.write_attribute_mem = altera_ci_write_attribute_mem;\n\tstate->ca.read_cam_control = altera_ci_read_cam_ctl;\n\tstate->ca.write_cam_control = altera_ci_write_cam_ctl;\n\tstate->ca.slot_reset = altera_ci_slot_reset;\n\tstate->ca.slot_shutdown = altera_ci_slot_shutdown;\n\tstate->ca.slot_ts_enable = altera_ci_slot_ts_ctl;\n\tstate->ca.poll_slot_status = altera_poll_ci_slot_status;\n\tstate->ca.data = state;\n\n\tret = dvb_ca_en50221_init(config->adapter,\n\t\t\t\t   &state->ca,\n\t\t\t\t     0,\n\t\t\t\t     1);\n\tif (0 != ret)\n\t\tgoto err;\n\n\tinter->state[ci_nr - 1] = state;\n\n\taltera_hw_filt_init(config, ci_nr);\n\n\tif (inter->strt_wrk) {\n\t\tINIT_WORK(&inter->work, netup_read_ci_status);\n\t\tinter->strt_wrk = 0;\n\t}\n\n\tci_dbg_print(\"%s: CI initialized!\\n\", __func__);\n\n\tmutex_lock(&inter->fpga_mutex);\n\n\t \n\tnetup_fpga_op_rw(inter, NETUP_CI_TSA_DIV, 0x0, 0);\n\tnetup_fpga_op_rw(inter, NETUP_CI_TSB_DIV, 0x0, 0);\n\n\t \n\tstore = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL2, 0, NETUP_CI_FLG_RD);\n\tstore |= (3 << 4);\n\tnetup_fpga_op_rw(inter, NETUP_CI_BUSCTRL2, store, 0);\n\n\tret = netup_fpga_op_rw(inter, NETUP_CI_REVISION, 0, NETUP_CI_FLG_RD);\n\t \n\tnetup_fpga_op_rw(inter, NETUP_CI_INT_CTRL, 0x44, 0);\n\n\tmutex_unlock(&inter->fpga_mutex);\n\n\tci_dbg_print(\"%s: NetUP CI Revision = 0x%x\\n\", __func__, ret);\n\n\tschedule_work(&inter->work);\n\n\treturn 0;\nerr:\n\tci_dbg_print(\"%s: Cannot initialize CI: Error %d.\\n\", __func__, ret);\n\n\tkfree(state);\n\tkfree(inter);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(altera_ci_init);\n\nint altera_ci_tuner_reset(void *dev, int ci_nr)\n{\n\tstruct fpga_inode *temp_int = find_inode(dev);\n\tstruct fpga_internal *inter = NULL;\n\tu8 store;\n\n\tci_dbg_print(\"%s\\n\", __func__);\n\n\tif (temp_int == NULL)\n\t\treturn -1;\n\n\tif (temp_int->internal == NULL)\n\t\treturn -1;\n\n\tinter = temp_int->internal;\n\n\tmutex_lock(&inter->fpga_mutex);\n\n\tstore = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL2, 0, NETUP_CI_FLG_RD);\n\tstore &= ~(4 << (2 - ci_nr));\n\tnetup_fpga_op_rw(inter, NETUP_CI_BUSCTRL2, store, 0);\n\tmsleep(100);\n\tstore |= (4 << (2 - ci_nr));\n\tnetup_fpga_op_rw(inter, NETUP_CI_BUSCTRL2, store, 0);\n\n\tmutex_unlock(&inter->fpga_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(altera_ci_tuner_reset);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}