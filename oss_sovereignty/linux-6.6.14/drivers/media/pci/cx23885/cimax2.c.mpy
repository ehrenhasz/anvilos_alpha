{
  "module_name": "cimax2.c",
  "hash_id": "2a29e05c2121d12be9a16b188c560cf6dc1baa3bf02d6fe1af0a2044bf1bb103",
  "original_prompt": "Ingested from linux-6.6.14/drivers/media/pci/cx23885/cimax2.c",
  "human_readable_source": "\n \n\n#include \"cx23885.h\"\n#include \"cimax2.h\"\n#include <media/dvb_ca_en50221.h>\n\n \n#define MAX_XFER_SIZE  64\n\n \n \n#define NETUP_DATA\t\t0x000000ff\n#define NETUP_WR\t\t0x00008000\n#define NETUP_RD\t\t0x00004000\n#define NETUP_ACK\t\t0x00001000\n#define NETUP_ADHI\t\t0x00000800\n#define NETUP_ADLO\t\t0x00000400\n#define NETUP_CS1\t\t0x00000200\n#define NETUP_CS0\t\t0x00000100\n#define NETUP_EN_ALL\t\t0x00001000\n#define NETUP_CTRL_OFF\t\t(NETUP_CS1 | NETUP_CS0 | NETUP_WR | NETUP_RD)\n#define NETUP_CI_CTL\t\t0x04\n#define NETUP_CI_RD\t\t1\n\n#define NETUP_IRQ_DETAM\t\t0x1\n#define NETUP_IRQ_IRQAM\t\t0x4\n\nstatic unsigned int ci_dbg;\nmodule_param(ci_dbg, int, 0644);\nMODULE_PARM_DESC(ci_dbg, \"Enable CI debugging\");\n\nstatic unsigned int ci_irq_enable;\nmodule_param(ci_irq_enable, int, 0644);\nMODULE_PARM_DESC(ci_irq_enable, \"Enable IRQ from CAM\");\n\n#define ci_dbg_print(fmt, args...) \\\n\tdo { \\\n\t\tif (ci_dbg) \\\n\t\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" fmt), \\\n\t\t\t       __func__, ##args); \\\n\t} while (0)\n\n#define ci_irq_flags() (ci_irq_enable ? NETUP_IRQ_IRQAM : 0)\n\n \nstruct netup_ci_state {\n\tstruct dvb_ca_en50221 ca;\n\tstruct mutex ca_mutex;\n\tstruct i2c_adapter *i2c_adap;\n\tu8 ci_i2c_addr;\n\tint status;\n\tstruct work_struct work;\n\tvoid *priv;\n\tu8 current_irq_mode;\n\tint current_ci_flag;\n\tunsigned long next_status_checked_time;\n};\n\n\nstatic int netup_read_i2c(struct i2c_adapter *i2c_adap, u8 addr, u8 reg,\n\t\t\t\t\t\tu8 *buf, int len)\n{\n\tint ret;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= addr,\n\t\t\t.flags\t= 0,\n\t\t\t.buf\t= &reg,\n\t\t\t.len\t= 1\n\t\t}, {\n\t\t\t.addr\t= addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.buf\t= buf,\n\t\t\t.len\t= len\n\t\t}\n\t};\n\n\tret = i2c_transfer(i2c_adap, msg, 2);\n\n\tif (ret != 2) {\n\t\tci_dbg_print(\"%s: i2c read error, Reg = 0x%02x, Status = %d\\n\",\n\t\t\t\t\t\t__func__, reg, ret);\n\n\t\treturn -1;\n\t}\n\n\tci_dbg_print(\"%s: i2c read Addr=0x%04x, Reg = 0x%02x, data = %02x\\n\",\n\t\t\t\t\t\t__func__, addr, reg, buf[0]);\n\n\treturn 0;\n}\n\nstatic int netup_write_i2c(struct i2c_adapter *i2c_adap, u8 addr, u8 reg,\n\t\t\t\t\t\tu8 *buf, int len)\n{\n\tint ret;\n\tu8 buffer[MAX_XFER_SIZE];\n\n\tstruct i2c_msg msg = {\n\t\t.addr\t= addr,\n\t\t.flags\t= 0,\n\t\t.buf\t= &buffer[0],\n\t\t.len\t= len + 1\n\t};\n\n\tif (1 + len > sizeof(buffer)) {\n\t\tpr_warn(\"%s: i2c wr reg=%04x: len=%d is too big!\\n\",\n\t\t       KBUILD_MODNAME, reg, len);\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer[0] = reg;\n\tmemcpy(&buffer[1], buf, len);\n\n\tret = i2c_transfer(i2c_adap, &msg, 1);\n\n\tif (ret != 1) {\n\t\tci_dbg_print(\"%s: i2c write error, Reg=[0x%02x], Status=%d\\n\",\n\t\t\t\t\t\t__func__, reg, ret);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int netup_ci_get_mem(struct cx23885_dev *dev)\n{\n\tint mem;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1);\n\n\tfor (;;) {\n\t\tmem = cx_read(MC417_RWD);\n\t\tif ((mem & NETUP_ACK) == 0)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tcx_set(MC417_RWD, NETUP_CTRL_OFF);\n\n\treturn mem & 0xff;\n}\n\nstatic int netup_ci_op_cam(struct dvb_ca_en50221 *en50221, int slot,\n\t\t\t\tu8 flag, u8 read, int addr, u8 data)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\tstruct cx23885_tsport *port = state->priv;\n\tstruct cx23885_dev *dev = port->dev;\n\n\tu8 store;\n\tint mem;\n\tint ret;\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tif (state->current_ci_flag != flag) {\n\t\tret = netup_read_i2c(state->i2c_adap, state->ci_i2c_addr,\n\t\t\t\t0, &store, 1);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tstore &= ~0x0c;\n\t\tstore |= flag;\n\n\t\tret = netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\n\t\t\t\t0, &store, 1);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\tstate->current_ci_flag = flag;\n\n\tmutex_lock(&dev->gpio_lock);\n\n\t \n\tcx_write(MC417_OEN, NETUP_EN_ALL);\n\tcx_write(MC417_RWD, NETUP_CTRL_OFF |\n\t\t\t\tNETUP_ADLO | (0xff & addr));\n\tcx_clear(MC417_RWD, NETUP_ADLO);\n\tcx_write(MC417_RWD, NETUP_CTRL_OFF |\n\t\t\t\tNETUP_ADHI | (0xff & (addr >> 8)));\n\tcx_clear(MC417_RWD, NETUP_ADHI);\n\n\tif (read) {  \n\t\tcx_write(MC417_OEN, NETUP_EN_ALL | NETUP_DATA);\n\t} else  \n\t\tcx_write(MC417_RWD, NETUP_CTRL_OFF | data);\n\n\t \n\tcx_clear(MC417_RWD,\n\t\t\t(state->ci_i2c_addr == 0x40) ? NETUP_CS0 : NETUP_CS1);\n\t \n\tcx_clear(MC417_RWD, (read) ? NETUP_RD : NETUP_WR);\n\tmem = netup_ci_get_mem(dev);\n\n\tmutex_unlock(&dev->gpio_lock);\n\n\tif (!read)\n\t\tif (mem < 0)\n\t\t\treturn -EREMOTEIO;\n\n\tci_dbg_print(\"%s: %s: chipaddr=[0x%x] addr=[0x%02x], %s=%x\\n\", __func__,\n\t\t\t(read) ? \"read\" : \"write\", state->ci_i2c_addr, addr,\n\t\t\t(flag == NETUP_CI_CTL) ? \"ctl\" : \"mem\",\n\t\t\t(read) ? mem : data);\n\n\tif (read)\n\t\treturn mem;\n\n\treturn 0;\n}\n\nint netup_ci_read_attribute_mem(struct dvb_ca_en50221 *en50221,\n\t\t\t\t\t\tint slot, int addr)\n{\n\treturn netup_ci_op_cam(en50221, slot, 0, NETUP_CI_RD, addr, 0);\n}\n\nint netup_ci_write_attribute_mem(struct dvb_ca_en50221 *en50221,\n\t\t\t\t\t\tint slot, int addr, u8 data)\n{\n\treturn netup_ci_op_cam(en50221, slot, 0, 0, addr, data);\n}\n\nint netup_ci_read_cam_ctl(struct dvb_ca_en50221 *en50221, int slot,\n\t\t\t\t u8 addr)\n{\n\treturn netup_ci_op_cam(en50221, slot, NETUP_CI_CTL,\n\t\t\t\t\t\t\tNETUP_CI_RD, addr, 0);\n}\n\nint netup_ci_write_cam_ctl(struct dvb_ca_en50221 *en50221, int slot,\n\t\t\t\t\t\t\tu8 addr, u8 data)\n{\n\treturn netup_ci_op_cam(en50221, slot, NETUP_CI_CTL, 0, addr, data);\n}\n\nint netup_ci_slot_reset(struct dvb_ca_en50221 *en50221, int slot)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\tu8 buf =  0x80;\n\tint ret;\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tudelay(500);\n\tret = netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\n\t\t\t\t\t\t\t0, &buf, 1);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tudelay(500);\n\n\tbuf = 0x00;\n\tret = netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\n\t\t\t\t\t\t\t0, &buf, 1);\n\n\tmsleep(1000);\n\tdvb_ca_en50221_camready_irq(&state->ca, 0);\n\n\treturn 0;\n\n}\n\nint netup_ci_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)\n{\n\t \n\treturn 0;\n}\n\nstatic int netup_ci_set_irq(struct dvb_ca_en50221 *en50221, u8 irq_mode)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\tint ret;\n\n\tif (irq_mode == state->current_irq_mode)\n\t\treturn 0;\n\n\tci_dbg_print(\"%s: chipaddr=[0x%x] setting ci IRQ to [0x%x] \\n\",\n\t\t\t__func__, state->ci_i2c_addr, irq_mode);\n\tret = netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\n\t\t\t\t\t\t\t0x1b, &irq_mode, 1);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tstate->current_irq_mode = irq_mode;\n\n\treturn 0;\n}\n\nint netup_ci_slot_ts_ctl(struct dvb_ca_en50221 *en50221, int slot)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\tu8 buf;\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tnetup_read_i2c(state->i2c_adap, state->ci_i2c_addr,\n\t\t\t0, &buf, 1);\n\tbuf |= 0x60;\n\n\treturn netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\n\t\t\t\t\t\t\t0, &buf, 1);\n}\n\n \nstatic void netup_read_ci_status(struct work_struct *work)\n{\n\tstruct netup_ci_state *state =\n\t\t\tcontainer_of(work, struct netup_ci_state, work);\n\tu8 buf[33];\n\tint ret;\n\n\t \n\tdvb_ca_en50221_frda_irq(&state->ca, 0);\n\n\t \n\tif (time_after(jiffies, state->next_status_checked_time)\n\t\t\t|| !state->status) {\n\t\tret = netup_read_i2c(state->i2c_adap, state->ci_i2c_addr,\n\t\t\t\t0, &buf[0], 33);\n\n\t\tstate->next_status_checked_time = jiffies\n\t\t\t+ msecs_to_jiffies(1000);\n\n\t\tif (ret != 0)\n\t\t\treturn;\n\n\t\tci_dbg_print(\"%s: Slot Status Addr=[0x%04x], Reg=[0x%02x], data=%02x, TS config = %02x\\n\",\n\t\t\t     __func__,\tstate->ci_i2c_addr, 0, buf[0], buf[0]);\n\n\n\t\tif (buf[0] & 1)\n\t\t\tstate->status = DVB_CA_EN50221_POLL_CAM_PRESENT |\n\t\t\t\tDVB_CA_EN50221_POLL_CAM_READY;\n\t\telse\n\t\t\tstate->status = 0;\n\t}\n}\n\n \nint netup_ci_slot_status(struct cx23885_dev *dev, u32 pci_status)\n{\n\tstruct cx23885_tsport *port = NULL;\n\tstruct netup_ci_state *state = NULL;\n\n\tci_dbg_print(\"%s:\\n\", __func__);\n\n\tif (0 == (pci_status & (PCI_MSK_GPIO0 | PCI_MSK_GPIO1)))\n\t\treturn 0;\n\n\tif (pci_status & PCI_MSK_GPIO0) {\n\t\tport = &dev->ts1;\n\t\tstate = port->port_priv;\n\t\tschedule_work(&state->work);\n\t\tci_dbg_print(\"%s: Wakeup CI0\\n\", __func__);\n\t}\n\n\tif (pci_status & PCI_MSK_GPIO1) {\n\t\tport = &dev->ts2;\n\t\tstate = port->port_priv;\n\t\tschedule_work(&state->work);\n\t\tci_dbg_print(\"%s: Wakeup CI1\\n\", __func__);\n\t}\n\n\treturn 1;\n}\n\nint netup_poll_ci_slot_status(struct dvb_ca_en50221 *en50221,\n\t\t\t\t     int slot, int open)\n{\n\tstruct netup_ci_state *state = en50221->data;\n\n\tif (0 != slot)\n\t\treturn -EINVAL;\n\n\tnetup_ci_set_irq(en50221, open ? (NETUP_IRQ_DETAM | ci_irq_flags())\n\t\t\t: NETUP_IRQ_DETAM);\n\n\treturn state->status;\n}\n\nint netup_ci_init(struct cx23885_tsport *port)\n{\n\tstruct netup_ci_state *state;\n\tu8 cimax_init[34] = {\n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x44,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x44,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x00,  \n\t\t0x02,  \n\t\t0x01,  \n\t\t0x00,  \n\t\t0x00,  \n\t\tci_irq_flags() | NETUP_IRQ_DETAM,  \n\t\t0x05,  \n\t\t0x00,  \n\t\t0x04,  \n\t\t0x00,  \n\t\t0x33,  \n\t\t0x31,  \n\t};\n\tint ret;\n\n\tci_dbg_print(\"%s\\n\", __func__);\n\tstate = kzalloc(sizeof(struct netup_ci_state), GFP_KERNEL);\n\tif (!state) {\n\t\tci_dbg_print(\"%s: Unable create CI structure!\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tport->port_priv = state;\n\n\tswitch (port->nr) {\n\tcase 1:\n\t\tstate->ci_i2c_addr = 0x40;\n\t\tbreak;\n\tcase 2:\n\t\tstate->ci_i2c_addr = 0x41;\n\t\tbreak;\n\t}\n\n\tstate->i2c_adap = &port->dev->i2c_bus[0].i2c_adap;\n\tstate->ca.owner = THIS_MODULE;\n\tstate->ca.read_attribute_mem = netup_ci_read_attribute_mem;\n\tstate->ca.write_attribute_mem = netup_ci_write_attribute_mem;\n\tstate->ca.read_cam_control = netup_ci_read_cam_ctl;\n\tstate->ca.write_cam_control = netup_ci_write_cam_ctl;\n\tstate->ca.slot_reset = netup_ci_slot_reset;\n\tstate->ca.slot_shutdown = netup_ci_slot_shutdown;\n\tstate->ca.slot_ts_enable = netup_ci_slot_ts_ctl;\n\tstate->ca.poll_slot_status = netup_poll_ci_slot_status;\n\tstate->ca.data = state;\n\tstate->priv = port;\n\tstate->current_irq_mode = ci_irq_flags() | NETUP_IRQ_DETAM;\n\n\tret = netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\n\t\t\t\t\t\t0, &cimax_init[0], 34);\n\t \n\tret |= netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\n\t\t\t\t\t\t0x1f, &cimax_init[0x18], 1);\n\t \n\tret |= netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\n\t\t\t\t\t\t0x18, &cimax_init[0x18], 1);\n\n\tif (0 != ret)\n\t\tgoto err;\n\n\tret = dvb_ca_en50221_init(&port->frontends.adapter,\n\t\t\t\t   &state->ca,\n\t\t\t\t     0,\n\t\t\t\t     1);\n\tif (0 != ret)\n\t\tgoto err;\n\n\tINIT_WORK(&state->work, netup_read_ci_status);\n\tschedule_work(&state->work);\n\n\tci_dbg_print(\"%s: CI initialized!\\n\", __func__);\n\n\treturn 0;\nerr:\n\tci_dbg_print(\"%s: Cannot initialize CI: Error %d.\\n\", __func__, ret);\n\tkfree(state);\n\treturn ret;\n}\n\nvoid netup_ci_exit(struct cx23885_tsport *port)\n{\n\tstruct netup_ci_state *state;\n\n\tif (NULL == port)\n\t\treturn;\n\n\tstate = (struct netup_ci_state *)port->port_priv;\n\tif (NULL == state)\n\t\treturn;\n\n\tif (NULL == state->ca.data)\n\t\treturn;\n\n\tdvb_ca_en50221_release(&state->ca);\n\tkfree(state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}